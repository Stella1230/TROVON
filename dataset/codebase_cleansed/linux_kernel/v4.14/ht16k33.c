static int ht16k33_display_on(struct ht16k33_priv *priv)\r\n{\r\nuint8_t data = REG_DISPLAY_SETUP | REG_DISPLAY_SETUP_ON;\r\nreturn i2c_smbus_write_byte(priv->client, data);\r\n}\r\nstatic int ht16k33_display_off(struct ht16k33_priv *priv)\r\n{\r\nreturn i2c_smbus_write_byte(priv->client, REG_DISPLAY_SETUP);\r\n}\r\nstatic void ht16k33_fb_queue(struct ht16k33_priv *priv)\r\n{\r\nstruct ht16k33_fbdev *fbdev = &priv->fbdev;\r\nschedule_delayed_work(&fbdev->work,\r\nmsecs_to_jiffies(HZ / fbdev->refresh_rate));\r\n}\r\nstatic void ht16k33_fb_update(struct work_struct *work)\r\n{\r\nstruct ht16k33_fbdev *fbdev =\r\ncontainer_of(work, struct ht16k33_fbdev, work.work);\r\nstruct ht16k33_priv *priv =\r\ncontainer_of(fbdev, struct ht16k33_priv, fbdev);\r\nuint8_t *p1, *p2;\r\nint len, pos = 0, first = -1;\r\np1 = fbdev->cache;\r\np2 = fbdev->buffer;\r\nwhile (pos < HT16K33_FB_SIZE && first < 0) {\r\nif (*(p1++) - *(p2++))\r\nfirst = pos;\r\npos++;\r\n}\r\nif (first < 0)\r\ngoto requeue;\r\nlen = HT16K33_FB_SIZE - first;\r\np1 = fbdev->cache + HT16K33_FB_SIZE - 1;\r\np2 = fbdev->buffer + HT16K33_FB_SIZE - 1;\r\nwhile (len > 1) {\r\nif (*(p1--) - *(p2--))\r\nbreak;\r\nlen--;\r\n}\r\np1 = fbdev->cache + first;\r\np2 = fbdev->buffer + first;\r\nif (!i2c_smbus_write_i2c_block_data(priv->client, first, len, p2))\r\nmemcpy(p1, p2, len);\r\nrequeue:\r\nht16k33_fb_queue(priv);\r\n}\r\nstatic int ht16k33_initialize(struct ht16k33_priv *priv)\r\n{\r\nuint8_t byte;\r\nint err;\r\nuint8_t data[HT16K33_MATRIX_LED_MAX_COLS * 2];\r\nmemset(data, 0, sizeof(data));\r\nerr = i2c_smbus_write_block_data(priv->client, 0, sizeof(data), data);\r\nif (err)\r\nreturn err;\r\nbyte = REG_SYSTEM_SETUP_OSC_ON | REG_SYSTEM_SETUP;\r\nerr = i2c_smbus_write_byte(priv->client, byte);\r\nif (err)\r\nreturn err;\r\nbyte = REG_ROWINT_SET | REG_ROWINT_SET_INT_ACT_HIGH;\r\nif (priv->client->irq > 0)\r\nbyte |= REG_ROWINT_SET_INT_EN;\r\nreturn i2c_smbus_write_byte(priv->client, byte);\r\n}\r\nstatic int ht16k33_bl_update_status(struct backlight_device *bl)\r\n{\r\nint brightness = bl->props.brightness;\r\nstruct ht16k33_priv *priv = bl_get_data(bl);\r\nif (bl->props.power != FB_BLANK_UNBLANK ||\r\nbl->props.fb_blank != FB_BLANK_UNBLANK ||\r\nbl->props.state & BL_CORE_FBBLANK || brightness == 0) {\r\nreturn ht16k33_display_off(priv);\r\n}\r\nht16k33_display_on(priv);\r\nreturn i2c_smbus_write_byte(priv->client,\r\nREG_BRIGHTNESS | (brightness - 1));\r\n}\r\nstatic int ht16k33_bl_check_fb(struct backlight_device *bl, struct fb_info *fi)\r\n{\r\nstruct ht16k33_priv *priv = bl_get_data(bl);\r\nreturn (fi == NULL) || (fi->par == priv);\r\n}\r\nstatic int ht16k33_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nstruct ht16k33_priv *priv = info->par;\r\nreturn vm_insert_page(vma, vma->vm_start,\r\nvirt_to_page(priv->fbdev.buffer));\r\n}\r\nstatic bool ht16k33_keypad_scan(struct ht16k33_keypad *keypad)\r\n{\r\nconst unsigned short *keycodes = keypad->dev->keycode;\r\nu16 new_state[HT16K33_MATRIX_KEYPAD_MAX_COLS];\r\n__le16 data[HT16K33_MATRIX_KEYPAD_MAX_COLS];\r\nunsigned long bits_changed;\r\nint row, col, code;\r\nint rc;\r\nbool pressed = false;\r\nrc = i2c_smbus_read_i2c_block_data(keypad->client, 0x40,\r\nsizeof(data), (u8 *)data);\r\nif (rc != sizeof(data)) {\r\ndev_err(&keypad->client->dev,\r\n"Failed to read key data, rc=%d\n", rc);\r\nreturn false;\r\n}\r\nfor (col = 0; col < keypad->cols; col++) {\r\nnew_state[col] = le16_to_cpu(data[col]);\r\nif (new_state[col])\r\npressed = true;\r\nbits_changed = keypad->last_key_state[col] ^ new_state[col];\r\nfor_each_set_bit(row, &bits_changed, BITS_PER_LONG) {\r\ncode = MATRIX_SCAN_CODE(row, col, keypad->row_shift);\r\ninput_event(keypad->dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(keypad->dev, keycodes[code],\r\nnew_state[col] & BIT(row));\r\n}\r\n}\r\ninput_sync(keypad->dev);\r\nmemcpy(keypad->last_key_state, new_state, sizeof(u16) * keypad->cols);\r\nreturn pressed;\r\n}\r\nstatic irqreturn_t ht16k33_keypad_irq_thread(int irq, void *dev)\r\n{\r\nstruct ht16k33_keypad *keypad = dev;\r\ndo {\r\nwait_event_timeout(keypad->wait, keypad->stopped,\r\nmsecs_to_jiffies(keypad->debounce_ms));\r\nif (keypad->stopped)\r\nbreak;\r\n} while (ht16k33_keypad_scan(keypad));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ht16k33_keypad_start(struct input_dev *dev)\r\n{\r\nstruct ht16k33_keypad *keypad = input_get_drvdata(dev);\r\nkeypad->stopped = false;\r\nmb();\r\nenable_irq(keypad->client->irq);\r\nreturn 0;\r\n}\r\nstatic void ht16k33_keypad_stop(struct input_dev *dev)\r\n{\r\nstruct ht16k33_keypad *keypad = input_get_drvdata(dev);\r\nkeypad->stopped = true;\r\nmb();\r\nwake_up(&keypad->wait);\r\ndisable_irq(keypad->client->irq);\r\n}\r\nstatic int ht16k33_keypad_probe(struct i2c_client *client,\r\nstruct ht16k33_keypad *keypad)\r\n{\r\nstruct device_node *node = client->dev.of_node;\r\nu32 rows = HT16K33_MATRIX_KEYPAD_MAX_ROWS;\r\nu32 cols = HT16K33_MATRIX_KEYPAD_MAX_COLS;\r\nint err;\r\nkeypad->client = client;\r\ninit_waitqueue_head(&keypad->wait);\r\nkeypad->dev = devm_input_allocate_device(&client->dev);\r\nif (!keypad->dev)\r\nreturn -ENOMEM;\r\ninput_set_drvdata(keypad->dev, keypad);\r\nkeypad->dev->name = DRIVER_NAME"-keypad";\r\nkeypad->dev->id.bustype = BUS_I2C;\r\nkeypad->dev->open = ht16k33_keypad_start;\r\nkeypad->dev->close = ht16k33_keypad_stop;\r\nif (!of_get_property(node, "linux,no-autorepeat", NULL))\r\n__set_bit(EV_REP, keypad->dev->evbit);\r\nerr = of_property_read_u32(node, "debounce-delay-ms",\r\n&keypad->debounce_ms);\r\nif (err) {\r\ndev_err(&client->dev, "key debounce delay not specified\n");\r\nreturn err;\r\n}\r\nerr = matrix_keypad_parse_of_params(&client->dev, &rows, &cols);\r\nif (err)\r\nreturn err;\r\nif (rows > HT16K33_MATRIX_KEYPAD_MAX_ROWS ||\r\ncols > HT16K33_MATRIX_KEYPAD_MAX_COLS) {\r\ndev_err(&client->dev, "%u rows or %u cols out of range in DT\n",\r\nrows, cols);\r\nreturn -ERANGE;\r\n}\r\nkeypad->rows = rows;\r\nkeypad->cols = cols;\r\nkeypad->row_shift = get_count_order(cols);\r\nerr = matrix_keypad_build_keymap(NULL, NULL, rows, cols, NULL,\r\nkeypad->dev);\r\nif (err) {\r\ndev_err(&client->dev, "failed to build keymap\n");\r\nreturn err;\r\n}\r\nerr = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, ht16k33_keypad_irq_thread,\r\nIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\r\nDRIVER_NAME, keypad);\r\nif (err) {\r\ndev_err(&client->dev, "irq request failed %d, error %d\n",\r\nclient->irq, err);\r\nreturn err;\r\n}\r\nht16k33_keypad_stop(keypad->dev);\r\nerr = input_register_device(keypad->dev);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int ht16k33_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint err;\r\nuint32_t dft_brightness;\r\nstruct backlight_device *bl;\r\nstruct backlight_properties bl_props;\r\nstruct ht16k33_priv *priv;\r\nstruct ht16k33_fbdev *fbdev;\r\nstruct device_node *node = client->dev.of_node;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "i2c_check_functionality error\n");\r\nreturn -EIO;\r\n}\r\nif (client->irq <= 0) {\r\ndev_err(&client->dev, "No IRQ specified\n");\r\nreturn -EINVAL;\r\n}\r\npriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->client = client;\r\ni2c_set_clientdata(client, priv);\r\nfbdev = &priv->fbdev;\r\nerr = ht16k33_initialize(priv);\r\nif (err)\r\nreturn err;\r\nBUILD_BUG_ON(PAGE_SIZE < HT16K33_FB_SIZE);\r\nfbdev->buffer = (unsigned char *) get_zeroed_page(GFP_KERNEL);\r\nif (!fbdev->buffer)\r\nreturn -ENOMEM;\r\nfbdev->cache = devm_kmalloc(&client->dev, HT16K33_FB_SIZE, GFP_KERNEL);\r\nif (!fbdev->cache) {\r\nerr = -ENOMEM;\r\ngoto err_fbdev_buffer;\r\n}\r\nfbdev->info = framebuffer_alloc(0, &client->dev);\r\nif (!fbdev->info) {\r\nerr = -ENOMEM;\r\ngoto err_fbdev_buffer;\r\n}\r\nerr = of_property_read_u32(node, "refresh-rate-hz",\r\n&fbdev->refresh_rate);\r\nif (err) {\r\ndev_err(&client->dev, "refresh rate not specified\n");\r\ngoto err_fbdev_info;\r\n}\r\nfb_bl_default_curve(fbdev->info, 0, MIN_BRIGHTNESS, MAX_BRIGHTNESS);\r\nINIT_DELAYED_WORK(&fbdev->work, ht16k33_fb_update);\r\nfbdev->info->fbops = &ht16k33_fb_ops;\r\nfbdev->info->screen_base = (char __iomem *) fbdev->buffer;\r\nfbdev->info->screen_size = HT16K33_FB_SIZE;\r\nfbdev->info->fix = ht16k33_fb_fix;\r\nfbdev->info->var = ht16k33_fb_var;\r\nfbdev->info->pseudo_palette = NULL;\r\nfbdev->info->flags = FBINFO_FLAG_DEFAULT;\r\nfbdev->info->par = priv;\r\nerr = register_framebuffer(fbdev->info);\r\nif (err)\r\ngoto err_fbdev_info;\r\nerr = ht16k33_keypad_probe(client, &priv->keypad);\r\nif (err)\r\ngoto err_fbdev_unregister;\r\nmemset(&bl_props, 0, sizeof(struct backlight_properties));\r\nbl_props.type = BACKLIGHT_RAW;\r\nbl_props.max_brightness = MAX_BRIGHTNESS;\r\nbl = devm_backlight_device_register(&client->dev, DRIVER_NAME"-bl",\r\n&client->dev, priv,\r\n&ht16k33_bl_ops, &bl_props);\r\nif (IS_ERR(bl)) {\r\ndev_err(&client->dev, "failed to register backlight\n");\r\nerr = PTR_ERR(bl);\r\ngoto err_fbdev_unregister;\r\n}\r\nerr = of_property_read_u32(node, "default-brightness-level",\r\n&dft_brightness);\r\nif (err) {\r\ndft_brightness = MAX_BRIGHTNESS;\r\n} else if (dft_brightness > MAX_BRIGHTNESS) {\r\ndev_warn(&client->dev,\r\n"invalid default brightness level: %u, using %u\n",\r\ndft_brightness, MAX_BRIGHTNESS);\r\ndft_brightness = MAX_BRIGHTNESS;\r\n}\r\nbl->props.brightness = dft_brightness;\r\nht16k33_bl_update_status(bl);\r\nht16k33_fb_queue(priv);\r\nreturn 0;\r\nerr_fbdev_unregister:\r\nunregister_framebuffer(fbdev->info);\r\nerr_fbdev_info:\r\nframebuffer_release(fbdev->info);\r\nerr_fbdev_buffer:\r\nfree_page((unsigned long) fbdev->buffer);\r\nreturn err;\r\n}\r\nstatic int ht16k33_remove(struct i2c_client *client)\r\n{\r\nstruct ht16k33_priv *priv = i2c_get_clientdata(client);\r\nstruct ht16k33_fbdev *fbdev = &priv->fbdev;\r\ncancel_delayed_work(&fbdev->work);\r\nunregister_framebuffer(fbdev->info);\r\nframebuffer_release(fbdev->info);\r\nfree_page((unsigned long) fbdev->buffer);\r\nreturn 0;\r\n}
