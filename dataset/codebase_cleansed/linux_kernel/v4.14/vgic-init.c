void kvm_vgic_early_init(struct kvm *kvm)\r\n{\r\nstruct vgic_dist *dist = &kvm->arch.vgic;\r\nINIT_LIST_HEAD(&dist->lpi_list_head);\r\nspin_lock_init(&dist->lpi_list_lock);\r\n}\r\nvoid kvm_vgic_vcpu_early_init(struct kvm_vcpu *vcpu)\r\n{\r\nstruct vgic_cpu *vgic_cpu = &vcpu->arch.vgic_cpu;\r\nint i;\r\nINIT_LIST_HEAD(&vgic_cpu->ap_list_head);\r\nspin_lock_init(&vgic_cpu->ap_list_lock);\r\nfor (i = 0; i < VGIC_NR_PRIVATE_IRQS; i++) {\r\nstruct vgic_irq *irq = &vgic_cpu->private_irqs[i];\r\nINIT_LIST_HEAD(&irq->ap_list);\r\nspin_lock_init(&irq->irq_lock);\r\nirq->intid = i;\r\nirq->vcpu = NULL;\r\nirq->target_vcpu = vcpu;\r\nirq->targets = 1U << vcpu->vcpu_id;\r\nkref_init(&irq->refcount);\r\nif (vgic_irq_is_sgi(i)) {\r\nirq->enabled = 1;\r\nirq->config = VGIC_CONFIG_EDGE;\r\n} else {\r\nirq->config = VGIC_CONFIG_LEVEL;\r\n}\r\n}\r\n}\r\nint kvm_vgic_create(struct kvm *kvm, u32 type)\r\n{\r\nint i, vcpu_lock_idx = -1, ret;\r\nstruct kvm_vcpu *vcpu;\r\nif (irqchip_in_kernel(kvm))\r\nreturn -EEXIST;\r\nif (type == KVM_DEV_TYPE_ARM_VGIC_V2 &&\r\n!kvm_vgic_global_state.can_emulate_gicv2)\r\nreturn -ENODEV;\r\nret = -EBUSY;\r\nkvm_for_each_vcpu(i, vcpu, kvm) {\r\nif (!mutex_trylock(&vcpu->mutex))\r\ngoto out_unlock;\r\nvcpu_lock_idx = i;\r\n}\r\nkvm_for_each_vcpu(i, vcpu, kvm) {\r\nif (vcpu->arch.has_run_once)\r\ngoto out_unlock;\r\n}\r\nret = 0;\r\nif (type == KVM_DEV_TYPE_ARM_VGIC_V2)\r\nkvm->arch.max_vcpus = VGIC_V2_MAX_CPUS;\r\nelse\r\nkvm->arch.max_vcpus = VGIC_V3_MAX_CPUS;\r\nif (atomic_read(&kvm->online_vcpus) > kvm->arch.max_vcpus) {\r\nret = -E2BIG;\r\ngoto out_unlock;\r\n}\r\nkvm->arch.vgic.in_kernel = true;\r\nkvm->arch.vgic.vgic_model = type;\r\nkvm->arch.vgic.vctrl_base = kvm_vgic_global_state.vctrl_base;\r\nkvm->arch.vgic.vgic_dist_base = VGIC_ADDR_UNDEF;\r\nkvm->arch.vgic.vgic_cpu_base = VGIC_ADDR_UNDEF;\r\nkvm->arch.vgic.vgic_redist_base = VGIC_ADDR_UNDEF;\r\nout_unlock:\r\nfor (; vcpu_lock_idx >= 0; vcpu_lock_idx--) {\r\nvcpu = kvm_get_vcpu(kvm, vcpu_lock_idx);\r\nmutex_unlock(&vcpu->mutex);\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_vgic_dist_init(struct kvm *kvm, unsigned int nr_spis)\r\n{\r\nstruct vgic_dist *dist = &kvm->arch.vgic;\r\nstruct kvm_vcpu *vcpu0 = kvm_get_vcpu(kvm, 0);\r\nint i;\r\ndist->spis = kcalloc(nr_spis, sizeof(struct vgic_irq), GFP_KERNEL);\r\nif (!dist->spis)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < nr_spis; i++) {\r\nstruct vgic_irq *irq = &dist->spis[i];\r\nirq->intid = i + VGIC_NR_PRIVATE_IRQS;\r\nINIT_LIST_HEAD(&irq->ap_list);\r\nspin_lock_init(&irq->irq_lock);\r\nirq->vcpu = NULL;\r\nirq->target_vcpu = vcpu0;\r\nkref_init(&irq->refcount);\r\nif (dist->vgic_model == KVM_DEV_TYPE_ARM_VGIC_V2)\r\nirq->targets = 0;\r\nelse\r\nirq->mpidr = 0;\r\n}\r\nreturn 0;\r\n}\r\nint kvm_vgic_vcpu_init(struct kvm_vcpu *vcpu)\r\n{\r\nint ret = 0;\r\nstruct vgic_dist *dist = &vcpu->kvm->arch.vgic;\r\nif (!irqchip_in_kernel(vcpu->kvm))\r\nreturn 0;\r\nif (dist->vgic_model == KVM_DEV_TYPE_ARM_VGIC_V3) {\r\nmutex_lock(&vcpu->kvm->lock);\r\nret = vgic_register_redist_iodev(vcpu);\r\nmutex_unlock(&vcpu->kvm->lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic void kvm_vgic_vcpu_enable(struct kvm_vcpu *vcpu)\r\n{\r\nif (kvm_vgic_global_state.type == VGIC_V2)\r\nvgic_v2_enable(vcpu);\r\nelse\r\nvgic_v3_enable(vcpu);\r\n}\r\nint vgic_init(struct kvm *kvm)\r\n{\r\nstruct vgic_dist *dist = &kvm->arch.vgic;\r\nstruct kvm_vcpu *vcpu;\r\nint ret = 0, i;\r\nif (vgic_initialized(kvm))\r\nreturn 0;\r\nif (!dist->nr_spis)\r\ndist->nr_spis = VGIC_NR_IRQS_LEGACY - VGIC_NR_PRIVATE_IRQS;\r\nret = kvm_vgic_dist_init(kvm, dist->nr_spis);\r\nif (ret)\r\ngoto out;\r\nkvm_for_each_vcpu(i, vcpu, kvm)\r\nkvm_vgic_vcpu_enable(vcpu);\r\nret = kvm_vgic_setup_default_irq_routing(kvm);\r\nif (ret)\r\ngoto out;\r\nvgic_debug_init(kvm);\r\ndist->initialized = true;\r\npreempt_disable();\r\nvcpu = kvm_arm_get_running_vcpu();\r\nif (vcpu)\r\nkvm_vgic_load(vcpu);\r\npreempt_enable();\r\nout:\r\nreturn ret;\r\n}\r\nstatic void kvm_vgic_dist_destroy(struct kvm *kvm)\r\n{\r\nstruct vgic_dist *dist = &kvm->arch.vgic;\r\ndist->ready = false;\r\ndist->initialized = false;\r\nkfree(dist->spis);\r\ndist->nr_spis = 0;\r\n}\r\nvoid kvm_vgic_vcpu_destroy(struct kvm_vcpu *vcpu)\r\n{\r\nstruct vgic_cpu *vgic_cpu = &vcpu->arch.vgic_cpu;\r\nINIT_LIST_HEAD(&vgic_cpu->ap_list_head);\r\n}\r\nstatic void __kvm_vgic_destroy(struct kvm *kvm)\r\n{\r\nstruct kvm_vcpu *vcpu;\r\nint i;\r\nvgic_debug_destroy(kvm);\r\nkvm_vgic_dist_destroy(kvm);\r\nkvm_for_each_vcpu(i, vcpu, kvm)\r\nkvm_vgic_vcpu_destroy(vcpu);\r\n}\r\nvoid kvm_vgic_destroy(struct kvm *kvm)\r\n{\r\nmutex_lock(&kvm->lock);\r\n__kvm_vgic_destroy(kvm);\r\nmutex_unlock(&kvm->lock);\r\n}\r\nint vgic_lazy_init(struct kvm *kvm)\r\n{\r\nint ret = 0;\r\nif (unlikely(!vgic_initialized(kvm))) {\r\nif (kvm->arch.vgic.vgic_model != KVM_DEV_TYPE_ARM_VGIC_V2)\r\nreturn -EBUSY;\r\nmutex_lock(&kvm->lock);\r\nret = vgic_init(kvm);\r\nmutex_unlock(&kvm->lock);\r\n}\r\nreturn ret;\r\n}\r\nint kvm_vgic_map_resources(struct kvm *kvm)\r\n{\r\nstruct vgic_dist *dist = &kvm->arch.vgic;\r\nint ret = 0;\r\nmutex_lock(&kvm->lock);\r\nif (!irqchip_in_kernel(kvm))\r\ngoto out;\r\nif (dist->vgic_model == KVM_DEV_TYPE_ARM_VGIC_V2)\r\nret = vgic_v2_map_resources(kvm);\r\nelse\r\nret = vgic_v3_map_resources(kvm);\r\nif (ret)\r\n__kvm_vgic_destroy(kvm);\r\nout:\r\nmutex_unlock(&kvm->lock);\r\nreturn ret;\r\n}\r\nstatic int vgic_init_cpu_starting(unsigned int cpu)\r\n{\r\nenable_percpu_irq(kvm_vgic_global_state.maint_irq, 0);\r\nreturn 0;\r\n}\r\nstatic int vgic_init_cpu_dying(unsigned int cpu)\r\n{\r\ndisable_percpu_irq(kvm_vgic_global_state.maint_irq);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t vgic_maintenance_handler(int irq, void *data)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid kvm_vgic_init_cpu_hardware(void)\r\n{\r\nBUG_ON(preemptible());\r\nif (kvm_vgic_global_state.type == VGIC_V2)\r\nvgic_v2_init_lrs();\r\nelse\r\nkvm_call_hyp(__vgic_v3_init_lrs);\r\n}\r\nint kvm_vgic_hyp_init(void)\r\n{\r\nconst struct gic_kvm_info *gic_kvm_info;\r\nint ret;\r\ngic_kvm_info = gic_get_kvm_info();\r\nif (!gic_kvm_info)\r\nreturn -ENODEV;\r\nif (!gic_kvm_info->maint_irq) {\r\nkvm_err("No vgic maintenance irq\n");\r\nreturn -ENXIO;\r\n}\r\nswitch (gic_kvm_info->type) {\r\ncase GIC_V2:\r\nret = vgic_v2_probe(gic_kvm_info);\r\nbreak;\r\ncase GIC_V3:\r\nret = vgic_v3_probe(gic_kvm_info);\r\nif (!ret) {\r\nstatic_branch_enable(&kvm_vgic_global_state.gicv3_cpuif);\r\nkvm_info("GIC system register CPU interface enabled\n");\r\n}\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\n};\r\nif (ret)\r\nreturn ret;\r\nkvm_vgic_global_state.maint_irq = gic_kvm_info->maint_irq;\r\nret = request_percpu_irq(kvm_vgic_global_state.maint_irq,\r\nvgic_maintenance_handler,\r\n"vgic", kvm_get_running_vcpus());\r\nif (ret) {\r\nkvm_err("Cannot register interrupt %d\n",\r\nkvm_vgic_global_state.maint_irq);\r\nreturn ret;\r\n}\r\nret = cpuhp_setup_state(CPUHP_AP_KVM_ARM_VGIC_INIT_STARTING,\r\n"kvm/arm/vgic:starting",\r\nvgic_init_cpu_starting, vgic_init_cpu_dying);\r\nif (ret) {\r\nkvm_err("Cannot register vgic CPU notifier\n");\r\ngoto out_free_irq;\r\n}\r\nkvm_info("vgic interrupt IRQ%d\n", kvm_vgic_global_state.maint_irq);\r\nreturn 0;\r\nout_free_irq:\r\nfree_percpu_irq(kvm_vgic_global_state.maint_irq,\r\nkvm_get_running_vcpus());\r\nreturn ret;\r\n}
