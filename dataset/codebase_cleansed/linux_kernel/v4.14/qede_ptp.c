static int qede_ptp_adjfreq(struct ptp_clock_info *info, s32 ppb)\r\n{\r\nstruct qede_ptp *ptp = container_of(info, struct qede_ptp, clock_info);\r\nstruct qede_dev *edev = ptp->edev;\r\nint rc;\r\n__qede_lock(edev);\r\nif (edev->state == QEDE_STATE_OPEN) {\r\nspin_lock_bh(&ptp->lock);\r\nrc = ptp->ops->adjfreq(edev->cdev, ppb);\r\nspin_unlock_bh(&ptp->lock);\r\n} else {\r\nDP_ERR(edev, "PTP adjfreq called while interface is down\n");\r\nrc = -EFAULT;\r\n}\r\n__qede_unlock(edev);\r\nreturn rc;\r\n}\r\nstatic int qede_ptp_adjtime(struct ptp_clock_info *info, s64 delta)\r\n{\r\nstruct qede_dev *edev;\r\nstruct qede_ptp *ptp;\r\nptp = container_of(info, struct qede_ptp, clock_info);\r\nedev = ptp->edev;\r\nDP_VERBOSE(edev, QED_MSG_DEBUG, "PTP adjtime called, delta = %llx\n",\r\ndelta);\r\nspin_lock_bh(&ptp->lock);\r\ntimecounter_adjtime(&ptp->tc, delta);\r\nspin_unlock_bh(&ptp->lock);\r\nreturn 0;\r\n}\r\nstatic int qede_ptp_gettime(struct ptp_clock_info *info, struct timespec64 *ts)\r\n{\r\nstruct qede_dev *edev;\r\nstruct qede_ptp *ptp;\r\nu64 ns;\r\nptp = container_of(info, struct qede_ptp, clock_info);\r\nedev = ptp->edev;\r\nspin_lock_bh(&ptp->lock);\r\nns = timecounter_read(&ptp->tc);\r\nspin_unlock_bh(&ptp->lock);\r\nDP_VERBOSE(edev, QED_MSG_DEBUG, "PTP gettime called, ns = %llu\n", ns);\r\n*ts = ns_to_timespec64(ns);\r\nreturn 0;\r\n}\r\nstatic int qede_ptp_settime(struct ptp_clock_info *info,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct qede_dev *edev;\r\nstruct qede_ptp *ptp;\r\nu64 ns;\r\nptp = container_of(info, struct qede_ptp, clock_info);\r\nedev = ptp->edev;\r\nns = timespec64_to_ns(ts);\r\nDP_VERBOSE(edev, QED_MSG_DEBUG, "PTP settime called, ns = %llu\n", ns);\r\nspin_lock_bh(&ptp->lock);\r\ntimecounter_init(&ptp->tc, &ptp->cc, ns);\r\nspin_unlock_bh(&ptp->lock);\r\nreturn 0;\r\n}\r\nstatic int qede_ptp_ancillary_feature_enable(struct ptp_clock_info *info,\r\nstruct ptp_clock_request *rq,\r\nint on)\r\n{\r\nstruct qede_dev *edev;\r\nstruct qede_ptp *ptp;\r\nptp = container_of(info, struct qede_ptp, clock_info);\r\nedev = ptp->edev;\r\nDP_ERR(edev, "PHC ancillary features are not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nstatic void qede_ptp_task(struct work_struct *work)\r\n{\r\nstruct skb_shared_hwtstamps shhwtstamps;\r\nstruct qede_dev *edev;\r\nstruct qede_ptp *ptp;\r\nu64 timestamp, ns;\r\nint rc;\r\nptp = container_of(work, struct qede_ptp, work);\r\nedev = ptp->edev;\r\nspin_lock_bh(&ptp->lock);\r\nrc = ptp->ops->read_tx_ts(edev->cdev, &timestamp);\r\nspin_unlock_bh(&ptp->lock);\r\nif (rc) {\r\nschedule_work(&ptp->work);\r\nreturn;\r\n}\r\nns = timecounter_cyc2time(&ptp->tc, timestamp);\r\nmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\r\nshhwtstamps.hwtstamp = ns_to_ktime(ns);\r\nskb_tstamp_tx(ptp->tx_skb, &shhwtstamps);\r\ndev_kfree_skb_any(ptp->tx_skb);\r\nptp->tx_skb = NULL;\r\nclear_bit_unlock(QEDE_FLAGS_PTP_TX_IN_PRORGESS, &edev->flags);\r\nDP_VERBOSE(edev, QED_MSG_DEBUG,\r\n"Tx timestamp, timestamp cycles = %llu, ns = %llu\n",\r\ntimestamp, ns);\r\n}\r\nstatic u64 qede_ptp_read_cc(const struct cyclecounter *cc)\r\n{\r\nstruct qede_dev *edev;\r\nstruct qede_ptp *ptp;\r\nu64 phc_cycles;\r\nint rc;\r\nptp = container_of(cc, struct qede_ptp, cc);\r\nedev = ptp->edev;\r\nrc = ptp->ops->read_cc(edev->cdev, &phc_cycles);\r\nif (rc)\r\nWARN_ONCE(1, "PHC read err %d\n", rc);\r\nDP_VERBOSE(edev, QED_MSG_DEBUG, "PHC read cycles = %llu\n", phc_cycles);\r\nreturn phc_cycles;\r\n}\r\nstatic int qede_ptp_cfg_filters(struct qede_dev *edev)\r\n{\r\nenum qed_ptp_hwtstamp_tx_type tx_type = QED_PTP_HWTSTAMP_TX_ON;\r\nenum qed_ptp_filter_type rx_filter = QED_PTP_FILTER_NONE;\r\nstruct qede_ptp *ptp = edev->ptp;\r\nif (!ptp)\r\nreturn -EIO;\r\nif (!ptp->hw_ts_ioctl_called) {\r\nDP_INFO(edev, "TS IOCTL not called\n");\r\nreturn 0;\r\n}\r\nswitch (ptp->tx_type) {\r\ncase HWTSTAMP_TX_ON:\r\nedev->flags |= QEDE_TX_TIMESTAMPING_EN;\r\ntx_type = QED_PTP_HWTSTAMP_TX_ON;\r\nbreak;\r\ncase HWTSTAMP_TX_OFF:\r\nedev->flags &= ~QEDE_TX_TIMESTAMPING_EN;\r\ntx_type = QED_PTP_HWTSTAMP_TX_OFF;\r\nbreak;\r\ncase HWTSTAMP_TX_ONESTEP_SYNC:\r\nDP_ERR(edev, "One-step timestamping is not supported\n");\r\nreturn -ERANGE;\r\n}\r\nspin_lock_bh(&ptp->lock);\r\nswitch (ptp->rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\nrx_filter = QED_PTP_FILTER_NONE;\r\nbreak;\r\ncase HWTSTAMP_FILTER_ALL:\r\ncase HWTSTAMP_FILTER_SOME:\r\ncase HWTSTAMP_FILTER_NTP_ALL:\r\nptp->rx_filter = HWTSTAMP_FILTER_NONE;\r\nrx_filter = QED_PTP_FILTER_ALL;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\nptp->rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\r\nrx_filter = QED_PTP_FILTER_V1_L4_EVENT;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\nptp->rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\r\nrx_filter = QED_PTP_FILTER_V1_L4_GEN;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\nptp->rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\r\nrx_filter = QED_PTP_FILTER_V2_L4_EVENT;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\nptp->rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\r\nrx_filter = QED_PTP_FILTER_V2_L4_GEN;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\nptp->rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\r\nrx_filter = QED_PTP_FILTER_V2_L2_EVENT;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\nptp->rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\r\nrx_filter = QED_PTP_FILTER_V2_L2_GEN;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_EVENT:\r\nptp->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\r\nrx_filter = QED_PTP_FILTER_V2_EVENT;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\nptp->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\r\nrx_filter = QED_PTP_FILTER_V2_GEN;\r\nbreak;\r\n}\r\nptp->ops->cfg_filters(edev->cdev, rx_filter, tx_type);\r\nspin_unlock_bh(&ptp->lock);\r\nreturn 0;\r\n}\r\nint qede_ptp_hw_ts(struct qede_dev *edev, struct ifreq *ifr)\r\n{\r\nstruct hwtstamp_config config;\r\nstruct qede_ptp *ptp;\r\nint rc;\r\nptp = edev->ptp;\r\nif (!ptp)\r\nreturn -EIO;\r\nif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\r\nreturn -EFAULT;\r\nDP_VERBOSE(edev, QED_MSG_DEBUG,\r\n"HWTSTAMP IOCTL: Requested tx_type = %d, requested rx_filters = %d\n",\r\nconfig.tx_type, config.rx_filter);\r\nif (config.flags) {\r\nDP_ERR(edev, "config.flags is reserved for future use\n");\r\nreturn -EINVAL;\r\n}\r\nptp->hw_ts_ioctl_called = 1;\r\nptp->tx_type = config.tx_type;\r\nptp->rx_filter = config.rx_filter;\r\nrc = qede_ptp_cfg_filters(edev);\r\nif (rc)\r\nreturn rc;\r\nconfig.rx_filter = ptp->rx_filter;\r\nreturn copy_to_user(ifr->ifr_data, &config,\r\nsizeof(config)) ? -EFAULT : 0;\r\n}\r\nint qede_ptp_get_ts_info(struct qede_dev *edev, struct ethtool_ts_info *info)\r\n{\r\nstruct qede_ptp *ptp = edev->ptp;\r\nif (!ptp)\r\nreturn -EIO;\r\ninfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\r\nSOF_TIMESTAMPING_RX_SOFTWARE |\r\nSOF_TIMESTAMPING_SOFTWARE |\r\nSOF_TIMESTAMPING_TX_HARDWARE |\r\nSOF_TIMESTAMPING_RX_HARDWARE |\r\nSOF_TIMESTAMPING_RAW_HARDWARE;\r\nif (ptp->clock)\r\ninfo->phc_index = ptp_clock_index(ptp->clock);\r\nelse\r\ninfo->phc_index = -1;\r\ninfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |\r\nBIT(HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\r\nBIT(HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |\r\nBIT(HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |\r\nBIT(HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\r\nBIT(HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\r\nBIT(HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |\r\nBIT(HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\r\nBIT(HWTSTAMP_FILTER_PTP_V2_L2_SYNC) |\r\nBIT(HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ) |\r\nBIT(HWTSTAMP_FILTER_PTP_V2_EVENT) |\r\nBIT(HWTSTAMP_FILTER_PTP_V2_SYNC) |\r\nBIT(HWTSTAMP_FILTER_PTP_V2_DELAY_REQ);\r\ninfo->tx_types = BIT(HWTSTAMP_TX_OFF) | BIT(HWTSTAMP_TX_ON);\r\nreturn 0;\r\n}\r\nvoid qede_ptp_disable(struct qede_dev *edev)\r\n{\r\nstruct qede_ptp *ptp;\r\nptp = edev->ptp;\r\nif (!ptp)\r\nreturn;\r\nif (ptp->clock) {\r\nptp_clock_unregister(ptp->clock);\r\nptp->clock = NULL;\r\n}\r\ncancel_work_sync(&ptp->work);\r\nif (ptp->tx_skb) {\r\ndev_kfree_skb_any(ptp->tx_skb);\r\nptp->tx_skb = NULL;\r\n}\r\nspin_lock_bh(&ptp->lock);\r\nptp->ops->disable(edev->cdev);\r\nspin_unlock_bh(&ptp->lock);\r\nkfree(ptp);\r\nedev->ptp = NULL;\r\n}\r\nstatic int qede_ptp_init(struct qede_dev *edev, bool init_tc)\r\n{\r\nstruct qede_ptp *ptp;\r\nint rc;\r\nptp = edev->ptp;\r\nif (!ptp)\r\nreturn -EINVAL;\r\nspin_lock_init(&ptp->lock);\r\nrc = ptp->ops->enable(edev->cdev);\r\nif (rc) {\r\nDP_INFO(edev, "PTP HW enable failed\n");\r\nreturn rc;\r\n}\r\nINIT_WORK(&ptp->work, qede_ptp_task);\r\nif (init_tc) {\r\nmemset(&ptp->cc, 0, sizeof(ptp->cc));\r\nptp->cc.read = qede_ptp_read_cc;\r\nptp->cc.mask = CYCLECOUNTER_MASK(64);\r\nptp->cc.shift = 0;\r\nptp->cc.mult = 1;\r\ntimecounter_init(&ptp->tc, &ptp->cc,\r\nktime_to_ns(ktime_get_real()));\r\n}\r\nreturn rc;\r\n}\r\nint qede_ptp_enable(struct qede_dev *edev, bool init_tc)\r\n{\r\nstruct qede_ptp *ptp;\r\nint rc;\r\nptp = kzalloc(sizeof(*ptp), GFP_KERNEL);\r\nif (!ptp) {\r\nDP_INFO(edev, "Failed to allocate struct for PTP\n");\r\nreturn -ENOMEM;\r\n}\r\nptp->edev = edev;\r\nptp->ops = edev->ops->ptp;\r\nif (!ptp->ops) {\r\nDP_INFO(edev, "PTP enable failed\n");\r\nrc = -EIO;\r\ngoto err1;\r\n}\r\nedev->ptp = ptp;\r\nrc = qede_ptp_init(edev, init_tc);\r\nif (rc)\r\ngoto err1;\r\nqede_ptp_cfg_filters(edev);\r\nptp->clock_info.owner = THIS_MODULE;\r\nsnprintf(ptp->clock_info.name, 16, "%s", edev->ndev->name);\r\nptp->clock_info.max_adj = QED_MAX_PHC_DRIFT_PPB;\r\nptp->clock_info.n_alarm = 0;\r\nptp->clock_info.n_ext_ts = 0;\r\nptp->clock_info.n_per_out = 0;\r\nptp->clock_info.pps = 0;\r\nptp->clock_info.adjfreq = qede_ptp_adjfreq;\r\nptp->clock_info.adjtime = qede_ptp_adjtime;\r\nptp->clock_info.gettime64 = qede_ptp_gettime;\r\nptp->clock_info.settime64 = qede_ptp_settime;\r\nptp->clock_info.enable = qede_ptp_ancillary_feature_enable;\r\nptp->clock = ptp_clock_register(&ptp->clock_info, &edev->pdev->dev);\r\nif (IS_ERR(ptp->clock)) {\r\nrc = -EINVAL;\r\nDP_ERR(edev, "PTP clock registeration failed\n");\r\ngoto err2;\r\n}\r\nreturn 0;\r\nerr2:\r\nqede_ptp_disable(edev);\r\nptp->clock = NULL;\r\nerr1:\r\nkfree(ptp);\r\nedev->ptp = NULL;\r\nreturn rc;\r\n}\r\nvoid qede_ptp_tx_ts(struct qede_dev *edev, struct sk_buff *skb)\r\n{\r\nstruct qede_ptp *ptp;\r\nptp = edev->ptp;\r\nif (!ptp)\r\nreturn;\r\nif (test_and_set_bit_lock(QEDE_FLAGS_PTP_TX_IN_PRORGESS, &edev->flags))\r\nreturn;\r\nif (unlikely(!(edev->flags & QEDE_TX_TIMESTAMPING_EN))) {\r\nDP_NOTICE(edev,\r\n"Tx timestamping was not enabled, this packet will not be timestamped\n");\r\n} else if (unlikely(ptp->tx_skb)) {\r\nDP_NOTICE(edev,\r\n"The device supports only a single outstanding packet to timestamp, this packet will not be timestamped\n");\r\n} else {\r\nskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\r\nptp->tx_skb = skb_get(skb);\r\nschedule_work(&ptp->work);\r\n}\r\n}\r\nvoid qede_ptp_rx_ts(struct qede_dev *edev, struct sk_buff *skb)\r\n{\r\nstruct qede_ptp *ptp;\r\nu64 timestamp, ns;\r\nint rc;\r\nptp = edev->ptp;\r\nif (!ptp)\r\nreturn;\r\nspin_lock_bh(&ptp->lock);\r\nrc = ptp->ops->read_rx_ts(edev->cdev, &timestamp);\r\nif (rc) {\r\nspin_unlock_bh(&ptp->lock);\r\nDP_INFO(edev, "Invalid Rx timestamp\n");\r\nreturn;\r\n}\r\nns = timecounter_cyc2time(&ptp->tc, timestamp);\r\nspin_unlock_bh(&ptp->lock);\r\nskb_hwtstamps(skb)->hwtstamp = ns_to_ktime(ns);\r\nDP_VERBOSE(edev, QED_MSG_DEBUG,\r\n"Rx timestamp, timestamp cycles = %llu, ns = %llu\n",\r\ntimestamp, ns);\r\n}
