static void csi2_if_enable(struct iss_csi2_device *csi2, u8 enable)\r\n{\r\nstruct iss_csi2_ctrl_cfg *currctrl = &csi2->ctrl;\r\niss_reg_update(csi2->iss, csi2->regs1, CSI2_CTRL, CSI2_CTRL_IF_EN,\r\nenable ? CSI2_CTRL_IF_EN : 0);\r\ncurrctrl->if_enable = enable;\r\n}\r\nstatic void csi2_recv_config(struct iss_csi2_device *csi2,\r\nstruct iss_csi2_ctrl_cfg *currctrl)\r\n{\r\nu32 reg = 0;\r\nif (currctrl->frame_mode)\r\nreg |= CSI2_CTRL_FRAME;\r\nelse\r\nreg &= ~CSI2_CTRL_FRAME;\r\nif (currctrl->vp_clk_enable)\r\nreg |= CSI2_CTRL_VP_CLK_EN;\r\nelse\r\nreg &= ~CSI2_CTRL_VP_CLK_EN;\r\nif (currctrl->vp_only_enable)\r\nreg |= CSI2_CTRL_VP_ONLY_EN;\r\nelse\r\nreg &= ~CSI2_CTRL_VP_ONLY_EN;\r\nreg &= ~CSI2_CTRL_VP_OUT_CTRL_MASK;\r\nreg |= currctrl->vp_out_ctrl << CSI2_CTRL_VP_OUT_CTRL_SHIFT;\r\nif (currctrl->ecc_enable)\r\nreg |= CSI2_CTRL_ECC_EN;\r\nelse\r\nreg &= ~CSI2_CTRL_ECC_EN;\r\nreg &= ~(CSI2_CTRL_MFLAG_LEVH_MASK | CSI2_CTRL_MFLAG_LEVL_MASK);\r\nreg |= (2 << CSI2_CTRL_MFLAG_LEVH_SHIFT) |\r\n(4 << CSI2_CTRL_MFLAG_LEVL_SHIFT);\r\nreg |= CSI2_CTRL_BURST_SIZE_EXPAND;\r\nreg |= CSI2_CTRL_NON_POSTED_WRITE;\r\nreg |= CSI2_CTRL_ENDIANNESS;\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_CTRL, reg);\r\n}\r\nstatic u16 csi2_ctx_map_format(struct iss_csi2_device *csi2)\r\n{\r\nconst struct v4l2_mbus_framefmt *fmt = &csi2->formats[CSI2_PAD_SINK];\r\nint fmtidx, destidx;\r\nswitch (fmt->code) {\r\ncase MEDIA_BUS_FMT_SGRBG10_1X10:\r\ncase MEDIA_BUS_FMT_SRGGB10_1X10:\r\ncase MEDIA_BUS_FMT_SBGGR10_1X10:\r\ncase MEDIA_BUS_FMT_SGBRG10_1X10:\r\nfmtidx = 0;\r\nbreak;\r\ncase MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:\r\ncase MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:\r\ncase MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:\r\ncase MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:\r\nfmtidx = 1;\r\nbreak;\r\ncase MEDIA_BUS_FMT_SBGGR8_1X8:\r\ncase MEDIA_BUS_FMT_SGBRG8_1X8:\r\ncase MEDIA_BUS_FMT_SGRBG8_1X8:\r\ncase MEDIA_BUS_FMT_SRGGB8_1X8:\r\nfmtidx = 2;\r\nbreak;\r\ncase MEDIA_BUS_FMT_UYVY8_1X16:\r\ncase MEDIA_BUS_FMT_YUYV8_1X16:\r\nfmtidx = 3;\r\nbreak;\r\ndefault:\r\nWARN(1, "CSI2: pixel format %08x unsupported!\n",\r\nfmt->code);\r\nreturn 0;\r\n}\r\nif (!(csi2->output & CSI2_OUTPUT_IPIPEIF) &&\r\n!(csi2->output & CSI2_OUTPUT_MEMORY)) {\r\nreturn CSI2_PIX_FMT_OTHERS;\r\n}\r\ndestidx = csi2->frame_skip ? 0 : !!(csi2->output & CSI2_OUTPUT_IPIPEIF);\r\nreturn __csi2_fmt_map[fmtidx][destidx][csi2->dpcm_decompress];\r\n}\r\nstatic void csi2_set_outaddr(struct iss_csi2_device *csi2, u32 addr)\r\n{\r\nstruct iss_csi2_ctx_cfg *ctx = &csi2->contexts[0];\r\nctx->ping_addr = addr;\r\nctx->pong_addr = addr;\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_PING_ADDR(ctx->ctxnum),\r\nctx->ping_addr);\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_PONG_ADDR(ctx->ctxnum),\r\nctx->pong_addr);\r\n}\r\nstatic inline int is_usr_def_mapping(u32 format_id)\r\n{\r\nreturn (format_id & 0xf0) == 0x40 ? 1 : 0;\r\n}\r\nstatic void csi2_ctx_enable(struct iss_csi2_device *csi2, u8 ctxnum, u8 enable)\r\n{\r\nstruct iss_csi2_ctx_cfg *ctx = &csi2->contexts[ctxnum];\r\nu32 reg;\r\nreg = iss_reg_read(csi2->iss, csi2->regs1, CSI2_CTX_CTRL1(ctxnum));\r\nif (enable) {\r\nunsigned int skip = 0;\r\nif (csi2->frame_skip)\r\nskip = csi2->frame_skip;\r\nelse if (csi2->output & CSI2_OUTPUT_MEMORY)\r\nskip = 1;\r\nreg &= ~CSI2_CTX_CTRL1_COUNT_MASK;\r\nreg |= CSI2_CTX_CTRL1_COUNT_UNLOCK\r\n| (skip << CSI2_CTX_CTRL1_COUNT_SHIFT)\r\n| CSI2_CTX_CTRL1_CTX_EN;\r\n} else {\r\nreg &= ~CSI2_CTX_CTRL1_CTX_EN;\r\n}\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_CTRL1(ctxnum), reg);\r\nctx->enabled = enable;\r\n}\r\nstatic void csi2_ctx_config(struct iss_csi2_device *csi2,\r\nstruct iss_csi2_ctx_cfg *ctx)\r\n{\r\nu32 reg = 0;\r\nctx->frame = 0;\r\nif (ctx->eof_enabled)\r\nreg = CSI2_CTX_CTRL1_EOF_EN;\r\nif (ctx->eol_enabled)\r\nreg |= CSI2_CTX_CTRL1_EOL_EN;\r\nif (ctx->checksum_enabled)\r\nreg |= CSI2_CTX_CTRL1_CS_EN;\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_CTRL1(ctx->ctxnum), reg);\r\nreg = ctx->virtual_id << CSI2_CTX_CTRL2_VIRTUAL_ID_SHIFT;\r\nreg |= ctx->format_id << CSI2_CTX_CTRL2_FORMAT_SHIFT;\r\nif (ctx->dpcm_decompress && ctx->dpcm_predictor)\r\nreg |= CSI2_CTX_CTRL2_DPCM_PRED;\r\nif (is_usr_def_mapping(ctx->format_id))\r\nreg |= 2 << CSI2_CTX_CTRL2_USER_DEF_MAP_SHIFT;\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_CTRL2(ctx->ctxnum), reg);\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_CTRL3(ctx->ctxnum),\r\nctx->alpha << CSI2_CTX_CTRL3_ALPHA_SHIFT);\r\niss_reg_update(csi2->iss, csi2->regs1, CSI2_CTX_DAT_OFST(ctx->ctxnum),\r\nCSI2_CTX_DAT_OFST_MASK, ctx->data_offset);\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_PING_ADDR(ctx->ctxnum),\r\nctx->ping_addr);\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_PONG_ADDR(ctx->ctxnum),\r\nctx->pong_addr);\r\n}\r\nstatic void csi2_timing_config(struct iss_csi2_device *csi2,\r\nstruct iss_csi2_timing_cfg *timing)\r\n{\r\nu32 reg;\r\nreg = iss_reg_read(csi2->iss, csi2->regs1, CSI2_TIMING);\r\nif (timing->force_rx_mode)\r\nreg |= CSI2_TIMING_FORCE_RX_MODE_IO1;\r\nelse\r\nreg &= ~CSI2_TIMING_FORCE_RX_MODE_IO1;\r\nif (timing->stop_state_16x)\r\nreg |= CSI2_TIMING_STOP_STATE_X16_IO1;\r\nelse\r\nreg &= ~CSI2_TIMING_STOP_STATE_X16_IO1;\r\nif (timing->stop_state_4x)\r\nreg |= CSI2_TIMING_STOP_STATE_X4_IO1;\r\nelse\r\nreg &= ~CSI2_TIMING_STOP_STATE_X4_IO1;\r\nreg &= ~CSI2_TIMING_STOP_STATE_COUNTER_IO1_MASK;\r\nreg |= timing->stop_state_counter <<\r\nCSI2_TIMING_STOP_STATE_COUNTER_IO1_SHIFT;\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_TIMING, reg);\r\n}\r\nstatic void csi2_irq_ctx_set(struct iss_csi2_device *csi2, int enable)\r\n{\r\nconst u32 mask = CSI2_CTX_IRQ_FE | CSI2_CTX_IRQ_FS;\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_IRQSTATUS(i),\r\nmask);\r\nif (enable)\r\niss_reg_set(csi2->iss, csi2->regs1,\r\nCSI2_CTX_IRQENABLE(i), mask);\r\nelse\r\niss_reg_clr(csi2->iss, csi2->regs1,\r\nCSI2_CTX_IRQENABLE(i), mask);\r\n}\r\n}\r\nstatic void csi2_irq_complexio1_set(struct iss_csi2_device *csi2, int enable)\r\n{\r\nu32 reg;\r\nreg = CSI2_COMPLEXIO_IRQ_STATEALLULPMEXIT |\r\nCSI2_COMPLEXIO_IRQ_STATEALLULPMENTER |\r\nCSI2_COMPLEXIO_IRQ_STATEULPM5 |\r\nCSI2_COMPLEXIO_IRQ_ERRCONTROL5 |\r\nCSI2_COMPLEXIO_IRQ_ERRESC5 |\r\nCSI2_COMPLEXIO_IRQ_ERRSOTSYNCHS5 |\r\nCSI2_COMPLEXIO_IRQ_ERRSOTHS5 |\r\nCSI2_COMPLEXIO_IRQ_STATEULPM4 |\r\nCSI2_COMPLEXIO_IRQ_ERRCONTROL4 |\r\nCSI2_COMPLEXIO_IRQ_ERRESC4 |\r\nCSI2_COMPLEXIO_IRQ_ERRSOTSYNCHS4 |\r\nCSI2_COMPLEXIO_IRQ_ERRSOTHS4 |\r\nCSI2_COMPLEXIO_IRQ_STATEULPM3 |\r\nCSI2_COMPLEXIO_IRQ_ERRCONTROL3 |\r\nCSI2_COMPLEXIO_IRQ_ERRESC3 |\r\nCSI2_COMPLEXIO_IRQ_ERRSOTSYNCHS3 |\r\nCSI2_COMPLEXIO_IRQ_ERRSOTHS3 |\r\nCSI2_COMPLEXIO_IRQ_STATEULPM2 |\r\nCSI2_COMPLEXIO_IRQ_ERRCONTROL2 |\r\nCSI2_COMPLEXIO_IRQ_ERRESC2 |\r\nCSI2_COMPLEXIO_IRQ_ERRSOTSYNCHS2 |\r\nCSI2_COMPLEXIO_IRQ_ERRSOTHS2 |\r\nCSI2_COMPLEXIO_IRQ_STATEULPM1 |\r\nCSI2_COMPLEXIO_IRQ_ERRCONTROL1 |\r\nCSI2_COMPLEXIO_IRQ_ERRESC1 |\r\nCSI2_COMPLEXIO_IRQ_ERRSOTSYNCHS1 |\r\nCSI2_COMPLEXIO_IRQ_ERRSOTHS1;\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_COMPLEXIO_IRQSTATUS, reg);\r\nif (enable)\r\niss_reg_set(csi2->iss, csi2->regs1, CSI2_COMPLEXIO_IRQENABLE,\r\nreg);\r\nelse\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_COMPLEXIO_IRQENABLE,\r\n0);\r\n}\r\nstatic void csi2_irq_status_set(struct iss_csi2_device *csi2, int enable)\r\n{\r\nu32 reg;\r\nreg = CSI2_IRQ_OCP_ERR |\r\nCSI2_IRQ_SHORT_PACKET |\r\nCSI2_IRQ_ECC_CORRECTION |\r\nCSI2_IRQ_ECC_NO_CORRECTION |\r\nCSI2_IRQ_COMPLEXIO_ERR |\r\nCSI2_IRQ_FIFO_OVF |\r\nCSI2_IRQ_CONTEXT0;\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_IRQSTATUS, reg);\r\nif (enable)\r\niss_reg_set(csi2->iss, csi2->regs1, CSI2_IRQENABLE, reg);\r\nelse\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_IRQENABLE, 0);\r\n}\r\nint omap4iss_csi2_reset(struct iss_csi2_device *csi2)\r\n{\r\nunsigned int timeout;\r\nif (!csi2->available)\r\nreturn -ENODEV;\r\nif (csi2->phy->phy_in_use)\r\nreturn -EBUSY;\r\niss_reg_set(csi2->iss, csi2->regs1, CSI2_SYSCONFIG,\r\nCSI2_SYSCONFIG_SOFT_RESET);\r\ntimeout = iss_poll_condition_timeout(\r\niss_reg_read(csi2->iss, csi2->regs1, CSI2_SYSSTATUS) &\r\nCSI2_SYSSTATUS_RESET_DONE, 500, 100, 200);\r\nif (timeout) {\r\ndev_err(csi2->iss->dev, "CSI2: Soft reset timeout!\n");\r\nreturn -EBUSY;\r\n}\r\niss_reg_set(csi2->iss, csi2->regs1, CSI2_COMPLEXIO_CFG,\r\nCSI2_COMPLEXIO_CFG_RESET_CTRL);\r\ntimeout = iss_poll_condition_timeout(\r\niss_reg_read(csi2->iss, csi2->phy->phy_regs, REGISTER1) &\r\nREGISTER1_RESET_DONE_CTRLCLK, 10000, 100, 500);\r\nif (timeout) {\r\ndev_err(csi2->iss->dev, "CSI2: CSI2_96M_FCLK reset timeout!\n");\r\nreturn -EBUSY;\r\n}\r\niss_reg_update(csi2->iss, csi2->regs1, CSI2_SYSCONFIG,\r\nCSI2_SYSCONFIG_MSTANDBY_MODE_MASK |\r\nCSI2_SYSCONFIG_AUTO_IDLE,\r\nCSI2_SYSCONFIG_MSTANDBY_MODE_NO);\r\nreturn 0;\r\n}\r\nstatic int csi2_configure(struct iss_csi2_device *csi2)\r\n{\r\nconst struct iss_v4l2_subdevs_group *pdata;\r\nstruct iss_csi2_timing_cfg *timing = &csi2->timing[0];\r\nstruct v4l2_subdev *sensor;\r\nstruct media_pad *pad;\r\nif (csi2->contexts[0].enabled || csi2->ctrl.if_enable)\r\nreturn -EBUSY;\r\npad = media_entity_remote_pad(&csi2->pads[CSI2_PAD_SINK]);\r\nsensor = media_entity_to_v4l2_subdev(pad->entity);\r\npdata = sensor->host_priv;\r\ncsi2->frame_skip = 0;\r\nv4l2_subdev_call(sensor, sensor, g_skip_frames, &csi2->frame_skip);\r\ncsi2->ctrl.vp_out_ctrl = pdata->bus.csi2.vpclk_div;\r\ncsi2->ctrl.frame_mode = ISS_CSI2_FRAME_IMMEDIATE;\r\ncsi2->ctrl.ecc_enable = pdata->bus.csi2.crc;\r\ntiming->force_rx_mode = 1;\r\ntiming->stop_state_16x = 1;\r\ntiming->stop_state_4x = 1;\r\ntiming->stop_state_counter = 0x1ff;\r\nif (csi2->formats[CSI2_PAD_SINK].code !=\r\ncsi2->formats[CSI2_PAD_SOURCE].code)\r\ncsi2->dpcm_decompress = true;\r\nelse\r\ncsi2->dpcm_decompress = false;\r\ncsi2->contexts[0].format_id = csi2_ctx_map_format(csi2);\r\nif (csi2->video_out.bpl_padding == 0)\r\ncsi2->contexts[0].data_offset = 0;\r\nelse\r\ncsi2->contexts[0].data_offset = csi2->video_out.bpl_value;\r\ncsi2->contexts[0].eof_enabled = 1;\r\ncsi2->contexts[0].eol_enabled = 1;\r\ncsi2_irq_complexio1_set(csi2, 1);\r\ncsi2_irq_ctx_set(csi2, 1);\r\ncsi2_irq_status_set(csi2, 1);\r\ncsi2_timing_config(csi2, timing);\r\ncsi2_recv_config(csi2, &csi2->ctrl);\r\ncsi2_ctx_config(csi2, &csi2->contexts[0]);\r\nreturn 0;\r\n}\r\nstatic void csi2_print_status(struct iss_csi2_device *csi2)\r\n{\r\nstruct iss_device *iss = csi2->iss;\r\nif (!csi2->available)\r\nreturn;\r\ndev_dbg(iss->dev, "-------------CSI2 Register dump-------------\n");\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, SYSCONFIG);\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, SYSSTATUS);\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, IRQENABLE);\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, IRQSTATUS);\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, CTRL);\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, DBG_H);\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, COMPLEXIO_CFG);\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, COMPLEXIO_IRQSTATUS);\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, SHORT_PACKET);\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, COMPLEXIO_IRQENABLE);\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, DBG_P);\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, TIMING);\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_CTRL1(0));\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_CTRL2(0));\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_DAT_OFST(0));\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_PING_ADDR(0));\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_PONG_ADDR(0));\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_IRQENABLE(0));\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_IRQSTATUS(0));\r\nCSI2_PRINT_REGISTER(iss, csi2->regs1, CTX_CTRL3(0));\r\ndev_dbg(iss->dev, "--------------------------------------------\n");\r\n}\r\nstatic void csi2_isr_buffer(struct iss_csi2_device *csi2)\r\n{\r\nstruct iss_buffer *buffer;\r\ncsi2_ctx_enable(csi2, 0, 0);\r\nbuffer = omap4iss_video_buffer_next(&csi2->video_out);\r\nif (!buffer)\r\nreturn;\r\ncsi2_set_outaddr(csi2, buffer->iss_addr);\r\ncsi2_ctx_enable(csi2, 0, 1);\r\n}\r\nstatic void csi2_isr_ctx(struct iss_csi2_device *csi2,\r\nstruct iss_csi2_ctx_cfg *ctx)\r\n{\r\nunsigned int n = ctx->ctxnum;\r\nu32 status;\r\nstatus = iss_reg_read(csi2->iss, csi2->regs1, CSI2_CTX_IRQSTATUS(n));\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_CTX_IRQSTATUS(n), status);\r\nif (omap4iss_module_sync_is_stopping(&csi2->wait, &csi2->stopping))\r\nreturn;\r\nif (status & CSI2_CTX_IRQ_FS) {\r\nstruct iss_pipeline *pipe =\r\nto_iss_pipeline(&csi2->subdev.entity);\r\nu16 frame;\r\nu16 delta;\r\nframe = iss_reg_read(csi2->iss, csi2->regs1,\r\nCSI2_CTX_CTRL2(ctx->ctxnum))\r\n>> CSI2_CTX_CTRL2_FRAME_SHIFT;\r\nif (frame == 0) {\r\natomic_inc(&pipe->frame_number);\r\n} else {\r\ndelta = frame - ctx->frame;\r\nif (frame < ctx->frame)\r\ndelta--;\r\nctx->frame = frame;\r\natomic_add(delta, &pipe->frame_number);\r\n}\r\n}\r\nif (!(status & CSI2_CTX_IRQ_FE))\r\nreturn;\r\nif (csi2->frame_skip) {\r\ncsi2->frame_skip--;\r\nif (csi2->frame_skip == 0) {\r\nctx->format_id = csi2_ctx_map_format(csi2);\r\ncsi2_ctx_config(csi2, ctx);\r\ncsi2_ctx_enable(csi2, n, 1);\r\n}\r\nreturn;\r\n}\r\nif (csi2->output & CSI2_OUTPUT_MEMORY)\r\ncsi2_isr_buffer(csi2);\r\n}\r\nvoid omap4iss_csi2_isr(struct iss_csi2_device *csi2)\r\n{\r\nstruct iss_pipeline *pipe = to_iss_pipeline(&csi2->subdev.entity);\r\nu32 csi2_irqstatus, cpxio1_irqstatus;\r\nstruct iss_device *iss = csi2->iss;\r\nif (!csi2->available)\r\nreturn;\r\ncsi2_irqstatus = iss_reg_read(csi2->iss, csi2->regs1, CSI2_IRQSTATUS);\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_IRQSTATUS, csi2_irqstatus);\r\nif (csi2_irqstatus & CSI2_IRQ_COMPLEXIO_ERR) {\r\ncpxio1_irqstatus = iss_reg_read(csi2->iss, csi2->regs1,\r\nCSI2_COMPLEXIO_IRQSTATUS);\r\niss_reg_write(csi2->iss, csi2->regs1, CSI2_COMPLEXIO_IRQSTATUS,\r\ncpxio1_irqstatus);\r\ndev_dbg(iss->dev, "CSI2: ComplexIO Error IRQ %x\n",\r\ncpxio1_irqstatus);\r\npipe->error = true;\r\n}\r\nif (csi2_irqstatus & (CSI2_IRQ_OCP_ERR |\r\nCSI2_IRQ_SHORT_PACKET |\r\nCSI2_IRQ_ECC_NO_CORRECTION |\r\nCSI2_IRQ_COMPLEXIO_ERR |\r\nCSI2_IRQ_FIFO_OVF)) {\r\ndev_dbg(iss->dev,\r\n"CSI2 Err: OCP:%d SHORT:%d ECC:%d CPXIO:%d OVF:%d\n",\r\ncsi2_irqstatus & CSI2_IRQ_OCP_ERR ? 1 : 0,\r\ncsi2_irqstatus & CSI2_IRQ_SHORT_PACKET ? 1 : 0,\r\ncsi2_irqstatus & CSI2_IRQ_ECC_NO_CORRECTION ? 1 : 0,\r\ncsi2_irqstatus & CSI2_IRQ_COMPLEXIO_ERR ? 1 : 0,\r\ncsi2_irqstatus & CSI2_IRQ_FIFO_OVF ? 1 : 0);\r\npipe->error = true;\r\n}\r\nif (csi2_irqstatus & CSI2_IRQ_CONTEXT0)\r\ncsi2_isr_ctx(csi2, &csi2->contexts[0]);\r\nif (csi2_irqstatus & CSI2_IRQ_ECC_CORRECTION)\r\ndev_dbg(iss->dev, "CSI2: ECC correction done\n");\r\n}\r\nstatic int csi2_queue(struct iss_video *video, struct iss_buffer *buffer)\r\n{\r\nstruct iss_csi2_device *csi2 = container_of(video,\r\nstruct iss_csi2_device, video_out);\r\ncsi2_set_outaddr(csi2, buffer->iss_addr);\r\nif (csi2->video_out.dmaqueue_flags & ISS_VIDEO_DMAQUEUE_UNDERRUN) {\r\ncsi2_if_enable(csi2, 1);\r\ncsi2_ctx_enable(csi2, 0, 1);\r\niss_video_dmaqueue_flags_clr(&csi2->video_out);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__csi2_get_format(struct iss_csi2_device *csi2,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nunsigned int pad,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_format(&csi2->subdev, cfg, pad);\r\nreturn &csi2->formats[pad];\r\n}\r\nstatic void\r\ncsi2_try_format(struct iss_csi2_device *csi2,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nunsigned int pad,\r\nstruct v4l2_mbus_framefmt *fmt,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nu32 pixelcode;\r\nstruct v4l2_mbus_framefmt *format;\r\nconst struct iss_format_info *info;\r\nunsigned int i;\r\nswitch (pad) {\r\ncase CSI2_PAD_SINK:\r\nfor (i = 0; i < ARRAY_SIZE(csi2_input_fmts); i++) {\r\nif (fmt->code == csi2_input_fmts[i])\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(csi2_input_fmts))\r\nfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\r\nfmt->width = clamp_t(u32, fmt->width, 1, 8191);\r\nfmt->height = clamp_t(u32, fmt->height, 1, 8191);\r\nbreak;\r\ncase CSI2_PAD_SOURCE:\r\npixelcode = fmt->code;\r\nformat = __csi2_get_format(csi2, cfg, CSI2_PAD_SINK, which);\r\nmemcpy(fmt, format, sizeof(*fmt));\r\ninfo = omap4iss_video_format_info(fmt->code);\r\nif (info->uncompressed == pixelcode)\r\nfmt->code = pixelcode;\r\nbreak;\r\n}\r\nfmt->colorspace = V4L2_COLORSPACE_SRGB;\r\nfmt->field = V4L2_FIELD_NONE;\r\n}\r\nstatic int csi2_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nconst struct iss_format_info *info;\r\nif (code->pad == CSI2_PAD_SINK) {\r\nif (code->index >= ARRAY_SIZE(csi2_input_fmts))\r\nreturn -EINVAL;\r\ncode->code = csi2_input_fmts[code->index];\r\n} else {\r\nformat = __csi2_get_format(csi2, cfg, CSI2_PAD_SINK,\r\ncode->which);\r\nswitch (code->index) {\r\ncase 0:\r\ncode->code = format->code;\r\nbreak;\r\ncase 1:\r\ninfo = omap4iss_video_format_info(format->code);\r\nif (info->uncompressed == format->code)\r\nreturn -EINVAL;\r\ncode->code = info->uncompressed;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int csi2_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt format;\r\nif (fse->index != 0)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = 1;\r\nformat.height = 1;\r\ncsi2_try_format(csi2, cfg, fse->pad, &format, fse->which);\r\nfse->min_width = format.width;\r\nfse->min_height = format.height;\r\nif (format.code != fse->code)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = -1;\r\nformat.height = -1;\r\ncsi2_try_format(csi2, cfg, fse->pad, &format, fse->which);\r\nfse->max_width = format.width;\r\nfse->max_height = format.height;\r\nreturn 0;\r\n}\r\nstatic int csi2_get_format(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __csi2_get_format(csi2, cfg, fmt->pad, fmt->which);\r\nif (!format)\r\nreturn -EINVAL;\r\nfmt->format = *format;\r\nreturn 0;\r\n}\r\nstatic int csi2_set_format(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __csi2_get_format(csi2, cfg, fmt->pad, fmt->which);\r\nif (!format)\r\nreturn -EINVAL;\r\ncsi2_try_format(csi2, cfg, fmt->pad, &fmt->format, fmt->which);\r\n*format = fmt->format;\r\nif (fmt->pad == CSI2_PAD_SINK) {\r\nformat = __csi2_get_format(csi2, cfg, CSI2_PAD_SOURCE,\r\nfmt->which);\r\n*format = fmt->format;\r\ncsi2_try_format(csi2, cfg, CSI2_PAD_SOURCE, format, fmt->which);\r\n}\r\nreturn 0;\r\n}\r\nstatic int csi2_link_validate(struct v4l2_subdev *sd, struct media_link *link,\r\nstruct v4l2_subdev_format *source_fmt,\r\nstruct v4l2_subdev_format *sink_fmt)\r\n{\r\nstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nstruct iss_pipeline *pipe = to_iss_pipeline(&csi2->subdev.entity);\r\nint rval;\r\npipe->external = media_entity_to_v4l2_subdev(link->source->entity);\r\nrval = omap4iss_get_external_info(pipe, link);\r\nif (rval < 0)\r\nreturn rval;\r\nreturn v4l2_subdev_link_validate_default(sd, link, source_fmt,\r\nsink_fmt);\r\n}\r\nstatic int csi2_init_formats(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_subdev_format format;\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = CSI2_PAD_SINK;\r\nformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\r\nformat.format.code = MEDIA_BUS_FMT_SGRBG10_1X10;\r\nformat.format.width = 4096;\r\nformat.format.height = 4096;\r\ncsi2_set_format(sd, fh ? fh->pad : NULL, &format);\r\nreturn 0;\r\n}\r\nstatic int csi2_set_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nstruct iss_device *iss = csi2->iss;\r\nstruct iss_video *video_out = &csi2->video_out;\r\nint ret = 0;\r\nif (csi2->state == ISS_PIPELINE_STREAM_STOPPED) {\r\nif (enable == ISS_PIPELINE_STREAM_STOPPED)\r\nreturn 0;\r\nomap4iss_subclk_enable(iss, csi2->subclk);\r\n}\r\nswitch (enable) {\r\ncase ISS_PIPELINE_STREAM_CONTINUOUS: {\r\nret = omap4iss_csiphy_config(iss, sd);\r\nif (ret < 0)\r\nreturn ret;\r\nif (omap4iss_csiphy_acquire(csi2->phy) < 0)\r\nreturn -ENODEV;\r\ncsi2_configure(csi2);\r\ncsi2_print_status(csi2);\r\nif (csi2->output & CSI2_OUTPUT_MEMORY &&\r\n!(video_out->dmaqueue_flags & ISS_VIDEO_DMAQUEUE_QUEUED))\r\nbreak;\r\natomic_set(&csi2->stopping, 0);\r\ncsi2_ctx_enable(csi2, 0, 1);\r\ncsi2_if_enable(csi2, 1);\r\niss_video_dmaqueue_flags_clr(video_out);\r\nbreak;\r\n}\r\ncase ISS_PIPELINE_STREAM_STOPPED:\r\nif (csi2->state == ISS_PIPELINE_STREAM_STOPPED)\r\nreturn 0;\r\nif (omap4iss_module_sync_idle(&sd->entity, &csi2->wait,\r\n&csi2->stopping))\r\nret = -ETIMEDOUT;\r\ncsi2_ctx_enable(csi2, 0, 0);\r\ncsi2_if_enable(csi2, 0);\r\ncsi2_irq_ctx_set(csi2, 0);\r\nomap4iss_csiphy_release(csi2->phy);\r\nomap4iss_subclk_disable(iss, csi2->subclk);\r\niss_video_dmaqueue_flags_clr(video_out);\r\nbreak;\r\n}\r\ncsi2->state = enable;\r\nreturn ret;\r\n}\r\nstatic int csi2_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nstruct iss_csi2_ctrl_cfg *ctrl = &csi2->ctrl;\r\nunsigned int index = local->index;\r\nif (is_media_entity_v4l2_subdev(remote->entity))\r\nindex |= 2 << 16;\r\nswitch (index) {\r\ncase CSI2_PAD_SOURCE:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (csi2->output & ~CSI2_OUTPUT_MEMORY)\r\nreturn -EBUSY;\r\ncsi2->output |= CSI2_OUTPUT_MEMORY;\r\n} else {\r\ncsi2->output &= ~CSI2_OUTPUT_MEMORY;\r\n}\r\nbreak;\r\ncase CSI2_PAD_SOURCE | 2 << 16:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (csi2->output & ~CSI2_OUTPUT_IPIPEIF)\r\nreturn -EBUSY;\r\ncsi2->output |= CSI2_OUTPUT_IPIPEIF;\r\n} else {\r\ncsi2->output &= ~CSI2_OUTPUT_IPIPEIF;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nctrl->vp_only_enable = csi2->output & CSI2_OUTPUT_MEMORY ? false : true;\r\nctrl->vp_clk_enable = !!(csi2->output & CSI2_OUTPUT_IPIPEIF);\r\nreturn 0;\r\n}\r\nvoid omap4iss_csi2_unregister_entities(struct iss_csi2_device *csi2)\r\n{\r\nv4l2_device_unregister_subdev(&csi2->subdev);\r\nomap4iss_video_unregister(&csi2->video_out);\r\n}\r\nint omap4iss_csi2_register_entities(struct iss_csi2_device *csi2,\r\nstruct v4l2_device *vdev)\r\n{\r\nint ret;\r\nret = v4l2_device_register_subdev(vdev, &csi2->subdev);\r\nif (ret < 0)\r\ngoto error;\r\nret = omap4iss_video_register(&csi2->video_out, vdev);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nomap4iss_csi2_unregister_entities(csi2);\r\nreturn ret;\r\n}\r\nstatic int csi2_init_entities(struct iss_csi2_device *csi2, const char *subname)\r\n{\r\nstruct v4l2_subdev *sd = &csi2->subdev;\r\nstruct media_pad *pads = csi2->pads;\r\nstruct media_entity *me = &sd->entity;\r\nint ret;\r\nchar name[V4L2_SUBDEV_NAME_SIZE];\r\nv4l2_subdev_init(sd, &csi2_ops);\r\nsd->internal_ops = &csi2_internal_ops;\r\nsnprintf(name, sizeof(name), "CSI2%s", subname);\r\nsnprintf(sd->name, sizeof(sd->name), "OMAP4 ISS %s", name);\r\nsd->grp_id = BIT(16);\r\nv4l2_set_subdevdata(sd, csi2);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\npads[CSI2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\npads[CSI2_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\nme->ops = &csi2_media_ops;\r\nret = media_entity_pads_init(me, CSI2_PADS_NUM, pads);\r\nif (ret < 0)\r\nreturn ret;\r\ncsi2_init_formats(sd, NULL);\r\ncsi2->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ncsi2->video_out.ops = &csi2_issvideo_ops;\r\ncsi2->video_out.bpl_alignment = 32;\r\ncsi2->video_out.bpl_zero_padding = 1;\r\ncsi2->video_out.bpl_max = 0x1ffe0;\r\ncsi2->video_out.iss = csi2->iss;\r\ncsi2->video_out.capture_mem = PAGE_ALIGN(4096 * 4096) * 3;\r\nret = omap4iss_video_init(&csi2->video_out, name);\r\nif (ret < 0)\r\ngoto error_video;\r\nreturn 0;\r\nerror_video:\r\nmedia_entity_cleanup(&csi2->subdev.entity);\r\nreturn ret;\r\n}\r\nint omap4iss_csi2_init(struct iss_device *iss)\r\n{\r\nstruct iss_csi2_device *csi2a = &iss->csi2a;\r\nstruct iss_csi2_device *csi2b = &iss->csi2b;\r\nint ret;\r\ncsi2a->iss = iss;\r\ncsi2a->available = 1;\r\ncsi2a->regs1 = OMAP4_ISS_MEM_CSI2_A_REGS1;\r\ncsi2a->phy = &iss->csiphy1;\r\ncsi2a->subclk = OMAP4_ISS_SUBCLK_CSI2_A;\r\ncsi2a->state = ISS_PIPELINE_STREAM_STOPPED;\r\ninit_waitqueue_head(&csi2a->wait);\r\nret = csi2_init_entities(csi2a, "a");\r\nif (ret < 0)\r\nreturn ret;\r\ncsi2b->iss = iss;\r\ncsi2b->available = 1;\r\ncsi2b->regs1 = OMAP4_ISS_MEM_CSI2_B_REGS1;\r\ncsi2b->phy = &iss->csiphy2;\r\ncsi2b->subclk = OMAP4_ISS_SUBCLK_CSI2_B;\r\ncsi2b->state = ISS_PIPELINE_STREAM_STOPPED;\r\ninit_waitqueue_head(&csi2b->wait);\r\nret = csi2_init_entities(csi2b, "b");\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint omap4iss_csi2_create_links(struct iss_device *iss)\r\n{\r\nstruct iss_csi2_device *csi2a = &iss->csi2a;\r\nstruct iss_csi2_device *csi2b = &iss->csi2b;\r\nint ret;\r\nret = media_create_pad_link(&csi2a->subdev.entity, CSI2_PAD_SOURCE,\r\n&csi2a->video_out.video.entity, 0, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = media_create_pad_link(&csi2b->subdev.entity, CSI2_PAD_SOURCE,\r\n&csi2b->video_out.video.entity, 0, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nvoid omap4iss_csi2_cleanup(struct iss_device *iss)\r\n{\r\nstruct iss_csi2_device *csi2a = &iss->csi2a;\r\nstruct iss_csi2_device *csi2b = &iss->csi2b;\r\nomap4iss_video_cleanup(&csi2a->video_out);\r\nmedia_entity_cleanup(&csi2a->subdev.entity);\r\nomap4iss_video_cleanup(&csi2b->video_out);\r\nmedia_entity_cleanup(&csi2b->subdev.entity);\r\n}
