enum dlm_status dlmconvert_master(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res,\r\nstruct dlm_lock *lock, int flags, int type)\r\n{\r\nint call_ast = 0, kick_thread = 0;\r\nenum dlm_status status;\r\nspin_lock(&res->spinlock);\r\n__dlm_wait_on_lockres(res);\r\n__dlm_lockres_reserve_ast(res);\r\nres->state |= DLM_LOCK_RES_IN_PROGRESS;\r\nstatus = __dlmconvert_master(dlm, res, lock, flags, type,\r\n&call_ast, &kick_thread);\r\nres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\r\nspin_unlock(&res->spinlock);\r\nwake_up(&res->wq);\r\nif (status != DLM_NORMAL && status != DLM_NOTQUEUED)\r\ndlm_error(status);\r\nif (call_ast)\r\ndlm_queue_ast(dlm, lock);\r\nelse\r\ndlm_lockres_release_ast(dlm, res);\r\nif (kick_thread)\r\ndlm_kick_thread(dlm, res);\r\nreturn status;\r\n}\r\nstatic enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res,\r\nstruct dlm_lock *lock, int flags,\r\nint type, int *call_ast,\r\nint *kick_thread)\r\n{\r\nenum dlm_status status = DLM_NORMAL;\r\nstruct dlm_lock *tmplock=NULL;\r\nassert_spin_locked(&res->spinlock);\r\nmlog(0, "type=%d, convert_type=%d, new convert_type=%d\n",\r\nlock->ml.type, lock->ml.convert_type, type);\r\nspin_lock(&lock->spinlock);\r\nif (lock->ml.convert_type != LKM_IVMODE) {\r\nmlog(ML_ERROR, "attempted to convert a lock with a lock "\r\n"conversion pending\n");\r\nstatus = DLM_DENIED;\r\ngoto unlock_exit;\r\n}\r\nif (!dlm_lock_on_list(&res->granted, lock)) {\r\nmlog(ML_ERROR, "attempted to convert a lock not on grant "\r\n"queue\n");\r\nstatus = DLM_DENIED;\r\ngoto unlock_exit;\r\n}\r\nif (flags & LKM_VALBLK) {\r\nswitch (lock->ml.type) {\r\ncase LKM_EXMODE:\r\nmlog(0, "will set lvb: converting %s->%s\n",\r\ndlm_lock_mode_name(lock->ml.type),\r\ndlm_lock_mode_name(type));\r\nlock->lksb->flags |= DLM_LKSB_PUT_LVB;\r\nbreak;\r\ncase LKM_PRMODE:\r\ncase LKM_NLMODE:\r\nif (type > LKM_NLMODE) {\r\nmlog(0, "will fetch new value into "\r\n"lvb: converting %s->%s\n",\r\ndlm_lock_mode_name(lock->ml.type),\r\ndlm_lock_mode_name(type));\r\nlock->lksb->flags |= DLM_LKSB_GET_LVB;\r\n} else {\r\nmlog(0, "will NOT fetch new value "\r\n"into lvb: converting %s->%s\n",\r\ndlm_lock_mode_name(lock->ml.type),\r\ndlm_lock_mode_name(type));\r\nflags &= ~(LKM_VALBLK);\r\n}\r\nbreak;\r\n}\r\n}\r\nif (type <= lock->ml.type)\r\ngoto grant;\r\nstatus = DLM_NORMAL;\r\nlist_for_each_entry(tmplock, &res->granted, list) {\r\nif (tmplock == lock)\r\ncontinue;\r\nif (!dlm_lock_compatible(tmplock->ml.type, type))\r\ngoto switch_queues;\r\n}\r\nlist_for_each_entry(tmplock, &res->converting, list) {\r\nif (!dlm_lock_compatible(tmplock->ml.type, type))\r\ngoto switch_queues;\r\nif (!dlm_lock_compatible(tmplock->ml.convert_type, type))\r\ngoto switch_queues;\r\n}\r\ngrant:\r\nmlog(0, "res %.*s, granting %s lock\n", res->lockname.len,\r\nres->lockname.name, dlm_lock_mode_name(type));\r\nlock->lksb->status = DLM_NORMAL;\r\nif (lock->ml.node == dlm->node_num)\r\nmlog(0, "doing in-place convert for nonlocal lock\n");\r\nlock->ml.type = type;\r\nif (lock->lksb->flags & DLM_LKSB_PUT_LVB)\r\nmemcpy(res->lvb, lock->lksb->lvb, DLM_LVB_LEN);\r\nlist_move_tail(&lock->list, &res->granted);\r\nstatus = DLM_NORMAL;\r\n*call_ast = 1;\r\ngoto unlock_exit;\r\nswitch_queues:\r\nif (flags & LKM_NOQUEUE) {\r\nmlog(0, "failed to convert NOQUEUE lock %.*s from "\r\n"%d to %d...\n", res->lockname.len, res->lockname.name,\r\nlock->ml.type, type);\r\nstatus = DLM_NOTQUEUED;\r\ngoto unlock_exit;\r\n}\r\nmlog(0, "res %.*s, queueing...\n", res->lockname.len,\r\nres->lockname.name);\r\nlock->ml.convert_type = type;\r\nlist_move_tail(&lock->list, &res->converting);\r\nunlock_exit:\r\nspin_unlock(&lock->spinlock);\r\nif (status == DLM_DENIED) {\r\n__dlm_print_one_lock_resource(res);\r\n}\r\nif (status == DLM_NORMAL)\r\n*kick_thread = 1;\r\nreturn status;\r\n}\r\nvoid dlm_revert_pending_convert(struct dlm_lock_resource *res,\r\nstruct dlm_lock *lock)\r\n{\r\nlist_move_tail(&lock->list, &res->granted);\r\nlock->ml.convert_type = LKM_IVMODE;\r\nlock->lksb->flags &= ~(DLM_LKSB_GET_LVB|DLM_LKSB_PUT_LVB);\r\n}\r\nenum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res,\r\nstruct dlm_lock *lock, int flags, int type)\r\n{\r\nenum dlm_status status;\r\nmlog(0, "type=%d, convert_type=%d, busy=%d\n", lock->ml.type,\r\nlock->ml.convert_type, res->state & DLM_LOCK_RES_IN_PROGRESS);\r\nspin_lock(&res->spinlock);\r\nif (res->state & DLM_LOCK_RES_RECOVERING) {\r\nmlog(0, "bailing out early since res is RECOVERING "\r\n"on secondary queue\n");\r\nstatus = DLM_RECOVERING;\r\ngoto bail;\r\n}\r\n__dlm_wait_on_lockres(res);\r\nif (lock->ml.convert_type != LKM_IVMODE) {\r\n__dlm_print_one_lock_resource(res);\r\nmlog(ML_ERROR, "converting a remote lock that is already "\r\n"converting! (cookie=%u:%llu, conv=%d)\n",\r\ndlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\r\nlock->ml.convert_type);\r\nstatus = DLM_DENIED;\r\ngoto bail;\r\n}\r\nif (lock->ml.type == type && lock->ml.convert_type == LKM_IVMODE) {\r\nmlog(0, "last convert request returned DLM_RECOVERING, but "\r\n"owner has already queued and sent ast to me. res %.*s, "\r\n"(cookie=%u:%llu, type=%d, conv=%d)\n",\r\nres->lockname.len, res->lockname.name,\r\ndlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\r\nlock->ml.type, lock->ml.convert_type);\r\nstatus = DLM_NORMAL;\r\ngoto bail;\r\n}\r\nres->state |= DLM_LOCK_RES_IN_PROGRESS;\r\nlist_move_tail(&lock->list, &res->converting);\r\nlock->convert_pending = 1;\r\nlock->ml.convert_type = type;\r\nif (flags & LKM_VALBLK) {\r\nif (lock->ml.type == LKM_EXMODE) {\r\nflags |= LKM_PUT_LVB;\r\nlock->lksb->flags |= DLM_LKSB_PUT_LVB;\r\n} else {\r\nif (lock->ml.convert_type == LKM_NLMODE)\r\nflags &= ~LKM_VALBLK;\r\nelse {\r\nflags |= LKM_GET_LVB;\r\nlock->lksb->flags |= DLM_LKSB_GET_LVB;\r\n}\r\n}\r\n}\r\nspin_unlock(&res->spinlock);\r\nstatus = dlm_send_remote_convert_request(dlm, res, lock, flags, type);\r\nspin_lock(&res->spinlock);\r\nres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\r\nif (status != DLM_NORMAL) {\r\nif (status != DLM_NOTQUEUED)\r\ndlm_error(status);\r\ndlm_revert_pending_convert(res, lock);\r\n} else if (!lock->convert_pending) {\r\nmlog(0, "%s: res %.*s, owner died and lock has been moved back "\r\n"to granted list, retry convert.\n",\r\ndlm->name, res->lockname.len, res->lockname.name);\r\nstatus = DLM_RECOVERING;\r\n}\r\nlock->convert_pending = 0;\r\nbail:\r\nspin_unlock(&res->spinlock);\r\nwake_up(&res->wq);\r\nreturn status;\r\n}\r\nstatic enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res,\r\nstruct dlm_lock *lock, int flags, int type)\r\n{\r\nstruct dlm_convert_lock convert;\r\nint tmpret;\r\nenum dlm_status ret;\r\nint status = 0;\r\nstruct kvec vec[2];\r\nsize_t veclen = 1;\r\nmlog(0, "%.*s\n", res->lockname.len, res->lockname.name);\r\nmemset(&convert, 0, sizeof(struct dlm_convert_lock));\r\nconvert.node_idx = dlm->node_num;\r\nconvert.requested_type = type;\r\nconvert.cookie = lock->ml.cookie;\r\nconvert.namelen = res->lockname.len;\r\nconvert.flags = cpu_to_be32(flags);\r\nmemcpy(convert.name, res->lockname.name, convert.namelen);\r\nvec[0].iov_len = sizeof(struct dlm_convert_lock);\r\nvec[0].iov_base = &convert;\r\nif (flags & LKM_PUT_LVB) {\r\nvec[1].iov_len = DLM_LVB_LEN;\r\nvec[1].iov_base = lock->lksb->lvb;\r\nveclen++;\r\n}\r\ntmpret = o2net_send_message_vec(DLM_CONVERT_LOCK_MSG, dlm->key,\r\nvec, veclen, res->owner, &status);\r\nif (tmpret >= 0) {\r\nret = status;\r\nif (ret == DLM_RECOVERING) {\r\nmlog(0, "node %u returned DLM_RECOVERING from convert "\r\n"message!\n", res->owner);\r\n} else if (ret == DLM_MIGRATING) {\r\nmlog(0, "node %u returned DLM_MIGRATING from convert "\r\n"message!\n", res->owner);\r\n} else if (ret == DLM_FORWARD) {\r\nmlog(0, "node %u returned DLM_FORWARD from convert "\r\n"message!\n", res->owner);\r\n} else if (ret != DLM_NORMAL && ret != DLM_NOTQUEUED)\r\ndlm_error(ret);\r\n} else {\r\nmlog(ML_ERROR, "Error %d when sending message %u (key 0x%x) to "\r\n"node %u\n", tmpret, DLM_CONVERT_LOCK_MSG, dlm->key,\r\nres->owner);\r\nif (dlm_is_host_down(tmpret)) {\r\ndlm_wait_for_node_death(dlm, res->owner,\r\nDLM_NODE_DEATH_WAIT_MAX);\r\nret = DLM_RECOVERING;\r\nmlog(0, "node %u died so returning DLM_RECOVERING "\r\n"from convert message!\n", res->owner);\r\n} else {\r\nret = dlm_err_to_dlm_status(tmpret);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint dlm_convert_lock_handler(struct o2net_msg *msg, u32 len, void *data,\r\nvoid **ret_data)\r\n{\r\nstruct dlm_ctxt *dlm = data;\r\nstruct dlm_convert_lock *cnv = (struct dlm_convert_lock *)msg->buf;\r\nstruct dlm_lock_resource *res = NULL;\r\nstruct dlm_lock *lock = NULL;\r\nstruct dlm_lock *tmp_lock;\r\nstruct dlm_lockstatus *lksb;\r\nenum dlm_status status = DLM_NORMAL;\r\nu32 flags;\r\nint call_ast = 0, kick_thread = 0, ast_reserved = 0, wake = 0;\r\nif (!dlm_grab(dlm)) {\r\ndlm_error(DLM_REJECTED);\r\nreturn DLM_REJECTED;\r\n}\r\nmlog_bug_on_msg(!dlm_domain_fully_joined(dlm),\r\n"Domain %s not fully joined!\n", dlm->name);\r\nif (cnv->namelen > DLM_LOCKID_NAME_MAX) {\r\nstatus = DLM_IVBUFLEN;\r\ndlm_error(status);\r\ngoto leave;\r\n}\r\nflags = be32_to_cpu(cnv->flags);\r\nif ((flags & (LKM_PUT_LVB|LKM_GET_LVB)) ==\r\n(LKM_PUT_LVB|LKM_GET_LVB)) {\r\nmlog(ML_ERROR, "both PUT and GET lvb specified\n");\r\nstatus = DLM_BADARGS;\r\ngoto leave;\r\n}\r\nmlog(0, "lvb: %s\n", flags & LKM_PUT_LVB ? "put lvb" :\r\n(flags & LKM_GET_LVB ? "get lvb" : "none"));\r\nstatus = DLM_IVLOCKID;\r\nres = dlm_lookup_lockres(dlm, cnv->name, cnv->namelen);\r\nif (!res) {\r\ndlm_error(status);\r\ngoto leave;\r\n}\r\nspin_lock(&res->spinlock);\r\nstatus = __dlm_lockres_state_to_status(res);\r\nif (status != DLM_NORMAL) {\r\nspin_unlock(&res->spinlock);\r\ndlm_error(status);\r\ngoto leave;\r\n}\r\nlist_for_each_entry(tmp_lock, &res->granted, list) {\r\nif (tmp_lock->ml.cookie == cnv->cookie &&\r\ntmp_lock->ml.node == cnv->node_idx) {\r\nlock = tmp_lock;\r\ndlm_lock_get(lock);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&res->spinlock);\r\nif (!lock) {\r\nstatus = DLM_IVLOCKID;\r\nmlog(ML_ERROR, "did not find lock to convert on grant queue! "\r\n"cookie=%u:%llu\n",\r\ndlm_get_lock_cookie_node(be64_to_cpu(cnv->cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(cnv->cookie)));\r\ndlm_print_one_lock_resource(res);\r\ngoto leave;\r\n}\r\nlksb = lock->lksb;\r\nif (flags & LKM_PUT_LVB) {\r\nBUG_ON(lksb->flags & (DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB));\r\nlksb->flags |= DLM_LKSB_PUT_LVB;\r\nmemcpy(&lksb->lvb[0], &cnv->lvb[0], DLM_LVB_LEN);\r\n} else if (flags & LKM_GET_LVB) {\r\nBUG_ON(lksb->flags & (DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB));\r\nlksb->flags |= DLM_LKSB_GET_LVB;\r\n}\r\nspin_lock(&res->spinlock);\r\nstatus = __dlm_lockres_state_to_status(res);\r\nif (status == DLM_NORMAL) {\r\n__dlm_lockres_reserve_ast(res);\r\nast_reserved = 1;\r\nres->state |= DLM_LOCK_RES_IN_PROGRESS;\r\nstatus = __dlmconvert_master(dlm, res, lock, flags,\r\ncnv->requested_type,\r\n&call_ast, &kick_thread);\r\nres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\r\nwake = 1;\r\n}\r\nspin_unlock(&res->spinlock);\r\nif (wake)\r\nwake_up(&res->wq);\r\nif (status != DLM_NORMAL) {\r\nif (status != DLM_NOTQUEUED)\r\ndlm_error(status);\r\nlksb->flags &= ~(DLM_LKSB_GET_LVB|DLM_LKSB_PUT_LVB);\r\n}\r\nleave:\r\nif (lock)\r\ndlm_lock_put(lock);\r\nif (call_ast)\r\ndlm_queue_ast(dlm, lock);\r\nelse if (ast_reserved)\r\ndlm_lockres_release_ast(dlm, res);\r\nif (kick_thread)\r\ndlm_kick_thread(dlm, res);\r\nif (res)\r\ndlm_lockres_put(res);\r\ndlm_put(dlm);\r\nreturn status;\r\n}
