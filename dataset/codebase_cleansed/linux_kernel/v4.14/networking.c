static int skb_to_mamac(const struct sk_buff *skb, struct mbo *mbo)\r\n{\r\nu8 *buff = mbo->virt_address;\r\nconst u8 broadcast[] = { 0x03, 0xFF };\r\nconst u8 *dest_addr = skb->data + 4;\r\nconst u8 *eth_type = skb->data + 12;\r\nunsigned int payload_len = skb->len - ETH_HLEN;\r\nunsigned int mdp_len = payload_len + MDP_HDR_LEN;\r\nif (mbo->buffer_length < mdp_len) {\r\npr_err("drop: too small buffer! (%d for %d)\n",\r\nmbo->buffer_length, mdp_len);\r\nreturn -EINVAL;\r\n}\r\nif (skb->len < ETH_HLEN) {\r\npr_err("drop: too small packet! (%d)\n", skb->len);\r\nreturn -EINVAL;\r\n}\r\nif (dest_addr[0] == 0xFF && dest_addr[1] == 0xFF)\r\ndest_addr = broadcast;\r\n*buff++ = HB(mdp_len - 2);\r\n*buff++ = LB(mdp_len - 2);\r\n*buff++ = PMHL;\r\n*buff++ = (PMS_FIFONO_MDP << PMS_FIFONO_SHIFT) | PMS_MSGTYPE_DATA;\r\n*buff++ = PMS_DEF_PRIO;\r\n*buff++ = dest_addr[0];\r\n*buff++ = dest_addr[1];\r\n*buff++ = 0x00;\r\n*buff++ = HB(payload_len + 6);\r\n*buff++ = LB(payload_len + 6);\r\n*buff++ = eth_type[0];\r\n*buff++ = eth_type[1];\r\n*buff++ = 0;\r\n*buff++ = 0;\r\n*buff++ = PMS_TELID_UNSEGM_MAMAC << 4 | HB(payload_len);\r\n*buff++ = LB(payload_len);\r\nmemcpy(buff, skb->data + ETH_HLEN, payload_len);\r\nmbo->buffer_length = mdp_len;\r\nreturn 0;\r\n}\r\nstatic int skb_to_mep(const struct sk_buff *skb, struct mbo *mbo)\r\n{\r\nu8 *buff = mbo->virt_address;\r\nunsigned int mep_len = skb->len + MEP_HDR_LEN;\r\nif (mbo->buffer_length < mep_len) {\r\npr_err("drop: too small buffer! (%d for %d)\n",\r\nmbo->buffer_length, mep_len);\r\nreturn -EINVAL;\r\n}\r\n*buff++ = HB(mep_len - 2);\r\n*buff++ = LB(mep_len - 2);\r\n*buff++ = PMHL;\r\n*buff++ = (PMS_FIFONO_MEP << PMS_FIFONO_SHIFT) | PMS_MSGTYPE_DATA;\r\n*buff++ = (MEP_DEF_RETRY << PMS_RETRY_SHIFT) | PMS_DEF_PRIO;\r\n*buff++ = 0;\r\n*buff++ = 0;\r\n*buff++ = 0;\r\nmemcpy(buff, skb->data, skb->len);\r\nmbo->buffer_length = mep_len;\r\nreturn 0;\r\n}\r\nstatic int most_nd_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct net_dev_context *nd = netdev_priv(dev);\r\nint err = eth_mac_addr(dev, p);\r\nif (err)\r\nreturn err;\r\nnd->is_mamac =\r\n(dev->dev_addr[0] == 0 && dev->dev_addr[1] == 0 &&\r\ndev->dev_addr[2] == 0 && dev->dev_addr[3] == 0);\r\ndev->mtu = nd->is_mamac ? MAMAC_DATA_LEN : ETH_DATA_LEN;\r\nreturn 0;\r\n}\r\nstatic int most_nd_open(struct net_device *dev)\r\n{\r\nstruct net_dev_context *nd = netdev_priv(dev);\r\nint ret = 0;\r\nmutex_lock(&probe_disc_mt);\r\nif (most_start_channel(nd->iface, nd->rx.ch_id, &aim)) {\r\nnetdev_err(dev, "most_start_channel() failed\n");\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\nif (most_start_channel(nd->iface, nd->tx.ch_id, &aim)) {\r\nnetdev_err(dev, "most_start_channel() failed\n");\r\nmost_stop_channel(nd->iface, nd->rx.ch_id, &aim);\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\nnetif_carrier_off(dev);\r\nif (is_valid_ether_addr(dev->dev_addr))\r\nnetif_dormant_off(dev);\r\nelse\r\nnetif_dormant_on(dev);\r\nnetif_wake_queue(dev);\r\nif (nd->iface->request_netinfo)\r\nnd->iface->request_netinfo(nd->iface, nd->tx.ch_id, on_netinfo);\r\nunlock:\r\nmutex_unlock(&probe_disc_mt);\r\nreturn ret;\r\n}\r\nstatic int most_nd_stop(struct net_device *dev)\r\n{\r\nstruct net_dev_context *nd = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nif (nd->iface->request_netinfo)\r\nnd->iface->request_netinfo(nd->iface, nd->tx.ch_id, NULL);\r\nmost_stop_channel(nd->iface, nd->rx.ch_id, &aim);\r\nmost_stop_channel(nd->iface, nd->tx.ch_id, &aim);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t most_nd_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct net_dev_context *nd = netdev_priv(dev);\r\nstruct mbo *mbo;\r\nint ret;\r\nmbo = most_get_mbo(nd->iface, nd->tx.ch_id, &aim);\r\nif (!mbo) {\r\nnetif_stop_queue(dev);\r\ndev->stats.tx_fifo_errors++;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (nd->is_mamac)\r\nret = skb_to_mamac(skb, mbo);\r\nelse\r\nret = skb_to_mep(skb, mbo);\r\nif (ret) {\r\nmost_put_mbo(mbo);\r\ndev->stats.tx_dropped++;\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nmost_submit_mbo(mbo);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void most_nd_setup(struct net_device *dev)\r\n{\r\nether_setup(dev);\r\ndev->netdev_ops = &most_nd_ops;\r\n}\r\nstatic struct net_dev_context *get_net_dev(struct most_interface *iface)\r\n{\r\nstruct net_dev_context *nd;\r\nlist_for_each_entry(nd, &net_devices, list)\r\nif (nd->iface == iface)\r\nreturn nd;\r\nreturn NULL;\r\n}\r\nstatic struct net_dev_context *get_net_dev_hold(struct most_interface *iface)\r\n{\r\nstruct net_dev_context *nd;\r\nunsigned long flags;\r\nspin_lock_irqsave(&list_lock, flags);\r\nnd = get_net_dev(iface);\r\nif (nd && nd->rx.linked && nd->tx.linked)\r\ndev_hold(nd->dev);\r\nelse\r\nnd = NULL;\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nreturn nd;\r\n}\r\nstatic int aim_probe_channel(struct most_interface *iface, int channel_idx,\r\nstruct most_channel_config *ccfg,\r\nstruct kobject *parent, char *name)\r\n{\r\nstruct net_dev_context *nd;\r\nstruct net_dev_channel *ch;\r\nstruct net_device *dev;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (!iface)\r\nreturn -EINVAL;\r\nif (ccfg->data_type != MOST_CH_ASYNC)\r\nreturn -EINVAL;\r\nmutex_lock(&probe_disc_mt);\r\nnd = get_net_dev(iface);\r\nif (!nd) {\r\ndev = alloc_netdev(sizeof(struct net_dev_context), "meth%d",\r\nNET_NAME_UNKNOWN, most_nd_setup);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto unlock;\r\n}\r\nnd = netdev_priv(dev);\r\nnd->iface = iface;\r\nnd->dev = dev;\r\nspin_lock_irqsave(&list_lock, flags);\r\nlist_add(&nd->list, &net_devices);\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nch = ccfg->direction == MOST_CH_TX ? &nd->tx : &nd->rx;\r\n} else {\r\nch = ccfg->direction == MOST_CH_TX ? &nd->tx : &nd->rx;\r\nif (ch->linked) {\r\npr_err("direction is allocated\n");\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nif (register_netdev(nd->dev)) {\r\npr_err("register_netdev() failed\n");\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\n}\r\nch->ch_id = channel_idx;\r\nch->linked = true;\r\nunlock:\r\nmutex_unlock(&probe_disc_mt);\r\nreturn ret;\r\n}\r\nstatic int aim_disconnect_channel(struct most_interface *iface,\r\nint channel_idx)\r\n{\r\nstruct net_dev_context *nd;\r\nstruct net_dev_channel *ch;\r\nunsigned long flags;\r\nint ret = 0;\r\nmutex_lock(&probe_disc_mt);\r\nnd = get_net_dev(iface);\r\nif (!nd) {\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nif (nd->rx.linked && channel_idx == nd->rx.ch_id) {\r\nch = &nd->rx;\r\n} else if (nd->tx.linked && channel_idx == nd->tx.ch_id) {\r\nch = &nd->tx;\r\n} else {\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nif (nd->rx.linked && nd->tx.linked) {\r\nspin_lock_irqsave(&list_lock, flags);\r\nch->linked = false;\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nunregister_netdev(nd->dev);\r\n} else {\r\nspin_lock_irqsave(&list_lock, flags);\r\nlist_del(&nd->list);\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nfree_netdev(nd->dev);\r\n}\r\nunlock:\r\nmutex_unlock(&probe_disc_mt);\r\nreturn ret;\r\n}\r\nstatic int aim_resume_tx_channel(struct most_interface *iface,\r\nint channel_idx)\r\n{\r\nstruct net_dev_context *nd;\r\nnd = get_net_dev_hold(iface);\r\nif (!nd)\r\nreturn 0;\r\nif (nd->tx.ch_id != channel_idx)\r\ngoto put_nd;\r\nnetif_wake_queue(nd->dev);\r\nput_nd:\r\ndev_put(nd->dev);\r\nreturn 0;\r\n}\r\nstatic int aim_rx_data(struct mbo *mbo)\r\n{\r\nconst u32 zero = 0;\r\nstruct net_dev_context *nd;\r\nchar *buf = mbo->virt_address;\r\nu32 len = mbo->processed_length;\r\nstruct sk_buff *skb;\r\nstruct net_device *dev;\r\nunsigned int skb_len;\r\nint ret = 0;\r\nnd = get_net_dev_hold(mbo->ifp);\r\nif (!nd)\r\nreturn -EIO;\r\nif (nd->rx.ch_id != mbo->hdm_channel_id) {\r\nret = -EIO;\r\ngoto put_nd;\r\n}\r\ndev = nd->dev;\r\nif (nd->is_mamac) {\r\nif (!PMS_IS_MAMAC(buf, len)) {\r\nret = -EIO;\r\ngoto put_nd;\r\n}\r\nskb = dev_alloc_skb(len - MDP_HDR_LEN + 2 * ETH_ALEN + 2);\r\n} else {\r\nif (!PMS_IS_MEP(buf, len)) {\r\nret = -EIO;\r\ngoto put_nd;\r\n}\r\nskb = dev_alloc_skb(len - MEP_HDR_LEN);\r\n}\r\nif (!skb) {\r\ndev->stats.rx_dropped++;\r\npr_err_once("drop packet: no memory for skb\n");\r\ngoto out;\r\n}\r\nskb->dev = dev;\r\nif (nd->is_mamac) {\r\nether_addr_copy(skb_put(skb, ETH_ALEN), dev->dev_addr);\r\nskb_put_data(skb, &zero, 4);\r\nskb_put_data(skb, buf + 5, 2);\r\nskb_put_data(skb, buf + 10, 2);\r\nbuf += MDP_HDR_LEN;\r\nlen -= MDP_HDR_LEN;\r\n} else {\r\nbuf += MEP_HDR_LEN;\r\nlen -= MEP_HDR_LEN;\r\n}\r\nskb_put_data(skb, buf, len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nskb_len = skb->len;\r\nif (netif_rx(skb) == NET_RX_SUCCESS) {\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb_len;\r\n} else {\r\ndev->stats.rx_dropped++;\r\n}\r\nout:\r\nmost_put_mbo(mbo);\r\nput_nd:\r\ndev_put(nd->dev);\r\nreturn ret;\r\n}\r\nstatic int __init most_net_init(void)\r\n{\r\nspin_lock_init(&list_lock);\r\nmutex_init(&probe_disc_mt);\r\nreturn most_register_aim(&aim);\r\n}\r\nstatic void __exit most_net_exit(void)\r\n{\r\nmost_deregister_aim(&aim);\r\n}\r\nstatic void on_netinfo(struct most_interface *iface,\r\nunsigned char link_stat, unsigned char *mac_addr)\r\n{\r\nstruct net_dev_context *nd;\r\nstruct net_device *dev;\r\nconst u8 *m = mac_addr;\r\nnd = get_net_dev_hold(iface);\r\nif (!nd)\r\nreturn;\r\ndev = nd->dev;\r\nif (link_stat)\r\nnetif_carrier_on(dev);\r\nelse\r\nnetif_carrier_off(dev);\r\nif (m && is_valid_ether_addr(m)) {\r\nif (!is_valid_ether_addr(dev->dev_addr)) {\r\nnetdev_info(dev, "set mac %02x-%02x-%02x-%02x-%02x-%02x\n",\r\nm[0], m[1], m[2], m[3], m[4], m[5]);\r\nether_addr_copy(dev->dev_addr, m);\r\nnetif_dormant_off(dev);\r\n} else if (!ether_addr_equal(dev->dev_addr, m)) {\r\nnetdev_warn(dev, "reject mac %02x-%02x-%02x-%02x-%02x-%02x\n",\r\nm[0], m[1], m[2], m[3], m[4], m[5]);\r\n}\r\n}\r\ndev_put(nd->dev);\r\n}
