static void\r\nl2m_debug(struct FsmInst *fi, char *fmt, ...)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct va_format vaf;\r\nva_list va;\r\nif (!(*debug & DEBUG_L2_FSM))\r\nreturn;\r\nva_start(va, fmt);\r\nvaf.fmt = fmt;\r\nvaf.va = &va;\r\nprintk(KERN_DEBUG "%s l2 (sapi %d tei %d): %pV\n",\r\nmISDNDevName4ch(&l2->ch), l2->sapi, l2->tei, &vaf);\r\nva_end(va);\r\n}\r\ninline u_int\r\nl2headersize(struct layer2 *l2, int ui)\r\n{\r\nreturn ((test_bit(FLG_MOD128, &l2->flag) && (!ui)) ? 2 : 1) +\r\n(test_bit(FLG_LAPD, &l2->flag) ? 2 : 1);\r\n}\r\ninline u_int\r\nl2addrsize(struct layer2 *l2)\r\n{\r\nreturn test_bit(FLG_LAPD, &l2->flag) ? 2 : 1;\r\n}\r\nstatic u_int\r\nl2_newid(struct layer2 *l2)\r\n{\r\nu_int id;\r\nid = l2->next_id++;\r\nif (id == 0x7fff)\r\nl2->next_id = 1;\r\nid <<= 16;\r\nid |= l2->tei << 8;\r\nid |= l2->sapi;\r\nreturn id;\r\n}\r\nstatic void\r\nl2up(struct layer2 *l2, u_int prim, struct sk_buff *skb)\r\n{\r\nint err;\r\nif (!l2->up)\r\nreturn;\r\nmISDN_HEAD_PRIM(skb) = prim;\r\nmISDN_HEAD_ID(skb) = (l2->ch.nr << 16) | l2->ch.addr;\r\nerr = l2->up->send(l2->up, skb);\r\nif (err) {\r\nprintk(KERN_WARNING "%s: dev %s err=%d\n", __func__,\r\nmISDNDevName4ch(&l2->ch), err);\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\nstatic void\r\nl2up_create(struct layer2 *l2, u_int prim, int len, void *arg)\r\n{\r\nstruct sk_buff *skb;\r\nstruct mISDNhead *hh;\r\nint err;\r\nif (!l2->up)\r\nreturn;\r\nskb = mI_alloc_skb(len, GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nhh = mISDN_HEAD_P(skb);\r\nhh->prim = prim;\r\nhh->id = (l2->ch.nr << 16) | l2->ch.addr;\r\nif (len)\r\nskb_put_data(skb, arg, len);\r\nerr = l2->up->send(l2->up, skb);\r\nif (err) {\r\nprintk(KERN_WARNING "%s: dev %s err=%d\n", __func__,\r\nmISDNDevName4ch(&l2->ch), err);\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\nstatic int\r\nl2down_skb(struct layer2 *l2, struct sk_buff *skb) {\r\nint ret;\r\nret = l2->ch.recv(l2->ch.peer, skb);\r\nif (ret && (*debug & DEBUG_L2_RECV))\r\nprintk(KERN_DEBUG "l2down_skb: dev %s ret(%d)\n",\r\nmISDNDevName4ch(&l2->ch), ret);\r\nreturn ret;\r\n}\r\nstatic int\r\nl2down_raw(struct layer2 *l2, struct sk_buff *skb)\r\n{\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nif (hh->prim == PH_DATA_REQ) {\r\nif (test_and_set_bit(FLG_L1_NOTREADY, &l2->flag)) {\r\nskb_queue_tail(&l2->down_queue, skb);\r\nreturn 0;\r\n}\r\nl2->down_id = mISDN_HEAD_ID(skb);\r\n}\r\nreturn l2down_skb(l2, skb);\r\n}\r\nstatic int\r\nl2down(struct layer2 *l2, u_int prim, u_int id, struct sk_buff *skb)\r\n{\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nhh->prim = prim;\r\nhh->id = id;\r\nreturn l2down_raw(l2, skb);\r\n}\r\nstatic int\r\nl2down_create(struct layer2 *l2, u_int prim, u_int id, int len, void *arg)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nstruct mISDNhead *hh;\r\nskb = mI_alloc_skb(len, GFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nhh = mISDN_HEAD_P(skb);\r\nhh->prim = prim;\r\nhh->id = id;\r\nif (len)\r\nskb_put_data(skb, arg, len);\r\nerr = l2down_raw(l2, skb);\r\nif (err)\r\ndev_kfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic int\r\nph_data_confirm(struct layer2 *l2, struct mISDNhead *hh, struct sk_buff *skb) {\r\nstruct sk_buff *nskb = skb;\r\nint ret = -EAGAIN;\r\nif (test_bit(FLG_L1_NOTREADY, &l2->flag)) {\r\nif (hh->id == l2->down_id) {\r\nnskb = skb_dequeue(&l2->down_queue);\r\nif (nskb) {\r\nl2->down_id = mISDN_HEAD_ID(nskb);\r\nif (l2down_skb(l2, nskb)) {\r\ndev_kfree_skb(nskb);\r\nl2->down_id = MISDN_ID_NONE;\r\n}\r\n} else\r\nl2->down_id = MISDN_ID_NONE;\r\nif (ret) {\r\ndev_kfree_skb(skb);\r\nret = 0;\r\n}\r\nif (l2->down_id == MISDN_ID_NONE) {\r\ntest_and_clear_bit(FLG_L1_NOTREADY, &l2->flag);\r\nmISDN_FsmEvent(&l2->l2m, EV_L2_ACK_PULL, NULL);\r\n}\r\n}\r\n}\r\nif (!test_and_set_bit(FLG_L1_NOTREADY, &l2->flag)) {\r\nnskb = skb_dequeue(&l2->down_queue);\r\nif (nskb) {\r\nl2->down_id = mISDN_HEAD_ID(nskb);\r\nif (l2down_skb(l2, nskb)) {\r\ndev_kfree_skb(nskb);\r\nl2->down_id = MISDN_ID_NONE;\r\ntest_and_clear_bit(FLG_L1_NOTREADY, &l2->flag);\r\n}\r\n} else\r\ntest_and_clear_bit(FLG_L1_NOTREADY, &l2->flag);\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nl2_timeout(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb;\r\nstruct mISDNhead *hh;\r\nskb = mI_alloc_skb(0, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_WARNING "%s: L2(%d,%d) nr:%x timer %s no skb\n",\r\nmISDNDevName4ch(&l2->ch), l2->sapi, l2->tei,\r\nl2->ch.nr, event == EV_L2_T200 ? "T200" : "T203");\r\nreturn;\r\n}\r\nhh = mISDN_HEAD_P(skb);\r\nhh->prim = event == EV_L2_T200 ? DL_TIMER200_IND : DL_TIMER203_IND;\r\nhh->id = l2->ch.nr;\r\nif (*debug & DEBUG_TIMER)\r\nprintk(KERN_DEBUG "%s: L2(%d,%d) nr:%x timer %s expired\n",\r\nmISDNDevName4ch(&l2->ch), l2->sapi, l2->tei,\r\nl2->ch.nr, event == EV_L2_T200 ? "T200" : "T203");\r\nif (l2->ch.st)\r\nl2->ch.st->own.recv(&l2->ch.st->own, skb);\r\n}\r\nstatic int\r\nl2mgr(struct layer2 *l2, u_int prim, void *arg) {\r\nlong c = (long)arg;\r\nprintk(KERN_WARNING "l2mgr: dev %s addr:%x prim %x %c\n",\r\nmISDNDevName4ch(&l2->ch), l2->id, prim, (char)c);\r\nif (test_bit(FLG_LAPD, &l2->flag) &&\r\n!test_bit(FLG_FIXED_TEI, &l2->flag)) {\r\nswitch (c) {\r\ncase 'C':\r\ncase 'D':\r\ncase 'G':\r\ncase 'H':\r\nl2_tei(l2, prim, (u_long)arg);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nset_peer_busy(struct layer2 *l2) {\r\ntest_and_set_bit(FLG_PEER_BUSY, &l2->flag);\r\nif (skb_queue_len(&l2->i_queue) || skb_queue_len(&l2->ui_queue))\r\ntest_and_set_bit(FLG_L2BLOCK, &l2->flag);\r\n}\r\nstatic void\r\nclear_peer_busy(struct layer2 *l2) {\r\nif (test_and_clear_bit(FLG_PEER_BUSY, &l2->flag))\r\ntest_and_clear_bit(FLG_L2BLOCK, &l2->flag);\r\n}\r\nstatic void\r\nInitWin(struct layer2 *l2)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_WINDOW; i++)\r\nl2->windowar[i] = NULL;\r\n}\r\nstatic int\r\nfreewin(struct layer2 *l2)\r\n{\r\nint i, cnt = 0;\r\nfor (i = 0; i < MAX_WINDOW; i++) {\r\nif (l2->windowar[i]) {\r\ncnt++;\r\ndev_kfree_skb(l2->windowar[i]);\r\nl2->windowar[i] = NULL;\r\n}\r\n}\r\nreturn cnt;\r\n}\r\nstatic void\r\nReleaseWin(struct layer2 *l2)\r\n{\r\nint cnt = freewin(l2);\r\nif (cnt)\r\nprintk(KERN_WARNING\r\n"isdnl2 freed %d skbuffs in release\n", cnt);\r\n}\r\ninline unsigned int\r\ncansend(struct layer2 *l2)\r\n{\r\nunsigned int p1;\r\nif (test_bit(FLG_MOD128, &l2->flag))\r\np1 = (l2->vs - l2->va) % 128;\r\nelse\r\np1 = (l2->vs - l2->va) % 8;\r\nreturn (p1 < l2->window) && !test_bit(FLG_PEER_BUSY, &l2->flag);\r\n}\r\ninline void\r\nclear_exception(struct layer2 *l2)\r\n{\r\ntest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\r\ntest_and_clear_bit(FLG_REJEXC, &l2->flag);\r\ntest_and_clear_bit(FLG_OWN_BUSY, &l2->flag);\r\nclear_peer_busy(l2);\r\n}\r\nstatic int\r\nsethdraddr(struct layer2 *l2, u_char *header, int rsp)\r\n{\r\nu_char *ptr = header;\r\nint crbit = rsp;\r\nif (test_bit(FLG_LAPD, &l2->flag)) {\r\nif (test_bit(FLG_LAPD_NET, &l2->flag))\r\ncrbit = !crbit;\r\n*ptr++ = (l2->sapi << 2) | (crbit ? 2 : 0);\r\n*ptr++ = (l2->tei << 1) | 1;\r\nreturn 2;\r\n} else {\r\nif (test_bit(FLG_ORIG, &l2->flag))\r\ncrbit = !crbit;\r\nif (crbit)\r\n*ptr++ = l2->addr.B;\r\nelse\r\n*ptr++ = l2->addr.A;\r\nreturn 1;\r\n}\r\n}\r\nstatic inline void\r\nenqueue_super(struct layer2 *l2, struct sk_buff *skb)\r\n{\r\nif (l2down(l2, PH_DATA_REQ, l2_newid(l2), skb))\r\ndev_kfree_skb(skb);\r\n}\r\nstatic inline void\r\nenqueue_ui(struct layer2 *l2, struct sk_buff *skb)\r\n{\r\nif (l2->tm)\r\nl2_tei(l2, MDL_STATUS_UI_IND, 0);\r\nif (l2down(l2, PH_DATA_REQ, l2_newid(l2), skb))\r\ndev_kfree_skb(skb);\r\n}\r\ninline int\r\nIsUI(u_char *data)\r\n{\r\nreturn (data[0] & 0xef) == UI;\r\n}\r\ninline int\r\nIsUA(u_char *data)\r\n{\r\nreturn (data[0] & 0xef) == UA;\r\n}\r\ninline int\r\nIsDM(u_char *data)\r\n{\r\nreturn (data[0] & 0xef) == DM;\r\n}\r\ninline int\r\nIsDISC(u_char *data)\r\n{\r\nreturn (data[0] & 0xef) == DISC;\r\n}\r\ninline int\r\nIsRR(u_char *data, struct layer2 *l2)\r\n{\r\nif (test_bit(FLG_MOD128, &l2->flag))\r\nreturn data[0] == RR;\r\nelse\r\nreturn (data[0] & 0xf) == 1;\r\n}\r\ninline int\r\nIsSFrame(u_char *data, struct layer2 *l2)\r\n{\r\nregister u_char d = *data;\r\nif (!test_bit(FLG_MOD128, &l2->flag))\r\nd &= 0xf;\r\nreturn ((d & 0xf3) == 1) && ((d & 0x0c) != 0x0c);\r\n}\r\ninline int\r\nIsSABME(u_char *data, struct layer2 *l2)\r\n{\r\nu_char d = data[0] & ~0x10;\r\nreturn test_bit(FLG_MOD128, &l2->flag) ? d == SABME : d == SABM;\r\n}\r\ninline int\r\nIsREJ(u_char *data, struct layer2 *l2)\r\n{\r\nreturn test_bit(FLG_MOD128, &l2->flag) ?\r\ndata[0] == REJ : (data[0] & 0xf) == REJ;\r\n}\r\ninline int\r\nIsFRMR(u_char *data)\r\n{\r\nreturn (data[0] & 0xef) == FRMR;\r\n}\r\ninline int\r\nIsRNR(u_char *data, struct layer2 *l2)\r\n{\r\nreturn test_bit(FLG_MOD128, &l2->flag) ?\r\ndata[0] == RNR : (data[0] & 0xf) == RNR;\r\n}\r\nstatic int\r\niframe_error(struct layer2 *l2, struct sk_buff *skb)\r\n{\r\nu_int i;\r\nint rsp = *skb->data & 0x2;\r\ni = l2addrsize(l2) + (test_bit(FLG_MOD128, &l2->flag) ? 2 : 1);\r\nif (test_bit(FLG_ORIG, &l2->flag))\r\nrsp = !rsp;\r\nif (rsp)\r\nreturn 'L';\r\nif (skb->len < i)\r\nreturn 'N';\r\nif ((skb->len - i) > l2->maxlen)\r\nreturn 'O';\r\nreturn 0;\r\n}\r\nstatic int\r\nsuper_error(struct layer2 *l2, struct sk_buff *skb)\r\n{\r\nif (skb->len != l2addrsize(l2) +\r\n(test_bit(FLG_MOD128, &l2->flag) ? 2 : 1))\r\nreturn 'N';\r\nreturn 0;\r\n}\r\nstatic int\r\nunnum_error(struct layer2 *l2, struct sk_buff *skb, int wantrsp)\r\n{\r\nint rsp = (*skb->data & 0x2) >> 1;\r\nif (test_bit(FLG_ORIG, &l2->flag))\r\nrsp = !rsp;\r\nif (rsp != wantrsp)\r\nreturn 'L';\r\nif (skb->len != l2addrsize(l2) + 1)\r\nreturn 'N';\r\nreturn 0;\r\n}\r\nstatic int\r\nUI_error(struct layer2 *l2, struct sk_buff *skb)\r\n{\r\nint rsp = *skb->data & 0x2;\r\nif (test_bit(FLG_ORIG, &l2->flag))\r\nrsp = !rsp;\r\nif (rsp)\r\nreturn 'L';\r\nif (skb->len > l2->maxlen + l2addrsize(l2) + 1)\r\nreturn 'O';\r\nreturn 0;\r\n}\r\nstatic int\r\nFRMR_error(struct layer2 *l2, struct sk_buff *skb)\r\n{\r\nu_int headers = l2addrsize(l2) + 1;\r\nu_char *datap = skb->data + headers;\r\nint rsp = *skb->data & 0x2;\r\nif (test_bit(FLG_ORIG, &l2->flag))\r\nrsp = !rsp;\r\nif (!rsp)\r\nreturn 'L';\r\nif (test_bit(FLG_MOD128, &l2->flag)) {\r\nif (skb->len < headers + 5)\r\nreturn 'N';\r\nelse if (*debug & DEBUG_L2)\r\nl2m_debug(&l2->l2m,\r\n"FRMR information %2x %2x %2x %2x %2x",\r\ndatap[0], datap[1], datap[2], datap[3], datap[4]);\r\n} else {\r\nif (skb->len < headers + 3)\r\nreturn 'N';\r\nelse if (*debug & DEBUG_L2)\r\nl2m_debug(&l2->l2m,\r\n"FRMR information %2x %2x %2x",\r\ndatap[0], datap[1], datap[2]);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\nlegalnr(struct layer2 *l2, unsigned int nr)\r\n{\r\nif (test_bit(FLG_MOD128, &l2->flag))\r\nreturn ((nr - l2->va) % 128) <= ((l2->vs - l2->va) % 128);\r\nelse\r\nreturn ((nr - l2->va) % 8) <= ((l2->vs - l2->va) % 8);\r\n}\r\nstatic void\r\nsetva(struct layer2 *l2, unsigned int nr)\r\n{\r\nstruct sk_buff *skb;\r\nwhile (l2->va != nr) {\r\nl2->va++;\r\nif (test_bit(FLG_MOD128, &l2->flag))\r\nl2->va %= 128;\r\nelse\r\nl2->va %= 8;\r\nif (l2->windowar[l2->sow]) {\r\nskb_trim(l2->windowar[l2->sow], 0);\r\nskb_queue_tail(&l2->tmp_queue, l2->windowar[l2->sow]);\r\nl2->windowar[l2->sow] = NULL;\r\n}\r\nl2->sow = (l2->sow + 1) % l2->window;\r\n}\r\nskb = skb_dequeue(&l2->tmp_queue);\r\nwhile (skb) {\r\ndev_kfree_skb(skb);\r\nskb = skb_dequeue(&l2->tmp_queue);\r\n}\r\n}\r\nstatic void\r\nsend_uframe(struct layer2 *l2, struct sk_buff *skb, u_char cmd, u_char cr)\r\n{\r\nu_char tmp[MAX_L2HEADER_LEN];\r\nint i;\r\ni = sethdraddr(l2, tmp, cr);\r\ntmp[i++] = cmd;\r\nif (skb)\r\nskb_trim(skb, 0);\r\nelse {\r\nskb = mI_alloc_skb(i, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_WARNING "%s: can't alloc skbuff in %s\n",\r\nmISDNDevName4ch(&l2->ch), __func__);\r\nreturn;\r\n}\r\n}\r\nskb_put_data(skb, tmp, i);\r\nenqueue_super(l2, skb);\r\n}\r\ninline u_char\r\nget_PollFlag(struct layer2 *l2, struct sk_buff *skb)\r\n{\r\nreturn skb->data[l2addrsize(l2)] & 0x10;\r\n}\r\ninline u_char\r\nget_PollFlagFree(struct layer2 *l2, struct sk_buff *skb)\r\n{\r\nu_char PF;\r\nPF = get_PollFlag(l2, skb);\r\ndev_kfree_skb(skb);\r\nreturn PF;\r\n}\r\ninline void\r\nstart_t200(struct layer2 *l2, int i)\r\n{\r\nmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, i);\r\ntest_and_set_bit(FLG_T200_RUN, &l2->flag);\r\n}\r\ninline void\r\nrestart_t200(struct layer2 *l2, int i)\r\n{\r\nmISDN_FsmRestartTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, i);\r\ntest_and_set_bit(FLG_T200_RUN, &l2->flag);\r\n}\r\ninline void\r\nstop_t200(struct layer2 *l2, int i)\r\n{\r\nif (test_and_clear_bit(FLG_T200_RUN, &l2->flag))\r\nmISDN_FsmDelTimer(&l2->t200, i);\r\n}\r\ninline void\r\nst5_dl_release_l2l3(struct layer2 *l2)\r\n{\r\nint pr;\r\nif (test_and_clear_bit(FLG_PEND_REL, &l2->flag))\r\npr = DL_RELEASE_CNF;\r\nelse\r\npr = DL_RELEASE_IND;\r\nl2up_create(l2, pr, 0, NULL);\r\n}\r\ninline void\r\nlapb_dl_release_l2l3(struct layer2 *l2, int f)\r\n{\r\nif (test_bit(FLG_LAPB, &l2->flag))\r\nl2down_create(l2, PH_DEACTIVATE_REQ, l2_newid(l2), 0, NULL);\r\nl2up_create(l2, f, 0, NULL);\r\n}\r\nstatic void\r\nestablishlink(struct FsmInst *fi)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nu_char cmd;\r\nclear_exception(l2);\r\nl2->rc = 0;\r\ncmd = (test_bit(FLG_MOD128, &l2->flag) ? SABME : SABM) | 0x10;\r\nsend_uframe(l2, NULL, cmd, CMD);\r\nmISDN_FsmDelTimer(&l2->t203, 1);\r\nrestart_t200(l2, 1);\r\ntest_and_clear_bit(FLG_PEND_REL, &l2->flag);\r\nfreewin(l2);\r\nmISDN_FsmChangeState(fi, ST_L2_5);\r\n}\r\nstatic void\r\nl2_mdl_error_ua(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nstruct layer2 *l2 = fi->userdata;\r\nif (get_PollFlagFree(l2, skb))\r\nl2mgr(l2, MDL_ERROR_IND, (void *) 'C');\r\nelse\r\nl2mgr(l2, MDL_ERROR_IND, (void *) 'D');\r\n}\r\nstatic void\r\nl2_mdl_error_dm(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nstruct layer2 *l2 = fi->userdata;\r\nif (get_PollFlagFree(l2, skb))\r\nl2mgr(l2, MDL_ERROR_IND, (void *) 'B');\r\nelse {\r\nl2mgr(l2, MDL_ERROR_IND, (void *) 'E');\r\nestablishlink(fi);\r\ntest_and_clear_bit(FLG_L3_INIT, &l2->flag);\r\n}\r\n}\r\nstatic void\r\nl2_st8_mdl_error_dm(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nstruct layer2 *l2 = fi->userdata;\r\nif (get_PollFlagFree(l2, skb))\r\nl2mgr(l2, MDL_ERROR_IND, (void *) 'B');\r\nelse\r\nl2mgr(l2, MDL_ERROR_IND, (void *) 'E');\r\nestablishlink(fi);\r\ntest_and_clear_bit(FLG_L3_INIT, &l2->flag);\r\n}\r\nstatic void\r\nl2_go_st3(struct FsmInst *fi, int event, void *arg)\r\n{\r\ndev_kfree_skb((struct sk_buff *)arg);\r\nmISDN_FsmChangeState(fi, ST_L2_3);\r\n}\r\nstatic void\r\nl2_mdl_assign(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nmISDN_FsmChangeState(fi, ST_L2_3);\r\ndev_kfree_skb((struct sk_buff *)arg);\r\nl2_tei(l2, MDL_ASSIGN_IND, 0);\r\n}\r\nstatic void\r\nl2_queue_ui_assign(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_queue_tail(&l2->ui_queue, skb);\r\nmISDN_FsmChangeState(fi, ST_L2_2);\r\nl2_tei(l2, MDL_ASSIGN_IND, 0);\r\n}\r\nstatic void\r\nl2_queue_ui(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_queue_tail(&l2->ui_queue, skb);\r\n}\r\nstatic void\r\ntx_ui(struct layer2 *l2)\r\n{\r\nstruct sk_buff *skb;\r\nu_char header[MAX_L2HEADER_LEN];\r\nint i;\r\ni = sethdraddr(l2, header, CMD);\r\nif (test_bit(FLG_LAPD_NET, &l2->flag))\r\nheader[1] = 0xff;\r\nheader[i++] = UI;\r\nwhile ((skb = skb_dequeue(&l2->ui_queue))) {\r\nmemcpy(skb_push(skb, i), header, i);\r\nenqueue_ui(l2, skb);\r\n}\r\n}\r\nstatic void\r\nl2_send_ui(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_queue_tail(&l2->ui_queue, skb);\r\ntx_ui(l2);\r\n}\r\nstatic void\r\nl2_got_ui(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_pull(skb, l2headersize(l2, 1));\r\nif (l2->tm)\r\nl2_tei(l2, MDL_STATUS_UI_IND, 0);\r\nl2up(l2, DL_UNITDATA_IND, skb);\r\n}\r\nstatic void\r\nl2_establish(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nstruct layer2 *l2 = fi->userdata;\r\nestablishlink(fi);\r\ntest_and_set_bit(FLG_L3_INIT, &l2->flag);\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nl2_discard_i_setl3(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nstruct layer2 *l2 = fi->userdata;\r\nskb_queue_purge(&l2->i_queue);\r\ntest_and_set_bit(FLG_L3_INIT, &l2->flag);\r\ntest_and_clear_bit(FLG_PEND_REL, &l2->flag);\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nl2_l3_reestablish(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nstruct layer2 *l2 = fi->userdata;\r\nskb_queue_purge(&l2->i_queue);\r\nestablishlink(fi);\r\ntest_and_set_bit(FLG_L3_INIT, &l2->flag);\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nl2_release(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_trim(skb, 0);\r\nl2up(l2, DL_RELEASE_CNF, skb);\r\n}\r\nstatic void\r\nl2_pend_rel(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nstruct layer2 *l2 = fi->userdata;\r\ntest_and_set_bit(FLG_PEND_REL, &l2->flag);\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nl2_disconnect(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_queue_purge(&l2->i_queue);\r\nfreewin(l2);\r\nmISDN_FsmChangeState(fi, ST_L2_6);\r\nl2->rc = 0;\r\nsend_uframe(l2, NULL, DISC | 0x10, CMD);\r\nmISDN_FsmDelTimer(&l2->t203, 1);\r\nrestart_t200(l2, 2);\r\nif (skb)\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nl2_start_multi(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nl2->vs = 0;\r\nl2->va = 0;\r\nl2->vr = 0;\r\nl2->sow = 0;\r\nclear_exception(l2);\r\nsend_uframe(l2, NULL, UA | get_PollFlag(l2, skb), RSP);\r\nmISDN_FsmChangeState(fi, ST_L2_7);\r\nmISDN_FsmAddTimer(&l2->t203, l2->T203, EV_L2_T203, NULL, 3);\r\nskb_trim(skb, 0);\r\nl2up(l2, DL_ESTABLISH_IND, skb);\r\nif (l2->tm)\r\nl2_tei(l2, MDL_STATUS_UP_IND, 0);\r\n}\r\nstatic void\r\nl2_send_UA(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nsend_uframe(l2, skb, UA | get_PollFlag(l2, skb), RSP);\r\n}\r\nstatic void\r\nl2_send_DM(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nsend_uframe(l2, skb, DM | get_PollFlag(l2, skb), RSP);\r\n}\r\nstatic void\r\nl2_restart_multi(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nint est = 0;\r\nsend_uframe(l2, skb, UA | get_PollFlag(l2, skb), RSP);\r\nl2mgr(l2, MDL_ERROR_IND, (void *) 'F');\r\nif (l2->vs != l2->va) {\r\nskb_queue_purge(&l2->i_queue);\r\nest = 1;\r\n}\r\nclear_exception(l2);\r\nl2->vs = 0;\r\nl2->va = 0;\r\nl2->vr = 0;\r\nl2->sow = 0;\r\nmISDN_FsmChangeState(fi, ST_L2_7);\r\nstop_t200(l2, 3);\r\nmISDN_FsmRestartTimer(&l2->t203, l2->T203, EV_L2_T203, NULL, 3);\r\nif (est)\r\nl2up_create(l2, DL_ESTABLISH_IND, 0, NULL);\r\nif (skb_queue_len(&l2->i_queue) && cansend(l2))\r\nmISDN_FsmEvent(fi, EV_L2_ACK_PULL, NULL);\r\n}\r\nstatic void\r\nl2_stop_multi(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nmISDN_FsmChangeState(fi, ST_L2_4);\r\nmISDN_FsmDelTimer(&l2->t203, 3);\r\nstop_t200(l2, 4);\r\nsend_uframe(l2, skb, UA | get_PollFlag(l2, skb), RSP);\r\nskb_queue_purge(&l2->i_queue);\r\nfreewin(l2);\r\nlapb_dl_release_l2l3(l2, DL_RELEASE_IND);\r\nif (l2->tm)\r\nl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\r\n}\r\nstatic void\r\nl2_connected(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nint pr = -1;\r\nif (!get_PollFlag(l2, skb)) {\r\nl2_mdl_error_ua(fi, event, arg);\r\nreturn;\r\n}\r\ndev_kfree_skb(skb);\r\nif (test_and_clear_bit(FLG_PEND_REL, &l2->flag))\r\nl2_disconnect(fi, event, NULL);\r\nif (test_and_clear_bit(FLG_L3_INIT, &l2->flag)) {\r\npr = DL_ESTABLISH_CNF;\r\n} else if (l2->vs != l2->va) {\r\nskb_queue_purge(&l2->i_queue);\r\npr = DL_ESTABLISH_IND;\r\n}\r\nstop_t200(l2, 5);\r\nl2->vr = 0;\r\nl2->vs = 0;\r\nl2->va = 0;\r\nl2->sow = 0;\r\nmISDN_FsmChangeState(fi, ST_L2_7);\r\nmISDN_FsmAddTimer(&l2->t203, l2->T203, EV_L2_T203, NULL, 4);\r\nif (pr != -1)\r\nl2up_create(l2, pr, 0, NULL);\r\nif (skb_queue_len(&l2->i_queue) && cansend(l2))\r\nmISDN_FsmEvent(fi, EV_L2_ACK_PULL, NULL);\r\nif (l2->tm)\r\nl2_tei(l2, MDL_STATUS_UP_IND, 0);\r\n}\r\nstatic void\r\nl2_released(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nif (!get_PollFlag(l2, skb)) {\r\nl2_mdl_error_ua(fi, event, arg);\r\nreturn;\r\n}\r\ndev_kfree_skb(skb);\r\nstop_t200(l2, 6);\r\nlapb_dl_release_l2l3(l2, DL_RELEASE_CNF);\r\nmISDN_FsmChangeState(fi, ST_L2_4);\r\nif (l2->tm)\r\nl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\r\n}\r\nstatic void\r\nl2_reestablish(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nif (!get_PollFlagFree(l2, skb)) {\r\nestablishlink(fi);\r\ntest_and_set_bit(FLG_L3_INIT, &l2->flag);\r\n}\r\n}\r\nstatic void\r\nl2_st5_dm_release(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nif (get_PollFlagFree(l2, skb)) {\r\nstop_t200(l2, 7);\r\nif (!test_bit(FLG_L3_INIT, &l2->flag))\r\nskb_queue_purge(&l2->i_queue);\r\nif (test_bit(FLG_LAPB, &l2->flag))\r\nl2down_create(l2, PH_DEACTIVATE_REQ,\r\nl2_newid(l2), 0, NULL);\r\nst5_dl_release_l2l3(l2);\r\nmISDN_FsmChangeState(fi, ST_L2_4);\r\nif (l2->tm)\r\nl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\r\n}\r\n}\r\nstatic void\r\nl2_st6_dm_release(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nif (get_PollFlagFree(l2, skb)) {\r\nstop_t200(l2, 8);\r\nlapb_dl_release_l2l3(l2, DL_RELEASE_CNF);\r\nmISDN_FsmChangeState(fi, ST_L2_4);\r\nif (l2->tm)\r\nl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\r\n}\r\n}\r\nstatic void\r\nenquiry_cr(struct layer2 *l2, u_char typ, u_char cr, u_char pf)\r\n{\r\nstruct sk_buff *skb;\r\nu_char tmp[MAX_L2HEADER_LEN];\r\nint i;\r\ni = sethdraddr(l2, tmp, cr);\r\nif (test_bit(FLG_MOD128, &l2->flag)) {\r\ntmp[i++] = typ;\r\ntmp[i++] = (l2->vr << 1) | (pf ? 1 : 0);\r\n} else\r\ntmp[i++] = (l2->vr << 5) | typ | (pf ? 0x10 : 0);\r\nskb = mI_alloc_skb(i, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_WARNING "%s: isdnl2 can't alloc sbbuff in %s\n",\r\nmISDNDevName4ch(&l2->ch), __func__);\r\nreturn;\r\n}\r\nskb_put_data(skb, tmp, i);\r\nenqueue_super(l2, skb);\r\n}\r\ninline void\r\nenquiry_response(struct layer2 *l2)\r\n{\r\nif (test_bit(FLG_OWN_BUSY, &l2->flag))\r\nenquiry_cr(l2, RNR, RSP, 1);\r\nelse\r\nenquiry_cr(l2, RR, RSP, 1);\r\ntest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\r\n}\r\ninline void\r\ntransmit_enquiry(struct layer2 *l2)\r\n{\r\nif (test_bit(FLG_OWN_BUSY, &l2->flag))\r\nenquiry_cr(l2, RNR, CMD, 1);\r\nelse\r\nenquiry_cr(l2, RR, CMD, 1);\r\ntest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\r\nstart_t200(l2, 9);\r\n}\r\nstatic void\r\nnrerrorrecovery(struct FsmInst *fi)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nl2mgr(l2, MDL_ERROR_IND, (void *) 'J');\r\nestablishlink(fi);\r\ntest_and_clear_bit(FLG_L3_INIT, &l2->flag);\r\n}\r\nstatic void\r\ninvoke_retransmission(struct layer2 *l2, unsigned int nr)\r\n{\r\nu_int p1;\r\nif (l2->vs != nr) {\r\nwhile (l2->vs != nr) {\r\n(l2->vs)--;\r\nif (test_bit(FLG_MOD128, &l2->flag)) {\r\nl2->vs %= 128;\r\np1 = (l2->vs - l2->va) % 128;\r\n} else {\r\nl2->vs %= 8;\r\np1 = (l2->vs - l2->va) % 8;\r\n}\r\np1 = (p1 + l2->sow) % l2->window;\r\nif (l2->windowar[p1])\r\nskb_queue_head(&l2->i_queue, l2->windowar[p1]);\r\nelse\r\nprintk(KERN_WARNING\r\n"%s: windowar[%d] is NULL\n",\r\nmISDNDevName4ch(&l2->ch), p1);\r\nl2->windowar[p1] = NULL;\r\n}\r\nmISDN_FsmEvent(&l2->l2m, EV_L2_ACK_PULL, NULL);\r\n}\r\n}\r\nstatic void\r\nl2_st7_got_super(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nint PollFlag, rsp, typ = RR;\r\nunsigned int nr;\r\nrsp = *skb->data & 0x2;\r\nif (test_bit(FLG_ORIG, &l2->flag))\r\nrsp = !rsp;\r\nskb_pull(skb, l2addrsize(l2));\r\nif (IsRNR(skb->data, l2)) {\r\nset_peer_busy(l2);\r\ntyp = RNR;\r\n} else\r\nclear_peer_busy(l2);\r\nif (IsREJ(skb->data, l2))\r\ntyp = REJ;\r\nif (test_bit(FLG_MOD128, &l2->flag)) {\r\nPollFlag = (skb->data[1] & 0x1) == 0x1;\r\nnr = skb->data[1] >> 1;\r\n} else {\r\nPollFlag = (skb->data[0] & 0x10);\r\nnr = (skb->data[0] >> 5) & 0x7;\r\n}\r\ndev_kfree_skb(skb);\r\nif (PollFlag) {\r\nif (rsp)\r\nl2mgr(l2, MDL_ERROR_IND, (void *) 'A');\r\nelse\r\nenquiry_response(l2);\r\n}\r\nif (legalnr(l2, nr)) {\r\nif (typ == REJ) {\r\nsetva(l2, nr);\r\ninvoke_retransmission(l2, nr);\r\nstop_t200(l2, 10);\r\nif (mISDN_FsmAddTimer(&l2->t203, l2->T203,\r\nEV_L2_T203, NULL, 6))\r\nl2m_debug(&l2->l2m, "Restart T203 ST7 REJ");\r\n} else if ((nr == l2->vs) && (typ == RR)) {\r\nsetva(l2, nr);\r\nstop_t200(l2, 11);\r\nmISDN_FsmRestartTimer(&l2->t203, l2->T203,\r\nEV_L2_T203, NULL, 7);\r\n} else if ((l2->va != nr) || (typ == RNR)) {\r\nsetva(l2, nr);\r\nif (typ != RR)\r\nmISDN_FsmDelTimer(&l2->t203, 9);\r\nrestart_t200(l2, 12);\r\n}\r\nif (skb_queue_len(&l2->i_queue) && (typ == RR))\r\nmISDN_FsmEvent(fi, EV_L2_ACK_PULL, NULL);\r\n} else\r\nnrerrorrecovery(fi);\r\n}\r\nstatic void\r\nl2_feed_i_if_reest(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nif (!test_bit(FLG_L3_INIT, &l2->flag))\r\nskb_queue_tail(&l2->i_queue, skb);\r\nelse\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nl2_feed_i_pull(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_queue_tail(&l2->i_queue, skb);\r\nmISDN_FsmEvent(fi, EV_L2_ACK_PULL, NULL);\r\n}\r\nstatic void\r\nl2_feed_iqueue(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_queue_tail(&l2->i_queue, skb);\r\n}\r\nstatic void\r\nl2_got_iframe(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nint PollFlag, i;\r\nu_int ns, nr;\r\ni = l2addrsize(l2);\r\nif (test_bit(FLG_MOD128, &l2->flag)) {\r\nPollFlag = ((skb->data[i + 1] & 0x1) == 0x1);\r\nns = skb->data[i] >> 1;\r\nnr = (skb->data[i + 1] >> 1) & 0x7f;\r\n} else {\r\nPollFlag = (skb->data[i] & 0x10);\r\nns = (skb->data[i] >> 1) & 0x7;\r\nnr = (skb->data[i] >> 5) & 0x7;\r\n}\r\nif (test_bit(FLG_OWN_BUSY, &l2->flag)) {\r\ndev_kfree_skb(skb);\r\nif (PollFlag)\r\nenquiry_response(l2);\r\n} else {\r\nif (l2->vr == ns) {\r\nl2->vr++;\r\nif (test_bit(FLG_MOD128, &l2->flag))\r\nl2->vr %= 128;\r\nelse\r\nl2->vr %= 8;\r\ntest_and_clear_bit(FLG_REJEXC, &l2->flag);\r\nif (PollFlag)\r\nenquiry_response(l2);\r\nelse\r\ntest_and_set_bit(FLG_ACK_PEND, &l2->flag);\r\nskb_pull(skb, l2headersize(l2, 0));\r\nl2up(l2, DL_DATA_IND, skb);\r\n} else {\r\ndev_kfree_skb(skb);\r\nif (test_and_set_bit(FLG_REJEXC, &l2->flag)) {\r\nif (PollFlag)\r\nenquiry_response(l2);\r\n} else {\r\nenquiry_cr(l2, REJ, RSP, PollFlag);\r\ntest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\r\n}\r\n}\r\n}\r\nif (legalnr(l2, nr)) {\r\nif (!test_bit(FLG_PEER_BUSY, &l2->flag) &&\r\n(fi->state == ST_L2_7)) {\r\nif (nr == l2->vs) {\r\nstop_t200(l2, 13);\r\nmISDN_FsmRestartTimer(&l2->t203, l2->T203,\r\nEV_L2_T203, NULL, 7);\r\n} else if (nr != l2->va)\r\nrestart_t200(l2, 14);\r\n}\r\nsetva(l2, nr);\r\n} else {\r\nnrerrorrecovery(fi);\r\nreturn;\r\n}\r\nif (skb_queue_len(&l2->i_queue) && (fi->state == ST_L2_7))\r\nmISDN_FsmEvent(fi, EV_L2_ACK_PULL, NULL);\r\nif (test_and_clear_bit(FLG_ACK_PEND, &l2->flag))\r\nenquiry_cr(l2, RR, RSP, 0);\r\n}\r\nstatic void\r\nl2_got_tei(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nu_int info;\r\nl2->tei = (signed char)(long)arg;\r\nset_channel_address(&l2->ch, l2->sapi, l2->tei);\r\ninfo = DL_INFO_L2_CONNECT;\r\nl2up_create(l2, DL_INFORMATION_IND, sizeof(info), &info);\r\nif (fi->state == ST_L2_3) {\r\nestablishlink(fi);\r\ntest_and_set_bit(FLG_L3_INIT, &l2->flag);\r\n} else\r\nmISDN_FsmChangeState(fi, ST_L2_4);\r\nif (skb_queue_len(&l2->ui_queue))\r\ntx_ui(l2);\r\n}\r\nstatic void\r\nl2_st5_tout_200(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nif (test_bit(FLG_LAPD, &l2->flag) &&\r\ntest_bit(FLG_DCHAN_BUSY, &l2->flag)) {\r\nmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, 9);\r\n} else if (l2->rc == l2->N200) {\r\nmISDN_FsmChangeState(fi, ST_L2_4);\r\ntest_and_clear_bit(FLG_T200_RUN, &l2->flag);\r\nskb_queue_purge(&l2->i_queue);\r\nl2mgr(l2, MDL_ERROR_IND, (void *) 'G');\r\nif (test_bit(FLG_LAPB, &l2->flag))\r\nl2down_create(l2, PH_DEACTIVATE_REQ,\r\nl2_newid(l2), 0, NULL);\r\nst5_dl_release_l2l3(l2);\r\nif (l2->tm)\r\nl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\r\n} else {\r\nl2->rc++;\r\nmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, 9);\r\nsend_uframe(l2, NULL, (test_bit(FLG_MOD128, &l2->flag) ?\r\nSABME : SABM) | 0x10, CMD);\r\n}\r\n}\r\nstatic void\r\nl2_st6_tout_200(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nif (test_bit(FLG_LAPD, &l2->flag) &&\r\ntest_bit(FLG_DCHAN_BUSY, &l2->flag)) {\r\nmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, 9);\r\n} else if (l2->rc == l2->N200) {\r\nmISDN_FsmChangeState(fi, ST_L2_4);\r\ntest_and_clear_bit(FLG_T200_RUN, &l2->flag);\r\nl2mgr(l2, MDL_ERROR_IND, (void *) 'H');\r\nlapb_dl_release_l2l3(l2, DL_RELEASE_CNF);\r\nif (l2->tm)\r\nl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\r\n} else {\r\nl2->rc++;\r\nmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200,\r\nNULL, 9);\r\nsend_uframe(l2, NULL, DISC | 0x10, CMD);\r\n}\r\n}\r\nstatic void\r\nl2_st7_tout_200(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nif (test_bit(FLG_LAPD, &l2->flag) &&\r\ntest_bit(FLG_DCHAN_BUSY, &l2->flag)) {\r\nmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, 9);\r\nreturn;\r\n}\r\ntest_and_clear_bit(FLG_T200_RUN, &l2->flag);\r\nl2->rc = 0;\r\nmISDN_FsmChangeState(fi, ST_L2_8);\r\ntransmit_enquiry(l2);\r\nl2->rc++;\r\n}\r\nstatic void\r\nl2_st8_tout_200(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nif (test_bit(FLG_LAPD, &l2->flag) &&\r\ntest_bit(FLG_DCHAN_BUSY, &l2->flag)) {\r\nmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, 9);\r\nreturn;\r\n}\r\ntest_and_clear_bit(FLG_T200_RUN, &l2->flag);\r\nif (l2->rc == l2->N200) {\r\nl2mgr(l2, MDL_ERROR_IND, (void *) 'I');\r\nestablishlink(fi);\r\ntest_and_clear_bit(FLG_L3_INIT, &l2->flag);\r\n} else {\r\ntransmit_enquiry(l2);\r\nl2->rc++;\r\n}\r\n}\r\nstatic void\r\nl2_st7_tout_203(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nif (test_bit(FLG_LAPD, &l2->flag) &&\r\ntest_bit(FLG_DCHAN_BUSY, &l2->flag)) {\r\nmISDN_FsmAddTimer(&l2->t203, l2->T203, EV_L2_T203, NULL, 9);\r\nreturn;\r\n}\r\nmISDN_FsmChangeState(fi, ST_L2_8);\r\ntransmit_enquiry(l2);\r\nl2->rc = 0;\r\n}\r\nstatic void\r\nl2_pull_iqueue(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb, *nskb;\r\nu_char header[MAX_L2HEADER_LEN];\r\nu_int i, p1;\r\nif (!cansend(l2))\r\nreturn;\r\nskb = skb_dequeue(&l2->i_queue);\r\nif (!skb)\r\nreturn;\r\ni = sethdraddr(l2, header, CMD);\r\nif (test_bit(FLG_MOD128, &l2->flag)) {\r\nheader[i++] = l2->vs << 1;\r\nheader[i++] = l2->vr << 1;\r\n} else\r\nheader[i++] = (l2->vr << 5) | (l2->vs << 1);\r\nnskb = skb_realloc_headroom(skb, i);\r\nif (!nskb) {\r\nprintk(KERN_WARNING "%s: no headroom(%d) copy for IFrame\n",\r\nmISDNDevName4ch(&l2->ch), i);\r\nskb_queue_head(&l2->i_queue, skb);\r\nreturn;\r\n}\r\nif (test_bit(FLG_MOD128, &l2->flag)) {\r\np1 = (l2->vs - l2->va) % 128;\r\nl2->vs = (l2->vs + 1) % 128;\r\n} else {\r\np1 = (l2->vs - l2->va) % 8;\r\nl2->vs = (l2->vs + 1) % 8;\r\n}\r\np1 = (p1 + l2->sow) % l2->window;\r\nif (l2->windowar[p1]) {\r\nprintk(KERN_WARNING "%s: l2 try overwrite ack queue entry %d\n",\r\nmISDNDevName4ch(&l2->ch), p1);\r\ndev_kfree_skb(l2->windowar[p1]);\r\n}\r\nl2->windowar[p1] = skb;\r\nmemcpy(skb_push(nskb, i), header, i);\r\nl2down(l2, PH_DATA_REQ, l2_newid(l2), nskb);\r\ntest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\r\nif (!test_and_set_bit(FLG_T200_RUN, &l2->flag)) {\r\nmISDN_FsmDelTimer(&l2->t203, 13);\r\nmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, 11);\r\n}\r\n}\r\nstatic void\r\nl2_st8_got_super(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nint PollFlag, rsp, rnr = 0;\r\nunsigned int nr;\r\nrsp = *skb->data & 0x2;\r\nif (test_bit(FLG_ORIG, &l2->flag))\r\nrsp = !rsp;\r\nskb_pull(skb, l2addrsize(l2));\r\nif (IsRNR(skb->data, l2)) {\r\nset_peer_busy(l2);\r\nrnr = 1;\r\n} else\r\nclear_peer_busy(l2);\r\nif (test_bit(FLG_MOD128, &l2->flag)) {\r\nPollFlag = (skb->data[1] & 0x1) == 0x1;\r\nnr = skb->data[1] >> 1;\r\n} else {\r\nPollFlag = (skb->data[0] & 0x10);\r\nnr = (skb->data[0] >> 5) & 0x7;\r\n}\r\ndev_kfree_skb(skb);\r\nif (rsp && PollFlag) {\r\nif (legalnr(l2, nr)) {\r\nif (rnr) {\r\nrestart_t200(l2, 15);\r\n} else {\r\nstop_t200(l2, 16);\r\nmISDN_FsmAddTimer(&l2->t203, l2->T203,\r\nEV_L2_T203, NULL, 5);\r\nsetva(l2, nr);\r\n}\r\ninvoke_retransmission(l2, nr);\r\nmISDN_FsmChangeState(fi, ST_L2_7);\r\nif (skb_queue_len(&l2->i_queue) && cansend(l2))\r\nmISDN_FsmEvent(fi, EV_L2_ACK_PULL, NULL);\r\n} else\r\nnrerrorrecovery(fi);\r\n} else {\r\nif (!rsp && PollFlag)\r\nenquiry_response(l2);\r\nif (legalnr(l2, nr))\r\nsetva(l2, nr);\r\nelse\r\nnrerrorrecovery(fi);\r\n}\r\n}\r\nstatic void\r\nl2_got_FRMR(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_pull(skb, l2addrsize(l2) + 1);\r\nif (!(skb->data[0] & 1) || ((skb->data[0] & 3) == 1) ||\r\n(IsUA(skb->data) && (fi->state == ST_L2_7))) {\r\nl2mgr(l2, MDL_ERROR_IND, (void *) 'K');\r\nestablishlink(fi);\r\ntest_and_clear_bit(FLG_L3_INIT, &l2->flag);\r\n}\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nl2_st24_tei_remove(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nskb_queue_purge(&l2->ui_queue);\r\nl2->tei = GROUP_TEI;\r\nmISDN_FsmChangeState(fi, ST_L2_1);\r\n}\r\nstatic void\r\nl2_st3_tei_remove(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nskb_queue_purge(&l2->ui_queue);\r\nl2->tei = GROUP_TEI;\r\nl2up_create(l2, DL_RELEASE_IND, 0, NULL);\r\nmISDN_FsmChangeState(fi, ST_L2_1);\r\n}\r\nstatic void\r\nl2_st5_tei_remove(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nskb_queue_purge(&l2->i_queue);\r\nskb_queue_purge(&l2->ui_queue);\r\nfreewin(l2);\r\nl2->tei = GROUP_TEI;\r\nstop_t200(l2, 17);\r\nst5_dl_release_l2l3(l2);\r\nmISDN_FsmChangeState(fi, ST_L2_1);\r\n}\r\nstatic void\r\nl2_st6_tei_remove(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nskb_queue_purge(&l2->ui_queue);\r\nl2->tei = GROUP_TEI;\r\nstop_t200(l2, 18);\r\nl2up_create(l2, DL_RELEASE_IND, 0, NULL);\r\nmISDN_FsmChangeState(fi, ST_L2_1);\r\n}\r\nstatic void\r\nl2_tei_remove(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nskb_queue_purge(&l2->i_queue);\r\nskb_queue_purge(&l2->ui_queue);\r\nfreewin(l2);\r\nl2->tei = GROUP_TEI;\r\nstop_t200(l2, 17);\r\nmISDN_FsmDelTimer(&l2->t203, 19);\r\nl2up_create(l2, DL_RELEASE_IND, 0, NULL);\r\nmISDN_FsmChangeState(fi, ST_L2_1);\r\n}\r\nstatic void\r\nl2_st14_persistent_da(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_queue_purge(&l2->i_queue);\r\nskb_queue_purge(&l2->ui_queue);\r\nif (test_and_clear_bit(FLG_ESTAB_PEND, &l2->flag))\r\nl2up(l2, DL_RELEASE_IND, skb);\r\nelse\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nl2_st5_persistent_da(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_queue_purge(&l2->i_queue);\r\nskb_queue_purge(&l2->ui_queue);\r\nfreewin(l2);\r\nstop_t200(l2, 19);\r\nst5_dl_release_l2l3(l2);\r\nmISDN_FsmChangeState(fi, ST_L2_4);\r\nif (l2->tm)\r\nl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nl2_st6_persistent_da(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_queue_purge(&l2->ui_queue);\r\nstop_t200(l2, 20);\r\nl2up(l2, DL_RELEASE_CNF, skb);\r\nmISDN_FsmChangeState(fi, ST_L2_4);\r\nif (l2->tm)\r\nl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\r\n}\r\nstatic void\r\nl2_persistent_da(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_queue_purge(&l2->i_queue);\r\nskb_queue_purge(&l2->ui_queue);\r\nfreewin(l2);\r\nstop_t200(l2, 19);\r\nmISDN_FsmDelTimer(&l2->t203, 19);\r\nl2up(l2, DL_RELEASE_IND, skb);\r\nmISDN_FsmChangeState(fi, ST_L2_4);\r\nif (l2->tm)\r\nl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\r\n}\r\nstatic void\r\nl2_set_own_busy(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nif (!test_and_set_bit(FLG_OWN_BUSY, &l2->flag)) {\r\nenquiry_cr(l2, RNR, RSP, 0);\r\ntest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\r\n}\r\nif (skb)\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nl2_clear_own_busy(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nif (!test_and_clear_bit(FLG_OWN_BUSY, &l2->flag)) {\r\nenquiry_cr(l2, RR, RSP, 0);\r\ntest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\r\n}\r\nif (skb)\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nl2_frame_error(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nl2mgr(l2, MDL_ERROR_IND, arg);\r\n}\r\nstatic void\r\nl2_frame_error_reest(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct layer2 *l2 = fi->userdata;\r\nl2mgr(l2, MDL_ERROR_IND, arg);\r\nestablishlink(fi);\r\ntest_and_clear_bit(FLG_L3_INIT, &l2->flag);\r\n}\r\nstatic int\r\nph_data_indication(struct layer2 *l2, struct mISDNhead *hh, struct sk_buff *skb)\r\n{\r\nu_char *datap = skb->data;\r\nint ret = -EINVAL;\r\nint psapi, ptei;\r\nu_int l;\r\nint c = 0;\r\nl = l2addrsize(l2);\r\nif (skb->len <= l) {\r\nmISDN_FsmEvent(&l2->l2m, EV_L2_FRAME_ERROR, (void *) 'N');\r\nreturn ret;\r\n}\r\nif (test_bit(FLG_LAPD, &l2->flag)) {\r\npsapi = *datap++;\r\nptei = *datap++;\r\nif ((psapi & 1) || !(ptei & 1)) {\r\nprintk(KERN_WARNING\r\n"%s l2 D-channel frame wrong EA0/EA1\n",\r\nmISDNDevName4ch(&l2->ch));\r\nreturn ret;\r\n}\r\npsapi >>= 2;\r\nptei >>= 1;\r\nif (psapi != l2->sapi) {\r\nif (*debug & DEBUG_L2)\r\nprintk(KERN_DEBUG "%s: sapi %d/%d mismatch\n",\r\nmISDNDevName4ch(&l2->ch), psapi,\r\nl2->sapi);\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nif ((ptei != l2->tei) && (ptei != GROUP_TEI)) {\r\nif (*debug & DEBUG_L2)\r\nprintk(KERN_DEBUG "%s: tei %d/%d mismatch\n",\r\nmISDNDevName4ch(&l2->ch), ptei, l2->tei);\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\n} else\r\ndatap += l;\r\nif (!(*datap & 1)) {\r\nc = iframe_error(l2, skb);\r\nif (!c)\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L2_I, skb);\r\n} else if (IsSFrame(datap, l2)) {\r\nc = super_error(l2, skb);\r\nif (!c)\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L2_SUPER, skb);\r\n} else if (IsUI(datap)) {\r\nc = UI_error(l2, skb);\r\nif (!c)\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L2_UI, skb);\r\n} else if (IsSABME(datap, l2)) {\r\nc = unnum_error(l2, skb, CMD);\r\nif (!c)\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L2_SABME, skb);\r\n} else if (IsUA(datap)) {\r\nc = unnum_error(l2, skb, RSP);\r\nif (!c)\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L2_UA, skb);\r\n} else if (IsDISC(datap)) {\r\nc = unnum_error(l2, skb, CMD);\r\nif (!c)\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L2_DISC, skb);\r\n} else if (IsDM(datap)) {\r\nc = unnum_error(l2, skb, RSP);\r\nif (!c)\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L2_DM, skb);\r\n} else if (IsFRMR(datap)) {\r\nc = FRMR_error(l2, skb);\r\nif (!c)\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L2_FRMR, skb);\r\n} else\r\nc = 'L';\r\nif (c) {\r\nprintk(KERN_WARNING "%s:l2 D-channel frame error %c\n",\r\nmISDNDevName4ch(&l2->ch), c);\r\nmISDN_FsmEvent(&l2->l2m, EV_L2_FRAME_ERROR, (void *)(long)c);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nl2_send(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct layer2 *l2 = container_of(ch, struct layer2, ch);\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nint ret = -EINVAL;\r\nif (*debug & DEBUG_L2_RECV)\r\nprintk(KERN_DEBUG "%s: %s prim(%x) id(%x) sapi(%d) tei(%d)\n",\r\n__func__, mISDNDevName4ch(&l2->ch), hh->prim, hh->id,\r\nl2->sapi, l2->tei);\r\nif (hh->prim == DL_INTERN_MSG) {\r\nstruct mISDNhead *chh = hh + 1;\r\n*hh = *chh;\r\nif (*debug & DEBUG_L2_RECV)\r\nprintk(KERN_DEBUG "%s: prim(%x) id(%x) internal msg\n",\r\nmISDNDevName4ch(&l2->ch), hh->prim, hh->id);\r\n}\r\nswitch (hh->prim) {\r\ncase PH_DATA_IND:\r\nret = ph_data_indication(l2, hh, skb);\r\nbreak;\r\ncase PH_DATA_CNF:\r\nret = ph_data_confirm(l2, hh, skb);\r\nbreak;\r\ncase PH_ACTIVATE_IND:\r\ntest_and_set_bit(FLG_L1_ACTIV, &l2->flag);\r\nl2up_create(l2, MPH_ACTIVATE_IND, 0, NULL);\r\nif (test_and_clear_bit(FLG_ESTAB_PEND, &l2->flag))\r\nret = mISDN_FsmEvent(&l2->l2m,\r\nEV_L2_DL_ESTABLISH_REQ, skb);\r\nbreak;\r\ncase PH_DEACTIVATE_IND:\r\ntest_and_clear_bit(FLG_L1_ACTIV, &l2->flag);\r\nl2up_create(l2, MPH_DEACTIVATE_IND, 0, NULL);\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L1_DEACTIVATE, skb);\r\nbreak;\r\ncase MPH_INFORMATION_IND:\r\nif (!l2->up)\r\nbreak;\r\nret = l2->up->send(l2->up, skb);\r\nbreak;\r\ncase DL_DATA_REQ:\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L2_DL_DATA, skb);\r\nbreak;\r\ncase DL_UNITDATA_REQ:\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L2_DL_UNITDATA, skb);\r\nbreak;\r\ncase DL_ESTABLISH_REQ:\r\nif (test_bit(FLG_LAPB, &l2->flag))\r\ntest_and_set_bit(FLG_ORIG, &l2->flag);\r\nif (test_bit(FLG_L1_ACTIV, &l2->flag)) {\r\nif (test_bit(FLG_LAPD, &l2->flag) ||\r\ntest_bit(FLG_ORIG, &l2->flag))\r\nret = mISDN_FsmEvent(&l2->l2m,\r\nEV_L2_DL_ESTABLISH_REQ, skb);\r\n} else {\r\nif (test_bit(FLG_LAPD, &l2->flag) ||\r\ntest_bit(FLG_ORIG, &l2->flag)) {\r\ntest_and_set_bit(FLG_ESTAB_PEND,\r\n&l2->flag);\r\n}\r\nret = l2down(l2, PH_ACTIVATE_REQ, l2_newid(l2),\r\nskb);\r\n}\r\nbreak;\r\ncase DL_RELEASE_REQ:\r\nif (test_bit(FLG_LAPB, &l2->flag))\r\nl2down_create(l2, PH_DEACTIVATE_REQ,\r\nl2_newid(l2), 0, NULL);\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L2_DL_RELEASE_REQ,\r\nskb);\r\nbreak;\r\ncase DL_TIMER200_IND:\r\nmISDN_FsmEvent(&l2->l2m, EV_L2_T200I, NULL);\r\nbreak;\r\ncase DL_TIMER203_IND:\r\nmISDN_FsmEvent(&l2->l2m, EV_L2_T203I, NULL);\r\nbreak;\r\ndefault:\r\nif (*debug & DEBUG_L2)\r\nl2m_debug(&l2->l2m, "l2 unknown pr %04x",\r\nhh->prim);\r\n}\r\nif (ret) {\r\ndev_kfree_skb(skb);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nint\r\ntei_l2(struct layer2 *l2, u_int cmd, u_long arg)\r\n{\r\nint ret = -EINVAL;\r\nif (*debug & DEBUG_L2_TEI)\r\nprintk(KERN_DEBUG "%s: cmd(%x) in %s\n",\r\nmISDNDevName4ch(&l2->ch), cmd, __func__);\r\nswitch (cmd) {\r\ncase (MDL_ASSIGN_REQ):\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L2_MDL_ASSIGN, (void *)arg);\r\nbreak;\r\ncase (MDL_REMOVE_REQ):\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L2_MDL_REMOVE, NULL);\r\nbreak;\r\ncase (MDL_ERROR_IND):\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L2_MDL_ERROR, NULL);\r\nbreak;\r\ncase (MDL_ERROR_RSP):\r\nprintk(KERN_NOTICE "%s: MDL_ERROR|REQ (tei_l2)\n",\r\nmISDNDevName4ch(&l2->ch));\r\nret = mISDN_FsmEvent(&l2->l2m, EV_L2_MDL_ERROR, NULL);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nrelease_l2(struct layer2 *l2)\r\n{\r\nmISDN_FsmDelTimer(&l2->t200, 21);\r\nmISDN_FsmDelTimer(&l2->t203, 16);\r\nskb_queue_purge(&l2->i_queue);\r\nskb_queue_purge(&l2->ui_queue);\r\nskb_queue_purge(&l2->down_queue);\r\nReleaseWin(l2);\r\nif (test_bit(FLG_LAPD, &l2->flag)) {\r\nTEIrelease(l2);\r\nif (l2->ch.st)\r\nl2->ch.st->dev->D.ctrl(&l2->ch.st->dev->D,\r\nCLOSE_CHANNEL, NULL);\r\n}\r\nkfree(l2);\r\n}\r\nstatic int\r\nl2_ctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\r\n{\r\nstruct layer2 *l2 = container_of(ch, struct layer2, ch);\r\nu_int info;\r\nif (*debug & DEBUG_L2_CTRL)\r\nprintk(KERN_DEBUG "%s: %s cmd(%x)\n",\r\nmISDNDevName4ch(ch), __func__, cmd);\r\nswitch (cmd) {\r\ncase OPEN_CHANNEL:\r\nif (test_bit(FLG_LAPD, &l2->flag)) {\r\nset_channel_address(&l2->ch, l2->sapi, l2->tei);\r\ninfo = DL_INFO_L2_CONNECT;\r\nl2up_create(l2, DL_INFORMATION_IND,\r\nsizeof(info), &info);\r\n}\r\nbreak;\r\ncase CLOSE_CHANNEL:\r\nif (l2->ch.peer)\r\nl2->ch.peer->ctrl(l2->ch.peer, CLOSE_CHANNEL, NULL);\r\nrelease_l2(l2);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstruct layer2 *\r\ncreate_l2(struct mISDNchannel *ch, u_int protocol, u_long options, int tei,\r\nint sapi)\r\n{\r\nstruct layer2 *l2;\r\nstruct channel_req rq;\r\nl2 = kzalloc(sizeof(struct layer2), GFP_KERNEL);\r\nif (!l2) {\r\nprintk(KERN_ERR "kzalloc layer2 failed\n");\r\nreturn NULL;\r\n}\r\nl2->next_id = 1;\r\nl2->down_id = MISDN_ID_NONE;\r\nl2->up = ch;\r\nl2->ch.st = ch->st;\r\nl2->ch.send = l2_send;\r\nl2->ch.ctrl = l2_ctrl;\r\nswitch (protocol) {\r\ncase ISDN_P_LAPD_NT:\r\ntest_and_set_bit(FLG_LAPD, &l2->flag);\r\ntest_and_set_bit(FLG_LAPD_NET, &l2->flag);\r\ntest_and_set_bit(FLG_MOD128, &l2->flag);\r\nl2->sapi = sapi;\r\nl2->maxlen = MAX_DFRAME_LEN;\r\nif (test_bit(OPTION_L2_PMX, &options))\r\nl2->window = 7;\r\nelse\r\nl2->window = 1;\r\nif (test_bit(OPTION_L2_PTP, &options))\r\ntest_and_set_bit(FLG_PTP, &l2->flag);\r\nif (test_bit(OPTION_L2_FIXEDTEI, &options))\r\ntest_and_set_bit(FLG_FIXED_TEI, &l2->flag);\r\nl2->tei = tei;\r\nl2->T200 = 1000;\r\nl2->N200 = 3;\r\nl2->T203 = 10000;\r\nif (test_bit(OPTION_L2_PMX, &options))\r\nrq.protocol = ISDN_P_NT_E1;\r\nelse\r\nrq.protocol = ISDN_P_NT_S0;\r\nrq.adr.channel = 0;\r\nl2->ch.st->dev->D.ctrl(&l2->ch.st->dev->D, OPEN_CHANNEL, &rq);\r\nbreak;\r\ncase ISDN_P_LAPD_TE:\r\ntest_and_set_bit(FLG_LAPD, &l2->flag);\r\ntest_and_set_bit(FLG_MOD128, &l2->flag);\r\ntest_and_set_bit(FLG_ORIG, &l2->flag);\r\nl2->sapi = sapi;\r\nl2->maxlen = MAX_DFRAME_LEN;\r\nif (test_bit(OPTION_L2_PMX, &options))\r\nl2->window = 7;\r\nelse\r\nl2->window = 1;\r\nif (test_bit(OPTION_L2_PTP, &options))\r\ntest_and_set_bit(FLG_PTP, &l2->flag);\r\nif (test_bit(OPTION_L2_FIXEDTEI, &options))\r\ntest_and_set_bit(FLG_FIXED_TEI, &l2->flag);\r\nl2->tei = tei;\r\nl2->T200 = 1000;\r\nl2->N200 = 3;\r\nl2->T203 = 10000;\r\nif (test_bit(OPTION_L2_PMX, &options))\r\nrq.protocol = ISDN_P_TE_E1;\r\nelse\r\nrq.protocol = ISDN_P_TE_S0;\r\nrq.adr.channel = 0;\r\nl2->ch.st->dev->D.ctrl(&l2->ch.st->dev->D, OPEN_CHANNEL, &rq);\r\nbreak;\r\ncase ISDN_P_B_X75SLP:\r\ntest_and_set_bit(FLG_LAPB, &l2->flag);\r\nl2->window = 7;\r\nl2->maxlen = MAX_DATA_SIZE;\r\nl2->T200 = 1000;\r\nl2->N200 = 4;\r\nl2->T203 = 5000;\r\nl2->addr.A = 3;\r\nl2->addr.B = 1;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "layer2 create failed prt %x\n",\r\nprotocol);\r\nkfree(l2);\r\nreturn NULL;\r\n}\r\nskb_queue_head_init(&l2->i_queue);\r\nskb_queue_head_init(&l2->ui_queue);\r\nskb_queue_head_init(&l2->down_queue);\r\nskb_queue_head_init(&l2->tmp_queue);\r\nInitWin(l2);\r\nl2->l2m.fsm = &l2fsm;\r\nif (test_bit(FLG_LAPB, &l2->flag) ||\r\ntest_bit(FLG_FIXED_TEI, &l2->flag) ||\r\ntest_bit(FLG_LAPD_NET, &l2->flag))\r\nl2->l2m.state = ST_L2_4;\r\nelse\r\nl2->l2m.state = ST_L2_1;\r\nl2->l2m.debug = *debug;\r\nl2->l2m.userdata = l2;\r\nl2->l2m.userint = 0;\r\nl2->l2m.printdebug = l2m_debug;\r\nmISDN_FsmInitTimer(&l2->l2m, &l2->t200);\r\nmISDN_FsmInitTimer(&l2->l2m, &l2->t203);\r\nreturn l2;\r\n}\r\nstatic int\r\nx75create(struct channel_req *crq)\r\n{\r\nstruct layer2 *l2;\r\nif (crq->protocol != ISDN_P_B_X75SLP)\r\nreturn -EPROTONOSUPPORT;\r\nl2 = create_l2(crq->ch, crq->protocol, 0, 0, 0);\r\nif (!l2)\r\nreturn -ENOMEM;\r\ncrq->ch = &l2->ch;\r\ncrq->protocol = ISDN_P_B_HDLC;\r\nreturn 0;\r\n}\r\nint\r\nIsdnl2_Init(u_int *deb)\r\n{\r\nint res;\r\ndebug = deb;\r\nmISDN_register_Bprotocol(&X75SLP);\r\nl2fsm.state_count = L2_STATE_COUNT;\r\nl2fsm.event_count = L2_EVENT_COUNT;\r\nl2fsm.strEvent = strL2Event;\r\nl2fsm.strState = strL2State;\r\nres = mISDN_FsmNew(&l2fsm, L2FnList, ARRAY_SIZE(L2FnList));\r\nif (res)\r\ngoto error;\r\nres = TEIInit(deb);\r\nif (res)\r\ngoto error_fsm;\r\nreturn 0;\r\nerror_fsm:\r\nmISDN_FsmFree(&l2fsm);\r\nerror:\r\nmISDN_unregister_Bprotocol(&X75SLP);\r\nreturn res;\r\n}\r\nvoid\r\nIsdnl2_cleanup(void)\r\n{\r\nmISDN_unregister_Bprotocol(&X75SLP);\r\nTEIFree();\r\nmISDN_FsmFree(&l2fsm);\r\n}
