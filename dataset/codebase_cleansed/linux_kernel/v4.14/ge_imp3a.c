void __init ge_imp3a_pic_init(void)\r\n{\r\nstruct mpic *mpic;\r\nstruct device_node *np;\r\nstruct device_node *cascade_node = NULL;\r\nif (of_machine_is_compatible("fsl,MPC8572DS-CAMP")) {\r\nmpic = mpic_alloc(NULL, 0,\r\nMPIC_NO_RESET |\r\nMPIC_BIG_ENDIAN |\r\nMPIC_SINGLE_DEST_CPU,\r\n0, 256, " OpenPIC ");\r\n} else {\r\nmpic = mpic_alloc(NULL, 0,\r\nMPIC_BIG_ENDIAN |\r\nMPIC_SINGLE_DEST_CPU,\r\n0, 256, " OpenPIC ");\r\n}\r\nBUG_ON(mpic == NULL);\r\nmpic_init(mpic);\r\nfor_each_node_by_type(np, "interrupt-controller")\r\nif (of_device_is_compatible(np, "gef,fpga-pic-1.00")) {\r\ncascade_node = np;\r\nbreak;\r\n}\r\nif (cascade_node == NULL) {\r\nprintk(KERN_WARNING "IMP3A: No FPGA PIC\n");\r\nreturn;\r\n}\r\ngef_pic_init(cascade_node);\r\nof_node_put(cascade_node);\r\n}\r\nstatic void ge_imp3a_pci_assign_primary(void)\r\n{\r\n#ifdef CONFIG_PCI\r\nstruct device_node *np;\r\nstruct resource rsrc;\r\nfor_each_node_by_type(np, "pci") {\r\nif (of_device_is_compatible(np, "fsl,mpc8540-pci") ||\r\nof_device_is_compatible(np, "fsl,mpc8548-pcie") ||\r\nof_device_is_compatible(np, "fsl,p2020-pcie")) {\r\nof_address_to_resource(np, 0, &rsrc);\r\nif ((rsrc.start & 0xfffff) == 0x9000)\r\nfsl_pci_primary = np;\r\n}\r\n}\r\n#endif\r\n}\r\nstatic void __init ge_imp3a_setup_arch(void)\r\n{\r\nstruct device_node *regs;\r\nif (ppc_md.progress)\r\nppc_md.progress("ge_imp3a_setup_arch()", 0);\r\nmpc85xx_smp_init();\r\nge_imp3a_pci_assign_primary();\r\nswiotlb_detect_4g();\r\nregs = of_find_compatible_node(NULL, NULL, "ge,imp3a-fpga-regs");\r\nif (regs) {\r\nimp3a_regs = of_iomap(regs, 0);\r\nif (imp3a_regs == NULL)\r\nprintk(KERN_WARNING "Unable to map board registers\n");\r\nof_node_put(regs);\r\n}\r\n#if defined(CONFIG_MMIO_NVRAM)\r\nmmio_nvram_init();\r\n#endif\r\nprintk(KERN_INFO "GE Intelligent Platforms IMP3A 3U cPCI SBC\n");\r\n}\r\nstatic unsigned int ge_imp3a_get_pcb_rev(void)\r\n{\r\nunsigned int reg;\r\nreg = ioread16(imp3a_regs);\r\nreturn (reg >> 8) & 0xff;\r\n}\r\nstatic unsigned int ge_imp3a_get_board_rev(void)\r\n{\r\nunsigned int reg;\r\nreg = ioread16(imp3a_regs + 0x2);\r\nreturn reg & 0xff;\r\n}\r\nstatic unsigned int ge_imp3a_get_fpga_rev(void)\r\n{\r\nunsigned int reg;\r\nreg = ioread16(imp3a_regs + 0x2);\r\nreturn (reg >> 8) & 0xff;\r\n}\r\nstatic unsigned int ge_imp3a_get_cpci_geo_addr(void)\r\n{\r\nunsigned int reg;\r\nreg = ioread16(imp3a_regs + 0x6);\r\nreturn (reg & 0x0f00) >> 8;\r\n}\r\nstatic unsigned int ge_imp3a_get_cpci_is_syscon(void)\r\n{\r\nunsigned int reg;\r\nreg = ioread16(imp3a_regs + 0x6);\r\nreturn reg & (1 << 12);\r\n}\r\nstatic void ge_imp3a_show_cpuinfo(struct seq_file *m)\r\n{\r\nseq_printf(m, "Vendor\t\t: GE Intelligent Platforms\n");\r\nseq_printf(m, "Revision\t: %u%c\n", ge_imp3a_get_pcb_rev(),\r\n('A' + ge_imp3a_get_board_rev() - 1));\r\nseq_printf(m, "FPGA Revision\t: %u\n", ge_imp3a_get_fpga_rev());\r\nseq_printf(m, "cPCI geo. addr\t: %u\n", ge_imp3a_get_cpci_geo_addr());\r\nseq_printf(m, "cPCI syscon\t: %s\n",\r\nge_imp3a_get_cpci_is_syscon() ? "yes" : "no");\r\n}\r\nstatic int __init ge_imp3a_probe(void)\r\n{\r\nreturn of_machine_is_compatible("ge,IMP3A");\r\n}
