void __init octeon_setup_delays(void)\r\n{\r\nocteon_udelay_factor = octeon_get_clock_rate() / 1000000;\r\nocteon_ndelay_factor = (octeon_udelay_factor * 0x10000ull) / 1000ull;\r\npreset_lpj = octeon_get_clock_rate() / HZ;\r\nif (current_cpu_type() == CPU_CAVIUM_OCTEON2) {\r\nunion cvmx_mio_rst_boot rst_boot;\r\nrst_boot.u64 = cvmx_read_csr(CVMX_MIO_RST_BOOT);\r\nrdiv = rst_boot.s.c_mul;\r\nsdiv = rst_boot.s.pnr_mul;\r\nf = (0x8000000000000000ull / sdiv) * 2;\r\n} else if (current_cpu_type() == CPU_CAVIUM_OCTEON3) {\r\nunion cvmx_rst_boot rst_boot;\r\nrst_boot.u64 = cvmx_read_csr(CVMX_RST_BOOT);\r\nrdiv = rst_boot.s.c_mul;\r\nsdiv = rst_boot.s.pnr_mul;\r\nf = (0x8000000000000000ull / sdiv) * 2;\r\n}\r\n}\r\nvoid octeon_init_cvmcount(void)\r\n{\r\nu64 clk_reg;\r\nunsigned long flags;\r\nunsigned loops = 2;\r\nclk_reg = octeon_has_feature(OCTEON_FEATURE_FPA3) ?\r\nCVMX_FPA_CLK_COUNT : CVMX_IPD_CLK_COUNT;\r\nasm("" : "+r" (loops));\r\nlocal_irq_save(flags);\r\nwhile (loops--) {\r\nu64 clk_count = cvmx_read_csr(clk_reg);\r\nif (rdiv != 0) {\r\nclk_count *= rdiv;\r\nif (f != 0) {\r\nasm("dmultu\t%[cnt],%[f]\n\t"\r\n"mfhi\t%[cnt]"\r\n: [cnt] "+r" (clk_count)\r\n: [f] "r" (f)\r\n: "hi", "lo");\r\n}\r\n}\r\nwrite_c0_cvmcount(clk_count);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic u64 octeon_cvmcount_read(struct clocksource *cs)\r\n{\r\nreturn read_c0_cvmcount();\r\n}\r\nunsigned long long notrace sched_clock(void)\r\n{\r\nu64 t1, t2, t3;\r\nunsigned long long rv;\r\nu64 mult = clocksource_mips.mult;\r\nu64 shift = clocksource_mips.shift;\r\nu64 cnt = read_c0_cvmcount();\r\nasm (\r\n"dmultu\t%[cnt],%[mult]\n\t"\r\n"nor\t%[t1],$0,%[shift]\n\t"\r\n"mfhi\t%[t2]\n\t"\r\n"mflo\t%[t3]\n\t"\r\n"dsll\t%[t2],%[t2],1\n\t"\r\n"dsrlv\t%[rv],%[t3],%[shift]\n\t"\r\n"dsllv\t%[t1],%[t2],%[t1]\n\t"\r\n"or\t%[rv],%[t1],%[rv]\n\t"\r\n: [rv] "=&r" (rv), [t1] "=&r" (t1), [t2] "=&r" (t2), [t3] "=&r" (t3)\r\n: [cnt] "r" (cnt), [mult] "r" (mult), [shift] "r" (shift)\r\n: "hi", "lo");\r\nreturn rv;\r\n}\r\nvoid __init plat_time_init(void)\r\n{\r\nclocksource_mips.rating = 300;\r\nclocksource_register_hz(&clocksource_mips, octeon_get_clock_rate());\r\n}\r\nvoid __udelay(unsigned long us)\r\n{\r\nu64 cur, end, inc;\r\ncur = read_c0_cvmcount();\r\ninc = us * octeon_udelay_factor;\r\nend = cur + inc;\r\nwhile (end > cur)\r\ncur = read_c0_cvmcount();\r\n}\r\nvoid __ndelay(unsigned long ns)\r\n{\r\nu64 cur, end, inc;\r\ncur = read_c0_cvmcount();\r\ninc = ((ns * octeon_ndelay_factor) >> 16);\r\nend = cur + inc;\r\nwhile (end > cur)\r\ncur = read_c0_cvmcount();\r\n}\r\nvoid __delay(unsigned long loops)\r\n{\r\nu64 cur, end;\r\ncur = read_c0_cvmcount();\r\nend = cur + loops;\r\nwhile (end > cur)\r\ncur = read_c0_cvmcount();\r\n}\r\nvoid octeon_io_clk_delay(unsigned long count)\r\n{\r\nu64 cur, end;\r\ncur = read_c0_cvmcount();\r\nif (rdiv != 0) {\r\nend = count * rdiv;\r\nif (f != 0) {\r\nasm("dmultu\t%[cnt],%[f]\n\t"\r\n"mfhi\t%[cnt]"\r\n: [cnt] "+r" (end)\r\n: [f] "r" (f)\r\n: "hi", "lo");\r\n}\r\nend = cur + end;\r\n} else {\r\nend = cur + count;\r\n}\r\nwhile (end > cur)\r\ncur = read_c0_cvmcount();\r\n}
