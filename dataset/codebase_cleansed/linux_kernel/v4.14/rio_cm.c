static int riocm_cmp(struct rio_channel *ch, enum rio_cm_state cmp)\r\n{\r\nint ret;\r\nspin_lock_bh(&ch->lock);\r\nret = (ch->state == cmp);\r\nspin_unlock_bh(&ch->lock);\r\nreturn ret;\r\n}\r\nstatic int riocm_cmp_exch(struct rio_channel *ch,\r\nenum rio_cm_state cmp, enum rio_cm_state exch)\r\n{\r\nint ret;\r\nspin_lock_bh(&ch->lock);\r\nret = (ch->state == cmp);\r\nif (ret)\r\nch->state = exch;\r\nspin_unlock_bh(&ch->lock);\r\nreturn ret;\r\n}\r\nstatic enum rio_cm_state riocm_exch(struct rio_channel *ch,\r\nenum rio_cm_state exch)\r\n{\r\nenum rio_cm_state old;\r\nspin_lock_bh(&ch->lock);\r\nold = ch->state;\r\nch->state = exch;\r\nspin_unlock_bh(&ch->lock);\r\nreturn old;\r\n}\r\nstatic struct rio_channel *riocm_get_channel(u16 nr)\r\n{\r\nstruct rio_channel *ch;\r\nspin_lock_bh(&idr_lock);\r\nch = idr_find(&ch_idr, nr);\r\nif (ch)\r\nkref_get(&ch->ref);\r\nspin_unlock_bh(&idr_lock);\r\nreturn ch;\r\n}\r\nstatic void riocm_put_channel(struct rio_channel *ch)\r\n{\r\nkref_put(&ch->ref, riocm_ch_free);\r\n}\r\nstatic void *riocm_rx_get_msg(struct cm_dev *cm)\r\n{\r\nvoid *msg;\r\nint i;\r\nmsg = rio_get_inb_message(cm->mport, cmbox);\r\nif (msg) {\r\nfor (i = 0; i < RIOCM_RX_RING_SIZE; i++) {\r\nif (cm->rx_buf[i] == msg) {\r\ncm->rx_buf[i] = NULL;\r\ncm->rx_slots++;\r\nbreak;\r\n}\r\n}\r\nif (i == RIOCM_RX_RING_SIZE)\r\nriocm_warn("no record for buffer 0x%p", msg);\r\n}\r\nreturn msg;\r\n}\r\nstatic void riocm_rx_fill(struct cm_dev *cm, int nent)\r\n{\r\nint i;\r\nif (cm->rx_slots == 0)\r\nreturn;\r\nfor (i = 0; i < RIOCM_RX_RING_SIZE && cm->rx_slots && nent; i++) {\r\nif (cm->rx_buf[i] == NULL) {\r\ncm->rx_buf[i] = kmalloc(RIO_MAX_MSG_SIZE, GFP_KERNEL);\r\nif (cm->rx_buf[i] == NULL)\r\nbreak;\r\nrio_add_inb_buffer(cm->mport, cmbox, cm->rx_buf[i]);\r\ncm->rx_slots--;\r\nnent--;\r\n}\r\n}\r\n}\r\nstatic void riocm_rx_free(struct cm_dev *cm)\r\n{\r\nint i;\r\nfor (i = 0; i < RIOCM_RX_RING_SIZE; i++) {\r\nif (cm->rx_buf[i] != NULL) {\r\nkfree(cm->rx_buf[i]);\r\ncm->rx_buf[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic int riocm_req_handler(struct cm_dev *cm, void *req_data)\r\n{\r\nstruct rio_channel *ch;\r\nstruct conn_req *req;\r\nstruct rio_ch_chan_hdr *hh = req_data;\r\nu16 chnum;\r\nchnum = ntohs(hh->dst_ch);\r\nch = riocm_get_channel(chnum);\r\nif (!ch)\r\nreturn -ENODEV;\r\nif (ch->state != RIO_CM_LISTEN) {\r\nriocm_debug(RX_CMD, "channel %d is not in listen state", chnum);\r\nriocm_put_channel(ch);\r\nreturn -EINVAL;\r\n}\r\nreq = kzalloc(sizeof(*req), GFP_KERNEL);\r\nif (!req) {\r\nriocm_put_channel(ch);\r\nreturn -ENOMEM;\r\n}\r\nreq->destid = ntohl(hh->bhdr.src_id);\r\nreq->chan = ntohs(hh->src_ch);\r\nreq->cmdev = cm;\r\nspin_lock_bh(&ch->lock);\r\nlist_add_tail(&req->node, &ch->accept_queue);\r\nspin_unlock_bh(&ch->lock);\r\ncomplete(&ch->comp);\r\nriocm_put_channel(ch);\r\nreturn 0;\r\n}\r\nstatic int riocm_resp_handler(void *resp_data)\r\n{\r\nstruct rio_channel *ch;\r\nstruct rio_ch_chan_hdr *hh = resp_data;\r\nu16 chnum;\r\nchnum = ntohs(hh->dst_ch);\r\nch = riocm_get_channel(chnum);\r\nif (!ch)\r\nreturn -ENODEV;\r\nif (ch->state != RIO_CM_CONNECT) {\r\nriocm_put_channel(ch);\r\nreturn -EINVAL;\r\n}\r\nriocm_exch(ch, RIO_CM_CONNECTED);\r\nch->rem_channel = ntohs(hh->src_ch);\r\ncomplete(&ch->comp);\r\nriocm_put_channel(ch);\r\nreturn 0;\r\n}\r\nstatic int riocm_close_handler(void *data)\r\n{\r\nstruct rio_channel *ch;\r\nstruct rio_ch_chan_hdr *hh = data;\r\nint ret;\r\nriocm_debug(RX_CMD, "for ch=%d", ntohs(hh->dst_ch));\r\nspin_lock_bh(&idr_lock);\r\nch = idr_find(&ch_idr, ntohs(hh->dst_ch));\r\nif (!ch) {\r\nspin_unlock_bh(&idr_lock);\r\nreturn -ENODEV;\r\n}\r\nidr_remove(&ch_idr, ch->id);\r\nspin_unlock_bh(&idr_lock);\r\nriocm_exch(ch, RIO_CM_DISCONNECT);\r\nret = riocm_ch_close(ch);\r\nif (ret)\r\nriocm_debug(RX_CMD, "riocm_ch_close() returned %d", ret);\r\nreturn 0;\r\n}\r\nstatic void rio_cm_handler(struct cm_dev *cm, void *data)\r\n{\r\nstruct rio_ch_chan_hdr *hdr;\r\nif (!rio_mport_is_running(cm->mport))\r\ngoto out;\r\nhdr = data;\r\nriocm_debug(RX_CMD, "OP=%x for ch=%d from %d",\r\nhdr->ch_op, ntohs(hdr->dst_ch), ntohs(hdr->src_ch));\r\nswitch (hdr->ch_op) {\r\ncase CM_CONN_REQ:\r\nriocm_req_handler(cm, data);\r\nbreak;\r\ncase CM_CONN_ACK:\r\nriocm_resp_handler(data);\r\nbreak;\r\ncase CM_CONN_CLOSE:\r\nriocm_close_handler(data);\r\nbreak;\r\ndefault:\r\nriocm_error("Invalid packet header");\r\nbreak;\r\n}\r\nout:\r\nkfree(data);\r\n}\r\nstatic int rio_rx_data_handler(struct cm_dev *cm, void *buf)\r\n{\r\nstruct rio_ch_chan_hdr *hdr;\r\nstruct rio_channel *ch;\r\nhdr = buf;\r\nriocm_debug(RX_DATA, "for ch=%d", ntohs(hdr->dst_ch));\r\nch = riocm_get_channel(ntohs(hdr->dst_ch));\r\nif (!ch) {\r\nkfree(buf);\r\nreturn -ENODEV;\r\n}\r\nspin_lock(&ch->lock);\r\nif (ch->state != RIO_CM_CONNECTED) {\r\nriocm_debug(RX_DATA, "ch=%d is in wrong state=%d",\r\nch->id, ch->state);\r\nspin_unlock(&ch->lock);\r\nkfree(buf);\r\nriocm_put_channel(ch);\r\nreturn -EIO;\r\n}\r\nif (ch->rx_ring.count == RIOCM_RX_RING_SIZE) {\r\nriocm_debug(RX_DATA, "ch=%d is full", ch->id);\r\nspin_unlock(&ch->lock);\r\nkfree(buf);\r\nriocm_put_channel(ch);\r\nreturn -ENOMEM;\r\n}\r\nch->rx_ring.buf[ch->rx_ring.head] = buf;\r\nch->rx_ring.head++;\r\nch->rx_ring.count++;\r\nch->rx_ring.head %= RIOCM_RX_RING_SIZE;\r\ncomplete(&ch->comp);\r\nspin_unlock(&ch->lock);\r\nriocm_put_channel(ch);\r\nreturn 0;\r\n}\r\nstatic void rio_ibmsg_handler(struct work_struct *work)\r\n{\r\nstruct cm_dev *cm = container_of(work, struct cm_dev, rx_work);\r\nvoid *data;\r\nstruct rio_ch_chan_hdr *hdr;\r\nif (!rio_mport_is_running(cm->mport))\r\nreturn;\r\nwhile (1) {\r\nmutex_lock(&cm->rx_lock);\r\ndata = riocm_rx_get_msg(cm);\r\nif (data)\r\nriocm_rx_fill(cm, 1);\r\nmutex_unlock(&cm->rx_lock);\r\nif (data == NULL)\r\nbreak;\r\nhdr = data;\r\nif (hdr->bhdr.type != RIO_CM_CHAN) {\r\nriocm_error("Unsupported TYPE code (0x%x). Msg dropped",\r\nhdr->bhdr.type);\r\nkfree(data);\r\ncontinue;\r\n}\r\nif (hdr->ch_op == CM_DATA_MSG)\r\nrio_rx_data_handler(cm, data);\r\nelse\r\nrio_cm_handler(cm, data);\r\n}\r\n}\r\nstatic void riocm_inb_msg_event(struct rio_mport *mport, void *dev_id,\r\nint mbox, int slot)\r\n{\r\nstruct cm_dev *cm = dev_id;\r\nif (rio_mport_is_running(cm->mport) && !work_pending(&cm->rx_work))\r\nqueue_work(cm->rx_wq, &cm->rx_work);\r\n}\r\nstatic void rio_txcq_handler(struct cm_dev *cm, int slot)\r\n{\r\nint ack_slot;\r\nriocm_debug(TX_EVENT, "for mport_%d slot %d tx_cnt %d",\r\ncm->mport->id, slot, cm->tx_cnt);\r\nspin_lock(&cm->tx_lock);\r\nack_slot = cm->tx_ack_slot;\r\nif (ack_slot == slot)\r\nriocm_debug(TX_EVENT, "slot == ack_slot");\r\nwhile (cm->tx_cnt && ((ack_slot != slot) ||\r\n(cm->tx_cnt == RIOCM_TX_RING_SIZE))) {\r\ncm->tx_buf[ack_slot] = NULL;\r\n++ack_slot;\r\nack_slot &= (RIOCM_TX_RING_SIZE - 1);\r\ncm->tx_cnt--;\r\n}\r\nif (cm->tx_cnt < 0 || cm->tx_cnt > RIOCM_TX_RING_SIZE)\r\nriocm_error("tx_cnt %d out of sync", cm->tx_cnt);\r\nWARN_ON((cm->tx_cnt < 0) || (cm->tx_cnt > RIOCM_TX_RING_SIZE));\r\ncm->tx_ack_slot = ack_slot;\r\nif (!list_empty(&cm->tx_reqs) && (cm->tx_cnt < RIOCM_TX_RING_SIZE)) {\r\nstruct tx_req *req, *_req;\r\nint rc;\r\nlist_for_each_entry_safe(req, _req, &cm->tx_reqs, node) {\r\nlist_del(&req->node);\r\ncm->tx_buf[cm->tx_slot] = req->buffer;\r\nrc = rio_add_outb_message(cm->mport, req->rdev, cmbox,\r\nreq->buffer, req->len);\r\nkfree(req->buffer);\r\nkfree(req);\r\n++cm->tx_cnt;\r\n++cm->tx_slot;\r\ncm->tx_slot &= (RIOCM_TX_RING_SIZE - 1);\r\nif (cm->tx_cnt == RIOCM_TX_RING_SIZE)\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&cm->tx_lock);\r\n}\r\nstatic void riocm_outb_msg_event(struct rio_mport *mport, void *dev_id,\r\nint mbox, int slot)\r\n{\r\nstruct cm_dev *cm = dev_id;\r\nif (cm && rio_mport_is_running(cm->mport))\r\nrio_txcq_handler(cm, slot);\r\n}\r\nstatic int riocm_queue_req(struct cm_dev *cm, struct rio_dev *rdev,\r\nvoid *buffer, size_t len)\r\n{\r\nunsigned long flags;\r\nstruct tx_req *treq;\r\ntreq = kzalloc(sizeof(*treq), GFP_KERNEL);\r\nif (treq == NULL)\r\nreturn -ENOMEM;\r\ntreq->rdev = rdev;\r\ntreq->buffer = buffer;\r\ntreq->len = len;\r\nspin_lock_irqsave(&cm->tx_lock, flags);\r\nlist_add_tail(&treq->node, &cm->tx_reqs);\r\nspin_unlock_irqrestore(&cm->tx_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int riocm_post_send(struct cm_dev *cm, struct rio_dev *rdev,\r\nvoid *buffer, size_t len)\r\n{\r\nint rc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cm->tx_lock, flags);\r\nif (cm->mport == NULL) {\r\nrc = -ENODEV;\r\ngoto err_out;\r\n}\r\nif (cm->tx_cnt == RIOCM_TX_RING_SIZE) {\r\nriocm_debug(TX, "Tx Queue is full");\r\nrc = -EBUSY;\r\ngoto err_out;\r\n}\r\ncm->tx_buf[cm->tx_slot] = buffer;\r\nrc = rio_add_outb_message(cm->mport, rdev, cmbox, buffer, len);\r\nriocm_debug(TX, "Add buf@%p destid=%x tx_slot=%d tx_cnt=%d",\r\nbuffer, rdev->destid, cm->tx_slot, cm->tx_cnt);\r\n++cm->tx_cnt;\r\n++cm->tx_slot;\r\ncm->tx_slot &= (RIOCM_TX_RING_SIZE - 1);\r\nerr_out:\r\nspin_unlock_irqrestore(&cm->tx_lock, flags);\r\nreturn rc;\r\n}\r\nstatic int riocm_ch_send(u16 ch_id, void *buf, int len)\r\n{\r\nstruct rio_channel *ch;\r\nstruct rio_ch_chan_hdr *hdr;\r\nint ret;\r\nif (buf == NULL || ch_id == 0 || len == 0 || len > RIO_MAX_MSG_SIZE)\r\nreturn -EINVAL;\r\nch = riocm_get_channel(ch_id);\r\nif (!ch) {\r\nriocm_error("%s(%d) ch_%d not found", current->comm,\r\ntask_pid_nr(current), ch_id);\r\nreturn -ENODEV;\r\n}\r\nif (!riocm_cmp(ch, RIO_CM_CONNECTED)) {\r\nret = -EAGAIN;\r\ngoto err_out;\r\n}\r\nhdr = buf;\r\nhdr->bhdr.src_id = htonl(ch->loc_destid);\r\nhdr->bhdr.dst_id = htonl(ch->rem_destid);\r\nhdr->bhdr.src_mbox = cmbox;\r\nhdr->bhdr.dst_mbox = cmbox;\r\nhdr->bhdr.type = RIO_CM_CHAN;\r\nhdr->ch_op = CM_DATA_MSG;\r\nhdr->dst_ch = htons(ch->rem_channel);\r\nhdr->src_ch = htons(ch->id);\r\nhdr->msg_len = htons((u16)len);\r\nret = riocm_post_send(ch->cmdev, ch->rdev, buf, len);\r\nif (ret)\r\nriocm_debug(TX, "ch %d send_err=%d", ch->id, ret);\r\nerr_out:\r\nriocm_put_channel(ch);\r\nreturn ret;\r\n}\r\nstatic int riocm_ch_free_rxbuf(struct rio_channel *ch, void *buf)\r\n{\r\nint i, ret = -EINVAL;\r\nspin_lock_bh(&ch->lock);\r\nfor (i = 0; i < RIOCM_RX_RING_SIZE; i++) {\r\nif (ch->rx_ring.inuse[i] == buf) {\r\nch->rx_ring.inuse[i] = NULL;\r\nch->rx_ring.inuse_cnt--;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&ch->lock);\r\nif (!ret)\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int riocm_ch_receive(struct rio_channel *ch, void **buf, long timeout)\r\n{\r\nvoid *rxmsg = NULL;\r\nint i, ret = 0;\r\nlong wret;\r\nif (!riocm_cmp(ch, RIO_CM_CONNECTED)) {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nif (ch->rx_ring.inuse_cnt == RIOCM_RX_RING_SIZE) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nwret = wait_for_completion_interruptible_timeout(&ch->comp, timeout);\r\nriocm_debug(WAIT, "wait on %d returned %ld", ch->id, wret);\r\nif (!wret)\r\nret = -ETIME;\r\nelse if (wret == -ERESTARTSYS)\r\nret = -EINTR;\r\nelse\r\nret = riocm_cmp(ch, RIO_CM_CONNECTED) ? 0 : -ECONNRESET;\r\nif (ret)\r\ngoto out;\r\nspin_lock_bh(&ch->lock);\r\nrxmsg = ch->rx_ring.buf[ch->rx_ring.tail];\r\nch->rx_ring.buf[ch->rx_ring.tail] = NULL;\r\nch->rx_ring.count--;\r\nch->rx_ring.tail++;\r\nch->rx_ring.tail %= RIOCM_RX_RING_SIZE;\r\nret = -ENOMEM;\r\nfor (i = 0; i < RIOCM_RX_RING_SIZE; i++) {\r\nif (ch->rx_ring.inuse[i] == NULL) {\r\nch->rx_ring.inuse[i] = rxmsg;\r\nch->rx_ring.inuse_cnt++;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nif (ret) {\r\nkfree(rxmsg);\r\nrxmsg = NULL;\r\n}\r\nspin_unlock_bh(&ch->lock);\r\nout:\r\n*buf = rxmsg;\r\nreturn ret;\r\n}\r\nstatic int riocm_ch_connect(u16 loc_ch, struct cm_dev *cm,\r\nstruct cm_peer *peer, u16 rem_ch)\r\n{\r\nstruct rio_channel *ch = NULL;\r\nstruct rio_ch_chan_hdr *hdr;\r\nint ret;\r\nlong wret;\r\nch = riocm_get_channel(loc_ch);\r\nif (!ch)\r\nreturn -ENODEV;\r\nif (!riocm_cmp_exch(ch, RIO_CM_IDLE, RIO_CM_CONNECT)) {\r\nret = -EINVAL;\r\ngoto conn_done;\r\n}\r\nch->cmdev = cm;\r\nch->rdev = peer->rdev;\r\nch->context = NULL;\r\nch->loc_destid = cm->mport->host_deviceid;\r\nch->rem_channel = rem_ch;\r\nhdr = kzalloc(sizeof(*hdr), GFP_KERNEL);\r\nif (hdr == NULL) {\r\nret = -ENOMEM;\r\ngoto conn_done;\r\n}\r\nhdr->bhdr.src_id = htonl(ch->loc_destid);\r\nhdr->bhdr.dst_id = htonl(peer->rdev->destid);\r\nhdr->bhdr.src_mbox = cmbox;\r\nhdr->bhdr.dst_mbox = cmbox;\r\nhdr->bhdr.type = RIO_CM_CHAN;\r\nhdr->ch_op = CM_CONN_REQ;\r\nhdr->dst_ch = htons(rem_ch);\r\nhdr->src_ch = htons(loc_ch);\r\nret = riocm_post_send(cm, peer->rdev, hdr, sizeof(*hdr));\r\nif (ret != -EBUSY) {\r\nkfree(hdr);\r\n} else {\r\nret = riocm_queue_req(cm, peer->rdev, hdr, sizeof(*hdr));\r\nif (ret)\r\nkfree(hdr);\r\n}\r\nif (ret) {\r\nriocm_cmp_exch(ch, RIO_CM_CONNECT, RIO_CM_IDLE);\r\ngoto conn_done;\r\n}\r\nwret = wait_for_completion_interruptible_timeout(&ch->comp,\r\nRIOCM_CONNECT_TO * HZ);\r\nriocm_debug(WAIT, "wait on %d returns %ld", ch->id, wret);\r\nif (!wret)\r\nret = -ETIME;\r\nelse if (wret == -ERESTARTSYS)\r\nret = -EINTR;\r\nelse\r\nret = riocm_cmp(ch, RIO_CM_CONNECTED) ? 0 : -1;\r\nconn_done:\r\nriocm_put_channel(ch);\r\nreturn ret;\r\n}\r\nstatic int riocm_send_ack(struct rio_channel *ch)\r\n{\r\nstruct rio_ch_chan_hdr *hdr;\r\nint ret;\r\nhdr = kzalloc(sizeof(*hdr), GFP_KERNEL);\r\nif (hdr == NULL)\r\nreturn -ENOMEM;\r\nhdr->bhdr.src_id = htonl(ch->loc_destid);\r\nhdr->bhdr.dst_id = htonl(ch->rem_destid);\r\nhdr->dst_ch = htons(ch->rem_channel);\r\nhdr->src_ch = htons(ch->id);\r\nhdr->bhdr.src_mbox = cmbox;\r\nhdr->bhdr.dst_mbox = cmbox;\r\nhdr->bhdr.type = RIO_CM_CHAN;\r\nhdr->ch_op = CM_CONN_ACK;\r\nret = riocm_post_send(ch->cmdev, ch->rdev, hdr, sizeof(*hdr));\r\nif (ret == -EBUSY && !riocm_queue_req(ch->cmdev,\r\nch->rdev, hdr, sizeof(*hdr)))\r\nreturn 0;\r\nkfree(hdr);\r\nif (ret)\r\nriocm_error("send ACK to ch_%d on %s failed (ret=%d)",\r\nch->id, rio_name(ch->rdev), ret);\r\nreturn ret;\r\n}\r\nstatic struct rio_channel *riocm_ch_accept(u16 ch_id, u16 *new_ch_id,\r\nlong timeout)\r\n{\r\nstruct rio_channel *ch;\r\nstruct rio_channel *new_ch;\r\nstruct conn_req *req;\r\nstruct cm_peer *peer;\r\nint found = 0;\r\nint err = 0;\r\nlong wret;\r\nch = riocm_get_channel(ch_id);\r\nif (!ch)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!riocm_cmp(ch, RIO_CM_LISTEN)) {\r\nerr = -EINVAL;\r\ngoto err_put;\r\n}\r\nif (!timeout) {\r\nif (!try_wait_for_completion(&ch->comp)) {\r\nerr = -EAGAIN;\r\ngoto err_put;\r\n}\r\n} else {\r\nriocm_debug(WAIT, "on %d", ch->id);\r\nwret = wait_for_completion_interruptible_timeout(&ch->comp,\r\ntimeout);\r\nif (!wret) {\r\nerr = -ETIME;\r\ngoto err_put;\r\n} else if (wret == -ERESTARTSYS) {\r\nerr = -EINTR;\r\ngoto err_put;\r\n}\r\n}\r\nspin_lock_bh(&ch->lock);\r\nif (ch->state != RIO_CM_LISTEN) {\r\nerr = -ECANCELED;\r\n} else if (list_empty(&ch->accept_queue)) {\r\nriocm_debug(WAIT, "on %d accept_queue is empty on completion",\r\nch->id);\r\nerr = -EIO;\r\n}\r\nspin_unlock_bh(&ch->lock);\r\nif (err) {\r\nriocm_debug(WAIT, "on %d returns %d", ch->id, err);\r\ngoto err_put;\r\n}\r\nnew_ch = riocm_ch_alloc(RIOCM_CHNUM_AUTO);\r\nif (IS_ERR(new_ch)) {\r\nriocm_error("failed to get channel for new req (%ld)",\r\nPTR_ERR(new_ch));\r\nerr = -ENOMEM;\r\ngoto err_put;\r\n}\r\nspin_lock_bh(&ch->lock);\r\nreq = list_first_entry(&ch->accept_queue, struct conn_req, node);\r\nlist_del(&req->node);\r\nnew_ch->cmdev = ch->cmdev;\r\nnew_ch->loc_destid = ch->loc_destid;\r\nnew_ch->rem_destid = req->destid;\r\nnew_ch->rem_channel = req->chan;\r\nspin_unlock_bh(&ch->lock);\r\nriocm_put_channel(ch);\r\nch = NULL;\r\nkfree(req);\r\ndown_read(&rdev_sem);\r\nlist_for_each_entry(peer, &new_ch->cmdev->peers, node) {\r\nif (peer->rdev->destid == new_ch->rem_destid) {\r\nriocm_debug(RX_CMD, "found matching device(%s)",\r\nrio_name(peer->rdev));\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nup_read(&rdev_sem);\r\nif (!found) {\r\nerr = -ENODEV;\r\ngoto err_put_new_ch;\r\n}\r\nnew_ch->rdev = peer->rdev;\r\nnew_ch->state = RIO_CM_CONNECTED;\r\nspin_lock_init(&new_ch->lock);\r\nriocm_send_ack(new_ch);\r\n*new_ch_id = new_ch->id;\r\nreturn new_ch;\r\nerr_put_new_ch:\r\nspin_lock_bh(&idr_lock);\r\nidr_remove(&ch_idr, new_ch->id);\r\nspin_unlock_bh(&idr_lock);\r\nriocm_put_channel(new_ch);\r\nerr_put:\r\nif (ch)\r\nriocm_put_channel(ch);\r\n*new_ch_id = 0;\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int riocm_ch_listen(u16 ch_id)\r\n{\r\nstruct rio_channel *ch = NULL;\r\nint ret = 0;\r\nriocm_debug(CHOP, "(ch_%d)", ch_id);\r\nch = riocm_get_channel(ch_id);\r\nif (!ch || !riocm_cmp_exch(ch, RIO_CM_CHAN_BOUND, RIO_CM_LISTEN))\r\nret = -EINVAL;\r\nriocm_put_channel(ch);\r\nreturn ret;\r\n}\r\nstatic int riocm_ch_bind(u16 ch_id, u8 mport_id, void *context)\r\n{\r\nstruct rio_channel *ch = NULL;\r\nstruct cm_dev *cm;\r\nint rc = -ENODEV;\r\nriocm_debug(CHOP, "ch_%d to mport_%d", ch_id, mport_id);\r\ndown_read(&rdev_sem);\r\nlist_for_each_entry(cm, &cm_dev_list, list) {\r\nif ((cm->mport->id == mport_id) &&\r\nrio_mport_is_running(cm->mport)) {\r\nrc = 0;\r\nbreak;\r\n}\r\n}\r\nif (rc)\r\ngoto exit;\r\nch = riocm_get_channel(ch_id);\r\nif (!ch) {\r\nrc = -EINVAL;\r\ngoto exit;\r\n}\r\nspin_lock_bh(&ch->lock);\r\nif (ch->state != RIO_CM_IDLE) {\r\nspin_unlock_bh(&ch->lock);\r\nrc = -EINVAL;\r\ngoto err_put;\r\n}\r\nch->cmdev = cm;\r\nch->loc_destid = cm->mport->host_deviceid;\r\nch->context = context;\r\nch->state = RIO_CM_CHAN_BOUND;\r\nspin_unlock_bh(&ch->lock);\r\nerr_put:\r\nriocm_put_channel(ch);\r\nexit:\r\nup_read(&rdev_sem);\r\nreturn rc;\r\n}\r\nstatic struct rio_channel *riocm_ch_alloc(u16 ch_num)\r\n{\r\nint id;\r\nint start, end;\r\nstruct rio_channel *ch;\r\nch = kzalloc(sizeof(*ch), GFP_KERNEL);\r\nif (!ch)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (ch_num) {\r\nstart = ch_num;\r\nend = ch_num + 1;\r\n} else {\r\nstart = chstart;\r\nend = RIOCM_MAX_CHNUM + 1;\r\n}\r\nidr_preload(GFP_KERNEL);\r\nspin_lock_bh(&idr_lock);\r\nid = idr_alloc_cyclic(&ch_idr, ch, start, end, GFP_NOWAIT);\r\nspin_unlock_bh(&idr_lock);\r\nidr_preload_end();\r\nif (id < 0) {\r\nkfree(ch);\r\nreturn ERR_PTR(id == -ENOSPC ? -EBUSY : id);\r\n}\r\nch->id = (u16)id;\r\nch->state = RIO_CM_IDLE;\r\nspin_lock_init(&ch->lock);\r\nINIT_LIST_HEAD(&ch->accept_queue);\r\nINIT_LIST_HEAD(&ch->ch_node);\r\ninit_completion(&ch->comp);\r\ninit_completion(&ch->comp_close);\r\nkref_init(&ch->ref);\r\nch->rx_ring.head = 0;\r\nch->rx_ring.tail = 0;\r\nch->rx_ring.count = 0;\r\nch->rx_ring.inuse_cnt = 0;\r\nreturn ch;\r\n}\r\nstatic struct rio_channel *riocm_ch_create(u16 *ch_num)\r\n{\r\nstruct rio_channel *ch = NULL;\r\nch = riocm_ch_alloc(*ch_num);\r\nif (IS_ERR(ch))\r\nriocm_debug(CHOP, "Failed to allocate channel %d (err=%ld)",\r\n*ch_num, PTR_ERR(ch));\r\nelse\r\n*ch_num = ch->id;\r\nreturn ch;\r\n}\r\nstatic void riocm_ch_free(struct kref *ref)\r\n{\r\nstruct rio_channel *ch = container_of(ref, struct rio_channel, ref);\r\nint i;\r\nriocm_debug(CHOP, "(ch_%d)", ch->id);\r\nif (ch->rx_ring.inuse_cnt) {\r\nfor (i = 0;\r\ni < RIOCM_RX_RING_SIZE && ch->rx_ring.inuse_cnt; i++) {\r\nif (ch->rx_ring.inuse[i] != NULL) {\r\nkfree(ch->rx_ring.inuse[i]);\r\nch->rx_ring.inuse_cnt--;\r\n}\r\n}\r\n}\r\nif (ch->rx_ring.count)\r\nfor (i = 0; i < RIOCM_RX_RING_SIZE && ch->rx_ring.count; i++) {\r\nif (ch->rx_ring.buf[i] != NULL) {\r\nkfree(ch->rx_ring.buf[i]);\r\nch->rx_ring.count--;\r\n}\r\n}\r\ncomplete(&ch->comp_close);\r\n}\r\nstatic int riocm_send_close(struct rio_channel *ch)\r\n{\r\nstruct rio_ch_chan_hdr *hdr;\r\nint ret;\r\nhdr = kzalloc(sizeof(*hdr), GFP_KERNEL);\r\nif (hdr == NULL)\r\nreturn -ENOMEM;\r\nhdr->bhdr.src_id = htonl(ch->loc_destid);\r\nhdr->bhdr.dst_id = htonl(ch->rem_destid);\r\nhdr->bhdr.src_mbox = cmbox;\r\nhdr->bhdr.dst_mbox = cmbox;\r\nhdr->bhdr.type = RIO_CM_CHAN;\r\nhdr->ch_op = CM_CONN_CLOSE;\r\nhdr->dst_ch = htons(ch->rem_channel);\r\nhdr->src_ch = htons(ch->id);\r\nret = riocm_post_send(ch->cmdev, ch->rdev, hdr, sizeof(*hdr));\r\nif (ret == -EBUSY && !riocm_queue_req(ch->cmdev, ch->rdev,\r\nhdr, sizeof(*hdr)))\r\nreturn 0;\r\nkfree(hdr);\r\nif (ret)\r\nriocm_error("ch(%d) send CLOSE failed (ret=%d)", ch->id, ret);\r\nreturn ret;\r\n}\r\nstatic int riocm_ch_close(struct rio_channel *ch)\r\n{\r\nunsigned long tmo = msecs_to_jiffies(3000);\r\nenum rio_cm_state state;\r\nlong wret;\r\nint ret = 0;\r\nriocm_debug(CHOP, "ch_%d by %s(%d)",\r\nch->id, current->comm, task_pid_nr(current));\r\nstate = riocm_exch(ch, RIO_CM_DESTROYING);\r\nif (state == RIO_CM_CONNECTED)\r\nriocm_send_close(ch);\r\ncomplete_all(&ch->comp);\r\nriocm_put_channel(ch);\r\nwret = wait_for_completion_interruptible_timeout(&ch->comp_close, tmo);\r\nriocm_debug(WAIT, "wait on %d returns %ld", ch->id, wret);\r\nif (wret == 0) {\r\nriocm_debug(CHOP, "%s(%d) timed out waiting for ch %d",\r\ncurrent->comm, task_pid_nr(current), ch->id);\r\nret = -ETIMEDOUT;\r\n} else if (wret == -ERESTARTSYS) {\r\nriocm_debug(CHOP, "%s(%d) wait for ch %d was interrupted",\r\ncurrent->comm, task_pid_nr(current), ch->id);\r\nret = -EINTR;\r\n}\r\nif (!ret) {\r\nriocm_debug(CHOP, "ch_%d resources released", ch->id);\r\nkfree(ch);\r\n} else {\r\nriocm_debug(CHOP, "failed to release ch_%d resources", ch->id);\r\n}\r\nreturn ret;\r\n}\r\nstatic int riocm_cdev_open(struct inode *inode, struct file *filp)\r\n{\r\nriocm_debug(INIT, "by %s(%d) filp=%p ",\r\ncurrent->comm, task_pid_nr(current), filp);\r\nif (list_empty(&cm_dev_list))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int riocm_cdev_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct rio_channel *ch, *_c;\r\nunsigned int i;\r\nLIST_HEAD(list);\r\nriocm_debug(EXIT, "by %s(%d) filp=%p",\r\ncurrent->comm, task_pid_nr(current), filp);\r\nspin_lock_bh(&idr_lock);\r\nidr_for_each_entry(&ch_idr, ch, i) {\r\nif (ch && ch->filp == filp) {\r\nriocm_debug(EXIT, "ch_%d not released by %s(%d)",\r\nch->id, current->comm,\r\ntask_pid_nr(current));\r\nidr_remove(&ch_idr, ch->id);\r\nlist_add(&ch->ch_node, &list);\r\n}\r\n}\r\nspin_unlock_bh(&idr_lock);\r\nif (!list_empty(&list)) {\r\nlist_for_each_entry_safe(ch, _c, &list, ch_node) {\r\nlist_del(&ch->ch_node);\r\nriocm_ch_close(ch);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cm_ep_get_list_size(void __user *arg)\r\n{\r\nu32 __user *p = arg;\r\nu32 mport_id;\r\nu32 count = 0;\r\nstruct cm_dev *cm;\r\nif (get_user(mport_id, p))\r\nreturn -EFAULT;\r\nif (mport_id >= RIO_MAX_MPORTS)\r\nreturn -EINVAL;\r\ndown_read(&rdev_sem);\r\nlist_for_each_entry(cm, &cm_dev_list, list) {\r\nif (cm->mport->id == mport_id) {\r\ncount = cm->npeers;\r\nup_read(&rdev_sem);\r\nif (copy_to_user(arg, &count, sizeof(u32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\n}\r\nup_read(&rdev_sem);\r\nreturn -ENODEV;\r\n}\r\nstatic int cm_ep_get_list(void __user *arg)\r\n{\r\nstruct cm_dev *cm;\r\nstruct cm_peer *peer;\r\nu32 info[2];\r\nvoid *buf;\r\nu32 nent;\r\nu32 *entry_ptr;\r\nu32 i = 0;\r\nint ret = 0;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\nif (info[1] >= RIO_MAX_MPORTS || info[0] > RIOCM_MAX_EP_COUNT)\r\nreturn -EINVAL;\r\ndown_read(&rdev_sem);\r\nlist_for_each_entry(cm, &cm_dev_list, list)\r\nif (cm->mport->id == (u8)info[1])\r\ngoto found;\r\nup_read(&rdev_sem);\r\nreturn -ENODEV;\r\nfound:\r\nnent = min(info[0], cm->npeers);\r\nbuf = kcalloc(nent + 2, sizeof(u32), GFP_KERNEL);\r\nif (!buf) {\r\nup_read(&rdev_sem);\r\nreturn -ENOMEM;\r\n}\r\nentry_ptr = (u32 *)((uintptr_t)buf + 2*sizeof(u32));\r\nlist_for_each_entry(peer, &cm->peers, node) {\r\n*entry_ptr = (u32)peer->rdev->destid;\r\nentry_ptr++;\r\nif (++i == nent)\r\nbreak;\r\n}\r\nup_read(&rdev_sem);\r\n((u32 *)buf)[0] = i;\r\n((u32 *)buf)[1] = info[1];\r\nif (copy_to_user(arg, buf, sizeof(u32) * (info[0] + 2)))\r\nret = -EFAULT;\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int cm_mport_get_list(void __user *arg)\r\n{\r\nint ret = 0;\r\nu32 entries;\r\nvoid *buf;\r\nstruct cm_dev *cm;\r\nu32 *entry_ptr;\r\nint count = 0;\r\nif (copy_from_user(&entries, arg, sizeof(entries)))\r\nreturn -EFAULT;\r\nif (entries == 0 || entries > RIO_MAX_MPORTS)\r\nreturn -EINVAL;\r\nbuf = kcalloc(entries + 1, sizeof(u32), GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nentry_ptr = (u32 *)((uintptr_t)buf + sizeof(u32));\r\ndown_read(&rdev_sem);\r\nlist_for_each_entry(cm, &cm_dev_list, list) {\r\nif (count++ < entries) {\r\n*entry_ptr = (cm->mport->id << 16) |\r\ncm->mport->host_deviceid;\r\nentry_ptr++;\r\n}\r\n}\r\nup_read(&rdev_sem);\r\n*((u32 *)buf) = count;\r\nif (copy_to_user(arg, buf, sizeof(u32) * (count + 1)))\r\nret = -EFAULT;\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int cm_chan_create(struct file *filp, void __user *arg)\r\n{\r\nu16 __user *p = arg;\r\nu16 ch_num;\r\nstruct rio_channel *ch;\r\nif (get_user(ch_num, p))\r\nreturn -EFAULT;\r\nriocm_debug(CHOP, "ch_%d requested by %s(%d)",\r\nch_num, current->comm, task_pid_nr(current));\r\nch = riocm_ch_create(&ch_num);\r\nif (IS_ERR(ch))\r\nreturn PTR_ERR(ch);\r\nch->filp = filp;\r\nriocm_debug(CHOP, "ch_%d created by %s(%d)",\r\nch_num, current->comm, task_pid_nr(current));\r\nreturn put_user(ch_num, p);\r\n}\r\nstatic int cm_chan_close(struct file *filp, void __user *arg)\r\n{\r\nu16 __user *p = arg;\r\nu16 ch_num;\r\nstruct rio_channel *ch;\r\nif (get_user(ch_num, p))\r\nreturn -EFAULT;\r\nriocm_debug(CHOP, "ch_%d by %s(%d)",\r\nch_num, current->comm, task_pid_nr(current));\r\nspin_lock_bh(&idr_lock);\r\nch = idr_find(&ch_idr, ch_num);\r\nif (!ch) {\r\nspin_unlock_bh(&idr_lock);\r\nreturn 0;\r\n}\r\nif (ch->filp != filp) {\r\nspin_unlock_bh(&idr_lock);\r\nreturn -EINVAL;\r\n}\r\nidr_remove(&ch_idr, ch->id);\r\nspin_unlock_bh(&idr_lock);\r\nreturn riocm_ch_close(ch);\r\n}\r\nstatic int cm_chan_bind(void __user *arg)\r\n{\r\nstruct rio_cm_channel chan;\r\nif (copy_from_user(&chan, arg, sizeof(chan)))\r\nreturn -EFAULT;\r\nif (chan.mport_id >= RIO_MAX_MPORTS)\r\nreturn -EINVAL;\r\nreturn riocm_ch_bind(chan.id, chan.mport_id, NULL);\r\n}\r\nstatic int cm_chan_listen(void __user *arg)\r\n{\r\nu16 __user *p = arg;\r\nu16 ch_num;\r\nif (get_user(ch_num, p))\r\nreturn -EFAULT;\r\nreturn riocm_ch_listen(ch_num);\r\n}\r\nstatic int cm_chan_accept(struct file *filp, void __user *arg)\r\n{\r\nstruct rio_cm_accept param;\r\nlong accept_to;\r\nstruct rio_channel *ch;\r\nif (copy_from_user(&param, arg, sizeof(param)))\r\nreturn -EFAULT;\r\nriocm_debug(CHOP, "on ch_%d by %s(%d)",\r\nparam.ch_num, current->comm, task_pid_nr(current));\r\naccept_to = param.wait_to ?\r\nmsecs_to_jiffies(param.wait_to) : 0;\r\nch = riocm_ch_accept(param.ch_num, &param.ch_num, accept_to);\r\nif (IS_ERR(ch))\r\nreturn PTR_ERR(ch);\r\nch->filp = filp;\r\nriocm_debug(CHOP, "new ch_%d for %s(%d)",\r\nch->id, current->comm, task_pid_nr(current));\r\nif (copy_to_user(arg, &param, sizeof(param)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int cm_chan_connect(void __user *arg)\r\n{\r\nstruct rio_cm_channel chan;\r\nstruct cm_dev *cm;\r\nstruct cm_peer *peer;\r\nint ret = -ENODEV;\r\nif (copy_from_user(&chan, arg, sizeof(chan)))\r\nreturn -EFAULT;\r\nif (chan.mport_id >= RIO_MAX_MPORTS)\r\nreturn -EINVAL;\r\ndown_read(&rdev_sem);\r\nlist_for_each_entry(cm, &cm_dev_list, list) {\r\nif (cm->mport->id == chan.mport_id) {\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nif (ret)\r\ngoto err_out;\r\nif (chan.remote_destid >= RIO_ANY_DESTID(cm->mport->sys_size)) {\r\nret = -EINVAL;\r\ngoto err_out;\r\n}\r\nret = -ENODEV;\r\nlist_for_each_entry(peer, &cm->peers, node) {\r\nif (peer->rdev->destid == chan.remote_destid) {\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nif (ret)\r\ngoto err_out;\r\nup_read(&rdev_sem);\r\nreturn riocm_ch_connect(chan.id, cm, peer, chan.remote_channel);\r\nerr_out:\r\nup_read(&rdev_sem);\r\nreturn ret;\r\n}\r\nstatic int cm_chan_msg_send(void __user *arg)\r\n{\r\nstruct rio_cm_msg msg;\r\nvoid *buf;\r\nint ret;\r\nif (copy_from_user(&msg, arg, sizeof(msg)))\r\nreturn -EFAULT;\r\nif (msg.size > RIO_MAX_MSG_SIZE)\r\nreturn -EINVAL;\r\nbuf = memdup_user((void __user *)(uintptr_t)msg.msg, msg.size);\r\nif (IS_ERR(buf))\r\nreturn PTR_ERR(buf);\r\nret = riocm_ch_send(msg.ch_num, buf, msg.size);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int cm_chan_msg_rcv(void __user *arg)\r\n{\r\nstruct rio_cm_msg msg;\r\nstruct rio_channel *ch;\r\nvoid *buf;\r\nlong rxto;\r\nint ret = 0, msg_size;\r\nif (copy_from_user(&msg, arg, sizeof(msg)))\r\nreturn -EFAULT;\r\nif (msg.ch_num == 0 || msg.size == 0)\r\nreturn -EINVAL;\r\nch = riocm_get_channel(msg.ch_num);\r\nif (!ch)\r\nreturn -ENODEV;\r\nrxto = msg.rxto ? msecs_to_jiffies(msg.rxto) : MAX_SCHEDULE_TIMEOUT;\r\nret = riocm_ch_receive(ch, &buf, rxto);\r\nif (ret)\r\ngoto out;\r\nmsg_size = min(msg.size, (u16)(RIO_MAX_MSG_SIZE));\r\nif (copy_to_user((void __user *)(uintptr_t)msg.msg, buf, msg_size))\r\nret = -EFAULT;\r\nriocm_ch_free_rxbuf(ch, buf);\r\nout:\r\nriocm_put_channel(ch);\r\nreturn ret;\r\n}\r\nstatic long\r\nriocm_cdev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase RIO_CM_EP_GET_LIST_SIZE:\r\nreturn cm_ep_get_list_size((void __user *)arg);\r\ncase RIO_CM_EP_GET_LIST:\r\nreturn cm_ep_get_list((void __user *)arg);\r\ncase RIO_CM_CHAN_CREATE:\r\nreturn cm_chan_create(filp, (void __user *)arg);\r\ncase RIO_CM_CHAN_CLOSE:\r\nreturn cm_chan_close(filp, (void __user *)arg);\r\ncase RIO_CM_CHAN_BIND:\r\nreturn cm_chan_bind((void __user *)arg);\r\ncase RIO_CM_CHAN_LISTEN:\r\nreturn cm_chan_listen((void __user *)arg);\r\ncase RIO_CM_CHAN_ACCEPT:\r\nreturn cm_chan_accept(filp, (void __user *)arg);\r\ncase RIO_CM_CHAN_CONNECT:\r\nreturn cm_chan_connect((void __user *)arg);\r\ncase RIO_CM_CHAN_SEND:\r\nreturn cm_chan_msg_send((void __user *)arg);\r\ncase RIO_CM_CHAN_RECEIVE:\r\nreturn cm_chan_msg_rcv((void __user *)arg);\r\ncase RIO_CM_MPORT_GET_LIST:\r\nreturn cm_mport_get_list((void __user *)arg);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int riocm_add_dev(struct device *dev, struct subsys_interface *sif)\r\n{\r\nstruct cm_peer *peer;\r\nstruct rio_dev *rdev = to_rio_dev(dev);\r\nstruct cm_dev *cm;\r\nif (!dev_cm_capable(rdev))\r\nreturn 0;\r\nriocm_debug(RDEV, "(%s)", rio_name(rdev));\r\npeer = kmalloc(sizeof(*peer), GFP_KERNEL);\r\nif (!peer)\r\nreturn -ENOMEM;\r\ndown_write(&rdev_sem);\r\nlist_for_each_entry(cm, &cm_dev_list, list) {\r\nif (cm->mport == rdev->net->hport)\r\ngoto found;\r\n}\r\nup_write(&rdev_sem);\r\nkfree(peer);\r\nreturn -ENODEV;\r\nfound:\r\npeer->rdev = rdev;\r\nlist_add_tail(&peer->node, &cm->peers);\r\ncm->npeers++;\r\nup_write(&rdev_sem);\r\nreturn 0;\r\n}\r\nstatic void riocm_remove_dev(struct device *dev, struct subsys_interface *sif)\r\n{\r\nstruct rio_dev *rdev = to_rio_dev(dev);\r\nstruct cm_dev *cm;\r\nstruct cm_peer *peer;\r\nstruct rio_channel *ch, *_c;\r\nunsigned int i;\r\nbool found = false;\r\nLIST_HEAD(list);\r\nif (!dev_cm_capable(rdev))\r\nreturn;\r\nriocm_debug(RDEV, "(%s)", rio_name(rdev));\r\ndown_write(&rdev_sem);\r\nlist_for_each_entry(cm, &cm_dev_list, list) {\r\nif (cm->mport == rdev->net->hport) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nup_write(&rdev_sem);\r\nreturn;\r\n}\r\nfound = false;\r\nlist_for_each_entry(peer, &cm->peers, node) {\r\nif (peer->rdev == rdev) {\r\nriocm_debug(RDEV, "removing peer %s", rio_name(rdev));\r\nfound = true;\r\nlist_del(&peer->node);\r\ncm->npeers--;\r\nkfree(peer);\r\nbreak;\r\n}\r\n}\r\nup_write(&rdev_sem);\r\nif (!found)\r\nreturn;\r\nspin_lock_bh(&idr_lock);\r\nidr_for_each_entry(&ch_idr, ch, i) {\r\nif (ch && ch->rdev == rdev) {\r\nif (atomic_read(&rdev->state) != RIO_DEVICE_SHUTDOWN)\r\nriocm_exch(ch, RIO_CM_DISCONNECT);\r\nidr_remove(&ch_idr, ch->id);\r\nlist_add(&ch->ch_node, &list);\r\n}\r\n}\r\nspin_unlock_bh(&idr_lock);\r\nif (!list_empty(&list)) {\r\nlist_for_each_entry_safe(ch, _c, &list, ch_node) {\r\nlist_del(&ch->ch_node);\r\nriocm_ch_close(ch);\r\n}\r\n}\r\n}\r\nstatic int riocm_cdev_add(dev_t devno)\r\n{\r\nint ret;\r\ncdev_init(&riocm_cdev.cdev, &riocm_cdev_fops);\r\nriocm_cdev.cdev.owner = THIS_MODULE;\r\nret = cdev_add(&riocm_cdev.cdev, devno, 1);\r\nif (ret < 0) {\r\nriocm_error("Cannot register a device with error %d", ret);\r\nreturn ret;\r\n}\r\nriocm_cdev.dev = device_create(dev_class, NULL, devno, NULL, DEV_NAME);\r\nif (IS_ERR(riocm_cdev.dev)) {\r\ncdev_del(&riocm_cdev.cdev);\r\nreturn PTR_ERR(riocm_cdev.dev);\r\n}\r\nriocm_debug(MPORT, "Added %s cdev(%d:%d)",\r\nDEV_NAME, MAJOR(devno), MINOR(devno));\r\nreturn 0;\r\n}\r\nstatic int riocm_add_mport(struct device *dev,\r\nstruct class_interface *class_intf)\r\n{\r\nint rc;\r\nint i;\r\nstruct cm_dev *cm;\r\nstruct rio_mport *mport = to_rio_mport(dev);\r\nriocm_debug(MPORT, "add mport %s", mport->name);\r\ncm = kzalloc(sizeof(*cm), GFP_KERNEL);\r\nif (!cm)\r\nreturn -ENOMEM;\r\ncm->mport = mport;\r\nrc = rio_request_outb_mbox(mport, cm, cmbox,\r\nRIOCM_TX_RING_SIZE, riocm_outb_msg_event);\r\nif (rc) {\r\nriocm_error("failed to allocate OBMBOX_%d on %s",\r\ncmbox, mport->name);\r\nkfree(cm);\r\nreturn -ENODEV;\r\n}\r\nrc = rio_request_inb_mbox(mport, cm, cmbox,\r\nRIOCM_RX_RING_SIZE, riocm_inb_msg_event);\r\nif (rc) {\r\nriocm_error("failed to allocate IBMBOX_%d on %s",\r\ncmbox, mport->name);\r\nrio_release_outb_mbox(mport, cmbox);\r\nkfree(cm);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < RIOCM_RX_RING_SIZE; i++)\r\ncm->rx_buf[i] = NULL;\r\ncm->rx_slots = RIOCM_RX_RING_SIZE;\r\nmutex_init(&cm->rx_lock);\r\nriocm_rx_fill(cm, RIOCM_RX_RING_SIZE);\r\ncm->rx_wq = create_workqueue(DRV_NAME "/rxq");\r\nINIT_WORK(&cm->rx_work, rio_ibmsg_handler);\r\ncm->tx_slot = 0;\r\ncm->tx_cnt = 0;\r\ncm->tx_ack_slot = 0;\r\nspin_lock_init(&cm->tx_lock);\r\nINIT_LIST_HEAD(&cm->peers);\r\ncm->npeers = 0;\r\nINIT_LIST_HEAD(&cm->tx_reqs);\r\ndown_write(&rdev_sem);\r\nlist_add_tail(&cm->list, &cm_dev_list);\r\nup_write(&rdev_sem);\r\nreturn 0;\r\n}\r\nstatic void riocm_remove_mport(struct device *dev,\r\nstruct class_interface *class_intf)\r\n{\r\nstruct rio_mport *mport = to_rio_mport(dev);\r\nstruct cm_dev *cm;\r\nstruct cm_peer *peer, *temp;\r\nstruct rio_channel *ch, *_c;\r\nunsigned int i;\r\nbool found = false;\r\nLIST_HEAD(list);\r\nriocm_debug(MPORT, "%s", mport->name);\r\ndown_write(&rdev_sem);\r\nlist_for_each_entry(cm, &cm_dev_list, list) {\r\nif (cm->mport == mport) {\r\nlist_del(&cm->list);\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nup_write(&rdev_sem);\r\nif (!found)\r\nreturn;\r\nflush_workqueue(cm->rx_wq);\r\ndestroy_workqueue(cm->rx_wq);\r\nspin_lock_bh(&idr_lock);\r\nidr_for_each_entry(&ch_idr, ch, i) {\r\nif (ch->cmdev == cm) {\r\nriocm_debug(RDEV, "%s drop ch_%d",\r\nmport->name, ch->id);\r\nidr_remove(&ch_idr, ch->id);\r\nlist_add(&ch->ch_node, &list);\r\n}\r\n}\r\nspin_unlock_bh(&idr_lock);\r\nif (!list_empty(&list)) {\r\nlist_for_each_entry_safe(ch, _c, &list, ch_node) {\r\nlist_del(&ch->ch_node);\r\nriocm_ch_close(ch);\r\n}\r\n}\r\nrio_release_inb_mbox(mport, cmbox);\r\nrio_release_outb_mbox(mport, cmbox);\r\nif (!list_empty(&cm->peers))\r\nriocm_debug(RDEV, "ATTN: peer list not empty");\r\nlist_for_each_entry_safe(peer, temp, &cm->peers, node) {\r\nriocm_debug(RDEV, "removing peer %s", rio_name(peer->rdev));\r\nlist_del(&peer->node);\r\nkfree(peer);\r\n}\r\nriocm_rx_free(cm);\r\nkfree(cm);\r\nriocm_debug(MPORT, "%s done", mport->name);\r\n}\r\nstatic int rio_cm_shutdown(struct notifier_block *nb, unsigned long code,\r\nvoid *unused)\r\n{\r\nstruct rio_channel *ch;\r\nunsigned int i;\r\nLIST_HEAD(list);\r\nriocm_debug(EXIT, ".");\r\nspin_lock_bh(&idr_lock);\r\nidr_for_each_entry(&ch_idr, ch, i) {\r\nif (ch->state == RIO_CM_CONNECTED) {\r\nriocm_debug(EXIT, "close ch %d", ch->id);\r\nidr_remove(&ch_idr, ch->id);\r\nlist_add(&ch->ch_node, &list);\r\n}\r\n}\r\nspin_unlock_bh(&idr_lock);\r\nlist_for_each_entry(ch, &list, ch_node)\r\nriocm_send_close(ch);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init riocm_init(void)\r\n{\r\nint ret;\r\ndev_class = class_create(THIS_MODULE, DRV_NAME);\r\nif (IS_ERR(dev_class)) {\r\nriocm_error("Cannot create " DRV_NAME " class");\r\nreturn PTR_ERR(dev_class);\r\n}\r\nret = alloc_chrdev_region(&dev_number, 0, 1, DRV_NAME);\r\nif (ret) {\r\nclass_destroy(dev_class);\r\nreturn ret;\r\n}\r\ndev_major = MAJOR(dev_number);\r\ndev_minor_base = MINOR(dev_number);\r\nriocm_debug(INIT, "Registered class with %d major", dev_major);\r\nret = class_interface_register(&rio_mport_interface);\r\nif (ret) {\r\nriocm_error("class_interface_register error: %d", ret);\r\ngoto err_reg;\r\n}\r\nret = subsys_interface_register(&riocm_interface);\r\nif (ret) {\r\nriocm_error("subsys_interface_register error: %d", ret);\r\ngoto err_cl;\r\n}\r\nret = register_reboot_notifier(&rio_cm_notifier);\r\nif (ret) {\r\nriocm_error("failed to register reboot notifier (err=%d)", ret);\r\ngoto err_sif;\r\n}\r\nret = riocm_cdev_add(dev_number);\r\nif (ret) {\r\nunregister_reboot_notifier(&rio_cm_notifier);\r\nret = -ENODEV;\r\ngoto err_sif;\r\n}\r\nreturn 0;\r\nerr_sif:\r\nsubsys_interface_unregister(&riocm_interface);\r\nerr_cl:\r\nclass_interface_unregister(&rio_mport_interface);\r\nerr_reg:\r\nunregister_chrdev_region(dev_number, 1);\r\nclass_destroy(dev_class);\r\nreturn ret;\r\n}\r\nstatic void __exit riocm_exit(void)\r\n{\r\nriocm_debug(EXIT, "enter");\r\nunregister_reboot_notifier(&rio_cm_notifier);\r\nsubsys_interface_unregister(&riocm_interface);\r\nclass_interface_unregister(&rio_mport_interface);\r\nidr_destroy(&ch_idr);\r\ndevice_unregister(riocm_cdev.dev);\r\ncdev_del(&(riocm_cdev.cdev));\r\nclass_destroy(dev_class);\r\nunregister_chrdev_region(dev_number, 1);\r\n}
