static int bu21013_read_block_data(struct bu21013_ts_data *data, u8 *buf)\r\n{\r\nint ret, i;\r\nfor (i = 0; i < I2C_RETRY_COUNT; i++) {\r\nret = i2c_smbus_read_i2c_block_data\r\n(data->client, BU21013_SENSORS_BTN_0_7_REG,\r\nLENGTH_OF_BUFFER, buf);\r\nif (ret == LENGTH_OF_BUFFER)\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int bu21013_do_touch_report(struct bu21013_ts_data *data)\r\n{\r\nu8 buf[LENGTH_OF_BUFFER];\r\nunsigned int pos_x[2], pos_y[2];\r\nbool has_x_sensors, has_y_sensors;\r\nint finger_down_count = 0;\r\nint i;\r\nif (data == NULL)\r\nreturn -EINVAL;\r\nif (bu21013_read_block_data(data, buf) < 0)\r\nreturn -EINVAL;\r\nhas_x_sensors = hweight32(buf[0] & BU21013_SENSORS_EN_0_7);\r\nhas_y_sensors = hweight32(((buf[1] & BU21013_SENSORS_EN_8_15) |\r\n((buf[2] & BU21013_SENSORS_EN_16_23) << SHIFT_8)) >> SHIFT_2);\r\nif (!has_x_sensors || !has_y_sensors)\r\nreturn 0;\r\nfor (i = 0; i < MAX_FINGERS; i++) {\r\nconst u8 *p = &buf[4 * i + 3];\r\nunsigned int x = p[0] << SHIFT_2 | (p[1] & MASK_BITS);\r\nunsigned int y = p[2] << SHIFT_2 | (p[3] & MASK_BITS);\r\nif (x == 0 || y == 0)\r\ncontinue;\r\npos_x[finger_down_count] = x;\r\npos_y[finger_down_count] = y;\r\nfinger_down_count++;\r\n}\r\nif (finger_down_count) {\r\nif (finger_down_count == 2 &&\r\n(abs(pos_x[0] - pos_x[1]) < DELTA_MIN ||\r\nabs(pos_y[0] - pos_y[1]) < DELTA_MIN)) {\r\nreturn 0;\r\n}\r\nfor (i = 0; i < finger_down_count; i++) {\r\nif (data->chip->x_flip)\r\npos_x[i] = data->chip->touch_x_max - pos_x[i];\r\nif (data->chip->y_flip)\r\npos_y[i] = data->chip->touch_y_max - pos_y[i];\r\ninput_report_abs(data->in_dev,\r\nABS_MT_POSITION_X, pos_x[i]);\r\ninput_report_abs(data->in_dev,\r\nABS_MT_POSITION_Y, pos_y[i]);\r\ninput_mt_sync(data->in_dev);\r\n}\r\n} else\r\ninput_mt_sync(data->in_dev);\r\ninput_sync(data->in_dev);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t bu21013_gpio_irq(int irq, void *device_data)\r\n{\r\nstruct bu21013_ts_data *data = device_data;\r\nstruct i2c_client *i2c = data->client;\r\nint retval;\r\ndo {\r\nretval = bu21013_do_touch_report(data);\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "bu21013_do_touch_report failed\n");\r\nreturn IRQ_NONE;\r\n}\r\ndata->intr_pin = gpio_get_value(data->chip->touch_pin);\r\nif (data->intr_pin == PEN_DOWN_INTR)\r\nwait_event_timeout(data->wait, data->touch_stopped,\r\nmsecs_to_jiffies(2));\r\n} while (!data->intr_pin && !data->touch_stopped);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bu21013_init_chip(struct bu21013_ts_data *data)\r\n{\r\nint retval;\r\nstruct i2c_client *i2c = data->client;\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_RESET_REG,\r\nBU21013_RESET_ENABLE);\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_RESET reg write failed\n");\r\nreturn retval;\r\n}\r\nmsleep(RESET_DELAY);\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_SENSOR_0_7_REG,\r\nBU21013_SENSORS_EN_0_7);\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_SENSOR_0_7 reg write failed\n");\r\nreturn retval;\r\n}\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_SENSOR_8_15_REG,\r\nBU21013_SENSORS_EN_8_15);\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_SENSOR_8_15 reg write failed\n");\r\nreturn retval;\r\n}\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_SENSOR_16_23_REG,\r\nBU21013_SENSORS_EN_16_23);\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_SENSOR_16_23 reg write failed\n");\r\nreturn retval;\r\n}\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_POS_MODE1_REG,\r\n(BU21013_POS_MODE1_0 | BU21013_POS_MODE1_1));\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_POS_MODE1 reg write failed\n");\r\nreturn retval;\r\n}\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_POS_MODE2_REG,\r\n(BU21013_POS_MODE2_ZERO | BU21013_POS_MODE2_AVG1 |\r\nBU21013_POS_MODE2_AVG2 | BU21013_POS_MODE2_EN_RAW |\r\nBU21013_POS_MODE2_MULTI));\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_POS_MODE2 reg write failed\n");\r\nreturn retval;\r\n}\r\nif (data->chip->ext_clk)\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_CLK_MODE_REG,\r\n(BU21013_CLK_MODE_EXT | BU21013_CLK_MODE_CALIB));\r\nelse\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_CLK_MODE_REG,\r\n(BU21013_CLK_MODE_DIV | BU21013_CLK_MODE_CALIB));\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_CLK_MODE reg write failed\n");\r\nreturn retval;\r\n}\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_IDLE_REG,\r\n(BU21013_IDLET_0 | BU21013_IDLE_INTERMIT_EN));\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_IDLE reg write failed\n");\r\nreturn retval;\r\n}\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_INT_MODE_REG,\r\nBU21013_INT_MODE_LEVEL);\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_INT_MODE reg write failed\n");\r\nreturn retval;\r\n}\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_FILTER_REG,\r\n(BU21013_DELTA_0_6 |\r\nBU21013_FILTER_EN));\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_FILTER reg write failed\n");\r\nreturn retval;\r\n}\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_TH_ON_REG,\r\nBU21013_TH_ON_5);\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_TH_ON reg write failed\n");\r\nreturn retval;\r\n}\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_TH_OFF_REG,\r\nBU21013_TH_OFF_4 | BU21013_TH_OFF_3);\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_TH_OFF reg write failed\n");\r\nreturn retval;\r\n}\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_GAIN_REG,\r\n(BU21013_GAIN_0 | BU21013_GAIN_1));\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_GAIN reg write failed\n");\r\nreturn retval;\r\n}\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_OFFSET_MODE_REG,\r\nBU21013_OFFSET_MODE_DEFAULT);\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_OFFSET_MODE reg write failed\n");\r\nreturn retval;\r\n}\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_XY_EDGE_REG,\r\n(BU21013_X_EDGE_0 | BU21013_X_EDGE_2 |\r\nBU21013_Y_EDGE_1 | BU21013_Y_EDGE_3));\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_XY_EDGE reg write failed\n");\r\nreturn retval;\r\n}\r\nretval = i2c_smbus_write_byte_data(i2c, BU21013_DONE_REG,\r\nBU21013_DONE);\r\nif (retval < 0) {\r\ndev_err(&i2c->dev, "BU21013_REG_DONE reg write failed\n");\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bu21013_free_irq(struct bu21013_ts_data *bu21013_data)\r\n{\r\nbu21013_data->touch_stopped = true;\r\nwake_up(&bu21013_data->wait);\r\nfree_irq(bu21013_data->irq, bu21013_data);\r\n}\r\nstatic void bu21013_cs_disable(struct bu21013_ts_data *bu21013_data)\r\n{\r\nint error;\r\nerror = gpio_direction_output(bu21013_data->chip->cs_pin, 0);\r\nif (error < 0)\r\ndev_warn(&bu21013_data->client->dev,\r\n"%s: gpio direction failed, error: %d\n",\r\n__func__, error);\r\nelse\r\ngpio_set_value(bu21013_data->chip->cs_pin, 0);\r\ngpio_free(bu21013_data->chip->cs_pin);\r\n}\r\nstatic const struct bu21013_platform_device *\r\nbu21013_parse_dt(struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct bu21013_platform_device *pdata;\r\nif (!np) {\r\ndev_err(dev, "no device tree or platform data\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\npdata->y_flip = pdata->x_flip = false;\r\npdata->x_flip = of_property_read_bool(np, "rohm,flip-x");\r\npdata->y_flip = of_property_read_bool(np, "rohm,flip-y");\r\nof_property_read_u32(np, "rohm,touch-max-x", &pdata->touch_x_max);\r\nof_property_read_u32(np, "rohm,touch-max-y", &pdata->touch_y_max);\r\npdata->touch_pin = of_get_named_gpio(np, "touch-gpio", 0);\r\npdata->cs_pin = of_get_named_gpio(np, "reset-gpio", 0);\r\npdata->ext_clk = false;\r\nreturn pdata;\r\n}\r\nstatic inline const struct bu21013_platform_device *\r\nbu21013_parse_dt(struct device *dev)\r\n{\r\ndev_err(dev, "no platform data available\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int bu21013_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct bu21013_platform_device *pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct bu21013_ts_data *bu21013_data;\r\nstruct input_dev *in_dev;\r\nint error;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&client->dev, "i2c smbus byte data not supported\n");\r\nreturn -EIO;\r\n}\r\nif (!pdata) {\r\npdata = bu21013_parse_dt(&client->dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n}\r\nif (!gpio_is_valid(pdata->touch_pin)) {\r\ndev_err(&client->dev, "invalid touch_pin supplied\n");\r\nreturn -EINVAL;\r\n}\r\nbu21013_data = kzalloc(sizeof(struct bu21013_ts_data), GFP_KERNEL);\r\nin_dev = input_allocate_device();\r\nif (!bu21013_data || !in_dev) {\r\ndev_err(&client->dev, "device memory alloc failed\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nbu21013_data->in_dev = in_dev;\r\nbu21013_data->chip = pdata;\r\nbu21013_data->client = client;\r\nbu21013_data->irq = gpio_to_irq(pdata->touch_pin);\r\nbu21013_data->regulator = regulator_get(&client->dev, "avdd");\r\nif (IS_ERR(bu21013_data->regulator)) {\r\ndev_err(&client->dev, "regulator_get failed\n");\r\nerror = PTR_ERR(bu21013_data->regulator);\r\ngoto err_free_mem;\r\n}\r\nerror = regulator_enable(bu21013_data->regulator);\r\nif (error < 0) {\r\ndev_err(&client->dev, "regulator enable failed\n");\r\ngoto err_put_regulator;\r\n}\r\nbu21013_data->touch_stopped = false;\r\ninit_waitqueue_head(&bu21013_data->wait);\r\nerror = gpio_request_one(pdata->cs_pin, GPIOF_OUT_INIT_HIGH,\r\n"touchp_reset");\r\nif (error < 0) {\r\ndev_err(&client->dev, "Unable to request gpio reset_pin\n");\r\ngoto err_disable_regulator;\r\n}\r\nerror = bu21013_init_chip(bu21013_data);\r\nif (error) {\r\ndev_err(&client->dev, "error in bu21013 config\n");\r\ngoto err_cs_disable;\r\n}\r\nin_dev->name = DRIVER_TP;\r\nin_dev->id.bustype = BUS_I2C;\r\nin_dev->dev.parent = &client->dev;\r\n__set_bit(EV_SYN, in_dev->evbit);\r\n__set_bit(EV_KEY, in_dev->evbit);\r\n__set_bit(EV_ABS, in_dev->evbit);\r\ninput_set_abs_params(in_dev, ABS_MT_POSITION_X, 0,\r\npdata->touch_x_max, 0, 0);\r\ninput_set_abs_params(in_dev, ABS_MT_POSITION_Y, 0,\r\npdata->touch_y_max, 0, 0);\r\ninput_set_drvdata(in_dev, bu21013_data);\r\nerror = request_threaded_irq(bu21013_data->irq, NULL, bu21013_gpio_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_SHARED |\r\nIRQF_ONESHOT,\r\nDRIVER_TP, bu21013_data);\r\nif (error) {\r\ndev_err(&client->dev, "request irq %d failed\n",\r\nbu21013_data->irq);\r\ngoto err_cs_disable;\r\n}\r\nerror = input_register_device(in_dev);\r\nif (error) {\r\ndev_err(&client->dev, "failed to register input device\n");\r\ngoto err_free_irq;\r\n}\r\ndevice_init_wakeup(&client->dev, pdata->wakeup);\r\ni2c_set_clientdata(client, bu21013_data);\r\nreturn 0;\r\nerr_free_irq:\r\nbu21013_free_irq(bu21013_data);\r\nerr_cs_disable:\r\nbu21013_cs_disable(bu21013_data);\r\nerr_disable_regulator:\r\nregulator_disable(bu21013_data->regulator);\r\nerr_put_regulator:\r\nregulator_put(bu21013_data->regulator);\r\nerr_free_mem:\r\ninput_free_device(in_dev);\r\nkfree(bu21013_data);\r\nreturn error;\r\n}\r\nstatic int bu21013_remove(struct i2c_client *client)\r\n{\r\nstruct bu21013_ts_data *bu21013_data = i2c_get_clientdata(client);\r\nbu21013_free_irq(bu21013_data);\r\nbu21013_cs_disable(bu21013_data);\r\ninput_unregister_device(bu21013_data->in_dev);\r\nregulator_disable(bu21013_data->regulator);\r\nregulator_put(bu21013_data->regulator);\r\nkfree(bu21013_data);\r\nreturn 0;\r\n}\r\nstatic int bu21013_suspend(struct device *dev)\r\n{\r\nstruct bu21013_ts_data *bu21013_data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = bu21013_data->client;\r\nbu21013_data->touch_stopped = true;\r\nif (device_may_wakeup(&client->dev))\r\nenable_irq_wake(bu21013_data->irq);\r\nelse\r\ndisable_irq(bu21013_data->irq);\r\nregulator_disable(bu21013_data->regulator);\r\nreturn 0;\r\n}\r\nstatic int bu21013_resume(struct device *dev)\r\n{\r\nstruct bu21013_ts_data *bu21013_data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = bu21013_data->client;\r\nint retval;\r\nretval = regulator_enable(bu21013_data->regulator);\r\nif (retval < 0) {\r\ndev_err(&client->dev, "bu21013 regulator enable failed\n");\r\nreturn retval;\r\n}\r\nretval = bu21013_init_chip(bu21013_data);\r\nif (retval < 0) {\r\ndev_err(&client->dev, "bu21013 controller config failed\n");\r\nreturn retval;\r\n}\r\nbu21013_data->touch_stopped = false;\r\nif (device_may_wakeup(&client->dev))\r\ndisable_irq_wake(bu21013_data->irq);\r\nelse\r\nenable_irq(bu21013_data->irq);\r\nreturn 0;\r\n}
