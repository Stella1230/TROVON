void ath10k_bmi_start(struct ath10k *ar)\r\n{\r\nint ret;\r\nath10k_dbg(ar, ATH10K_DBG_BMI, "bmi start\n");\r\nar->bmi.done_sent = false;\r\nif (ar->hw_params.hw_ops->enable_pll_clk) {\r\nret = ar->hw_params.hw_ops->enable_pll_clk(ar);\r\nath10k_dbg(ar, ATH10K_DBG_BMI, "bmi enable pll ret %d\n", ret);\r\n}\r\n}\r\nint ath10k_bmi_done(struct ath10k *ar)\r\n{\r\nstruct bmi_cmd cmd;\r\nu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.done);\r\nint ret;\r\nath10k_dbg(ar, ATH10K_DBG_BMI, "bmi done\n");\r\nif (ar->bmi.done_sent) {\r\nath10k_dbg(ar, ATH10K_DBG_BMI, "bmi skipped\n");\r\nreturn 0;\r\n}\r\nar->bmi.done_sent = true;\r\ncmd.id = __cpu_to_le32(BMI_DONE);\r\nret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen, NULL, NULL);\r\nif (ret) {\r\nath10k_warn(ar, "unable to write to the device: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint ath10k_bmi_get_target_info(struct ath10k *ar,\r\nstruct bmi_target_info *target_info)\r\n{\r\nstruct bmi_cmd cmd;\r\nunion bmi_resp resp;\r\nu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.get_target_info);\r\nu32 resplen = sizeof(resp.get_target_info);\r\nint ret;\r\nath10k_dbg(ar, ATH10K_DBG_BMI, "bmi get target info\n");\r\nif (ar->bmi.done_sent) {\r\nath10k_warn(ar, "BMI Get Target Info Command disallowed\n");\r\nreturn -EBUSY;\r\n}\r\ncmd.id = __cpu_to_le32(BMI_GET_TARGET_INFO);\r\nret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen, &resp, &resplen);\r\nif (ret) {\r\nath10k_warn(ar, "unable to get target info from device\n");\r\nreturn ret;\r\n}\r\nif (resplen < sizeof(resp.get_target_info)) {\r\nath10k_warn(ar, "invalid get_target_info response length (%d)\n",\r\nresplen);\r\nreturn -EIO;\r\n}\r\ntarget_info->version = __le32_to_cpu(resp.get_target_info.version);\r\ntarget_info->type = __le32_to_cpu(resp.get_target_info.type);\r\nreturn 0;\r\n}\r\nint ath10k_bmi_get_target_info_sdio(struct ath10k *ar,\r\nstruct bmi_target_info *target_info)\r\n{\r\nstruct bmi_cmd cmd;\r\nunion bmi_resp resp;\r\nu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.get_target_info);\r\nu32 resplen, ver_len;\r\n__le32 tmp;\r\nint ret;\r\nath10k_dbg(ar, ATH10K_DBG_BMI, "bmi get target info SDIO\n");\r\nif (ar->bmi.done_sent) {\r\nath10k_warn(ar, "BMI Get Target Info Command disallowed\n");\r\nreturn -EBUSY;\r\n}\r\ncmd.id = __cpu_to_le32(BMI_GET_TARGET_INFO);\r\nresplen = sizeof(u32);\r\nret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen, &tmp, &resplen);\r\nif (ret) {\r\nath10k_warn(ar, "unable to read from device\n");\r\nreturn ret;\r\n}\r\nif (__le32_to_cpu(tmp) == TARGET_VERSION_SENTINAL) {\r\nresplen = sizeof(u32);\r\nret = ath10k_hif_exchange_bmi_msg(ar, NULL, 0, &tmp,\r\n&resplen);\r\nif (ret) {\r\nath10k_warn(ar, "unable to read from device\n");\r\nreturn ret;\r\n}\r\n}\r\nver_len = __le32_to_cpu(tmp);\r\nif (ver_len != sizeof(resp.get_target_info)) {\r\nath10k_warn(ar, "Unexpected target info len: %u. Expected: %zu\n",\r\nver_len, sizeof(resp.get_target_info));\r\nreturn -EINVAL;\r\n}\r\nresplen = sizeof(resp.get_target_info) - sizeof(u32);\r\nret = ath10k_hif_exchange_bmi_msg(ar, NULL, 0,\r\n&resp.get_target_info.version,\r\n&resplen);\r\nif (ret) {\r\nath10k_warn(ar, "unable to read from device\n");\r\nreturn ret;\r\n}\r\ntarget_info->version = __le32_to_cpu(resp.get_target_info.version);\r\ntarget_info->type = __le32_to_cpu(resp.get_target_info.type);\r\nreturn 0;\r\n}\r\nint ath10k_bmi_read_memory(struct ath10k *ar,\r\nu32 address, void *buffer, u32 length)\r\n{\r\nstruct bmi_cmd cmd;\r\nunion bmi_resp resp;\r\nu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.read_mem);\r\nu32 rxlen;\r\nint ret;\r\nath10k_dbg(ar, ATH10K_DBG_BMI, "bmi read address 0x%x length %d\n",\r\naddress, length);\r\nif (ar->bmi.done_sent) {\r\nath10k_warn(ar, "command disallowed\n");\r\nreturn -EBUSY;\r\n}\r\nwhile (length) {\r\nrxlen = min_t(u32, length, BMI_MAX_DATA_SIZE);\r\ncmd.id = __cpu_to_le32(BMI_READ_MEMORY);\r\ncmd.read_mem.addr = __cpu_to_le32(address);\r\ncmd.read_mem.len = __cpu_to_le32(rxlen);\r\nret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen,\r\n&resp, &rxlen);\r\nif (ret) {\r\nath10k_warn(ar, "unable to read from the device (%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\nmemcpy(buffer, resp.read_mem.payload, rxlen);\r\naddress += rxlen;\r\nbuffer += rxlen;\r\nlength -= rxlen;\r\n}\r\nreturn 0;\r\n}\r\nint ath10k_bmi_write_soc_reg(struct ath10k *ar, u32 address, u32 reg_val)\r\n{\r\nstruct bmi_cmd cmd;\r\nu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.write_soc_reg);\r\nint ret;\r\nath10k_dbg(ar, ATH10K_DBG_BMI,\r\n"bmi write soc register 0x%08x val 0x%08x\n",\r\naddress, reg_val);\r\nif (ar->bmi.done_sent) {\r\nath10k_warn(ar, "bmi write soc register command in progress\n");\r\nreturn -EBUSY;\r\n}\r\ncmd.id = __cpu_to_le32(BMI_WRITE_SOC_REGISTER);\r\ncmd.write_soc_reg.addr = __cpu_to_le32(address);\r\ncmd.write_soc_reg.value = __cpu_to_le32(reg_val);\r\nret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen, NULL, NULL);\r\nif (ret) {\r\nath10k_warn(ar, "Unable to write soc register to device: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint ath10k_bmi_read_soc_reg(struct ath10k *ar, u32 address, u32 *reg_val)\r\n{\r\nstruct bmi_cmd cmd;\r\nunion bmi_resp resp;\r\nu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.read_soc_reg);\r\nu32 resplen = sizeof(resp.read_soc_reg);\r\nint ret;\r\nath10k_dbg(ar, ATH10K_DBG_BMI, "bmi read soc register 0x%08x\n",\r\naddress);\r\nif (ar->bmi.done_sent) {\r\nath10k_warn(ar, "bmi read soc register command in progress\n");\r\nreturn -EBUSY;\r\n}\r\ncmd.id = __cpu_to_le32(BMI_READ_SOC_REGISTER);\r\ncmd.read_soc_reg.addr = __cpu_to_le32(address);\r\nret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen, &resp, &resplen);\r\nif (ret) {\r\nath10k_warn(ar, "Unable to read soc register from device: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n*reg_val = __le32_to_cpu(resp.read_soc_reg.value);\r\nath10k_dbg(ar, ATH10K_DBG_BMI, "bmi read soc register value 0x%08x\n",\r\n*reg_val);\r\nreturn 0;\r\n}\r\nint ath10k_bmi_write_memory(struct ath10k *ar,\r\nu32 address, const void *buffer, u32 length)\r\n{\r\nstruct bmi_cmd cmd;\r\nu32 hdrlen = sizeof(cmd.id) + sizeof(cmd.write_mem);\r\nu32 txlen;\r\nint ret;\r\nath10k_dbg(ar, ATH10K_DBG_BMI, "bmi write address 0x%x length %d\n",\r\naddress, length);\r\nif (ar->bmi.done_sent) {\r\nath10k_warn(ar, "command disallowed\n");\r\nreturn -EBUSY;\r\n}\r\nwhile (length) {\r\ntxlen = min(length, BMI_MAX_DATA_SIZE - hdrlen);\r\nmemcpy(cmd.write_mem.payload, buffer, txlen);\r\ntxlen = roundup(txlen, 4);\r\ncmd.id = __cpu_to_le32(BMI_WRITE_MEMORY);\r\ncmd.write_mem.addr = __cpu_to_le32(address);\r\ncmd.write_mem.len = __cpu_to_le32(txlen);\r\nret = ath10k_hif_exchange_bmi_msg(ar, &cmd, hdrlen + txlen,\r\nNULL, NULL);\r\nif (ret) {\r\nath10k_warn(ar, "unable to write to the device (%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\ntxlen = min(txlen, length);\r\naddress += txlen;\r\nbuffer += txlen;\r\nlength -= txlen;\r\n}\r\nreturn 0;\r\n}\r\nint ath10k_bmi_execute(struct ath10k *ar, u32 address, u32 param, u32 *result)\r\n{\r\nstruct bmi_cmd cmd;\r\nunion bmi_resp resp;\r\nu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.execute);\r\nu32 resplen = sizeof(resp.execute);\r\nint ret;\r\nath10k_dbg(ar, ATH10K_DBG_BMI, "bmi execute address 0x%x param 0x%x\n",\r\naddress, param);\r\nif (ar->bmi.done_sent) {\r\nath10k_warn(ar, "command disallowed\n");\r\nreturn -EBUSY;\r\n}\r\ncmd.id = __cpu_to_le32(BMI_EXECUTE);\r\ncmd.execute.addr = __cpu_to_le32(address);\r\ncmd.execute.param = __cpu_to_le32(param);\r\nret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen, &resp, &resplen);\r\nif (ret) {\r\nath10k_warn(ar, "unable to read from the device\n");\r\nreturn ret;\r\n}\r\nif (resplen < sizeof(resp.execute)) {\r\nath10k_warn(ar, "invalid execute response length (%d)\n",\r\nresplen);\r\nreturn -EIO;\r\n}\r\n*result = __le32_to_cpu(resp.execute.result);\r\nath10k_dbg(ar, ATH10K_DBG_BMI, "bmi execute result 0x%x\n", *result);\r\nreturn 0;\r\n}\r\nint ath10k_bmi_lz_data(struct ath10k *ar, const void *buffer, u32 length)\r\n{\r\nstruct bmi_cmd cmd;\r\nu32 hdrlen = sizeof(cmd.id) + sizeof(cmd.lz_data);\r\nu32 txlen;\r\nint ret;\r\nath10k_dbg(ar, ATH10K_DBG_BMI, "bmi lz data buffer 0x%pK length %d\n",\r\nbuffer, length);\r\nif (ar->bmi.done_sent) {\r\nath10k_warn(ar, "command disallowed\n");\r\nreturn -EBUSY;\r\n}\r\nwhile (length) {\r\ntxlen = min(length, BMI_MAX_DATA_SIZE - hdrlen);\r\nWARN_ON_ONCE(txlen & 3);\r\ncmd.id = __cpu_to_le32(BMI_LZ_DATA);\r\ncmd.lz_data.len = __cpu_to_le32(txlen);\r\nmemcpy(cmd.lz_data.payload, buffer, txlen);\r\nret = ath10k_hif_exchange_bmi_msg(ar, &cmd, hdrlen + txlen,\r\nNULL, NULL);\r\nif (ret) {\r\nath10k_warn(ar, "unable to write to the device\n");\r\nreturn ret;\r\n}\r\nbuffer += txlen;\r\nlength -= txlen;\r\n}\r\nreturn 0;\r\n}\r\nint ath10k_bmi_lz_stream_start(struct ath10k *ar, u32 address)\r\n{\r\nstruct bmi_cmd cmd;\r\nu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.lz_start);\r\nint ret;\r\nath10k_dbg(ar, ATH10K_DBG_BMI, "bmi lz stream start address 0x%x\n",\r\naddress);\r\nif (ar->bmi.done_sent) {\r\nath10k_warn(ar, "command disallowed\n");\r\nreturn -EBUSY;\r\n}\r\ncmd.id = __cpu_to_le32(BMI_LZ_STREAM_START);\r\ncmd.lz_start.addr = __cpu_to_le32(address);\r\nret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen, NULL, NULL);\r\nif (ret) {\r\nath10k_warn(ar, "unable to Start LZ Stream to the device\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint ath10k_bmi_fast_download(struct ath10k *ar,\r\nu32 address, const void *buffer, u32 length)\r\n{\r\nu8 trailer[4] = {};\r\nu32 head_len = rounddown(length, 4);\r\nu32 trailer_len = length - head_len;\r\nint ret;\r\nath10k_dbg(ar, ATH10K_DBG_BMI,\r\n"bmi fast download address 0x%x buffer 0x%pK length %d\n",\r\naddress, buffer, length);\r\nret = ath10k_bmi_lz_stream_start(ar, address);\r\nif (ret)\r\nreturn ret;\r\nif (trailer_len > 0)\r\nmemcpy(trailer, buffer + head_len, trailer_len);\r\nret = ath10k_bmi_lz_data(ar, buffer, head_len);\r\nif (ret)\r\nreturn ret;\r\nif (trailer_len > 0)\r\nret = ath10k_bmi_lz_data(ar, trailer, 4);\r\nif (ret != 0)\r\nreturn ret;\r\nret = ath10k_bmi_lz_stream_start(ar, 0x00);\r\nreturn ret;\r\n}
