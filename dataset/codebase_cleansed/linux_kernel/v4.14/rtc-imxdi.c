static void di_write_busy_wait(const struct imxdi_dev *imxdi, u32 val,\r\nunsigned reg)\r\n{\r\nwritel(val, imxdi->ioaddr + reg);\r\nusleep_range(130, 200);\r\n}\r\nstatic void di_report_tamper_info(struct imxdi_dev *imxdi, u32 dsr)\r\n{\r\nu32 dtcr;\r\ndtcr = readl(imxdi->ioaddr + DTCR);\r\ndev_emerg(&imxdi->pdev->dev, "DryIce tamper event detected\n");\r\nif (dsr & DSR_VTD)\r\ndev_emerg(&imxdi->pdev->dev, "%sVoltage Tamper Event\n",\r\ndtcr & DTCR_VTE ? "" : "Spurious ");\r\nif (dsr & DSR_CTD)\r\ndev_emerg(&imxdi->pdev->dev, "%s32768 Hz Clock Tamper Event\n",\r\ndtcr & DTCR_CTE ? "" : "Spurious ");\r\nif (dsr & DSR_TTD)\r\ndev_emerg(&imxdi->pdev->dev, "%sTemperature Tamper Event\n",\r\ndtcr & DTCR_TTE ? "" : "Spurious ");\r\nif (dsr & DSR_SAD)\r\ndev_emerg(&imxdi->pdev->dev,\r\n"%sSecure Controller Alarm Event\n",\r\ndtcr & DTCR_SAIE ? "" : "Spurious ");\r\nif (dsr & DSR_EBD)\r\ndev_emerg(&imxdi->pdev->dev, "%sExternal Boot Tamper Event\n",\r\ndtcr & DTCR_EBE ? "" : "Spurious ");\r\nif (dsr & DSR_ETAD)\r\ndev_emerg(&imxdi->pdev->dev, "%sExternal Tamper A Event\n",\r\ndtcr & DTCR_ETAE ? "" : "Spurious ");\r\nif (dsr & DSR_ETBD)\r\ndev_emerg(&imxdi->pdev->dev, "%sExternal Tamper B Event\n",\r\ndtcr & DTCR_ETBE ? "" : "Spurious ");\r\nif (dsr & DSR_WTD)\r\ndev_emerg(&imxdi->pdev->dev, "%sWire-mesh Tamper Event\n",\r\ndtcr & DTCR_WTE ? "" : "Spurious ");\r\nif (dsr & DSR_MCO)\r\ndev_emerg(&imxdi->pdev->dev,\r\n"%sMonotonic-counter Overflow Event\n",\r\ndtcr & DTCR_MOE ? "" : "Spurious ");\r\nif (dsr & DSR_TCO)\r\ndev_emerg(&imxdi->pdev->dev, "%sTimer-counter Overflow Event\n",\r\ndtcr & DTCR_TOE ? "" : "Spurious ");\r\n}\r\nstatic void di_what_is_to_be_done(struct imxdi_dev *imxdi,\r\nconst char *power_supply)\r\n{\r\ndev_emerg(&imxdi->pdev->dev, "Please cycle the %s power supply in order to get the DryIce/RTC unit working again\n",\r\npower_supply);\r\n}\r\nstatic int di_handle_failure_state(struct imxdi_dev *imxdi, u32 dsr)\r\n{\r\nu32 dcr;\r\ndev_dbg(&imxdi->pdev->dev, "DSR register reports: %08X\n", dsr);\r\ndi_report_tamper_info(imxdi, dsr);\r\ndcr = readl(imxdi->ioaddr + DCR);\r\nif (dcr & DCR_FSHL) {\r\ndi_what_is_to_be_done(imxdi, "battery");\r\nreturn -ENODEV;\r\n}\r\ndi_what_is_to_be_done(imxdi, "main");\r\nreturn -ENODEV;\r\n}\r\nstatic int di_handle_valid_state(struct imxdi_dev *imxdi, u32 dsr)\r\n{\r\ndi_write_busy_wait(imxdi, DCAMR_UNSET, DCAMR);\r\ndi_write_busy_wait(imxdi, 0, DCALR);\r\nif (dsr & DSR_CAF)\r\ndi_write_busy_wait(imxdi, DSR_CAF, DSR);\r\nreturn 0;\r\n}\r\nstatic int di_handle_invalid_state(struct imxdi_dev *imxdi, u32 dsr)\r\n{\r\nu32 dcr, sec;\r\ndi_write_busy_wait(imxdi, 0x00000000, DTCR);\r\ndi_write_busy_wait(imxdi, DCR_TDCSL, DCR);\r\nsec = readl(imxdi->ioaddr + DTCMR);\r\nif (sec != 0)\r\ndev_warn(&imxdi->pdev->dev,\r\n"The security violation has happened at %u seconds\n",\r\nsec);\r\ndcr = readl(imxdi->ioaddr + DCR);\r\nif (!(dcr & DCR_TCE)) {\r\nif (dcr & DCR_TCHL) {\r\ndi_what_is_to_be_done(imxdi, "battery");\r\nreturn -ENODEV;\r\n}\r\nif (dcr & DCR_TCSL) {\r\ndi_what_is_to_be_done(imxdi, "main");\r\nreturn -ENODEV;\r\n}\r\n}\r\ndi_write_busy_wait(imxdi, DSR_NVF, DSR);\r\ndi_write_busy_wait(imxdi, DSR_TCO, DSR);\r\ndi_write_busy_wait(imxdi, dcr | DCR_TCE, DCR);\r\ndi_write_busy_wait(imxdi, sec, DTCMR);\r\nreturn di_handle_valid_state(imxdi, __raw_readl(imxdi->ioaddr + DSR));\r\n}\r\nstatic int di_handle_invalid_and_failure_state(struct imxdi_dev *imxdi, u32 dsr)\r\n{\r\nu32 dcr;\r\nif (dsr & (DSR_WTD | DSR_ETBD | DSR_ETAD | DSR_EBD | DSR_SAD |\r\nDSR_TTD | DSR_CTD | DSR_VTD | DSR_MCO | DSR_TCO)) {\r\ndcr = __raw_readl(imxdi->ioaddr + DCR);\r\nif (dcr & DCR_TDCHL) {\r\ndi_what_is_to_be_done(imxdi, "battery");\r\nreturn -ENODEV;\r\n}\r\nif (dcr & DCR_TDCSL) {\r\ndi_what_is_to_be_done(imxdi, "main");\r\nreturn -ENODEV;\r\n}\r\n}\r\ndi_write_busy_wait(imxdi, 0x00000000, DTCR);\r\ndi_write_busy_wait(imxdi, dsr & (DSR_WTD | DSR_ETBD | DSR_ETAD |\r\nDSR_EBD | DSR_SAD | DSR_TTD | DSR_CTD | DSR_VTD |\r\nDSR_MCO | DSR_TCO), DSR);\r\ndsr = readl(imxdi->ioaddr + DSR);\r\nif ((dsr & ~(DSR_NVF | DSR_SVF | DSR_WBF | DSR_WNF |\r\nDSR_WCF | DSR_WEF)) != 0)\r\ndev_warn(&imxdi->pdev->dev,\r\n"There are still some sources of pain in DSR: %08x!\n",\r\ndsr & ~(DSR_NVF | DSR_SVF | DSR_WBF | DSR_WNF |\r\nDSR_WCF | DSR_WEF));\r\ndi_write_busy_wait(imxdi, DSR_SVF, DSR);\r\ndsr = readl(imxdi->ioaddr + DSR);\r\nif (dsr & DSR_SVF) {\r\ndev_crit(&imxdi->pdev->dev,\r\n"Cannot clear the security violation flag. We are ending up in an endless loop!\n");\r\ndi_what_is_to_be_done(imxdi, "battery");\r\nreturn -ENODEV;\r\n}\r\nreturn di_handle_invalid_state(imxdi, dsr);\r\n}\r\nstatic int di_handle_state(struct imxdi_dev *imxdi)\r\n{\r\nint rc;\r\nu32 dsr;\r\ndsr = readl(imxdi->ioaddr + DSR);\r\nswitch (dsr & (DSR_NVF | DSR_SVF)) {\r\ncase DSR_NVF:\r\ndev_warn(&imxdi->pdev->dev, "Invalid stated unit detected\n");\r\nrc = di_handle_invalid_state(imxdi, dsr);\r\nbreak;\r\ncase DSR_SVF:\r\ndev_warn(&imxdi->pdev->dev, "Failure stated unit detected\n");\r\nrc = di_handle_failure_state(imxdi, dsr);\r\nbreak;\r\ncase DSR_NVF | DSR_SVF:\r\ndev_warn(&imxdi->pdev->dev,\r\n"Failure+Invalid stated unit detected\n");\r\nrc = di_handle_invalid_and_failure_state(imxdi, dsr);\r\nbreak;\r\ndefault:\r\ndev_notice(&imxdi->pdev->dev, "Unlocked unit detected\n");\r\nrc = di_handle_valid_state(imxdi, dsr);\r\n}\r\nreturn rc;\r\n}\r\nstatic void di_int_enable(struct imxdi_dev *imxdi, u32 intr)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&imxdi->irq_lock, flags);\r\nwritel(readl(imxdi->ioaddr + DIER) | intr,\r\nimxdi->ioaddr + DIER);\r\nspin_unlock_irqrestore(&imxdi->irq_lock, flags);\r\n}\r\nstatic void di_int_disable(struct imxdi_dev *imxdi, u32 intr)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&imxdi->irq_lock, flags);\r\nwritel(readl(imxdi->ioaddr + DIER) & ~intr,\r\nimxdi->ioaddr + DIER);\r\nspin_unlock_irqrestore(&imxdi->irq_lock, flags);\r\n}\r\nstatic void clear_write_error(struct imxdi_dev *imxdi)\r\n{\r\nint cnt;\r\ndev_warn(&imxdi->pdev->dev, "WARNING: Register write error!\n");\r\nwritel(DSR_WEF, imxdi->ioaddr + DSR);\r\nfor (cnt = 0; cnt < 1000; cnt++) {\r\nif ((readl(imxdi->ioaddr + DSR) & DSR_WEF) == 0)\r\nreturn;\r\nudelay(10);\r\n}\r\ndev_err(&imxdi->pdev->dev,\r\n"ERROR: Cannot clear write-error flag!\n");\r\n}\r\nstatic int di_write_wait(struct imxdi_dev *imxdi, u32 val, int reg)\r\n{\r\nint ret;\r\nint rc = 0;\r\nmutex_lock(&imxdi->write_mutex);\r\ndi_int_enable(imxdi, DIER_WCIE);\r\nimxdi->dsr = 0;\r\nwritel(val, imxdi->ioaddr + reg);\r\nret = wait_event_interruptible_timeout(imxdi->write_wait,\r\nimxdi->dsr & (DSR_WCF | DSR_WEF), msecs_to_jiffies(1));\r\nif (ret < 0) {\r\nrc = ret;\r\ngoto out;\r\n} else if (ret == 0) {\r\ndev_warn(&imxdi->pdev->dev,\r\n"Write-wait timeout "\r\n"val = 0x%08x reg = 0x%08x\n", val, reg);\r\n}\r\nif (imxdi->dsr & DSR_WEF) {\r\nclear_write_error(imxdi);\r\nrc = -EIO;\r\n}\r\nout:\r\nmutex_unlock(&imxdi->write_mutex);\r\nreturn rc;\r\n}\r\nstatic int dryice_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct imxdi_dev *imxdi = dev_get_drvdata(dev);\r\nunsigned long now;\r\nnow = readl(imxdi->ioaddr + DTCMR);\r\nrtc_time_to_tm(now, tm);\r\nreturn 0;\r\n}\r\nstatic int dryice_rtc_set_mmss(struct device *dev, unsigned long secs)\r\n{\r\nstruct imxdi_dev *imxdi = dev_get_drvdata(dev);\r\nu32 dcr, dsr;\r\nint rc;\r\ndcr = readl(imxdi->ioaddr + DCR);\r\ndsr = readl(imxdi->ioaddr + DSR);\r\nif (!(dcr & DCR_TCE) || (dsr & DSR_SVF)) {\r\nif (dcr & DCR_TCHL) {\r\ndi_what_is_to_be_done(imxdi, "battery");\r\nreturn -EPERM;\r\n}\r\nif ((dcr & DCR_TCSL) || (dsr & DSR_SVF)) {\r\ndi_what_is_to_be_done(imxdi, "main");\r\nreturn -EPERM;\r\n}\r\n}\r\nrc = di_write_wait(imxdi, 0, DTCLR);\r\nif (rc != 0)\r\nreturn rc;\r\nrc = di_write_wait(imxdi, secs, DTCMR);\r\nif (rc != 0)\r\nreturn rc;\r\nreturn di_write_wait(imxdi, readl(imxdi->ioaddr + DCR) | DCR_TCE, DCR);\r\n}\r\nstatic int dryice_rtc_alarm_irq_enable(struct device *dev,\r\nunsigned int enabled)\r\n{\r\nstruct imxdi_dev *imxdi = dev_get_drvdata(dev);\r\nif (enabled)\r\ndi_int_enable(imxdi, DIER_CAIE);\r\nelse\r\ndi_int_disable(imxdi, DIER_CAIE);\r\nreturn 0;\r\n}\r\nstatic int dryice_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct imxdi_dev *imxdi = dev_get_drvdata(dev);\r\nu32 dcamr;\r\ndcamr = readl(imxdi->ioaddr + DCAMR);\r\nrtc_time_to_tm(dcamr, &alarm->time);\r\nalarm->enabled = (readl(imxdi->ioaddr + DIER) & DIER_CAIE) != 0;\r\nmutex_lock(&imxdi->write_mutex);\r\nalarm->pending = (readl(imxdi->ioaddr + DSR) & DSR_CAF) != 0;\r\nmutex_unlock(&imxdi->write_mutex);\r\nreturn 0;\r\n}\r\nstatic int dryice_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct imxdi_dev *imxdi = dev_get_drvdata(dev);\r\nunsigned long now;\r\nunsigned long alarm_time;\r\nint rc;\r\nrc = rtc_tm_to_time(&alarm->time, &alarm_time);\r\nif (rc)\r\nreturn rc;\r\nnow = readl(imxdi->ioaddr + DTCMR);\r\nif (alarm_time < now)\r\nreturn -EINVAL;\r\nrc = di_write_wait(imxdi, (u32)alarm_time, DCAMR);\r\nif (rc)\r\nreturn rc;\r\nif (alarm->enabled)\r\ndi_int_enable(imxdi, DIER_CAIE);\r\nelse\r\ndi_int_disable(imxdi, DIER_CAIE);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t dryice_irq(int irq, void *dev_id)\r\n{\r\nstruct imxdi_dev *imxdi = dev_id;\r\nu32 dsr, dier;\r\nirqreturn_t rc = IRQ_NONE;\r\ndier = readl(imxdi->ioaddr + DIER);\r\ndsr = readl(imxdi->ioaddr + DSR);\r\nif (dier & DIER_SVIE) {\r\nif (dsr & DSR_SVF) {\r\ndi_int_disable(imxdi, DIER_SVIE);\r\ndi_report_tamper_info(imxdi, dsr);\r\nrc = IRQ_HANDLED;\r\n}\r\n}\r\nif (dier & DIER_WCIE) {\r\nif (list_empty_careful(&imxdi->write_wait.head))\r\nreturn rc;\r\nif (dsr & (DSR_WCF | DSR_WEF)) {\r\ndi_int_disable(imxdi, DIER_WCIE);\r\nimxdi->dsr |= dsr;\r\nwake_up_interruptible(&imxdi->write_wait);\r\nrc = IRQ_HANDLED;\r\n}\r\n}\r\nif (dier & DIER_CAIE) {\r\nif (dsr & DSR_CAF) {\r\ndi_int_disable(imxdi, DIER_CAIE);\r\nschedule_work(&imxdi->work);\r\nrc = IRQ_HANDLED;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic void dryice_work(struct work_struct *work)\r\n{\r\nstruct imxdi_dev *imxdi = container_of(work,\r\nstruct imxdi_dev, work);\r\ndi_write_wait(imxdi, DSR_CAF, DSR);\r\nrtc_update_irq(imxdi->rtc, 1, RTC_AF | RTC_IRQF);\r\n}\r\nstatic int __init dryice_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct imxdi_dev *imxdi;\r\nint norm_irq, sec_irq;\r\nint rc;\r\nimxdi = devm_kzalloc(&pdev->dev, sizeof(*imxdi), GFP_KERNEL);\r\nif (!imxdi)\r\nreturn -ENOMEM;\r\nimxdi->pdev = pdev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nimxdi->ioaddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(imxdi->ioaddr))\r\nreturn PTR_ERR(imxdi->ioaddr);\r\nspin_lock_init(&imxdi->irq_lock);\r\nnorm_irq = platform_get_irq(pdev, 0);\r\nif (norm_irq < 0)\r\nreturn norm_irq;\r\nsec_irq = platform_get_irq(pdev, 1);\r\nif (sec_irq <= 0)\r\nsec_irq = IRQ_NOTCONNECTED;\r\ninit_waitqueue_head(&imxdi->write_wait);\r\nINIT_WORK(&imxdi->work, dryice_work);\r\nmutex_init(&imxdi->write_mutex);\r\nimxdi->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(imxdi->clk))\r\nreturn PTR_ERR(imxdi->clk);\r\nrc = clk_prepare_enable(imxdi->clk);\r\nif (rc)\r\nreturn rc;\r\nwritel(0, imxdi->ioaddr + DIER);\r\nrc = di_handle_state(imxdi);\r\nif (rc != 0)\r\ngoto err;\r\nrc = devm_request_irq(&pdev->dev, norm_irq, dryice_irq,\r\nIRQF_SHARED, pdev->name, imxdi);\r\nif (rc) {\r\ndev_warn(&pdev->dev, "interrupt not available.\n");\r\ngoto err;\r\n}\r\nrc = devm_request_irq(&pdev->dev, sec_irq, dryice_irq,\r\nIRQF_SHARED, pdev->name, imxdi);\r\nif (rc) {\r\ndev_warn(&pdev->dev, "security violation interrupt not available.\n");\r\n}\r\nplatform_set_drvdata(pdev, imxdi);\r\nimxdi->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&dryice_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(imxdi->rtc)) {\r\nrc = PTR_ERR(imxdi->rtc);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nclk_disable_unprepare(imxdi->clk);\r\nreturn rc;\r\n}\r\nstatic int __exit dryice_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct imxdi_dev *imxdi = platform_get_drvdata(pdev);\r\nflush_work(&imxdi->work);\r\nwritel(0, imxdi->ioaddr + DIER);\r\nclk_disable_unprepare(imxdi->clk);\r\nreturn 0;\r\n}
