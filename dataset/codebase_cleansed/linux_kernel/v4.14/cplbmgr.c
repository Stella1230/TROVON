static inline void write_dcplb_data(int cpu, int idx, unsigned long data,\r\nunsigned long addr)\r\n{\r\n_disable_dcplb();\r\nbfin_write32(DCPLB_DATA0 + idx * 4, data);\r\nbfin_write32(DCPLB_ADDR0 + idx * 4, addr);\r\n_enable_dcplb();\r\n#ifdef CONFIG_CPLB_INFO\r\ndcplb_tbl[cpu][idx].addr = addr;\r\ndcplb_tbl[cpu][idx].data = data;\r\n#endif\r\n}\r\nstatic inline void write_icplb_data(int cpu, int idx, unsigned long data,\r\nunsigned long addr)\r\n{\r\n_disable_icplb();\r\nbfin_write32(ICPLB_DATA0 + idx * 4, data);\r\nbfin_write32(ICPLB_ADDR0 + idx * 4, addr);\r\n_enable_icplb();\r\n#ifdef CONFIG_CPLB_INFO\r\nicplb_tbl[cpu][idx].addr = addr;\r\nicplb_tbl[cpu][idx].data = data;\r\n#endif\r\n}\r\nstatic int evict_one_icplb(int cpu)\r\n{\r\nint i = first_switched_icplb + icplb_rr_index[cpu];\r\nif (i >= MAX_CPLBS) {\r\ni -= MAX_CPLBS - first_switched_icplb;\r\nicplb_rr_index[cpu] -= MAX_CPLBS - first_switched_icplb;\r\n}\r\nicplb_rr_index[cpu]++;\r\nreturn i;\r\n}\r\nstatic int evict_one_dcplb(int cpu)\r\n{\r\nint i = first_switched_dcplb + dcplb_rr_index[cpu];\r\nif (i >= MAX_CPLBS) {\r\ni -= MAX_CPLBS - first_switched_dcplb;\r\ndcplb_rr_index[cpu] -= MAX_CPLBS - first_switched_dcplb;\r\n}\r\ndcplb_rr_index[cpu]++;\r\nreturn i;\r\n}\r\nMGR_ATTR static int icplb_miss(int cpu)\r\n{\r\nunsigned long addr = bfin_read_ICPLB_FAULT_ADDR();\r\nint status = bfin_read_ICPLB_STATUS();\r\nint idx;\r\nunsigned long i_data, base, addr1, eaddr;\r\nnr_icplb_miss[cpu]++;\r\nif (unlikely(status & FAULT_USERSUPV))\r\nnr_icplb_supv_miss[cpu]++;\r\nbase = 0;\r\nidx = 0;\r\ndo {\r\neaddr = icplb_bounds[idx].eaddr;\r\nif (addr < eaddr)\r\nbreak;\r\nbase = eaddr;\r\n} while (++idx < icplb_nr_bounds);\r\nif (unlikely(idx == icplb_nr_bounds))\r\nreturn CPLB_NO_ADDR_MATCH;\r\ni_data = icplb_bounds[idx].data;\r\nif (unlikely(i_data == 0))\r\nreturn CPLB_NO_ADDR_MATCH;\r\naddr1 = addr & ~(SIZE_4M - 1);\r\naddr &= ~(SIZE_1M - 1);\r\ni_data |= PAGE_SIZE_1MB;\r\nif (addr1 >= base && (addr1 + SIZE_4M) <= eaddr) {\r\ni_data |= PAGE_SIZE_4MB;\r\naddr = addr1;\r\n}\r\nidx = evict_one_icplb(cpu);\r\nwrite_icplb_data(cpu, idx, i_data, addr);\r\nreturn CPLB_RELOADED;\r\n}\r\nMGR_ATTR static int dcplb_miss(int cpu)\r\n{\r\nunsigned long addr = bfin_read_DCPLB_FAULT_ADDR();\r\nint status = bfin_read_DCPLB_STATUS();\r\nint idx;\r\nunsigned long d_data, base, addr1, eaddr, cplb_pagesize, cplb_pageflags;\r\nnr_dcplb_miss[cpu]++;\r\nif (unlikely(status & FAULT_USERSUPV))\r\nnr_dcplb_supv_miss[cpu]++;\r\nbase = 0;\r\nidx = 0;\r\ndo {\r\neaddr = dcplb_bounds[idx].eaddr;\r\nif (addr < eaddr)\r\nbreak;\r\nbase = eaddr;\r\n} while (++idx < dcplb_nr_bounds);\r\nif (unlikely(idx == dcplb_nr_bounds))\r\nreturn CPLB_NO_ADDR_MATCH;\r\nd_data = dcplb_bounds[idx].data;\r\nif (unlikely(d_data == 0))\r\nreturn CPLB_NO_ADDR_MATCH;\r\naddr &= ~(SIZE_1M - 1);\r\nd_data |= PAGE_SIZE_1MB;\r\n#ifdef PAGE_SIZE_16MB\r\ncplb_pageflags = PAGE_SIZE_16MB;\r\ncplb_pagesize = SIZE_16M;\r\n#else\r\ncplb_pageflags = PAGE_SIZE_4MB;\r\ncplb_pagesize = SIZE_4M;\r\n#endif\r\nfind_pagesize:\r\naddr1 = addr & ~(cplb_pagesize - 1);\r\nif (addr1 >= base && (addr1 + cplb_pagesize) <= eaddr) {\r\nd_data |= cplb_pageflags;\r\naddr = addr1;\r\ngoto found_pagesize;\r\n} else {\r\nif (cplb_pagesize > SIZE_4M) {\r\ncplb_pageflags = PAGE_SIZE_4MB;\r\ncplb_pagesize = SIZE_4M;\r\ngoto find_pagesize;\r\n}\r\n}\r\nfound_pagesize:\r\n#ifdef CONFIG_BF60x\r\nif ((addr >= ASYNC_BANK0_BASE)\r\n&& (addr < ASYNC_BANK3_BASE + ASYNC_BANK3_SIZE))\r\nd_data |= PAGE_SIZE_64MB;\r\n#endif\r\nidx = evict_one_dcplb(cpu);\r\nwrite_dcplb_data(cpu, idx, d_data, addr);\r\nreturn CPLB_RELOADED;\r\n}\r\nMGR_ATTR int cplb_hdr(int seqstat, struct pt_regs *regs)\r\n{\r\nint cause = seqstat & 0x3f;\r\nunsigned int cpu = raw_smp_processor_id();\r\nswitch (cause) {\r\ncase VEC_CPLB_I_M:\r\nreturn icplb_miss(cpu);\r\ncase VEC_CPLB_M:\r\nreturn dcplb_miss(cpu);\r\ndefault:\r\nreturn CPLB_UNKNOWN_ERR;\r\n}\r\n}
