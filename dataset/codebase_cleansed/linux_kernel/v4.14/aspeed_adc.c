static int aspeed_adc_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct aspeed_adc_data *data = iio_priv(indio_dev);\r\nconst struct aspeed_adc_model_data *model_data =\r\nof_device_get_match_data(data->dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\n*val = readw(data->base + chan->address);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = model_data->vref_voltage;\r\n*val2 = ASPEED_RESOLUTION_BITS;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\n*val = clk_get_rate(data->clk_scaler->clk) /\r\nASPEED_CLOCKS_PER_SAMPLE;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int aspeed_adc_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct aspeed_adc_data *data = iio_priv(indio_dev);\r\nconst struct aspeed_adc_model_data *model_data =\r\nof_device_get_match_data(data->dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nif (val < model_data->min_sampling_rate ||\r\nval > model_data->max_sampling_rate)\r\nreturn -EINVAL;\r\nclk_set_rate(data->clk_scaler->clk,\r\nval * ASPEED_CLOCKS_PER_SAMPLE);\r\nreturn 0;\r\ncase IIO_CHAN_INFO_SCALE:\r\ncase IIO_CHAN_INFO_RAW:\r\nreturn -EPERM;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int aspeed_adc_reg_access(struct iio_dev *indio_dev,\r\nunsigned int reg, unsigned int writeval,\r\nunsigned int *readval)\r\n{\r\nstruct aspeed_adc_data *data = iio_priv(indio_dev);\r\nif (!readval || reg % 4 || reg > ASPEED_REG_MAX)\r\nreturn -EINVAL;\r\n*readval = readl(data->base + reg);\r\nreturn 0;\r\n}\r\nstatic int aspeed_adc_probe(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct aspeed_adc_data *data;\r\nconst struct aspeed_adc_model_data *model_data;\r\nstruct resource *res;\r\nconst char *clk_parent_name;\r\nint ret;\r\nu32 adc_engine_control_reg_val;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ndata->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndata->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(data->base))\r\nreturn PTR_ERR(data->base);\r\nspin_lock_init(&data->clk_lock);\r\nclk_parent_name = of_clk_get_parent_name(pdev->dev.of_node, 0);\r\ndata->clk_prescaler = clk_hw_register_divider(\r\n&pdev->dev, "prescaler", clk_parent_name, 0,\r\ndata->base + ASPEED_REG_CLOCK_CONTROL,\r\n17, 15, 0, &data->clk_lock);\r\nif (IS_ERR(data->clk_prescaler))\r\nreturn PTR_ERR(data->clk_prescaler);\r\ndata->clk_scaler = clk_hw_register_divider(\r\n&pdev->dev, "scaler", "prescaler",\r\nCLK_SET_RATE_PARENT,\r\ndata->base + ASPEED_REG_CLOCK_CONTROL,\r\n0, 10, 0, &data->clk_lock);\r\nif (IS_ERR(data->clk_scaler)) {\r\nret = PTR_ERR(data->clk_scaler);\r\ngoto scaler_error;\r\n}\r\nmodel_data = of_device_get_match_data(&pdev->dev);\r\nif (model_data->wait_init_sequence) {\r\nwritel(ASPEED_OPERATION_MODE_NORMAL | ASPEED_ENGINE_ENABLE,\r\ndata->base + ASPEED_REG_ENGINE_CONTROL);\r\nret = readl_poll_timeout(data->base + ASPEED_REG_ENGINE_CONTROL,\r\nadc_engine_control_reg_val,\r\nadc_engine_control_reg_val &\r\nASPEED_ADC_CTRL_INIT_RDY,\r\nASPEED_ADC_INIT_POLLING_TIME,\r\nASPEED_ADC_INIT_TIMEOUT);\r\nif (ret)\r\ngoto scaler_error;\r\n}\r\nret = clk_prepare_enable(data->clk_scaler->clk);\r\nif (ret)\r\ngoto clk_enable_error;\r\nadc_engine_control_reg_val = GENMASK(31, 16) |\r\nASPEED_OPERATION_MODE_NORMAL | ASPEED_ENGINE_ENABLE;\r\nwritel(adc_engine_control_reg_val,\r\ndata->base + ASPEED_REG_ENGINE_CONTROL);\r\nmodel_data = of_device_get_match_data(&pdev->dev);\r\nindio_dev->name = model_data->model_name;\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->info = &aspeed_adc_iio_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = aspeed_adc_iio_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(aspeed_adc_iio_channels);\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto iio_register_error;\r\nreturn 0;\r\niio_register_error:\r\nwritel(ASPEED_OPERATION_MODE_POWER_DOWN,\r\ndata->base + ASPEED_REG_ENGINE_CONTROL);\r\nclk_disable_unprepare(data->clk_scaler->clk);\r\nclk_enable_error:\r\nclk_hw_unregister_divider(data->clk_scaler);\r\nscaler_error:\r\nclk_hw_unregister_divider(data->clk_prescaler);\r\nreturn ret;\r\n}\r\nstatic int aspeed_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct aspeed_adc_data *data = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nwritel(ASPEED_OPERATION_MODE_POWER_DOWN,\r\ndata->base + ASPEED_REG_ENGINE_CONTROL);\r\nclk_disable_unprepare(data->clk_scaler->clk);\r\nclk_hw_unregister_divider(data->clk_scaler);\r\nclk_hw_unregister_divider(data->clk_prescaler);\r\nreturn 0;\r\n}
