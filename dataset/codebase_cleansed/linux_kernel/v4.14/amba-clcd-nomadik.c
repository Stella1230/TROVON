static u8 tpg110_readwrite_reg(bool write, u8 address, u8 outval)\r\n{\r\nint i;\r\nu8 inval = 0;\r\ngpiod_set_value_cansleep(scen, 1);\r\nndelay(150);\r\nfor (i = 5; i >= 0; i--) {\r\nif (address & BIT(i))\r\ngpiod_set_value_cansleep(sda, 1);\r\nelse\r\ngpiod_set_value_cansleep(sda, 0);\r\nndelay(150);\r\ngpiod_set_value_cansleep(scl, 1);\r\nndelay(160);\r\ngpiod_set_value_cansleep(scl, 0);\r\nndelay(160);\r\n}\r\nif (write) {\r\ngpiod_set_value_cansleep(sda, 0);\r\n} else {\r\ngpiod_set_value_cansleep(sda, 1);\r\n}\r\nndelay(150);\r\ngpiod_set_value_cansleep(scl, 1);\r\nndelay(160);\r\ngpiod_set_value_cansleep(scl, 0);\r\nndelay(160);\r\nif (!write)\r\ngpiod_direction_input(sda);\r\nndelay(150);\r\ngpiod_set_value_cansleep(scl, 1);\r\nndelay(160);\r\ngpiod_set_value_cansleep(scl, 0);\r\nndelay(160);\r\nfor (i = 7; i >= 0; i--) {\r\nint value;\r\nif (write) {\r\nvalue = !!(outval & BIT(i));\r\ngpiod_set_value_cansleep(sda, value);\r\n} else {\r\nvalue = gpiod_get_value(sda);\r\nif (value)\r\ninval |= BIT(i);\r\n}\r\nndelay(150);\r\ngpiod_set_value_cansleep(scl, 1);\r\nndelay(160);\r\ngpiod_set_value_cansleep(scl, 0);\r\nndelay(160);\r\n}\r\ngpiod_direction_output(sda, 0);\r\ngpiod_set_value_cansleep(scen, 0);\r\nudelay(1);\r\nreturn inval;\r\n}\r\nstatic u8 tpg110_read_reg(u8 address)\r\n{\r\nreturn tpg110_readwrite_reg(false, address, 0);\r\n}\r\nstatic void tpg110_write_reg(u8 address, u8 outval)\r\n{\r\ntpg110_readwrite_reg(true, address, outval);\r\n}\r\nstatic void tpg110_startup(struct device *dev)\r\n{\r\nu8 val;\r\ndev_info(dev, "TPG110 display enable\n");\r\ngpiod_set_value_cansleep(grestb, 0);\r\nmdelay(1);\r\ndev_info(dev, "de-asserted GRESTB\n");\r\ntpg110_write_reg(0x00, 0x55);\r\nval = tpg110_read_reg(0x00);\r\nif (val == 0x55)\r\ndev_info(dev, "passed communication test\n");\r\nval = tpg110_read_reg(0x01);\r\ndev_info(dev, "TPG110 chip ID: %d version: %d\n",\r\nval>>4, val&0x0f);\r\nval = tpg110_read_reg(0x02);\r\nval &= 7;\r\nswitch (val) {\r\ncase 0x0:\r\ndev_info(dev, "IN 400x240 RGB -> OUT 800x480 RGB (dual scan)");\r\nbreak;\r\ncase 0x1:\r\ndev_info(dev, "IN 480x272 RGB -> OUT 800x480 RGB (dual scan)");\r\nbreak;\r\ncase 0x4:\r\ndev_info(dev, "480x640 RGB");\r\nbreak;\r\ncase 0x5:\r\ndev_info(dev, "480x272 RGB");\r\nbreak;\r\ncase 0x6:\r\ndev_info(dev, "640x480 RGB");\r\nbreak;\r\ncase 0x7:\r\ndev_info(dev, "800x480 RGB");\r\nbreak;\r\ndefault:\r\ndev_info(dev, "ILLEGAL RESOLUTION");\r\nbreak;\r\n}\r\nval = tpg110_read_reg(0x03);\r\ndev_info(dev, "resolution is controlled by %s\n",\r\n(val & BIT(7)) ? "software" : "hardware");\r\n}\r\nstatic void tpg110_enable(struct clcd_fb *fb)\r\n{\r\nstruct device *dev = &fb->dev->dev;\r\nstatic bool startup;\r\nu8 val;\r\nif (!startup) {\r\ntpg110_startup(dev);\r\nstartup = true;\r\n}\r\nval = tpg110_read_reg(0x03);\r\nval |= BIT(0);\r\ntpg110_write_reg(0x03, val);\r\n}\r\nstatic void tpg110_disable(struct clcd_fb *fb)\r\n{\r\nu8 val;\r\ndev_info(&fb->dev->dev, "TPG110 display disable\n");\r\nval = tpg110_read_reg(0x03);\r\nval &= ~BIT(0);\r\ntpg110_write_reg(0x03, val);\r\n}\r\nstatic void tpg110_init(struct device *dev, struct device_node *np,\r\nstruct clcd_board *board)\r\n{\r\ndev_info(dev, "TPG110 display init\n");\r\ngrestb = devm_fwnode_get_gpiod_from_child(dev, "grestb", &np->fwnode,\r\nGPIOD_OUT_HIGH, "grestb");\r\nif (IS_ERR(grestb)) {\r\ndev_err(dev, "no GRESTB GPIO\n");\r\nreturn;\r\n}\r\nscen = devm_fwnode_get_gpiod_from_child(dev, "scen", &np->fwnode,\r\nGPIOD_OUT_LOW, "scen");\r\nif (IS_ERR(scen)) {\r\ndev_err(dev, "no SCEN GPIO\n");\r\nreturn;\r\n}\r\nscl = devm_fwnode_get_gpiod_from_child(dev, "scl", &np->fwnode,\r\nGPIOD_OUT_LOW, "scl");\r\nif (IS_ERR(scl)) {\r\ndev_err(dev, "no SCL GPIO\n");\r\nreturn;\r\n}\r\nsda = devm_fwnode_get_gpiod_from_child(dev, "sda", &np->fwnode,\r\nGPIOD_OUT_LOW, "sda");\r\nif (IS_ERR(sda)) {\r\ndev_err(dev, "no SDA GPIO\n");\r\nreturn;\r\n}\r\nboard->enable = tpg110_enable;\r\nboard->disable = tpg110_disable;\r\n}\r\nint nomadik_clcd_init_panel(struct clcd_fb *fb, struct device_node *panel)\r\n{\r\nif (of_device_is_compatible(panel, "tpo,tpg110"))\r\ntpg110_init(&fb->dev->dev, panel, fb->board);\r\nelse\r\ndev_info(&fb->dev->dev, "unknown panel\n");\r\nreturn 0;\r\n}\r\nint nomadik_clcd_init_board(struct amba_device *adev,\r\nstruct clcd_board *board)\r\n{\r\nstruct regmap *pmu_regmap;\r\ndev_info(&adev->dev, "Nomadik CLCD board init\n");\r\npmu_regmap =\r\nsyscon_regmap_lookup_by_compatible("stericsson,nomadik-pmu");\r\nif (IS_ERR(pmu_regmap)) {\r\ndev_err(&adev->dev, "could not find PMU syscon regmap\n");\r\nreturn PTR_ERR(pmu_regmap);\r\n}\r\nregmap_update_bits(pmu_regmap,\r\nPMU_CTRL_OFFSET,\r\nPMU_CTRL_LCDNDIF,\r\n0);\r\ndev_info(&adev->dev, "set PMU mux to CLCD mode\n");\r\nreturn 0;\r\n}
