static struct ide_tape_obj *ide_tape_get(struct gendisk *disk, bool cdev,\r\nunsigned int i)\r\n{\r\nstruct ide_tape_obj *tape = NULL;\r\nmutex_lock(&idetape_ref_mutex);\r\nif (cdev)\r\ntape = idetape_devs[i];\r\nelse\r\ntape = ide_drv_g(disk, ide_tape_obj);\r\nif (tape) {\r\nif (ide_device_get(tape->drive))\r\ntape = NULL;\r\nelse\r\nget_device(&tape->dev);\r\n}\r\nmutex_unlock(&idetape_ref_mutex);\r\nreturn tape;\r\n}\r\nstatic void ide_tape_put(struct ide_tape_obj *tape)\r\n{\r\nide_drive_t *drive = tape->drive;\r\nmutex_lock(&idetape_ref_mutex);\r\nput_device(&tape->dev);\r\nide_device_put(drive);\r\nmutex_unlock(&idetape_ref_mutex);\r\n}\r\nstatic void idetape_analyze_error(ide_drive_t *drive)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nstruct ide_atapi_pc *pc = drive->failed_pc;\r\nstruct request *rq = drive->hwif->rq;\r\nu8 *sense = bio_data(rq->bio);\r\ntape->sense_key = sense[2] & 0xF;\r\ntape->asc = sense[12];\r\ntape->ascq = sense[13];\r\nide_debug_log(IDE_DBG_FUNC,\r\n"cmd: 0x%x, sense key = %x, asc = %x, ascq = %x",\r\nrq->cmd[0], tape->sense_key, tape->asc, tape->ascq);\r\nif (pc->flags & PC_FLAG_DMA_ERROR)\r\nscsi_req(rq)->resid_len = tape->blk_size * get_unaligned_be32(&sense[3]);\r\nif ((pc->c[0] == READ_6 || pc->c[0] == WRITE_6)\r\n&& pc->c[4] == 0 && pc->c[3] == 0 && pc->c[2] == 0) {\r\nif (tape->sense_key == 5) {\r\npc->error = 0;\r\npc->flags |= PC_FLAG_ABORT;\r\n}\r\n}\r\nif (pc->c[0] == READ_6 && (sense[2] & 0x80)) {\r\npc->error = IDE_DRV_ERROR_FILEMARK;\r\npc->flags |= PC_FLAG_ABORT;\r\n}\r\nif (pc->c[0] == WRITE_6) {\r\nif ((sense[2] & 0x40) || (tape->sense_key == 0xd\r\n&& tape->asc == 0x0 && tape->ascq == 0x2)) {\r\npc->error = IDE_DRV_ERROR_EOD;\r\npc->flags |= PC_FLAG_ABORT;\r\n}\r\n}\r\nif (pc->c[0] == READ_6 || pc->c[0] == WRITE_6) {\r\nif (tape->sense_key == 8) {\r\npc->error = IDE_DRV_ERROR_EOD;\r\npc->flags |= PC_FLAG_ABORT;\r\n}\r\nif (!(pc->flags & PC_FLAG_ABORT) &&\r\n(blk_rq_bytes(rq) - scsi_req(rq)->resid_len))\r\npc->retries = IDETAPE_MAX_PC_RETRIES + 1;\r\n}\r\n}\r\nstatic int ide_tape_callback(ide_drive_t *drive, int dsc)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nstruct ide_atapi_pc *pc = drive->pc;\r\nstruct request *rq = drive->hwif->rq;\r\nint uptodate = pc->error ? 0 : 1;\r\nint err = uptodate ? 0 : IDE_DRV_ERROR_GENERAL;\r\nide_debug_log(IDE_DBG_FUNC, "cmd: 0x%x, dsc: %d, err: %d", rq->cmd[0],\r\ndsc, err);\r\nif (dsc)\r\nide_tape_handle_dsc(drive);\r\nif (drive->failed_pc == pc)\r\ndrive->failed_pc = NULL;\r\nif (pc->c[0] == REQUEST_SENSE) {\r\nif (uptodate)\r\nidetape_analyze_error(drive);\r\nelse\r\nprintk(KERN_ERR "ide-tape: Error in REQUEST SENSE "\r\n"itself - Aborting request!\n");\r\n} else if (pc->c[0] == READ_6 || pc->c[0] == WRITE_6) {\r\nunsigned int blocks =\r\n(blk_rq_bytes(rq) - scsi_req(rq)->resid_len) / tape->blk_size;\r\ntape->avg_size += blocks * tape->blk_size;\r\nif (time_after_eq(jiffies, tape->avg_time + HZ)) {\r\ntape->avg_speed = tape->avg_size * HZ /\r\n(jiffies - tape->avg_time) / 1024;\r\ntape->avg_size = 0;\r\ntape->avg_time = jiffies;\r\n}\r\ntape->first_frame += blocks;\r\nif (pc->error) {\r\nuptodate = 0;\r\nerr = pc->error;\r\n}\r\n}\r\nscsi_req(rq)->result = err;\r\nreturn uptodate;\r\n}\r\nstatic void ide_tape_stall_queue(ide_drive_t *drive)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nide_debug_log(IDE_DBG_FUNC, "cmd: 0x%x, dsc_poll_freq: %lu",\r\ndrive->hwif->rq->cmd[0], tape->dsc_poll_freq);\r\ntape->postponed_rq = true;\r\nide_stall_queue(drive, tape->dsc_poll_freq);\r\n}\r\nstatic void ide_tape_handle_dsc(ide_drive_t *drive)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\ntape->dsc_polling_start = jiffies;\r\ntape->dsc_poll_freq = IDETAPE_DSC_MA_FAST;\r\ntape->dsc_timeout = jiffies + IDETAPE_DSC_MA_TIMEOUT;\r\nide_tape_stall_queue(drive);\r\n}\r\nstatic ide_startstop_t ide_tape_issue_pc(ide_drive_t *drive,\r\nstruct ide_cmd *cmd,\r\nstruct ide_atapi_pc *pc)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nstruct request *rq = drive->hwif->rq;\r\nif (drive->failed_pc == NULL && pc->c[0] != REQUEST_SENSE)\r\ndrive->failed_pc = pc;\r\ndrive->pc = pc;\r\nif (pc->retries > IDETAPE_MAX_PC_RETRIES ||\r\n(pc->flags & PC_FLAG_ABORT)) {\r\nif (!(pc->flags & PC_FLAG_ABORT)) {\r\nif (!(pc->c[0] == TEST_UNIT_READY &&\r\ntape->sense_key == 2 && tape->asc == 4 &&\r\n(tape->ascq == 1 || tape->ascq == 8))) {\r\nprintk(KERN_ERR "ide-tape: %s: I/O error, "\r\n"pc = %2x, key = %2x, "\r\n"asc = %2x, ascq = %2x\n",\r\ntape->name, pc->c[0],\r\ntape->sense_key, tape->asc,\r\ntape->ascq);\r\n}\r\npc->error = IDE_DRV_ERROR_GENERAL;\r\n}\r\ndrive->failed_pc = NULL;\r\ndrive->pc_callback(drive, 0);\r\nide_complete_rq(drive, BLK_STS_IOERR, blk_rq_bytes(rq));\r\nreturn ide_stopped;\r\n}\r\nide_debug_log(IDE_DBG_SENSE, "retry #%d, cmd: 0x%02x", pc->retries,\r\npc->c[0]);\r\npc->retries++;\r\nreturn ide_issue_pc(drive, cmd);\r\n}\r\nstatic void idetape_create_mode_sense_cmd(struct ide_atapi_pc *pc, u8 page_code)\r\n{\r\nide_init_pc(pc);\r\npc->c[0] = MODE_SENSE;\r\nif (page_code != IDETAPE_BLOCK_DESCRIPTOR)\r\npc->c[1] = 8;\r\npc->c[2] = page_code;\r\npc->c[3] = 0;\r\npc->c[4] = 255;\r\nif (page_code == IDETAPE_BLOCK_DESCRIPTOR)\r\npc->req_xfer = 12;\r\nelse if (page_code == IDETAPE_CAPABILITIES_PAGE)\r\npc->req_xfer = 24;\r\nelse\r\npc->req_xfer = 50;\r\n}\r\nstatic ide_startstop_t idetape_media_access_finished(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nidetape_tape_t *tape = drive->driver_data;\r\nstruct ide_atapi_pc *pc = drive->pc;\r\nu8 stat;\r\nstat = hwif->tp_ops->read_status(hwif);\r\nif (stat & ATA_DSC) {\r\nif (stat & ATA_ERR) {\r\nif (pc->c[0] != TEST_UNIT_READY)\r\nprintk(KERN_ERR "ide-tape: %s: I/O error, ",\r\ntape->name);\r\nide_retry_pc(drive);\r\nreturn ide_stopped;\r\n}\r\npc->error = 0;\r\n} else {\r\npc->error = IDE_DRV_ERROR_GENERAL;\r\ndrive->failed_pc = NULL;\r\n}\r\ndrive->pc_callback(drive, 0);\r\nreturn ide_stopped;\r\n}\r\nstatic void ide_tape_create_rw_cmd(idetape_tape_t *tape,\r\nstruct ide_atapi_pc *pc, struct request *rq,\r\nu8 opcode)\r\n{\r\nunsigned int length = blk_rq_sectors(rq) / (tape->blk_size >> 9);\r\nide_init_pc(pc);\r\nput_unaligned(cpu_to_be32(length), (unsigned int *) &pc->c[1]);\r\npc->c[1] = 1;\r\nif (blk_rq_bytes(rq) == tape->buffer_size)\r\npc->flags |= PC_FLAG_DMA_OK;\r\nif (opcode == READ_6)\r\npc->c[0] = READ_6;\r\nelse if (opcode == WRITE_6) {\r\npc->c[0] = WRITE_6;\r\npc->flags |= PC_FLAG_WRITING;\r\n}\r\nmemcpy(scsi_req(rq)->cmd, pc->c, 12);\r\n}\r\nstatic ide_startstop_t idetape_do_request(ide_drive_t *drive,\r\nstruct request *rq, sector_t block)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nidetape_tape_t *tape = drive->driver_data;\r\nstruct ide_atapi_pc *pc = NULL;\r\nstruct ide_cmd cmd;\r\nstruct scsi_request *req = scsi_req(rq);\r\nu8 stat;\r\nide_debug_log(IDE_DBG_RQ, "cmd: 0x%x, sector: %llu, nr_sectors: %u",\r\nreq->cmd[0], (unsigned long long)blk_rq_pos(rq),\r\nblk_rq_sectors(rq));\r\nBUG_ON(!blk_rq_is_private(rq));\r\nBUG_ON(ide_req(rq)->type != ATA_PRIV_MISC &&\r\nide_req(rq)->type != ATA_PRIV_SENSE);\r\nif (drive->failed_pc && drive->pc->c[0] == REQUEST_SENSE) {\r\npc = drive->failed_pc;\r\ngoto out;\r\n}\r\nstat = hwif->tp_ops->read_status(hwif);\r\nif ((drive->dev_flags & IDE_DFLAG_DSC_OVERLAP) == 0 &&\r\n(req->cmd[13] & REQ_IDETAPE_PC2) == 0)\r\ndrive->atapi_flags |= IDE_AFLAG_IGNORE_DSC;\r\nif (drive->dev_flags & IDE_DFLAG_POST_RESET) {\r\ndrive->atapi_flags |= IDE_AFLAG_IGNORE_DSC;\r\ndrive->dev_flags &= ~IDE_DFLAG_POST_RESET;\r\n}\r\nif (!(drive->atapi_flags & IDE_AFLAG_IGNORE_DSC) &&\r\n!(stat & ATA_DSC)) {\r\nif (!tape->postponed_rq) {\r\ntape->dsc_polling_start = jiffies;\r\ntape->dsc_poll_freq = tape->best_dsc_rw_freq;\r\ntape->dsc_timeout = jiffies + IDETAPE_DSC_RW_TIMEOUT;\r\n} else if (time_after(jiffies, tape->dsc_timeout)) {\r\nprintk(KERN_ERR "ide-tape: %s: DSC timeout\n",\r\ntape->name);\r\nif (req->cmd[13] & REQ_IDETAPE_PC2) {\r\nidetape_media_access_finished(drive);\r\nreturn ide_stopped;\r\n} else {\r\nreturn ide_do_reset(drive);\r\n}\r\n} else if (time_after(jiffies,\r\ntape->dsc_polling_start +\r\nIDETAPE_DSC_MA_THRESHOLD))\r\ntape->dsc_poll_freq = IDETAPE_DSC_MA_SLOW;\r\nide_tape_stall_queue(drive);\r\nreturn ide_stopped;\r\n} else {\r\ndrive->atapi_flags &= ~IDE_AFLAG_IGNORE_DSC;\r\ntape->postponed_rq = false;\r\n}\r\nif (req->cmd[13] & REQ_IDETAPE_READ) {\r\npc = &tape->queued_pc;\r\nide_tape_create_rw_cmd(tape, pc, rq, READ_6);\r\ngoto out;\r\n}\r\nif (req->cmd[13] & REQ_IDETAPE_WRITE) {\r\npc = &tape->queued_pc;\r\nide_tape_create_rw_cmd(tape, pc, rq, WRITE_6);\r\ngoto out;\r\n}\r\nif (req->cmd[13] & REQ_IDETAPE_PC1) {\r\npc = (struct ide_atapi_pc *)rq->special;\r\nreq->cmd[13] &= ~(REQ_IDETAPE_PC1);\r\nreq->cmd[13] |= REQ_IDETAPE_PC2;\r\ngoto out;\r\n}\r\nif (req->cmd[13] & REQ_IDETAPE_PC2) {\r\nidetape_media_access_finished(drive);\r\nreturn ide_stopped;\r\n}\r\nBUG();\r\nout:\r\nide_prep_sense(drive, rq);\r\nmemset(&cmd, 0, sizeof(cmd));\r\nif (rq_data_dir(rq))\r\ncmd.tf_flags |= IDE_TFLAG_WRITE;\r\ncmd.rq = rq;\r\nide_init_sg_cmd(&cmd, blk_rq_bytes(rq));\r\nide_map_sg(drive, &cmd);\r\nreturn ide_tape_issue_pc(drive, &cmd, pc);\r\n}\r\nstatic void idetape_create_write_filemark_cmd(ide_drive_t *drive,\r\nstruct ide_atapi_pc *pc, int write_filemark)\r\n{\r\nide_init_pc(pc);\r\npc->c[0] = WRITE_FILEMARKS;\r\npc->c[4] = write_filemark;\r\npc->flags |= PC_FLAG_WAIT_FOR_DSC;\r\n}\r\nstatic int idetape_wait_ready(ide_drive_t *drive, unsigned long timeout)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nstruct gendisk *disk = tape->disk;\r\nint load_attempted = 0;\r\nset_bit(ilog2(IDE_AFLAG_MEDIUM_PRESENT), &drive->atapi_flags);\r\ntimeout += jiffies;\r\nwhile (time_before(jiffies, timeout)) {\r\nif (ide_do_test_unit_ready(drive, disk) == 0)\r\nreturn 0;\r\nif ((tape->sense_key == 2 && tape->asc == 4 && tape->ascq == 2)\r\n|| (tape->asc == 0x3A)) {\r\nif (load_attempted)\r\nreturn -ENOMEDIUM;\r\nide_do_start_stop(drive, disk, IDETAPE_LU_LOAD_MASK);\r\nload_attempted = 1;\r\n} else if (!(tape->sense_key == 2 && tape->asc == 4 &&\r\n(tape->ascq == 1 || tape->ascq == 8)))\r\nreturn -EIO;\r\nmsleep(100);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int idetape_flush_tape_buffers(ide_drive_t *drive)\r\n{\r\nstruct ide_tape_obj *tape = drive->driver_data;\r\nstruct ide_atapi_pc pc;\r\nint rc;\r\nidetape_create_write_filemark_cmd(drive, &pc, 0);\r\nrc = ide_queue_pc_tail(drive, tape->disk, &pc, NULL, 0);\r\nif (rc)\r\nreturn rc;\r\nidetape_wait_ready(drive, 60 * 5 * HZ);\r\nreturn 0;\r\n}\r\nstatic int ide_tape_read_position(ide_drive_t *drive)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nstruct ide_atapi_pc pc;\r\nu8 buf[20];\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nide_init_pc(&pc);\r\npc.c[0] = READ_POSITION;\r\npc.req_xfer = 20;\r\nif (ide_queue_pc_tail(drive, tape->disk, &pc, buf, pc.req_xfer))\r\nreturn -1;\r\nif (!pc.error) {\r\nide_debug_log(IDE_DBG_FUNC, "BOP - %s",\r\n(buf[0] & 0x80) ? "Yes" : "No");\r\nide_debug_log(IDE_DBG_FUNC, "EOP - %s",\r\n(buf[0] & 0x40) ? "Yes" : "No");\r\nif (buf[0] & 0x4) {\r\nprintk(KERN_INFO "ide-tape: Block location is unknown"\r\n"to the tape\n");\r\nclear_bit(ilog2(IDE_AFLAG_ADDRESS_VALID),\r\n&drive->atapi_flags);\r\nreturn -1;\r\n} else {\r\nide_debug_log(IDE_DBG_FUNC, "Block Location: %u",\r\nbe32_to_cpup((__be32 *)&buf[4]));\r\ntape->partition = buf[1];\r\ntape->first_frame = be32_to_cpup((__be32 *)&buf[4]);\r\nset_bit(ilog2(IDE_AFLAG_ADDRESS_VALID),\r\n&drive->atapi_flags);\r\n}\r\n}\r\nreturn tape->first_frame;\r\n}\r\nstatic void idetape_create_locate_cmd(ide_drive_t *drive,\r\nstruct ide_atapi_pc *pc,\r\nunsigned int block, u8 partition, int skip)\r\n{\r\nide_init_pc(pc);\r\npc->c[0] = POSITION_TO_ELEMENT;\r\npc->c[1] = 2;\r\nput_unaligned(cpu_to_be32(block), (unsigned int *) &pc->c[3]);\r\npc->c[8] = partition;\r\npc->flags |= PC_FLAG_WAIT_FOR_DSC;\r\n}\r\nstatic void __ide_tape_discard_merge_buffer(ide_drive_t *drive)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nif (tape->chrdev_dir != IDETAPE_DIR_READ)\r\nreturn;\r\nclear_bit(ilog2(IDE_AFLAG_FILEMARK), &drive->atapi_flags);\r\ntape->valid = 0;\r\nif (tape->buf != NULL) {\r\nkfree(tape->buf);\r\ntape->buf = NULL;\r\n}\r\ntape->chrdev_dir = IDETAPE_DIR_NONE;\r\n}\r\nstatic int idetape_position_tape(ide_drive_t *drive, unsigned int block,\r\nu8 partition, int skip)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nstruct gendisk *disk = tape->disk;\r\nint ret;\r\nstruct ide_atapi_pc pc;\r\nif (tape->chrdev_dir == IDETAPE_DIR_READ)\r\n__ide_tape_discard_merge_buffer(drive);\r\nidetape_wait_ready(drive, 60 * 5 * HZ);\r\nidetape_create_locate_cmd(drive, &pc, block, partition, skip);\r\nret = ide_queue_pc_tail(drive, disk, &pc, NULL, 0);\r\nif (ret)\r\nreturn ret;\r\nret = ide_tape_read_position(drive);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void ide_tape_discard_merge_buffer(ide_drive_t *drive,\r\nint restore_position)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nint seek, position;\r\n__ide_tape_discard_merge_buffer(drive);\r\nif (restore_position) {\r\nposition = ide_tape_read_position(drive);\r\nseek = position > 0 ? position : 0;\r\nif (idetape_position_tape(drive, seek, 0, 0)) {\r\nprintk(KERN_INFO "ide-tape: %s: position_tape failed in"\r\n" %s\n", tape->name, __func__);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int idetape_queue_rw_tail(ide_drive_t *drive, int cmd, int size)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nstruct request *rq;\r\nint ret;\r\nide_debug_log(IDE_DBG_FUNC, "cmd: 0x%x, size: %d", cmd, size);\r\nBUG_ON(cmd != REQ_IDETAPE_READ && cmd != REQ_IDETAPE_WRITE);\r\nBUG_ON(size < 0 || size % tape->blk_size);\r\nrq = blk_get_request(drive->queue, REQ_OP_DRV_IN, __GFP_RECLAIM);\r\nide_req(rq)->type = ATA_PRIV_MISC;\r\nscsi_req(rq)->cmd[13] = cmd;\r\nrq->rq_disk = tape->disk;\r\nrq->__sector = tape->first_frame;\r\nif (size) {\r\nret = blk_rq_map_kern(drive->queue, rq, tape->buf, size,\r\n__GFP_RECLAIM);\r\nif (ret)\r\ngoto out_put;\r\n}\r\nblk_execute_rq(drive->queue, tape->disk, rq, 0);\r\nsize -= scsi_req(rq)->resid_len;\r\ntape->cur = tape->buf;\r\nif (cmd == REQ_IDETAPE_READ)\r\ntape->valid = size;\r\nelse\r\ntape->valid = 0;\r\nret = size;\r\nif (scsi_req(rq)->result == IDE_DRV_ERROR_GENERAL)\r\nret = -EIO;\r\nout_put:\r\nblk_put_request(rq);\r\nreturn ret;\r\n}\r\nstatic void idetape_create_inquiry_cmd(struct ide_atapi_pc *pc)\r\n{\r\nide_init_pc(pc);\r\npc->c[0] = INQUIRY;\r\npc->c[4] = 254;\r\npc->req_xfer = 254;\r\n}\r\nstatic void idetape_create_rewind_cmd(ide_drive_t *drive,\r\nstruct ide_atapi_pc *pc)\r\n{\r\nide_init_pc(pc);\r\npc->c[0] = REZERO_UNIT;\r\npc->flags |= PC_FLAG_WAIT_FOR_DSC;\r\n}\r\nstatic void idetape_create_erase_cmd(struct ide_atapi_pc *pc)\r\n{\r\nide_init_pc(pc);\r\npc->c[0] = ERASE;\r\npc->c[1] = 1;\r\npc->flags |= PC_FLAG_WAIT_FOR_DSC;\r\n}\r\nstatic void idetape_create_space_cmd(struct ide_atapi_pc *pc, int count, u8 cmd)\r\n{\r\nide_init_pc(pc);\r\npc->c[0] = SPACE;\r\nput_unaligned(cpu_to_be32(count), (unsigned int *) &pc->c[1]);\r\npc->c[1] = cmd;\r\npc->flags |= PC_FLAG_WAIT_FOR_DSC;\r\n}\r\nstatic void ide_tape_flush_merge_buffer(ide_drive_t *drive)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nif (tape->chrdev_dir != IDETAPE_DIR_WRITE) {\r\nprintk(KERN_ERR "ide-tape: bug: Trying to empty merge buffer"\r\n" but we are not writing.\n");\r\nreturn;\r\n}\r\nif (tape->buf) {\r\nsize_t aligned = roundup(tape->valid, tape->blk_size);\r\nmemset(tape->cur, 0, aligned - tape->valid);\r\nidetape_queue_rw_tail(drive, REQ_IDETAPE_WRITE, aligned);\r\nkfree(tape->buf);\r\ntape->buf = NULL;\r\n}\r\ntape->chrdev_dir = IDETAPE_DIR_NONE;\r\n}\r\nstatic int idetape_init_rw(ide_drive_t *drive, int dir)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nint rc;\r\nBUG_ON(dir != IDETAPE_DIR_READ && dir != IDETAPE_DIR_WRITE);\r\nif (tape->chrdev_dir == dir)\r\nreturn 0;\r\nif (tape->chrdev_dir == IDETAPE_DIR_READ)\r\nide_tape_discard_merge_buffer(drive, 1);\r\nelse if (tape->chrdev_dir == IDETAPE_DIR_WRITE) {\r\nide_tape_flush_merge_buffer(drive);\r\nidetape_flush_tape_buffers(drive);\r\n}\r\nif (tape->buf || tape->valid) {\r\nprintk(KERN_ERR "ide-tape: valid should be 0 now\n");\r\ntape->valid = 0;\r\n}\r\ntape->buf = kmalloc(tape->buffer_size, GFP_KERNEL);\r\nif (!tape->buf)\r\nreturn -ENOMEM;\r\ntape->chrdev_dir = dir;\r\ntape->cur = tape->buf;\r\nif (drive->dev_flags & IDE_DFLAG_DSC_OVERLAP) {\r\nint cmd = dir == IDETAPE_DIR_READ ? REQ_IDETAPE_READ\r\n: REQ_IDETAPE_WRITE;\r\nrc = idetape_queue_rw_tail(drive, cmd, 0);\r\nif (rc < 0) {\r\nkfree(tape->buf);\r\ntape->buf = NULL;\r\ntape->chrdev_dir = IDETAPE_DIR_NONE;\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void idetape_pad_zeros(ide_drive_t *drive, int bcount)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nmemset(tape->buf, 0, tape->buffer_size);\r\nwhile (bcount) {\r\nunsigned int count = min(tape->buffer_size, bcount);\r\nidetape_queue_rw_tail(drive, REQ_IDETAPE_WRITE, count);\r\nbcount -= count;\r\n}\r\n}\r\nstatic int idetape_rewind_tape(ide_drive_t *drive)\r\n{\r\nstruct ide_tape_obj *tape = drive->driver_data;\r\nstruct gendisk *disk = tape->disk;\r\nstruct ide_atapi_pc pc;\r\nint ret;\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nidetape_create_rewind_cmd(drive, &pc);\r\nret = ide_queue_pc_tail(drive, disk, &pc, NULL, 0);\r\nif (ret)\r\nreturn ret;\r\nret = ide_tape_read_position(drive);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int idetape_blkdev_ioctl(ide_drive_t *drive, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nvoid __user *argp = (void __user *)arg;\r\nstruct idetape_config {\r\nint dsc_rw_frequency;\r\nint dsc_media_access_frequency;\r\nint nr_stages;\r\n} config;\r\nide_debug_log(IDE_DBG_FUNC, "cmd: 0x%04x", cmd);\r\nswitch (cmd) {\r\ncase 0x0340:\r\nif (copy_from_user(&config, argp, sizeof(config)))\r\nreturn -EFAULT;\r\ntape->best_dsc_rw_freq = config.dsc_rw_frequency;\r\nbreak;\r\ncase 0x0350:\r\nmemset(&config, 0, sizeof(config));\r\nconfig.dsc_rw_frequency = (int) tape->best_dsc_rw_freq;\r\nconfig.nr_stages = 1;\r\nif (copy_to_user(argp, &config, sizeof(config)))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int idetape_space_over_filemarks(ide_drive_t *drive, short mt_op,\r\nint mt_count)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nstruct gendisk *disk = tape->disk;\r\nstruct ide_atapi_pc pc;\r\nint retval, count = 0;\r\nint sprev = !!(tape->caps[4] & 0x20);\r\nide_debug_log(IDE_DBG_FUNC, "mt_op: %d, mt_count: %d", mt_op, mt_count);\r\nif (mt_count == 0)\r\nreturn 0;\r\nif (MTBSF == mt_op || MTBSFM == mt_op) {\r\nif (!sprev)\r\nreturn -EIO;\r\nmt_count = -mt_count;\r\n}\r\nif (tape->chrdev_dir == IDETAPE_DIR_READ) {\r\ntape->valid = 0;\r\nif (test_and_clear_bit(ilog2(IDE_AFLAG_FILEMARK),\r\n&drive->atapi_flags))\r\n++count;\r\nide_tape_discard_merge_buffer(drive, 0);\r\n}\r\nswitch (mt_op) {\r\ncase MTFSF:\r\ncase MTBSF:\r\nidetape_create_space_cmd(&pc, mt_count - count,\r\nIDETAPE_SPACE_OVER_FILEMARK);\r\nreturn ide_queue_pc_tail(drive, disk, &pc, NULL, 0);\r\ncase MTFSFM:\r\ncase MTBSFM:\r\nif (!sprev)\r\nreturn -EIO;\r\nretval = idetape_space_over_filemarks(drive, MTFSF,\r\nmt_count - count);\r\nif (retval)\r\nreturn retval;\r\ncount = (MTBSFM == mt_op ? 1 : -1);\r\nreturn idetape_space_over_filemarks(drive, MTFSF, count);\r\ndefault:\r\nprintk(KERN_ERR "ide-tape: MTIO operation %d not supported\n",\r\nmt_op);\r\nreturn -EIO;\r\n}\r\n}\r\nstatic ssize_t idetape_chrdev_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ide_tape_obj *tape = file->private_data;\r\nide_drive_t *drive = tape->drive;\r\nsize_t done = 0;\r\nssize_t ret = 0;\r\nint rc;\r\nide_debug_log(IDE_DBG_FUNC, "count %zd", count);\r\nif (tape->chrdev_dir != IDETAPE_DIR_READ) {\r\nif (test_bit(ilog2(IDE_AFLAG_DETECT_BS), &drive->atapi_flags))\r\nif (count > tape->blk_size &&\r\n(count % tape->blk_size) == 0)\r\ntape->user_bs_factor = count / tape->blk_size;\r\n}\r\nrc = idetape_init_rw(drive, IDETAPE_DIR_READ);\r\nif (rc < 0)\r\nreturn rc;\r\nwhile (done < count) {\r\nsize_t todo;\r\nif (!tape->valid) {\r\nif (test_bit(ilog2(IDE_AFLAG_FILEMARK),\r\n&drive->atapi_flags))\r\nbreak;\r\nif (idetape_queue_rw_tail(drive, REQ_IDETAPE_READ,\r\ntape->buffer_size) <= 0)\r\nbreak;\r\n}\r\ntodo = min_t(size_t, count - done, tape->valid);\r\nif (copy_to_user(buf + done, tape->cur, todo))\r\nret = -EFAULT;\r\ntape->cur += todo;\r\ntape->valid -= todo;\r\ndone += todo;\r\n}\r\nif (!done && test_bit(ilog2(IDE_AFLAG_FILEMARK), &drive->atapi_flags)) {\r\nidetape_space_over_filemarks(drive, MTFSF, 1);\r\nreturn 0;\r\n}\r\nreturn ret ? ret : done;\r\n}\r\nstatic ssize_t idetape_chrdev_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ide_tape_obj *tape = file->private_data;\r\nide_drive_t *drive = tape->drive;\r\nsize_t done = 0;\r\nssize_t ret = 0;\r\nint rc;\r\nif (tape->write_prot)\r\nreturn -EACCES;\r\nide_debug_log(IDE_DBG_FUNC, "count %zd", count);\r\nrc = idetape_init_rw(drive, IDETAPE_DIR_WRITE);\r\nif (rc < 0)\r\nreturn rc;\r\nwhile (done < count) {\r\nsize_t todo;\r\nif (tape->valid == tape->buffer_size &&\r\nidetape_queue_rw_tail(drive, REQ_IDETAPE_WRITE,\r\ntape->buffer_size) <= 0)\r\nreturn rc;\r\ntodo = min_t(size_t, count - done,\r\ntape->buffer_size - tape->valid);\r\nif (copy_from_user(tape->cur, buf + done, todo))\r\nret = -EFAULT;\r\ntape->cur += todo;\r\ntape->valid += todo;\r\ndone += todo;\r\n}\r\nreturn ret ? ret : done;\r\n}\r\nstatic int idetape_write_filemark(ide_drive_t *drive)\r\n{\r\nstruct ide_tape_obj *tape = drive->driver_data;\r\nstruct ide_atapi_pc pc;\r\nidetape_create_write_filemark_cmd(drive, &pc, 1);\r\nif (ide_queue_pc_tail(drive, tape->disk, &pc, NULL, 0)) {\r\nprintk(KERN_ERR "ide-tape: Couldn't write a filemark\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int idetape_mtioctop(ide_drive_t *drive, short mt_op, int mt_count)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nstruct gendisk *disk = tape->disk;\r\nstruct ide_atapi_pc pc;\r\nint i, retval;\r\nide_debug_log(IDE_DBG_FUNC, "MTIOCTOP ioctl: mt_op: %d, mt_count: %d",\r\nmt_op, mt_count);\r\nswitch (mt_op) {\r\ncase MTFSF:\r\ncase MTFSFM:\r\ncase MTBSF:\r\ncase MTBSFM:\r\nif (!mt_count)\r\nreturn 0;\r\nreturn idetape_space_over_filemarks(drive, mt_op, mt_count);\r\ndefault:\r\nbreak;\r\n}\r\nswitch (mt_op) {\r\ncase MTWEOF:\r\nif (tape->write_prot)\r\nreturn -EACCES;\r\nide_tape_discard_merge_buffer(drive, 1);\r\nfor (i = 0; i < mt_count; i++) {\r\nretval = idetape_write_filemark(drive);\r\nif (retval)\r\nreturn retval;\r\n}\r\nreturn 0;\r\ncase MTREW:\r\nide_tape_discard_merge_buffer(drive, 0);\r\nif (idetape_rewind_tape(drive))\r\nreturn -EIO;\r\nreturn 0;\r\ncase MTLOAD:\r\nide_tape_discard_merge_buffer(drive, 0);\r\nreturn ide_do_start_stop(drive, disk, IDETAPE_LU_LOAD_MASK);\r\ncase MTUNLOAD:\r\ncase MTOFFL:\r\nif (tape->door_locked) {\r\nif (!ide_set_media_lock(drive, disk, 0))\r\ntape->door_locked = DOOR_UNLOCKED;\r\n}\r\nide_tape_discard_merge_buffer(drive, 0);\r\nretval = ide_do_start_stop(drive, disk, !IDETAPE_LU_LOAD_MASK);\r\nif (!retval)\r\nclear_bit(ilog2(IDE_AFLAG_MEDIUM_PRESENT),\r\n&drive->atapi_flags);\r\nreturn retval;\r\ncase MTNOP:\r\nide_tape_discard_merge_buffer(drive, 0);\r\nreturn idetape_flush_tape_buffers(drive);\r\ncase MTRETEN:\r\nide_tape_discard_merge_buffer(drive, 0);\r\nreturn ide_do_start_stop(drive, disk,\r\nIDETAPE_LU_RETENSION_MASK | IDETAPE_LU_LOAD_MASK);\r\ncase MTEOM:\r\nidetape_create_space_cmd(&pc, 0, IDETAPE_SPACE_TO_EOD);\r\nreturn ide_queue_pc_tail(drive, disk, &pc, NULL, 0);\r\ncase MTERASE:\r\n(void)idetape_rewind_tape(drive);\r\nidetape_create_erase_cmd(&pc);\r\nreturn ide_queue_pc_tail(drive, disk, &pc, NULL, 0);\r\ncase MTSETBLK:\r\nif (mt_count) {\r\nif (mt_count < tape->blk_size ||\r\nmt_count % tape->blk_size)\r\nreturn -EIO;\r\ntape->user_bs_factor = mt_count / tape->blk_size;\r\nclear_bit(ilog2(IDE_AFLAG_DETECT_BS),\r\n&drive->atapi_flags);\r\n} else\r\nset_bit(ilog2(IDE_AFLAG_DETECT_BS),\r\n&drive->atapi_flags);\r\nreturn 0;\r\ncase MTSEEK:\r\nide_tape_discard_merge_buffer(drive, 0);\r\nreturn idetape_position_tape(drive,\r\nmt_count * tape->user_bs_factor, tape->partition, 0);\r\ncase MTSETPART:\r\nide_tape_discard_merge_buffer(drive, 0);\r\nreturn idetape_position_tape(drive, 0, mt_count, 0);\r\ncase MTFSR:\r\ncase MTBSR:\r\ncase MTLOCK:\r\nretval = ide_set_media_lock(drive, disk, 1);\r\nif (retval)\r\nreturn retval;\r\ntape->door_locked = DOOR_EXPLICITLY_LOCKED;\r\nreturn 0;\r\ncase MTUNLOCK:\r\nretval = ide_set_media_lock(drive, disk, 0);\r\nif (retval)\r\nreturn retval;\r\ntape->door_locked = DOOR_UNLOCKED;\r\nreturn 0;\r\ndefault:\r\nprintk(KERN_ERR "ide-tape: MTIO operation %d not supported\n",\r\nmt_op);\r\nreturn -EIO;\r\n}\r\n}\r\nstatic long do_idetape_chrdev_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct ide_tape_obj *tape = file->private_data;\r\nide_drive_t *drive = tape->drive;\r\nstruct mtop mtop;\r\nstruct mtget mtget;\r\nstruct mtpos mtpos;\r\nint block_offset = 0, position = tape->first_frame;\r\nvoid __user *argp = (void __user *)arg;\r\nide_debug_log(IDE_DBG_FUNC, "cmd: 0x%x", cmd);\r\nif (tape->chrdev_dir == IDETAPE_DIR_WRITE) {\r\nide_tape_flush_merge_buffer(drive);\r\nidetape_flush_tape_buffers(drive);\r\n}\r\nif (cmd == MTIOCGET || cmd == MTIOCPOS) {\r\nblock_offset = tape->valid /\r\n(tape->blk_size * tape->user_bs_factor);\r\nposition = ide_tape_read_position(drive);\r\nif (position < 0)\r\nreturn -EIO;\r\n}\r\nswitch (cmd) {\r\ncase MTIOCTOP:\r\nif (copy_from_user(&mtop, argp, sizeof(struct mtop)))\r\nreturn -EFAULT;\r\nreturn idetape_mtioctop(drive, mtop.mt_op, mtop.mt_count);\r\ncase MTIOCGET:\r\nmemset(&mtget, 0, sizeof(struct mtget));\r\nmtget.mt_type = MT_ISSCSI2;\r\nmtget.mt_blkno = position / tape->user_bs_factor - block_offset;\r\nmtget.mt_dsreg =\r\n((tape->blk_size * tape->user_bs_factor)\r\n<< MT_ST_BLKSIZE_SHIFT) & MT_ST_BLKSIZE_MASK;\r\nif (tape->drv_write_prot)\r\nmtget.mt_gstat |= GMT_WR_PROT(0xffffffff);\r\nif (copy_to_user(argp, &mtget, sizeof(struct mtget)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase MTIOCPOS:\r\nmtpos.mt_blkno = position / tape->user_bs_factor - block_offset;\r\nif (copy_to_user(argp, &mtpos, sizeof(struct mtpos)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ndefault:\r\nif (tape->chrdev_dir == IDETAPE_DIR_READ)\r\nide_tape_discard_merge_buffer(drive, 1);\r\nreturn idetape_blkdev_ioctl(drive, cmd, arg);\r\n}\r\n}\r\nstatic long idetape_chrdev_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nlong ret;\r\nmutex_lock(&ide_tape_mutex);\r\nret = do_idetape_chrdev_ioctl(file, cmd, arg);\r\nmutex_unlock(&ide_tape_mutex);\r\nreturn ret;\r\n}\r\nstatic void ide_tape_get_bsize_from_bdesc(ide_drive_t *drive)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nstruct ide_atapi_pc pc;\r\nu8 buf[12];\r\nidetape_create_mode_sense_cmd(&pc, IDETAPE_BLOCK_DESCRIPTOR);\r\nif (ide_queue_pc_tail(drive, tape->disk, &pc, buf, pc.req_xfer)) {\r\nprintk(KERN_ERR "ide-tape: Can't get block descriptor\n");\r\nif (tape->blk_size == 0) {\r\nprintk(KERN_WARNING "ide-tape: Cannot deal with zero "\r\n"block size, assuming 32k\n");\r\ntape->blk_size = 32768;\r\n}\r\nreturn;\r\n}\r\ntape->blk_size = (buf[4 + 5] << 16) +\r\n(buf[4 + 6] << 8) +\r\nbuf[4 + 7];\r\ntape->drv_write_prot = (buf[2] & 0x80) >> 7;\r\nide_debug_log(IDE_DBG_FUNC, "blk_size: %d, write_prot: %d",\r\ntape->blk_size, tape->drv_write_prot);\r\n}\r\nstatic int idetape_chrdev_open(struct inode *inode, struct file *filp)\r\n{\r\nunsigned int minor = iminor(inode), i = minor & ~0xc0;\r\nide_drive_t *drive;\r\nidetape_tape_t *tape;\r\nint retval;\r\nif (i >= MAX_HWIFS * MAX_DRIVES)\r\nreturn -ENXIO;\r\nmutex_lock(&idetape_chrdev_mutex);\r\ntape = ide_tape_get(NULL, true, i);\r\nif (!tape) {\r\nmutex_unlock(&idetape_chrdev_mutex);\r\nreturn -ENXIO;\r\n}\r\ndrive = tape->drive;\r\nfilp->private_data = tape;\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nfilp->f_mode &= ~(FMODE_PREAD | FMODE_PWRITE);\r\nif (test_and_set_bit(ilog2(IDE_AFLAG_BUSY), &drive->atapi_flags)) {\r\nretval = -EBUSY;\r\ngoto out_put_tape;\r\n}\r\nretval = idetape_wait_ready(drive, 60 * HZ);\r\nif (retval) {\r\nclear_bit(ilog2(IDE_AFLAG_BUSY), &drive->atapi_flags);\r\nprintk(KERN_ERR "ide-tape: %s: drive not ready\n", tape->name);\r\ngoto out_put_tape;\r\n}\r\nide_tape_read_position(drive);\r\nif (!test_bit(ilog2(IDE_AFLAG_ADDRESS_VALID), &drive->atapi_flags))\r\n(void)idetape_rewind_tape(drive);\r\nide_tape_get_bsize_from_bdesc(drive);\r\nif ((filp->f_flags & O_ACCMODE) == O_RDONLY)\r\ntape->write_prot = 1;\r\nelse\r\ntape->write_prot = tape->drv_write_prot;\r\nif (tape->write_prot) {\r\nif ((filp->f_flags & O_ACCMODE) == O_WRONLY ||\r\n(filp->f_flags & O_ACCMODE) == O_RDWR) {\r\nclear_bit(ilog2(IDE_AFLAG_BUSY), &drive->atapi_flags);\r\nretval = -EROFS;\r\ngoto out_put_tape;\r\n}\r\n}\r\nif (tape->chrdev_dir == IDETAPE_DIR_NONE) {\r\nif (!ide_set_media_lock(drive, tape->disk, 1)) {\r\nif (tape->door_locked != DOOR_EXPLICITLY_LOCKED)\r\ntape->door_locked = DOOR_LOCKED;\r\n}\r\n}\r\nmutex_unlock(&idetape_chrdev_mutex);\r\nreturn 0;\r\nout_put_tape:\r\nide_tape_put(tape);\r\nmutex_unlock(&idetape_chrdev_mutex);\r\nreturn retval;\r\n}\r\nstatic void idetape_write_release(ide_drive_t *drive, unsigned int minor)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nide_tape_flush_merge_buffer(drive);\r\ntape->buf = kmalloc(tape->buffer_size, GFP_KERNEL);\r\nif (tape->buf != NULL) {\r\nidetape_pad_zeros(drive, tape->blk_size *\r\n(tape->user_bs_factor - 1));\r\nkfree(tape->buf);\r\ntape->buf = NULL;\r\n}\r\nidetape_write_filemark(drive);\r\nidetape_flush_tape_buffers(drive);\r\nidetape_flush_tape_buffers(drive);\r\n}\r\nstatic int idetape_chrdev_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct ide_tape_obj *tape = filp->private_data;\r\nide_drive_t *drive = tape->drive;\r\nunsigned int minor = iminor(inode);\r\nmutex_lock(&idetape_chrdev_mutex);\r\ntape = drive->driver_data;\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nif (tape->chrdev_dir == IDETAPE_DIR_WRITE)\r\nidetape_write_release(drive, minor);\r\nif (tape->chrdev_dir == IDETAPE_DIR_READ) {\r\nif (minor < 128)\r\nide_tape_discard_merge_buffer(drive, 1);\r\n}\r\nif (minor < 128 && test_bit(ilog2(IDE_AFLAG_MEDIUM_PRESENT),\r\n&drive->atapi_flags))\r\n(void) idetape_rewind_tape(drive);\r\nif (tape->chrdev_dir == IDETAPE_DIR_NONE) {\r\nif (tape->door_locked == DOOR_LOCKED) {\r\nif (!ide_set_media_lock(drive, tape->disk, 0))\r\ntape->door_locked = DOOR_UNLOCKED;\r\n}\r\n}\r\nclear_bit(ilog2(IDE_AFLAG_BUSY), &drive->atapi_flags);\r\nide_tape_put(tape);\r\nmutex_unlock(&idetape_chrdev_mutex);\r\nreturn 0;\r\n}\r\nstatic void idetape_get_inquiry_results(ide_drive_t *drive)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nstruct ide_atapi_pc pc;\r\nu8 pc_buf[256];\r\nchar fw_rev[4], vendor_id[8], product_id[16];\r\nidetape_create_inquiry_cmd(&pc);\r\nif (ide_queue_pc_tail(drive, tape->disk, &pc, pc_buf, pc.req_xfer)) {\r\nprintk(KERN_ERR "ide-tape: %s: can't get INQUIRY results\n",\r\ntape->name);\r\nreturn;\r\n}\r\nmemcpy(vendor_id, &pc_buf[8], 8);\r\nmemcpy(product_id, &pc_buf[16], 16);\r\nmemcpy(fw_rev, &pc_buf[32], 4);\r\nide_fixstring(vendor_id, 8, 0);\r\nide_fixstring(product_id, 16, 0);\r\nide_fixstring(fw_rev, 4, 0);\r\nprintk(KERN_INFO "ide-tape: %s <-> %s: %.8s %.16s rev %.4s\n",\r\ndrive->name, tape->name, vendor_id, product_id, fw_rev);\r\n}\r\nstatic void idetape_get_mode_sense_results(ide_drive_t *drive)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nstruct ide_atapi_pc pc;\r\nu8 buf[24], *caps;\r\nu8 speed, max_speed;\r\nidetape_create_mode_sense_cmd(&pc, IDETAPE_CAPABILITIES_PAGE);\r\nif (ide_queue_pc_tail(drive, tape->disk, &pc, buf, pc.req_xfer)) {\r\nprintk(KERN_ERR "ide-tape: Can't get tape parameters - assuming"\r\n" some default values\n");\r\ntape->blk_size = 512;\r\nput_unaligned(52, (u16 *)&tape->caps[12]);\r\nput_unaligned(540, (u16 *)&tape->caps[14]);\r\nput_unaligned(6*52, (u16 *)&tape->caps[16]);\r\nreturn;\r\n}\r\ncaps = buf + 4 + buf[3];\r\nspeed = be16_to_cpup((__be16 *)&caps[14]);\r\nmax_speed = be16_to_cpup((__be16 *)&caps[8]);\r\n*(u16 *)&caps[8] = max_speed;\r\n*(u16 *)&caps[12] = be16_to_cpup((__be16 *)&caps[12]);\r\n*(u16 *)&caps[14] = speed;\r\n*(u16 *)&caps[16] = be16_to_cpup((__be16 *)&caps[16]);\r\nif (!speed) {\r\nprintk(KERN_INFO "ide-tape: %s: invalid tape speed "\r\n"(assuming 650KB/sec)\n", drive->name);\r\n*(u16 *)&caps[14] = 650;\r\n}\r\nif (!max_speed) {\r\nprintk(KERN_INFO "ide-tape: %s: invalid max_speed "\r\n"(assuming 650KB/sec)\n", drive->name);\r\n*(u16 *)&caps[8] = 650;\r\n}\r\nmemcpy(&tape->caps, caps, 20);\r\nif ((caps[6] & 1) == 0)\r\ndrive->dev_flags &= ~IDE_DFLAG_DOORLOCKING;\r\nif (caps[7] & 0x02)\r\ntape->blk_size = 512;\r\nelse if (caps[7] & 0x04)\r\ntape->blk_size = 1024;\r\n}\r\nstatic int mulf_tdsc(ide_drive_t *drive) { return 1000; }\r\nstatic int divf_tdsc(ide_drive_t *drive) { return HZ; }\r\nstatic int divf_buffer(ide_drive_t *drive) { return 2; }\r\nstatic int divf_buffer_size(ide_drive_t *drive) { return 1024; }\r\nstatic void idetape_setup(ide_drive_t *drive, idetape_tape_t *tape, int minor)\r\n{\r\nunsigned long t;\r\nint speed;\r\nint buffer_size;\r\nu16 *ctl = (u16 *)&tape->caps[12];\r\nide_debug_log(IDE_DBG_FUNC, "minor: %d", minor);\r\ndrive->pc_callback = ide_tape_callback;\r\ndrive->dev_flags |= IDE_DFLAG_DSC_OVERLAP;\r\nif (drive->hwif->host_flags & IDE_HFLAG_NO_DSC) {\r\nprintk(KERN_INFO "ide-tape: %s: disabling DSC overlap\n",\r\ntape->name);\r\ndrive->dev_flags &= ~IDE_DFLAG_DSC_OVERLAP;\r\n}\r\nif (strstr((char *)&drive->id[ATA_ID_PROD], "Seagate STT3401"))\r\ndrive->dev_flags &= ~IDE_DFLAG_DSC_OVERLAP;\r\ntape->minor = minor;\r\ntape->name[0] = 'h';\r\ntape->name[1] = 't';\r\ntape->name[2] = '0' + minor;\r\ntape->chrdev_dir = IDETAPE_DIR_NONE;\r\nidetape_get_inquiry_results(drive);\r\nidetape_get_mode_sense_results(drive);\r\nide_tape_get_bsize_from_bdesc(drive);\r\ntape->user_bs_factor = 1;\r\ntape->buffer_size = *ctl * tape->blk_size;\r\nwhile (tape->buffer_size > 0xffff) {\r\nprintk(KERN_NOTICE "ide-tape: decreasing stage size\n");\r\n*ctl /= 2;\r\ntape->buffer_size = *ctl * tape->blk_size;\r\n}\r\nbuffer_size = tape->buffer_size;\r\nspeed = max(*(u16 *)&tape->caps[14], *(u16 *)&tape->caps[8]);\r\nt = (IDETAPE_FIFO_THRESHOLD * tape->buffer_size * HZ) / (speed * 1000);\r\ntape->best_dsc_rw_freq = clamp_t(unsigned long, t, IDETAPE_DSC_RW_MIN,\r\nIDETAPE_DSC_RW_MAX);\r\nprintk(KERN_INFO "ide-tape: %s <-> %s: %dKBps, %d*%dkB buffer, "\r\n"%ums tDSC%s\n",\r\ndrive->name, tape->name, *(u16 *)&tape->caps[14],\r\n(*(u16 *)&tape->caps[16] * 512) / tape->buffer_size,\r\ntape->buffer_size / 1024,\r\njiffies_to_msecs(tape->best_dsc_rw_freq),\r\n(drive->dev_flags & IDE_DFLAG_USING_DMA) ? ", DMA" : "");\r\nide_proc_register_driver(drive, tape->driver);\r\n}\r\nstatic void ide_tape_remove(ide_drive_t *drive)\r\n{\r\nidetape_tape_t *tape = drive->driver_data;\r\nide_proc_unregister_driver(drive, tape->driver);\r\ndevice_del(&tape->dev);\r\nide_unregister_region(tape->disk);\r\nmutex_lock(&idetape_ref_mutex);\r\nput_device(&tape->dev);\r\nmutex_unlock(&idetape_ref_mutex);\r\n}\r\nstatic void ide_tape_release(struct device *dev)\r\n{\r\nstruct ide_tape_obj *tape = to_ide_drv(dev, ide_tape_obj);\r\nide_drive_t *drive = tape->drive;\r\nstruct gendisk *g = tape->disk;\r\nBUG_ON(tape->valid);\r\ndrive->dev_flags &= ~IDE_DFLAG_DSC_OVERLAP;\r\ndrive->driver_data = NULL;\r\ndevice_destroy(idetape_sysfs_class, MKDEV(IDETAPE_MAJOR, tape->minor));\r\ndevice_destroy(idetape_sysfs_class,\r\nMKDEV(IDETAPE_MAJOR, tape->minor + 128));\r\nidetape_devs[tape->minor] = NULL;\r\ng->private_data = NULL;\r\nput_disk(g);\r\nkfree(tape);\r\n}\r\nstatic int idetape_name_proc_show(struct seq_file *m, void *v)\r\n{\r\nide_drive_t *drive = (ide_drive_t *) m->private;\r\nidetape_tape_t *tape = drive->driver_data;\r\nseq_printf(m, "%s\n", tape->name);\r\nreturn 0;\r\n}\r\nstatic int idetape_name_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, idetape_name_proc_show, PDE_DATA(inode));\r\n}\r\nstatic ide_proc_entry_t *ide_tape_proc_entries(ide_drive_t *drive)\r\n{\r\nreturn idetape_proc;\r\n}\r\nstatic const struct ide_proc_devset *ide_tape_proc_devsets(ide_drive_t *drive)\r\n{\r\nreturn idetape_settings;\r\n}\r\nstatic int idetape_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct ide_tape_obj *tape;\r\nmutex_lock(&ide_tape_mutex);\r\ntape = ide_tape_get(bdev->bd_disk, false, 0);\r\nmutex_unlock(&ide_tape_mutex);\r\nif (!tape)\r\nreturn -ENXIO;\r\nreturn 0;\r\n}\r\nstatic void idetape_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct ide_tape_obj *tape = ide_drv_g(disk, ide_tape_obj);\r\nmutex_lock(&ide_tape_mutex);\r\nide_tape_put(tape);\r\nmutex_unlock(&ide_tape_mutex);\r\n}\r\nstatic int idetape_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct ide_tape_obj *tape = ide_drv_g(bdev->bd_disk, ide_tape_obj);\r\nide_drive_t *drive = tape->drive;\r\nint err;\r\nmutex_lock(&ide_tape_mutex);\r\nerr = generic_ide_ioctl(drive, bdev, cmd, arg);\r\nif (err == -EINVAL)\r\nerr = idetape_blkdev_ioctl(drive, cmd, arg);\r\nmutex_unlock(&ide_tape_mutex);\r\nreturn err;\r\n}\r\nstatic int ide_tape_probe(ide_drive_t *drive)\r\n{\r\nidetape_tape_t *tape;\r\nstruct gendisk *g;\r\nint minor;\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nif (!strstr(DRV_NAME, drive->driver_req))\r\ngoto failed;\r\nif (drive->media != ide_tape)\r\ngoto failed;\r\nif ((drive->dev_flags & IDE_DFLAG_ID_READ) &&\r\nide_check_atapi_device(drive, DRV_NAME) == 0) {\r\nprintk(KERN_ERR "ide-tape: %s: not supported by this version of"\r\n" the driver\n", drive->name);\r\ngoto failed;\r\n}\r\ntape = kzalloc(sizeof(idetape_tape_t), GFP_KERNEL);\r\nif (tape == NULL) {\r\nprintk(KERN_ERR "ide-tape: %s: Can't allocate a tape struct\n",\r\ndrive->name);\r\ngoto failed;\r\n}\r\ng = alloc_disk(1 << PARTN_BITS);\r\nif (!g)\r\ngoto out_free_tape;\r\nide_init_disk(g, drive);\r\ntape->dev.parent = &drive->gendev;\r\ntape->dev.release = ide_tape_release;\r\ndev_set_name(&tape->dev, "%s", dev_name(&drive->gendev));\r\nif (device_register(&tape->dev))\r\ngoto out_free_disk;\r\ntape->drive = drive;\r\ntape->driver = &idetape_driver;\r\ntape->disk = g;\r\ng->private_data = &tape->driver;\r\ndrive->driver_data = tape;\r\nmutex_lock(&idetape_ref_mutex);\r\nfor (minor = 0; idetape_devs[minor]; minor++)\r\n;\r\nidetape_devs[minor] = tape;\r\nmutex_unlock(&idetape_ref_mutex);\r\nidetape_setup(drive, tape, minor);\r\ndevice_create(idetape_sysfs_class, &drive->gendev,\r\nMKDEV(IDETAPE_MAJOR, minor), NULL, "%s", tape->name);\r\ndevice_create(idetape_sysfs_class, &drive->gendev,\r\nMKDEV(IDETAPE_MAJOR, minor + 128), NULL,\r\n"n%s", tape->name);\r\ng->fops = &idetape_block_ops;\r\nide_register_region(g);\r\nreturn 0;\r\nout_free_disk:\r\nput_disk(g);\r\nout_free_tape:\r\nkfree(tape);\r\nfailed:\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit idetape_exit(void)\r\n{\r\ndriver_unregister(&idetape_driver.gen_driver);\r\nclass_destroy(idetape_sysfs_class);\r\nunregister_chrdev(IDETAPE_MAJOR, "ht");\r\n}\r\nstatic int __init idetape_init(void)\r\n{\r\nint error = 1;\r\nidetape_sysfs_class = class_create(THIS_MODULE, "ide_tape");\r\nif (IS_ERR(idetape_sysfs_class)) {\r\nidetape_sysfs_class = NULL;\r\nprintk(KERN_ERR "Unable to create sysfs class for ide tapes\n");\r\nerror = -EBUSY;\r\ngoto out;\r\n}\r\nif (register_chrdev(IDETAPE_MAJOR, "ht", &idetape_fops)) {\r\nprintk(KERN_ERR "ide-tape: Failed to register chrdev"\r\n" interface\n");\r\nerror = -EBUSY;\r\ngoto out_free_class;\r\n}\r\nerror = driver_register(&idetape_driver.gen_driver);\r\nif (error)\r\ngoto out_free_chrdev;\r\nreturn 0;\r\nout_free_chrdev:\r\nunregister_chrdev(IDETAPE_MAJOR, "ht");\r\nout_free_class:\r\nclass_destroy(idetape_sysfs_class);\r\nout:\r\nreturn error;\r\n}
