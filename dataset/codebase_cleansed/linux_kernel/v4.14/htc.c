static void ath10k_htc_control_tx_complete(struct ath10k *ar,\r\nstruct sk_buff *skb)\r\n{\r\nkfree_skb(skb);\r\n}\r\nstatic struct sk_buff *ath10k_htc_build_tx_ctrl_skb(void *ar)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ath10k_skb_cb *skb_cb;\r\nskb = dev_alloc_skb(ATH10K_HTC_CONTROL_BUFFER_SIZE);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, 20);\r\nWARN_ONCE((unsigned long)skb->data & 3, "unaligned skb");\r\nskb_cb = ATH10K_SKB_CB(skb);\r\nmemset(skb_cb, 0, sizeof(*skb_cb));\r\nath10k_dbg(ar, ATH10K_DBG_HTC, "%s: skb %pK\n", __func__, skb);\r\nreturn skb;\r\n}\r\nstatic inline void ath10k_htc_restore_tx_skb(struct ath10k_htc *htc,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ath10k_skb_cb *skb_cb = ATH10K_SKB_CB(skb);\r\ndma_unmap_single(htc->ar->dev, skb_cb->paddr, skb->len, DMA_TO_DEVICE);\r\nskb_pull(skb, sizeof(struct ath10k_htc_hdr));\r\n}\r\nvoid ath10k_htc_notify_tx_completion(struct ath10k_htc_ep *ep,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ath10k *ar = ep->htc->ar;\r\nath10k_dbg(ar, ATH10K_DBG_HTC, "%s: ep %d skb %pK\n", __func__,\r\nep->eid, skb);\r\nath10k_htc_restore_tx_skb(ep->htc, skb);\r\nif (!ep->ep_ops.ep_tx_complete) {\r\nath10k_warn(ar, "no tx handler for eid %d\n", ep->eid);\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nep->ep_ops.ep_tx_complete(ep->htc->ar, skb);\r\n}\r\nstatic void ath10k_htc_prepare_tx_skb(struct ath10k_htc_ep *ep,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ath10k_htc_hdr *hdr;\r\nhdr = (struct ath10k_htc_hdr *)skb->data;\r\nhdr->eid = ep->eid;\r\nhdr->len = __cpu_to_le16(skb->len - sizeof(*hdr));\r\nhdr->flags = 0;\r\nhdr->flags |= ATH10K_HTC_FLAG_NEED_CREDIT_UPDATE;\r\nspin_lock_bh(&ep->htc->tx_lock);\r\nhdr->seq_no = ep->seq_no++;\r\nspin_unlock_bh(&ep->htc->tx_lock);\r\n}\r\nint ath10k_htc_send(struct ath10k_htc *htc,\r\nenum ath10k_htc_ep_id eid,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ath10k *ar = htc->ar;\r\nstruct ath10k_htc_ep *ep = &htc->endpoint[eid];\r\nstruct ath10k_skb_cb *skb_cb = ATH10K_SKB_CB(skb);\r\nstruct ath10k_hif_sg_item sg_item;\r\nstruct device *dev = htc->ar->dev;\r\nint credits = 0;\r\nint ret;\r\nif (htc->ar->state == ATH10K_STATE_WEDGED)\r\nreturn -ECOMM;\r\nif (eid >= ATH10K_HTC_EP_COUNT) {\r\nath10k_warn(ar, "Invalid endpoint id: %d\n", eid);\r\nreturn -ENOENT;\r\n}\r\nskb_push(skb, sizeof(struct ath10k_htc_hdr));\r\nif (ep->tx_credit_flow_enabled) {\r\ncredits = DIV_ROUND_UP(skb->len, htc->target_credit_size);\r\nspin_lock_bh(&htc->tx_lock);\r\nif (ep->tx_credits < credits) {\r\nath10k_dbg(ar, ATH10K_DBG_HTC,\r\n"htc insufficient credits ep %d required %d available %d\n",\r\neid, credits, ep->tx_credits);\r\nspin_unlock_bh(&htc->tx_lock);\r\nret = -EAGAIN;\r\ngoto err_pull;\r\n}\r\nep->tx_credits -= credits;\r\nath10k_dbg(ar, ATH10K_DBG_HTC,\r\n"htc ep %d consumed %d credits (total %d)\n",\r\neid, credits, ep->tx_credits);\r\nspin_unlock_bh(&htc->tx_lock);\r\n}\r\nath10k_htc_prepare_tx_skb(ep, skb);\r\nskb_cb->eid = eid;\r\nskb_cb->paddr = dma_map_single(dev, skb->data, skb->len, DMA_TO_DEVICE);\r\nret = dma_mapping_error(dev, skb_cb->paddr);\r\nif (ret) {\r\nret = -EIO;\r\ngoto err_credits;\r\n}\r\nsg_item.transfer_id = ep->eid;\r\nsg_item.transfer_context = skb;\r\nsg_item.vaddr = skb->data;\r\nsg_item.paddr = skb_cb->paddr;\r\nsg_item.len = skb->len;\r\nret = ath10k_hif_tx_sg(htc->ar, ep->ul_pipe_id, &sg_item, 1);\r\nif (ret)\r\ngoto err_unmap;\r\nreturn 0;\r\nerr_unmap:\r\ndma_unmap_single(dev, skb_cb->paddr, skb->len, DMA_TO_DEVICE);\r\nerr_credits:\r\nif (ep->tx_credit_flow_enabled) {\r\nspin_lock_bh(&htc->tx_lock);\r\nep->tx_credits += credits;\r\nath10k_dbg(ar, ATH10K_DBG_HTC,\r\n"htc ep %d reverted %d credits back (total %d)\n",\r\neid, credits, ep->tx_credits);\r\nspin_unlock_bh(&htc->tx_lock);\r\nif (ep->ep_ops.ep_tx_credits)\r\nep->ep_ops.ep_tx_credits(htc->ar);\r\n}\r\nerr_pull:\r\nskb_pull(skb, sizeof(struct ath10k_htc_hdr));\r\nreturn ret;\r\n}\r\nvoid ath10k_htc_tx_completion_handler(struct ath10k *ar, struct sk_buff *skb)\r\n{\r\nstruct ath10k_htc *htc = &ar->htc;\r\nstruct ath10k_skb_cb *skb_cb;\r\nstruct ath10k_htc_ep *ep;\r\nif (WARN_ON_ONCE(!skb))\r\nreturn;\r\nskb_cb = ATH10K_SKB_CB(skb);\r\nep = &htc->endpoint[skb_cb->eid];\r\nath10k_htc_notify_tx_completion(ep, skb);\r\n}\r\nstatic void\r\nath10k_htc_process_credit_report(struct ath10k_htc *htc,\r\nconst struct ath10k_htc_credit_report *report,\r\nint len,\r\nenum ath10k_htc_ep_id eid)\r\n{\r\nstruct ath10k *ar = htc->ar;\r\nstruct ath10k_htc_ep *ep;\r\nint i, n_reports;\r\nif (len % sizeof(*report))\r\nath10k_warn(ar, "Uneven credit report len %d", len);\r\nn_reports = len / sizeof(*report);\r\nspin_lock_bh(&htc->tx_lock);\r\nfor (i = 0; i < n_reports; i++, report++) {\r\nif (report->eid >= ATH10K_HTC_EP_COUNT)\r\nbreak;\r\nep = &htc->endpoint[report->eid];\r\nep->tx_credits += report->credits;\r\nath10k_dbg(ar, ATH10K_DBG_HTC, "htc ep %d got %d credits (total %d)\n",\r\nreport->eid, report->credits, ep->tx_credits);\r\nif (ep->ep_ops.ep_tx_credits) {\r\nspin_unlock_bh(&htc->tx_lock);\r\nep->ep_ops.ep_tx_credits(htc->ar);\r\nspin_lock_bh(&htc->tx_lock);\r\n}\r\n}\r\nspin_unlock_bh(&htc->tx_lock);\r\n}\r\nstatic int\r\nath10k_htc_process_lookahead(struct ath10k_htc *htc,\r\nconst struct ath10k_htc_lookahead_report *report,\r\nint len,\r\nenum ath10k_htc_ep_id eid,\r\nvoid *next_lookaheads,\r\nint *next_lookaheads_len)\r\n{\r\nstruct ath10k *ar = htc->ar;\r\nif (report->pre_valid != ((~report->post_valid) & 0xFF))\r\nreturn 0;\r\nif (next_lookaheads && next_lookaheads_len) {\r\nath10k_dbg(ar, ATH10K_DBG_HTC,\r\n"htc rx lookahead found pre_valid 0x%x post_valid 0x%x\n",\r\nreport->pre_valid, report->post_valid);\r\nmemcpy((u8 *)next_lookaheads, report->lookahead, 4);\r\n*next_lookaheads_len = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nath10k_htc_process_lookahead_bundle(struct ath10k_htc *htc,\r\nconst struct ath10k_htc_lookahead_bundle *report,\r\nint len,\r\nenum ath10k_htc_ep_id eid,\r\nvoid *next_lookaheads,\r\nint *next_lookaheads_len)\r\n{\r\nstruct ath10k *ar = htc->ar;\r\nint bundle_cnt = len / sizeof(*report);\r\nif (!bundle_cnt || (bundle_cnt > HTC_HOST_MAX_MSG_PER_BUNDLE)) {\r\nath10k_warn(ar, "Invalid lookahead bundle count: %d\n",\r\nbundle_cnt);\r\nreturn -EINVAL;\r\n}\r\nif (next_lookaheads && next_lookaheads_len) {\r\nint i;\r\nfor (i = 0; i < bundle_cnt; i++) {\r\nmemcpy(((u8 *)next_lookaheads) + 4 * i,\r\nreport->lookahead, 4);\r\nreport++;\r\n}\r\n*next_lookaheads_len = bundle_cnt;\r\n}\r\nreturn 0;\r\n}\r\nint ath10k_htc_process_trailer(struct ath10k_htc *htc,\r\nu8 *buffer,\r\nint length,\r\nenum ath10k_htc_ep_id src_eid,\r\nvoid *next_lookaheads,\r\nint *next_lookaheads_len)\r\n{\r\nstruct ath10k_htc_lookahead_bundle *bundle;\r\nstruct ath10k *ar = htc->ar;\r\nint status = 0;\r\nstruct ath10k_htc_record *record;\r\nu8 *orig_buffer;\r\nint orig_length;\r\nsize_t len;\r\norig_buffer = buffer;\r\norig_length = length;\r\nwhile (length > 0) {\r\nrecord = (struct ath10k_htc_record *)buffer;\r\nif (length < sizeof(record->hdr)) {\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nif (record->hdr.len > length) {\r\nath10k_warn(ar, "Invalid record length: %d\n",\r\nrecord->hdr.len);\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nswitch (record->hdr.id) {\r\ncase ATH10K_HTC_RECORD_CREDITS:\r\nlen = sizeof(struct ath10k_htc_credit_report);\r\nif (record->hdr.len < len) {\r\nath10k_warn(ar, "Credit report too long\n");\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nath10k_htc_process_credit_report(htc,\r\nrecord->credit_report,\r\nrecord->hdr.len,\r\nsrc_eid);\r\nbreak;\r\ncase ATH10K_HTC_RECORD_LOOKAHEAD:\r\nlen = sizeof(struct ath10k_htc_lookahead_report);\r\nif (record->hdr.len < len) {\r\nath10k_warn(ar, "Lookahead report too long\n");\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nstatus = ath10k_htc_process_lookahead(htc,\r\nrecord->lookahead_report,\r\nrecord->hdr.len,\r\nsrc_eid,\r\nnext_lookaheads,\r\nnext_lookaheads_len);\r\nbreak;\r\ncase ATH10K_HTC_RECORD_LOOKAHEAD_BUNDLE:\r\nbundle = record->lookahead_bundle;\r\nstatus = ath10k_htc_process_lookahead_bundle(htc,\r\nbundle,\r\nrecord->hdr.len,\r\nsrc_eid,\r\nnext_lookaheads,\r\nnext_lookaheads_len);\r\nbreak;\r\ndefault:\r\nath10k_warn(ar, "Unhandled record: id:%d length:%d\n",\r\nrecord->hdr.id, record->hdr.len);\r\nbreak;\r\n}\r\nif (status)\r\nbreak;\r\nbuffer += sizeof(record->hdr) + record->hdr.len;\r\nlength -= sizeof(record->hdr) + record->hdr.len;\r\n}\r\nif (status)\r\nath10k_dbg_dump(ar, ATH10K_DBG_HTC, "htc rx bad trailer", "",\r\norig_buffer, orig_length);\r\nreturn status;\r\n}\r\nvoid ath10k_htc_rx_completion_handler(struct ath10k *ar, struct sk_buff *skb)\r\n{\r\nint status = 0;\r\nstruct ath10k_htc *htc = &ar->htc;\r\nstruct ath10k_htc_hdr *hdr;\r\nstruct ath10k_htc_ep *ep;\r\nu16 payload_len;\r\nu32 trailer_len = 0;\r\nsize_t min_len;\r\nu8 eid;\r\nbool trailer_present;\r\nhdr = (struct ath10k_htc_hdr *)skb->data;\r\nskb_pull(skb, sizeof(*hdr));\r\neid = hdr->eid;\r\nif (eid >= ATH10K_HTC_EP_COUNT) {\r\nath10k_warn(ar, "HTC Rx: invalid eid %d\n", eid);\r\nath10k_dbg_dump(ar, ATH10K_DBG_HTC, "htc bad header", "",\r\nhdr, sizeof(*hdr));\r\ngoto out;\r\n}\r\nep = &htc->endpoint[eid];\r\npayload_len = __le16_to_cpu(hdr->len);\r\nif (payload_len + sizeof(*hdr) > ATH10K_HTC_MAX_LEN) {\r\nath10k_warn(ar, "HTC rx frame too long, len: %zu\n",\r\npayload_len + sizeof(*hdr));\r\nath10k_dbg_dump(ar, ATH10K_DBG_HTC, "htc bad rx pkt len", "",\r\nhdr, sizeof(*hdr));\r\ngoto out;\r\n}\r\nif (skb->len < payload_len) {\r\nath10k_dbg(ar, ATH10K_DBG_HTC,\r\n"HTC Rx: insufficient length, got %d, expected %d\n",\r\nskb->len, payload_len);\r\nath10k_dbg_dump(ar, ATH10K_DBG_HTC, "htc bad rx pkt len",\r\n"", hdr, sizeof(*hdr));\r\ngoto out;\r\n}\r\ntrailer_present = hdr->flags & ATH10K_HTC_FLAG_TRAILER_PRESENT;\r\nif (trailer_present) {\r\nu8 *trailer;\r\ntrailer_len = hdr->trailer_len;\r\nmin_len = sizeof(struct ath10k_ath10k_htc_record_hdr);\r\nif ((trailer_len < min_len) ||\r\n(trailer_len > payload_len)) {\r\nath10k_warn(ar, "Invalid trailer length: %d\n",\r\ntrailer_len);\r\ngoto out;\r\n}\r\ntrailer = (u8 *)hdr;\r\ntrailer += sizeof(*hdr);\r\ntrailer += payload_len;\r\ntrailer -= trailer_len;\r\nstatus = ath10k_htc_process_trailer(htc, trailer,\r\ntrailer_len, hdr->eid,\r\nNULL, NULL);\r\nif (status)\r\ngoto out;\r\nskb_trim(skb, skb->len - trailer_len);\r\n}\r\nif (((int)payload_len - (int)trailer_len) <= 0)\r\ngoto out;\r\nath10k_dbg(ar, ATH10K_DBG_HTC, "htc rx completion ep %d skb %pK\n",\r\neid, skb);\r\nep->ep_ops.ep_rx_complete(ar, skb);\r\nskb = NULL;\r\nout:\r\nkfree_skb(skb);\r\n}\r\nstatic void ath10k_htc_control_rx_complete(struct ath10k *ar,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ath10k_htc *htc = &ar->htc;\r\nstruct ath10k_htc_msg *msg = (struct ath10k_htc_msg *)skb->data;\r\nswitch (__le16_to_cpu(msg->hdr.message_id)) {\r\ncase ATH10K_HTC_MSG_READY_ID:\r\ncase ATH10K_HTC_MSG_CONNECT_SERVICE_RESP_ID:\r\nif (completion_done(&htc->ctl_resp)) {\r\nath10k_warn(ar, "HTC rx ctrl still processing\n");\r\ncomplete(&htc->ctl_resp);\r\ngoto out;\r\n}\r\nhtc->control_resp_len =\r\nmin_t(int, skb->len,\r\nATH10K_HTC_MAX_CTRL_MSG_LEN);\r\nmemcpy(htc->control_resp_buffer, skb->data,\r\nhtc->control_resp_len);\r\ncomplete(&htc->ctl_resp);\r\nbreak;\r\ncase ATH10K_HTC_MSG_SEND_SUSPEND_COMPLETE:\r\nhtc->htc_ops.target_send_suspend_complete(ar);\r\nbreak;\r\ndefault:\r\nath10k_warn(ar, "ignoring unsolicited htc ep0 event\n");\r\nbreak;\r\n}\r\nout:\r\nkfree_skb(skb);\r\n}\r\nstatic const char *htc_service_name(enum ath10k_htc_svc_id id)\r\n{\r\nswitch (id) {\r\ncase ATH10K_HTC_SVC_ID_RESERVED:\r\nreturn "Reserved";\r\ncase ATH10K_HTC_SVC_ID_RSVD_CTRL:\r\nreturn "Control";\r\ncase ATH10K_HTC_SVC_ID_WMI_CONTROL:\r\nreturn "WMI";\r\ncase ATH10K_HTC_SVC_ID_WMI_DATA_BE:\r\nreturn "DATA BE";\r\ncase ATH10K_HTC_SVC_ID_WMI_DATA_BK:\r\nreturn "DATA BK";\r\ncase ATH10K_HTC_SVC_ID_WMI_DATA_VI:\r\nreturn "DATA VI";\r\ncase ATH10K_HTC_SVC_ID_WMI_DATA_VO:\r\nreturn "DATA VO";\r\ncase ATH10K_HTC_SVC_ID_NMI_CONTROL:\r\nreturn "NMI Control";\r\ncase ATH10K_HTC_SVC_ID_NMI_DATA:\r\nreturn "NMI Data";\r\ncase ATH10K_HTC_SVC_ID_HTT_DATA_MSG:\r\nreturn "HTT Data";\r\ncase ATH10K_HTC_SVC_ID_TEST_RAW_STREAMS:\r\nreturn "RAW";\r\n}\r\nreturn "Unknown";\r\n}\r\nstatic void ath10k_htc_reset_endpoint_states(struct ath10k_htc *htc)\r\n{\r\nstruct ath10k_htc_ep *ep;\r\nint i;\r\nfor (i = ATH10K_HTC_EP_0; i < ATH10K_HTC_EP_COUNT; i++) {\r\nep = &htc->endpoint[i];\r\nep->service_id = ATH10K_HTC_SVC_ID_UNUSED;\r\nep->max_ep_message_len = 0;\r\nep->max_tx_queue_depth = 0;\r\nep->eid = i;\r\nep->htc = htc;\r\nep->tx_credit_flow_enabled = true;\r\n}\r\n}\r\nstatic u8 ath10k_htc_get_credit_allocation(struct ath10k_htc *htc,\r\nu16 service_id)\r\n{\r\nu8 allocation = 0;\r\nif (service_id == ATH10K_HTC_SVC_ID_WMI_CONTROL)\r\nallocation = htc->total_transmit_credits;\r\nreturn allocation;\r\n}\r\nint ath10k_htc_wait_target(struct ath10k_htc *htc)\r\n{\r\nstruct ath10k *ar = htc->ar;\r\nint i, status = 0;\r\nunsigned long time_left;\r\nstruct ath10k_htc_msg *msg;\r\nu16 message_id;\r\ntime_left = wait_for_completion_timeout(&htc->ctl_resp,\r\nATH10K_HTC_WAIT_TIMEOUT_HZ);\r\nif (!time_left) {\r\nath10k_warn(ar, "failed to receive control response completion, polling..\n");\r\nfor (i = 0; i < CE_COUNT; i++)\r\nath10k_hif_send_complete_check(htc->ar, i, 1);\r\ntime_left =\r\nwait_for_completion_timeout(&htc->ctl_resp,\r\nATH10K_HTC_WAIT_TIMEOUT_HZ);\r\nif (!time_left)\r\nstatus = -ETIMEDOUT;\r\n}\r\nif (status < 0) {\r\nath10k_err(ar, "ctl_resp never came in (%d)\n", status);\r\nreturn status;\r\n}\r\nif (htc->control_resp_len < sizeof(msg->hdr) + sizeof(msg->ready)) {\r\nath10k_err(ar, "Invalid HTC ready msg len:%d\n",\r\nhtc->control_resp_len);\r\nreturn -ECOMM;\r\n}\r\nmsg = (struct ath10k_htc_msg *)htc->control_resp_buffer;\r\nmessage_id = __le16_to_cpu(msg->hdr.message_id);\r\nif (message_id != ATH10K_HTC_MSG_READY_ID) {\r\nath10k_err(ar, "Invalid HTC ready msg: 0x%x\n", message_id);\r\nreturn -ECOMM;\r\n}\r\nhtc->total_transmit_credits = __le16_to_cpu(msg->ready.credit_count);\r\nhtc->target_credit_size = __le16_to_cpu(msg->ready.credit_size);\r\nath10k_dbg(ar, ATH10K_DBG_HTC,\r\n"Target ready! transmit resources: %d size:%d\n",\r\nhtc->total_transmit_credits,\r\nhtc->target_credit_size);\r\nif ((htc->total_transmit_credits == 0) ||\r\n(htc->target_credit_size == 0)) {\r\nath10k_err(ar, "Invalid credit size received\n");\r\nreturn -ECOMM;\r\n}\r\nif (htc->control_resp_len >=\r\nsizeof(msg->hdr) + sizeof(msg->ready_ext)) {\r\nhtc->max_msgs_per_htc_bundle =\r\nmin_t(u8, msg->ready_ext.max_msgs_per_htc_bundle,\r\nHTC_HOST_MAX_MSG_PER_BUNDLE);\r\nath10k_dbg(ar, ATH10K_DBG_HTC,\r\n"Extended ready message. RX bundle size: %d\n",\r\nhtc->max_msgs_per_htc_bundle);\r\n}\r\nreturn 0;\r\n}\r\nint ath10k_htc_connect_service(struct ath10k_htc *htc,\r\nstruct ath10k_htc_svc_conn_req *conn_req,\r\nstruct ath10k_htc_svc_conn_resp *conn_resp)\r\n{\r\nstruct ath10k *ar = htc->ar;\r\nstruct ath10k_htc_msg *msg;\r\nstruct ath10k_htc_conn_svc *req_msg;\r\nstruct ath10k_htc_conn_svc_response resp_msg_dummy;\r\nstruct ath10k_htc_conn_svc_response *resp_msg = &resp_msg_dummy;\r\nenum ath10k_htc_ep_id assigned_eid = ATH10K_HTC_EP_COUNT;\r\nstruct ath10k_htc_ep *ep;\r\nstruct sk_buff *skb;\r\nunsigned int max_msg_size = 0;\r\nint length, status;\r\nunsigned long time_left;\r\nbool disable_credit_flow_ctrl = false;\r\nu16 message_id, service_id, flags = 0;\r\nu8 tx_alloc = 0;\r\nif (conn_req->service_id == ATH10K_HTC_SVC_ID_RSVD_CTRL) {\r\ndisable_credit_flow_ctrl = true;\r\nassigned_eid = ATH10K_HTC_EP_0;\r\nmax_msg_size = ATH10K_HTC_MAX_CTRL_MSG_LEN;\r\nmemset(&resp_msg_dummy, 0, sizeof(resp_msg_dummy));\r\ngoto setup;\r\n}\r\ntx_alloc = ath10k_htc_get_credit_allocation(htc,\r\nconn_req->service_id);\r\nif (!tx_alloc)\r\nath10k_dbg(ar, ATH10K_DBG_BOOT,\r\n"boot htc service %s does not allocate target credits\n",\r\nhtc_service_name(conn_req->service_id));\r\nskb = ath10k_htc_build_tx_ctrl_skb(htc->ar);\r\nif (!skb) {\r\nath10k_err(ar, "Failed to allocate HTC packet\n");\r\nreturn -ENOMEM;\r\n}\r\nlength = sizeof(msg->hdr) + sizeof(msg->connect_service);\r\nskb_put(skb, length);\r\nmemset(skb->data, 0, length);\r\nmsg = (struct ath10k_htc_msg *)skb->data;\r\nmsg->hdr.message_id =\r\n__cpu_to_le16(ATH10K_HTC_MSG_CONNECT_SERVICE_ID);\r\nflags |= SM(tx_alloc, ATH10K_HTC_CONN_FLAGS_RECV_ALLOC);\r\nif (conn_req->service_id != ATH10K_HTC_SVC_ID_WMI_CONTROL) {\r\nflags |= ATH10K_HTC_CONN_FLAGS_DISABLE_CREDIT_FLOW_CTRL;\r\ndisable_credit_flow_ctrl = true;\r\n}\r\nreq_msg = &msg->connect_service;\r\nreq_msg->flags = __cpu_to_le16(flags);\r\nreq_msg->service_id = __cpu_to_le16(conn_req->service_id);\r\nreinit_completion(&htc->ctl_resp);\r\nstatus = ath10k_htc_send(htc, ATH10K_HTC_EP_0, skb);\r\nif (status) {\r\nkfree_skb(skb);\r\nreturn status;\r\n}\r\ntime_left = wait_for_completion_timeout(&htc->ctl_resp,\r\nATH10K_HTC_CONN_SVC_TIMEOUT_HZ);\r\nif (!time_left) {\r\nath10k_err(ar, "Service connect timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmsg = (struct ath10k_htc_msg *)htc->control_resp_buffer;\r\nresp_msg = &msg->connect_service_response;\r\nmessage_id = __le16_to_cpu(msg->hdr.message_id);\r\nservice_id = __le16_to_cpu(resp_msg->service_id);\r\nif ((message_id != ATH10K_HTC_MSG_CONNECT_SERVICE_RESP_ID) ||\r\n(htc->control_resp_len < sizeof(msg->hdr) +\r\nsizeof(msg->connect_service_response))) {\r\nath10k_err(ar, "Invalid resp message ID 0x%x", message_id);\r\nreturn -EPROTO;\r\n}\r\nath10k_dbg(ar, ATH10K_DBG_HTC,\r\n"HTC Service %s connect response: status: 0x%x, assigned ep: 0x%x\n",\r\nhtc_service_name(service_id),\r\nresp_msg->status, resp_msg->eid);\r\nconn_resp->connect_resp_code = resp_msg->status;\r\nif (resp_msg->status != ATH10K_HTC_CONN_SVC_STATUS_SUCCESS) {\r\nath10k_err(ar, "HTC Service %s connect request failed: 0x%x)\n",\r\nhtc_service_name(service_id),\r\nresp_msg->status);\r\nreturn -EPROTO;\r\n}\r\nassigned_eid = (enum ath10k_htc_ep_id)resp_msg->eid;\r\nmax_msg_size = __le16_to_cpu(resp_msg->max_msg_size);\r\nsetup:\r\nif (assigned_eid >= ATH10K_HTC_EP_COUNT)\r\nreturn -EPROTO;\r\nif (max_msg_size == 0)\r\nreturn -EPROTO;\r\nep = &htc->endpoint[assigned_eid];\r\nep->eid = assigned_eid;\r\nif (ep->service_id != ATH10K_HTC_SVC_ID_UNUSED)\r\nreturn -EPROTO;\r\nconn_resp->eid = assigned_eid;\r\nconn_resp->max_msg_len = __le16_to_cpu(resp_msg->max_msg_size);\r\nep->service_id = conn_req->service_id;\r\nep->max_tx_queue_depth = conn_req->max_send_queue_depth;\r\nep->max_ep_message_len = __le16_to_cpu(resp_msg->max_msg_size);\r\nep->tx_credits = tx_alloc;\r\nep->ep_ops = conn_req->ep_ops;\r\nstatus = ath10k_hif_map_service_to_pipe(htc->ar,\r\nep->service_id,\r\n&ep->ul_pipe_id,\r\n&ep->dl_pipe_id);\r\nif (status)\r\nreturn status;\r\nath10k_dbg(ar, ATH10K_DBG_BOOT,\r\n"boot htc service '%s' ul pipe %d dl pipe %d eid %d ready\n",\r\nhtc_service_name(ep->service_id), ep->ul_pipe_id,\r\nep->dl_pipe_id, ep->eid);\r\nif (disable_credit_flow_ctrl && ep->tx_credit_flow_enabled) {\r\nep->tx_credit_flow_enabled = false;\r\nath10k_dbg(ar, ATH10K_DBG_BOOT,\r\n"boot htc service '%s' eid %d TX flow control disabled\n",\r\nhtc_service_name(ep->service_id), assigned_eid);\r\n}\r\nreturn status;\r\n}\r\nstruct sk_buff *ath10k_htc_alloc_skb(struct ath10k *ar, int size)\r\n{\r\nstruct sk_buff *skb;\r\nskb = dev_alloc_skb(size + sizeof(struct ath10k_htc_hdr));\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, sizeof(struct ath10k_htc_hdr));\r\nif (!IS_ALIGNED((unsigned long)skb->data, 4))\r\nath10k_warn(ar, "Unaligned HTC tx skb\n");\r\nreturn skb;\r\n}\r\nint ath10k_htc_start(struct ath10k_htc *htc)\r\n{\r\nstruct ath10k *ar = htc->ar;\r\nstruct sk_buff *skb;\r\nint status = 0;\r\nstruct ath10k_htc_msg *msg;\r\nskb = ath10k_htc_build_tx_ctrl_skb(htc->ar);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_put(skb, sizeof(msg->hdr) + sizeof(msg->setup_complete_ext));\r\nmemset(skb->data, 0, skb->len);\r\nmsg = (struct ath10k_htc_msg *)skb->data;\r\nmsg->hdr.message_id =\r\n__cpu_to_le16(ATH10K_HTC_MSG_SETUP_COMPLETE_EX_ID);\r\nif (ar->hif.bus == ATH10K_BUS_SDIO) {\r\nmsg->setup_complete_ext.flags =\r\n__cpu_to_le32(ATH10K_HTC_SETUP_COMPLETE_FLAGS_RX_BNDL_EN);\r\nmsg->setup_complete_ext.max_msgs_per_bundled_recv =\r\nhtc->max_msgs_per_htc_bundle;\r\n}\r\nath10k_dbg(ar, ATH10K_DBG_HTC, "HTC is using TX credit flow control\n");\r\nstatus = ath10k_htc_send(htc, ATH10K_HTC_EP_0, skb);\r\nif (status) {\r\nkfree_skb(skb);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nint ath10k_htc_init(struct ath10k *ar)\r\n{\r\nint status;\r\nstruct ath10k_htc *htc = &ar->htc;\r\nstruct ath10k_htc_svc_conn_req conn_req;\r\nstruct ath10k_htc_svc_conn_resp conn_resp;\r\nspin_lock_init(&htc->tx_lock);\r\nath10k_htc_reset_endpoint_states(htc);\r\nhtc->ar = ar;\r\nmemset(&conn_req, 0, sizeof(conn_req));\r\nmemset(&conn_resp, 0, sizeof(conn_resp));\r\nconn_req.ep_ops.ep_tx_complete = ath10k_htc_control_tx_complete;\r\nconn_req.ep_ops.ep_rx_complete = ath10k_htc_control_rx_complete;\r\nconn_req.max_send_queue_depth = ATH10K_NUM_CONTROL_TX_BUFFERS;\r\nconn_req.service_id = ATH10K_HTC_SVC_ID_RSVD_CTRL;\r\nstatus = ath10k_htc_connect_service(htc, &conn_req, &conn_resp);\r\nif (status) {\r\nath10k_err(ar, "could not connect to htc service (%d)\n",\r\nstatus);\r\nreturn status;\r\n}\r\ninit_completion(&htc->ctl_resp);\r\nreturn 0;\r\n}
