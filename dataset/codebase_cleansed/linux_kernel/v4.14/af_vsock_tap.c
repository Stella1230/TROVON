int vsock_add_tap(struct vsock_tap *vt)\r\n{\r\nif (unlikely(vt->dev->type != ARPHRD_VSOCKMON))\r\nreturn -EINVAL;\r\n__module_get(vt->module);\r\nspin_lock(&vsock_tap_lock);\r\nlist_add_rcu(&vt->list, &vsock_tap_all);\r\nspin_unlock(&vsock_tap_lock);\r\nreturn 0;\r\n}\r\nint vsock_remove_tap(struct vsock_tap *vt)\r\n{\r\nstruct vsock_tap *tmp;\r\nbool found = false;\r\nspin_lock(&vsock_tap_lock);\r\nlist_for_each_entry(tmp, &vsock_tap_all, list) {\r\nif (vt == tmp) {\r\nlist_del_rcu(&vt->list);\r\nfound = true;\r\ngoto out;\r\n}\r\n}\r\npr_warn("vsock_remove_tap: %p not found\n", vt);\r\nout:\r\nspin_unlock(&vsock_tap_lock);\r\nsynchronize_net();\r\nif (found)\r\nmodule_put(vt->module);\r\nreturn found ? 0 : -ENODEV;\r\n}\r\nstatic int __vsock_deliver_tap_skb(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nint ret = 0;\r\nstruct sk_buff *nskb = skb_clone(skb, GFP_ATOMIC);\r\nif (nskb) {\r\ndev_hold(dev);\r\nnskb->dev = dev;\r\nret = dev_queue_xmit(nskb);\r\nif (unlikely(ret > 0))\r\nret = net_xmit_errno(ret);\r\ndev_put(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __vsock_deliver_tap(struct sk_buff *skb)\r\n{\r\nint ret;\r\nstruct vsock_tap *tmp;\r\nlist_for_each_entry_rcu(tmp, &vsock_tap_all, list) {\r\nret = __vsock_deliver_tap_skb(skb, tmp->dev);\r\nif (unlikely(ret))\r\nbreak;\r\n}\r\n}
