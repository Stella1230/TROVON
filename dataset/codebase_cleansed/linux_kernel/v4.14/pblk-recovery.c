void pblk_submit_rec(struct work_struct *work)\r\n{\r\nstruct pblk_rec_ctx *recovery =\r\ncontainer_of(work, struct pblk_rec_ctx, ws_rec);\r\nstruct pblk *pblk = recovery->pblk;\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_rq *rqd = recovery->rqd;\r\nstruct pblk_c_ctx *c_ctx = nvm_rq_to_pdu(rqd);\r\nint max_secs = nvm_max_phys_sects(dev);\r\nstruct bio *bio;\r\nunsigned int nr_rec_secs;\r\nunsigned int pgs_read;\r\nint ret;\r\nnr_rec_secs = bitmap_weight((unsigned long int *)&rqd->ppa_status,\r\nmax_secs);\r\nbio = bio_alloc(GFP_KERNEL, nr_rec_secs);\r\nif (!bio) {\r\npr_err("pblk: not able to create recovery bio\n");\r\nreturn;\r\n}\r\nbio->bi_iter.bi_sector = 0;\r\nbio_set_op_attrs(bio, REQ_OP_WRITE, 0);\r\nrqd->bio = bio;\r\nrqd->nr_ppas = nr_rec_secs;\r\npgs_read = pblk_rb_read_to_bio_list(&pblk->rwb, bio, &recovery->failed,\r\nnr_rec_secs);\r\nif (pgs_read != nr_rec_secs) {\r\npr_err("pblk: could not read recovery entries\n");\r\ngoto err;\r\n}\r\nif (pblk_setup_w_rec_rq(pblk, rqd, c_ctx)) {\r\npr_err("pblk: could not setup recovery request\n");\r\ngoto err;\r\n}\r\n#ifdef CONFIG_NVM_DEBUG\r\natomic_long_add(nr_rec_secs, &pblk->recov_writes);\r\n#endif\r\nret = pblk_submit_io(pblk, rqd);\r\nif (ret) {\r\npr_err("pblk: I/O submission failed: %d\n", ret);\r\ngoto err;\r\n}\r\nmempool_free(recovery, pblk->rec_pool);\r\nreturn;\r\nerr:\r\nbio_put(bio);\r\npblk_free_rqd(pblk, rqd, WRITE);\r\n}\r\nint pblk_recov_setup_rq(struct pblk *pblk, struct pblk_c_ctx *c_ctx,\r\nstruct pblk_rec_ctx *recovery, u64 *comp_bits,\r\nunsigned int comp)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nint max_secs = nvm_max_phys_sects(dev);\r\nstruct nvm_rq *rec_rqd;\r\nstruct pblk_c_ctx *rec_ctx;\r\nint nr_entries = c_ctx->nr_valid + c_ctx->nr_padded;\r\nrec_rqd = pblk_alloc_rqd(pblk, WRITE);\r\nif (IS_ERR(rec_rqd)) {\r\npr_err("pblk: could not create recovery req.\n");\r\nreturn -ENOMEM;\r\n}\r\nrec_ctx = nvm_rq_to_pdu(rec_rqd);\r\nbitmap_shift_right((unsigned long int *)&rec_rqd->ppa_status,\r\n(unsigned long int *)comp_bits,\r\ncomp, max_secs);\r\nrec_ctx->sentry = pblk_rb_wrap_pos(&pblk->rwb, c_ctx->sentry + comp);\r\nif (comp >= c_ctx->nr_valid) {\r\nrec_ctx->nr_valid = 0;\r\nrec_ctx->nr_padded = nr_entries - comp;\r\nc_ctx->nr_padded = comp - c_ctx->nr_valid;\r\n} else {\r\nrec_ctx->nr_valid = c_ctx->nr_valid - comp;\r\nrec_ctx->nr_padded = c_ctx->nr_padded;\r\nc_ctx->nr_valid = comp;\r\nc_ctx->nr_padded = 0;\r\n}\r\nrecovery->rqd = rec_rqd;\r\nrecovery->pblk = pblk;\r\nreturn 0;\r\n}\r\n__le64 *pblk_recov_get_lba_list(struct pblk *pblk, struct line_emeta *emeta_buf)\r\n{\r\nu32 crc;\r\ncrc = pblk_calc_emeta_crc(pblk, emeta_buf);\r\nif (le32_to_cpu(emeta_buf->crc) != crc)\r\nreturn NULL;\r\nif (le32_to_cpu(emeta_buf->header.identifier) != PBLK_MAGIC)\r\nreturn NULL;\r\nreturn emeta_to_lbas(pblk, emeta_buf);\r\n}\r\nstatic int pblk_recov_l2p_from_emeta(struct pblk *pblk, struct pblk_line *line)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct pblk_line_meta *lm = &pblk->lm;\r\nstruct pblk_emeta *emeta = line->emeta;\r\nstruct line_emeta *emeta_buf = emeta->buf;\r\n__le64 *lba_list;\r\nint data_start;\r\nint nr_data_lbas, nr_valid_lbas, nr_lbas = 0;\r\nint i;\r\nlba_list = pblk_recov_get_lba_list(pblk, emeta_buf);\r\nif (!lba_list)\r\nreturn 1;\r\ndata_start = pblk_line_smeta_start(pblk, line) + lm->smeta_sec;\r\nnr_data_lbas = lm->sec_per_line - lm->emeta_sec[0];\r\nnr_valid_lbas = le64_to_cpu(emeta_buf->nr_valid_lbas);\r\nfor (i = data_start; i < nr_data_lbas && nr_lbas < nr_valid_lbas; i++) {\r\nstruct ppa_addr ppa;\r\nint pos;\r\nppa = addr_to_pblk_ppa(pblk, i, line->id);\r\npos = pblk_ppa_to_pos(geo, ppa);\r\nif (test_bit(pos, line->blk_bitmap))\r\ncontinue;\r\nif (le64_to_cpu(lba_list[i]) == ADDR_EMPTY) {\r\nspin_lock(&line->lock);\r\nif (test_and_set_bit(i, line->invalid_bitmap))\r\nWARN_ONCE(1, "pblk: rec. double invalidate:\n");\r\nelse\r\nle32_add_cpu(line->vsc, -1);\r\nspin_unlock(&line->lock);\r\ncontinue;\r\n}\r\npblk_update_map(pblk, le64_to_cpu(lba_list[i]), ppa);\r\nnr_lbas++;\r\n}\r\nif (nr_valid_lbas != nr_lbas)\r\npr_err("pblk: line %d - inconsistent lba list(%llu/%d)\n",\r\nline->id, emeta_buf->nr_valid_lbas, nr_lbas);\r\nline->left_msecs = 0;\r\nreturn 0;\r\n}\r\nstatic int pblk_calc_sec_in_line(struct pblk *pblk, struct pblk_line *line)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct pblk_line_meta *lm = &pblk->lm;\r\nint nr_bb = bitmap_weight(line->blk_bitmap, lm->blk_per_line);\r\nreturn lm->sec_per_line - lm->smeta_sec - lm->emeta_sec[0] -\r\nnr_bb * geo->sec_per_blk;\r\n}\r\nstatic int pblk_recov_read_oob(struct pblk *pblk, struct pblk_line *line,\r\nstruct pblk_recov_alloc p, u64 r_ptr)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct ppa_addr *ppa_list;\r\nstruct pblk_sec_meta *meta_list;\r\nstruct nvm_rq *rqd;\r\nstruct bio *bio;\r\nvoid *data;\r\ndma_addr_t dma_ppa_list, dma_meta_list;\r\nu64 r_ptr_int;\r\nint left_ppas;\r\nint rq_ppas, rq_len;\r\nint i, j;\r\nint ret = 0;\r\nDECLARE_COMPLETION_ONSTACK(wait);\r\nppa_list = p.ppa_list;\r\nmeta_list = p.meta_list;\r\nrqd = p.rqd;\r\ndata = p.data;\r\ndma_ppa_list = p.dma_ppa_list;\r\ndma_meta_list = p.dma_meta_list;\r\nleft_ppas = line->cur_sec - r_ptr;\r\nif (!left_ppas)\r\nreturn 0;\r\nr_ptr_int = r_ptr;\r\nnext_read_rq:\r\nmemset(rqd, 0, pblk_g_rq_size);\r\nrq_ppas = pblk_calc_secs(pblk, left_ppas, 0);\r\nif (!rq_ppas)\r\nrq_ppas = pblk->min_write_pgs;\r\nrq_len = rq_ppas * geo->sec_size;\r\nbio = bio_map_kern(dev->q, data, rq_len, GFP_KERNEL);\r\nif (IS_ERR(bio))\r\nreturn PTR_ERR(bio);\r\nbio->bi_iter.bi_sector = 0;\r\nbio_set_op_attrs(bio, REQ_OP_READ, 0);\r\nrqd->bio = bio;\r\nrqd->opcode = NVM_OP_PREAD;\r\nrqd->meta_list = meta_list;\r\nrqd->nr_ppas = rq_ppas;\r\nrqd->ppa_list = ppa_list;\r\nrqd->dma_ppa_list = dma_ppa_list;\r\nrqd->dma_meta_list = dma_meta_list;\r\nrqd->end_io = pblk_end_io_sync;\r\nrqd->private = &wait;\r\nif (pblk_io_aligned(pblk, rq_ppas))\r\nrqd->flags = pblk_set_read_mode(pblk, PBLK_READ_SEQUENTIAL);\r\nelse\r\nrqd->flags = pblk_set_read_mode(pblk, PBLK_READ_RANDOM);\r\nfor (i = 0; i < rqd->nr_ppas; ) {\r\nstruct ppa_addr ppa;\r\nint pos;\r\nppa = addr_to_gen_ppa(pblk, r_ptr_int, line->id);\r\npos = pblk_dev_ppa_to_pos(geo, ppa);\r\nwhile (test_bit(pos, line->blk_bitmap)) {\r\nr_ptr_int += pblk->min_write_pgs;\r\nppa = addr_to_gen_ppa(pblk, r_ptr_int, line->id);\r\npos = pblk_dev_ppa_to_pos(geo, ppa);\r\n}\r\nfor (j = 0; j < pblk->min_write_pgs; j++, i++, r_ptr_int++)\r\nrqd->ppa_list[i] =\r\naddr_to_gen_ppa(pblk, r_ptr_int, line->id);\r\n}\r\nret = pblk_submit_io(pblk, rqd);\r\nif (ret) {\r\npr_err("pblk: I/O submission failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (!wait_for_completion_io_timeout(&wait,\r\nmsecs_to_jiffies(PBLK_COMMAND_TIMEOUT_MS))) {\r\npr_err("pblk: L2P recovery read timed out\n");\r\nreturn -EINTR;\r\n}\r\natomic_dec(&pblk->inflight_io);\r\nreinit_completion(&wait);\r\nif (rqd->error) {\r\npr_err("pblk: L2P recovery failed (%d)\n", rqd->error);\r\nreturn -EINTR;\r\n}\r\nfor (i = 0; i < rqd->nr_ppas; i++) {\r\nu64 lba = le64_to_cpu(meta_list[i].lba);\r\nif (lba == ADDR_EMPTY || lba > pblk->rl.nr_secs)\r\ncontinue;\r\npblk_update_map(pblk, lba, rqd->ppa_list[i]);\r\n}\r\nleft_ppas -= rq_ppas;\r\nif (left_ppas > 0)\r\ngoto next_read_rq;\r\nreturn 0;\r\n}\r\nstatic void pblk_recov_complete(struct kref *ref)\r\n{\r\nstruct pblk_pad_rq *pad_rq = container_of(ref, struct pblk_pad_rq, ref);\r\ncomplete(&pad_rq->wait);\r\n}\r\nstatic void pblk_end_io_recov(struct nvm_rq *rqd)\r\n{\r\nstruct pblk_pad_rq *pad_rq = rqd->private;\r\nstruct pblk *pblk = pad_rq->pblk;\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\npblk_up_page(pblk, rqd->ppa_list, rqd->nr_ppas);\r\nbio_put(rqd->bio);\r\nnvm_dev_dma_free(dev->parent, rqd->meta_list, rqd->dma_meta_list);\r\npblk_free_rqd(pblk, rqd, WRITE);\r\natomic_dec(&pblk->inflight_io);\r\nkref_put(&pad_rq->ref, pblk_recov_complete);\r\n}\r\nstatic int pblk_recov_pad_oob(struct pblk *pblk, struct pblk_line *line,\r\nint left_ppas)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct ppa_addr *ppa_list;\r\nstruct pblk_sec_meta *meta_list;\r\nstruct pblk_pad_rq *pad_rq;\r\nstruct nvm_rq *rqd;\r\nstruct bio *bio;\r\nvoid *data;\r\ndma_addr_t dma_ppa_list, dma_meta_list;\r\n__le64 *lba_list = emeta_to_lbas(pblk, line->emeta->buf);\r\nu64 w_ptr = line->cur_sec;\r\nint left_line_ppas, rq_ppas, rq_len;\r\nint i, j;\r\nint ret = 0;\r\nspin_lock(&line->lock);\r\nleft_line_ppas = line->left_msecs;\r\nspin_unlock(&line->lock);\r\npad_rq = kmalloc(sizeof(struct pblk_pad_rq), GFP_KERNEL);\r\nif (!pad_rq)\r\nreturn -ENOMEM;\r\ndata = vzalloc(pblk->max_write_pgs * geo->sec_size);\r\nif (!data) {\r\nret = -ENOMEM;\r\ngoto free_rq;\r\n}\r\npad_rq->pblk = pblk;\r\ninit_completion(&pad_rq->wait);\r\nkref_init(&pad_rq->ref);\r\nnext_pad_rq:\r\nrq_ppas = pblk_calc_secs(pblk, left_ppas, 0);\r\nif (rq_ppas < pblk->min_write_pgs) {\r\npr_err("pblk: corrupted pad line %d\n", line->id);\r\ngoto fail_free_pad;\r\n}\r\nrq_len = rq_ppas * geo->sec_size;\r\nmeta_list = nvm_dev_dma_alloc(dev->parent, GFP_KERNEL, &dma_meta_list);\r\nif (!meta_list) {\r\nret = -ENOMEM;\r\ngoto fail_free_pad;\r\n}\r\nppa_list = (void *)(meta_list) + pblk_dma_meta_size;\r\ndma_ppa_list = dma_meta_list + pblk_dma_meta_size;\r\nrqd = pblk_alloc_rqd(pblk, WRITE);\r\nif (IS_ERR(rqd)) {\r\nret = PTR_ERR(rqd);\r\ngoto fail_free_meta;\r\n}\r\nbio = pblk_bio_map_addr(pblk, data, rq_ppas, rq_len,\r\nPBLK_VMALLOC_META, GFP_KERNEL);\r\nif (IS_ERR(bio)) {\r\nret = PTR_ERR(bio);\r\ngoto fail_free_rqd;\r\n}\r\nbio->bi_iter.bi_sector = 0;\r\nbio_set_op_attrs(bio, REQ_OP_WRITE, 0);\r\nrqd->bio = bio;\r\nrqd->opcode = NVM_OP_PWRITE;\r\nrqd->flags = pblk_set_progr_mode(pblk, WRITE);\r\nrqd->meta_list = meta_list;\r\nrqd->nr_ppas = rq_ppas;\r\nrqd->ppa_list = ppa_list;\r\nrqd->dma_ppa_list = dma_ppa_list;\r\nrqd->dma_meta_list = dma_meta_list;\r\nrqd->end_io = pblk_end_io_recov;\r\nrqd->private = pad_rq;\r\nfor (i = 0; i < rqd->nr_ppas; ) {\r\nstruct ppa_addr ppa;\r\nint pos;\r\nw_ptr = pblk_alloc_page(pblk, line, pblk->min_write_pgs);\r\nppa = addr_to_pblk_ppa(pblk, w_ptr, line->id);\r\npos = pblk_ppa_to_pos(geo, ppa);\r\nwhile (test_bit(pos, line->blk_bitmap)) {\r\nw_ptr += pblk->min_write_pgs;\r\nppa = addr_to_pblk_ppa(pblk, w_ptr, line->id);\r\npos = pblk_ppa_to_pos(geo, ppa);\r\n}\r\nfor (j = 0; j < pblk->min_write_pgs; j++, i++, w_ptr++) {\r\nstruct ppa_addr dev_ppa;\r\n__le64 addr_empty = cpu_to_le64(ADDR_EMPTY);\r\ndev_ppa = addr_to_gen_ppa(pblk, w_ptr, line->id);\r\npblk_map_invalidate(pblk, dev_ppa);\r\nlba_list[w_ptr] = meta_list[i].lba = addr_empty;\r\nrqd->ppa_list[i] = dev_ppa;\r\n}\r\n}\r\nkref_get(&pad_rq->ref);\r\npblk_down_page(pblk, rqd->ppa_list, rqd->nr_ppas);\r\nret = pblk_submit_io(pblk, rqd);\r\nif (ret) {\r\npr_err("pblk: I/O submission failed: %d\n", ret);\r\npblk_up_page(pblk, rqd->ppa_list, rqd->nr_ppas);\r\ngoto fail_free_bio;\r\n}\r\nleft_line_ppas -= rq_ppas;\r\nleft_ppas -= rq_ppas;\r\nif (left_ppas && left_line_ppas)\r\ngoto next_pad_rq;\r\nkref_put(&pad_rq->ref, pblk_recov_complete);\r\nif (!wait_for_completion_io_timeout(&pad_rq->wait,\r\nmsecs_to_jiffies(PBLK_COMMAND_TIMEOUT_MS))) {\r\npr_err("pblk: pad write timed out\n");\r\nret = -ETIME;\r\n}\r\nif (!pblk_line_is_full(line))\r\npr_err("pblk: corrupted padded line: %d\n", line->id);\r\nvfree(data);\r\nfree_rq:\r\nkfree(pad_rq);\r\nreturn ret;\r\nfail_free_bio:\r\nbio_put(bio);\r\nfail_free_rqd:\r\npblk_free_rqd(pblk, rqd, WRITE);\r\nfail_free_meta:\r\nnvm_dev_dma_free(dev->parent, meta_list, dma_meta_list);\r\nfail_free_pad:\r\nkfree(pad_rq);\r\nvfree(data);\r\nreturn ret;\r\n}\r\nstatic int pblk_recov_scan_all_oob(struct pblk *pblk, struct pblk_line *line,\r\nstruct pblk_recov_alloc p)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct ppa_addr *ppa_list;\r\nstruct pblk_sec_meta *meta_list;\r\nstruct nvm_rq *rqd;\r\nstruct bio *bio;\r\nvoid *data;\r\ndma_addr_t dma_ppa_list, dma_meta_list;\r\nu64 w_ptr = 0, r_ptr;\r\nint rq_ppas, rq_len;\r\nint i, j;\r\nint ret = 0;\r\nint rec_round;\r\nint left_ppas = pblk_calc_sec_in_line(pblk, line) - line->cur_sec;\r\nDECLARE_COMPLETION_ONSTACK(wait);\r\nppa_list = p.ppa_list;\r\nmeta_list = p.meta_list;\r\nrqd = p.rqd;\r\ndata = p.data;\r\ndma_ppa_list = p.dma_ppa_list;\r\ndma_meta_list = p.dma_meta_list;\r\nr_ptr = line->cur_sec;\r\nrec_round = 0;\r\nnext_rq:\r\nmemset(rqd, 0, pblk_g_rq_size);\r\nrq_ppas = pblk_calc_secs(pblk, left_ppas, 0);\r\nif (!rq_ppas)\r\nrq_ppas = pblk->min_write_pgs;\r\nrq_len = rq_ppas * geo->sec_size;\r\nbio = bio_map_kern(dev->q, data, rq_len, GFP_KERNEL);\r\nif (IS_ERR(bio))\r\nreturn PTR_ERR(bio);\r\nbio->bi_iter.bi_sector = 0;\r\nbio_set_op_attrs(bio, REQ_OP_READ, 0);\r\nrqd->bio = bio;\r\nrqd->opcode = NVM_OP_PREAD;\r\nrqd->meta_list = meta_list;\r\nrqd->nr_ppas = rq_ppas;\r\nrqd->ppa_list = ppa_list;\r\nrqd->dma_ppa_list = dma_ppa_list;\r\nrqd->dma_meta_list = dma_meta_list;\r\nrqd->end_io = pblk_end_io_sync;\r\nrqd->private = &wait;\r\nif (pblk_io_aligned(pblk, rq_ppas))\r\nrqd->flags = pblk_set_read_mode(pblk, PBLK_READ_SEQUENTIAL);\r\nelse\r\nrqd->flags = pblk_set_read_mode(pblk, PBLK_READ_RANDOM);\r\nfor (i = 0; i < rqd->nr_ppas; ) {\r\nstruct ppa_addr ppa;\r\nint pos;\r\nw_ptr = pblk_alloc_page(pblk, line, pblk->min_write_pgs);\r\nppa = addr_to_gen_ppa(pblk, w_ptr, line->id);\r\npos = pblk_dev_ppa_to_pos(geo, ppa);\r\nwhile (test_bit(pos, line->blk_bitmap)) {\r\nw_ptr += pblk->min_write_pgs;\r\nppa = addr_to_gen_ppa(pblk, w_ptr, line->id);\r\npos = pblk_dev_ppa_to_pos(geo, ppa);\r\n}\r\nfor (j = 0; j < pblk->min_write_pgs; j++, i++, w_ptr++)\r\nrqd->ppa_list[i] =\r\naddr_to_gen_ppa(pblk, w_ptr, line->id);\r\n}\r\nret = pblk_submit_io(pblk, rqd);\r\nif (ret) {\r\npr_err("pblk: I/O submission failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (!wait_for_completion_io_timeout(&wait,\r\nmsecs_to_jiffies(PBLK_COMMAND_TIMEOUT_MS))) {\r\npr_err("pblk: L2P recovery read timed out\n");\r\n}\r\natomic_dec(&pblk->inflight_io);\r\nreinit_completion(&wait);\r\nif (!rec_round++ && !rqd->error) {\r\nrec_round = 0;\r\nfor (i = 0; i < rqd->nr_ppas; i++, r_ptr++) {\r\nu64 lba = le64_to_cpu(meta_list[i].lba);\r\nif (lba == ADDR_EMPTY || lba > pblk->rl.nr_secs)\r\ncontinue;\r\npblk_update_map(pblk, lba, rqd->ppa_list[i]);\r\n}\r\n}\r\nif (rqd->error == NVM_RSP_ERR_EMPTYPAGE) {\r\nint pad_secs, nr_error_bits, bit;\r\nint ret;\r\nbit = find_first_bit((void *)&rqd->ppa_status, rqd->nr_ppas);\r\nnr_error_bits = rqd->nr_ppas - bit;\r\nline->cur_sec -= nr_error_bits;\r\nline->left_msecs += nr_error_bits;\r\nbitmap_clear(line->map_bitmap, line->cur_sec, nr_error_bits);\r\npad_secs = pblk_pad_distance(pblk);\r\nif (pad_secs > line->left_msecs)\r\npad_secs = line->left_msecs;\r\nret = pblk_recov_pad_oob(pblk, line, pad_secs);\r\nif (ret)\r\npr_err("pblk: OOB padding failed (err:%d)\n", ret);\r\nret = pblk_recov_read_oob(pblk, line, p, r_ptr);\r\nif (ret)\r\npr_err("pblk: OOB read failed (err:%d)\n", ret);\r\nleft_ppas = 0;\r\n}\r\nleft_ppas -= rq_ppas;\r\nif (left_ppas > 0)\r\ngoto next_rq;\r\nreturn ret;\r\n}\r\nstatic int pblk_recov_scan_oob(struct pblk *pblk, struct pblk_line *line,\r\nstruct pblk_recov_alloc p, int *done)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct ppa_addr *ppa_list;\r\nstruct pblk_sec_meta *meta_list;\r\nstruct nvm_rq *rqd;\r\nstruct bio *bio;\r\nvoid *data;\r\ndma_addr_t dma_ppa_list, dma_meta_list;\r\nu64 paddr;\r\nint rq_ppas, rq_len;\r\nint i, j;\r\nint ret = 0;\r\nint left_ppas = pblk_calc_sec_in_line(pblk, line);\r\nDECLARE_COMPLETION_ONSTACK(wait);\r\nppa_list = p.ppa_list;\r\nmeta_list = p.meta_list;\r\nrqd = p.rqd;\r\ndata = p.data;\r\ndma_ppa_list = p.dma_ppa_list;\r\ndma_meta_list = p.dma_meta_list;\r\n*done = 1;\r\nnext_rq:\r\nmemset(rqd, 0, pblk_g_rq_size);\r\nrq_ppas = pblk_calc_secs(pblk, left_ppas, 0);\r\nif (!rq_ppas)\r\nrq_ppas = pblk->min_write_pgs;\r\nrq_len = rq_ppas * geo->sec_size;\r\nbio = bio_map_kern(dev->q, data, rq_len, GFP_KERNEL);\r\nif (IS_ERR(bio))\r\nreturn PTR_ERR(bio);\r\nbio->bi_iter.bi_sector = 0;\r\nbio_set_op_attrs(bio, REQ_OP_READ, 0);\r\nrqd->bio = bio;\r\nrqd->opcode = NVM_OP_PREAD;\r\nrqd->meta_list = meta_list;\r\nrqd->nr_ppas = rq_ppas;\r\nrqd->ppa_list = ppa_list;\r\nrqd->dma_ppa_list = dma_ppa_list;\r\nrqd->dma_meta_list = dma_meta_list;\r\nrqd->end_io = pblk_end_io_sync;\r\nrqd->private = &wait;\r\nif (pblk_io_aligned(pblk, rq_ppas))\r\nrqd->flags = pblk_set_read_mode(pblk, PBLK_READ_SEQUENTIAL);\r\nelse\r\nrqd->flags = pblk_set_read_mode(pblk, PBLK_READ_RANDOM);\r\nfor (i = 0; i < rqd->nr_ppas; ) {\r\nstruct ppa_addr ppa;\r\nint pos;\r\npaddr = pblk_alloc_page(pblk, line, pblk->min_write_pgs);\r\nppa = addr_to_gen_ppa(pblk, paddr, line->id);\r\npos = pblk_dev_ppa_to_pos(geo, ppa);\r\nwhile (test_bit(pos, line->blk_bitmap)) {\r\npaddr += pblk->min_write_pgs;\r\nppa = addr_to_gen_ppa(pblk, paddr, line->id);\r\npos = pblk_dev_ppa_to_pos(geo, ppa);\r\n}\r\nfor (j = 0; j < pblk->min_write_pgs; j++, i++, paddr++)\r\nrqd->ppa_list[i] =\r\naddr_to_gen_ppa(pblk, paddr, line->id);\r\n}\r\nret = pblk_submit_io(pblk, rqd);\r\nif (ret) {\r\npr_err("pblk: I/O submission failed: %d\n", ret);\r\nbio_put(bio);\r\nreturn ret;\r\n}\r\nif (!wait_for_completion_io_timeout(&wait,\r\nmsecs_to_jiffies(PBLK_COMMAND_TIMEOUT_MS))) {\r\npr_err("pblk: L2P recovery read timed out\n");\r\n}\r\natomic_dec(&pblk->inflight_io);\r\nreinit_completion(&wait);\r\nif (rqd->error) {\r\nint nr_error_bits, bit;\r\nbit = find_first_bit((void *)&rqd->ppa_status, rqd->nr_ppas);\r\nnr_error_bits = rqd->nr_ppas - bit;\r\nline->cur_sec -= nr_error_bits;\r\nline->left_msecs += nr_error_bits;\r\nbitmap_clear(line->map_bitmap, line->cur_sec, nr_error_bits);\r\nleft_ppas = 0;\r\nrqd->nr_ppas = bit;\r\nif (rqd->error != NVM_RSP_ERR_EMPTYPAGE)\r\n*done = 0;\r\n}\r\nfor (i = 0; i < rqd->nr_ppas; i++) {\r\nu64 lba = le64_to_cpu(meta_list[i].lba);\r\nif (lba == ADDR_EMPTY || lba > pblk->rl.nr_secs)\r\ncontinue;\r\npblk_update_map(pblk, lba, rqd->ppa_list[i]);\r\n}\r\nleft_ppas -= rq_ppas;\r\nif (left_ppas > 0)\r\ngoto next_rq;\r\nreturn ret;\r\n}\r\nstatic int pblk_recov_l2p_from_oob(struct pblk *pblk, struct pblk_line *line)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct nvm_rq *rqd;\r\nstruct ppa_addr *ppa_list;\r\nstruct pblk_sec_meta *meta_list;\r\nstruct pblk_recov_alloc p;\r\nvoid *data;\r\ndma_addr_t dma_ppa_list, dma_meta_list;\r\nint done, ret = 0;\r\nrqd = pblk_alloc_rqd(pblk, READ);\r\nif (IS_ERR(rqd))\r\nreturn PTR_ERR(rqd);\r\nmeta_list = nvm_dev_dma_alloc(dev->parent, GFP_KERNEL, &dma_meta_list);\r\nif (!meta_list) {\r\nret = -ENOMEM;\r\ngoto free_rqd;\r\n}\r\nppa_list = (void *)(meta_list) + pblk_dma_meta_size;\r\ndma_ppa_list = dma_meta_list + pblk_dma_meta_size;\r\ndata = kcalloc(pblk->max_write_pgs, geo->sec_size, GFP_KERNEL);\r\nif (!data) {\r\nret = -ENOMEM;\r\ngoto free_meta_list;\r\n}\r\np.ppa_list = ppa_list;\r\np.meta_list = meta_list;\r\np.rqd = rqd;\r\np.data = data;\r\np.dma_ppa_list = dma_ppa_list;\r\np.dma_meta_list = dma_meta_list;\r\nret = pblk_recov_scan_oob(pblk, line, p, &done);\r\nif (ret) {\r\npr_err("pblk: could not recover L2P from OOB\n");\r\ngoto out;\r\n}\r\nif (!done) {\r\nret = pblk_recov_scan_all_oob(pblk, line, p);\r\nif (ret) {\r\npr_err("pblk: could not recover L2P from OOB\n");\r\ngoto out;\r\n}\r\n}\r\nif (pblk_line_is_full(line))\r\npblk_line_recov_close(pblk, line);\r\nout:\r\nkfree(data);\r\nfree_meta_list:\r\nnvm_dev_dma_free(dev->parent, meta_list, dma_meta_list);\r\nfree_rqd:\r\npblk_free_rqd(pblk, rqd, READ);\r\nreturn ret;\r\n}\r\nstatic void pblk_recov_line_add_ordered(struct list_head *head,\r\nstruct pblk_line *line)\r\n{\r\nstruct pblk_line *t = NULL;\r\nlist_for_each_entry(t, head, list)\r\nif (t->seq_nr > line->seq_nr)\r\nbreak;\r\n__list_add(&line->list, t->list.prev, &t->list);\r\n}\r\nstruct pblk_line *pblk_recov_l2p(struct pblk *pblk)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct pblk_line_meta *lm = &pblk->lm;\r\nstruct pblk_line_mgmt *l_mg = &pblk->l_mg;\r\nstruct pblk_line *line, *tline, *data_line = NULL;\r\nstruct pblk_smeta *smeta;\r\nstruct pblk_emeta *emeta;\r\nstruct line_smeta *smeta_buf;\r\nint found_lines = 0, recovered_lines = 0, open_lines = 0;\r\nint is_next = 0;\r\nint meta_line;\r\nint i, valid_uuid = 0;\r\nLIST_HEAD(recov_list);\r\nspin_lock(&l_mg->free_lock);\r\nmeta_line = find_first_zero_bit(&l_mg->meta_bitmap, PBLK_DATA_LINES);\r\nset_bit(meta_line, &l_mg->meta_bitmap);\r\nsmeta = l_mg->sline_meta[meta_line];\r\nemeta = l_mg->eline_meta[meta_line];\r\nsmeta_buf = (struct line_smeta *)smeta;\r\nspin_unlock(&l_mg->free_lock);\r\nfor (i = 0; i < l_mg->nr_lines; i++) {\r\nu32 crc;\r\nline = &pblk->lines[i];\r\nmemset(smeta, 0, lm->smeta_len);\r\nline->smeta = smeta;\r\nline->lun_bitmap = ((void *)(smeta_buf)) +\r\nsizeof(struct line_smeta);\r\nif (pblk_line_read_smeta(pblk, line))\r\ncontinue;\r\ncrc = pblk_calc_smeta_crc(pblk, smeta_buf);\r\nif (le32_to_cpu(smeta_buf->crc) != crc)\r\ncontinue;\r\nif (le32_to_cpu(smeta_buf->header.identifier) != PBLK_MAGIC)\r\ncontinue;\r\nif (le16_to_cpu(smeta_buf->header.version) != 1) {\r\npr_err("pblk: found incompatible line version %u\n",\r\nsmeta_buf->header.version);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!valid_uuid) {\r\nmemcpy(pblk->instance_uuid, smeta_buf->header.uuid, 16);\r\nvalid_uuid = 1;\r\n}\r\nif (memcmp(pblk->instance_uuid, smeta_buf->header.uuid, 16)) {\r\npr_debug("pblk: ignore line %u due to uuid mismatch\n",\r\ni);\r\ncontinue;\r\n}\r\nspin_lock(&line->lock);\r\nline->id = le32_to_cpu(smeta_buf->header.id);\r\nline->type = le16_to_cpu(smeta_buf->header.type);\r\nline->seq_nr = le64_to_cpu(smeta_buf->seq_nr);\r\nspin_unlock(&line->lock);\r\nspin_lock(&l_mg->free_lock);\r\nif (line->seq_nr >= l_mg->d_seq_nr)\r\nl_mg->d_seq_nr = line->seq_nr + 1;\r\nl_mg->nr_free_lines--;\r\nspin_unlock(&l_mg->free_lock);\r\nif (pblk_line_recov_alloc(pblk, line))\r\ngoto out;\r\npblk_recov_line_add_ordered(&recov_list, line);\r\nfound_lines++;\r\npr_debug("pblk: recovering data line %d, seq:%llu\n",\r\nline->id, smeta_buf->seq_nr);\r\n}\r\nif (!found_lines) {\r\npblk_setup_uuid(pblk);\r\nspin_lock(&l_mg->free_lock);\r\nWARN_ON_ONCE(!test_and_clear_bit(meta_line,\r\n&l_mg->meta_bitmap));\r\nspin_unlock(&l_mg->free_lock);\r\ngoto out;\r\n}\r\nlist_for_each_entry_safe(line, tline, &recov_list, list) {\r\nint off, nr_bb;\r\nrecovered_lines++;\r\noff = lm->sec_per_line - lm->emeta_sec[0];\r\nnr_bb = bitmap_weight(line->blk_bitmap, lm->blk_per_line);\r\noff -= nr_bb * geo->sec_per_pl;\r\nline->emeta_ssec = off;\r\nline->emeta = emeta;\r\nmemset(line->emeta->buf, 0, lm->emeta_len[0]);\r\nif (pblk_line_read_emeta(pblk, line, line->emeta->buf)) {\r\npblk_recov_l2p_from_oob(pblk, line);\r\ngoto next;\r\n}\r\nif (pblk_recov_l2p_from_emeta(pblk, line))\r\npblk_recov_l2p_from_oob(pblk, line);\r\nnext:\r\nif (pblk_line_is_full(line)) {\r\nstruct list_head *move_list;\r\nspin_lock(&line->lock);\r\nline->state = PBLK_LINESTATE_CLOSED;\r\nmove_list = pblk_line_gc_list(pblk, line);\r\nspin_unlock(&line->lock);\r\nspin_lock(&l_mg->gc_lock);\r\nlist_move_tail(&line->list, move_list);\r\nspin_unlock(&l_mg->gc_lock);\r\nmempool_free(line->map_bitmap, pblk->line_meta_pool);\r\nline->map_bitmap = NULL;\r\nline->smeta = NULL;\r\nline->emeta = NULL;\r\n} else {\r\nif (open_lines > 1)\r\npr_err("pblk: failed to recover L2P\n");\r\nopen_lines++;\r\nline->meta_line = meta_line;\r\ndata_line = line;\r\n}\r\n}\r\nspin_lock(&l_mg->free_lock);\r\nif (!open_lines) {\r\nWARN_ON_ONCE(!test_and_clear_bit(meta_line,\r\n&l_mg->meta_bitmap));\r\npblk_line_replace_data(pblk);\r\n} else {\r\nl_mg->data_next = pblk_line_get(pblk);\r\nif (l_mg->data_next) {\r\nl_mg->data_next->seq_nr = l_mg->d_seq_nr++;\r\nl_mg->data_next->type = PBLK_LINETYPE_DATA;\r\nis_next = 1;\r\n}\r\n}\r\nspin_unlock(&l_mg->free_lock);\r\nif (is_next) {\r\npblk_line_erase(pblk, l_mg->data_next);\r\npblk_rl_free_lines_dec(&pblk->rl, l_mg->data_next);\r\n}\r\nout:\r\nif (found_lines != recovered_lines)\r\npr_err("pblk: failed to recover all found lines %d/%d\n",\r\nfound_lines, recovered_lines);\r\nreturn data_line;\r\n}\r\nint pblk_recov_pad(struct pblk *pblk)\r\n{\r\nstruct pblk_line *line;\r\nstruct pblk_line_mgmt *l_mg = &pblk->l_mg;\r\nint left_msecs;\r\nint ret = 0;\r\nspin_lock(&l_mg->free_lock);\r\nline = l_mg->data_line;\r\nleft_msecs = line->left_msecs;\r\nspin_unlock(&l_mg->free_lock);\r\nret = pblk_recov_pad_oob(pblk, line, left_msecs);\r\nif (ret) {\r\npr_err("pblk: Tear down padding failed (%d)\n", ret);\r\nreturn ret;\r\n}\r\npblk_line_close_meta(pblk, line);\r\nreturn ret;\r\n}
