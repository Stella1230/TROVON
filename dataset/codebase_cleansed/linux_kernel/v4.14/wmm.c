static void\r\nmwifiex_wmm_ac_debug_print(const struct ieee_types_wmm_ac_parameters *ac_param)\r\n{\r\nconst char *ac_str[] = { "BK", "BE", "VI", "VO" };\r\npr_debug("info: WMM AC_%s: ACI=%d, ACM=%d, Aifsn=%d, "\r\n"EcwMin=%d, EcwMax=%d, TxopLimit=%d\n",\r\nac_str[wmm_aci_to_qidx_map[(ac_param->aci_aifsn_bitmap\r\n& MWIFIEX_ACI) >> 5]],\r\n(ac_param->aci_aifsn_bitmap & MWIFIEX_ACI) >> 5,\r\n(ac_param->aci_aifsn_bitmap & MWIFIEX_ACM) >> 4,\r\nac_param->aci_aifsn_bitmap & MWIFIEX_AIFSN,\r\nac_param->ecw_bitmap & MWIFIEX_ECW_MIN,\r\n(ac_param->ecw_bitmap & MWIFIEX_ECW_MAX) >> 4,\r\nle16_to_cpu(ac_param->tx_op_limit));\r\n}\r\nstatic struct mwifiex_ra_list_tbl *\r\nmwifiex_wmm_allocate_ralist_node(struct mwifiex_adapter *adapter, const u8 *ra)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nra_list = kzalloc(sizeof(struct mwifiex_ra_list_tbl), GFP_ATOMIC);\r\nif (!ra_list)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&ra_list->list);\r\nskb_queue_head_init(&ra_list->skb_head);\r\nmemcpy(ra_list->ra, ra, ETH_ALEN);\r\nra_list->total_pkt_count = 0;\r\nmwifiex_dbg(adapter, INFO, "info: allocated ra_list %p\n", ra_list);\r\nreturn ra_list;\r\n}\r\nstatic u8 mwifiex_get_random_ba_threshold(void)\r\n{\r\nu64 ns;\r\nns = ktime_get_ns();\r\nns += (ns >> 32) + (ns >> 16);\r\nreturn ((u8)ns % BA_SETUP_MAX_PACKET_THRESHOLD) + BA_SETUP_PACKET_OFFSET;\r\n}\r\nvoid mwifiex_ralist_add(struct mwifiex_private *priv, const u8 *ra)\r\n{\r\nint i;\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct mwifiex_sta_node *node;\r\nunsigned long flags;\r\nfor (i = 0; i < MAX_NUM_TID; ++i) {\r\nra_list = mwifiex_wmm_allocate_ralist_node(adapter, ra);\r\nmwifiex_dbg(adapter, INFO,\r\n"info: created ra_list %p\n", ra_list);\r\nif (!ra_list)\r\nbreak;\r\nra_list->is_11n_enabled = 0;\r\nra_list->tdls_link = false;\r\nra_list->ba_status = BA_SETUP_NONE;\r\nra_list->amsdu_in_ampdu = false;\r\nif (!mwifiex_queuing_ra_based(priv)) {\r\nif (mwifiex_is_tdls_link_setup\r\n(mwifiex_get_tdls_link_status(priv, ra))) {\r\nra_list->tdls_link = true;\r\nra_list->is_11n_enabled =\r\nmwifiex_tdls_peer_11n_enabled(priv, ra);\r\n} else {\r\nra_list->is_11n_enabled = IS_11N_ENABLED(priv);\r\n}\r\n} else {\r\nspin_lock_irqsave(&priv->sta_list_spinlock, flags);\r\nnode = mwifiex_get_sta_entry(priv, ra);\r\nif (node)\r\nra_list->tx_paused = node->tx_pause;\r\nra_list->is_11n_enabled =\r\nmwifiex_is_sta_11n_enabled(priv, node);\r\nif (ra_list->is_11n_enabled)\r\nra_list->max_amsdu = node->max_amsdu;\r\nspin_unlock_irqrestore(&priv->sta_list_spinlock, flags);\r\n}\r\nmwifiex_dbg(adapter, DATA, "data: ralist %p: is_11n_enabled=%d\n",\r\nra_list, ra_list->is_11n_enabled);\r\nif (ra_list->is_11n_enabled) {\r\nra_list->ba_pkt_count = 0;\r\nra_list->ba_packet_thr =\r\nmwifiex_get_random_ba_threshold();\r\n}\r\nlist_add_tail(&ra_list->list,\r\n&priv->wmm.tid_tbl_ptr[i].ra_list);\r\n}\r\n}\r\nstatic void mwifiex_wmm_default_queue_priorities(struct mwifiex_private *priv)\r\n{\r\npriv->wmm.queue_priority[0] = WMM_AC_VO;\r\npriv->wmm.queue_priority[1] = WMM_AC_VI;\r\npriv->wmm.queue_priority[2] = WMM_AC_BE;\r\npriv->wmm.queue_priority[3] = WMM_AC_BK;\r\n}\r\nstatic void\r\nmwifiex_wmm_queue_priorities_tid(struct mwifiex_private *priv)\r\n{\r\nstruct mwifiex_wmm_desc *wmm = &priv->wmm;\r\nu8 *queue_priority = wmm->queue_priority;\r\nint i;\r\nfor (i = 0; i < 4; ++i) {\r\ntos_to_tid[7 - (i * 2)] = ac_to_tid[queue_priority[i]][1];\r\ntos_to_tid[6 - (i * 2)] = ac_to_tid[queue_priority[i]][0];\r\n}\r\nfor (i = 0; i < MAX_NUM_TID; ++i)\r\npriv->tos_to_tid_inv[tos_to_tid[i]] = (u8)i;\r\natomic_set(&wmm->highest_queued_prio, HIGH_PRIO_TID);\r\n}\r\nvoid\r\nmwifiex_wmm_setup_queue_priorities(struct mwifiex_private *priv,\r\nstruct ieee_types_wmm_parameter *wmm_ie)\r\n{\r\nu16 cw_min, avg_back_off, tmp[4];\r\nu32 i, j, num_ac;\r\nu8 ac_idx;\r\nif (!wmm_ie || !priv->wmm_enabled) {\r\nmwifiex_wmm_default_queue_priorities(priv);\r\nreturn;\r\n}\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: WMM Parameter IE: version=%d,\t"\r\n"qos_info Parameter Set Count=%d, Reserved=%#x\n",\r\nwmm_ie->vend_hdr.version, wmm_ie->qos_info_bitmap &\r\nIEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK,\r\nwmm_ie->reserved);\r\nfor (num_ac = 0; num_ac < ARRAY_SIZE(wmm_ie->ac_params); num_ac++) {\r\nu8 ecw = wmm_ie->ac_params[num_ac].ecw_bitmap;\r\nu8 aci_aifsn = wmm_ie->ac_params[num_ac].aci_aifsn_bitmap;\r\ncw_min = (1 << (ecw & MWIFIEX_ECW_MIN)) - 1;\r\navg_back_off = (cw_min >> 1) + (aci_aifsn & MWIFIEX_AIFSN);\r\nac_idx = wmm_aci_to_qidx_map[(aci_aifsn & MWIFIEX_ACI) >> 5];\r\npriv->wmm.queue_priority[ac_idx] = ac_idx;\r\ntmp[ac_idx] = avg_back_off;\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: WMM: CWmax=%d CWmin=%d Avg Back-off=%d\n",\r\n(1 << ((ecw & MWIFIEX_ECW_MAX) >> 4)) - 1,\r\ncw_min, avg_back_off);\r\nmwifiex_wmm_ac_debug_print(&wmm_ie->ac_params[num_ac]);\r\n}\r\nfor (i = 0; i < num_ac; i++) {\r\nfor (j = 1; j < num_ac - i; j++) {\r\nif (tmp[j - 1] > tmp[j]) {\r\nswap(tmp[j - 1], tmp[j]);\r\nswap(priv->wmm.queue_priority[j - 1],\r\npriv->wmm.queue_priority[j]);\r\n} else if (tmp[j - 1] == tmp[j]) {\r\nif (priv->wmm.queue_priority[j - 1]\r\n< priv->wmm.queue_priority[j])\r\nswap(priv->wmm.queue_priority[j - 1],\r\npriv->wmm.queue_priority[j]);\r\n}\r\n}\r\n}\r\nmwifiex_wmm_queue_priorities_tid(priv);\r\n}\r\nstatic enum mwifiex_wmm_ac_e\r\nmwifiex_wmm_eval_downgrade_ac(struct mwifiex_private *priv,\r\nenum mwifiex_wmm_ac_e eval_ac)\r\n{\r\nint down_ac;\r\nenum mwifiex_wmm_ac_e ret_ac;\r\nstruct mwifiex_wmm_ac_status *ac_status;\r\nac_status = &priv->wmm.ac_status[eval_ac];\r\nif (!ac_status->disabled)\r\nreturn eval_ac;\r\nret_ac = WMM_AC_BK;\r\nfor (down_ac = WMM_AC_BK; down_ac < eval_ac; down_ac++) {\r\nac_status = &priv->wmm.ac_status[down_ac];\r\nif (!ac_status->disabled && !ac_status->flow_required)\r\nret_ac = (enum mwifiex_wmm_ac_e) down_ac;\r\n}\r\nreturn ret_ac;\r\n}\r\nvoid\r\nmwifiex_wmm_setup_ac_downgrade(struct mwifiex_private *priv)\r\n{\r\nint ac_val;\r\nmwifiex_dbg(priv->adapter, INFO, "info: WMM: AC Priorities:\t"\r\n"BK(0), BE(1), VI(2), VO(3)\n");\r\nif (!priv->wmm_enabled) {\r\nfor (ac_val = WMM_AC_BK; ac_val <= WMM_AC_VO; ac_val++)\r\npriv->wmm.ac_down_graded_vals[ac_val] =\r\n(enum mwifiex_wmm_ac_e) ac_val;\r\n} else {\r\nfor (ac_val = WMM_AC_BK; ac_val <= WMM_AC_VO; ac_val++) {\r\npriv->wmm.ac_down_graded_vals[ac_val]\r\n= mwifiex_wmm_eval_downgrade_ac(priv,\r\n(enum mwifiex_wmm_ac_e) ac_val);\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: WMM: AC PRIO %d maps to %d\n",\r\nac_val,\r\npriv->wmm.ac_down_graded_vals[ac_val]);\r\n}\r\n}\r\n}\r\nstatic enum mwifiex_wmm_ac_e\r\nmwifiex_wmm_convert_tos_to_ac(struct mwifiex_adapter *adapter, u32 tos)\r\n{\r\nconst enum mwifiex_wmm_ac_e tos_to_ac[] = { WMM_AC_BE,\r\nWMM_AC_BK,\r\nWMM_AC_BK,\r\nWMM_AC_BE,\r\nWMM_AC_VI,\r\nWMM_AC_VI,\r\nWMM_AC_VO,\r\nWMM_AC_VO\r\n};\r\nif (tos >= ARRAY_SIZE(tos_to_ac))\r\nreturn WMM_AC_BE;\r\nreturn tos_to_ac[tos];\r\n}\r\nu8 mwifiex_wmm_downgrade_tid(struct mwifiex_private *priv, u32 tid)\r\n{\r\nenum mwifiex_wmm_ac_e ac, ac_down;\r\nu8 new_tid;\r\nac = mwifiex_wmm_convert_tos_to_ac(priv->adapter, tid);\r\nac_down = priv->wmm.ac_down_graded_vals[ac];\r\nnew_tid = ac_to_tid[ac_down][tid % 2];\r\nreturn new_tid;\r\n}\r\nvoid\r\nmwifiex_wmm_init(struct mwifiex_adapter *adapter)\r\n{\r\nint i, j;\r\nstruct mwifiex_private *priv;\r\nfor (j = 0; j < adapter->priv_num; ++j) {\r\npriv = adapter->priv[j];\r\nif (!priv)\r\ncontinue;\r\nfor (i = 0; i < MAX_NUM_TID; ++i) {\r\nif (!disable_tx_amsdu &&\r\nadapter->tx_buf_size > MWIFIEX_TX_DATA_BUF_SIZE_2K)\r\npriv->aggr_prio_tbl[i].amsdu =\r\npriv->tos_to_tid_inv[i];\r\nelse\r\npriv->aggr_prio_tbl[i].amsdu =\r\nBA_STREAM_NOT_ALLOWED;\r\npriv->aggr_prio_tbl[i].ampdu_ap =\r\npriv->tos_to_tid_inv[i];\r\npriv->aggr_prio_tbl[i].ampdu_user =\r\npriv->tos_to_tid_inv[i];\r\n}\r\npriv->aggr_prio_tbl[6].amsdu\r\n= priv->aggr_prio_tbl[6].ampdu_ap\r\n= priv->aggr_prio_tbl[6].ampdu_user\r\n= BA_STREAM_NOT_ALLOWED;\r\npriv->aggr_prio_tbl[7].amsdu = priv->aggr_prio_tbl[7].ampdu_ap\r\n= priv->aggr_prio_tbl[7].ampdu_user\r\n= BA_STREAM_NOT_ALLOWED;\r\nmwifiex_set_ba_params(priv);\r\nmwifiex_reset_11n_rx_seq_num(priv);\r\npriv->wmm.drv_pkt_delay_max = MWIFIEX_WMM_DRV_DELAY_MAX;\r\natomic_set(&priv->wmm.tx_pkts_queued, 0);\r\natomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\r\n}\r\n}\r\nint mwifiex_bypass_txlist_empty(struct mwifiex_adapter *adapter)\r\n{\r\nstruct mwifiex_private *priv;\r\nint i;\r\nfor (i = 0; i < adapter->priv_num; i++) {\r\npriv = adapter->priv[i];\r\nif (!priv)\r\ncontinue;\r\nif (adapter->if_ops.is_port_ready &&\r\n!adapter->if_ops.is_port_ready(priv))\r\ncontinue;\r\nif (!skb_queue_empty(&priv->bypass_txq))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nint\r\nmwifiex_wmm_lists_empty(struct mwifiex_adapter *adapter)\r\n{\r\nint i;\r\nstruct mwifiex_private *priv;\r\nfor (i = 0; i < adapter->priv_num; ++i) {\r\npriv = adapter->priv[i];\r\nif (!priv)\r\ncontinue;\r\nif (!priv->port_open &&\r\n(priv->bss_mode != NL80211_IFTYPE_ADHOC))\r\ncontinue;\r\nif (adapter->if_ops.is_port_ready &&\r\n!adapter->if_ops.is_port_ready(priv))\r\ncontinue;\r\nif (atomic_read(&priv->wmm.tx_pkts_queued))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void\r\nmwifiex_wmm_del_pkts_in_ralist_node(struct mwifiex_private *priv,\r\nstruct mwifiex_ra_list_tbl *ra_list)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct sk_buff *skb, *tmp;\r\nskb_queue_walk_safe(&ra_list->skb_head, skb, tmp) {\r\nskb_unlink(skb, &ra_list->skb_head);\r\nmwifiex_write_data_complete(adapter, skb, 0, -1);\r\n}\r\n}\r\nstatic void\r\nmwifiex_wmm_del_pkts_in_ralist(struct mwifiex_private *priv,\r\nstruct list_head *ra_list_head)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nlist_for_each_entry(ra_list, ra_list_head, list)\r\nmwifiex_wmm_del_pkts_in_ralist_node(priv, ra_list);\r\n}\r\nstatic void mwifiex_wmm_cleanup_queues(struct mwifiex_private *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_NUM_TID; i++)\r\nmwifiex_wmm_del_pkts_in_ralist(priv, &priv->wmm.tid_tbl_ptr[i].\r\nra_list);\r\natomic_set(&priv->wmm.tx_pkts_queued, 0);\r\natomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\r\n}\r\nstatic void mwifiex_wmm_delete_all_ralist(struct mwifiex_private *priv)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list, *tmp_node;\r\nint i;\r\nfor (i = 0; i < MAX_NUM_TID; ++i) {\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: ra_list: freeing buf for tid %d\n", i);\r\nlist_for_each_entry_safe(ra_list, tmp_node,\r\n&priv->wmm.tid_tbl_ptr[i].ra_list,\r\nlist) {\r\nlist_del(&ra_list->list);\r\nkfree(ra_list);\r\n}\r\nINIT_LIST_HEAD(&priv->wmm.tid_tbl_ptr[i].ra_list);\r\n}\r\n}\r\nstatic int mwifiex_free_ack_frame(int id, void *p, void *data)\r\n{\r\npr_warn("Have pending ack frames!\n");\r\nkfree_skb(p);\r\nreturn 0;\r\n}\r\nvoid\r\nmwifiex_clean_txrx(struct mwifiex_private *priv)\r\n{\r\nunsigned long flags;\r\nstruct sk_buff *skb, *tmp;\r\nmwifiex_11n_cleanup_reorder_tbl(priv);\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);\r\nmwifiex_wmm_cleanup_queues(priv);\r\nmwifiex_11n_delete_all_tx_ba_stream_tbl(priv);\r\nif (priv->adapter->if_ops.cleanup_mpa_buf)\r\npriv->adapter->if_ops.cleanup_mpa_buf(priv->adapter);\r\nmwifiex_wmm_delete_all_ralist(priv);\r\nmemcpy(tos_to_tid, ac_to_tid, sizeof(tos_to_tid));\r\nif (priv->adapter->if_ops.clean_pcie_ring &&\r\n!priv->adapter->surprise_removed)\r\npriv->adapter->if_ops.clean_pcie_ring(priv->adapter);\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);\r\nskb_queue_walk_safe(&priv->tdls_txq, skb, tmp) {\r\nskb_unlink(skb, &priv->tdls_txq);\r\nmwifiex_write_data_complete(priv->adapter, skb, 0, -1);\r\n}\r\nskb_queue_walk_safe(&priv->bypass_txq, skb, tmp) {\r\nskb_unlink(skb, &priv->bypass_txq);\r\nmwifiex_write_data_complete(priv->adapter, skb, 0, -1);\r\n}\r\natomic_set(&priv->adapter->bypass_tx_pending, 0);\r\nidr_for_each(&priv->ack_status_frames, mwifiex_free_ack_frame, NULL);\r\nidr_destroy(&priv->ack_status_frames);\r\n}\r\nstruct mwifiex_ra_list_tbl *\r\nmwifiex_wmm_get_ralist_node(struct mwifiex_private *priv, u8 tid,\r\nconst u8 *ra_addr)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nlist_for_each_entry(ra_list, &priv->wmm.tid_tbl_ptr[tid].ra_list,\r\nlist) {\r\nif (!memcmp(ra_list->ra, ra_addr, ETH_ALEN))\r\nreturn ra_list;\r\n}\r\nreturn NULL;\r\n}\r\nvoid mwifiex_update_ralist_tx_pause(struct mwifiex_private *priv, u8 *mac,\r\nu8 tx_pause)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nu32 pkt_cnt = 0, tx_pkts_queued;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);\r\nfor (i = 0; i < MAX_NUM_TID; ++i) {\r\nra_list = mwifiex_wmm_get_ralist_node(priv, i, mac);\r\nif (ra_list && ra_list->tx_paused != tx_pause) {\r\npkt_cnt += ra_list->total_pkt_count;\r\nra_list->tx_paused = tx_pause;\r\nif (tx_pause)\r\npriv->wmm.pkts_paused[i] +=\r\nra_list->total_pkt_count;\r\nelse\r\npriv->wmm.pkts_paused[i] -=\r\nra_list->total_pkt_count;\r\n}\r\n}\r\nif (pkt_cnt) {\r\ntx_pkts_queued = atomic_read(&priv->wmm.tx_pkts_queued);\r\nif (tx_pause)\r\ntx_pkts_queued -= pkt_cnt;\r\nelse\r\ntx_pkts_queued += pkt_cnt;\r\natomic_set(&priv->wmm.tx_pkts_queued, tx_pkts_queued);\r\natomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\r\n}\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);\r\n}\r\nvoid mwifiex_update_ralist_tx_pause_in_tdls_cs(struct mwifiex_private *priv,\r\nu8 *mac, u8 tx_pause)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nu32 pkt_cnt = 0, tx_pkts_queued;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);\r\nfor (i = 0; i < MAX_NUM_TID; ++i) {\r\nlist_for_each_entry(ra_list, &priv->wmm.tid_tbl_ptr[i].ra_list,\r\nlist) {\r\nif (!memcmp(ra_list->ra, mac, ETH_ALEN))\r\ncontinue;\r\nif (ra_list->tx_paused != tx_pause) {\r\npkt_cnt += ra_list->total_pkt_count;\r\nra_list->tx_paused = tx_pause;\r\nif (tx_pause)\r\npriv->wmm.pkts_paused[i] +=\r\nra_list->total_pkt_count;\r\nelse\r\npriv->wmm.pkts_paused[i] -=\r\nra_list->total_pkt_count;\r\n}\r\n}\r\n}\r\nif (pkt_cnt) {\r\ntx_pkts_queued = atomic_read(&priv->wmm.tx_pkts_queued);\r\nif (tx_pause)\r\ntx_pkts_queued -= pkt_cnt;\r\nelse\r\ntx_pkts_queued += pkt_cnt;\r\natomic_set(&priv->wmm.tx_pkts_queued, tx_pkts_queued);\r\natomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\r\n}\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);\r\n}\r\nstruct mwifiex_ra_list_tbl *\r\nmwifiex_wmm_get_queue_raptr(struct mwifiex_private *priv, u8 tid,\r\nconst u8 *ra_addr)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nra_list = mwifiex_wmm_get_ralist_node(priv, tid, ra_addr);\r\nif (ra_list)\r\nreturn ra_list;\r\nmwifiex_ralist_add(priv, ra_addr);\r\nreturn mwifiex_wmm_get_ralist_node(priv, tid, ra_addr);\r\n}\r\nvoid\r\nmwifiex_wmm_del_peer_ra_list(struct mwifiex_private *priv, const u8 *ra_addr)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);\r\nfor (i = 0; i < MAX_NUM_TID; ++i) {\r\nra_list = mwifiex_wmm_get_ralist_node(priv, i, ra_addr);\r\nif (!ra_list)\r\ncontinue;\r\nmwifiex_wmm_del_pkts_in_ralist_node(priv, ra_list);\r\nif (ra_list->tx_paused)\r\npriv->wmm.pkts_paused[i] -= ra_list->total_pkt_count;\r\nelse\r\natomic_sub(ra_list->total_pkt_count,\r\n&priv->wmm.tx_pkts_queued);\r\nlist_del(&ra_list->list);\r\nkfree(ra_list);\r\n}\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);\r\n}\r\nint\r\nmwifiex_is_ralist_valid(struct mwifiex_private *priv,\r\nstruct mwifiex_ra_list_tbl *ra_list, int ptr_index)\r\n{\r\nstruct mwifiex_ra_list_tbl *rlist;\r\nlist_for_each_entry(rlist, &priv->wmm.tid_tbl_ptr[ptr_index].ra_list,\r\nlist) {\r\nif (rlist == ra_list)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid\r\nmwifiex_wmm_add_buf_bypass_txqueue(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nskb_queue_tail(&priv->bypass_txq, skb);\r\n}\r\nvoid\r\nmwifiex_wmm_add_buf_txqueue(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nu32 tid;\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nu8 ra[ETH_ALEN], tid_down;\r\nunsigned long flags;\r\nstruct list_head list_head;\r\nint tdls_status = TDLS_NOT_SETUP;\r\nstruct ethhdr *eth_hdr = (struct ethhdr *)skb->data;\r\nstruct mwifiex_txinfo *tx_info = MWIFIEX_SKB_TXCB(skb);\r\nmemcpy(ra, eth_hdr->h_dest, ETH_ALEN);\r\nif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA &&\r\nISSUPP_TDLS_ENABLED(adapter->fw_cap_info)) {\r\nif (ntohs(eth_hdr->h_proto) == ETH_P_TDLS)\r\nmwifiex_dbg(adapter, DATA,\r\n"TDLS setup packet for %pM.\t"\r\n"Don't block\n", ra);\r\nelse if (memcmp(priv->cfg_bssid, ra, ETH_ALEN))\r\ntdls_status = mwifiex_get_tdls_link_status(priv, ra);\r\n}\r\nif (!priv->media_connected && !mwifiex_is_skb_mgmt_frame(skb)) {\r\nmwifiex_dbg(adapter, DATA, "data: drop packet in disconnect\n");\r\nmwifiex_write_data_complete(adapter, skb, 0, -1);\r\nreturn;\r\n}\r\ntid = skb->priority;\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);\r\ntid_down = mwifiex_wmm_downgrade_tid(priv, tid);\r\nif (!mwifiex_queuing_ra_based(priv) &&\r\n!mwifiex_is_skb_mgmt_frame(skb)) {\r\nswitch (tdls_status) {\r\ncase TDLS_SETUP_COMPLETE:\r\ncase TDLS_CHAN_SWITCHING:\r\ncase TDLS_IN_BASE_CHAN:\r\ncase TDLS_IN_OFF_CHAN:\r\nra_list = mwifiex_wmm_get_queue_raptr(priv, tid_down,\r\nra);\r\ntx_info->flags |= MWIFIEX_BUF_FLAG_TDLS_PKT;\r\nbreak;\r\ncase TDLS_SETUP_INPROGRESS:\r\nskb_queue_tail(&priv->tdls_txq, skb);\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock,\r\nflags);\r\nreturn;\r\ndefault:\r\nlist_head = priv->wmm.tid_tbl_ptr[tid_down].ra_list;\r\nra_list = list_first_entry_or_null(&list_head,\r\nstruct mwifiex_ra_list_tbl, list);\r\nbreak;\r\n}\r\n} else {\r\nmemcpy(ra, skb->data, ETH_ALEN);\r\nif (ra[0] & 0x01 || mwifiex_is_skb_mgmt_frame(skb))\r\neth_broadcast_addr(ra);\r\nra_list = mwifiex_wmm_get_queue_raptr(priv, tid_down, ra);\r\n}\r\nif (!ra_list) {\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);\r\nmwifiex_write_data_complete(adapter, skb, 0, -1);\r\nreturn;\r\n}\r\nskb_queue_tail(&ra_list->skb_head, skb);\r\nra_list->ba_pkt_count++;\r\nra_list->total_pkt_count++;\r\nif (atomic_read(&priv->wmm.highest_queued_prio) <\r\npriv->tos_to_tid_inv[tid_down])\r\natomic_set(&priv->wmm.highest_queued_prio,\r\npriv->tos_to_tid_inv[tid_down]);\r\nif (ra_list->tx_paused)\r\npriv->wmm.pkts_paused[tid_down]++;\r\nelse\r\natomic_inc(&priv->wmm.tx_pkts_queued);\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);\r\n}\r\nint mwifiex_ret_wmm_get_status(struct mwifiex_private *priv,\r\nconst struct host_cmd_ds_command *resp)\r\n{\r\nu8 *curr = (u8 *) &resp->params.get_wmm_status;\r\nuint16_t resp_len = le16_to_cpu(resp->size), tlv_len;\r\nint mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK;\r\nbool valid = true;\r\nstruct mwifiex_ie_types_data *tlv_hdr;\r\nstruct mwifiex_ie_types_wmm_queue_status *tlv_wmm_qstatus;\r\nstruct ieee_types_wmm_parameter *wmm_param_ie = NULL;\r\nstruct mwifiex_wmm_ac_status *ac_status;\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: WMM: WMM_GET_STATUS cmdresp received: %d\n",\r\nresp_len);\r\nwhile ((resp_len >= sizeof(tlv_hdr->header)) && valid) {\r\ntlv_hdr = (struct mwifiex_ie_types_data *) curr;\r\ntlv_len = le16_to_cpu(tlv_hdr->header.len);\r\nif (resp_len < tlv_len + sizeof(tlv_hdr->header))\r\nbreak;\r\nswitch (le16_to_cpu(tlv_hdr->header.type)) {\r\ncase TLV_TYPE_WMMQSTATUS:\r\ntlv_wmm_qstatus =\r\n(struct mwifiex_ie_types_wmm_queue_status *)\r\ntlv_hdr;\r\nmwifiex_dbg(priv->adapter, CMD,\r\n"info: CMD_RESP: WMM_GET_STATUS:\t"\r\n"QSTATUS TLV: %d, %d, %d\n",\r\ntlv_wmm_qstatus->queue_index,\r\ntlv_wmm_qstatus->flow_required,\r\ntlv_wmm_qstatus->disabled);\r\nac_status = &priv->wmm.ac_status[tlv_wmm_qstatus->\r\nqueue_index];\r\nac_status->disabled = tlv_wmm_qstatus->disabled;\r\nac_status->flow_required =\r\ntlv_wmm_qstatus->flow_required;\r\nac_status->flow_created = tlv_wmm_qstatus->flow_created;\r\nbreak;\r\ncase WLAN_EID_VENDOR_SPECIFIC:\r\nwmm_param_ie =\r\n(struct ieee_types_wmm_parameter *) (curr +\r\n2);\r\nwmm_param_ie->vend_hdr.len = (u8) tlv_len;\r\nwmm_param_ie->vend_hdr.element_id =\r\nWLAN_EID_VENDOR_SPECIFIC;\r\nmwifiex_dbg(priv->adapter, CMD,\r\n"info: CMD_RESP: WMM_GET_STATUS:\t"\r\n"WMM Parameter Set Count: %d\n",\r\nwmm_param_ie->qos_info_bitmap & mask);\r\nmemcpy((u8 *) &priv->curr_bss_params.bss_descriptor.\r\nwmm_ie, wmm_param_ie,\r\nwmm_param_ie->vend_hdr.len + 2);\r\nbreak;\r\ndefault:\r\nvalid = false;\r\nbreak;\r\n}\r\ncurr += (tlv_len + sizeof(tlv_hdr->header));\r\nresp_len -= (tlv_len + sizeof(tlv_hdr->header));\r\n}\r\nmwifiex_wmm_setup_queue_priorities(priv, wmm_param_ie);\r\nmwifiex_wmm_setup_ac_downgrade(priv);\r\nreturn 0;\r\n}\r\nu32\r\nmwifiex_wmm_process_association_req(struct mwifiex_private *priv,\r\nu8 **assoc_buf,\r\nstruct ieee_types_wmm_parameter *wmm_ie,\r\nstruct ieee80211_ht_cap *ht_cap)\r\n{\r\nstruct mwifiex_ie_types_wmm_param_set *wmm_tlv;\r\nu32 ret_len = 0;\r\nif (!assoc_buf)\r\nreturn 0;\r\nif (!(*assoc_buf))\r\nreturn 0;\r\nif (!wmm_ie)\r\nreturn 0;\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: WMM: process assoc req: bss->wmm_ie=%#x\n",\r\nwmm_ie->vend_hdr.element_id);\r\nif ((priv->wmm_required ||\r\n(ht_cap && (priv->adapter->config_bands & BAND_GN ||\r\npriv->adapter->config_bands & BAND_AN))) &&\r\nwmm_ie->vend_hdr.element_id == WLAN_EID_VENDOR_SPECIFIC) {\r\nwmm_tlv = (struct mwifiex_ie_types_wmm_param_set *) *assoc_buf;\r\nwmm_tlv->header.type = cpu_to_le16((u16) wmm_info_ie[0]);\r\nwmm_tlv->header.len = cpu_to_le16((u16) wmm_info_ie[1]);\r\nmemcpy(wmm_tlv->wmm_ie, &wmm_info_ie[2],\r\nle16_to_cpu(wmm_tlv->header.len));\r\nif (wmm_ie->qos_info_bitmap & IEEE80211_WMM_IE_AP_QOSINFO_UAPSD)\r\nmemcpy((u8 *) (wmm_tlv->wmm_ie\r\n+ le16_to_cpu(wmm_tlv->header.len)\r\n- sizeof(priv->wmm_qosinfo)),\r\n&priv->wmm_qosinfo, sizeof(priv->wmm_qosinfo));\r\nret_len = sizeof(wmm_tlv->header)\r\n+ le16_to_cpu(wmm_tlv->header.len);\r\n*assoc_buf += ret_len;\r\n}\r\nreturn ret_len;\r\n}\r\nu8\r\nmwifiex_wmm_compute_drv_pkt_delay(struct mwifiex_private *priv,\r\nconst struct sk_buff *skb)\r\n{\r\nu32 queue_delay = ktime_to_ms(net_timedelta(skb->tstamp));\r\nu8 ret_val;\r\nret_val = (u8) (min(queue_delay, priv->wmm.drv_pkt_delay_max) >> 1);\r\nmwifiex_dbg(priv->adapter, DATA, "data: WMM: Pkt Delay: %d ms,\t"\r\n"%d ms sent to FW\n", queue_delay, ret_val);\r\nreturn ret_val;\r\n}\r\nstatic struct mwifiex_ra_list_tbl *\r\nmwifiex_wmm_get_highest_priolist_ptr(struct mwifiex_adapter *adapter,\r\nstruct mwifiex_private **priv, int *tid)\r\n{\r\nstruct mwifiex_private *priv_tmp;\r\nstruct mwifiex_ra_list_tbl *ptr;\r\nstruct mwifiex_tid_tbl *tid_ptr;\r\natomic_t *hqp;\r\nunsigned long flags_ra;\r\nint i, j;\r\nfor (j = adapter->priv_num - 1; j >= 0; --j) {\r\nlist_for_each_entry(adapter->bss_prio_tbl[j].bss_prio_cur,\r\n&adapter->bss_prio_tbl[j].bss_prio_head,\r\nlist) {\r\ntry_again:\r\npriv_tmp = adapter->bss_prio_tbl[j].bss_prio_cur->priv;\r\nif (((priv_tmp->bss_mode != NL80211_IFTYPE_ADHOC) &&\r\n!priv_tmp->port_open) ||\r\n(atomic_read(&priv_tmp->wmm.tx_pkts_queued) == 0))\r\ncontinue;\r\nif (adapter->if_ops.is_port_ready &&\r\n!adapter->if_ops.is_port_ready(priv_tmp))\r\ncontinue;\r\nhqp = &priv_tmp->wmm.highest_queued_prio;\r\nfor (i = atomic_read(hqp); i >= LOW_PRIO_TID; --i) {\r\nspin_lock_irqsave(&priv_tmp->wmm.\r\nra_list_spinlock, flags_ra);\r\ntid_ptr = &(priv_tmp)->wmm.\r\ntid_tbl_ptr[tos_to_tid[i]];\r\nlist_for_each_entry(ptr, &tid_ptr->ra_list,\r\nlist) {\r\nif (!ptr->tx_paused &&\r\n!skb_queue_empty(&ptr->skb_head))\r\ngoto found;\r\n}\r\nspin_unlock_irqrestore(&priv_tmp->wmm.\r\nra_list_spinlock,\r\nflags_ra);\r\n}\r\nif (atomic_read(&priv_tmp->wmm.tx_pkts_queued) != 0) {\r\natomic_set(&priv_tmp->wmm.highest_queued_prio,\r\nHIGH_PRIO_TID);\r\ngoto try_again;\r\n} else\r\natomic_set(&priv_tmp->wmm.highest_queued_prio,\r\nNO_PKT_PRIO_TID);\r\n}\r\n}\r\nreturn NULL;\r\nfound:\r\nif (atomic_read(hqp) > i)\r\natomic_set(hqp, i);\r\nspin_unlock_irqrestore(&priv_tmp->wmm.ra_list_spinlock, flags_ra);\r\n*priv = priv_tmp;\r\n*tid = tos_to_tid[i];\r\nreturn ptr;\r\n}\r\nvoid mwifiex_rotate_priolists(struct mwifiex_private *priv,\r\nstruct mwifiex_ra_list_tbl *ra,\r\nint tid)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct mwifiex_bss_prio_tbl *tbl = adapter->bss_prio_tbl;\r\nstruct mwifiex_tid_tbl *tid_ptr = &priv->wmm.tid_tbl_ptr[tid];\r\nunsigned long flags;\r\nspin_lock_irqsave(&tbl[priv->bss_priority].bss_prio_lock, flags);\r\nlist_move(&tbl[priv->bss_priority].bss_prio_head,\r\n&tbl[priv->bss_priority].bss_prio_cur->list);\r\nspin_unlock_irqrestore(&tbl[priv->bss_priority].bss_prio_lock, flags);\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);\r\nif (mwifiex_is_ralist_valid(priv, ra, tid)) {\r\npriv->wmm.packets_out[tid]++;\r\nlist_move(&tid_ptr->ra_list, &ra->list);\r\n}\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);\r\n}\r\nstatic int\r\nmwifiex_is_11n_aggragation_possible(struct mwifiex_private *priv,\r\nstruct mwifiex_ra_list_tbl *ptr,\r\nint max_buf_size)\r\n{\r\nint count = 0, total_size = 0;\r\nstruct sk_buff *skb, *tmp;\r\nint max_amsdu_size;\r\nif (priv->bss_role == MWIFIEX_BSS_ROLE_UAP && priv->ap_11n_enabled &&\r\nptr->is_11n_enabled)\r\nmax_amsdu_size = min_t(int, ptr->max_amsdu, max_buf_size);\r\nelse\r\nmax_amsdu_size = max_buf_size;\r\nskb_queue_walk_safe(&ptr->skb_head, skb, tmp) {\r\ntotal_size += skb->len;\r\nif (total_size >= max_amsdu_size)\r\nbreak;\r\nif (++count >= MIN_NUM_AMSDU)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void\r\nmwifiex_send_single_packet(struct mwifiex_private *priv,\r\nstruct mwifiex_ra_list_tbl *ptr, int ptr_index,\r\nunsigned long ra_list_flags)\r\n__releases(&priv->wmm.ra_list_spinlock\r\nstatic int\r\nmwifiex_is_ptr_processed(struct mwifiex_private *priv,\r\nstruct mwifiex_ra_list_tbl *ptr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct mwifiex_txinfo *tx_info;\r\nif (skb_queue_empty(&ptr->skb_head))\r\nreturn false;\r\nskb = skb_peek(&ptr->skb_head);\r\ntx_info = MWIFIEX_SKB_TXCB(skb);\r\nif (tx_info->flags & MWIFIEX_BUF_FLAG_REQUEUED_PKT)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void\r\nmwifiex_send_processed_packet(struct mwifiex_private *priv,\r\nstruct mwifiex_ra_list_tbl *ptr, int ptr_index,\r\nunsigned long ra_list_flags)\r\n__releases(&priv->wmm.ra_list_spinlock\r\nstatic int\r\nmwifiex_dequeue_tx_packet(struct mwifiex_adapter *adapter)\r\n{\r\nstruct mwifiex_ra_list_tbl *ptr;\r\nstruct mwifiex_private *priv = NULL;\r\nint ptr_index = 0;\r\nu8 ra[ETH_ALEN];\r\nint tid_del = 0, tid = 0;\r\nunsigned long flags;\r\nptr = mwifiex_wmm_get_highest_priolist_ptr(adapter, &priv, &ptr_index);\r\nif (!ptr)\r\nreturn -1;\r\ntid = mwifiex_get_tid(ptr);\r\nmwifiex_dbg(adapter, DATA, "data: tid=%d\n", tid);\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);\r\nif (!mwifiex_is_ralist_valid(priv, ptr, ptr_index)) {\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);\r\nreturn -1;\r\n}\r\nif (mwifiex_is_ptr_processed(priv, ptr)) {\r\nmwifiex_send_processed_packet(priv, ptr, ptr_index, flags);\r\nreturn 0;\r\n}\r\nif (!ptr->is_11n_enabled ||\r\nptr->ba_status ||\r\npriv->wps.session_enable) {\r\nif (ptr->is_11n_enabled &&\r\nptr->ba_status &&\r\nptr->amsdu_in_ampdu &&\r\nmwifiex_is_amsdu_allowed(priv, tid) &&\r\nmwifiex_is_11n_aggragation_possible(priv, ptr,\r\nadapter->tx_buf_size))\r\nmwifiex_11n_aggregate_pkt(priv, ptr, ptr_index, flags);\r\nelse\r\nmwifiex_send_single_packet(priv, ptr, ptr_index, flags);\r\n} else {\r\nif (mwifiex_is_ampdu_allowed(priv, ptr, tid) &&\r\nptr->ba_pkt_count > ptr->ba_packet_thr) {\r\nif (mwifiex_space_avail_for_new_ba_stream(adapter)) {\r\nmwifiex_create_ba_tbl(priv, ptr->ra, tid,\r\nBA_SETUP_INPROGRESS);\r\nmwifiex_send_addba(priv, tid, ptr->ra);\r\n} else if (mwifiex_find_stream_to_delete\r\n(priv, tid, &tid_del, ra)) {\r\nmwifiex_create_ba_tbl(priv, ptr->ra, tid,\r\nBA_SETUP_INPROGRESS);\r\nmwifiex_send_delba(priv, tid_del, ra, 1);\r\n}\r\n}\r\nif (mwifiex_is_amsdu_allowed(priv, tid) &&\r\nmwifiex_is_11n_aggragation_possible(priv, ptr,\r\nadapter->tx_buf_size))\r\nmwifiex_11n_aggregate_pkt(priv, ptr, ptr_index, flags);\r\nelse\r\nmwifiex_send_single_packet(priv, ptr, ptr_index, flags);\r\n}\r\nreturn 0;\r\n}\r\nvoid mwifiex_process_bypass_tx(struct mwifiex_adapter *adapter)\r\n{\r\nstruct mwifiex_tx_param tx_param;\r\nstruct sk_buff *skb;\r\nstruct mwifiex_txinfo *tx_info;\r\nstruct mwifiex_private *priv;\r\nint i;\r\nif (adapter->data_sent || adapter->tx_lock_flag)\r\nreturn;\r\nfor (i = 0; i < adapter->priv_num; ++i) {\r\npriv = adapter->priv[i];\r\nif (!priv)\r\ncontinue;\r\nif (adapter->if_ops.is_port_ready &&\r\n!adapter->if_ops.is_port_ready(priv))\r\ncontinue;\r\nif (skb_queue_empty(&priv->bypass_txq))\r\ncontinue;\r\nskb = skb_dequeue(&priv->bypass_txq);\r\ntx_info = MWIFIEX_SKB_TXCB(skb);\r\ntx_param.next_pkt_len = 0;\r\nif (mwifiex_process_tx(priv, skb, &tx_param) == -EBUSY) {\r\nskb_queue_head(&priv->bypass_txq, skb);\r\ntx_info->flags |= MWIFIEX_BUF_FLAG_REQUEUED_PKT;\r\n} else {\r\natomic_dec(&adapter->bypass_tx_pending);\r\n}\r\n}\r\n}\r\nvoid\r\nmwifiex_wmm_process_tx(struct mwifiex_adapter *adapter)\r\n{\r\ndo {\r\nif (mwifiex_dequeue_tx_packet(adapter))\r\nbreak;\r\nif (adapter->iface_type != MWIFIEX_SDIO) {\r\nif (adapter->data_sent ||\r\nadapter->tx_lock_flag)\r\nbreak;\r\n} else {\r\nif (atomic_read(&adapter->tx_queued) >=\r\nMWIFIEX_MAX_PKTS_TXQ)\r\nbreak;\r\n}\r\n} while (!mwifiex_wmm_lists_empty(adapter));\r\n}
