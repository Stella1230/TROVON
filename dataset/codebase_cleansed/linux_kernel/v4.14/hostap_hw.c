static u16 hfa384x_read_reg(struct net_device *dev, u16 reg)\r\n{\r\nreturn HFA384X_INW(reg);\r\n}\r\nstatic void hfa384x_read_regs(struct net_device *dev,\r\nstruct hfa384x_regs *regs)\r\n{\r\nregs->cmd = HFA384X_INW(HFA384X_CMD_OFF);\r\nregs->evstat = HFA384X_INW(HFA384X_EVSTAT_OFF);\r\nregs->offset0 = HFA384X_INW(HFA384X_OFFSET0_OFF);\r\nregs->offset1 = HFA384X_INW(HFA384X_OFFSET1_OFF);\r\nregs->swsupport0 = HFA384X_INW(HFA384X_SWSUPPORT0_OFF);\r\n}\r\nstatic inline void __hostap_cmd_queue_free(local_info_t *local,\r\nstruct hostap_cmd_queue *entry,\r\nint del_req)\r\n{\r\nif (del_req) {\r\nentry->del_req = 1;\r\nif (!list_empty(&entry->list)) {\r\nlist_del_init(&entry->list);\r\nlocal->cmd_queue_len--;\r\n}\r\n}\r\nif (refcount_dec_and_test(&entry->usecnt) && entry->del_req)\r\nkfree(entry);\r\n}\r\nstatic inline void hostap_cmd_queue_free(local_info_t *local,\r\nstruct hostap_cmd_queue *entry,\r\nint del_req)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&local->cmdlock, flags);\r\n__hostap_cmd_queue_free(local, entry, del_req);\r\nspin_unlock_irqrestore(&local->cmdlock, flags);\r\n}\r\nstatic void prism2_clear_cmd_queue(local_info_t *local)\r\n{\r\nstruct list_head *ptr, *n;\r\nunsigned long flags;\r\nstruct hostap_cmd_queue *entry;\r\nspin_lock_irqsave(&local->cmdlock, flags);\r\nlist_for_each_safe(ptr, n, &local->cmd_queue) {\r\nentry = list_entry(ptr, struct hostap_cmd_queue, list);\r\nrefcount_inc(&entry->usecnt);\r\nprintk(KERN_DEBUG "%s: removed pending cmd_queue entry "\r\n"(type=%d, cmd=0x%04x, param0=0x%04x)\n",\r\nlocal->dev->name, entry->type, entry->cmd,\r\nentry->param0);\r\n__hostap_cmd_queue_free(local, entry, 1);\r\n}\r\nif (local->cmd_queue_len) {\r\nprintk(KERN_DEBUG "%s: cmd_queue_len (%d) not zero after "\r\n"flush\n", local->dev->name, local->cmd_queue_len);\r\nlocal->cmd_queue_len = 0;\r\n}\r\nspin_unlock_irqrestore(&local->cmdlock, flags);\r\n}\r\nstatic int hfa384x_cmd_issue(struct net_device *dev,\r\nstruct hostap_cmd_queue *entry)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint tries;\r\nu16 reg;\r\nunsigned long flags;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->func->card_present && !local->func->card_present(local))\r\nreturn -ENODEV;\r\nif (entry->issued) {\r\nprintk(KERN_DEBUG "%s: driver bug - re-issuing command @%p\n",\r\ndev->name, entry);\r\n}\r\ntries = HFA384X_CMD_BUSY_TIMEOUT;\r\nwhile (HFA384X_INW(HFA384X_CMD_OFF) & HFA384X_CMD_BUSY && tries > 0) {\r\ntries--;\r\nudelay(1);\r\n}\r\n#ifndef final_version\r\nif (tries != HFA384X_CMD_BUSY_TIMEOUT) {\r\nprism2_io_debug_error(dev, 1);\r\nprintk(KERN_DEBUG "%s: hfa384x_cmd_issue: cmd reg was busy "\r\n"for %d usec\n", dev->name,\r\nHFA384X_CMD_BUSY_TIMEOUT - tries);\r\n}\r\n#endif\r\nif (tries == 0) {\r\nreg = HFA384X_INW(HFA384X_CMD_OFF);\r\nprism2_io_debug_error(dev, 2);\r\nprintk(KERN_DEBUG "%s: hfa384x_cmd_issue - timeout - "\r\n"reg=0x%04x\n", dev->name, reg);\r\nreturn -ETIMEDOUT;\r\n}\r\nspin_lock_irqsave(&local->cmdlock, flags);\r\nHFA384X_OUTW(entry->param0, HFA384X_PARAM0_OFF);\r\nHFA384X_OUTW(entry->param1, HFA384X_PARAM1_OFF);\r\nHFA384X_OUTW(entry->cmd, HFA384X_CMD_OFF);\r\nentry->issued = 1;\r\nspin_unlock_irqrestore(&local->cmdlock, flags);\r\nreturn 0;\r\n}\r\nstatic int hfa384x_cmd(struct net_device *dev, u16 cmd, u16 param0,\r\nu16 *param1, u16 *resp0)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint err, res, issue, issued = 0;\r\nunsigned long flags;\r\nstruct hostap_cmd_queue *entry;\r\nDECLARE_WAITQUEUE(wait, current);\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (in_interrupt()) {\r\nprintk(KERN_DEBUG "%s: hfa384x_cmd called from interrupt "\r\n"context\n", dev->name);\r\nreturn -1;\r\n}\r\nif (local->cmd_queue_len >= HOSTAP_CMD_QUEUE_MAX_LEN) {\r\nprintk(KERN_DEBUG "%s: hfa384x_cmd: cmd_queue full\n",\r\ndev->name);\r\nreturn -1;\r\n}\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nrefcount_set(&entry->usecnt, 1);\r\nentry->type = CMD_SLEEP;\r\nentry->cmd = cmd;\r\nentry->param0 = param0;\r\nif (param1)\r\nentry->param1 = *param1;\r\ninit_waitqueue_head(&entry->compl);\r\nadd_wait_queue(&entry->compl, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_lock_irqsave(&local->cmdlock, flags);\r\nissue = list_empty(&local->cmd_queue);\r\nif (issue)\r\nentry->issuing = 1;\r\nlist_add_tail(&entry->list, &local->cmd_queue);\r\nlocal->cmd_queue_len++;\r\nspin_unlock_irqrestore(&local->cmdlock, flags);\r\nerr = 0;\r\nif (!issue)\r\ngoto wait_completion;\r\nif (signal_pending(current))\r\nerr = -EINTR;\r\nif (!err) {\r\nif (hfa384x_cmd_issue(dev, entry))\r\nerr = -ETIMEDOUT;\r\nelse\r\nissued = 1;\r\n}\r\nwait_completion:\r\nif (!err && entry->type != CMD_COMPLETED) {\r\nres = schedule_timeout(2 * HZ);\r\n} else\r\nres = -1;\r\nif (!err && signal_pending(current))\r\nerr = -EINTR;\r\nif (err && issued) {\r\nudelay(300);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&entry->compl, &wait);\r\nspin_lock_irqsave(&local->cmdlock, flags);\r\nif (!list_empty(&entry->list)) {\r\nprintk(KERN_DEBUG "%s: hfa384x_cmd: entry still in list? "\r\n"(entry=%p, type=%d, res=%d)\n", dev->name, entry,\r\nentry->type, res);\r\nlist_del_init(&entry->list);\r\nlocal->cmd_queue_len--;\r\n}\r\nspin_unlock_irqrestore(&local->cmdlock, flags);\r\nif (err) {\r\nprintk(KERN_DEBUG "%s: hfa384x_cmd: interrupted; err=%d\n",\r\ndev->name, err);\r\nres = err;\r\ngoto done;\r\n}\r\nif (entry->type != CMD_COMPLETED) {\r\nu16 reg = HFA384X_INW(HFA384X_EVSTAT_OFF);\r\nprintk(KERN_DEBUG "%s: hfa384x_cmd: command was not "\r\n"completed (res=%d, entry=%p, type=%d, cmd=0x%04x, "\r\n"param0=0x%04x, EVSTAT=%04x INTEN=%04x)\n", dev->name,\r\nres, entry, entry->type, entry->cmd, entry->param0, reg,\r\nHFA384X_INW(HFA384X_INTEN_OFF));\r\nif (reg & HFA384X_EV_CMD) {\r\nprintk(KERN_WARNING "%s: interrupt delivery does not "\r\n"seem to work\n", dev->name);\r\n}\r\nprism2_io_debug_error(dev, 3);\r\nres = -ETIMEDOUT;\r\ngoto done;\r\n}\r\nif (resp0 != NULL)\r\n*resp0 = entry->resp0;\r\n#ifndef final_version\r\nif (entry->res) {\r\nprintk(KERN_DEBUG "%s: CMD=0x%04x => res=0x%02x, "\r\n"resp0=0x%04x\n",\r\ndev->name, cmd, entry->res, entry->resp0);\r\n}\r\n#endif\r\nres = entry->res;\r\ndone:\r\nhostap_cmd_queue_free(local, entry, 1);\r\nreturn res;\r\n}\r\nstatic int hfa384x_cmd_callback(struct net_device *dev, u16 cmd, u16 param0,\r\nvoid (*callback)(struct net_device *dev,\r\nlong context, u16 resp0,\r\nu16 status),\r\nlong context)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint issue, ret;\r\nunsigned long flags;\r\nstruct hostap_cmd_queue *entry;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->cmd_queue_len >= HOSTAP_CMD_QUEUE_MAX_LEN + 2) {\r\nprintk(KERN_DEBUG "%s: hfa384x_cmd: cmd_queue full\n",\r\ndev->name);\r\nreturn -1;\r\n}\r\nentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nrefcount_set(&entry->usecnt, 1);\r\nentry->type = CMD_CALLBACK;\r\nentry->cmd = cmd;\r\nentry->param0 = param0;\r\nentry->callback = callback;\r\nentry->context = context;\r\nspin_lock_irqsave(&local->cmdlock, flags);\r\nissue = list_empty(&local->cmd_queue);\r\nif (issue)\r\nentry->issuing = 1;\r\nlist_add_tail(&entry->list, &local->cmd_queue);\r\nlocal->cmd_queue_len++;\r\nspin_unlock_irqrestore(&local->cmdlock, flags);\r\nif (issue && hfa384x_cmd_issue(dev, entry))\r\nret = -ETIMEDOUT;\r\nelse\r\nret = 0;\r\nhostap_cmd_queue_free(local, entry, ret);\r\nreturn ret;\r\n}\r\nstatic int __hfa384x_cmd_no_wait(struct net_device *dev, u16 cmd, u16 param0,\r\nint io_debug_num)\r\n{\r\nint tries;\r\nu16 reg;\r\ntries = HFA384X_CMD_BUSY_TIMEOUT;\r\nwhile (HFA384X_INW(HFA384X_CMD_OFF) & HFA384X_CMD_BUSY && tries > 0) {\r\ntries--;\r\nudelay(1);\r\n}\r\nif (tries == 0) {\r\nreg = HFA384X_INW(HFA384X_CMD_OFF);\r\nprism2_io_debug_error(dev, io_debug_num);\r\nprintk(KERN_DEBUG "%s: __hfa384x_cmd_no_wait(%d) - timeout - "\r\n"reg=0x%04x\n", dev->name, io_debug_num, reg);\r\nreturn -ETIMEDOUT;\r\n}\r\nHFA384X_OUTW(param0, HFA384X_PARAM0_OFF);\r\nHFA384X_OUTW(cmd, HFA384X_CMD_OFF);\r\nreturn 0;\r\n}\r\nstatic int hfa384x_cmd_wait(struct net_device *dev, u16 cmd, u16 param0)\r\n{\r\nint res, tries;\r\nu16 reg;\r\nres = __hfa384x_cmd_no_wait(dev, cmd, param0, 4);\r\nif (res)\r\nreturn res;\r\nif ((cmd & HFA384X_CMDCODE_MASK) == HFA384X_CMDCODE_DOWNLOAD)\r\ntries = HFA384X_DL_COMPL_TIMEOUT;\r\nelse\r\ntries = HFA384X_CMD_COMPL_TIMEOUT;\r\nwhile (!(HFA384X_INW(HFA384X_EVSTAT_OFF) & HFA384X_EV_CMD) &&\r\ntries > 0) {\r\ntries--;\r\nudelay(10);\r\n}\r\nif (tries == 0) {\r\nreg = HFA384X_INW(HFA384X_EVSTAT_OFF);\r\nprism2_io_debug_error(dev, 5);\r\nprintk(KERN_DEBUG "%s: hfa384x_cmd_wait - timeout2 - "\r\n"reg=0x%04x\n", dev->name, reg);\r\nreturn -ETIMEDOUT;\r\n}\r\nres = (HFA384X_INW(HFA384X_STATUS_OFF) &\r\n(BIT(14) | BIT(13) | BIT(12) | BIT(11) | BIT(10) | BIT(9) |\r\nBIT(8))) >> 8;\r\n#ifndef final_version\r\nif (res) {\r\nprintk(KERN_DEBUG "%s: CMD=0x%04x => res=0x%02x\n",\r\ndev->name, cmd, res);\r\n}\r\n#endif\r\nHFA384X_OUTW(HFA384X_EV_CMD, HFA384X_EVACK_OFF);\r\nreturn res;\r\n}\r\nstatic inline int hfa384x_cmd_no_wait(struct net_device *dev, u16 cmd,\r\nu16 param0)\r\n{\r\nreturn __hfa384x_cmd_no_wait(dev, cmd, param0, 6);\r\n}\r\nstatic void prism2_cmd_ev(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct hostap_cmd_queue *entry = NULL;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nspin_lock(&local->cmdlock);\r\nif (!list_empty(&local->cmd_queue)) {\r\nentry = list_entry(local->cmd_queue.next,\r\nstruct hostap_cmd_queue, list);\r\nrefcount_inc(&entry->usecnt);\r\nlist_del_init(&entry->list);\r\nlocal->cmd_queue_len--;\r\nif (!entry->issued) {\r\nprintk(KERN_DEBUG "%s: Command completion event, but "\r\n"cmd not issued\n", dev->name);\r\n__hostap_cmd_queue_free(local, entry, 1);\r\nentry = NULL;\r\n}\r\n}\r\nspin_unlock(&local->cmdlock);\r\nif (!entry) {\r\nHFA384X_OUTW(HFA384X_EV_CMD, HFA384X_EVACK_OFF);\r\nprintk(KERN_DEBUG "%s: Command completion event, but no "\r\n"pending commands\n", dev->name);\r\nreturn;\r\n}\r\nentry->resp0 = HFA384X_INW(HFA384X_RESP0_OFF);\r\nentry->res = (HFA384X_INW(HFA384X_STATUS_OFF) &\r\n(BIT(14) | BIT(13) | BIT(12) | BIT(11) | BIT(10) |\r\nBIT(9) | BIT(8))) >> 8;\r\nHFA384X_OUTW(HFA384X_EV_CMD, HFA384X_EVACK_OFF);\r\nif (entry->type == CMD_SLEEP) {\r\nentry->type = CMD_COMPLETED;\r\nwake_up_interruptible(&entry->compl);\r\n} else if (entry->type == CMD_CALLBACK) {\r\nif (entry->callback)\r\nentry->callback(dev, entry->context, entry->resp0,\r\nentry->res);\r\n} else {\r\nprintk(KERN_DEBUG "%s: Invalid command completion type %d\n",\r\ndev->name, entry->type);\r\n}\r\nhostap_cmd_queue_free(local, entry, 1);\r\nentry = NULL;\r\nspin_lock(&local->cmdlock);\r\nif (!list_empty(&local->cmd_queue)) {\r\nentry = list_entry(local->cmd_queue.next,\r\nstruct hostap_cmd_queue, list);\r\nif (entry->issuing) {\r\nentry = NULL;\r\n}\r\nif (entry)\r\nrefcount_inc(&entry->usecnt);\r\n}\r\nspin_unlock(&local->cmdlock);\r\nif (entry) {\r\nint res = hfa384x_cmd_issue(dev, entry);\r\nspin_lock(&local->cmdlock);\r\n__hostap_cmd_queue_free(local, entry, res);\r\nspin_unlock(&local->cmdlock);\r\n}\r\n}\r\nstatic int hfa384x_wait_offset(struct net_device *dev, u16 o_off)\r\n{\r\nint tries = HFA384X_BAP_BUSY_TIMEOUT;\r\nint res = HFA384X_INW(o_off) & HFA384X_OFFSET_BUSY;\r\nwhile (res && tries > 0) {\r\ntries--;\r\nudelay(1);\r\nres = HFA384X_INW(o_off) & HFA384X_OFFSET_BUSY;\r\n}\r\nreturn res;\r\n}\r\nstatic int hfa384x_setup_bap(struct net_device *dev, u16 bap, u16 id,\r\nint offset)\r\n{\r\nu16 o_off, s_off;\r\nint ret = 0;\r\nif (offset % 2 || bap > 1)\r\nreturn -EINVAL;\r\nif (bap == BAP1) {\r\no_off = HFA384X_OFFSET1_OFF;\r\ns_off = HFA384X_SELECT1_OFF;\r\n} else {\r\no_off = HFA384X_OFFSET0_OFF;\r\ns_off = HFA384X_SELECT0_OFF;\r\n}\r\nif (hfa384x_wait_offset(dev, o_off)) {\r\nprism2_io_debug_error(dev, 7);\r\nprintk(KERN_DEBUG "%s: hfa384x_setup_bap - timeout before\n",\r\ndev->name);\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nHFA384X_OUTW(id, s_off);\r\nHFA384X_OUTW(offset, o_off);\r\nif (hfa384x_wait_offset(dev, o_off)) {\r\nprism2_io_debug_error(dev, 8);\r\nprintk(KERN_DEBUG "%s: hfa384x_setup_bap - timeout after\n",\r\ndev->name);\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\n#ifndef final_version\r\nif (HFA384X_INW(o_off) & HFA384X_OFFSET_ERR) {\r\nprism2_io_debug_error(dev, 9);\r\nprintk(KERN_DEBUG "%s: hfa384x_setup_bap - offset error "\r\n"(%d,0x04%x,%d); reg=0x%04x\n",\r\ndev->name, bap, id, offset, HFA384X_INW(o_off));\r\nret = -EINVAL;\r\n}\r\n#endif\r\nout:\r\nreturn ret;\r\n}\r\nstatic int hfa384x_get_rid(struct net_device *dev, u16 rid, void *buf, int len,\r\nint exact_len)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint res, rlen = 0;\r\nstruct hfa384x_rid_hdr rec;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->no_pri) {\r\nprintk(KERN_DEBUG "%s: cannot get RID %04x (len=%d) - no PRI "\r\n"f/w\n", dev->name, rid, len);\r\nreturn -ENOTTY;\r\n}\r\nif ((local->func->card_present && !local->func->card_present(local)) ||\r\nlocal->hw_downloading)\r\nreturn -ENODEV;\r\nres = mutex_lock_interruptible(&local->rid_bap_mtx);\r\nif (res)\r\nreturn res;\r\nres = hfa384x_cmd(dev, HFA384X_CMDCODE_ACCESS, rid, NULL, NULL);\r\nif (res) {\r\nprintk(KERN_DEBUG "%s: hfa384x_get_rid: CMDCODE_ACCESS failed "\r\n"(res=%d, rid=%04x, len=%d)\n",\r\ndev->name, res, rid, len);\r\nmutex_unlock(&local->rid_bap_mtx);\r\nreturn res;\r\n}\r\nspin_lock_bh(&local->baplock);\r\nres = hfa384x_setup_bap(dev, BAP0, rid, 0);\r\nif (res)\r\ngoto unlock;\r\nres = hfa384x_from_bap(dev, BAP0, &rec, sizeof(rec));\r\nif (res)\r\ngoto unlock;\r\nif (le16_to_cpu(rec.len) == 0) {\r\nres = -ENODATA;\r\ngoto unlock;\r\n}\r\nrlen = (le16_to_cpu(rec.len) - 1) * 2;\r\nif (exact_len && rlen != len) {\r\nprintk(KERN_DEBUG "%s: hfa384x_get_rid - RID len mismatch: "\r\n"rid=0x%04x, len=%d (expected %d)\n",\r\ndev->name, rid, rlen, len);\r\nres = -ENODATA;\r\n}\r\nres = hfa384x_from_bap(dev, BAP0, buf, len);\r\nunlock:\r\nspin_unlock_bh(&local->baplock);\r\nmutex_unlock(&local->rid_bap_mtx);\r\nif (res) {\r\nif (res != -ENODATA)\r\nprintk(KERN_DEBUG "%s: hfa384x_get_rid (rid=%04x, "\r\n"len=%d) - failed - res=%d\n", dev->name, rid,\r\nlen, res);\r\nif (res == -ETIMEDOUT)\r\nprism2_hw_reset(dev);\r\nreturn res;\r\n}\r\nreturn rlen;\r\n}\r\nstatic int hfa384x_set_rid(struct net_device *dev, u16 rid, void *buf, int len)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct hfa384x_rid_hdr rec;\r\nint res;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->no_pri) {\r\nprintk(KERN_DEBUG "%s: cannot set RID %04x (len=%d) - no PRI "\r\n"f/w\n", dev->name, rid, len);\r\nreturn -ENOTTY;\r\n}\r\nif ((local->func->card_present && !local->func->card_present(local)) ||\r\nlocal->hw_downloading)\r\nreturn -ENODEV;\r\nrec.rid = cpu_to_le16(rid);\r\nrec.len = cpu_to_le16(len / 2 + len % 2 + 1);\r\nres = mutex_lock_interruptible(&local->rid_bap_mtx);\r\nif (res)\r\nreturn res;\r\nspin_lock_bh(&local->baplock);\r\nres = hfa384x_setup_bap(dev, BAP0, rid, 0);\r\nif (!res)\r\nres = hfa384x_to_bap(dev, BAP0, &rec, sizeof(rec));\r\nif (!res)\r\nres = hfa384x_to_bap(dev, BAP0, buf, len);\r\nspin_unlock_bh(&local->baplock);\r\nif (res) {\r\nprintk(KERN_DEBUG "%s: hfa384x_set_rid (rid=%04x, len=%d) - "\r\n"failed - res=%d\n", dev->name, rid, len, res);\r\nmutex_unlock(&local->rid_bap_mtx);\r\nreturn res;\r\n}\r\nres = hfa384x_cmd(dev, HFA384X_CMDCODE_ACCESS_WRITE, rid, NULL, NULL);\r\nmutex_unlock(&local->rid_bap_mtx);\r\nif (res) {\r\nprintk(KERN_DEBUG "%s: hfa384x_set_rid: CMDCODE_ACCESS_WRITE "\r\n"failed (res=%d, rid=%04x, len=%d)\n",\r\ndev->name, res, rid, len);\r\nif (res == -ETIMEDOUT)\r\nprism2_hw_reset(dev);\r\n}\r\nreturn res;\r\n}\r\nstatic void hfa384x_disable_interrupts(struct net_device *dev)\r\n{\r\nHFA384X_OUTW(0, HFA384X_INTEN_OFF);\r\nHFA384X_OUTW(0xffff, HFA384X_EVACK_OFF);\r\n}\r\nstatic void hfa384x_enable_interrupts(struct net_device *dev)\r\n{\r\nHFA384X_OUTW(0xffff, HFA384X_EVACK_OFF);\r\nHFA384X_OUTW(HFA384X_EVENT_MASK, HFA384X_INTEN_OFF);\r\n}\r\nstatic void hfa384x_events_no_bap0(struct net_device *dev)\r\n{\r\nHFA384X_OUTW(HFA384X_EVENT_MASK & ~HFA384X_BAP0_EVENTS,\r\nHFA384X_INTEN_OFF);\r\n}\r\nstatic void hfa384x_events_all(struct net_device *dev)\r\n{\r\nHFA384X_OUTW(HFA384X_EVENT_MASK, HFA384X_INTEN_OFF);\r\n}\r\nstatic void hfa384x_events_only_cmd(struct net_device *dev)\r\n{\r\nHFA384X_OUTW(HFA384X_EV_CMD, HFA384X_INTEN_OFF);\r\n}\r\nstatic u16 hfa384x_allocate_fid(struct net_device *dev, int len)\r\n{\r\nu16 fid;\r\nunsigned long delay;\r\nif (hfa384x_cmd_wait(dev, HFA384X_CMDCODE_ALLOC, len)) {\r\nprintk(KERN_DEBUG "%s: cannot allocate fid, len=%d\n",\r\ndev->name, len);\r\nreturn 0xffff;\r\n}\r\ndelay = jiffies + HFA384X_ALLOC_COMPL_TIMEOUT;\r\nwhile (!(HFA384X_INW(HFA384X_EVSTAT_OFF) & HFA384X_EV_ALLOC) &&\r\ntime_before(jiffies, delay))\r\nyield();\r\nif (!(HFA384X_INW(HFA384X_EVSTAT_OFF) & HFA384X_EV_ALLOC)) {\r\nprintk("%s: fid allocate, len=%d - timeout\n", dev->name, len);\r\nreturn 0xffff;\r\n}\r\nfid = HFA384X_INW(HFA384X_ALLOCFID_OFF);\r\nHFA384X_OUTW(HFA384X_EV_ALLOC, HFA384X_EVACK_OFF);\r\nreturn fid;\r\n}\r\nstatic int prism2_reset_port(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint res;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (!local->dev_enabled)\r\nreturn 0;\r\nres = hfa384x_cmd(dev, HFA384X_CMDCODE_DISABLE, 0,\r\nNULL, NULL);\r\nif (res)\r\nprintk(KERN_DEBUG "%s: reset port failed to disable port\n",\r\ndev->name);\r\nelse {\r\nres = hfa384x_cmd(dev, HFA384X_CMDCODE_ENABLE, 0,\r\nNULL, NULL);\r\nif (res)\r\nprintk(KERN_DEBUG "%s: reset port failed to enable "\r\n"port\n", dev->name);\r\n}\r\nif (local->fragm_threshold != 2346 &&\r\nhostap_set_word(dev, HFA384X_RID_FRAGMENTATIONTHRESHOLD,\r\nlocal->fragm_threshold)) {\r\nprintk(KERN_DEBUG "%s: failed to restore fragmentation "\r\n"threshold (%d) after Port0 enable\n",\r\ndev->name, local->fragm_threshold);\r\n}\r\n(void) hostap_set_antsel(local);\r\nreturn res;\r\n}\r\nstatic int prism2_get_version_info(struct net_device *dev, u16 rid,\r\nconst char *txt)\r\n{\r\nstruct hfa384x_comp_ident comp;\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->no_pri) {\r\nreturn -1;\r\n}\r\nif (hfa384x_get_rid(dev, rid, &comp, sizeof(comp), 1) < 0) {\r\nprintk(KERN_DEBUG "Could not get RID for component %s\n", txt);\r\nreturn -1;\r\n}\r\nprintk(KERN_INFO "%s: %s: id=0x%02x v%d.%d.%d\n", dev->name, txt,\r\n__le16_to_cpu(comp.id), __le16_to_cpu(comp.major),\r\n__le16_to_cpu(comp.minor), __le16_to_cpu(comp.variant));\r\nreturn 0;\r\n}\r\nstatic int prism2_setup_rids(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\n__le16 tmp;\r\nint ret = 0;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nhostap_set_word(dev, HFA384X_RID_TICKTIME, 2000);\r\nif (!local->fw_ap) {\r\nu16 tmp1 = hostap_get_porttype(local);\r\nret = hostap_set_word(dev, HFA384X_RID_CNFPORTTYPE, tmp1);\r\nif (ret) {\r\nprintk("%s: Port type setting to %d failed\n",\r\ndev->name, tmp1);\r\ngoto fail;\r\n}\r\n}\r\nif (local->iw_mode != IW_MODE_MASTER || local->essid[0] != '\0') {\r\nret = hostap_set_string(dev, HFA384X_RID_CNFOWNSSID,\r\nlocal->essid);\r\nif (ret) {\r\nprintk("%s: AP own SSID setting failed\n", dev->name);\r\ngoto fail;\r\n}\r\n}\r\nret = hostap_set_word(dev, HFA384X_RID_CNFMAXDATALEN,\r\nPRISM2_DATA_MAXLEN);\r\nif (ret) {\r\nprintk("%s: MAC data length setting to %d failed\n",\r\ndev->name, PRISM2_DATA_MAXLEN);\r\ngoto fail;\r\n}\r\nif (hfa384x_get_rid(dev, HFA384X_RID_CHANNELLIST, &tmp, 2, 1) < 0) {\r\nprintk("%s: Channel list read failed\n", dev->name);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nlocal->channel_mask = le16_to_cpu(tmp);\r\nif (local->channel < 1 || local->channel > 14 ||\r\n!(local->channel_mask & (1 << (local->channel - 1)))) {\r\nprintk(KERN_WARNING "%s: Channel setting out of range "\r\n"(%d)!\n", dev->name, local->channel);\r\nret = -EBUSY;\r\ngoto fail;\r\n}\r\nret = hostap_set_word(dev, HFA384X_RID_CNFOWNCHANNEL, local->channel);\r\nif (ret) {\r\nprintk("%s: Channel setting to %d failed\n",\r\ndev->name, local->channel);\r\ngoto fail;\r\n}\r\nret = hostap_set_word(dev, HFA384X_RID_CNFBEACONINT,\r\nlocal->beacon_int);\r\nif (ret) {\r\nprintk("%s: Beacon interval setting to %d failed\n",\r\ndev->name, local->beacon_int);\r\nif (ret == -ETIMEDOUT)\r\ngoto fail;\r\n}\r\nret = hostap_set_word(dev, HFA384X_RID_CNFOWNDTIMPERIOD,\r\nlocal->dtim_period);\r\nif (ret) {\r\nprintk("%s: DTIM period setting to %d failed\n",\r\ndev->name, local->dtim_period);\r\nif (ret == -ETIMEDOUT)\r\ngoto fail;\r\n}\r\nret = hostap_set_word(dev, HFA384X_RID_PROMISCUOUSMODE,\r\nlocal->is_promisc);\r\nif (ret)\r\nprintk(KERN_INFO "%s: Setting promiscuous mode (%d) failed\n",\r\ndev->name, local->is_promisc);\r\nif (!local->fw_ap) {\r\nret = hostap_set_string(dev, HFA384X_RID_CNFDESIREDSSID,\r\nlocal->essid);\r\nif (ret) {\r\nprintk("%s: Desired SSID setting failed\n", dev->name);\r\ngoto fail;\r\n}\r\n}\r\nif (local->tx_rate_control == 0) {\r\nlocal->tx_rate_control =\r\nHFA384X_RATES_1MBPS |\r\nHFA384X_RATES_2MBPS |\r\nHFA384X_RATES_5MBPS |\r\nHFA384X_RATES_11MBPS;\r\n}\r\nif (local->basic_rates == 0)\r\nlocal->basic_rates = HFA384X_RATES_1MBPS | HFA384X_RATES_2MBPS;\r\nif (!local->fw_ap) {\r\nret = hostap_set_word(dev, HFA384X_RID_TXRATECONTROL,\r\nlocal->tx_rate_control);\r\nif (ret) {\r\nprintk("%s: TXRateControl setting to %d failed\n",\r\ndev->name, local->tx_rate_control);\r\ngoto fail;\r\n}\r\nret = hostap_set_word(dev, HFA384X_RID_CNFSUPPORTEDRATES,\r\nlocal->tx_rate_control);\r\nif (ret) {\r\nprintk("%s: cnfSupportedRates setting to %d failed\n",\r\ndev->name, local->tx_rate_control);\r\n}\r\nret = hostap_set_word(dev, HFA384X_RID_CNFBASICRATES,\r\nlocal->basic_rates);\r\nif (ret) {\r\nprintk("%s: cnfBasicRates setting to %d failed\n",\r\ndev->name, local->basic_rates);\r\n}\r\nret = hostap_set_word(dev, HFA384X_RID_CREATEIBSS, 1);\r\nif (ret) {\r\nprintk("%s: Create IBSS setting to 1 failed\n",\r\ndev->name);\r\n}\r\n}\r\nif (local->name_set)\r\n(void) hostap_set_string(dev, HFA384X_RID_CNFOWNNAME,\r\nlocal->name);\r\nif (hostap_set_encryption(local)) {\r\nprintk(KERN_INFO "%s: could not configure encryption\n",\r\ndev->name);\r\n}\r\n(void) hostap_set_antsel(local);\r\nif (hostap_set_roaming(local)) {\r\nprintk(KERN_INFO "%s: could not set host roaming\n",\r\ndev->name);\r\n}\r\nif (local->sta_fw_ver >= PRISM2_FW_VER(1,6,3) &&\r\nhostap_set_word(dev, HFA384X_RID_CNFENHSECURITY, local->enh_sec))\r\nprintk(KERN_INFO "%s: cnfEnhSecurity setting to 0x%x failed\n",\r\ndev->name, local->enh_sec);\r\nif (local->sta_fw_ver >= PRISM2_FW_VER(0,8,2)) {\r\nif (hostap_set_word(dev, HFA384X_RID_CNFTHIRTY2TALLY, 1)) {\r\nprintk(KERN_INFO "%s: cnfThirty2Tally setting "\r\n"failed\n", dev->name);\r\nlocal->tallies32 = 0;\r\n} else\r\nlocal->tallies32 = 1;\r\n} else\r\nlocal->tallies32 = 0;\r\nhostap_set_auth_algs(local);\r\nif (hostap_set_word(dev, HFA384X_RID_FRAGMENTATIONTHRESHOLD,\r\nlocal->fragm_threshold)) {\r\nprintk(KERN_INFO "%s: setting FragmentationThreshold to %d "\r\n"failed\n", dev->name, local->fragm_threshold);\r\n}\r\nif (hostap_set_word(dev, HFA384X_RID_RTSTHRESHOLD,\r\nlocal->rts_threshold)) {\r\nprintk(KERN_INFO "%s: setting RTSThreshold to %d failed\n",\r\ndev->name, local->rts_threshold);\r\n}\r\nif (local->manual_retry_count >= 0 &&\r\nhostap_set_word(dev, HFA384X_RID_CNFALTRETRYCOUNT,\r\nlocal->manual_retry_count)) {\r\nprintk(KERN_INFO "%s: setting cnfAltRetryCount to %d failed\n",\r\ndev->name, local->manual_retry_count);\r\n}\r\nif (local->sta_fw_ver >= PRISM2_FW_VER(1,3,1) &&\r\nhfa384x_get_rid(dev, HFA384X_RID_CNFDBMADJUST, &tmp, 2, 1) == 2) {\r\nlocal->rssi_to_dBm = le16_to_cpu(tmp);\r\n}\r\nif (local->sta_fw_ver >= PRISM2_FW_VER(1,7,0) && local->wpa &&\r\nhostap_set_word(dev, HFA384X_RID_SSNHANDLINGMODE, 1)) {\r\nprintk(KERN_INFO "%s: setting ssnHandlingMode to 1 failed\n",\r\ndev->name);\r\n}\r\nif (local->sta_fw_ver >= PRISM2_FW_VER(1,7,0) && local->generic_elem &&\r\nhfa384x_set_rid(dev, HFA384X_RID_GENERICELEMENT,\r\nlocal->generic_elem, local->generic_elem_len)) {\r\nprintk(KERN_INFO "%s: setting genericElement failed\n",\r\ndev->name);\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int prism2_hw_init(struct net_device *dev, int initial)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint ret, first = 1;\r\nunsigned long start, delay;\r\nPDEBUG(DEBUG_FLOW, "prism2_hw_init()\n");\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nclear_bit(HOSTAP_BITS_TRANSMIT, &local->bits);\r\ninit:\r\nret = hfa384x_cmd_no_wait(dev, HFA384X_CMDCODE_INIT, 0);\r\nif (ret) {\r\nprintk(KERN_INFO "%s: first command failed - assuming card "\r\n"does not have primary firmware\n", dev_info);\r\n}\r\nif (first && (HFA384X_INW(HFA384X_EVSTAT_OFF) & HFA384X_EV_CMD)) {\r\nHFA384X_OUTW(HFA384X_EV_CMD, HFA384X_EVACK_OFF);\r\nprintk(KERN_DEBUG "%s: init command completed too quickly - "\r\n"retrying\n", dev->name);\r\nfirst = 0;\r\ngoto init;\r\n}\r\nstart = jiffies;\r\ndelay = jiffies + HFA384X_INIT_TIMEOUT;\r\nwhile (!(HFA384X_INW(HFA384X_EVSTAT_OFF) & HFA384X_EV_CMD) &&\r\ntime_before(jiffies, delay))\r\nyield();\r\nif (!(HFA384X_INW(HFA384X_EVSTAT_OFF) & HFA384X_EV_CMD)) {\r\nprintk(KERN_DEBUG "%s: assuming no Primary image in "\r\n"flash - card initialization not completed\n",\r\ndev_info);\r\nlocal->no_pri = 1;\r\n#ifdef PRISM2_DOWNLOAD_SUPPORT\r\nif (local->sram_type == -1)\r\nlocal->sram_type = prism2_get_ram_size(local);\r\n#endif\r\nreturn 1;\r\n}\r\nlocal->no_pri = 0;\r\nprintk(KERN_DEBUG "prism2_hw_init: initialized in %lu ms\n",\r\n(jiffies - start) * 1000 / HZ);\r\nHFA384X_OUTW(HFA384X_EV_CMD, HFA384X_EVACK_OFF);\r\nreturn 0;\r\n}\r\nstatic int prism2_hw_init2(struct net_device *dev, int initial)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint i;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\n#ifdef PRISM2_DOWNLOAD_SUPPORT\r\nkfree(local->pda);\r\nif (local->no_pri)\r\nlocal->pda = NULL;\r\nelse\r\nlocal->pda = prism2_read_pda(dev);\r\n#endif\r\nhfa384x_disable_interrupts(dev);\r\n#ifndef final_version\r\nHFA384X_OUTW(HFA384X_MAGIC, HFA384X_SWSUPPORT0_OFF);\r\nif (HFA384X_INW(HFA384X_SWSUPPORT0_OFF) != HFA384X_MAGIC) {\r\nprintk("SWSUPPORT0 write/read failed: %04X != %04X\n",\r\nHFA384X_INW(HFA384X_SWSUPPORT0_OFF), HFA384X_MAGIC);\r\ngoto failed;\r\n}\r\n#endif\r\nif (initial || local->pri_only) {\r\nhfa384x_events_only_cmd(dev);\r\nif (prism2_get_version_info(dev, HFA384X_RID_NICID, "NIC") ||\r\nprism2_get_version_info(dev, HFA384X_RID_PRIID, "PRI")) {\r\nhfa384x_disable_interrupts(dev);\r\ngoto failed;\r\n}\r\nif (prism2_get_version_info(dev, HFA384X_RID_STAID, "STA")) {\r\nprintk(KERN_DEBUG "%s: Failed to read STA f/w version "\r\n"- only Primary f/w present\n", dev->name);\r\nlocal->pri_only = 1;\r\nreturn 0;\r\n}\r\nlocal->pri_only = 0;\r\nhfa384x_disable_interrupts(dev);\r\n}\r\nlocal->txfid_len = PRISM2_TXFID_LEN;\r\nfor (i = 0; i < PRISM2_TXFID_COUNT; i++) {\r\nlocal->txfid[i] = hfa384x_allocate_fid(dev, local->txfid_len);\r\nif (local->txfid[i] == 0xffff && local->txfid_len > 1600) {\r\nlocal->txfid[i] = hfa384x_allocate_fid(dev, 1600);\r\nif (local->txfid[i] != 0xffff) {\r\nprintk(KERN_DEBUG "%s: Using shorter TX FID "\r\n"(1600 bytes)\n", dev->name);\r\nlocal->txfid_len = 1600;\r\n}\r\n}\r\nif (local->txfid[i] == 0xffff)\r\ngoto failed;\r\nlocal->intransmitfid[i] = PRISM2_TXFID_EMPTY;\r\n}\r\nhfa384x_events_only_cmd(dev);\r\nif (initial) {\r\nstruct list_head *ptr;\r\nprism2_check_sta_fw_version(local);\r\nif (hfa384x_get_rid(dev, HFA384X_RID_CNFOWNMACADDR,\r\ndev->dev_addr, 6, 1) < 0) {\r\nprintk("%s: could not get own MAC address\n",\r\ndev->name);\r\n}\r\nlist_for_each(ptr, &local->hostap_interfaces) {\r\niface = list_entry(ptr, struct hostap_interface, list);\r\neth_hw_addr_inherit(iface->dev, dev);\r\n}\r\n} else if (local->fw_ap)\r\nprism2_check_sta_fw_version(local);\r\nprism2_setup_rids(dev);\r\nreturn 0;\r\nfailed:\r\nif (!local->no_pri)\r\nprintk(KERN_WARNING "%s: Initialization failed\n", dev_info);\r\nreturn 1;\r\n}\r\nstatic int prism2_hw_enable(struct net_device *dev, int initial)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint was_resetting;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nwas_resetting = local->hw_resetting;\r\nif (hfa384x_cmd(dev, HFA384X_CMDCODE_ENABLE, 0, NULL, NULL)) {\r\nprintk("%s: MAC port 0 enabling failed\n", dev->name);\r\nreturn 1;\r\n}\r\nlocal->hw_ready = 1;\r\nlocal->hw_reset_tries = 0;\r\nlocal->hw_resetting = 0;\r\nhfa384x_enable_interrupts(dev);\r\nif (initial && prism2_reset_port(dev)) {\r\nprintk("%s: MAC port 0 resetting failed\n", dev->name);\r\nreturn 1;\r\n}\r\nif (was_resetting && netif_queue_stopped(dev)) {\r\nnetif_wake_queue(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int prism2_hw_config(struct net_device *dev, int initial)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->hw_downloading)\r\nreturn 1;\r\nif (prism2_hw_init(dev, initial)) {\r\nreturn local->no_pri ? 0 : 1;\r\n}\r\nif (prism2_hw_init2(dev, initial))\r\nreturn 1;\r\nif (!local->pri_only &&\r\n(initial == 0 || (initial == 2 && local->num_dev_open > 0))) {\r\nif (!local->dev_enabled)\r\nprism2_callback(local, PRISM2_CALLBACK_ENABLE);\r\nlocal->dev_enabled = 1;\r\nreturn prism2_hw_enable(dev, initial);\r\n}\r\nreturn 0;\r\n}\r\nstatic void prism2_hw_shutdown(struct net_device *dev, int no_disable)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nhfa384x_events_only_cmd(dev);\r\nlocal->hw_ready = 0;\r\nif (local->dev_enabled)\r\nprism2_callback(local, PRISM2_CALLBACK_DISABLE);\r\nlocal->dev_enabled = 0;\r\nif (local->func->card_present && !local->func->card_present(local)) {\r\nprintk(KERN_DEBUG "%s: card already removed or not configured "\r\n"during shutdown\n", dev->name);\r\nreturn;\r\n}\r\nif ((no_disable & HOSTAP_HW_NO_DISABLE) == 0 &&\r\nhfa384x_cmd(dev, HFA384X_CMDCODE_DISABLE, 0, NULL, NULL))\r\nprintk(KERN_WARNING "%s: Shutdown failed\n", dev_info);\r\nhfa384x_disable_interrupts(dev);\r\nif (no_disable & HOSTAP_HW_ENABLE_CMDCOMPL)\r\nhfa384x_events_only_cmd(dev);\r\nelse\r\nprism2_clear_cmd_queue(local);\r\n}\r\nstatic void prism2_hw_reset(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\n#if 0\r\nstatic long last_reset = 0;\r\nif (time_before_eq(jiffies, last_reset + HZ))\r\nreturn;\r\nlast_reset = jiffies;\r\n#endif\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (in_interrupt()) {\r\nprintk(KERN_DEBUG "%s: driver bug - prism2_hw_reset() called "\r\n"in interrupt context\n", dev->name);\r\nreturn;\r\n}\r\nif (local->hw_downloading)\r\nreturn;\r\nif (local->hw_resetting) {\r\nprintk(KERN_WARNING "%s: %s: already resetting card - "\r\n"ignoring reset request\n", dev_info, dev->name);\r\nreturn;\r\n}\r\nlocal->hw_reset_tries++;\r\nif (local->hw_reset_tries > 10) {\r\nprintk(KERN_WARNING "%s: too many reset tries, skipping\n",\r\ndev->name);\r\nreturn;\r\n}\r\nprintk(KERN_WARNING "%s: %s: resetting card\n", dev_info, dev->name);\r\nhfa384x_disable_interrupts(dev);\r\nlocal->hw_resetting = 1;\r\nif (local->func->cor_sreset) {\r\ndisable_irq(dev->irq);\r\nlocal->func->cor_sreset(local);\r\nenable_irq(dev->irq);\r\n}\r\nprism2_hw_shutdown(dev, 1);\r\nprism2_hw_config(dev, 0);\r\nlocal->hw_resetting = 0;\r\n#ifdef PRISM2_DOWNLOAD_SUPPORT\r\nif (local->dl_pri) {\r\nprintk(KERN_DEBUG "%s: persistent download of primary "\r\n"firmware\n", dev->name);\r\nif (prism2_download_genesis(local, local->dl_pri) < 0)\r\nprintk(KERN_WARNING "%s: download (PRI) failed\n",\r\ndev->name);\r\n}\r\nif (local->dl_sec) {\r\nprintk(KERN_DEBUG "%s: persistent download of secondary "\r\n"firmware\n", dev->name);\r\nif (prism2_download_volatile(local, local->dl_sec) < 0)\r\nprintk(KERN_WARNING "%s: download (SEC) failed\n",\r\ndev->name);\r\n}\r\n#endif\r\n}\r\nstatic void prism2_schedule_reset(local_info_t *local)\r\n{\r\nschedule_work(&local->reset_queue);\r\n}\r\nstatic void handle_reset_queue(struct work_struct *work)\r\n{\r\nlocal_info_t *local = container_of(work, local_info_t, reset_queue);\r\nprintk(KERN_DEBUG "%s: scheduled card reset\n", local->dev->name);\r\nprism2_hw_reset(local->dev);\r\nif (netif_queue_stopped(local->dev)) {\r\nint i;\r\nfor (i = 0; i < PRISM2_TXFID_COUNT; i++)\r\nif (local->intransmitfid[i] == PRISM2_TXFID_EMPTY) {\r\nPDEBUG(DEBUG_EXTRA, "prism2_tx_timeout: "\r\n"wake up queue\n");\r\nnetif_wake_queue(local->dev);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int prism2_get_txfid_idx(local_info_t *local)\r\n{\r\nint idx, end;\r\nunsigned long flags;\r\nspin_lock_irqsave(&local->txfidlock, flags);\r\nend = idx = local->next_txfid;\r\ndo {\r\nif (local->intransmitfid[idx] == PRISM2_TXFID_EMPTY) {\r\nlocal->intransmitfid[idx] = PRISM2_TXFID_RESERVED;\r\nspin_unlock_irqrestore(&local->txfidlock, flags);\r\nreturn idx;\r\n}\r\nidx++;\r\nif (idx >= PRISM2_TXFID_COUNT)\r\nidx = 0;\r\n} while (idx != end);\r\nspin_unlock_irqrestore(&local->txfidlock, flags);\r\nPDEBUG(DEBUG_EXTRA2, "prism2_get_txfid_idx: no room in txfid buf: "\r\n"packet dropped\n");\r\nlocal->dev->stats.tx_dropped++;\r\nreturn -1;\r\n}\r\nstatic void prism2_transmit_cb(struct net_device *dev, long context,\r\nu16 resp0, u16 res)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint idx = (int) context;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (res) {\r\nprintk(KERN_DEBUG "%s: prism2_transmit_cb - res=0x%02x\n",\r\ndev->name, res);\r\nreturn;\r\n}\r\nif (idx < 0 || idx >= PRISM2_TXFID_COUNT) {\r\nprintk(KERN_DEBUG "%s: prism2_transmit_cb called with invalid "\r\n"idx=%d\n", dev->name, idx);\r\nreturn;\r\n}\r\nif (!test_and_clear_bit(HOSTAP_BITS_TRANSMIT, &local->bits)) {\r\nprintk(KERN_DEBUG "%s: driver bug: prism2_transmit_cb called "\r\n"with no pending transmit\n", dev->name);\r\n}\r\nif (netif_queue_stopped(dev)) {\r\nnetif_wake_queue(dev);\r\n}\r\nspin_lock(&local->txfidlock);\r\nlocal->intransmitfid[idx] = resp0;\r\nPDEBUG(DEBUG_FID, "%s: prism2_transmit_cb: txfid[%d]=0x%04x, "\r\n"resp0=0x%04x, transmit_txfid=0x%04x\n",\r\ndev->name, idx, local->txfid[idx],\r\nresp0, local->intransmitfid[local->next_txfid]);\r\nidx++;\r\nif (idx >= PRISM2_TXFID_COUNT)\r\nidx = 0;\r\nlocal->next_txfid = idx;\r\ndo {\r\nif (local->intransmitfid[idx] == PRISM2_TXFID_EMPTY) {\r\nspin_unlock(&local->txfidlock);\r\nreturn;\r\n}\r\nidx++;\r\nif (idx >= PRISM2_TXFID_COUNT)\r\nidx = 0;\r\n} while (idx != local->next_txfid);\r\nspin_unlock(&local->txfidlock);\r\nnetif_stop_queue(dev);\r\n}\r\nstatic int prism2_transmit(struct net_device *dev, int idx)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint res;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (test_and_set_bit(HOSTAP_BITS_TRANSMIT, &local->bits)) {\r\nprintk(KERN_DEBUG "%s: driver bug - prism2_transmit() called "\r\n"when previous TX was pending\n", dev->name);\r\nreturn -1;\r\n}\r\nnetif_stop_queue(dev);\r\nres = hfa384x_cmd_callback(\r\ndev,\r\nHFA384X_CMDCODE_TRANSMIT | HFA384X_CMD_TX_RECLAIM,\r\nlocal->txfid[idx],\r\nprism2_transmit_cb, (long) idx);\r\nif (res) {\r\nprintk(KERN_DEBUG "%s: prism2_transmit: CMDCODE_TRANSMIT "\r\n"failed (res=%d)\n", dev->name, res);\r\ndev->stats.tx_dropped++;\r\nnetif_wake_queue(dev);\r\nreturn -1;\r\n}\r\nnetif_trans_update(dev);\r\nreturn 0;\r\n}\r\nstatic int prism2_tx_80211(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct hfa384x_tx_frame txdesc;\r\nstruct hostap_skb_tx_data *meta;\r\nint hdr_len, data_len, idx, res, ret = -1;\r\nu16 tx_control, fc;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nmeta = (struct hostap_skb_tx_data *) skb->cb;\r\nprism2_callback(local, PRISM2_CALLBACK_TX_START);\r\nif ((local->func->card_present && !local->func->card_present(local)) ||\r\n!local->hw_ready || local->hw_downloading || local->pri_only) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "%s: prism2_tx_80211: hw not ready -"\r\n" skipping\n", dev->name);\r\n}\r\ngoto fail;\r\n}\r\nmemset(&txdesc, 0, sizeof(txdesc));\r\nhdr_len = 24;\r\nskb_copy_from_linear_data(skb, &txdesc.frame_control, hdr_len);\r\nfc = le16_to_cpu(txdesc.frame_control);\r\nif (ieee80211_is_data(txdesc.frame_control) &&\r\nieee80211_has_a4(txdesc.frame_control) &&\r\nskb->len >= 30) {\r\nskb_copy_from_linear_data_offset(skb, hdr_len, txdesc.addr4,\r\nETH_ALEN);\r\nhdr_len += ETH_ALEN;\r\n}\r\ntx_control = local->tx_control;\r\nif (meta->tx_cb_idx) {\r\ntx_control |= HFA384X_TX_CTRL_TX_OK;\r\ntxdesc.sw_support = cpu_to_le32(meta->tx_cb_idx);\r\n}\r\ntxdesc.tx_control = cpu_to_le16(tx_control);\r\ntxdesc.tx_rate = meta->rate;\r\ndata_len = skb->len - hdr_len;\r\ntxdesc.data_len = cpu_to_le16(data_len);\r\ntxdesc.len = cpu_to_be16(data_len);\r\nidx = prism2_get_txfid_idx(local);\r\nif (idx < 0)\r\ngoto fail;\r\nif (local->frame_dump & PRISM2_DUMP_TX_HDR)\r\nhostap_dump_tx_header(dev->name, &txdesc);\r\nspin_lock(&local->baplock);\r\nres = hfa384x_setup_bap(dev, BAP0, local->txfid[idx], 0);\r\nif (!res)\r\nres = hfa384x_to_bap(dev, BAP0, &txdesc, sizeof(txdesc));\r\nif (!res)\r\nres = hfa384x_to_bap(dev, BAP0, skb->data + hdr_len,\r\nskb->len - hdr_len);\r\nspin_unlock(&local->baplock);\r\nif (!res)\r\nres = prism2_transmit(dev, idx);\r\nif (res) {\r\nprintk(KERN_DEBUG "%s: prism2_tx_80211 - to BAP0 failed\n",\r\ndev->name);\r\nlocal->intransmitfid[idx] = PRISM2_TXFID_EMPTY;\r\nschedule_work(&local->reset_queue);\r\ngoto fail;\r\n}\r\nret = 0;\r\nfail:\r\nprism2_callback(local, PRISM2_CALLBACK_TX_END);\r\nreturn ret;\r\n}\r\nstatic u16 prism2_read_fid_reg(struct net_device *dev, u16 reg)\r\n{\r\n#ifdef EXTRA_FID_READ_TESTS\r\nu16 val, val2, val3;\r\nint i;\r\nfor (i = 0; i < 10; i++) {\r\nval = HFA384X_INW(reg);\r\nval2 = HFA384X_INW(reg);\r\nval3 = HFA384X_INW(reg);\r\nif (val == val2 && val == val3)\r\nreturn val;\r\nprintk(KERN_DEBUG "%s: detected fid change (try=%d, reg=%04x):"\r\n" %04x %04x %04x\n",\r\ndev->name, i, reg, val, val2, val3);\r\nif ((val == val2 || val == val3) && val != 0)\r\nreturn val;\r\nif (val2 == val3 && val2 != 0)\r\nreturn val2;\r\n}\r\nprintk(KERN_WARNING "%s: Uhhuh.. could not read good fid from reg "\r\n"%04x (%04x %04x %04x)\n", dev->name, reg, val, val2, val3);\r\nreturn val;\r\n#else\r\nreturn HFA384X_INW(reg);\r\n#endif\r\n}\r\nstatic void prism2_rx(local_info_t *local)\r\n{\r\nstruct net_device *dev = local->dev;\r\nint res, rx_pending = 0;\r\nu16 len, hdr_len, rxfid, status, macport;\r\nstruct hfa384x_rx_frame rxdesc;\r\nstruct sk_buff *skb = NULL;\r\nprism2_callback(local, PRISM2_CALLBACK_RX_START);\r\nrxfid = prism2_read_fid_reg(dev, HFA384X_RXFID_OFF);\r\n#ifndef final_version\r\nif (rxfid == 0) {\r\nrxfid = HFA384X_INW(HFA384X_RXFID_OFF);\r\nprintk(KERN_DEBUG "prism2_rx: rxfid=0 (next 0x%04x)\n",\r\nrxfid);\r\nif (rxfid == 0) {\r\nschedule_work(&local->reset_queue);\r\ngoto rx_dropped;\r\n}\r\n}\r\n#endif\r\nspin_lock(&local->baplock);\r\nres = hfa384x_setup_bap(dev, BAP0, rxfid, 0);\r\nif (!res)\r\nres = hfa384x_from_bap(dev, BAP0, &rxdesc, sizeof(rxdesc));\r\nif (res) {\r\nspin_unlock(&local->baplock);\r\nprintk(KERN_DEBUG "%s: copy from BAP0 failed %d\n", dev->name,\r\nres);\r\nif (res == -ETIMEDOUT) {\r\nschedule_work(&local->reset_queue);\r\n}\r\ngoto rx_dropped;\r\n}\r\nlen = le16_to_cpu(rxdesc.data_len);\r\nhdr_len = sizeof(rxdesc);\r\nstatus = le16_to_cpu(rxdesc.status);\r\nmacport = (status >> 8) & 0x07;\r\nif (len > PRISM2_DATA_MAXLEN + 8 ) {\r\nif (macport == 7 && local->iw_mode == IW_MODE_MONITOR) {\r\nif (len >= (u16) -14) {\r\nhdr_len -= 65535 - len;\r\nhdr_len--;\r\n}\r\nlen = 0;\r\n} else {\r\nspin_unlock(&local->baplock);\r\nprintk(KERN_DEBUG "%s: Received frame with invalid "\r\n"length 0x%04x\n", dev->name, len);\r\nhostap_dump_rx_header(dev->name, &rxdesc);\r\ngoto rx_dropped;\r\n}\r\n}\r\nskb = dev_alloc_skb(len + hdr_len);\r\nif (!skb) {\r\nspin_unlock(&local->baplock);\r\nprintk(KERN_DEBUG "%s: RX failed to allocate skb\n",\r\ndev->name);\r\ngoto rx_dropped;\r\n}\r\nskb->dev = dev;\r\nskb_put_data(skb, &rxdesc, hdr_len);\r\nif (len > 0)\r\nres = hfa384x_from_bap(dev, BAP0, skb_put(skb, len), len);\r\nspin_unlock(&local->baplock);\r\nif (res) {\r\nprintk(KERN_DEBUG "%s: RX failed to read "\r\n"frame data\n", dev->name);\r\ngoto rx_dropped;\r\n}\r\nskb_queue_tail(&local->rx_list, skb);\r\ntasklet_schedule(&local->rx_tasklet);\r\nrx_exit:\r\nprism2_callback(local, PRISM2_CALLBACK_RX_END);\r\nif (!rx_pending) {\r\nHFA384X_OUTW(HFA384X_EV_RX, HFA384X_EVACK_OFF);\r\n}\r\nreturn;\r\nrx_dropped:\r\ndev->stats.rx_dropped++;\r\nif (skb)\r\ndev_kfree_skb(skb);\r\ngoto rx_exit;\r\n}\r\nstatic void hostap_rx_skb(local_info_t *local, struct sk_buff *skb)\r\n{\r\nstruct hfa384x_rx_frame *rxdesc;\r\nstruct net_device *dev = skb->dev;\r\nstruct hostap_80211_rx_status stats;\r\nint hdrlen, rx_hdrlen;\r\nrx_hdrlen = sizeof(*rxdesc);\r\nif (skb->len < sizeof(*rxdesc)) {\r\nif (local->iw_mode == IW_MODE_MONITOR &&\r\nskb->len >= sizeof(*rxdesc) - 30) {\r\nrx_hdrlen = skb->len;\r\n} else {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\n}\r\nrxdesc = (struct hfa384x_rx_frame *) skb->data;\r\nif (local->frame_dump & PRISM2_DUMP_RX_HDR &&\r\nskb->len >= sizeof(*rxdesc))\r\nhostap_dump_rx_header(dev->name, rxdesc);\r\nif (le16_to_cpu(rxdesc->status) & HFA384X_RX_STATUS_FCSERR &&\r\n(!local->monitor_allow_fcserr ||\r\nlocal->iw_mode != IW_MODE_MONITOR))\r\ngoto drop;\r\nif (skb->len > PRISM2_DATA_MAXLEN) {\r\nprintk(KERN_DEBUG "%s: RX: len(%d) > MAX(%d)\n",\r\ndev->name, skb->len, PRISM2_DATA_MAXLEN);\r\ngoto drop;\r\n}\r\nstats.mac_time = le32_to_cpu(rxdesc->time);\r\nstats.signal = rxdesc->signal - local->rssi_to_dBm;\r\nstats.noise = rxdesc->silence - local->rssi_to_dBm;\r\nstats.rate = rxdesc->rate;\r\nhdrlen = hostap_80211_get_hdrlen(rxdesc->frame_control);\r\nif (hdrlen > rx_hdrlen)\r\nhdrlen = rx_hdrlen;\r\nmemmove(skb_pull(skb, rx_hdrlen - hdrlen),\r\n&rxdesc->frame_control, hdrlen);\r\nhostap_80211_rx(dev, skb, &stats);\r\nreturn;\r\ndrop:\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void hostap_rx_tasklet(unsigned long data)\r\n{\r\nlocal_info_t *local = (local_info_t *) data;\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(&local->rx_list)) != NULL)\r\nhostap_rx_skb(local, skb);\r\n}\r\nstatic void prism2_alloc_ev(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint idx;\r\nu16 fid;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nfid = prism2_read_fid_reg(dev, HFA384X_ALLOCFID_OFF);\r\nPDEBUG(DEBUG_FID, "FID: interrupt: ALLOC - fid=0x%04x\n", fid);\r\nspin_lock(&local->txfidlock);\r\nidx = local->next_alloc;\r\ndo {\r\nif (local->txfid[idx] == fid) {\r\nPDEBUG(DEBUG_FID, "FID: found matching txfid[%d]\n",\r\nidx);\r\n#ifndef final_version\r\nif (local->intransmitfid[idx] == PRISM2_TXFID_EMPTY)\r\nprintk("Already released txfid found at idx "\r\n"%d\n", idx);\r\nif (local->intransmitfid[idx] == PRISM2_TXFID_RESERVED)\r\nprintk("Already reserved txfid found at idx "\r\n"%d\n", idx);\r\n#endif\r\nlocal->intransmitfid[idx] = PRISM2_TXFID_EMPTY;\r\nidx++;\r\nlocal->next_alloc = idx >= PRISM2_TXFID_COUNT ? 0 :\r\nidx;\r\nif (!test_bit(HOSTAP_BITS_TRANSMIT, &local->bits) &&\r\nnetif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\nspin_unlock(&local->txfidlock);\r\nreturn;\r\n}\r\nidx++;\r\nif (idx >= PRISM2_TXFID_COUNT)\r\nidx = 0;\r\n} while (idx != local->next_alloc);\r\nprintk(KERN_WARNING "%s: could not find matching txfid (0x%04x, new "\r\n"read 0x%04x) for alloc event\n", dev->name, fid,\r\nHFA384X_INW(HFA384X_ALLOCFID_OFF));\r\nprintk(KERN_DEBUG "TXFIDs:");\r\nfor (idx = 0; idx < PRISM2_TXFID_COUNT; idx++)\r\nprintk(" %04x[%04x]", local->txfid[idx],\r\nlocal->intransmitfid[idx]);\r\nprintk("\n");\r\nspin_unlock(&local->txfidlock);\r\n}\r\nstatic void hostap_tx_callback(local_info_t *local,\r\nstruct hfa384x_tx_frame *txdesc, int ok,\r\nchar *payload)\r\n{\r\nu16 sw_support, hdrlen, len;\r\nstruct sk_buff *skb;\r\nstruct hostap_tx_callback_info *cb;\r\nif (!ether_addr_equal(txdesc->addr2, local->dev->dev_addr)) {\r\nprintk(KERN_DEBUG "%s: TX callback - foreign frame\n",\r\nlocal->dev->name);\r\nreturn;\r\n}\r\nsw_support = le32_to_cpu(txdesc->sw_support);\r\nspin_lock(&local->lock);\r\ncb = local->tx_callback;\r\nwhile (cb != NULL && cb->idx != sw_support)\r\ncb = cb->next;\r\nspin_unlock(&local->lock);\r\nif (cb == NULL) {\r\nprintk(KERN_DEBUG "%s: could not find TX callback (idx %d)\n",\r\nlocal->dev->name, sw_support);\r\nreturn;\r\n}\r\nhdrlen = hostap_80211_get_hdrlen(txdesc->frame_control);\r\nlen = le16_to_cpu(txdesc->data_len);\r\nskb = dev_alloc_skb(hdrlen + len);\r\nif (skb == NULL) {\r\nprintk(KERN_DEBUG "%s: hostap_tx_callback failed to allocate "\r\n"skb\n", local->dev->name);\r\nreturn;\r\n}\r\nskb_put_data(skb, (void *)&txdesc->frame_control, hdrlen);\r\nif (payload)\r\nskb_put_data(skb, payload, len);\r\nskb->dev = local->dev;\r\nskb_reset_mac_header(skb);\r\ncb->func(skb, ok, cb->data);\r\n}\r\nstatic int hostap_tx_compl_read(local_info_t *local, int error,\r\nstruct hfa384x_tx_frame *txdesc,\r\nchar **payload)\r\n{\r\nu16 fid, len;\r\nint res, ret = 0;\r\nstruct net_device *dev = local->dev;\r\nfid = prism2_read_fid_reg(dev, HFA384X_TXCOMPLFID_OFF);\r\nPDEBUG(DEBUG_FID, "interrupt: TX (err=%d) - fid=0x%04x\n", fid, error);\r\nspin_lock(&local->baplock);\r\nres = hfa384x_setup_bap(dev, BAP0, fid, 0);\r\nif (!res)\r\nres = hfa384x_from_bap(dev, BAP0, txdesc, sizeof(*txdesc));\r\nif (res) {\r\nPDEBUG(DEBUG_EXTRA, "%s: TX (err=%d) - fid=0x%04x - could not "\r\n"read txdesc\n", dev->name, error, fid);\r\nif (res == -ETIMEDOUT) {\r\nschedule_work(&local->reset_queue);\r\n}\r\nret = -1;\r\ngoto fail;\r\n}\r\nif (txdesc->sw_support) {\r\nlen = le16_to_cpu(txdesc->data_len);\r\nif (len < PRISM2_DATA_MAXLEN) {\r\n*payload = kmalloc(len, GFP_ATOMIC);\r\nif (*payload == NULL ||\r\nhfa384x_from_bap(dev, BAP0, *payload, len)) {\r\nPDEBUG(DEBUG_EXTRA, "%s: could not read TX "\r\n"frame payload\n", dev->name);\r\nkfree(*payload);\r\n*payload = NULL;\r\nret = -1;\r\ngoto fail;\r\n}\r\n}\r\n}\r\nfail:\r\nspin_unlock(&local->baplock);\r\nreturn ret;\r\n}\r\nstatic void prism2_tx_ev(local_info_t *local)\r\n{\r\nstruct net_device *dev = local->dev;\r\nchar *payload = NULL;\r\nstruct hfa384x_tx_frame txdesc;\r\nif (hostap_tx_compl_read(local, 0, &txdesc, &payload))\r\ngoto fail;\r\nif (local->frame_dump & PRISM2_DUMP_TX_HDR) {\r\nPDEBUG(DEBUG_EXTRA, "%s: TX - status=0x%04x "\r\n"retry_count=%d tx_rate=%d seq_ctrl=%d "\r\n"duration_id=%d\n",\r\ndev->name, le16_to_cpu(txdesc.status),\r\ntxdesc.retry_count, txdesc.tx_rate,\r\nle16_to_cpu(txdesc.seq_ctrl),\r\nle16_to_cpu(txdesc.duration_id));\r\n}\r\nif (txdesc.sw_support)\r\nhostap_tx_callback(local, &txdesc, 1, payload);\r\nkfree(payload);\r\nfail:\r\nHFA384X_OUTW(HFA384X_EV_TX, HFA384X_EVACK_OFF);\r\n}\r\nstatic void hostap_sta_tx_exc_tasklet(unsigned long data)\r\n{\r\nlocal_info_t *local = (local_info_t *) data;\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(&local->sta_tx_exc_list)) != NULL) {\r\nstruct hfa384x_tx_frame *txdesc =\r\n(struct hfa384x_tx_frame *) skb->data;\r\nif (skb->len >= sizeof(*txdesc)) {\r\nint hdrlen = hostap_80211_get_hdrlen(txdesc->frame_control);\r\nmemmove(skb_pull(skb, sizeof(*txdesc) - hdrlen),\r\n&txdesc->frame_control, hdrlen);\r\nhostap_handle_sta_tx_exc(local, skb);\r\n}\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\nstatic void prism2_txexc(local_info_t *local)\r\n{\r\nstruct net_device *dev = local->dev;\r\nu16 status, fc;\r\nint show_dump, res;\r\nchar *payload = NULL;\r\nstruct hfa384x_tx_frame txdesc;\r\nshow_dump = local->frame_dump & PRISM2_DUMP_TXEXC_HDR;\r\ndev->stats.tx_errors++;\r\nres = hostap_tx_compl_read(local, 1, &txdesc, &payload);\r\nHFA384X_OUTW(HFA384X_EV_TXEXC, HFA384X_EVACK_OFF);\r\nif (res)\r\nreturn;\r\nstatus = le16_to_cpu(txdesc.status);\r\nif (status & (HFA384X_TX_STATUS_RETRYERR | HFA384X_TX_STATUS_AGEDERR))\r\n{\r\nunion iwreq_data wrqu;\r\nmemcpy(wrqu.addr.sa_data, txdesc.addr1, ETH_ALEN);\r\nwrqu.addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event(dev, IWEVTXDROP, &wrqu, NULL);\r\n} else\r\nshow_dump = 1;\r\nif (local->iw_mode == IW_MODE_MASTER ||\r\nlocal->iw_mode == IW_MODE_REPEAT ||\r\nlocal->wds_type & HOSTAP_WDS_AP_CLIENT) {\r\nstruct sk_buff *skb;\r\nskb = dev_alloc_skb(sizeof(txdesc));\r\nif (skb) {\r\nskb_put_data(skb, &txdesc, sizeof(txdesc));\r\nskb_queue_tail(&local->sta_tx_exc_list, skb);\r\ntasklet_schedule(&local->sta_tx_exc_tasklet);\r\n}\r\n}\r\nif (txdesc.sw_support)\r\nhostap_tx_callback(local, &txdesc, 0, payload);\r\nkfree(payload);\r\nif (!show_dump)\r\nreturn;\r\nPDEBUG(DEBUG_EXTRA, "%s: TXEXC - status=0x%04x (%s%s%s%s)"\r\n" tx_control=%04x\n",\r\ndev->name, status,\r\nstatus & HFA384X_TX_STATUS_RETRYERR ? "[RetryErr]" : "",\r\nstatus & HFA384X_TX_STATUS_AGEDERR ? "[AgedErr]" : "",\r\nstatus & HFA384X_TX_STATUS_DISCON ? "[Discon]" : "",\r\nstatus & HFA384X_TX_STATUS_FORMERR ? "[FormErr]" : "",\r\nle16_to_cpu(txdesc.tx_control));\r\nfc = le16_to_cpu(txdesc.frame_control);\r\nPDEBUG(DEBUG_EXTRA, " retry_count=%d tx_rate=%d fc=0x%04x "\r\n"(%s%s%s::%d%s%s)\n",\r\ntxdesc.retry_count, txdesc.tx_rate, fc,\r\nieee80211_is_mgmt(txdesc.frame_control) ? "Mgmt" : "",\r\nieee80211_is_ctl(txdesc.frame_control) ? "Ctrl" : "",\r\nieee80211_is_data(txdesc.frame_control) ? "Data" : "",\r\n(fc & IEEE80211_FCTL_STYPE) >> 4,\r\nieee80211_has_tods(txdesc.frame_control) ? " ToDS" : "",\r\nieee80211_has_fromds(txdesc.frame_control) ? " FromDS" : "");\r\nPDEBUG(DEBUG_EXTRA, " A1=%pM A2=%pM A3=%pM A4=%pM\n",\r\ntxdesc.addr1, txdesc.addr2,\r\ntxdesc.addr3, txdesc.addr4);\r\n}\r\nstatic void hostap_info_tasklet(unsigned long data)\r\n{\r\nlocal_info_t *local = (local_info_t *) data;\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(&local->info_list)) != NULL) {\r\nhostap_info_process(local, skb);\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\nstatic void prism2_info(local_info_t *local)\r\n{\r\nstruct net_device *dev = local->dev;\r\nu16 fid;\r\nint res, left;\r\nstruct hfa384x_info_frame info;\r\nstruct sk_buff *skb;\r\nfid = HFA384X_INW(HFA384X_INFOFID_OFF);\r\nspin_lock(&local->baplock);\r\nres = hfa384x_setup_bap(dev, BAP0, fid, 0);\r\nif (!res)\r\nres = hfa384x_from_bap(dev, BAP0, &info, sizeof(info));\r\nif (res) {\r\nspin_unlock(&local->baplock);\r\nprintk(KERN_DEBUG "Could not get info frame (fid=0x%04x)\n",\r\nfid);\r\nif (res == -ETIMEDOUT) {\r\nschedule_work(&local->reset_queue);\r\n}\r\ngoto out;\r\n}\r\nleft = (le16_to_cpu(info.len) - 1) * 2;\r\nif (info.len & cpu_to_le16(0x8000) || info.len == 0 || left > 2060) {\r\nspin_unlock(&local->baplock);\r\nprintk(KERN_DEBUG "%s: Received info frame with invalid "\r\n"length 0x%04x (type 0x%04x)\n", dev->name,\r\nle16_to_cpu(info.len), le16_to_cpu(info.type));\r\ngoto out;\r\n}\r\nskb = dev_alloc_skb(sizeof(info) + left);\r\nif (skb == NULL) {\r\nspin_unlock(&local->baplock);\r\nprintk(KERN_DEBUG "%s: Could not allocate skb for info "\r\n"frame\n", dev->name);\r\ngoto out;\r\n}\r\nskb_put_data(skb, &info, sizeof(info));\r\nif (left > 0 && hfa384x_from_bap(dev, BAP0, skb_put(skb, left), left))\r\n{\r\nspin_unlock(&local->baplock);\r\nprintk(KERN_WARNING "%s: Info frame read failed (fid=0x%04x, "\r\n"len=0x%04x, type=0x%04x\n", dev->name, fid,\r\nle16_to_cpu(info.len), le16_to_cpu(info.type));\r\ndev_kfree_skb(skb);\r\ngoto out;\r\n}\r\nspin_unlock(&local->baplock);\r\nskb_queue_tail(&local->info_list, skb);\r\ntasklet_schedule(&local->info_tasklet);\r\nout:\r\nHFA384X_OUTW(HFA384X_EV_INFO, HFA384X_EVACK_OFF);\r\n}\r\nstatic void hostap_bap_tasklet(unsigned long data)\r\n{\r\nlocal_info_t *local = (local_info_t *) data;\r\nstruct net_device *dev = local->dev;\r\nu16 ev;\r\nint frames = 30;\r\nif (local->func->card_present && !local->func->card_present(local))\r\nreturn;\r\nset_bit(HOSTAP_BITS_BAP_TASKLET, &local->bits);\r\nwhile (frames-- > 0) {\r\nev = HFA384X_INW(HFA384X_EVSTAT_OFF);\r\nif (ev == 0xffff || !(ev & HFA384X_BAP0_EVENTS))\r\nbreak;\r\nif (ev & HFA384X_EV_RX)\r\nprism2_rx(local);\r\nif (ev & HFA384X_EV_INFO)\r\nprism2_info(local);\r\nif (ev & HFA384X_EV_TX)\r\nprism2_tx_ev(local);\r\nif (ev & HFA384X_EV_TXEXC)\r\nprism2_txexc(local);\r\n}\r\nset_bit(HOSTAP_BITS_BAP_TASKLET2, &local->bits);\r\nclear_bit(HOSTAP_BITS_BAP_TASKLET, &local->bits);\r\nhfa384x_events_all(dev);\r\nclear_bit(HOSTAP_BITS_BAP_TASKLET2, &local->bits);\r\n}\r\nstatic void prism2_infdrop(struct net_device *dev)\r\n{\r\nstatic unsigned long last_inquire = 0;\r\nPDEBUG(DEBUG_EXTRA, "%s: INFDROP event\n", dev->name);\r\nif (!last_inquire || time_after(jiffies, last_inquire + HZ)) {\r\nhfa384x_cmd_callback(dev, HFA384X_CMDCODE_INQUIRE,\r\nHFA384X_INFO_COMMTALLIES, NULL, 0);\r\nlast_inquire = jiffies;\r\n}\r\n}\r\nstatic void prism2_ev_tick(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nu16 evstat, inten;\r\nstatic int prev_stuck = 0;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (time_after(jiffies, local->last_tick_timer + 5 * HZ) &&\r\nlocal->last_tick_timer) {\r\nevstat = HFA384X_INW(HFA384X_EVSTAT_OFF);\r\ninten = HFA384X_INW(HFA384X_INTEN_OFF);\r\nif (!prev_stuck) {\r\nprintk(KERN_INFO "%s: SW TICK stuck? "\r\n"bits=0x%lx EvStat=%04x IntEn=%04x\n",\r\ndev->name, local->bits, evstat, inten);\r\n}\r\nlocal->sw_tick_stuck++;\r\nif ((evstat & HFA384X_BAP0_EVENTS) &&\r\n(inten & HFA384X_BAP0_EVENTS)) {\r\nprintk(KERN_INFO "%s: trying to recover from IRQ "\r\n"hang\n", dev->name);\r\nhfa384x_events_no_bap0(dev);\r\n}\r\nprev_stuck = 1;\r\n} else\r\nprev_stuck = 0;\r\n}\r\nstatic void prism2_check_magic(local_info_t *local)\r\n{\r\n#ifndef PRISM2_PCI\r\n#ifndef final_version\r\nstatic unsigned long last_magic_err = 0;\r\nstruct net_device *dev = local->dev;\r\nif (HFA384X_INW(HFA384X_SWSUPPORT0_OFF) != HFA384X_MAGIC) {\r\nif (!local->hw_ready)\r\nreturn;\r\nHFA384X_OUTW(0xffff, HFA384X_EVACK_OFF);\r\nif (time_after(jiffies, last_magic_err + 10 * HZ)) {\r\nprintk("%s: Interrupt, but SWSUPPORT0 does not match: "\r\n"%04X != %04X - card removed?\n", dev->name,\r\nHFA384X_INW(HFA384X_SWSUPPORT0_OFF),\r\nHFA384X_MAGIC);\r\nlast_magic_err = jiffies;\r\n} else if (net_ratelimit()) {\r\nprintk(KERN_DEBUG "%s: interrupt - SWSUPPORT0=%04x "\r\n"MAGIC=%04x\n", dev->name,\r\nHFA384X_INW(HFA384X_SWSUPPORT0_OFF),\r\nHFA384X_MAGIC);\r\n}\r\nif (HFA384X_INW(HFA384X_SWSUPPORT0_OFF) != 0xffff)\r\nschedule_work(&local->reset_queue);\r\nreturn;\r\n}\r\n#endif\r\n#endif\r\n}\r\nstatic irqreturn_t prism2_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint events = 0;\r\nu16 ev;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nspin_lock(&local->irq_init_lock);\r\nif (!dev->base_addr) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "%s: Interrupt, but dev not configured\n",\r\ndev->name);\r\n}\r\nspin_unlock(&local->irq_init_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nspin_unlock(&local->irq_init_lock);\r\nprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INTERRUPT, 0, 0);\r\nif (local->func->card_present && !local->func->card_present(local)) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "%s: Interrupt, but dev not OK\n",\r\ndev->name);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nprism2_check_magic(local);\r\nfor (;;) {\r\nev = HFA384X_INW(HFA384X_EVSTAT_OFF);\r\nif (ev == 0xffff) {\r\nif (local->shutdown)\r\nreturn IRQ_HANDLED;\r\nHFA384X_OUTW(0xffff, HFA384X_EVACK_OFF);\r\nprintk(KERN_DEBUG "%s: prism2_interrupt: ev=0xffff\n",\r\ndev->name);\r\nreturn IRQ_HANDLED;\r\n}\r\nev &= HFA384X_INW(HFA384X_INTEN_OFF);\r\nif (ev == 0)\r\nbreak;\r\nif (ev & HFA384X_EV_CMD) {\r\nprism2_cmd_ev(dev);\r\n}\r\nif (!local->hw_ready || local->hw_resetting ||\r\n!local->dev_enabled) {\r\nev = HFA384X_INW(HFA384X_EVSTAT_OFF);\r\nif (ev & HFA384X_EV_CMD)\r\ngoto next_event;\r\nif ((ev & HFA384X_EVENT_MASK) == 0)\r\nreturn IRQ_HANDLED;\r\nif (local->dev_enabled && (ev & ~HFA384X_EV_TICK) &&\r\nnet_ratelimit()) {\r\nprintk(KERN_DEBUG "%s: prism2_interrupt: hw "\r\n"not ready; skipping events 0x%04x "\r\n"(IntEn=0x%04x)%s%s%s\n",\r\ndev->name, ev,\r\nHFA384X_INW(HFA384X_INTEN_OFF),\r\n!local->hw_ready ? " (!hw_ready)" : "",\r\nlocal->hw_resetting ?\r\n" (hw_resetting)" : "",\r\n!local->dev_enabled ?\r\n" (!dev_enabled)" : "");\r\n}\r\nHFA384X_OUTW(ev, HFA384X_EVACK_OFF);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (ev & HFA384X_EV_TICK) {\r\nprism2_ev_tick(dev);\r\nHFA384X_OUTW(HFA384X_EV_TICK, HFA384X_EVACK_OFF);\r\n}\r\nif (ev & HFA384X_EV_ALLOC) {\r\nprism2_alloc_ev(dev);\r\nHFA384X_OUTW(HFA384X_EV_ALLOC, HFA384X_EVACK_OFF);\r\n}\r\nif (ev & HFA384X_BAP0_EVENTS) {\r\nhfa384x_events_no_bap0(dev);\r\ntasklet_schedule(&local->bap_tasklet);\r\n}\r\n#ifndef final_version\r\nif (ev & HFA384X_EV_WTERR) {\r\nPDEBUG(DEBUG_EXTRA, "%s: WTERR event\n", dev->name);\r\nHFA384X_OUTW(HFA384X_EV_WTERR, HFA384X_EVACK_OFF);\r\n}\r\n#endif\r\nif (ev & HFA384X_EV_INFDROP) {\r\nprism2_infdrop(dev);\r\nHFA384X_OUTW(HFA384X_EV_INFDROP, HFA384X_EVACK_OFF);\r\n}\r\nnext_event:\r\nevents++;\r\nif (events >= PRISM2_MAX_INTERRUPT_EVENTS) {\r\nPDEBUG(DEBUG_EXTRA, "prism2_interrupt: >%d events "\r\n"(EvStat=0x%04x)\n",\r\nPRISM2_MAX_INTERRUPT_EVENTS,\r\nHFA384X_INW(HFA384X_EVSTAT_OFF));\r\nbreak;\r\n}\r\n}\r\nprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INTERRUPT, 0, 1);\r\nreturn IRQ_RETVAL(events);\r\n}\r\nstatic void prism2_check_sta_fw_version(local_info_t *local)\r\n{\r\nstruct hfa384x_comp_ident comp;\r\nint id, variant, major, minor;\r\nif (hfa384x_get_rid(local->dev, HFA384X_RID_STAID,\r\n&comp, sizeof(comp), 1) < 0)\r\nreturn;\r\nlocal->fw_ap = 0;\r\nid = le16_to_cpu(comp.id);\r\nif (id != HFA384X_COMP_ID_STA) {\r\nif (id == HFA384X_COMP_ID_FW_AP)\r\nlocal->fw_ap = 1;\r\nreturn;\r\n}\r\nmajor = __le16_to_cpu(comp.major);\r\nminor = __le16_to_cpu(comp.minor);\r\nvariant = __le16_to_cpu(comp.variant);\r\nlocal->sta_fw_ver = PRISM2_FW_VER(major, minor, variant);\r\nlocal->fw_encrypt_ok = local->sta_fw_ver >= PRISM2_FW_VER(1,4,9);\r\nif (local->iw_mode == IW_MODE_MASTER && !local->host_encrypt &&\r\n!local->fw_encrypt_ok) {\r\nprintk(KERN_DEBUG "%s: defaulting to host-based encryption as "\r\n"a workaround for firmware bug in Host AP mode WEP\n",\r\nlocal->dev->name);\r\nlocal->host_encrypt = 1;\r\n}\r\nif (local->sta_fw_ver >= PRISM2_FW_VER(1,5,0))\r\nlocal->wds_type |= HOSTAP_WDS_STANDARD_FRAME;\r\nelse {\r\nprintk(KERN_DEBUG "%s: defaulting to bogus WDS frame as a "\r\n"workaround for firmware bug in Host AP mode WDS\n",\r\nlocal->dev->name);\r\n}\r\nhostap_check_sta_fw_version(local->ap, local->sta_fw_ver);\r\n}\r\nstatic void hostap_passive_scan(unsigned long data)\r\n{\r\nlocal_info_t *local = (local_info_t *) data;\r\nstruct net_device *dev = local->dev;\r\nu16 chan;\r\nif (local->passive_scan_interval <= 0)\r\nreturn;\r\nif (local->passive_scan_state == PASSIVE_SCAN_LISTEN) {\r\nint max_tries = 16;\r\nif (test_bit(HOSTAP_BITS_TRANSMIT, &local->bits)) {\r\nprintk(KERN_DEBUG "%s: passive scan detected pending "\r\n"TX - delaying\n", dev->name);\r\nlocal->passive_scan_timer.expires = jiffies + HZ / 10;\r\nadd_timer(&local->passive_scan_timer);\r\nreturn;\r\n}\r\ndo {\r\nlocal->passive_scan_channel++;\r\nif (local->passive_scan_channel > 14)\r\nlocal->passive_scan_channel = 1;\r\nmax_tries--;\r\n} while (!(local->channel_mask &\r\n(1 << (local->passive_scan_channel - 1))) &&\r\nmax_tries > 0);\r\nif (max_tries == 0) {\r\nprintk(KERN_INFO "%s: no allowed passive scan channels"\r\n" found\n", dev->name);\r\nreturn;\r\n}\r\nprintk(KERN_DEBUG "%s: passive scan channel %d\n",\r\ndev->name, local->passive_scan_channel);\r\nchan = local->passive_scan_channel;\r\nlocal->passive_scan_state = PASSIVE_SCAN_WAIT;\r\nlocal->passive_scan_timer.expires = jiffies + HZ / 10;\r\n} else {\r\nchan = local->channel;\r\nlocal->passive_scan_state = PASSIVE_SCAN_LISTEN;\r\nlocal->passive_scan_timer.expires = jiffies +\r\nlocal->passive_scan_interval * HZ;\r\n}\r\nif (hfa384x_cmd_callback(dev, HFA384X_CMDCODE_TEST |\r\n(HFA384X_TEST_CHANGE_CHANNEL << 8),\r\nchan, NULL, 0))\r\nprintk(KERN_ERR "%s: passive scan channel set %d "\r\n"failed\n", dev->name, chan);\r\nadd_timer(&local->passive_scan_timer);\r\n}\r\nstatic void handle_comms_qual_update(struct work_struct *work)\r\n{\r\nlocal_info_t *local =\r\ncontainer_of(work, local_info_t, comms_qual_update);\r\nprism2_update_comms_qual(local->dev);\r\n}\r\nstatic void hostap_tick_timer(unsigned long data)\r\n{\r\nstatic unsigned long last_inquire = 0;\r\nlocal_info_t *local = (local_info_t *) data;\r\nlocal->last_tick_timer = jiffies;\r\nif ((!last_inquire || time_after(jiffies, last_inquire + 10 * HZ)) &&\r\n!local->hw_downloading && local->hw_ready &&\r\n!local->hw_resetting && local->dev_enabled) {\r\nhfa384x_cmd_callback(local->dev, HFA384X_CMDCODE_INQUIRE,\r\nHFA384X_INFO_COMMTALLIES, NULL, 0);\r\nlast_inquire = jiffies;\r\n}\r\nif ((local->last_comms_qual_update == 0 ||\r\ntime_after(jiffies, local->last_comms_qual_update + 10 * HZ)) &&\r\n(local->iw_mode == IW_MODE_INFRA ||\r\nlocal->iw_mode == IW_MODE_ADHOC)) {\r\nschedule_work(&local->comms_qual_update);\r\n}\r\nlocal->tick_timer.expires = jiffies + 2 * HZ;\r\nadd_timer(&local->tick_timer);\r\n}\r\nstatic int prism2_registers_proc_show(struct seq_file *m, void *v)\r\n{\r\nlocal_info_t *local = m->private;\r\n#define SHOW_REG(n) \\r\nseq_printf(m, #n "=%04x\n", hfa384x_read_reg(local->dev, HFA384X_##n##_OFF))\r\nSHOW_REG(CMD);\r\nSHOW_REG(PARAM0);\r\nSHOW_REG(PARAM1);\r\nSHOW_REG(PARAM2);\r\nSHOW_REG(STATUS);\r\nSHOW_REG(RESP0);\r\nSHOW_REG(RESP1);\r\nSHOW_REG(RESP2);\r\nSHOW_REG(INFOFID);\r\nSHOW_REG(CONTROL);\r\nSHOW_REG(SELECT0);\r\nSHOW_REG(SELECT1);\r\nSHOW_REG(OFFSET0);\r\nSHOW_REG(OFFSET1);\r\nSHOW_REG(RXFID);\r\nSHOW_REG(ALLOCFID);\r\nSHOW_REG(TXCOMPLFID);\r\nSHOW_REG(SWSUPPORT0);\r\nSHOW_REG(SWSUPPORT1);\r\nSHOW_REG(SWSUPPORT2);\r\nSHOW_REG(EVSTAT);\r\nSHOW_REG(INTEN);\r\nSHOW_REG(EVACK);\r\nSHOW_REG(AUXPAGE);\r\nSHOW_REG(AUXOFFSET);\r\n#ifdef PRISM2_PCI\r\nSHOW_REG(PCICOR);\r\nSHOW_REG(PCIHCR);\r\nSHOW_REG(PCI_M0_ADDRH);\r\nSHOW_REG(PCI_M0_ADDRL);\r\nSHOW_REG(PCI_M0_LEN);\r\nSHOW_REG(PCI_M0_CTL);\r\nSHOW_REG(PCI_STATUS);\r\nSHOW_REG(PCI_M1_ADDRH);\r\nSHOW_REG(PCI_M1_ADDRL);\r\nSHOW_REG(PCI_M1_LEN);\r\nSHOW_REG(PCI_M1_CTL);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int prism2_registers_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, prism2_registers_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int prism2_set_tim(struct net_device *dev, int aid, int set)\r\n{\r\nstruct list_head *ptr;\r\nstruct set_tim_data *new_entry;\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nnew_entry = kzalloc(sizeof(*new_entry), GFP_ATOMIC);\r\nif (new_entry == NULL)\r\nreturn -ENOMEM;\r\nnew_entry->aid = aid;\r\nnew_entry->set = set;\r\nspin_lock_bh(&local->set_tim_lock);\r\nlist_for_each(ptr, &local->set_tim_list) {\r\nstruct set_tim_data *entry =\r\nlist_entry(ptr, struct set_tim_data, list);\r\nif (entry->aid == aid) {\r\nPDEBUG(DEBUG_PS2, "%s: prism2_set_tim: aid=%d "\r\n"set=%d ==> %d\n",\r\nlocal->dev->name, aid, entry->set, set);\r\nentry->set = set;\r\nkfree(new_entry);\r\nnew_entry = NULL;\r\nbreak;\r\n}\r\n}\r\nif (new_entry)\r\nlist_add_tail(&new_entry->list, &local->set_tim_list);\r\nspin_unlock_bh(&local->set_tim_lock);\r\nschedule_work(&local->set_tim_queue);\r\nreturn 0;\r\n}\r\nstatic void handle_set_tim_queue(struct work_struct *work)\r\n{\r\nlocal_info_t *local = container_of(work, local_info_t, set_tim_queue);\r\nstruct set_tim_data *entry;\r\nu16 val;\r\nfor (;;) {\r\nentry = NULL;\r\nspin_lock_bh(&local->set_tim_lock);\r\nif (!list_empty(&local->set_tim_list)) {\r\nentry = list_entry(local->set_tim_list.next,\r\nstruct set_tim_data, list);\r\nlist_del(&entry->list);\r\n}\r\nspin_unlock_bh(&local->set_tim_lock);\r\nif (!entry)\r\nbreak;\r\nPDEBUG(DEBUG_PS2, "%s: handle_set_tim_queue: aid=%d set=%d\n",\r\nlocal->dev->name, entry->aid, entry->set);\r\nval = entry->aid;\r\nif (entry->set)\r\nval |= 0x8000;\r\nif (hostap_set_word(local->dev, HFA384X_RID_CNFTIMCTRL, val)) {\r\nprintk(KERN_DEBUG "%s: set_tim failed (aid=%d "\r\n"set=%d)\n",\r\nlocal->dev->name, entry->aid, entry->set);\r\n}\r\nkfree(entry);\r\n}\r\n}\r\nstatic void prism2_clear_set_tim_queue(local_info_t *local)\r\n{\r\nstruct list_head *ptr, *n;\r\nlist_for_each_safe(ptr, n, &local->set_tim_list) {\r\nstruct set_tim_data *entry;\r\nentry = list_entry(ptr, struct set_tim_data, list);\r\nlist_del(&entry->list);\r\nkfree(entry);\r\n}\r\n}\r\nstatic void prism2_set_lockdep_class_one(struct net_device *dev,\r\nstruct netdev_queue *txq,\r\nvoid *_unused)\r\n{\r\nlockdep_set_class(&txq->_xmit_lock,\r\n&hostap_netdev_xmit_lock_key);\r\n}\r\nstatic void prism2_set_lockdep_class(struct net_device *dev)\r\n{\r\nlockdep_set_class(&dev->addr_list_lock,\r\n&hostap_netdev_addr_lock_key);\r\nnetdev_for_each_tx_queue(dev, prism2_set_lockdep_class_one, NULL);\r\n}\r\nstatic struct net_device *\r\nprism2_init_local_data(struct prism2_helper_functions *funcs, int card_idx,\r\nstruct device *sdev)\r\n{\r\nstruct net_device *dev;\r\nstruct hostap_interface *iface;\r\nstruct local_info *local;\r\nint len, i, ret;\r\nif (funcs == NULL)\r\nreturn NULL;\r\nlen = strlen(dev_template);\r\nif (len >= IFNAMSIZ || strstr(dev_template, "%d") == NULL) {\r\nprintk(KERN_WARNING "hostap: Invalid dev_template='%s'\n",\r\ndev_template);\r\nreturn NULL;\r\n}\r\nlen = sizeof(struct hostap_interface) +\r\n3 + sizeof(struct local_info) +\r\n3 + sizeof(struct ap_data);\r\ndev = alloc_etherdev(len);\r\nif (dev == NULL)\r\nreturn NULL;\r\niface = netdev_priv(dev);\r\nlocal = (struct local_info *) ((((long) (iface + 1)) + 3) & ~3);\r\nlocal->ap = (struct ap_data *) ((((long) (local + 1)) + 3) & ~3);\r\nlocal->dev = iface->dev = dev;\r\niface->local = local;\r\niface->type = HOSTAP_INTERFACE_MASTER;\r\nINIT_LIST_HEAD(&local->hostap_interfaces);\r\nlocal->hw_module = THIS_MODULE;\r\n#ifdef PRISM2_IO_DEBUG\r\nlocal->io_debug_enabled = 1;\r\n#endif\r\nlocal->func = funcs;\r\nlocal->func->cmd = hfa384x_cmd;\r\nlocal->func->read_regs = hfa384x_read_regs;\r\nlocal->func->get_rid = hfa384x_get_rid;\r\nlocal->func->set_rid = hfa384x_set_rid;\r\nlocal->func->hw_enable = prism2_hw_enable;\r\nlocal->func->hw_config = prism2_hw_config;\r\nlocal->func->hw_reset = prism2_hw_reset;\r\nlocal->func->hw_shutdown = prism2_hw_shutdown;\r\nlocal->func->reset_port = prism2_reset_port;\r\nlocal->func->schedule_reset = prism2_schedule_reset;\r\n#ifdef PRISM2_DOWNLOAD_SUPPORT\r\nlocal->func->read_aux_fops = &prism2_download_aux_dump_proc_fops;\r\nlocal->func->download = prism2_download;\r\n#endif\r\nlocal->func->tx = prism2_tx_80211;\r\nlocal->func->set_tim = prism2_set_tim;\r\nlocal->func->need_tx_headroom = 0;\r\nlocal->mtu = mtu;\r\nrwlock_init(&local->iface_lock);\r\nspin_lock_init(&local->txfidlock);\r\nspin_lock_init(&local->cmdlock);\r\nspin_lock_init(&local->baplock);\r\nspin_lock_init(&local->lock);\r\nspin_lock_init(&local->irq_init_lock);\r\nmutex_init(&local->rid_bap_mtx);\r\nif (card_idx < 0 || card_idx >= MAX_PARM_DEVICES)\r\ncard_idx = 0;\r\nlocal->card_idx = card_idx;\r\nlen = strlen(essid);\r\nmemcpy(local->essid, essid,\r\nlen > MAX_SSID_LEN ? MAX_SSID_LEN : len);\r\nlocal->essid[MAX_SSID_LEN] = '\0';\r\ni = GET_INT_PARM(iw_mode, card_idx);\r\nif ((i >= IW_MODE_ADHOC && i <= IW_MODE_REPEAT) ||\r\ni == IW_MODE_MONITOR) {\r\nlocal->iw_mode = i;\r\n} else {\r\nprintk(KERN_WARNING "prism2: Unknown iw_mode %d; using "\r\n"IW_MODE_MASTER\n", i);\r\nlocal->iw_mode = IW_MODE_MASTER;\r\n}\r\nlocal->channel = GET_INT_PARM(channel, card_idx);\r\nlocal->beacon_int = GET_INT_PARM(beacon_int, card_idx);\r\nlocal->dtim_period = GET_INT_PARM(dtim_period, card_idx);\r\nlocal->wds_max_connections = 16;\r\nlocal->tx_control = HFA384X_TX_CTRL_FLAGS;\r\nlocal->manual_retry_count = -1;\r\nlocal->rts_threshold = 2347;\r\nlocal->fragm_threshold = 2346;\r\nlocal->rssi_to_dBm = 100;\r\nlocal->auth_algs = PRISM2_AUTH_OPEN | PRISM2_AUTH_SHARED_KEY;\r\nlocal->sram_type = -1;\r\nlocal->scan_channel_mask = 0xffff;\r\nlocal->monitor_type = PRISM2_MONITOR_RADIOTAP;\r\nINIT_WORK(&local->reset_queue, handle_reset_queue);\r\nINIT_WORK(&local->set_multicast_list_queue,\r\nhostap_set_multicast_list_queue);\r\nINIT_WORK(&local->set_tim_queue, handle_set_tim_queue);\r\nINIT_LIST_HEAD(&local->set_tim_list);\r\nspin_lock_init(&local->set_tim_lock);\r\nINIT_WORK(&local->comms_qual_update, handle_comms_qual_update);\r\n#define HOSTAP_TASKLET_INIT(q, f, d) \\r\ndo { memset((q), 0, sizeof(*(q))); (q)->func = (f); (q)->data = (d); } \\r\nwhile (0)\r\nHOSTAP_TASKLET_INIT(&local->bap_tasklet, hostap_bap_tasklet,\r\n(unsigned long) local);\r\nHOSTAP_TASKLET_INIT(&local->info_tasklet, hostap_info_tasklet,\r\n(unsigned long) local);\r\nhostap_info_init(local);\r\nHOSTAP_TASKLET_INIT(&local->rx_tasklet,\r\nhostap_rx_tasklet, (unsigned long) local);\r\nskb_queue_head_init(&local->rx_list);\r\nHOSTAP_TASKLET_INIT(&local->sta_tx_exc_tasklet,\r\nhostap_sta_tx_exc_tasklet, (unsigned long) local);\r\nskb_queue_head_init(&local->sta_tx_exc_list);\r\nINIT_LIST_HEAD(&local->cmd_queue);\r\ninit_waitqueue_head(&local->hostscan_wq);\r\nlib80211_crypt_info_init(&local->crypt_info, dev->name, &local->lock);\r\ninit_timer(&local->passive_scan_timer);\r\nlocal->passive_scan_timer.data = (unsigned long) local;\r\nlocal->passive_scan_timer.function = hostap_passive_scan;\r\ninit_timer(&local->tick_timer);\r\nlocal->tick_timer.data = (unsigned long) local;\r\nlocal->tick_timer.function = hostap_tick_timer;\r\nlocal->tick_timer.expires = jiffies + 2 * HZ;\r\nadd_timer(&local->tick_timer);\r\nINIT_LIST_HEAD(&local->bss_list);\r\nhostap_setup_dev(dev, local, HOSTAP_INTERFACE_MASTER);\r\ndev->type = ARPHRD_IEEE80211;\r\ndev->header_ops = &hostap_80211_ops;\r\nrtnl_lock();\r\nret = dev_alloc_name(dev, "wifi%d");\r\nSET_NETDEV_DEV(dev, sdev);\r\nif (ret >= 0)\r\nret = register_netdevice(dev);\r\nprism2_set_lockdep_class(dev);\r\nrtnl_unlock();\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "%s: register netdevice failed!\n",\r\ndev_info);\r\ngoto fail;\r\n}\r\nprintk(KERN_INFO "%s: Registered netdevice %s\n", dev_info, dev->name);\r\nhostap_init_data(local);\r\nreturn dev;\r\nfail:\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\nstatic int hostap_hw_ready(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nstruct local_info *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nlocal->ddev = hostap_add_interface(local, HOSTAP_INTERFACE_MAIN, 0,\r\n"", dev_template);\r\nif (local->ddev) {\r\nif (local->iw_mode == IW_MODE_INFRA ||\r\nlocal->iw_mode == IW_MODE_ADHOC) {\r\nnetif_carrier_off(local->dev);\r\nnetif_carrier_off(local->ddev);\r\n}\r\nhostap_init_proc(local);\r\n#ifndef PRISM2_NO_PROCFS_DEBUG\r\nproc_create_data("registers", 0, local->proc,\r\n&prism2_registers_proc_fops, local);\r\n#endif\r\nhostap_init_ap_proc(local);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic void prism2_free_local_data(struct net_device *dev)\r\n{\r\nstruct hostap_tx_callback_info *tx_cb, *tx_cb_prev;\r\nint i;\r\nstruct hostap_interface *iface;\r\nstruct local_info *local;\r\nstruct list_head *ptr, *n;\r\nif (dev == NULL)\r\nreturn;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nlist_for_each_safe(ptr, n, &local->hostap_interfaces) {\r\niface = list_entry(ptr, struct hostap_interface, list);\r\nif (iface->type == HOSTAP_INTERFACE_MASTER) {\r\ncontinue;\r\n}\r\nhostap_remove_interface(iface->dev, 0, 1);\r\n}\r\nunregister_netdev(local->dev);\r\nflush_work(&local->reset_queue);\r\nflush_work(&local->set_multicast_list_queue);\r\nflush_work(&local->set_tim_queue);\r\n#ifndef PRISM2_NO_STATION_MODES\r\nflush_work(&local->info_queue);\r\n#endif\r\nflush_work(&local->comms_qual_update);\r\nlib80211_crypt_info_free(&local->crypt_info);\r\nif (timer_pending(&local->passive_scan_timer))\r\ndel_timer(&local->passive_scan_timer);\r\nif (timer_pending(&local->tick_timer))\r\ndel_timer(&local->tick_timer);\r\nprism2_clear_cmd_queue(local);\r\nskb_queue_purge(&local->info_list);\r\nskb_queue_purge(&local->rx_list);\r\nskb_queue_purge(&local->sta_tx_exc_list);\r\nif (local->dev_enabled)\r\nprism2_callback(local, PRISM2_CALLBACK_DISABLE);\r\nif (local->ap != NULL)\r\nhostap_free_data(local->ap);\r\n#ifndef PRISM2_NO_PROCFS_DEBUG\r\nif (local->proc != NULL)\r\nremove_proc_entry("registers", local->proc);\r\n#endif\r\nhostap_remove_proc(local);\r\ntx_cb = local->tx_callback;\r\nwhile (tx_cb != NULL) {\r\ntx_cb_prev = tx_cb;\r\ntx_cb = tx_cb->next;\r\nkfree(tx_cb_prev);\r\n}\r\nhostap_set_hostapd(local, 0, 0);\r\nhostap_set_hostapd_sta(local, 0, 0);\r\nfor (i = 0; i < PRISM2_FRAG_CACHE_LEN; i++) {\r\nif (local->frag_cache[i].skb != NULL)\r\ndev_kfree_skb(local->frag_cache[i].skb);\r\n}\r\n#ifdef PRISM2_DOWNLOAD_SUPPORT\r\nprism2_download_free_data(local->dl_pri);\r\nprism2_download_free_data(local->dl_sec);\r\n#endif\r\nprism2_clear_set_tim_queue(local);\r\nlist_for_each_safe(ptr, n, &local->bss_list) {\r\nstruct hostap_bss_info *bss =\r\nlist_entry(ptr, struct hostap_bss_info, list);\r\nkfree(bss);\r\n}\r\nkfree(local->pda);\r\nkfree(local->last_scan_results);\r\nkfree(local->generic_elem);\r\nfree_netdev(local->dev);\r\n}\r\nstatic void prism2_suspend(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nstruct local_info *local;\r\nunion iwreq_data wrqu;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event(local->dev, SIOCGIWAP, &wrqu, NULL);\r\nprism2_hw_shutdown(dev, 0);\r\n}
