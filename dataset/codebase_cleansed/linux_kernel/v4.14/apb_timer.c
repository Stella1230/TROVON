static inline void __iomem *adev_virt_addr(struct apbt_dev *adev)\r\n{\r\nreturn apbt_virt_address + adev->num * APBTMRS_REG_SIZE;\r\n}\r\nstatic inline void apbt_set_mapping(void)\r\n{\r\nstruct sfi_timer_table_entry *mtmr;\r\nint phy_cs_timer_id = 0;\r\nif (apbt_virt_address) {\r\npr_debug("APBT base already mapped\n");\r\nreturn;\r\n}\r\nmtmr = sfi_get_mtmr(APBT_CLOCKEVENT0_NUM);\r\nif (mtmr == NULL) {\r\nprintk(KERN_ERR "Failed to get MTMR %d from SFI\n",\r\nAPBT_CLOCKEVENT0_NUM);\r\nreturn;\r\n}\r\napbt_address = (phys_addr_t)mtmr->phys_addr;\r\nif (!apbt_address) {\r\nprintk(KERN_WARNING "No timer base from SFI, use default\n");\r\napbt_address = APBT_DEFAULT_BASE;\r\n}\r\napbt_virt_address = ioremap_nocache(apbt_address, APBT_MMAP_SIZE);\r\nif (!apbt_virt_address) {\r\npr_debug("Failed mapping APBT phy address at %lu\n",\\r\n(unsigned long)apbt_address);\r\ngoto panic_noapbt;\r\n}\r\napbt_freq = mtmr->freq_hz;\r\nsfi_free_mtmr(mtmr);\r\nmtmr = sfi_get_mtmr(APBT_CLOCKSOURCE_NUM);\r\nif (mtmr == NULL)\r\ngoto panic_noapbt;\r\npr_debug("Use timer %d for clocksource\n",\r\n(int)(mtmr->phys_addr & 0xff) / APBTMRS_REG_SIZE);\r\nphy_cs_timer_id = (unsigned int)(mtmr->phys_addr & 0xff) /\r\nAPBTMRS_REG_SIZE;\r\nclocksource_apbt = dw_apb_clocksource_init(APBT_CLOCKSOURCE_RATING,\r\n"apbt0", apbt_virt_address + phy_cs_timer_id *\r\nAPBTMRS_REG_SIZE, apbt_freq);\r\nreturn;\r\npanic_noapbt:\r\npanic("Failed to setup APB system timer\n");\r\n}\r\nstatic inline void apbt_clear_mapping(void)\r\n{\r\niounmap(apbt_virt_address);\r\napbt_virt_address = NULL;\r\n}\r\nstatic int __init apbt_clockevent_register(void)\r\n{\r\nstruct sfi_timer_table_entry *mtmr;\r\nstruct apbt_dev *adev = this_cpu_ptr(&cpu_apbt_dev);\r\nmtmr = sfi_get_mtmr(APBT_CLOCKEVENT0_NUM);\r\nif (mtmr == NULL) {\r\nprintk(KERN_ERR "Failed to get MTMR %d from SFI\n",\r\nAPBT_CLOCKEVENT0_NUM);\r\nreturn -ENODEV;\r\n}\r\nadev->num = smp_processor_id();\r\nadev->timer = dw_apb_clockevent_init(smp_processor_id(), "apbt0",\r\nintel_mid_timer_options == INTEL_MID_TIMER_LAPIC_APBT ?\r\nAPBT_CLOCKEVENT_RATING - 100 : APBT_CLOCKEVENT_RATING,\r\nadev_virt_addr(adev), 0, apbt_freq);\r\nadev->timer->eoi = NULL;\r\nif (intel_mid_timer_options == INTEL_MID_TIMER_LAPIC_APBT) {\r\nglobal_clock_event = &adev->timer->ced;\r\nprintk(KERN_DEBUG "%s clockevent registered as global\n",\r\nglobal_clock_event->name);\r\n}\r\ndw_apb_clockevent_register(adev->timer);\r\nsfi_free_mtmr(mtmr);\r\nreturn 0;\r\n}\r\nstatic void apbt_setup_irq(struct apbt_dev *adev)\r\n{\r\nirq_modify_status(adev->irq, 0, IRQ_MOVE_PCNTXT);\r\nirq_set_affinity(adev->irq, cpumask_of(adev->cpu));\r\n}\r\nvoid apbt_setup_secondary_clock(void)\r\n{\r\nstruct apbt_dev *adev;\r\nint cpu;\r\ncpu = smp_processor_id();\r\nif (!cpu)\r\nreturn;\r\nadev = this_cpu_ptr(&cpu_apbt_dev);\r\nif (!adev->timer) {\r\nadev->timer = dw_apb_clockevent_init(cpu, adev->name,\r\nAPBT_CLOCKEVENT_RATING, adev_virt_addr(adev),\r\nadev->irq, apbt_freq);\r\nadev->timer->eoi = NULL;\r\n} else {\r\ndw_apb_clockevent_resume(adev->timer);\r\n}\r\nprintk(KERN_INFO "Registering CPU %d clockevent device %s, cpu %08x\n",\r\ncpu, adev->name, adev->cpu);\r\napbt_setup_irq(adev);\r\ndw_apb_clockevent_register(adev->timer);\r\nreturn;\r\n}\r\nstatic int apbt_cpu_dead(unsigned int cpu)\r\n{\r\nstruct apbt_dev *adev = &per_cpu(cpu_apbt_dev, cpu);\r\ndw_apb_clockevent_pause(adev->timer);\r\nif (system_state == SYSTEM_RUNNING) {\r\npr_debug("skipping APBT CPU %u offline\n", cpu);\r\n} else {\r\npr_debug("APBT clockevent for cpu %u offline\n", cpu);\r\ndw_apb_clockevent_stop(adev->timer);\r\n}\r\nreturn 0;\r\n}\r\nstatic __init int apbt_late_init(void)\r\n{\r\nif (intel_mid_timer_options == INTEL_MID_TIMER_LAPIC_APBT ||\r\n!apb_timer_block_enabled)\r\nreturn 0;\r\nreturn cpuhp_setup_state(CPUHP_X86_APB_DEAD, "x86/apb:dead", NULL,\r\napbt_cpu_dead);\r\n}\r\nvoid apbt_setup_secondary_clock(void) {}\r\nstatic int apbt_clocksource_register(void)\r\n{\r\nu64 start, now;\r\nu64 t1;\r\ndw_apb_clocksource_start(clocksource_apbt);\r\nt1 = dw_apb_clocksource_read(clocksource_apbt);\r\nstart = rdtsc();\r\ndo {\r\nrep_nop();\r\nnow = rdtsc();\r\n} while ((now - start) < 200000UL);\r\nif (t1 == dw_apb_clocksource_read(clocksource_apbt))\r\npanic("APBT counter not counting. APBT disabled\n");\r\ndw_apb_clocksource_register(clocksource_apbt);\r\nreturn 0;\r\n}\r\nvoid __init apbt_time_init(void)\r\n{\r\n#ifdef CONFIG_SMP\r\nint i;\r\nstruct sfi_timer_table_entry *p_mtmr;\r\nstruct apbt_dev *adev;\r\n#endif\r\nif (apb_timer_block_enabled)\r\nreturn;\r\napbt_set_mapping();\r\nif (!apbt_virt_address)\r\ngoto out_noapbt;\r\nif (apbt_freq < APBT_MIN_FREQ || apbt_freq > APBT_MAX_FREQ) {\r\npr_debug("APBT has invalid freq 0x%lx\n", apbt_freq);\r\ngoto out_noapbt;\r\n}\r\nif (apbt_clocksource_register()) {\r\npr_debug("APBT has failed to register clocksource\n");\r\ngoto out_noapbt;\r\n}\r\nif (!apbt_clockevent_register())\r\napb_timer_block_enabled = 1;\r\nelse {\r\npr_debug("APBT has failed to register clockevent\n");\r\ngoto out_noapbt;\r\n}\r\n#ifdef CONFIG_SMP\r\nif (intel_mid_timer_options == INTEL_MID_TIMER_LAPIC_APBT) {\r\nprintk(KERN_INFO "apbt: disabled per cpu timer\n");\r\nreturn;\r\n}\r\npr_debug("%s: %d CPUs online\n", __func__, num_online_cpus());\r\nif (num_possible_cpus() <= sfi_mtimer_num)\r\napbt_num_timers_used = num_possible_cpus();\r\nelse\r\napbt_num_timers_used = 1;\r\npr_debug("%s: %d APB timers used\n", __func__, apbt_num_timers_used);\r\nfor (i = 0; i < apbt_num_timers_used; i++) {\r\nadev = &per_cpu(cpu_apbt_dev, i);\r\nadev->num = i;\r\nadev->cpu = i;\r\np_mtmr = sfi_get_mtmr(i);\r\nif (p_mtmr)\r\nadev->irq = p_mtmr->irq;\r\nelse\r\nprintk(KERN_ERR "Failed to get timer for cpu %d\n", i);\r\nsnprintf(adev->name, sizeof(adev->name) - 1, "apbt%d", i);\r\n}\r\n#endif\r\nreturn;\r\nout_noapbt:\r\napbt_clear_mapping();\r\napb_timer_block_enabled = 0;\r\npanic("failed to enable APB timer\n");\r\n}\r\nunsigned long apbt_quick_calibrate(void)\r\n{\r\nint i, scale;\r\nu64 old, new;\r\nu64 t1, t2;\r\nunsigned long khz = 0;\r\nu32 loop, shift;\r\napbt_set_mapping();\r\ndw_apb_clocksource_start(clocksource_apbt);\r\nold = dw_apb_clocksource_read(clocksource_apbt);\r\ni = 10000;\r\nwhile (--i) {\r\nif (old != dw_apb_clocksource_read(clocksource_apbt))\r\nbreak;\r\n}\r\nif (!i)\r\ngoto failed;\r\nloop = (apbt_freq / 1000) << 4;\r\ndw_apb_clocksource_start(clocksource_apbt);\r\nold = dw_apb_clocksource_read(clocksource_apbt);\r\nold += loop;\r\nt1 = rdtsc();\r\ndo {\r\nnew = dw_apb_clocksource_read(clocksource_apbt);\r\n} while (new < old);\r\nt2 = rdtsc();\r\nshift = 5;\r\nif (unlikely(loop >> shift == 0)) {\r\nprintk(KERN_INFO\r\n"APBT TSC calibration failed, not enough resolution\n");\r\nreturn 0;\r\n}\r\nscale = (int)div_u64((t2 - t1), loop >> shift);\r\nkhz = (scale * (apbt_freq / 1000)) >> shift;\r\nprintk(KERN_INFO "TSC freq calculated by APB timer is %lu khz\n", khz);\r\nreturn khz;\r\nfailed:\r\nreturn 0;\r\n}
