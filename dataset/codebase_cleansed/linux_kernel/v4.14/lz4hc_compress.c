static U32 LZ4HC_hashPtr(const void *ptr)\r\n{\r\nreturn HASH_FUNCTION(LZ4_read32(ptr));\r\n}\r\nstatic void LZ4HC_init(LZ4HC_CCtx_internal *hc4, const BYTE *start)\r\n{\r\nmemset((void *)hc4->hashTable, 0, sizeof(hc4->hashTable));\r\nmemset(hc4->chainTable, 0xFF, sizeof(hc4->chainTable));\r\nhc4->nextToUpdate = 64 * KB;\r\nhc4->base = start - 64 * KB;\r\nhc4->end = start;\r\nhc4->dictBase = start - 64 * KB;\r\nhc4->dictLimit = 64 * KB;\r\nhc4->lowLimit = 64 * KB;\r\n}\r\nstatic FORCE_INLINE void LZ4HC_Insert(LZ4HC_CCtx_internal *hc4,\r\nconst BYTE *ip)\r\n{\r\nU16 * const chainTable = hc4->chainTable;\r\nU32 * const hashTable = hc4->hashTable;\r\nconst BYTE * const base = hc4->base;\r\nU32 const target = (U32)(ip - base);\r\nU32 idx = hc4->nextToUpdate;\r\nwhile (idx < target) {\r\nU32 const h = LZ4HC_hashPtr(base + idx);\r\nsize_t delta = idx - hashTable[h];\r\nif (delta > MAX_DISTANCE)\r\ndelta = MAX_DISTANCE;\r\nDELTANEXTU16(idx) = (U16)delta;\r\nhashTable[h] = idx;\r\nidx++;\r\n}\r\nhc4->nextToUpdate = target;\r\n}\r\nstatic FORCE_INLINE int LZ4HC_InsertAndFindBestMatch(\r\nLZ4HC_CCtx_internal *hc4,\r\nconst BYTE *ip,\r\nconst BYTE * const iLimit,\r\nconst BYTE **matchpos,\r\nconst int maxNbAttempts)\r\n{\r\nU16 * const chainTable = hc4->chainTable;\r\nU32 * const HashTable = hc4->hashTable;\r\nconst BYTE * const base = hc4->base;\r\nconst BYTE * const dictBase = hc4->dictBase;\r\nconst U32 dictLimit = hc4->dictLimit;\r\nconst U32 lowLimit = (hc4->lowLimit + 64 * KB > (U32)(ip - base))\r\n? hc4->lowLimit\r\n: (U32)(ip - base) - (64 * KB - 1);\r\nU32 matchIndex;\r\nint nbAttempts = maxNbAttempts;\r\nsize_t ml = 0;\r\nLZ4HC_Insert(hc4, ip);\r\nmatchIndex = HashTable[LZ4HC_hashPtr(ip)];\r\nwhile ((matchIndex >= lowLimit)\r\n&& (nbAttempts)) {\r\nnbAttempts--;\r\nif (matchIndex >= dictLimit) {\r\nconst BYTE * const match = base + matchIndex;\r\nif (*(match + ml) == *(ip + ml)\r\n&& (LZ4_read32(match) == LZ4_read32(ip))) {\r\nsize_t const mlt = LZ4_count(ip + MINMATCH,\r\nmatch + MINMATCH, iLimit) + MINMATCH;\r\nif (mlt > ml) {\r\nml = mlt;\r\n*matchpos = match;\r\n}\r\n}\r\n} else {\r\nconst BYTE * const match = dictBase + matchIndex;\r\nif (LZ4_read32(match) == LZ4_read32(ip)) {\r\nsize_t mlt;\r\nconst BYTE *vLimit = ip\r\n+ (dictLimit - matchIndex);\r\nif (vLimit > iLimit)\r\nvLimit = iLimit;\r\nmlt = LZ4_count(ip + MINMATCH,\r\nmatch + MINMATCH, vLimit) + MINMATCH;\r\nif ((ip + mlt == vLimit)\r\n&& (vLimit < iLimit))\r\nmlt += LZ4_count(ip + mlt,\r\nbase + dictLimit,\r\niLimit);\r\nif (mlt > ml) {\r\nml = mlt;\r\n*matchpos = base + matchIndex;\r\n}\r\n}\r\n}\r\nmatchIndex -= DELTANEXTU16(matchIndex);\r\n}\r\nreturn (int)ml;\r\n}\r\nstatic FORCE_INLINE int LZ4HC_InsertAndGetWiderMatch(\r\nLZ4HC_CCtx_internal *hc4,\r\nconst BYTE * const ip,\r\nconst BYTE * const iLowLimit,\r\nconst BYTE * const iHighLimit,\r\nint longest,\r\nconst BYTE **matchpos,\r\nconst BYTE **startpos,\r\nconst int maxNbAttempts)\r\n{\r\nU16 * const chainTable = hc4->chainTable;\r\nU32 * const HashTable = hc4->hashTable;\r\nconst BYTE * const base = hc4->base;\r\nconst U32 dictLimit = hc4->dictLimit;\r\nconst BYTE * const lowPrefixPtr = base + dictLimit;\r\nconst U32 lowLimit = (hc4->lowLimit + 64 * KB > (U32)(ip - base))\r\n? hc4->lowLimit\r\n: (U32)(ip - base) - (64 * KB - 1);\r\nconst BYTE * const dictBase = hc4->dictBase;\r\nU32 matchIndex;\r\nint nbAttempts = maxNbAttempts;\r\nint delta = (int)(ip - iLowLimit);\r\nLZ4HC_Insert(hc4, ip);\r\nmatchIndex = HashTable[LZ4HC_hashPtr(ip)];\r\nwhile ((matchIndex >= lowLimit)\r\n&& (nbAttempts)) {\r\nnbAttempts--;\r\nif (matchIndex >= dictLimit) {\r\nconst BYTE *matchPtr = base + matchIndex;\r\nif (*(iLowLimit + longest)\r\n== *(matchPtr - delta + longest)) {\r\nif (LZ4_read32(matchPtr) == LZ4_read32(ip)) {\r\nint mlt = MINMATCH + LZ4_count(\r\nip + MINMATCH,\r\nmatchPtr + MINMATCH,\r\niHighLimit);\r\nint back = 0;\r\nwhile ((ip + back > iLowLimit)\r\n&& (matchPtr + back > lowPrefixPtr)\r\n&& (ip[back - 1] == matchPtr[back - 1]))\r\nback--;\r\nmlt -= back;\r\nif (mlt > longest) {\r\nlongest = (int)mlt;\r\n*matchpos = matchPtr + back;\r\n*startpos = ip + back;\r\n}\r\n}\r\n}\r\n} else {\r\nconst BYTE * const matchPtr = dictBase + matchIndex;\r\nif (LZ4_read32(matchPtr) == LZ4_read32(ip)) {\r\nsize_t mlt;\r\nint back = 0;\r\nconst BYTE *vLimit = ip + (dictLimit - matchIndex);\r\nif (vLimit > iHighLimit)\r\nvLimit = iHighLimit;\r\nmlt = LZ4_count(ip + MINMATCH,\r\nmatchPtr + MINMATCH, vLimit) + MINMATCH;\r\nif ((ip + mlt == vLimit) && (vLimit < iHighLimit))\r\nmlt += LZ4_count(ip + mlt, base + dictLimit,\r\niHighLimit);\r\nwhile ((ip + back > iLowLimit)\r\n&& (matchIndex + back > lowLimit)\r\n&& (ip[back - 1] == matchPtr[back - 1]))\r\nback--;\r\nmlt -= back;\r\nif ((int)mlt > longest) {\r\nlongest = (int)mlt;\r\n*matchpos = base + matchIndex + back;\r\n*startpos = ip + back;\r\n}\r\n}\r\n}\r\nmatchIndex -= DELTANEXTU16(matchIndex);\r\n}\r\nreturn longest;\r\n}\r\nstatic FORCE_INLINE int LZ4HC_encodeSequence(\r\nconst BYTE **ip,\r\nBYTE **op,\r\nconst BYTE **anchor,\r\nint matchLength,\r\nconst BYTE * const match,\r\nlimitedOutput_directive limitedOutputBuffer,\r\nBYTE *oend)\r\n{\r\nint length;\r\nBYTE *token;\r\nlength = (int)(*ip - *anchor);\r\ntoken = (*op)++;\r\nif ((limitedOutputBuffer)\r\n&& ((*op + (length>>8)\r\n+ length + (2 + 1 + LASTLITERALS)) > oend)) {\r\nreturn 1;\r\n}\r\nif (length >= (int)RUN_MASK) {\r\nint len;\r\n*token = (RUN_MASK<<ML_BITS);\r\nlen = length - RUN_MASK;\r\nfor (; len > 254 ; len -= 255)\r\n*(*op)++ = 255;\r\n*(*op)++ = (BYTE)len;\r\n} else\r\n*token = (BYTE)(length<<ML_BITS);\r\nLZ4_wildCopy(*op, *anchor, (*op) + length);\r\n*op += length;\r\nLZ4_writeLE16(*op, (U16)(*ip - match));\r\n*op += 2;\r\nlength = (int)(matchLength - MINMATCH);\r\nif ((limitedOutputBuffer)\r\n&& (*op + (length>>8)\r\n+ (1 + LASTLITERALS) > oend)) {\r\nreturn 1;\r\n}\r\nif (length >= (int)ML_MASK) {\r\n*token += ML_MASK;\r\nlength -= ML_MASK;\r\nfor (; length > 509 ; length -= 510) {\r\n*(*op)++ = 255;\r\n*(*op)++ = 255;\r\n}\r\nif (length > 254) {\r\nlength -= 255;\r\n*(*op)++ = 255;\r\n}\r\n*(*op)++ = (BYTE)length;\r\n} else\r\n*token += (BYTE)(length);\r\n*ip += matchLength;\r\n*anchor = *ip;\r\nreturn 0;\r\n}\r\nstatic int LZ4HC_compress_generic(\r\nLZ4HC_CCtx_internal *const ctx,\r\nconst char * const source,\r\nchar * const dest,\r\nint const inputSize,\r\nint const maxOutputSize,\r\nint compressionLevel,\r\nlimitedOutput_directive limit\r\n)\r\n{\r\nconst BYTE *ip = (const BYTE *) source;\r\nconst BYTE *anchor = ip;\r\nconst BYTE * const iend = ip + inputSize;\r\nconst BYTE * const mflimit = iend - MFLIMIT;\r\nconst BYTE * const matchlimit = (iend - LASTLITERALS);\r\nBYTE *op = (BYTE *) dest;\r\nBYTE * const oend = op + maxOutputSize;\r\nunsigned int maxNbAttempts;\r\nint ml, ml2, ml3, ml0;\r\nconst BYTE *ref = NULL;\r\nconst BYTE *start2 = NULL;\r\nconst BYTE *ref2 = NULL;\r\nconst BYTE *start3 = NULL;\r\nconst BYTE *ref3 = NULL;\r\nconst BYTE *start0;\r\nconst BYTE *ref0;\r\nif (compressionLevel > LZ4HC_MAX_CLEVEL)\r\ncompressionLevel = LZ4HC_MAX_CLEVEL;\r\nif (compressionLevel < 1)\r\ncompressionLevel = LZ4HC_DEFAULT_CLEVEL;\r\nmaxNbAttempts = 1 << (compressionLevel - 1);\r\nctx->end += inputSize;\r\nip++;\r\nwhile (ip < mflimit) {\r\nml = LZ4HC_InsertAndFindBestMatch(ctx, ip,\r\nmatchlimit, (&ref), maxNbAttempts);\r\nif (!ml) {\r\nip++;\r\ncontinue;\r\n}\r\nstart0 = ip;\r\nref0 = ref;\r\nml0 = ml;\r\n_Search2:\r\nif (ip + ml < mflimit)\r\nml2 = LZ4HC_InsertAndGetWiderMatch(ctx,\r\nip + ml - 2, ip + 0,\r\nmatchlimit, ml, &ref2,\r\n&start2, maxNbAttempts);\r\nelse\r\nml2 = ml;\r\nif (ml2 == ml) {\r\nif (LZ4HC_encodeSequence(&ip, &op,\r\n&anchor, ml, ref, limit, oend))\r\nreturn 0;\r\ncontinue;\r\n}\r\nif (start0 < ip) {\r\nif (start2 < ip + ml0) {\r\nip = start0;\r\nref = ref0;\r\nml = ml0;\r\n}\r\n}\r\nif ((start2 - ip) < 3) {\r\nml = ml2;\r\nip = start2;\r\nref = ref2;\r\ngoto _Search2;\r\n}\r\n_Search3:\r\nif ((start2 - ip) < OPTIMAL_ML) {\r\nint correction;\r\nint new_ml = ml;\r\nif (new_ml > OPTIMAL_ML)\r\nnew_ml = OPTIMAL_ML;\r\nif (ip + new_ml > start2 + ml2 - MINMATCH)\r\nnew_ml = (int)(start2 - ip) + ml2 - MINMATCH;\r\ncorrection = new_ml - (int)(start2 - ip);\r\nif (correction > 0) {\r\nstart2 += correction;\r\nref2 += correction;\r\nml2 -= correction;\r\n}\r\n}\r\nif (start2 + ml2 < mflimit)\r\nml3 = LZ4HC_InsertAndGetWiderMatch(ctx,\r\nstart2 + ml2 - 3, start2,\r\nmatchlimit, ml2, &ref3, &start3,\r\nmaxNbAttempts);\r\nelse\r\nml3 = ml2;\r\nif (ml3 == ml2) {\r\nif (start2 < ip + ml)\r\nml = (int)(start2 - ip);\r\nif (LZ4HC_encodeSequence(&ip, &op, &anchor,\r\nml, ref, limit, oend))\r\nreturn 0;\r\nip = start2;\r\nif (LZ4HC_encodeSequence(&ip, &op, &anchor,\r\nml2, ref2, limit, oend))\r\nreturn 0;\r\ncontinue;\r\n}\r\nif (start3 < ip + ml + 3) {\r\nif (start3 >= (ip + ml)) {\r\nif (start2 < ip + ml) {\r\nint correction = (int)(ip + ml - start2);\r\nstart2 += correction;\r\nref2 += correction;\r\nml2 -= correction;\r\nif (ml2 < MINMATCH) {\r\nstart2 = start3;\r\nref2 = ref3;\r\nml2 = ml3;\r\n}\r\n}\r\nif (LZ4HC_encodeSequence(&ip, &op, &anchor,\r\nml, ref, limit, oend))\r\nreturn 0;\r\nip = start3;\r\nref = ref3;\r\nml = ml3;\r\nstart0 = start2;\r\nref0 = ref2;\r\nml0 = ml2;\r\ngoto _Search2;\r\n}\r\nstart2 = start3;\r\nref2 = ref3;\r\nml2 = ml3;\r\ngoto _Search3;\r\n}\r\nif (start2 < ip + ml) {\r\nif ((start2 - ip) < (int)ML_MASK) {\r\nint correction;\r\nif (ml > OPTIMAL_ML)\r\nml = OPTIMAL_ML;\r\nif (ip + ml > start2 + ml2 - MINMATCH)\r\nml = (int)(start2 - ip) + ml2 - MINMATCH;\r\ncorrection = ml - (int)(start2 - ip);\r\nif (correction > 0) {\r\nstart2 += correction;\r\nref2 += correction;\r\nml2 -= correction;\r\n}\r\n} else\r\nml = (int)(start2 - ip);\r\n}\r\nif (LZ4HC_encodeSequence(&ip, &op, &anchor, ml,\r\nref, limit, oend))\r\nreturn 0;\r\nip = start2;\r\nref = ref2;\r\nml = ml2;\r\nstart2 = start3;\r\nref2 = ref3;\r\nml2 = ml3;\r\ngoto _Search3;\r\n}\r\n{\r\nint lastRun = (int)(iend - anchor);\r\nif ((limit)\r\n&& (((char *)op - dest) + lastRun + 1\r\n+ ((lastRun + 255 - RUN_MASK)/255)\r\n> (U32)maxOutputSize)) {\r\nreturn 0;\r\n}\r\nif (lastRun >= (int)RUN_MASK) {\r\n*op++ = (RUN_MASK<<ML_BITS);\r\nlastRun -= RUN_MASK;\r\nfor (; lastRun > 254 ; lastRun -= 255)\r\n*op++ = 255;\r\n*op++ = (BYTE) lastRun;\r\n} else\r\n*op++ = (BYTE)(lastRun<<ML_BITS);\r\nmemcpy(op, anchor, iend - anchor);\r\nop += iend - anchor;\r\n}\r\nreturn (int) (((char *)op) - dest);\r\n}\r\nstatic int LZ4_compress_HC_extStateHC(\r\nvoid *state,\r\nconst char *src,\r\nchar *dst,\r\nint srcSize,\r\nint maxDstSize,\r\nint compressionLevel)\r\n{\r\nLZ4HC_CCtx_internal *ctx = &((LZ4_streamHC_t *)state)->internal_donotuse;\r\nif (((size_t)(state)&(sizeof(void *) - 1)) != 0) {\r\nreturn 0;\r\n}\r\nLZ4HC_init(ctx, (const BYTE *)src);\r\nif (maxDstSize < LZ4_compressBound(srcSize))\r\nreturn LZ4HC_compress_generic(ctx, src, dst,\r\nsrcSize, maxDstSize, compressionLevel, limitedOutput);\r\nelse\r\nreturn LZ4HC_compress_generic(ctx, src, dst,\r\nsrcSize, maxDstSize, compressionLevel, noLimit);\r\n}\r\nint LZ4_compress_HC(const char *src, char *dst, int srcSize,\r\nint maxDstSize, int compressionLevel, void *wrkmem)\r\n{\r\nreturn LZ4_compress_HC_extStateHC(wrkmem, src, dst,\r\nsrcSize, maxDstSize, compressionLevel);\r\n}\r\nvoid LZ4_resetStreamHC(LZ4_streamHC_t *LZ4_streamHCPtr, int compressionLevel)\r\n{\r\nLZ4_streamHCPtr->internal_donotuse.base = NULL;\r\nLZ4_streamHCPtr->internal_donotuse.compressionLevel = (unsigned int)compressionLevel;\r\n}\r\nint LZ4_loadDictHC(LZ4_streamHC_t *LZ4_streamHCPtr,\r\nconst char *dictionary,\r\nint dictSize)\r\n{\r\nLZ4HC_CCtx_internal *ctxPtr = &LZ4_streamHCPtr->internal_donotuse;\r\nif (dictSize > 64 * KB) {\r\ndictionary += dictSize - 64 * KB;\r\ndictSize = 64 * KB;\r\n}\r\nLZ4HC_init(ctxPtr, (const BYTE *)dictionary);\r\nif (dictSize >= 4)\r\nLZ4HC_Insert(ctxPtr, (const BYTE *)dictionary + (dictSize - 3));\r\nctxPtr->end = (const BYTE *)dictionary + dictSize;\r\nreturn dictSize;\r\n}\r\nstatic void LZ4HC_setExternalDict(\r\nLZ4HC_CCtx_internal *ctxPtr,\r\nconst BYTE *newBlock)\r\n{\r\nif (ctxPtr->end >= ctxPtr->base + 4) {\r\nLZ4HC_Insert(ctxPtr, ctxPtr->end - 3);\r\n}\r\nctxPtr->lowLimit = ctxPtr->dictLimit;\r\nctxPtr->dictLimit = (U32)(ctxPtr->end - ctxPtr->base);\r\nctxPtr->dictBase = ctxPtr->base;\r\nctxPtr->base = newBlock - ctxPtr->dictLimit;\r\nctxPtr->end = newBlock;\r\nctxPtr->nextToUpdate = ctxPtr->dictLimit;\r\n}\r\nstatic int LZ4_compressHC_continue_generic(\r\nLZ4_streamHC_t *LZ4_streamHCPtr,\r\nconst char *source,\r\nchar *dest,\r\nint inputSize,\r\nint maxOutputSize,\r\nlimitedOutput_directive limit)\r\n{\r\nLZ4HC_CCtx_internal *ctxPtr = &LZ4_streamHCPtr->internal_donotuse;\r\nif (ctxPtr->base == NULL)\r\nLZ4HC_init(ctxPtr, (const BYTE *) source);\r\nif ((size_t)(ctxPtr->end - ctxPtr->base) > 2 * GB) {\r\nsize_t dictSize = (size_t)(ctxPtr->end - ctxPtr->base)\r\n- ctxPtr->dictLimit;\r\nif (dictSize > 64 * KB)\r\ndictSize = 64 * KB;\r\nLZ4_loadDictHC(LZ4_streamHCPtr,\r\n(const char *)(ctxPtr->end) - dictSize, (int)dictSize);\r\n}\r\nif ((const BYTE *)source != ctxPtr->end)\r\nLZ4HC_setExternalDict(ctxPtr, (const BYTE *)source);\r\n{\r\nconst BYTE *sourceEnd = (const BYTE *) source + inputSize;\r\nconst BYTE * const dictBegin = ctxPtr->dictBase + ctxPtr->lowLimit;\r\nconst BYTE * const dictEnd = ctxPtr->dictBase + ctxPtr->dictLimit;\r\nif ((sourceEnd > dictBegin)\r\n&& ((const BYTE *)source < dictEnd)) {\r\nif (sourceEnd > dictEnd)\r\nsourceEnd = dictEnd;\r\nctxPtr->lowLimit = (U32)(sourceEnd - ctxPtr->dictBase);\r\nif (ctxPtr->dictLimit - ctxPtr->lowLimit < 4)\r\nctxPtr->lowLimit = ctxPtr->dictLimit;\r\n}\r\n}\r\nreturn LZ4HC_compress_generic(ctxPtr, source, dest,\r\ninputSize, maxOutputSize, ctxPtr->compressionLevel, limit);\r\n}\r\nint LZ4_compress_HC_continue(\r\nLZ4_streamHC_t *LZ4_streamHCPtr,\r\nconst char *source,\r\nchar *dest,\r\nint inputSize,\r\nint maxOutputSize)\r\n{\r\nif (maxOutputSize < LZ4_compressBound(inputSize))\r\nreturn LZ4_compressHC_continue_generic(LZ4_streamHCPtr,\r\nsource, dest, inputSize, maxOutputSize, limitedOutput);\r\nelse\r\nreturn LZ4_compressHC_continue_generic(LZ4_streamHCPtr,\r\nsource, dest, inputSize, maxOutputSize, noLimit);\r\n}\r\nint LZ4_saveDictHC(\r\nLZ4_streamHC_t *LZ4_streamHCPtr,\r\nchar *safeBuffer,\r\nint dictSize)\r\n{\r\nLZ4HC_CCtx_internal *const streamPtr = &LZ4_streamHCPtr->internal_donotuse;\r\nint const prefixSize = (int)(streamPtr->end\r\n- (streamPtr->base + streamPtr->dictLimit));\r\nif (dictSize > 64 * KB)\r\ndictSize = 64 * KB;\r\nif (dictSize < 4)\r\ndictSize = 0;\r\nif (dictSize > prefixSize)\r\ndictSize = prefixSize;\r\nmemmove(safeBuffer, streamPtr->end - dictSize, dictSize);\r\n{\r\nU32 const endIndex = (U32)(streamPtr->end - streamPtr->base);\r\nstreamPtr->end = (const BYTE *)safeBuffer + dictSize;\r\nstreamPtr->base = streamPtr->end - endIndex;\r\nstreamPtr->dictLimit = endIndex - dictSize;\r\nstreamPtr->lowLimit = endIndex - dictSize;\r\nif (streamPtr->nextToUpdate < streamPtr->dictLimit)\r\nstreamPtr->nextToUpdate = streamPtr->dictLimit;\r\n}\r\nreturn dictSize;\r\n}
