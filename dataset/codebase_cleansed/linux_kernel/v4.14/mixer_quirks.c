static int snd_create_std_mono_ctl_offset(struct usb_mixer_interface *mixer,\r\nunsigned int unitid,\r\nunsigned int control,\r\nunsigned int cmask,\r\nint val_type,\r\nunsigned int idx_off,\r\nconst char *name,\r\nsnd_kcontrol_tlv_rw_t *tlv_callback)\r\n{\r\nstruct usb_mixer_elem_info *cval;\r\nstruct snd_kcontrol *kctl;\r\ncval = kzalloc(sizeof(*cval), GFP_KERNEL);\r\nif (!cval)\r\nreturn -ENOMEM;\r\nsnd_usb_mixer_elem_init_std(&cval->head, mixer, unitid);\r\ncval->val_type = val_type;\r\ncval->channels = 1;\r\ncval->control = control;\r\ncval->cmask = cmask;\r\ncval->idx_off = idx_off;\r\ncval->min = 0;\r\ncval->max = 1;\r\ncval->res = 0;\r\ncval->dBmin = 0;\r\ncval->dBmax = 0;\r\nkctl = snd_ctl_new1(snd_usb_feature_unit_ctl, cval);\r\nif (!kctl) {\r\nkfree(cval);\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(kctl->id.name, sizeof(kctl->id.name), name);\r\nkctl->private_free = snd_usb_mixer_elem_free;\r\nif (tlv_callback) {\r\nkctl->tlv.c = tlv_callback;\r\nkctl->vd[0].access |=\r\nSNDRV_CTL_ELEM_ACCESS_TLV_READ |\r\nSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\r\n}\r\nreturn snd_usb_mixer_add_control(&cval->head, kctl);\r\n}\r\nstatic int snd_create_std_mono_ctl(struct usb_mixer_interface *mixer,\r\nunsigned int unitid,\r\nunsigned int control,\r\nunsigned int cmask,\r\nint val_type,\r\nconst char *name,\r\nsnd_kcontrol_tlv_rw_t *tlv_callback)\r\n{\r\nreturn snd_create_std_mono_ctl_offset(mixer, unitid, control, cmask,\r\nval_type, 0 , name, tlv_callback);\r\n}\r\nstatic int snd_create_std_mono_table(struct usb_mixer_interface *mixer,\r\nstruct std_mono_table *t)\r\n{\r\nint err;\r\nwhile (t->name != NULL) {\r\nerr = snd_create_std_mono_ctl(mixer, t->unitid, t->control,\r\nt->cmask, t->val_type, t->name, t->tlv_callback);\r\nif (err < 0)\r\nreturn err;\r\nt++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int add_single_ctl_with_resume(struct usb_mixer_interface *mixer,\r\nint id,\r\nusb_mixer_elem_resume_func_t resume,\r\nconst struct snd_kcontrol_new *knew,\r\nstruct usb_mixer_elem_list **listp)\r\n{\r\nstruct usb_mixer_elem_list *list;\r\nstruct snd_kcontrol *kctl;\r\nlist = kzalloc(sizeof(*list), GFP_KERNEL);\r\nif (!list)\r\nreturn -ENOMEM;\r\nif (listp)\r\n*listp = list;\r\nlist->mixer = mixer;\r\nlist->id = id;\r\nlist->resume = resume;\r\nkctl = snd_ctl_new1(knew, list);\r\nif (!kctl) {\r\nkfree(list);\r\nreturn -ENOMEM;\r\n}\r\nkctl->private_free = snd_usb_mixer_elem_free;\r\nreturn snd_usb_mixer_add_control(list, kctl);\r\n}\r\nstatic void snd_usb_soundblaster_remote_complete(struct urb *urb)\r\n{\r\nstruct usb_mixer_interface *mixer = urb->context;\r\nconst struct rc_config *rc = mixer->rc_cfg;\r\nu32 code;\r\nif (urb->status < 0 || urb->actual_length < rc->min_packet_length)\r\nreturn;\r\ncode = mixer->rc_buffer[rc->offset];\r\nif (rc->length == 2)\r\ncode |= mixer->rc_buffer[rc->offset + 1] << 8;\r\nif (code == rc->mute_code)\r\nsnd_usb_mixer_notify_id(mixer, rc->mute_mixer_id);\r\nmixer->rc_code = code;\r\nwmb();\r\nwake_up(&mixer->rc_waitq);\r\n}\r\nstatic long snd_usb_sbrc_hwdep_read(struct snd_hwdep *hw, char __user *buf,\r\nlong count, loff_t *offset)\r\n{\r\nstruct usb_mixer_interface *mixer = hw->private_data;\r\nint err;\r\nu32 rc_code;\r\nif (count != 1 && count != 4)\r\nreturn -EINVAL;\r\nerr = wait_event_interruptible(mixer->rc_waitq,\r\n(rc_code = xchg(&mixer->rc_code, 0)) != 0);\r\nif (err == 0) {\r\nif (count == 1)\r\nerr = put_user(rc_code, buf);\r\nelse\r\nerr = put_user(rc_code, (u32 __user *)buf);\r\n}\r\nreturn err < 0 ? err : count;\r\n}\r\nstatic unsigned int snd_usb_sbrc_hwdep_poll(struct snd_hwdep *hw, struct file *file,\r\npoll_table *wait)\r\n{\r\nstruct usb_mixer_interface *mixer = hw->private_data;\r\npoll_wait(file, &mixer->rc_waitq, wait);\r\nreturn mixer->rc_code ? POLLIN | POLLRDNORM : 0;\r\n}\r\nstatic int snd_usb_soundblaster_remote_init(struct usb_mixer_interface *mixer)\r\n{\r\nstruct snd_hwdep *hwdep;\r\nint err, len, i;\r\nfor (i = 0; i < ARRAY_SIZE(rc_configs); ++i)\r\nif (rc_configs[i].usb_id == mixer->chip->usb_id)\r\nbreak;\r\nif (i >= ARRAY_SIZE(rc_configs))\r\nreturn 0;\r\nmixer->rc_cfg = &rc_configs[i];\r\nlen = mixer->rc_cfg->packet_length;\r\ninit_waitqueue_head(&mixer->rc_waitq);\r\nerr = snd_hwdep_new(mixer->chip->card, "SB remote control", 0, &hwdep);\r\nif (err < 0)\r\nreturn err;\r\nsnprintf(hwdep->name, sizeof(hwdep->name),\r\n"%s remote control", mixer->chip->card->shortname);\r\nhwdep->iface = SNDRV_HWDEP_IFACE_SB_RC;\r\nhwdep->private_data = mixer;\r\nhwdep->ops.read = snd_usb_sbrc_hwdep_read;\r\nhwdep->ops.poll = snd_usb_sbrc_hwdep_poll;\r\nhwdep->exclusive = 1;\r\nmixer->rc_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!mixer->rc_urb)\r\nreturn -ENOMEM;\r\nmixer->rc_setup_packet = kmalloc(sizeof(*mixer->rc_setup_packet), GFP_KERNEL);\r\nif (!mixer->rc_setup_packet) {\r\nusb_free_urb(mixer->rc_urb);\r\nmixer->rc_urb = NULL;\r\nreturn -ENOMEM;\r\n}\r\nmixer->rc_setup_packet->bRequestType =\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE;\r\nmixer->rc_setup_packet->bRequest = UAC_GET_MEM;\r\nmixer->rc_setup_packet->wValue = cpu_to_le16(0);\r\nmixer->rc_setup_packet->wIndex = cpu_to_le16(0);\r\nmixer->rc_setup_packet->wLength = cpu_to_le16(len);\r\nusb_fill_control_urb(mixer->rc_urb, mixer->chip->dev,\r\nusb_rcvctrlpipe(mixer->chip->dev, 0),\r\n(u8*)mixer->rc_setup_packet, mixer->rc_buffer, len,\r\nsnd_usb_soundblaster_remote_complete, mixer);\r\nreturn 0;\r\n}\r\nstatic int snd_audigy2nx_led_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.integer.value[0] = kcontrol->private_value >> 8;\r\nreturn 0;\r\n}\r\nstatic int snd_audigy2nx_led_update(struct usb_mixer_interface *mixer,\r\nint value, int index)\r\n{\r\nstruct snd_usb_audio *chip = mixer->chip;\r\nint err;\r\nerr = snd_usb_lock_shutdown(chip);\r\nif (err < 0)\r\nreturn err;\r\nif (chip->usb_id == USB_ID(0x041e, 0x3042))\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_sndctrlpipe(chip->dev, 0), 0x24,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\n!value, 0, NULL, 0);\r\nif (chip->usb_id == USB_ID(0x041e, 0x30df))\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_sndctrlpipe(chip->dev, 0), 0x24,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\n!value, 0, NULL, 0);\r\nelse\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_sndctrlpipe(chip->dev, 0), 0x24,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\nvalue, index + 2, NULL, 0);\r\nsnd_usb_unlock_shutdown(chip);\r\nreturn err;\r\n}\r\nstatic int snd_audigy2nx_led_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\r\nstruct usb_mixer_interface *mixer = list->mixer;\r\nint index = kcontrol->private_value & 0xff;\r\nunsigned int value = ucontrol->value.integer.value[0];\r\nint old_value = kcontrol->private_value >> 8;\r\nint err;\r\nif (value > 1)\r\nreturn -EINVAL;\r\nif (value == old_value)\r\nreturn 0;\r\nkcontrol->private_value = (value << 8) | index;\r\nerr = snd_audigy2nx_led_update(mixer, value, index);\r\nreturn err < 0 ? err : 1;\r\n}\r\nstatic int snd_audigy2nx_led_resume(struct usb_mixer_elem_list *list)\r\n{\r\nint priv_value = list->kctl->private_value;\r\nreturn snd_audigy2nx_led_update(list->mixer, priv_value >> 8,\r\npriv_value & 0xff);\r\n}\r\nstatic int snd_audigy2nx_controls_create(struct usb_mixer_interface *mixer)\r\n{\r\nint i, err;\r\nfor (i = 0; i < ARRAY_SIZE(snd_audigy2nx_led_names); ++i) {\r\nstruct snd_kcontrol_new knew;\r\nif ((mixer->chip->usb_id == USB_ID(0x041e, 0x3042)) && i == 0)\r\ncontinue;\r\nif ((mixer->chip->usb_id == USB_ID(0x041e, 0x30df)) && i == 0)\r\ncontinue;\r\nif (i > 1 &&\r\n(mixer->chip->usb_id == USB_ID(0x041e, 0x3040) ||\r\nmixer->chip->usb_id == USB_ID(0x041e, 0x3042) ||\r\nmixer->chip->usb_id == USB_ID(0x041e, 0x30df) ||\r\nmixer->chip->usb_id == USB_ID(0x041e, 0x3048)))\r\nbreak;\r\nknew = snd_audigy2nx_control;\r\nknew.name = snd_audigy2nx_led_names[i];\r\nknew.private_value = (1 << 8) | i;\r\nerr = add_single_ctl_with_resume(mixer, 0,\r\nsnd_audigy2nx_led_resume,\r\n&knew, NULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_audigy2nx_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstatic const struct sb_jack {\r\nint unitid;\r\nconst char *name;\r\n} jacks_audigy2nx[] = {\r\n{4, "dig in "},\r\n{7, "line in"},\r\n{19, "spk out"},\r\n{20, "hph out"},\r\n{-1, NULL}\r\n}, jacks_live24ext[] = {\r\n{4, "line in"},\r\n{3, "hph out"},\r\n{0, "RC "},\r\n{-1, NULL}\r\n};\r\nconst struct sb_jack *jacks;\r\nstruct usb_mixer_interface *mixer = entry->private_data;\r\nint i, err;\r\nu8 buf[3];\r\nsnd_iprintf(buffer, "%s jacks\n\n", mixer->chip->card->shortname);\r\nif (mixer->chip->usb_id == USB_ID(0x041e, 0x3020))\r\njacks = jacks_audigy2nx;\r\nelse if (mixer->chip->usb_id == USB_ID(0x041e, 0x3040) ||\r\nmixer->chip->usb_id == USB_ID(0x041e, 0x3048))\r\njacks = jacks_live24ext;\r\nelse\r\nreturn;\r\nfor (i = 0; jacks[i].name; ++i) {\r\nsnd_iprintf(buffer, "%s: ", jacks[i].name);\r\nerr = snd_usb_lock_shutdown(mixer->chip);\r\nif (err < 0)\r\nreturn;\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_rcvctrlpipe(mixer->chip->dev, 0),\r\nUAC_GET_MEM, USB_DIR_IN | USB_TYPE_CLASS |\r\nUSB_RECIP_INTERFACE, 0,\r\njacks[i].unitid << 8, buf, 3);\r\nsnd_usb_unlock_shutdown(mixer->chip);\r\nif (err == 3 && (buf[0] == 3 || buf[0] == 6))\r\nsnd_iprintf(buffer, "%02x %02x\n", buf[1], buf[2]);\r\nelse\r\nsnd_iprintf(buffer, "?\n");\r\n}\r\n}\r\nstatic int snd_emu0204_ch_switch_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[2] = {"1/2", "3/4"};\r\nreturn snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(texts), texts);\r\n}\r\nstatic int snd_emu0204_ch_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.enumerated.item[0] = kcontrol->private_value;\r\nreturn 0;\r\n}\r\nstatic int snd_emu0204_ch_switch_update(struct usb_mixer_interface *mixer,\r\nint value)\r\n{\r\nstruct snd_usb_audio *chip = mixer->chip;\r\nint err;\r\nunsigned char buf[2];\r\nerr = snd_usb_lock_shutdown(chip);\r\nif (err < 0)\r\nreturn err;\r\nbuf[0] = 0x01;\r\nbuf[1] = value ? 0x02 : 0x01;\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_sndctrlpipe(chip->dev, 0), UAC_SET_CUR,\r\nUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,\r\n0x0400, 0x0e00, buf, 2);\r\nsnd_usb_unlock_shutdown(chip);\r\nreturn err;\r\n}\r\nstatic int snd_emu0204_ch_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\r\nstruct usb_mixer_interface *mixer = list->mixer;\r\nunsigned int value = ucontrol->value.enumerated.item[0];\r\nint err;\r\nif (value > 1)\r\nreturn -EINVAL;\r\nif (value == kcontrol->private_value)\r\nreturn 0;\r\nkcontrol->private_value = value;\r\nerr = snd_emu0204_ch_switch_update(mixer, value);\r\nreturn err < 0 ? err : 1;\r\n}\r\nstatic int snd_emu0204_ch_switch_resume(struct usb_mixer_elem_list *list)\r\n{\r\nreturn snd_emu0204_ch_switch_update(list->mixer,\r\nlist->kctl->private_value);\r\n}\r\nstatic int snd_emu0204_controls_create(struct usb_mixer_interface *mixer)\r\n{\r\nreturn add_single_ctl_with_resume(mixer, 0,\r\nsnd_emu0204_ch_switch_resume,\r\n&snd_emu0204_control, NULL);\r\n}\r\nstatic int snd_xonar_u1_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.integer.value[0] = !!(kcontrol->private_value & 0x02);\r\nreturn 0;\r\n}\r\nstatic int snd_xonar_u1_switch_update(struct usb_mixer_interface *mixer,\r\nunsigned char status)\r\n{\r\nstruct snd_usb_audio *chip = mixer->chip;\r\nint err;\r\nerr = snd_usb_lock_shutdown(chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_sndctrlpipe(chip->dev, 0), 0x08,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\n50, 0, &status, 1);\r\nsnd_usb_unlock_shutdown(chip);\r\nreturn err;\r\n}\r\nstatic int snd_xonar_u1_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\r\nu8 old_status, new_status;\r\nint err;\r\nold_status = kcontrol->private_value;\r\nif (ucontrol->value.integer.value[0])\r\nnew_status = old_status | 0x02;\r\nelse\r\nnew_status = old_status & ~0x02;\r\nif (new_status == old_status)\r\nreturn 0;\r\nkcontrol->private_value = new_status;\r\nerr = snd_xonar_u1_switch_update(list->mixer, new_status);\r\nreturn err < 0 ? err : 1;\r\n}\r\nstatic int snd_xonar_u1_switch_resume(struct usb_mixer_elem_list *list)\r\n{\r\nreturn snd_xonar_u1_switch_update(list->mixer,\r\nlist->kctl->private_value);\r\n}\r\nstatic int snd_xonar_u1_controls_create(struct usb_mixer_interface *mixer)\r\n{\r\nreturn add_single_ctl_with_resume(mixer, 0,\r\nsnd_xonar_u1_switch_resume,\r\n&snd_xonar_u1_output_switch, NULL);\r\n}\r\nstatic int snd_mbox1_switch_get(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.enumerated.item[0] = kctl->private_value;\r\nreturn 0;\r\n}\r\nstatic int snd_mbox1_switch_update(struct usb_mixer_interface *mixer, int val)\r\n{\r\nstruct snd_usb_audio *chip = mixer->chip;\r\nint err;\r\nunsigned char buff[3];\r\nerr = snd_usb_lock_shutdown(chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_rcvctrlpipe(chip->dev, 0), 0x81,\r\nUSB_DIR_IN |\r\nUSB_TYPE_CLASS |\r\nUSB_RECIP_INTERFACE, 0x00, 0x500, buff, 1);\r\nif (err < 0)\r\ngoto err;\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_rcvctrlpipe(chip->dev, 0), 0x81,\r\nUSB_DIR_IN |\r\nUSB_TYPE_CLASS |\r\nUSB_RECIP_ENDPOINT, 0x100, 0x81, buff, 3);\r\nif (err < 0)\r\ngoto err;\r\nif (val == 0) {\r\nbuff[0] = 0x80;\r\nbuff[1] = 0xbb;\r\nbuff[2] = 0x00;\r\n} else {\r\nbuff[0] = buff[1] = buff[2] = 0x00;\r\n}\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_sndctrlpipe(chip->dev, 0), 0x1,\r\nUSB_TYPE_CLASS |\r\nUSB_RECIP_ENDPOINT, 0x100, 0x81, buff, 3);\r\nif (err < 0)\r\ngoto err;\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_rcvctrlpipe(chip->dev, 0), 0x81,\r\nUSB_DIR_IN |\r\nUSB_TYPE_CLASS |\r\nUSB_RECIP_ENDPOINT, 0x100, 0x81, buff, 3);\r\nif (err < 0)\r\ngoto err;\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_rcvctrlpipe(chip->dev, 0), 0x81,\r\nUSB_DIR_IN |\r\nUSB_TYPE_CLASS |\r\nUSB_RECIP_ENDPOINT, 0x100, 0x2, buff, 3);\r\nif (err < 0)\r\ngoto err;\r\nerr:\r\nsnd_usb_unlock_shutdown(chip);\r\nreturn err;\r\n}\r\nstatic int snd_mbox1_switch_put(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kctl);\r\nstruct usb_mixer_interface *mixer = list->mixer;\r\nint err;\r\nbool cur_val, new_val;\r\ncur_val = kctl->private_value;\r\nnew_val = ucontrol->value.enumerated.item[0];\r\nif (cur_val == new_val)\r\nreturn 0;\r\nkctl->private_value = new_val;\r\nerr = snd_mbox1_switch_update(mixer, new_val);\r\nreturn err < 0 ? err : 1;\r\n}\r\nstatic int snd_mbox1_switch_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char *const texts[2] = {\r\n"Internal",\r\n"S/PDIF"\r\n};\r\nreturn snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(texts), texts);\r\n}\r\nstatic int snd_mbox1_switch_resume(struct usb_mixer_elem_list *list)\r\n{\r\nreturn snd_mbox1_switch_update(list->mixer, list->kctl->private_value);\r\n}\r\nstatic int snd_mbox1_create_sync_switch(struct usb_mixer_interface *mixer)\r\n{\r\nreturn add_single_ctl_with_resume(mixer, 0,\r\nsnd_mbox1_switch_resume,\r\n&snd_mbox1_switch, NULL);\r\n}\r\nstatic int snd_ni_control_init_val(struct usb_mixer_interface *mixer,\r\nstruct snd_kcontrol *kctl)\r\n{\r\nstruct usb_device *dev = mixer->chip->dev;\r\nunsigned int pval = kctl->private_value;\r\nu8 value;\r\nint err;\r\nerr = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0),\r\n(pval >> 16) & 0xff,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0, pval & 0xffff, &value, 1);\r\nif (err < 0) {\r\ndev_err(&dev->dev,\r\n"unable to issue vendor read request (ret = %d)", err);\r\nreturn err;\r\n}\r\nkctl->private_value |= (value << 24);\r\nreturn 0;\r\n}\r\nstatic int snd_nativeinstruments_control_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.integer.value[0] = kcontrol->private_value >> 24;\r\nreturn 0;\r\n}\r\nstatic int snd_ni_update_cur_val(struct usb_mixer_elem_list *list)\r\n{\r\nstruct snd_usb_audio *chip = list->mixer->chip;\r\nunsigned int pval = list->kctl->private_value;\r\nint err;\r\nerr = snd_usb_lock_shutdown(chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = usb_control_msg(chip->dev, usb_sndctrlpipe(chip->dev, 0),\r\n(pval >> 16) & 0xff,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\r\npval >> 24, pval & 0xffff, NULL, 0, 1000);\r\nsnd_usb_unlock_shutdown(chip);\r\nreturn err;\r\n}\r\nstatic int snd_nativeinstruments_control_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\r\nu8 oldval = (kcontrol->private_value >> 24) & 0xff;\r\nu8 newval = ucontrol->value.integer.value[0];\r\nint err;\r\nif (oldval == newval)\r\nreturn 0;\r\nkcontrol->private_value &= ~(0xff << 24);\r\nkcontrol->private_value |= (unsigned int)newval << 24;\r\nerr = snd_ni_update_cur_val(list);\r\nreturn err < 0 ? err : 1;\r\n}\r\nstatic int snd_nativeinstruments_create_mixer(struct usb_mixer_interface *mixer,\r\nconst struct snd_kcontrol_new *kc,\r\nunsigned int count)\r\n{\r\nint i, err = 0;\r\nstruct snd_kcontrol_new template = {\r\n.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\r\n.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\r\n.get = snd_nativeinstruments_control_get,\r\n.put = snd_nativeinstruments_control_put,\r\n.info = snd_ctl_boolean_mono_info,\r\n};\r\nfor (i = 0; i < count; i++) {\r\nstruct usb_mixer_elem_list *list;\r\ntemplate.name = kc[i].name;\r\ntemplate.private_value = kc[i].private_value;\r\nerr = add_single_ctl_with_resume(mixer, 0,\r\nsnd_ni_update_cur_val,\r\n&template, &list);\r\nif (err < 0)\r\nbreak;\r\nsnd_ni_control_init_val(mixer, list->kctl);\r\n}\r\nreturn err;\r\n}\r\nstatic int snd_ftu_eff_switch_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char *const texts[8] = {\r\n"Room 1", "Room 2", "Room 3", "Hall 1",\r\n"Hall 2", "Plate", "Delay", "Echo"\r\n};\r\nreturn snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(texts), texts);\r\n}\r\nstatic int snd_ftu_eff_switch_init(struct usb_mixer_interface *mixer,\r\nstruct snd_kcontrol *kctl)\r\n{\r\nstruct usb_device *dev = mixer->chip->dev;\r\nunsigned int pval = kctl->private_value;\r\nint err;\r\nunsigned char value[2];\r\nvalue[0] = 0x00;\r\nvalue[1] = 0x00;\r\nerr = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), UAC_GET_CUR,\r\nUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\r\npval & 0xff00,\r\nsnd_usb_ctrl_intf(mixer->chip) | ((pval & 0xff) << 8),\r\nvalue, 2);\r\nif (err < 0)\r\nreturn err;\r\nkctl->private_value |= value[0] << 24;\r\nreturn 0;\r\n}\r\nstatic int snd_ftu_eff_switch_get(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.enumerated.item[0] = kctl->private_value >> 24;\r\nreturn 0;\r\n}\r\nstatic int snd_ftu_eff_switch_update(struct usb_mixer_elem_list *list)\r\n{\r\nstruct snd_usb_audio *chip = list->mixer->chip;\r\nunsigned int pval = list->kctl->private_value;\r\nunsigned char value[2];\r\nint err;\r\nvalue[0] = pval >> 24;\r\nvalue[1] = 0;\r\nerr = snd_usb_lock_shutdown(chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_sndctrlpipe(chip->dev, 0),\r\nUAC_SET_CUR,\r\nUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,\r\npval & 0xff00,\r\nsnd_usb_ctrl_intf(chip) | ((pval & 0xff) << 8),\r\nvalue, 2);\r\nsnd_usb_unlock_shutdown(chip);\r\nreturn err;\r\n}\r\nstatic int snd_ftu_eff_switch_put(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kctl);\r\nunsigned int pval = list->kctl->private_value;\r\nint cur_val, err, new_val;\r\ncur_val = pval >> 24;\r\nnew_val = ucontrol->value.enumerated.item[0];\r\nif (cur_val == new_val)\r\nreturn 0;\r\nkctl->private_value &= ~(0xff << 24);\r\nkctl->private_value |= new_val << 24;\r\nerr = snd_ftu_eff_switch_update(list);\r\nreturn err < 0 ? err : 1;\r\n}\r\nstatic int snd_ftu_create_effect_switch(struct usb_mixer_interface *mixer,\r\nint validx, int bUnitID)\r\n{\r\nstatic struct snd_kcontrol_new template = {\r\n.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\r\n.name = "Effect Program Switch",\r\n.index = 0,\r\n.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\r\n.info = snd_ftu_eff_switch_info,\r\n.get = snd_ftu_eff_switch_get,\r\n.put = snd_ftu_eff_switch_put\r\n};\r\nstruct usb_mixer_elem_list *list;\r\nint err;\r\nerr = add_single_ctl_with_resume(mixer, bUnitID,\r\nsnd_ftu_eff_switch_update,\r\n&template, &list);\r\nif (err < 0)\r\nreturn err;\r\nlist->kctl->private_value = (validx << 8) | bUnitID;\r\nsnd_ftu_eff_switch_init(mixer, list->kctl);\r\nreturn 0;\r\n}\r\nstatic int snd_ftu_create_volume_ctls(struct usb_mixer_interface *mixer)\r\n{\r\nchar name[64];\r\nunsigned int control, cmask;\r\nint in, out, err;\r\nconst unsigned int id = 5;\r\nconst int val_type = USB_MIXER_S16;\r\nfor (out = 0; out < 8; out++) {\r\ncontrol = out + 1;\r\nfor (in = 0; in < 8; in++) {\r\ncmask = 1 << in;\r\nsnprintf(name, sizeof(name),\r\n"AIn%d - Out%d Capture Volume",\r\nin + 1, out + 1);\r\nerr = snd_create_std_mono_ctl(mixer, id, control,\r\ncmask, val_type, name,\r\n&snd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (in = 8; in < 16; in++) {\r\ncmask = 1 << in;\r\nsnprintf(name, sizeof(name),\r\n"DIn%d - Out%d Playback Volume",\r\nin - 7, out + 1);\r\nerr = snd_create_std_mono_ctl(mixer, id, control,\r\ncmask, val_type, name,\r\n&snd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ftu_create_effect_volume_ctl(struct usb_mixer_interface *mixer)\r\n{\r\nstatic const char name[] = "Effect Volume";\r\nconst unsigned int id = 6;\r\nconst int val_type = USB_MIXER_U8;\r\nconst unsigned int control = 2;\r\nconst unsigned int cmask = 0;\r\nreturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\r\nname, snd_usb_mixer_vol_tlv);\r\n}\r\nstatic int snd_ftu_create_effect_duration_ctl(struct usb_mixer_interface *mixer)\r\n{\r\nstatic const char name[] = "Effect Duration";\r\nconst unsigned int id = 6;\r\nconst int val_type = USB_MIXER_S16;\r\nconst unsigned int control = 3;\r\nconst unsigned int cmask = 0;\r\nreturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\r\nname, snd_usb_mixer_vol_tlv);\r\n}\r\nstatic int snd_ftu_create_effect_feedback_ctl(struct usb_mixer_interface *mixer)\r\n{\r\nstatic const char name[] = "Effect Feedback Volume";\r\nconst unsigned int id = 6;\r\nconst int val_type = USB_MIXER_U8;\r\nconst unsigned int control = 4;\r\nconst unsigned int cmask = 0;\r\nreturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\r\nname, NULL);\r\n}\r\nstatic int snd_ftu_create_effect_return_ctls(struct usb_mixer_interface *mixer)\r\n{\r\nunsigned int cmask;\r\nint err, ch;\r\nchar name[48];\r\nconst unsigned int id = 7;\r\nconst int val_type = USB_MIXER_S16;\r\nconst unsigned int control = 7;\r\nfor (ch = 0; ch < 4; ++ch) {\r\ncmask = 1 << ch;\r\nsnprintf(name, sizeof(name),\r\n"Effect Return %d Volume", ch + 1);\r\nerr = snd_create_std_mono_ctl(mixer, id, control,\r\ncmask, val_type, name,\r\nsnd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ftu_create_effect_send_ctls(struct usb_mixer_interface *mixer)\r\n{\r\nunsigned int cmask;\r\nint err, ch;\r\nchar name[48];\r\nconst unsigned int id = 5;\r\nconst int val_type = USB_MIXER_S16;\r\nconst unsigned int control = 9;\r\nfor (ch = 0; ch < 8; ++ch) {\r\ncmask = 1 << ch;\r\nsnprintf(name, sizeof(name),\r\n"Effect Send AIn%d Volume", ch + 1);\r\nerr = snd_create_std_mono_ctl(mixer, id, control, cmask,\r\nval_type, name,\r\nsnd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (ch = 8; ch < 16; ++ch) {\r\ncmask = 1 << ch;\r\nsnprintf(name, sizeof(name),\r\n"Effect Send DIn%d Volume", ch - 7);\r\nerr = snd_create_std_mono_ctl(mixer, id, control, cmask,\r\nval_type, name,\r\nsnd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ftu_create_mixer(struct usb_mixer_interface *mixer)\r\n{\r\nint err;\r\nerr = snd_ftu_create_volume_ctls(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ftu_create_effect_switch(mixer, 1, 6);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ftu_create_effect_volume_ctl(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ftu_create_effect_duration_ctl(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ftu_create_effect_feedback_ctl(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ftu_create_effect_return_ctls(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ftu_create_effect_send_ctls(mixer);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nvoid snd_emuusb_set_samplerate(struct snd_usb_audio *chip,\r\nunsigned char samplerate_id)\r\n{\r\nstruct usb_mixer_interface *mixer;\r\nstruct usb_mixer_elem_info *cval;\r\nint unitid = 12;\r\nlist_for_each_entry(mixer, &chip->mixer_list, list) {\r\ncval = (struct usb_mixer_elem_info *)mixer->id_elems[unitid];\r\nif (cval) {\r\nsnd_usb_mixer_set_ctl_value(cval, UAC_SET_CUR,\r\ncval->control << 8,\r\nsamplerate_id);\r\nsnd_usb_mixer_notify_id(mixer, unitid);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int snd_c400_create_vol_ctls(struct usb_mixer_interface *mixer)\r\n{\r\nchar name[64];\r\nunsigned int cmask, offset;\r\nint out, chan, err;\r\nint num_outs = 0;\r\nint num_ins = 0;\r\nconst unsigned int id = 0x40;\r\nconst int val_type = USB_MIXER_S16;\r\nconst int control = 1;\r\nswitch (mixer->chip->usb_id) {\r\ncase USB_ID(0x0763, 0x2030):\r\nnum_outs = 6;\r\nnum_ins = 4;\r\nbreak;\r\ncase USB_ID(0x0763, 0x2031):\r\nnum_outs = 8;\r\nnum_ins = 6;\r\nbreak;\r\n}\r\nfor (chan = 0; chan < num_outs + num_ins; chan++) {\r\nfor (out = 0; out < num_outs; out++) {\r\nif (chan < num_outs) {\r\nsnprintf(name, sizeof(name),\r\n"PCM%d-Out%d Playback Volume",\r\nchan + 1, out + 1);\r\n} else {\r\nsnprintf(name, sizeof(name),\r\n"In%d-Out%d Playback Volume",\r\nchan - num_outs + 1, out + 1);\r\n}\r\ncmask = (out == 0) ? 0 : 1 << (out - 1);\r\noffset = chan * num_outs;\r\nerr = snd_create_std_mono_ctl_offset(mixer, id, control,\r\ncmask, val_type, offset, name,\r\n&snd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_c400_create_effect_volume_ctl(struct usb_mixer_interface *mixer)\r\n{\r\nstatic const char name[] = "Effect Volume";\r\nconst unsigned int id = 0x43;\r\nconst int val_type = USB_MIXER_U8;\r\nconst unsigned int control = 3;\r\nconst unsigned int cmask = 0;\r\nreturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\r\nname, snd_usb_mixer_vol_tlv);\r\n}\r\nstatic int snd_c400_create_effect_duration_ctl(struct usb_mixer_interface *mixer)\r\n{\r\nstatic const char name[] = "Effect Duration";\r\nconst unsigned int id = 0x43;\r\nconst int val_type = USB_MIXER_S16;\r\nconst unsigned int control = 4;\r\nconst unsigned int cmask = 0;\r\nreturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\r\nname, snd_usb_mixer_vol_tlv);\r\n}\r\nstatic int snd_c400_create_effect_feedback_ctl(struct usb_mixer_interface *mixer)\r\n{\r\nstatic const char name[] = "Effect Feedback Volume";\r\nconst unsigned int id = 0x43;\r\nconst int val_type = USB_MIXER_U8;\r\nconst unsigned int control = 5;\r\nconst unsigned int cmask = 0;\r\nreturn snd_create_std_mono_ctl(mixer, id, control, cmask, val_type,\r\nname, NULL);\r\n}\r\nstatic int snd_c400_create_effect_vol_ctls(struct usb_mixer_interface *mixer)\r\n{\r\nchar name[64];\r\nunsigned int cmask;\r\nint chan, err;\r\nint num_outs = 0;\r\nint num_ins = 0;\r\nconst unsigned int id = 0x42;\r\nconst int val_type = USB_MIXER_S16;\r\nconst int control = 1;\r\nswitch (mixer->chip->usb_id) {\r\ncase USB_ID(0x0763, 0x2030):\r\nnum_outs = 6;\r\nnum_ins = 4;\r\nbreak;\r\ncase USB_ID(0x0763, 0x2031):\r\nnum_outs = 8;\r\nnum_ins = 6;\r\nbreak;\r\n}\r\nfor (chan = 0; chan < num_outs + num_ins; chan++) {\r\nif (chan < num_outs) {\r\nsnprintf(name, sizeof(name),\r\n"Effect Send DOut%d",\r\nchan + 1);\r\n} else {\r\nsnprintf(name, sizeof(name),\r\n"Effect Send AIn%d",\r\nchan - num_outs + 1);\r\n}\r\ncmask = (chan == 0) ? 0 : 1 << (chan - 1);\r\nerr = snd_create_std_mono_ctl(mixer, id, control,\r\ncmask, val_type, name,\r\n&snd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_c400_create_effect_ret_vol_ctls(struct usb_mixer_interface *mixer)\r\n{\r\nchar name[64];\r\nunsigned int cmask;\r\nint chan, err;\r\nint num_outs = 0;\r\nint offset = 0;\r\nconst unsigned int id = 0x40;\r\nconst int val_type = USB_MIXER_S16;\r\nconst int control = 1;\r\nswitch (mixer->chip->usb_id) {\r\ncase USB_ID(0x0763, 0x2030):\r\nnum_outs = 6;\r\noffset = 0x3c;\r\nbreak;\r\ncase USB_ID(0x0763, 0x2031):\r\nnum_outs = 8;\r\noffset = 0x70;\r\nbreak;\r\n}\r\nfor (chan = 0; chan < num_outs; chan++) {\r\nsnprintf(name, sizeof(name),\r\n"Effect Return %d",\r\nchan + 1);\r\ncmask = (chan == 0) ? 0 :\r\n1 << (chan + (chan % 2) * num_outs - 1);\r\nerr = snd_create_std_mono_ctl_offset(mixer, id, control,\r\ncmask, val_type, offset, name,\r\n&snd_usb_mixer_vol_tlv);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_c400_create_mixer(struct usb_mixer_interface *mixer)\r\n{\r\nint err;\r\nerr = snd_c400_create_vol_ctls(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_c400_create_effect_vol_ctls(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_c400_create_effect_ret_vol_ctls(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ftu_create_effect_switch(mixer, 2, 0x43);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_c400_create_effect_volume_ctl(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_c400_create_effect_duration_ctl(mixer);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_c400_create_effect_feedback_ctl(mixer);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_microii_spdif_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_microii_spdif_default_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\r\nstruct snd_usb_audio *chip = list->mixer->chip;\r\nint err;\r\nstruct usb_interface *iface;\r\nstruct usb_host_interface *alts;\r\nunsigned int ep;\r\nunsigned char data[3];\r\nint rate;\r\nerr = snd_usb_lock_shutdown(chip);\r\nif (err < 0)\r\nreturn err;\r\nucontrol->value.iec958.status[0] = kcontrol->private_value & 0xff;\r\nucontrol->value.iec958.status[1] = (kcontrol->private_value >> 8) & 0xff;\r\nucontrol->value.iec958.status[2] = 0x00;\r\niface = usb_ifnum_to_if(chip->dev, 1);\r\nif (!iface || iface->num_altsetting < 2)\r\nreturn -EINVAL;\r\nalts = &iface->altsetting[1];\r\nif (get_iface_desc(alts)->bNumEndpoints < 1)\r\nreturn -EINVAL;\r\nep = get_endpoint(alts, 0)->bEndpointAddress;\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_rcvctrlpipe(chip->dev, 0),\r\nUAC_GET_CUR,\r\nUSB_TYPE_CLASS | USB_RECIP_ENDPOINT | USB_DIR_IN,\r\nUAC_EP_CS_ATTR_SAMPLE_RATE << 8,\r\nep,\r\ndata,\r\nsizeof(data));\r\nif (err < 0)\r\ngoto end;\r\nrate = data[0] | (data[1] << 8) | (data[2] << 16);\r\nucontrol->value.iec958.status[3] = (rate == 48000) ?\r\nIEC958_AES3_CON_FS_48000 : IEC958_AES3_CON_FS_44100;\r\nerr = 0;\r\nend:\r\nsnd_usb_unlock_shutdown(chip);\r\nreturn err;\r\n}\r\nstatic int snd_microii_spdif_default_update(struct usb_mixer_elem_list *list)\r\n{\r\nstruct snd_usb_audio *chip = list->mixer->chip;\r\nunsigned int pval = list->kctl->private_value;\r\nu8 reg;\r\nint err;\r\nerr = snd_usb_lock_shutdown(chip);\r\nif (err < 0)\r\nreturn err;\r\nreg = ((pval >> 4) & 0xf0) | (pval & 0x0f);\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_sndctrlpipe(chip->dev, 0),\r\nUAC_SET_CUR,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\nreg,\r\n2,\r\nNULL,\r\n0);\r\nif (err < 0)\r\ngoto end;\r\nreg = (pval & IEC958_AES0_NONAUDIO) ? 0xa0 : 0x20;\r\nreg |= (pval >> 12) & 0x0f;\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_sndctrlpipe(chip->dev, 0),\r\nUAC_SET_CUR,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\nreg,\r\n3,\r\nNULL,\r\n0);\r\nif (err < 0)\r\ngoto end;\r\nend:\r\nsnd_usb_unlock_shutdown(chip);\r\nreturn err;\r\n}\r\nstatic int snd_microii_spdif_default_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\r\nunsigned int pval, pval_old;\r\nint err;\r\npval = pval_old = kcontrol->private_value;\r\npval &= 0xfffff0f0;\r\npval |= (ucontrol->value.iec958.status[1] & 0x0f) << 8;\r\npval |= (ucontrol->value.iec958.status[0] & 0x0f);\r\npval &= 0xffff0fff;\r\npval |= (ucontrol->value.iec958.status[1] & 0xf0) << 8;\r\nif (pval == pval_old)\r\nreturn 0;\r\nkcontrol->private_value = pval;\r\nerr = snd_microii_spdif_default_update(list);\r\nreturn err < 0 ? err : 1;\r\n}\r\nstatic int snd_microii_spdif_mask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = 0x0f;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[2] = 0x00;\r\nucontrol->value.iec958.status[3] = 0x00;\r\nreturn 0;\r\n}\r\nstatic int snd_microii_spdif_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.integer.value[0] = !(kcontrol->private_value & 0x02);\r\nreturn 0;\r\n}\r\nstatic int snd_microii_spdif_switch_update(struct usb_mixer_elem_list *list)\r\n{\r\nstruct snd_usb_audio *chip = list->mixer->chip;\r\nu8 reg = list->kctl->private_value;\r\nint err;\r\nerr = snd_usb_lock_shutdown(chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_sndctrlpipe(chip->dev, 0),\r\nUAC_SET_CUR,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\nreg,\r\n9,\r\nNULL,\r\n0);\r\nsnd_usb_unlock_shutdown(chip);\r\nreturn err;\r\n}\r\nstatic int snd_microii_spdif_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_list *list = snd_kcontrol_chip(kcontrol);\r\nu8 reg;\r\nint err;\r\nreg = ucontrol->value.integer.value[0] ? 0x28 : 0x2a;\r\nif (reg != list->kctl->private_value)\r\nreturn 0;\r\nkcontrol->private_value = reg;\r\nerr = snd_microii_spdif_switch_update(list);\r\nreturn err < 0 ? err : 1;\r\n}\r\nstatic int snd_microii_controls_create(struct usb_mixer_interface *mixer)\r\n{\r\nint err, i;\r\nstatic usb_mixer_elem_resume_func_t resume_funcs[] = {\r\nsnd_microii_spdif_default_update,\r\nNULL,\r\nsnd_microii_spdif_switch_update\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(snd_microii_mixer_spdif); ++i) {\r\nerr = add_single_ctl_with_resume(mixer, 0,\r\nresume_funcs[i],\r\n&snd_microii_mixer_spdif[i],\r\nNULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint snd_usb_mixer_apply_create_quirk(struct usb_mixer_interface *mixer)\r\n{\r\nint err = 0;\r\nstruct snd_info_entry *entry;\r\nif ((err = snd_usb_soundblaster_remote_init(mixer)) < 0)\r\nreturn err;\r\nswitch (mixer->chip->usb_id) {\r\ncase USB_ID(0x0644, 0x8047):\r\nerr = snd_us16x08_controls_create(mixer);\r\nbreak;\r\ncase USB_ID(0x041e, 0x3020):\r\ncase USB_ID(0x041e, 0x3040):\r\ncase USB_ID(0x041e, 0x3042):\r\ncase USB_ID(0x041e, 0x30df):\r\ncase USB_ID(0x041e, 0x3048):\r\nerr = snd_audigy2nx_controls_create(mixer);\r\nif (err < 0)\r\nbreak;\r\nif (!snd_card_proc_new(mixer->chip->card, "audigy2nx", &entry))\r\nsnd_info_set_text_ops(entry, mixer,\r\nsnd_audigy2nx_proc_read);\r\nbreak;\r\ncase USB_ID(0x041e, 0x3f19):\r\nerr = snd_emu0204_controls_create(mixer);\r\nif (err < 0)\r\nbreak;\r\nbreak;\r\ncase USB_ID(0x0763, 0x2030):\r\ncase USB_ID(0x0763, 0x2031):\r\nerr = snd_c400_create_mixer(mixer);\r\nbreak;\r\ncase USB_ID(0x0763, 0x2080):\r\ncase USB_ID(0x0763, 0x2081):\r\nerr = snd_ftu_create_mixer(mixer);\r\nbreak;\r\ncase USB_ID(0x0b05, 0x1739):\r\ncase USB_ID(0x0b05, 0x1743):\r\ncase USB_ID(0x0b05, 0x17a0):\r\nerr = snd_xonar_u1_controls_create(mixer);\r\nbreak;\r\ncase USB_ID(0x0d8c, 0x0103):\r\nerr = snd_microii_controls_create(mixer);\r\nbreak;\r\ncase USB_ID(0x0dba, 0x1000):\r\nerr = snd_mbox1_create_sync_switch(mixer);\r\nbreak;\r\ncase USB_ID(0x17cc, 0x1011):\r\nerr = snd_nativeinstruments_create_mixer(mixer,\r\nsnd_nativeinstruments_ta6_mixers,\r\nARRAY_SIZE(snd_nativeinstruments_ta6_mixers));\r\nbreak;\r\ncase USB_ID(0x17cc, 0x1021):\r\nerr = snd_nativeinstruments_create_mixer(mixer,\r\nsnd_nativeinstruments_ta10_mixers,\r\nARRAY_SIZE(snd_nativeinstruments_ta10_mixers));\r\nbreak;\r\ncase USB_ID(0x200c, 0x1018):\r\nerr = snd_create_std_mono_table(mixer, ebox44_table);\r\nbreak;\r\ncase USB_ID(0x1235, 0x8012):\r\ncase USB_ID(0x1235, 0x8002):\r\ncase USB_ID(0x1235, 0x8004):\r\ncase USB_ID(0x1235, 0x8014):\r\ncase USB_ID(0x1235, 0x800c):\r\nerr = snd_scarlett_controls_create(mixer);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nvoid snd_usb_mixer_rc_memory_change(struct usb_mixer_interface *mixer,\r\nint unitid)\r\n{\r\nif (!mixer->rc_cfg)\r\nreturn;\r\nswitch (unitid) {\r\ncase 0:\r\nmixer->rc_urb->dev = mixer->chip->dev;\r\nusb_submit_urb(mixer->rc_urb, GFP_ATOMIC);\r\nbreak;\r\ncase 4:\r\ncase 7:\r\ncase 19:\r\ncase 20:\r\nbreak;\r\ncase 3:\r\nif (mixer->chip->usb_id == USB_ID(0x041e, 0x3040) ||\r\nmixer->chip->usb_id == USB_ID(0x041e, 0x3048))\r\nsnd_usb_mixer_notify_id(mixer, mixer->rc_cfg->mute_mixer_id);\r\nbreak;\r\ndefault:\r\nusb_audio_dbg(mixer->chip, "memory change in unknown unit %d\n", unitid);\r\nbreak;\r\n}\r\n}\r\nstatic void snd_dragonfly_quirk_db_scale(struct usb_mixer_interface *mixer,\r\nstruct usb_mixer_elem_info *cval,\r\nstruct snd_kcontrol *kctl)\r\n{\r\nstatic const DECLARE_TLV_DB_RANGE(scale,\r\n0, 1, TLV_DB_MINMAX_ITEM(-5300, -4970),\r\n2, 5, TLV_DB_MINMAX_ITEM(-4710, -4160),\r\n6, 7, TLV_DB_MINMAX_ITEM(-3884, -3710),\r\n8, 14, TLV_DB_MINMAX_ITEM(-3443, -2560),\r\n15, 16, TLV_DB_MINMAX_ITEM(-2475, -2324),\r\n17, 19, TLV_DB_MINMAX_ITEM(-2228, -2031),\r\n20, 26, TLV_DB_MINMAX_ITEM(-1910, -1393),\r\n27, 31, TLV_DB_MINMAX_ITEM(-1322, -1032),\r\n32, 40, TLV_DB_MINMAX_ITEM(-968, -490),\r\n41, 50, TLV_DB_MINMAX_ITEM(-441, 0),\r\n);\r\nif (cval->min == 0 && cval->max == 50) {\r\nusb_audio_info(mixer->chip, "applying DragonFly dB scale quirk (0-50 variant)\n");\r\nkctl->tlv.p = scale;\r\nkctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;\r\nkctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\r\n} else if (cval->min == 0 && cval->max <= 1000) {\r\nusb_audio_info(mixer->chip, "ignoring too narrow dB range on a DragonFly device");\r\nkctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\r\n}\r\n}\r\nvoid snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,\r\nstruct usb_mixer_elem_info *cval, int unitid,\r\nstruct snd_kcontrol *kctl)\r\n{\r\nswitch (mixer->chip->usb_id) {\r\ncase USB_ID(0x21b4, 0x0081):\r\nif (unitid == 7 && cval->control == UAC_FU_VOLUME)\r\nsnd_dragonfly_quirk_db_scale(mixer, cval, kctl);\r\nbreak;\r\ncase USB_ID(0x0d8c, 0x000c):\r\ncase USB_ID(0x0d8c, 0x0014):\r\nif (strstr(kctl->id.name, "Playback"))\r\ncval->min_mute = 1;\r\nbreak;\r\n}\r\n}
