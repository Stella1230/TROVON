static inline void spear_rtc_clear_interrupt(struct spear_rtc_config *config)\r\n{\r\nunsigned int val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&config->lock, flags);\r\nval = readl(config->ioaddr + STATUS_REG);\r\nval |= RTC_INT_MASK;\r\nwritel(val, config->ioaddr + STATUS_REG);\r\nspin_unlock_irqrestore(&config->lock, flags);\r\n}\r\nstatic inline void spear_rtc_enable_interrupt(struct spear_rtc_config *config)\r\n{\r\nunsigned int val;\r\nval = readl(config->ioaddr + CTRL_REG);\r\nif (!(val & INT_ENABLE)) {\r\nspear_rtc_clear_interrupt(config);\r\nval |= INT_ENABLE;\r\nwritel(val, config->ioaddr + CTRL_REG);\r\n}\r\n}\r\nstatic inline void spear_rtc_disable_interrupt(struct spear_rtc_config *config)\r\n{\r\nunsigned int val;\r\nval = readl(config->ioaddr + CTRL_REG);\r\nif (val & INT_ENABLE) {\r\nval &= ~INT_ENABLE;\r\nwritel(val, config->ioaddr + CTRL_REG);\r\n}\r\n}\r\nstatic inline int is_write_complete(struct spear_rtc_config *config)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&config->lock, flags);\r\nif ((readl(config->ioaddr + STATUS_REG)) & STATUS_FAIL)\r\nret = -EIO;\r\nspin_unlock_irqrestore(&config->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void rtc_wait_not_busy(struct spear_rtc_config *config)\r\n{\r\nint status, count = 0;\r\nunsigned long flags;\r\nfor (count = 0; count < 80; count++) {\r\nspin_lock_irqsave(&config->lock, flags);\r\nstatus = readl(config->ioaddr + STATUS_REG);\r\nspin_unlock_irqrestore(&config->lock, flags);\r\nif ((status & STATUS_BUSY) == 0)\r\nbreak;\r\nmsleep(1);\r\n}\r\n}\r\nstatic irqreturn_t spear_rtc_irq(int irq, void *dev_id)\r\n{\r\nstruct spear_rtc_config *config = dev_id;\r\nunsigned long flags, events = 0;\r\nunsigned int irq_data;\r\nspin_lock_irqsave(&config->lock, flags);\r\nirq_data = readl(config->ioaddr + STATUS_REG);\r\nspin_unlock_irqrestore(&config->lock, flags);\r\nif ((irq_data & RTC_INT_MASK)) {\r\nspear_rtc_clear_interrupt(config);\r\nevents = RTC_IRQF | RTC_AF;\r\nrtc_update_irq(config->rtc, 1, events);\r\nreturn IRQ_HANDLED;\r\n} else\r\nreturn IRQ_NONE;\r\n}\r\nstatic int tm2bcd(struct rtc_time *tm)\r\n{\r\nif (rtc_valid_tm(tm) != 0)\r\nreturn -EINVAL;\r\ntm->tm_sec = bin2bcd(tm->tm_sec);\r\ntm->tm_min = bin2bcd(tm->tm_min);\r\ntm->tm_hour = bin2bcd(tm->tm_hour);\r\ntm->tm_mday = bin2bcd(tm->tm_mday);\r\ntm->tm_mon = bin2bcd(tm->tm_mon + 1);\r\ntm->tm_year = bin2bcd(tm->tm_year);\r\nreturn 0;\r\n}\r\nstatic void bcd2tm(struct rtc_time *tm)\r\n{\r\ntm->tm_sec = bcd2bin(tm->tm_sec);\r\ntm->tm_min = bcd2bin(tm->tm_min);\r\ntm->tm_hour = bcd2bin(tm->tm_hour);\r\ntm->tm_mday = bcd2bin(tm->tm_mday);\r\ntm->tm_mon = bcd2bin(tm->tm_mon) - 1;\r\ntm->tm_year = bcd2bin(tm->tm_year);\r\n}\r\nstatic int spear_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct spear_rtc_config *config = dev_get_drvdata(dev);\r\nunsigned int time, date;\r\nrtc_wait_not_busy(config);\r\ntime = readl(config->ioaddr + TIME_REG);\r\ndate = readl(config->ioaddr + DATE_REG);\r\ntm->tm_sec = (time >> SECOND_SHIFT) & SECOND_MASK;\r\ntm->tm_min = (time >> MINUTE_SHIFT) & MIN_MASK;\r\ntm->tm_hour = (time >> HOUR_SHIFT) & HOUR_MASK;\r\ntm->tm_mday = (date >> MDAY_SHIFT) & DAY_MASK;\r\ntm->tm_mon = (date >> MONTH_SHIFT) & MONTH_MASK;\r\ntm->tm_year = (date >> YEAR_SHIFT) & YEAR_MASK;\r\nbcd2tm(tm);\r\nreturn 0;\r\n}\r\nstatic int spear_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct spear_rtc_config *config = dev_get_drvdata(dev);\r\nunsigned int time, date;\r\nif (tm2bcd(tm) < 0)\r\nreturn -EINVAL;\r\nrtc_wait_not_busy(config);\r\ntime = (tm->tm_sec << SECOND_SHIFT) | (tm->tm_min << MINUTE_SHIFT) |\r\n(tm->tm_hour << HOUR_SHIFT);\r\ndate = (tm->tm_mday << MDAY_SHIFT) | (tm->tm_mon << MONTH_SHIFT) |\r\n(tm->tm_year << YEAR_SHIFT);\r\nwritel(time, config->ioaddr + TIME_REG);\r\nwritel(date, config->ioaddr + DATE_REG);\r\nreturn is_write_complete(config);\r\n}\r\nstatic int spear_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\r\n{\r\nstruct spear_rtc_config *config = dev_get_drvdata(dev);\r\nunsigned int time, date;\r\nrtc_wait_not_busy(config);\r\ntime = readl(config->ioaddr + ALARM_TIME_REG);\r\ndate = readl(config->ioaddr + ALARM_DATE_REG);\r\nalm->time.tm_sec = (time >> SECOND_SHIFT) & SECOND_MASK;\r\nalm->time.tm_min = (time >> MINUTE_SHIFT) & MIN_MASK;\r\nalm->time.tm_hour = (time >> HOUR_SHIFT) & HOUR_MASK;\r\nalm->time.tm_mday = (date >> MDAY_SHIFT) & DAY_MASK;\r\nalm->time.tm_mon = (date >> MONTH_SHIFT) & MONTH_MASK;\r\nalm->time.tm_year = (date >> YEAR_SHIFT) & YEAR_MASK;\r\nbcd2tm(&alm->time);\r\nalm->enabled = readl(config->ioaddr + CTRL_REG) & INT_ENABLE;\r\nreturn 0;\r\n}\r\nstatic int spear_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\r\n{\r\nstruct spear_rtc_config *config = dev_get_drvdata(dev);\r\nunsigned int time, date;\r\nint err;\r\nif (tm2bcd(&alm->time) < 0)\r\nreturn -EINVAL;\r\nrtc_wait_not_busy(config);\r\ntime = (alm->time.tm_sec << SECOND_SHIFT) | (alm->time.tm_min <<\r\nMINUTE_SHIFT) | (alm->time.tm_hour << HOUR_SHIFT);\r\ndate = (alm->time.tm_mday << MDAY_SHIFT) | (alm->time.tm_mon <<\r\nMONTH_SHIFT) | (alm->time.tm_year << YEAR_SHIFT);\r\nwritel(time, config->ioaddr + ALARM_TIME_REG);\r\nwritel(date, config->ioaddr + ALARM_DATE_REG);\r\nerr = is_write_complete(config);\r\nif (err < 0)\r\nreturn err;\r\nif (alm->enabled)\r\nspear_rtc_enable_interrupt(config);\r\nelse\r\nspear_rtc_disable_interrupt(config);\r\nreturn 0;\r\n}\r\nstatic int spear_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct spear_rtc_config *config = dev_get_drvdata(dev);\r\nint ret = 0;\r\nspear_rtc_clear_interrupt(config);\r\nswitch (enabled) {\r\ncase 0:\r\nspear_rtc_disable_interrupt(config);\r\nbreak;\r\ncase 1:\r\nspear_rtc_enable_interrupt(config);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int spear_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct spear_rtc_config *config;\r\nint status = 0;\r\nint irq;\r\nconfig = devm_kzalloc(&pdev->dev, sizeof(*config), GFP_KERNEL);\r\nif (!config)\r\nreturn -ENOMEM;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no update irq?\n");\r\nreturn irq;\r\n}\r\nstatus = devm_request_irq(&pdev->dev, irq, spear_rtc_irq, 0, pdev->name,\r\nconfig);\r\nif (status) {\r\ndev_err(&pdev->dev, "Alarm interrupt IRQ%d already claimed\n",\r\nirq);\r\nreturn status;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nconfig->ioaddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(config->ioaddr))\r\nreturn PTR_ERR(config->ioaddr);\r\nconfig->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(config->clk))\r\nreturn PTR_ERR(config->clk);\r\nstatus = clk_prepare_enable(config->clk);\r\nif (status < 0)\r\nreturn status;\r\nspin_lock_init(&config->lock);\r\nplatform_set_drvdata(pdev, config);\r\nconfig->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&spear_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(config->rtc)) {\r\ndev_err(&pdev->dev, "can't register RTC device, err %ld\n",\r\nPTR_ERR(config->rtc));\r\nstatus = PTR_ERR(config->rtc);\r\ngoto err_disable_clock;\r\n}\r\nconfig->rtc->uie_unsupported = 1;\r\nif (!device_can_wakeup(&pdev->dev))\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nreturn 0;\r\nerr_disable_clock:\r\nclk_disable_unprepare(config->clk);\r\nreturn status;\r\n}\r\nstatic int spear_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct spear_rtc_config *config = platform_get_drvdata(pdev);\r\nspear_rtc_disable_interrupt(config);\r\nclk_disable_unprepare(config->clk);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nreturn 0;\r\n}\r\nstatic int spear_rtc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct spear_rtc_config *config = platform_get_drvdata(pdev);\r\nint irq;\r\nirq = platform_get_irq(pdev, 0);\r\nif (device_may_wakeup(&pdev->dev)) {\r\nif (!enable_irq_wake(irq))\r\nconfig->irq_wake = 1;\r\n} else {\r\nspear_rtc_disable_interrupt(config);\r\nclk_disable(config->clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int spear_rtc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct spear_rtc_config *config = platform_get_drvdata(pdev);\r\nint irq;\r\nirq = platform_get_irq(pdev, 0);\r\nif (device_may_wakeup(&pdev->dev)) {\r\nif (config->irq_wake) {\r\ndisable_irq_wake(irq);\r\nconfig->irq_wake = 0;\r\n}\r\n} else {\r\nclk_enable(config->clk);\r\nspear_rtc_enable_interrupt(config);\r\n}\r\nreturn 0;\r\n}\r\nstatic void spear_rtc_shutdown(struct platform_device *pdev)\r\n{\r\nstruct spear_rtc_config *config = platform_get_drvdata(pdev);\r\nspear_rtc_disable_interrupt(config);\r\nclk_disable(config->clk);\r\n}
