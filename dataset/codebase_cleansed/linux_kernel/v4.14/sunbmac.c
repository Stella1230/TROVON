static int qec_global_reset(void __iomem *gregs)\r\n{\r\nint tries = QEC_RESET_TRIES;\r\nsbus_writel(GLOB_CTRL_RESET, gregs + GLOB_CTRL);\r\nwhile (--tries) {\r\nif (sbus_readl(gregs + GLOB_CTRL) & GLOB_CTRL_RESET) {\r\nudelay(20);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (tries)\r\nreturn 0;\r\nprintk(KERN_ERR "BigMAC: Cannot reset the QEC.\n");\r\nreturn -1;\r\n}\r\nstatic void qec_init(struct bigmac *bp)\r\n{\r\nstruct platform_device *qec_op = bp->qec_op;\r\nvoid __iomem *gregs = bp->gregs;\r\nu8 bsizes = bp->bigmac_bursts;\r\nu32 regval;\r\nif (bsizes & DMA_BURST32)\r\nregval = GLOB_CTRL_B32;\r\nelse\r\nregval = GLOB_CTRL_B16;\r\nsbus_writel(regval | GLOB_CTRL_BMODE, gregs + GLOB_CTRL);\r\nsbus_writel(GLOB_PSIZE_2048, gregs + GLOB_PSIZE);\r\nsbus_writel(resource_size(&qec_op->resource[1]),\r\ngregs + GLOB_MSIZE);\r\nsbus_writel(resource_size(&qec_op->resource[1]) >> 1,\r\ngregs + GLOB_TSIZE);\r\nsbus_writel(resource_size(&qec_op->resource[1]) >> 1,\r\ngregs + GLOB_RSIZE);\r\n}\r\nstatic void bigmac_tx_reset(void __iomem *bregs)\r\n{\r\nint tries = TX_RESET_TRIES;\r\nsbus_writel(0, bregs + BMAC_TXCFG);\r\nwhile ((sbus_readl(bregs + BMAC_TXCFG) & ~(BIGMAC_TXCFG_FIFO)) != 0 &&\r\n--tries != 0)\r\nudelay(20);\r\nif (!tries) {\r\nprintk(KERN_ERR "BIGMAC: Transmitter will not reset.\n");\r\nprintk(KERN_ERR "BIGMAC: tx_cfg is %08x\n",\r\nsbus_readl(bregs + BMAC_TXCFG));\r\n}\r\n}\r\nstatic void bigmac_rx_reset(void __iomem *bregs)\r\n{\r\nint tries = RX_RESET_TRIES;\r\nsbus_writel(0, bregs + BMAC_RXCFG);\r\nwhile (sbus_readl(bregs + BMAC_RXCFG) && --tries)\r\nudelay(20);\r\nif (!tries) {\r\nprintk(KERN_ERR "BIGMAC: Receiver will not reset.\n");\r\nprintk(KERN_ERR "BIGMAC: rx_cfg is %08x\n",\r\nsbus_readl(bregs + BMAC_RXCFG));\r\n}\r\n}\r\nstatic void bigmac_stop(struct bigmac *bp)\r\n{\r\nbigmac_tx_reset(bp->bregs);\r\nbigmac_rx_reset(bp->bregs);\r\n}\r\nstatic void bigmac_get_counters(struct bigmac *bp, void __iomem *bregs)\r\n{\r\nstruct net_device_stats *stats = &bp->dev->stats;\r\nstats->rx_crc_errors += sbus_readl(bregs + BMAC_RCRCECTR);\r\nsbus_writel(0, bregs + BMAC_RCRCECTR);\r\nstats->rx_frame_errors += sbus_readl(bregs + BMAC_UNALECTR);\r\nsbus_writel(0, bregs + BMAC_UNALECTR);\r\nstats->rx_length_errors += sbus_readl(bregs + BMAC_GLECTR);\r\nsbus_writel(0, bregs + BMAC_GLECTR);\r\nstats->tx_aborted_errors += sbus_readl(bregs + BMAC_EXCTR);\r\nstats->collisions +=\r\n(sbus_readl(bregs + BMAC_EXCTR) +\r\nsbus_readl(bregs + BMAC_LTCTR));\r\nsbus_writel(0, bregs + BMAC_EXCTR);\r\nsbus_writel(0, bregs + BMAC_LTCTR);\r\n}\r\nstatic void bigmac_clean_rings(struct bigmac *bp)\r\n{\r\nint i;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nif (bp->rx_skbs[i] != NULL) {\r\ndev_kfree_skb_any(bp->rx_skbs[i]);\r\nbp->rx_skbs[i] = NULL;\r\n}\r\n}\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nif (bp->tx_skbs[i] != NULL) {\r\ndev_kfree_skb_any(bp->tx_skbs[i]);\r\nbp->tx_skbs[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic void bigmac_init_rings(struct bigmac *bp, int from_irq)\r\n{\r\nstruct bmac_init_block *bb = bp->bmac_block;\r\nint i;\r\ngfp_t gfp_flags = GFP_KERNEL;\r\nif (from_irq || in_interrupt())\r\ngfp_flags = GFP_ATOMIC;\r\nbp->rx_new = bp->rx_old = bp->tx_new = bp->tx_old = 0;\r\nbigmac_clean_rings(bp);\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nstruct sk_buff *skb;\r\nskb = big_mac_alloc_skb(RX_BUF_ALLOC_SIZE, gfp_flags);\r\nif (!skb)\r\ncontinue;\r\nbp->rx_skbs[i] = skb;\r\nskb_put(skb, ETH_FRAME_LEN);\r\nskb_reserve(skb, 34);\r\nbb->be_rxd[i].rx_addr =\r\ndma_map_single(&bp->bigmac_op->dev,\r\nskb->data,\r\nRX_BUF_ALLOC_SIZE - 34,\r\nDMA_FROM_DEVICE);\r\nbb->be_rxd[i].rx_flags =\r\n(RXD_OWN | ((RX_BUF_ALLOC_SIZE - 34) & RXD_LENGTH));\r\n}\r\nfor (i = 0; i < TX_RING_SIZE; i++)\r\nbb->be_txd[i].tx_flags = bb->be_txd[i].tx_addr = 0;\r\n}\r\nstatic void idle_transceiver(void __iomem *tregs)\r\n{\r\nint i = 20;\r\nwhile (i--) {\r\nsbus_writel(MGMT_CLKOFF, tregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\nsbus_writel(MGMT_CLKON, tregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\n}\r\n}\r\nstatic void write_tcvr_bit(struct bigmac *bp, void __iomem *tregs, int bit)\r\n{\r\nif (bp->tcvr_type == internal) {\r\nbit = (bit & 1) << 3;\r\nsbus_writel(bit | (MGMT_PAL_OENAB | MGMT_PAL_EXT_MDIO),\r\ntregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\nsbus_writel(bit | MGMT_PAL_OENAB | MGMT_PAL_EXT_MDIO | MGMT_PAL_DCLOCK,\r\ntregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\n} else if (bp->tcvr_type == external) {\r\nbit = (bit & 1) << 2;\r\nsbus_writel(bit | MGMT_PAL_INT_MDIO | MGMT_PAL_OENAB,\r\ntregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\nsbus_writel(bit | MGMT_PAL_INT_MDIO | MGMT_PAL_OENAB | MGMT_PAL_DCLOCK,\r\ntregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\n} else {\r\nprintk(KERN_ERR "write_tcvr_bit: No transceiver type known!\n");\r\n}\r\n}\r\nstatic int read_tcvr_bit(struct bigmac *bp, void __iomem *tregs)\r\n{\r\nint retval = 0;\r\nif (bp->tcvr_type == internal) {\r\nsbus_writel(MGMT_PAL_EXT_MDIO, tregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\nsbus_writel(MGMT_PAL_EXT_MDIO | MGMT_PAL_DCLOCK,\r\ntregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\nretval = (sbus_readl(tregs + TCVR_MPAL) & MGMT_PAL_INT_MDIO) >> 3;\r\n} else if (bp->tcvr_type == external) {\r\nsbus_writel(MGMT_PAL_INT_MDIO, tregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\nsbus_writel(MGMT_PAL_INT_MDIO | MGMT_PAL_DCLOCK, tregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\nretval = (sbus_readl(tregs + TCVR_MPAL) & MGMT_PAL_EXT_MDIO) >> 2;\r\n} else {\r\nprintk(KERN_ERR "read_tcvr_bit: No transceiver type known!\n");\r\n}\r\nreturn retval;\r\n}\r\nstatic int read_tcvr_bit2(struct bigmac *bp, void __iomem *tregs)\r\n{\r\nint retval = 0;\r\nif (bp->tcvr_type == internal) {\r\nsbus_writel(MGMT_PAL_EXT_MDIO, tregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\nretval = (sbus_readl(tregs + TCVR_MPAL) & MGMT_PAL_INT_MDIO) >> 3;\r\nsbus_writel(MGMT_PAL_EXT_MDIO | MGMT_PAL_DCLOCK, tregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\n} else if (bp->tcvr_type == external) {\r\nsbus_writel(MGMT_PAL_INT_MDIO, tregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\nretval = (sbus_readl(tregs + TCVR_MPAL) & MGMT_PAL_EXT_MDIO) >> 2;\r\nsbus_writel(MGMT_PAL_INT_MDIO | MGMT_PAL_DCLOCK, tregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\n} else {\r\nprintk(KERN_ERR "read_tcvr_bit2: No transceiver type known!\n");\r\n}\r\nreturn retval;\r\n}\r\nstatic void put_tcvr_byte(struct bigmac *bp,\r\nvoid __iomem *tregs,\r\nunsigned int byte)\r\n{\r\nint shift = 4;\r\ndo {\r\nwrite_tcvr_bit(bp, tregs, ((byte >> shift) & 1));\r\nshift -= 1;\r\n} while (shift >= 0);\r\n}\r\nstatic void bigmac_tcvr_write(struct bigmac *bp, void __iomem *tregs,\r\nint reg, unsigned short val)\r\n{\r\nint shift;\r\nreg &= 0xff;\r\nval &= 0xffff;\r\nswitch(bp->tcvr_type) {\r\ncase internal:\r\ncase external:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "bigmac_tcvr_read: Whoops, no known transceiver type.\n");\r\nreturn;\r\n}\r\nidle_transceiver(tregs);\r\nwrite_tcvr_bit(bp, tregs, 0);\r\nwrite_tcvr_bit(bp, tregs, 1);\r\nwrite_tcvr_bit(bp, tregs, 0);\r\nwrite_tcvr_bit(bp, tregs, 1);\r\nput_tcvr_byte(bp, tregs,\r\n((bp->tcvr_type == internal) ?\r\nBIGMAC_PHY_INTERNAL : BIGMAC_PHY_EXTERNAL));\r\nput_tcvr_byte(bp, tregs, reg);\r\nwrite_tcvr_bit(bp, tregs, 1);\r\nwrite_tcvr_bit(bp, tregs, 0);\r\nshift = 15;\r\ndo {\r\nwrite_tcvr_bit(bp, tregs, (val >> shift) & 1);\r\nshift -= 1;\r\n} while (shift >= 0);\r\n}\r\nstatic unsigned short bigmac_tcvr_read(struct bigmac *bp,\r\nvoid __iomem *tregs,\r\nint reg)\r\n{\r\nunsigned short retval = 0;\r\nreg &= 0xff;\r\nswitch(bp->tcvr_type) {\r\ncase internal:\r\ncase external:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "bigmac_tcvr_read: Whoops, no known transceiver type.\n");\r\nreturn 0xffff;\r\n}\r\nidle_transceiver(tregs);\r\nwrite_tcvr_bit(bp, tregs, 0);\r\nwrite_tcvr_bit(bp, tregs, 1);\r\nwrite_tcvr_bit(bp, tregs, 1);\r\nwrite_tcvr_bit(bp, tregs, 0);\r\nput_tcvr_byte(bp, tregs,\r\n((bp->tcvr_type == internal) ?\r\nBIGMAC_PHY_INTERNAL : BIGMAC_PHY_EXTERNAL));\r\nput_tcvr_byte(bp, tregs, reg);\r\nif (bp->tcvr_type == external) {\r\nint shift = 15;\r\n(void) read_tcvr_bit2(bp, tregs);\r\n(void) read_tcvr_bit2(bp, tregs);\r\ndo {\r\nint tmp;\r\ntmp = read_tcvr_bit2(bp, tregs);\r\nretval |= ((tmp & 1) << shift);\r\nshift -= 1;\r\n} while (shift >= 0);\r\n(void) read_tcvr_bit2(bp, tregs);\r\n(void) read_tcvr_bit2(bp, tregs);\r\n(void) read_tcvr_bit2(bp, tregs);\r\n} else {\r\nint shift = 15;\r\n(void) read_tcvr_bit(bp, tregs);\r\n(void) read_tcvr_bit(bp, tregs);\r\ndo {\r\nint tmp;\r\ntmp = read_tcvr_bit(bp, tregs);\r\nretval |= ((tmp & 1) << shift);\r\nshift -= 1;\r\n} while (shift >= 0);\r\n(void) read_tcvr_bit(bp, tregs);\r\n(void) read_tcvr_bit(bp, tregs);\r\n(void) read_tcvr_bit(bp, tregs);\r\n}\r\nreturn retval;\r\n}\r\nstatic void bigmac_tcvr_init(struct bigmac *bp)\r\n{\r\nvoid __iomem *tregs = bp->tregs;\r\nu32 mpal;\r\nidle_transceiver(tregs);\r\nsbus_writel(MGMT_PAL_INT_MDIO | MGMT_PAL_EXT_MDIO | MGMT_PAL_DCLOCK,\r\ntregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\nsbus_writel(MGMT_PAL_INT_MDIO | MGMT_PAL_EXT_MDIO, tregs + TCVR_MPAL);\r\nsbus_readl(tregs + TCVR_MPAL);\r\nudelay(20);\r\nmpal = sbus_readl(tregs + TCVR_MPAL);\r\nif (mpal & MGMT_PAL_EXT_MDIO) {\r\nbp->tcvr_type = external;\r\nsbus_writel(~(TCVR_PAL_EXTLBACK | TCVR_PAL_MSENSE | TCVR_PAL_LTENABLE),\r\ntregs + TCVR_TPAL);\r\nsbus_readl(tregs + TCVR_TPAL);\r\n} else if (mpal & MGMT_PAL_INT_MDIO) {\r\nbp->tcvr_type = internal;\r\nsbus_writel(~(TCVR_PAL_SERIAL | TCVR_PAL_EXTLBACK |\r\nTCVR_PAL_MSENSE | TCVR_PAL_LTENABLE),\r\ntregs + TCVR_TPAL);\r\nsbus_readl(tregs + TCVR_TPAL);\r\n} else {\r\nprintk(KERN_ERR "BIGMAC: AIEEE, neither internal nor "\r\n"external MDIO available!\n");\r\nprintk(KERN_ERR "BIGMAC: mgmt_pal[%08x] tcvr_pal[%08x]\n",\r\nsbus_readl(tregs + TCVR_MPAL),\r\nsbus_readl(tregs + TCVR_TPAL));\r\n}\r\n}\r\nstatic int try_next_permutation(struct bigmac *bp, void __iomem *tregs)\r\n{\r\nif (bp->sw_bmcr & BMCR_SPEED100) {\r\nint timeout;\r\nbp->sw_bmcr = (BMCR_ISOLATE | BMCR_PDOWN | BMCR_LOOPBACK);\r\nbigmac_tcvr_write(bp, tregs, MII_BMCR, bp->sw_bmcr);\r\nbp->sw_bmcr = (BMCR_RESET);\r\nbigmac_tcvr_write(bp, tregs, MII_BMCR, bp->sw_bmcr);\r\ntimeout = 64;\r\nwhile (--timeout) {\r\nbp->sw_bmcr = bigmac_tcvr_read(bp, tregs, MII_BMCR);\r\nif ((bp->sw_bmcr & BMCR_RESET) == 0)\r\nbreak;\r\nudelay(20);\r\n}\r\nif (timeout == 0)\r\nprintk(KERN_ERR "%s: PHY reset failed.\n", bp->dev->name);\r\nbp->sw_bmcr = bigmac_tcvr_read(bp, tregs, MII_BMCR);\r\nbp->sw_bmcr &= ~(BMCR_SPEED100);\r\nbigmac_tcvr_write(bp, tregs, MII_BMCR, bp->sw_bmcr);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic void bigmac_timer(unsigned long data)\r\n{\r\nstruct bigmac *bp = (struct bigmac *) data;\r\nvoid __iomem *tregs = bp->tregs;\r\nint restart_timer = 0;\r\nbp->timer_ticks++;\r\nif (bp->timer_state == ltrywait) {\r\nbp->sw_bmsr = bigmac_tcvr_read(bp, tregs, MII_BMSR);\r\nbp->sw_bmcr = bigmac_tcvr_read(bp, tregs, MII_BMCR);\r\nif (bp->sw_bmsr & BMSR_LSTATUS) {\r\nprintk(KERN_INFO "%s: Link is now up at %s.\n",\r\nbp->dev->name,\r\n(bp->sw_bmcr & BMCR_SPEED100) ?\r\n"100baseT" : "10baseT");\r\nbp->timer_state = asleep;\r\nrestart_timer = 0;\r\n} else {\r\nif (bp->timer_ticks >= 4) {\r\nint ret;\r\nret = try_next_permutation(bp, tregs);\r\nif (ret == -1) {\r\nprintk(KERN_ERR "%s: Link down, cable problem?\n",\r\nbp->dev->name);\r\nret = bigmac_init_hw(bp, 0);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: Error, cannot re-init the "\r\n"BigMAC.\n", bp->dev->name);\r\n}\r\nreturn;\r\n}\r\nbp->timer_ticks = 0;\r\nrestart_timer = 1;\r\n} else {\r\nrestart_timer = 1;\r\n}\r\n}\r\n} else {\r\nprintk(KERN_ERR "%s: Aieee, link timer is asleep but we got one anyways!\n",\r\nbp->dev->name);\r\nrestart_timer = 0;\r\nbp->timer_ticks = 0;\r\nbp->timer_state = asleep;\r\n}\r\nif (restart_timer != 0) {\r\nbp->bigmac_timer.expires = jiffies + ((12 * HZ)/10);\r\nadd_timer(&bp->bigmac_timer);\r\n}\r\n}\r\nstatic void bigmac_begin_auto_negotiation(struct bigmac *bp)\r\n{\r\nvoid __iomem *tregs = bp->tregs;\r\nint timeout;\r\nbp->sw_bmsr = bigmac_tcvr_read(bp, tregs, MII_BMSR);\r\nbp->sw_bmcr = bigmac_tcvr_read(bp, tregs, MII_BMCR);\r\nbp->sw_bmcr = (BMCR_ISOLATE | BMCR_PDOWN | BMCR_LOOPBACK);\r\nbigmac_tcvr_write(bp, tregs, MII_BMCR, bp->sw_bmcr);\r\nbp->sw_bmcr = (BMCR_RESET);\r\nbigmac_tcvr_write(bp, tregs, MII_BMCR, bp->sw_bmcr);\r\ntimeout = 64;\r\nwhile (--timeout) {\r\nbp->sw_bmcr = bigmac_tcvr_read(bp, tregs, MII_BMCR);\r\nif ((bp->sw_bmcr & BMCR_RESET) == 0)\r\nbreak;\r\nudelay(20);\r\n}\r\nif (timeout == 0)\r\nprintk(KERN_ERR "%s: PHY reset failed.\n", bp->dev->name);\r\nbp->sw_bmcr = bigmac_tcvr_read(bp, tregs, MII_BMCR);\r\nbp->sw_bmcr |= BMCR_SPEED100;\r\nbigmac_tcvr_write(bp, tregs, MII_BMCR, bp->sw_bmcr);\r\nbp->timer_state = ltrywait;\r\nbp->timer_ticks = 0;\r\nbp->bigmac_timer.expires = jiffies + (12 * HZ) / 10;\r\nbp->bigmac_timer.data = (unsigned long) bp;\r\nbp->bigmac_timer.function = bigmac_timer;\r\nadd_timer(&bp->bigmac_timer);\r\n}\r\nstatic int bigmac_init_hw(struct bigmac *bp, int from_irq)\r\n{\r\nvoid __iomem *gregs = bp->gregs;\r\nvoid __iomem *cregs = bp->creg;\r\nvoid __iomem *bregs = bp->bregs;\r\n__u32 bblk_dvma = (__u32)bp->bblock_dvma;\r\nunsigned char *e = &bp->dev->dev_addr[0];\r\nbigmac_get_counters(bp, bregs);\r\nqec_global_reset(gregs);\r\nqec_init(bp);\r\nbigmac_init_rings(bp, from_irq);\r\nbigmac_tcvr_init(bp);\r\nbigmac_stop(bp);\r\nsbus_writel(((e[4] << 8) | e[5]), bregs + BMAC_MACADDR2);\r\nsbus_writel(((e[2] << 8) | e[3]), bregs + BMAC_MACADDR1);\r\nsbus_writel(((e[0] << 8) | e[1]), bregs + BMAC_MACADDR0);\r\nsbus_writel(0, bregs + BMAC_HTABLE3);\r\nsbus_writel(0, bregs + BMAC_HTABLE2);\r\nsbus_writel(0, bregs + BMAC_HTABLE1);\r\nsbus_writel(0, bregs + BMAC_HTABLE0);\r\nsbus_writel(BIGMAC_RXCFG_HENABLE | BIGMAC_RXCFG_FIFO,\r\nbregs + BMAC_RXCFG);\r\nudelay(20);\r\nsbus_writel(BIGMAC_TXCFG_FIFO, bregs + BMAC_TXCFG);\r\nsbus_writel(((e[5] | e[4] << 8) & 0x3ff),\r\nbregs + BMAC_RSEED);\r\nsbus_writel(BIGMAC_XCFG_ODENABLE | BIGMAC_XCFG_RESV,\r\nbregs + BMAC_XIFCFG);\r\nsbus_writel(bblk_dvma + bib_offset(be_rxd, 0),\r\ncregs + CREG_RXDS);\r\nsbus_writel(bblk_dvma + bib_offset(be_txd, 0),\r\ncregs + CREG_TXDS);\r\nsbus_writel(0, cregs + CREG_RXRBUFPTR);\r\nsbus_writel(0, cregs + CREG_RXWBUFPTR);\r\nsbus_writel(sbus_readl(gregs + GLOB_RSIZE),\r\ncregs + CREG_TXRBUFPTR);\r\nsbus_writel(sbus_readl(gregs + GLOB_RSIZE),\r\ncregs + CREG_TXWBUFPTR);\r\nsbus_writel(BIGMAC_IMASK_GOTFRAME | BIGMAC_IMASK_SENTFRAME,\r\nbregs + BMAC_IMASK);\r\nsbus_writel(0, cregs + CREG_RIMASK);\r\nsbus_writel(0, cregs + CREG_TIMASK);\r\nsbus_writel(0, cregs + CREG_QMASK);\r\nsbus_writel(0, cregs + CREG_BMASK);\r\nsbus_writel(DEFAULT_JAMSIZE, bregs + BMAC_JSIZE);\r\nsbus_writel(0, cregs + CREG_CCNT);\r\nsbus_writel(sbus_readl(bregs + BMAC_TXCFG) | BIGMAC_TXCFG_ENABLE,\r\nbregs + BMAC_TXCFG);\r\nsbus_writel(sbus_readl(bregs + BMAC_RXCFG) | BIGMAC_RXCFG_ENABLE,\r\nbregs + BMAC_RXCFG);\r\nbigmac_begin_auto_negotiation(bp);\r\nreturn 0;\r\n}\r\nstatic void bigmac_is_medium_rare(struct bigmac *bp, u32 qec_status, u32 bmac_status)\r\n{\r\nprintk(KERN_ERR "bigmac_is_medium_rare: ");\r\nif (qec_status & (GLOB_STAT_ER | GLOB_STAT_BM)) {\r\nif (qec_status & GLOB_STAT_ER)\r\nprintk("QEC_ERROR, ");\r\nif (qec_status & GLOB_STAT_BM)\r\nprintk("QEC_BMAC_ERROR, ");\r\n}\r\nif (bmac_status & CREG_STAT_ERRORS) {\r\nif (bmac_status & CREG_STAT_BERROR)\r\nprintk("BMAC_ERROR, ");\r\nif (bmac_status & CREG_STAT_TXDERROR)\r\nprintk("TXD_ERROR, ");\r\nif (bmac_status & CREG_STAT_TXLERR)\r\nprintk("TX_LATE_ERROR, ");\r\nif (bmac_status & CREG_STAT_TXPERR)\r\nprintk("TX_PARITY_ERROR, ");\r\nif (bmac_status & CREG_STAT_TXSERR)\r\nprintk("TX_SBUS_ERROR, ");\r\nif (bmac_status & CREG_STAT_RXDROP)\r\nprintk("RX_DROP_ERROR, ");\r\nif (bmac_status & CREG_STAT_RXSMALL)\r\nprintk("RX_SMALL_ERROR, ");\r\nif (bmac_status & CREG_STAT_RXLERR)\r\nprintk("RX_LATE_ERROR, ");\r\nif (bmac_status & CREG_STAT_RXPERR)\r\nprintk("RX_PARITY_ERROR, ");\r\nif (bmac_status & CREG_STAT_RXSERR)\r\nprintk("RX_SBUS_ERROR, ");\r\n}\r\nprintk(" RESET\n");\r\nbigmac_init_hw(bp, 1);\r\n}\r\nstatic void bigmac_tx(struct bigmac *bp)\r\n{\r\nstruct be_txd *txbase = &bp->bmac_block->be_txd[0];\r\nstruct net_device *dev = bp->dev;\r\nint elem;\r\nspin_lock(&bp->lock);\r\nelem = bp->tx_old;\r\nDTX(("bigmac_tx: tx_old[%d] ", elem));\r\nwhile (elem != bp->tx_new) {\r\nstruct sk_buff *skb;\r\nstruct be_txd *this = &txbase[elem];\r\nDTX(("this(%p) [flags(%08x)addr(%08x)]",\r\nthis, this->tx_flags, this->tx_addr));\r\nif (this->tx_flags & TXD_OWN)\r\nbreak;\r\nskb = bp->tx_skbs[elem];\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\ndma_unmap_single(&bp->bigmac_op->dev,\r\nthis->tx_addr, skb->len,\r\nDMA_TO_DEVICE);\r\nDTX(("skb(%p) ", skb));\r\nbp->tx_skbs[elem] = NULL;\r\ndev_kfree_skb_irq(skb);\r\nelem = NEXT_TX(elem);\r\n}\r\nDTX((" DONE, tx_old=%d\n", elem));\r\nbp->tx_old = elem;\r\nif (netif_queue_stopped(dev) &&\r\nTX_BUFFS_AVAIL(bp) > 0)\r\nnetif_wake_queue(bp->dev);\r\nspin_unlock(&bp->lock);\r\n}\r\nstatic void bigmac_rx(struct bigmac *bp)\r\n{\r\nstruct be_rxd *rxbase = &bp->bmac_block->be_rxd[0];\r\nstruct be_rxd *this;\r\nint elem = bp->rx_new, drops = 0;\r\nu32 flags;\r\nthis = &rxbase[elem];\r\nwhile (!((flags = this->rx_flags) & RXD_OWN)) {\r\nstruct sk_buff *skb;\r\nint len = (flags & RXD_LENGTH);\r\nif (len < ETH_ZLEN) {\r\nbp->dev->stats.rx_errors++;\r\nbp->dev->stats.rx_length_errors++;\r\ndrop_it:\r\nbp->dev->stats.rx_dropped++;\r\nthis->rx_flags =\r\n(RXD_OWN | ((RX_BUF_ALLOC_SIZE - 34) & RXD_LENGTH));\r\ngoto next;\r\n}\r\nskb = bp->rx_skbs[elem];\r\nif (len > RX_COPY_THRESHOLD) {\r\nstruct sk_buff *new_skb;\r\nnew_skb = big_mac_alloc_skb(RX_BUF_ALLOC_SIZE, GFP_ATOMIC);\r\nif (new_skb == NULL) {\r\ndrops++;\r\ngoto drop_it;\r\n}\r\ndma_unmap_single(&bp->bigmac_op->dev,\r\nthis->rx_addr,\r\nRX_BUF_ALLOC_SIZE - 34,\r\nDMA_FROM_DEVICE);\r\nbp->rx_skbs[elem] = new_skb;\r\nskb_put(new_skb, ETH_FRAME_LEN);\r\nskb_reserve(new_skb, 34);\r\nthis->rx_addr =\r\ndma_map_single(&bp->bigmac_op->dev,\r\nnew_skb->data,\r\nRX_BUF_ALLOC_SIZE - 34,\r\nDMA_FROM_DEVICE);\r\nthis->rx_flags =\r\n(RXD_OWN | ((RX_BUF_ALLOC_SIZE - 34) & RXD_LENGTH));\r\nskb_trim(skb, len);\r\n} else {\r\nstruct sk_buff *copy_skb = netdev_alloc_skb(bp->dev, len + 2);\r\nif (copy_skb == NULL) {\r\ndrops++;\r\ngoto drop_it;\r\n}\r\nskb_reserve(copy_skb, 2);\r\nskb_put(copy_skb, len);\r\ndma_sync_single_for_cpu(&bp->bigmac_op->dev,\r\nthis->rx_addr, len,\r\nDMA_FROM_DEVICE);\r\nskb_copy_to_linear_data(copy_skb, (unsigned char *)skb->data, len);\r\ndma_sync_single_for_device(&bp->bigmac_op->dev,\r\nthis->rx_addr, len,\r\nDMA_FROM_DEVICE);\r\nthis->rx_flags =\r\n(RXD_OWN | ((RX_BUF_ALLOC_SIZE - 34) & RXD_LENGTH));\r\nskb = copy_skb;\r\n}\r\nskb->protocol = eth_type_trans(skb, bp->dev);\r\nnetif_rx(skb);\r\nbp->dev->stats.rx_packets++;\r\nbp->dev->stats.rx_bytes += len;\r\nnext:\r\nelem = NEXT_RX(elem);\r\nthis = &rxbase[elem];\r\n}\r\nbp->rx_new = elem;\r\nif (drops)\r\nprintk(KERN_NOTICE "%s: Memory squeeze, deferring packet.\n", bp->dev->name);\r\n}\r\nstatic irqreturn_t bigmac_interrupt(int irq, void *dev_id)\r\n{\r\nstruct bigmac *bp = (struct bigmac *) dev_id;\r\nu32 qec_status, bmac_status;\r\nDIRQ(("bigmac_interrupt: "));\r\nbmac_status = sbus_readl(bp->creg + CREG_STAT);\r\nqec_status = sbus_readl(bp->gregs + GLOB_STAT);\r\nDIRQ(("qec_status=%08x bmac_status=%08x\n", qec_status, bmac_status));\r\nif ((qec_status & (GLOB_STAT_ER | GLOB_STAT_BM)) ||\r\n(bmac_status & CREG_STAT_ERRORS))\r\nbigmac_is_medium_rare(bp, qec_status, bmac_status);\r\nif (bmac_status & CREG_STAT_TXIRQ)\r\nbigmac_tx(bp);\r\nif (bmac_status & CREG_STAT_RXIRQ)\r\nbigmac_rx(bp);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bigmac_open(struct net_device *dev)\r\n{\r\nstruct bigmac *bp = netdev_priv(dev);\r\nint ret;\r\nret = request_irq(dev->irq, bigmac_interrupt, IRQF_SHARED, dev->name, bp);\r\nif (ret) {\r\nprintk(KERN_ERR "BIGMAC: Can't order irq %d to go.\n", dev->irq);\r\nreturn ret;\r\n}\r\ninit_timer(&bp->bigmac_timer);\r\nret = bigmac_init_hw(bp, 0);\r\nif (ret)\r\nfree_irq(dev->irq, bp);\r\nreturn ret;\r\n}\r\nstatic int bigmac_close(struct net_device *dev)\r\n{\r\nstruct bigmac *bp = netdev_priv(dev);\r\ndel_timer(&bp->bigmac_timer);\r\nbp->timer_state = asleep;\r\nbp->timer_ticks = 0;\r\nbigmac_stop(bp);\r\nbigmac_clean_rings(bp);\r\nfree_irq(dev->irq, bp);\r\nreturn 0;\r\n}\r\nstatic void bigmac_tx_timeout(struct net_device *dev)\r\n{\r\nstruct bigmac *bp = netdev_priv(dev);\r\nbigmac_init_hw(bp, 0);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int bigmac_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct bigmac *bp = netdev_priv(dev);\r\nint len, entry;\r\nu32 mapping;\r\nlen = skb->len;\r\nmapping = dma_map_single(&bp->bigmac_op->dev, skb->data,\r\nlen, DMA_TO_DEVICE);\r\nspin_lock_irq(&bp->lock);\r\nentry = bp->tx_new;\r\nDTX(("bigmac_start_xmit: len(%d) entry(%d)\n", len, entry));\r\nbp->bmac_block->be_txd[entry].tx_flags = TXD_UPDATE;\r\nbp->tx_skbs[entry] = skb;\r\nbp->bmac_block->be_txd[entry].tx_addr = mapping;\r\nbp->bmac_block->be_txd[entry].tx_flags =\r\n(TXD_OWN | TXD_SOP | TXD_EOP | (len & TXD_LENGTH));\r\nbp->tx_new = NEXT_TX(entry);\r\nif (TX_BUFFS_AVAIL(bp) <= 0)\r\nnetif_stop_queue(dev);\r\nspin_unlock_irq(&bp->lock);\r\nsbus_writel(CREG_CTRL_TWAKEUP, bp->creg + CREG_CTRL);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct net_device_stats *bigmac_get_stats(struct net_device *dev)\r\n{\r\nstruct bigmac *bp = netdev_priv(dev);\r\nbigmac_get_counters(bp, bp->bregs);\r\nreturn &dev->stats;\r\n}\r\nstatic void bigmac_set_multicast(struct net_device *dev)\r\n{\r\nstruct bigmac *bp = netdev_priv(dev);\r\nvoid __iomem *bregs = bp->bregs;\r\nstruct netdev_hw_addr *ha;\r\nu32 tmp, crc;\r\ntmp = sbus_readl(bregs + BMAC_RXCFG);\r\ntmp &= ~(BIGMAC_RXCFG_ENABLE);\r\nsbus_writel(tmp, bregs + BMAC_RXCFG);\r\nwhile ((sbus_readl(bregs + BMAC_RXCFG) & BIGMAC_RXCFG_ENABLE) != 0)\r\nudelay(20);\r\nif ((dev->flags & IFF_ALLMULTI) || (netdev_mc_count(dev) > 64)) {\r\nsbus_writel(0xffff, bregs + BMAC_HTABLE0);\r\nsbus_writel(0xffff, bregs + BMAC_HTABLE1);\r\nsbus_writel(0xffff, bregs + BMAC_HTABLE2);\r\nsbus_writel(0xffff, bregs + BMAC_HTABLE3);\r\n} else if (dev->flags & IFF_PROMISC) {\r\ntmp = sbus_readl(bregs + BMAC_RXCFG);\r\ntmp |= BIGMAC_RXCFG_PMISC;\r\nsbus_writel(tmp, bregs + BMAC_RXCFG);\r\n} else {\r\nu16 hash_table[4] = { 0 };\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc_le(6, ha->addr);\r\ncrc >>= 26;\r\nhash_table[crc >> 4] |= 1 << (crc & 0xf);\r\n}\r\nsbus_writel(hash_table[0], bregs + BMAC_HTABLE0);\r\nsbus_writel(hash_table[1], bregs + BMAC_HTABLE1);\r\nsbus_writel(hash_table[2], bregs + BMAC_HTABLE2);\r\nsbus_writel(hash_table[3], bregs + BMAC_HTABLE3);\r\n}\r\ntmp = sbus_readl(bregs + BMAC_RXCFG);\r\ntmp |= BIGMAC_RXCFG_ENABLE;\r\nsbus_writel(tmp, bregs + BMAC_RXCFG);\r\n}\r\nstatic void bigmac_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, "sunbmac", sizeof(info->driver));\r\nstrlcpy(info->version, "2.0", sizeof(info->version));\r\n}\r\nstatic u32 bigmac_get_link(struct net_device *dev)\r\n{\r\nstruct bigmac *bp = netdev_priv(dev);\r\nspin_lock_irq(&bp->lock);\r\nbp->sw_bmsr = bigmac_tcvr_read(bp, bp->tregs, MII_BMSR);\r\nspin_unlock_irq(&bp->lock);\r\nreturn (bp->sw_bmsr & BMSR_LSTATUS);\r\n}\r\nstatic int bigmac_ether_init(struct platform_device *op,\r\nstruct platform_device *qec_op)\r\n{\r\nstatic int version_printed;\r\nstruct net_device *dev;\r\nu8 bsizes, bsizes_more;\r\nstruct bigmac *bp;\r\nint i;\r\ndev = alloc_etherdev(sizeof(struct bigmac));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nif (version_printed++ == 0)\r\nprintk(KERN_INFO "%s", version);\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = idprom->id_ethaddr[i];\r\nbp = netdev_priv(dev);\r\nbp->qec_op = qec_op;\r\nbp->bigmac_op = op;\r\nSET_NETDEV_DEV(dev, &op->dev);\r\nspin_lock_init(&bp->lock);\r\nbp->gregs = of_ioremap(&qec_op->resource[0], 0,\r\nGLOB_REG_SIZE, "BigMAC QEC GLobal Regs");\r\nif (!bp->gregs) {\r\nprintk(KERN_ERR "BIGMAC: Cannot map QEC global registers.\n");\r\ngoto fail_and_cleanup;\r\n}\r\nif ((sbus_readl(bp->gregs + GLOB_CTRL) & 0xf0000000) != GLOB_CTRL_BMODE) {\r\nprintk(KERN_ERR "BigMAC: AIEEE, QEC is not in BigMAC mode!\n");\r\ngoto fail_and_cleanup;\r\n}\r\nif (qec_global_reset(bp->gregs))\r\ngoto fail_and_cleanup;\r\nbsizes = of_getintprop_default(qec_op->dev.of_node, "burst-sizes", 0xff);\r\nbsizes_more = of_getintprop_default(qec_op->dev.of_node, "burst-sizes", 0xff);\r\nbsizes &= 0xff;\r\nif (bsizes_more != 0xff)\r\nbsizes &= bsizes_more;\r\nif (bsizes == 0xff || (bsizes & DMA_BURST16) == 0 ||\r\n(bsizes & DMA_BURST32) == 0)\r\nbsizes = (DMA_BURST32 - 1);\r\nbp->bigmac_bursts = bsizes;\r\nqec_init(bp);\r\nbp->creg = of_ioremap(&op->resource[0], 0,\r\nCREG_REG_SIZE, "BigMAC QEC Channel Regs");\r\nif (!bp->creg) {\r\nprintk(KERN_ERR "BIGMAC: Cannot map QEC channel registers.\n");\r\ngoto fail_and_cleanup;\r\n}\r\nbp->bregs = of_ioremap(&op->resource[1], 0,\r\nBMAC_REG_SIZE, "BigMAC Primary Regs");\r\nif (!bp->bregs) {\r\nprintk(KERN_ERR "BIGMAC: Cannot map BigMAC primary registers.\n");\r\ngoto fail_and_cleanup;\r\n}\r\nbp->tregs = of_ioremap(&op->resource[2], 0,\r\nTCVR_REG_SIZE, "BigMAC Transceiver Regs");\r\nif (!bp->tregs) {\r\nprintk(KERN_ERR "BIGMAC: Cannot map BigMAC transceiver registers.\n");\r\ngoto fail_and_cleanup;\r\n}\r\nbigmac_stop(bp);\r\nbp->bmac_block = dma_alloc_coherent(&bp->bigmac_op->dev,\r\nPAGE_SIZE,\r\n&bp->bblock_dvma, GFP_ATOMIC);\r\nif (bp->bmac_block == NULL || bp->bblock_dvma == 0)\r\ngoto fail_and_cleanup;\r\nbp->board_rev = of_getintprop_default(bp->bigmac_op->dev.of_node,\r\n"board-version", 1);\r\ninit_timer(&bp->bigmac_timer);\r\nbp->timer_state = asleep;\r\nbp->timer_ticks = 0;\r\nbp->dev = dev;\r\ndev->ethtool_ops = &bigmac_ethtool_ops;\r\ndev->netdev_ops = &bigmac_ops;\r\ndev->watchdog_timeo = 5*HZ;\r\ndev->irq = bp->bigmac_op->archdata.irqs[0];\r\ndev->dma = 0;\r\nif (register_netdev(dev)) {\r\nprintk(KERN_ERR "BIGMAC: Cannot register device.\n");\r\ngoto fail_and_cleanup;\r\n}\r\ndev_set_drvdata(&bp->bigmac_op->dev, bp);\r\nprintk(KERN_INFO "%s: BigMAC 100baseT Ethernet %pM\n",\r\ndev->name, dev->dev_addr);\r\nreturn 0;\r\nfail_and_cleanup:\r\nif (bp->gregs)\r\nof_iounmap(&qec_op->resource[0], bp->gregs, GLOB_REG_SIZE);\r\nif (bp->creg)\r\nof_iounmap(&op->resource[0], bp->creg, CREG_REG_SIZE);\r\nif (bp->bregs)\r\nof_iounmap(&op->resource[1], bp->bregs, BMAC_REG_SIZE);\r\nif (bp->tregs)\r\nof_iounmap(&op->resource[2], bp->tregs, TCVR_REG_SIZE);\r\nif (bp->bmac_block)\r\ndma_free_coherent(&bp->bigmac_op->dev,\r\nPAGE_SIZE,\r\nbp->bmac_block,\r\nbp->bblock_dvma);\r\nfree_netdev(dev);\r\nreturn -ENODEV;\r\n}\r\nstatic int bigmac_sbus_probe(struct platform_device *op)\r\n{\r\nstruct device *parent = op->dev.parent;\r\nstruct platform_device *qec_op;\r\nqec_op = to_platform_device(parent);\r\nreturn bigmac_ether_init(op, qec_op);\r\n}\r\nstatic int bigmac_sbus_remove(struct platform_device *op)\r\n{\r\nstruct bigmac *bp = platform_get_drvdata(op);\r\nstruct device *parent = op->dev.parent;\r\nstruct net_device *net_dev = bp->dev;\r\nstruct platform_device *qec_op;\r\nqec_op = to_platform_device(parent);\r\nunregister_netdev(net_dev);\r\nof_iounmap(&qec_op->resource[0], bp->gregs, GLOB_REG_SIZE);\r\nof_iounmap(&op->resource[0], bp->creg, CREG_REG_SIZE);\r\nof_iounmap(&op->resource[1], bp->bregs, BMAC_REG_SIZE);\r\nof_iounmap(&op->resource[2], bp->tregs, TCVR_REG_SIZE);\r\ndma_free_coherent(&op->dev,\r\nPAGE_SIZE,\r\nbp->bmac_block,\r\nbp->bblock_dvma);\r\nfree_netdev(net_dev);\r\nreturn 0;\r\n}
