static int jcore_spi_wait(void __iomem *ctrl_reg)\r\n{\r\nunsigned timeout = JCORE_SPI_WAIT_RDY_MAX_LOOP;\r\ndo {\r\nif (!(readl(ctrl_reg) & JCORE_SPI_STAT_BUSY))\r\nreturn 0;\r\ncpu_relax();\r\n} while (--timeout);\r\nreturn -EBUSY;\r\n}\r\nstatic void jcore_spi_program(struct jcore_spi *hw)\r\n{\r\nvoid __iomem *ctrl_reg = hw->base + CTRL_REG;\r\nif (jcore_spi_wait(ctrl_reg))\r\ndev_err(hw->master->dev.parent,\r\n"timeout waiting to program ctrl reg.\n");\r\nwritel(hw->cs_reg | hw->speed_reg, ctrl_reg);\r\n}\r\nstatic void jcore_spi_chipsel(struct spi_device *spi, bool value)\r\n{\r\nstruct jcore_spi *hw = spi_master_get_devdata(spi->master);\r\nu32 csbit = 1U << (2 * spi->chip_select);\r\ndev_dbg(hw->master->dev.parent, "chipselect %d\n", spi->chip_select);\r\nif (value)\r\nhw->cs_reg |= csbit;\r\nelse\r\nhw->cs_reg &= ~csbit;\r\njcore_spi_program(hw);\r\n}\r\nstatic void jcore_spi_baudrate(struct jcore_spi *hw, int speed)\r\n{\r\nif (speed == hw->speed_hz) return;\r\nhw->speed_hz = speed;\r\nif (speed >= hw->clock_freq / 2)\r\nhw->speed_reg = 0;\r\nelse\r\nhw->speed_reg = ((hw->clock_freq / 2 / speed) - 1) << 27;\r\njcore_spi_program(hw);\r\ndev_dbg(hw->master->dev.parent, "speed=%d reg=0x%x\n",\r\nspeed, hw->speed_reg);\r\n}\r\nstatic int jcore_spi_txrx(struct spi_master *master, struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct jcore_spi *hw = spi_master_get_devdata(master);\r\nvoid __iomem *ctrl_reg = hw->base + CTRL_REG;\r\nvoid __iomem *data_reg = hw->base + DATA_REG;\r\nu32 xmit;\r\nconst unsigned char *tx;\r\nunsigned char *rx;\r\nunsigned int len;\r\nunsigned int count;\r\njcore_spi_baudrate(hw, t->speed_hz);\r\nxmit = hw->cs_reg | hw->speed_reg | JCORE_SPI_CTRL_XMIT;\r\ntx = t->tx_buf;\r\nrx = t->rx_buf;\r\nlen = t->len;\r\nfor (count = 0; count < len; count++) {\r\nif (jcore_spi_wait(ctrl_reg))\r\nbreak;\r\nwritel(tx ? *tx++ : 0, data_reg);\r\nwritel(xmit, ctrl_reg);\r\nif (jcore_spi_wait(ctrl_reg))\r\nbreak;\r\nif (rx)\r\n*rx++ = readl(data_reg);\r\n}\r\nspi_finalize_current_transfer(master);\r\nif (count < len)\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int jcore_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct jcore_spi *hw;\r\nstruct spi_master *master;\r\nstruct resource *res;\r\nu32 clock_freq;\r\nstruct clk *clk;\r\nint err = -ENODEV;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct jcore_spi));\r\nif (!master)\r\nreturn err;\r\nmaster->num_chipselect = 3;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->transfer_one = jcore_spi_txrx;\r\nmaster->set_cs = jcore_spi_chipsel;\r\nmaster->dev.of_node = node;\r\nmaster->bus_num = pdev->id;\r\nhw = spi_master_get_devdata(master);\r\nhw->master = master;\r\nplatform_set_drvdata(pdev, hw);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\ngoto exit_busy;\r\nif (!devm_request_mem_region(&pdev->dev, res->start,\r\nresource_size(res), pdev->name))\r\ngoto exit_busy;\r\nhw->base = devm_ioremap_nocache(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!hw->base)\r\ngoto exit_busy;\r\nclock_freq = 50000000;\r\nclk = devm_clk_get(&pdev->dev, "ref_clk");\r\nif (!IS_ERR_OR_NULL(clk)) {\r\nif (clk_enable(clk) == 0)\r\nclock_freq = clk_get_rate(clk);\r\nelse\r\ndev_warn(&pdev->dev, "could not enable ref_clk\n");\r\n}\r\nhw->clock_freq = clock_freq;\r\nhw->cs_reg = JCORE_SPI_CTRL_CS_BITS;\r\njcore_spi_baudrate(hw, 400000);\r\nerr = devm_spi_register_master(&pdev->dev, master);\r\nif (err)\r\ngoto exit;\r\nreturn 0;\r\nexit_busy:\r\nerr = -EBUSY;\r\nexit:\r\nspi_master_put(master);\r\nreturn err;\r\n}
