bool phm_is_hw_access_blocked(struct pp_hwmgr *hwmgr)\r\n{\r\nreturn hwmgr->block_hw_access;\r\n}\r\nint phm_block_hw_access(struct pp_hwmgr *hwmgr, bool block)\r\n{\r\nhwmgr->block_hw_access = block;\r\nreturn 0;\r\n}\r\nint phm_setup_asic(struct pp_hwmgr *hwmgr)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_TablelessHardwareInterface)) {\r\nif (NULL != hwmgr->hwmgr_func->asic_setup)\r\nreturn hwmgr->hwmgr_func->asic_setup(hwmgr);\r\n} else {\r\nreturn phm_dispatch_table(hwmgr, &(hwmgr->setup_asic),\r\nNULL, NULL);\r\n}\r\nreturn 0;\r\n}\r\nint phm_power_down_asic(struct pp_hwmgr *hwmgr)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_TablelessHardwareInterface)) {\r\nif (NULL != hwmgr->hwmgr_func->power_off_asic)\r\nreturn hwmgr->hwmgr_func->power_off_asic(hwmgr);\r\n} else {\r\nreturn phm_dispatch_table(hwmgr, &(hwmgr->power_down_asic),\r\nNULL, NULL);\r\n}\r\nreturn 0;\r\n}\r\nint phm_set_power_state(struct pp_hwmgr *hwmgr,\r\nconst struct pp_hw_power_state *pcurrent_state,\r\nconst struct pp_hw_power_state *pnew_power_state)\r\n{\r\nstruct phm_set_power_state_input states;\r\nPHM_FUNC_CHECK(hwmgr);\r\nstates.pcurrent_state = pcurrent_state;\r\nstates.pnew_state = pnew_power_state;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_TablelessHardwareInterface)) {\r\nif (NULL != hwmgr->hwmgr_func->power_state_set)\r\nreturn hwmgr->hwmgr_func->power_state_set(hwmgr, &states);\r\n} else {\r\nreturn phm_dispatch_table(hwmgr, &(hwmgr->set_power_state), &states, NULL);\r\n}\r\nreturn 0;\r\n}\r\nint phm_enable_dynamic_state_management(struct pp_hwmgr *hwmgr)\r\n{\r\nint ret = 1;\r\nbool enabled;\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_TablelessHardwareInterface)) {\r\nif (NULL != hwmgr->hwmgr_func->dynamic_state_management_enable)\r\nret = hwmgr->hwmgr_func->dynamic_state_management_enable(hwmgr);\r\n} else {\r\nret = phm_dispatch_table(hwmgr,\r\n&(hwmgr->enable_dynamic_state_management),\r\nNULL, NULL);\r\n}\r\nenabled = ret == 0;\r\ncgs_notify_dpm_enabled(hwmgr->device, enabled);\r\nreturn ret;\r\n}\r\nint phm_disable_dynamic_state_management(struct pp_hwmgr *hwmgr)\r\n{\r\nint ret = -1;\r\nbool enabled;\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_TablelessHardwareInterface)) {\r\nif (hwmgr->hwmgr_func->dynamic_state_management_disable)\r\nret = hwmgr->hwmgr_func->dynamic_state_management_disable(hwmgr);\r\n} else {\r\nret = phm_dispatch_table(hwmgr,\r\n&(hwmgr->disable_dynamic_state_management),\r\nNULL, NULL);\r\n}\r\nenabled = ret == 0 ? false : true;\r\ncgs_notify_dpm_enabled(hwmgr->device, enabled);\r\nreturn ret;\r\n}\r\nint phm_force_dpm_levels(struct pp_hwmgr *hwmgr, enum amd_dpm_forced_level level)\r\n{\r\nint ret = 0;\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->force_dpm_level != NULL) {\r\nret = hwmgr->hwmgr_func->force_dpm_level(hwmgr, level);\r\nif (ret)\r\nreturn ret;\r\nif (hwmgr->hwmgr_func->set_power_profile_state) {\r\nif (hwmgr->current_power_profile == AMD_PP_GFX_PROFILE)\r\nret = hwmgr->hwmgr_func->set_power_profile_state(\r\nhwmgr,\r\n&hwmgr->gfx_power_profile);\r\nelse if (hwmgr->current_power_profile == AMD_PP_COMPUTE_PROFILE)\r\nret = hwmgr->hwmgr_func->set_power_profile_state(\r\nhwmgr,\r\n&hwmgr->compute_power_profile);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint phm_apply_state_adjust_rules(struct pp_hwmgr *hwmgr,\r\nstruct pp_power_state *adjusted_ps,\r\nconst struct pp_power_state *current_ps)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->apply_state_adjust_rules != NULL)\r\nreturn hwmgr->hwmgr_func->apply_state_adjust_rules(\r\nhwmgr,\r\nadjusted_ps,\r\ncurrent_ps);\r\nreturn 0;\r\n}\r\nint phm_powerdown_uvd(struct pp_hwmgr *hwmgr)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->powerdown_uvd != NULL)\r\nreturn hwmgr->hwmgr_func->powerdown_uvd(hwmgr);\r\nreturn 0;\r\n}\r\nint phm_powergate_uvd(struct pp_hwmgr *hwmgr, bool gate)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->powergate_uvd != NULL)\r\nreturn hwmgr->hwmgr_func->powergate_uvd(hwmgr, gate);\r\nreturn 0;\r\n}\r\nint phm_powergate_vce(struct pp_hwmgr *hwmgr, bool gate)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->powergate_vce != NULL)\r\nreturn hwmgr->hwmgr_func->powergate_vce(hwmgr, gate);\r\nreturn 0;\r\n}\r\nint phm_enable_clock_power_gatings(struct pp_hwmgr *hwmgr)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_TablelessHardwareInterface)) {\r\nif (NULL != hwmgr->hwmgr_func->enable_clock_power_gating)\r\nreturn hwmgr->hwmgr_func->enable_clock_power_gating(hwmgr);\r\n} else {\r\nreturn phm_dispatch_table(hwmgr, &(hwmgr->enable_clock_power_gatings), NULL, NULL);\r\n}\r\nreturn 0;\r\n}\r\nint phm_disable_clock_power_gatings(struct pp_hwmgr *hwmgr)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_TablelessHardwareInterface)) {\r\nif (NULL != hwmgr->hwmgr_func->disable_clock_power_gating)\r\nreturn hwmgr->hwmgr_func->disable_clock_power_gating(hwmgr);\r\n}\r\nreturn 0;\r\n}\r\nint phm_display_configuration_changed(struct pp_hwmgr *hwmgr)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_TablelessHardwareInterface)) {\r\nif (NULL != hwmgr->hwmgr_func->display_config_changed)\r\nhwmgr->hwmgr_func->display_config_changed(hwmgr);\r\n} else\r\nreturn phm_dispatch_table(hwmgr, &hwmgr->display_configuration_changed, NULL, NULL);\r\nreturn 0;\r\n}\r\nint phm_notify_smc_display_config_after_ps_adjustment(struct pp_hwmgr *hwmgr)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_TablelessHardwareInterface))\r\nif (NULL != hwmgr->hwmgr_func->notify_smc_display_config_after_ps_adjustment)\r\nhwmgr->hwmgr_func->notify_smc_display_config_after_ps_adjustment(hwmgr);\r\nreturn 0;\r\n}\r\nint phm_stop_thermal_controller(struct pp_hwmgr *hwmgr)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->stop_thermal_controller == NULL)\r\nreturn -EINVAL;\r\nreturn hwmgr->hwmgr_func->stop_thermal_controller(hwmgr);\r\n}\r\nint phm_register_thermal_interrupt(struct pp_hwmgr *hwmgr, const void *info)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->register_internal_thermal_interrupt == NULL)\r\nreturn -EINVAL;\r\nreturn hwmgr->hwmgr_func->register_internal_thermal_interrupt(hwmgr, info);\r\n}\r\nint phm_start_thermal_controller(struct pp_hwmgr *hwmgr, struct PP_TemperatureRange *temperature_range)\r\n{\r\nreturn phm_dispatch_table(hwmgr, &(hwmgr->start_thermal_controller), temperature_range, NULL);\r\n}\r\nbool phm_check_smc_update_required_for_display_configuration(struct pp_hwmgr *hwmgr)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->check_smc_update_required_for_display_configuration == NULL)\r\nreturn false;\r\nreturn hwmgr->hwmgr_func->check_smc_update_required_for_display_configuration(hwmgr);\r\n}\r\nint phm_check_states_equal(struct pp_hwmgr *hwmgr,\r\nconst struct pp_hw_power_state *pstate1,\r\nconst struct pp_hw_power_state *pstate2,\r\nbool *equal)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->check_states_equal == NULL)\r\nreturn -EINVAL;\r\nreturn hwmgr->hwmgr_func->check_states_equal(hwmgr, pstate1, pstate2, equal);\r\n}\r\nint phm_store_dal_configuration_data(struct pp_hwmgr *hwmgr,\r\nconst struct amd_pp_display_configuration *display_config)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (display_config == NULL)\r\nreturn -EINVAL;\r\nhwmgr->display_config = *display_config;\r\nif (hwmgr->hwmgr_func->store_cc6_data == NULL)\r\nreturn -EINVAL;\r\nif (hwmgr->hwmgr_func->store_cc6_data)\r\nhwmgr->hwmgr_func->store_cc6_data(hwmgr,\r\ndisplay_config->cpu_pstate_separation_time,\r\ndisplay_config->cpu_cc6_disable,\r\ndisplay_config->cpu_pstate_disable,\r\ndisplay_config->nb_pstate_switch_disable);\r\nreturn 0;\r\n}\r\nint phm_get_dal_power_level(struct pp_hwmgr *hwmgr,\r\nstruct amd_pp_simple_clock_info *info)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (info == NULL || hwmgr->hwmgr_func->get_dal_power_level == NULL)\r\nreturn -EINVAL;\r\nreturn hwmgr->hwmgr_func->get_dal_power_level(hwmgr, info);\r\n}\r\nint phm_set_cpu_power_state(struct pp_hwmgr *hwmgr)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->set_cpu_power_state != NULL)\r\nreturn hwmgr->hwmgr_func->set_cpu_power_state(hwmgr);\r\nreturn 0;\r\n}\r\nint phm_get_performance_level(struct pp_hwmgr *hwmgr, const struct pp_hw_power_state *state,\r\nPHM_PerformanceLevelDesignation designation, uint32_t index,\r\nPHM_PerformanceLevel *level)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->get_performance_level == NULL)\r\nreturn -EINVAL;\r\nreturn hwmgr->hwmgr_func->get_performance_level(hwmgr, state, designation, index, level);\r\n}\r\nint phm_get_clock_info(struct pp_hwmgr *hwmgr, const struct pp_hw_power_state *state, struct pp_clock_info *pclock_info,\r\nPHM_PerformanceLevelDesignation designation)\r\n{\r\nint result;\r\nPHM_PerformanceLevel performance_level;\r\nPHM_FUNC_CHECK(hwmgr);\r\nPP_ASSERT_WITH_CODE((NULL != state), "Invalid Input!", return -EINVAL);\r\nPP_ASSERT_WITH_CODE((NULL != pclock_info), "Invalid Input!", return -EINVAL);\r\nresult = phm_get_performance_level(hwmgr, state, PHM_PerformanceLevelDesignation_Activity, 0, &performance_level);\r\nPP_ASSERT_WITH_CODE((0 == result), "Failed to retrieve minimum clocks.", return result);\r\npclock_info->min_mem_clk = performance_level.memory_clock;\r\npclock_info->min_eng_clk = performance_level.coreClock;\r\npclock_info->min_bus_bandwidth = performance_level.nonLocalMemoryFreq * performance_level.nonLocalMemoryWidth;\r\nresult = phm_get_performance_level(hwmgr, state, designation,\r\n(hwmgr->platform_descriptor.hardwareActivityPerformanceLevels - 1), &performance_level);\r\nPP_ASSERT_WITH_CODE((0 == result), "Failed to retrieve maximum clocks.", return result);\r\npclock_info->max_mem_clk = performance_level.memory_clock;\r\npclock_info->max_eng_clk = performance_level.coreClock;\r\npclock_info->max_bus_bandwidth = performance_level.nonLocalMemoryFreq * performance_level.nonLocalMemoryWidth;\r\nreturn 0;\r\n}\r\nint phm_get_current_shallow_sleep_clocks(struct pp_hwmgr *hwmgr, const struct pp_hw_power_state *state, struct pp_clock_info *clock_info)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->get_current_shallow_sleep_clocks == NULL)\r\nreturn -EINVAL;\r\nreturn hwmgr->hwmgr_func->get_current_shallow_sleep_clocks(hwmgr, state, clock_info);\r\n}\r\nint phm_get_clock_by_type(struct pp_hwmgr *hwmgr, enum amd_pp_clock_type type, struct amd_pp_clocks *clocks)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->get_clock_by_type == NULL)\r\nreturn -EINVAL;\r\nreturn hwmgr->hwmgr_func->get_clock_by_type(hwmgr, type, clocks);\r\n}\r\nint phm_get_clock_by_type_with_latency(struct pp_hwmgr *hwmgr,\r\nenum amd_pp_clock_type type,\r\nstruct pp_clock_levels_with_latency *clocks)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->get_clock_by_type_with_latency == NULL)\r\nreturn -EINVAL;\r\nreturn hwmgr->hwmgr_func->get_clock_by_type_with_latency(hwmgr, type, clocks);\r\n}\r\nint phm_get_clock_by_type_with_voltage(struct pp_hwmgr *hwmgr,\r\nenum amd_pp_clock_type type,\r\nstruct pp_clock_levels_with_voltage *clocks)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->get_clock_by_type_with_voltage == NULL)\r\nreturn -EINVAL;\r\nreturn hwmgr->hwmgr_func->get_clock_by_type_with_voltage(hwmgr, type, clocks);\r\n}\r\nint phm_set_watermarks_for_clocks_ranges(struct pp_hwmgr *hwmgr,\r\nstruct pp_wm_sets_with_clock_ranges_soc15 *wm_with_clock_ranges)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (!hwmgr->hwmgr_func->set_watermarks_for_clocks_ranges)\r\nreturn -EINVAL;\r\nreturn hwmgr->hwmgr_func->set_watermarks_for_clocks_ranges(hwmgr,\r\nwm_with_clock_ranges);\r\n}\r\nint phm_display_clock_voltage_request(struct pp_hwmgr *hwmgr,\r\nstruct pp_display_clock_request *clock)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (!hwmgr->hwmgr_func->display_clock_voltage_request)\r\nreturn -EINVAL;\r\nreturn hwmgr->hwmgr_func->display_clock_voltage_request(hwmgr, clock);\r\n}\r\nint phm_get_max_high_clocks(struct pp_hwmgr *hwmgr, struct amd_pp_simple_clock_info *clocks)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->get_max_high_clocks == NULL)\r\nreturn -EINVAL;\r\nreturn hwmgr->hwmgr_func->get_max_high_clocks(hwmgr, clocks);\r\n}\r\nint phm_disable_smc_firmware_ctf(struct pp_hwmgr *hwmgr)\r\n{\r\nPHM_FUNC_CHECK(hwmgr);\r\nif (hwmgr->hwmgr_func->disable_smc_firmware_ctf == NULL)\r\nreturn -EINVAL;\r\nreturn hwmgr->hwmgr_func->disable_smc_firmware_ctf(hwmgr);\r\n}
