int simple_getattr(const struct path *path, struct kstat *stat,\r\nu32 request_mask, unsigned int query_flags)\r\n{\r\nstruct inode *inode = d_inode(path->dentry);\r\ngeneric_fillattr(inode, stat);\r\nstat->blocks = inode->i_mapping->nrpages << (PAGE_SHIFT - 9);\r\nreturn 0;\r\n}\r\nint simple_statfs(struct dentry *dentry, struct kstatfs *buf)\r\n{\r\nbuf->f_type = dentry->d_sb->s_magic;\r\nbuf->f_bsize = PAGE_SIZE;\r\nbuf->f_namelen = NAME_MAX;\r\nreturn 0;\r\n}\r\nint always_delete_dentry(const struct dentry *dentry)\r\n{\r\nreturn 1;\r\n}\r\nstruct dentry *simple_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\r\n{\r\nif (dentry->d_name.len > NAME_MAX)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nif (!dentry->d_sb->s_d_op)\r\nd_set_d_op(dentry, &simple_dentry_operations);\r\nd_add(dentry, NULL);\r\nreturn NULL;\r\n}\r\nint dcache_dir_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = d_alloc_cursor(file->f_path.dentry);\r\nreturn file->private_data ? 0 : -ENOMEM;\r\n}\r\nint dcache_dir_close(struct inode *inode, struct file *file)\r\n{\r\ndput(file->private_data);\r\nreturn 0;\r\n}\r\nstatic struct dentry *next_positive(struct dentry *parent,\r\nstruct list_head *from,\r\nint count)\r\n{\r\nunsigned *seq = &parent->d_inode->i_dir_seq, n;\r\nstruct dentry *res;\r\nstruct list_head *p;\r\nbool skipped;\r\nint i;\r\nretry:\r\ni = count;\r\nskipped = false;\r\nn = smp_load_acquire(seq) & ~1;\r\nres = NULL;\r\nrcu_read_lock();\r\nfor (p = from->next; p != &parent->d_subdirs; p = p->next) {\r\nstruct dentry *d = list_entry(p, struct dentry, d_child);\r\nif (!simple_positive(d)) {\r\nskipped = true;\r\n} else if (!--i) {\r\nres = d;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (skipped) {\r\nsmp_rmb();\r\nif (unlikely(*seq != n))\r\ngoto retry;\r\n}\r\nreturn res;\r\n}\r\nstatic void move_cursor(struct dentry *cursor, struct list_head *after)\r\n{\r\nstruct dentry *parent = cursor->d_parent;\r\nunsigned n, *seq = &parent->d_inode->i_dir_seq;\r\nspin_lock(&parent->d_lock);\r\nfor (;;) {\r\nn = *seq;\r\nif (!(n & 1) && cmpxchg(seq, n, n + 1) == n)\r\nbreak;\r\ncpu_relax();\r\n}\r\n__list_del(cursor->d_child.prev, cursor->d_child.next);\r\nif (after)\r\nlist_add(&cursor->d_child, after);\r\nelse\r\nlist_add_tail(&cursor->d_child, &parent->d_subdirs);\r\nsmp_store_release(seq, n + 2);\r\nspin_unlock(&parent->d_lock);\r\n}\r\nloff_t dcache_dir_lseek(struct file *file, loff_t offset, int whence)\r\n{\r\nstruct dentry *dentry = file->f_path.dentry;\r\nswitch (whence) {\r\ncase 1:\r\noffset += file->f_pos;\r\ncase 0:\r\nif (offset >= 0)\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (offset != file->f_pos) {\r\nfile->f_pos = offset;\r\nif (file->f_pos >= 2) {\r\nstruct dentry *cursor = file->private_data;\r\nstruct dentry *to;\r\nloff_t n = file->f_pos - 2;\r\ninode_lock_shared(dentry->d_inode);\r\nto = next_positive(dentry, &dentry->d_subdirs, n);\r\nmove_cursor(cursor, to ? &to->d_child : NULL);\r\ninode_unlock_shared(dentry->d_inode);\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic inline unsigned char dt_type(struct inode *inode)\r\n{\r\nreturn (inode->i_mode >> 12) & 15;\r\n}\r\nint dcache_readdir(struct file *file, struct dir_context *ctx)\r\n{\r\nstruct dentry *dentry = file->f_path.dentry;\r\nstruct dentry *cursor = file->private_data;\r\nstruct list_head *p = &cursor->d_child;\r\nstruct dentry *next;\r\nbool moved = false;\r\nif (!dir_emit_dots(file, ctx))\r\nreturn 0;\r\nif (ctx->pos == 2)\r\np = &dentry->d_subdirs;\r\nwhile ((next = next_positive(dentry, p, 1)) != NULL) {\r\nif (!dir_emit(ctx, next->d_name.name, next->d_name.len,\r\nd_inode(next)->i_ino, dt_type(d_inode(next))))\r\nbreak;\r\nmoved = true;\r\np = &next->d_child;\r\nctx->pos++;\r\n}\r\nif (moved)\r\nmove_cursor(cursor, p);\r\nreturn 0;\r\n}\r\nssize_t generic_read_dir(struct file *filp, char __user *buf, size_t siz, loff_t *ppos)\r\n{\r\nreturn -EISDIR;\r\n}\r\nstruct dentry *mount_pseudo_xattr(struct file_system_type *fs_type, char *name,\r\nconst struct super_operations *ops, const struct xattr_handler **xattr,\r\nconst struct dentry_operations *dops, unsigned long magic)\r\n{\r\nstruct super_block *s;\r\nstruct dentry *dentry;\r\nstruct inode *root;\r\nstruct qstr d_name = QSTR_INIT(name, strlen(name));\r\ns = sget_userns(fs_type, NULL, set_anon_super, MS_KERNMOUNT|MS_NOUSER,\r\n&init_user_ns, NULL);\r\nif (IS_ERR(s))\r\nreturn ERR_CAST(s);\r\ns->s_maxbytes = MAX_LFS_FILESIZE;\r\ns->s_blocksize = PAGE_SIZE;\r\ns->s_blocksize_bits = PAGE_SHIFT;\r\ns->s_magic = magic;\r\ns->s_op = ops ? ops : &simple_super_operations;\r\ns->s_xattr = xattr;\r\ns->s_time_gran = 1;\r\nroot = new_inode(s);\r\nif (!root)\r\ngoto Enomem;\r\nroot->i_ino = 1;\r\nroot->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;\r\nroot->i_atime = root->i_mtime = root->i_ctime = current_time(root);\r\ndentry = __d_alloc(s, &d_name);\r\nif (!dentry) {\r\niput(root);\r\ngoto Enomem;\r\n}\r\nd_instantiate(dentry, root);\r\ns->s_root = dentry;\r\ns->s_d_op = dops;\r\ns->s_flags |= MS_ACTIVE;\r\nreturn dget(s->s_root);\r\nEnomem:\r\ndeactivate_locked_super(s);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nint simple_open(struct inode *inode, struct file *file)\r\n{\r\nif (inode->i_private)\r\nfile->private_data = inode->i_private;\r\nreturn 0;\r\n}\r\nint simple_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct inode *inode = d_inode(old_dentry);\r\ninode->i_ctime = dir->i_ctime = dir->i_mtime = current_time(inode);\r\ninc_nlink(inode);\r\nihold(inode);\r\ndget(dentry);\r\nd_instantiate(dentry, inode);\r\nreturn 0;\r\n}\r\nint simple_empty(struct dentry *dentry)\r\n{\r\nstruct dentry *child;\r\nint ret = 0;\r\nspin_lock(&dentry->d_lock);\r\nlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\r\nspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\r\nif (simple_positive(child)) {\r\nspin_unlock(&child->d_lock);\r\ngoto out;\r\n}\r\nspin_unlock(&child->d_lock);\r\n}\r\nret = 1;\r\nout:\r\nspin_unlock(&dentry->d_lock);\r\nreturn ret;\r\n}\r\nint simple_unlink(struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct inode *inode = d_inode(dentry);\r\ninode->i_ctime = dir->i_ctime = dir->i_mtime = current_time(inode);\r\ndrop_nlink(inode);\r\ndput(dentry);\r\nreturn 0;\r\n}\r\nint simple_rmdir(struct inode *dir, struct dentry *dentry)\r\n{\r\nif (!simple_empty(dentry))\r\nreturn -ENOTEMPTY;\r\ndrop_nlink(d_inode(dentry));\r\nsimple_unlink(dir, dentry);\r\ndrop_nlink(dir);\r\nreturn 0;\r\n}\r\nint simple_rename(struct inode *old_dir, struct dentry *old_dentry,\r\nstruct inode *new_dir, struct dentry *new_dentry,\r\nunsigned int flags)\r\n{\r\nstruct inode *inode = d_inode(old_dentry);\r\nint they_are_dirs = d_is_dir(old_dentry);\r\nif (flags & ~RENAME_NOREPLACE)\r\nreturn -EINVAL;\r\nif (!simple_empty(new_dentry))\r\nreturn -ENOTEMPTY;\r\nif (d_really_is_positive(new_dentry)) {\r\nsimple_unlink(new_dir, new_dentry);\r\nif (they_are_dirs) {\r\ndrop_nlink(d_inode(new_dentry));\r\ndrop_nlink(old_dir);\r\n}\r\n} else if (they_are_dirs) {\r\ndrop_nlink(old_dir);\r\ninc_nlink(new_dir);\r\n}\r\nold_dir->i_ctime = old_dir->i_mtime = new_dir->i_ctime =\r\nnew_dir->i_mtime = inode->i_ctime = current_time(old_dir);\r\nreturn 0;\r\n}\r\nint simple_setattr(struct dentry *dentry, struct iattr *iattr)\r\n{\r\nstruct inode *inode = d_inode(dentry);\r\nint error;\r\nerror = setattr_prepare(dentry, iattr);\r\nif (error)\r\nreturn error;\r\nif (iattr->ia_valid & ATTR_SIZE)\r\ntruncate_setsize(inode, iattr->ia_size);\r\nsetattr_copy(inode, iattr);\r\nmark_inode_dirty(inode);\r\nreturn 0;\r\n}\r\nint simple_readpage(struct file *file, struct page *page)\r\n{\r\nclear_highpage(page);\r\nflush_dcache_page(page);\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\nreturn 0;\r\n}\r\nint simple_write_begin(struct file *file, struct address_space *mapping,\r\nloff_t pos, unsigned len, unsigned flags,\r\nstruct page **pagep, void **fsdata)\r\n{\r\nstruct page *page;\r\npgoff_t index;\r\nindex = pos >> PAGE_SHIFT;\r\npage = grab_cache_page_write_begin(mapping, index, flags);\r\nif (!page)\r\nreturn -ENOMEM;\r\n*pagep = page;\r\nif (!PageUptodate(page) && (len != PAGE_SIZE)) {\r\nunsigned from = pos & (PAGE_SIZE - 1);\r\nzero_user_segments(page, 0, from, from + len, PAGE_SIZE);\r\n}\r\nreturn 0;\r\n}\r\nint simple_write_end(struct file *file, struct address_space *mapping,\r\nloff_t pos, unsigned len, unsigned copied,\r\nstruct page *page, void *fsdata)\r\n{\r\nstruct inode *inode = page->mapping->host;\r\nloff_t last_pos = pos + copied;\r\nif (!PageUptodate(page)) {\r\nif (copied < len) {\r\nunsigned from = pos & (PAGE_SIZE - 1);\r\nzero_user(page, from + copied, len - copied);\r\n}\r\nSetPageUptodate(page);\r\n}\r\nif (last_pos > inode->i_size)\r\ni_size_write(inode, last_pos);\r\nset_page_dirty(page);\r\nunlock_page(page);\r\nput_page(page);\r\nreturn copied;\r\n}\r\nint simple_fill_super(struct super_block *s, unsigned long magic,\r\nconst struct tree_descr *files)\r\n{\r\nstruct inode *inode;\r\nstruct dentry *root;\r\nstruct dentry *dentry;\r\nint i;\r\ns->s_blocksize = PAGE_SIZE;\r\ns->s_blocksize_bits = PAGE_SHIFT;\r\ns->s_magic = magic;\r\ns->s_op = &simple_super_operations;\r\ns->s_time_gran = 1;\r\ninode = new_inode(s);\r\nif (!inode)\r\nreturn -ENOMEM;\r\ninode->i_ino = 1;\r\ninode->i_mode = S_IFDIR | 0755;\r\ninode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\r\ninode->i_op = &simple_dir_inode_operations;\r\ninode->i_fop = &simple_dir_operations;\r\nset_nlink(inode, 2);\r\nroot = d_make_root(inode);\r\nif (!root)\r\nreturn -ENOMEM;\r\nfor (i = 0; !files->name || files->name[0]; i++, files++) {\r\nif (!files->name)\r\ncontinue;\r\nif (unlikely(i == 1))\r\nprintk(KERN_WARNING "%s: %s passed in a files array"\r\n"with an index of 1!\n", __func__,\r\ns->s_type->name);\r\ndentry = d_alloc_name(root, files->name);\r\nif (!dentry)\r\ngoto out;\r\ninode = new_inode(s);\r\nif (!inode) {\r\ndput(dentry);\r\ngoto out;\r\n}\r\ninode->i_mode = S_IFREG | files->mode;\r\ninode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\r\ninode->i_fop = files->ops;\r\ninode->i_ino = i;\r\nd_add(dentry, inode);\r\n}\r\ns->s_root = root;\r\nreturn 0;\r\nout:\r\nd_genocide(root);\r\nshrink_dcache_parent(root);\r\ndput(root);\r\nreturn -ENOMEM;\r\n}\r\nint simple_pin_fs(struct file_system_type *type, struct vfsmount **mount, int *count)\r\n{\r\nstruct vfsmount *mnt = NULL;\r\nspin_lock(&pin_fs_lock);\r\nif (unlikely(!*mount)) {\r\nspin_unlock(&pin_fs_lock);\r\nmnt = vfs_kern_mount(type, MS_KERNMOUNT, type->name, NULL);\r\nif (IS_ERR(mnt))\r\nreturn PTR_ERR(mnt);\r\nspin_lock(&pin_fs_lock);\r\nif (!*mount)\r\n*mount = mnt;\r\n}\r\nmntget(*mount);\r\n++*count;\r\nspin_unlock(&pin_fs_lock);\r\nmntput(mnt);\r\nreturn 0;\r\n}\r\nvoid simple_release_fs(struct vfsmount **mount, int *count)\r\n{\r\nstruct vfsmount *mnt;\r\nspin_lock(&pin_fs_lock);\r\nmnt = *mount;\r\nif (!--*count)\r\n*mount = NULL;\r\nspin_unlock(&pin_fs_lock);\r\nmntput(mnt);\r\n}\r\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\r\nconst void *from, size_t available)\r\n{\r\nloff_t pos = *ppos;\r\nsize_t ret;\r\nif (pos < 0)\r\nreturn -EINVAL;\r\nif (pos >= available || !count)\r\nreturn 0;\r\nif (count > available - pos)\r\ncount = available - pos;\r\nret = copy_to_user(to, from + pos, count);\r\nif (ret == count)\r\nreturn -EFAULT;\r\ncount -= ret;\r\n*ppos = pos + count;\r\nreturn count;\r\n}\r\nssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,\r\nconst void __user *from, size_t count)\r\n{\r\nloff_t pos = *ppos;\r\nsize_t res;\r\nif (pos < 0)\r\nreturn -EINVAL;\r\nif (pos >= available || !count)\r\nreturn 0;\r\nif (count > available - pos)\r\ncount = available - pos;\r\nres = copy_from_user(to + pos, from, count);\r\nif (res == count)\r\nreturn -EFAULT;\r\ncount -= res;\r\n*ppos = pos + count;\r\nreturn count;\r\n}\r\nssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,\r\nconst void *from, size_t available)\r\n{\r\nloff_t pos = *ppos;\r\nif (pos < 0)\r\nreturn -EINVAL;\r\nif (pos >= available)\r\nreturn 0;\r\nif (count > available - pos)\r\ncount = available - pos;\r\nmemcpy(to, from + pos, count);\r\n*ppos = pos + count;\r\nreturn count;\r\n}\r\nvoid simple_transaction_set(struct file *file, size_t n)\r\n{\r\nstruct simple_transaction_argresp *ar = file->private_data;\r\nBUG_ON(n > SIMPLE_TRANSACTION_LIMIT);\r\nsmp_mb();\r\nar->size = n;\r\n}\r\nchar *simple_transaction_get(struct file *file, const char __user *buf, size_t size)\r\n{\r\nstruct simple_transaction_argresp *ar;\r\nstatic DEFINE_SPINLOCK(simple_transaction_lock);\r\nif (size > SIMPLE_TRANSACTION_LIMIT - 1)\r\nreturn ERR_PTR(-EFBIG);\r\nar = (struct simple_transaction_argresp *)get_zeroed_page(GFP_KERNEL);\r\nif (!ar)\r\nreturn ERR_PTR(-ENOMEM);\r\nspin_lock(&simple_transaction_lock);\r\nif (file->private_data) {\r\nspin_unlock(&simple_transaction_lock);\r\nfree_page((unsigned long)ar);\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\nfile->private_data = ar;\r\nspin_unlock(&simple_transaction_lock);\r\nif (copy_from_user(ar->data, buf, size))\r\nreturn ERR_PTR(-EFAULT);\r\nreturn ar->data;\r\n}\r\nssize_t simple_transaction_read(struct file *file, char __user *buf, size_t size, loff_t *pos)\r\n{\r\nstruct simple_transaction_argresp *ar = file->private_data;\r\nif (!ar)\r\nreturn 0;\r\nreturn simple_read_from_buffer(buf, size, pos, ar->data, ar->size);\r\n}\r\nint simple_transaction_release(struct inode *inode, struct file *file)\r\n{\r\nfree_page((unsigned long)file->private_data);\r\nreturn 0;\r\n}\r\nint simple_attr_open(struct inode *inode, struct file *file,\r\nint (*get)(void *, u64 *), int (*set)(void *, u64),\r\nconst char *fmt)\r\n{\r\nstruct simple_attr *attr;\r\nattr = kmalloc(sizeof(*attr), GFP_KERNEL);\r\nif (!attr)\r\nreturn -ENOMEM;\r\nattr->get = get;\r\nattr->set = set;\r\nattr->data = inode->i_private;\r\nattr->fmt = fmt;\r\nmutex_init(&attr->mutex);\r\nfile->private_data = attr;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nint simple_attr_release(struct inode *inode, struct file *file)\r\n{\r\nkfree(file->private_data);\r\nreturn 0;\r\n}\r\nssize_t simple_attr_read(struct file *file, char __user *buf,\r\nsize_t len, loff_t *ppos)\r\n{\r\nstruct simple_attr *attr;\r\nsize_t size;\r\nssize_t ret;\r\nattr = file->private_data;\r\nif (!attr->get)\r\nreturn -EACCES;\r\nret = mutex_lock_interruptible(&attr->mutex);\r\nif (ret)\r\nreturn ret;\r\nif (*ppos) {\r\nsize = strlen(attr->get_buf);\r\n} else {\r\nu64 val;\r\nret = attr->get(attr->data, &val);\r\nif (ret)\r\ngoto out;\r\nsize = scnprintf(attr->get_buf, sizeof(attr->get_buf),\r\nattr->fmt, (unsigned long long)val);\r\n}\r\nret = simple_read_from_buffer(buf, len, ppos, attr->get_buf, size);\r\nout:\r\nmutex_unlock(&attr->mutex);\r\nreturn ret;\r\n}\r\nssize_t simple_attr_write(struct file *file, const char __user *buf,\r\nsize_t len, loff_t *ppos)\r\n{\r\nstruct simple_attr *attr;\r\nu64 val;\r\nsize_t size;\r\nssize_t ret;\r\nattr = file->private_data;\r\nif (!attr->set)\r\nreturn -EACCES;\r\nret = mutex_lock_interruptible(&attr->mutex);\r\nif (ret)\r\nreturn ret;\r\nret = -EFAULT;\r\nsize = min(sizeof(attr->set_buf) - 1, len);\r\nif (copy_from_user(attr->set_buf, buf, size))\r\ngoto out;\r\nattr->set_buf[size] = '\0';\r\nval = simple_strtoll(attr->set_buf, NULL, 0);\r\nret = attr->set(attr->data, val);\r\nif (ret == 0)\r\nret = len;\r\nout:\r\nmutex_unlock(&attr->mutex);\r\nreturn ret;\r\n}\r\nint __generic_file_fsync(struct file *file, loff_t start, loff_t end,\r\nint datasync)\r\n{\r\nstruct inode *inode = file->f_mapping->host;\r\nint err;\r\nint ret;\r\nerr = file_write_and_wait_range(file, start, end);\r\nif (err)\r\nreturn err;\r\ninode_lock(inode);\r\nret = sync_mapping_buffers(inode->i_mapping);\r\nif (!(inode->i_state & I_DIRTY_ALL))\r\ngoto out;\r\nif (datasync && !(inode->i_state & I_DIRTY_DATASYNC))\r\ngoto out;\r\nerr = sync_inode_metadata(inode, 1);\r\nif (ret == 0)\r\nret = err;\r\nout:\r\ninode_unlock(inode);\r\nerr = file_check_and_advance_wb_err(file);\r\nif (ret == 0)\r\nret = err;\r\nreturn ret;\r\n}\r\nint generic_file_fsync(struct file *file, loff_t start, loff_t end,\r\nint datasync)\r\n{\r\nstruct inode *inode = file->f_mapping->host;\r\nint err;\r\nerr = __generic_file_fsync(file, start, end, datasync);\r\nif (err)\r\nreturn err;\r\nreturn blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);\r\n}\r\nint generic_check_addressable(unsigned blocksize_bits, u64 num_blocks)\r\n{\r\nu64 last_fs_block = num_blocks - 1;\r\nu64 last_fs_page =\r\nlast_fs_block >> (PAGE_SHIFT - blocksize_bits);\r\nif (unlikely(num_blocks == 0))\r\nreturn 0;\r\nif ((blocksize_bits < 9) || (blocksize_bits > PAGE_SHIFT))\r\nreturn -EINVAL;\r\nif ((last_fs_block > (sector_t)(~0ULL) >> (blocksize_bits - 9)) ||\r\n(last_fs_page > (pgoff_t)(~0ULL))) {\r\nreturn -EFBIG;\r\n}\r\nreturn 0;\r\n}\r\nint noop_fsync(struct file *file, loff_t start, loff_t end, int datasync)\r\n{\r\nreturn 0;\r\n}\r\nvoid kfree_link(void *p)\r\n{\r\nkfree(p);\r\n}\r\nstatic int anon_set_page_dirty(struct page *page)\r\n{\r\nreturn 0;\r\n}\r\nstruct inode *alloc_anon_inode(struct super_block *s)\r\n{\r\nstatic const struct address_space_operations anon_aops = {\r\n.set_page_dirty = anon_set_page_dirty,\r\n};\r\nstruct inode *inode = new_inode_pseudo(s);\r\nif (!inode)\r\nreturn ERR_PTR(-ENOMEM);\r\ninode->i_ino = get_next_ino();\r\ninode->i_mapping->a_ops = &anon_aops;\r\ninode->i_state = I_DIRTY;\r\ninode->i_mode = S_IRUSR | S_IWUSR;\r\ninode->i_uid = current_fsuid();\r\ninode->i_gid = current_fsgid();\r\ninode->i_flags |= S_PRIVATE;\r\ninode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\r\nreturn inode;\r\n}\r\nint\r\nsimple_nosetlease(struct file *filp, long arg, struct file_lock **flp,\r\nvoid **priv)\r\n{\r\nreturn -EINVAL;\r\n}\r\nconst char *simple_get_link(struct dentry *dentry, struct inode *inode,\r\nstruct delayed_call *done)\r\n{\r\nreturn inode->i_link;\r\n}\r\nstatic struct dentry *empty_dir_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\r\n{\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nstatic int empty_dir_getattr(const struct path *path, struct kstat *stat,\r\nu32 request_mask, unsigned int query_flags)\r\n{\r\nstruct inode *inode = d_inode(path->dentry);\r\ngeneric_fillattr(inode, stat);\r\nreturn 0;\r\n}\r\nstatic int empty_dir_setattr(struct dentry *dentry, struct iattr *attr)\r\n{\r\nreturn -EPERM;\r\n}\r\nstatic ssize_t empty_dir_listxattr(struct dentry *dentry, char *list, size_t size)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic loff_t empty_dir_llseek(struct file *file, loff_t offset, int whence)\r\n{\r\nreturn generic_file_llseek_size(file, offset, whence, 2, 2);\r\n}\r\nstatic int empty_dir_readdir(struct file *file, struct dir_context *ctx)\r\n{\r\ndir_emit_dots(file, ctx);\r\nreturn 0;\r\n}\r\nvoid make_empty_dir_inode(struct inode *inode)\r\n{\r\nset_nlink(inode, 2);\r\ninode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;\r\ninode->i_uid = GLOBAL_ROOT_UID;\r\ninode->i_gid = GLOBAL_ROOT_GID;\r\ninode->i_rdev = 0;\r\ninode->i_size = 0;\r\ninode->i_blkbits = PAGE_SHIFT;\r\ninode->i_blocks = 0;\r\ninode->i_op = &empty_dir_inode_operations;\r\ninode->i_opflags &= ~IOP_XATTR;\r\ninode->i_fop = &empty_dir_operations;\r\n}\r\nbool is_empty_dir_inode(struct inode *inode)\r\n{\r\nreturn (inode->i_fop == &empty_dir_operations) &&\r\n(inode->i_op == &empty_dir_inode_operations);\r\n}
