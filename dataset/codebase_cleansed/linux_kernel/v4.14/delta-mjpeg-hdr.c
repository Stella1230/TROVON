static char *header_str(struct mjpeg_header *header,\r\nchar *str,\r\nunsigned int len)\r\n{\r\nchar *cur = str;\r\nunsigned int left = len;\r\nif (!header)\r\nreturn "";\r\nsnprintf(cur, left, "[MJPEG header]\n"\r\n"|- length = %d\n"\r\n"|- precision = %d\n"\r\n"|- width = %d\n"\r\n"|- height = %d\n"\r\n"|- components = %d\n",\r\nheader->length,\r\nheader->sample_precision,\r\nheader->frame_width,\r\nheader->frame_height,\r\nheader->nb_of_components);\r\nreturn str;\r\n}\r\nstatic int delta_mjpeg_read_sof(struct delta_ctx *pctx,\r\nunsigned char *data, unsigned int size,\r\nstruct mjpeg_header *header)\r\n{\r\nstruct delta_dev *delta = pctx->dev;\r\nunsigned int offset = 0;\r\nif (size < 64)\r\ngoto err_no_more;\r\nmemset(header, 0, sizeof(*header));\r\nheader->length = be16_to_cpu(*(__be16 *)(data + offset));\r\noffset += sizeof(u16);\r\nheader->sample_precision = *(u8 *)(data + offset);\r\noffset += sizeof(u8);\r\nheader->frame_height = be16_to_cpu(*(__be16 *)(data + offset));\r\noffset += sizeof(u16);\r\nheader->frame_width = be16_to_cpu(*(__be16 *)(data + offset));\r\noffset += sizeof(u16);\r\nheader->nb_of_components = *(u8 *)(data + offset);\r\noffset += sizeof(u8);\r\nif (header->nb_of_components >= MJPEG_MAX_COMPONENTS) {\r\ndev_err(delta->dev,\r\n"%s unsupported number of components (%d > %d)\n",\r\npctx->name, header->nb_of_components,\r\nMJPEG_MAX_COMPONENTS);\r\nreturn -EINVAL;\r\n}\r\nif ((offset + header->nb_of_components *\r\nsizeof(header->components[0])) > size)\r\ngoto err_no_more;\r\nreturn 0;\r\nerr_no_more:\r\ndev_err(delta->dev,\r\n"%s sof: reached end of %d size input stream\n",\r\npctx->name, size);\r\nreturn -ENODATA;\r\n}\r\nint delta_mjpeg_read_header(struct delta_ctx *pctx,\r\nunsigned char *data, unsigned int size,\r\nstruct mjpeg_header *header,\r\nunsigned int *data_offset)\r\n{\r\nstruct delta_dev *delta = pctx->dev;\r\nunsigned char str[200];\r\nunsigned int ret = 0;\r\nunsigned int offset = 0;\r\nunsigned int soi = 0;\r\nif (size < 2)\r\ngoto err_no_more;\r\noffset = 0;\r\nwhile (1) {\r\nif (data[offset] == MJPEG_MARKER)\r\nswitch (data[offset + 1]) {\r\ncase MJPEG_SOI:\r\nsoi = 1;\r\n*data_offset = offset;\r\nbreak;\r\ncase MJPEG_SOF_0:\r\ncase MJPEG_SOF_1:\r\nif (!soi) {\r\ndev_err(delta->dev,\r\n"%s wrong sequence, got SOF while SOI not seen\n",\r\npctx->name);\r\nreturn -EINVAL;\r\n}\r\nret = delta_mjpeg_read_sof(pctx,\r\n&data[offset + 2],\r\nsize - (offset + 2),\r\nheader);\r\nif (ret)\r\ngoto err;\r\ngoto done;\r\ndefault:\r\nbreak;\r\n}\r\noffset++;\r\nif ((offset + 2) >= size)\r\ngoto err_no_more;\r\n}\r\ndone:\r\ndev_dbg(delta->dev,\r\n"%s found header @ offset %d:\n%s", pctx->name,\r\n*data_offset,\r\nheader_str(header, str, sizeof(str)));\r\nreturn 0;\r\nerr_no_more:\r\ndev_err(delta->dev,\r\n"%s no header found within %d bytes input stream\n",\r\npctx->name, size);\r\nreturn -ENODATA;\r\nerr:\r\nreturn ret;\r\n}
