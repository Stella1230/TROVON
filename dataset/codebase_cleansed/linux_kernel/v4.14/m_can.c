static inline u32 m_can_read(const struct m_can_priv *priv, enum m_can_reg reg)\r\n{\r\nreturn readl(priv->base + reg);\r\n}\r\nstatic inline void m_can_write(const struct m_can_priv *priv,\r\nenum m_can_reg reg, u32 val)\r\n{\r\nwritel(val, priv->base + reg);\r\n}\r\nstatic inline u32 m_can_fifo_read(const struct m_can_priv *priv,\r\nu32 fgi, unsigned int offset)\r\n{\r\nreturn readl(priv->mram_base + priv->mcfg[MRAM_RXF0].off +\r\nfgi * RXF0_ELEMENT_SIZE + offset);\r\n}\r\nstatic inline void m_can_fifo_write(const struct m_can_priv *priv,\r\nu32 fpi, unsigned int offset, u32 val)\r\n{\r\nwritel(val, priv->mram_base + priv->mcfg[MRAM_TXB].off +\r\nfpi * TXB_ELEMENT_SIZE + offset);\r\n}\r\nstatic inline u32 m_can_txe_fifo_read(const struct m_can_priv *priv,\r\nu32 fgi,\r\nu32 offset) {\r\nreturn readl(priv->mram_base + priv->mcfg[MRAM_TXE].off +\r\nfgi * TXE_ELEMENT_SIZE + offset);\r\n}\r\nstatic inline bool m_can_tx_fifo_full(const struct m_can_priv *priv)\r\n{\r\nreturn !!(m_can_read(priv, M_CAN_TXFQS) & TXFQS_TFQF);\r\n}\r\nstatic inline void m_can_config_endisable(const struct m_can_priv *priv,\r\nbool enable)\r\n{\r\nu32 cccr = m_can_read(priv, M_CAN_CCCR);\r\nu32 timeout = 10;\r\nu32 val = 0;\r\nif (enable) {\r\nm_can_write(priv, M_CAN_CCCR, cccr | CCCR_INIT);\r\nudelay(5);\r\nm_can_write(priv, M_CAN_CCCR, cccr | CCCR_INIT | CCCR_CCE);\r\n} else {\r\nm_can_write(priv, M_CAN_CCCR, cccr & ~(CCCR_INIT | CCCR_CCE));\r\n}\r\nif (enable)\r\nval = CCCR_INIT | CCCR_CCE;\r\nwhile ((m_can_read(priv, M_CAN_CCCR) & (CCCR_INIT | CCCR_CCE)) != val) {\r\nif (timeout == 0) {\r\nnetdev_warn(priv->dev, "Failed to init module\n");\r\nreturn;\r\n}\r\ntimeout--;\r\nudelay(1);\r\n}\r\n}\r\nstatic inline void m_can_enable_all_interrupts(const struct m_can_priv *priv)\r\n{\r\nm_can_write(priv, M_CAN_ILE, ILE_EINT0);\r\n}\r\nstatic inline void m_can_disable_all_interrupts(const struct m_can_priv *priv)\r\n{\r\nm_can_write(priv, M_CAN_ILE, 0x0);\r\n}\r\nstatic void m_can_read_fifo(struct net_device *dev, u32 rxfs)\r\n{\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nstruct canfd_frame *cf;\r\nstruct sk_buff *skb;\r\nu32 id, fgi, dlc;\r\nint i;\r\nfgi = (rxfs & RXFS_FGI_MASK) >> RXFS_FGI_SHIFT;\r\ndlc = m_can_fifo_read(priv, fgi, M_CAN_FIFO_DLC);\r\nif (dlc & RX_BUF_FDF)\r\nskb = alloc_canfd_skb(dev, &cf);\r\nelse\r\nskb = alloc_can_skb(dev, (struct can_frame **)&cf);\r\nif (!skb) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\nif (dlc & RX_BUF_FDF)\r\ncf->len = can_dlc2len((dlc >> 16) & 0x0F);\r\nelse\r\ncf->len = get_can_dlc((dlc >> 16) & 0x0F);\r\nid = m_can_fifo_read(priv, fgi, M_CAN_FIFO_ID);\r\nif (id & RX_BUF_XTD)\r\ncf->can_id = (id & CAN_EFF_MASK) | CAN_EFF_FLAG;\r\nelse\r\ncf->can_id = (id >> 18) & CAN_SFF_MASK;\r\nif (id & RX_BUF_ESI) {\r\ncf->flags |= CANFD_ESI;\r\nnetdev_dbg(dev, "ESI Error\n");\r\n}\r\nif (!(dlc & RX_BUF_FDF) && (id & RX_BUF_RTR)) {\r\ncf->can_id |= CAN_RTR_FLAG;\r\n} else {\r\nif (dlc & RX_BUF_BRS)\r\ncf->flags |= CANFD_BRS;\r\nfor (i = 0; i < cf->len; i += 4)\r\n*(u32 *)(cf->data + i) =\r\nm_can_fifo_read(priv, fgi,\r\nM_CAN_FIFO_DATA(i / 4));\r\n}\r\nm_can_write(priv, M_CAN_RXF0A, fgi);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->len;\r\nnetif_receive_skb(skb);\r\n}\r\nstatic int m_can_do_rx_poll(struct net_device *dev, int quota)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nu32 pkts = 0;\r\nu32 rxfs;\r\nrxfs = m_can_read(priv, M_CAN_RXF0S);\r\nif (!(rxfs & RXFS_FFL_MASK)) {\r\nnetdev_dbg(dev, "no messages in fifo0\n");\r\nreturn 0;\r\n}\r\nwhile ((rxfs & RXFS_FFL_MASK) && (quota > 0)) {\r\nif (rxfs & RXFS_RFL)\r\nnetdev_warn(dev, "Rx FIFO 0 Message Lost\n");\r\nm_can_read_fifo(dev, rxfs);\r\nquota--;\r\npkts++;\r\nrxfs = m_can_read(priv, M_CAN_RXF0S);\r\n}\r\nif (pkts)\r\ncan_led_event(dev, CAN_LED_EVENT_RX);\r\nreturn pkts;\r\n}\r\nstatic int m_can_handle_lost_msg(struct net_device *dev)\r\n{\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct sk_buff *skb;\r\nstruct can_frame *frame;\r\nnetdev_err(dev, "msg lost in rxf0\n");\r\nstats->rx_errors++;\r\nstats->rx_over_errors++;\r\nskb = alloc_can_err_skb(dev, &frame);\r\nif (unlikely(!skb))\r\nreturn 0;\r\nframe->can_id |= CAN_ERR_CRTL;\r\nframe->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nnetif_receive_skb(skb);\r\nreturn 1;\r\n}\r\nstatic int m_can_handle_lec_err(struct net_device *dev,\r\nenum m_can_lec_type lec_type)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\npriv->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (unlikely(!skb))\r\nreturn 0;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\nswitch (lec_type) {\r\ncase LEC_STUFF_ERROR:\r\nnetdev_dbg(dev, "stuff error\n");\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nbreak;\r\ncase LEC_FORM_ERROR:\r\nnetdev_dbg(dev, "form error\n");\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nbreak;\r\ncase LEC_ACK_ERROR:\r\nnetdev_dbg(dev, "ack error\n");\r\ncf->data[3] = CAN_ERR_PROT_LOC_ACK;\r\nbreak;\r\ncase LEC_BIT1_ERROR:\r\nnetdev_dbg(dev, "bit1 error\n");\r\ncf->data[2] |= CAN_ERR_PROT_BIT1;\r\nbreak;\r\ncase LEC_BIT0_ERROR:\r\nnetdev_dbg(dev, "bit0 error\n");\r\ncf->data[2] |= CAN_ERR_PROT_BIT0;\r\nbreak;\r\ncase LEC_CRC_ERROR:\r\nnetdev_dbg(dev, "CRC error\n");\r\ncf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_receive_skb(skb);\r\nreturn 1;\r\n}\r\nstatic int __m_can_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nunsigned int ecr;\r\necr = m_can_read(priv, M_CAN_ECR);\r\nbec->rxerr = (ecr & ECR_REC_MASK) >> ECR_REC_SHIFT;\r\nbec->txerr = (ecr & ECR_TEC_MASK) >> ECR_TEC_SHIFT;\r\nreturn 0;\r\n}\r\nstatic int m_can_clk_start(struct m_can_priv *priv)\r\n{\r\nint err;\r\nerr = clk_prepare_enable(priv->hclk);\r\nif (err)\r\nreturn err;\r\nerr = clk_prepare_enable(priv->cclk);\r\nif (err)\r\nclk_disable_unprepare(priv->hclk);\r\nreturn err;\r\n}\r\nstatic void m_can_clk_stop(struct m_can_priv *priv)\r\n{\r\nclk_disable_unprepare(priv->cclk);\r\nclk_disable_unprepare(priv->hclk);\r\n}\r\nstatic int m_can_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nint err;\r\nerr = m_can_clk_start(priv);\r\nif (err)\r\nreturn err;\r\n__m_can_get_berr_counter(dev, bec);\r\nm_can_clk_stop(priv);\r\nreturn 0;\r\n}\r\nstatic int m_can_handle_state_change(struct net_device *dev,\r\nenum can_state new_state)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nstruct can_berr_counter bec;\r\nunsigned int ecr;\r\nswitch (new_state) {\r\ncase CAN_STATE_ERROR_ACTIVE:\r\npriv->can.can_stats.error_warning++;\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\nbreak;\r\ncase CAN_STATE_ERROR_PASSIVE:\r\npriv->can.can_stats.error_passive++;\r\npriv->can.state = CAN_STATE_ERROR_PASSIVE;\r\nbreak;\r\ncase CAN_STATE_BUS_OFF:\r\npriv->can.state = CAN_STATE_BUS_OFF;\r\nm_can_disable_all_interrupts(priv);\r\npriv->can.can_stats.bus_off++;\r\ncan_bus_off(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (unlikely(!skb))\r\nreturn 0;\r\n__m_can_get_berr_counter(dev, &bec);\r\nswitch (new_state) {\r\ncase CAN_STATE_ERROR_ACTIVE:\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = (bec.txerr > bec.rxerr) ?\r\nCAN_ERR_CRTL_TX_WARNING :\r\nCAN_ERR_CRTL_RX_WARNING;\r\ncf->data[6] = bec.txerr;\r\ncf->data[7] = bec.rxerr;\r\nbreak;\r\ncase CAN_STATE_ERROR_PASSIVE:\r\ncf->can_id |= CAN_ERR_CRTL;\r\necr = m_can_read(priv, M_CAN_ECR);\r\nif (ecr & ECR_RP)\r\ncf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;\r\nif (bec.txerr > 127)\r\ncf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;\r\ncf->data[6] = bec.txerr;\r\ncf->data[7] = bec.rxerr;\r\nbreak;\r\ncase CAN_STATE_BUS_OFF:\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_receive_skb(skb);\r\nreturn 1;\r\n}\r\nstatic int m_can_handle_state_errors(struct net_device *dev, u32 psr)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nint work_done = 0;\r\nif ((psr & PSR_EW) &&\r\n(priv->can.state != CAN_STATE_ERROR_WARNING)) {\r\nnetdev_dbg(dev, "entered error warning state\n");\r\nwork_done += m_can_handle_state_change(dev,\r\nCAN_STATE_ERROR_WARNING);\r\n}\r\nif ((psr & PSR_EP) &&\r\n(priv->can.state != CAN_STATE_ERROR_PASSIVE)) {\r\nnetdev_dbg(dev, "entered error passive state\n");\r\nwork_done += m_can_handle_state_change(dev,\r\nCAN_STATE_ERROR_PASSIVE);\r\n}\r\nif ((psr & PSR_BO) &&\r\n(priv->can.state != CAN_STATE_BUS_OFF)) {\r\nnetdev_dbg(dev, "entered error bus off state\n");\r\nwork_done += m_can_handle_state_change(dev,\r\nCAN_STATE_BUS_OFF);\r\n}\r\nreturn work_done;\r\n}\r\nstatic void m_can_handle_other_err(struct net_device *dev, u32 irqstatus)\r\n{\r\nif (irqstatus & IR_WDI)\r\nnetdev_err(dev, "Message RAM Watchdog event due to missing READY\n");\r\nif (irqstatus & IR_ELO)\r\nnetdev_err(dev, "Error Logging Overflow\n");\r\nif (irqstatus & IR_BEU)\r\nnetdev_err(dev, "Bit Error Uncorrected\n");\r\nif (irqstatus & IR_BEC)\r\nnetdev_err(dev, "Bit Error Corrected\n");\r\nif (irqstatus & IR_TOO)\r\nnetdev_err(dev, "Timeout reached\n");\r\nif (irqstatus & IR_MRAF)\r\nnetdev_err(dev, "Message RAM access failure occurred\n");\r\n}\r\nstatic inline bool is_lec_err(u32 psr)\r\n{\r\npsr &= LEC_UNUSED;\r\nreturn psr && (psr != LEC_UNUSED);\r\n}\r\nstatic int m_can_handle_bus_errors(struct net_device *dev, u32 irqstatus,\r\nu32 psr)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nint work_done = 0;\r\nif (irqstatus & IR_RF0L)\r\nwork_done += m_can_handle_lost_msg(dev);\r\nif ((priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) &&\r\nis_lec_err(psr))\r\nwork_done += m_can_handle_lec_err(dev, psr & LEC_UNUSED);\r\nm_can_handle_other_err(dev, irqstatus);\r\nreturn work_done;\r\n}\r\nstatic int m_can_poll(struct napi_struct *napi, int quota)\r\n{\r\nstruct net_device *dev = napi->dev;\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nint work_done = 0;\r\nu32 irqstatus, psr;\r\nirqstatus = priv->irqstatus | m_can_read(priv, M_CAN_IR);\r\nif (!irqstatus)\r\ngoto end;\r\npsr = m_can_read(priv, M_CAN_PSR);\r\nif (irqstatus & IR_ERR_STATE)\r\nwork_done += m_can_handle_state_errors(dev, psr);\r\nif (irqstatus & IR_ERR_BUS_30X)\r\nwork_done += m_can_handle_bus_errors(dev, irqstatus, psr);\r\nif (irqstatus & IR_RF0N)\r\nwork_done += m_can_do_rx_poll(dev, (quota - work_done));\r\nif (work_done < quota) {\r\nnapi_complete_done(napi, work_done);\r\nm_can_enable_all_interrupts(priv);\r\n}\r\nend:\r\nreturn work_done;\r\n}\r\nstatic void m_can_echo_tx_event(struct net_device *dev)\r\n{\r\nu32 txe_count = 0;\r\nu32 m_can_txefs;\r\nu32 fgi = 0;\r\nint i = 0;\r\nunsigned int msg_mark;\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nm_can_txefs = m_can_read(priv, M_CAN_TXEFS);\r\ntxe_count = (m_can_txefs & TXEFS_EFFL_MASK)\r\n>> TXEFS_EFFL_SHIFT;\r\nfor (i = 0; i < txe_count; i++) {\r\nfgi = (m_can_read(priv, M_CAN_TXEFS) & TXEFS_EFGI_MASK)\r\n>> TXEFS_EFGI_SHIFT;\r\nmsg_mark = (m_can_txe_fifo_read(priv, fgi, 4) &\r\nTX_EVENT_MM_MASK) >> TX_EVENT_MM_SHIFT;\r\nm_can_write(priv, M_CAN_TXEFA, (TXEFA_EFAI_MASK &\r\n(fgi << TXEFA_EFAI_SHIFT)));\r\nstats->tx_bytes += can_get_echo_skb(dev, msg_mark);\r\nstats->tx_packets++;\r\n}\r\n}\r\nstatic irqreturn_t m_can_isr(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nu32 ir;\r\nir = m_can_read(priv, M_CAN_IR);\r\nif (!ir)\r\nreturn IRQ_NONE;\r\nif (ir & IR_ALL_INT)\r\nm_can_write(priv, M_CAN_IR, ir);\r\nif ((ir & IR_RF0N) || (ir & IR_ERR_ALL_30X)) {\r\npriv->irqstatus = ir;\r\nm_can_disable_all_interrupts(priv);\r\nnapi_schedule(&priv->napi);\r\n}\r\nif (priv->version == 30) {\r\nif (ir & IR_TC) {\r\nstats->tx_bytes += can_get_echo_skb(dev, 0);\r\nstats->tx_packets++;\r\ncan_led_event(dev, CAN_LED_EVENT_TX);\r\nnetif_wake_queue(dev);\r\n}\r\n} else {\r\nif (ir & IR_TEFN) {\r\nm_can_echo_tx_event(dev);\r\ncan_led_event(dev, CAN_LED_EVENT_TX);\r\nif (netif_queue_stopped(dev) &&\r\n!m_can_tx_fifo_full(priv))\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int m_can_set_bittiming(struct net_device *dev)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nconst struct can_bittiming *bt = &priv->can.bittiming;\r\nconst struct can_bittiming *dbt = &priv->can.data_bittiming;\r\nu16 brp, sjw, tseg1, tseg2;\r\nu32 reg_btp;\r\nbrp = bt->brp - 1;\r\nsjw = bt->sjw - 1;\r\ntseg1 = bt->prop_seg + bt->phase_seg1 - 1;\r\ntseg2 = bt->phase_seg2 - 1;\r\nreg_btp = (brp << NBTP_NBRP_SHIFT) | (sjw << NBTP_NSJW_SHIFT) |\r\n(tseg1 << NBTP_NTSEG1_SHIFT) | (tseg2 << NBTP_NTSEG2_SHIFT);\r\nm_can_write(priv, M_CAN_NBTP, reg_btp);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_FD) {\r\nbrp = dbt->brp - 1;\r\nsjw = dbt->sjw - 1;\r\ntseg1 = dbt->prop_seg + dbt->phase_seg1 - 1;\r\ntseg2 = dbt->phase_seg2 - 1;\r\nreg_btp = (brp << DBTP_DBRP_SHIFT) | (sjw << DBTP_DSJW_SHIFT) |\r\n(tseg1 << DBTP_DTSEG1_SHIFT) |\r\n(tseg2 << DBTP_DTSEG2_SHIFT);\r\nm_can_write(priv, M_CAN_DBTP, reg_btp);\r\n}\r\nreturn 0;\r\n}\r\nstatic void m_can_chip_config(struct net_device *dev)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nu32 cccr, test;\r\nm_can_config_endisable(priv, true);\r\nm_can_write(priv, M_CAN_RXESC, M_CAN_RXESC_64BYTES);\r\nm_can_write(priv, M_CAN_GFC, 0x0);\r\nif (priv->version == 30) {\r\nm_can_write(priv, M_CAN_TXBC, (1 << TXBC_NDTB_SHIFT) |\r\npriv->mcfg[MRAM_TXB].off);\r\n} else {\r\nm_can_write(priv, M_CAN_TXBC,\r\n(priv->mcfg[MRAM_TXB].num << TXBC_TFQS_SHIFT) |\r\n(priv->mcfg[MRAM_TXB].off));\r\n}\r\nm_can_write(priv, M_CAN_TXESC, TXESC_TBDS_64BYTES);\r\nif (priv->version == 30) {\r\nm_can_write(priv, M_CAN_TXEFC, (1 << TXEFC_EFS_SHIFT) |\r\npriv->mcfg[MRAM_TXE].off);\r\n} else {\r\nm_can_write(priv, M_CAN_TXEFC,\r\n((priv->mcfg[MRAM_TXE].num << TXEFC_EFS_SHIFT)\r\n& TXEFC_EFS_MASK) |\r\npriv->mcfg[MRAM_TXE].off);\r\n}\r\nm_can_write(priv, M_CAN_RXF0C,\r\n(priv->mcfg[MRAM_RXF0].num << RXFC_FS_SHIFT) |\r\npriv->mcfg[MRAM_RXF0].off);\r\nm_can_write(priv, M_CAN_RXF1C,\r\n(priv->mcfg[MRAM_RXF1].num << RXFC_FS_SHIFT) |\r\npriv->mcfg[MRAM_RXF1].off);\r\ncccr = m_can_read(priv, M_CAN_CCCR);\r\ntest = m_can_read(priv, M_CAN_TEST);\r\ntest &= ~TEST_LBCK;\r\nif (priv->version == 30) {\r\ncccr &= ~(CCCR_TEST | CCCR_MON |\r\n(CCCR_CMR_MASK << CCCR_CMR_SHIFT) |\r\n(CCCR_CME_MASK << CCCR_CME_SHIFT));\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_FD)\r\ncccr |= CCCR_CME_CANFD_BRS << CCCR_CME_SHIFT;\r\n} else {\r\ncccr &= ~(CCCR_TEST | CCCR_MON | CCCR_BRSE | CCCR_FDOE);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO)\r\ncccr |= CCCR_NISO;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_FD)\r\ncccr |= (CCCR_BRSE | CCCR_FDOE);\r\n}\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK) {\r\ncccr |= CCCR_TEST | CCCR_MON;\r\ntest |= TEST_LBCK;\r\n}\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\r\ncccr |= CCCR_MON;\r\nm_can_write(priv, M_CAN_CCCR, cccr);\r\nm_can_write(priv, M_CAN_TEST, test);\r\nm_can_write(priv, M_CAN_IR, IR_ALL_INT);\r\nif (!(priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING))\r\nif (priv->version == 30)\r\nm_can_write(priv, M_CAN_IE, IR_ALL_INT &\r\n~(IR_ERR_LEC_30X));\r\nelse\r\nm_can_write(priv, M_CAN_IE, IR_ALL_INT &\r\n~(IR_ERR_LEC_31X));\r\nelse\r\nm_can_write(priv, M_CAN_IE, IR_ALL_INT);\r\nm_can_write(priv, M_CAN_ILS, ILS_ALL_INT0);\r\nm_can_set_bittiming(dev);\r\nm_can_config_endisable(priv, false);\r\n}\r\nstatic void m_can_start(struct net_device *dev)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nm_can_chip_config(dev);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nm_can_enable_all_interrupts(priv);\r\n}\r\nstatic int m_can_set_mode(struct net_device *dev, enum can_mode mode)\r\n{\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nm_can_start(dev);\r\nnetif_wake_queue(dev);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_m_can_dev(struct net_device *dev)\r\n{\r\nfree_candev(dev);\r\n}\r\nstatic int m_can_check_core_release(void __iomem *m_can_base)\r\n{\r\nu32 crel_reg;\r\nu8 rel;\r\nu8 step;\r\nint res;\r\nstruct m_can_priv temp_priv = {\r\n.base = m_can_base\r\n};\r\ncrel_reg = m_can_read(&temp_priv, M_CAN_CREL);\r\nrel = (u8)((crel_reg & CREL_REL_MASK) >> CREL_REL_SHIFT);\r\nstep = (u8)((crel_reg & CREL_STEP_MASK) >> CREL_STEP_SHIFT);\r\nif (rel == 3) {\r\nres = 30 + step;\r\n} else {\r\nres = 0;\r\n}\r\nreturn res;\r\n}\r\nstatic bool m_can_niso_supported(const struct m_can_priv *priv)\r\n{\r\nu32 cccr_reg, cccr_poll;\r\nint niso_timeout;\r\nm_can_config_endisable(priv, true);\r\ncccr_reg = m_can_read(priv, M_CAN_CCCR);\r\ncccr_reg |= CCCR_NISO;\r\nm_can_write(priv, M_CAN_CCCR, cccr_reg);\r\nniso_timeout = readl_poll_timeout((priv->base + M_CAN_CCCR), cccr_poll,\r\n(cccr_poll == cccr_reg), 0, 10);\r\ncccr_reg &= ~(CCCR_NISO);\r\nm_can_write(priv, M_CAN_CCCR, cccr_reg);\r\nm_can_config_endisable(priv, false);\r\nreturn !niso_timeout;\r\n}\r\nstatic struct net_device *alloc_m_can_dev(struct platform_device *pdev,\r\nvoid __iomem *addr, u32 tx_fifo_size)\r\n{\r\nstruct net_device *dev;\r\nstruct m_can_priv *priv;\r\nint m_can_version;\r\nunsigned int echo_buffer_count;\r\nm_can_version = m_can_check_core_release(addr);\r\nif (!m_can_version) {\r\ndev = NULL;\r\ngoto return_dev;\r\n}\r\necho_buffer_count = ((m_can_version == 30)\r\n? 1U\r\n: (unsigned int)tx_fifo_size);\r\ndev = alloc_candev(sizeof(*priv), echo_buffer_count);\r\nif (!dev) {\r\ndev = NULL;\r\ngoto return_dev;\r\n}\r\npriv = netdev_priv(dev);\r\nnetif_napi_add(dev, &priv->napi, m_can_poll, M_CAN_NAPI_WEIGHT);\r\npriv->version = m_can_version;\r\npriv->dev = dev;\r\npriv->base = addr;\r\npriv->can.do_set_mode = m_can_set_mode;\r\npriv->can.do_get_berr_counter = m_can_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\r\nCAN_CTRLMODE_LISTENONLY |\r\nCAN_CTRLMODE_BERR_REPORTING |\r\nCAN_CTRLMODE_FD;\r\nswitch (priv->version) {\r\ncase 30:\r\ncan_set_static_ctrlmode(dev, CAN_CTRLMODE_FD_NON_ISO);\r\npriv->can.bittiming_const = &m_can_bittiming_const_30X;\r\npriv->can.data_bittiming_const =\r\n&m_can_data_bittiming_const_30X;\r\nbreak;\r\ncase 31:\r\ncan_set_static_ctrlmode(dev, CAN_CTRLMODE_FD_NON_ISO);\r\npriv->can.bittiming_const = &m_can_bittiming_const_31X;\r\npriv->can.data_bittiming_const =\r\n&m_can_data_bittiming_const_31X;\r\nbreak;\r\ncase 32:\r\npriv->can.bittiming_const = &m_can_bittiming_const_31X;\r\npriv->can.data_bittiming_const =\r\n&m_can_data_bittiming_const_31X;\r\npriv->can.ctrlmode_supported |= (m_can_niso_supported(priv)\r\n? CAN_CTRLMODE_FD_NON_ISO\r\n: 0);\r\nbreak;\r\ndefault:\r\nfree_m_can_dev(dev);\r\ndev_err(&pdev->dev, "Unsupported version number: %2d",\r\npriv->version);\r\ndev = NULL;\r\nbreak;\r\n}\r\nreturn_dev:\r\nreturn dev;\r\n}\r\nstatic int m_can_open(struct net_device *dev)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nint err;\r\nerr = m_can_clk_start(priv);\r\nif (err)\r\nreturn err;\r\nerr = open_candev(dev);\r\nif (err) {\r\nnetdev_err(dev, "failed to open can device\n");\r\ngoto exit_disable_clks;\r\n}\r\nerr = request_irq(dev->irq, m_can_isr, IRQF_SHARED, dev->name,\r\ndev);\r\nif (err < 0) {\r\nnetdev_err(dev, "failed to request interrupt\n");\r\ngoto exit_irq_fail;\r\n}\r\nm_can_start(dev);\r\ncan_led_event(dev, CAN_LED_EVENT_OPEN);\r\nnapi_enable(&priv->napi);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nexit_irq_fail:\r\nclose_candev(dev);\r\nexit_disable_clks:\r\nm_can_clk_stop(priv);\r\nreturn err;\r\n}\r\nstatic void m_can_stop(struct net_device *dev)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nm_can_disable_all_interrupts(priv);\r\npriv->can.state = CAN_STATE_STOPPED;\r\n}\r\nstatic int m_can_close(struct net_device *dev)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&priv->napi);\r\nm_can_stop(dev);\r\nm_can_clk_stop(priv);\r\nfree_irq(dev->irq, dev);\r\nclose_candev(dev);\r\ncan_led_event(dev, CAN_LED_EVENT_STOP);\r\nreturn 0;\r\n}\r\nstatic int m_can_next_echo_skb_occupied(struct net_device *dev, int putidx)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nunsigned int wrap = priv->can.echo_skb_max;\r\nint next_idx;\r\nnext_idx = (++putidx >= wrap ? 0 : putidx);\r\nreturn !!priv->can.echo_skb[next_idx];\r\n}\r\nstatic netdev_tx_t m_can_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct m_can_priv *priv = netdev_priv(dev);\r\nstruct canfd_frame *cf = (struct canfd_frame *)skb->data;\r\nu32 id, cccr, fdflags;\r\nint i;\r\nint putidx;\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\nid = cf->can_id & CAN_EFF_MASK;\r\nid |= TX_BUF_XTD;\r\n} else {\r\nid = ((cf->can_id & CAN_SFF_MASK) << 18);\r\n}\r\nif (cf->can_id & CAN_RTR_FLAG)\r\nid |= TX_BUF_RTR;\r\nif (priv->version == 30) {\r\nnetif_stop_queue(dev);\r\nm_can_fifo_write(priv, 0, M_CAN_FIFO_ID, id);\r\nm_can_fifo_write(priv, 0, M_CAN_FIFO_DLC,\r\ncan_len2dlc(cf->len) << 16);\r\nfor (i = 0; i < cf->len; i += 4)\r\nm_can_fifo_write(priv, 0,\r\nM_CAN_FIFO_DATA(i / 4),\r\n*(u32 *)(cf->data + i));\r\ncan_put_echo_skb(skb, dev, 0);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_FD) {\r\ncccr = m_can_read(priv, M_CAN_CCCR);\r\ncccr &= ~(CCCR_CMR_MASK << CCCR_CMR_SHIFT);\r\nif (can_is_canfd_skb(skb)) {\r\nif (cf->flags & CANFD_BRS)\r\ncccr |= CCCR_CMR_CANFD_BRS <<\r\nCCCR_CMR_SHIFT;\r\nelse\r\ncccr |= CCCR_CMR_CANFD <<\r\nCCCR_CMR_SHIFT;\r\n} else {\r\ncccr |= CCCR_CMR_CAN << CCCR_CMR_SHIFT;\r\n}\r\nm_can_write(priv, M_CAN_CCCR, cccr);\r\n}\r\nm_can_write(priv, M_CAN_TXBTIE, 0x1);\r\nm_can_write(priv, M_CAN_TXBAR, 0x1);\r\n} else {\r\nif (m_can_tx_fifo_full(priv)) {\r\nnetif_stop_queue(dev);\r\nnetdev_warn(dev,\r\n"TX queue active although FIFO is full.");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nputidx = ((m_can_read(priv, M_CAN_TXFQS) & TXFQS_TFQPI_MASK)\r\n>> TXFQS_TFQPI_SHIFT);\r\nm_can_fifo_write(priv, putidx, M_CAN_FIFO_ID, id);\r\nfdflags = 0;\r\nif (can_is_canfd_skb(skb)) {\r\nfdflags |= TX_BUF_FDF;\r\nif (cf->flags & CANFD_BRS)\r\nfdflags |= TX_BUF_BRS;\r\n}\r\nm_can_fifo_write(priv, putidx, M_CAN_FIFO_DLC,\r\n((putidx << TX_BUF_MM_SHIFT) &\r\nTX_BUF_MM_MASK) |\r\n(can_len2dlc(cf->len) << 16) |\r\nfdflags | TX_BUF_EFC);\r\nfor (i = 0; i < cf->len; i += 4)\r\nm_can_fifo_write(priv, putidx, M_CAN_FIFO_DATA(i / 4),\r\n*(u32 *)(cf->data + i));\r\ncan_put_echo_skb(skb, dev, putidx);\r\nm_can_write(priv, M_CAN_TXBAR, (1 << putidx));\r\nif (m_can_tx_fifo_full(priv) ||\r\nm_can_next_echo_skb_occupied(dev, putidx))\r\nnetif_stop_queue(dev);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int register_m_can_dev(struct net_device *dev)\r\n{\r\ndev->flags |= IFF_ECHO;\r\ndev->netdev_ops = &m_can_netdev_ops;\r\nreturn register_candev(dev);\r\n}\r\nstatic void m_can_init_ram(struct m_can_priv *priv)\r\n{\r\nint end, i, start;\r\nstart = priv->mcfg[MRAM_SIDF].off;\r\nend = priv->mcfg[MRAM_TXB].off +\r\npriv->mcfg[MRAM_TXB].num * TXB_ELEMENT_SIZE;\r\nfor (i = start; i < end; i += 4)\r\nwritel(0x0, priv->mram_base + i);\r\n}\r\nstatic void m_can_of_parse_mram(struct m_can_priv *priv,\r\nconst u32 *mram_config_vals)\r\n{\r\npriv->mcfg[MRAM_SIDF].off = mram_config_vals[0];\r\npriv->mcfg[MRAM_SIDF].num = mram_config_vals[1];\r\npriv->mcfg[MRAM_XIDF].off = priv->mcfg[MRAM_SIDF].off +\r\npriv->mcfg[MRAM_SIDF].num * SIDF_ELEMENT_SIZE;\r\npriv->mcfg[MRAM_XIDF].num = mram_config_vals[2];\r\npriv->mcfg[MRAM_RXF0].off = priv->mcfg[MRAM_XIDF].off +\r\npriv->mcfg[MRAM_XIDF].num * XIDF_ELEMENT_SIZE;\r\npriv->mcfg[MRAM_RXF0].num = mram_config_vals[3] &\r\n(RXFC_FS_MASK >> RXFC_FS_SHIFT);\r\npriv->mcfg[MRAM_RXF1].off = priv->mcfg[MRAM_RXF0].off +\r\npriv->mcfg[MRAM_RXF0].num * RXF0_ELEMENT_SIZE;\r\npriv->mcfg[MRAM_RXF1].num = mram_config_vals[4] &\r\n(RXFC_FS_MASK >> RXFC_FS_SHIFT);\r\npriv->mcfg[MRAM_RXB].off = priv->mcfg[MRAM_RXF1].off +\r\npriv->mcfg[MRAM_RXF1].num * RXF1_ELEMENT_SIZE;\r\npriv->mcfg[MRAM_RXB].num = mram_config_vals[5];\r\npriv->mcfg[MRAM_TXE].off = priv->mcfg[MRAM_RXB].off +\r\npriv->mcfg[MRAM_RXB].num * RXB_ELEMENT_SIZE;\r\npriv->mcfg[MRAM_TXE].num = mram_config_vals[6];\r\npriv->mcfg[MRAM_TXB].off = priv->mcfg[MRAM_TXE].off +\r\npriv->mcfg[MRAM_TXE].num * TXE_ELEMENT_SIZE;\r\npriv->mcfg[MRAM_TXB].num = mram_config_vals[7] &\r\n(TXBC_NDTB_MASK >> TXBC_NDTB_SHIFT);\r\ndev_dbg(priv->device,\r\n"mram_base %p sidf 0x%x %d xidf 0x%x %d rxf0 0x%x %d rxf1 0x%x %d rxb 0x%x %d txe 0x%x %d txb 0x%x %d\n",\r\npriv->mram_base,\r\npriv->mcfg[MRAM_SIDF].off, priv->mcfg[MRAM_SIDF].num,\r\npriv->mcfg[MRAM_XIDF].off, priv->mcfg[MRAM_XIDF].num,\r\npriv->mcfg[MRAM_RXF0].off, priv->mcfg[MRAM_RXF0].num,\r\npriv->mcfg[MRAM_RXF1].off, priv->mcfg[MRAM_RXF1].num,\r\npriv->mcfg[MRAM_RXB].off, priv->mcfg[MRAM_RXB].num,\r\npriv->mcfg[MRAM_TXE].off, priv->mcfg[MRAM_TXE].num,\r\npriv->mcfg[MRAM_TXB].off, priv->mcfg[MRAM_TXB].num);\r\nm_can_init_ram(priv);\r\n}\r\nstatic int m_can_plat_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct m_can_priv *priv;\r\nstruct resource *res;\r\nvoid __iomem *addr;\r\nvoid __iomem *mram_addr;\r\nstruct clk *hclk, *cclk;\r\nint irq, ret;\r\nstruct device_node *np;\r\nu32 mram_config_vals[MRAM_CFG_LEN];\r\nu32 tx_fifo_size;\r\nnp = pdev->dev.of_node;\r\nhclk = devm_clk_get(&pdev->dev, "hclk");\r\ncclk = devm_clk_get(&pdev->dev, "cclk");\r\nif (IS_ERR(hclk) || IS_ERR(cclk)) {\r\ndev_err(&pdev->dev, "no clock found\n");\r\nret = -ENODEV;\r\ngoto failed_ret;\r\n}\r\nret = clk_prepare_enable(hclk);\r\nif (ret)\r\ngoto disable_hclk_ret;\r\nret = clk_prepare_enable(cclk);\r\nif (ret)\r\ngoto disable_cclk_ret;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "m_can");\r\naddr = devm_ioremap_resource(&pdev->dev, res);\r\nirq = platform_get_irq_byname(pdev, "int0");\r\nif (IS_ERR(addr) || irq < 0) {\r\nret = -EINVAL;\r\ngoto disable_cclk_ret;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "message_ram");\r\nif (!res) {\r\nret = -ENODEV;\r\ngoto disable_cclk_ret;\r\n}\r\nmram_addr = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (!mram_addr) {\r\nret = -ENOMEM;\r\ngoto disable_cclk_ret;\r\n}\r\nret = of_property_read_u32_array(np, "bosch,mram-cfg",\r\nmram_config_vals,\r\nsizeof(mram_config_vals) / 4);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not get Message RAM configuration.");\r\ngoto disable_cclk_ret;\r\n}\r\ntx_fifo_size = mram_config_vals[7];\r\ndev = alloc_m_can_dev(pdev, addr, tx_fifo_size);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto disable_cclk_ret;\r\n}\r\npriv = netdev_priv(dev);\r\ndev->irq = irq;\r\npriv->device = &pdev->dev;\r\npriv->hclk = hclk;\r\npriv->cclk = cclk;\r\npriv->can.clock.freq = clk_get_rate(cclk);\r\npriv->mram_base = mram_addr;\r\nm_can_of_parse_mram(priv, mram_config_vals);\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nret = register_m_can_dev(dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "registering %s failed (err=%d)\n",\r\nKBUILD_MODNAME, ret);\r\ngoto failed_free_dev;\r\n}\r\ndevm_can_led_init(dev);\r\ndev_info(&pdev->dev, "%s device registered (irq=%d, version=%d)\n",\r\nKBUILD_MODNAME, dev->irq, priv->version);\r\ngoto disable_cclk_ret;\r\nfailed_free_dev:\r\nfree_m_can_dev(dev);\r\ndisable_cclk_ret:\r\nclk_disable_unprepare(cclk);\r\ndisable_hclk_ret:\r\nclk_disable_unprepare(hclk);\r\nfailed_ret:\r\nreturn ret;\r\n}\r\nstatic __maybe_unused int m_can_suspend(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct m_can_priv *priv = netdev_priv(ndev);\r\nif (netif_running(ndev)) {\r\nnetif_stop_queue(ndev);\r\nnetif_device_detach(ndev);\r\nm_can_stop(ndev);\r\nm_can_clk_stop(priv);\r\n}\r\npriv->can.state = CAN_STATE_SLEEPING;\r\nreturn 0;\r\n}\r\nstatic __maybe_unused int m_can_resume(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct m_can_priv *priv = netdev_priv(ndev);\r\nm_can_init_ram(priv);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nif (netif_running(ndev)) {\r\nint ret;\r\nret = m_can_clk_start(priv);\r\nif (ret)\r\nreturn ret;\r\nm_can_start(ndev);\r\nnetif_device_attach(ndev);\r\nnetif_start_queue(ndev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void unregister_m_can_dev(struct net_device *dev)\r\n{\r\nunregister_candev(dev);\r\n}\r\nstatic int m_can_plat_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nunregister_m_can_dev(dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_m_can_dev(dev);\r\nreturn 0;\r\n}
