static bool cros_ec_keyb_has_ghosting(struct cros_ec_keyb *ckdev, uint8_t *buf)\r\n{\r\nint col1, col2, buf1, buf2;\r\nstruct device *dev = ckdev->dev;\r\nuint8_t *valid_keys = ckdev->valid_keys;\r\nfor (col1 = 0; col1 < ckdev->cols; col1++) {\r\nbuf1 = buf[col1] & valid_keys[col1];\r\nfor (col2 = col1 + 1; col2 < ckdev->cols; col2++) {\r\nbuf2 = buf[col2] & valid_keys[col2];\r\nif (hweight8(buf1 & buf2) > 1) {\r\ndev_dbg(dev, "ghost found at: B[%02d]:0x%02x & B[%02d]:0x%02x",\r\ncol1, buf1, col2, buf2);\r\nreturn true;\r\n}\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic void cros_ec_keyb_process(struct cros_ec_keyb *ckdev,\r\nuint8_t *kb_state, int len)\r\n{\r\nstruct input_dev *idev = ckdev->idev;\r\nint col, row;\r\nint new_state;\r\nint old_state;\r\nint num_cols;\r\nnum_cols = len;\r\nif (ckdev->ghost_filter && cros_ec_keyb_has_ghosting(ckdev, kb_state)) {\r\ndev_dbg(ckdev->dev, "ghosting found\n");\r\nreturn;\r\n}\r\nfor (col = 0; col < ckdev->cols; col++) {\r\nfor (row = 0; row < ckdev->rows; row++) {\r\nint pos = MATRIX_SCAN_CODE(row, col, ckdev->row_shift);\r\nconst unsigned short *keycodes = idev->keycode;\r\nnew_state = kb_state[col] & (1 << row);\r\nold_state = ckdev->old_kb_state[col] & (1 << row);\r\nif (new_state != old_state) {\r\ndev_dbg(ckdev->dev,\r\n"changed: [r%d c%d]: byte %02x\n",\r\nrow, col, new_state);\r\ninput_report_key(idev, keycodes[pos],\r\nnew_state);\r\n}\r\n}\r\nckdev->old_kb_state[col] = kb_state[col];\r\n}\r\ninput_sync(ckdev->idev);\r\n}\r\nstatic void cros_ec_keyb_report_bs(struct cros_ec_keyb *ckdev,\r\nunsigned int ev_type, u32 mask)\r\n{\r\nstruct input_dev *idev = ckdev->bs_idev;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cros_ec_keyb_bs); i++) {\r\nconst struct cros_ec_bs_map *map = &cros_ec_keyb_bs[i];\r\nif (map->ev_type != ev_type)\r\ncontinue;\r\ninput_event(idev, ev_type, map->code,\r\n!!(mask & BIT(map->bit)) ^ map->inverted);\r\n}\r\ninput_sync(idev);\r\n}\r\nstatic int cros_ec_keyb_work(struct notifier_block *nb,\r\nunsigned long queued_during_suspend, void *_notify)\r\n{\r\nstruct cros_ec_keyb *ckdev = container_of(nb, struct cros_ec_keyb,\r\nnotifier);\r\nu32 val;\r\nunsigned int ev_type;\r\nswitch (ckdev->ec->event_data.event_type) {\r\ncase EC_MKBP_EVENT_KEY_MATRIX:\r\nif (queued_during_suspend)\r\nreturn NOTIFY_OK;\r\nif (ckdev->ec->event_size != ckdev->cols) {\r\ndev_err(ckdev->dev,\r\n"Discarded incomplete key matrix event.\n");\r\nreturn NOTIFY_OK;\r\n}\r\ncros_ec_keyb_process(ckdev,\r\nckdev->ec->event_data.data.key_matrix,\r\nckdev->ec->event_size);\r\nbreak;\r\ncase EC_MKBP_EVENT_SYSRQ:\r\nval = get_unaligned_le32(&ckdev->ec->event_data.data.sysrq);\r\ndev_dbg(ckdev->dev, "sysrq code from EC: %#x\n", val);\r\nhandle_sysrq(val);\r\nbreak;\r\ncase EC_MKBP_EVENT_BUTTON:\r\ncase EC_MKBP_EVENT_SWITCH:\r\nif (queued_during_suspend)\r\nreturn NOTIFY_OK;\r\nif (ckdev->ec->event_data.event_type == EC_MKBP_EVENT_BUTTON) {\r\nval = get_unaligned_le32(\r\n&ckdev->ec->event_data.data.buttons);\r\nev_type = EV_KEY;\r\n} else {\r\nval = get_unaligned_le32(\r\n&ckdev->ec->event_data.data.switches);\r\nev_type = EV_SW;\r\n}\r\ncros_ec_keyb_report_bs(ckdev, ev_type, val);\r\nbreak;\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void cros_ec_keyb_compute_valid_keys(struct cros_ec_keyb *ckdev)\r\n{\r\nint row, col;\r\nint row_shift = ckdev->row_shift;\r\nunsigned short *keymap = ckdev->idev->keycode;\r\nunsigned short code;\r\nBUG_ON(ckdev->idev->keycodesize != sizeof(*keymap));\r\nfor (col = 0; col < ckdev->cols; col++) {\r\nfor (row = 0; row < ckdev->rows; row++) {\r\ncode = keymap[MATRIX_SCAN_CODE(row, col, row_shift)];\r\nif (code && (code != KEY_BATTERY))\r\nckdev->valid_keys[col] |= 1 << row;\r\n}\r\ndev_dbg(ckdev->dev, "valid_keys[%02d] = 0x%02x\n",\r\ncol, ckdev->valid_keys[col]);\r\n}\r\n}\r\nstatic int cros_ec_keyb_info(struct cros_ec_device *ec_dev,\r\nenum ec_mkbp_info_type info_type,\r\nenum ec_mkbp_event event_type,\r\nunion ec_response_get_next_data *result,\r\nsize_t result_size)\r\n{\r\nstruct ec_params_mkbp_info *params;\r\nstruct cros_ec_command *msg;\r\nint ret;\r\nmsg = kzalloc(sizeof(*msg) + max_t(size_t, result_size,\r\nsizeof(*params)), GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->command = EC_CMD_MKBP_INFO;\r\nmsg->version = 1;\r\nmsg->outsize = sizeof(*params);\r\nmsg->insize = result_size;\r\nparams = (struct ec_params_mkbp_info *)msg->data;\r\nparams->info_type = info_type;\r\nparams->event_type = event_type;\r\nret = cros_ec_cmd_xfer(ec_dev, msg);\r\nif (ret < 0) {\r\ndev_warn(ec_dev->dev, "Transfer error %d/%d: %d\n",\r\n(int)info_type, (int)event_type, ret);\r\n} else if (msg->result == EC_RES_INVALID_VERSION) {\r\nmemset(result, 0, result_size);\r\nret = 0;\r\n} else if (msg->result != EC_RES_SUCCESS) {\r\ndev_warn(ec_dev->dev, "Error getting info %d/%d: %d\n",\r\n(int)info_type, (int)event_type, msg->result);\r\nret = -EPROTO;\r\n} else if (ret != result_size) {\r\ndev_warn(ec_dev->dev, "Wrong size %d/%d: %d != %zu\n",\r\n(int)info_type, (int)event_type,\r\nret, result_size);\r\nret = -EPROTO;\r\n} else {\r\nmemcpy(result, msg->data, result_size);\r\nret = 0;\r\n}\r\nkfree(msg);\r\nreturn ret;\r\n}\r\nstatic int cros_ec_keyb_query_switches(struct cros_ec_keyb *ckdev)\r\n{\r\nstruct cros_ec_device *ec_dev = ckdev->ec;\r\nunion ec_response_get_next_data event_data = {};\r\nint ret;\r\nret = cros_ec_keyb_info(ec_dev, EC_MKBP_INFO_CURRENT,\r\nEC_MKBP_EVENT_SWITCH, &event_data,\r\nsizeof(event_data.switches));\r\nif (ret)\r\nreturn ret;\r\ncros_ec_keyb_report_bs(ckdev, EV_SW,\r\nget_unaligned_le32(&event_data.switches));\r\nreturn 0;\r\n}\r\nstatic __maybe_unused int cros_ec_keyb_resume(struct device *dev)\r\n{\r\nstruct cros_ec_keyb *ckdev = dev_get_drvdata(dev);\r\nif (ckdev->bs_idev)\r\nreturn cros_ec_keyb_query_switches(ckdev);\r\nreturn 0;\r\n}\r\nstatic int cros_ec_keyb_register_bs(struct cros_ec_keyb *ckdev)\r\n{\r\nstruct cros_ec_device *ec_dev = ckdev->ec;\r\nstruct device *dev = ckdev->dev;\r\nstruct input_dev *idev;\r\nunion ec_response_get_next_data event_data = {};\r\nconst char *phys;\r\nu32 buttons;\r\nu32 switches;\r\nint ret;\r\nint i;\r\nret = cros_ec_keyb_info(ec_dev, EC_MKBP_INFO_SUPPORTED,\r\nEC_MKBP_EVENT_BUTTON, &event_data,\r\nsizeof(event_data.buttons));\r\nif (ret)\r\nreturn ret;\r\nbuttons = get_unaligned_le32(&event_data.buttons);\r\nret = cros_ec_keyb_info(ec_dev, EC_MKBP_INFO_SUPPORTED,\r\nEC_MKBP_EVENT_SWITCH, &event_data,\r\nsizeof(event_data.switches));\r\nif (ret)\r\nreturn ret;\r\nswitches = get_unaligned_le32(&event_data.switches);\r\nif (!buttons && !switches)\r\nreturn 0;\r\nphys = devm_kasprintf(dev, GFP_KERNEL, "%s/input1", ec_dev->phys_name);\r\nif (!phys)\r\nreturn -ENOMEM;\r\nidev = devm_input_allocate_device(dev);\r\nif (!idev)\r\nreturn -ENOMEM;\r\nidev->name = "cros_ec_buttons";\r\nidev->phys = phys;\r\n__set_bit(EV_REP, idev->evbit);\r\nidev->id.bustype = BUS_VIRTUAL;\r\nidev->id.version = 1;\r\nidev->id.product = 0;\r\nidev->dev.parent = dev;\r\ninput_set_drvdata(idev, ckdev);\r\nckdev->bs_idev = idev;\r\nfor (i = 0; i < ARRAY_SIZE(cros_ec_keyb_bs); i++) {\r\nconst struct cros_ec_bs_map *map = &cros_ec_keyb_bs[i];\r\nif (buttons & BIT(map->bit))\r\ninput_set_capability(idev, map->ev_type, map->code);\r\n}\r\nret = cros_ec_keyb_query_switches(ckdev);\r\nif (ret) {\r\ndev_err(dev, "cannot query switches\n");\r\nreturn ret;\r\n}\r\nret = input_register_device(ckdev->bs_idev);\r\nif (ret) {\r\ndev_err(dev, "cannot register input device\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cros_ec_keyb_register_matrix(struct cros_ec_keyb *ckdev)\r\n{\r\nstruct cros_ec_device *ec_dev = ckdev->ec;\r\nstruct device *dev = ckdev->dev;\r\nstruct input_dev *idev;\r\nconst char *phys;\r\nint err;\r\nerr = matrix_keypad_parse_properties(dev, &ckdev->rows, &ckdev->cols);\r\nif (err)\r\nreturn err;\r\nckdev->valid_keys = devm_kzalloc(dev, ckdev->cols, GFP_KERNEL);\r\nif (!ckdev->valid_keys)\r\nreturn -ENOMEM;\r\nckdev->old_kb_state = devm_kzalloc(dev, ckdev->cols, GFP_KERNEL);\r\nif (!ckdev->old_kb_state)\r\nreturn -ENOMEM;\r\nphys = devm_kasprintf(dev, GFP_KERNEL, "%s/input0", ec_dev->phys_name);\r\nif (!phys)\r\nreturn -ENOMEM;\r\nidev = devm_input_allocate_device(dev);\r\nif (!idev)\r\nreturn -ENOMEM;\r\nidev->name = CROS_EC_DEV_NAME;\r\nidev->phys = phys;\r\n__set_bit(EV_REP, idev->evbit);\r\nidev->id.bustype = BUS_VIRTUAL;\r\nidev->id.version = 1;\r\nidev->id.product = 0;\r\nidev->dev.parent = dev;\r\nckdev->ghost_filter = of_property_read_bool(dev->of_node,\r\n"google,needs-ghost-filter");\r\nerr = matrix_keypad_build_keymap(NULL, NULL, ckdev->rows, ckdev->cols,\r\nNULL, idev);\r\nif (err) {\r\ndev_err(dev, "cannot build key matrix\n");\r\nreturn err;\r\n}\r\nckdev->row_shift = get_count_order(ckdev->cols);\r\ninput_set_capability(idev, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(idev, ckdev);\r\nckdev->idev = idev;\r\ncros_ec_keyb_compute_valid_keys(ckdev);\r\nerr = input_register_device(ckdev->idev);\r\nif (err) {\r\ndev_err(dev, "cannot register input device\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cros_ec_keyb_probe(struct platform_device *pdev)\r\n{\r\nstruct cros_ec_device *ec = dev_get_drvdata(pdev->dev.parent);\r\nstruct device *dev = &pdev->dev;\r\nstruct cros_ec_keyb *ckdev;\r\nint err;\r\nif (!dev->of_node)\r\nreturn -ENODEV;\r\nckdev = devm_kzalloc(dev, sizeof(*ckdev), GFP_KERNEL);\r\nif (!ckdev)\r\nreturn -ENOMEM;\r\nckdev->ec = ec;\r\nckdev->dev = dev;\r\ndev_set_drvdata(dev, ckdev);\r\nerr = cros_ec_keyb_register_matrix(ckdev);\r\nif (err) {\r\ndev_err(dev, "cannot register matrix inputs: %d\n", err);\r\nreturn err;\r\n}\r\nerr = cros_ec_keyb_register_bs(ckdev);\r\nif (err) {\r\ndev_err(dev, "cannot register non-matrix inputs: %d\n", err);\r\nreturn err;\r\n}\r\nckdev->notifier.notifier_call = cros_ec_keyb_work;\r\nerr = blocking_notifier_chain_register(&ckdev->ec->event_notifier,\r\n&ckdev->notifier);\r\nif (err) {\r\ndev_err(dev, "cannot register notifier: %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cros_ec_keyb_remove(struct platform_device *pdev)\r\n{\r\nstruct cros_ec_keyb *ckdev = dev_get_drvdata(&pdev->dev);\r\nblocking_notifier_chain_unregister(&ckdev->ec->event_notifier,\r\n&ckdev->notifier);\r\nreturn 0;\r\n}
