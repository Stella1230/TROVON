static int hns_roce_pd_alloc(struct hns_roce_dev *hr_dev, unsigned long *pdn)\r\n{\r\nreturn hns_roce_bitmap_alloc(&hr_dev->pd_bitmap, pdn);\r\n}\r\nstatic void hns_roce_pd_free(struct hns_roce_dev *hr_dev, unsigned long pdn)\r\n{\r\nhns_roce_bitmap_free(&hr_dev->pd_bitmap, pdn, BITMAP_NO_RR);\r\n}\r\nint hns_roce_init_pd_table(struct hns_roce_dev *hr_dev)\r\n{\r\nreturn hns_roce_bitmap_init(&hr_dev->pd_bitmap, hr_dev->caps.num_pds,\r\nhr_dev->caps.num_pds - 1,\r\nhr_dev->caps.reserved_pds, 0);\r\n}\r\nvoid hns_roce_cleanup_pd_table(struct hns_roce_dev *hr_dev)\r\n{\r\nhns_roce_bitmap_cleanup(&hr_dev->pd_bitmap);\r\n}\r\nstruct ib_pd *hns_roce_alloc_pd(struct ib_device *ib_dev,\r\nstruct ib_ucontext *context,\r\nstruct ib_udata *udata)\r\n{\r\nstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\r\nstruct device *dev = &hr_dev->pdev->dev;\r\nstruct hns_roce_pd *pd;\r\nint ret;\r\npd = kmalloc(sizeof(*pd), GFP_KERNEL);\r\nif (!pd)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = hns_roce_pd_alloc(to_hr_dev(ib_dev), &pd->pdn);\r\nif (ret) {\r\nkfree(pd);\r\ndev_err(dev, "[alloc_pd]hns_roce_pd_alloc failed!\n");\r\nreturn ERR_PTR(ret);\r\n}\r\nif (context) {\r\nif (ib_copy_to_udata(udata, &pd->pdn, sizeof(u64))) {\r\nhns_roce_pd_free(to_hr_dev(ib_dev), pd->pdn);\r\ndev_err(dev, "[alloc_pd]ib_copy_to_udata failed!\n");\r\nkfree(pd);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\n}\r\nreturn &pd->ibpd;\r\n}\r\nint hns_roce_dealloc_pd(struct ib_pd *pd)\r\n{\r\nhns_roce_pd_free(to_hr_dev(pd->device), to_hr_pd(pd)->pdn);\r\nkfree(to_hr_pd(pd));\r\nreturn 0;\r\n}\r\nint hns_roce_uar_alloc(struct hns_roce_dev *hr_dev, struct hns_roce_uar *uar)\r\n{\r\nstruct resource *res;\r\nint ret = 0;\r\nret = hns_roce_bitmap_alloc(&hr_dev->uar_table.bitmap, &uar->index);\r\nif (ret == -1)\r\nreturn -ENOMEM;\r\nif (uar->index > 0)\r\nuar->index = (uar->index - 1) %\r\n(hr_dev->caps.phy_num_uars - 1) + 1;\r\nres = platform_get_resource(hr_dev->pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&hr_dev->pdev->dev, "memory resource not found!\n");\r\nreturn -EINVAL;\r\n}\r\nuar->pfn = ((res->start) >> PAGE_SHIFT) + uar->index;\r\nreturn 0;\r\n}\r\nvoid hns_roce_uar_free(struct hns_roce_dev *hr_dev, struct hns_roce_uar *uar)\r\n{\r\nhns_roce_bitmap_free(&hr_dev->uar_table.bitmap, uar->index,\r\nBITMAP_NO_RR);\r\n}\r\nint hns_roce_init_uar_table(struct hns_roce_dev *hr_dev)\r\n{\r\nreturn hns_roce_bitmap_init(&hr_dev->uar_table.bitmap,\r\nhr_dev->caps.num_uars,\r\nhr_dev->caps.num_uars - 1,\r\nhr_dev->caps.reserved_uars, 0);\r\n}\r\nvoid hns_roce_cleanup_uar_table(struct hns_roce_dev *hr_dev)\r\n{\r\nhns_roce_bitmap_cleanup(&hr_dev->uar_table.bitmap);\r\n}
