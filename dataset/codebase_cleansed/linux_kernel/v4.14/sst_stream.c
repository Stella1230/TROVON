int sst_alloc_stream_mrfld(struct intel_sst_drv *sst_drv_ctx, void *params)\r\n{\r\nstruct snd_sst_alloc_mrfld alloc_param;\r\nstruct snd_sst_params *str_params;\r\nstruct snd_sst_tstamp fw_tstamp;\r\nstruct stream_info *str_info;\r\nstruct snd_sst_alloc_response *response;\r\nunsigned int str_id, pipe_id, task_id;\r\nint i, num_ch, ret = 0;\r\nvoid *data = NULL;\r\ndev_dbg(sst_drv_ctx->dev, "Enter\n");\r\nBUG_ON(!params);\r\nstr_params = (struct snd_sst_params *)params;\r\nmemset(&alloc_param, 0, sizeof(alloc_param));\r\nalloc_param.operation = str_params->ops;\r\nalloc_param.codec_type = str_params->codec;\r\nalloc_param.sg_count = str_params->aparams.sg_count;\r\nalloc_param.ring_buf_info[0].addr =\r\nstr_params->aparams.ring_buf_info[0].addr;\r\nalloc_param.ring_buf_info[0].size =\r\nstr_params->aparams.ring_buf_info[0].size;\r\nalloc_param.frag_size = str_params->aparams.frag_size;\r\nmemcpy(&alloc_param.codec_params, &str_params->sparams,\r\nsizeof(struct snd_sst_stream_params));\r\nnum_ch = sst_get_num_channel(str_params);\r\nfor (i = 0; i < 8; i++) {\r\nif (i < num_ch)\r\nalloc_param.codec_params.uc.pcm_params.channel_map[i] = i;\r\nelse\r\nalloc_param.codec_params.uc.pcm_params.channel_map[i] = 0xFF;\r\n}\r\nstr_id = str_params->stream_id;\r\nstr_info = get_stream_info(sst_drv_ctx, str_id);\r\nif (str_info == NULL) {\r\ndev_err(sst_drv_ctx->dev, "get stream info returned null\n");\r\nreturn -EINVAL;\r\n}\r\npipe_id = str_params->device_type;\r\ntask_id = str_params->task;\r\nsst_drv_ctx->streams[str_id].pipe_id = pipe_id;\r\nsst_drv_ctx->streams[str_id].task_id = task_id;\r\nsst_drv_ctx->streams[str_id].num_ch = num_ch;\r\nif (sst_drv_ctx->info.lpe_viewpt_rqd)\r\nalloc_param.ts = sst_drv_ctx->info.mailbox_start +\r\nsst_drv_ctx->tstamp + (str_id * sizeof(fw_tstamp));\r\nelse\r\nalloc_param.ts = sst_drv_ctx->mailbox_add +\r\nsst_drv_ctx->tstamp + (str_id * sizeof(fw_tstamp));\r\ndev_dbg(sst_drv_ctx->dev, "alloc tstamp location = 0x%x\n",\r\nalloc_param.ts);\r\ndev_dbg(sst_drv_ctx->dev, "assigned pipe id 0x%x to task %d\n",\r\npipe_id, task_id);\r\nsst_init_stream(&sst_drv_ctx->streams[str_id], alloc_param.codec_type,\r\nstr_id, alloc_param.operation, 0);\r\ndev_dbg(sst_drv_ctx->dev, "Alloc for str %d pipe %#x\n",\r\nstr_id, pipe_id);\r\nret = sst_prepare_and_post_msg(sst_drv_ctx, task_id, IPC_CMD,\r\nIPC_IA_ALLOC_STREAM_MRFLD, pipe_id, sizeof(alloc_param),\r\n&alloc_param, &data, true, true, false, true);\r\nif (ret < 0) {\r\ndev_err(sst_drv_ctx->dev, "FW alloc failed ret %d\n", ret);\r\nstr_info->status = STREAM_UN_INIT;\r\nstr_id = ret;\r\n} else if (data) {\r\nresponse = (struct snd_sst_alloc_response *)data;\r\nret = response->str_type.result;\r\nif (!ret)\r\ngoto out;\r\ndev_err(sst_drv_ctx->dev, "FW alloc failed ret %d\n", ret);\r\nif (ret == SST_ERR_STREAM_IN_USE) {\r\ndev_err(sst_drv_ctx->dev,\r\n"FW not in clean state, send free for:%d\n", str_id);\r\nsst_free_stream(sst_drv_ctx, str_id);\r\n}\r\nstr_id = -ret;\r\n}\r\nout:\r\nkfree(data);\r\nreturn str_id;\r\n}\r\nint sst_start_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)\r\n{\r\nint retval = 0;\r\nstruct stream_info *str_info;\r\nu16 data = 0;\r\ndev_dbg(sst_drv_ctx->dev, "sst_start_stream for %d\n", str_id);\r\nstr_info = get_stream_info(sst_drv_ctx, str_id);\r\nif (!str_info)\r\nreturn -EINVAL;\r\nif (str_info->status != STREAM_RUNNING)\r\nreturn -EBADRQC;\r\nretval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id,\r\nIPC_CMD, IPC_IA_START_STREAM_MRFLD, str_info->pipe_id,\r\nsizeof(u16), &data, NULL, true, true, true, false);\r\nreturn retval;\r\n}\r\nint sst_send_byte_stream_mrfld(struct intel_sst_drv *sst_drv_ctx,\r\nstruct snd_sst_bytes_v2 *bytes)\r\n{ struct ipc_post *msg = NULL;\r\nu32 length;\r\nint pvt_id, ret = 0;\r\nstruct sst_block *block = NULL;\r\ndev_dbg(sst_drv_ctx->dev,\r\n"type:%u ipc_msg:%u block:%u task_id:%u pipe: %#x length:%#x\n",\r\nbytes->type, bytes->ipc_msg, bytes->block, bytes->task_id,\r\nbytes->pipe_id, bytes->len);\r\nif (sst_create_ipc_msg(&msg, true))\r\nreturn -ENOMEM;\r\npvt_id = sst_assign_pvt_id(sst_drv_ctx);\r\nsst_fill_header_mrfld(&msg->mrfld_header, bytes->ipc_msg,\r\nbytes->task_id, 1, pvt_id);\r\nmsg->mrfld_header.p.header_high.part.res_rqd = bytes->block;\r\nlength = bytes->len;\r\nmsg->mrfld_header.p.header_low_payload = length;\r\ndev_dbg(sst_drv_ctx->dev, "length is %d\n", length);\r\nmemcpy(msg->mailbox_data, &bytes->bytes, bytes->len);\r\nif (bytes->block) {\r\nblock = sst_create_block(sst_drv_ctx, bytes->ipc_msg, pvt_id);\r\nif (block == NULL) {\r\nkfree(msg);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nsst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);\r\ndev_dbg(sst_drv_ctx->dev, "msg->mrfld_header.p.header_low_payload:%d",\r\nmsg->mrfld_header.p.header_low_payload);\r\nif (bytes->block) {\r\nret = sst_wait_timeout(sst_drv_ctx, block);\r\nif (ret) {\r\ndev_err(sst_drv_ctx->dev, "fw returned err %d\n", ret);\r\nsst_free_block(sst_drv_ctx, block);\r\ngoto out;\r\n}\r\n}\r\nif (bytes->type == SND_SST_BYTES_GET) {\r\nif (bytes->block) {\r\nunsigned char *r = block->data;\r\ndev_dbg(sst_drv_ctx->dev, "read back %d bytes",\r\nbytes->len);\r\nmemcpy(bytes->bytes, r, bytes->len);\r\n}\r\n}\r\nif (bytes->block)\r\nsst_free_block(sst_drv_ctx, block);\r\nout:\r\ntest_and_clear_bit(pvt_id, &sst_drv_ctx->pvt_id);\r\nreturn 0;\r\n}\r\nint sst_pause_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)\r\n{\r\nint retval = 0;\r\nstruct stream_info *str_info;\r\ndev_dbg(sst_drv_ctx->dev, "SST DBG:sst_pause_stream for %d\n", str_id);\r\nstr_info = get_stream_info(sst_drv_ctx, str_id);\r\nif (!str_info)\r\nreturn -EINVAL;\r\nif (str_info->status == STREAM_PAUSED)\r\nreturn 0;\r\nif (str_info->status == STREAM_RUNNING ||\r\nstr_info->status == STREAM_INIT) {\r\nif (str_info->prev == STREAM_UN_INIT)\r\nreturn -EBADRQC;\r\nretval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id, IPC_CMD,\r\nIPC_IA_PAUSE_STREAM_MRFLD, str_info->pipe_id,\r\n0, NULL, NULL, true, true, false, true);\r\nif (retval == 0) {\r\nstr_info->prev = str_info->status;\r\nstr_info->status = STREAM_PAUSED;\r\n} else if (retval == SST_ERR_INVALID_STREAM_ID) {\r\nretval = -EINVAL;\r\nmutex_lock(&sst_drv_ctx->sst_lock);\r\nsst_clean_stream(str_info);\r\nmutex_unlock(&sst_drv_ctx->sst_lock);\r\n}\r\n} else {\r\nretval = -EBADRQC;\r\ndev_dbg(sst_drv_ctx->dev, "SST DBG:BADRQC for stream\n ");\r\n}\r\nreturn retval;\r\n}\r\nint sst_resume_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)\r\n{\r\nint retval = 0;\r\nstruct stream_info *str_info;\r\ndev_dbg(sst_drv_ctx->dev, "SST DBG:sst_resume_stream for %d\n", str_id);\r\nstr_info = get_stream_info(sst_drv_ctx, str_id);\r\nif (!str_info)\r\nreturn -EINVAL;\r\nif (str_info->status == STREAM_RUNNING)\r\nreturn 0;\r\nif (str_info->status == STREAM_PAUSED) {\r\nretval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id,\r\nIPC_CMD, IPC_IA_RESUME_STREAM_MRFLD,\r\nstr_info->pipe_id, 0, NULL, NULL,\r\ntrue, true, false, true);\r\nif (!retval) {\r\nif (str_info->prev == STREAM_RUNNING)\r\nstr_info->status = STREAM_RUNNING;\r\nelse\r\nstr_info->status = STREAM_INIT;\r\nstr_info->prev = STREAM_PAUSED;\r\n} else if (retval == -SST_ERR_INVALID_STREAM_ID) {\r\nretval = -EINVAL;\r\nmutex_lock(&sst_drv_ctx->sst_lock);\r\nsst_clean_stream(str_info);\r\nmutex_unlock(&sst_drv_ctx->sst_lock);\r\n}\r\n} else {\r\nretval = -EBADRQC;\r\ndev_err(sst_drv_ctx->dev, "SST ERR: BADQRC for stream\n");\r\n}\r\nreturn retval;\r\n}\r\nint sst_drop_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)\r\n{\r\nint retval = 0;\r\nstruct stream_info *str_info;\r\ndev_dbg(sst_drv_ctx->dev, "SST DBG:sst_drop_stream for %d\n", str_id);\r\nstr_info = get_stream_info(sst_drv_ctx, str_id);\r\nif (!str_info)\r\nreturn -EINVAL;\r\nif (str_info->status != STREAM_UN_INIT) {\r\nstr_info->prev = STREAM_UN_INIT;\r\nstr_info->status = STREAM_INIT;\r\nstr_info->cumm_bytes = 0;\r\nretval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id,\r\nIPC_CMD, IPC_IA_DROP_STREAM_MRFLD,\r\nstr_info->pipe_id, 0, NULL, NULL,\r\ntrue, true, true, false);\r\n} else {\r\nretval = -EBADRQC;\r\ndev_dbg(sst_drv_ctx->dev, "BADQRC for stream, state %x\n",\r\nstr_info->status);\r\n}\r\nreturn retval;\r\n}\r\nint sst_drain_stream(struct intel_sst_drv *sst_drv_ctx,\r\nint str_id, bool partial_drain)\r\n{\r\nint retval = 0;\r\nstruct stream_info *str_info;\r\ndev_dbg(sst_drv_ctx->dev, "SST DBG:sst_drain_stream for %d\n", str_id);\r\nstr_info = get_stream_info(sst_drv_ctx, str_id);\r\nif (!str_info)\r\nreturn -EINVAL;\r\nif (str_info->status != STREAM_RUNNING &&\r\nstr_info->status != STREAM_INIT &&\r\nstr_info->status != STREAM_PAUSED) {\r\ndev_err(sst_drv_ctx->dev, "SST ERR: BADQRC for stream = %d\n",\r\nstr_info->status);\r\nreturn -EBADRQC;\r\n}\r\nretval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id, IPC_CMD,\r\nIPC_IA_DRAIN_STREAM_MRFLD, str_info->pipe_id,\r\nsizeof(u8), &partial_drain, NULL, true, true, false, false);\r\nreturn retval;\r\n}\r\nint sst_free_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)\r\n{\r\nint retval = 0;\r\nstruct stream_info *str_info;\r\ndev_dbg(sst_drv_ctx->dev, "SST DBG:sst_free_stream for %d\n", str_id);\r\nmutex_lock(&sst_drv_ctx->sst_lock);\r\nif (sst_drv_ctx->sst_state == SST_RESET) {\r\nmutex_unlock(&sst_drv_ctx->sst_lock);\r\nreturn -ENODEV;\r\n}\r\nmutex_unlock(&sst_drv_ctx->sst_lock);\r\nstr_info = get_stream_info(sst_drv_ctx, str_id);\r\nif (!str_info)\r\nreturn -EINVAL;\r\nmutex_lock(&str_info->lock);\r\nif (str_info->status != STREAM_UN_INIT) {\r\nstr_info->prev = str_info->status;\r\nstr_info->status = STREAM_UN_INIT;\r\nmutex_unlock(&str_info->lock);\r\ndev_dbg(sst_drv_ctx->dev, "Free for str %d pipe %#x\n",\r\nstr_id, str_info->pipe_id);\r\nretval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id, IPC_CMD,\r\nIPC_IA_FREE_STREAM_MRFLD, str_info->pipe_id, 0,\r\nNULL, NULL, true, true, false, true);\r\ndev_dbg(sst_drv_ctx->dev, "sst: wait for free returned %d\n",\r\nretval);\r\nmutex_lock(&sst_drv_ctx->sst_lock);\r\nsst_clean_stream(str_info);\r\nmutex_unlock(&sst_drv_ctx->sst_lock);\r\ndev_dbg(sst_drv_ctx->dev, "SST DBG:Stream freed\n");\r\n} else {\r\nmutex_unlock(&str_info->lock);\r\nretval = -EBADRQC;\r\ndev_dbg(sst_drv_ctx->dev, "SST DBG:BADQRC for stream\n");\r\n}\r\nreturn retval;\r\n}
