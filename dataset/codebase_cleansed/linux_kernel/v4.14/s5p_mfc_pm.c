int s5p_mfc_init_pm(struct s5p_mfc_dev *dev)\r\n{\r\nint i;\r\npm = &dev->pm;\r\np_dev = dev;\r\npm->num_clocks = dev->variant->num_clocks;\r\npm->clk_names = dev->variant->clk_names;\r\npm->device = &dev->plat_dev->dev;\r\npm->clock_gate = NULL;\r\nfor (i = 0; i < pm->num_clocks; i++) {\r\npm->clocks[i] = devm_clk_get(pm->device, pm->clk_names[i]);\r\nif (IS_ERR(pm->clocks[i])) {\r\nmfc_err("Failed to get clock: %s\n",\r\npm->clk_names[i]);\r\nreturn PTR_ERR(pm->clocks[i]);\r\n}\r\n}\r\nif (dev->variant->use_clock_gating)\r\npm->clock_gate = pm->clocks[0];\r\npm_runtime_enable(pm->device);\r\natomic_set(&clk_ref, 0);\r\nreturn 0;\r\n}\r\nvoid s5p_mfc_final_pm(struct s5p_mfc_dev *dev)\r\n{\r\npm_runtime_disable(pm->device);\r\n}\r\nint s5p_mfc_clock_on(void)\r\n{\r\natomic_inc(&clk_ref);\r\nmfc_debug(3, "+ %d\n", atomic_read(&clk_ref));\r\nreturn clk_enable(pm->clock_gate);\r\n}\r\nvoid s5p_mfc_clock_off(void)\r\n{\r\natomic_dec(&clk_ref);\r\nmfc_debug(3, "- %d\n", atomic_read(&clk_ref));\r\nclk_disable(pm->clock_gate);\r\n}\r\nint s5p_mfc_power_on(void)\r\n{\r\nint i, ret = 0;\r\nret = pm_runtime_get_sync(pm->device);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < pm->num_clocks; i++) {\r\nret = clk_prepare_enable(pm->clocks[i]);\r\nif (ret < 0) {\r\nmfc_err("clock prepare failed for clock: %s\n",\r\npm->clk_names[i]);\r\ni++;\r\ngoto err;\r\n}\r\n}\r\nclk_disable(pm->clock_gate);\r\nreturn 0;\r\nerr:\r\nwhile (--i > 0)\r\nclk_disable_unprepare(pm->clocks[i]);\r\npm_runtime_put(pm->device);\r\nreturn ret;\r\n}\r\nint s5p_mfc_power_off(void)\r\n{\r\nint i;\r\nclk_enable(pm->clock_gate);\r\nfor (i = 0; i < pm->num_clocks; i++)\r\nclk_disable_unprepare(pm->clocks[i]);\r\nreturn pm_runtime_put_sync(pm->device);\r\n}
