static unsigned int get_pages_from_reserved_pool(void *pool,\r\nstruct hmm_page_object *page_obj,\r\nunsigned int size, bool cached)\r\n{\r\nunsigned long flags;\r\nunsigned int i = 0;\r\nunsigned int repool_pgnr;\r\nint j;\r\nstruct hmm_reserved_pool_info *repool_info = pool;\r\nif (!repool_info)\r\nreturn 0;\r\nspin_lock_irqsave(&repool_info->list_lock, flags);\r\nif (repool_info->initialized) {\r\nrepool_pgnr = repool_info->index;\r\nfor (j = repool_pgnr-1; j >= 0; j--) {\r\npage_obj[i].page = repool_info->pages[j];\r\npage_obj[i].type = HMM_PAGE_TYPE_RESERVED;\r\ni++;\r\nrepool_info->index--;\r\nif (i == size)\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&repool_info->list_lock, flags);\r\nreturn i;\r\n}\r\nstatic void free_pages_to_reserved_pool(void *pool,\r\nstruct hmm_page_object *page_obj)\r\n{\r\nunsigned long flags;\r\nstruct hmm_reserved_pool_info *repool_info = pool;\r\nif (!repool_info)\r\nreturn;\r\nspin_lock_irqsave(&repool_info->list_lock, flags);\r\nif (repool_info->initialized &&\r\nrepool_info->index < repool_info->pgnr &&\r\npage_obj->type == HMM_PAGE_TYPE_RESERVED) {\r\nrepool_info->pages[repool_info->index++] = page_obj->page;\r\n}\r\nspin_unlock_irqrestore(&repool_info->list_lock, flags);\r\n}\r\nstatic int hmm_reserved_pool_setup(struct hmm_reserved_pool_info **repool_info,\r\nunsigned int pool_size)\r\n{\r\nstruct hmm_reserved_pool_info *pool_info;\r\npool_info = kmalloc(sizeof(struct hmm_reserved_pool_info),\r\nGFP_KERNEL);\r\nif (unlikely(!pool_info)) {\r\ndev_err(atomisp_dev, "out of memory for repool_info.\n");\r\nreturn -ENOMEM;\r\n}\r\npool_info->pages = kmalloc(sizeof(struct page *) * pool_size,\r\nGFP_KERNEL);\r\nif (unlikely(!pool_info->pages)) {\r\ndev_err(atomisp_dev, "out of memory for repool_info->pages.\n");\r\nkfree(pool_info);\r\nreturn -ENOMEM;\r\n}\r\npool_info->index = 0;\r\npool_info->pgnr = 0;\r\nspin_lock_init(&pool_info->list_lock);\r\npool_info->initialized = true;\r\n*repool_info = pool_info;\r\nreturn 0;\r\n}\r\nstatic int hmm_reserved_pool_init(void **pool, unsigned int pool_size)\r\n{\r\nint ret;\r\nunsigned int blk_pgnr;\r\nunsigned int pgnr = pool_size;\r\nunsigned int order = 0;\r\nunsigned int i = 0;\r\nint fail_number = 0;\r\nstruct page *pages;\r\nint j;\r\nstruct hmm_reserved_pool_info *repool_info;\r\nif (pool_size == 0)\r\nreturn 0;\r\nret = hmm_reserved_pool_setup(&repool_info, pool_size);\r\nif (ret) {\r\ndev_err(atomisp_dev, "hmm_reserved_pool_setup failed.\n");\r\nreturn ret;\r\n}\r\npgnr = pool_size;\r\ni = 0;\r\norder = MAX_ORDER;\r\nwhile (pgnr) {\r\nblk_pgnr = 1U << order;\r\nwhile (blk_pgnr > pgnr) {\r\norder--;\r\nblk_pgnr >>= 1U;\r\n}\r\nBUG_ON(order > MAX_ORDER);\r\npages = alloc_pages(GFP_KERNEL | __GFP_NOWARN, order);\r\nif (unlikely(!pages)) {\r\nif (order == 0) {\r\nfail_number++;\r\ndev_err(atomisp_dev, "%s: alloc_pages failed: %d\n",\r\n__func__, fail_number);\r\nif (fail_number == ALLOC_PAGE_FAIL_NUM)\r\ngoto end;\r\n} else {\r\norder--;\r\n}\r\n} else {\r\nblk_pgnr = 1U << order;\r\nret = set_pages_uc(pages, blk_pgnr);\r\nif (ret) {\r\ndev_err(atomisp_dev,\r\n"set pages uncached failed\n");\r\n__free_pages(pages, order);\r\ngoto end;\r\n}\r\nfor (j = 0; j < blk_pgnr; j++)\r\nrepool_info->pages[i++] = pages + j;\r\nrepool_info->index += blk_pgnr;\r\nrepool_info->pgnr += blk_pgnr;\r\npgnr -= blk_pgnr;\r\nfail_number = 0;\r\n}\r\n}\r\nend:\r\nrepool_info->initialized = true;\r\n*pool = repool_info;\r\ndev_info(atomisp_dev,\r\n"hmm_reserved_pool init successfully,"\r\n"hmm_reserved_pool is with %d pages.\n",\r\nrepool_info->pgnr);\r\nreturn 0;\r\n}\r\nstatic void hmm_reserved_pool_exit(void **pool)\r\n{\r\nunsigned long flags;\r\nint i, ret;\r\nunsigned int pgnr;\r\nstruct hmm_reserved_pool_info *repool_info = *pool;\r\nif (!repool_info)\r\nreturn;\r\nspin_lock_irqsave(&repool_info->list_lock, flags);\r\nif (!repool_info->initialized) {\r\nspin_unlock_irqrestore(&repool_info->list_lock, flags);\r\nreturn;\r\n}\r\npgnr = repool_info->pgnr;\r\nrepool_info->index = 0;\r\nrepool_info->pgnr = 0;\r\nrepool_info->initialized = false;\r\nspin_unlock_irqrestore(&repool_info->list_lock, flags);\r\nfor (i = 0; i < pgnr; i++) {\r\nret = set_pages_wb(repool_info->pages[i], 1);\r\nif (ret)\r\ndev_err(atomisp_dev,\r\n"set page to WB err...ret=%d\n", ret);\r\nif (!ret)\r\n__free_pages(repool_info->pages[i], 0);\r\n}\r\nkfree(repool_info->pages);\r\nkfree(repool_info);\r\n*pool = NULL;\r\n}\r\nstatic int hmm_reserved_pool_inited(void *pool)\r\n{\r\nstruct hmm_reserved_pool_info *repool_info = pool;\r\nif (!repool_info)\r\nreturn 0;\r\nreturn repool_info->initialized;\r\n}
