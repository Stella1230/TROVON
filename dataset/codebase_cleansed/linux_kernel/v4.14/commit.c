static void journal_end_buffer_io_sync(struct buffer_head *bh, int uptodate)\r\n{\r\nstruct buffer_head *orig_bh = bh->b_private;\r\nBUFFER_TRACE(bh, "");\r\nif (uptodate)\r\nset_buffer_uptodate(bh);\r\nelse\r\nclear_buffer_uptodate(bh);\r\nif (orig_bh) {\r\nclear_bit_unlock(BH_Shadow, &orig_bh->b_state);\r\nsmp_mb__after_atomic();\r\nwake_up_bit(&orig_bh->b_state, BH_Shadow);\r\n}\r\nunlock_buffer(bh);\r\n}\r\nstatic void release_buffer_page(struct buffer_head *bh)\r\n{\r\nstruct page *page;\r\nif (buffer_dirty(bh))\r\ngoto nope;\r\nif (atomic_read(&bh->b_count) != 1)\r\ngoto nope;\r\npage = bh->b_page;\r\nif (!page)\r\ngoto nope;\r\nif (page->mapping)\r\ngoto nope;\r\nif (!trylock_page(page))\r\ngoto nope;\r\nget_page(page);\r\n__brelse(bh);\r\ntry_to_free_buffers(page);\r\nunlock_page(page);\r\nput_page(page);\r\nreturn;\r\nnope:\r\n__brelse(bh);\r\n}\r\nstatic void jbd2_commit_block_csum_set(journal_t *j, struct buffer_head *bh)\r\n{\r\nstruct commit_header *h;\r\n__u32 csum;\r\nif (!jbd2_journal_has_csum_v2or3(j))\r\nreturn;\r\nh = (struct commit_header *)(bh->b_data);\r\nh->h_chksum_type = 0;\r\nh->h_chksum_size = 0;\r\nh->h_chksum[0] = 0;\r\ncsum = jbd2_chksum(j, j->j_csum_seed, bh->b_data, j->j_blocksize);\r\nh->h_chksum[0] = cpu_to_be32(csum);\r\n}\r\nstatic int journal_submit_commit_record(journal_t *journal,\r\ntransaction_t *commit_transaction,\r\nstruct buffer_head **cbh,\r\n__u32 crc32_sum)\r\n{\r\nstruct commit_header *tmp;\r\nstruct buffer_head *bh;\r\nint ret;\r\nstruct timespec64 now = current_kernel_time64();\r\n*cbh = NULL;\r\nif (is_journal_aborted(journal))\r\nreturn 0;\r\nbh = jbd2_journal_get_descriptor_buffer(commit_transaction,\r\nJBD2_COMMIT_BLOCK);\r\nif (!bh)\r\nreturn 1;\r\ntmp = (struct commit_header *)bh->b_data;\r\ntmp->h_commit_sec = cpu_to_be64(now.tv_sec);\r\ntmp->h_commit_nsec = cpu_to_be32(now.tv_nsec);\r\nif (jbd2_has_feature_checksum(journal)) {\r\ntmp->h_chksum_type = JBD2_CRC32_CHKSUM;\r\ntmp->h_chksum_size = JBD2_CRC32_CHKSUM_SIZE;\r\ntmp->h_chksum[0] = cpu_to_be32(crc32_sum);\r\n}\r\njbd2_commit_block_csum_set(journal, bh);\r\nBUFFER_TRACE(bh, "submit commit block");\r\nlock_buffer(bh);\r\nclear_buffer_dirty(bh);\r\nset_buffer_uptodate(bh);\r\nbh->b_end_io = journal_end_buffer_io_sync;\r\nif (journal->j_flags & JBD2_BARRIER &&\r\n!jbd2_has_feature_async_commit(journal))\r\nret = submit_bh(REQ_OP_WRITE,\r\nREQ_SYNC | REQ_PREFLUSH | REQ_FUA, bh);\r\nelse\r\nret = submit_bh(REQ_OP_WRITE, REQ_SYNC, bh);\r\n*cbh = bh;\r\nreturn ret;\r\n}\r\nstatic int journal_wait_on_commit_record(journal_t *journal,\r\nstruct buffer_head *bh)\r\n{\r\nint ret = 0;\r\nclear_buffer_dirty(bh);\r\nwait_on_buffer(bh);\r\nif (unlikely(!buffer_uptodate(bh)))\r\nret = -EIO;\r\nput_bh(bh);\r\nreturn ret;\r\n}\r\nstatic int journal_submit_inode_data_buffers(struct address_space *mapping)\r\n{\r\nint ret;\r\nstruct writeback_control wbc = {\r\n.sync_mode = WB_SYNC_ALL,\r\n.nr_to_write = mapping->nrpages * 2,\r\n.range_start = 0,\r\n.range_end = i_size_read(mapping->host),\r\n};\r\nret = generic_writepages(mapping, &wbc);\r\nreturn ret;\r\n}\r\nstatic int journal_submit_data_buffers(journal_t *journal,\r\ntransaction_t *commit_transaction)\r\n{\r\nstruct jbd2_inode *jinode;\r\nint err, ret = 0;\r\nstruct address_space *mapping;\r\nspin_lock(&journal->j_list_lock);\r\nlist_for_each_entry(jinode, &commit_transaction->t_inode_list, i_list) {\r\nif (!(jinode->i_flags & JI_WRITE_DATA))\r\ncontinue;\r\nmapping = jinode->i_vfs_inode->i_mapping;\r\njinode->i_flags |= JI_COMMIT_RUNNING;\r\nspin_unlock(&journal->j_list_lock);\r\ntrace_jbd2_submit_inode_data(jinode->i_vfs_inode);\r\nerr = journal_submit_inode_data_buffers(mapping);\r\nif (!ret)\r\nret = err;\r\nspin_lock(&journal->j_list_lock);\r\nJ_ASSERT(jinode->i_transaction == commit_transaction);\r\njinode->i_flags &= ~JI_COMMIT_RUNNING;\r\nsmp_mb();\r\nwake_up_bit(&jinode->i_flags, __JI_COMMIT_RUNNING);\r\n}\r\nspin_unlock(&journal->j_list_lock);\r\nreturn ret;\r\n}\r\nstatic int journal_finish_inode_data_buffers(journal_t *journal,\r\ntransaction_t *commit_transaction)\r\n{\r\nstruct jbd2_inode *jinode, *next_i;\r\nint err, ret = 0;\r\nspin_lock(&journal->j_list_lock);\r\nlist_for_each_entry(jinode, &commit_transaction->t_inode_list, i_list) {\r\nif (!(jinode->i_flags & JI_WAIT_DATA))\r\ncontinue;\r\njinode->i_flags |= JI_COMMIT_RUNNING;\r\nspin_unlock(&journal->j_list_lock);\r\nerr = filemap_fdatawait_keep_errors(\r\njinode->i_vfs_inode->i_mapping);\r\nif (!ret)\r\nret = err;\r\nspin_lock(&journal->j_list_lock);\r\njinode->i_flags &= ~JI_COMMIT_RUNNING;\r\nsmp_mb();\r\nwake_up_bit(&jinode->i_flags, __JI_COMMIT_RUNNING);\r\n}\r\nlist_for_each_entry_safe(jinode, next_i,\r\n&commit_transaction->t_inode_list, i_list) {\r\nlist_del(&jinode->i_list);\r\nif (jinode->i_next_transaction) {\r\njinode->i_transaction = jinode->i_next_transaction;\r\njinode->i_next_transaction = NULL;\r\nlist_add(&jinode->i_list,\r\n&jinode->i_transaction->t_inode_list);\r\n} else {\r\njinode->i_transaction = NULL;\r\n}\r\n}\r\nspin_unlock(&journal->j_list_lock);\r\nreturn ret;\r\n}\r\nstatic __u32 jbd2_checksum_data(__u32 crc32_sum, struct buffer_head *bh)\r\n{\r\nstruct page *page = bh->b_page;\r\nchar *addr;\r\n__u32 checksum;\r\naddr = kmap_atomic(page);\r\nchecksum = crc32_be(crc32_sum,\r\n(void *)(addr + offset_in_page(bh->b_data)), bh->b_size);\r\nkunmap_atomic(addr);\r\nreturn checksum;\r\n}\r\nstatic void write_tag_block(journal_t *j, journal_block_tag_t *tag,\r\nunsigned long long block)\r\n{\r\ntag->t_blocknr = cpu_to_be32(block & (u32)~0);\r\nif (jbd2_has_feature_64bit(j))\r\ntag->t_blocknr_high = cpu_to_be32((block >> 31) >> 1);\r\n}\r\nstatic void jbd2_block_tag_csum_set(journal_t *j, journal_block_tag_t *tag,\r\nstruct buffer_head *bh, __u32 sequence)\r\n{\r\njournal_block_tag3_t *tag3 = (journal_block_tag3_t *)tag;\r\nstruct page *page = bh->b_page;\r\n__u8 *addr;\r\n__u32 csum32;\r\n__be32 seq;\r\nif (!jbd2_journal_has_csum_v2or3(j))\r\nreturn;\r\nseq = cpu_to_be32(sequence);\r\naddr = kmap_atomic(page);\r\ncsum32 = jbd2_chksum(j, j->j_csum_seed, (__u8 *)&seq, sizeof(seq));\r\ncsum32 = jbd2_chksum(j, csum32, addr + offset_in_page(bh->b_data),\r\nbh->b_size);\r\nkunmap_atomic(addr);\r\nif (jbd2_has_feature_csum3(j))\r\ntag3->t_checksum = cpu_to_be32(csum32);\r\nelse\r\ntag->t_checksum = cpu_to_be16(csum32);\r\n}\r\nvoid jbd2_journal_commit_transaction(journal_t *journal)\r\n{\r\nstruct transaction_stats_s stats;\r\ntransaction_t *commit_transaction;\r\nstruct journal_head *jh;\r\nstruct buffer_head *descriptor;\r\nstruct buffer_head **wbuf = journal->j_wbuf;\r\nint bufs;\r\nint flags;\r\nint err;\r\nunsigned long long blocknr;\r\nktime_t start_time;\r\nu64 commit_time;\r\nchar *tagp = NULL;\r\njournal_block_tag_t *tag = NULL;\r\nint space_left = 0;\r\nint first_tag = 0;\r\nint tag_flag;\r\nint i;\r\nint tag_bytes = journal_tag_bytes(journal);\r\nstruct buffer_head *cbh = NULL;\r\n__u32 crc32_sum = ~0;\r\nstruct blk_plug plug;\r\nunsigned long first_block;\r\ntid_t first_tid;\r\nint update_tail;\r\nint csum_size = 0;\r\nLIST_HEAD(io_bufs);\r\nLIST_HEAD(log_bufs);\r\nif (jbd2_journal_has_csum_v2or3(journal))\r\ncsum_size = sizeof(struct jbd2_journal_block_tail);\r\nif (journal->j_flags & JBD2_FLUSHED) {\r\njbd_debug(3, "super block updated\n");\r\nmutex_lock_io(&journal->j_checkpoint_mutex);\r\njbd2_journal_update_sb_log_tail(journal,\r\njournal->j_tail_sequence,\r\njournal->j_tail,\r\nREQ_SYNC);\r\nmutex_unlock(&journal->j_checkpoint_mutex);\r\n} else {\r\njbd_debug(3, "superblock not updated\n");\r\n}\r\nJ_ASSERT(journal->j_running_transaction != NULL);\r\nJ_ASSERT(journal->j_committing_transaction == NULL);\r\ncommit_transaction = journal->j_running_transaction;\r\ntrace_jbd2_start_commit(journal, commit_transaction);\r\njbd_debug(1, "JBD2: starting commit of transaction %d\n",\r\ncommit_transaction->t_tid);\r\nwrite_lock(&journal->j_state_lock);\r\nJ_ASSERT(commit_transaction->t_state == T_RUNNING);\r\ncommit_transaction->t_state = T_LOCKED;\r\ntrace_jbd2_commit_locking(journal, commit_transaction);\r\nstats.run.rs_wait = commit_transaction->t_max_wait;\r\nstats.run.rs_request_delay = 0;\r\nstats.run.rs_locked = jiffies;\r\nif (commit_transaction->t_requested)\r\nstats.run.rs_request_delay =\r\njbd2_time_diff(commit_transaction->t_requested,\r\nstats.run.rs_locked);\r\nstats.run.rs_running = jbd2_time_diff(commit_transaction->t_start,\r\nstats.run.rs_locked);\r\nspin_lock(&commit_transaction->t_handle_lock);\r\nwhile (atomic_read(&commit_transaction->t_updates)) {\r\nDEFINE_WAIT(wait);\r\nprepare_to_wait(&journal->j_wait_updates, &wait,\r\nTASK_UNINTERRUPTIBLE);\r\nif (atomic_read(&commit_transaction->t_updates)) {\r\nspin_unlock(&commit_transaction->t_handle_lock);\r\nwrite_unlock(&journal->j_state_lock);\r\nschedule();\r\nwrite_lock(&journal->j_state_lock);\r\nspin_lock(&commit_transaction->t_handle_lock);\r\n}\r\nfinish_wait(&journal->j_wait_updates, &wait);\r\n}\r\nspin_unlock(&commit_transaction->t_handle_lock);\r\nJ_ASSERT (atomic_read(&commit_transaction->t_outstanding_credits) <=\r\njournal->j_max_transaction_buffers);\r\nwhile (commit_transaction->t_reserved_list) {\r\njh = commit_transaction->t_reserved_list;\r\nJBUFFER_TRACE(jh, "reserved, unused: refile");\r\nif (jh->b_committed_data) {\r\nstruct buffer_head *bh = jh2bh(jh);\r\njbd_lock_bh_state(bh);\r\njbd2_free(jh->b_committed_data, bh->b_size);\r\njh->b_committed_data = NULL;\r\njbd_unlock_bh_state(bh);\r\n}\r\njbd2_journal_refile_buffer(journal, jh);\r\n}\r\nspin_lock(&journal->j_list_lock);\r\n__jbd2_journal_clean_checkpoint_list(journal, false);\r\nspin_unlock(&journal->j_list_lock);\r\njbd_debug(3, "JBD2: commit phase 1\n");\r\njbd2_clear_buffer_revoked_flags(journal);\r\njbd2_journal_switch_revoke_table(journal);\r\natomic_sub(atomic_read(&journal->j_reserved_credits),\r\n&commit_transaction->t_outstanding_credits);\r\ntrace_jbd2_commit_flushing(journal, commit_transaction);\r\nstats.run.rs_flushing = jiffies;\r\nstats.run.rs_locked = jbd2_time_diff(stats.run.rs_locked,\r\nstats.run.rs_flushing);\r\ncommit_transaction->t_state = T_FLUSH;\r\njournal->j_committing_transaction = commit_transaction;\r\njournal->j_running_transaction = NULL;\r\nstart_time = ktime_get();\r\ncommit_transaction->t_log_start = journal->j_head;\r\nwake_up(&journal->j_wait_transaction_locked);\r\nwrite_unlock(&journal->j_state_lock);\r\njbd_debug(3, "JBD2: commit phase 2a\n");\r\nerr = journal_submit_data_buffers(journal, commit_transaction);\r\nif (err)\r\njbd2_journal_abort(journal, err);\r\nblk_start_plug(&plug);\r\njbd2_journal_write_revoke_records(commit_transaction, &log_bufs);\r\njbd_debug(3, "JBD2: commit phase 2b\n");\r\nwrite_lock(&journal->j_state_lock);\r\ncommit_transaction->t_state = T_COMMIT;\r\nwrite_unlock(&journal->j_state_lock);\r\ntrace_jbd2_commit_logging(journal, commit_transaction);\r\nstats.run.rs_logging = jiffies;\r\nstats.run.rs_flushing = jbd2_time_diff(stats.run.rs_flushing,\r\nstats.run.rs_logging);\r\nstats.run.rs_blocks =\r\natomic_read(&commit_transaction->t_outstanding_credits);\r\nstats.run.rs_blocks_logged = 0;\r\nJ_ASSERT(commit_transaction->t_nr_buffers <=\r\natomic_read(&commit_transaction->t_outstanding_credits));\r\nerr = 0;\r\nbufs = 0;\r\ndescriptor = NULL;\r\nwhile (commit_transaction->t_buffers) {\r\njh = commit_transaction->t_buffers;\r\nif (is_journal_aborted(journal)) {\r\nclear_buffer_jbddirty(jh2bh(jh));\r\nJBUFFER_TRACE(jh, "journal is aborting: refile");\r\njbd2_buffer_abort_trigger(jh,\r\njh->b_frozen_data ?\r\njh->b_frozen_triggers :\r\njh->b_triggers);\r\njbd2_journal_refile_buffer(journal, jh);\r\nif (!commit_transaction->t_buffers)\r\ngoto start_journal_io;\r\ncontinue;\r\n}\r\nif (!descriptor) {\r\nJ_ASSERT (bufs == 0);\r\njbd_debug(4, "JBD2: get descriptor\n");\r\ndescriptor = jbd2_journal_get_descriptor_buffer(\r\ncommit_transaction,\r\nJBD2_DESCRIPTOR_BLOCK);\r\nif (!descriptor) {\r\njbd2_journal_abort(journal, -EIO);\r\ncontinue;\r\n}\r\njbd_debug(4, "JBD2: got buffer %llu (%p)\n",\r\n(unsigned long long)descriptor->b_blocknr,\r\ndescriptor->b_data);\r\ntagp = &descriptor->b_data[sizeof(journal_header_t)];\r\nspace_left = descriptor->b_size -\r\nsizeof(journal_header_t);\r\nfirst_tag = 1;\r\nset_buffer_jwrite(descriptor);\r\nset_buffer_dirty(descriptor);\r\nwbuf[bufs++] = descriptor;\r\nBUFFER_TRACE(descriptor, "ph3: file as descriptor");\r\njbd2_file_log_bh(&log_bufs, descriptor);\r\n}\r\nerr = jbd2_journal_next_log_block(journal, &blocknr);\r\nif (err) {\r\njbd2_journal_abort(journal, err);\r\ncontinue;\r\n}\r\natomic_dec(&commit_transaction->t_outstanding_credits);\r\natomic_inc(&jh2bh(jh)->b_count);\r\nset_bit(BH_JWrite, &jh2bh(jh)->b_state);\r\nJBUFFER_TRACE(jh, "ph3: write metadata");\r\nflags = jbd2_journal_write_metadata_buffer(commit_transaction,\r\njh, &wbuf[bufs], blocknr);\r\nif (flags < 0) {\r\njbd2_journal_abort(journal, flags);\r\ncontinue;\r\n}\r\njbd2_file_log_bh(&io_bufs, wbuf[bufs]);\r\ntag_flag = 0;\r\nif (flags & 1)\r\ntag_flag |= JBD2_FLAG_ESCAPE;\r\nif (!first_tag)\r\ntag_flag |= JBD2_FLAG_SAME_UUID;\r\ntag = (journal_block_tag_t *) tagp;\r\nwrite_tag_block(journal, tag, jh2bh(jh)->b_blocknr);\r\ntag->t_flags = cpu_to_be16(tag_flag);\r\njbd2_block_tag_csum_set(journal, tag, wbuf[bufs],\r\ncommit_transaction->t_tid);\r\ntagp += tag_bytes;\r\nspace_left -= tag_bytes;\r\nbufs++;\r\nif (first_tag) {\r\nmemcpy (tagp, journal->j_uuid, 16);\r\ntagp += 16;\r\nspace_left -= 16;\r\nfirst_tag = 0;\r\n}\r\nif (bufs == journal->j_wbufsize ||\r\ncommit_transaction->t_buffers == NULL ||\r\nspace_left < tag_bytes + 16 + csum_size) {\r\njbd_debug(4, "JBD2: Submit %d IOs\n", bufs);\r\ntag->t_flags |= cpu_to_be16(JBD2_FLAG_LAST_TAG);\r\njbd2_descriptor_block_csum_set(journal, descriptor);\r\nstart_journal_io:\r\nfor (i = 0; i < bufs; i++) {\r\nstruct buffer_head *bh = wbuf[i];\r\nif (jbd2_has_feature_checksum(journal)) {\r\ncrc32_sum =\r\njbd2_checksum_data(crc32_sum, bh);\r\n}\r\nlock_buffer(bh);\r\nclear_buffer_dirty(bh);\r\nset_buffer_uptodate(bh);\r\nbh->b_end_io = journal_end_buffer_io_sync;\r\nsubmit_bh(REQ_OP_WRITE, REQ_SYNC, bh);\r\n}\r\ncond_resched();\r\nstats.run.rs_blocks_logged += bufs;\r\ndescriptor = NULL;\r\nbufs = 0;\r\n}\r\n}\r\nerr = journal_finish_inode_data_buffers(journal, commit_transaction);\r\nif (err) {\r\nprintk(KERN_WARNING\r\n"JBD2: Detected IO errors while flushing file data "\r\n"on %s\n", journal->j_devname);\r\nif (journal->j_flags & JBD2_ABORT_ON_SYNCDATA_ERR)\r\njbd2_journal_abort(journal, err);\r\nerr = 0;\r\n}\r\nupdate_tail =\r\njbd2_journal_get_log_tail(journal, &first_tid, &first_block);\r\nwrite_lock(&journal->j_state_lock);\r\nif (update_tail) {\r\nlong freed = first_block - journal->j_tail;\r\nif (first_block < journal->j_tail)\r\nfreed += journal->j_last - journal->j_first;\r\nif (freed < journal->j_maxlen / 4)\r\nupdate_tail = 0;\r\n}\r\nJ_ASSERT(commit_transaction->t_state == T_COMMIT);\r\ncommit_transaction->t_state = T_COMMIT_DFLUSH;\r\nwrite_unlock(&journal->j_state_lock);\r\nif (commit_transaction->t_need_data_flush &&\r\n(journal->j_fs_dev != journal->j_dev) &&\r\n(journal->j_flags & JBD2_BARRIER))\r\nblkdev_issue_flush(journal->j_fs_dev, GFP_NOFS, NULL);\r\nif (jbd2_has_feature_async_commit(journal)) {\r\nerr = journal_submit_commit_record(journal, commit_transaction,\r\n&cbh, crc32_sum);\r\nif (err)\r\n__jbd2_journal_abort_hard(journal);\r\n}\r\nblk_finish_plug(&plug);\r\njbd_debug(3, "JBD2: commit phase 3\n");\r\nwhile (!list_empty(&io_bufs)) {\r\nstruct buffer_head *bh = list_entry(io_bufs.prev,\r\nstruct buffer_head,\r\nb_assoc_buffers);\r\nwait_on_buffer(bh);\r\ncond_resched();\r\nif (unlikely(!buffer_uptodate(bh)))\r\nerr = -EIO;\r\njbd2_unfile_log_bh(bh);\r\nBUFFER_TRACE(bh, "dumping temporary bh");\r\n__brelse(bh);\r\nJ_ASSERT_BH(bh, atomic_read(&bh->b_count) == 0);\r\nfree_buffer_head(bh);\r\njh = commit_transaction->t_shadow_list->b_tprev;\r\nbh = jh2bh(jh);\r\nclear_buffer_jwrite(bh);\r\nJ_ASSERT_BH(bh, buffer_jbddirty(bh));\r\nJ_ASSERT_BH(bh, !buffer_shadow(bh));\r\nJBUFFER_TRACE(jh, "file as BJ_Forget");\r\njbd2_journal_file_buffer(jh, commit_transaction, BJ_Forget);\r\nJBUFFER_TRACE(jh, "brelse shadowed buffer");\r\n__brelse(bh);\r\n}\r\nJ_ASSERT (commit_transaction->t_shadow_list == NULL);\r\njbd_debug(3, "JBD2: commit phase 4\n");\r\nwhile (!list_empty(&log_bufs)) {\r\nstruct buffer_head *bh;\r\nbh = list_entry(log_bufs.prev, struct buffer_head, b_assoc_buffers);\r\nwait_on_buffer(bh);\r\ncond_resched();\r\nif (unlikely(!buffer_uptodate(bh)))\r\nerr = -EIO;\r\nBUFFER_TRACE(bh, "ph5: control buffer writeout done: unfile");\r\nclear_buffer_jwrite(bh);\r\njbd2_unfile_log_bh(bh);\r\n__brelse(bh);\r\n}\r\nif (err)\r\njbd2_journal_abort(journal, err);\r\njbd_debug(3, "JBD2: commit phase 5\n");\r\nwrite_lock(&journal->j_state_lock);\r\nJ_ASSERT(commit_transaction->t_state == T_COMMIT_DFLUSH);\r\ncommit_transaction->t_state = T_COMMIT_JFLUSH;\r\nwrite_unlock(&journal->j_state_lock);\r\nif (!jbd2_has_feature_async_commit(journal)) {\r\nerr = journal_submit_commit_record(journal, commit_transaction,\r\n&cbh, crc32_sum);\r\nif (err)\r\n__jbd2_journal_abort_hard(journal);\r\n}\r\nif (cbh)\r\nerr = journal_wait_on_commit_record(journal, cbh);\r\nif (jbd2_has_feature_async_commit(journal) &&\r\njournal->j_flags & JBD2_BARRIER) {\r\nblkdev_issue_flush(journal->j_dev, GFP_NOFS, NULL);\r\n}\r\nif (err)\r\njbd2_journal_abort(journal, err);\r\nif (update_tail)\r\njbd2_update_log_tail(journal, first_tid, first_block);\r\njbd_debug(3, "JBD2: commit phase 6\n");\r\nJ_ASSERT(list_empty(&commit_transaction->t_inode_list));\r\nJ_ASSERT(commit_transaction->t_buffers == NULL);\r\nJ_ASSERT(commit_transaction->t_checkpoint_list == NULL);\r\nJ_ASSERT(commit_transaction->t_shadow_list == NULL);\r\nrestart_loop:\r\nspin_lock(&journal->j_list_lock);\r\nwhile (commit_transaction->t_forget) {\r\ntransaction_t *cp_transaction;\r\nstruct buffer_head *bh;\r\nint try_to_free = 0;\r\njh = commit_transaction->t_forget;\r\nspin_unlock(&journal->j_list_lock);\r\nbh = jh2bh(jh);\r\nget_bh(bh);\r\njbd_lock_bh_state(bh);\r\nJ_ASSERT_JH(jh, jh->b_transaction == commit_transaction);\r\nif (jh->b_committed_data) {\r\njbd2_free(jh->b_committed_data, bh->b_size);\r\njh->b_committed_data = NULL;\r\nif (jh->b_frozen_data) {\r\njh->b_committed_data = jh->b_frozen_data;\r\njh->b_frozen_data = NULL;\r\njh->b_frozen_triggers = NULL;\r\n}\r\n} else if (jh->b_frozen_data) {\r\njbd2_free(jh->b_frozen_data, bh->b_size);\r\njh->b_frozen_data = NULL;\r\njh->b_frozen_triggers = NULL;\r\n}\r\nspin_lock(&journal->j_list_lock);\r\ncp_transaction = jh->b_cp_transaction;\r\nif (cp_transaction) {\r\nJBUFFER_TRACE(jh, "remove from old cp transaction");\r\ncp_transaction->t_chp_stats.cs_dropped++;\r\n__jbd2_journal_remove_checkpoint(jh);\r\n}\r\nif (buffer_freed(bh)) {\r\njh->b_modified = 0;\r\nif (!jh->b_next_transaction) {\r\nclear_buffer_freed(bh);\r\nclear_buffer_jbddirty(bh);\r\nclear_buffer_mapped(bh);\r\nclear_buffer_new(bh);\r\nclear_buffer_req(bh);\r\nbh->b_bdev = NULL;\r\n}\r\n}\r\nif (buffer_jbddirty(bh)) {\r\nJBUFFER_TRACE(jh, "add to new checkpointing trans");\r\n__jbd2_journal_insert_checkpoint(jh, commit_transaction);\r\nif (is_journal_aborted(journal))\r\nclear_buffer_jbddirty(bh);\r\n} else {\r\nJ_ASSERT_BH(bh, !buffer_dirty(bh));\r\nif (!jh->b_next_transaction)\r\ntry_to_free = 1;\r\n}\r\nJBUFFER_TRACE(jh, "refile or unfile buffer");\r\n__jbd2_journal_refile_buffer(jh);\r\njbd_unlock_bh_state(bh);\r\nif (try_to_free)\r\nrelease_buffer_page(bh);\r\nelse\r\n__brelse(bh);\r\ncond_resched_lock(&journal->j_list_lock);\r\n}\r\nspin_unlock(&journal->j_list_lock);\r\nwrite_lock(&journal->j_state_lock);\r\nspin_lock(&journal->j_list_lock);\r\nif (commit_transaction->t_forget) {\r\nspin_unlock(&journal->j_list_lock);\r\nwrite_unlock(&journal->j_state_lock);\r\ngoto restart_loop;\r\n}\r\nif (journal->j_checkpoint_transactions == NULL) {\r\njournal->j_checkpoint_transactions = commit_transaction;\r\ncommit_transaction->t_cpnext = commit_transaction;\r\ncommit_transaction->t_cpprev = commit_transaction;\r\n} else {\r\ncommit_transaction->t_cpnext =\r\njournal->j_checkpoint_transactions;\r\ncommit_transaction->t_cpprev =\r\ncommit_transaction->t_cpnext->t_cpprev;\r\ncommit_transaction->t_cpnext->t_cpprev =\r\ncommit_transaction;\r\ncommit_transaction->t_cpprev->t_cpnext =\r\ncommit_transaction;\r\n}\r\nspin_unlock(&journal->j_list_lock);\r\njbd_debug(3, "JBD2: commit phase 7\n");\r\nJ_ASSERT(commit_transaction->t_state == T_COMMIT_JFLUSH);\r\ncommit_transaction->t_start = jiffies;\r\nstats.run.rs_logging = jbd2_time_diff(stats.run.rs_logging,\r\ncommit_transaction->t_start);\r\nstats.ts_tid = commit_transaction->t_tid;\r\nstats.run.rs_handle_count =\r\natomic_read(&commit_transaction->t_handle_count);\r\ntrace_jbd2_run_stats(journal->j_fs_dev->bd_dev,\r\ncommit_transaction->t_tid, &stats.run);\r\nstats.ts_requested = (commit_transaction->t_requested) ? 1 : 0;\r\ncommit_transaction->t_state = T_COMMIT_CALLBACK;\r\nJ_ASSERT(commit_transaction == journal->j_committing_transaction);\r\njournal->j_commit_sequence = commit_transaction->t_tid;\r\njournal->j_committing_transaction = NULL;\r\ncommit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\r\nif (likely(journal->j_average_commit_time))\r\njournal->j_average_commit_time = (commit_time +\r\njournal->j_average_commit_time*3) / 4;\r\nelse\r\njournal->j_average_commit_time = commit_time;\r\nwrite_unlock(&journal->j_state_lock);\r\nif (journal->j_commit_callback)\r\njournal->j_commit_callback(journal, commit_transaction);\r\ntrace_jbd2_end_commit(journal, commit_transaction);\r\njbd_debug(1, "JBD2: commit %d complete, head %d\n",\r\njournal->j_commit_sequence, journal->j_tail_sequence);\r\nwrite_lock(&journal->j_state_lock);\r\nspin_lock(&journal->j_list_lock);\r\ncommit_transaction->t_state = T_FINISHED;\r\nif (commit_transaction->t_checkpoint_list == NULL &&\r\ncommit_transaction->t_checkpoint_io_list == NULL) {\r\n__jbd2_journal_drop_transaction(journal, commit_transaction);\r\njbd2_journal_free_transaction(commit_transaction);\r\n}\r\nspin_unlock(&journal->j_list_lock);\r\nwrite_unlock(&journal->j_state_lock);\r\nwake_up(&journal->j_wait_done_commit);\r\nspin_lock(&journal->j_history_lock);\r\njournal->j_stats.ts_tid++;\r\njournal->j_stats.ts_requested += stats.ts_requested;\r\njournal->j_stats.run.rs_wait += stats.run.rs_wait;\r\njournal->j_stats.run.rs_request_delay += stats.run.rs_request_delay;\r\njournal->j_stats.run.rs_running += stats.run.rs_running;\r\njournal->j_stats.run.rs_locked += stats.run.rs_locked;\r\njournal->j_stats.run.rs_flushing += stats.run.rs_flushing;\r\njournal->j_stats.run.rs_logging += stats.run.rs_logging;\r\njournal->j_stats.run.rs_handle_count += stats.run.rs_handle_count;\r\njournal->j_stats.run.rs_blocks += stats.run.rs_blocks;\r\njournal->j_stats.run.rs_blocks_logged += stats.run.rs_blocks_logged;\r\nspin_unlock(&journal->j_history_lock);\r\n}
