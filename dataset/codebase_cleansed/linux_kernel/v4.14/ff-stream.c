static int get_rate_mode(unsigned int rate, unsigned int *mode)\r\n{\r\nint i;\r\nfor (i = 0; i < CIP_SFC_COUNT; i++) {\r\nif (amdtp_rate_table[i] == rate)\r\nbreak;\r\n}\r\nif (i == CIP_SFC_COUNT)\r\nreturn -EINVAL;\r\n*mode = ((int)i - 1) / 2;\r\nreturn 0;\r\n}\r\nstatic int keep_resources(struct snd_ff *ff, unsigned int rate)\r\n{\r\nint mode;\r\nint err;\r\nerr = get_rate_mode(rate, &mode);\r\nif (err < 0)\r\nreturn err;\r\nerr = amdtp_ff_set_parameters(&ff->tx_stream, rate,\r\nff->spec->pcm_capture_channels[mode]);\r\nif (err < 0)\r\nreturn err;\r\nff->tx_resources.channels_mask = 0x00000000000000ffuLL;\r\nerr = fw_iso_resources_allocate(&ff->tx_resources,\r\namdtp_stream_get_max_payload(&ff->tx_stream),\r\nfw_parent_device(ff->unit)->max_speed);\r\nif (err < 0)\r\nreturn err;\r\nerr = amdtp_ff_set_parameters(&ff->rx_stream, rate,\r\nff->spec->pcm_playback_channels[mode]);\r\nif (err < 0)\r\nreturn err;\r\nff->rx_resources.channels_mask = 0x00000000000000ffuLL;\r\nerr = fw_iso_resources_allocate(&ff->rx_resources,\r\namdtp_stream_get_max_payload(&ff->rx_stream),\r\nfw_parent_device(ff->unit)->max_speed);\r\nif (err < 0)\r\nfw_iso_resources_free(&ff->tx_resources);\r\nreturn err;\r\n}\r\nstatic void release_resources(struct snd_ff *ff)\r\n{\r\nfw_iso_resources_free(&ff->tx_resources);\r\nfw_iso_resources_free(&ff->rx_resources);\r\n}\r\nstatic inline void finish_session(struct snd_ff *ff)\r\n{\r\nff->spec->protocol->finish_session(ff);\r\nff->spec->protocol->switch_fetching_mode(ff, false);\r\n}\r\nstatic int init_stream(struct snd_ff *ff, enum amdtp_stream_direction dir)\r\n{\r\nint err;\r\nstruct fw_iso_resources *resources;\r\nstruct amdtp_stream *stream;\r\nif (dir == AMDTP_IN_STREAM) {\r\nresources = &ff->tx_resources;\r\nstream = &ff->tx_stream;\r\n} else {\r\nresources = &ff->rx_resources;\r\nstream = &ff->rx_stream;\r\n}\r\nerr = fw_iso_resources_init(resources, ff->unit);\r\nif (err < 0)\r\nreturn err;\r\nerr = amdtp_ff_init(stream, ff->unit, dir);\r\nif (err < 0)\r\nfw_iso_resources_destroy(resources);\r\nreturn err;\r\n}\r\nstatic void destroy_stream(struct snd_ff *ff, enum amdtp_stream_direction dir)\r\n{\r\nif (dir == AMDTP_IN_STREAM) {\r\namdtp_stream_destroy(&ff->tx_stream);\r\nfw_iso_resources_destroy(&ff->tx_resources);\r\n} else {\r\namdtp_stream_destroy(&ff->rx_stream);\r\nfw_iso_resources_destroy(&ff->rx_resources);\r\n}\r\n}\r\nint snd_ff_stream_init_duplex(struct snd_ff *ff)\r\n{\r\nint err;\r\nerr = init_stream(ff, AMDTP_OUT_STREAM);\r\nif (err < 0)\r\ngoto end;\r\nerr = init_stream(ff, AMDTP_IN_STREAM);\r\nif (err < 0)\r\ndestroy_stream(ff, AMDTP_OUT_STREAM);\r\nend:\r\nreturn err;\r\n}\r\nvoid snd_ff_stream_destroy_duplex(struct snd_ff *ff)\r\n{\r\ndestroy_stream(ff, AMDTP_IN_STREAM);\r\ndestroy_stream(ff, AMDTP_OUT_STREAM);\r\n}\r\nint snd_ff_stream_start_duplex(struct snd_ff *ff, unsigned int rate)\r\n{\r\nunsigned int curr_rate;\r\nenum snd_ff_clock_src src;\r\nint err;\r\nif (ff->substreams_counter == 0)\r\nreturn 0;\r\nerr = ff->spec->protocol->get_clock(ff, &curr_rate, &src);\r\nif (err < 0)\r\nreturn err;\r\nif (curr_rate != rate ||\r\namdtp_streaming_error(&ff->tx_stream) ||\r\namdtp_streaming_error(&ff->rx_stream)) {\r\nfinish_session(ff);\r\namdtp_stream_stop(&ff->tx_stream);\r\namdtp_stream_stop(&ff->rx_stream);\r\nrelease_resources(ff);\r\n}\r\nif (!amdtp_stream_running(&ff->rx_stream)) {\r\nerr = keep_resources(ff, rate);\r\nif (err < 0)\r\ngoto error;\r\nerr = ff->spec->protocol->begin_session(ff, rate);\r\nif (err < 0)\r\ngoto error;\r\nerr = amdtp_stream_start(&ff->rx_stream,\r\nff->rx_resources.channel,\r\nfw_parent_device(ff->unit)->max_speed);\r\nif (err < 0)\r\ngoto error;\r\nif (!amdtp_stream_wait_callback(&ff->rx_stream,\r\nCALLBACK_TIMEOUT_MS)) {\r\nerr = -ETIMEDOUT;\r\ngoto error;\r\n}\r\nerr = ff->spec->protocol->switch_fetching_mode(ff, true);\r\nif (err < 0)\r\ngoto error;\r\n}\r\nif (!amdtp_stream_running(&ff->tx_stream)) {\r\nerr = amdtp_stream_start(&ff->tx_stream,\r\nff->tx_resources.channel,\r\nfw_parent_device(ff->unit)->max_speed);\r\nif (err < 0)\r\ngoto error;\r\nif (!amdtp_stream_wait_callback(&ff->tx_stream,\r\nCALLBACK_TIMEOUT_MS)) {\r\nerr = -ETIMEDOUT;\r\ngoto error;\r\n}\r\n}\r\nreturn 0;\r\nerror:\r\namdtp_stream_stop(&ff->tx_stream);\r\namdtp_stream_stop(&ff->rx_stream);\r\nfinish_session(ff);\r\nrelease_resources(ff);\r\nreturn err;\r\n}\r\nvoid snd_ff_stream_stop_duplex(struct snd_ff *ff)\r\n{\r\nif (ff->substreams_counter > 0)\r\nreturn;\r\namdtp_stream_stop(&ff->tx_stream);\r\namdtp_stream_stop(&ff->rx_stream);\r\nfinish_session(ff);\r\nrelease_resources(ff);\r\n}\r\nvoid snd_ff_stream_update_duplex(struct snd_ff *ff)\r\n{\r\namdtp_stream_pcm_abort(&ff->tx_stream);\r\namdtp_stream_stop(&ff->tx_stream);\r\namdtp_stream_pcm_abort(&ff->rx_stream);\r\namdtp_stream_stop(&ff->rx_stream);\r\nfw_iso_resources_update(&ff->tx_resources);\r\nfw_iso_resources_update(&ff->rx_resources);\r\n}\r\nvoid snd_ff_stream_lock_changed(struct snd_ff *ff)\r\n{\r\nff->dev_lock_changed = true;\r\nwake_up(&ff->hwdep_wait);\r\n}\r\nint snd_ff_stream_lock_try(struct snd_ff *ff)\r\n{\r\nint err;\r\nspin_lock_irq(&ff->lock);\r\nif (ff->dev_lock_count < 0) {\r\nerr = -EBUSY;\r\ngoto end;\r\n}\r\nif (ff->dev_lock_count++ == 0)\r\nsnd_ff_stream_lock_changed(ff);\r\nerr = 0;\r\nend:\r\nspin_unlock_irq(&ff->lock);\r\nreturn err;\r\n}\r\nvoid snd_ff_stream_lock_release(struct snd_ff *ff)\r\n{\r\nspin_lock_irq(&ff->lock);\r\nif (WARN_ON(ff->dev_lock_count <= 0))\r\ngoto end;\r\nif (--ff->dev_lock_count == 0)\r\nsnd_ff_stream_lock_changed(ff);\r\nend:\r\nspin_unlock_irq(&ff->lock);\r\n}
