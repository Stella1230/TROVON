void cdn_dp_set_fw_clk(struct cdn_dp_device *dp, unsigned long clk)\r\n{\r\nwritel(clk / 1000000, dp->regs + SW_CLK_H);\r\n}\r\nvoid cdn_dp_clock_reset(struct cdn_dp_device *dp)\r\n{\r\nu32 val;\r\nval = DPTX_FRMR_DATA_CLK_RSTN_EN |\r\nDPTX_FRMR_DATA_CLK_EN |\r\nDPTX_PHY_DATA_RSTN_EN |\r\nDPTX_PHY_DATA_CLK_EN |\r\nDPTX_PHY_CHAR_RSTN_EN |\r\nDPTX_PHY_CHAR_CLK_EN |\r\nSOURCE_AUX_SYS_CLK_RSTN_EN |\r\nSOURCE_AUX_SYS_CLK_EN |\r\nDPTX_SYS_CLK_RSTN_EN |\r\nDPTX_SYS_CLK_EN |\r\nCFG_DPTX_VIF_CLK_RSTN_EN |\r\nCFG_DPTX_VIF_CLK_EN;\r\nwritel(val, dp->regs + SOURCE_DPTX_CAR);\r\nval = SOURCE_PHY_RSTN_EN | SOURCE_PHY_CLK_EN;\r\nwritel(val, dp->regs + SOURCE_PHY_CAR);\r\nval = SOURCE_PKT_SYS_RSTN_EN |\r\nSOURCE_PKT_SYS_CLK_EN |\r\nSOURCE_PKT_DATA_RSTN_EN |\r\nSOURCE_PKT_DATA_CLK_EN;\r\nwritel(val, dp->regs + SOURCE_PKT_CAR);\r\nval = SPDIF_CDR_CLK_RSTN_EN |\r\nSPDIF_CDR_CLK_EN |\r\nSOURCE_AIF_SYS_RSTN_EN |\r\nSOURCE_AIF_SYS_CLK_EN |\r\nSOURCE_AIF_CLK_RSTN_EN |\r\nSOURCE_AIF_CLK_EN;\r\nwritel(val, dp->regs + SOURCE_AIF_CAR);\r\nval = SOURCE_CIPHER_SYSTEM_CLK_RSTN_EN |\r\nSOURCE_CIPHER_SYS_CLK_EN |\r\nSOURCE_CIPHER_CHAR_CLK_RSTN_EN |\r\nSOURCE_CIPHER_CHAR_CLK_EN;\r\nwritel(val, dp->regs + SOURCE_CIPHER_CAR);\r\nval = SOURCE_CRYPTO_SYS_CLK_RSTN_EN |\r\nSOURCE_CRYPTO_SYS_CLK_EN;\r\nwritel(val, dp->regs + SOURCE_CRYPTO_CAR);\r\nwritel(0, dp->regs + APB_INT_MASK);\r\n}\r\nstatic int cdn_dp_mailbox_read(struct cdn_dp_device *dp)\r\n{\r\nint val, ret;\r\nret = readx_poll_timeout(readl, dp->regs + MAILBOX_EMPTY_ADDR,\r\nval, !val, MAILBOX_RETRY_US,\r\nMAILBOX_TIMEOUT_US);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn readl(dp->regs + MAILBOX0_RD_DATA) & 0xff;\r\n}\r\nstatic int cdp_dp_mailbox_write(struct cdn_dp_device *dp, u8 val)\r\n{\r\nint ret, full;\r\nret = readx_poll_timeout(readl, dp->regs + MAILBOX_FULL_ADDR,\r\nfull, !full, MAILBOX_RETRY_US,\r\nMAILBOX_TIMEOUT_US);\r\nif (ret < 0)\r\nreturn ret;\r\nwritel(val, dp->regs + MAILBOX0_WR_DATA);\r\nreturn 0;\r\n}\r\nstatic int cdn_dp_mailbox_validate_receive(struct cdn_dp_device *dp,\r\nu8 module_id, u8 opcode,\r\nu8 req_size)\r\n{\r\nu32 mbox_size, i;\r\nu8 header[4];\r\nint ret;\r\nfor (i = 0; i < 4; i++) {\r\nret = cdn_dp_mailbox_read(dp);\r\nif (ret < 0)\r\nreturn ret;\r\nheader[i] = ret;\r\n}\r\nmbox_size = (header[2] << 8) | header[3];\r\nif (opcode != header[0] || module_id != header[1] ||\r\nreq_size != mbox_size) {\r\nfor (i = 0; i < mbox_size; i++)\r\nif (cdn_dp_mailbox_read(dp) < 0)\r\nbreak;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cdn_dp_mailbox_read_receive(struct cdn_dp_device *dp,\r\nu8 *buff, u8 buff_size)\r\n{\r\nu32 i;\r\nint ret;\r\nfor (i = 0; i < buff_size; i++) {\r\nret = cdn_dp_mailbox_read(dp);\r\nif (ret < 0)\r\nreturn ret;\r\nbuff[i] = ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cdn_dp_mailbox_send(struct cdn_dp_device *dp, u8 module_id,\r\nu8 opcode, u16 size, u8 *message)\r\n{\r\nu8 header[4];\r\nint ret, i;\r\nheader[0] = opcode;\r\nheader[1] = module_id;\r\nheader[2] = (size >> 8) & 0xff;\r\nheader[3] = size & 0xff;\r\nfor (i = 0; i < 4; i++) {\r\nret = cdp_dp_mailbox_write(dp, header[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < size; i++) {\r\nret = cdp_dp_mailbox_write(dp, message[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cdn_dp_reg_write(struct cdn_dp_device *dp, u16 addr, u32 val)\r\n{\r\nu8 msg[6];\r\nmsg[0] = (addr >> 8) & 0xff;\r\nmsg[1] = addr & 0xff;\r\nmsg[2] = (val >> 24) & 0xff;\r\nmsg[3] = (val >> 16) & 0xff;\r\nmsg[4] = (val >> 8) & 0xff;\r\nmsg[5] = val & 0xff;\r\nreturn cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_WRITE_REGISTER,\r\nsizeof(msg), msg);\r\n}\r\nstatic int cdn_dp_reg_write_bit(struct cdn_dp_device *dp, u16 addr,\r\nu8 start_bit, u8 bits_no, u32 val)\r\n{\r\nu8 field[8];\r\nfield[0] = (addr >> 8) & 0xff;\r\nfield[1] = addr & 0xff;\r\nfield[2] = start_bit;\r\nfield[3] = bits_no;\r\nfield[4] = (val >> 24) & 0xff;\r\nfield[5] = (val >> 16) & 0xff;\r\nfield[6] = (val >> 8) & 0xff;\r\nfield[7] = val & 0xff;\r\nreturn cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_WRITE_FIELD,\r\nsizeof(field), field);\r\n}\r\nint cdn_dp_dpcd_read(struct cdn_dp_device *dp, u32 addr, u8 *data, u16 len)\r\n{\r\nu8 msg[5], reg[5];\r\nint ret;\r\nmsg[0] = (len >> 8) & 0xff;\r\nmsg[1] = len & 0xff;\r\nmsg[2] = (addr >> 16) & 0xff;\r\nmsg[3] = (addr >> 8) & 0xff;\r\nmsg[4] = addr & 0xff;\r\nret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_READ_DPCD,\r\nsizeof(msg), msg);\r\nif (ret)\r\ngoto err_dpcd_read;\r\nret = cdn_dp_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,\r\nDPTX_READ_DPCD,\r\nsizeof(reg) + len);\r\nif (ret)\r\ngoto err_dpcd_read;\r\nret = cdn_dp_mailbox_read_receive(dp, reg, sizeof(reg));\r\nif (ret)\r\ngoto err_dpcd_read;\r\nret = cdn_dp_mailbox_read_receive(dp, data, len);\r\nerr_dpcd_read:\r\nreturn ret;\r\n}\r\nint cdn_dp_dpcd_write(struct cdn_dp_device *dp, u32 addr, u8 value)\r\n{\r\nu8 msg[6], reg[5];\r\nint ret;\r\nmsg[0] = 0;\r\nmsg[1] = 1;\r\nmsg[2] = (addr >> 16) & 0xff;\r\nmsg[3] = (addr >> 8) & 0xff;\r\nmsg[4] = addr & 0xff;\r\nmsg[5] = value;\r\nret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_WRITE_DPCD,\r\nsizeof(msg), msg);\r\nif (ret)\r\ngoto err_dpcd_write;\r\nret = cdn_dp_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,\r\nDPTX_WRITE_DPCD, sizeof(reg));\r\nif (ret)\r\ngoto err_dpcd_write;\r\nret = cdn_dp_mailbox_read_receive(dp, reg, sizeof(reg));\r\nif (ret)\r\ngoto err_dpcd_write;\r\nif (addr != (reg[2] << 16 | reg[3] << 8 | reg[4]))\r\nret = -EINVAL;\r\nerr_dpcd_write:\r\nif (ret)\r\nDRM_DEV_ERROR(dp->dev, "dpcd write failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nint cdn_dp_load_firmware(struct cdn_dp_device *dp, const u32 *i_mem,\r\nu32 i_size, const u32 *d_mem, u32 d_size)\r\n{\r\nu32 reg;\r\nint i, ret;\r\nwritel(APB_IRAM_PATH | APB_DRAM_PATH | APB_XT_RESET,\r\ndp->regs + APB_CTRL);\r\nfor (i = 0; i < i_size; i += 4)\r\nwritel(*i_mem++, dp->regs + ADDR_IMEM + i);\r\nfor (i = 0; i < d_size; i += 4)\r\nwritel(*d_mem++, dp->regs + ADDR_DMEM + i);\r\nwritel(0, dp->regs + APB_CTRL);\r\nret = readx_poll_timeout(readl, dp->regs + KEEP_ALIVE,\r\nreg, reg, 2000, FW_ALIVE_TIMEOUT_US);\r\nif (ret < 0) {\r\nDRM_DEV_ERROR(dp->dev, "failed to loaded the FW reg = %x\n",\r\nreg);\r\nreturn -EINVAL;\r\n}\r\nreg = readl(dp->regs + VER_L) & 0xff;\r\ndp->fw_version = reg;\r\nreg = readl(dp->regs + VER_H) & 0xff;\r\ndp->fw_version |= reg << 8;\r\nreg = readl(dp->regs + VER_LIB_L_ADDR) & 0xff;\r\ndp->fw_version |= reg << 16;\r\nreg = readl(dp->regs + VER_LIB_H_ADDR) & 0xff;\r\ndp->fw_version |= reg << 24;\r\ndev_dbg(dp->dev, "firmware version: %x\n", dp->fw_version);\r\nreturn 0;\r\n}\r\nint cdn_dp_set_firmware_active(struct cdn_dp_device *dp, bool enable)\r\n{\r\nu8 msg[5];\r\nint ret, i;\r\nmsg[0] = GENERAL_MAIN_CONTROL;\r\nmsg[1] = MB_MODULE_ID_GENERAL;\r\nmsg[2] = 0;\r\nmsg[3] = 1;\r\nmsg[4] = enable ? FW_ACTIVE : FW_STANDBY;\r\nfor (i = 0; i < sizeof(msg); i++) {\r\nret = cdp_dp_mailbox_write(dp, msg[i]);\r\nif (ret)\r\ngoto err_set_firmware_active;\r\n}\r\nfor (i = 0; i < sizeof(msg); i++) {\r\nret = cdn_dp_mailbox_read(dp);\r\nif (ret < 0)\r\ngoto err_set_firmware_active;\r\nmsg[i] = ret;\r\n}\r\nret = 0;\r\nerr_set_firmware_active:\r\nif (ret < 0)\r\nDRM_DEV_ERROR(dp->dev, "set firmware active failed\n");\r\nreturn ret;\r\n}\r\nint cdn_dp_set_host_cap(struct cdn_dp_device *dp, u8 lanes, bool flip)\r\n{\r\nu8 msg[8];\r\nint ret;\r\nmsg[0] = CDN_DP_MAX_LINK_RATE;\r\nmsg[1] = lanes | SCRAMBLER_EN;\r\nmsg[2] = VOLTAGE_LEVEL_2;\r\nmsg[3] = PRE_EMPHASIS_LEVEL_3;\r\nmsg[4] = PTS1 | PTS2 | PTS3 | PTS4;\r\nmsg[5] = FAST_LT_NOT_SUPPORT;\r\nmsg[6] = flip ? LANE_MAPPING_FLIPPED : LANE_MAPPING_NORMAL;\r\nmsg[7] = ENHANCED;\r\nret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX,\r\nDPTX_SET_HOST_CAPABILITIES,\r\nsizeof(msg), msg);\r\nif (ret)\r\ngoto err_set_host_cap;\r\nret = cdn_dp_reg_write(dp, DP_AUX_SWAP_INVERSION_CONTROL,\r\nAUX_HOST_INVERT);\r\nerr_set_host_cap:\r\nif (ret)\r\nDRM_DEV_ERROR(dp->dev, "set host cap failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nint cdn_dp_event_config(struct cdn_dp_device *dp)\r\n{\r\nu8 msg[5];\r\nint ret;\r\nmemset(msg, 0, sizeof(msg));\r\nmsg[0] = DPTX_EVENT_ENABLE_HPD | DPTX_EVENT_ENABLE_TRAINING;\r\nret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_ENABLE_EVENT,\r\nsizeof(msg), msg);\r\nif (ret)\r\nDRM_DEV_ERROR(dp->dev, "set event config failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nu32 cdn_dp_get_event(struct cdn_dp_device *dp)\r\n{\r\nreturn readl(dp->regs + SW_EVENTS0);\r\n}\r\nint cdn_dp_get_hpd_status(struct cdn_dp_device *dp)\r\n{\r\nu8 status;\r\nint ret;\r\nret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_HPD_STATE,\r\n0, NULL);\r\nif (ret)\r\ngoto err_get_hpd;\r\nret = cdn_dp_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,\r\nDPTX_HPD_STATE, sizeof(status));\r\nif (ret)\r\ngoto err_get_hpd;\r\nret = cdn_dp_mailbox_read_receive(dp, &status, sizeof(status));\r\nif (ret)\r\ngoto err_get_hpd;\r\nreturn status;\r\nerr_get_hpd:\r\nDRM_DEV_ERROR(dp->dev, "get hpd status failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nint cdn_dp_get_edid_block(void *data, u8 *edid,\r\nunsigned int block, size_t length)\r\n{\r\nstruct cdn_dp_device *dp = data;\r\nu8 msg[2], reg[2], i;\r\nint ret;\r\nfor (i = 0; i < 4; i++) {\r\nmsg[0] = block / 2;\r\nmsg[1] = block % 2;\r\nret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_GET_EDID,\r\nsizeof(msg), msg);\r\nif (ret)\r\ncontinue;\r\nret = cdn_dp_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,\r\nDPTX_GET_EDID,\r\nsizeof(reg) + length);\r\nif (ret)\r\ncontinue;\r\nret = cdn_dp_mailbox_read_receive(dp, reg, sizeof(reg));\r\nif (ret)\r\ncontinue;\r\nret = cdn_dp_mailbox_read_receive(dp, edid, length);\r\nif (ret)\r\ncontinue;\r\nif (reg[0] == length && reg[1] == block / 2)\r\nbreak;\r\n}\r\nif (ret)\r\nDRM_DEV_ERROR(dp->dev, "get block[%d] edid failed: %d\n", block,\r\nret);\r\nreturn ret;\r\n}\r\nstatic int cdn_dp_training_start(struct cdn_dp_device *dp)\r\n{\r\nunsigned long timeout;\r\nu8 msg, event[2];\r\nint ret;\r\nmsg = LINK_TRAINING_RUN;\r\nret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_TRAINING_CONTROL,\r\nsizeof(msg), &msg);\r\nif (ret)\r\ngoto err_training_start;\r\ntimeout = jiffies + msecs_to_jiffies(LINK_TRAINING_TIMEOUT_MS);\r\nwhile (time_before(jiffies, timeout)) {\r\nmsleep(LINK_TRAINING_RETRY_MS);\r\nret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX,\r\nDPTX_READ_EVENT, 0, NULL);\r\nif (ret)\r\ngoto err_training_start;\r\nret = cdn_dp_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,\r\nDPTX_READ_EVENT,\r\nsizeof(event));\r\nif (ret)\r\ngoto err_training_start;\r\nret = cdn_dp_mailbox_read_receive(dp, event, sizeof(event));\r\nif (ret)\r\ngoto err_training_start;\r\nif (event[1] & EQ_PHASE_FINISHED)\r\nreturn 0;\r\n}\r\nret = -ETIMEDOUT;\r\nerr_training_start:\r\nDRM_DEV_ERROR(dp->dev, "training failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int cdn_dp_get_training_status(struct cdn_dp_device *dp)\r\n{\r\nu8 status[10];\r\nint ret;\r\nret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_READ_LINK_STAT,\r\n0, NULL);\r\nif (ret)\r\ngoto err_get_training_status;\r\nret = cdn_dp_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,\r\nDPTX_READ_LINK_STAT,\r\nsizeof(status));\r\nif (ret)\r\ngoto err_get_training_status;\r\nret = cdn_dp_mailbox_read_receive(dp, status, sizeof(status));\r\nif (ret)\r\ngoto err_get_training_status;\r\ndp->link.rate = status[0];\r\ndp->link.num_lanes = status[1];\r\nerr_get_training_status:\r\nif (ret)\r\nDRM_DEV_ERROR(dp->dev, "get training status failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nint cdn_dp_train_link(struct cdn_dp_device *dp)\r\n{\r\nint ret;\r\nret = cdn_dp_training_start(dp);\r\nif (ret) {\r\nDRM_DEV_ERROR(dp->dev, "Failed to start training %d\n", ret);\r\nreturn ret;\r\n}\r\nret = cdn_dp_get_training_status(dp);\r\nif (ret) {\r\nDRM_DEV_ERROR(dp->dev, "Failed to get training stat %d\n", ret);\r\nreturn ret;\r\n}\r\nDRM_DEV_DEBUG_KMS(dp->dev, "rate:0x%x, lanes:%d\n", dp->link.rate,\r\ndp->link.num_lanes);\r\nreturn ret;\r\n}\r\nint cdn_dp_set_video_status(struct cdn_dp_device *dp, int active)\r\n{\r\nu8 msg;\r\nint ret;\r\nmsg = !!active;\r\nret = cdn_dp_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_SET_VIDEO,\r\nsizeof(msg), &msg);\r\nif (ret)\r\nDRM_DEV_ERROR(dp->dev, "set video status failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int cdn_dp_get_msa_misc(struct video_info *video,\r\nstruct drm_display_mode *mode)\r\n{\r\nu32 msa_misc;\r\nu8 val[2] = {0};\r\nswitch (video->color_fmt) {\r\ncase PXL_RGB:\r\ncase Y_ONLY:\r\nval[0] = 0;\r\nbreak;\r\ncase YCBCR_4_4_4:\r\nval[0] = 6 + BT_601 * 8;\r\nbreak;\r\ncase YCBCR_4_2_2:\r\nval[0] = 5 + BT_601 * 8;\r\nbreak;\r\ncase YCBCR_4_2_0:\r\nval[0] = 5;\r\nbreak;\r\n};\r\nswitch (video->color_depth) {\r\ncase 6:\r\nval[1] = 0;\r\nbreak;\r\ncase 8:\r\nval[1] = 1;\r\nbreak;\r\ncase 10:\r\nval[1] = 2;\r\nbreak;\r\ncase 12:\r\nval[1] = 3;\r\nbreak;\r\ncase 16:\r\nval[1] = 4;\r\nbreak;\r\n};\r\nmsa_misc = 2 * val[0] + 32 * val[1] +\r\n((video->color_fmt == Y_ONLY) ? (1 << 14) : 0);\r\nreturn msa_misc;\r\n}\r\nint cdn_dp_config_video(struct cdn_dp_device *dp)\r\n{\r\nstruct video_info *video = &dp->video_info;\r\nstruct drm_display_mode *mode = &dp->mode;\r\nu64 symbol;\r\nu32 val, link_rate, rem;\r\nu8 bit_per_pix, tu_size_reg = TU_SIZE;\r\nint ret;\r\nbit_per_pix = (video->color_fmt == YCBCR_4_2_2) ?\r\n(video->color_depth * 2) : (video->color_depth * 3);\r\nlink_rate = drm_dp_bw_code_to_link_rate(dp->link.rate) / 1000;\r\nret = cdn_dp_reg_write(dp, BND_HSYNC2VSYNC, VIF_BYPASS_INTERLACE);\r\nif (ret)\r\ngoto err_config_video;\r\nret = cdn_dp_reg_write(dp, HSYNC2VSYNC_POL_CTRL, 0);\r\nif (ret)\r\ngoto err_config_video;\r\ndo {\r\ntu_size_reg += 2;\r\nsymbol = tu_size_reg * mode->clock * bit_per_pix;\r\ndo_div(symbol, dp->link.num_lanes * link_rate * 8);\r\nrem = do_div(symbol, 1000);\r\nif (tu_size_reg > 64) {\r\nret = -EINVAL;\r\nDRM_DEV_ERROR(dp->dev,\r\n"tu error, clk:%d, lanes:%d, rate:%d\n",\r\nmode->clock, dp->link.num_lanes,\r\nlink_rate);\r\ngoto err_config_video;\r\n}\r\n} while ((symbol <= 1) || (tu_size_reg - symbol < 4) ||\r\n(rem > 850) || (rem < 100));\r\nval = symbol + (tu_size_reg << 8);\r\nval |= TU_CNT_RST_EN;\r\nret = cdn_dp_reg_write(dp, DP_FRAMER_TU, val);\r\nif (ret)\r\ngoto err_config_video;\r\nval = div_u64(mode->clock * (symbol + 1), 1000) + link_rate;\r\nval /= (dp->link.num_lanes * link_rate);\r\nval = div_u64(8 * (symbol + 1), bit_per_pix) - val;\r\nval += 2;\r\nret = cdn_dp_reg_write(dp, DP_VC_TABLE(15), val);\r\nswitch (video->color_depth) {\r\ncase 6:\r\nval = BCS_6;\r\nbreak;\r\ncase 8:\r\nval = BCS_8;\r\nbreak;\r\ncase 10:\r\nval = BCS_10;\r\nbreak;\r\ncase 12:\r\nval = BCS_12;\r\nbreak;\r\ncase 16:\r\nval = BCS_16;\r\nbreak;\r\n};\r\nval += video->color_fmt << 8;\r\nret = cdn_dp_reg_write(dp, DP_FRAMER_PXL_REPR, val);\r\nif (ret)\r\ngoto err_config_video;\r\nval = video->h_sync_polarity ? DP_FRAMER_SP_HSP : 0;\r\nval |= video->v_sync_polarity ? DP_FRAMER_SP_VSP : 0;\r\nret = cdn_dp_reg_write(dp, DP_FRAMER_SP, val);\r\nif (ret)\r\ngoto err_config_video;\r\nval = (mode->hsync_start - mode->hdisplay) << 16;\r\nval |= mode->htotal - mode->hsync_end;\r\nret = cdn_dp_reg_write(dp, DP_FRONT_BACK_PORCH, val);\r\nif (ret)\r\ngoto err_config_video;\r\nval = mode->hdisplay * bit_per_pix / 8;\r\nret = cdn_dp_reg_write(dp, DP_BYTE_COUNT, val);\r\nif (ret)\r\ngoto err_config_video;\r\nval = mode->htotal | ((mode->htotal - mode->hsync_start) << 16);\r\nret = cdn_dp_reg_write(dp, MSA_HORIZONTAL_0, val);\r\nif (ret)\r\ngoto err_config_video;\r\nval = mode->hsync_end - mode->hsync_start;\r\nval |= (mode->hdisplay << 16) | (video->h_sync_polarity << 15);\r\nret = cdn_dp_reg_write(dp, MSA_HORIZONTAL_1, val);\r\nif (ret)\r\ngoto err_config_video;\r\nval = mode->vtotal;\r\nval |= (mode->vtotal - mode->vsync_start) << 16;\r\nret = cdn_dp_reg_write(dp, MSA_VERTICAL_0, val);\r\nif (ret)\r\ngoto err_config_video;\r\nval = mode->vsync_end - mode->vsync_start;\r\nval |= (mode->vdisplay << 16) | (video->v_sync_polarity << 15);\r\nret = cdn_dp_reg_write(dp, MSA_VERTICAL_1, val);\r\nif (ret)\r\ngoto err_config_video;\r\nval = cdn_dp_get_msa_misc(video, mode);\r\nret = cdn_dp_reg_write(dp, MSA_MISC, val);\r\nif (ret)\r\ngoto err_config_video;\r\nret = cdn_dp_reg_write(dp, STREAM_CONFIG, 1);\r\nif (ret)\r\ngoto err_config_video;\r\nval = mode->hsync_end - mode->hsync_start;\r\nval |= mode->hdisplay << 16;\r\nret = cdn_dp_reg_write(dp, DP_HORIZONTAL, val);\r\nif (ret)\r\ngoto err_config_video;\r\nval = mode->vdisplay;\r\nval |= (mode->vtotal - mode->vsync_start) << 16;\r\nret = cdn_dp_reg_write(dp, DP_VERTICAL_0, val);\r\nif (ret)\r\ngoto err_config_video;\r\nval = mode->vtotal;\r\nret = cdn_dp_reg_write(dp, DP_VERTICAL_1, val);\r\nif (ret)\r\ngoto err_config_video;\r\nret = cdn_dp_reg_write_bit(dp, DP_VB_ID, 2, 1, 0);\r\nerr_config_video:\r\nif (ret)\r\nDRM_DEV_ERROR(dp->dev, "config video failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nint cdn_dp_audio_stop(struct cdn_dp_device *dp, struct audio_info *audio)\r\n{\r\nu32 val;\r\nint ret;\r\nret = cdn_dp_reg_write(dp, AUDIO_PACK_CONTROL, 0);\r\nif (ret) {\r\nDRM_DEV_ERROR(dp->dev, "audio stop failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nval = SPDIF_AVG_SEL | SPDIF_JITTER_BYPASS;\r\nval |= SPDIF_FIFO_MID_RANGE(0xe0);\r\nval |= SPDIF_JITTER_THRSH(0xe0);\r\nval |= SPDIF_JITTER_AVG_WIN(7);\r\nwritel(val, dp->regs + SPDIF_CTRL_ADDR);\r\nwritel(0, dp->regs + AUDIO_SRC_CNTL);\r\nwritel(0, dp->regs + AUDIO_SRC_CNFG);\r\nwritel(AUDIO_SW_RST, dp->regs + AUDIO_SRC_CNTL);\r\nwritel(0, dp->regs + AUDIO_SRC_CNTL);\r\nwritel(0, dp->regs + SMPL2PKT_CNTL);\r\nwritel(AUDIO_SW_RST, dp->regs + SMPL2PKT_CNTL);\r\nwritel(0, dp->regs + SMPL2PKT_CNTL);\r\nwritel(AUDIO_SW_RST, dp->regs + FIFO_CNTL);\r\nwritel(0, dp->regs + FIFO_CNTL);\r\nif (audio->format == AFMT_SPDIF)\r\nclk_disable_unprepare(dp->spdif_clk);\r\nreturn 0;\r\n}\r\nint cdn_dp_audio_mute(struct cdn_dp_device *dp, bool enable)\r\n{\r\nint ret;\r\nret = cdn_dp_reg_write_bit(dp, DP_VB_ID, 4, 1, enable);\r\nif (ret)\r\nDRM_DEV_ERROR(dp->dev, "audio mute failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void cdn_dp_audio_config_i2s(struct cdn_dp_device *dp,\r\nstruct audio_info *audio)\r\n{\r\nint sub_pckt_num = 1, i2s_port_en_val = 0xf, i;\r\nu32 val;\r\nif (audio->channels == 2) {\r\nif (dp->link.num_lanes == 1)\r\nsub_pckt_num = 2;\r\nelse\r\nsub_pckt_num = 4;\r\ni2s_port_en_val = 1;\r\n} else if (audio->channels == 4) {\r\ni2s_port_en_val = 3;\r\n}\r\nwritel(0x0, dp->regs + SPDIF_CTRL_ADDR);\r\nwritel(SYNC_WR_TO_CH_ZERO, dp->regs + FIFO_CNTL);\r\nval = MAX_NUM_CH(audio->channels);\r\nval |= NUM_OF_I2S_PORTS(audio->channels);\r\nval |= AUDIO_TYPE_LPCM;\r\nval |= CFG_SUB_PCKT_NUM(sub_pckt_num);\r\nwritel(val, dp->regs + SMPL2PKT_CNFG);\r\nif (audio->sample_width == 16)\r\nval = 0;\r\nelse if (audio->sample_width == 24)\r\nval = 1 << 9;\r\nelse\r\nval = 2 << 9;\r\nval |= AUDIO_CH_NUM(audio->channels);\r\nval |= I2S_DEC_PORT_EN(i2s_port_en_val);\r\nval |= TRANS_SMPL_WIDTH_32;\r\nwritel(val, dp->regs + AUDIO_SRC_CNFG);\r\nfor (i = 0; i < (audio->channels + 1) / 2; i++) {\r\nif (audio->sample_width == 16)\r\nval = (0x02 << 8) | (0x02 << 20);\r\nelse if (audio->sample_width == 24)\r\nval = (0x0b << 8) | (0x0b << 20);\r\nval |= ((2 * i) << 4) | ((2 * i + 1) << 16);\r\nwritel(val, dp->regs + STTS_BIT_CH(i));\r\n}\r\nswitch (audio->sample_rate) {\r\ncase 32000:\r\nval = SAMPLING_FREQ(3) |\r\nORIGINAL_SAMP_FREQ(0xc);\r\nbreak;\r\ncase 44100:\r\nval = SAMPLING_FREQ(0) |\r\nORIGINAL_SAMP_FREQ(0xf);\r\nbreak;\r\ncase 48000:\r\nval = SAMPLING_FREQ(2) |\r\nORIGINAL_SAMP_FREQ(0xd);\r\nbreak;\r\ncase 88200:\r\nval = SAMPLING_FREQ(8) |\r\nORIGINAL_SAMP_FREQ(0x7);\r\nbreak;\r\ncase 96000:\r\nval = SAMPLING_FREQ(0xa) |\r\nORIGINAL_SAMP_FREQ(5);\r\nbreak;\r\ncase 176400:\r\nval = SAMPLING_FREQ(0xc) |\r\nORIGINAL_SAMP_FREQ(3);\r\nbreak;\r\ncase 192000:\r\nval = SAMPLING_FREQ(0xe) |\r\nORIGINAL_SAMP_FREQ(1);\r\nbreak;\r\n}\r\nval |= 4;\r\nwritel(val, dp->regs + COM_CH_STTS_BITS);\r\nwritel(SMPL2PKT_EN, dp->regs + SMPL2PKT_CNTL);\r\nwritel(I2S_DEC_START, dp->regs + AUDIO_SRC_CNTL);\r\n}\r\nstatic void cdn_dp_audio_config_spdif(struct cdn_dp_device *dp)\r\n{\r\nu32 val;\r\nval = SPDIF_AVG_SEL | SPDIF_JITTER_BYPASS;\r\nval |= SPDIF_FIFO_MID_RANGE(0xe0);\r\nval |= SPDIF_JITTER_THRSH(0xe0);\r\nval |= SPDIF_JITTER_AVG_WIN(7);\r\nwritel(val, dp->regs + SPDIF_CTRL_ADDR);\r\nwritel(SYNC_WR_TO_CH_ZERO, dp->regs + FIFO_CNTL);\r\nval = MAX_NUM_CH(2) | AUDIO_TYPE_LPCM | CFG_SUB_PCKT_NUM(4);\r\nwritel(val, dp->regs + SMPL2PKT_CNFG);\r\nwritel(SMPL2PKT_EN, dp->regs + SMPL2PKT_CNTL);\r\nval = SPDIF_ENABLE | SPDIF_AVG_SEL | SPDIF_JITTER_BYPASS;\r\nval |= SPDIF_FIFO_MID_RANGE(0xe0);\r\nval |= SPDIF_JITTER_THRSH(0xe0);\r\nval |= SPDIF_JITTER_AVG_WIN(7);\r\nwritel(val, dp->regs + SPDIF_CTRL_ADDR);\r\nclk_prepare_enable(dp->spdif_clk);\r\nclk_set_rate(dp->spdif_clk, CDN_DP_SPDIF_CLK);\r\n}\r\nint cdn_dp_audio_config(struct cdn_dp_device *dp, struct audio_info *audio)\r\n{\r\nint ret;\r\nif (audio->format == AFMT_SPDIF) {\r\nreset_control_assert(dp->spdif_rst);\r\nreset_control_deassert(dp->spdif_rst);\r\n}\r\nret = cdn_dp_reg_write(dp, CM_LANE_CTRL, LANE_REF_CYC);\r\nif (ret)\r\ngoto err_audio_config;\r\nret = cdn_dp_reg_write(dp, CM_CTRL, 0);\r\nif (ret)\r\ngoto err_audio_config;\r\nif (audio->format == AFMT_I2S)\r\ncdn_dp_audio_config_i2s(dp, audio);\r\nelse if (audio->format == AFMT_SPDIF)\r\ncdn_dp_audio_config_spdif(dp);\r\nret = cdn_dp_reg_write(dp, AUDIO_PACK_CONTROL, AUDIO_PACK_EN);\r\nerr_audio_config:\r\nif (ret)\r\nDRM_DEV_ERROR(dp->dev, "audio config failed: %d\n", ret);\r\nreturn ret;\r\n}
