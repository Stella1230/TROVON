static int tonga_get_dependecy_volt_by_clk(struct pp_hwmgr *hwmgr,\r\nphm_ppt_v1_clock_voltage_dependency_table *allowed_clock_voltage_table,\r\nuint32_t clock, SMU_VoltageLevel *voltage, uint32_t *mvdd)\r\n{\r\nuint32_t i = 0;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct phm_ppt_v1_information *pptable_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nif (allowed_clock_voltage_table->count == 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < allowed_clock_voltage_table->count; i++) {\r\nif (allowed_clock_voltage_table->entries[i].clk >= clock) {\r\nvoltage->VddGfx = phm_get_voltage_index(\r\npptable_info->vddgfx_lookup_table,\r\nallowed_clock_voltage_table->entries[i].vddgfx);\r\nvoltage->Vddc = phm_get_voltage_index(\r\npptable_info->vddc_lookup_table,\r\nallowed_clock_voltage_table->entries[i].vddc);\r\nif (allowed_clock_voltage_table->entries[i].vddci)\r\nvoltage->Vddci =\r\nphm_get_voltage_id(&data->vddci_voltage_table, allowed_clock_voltage_table->entries[i].vddci);\r\nelse\r\nvoltage->Vddci =\r\nphm_get_voltage_id(&data->vddci_voltage_table,\r\nallowed_clock_voltage_table->entries[i].vddc - VDDC_VDDCI_DELTA);\r\nif (allowed_clock_voltage_table->entries[i].mvdd)\r\n*mvdd = (uint32_t) allowed_clock_voltage_table->entries[i].mvdd;\r\nvoltage->Phases = 1;\r\nreturn 0;\r\n}\r\n}\r\nvoltage->VddGfx = phm_get_voltage_index(pptable_info->vddgfx_lookup_table,\r\nallowed_clock_voltage_table->entries[i-1].vddgfx);\r\nvoltage->Vddc = phm_get_voltage_index(pptable_info->vddc_lookup_table,\r\nallowed_clock_voltage_table->entries[i-1].vddc);\r\nif (allowed_clock_voltage_table->entries[i-1].vddci)\r\nvoltage->Vddci = phm_get_voltage_id(&data->vddci_voltage_table,\r\nallowed_clock_voltage_table->entries[i-1].vddci);\r\nif (allowed_clock_voltage_table->entries[i-1].mvdd)\r\n*mvdd = (uint32_t) allowed_clock_voltage_table->entries[i-1].mvdd;\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_smc_vddc_table(struct pp_hwmgr *hwmgr,\r\nSMU72_Discrete_DpmTable *table)\r\n{\r\nunsigned int count;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->voltage_control) {\r\ntable->VddcLevelCount = data->vddc_voltage_table.count;\r\nfor (count = 0; count < table->VddcLevelCount; count++) {\r\ntable->VddcTable[count] =\r\nPP_HOST_TO_SMC_US(data->vddc_voltage_table.entries[count].value * VOLTAGE_SCALE);\r\n}\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->VddcLevelCount);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_smc_vdd_gfx_table(struct pp_hwmgr *hwmgr,\r\nSMU72_Discrete_DpmTable *table)\r\n{\r\nunsigned int count;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->vdd_gfx_control) {\r\ntable->VddGfxLevelCount = data->vddgfx_voltage_table.count;\r\nfor (count = 0; count < data->vddgfx_voltage_table.count; count++) {\r\ntable->VddGfxTable[count] =\r\nPP_HOST_TO_SMC_US(data->vddgfx_voltage_table.entries[count].value * VOLTAGE_SCALE);\r\n}\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->VddGfxLevelCount);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_smc_vdd_ci_table(struct pp_hwmgr *hwmgr,\r\nSMU72_Discrete_DpmTable *table)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nuint32_t count;\r\ntable->VddciLevelCount = data->vddci_voltage_table.count;\r\nfor (count = 0; count < table->VddciLevelCount; count++) {\r\nif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->vddci_control) {\r\ntable->VddciTable[count] =\r\nPP_HOST_TO_SMC_US(data->vddci_voltage_table.entries[count].value * VOLTAGE_SCALE);\r\n} else if (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->vddci_control) {\r\ntable->SmioTable1.Pattern[count].Voltage =\r\nPP_HOST_TO_SMC_US(data->vddci_voltage_table.entries[count].value * VOLTAGE_SCALE);\r\ntable->SmioTable1.Pattern[count].Smio =\r\n(uint8_t) count;\r\ntable->Smio[count] |=\r\ndata->vddci_voltage_table.entries[count].smio_low;\r\ntable->VddciTable[count] =\r\nPP_HOST_TO_SMC_US(data->vddci_voltage_table.entries[count].value * VOLTAGE_SCALE);\r\n}\r\n}\r\ntable->SmioMask1 = data->vddci_voltage_table.mask_low;\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->VddciLevelCount);\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_smc_mvdd_table(struct pp_hwmgr *hwmgr,\r\nSMU72_Discrete_DpmTable *table)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nuint32_t count;\r\nif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->mvdd_control) {\r\ntable->MvddLevelCount = data->mvdd_voltage_table.count;\r\nfor (count = 0; count < table->MvddLevelCount; count++) {\r\ntable->SmioTable2.Pattern[count].Voltage =\r\nPP_HOST_TO_SMC_US(data->mvdd_voltage_table.entries[count].value * VOLTAGE_SCALE);\r\ntable->SmioTable2.Pattern[count].Smio =\r\n(uint8_t) count;\r\ntable->Smio[count] |=\r\ndata->mvdd_voltage_table.entries[count].smio_low;\r\n}\r\ntable->SmioMask2 = data->mvdd_voltage_table.mask_low;\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->MvddLevelCount);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_cac_tables(struct pp_hwmgr *hwmgr,\r\nSMU72_Discrete_DpmTable *table)\r\n{\r\nuint32_t count;\r\nuint8_t index = 0;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct phm_ppt_v1_information *pptable_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nstruct phm_ppt_v1_voltage_lookup_table *vddgfx_lookup_table =\r\npptable_info->vddgfx_lookup_table;\r\nstruct phm_ppt_v1_voltage_lookup_table *vddc_lookup_table =\r\npptable_info->vddc_lookup_table;\r\nuint32_t vddc_level_count = PP_SMC_TO_HOST_UL(table->VddcLevelCount);\r\nuint32_t vddgfx_level_count = PP_SMC_TO_HOST_UL(table->VddGfxLevelCount);\r\nfor (count = 0; count < vddc_level_count; count++) {\r\nindex = phm_get_voltage_index(vddc_lookup_table,\r\ndata->vddc_voltage_table.entries[count].value);\r\ntable->BapmVddcVidLoSidd[count] =\r\nconvert_to_vid(vddc_lookup_table->entries[index].us_cac_low);\r\ntable->BapmVddcVidHiSidd[count] =\r\nconvert_to_vid(vddc_lookup_table->entries[index].us_cac_mid);\r\ntable->BapmVddcVidHiSidd2[count] =\r\nconvert_to_vid(vddc_lookup_table->entries[index].us_cac_high);\r\n}\r\nif ((data->vdd_gfx_control == SMU7_VOLTAGE_CONTROL_BY_SVID2)) {\r\nfor (count = 0; count < vddgfx_level_count; count++) {\r\nindex = phm_get_voltage_index(vddgfx_lookup_table,\r\nconvert_to_vid(vddgfx_lookup_table->entries[index].us_cac_mid));\r\ntable->BapmVddGfxVidHiSidd2[count] =\r\nconvert_to_vid(vddgfx_lookup_table->entries[index].us_cac_high);\r\n}\r\n} else {\r\nfor (count = 0; count < vddc_level_count; count++) {\r\nindex = phm_get_voltage_index(vddc_lookup_table,\r\ndata->vddc_voltage_table.entries[count].value);\r\ntable->BapmVddGfxVidLoSidd[count] =\r\nconvert_to_vid(vddc_lookup_table->entries[index].us_cac_low);\r\ntable->BapmVddGfxVidHiSidd[count] =\r\nconvert_to_vid(vddc_lookup_table->entries[index].us_cac_mid);\r\ntable->BapmVddGfxVidHiSidd2[count] =\r\nconvert_to_vid(vddc_lookup_table->entries[index].us_cac_high);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_smc_voltage_tables(struct pp_hwmgr *hwmgr,\r\nSMU72_Discrete_DpmTable *table)\r\n{\r\nint result;\r\nresult = tonga_populate_smc_vddc_table(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"can not populate VDDC voltage table to SMC",\r\nreturn -EINVAL);\r\nresult = tonga_populate_smc_vdd_ci_table(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"can not populate VDDCI voltage table to SMC",\r\nreturn -EINVAL);\r\nresult = tonga_populate_smc_vdd_gfx_table(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"can not populate VDDGFX voltage table to SMC",\r\nreturn -EINVAL);\r\nresult = tonga_populate_smc_mvdd_table(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"can not populate MVDD voltage table to SMC",\r\nreturn -EINVAL);\r\nresult = tonga_populate_cac_tables(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"can not populate CAC voltage tables to SMC",\r\nreturn -EINVAL);\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_ulv_level(struct pp_hwmgr *hwmgr,\r\nstruct SMU72_Discrete_Ulv *state)\r\n{\r\nstruct phm_ppt_v1_information *table_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nstate->CcPwrDynRm = 0;\r\nstate->CcPwrDynRm1 = 0;\r\nstate->VddcOffset = (uint16_t) table_info->us_ulv_voltage_offset;\r\nstate->VddcOffsetVid = (uint8_t)(table_info->us_ulv_voltage_offset *\r\nVOLTAGE_VID_OFFSET_SCALE2 / VOLTAGE_VID_OFFSET_SCALE1);\r\nstate->VddcPhase = 1;\r\nCONVERT_FROM_HOST_TO_SMC_UL(state->CcPwrDynRm);\r\nCONVERT_FROM_HOST_TO_SMC_UL(state->CcPwrDynRm1);\r\nCONVERT_FROM_HOST_TO_SMC_US(state->VddcOffset);\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_ulv_state(struct pp_hwmgr *hwmgr,\r\nstruct SMU72_Discrete_DpmTable *table)\r\n{\r\nreturn tonga_populate_ulv_level(hwmgr, &table->Ulv);\r\n}\r\nstatic int tonga_populate_smc_link_level(struct pp_hwmgr *hwmgr, SMU72_Discrete_DpmTable *table)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct smu7_dpm_table *dpm_table = &data->dpm_table;\r\nstruct tonga_smumgr *smu_data = (struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nuint32_t i;\r\nfor (i = 0; i <= dpm_table->pcie_speed_table.count; i++) {\r\ntable->LinkLevel[i].PcieGenSpeed =\r\n(uint8_t)dpm_table->pcie_speed_table.dpm_levels[i].value;\r\ntable->LinkLevel[i].PcieLaneCount =\r\n(uint8_t)encode_pcie_lane_width(dpm_table->pcie_speed_table.dpm_levels[i].param1);\r\ntable->LinkLevel[i].EnabledForActivity =\r\n1;\r\ntable->LinkLevel[i].SPC =\r\n(uint8_t)(data->pcie_spc_cap & 0xff);\r\ntable->LinkLevel[i].DownThreshold =\r\nPP_HOST_TO_SMC_UL(5);\r\ntable->LinkLevel[i].UpThreshold =\r\nPP_HOST_TO_SMC_UL(30);\r\n}\r\nsmu_data->smc_state_table.LinkLevelCount =\r\n(uint8_t)dpm_table->pcie_speed_table.count;\r\ndata->dpm_level_enable_mask.pcie_dpm_enable_mask =\r\nphm_get_dpm_level_enable_mask_value(&dpm_table->pcie_speed_table);\r\nreturn 0;\r\n}\r\nstatic int tonga_calculate_sclk_params(struct pp_hwmgr *hwmgr,\r\nuint32_t engine_clock, SMU72_Discrete_GraphicsLevel *sclk)\r\n{\r\nconst struct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\npp_atomctrl_clock_dividers_vi dividers;\r\nuint32_t spll_func_cntl = data->clock_registers.vCG_SPLL_FUNC_CNTL;\r\nuint32_t spll_func_cntl_3 = data->clock_registers.vCG_SPLL_FUNC_CNTL_3;\r\nuint32_t spll_func_cntl_4 = data->clock_registers.vCG_SPLL_FUNC_CNTL_4;\r\nuint32_t cg_spll_spread_spectrum = data->clock_registers.vCG_SPLL_SPREAD_SPECTRUM;\r\nuint32_t cg_spll_spread_spectrum_2 = data->clock_registers.vCG_SPLL_SPREAD_SPECTRUM_2;\r\nuint32_t reference_clock;\r\nuint32_t reference_divider;\r\nuint32_t fbdiv;\r\nint result;\r\nresult = atomctrl_get_engine_pll_dividers_vi(hwmgr, engine_clock, &dividers);\r\nPP_ASSERT_WITH_CODE(result == 0,\r\n"Error retrieving Engine Clock dividers from VBIOS.", return result);\r\nreference_clock = atomctrl_get_reference_clock(hwmgr);\r\nreference_divider = 1 + dividers.uc_pll_ref_div;\r\nfbdiv = dividers.ul_fb_div.ul_fb_divider & 0x3FFFFFF;\r\nspll_func_cntl = PHM_SET_FIELD(spll_func_cntl,\r\nCG_SPLL_FUNC_CNTL, SPLL_REF_DIV, dividers.uc_pll_ref_div);\r\nspll_func_cntl = PHM_SET_FIELD(spll_func_cntl,\r\nCG_SPLL_FUNC_CNTL, SPLL_PDIV_A, dividers.uc_pll_post_div);\r\nspll_func_cntl_3 = PHM_SET_FIELD(spll_func_cntl_3,\r\nCG_SPLL_FUNC_CNTL_3, SPLL_FB_DIV, fbdiv);\r\nspll_func_cntl_3 = PHM_SET_FIELD(spll_func_cntl_3,\r\nCG_SPLL_FUNC_CNTL_3, SPLL_DITHEN, 1);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_EngineSpreadSpectrumSupport)) {\r\npp_atomctrl_internal_ss_info ss_info;\r\nuint32_t vcoFreq = engine_clock * dividers.uc_pll_post_div;\r\nif (0 == atomctrl_get_engine_clock_spread_spectrum(hwmgr, vcoFreq, &ss_info)) {\r\nuint32_t clkS = reference_clock * 5 / (reference_divider * ss_info.speed_spectrum_rate);\r\nuint32_t clkV = 4 * ss_info.speed_spectrum_percentage * fbdiv / (clkS * 10000);\r\ncg_spll_spread_spectrum =\r\nPHM_SET_FIELD(cg_spll_spread_spectrum, CG_SPLL_SPREAD_SPECTRUM, CLKS, clkS);\r\ncg_spll_spread_spectrum =\r\nPHM_SET_FIELD(cg_spll_spread_spectrum, CG_SPLL_SPREAD_SPECTRUM, SSEN, 1);\r\ncg_spll_spread_spectrum_2 =\r\nPHM_SET_FIELD(cg_spll_spread_spectrum_2, CG_SPLL_SPREAD_SPECTRUM_2, CLKV, clkV);\r\n}\r\n}\r\nsclk->SclkFrequency = engine_clock;\r\nsclk->CgSpllFuncCntl3 = spll_func_cntl_3;\r\nsclk->CgSpllFuncCntl4 = spll_func_cntl_4;\r\nsclk->SpllSpreadSpectrum = cg_spll_spread_spectrum;\r\nsclk->SpllSpreadSpectrum2 = cg_spll_spread_spectrum_2;\r\nsclk->SclkDid = (uint8_t)dividers.pll_post_divider;\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_single_graphic_level(struct pp_hwmgr *hwmgr,\r\nuint32_t engine_clock,\r\nuint16_t sclk_activity_level_threshold,\r\nSMU72_Discrete_GraphicsLevel *graphic_level)\r\n{\r\nint result;\r\nuint32_t mvdd;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct phm_ppt_v1_information *pptable_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nresult = tonga_calculate_sclk_params(hwmgr, engine_clock, graphic_level);\r\nresult = tonga_get_dependecy_volt_by_clk(hwmgr,\r\npptable_info->vdd_dep_on_sclk, engine_clock,\r\n&graphic_level->MinVoltage, &mvdd);\r\nPP_ASSERT_WITH_CODE((!result),\r\n"can not find VDDC voltage value for VDDC "\r\n"engine clock dependency table", return result);\r\ngraphic_level->SclkFrequency = engine_clock;\r\ngraphic_level->ActivityLevel = sclk_activity_level_threshold;\r\ngraphic_level->CcPwrDynRm = 0;\r\ngraphic_level->CcPwrDynRm1 = 0;\r\ngraphic_level->EnabledForActivity = 0;\r\ngraphic_level->EnabledForThrottle = 1;\r\ngraphic_level->UpHyst = 0;\r\ngraphic_level->DownHyst = 0;\r\ngraphic_level->VoltageDownHyst = 0;\r\ngraphic_level->PowerThrottle = 0;\r\ndata->display_timing.min_clock_in_sr =\r\nhwmgr->display_config.min_core_set_clock_in_sr;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_SclkDeepSleep))\r\ngraphic_level->DeepSleepDivId =\r\nsmu7_get_sleep_divider_id_from_clock(engine_clock,\r\ndata->display_timing.min_clock_in_sr);\r\ngraphic_level->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\r\nif (!result) {\r\nCONVERT_FROM_HOST_TO_SMC_UL(graphic_level->SclkFrequency);\r\nCONVERT_FROM_HOST_TO_SMC_US(graphic_level->ActivityLevel);\r\nCONVERT_FROM_HOST_TO_SMC_UL(graphic_level->CgSpllFuncCntl3);\r\nCONVERT_FROM_HOST_TO_SMC_UL(graphic_level->CgSpllFuncCntl4);\r\nCONVERT_FROM_HOST_TO_SMC_UL(graphic_level->SpllSpreadSpectrum);\r\nCONVERT_FROM_HOST_TO_SMC_UL(graphic_level->SpllSpreadSpectrum2);\r\nCONVERT_FROM_HOST_TO_SMC_UL(graphic_level->CcPwrDynRm);\r\nCONVERT_FROM_HOST_TO_SMC_UL(graphic_level->CcPwrDynRm1);\r\n}\r\nreturn result;\r\n}\r\nint tonga_populate_all_graphic_levels(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct tonga_smumgr *smu_data = (struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nstruct phm_ppt_v1_information *pptable_info = (struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nstruct smu7_dpm_table *dpm_table = &data->dpm_table;\r\nstruct phm_ppt_v1_pcie_table *pcie_table = pptable_info->pcie_table;\r\nuint8_t pcie_entry_count = (uint8_t) data->dpm_table.pcie_speed_table.count;\r\nuint32_t level_array_address = smu_data->smu7_data.dpm_table_start +\r\noffsetof(SMU72_Discrete_DpmTable, GraphicsLevel);\r\nuint32_t level_array_size = sizeof(SMU72_Discrete_GraphicsLevel) *\r\nSMU72_MAX_LEVELS_GRAPHICS;\r\nSMU72_Discrete_GraphicsLevel *levels = smu_data->smc_state_table.GraphicsLevel;\r\nuint32_t i, max_entry;\r\nuint8_t highest_pcie_level_enabled = 0;\r\nuint8_t lowest_pcie_level_enabled = 0, mid_pcie_level_enabled = 0;\r\nuint8_t count = 0;\r\nint result = 0;\r\nmemset(levels, 0x00, level_array_size);\r\nfor (i = 0; i < dpm_table->sclk_table.count; i++) {\r\nresult = tonga_populate_single_graphic_level(hwmgr,\r\ndpm_table->sclk_table.dpm_levels[i].value,\r\n(uint16_t)smu_data->activity_target[i],\r\n&(smu_data->smc_state_table.GraphicsLevel[i]));\r\nif (result != 0)\r\nreturn result;\r\nif (i > 1)\r\nsmu_data->smc_state_table.GraphicsLevel[i].DeepSleepDivId = 0;\r\n}\r\nsmu_data->smc_state_table.GraphicsLevel[0].EnabledForActivity = 1;\r\nif (dpm_table->sclk_table.count > 1)\r\nsmu_data->smc_state_table.GraphicsLevel[dpm_table->sclk_table.count-1].DisplayWatermark =\r\nPPSMC_DISPLAY_WATERMARK_HIGH;\r\nsmu_data->smc_state_table.GraphicsDpmLevelCount =\r\n(uint8_t)dpm_table->sclk_table.count;\r\ndata->dpm_level_enable_mask.sclk_dpm_enable_mask =\r\nphm_get_dpm_level_enable_mask_value(&dpm_table->sclk_table);\r\nif (pcie_table != NULL) {\r\nPP_ASSERT_WITH_CODE((pcie_entry_count >= 1),\r\n"There must be 1 or more PCIE levels defined in PPTable.",\r\nreturn -EINVAL);\r\nmax_entry = pcie_entry_count - 1;\r\nfor (i = 0; i < dpm_table->sclk_table.count; i++) {\r\nsmu_data->smc_state_table.GraphicsLevel[i].pcieDpmLevel =\r\n(uint8_t) ((i < max_entry) ? i : max_entry);\r\n}\r\n} else {\r\nif (0 == data->dpm_level_enable_mask.pcie_dpm_enable_mask)\r\npr_err("Pcie Dpm Enablemask is 0 !");\r\nwhile (data->dpm_level_enable_mask.pcie_dpm_enable_mask &&\r\n((data->dpm_level_enable_mask.pcie_dpm_enable_mask &\r\n(1<<(highest_pcie_level_enabled+1))) != 0)) {\r\nhighest_pcie_level_enabled++;\r\n}\r\nwhile (data->dpm_level_enable_mask.pcie_dpm_enable_mask &&\r\n((data->dpm_level_enable_mask.pcie_dpm_enable_mask &\r\n(1<<lowest_pcie_level_enabled)) == 0)) {\r\nlowest_pcie_level_enabled++;\r\n}\r\nwhile ((count < highest_pcie_level_enabled) &&\r\n((data->dpm_level_enable_mask.pcie_dpm_enable_mask &\r\n(1<<(lowest_pcie_level_enabled+1+count))) == 0)) {\r\ncount++;\r\n}\r\nmid_pcie_level_enabled = (lowest_pcie_level_enabled+1+count) < highest_pcie_level_enabled ?\r\n(lowest_pcie_level_enabled+1+count) : highest_pcie_level_enabled;\r\nfor (i = 2; i < dpm_table->sclk_table.count; i++)\r\nsmu_data->smc_state_table.GraphicsLevel[i].pcieDpmLevel = highest_pcie_level_enabled;\r\nsmu_data->smc_state_table.GraphicsLevel[0].pcieDpmLevel = lowest_pcie_level_enabled;\r\nsmu_data->smc_state_table.GraphicsLevel[1].pcieDpmLevel = mid_pcie_level_enabled;\r\n}\r\nresult = smu7_copy_bytes_to_smc(hwmgr->smumgr, level_array_address,\r\n(uint8_t *)levels, (uint32_t)level_array_size,\r\nSMC_RAM_END);\r\nreturn result;\r\n}\r\nstatic int tonga_calculate_mclk_params(\r\nstruct pp_hwmgr *hwmgr,\r\nuint32_t memory_clock,\r\nSMU72_Discrete_MemoryLevel *mclk,\r\nbool strobe_mode,\r\nbool dllStateOn\r\n)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nuint32_t dll_cntl = data->clock_registers.vDLL_CNTL;\r\nuint32_t mclk_pwrmgt_cntl = data->clock_registers.vMCLK_PWRMGT_CNTL;\r\nuint32_t mpll_ad_func_cntl = data->clock_registers.vMPLL_AD_FUNC_CNTL;\r\nuint32_t mpll_dq_func_cntl = data->clock_registers.vMPLL_DQ_FUNC_CNTL;\r\nuint32_t mpll_func_cntl = data->clock_registers.vMPLL_FUNC_CNTL;\r\nuint32_t mpll_func_cntl_1 = data->clock_registers.vMPLL_FUNC_CNTL_1;\r\nuint32_t mpll_func_cntl_2 = data->clock_registers.vMPLL_FUNC_CNTL_2;\r\nuint32_t mpll_ss1 = data->clock_registers.vMPLL_SS1;\r\nuint32_t mpll_ss2 = data->clock_registers.vMPLL_SS2;\r\npp_atomctrl_memory_clock_param mpll_param;\r\nint result;\r\nresult = atomctrl_get_memory_pll_dividers_si(hwmgr,\r\nmemory_clock, &mpll_param, strobe_mode);\r\nPP_ASSERT_WITH_CODE(\r\n!result,\r\n"Error retrieving Memory Clock Parameters from VBIOS.",\r\nreturn result);\r\nmpll_func_cntl = PHM_SET_FIELD(mpll_func_cntl, MPLL_FUNC_CNTL, BWCTRL,\r\nmpll_param.bw_ctrl);\r\nmpll_func_cntl_1 = PHM_SET_FIELD(mpll_func_cntl_1,\r\nMPLL_FUNC_CNTL_1, CLKF,\r\nmpll_param.mpll_fb_divider.cl_kf);\r\nmpll_func_cntl_1 = PHM_SET_FIELD(mpll_func_cntl_1,\r\nMPLL_FUNC_CNTL_1, CLKFRAC,\r\nmpll_param.mpll_fb_divider.clk_frac);\r\nmpll_func_cntl_1 = PHM_SET_FIELD(mpll_func_cntl_1,\r\nMPLL_FUNC_CNTL_1, VCO_MODE,\r\nmpll_param.vco_mode);\r\nmpll_ad_func_cntl = PHM_SET_FIELD(mpll_ad_func_cntl,\r\nMPLL_AD_FUNC_CNTL, YCLK_POST_DIV,\r\nmpll_param.mpll_post_divider);\r\nif (data->is_memory_gddr5) {\r\nmpll_dq_func_cntl = PHM_SET_FIELD(mpll_dq_func_cntl,\r\nMPLL_DQ_FUNC_CNTL, YCLK_SEL,\r\nmpll_param.yclk_sel);\r\nmpll_dq_func_cntl = PHM_SET_FIELD(mpll_dq_func_cntl,\r\nMPLL_DQ_FUNC_CNTL, YCLK_POST_DIV,\r\nmpll_param.mpll_post_divider);\r\n}\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_MemorySpreadSpectrumSupport)) {\r\npp_atomctrl_internal_ss_info ss_info;\r\nuint32_t freq_nom;\r\nuint32_t tmp;\r\nuint32_t reference_clock = atomctrl_get_mpll_reference_clock(hwmgr);\r\nif (1 == mpll_param.qdr)\r\nfreq_nom = memory_clock * 4 * (1 << mpll_param.mpll_post_divider);\r\nelse\r\nfreq_nom = memory_clock * 2 * (1 << mpll_param.mpll_post_divider);\r\ntmp = (freq_nom / reference_clock);\r\ntmp = tmp * tmp;\r\nif (0 == atomctrl_get_memory_clock_spread_spectrum(hwmgr, freq_nom, &ss_info)) {\r\nuint32_t clks = reference_clock * 5 / ss_info.speed_spectrum_rate;\r\nuint32_t clkv =\r\n(uint32_t)((((131 * ss_info.speed_spectrum_percentage *\r\nss_info.speed_spectrum_rate) / 100) * tmp) / freq_nom);\r\nmpll_ss1 = PHM_SET_FIELD(mpll_ss1, MPLL_SS1, CLKV, clkv);\r\nmpll_ss2 = PHM_SET_FIELD(mpll_ss2, MPLL_SS2, CLKS, clks);\r\n}\r\n}\r\nmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\r\nMCLK_PWRMGT_CNTL, DLL_SPEED, mpll_param.dll_speed);\r\nmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\r\nMCLK_PWRMGT_CNTL, MRDCK0_PDNB, dllStateOn);\r\nmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\r\nMCLK_PWRMGT_CNTL, MRDCK1_PDNB, dllStateOn);\r\nmclk->MclkFrequency = memory_clock;\r\nmclk->MpllFuncCntl = mpll_func_cntl;\r\nmclk->MpllFuncCntl_1 = mpll_func_cntl_1;\r\nmclk->MpllFuncCntl_2 = mpll_func_cntl_2;\r\nmclk->MpllAdFuncCntl = mpll_ad_func_cntl;\r\nmclk->MpllDqFuncCntl = mpll_dq_func_cntl;\r\nmclk->MclkPwrmgtCntl = mclk_pwrmgt_cntl;\r\nmclk->DllCntl = dll_cntl;\r\nmclk->MpllSs1 = mpll_ss1;\r\nmclk->MpllSs2 = mpll_ss2;\r\nreturn 0;\r\n}\r\nstatic uint8_t tonga_get_mclk_frequency_ratio(uint32_t memory_clock,\r\nbool strobe_mode)\r\n{\r\nuint8_t mc_para_index;\r\nif (strobe_mode) {\r\nif (memory_clock < 12500)\r\nmc_para_index = 0x00;\r\nelse if (memory_clock > 47500)\r\nmc_para_index = 0x0f;\r\nelse\r\nmc_para_index = (uint8_t)((memory_clock - 10000) / 2500);\r\n} else {\r\nif (memory_clock < 65000)\r\nmc_para_index = 0x00;\r\nelse if (memory_clock > 135000)\r\nmc_para_index = 0x0f;\r\nelse\r\nmc_para_index = (uint8_t)((memory_clock - 60000) / 5000);\r\n}\r\nreturn mc_para_index;\r\n}\r\nstatic uint8_t tonga_get_ddr3_mclk_frequency_ratio(uint32_t memory_clock)\r\n{\r\nuint8_t mc_para_index;\r\nif (memory_clock < 10000)\r\nmc_para_index = 0;\r\nelse if (memory_clock >= 80000)\r\nmc_para_index = 0x0f;\r\nelse\r\nmc_para_index = (uint8_t)((memory_clock - 10000) / 5000 + 1);\r\nreturn mc_para_index;\r\n}\r\nstatic int tonga_populate_single_memory_level(\r\nstruct pp_hwmgr *hwmgr,\r\nuint32_t memory_clock,\r\nSMU72_Discrete_MemoryLevel *memory_level\r\n)\r\n{\r\nuint32_t mvdd = 0;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct phm_ppt_v1_information *pptable_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nint result = 0;\r\nbool dll_state_on;\r\nstruct cgs_display_info info = {0};\r\nuint32_t mclk_edc_wr_enable_threshold = 40000;\r\nuint32_t mclk_stutter_mode_threshold = 30000;\r\nuint32_t mclk_edc_enable_threshold = 40000;\r\nuint32_t mclk_strobe_mode_threshold = 40000;\r\nif (NULL != pptable_info->vdd_dep_on_mclk) {\r\nresult = tonga_get_dependecy_volt_by_clk(hwmgr,\r\npptable_info->vdd_dep_on_mclk,\r\nmemory_clock,\r\n&memory_level->MinVoltage, &mvdd);\r\nPP_ASSERT_WITH_CODE(\r\n!result,\r\n"can not find MinVddc voltage value from memory VDDC "\r\n"voltage dependency table",\r\nreturn result);\r\n}\r\nif (data->mvdd_control == SMU7_VOLTAGE_CONTROL_NONE)\r\nmemory_level->MinMvdd = data->vbios_boot_state.mvdd_bootup_value;\r\nelse\r\nmemory_level->MinMvdd = mvdd;\r\nmemory_level->EnabledForThrottle = 1;\r\nmemory_level->EnabledForActivity = 0;\r\nmemory_level->UpHyst = 0;\r\nmemory_level->DownHyst = 100;\r\nmemory_level->VoltageDownHyst = 0;\r\nmemory_level->ActivityLevel = (uint16_t)data->mclk_activity_target;\r\nmemory_level->StutterEnable = 0;\r\nmemory_level->StrobeEnable = 0;\r\nmemory_level->EdcReadEnable = 0;\r\nmemory_level->EdcWriteEnable = 0;\r\nmemory_level->RttEnable = 0;\r\nmemory_level->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\r\ncgs_get_active_displays_info(hwmgr->device, &info);\r\ndata->display_timing.num_existing_displays = info.display_count;\r\nif ((mclk_stutter_mode_threshold != 0) &&\r\n(memory_clock <= mclk_stutter_mode_threshold) &&\r\n(!data->is_uvd_enabled)\r\n&& (PHM_READ_FIELD(hwmgr->device, DPG_PIPE_STUTTER_CONTROL, STUTTER_ENABLE) & 0x1)\r\n&& (data->display_timing.num_existing_displays <= 2)\r\n&& (data->display_timing.num_existing_displays != 0))\r\nmemory_level->StutterEnable = 1;\r\nmemory_level->StrobeEnable = (mclk_strobe_mode_threshold != 0) &&\r\n(memory_clock <= mclk_strobe_mode_threshold);\r\nif (data->is_memory_gddr5) {\r\nmemory_level->StrobeRatio = tonga_get_mclk_frequency_ratio(memory_clock,\r\nmemory_level->StrobeEnable);\r\nif ((mclk_edc_enable_threshold != 0) &&\r\n(memory_clock > mclk_edc_enable_threshold)) {\r\nmemory_level->EdcReadEnable = 1;\r\n}\r\nif ((mclk_edc_wr_enable_threshold != 0) &&\r\n(memory_clock > mclk_edc_wr_enable_threshold)) {\r\nmemory_level->EdcWriteEnable = 1;\r\n}\r\nif (memory_level->StrobeEnable) {\r\nif (tonga_get_mclk_frequency_ratio(memory_clock, 1) >=\r\n((cgs_read_register(hwmgr->device, mmMC_SEQ_MISC7) >> 16) & 0xf)) {\r\ndll_state_on = ((cgs_read_register(hwmgr->device, mmMC_SEQ_MISC5) >> 1) & 0x1) ? 1 : 0;\r\n} else {\r\ndll_state_on = ((cgs_read_register(hwmgr->device, mmMC_SEQ_MISC6) >> 1) & 0x1) ? 1 : 0;\r\n}\r\n} else {\r\ndll_state_on = data->dll_default_on;\r\n}\r\n} else {\r\nmemory_level->StrobeRatio =\r\ntonga_get_ddr3_mclk_frequency_ratio(memory_clock);\r\ndll_state_on = ((cgs_read_register(hwmgr->device, mmMC_SEQ_MISC5) >> 1) & 0x1) ? 1 : 0;\r\n}\r\nresult = tonga_calculate_mclk_params(hwmgr,\r\nmemory_clock, memory_level, memory_level->StrobeEnable, dll_state_on);\r\nif (!result) {\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MinMvdd);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MclkFrequency);\r\nCONVERT_FROM_HOST_TO_SMC_US(memory_level->ActivityLevel);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllFuncCntl);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllFuncCntl_1);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllFuncCntl_2);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllAdFuncCntl);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllDqFuncCntl);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MclkPwrmgtCntl);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->DllCntl);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllSs1);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllSs2);\r\n}\r\nreturn result;\r\n}\r\nint tonga_populate_all_memory_levels(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nstruct smu7_dpm_table *dpm_table = &data->dpm_table;\r\nint result;\r\nuint32_t level_array_address =\r\nsmu_data->smu7_data.dpm_table_start +\r\noffsetof(SMU72_Discrete_DpmTable, MemoryLevel);\r\nuint32_t level_array_size =\r\nsizeof(SMU72_Discrete_MemoryLevel) *\r\nSMU72_MAX_LEVELS_MEMORY;\r\nSMU72_Discrete_MemoryLevel *levels =\r\nsmu_data->smc_state_table.MemoryLevel;\r\nuint32_t i;\r\nmemset(levels, 0x00, level_array_size);\r\nfor (i = 0; i < dpm_table->mclk_table.count; i++) {\r\nPP_ASSERT_WITH_CODE((0 != dpm_table->mclk_table.dpm_levels[i].value),\r\n"can not populate memory level as memory clock is zero",\r\nreturn -EINVAL);\r\nresult = tonga_populate_single_memory_level(\r\nhwmgr,\r\ndpm_table->mclk_table.dpm_levels[i].value,\r\n&(smu_data->smc_state_table.MemoryLevel[i]));\r\nif (result)\r\nreturn result;\r\n}\r\nsmu_data->smc_state_table.MemoryLevel[0].EnabledForActivity = 1;\r\nsmu_data->smc_state_table.MemoryLevel[0].ActivityLevel = 0x1F;\r\nCONVERT_FROM_HOST_TO_SMC_US(smu_data->smc_state_table.MemoryLevel[0].ActivityLevel);\r\nsmu_data->smc_state_table.MemoryDpmLevelCount = (uint8_t)dpm_table->mclk_table.count;\r\ndata->dpm_level_enable_mask.mclk_dpm_enable_mask = phm_get_dpm_level_enable_mask_value(&dpm_table->mclk_table);\r\nsmu_data->smc_state_table.MemoryLevel[dpm_table->mclk_table.count-1].DisplayWatermark = PPSMC_DISPLAY_WATERMARK_HIGH;\r\nresult = smu7_copy_bytes_to_smc(hwmgr->smumgr,\r\nlevel_array_address, (uint8_t *)levels, (uint32_t)level_array_size,\r\nSMC_RAM_END);\r\nreturn result;\r\n}\r\nstatic int tonga_populate_mvdd_value(struct pp_hwmgr *hwmgr,\r\nuint32_t mclk, SMIO_Pattern *smio_pattern)\r\n{\r\nconst struct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct phm_ppt_v1_information *table_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nuint32_t i = 0;\r\nif (SMU7_VOLTAGE_CONTROL_NONE != data->mvdd_control) {\r\nfor (i = 0; i < table_info->vdd_dep_on_mclk->count; i++) {\r\nif (mclk <= table_info->vdd_dep_on_mclk->entries[i].clk) {\r\nsmio_pattern->Voltage =\r\ndata->mvdd_voltage_table.entries[i].value;\r\nbreak;\r\n}\r\n}\r\nPP_ASSERT_WITH_CODE(i < table_info->vdd_dep_on_mclk->count,\r\n"MVDD Voltage is outside the supported range.",\r\nreturn -EINVAL);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_smc_acpi_level(struct pp_hwmgr *hwmgr,\r\nSMU72_Discrete_DpmTable *table)\r\n{\r\nint result = 0;\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nconst struct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct pp_atomctrl_clock_dividers_vi dividers;\r\nSMIO_Pattern voltage_level;\r\nuint32_t spll_func_cntl = data->clock_registers.vCG_SPLL_FUNC_CNTL;\r\nuint32_t spll_func_cntl_2 = data->clock_registers.vCG_SPLL_FUNC_CNTL_2;\r\nuint32_t dll_cntl = data->clock_registers.vDLL_CNTL;\r\nuint32_t mclk_pwrmgt_cntl = data->clock_registers.vMCLK_PWRMGT_CNTL;\r\ntable->ACPILevel.Flags &= ~PPSMC_SWSTATE_FLAG_DC;\r\ntable->ACPILevel.MinVoltage =\r\nsmu_data->smc_state_table.GraphicsLevel[0].MinVoltage;\r\ntable->ACPILevel.SclkFrequency = atomctrl_get_reference_clock(hwmgr);\r\nresult = atomctrl_get_engine_pll_dividers_vi(hwmgr,\r\ntable->ACPILevel.SclkFrequency, &dividers);\r\nPP_ASSERT_WITH_CODE(result == 0,\r\n"Error retrieving Engine Clock dividers from VBIOS.",\r\nreturn result);\r\ntable->ACPILevel.SclkDid = (uint8_t)dividers.pll_post_divider;\r\ntable->ACPILevel.DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\r\ntable->ACPILevel.DeepSleepDivId = 0;\r\nspll_func_cntl = PHM_SET_FIELD(spll_func_cntl, CG_SPLL_FUNC_CNTL,\r\nSPLL_PWRON, 0);\r\nspll_func_cntl = PHM_SET_FIELD(spll_func_cntl, CG_SPLL_FUNC_CNTL,\r\nSPLL_RESET, 1);\r\nspll_func_cntl_2 = PHM_SET_FIELD(spll_func_cntl_2, CG_SPLL_FUNC_CNTL_2,\r\nSCLK_MUX_SEL, 4);\r\ntable->ACPILevel.CgSpllFuncCntl = spll_func_cntl;\r\ntable->ACPILevel.CgSpllFuncCntl2 = spll_func_cntl_2;\r\ntable->ACPILevel.CgSpllFuncCntl3 = data->clock_registers.vCG_SPLL_FUNC_CNTL_3;\r\ntable->ACPILevel.CgSpllFuncCntl4 = data->clock_registers.vCG_SPLL_FUNC_CNTL_4;\r\ntable->ACPILevel.SpllSpreadSpectrum = data->clock_registers.vCG_SPLL_SPREAD_SPECTRUM;\r\ntable->ACPILevel.SpllSpreadSpectrum2 = data->clock_registers.vCG_SPLL_SPREAD_SPECTRUM_2;\r\ntable->ACPILevel.CcPwrDynRm = 0;\r\ntable->ACPILevel.CcPwrDynRm1 = 0;\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.Flags);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.SclkFrequency);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl2);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl3);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl4);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.SpllSpreadSpectrum);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.SpllSpreadSpectrum2);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CcPwrDynRm);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CcPwrDynRm1);\r\ntable->MemoryACPILevel.MinVoltage =\r\nsmu_data->smc_state_table.MemoryLevel[0].MinVoltage;\r\nif (0 == tonga_populate_mvdd_value(hwmgr, 0, &voltage_level))\r\ntable->MemoryACPILevel.MinMvdd =\r\nPP_HOST_TO_SMC_UL(voltage_level.Voltage * VOLTAGE_SCALE);\r\nelse\r\ntable->MemoryACPILevel.MinMvdd = 0;\r\nmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\r\nMCLK_PWRMGT_CNTL, MRDCK0_RESET, 0x1);\r\nmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\r\nMCLK_PWRMGT_CNTL, MRDCK1_RESET, 0x1);\r\nmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\r\nMCLK_PWRMGT_CNTL, MRDCK0_PDNB, 0);\r\nmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\r\nMCLK_PWRMGT_CNTL, MRDCK1_PDNB, 0);\r\ndll_cntl = PHM_SET_FIELD(dll_cntl,\r\nDLL_CNTL, MRDCK0_BYPASS, 0);\r\ndll_cntl = PHM_SET_FIELD(dll_cntl,\r\nDLL_CNTL, MRDCK1_BYPASS, 0);\r\ntable->MemoryACPILevel.DllCntl =\r\nPP_HOST_TO_SMC_UL(dll_cntl);\r\ntable->MemoryACPILevel.MclkPwrmgtCntl =\r\nPP_HOST_TO_SMC_UL(mclk_pwrmgt_cntl);\r\ntable->MemoryACPILevel.MpllAdFuncCntl =\r\nPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_AD_FUNC_CNTL);\r\ntable->MemoryACPILevel.MpllDqFuncCntl =\r\nPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_DQ_FUNC_CNTL);\r\ntable->MemoryACPILevel.MpllFuncCntl =\r\nPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_FUNC_CNTL);\r\ntable->MemoryACPILevel.MpllFuncCntl_1 =\r\nPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_FUNC_CNTL_1);\r\ntable->MemoryACPILevel.MpllFuncCntl_2 =\r\nPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_FUNC_CNTL_2);\r\ntable->MemoryACPILevel.MpllSs1 =\r\nPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_SS1);\r\ntable->MemoryACPILevel.MpllSs2 =\r\nPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_SS2);\r\ntable->MemoryACPILevel.EnabledForThrottle = 0;\r\ntable->MemoryACPILevel.EnabledForActivity = 0;\r\ntable->MemoryACPILevel.UpHyst = 0;\r\ntable->MemoryACPILevel.DownHyst = 100;\r\ntable->MemoryACPILevel.VoltageDownHyst = 0;\r\ntable->MemoryACPILevel.ActivityLevel =\r\nPP_HOST_TO_SMC_US((uint16_t)data->mclk_activity_target);\r\ntable->MemoryACPILevel.StutterEnable = 0;\r\ntable->MemoryACPILevel.StrobeEnable = 0;\r\ntable->MemoryACPILevel.EdcReadEnable = 0;\r\ntable->MemoryACPILevel.EdcWriteEnable = 0;\r\ntable->MemoryACPILevel.RttEnable = 0;\r\nreturn result;\r\n}\r\nstatic int tonga_populate_smc_uvd_level(struct pp_hwmgr *hwmgr,\r\nSMU72_Discrete_DpmTable *table)\r\n{\r\nint result = 0;\r\nuint8_t count;\r\npp_atomctrl_clock_dividers_vi dividers;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct phm_ppt_v1_information *pptable_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nphm_ppt_v1_mm_clock_voltage_dependency_table *mm_table =\r\npptable_info->mm_dep_table;\r\ntable->UvdLevelCount = (uint8_t) (mm_table->count);\r\ntable->UvdBootLevel = 0;\r\nfor (count = 0; count < table->UvdLevelCount; count++) {\r\ntable->UvdLevel[count].VclkFrequency = mm_table->entries[count].vclk;\r\ntable->UvdLevel[count].DclkFrequency = mm_table->entries[count].dclk;\r\ntable->UvdLevel[count].MinVoltage.Vddc =\r\nphm_get_voltage_index(pptable_info->vddc_lookup_table,\r\nmm_table->entries[count].vddc);\r\ntable->UvdLevel[count].MinVoltage.VddGfx =\r\n(data->vdd_gfx_control == SMU7_VOLTAGE_CONTROL_BY_SVID2) ?\r\nphm_get_voltage_index(pptable_info->vddgfx_lookup_table,\r\nmm_table->entries[count].vddgfx) : 0;\r\ntable->UvdLevel[count].MinVoltage.Vddci =\r\nphm_get_voltage_id(&data->vddci_voltage_table,\r\nmm_table->entries[count].vddc - VDDC_VDDCI_DELTA);\r\ntable->UvdLevel[count].MinVoltage.Phases = 1;\r\nresult = atomctrl_get_dfs_pll_dividers_vi(\r\nhwmgr,\r\ntable->UvdLevel[count].VclkFrequency,\r\n&dividers);\r\nPP_ASSERT_WITH_CODE((!result),\r\n"can not find divide id for Vclk clock",\r\nreturn result);\r\ntable->UvdLevel[count].VclkDivider = (uint8_t)dividers.pll_post_divider;\r\nresult = atomctrl_get_dfs_pll_dividers_vi(hwmgr,\r\ntable->UvdLevel[count].DclkFrequency, &dividers);\r\nPP_ASSERT_WITH_CODE((!result),\r\n"can not find divide id for Dclk clock",\r\nreturn result);\r\ntable->UvdLevel[count].DclkDivider =\r\n(uint8_t)dividers.pll_post_divider;\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->UvdLevel[count].VclkFrequency);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->UvdLevel[count].DclkFrequency);\r\n}\r\nreturn result;\r\n}\r\nstatic int tonga_populate_smc_vce_level(struct pp_hwmgr *hwmgr,\r\nSMU72_Discrete_DpmTable *table)\r\n{\r\nint result = 0;\r\nuint8_t count;\r\npp_atomctrl_clock_dividers_vi dividers;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct phm_ppt_v1_information *pptable_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nphm_ppt_v1_mm_clock_voltage_dependency_table *mm_table =\r\npptable_info->mm_dep_table;\r\ntable->VceLevelCount = (uint8_t) (mm_table->count);\r\ntable->VceBootLevel = 0;\r\nfor (count = 0; count < table->VceLevelCount; count++) {\r\ntable->VceLevel[count].Frequency =\r\nmm_table->entries[count].eclk;\r\ntable->VceLevel[count].MinVoltage.Vddc =\r\nphm_get_voltage_index(pptable_info->vddc_lookup_table,\r\nmm_table->entries[count].vddc);\r\ntable->VceLevel[count].MinVoltage.VddGfx =\r\n(data->vdd_gfx_control == SMU7_VOLTAGE_CONTROL_BY_SVID2) ?\r\nphm_get_voltage_index(pptable_info->vddgfx_lookup_table,\r\nmm_table->entries[count].vddgfx) : 0;\r\ntable->VceLevel[count].MinVoltage.Vddci =\r\nphm_get_voltage_id(&data->vddci_voltage_table,\r\nmm_table->entries[count].vddc - VDDC_VDDCI_DELTA);\r\ntable->VceLevel[count].MinVoltage.Phases = 1;\r\nresult = atomctrl_get_dfs_pll_dividers_vi(hwmgr,\r\ntable->VceLevel[count].Frequency, &dividers);\r\nPP_ASSERT_WITH_CODE((!result),\r\n"can not find divide id for VCE engine clock",\r\nreturn result);\r\ntable->VceLevel[count].Divider = (uint8_t)dividers.pll_post_divider;\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->VceLevel[count].Frequency);\r\n}\r\nreturn result;\r\n}\r\nstatic int tonga_populate_smc_acp_level(struct pp_hwmgr *hwmgr,\r\nSMU72_Discrete_DpmTable *table)\r\n{\r\nint result = 0;\r\nuint8_t count;\r\npp_atomctrl_clock_dividers_vi dividers;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct phm_ppt_v1_information *pptable_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nphm_ppt_v1_mm_clock_voltage_dependency_table *mm_table =\r\npptable_info->mm_dep_table;\r\ntable->AcpLevelCount = (uint8_t) (mm_table->count);\r\ntable->AcpBootLevel = 0;\r\nfor (count = 0; count < table->AcpLevelCount; count++) {\r\ntable->AcpLevel[count].Frequency =\r\npptable_info->mm_dep_table->entries[count].aclk;\r\ntable->AcpLevel[count].MinVoltage.Vddc =\r\nphm_get_voltage_index(pptable_info->vddc_lookup_table,\r\nmm_table->entries[count].vddc);\r\ntable->AcpLevel[count].MinVoltage.VddGfx =\r\n(data->vdd_gfx_control == SMU7_VOLTAGE_CONTROL_BY_SVID2) ?\r\nphm_get_voltage_index(pptable_info->vddgfx_lookup_table,\r\nmm_table->entries[count].vddgfx) : 0;\r\ntable->AcpLevel[count].MinVoltage.Vddci =\r\nphm_get_voltage_id(&data->vddci_voltage_table,\r\nmm_table->entries[count].vddc - VDDC_VDDCI_DELTA);\r\ntable->AcpLevel[count].MinVoltage.Phases = 1;\r\nresult = atomctrl_get_dfs_pll_dividers_vi(hwmgr,\r\ntable->AcpLevel[count].Frequency, &dividers);\r\nPP_ASSERT_WITH_CODE((!result),\r\n"can not find divide id for engine clock", return result);\r\ntable->AcpLevel[count].Divider = (uint8_t)dividers.pll_post_divider;\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->AcpLevel[count].Frequency);\r\n}\r\nreturn result;\r\n}\r\nstatic int tonga_populate_smc_samu_level(struct pp_hwmgr *hwmgr,\r\nSMU72_Discrete_DpmTable *table)\r\n{\r\nint result = 0;\r\nuint8_t count;\r\npp_atomctrl_clock_dividers_vi dividers;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct phm_ppt_v1_information *pptable_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nphm_ppt_v1_mm_clock_voltage_dependency_table *mm_table =\r\npptable_info->mm_dep_table;\r\ntable->SamuBootLevel = 0;\r\ntable->SamuLevelCount = (uint8_t) (mm_table->count);\r\nfor (count = 0; count < table->SamuLevelCount; count++) {\r\ntable->SamuLevel[count].Frequency =\r\npptable_info->mm_dep_table->entries[count].samclock;\r\ntable->SamuLevel[count].MinVoltage.Vddc =\r\nphm_get_voltage_index(pptable_info->vddc_lookup_table,\r\nmm_table->entries[count].vddc);\r\ntable->SamuLevel[count].MinVoltage.VddGfx =\r\n(data->vdd_gfx_control == SMU7_VOLTAGE_CONTROL_BY_SVID2) ?\r\nphm_get_voltage_index(pptable_info->vddgfx_lookup_table,\r\nmm_table->entries[count].vddgfx) : 0;\r\ntable->SamuLevel[count].MinVoltage.Vddci =\r\nphm_get_voltage_id(&data->vddci_voltage_table,\r\nmm_table->entries[count].vddc - VDDC_VDDCI_DELTA);\r\ntable->SamuLevel[count].MinVoltage.Phases = 1;\r\nresult = atomctrl_get_dfs_pll_dividers_vi(hwmgr,\r\ntable->SamuLevel[count].Frequency, &dividers);\r\nPP_ASSERT_WITH_CODE((!result),\r\n"can not find divide id for samu clock", return result);\r\ntable->SamuLevel[count].Divider = (uint8_t)dividers.pll_post_divider;\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->SamuLevel[count].Frequency);\r\n}\r\nreturn result;\r\n}\r\nstatic int tonga_populate_memory_timing_parameters(\r\nstruct pp_hwmgr *hwmgr,\r\nuint32_t engine_clock,\r\nuint32_t memory_clock,\r\nstruct SMU72_Discrete_MCArbDramTimingTableEntry *arb_regs\r\n)\r\n{\r\nuint32_t dramTiming;\r\nuint32_t dramTiming2;\r\nuint32_t burstTime;\r\nint result;\r\nresult = atomctrl_set_engine_dram_timings_rv770(hwmgr,\r\nengine_clock, memory_clock);\r\nPP_ASSERT_WITH_CODE(result == 0,\r\n"Error calling VBIOS to set DRAM_TIMING.", return result);\r\ndramTiming = cgs_read_register(hwmgr->device, mmMC_ARB_DRAM_TIMING);\r\ndramTiming2 = cgs_read_register(hwmgr->device, mmMC_ARB_DRAM_TIMING2);\r\nburstTime = PHM_READ_FIELD(hwmgr->device, MC_ARB_BURST_TIME, STATE0);\r\narb_regs->McArbDramTiming = PP_HOST_TO_SMC_UL(dramTiming);\r\narb_regs->McArbDramTiming2 = PP_HOST_TO_SMC_UL(dramTiming2);\r\narb_regs->McArbBurstTime = (uint8_t)burstTime;\r\nreturn 0;\r\n}\r\nstatic int tonga_program_memory_timing_parameters(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nint result = 0;\r\nSMU72_Discrete_MCArbDramTimingTable arb_regs;\r\nuint32_t i, j;\r\nmemset(&arb_regs, 0x00, sizeof(SMU72_Discrete_MCArbDramTimingTable));\r\nfor (i = 0; i < data->dpm_table.sclk_table.count; i++) {\r\nfor (j = 0; j < data->dpm_table.mclk_table.count; j++) {\r\nresult = tonga_populate_memory_timing_parameters\r\n(hwmgr, data->dpm_table.sclk_table.dpm_levels[i].value,\r\ndata->dpm_table.mclk_table.dpm_levels[j].value,\r\n&arb_regs.entries[i][j]);\r\nif (result)\r\nbreak;\r\n}\r\n}\r\nif (!result) {\r\nresult = smu7_copy_bytes_to_smc(\r\nhwmgr->smumgr,\r\nsmu_data->smu7_data.arb_table_start,\r\n(uint8_t *)&arb_regs,\r\nsizeof(SMU72_Discrete_MCArbDramTimingTable),\r\nSMC_RAM_END\r\n);\r\n}\r\nreturn result;\r\n}\r\nstatic int tonga_populate_smc_boot_level(struct pp_hwmgr *hwmgr,\r\nSMU72_Discrete_DpmTable *table)\r\n{\r\nint result = 0;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\ntable->GraphicsBootLevel = 0;\r\ntable->MemoryBootLevel = 0;\r\nresult = phm_find_boot_level(&(data->dpm_table.sclk_table),\r\ndata->vbios_boot_state.sclk_bootup_value,\r\n(uint32_t *)&(smu_data->smc_state_table.GraphicsBootLevel));\r\nif (result != 0) {\r\nsmu_data->smc_state_table.GraphicsBootLevel = 0;\r\npr_err("[powerplay] VBIOS did not find boot engine "\r\n"clock value in dependency table. "\r\n"Using Graphics DPM level 0 !");\r\nresult = 0;\r\n}\r\nresult = phm_find_boot_level(&(data->dpm_table.mclk_table),\r\ndata->vbios_boot_state.mclk_bootup_value,\r\n(uint32_t *)&(smu_data->smc_state_table.MemoryBootLevel));\r\nif (result != 0) {\r\nsmu_data->smc_state_table.MemoryBootLevel = 0;\r\npr_err("[powerplay] VBIOS did not find boot "\r\n"engine clock value in dependency table."\r\n"Using Memory DPM level 0 !");\r\nresult = 0;\r\n}\r\ntable->BootVoltage.Vddc =\r\nphm_get_voltage_id(&(data->vddc_voltage_table),\r\ndata->vbios_boot_state.vddc_bootup_value);\r\ntable->BootVoltage.VddGfx =\r\nphm_get_voltage_id(&(data->vddgfx_voltage_table),\r\ndata->vbios_boot_state.vddgfx_bootup_value);\r\ntable->BootVoltage.Vddci =\r\nphm_get_voltage_id(&(data->vddci_voltage_table),\r\ndata->vbios_boot_state.vddci_bootup_value);\r\ntable->BootMVdd = data->vbios_boot_state.mvdd_bootup_value;\r\nCONVERT_FROM_HOST_TO_SMC_US(table->BootMVdd);\r\nreturn result;\r\n}\r\nstatic int tonga_populate_clock_stretcher_data_table(struct pp_hwmgr *hwmgr)\r\n{\r\nuint32_t ro, efuse, efuse2, clock_freq, volt_without_cks,\r\nvolt_with_cks, value;\r\nuint16_t clock_freq_u16;\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nuint8_t type, i, j, cks_setting, stretch_amount, stretch_amount2,\r\nvolt_offset = 0;\r\nstruct phm_ppt_v1_information *table_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nstruct phm_ppt_v1_clock_voltage_dependency_table *sclk_table =\r\ntable_info->vdd_dep_on_sclk;\r\nuint32_t hw_revision, dev_id;\r\nstruct cgs_system_info sys_info = {0};\r\nstretch_amount = (uint8_t)table_info->cac_dtp_table->usClockStretchAmount;\r\nsys_info.size = sizeof(struct cgs_system_info);\r\nsys_info.info_id = CGS_SYSTEM_INFO_PCIE_REV;\r\ncgs_query_system_info(hwmgr->device, &sys_info);\r\nhw_revision = (uint32_t)sys_info.value;\r\nsys_info.info_id = CGS_SYSTEM_INFO_PCIE_DEV;\r\ncgs_query_system_info(hwmgr->device, &sys_info);\r\ndev_id = (uint32_t)sys_info.value;\r\nefuse = cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC,\r\nixSMU_EFUSE_0 + (146 * 4));\r\nefuse2 = cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC,\r\nixSMU_EFUSE_0 + (148 * 4));\r\nefuse &= 0xFF000000;\r\nefuse = efuse >> 24;\r\nefuse2 &= 0xF;\r\nif (efuse2 == 1)\r\nro = (2300 - 1350) * efuse / 255 + 1350;\r\nelse\r\nro = (2500 - 1000) * efuse / 255 + 1000;\r\nif (ro >= 1660)\r\ntype = 0;\r\nelse\r\ntype = 1;\r\nsmu_data->smc_state_table.ClockStretcherAmount = stretch_amount;\r\nfor (i = 0; i < sclk_table->count; i++) {\r\nsmu_data->smc_state_table.Sclk_CKS_masterEn0_7 |=\r\nsclk_table->entries[i].cks_enable << i;\r\nif (ASICID_IS_TONGA_P(dev_id, hw_revision)) {\r\nvolt_without_cks = (uint32_t)((7732 + 60 - ro - 20838 *\r\n(sclk_table->entries[i].clk/100) / 10000) * 1000 /\r\n(8730 - (5301 * (sclk_table->entries[i].clk/100) / 1000)));\r\nvolt_with_cks = (uint32_t)((5250 + 51 - ro - 2404 *\r\n(sclk_table->entries[i].clk/100) / 100000) * 1000 /\r\n(6146 - (3193 * (sclk_table->entries[i].clk/100) / 1000)));\r\n} else {\r\nvolt_without_cks = (uint32_t)((14041 *\r\n(sclk_table->entries[i].clk/100) / 10000 + 3571 + 75 - ro) * 1000 /\r\n(4026 - (13924 * (sclk_table->entries[i].clk/100) / 10000)));\r\nvolt_with_cks = (uint32_t)((13946 *\r\n(sclk_table->entries[i].clk/100) / 10000 + 3320 + 45 - ro) * 1000 /\r\n(3664 - (11454 * (sclk_table->entries[i].clk/100) / 10000)));\r\n}\r\nif (volt_without_cks >= volt_with_cks)\r\nvolt_offset = (uint8_t)(((volt_without_cks - volt_with_cks +\r\nsclk_table->entries[i].cks_voffset) * 100 / 625) + 1);\r\nsmu_data->smc_state_table.Sclk_voltageOffset[i] = volt_offset;\r\n}\r\nPHM_WRITE_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, PWR_CKS_ENABLE,\r\nSTRETCH_ENABLE, 0x0);\r\nPHM_WRITE_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, PWR_CKS_ENABLE,\r\nmasterReset, 0x1);\r\nPHM_WRITE_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, PWR_CKS_ENABLE,\r\nstaticEnable, 0x1);\r\nPHM_WRITE_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, PWR_CKS_ENABLE,\r\nmasterReset, 0x0);\r\nif (stretch_amount == 1 || stretch_amount == 2 || stretch_amount == 5)\r\nstretch_amount2 = 0;\r\nelse if (stretch_amount == 3 || stretch_amount == 4)\r\nstretch_amount2 = 1;\r\nelse {\r\nphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_ClockStretcher);\r\nPP_ASSERT_WITH_CODE(false,\r\n"Stretch Amount in PPTable not supported\n",\r\nreturn -EINVAL);\r\n}\r\nvalue = cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC,\r\nixPWR_CKS_CNTL);\r\nvalue &= 0xFFC2FF87;\r\nsmu_data->smc_state_table.CKS_LOOKUPTable.CKS_LOOKUPTableEntry[0].minFreq =\r\ntonga_clock_stretcher_lookup_table[stretch_amount2][0];\r\nsmu_data->smc_state_table.CKS_LOOKUPTable.CKS_LOOKUPTableEntry[0].maxFreq =\r\ntonga_clock_stretcher_lookup_table[stretch_amount2][1];\r\nclock_freq_u16 = (uint16_t)(PP_SMC_TO_HOST_UL(smu_data->smc_state_table.\r\nGraphicsLevel[smu_data->smc_state_table.GraphicsDpmLevelCount - 1].\r\nSclkFrequency) / 100);\r\nif (tonga_clock_stretcher_lookup_table[stretch_amount2][0] <\r\nclock_freq_u16 &&\r\ntonga_clock_stretcher_lookup_table[stretch_amount2][1] >\r\nclock_freq_u16) {\r\nvalue |= (tonga_clock_stretcher_lookup_table[stretch_amount2][3]) << 16;\r\nvalue |= (tonga_clock_stretcher_lookup_table[stretch_amount2][2]) << 18;\r\nvalue |= (tonga_clock_stretch_amount_conversion\r\n[tonga_clock_stretcher_lookup_table[stretch_amount2][3]]\r\n[stretch_amount]) << 3;\r\n}\r\nCONVERT_FROM_HOST_TO_SMC_US(smu_data->smc_state_table.CKS_LOOKUPTable.\r\nCKS_LOOKUPTableEntry[0].minFreq);\r\nCONVERT_FROM_HOST_TO_SMC_US(smu_data->smc_state_table.CKS_LOOKUPTable.\r\nCKS_LOOKUPTableEntry[0].maxFreq);\r\nsmu_data->smc_state_table.CKS_LOOKUPTable.CKS_LOOKUPTableEntry[0].setting =\r\ntonga_clock_stretcher_lookup_table[stretch_amount2][2] & 0x7F;\r\nsmu_data->smc_state_table.CKS_LOOKUPTable.CKS_LOOKUPTableEntry[0].setting |=\r\n(tonga_clock_stretcher_lookup_table[stretch_amount2][3]) << 7;\r\ncgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC,\r\nixPWR_CKS_CNTL, value);\r\nfor (i = 0; i < 4; i++) {\r\nsmu_data->smc_state_table.ClockStretcherDataTable.\r\nClockStretcherDataTableEntry[i].minVID =\r\n(uint8_t) tonga_clock_stretcher_ddt_table[type][i][2];\r\nsmu_data->smc_state_table.ClockStretcherDataTable.\r\nClockStretcherDataTableEntry[i].maxVID =\r\n(uint8_t) tonga_clock_stretcher_ddt_table[type][i][3];\r\nfor (j = 0; j < smu_data->smc_state_table.GraphicsDpmLevelCount; j++) {\r\ncks_setting = 0;\r\nclock_freq = PP_SMC_TO_HOST_UL(\r\nsmu_data->smc_state_table.GraphicsLevel[j].SclkFrequency);\r\nif (clock_freq >= tonga_clock_stretcher_ddt_table[type][i][0] * 100) {\r\ncks_setting |= 0x2;\r\nif (clock_freq < tonga_clock_stretcher_ddt_table[type][i][1] * 100)\r\ncks_setting |= 0x1;\r\n}\r\nsmu_data->smc_state_table.ClockStretcherDataTable.\r\nClockStretcherDataTableEntry[i].setting |= cks_setting << (j * 2);\r\n}\r\nCONVERT_FROM_HOST_TO_SMC_US(smu_data->smc_state_table.\r\nClockStretcherDataTable.\r\nClockStretcherDataTableEntry[i].setting);\r\n}\r\nvalue = cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC,\r\nixPWR_CKS_CNTL);\r\nvalue &= 0xFFFFFFFE;\r\ncgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC,\r\nixPWR_CKS_CNTL, value);\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_vr_config(struct pp_hwmgr *hwmgr,\r\nSMU72_Discrete_DpmTable *table)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nuint16_t config;\r\nif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->vdd_gfx_control) {\r\nconfig = VR_SVI2_PLANE_1;\r\ntable->VRConfig |= (config<<VRCONF_VDDGFX_SHIFT);\r\nif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->voltage_control) {\r\nconfig = VR_SVI2_PLANE_2;\r\ntable->VRConfig |= config;\r\n} else {\r\npr_err("VDDC and VDDGFX should "\r\n"be both on SVI2 control in splitted mode !\n");\r\n}\r\n} else {\r\nconfig = VR_MERGED_WITH_VDDC;\r\ntable->VRConfig |= (config<<VRCONF_VDDGFX_SHIFT);\r\nif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->voltage_control) {\r\nconfig = VR_SVI2_PLANE_1;\r\ntable->VRConfig |= config;\r\n} else {\r\npr_err("VDDC should be on "\r\n"SVI2 control in merged mode !\n");\r\n}\r\n}\r\nif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->vddci_control) {\r\nconfig = VR_SVI2_PLANE_2;\r\ntable->VRConfig |= (config<<VRCONF_VDDCI_SHIFT);\r\n} else if (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->vddci_control) {\r\nconfig = VR_SMIO_PATTERN_1;\r\ntable->VRConfig |= (config<<VRCONF_VDDCI_SHIFT);\r\n}\r\nif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->mvdd_control) {\r\nconfig = VR_SMIO_PATTERN_2;\r\ntable->VRConfig |= (config<<VRCONF_MVDD_SHIFT);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tonga_init_arb_table_index(struct pp_smumgr *smumgr)\r\n{\r\nstruct tonga_smumgr *smu_data = (struct tonga_smumgr *)(smumgr->backend);\r\nuint32_t tmp;\r\nint result;\r\nresult = smu7_read_smc_sram_dword(smumgr,\r\nsmu_data->smu7_data.arb_table_start, &tmp, SMC_RAM_END);\r\nif (result != 0)\r\nreturn result;\r\ntmp &= 0x00FFFFFF;\r\ntmp |= ((uint32_t)MC_CG_ARB_FREQ_F1) << 24;\r\nreturn smu7_write_smc_sram_dword(smumgr,\r\nsmu_data->smu7_data.arb_table_start, tmp, SMC_RAM_END);\r\n}\r\nstatic int tonga_populate_bapm_parameters_in_dpm_table(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nconst struct tonga_pt_defaults *defaults = smu_data->power_tune_defaults;\r\nSMU72_Discrete_DpmTable *dpm_table = &(smu_data->smc_state_table);\r\nstruct phm_ppt_v1_information *table_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nstruct phm_cac_tdp_table *cac_dtp_table = table_info->cac_dtp_table;\r\nint i, j, k;\r\nconst uint16_t *pdef1, *pdef2;\r\ndpm_table->DefaultTdp = PP_HOST_TO_SMC_US(\r\n(uint16_t)(cac_dtp_table->usTDP * 256));\r\ndpm_table->TargetTdp = PP_HOST_TO_SMC_US(\r\n(uint16_t)(cac_dtp_table->usConfigurableTDP * 256));\r\nPP_ASSERT_WITH_CODE(cac_dtp_table->usTargetOperatingTemp <= 255,\r\n"Target Operating Temp is out of Range !",\r\n);\r\ndpm_table->GpuTjMax = (uint8_t)(cac_dtp_table->usTargetOperatingTemp);\r\ndpm_table->GpuTjHyst = 8;\r\ndpm_table->DTEAmbientTempBase = defaults->dte_ambient_temp_base;\r\ndpm_table->BAPM_TEMP_GRADIENT =\r\nPP_HOST_TO_SMC_UL(defaults->bamp_temp_gradient);\r\npdef1 = defaults->bapmti_r;\r\npdef2 = defaults->bapmti_rc;\r\nfor (i = 0; i < SMU72_DTE_ITERATIONS; i++) {\r\nfor (j = 0; j < SMU72_DTE_SOURCES; j++) {\r\nfor (k = 0; k < SMU72_DTE_SINKS; k++) {\r\ndpm_table->BAPMTI_R[i][j][k] =\r\nPP_HOST_TO_SMC_US(*pdef1);\r\ndpm_table->BAPMTI_RC[i][j][k] =\r\nPP_HOST_TO_SMC_US(*pdef2);\r\npdef1++;\r\npdef2++;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_svi_load_line(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nconst struct tonga_pt_defaults *defaults = smu_data->power_tune_defaults;\r\nsmu_data->power_tune_table.SviLoadLineEn = defaults->svi_load_line_en;\r\nsmu_data->power_tune_table.SviLoadLineVddC = defaults->svi_load_line_vddC;\r\nsmu_data->power_tune_table.SviLoadLineTrimVddC = 3;\r\nsmu_data->power_tune_table.SviLoadLineOffsetVddC = 0;\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_tdc_limit(struct pp_hwmgr *hwmgr)\r\n{\r\nuint16_t tdc_limit;\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nconst struct tonga_pt_defaults *defaults = smu_data->power_tune_defaults;\r\nstruct phm_ppt_v1_information *table_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\ntdc_limit = (uint16_t)(table_info->cac_dtp_table->usTDC * 256);\r\nsmu_data->power_tune_table.TDC_VDDC_PkgLimit =\r\nCONVERT_FROM_HOST_TO_SMC_US(tdc_limit);\r\nsmu_data->power_tune_table.TDC_VDDC_ThrottleReleaseLimitPerc =\r\ndefaults->tdc_vddc_throttle_release_limit_perc;\r\nsmu_data->power_tune_table.TDC_MAWt = defaults->tdc_mawt;\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_dw8(struct pp_hwmgr *hwmgr, uint32_t fuse_table_offset)\r\n{\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nconst struct tonga_pt_defaults *defaults = smu_data->power_tune_defaults;\r\nuint32_t temp;\r\nif (smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nfuse_table_offset +\r\noffsetof(SMU72_Discrete_PmFuses, TdcWaterfallCtl),\r\n(uint32_t *)&temp, SMC_RAM_END))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to read PmFuses.DW6 "\r\n"(SviLoadLineEn) from SMC Failed !",\r\nreturn -EINVAL);\r\nelse\r\nsmu_data->power_tune_table.TdcWaterfallCtl = defaults->tdc_waterfall_ctl;\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_temperature_scaler(struct pp_hwmgr *hwmgr)\r\n{\r\nint i;\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nfor (i = 0; i < 16; i++)\r\nsmu_data->power_tune_table.LPMLTemperatureScaler[i] = 0;\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_fuzzy_fan(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct tonga_smumgr *smu_data = (struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nif ((hwmgr->thermal_controller.advanceFanControlParameters.\r\nusFanOutputSensitivity & (1 << 15)) ||\r\n(hwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity == 0))\r\nhwmgr->thermal_controller.advanceFanControlParameters.\r\nusFanOutputSensitivity = hwmgr->thermal_controller.\r\nadvanceFanControlParameters.usDefaultFanOutputSensitivity;\r\nsmu_data->power_tune_table.FuzzyFan_PwmSetDelta =\r\nPP_HOST_TO_SMC_US(hwmgr->thermal_controller.\r\nadvanceFanControlParameters.usFanOutputSensitivity);\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_gnb_lpml(struct pp_hwmgr *hwmgr)\r\n{\r\nint i;\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nfor (i = 0; i < 16; i++)\r\nsmu_data->power_tune_table.GnbLPML[i] = 0;\r\nreturn 0;\r\n}\r\nstatic int tonga_min_max_vgnb_lpml_id_from_bapm_vddc(struct pp_hwmgr *hwmgr)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_bapm_vddc_base_leakage_sidd(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nstruct phm_ppt_v1_information *table_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nuint16_t hi_sidd = smu_data->power_tune_table.BapmVddCBaseLeakageHiSidd;\r\nuint16_t lo_sidd = smu_data->power_tune_table.BapmVddCBaseLeakageLoSidd;\r\nstruct phm_cac_tdp_table *cac_table = table_info->cac_dtp_table;\r\nhi_sidd = (uint16_t)(cac_table->usHighCACLeakage / 100 * 256);\r\nlo_sidd = (uint16_t)(cac_table->usLowCACLeakage / 100 * 256);\r\nsmu_data->power_tune_table.BapmVddCBaseLeakageHiSidd =\r\nCONVERT_FROM_HOST_TO_SMC_US(hi_sidd);\r\nsmu_data->power_tune_table.BapmVddCBaseLeakageLoSidd =\r\nCONVERT_FROM_HOST_TO_SMC_US(lo_sidd);\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_pm_fuses(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nuint32_t pm_fuse_table_offset;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_PowerContainment)) {\r\nif (smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nSMU72_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU72_Firmware_Header, PmFuseTable),\r\n&pm_fuse_table_offset, SMC_RAM_END))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to get pm_fuse_table_offset Failed !",\r\nreturn -EINVAL);\r\nif (tonga_populate_svi_load_line(hwmgr))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate SviLoadLine Failed !",\r\nreturn -EINVAL);\r\nif (tonga_populate_tdc_limit(hwmgr))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate TDCLimit Failed !",\r\nreturn -EINVAL);\r\nif (tonga_populate_dw8(hwmgr, pm_fuse_table_offset))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate TdcWaterfallCtl Failed !",\r\nreturn -EINVAL);\r\nif (tonga_populate_temperature_scaler(hwmgr) != 0)\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate LPMLTemperatureScaler Failed !",\r\nreturn -EINVAL);\r\nif (tonga_populate_fuzzy_fan(hwmgr))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate Fuzzy Fan "\r\n"Control parameters Failed !",\r\nreturn -EINVAL);\r\nif (tonga_populate_gnb_lpml(hwmgr))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate GnbLPML Failed !",\r\nreturn -EINVAL);\r\nif (tonga_min_max_vgnb_lpml_id_from_bapm_vddc(hwmgr))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate GnbLPML "\r\n"Min and Max Vid Failed !",\r\nreturn -EINVAL);\r\nif (tonga_populate_bapm_vddc_base_leakage_sidd(hwmgr))\r\nPP_ASSERT_WITH_CODE(\r\nfalse,\r\n"Attempt to populate BapmVddCBaseLeakage "\r\n"Hi and Lo Sidd Failed !",\r\nreturn -EINVAL);\r\nif (smu7_copy_bytes_to_smc(hwmgr->smumgr, pm_fuse_table_offset,\r\n(uint8_t *)&smu_data->power_tune_table,\r\nsizeof(struct SMU72_Discrete_PmFuses), SMC_RAM_END))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to download PmFuseTable Failed !",\r\nreturn -EINVAL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tonga_populate_mc_reg_address(struct pp_smumgr *smumgr,\r\nSMU72_Discrete_MCRegisters *mc_reg_table)\r\n{\r\nconst struct tonga_smumgr *smu_data = (struct tonga_smumgr *)smumgr->backend;\r\nuint32_t i, j;\r\nfor (i = 0, j = 0; j < smu_data->mc_reg_table.last; j++) {\r\nif (smu_data->mc_reg_table.validflag & 1<<j) {\r\nPP_ASSERT_WITH_CODE(\r\ni < SMU72_DISCRETE_MC_REGISTER_ARRAY_SIZE,\r\n"Index of mc_reg_table->address[] array "\r\n"out of boundary",\r\nreturn -EINVAL);\r\nmc_reg_table->address[i].s0 =\r\nPP_HOST_TO_SMC_US(smu_data->mc_reg_table.mc_reg_address[j].s0);\r\nmc_reg_table->address[i].s1 =\r\nPP_HOST_TO_SMC_US(smu_data->mc_reg_table.mc_reg_address[j].s1);\r\ni++;\r\n}\r\n}\r\nmc_reg_table->last = (uint8_t)i;\r\nreturn 0;\r\n}\r\nstatic void tonga_convert_mc_registers(\r\nconst struct tonga_mc_reg_entry *entry,\r\nSMU72_Discrete_MCRegisterSet *data,\r\nuint32_t num_entries, uint32_t valid_flag)\r\n{\r\nuint32_t i, j;\r\nfor (i = 0, j = 0; j < num_entries; j++) {\r\nif (valid_flag & 1<<j) {\r\ndata->value[i] = PP_HOST_TO_SMC_UL(entry->mc_data[j]);\r\ni++;\r\n}\r\n}\r\n}\r\nstatic int tonga_convert_mc_reg_table_entry_to_smc(\r\nstruct pp_smumgr *smumgr,\r\nconst uint32_t memory_clock,\r\nSMU72_Discrete_MCRegisterSet *mc_reg_table_data\r\n)\r\n{\r\nstruct tonga_smumgr *smu_data = (struct tonga_smumgr *)(smumgr->backend);\r\nuint32_t i = 0;\r\nfor (i = 0; i < smu_data->mc_reg_table.num_entries; i++) {\r\nif (memory_clock <=\r\nsmu_data->mc_reg_table.mc_reg_table_entry[i].mclk_max) {\r\nbreak;\r\n}\r\n}\r\nif ((i == smu_data->mc_reg_table.num_entries) && (i > 0))\r\n--i;\r\ntonga_convert_mc_registers(&smu_data->mc_reg_table.mc_reg_table_entry[i],\r\nmc_reg_table_data, smu_data->mc_reg_table.last,\r\nsmu_data->mc_reg_table.validflag);\r\nreturn 0;\r\n}\r\nstatic int tonga_convert_mc_reg_table_to_smc(struct pp_hwmgr *hwmgr,\r\nSMU72_Discrete_MCRegisters *mc_regs)\r\n{\r\nint result = 0;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nint res;\r\nuint32_t i;\r\nfor (i = 0; i < data->dpm_table.mclk_table.count; i++) {\r\nres = tonga_convert_mc_reg_table_entry_to_smc(\r\nhwmgr->smumgr,\r\ndata->dpm_table.mclk_table.dpm_levels[i].value,\r\n&mc_regs->data[i]\r\n);\r\nif (0 != res)\r\nresult = res;\r\n}\r\nreturn result;\r\n}\r\nstatic int tonga_update_and_upload_mc_reg_table(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct pp_smumgr *smumgr = hwmgr->smumgr;\r\nstruct tonga_smumgr *smu_data = (struct tonga_smumgr *)(smumgr->backend);\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nuint32_t address;\r\nint32_t result;\r\nif (0 == (data->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK))\r\nreturn 0;\r\nmemset(&smu_data->mc_regs, 0, sizeof(SMU72_Discrete_MCRegisters));\r\nresult = tonga_convert_mc_reg_table_to_smc(hwmgr, &(smu_data->mc_regs));\r\nif (result != 0)\r\nreturn result;\r\naddress = smu_data->smu7_data.mc_reg_table_start +\r\n(uint32_t)offsetof(SMU72_Discrete_MCRegisters, data[0]);\r\nreturn smu7_copy_bytes_to_smc(\r\nhwmgr->smumgr, address,\r\n(uint8_t *)&smu_data->mc_regs.data[0],\r\nsizeof(SMU72_Discrete_MCRegisterSet) *\r\ndata->dpm_table.mclk_table.count,\r\nSMC_RAM_END);\r\n}\r\nstatic int tonga_populate_initial_mc_reg_table(struct pp_hwmgr *hwmgr)\r\n{\r\nint result;\r\nstruct pp_smumgr *smumgr = hwmgr->smumgr;\r\nstruct tonga_smumgr *smu_data = (struct tonga_smumgr *)(smumgr->backend);\r\nmemset(&smu_data->mc_regs, 0x00, sizeof(SMU72_Discrete_MCRegisters));\r\nresult = tonga_populate_mc_reg_address(smumgr, &(smu_data->mc_regs));\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to initialize MCRegTable for the MC register addresses !",\r\nreturn result;);\r\nresult = tonga_convert_mc_reg_table_to_smc(hwmgr, &smu_data->mc_regs);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to initialize MCRegTable for driver state !",\r\nreturn result;);\r\nreturn smu7_copy_bytes_to_smc(smumgr, smu_data->smu7_data.mc_reg_table_start,\r\n(uint8_t *)&smu_data->mc_regs, sizeof(SMU72_Discrete_MCRegisters), SMC_RAM_END);\r\n}\r\nstatic void tonga_initialize_power_tune_defaults(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct tonga_smumgr *smu_data = (struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nstruct phm_ppt_v1_information *table_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nif (table_info &&\r\ntable_info->cac_dtp_table->usPowerTuneDataSetID <= POWERTUNE_DEFAULT_SET_MAX &&\r\ntable_info->cac_dtp_table->usPowerTuneDataSetID)\r\nsmu_data->power_tune_defaults =\r\n&tonga_power_tune_data_set_array\r\n[table_info->cac_dtp_table->usPowerTuneDataSetID - 1];\r\nelse\r\nsmu_data->power_tune_defaults = &tonga_power_tune_data_set_array[0];\r\n}\r\nstatic void tonga_save_default_power_profile(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct tonga_smumgr *data = (struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nstruct SMU72_Discrete_GraphicsLevel *levels =\r\ndata->smc_state_table.GraphicsLevel;\r\nunsigned min_level = 1;\r\nhwmgr->default_gfx_power_profile.activity_threshold =\r\nbe16_to_cpu(levels[0].ActivityLevel);\r\nhwmgr->default_gfx_power_profile.up_hyst = levels[0].UpHyst;\r\nhwmgr->default_gfx_power_profile.down_hyst = levels[0].DownHyst;\r\nhwmgr->default_gfx_power_profile.type = AMD_PP_GFX_PROFILE;\r\nhwmgr->default_compute_power_profile = hwmgr->default_gfx_power_profile;\r\nhwmgr->default_compute_power_profile.type = AMD_PP_COMPUTE_PROFILE;\r\nif (data->smc_state_table.GraphicsDpmLevelCount > 2)\r\nmin_level = data->smc_state_table.GraphicsDpmLevelCount - 2;\r\nelse if (data->smc_state_table.GraphicsDpmLevelCount == 2)\r\nmin_level = 1;\r\nelse\r\nmin_level = 0;\r\nhwmgr->default_compute_power_profile.min_sclk =\r\nbe32_to_cpu(levels[min_level].SclkFrequency);\r\nhwmgr->default_compute_power_profile.up_hyst = 0;\r\nhwmgr->default_compute_power_profile.down_hyst = 5;\r\nhwmgr->gfx_power_profile = hwmgr->default_gfx_power_profile;\r\nhwmgr->compute_power_profile = hwmgr->default_compute_power_profile;\r\n}\r\nint tonga_init_smc_table(struct pp_hwmgr *hwmgr)\r\n{\r\nint result;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nSMU72_Discrete_DpmTable *table = &(smu_data->smc_state_table);\r\nstruct phm_ppt_v1_information *table_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nuint8_t i;\r\npp_atomctrl_gpio_pin_assignment gpio_pin_assignment;\r\nmemset(&(smu_data->smc_state_table), 0x00, sizeof(smu_data->smc_state_table));\r\ntonga_initialize_power_tune_defaults(hwmgr);\r\nif (SMU7_VOLTAGE_CONTROL_NONE != data->voltage_control)\r\ntonga_populate_smc_voltage_tables(hwmgr, table);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_AutomaticDCTransition))\r\ntable->SystemFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_StepVddc))\r\ntable->SystemFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;\r\nif (data->is_memory_gddr5)\r\ntable->SystemFlags |= PPSMC_SYSTEMFLAG_GDDR5;\r\ni = PHM_READ_FIELD(hwmgr->device, CC_MC_MAX_CHANNEL, NOOFCHAN);\r\nif (i == 1 || i == 0)\r\ntable->SystemFlags |= 0x40;\r\nif (data->ulv_supported && table_info->us_ulv_voltage_offset) {\r\nresult = tonga_populate_ulv_state(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to initialize ULV state !",\r\nreturn result;);\r\ncgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC,\r\nixCG_ULV_PARAMETER, 0x40035);\r\n}\r\nresult = tonga_populate_smc_link_level(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to initialize Link Level !", return result);\r\nresult = tonga_populate_all_graphic_levels(hwmgr);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to initialize Graphics Level !", return result);\r\nresult = tonga_populate_all_memory_levels(hwmgr);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to initialize Memory Level !", return result);\r\nresult = tonga_populate_smc_acpi_level(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to initialize ACPI Level !", return result);\r\nresult = tonga_populate_smc_vce_level(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to initialize VCE Level !", return result);\r\nresult = tonga_populate_smc_acp_level(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to initialize ACP Level !", return result);\r\nresult = tonga_populate_smc_samu_level(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to initialize SAMU Level !", return result);\r\nresult = tonga_program_memory_timing_parameters(hwmgr);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to Write ARB settings for the initial state.",\r\nreturn result;);\r\nresult = tonga_populate_smc_uvd_level(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to initialize UVD Level !", return result);\r\nresult = tonga_populate_smc_boot_level(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to initialize Boot Level !", return result);\r\ntonga_populate_bapm_parameters_in_dpm_table(hwmgr);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to populate BAPM Parameters !", return result);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_ClockStretcher)) {\r\nresult = tonga_populate_clock_stretcher_data_table(hwmgr);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to populate Clock Stretcher Data Table !",\r\nreturn result;);\r\n}\r\ntable->GraphicsVoltageChangeEnable = 1;\r\ntable->GraphicsThermThrottleEnable = 1;\r\ntable->GraphicsInterval = 1;\r\ntable->VoltageInterval = 1;\r\ntable->ThermalInterval = 1;\r\ntable->TemperatureLimitHigh =\r\ntable_info->cac_dtp_table->usTargetOperatingTemp *\r\nSMU7_Q88_FORMAT_CONVERSION_UNIT;\r\ntable->TemperatureLimitLow =\r\n(table_info->cac_dtp_table->usTargetOperatingTemp - 1) *\r\nSMU7_Q88_FORMAT_CONVERSION_UNIT;\r\ntable->MemoryVoltageChangeEnable = 1;\r\ntable->MemoryInterval = 1;\r\ntable->VoltageResponseTime = 0;\r\ntable->PhaseResponseTime = 0;\r\ntable->MemoryThermThrottleEnable = 1;\r\nPP_ASSERT_WITH_CODE((1 <= data->dpm_table.pcie_speed_table.count),\r\n"There must be 1 or more PCIE levels defined in PPTable.",\r\nreturn -EINVAL);\r\ntable->PCIeBootLinkLevel = (uint8_t) (data->dpm_table.pcie_speed_table.count);\r\ntable->PCIeGenInterval = 1;\r\nresult = tonga_populate_vr_config(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to populate VRConfig setting !", return result);\r\ntable->ThermGpio = 17;\r\ntable->SclkStepSize = 0x4000;\r\nif (atomctrl_get_pp_assign_pin(hwmgr, VDDC_VRHOT_GPIO_PINID,\r\n&gpio_pin_assignment)) {\r\ntable->VRHotGpio = gpio_pin_assignment.uc_gpio_pin_bit_shift;\r\nphm_cap_set(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_RegulatorHot);\r\n} else {\r\ntable->VRHotGpio = SMU7_UNUSED_GPIO_PIN;\r\nphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_RegulatorHot);\r\n}\r\nif (atomctrl_get_pp_assign_pin(hwmgr, PP_AC_DC_SWITCH_GPIO_PINID,\r\n&gpio_pin_assignment)) {\r\ntable->AcDcGpio = gpio_pin_assignment.uc_gpio_pin_bit_shift;\r\nphm_cap_set(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_AutomaticDCTransition);\r\n} else {\r\ntable->AcDcGpio = SMU7_UNUSED_GPIO_PIN;\r\nphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_AutomaticDCTransition);\r\n}\r\nphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_Falcon_QuickTransition);\r\nif (0) {\r\nphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_AutomaticDCTransition);\r\nphm_cap_set(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_Falcon_QuickTransition);\r\n}\r\nif (atomctrl_get_pp_assign_pin(hwmgr,\r\nTHERMAL_INT_OUTPUT_GPIO_PINID, &gpio_pin_assignment)) {\r\nphm_cap_set(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_ThermalOutGPIO);\r\ntable->ThermOutGpio = gpio_pin_assignment.uc_gpio_pin_bit_shift;\r\ntable->ThermOutPolarity =\r\n(0 == (cgs_read_register(hwmgr->device, mmGPIOPAD_A) &\r\n(1 << gpio_pin_assignment.uc_gpio_pin_bit_shift))) ? 1 : 0;\r\ntable->ThermOutMode = SMU7_THERM_OUT_MODE_THERM_ONLY;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_RegulatorHot) &&\r\nphm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_CombinePCCWithThermalSignal)){\r\ntable->ThermOutMode = SMU7_THERM_OUT_MODE_THERM_VRHOT;\r\n}\r\n} else {\r\nphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_ThermalOutGPIO);\r\ntable->ThermOutGpio = 17;\r\ntable->ThermOutPolarity = 1;\r\ntable->ThermOutMode = SMU7_THERM_OUT_MODE_DISABLE;\r\n}\r\nfor (i = 0; i < SMU72_MAX_ENTRIES_SMIO; i++)\r\ntable->Smio[i] = PP_HOST_TO_SMC_UL(table->Smio[i]);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->SystemFlags);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->VRConfig);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->SmioMask1);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->SmioMask2);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->SclkStepSize);\r\nCONVERT_FROM_HOST_TO_SMC_US(table->TemperatureLimitHigh);\r\nCONVERT_FROM_HOST_TO_SMC_US(table->TemperatureLimitLow);\r\nCONVERT_FROM_HOST_TO_SMC_US(table->VoltageResponseTime);\r\nCONVERT_FROM_HOST_TO_SMC_US(table->PhaseResponseTime);\r\nresult = smu7_copy_bytes_to_smc(\r\nhwmgr->smumgr,\r\nsmu_data->smu7_data.dpm_table_start + offsetof(SMU72_Discrete_DpmTable, SystemFlags),\r\n(uint8_t *)&(table->SystemFlags),\r\nsizeof(SMU72_Discrete_DpmTable) - 3 * sizeof(SMU72_PIDController),\r\nSMC_RAM_END);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to upload dpm data to SMC memory !", return result;);\r\nresult = tonga_init_arb_table_index(hwmgr->smumgr);\r\nPP_ASSERT_WITH_CODE(!result,\r\n"Failed to upload arb data to SMC memory !", return result);\r\ntonga_populate_pm_fuses(hwmgr);\r\nPP_ASSERT_WITH_CODE((!result),\r\n"Failed to populate initialize pm fuses !", return result);\r\nresult = tonga_populate_initial_mc_reg_table(hwmgr);\r\nPP_ASSERT_WITH_CODE((!result),\r\n"Failed to populate initialize MC Reg table !", return result);\r\ntonga_save_default_power_profile(hwmgr);\r\nreturn 0;\r\n}\r\nint tonga_thermal_setup_fan_table(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nSMU72_Discrete_FanTable fan_table = { FDO_MODE_HARDWARE };\r\nuint32_t duty100;\r\nuint32_t t_diff1, t_diff2, pwm_diff1, pwm_diff2;\r\nuint16_t fdo_min, slope1, slope2;\r\nuint32_t reference_clock;\r\nint res;\r\nuint64_t tmp64;\r\nif (!phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_MicrocodeFanControl))\r\nreturn 0;\r\nif (hwmgr->thermal_controller.fanInfo.bNoFan) {\r\nphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_MicrocodeFanControl);\r\nreturn 0;\r\n}\r\nif (0 == smu_data->smu7_data.fan_table_start) {\r\nphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_MicrocodeFanControl);\r\nreturn 0;\r\n}\r\nduty100 = PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device,\r\nCGS_IND_REG__SMC,\r\nCG_FDO_CTRL1, FMAX_DUTY100);\r\nif (0 == duty100) {\r\nphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_MicrocodeFanControl);\r\nreturn 0;\r\n}\r\ntmp64 = hwmgr->thermal_controller.advanceFanControlParameters.usPWMMin * duty100;\r\ndo_div(tmp64, 10000);\r\nfdo_min = (uint16_t)tmp64;\r\nt_diff1 = hwmgr->thermal_controller.advanceFanControlParameters.usTMed -\r\nhwmgr->thermal_controller.advanceFanControlParameters.usTMin;\r\nt_diff2 = hwmgr->thermal_controller.advanceFanControlParameters.usTHigh -\r\nhwmgr->thermal_controller.advanceFanControlParameters.usTMed;\r\npwm_diff1 = hwmgr->thermal_controller.advanceFanControlParameters.usPWMMed -\r\nhwmgr->thermal_controller.advanceFanControlParameters.usPWMMin;\r\npwm_diff2 = hwmgr->thermal_controller.advanceFanControlParameters.usPWMHigh -\r\nhwmgr->thermal_controller.advanceFanControlParameters.usPWMMed;\r\nslope1 = (uint16_t)((50 + ((16 * duty100 * pwm_diff1) / t_diff1)) / 100);\r\nslope2 = (uint16_t)((50 + ((16 * duty100 * pwm_diff2) / t_diff2)) / 100);\r\nfan_table.TempMin = cpu_to_be16((50 + hwmgr->thermal_controller.advanceFanControlParameters.usTMin) / 100);\r\nfan_table.TempMed = cpu_to_be16((50 + hwmgr->thermal_controller.advanceFanControlParameters.usTMed) / 100);\r\nfan_table.TempMax = cpu_to_be16((50 + hwmgr->thermal_controller.advanceFanControlParameters.usTMax) / 100);\r\nfan_table.Slope1 = cpu_to_be16(slope1);\r\nfan_table.Slope2 = cpu_to_be16(slope2);\r\nfan_table.FdoMin = cpu_to_be16(fdo_min);\r\nfan_table.HystDown = cpu_to_be16(hwmgr->thermal_controller.advanceFanControlParameters.ucTHyst);\r\nfan_table.HystUp = cpu_to_be16(1);\r\nfan_table.HystSlope = cpu_to_be16(1);\r\nfan_table.TempRespLim = cpu_to_be16(5);\r\nreference_clock = smu7_get_xclk(hwmgr);\r\nfan_table.RefreshPeriod = cpu_to_be32((hwmgr->thermal_controller.advanceFanControlParameters.ulCycleDelay * reference_clock) / 1600);\r\nfan_table.FdoMax = cpu_to_be16((uint16_t)duty100);\r\nfan_table.TempSrc = (uint8_t)PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, CG_MULT_THERMAL_CTRL, TEMP_SEL);\r\nfan_table.FanControl_GL_Flag = 1;\r\nres = smu7_copy_bytes_to_smc(hwmgr->smumgr,\r\nsmu_data->smu7_data.fan_table_start,\r\n(uint8_t *)&fan_table,\r\n(uint32_t)sizeof(fan_table),\r\nSMC_RAM_END);\r\nreturn 0;\r\n}\r\nstatic int tonga_program_mem_timing_parameters(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nif (data->need_update_smu7_dpm_table &\r\n(DPMTABLE_OD_UPDATE_SCLK + DPMTABLE_OD_UPDATE_MCLK))\r\nreturn tonga_program_memory_timing_parameters(hwmgr);\r\nreturn 0;\r\n}\r\nint tonga_update_sclk_threshold(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nint result = 0;\r\nuint32_t low_sclk_interrupt_threshold = 0;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_SclkThrottleLowNotification)\r\n&& (hwmgr->gfx_arbiter.sclk_threshold !=\r\ndata->low_sclk_interrupt_threshold)) {\r\ndata->low_sclk_interrupt_threshold =\r\nhwmgr->gfx_arbiter.sclk_threshold;\r\nlow_sclk_interrupt_threshold =\r\ndata->low_sclk_interrupt_threshold;\r\nCONVERT_FROM_HOST_TO_SMC_UL(low_sclk_interrupt_threshold);\r\nresult = smu7_copy_bytes_to_smc(\r\nhwmgr->smumgr,\r\nsmu_data->smu7_data.dpm_table_start +\r\noffsetof(SMU72_Discrete_DpmTable,\r\nLowSclkInterruptThreshold),\r\n(uint8_t *)&low_sclk_interrupt_threshold,\r\nsizeof(uint32_t),\r\nSMC_RAM_END);\r\n}\r\nresult = tonga_update_and_upload_mc_reg_table(hwmgr);\r\nPP_ASSERT_WITH_CODE((!result),\r\n"Failed to upload MC reg table !",\r\nreturn result);\r\nresult = tonga_program_mem_timing_parameters(hwmgr);\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"Failed to program memory timing parameters !",\r\n);\r\nreturn result;\r\n}\r\nuint32_t tonga_get_offsetof(uint32_t type, uint32_t member)\r\n{\r\nswitch (type) {\r\ncase SMU_SoftRegisters:\r\nswitch (member) {\r\ncase HandshakeDisables:\r\nreturn offsetof(SMU72_SoftRegisters, HandshakeDisables);\r\ncase VoltageChangeTimeout:\r\nreturn offsetof(SMU72_SoftRegisters, VoltageChangeTimeout);\r\ncase AverageGraphicsActivity:\r\nreturn offsetof(SMU72_SoftRegisters, AverageGraphicsActivity);\r\ncase PreVBlankGap:\r\nreturn offsetof(SMU72_SoftRegisters, PreVBlankGap);\r\ncase VBlankTimeout:\r\nreturn offsetof(SMU72_SoftRegisters, VBlankTimeout);\r\ncase UcodeLoadStatus:\r\nreturn offsetof(SMU72_SoftRegisters, UcodeLoadStatus);\r\n}\r\ncase SMU_Discrete_DpmTable:\r\nswitch (member) {\r\ncase UvdBootLevel:\r\nreturn offsetof(SMU72_Discrete_DpmTable, UvdBootLevel);\r\ncase VceBootLevel:\r\nreturn offsetof(SMU72_Discrete_DpmTable, VceBootLevel);\r\ncase SamuBootLevel:\r\nreturn offsetof(SMU72_Discrete_DpmTable, SamuBootLevel);\r\ncase LowSclkInterruptThreshold:\r\nreturn offsetof(SMU72_Discrete_DpmTable, LowSclkInterruptThreshold);\r\n}\r\n}\r\npr_warn("can't get the offset of type %x member %x\n", type, member);\r\nreturn 0;\r\n}\r\nuint32_t tonga_get_mac_definition(uint32_t value)\r\n{\r\nswitch (value) {\r\ncase SMU_MAX_LEVELS_GRAPHICS:\r\nreturn SMU72_MAX_LEVELS_GRAPHICS;\r\ncase SMU_MAX_LEVELS_MEMORY:\r\nreturn SMU72_MAX_LEVELS_MEMORY;\r\ncase SMU_MAX_LEVELS_LINK:\r\nreturn SMU72_MAX_LEVELS_LINK;\r\ncase SMU_MAX_ENTRIES_SMIO:\r\nreturn SMU72_MAX_ENTRIES_SMIO;\r\ncase SMU_MAX_LEVELS_VDDC:\r\nreturn SMU72_MAX_LEVELS_VDDC;\r\ncase SMU_MAX_LEVELS_VDDGFX:\r\nreturn SMU72_MAX_LEVELS_VDDGFX;\r\ncase SMU_MAX_LEVELS_VDDCI:\r\nreturn SMU72_MAX_LEVELS_VDDCI;\r\ncase SMU_MAX_LEVELS_MVDD:\r\nreturn SMU72_MAX_LEVELS_MVDD;\r\n}\r\npr_warn("can't get the mac value %x\n", value);\r\nreturn 0;\r\n}\r\nstatic int tonga_update_uvd_smc_table(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nuint32_t mm_boot_level_offset, mm_boot_level_value;\r\nstruct phm_ppt_v1_information *table_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nsmu_data->smc_state_table.UvdBootLevel = 0;\r\nif (table_info->mm_dep_table->count > 0)\r\nsmu_data->smc_state_table.UvdBootLevel =\r\n(uint8_t) (table_info->mm_dep_table->count - 1);\r\nmm_boot_level_offset = smu_data->smu7_data.dpm_table_start +\r\noffsetof(SMU72_Discrete_DpmTable, UvdBootLevel);\r\nmm_boot_level_offset /= 4;\r\nmm_boot_level_offset *= 4;\r\nmm_boot_level_value = cgs_read_ind_register(hwmgr->device,\r\nCGS_IND_REG__SMC, mm_boot_level_offset);\r\nmm_boot_level_value &= 0x00FFFFFF;\r\nmm_boot_level_value |= smu_data->smc_state_table.UvdBootLevel << 24;\r\ncgs_write_ind_register(hwmgr->device,\r\nCGS_IND_REG__SMC,\r\nmm_boot_level_offset, mm_boot_level_value);\r\nif (!phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_UVDDPM) ||\r\nphm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_StablePState))\r\nsmum_send_msg_to_smc_with_parameter(hwmgr->smumgr,\r\nPPSMC_MSG_UVDDPM_SetEnabledMask,\r\n(uint32_t)(1 << smu_data->smc_state_table.UvdBootLevel));\r\nreturn 0;\r\n}\r\nstatic int tonga_update_vce_smc_table(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct tonga_smumgr *smu_data =\r\n(struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nuint32_t mm_boot_level_offset, mm_boot_level_value;\r\nstruct phm_ppt_v1_information *table_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nsmu_data->smc_state_table.VceBootLevel =\r\n(uint8_t) (table_info->mm_dep_table->count - 1);\r\nmm_boot_level_offset = smu_data->smu7_data.dpm_table_start +\r\noffsetof(SMU72_Discrete_DpmTable, VceBootLevel);\r\nmm_boot_level_offset /= 4;\r\nmm_boot_level_offset *= 4;\r\nmm_boot_level_value = cgs_read_ind_register(hwmgr->device,\r\nCGS_IND_REG__SMC, mm_boot_level_offset);\r\nmm_boot_level_value &= 0xFF00FFFF;\r\nmm_boot_level_value |= smu_data->smc_state_table.VceBootLevel << 16;\r\ncgs_write_ind_register(hwmgr->device,\r\nCGS_IND_REG__SMC, mm_boot_level_offset, mm_boot_level_value);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_StablePState))\r\nsmum_send_msg_to_smc_with_parameter(hwmgr->smumgr,\r\nPPSMC_MSG_VCEDPM_SetEnabledMask,\r\n(uint32_t)1 << smu_data->smc_state_table.VceBootLevel);\r\nreturn 0;\r\n}\r\nstatic int tonga_update_samu_smc_table(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct tonga_smumgr *smu_data = (struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nuint32_t mm_boot_level_offset, mm_boot_level_value;\r\nsmu_data->smc_state_table.SamuBootLevel = 0;\r\nmm_boot_level_offset = smu_data->smu7_data.dpm_table_start +\r\noffsetof(SMU72_Discrete_DpmTable, SamuBootLevel);\r\nmm_boot_level_offset /= 4;\r\nmm_boot_level_offset *= 4;\r\nmm_boot_level_value = cgs_read_ind_register(hwmgr->device,\r\nCGS_IND_REG__SMC, mm_boot_level_offset);\r\nmm_boot_level_value &= 0xFFFFFF00;\r\nmm_boot_level_value |= smu_data->smc_state_table.SamuBootLevel << 0;\r\ncgs_write_ind_register(hwmgr->device,\r\nCGS_IND_REG__SMC, mm_boot_level_offset, mm_boot_level_value);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_StablePState))\r\nsmum_send_msg_to_smc_with_parameter(hwmgr->smumgr,\r\nPPSMC_MSG_SAMUDPM_SetEnabledMask,\r\n(uint32_t)(1 << smu_data->smc_state_table.SamuBootLevel));\r\nreturn 0;\r\n}\r\nint tonga_update_smc_table(struct pp_hwmgr *hwmgr, uint32_t type)\r\n{\r\nswitch (type) {\r\ncase SMU_UVD_TABLE:\r\ntonga_update_uvd_smc_table(hwmgr);\r\nbreak;\r\ncase SMU_VCE_TABLE:\r\ntonga_update_vce_smc_table(hwmgr);\r\nbreak;\r\ncase SMU_SAMU_TABLE:\r\ntonga_update_samu_smc_table(hwmgr);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint tonga_process_firmware_header(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct tonga_smumgr *smu_data = (struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\nuint32_t tmp;\r\nint result;\r\nbool error = false;\r\nresult = smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nSMU72_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU72_Firmware_Header, DpmTable),\r\n&tmp, SMC_RAM_END);\r\nif (!result)\r\nsmu_data->smu7_data.dpm_table_start = tmp;\r\nerror |= (result != 0);\r\nresult = smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nSMU72_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU72_Firmware_Header, SoftRegisters),\r\n&tmp, SMC_RAM_END);\r\nif (!result) {\r\ndata->soft_regs_start = tmp;\r\nsmu_data->smu7_data.soft_regs_start = tmp;\r\n}\r\nerror |= (result != 0);\r\nresult = smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nSMU72_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU72_Firmware_Header, mcRegisterTable),\r\n&tmp, SMC_RAM_END);\r\nif (!result)\r\nsmu_data->smu7_data.mc_reg_table_start = tmp;\r\nresult = smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nSMU72_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU72_Firmware_Header, FanTable),\r\n&tmp, SMC_RAM_END);\r\nif (!result)\r\nsmu_data->smu7_data.fan_table_start = tmp;\r\nerror |= (result != 0);\r\nresult = smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nSMU72_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU72_Firmware_Header, mcArbDramTimingTable),\r\n&tmp, SMC_RAM_END);\r\nif (!result)\r\nsmu_data->smu7_data.arb_table_start = tmp;\r\nerror |= (result != 0);\r\nresult = smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nSMU72_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU72_Firmware_Header, Version),\r\n&tmp, SMC_RAM_END);\r\nif (!result)\r\nhwmgr->microcode_version_info.SMC = tmp;\r\nerror |= (result != 0);\r\nreturn error ? 1 : 0;\r\n}\r\nstatic uint8_t tonga_get_memory_modile_index(struct pp_hwmgr *hwmgr)\r\n{\r\nreturn (uint8_t) (0xFF & (cgs_read_register(hwmgr->device, mmBIOS_SCRATCH_4) >> 16));\r\n}\r\nstatic bool tonga_check_s0_mc_reg_index(uint16_t in_reg, uint16_t *out_reg)\r\n{\r\nbool result = true;\r\nswitch (in_reg) {\r\ncase mmMC_SEQ_RAS_TIMING:\r\n*out_reg = mmMC_SEQ_RAS_TIMING_LP;\r\nbreak;\r\ncase mmMC_SEQ_DLL_STBY:\r\n*out_reg = mmMC_SEQ_DLL_STBY_LP;\r\nbreak;\r\ncase mmMC_SEQ_G5PDX_CMD0:\r\n*out_reg = mmMC_SEQ_G5PDX_CMD0_LP;\r\nbreak;\r\ncase mmMC_SEQ_G5PDX_CMD1:\r\n*out_reg = mmMC_SEQ_G5PDX_CMD1_LP;\r\nbreak;\r\ncase mmMC_SEQ_G5PDX_CTRL:\r\n*out_reg = mmMC_SEQ_G5PDX_CTRL_LP;\r\nbreak;\r\ncase mmMC_SEQ_CAS_TIMING:\r\n*out_reg = mmMC_SEQ_CAS_TIMING_LP;\r\nbreak;\r\ncase mmMC_SEQ_MISC_TIMING:\r\n*out_reg = mmMC_SEQ_MISC_TIMING_LP;\r\nbreak;\r\ncase mmMC_SEQ_MISC_TIMING2:\r\n*out_reg = mmMC_SEQ_MISC_TIMING2_LP;\r\nbreak;\r\ncase mmMC_SEQ_PMG_DVS_CMD:\r\n*out_reg = mmMC_SEQ_PMG_DVS_CMD_LP;\r\nbreak;\r\ncase mmMC_SEQ_PMG_DVS_CTL:\r\n*out_reg = mmMC_SEQ_PMG_DVS_CTL_LP;\r\nbreak;\r\ncase mmMC_SEQ_RD_CTL_D0:\r\n*out_reg = mmMC_SEQ_RD_CTL_D0_LP;\r\nbreak;\r\ncase mmMC_SEQ_RD_CTL_D1:\r\n*out_reg = mmMC_SEQ_RD_CTL_D1_LP;\r\nbreak;\r\ncase mmMC_SEQ_WR_CTL_D0:\r\n*out_reg = mmMC_SEQ_WR_CTL_D0_LP;\r\nbreak;\r\ncase mmMC_SEQ_WR_CTL_D1:\r\n*out_reg = mmMC_SEQ_WR_CTL_D1_LP;\r\nbreak;\r\ncase mmMC_PMG_CMD_EMRS:\r\n*out_reg = mmMC_SEQ_PMG_CMD_EMRS_LP;\r\nbreak;\r\ncase mmMC_PMG_CMD_MRS:\r\n*out_reg = mmMC_SEQ_PMG_CMD_MRS_LP;\r\nbreak;\r\ncase mmMC_PMG_CMD_MRS1:\r\n*out_reg = mmMC_SEQ_PMG_CMD_MRS1_LP;\r\nbreak;\r\ncase mmMC_SEQ_PMG_TIMING:\r\n*out_reg = mmMC_SEQ_PMG_TIMING_LP;\r\nbreak;\r\ncase mmMC_PMG_CMD_MRS2:\r\n*out_reg = mmMC_SEQ_PMG_CMD_MRS2_LP;\r\nbreak;\r\ncase mmMC_SEQ_WR_CTL_2:\r\n*out_reg = mmMC_SEQ_WR_CTL_2_LP;\r\nbreak;\r\ndefault:\r\nresult = false;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int tonga_set_s0_mc_reg_index(struct tonga_mc_reg_table *table)\r\n{\r\nuint32_t i;\r\nuint16_t address;\r\nfor (i = 0; i < table->last; i++) {\r\ntable->mc_reg_address[i].s0 =\r\ntonga_check_s0_mc_reg_index(table->mc_reg_address[i].s1,\r\n&address) ?\r\naddress :\r\ntable->mc_reg_address[i].s1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tonga_copy_vbios_smc_reg_table(const pp_atomctrl_mc_reg_table *table,\r\nstruct tonga_mc_reg_table *ni_table)\r\n{\r\nuint8_t i, j;\r\nPP_ASSERT_WITH_CODE((table->last <= SMU72_DISCRETE_MC_REGISTER_ARRAY_SIZE),\r\n"Invalid VramInfo table.", return -EINVAL);\r\nPP_ASSERT_WITH_CODE((table->num_entries <= MAX_AC_TIMING_ENTRIES),\r\n"Invalid VramInfo table.", return -EINVAL);\r\nfor (i = 0; i < table->last; i++)\r\nni_table->mc_reg_address[i].s1 = table->mc_reg_address[i].s1;\r\nni_table->last = table->last;\r\nfor (i = 0; i < table->num_entries; i++) {\r\nni_table->mc_reg_table_entry[i].mclk_max =\r\ntable->mc_reg_table_entry[i].mclk_max;\r\nfor (j = 0; j < table->last; j++) {\r\nni_table->mc_reg_table_entry[i].mc_data[j] =\r\ntable->mc_reg_table_entry[i].mc_data[j];\r\n}\r\n}\r\nni_table->num_entries = table->num_entries;\r\nreturn 0;\r\n}\r\nstatic int tonga_set_mc_special_registers(struct pp_hwmgr *hwmgr,\r\nstruct tonga_mc_reg_table *table)\r\n{\r\nuint8_t i, j, k;\r\nuint32_t temp_reg;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nfor (i = 0, j = table->last; i < table->last; i++) {\r\nPP_ASSERT_WITH_CODE((j < SMU72_DISCRETE_MC_REGISTER_ARRAY_SIZE),\r\n"Invalid VramInfo table.", return -EINVAL);\r\nswitch (table->mc_reg_address[i].s1) {\r\ncase mmMC_SEQ_MISC1:\r\ntemp_reg = cgs_read_register(hwmgr->device,\r\nmmMC_PMG_CMD_EMRS);\r\ntable->mc_reg_address[j].s1 = mmMC_PMG_CMD_EMRS;\r\ntable->mc_reg_address[j].s0 = mmMC_SEQ_PMG_CMD_EMRS_LP;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n((temp_reg & 0xffff0000)) |\r\n((table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16);\r\n}\r\nj++;\r\nPP_ASSERT_WITH_CODE((j < SMU72_DISCRETE_MC_REGISTER_ARRAY_SIZE),\r\n"Invalid VramInfo table.", return -EINVAL);\r\ntemp_reg = cgs_read_register(hwmgr->device, mmMC_PMG_CMD_MRS);\r\ntable->mc_reg_address[j].s1 = mmMC_PMG_CMD_MRS;\r\ntable->mc_reg_address[j].s0 = mmMC_SEQ_PMG_CMD_MRS_LP;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n(temp_reg & 0xffff0000) |\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\r\nif (!data->is_memory_gddr5)\r\ntable->mc_reg_table_entry[k].mc_data[j] |= 0x100;\r\n}\r\nj++;\r\nPP_ASSERT_WITH_CODE((j <= SMU72_DISCRETE_MC_REGISTER_ARRAY_SIZE),\r\n"Invalid VramInfo table.", return -EINVAL);\r\nif (!data->is_memory_gddr5) {\r\ntable->mc_reg_address[j].s1 = mmMC_PMG_AUTO_CMD;\r\ntable->mc_reg_address[j].s0 = mmMC_PMG_AUTO_CMD;\r\nfor (k = 0; k < table->num_entries; k++)\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16;\r\nj++;\r\nPP_ASSERT_WITH_CODE((j <= SMU72_DISCRETE_MC_REGISTER_ARRAY_SIZE),\r\n"Invalid VramInfo table.", return -EINVAL);\r\n}\r\nbreak;\r\ncase mmMC_SEQ_RESERVE_M:\r\ntemp_reg = cgs_read_register(hwmgr->device, mmMC_PMG_CMD_MRS1);\r\ntable->mc_reg_address[j].s1 = mmMC_PMG_CMD_MRS1;\r\ntable->mc_reg_address[j].s0 = mmMC_SEQ_PMG_CMD_MRS1_LP;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n(temp_reg & 0xffff0000) |\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\r\n}\r\nj++;\r\nPP_ASSERT_WITH_CODE((j <= SMU72_DISCRETE_MC_REGISTER_ARRAY_SIZE),\r\n"Invalid VramInfo table.", return -EINVAL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ntable->last = j;\r\nreturn 0;\r\n}\r\nstatic int tonga_set_valid_flag(struct tonga_mc_reg_table *table)\r\n{\r\nuint8_t i, j;\r\nfor (i = 0; i < table->last; i++) {\r\nfor (j = 1; j < table->num_entries; j++) {\r\nif (table->mc_reg_table_entry[j-1].mc_data[i] !=\r\ntable->mc_reg_table_entry[j].mc_data[i]) {\r\ntable->validflag |= (1<<i);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint tonga_initialize_mc_reg_table(struct pp_hwmgr *hwmgr)\r\n{\r\nint result;\r\nstruct tonga_smumgr *smu_data = (struct tonga_smumgr *)(hwmgr->smumgr->backend);\r\npp_atomctrl_mc_reg_table *table;\r\nstruct tonga_mc_reg_table *ni_table = &smu_data->mc_reg_table;\r\nuint8_t module_index = tonga_get_memory_modile_index(hwmgr);\r\ntable = kzalloc(sizeof(pp_atomctrl_mc_reg_table), GFP_KERNEL);\r\nif (table == NULL)\r\nreturn -ENOMEM;\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_RAS_TIMING_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_RAS_TIMING));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_CAS_TIMING_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_CAS_TIMING));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_DLL_STBY_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_DLL_STBY));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_G5PDX_CMD0_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_G5PDX_CMD0));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_G5PDX_CMD1_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_G5PDX_CMD1));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_G5PDX_CTRL_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_G5PDX_CTRL));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_PMG_DVS_CMD_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_PMG_DVS_CMD));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_PMG_DVS_CTL_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_PMG_DVS_CTL));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_MISC_TIMING_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_MISC_TIMING));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_MISC_TIMING2_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_MISC_TIMING2));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_PMG_CMD_EMRS_LP,\r\ncgs_read_register(hwmgr->device, mmMC_PMG_CMD_EMRS));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_PMG_CMD_MRS_LP,\r\ncgs_read_register(hwmgr->device, mmMC_PMG_CMD_MRS));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_PMG_CMD_MRS1_LP,\r\ncgs_read_register(hwmgr->device, mmMC_PMG_CMD_MRS1));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_WR_CTL_D0_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_WR_CTL_D0));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_WR_CTL_D1_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_WR_CTL_D1));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_RD_CTL_D0_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_RD_CTL_D0));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_RD_CTL_D1_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_RD_CTL_D1));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_PMG_TIMING_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_PMG_TIMING));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_PMG_CMD_MRS2_LP,\r\ncgs_read_register(hwmgr->device, mmMC_PMG_CMD_MRS2));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_WR_CTL_2_LP,\r\ncgs_read_register(hwmgr->device, mmMC_SEQ_WR_CTL_2));\r\nmemset(table, 0x00, sizeof(pp_atomctrl_mc_reg_table));\r\nresult = atomctrl_initialize_mc_reg_table(hwmgr, module_index, table);\r\nif (!result)\r\nresult = tonga_copy_vbios_smc_reg_table(table, ni_table);\r\nif (!result) {\r\ntonga_set_s0_mc_reg_index(ni_table);\r\nresult = tonga_set_mc_special_registers(hwmgr, ni_table);\r\n}\r\nif (!result)\r\ntonga_set_valid_flag(ni_table);\r\nkfree(table);\r\nreturn result;\r\n}\r\nbool tonga_is_dpm_running(struct pp_hwmgr *hwmgr)\r\n{\r\nreturn (1 == PHM_READ_INDIRECT_FIELD(hwmgr->device,\r\nCGS_IND_REG__SMC, FEATURE_STATUS, VOLTAGE_CONTROLLER_ON))\r\n? true : false;\r\n}\r\nint tonga_populate_requested_graphic_levels(struct pp_hwmgr *hwmgr,\r\nstruct amd_pp_profile *request)\r\n{\r\nstruct tonga_smumgr *smu_data = (struct tonga_smumgr *)\r\n(hwmgr->smumgr->backend);\r\nstruct SMU72_Discrete_GraphicsLevel *levels =\r\nsmu_data->smc_state_table.GraphicsLevel;\r\nuint32_t array = smu_data->smu7_data.dpm_table_start +\r\noffsetof(SMU72_Discrete_DpmTable, GraphicsLevel);\r\nuint32_t array_size = sizeof(struct SMU72_Discrete_GraphicsLevel) *\r\nSMU72_MAX_LEVELS_GRAPHICS;\r\nuint32_t i;\r\nfor (i = 0; i < smu_data->smc_state_table.GraphicsDpmLevelCount; i++) {\r\nlevels[i].ActivityLevel =\r\ncpu_to_be16(request->activity_threshold);\r\nlevels[i].EnabledForActivity = 1;\r\nlevels[i].UpHyst = request->up_hyst;\r\nlevels[i].DownHyst = request->down_hyst;\r\n}\r\nreturn smu7_copy_bytes_to_smc(hwmgr->smumgr, array, (uint8_t *)levels,\r\narray_size, SMC_RAM_END);\r\n}
