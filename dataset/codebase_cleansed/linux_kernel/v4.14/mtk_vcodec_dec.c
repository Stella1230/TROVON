static struct mtk_video_fmt *mtk_vdec_find_format(struct v4l2_format *f)\r\n{\r\nstruct mtk_video_fmt *fmt;\r\nunsigned int k;\r\nfor (k = 0; k < NUM_FORMATS; k++) {\r\nfmt = &mtk_video_formats[k];\r\nif (fmt->fourcc == f->fmt.pix_mp.pixelformat)\r\nreturn fmt;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mtk_q_data *mtk_vdec_get_q_data(struct mtk_vcodec_ctx *ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nif (V4L2_TYPE_IS_OUTPUT(type))\r\nreturn &ctx->q_data[MTK_Q_DATA_SRC];\r\nreturn &ctx->q_data[MTK_Q_DATA_DST];\r\n}\r\nstatic struct vb2_buffer *get_display_buffer(struct mtk_vcodec_ctx *ctx)\r\n{\r\nstruct vdec_fb *disp_frame_buffer = NULL;\r\nstruct mtk_video_dec_buf *dstbuf;\r\nmtk_v4l2_debug(3, "[%d]", ctx->id);\r\nif (vdec_if_get_param(ctx,\r\nGET_PARAM_DISP_FRAME_BUFFER,\r\n&disp_frame_buffer)) {\r\nmtk_v4l2_err("[%d]Cannot get param : GET_PARAM_DISP_FRAME_BUFFER",\r\nctx->id);\r\nreturn NULL;\r\n}\r\nif (disp_frame_buffer == NULL) {\r\nmtk_v4l2_debug(3, "No display frame buffer");\r\nreturn NULL;\r\n}\r\ndstbuf = container_of(disp_frame_buffer, struct mtk_video_dec_buf,\r\nframe_buffer);\r\nmutex_lock(&ctx->lock);\r\nif (dstbuf->used) {\r\nvb2_set_plane_payload(&dstbuf->vb.vb2_buf, 0,\r\nctx->picinfo.y_bs_sz);\r\nvb2_set_plane_payload(&dstbuf->vb.vb2_buf, 1,\r\nctx->picinfo.c_bs_sz);\r\ndstbuf->ready_to_display = true;\r\nmtk_v4l2_debug(2,\r\n"[%d]status=%x queue id=%d to done_list %d",\r\nctx->id, disp_frame_buffer->status,\r\ndstbuf->vb.vb2_buf.index,\r\ndstbuf->queued_in_vb2);\r\nv4l2_m2m_buf_done(&dstbuf->vb, VB2_BUF_STATE_DONE);\r\nctx->decoded_frame_cnt++;\r\n}\r\nmutex_unlock(&ctx->lock);\r\nreturn &dstbuf->vb.vb2_buf;\r\n}\r\nstatic struct vb2_buffer *get_free_buffer(struct mtk_vcodec_ctx *ctx)\r\n{\r\nstruct mtk_video_dec_buf *dstbuf;\r\nstruct vdec_fb *free_frame_buffer = NULL;\r\nif (vdec_if_get_param(ctx,\r\nGET_PARAM_FREE_FRAME_BUFFER,\r\n&free_frame_buffer)) {\r\nmtk_v4l2_err("[%d] Error!! Cannot get param", ctx->id);\r\nreturn NULL;\r\n}\r\nif (free_frame_buffer == NULL) {\r\nmtk_v4l2_debug(3, " No free frame buffer");\r\nreturn NULL;\r\n}\r\nmtk_v4l2_debug(3, "[%d] tmp_frame_addr = 0x%p",\r\nctx->id, free_frame_buffer);\r\ndstbuf = container_of(free_frame_buffer, struct mtk_video_dec_buf,\r\nframe_buffer);\r\nmutex_lock(&ctx->lock);\r\nif (dstbuf->used) {\r\nif ((dstbuf->queued_in_vb2) &&\r\n(dstbuf->queued_in_v4l2) &&\r\n(free_frame_buffer->status == FB_ST_FREE)) {\r\nmtk_v4l2_debug(2,\r\n"[%d]status=%x queue id=%d to rdy_queue %d",\r\nctx->id, free_frame_buffer->status,\r\ndstbuf->vb.vb2_buf.index,\r\ndstbuf->queued_in_vb2);\r\nv4l2_m2m_buf_queue(ctx->m2m_ctx, &dstbuf->vb);\r\n} else if ((dstbuf->queued_in_vb2 == false) &&\r\n(dstbuf->queued_in_v4l2 == true)) {\r\nmtk_v4l2_debug(2,\r\n"[%d]status=%x queue id=%d to rdy_queue",\r\nctx->id, free_frame_buffer->status,\r\ndstbuf->vb.vb2_buf.index);\r\nv4l2_m2m_buf_queue(ctx->m2m_ctx, &dstbuf->vb);\r\ndstbuf->queued_in_vb2 = true;\r\n} else {\r\nmtk_v4l2_debug(3, "[%d]status=%x err queue id=%d %d %d",\r\nctx->id, free_frame_buffer->status,\r\ndstbuf->vb.vb2_buf.index,\r\ndstbuf->queued_in_vb2,\r\ndstbuf->queued_in_v4l2);\r\n}\r\ndstbuf->used = false;\r\n}\r\nmutex_unlock(&ctx->lock);\r\nreturn &dstbuf->vb.vb2_buf;\r\n}\r\nstatic void clean_display_buffer(struct mtk_vcodec_ctx *ctx)\r\n{\r\nstruct vb2_buffer *framptr;\r\ndo {\r\nframptr = get_display_buffer(ctx);\r\n} while (framptr);\r\n}\r\nstatic void clean_free_buffer(struct mtk_vcodec_ctx *ctx)\r\n{\r\nstruct vb2_buffer *framptr;\r\ndo {\r\nframptr = get_free_buffer(ctx);\r\n} while (framptr);\r\n}\r\nstatic void mtk_vdec_queue_res_chg_event(struct mtk_vcodec_ctx *ctx)\r\n{\r\nstatic const struct v4l2_event ev_src_ch = {\r\n.type = V4L2_EVENT_SOURCE_CHANGE,\r\n.u.src_change.changes =\r\nV4L2_EVENT_SRC_CH_RESOLUTION,\r\n};\r\nmtk_v4l2_debug(1, "[%d]", ctx->id);\r\nv4l2_event_queue_fh(&ctx->fh, &ev_src_ch);\r\n}\r\nstatic void mtk_vdec_flush_decoder(struct mtk_vcodec_ctx *ctx)\r\n{\r\nbool res_chg;\r\nint ret = 0;\r\nret = vdec_if_decode(ctx, NULL, NULL, &res_chg);\r\nif (ret)\r\nmtk_v4l2_err("DecodeFinal failed, ret=%d", ret);\r\nclean_display_buffer(ctx);\r\nclean_free_buffer(ctx);\r\n}\r\nstatic int mtk_vdec_pic_info_update(struct mtk_vcodec_ctx *ctx)\r\n{\r\nunsigned int dpbsize = 0;\r\nint ret;\r\nif (vdec_if_get_param(ctx,\r\nGET_PARAM_PIC_INFO,\r\n&ctx->last_decoded_picinfo)) {\r\nmtk_v4l2_err("[%d]Error!! Cannot get param : GET_PARAM_PICTURE_INFO ERR",\r\nctx->id);\r\nreturn -EINVAL;\r\n}\r\nif (ctx->last_decoded_picinfo.pic_w == 0 ||\r\nctx->last_decoded_picinfo.pic_h == 0 ||\r\nctx->last_decoded_picinfo.buf_w == 0 ||\r\nctx->last_decoded_picinfo.buf_h == 0) {\r\nmtk_v4l2_err("Cannot get correct pic info");\r\nreturn -EINVAL;\r\n}\r\nif ((ctx->last_decoded_picinfo.pic_w == ctx->picinfo.pic_w) ||\r\n(ctx->last_decoded_picinfo.pic_h == ctx->picinfo.pic_h))\r\nreturn 0;\r\nmtk_v4l2_debug(1,\r\n"[%d]-> new(%d,%d), old(%d,%d), real(%d,%d)",\r\nctx->id, ctx->last_decoded_picinfo.pic_w,\r\nctx->last_decoded_picinfo.pic_h,\r\nctx->picinfo.pic_w, ctx->picinfo.pic_h,\r\nctx->last_decoded_picinfo.buf_w,\r\nctx->last_decoded_picinfo.buf_h);\r\nret = vdec_if_get_param(ctx, GET_PARAM_DPB_SIZE, &dpbsize);\r\nif (dpbsize == 0)\r\nmtk_v4l2_err("Incorrect dpb size, ret=%d", ret);\r\nctx->dpb_size = dpbsize;\r\nreturn ret;\r\n}\r\nstatic void mtk_vdec_worker(struct work_struct *work)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = container_of(work, struct mtk_vcodec_ctx,\r\ndecode_work);\r\nstruct mtk_vcodec_dev *dev = ctx->dev;\r\nstruct vb2_buffer *src_buf, *dst_buf;\r\nstruct mtk_vcodec_mem buf;\r\nstruct vdec_fb *pfb;\r\nbool res_chg = false;\r\nint ret;\r\nstruct mtk_video_dec_buf *dst_buf_info, *src_buf_info;\r\nstruct vb2_v4l2_buffer *dst_vb2_v4l2, *src_vb2_v4l2;\r\nsrc_buf = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\r\nif (src_buf == NULL) {\r\nv4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);\r\nmtk_v4l2_debug(1, "[%d] src_buf empty!!", ctx->id);\r\nreturn;\r\n}\r\ndst_buf = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\r\nif (dst_buf == NULL) {\r\nv4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);\r\nmtk_v4l2_debug(1, "[%d] dst_buf empty!!", ctx->id);\r\nreturn;\r\n}\r\nsrc_vb2_v4l2 = container_of(src_buf, struct vb2_v4l2_buffer, vb2_buf);\r\nsrc_buf_info = container_of(src_vb2_v4l2, struct mtk_video_dec_buf, vb);\r\ndst_vb2_v4l2 = container_of(dst_buf, struct vb2_v4l2_buffer, vb2_buf);\r\ndst_buf_info = container_of(dst_vb2_v4l2, struct mtk_video_dec_buf, vb);\r\npfb = &dst_buf_info->frame_buffer;\r\npfb->base_y.va = vb2_plane_vaddr(dst_buf, 0);\r\npfb->base_y.dma_addr = vb2_dma_contig_plane_dma_addr(dst_buf, 0);\r\npfb->base_y.size = ctx->picinfo.y_bs_sz + ctx->picinfo.y_len_sz;\r\npfb->base_c.va = vb2_plane_vaddr(dst_buf, 1);\r\npfb->base_c.dma_addr = vb2_dma_contig_plane_dma_addr(dst_buf, 1);\r\npfb->base_c.size = ctx->picinfo.c_bs_sz + ctx->picinfo.c_len_sz;\r\npfb->status = 0;\r\nmtk_v4l2_debug(3, "===>[%d] vdec_if_decode() ===>", ctx->id);\r\nmtk_v4l2_debug(3,\r\n"id=%d Framebuf pfb=%p VA=%p Y_DMA=%pad C_DMA=%pad Size=%zx",\r\ndst_buf->index, pfb,\r\npfb->base_y.va, &pfb->base_y.dma_addr,\r\n&pfb->base_c.dma_addr, pfb->base_y.size);\r\nif (src_buf_info->lastframe) {\r\nmtk_v4l2_debug(1, "Got empty flush input buffer.");\r\nsrc_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\r\ndst_buf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\r\nmutex_lock(&ctx->lock);\r\ndst_buf_info->used = false;\r\nmutex_unlock(&ctx->lock);\r\nvdec_if_decode(ctx, NULL, NULL, &res_chg);\r\nclean_display_buffer(ctx);\r\nvb2_set_plane_payload(&dst_buf_info->vb.vb2_buf, 0, 0);\r\nvb2_set_plane_payload(&dst_buf_info->vb.vb2_buf, 1, 0);\r\ndst_vb2_v4l2->flags |= V4L2_BUF_FLAG_LAST;\r\nv4l2_m2m_buf_done(&dst_buf_info->vb, VB2_BUF_STATE_DONE);\r\nclean_free_buffer(ctx);\r\nv4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);\r\nreturn;\r\n}\r\nbuf.va = vb2_plane_vaddr(src_buf, 0);\r\nbuf.dma_addr = vb2_dma_contig_plane_dma_addr(src_buf, 0);\r\nbuf.size = (size_t)src_buf->planes[0].bytesused;\r\nif (!buf.va) {\r\nv4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);\r\nmtk_v4l2_err("[%d] id=%d src_addr is NULL!!",\r\nctx->id, src_buf->index);\r\nreturn;\r\n}\r\nmtk_v4l2_debug(3, "[%d] Bitstream VA=%p DMA=%pad Size=%zx vb=%p",\r\nctx->id, buf.va, &buf.dma_addr, buf.size, src_buf);\r\ndst_buf_info->vb.vb2_buf.timestamp\r\n= src_buf_info->vb.vb2_buf.timestamp;\r\ndst_buf_info->vb.timecode\r\n= src_buf_info->vb.timecode;\r\nmutex_lock(&ctx->lock);\r\ndst_buf_info->used = true;\r\nmutex_unlock(&ctx->lock);\r\nsrc_buf_info->used = true;\r\nret = vdec_if_decode(ctx, &buf, pfb, &res_chg);\r\nif (ret) {\r\nmtk_v4l2_err(\r\n" <===[%d], src_buf[%d] sz=0x%zx pts=%llu dst_buf[%d] vdec_if_decode() ret=%d res_chg=%d===>",\r\nctx->id,\r\nsrc_buf->index,\r\nbuf.size,\r\nsrc_buf_info->vb.vb2_buf.timestamp,\r\ndst_buf->index,\r\nret, res_chg);\r\nsrc_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\r\nif (ret == -EIO) {\r\nmutex_lock(&ctx->lock);\r\nsrc_buf_info->error = true;\r\nmutex_unlock(&ctx->lock);\r\n}\r\nv4l2_m2m_buf_done(&src_buf_info->vb, VB2_BUF_STATE_ERROR);\r\n} else if (res_chg == false) {\r\nsrc_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\r\nv4l2_m2m_buf_done(&src_buf_info->vb, VB2_BUF_STATE_DONE);\r\n}\r\ndst_buf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\r\nclean_display_buffer(ctx);\r\nclean_free_buffer(ctx);\r\nif (!ret && res_chg) {\r\nmtk_vdec_pic_info_update(ctx);\r\nmtk_vdec_flush_decoder(ctx);\r\nmtk_vdec_queue_res_chg_event(ctx);\r\n}\r\nv4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);\r\n}\r\nstatic int vidioc_try_decoder_cmd(struct file *file, void *priv,\r\nstruct v4l2_decoder_cmd *cmd)\r\n{\r\nswitch (cmd->cmd) {\r\ncase V4L2_DEC_CMD_STOP:\r\ncase V4L2_DEC_CMD_START:\r\nif (cmd->flags != 0) {\r\nmtk_v4l2_err("cmd->flags=%u", cmd->flags);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_decoder_cmd(struct file *file, void *priv,\r\nstruct v4l2_decoder_cmd *cmd)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nstruct vb2_queue *src_vq, *dst_vq;\r\nint ret;\r\nret = vidioc_try_decoder_cmd(file, priv, cmd);\r\nif (ret)\r\nreturn ret;\r\nmtk_v4l2_debug(1, "decoder cmd=%u", cmd->cmd);\r\ndst_vq = v4l2_m2m_get_vq(ctx->m2m_ctx,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\r\nswitch (cmd->cmd) {\r\ncase V4L2_DEC_CMD_STOP:\r\nsrc_vq = v4l2_m2m_get_vq(ctx->m2m_ctx,\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\r\nif (!vb2_is_streaming(src_vq)) {\r\nmtk_v4l2_debug(1, "Output stream is off. No need to flush.");\r\nreturn 0;\r\n}\r\nif (!vb2_is_streaming(dst_vq)) {\r\nmtk_v4l2_debug(1, "Capture stream is off. No need to flush.");\r\nreturn 0;\r\n}\r\nv4l2_m2m_buf_queue(ctx->m2m_ctx, &ctx->empty_flush_buf->vb);\r\nv4l2_m2m_try_schedule(ctx->m2m_ctx);\r\nbreak;\r\ncase V4L2_DEC_CMD_START:\r\nvb2_clear_last_buffer_dequeued(dst_vq);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid mtk_vdec_unlock(struct mtk_vcodec_ctx *ctx)\r\n{\r\nmutex_unlock(&ctx->dev->dec_mutex);\r\n}\r\nvoid mtk_vdec_lock(struct mtk_vcodec_ctx *ctx)\r\n{\r\nmutex_lock(&ctx->dev->dec_mutex);\r\n}\r\nvoid mtk_vcodec_dec_release(struct mtk_vcodec_ctx *ctx)\r\n{\r\nvdec_if_deinit(ctx);\r\nctx->state = MTK_STATE_FREE;\r\n}\r\nvoid mtk_vcodec_dec_set_default_params(struct mtk_vcodec_ctx *ctx)\r\n{\r\nstruct mtk_q_data *q_data;\r\nctx->m2m_ctx->q_lock = &ctx->dev->dev_mutex;\r\nctx->fh.m2m_ctx = ctx->m2m_ctx;\r\nctx->fh.ctrl_handler = &ctx->ctrl_hdl;\r\nINIT_WORK(&ctx->decode_work, mtk_vdec_worker);\r\nctx->colorspace = V4L2_COLORSPACE_REC709;\r\nctx->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\r\nctx->quantization = V4L2_QUANTIZATION_DEFAULT;\r\nctx->xfer_func = V4L2_XFER_FUNC_DEFAULT;\r\nq_data = &ctx->q_data[MTK_Q_DATA_SRC];\r\nmemset(q_data, 0, sizeof(struct mtk_q_data));\r\nq_data->visible_width = DFT_CFG_WIDTH;\r\nq_data->visible_height = DFT_CFG_HEIGHT;\r\nq_data->fmt = &mtk_video_formats[OUT_FMT_IDX];\r\nq_data->field = V4L2_FIELD_NONE;\r\nq_data->sizeimage[0] = DFT_CFG_WIDTH * DFT_CFG_HEIGHT;\r\nq_data->bytesperline[0] = 0;\r\nq_data = &ctx->q_data[MTK_Q_DATA_DST];\r\nmemset(q_data, 0, sizeof(struct mtk_q_data));\r\nq_data->visible_width = DFT_CFG_WIDTH;\r\nq_data->visible_height = DFT_CFG_HEIGHT;\r\nq_data->coded_width = DFT_CFG_WIDTH;\r\nq_data->coded_height = DFT_CFG_HEIGHT;\r\nq_data->fmt = &mtk_video_formats[CAP_FMT_IDX];\r\nq_data->field = V4L2_FIELD_NONE;\r\nv4l_bound_align_image(&q_data->coded_width,\r\nMTK_VDEC_MIN_W,\r\nMTK_VDEC_MAX_W, 4,\r\n&q_data->coded_height,\r\nMTK_VDEC_MIN_H,\r\nMTK_VDEC_MAX_H, 5, 6);\r\nq_data->sizeimage[0] = q_data->coded_width * q_data->coded_height;\r\nq_data->bytesperline[0] = q_data->coded_width;\r\nq_data->sizeimage[1] = q_data->sizeimage[0] / 2;\r\nq_data->bytesperline[1] = q_data->coded_width;\r\n}\r\nstatic int vidioc_vdec_qbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nif (ctx->state == MTK_STATE_ABORT) {\r\nmtk_v4l2_err("[%d] Call on QBUF after unrecoverable error",\r\nctx->id);\r\nreturn -EIO;\r\n}\r\nreturn v4l2_m2m_qbuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int vidioc_vdec_dqbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nif (ctx->state == MTK_STATE_ABORT) {\r\nmtk_v4l2_err("[%d] Call on DQBUF after unrecoverable error",\r\nctx->id);\r\nreturn -EIO;\r\n}\r\nreturn v4l2_m2m_dqbuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int vidioc_vdec_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrlcpy(cap->driver, MTK_VCODEC_DEC_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->bus_info, MTK_PLATFORM_STR, sizeof(cap->bus_info));\r\nstrlcpy(cap->card, MTK_PLATFORM_STR, sizeof(cap->card));\r\nreturn 0;\r\n}\r\nstatic int vidioc_vdec_subscribe_evt(struct v4l2_fh *fh,\r\nconst struct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_EOS:\r\nreturn v4l2_event_subscribe(fh, sub, 2, NULL);\r\ncase V4L2_EVENT_SOURCE_CHANGE:\r\nreturn v4l2_src_change_event_subscribe(fh, sub);\r\ndefault:\r\nreturn v4l2_ctrl_subscribe_event(fh, sub);\r\n}\r\n}\r\nstatic int vidioc_try_fmt(struct v4l2_format *f, struct mtk_video_fmt *fmt)\r\n{\r\nstruct v4l2_pix_format_mplane *pix_fmt_mp = &f->fmt.pix_mp;\r\nint i;\r\npix_fmt_mp->field = V4L2_FIELD_NONE;\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\npix_fmt_mp->num_planes = 1;\r\npix_fmt_mp->plane_fmt[0].bytesperline = 0;\r\n} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nint tmp_w, tmp_h;\r\npix_fmt_mp->height = clamp(pix_fmt_mp->height,\r\nMTK_VDEC_MIN_H,\r\nMTK_VDEC_MAX_H);\r\npix_fmt_mp->width = clamp(pix_fmt_mp->width,\r\nMTK_VDEC_MIN_W,\r\nMTK_VDEC_MAX_W);\r\ntmp_w = pix_fmt_mp->width;\r\ntmp_h = pix_fmt_mp->height;\r\nv4l_bound_align_image(&pix_fmt_mp->width,\r\nMTK_VDEC_MIN_W,\r\nMTK_VDEC_MAX_W, 6,\r\n&pix_fmt_mp->height,\r\nMTK_VDEC_MIN_H,\r\nMTK_VDEC_MAX_H, 6, 9);\r\nif (pix_fmt_mp->width < tmp_w &&\r\n(pix_fmt_mp->width + 64) <= MTK_VDEC_MAX_W)\r\npix_fmt_mp->width += 64;\r\nif (pix_fmt_mp->height < tmp_h &&\r\n(pix_fmt_mp->height + 64) <= MTK_VDEC_MAX_H)\r\npix_fmt_mp->height += 64;\r\nmtk_v4l2_debug(0,\r\n"before resize width=%d, height=%d, after resize width=%d, height=%d, sizeimage=%d",\r\ntmp_w, tmp_h, pix_fmt_mp->width,\r\npix_fmt_mp->height,\r\npix_fmt_mp->width * pix_fmt_mp->height);\r\npix_fmt_mp->num_planes = fmt->num_planes;\r\npix_fmt_mp->plane_fmt[0].sizeimage =\r\npix_fmt_mp->width * pix_fmt_mp->height;\r\npix_fmt_mp->plane_fmt[0].bytesperline = pix_fmt_mp->width;\r\nif (pix_fmt_mp->num_planes == 2) {\r\npix_fmt_mp->plane_fmt[1].sizeimage =\r\n(pix_fmt_mp->width * pix_fmt_mp->height) / 2;\r\npix_fmt_mp->plane_fmt[1].bytesperline =\r\npix_fmt_mp->width;\r\n}\r\n}\r\nfor (i = 0; i < pix_fmt_mp->num_planes; i++)\r\nmemset(&(pix_fmt_mp->plane_fmt[i].reserved[0]), 0x0,\r\nsizeof(pix_fmt_mp->plane_fmt[0].reserved));\r\npix_fmt_mp->flags = 0;\r\nmemset(&pix_fmt_mp->reserved, 0x0, sizeof(pix_fmt_mp->reserved));\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap_mplane(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct mtk_video_fmt *fmt;\r\nfmt = mtk_vdec_find_format(f);\r\nif (!fmt) {\r\nf->fmt.pix.pixelformat = mtk_video_formats[CAP_FMT_IDX].fourcc;\r\nfmt = mtk_vdec_find_format(f);\r\n}\r\nreturn vidioc_try_fmt(f, fmt);\r\n}\r\nstatic int vidioc_try_fmt_vid_out_mplane(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_pix_format_mplane *pix_fmt_mp = &f->fmt.pix_mp;\r\nstruct mtk_video_fmt *fmt;\r\nfmt = mtk_vdec_find_format(f);\r\nif (!fmt) {\r\nf->fmt.pix.pixelformat = mtk_video_formats[OUT_FMT_IDX].fourcc;\r\nfmt = mtk_vdec_find_format(f);\r\n}\r\nif (pix_fmt_mp->plane_fmt[0].sizeimage == 0) {\r\nmtk_v4l2_err("sizeimage of output format must be given");\r\nreturn -EINVAL;\r\n}\r\nreturn vidioc_try_fmt(f, fmt);\r\n}\r\nstatic int vidioc_vdec_g_selection(struct file *file, void *priv,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nstruct mtk_q_data *q_data;\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nq_data = &ctx->q_data[MTK_Q_DATA_DST];\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ns->r.left = 0;\r\ns->r.top = 0;\r\ns->r.width = ctx->picinfo.pic_w;\r\ns->r.height = ctx->picinfo.pic_h;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\ns->r.left = 0;\r\ns->r.top = 0;\r\ns->r.width = ctx->picinfo.buf_w;\r\ns->r.height = ctx->picinfo.buf_h;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nif (vdec_if_get_param(ctx, GET_PARAM_CROP_INFO, &(s->r))) {\r\ns->r.left = 0;\r\ns->r.top = 0;\r\ns->r.width = q_data->visible_width;\r\ns->r.height = q_data->visible_height;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (ctx->state < MTK_STATE_HEADER) {\r\ns->r.left = 0;\r\ns->r.top = 0;\r\ns->r.width = q_data->visible_width;\r\ns->r.height = q_data->visible_height;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_vdec_s_selection(struct file *file, void *priv,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ns->r.left = 0;\r\ns->r.top = 0;\r\ns->r.width = ctx->picinfo.pic_w;\r\ns->r.height = ctx->picinfo.pic_h;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_vdec_s_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nstruct v4l2_pix_format_mplane *pix_mp;\r\nstruct mtk_q_data *q_data;\r\nint ret = 0;\r\nstruct mtk_video_fmt *fmt;\r\nmtk_v4l2_debug(3, "[%d]", ctx->id);\r\nq_data = mtk_vdec_get_q_data(ctx, f->type);\r\nif (!q_data)\r\nreturn -EINVAL;\r\npix_mp = &f->fmt.pix_mp;\r\nif ((f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) &&\r\nvb2_is_busy(&ctx->m2m_ctx->out_q_ctx.q)) {\r\nmtk_v4l2_err("out_q_ctx buffers already requested");\r\nret = -EBUSY;\r\n}\r\nif ((f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) &&\r\nvb2_is_busy(&ctx->m2m_ctx->cap_q_ctx.q)) {\r\nmtk_v4l2_err("cap_q_ctx buffers already requested");\r\nret = -EBUSY;\r\n}\r\nfmt = mtk_vdec_find_format(f);\r\nif (fmt == NULL) {\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nf->fmt.pix.pixelformat =\r\nmtk_video_formats[OUT_FMT_IDX].fourcc;\r\nfmt = mtk_vdec_find_format(f);\r\n} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nf->fmt.pix.pixelformat =\r\nmtk_video_formats[CAP_FMT_IDX].fourcc;\r\nfmt = mtk_vdec_find_format(f);\r\n}\r\n}\r\nq_data->fmt = fmt;\r\nvidioc_try_fmt(f, q_data->fmt);\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nq_data->sizeimage[0] = pix_mp->plane_fmt[0].sizeimage;\r\nq_data->coded_width = pix_mp->width;\r\nq_data->coded_height = pix_mp->height;\r\nctx->colorspace = f->fmt.pix_mp.colorspace;\r\nctx->ycbcr_enc = f->fmt.pix_mp.ycbcr_enc;\r\nctx->quantization = f->fmt.pix_mp.quantization;\r\nctx->xfer_func = f->fmt.pix_mp.xfer_func;\r\nif (ctx->state == MTK_STATE_FREE) {\r\nret = vdec_if_init(ctx, q_data->fmt->fourcc);\r\nif (ret) {\r\nmtk_v4l2_err("[%d]: vdec_if_init() fail ret=%d",\r\nctx->id, ret);\r\nreturn -EINVAL;\r\n}\r\nctx->state = MTK_STATE_INIT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_framesizes(struct file *file, void *priv,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nint i = 0;\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nif (fsize->index != 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < NUM_SUPPORTED_FRAMESIZE; ++i) {\r\nif (fsize->pixel_format != mtk_vdec_framesizes[i].fourcc)\r\ncontinue;\r\nfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\r\nfsize->stepwise = mtk_vdec_framesizes[i].stepwise;\r\nif (!(ctx->dev->dec_capability &\r\nVCODEC_CAPABILITY_4K_DISABLED)) {\r\nmtk_v4l2_debug(3, "4K is enabled");\r\nfsize->stepwise.max_width =\r\nVCODEC_DEC_4K_CODED_WIDTH;\r\nfsize->stepwise.max_height =\r\nVCODEC_DEC_4K_CODED_HEIGHT;\r\n}\r\nmtk_v4l2_debug(1, "%x, %d %d %d %d %d %d",\r\nctx->dev->dec_capability,\r\nfsize->stepwise.min_width,\r\nfsize->stepwise.max_width,\r\nfsize->stepwise.step_width,\r\nfsize->stepwise.min_height,\r\nfsize->stepwise.max_height,\r\nfsize->stepwise.step_height);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_enum_fmt(struct v4l2_fmtdesc *f, bool output_queue)\r\n{\r\nstruct mtk_video_fmt *fmt;\r\nint i, j = 0;\r\nfor (i = 0; i < NUM_FORMATS; i++) {\r\nif (output_queue && (mtk_video_formats[i].type != MTK_FMT_DEC))\r\ncontinue;\r\nif (!output_queue &&\r\n(mtk_video_formats[i].type != MTK_FMT_FRAME))\r\ncontinue;\r\nif (j == f->index)\r\nbreak;\r\n++j;\r\n}\r\nif (i == NUM_FORMATS)\r\nreturn -EINVAL;\r\nfmt = &mtk_video_formats[i];\r\nf->pixelformat = fmt->fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_vdec_enum_fmt_vid_cap_mplane(struct file *file, void *pirv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn vidioc_enum_fmt(f, false);\r\n}\r\nstatic int vidioc_vdec_enum_fmt_vid_out_mplane(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn vidioc_enum_fmt(f, true);\r\n}\r\nstatic int vidioc_vdec_g_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\r\nstruct vb2_queue *vq;\r\nstruct mtk_q_data *q_data;\r\nvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\r\nif (!vq) {\r\nmtk_v4l2_err("no vb2 queue for type=%d", f->type);\r\nreturn -EINVAL;\r\n}\r\nq_data = mtk_vdec_get_q_data(ctx, f->type);\r\npix_mp->field = V4L2_FIELD_NONE;\r\npix_mp->colorspace = ctx->colorspace;\r\npix_mp->ycbcr_enc = ctx->ycbcr_enc;\r\npix_mp->quantization = ctx->quantization;\r\npix_mp->xfer_func = ctx->xfer_func;\r\nif ((f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) &&\r\n(ctx->state >= MTK_STATE_HEADER)) {\r\nq_data->sizeimage[0] = ctx->picinfo.y_bs_sz +\r\nctx->picinfo.y_len_sz;\r\nq_data->sizeimage[1] = ctx->picinfo.c_bs_sz +\r\nctx->picinfo.c_len_sz;\r\nq_data->bytesperline[0] = ctx->last_decoded_picinfo.buf_w;\r\nq_data->bytesperline[1] = ctx->last_decoded_picinfo.buf_w;\r\nq_data->coded_width = ctx->picinfo.buf_w;\r\nq_data->coded_height = ctx->picinfo.buf_h;\r\npix_mp->width = q_data->coded_width;\r\npix_mp->height = q_data->coded_height;\r\npix_mp->num_planes = q_data->fmt->num_planes;\r\npix_mp->pixelformat = q_data->fmt->fourcc;\r\npix_mp->plane_fmt[0].bytesperline = q_data->bytesperline[0];\r\npix_mp->plane_fmt[0].sizeimage = q_data->sizeimage[0];\r\npix_mp->plane_fmt[1].bytesperline = q_data->bytesperline[1];\r\npix_mp->plane_fmt[1].sizeimage = q_data->sizeimage[1];\r\n} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\npix_mp->width = q_data->visible_width;\r\npix_mp->height = q_data->visible_height;\r\npix_mp->plane_fmt[0].bytesperline = q_data->bytesperline[0];\r\npix_mp->plane_fmt[0].sizeimage = q_data->sizeimage[0];\r\npix_mp->pixelformat = q_data->fmt->fourcc;\r\npix_mp->num_planes = q_data->fmt->num_planes;\r\n} else {\r\npix_mp->width = q_data->coded_width;\r\npix_mp->height = q_data->coded_height;\r\npix_mp->num_planes = q_data->fmt->num_planes;\r\npix_mp->pixelformat = q_data->fmt->fourcc;\r\npix_mp->plane_fmt[0].bytesperline = q_data->bytesperline[0];\r\npix_mp->plane_fmt[0].sizeimage = q_data->sizeimage[0];\r\npix_mp->plane_fmt[1].bytesperline = q_data->bytesperline[1];\r\npix_mp->plane_fmt[1].sizeimage = q_data->sizeimage[1];\r\nmtk_v4l2_debug(1, "[%d] type=%d state=%d Format information could not be read, not ready yet!",\r\nctx->id, f->type, ctx->state);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vb2ops_vdec_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers,\r\nunsigned int *nplanes,\r\nunsigned int sizes[],\r\nstruct device *alloc_devs[])\r\n{\r\nstruct mtk_vcodec_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct mtk_q_data *q_data;\r\nunsigned int i;\r\nq_data = mtk_vdec_get_q_data(ctx, vq->type);\r\nif (q_data == NULL) {\r\nmtk_v4l2_err("vq->type=%d err\n", vq->type);\r\nreturn -EINVAL;\r\n}\r\nif (*nplanes) {\r\nfor (i = 0; i < *nplanes; i++) {\r\nif (sizes[i] < q_data->sizeimage[i])\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\n*nplanes = 2;\r\nelse\r\n*nplanes = 1;\r\nfor (i = 0; i < *nplanes; i++)\r\nsizes[i] = q_data->sizeimage[i];\r\n}\r\nmtk_v4l2_debug(1,\r\n"[%d]\t type = %d, get %d plane(s), %d buffer(s) of size 0x%x 0x%x ",\r\nctx->id, vq->type, *nplanes, *nbuffers,\r\nsizes[0], sizes[1]);\r\nreturn 0;\r\n}\r\nstatic int vb2ops_vdec_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct mtk_q_data *q_data;\r\nint i;\r\nmtk_v4l2_debug(3, "[%d] (%d) id=%d",\r\nctx->id, vb->vb2_queue->type, vb->index);\r\nq_data = mtk_vdec_get_q_data(ctx, vb->vb2_queue->type);\r\nfor (i = 0; i < q_data->fmt->num_planes; i++) {\r\nif (vb2_plane_size(vb, i) < q_data->sizeimage[i]) {\r\nmtk_v4l2_err("data will not fit into plane %d (%lu < %d)",\r\ni, vb2_plane_size(vb, i),\r\nq_data->sizeimage[i]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void vb2ops_vdec_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_buffer *src_buf;\r\nstruct mtk_vcodec_mem src_mem;\r\nbool res_chg = false;\r\nint ret = 0;\r\nunsigned int dpbsize = 1;\r\nstruct mtk_vcodec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vb2_v4l2_buffer *vb2_v4l2 = NULL;\r\nstruct mtk_video_dec_buf *buf = NULL;\r\nmtk_v4l2_debug(3, "[%d] (%d) id=%d, vb=%p",\r\nctx->id, vb->vb2_queue->type,\r\nvb->index, vb);\r\nif (vb->vb2_queue->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nvb2_v4l2 = to_vb2_v4l2_buffer(vb);\r\nbuf = container_of(vb2_v4l2, struct mtk_video_dec_buf, vb);\r\nmutex_lock(&ctx->lock);\r\nif (buf->used == false) {\r\nv4l2_m2m_buf_queue(ctx->m2m_ctx, vb2_v4l2);\r\nbuf->queued_in_vb2 = true;\r\nbuf->queued_in_v4l2 = true;\r\nbuf->ready_to_display = false;\r\n} else {\r\nbuf->queued_in_vb2 = false;\r\nbuf->queued_in_v4l2 = true;\r\nbuf->ready_to_display = false;\r\n}\r\nmutex_unlock(&ctx->lock);\r\nreturn;\r\n}\r\nv4l2_m2m_buf_queue(ctx->m2m_ctx, to_vb2_v4l2_buffer(vb));\r\nif (ctx->state != MTK_STATE_INIT) {\r\nmtk_v4l2_debug(3, "[%d] already init driver %d",\r\nctx->id, ctx->state);\r\nreturn;\r\n}\r\nsrc_buf = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\r\nif (!src_buf) {\r\nmtk_v4l2_err("No src buffer");\r\nreturn;\r\n}\r\nvb2_v4l2 = to_vb2_v4l2_buffer(src_buf);\r\nbuf = container_of(vb2_v4l2, struct mtk_video_dec_buf, vb);\r\nif (buf->lastframe) {\r\nmtk_v4l2_err("Invalid flush buffer.");\r\nv4l2_m2m_src_buf_remove(ctx->m2m_ctx);\r\nreturn;\r\n}\r\nsrc_mem.va = vb2_plane_vaddr(src_buf, 0);\r\nsrc_mem.dma_addr = vb2_dma_contig_plane_dma_addr(src_buf, 0);\r\nsrc_mem.size = (size_t)src_buf->planes[0].bytesused;\r\nmtk_v4l2_debug(2,\r\n"[%d] buf id=%d va=%p dma=%pad size=%zx",\r\nctx->id, src_buf->index,\r\nsrc_mem.va, &src_mem.dma_addr,\r\nsrc_mem.size);\r\nret = vdec_if_decode(ctx, &src_mem, NULL, &res_chg);\r\nif (ret || !res_chg) {\r\nsrc_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\r\nif (ret == -EIO) {\r\nmtk_v4l2_err("[%d] Unrecoverable error in vdec_if_decode.",\r\nctx->id);\r\nctx->state = MTK_STATE_ABORT;\r\nv4l2_m2m_buf_done(to_vb2_v4l2_buffer(src_buf),\r\nVB2_BUF_STATE_ERROR);\r\n} else {\r\nv4l2_m2m_buf_done(to_vb2_v4l2_buffer(src_buf),\r\nVB2_BUF_STATE_DONE);\r\n}\r\nmtk_v4l2_debug(ret ? 0 : 1,\r\n"[%d] vdec_if_decode() src_buf=%d, size=%zu, fail=%d, res_chg=%d",\r\nctx->id, src_buf->index,\r\nsrc_mem.size, ret, res_chg);\r\nreturn;\r\n}\r\nif (vdec_if_get_param(ctx, GET_PARAM_PIC_INFO, &ctx->picinfo)) {\r\nmtk_v4l2_err("[%d]Error!! Cannot get param : GET_PARAM_PICTURE_INFO ERR",\r\nctx->id);\r\nreturn;\r\n}\r\nctx->last_decoded_picinfo = ctx->picinfo;\r\nctx->q_data[MTK_Q_DATA_DST].sizeimage[0] =\r\nctx->picinfo.y_bs_sz +\r\nctx->picinfo.y_len_sz;\r\nctx->q_data[MTK_Q_DATA_DST].bytesperline[0] =\r\nctx->picinfo.buf_w;\r\nctx->q_data[MTK_Q_DATA_DST].sizeimage[1] =\r\nctx->picinfo.c_bs_sz +\r\nctx->picinfo.c_len_sz;\r\nctx->q_data[MTK_Q_DATA_DST].bytesperline[1] = ctx->picinfo.buf_w;\r\nmtk_v4l2_debug(2, "[%d] vdec_if_init() OK wxh=%dx%d pic wxh=%dx%d sz[0]=0x%x sz[1]=0x%x",\r\nctx->id,\r\nctx->picinfo.buf_w, ctx->picinfo.buf_h,\r\nctx->picinfo.pic_w, ctx->picinfo.pic_h,\r\nctx->q_data[MTK_Q_DATA_DST].sizeimage[0],\r\nctx->q_data[MTK_Q_DATA_DST].sizeimage[1]);\r\nret = vdec_if_get_param(ctx, GET_PARAM_DPB_SIZE, &dpbsize);\r\nif (dpbsize == 0)\r\nmtk_v4l2_err("[%d] GET_PARAM_DPB_SIZE fail=%d", ctx->id, ret);\r\nctx->dpb_size = dpbsize;\r\nctx->state = MTK_STATE_HEADER;\r\nmtk_v4l2_debug(1, "[%d] dpbsize=%d", ctx->id, ctx->dpb_size);\r\n}\r\nstatic void vb2ops_vdec_buf_finish(struct vb2_buffer *vb)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vb2_v4l2_buffer *vb2_v4l2;\r\nstruct mtk_video_dec_buf *buf;\r\nbool buf_error;\r\nvb2_v4l2 = container_of(vb, struct vb2_v4l2_buffer, vb2_buf);\r\nbuf = container_of(vb2_v4l2, struct mtk_video_dec_buf, vb);\r\nmutex_lock(&ctx->lock);\r\nif (vb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nbuf->queued_in_v4l2 = false;\r\nbuf->queued_in_vb2 = false;\r\n}\r\nbuf_error = buf->error;\r\nmutex_unlock(&ctx->lock);\r\nif (buf_error) {\r\nmtk_v4l2_err("Unrecoverable error on buffer.");\r\nctx->state = MTK_STATE_ABORT;\r\n}\r\n}\r\nstatic int vb2ops_vdec_buf_init(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vb2_v4l2 = container_of(vb,\r\nstruct vb2_v4l2_buffer, vb2_buf);\r\nstruct mtk_video_dec_buf *buf = container_of(vb2_v4l2,\r\nstruct mtk_video_dec_buf, vb);\r\nif (vb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nbuf->used = false;\r\nbuf->ready_to_display = false;\r\nbuf->queued_in_v4l2 = false;\r\n} else {\r\nbuf->lastframe = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vb2ops_vdec_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = vb2_get_drv_priv(q);\r\nif (ctx->state == MTK_STATE_FLUSH)\r\nctx->state = MTK_STATE_HEADER;\r\nreturn 0;\r\n}\r\nstatic void vb2ops_vdec_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct vb2_buffer *src_buf = NULL, *dst_buf = NULL;\r\nstruct mtk_vcodec_ctx *ctx = vb2_get_drv_priv(q);\r\nmtk_v4l2_debug(3, "[%d] (%d) state=(%x) ctx->decoded_frame_cnt=%d",\r\nctx->id, q->type, ctx->state, ctx->decoded_frame_cnt);\r\nif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nwhile ((src_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx))) {\r\nstruct vb2_v4l2_buffer *vb2_v4l2 =\r\nto_vb2_v4l2_buffer(src_buf);\r\nstruct mtk_video_dec_buf *buf_info = container_of(\r\nvb2_v4l2, struct mtk_video_dec_buf, vb);\r\nif (!buf_info->lastframe)\r\nv4l2_m2m_buf_done(vb2_v4l2,\r\nVB2_BUF_STATE_ERROR);\r\n}\r\nreturn;\r\n}\r\nif (ctx->state >= MTK_STATE_HEADER) {\r\nctx->picinfo = ctx->last_decoded_picinfo;\r\nmtk_v4l2_debug(2,\r\n"[%d]-> new(%d,%d), old(%d,%d), real(%d,%d)",\r\nctx->id, ctx->last_decoded_picinfo.pic_w,\r\nctx->last_decoded_picinfo.pic_h,\r\nctx->picinfo.pic_w, ctx->picinfo.pic_h,\r\nctx->last_decoded_picinfo.buf_w,\r\nctx->last_decoded_picinfo.buf_h);\r\nmtk_vdec_flush_decoder(ctx);\r\n}\r\nctx->state = MTK_STATE_FLUSH;\r\nwhile ((dst_buf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx))) {\r\nvb2_set_plane_payload(dst_buf, 0, 0);\r\nvb2_set_plane_payload(dst_buf, 1, 0);\r\nv4l2_m2m_buf_done(to_vb2_v4l2_buffer(dst_buf),\r\nVB2_BUF_STATE_ERROR);\r\n}\r\n}\r\nstatic void m2mops_vdec_device_run(void *priv)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = priv;\r\nstruct mtk_vcodec_dev *dev = ctx->dev;\r\nqueue_work(dev->decode_workqueue, &ctx->decode_work);\r\n}\r\nstatic int m2mops_vdec_job_ready(void *m2m_priv)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = m2m_priv;\r\nmtk_v4l2_debug(3, "[%d]", ctx->id);\r\nif (ctx->state == MTK_STATE_ABORT)\r\nreturn 0;\r\nif ((ctx->last_decoded_picinfo.pic_w != ctx->picinfo.pic_w) ||\r\n(ctx->last_decoded_picinfo.pic_h != ctx->picinfo.pic_h))\r\nreturn 0;\r\nif (ctx->state != MTK_STATE_HEADER)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void m2mops_vdec_job_abort(void *priv)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = priv;\r\nctx->state = MTK_STATE_ABORT;\r\n}\r\nstatic int mtk_vdec_g_v_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = ctrl_to_ctx(ctrl);\r\nint ret = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:\r\nif (ctx->state >= MTK_STATE_HEADER) {\r\nctrl->val = ctx->dpb_size;\r\n} else {\r\nmtk_v4l2_debug(0, "Seqinfo not ready");\r\nctrl->val = 0;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nint mtk_vcodec_dec_ctrls_setup(struct mtk_vcodec_ctx *ctx)\r\n{\r\nstruct v4l2_ctrl *ctrl;\r\nv4l2_ctrl_handler_init(&ctx->ctrl_hdl, 1);\r\nctrl = v4l2_ctrl_new_std(&ctx->ctrl_hdl,\r\n&mtk_vcodec_dec_ctrl_ops,\r\nV4L2_CID_MIN_BUFFERS_FOR_CAPTURE,\r\n0, 32, 1, 1);\r\nctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\nif (ctx->ctrl_hdl.error) {\r\nmtk_v4l2_err("Adding control failed %d",\r\nctx->ctrl_hdl.error);\r\nreturn ctx->ctrl_hdl.error;\r\n}\r\nv4l2_ctrl_handler_setup(&ctx->ctrl_hdl);\r\nreturn 0;\r\n}\r\nstatic void m2mops_vdec_lock(void *m2m_priv)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = m2m_priv;\r\nmtk_v4l2_debug(3, "[%d]", ctx->id);\r\nmutex_lock(&ctx->dev->dev_mutex);\r\n}\r\nstatic void m2mops_vdec_unlock(void *m2m_priv)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = m2m_priv;\r\nmtk_v4l2_debug(3, "[%d]", ctx->id);\r\nmutex_unlock(&ctx->dev->dev_mutex);\r\n}\r\nint mtk_vcodec_dec_queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = priv;\r\nint ret = 0;\r\nmtk_v4l2_debug(3, "[%d]", ctx->id);\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\r\nsrc_vq->io_modes = VB2_DMABUF | VB2_MMAP;\r\nsrc_vq->drv_priv = ctx;\r\nsrc_vq->buf_struct_size = sizeof(struct mtk_video_dec_buf);\r\nsrc_vq->ops = &mtk_vdec_vb2_ops;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nsrc_vq->lock = &ctx->dev->dev_mutex;\r\nsrc_vq->dev = &ctx->dev->plat_dev->dev;\r\nret = vb2_queue_init(src_vq);\r\nif (ret) {\r\nmtk_v4l2_err("Failed to initialize videobuf2 queue(output)");\r\nreturn ret;\r\n}\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\r\ndst_vq->io_modes = VB2_DMABUF | VB2_MMAP;\r\ndst_vq->drv_priv = ctx;\r\ndst_vq->buf_struct_size = sizeof(struct mtk_video_dec_buf);\r\ndst_vq->ops = &mtk_vdec_vb2_ops;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\ndst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\ndst_vq->lock = &ctx->dev->dev_mutex;\r\ndst_vq->dev = &ctx->dev->plat_dev->dev;\r\nret = vb2_queue_init(dst_vq);\r\nif (ret) {\r\nvb2_queue_release(src_vq);\r\nmtk_v4l2_err("Failed to initialize videobuf2 queue(capture)");\r\n}\r\nreturn ret;\r\n}
