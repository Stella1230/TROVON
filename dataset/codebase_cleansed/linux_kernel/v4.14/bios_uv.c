s64 uv_bios_call(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3, u64 a4, u64 a5)\r\n{\r\nstruct uv_systab *tab = uv_systab;\r\ns64 ret;\r\nif (!tab || !tab->function)\r\nreturn BIOS_STATUS_UNIMPLEMENTED;\r\nif (unlikely(test_bit(EFI_OLD_MEMMAP, &efi.flags)))\r\nret = efi_call((void *)__va(tab->function), (u64)which, a1, a2, a3, a4, a5);\r\nelse\r\nret = efi_call_virt_pointer(tab, function, (u64)which, a1, a2, a3, a4, a5);\r\nreturn ret;\r\n}\r\ns64 uv_bios_call_irqsave(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3,\r\nu64 a4, u64 a5)\r\n{\r\nunsigned long bios_flags;\r\ns64 ret;\r\nlocal_irq_save(bios_flags);\r\nret = uv_bios_call(which, a1, a2, a3, a4, a5);\r\nlocal_irq_restore(bios_flags);\r\nreturn ret;\r\n}\r\ns64 uv_bios_call_reentrant(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3,\r\nu64 a4, u64 a5)\r\n{\r\ns64 ret;\r\npreempt_disable();\r\nret = uv_bios_call(which, a1, a2, a3, a4, a5);\r\npreempt_enable();\r\nreturn ret;\r\n}\r\ns64 uv_bios_get_sn_info(int fc, int *uvtype, long *partid, long *coher,\r\nlong *region, long *ssn)\r\n{\r\ns64 ret;\r\nu64 v0, v1;\r\nunion partition_info_u part;\r\nret = uv_bios_call_irqsave(UV_BIOS_GET_SN_INFO, fc,\r\n(u64)(&v0), (u64)(&v1), 0, 0);\r\nif (ret != BIOS_STATUS_SUCCESS)\r\nreturn ret;\r\npart.val = v0;\r\nif (uvtype)\r\n*uvtype = part.hub_version;\r\nif (partid)\r\n*partid = part.partition_id;\r\nif (coher)\r\n*coher = part.coherence_id;\r\nif (region)\r\n*region = part.region_size;\r\nif (ssn)\r\n*ssn = v1;\r\nreturn ret;\r\n}\r\nint\r\nuv_bios_mq_watchlist_alloc(unsigned long addr, unsigned int mq_size,\r\nunsigned long *intr_mmr_offset)\r\n{\r\nu64 watchlist;\r\ns64 ret;\r\nret = (int)uv_bios_call_irqsave(UV_BIOS_WATCHLIST_ALLOC, addr,\r\nmq_size, (u64)intr_mmr_offset,\r\n(u64)&watchlist, 0);\r\nif (ret < BIOS_STATUS_SUCCESS)\r\nreturn ret;\r\nreturn watchlist;\r\n}\r\nint\r\nuv_bios_mq_watchlist_free(int blade, int watchlist_num)\r\n{\r\nreturn (int)uv_bios_call_irqsave(UV_BIOS_WATCHLIST_FREE,\r\nblade, watchlist_num, 0, 0, 0);\r\n}\r\ns64\r\nuv_bios_change_memprotect(u64 paddr, u64 len, enum uv_memprotect perms)\r\n{\r\nreturn uv_bios_call_irqsave(UV_BIOS_MEMPROTECT, paddr, len,\r\nperms, 0, 0);\r\n}\r\ns64\r\nuv_bios_reserved_page_pa(u64 buf, u64 *cookie, u64 *addr, u64 *len)\r\n{\r\nreturn uv_bios_call_irqsave(UV_BIOS_GET_PARTITION_ADDR, (u64)cookie,\r\n(u64)addr, buf, (u64)len, 0);\r\n}\r\ns64 uv_bios_freq_base(u64 clock_type, u64 *ticks_per_second)\r\n{\r\nreturn uv_bios_call(UV_BIOS_FREQ_BASE, clock_type,\r\n(u64)ticks_per_second, 0, 0, 0);\r\n}\r\nint uv_bios_set_legacy_vga_target(bool decode, int domain, int bus)\r\n{\r\nreturn uv_bios_call(UV_BIOS_SET_LEGACY_VGA_TARGET,\r\n(u64)decode, (u64)domain, (u64)bus, 0, 0);\r\n}\r\nvoid uv_bios_init(void)\r\n{\r\nuv_systab = NULL;\r\nif ((efi.uv_systab == EFI_INVALID_TABLE_ADDR) ||\r\n!efi.uv_systab || efi_runtime_disabled()) {\r\npr_crit("UV: UVsystab: missing\n");\r\nreturn;\r\n}\r\nuv_systab = ioremap(efi.uv_systab, sizeof(struct uv_systab));\r\nif (!uv_systab || strncmp(uv_systab->signature, UV_SYSTAB_SIG, 4)) {\r\npr_err("UV: UVsystab: bad signature!\n");\r\niounmap(uv_systab);\r\nreturn;\r\n}\r\nif (uv_systab->revision >= UV_SYSTAB_VERSION_UV4) {\r\nint size = uv_systab->size;\r\niounmap(uv_systab);\r\nuv_systab = ioremap(efi.uv_systab, size);\r\nif (!uv_systab) {\r\npr_err("UV: UVsystab: ioremap(%d) failed!\n", size);\r\nreturn;\r\n}\r\n}\r\npr_info("UV: UVsystab: Revision:%x\n", uv_systab->revision);\r\n}
