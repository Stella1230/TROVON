static void _init_txservq(struct tx_servq *ptxservq)\r\n{\r\nINIT_LIST_HEAD(&ptxservq->tx_pending);\r\n_rtw_init_queue(&ptxservq->sta_pending);\r\nptxservq->qcnt = 0;\r\n}\r\nvoid _rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv)\r\n{\r\nmemset((unsigned char *)psta_xmitpriv, 0, sizeof(struct sta_xmit_priv));\r\nspin_lock_init(&psta_xmitpriv->lock);\r\n_init_txservq(&psta_xmitpriv->be_q);\r\n_init_txservq(&psta_xmitpriv->bk_q);\r\n_init_txservq(&psta_xmitpriv->vi_q);\r\n_init_txservq(&psta_xmitpriv->vo_q);\r\nINIT_LIST_HEAD(&psta_xmitpriv->legacy_dz);\r\nINIT_LIST_HEAD(&psta_xmitpriv->apsd);\r\n}\r\ns32 _rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, struct adapter *padapter)\r\n{\r\nint i;\r\nstruct xmit_buf *pxmitbuf;\r\nstruct xmit_frame *pxframe;\r\nint res = _SUCCESS;\r\nu32 max_xmit_extbuf_size = MAX_XMIT_EXTBUF_SZ;\r\nu32 num_xmit_extbuf = NR_XMIT_EXTBUFF;\r\nspin_lock_init(&pxmitpriv->lock);\r\npxmitpriv->adapter = padapter;\r\n_rtw_init_queue(&pxmitpriv->be_pending);\r\n_rtw_init_queue(&pxmitpriv->bk_pending);\r\n_rtw_init_queue(&pxmitpriv->vi_pending);\r\n_rtw_init_queue(&pxmitpriv->vo_pending);\r\n_rtw_init_queue(&pxmitpriv->bm_pending);\r\n_rtw_init_queue(&pxmitpriv->free_xmit_queue);\r\npxmitpriv->pallocated_frame_buf = vzalloc(NR_XMITFRAME * sizeof(struct xmit_frame) + 4);\r\nif (pxmitpriv->pallocated_frame_buf == NULL) {\r\npxmitpriv->pxmit_frame_buf = NULL;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("alloc xmit_frame fail!\n"));\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npxmitpriv->pxmit_frame_buf = PTR_ALIGN(pxmitpriv->pallocated_frame_buf, 4);\r\npxframe = (struct xmit_frame *)pxmitpriv->pxmit_frame_buf;\r\nfor (i = 0; i < NR_XMITFRAME; i++) {\r\nINIT_LIST_HEAD(&(pxframe->list));\r\npxframe->padapter = padapter;\r\npxframe->frame_tag = NULL_FRAMETAG;\r\npxframe->pkt = NULL;\r\npxframe->buf_addr = NULL;\r\npxframe->pxmitbuf = NULL;\r\nlist_add_tail(&(pxframe->list), &(pxmitpriv->free_xmit_queue.queue));\r\npxframe++;\r\n}\r\npxmitpriv->free_xmitframe_cnt = NR_XMITFRAME;\r\npxmitpriv->frag_len = MAX_FRAG_THRESHOLD;\r\n_rtw_init_queue(&pxmitpriv->free_xmitbuf_queue);\r\n_rtw_init_queue(&pxmitpriv->pending_xmitbuf_queue);\r\npxmitpriv->pallocated_xmitbuf = vzalloc(NR_XMITBUFF * sizeof(struct xmit_buf) + 4);\r\nif (pxmitpriv->pallocated_xmitbuf == NULL) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("alloc xmit_buf fail!\n"));\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npxmitpriv->pxmitbuf = PTR_ALIGN(pxmitpriv->pallocated_xmitbuf, 4);\r\npxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;\r\nfor (i = 0; i < NR_XMITBUFF; i++) {\r\nINIT_LIST_HEAD(&pxmitbuf->list);\r\npxmitbuf->priv_data = NULL;\r\npxmitbuf->padapter = padapter;\r\npxmitbuf->ext_tag = false;\r\nres = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ));\r\nif (res == _FAIL) {\r\nmsleep(10);\r\nres = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ));\r\nif (res == _FAIL)\r\ngoto exit;\r\n}\r\npxmitbuf->flags = XMIT_VO_QUEUE;\r\nlist_add_tail(&pxmitbuf->list, &(pxmitpriv->free_xmitbuf_queue.queue));\r\npxmitbuf++;\r\n}\r\npxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF;\r\n_rtw_init_queue(&pxmitpriv->free_xmit_extbuf_queue);\r\npxmitpriv->pallocated_xmit_extbuf = vzalloc(num_xmit_extbuf * sizeof(struct xmit_buf) + 4);\r\nif (pxmitpriv->pallocated_xmit_extbuf == NULL) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("alloc xmit_extbuf fail!\n"));\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npxmitpriv->pxmit_extbuf = PTR_ALIGN(pxmitpriv->pallocated_xmit_extbuf, 4);\r\npxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;\r\nfor (i = 0; i < num_xmit_extbuf; i++) {\r\nINIT_LIST_HEAD(&pxmitbuf->list);\r\npxmitbuf->priv_data = NULL;\r\npxmitbuf->padapter = padapter;\r\npxmitbuf->ext_tag = true;\r\nres = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, max_xmit_extbuf_size + XMITBUF_ALIGN_SZ);\r\nif (res == _FAIL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nlist_add_tail(&pxmitbuf->list, &(pxmitpriv->free_xmit_extbuf_queue.queue));\r\npxmitbuf++;\r\n}\r\npxmitpriv->free_xmit_extbuf_cnt = num_xmit_extbuf;\r\nrtw_alloc_hwxmits(padapter);\r\nrtw_init_hwxmits(pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);\r\nfor (i = 0; i < 4; i++)\r\npxmitpriv->wmm_para_seq[i] = i;\r\npxmitpriv->txirp_cnt = 1;\r\npxmitpriv->beq_cnt = 0;\r\npxmitpriv->bkq_cnt = 0;\r\npxmitpriv->viq_cnt = 0;\r\npxmitpriv->voq_cnt = 0;\r\npxmitpriv->ack_tx = false;\r\nmutex_init(&pxmitpriv->ack_tx_mutex);\r\nrtw_sctx_init(&pxmitpriv->ack_tx_ops, 0);\r\nrtw_hal_init_xmit_priv(padapter);\r\nexit:\r\nreturn res;\r\n}\r\nvoid _rtw_free_xmit_priv(struct xmit_priv *pxmitpriv)\r\n{\r\nint i;\r\nstruct adapter *padapter = pxmitpriv->adapter;\r\nstruct xmit_frame *pxmitframe = (struct xmit_frame *)pxmitpriv->pxmit_frame_buf;\r\nstruct xmit_buf *pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;\r\nu32 num_xmit_extbuf = NR_XMIT_EXTBUFF;\r\nif (pxmitpriv->pxmit_frame_buf == NULL)\r\nreturn;\r\nfor (i = 0; i < NR_XMITFRAME; i++) {\r\nrtw_os_xmit_complete(padapter, pxmitframe);\r\npxmitframe++;\r\n}\r\nfor (i = 0; i < NR_XMITBUFF; i++) {\r\nrtw_os_xmit_resource_free(pxmitbuf);\r\npxmitbuf++;\r\n}\r\nvfree(pxmitpriv->pallocated_frame_buf);\r\nvfree(pxmitpriv->pallocated_xmitbuf);\r\npxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;\r\nfor (i = 0; i < num_xmit_extbuf; i++) {\r\nrtw_os_xmit_resource_free(pxmitbuf);\r\npxmitbuf++;\r\n}\r\nvfree(pxmitpriv->pallocated_xmit_extbuf);\r\nrtw_free_hwxmits(padapter);\r\nmutex_destroy(&pxmitpriv->ack_tx_mutex);\r\n}\r\nstatic void update_attrib_vcs_info(struct adapter *padapter, struct xmit_frame *pxmitframe)\r\n{\r\nu32 sz;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct sta_info *psta = pattrib->psta;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nif (pattrib->nr_frags != 1)\r\nsz = padapter->xmitpriv.frag_len;\r\nelse\r\nsz = pattrib->last_txcmdsz;\r\nif (pmlmeext->cur_wireless_mode < WIRELESS_11_24N || padapter->registrypriv.wifi_spec) {\r\nif (sz > padapter->registrypriv.rts_thresh) {\r\npattrib->vcs_mode = RTS_CTS;\r\n} else {\r\nif (psta->rtsen)\r\npattrib->vcs_mode = RTS_CTS;\r\nelse if (psta->cts2self)\r\npattrib->vcs_mode = CTS_TO_SELF;\r\nelse\r\npattrib->vcs_mode = NONE_VCS;\r\n}\r\n} else {\r\nwhile (true) {\r\nif ((pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_ATHEROS) && pattrib->ampdu_en &&\r\n(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)) {\r\npattrib->vcs_mode = CTS_TO_SELF;\r\nbreak;\r\n}\r\nif (psta->rtsen || psta->cts2self) {\r\nif (psta->rtsen)\r\npattrib->vcs_mode = RTS_CTS;\r\nelse if (psta->cts2self)\r\npattrib->vcs_mode = CTS_TO_SELF;\r\nbreak;\r\n}\r\nif (pattrib->ht_en) {\r\nu8 htopmode = pmlmeinfo->HT_protection;\r\nif ((pmlmeext->cur_bwmode && (htopmode == 2 || htopmode == 3)) ||\r\n(!pmlmeext->cur_bwmode && htopmode == 3)) {\r\npattrib->vcs_mode = RTS_CTS;\r\nbreak;\r\n}\r\n}\r\nif (sz > padapter->registrypriv.rts_thresh) {\r\npattrib->vcs_mode = RTS_CTS;\r\nbreak;\r\n}\r\nif (pattrib->ampdu_en) {\r\npattrib->vcs_mode = RTS_CTS;\r\nbreak;\r\n}\r\npattrib->vcs_mode = NONE_VCS;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void update_attrib_phy_info(struct pkt_attrib *pattrib, struct sta_info *psta)\r\n{\r\npattrib->mdata = 0;\r\npattrib->eosp = 0;\r\npattrib->triggered = 0;\r\npattrib->qos_en = psta->qos_option;\r\npattrib->raid = psta->raid;\r\npattrib->ht_en = psta->htpriv.ht_option;\r\npattrib->bwmode = psta->htpriv.bwmode;\r\npattrib->ch_offset = psta->htpriv.ch_offset;\r\npattrib->sgi = psta->htpriv.sgi;\r\npattrib->ampdu_en = false;\r\npattrib->retry_ctrl = false;\r\n}\r\nu8 qos_acm(u8 acm_mask, u8 priority)\r\n{\r\nu8 change_priority = priority;\r\nswitch (priority) {\r\ncase 0:\r\ncase 3:\r\nif (acm_mask & BIT(1))\r\nchange_priority = 1;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nif (acm_mask & BIT(2))\r\nchange_priority = 0;\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nif (acm_mask & BIT(3))\r\nchange_priority = 5;\r\nbreak;\r\ndefault:\r\nDBG_88E("qos_acm(): invalid pattrib->priority: %d!!!\n", priority);\r\nbreak;\r\n}\r\nreturn change_priority;\r\n}\r\nstatic void set_qos(struct pkt_file *ppktfile, struct pkt_attrib *pattrib)\r\n{\r\nstruct ethhdr etherhdr;\r\nstruct iphdr ip_hdr;\r\ns32 user_prio = 0;\r\n_rtw_open_pktfile(ppktfile->pkt, ppktfile);\r\n_rtw_pktfile_read(ppktfile, (unsigned char *)&etherhdr, ETH_HLEN);\r\nif (pattrib->ether_type == 0x0800) {\r\n_rtw_pktfile_read(ppktfile, (u8 *)&ip_hdr, sizeof(ip_hdr));\r\nuser_prio = ip_hdr.tos >> 5;\r\n} else if (pattrib->ether_type == ETH_P_PAE) {\r\nuser_prio = 7;\r\n}\r\npattrib->priority = user_prio;\r\npattrib->hdrlen = WLAN_HDR_A3_QOS_LEN;\r\npattrib->subtype = WIFI_QOS_DATA_TYPE;\r\n}\r\nstatic s32 update_attrib(struct adapter *padapter, struct sk_buff *pkt, struct pkt_attrib *pattrib)\r\n{\r\nstruct pkt_file pktfile;\r\nstruct sta_info *psta = NULL;\r\nstruct ethhdr etherhdr;\r\nint bmcast;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct qos_priv *pqospriv = &pmlmepriv->qospriv;\r\nint res = _SUCCESS;\r\n_rtw_open_pktfile(pkt, &pktfile);\r\n_rtw_pktfile_read(&pktfile, (u8 *)&etherhdr, ETH_HLEN);\r\npattrib->ether_type = ntohs(etherhdr.h_proto);\r\nmemcpy(pattrib->dst, &etherhdr.h_dest, ETH_ALEN);\r\nmemcpy(pattrib->src, &etherhdr.h_source, ETH_ALEN);\r\npattrib->pctrl = 0;\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) ||\r\ncheck_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {\r\nmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\r\nmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\r\n} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\r\nmemcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);\r\nmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\r\n} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\r\nmemcpy(pattrib->ta, get_bssid(pmlmepriv), ETH_ALEN);\r\n}\r\npattrib->pktlen = pktfile.pkt_len;\r\nif (pattrib->ether_type == ETH_P_IP) {\r\nu8 tmp[24];\r\n_rtw_pktfile_read(&pktfile, &tmp[0], 24);\r\npattrib->dhcp_pkt = 0;\r\nif (pktfile.pkt_len > 282) {\r\nif (pattrib->ether_type == ETH_P_IP) {\r\nif (((tmp[21] == 68) && (tmp[23] == 67)) ||\r\n((tmp[21] == 67) && (tmp[23] == 68))) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("====================== update_attrib: get DHCP Packet\n"));\r\npattrib->dhcp_pkt = 1;\r\n}\r\n}\r\n}\r\n} else if (pattrib->ether_type == ETH_P_PAE) {\r\nDBG_88E_LEVEL(_drv_info_, "send eapol packet\n");\r\n}\r\nif ((pattrib->ether_type == ETH_P_PAE) || (pattrib->dhcp_pkt == 1))\r\nrtw_set_scan_deny(padapter, 3000);\r\nif ((pattrib->ether_type == ETH_P_ARP) || (pattrib->ether_type == ETH_P_PAE) || (pattrib->dhcp_pkt == 1))\r\nrtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SPECIAL_PACKET, 1);\r\nbmcast = IS_MCAST(pattrib->ra);\r\nif (bmcast) {\r\npsta = rtw_get_bcmc_stainfo(padapter);\r\n} else {\r\npsta = rtw_get_stainfo(pstapriv, pattrib->ra);\r\nif (psta == NULL) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("\nupdate_attrib => get sta_info fail, ra: %pM\n", (pattrib->ra)));\r\nres = _FAIL;\r\ngoto exit;\r\n} else if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) && (!(psta->state & _FW_LINKED))) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\n}\r\nif (psta) {\r\npattrib->mac_id = psta->mac_id;\r\npattrib->psta = psta;\r\n} else {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("\nupdate_attrib => get sta_info fail, ra:%pM\n", (pattrib->ra)));\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npattrib->ack_policy = 0;\r\npattrib->hdrlen = WLAN_HDR_A3_LEN;\r\npattrib->subtype = WIFI_DATA_TYPE;\r\npattrib->priority = 0;\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE)) {\r\nif (psta->qos_option)\r\nset_qos(&pktfile, pattrib);\r\n} else {\r\nif (pqospriv->qos_option) {\r\nset_qos(&pktfile, pattrib);\r\nif (pmlmepriv->acm_mask != 0)\r\npattrib->priority = qos_acm(pmlmepriv->acm_mask, pattrib->priority);\r\n}\r\n}\r\nif (psta->ieee8021x_blocked) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("\n psta->ieee8021x_blocked == true\n"));\r\npattrib->encrypt = 0;\r\nif (pattrib->ether_type != ETH_P_PAE) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("\npsta->ieee8021x_blocked == true, pattrib->ether_type(%.4x) != ETH_P_PAE\n", pattrib->ether_type));\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\n} else {\r\nGET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, bmcast);\r\nswitch (psecuritypriv->dot11AuthAlgrthm) {\r\ncase dot11AuthAlgrthm_Open:\r\ncase dot11AuthAlgrthm_Shared:\r\ncase dot11AuthAlgrthm_Auto:\r\npattrib->key_idx = (u8)psecuritypriv->dot11PrivacyKeyIndex;\r\nbreak;\r\ncase dot11AuthAlgrthm_8021X:\r\nif (bmcast)\r\npattrib->key_idx = (u8)psecuritypriv->dot118021XGrpKeyid;\r\nelse\r\npattrib->key_idx = 0;\r\nbreak;\r\ndefault:\r\npattrib->key_idx = 0;\r\nbreak;\r\n}\r\n}\r\nswitch (pattrib->encrypt) {\r\ncase _WEP40_:\r\ncase _WEP104_:\r\npattrib->iv_len = 4;\r\npattrib->icv_len = 4;\r\nbreak;\r\ncase _TKIP_:\r\npattrib->iv_len = 8;\r\npattrib->icv_len = 4;\r\nif (padapter->securitypriv.busetkipkey == _FAIL) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n("\npadapter->securitypriv.busetkipkey(%d) == _FAIL drop packet\n",\r\npadapter->securitypriv.busetkipkey));\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nbreak;\r\ncase _AES_:\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("pattrib->encrypt=%d (_AES_)\n", pattrib->encrypt));\r\npattrib->iv_len = 8;\r\npattrib->icv_len = 8;\r\nbreak;\r\ndefault:\r\npattrib->iv_len = 0;\r\npattrib->icv_len = 0;\r\nbreak;\r\n}\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n("update_attrib: encrypt=%d\n", pattrib->encrypt));\r\nif (pattrib->encrypt && !psecuritypriv->hw_decrypted) {\r\npattrib->bswenc = true;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n("update_attrib: encrypt=%d bswenc = true\n",\r\npattrib->encrypt));\r\n} else {\r\npattrib->bswenc = false;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("update_attrib: bswenc = false\n"));\r\n}\r\nupdate_attrib_phy_info(pattrib, psta);\r\nexit:\r\nreturn res;\r\n}\r\nstatic s32 xmitframe_addmic(struct adapter *padapter, struct xmit_frame *pxmitframe)\r\n{\r\nint curfragnum, length;\r\nu8 *pframe, *payload, mic[8];\r\nstruct mic_data micdata;\r\nstruct sta_info *stainfo;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nu8 priority[4] = {0x0, 0x0, 0x0, 0x0};\r\nu8 hw_hdr_offset = 0;\r\nint bmcst = IS_MCAST(pattrib->ra);\r\nif (pattrib->psta)\r\nstainfo = pattrib->psta;\r\nelse\r\nstainfo = rtw_get_stainfo(&padapter->stapriv, &pattrib->ra[0]);\r\nhw_hdr_offset = TXDESC_SIZE + (pxmitframe->pkt_offset * PACKET_OFFSET_SZ);\r\nif (pattrib->encrypt == _TKIP_) {\r\nif (stainfo != NULL) {\r\nu8 null_key[16] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\r\n0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\r\n0x0, 0x0};\r\npframe = pxmitframe->buf_addr + hw_hdr_offset;\r\nif (bmcst) {\r\nif (!memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16))\r\nreturn _FAIL;\r\nrtw_secmicsetkey(&micdata, psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey);\r\n} else {\r\nif (!memcmp(&stainfo->dot11tkiptxmickey.skey[0], null_key, 16)) {\r\nreturn _FAIL;\r\n}\r\nrtw_secmicsetkey(&micdata, &stainfo->dot11tkiptxmickey.skey[0]);\r\n}\r\nif (pframe[1]&1) {\r\nrtw_secmicappend(&micdata, &pframe[16], 6);\r\nif (pframe[1]&2)\r\nrtw_secmicappend(&micdata, &pframe[24], 6);\r\nelse\r\nrtw_secmicappend(&micdata, &pframe[10], 6);\r\n} else {\r\nrtw_secmicappend(&micdata, &pframe[4], 6);\r\nif (pframe[1]&2)\r\nrtw_secmicappend(&micdata, &pframe[16], 6);\r\nelse\r\nrtw_secmicappend(&micdata, &pframe[10], 6);\r\n}\r\nif (pattrib->qos_en)\r\npriority[0] = (u8)pxmitframe->attrib.priority;\r\nrtw_secmicappend(&micdata, &priority[0], 4);\r\npayload = pframe;\r\nfor (curfragnum = 0; curfragnum < pattrib->nr_frags; curfragnum++) {\r\npayload = (u8 *)round_up((size_t)(payload), 4);\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n("=== curfragnum=%d, pframe = 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x,!!!\n",\r\ncurfragnum, *payload, *(payload+1),\r\n*(payload+2), *(payload+3),\r\n*(payload+4), *(payload+5),\r\n*(payload+6), *(payload+7)));\r\npayload = payload+pattrib->hdrlen+pattrib->iv_len;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n("curfragnum=%d pattrib->hdrlen=%d pattrib->iv_len=%d",\r\ncurfragnum, pattrib->hdrlen, pattrib->iv_len));\r\nif ((curfragnum+1) == pattrib->nr_frags) {\r\nlength = pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);\r\nrtw_secmicappend(&micdata, payload, length);\r\npayload = payload+length;\r\n} else {\r\nlength = pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);\r\nrtw_secmicappend(&micdata, payload, length);\r\npayload = payload+length+pattrib->icv_len;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("curfragnum=%d length=%d pattrib->icv_len=%d", curfragnum, length, pattrib->icv_len));\r\n}\r\n}\r\nrtw_secgetmic(&micdata, &(mic[0]));\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("xmitframe_addmic: before add mic code!!!\n"));\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("xmitframe_addmic: pattrib->last_txcmdsz=%d!!!\n", pattrib->last_txcmdsz));\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("xmitframe_addmic: mic[0]=0x%.2x , mic[1]=0x%.2x , mic[2]= 0x%.2x, mic[3]=0x%.2x\n\\r\nmic[4]= 0x%.2x , mic[5]= 0x%.2x , mic[6]= 0x%.2x , mic[7]= 0x%.2x !!!!\n",\r\nmic[0], mic[1], mic[2], mic[3], mic[4], mic[5], mic[6], mic[7]));\r\nmemcpy(payload, &(mic[0]), 8);\r\npattrib->last_txcmdsz += 8;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("\n ======== last pkt ========\n"));\r\npayload = payload-pattrib->last_txcmdsz+8;\r\nfor (curfragnum = 0; curfragnum < pattrib->last_txcmdsz; curfragnum = curfragnum+8)\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n(" %.2x, %.2x, %.2x, %.2x, %.2x, %.2x, %.2x, %.2x ",\r\n*(payload+curfragnum), *(payload+curfragnum+1),\r\n*(payload+curfragnum+2), *(payload+curfragnum+3),\r\n*(payload+curfragnum+4), *(payload+curfragnum+5),\r\n*(payload+curfragnum+6), *(payload+curfragnum+7)));\r\n} else {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("xmitframe_addmic: rtw_get_stainfo==NULL!!!\n"));\r\n}\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic s32 xmitframe_swencrypt(struct adapter *padapter, struct xmit_frame *pxmitframe)\r\n{\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nif (pattrib->bswenc) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("### xmitframe_swencrypt\n"));\r\nswitch (pattrib->encrypt) {\r\ncase _WEP40_:\r\ncase _WEP104_:\r\nrtw_wep_encrypt(padapter, (u8 *)pxmitframe);\r\nbreak;\r\ncase _TKIP_:\r\nrtw_tkip_encrypt(padapter, (u8 *)pxmitframe);\r\nbreak;\r\ncase _AES_:\r\nrtw_aes_encrypt(padapter, (u8 *)pxmitframe);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_, ("### xmitframe_hwencrypt\n"));\r\n}\r\nreturn _SUCCESS;\r\n}\r\ns32 rtw_make_wlanhdr(struct adapter *padapter, u8 *hdr, struct pkt_attrib *pattrib)\r\n{\r\nu16 *qc;\r\nstruct ieee80211_hdr *pwlanhdr = (struct ieee80211_hdr *)hdr;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct qos_priv *pqospriv = &pmlmepriv->qospriv;\r\nu8 qos_option = false;\r\nint res = _SUCCESS;\r\n__le16 *fctrl = &pwlanhdr->frame_control;\r\nstruct sta_info *psta;\r\nint bmcst = IS_MCAST(pattrib->ra);\r\nif (pattrib->psta) {\r\npsta = pattrib->psta;\r\n} else {\r\nif (bmcst)\r\npsta = rtw_get_bcmc_stainfo(padapter);\r\nelse\r\npsta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);\r\n}\r\nmemset(hdr, 0, WLANHDR_OFFSET);\r\nSetFrameSubType(fctrl, pattrib->subtype);\r\nif (pattrib->subtype & WIFI_DATA_TYPE) {\r\nif ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)) {\r\nSetToDs(fctrl);\r\nmemcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);\r\nif (pqospriv->qos_option)\r\nqos_option = true;\r\n} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nSetFrDs(fctrl);\r\nmemcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, get_bssid(pmlmepriv), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, pattrib->src, ETH_ALEN);\r\nif (psta->qos_option)\r\nqos_option = true;\r\n} else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) ||\r\ncheck_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {\r\nmemcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);\r\nif (psta->qos_option)\r\nqos_option = true;\r\n} else {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("fw_state:%x is not allowed to xmit frame\n", get_fwstate(pmlmepriv)));\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nif (pattrib->mdata)\r\nSetMData(fctrl);\r\nif (pattrib->encrypt)\r\nSetPrivacy(fctrl);\r\nif (qos_option) {\r\nqc = (unsigned short *)(hdr + pattrib->hdrlen - 2);\r\nif (pattrib->priority)\r\nSetPriority(qc, pattrib->priority);\r\nSetEOSP(qc, pattrib->eosp);\r\nSetAckpolicy(qc, pattrib->ack_policy);\r\n}\r\nif (psta) {\r\npsta->sta_xmitpriv.txseq_tid[pattrib->priority]++;\r\npsta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;\r\npattrib->seqnum = psta->sta_xmitpriv.txseq_tid[pattrib->priority];\r\nSetSeqNum(hdr, pattrib->seqnum);\r\nif (pattrib->ht_en && psta->htpriv.ampdu_enable) {\r\nif (psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))\r\npattrib->ampdu_en = true;\r\n}\r\nif (pattrib->ampdu_en) {\r\nu16 tx_seq;\r\ntx_seq = psta->BA_starting_seqctrl[pattrib->priority & 0x0f];\r\nif (SN_LESS(pattrib->seqnum, tx_seq)) {\r\npattrib->ampdu_en = false;\r\n} else if (SN_EQUAL(pattrib->seqnum, tx_seq)) {\r\npsta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (tx_seq+1)&0xfff;\r\npattrib->ampdu_en = true;\r\n} else {\r\npsta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (pattrib->seqnum+1)&0xfff;\r\npattrib->ampdu_en = true;\r\n}\r\n}\r\n}\r\n}\r\nexit:\r\nreturn res;\r\n}\r\ns32 rtw_txframes_pending(struct adapter *padapter)\r\n{\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nreturn (!list_empty(&pxmitpriv->be_pending.queue) ||\r\n!list_empty(&pxmitpriv->bk_pending.queue) ||\r\n!list_empty(&pxmitpriv->vi_pending.queue) ||\r\n!list_empty(&pxmitpriv->vo_pending.queue));\r\n}\r\ns32 rtw_txframes_sta_ac_pending(struct adapter *padapter, struct pkt_attrib *pattrib)\r\n{\r\nstruct sta_info *psta;\r\nstruct tx_servq *ptxservq;\r\nint priority = pattrib->priority;\r\npsta = pattrib->psta;\r\nswitch (priority) {\r\ncase 1:\r\ncase 2:\r\nptxservq = &(psta->sta_xmitpriv.bk_q);\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nptxservq = &(psta->sta_xmitpriv.vi_q);\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nptxservq = &(psta->sta_xmitpriv.vo_q);\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\nptxservq = &(psta->sta_xmitpriv.be_q);\r\nbreak;\r\n}\r\nreturn ptxservq->qcnt;\r\n}\r\nu32 rtw_calculate_wlan_pkt_size_by_attribue(struct pkt_attrib *pattrib)\r\n{\r\nu32 len = 0;\r\nlen = pattrib->hdrlen + pattrib->iv_len;\r\nlen += SNAP_SIZE + sizeof(u16);\r\nlen += pattrib->pktlen;\r\nif (pattrib->encrypt == _TKIP_)\r\nlen += 8;\r\nlen += ((pattrib->bswenc) ? pattrib->icv_len : 0);\r\nreturn len;\r\n}\r\ns32 rtw_xmitframe_coalesce(struct adapter *padapter, struct sk_buff *pkt, struct xmit_frame *pxmitframe)\r\n{\r\nstruct pkt_file pktfile;\r\ns32 frg_inx, frg_len, mpdu_len, llc_sz, mem_sz;\r\nsize_t addr;\r\nu8 *pframe, *mem_start;\r\nu8 hw_hdr_offset;\r\nstruct sta_info *psta;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nu8 *pbuf_start;\r\ns32 bmcst = IS_MCAST(pattrib->ra);\r\ns32 res = _SUCCESS;\r\npsta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);\r\nif (psta == NULL)\r\nreturn _FAIL;\r\nif (pxmitframe->buf_addr == NULL) {\r\nDBG_88E("==> %s buf_addr == NULL\n", __func__);\r\nreturn _FAIL;\r\n}\r\npbuf_start = pxmitframe->buf_addr;\r\nhw_hdr_offset = TXDESC_SIZE + (pxmitframe->pkt_offset * PACKET_OFFSET_SZ);\r\nmem_start = pbuf_start + hw_hdr_offset;\r\nif (rtw_make_wlanhdr(padapter, mem_start, pattrib) == _FAIL) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("rtw_xmitframe_coalesce: rtw_make_wlanhdr fail; drop pkt\n"));\r\nDBG_88E("rtw_xmitframe_coalesce: rtw_make_wlanhdr fail; drop pkt\n");\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\n_rtw_open_pktfile(pkt, &pktfile);\r\n_rtw_pktfile_read(&pktfile, NULL, ETH_HLEN);\r\nfrg_inx = 0;\r\nfrg_len = pxmitpriv->frag_len - 4;\r\nwhile (1) {\r\nllc_sz = 0;\r\nmpdu_len = frg_len;\r\npframe = mem_start;\r\nSetMFrag(mem_start);\r\npframe += pattrib->hdrlen;\r\nmpdu_len -= pattrib->hdrlen;\r\nif (pattrib->iv_len) {\r\nswitch (pattrib->encrypt) {\r\ncase _WEP40_:\r\ncase _WEP104_:\r\nWEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);\r\nbreak;\r\ncase _TKIP_:\r\nif (bmcst)\r\nTKIP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);\r\nelse\r\nTKIP_IV(pattrib->iv, psta->dot11txpn, 0);\r\nbreak;\r\ncase _AES_:\r\nif (bmcst)\r\nAES_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);\r\nelse\r\nAES_IV(pattrib->iv, psta->dot11txpn, 0);\r\nbreak;\r\n}\r\nmemcpy(pframe, pattrib->iv, pattrib->iv_len);\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_,\r\n("rtw_xmitframe_coalesce: keyid=%d pattrib->iv[3]=%.2x pframe=%.2x %.2x %.2x %.2x\n",\r\npadapter->securitypriv.dot11PrivacyKeyIndex, pattrib->iv[3], *pframe, *(pframe+1), *(pframe+2), *(pframe+3)));\r\npframe += pattrib->iv_len;\r\nmpdu_len -= pattrib->iv_len;\r\n}\r\nif (frg_inx == 0) {\r\nllc_sz = rtw_put_snap(pframe, pattrib->ether_type);\r\npframe += llc_sz;\r\nmpdu_len -= llc_sz;\r\n}\r\nif ((pattrib->icv_len > 0) && (pattrib->bswenc))\r\nmpdu_len -= pattrib->icv_len;\r\nif (bmcst) {\r\nmem_sz = _rtw_pktfile_read(&pktfile, pframe, pattrib->pktlen);\r\n} else {\r\nmem_sz = _rtw_pktfile_read(&pktfile, pframe, mpdu_len);\r\n}\r\npframe += mem_sz;\r\nif ((pattrib->icv_len > 0) && (pattrib->bswenc)) {\r\nmemcpy(pframe, pattrib->icv, pattrib->icv_len);\r\npframe += pattrib->icv_len;\r\n}\r\nfrg_inx++;\r\nif (bmcst || pktfile.pkt_len == 0) {\r\npattrib->nr_frags = frg_inx;\r\npattrib->last_txcmdsz = pattrib->hdrlen + pattrib->iv_len + ((pattrib->nr_frags == 1) ? llc_sz : 0) +\r\n((pattrib->bswenc) ? pattrib->icv_len : 0) + mem_sz;\r\nClearMFrag(mem_start);\r\nbreak;\r\n} else {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("%s: There're still something in packet!\n", __func__));\r\n}\r\naddr = (size_t)(pframe);\r\nmem_start = (unsigned char *)round_up(addr, 4) + hw_hdr_offset;\r\nmemcpy(mem_start, pbuf_start + hw_hdr_offset, pattrib->hdrlen);\r\n}\r\nrtl88eu_mon_xmit_hook(padapter->pmondev, pxmitframe, frg_len);\r\nif (xmitframe_addmic(padapter, pxmitframe) == _FAIL) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("xmitframe_addmic(padapter, pxmitframe) == _FAIL\n"));\r\nDBG_88E("xmitframe_addmic(padapter, pxmitframe) == _FAIL\n");\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nxmitframe_swencrypt(padapter, pxmitframe);\r\nif (!bmcst)\r\nupdate_attrib_vcs_info(padapter, pxmitframe);\r\nelse\r\npattrib->vcs_mode = NONE_VCS;\r\nexit:\r\nreturn res;\r\n}\r\ns32 rtw_put_snap(u8 *data, u16 h_proto)\r\n{\r\nstruct ieee80211_snap_hdr *snap;\r\nu8 *oui;\r\nsnap = (struct ieee80211_snap_hdr *)data;\r\nsnap->dsap = 0xaa;\r\nsnap->ssap = 0xaa;\r\nsnap->ctrl = 0x03;\r\nif (h_proto == 0x8137 || h_proto == 0x80f3)\r\noui = P802_1H_OUI;\r\nelse\r\noui = RFC1042_OUI;\r\nsnap->oui[0] = oui[0];\r\nsnap->oui[1] = oui[1];\r\nsnap->oui[2] = oui[2];\r\n*(__be16 *)(data + SNAP_SIZE) = htons(h_proto);\r\nreturn SNAP_SIZE + sizeof(u16);\r\n}\r\nvoid rtw_update_protection(struct adapter *padapter, u8 *ie, uint ie_len)\r\n{\r\nuint protection, erp_len;\r\nu8 *perp;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nswitch (pxmitpriv->vcs_setting) {\r\ncase DISABLE_VCS:\r\npxmitpriv->vcs = NONE_VCS;\r\nbreak;\r\ncase ENABLE_VCS:\r\nbreak;\r\ncase AUTO_VCS:\r\ndefault:\r\nperp = rtw_get_ie(ie, _ERPINFO_IE_, &erp_len, ie_len);\r\nif (perp == NULL) {\r\npxmitpriv->vcs = NONE_VCS;\r\n} else {\r\nprotection = (*(perp + 2)) & BIT(1);\r\nif (protection) {\r\nif (pregistrypriv->vcs_type == RTS_CTS)\r\npxmitpriv->vcs = RTS_CTS;\r\nelse\r\npxmitpriv->vcs = CTS_TO_SELF;\r\n} else {\r\npxmitpriv->vcs = NONE_VCS;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nvoid rtw_count_tx_stats(struct adapter *padapter, struct xmit_frame *pxmitframe, int sz)\r\n{\r\nstruct sta_info *psta = NULL;\r\nstruct stainfo_stats *pstats = NULL;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nif ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG) {\r\npxmitpriv->tx_bytes += sz;\r\npmlmepriv->LinkDetectInfo.NumTxOkInPeriod += pxmitframe->agg_num;\r\npsta = pxmitframe->attrib.psta;\r\nif (psta) {\r\npstats = &psta->sta_stats;\r\npstats->tx_pkts += pxmitframe->agg_num;\r\npstats->tx_bytes += sz;\r\n}\r\n}\r\n}\r\nstruct xmit_buf *rtw_alloc_xmitbuf_ext(struct xmit_priv *pxmitpriv)\r\n{\r\nunsigned long irql;\r\nstruct xmit_buf *pxmitbuf;\r\nstruct __queue *pfree_queue = &pxmitpriv->free_xmit_extbuf_queue;\r\nspin_lock_irqsave(&pfree_queue->lock, irql);\r\npxmitbuf = list_first_entry_or_null(&pfree_queue->queue,\r\nstruct xmit_buf, list);\r\nif (pxmitbuf) {\r\nlist_del_init(&pxmitbuf->list);\r\npxmitpriv->free_xmit_extbuf_cnt--;\r\npxmitbuf->priv_data = NULL;\r\nif (pxmitbuf->sctx) {\r\nDBG_88E("%s pxmitbuf->sctx is not NULL\n", __func__);\r\nrtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_ALLOC);\r\n}\r\n}\r\nspin_unlock_irqrestore(&pfree_queue->lock, irql);\r\nreturn pxmitbuf;\r\n}\r\ns32 rtw_free_xmitbuf_ext(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)\r\n{\r\nunsigned long irql;\r\nstruct __queue *pfree_queue = &pxmitpriv->free_xmit_extbuf_queue;\r\nif (pxmitbuf == NULL)\r\nreturn _FAIL;\r\nspin_lock_irqsave(&pfree_queue->lock, irql);\r\nlist_del_init(&pxmitbuf->list);\r\nlist_add_tail(&(pxmitbuf->list), get_list_head(pfree_queue));\r\npxmitpriv->free_xmit_extbuf_cnt++;\r\nspin_unlock_irqrestore(&pfree_queue->lock, irql);\r\nreturn _SUCCESS;\r\n}\r\nstruct xmit_buf *rtw_alloc_xmitbuf(struct xmit_priv *pxmitpriv)\r\n{\r\nunsigned long irql;\r\nstruct xmit_buf *pxmitbuf;\r\nstruct __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;\r\nspin_lock_irqsave(&pfree_xmitbuf_queue->lock, irql);\r\npxmitbuf = list_first_entry_or_null(&pfree_xmitbuf_queue->queue,\r\nstruct xmit_buf, list);\r\nif (pxmitbuf) {\r\nlist_del_init(&pxmitbuf->list);\r\npxmitpriv->free_xmitbuf_cnt--;\r\npxmitbuf->priv_data = NULL;\r\nif (pxmitbuf->sctx) {\r\nDBG_88E("%s pxmitbuf->sctx is not NULL\n", __func__);\r\nrtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_ALLOC);\r\n}\r\n}\r\nspin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irql);\r\nreturn pxmitbuf;\r\n}\r\ns32 rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)\r\n{\r\nunsigned long irql;\r\nstruct __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;\r\nif (pxmitbuf == NULL)\r\nreturn _FAIL;\r\nif (pxmitbuf->sctx) {\r\nDBG_88E("%s pxmitbuf->sctx is not NULL\n", __func__);\r\nrtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_FREE);\r\n}\r\nif (pxmitbuf->ext_tag) {\r\nrtw_free_xmitbuf_ext(pxmitpriv, pxmitbuf);\r\n} else {\r\nspin_lock_irqsave(&pfree_xmitbuf_queue->lock, irql);\r\nlist_del_init(&pxmitbuf->list);\r\nlist_add_tail(&(pxmitbuf->list), get_list_head(pfree_xmitbuf_queue));\r\npxmitpriv->free_xmitbuf_cnt++;\r\nspin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irql);\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstruct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv)\r\n{\r\nstruct xmit_frame *pxframe;\r\nstruct __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;\r\nspin_lock_bh(&pfree_xmit_queue->lock);\r\npxframe = list_first_entry_or_null(&pfree_xmit_queue->queue,\r\nstruct xmit_frame, list);\r\nif (!pxframe) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n("rtw_alloc_xmitframe:%d\n",\r\npxmitpriv->free_xmitframe_cnt));\r\n} else {\r\nlist_del_init(&pxframe->list);\r\npxmitpriv->free_xmitframe_cnt--;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n("rtw_alloc_xmitframe():free_xmitframe_cnt=%d\n",\r\npxmitpriv->free_xmitframe_cnt));\r\npxframe->buf_addr = NULL;\r\npxframe->pxmitbuf = NULL;\r\nmemset(&pxframe->attrib, 0, sizeof(struct pkt_attrib));\r\npxframe->frame_tag = DATA_FRAMETAG;\r\npxframe->pkt = NULL;\r\npxframe->pkt_offset = 1;\r\npxframe->agg_num = 1;\r\npxframe->ack_report = 0;\r\n}\r\nspin_unlock_bh(&pfree_xmit_queue->lock);\r\nreturn pxframe;\r\n}\r\ns32 rtw_free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe)\r\n{\r\nstruct __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;\r\nstruct adapter *padapter = pxmitpriv->adapter;\r\nstruct sk_buff *pndis_pkt = NULL;\r\nif (pxmitframe == NULL) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("====== rtw_free_xmitframe():pxmitframe == NULL!!!!!!!!!!\n"));\r\ngoto exit;\r\n}\r\nspin_lock_bh(&pfree_xmit_queue->lock);\r\nlist_del_init(&pxmitframe->list);\r\nif (pxmitframe->pkt) {\r\npndis_pkt = pxmitframe->pkt;\r\npxmitframe->pkt = NULL;\r\n}\r\nlist_add_tail(&pxmitframe->list, get_list_head(pfree_xmit_queue));\r\npxmitpriv->free_xmitframe_cnt++;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("rtw_free_xmitframe():free_xmitframe_cnt=%d\n", pxmitpriv->free_xmitframe_cnt));\r\nspin_unlock_bh(&pfree_xmit_queue->lock);\r\nif (pndis_pkt)\r\nrtw_os_pkt_complete(padapter, pndis_pkt);\r\nexit:\r\nreturn _SUCCESS;\r\n}\r\nvoid rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, struct __queue *pframequeue)\r\n{\r\nstruct list_head *plist, *phead;\r\nstruct xmit_frame *pxmitframe;\r\nspin_lock_bh(&(pframequeue->lock));\r\nphead = get_list_head(pframequeue);\r\nplist = phead->next;\r\nwhile (phead != plist) {\r\npxmitframe = container_of(plist, struct xmit_frame, list);\r\nplist = plist->next;\r\nrtw_free_xmitframe(pxmitpriv, pxmitframe);\r\n}\r\nspin_unlock_bh(&(pframequeue->lock));\r\n}\r\ns32 rtw_xmitframe_enqueue(struct adapter *padapter, struct xmit_frame *pxmitframe)\r\n{\r\nif (rtw_xmit_classifier(padapter, pxmitframe) == _FAIL) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n("rtw_xmitframe_enqueue: drop xmit pkt for classifier fail\n"));\r\nreturn _FAIL;\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit, struct tx_servq *ptxservq, struct __queue *pframe_queue)\r\n{\r\nstruct list_head *xmitframe_plist, *xmitframe_phead;\r\nstruct xmit_frame *pxmitframe = NULL;\r\nxmitframe_phead = get_list_head(pframe_queue);\r\nxmitframe_plist = xmitframe_phead->next;\r\nif (xmitframe_phead != xmitframe_plist) {\r\npxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);\r\nxmitframe_plist = xmitframe_plist->next;\r\nlist_del_init(&pxmitframe->list);\r\nptxservq->qcnt--;\r\n}\r\nreturn pxmitframe;\r\n}\r\nstruct xmit_frame *rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i, int entry)\r\n{\r\nstruct list_head *sta_plist, *sta_phead;\r\nstruct hw_xmit *phwxmit;\r\nstruct tx_servq *ptxservq = NULL;\r\nstruct __queue *pframe_queue = NULL;\r\nstruct xmit_frame *pxmitframe = NULL;\r\nstruct adapter *padapter = pxmitpriv->adapter;\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nint i, inx[4];\r\ninx[0] = 0; inx[1] = 1; inx[2] = 2; inx[3] = 3;\r\nif (pregpriv->wifi_spec == 1) {\r\nint j;\r\nfor (j = 0; j < 4; j++)\r\ninx[j] = pxmitpriv->wmm_para_seq[j];\r\n}\r\nspin_lock_bh(&pxmitpriv->lock);\r\nfor (i = 0; i < entry; i++) {\r\nphwxmit = phwxmit_i + inx[i];\r\nsta_phead = get_list_head(phwxmit->sta_queue);\r\nsta_plist = sta_phead->next;\r\nwhile (sta_phead != sta_plist) {\r\nptxservq = container_of(sta_plist, struct tx_servq, tx_pending);\r\npframe_queue = &ptxservq->sta_pending;\r\npxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);\r\nif (pxmitframe) {\r\nphwxmit->accnt--;\r\nif (list_empty(&pframe_queue->queue))\r\nlist_del_init(&ptxservq->tx_pending);\r\ngoto exit;\r\n}\r\nsta_plist = sta_plist->next;\r\n}\r\n}\r\nexit:\r\nspin_unlock_bh(&pxmitpriv->lock);\r\nreturn pxmitframe;\r\n}\r\nstruct tx_servq *rtw_get_sta_pending(struct adapter *padapter, struct sta_info *psta, int up, u8 *ac)\r\n{\r\nstruct tx_servq *ptxservq;\r\nswitch (up) {\r\ncase 1:\r\ncase 2:\r\nptxservq = &(psta->sta_xmitpriv.bk_q);\r\n*(ac) = 3;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_get_sta_pending : BK\n"));\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nptxservq = &(psta->sta_xmitpriv.vi_q);\r\n*(ac) = 1;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_get_sta_pending : VI\n"));\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nptxservq = &(psta->sta_xmitpriv.vo_q);\r\n*(ac) = 0;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_get_sta_pending : VO\n"));\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\nptxservq = &(psta->sta_xmitpriv.be_q);\r\n*(ac) = 2;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_get_sta_pending : BE\n"));\r\nbreak;\r\n}\r\nreturn ptxservq;\r\n}\r\ns32 rtw_xmit_classifier(struct adapter *padapter, struct xmit_frame *pxmitframe)\r\n{\r\nu8 ac_index;\r\nstruct sta_info *psta;\r\nstruct tx_servq *ptxservq;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct hw_xmit *phwxmits = padapter->xmitpriv.hwxmits;\r\nint res = _SUCCESS;\r\nif (pattrib->psta)\r\npsta = pattrib->psta;\r\nelse\r\npsta = rtw_get_stainfo(pstapriv, pattrib->ra);\r\nif (psta == NULL) {\r\nres = _FAIL;\r\nDBG_88E("rtw_xmit_classifier: psta == NULL\n");\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("rtw_xmit_classifier: psta == NULL\n"));\r\ngoto exit;\r\n}\r\nptxservq = rtw_get_sta_pending(padapter, psta, pattrib->priority, (u8 *)(&ac_index));\r\nif (list_empty(&ptxservq->tx_pending))\r\nlist_add_tail(&ptxservq->tx_pending, get_list_head(phwxmits[ac_index].sta_queue));\r\nlist_add_tail(&pxmitframe->list, get_list_head(&ptxservq->sta_pending));\r\nptxservq->qcnt++;\r\nphwxmits[ac_index].accnt++;\r\nexit:\r\nreturn res;\r\n}\r\nvoid rtw_alloc_hwxmits(struct adapter *padapter)\r\n{\r\nstruct hw_xmit *hwxmits;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\npxmitpriv->hwxmit_entry = HWXMIT_ENTRY;\r\npxmitpriv->hwxmits = kcalloc(pxmitpriv->hwxmit_entry,\r\nsizeof(struct hw_xmit), GFP_KERNEL);\r\nhwxmits = pxmitpriv->hwxmits;\r\nhwxmits[0] .sta_queue = &pxmitpriv->vo_pending;\r\nhwxmits[1] .sta_queue = &pxmitpriv->vi_pending;\r\nhwxmits[2] .sta_queue = &pxmitpriv->be_pending;\r\nhwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\r\n}\r\nvoid rtw_free_hwxmits(struct adapter *padapter)\r\n{\r\nstruct hw_xmit *hwxmits;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nhwxmits = pxmitpriv->hwxmits;\r\nkfree(hwxmits);\r\n}\r\nvoid rtw_init_hwxmits(struct hw_xmit *phwxmit, int entry)\r\n{\r\nint i;\r\nfor (i = 0; i < entry; i++, phwxmit++)\r\nphwxmit->accnt = 0;\r\n}\r\nu32 rtw_get_ff_hwaddr(struct xmit_frame *pxmitframe)\r\n{\r\nu32 addr;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nswitch (pattrib->qsel) {\r\ncase 0:\r\ncase 3:\r\naddr = BE_QUEUE_INX;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\naddr = BK_QUEUE_INX;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\naddr = VI_QUEUE_INX;\r\nbreak;\r\ncase 6:\r\ncase 7:\r\naddr = VO_QUEUE_INX;\r\nbreak;\r\ncase 0x10:\r\naddr = BCN_QUEUE_INX;\r\nbreak;\r\ncase 0x11:\r\naddr = HIGH_QUEUE_INX;\r\nbreak;\r\ncase 0x12:\r\ndefault:\r\naddr = MGT_QUEUE_INX;\r\nbreak;\r\n}\r\nreturn addr;\r\n}\r\ns32 rtw_xmit(struct adapter *padapter, struct sk_buff **ppkt)\r\n{\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct xmit_frame *pxmitframe = NULL;\r\ns32 res;\r\npxmitframe = rtw_alloc_xmitframe(pxmitpriv);\r\nif (pxmitframe == NULL) {\r\nRT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("rtw_xmit: no more pxmitframe\n"));\r\nDBG_88E("DBG_TX_DROP_FRAME %s no more pxmitframe\n", __func__);\r\nreturn -1;\r\n}\r\nres = update_attrib(padapter, *ppkt, &pxmitframe->attrib);\r\nif (res == _FAIL) {\r\nRT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("rtw_xmit: update attrib fail\n"));\r\nrtw_free_xmitframe(pxmitpriv, pxmitframe);\r\nreturn -1;\r\n}\r\npxmitframe->pkt = *ppkt;\r\nLedControl8188eu(padapter, LED_CTL_TX);\r\npxmitframe->attrib.qsel = pxmitframe->attrib.priority;\r\n#ifdef CONFIG_88EU_AP_MODE\r\nspin_lock_bh(&pxmitpriv->lock);\r\nif (xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe)) {\r\nspin_unlock_bh(&pxmitpriv->lock);\r\nreturn 1;\r\n}\r\nspin_unlock_bh(&pxmitpriv->lock);\r\n#endif\r\nif (rtw_hal_xmit(padapter, pxmitframe) == false)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint xmitframe_enqueue_for_sleeping_sta(struct adapter *padapter, struct xmit_frame *pxmitframe)\r\n{\r\nint ret = false;\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nint bmcst = IS_MCAST(pattrib->ra);\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) == false)\r\nreturn ret;\r\nif (pattrib->psta)\r\npsta = pattrib->psta;\r\nelse\r\npsta = rtw_get_stainfo(pstapriv, pattrib->ra);\r\nif (psta == NULL)\r\nreturn ret;\r\nif (pattrib->triggered == 1) {\r\nif (bmcst)\r\npattrib->qsel = 0x11;\r\nreturn ret;\r\n}\r\nif (bmcst) {\r\nspin_lock_bh(&psta->sleep_q.lock);\r\nif (pstapriv->sta_dz_bitmap) {\r\nlist_del_init(&pxmitframe->list);\r\nlist_add_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));\r\npsta->sleepq_len++;\r\npstapriv->tim_bitmap |= BIT(0);\r\npstapriv->sta_dz_bitmap |= BIT(0);\r\nupdate_beacon(padapter, _TIM_IE_, NULL, false);\r\nret = true;\r\n}\r\nspin_unlock_bh(&psta->sleep_q.lock);\r\nreturn ret;\r\n}\r\nspin_lock_bh(&psta->sleep_q.lock);\r\nif (psta->state&WIFI_SLEEP_STATE) {\r\nu8 wmmps_ac = 0;\r\nif (pstapriv->sta_dz_bitmap&BIT(psta->aid)) {\r\nlist_del_init(&pxmitframe->list);\r\nlist_add_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));\r\npsta->sleepq_len++;\r\nswitch (pattrib->priority) {\r\ncase 1:\r\ncase 2:\r\nwmmps_ac = psta->uapsd_bk & BIT(0);\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nwmmps_ac = psta->uapsd_vi & BIT(0);\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nwmmps_ac = psta->uapsd_vo & BIT(0);\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\nwmmps_ac = psta->uapsd_be & BIT(0);\r\nbreak;\r\n}\r\nif (wmmps_ac)\r\npsta->sleepq_ac_len++;\r\nif (((psta->has_legacy_ac) && (!wmmps_ac)) ||\r\n((!psta->has_legacy_ac) && (wmmps_ac))) {\r\npstapriv->tim_bitmap |= BIT(psta->aid);\r\nif (psta->sleepq_len == 1) {\r\nupdate_beacon(padapter, _TIM_IE_, NULL, false);\r\n}\r\n}\r\nret = true;\r\n}\r\n}\r\nspin_unlock_bh(&psta->sleep_q.lock);\r\nreturn ret;\r\n}\r\nstatic void dequeue_xmitframes_to_sleeping_queue(struct adapter *padapter, struct sta_info *psta, struct __queue *pframequeue)\r\n{\r\nstruct list_head *plist, *phead;\r\nu8 ac_index;\r\nstruct tx_servq *ptxservq;\r\nstruct pkt_attrib *pattrib;\r\nstruct xmit_frame *pxmitframe;\r\nstruct hw_xmit *phwxmits = padapter->xmitpriv.hwxmits;\r\nphead = get_list_head(pframequeue);\r\nplist = phead->next;\r\nwhile (phead != plist) {\r\npxmitframe = container_of(plist, struct xmit_frame, list);\r\nplist = plist->next;\r\nxmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe);\r\npattrib = &pxmitframe->attrib;\r\nptxservq = rtw_get_sta_pending(padapter, psta, pattrib->priority, (u8 *)(&ac_index));\r\nptxservq->qcnt--;\r\nphwxmits[ac_index].accnt--;\r\n}\r\n}\r\nvoid stop_sta_xmit(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nstruct sta_info *psta_bmc;\r\nstruct sta_xmit_priv *pstaxmitpriv;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\npstaxmitpriv = &psta->sta_xmitpriv;\r\npsta_bmc = rtw_get_bcmc_stainfo(padapter);\r\nspin_lock_bh(&pxmitpriv->lock);\r\npsta->state |= WIFI_SLEEP_STATE;\r\npstapriv->sta_dz_bitmap |= BIT(psta->aid);\r\ndequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->vo_q.sta_pending);\r\nlist_del_init(&(pstaxmitpriv->vo_q.tx_pending));\r\ndequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->vi_q.sta_pending);\r\nlist_del_init(&(pstaxmitpriv->vi_q.tx_pending));\r\ndequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->be_q.sta_pending);\r\nlist_del_init(&(pstaxmitpriv->be_q.tx_pending));\r\ndequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->bk_q.sta_pending);\r\nlist_del_init(&(pstaxmitpriv->bk_q.tx_pending));\r\npstaxmitpriv = &psta_bmc->sta_xmitpriv;\r\ndequeue_xmitframes_to_sleeping_queue(padapter, psta_bmc, &pstaxmitpriv->be_q.sta_pending);\r\nlist_del_init(&(pstaxmitpriv->be_q.tx_pending));\r\nspin_unlock_bh(&pxmitpriv->lock);\r\n}\r\nvoid wakeup_sta_to_xmit(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nu8 update_mask = 0, wmmps_ac = 0;\r\nstruct sta_info *psta_bmc;\r\nstruct list_head *xmitframe_plist, *xmitframe_phead;\r\nstruct xmit_frame *pxmitframe = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nspin_lock_bh(&psta->sleep_q.lock);\r\nxmitframe_phead = get_list_head(&psta->sleep_q);\r\nxmitframe_plist = xmitframe_phead->next;\r\nwhile (xmitframe_phead != xmitframe_plist) {\r\npxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);\r\nxmitframe_plist = xmitframe_plist->next;\r\nlist_del_init(&pxmitframe->list);\r\nswitch (pxmitframe->attrib.priority) {\r\ncase 1:\r\ncase 2:\r\nwmmps_ac = psta->uapsd_bk & BIT(1);\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nwmmps_ac = psta->uapsd_vi & BIT(1);\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nwmmps_ac = psta->uapsd_vo & BIT(1);\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\nwmmps_ac = psta->uapsd_be & BIT(1);\r\nbreak;\r\n}\r\npsta->sleepq_len--;\r\nif (psta->sleepq_len > 0)\r\npxmitframe->attrib.mdata = 1;\r\nelse\r\npxmitframe->attrib.mdata = 0;\r\nif (wmmps_ac) {\r\npsta->sleepq_ac_len--;\r\nif (psta->sleepq_ac_len > 0) {\r\npxmitframe->attrib.mdata = 1;\r\npxmitframe->attrib.eosp = 0;\r\n} else {\r\npxmitframe->attrib.mdata = 0;\r\npxmitframe->attrib.eosp = 1;\r\n}\r\n}\r\npxmitframe->attrib.triggered = 1;\r\nspin_unlock_bh(&psta->sleep_q.lock);\r\nif (rtw_hal_xmit(padapter, pxmitframe))\r\nrtw_os_xmit_complete(padapter, pxmitframe);\r\nspin_lock_bh(&psta->sleep_q.lock);\r\n}\r\nif (psta->sleepq_len == 0) {\r\npstapriv->tim_bitmap &= ~BIT(psta->aid);\r\nupdate_mask = BIT(0);\r\nif (psta->state&WIFI_SLEEP_STATE)\r\npsta->state ^= WIFI_SLEEP_STATE;\r\nif (psta->state & WIFI_STA_ALIVE_CHK_STATE) {\r\npsta->expire_to = pstapriv->expire_to;\r\npsta->state ^= WIFI_STA_ALIVE_CHK_STATE;\r\n}\r\npstapriv->sta_dz_bitmap &= ~BIT(psta->aid);\r\n}\r\nspin_unlock_bh(&psta->sleep_q.lock);\r\npsta_bmc = rtw_get_bcmc_stainfo(padapter);\r\nif (!psta_bmc)\r\nreturn;\r\nif ((pstapriv->sta_dz_bitmap&0xfffe) == 0x0) {\r\nspin_lock_bh(&psta_bmc->sleep_q.lock);\r\nxmitframe_phead = get_list_head(&psta_bmc->sleep_q);\r\nxmitframe_plist = xmitframe_phead->next;\r\nwhile (xmitframe_phead != xmitframe_plist) {\r\npxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);\r\nxmitframe_plist = xmitframe_plist->next;\r\nlist_del_init(&pxmitframe->list);\r\npsta_bmc->sleepq_len--;\r\nif (psta_bmc->sleepq_len > 0)\r\npxmitframe->attrib.mdata = 1;\r\nelse\r\npxmitframe->attrib.mdata = 0;\r\npxmitframe->attrib.triggered = 1;\r\nspin_unlock_bh(&psta_bmc->sleep_q.lock);\r\nif (rtw_hal_xmit(padapter, pxmitframe))\r\nrtw_os_xmit_complete(padapter, pxmitframe);\r\nspin_lock_bh(&psta_bmc->sleep_q.lock);\r\n}\r\nif (psta_bmc->sleepq_len == 0) {\r\npstapriv->tim_bitmap &= ~BIT(0);\r\npstapriv->sta_dz_bitmap &= ~BIT(0);\r\nupdate_mask |= BIT(1);\r\n}\r\nspin_unlock_bh(&psta_bmc->sleep_q.lock);\r\n}\r\nif (update_mask)\r\nupdate_beacon(padapter, _TIM_IE_, NULL, false);\r\n}\r\nvoid xmit_delivery_enabled_frames(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nu8 wmmps_ac = 0;\r\nstruct list_head *xmitframe_plist, *xmitframe_phead;\r\nstruct xmit_frame *pxmitframe = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nspin_lock_bh(&psta->sleep_q.lock);\r\nxmitframe_phead = get_list_head(&psta->sleep_q);\r\nxmitframe_plist = xmitframe_phead->next;\r\nwhile (xmitframe_phead != xmitframe_plist) {\r\npxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);\r\nxmitframe_plist = xmitframe_plist->next;\r\nswitch (pxmitframe->attrib.priority) {\r\ncase 1:\r\ncase 2:\r\nwmmps_ac = psta->uapsd_bk & BIT(1);\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nwmmps_ac = psta->uapsd_vi & BIT(1);\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nwmmps_ac = psta->uapsd_vo & BIT(1);\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\nwmmps_ac = psta->uapsd_be & BIT(1);\r\nbreak;\r\n}\r\nif (!wmmps_ac)\r\ncontinue;\r\nlist_del_init(&pxmitframe->list);\r\npsta->sleepq_len--;\r\npsta->sleepq_ac_len--;\r\nif (psta->sleepq_ac_len > 0) {\r\npxmitframe->attrib.mdata = 1;\r\npxmitframe->attrib.eosp = 0;\r\n} else {\r\npxmitframe->attrib.mdata = 0;\r\npxmitframe->attrib.eosp = 1;\r\n}\r\npxmitframe->attrib.triggered = 1;\r\nif (rtw_hal_xmit(padapter, pxmitframe) == true)\r\nrtw_os_xmit_complete(padapter, pxmitframe);\r\nif ((psta->sleepq_ac_len == 0) && (!psta->has_legacy_ac) && (wmmps_ac)) {\r\npstapriv->tim_bitmap &= ~BIT(psta->aid);\r\nupdate_beacon(padapter, _TIM_IE_, NULL, false);\r\n}\r\n}\r\nspin_unlock_bh(&psta->sleep_q.lock);\r\n}\r\nvoid rtw_sctx_init(struct submit_ctx *sctx, int timeout_ms)\r\n{\r\nsctx->timeout_ms = timeout_ms;\r\nsctx->submit_time = jiffies;\r\ninit_completion(&sctx->done);\r\nsctx->status = RTW_SCTX_SUBMITTED;\r\n}\r\nint rtw_sctx_wait(struct submit_ctx *sctx)\r\n{\r\nint ret = _FAIL;\r\nunsigned long expire;\r\nint status = 0;\r\nexpire = sctx->timeout_ms ? msecs_to_jiffies(sctx->timeout_ms) : MAX_SCHEDULE_TIMEOUT;\r\nif (!wait_for_completion_timeout(&sctx->done, expire)) {\r\nstatus = RTW_SCTX_DONE_TIMEOUT;\r\nDBG_88E("%s timeout\n", __func__);\r\n} else {\r\nstatus = sctx->status;\r\n}\r\nif (status == RTW_SCTX_DONE_SUCCESS)\r\nret = _SUCCESS;\r\nreturn ret;\r\n}\r\nstatic bool rtw_sctx_chk_waring_status(int status)\r\n{\r\nswitch (status) {\r\ncase RTW_SCTX_DONE_UNKNOWN:\r\ncase RTW_SCTX_DONE_BUF_ALLOC:\r\ncase RTW_SCTX_DONE_BUF_FREE:\r\ncase RTW_SCTX_DONE_DRV_STOP:\r\ncase RTW_SCTX_DONE_DEV_REMOVE:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nvoid rtw_sctx_done_err(struct submit_ctx **sctx, int status)\r\n{\r\nif (*sctx) {\r\nif (rtw_sctx_chk_waring_status(status))\r\nDBG_88E("%s status:%d\n", __func__, status);\r\n(*sctx)->status = status;\r\ncomplete(&((*sctx)->done));\r\n*sctx = NULL;\r\n}\r\n}\r\nint rtw_ack_tx_wait(struct xmit_priv *pxmitpriv, u32 timeout_ms)\r\n{\r\nstruct submit_ctx *pack_tx_ops = &pxmitpriv->ack_tx_ops;\r\npack_tx_ops->submit_time = jiffies;\r\npack_tx_ops->timeout_ms = timeout_ms;\r\npack_tx_ops->status = RTW_SCTX_SUBMITTED;\r\nreturn rtw_sctx_wait(pack_tx_ops);\r\n}\r\nvoid rtw_ack_tx_done(struct xmit_priv *pxmitpriv, int status)\r\n{\r\nstruct submit_ctx *pack_tx_ops = &pxmitpriv->ack_tx_ops;\r\nif (pxmitpriv->ack_tx)\r\nrtw_sctx_done_err(&pack_tx_ops, status);\r\nelse\r\nDBG_88E("%s ack_tx not set\n", __func__);\r\n}
