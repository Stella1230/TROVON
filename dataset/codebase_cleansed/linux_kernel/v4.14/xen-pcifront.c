static inline struct pcifront_device *\r\npcifront_get_pdev(struct pcifront_sd *sd)\r\n{\r\nreturn sd->pdev;\r\n}\r\nstatic inline void pcifront_init_sd(struct pcifront_sd *sd,\r\nunsigned int domain, unsigned int bus,\r\nstruct pcifront_device *pdev)\r\n{\r\nsd->sd.node = first_online_node;\r\nsd->sd.domain = domain;\r\nsd->pdev = pdev;\r\n}\r\nstatic int errno_to_pcibios_err(int errno)\r\n{\r\nswitch (errno) {\r\ncase XEN_PCI_ERR_success:\r\nreturn PCIBIOS_SUCCESSFUL;\r\ncase XEN_PCI_ERR_dev_not_found:\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\ncase XEN_PCI_ERR_invalid_offset:\r\ncase XEN_PCI_ERR_op_failed:\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\ncase XEN_PCI_ERR_not_implemented:\r\nreturn PCIBIOS_FUNC_NOT_SUPPORTED;\r\ncase XEN_PCI_ERR_access_denied:\r\nreturn PCIBIOS_SET_FAILED;\r\n}\r\nreturn errno;\r\n}\r\nstatic inline void schedule_pcifront_aer_op(struct pcifront_device *pdev)\r\n{\r\nif (test_bit(_XEN_PCIB_active, (unsigned long *)&pdev->sh_info->flags)\r\n&& !test_and_set_bit(_PDEVB_op_active, &pdev->flags)) {\r\ndev_dbg(&pdev->xdev->dev, "schedule aer frontend job\n");\r\nschedule_work(&pdev->op_work);\r\n}\r\n}\r\nstatic int do_pci_op(struct pcifront_device *pdev, struct xen_pci_op *op)\r\n{\r\nint err = 0;\r\nstruct xen_pci_op *active_op = &pdev->sh_info->op;\r\nunsigned long irq_flags;\r\nevtchn_port_t port = pdev->evtchn;\r\nunsigned irq = pdev->irq;\r\ns64 ns, ns_timeout;\r\nspin_lock_irqsave(&pdev->sh_info_lock, irq_flags);\r\nmemcpy(active_op, op, sizeof(struct xen_pci_op));\r\nwmb();\r\nset_bit(_XEN_PCIF_active, (unsigned long *)&pdev->sh_info->flags);\r\nnotify_remote_via_evtchn(port);\r\nns_timeout = ktime_get_ns() + 2 * (s64)NSEC_PER_SEC;\r\nxen_clear_irq_pending(irq);\r\nwhile (test_bit(_XEN_PCIF_active,\r\n(unsigned long *)&pdev->sh_info->flags)) {\r\nxen_poll_irq_timeout(irq, jiffies + 3*HZ);\r\nxen_clear_irq_pending(irq);\r\nns = ktime_get_ns();\r\nif (ns > ns_timeout) {\r\ndev_err(&pdev->xdev->dev,\r\n"pciback not responding!!!\n");\r\nclear_bit(_XEN_PCIF_active,\r\n(unsigned long *)&pdev->sh_info->flags);\r\nerr = XEN_PCI_ERR_dev_not_found;\r\ngoto out;\r\n}\r\n}\r\nif (test_bit(_XEN_PCIB_active,\r\n(unsigned long *)&pdev->sh_info->flags)) {\r\ndev_err(&pdev->xdev->dev,\r\n"schedule aer pcifront service\n");\r\nschedule_pcifront_aer_op(pdev);\r\n}\r\nmemcpy(op, active_op, sizeof(struct xen_pci_op));\r\nerr = op->err;\r\nout:\r\nspin_unlock_irqrestore(&pdev->sh_info_lock, irq_flags);\r\nreturn err;\r\n}\r\nstatic int pcifront_bus_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nint err = 0;\r\nstruct xen_pci_op op = {\r\n.cmd = XEN_PCI_OP_conf_read,\r\n.domain = pci_domain_nr(bus),\r\n.bus = bus->number,\r\n.devfn = devfn,\r\n.offset = where,\r\n.size = size,\r\n};\r\nstruct pcifront_sd *sd = bus->sysdata;\r\nstruct pcifront_device *pdev = pcifront_get_pdev(sd);\r\nif (verbose_request)\r\ndev_info(&pdev->xdev->dev,\r\n"read dev=%04x:%02x:%02x.%d - offset %x size %d\n",\r\npci_domain_nr(bus), bus->number, PCI_SLOT(devfn),\r\nPCI_FUNC(devfn), where, size);\r\nerr = do_pci_op(pdev, &op);\r\nif (likely(!err)) {\r\nif (verbose_request)\r\ndev_info(&pdev->xdev->dev, "read got back value %x\n",\r\nop.value);\r\n*val = op.value;\r\n} else if (err == -ENODEV) {\r\nerr = 0;\r\n*val = 0;\r\n}\r\nreturn errno_to_pcibios_err(err);\r\n}\r\nstatic int pcifront_bus_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nstruct xen_pci_op op = {\r\n.cmd = XEN_PCI_OP_conf_write,\r\n.domain = pci_domain_nr(bus),\r\n.bus = bus->number,\r\n.devfn = devfn,\r\n.offset = where,\r\n.size = size,\r\n.value = val,\r\n};\r\nstruct pcifront_sd *sd = bus->sysdata;\r\nstruct pcifront_device *pdev = pcifront_get_pdev(sd);\r\nif (verbose_request)\r\ndev_info(&pdev->xdev->dev,\r\n"write dev=%04x:%02x:%02x.%d - "\r\n"offset %x size %d val %x\n",\r\npci_domain_nr(bus), bus->number,\r\nPCI_SLOT(devfn), PCI_FUNC(devfn), where, size, val);\r\nreturn errno_to_pcibios_err(do_pci_op(pdev, &op));\r\n}\r\nstatic int pci_frontend_enable_msix(struct pci_dev *dev,\r\nint vector[], int nvec)\r\n{\r\nint err;\r\nint i;\r\nstruct xen_pci_op op = {\r\n.cmd = XEN_PCI_OP_enable_msix,\r\n.domain = pci_domain_nr(dev->bus),\r\n.bus = dev->bus->number,\r\n.devfn = dev->devfn,\r\n.value = nvec,\r\n};\r\nstruct pcifront_sd *sd = dev->bus->sysdata;\r\nstruct pcifront_device *pdev = pcifront_get_pdev(sd);\r\nstruct msi_desc *entry;\r\nif (nvec > SH_INFO_MAX_VEC) {\r\ndev_err(&dev->dev, "too much vector for pci frontend: %x."\r\n" Increase SH_INFO_MAX_VEC.\n", nvec);\r\nreturn -EINVAL;\r\n}\r\ni = 0;\r\nfor_each_pci_msi_entry(entry, dev) {\r\nop.msix_entries[i].entry = entry->msi_attrib.entry_nr;\r\nop.msix_entries[i].vector = -1;\r\ni++;\r\n}\r\nerr = do_pci_op(pdev, &op);\r\nif (likely(!err)) {\r\nif (likely(!op.value)) {\r\nfor (i = 0; i < nvec; i++) {\r\nif (op.msix_entries[i].vector <= 0) {\r\ndev_warn(&dev->dev, "MSI-X entry %d is invalid: %d!\n",\r\ni, op.msix_entries[i].vector);\r\nerr = -EINVAL;\r\nvector[i] = -1;\r\ncontinue;\r\n}\r\nvector[i] = op.msix_entries[i].vector;\r\n}\r\n} else {\r\nprintk(KERN_DEBUG "enable msix get value %x\n",\r\nop.value);\r\nerr = op.value;\r\n}\r\n} else {\r\ndev_err(&dev->dev, "enable msix get err %x\n", err);\r\n}\r\nreturn err;\r\n}\r\nstatic void pci_frontend_disable_msix(struct pci_dev *dev)\r\n{\r\nint err;\r\nstruct xen_pci_op op = {\r\n.cmd = XEN_PCI_OP_disable_msix,\r\n.domain = pci_domain_nr(dev->bus),\r\n.bus = dev->bus->number,\r\n.devfn = dev->devfn,\r\n};\r\nstruct pcifront_sd *sd = dev->bus->sysdata;\r\nstruct pcifront_device *pdev = pcifront_get_pdev(sd);\r\nerr = do_pci_op(pdev, &op);\r\nif (err)\r\ndev_err(&dev->dev, "pci_disable_msix get err %x\n", err);\r\n}\r\nstatic int pci_frontend_enable_msi(struct pci_dev *dev, int vector[])\r\n{\r\nint err;\r\nstruct xen_pci_op op = {\r\n.cmd = XEN_PCI_OP_enable_msi,\r\n.domain = pci_domain_nr(dev->bus),\r\n.bus = dev->bus->number,\r\n.devfn = dev->devfn,\r\n};\r\nstruct pcifront_sd *sd = dev->bus->sysdata;\r\nstruct pcifront_device *pdev = pcifront_get_pdev(sd);\r\nerr = do_pci_op(pdev, &op);\r\nif (likely(!err)) {\r\nvector[0] = op.value;\r\nif (op.value <= 0) {\r\ndev_warn(&dev->dev, "MSI entry is invalid: %d!\n",\r\nop.value);\r\nerr = -EINVAL;\r\nvector[0] = -1;\r\n}\r\n} else {\r\ndev_err(&dev->dev, "pci frontend enable msi failed for dev "\r\n"%x:%x\n", op.bus, op.devfn);\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic void pci_frontend_disable_msi(struct pci_dev *dev)\r\n{\r\nint err;\r\nstruct xen_pci_op op = {\r\n.cmd = XEN_PCI_OP_disable_msi,\r\n.domain = pci_domain_nr(dev->bus),\r\n.bus = dev->bus->number,\r\n.devfn = dev->devfn,\r\n};\r\nstruct pcifront_sd *sd = dev->bus->sysdata;\r\nstruct pcifront_device *pdev = pcifront_get_pdev(sd);\r\nerr = do_pci_op(pdev, &op);\r\nif (err == XEN_PCI_ERR_dev_not_found) {\r\nprintk(KERN_DEBUG "get no response from backend for disable MSI\n");\r\nreturn;\r\n}\r\nif (err)\r\nprintk(KERN_DEBUG "get fake response frombackend\n");\r\n}\r\nstatic void pci_frontend_registrar(int enable)\r\n{\r\nif (enable)\r\nxen_pci_frontend = &pci_frontend_ops;\r\nelse\r\nxen_pci_frontend = NULL;\r\n}\r\nstatic inline void pci_frontend_registrar(int enable) { }\r\nstatic int pcifront_claim_resource(struct pci_dev *dev, void *data)\r\n{\r\nstruct pcifront_device *pdev = data;\r\nint i;\r\nstruct resource *r;\r\nfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\r\nr = &dev->resource[i];\r\nif (!r->parent && r->start && r->flags) {\r\ndev_info(&pdev->xdev->dev, "claiming resource %s/%d\n",\r\npci_name(dev), i);\r\nif (pci_claim_resource(dev, i)) {\r\ndev_err(&pdev->xdev->dev, "Could not claim resource %s/%d! "\r\n"Device offline. Try using e820_host=1 in the guest config.\n",\r\npci_name(dev), i);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcifront_scan_bus(struct pcifront_device *pdev,\r\nunsigned int domain, unsigned int bus,\r\nstruct pci_bus *b)\r\n{\r\nstruct pci_dev *d;\r\nunsigned int devfn;\r\nfor (devfn = 0; devfn < 0x100; devfn++) {\r\nd = pci_get_slot(b, devfn);\r\nif (d) {\r\npci_dev_put(d);\r\ncontinue;\r\n}\r\nd = pci_scan_single_device(b, devfn);\r\nif (d)\r\ndev_info(&pdev->xdev->dev, "New device on "\r\n"%04x:%02x:%02x.%d found.\n", domain, bus,\r\nPCI_SLOT(devfn), PCI_FUNC(devfn));\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcifront_scan_root(struct pcifront_device *pdev,\r\nunsigned int domain, unsigned int bus)\r\n{\r\nstruct pci_bus *b;\r\nLIST_HEAD(resources);\r\nstruct pcifront_sd *sd = NULL;\r\nstruct pci_bus_entry *bus_entry = NULL;\r\nint err = 0;\r\nstatic struct resource busn_res = {\r\n.start = 0,\r\n.end = 255,\r\n.flags = IORESOURCE_BUS,\r\n};\r\n#ifndef CONFIG_PCI_DOMAINS\r\nif (domain != 0) {\r\ndev_err(&pdev->xdev->dev,\r\n"PCI Root in non-zero PCI Domain! domain=%d\n", domain);\r\ndev_err(&pdev->xdev->dev,\r\n"Please compile with CONFIG_PCI_DOMAINS\n");\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\n#endif\r\ndev_info(&pdev->xdev->dev, "Creating PCI Frontend Bus %04x:%02x\n",\r\ndomain, bus);\r\nbus_entry = kzalloc(sizeof(*bus_entry), GFP_KERNEL);\r\nsd = kzalloc(sizeof(*sd), GFP_KERNEL);\r\nif (!bus_entry || !sd) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\npci_add_resource(&resources, &ioport_resource);\r\npci_add_resource(&resources, &iomem_resource);\r\npci_add_resource(&resources, &busn_res);\r\npcifront_init_sd(sd, domain, bus, pdev);\r\npci_lock_rescan_remove();\r\nb = pci_scan_root_bus(&pdev->xdev->dev, bus,\r\n&pcifront_bus_ops, sd, &resources);\r\nif (!b) {\r\ndev_err(&pdev->xdev->dev,\r\n"Error creating PCI Frontend Bus!\n");\r\nerr = -ENOMEM;\r\npci_unlock_rescan_remove();\r\npci_free_resource_list(&resources);\r\ngoto err_out;\r\n}\r\nbus_entry->bus = b;\r\nlist_add(&bus_entry->list, &pdev->root_buses);\r\nerr = pcifront_scan_bus(pdev, domain, bus, b);\r\npci_walk_bus(b, pcifront_claim_resource, pdev);\r\npci_bus_add_devices(b);\r\npci_unlock_rescan_remove();\r\nreturn err;\r\nerr_out:\r\nkfree(bus_entry);\r\nkfree(sd);\r\nreturn err;\r\n}\r\nstatic int pcifront_rescan_root(struct pcifront_device *pdev,\r\nunsigned int domain, unsigned int bus)\r\n{\r\nint err;\r\nstruct pci_bus *b;\r\n#ifndef CONFIG_PCI_DOMAINS\r\nif (domain != 0) {\r\ndev_err(&pdev->xdev->dev,\r\n"PCI Root in non-zero PCI Domain! domain=%d\n", domain);\r\ndev_err(&pdev->xdev->dev,\r\n"Please compile with CONFIG_PCI_DOMAINS\n");\r\nreturn -EINVAL;\r\n}\r\n#endif\r\ndev_info(&pdev->xdev->dev, "Rescanning PCI Frontend Bus %04x:%02x\n",\r\ndomain, bus);\r\nb = pci_find_bus(domain, bus);\r\nif (!b)\r\nreturn pcifront_scan_root(pdev, domain, bus);\r\nerr = pcifront_scan_bus(pdev, domain, bus, b);\r\npci_walk_bus(b, pcifront_claim_resource, pdev);\r\npci_bus_add_devices(b);\r\nreturn err;\r\n}\r\nstatic void free_root_bus_devs(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nwhile (!list_empty(&bus->devices)) {\r\ndev = container_of(bus->devices.next, struct pci_dev,\r\nbus_list);\r\ndev_dbg(&dev->dev, "removing device\n");\r\npci_stop_and_remove_bus_device(dev);\r\n}\r\n}\r\nstatic void pcifront_free_roots(struct pcifront_device *pdev)\r\n{\r\nstruct pci_bus_entry *bus_entry, *t;\r\ndev_dbg(&pdev->xdev->dev, "cleaning up root buses\n");\r\npci_lock_rescan_remove();\r\nlist_for_each_entry_safe(bus_entry, t, &pdev->root_buses, list) {\r\nlist_del(&bus_entry->list);\r\nfree_root_bus_devs(bus_entry->bus);\r\nkfree(bus_entry->bus->sysdata);\r\ndevice_unregister(bus_entry->bus->bridge);\r\npci_remove_bus(bus_entry->bus);\r\nkfree(bus_entry);\r\n}\r\npci_unlock_rescan_remove();\r\n}\r\nstatic pci_ers_result_t pcifront_common_process(int cmd,\r\nstruct pcifront_device *pdev,\r\npci_channel_state_t state)\r\n{\r\npci_ers_result_t result;\r\nstruct pci_driver *pdrv;\r\nint bus = pdev->sh_info->aer_op.bus;\r\nint devfn = pdev->sh_info->aer_op.devfn;\r\nstruct pci_dev *pcidev;\r\nint flag = 0;\r\ndev_dbg(&pdev->xdev->dev,\r\n"pcifront AER process: cmd %x (bus:%x, devfn%x)",\r\ncmd, bus, devfn);\r\nresult = PCI_ERS_RESULT_NONE;\r\npcidev = pci_get_bus_and_slot(bus, devfn);\r\nif (!pcidev || !pcidev->driver) {\r\ndev_err(&pdev->xdev->dev, "device or AER driver is NULL\n");\r\npci_dev_put(pcidev);\r\nreturn result;\r\n}\r\npdrv = pcidev->driver;\r\nif (pdrv) {\r\nif (pdrv->err_handler && pdrv->err_handler->error_detected) {\r\ndev_dbg(&pcidev->dev,\r\n"trying to call AER service\n");\r\nif (pcidev) {\r\nflag = 1;\r\nswitch (cmd) {\r\ncase XEN_PCI_OP_aer_detected:\r\nresult = pdrv->err_handler->\r\nerror_detected(pcidev, state);\r\nbreak;\r\ncase XEN_PCI_OP_aer_mmio:\r\nresult = pdrv->err_handler->\r\nmmio_enabled(pcidev);\r\nbreak;\r\ncase XEN_PCI_OP_aer_slotreset:\r\nresult = pdrv->err_handler->\r\nslot_reset(pcidev);\r\nbreak;\r\ncase XEN_PCI_OP_aer_resume:\r\npdrv->err_handler->resume(pcidev);\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->xdev->dev,\r\n"bad request in aer recovery "\r\n"operation!\n");\r\n}\r\n}\r\n}\r\n}\r\nif (!flag)\r\nresult = PCI_ERS_RESULT_NONE;\r\nreturn result;\r\n}\r\nstatic void pcifront_do_aer(struct work_struct *data)\r\n{\r\nstruct pcifront_device *pdev =\r\ncontainer_of(data, struct pcifront_device, op_work);\r\nint cmd = pdev->sh_info->aer_op.cmd;\r\npci_channel_state_t state =\r\n(pci_channel_state_t)pdev->sh_info->aer_op.err;\r\ndev_dbg(&pdev->xdev->dev,\r\n"pcifront service aer bus %x devfn %x\n",\r\npdev->sh_info->aer_op.bus, pdev->sh_info->aer_op.devfn);\r\npdev->sh_info->aer_op.err = pcifront_common_process(cmd, pdev, state);\r\nwmb();\r\nclear_bit(_XEN_PCIB_active, (unsigned long *)&pdev->sh_info->flags);\r\nnotify_remote_via_evtchn(pdev->evtchn);\r\nsmp_mb__before_atomic();\r\nclear_bit(_PDEVB_op_active, &pdev->flags);\r\nsmp_mb__after_atomic();\r\nschedule_pcifront_aer_op(pdev);\r\n}\r\nstatic irqreturn_t pcifront_handler_aer(int irq, void *dev)\r\n{\r\nstruct pcifront_device *pdev = dev;\r\nschedule_pcifront_aer_op(pdev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pcifront_connect_and_init_dma(struct pcifront_device *pdev)\r\n{\r\nint err = 0;\r\nspin_lock(&pcifront_dev_lock);\r\nif (!pcifront_dev) {\r\ndev_info(&pdev->xdev->dev, "Installing PCI frontend\n");\r\npcifront_dev = pdev;\r\n} else\r\nerr = -EEXIST;\r\nspin_unlock(&pcifront_dev_lock);\r\nif (!err && !swiotlb_nr_tbl()) {\r\nerr = pci_xen_swiotlb_init_late();\r\nif (err)\r\ndev_err(&pdev->xdev->dev, "Could not setup SWIOTLB!\n");\r\n}\r\nreturn err;\r\n}\r\nstatic void pcifront_disconnect(struct pcifront_device *pdev)\r\n{\r\nspin_lock(&pcifront_dev_lock);\r\nif (pdev == pcifront_dev) {\r\ndev_info(&pdev->xdev->dev,\r\n"Disconnecting PCI Frontend Buses\n");\r\npcifront_dev = NULL;\r\n}\r\nspin_unlock(&pcifront_dev_lock);\r\n}\r\nstatic struct pcifront_device *alloc_pdev(struct xenbus_device *xdev)\r\n{\r\nstruct pcifront_device *pdev;\r\npdev = kzalloc(sizeof(struct pcifront_device), GFP_KERNEL);\r\nif (pdev == NULL)\r\ngoto out;\r\npdev->sh_info =\r\n(struct xen_pci_sharedinfo *)__get_free_page(GFP_KERNEL);\r\nif (pdev->sh_info == NULL) {\r\nkfree(pdev);\r\npdev = NULL;\r\ngoto out;\r\n}\r\npdev->sh_info->flags = 0;\r\nset_bit(_XEN_PCIB_AERHANDLER, (void *)&pdev->sh_info->flags);\r\ndev_set_drvdata(&xdev->dev, pdev);\r\npdev->xdev = xdev;\r\nINIT_LIST_HEAD(&pdev->root_buses);\r\nspin_lock_init(&pdev->sh_info_lock);\r\npdev->evtchn = INVALID_EVTCHN;\r\npdev->gnt_ref = INVALID_GRANT_REF;\r\npdev->irq = -1;\r\nINIT_WORK(&pdev->op_work, pcifront_do_aer);\r\ndev_dbg(&xdev->dev, "Allocated pdev @ 0x%p pdev->sh_info @ 0x%p\n",\r\npdev, pdev->sh_info);\r\nout:\r\nreturn pdev;\r\n}\r\nstatic void free_pdev(struct pcifront_device *pdev)\r\n{\r\ndev_dbg(&pdev->xdev->dev, "freeing pdev @ 0x%p\n", pdev);\r\npcifront_free_roots(pdev);\r\ncancel_work_sync(&pdev->op_work);\r\nif (pdev->irq >= 0)\r\nunbind_from_irqhandler(pdev->irq, pdev);\r\nif (pdev->evtchn != INVALID_EVTCHN)\r\nxenbus_free_evtchn(pdev->xdev, pdev->evtchn);\r\nif (pdev->gnt_ref != INVALID_GRANT_REF)\r\ngnttab_end_foreign_access(pdev->gnt_ref, 0 ,\r\n(unsigned long)pdev->sh_info);\r\nelse\r\nfree_page((unsigned long)pdev->sh_info);\r\ndev_set_drvdata(&pdev->xdev->dev, NULL);\r\nkfree(pdev);\r\n}\r\nstatic int pcifront_publish_info(struct pcifront_device *pdev)\r\n{\r\nint err = 0;\r\nstruct xenbus_transaction trans;\r\ngrant_ref_t gref;\r\nerr = xenbus_grant_ring(pdev->xdev, pdev->sh_info, 1, &gref);\r\nif (err < 0)\r\ngoto out;\r\npdev->gnt_ref = gref;\r\nerr = xenbus_alloc_evtchn(pdev->xdev, &pdev->evtchn);\r\nif (err)\r\ngoto out;\r\nerr = bind_evtchn_to_irqhandler(pdev->evtchn, pcifront_handler_aer,\r\n0, "pcifront", pdev);\r\nif (err < 0)\r\nreturn err;\r\npdev->irq = err;\r\ndo_publish:\r\nerr = xenbus_transaction_start(&trans);\r\nif (err) {\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Error writing configuration for backend "\r\n"(start transaction)");\r\ngoto out;\r\n}\r\nerr = xenbus_printf(trans, pdev->xdev->nodename,\r\n"pci-op-ref", "%u", pdev->gnt_ref);\r\nif (!err)\r\nerr = xenbus_printf(trans, pdev->xdev->nodename,\r\n"event-channel", "%u", pdev->evtchn);\r\nif (!err)\r\nerr = xenbus_printf(trans, pdev->xdev->nodename,\r\n"magic", XEN_PCI_MAGIC);\r\nif (err) {\r\nxenbus_transaction_end(trans, 1);\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Error writing configuration for backend");\r\ngoto out;\r\n} else {\r\nerr = xenbus_transaction_end(trans, 0);\r\nif (err == -EAGAIN)\r\ngoto do_publish;\r\nelse if (err) {\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Error completing transaction "\r\n"for backend");\r\ngoto out;\r\n}\r\n}\r\nxenbus_switch_state(pdev->xdev, XenbusStateInitialised);\r\ndev_dbg(&pdev->xdev->dev, "publishing successful!\n");\r\nout:\r\nreturn err;\r\n}\r\nstatic int pcifront_try_connect(struct pcifront_device *pdev)\r\n{\r\nint err = -EFAULT;\r\nint i, num_roots, len;\r\nchar str[64];\r\nunsigned int domain, bus;\r\nif (xenbus_read_driver_state(pdev->xdev->nodename) !=\r\nXenbusStateInitialised)\r\ngoto out;\r\nerr = pcifront_connect_and_init_dma(pdev);\r\nif (err && err != -EEXIST) {\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Error setting up PCI Frontend");\r\ngoto out;\r\n}\r\nerr = xenbus_scanf(XBT_NIL, pdev->xdev->otherend,\r\n"root_num", "%d", &num_roots);\r\nif (err == -ENOENT) {\r\nxenbus_dev_error(pdev->xdev, err,\r\n"No PCI Roots found, trying 0000:00");\r\nerr = pcifront_scan_root(pdev, 0, 0);\r\nif (err) {\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Error scanning PCI root 0000:00");\r\ngoto out;\r\n}\r\nnum_roots = 0;\r\n} else if (err != 1) {\r\nif (err == 0)\r\nerr = -EINVAL;\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Error reading number of PCI roots");\r\ngoto out;\r\n}\r\nfor (i = 0; i < num_roots; i++) {\r\nlen = snprintf(str, sizeof(str), "root-%d", i);\r\nif (unlikely(len >= (sizeof(str) - 1))) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = xenbus_scanf(XBT_NIL, pdev->xdev->otherend, str,\r\n"%x:%x", &domain, &bus);\r\nif (err != 2) {\r\nif (err >= 0)\r\nerr = -EINVAL;\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Error reading PCI root %d", i);\r\ngoto out;\r\n}\r\nerr = pcifront_scan_root(pdev, domain, bus);\r\nif (err) {\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Error scanning PCI root %04x:%02x",\r\ndomain, bus);\r\ngoto out;\r\n}\r\n}\r\nerr = xenbus_switch_state(pdev->xdev, XenbusStateConnected);\r\nout:\r\nreturn err;\r\n}\r\nstatic int pcifront_try_disconnect(struct pcifront_device *pdev)\r\n{\r\nint err = 0;\r\nenum xenbus_state prev_state;\r\nprev_state = xenbus_read_driver_state(pdev->xdev->nodename);\r\nif (prev_state >= XenbusStateClosing)\r\ngoto out;\r\nif (prev_state == XenbusStateConnected) {\r\npcifront_free_roots(pdev);\r\npcifront_disconnect(pdev);\r\n}\r\nerr = xenbus_switch_state(pdev->xdev, XenbusStateClosed);\r\nout:\r\nreturn err;\r\n}\r\nstatic int pcifront_attach_devices(struct pcifront_device *pdev)\r\n{\r\nint err = -EFAULT;\r\nint i, num_roots, len;\r\nunsigned int domain, bus;\r\nchar str[64];\r\nif (xenbus_read_driver_state(pdev->xdev->nodename) !=\r\nXenbusStateReconfiguring)\r\ngoto out;\r\nerr = xenbus_scanf(XBT_NIL, pdev->xdev->otherend,\r\n"root_num", "%d", &num_roots);\r\nif (err == -ENOENT) {\r\nxenbus_dev_error(pdev->xdev, err,\r\n"No PCI Roots found, trying 0000:00");\r\nerr = pcifront_rescan_root(pdev, 0, 0);\r\nif (err) {\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Error scanning PCI root 0000:00");\r\ngoto out;\r\n}\r\nnum_roots = 0;\r\n} else if (err != 1) {\r\nif (err == 0)\r\nerr = -EINVAL;\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Error reading number of PCI roots");\r\ngoto out;\r\n}\r\nfor (i = 0; i < num_roots; i++) {\r\nlen = snprintf(str, sizeof(str), "root-%d", i);\r\nif (unlikely(len >= (sizeof(str) - 1))) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = xenbus_scanf(XBT_NIL, pdev->xdev->otherend, str,\r\n"%x:%x", &domain, &bus);\r\nif (err != 2) {\r\nif (err >= 0)\r\nerr = -EINVAL;\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Error reading PCI root %d", i);\r\ngoto out;\r\n}\r\nerr = pcifront_rescan_root(pdev, domain, bus);\r\nif (err) {\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Error scanning PCI root %04x:%02x",\r\ndomain, bus);\r\ngoto out;\r\n}\r\n}\r\nxenbus_switch_state(pdev->xdev, XenbusStateConnected);\r\nout:\r\nreturn err;\r\n}\r\nstatic int pcifront_detach_devices(struct pcifront_device *pdev)\r\n{\r\nint err = 0;\r\nint i, num_devs;\r\nunsigned int domain, bus, slot, func;\r\nstruct pci_dev *pci_dev;\r\nchar str[64];\r\nif (xenbus_read_driver_state(pdev->xdev->nodename) !=\r\nXenbusStateConnected)\r\ngoto out;\r\nerr = xenbus_scanf(XBT_NIL, pdev->xdev->otherend, "num_devs", "%d",\r\n&num_devs);\r\nif (err != 1) {\r\nif (err >= 0)\r\nerr = -EINVAL;\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Error reading number of PCI devices");\r\ngoto out;\r\n}\r\nfor (i = 0; i < num_devs; i++) {\r\nint l, state;\r\nl = snprintf(str, sizeof(str), "state-%d", i);\r\nif (unlikely(l >= (sizeof(str) - 1))) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nstate = xenbus_read_unsigned(pdev->xdev->otherend, str,\r\nXenbusStateUnknown);\r\nif (state != XenbusStateClosing)\r\ncontinue;\r\nl = snprintf(str, sizeof(str), "vdev-%d", i);\r\nif (unlikely(l >= (sizeof(str) - 1))) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = xenbus_scanf(XBT_NIL, pdev->xdev->otherend, str,\r\n"%x:%x:%x.%x", &domain, &bus, &slot, &func);\r\nif (err != 4) {\r\nif (err >= 0)\r\nerr = -EINVAL;\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Error reading PCI device %d", i);\r\ngoto out;\r\n}\r\npci_dev = pci_get_domain_bus_and_slot(domain, bus,\r\nPCI_DEVFN(slot, func));\r\nif (!pci_dev) {\r\ndev_dbg(&pdev->xdev->dev,\r\n"Cannot get PCI device %04x:%02x:%02x.%d\n",\r\ndomain, bus, slot, func);\r\ncontinue;\r\n}\r\npci_lock_rescan_remove();\r\npci_stop_and_remove_bus_device(pci_dev);\r\npci_dev_put(pci_dev);\r\npci_unlock_rescan_remove();\r\ndev_dbg(&pdev->xdev->dev,\r\n"PCI device %04x:%02x:%02x.%d removed.\n",\r\ndomain, bus, slot, func);\r\n}\r\nerr = xenbus_switch_state(pdev->xdev, XenbusStateReconfiguring);\r\nout:\r\nreturn err;\r\n}\r\nstatic void __ref pcifront_backend_changed(struct xenbus_device *xdev,\r\nenum xenbus_state be_state)\r\n{\r\nstruct pcifront_device *pdev = dev_get_drvdata(&xdev->dev);\r\nswitch (be_state) {\r\ncase XenbusStateUnknown:\r\ncase XenbusStateInitialising:\r\ncase XenbusStateInitWait:\r\ncase XenbusStateInitialised:\r\nbreak;\r\ncase XenbusStateConnected:\r\npcifront_try_connect(pdev);\r\nbreak;\r\ncase XenbusStateClosed:\r\nif (xdev->state == XenbusStateClosed)\r\nbreak;\r\ncase XenbusStateClosing:\r\ndev_warn(&xdev->dev, "backend going away!\n");\r\npcifront_try_disconnect(pdev);\r\nbreak;\r\ncase XenbusStateReconfiguring:\r\npcifront_detach_devices(pdev);\r\nbreak;\r\ncase XenbusStateReconfigured:\r\npcifront_attach_devices(pdev);\r\nbreak;\r\n}\r\n}\r\nstatic int pcifront_xenbus_probe(struct xenbus_device *xdev,\r\nconst struct xenbus_device_id *id)\r\n{\r\nint err = 0;\r\nstruct pcifront_device *pdev = alloc_pdev(xdev);\r\nif (pdev == NULL) {\r\nerr = -ENOMEM;\r\nxenbus_dev_fatal(xdev, err,\r\n"Error allocating pcifront_device struct");\r\ngoto out;\r\n}\r\nerr = pcifront_publish_info(pdev);\r\nif (err)\r\nfree_pdev(pdev);\r\nout:\r\nreturn err;\r\n}\r\nstatic int pcifront_xenbus_remove(struct xenbus_device *xdev)\r\n{\r\nstruct pcifront_device *pdev = dev_get_drvdata(&xdev->dev);\r\nif (pdev)\r\nfree_pdev(pdev);\r\nreturn 0;\r\n}\r\nstatic int __init pcifront_init(void)\r\n{\r\nif (!xen_pv_domain() || xen_initial_domain())\r\nreturn -ENODEV;\r\nif (!xen_has_pv_devices())\r\nreturn -ENODEV;\r\npci_frontend_registrar(1 );\r\nreturn xenbus_register_frontend(&xenpci_driver);\r\n}\r\nstatic void __exit pcifront_cleanup(void)\r\n{\r\nxenbus_unregister_driver(&xenpci_driver);\r\npci_frontend_registrar(0 );\r\n}
