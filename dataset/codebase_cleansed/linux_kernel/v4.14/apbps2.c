static irqreturn_t apbps2_isr(int irq, void *dev_id)\r\n{\r\nstruct apbps2_priv *priv = dev_id;\r\nunsigned long status, data, rxflags;\r\nirqreturn_t ret = IRQ_NONE;\r\nwhile ((status = ioread32be(&priv->regs->status)) & APBPS2_STATUS_DR) {\r\ndata = ioread32be(&priv->regs->data);\r\nrxflags = (status & APBPS2_STATUS_PE) ? SERIO_PARITY : 0;\r\nrxflags |= (status & APBPS2_STATUS_FE) ? SERIO_FRAME : 0;\r\nif (rxflags)\r\niowrite32be(0, &priv->regs->status);\r\nserio_interrupt(priv->io, data, rxflags);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic int apbps2_write(struct serio *io, unsigned char val)\r\n{\r\nstruct apbps2_priv *priv = io->port_data;\r\nunsigned int tleft = 10000;\r\nwhile ((ioread32be(&priv->regs->status) & APBPS2_STATUS_TF) && tleft--)\r\nudelay(10);\r\nif ((ioread32be(&priv->regs->status) & APBPS2_STATUS_TF) == 0) {\r\niowrite32be(val, &priv->regs->data);\r\niowrite32be(APBPS2_CTRL_RE | APBPS2_CTRL_RI | APBPS2_CTRL_TE,\r\n&priv->regs->ctrl);\r\nreturn 0;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int apbps2_open(struct serio *io)\r\n{\r\nstruct apbps2_priv *priv = io->port_data;\r\nint limit;\r\nunsigned long tmp;\r\niowrite32be(0, &priv->regs->status);\r\nlimit = 1024;\r\nwhile ((ioread32be(&priv->regs->status) & APBPS2_STATUS_DR) && --limit)\r\ntmp = ioread32be(&priv->regs->data);\r\niowrite32be(APBPS2_CTRL_RE | APBPS2_CTRL_RI, &priv->regs->ctrl);\r\nreturn 0;\r\n}\r\nstatic void apbps2_close(struct serio *io)\r\n{\r\nstruct apbps2_priv *priv = io->port_data;\r\niowrite32be(0, &priv->regs->ctrl);\r\n}\r\nstatic int apbps2_of_probe(struct platform_device *ofdev)\r\n{\r\nstruct apbps2_priv *priv;\r\nint irq, err;\r\nu32 freq_hz;\r\nstruct resource *res;\r\npriv = devm_kzalloc(&ofdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&ofdev->dev, "memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\r\npriv->regs = devm_ioremap_resource(&ofdev->dev, res);\r\nif (IS_ERR(priv->regs))\r\nreturn PTR_ERR(priv->regs);\r\niowrite32be(0, &priv->regs->ctrl);\r\nirq = irq_of_parse_and_map(ofdev->dev.of_node, 0);\r\nerr = devm_request_irq(&ofdev->dev, irq, apbps2_isr,\r\nIRQF_SHARED, "apbps2", priv);\r\nif (err) {\r\ndev_err(&ofdev->dev, "request IRQ%d failed\n", irq);\r\nreturn err;\r\n}\r\nif (of_property_read_u32(ofdev->dev.of_node, "freq", &freq_hz)) {\r\ndev_err(&ofdev->dev, "unable to get core frequency\n");\r\nreturn -EINVAL;\r\n}\r\niowrite32be(freq_hz / 10000, &priv->regs->reload);\r\npriv->io = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!priv->io)\r\nreturn -ENOMEM;\r\npriv->io->id.type = SERIO_8042;\r\npriv->io->open = apbps2_open;\r\npriv->io->close = apbps2_close;\r\npriv->io->write = apbps2_write;\r\npriv->io->port_data = priv;\r\nstrlcpy(priv->io->name, "APBPS2 PS/2", sizeof(priv->io->name));\r\nsnprintf(priv->io->phys, sizeof(priv->io->phys),\r\n"apbps2_%d", apbps2_idx++);\r\ndev_info(&ofdev->dev, "irq = %d, base = 0x%p\n", irq, priv->regs);\r\nserio_register_port(priv->io);\r\nplatform_set_drvdata(ofdev, priv);\r\nreturn 0;\r\n}\r\nstatic int apbps2_of_remove(struct platform_device *of_dev)\r\n{\r\nstruct apbps2_priv *priv = platform_get_drvdata(of_dev);\r\nserio_unregister_port(priv->io);\r\nreturn 0;\r\n}
