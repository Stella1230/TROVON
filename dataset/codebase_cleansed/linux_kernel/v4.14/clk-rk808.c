static unsigned long rk808_clkout_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn 32768;\r\n}\r\nstatic int rk808_clkout2_enable(struct clk_hw *hw, bool enable)\r\n{\r\nstruct rk808_clkout *rk808_clkout = container_of(hw,\r\nstruct rk808_clkout,\r\nclkout2_hw);\r\nstruct rk808 *rk808 = rk808_clkout->rk808;\r\nreturn regmap_update_bits(rk808->regmap, RK808_CLK32OUT_REG,\r\nCLK32KOUT2_EN, enable ? CLK32KOUT2_EN : 0);\r\n}\r\nstatic int rk808_clkout2_prepare(struct clk_hw *hw)\r\n{\r\nreturn rk808_clkout2_enable(hw, true);\r\n}\r\nstatic void rk808_clkout2_unprepare(struct clk_hw *hw)\r\n{\r\nrk808_clkout2_enable(hw, false);\r\n}\r\nstatic int rk808_clkout2_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct rk808_clkout *rk808_clkout = container_of(hw,\r\nstruct rk808_clkout,\r\nclkout2_hw);\r\nstruct rk808 *rk808 = rk808_clkout->rk808;\r\nuint32_t val;\r\nint ret = regmap_read(rk808->regmap, RK808_CLK32OUT_REG, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn (val & CLK32KOUT2_EN) ? 1 : 0;\r\n}\r\nstatic struct clk_hw *\r\nof_clk_rk808_get(struct of_phandle_args *clkspec, void *data)\r\n{\r\nstruct rk808_clkout *rk808_clkout = data;\r\nunsigned int idx = clkspec->args[0];\r\nif (idx >= 2) {\r\npr_err("%s: invalid index %u\n", __func__, idx);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn idx ? &rk808_clkout->clkout2_hw : &rk808_clkout->clkout1_hw;\r\n}\r\nstatic int rk808_clkout_probe(struct platform_device *pdev)\r\n{\r\nstruct rk808 *rk808 = dev_get_drvdata(pdev->dev.parent);\r\nstruct i2c_client *client = rk808->i2c;\r\nstruct device_node *node = client->dev.of_node;\r\nstruct clk_init_data init = {};\r\nstruct rk808_clkout *rk808_clkout;\r\nint ret;\r\nrk808_clkout = devm_kzalloc(&client->dev,\r\nsizeof(*rk808_clkout), GFP_KERNEL);\r\nif (!rk808_clkout)\r\nreturn -ENOMEM;\r\nrk808_clkout->rk808 = rk808;\r\ninit.parent_names = NULL;\r\ninit.num_parents = 0;\r\ninit.name = "rk808-clkout1";\r\ninit.ops = &rk808_clkout1_ops;\r\nrk808_clkout->clkout1_hw.init = &init;\r\nof_property_read_string_index(node, "clock-output-names",\r\n0, &init.name);\r\nret = devm_clk_hw_register(&client->dev, &rk808_clkout->clkout1_hw);\r\nif (ret)\r\nreturn ret;\r\ninit.name = "rk808-clkout2";\r\ninit.ops = &rk808_clkout2_ops;\r\nrk808_clkout->clkout2_hw.init = &init;\r\nof_property_read_string_index(node, "clock-output-names",\r\n1, &init.name);\r\nret = devm_clk_hw_register(&client->dev, &rk808_clkout->clkout2_hw);\r\nif (ret)\r\nreturn ret;\r\nreturn of_clk_add_hw_provider(node, of_clk_rk808_get, rk808_clkout);\r\n}\r\nstatic int rk808_clkout_remove(struct platform_device *pdev)\r\n{\r\nstruct rk808 *rk808 = dev_get_drvdata(pdev->dev.parent);\r\nstruct i2c_client *client = rk808->i2c;\r\nstruct device_node *node = client->dev.of_node;\r\nof_clk_del_provider(node);\r\nreturn 0;\r\n}
