static int vimc_cap_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct vimc_cap_device *vcap = video_drvdata(file);\r\nstrlcpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, KBUILD_MODNAME, sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info),\r\n"platform:%s", vcap->vdev.v4l2_dev->name);\r\nreturn 0;\r\n}\r\nstatic void vimc_cap_get_format(struct vimc_ent_device *ved,\r\nstruct v4l2_pix_format *fmt)\r\n{\r\nstruct vimc_cap_device *vcap = container_of(ved, struct vimc_cap_device,\r\nved);\r\n*fmt = vcap->format;\r\n}\r\nstatic int vimc_cap_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vimc_cap_device *vcap = video_drvdata(file);\r\nf->fmt.pix = vcap->format;\r\nreturn 0;\r\n}\r\nstatic int vimc_cap_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_pix_format *format = &f->fmt.pix;\r\nconst struct vimc_pix_map *vpix;\r\nformat->width = clamp_t(u32, format->width, VIMC_FRAME_MIN_WIDTH,\r\nVIMC_FRAME_MAX_WIDTH) & ~1;\r\nformat->height = clamp_t(u32, format->height, VIMC_FRAME_MIN_HEIGHT,\r\nVIMC_FRAME_MAX_HEIGHT) & ~1;\r\nvpix = vimc_pix_map_by_pixelformat(format->pixelformat);\r\nif (!vpix) {\r\nformat->pixelformat = fmt_default.pixelformat;\r\nvpix = vimc_pix_map_by_pixelformat(format->pixelformat);\r\n}\r\nformat->bytesperline = format->width * vpix->bpp;\r\nformat->sizeimage = format->bytesperline * format->height;\r\nif (format->field == V4L2_FIELD_ANY)\r\nformat->field = fmt_default.field;\r\nvimc_colorimetry_clamp(format);\r\nreturn 0;\r\n}\r\nstatic int vimc_cap_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vimc_cap_device *vcap = video_drvdata(file);\r\nif (vb2_is_busy(&vcap->queue))\r\nreturn -EBUSY;\r\nvimc_cap_try_fmt_vid_cap(file, priv, f);\r\ndev_dbg(vcap->dev, "%s: format update: "\r\n"old:%dx%d (0x%x, %d, %d, %d, %d) "\r\n"new:%dx%d (0x%x, %d, %d, %d, %d)\n", vcap->vdev.name,\r\nvcap->format.width, vcap->format.height,\r\nvcap->format.pixelformat, vcap->format.colorspace,\r\nvcap->format.quantization, vcap->format.xfer_func,\r\nvcap->format.ycbcr_enc,\r\nf->fmt.pix.width, f->fmt.pix.height,\r\nf->fmt.pix.pixelformat, f->fmt.pix.colorspace,\r\nf->fmt.pix.quantization, f->fmt.pix.xfer_func,\r\nf->fmt.pix.ycbcr_enc);\r\nvcap->format = f->fmt.pix;\r\nreturn 0;\r\n}\r\nstatic int vimc_cap_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nconst struct vimc_pix_map *vpix = vimc_pix_map_by_index(f->index);\r\nif (!vpix)\r\nreturn -EINVAL;\r\nf->pixelformat = vpix->pixelformat;\r\nreturn 0;\r\n}\r\nstatic int vimc_cap_enum_framesizes(struct file *file, void *fh,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nconst struct vimc_pix_map *vpix;\r\nif (fsize->index)\r\nreturn -EINVAL;\r\nvpix = vimc_pix_map_by_code(fsize->pixel_format);\r\nif (!vpix)\r\nreturn -EINVAL;\r\nfsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\r\nfsize->stepwise.min_width = VIMC_FRAME_MIN_WIDTH;\r\nfsize->stepwise.max_width = VIMC_FRAME_MAX_WIDTH;\r\nfsize->stepwise.min_height = VIMC_FRAME_MIN_HEIGHT;\r\nfsize->stepwise.max_height = VIMC_FRAME_MAX_HEIGHT;\r\nfsize->stepwise.step_width = 2;\r\nfsize->stepwise.step_height = 2;\r\nreturn 0;\r\n}\r\nstatic void vimc_cap_return_all_buffers(struct vimc_cap_device *vcap,\r\nenum vb2_buffer_state state)\r\n{\r\nstruct vimc_cap_buffer *vbuf, *node;\r\nspin_lock(&vcap->qlock);\r\nlist_for_each_entry_safe(vbuf, node, &vcap->buf_list, list) {\r\nlist_del(&vbuf->list);\r\nvb2_buffer_done(&vbuf->vb2.vb2_buf, state);\r\n}\r\nspin_unlock(&vcap->qlock);\r\n}\r\nstatic int vimc_cap_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct vimc_cap_device *vcap = vb2_get_drv_priv(vq);\r\nstruct media_entity *entity = &vcap->vdev.entity;\r\nint ret;\r\nvcap->sequence = 0;\r\nret = media_pipeline_start(entity, &vcap->pipe);\r\nif (ret) {\r\nvimc_cap_return_all_buffers(vcap, VB2_BUF_STATE_QUEUED);\r\nreturn ret;\r\n}\r\nret = vimc_pipeline_s_stream(&vcap->vdev.entity, 1);\r\nif (ret) {\r\nmedia_pipeline_stop(entity);\r\nvimc_cap_return_all_buffers(vcap, VB2_BUF_STATE_QUEUED);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vimc_cap_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct vimc_cap_device *vcap = vb2_get_drv_priv(vq);\r\nvimc_pipeline_s_stream(&vcap->vdev.entity, 0);\r\nmedia_pipeline_stop(&vcap->vdev.entity);\r\nvimc_cap_return_all_buffers(vcap, VB2_BUF_STATE_ERROR);\r\n}\r\nstatic void vimc_cap_buf_queue(struct vb2_buffer *vb2_buf)\r\n{\r\nstruct vimc_cap_device *vcap = vb2_get_drv_priv(vb2_buf->vb2_queue);\r\nstruct vimc_cap_buffer *buf = container_of(vb2_buf,\r\nstruct vimc_cap_buffer,\r\nvb2.vb2_buf);\r\nspin_lock(&vcap->qlock);\r\nlist_add_tail(&buf->list, &vcap->buf_list);\r\nspin_unlock(&vcap->qlock);\r\n}\r\nstatic int vimc_cap_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,\r\nunsigned int *nplanes, unsigned int sizes[],\r\nstruct device *alloc_devs[])\r\n{\r\nstruct vimc_cap_device *vcap = vb2_get_drv_priv(vq);\r\nif (*nplanes)\r\nreturn sizes[0] < vcap->format.sizeimage ? -EINVAL : 0;\r\n*nplanes = 1;\r\nsizes[0] = vcap->format.sizeimage;\r\nreturn 0;\r\n}\r\nstatic int vimc_cap_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vimc_cap_device *vcap = vb2_get_drv_priv(vb->vb2_queue);\r\nunsigned long size = vcap->format.sizeimage;\r\nif (vb2_plane_size(vb, 0) < size) {\r\ndev_err(vcap->dev, "%s: buffer too small (%lu < %lu)\n",\r\nvcap->vdev.name, vb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vimc_cap_comp_unbind(struct device *comp, struct device *master,\r\nvoid *master_data)\r\n{\r\nstruct vimc_ent_device *ved = dev_get_drvdata(comp);\r\nstruct vimc_cap_device *vcap = container_of(ved, struct vimc_cap_device,\r\nved);\r\nvb2_queue_release(&vcap->queue);\r\nmedia_entity_cleanup(ved->ent);\r\nvideo_unregister_device(&vcap->vdev);\r\nvimc_pads_cleanup(vcap->ved.pads);\r\nkfree(vcap);\r\n}\r\nstatic void vimc_cap_process_frame(struct vimc_ent_device *ved,\r\nstruct media_pad *sink, const void *frame)\r\n{\r\nstruct vimc_cap_device *vcap = container_of(ved, struct vimc_cap_device,\r\nved);\r\nstruct vimc_cap_buffer *vimc_buf;\r\nvoid *vbuf;\r\nspin_lock(&vcap->qlock);\r\nvimc_buf = list_first_entry_or_null(&vcap->buf_list,\r\ntypeof(*vimc_buf), list);\r\nif (!vimc_buf) {\r\nspin_unlock(&vcap->qlock);\r\nreturn;\r\n}\r\nlist_del(&vimc_buf->list);\r\nspin_unlock(&vcap->qlock);\r\nvimc_buf->vb2.vb2_buf.timestamp = ktime_get_ns();\r\nvimc_buf->vb2.sequence = vcap->sequence++;\r\nvimc_buf->vb2.field = vcap->format.field;\r\nvbuf = vb2_plane_vaddr(&vimc_buf->vb2.vb2_buf, 0);\r\nmemcpy(vbuf, frame, vcap->format.sizeimage);\r\nvb2_set_plane_payload(&vimc_buf->vb2.vb2_buf, 0,\r\nvcap->format.sizeimage);\r\nvb2_buffer_done(&vimc_buf->vb2.vb2_buf, VB2_BUF_STATE_DONE);\r\n}\r\nstatic int vimc_cap_comp_bind(struct device *comp, struct device *master,\r\nvoid *master_data)\r\n{\r\nstruct v4l2_device *v4l2_dev = master_data;\r\nstruct vimc_platform_data *pdata = comp->platform_data;\r\nconst struct vimc_pix_map *vpix;\r\nstruct vimc_cap_device *vcap;\r\nstruct video_device *vdev;\r\nstruct vb2_queue *q;\r\nint ret;\r\nvcap = kzalloc(sizeof(*vcap), GFP_KERNEL);\r\nif (!vcap)\r\nreturn -ENOMEM;\r\nvcap->ved.pads =\r\nvimc_pads_init(1, (const unsigned long[1]) {MEDIA_PAD_FL_SINK});\r\nif (IS_ERR(vcap->ved.pads)) {\r\nret = PTR_ERR(vcap->ved.pads);\r\ngoto err_free_vcap;\r\n}\r\nvcap->vdev.entity.name = pdata->entity_name;\r\nvcap->vdev.entity.function = MEDIA_ENT_F_IO_V4L;\r\nret = media_entity_pads_init(&vcap->vdev.entity,\r\n1, vcap->ved.pads);\r\nif (ret)\r\ngoto err_clean_pads;\r\nmutex_init(&vcap->lock);\r\nq = &vcap->queue;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_DMABUF;\r\nq->drv_priv = vcap;\r\nq->buf_struct_size = sizeof(struct vimc_cap_buffer);\r\nq->ops = &vimc_cap_qops;\r\nq->mem_ops = &vb2_vmalloc_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->min_buffers_needed = 2;\r\nq->lock = &vcap->lock;\r\nret = vb2_queue_init(q);\r\nif (ret) {\r\ndev_err(comp, "%s: vb2 queue init failed (err=%d)\n",\r\npdata->entity_name, ret);\r\ngoto err_clean_m_ent;\r\n}\r\nINIT_LIST_HEAD(&vcap->buf_list);\r\nspin_lock_init(&vcap->qlock);\r\nvcap->format = fmt_default;\r\nvpix = vimc_pix_map_by_pixelformat(vcap->format.pixelformat);\r\nvcap->format.bytesperline = vcap->format.width * vpix->bpp;\r\nvcap->format.sizeimage = vcap->format.bytesperline *\r\nvcap->format.height;\r\nvcap->ved.ent = &vcap->vdev.entity;\r\nvcap->ved.process_frame = vimc_cap_process_frame;\r\nvcap->ved.vdev_get_format = vimc_cap_get_format;\r\ndev_set_drvdata(comp, &vcap->ved);\r\nvcap->dev = comp;\r\nvdev = &vcap->vdev;\r\nvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\nvdev->entity.ops = &vimc_cap_mops;\r\nvdev->release = video_device_release_empty;\r\nvdev->fops = &vimc_cap_fops;\r\nvdev->ioctl_ops = &vimc_cap_ioctl_ops;\r\nvdev->lock = &vcap->lock;\r\nvdev->queue = q;\r\nvdev->v4l2_dev = v4l2_dev;\r\nvdev->vfl_dir = VFL_DIR_RX;\r\nstrlcpy(vdev->name, pdata->entity_name, sizeof(vdev->name));\r\nvideo_set_drvdata(vdev, &vcap->ved);\r\nret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret) {\r\ndev_err(comp, "%s: video register failed (err=%d)\n",\r\nvcap->vdev.name, ret);\r\ngoto err_release_queue;\r\n}\r\nreturn 0;\r\nerr_release_queue:\r\nvb2_queue_release(q);\r\nerr_clean_m_ent:\r\nmedia_entity_cleanup(&vcap->vdev.entity);\r\nerr_clean_pads:\r\nvimc_pads_cleanup(vcap->ved.pads);\r\nerr_free_vcap:\r\nkfree(vcap);\r\nreturn ret;\r\n}\r\nstatic int vimc_cap_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &vimc_cap_comp_ops);\r\n}\r\nstatic int vimc_cap_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &vimc_cap_comp_ops);\r\nreturn 0;\r\n}
