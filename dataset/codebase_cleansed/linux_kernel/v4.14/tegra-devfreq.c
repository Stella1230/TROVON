static u32 actmon_readl(struct tegra_devfreq *tegra, u32 offset)\r\n{\r\nreturn readl(tegra->regs + offset);\r\n}\r\nstatic void actmon_writel(struct tegra_devfreq *tegra, u32 val, u32 offset)\r\n{\r\nwritel(val, tegra->regs + offset);\r\n}\r\nstatic u32 device_readl(struct tegra_devfreq_device *dev, u32 offset)\r\n{\r\nreturn readl(dev->regs + offset);\r\n}\r\nstatic void device_writel(struct tegra_devfreq_device *dev, u32 val,\r\nu32 offset)\r\n{\r\nwritel(val, dev->regs + offset);\r\n}\r\nstatic unsigned long do_percent(unsigned long val, unsigned int pct)\r\n{\r\nreturn val * pct / 100;\r\n}\r\nstatic void tegra_devfreq_update_avg_wmark(struct tegra_devfreq *tegra,\r\nstruct tegra_devfreq_device *dev)\r\n{\r\nu32 avg = dev->avg_count;\r\nu32 avg_band_freq = tegra->max_freq * ACTMON_DEFAULT_AVG_BAND / KHZ;\r\nu32 band = avg_band_freq * ACTMON_SAMPLING_PERIOD;\r\ndevice_writel(dev, avg + band, ACTMON_DEV_AVG_UPPER_WMARK);\r\navg = max(dev->avg_count, band);\r\ndevice_writel(dev, avg - band, ACTMON_DEV_AVG_LOWER_WMARK);\r\n}\r\nstatic void tegra_devfreq_update_wmark(struct tegra_devfreq *tegra,\r\nstruct tegra_devfreq_device *dev)\r\n{\r\nu32 val = tegra->cur_freq * ACTMON_SAMPLING_PERIOD;\r\ndevice_writel(dev, do_percent(val, dev->config->boost_up_threshold),\r\nACTMON_DEV_UPPER_WMARK);\r\ndevice_writel(dev, do_percent(val, dev->config->boost_down_threshold),\r\nACTMON_DEV_LOWER_WMARK);\r\n}\r\nstatic void actmon_write_barrier(struct tegra_devfreq *tegra)\r\n{\r\nwmb();\r\nactmon_readl(tegra, ACTMON_GLB_STATUS);\r\n}\r\nstatic void actmon_isr_device(struct tegra_devfreq *tegra,\r\nstruct tegra_devfreq_device *dev)\r\n{\r\nunsigned long flags;\r\nu32 intr_status, dev_ctrl;\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->avg_count = device_readl(dev, ACTMON_DEV_AVG_COUNT);\r\ntegra_devfreq_update_avg_wmark(tegra, dev);\r\nintr_status = device_readl(dev, ACTMON_DEV_INTR_STATUS);\r\ndev_ctrl = device_readl(dev, ACTMON_DEV_CTRL);\r\nif (intr_status & ACTMON_DEV_INTR_CONSECUTIVE_UPPER) {\r\ndev->boost_freq = do_percent(dev->boost_freq,\r\ndev->config->boost_up_coeff);\r\ndev->boost_freq += ACTMON_BOOST_FREQ_STEP;\r\ndev_ctrl |= ACTMON_DEV_CTRL_CONSECUTIVE_BELOW_WMARK_EN;\r\nif (dev->boost_freq >= tegra->max_freq)\r\ndev->boost_freq = tegra->max_freq;\r\nelse\r\ndev_ctrl |= ACTMON_DEV_CTRL_CONSECUTIVE_ABOVE_WMARK_EN;\r\n} else if (intr_status & ACTMON_DEV_INTR_CONSECUTIVE_LOWER) {\r\ndev->boost_freq = do_percent(dev->boost_freq,\r\ndev->config->boost_down_coeff);\r\ndev_ctrl |= ACTMON_DEV_CTRL_CONSECUTIVE_ABOVE_WMARK_EN;\r\nif (dev->boost_freq < (ACTMON_BOOST_FREQ_STEP >> 1))\r\ndev->boost_freq = 0;\r\nelse\r\ndev_ctrl |= ACTMON_DEV_CTRL_CONSECUTIVE_BELOW_WMARK_EN;\r\n}\r\nif (dev->config->avg_dependency_threshold) {\r\nif (dev->avg_count >= dev->config->avg_dependency_threshold)\r\ndev_ctrl |= ACTMON_DEV_CTRL_CONSECUTIVE_BELOW_WMARK_EN;\r\nelse if (dev->boost_freq == 0)\r\ndev_ctrl &= ~ACTMON_DEV_CTRL_CONSECUTIVE_BELOW_WMARK_EN;\r\n}\r\ndevice_writel(dev, dev_ctrl, ACTMON_DEV_CTRL);\r\ndevice_writel(dev, ACTMON_INTR_STATUS_CLEAR, ACTMON_DEV_INTR_STATUS);\r\nactmon_write_barrier(tegra);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\n}\r\nstatic irqreturn_t actmon_isr(int irq, void *data)\r\n{\r\nstruct tegra_devfreq *tegra = data;\r\nbool handled = false;\r\nunsigned int i;\r\nu32 val;\r\nval = actmon_readl(tegra, ACTMON_GLB_STATUS);\r\nfor (i = 0; i < ARRAY_SIZE(tegra->devices); i++) {\r\nif (val & tegra->devices[i].config->irq_mask) {\r\nactmon_isr_device(tegra, tegra->devices + i);\r\nhandled = true;\r\n}\r\n}\r\nreturn handled ? IRQ_WAKE_THREAD : IRQ_NONE;\r\n}\r\nstatic unsigned long actmon_cpu_to_emc_rate(struct tegra_devfreq *tegra,\r\nunsigned long cpu_freq)\r\n{\r\nunsigned int i;\r\nstruct tegra_actmon_emc_ratio *ratio = actmon_emc_ratios;\r\nfor (i = 0; i < ARRAY_SIZE(actmon_emc_ratios); i++, ratio++) {\r\nif (cpu_freq >= ratio->cpu_freq) {\r\nif (ratio->emc_freq >= tegra->max_freq)\r\nreturn tegra->max_freq;\r\nelse\r\nreturn ratio->emc_freq;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void actmon_update_target(struct tegra_devfreq *tegra,\r\nstruct tegra_devfreq_device *dev)\r\n{\r\nunsigned long cpu_freq = 0;\r\nunsigned long static_cpu_emc_freq = 0;\r\nunsigned int avg_sustain_coef;\r\nunsigned long flags;\r\nif (dev->config->avg_dependency_threshold) {\r\ncpu_freq = cpufreq_get(0);\r\nstatic_cpu_emc_freq = actmon_cpu_to_emc_rate(tegra, cpu_freq);\r\n}\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->target_freq = dev->avg_count / ACTMON_SAMPLING_PERIOD;\r\navg_sustain_coef = 100 * 100 / dev->config->boost_up_threshold;\r\ndev->target_freq = do_percent(dev->target_freq, avg_sustain_coef);\r\ndev->target_freq += dev->boost_freq;\r\nif (dev->avg_count >= dev->config->avg_dependency_threshold)\r\ndev->target_freq = max(dev->target_freq, static_cpu_emc_freq);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\n}\r\nstatic irqreturn_t actmon_thread_isr(int irq, void *data)\r\n{\r\nstruct tegra_devfreq *tegra = data;\r\nmutex_lock(&tegra->devfreq->lock);\r\nupdate_devfreq(tegra->devfreq);\r\nmutex_unlock(&tegra->devfreq->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tegra_actmon_rate_notify_cb(struct notifier_block *nb,\r\nunsigned long action, void *ptr)\r\n{\r\nstruct clk_notifier_data *data = ptr;\r\nstruct tegra_devfreq *tegra;\r\nstruct tegra_devfreq_device *dev;\r\nunsigned int i;\r\nunsigned long flags;\r\nif (action != POST_RATE_CHANGE)\r\nreturn NOTIFY_OK;\r\ntegra = container_of(nb, struct tegra_devfreq, rate_change_nb);\r\ntegra->cur_freq = data->new_rate / KHZ;\r\nfor (i = 0; i < ARRAY_SIZE(tegra->devices); i++) {\r\ndev = &tegra->devices[i];\r\nspin_lock_irqsave(&dev->lock, flags);\r\ntegra_devfreq_update_wmark(tegra, dev);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\n}\r\nactmon_write_barrier(tegra);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void tegra_actmon_enable_interrupts(struct tegra_devfreq *tegra)\r\n{\r\nstruct tegra_devfreq_device *dev;\r\nu32 val;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(tegra->devices); i++) {\r\ndev = &tegra->devices[i];\r\nval = device_readl(dev, ACTMON_DEV_CTRL);\r\nval |= ACTMON_DEV_CTRL_AVG_ABOVE_WMARK_EN;\r\nval |= ACTMON_DEV_CTRL_AVG_BELOW_WMARK_EN;\r\nval |= ACTMON_DEV_CTRL_CONSECUTIVE_BELOW_WMARK_EN;\r\nval |= ACTMON_DEV_CTRL_CONSECUTIVE_ABOVE_WMARK_EN;\r\ndevice_writel(dev, val, ACTMON_DEV_CTRL);\r\n}\r\nactmon_write_barrier(tegra);\r\n}\r\nstatic void tegra_actmon_disable_interrupts(struct tegra_devfreq *tegra)\r\n{\r\nstruct tegra_devfreq_device *dev;\r\nu32 val;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(tegra->devices); i++) {\r\ndev = &tegra->devices[i];\r\nval = device_readl(dev, ACTMON_DEV_CTRL);\r\nval &= ~ACTMON_DEV_CTRL_AVG_ABOVE_WMARK_EN;\r\nval &= ~ACTMON_DEV_CTRL_AVG_BELOW_WMARK_EN;\r\nval &= ~ACTMON_DEV_CTRL_CONSECUTIVE_BELOW_WMARK_EN;\r\nval &= ~ACTMON_DEV_CTRL_CONSECUTIVE_ABOVE_WMARK_EN;\r\ndevice_writel(dev, val, ACTMON_DEV_CTRL);\r\n}\r\nactmon_write_barrier(tegra);\r\n}\r\nstatic void tegra_actmon_configure_device(struct tegra_devfreq *tegra,\r\nstruct tegra_devfreq_device *dev)\r\n{\r\nu32 val = 0;\r\ndev->target_freq = tegra->cur_freq;\r\ndev->avg_count = tegra->cur_freq * ACTMON_SAMPLING_PERIOD;\r\ndevice_writel(dev, dev->avg_count, ACTMON_DEV_INIT_AVG);\r\ntegra_devfreq_update_avg_wmark(tegra, dev);\r\ntegra_devfreq_update_wmark(tegra, dev);\r\ndevice_writel(dev, ACTMON_COUNT_WEIGHT, ACTMON_DEV_COUNT_WEIGHT);\r\ndevice_writel(dev, ACTMON_INTR_STATUS_CLEAR, ACTMON_DEV_INTR_STATUS);\r\nval |= ACTMON_DEV_CTRL_ENB_PERIODIC;\r\nval |= (ACTMON_AVERAGE_WINDOW_LOG2 - 1)\r\n<< ACTMON_DEV_CTRL_K_VAL_SHIFT;\r\nval |= (ACTMON_BELOW_WMARK_WINDOW - 1)\r\n<< ACTMON_DEV_CTRL_CONSECUTIVE_BELOW_WMARK_NUM_SHIFT;\r\nval |= (ACTMON_ABOVE_WMARK_WINDOW - 1)\r\n<< ACTMON_DEV_CTRL_CONSECUTIVE_ABOVE_WMARK_NUM_SHIFT;\r\nval |= ACTMON_DEV_CTRL_ENB;\r\ndevice_writel(dev, val, ACTMON_DEV_CTRL);\r\nactmon_write_barrier(tegra);\r\n}\r\nstatic int tegra_devfreq_target(struct device *dev, unsigned long *freq,\r\nu32 flags)\r\n{\r\nstruct tegra_devfreq *tegra = dev_get_drvdata(dev);\r\nstruct dev_pm_opp *opp;\r\nunsigned long rate = *freq * KHZ;\r\nopp = devfreq_recommended_opp(dev, &rate, flags);\r\nif (IS_ERR(opp)) {\r\ndev_err(dev, "Failed to find opp for %lu KHz\n", *freq);\r\nreturn PTR_ERR(opp);\r\n}\r\nrate = dev_pm_opp_get_freq(opp);\r\ndev_pm_opp_put(opp);\r\nclk_set_min_rate(tegra->emc_clock, rate);\r\nclk_set_rate(tegra->emc_clock, 0);\r\n*freq = rate;\r\nreturn 0;\r\n}\r\nstatic int tegra_devfreq_get_dev_status(struct device *dev,\r\nstruct devfreq_dev_status *stat)\r\n{\r\nstruct tegra_devfreq *tegra = dev_get_drvdata(dev);\r\nstruct tegra_devfreq_device *actmon_dev;\r\nstat->current_frequency = tegra->cur_freq;\r\nstat->private_data = tegra;\r\nactmon_dev = &tegra->devices[MCALL];\r\nstat->busy_time = device_readl(actmon_dev, ACTMON_DEV_AVG_COUNT);\r\nstat->busy_time *= 100 / BUS_SATURATION_RATIO;\r\nstat->total_time = ACTMON_SAMPLING_PERIOD * tegra->cur_freq;\r\nstat->busy_time = min(stat->busy_time, stat->total_time);\r\nreturn 0;\r\n}\r\nstatic int tegra_governor_get_target(struct devfreq *devfreq,\r\nunsigned long *freq)\r\n{\r\nstruct devfreq_dev_status *stat;\r\nstruct tegra_devfreq *tegra;\r\nstruct tegra_devfreq_device *dev;\r\nunsigned long target_freq = 0;\r\nunsigned int i;\r\nint err;\r\nerr = devfreq_update_stats(devfreq);\r\nif (err)\r\nreturn err;\r\nstat = &devfreq->last_status;\r\ntegra = stat->private_data;\r\nfor (i = 0; i < ARRAY_SIZE(tegra->devices); i++) {\r\ndev = &tegra->devices[i];\r\nactmon_update_target(tegra, dev);\r\ntarget_freq = max(target_freq, dev->target_freq);\r\n}\r\n*freq = target_freq;\r\nreturn 0;\r\n}\r\nstatic int tegra_governor_event_handler(struct devfreq *devfreq,\r\nunsigned int event, void *data)\r\n{\r\nstruct tegra_devfreq *tegra;\r\nint ret = 0;\r\ntegra = dev_get_drvdata(devfreq->dev.parent);\r\nswitch (event) {\r\ncase DEVFREQ_GOV_START:\r\ndevfreq_monitor_start(devfreq);\r\ntegra_actmon_enable_interrupts(tegra);\r\nbreak;\r\ncase DEVFREQ_GOV_STOP:\r\ntegra_actmon_disable_interrupts(tegra);\r\ndevfreq_monitor_stop(devfreq);\r\nbreak;\r\ncase DEVFREQ_GOV_SUSPEND:\r\ntegra_actmon_disable_interrupts(tegra);\r\ndevfreq_monitor_suspend(devfreq);\r\nbreak;\r\ncase DEVFREQ_GOV_RESUME:\r\ndevfreq_monitor_resume(devfreq);\r\ntegra_actmon_enable_interrupts(tegra);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tegra_devfreq_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra_devfreq *tegra;\r\nstruct tegra_devfreq_device *dev;\r\nstruct resource *res;\r\nunsigned int i;\r\nunsigned long rate;\r\nint irq;\r\nint err;\r\ntegra = devm_kzalloc(&pdev->dev, sizeof(*tegra), GFP_KERNEL);\r\nif (!tegra)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntegra->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(tegra->regs))\r\nreturn PTR_ERR(tegra->regs);\r\ntegra->reset = devm_reset_control_get(&pdev->dev, "actmon");\r\nif (IS_ERR(tegra->reset)) {\r\ndev_err(&pdev->dev, "Failed to get reset\n");\r\nreturn PTR_ERR(tegra->reset);\r\n}\r\ntegra->clock = devm_clk_get(&pdev->dev, "actmon");\r\nif (IS_ERR(tegra->clock)) {\r\ndev_err(&pdev->dev, "Failed to get actmon clock\n");\r\nreturn PTR_ERR(tegra->clock);\r\n}\r\ntegra->emc_clock = devm_clk_get(&pdev->dev, "emc");\r\nif (IS_ERR(tegra->emc_clock)) {\r\ndev_err(&pdev->dev, "Failed to get emc clock\n");\r\nreturn PTR_ERR(tegra->emc_clock);\r\n}\r\nclk_set_rate(tegra->emc_clock, ULONG_MAX);\r\ntegra->rate_change_nb.notifier_call = tegra_actmon_rate_notify_cb;\r\nerr = clk_notifier_register(tegra->emc_clock, &tegra->rate_change_nb);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Failed to register rate change notifier\n");\r\nreturn err;\r\n}\r\nreset_control_assert(tegra->reset);\r\nerr = clk_prepare_enable(tegra->clock);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Failed to prepare and enable ACTMON clock\n");\r\nreturn err;\r\n}\r\nreset_control_deassert(tegra->reset);\r\ntegra->max_freq = clk_round_rate(tegra->emc_clock, ULONG_MAX) / KHZ;\r\ntegra->cur_freq = clk_get_rate(tegra->emc_clock) / KHZ;\r\nactmon_writel(tegra, ACTMON_SAMPLING_PERIOD - 1,\r\nACTMON_GLB_PERIOD_CTRL);\r\nfor (i = 0; i < ARRAY_SIZE(actmon_device_configs); i++) {\r\ndev = tegra->devices + i;\r\ndev->config = actmon_device_configs + i;\r\ndev->regs = tegra->regs + dev->config->offset;\r\nspin_lock_init(&dev->lock);\r\ntegra_actmon_configure_device(tegra, dev);\r\n}\r\nfor (rate = 0; rate <= tegra->max_freq * KHZ; rate++) {\r\nrate = clk_round_rate(tegra->emc_clock, rate);\r\ndev_pm_opp_add(&pdev->dev, rate, 0);\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "Failed to get IRQ: %d\n", irq);\r\nreturn irq;\r\n}\r\nplatform_set_drvdata(pdev, tegra);\r\nerr = devm_request_threaded_irq(&pdev->dev, irq, actmon_isr,\r\nactmon_thread_isr, IRQF_SHARED,\r\n"tegra-devfreq", tegra);\r\nif (err) {\r\ndev_err(&pdev->dev, "Interrupt request failed\n");\r\nreturn err;\r\n}\r\ntegra_devfreq_profile.initial_freq = clk_get_rate(tegra->emc_clock);\r\ntegra->devfreq = devm_devfreq_add_device(&pdev->dev,\r\n&tegra_devfreq_profile,\r\n"tegra_actmon",\r\nNULL);\r\nreturn 0;\r\n}\r\nstatic int tegra_devfreq_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_devfreq *tegra = platform_get_drvdata(pdev);\r\nint irq = platform_get_irq(pdev, 0);\r\nu32 val;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(actmon_device_configs); i++) {\r\nval = device_readl(&tegra->devices[i], ACTMON_DEV_CTRL);\r\nval &= ~ACTMON_DEV_CTRL_ENB;\r\ndevice_writel(&tegra->devices[i], val, ACTMON_DEV_CTRL);\r\n}\r\nactmon_write_barrier(tegra);\r\ndevm_free_irq(&pdev->dev, irq, tegra);\r\nclk_notifier_unregister(tegra->emc_clock, &tegra->rate_change_nb);\r\nclk_disable_unprepare(tegra->clock);\r\nreturn 0;\r\n}\r\nstatic int __init tegra_devfreq_init(void)\r\n{\r\nint ret = 0;\r\nret = devfreq_add_governor(&tegra_devfreq_governor);\r\nif (ret) {\r\npr_err("%s: failed to add governor: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nret = platform_driver_register(&tegra_devfreq_driver);\r\nif (ret)\r\ndevfreq_remove_governor(&tegra_devfreq_governor);\r\nreturn ret;\r\n}\r\nstatic void __exit tegra_devfreq_exit(void)\r\n{\r\nint ret = 0;\r\nplatform_driver_unregister(&tegra_devfreq_driver);\r\nret = devfreq_remove_governor(&tegra_devfreq_governor);\r\nif (ret)\r\npr_err("%s: failed to remove governor: %d\n", __func__, ret);\r\n}
