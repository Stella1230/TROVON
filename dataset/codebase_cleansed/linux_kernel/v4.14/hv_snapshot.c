static void vss_poll_wrapper(void *channel)\r\n{\r\nvss_transaction.state = HVUTIL_READY;\r\nhv_vss_onchannelcallback(channel);\r\n}\r\nstatic void vss_timeout_func(struct work_struct *dummy)\r\n{\r\npr_warn("VSS: timeout waiting for daemon to reply\n");\r\nvss_respond_to_host(HV_E_FAIL);\r\nhv_poll_channel(vss_transaction.recv_channel, vss_poll_wrapper);\r\n}\r\nstatic void vss_register_done(void)\r\n{\r\nhv_poll_channel(vss_transaction.recv_channel, vss_poll_wrapper);\r\npr_debug("VSS: userspace daemon registered\n");\r\n}\r\nstatic int vss_handle_handshake(struct hv_vss_msg *vss_msg)\r\n{\r\nu32 our_ver = VSS_OP_REGISTER1;\r\nswitch (vss_msg->vss_hdr.operation) {\r\ncase VSS_OP_REGISTER:\r\ndm_reg_value = VSS_OP_REGISTER;\r\nbreak;\r\ncase VSS_OP_REGISTER1:\r\nif (hvutil_transport_send(hvt, &our_ver, sizeof(our_ver),\r\nvss_register_done))\r\nreturn -EFAULT;\r\ndm_reg_value = VSS_OP_REGISTER1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npr_info("VSS: userspace daemon ver. %d connected\n", dm_reg_value);\r\nreturn 0;\r\n}\r\nstatic int vss_on_msg(void *msg, int len)\r\n{\r\nstruct hv_vss_msg *vss_msg = (struct hv_vss_msg *)msg;\r\nif (len != sizeof(*vss_msg)) {\r\npr_debug("VSS: Message size does not match length\n");\r\nreturn -EINVAL;\r\n}\r\nif (vss_msg->vss_hdr.operation == VSS_OP_REGISTER ||\r\nvss_msg->vss_hdr.operation == VSS_OP_REGISTER1) {\r\nif (vss_transaction.state > HVUTIL_READY) {\r\npr_debug("VSS: Got unexpected registration request\n");\r\nreturn -EINVAL;\r\n}\r\nreturn vss_handle_handshake(vss_msg);\r\n} else if (vss_transaction.state == HVUTIL_USERSPACE_REQ) {\r\nvss_transaction.state = HVUTIL_USERSPACE_RECV;\r\nif (vss_msg->vss_hdr.operation == VSS_OP_HOT_BACKUP)\r\nvss_transaction.msg->vss_cf.flags =\r\nVSS_HBU_NO_AUTO_RECOVERY;\r\nif (cancel_delayed_work_sync(&vss_timeout_work)) {\r\nvss_respond_to_host(vss_msg->error);\r\nhv_poll_channel(vss_transaction.recv_channel,\r\nvss_poll_wrapper);\r\n}\r\n} else {\r\npr_debug("VSS: Transaction not active\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vss_send_op(void)\r\n{\r\nint op = vss_transaction.msg->vss_hdr.operation;\r\nint rc;\r\nstruct hv_vss_msg *vss_msg;\r\nif (vss_transaction.state != HVUTIL_HOSTMSG_RECEIVED) {\r\npr_debug("VSS: Unexpected attempt to send to daemon\n");\r\nreturn;\r\n}\r\nvss_msg = kzalloc(sizeof(*vss_msg), GFP_KERNEL);\r\nif (!vss_msg)\r\nreturn;\r\nvss_msg->vss_hdr.operation = op;\r\nvss_transaction.state = HVUTIL_USERSPACE_REQ;\r\nschedule_delayed_work(&vss_timeout_work, op == VSS_OP_FREEZE ?\r\nVSS_FREEZE_TIMEOUT * HZ : HV_UTIL_TIMEOUT * HZ);\r\nrc = hvutil_transport_send(hvt, vss_msg, sizeof(*vss_msg), NULL);\r\nif (rc) {\r\npr_warn("VSS: failed to communicate to the daemon: %d\n", rc);\r\nif (cancel_delayed_work_sync(&vss_timeout_work)) {\r\nvss_respond_to_host(HV_E_FAIL);\r\nvss_transaction.state = HVUTIL_READY;\r\n}\r\n}\r\nkfree(vss_msg);\r\n}\r\nstatic void vss_handle_request(struct work_struct *dummy)\r\n{\r\nswitch (vss_transaction.msg->vss_hdr.operation) {\r\ncase VSS_OP_THAW:\r\ncase VSS_OP_FREEZE:\r\ncase VSS_OP_HOT_BACKUP:\r\nif (vss_transaction.state < HVUTIL_READY) {\r\npr_debug("VSS: Not ready for request.\n");\r\nvss_respond_to_host(HV_E_FAIL);\r\nreturn;\r\n}\r\npr_debug("VSS: Received request for op code: %d\n",\r\nvss_transaction.msg->vss_hdr.operation);\r\nvss_transaction.state = HVUTIL_HOSTMSG_RECEIVED;\r\nvss_send_op();\r\nreturn;\r\ncase VSS_OP_GET_DM_INFO:\r\nvss_transaction.msg->dm_info.flags = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nvss_respond_to_host(0);\r\nhv_poll_channel(vss_transaction.recv_channel, vss_poll_wrapper);\r\n}\r\nstatic void\r\nvss_respond_to_host(int error)\r\n{\r\nstruct icmsg_hdr *icmsghdrp;\r\nu32 buf_len;\r\nstruct vmbus_channel *channel;\r\nu64 req_id;\r\nbuf_len = vss_transaction.recv_len;\r\nchannel = vss_transaction.recv_channel;\r\nreq_id = vss_transaction.recv_req_id;\r\nicmsghdrp = (struct icmsg_hdr *)\r\n&recv_buffer[sizeof(struct vmbuspipe_hdr)];\r\nif (channel->onchannel_callback == NULL)\r\nreturn;\r\nicmsghdrp->status = error;\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\nvoid hv_vss_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nstruct hv_vss_msg *vss_msg;\r\nint vss_srv_version;\r\nstruct icmsg_hdr *icmsghdrp;\r\nif (vss_transaction.state > HVUTIL_READY)\r\nreturn;\r\nvmbus_recvpacket(channel, recv_buffer, PAGE_SIZE * 2, &recvlen,\r\n&requestid);\r\nif (recvlen > 0) {\r\nicmsghdrp = (struct icmsg_hdr *)&recv_buffer[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nif (vmbus_prep_negotiate_resp(icmsghdrp,\r\nrecv_buffer, fw_versions, FW_VER_COUNT,\r\nvss_versions, VSS_VER_COUNT,\r\nNULL, &vss_srv_version)) {\r\npr_info("VSS IC version %d.%d\n",\r\nvss_srv_version >> 16,\r\nvss_srv_version & 0xFFFF);\r\n}\r\n} else {\r\nvss_msg = (struct hv_vss_msg *)&recv_buffer[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nvss_transaction.recv_len = recvlen;\r\nvss_transaction.recv_req_id = requestid;\r\nvss_transaction.msg = (struct hv_vss_msg *)vss_msg;\r\nschedule_work(&vss_handle_request_work);\r\nreturn;\r\n}\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\r\n| ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, recv_buffer,\r\nrecvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\n}\r\nstatic void vss_on_reset(void)\r\n{\r\nif (cancel_delayed_work_sync(&vss_timeout_work))\r\nvss_respond_to_host(HV_E_FAIL);\r\nvss_transaction.state = HVUTIL_DEVICE_INIT;\r\n}\r\nint\r\nhv_vss_init(struct hv_util_service *srv)\r\n{\r\nif (vmbus_proto_version < VERSION_WIN8_1) {\r\npr_warn("Integration service 'Backup (volume snapshot)'"\r\n" not supported on this host version.\n");\r\nreturn -ENOTSUPP;\r\n}\r\nrecv_buffer = srv->recv_buffer;\r\nvss_transaction.recv_channel = srv->channel;\r\nvss_transaction.state = HVUTIL_DEVICE_INIT;\r\nhvt = hvutil_transport_init(vss_devname, CN_VSS_IDX, CN_VSS_VAL,\r\nvss_on_msg, vss_on_reset);\r\nif (!hvt) {\r\npr_warn("VSS: Failed to initialize transport\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nvoid hv_vss_deinit(void)\r\n{\r\nvss_transaction.state = HVUTIL_DEVICE_DYING;\r\ncancel_delayed_work_sync(&vss_timeout_work);\r\ncancel_work_sync(&vss_handle_request_work);\r\nhvutil_transport_destroy(hvt);\r\n}
