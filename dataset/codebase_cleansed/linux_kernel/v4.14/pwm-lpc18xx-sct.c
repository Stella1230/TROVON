static inline struct lpc18xx_pwm_chip *\r\nto_lpc18xx_pwm_chip(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct lpc18xx_pwm_chip, chip);\r\n}\r\nstatic inline void lpc18xx_pwm_writel(struct lpc18xx_pwm_chip *lpc18xx_pwm,\r\nu32 reg, u32 val)\r\n{\r\nwritel(val, lpc18xx_pwm->base + reg);\r\n}\r\nstatic inline u32 lpc18xx_pwm_readl(struct lpc18xx_pwm_chip *lpc18xx_pwm,\r\nu32 reg)\r\n{\r\nreturn readl(lpc18xx_pwm->base + reg);\r\n}\r\nstatic void lpc18xx_pwm_set_conflict_res(struct lpc18xx_pwm_chip *lpc18xx_pwm,\r\nstruct pwm_device *pwm,\r\nenum lpc18xx_pwm_res_action action)\r\n{\r\nu32 val;\r\nmutex_lock(&lpc18xx_pwm->res_lock);\r\nval = lpc18xx_pwm_readl(lpc18xx_pwm, LPC18XX_PWM_RES_BASE);\r\nval &= ~LPC18XX_PWM_RES_MASK(pwm->hwpwm);\r\nval |= LPC18XX_PWM_RES(pwm->hwpwm, action);\r\nlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_RES_BASE, val);\r\nmutex_unlock(&lpc18xx_pwm->res_lock);\r\n}\r\nstatic void lpc18xx_pwm_config_period(struct pwm_chip *chip, int period_ns)\r\n{\r\nstruct lpc18xx_pwm_chip *lpc18xx_pwm = to_lpc18xx_pwm_chip(chip);\r\nu64 val;\r\nval = (u64)period_ns * lpc18xx_pwm->clk_rate;\r\ndo_div(val, NSEC_PER_SEC);\r\nlpc18xx_pwm_writel(lpc18xx_pwm,\r\nLPC18XX_PWM_MATCH(lpc18xx_pwm->period_event),\r\n(u32)val - 1);\r\nlpc18xx_pwm_writel(lpc18xx_pwm,\r\nLPC18XX_PWM_MATCHREL(lpc18xx_pwm->period_event),\r\n(u32)val - 1);\r\n}\r\nstatic void lpc18xx_pwm_config_duty(struct pwm_chip *chip,\r\nstruct pwm_device *pwm, int duty_ns)\r\n{\r\nstruct lpc18xx_pwm_chip *lpc18xx_pwm = to_lpc18xx_pwm_chip(chip);\r\nstruct lpc18xx_pwm_data *lpc18xx_data = pwm_get_chip_data(pwm);\r\nu64 val;\r\nval = (u64)duty_ns * lpc18xx_pwm->clk_rate;\r\ndo_div(val, NSEC_PER_SEC);\r\nlpc18xx_pwm_writel(lpc18xx_pwm,\r\nLPC18XX_PWM_MATCH(lpc18xx_data->duty_event),\r\n(u32)val);\r\nlpc18xx_pwm_writel(lpc18xx_pwm,\r\nLPC18XX_PWM_MATCHREL(lpc18xx_data->duty_event),\r\n(u32)val);\r\n}\r\nstatic int lpc18xx_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct lpc18xx_pwm_chip *lpc18xx_pwm = to_lpc18xx_pwm_chip(chip);\r\nint requested_events, i;\r\nif (period_ns < lpc18xx_pwm->min_period_ns ||\r\nperiod_ns > lpc18xx_pwm->max_period_ns) {\r\ndev_err(chip->dev, "period %d not in range\n", period_ns);\r\nreturn -ERANGE;\r\n}\r\nmutex_lock(&lpc18xx_pwm->period_lock);\r\nrequested_events = bitmap_weight(&lpc18xx_pwm->event_map,\r\nLPC18XX_PWM_EVENT_MAX);\r\nif (requested_events > 2 && lpc18xx_pwm->period_ns != period_ns &&\r\nlpc18xx_pwm->period_ns) {\r\ndev_err(chip->dev, "conflicting period requested for PWM %u\n",\r\npwm->hwpwm);\r\nmutex_unlock(&lpc18xx_pwm->period_lock);\r\nreturn -EBUSY;\r\n}\r\nif ((requested_events <= 2 && lpc18xx_pwm->period_ns != period_ns) ||\r\n!lpc18xx_pwm->period_ns) {\r\nlpc18xx_pwm->period_ns = period_ns;\r\nfor (i = 0; i < chip->npwm; i++)\r\npwm_set_period(&chip->pwms[i], period_ns);\r\nlpc18xx_pwm_config_period(chip, period_ns);\r\n}\r\nmutex_unlock(&lpc18xx_pwm->period_lock);\r\nlpc18xx_pwm_config_duty(chip, pwm, duty_ns);\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_pwm_set_polarity(struct pwm_chip *chip,\r\nstruct pwm_device *pwm,\r\nenum pwm_polarity polarity)\r\n{\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct lpc18xx_pwm_chip *lpc18xx_pwm = to_lpc18xx_pwm_chip(chip);\r\nstruct lpc18xx_pwm_data *lpc18xx_data = pwm_get_chip_data(pwm);\r\nenum lpc18xx_pwm_res_action res_action;\r\nunsigned int set_event, clear_event;\r\nlpc18xx_pwm_writel(lpc18xx_pwm,\r\nLPC18XX_PWM_EVCTRL(lpc18xx_data->duty_event),\r\nLPC18XX_PWM_EVCTRL_MATCH(lpc18xx_data->duty_event) |\r\nLPC18XX_PWM_EVCTRL_COMB_MATCH);\r\nlpc18xx_pwm_writel(lpc18xx_pwm,\r\nLPC18XX_PWM_EVSTATEMSK(lpc18xx_data->duty_event),\r\nLPC18XX_PWM_EVSTATEMSK_ALL);\r\nif (pwm_get_polarity(pwm) == PWM_POLARITY_NORMAL) {\r\nset_event = lpc18xx_pwm->period_event;\r\nclear_event = lpc18xx_data->duty_event;\r\nres_action = LPC18XX_PWM_RES_SET;\r\n} else {\r\nset_event = lpc18xx_data->duty_event;\r\nclear_event = lpc18xx_pwm->period_event;\r\nres_action = LPC18XX_PWM_RES_CLEAR;\r\n}\r\nlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_OUTPUTSET(pwm->hwpwm),\r\nBIT(set_event));\r\nlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_OUTPUTCL(pwm->hwpwm),\r\nBIT(clear_event));\r\nlpc18xx_pwm_set_conflict_res(lpc18xx_pwm, pwm, res_action);\r\nreturn 0;\r\n}\r\nstatic void lpc18xx_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct lpc18xx_pwm_chip *lpc18xx_pwm = to_lpc18xx_pwm_chip(chip);\r\nstruct lpc18xx_pwm_data *lpc18xx_data = pwm_get_chip_data(pwm);\r\nlpc18xx_pwm_writel(lpc18xx_pwm,\r\nLPC18XX_PWM_EVCTRL(lpc18xx_data->duty_event), 0);\r\nlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_OUTPUTSET(pwm->hwpwm), 0);\r\nlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_OUTPUTCL(pwm->hwpwm), 0);\r\n}\r\nstatic int lpc18xx_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct lpc18xx_pwm_chip *lpc18xx_pwm = to_lpc18xx_pwm_chip(chip);\r\nstruct lpc18xx_pwm_data *lpc18xx_data = pwm_get_chip_data(pwm);\r\nunsigned long event;\r\nevent = find_first_zero_bit(&lpc18xx_pwm->event_map,\r\nLPC18XX_PWM_EVENT_MAX);\r\nif (event >= LPC18XX_PWM_EVENT_MAX) {\r\ndev_err(lpc18xx_pwm->dev,\r\n"maximum number of simultaneous channels reached\n");\r\nreturn -EBUSY;\r\n};\r\nset_bit(event, &lpc18xx_pwm->event_map);\r\nlpc18xx_data->duty_event = event;\r\nlpc18xx_pwm_config_duty(chip, pwm, pwm_get_duty_cycle(pwm));\r\nreturn 0;\r\n}\r\nstatic void lpc18xx_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct lpc18xx_pwm_chip *lpc18xx_pwm = to_lpc18xx_pwm_chip(chip);\r\nstruct lpc18xx_pwm_data *lpc18xx_data = pwm_get_chip_data(pwm);\r\npwm_disable(pwm);\r\npwm_set_duty_cycle(pwm, 0);\r\nclear_bit(lpc18xx_data->duty_event, &lpc18xx_pwm->event_map);\r\n}\r\nstatic int lpc18xx_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct lpc18xx_pwm_chip *lpc18xx_pwm;\r\nstruct pwm_device *pwm;\r\nstruct resource *res;\r\nint ret, i;\r\nu64 val;\r\nlpc18xx_pwm = devm_kzalloc(&pdev->dev, sizeof(*lpc18xx_pwm),\r\nGFP_KERNEL);\r\nif (!lpc18xx_pwm)\r\nreturn -ENOMEM;\r\nlpc18xx_pwm->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nlpc18xx_pwm->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(lpc18xx_pwm->base))\r\nreturn PTR_ERR(lpc18xx_pwm->base);\r\nlpc18xx_pwm->pwm_clk = devm_clk_get(&pdev->dev, "pwm");\r\nif (IS_ERR(lpc18xx_pwm->pwm_clk)) {\r\ndev_err(&pdev->dev, "failed to get pwm clock\n");\r\nreturn PTR_ERR(lpc18xx_pwm->pwm_clk);\r\n}\r\nret = clk_prepare_enable(lpc18xx_pwm->pwm_clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "could not prepare or enable pwm clock\n");\r\nreturn ret;\r\n}\r\nlpc18xx_pwm->clk_rate = clk_get_rate(lpc18xx_pwm->pwm_clk);\r\nif (!lpc18xx_pwm->clk_rate) {\r\ndev_err(&pdev->dev, "pwm clock has no frequency\n");\r\nret = -EINVAL;\r\ngoto disable_pwmclk;\r\n}\r\nmutex_init(&lpc18xx_pwm->res_lock);\r\nmutex_init(&lpc18xx_pwm->period_lock);\r\nval = (u64)NSEC_PER_SEC * LPC18XX_PWM_TIMER_MAX;\r\ndo_div(val, lpc18xx_pwm->clk_rate);\r\nlpc18xx_pwm->max_period_ns = val;\r\nlpc18xx_pwm->min_period_ns = DIV_ROUND_UP(NSEC_PER_SEC,\r\nlpc18xx_pwm->clk_rate);\r\nlpc18xx_pwm->chip.dev = &pdev->dev;\r\nlpc18xx_pwm->chip.ops = &lpc18xx_pwm_ops;\r\nlpc18xx_pwm->chip.base = -1;\r\nlpc18xx_pwm->chip.npwm = 16;\r\nlpc18xx_pwm->chip.of_xlate = of_pwm_xlate_with_flags;\r\nlpc18xx_pwm->chip.of_pwm_n_cells = 3;\r\nlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_CONFIG,\r\nLPC18XX_PWM_CONFIG_UNIFY);\r\nset_bit(LPC18XX_PWM_EVENT_PERIOD, &lpc18xx_pwm->event_map);\r\nlpc18xx_pwm->period_event = LPC18XX_PWM_EVENT_PERIOD;\r\nlpc18xx_pwm_writel(lpc18xx_pwm,\r\nLPC18XX_PWM_EVSTATEMSK(lpc18xx_pwm->period_event),\r\nLPC18XX_PWM_EVSTATEMSK_ALL);\r\nval = LPC18XX_PWM_EVCTRL_MATCH(lpc18xx_pwm->period_event) |\r\nLPC18XX_PWM_EVCTRL_COMB_MATCH;\r\nlpc18xx_pwm_writel(lpc18xx_pwm,\r\nLPC18XX_PWM_EVCTRL(lpc18xx_pwm->period_event), val);\r\nlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_LIMIT,\r\nBIT(lpc18xx_pwm->period_event));\r\nret = pwmchip_add(&lpc18xx_pwm->chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "pwmchip_add failed: %d\n", ret);\r\ngoto disable_pwmclk;\r\n}\r\nfor (i = 0; i < lpc18xx_pwm->chip.npwm; i++) {\r\nstruct lpc18xx_pwm_data *data;\r\npwm = &lpc18xx_pwm->chip.pwms[i];\r\ndata = devm_kzalloc(lpc18xx_pwm->dev, sizeof(*data),\r\nGFP_KERNEL);\r\nif (!data) {\r\nret = -ENOMEM;\r\ngoto remove_pwmchip;\r\n}\r\npwm_set_chip_data(pwm, data);\r\n}\r\nplatform_set_drvdata(pdev, lpc18xx_pwm);\r\nval = lpc18xx_pwm_readl(lpc18xx_pwm, LPC18XX_PWM_CTRL);\r\nval &= ~LPC18XX_PWM_BIDIR;\r\nval &= ~LPC18XX_PWM_CTRL_HALT;\r\nval &= ~LPC18XX_PWM_PRE_MASK;\r\nval |= LPC18XX_PWM_PRE(0);\r\nlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_CTRL, val);\r\nreturn 0;\r\nremove_pwmchip:\r\npwmchip_remove(&lpc18xx_pwm->chip);\r\ndisable_pwmclk:\r\nclk_disable_unprepare(lpc18xx_pwm->pwm_clk);\r\nreturn ret;\r\n}\r\nstatic int lpc18xx_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct lpc18xx_pwm_chip *lpc18xx_pwm = platform_get_drvdata(pdev);\r\nu32 val;\r\nval = lpc18xx_pwm_readl(lpc18xx_pwm, LPC18XX_PWM_CTRL);\r\nlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_CTRL,\r\nval | LPC18XX_PWM_CTRL_HALT);\r\nclk_disable_unprepare(lpc18xx_pwm->pwm_clk);\r\nreturn pwmchip_remove(&lpc18xx_pwm->chip);\r\n}
