int shpchp_configure_device(struct slot *p_slot)\r\n{\r\nstruct pci_dev *dev;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nstruct pci_dev *bridge = ctrl->pci_dev;\r\nstruct pci_bus *parent = bridge->subordinate;\r\nint num, ret = 0;\r\npci_lock_rescan_remove();\r\ndev = pci_get_slot(parent, PCI_DEVFN(p_slot->device, 0));\r\nif (dev) {\r\nctrl_err(ctrl, "Device %s already exists at %04x:%02x:%02x, cannot hot-add\n",\r\npci_name(dev), pci_domain_nr(parent),\r\np_slot->bus, p_slot->device);\r\npci_dev_put(dev);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nnum = pci_scan_slot(parent, PCI_DEVFN(p_slot->device, 0));\r\nif (num == 0) {\r\nctrl_err(ctrl, "No new device found\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nlist_for_each_entry(dev, &parent->devices, bus_list) {\r\nif (PCI_SLOT(dev->devfn) != p_slot->device)\r\ncontinue;\r\nif (pci_is_bridge(dev))\r\npci_hp_add_bridge(dev);\r\n}\r\npci_assign_unassigned_bridge_resources(bridge);\r\npcie_bus_configure_settings(parent);\r\npci_bus_add_devices(parent);\r\nout:\r\npci_unlock_rescan_remove();\r\nreturn ret;\r\n}\r\nint shpchp_unconfigure_device(struct slot *p_slot)\r\n{\r\nint rc = 0;\r\nu8 bctl = 0;\r\nstruct pci_bus *parent = p_slot->ctrl->pci_dev->subordinate;\r\nstruct pci_dev *dev, *temp;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nctrl_dbg(ctrl, "%s: domain:bus:dev = %04x:%02x:%02x\n",\r\n__func__, pci_domain_nr(parent), p_slot->bus, p_slot->device);\r\npci_lock_rescan_remove();\r\nlist_for_each_entry_safe(dev, temp, &parent->devices, bus_list) {\r\nif (PCI_SLOT(dev->devfn) != p_slot->device)\r\ncontinue;\r\npci_dev_get(dev);\r\nif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\r\npci_read_config_byte(dev, PCI_BRIDGE_CONTROL, &bctl);\r\nif (bctl & PCI_BRIDGE_CTL_VGA) {\r\nctrl_err(ctrl,\r\n"Cannot remove display device %s\n",\r\npci_name(dev));\r\npci_dev_put(dev);\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\n}\r\npci_stop_and_remove_bus_device(dev);\r\npci_dev_put(dev);\r\n}\r\npci_unlock_rescan_remove();\r\nreturn rc;\r\n}
