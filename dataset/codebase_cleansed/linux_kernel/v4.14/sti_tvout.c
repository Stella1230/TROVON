static u32 tvout_read(struct sti_tvout *tvout, int offset)\r\n{\r\nreturn readl(tvout->regs + offset);\r\n}\r\nstatic void tvout_write(struct sti_tvout *tvout, u32 val, int offset)\r\n{\r\nwritel(val, tvout->regs + offset);\r\n}\r\nstatic void tvout_vip_set_color_order(struct sti_tvout *tvout, int reg,\r\nu32 cr_r, u32 y_g, u32 cb_b)\r\n{\r\nu32 val = tvout_read(tvout, reg);\r\nval &= ~(TVO_VIP_REORDER_MASK << TVO_VIP_REORDER_R_SHIFT);\r\nval &= ~(TVO_VIP_REORDER_MASK << TVO_VIP_REORDER_G_SHIFT);\r\nval &= ~(TVO_VIP_REORDER_MASK << TVO_VIP_REORDER_B_SHIFT);\r\nval |= cr_r << TVO_VIP_REORDER_R_SHIFT;\r\nval |= y_g << TVO_VIP_REORDER_G_SHIFT;\r\nval |= cb_b << TVO_VIP_REORDER_B_SHIFT;\r\ntvout_write(tvout, val, reg);\r\n}\r\nstatic void tvout_vip_set_clip_mode(struct sti_tvout *tvout, int reg, u32 range)\r\n{\r\nu32 val = tvout_read(tvout, reg);\r\nval &= ~(TVO_VIP_CLIP_MASK << TVO_VIP_CLIP_SHIFT);\r\nval |= range << TVO_VIP_CLIP_SHIFT;\r\ntvout_write(tvout, val, reg);\r\n}\r\nstatic void tvout_vip_set_rnd(struct sti_tvout *tvout, int reg, u32 rnd)\r\n{\r\nu32 val = tvout_read(tvout, reg);\r\nval &= ~(TVO_VIP_RND_MASK << TVO_VIP_RND_SHIFT);\r\nval |= rnd << TVO_VIP_RND_SHIFT;\r\ntvout_write(tvout, val, reg);\r\n}\r\nstatic void tvout_vip_set_sel_input(struct sti_tvout *tvout,\r\nint reg,\r\nbool main_path,\r\nenum sti_tvout_video_out_type video_out)\r\n{\r\nu32 sel_input;\r\nu32 val = tvout_read(tvout, reg);\r\nif (main_path)\r\nsel_input = TVO_VIP_SEL_INPUT_MAIN;\r\nelse\r\nsel_input = TVO_VIP_SEL_INPUT_AUX;\r\nswitch (video_out) {\r\ncase STI_TVOUT_VIDEO_OUT_RGB:\r\nsel_input |= TVO_VIP_SEL_INPUT_BYPASSED;\r\nbreak;\r\ncase STI_TVOUT_VIDEO_OUT_YUV:\r\nsel_input &= ~TVO_VIP_SEL_INPUT_BYPASSED;\r\nbreak;\r\n}\r\nsel_input = sel_input ^ TVO_VIP_SEL_INPUT_BYPASS_MASK;\r\nval &= ~TVO_VIP_SEL_INPUT_MASK;\r\nval |= sel_input;\r\ntvout_write(tvout, val, reg);\r\n}\r\nstatic void tvout_vip_set_in_vid_fmt(struct sti_tvout *tvout,\r\nint reg, u32 in_vid_fmt)\r\n{\r\nu32 val = tvout_read(tvout, reg);\r\nval &= ~TVO_IN_FMT_SIGNED;\r\nval |= in_vid_fmt;\r\ntvout_write(tvout, val, reg);\r\n}\r\nstatic void tvout_preformatter_set_matrix(struct sti_tvout *tvout,\r\nstruct drm_display_mode *mode)\r\n{\r\nunsigned int i;\r\nconst u32 *pf_matrix;\r\nif (mode->vdisplay >= TVO_MIN_HD_HEIGHT)\r\npf_matrix = rgb_to_ycbcr_709;\r\nelse\r\npf_matrix = rgb_to_ycbcr_601;\r\nfor (i = 0; i < 8; i++) {\r\ntvout_write(tvout, *(pf_matrix + i),\r\nTVO_CSC_MAIN_M0 + (i * 4));\r\ntvout_write(tvout, *(pf_matrix + i),\r\nTVO_CSC_AUX_M0 + (i * 4));\r\n}\r\n}\r\nstatic void tvout_dvo_start(struct sti_tvout *tvout, bool main_path)\r\n{\r\nu32 tvo_in_vid_format;\r\nint val, tmp;\r\ndev_dbg(tvout->dev, "%s\n", __func__);\r\nif (main_path) {\r\nDRM_DEBUG_DRIVER("main vip for DVO\n");\r\ntmp = TVO_SYNC_MAIN_VTG_SET_REF | VTG_SYNC_ID_DVO;\r\nval = tmp << TVO_SYNC_DVO_PAD_VSYNC_SHIFT;\r\nval |= tmp << TVO_SYNC_DVO_PAD_HSYNC_SHIFT;\r\nval |= tmp;\r\ntvout_write(tvout, val, TVO_DVO_SYNC_SEL);\r\ntvo_in_vid_format = TVO_MAIN_IN_VID_FORMAT;\r\n} else {\r\nDRM_DEBUG_DRIVER("aux vip for DVO\n");\r\ntmp = TVO_SYNC_AUX_VTG_SET_REF | VTG_SYNC_ID_DVO;\r\nval = tmp << TVO_SYNC_DVO_PAD_VSYNC_SHIFT;\r\nval |= tmp << TVO_SYNC_DVO_PAD_HSYNC_SHIFT;\r\nval |= tmp;\r\ntvout_write(tvout, val, TVO_DVO_SYNC_SEL);\r\ntvo_in_vid_format = TVO_AUX_IN_VID_FORMAT;\r\n}\r\ntvout_vip_set_color_order(tvout, TVO_VIP_DVO,\r\nTVO_VIP_REORDER_CR_R_SEL,\r\nTVO_VIP_REORDER_Y_G_SEL,\r\nTVO_VIP_REORDER_CB_B_SEL);\r\ntvout_vip_set_clip_mode(tvout, TVO_VIP_DVO, TVO_VIP_CLIP_DISABLED);\r\ntvout_vip_set_rnd(tvout, TVO_VIP_DVO, TVO_VIP_RND_8BIT_ROUNDED);\r\ntvout_vip_set_in_vid_fmt(tvout, tvo_in_vid_format, TVO_IN_FMT_SIGNED);\r\ntvout_vip_set_sel_input(tvout, TVO_VIP_DVO, main_path,\r\nSTI_TVOUT_VIDEO_OUT_RGB);\r\n}\r\nstatic void tvout_hdmi_start(struct sti_tvout *tvout, bool main_path)\r\n{\r\nu32 tvo_in_vid_format;\r\ndev_dbg(tvout->dev, "%s\n", __func__);\r\nif (main_path) {\r\nDRM_DEBUG_DRIVER("main vip for hdmi\n");\r\ntvout_write(tvout,\r\nTVO_SYNC_MAIN_VTG_SET_REF | VTG_SYNC_ID_HDMI,\r\nTVO_HDMI_SYNC_SEL);\r\ntvo_in_vid_format = TVO_MAIN_IN_VID_FORMAT;\r\n} else {\r\nDRM_DEBUG_DRIVER("aux vip for hdmi\n");\r\ntvout_write(tvout,\r\nTVO_SYNC_AUX_VTG_SET_REF | VTG_SYNC_ID_HDMI,\r\nTVO_HDMI_SYNC_SEL);\r\ntvo_in_vid_format = TVO_AUX_IN_VID_FORMAT;\r\n}\r\ntvout_vip_set_color_order(tvout, TVO_VIP_HDMI,\r\nTVO_VIP_REORDER_CR_R_SEL,\r\nTVO_VIP_REORDER_Y_G_SEL,\r\nTVO_VIP_REORDER_CB_B_SEL);\r\ntvout_vip_set_clip_mode(tvout, TVO_VIP_HDMI, TVO_VIP_CLIP_DISABLED);\r\ntvout_vip_set_rnd(tvout, TVO_VIP_HDMI, TVO_VIP_RND_8BIT_ROUNDED);\r\ntvout_vip_set_in_vid_fmt(tvout, tvo_in_vid_format, TVO_IN_FMT_SIGNED);\r\ntvout_vip_set_sel_input(tvout, TVO_VIP_HDMI, main_path,\r\nSTI_TVOUT_VIDEO_OUT_RGB);\r\n}\r\nstatic void tvout_hda_start(struct sti_tvout *tvout, bool main_path)\r\n{\r\nu32 tvo_in_vid_format;\r\nint val;\r\ndev_dbg(tvout->dev, "%s\n", __func__);\r\nif (main_path) {\r\nDRM_DEBUG_DRIVER("main vip for HDF\n");\r\nval = TVO_SYNC_MAIN_VTG_SET_REF | VTG_SYNC_ID_HDDCS;\r\nval = val << TVO_SYNC_HD_DCS_SHIFT;\r\nval |= TVO_SYNC_MAIN_VTG_SET_REF | VTG_SYNC_ID_HDF;\r\ntvout_write(tvout, val, TVO_HD_SYNC_SEL);\r\ntvo_in_vid_format = TVO_MAIN_IN_VID_FORMAT;\r\n} else {\r\nDRM_DEBUG_DRIVER("aux vip for HDF\n");\r\nval = TVO_SYNC_AUX_VTG_SET_REF | VTG_SYNC_ID_HDDCS;\r\nval = val << TVO_SYNC_HD_DCS_SHIFT;\r\nval |= TVO_SYNC_AUX_VTG_SET_REF | VTG_SYNC_ID_HDF;\r\ntvout_write(tvout, val, TVO_HD_SYNC_SEL);\r\ntvo_in_vid_format = TVO_AUX_IN_VID_FORMAT;\r\n}\r\ntvout_vip_set_color_order(tvout, TVO_VIP_HDF,\r\nTVO_VIP_REORDER_CR_R_SEL,\r\nTVO_VIP_REORDER_Y_G_SEL,\r\nTVO_VIP_REORDER_CB_B_SEL);\r\ntvout_vip_set_clip_mode(tvout, TVO_VIP_HDF, TVO_VIP_CLIP_DISABLED);\r\ntvout_vip_set_rnd(tvout, TVO_VIP_HDF, TVO_VIP_RND_10BIT_ROUNDED);\r\ntvout_vip_set_in_vid_fmt(tvout, tvo_in_vid_format, TVO_IN_FMT_SIGNED);\r\ntvout_vip_set_sel_input(tvout, TVO_VIP_HDF, main_path,\r\nSTI_TVOUT_VIDEO_OUT_YUV);\r\ntvout_write(tvout, 0, TVO_HD_DAC_CFG_OFF);\r\n}\r\nstatic void tvout_dbg_vip(struct seq_file *s, int val)\r\n{\r\nint r, g, b, tmp, mask;\r\nchar *const reorder[] = {"Y_G", "Cb_B", "Cr_R"};\r\nchar *const clipping[] = {"No", "EAV/SAV", "Limited range RGB/Y",\r\n"Limited range Cb/Cr", "decided by register"};\r\nchar *const round[] = {"8-bit", "10-bit", "12-bit"};\r\nchar *const input_sel[] = {"Main (color matrix enabled)",\r\n"Main (color matrix by-passed)",\r\n"", "", "", "", "", "",\r\n"Aux (color matrix enabled)",\r\n"Aux (color matrix by-passed)",\r\n"", "", "", "", "", "Force value"};\r\nseq_putc(s, '\t');\r\nmask = TVO_VIP_REORDER_MASK << TVO_VIP_REORDER_R_SHIFT;\r\nr = (val & mask) >> TVO_VIP_REORDER_R_SHIFT;\r\nmask = TVO_VIP_REORDER_MASK << TVO_VIP_REORDER_G_SHIFT;\r\ng = (val & mask) >> TVO_VIP_REORDER_G_SHIFT;\r\nmask = TVO_VIP_REORDER_MASK << TVO_VIP_REORDER_B_SHIFT;\r\nb = (val & mask) >> TVO_VIP_REORDER_B_SHIFT;\r\nseq_printf(s, "%-24s %s->%s %s->%s %s->%s\n", "Reorder:",\r\nreorder[r], reorder[TVO_VIP_REORDER_CR_R_SEL],\r\nreorder[g], reorder[TVO_VIP_REORDER_Y_G_SEL],\r\nreorder[b], reorder[TVO_VIP_REORDER_CB_B_SEL]);\r\nseq_puts(s, "\t\t\t\t\t");\r\nmask = TVO_VIP_CLIP_MASK << TVO_VIP_CLIP_SHIFT;\r\ntmp = (val & mask) >> TVO_VIP_CLIP_SHIFT;\r\nseq_printf(s, "%-24s %s\n", "Clipping:", clipping[tmp]);\r\nseq_puts(s, "\t\t\t\t\t");\r\nmask = TVO_VIP_RND_MASK << TVO_VIP_RND_SHIFT;\r\ntmp = (val & mask) >> TVO_VIP_RND_SHIFT;\r\nseq_printf(s, "%-24s input data rounded to %s per component\n",\r\n"Round:", round[tmp]);\r\nseq_puts(s, "\t\t\t\t\t");\r\ntmp = (val & TVO_VIP_SEL_INPUT_MASK);\r\nseq_printf(s, "%-24s %s", "Input selection:", input_sel[tmp]);\r\n}\r\nstatic void tvout_dbg_hd_dac_cfg(struct seq_file *s, int val)\r\n{\r\nseq_printf(s, "\t%-24s %s", "HD DAC:",\r\nval & 1 ? "disabled" : "enabled");\r\n}\r\nstatic int tvout_dbg_show(struct seq_file *s, void *data)\r\n{\r\nstruct drm_info_node *node = s->private;\r\nstruct sti_tvout *tvout = (struct sti_tvout *)node->info_ent->data;\r\nstruct drm_crtc *crtc;\r\nseq_printf(s, "TVOUT: (vaddr = 0x%p)", tvout->regs);\r\nseq_puts(s, "\n\n HDMI encoder: ");\r\ncrtc = tvout->hdmi->crtc;\r\nif (crtc) {\r\nseq_printf(s, "connected to %s path",\r\nsti_crtc_is_main(crtc) ? "main" : "aux");\r\nDBGFS_DUMP(TVO_HDMI_SYNC_SEL);\r\nDBGFS_DUMP(TVO_VIP_HDMI);\r\ntvout_dbg_vip(s, readl(tvout->regs + TVO_VIP_HDMI));\r\n} else {\r\nseq_puts(s, "disabled");\r\n}\r\nseq_puts(s, "\n\n DVO encoder: ");\r\ncrtc = tvout->dvo->crtc;\r\nif (crtc) {\r\nseq_printf(s, "connected to %s path",\r\nsti_crtc_is_main(crtc) ? "main" : "aux");\r\nDBGFS_DUMP(TVO_DVO_SYNC_SEL);\r\nDBGFS_DUMP(TVO_DVO_CONFIG);\r\nDBGFS_DUMP(TVO_VIP_DVO);\r\ntvout_dbg_vip(s, readl(tvout->regs + TVO_VIP_DVO));\r\n} else {\r\nseq_puts(s, "disabled");\r\n}\r\nseq_puts(s, "\n\n HDA encoder: ");\r\ncrtc = tvout->hda->crtc;\r\nif (crtc) {\r\nseq_printf(s, "connected to %s path",\r\nsti_crtc_is_main(crtc) ? "main" : "aux");\r\nDBGFS_DUMP(TVO_HD_SYNC_SEL);\r\nDBGFS_DUMP(TVO_HD_DAC_CFG_OFF);\r\ntvout_dbg_hd_dac_cfg(s,\r\nreadl(tvout->regs + TVO_HD_DAC_CFG_OFF));\r\nDBGFS_DUMP(TVO_VIP_HDF);\r\ntvout_dbg_vip(s, readl(tvout->regs + TVO_VIP_HDF));\r\n} else {\r\nseq_puts(s, "disabled");\r\n}\r\nseq_puts(s, "\n\n main path configuration");\r\nDBGFS_DUMP(TVO_CSC_MAIN_M0);\r\nDBGFS_DUMP(TVO_CSC_MAIN_M1);\r\nDBGFS_DUMP(TVO_CSC_MAIN_M2);\r\nDBGFS_DUMP(TVO_CSC_MAIN_M3);\r\nDBGFS_DUMP(TVO_CSC_MAIN_M4);\r\nDBGFS_DUMP(TVO_CSC_MAIN_M5);\r\nDBGFS_DUMP(TVO_CSC_MAIN_M6);\r\nDBGFS_DUMP(TVO_CSC_MAIN_M7);\r\nDBGFS_DUMP(TVO_MAIN_IN_VID_FORMAT);\r\nseq_puts(s, "\n\n auxiliary path configuration");\r\nDBGFS_DUMP(TVO_CSC_AUX_M0);\r\nDBGFS_DUMP(TVO_CSC_AUX_M2);\r\nDBGFS_DUMP(TVO_CSC_AUX_M3);\r\nDBGFS_DUMP(TVO_CSC_AUX_M4);\r\nDBGFS_DUMP(TVO_CSC_AUX_M5);\r\nDBGFS_DUMP(TVO_CSC_AUX_M6);\r\nDBGFS_DUMP(TVO_CSC_AUX_M7);\r\nDBGFS_DUMP(TVO_AUX_IN_VID_FORMAT);\r\nseq_putc(s, '\n');\r\nreturn 0;\r\n}\r\nstatic int tvout_debugfs_init(struct sti_tvout *tvout, struct drm_minor *minor)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(tvout_debugfs_files); i++)\r\ntvout_debugfs_files[i].data = tvout;\r\nreturn drm_debugfs_create_files(tvout_debugfs_files,\r\nARRAY_SIZE(tvout_debugfs_files),\r\nminor->debugfs_root, minor);\r\n}\r\nstatic void sti_tvout_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\n}\r\nstatic void sti_tvout_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\n}\r\nstatic void sti_tvout_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout_encoder *sti_encoder = to_sti_tvout_encoder(encoder);\r\ndrm_encoder_cleanup(encoder);\r\nkfree(sti_encoder);\r\n}\r\nstatic int sti_tvout_late_register(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout *tvout = to_sti_tvout(encoder);\r\nint ret;\r\nif (tvout->debugfs_registered)\r\nreturn 0;\r\nret = tvout_debugfs_init(tvout, encoder->dev->primary);\r\nif (ret)\r\nreturn ret;\r\ntvout->debugfs_registered = true;\r\nreturn 0;\r\n}\r\nstatic void sti_tvout_early_unregister(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout *tvout = to_sti_tvout(encoder);\r\nif (!tvout->debugfs_registered)\r\nreturn;\r\ntvout->debugfs_registered = false;\r\n}\r\nstatic void sti_dvo_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout *tvout = to_sti_tvout(encoder);\r\ntvout_preformatter_set_matrix(tvout, &encoder->crtc->mode);\r\ntvout_dvo_start(tvout, sti_crtc_is_main(encoder->crtc));\r\n}\r\nstatic void sti_dvo_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout *tvout = to_sti_tvout(encoder);\r\ntvout_write(tvout, 0x0, TVO_VIP_DVO);\r\n}\r\nstatic struct drm_encoder *\r\nsti_tvout_create_dvo_encoder(struct drm_device *dev,\r\nstruct sti_tvout *tvout)\r\n{\r\nstruct sti_tvout_encoder *encoder;\r\nstruct drm_encoder *drm_encoder;\r\nencoder = devm_kzalloc(tvout->dev, sizeof(*encoder), GFP_KERNEL);\r\nif (!encoder)\r\nreturn NULL;\r\nencoder->tvout = tvout;\r\ndrm_encoder = (struct drm_encoder *)encoder;\r\ndrm_encoder->possible_crtcs = ENCODER_CRTC_MASK;\r\ndrm_encoder->possible_clones = 1 << 0;\r\ndrm_encoder_init(dev, drm_encoder,\r\n&sti_tvout_encoder_funcs, DRM_MODE_ENCODER_LVDS,\r\nNULL);\r\ndrm_encoder_helper_add(drm_encoder, &sti_dvo_encoder_helper_funcs);\r\nreturn drm_encoder;\r\n}\r\nstatic void sti_hda_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout *tvout = to_sti_tvout(encoder);\r\ntvout_preformatter_set_matrix(tvout, &encoder->crtc->mode);\r\ntvout_hda_start(tvout, sti_crtc_is_main(encoder->crtc));\r\n}\r\nstatic void sti_hda_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout *tvout = to_sti_tvout(encoder);\r\ntvout_write(tvout, 0x0, TVO_VIP_HDF);\r\ntvout_write(tvout, 1, TVO_HD_DAC_CFG_OFF);\r\n}\r\nstatic struct drm_encoder *sti_tvout_create_hda_encoder(struct drm_device *dev,\r\nstruct sti_tvout *tvout)\r\n{\r\nstruct sti_tvout_encoder *encoder;\r\nstruct drm_encoder *drm_encoder;\r\nencoder = devm_kzalloc(tvout->dev, sizeof(*encoder), GFP_KERNEL);\r\nif (!encoder)\r\nreturn NULL;\r\nencoder->tvout = tvout;\r\ndrm_encoder = (struct drm_encoder *) encoder;\r\ndrm_encoder->possible_crtcs = ENCODER_CRTC_MASK;\r\ndrm_encoder->possible_clones = 1 << 0;\r\ndrm_encoder_init(dev, drm_encoder,\r\n&sti_tvout_encoder_funcs, DRM_MODE_ENCODER_DAC, NULL);\r\ndrm_encoder_helper_add(drm_encoder, &sti_hda_encoder_helper_funcs);\r\nreturn drm_encoder;\r\n}\r\nstatic void sti_hdmi_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout *tvout = to_sti_tvout(encoder);\r\ntvout_preformatter_set_matrix(tvout, &encoder->crtc->mode);\r\ntvout_hdmi_start(tvout, sti_crtc_is_main(encoder->crtc));\r\n}\r\nstatic void sti_hdmi_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout *tvout = to_sti_tvout(encoder);\r\ntvout_write(tvout, 0x0, TVO_VIP_HDMI);\r\n}\r\nstatic struct drm_encoder *sti_tvout_create_hdmi_encoder(struct drm_device *dev,\r\nstruct sti_tvout *tvout)\r\n{\r\nstruct sti_tvout_encoder *encoder;\r\nstruct drm_encoder *drm_encoder;\r\nencoder = devm_kzalloc(tvout->dev, sizeof(*encoder), GFP_KERNEL);\r\nif (!encoder)\r\nreturn NULL;\r\nencoder->tvout = tvout;\r\ndrm_encoder = (struct drm_encoder *) encoder;\r\ndrm_encoder->possible_crtcs = ENCODER_CRTC_MASK;\r\ndrm_encoder->possible_clones = 1 << 1;\r\ndrm_encoder_init(dev, drm_encoder,\r\n&sti_tvout_encoder_funcs, DRM_MODE_ENCODER_TMDS, NULL);\r\ndrm_encoder_helper_add(drm_encoder, &sti_hdmi_encoder_helper_funcs);\r\nreturn drm_encoder;\r\n}\r\nstatic void sti_tvout_create_encoders(struct drm_device *dev,\r\nstruct sti_tvout *tvout)\r\n{\r\ntvout->hdmi = sti_tvout_create_hdmi_encoder(dev, tvout);\r\ntvout->hda = sti_tvout_create_hda_encoder(dev, tvout);\r\ntvout->dvo = sti_tvout_create_dvo_encoder(dev, tvout);\r\n}\r\nstatic void sti_tvout_destroy_encoders(struct sti_tvout *tvout)\r\n{\r\nif (tvout->hdmi)\r\ndrm_encoder_cleanup(tvout->hdmi);\r\ntvout->hdmi = NULL;\r\nif (tvout->hda)\r\ndrm_encoder_cleanup(tvout->hda);\r\ntvout->hda = NULL;\r\nif (tvout->dvo)\r\ndrm_encoder_cleanup(tvout->dvo);\r\ntvout->dvo = NULL;\r\n}\r\nstatic int sti_tvout_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct sti_tvout *tvout = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\ntvout->drm_dev = drm_dev;\r\nsti_tvout_create_encoders(drm_dev, tvout);\r\nreturn 0;\r\n}\r\nstatic void sti_tvout_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct sti_tvout *tvout = dev_get_drvdata(dev);\r\nsti_tvout_destroy_encoders(tvout);\r\n}\r\nstatic int sti_tvout_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct sti_tvout *tvout;\r\nstruct resource *res;\r\nDRM_INFO("%s\n", __func__);\r\nif (!node)\r\nreturn -ENODEV;\r\ntvout = devm_kzalloc(dev, sizeof(*tvout), GFP_KERNEL);\r\nif (!tvout)\r\nreturn -ENOMEM;\r\ntvout->dev = dev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "tvout-reg");\r\nif (!res) {\r\nDRM_ERROR("Invalid glue resource\n");\r\nreturn -ENOMEM;\r\n}\r\ntvout->regs = devm_ioremap_nocache(dev, res->start, resource_size(res));\r\nif (!tvout->regs)\r\nreturn -ENOMEM;\r\ntvout->reset = devm_reset_control_get(dev, "tvout");\r\nif (!IS_ERR(tvout->reset))\r\nreset_control_deassert(tvout->reset);\r\nplatform_set_drvdata(pdev, tvout);\r\nreturn component_add(dev, &sti_tvout_ops);\r\n}\r\nstatic int sti_tvout_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &sti_tvout_ops);\r\nreturn 0;\r\n}
