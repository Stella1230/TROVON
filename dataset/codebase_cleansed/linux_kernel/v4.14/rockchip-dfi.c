static void rockchip_dfi_start_hardware_counter(struct devfreq_event_dev *edev)\r\n{\r\nstruct rockchip_dfi *info = devfreq_event_get_drvdata(edev);\r\nvoid __iomem *dfi_regs = info->regs;\r\nu32 val;\r\nu32 ddr_type;\r\nregmap_read(info->regmap_pmu, PMUGRF_OS_REG2, &val);\r\nddr_type = (val >> DDRTYPE_SHIFT) & DDRTYPE_MASK;\r\nwritel_relaxed(CLR_DDRMON_CTRL, dfi_regs + DDRMON_CTRL);\r\nif (ddr_type == LPDDR3)\r\nwritel_relaxed(LPDDR3_EN, dfi_regs + DDRMON_CTRL);\r\nelse if (ddr_type == LPDDR4)\r\nwritel_relaxed(LPDDR4_EN, dfi_regs + DDRMON_CTRL);\r\nwritel_relaxed(SOFTWARE_EN, dfi_regs + DDRMON_CTRL);\r\n}\r\nstatic void rockchip_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)\r\n{\r\nstruct rockchip_dfi *info = devfreq_event_get_drvdata(edev);\r\nvoid __iomem *dfi_regs = info->regs;\r\nwritel_relaxed(SOFTWARE_DIS, dfi_regs + DDRMON_CTRL);\r\n}\r\nstatic int rockchip_dfi_get_busier_ch(struct devfreq_event_dev *edev)\r\n{\r\nstruct rockchip_dfi *info = devfreq_event_get_drvdata(edev);\r\nu32 tmp, max = 0;\r\nu32 i, busier_ch = 0;\r\nvoid __iomem *dfi_regs = info->regs;\r\nrockchip_dfi_stop_hardware_counter(edev);\r\nfor (i = 0; i < RK3399_DMC_NUM_CH; i++) {\r\ninfo->ch_usage[i].access = readl_relaxed(dfi_regs +\r\nDDRMON_CH0_DFI_ACCESS_NUM + i * 20) * 4;\r\ninfo->ch_usage[i].total = readl_relaxed(dfi_regs +\r\nDDRMON_CH0_COUNT_NUM + i * 20);\r\ntmp = info->ch_usage[i].access;\r\nif (tmp > max) {\r\nbusier_ch = i;\r\nmax = tmp;\r\n}\r\n}\r\nrockchip_dfi_start_hardware_counter(edev);\r\nreturn busier_ch;\r\n}\r\nstatic int rockchip_dfi_disable(struct devfreq_event_dev *edev)\r\n{\r\nstruct rockchip_dfi *info = devfreq_event_get_drvdata(edev);\r\nrockchip_dfi_stop_hardware_counter(edev);\r\nclk_disable_unprepare(info->clk);\r\nreturn 0;\r\n}\r\nstatic int rockchip_dfi_enable(struct devfreq_event_dev *edev)\r\n{\r\nstruct rockchip_dfi *info = devfreq_event_get_drvdata(edev);\r\nint ret;\r\nret = clk_prepare_enable(info->clk);\r\nif (ret) {\r\ndev_err(&edev->dev, "failed to enable dfi clk: %d\n", ret);\r\nreturn ret;\r\n}\r\nrockchip_dfi_start_hardware_counter(edev);\r\nreturn 0;\r\n}\r\nstatic int rockchip_dfi_set_event(struct devfreq_event_dev *edev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int rockchip_dfi_get_event(struct devfreq_event_dev *edev,\r\nstruct devfreq_event_data *edata)\r\n{\r\nstruct rockchip_dfi *info = devfreq_event_get_drvdata(edev);\r\nint busier_ch;\r\nbusier_ch = rockchip_dfi_get_busier_ch(edev);\r\nedata->load_count = info->ch_usage[busier_ch].access;\r\nedata->total_count = info->ch_usage[busier_ch].total;\r\nreturn 0;\r\n}\r\nstatic int rockchip_dfi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct rockchip_dfi *data;\r\nstruct resource *res;\r\nstruct devfreq_event_desc *desc;\r\nstruct device_node *np = pdev->dev.of_node, *node;\r\ndata = devm_kzalloc(dev, sizeof(struct rockchip_dfi), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndata->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(data->regs))\r\nreturn PTR_ERR(data->regs);\r\ndata->clk = devm_clk_get(dev, "pclk_ddr_mon");\r\nif (IS_ERR(data->clk)) {\r\ndev_err(dev, "Cannot get the clk dmc_clk\n");\r\nreturn PTR_ERR(data->clk);\r\n};\r\nnode = of_parse_phandle(np, "rockchip,pmu", 0);\r\nif (node) {\r\ndata->regmap_pmu = syscon_node_to_regmap(node);\r\nif (IS_ERR(data->regmap_pmu))\r\nreturn PTR_ERR(data->regmap_pmu);\r\n}\r\ndata->dev = dev;\r\ndesc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);\r\nif (!desc)\r\nreturn -ENOMEM;\r\ndesc->ops = &rockchip_dfi_ops;\r\ndesc->driver_data = data;\r\ndesc->name = np->name;\r\ndata->desc = desc;\r\ndata->edev = devm_devfreq_event_add_edev(&pdev->dev, desc);\r\nif (IS_ERR(data->edev)) {\r\ndev_err(&pdev->dev,\r\n"failed to add devfreq-event device\n");\r\nreturn PTR_ERR(data->edev);\r\n}\r\nplatform_set_drvdata(pdev, data);\r\nreturn 0;\r\n}
