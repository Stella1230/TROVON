static int temp_from_reg_unsigned(u8 val_h, u8 val_l)\r\n{\r\nreturn val_h * 1000 + val_l * 1000 / 256;\r\n}\r\nstatic int temp_from_reg_signed(u8 val_h, u8 val_l)\r\n{\r\nif (val_h & 0x80)\r\nreturn (val_h - 0x100) * 1000;\r\nreturn temp_from_reg_unsigned(val_h, val_l);\r\n}\r\nstatic int lm95245_read_conversion_rate(struct lm95245_data *data)\r\n{\r\nunsigned int rate;\r\nint ret;\r\nret = regmap_read(data->regmap, LM95245_REG_RW_CONVERS_RATE, &rate);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (rate) {\r\ncase RATE_CR0063:\r\ndata->interval = 63;\r\nbreak;\r\ncase RATE_CR0364:\r\ndata->interval = 364;\r\nbreak;\r\ncase RATE_CR1000:\r\ndata->interval = 1000;\r\nbreak;\r\ncase RATE_CR2500:\r\ndefault:\r\ndata->interval = 2500;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lm95245_set_conversion_rate(struct lm95245_data *data, long interval)\r\n{\r\nint ret, rate;\r\nif (interval <= 63) {\r\ninterval = 63;\r\nrate = RATE_CR0063;\r\n} else if (interval <= 364) {\r\ninterval = 364;\r\nrate = RATE_CR0364;\r\n} else if (interval <= 1000) {\r\ninterval = 1000;\r\nrate = RATE_CR1000;\r\n} else {\r\ninterval = 2500;\r\nrate = RATE_CR2500;\r\n}\r\nret = regmap_write(data->regmap, LM95245_REG_RW_CONVERS_RATE, rate);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->interval = interval;\r\nreturn 0;\r\n}\r\nstatic int lm95245_read_temp(struct device *dev, u32 attr, int channel,\r\nlong *val)\r\n{\r\nstruct lm95245_data *data = dev_get_drvdata(dev);\r\nstruct regmap *regmap = data->regmap;\r\nint ret, regl, regh, regvall, regvalh;\r\nswitch (attr) {\r\ncase hwmon_temp_input:\r\nregl = channel ? LM95245_REG_R_REMOTE_TEMPL_S :\r\nLM95245_REG_R_LOCAL_TEMPL_S;\r\nregh = channel ? LM95245_REG_R_REMOTE_TEMPH_S :\r\nLM95245_REG_R_LOCAL_TEMPH_S;\r\nret = regmap_read(regmap, regl, &regvall);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_read(regmap, regh, &regvalh);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!channel || (regvalh & 0x80) || regvalh < 0x7f) {\r\n*val = temp_from_reg_signed(regvalh, regvall);\r\nreturn 0;\r\n}\r\nret = regmap_read(regmap, LM95245_REG_R_REMOTE_TEMPL_U,\r\n&regvall);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_read(regmap, LM95245_REG_R_REMOTE_TEMPH_U,\r\n&regvalh);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = temp_from_reg_unsigned(regvalh, regvall);\r\nreturn 0;\r\ncase hwmon_temp_max:\r\nret = regmap_read(regmap, LM95245_REG_RW_REMOTE_OS_LIMIT,\r\n&regvalh);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = regvalh * 1000;\r\nreturn 0;\r\ncase hwmon_temp_crit:\r\nregh = channel ? LM95245_REG_RW_REMOTE_TCRIT_LIMIT :\r\nLM95245_REG_RW_LOCAL_OS_TCRIT_LIMIT;\r\nret = regmap_read(regmap, regh, &regvalh);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = regvalh * 1000;\r\nreturn 0;\r\ncase hwmon_temp_max_hyst:\r\nret = regmap_read(regmap, LM95245_REG_RW_REMOTE_OS_LIMIT,\r\n&regvalh);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_read(regmap, LM95245_REG_RW_COMMON_HYSTERESIS,\r\n&regvall);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = (regvalh - regvall) * 1000;\r\nreturn 0;\r\ncase hwmon_temp_crit_hyst:\r\nregh = channel ? LM95245_REG_RW_REMOTE_TCRIT_LIMIT :\r\nLM95245_REG_RW_LOCAL_OS_TCRIT_LIMIT;\r\nret = regmap_read(regmap, regh, &regvalh);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_read(regmap, LM95245_REG_RW_COMMON_HYSTERESIS,\r\n&regvall);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = (regvalh - regvall) * 1000;\r\nreturn 0;\r\ncase hwmon_temp_type:\r\nret = regmap_read(regmap, LM95245_REG_RW_CONFIG2, &regvalh);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = (regvalh & CFG2_REMOTE_TT) ? 1 : 2;\r\nreturn 0;\r\ncase hwmon_temp_offset:\r\nret = regmap_read(regmap, LM95245_REG_RW_REMOTE_OFFL,\r\n&regvall);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_read(regmap, LM95245_REG_RW_REMOTE_OFFH,\r\n&regvalh);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = temp_from_reg_signed(regvalh, regvall);\r\nreturn 0;\r\ncase hwmon_temp_max_alarm:\r\nret = regmap_read(regmap, LM95245_REG_R_STATUS1, &regvalh);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = !!(regvalh & STATUS1_ROS);\r\nreturn 0;\r\ncase hwmon_temp_crit_alarm:\r\nret = regmap_read(regmap, LM95245_REG_R_STATUS1, &regvalh);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = !!(regvalh & (channel ? STATUS1_RTCRIT : STATUS1_LOC));\r\nreturn 0;\r\ncase hwmon_temp_fault:\r\nret = regmap_read(regmap, LM95245_REG_R_STATUS1, &regvalh);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = !!(regvalh & STATUS1_DIODE_FAULT);\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int lm95245_write_temp(struct device *dev, u32 attr, int channel,\r\nlong val)\r\n{\r\nstruct lm95245_data *data = dev_get_drvdata(dev);\r\nstruct regmap *regmap = data->regmap;\r\nunsigned int regval;\r\nint ret, reg;\r\nswitch (attr) {\r\ncase hwmon_temp_max:\r\nval = clamp_val(val / 1000, 0, 255);\r\nret = regmap_write(regmap, LM95245_REG_RW_REMOTE_OS_LIMIT, val);\r\nreturn ret;\r\ncase hwmon_temp_crit:\r\nreg = channel ? LM95245_REG_RW_REMOTE_TCRIT_LIMIT :\r\nLM95245_REG_RW_LOCAL_OS_TCRIT_LIMIT;\r\nval = clamp_val(val / 1000, 0, channel ? 255 : 127);\r\nret = regmap_write(regmap, reg, val);\r\nreturn ret;\r\ncase hwmon_temp_crit_hyst:\r\nmutex_lock(&data->update_lock);\r\nret = regmap_read(regmap, LM95245_REG_RW_LOCAL_OS_TCRIT_LIMIT,\r\n&regval);\r\nif (ret < 0) {\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nval = clamp_val(val, -1000000, 1000000);\r\nval = regval - val / 1000;\r\nval = clamp_val(val, 0, 31);\r\nret = regmap_write(regmap, LM95245_REG_RW_COMMON_HYSTERESIS,\r\nval);\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\ncase hwmon_temp_offset:\r\nval = clamp_val(val, -128000, 127875);\r\nval = val * 256 / 1000;\r\nmutex_lock(&data->update_lock);\r\nret = regmap_write(regmap, LM95245_REG_RW_REMOTE_OFFL,\r\nval & 0xe0);\r\nif (ret < 0) {\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nret = regmap_write(regmap, LM95245_REG_RW_REMOTE_OFFH,\r\n(val >> 8) & 0xff);\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\ncase hwmon_temp_type:\r\nif (val != 1 && val != 2)\r\nreturn -EINVAL;\r\nret = regmap_update_bits(regmap, LM95245_REG_RW_CONFIG2,\r\nCFG2_REMOTE_TT,\r\nval == 1 ? CFG2_REMOTE_TT : 0);\r\nreturn ret;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int lm95245_read_chip(struct device *dev, u32 attr, int channel,\r\nlong *val)\r\n{\r\nstruct lm95245_data *data = dev_get_drvdata(dev);\r\nswitch (attr) {\r\ncase hwmon_chip_update_interval:\r\n*val = data->interval;\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int lm95245_write_chip(struct device *dev, u32 attr, int channel,\r\nlong val)\r\n{\r\nstruct lm95245_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nswitch (attr) {\r\ncase hwmon_chip_update_interval:\r\nmutex_lock(&data->update_lock);\r\nret = lm95245_set_conversion_rate(data, val);\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int lm95245_read(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long *val)\r\n{\r\nswitch (type) {\r\ncase hwmon_chip:\r\nreturn lm95245_read_chip(dev, attr, channel, val);\r\ncase hwmon_temp:\r\nreturn lm95245_read_temp(dev, attr, channel, val);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int lm95245_write(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long val)\r\n{\r\nswitch (type) {\r\ncase hwmon_chip:\r\nreturn lm95245_write_chip(dev, attr, channel, val);\r\ncase hwmon_temp:\r\nreturn lm95245_write_temp(dev, attr, channel, val);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic umode_t lm95245_temp_is_visible(const void *data, u32 attr, int channel)\r\n{\r\nswitch (attr) {\r\ncase hwmon_temp_input:\r\ncase hwmon_temp_max_alarm:\r\ncase hwmon_temp_max_hyst:\r\ncase hwmon_temp_crit_alarm:\r\ncase hwmon_temp_fault:\r\nreturn S_IRUGO;\r\ncase hwmon_temp_type:\r\ncase hwmon_temp_max:\r\ncase hwmon_temp_crit:\r\ncase hwmon_temp_offset:\r\nreturn S_IRUGO | S_IWUSR;\r\ncase hwmon_temp_crit_hyst:\r\nreturn (channel == 0) ? S_IRUGO | S_IWUSR : S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic umode_t lm95245_is_visible(const void *data,\r\nenum hwmon_sensor_types type,\r\nu32 attr, int channel)\r\n{\r\nswitch (type) {\r\ncase hwmon_chip:\r\nswitch (attr) {\r\ncase hwmon_chip_update_interval:\r\nreturn S_IRUGO | S_IWUSR;\r\ndefault:\r\nreturn 0;\r\n}\r\ncase hwmon_temp:\r\nreturn lm95245_temp_is_visible(data, attr, channel);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int lm95245_detect(struct i2c_client *new_client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = new_client->adapter;\r\nint address = new_client->addr;\r\nconst char *name;\r\nint rev, id;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nid = i2c_smbus_read_byte_data(new_client, LM95245_REG_R_MAN_ID);\r\nif (id != MANUFACTURER_ID)\r\nreturn -ENODEV;\r\nrev = i2c_smbus_read_byte_data(new_client, LM95245_REG_R_CHIP_ID);\r\nswitch (rev) {\r\ncase LM95235_REVISION:\r\nif (address != 0x18 && address != 0x29 && address != 0x4c)\r\nreturn -ENODEV;\r\nname = "lm95235";\r\nbreak;\r\ncase LM95245_REVISION:\r\nname = "lm95245";\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(info->type, name, I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int lm95245_init_client(struct lm95245_data *data)\r\n{\r\nint ret;\r\nret = lm95245_read_conversion_rate(data);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn regmap_update_bits(data->regmap, LM95245_REG_RW_CONFIG1,\r\nCFG_STOP, 0);\r\n}\r\nstatic bool lm95245_is_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase LM95245_REG_RW_CONFIG1:\r\ncase LM95245_REG_RW_CONVERS_RATE:\r\ncase LM95245_REG_W_ONE_SHOT:\r\ncase LM95245_REG_RW_CONFIG2:\r\ncase LM95245_REG_RW_REMOTE_OFFH:\r\ncase LM95245_REG_RW_REMOTE_OFFL:\r\ncase LM95245_REG_RW_REMOTE_OS_LIMIT:\r\ncase LM95245_REG_RW_LOCAL_OS_TCRIT_LIMIT:\r\ncase LM95245_REG_RW_REMOTE_TCRIT_LIMIT:\r\ncase LM95245_REG_RW_COMMON_HYSTERESIS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool lm95245_is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase LM95245_REG_R_STATUS1:\r\ncase LM95245_REG_R_STATUS2:\r\ncase LM95245_REG_R_LOCAL_TEMPH_S:\r\ncase LM95245_REG_R_LOCAL_TEMPL_S:\r\ncase LM95245_REG_R_REMOTE_TEMPH_S:\r\ncase LM95245_REG_R_REMOTE_TEMPL_S:\r\ncase LM95245_REG_R_REMOTE_TEMPH_U:\r\ncase LM95245_REG_R_REMOTE_TEMPL_U:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int lm95245_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct lm95245_data *data;\r\nstruct device *hwmon_dev;\r\nint ret;\r\ndata = devm_kzalloc(dev, sizeof(struct lm95245_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->regmap = devm_regmap_init_i2c(client, &lm95245_regmap_config);\r\nif (IS_ERR(data->regmap))\r\nreturn PTR_ERR(data->regmap);\r\nmutex_init(&data->update_lock);\r\nret = lm95245_init_client(data);\r\nif (ret < 0)\r\nreturn ret;\r\nhwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\r\ndata,\r\n&lm95245_chip_info,\r\nNULL);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
