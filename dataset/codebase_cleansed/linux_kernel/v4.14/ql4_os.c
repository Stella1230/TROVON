static int qla4xxx_send_ping(struct Scsi_Host *shost, uint32_t iface_num,\r\nuint32_t iface_type, uint32_t payload_size,\r\nuint32_t pid, struct sockaddr *dst_addr)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nstruct sockaddr_in *addr;\r\nstruct sockaddr_in6 *addr6;\r\nuint32_t options = 0;\r\nuint8_t ipaddr[IPv6_ADDR_LEN];\r\nint rval;\r\nmemset(ipaddr, 0, IPv6_ADDR_LEN);\r\nif ((iface_type == ISCSI_IFACE_TYPE_IPV4) &&\r\n(dst_addr->sa_family == AF_INET)) {\r\naddr = (struct sockaddr_in *)dst_addr;\r\nmemcpy(ipaddr, &addr->sin_addr.s_addr, IP_ADDR_LEN);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: IPv4 Ping src: %pI4 "\r\n"dest: %pI4\n", __func__,\r\n&ha->ip_config.ip_address, ipaddr));\r\nrval = qla4xxx_ping_iocb(ha, options, payload_size, pid,\r\nipaddr);\r\nif (rval)\r\nrval = -EINVAL;\r\n} else if ((iface_type == ISCSI_IFACE_TYPE_IPV6) &&\r\n(dst_addr->sa_family == AF_INET6)) {\r\naddr6 = (struct sockaddr_in6 *)dst_addr;\r\nmemcpy(ipaddr, &addr6->sin6_addr.in6_u.u6_addr8, IPv6_ADDR_LEN);\r\noptions |= PING_IPV6_PROTOCOL_ENABLE;\r\nif ((iface_num == 0) || (iface_num == 1)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: LinkLocal Ping "\r\n"src: %pI6 dest: %pI6\n", __func__,\r\n&ha->ip_config.ipv6_link_local_addr,\r\nipaddr));\r\noptions |= PING_IPV6_LINKLOCAL_ADDR;\r\nrval = qla4xxx_ping_iocb(ha, options, payload_size,\r\npid, ipaddr);\r\n} else {\r\nql4_printk(KERN_WARNING, ha, "%s: iface num = %d "\r\n"not supported\n", __func__, iface_num);\r\nrval = -ENOSYS;\r\ngoto exit_send_ping;\r\n}\r\nif (rval != QLA_SUCCESS) {\r\noptions &= ~PING_IPV6_LINKLOCAL_ADDR;\r\nif (iface_num == 0) {\r\noptions |= PING_IPV6_ADDR0;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: IPv6 "\r\n"Ping src: %pI6 "\r\n"dest: %pI6\n", __func__,\r\n&ha->ip_config.ipv6_addr0,\r\nipaddr));\r\n} else if (iface_num == 1) {\r\noptions |= PING_IPV6_ADDR1;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: IPv6 "\r\n"Ping src: %pI6 "\r\n"dest: %pI6\n", __func__,\r\n&ha->ip_config.ipv6_addr1,\r\nipaddr));\r\n}\r\nrval = qla4xxx_ping_iocb(ha, options, payload_size,\r\npid, ipaddr);\r\nif (rval)\r\nrval = -EINVAL;\r\n}\r\n} else\r\nrval = -ENOSYS;\r\nexit_send_ping:\r\nreturn rval;\r\n}\r\nstatic umode_t qla4_attr_is_visible(int param_type, int param)\r\n{\r\nswitch (param_type) {\r\ncase ISCSI_HOST_PARAM:\r\nswitch (param) {\r\ncase ISCSI_HOST_PARAM_HWADDRESS:\r\ncase ISCSI_HOST_PARAM_IPADDRESS:\r\ncase ISCSI_HOST_PARAM_INITIATOR_NAME:\r\ncase ISCSI_HOST_PARAM_PORT_STATE:\r\ncase ISCSI_HOST_PARAM_PORT_SPEED:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\ncase ISCSI_PARAM:\r\nswitch (param) {\r\ncase ISCSI_PARAM_PERSISTENT_ADDRESS:\r\ncase ISCSI_PARAM_PERSISTENT_PORT:\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\ncase ISCSI_PARAM_CONN_PORT:\r\ncase ISCSI_PARAM_TARGET_NAME:\r\ncase ISCSI_PARAM_TPGT:\r\ncase ISCSI_PARAM_TARGET_ALIAS:\r\ncase ISCSI_PARAM_MAX_BURST:\r\ncase ISCSI_PARAM_MAX_R2T:\r\ncase ISCSI_PARAM_FIRST_BURST:\r\ncase ISCSI_PARAM_MAX_RECV_DLENGTH:\r\ncase ISCSI_PARAM_MAX_XMIT_DLENGTH:\r\ncase ISCSI_PARAM_IFACE_NAME:\r\ncase ISCSI_PARAM_CHAP_OUT_IDX:\r\ncase ISCSI_PARAM_CHAP_IN_IDX:\r\ncase ISCSI_PARAM_USERNAME:\r\ncase ISCSI_PARAM_PASSWORD:\r\ncase ISCSI_PARAM_USERNAME_IN:\r\ncase ISCSI_PARAM_PASSWORD_IN:\r\ncase ISCSI_PARAM_AUTO_SND_TGT_DISABLE:\r\ncase ISCSI_PARAM_DISCOVERY_SESS:\r\ncase ISCSI_PARAM_PORTAL_TYPE:\r\ncase ISCSI_PARAM_CHAP_AUTH_EN:\r\ncase ISCSI_PARAM_DISCOVERY_LOGOUT_EN:\r\ncase ISCSI_PARAM_BIDI_CHAP_EN:\r\ncase ISCSI_PARAM_DISCOVERY_AUTH_OPTIONAL:\r\ncase ISCSI_PARAM_DEF_TIME2WAIT:\r\ncase ISCSI_PARAM_DEF_TIME2RETAIN:\r\ncase ISCSI_PARAM_HDRDGST_EN:\r\ncase ISCSI_PARAM_DATADGST_EN:\r\ncase ISCSI_PARAM_INITIAL_R2T_EN:\r\ncase ISCSI_PARAM_IMM_DATA_EN:\r\ncase ISCSI_PARAM_PDU_INORDER_EN:\r\ncase ISCSI_PARAM_DATASEQ_INORDER_EN:\r\ncase ISCSI_PARAM_MAX_SEGMENT_SIZE:\r\ncase ISCSI_PARAM_TCP_TIMESTAMP_STAT:\r\ncase ISCSI_PARAM_TCP_WSF_DISABLE:\r\ncase ISCSI_PARAM_TCP_NAGLE_DISABLE:\r\ncase ISCSI_PARAM_TCP_TIMER_SCALE:\r\ncase ISCSI_PARAM_TCP_TIMESTAMP_EN:\r\ncase ISCSI_PARAM_TCP_XMIT_WSF:\r\ncase ISCSI_PARAM_TCP_RECV_WSF:\r\ncase ISCSI_PARAM_IP_FRAGMENT_DISABLE:\r\ncase ISCSI_PARAM_IPV4_TOS:\r\ncase ISCSI_PARAM_IPV6_TC:\r\ncase ISCSI_PARAM_IPV6_FLOW_LABEL:\r\ncase ISCSI_PARAM_IS_FW_ASSIGNED_IPV6:\r\ncase ISCSI_PARAM_KEEPALIVE_TMO:\r\ncase ISCSI_PARAM_LOCAL_PORT:\r\ncase ISCSI_PARAM_ISID:\r\ncase ISCSI_PARAM_TSID:\r\ncase ISCSI_PARAM_DEF_TASKMGMT_TMO:\r\ncase ISCSI_PARAM_ERL:\r\ncase ISCSI_PARAM_STATSN:\r\ncase ISCSI_PARAM_EXP_STATSN:\r\ncase ISCSI_PARAM_DISCOVERY_PARENT_IDX:\r\ncase ISCSI_PARAM_DISCOVERY_PARENT_TYPE:\r\ncase ISCSI_PARAM_LOCAL_IPADDR:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\ncase ISCSI_NET_PARAM:\r\nswitch (param) {\r\ncase ISCSI_NET_PARAM_IPV4_ADDR:\r\ncase ISCSI_NET_PARAM_IPV4_SUBNET:\r\ncase ISCSI_NET_PARAM_IPV4_GW:\r\ncase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\r\ncase ISCSI_NET_PARAM_IFACE_ENABLE:\r\ncase ISCSI_NET_PARAM_IPV6_LINKLOCAL:\r\ncase ISCSI_NET_PARAM_IPV6_ADDR:\r\ncase ISCSI_NET_PARAM_IPV6_ROUTER:\r\ncase ISCSI_NET_PARAM_IPV6_ADDR_AUTOCFG:\r\ncase ISCSI_NET_PARAM_IPV6_LINKLOCAL_AUTOCFG:\r\ncase ISCSI_NET_PARAM_VLAN_ID:\r\ncase ISCSI_NET_PARAM_VLAN_PRIORITY:\r\ncase ISCSI_NET_PARAM_VLAN_ENABLED:\r\ncase ISCSI_NET_PARAM_MTU:\r\ncase ISCSI_NET_PARAM_PORT:\r\ncase ISCSI_NET_PARAM_IPADDR_STATE:\r\ncase ISCSI_NET_PARAM_IPV6_LINKLOCAL_STATE:\r\ncase ISCSI_NET_PARAM_IPV6_ROUTER_STATE:\r\ncase ISCSI_NET_PARAM_DELAYED_ACK_EN:\r\ncase ISCSI_NET_PARAM_TCP_NAGLE_DISABLE:\r\ncase ISCSI_NET_PARAM_TCP_WSF_DISABLE:\r\ncase ISCSI_NET_PARAM_TCP_WSF:\r\ncase ISCSI_NET_PARAM_TCP_TIMER_SCALE:\r\ncase ISCSI_NET_PARAM_TCP_TIMESTAMP_EN:\r\ncase ISCSI_NET_PARAM_CACHE_ID:\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_DNS_ADDR_EN:\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_SLP_DA_EN:\r\ncase ISCSI_NET_PARAM_IPV4_TOS_EN:\r\ncase ISCSI_NET_PARAM_IPV4_TOS:\r\ncase ISCSI_NET_PARAM_IPV4_GRAT_ARP_EN:\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID_EN:\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID:\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_REQ_VENDOR_ID_EN:\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_USE_VENDOR_ID_EN:\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_VENDOR_ID:\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_LEARN_IQN_EN:\r\ncase ISCSI_NET_PARAM_IPV4_FRAGMENT_DISABLE:\r\ncase ISCSI_NET_PARAM_IPV4_IN_FORWARD_EN:\r\ncase ISCSI_NET_PARAM_REDIRECT_EN:\r\ncase ISCSI_NET_PARAM_IPV4_TTL:\r\ncase ISCSI_NET_PARAM_IPV6_GRAT_NEIGHBOR_ADV_EN:\r\ncase ISCSI_NET_PARAM_IPV6_MLD_EN:\r\ncase ISCSI_NET_PARAM_IPV6_FLOW_LABEL:\r\ncase ISCSI_NET_PARAM_IPV6_TRAFFIC_CLASS:\r\ncase ISCSI_NET_PARAM_IPV6_HOP_LIMIT:\r\ncase ISCSI_NET_PARAM_IPV6_ND_REACHABLE_TMO:\r\ncase ISCSI_NET_PARAM_IPV6_ND_REXMIT_TIME:\r\ncase ISCSI_NET_PARAM_IPV6_ND_STALE_TMO:\r\ncase ISCSI_NET_PARAM_IPV6_DUP_ADDR_DETECT_CNT:\r\ncase ISCSI_NET_PARAM_IPV6_RTR_ADV_LINK_MTU:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\ncase ISCSI_IFACE_PARAM:\r\nswitch (param) {\r\ncase ISCSI_IFACE_PARAM_DEF_TASKMGMT_TMO:\r\ncase ISCSI_IFACE_PARAM_HDRDGST_EN:\r\ncase ISCSI_IFACE_PARAM_DATADGST_EN:\r\ncase ISCSI_IFACE_PARAM_IMM_DATA_EN:\r\ncase ISCSI_IFACE_PARAM_INITIAL_R2T_EN:\r\ncase ISCSI_IFACE_PARAM_DATASEQ_INORDER_EN:\r\ncase ISCSI_IFACE_PARAM_PDU_INORDER_EN:\r\ncase ISCSI_IFACE_PARAM_ERL:\r\ncase ISCSI_IFACE_PARAM_MAX_RECV_DLENGTH:\r\ncase ISCSI_IFACE_PARAM_FIRST_BURST:\r\ncase ISCSI_IFACE_PARAM_MAX_R2T:\r\ncase ISCSI_IFACE_PARAM_MAX_BURST:\r\ncase ISCSI_IFACE_PARAM_CHAP_AUTH_EN:\r\ncase ISCSI_IFACE_PARAM_BIDI_CHAP_EN:\r\ncase ISCSI_IFACE_PARAM_DISCOVERY_AUTH_OPTIONAL:\r\ncase ISCSI_IFACE_PARAM_DISCOVERY_LOGOUT_EN:\r\ncase ISCSI_IFACE_PARAM_STRICT_LOGIN_COMP_EN:\r\ncase ISCSI_IFACE_PARAM_INITIATOR_NAME:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\ncase ISCSI_FLASHNODE_PARAM:\r\nswitch (param) {\r\ncase ISCSI_FLASHNODE_IS_FW_ASSIGNED_IPV6:\r\ncase ISCSI_FLASHNODE_PORTAL_TYPE:\r\ncase ISCSI_FLASHNODE_AUTO_SND_TGT_DISABLE:\r\ncase ISCSI_FLASHNODE_DISCOVERY_SESS:\r\ncase ISCSI_FLASHNODE_ENTRY_EN:\r\ncase ISCSI_FLASHNODE_HDR_DGST_EN:\r\ncase ISCSI_FLASHNODE_DATA_DGST_EN:\r\ncase ISCSI_FLASHNODE_IMM_DATA_EN:\r\ncase ISCSI_FLASHNODE_INITIAL_R2T_EN:\r\ncase ISCSI_FLASHNODE_DATASEQ_INORDER:\r\ncase ISCSI_FLASHNODE_PDU_INORDER:\r\ncase ISCSI_FLASHNODE_CHAP_AUTH_EN:\r\ncase ISCSI_FLASHNODE_SNACK_REQ_EN:\r\ncase ISCSI_FLASHNODE_DISCOVERY_LOGOUT_EN:\r\ncase ISCSI_FLASHNODE_BIDI_CHAP_EN:\r\ncase ISCSI_FLASHNODE_DISCOVERY_AUTH_OPTIONAL:\r\ncase ISCSI_FLASHNODE_ERL:\r\ncase ISCSI_FLASHNODE_TCP_TIMESTAMP_STAT:\r\ncase ISCSI_FLASHNODE_TCP_NAGLE_DISABLE:\r\ncase ISCSI_FLASHNODE_TCP_WSF_DISABLE:\r\ncase ISCSI_FLASHNODE_TCP_TIMER_SCALE:\r\ncase ISCSI_FLASHNODE_TCP_TIMESTAMP_EN:\r\ncase ISCSI_FLASHNODE_IP_FRAG_DISABLE:\r\ncase ISCSI_FLASHNODE_MAX_RECV_DLENGTH:\r\ncase ISCSI_FLASHNODE_MAX_XMIT_DLENGTH:\r\ncase ISCSI_FLASHNODE_FIRST_BURST:\r\ncase ISCSI_FLASHNODE_DEF_TIME2WAIT:\r\ncase ISCSI_FLASHNODE_DEF_TIME2RETAIN:\r\ncase ISCSI_FLASHNODE_MAX_R2T:\r\ncase ISCSI_FLASHNODE_KEEPALIVE_TMO:\r\ncase ISCSI_FLASHNODE_ISID:\r\ncase ISCSI_FLASHNODE_TSID:\r\ncase ISCSI_FLASHNODE_PORT:\r\ncase ISCSI_FLASHNODE_MAX_BURST:\r\ncase ISCSI_FLASHNODE_DEF_TASKMGMT_TMO:\r\ncase ISCSI_FLASHNODE_IPADDR:\r\ncase ISCSI_FLASHNODE_ALIAS:\r\ncase ISCSI_FLASHNODE_REDIRECT_IPADDR:\r\ncase ISCSI_FLASHNODE_MAX_SEGMENT_SIZE:\r\ncase ISCSI_FLASHNODE_LOCAL_PORT:\r\ncase ISCSI_FLASHNODE_IPV4_TOS:\r\ncase ISCSI_FLASHNODE_IPV6_TC:\r\ncase ISCSI_FLASHNODE_IPV6_FLOW_LABEL:\r\ncase ISCSI_FLASHNODE_NAME:\r\ncase ISCSI_FLASHNODE_TPGT:\r\ncase ISCSI_FLASHNODE_LINK_LOCAL_IPV6:\r\ncase ISCSI_FLASHNODE_DISCOVERY_PARENT_IDX:\r\ncase ISCSI_FLASHNODE_DISCOVERY_PARENT_TYPE:\r\ncase ISCSI_FLASHNODE_TCP_XMIT_WSF:\r\ncase ISCSI_FLASHNODE_TCP_RECV_WSF:\r\ncase ISCSI_FLASHNODE_CHAP_OUT_IDX:\r\ncase ISCSI_FLASHNODE_USERNAME:\r\ncase ISCSI_FLASHNODE_PASSWORD:\r\ncase ISCSI_FLASHNODE_STATSN:\r\ncase ISCSI_FLASHNODE_EXP_STATSN:\r\ncase ISCSI_FLASHNODE_IS_BOOT_TGT:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void qla4xxx_create_chap_list(struct scsi_qla_host *ha)\r\n{\r\nint rval = 0;\r\nuint8_t *chap_flash_data = NULL;\r\nuint32_t offset;\r\ndma_addr_t chap_dma;\r\nuint32_t chap_size = 0;\r\nif (is_qla40XX(ha))\r\nchap_size = MAX_CHAP_ENTRIES_40XX *\r\nsizeof(struct ql4_chap_table);\r\nelse\r\nchap_size = ha->hw.flt_chap_size / 2;\r\nchap_flash_data = dma_alloc_coherent(&ha->pdev->dev, chap_size,\r\n&chap_dma, GFP_KERNEL);\r\nif (!chap_flash_data) {\r\nql4_printk(KERN_ERR, ha, "No memory for chap_flash_data\n");\r\nreturn;\r\n}\r\nif (is_qla40XX(ha)) {\r\noffset = FLASH_CHAP_OFFSET;\r\n} else {\r\noffset = FLASH_RAW_ACCESS_ADDR + (ha->hw.flt_region_chap << 2);\r\nif (ha->port_num == 1)\r\noffset += chap_size;\r\n}\r\nrval = qla4xxx_get_flash(ha, chap_dma, offset, chap_size);\r\nif (rval != QLA_SUCCESS)\r\ngoto exit_chap_list;\r\nif (ha->chap_list == NULL)\r\nha->chap_list = vmalloc(chap_size);\r\nif (ha->chap_list == NULL) {\r\nql4_printk(KERN_ERR, ha, "No memory for ha->chap_list\n");\r\ngoto exit_chap_list;\r\n}\r\nmemset(ha->chap_list, 0, chap_size);\r\nmemcpy(ha->chap_list, chap_flash_data, chap_size);\r\nexit_chap_list:\r\ndma_free_coherent(&ha->pdev->dev, chap_size, chap_flash_data, chap_dma);\r\n}\r\nstatic int qla4xxx_get_chap_by_index(struct scsi_qla_host *ha,\r\nint16_t chap_index,\r\nstruct ql4_chap_table **chap_entry)\r\n{\r\nint rval = QLA_ERROR;\r\nint max_chap_entries;\r\nif (!ha->chap_list) {\r\nql4_printk(KERN_ERR, ha, "CHAP table cache is empty!\n");\r\nrval = QLA_ERROR;\r\ngoto exit_get_chap;\r\n}\r\nif (is_qla80XX(ha))\r\nmax_chap_entries = (ha->hw.flt_chap_size / 2) /\r\nsizeof(struct ql4_chap_table);\r\nelse\r\nmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\r\nif (chap_index > max_chap_entries) {\r\nql4_printk(KERN_ERR, ha, "Invalid Chap index\n");\r\nrval = QLA_ERROR;\r\ngoto exit_get_chap;\r\n}\r\n*chap_entry = (struct ql4_chap_table *)ha->chap_list + chap_index;\r\nif ((*chap_entry)->cookie !=\r\n__constant_cpu_to_le16(CHAP_VALID_COOKIE)) {\r\nrval = QLA_ERROR;\r\n*chap_entry = NULL;\r\n} else {\r\nrval = QLA_SUCCESS;\r\n}\r\nexit_get_chap:\r\nreturn rval;\r\n}\r\nstatic int qla4xxx_find_free_chap_index(struct scsi_qla_host *ha,\r\nuint16_t *chap_index)\r\n{\r\nint i, rval;\r\nint free_index = -1;\r\nint max_chap_entries = 0;\r\nstruct ql4_chap_table *chap_table;\r\nif (is_qla80XX(ha))\r\nmax_chap_entries = (ha->hw.flt_chap_size / 2) /\r\nsizeof(struct ql4_chap_table);\r\nelse\r\nmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\r\nif (!ha->chap_list) {\r\nql4_printk(KERN_ERR, ha, "CHAP table cache is empty!\n");\r\nrval = QLA_ERROR;\r\ngoto exit_find_chap;\r\n}\r\nfor (i = 0; i < max_chap_entries; i++) {\r\nchap_table = (struct ql4_chap_table *)ha->chap_list + i;\r\nif ((chap_table->cookie !=\r\n__constant_cpu_to_le16(CHAP_VALID_COOKIE)) &&\r\n(i > MAX_RESRV_CHAP_IDX)) {\r\nfree_index = i;\r\nbreak;\r\n}\r\n}\r\nif (free_index != -1) {\r\n*chap_index = free_index;\r\nrval = QLA_SUCCESS;\r\n} else {\r\nrval = QLA_ERROR;\r\n}\r\nexit_find_chap:\r\nreturn rval;\r\n}\r\nstatic int qla4xxx_get_chap_list(struct Scsi_Host *shost, uint16_t chap_tbl_idx,\r\nuint32_t *num_entries, char *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nstruct ql4_chap_table *chap_table;\r\nstruct iscsi_chap_rec *chap_rec;\r\nint max_chap_entries = 0;\r\nint valid_chap_entries = 0;\r\nint ret = 0, i;\r\nif (is_qla80XX(ha))\r\nmax_chap_entries = (ha->hw.flt_chap_size / 2) /\r\nsizeof(struct ql4_chap_table);\r\nelse\r\nmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\r\nql4_printk(KERN_INFO, ha, "%s: num_entries = %d, CHAP idx = %d\n",\r\n__func__, *num_entries, chap_tbl_idx);\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto exit_get_chap_list;\r\n}\r\nqla4xxx_create_chap_list(ha);\r\nchap_rec = (struct iscsi_chap_rec *) buf;\r\nmutex_lock(&ha->chap_sem);\r\nfor (i = chap_tbl_idx; i < max_chap_entries; i++) {\r\nchap_table = (struct ql4_chap_table *)ha->chap_list + i;\r\nif (chap_table->cookie !=\r\n__constant_cpu_to_le16(CHAP_VALID_COOKIE))\r\ncontinue;\r\nchap_rec->chap_tbl_idx = i;\r\nstrlcpy(chap_rec->username, chap_table->name,\r\nISCSI_CHAP_AUTH_NAME_MAX_LEN);\r\nstrlcpy(chap_rec->password, chap_table->secret,\r\nQL4_CHAP_MAX_SECRET_LEN);\r\nchap_rec->password_length = chap_table->secret_len;\r\nif (chap_table->flags & BIT_7)\r\nchap_rec->chap_type = CHAP_TYPE_OUT;\r\nif (chap_table->flags & BIT_6)\r\nchap_rec->chap_type = CHAP_TYPE_IN;\r\nchap_rec++;\r\nvalid_chap_entries++;\r\nif (valid_chap_entries == *num_entries)\r\nbreak;\r\nelse\r\ncontinue;\r\n}\r\nmutex_unlock(&ha->chap_sem);\r\nexit_get_chap_list:\r\nql4_printk(KERN_INFO, ha, "%s: Valid CHAP Entries = %d\n",\r\n__func__, valid_chap_entries);\r\n*num_entries = valid_chap_entries;\r\nreturn ret;\r\n}\r\nstatic int __qla4xxx_is_chap_active(struct device *dev, void *data)\r\n{\r\nint ret = 0;\r\nuint16_t *chap_tbl_idx = (uint16_t *) data;\r\nstruct iscsi_cls_session *cls_session;\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb_entry;\r\nif (!iscsi_is_session_dev(dev))\r\ngoto exit_is_chap_active;\r\ncls_session = iscsi_dev_to_session(dev);\r\nsess = cls_session->dd_data;\r\nddb_entry = sess->dd_data;\r\nif (iscsi_session_chkready(cls_session))\r\ngoto exit_is_chap_active;\r\nif (ddb_entry->chap_tbl_idx == *chap_tbl_idx)\r\nret = 1;\r\nexit_is_chap_active:\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_is_chap_active(struct Scsi_Host *shost,\r\nuint16_t chap_tbl_idx)\r\n{\r\nint ret = 0;\r\nret = device_for_each_child(&shost->shost_gendev, &chap_tbl_idx,\r\n__qla4xxx_is_chap_active);\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_delete_chap(struct Scsi_Host *shost, uint16_t chap_tbl_idx)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nstruct ql4_chap_table *chap_table;\r\ndma_addr_t chap_dma;\r\nint max_chap_entries = 0;\r\nuint32_t offset = 0;\r\nuint32_t chap_size;\r\nint ret = 0;\r\nchap_table = dma_pool_alloc(ha->chap_dma_pool, GFP_KERNEL, &chap_dma);\r\nif (chap_table == NULL)\r\nreturn -ENOMEM;\r\nmemset(chap_table, 0, sizeof(struct ql4_chap_table));\r\nif (is_qla80XX(ha))\r\nmax_chap_entries = (ha->hw.flt_chap_size / 2) /\r\nsizeof(struct ql4_chap_table);\r\nelse\r\nmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\r\nif (chap_tbl_idx > max_chap_entries) {\r\nret = -EINVAL;\r\ngoto exit_delete_chap;\r\n}\r\nret = qla4xxx_is_chap_active(shost, chap_tbl_idx);\r\nif (ret) {\r\nql4_printk(KERN_INFO, ha, "CHAP entry %d is in use, cannot "\r\n"delete from flash\n", chap_tbl_idx);\r\nret = -EBUSY;\r\ngoto exit_delete_chap;\r\n}\r\nchap_size = sizeof(struct ql4_chap_table);\r\nif (is_qla40XX(ha))\r\noffset = FLASH_CHAP_OFFSET | (chap_tbl_idx * chap_size);\r\nelse {\r\noffset = FLASH_RAW_ACCESS_ADDR + (ha->hw.flt_region_chap << 2);\r\nif (ha->port_num == 1)\r\noffset += (ha->hw.flt_chap_size / 2);\r\noffset += (chap_tbl_idx * chap_size);\r\n}\r\nret = qla4xxx_get_flash(ha, chap_dma, offset, chap_size);\r\nif (ret != QLA_SUCCESS) {\r\nret = -EINVAL;\r\ngoto exit_delete_chap;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Chap Cookie: x%x\n",\r\n__le16_to_cpu(chap_table->cookie)));\r\nif (__le16_to_cpu(chap_table->cookie) != CHAP_VALID_COOKIE) {\r\nql4_printk(KERN_ERR, ha, "No valid chap entry found\n");\r\ngoto exit_delete_chap;\r\n}\r\nchap_table->cookie = __constant_cpu_to_le16(0xFFFF);\r\noffset = FLASH_CHAP_OFFSET |\r\n(chap_tbl_idx * sizeof(struct ql4_chap_table));\r\nret = qla4xxx_set_flash(ha, chap_dma, offset, chap_size,\r\nFLASH_OPT_RMW_COMMIT);\r\nif (ret == QLA_SUCCESS && ha->chap_list) {\r\nmutex_lock(&ha->chap_sem);\r\nmemcpy((struct ql4_chap_table *)ha->chap_list + chap_tbl_idx,\r\nchap_table, sizeof(struct ql4_chap_table));\r\nmutex_unlock(&ha->chap_sem);\r\n}\r\nif (ret != QLA_SUCCESS)\r\nret = -EINVAL;\r\nexit_delete_chap:\r\ndma_pool_free(ha->chap_dma_pool, chap_table, chap_dma);\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_set_chap_entry(struct Scsi_Host *shost, void *data, int len)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nstruct iscsi_chap_rec chap_rec;\r\nstruct ql4_chap_table *chap_entry = NULL;\r\nstruct iscsi_param_info *param_info;\r\nstruct nlattr *attr;\r\nint max_chap_entries = 0;\r\nint type;\r\nint rem = len;\r\nint rc = 0;\r\nint size;\r\nmemset(&chap_rec, 0, sizeof(chap_rec));\r\nnla_for_each_attr(attr, data, len, rem) {\r\nparam_info = nla_data(attr);\r\nswitch (param_info->param) {\r\ncase ISCSI_CHAP_PARAM_INDEX:\r\nchap_rec.chap_tbl_idx = *(uint16_t *)param_info->value;\r\nbreak;\r\ncase ISCSI_CHAP_PARAM_CHAP_TYPE:\r\nchap_rec.chap_type = param_info->value[0];\r\nbreak;\r\ncase ISCSI_CHAP_PARAM_USERNAME:\r\nsize = min_t(size_t, sizeof(chap_rec.username),\r\nparam_info->len);\r\nmemcpy(chap_rec.username, param_info->value, size);\r\nbreak;\r\ncase ISCSI_CHAP_PARAM_PASSWORD:\r\nsize = min_t(size_t, sizeof(chap_rec.password),\r\nparam_info->len);\r\nmemcpy(chap_rec.password, param_info->value, size);\r\nbreak;\r\ncase ISCSI_CHAP_PARAM_PASSWORD_LEN:\r\nchap_rec.password_length = param_info->value[0];\r\nbreak;\r\ndefault:\r\nql4_printk(KERN_ERR, ha,\r\n"%s: No such sysfs attribute\n", __func__);\r\nrc = -ENOSYS;\r\ngoto exit_set_chap;\r\n};\r\n}\r\nif (chap_rec.chap_type == CHAP_TYPE_IN)\r\ntype = BIDI_CHAP;\r\nelse\r\ntype = LOCAL_CHAP;\r\nif (is_qla80XX(ha))\r\nmax_chap_entries = (ha->hw.flt_chap_size / 2) /\r\nsizeof(struct ql4_chap_table);\r\nelse\r\nmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\r\nmutex_lock(&ha->chap_sem);\r\nif (chap_rec.chap_tbl_idx < max_chap_entries) {\r\nrc = qla4xxx_get_chap_by_index(ha, chap_rec.chap_tbl_idx,\r\n&chap_entry);\r\nif (!rc) {\r\nif (!(type == qla4xxx_get_chap_type(chap_entry))) {\r\nql4_printk(KERN_INFO, ha,\r\n"Type mismatch for CHAP entry %d\n",\r\nchap_rec.chap_tbl_idx);\r\nrc = -EINVAL;\r\ngoto exit_unlock_chap;\r\n}\r\nrc = qla4xxx_is_chap_active(shost,\r\nchap_rec.chap_tbl_idx);\r\nif (rc) {\r\nql4_printk(KERN_INFO, ha,\r\n"CHAP entry %d is in use\n",\r\nchap_rec.chap_tbl_idx);\r\nrc = -EBUSY;\r\ngoto exit_unlock_chap;\r\n}\r\n}\r\n} else {\r\nrc = qla4xxx_find_free_chap_index(ha, &chap_rec.chap_tbl_idx);\r\nif (rc) {\r\nql4_printk(KERN_INFO, ha, "CHAP entry not available\n");\r\nrc = -EBUSY;\r\ngoto exit_unlock_chap;\r\n}\r\n}\r\nrc = qla4xxx_set_chap(ha, chap_rec.username, chap_rec.password,\r\nchap_rec.chap_tbl_idx, type);\r\nexit_unlock_chap:\r\nmutex_unlock(&ha->chap_sem);\r\nexit_set_chap:\r\nreturn rc;\r\n}\r\nstatic int qla4xxx_get_host_stats(struct Scsi_Host *shost, char *buf, int len)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nstruct iscsi_offload_host_stats *host_stats = NULL;\r\nint host_stats_size;\r\nint ret = 0;\r\nint ddb_idx = 0;\r\nstruct ql_iscsi_stats *ql_iscsi_stats = NULL;\r\nint stats_size;\r\ndma_addr_t iscsi_stats_dma;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Func: %s\n", __func__));\r\nhost_stats_size = sizeof(struct iscsi_offload_host_stats);\r\nif (host_stats_size != len) {\r\nql4_printk(KERN_INFO, ha, "%s: host_stats size mismatch expected = %d, is = %d\n",\r\n__func__, len, host_stats_size);\r\nret = -EINVAL;\r\ngoto exit_host_stats;\r\n}\r\nhost_stats = (struct iscsi_offload_host_stats *)buf;\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto exit_host_stats;\r\n}\r\nstats_size = PAGE_ALIGN(sizeof(struct ql_iscsi_stats));\r\nql_iscsi_stats = dma_alloc_coherent(&ha->pdev->dev, stats_size,\r\n&iscsi_stats_dma, GFP_KERNEL);\r\nif (!ql_iscsi_stats) {\r\nql4_printk(KERN_ERR, ha,\r\n"Unable to allocate memory for iscsi stats\n");\r\nret = -ENOMEM;\r\ngoto exit_host_stats;\r\n}\r\nret = qla4xxx_get_mgmt_data(ha, ddb_idx, stats_size,\r\niscsi_stats_dma);\r\nif (ret != QLA_SUCCESS) {\r\nql4_printk(KERN_ERR, ha,\r\n"Unable to retrieve iscsi stats\n");\r\nret = -EIO;\r\ngoto exit_host_stats;\r\n}\r\nhost_stats->mactx_frames = le64_to_cpu(ql_iscsi_stats->mac_tx_frames);\r\nhost_stats->mactx_bytes = le64_to_cpu(ql_iscsi_stats->mac_tx_bytes);\r\nhost_stats->mactx_multicast_frames =\r\nle64_to_cpu(ql_iscsi_stats->mac_tx_multicast_frames);\r\nhost_stats->mactx_broadcast_frames =\r\nle64_to_cpu(ql_iscsi_stats->mac_tx_broadcast_frames);\r\nhost_stats->mactx_pause_frames =\r\nle64_to_cpu(ql_iscsi_stats->mac_tx_pause_frames);\r\nhost_stats->mactx_control_frames =\r\nle64_to_cpu(ql_iscsi_stats->mac_tx_control_frames);\r\nhost_stats->mactx_deferral =\r\nle64_to_cpu(ql_iscsi_stats->mac_tx_deferral);\r\nhost_stats->mactx_excess_deferral =\r\nle64_to_cpu(ql_iscsi_stats->mac_tx_excess_deferral);\r\nhost_stats->mactx_late_collision =\r\nle64_to_cpu(ql_iscsi_stats->mac_tx_late_collision);\r\nhost_stats->mactx_abort = le64_to_cpu(ql_iscsi_stats->mac_tx_abort);\r\nhost_stats->mactx_single_collision =\r\nle64_to_cpu(ql_iscsi_stats->mac_tx_single_collision);\r\nhost_stats->mactx_multiple_collision =\r\nle64_to_cpu(ql_iscsi_stats->mac_tx_multiple_collision);\r\nhost_stats->mactx_collision =\r\nle64_to_cpu(ql_iscsi_stats->mac_tx_collision);\r\nhost_stats->mactx_frames_dropped =\r\nle64_to_cpu(ql_iscsi_stats->mac_tx_frames_dropped);\r\nhost_stats->mactx_jumbo_frames =\r\nle64_to_cpu(ql_iscsi_stats->mac_tx_jumbo_frames);\r\nhost_stats->macrx_frames = le64_to_cpu(ql_iscsi_stats->mac_rx_frames);\r\nhost_stats->macrx_bytes = le64_to_cpu(ql_iscsi_stats->mac_rx_bytes);\r\nhost_stats->macrx_unknown_control_frames =\r\nle64_to_cpu(ql_iscsi_stats->mac_rx_unknown_control_frames);\r\nhost_stats->macrx_pause_frames =\r\nle64_to_cpu(ql_iscsi_stats->mac_rx_pause_frames);\r\nhost_stats->macrx_control_frames =\r\nle64_to_cpu(ql_iscsi_stats->mac_rx_control_frames);\r\nhost_stats->macrx_dribble =\r\nle64_to_cpu(ql_iscsi_stats->mac_rx_dribble);\r\nhost_stats->macrx_frame_length_error =\r\nle64_to_cpu(ql_iscsi_stats->mac_rx_frame_length_error);\r\nhost_stats->macrx_jabber = le64_to_cpu(ql_iscsi_stats->mac_rx_jabber);\r\nhost_stats->macrx_carrier_sense_error =\r\nle64_to_cpu(ql_iscsi_stats->mac_rx_carrier_sense_error);\r\nhost_stats->macrx_frame_discarded =\r\nle64_to_cpu(ql_iscsi_stats->mac_rx_frame_discarded);\r\nhost_stats->macrx_frames_dropped =\r\nle64_to_cpu(ql_iscsi_stats->mac_rx_frames_dropped);\r\nhost_stats->mac_crc_error = le64_to_cpu(ql_iscsi_stats->mac_crc_error);\r\nhost_stats->mac_encoding_error =\r\nle64_to_cpu(ql_iscsi_stats->mac_encoding_error);\r\nhost_stats->macrx_length_error_large =\r\nle64_to_cpu(ql_iscsi_stats->mac_rx_length_error_large);\r\nhost_stats->macrx_length_error_small =\r\nle64_to_cpu(ql_iscsi_stats->mac_rx_length_error_small);\r\nhost_stats->macrx_multicast_frames =\r\nle64_to_cpu(ql_iscsi_stats->mac_rx_multicast_frames);\r\nhost_stats->macrx_broadcast_frames =\r\nle64_to_cpu(ql_iscsi_stats->mac_rx_broadcast_frames);\r\nhost_stats->iptx_packets = le64_to_cpu(ql_iscsi_stats->ip_tx_packets);\r\nhost_stats->iptx_bytes = le64_to_cpu(ql_iscsi_stats->ip_tx_bytes);\r\nhost_stats->iptx_fragments =\r\nle64_to_cpu(ql_iscsi_stats->ip_tx_fragments);\r\nhost_stats->iprx_packets = le64_to_cpu(ql_iscsi_stats->ip_rx_packets);\r\nhost_stats->iprx_bytes = le64_to_cpu(ql_iscsi_stats->ip_rx_bytes);\r\nhost_stats->iprx_fragments =\r\nle64_to_cpu(ql_iscsi_stats->ip_rx_fragments);\r\nhost_stats->ip_datagram_reassembly =\r\nle64_to_cpu(ql_iscsi_stats->ip_datagram_reassembly);\r\nhost_stats->ip_invalid_address_error =\r\nle64_to_cpu(ql_iscsi_stats->ip_invalid_address_error);\r\nhost_stats->ip_error_packets =\r\nle64_to_cpu(ql_iscsi_stats->ip_error_packets);\r\nhost_stats->ip_fragrx_overlap =\r\nle64_to_cpu(ql_iscsi_stats->ip_fragrx_overlap);\r\nhost_stats->ip_fragrx_outoforder =\r\nle64_to_cpu(ql_iscsi_stats->ip_fragrx_outoforder);\r\nhost_stats->ip_datagram_reassembly_timeout =\r\nle64_to_cpu(ql_iscsi_stats->ip_datagram_reassembly_timeout);\r\nhost_stats->ipv6tx_packets =\r\nle64_to_cpu(ql_iscsi_stats->ipv6_tx_packets);\r\nhost_stats->ipv6tx_bytes = le64_to_cpu(ql_iscsi_stats->ipv6_tx_bytes);\r\nhost_stats->ipv6tx_fragments =\r\nle64_to_cpu(ql_iscsi_stats->ipv6_tx_fragments);\r\nhost_stats->ipv6rx_packets =\r\nle64_to_cpu(ql_iscsi_stats->ipv6_rx_packets);\r\nhost_stats->ipv6rx_bytes = le64_to_cpu(ql_iscsi_stats->ipv6_rx_bytes);\r\nhost_stats->ipv6rx_fragments =\r\nle64_to_cpu(ql_iscsi_stats->ipv6_rx_fragments);\r\nhost_stats->ipv6_datagram_reassembly =\r\nle64_to_cpu(ql_iscsi_stats->ipv6_datagram_reassembly);\r\nhost_stats->ipv6_invalid_address_error =\r\nle64_to_cpu(ql_iscsi_stats->ipv6_invalid_address_error);\r\nhost_stats->ipv6_error_packets =\r\nle64_to_cpu(ql_iscsi_stats->ipv6_error_packets);\r\nhost_stats->ipv6_fragrx_overlap =\r\nle64_to_cpu(ql_iscsi_stats->ipv6_fragrx_overlap);\r\nhost_stats->ipv6_fragrx_outoforder =\r\nle64_to_cpu(ql_iscsi_stats->ipv6_fragrx_outoforder);\r\nhost_stats->ipv6_datagram_reassembly_timeout =\r\nle64_to_cpu(ql_iscsi_stats->ipv6_datagram_reassembly_timeout);\r\nhost_stats->tcptx_segments =\r\nle64_to_cpu(ql_iscsi_stats->tcp_tx_segments);\r\nhost_stats->tcptx_bytes = le64_to_cpu(ql_iscsi_stats->tcp_tx_bytes);\r\nhost_stats->tcprx_segments =\r\nle64_to_cpu(ql_iscsi_stats->tcp_rx_segments);\r\nhost_stats->tcprx_byte = le64_to_cpu(ql_iscsi_stats->tcp_rx_byte);\r\nhost_stats->tcp_duplicate_ack_retx =\r\nle64_to_cpu(ql_iscsi_stats->tcp_duplicate_ack_retx);\r\nhost_stats->tcp_retx_timer_expired =\r\nle64_to_cpu(ql_iscsi_stats->tcp_retx_timer_expired);\r\nhost_stats->tcprx_duplicate_ack =\r\nle64_to_cpu(ql_iscsi_stats->tcp_rx_duplicate_ack);\r\nhost_stats->tcprx_pure_ackr =\r\nle64_to_cpu(ql_iscsi_stats->tcp_rx_pure_ackr);\r\nhost_stats->tcptx_delayed_ack =\r\nle64_to_cpu(ql_iscsi_stats->tcp_tx_delayed_ack);\r\nhost_stats->tcptx_pure_ack =\r\nle64_to_cpu(ql_iscsi_stats->tcp_tx_pure_ack);\r\nhost_stats->tcprx_segment_error =\r\nle64_to_cpu(ql_iscsi_stats->tcp_rx_segment_error);\r\nhost_stats->tcprx_segment_outoforder =\r\nle64_to_cpu(ql_iscsi_stats->tcp_rx_segment_outoforder);\r\nhost_stats->tcprx_window_probe =\r\nle64_to_cpu(ql_iscsi_stats->tcp_rx_window_probe);\r\nhost_stats->tcprx_window_update =\r\nle64_to_cpu(ql_iscsi_stats->tcp_rx_window_update);\r\nhost_stats->tcptx_window_probe_persist =\r\nle64_to_cpu(ql_iscsi_stats->tcp_tx_window_probe_persist);\r\nhost_stats->ecc_error_correction =\r\nle64_to_cpu(ql_iscsi_stats->ecc_error_correction);\r\nhost_stats->iscsi_pdu_tx = le64_to_cpu(ql_iscsi_stats->iscsi_pdu_tx);\r\nhost_stats->iscsi_data_bytes_tx =\r\nle64_to_cpu(ql_iscsi_stats->iscsi_data_bytes_tx);\r\nhost_stats->iscsi_pdu_rx = le64_to_cpu(ql_iscsi_stats->iscsi_pdu_rx);\r\nhost_stats->iscsi_data_bytes_rx =\r\nle64_to_cpu(ql_iscsi_stats->iscsi_data_bytes_rx);\r\nhost_stats->iscsi_io_completed =\r\nle64_to_cpu(ql_iscsi_stats->iscsi_io_completed);\r\nhost_stats->iscsi_unexpected_io_rx =\r\nle64_to_cpu(ql_iscsi_stats->iscsi_unexpected_io_rx);\r\nhost_stats->iscsi_format_error =\r\nle64_to_cpu(ql_iscsi_stats->iscsi_format_error);\r\nhost_stats->iscsi_hdr_digest_error =\r\nle64_to_cpu(ql_iscsi_stats->iscsi_hdr_digest_error);\r\nhost_stats->iscsi_data_digest_error =\r\nle64_to_cpu(ql_iscsi_stats->iscsi_data_digest_error);\r\nhost_stats->iscsi_sequence_error =\r\nle64_to_cpu(ql_iscsi_stats->iscsi_sequence_error);\r\nexit_host_stats:\r\nif (ql_iscsi_stats)\r\ndma_free_coherent(&ha->pdev->dev, host_stats_size,\r\nql_iscsi_stats, iscsi_stats_dma);\r\nql4_printk(KERN_INFO, ha, "%s: Get host stats done\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_get_iface_param(struct iscsi_iface *iface,\r\nenum iscsi_param_type param_type,\r\nint param, char *buf)\r\n{\r\nstruct Scsi_Host *shost = iscsi_iface_to_shost(iface);\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nint ival;\r\nchar *pval = NULL;\r\nint len = -ENOSYS;\r\nif (param_type == ISCSI_NET_PARAM) {\r\nswitch (param) {\r\ncase ISCSI_NET_PARAM_IPV4_ADDR:\r\nlen = sprintf(buf, "%pI4\n", &ha->ip_config.ip_address);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_SUBNET:\r\nlen = sprintf(buf, "%pI4\n",\r\n&ha->ip_config.subnet_mask);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_GW:\r\nlen = sprintf(buf, "%pI4\n", &ha->ip_config.gateway);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IFACE_ENABLE:\r\nif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\r\nOP_STATE(ha->ip_config.ipv4_options,\r\nIPOPT_IPV4_PROTOCOL_ENABLE, pval);\r\n} else {\r\nOP_STATE(ha->ip_config.ipv6_options,\r\nIPV6_OPT_IPV6_PROTOCOL_ENABLE, pval);\r\n}\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\r\nlen = sprintf(buf, "%s\n",\r\n(ha->ip_config.tcp_options &\r\nTCPOPT_DHCP_ENABLE) ?\r\n"dhcp" : "static");\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_ADDR:\r\nif (iface->iface_num == 0)\r\nlen = sprintf(buf, "%pI6\n",\r\n&ha->ip_config.ipv6_addr0);\r\nif (iface->iface_num == 1)\r\nlen = sprintf(buf, "%pI6\n",\r\n&ha->ip_config.ipv6_addr1);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_LINKLOCAL:\r\nlen = sprintf(buf, "%pI6\n",\r\n&ha->ip_config.ipv6_link_local_addr);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_ROUTER:\r\nlen = sprintf(buf, "%pI6\n",\r\n&ha->ip_config.ipv6_default_router_addr);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_ADDR_AUTOCFG:\r\npval = (ha->ip_config.ipv6_addl_options &\r\nIPV6_ADDOPT_NEIGHBOR_DISCOVERY_ADDR_ENABLE) ?\r\n"nd" : "static";\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_LINKLOCAL_AUTOCFG:\r\npval = (ha->ip_config.ipv6_addl_options &\r\nIPV6_ADDOPT_AUTOCONFIG_LINK_LOCAL_ADDR) ?\r\n"auto" : "static";\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_VLAN_ID:\r\nif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\r\nival = ha->ip_config.ipv4_vlan_tag &\r\nISCSI_MAX_VLAN_ID;\r\nelse\r\nival = ha->ip_config.ipv6_vlan_tag &\r\nISCSI_MAX_VLAN_ID;\r\nlen = sprintf(buf, "%d\n", ival);\r\nbreak;\r\ncase ISCSI_NET_PARAM_VLAN_PRIORITY:\r\nif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\r\nival = (ha->ip_config.ipv4_vlan_tag >> 13) &\r\nISCSI_MAX_VLAN_PRIORITY;\r\nelse\r\nival = (ha->ip_config.ipv6_vlan_tag >> 13) &\r\nISCSI_MAX_VLAN_PRIORITY;\r\nlen = sprintf(buf, "%d\n", ival);\r\nbreak;\r\ncase ISCSI_NET_PARAM_VLAN_ENABLED:\r\nif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\r\nOP_STATE(ha->ip_config.ipv4_options,\r\nIPOPT_VLAN_TAGGING_ENABLE, pval);\r\n} else {\r\nOP_STATE(ha->ip_config.ipv6_options,\r\nIPV6_OPT_VLAN_TAGGING_ENABLE, pval);\r\n}\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_MTU:\r\nlen = sprintf(buf, "%d\n", ha->ip_config.eth_mtu_size);\r\nbreak;\r\ncase ISCSI_NET_PARAM_PORT:\r\nif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\r\nlen = sprintf(buf, "%d\n",\r\nha->ip_config.ipv4_port);\r\nelse\r\nlen = sprintf(buf, "%d\n",\r\nha->ip_config.ipv6_port);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPADDR_STATE:\r\nif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\r\npval = iscsi_get_ipaddress_state_name(\r\nha->ip_config.ipv4_addr_state);\r\n} else {\r\nif (iface->iface_num == 0)\r\npval = iscsi_get_ipaddress_state_name(\r\nha->ip_config.ipv6_addr0_state);\r\nelse if (iface->iface_num == 1)\r\npval = iscsi_get_ipaddress_state_name(\r\nha->ip_config.ipv6_addr1_state);\r\n}\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_LINKLOCAL_STATE:\r\npval = iscsi_get_ipaddress_state_name(\r\nha->ip_config.ipv6_link_local_state);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_ROUTER_STATE:\r\npval = iscsi_get_router_state_name(\r\nha->ip_config.ipv6_default_router_state);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_DELAYED_ACK_EN:\r\nif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\r\nOP_STATE(~ha->ip_config.tcp_options,\r\nTCPOPT_DELAYED_ACK_DISABLE, pval);\r\n} else {\r\nOP_STATE(~ha->ip_config.ipv6_tcp_options,\r\nIPV6_TCPOPT_DELAYED_ACK_DISABLE, pval);\r\n}\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_TCP_NAGLE_DISABLE:\r\nif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\r\nOP_STATE(~ha->ip_config.tcp_options,\r\nTCPOPT_NAGLE_ALGO_DISABLE, pval);\r\n} else {\r\nOP_STATE(~ha->ip_config.ipv6_tcp_options,\r\nIPV6_TCPOPT_NAGLE_ALGO_DISABLE, pval);\r\n}\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_TCP_WSF_DISABLE:\r\nif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\r\nOP_STATE(~ha->ip_config.tcp_options,\r\nTCPOPT_WINDOW_SCALE_DISABLE, pval);\r\n} else {\r\nOP_STATE(~ha->ip_config.ipv6_tcp_options,\r\nIPV6_TCPOPT_WINDOW_SCALE_DISABLE,\r\npval);\r\n}\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_TCP_WSF:\r\nif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\r\nlen = sprintf(buf, "%d\n",\r\nha->ip_config.tcp_wsf);\r\nelse\r\nlen = sprintf(buf, "%d\n",\r\nha->ip_config.ipv6_tcp_wsf);\r\nbreak;\r\ncase ISCSI_NET_PARAM_TCP_TIMER_SCALE:\r\nif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\r\nival = (ha->ip_config.tcp_options &\r\nTCPOPT_TIMER_SCALE) >> 1;\r\nelse\r\nival = (ha->ip_config.ipv6_tcp_options &\r\nIPV6_TCPOPT_TIMER_SCALE) >> 1;\r\nlen = sprintf(buf, "%d\n", ival);\r\nbreak;\r\ncase ISCSI_NET_PARAM_TCP_TIMESTAMP_EN:\r\nif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\r\nOP_STATE(ha->ip_config.tcp_options,\r\nTCPOPT_TIMESTAMP_ENABLE, pval);\r\n} else {\r\nOP_STATE(ha->ip_config.ipv6_tcp_options,\r\nIPV6_TCPOPT_TIMESTAMP_EN, pval);\r\n}\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_CACHE_ID:\r\nif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\r\nlen = sprintf(buf, "%d\n",\r\nha->ip_config.ipv4_cache_id);\r\nelse\r\nlen = sprintf(buf, "%d\n",\r\nha->ip_config.ipv6_cache_id);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_DNS_ADDR_EN:\r\nOP_STATE(ha->ip_config.tcp_options,\r\nTCPOPT_DNS_SERVER_IP_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_SLP_DA_EN:\r\nOP_STATE(ha->ip_config.tcp_options,\r\nTCPOPT_SLP_DA_INFO_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_TOS_EN:\r\nOP_STATE(ha->ip_config.ipv4_options,\r\nIPOPT_IPV4_TOS_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_TOS:\r\nlen = sprintf(buf, "%d\n", ha->ip_config.ipv4_tos);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_GRAT_ARP_EN:\r\nOP_STATE(ha->ip_config.ipv4_options,\r\nIPOPT_GRAT_ARP_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID_EN:\r\nOP_STATE(ha->ip_config.ipv4_options, IPOPT_ALT_CID_EN,\r\npval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID:\r\npval = (ha->ip_config.ipv4_alt_cid_len) ?\r\n(char *)ha->ip_config.ipv4_alt_cid : "";\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_REQ_VENDOR_ID_EN:\r\nOP_STATE(ha->ip_config.ipv4_options,\r\nIPOPT_REQ_VID_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_USE_VENDOR_ID_EN:\r\nOP_STATE(ha->ip_config.ipv4_options,\r\nIPOPT_USE_VID_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_VENDOR_ID:\r\npval = (ha->ip_config.ipv4_vid_len) ?\r\n(char *)ha->ip_config.ipv4_vid : "";\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_LEARN_IQN_EN:\r\nOP_STATE(ha->ip_config.ipv4_options,\r\nIPOPT_LEARN_IQN_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_FRAGMENT_DISABLE:\r\nOP_STATE(~ha->ip_config.ipv4_options,\r\nIPOPT_FRAGMENTATION_DISABLE, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_IN_FORWARD_EN:\r\nOP_STATE(ha->ip_config.ipv4_options,\r\nIPOPT_IN_FORWARD_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_REDIRECT_EN:\r\nif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\r\nOP_STATE(ha->ip_config.ipv4_options,\r\nIPOPT_ARP_REDIRECT_EN, pval);\r\n} else {\r\nOP_STATE(ha->ip_config.ipv6_options,\r\nIPV6_OPT_REDIRECT_EN, pval);\r\n}\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_TTL:\r\nlen = sprintf(buf, "%d\n", ha->ip_config.ipv4_ttl);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_GRAT_NEIGHBOR_ADV_EN:\r\nOP_STATE(ha->ip_config.ipv6_options,\r\nIPV6_OPT_GRAT_NEIGHBOR_ADV_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_MLD_EN:\r\nOP_STATE(ha->ip_config.ipv6_addl_options,\r\nIPV6_ADDOPT_MLD_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_FLOW_LABEL:\r\nlen = sprintf(buf, "%u\n", ha->ip_config.ipv6_flow_lbl);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_TRAFFIC_CLASS:\r\nlen = sprintf(buf, "%d\n",\r\nha->ip_config.ipv6_traffic_class);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_HOP_LIMIT:\r\nlen = sprintf(buf, "%d\n",\r\nha->ip_config.ipv6_hop_limit);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_ND_REACHABLE_TMO:\r\nlen = sprintf(buf, "%d\n",\r\nha->ip_config.ipv6_nd_reach_time);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_ND_REXMIT_TIME:\r\nlen = sprintf(buf, "%d\n",\r\nha->ip_config.ipv6_nd_rexmit_timer);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_ND_STALE_TMO:\r\nlen = sprintf(buf, "%d\n",\r\nha->ip_config.ipv6_nd_stale_timeout);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_DUP_ADDR_DETECT_CNT:\r\nlen = sprintf(buf, "%d\n",\r\nha->ip_config.ipv6_dup_addr_detect_count);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_RTR_ADV_LINK_MTU:\r\nlen = sprintf(buf, "%d\n",\r\nha->ip_config.ipv6_gw_advrt_mtu);\r\nbreak;\r\ndefault:\r\nlen = -ENOSYS;\r\n}\r\n} else if (param_type == ISCSI_IFACE_PARAM) {\r\nswitch (param) {\r\ncase ISCSI_IFACE_PARAM_DEF_TASKMGMT_TMO:\r\nlen = sprintf(buf, "%d\n", ha->ip_config.def_timeout);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_HDRDGST_EN:\r\nOP_STATE(ha->ip_config.iscsi_options,\r\nISCSIOPTS_HEADER_DIGEST_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_DATADGST_EN:\r\nOP_STATE(ha->ip_config.iscsi_options,\r\nISCSIOPTS_DATA_DIGEST_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_IMM_DATA_EN:\r\nOP_STATE(ha->ip_config.iscsi_options,\r\nISCSIOPTS_IMMEDIATE_DATA_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_INITIAL_R2T_EN:\r\nOP_STATE(ha->ip_config.iscsi_options,\r\nISCSIOPTS_INITIAL_R2T_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_DATASEQ_INORDER_EN:\r\nOP_STATE(ha->ip_config.iscsi_options,\r\nISCSIOPTS_DATA_SEQ_INORDER_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_PDU_INORDER_EN:\r\nOP_STATE(ha->ip_config.iscsi_options,\r\nISCSIOPTS_DATA_PDU_INORDER_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_ERL:\r\nlen = sprintf(buf, "%d\n",\r\n(ha->ip_config.iscsi_options &\r\nISCSIOPTS_ERL));\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_MAX_RECV_DLENGTH:\r\nlen = sprintf(buf, "%u\n",\r\nha->ip_config.iscsi_max_pdu_size *\r\nBYTE_UNITS);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_FIRST_BURST:\r\nlen = sprintf(buf, "%u\n",\r\nha->ip_config.iscsi_first_burst_len *\r\nBYTE_UNITS);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_MAX_R2T:\r\nlen = sprintf(buf, "%d\n",\r\nha->ip_config.iscsi_max_outstnd_r2t);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_MAX_BURST:\r\nlen = sprintf(buf, "%u\n",\r\nha->ip_config.iscsi_max_burst_len *\r\nBYTE_UNITS);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_CHAP_AUTH_EN:\r\nOP_STATE(ha->ip_config.iscsi_options,\r\nISCSIOPTS_CHAP_AUTH_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_BIDI_CHAP_EN:\r\nOP_STATE(ha->ip_config.iscsi_options,\r\nISCSIOPTS_BIDI_CHAP_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_DISCOVERY_AUTH_OPTIONAL:\r\nOP_STATE(ha->ip_config.iscsi_options,\r\nISCSIOPTS_DISCOVERY_AUTH_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_DISCOVERY_LOGOUT_EN:\r\nOP_STATE(ha->ip_config.iscsi_options,\r\nISCSIOPTS_DISCOVERY_LOGOUT_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_STRICT_LOGIN_COMP_EN:\r\nOP_STATE(ha->ip_config.iscsi_options,\r\nISCSIOPTS_STRICT_LOGIN_COMP_EN, pval);\r\nlen = sprintf(buf, "%s\n", pval);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_INITIATOR_NAME:\r\nlen = sprintf(buf, "%s\n", ha->ip_config.iscsi_name);\r\nbreak;\r\ndefault:\r\nlen = -ENOSYS;\r\n}\r\n}\r\nreturn len;\r\n}\r\nstatic struct iscsi_endpoint *\r\nqla4xxx_ep_connect(struct Scsi_Host *shost, struct sockaddr *dst_addr,\r\nint non_blocking)\r\n{\r\nint ret;\r\nstruct iscsi_endpoint *ep;\r\nstruct qla_endpoint *qla_ep;\r\nstruct scsi_qla_host *ha;\r\nstruct sockaddr_in *addr;\r\nstruct sockaddr_in6 *addr6;\r\nif (!shost) {\r\nret = -ENXIO;\r\npr_err("%s: shost is NULL\n", __func__);\r\nreturn ERR_PTR(ret);\r\n}\r\nha = iscsi_host_priv(shost);\r\nep = iscsi_create_endpoint(sizeof(struct qla_endpoint));\r\nif (!ep) {\r\nret = -ENOMEM;\r\nreturn ERR_PTR(ret);\r\n}\r\nqla_ep = ep->dd_data;\r\nmemset(qla_ep, 0, sizeof(struct qla_endpoint));\r\nif (dst_addr->sa_family == AF_INET) {\r\nmemcpy(&qla_ep->dst_addr, dst_addr, sizeof(struct sockaddr_in));\r\naddr = (struct sockaddr_in *)&qla_ep->dst_addr;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: %pI4\n", __func__,\r\n(char *)&addr->sin_addr));\r\n} else if (dst_addr->sa_family == AF_INET6) {\r\nmemcpy(&qla_ep->dst_addr, dst_addr,\r\nsizeof(struct sockaddr_in6));\r\naddr6 = (struct sockaddr_in6 *)&qla_ep->dst_addr;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: %pI6\n", __func__,\r\n(char *)&addr6->sin6_addr));\r\n} else {\r\nql4_printk(KERN_WARNING, ha, "%s: Invalid endpoint\n",\r\n__func__);\r\n}\r\nqla_ep->host = shost;\r\nreturn ep;\r\n}\r\nstatic int qla4xxx_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)\r\n{\r\nstruct qla_endpoint *qla_ep;\r\nstruct scsi_qla_host *ha;\r\nint ret = 0;\r\nqla_ep = ep->dd_data;\r\nha = to_qla_host(qla_ep->host);\r\nDEBUG2(pr_info_ratelimited("%s: host: %ld\n", __func__, ha->host_no));\r\nif (adapter_up(ha) && !test_bit(AF_BUILD_DDB_LIST, &ha->flags))\r\nret = 1;\r\nreturn ret;\r\n}\r\nstatic void qla4xxx_ep_disconnect(struct iscsi_endpoint *ep)\r\n{\r\nstruct qla_endpoint *qla_ep;\r\nstruct scsi_qla_host *ha;\r\nqla_ep = ep->dd_data;\r\nha = to_qla_host(qla_ep->host);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: host: %ld\n", __func__,\r\nha->host_no));\r\niscsi_destroy_endpoint(ep);\r\n}\r\nstatic int qla4xxx_get_ep_param(struct iscsi_endpoint *ep,\r\nenum iscsi_param param,\r\nchar *buf)\r\n{\r\nstruct qla_endpoint *qla_ep = ep->dd_data;\r\nstruct sockaddr *dst_addr;\r\nstruct scsi_qla_host *ha;\r\nif (!qla_ep)\r\nreturn -ENOTCONN;\r\nha = to_qla_host(qla_ep->host);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: host: %ld\n", __func__,\r\nha->host_no));\r\nswitch (param) {\r\ncase ISCSI_PARAM_CONN_PORT:\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\ndst_addr = (struct sockaddr *)&qla_ep->dst_addr;\r\nif (!dst_addr)\r\nreturn -ENOTCONN;\r\nreturn iscsi_conn_get_addr_param((struct sockaddr_storage *)\r\n&qla_ep->dst_addr, param, buf);\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\n}\r\nstatic void qla4xxx_conn_get_stats(struct iscsi_cls_conn *cls_conn,\r\nstruct iscsi_stats *stats)\r\n{\r\nstruct iscsi_session *sess;\r\nstruct iscsi_cls_session *cls_sess;\r\nstruct ddb_entry *ddb_entry;\r\nstruct scsi_qla_host *ha;\r\nstruct ql_iscsi_stats *ql_iscsi_stats;\r\nint stats_size;\r\nint ret;\r\ndma_addr_t iscsi_stats_dma;\r\ncls_sess = iscsi_conn_to_session(cls_conn);\r\nsess = cls_sess->dd_data;\r\nddb_entry = sess->dd_data;\r\nha = ddb_entry->ha;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: host: %ld\n", __func__,\r\nha->host_no));\r\nstats_size = PAGE_ALIGN(sizeof(struct ql_iscsi_stats));\r\nql_iscsi_stats = dma_alloc_coherent(&ha->pdev->dev, stats_size,\r\n&iscsi_stats_dma, GFP_KERNEL);\r\nif (!ql_iscsi_stats) {\r\nql4_printk(KERN_ERR, ha,\r\n"Unable to allocate memory for iscsi stats\n");\r\ngoto exit_get_stats;\r\n}\r\nret = qla4xxx_get_mgmt_data(ha, ddb_entry->fw_ddb_index, stats_size,\r\niscsi_stats_dma);\r\nif (ret != QLA_SUCCESS) {\r\nql4_printk(KERN_ERR, ha,\r\n"Unable to retrieve iscsi stats\n");\r\ngoto free_stats;\r\n}\r\nstats->txdata_octets = le64_to_cpu(ql_iscsi_stats->tx_data_octets);\r\nstats->rxdata_octets = le64_to_cpu(ql_iscsi_stats->rx_data_octets);\r\nstats->noptx_pdus = le32_to_cpu(ql_iscsi_stats->tx_nopout_pdus);\r\nstats->scsicmd_pdus = le32_to_cpu(ql_iscsi_stats->tx_scsi_cmd_pdus);\r\nstats->tmfcmd_pdus = le32_to_cpu(ql_iscsi_stats->tx_tmf_cmd_pdus);\r\nstats->login_pdus = le32_to_cpu(ql_iscsi_stats->tx_login_cmd_pdus);\r\nstats->text_pdus = le32_to_cpu(ql_iscsi_stats->tx_text_cmd_pdus);\r\nstats->dataout_pdus = le32_to_cpu(ql_iscsi_stats->tx_scsi_write_pdus);\r\nstats->logout_pdus = le32_to_cpu(ql_iscsi_stats->tx_logout_cmd_pdus);\r\nstats->snack_pdus = le32_to_cpu(ql_iscsi_stats->tx_snack_req_pdus);\r\nstats->noprx_pdus = le32_to_cpu(ql_iscsi_stats->rx_nopin_pdus);\r\nstats->scsirsp_pdus = le32_to_cpu(ql_iscsi_stats->rx_scsi_resp_pdus);\r\nstats->tmfrsp_pdus = le32_to_cpu(ql_iscsi_stats->rx_tmf_resp_pdus);\r\nstats->textrsp_pdus = le32_to_cpu(ql_iscsi_stats->rx_text_resp_pdus);\r\nstats->datain_pdus = le32_to_cpu(ql_iscsi_stats->rx_scsi_read_pdus);\r\nstats->logoutrsp_pdus =\r\nle32_to_cpu(ql_iscsi_stats->rx_logout_resp_pdus);\r\nstats->r2t_pdus = le32_to_cpu(ql_iscsi_stats->rx_r2t_pdus);\r\nstats->async_pdus = le32_to_cpu(ql_iscsi_stats->rx_async_pdus);\r\nstats->rjt_pdus = le32_to_cpu(ql_iscsi_stats->rx_reject_pdus);\r\nfree_stats:\r\ndma_free_coherent(&ha->pdev->dev, stats_size, ql_iscsi_stats,\r\niscsi_stats_dma);\r\nexit_get_stats:\r\nreturn;\r\n}\r\nstatic enum blk_eh_timer_return qla4xxx_eh_cmd_timed_out(struct scsi_cmnd *sc)\r\n{\r\nstruct iscsi_cls_session *session;\r\nstruct iscsi_session *sess;\r\nunsigned long flags;\r\nenum blk_eh_timer_return ret = BLK_EH_NOT_HANDLED;\r\nsession = starget_to_session(scsi_target(sc->device));\r\nsess = session->dd_data;\r\nspin_lock_irqsave(&session->lock, flags);\r\nif (session->state == ISCSI_SESSION_FAILED)\r\nret = BLK_EH_RESET_TIMER;\r\nspin_unlock_irqrestore(&session->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void qla4xxx_set_port_speed(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nstruct iscsi_cls_host *ihost = shost->shost_data;\r\nuint32_t speed = ISCSI_PORT_SPEED_UNKNOWN;\r\nqla4xxx_get_firmware_state(ha);\r\nswitch (ha->addl_fw_state & 0x0F00) {\r\ncase FW_ADDSTATE_LINK_SPEED_10MBPS:\r\nspeed = ISCSI_PORT_SPEED_10MBPS;\r\nbreak;\r\ncase FW_ADDSTATE_LINK_SPEED_100MBPS:\r\nspeed = ISCSI_PORT_SPEED_100MBPS;\r\nbreak;\r\ncase FW_ADDSTATE_LINK_SPEED_1GBPS:\r\nspeed = ISCSI_PORT_SPEED_1GBPS;\r\nbreak;\r\ncase FW_ADDSTATE_LINK_SPEED_10GBPS:\r\nspeed = ISCSI_PORT_SPEED_10GBPS;\r\nbreak;\r\n}\r\nihost->port_speed = speed;\r\n}\r\nstatic void qla4xxx_set_port_state(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nstruct iscsi_cls_host *ihost = shost->shost_data;\r\nuint32_t state = ISCSI_PORT_STATE_DOWN;\r\nif (test_bit(AF_LINK_UP, &ha->flags))\r\nstate = ISCSI_PORT_STATE_UP;\r\nihost->port_state = state;\r\n}\r\nstatic int qla4xxx_host_get_param(struct Scsi_Host *shost,\r\nenum iscsi_host_param param, char *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nint len;\r\nswitch (param) {\r\ncase ISCSI_HOST_PARAM_HWADDRESS:\r\nlen = sysfs_format_mac(buf, ha->my_mac, MAC_ADDR_LEN);\r\nbreak;\r\ncase ISCSI_HOST_PARAM_IPADDRESS:\r\nlen = sprintf(buf, "%pI4\n", &ha->ip_config.ip_address);\r\nbreak;\r\ncase ISCSI_HOST_PARAM_INITIATOR_NAME:\r\nlen = sprintf(buf, "%s\n", ha->name_string);\r\nbreak;\r\ncase ISCSI_HOST_PARAM_PORT_STATE:\r\nqla4xxx_set_port_state(shost);\r\nlen = sprintf(buf, "%s\n", iscsi_get_port_state_name(shost));\r\nbreak;\r\ncase ISCSI_HOST_PARAM_PORT_SPEED:\r\nqla4xxx_set_port_speed(shost);\r\nlen = sprintf(buf, "%s\n", iscsi_get_port_speed_name(shost));\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn len;\r\n}\r\nstatic void qla4xxx_create_ipv4_iface(struct scsi_qla_host *ha)\r\n{\r\nif (ha->iface_ipv4)\r\nreturn;\r\nha->iface_ipv4 = iscsi_create_iface(ha->host,\r\n&qla4xxx_iscsi_transport,\r\nISCSI_IFACE_TYPE_IPV4, 0, 0);\r\nif (!ha->iface_ipv4)\r\nql4_printk(KERN_ERR, ha, "Could not create IPv4 iSCSI "\r\n"iface0.\n");\r\n}\r\nstatic void qla4xxx_create_ipv6_iface(struct scsi_qla_host *ha)\r\n{\r\nif (!ha->iface_ipv6_0)\r\nha->iface_ipv6_0 = iscsi_create_iface(ha->host,\r\n&qla4xxx_iscsi_transport,\r\nISCSI_IFACE_TYPE_IPV6, 0,\r\n0);\r\nif (!ha->iface_ipv6_0)\r\nql4_printk(KERN_ERR, ha, "Could not create IPv6 iSCSI "\r\n"iface0.\n");\r\nif (!ha->iface_ipv6_1)\r\nha->iface_ipv6_1 = iscsi_create_iface(ha->host,\r\n&qla4xxx_iscsi_transport,\r\nISCSI_IFACE_TYPE_IPV6, 1,\r\n0);\r\nif (!ha->iface_ipv6_1)\r\nql4_printk(KERN_ERR, ha, "Could not create IPv6 iSCSI "\r\n"iface1.\n");\r\n}\r\nstatic void qla4xxx_create_ifaces(struct scsi_qla_host *ha)\r\n{\r\nif (ha->ip_config.ipv4_options & IPOPT_IPV4_PROTOCOL_ENABLE)\r\nqla4xxx_create_ipv4_iface(ha);\r\nif (ha->ip_config.ipv6_options & IPV6_OPT_IPV6_PROTOCOL_ENABLE)\r\nqla4xxx_create_ipv6_iface(ha);\r\n}\r\nstatic void qla4xxx_destroy_ipv4_iface(struct scsi_qla_host *ha)\r\n{\r\nif (ha->iface_ipv4) {\r\niscsi_destroy_iface(ha->iface_ipv4);\r\nha->iface_ipv4 = NULL;\r\n}\r\n}\r\nstatic void qla4xxx_destroy_ipv6_iface(struct scsi_qla_host *ha)\r\n{\r\nif (ha->iface_ipv6_0) {\r\niscsi_destroy_iface(ha->iface_ipv6_0);\r\nha->iface_ipv6_0 = NULL;\r\n}\r\nif (ha->iface_ipv6_1) {\r\niscsi_destroy_iface(ha->iface_ipv6_1);\r\nha->iface_ipv6_1 = NULL;\r\n}\r\n}\r\nstatic void qla4xxx_destroy_ifaces(struct scsi_qla_host *ha)\r\n{\r\nqla4xxx_destroy_ipv4_iface(ha);\r\nqla4xxx_destroy_ipv6_iface(ha);\r\n}\r\nstatic void qla4xxx_set_ipv6(struct scsi_qla_host *ha,\r\nstruct iscsi_iface_param_info *iface_param,\r\nstruct addr_ctrl_blk *init_fw_cb)\r\n{\r\nswitch (iface_param->param) {\r\ncase ISCSI_NET_PARAM_IPV6_ADDR:\r\nif (iface_param->iface_num & 0x1)\r\nmemcpy(init_fw_cb->ipv6_addr1, iface_param->value,\r\nsizeof(init_fw_cb->ipv6_addr1));\r\nelse\r\nmemcpy(init_fw_cb->ipv6_addr0, iface_param->value,\r\nsizeof(init_fw_cb->ipv6_addr0));\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_LINKLOCAL:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nmemcpy(init_fw_cb->ipv6_if_id, &iface_param->value[8],\r\nsizeof(init_fw_cb->ipv6_if_id));\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_ROUTER:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nmemcpy(init_fw_cb->ipv6_dflt_rtr_addr, iface_param->value,\r\nsizeof(init_fw_cb->ipv6_dflt_rtr_addr));\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_ADDR_AUTOCFG:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_IPV6_AUTOCFG_DISABLE)\r\ninit_fw_cb->ipv6_addtl_opts &=\r\ncpu_to_le16(\r\n~IPV6_ADDOPT_NEIGHBOR_DISCOVERY_ADDR_ENABLE);\r\nelse if (iface_param->value[0] == ISCSI_IPV6_AUTOCFG_ND_ENABLE)\r\ninit_fw_cb->ipv6_addtl_opts |=\r\ncpu_to_le16(\r\nIPV6_ADDOPT_NEIGHBOR_DISCOVERY_ADDR_ENABLE);\r\nelse\r\nql4_printk(KERN_ERR, ha,\r\n"Invalid autocfg setting for IPv6 addr\n");\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_LINKLOCAL_AUTOCFG:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] ==\r\nISCSI_IPV6_LINKLOCAL_AUTOCFG_ENABLE)\r\ninit_fw_cb->ipv6_addtl_opts |= cpu_to_le16(\r\nIPV6_ADDOPT_AUTOCONFIG_LINK_LOCAL_ADDR);\r\nelse if (iface_param->value[0] ==\r\nISCSI_IPV6_LINKLOCAL_AUTOCFG_DISABLE)\r\ninit_fw_cb->ipv6_addtl_opts &= cpu_to_le16(\r\n~IPV6_ADDOPT_AUTOCONFIG_LINK_LOCAL_ADDR);\r\nelse\r\nql4_printk(KERN_ERR, ha,\r\n"Invalid autocfg setting for IPv6 linklocal addr\n");\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_ROUTER_AUTOCFG:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_IPV6_ROUTER_AUTOCFG_ENABLE)\r\nmemset(init_fw_cb->ipv6_dflt_rtr_addr, 0,\r\nsizeof(init_fw_cb->ipv6_dflt_rtr_addr));\r\nbreak;\r\ncase ISCSI_NET_PARAM_IFACE_ENABLE:\r\nif (iface_param->value[0] == ISCSI_IFACE_ENABLE) {\r\ninit_fw_cb->ipv6_opts |=\r\ncpu_to_le16(IPV6_OPT_IPV6_PROTOCOL_ENABLE);\r\nqla4xxx_create_ipv6_iface(ha);\r\n} else {\r\ninit_fw_cb->ipv6_opts &=\r\ncpu_to_le16(~IPV6_OPT_IPV6_PROTOCOL_ENABLE &\r\n0xFFFF);\r\nqla4xxx_destroy_ipv6_iface(ha);\r\n}\r\nbreak;\r\ncase ISCSI_NET_PARAM_VLAN_TAG:\r\nif (iface_param->len != sizeof(init_fw_cb->ipv6_vlan_tag))\r\nbreak;\r\ninit_fw_cb->ipv6_vlan_tag =\r\ncpu_to_be16(*(uint16_t *)iface_param->value);\r\nbreak;\r\ncase ISCSI_NET_PARAM_VLAN_ENABLED:\r\nif (iface_param->value[0] == ISCSI_VLAN_ENABLE)\r\ninit_fw_cb->ipv6_opts |=\r\ncpu_to_le16(IPV6_OPT_VLAN_TAGGING_ENABLE);\r\nelse\r\ninit_fw_cb->ipv6_opts &=\r\ncpu_to_le16(~IPV6_OPT_VLAN_TAGGING_ENABLE);\r\nbreak;\r\ncase ISCSI_NET_PARAM_MTU:\r\ninit_fw_cb->eth_mtu_size =\r\ncpu_to_le16(*(uint16_t *)iface_param->value);\r\nbreak;\r\ncase ISCSI_NET_PARAM_PORT:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->ipv6_port =\r\ncpu_to_le16(*(uint16_t *)iface_param->value);\r\nbreak;\r\ncase ISCSI_NET_PARAM_DELAYED_ACK_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\r\ninit_fw_cb->ipv6_tcp_opts |=\r\ncpu_to_le16(IPV6_TCPOPT_DELAYED_ACK_DISABLE);\r\nelse\r\ninit_fw_cb->ipv6_tcp_opts &=\r\ncpu_to_le16(~IPV6_TCPOPT_DELAYED_ACK_DISABLE &\r\n0xFFFF);\r\nbreak;\r\ncase ISCSI_NET_PARAM_TCP_NAGLE_DISABLE:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\r\ninit_fw_cb->ipv6_tcp_opts |=\r\ncpu_to_le16(IPV6_TCPOPT_NAGLE_ALGO_DISABLE);\r\nelse\r\ninit_fw_cb->ipv6_tcp_opts &=\r\ncpu_to_le16(~IPV6_TCPOPT_NAGLE_ALGO_DISABLE);\r\nbreak;\r\ncase ISCSI_NET_PARAM_TCP_WSF_DISABLE:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\r\ninit_fw_cb->ipv6_tcp_opts |=\r\ncpu_to_le16(IPV6_TCPOPT_WINDOW_SCALE_DISABLE);\r\nelse\r\ninit_fw_cb->ipv6_tcp_opts &=\r\ncpu_to_le16(~IPV6_TCPOPT_WINDOW_SCALE_DISABLE);\r\nbreak;\r\ncase ISCSI_NET_PARAM_TCP_WSF:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->ipv6_tcp_wsf = iface_param->value[0];\r\nbreak;\r\ncase ISCSI_NET_PARAM_TCP_TIMER_SCALE:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->ipv6_tcp_opts &=\r\ncpu_to_le16(~IPV6_TCPOPT_TIMER_SCALE);\r\ninit_fw_cb->ipv6_tcp_opts |=\r\ncpu_to_le16((iface_param->value[0] << 1) &\r\nIPV6_TCPOPT_TIMER_SCALE);\r\nbreak;\r\ncase ISCSI_NET_PARAM_TCP_TIMESTAMP_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->ipv6_tcp_opts |=\r\ncpu_to_le16(IPV6_TCPOPT_TIMESTAMP_EN);\r\nelse\r\ninit_fw_cb->ipv6_tcp_opts &=\r\ncpu_to_le16(~IPV6_TCPOPT_TIMESTAMP_EN);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_GRAT_NEIGHBOR_ADV_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->ipv6_opts |=\r\ncpu_to_le16(IPV6_OPT_GRAT_NEIGHBOR_ADV_EN);\r\nelse\r\ninit_fw_cb->ipv6_opts &=\r\ncpu_to_le16(~IPV6_OPT_GRAT_NEIGHBOR_ADV_EN);\r\nbreak;\r\ncase ISCSI_NET_PARAM_REDIRECT_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->ipv6_opts |=\r\ncpu_to_le16(IPV6_OPT_REDIRECT_EN);\r\nelse\r\ninit_fw_cb->ipv6_opts &=\r\ncpu_to_le16(~IPV6_OPT_REDIRECT_EN);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_MLD_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->ipv6_addtl_opts |=\r\ncpu_to_le16(IPV6_ADDOPT_MLD_EN);\r\nelse\r\ninit_fw_cb->ipv6_addtl_opts &=\r\ncpu_to_le16(~IPV6_ADDOPT_MLD_EN);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_FLOW_LABEL:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->ipv6_flow_lbl =\r\ncpu_to_le16(*(uint16_t *)iface_param->value);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_TRAFFIC_CLASS:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->ipv6_traffic_class = iface_param->value[0];\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_HOP_LIMIT:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->ipv6_hop_limit = iface_param->value[0];\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_ND_REACHABLE_TMO:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->ipv6_nd_reach_time =\r\ncpu_to_le32(*(uint32_t *)iface_param->value);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_ND_REXMIT_TIME:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->ipv6_nd_rexmit_timer =\r\ncpu_to_le32(*(uint32_t *)iface_param->value);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_ND_STALE_TMO:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->ipv6_nd_stale_timeout =\r\ncpu_to_le32(*(uint32_t *)iface_param->value);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_DUP_ADDR_DETECT_CNT:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->ipv6_dup_addr_detect_count = iface_param->value[0];\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_RTR_ADV_LINK_MTU:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->ipv6_gw_advrt_mtu =\r\ncpu_to_le32(*(uint32_t *)iface_param->value);\r\nbreak;\r\ndefault:\r\nql4_printk(KERN_ERR, ha, "Unknown IPv6 param = %d\n",\r\niface_param->param);\r\nbreak;\r\n}\r\n}\r\nstatic void qla4xxx_set_ipv4(struct scsi_qla_host *ha,\r\nstruct iscsi_iface_param_info *iface_param,\r\nstruct addr_ctrl_blk *init_fw_cb)\r\n{\r\nswitch (iface_param->param) {\r\ncase ISCSI_NET_PARAM_IPV4_ADDR:\r\nmemcpy(init_fw_cb->ipv4_addr, iface_param->value,\r\nsizeof(init_fw_cb->ipv4_addr));\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_SUBNET:\r\nmemcpy(init_fw_cb->ipv4_subnet, iface_param->value,\r\nsizeof(init_fw_cb->ipv4_subnet));\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_GW:\r\nmemcpy(init_fw_cb->ipv4_gw_addr, iface_param->value,\r\nsizeof(init_fw_cb->ipv4_gw_addr));\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\r\nif (iface_param->value[0] == ISCSI_BOOTPROTO_DHCP)\r\ninit_fw_cb->ipv4_tcp_opts |=\r\ncpu_to_le16(TCPOPT_DHCP_ENABLE);\r\nelse if (iface_param->value[0] == ISCSI_BOOTPROTO_STATIC)\r\ninit_fw_cb->ipv4_tcp_opts &=\r\ncpu_to_le16(~TCPOPT_DHCP_ENABLE);\r\nelse\r\nql4_printk(KERN_ERR, ha, "Invalid IPv4 bootproto\n");\r\nbreak;\r\ncase ISCSI_NET_PARAM_IFACE_ENABLE:\r\nif (iface_param->value[0] == ISCSI_IFACE_ENABLE) {\r\ninit_fw_cb->ipv4_ip_opts |=\r\ncpu_to_le16(IPOPT_IPV4_PROTOCOL_ENABLE);\r\nqla4xxx_create_ipv4_iface(ha);\r\n} else {\r\ninit_fw_cb->ipv4_ip_opts &=\r\ncpu_to_le16(~IPOPT_IPV4_PROTOCOL_ENABLE &\r\n0xFFFF);\r\nqla4xxx_destroy_ipv4_iface(ha);\r\n}\r\nbreak;\r\ncase ISCSI_NET_PARAM_VLAN_TAG:\r\nif (iface_param->len != sizeof(init_fw_cb->ipv4_vlan_tag))\r\nbreak;\r\ninit_fw_cb->ipv4_vlan_tag =\r\ncpu_to_be16(*(uint16_t *)iface_param->value);\r\nbreak;\r\ncase ISCSI_NET_PARAM_VLAN_ENABLED:\r\nif (iface_param->value[0] == ISCSI_VLAN_ENABLE)\r\ninit_fw_cb->ipv4_ip_opts |=\r\ncpu_to_le16(IPOPT_VLAN_TAGGING_ENABLE);\r\nelse\r\ninit_fw_cb->ipv4_ip_opts &=\r\ncpu_to_le16(~IPOPT_VLAN_TAGGING_ENABLE);\r\nbreak;\r\ncase ISCSI_NET_PARAM_MTU:\r\ninit_fw_cb->eth_mtu_size =\r\ncpu_to_le16(*(uint16_t *)iface_param->value);\r\nbreak;\r\ncase ISCSI_NET_PARAM_PORT:\r\ninit_fw_cb->ipv4_port =\r\ncpu_to_le16(*(uint16_t *)iface_param->value);\r\nbreak;\r\ncase ISCSI_NET_PARAM_DELAYED_ACK_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\r\ninit_fw_cb->ipv4_tcp_opts |=\r\ncpu_to_le16(TCPOPT_DELAYED_ACK_DISABLE);\r\nelse\r\ninit_fw_cb->ipv4_tcp_opts &=\r\ncpu_to_le16(~TCPOPT_DELAYED_ACK_DISABLE &\r\n0xFFFF);\r\nbreak;\r\ncase ISCSI_NET_PARAM_TCP_NAGLE_DISABLE:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\r\ninit_fw_cb->ipv4_tcp_opts |=\r\ncpu_to_le16(TCPOPT_NAGLE_ALGO_DISABLE);\r\nelse\r\ninit_fw_cb->ipv4_tcp_opts &=\r\ncpu_to_le16(~TCPOPT_NAGLE_ALGO_DISABLE);\r\nbreak;\r\ncase ISCSI_NET_PARAM_TCP_WSF_DISABLE:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\r\ninit_fw_cb->ipv4_tcp_opts |=\r\ncpu_to_le16(TCPOPT_WINDOW_SCALE_DISABLE);\r\nelse\r\ninit_fw_cb->ipv4_tcp_opts &=\r\ncpu_to_le16(~TCPOPT_WINDOW_SCALE_DISABLE);\r\nbreak;\r\ncase ISCSI_NET_PARAM_TCP_WSF:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->ipv4_tcp_wsf = iface_param->value[0];\r\nbreak;\r\ncase ISCSI_NET_PARAM_TCP_TIMER_SCALE:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->ipv4_tcp_opts &= cpu_to_le16(~TCPOPT_TIMER_SCALE);\r\ninit_fw_cb->ipv4_tcp_opts |=\r\ncpu_to_le16((iface_param->value[0] << 1) &\r\nTCPOPT_TIMER_SCALE);\r\nbreak;\r\ncase ISCSI_NET_PARAM_TCP_TIMESTAMP_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->ipv4_tcp_opts |=\r\ncpu_to_le16(TCPOPT_TIMESTAMP_ENABLE);\r\nelse\r\ninit_fw_cb->ipv4_tcp_opts &=\r\ncpu_to_le16(~TCPOPT_TIMESTAMP_ENABLE);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_DNS_ADDR_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->ipv4_tcp_opts |=\r\ncpu_to_le16(TCPOPT_DNS_SERVER_IP_EN);\r\nelse\r\ninit_fw_cb->ipv4_tcp_opts &=\r\ncpu_to_le16(~TCPOPT_DNS_SERVER_IP_EN);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_SLP_DA_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->ipv4_tcp_opts |=\r\ncpu_to_le16(TCPOPT_SLP_DA_INFO_EN);\r\nelse\r\ninit_fw_cb->ipv4_tcp_opts &=\r\ncpu_to_le16(~TCPOPT_SLP_DA_INFO_EN);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_TOS_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->ipv4_ip_opts |=\r\ncpu_to_le16(IPOPT_IPV4_TOS_EN);\r\nelse\r\ninit_fw_cb->ipv4_ip_opts &=\r\ncpu_to_le16(~IPOPT_IPV4_TOS_EN);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_TOS:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->ipv4_tos = iface_param->value[0];\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_GRAT_ARP_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->ipv4_ip_opts |=\r\ncpu_to_le16(IPOPT_GRAT_ARP_EN);\r\nelse\r\ninit_fw_cb->ipv4_ip_opts &=\r\ncpu_to_le16(~IPOPT_GRAT_ARP_EN);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->ipv4_ip_opts |=\r\ncpu_to_le16(IPOPT_ALT_CID_EN);\r\nelse\r\ninit_fw_cb->ipv4_ip_opts &=\r\ncpu_to_le16(~IPOPT_ALT_CID_EN);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nmemcpy(init_fw_cb->ipv4_dhcp_alt_cid, iface_param->value,\r\n(sizeof(init_fw_cb->ipv4_dhcp_alt_cid) - 1));\r\ninit_fw_cb->ipv4_dhcp_alt_cid_len =\r\nstrlen(init_fw_cb->ipv4_dhcp_alt_cid);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_REQ_VENDOR_ID_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->ipv4_ip_opts |=\r\ncpu_to_le16(IPOPT_REQ_VID_EN);\r\nelse\r\ninit_fw_cb->ipv4_ip_opts &=\r\ncpu_to_le16(~IPOPT_REQ_VID_EN);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_USE_VENDOR_ID_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->ipv4_ip_opts |=\r\ncpu_to_le16(IPOPT_USE_VID_EN);\r\nelse\r\ninit_fw_cb->ipv4_ip_opts &=\r\ncpu_to_le16(~IPOPT_USE_VID_EN);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_VENDOR_ID:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nmemcpy(init_fw_cb->ipv4_dhcp_vid, iface_param->value,\r\n(sizeof(init_fw_cb->ipv4_dhcp_vid) - 1));\r\ninit_fw_cb->ipv4_dhcp_vid_len =\r\nstrlen(init_fw_cb->ipv4_dhcp_vid);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_DHCP_LEARN_IQN_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->ipv4_ip_opts |=\r\ncpu_to_le16(IPOPT_LEARN_IQN_EN);\r\nelse\r\ninit_fw_cb->ipv4_ip_opts &=\r\ncpu_to_le16(~IPOPT_LEARN_IQN_EN);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_FRAGMENT_DISABLE:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\r\ninit_fw_cb->ipv4_ip_opts |=\r\ncpu_to_le16(IPOPT_FRAGMENTATION_DISABLE);\r\nelse\r\ninit_fw_cb->ipv4_ip_opts &=\r\ncpu_to_le16(~IPOPT_FRAGMENTATION_DISABLE);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_IN_FORWARD_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->ipv4_ip_opts |=\r\ncpu_to_le16(IPOPT_IN_FORWARD_EN);\r\nelse\r\ninit_fw_cb->ipv4_ip_opts &=\r\ncpu_to_le16(~IPOPT_IN_FORWARD_EN);\r\nbreak;\r\ncase ISCSI_NET_PARAM_REDIRECT_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->ipv4_ip_opts |=\r\ncpu_to_le16(IPOPT_ARP_REDIRECT_EN);\r\nelse\r\ninit_fw_cb->ipv4_ip_opts &=\r\ncpu_to_le16(~IPOPT_ARP_REDIRECT_EN);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_TTL:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->ipv4_ttl = iface_param->value[0];\r\nbreak;\r\ndefault:\r\nql4_printk(KERN_ERR, ha, "Unknown IPv4 param = %d\n",\r\niface_param->param);\r\nbreak;\r\n}\r\n}\r\nstatic void qla4xxx_set_iscsi_param(struct scsi_qla_host *ha,\r\nstruct iscsi_iface_param_info *iface_param,\r\nstruct addr_ctrl_blk *init_fw_cb)\r\n{\r\nswitch (iface_param->param) {\r\ncase ISCSI_IFACE_PARAM_DEF_TASKMGMT_TMO:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->def_timeout =\r\ncpu_to_le16(*(uint16_t *)iface_param->value);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_HDRDGST_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->iscsi_opts |=\r\ncpu_to_le16(ISCSIOPTS_HEADER_DIGEST_EN);\r\nelse\r\ninit_fw_cb->iscsi_opts &=\r\ncpu_to_le16(~ISCSIOPTS_HEADER_DIGEST_EN);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_DATADGST_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->iscsi_opts |=\r\ncpu_to_le16(ISCSIOPTS_DATA_DIGEST_EN);\r\nelse\r\ninit_fw_cb->iscsi_opts &=\r\ncpu_to_le16(~ISCSIOPTS_DATA_DIGEST_EN);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_IMM_DATA_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->iscsi_opts |=\r\ncpu_to_le16(ISCSIOPTS_IMMEDIATE_DATA_EN);\r\nelse\r\ninit_fw_cb->iscsi_opts &=\r\ncpu_to_le16(~ISCSIOPTS_IMMEDIATE_DATA_EN);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_INITIAL_R2T_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->iscsi_opts |=\r\ncpu_to_le16(ISCSIOPTS_INITIAL_R2T_EN);\r\nelse\r\ninit_fw_cb->iscsi_opts &=\r\ncpu_to_le16(~ISCSIOPTS_INITIAL_R2T_EN);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_DATASEQ_INORDER_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->iscsi_opts |=\r\ncpu_to_le16(ISCSIOPTS_DATA_SEQ_INORDER_EN);\r\nelse\r\ninit_fw_cb->iscsi_opts &=\r\ncpu_to_le16(~ISCSIOPTS_DATA_SEQ_INORDER_EN);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_PDU_INORDER_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->iscsi_opts |=\r\ncpu_to_le16(ISCSIOPTS_DATA_PDU_INORDER_EN);\r\nelse\r\ninit_fw_cb->iscsi_opts &=\r\ncpu_to_le16(~ISCSIOPTS_DATA_PDU_INORDER_EN);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_ERL:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->iscsi_opts &= cpu_to_le16(~ISCSIOPTS_ERL);\r\ninit_fw_cb->iscsi_opts |= cpu_to_le16(iface_param->value[0] &\r\nISCSIOPTS_ERL);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_MAX_RECV_DLENGTH:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->iscsi_max_pdu_size =\r\ncpu_to_le32(*(uint32_t *)iface_param->value) /\r\nBYTE_UNITS;\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_FIRST_BURST:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->iscsi_fburst_len =\r\ncpu_to_le32(*(uint32_t *)iface_param->value) /\r\nBYTE_UNITS;\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_MAX_R2T:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->iscsi_max_outstnd_r2t =\r\ncpu_to_le16(*(uint16_t *)iface_param->value);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_MAX_BURST:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\ninit_fw_cb->iscsi_max_burst_len =\r\ncpu_to_le32(*(uint32_t *)iface_param->value) /\r\nBYTE_UNITS;\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_CHAP_AUTH_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->iscsi_opts |=\r\ncpu_to_le16(ISCSIOPTS_CHAP_AUTH_EN);\r\nelse\r\ninit_fw_cb->iscsi_opts &=\r\ncpu_to_le16(~ISCSIOPTS_CHAP_AUTH_EN);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_BIDI_CHAP_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->iscsi_opts |=\r\ncpu_to_le16(ISCSIOPTS_BIDI_CHAP_EN);\r\nelse\r\ninit_fw_cb->iscsi_opts &=\r\ncpu_to_le16(~ISCSIOPTS_BIDI_CHAP_EN);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_DISCOVERY_AUTH_OPTIONAL:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->iscsi_opts |=\r\ncpu_to_le16(ISCSIOPTS_DISCOVERY_AUTH_EN);\r\nelse\r\ninit_fw_cb->iscsi_opts &=\r\ncpu_to_le16(~ISCSIOPTS_DISCOVERY_AUTH_EN);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_DISCOVERY_LOGOUT_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->iscsi_opts |=\r\ncpu_to_le16(ISCSIOPTS_DISCOVERY_LOGOUT_EN);\r\nelse\r\ninit_fw_cb->iscsi_opts &=\r\ncpu_to_le16(~ISCSIOPTS_DISCOVERY_LOGOUT_EN);\r\nbreak;\r\ncase ISCSI_IFACE_PARAM_STRICT_LOGIN_COMP_EN:\r\nif (iface_param->iface_num & 0x1)\r\nbreak;\r\nif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\r\ninit_fw_cb->iscsi_opts |=\r\ncpu_to_le16(ISCSIOPTS_STRICT_LOGIN_COMP_EN);\r\nelse\r\ninit_fw_cb->iscsi_opts &=\r\ncpu_to_le16(~ISCSIOPTS_STRICT_LOGIN_COMP_EN);\r\nbreak;\r\ndefault:\r\nql4_printk(KERN_ERR, ha, "Unknown iscsi param = %d\n",\r\niface_param->param);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nqla4xxx_initcb_to_acb(struct addr_ctrl_blk *init_fw_cb)\r\n{\r\nstruct addr_ctrl_blk_def *acb;\r\nacb = (struct addr_ctrl_blk_def *)init_fw_cb;\r\nmemset(acb->reserved1, 0, sizeof(acb->reserved1));\r\nmemset(acb->reserved2, 0, sizeof(acb->reserved2));\r\nmemset(acb->reserved3, 0, sizeof(acb->reserved3));\r\nmemset(acb->reserved4, 0, sizeof(acb->reserved4));\r\nmemset(acb->reserved5, 0, sizeof(acb->reserved5));\r\nmemset(acb->reserved6, 0, sizeof(acb->reserved6));\r\nmemset(acb->reserved7, 0, sizeof(acb->reserved7));\r\nmemset(acb->reserved8, 0, sizeof(acb->reserved8));\r\nmemset(acb->reserved9, 0, sizeof(acb->reserved9));\r\nmemset(acb->reserved10, 0, sizeof(acb->reserved10));\r\nmemset(acb->reserved11, 0, sizeof(acb->reserved11));\r\nmemset(acb->reserved12, 0, sizeof(acb->reserved12));\r\nmemset(acb->reserved13, 0, sizeof(acb->reserved13));\r\nmemset(acb->reserved14, 0, sizeof(acb->reserved14));\r\nmemset(acb->reserved15, 0, sizeof(acb->reserved15));\r\n}\r\nstatic int\r\nqla4xxx_iface_set_param(struct Scsi_Host *shost, void *data, uint32_t len)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nint rval = 0;\r\nstruct iscsi_iface_param_info *iface_param = NULL;\r\nstruct addr_ctrl_blk *init_fw_cb = NULL;\r\ndma_addr_t init_fw_cb_dma;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nuint32_t rem = len;\r\nstruct nlattr *attr;\r\ninit_fw_cb = dma_alloc_coherent(&ha->pdev->dev,\r\nsizeof(struct addr_ctrl_blk),\r\n&init_fw_cb_dma, GFP_KERNEL);\r\nif (!init_fw_cb) {\r\nql4_printk(KERN_ERR, ha, "%s: Unable to alloc init_cb\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(init_fw_cb, 0, sizeof(struct addr_ctrl_blk));\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nif (qla4xxx_get_ifcb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb_dma)) {\r\nql4_printk(KERN_ERR, ha, "%s: get ifcb failed\n", __func__);\r\nrval = -EIO;\r\ngoto exit_init_fw_cb;\r\n}\r\nnla_for_each_attr(attr, data, len, rem) {\r\niface_param = nla_data(attr);\r\nif (iface_param->param_type == ISCSI_NET_PARAM) {\r\nswitch (iface_param->iface_type) {\r\ncase ISCSI_IFACE_TYPE_IPV4:\r\nswitch (iface_param->iface_num) {\r\ncase 0:\r\nqla4xxx_set_ipv4(ha, iface_param,\r\ninit_fw_cb);\r\nbreak;\r\ndefault:\r\nql4_printk(KERN_ERR, ha,\r\n"Invalid IPv4 iface number = %d\n",\r\niface_param->iface_num);\r\nbreak;\r\n}\r\nbreak;\r\ncase ISCSI_IFACE_TYPE_IPV6:\r\nswitch (iface_param->iface_num) {\r\ncase 0:\r\ncase 1:\r\nqla4xxx_set_ipv6(ha, iface_param,\r\ninit_fw_cb);\r\nbreak;\r\ndefault:\r\nql4_printk(KERN_ERR, ha,\r\n"Invalid IPv6 iface number = %d\n",\r\niface_param->iface_num);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nql4_printk(KERN_ERR, ha,\r\n"Invalid iface type\n");\r\nbreak;\r\n}\r\n} else if (iface_param->param_type == ISCSI_IFACE_PARAM) {\r\nqla4xxx_set_iscsi_param(ha, iface_param,\r\ninit_fw_cb);\r\n} else {\r\ncontinue;\r\n}\r\n}\r\ninit_fw_cb->cookie = cpu_to_le32(0x11BEAD5A);\r\nrval = qla4xxx_set_flash(ha, init_fw_cb_dma, FLASH_SEGMENT_IFCB,\r\nsizeof(struct addr_ctrl_blk),\r\nFLASH_OPT_RMW_COMMIT);\r\nif (rval != QLA_SUCCESS) {\r\nql4_printk(KERN_ERR, ha, "%s: set flash mbx failed\n",\r\n__func__);\r\nrval = -EIO;\r\ngoto exit_init_fw_cb;\r\n}\r\nrval = qla4xxx_disable_acb(ha);\r\nif (rval != QLA_SUCCESS) {\r\nql4_printk(KERN_ERR, ha, "%s: disable acb mbx failed\n",\r\n__func__);\r\nrval = -EIO;\r\ngoto exit_init_fw_cb;\r\n}\r\nwait_for_completion_timeout(&ha->disable_acb_comp,\r\nDISABLE_ACB_TOV * HZ);\r\nqla4xxx_initcb_to_acb(init_fw_cb);\r\nrval = qla4xxx_set_acb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb_dma);\r\nif (rval != QLA_SUCCESS) {\r\nql4_printk(KERN_ERR, ha, "%s: set acb mbx failed\n",\r\n__func__);\r\nrval = -EIO;\r\ngoto exit_init_fw_cb;\r\n}\r\nmemset(init_fw_cb, 0, sizeof(struct addr_ctrl_blk));\r\nqla4xxx_update_local_ifcb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb,\r\ninit_fw_cb_dma);\r\nexit_init_fw_cb:\r\ndma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk),\r\ninit_fw_cb, init_fw_cb_dma);\r\nreturn rval;\r\n}\r\nstatic int qla4xxx_session_get_param(struct iscsi_cls_session *cls_sess,\r\nenum iscsi_param param, char *buf)\r\n{\r\nstruct iscsi_session *sess = cls_sess->dd_data;\r\nstruct ddb_entry *ddb_entry = sess->dd_data;\r\nstruct scsi_qla_host *ha = ddb_entry->ha;\r\nstruct iscsi_cls_conn *cls_conn = ddb_entry->conn;\r\nstruct ql4_chap_table chap_tbl;\r\nint rval, len;\r\nuint16_t idx;\r\nmemset(&chap_tbl, 0, sizeof(chap_tbl));\r\nswitch (param) {\r\ncase ISCSI_PARAM_CHAP_IN_IDX:\r\nrval = qla4xxx_get_chap_index(ha, sess->username_in,\r\nsess->password_in, BIDI_CHAP,\r\n&idx);\r\nif (rval)\r\nlen = sprintf(buf, "\n");\r\nelse\r\nlen = sprintf(buf, "%hu\n", idx);\r\nbreak;\r\ncase ISCSI_PARAM_CHAP_OUT_IDX:\r\nif (ddb_entry->ddb_type == FLASH_DDB) {\r\nif (ddb_entry->chap_tbl_idx != INVALID_ENTRY) {\r\nidx = ddb_entry->chap_tbl_idx;\r\nrval = QLA_SUCCESS;\r\n} else {\r\nrval = QLA_ERROR;\r\n}\r\n} else {\r\nrval = qla4xxx_get_chap_index(ha, sess->username,\r\nsess->password,\r\nLOCAL_CHAP, &idx);\r\n}\r\nif (rval)\r\nlen = sprintf(buf, "\n");\r\nelse\r\nlen = sprintf(buf, "%hu\n", idx);\r\nbreak;\r\ncase ISCSI_PARAM_USERNAME:\r\ncase ISCSI_PARAM_PASSWORD:\r\nif (ddb_entry->ddb_type == FLASH_DDB &&\r\nddb_entry->chap_tbl_idx != INVALID_ENTRY &&\r\n!sess->username && !sess->password) {\r\nidx = ddb_entry->chap_tbl_idx;\r\nrval = qla4xxx_get_uni_chap_at_index(ha, chap_tbl.name,\r\nchap_tbl.secret,\r\nidx);\r\nif (!rval) {\r\niscsi_set_param(cls_conn, ISCSI_PARAM_USERNAME,\r\n(char *)chap_tbl.name,\r\nstrlen((char *)chap_tbl.name));\r\niscsi_set_param(cls_conn, ISCSI_PARAM_PASSWORD,\r\n(char *)chap_tbl.secret,\r\nchap_tbl.secret_len);\r\n}\r\n}\r\ndefault:\r\nreturn iscsi_session_get_param(cls_sess, param, buf);\r\n}\r\nreturn len;\r\n}\r\nstatic int qla4xxx_conn_get_param(struct iscsi_cls_conn *cls_conn,\r\nenum iscsi_param param, char *buf)\r\n{\r\nstruct iscsi_conn *conn;\r\nstruct qla_conn *qla_conn;\r\nstruct sockaddr *dst_addr;\r\nconn = cls_conn->dd_data;\r\nqla_conn = conn->dd_data;\r\ndst_addr = (struct sockaddr *)&qla_conn->qla_ep->dst_addr;\r\nswitch (param) {\r\ncase ISCSI_PARAM_CONN_PORT:\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\nreturn iscsi_conn_get_addr_param((struct sockaddr_storage *)\r\ndst_addr, param, buf);\r\ndefault:\r\nreturn iscsi_conn_get_param(cls_conn, param, buf);\r\n}\r\n}\r\nint qla4xxx_get_ddb_index(struct scsi_qla_host *ha, uint16_t *ddb_index)\r\n{\r\nuint32_t mbx_sts = 0;\r\nuint16_t tmp_ddb_index;\r\nint ret;\r\nget_ddb_index:\r\ntmp_ddb_index = find_first_zero_bit(ha->ddb_idx_map, MAX_DDB_ENTRIES);\r\nif (tmp_ddb_index >= MAX_DDB_ENTRIES) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Free DDB index not available\n"));\r\nret = QLA_ERROR;\r\ngoto exit_get_ddb_index;\r\n}\r\nif (test_and_set_bit(tmp_ddb_index, ha->ddb_idx_map))\r\ngoto get_ddb_index;\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Found a free DDB index at %d\n", tmp_ddb_index));\r\nret = qla4xxx_req_ddb_entry(ha, tmp_ddb_index, &mbx_sts);\r\nif (ret == QLA_ERROR) {\r\nif (mbx_sts == MBOX_STS_COMMAND_ERROR) {\r\nql4_printk(KERN_INFO, ha,\r\n"DDB index = %d not available trying next\n",\r\ntmp_ddb_index);\r\ngoto get_ddb_index;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Free FW DDB not available\n"));\r\n}\r\n*ddb_index = tmp_ddb_index;\r\nexit_get_ddb_index:\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_match_ipaddress(struct scsi_qla_host *ha,\r\nstruct ddb_entry *ddb_entry,\r\nchar *existing_ipaddr,\r\nchar *user_ipaddr)\r\n{\r\nuint8_t dst_ipaddr[IPv6_ADDR_LEN];\r\nchar formatted_ipaddr[DDB_IPADDR_LEN];\r\nint status = QLA_SUCCESS, ret = 0;\r\nif (ddb_entry->fw_ddb_entry.options & DDB_OPT_IPV6_DEVICE) {\r\nret = in6_pton(user_ipaddr, strlen(user_ipaddr), dst_ipaddr,\r\n'\0', NULL);\r\nif (ret == 0) {\r\nstatus = QLA_ERROR;\r\ngoto out_match;\r\n}\r\nret = sprintf(formatted_ipaddr, "%pI6", dst_ipaddr);\r\n} else {\r\nret = in4_pton(user_ipaddr, strlen(user_ipaddr), dst_ipaddr,\r\n'\0', NULL);\r\nif (ret == 0) {\r\nstatus = QLA_ERROR;\r\ngoto out_match;\r\n}\r\nret = sprintf(formatted_ipaddr, "%pI4", dst_ipaddr);\r\n}\r\nif (strcmp(existing_ipaddr, formatted_ipaddr))\r\nstatus = QLA_ERROR;\r\nout_match:\r\nreturn status;\r\n}\r\nstatic int qla4xxx_match_fwdb_session(struct scsi_qla_host *ha,\r\nstruct iscsi_cls_conn *cls_conn)\r\n{\r\nint idx = 0, max_ddbs, rval;\r\nstruct iscsi_cls_session *cls_sess = iscsi_conn_to_session(cls_conn);\r\nstruct iscsi_session *sess, *existing_sess;\r\nstruct iscsi_conn *conn, *existing_conn;\r\nstruct ddb_entry *ddb_entry;\r\nsess = cls_sess->dd_data;\r\nconn = cls_conn->dd_data;\r\nif (sess->targetname == NULL ||\r\nconn->persistent_address == NULL ||\r\nconn->persistent_port == 0)\r\nreturn QLA_ERROR;\r\nmax_ddbs = is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\r\nMAX_DEV_DB_ENTRIES;\r\nfor (idx = 0; idx < max_ddbs; idx++) {\r\nddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\r\nif (ddb_entry == NULL)\r\ncontinue;\r\nif (ddb_entry->ddb_type != FLASH_DDB)\r\ncontinue;\r\nexisting_sess = ddb_entry->sess->dd_data;\r\nexisting_conn = ddb_entry->conn->dd_data;\r\nif (existing_sess->targetname == NULL ||\r\nexisting_conn->persistent_address == NULL ||\r\nexisting_conn->persistent_port == 0)\r\ncontinue;\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"IQN = %s User IQN = %s\n",\r\nexisting_sess->targetname,\r\nsess->targetname));\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"IP = %s User IP = %s\n",\r\nexisting_conn->persistent_address,\r\nconn->persistent_address));\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Port = %d User Port = %d\n",\r\nexisting_conn->persistent_port,\r\nconn->persistent_port));\r\nif (strcmp(existing_sess->targetname, sess->targetname))\r\ncontinue;\r\nrval = qla4xxx_match_ipaddress(ha, ddb_entry,\r\nexisting_conn->persistent_address,\r\nconn->persistent_address);\r\nif (rval == QLA_ERROR)\r\ncontinue;\r\nif (existing_conn->persistent_port != conn->persistent_port)\r\ncontinue;\r\nbreak;\r\n}\r\nif (idx == max_ddbs)\r\nreturn QLA_ERROR;\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Match found in fwdb sessions\n"));\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic struct iscsi_cls_session *\r\nqla4xxx_session_create(struct iscsi_endpoint *ep,\r\nuint16_t cmds_max, uint16_t qdepth,\r\nuint32_t initial_cmdsn)\r\n{\r\nstruct iscsi_cls_session *cls_sess;\r\nstruct scsi_qla_host *ha;\r\nstruct qla_endpoint *qla_ep;\r\nstruct ddb_entry *ddb_entry;\r\nuint16_t ddb_index;\r\nstruct iscsi_session *sess;\r\nstruct sockaddr *dst_addr;\r\nint ret;\r\nif (!ep) {\r\nprintk(KERN_ERR "qla4xxx: missing ep.\n");\r\nreturn NULL;\r\n}\r\nqla_ep = ep->dd_data;\r\ndst_addr = (struct sockaddr *)&qla_ep->dst_addr;\r\nha = to_qla_host(qla_ep->host);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: host: %ld\n", __func__,\r\nha->host_no));\r\nret = qla4xxx_get_ddb_index(ha, &ddb_index);\r\nif (ret == QLA_ERROR)\r\nreturn NULL;\r\ncls_sess = iscsi_session_setup(&qla4xxx_iscsi_transport, qla_ep->host,\r\ncmds_max, sizeof(struct ddb_entry),\r\nsizeof(struct ql4_task_data),\r\ninitial_cmdsn, ddb_index);\r\nif (!cls_sess)\r\nreturn NULL;\r\nsess = cls_sess->dd_data;\r\nddb_entry = sess->dd_data;\r\nddb_entry->fw_ddb_index = ddb_index;\r\nddb_entry->fw_ddb_device_state = DDB_DS_NO_CONNECTION_ACTIVE;\r\nddb_entry->ha = ha;\r\nddb_entry->sess = cls_sess;\r\nddb_entry->unblock_sess = qla4xxx_unblock_ddb;\r\nddb_entry->ddb_change = qla4xxx_ddb_change;\r\nclear_bit(DDB_CONN_CLOSE_FAILURE, &ddb_entry->flags);\r\ncls_sess->recovery_tmo = ql4xsess_recovery_tmo;\r\nha->fw_ddb_index_map[ddb_entry->fw_ddb_index] = ddb_entry;\r\nha->tot_ddbs++;\r\nreturn cls_sess;\r\n}\r\nstatic void qla4xxx_session_destroy(struct iscsi_cls_session *cls_sess)\r\n{\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb_entry;\r\nstruct scsi_qla_host *ha;\r\nunsigned long flags, wtime;\r\nstruct dev_db_entry *fw_ddb_entry = NULL;\r\ndma_addr_t fw_ddb_entry_dma;\r\nuint32_t ddb_state;\r\nint ret;\r\nsess = cls_sess->dd_data;\r\nddb_entry = sess->dd_data;\r\nha = ddb_entry->ha;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: host: %ld\n", __func__,\r\nha->host_no));\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (!fw_ddb_entry) {\r\nql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer\n", __func__);\r\ngoto destroy_session;\r\n}\r\nwtime = jiffies + (HZ * LOGOUT_TOV);\r\ndo {\r\nret = qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index,\r\nfw_ddb_entry, fw_ddb_entry_dma,\r\nNULL, NULL, &ddb_state, NULL,\r\nNULL, NULL);\r\nif (ret == QLA_ERROR)\r\ngoto destroy_session;\r\nif ((ddb_state == DDB_DS_NO_CONNECTION_ACTIVE) ||\r\n(ddb_state == DDB_DS_SESSION_FAILED))\r\ngoto destroy_session;\r\nschedule_timeout_uninterruptible(HZ);\r\n} while ((time_after(wtime, jiffies)));\r\ndestroy_session:\r\nqla4xxx_clear_ddb_entry(ha, ddb_entry->fw_ddb_index);\r\nif (test_and_clear_bit(DDB_CONN_CLOSE_FAILURE, &ddb_entry->flags))\r\nclear_bit(ddb_entry->fw_ddb_index, ha->ddb_idx_map);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nqla4xxx_free_ddb(ha, ddb_entry);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\niscsi_session_teardown(cls_sess);\r\nif (fw_ddb_entry)\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\nfw_ddb_entry, fw_ddb_entry_dma);\r\n}\r\nstatic struct iscsi_cls_conn *\r\nqla4xxx_conn_create(struct iscsi_cls_session *cls_sess, uint32_t conn_idx)\r\n{\r\nstruct iscsi_cls_conn *cls_conn;\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb_entry;\r\nstruct scsi_qla_host *ha;\r\ncls_conn = iscsi_conn_setup(cls_sess, sizeof(struct qla_conn),\r\nconn_idx);\r\nif (!cls_conn) {\r\npr_info("%s: Can not create connection for conn_idx = %u\n",\r\n__func__, conn_idx);\r\nreturn NULL;\r\n}\r\nsess = cls_sess->dd_data;\r\nddb_entry = sess->dd_data;\r\nddb_entry->conn = cls_conn;\r\nha = ddb_entry->ha;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: conn_idx = %u\n", __func__,\r\nconn_idx));\r\nreturn cls_conn;\r\n}\r\nstatic int qla4xxx_conn_bind(struct iscsi_cls_session *cls_session,\r\nstruct iscsi_cls_conn *cls_conn,\r\nuint64_t transport_fd, int is_leading)\r\n{\r\nstruct iscsi_conn *conn;\r\nstruct qla_conn *qla_conn;\r\nstruct iscsi_endpoint *ep;\r\nstruct ddb_entry *ddb_entry;\r\nstruct scsi_qla_host *ha;\r\nstruct iscsi_session *sess;\r\nsess = cls_session->dd_data;\r\nddb_entry = sess->dd_data;\r\nha = ddb_entry->ha;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: sid = %d, cid = %d\n", __func__,\r\ncls_session->sid, cls_conn->cid));\r\nif (iscsi_conn_bind(cls_session, cls_conn, is_leading))\r\nreturn -EINVAL;\r\nep = iscsi_lookup_endpoint(transport_fd);\r\nconn = cls_conn->dd_data;\r\nqla_conn = conn->dd_data;\r\nqla_conn->qla_ep = ep->dd_data;\r\nreturn 0;\r\n}\r\nstatic int qla4xxx_conn_start(struct iscsi_cls_conn *cls_conn)\r\n{\r\nstruct iscsi_cls_session *cls_sess = iscsi_conn_to_session(cls_conn);\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb_entry;\r\nstruct scsi_qla_host *ha;\r\nstruct dev_db_entry *fw_ddb_entry = NULL;\r\ndma_addr_t fw_ddb_entry_dma;\r\nuint32_t mbx_sts = 0;\r\nint ret = 0;\r\nint status = QLA_SUCCESS;\r\nsess = cls_sess->dd_data;\r\nddb_entry = sess->dd_data;\r\nha = ddb_entry->ha;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: sid = %d, cid = %d\n", __func__,\r\ncls_sess->sid, cls_conn->cid));\r\nret = qla4xxx_match_fwdb_session(ha, cls_conn);\r\nif (ret == QLA_SUCCESS) {\r\nql4_printk(KERN_INFO, ha,\r\n"Session already exist in FW.\n");\r\nret = -EEXIST;\r\ngoto exit_conn_start;\r\n}\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (!fw_ddb_entry) {\r\nql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer\n", __func__);\r\nret = -ENOMEM;\r\ngoto exit_conn_start;\r\n}\r\nret = qla4xxx_set_param_ddbentry(ha, ddb_entry, cls_conn, &mbx_sts);\r\nif (ret) {\r\nif (mbx_sts)\r\nif (ddb_entry->fw_ddb_device_state ==\r\nDDB_DS_SESSION_ACTIVE) {\r\nddb_entry->unblock_sess(ddb_entry->sess);\r\ngoto exit_set_param;\r\n}\r\nql4_printk(KERN_ERR, ha, "%s: Failed set param for index[%d]\n",\r\n__func__, ddb_entry->fw_ddb_index);\r\ngoto exit_conn_start;\r\n}\r\nstatus = qla4xxx_conn_open(ha, ddb_entry->fw_ddb_index);\r\nif (status == QLA_ERROR) {\r\nql4_printk(KERN_ERR, ha, "%s: Login failed: %s\n", __func__,\r\nsess->targetname);\r\nret = -EINVAL;\r\ngoto exit_conn_start;\r\n}\r\nif (ddb_entry->fw_ddb_device_state == DDB_DS_NO_CONNECTION_ACTIVE)\r\nddb_entry->fw_ddb_device_state = DDB_DS_LOGIN_IN_PROCESS;\r\nDEBUG2(printk(KERN_INFO "%s: DDB state [%d]\n", __func__,\r\nddb_entry->fw_ddb_device_state));\r\nexit_set_param:\r\nret = 0;\r\nexit_conn_start:\r\nif (fw_ddb_entry)\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\nfw_ddb_entry, fw_ddb_entry_dma);\r\nreturn ret;\r\n}\r\nstatic void qla4xxx_conn_destroy(struct iscsi_cls_conn *cls_conn)\r\n{\r\nstruct iscsi_cls_session *cls_sess = iscsi_conn_to_session(cls_conn);\r\nstruct iscsi_session *sess;\r\nstruct scsi_qla_host *ha;\r\nstruct ddb_entry *ddb_entry;\r\nint options;\r\nsess = cls_sess->dd_data;\r\nddb_entry = sess->dd_data;\r\nha = ddb_entry->ha;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: cid = %d\n", __func__,\r\ncls_conn->cid));\r\noptions = LOGOUT_OPTION_CLOSE_SESSION;\r\nif (qla4xxx_session_logout_ddb(ha, ddb_entry, options) == QLA_ERROR)\r\nql4_printk(KERN_ERR, ha, "%s: Logout failed\n", __func__);\r\n}\r\nstatic void qla4xxx_task_work(struct work_struct *wdata)\r\n{\r\nstruct ql4_task_data *task_data;\r\nstruct scsi_qla_host *ha;\r\nstruct passthru_status *sts;\r\nstruct iscsi_task *task;\r\nstruct iscsi_hdr *hdr;\r\nuint8_t *data;\r\nuint32_t data_len;\r\nstruct iscsi_conn *conn;\r\nint hdr_len;\r\nitt_t itt;\r\ntask_data = container_of(wdata, struct ql4_task_data, task_work);\r\nha = task_data->ha;\r\ntask = task_data->task;\r\nsts = &task_data->sts;\r\nhdr_len = sizeof(struct iscsi_hdr);\r\nDEBUG3(printk(KERN_INFO "Status returned\n"));\r\nDEBUG3(qla4xxx_dump_buffer(sts, 64));\r\nDEBUG3(printk(KERN_INFO "Response buffer"));\r\nDEBUG3(qla4xxx_dump_buffer(task_data->resp_buffer, 64));\r\nconn = task->conn;\r\nswitch (sts->completionStatus) {\r\ncase PASSTHRU_STATUS_COMPLETE:\r\nhdr = (struct iscsi_hdr *)task_data->resp_buffer;\r\nitt = sts->handle;\r\nhdr->itt = itt;\r\ndata = task_data->resp_buffer + hdr_len;\r\ndata_len = task_data->resp_len - hdr_len;\r\niscsi_complete_pdu(conn, hdr, data, data_len);\r\nbreak;\r\ndefault:\r\nql4_printk(KERN_ERR, ha, "Passthru failed status = 0x%x\n",\r\nsts->completionStatus);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic int qla4xxx_alloc_pdu(struct iscsi_task *task, uint8_t opcode)\r\n{\r\nstruct ql4_task_data *task_data;\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb_entry;\r\nstruct scsi_qla_host *ha;\r\nint hdr_len;\r\nsess = task->conn->session;\r\nddb_entry = sess->dd_data;\r\nha = ddb_entry->ha;\r\ntask_data = task->dd_data;\r\nmemset(task_data, 0, sizeof(struct ql4_task_data));\r\nif (task->sc) {\r\nql4_printk(KERN_INFO, ha,\r\n"%s: SCSI Commands not implemented\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nhdr_len = sizeof(struct iscsi_hdr);\r\ntask_data->ha = ha;\r\ntask_data->task = task;\r\nif (task->data_count) {\r\ntask_data->data_dma = dma_map_single(&ha->pdev->dev, task->data,\r\ntask->data_count,\r\nPCI_DMA_TODEVICE);\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: MaxRecvLen %u, iscsi hrd %d\n",\r\n__func__, task->conn->max_recv_dlength, hdr_len));\r\ntask_data->resp_len = task->conn->max_recv_dlength + hdr_len;\r\ntask_data->resp_buffer = dma_alloc_coherent(&ha->pdev->dev,\r\ntask_data->resp_len,\r\n&task_data->resp_dma,\r\nGFP_ATOMIC);\r\nif (!task_data->resp_buffer)\r\ngoto exit_alloc_pdu;\r\ntask_data->req_len = task->data_count + hdr_len;\r\ntask_data->req_buffer = dma_alloc_coherent(&ha->pdev->dev,\r\ntask_data->req_len,\r\n&task_data->req_dma,\r\nGFP_ATOMIC);\r\nif (!task_data->req_buffer)\r\ngoto exit_alloc_pdu;\r\ntask->hdr = task_data->req_buffer;\r\nINIT_WORK(&task_data->task_work, qla4xxx_task_work);\r\nreturn 0;\r\nexit_alloc_pdu:\r\nif (task_data->resp_buffer)\r\ndma_free_coherent(&ha->pdev->dev, task_data->resp_len,\r\ntask_data->resp_buffer, task_data->resp_dma);\r\nif (task_data->req_buffer)\r\ndma_free_coherent(&ha->pdev->dev, task_data->req_len,\r\ntask_data->req_buffer, task_data->req_dma);\r\nreturn -ENOMEM;\r\n}\r\nstatic void qla4xxx_task_cleanup(struct iscsi_task *task)\r\n{\r\nstruct ql4_task_data *task_data;\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb_entry;\r\nstruct scsi_qla_host *ha;\r\nint hdr_len;\r\nhdr_len = sizeof(struct iscsi_hdr);\r\nsess = task->conn->session;\r\nddb_entry = sess->dd_data;\r\nha = ddb_entry->ha;\r\ntask_data = task->dd_data;\r\nif (task->data_count) {\r\ndma_unmap_single(&ha->pdev->dev, task_data->data_dma,\r\ntask->data_count, PCI_DMA_TODEVICE);\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: MaxRecvLen %u, iscsi hrd %d\n",\r\n__func__, task->conn->max_recv_dlength, hdr_len));\r\ndma_free_coherent(&ha->pdev->dev, task_data->resp_len,\r\ntask_data->resp_buffer, task_data->resp_dma);\r\ndma_free_coherent(&ha->pdev->dev, task_data->req_len,\r\ntask_data->req_buffer, task_data->req_dma);\r\nreturn;\r\n}\r\nstatic int qla4xxx_task_xmit(struct iscsi_task *task)\r\n{\r\nstruct scsi_cmnd *sc = task->sc;\r\nstruct iscsi_session *sess = task->conn->session;\r\nstruct ddb_entry *ddb_entry = sess->dd_data;\r\nstruct scsi_qla_host *ha = ddb_entry->ha;\r\nif (!sc)\r\nreturn qla4xxx_send_passthru0(task);\r\nql4_printk(KERN_INFO, ha, "%s: scsi cmd xmit not implemented\n",\r\n__func__);\r\nreturn -ENOSYS;\r\n}\r\nstatic int qla4xxx_copy_from_fwddb_param(struct iscsi_bus_flash_session *sess,\r\nstruct iscsi_bus_flash_conn *conn,\r\nstruct dev_db_entry *fw_ddb_entry)\r\n{\r\nunsigned long options = 0;\r\nint rc = 0;\r\noptions = le16_to_cpu(fw_ddb_entry->options);\r\nconn->is_fw_assigned_ipv6 = test_bit(OPT_IS_FW_ASSIGNED_IPV6, &options);\r\nif (test_bit(OPT_IPV6_DEVICE, &options)) {\r\nrc = iscsi_switch_str_param(&sess->portal_type,\r\nPORTAL_TYPE_IPV6);\r\nif (rc)\r\ngoto exit_copy;\r\n} else {\r\nrc = iscsi_switch_str_param(&sess->portal_type,\r\nPORTAL_TYPE_IPV4);\r\nif (rc)\r\ngoto exit_copy;\r\n}\r\nsess->auto_snd_tgt_disable = test_bit(OPT_AUTO_SENDTGTS_DISABLE,\r\n&options);\r\nsess->discovery_sess = test_bit(OPT_DISC_SESSION, &options);\r\nsess->entry_state = test_bit(OPT_ENTRY_STATE, &options);\r\noptions = le16_to_cpu(fw_ddb_entry->iscsi_options);\r\nconn->hdrdgst_en = test_bit(ISCSIOPT_HEADER_DIGEST_EN, &options);\r\nconn->datadgst_en = test_bit(ISCSIOPT_DATA_DIGEST_EN, &options);\r\nsess->imm_data_en = test_bit(ISCSIOPT_IMMEDIATE_DATA_EN, &options);\r\nsess->initial_r2t_en = test_bit(ISCSIOPT_INITIAL_R2T_EN, &options);\r\nsess->dataseq_inorder_en = test_bit(ISCSIOPT_DATA_SEQ_IN_ORDER,\r\n&options);\r\nsess->pdu_inorder_en = test_bit(ISCSIOPT_DATA_PDU_IN_ORDER, &options);\r\nsess->chap_auth_en = test_bit(ISCSIOPT_CHAP_AUTH_EN, &options);\r\nconn->snack_req_en = test_bit(ISCSIOPT_SNACK_REQ_EN, &options);\r\nsess->discovery_logout_en = test_bit(ISCSIOPT_DISCOVERY_LOGOUT_EN,\r\n&options);\r\nsess->bidi_chap_en = test_bit(ISCSIOPT_BIDI_CHAP_EN, &options);\r\nsess->discovery_auth_optional =\r\ntest_bit(ISCSIOPT_DISCOVERY_AUTH_OPTIONAL, &options);\r\nif (test_bit(ISCSIOPT_ERL1, &options))\r\nsess->erl |= BIT_1;\r\nif (test_bit(ISCSIOPT_ERL0, &options))\r\nsess->erl |= BIT_0;\r\noptions = le16_to_cpu(fw_ddb_entry->tcp_options);\r\nconn->tcp_timestamp_stat = test_bit(TCPOPT_TIMESTAMP_STAT, &options);\r\nconn->tcp_nagle_disable = test_bit(TCPOPT_NAGLE_DISABLE, &options);\r\nconn->tcp_wsf_disable = test_bit(TCPOPT_WSF_DISABLE, &options);\r\nif (test_bit(TCPOPT_TIMER_SCALE3, &options))\r\nconn->tcp_timer_scale |= BIT_3;\r\nif (test_bit(TCPOPT_TIMER_SCALE2, &options))\r\nconn->tcp_timer_scale |= BIT_2;\r\nif (test_bit(TCPOPT_TIMER_SCALE1, &options))\r\nconn->tcp_timer_scale |= BIT_1;\r\nconn->tcp_timer_scale >>= 1;\r\nconn->tcp_timestamp_en = test_bit(TCPOPT_TIMESTAMP_EN, &options);\r\noptions = le16_to_cpu(fw_ddb_entry->ip_options);\r\nconn->fragment_disable = test_bit(IPOPT_FRAGMENT_DISABLE, &options);\r\nconn->max_recv_dlength = BYTE_UNITS *\r\nle16_to_cpu(fw_ddb_entry->iscsi_max_rcv_data_seg_len);\r\nconn->max_xmit_dlength = BYTE_UNITS *\r\nle16_to_cpu(fw_ddb_entry->iscsi_max_snd_data_seg_len);\r\nsess->first_burst = BYTE_UNITS *\r\nle16_to_cpu(fw_ddb_entry->iscsi_first_burst_len);\r\nsess->max_burst = BYTE_UNITS *\r\nle16_to_cpu(fw_ddb_entry->iscsi_max_burst_len);\r\nsess->max_r2t = le16_to_cpu(fw_ddb_entry->iscsi_max_outsnd_r2t);\r\nsess->time2wait = le16_to_cpu(fw_ddb_entry->iscsi_def_time2wait);\r\nsess->time2retain = le16_to_cpu(fw_ddb_entry->iscsi_def_time2retain);\r\nsess->tpgt = le32_to_cpu(fw_ddb_entry->tgt_portal_grp);\r\nconn->max_segment_size = le16_to_cpu(fw_ddb_entry->mss);\r\nconn->tcp_xmit_wsf = fw_ddb_entry->tcp_xmt_wsf;\r\nconn->tcp_recv_wsf = fw_ddb_entry->tcp_rcv_wsf;\r\nconn->ipv6_flow_label = le16_to_cpu(fw_ddb_entry->ipv6_flow_lbl);\r\nconn->keepalive_timeout = le16_to_cpu(fw_ddb_entry->ka_timeout);\r\nconn->local_port = le16_to_cpu(fw_ddb_entry->lcl_port);\r\nconn->statsn = le32_to_cpu(fw_ddb_entry->stat_sn);\r\nconn->exp_statsn = le32_to_cpu(fw_ddb_entry->exp_stat_sn);\r\nsess->discovery_parent_idx = le16_to_cpu(fw_ddb_entry->ddb_link);\r\nsess->discovery_parent_type = le16_to_cpu(fw_ddb_entry->ddb_link);\r\nsess->chap_out_idx = le16_to_cpu(fw_ddb_entry->chap_tbl_idx);\r\nsess->tsid = le16_to_cpu(fw_ddb_entry->tsid);\r\nsess->default_taskmgmt_timeout =\r\nle16_to_cpu(fw_ddb_entry->def_timeout);\r\nconn->port = le16_to_cpu(fw_ddb_entry->port);\r\noptions = le16_to_cpu(fw_ddb_entry->options);\r\nconn->ipaddress = kzalloc(IPv6_ADDR_LEN, GFP_KERNEL);\r\nif (!conn->ipaddress) {\r\nrc = -ENOMEM;\r\ngoto exit_copy;\r\n}\r\nconn->redirect_ipaddr = kzalloc(IPv6_ADDR_LEN, GFP_KERNEL);\r\nif (!conn->redirect_ipaddr) {\r\nrc = -ENOMEM;\r\ngoto exit_copy;\r\n}\r\nmemcpy(conn->ipaddress, fw_ddb_entry->ip_addr, IPv6_ADDR_LEN);\r\nmemcpy(conn->redirect_ipaddr, fw_ddb_entry->tgt_addr, IPv6_ADDR_LEN);\r\nif (test_bit(OPT_IPV6_DEVICE, &options)) {\r\nconn->ipv6_traffic_class = fw_ddb_entry->ipv4_tos;\r\nconn->link_local_ipv6_addr = kmemdup(\r\nfw_ddb_entry->link_local_ipv6_addr,\r\nIPv6_ADDR_LEN, GFP_KERNEL);\r\nif (!conn->link_local_ipv6_addr) {\r\nrc = -ENOMEM;\r\ngoto exit_copy;\r\n}\r\n} else {\r\nconn->ipv4_tos = fw_ddb_entry->ipv4_tos;\r\n}\r\nif (fw_ddb_entry->iscsi_name[0]) {\r\nrc = iscsi_switch_str_param(&sess->targetname,\r\n(char *)fw_ddb_entry->iscsi_name);\r\nif (rc)\r\ngoto exit_copy;\r\n}\r\nif (fw_ddb_entry->iscsi_alias[0]) {\r\nrc = iscsi_switch_str_param(&sess->targetalias,\r\n(char *)fw_ddb_entry->iscsi_alias);\r\nif (rc)\r\ngoto exit_copy;\r\n}\r\nCOPY_ISID(sess->isid, fw_ddb_entry->isid);\r\nexit_copy:\r\nreturn rc;\r\n}\r\nstatic int qla4xxx_copy_to_fwddb_param(struct iscsi_bus_flash_session *sess,\r\nstruct iscsi_bus_flash_conn *conn,\r\nstruct dev_db_entry *fw_ddb_entry)\r\n{\r\nuint16_t options;\r\nint rc = 0;\r\noptions = le16_to_cpu(fw_ddb_entry->options);\r\nSET_BITVAL(conn->is_fw_assigned_ipv6, options, BIT_11);\r\nif (!strncmp(sess->portal_type, PORTAL_TYPE_IPV6, 4))\r\noptions |= BIT_8;\r\nelse\r\noptions &= ~BIT_8;\r\nSET_BITVAL(sess->auto_snd_tgt_disable, options, BIT_6);\r\nSET_BITVAL(sess->discovery_sess, options, BIT_4);\r\nSET_BITVAL(sess->entry_state, options, BIT_3);\r\nfw_ddb_entry->options = cpu_to_le16(options);\r\noptions = le16_to_cpu(fw_ddb_entry->iscsi_options);\r\nSET_BITVAL(conn->hdrdgst_en, options, BIT_13);\r\nSET_BITVAL(conn->datadgst_en, options, BIT_12);\r\nSET_BITVAL(sess->imm_data_en, options, BIT_11);\r\nSET_BITVAL(sess->initial_r2t_en, options, BIT_10);\r\nSET_BITVAL(sess->dataseq_inorder_en, options, BIT_9);\r\nSET_BITVAL(sess->pdu_inorder_en, options, BIT_8);\r\nSET_BITVAL(sess->chap_auth_en, options, BIT_7);\r\nSET_BITVAL(conn->snack_req_en, options, BIT_6);\r\nSET_BITVAL(sess->discovery_logout_en, options, BIT_5);\r\nSET_BITVAL(sess->bidi_chap_en, options, BIT_4);\r\nSET_BITVAL(sess->discovery_auth_optional, options, BIT_3);\r\nSET_BITVAL(sess->erl & BIT_1, options, BIT_1);\r\nSET_BITVAL(sess->erl & BIT_0, options, BIT_0);\r\nfw_ddb_entry->iscsi_options = cpu_to_le16(options);\r\noptions = le16_to_cpu(fw_ddb_entry->tcp_options);\r\nSET_BITVAL(conn->tcp_timestamp_stat, options, BIT_6);\r\nSET_BITVAL(conn->tcp_nagle_disable, options, BIT_5);\r\nSET_BITVAL(conn->tcp_wsf_disable, options, BIT_4);\r\nSET_BITVAL(conn->tcp_timer_scale & BIT_2, options, BIT_3);\r\nSET_BITVAL(conn->tcp_timer_scale & BIT_1, options, BIT_2);\r\nSET_BITVAL(conn->tcp_timer_scale & BIT_0, options, BIT_1);\r\nSET_BITVAL(conn->tcp_timestamp_en, options, BIT_0);\r\nfw_ddb_entry->tcp_options = cpu_to_le16(options);\r\noptions = le16_to_cpu(fw_ddb_entry->ip_options);\r\nSET_BITVAL(conn->fragment_disable, options, BIT_4);\r\nfw_ddb_entry->ip_options = cpu_to_le16(options);\r\nfw_ddb_entry->iscsi_max_outsnd_r2t = cpu_to_le16(sess->max_r2t);\r\nfw_ddb_entry->iscsi_max_rcv_data_seg_len =\r\ncpu_to_le16(conn->max_recv_dlength / BYTE_UNITS);\r\nfw_ddb_entry->iscsi_max_snd_data_seg_len =\r\ncpu_to_le16(conn->max_xmit_dlength / BYTE_UNITS);\r\nfw_ddb_entry->iscsi_first_burst_len =\r\ncpu_to_le16(sess->first_burst / BYTE_UNITS);\r\nfw_ddb_entry->iscsi_max_burst_len = cpu_to_le16(sess->max_burst /\r\nBYTE_UNITS);\r\nfw_ddb_entry->iscsi_def_time2wait = cpu_to_le16(sess->time2wait);\r\nfw_ddb_entry->iscsi_def_time2retain = cpu_to_le16(sess->time2retain);\r\nfw_ddb_entry->tgt_portal_grp = cpu_to_le16(sess->tpgt);\r\nfw_ddb_entry->mss = cpu_to_le16(conn->max_segment_size);\r\nfw_ddb_entry->tcp_xmt_wsf = (uint8_t) cpu_to_le32(conn->tcp_xmit_wsf);\r\nfw_ddb_entry->tcp_rcv_wsf = (uint8_t) cpu_to_le32(conn->tcp_recv_wsf);\r\nfw_ddb_entry->ipv6_flow_lbl = cpu_to_le16(conn->ipv6_flow_label);\r\nfw_ddb_entry->ka_timeout = cpu_to_le16(conn->keepalive_timeout);\r\nfw_ddb_entry->lcl_port = cpu_to_le16(conn->local_port);\r\nfw_ddb_entry->stat_sn = cpu_to_le32(conn->statsn);\r\nfw_ddb_entry->exp_stat_sn = cpu_to_le32(conn->exp_statsn);\r\nfw_ddb_entry->ddb_link = cpu_to_le16(sess->discovery_parent_idx);\r\nfw_ddb_entry->chap_tbl_idx = cpu_to_le16(sess->chap_out_idx);\r\nfw_ddb_entry->tsid = cpu_to_le16(sess->tsid);\r\nfw_ddb_entry->port = cpu_to_le16(conn->port);\r\nfw_ddb_entry->def_timeout =\r\ncpu_to_le16(sess->default_taskmgmt_timeout);\r\nif (!strncmp(sess->portal_type, PORTAL_TYPE_IPV6, 4))\r\nfw_ddb_entry->ipv4_tos = conn->ipv6_traffic_class;\r\nelse\r\nfw_ddb_entry->ipv4_tos = conn->ipv4_tos;\r\nif (conn->ipaddress)\r\nmemcpy(fw_ddb_entry->ip_addr, conn->ipaddress,\r\nsizeof(fw_ddb_entry->ip_addr));\r\nif (conn->redirect_ipaddr)\r\nmemcpy(fw_ddb_entry->tgt_addr, conn->redirect_ipaddr,\r\nsizeof(fw_ddb_entry->tgt_addr));\r\nif (conn->link_local_ipv6_addr)\r\nmemcpy(fw_ddb_entry->link_local_ipv6_addr,\r\nconn->link_local_ipv6_addr,\r\nsizeof(fw_ddb_entry->link_local_ipv6_addr));\r\nif (sess->targetname)\r\nmemcpy(fw_ddb_entry->iscsi_name, sess->targetname,\r\nsizeof(fw_ddb_entry->iscsi_name));\r\nif (sess->targetalias)\r\nmemcpy(fw_ddb_entry->iscsi_alias, sess->targetalias,\r\nsizeof(fw_ddb_entry->iscsi_alias));\r\nCOPY_ISID(fw_ddb_entry->isid, sess->isid);\r\nreturn rc;\r\n}\r\nstatic void qla4xxx_copy_to_sess_conn_params(struct iscsi_conn *conn,\r\nstruct iscsi_session *sess,\r\nstruct dev_db_entry *fw_ddb_entry)\r\n{\r\nunsigned long options = 0;\r\nuint16_t ddb_link;\r\nuint16_t disc_parent;\r\nchar ip_addr[DDB_IPADDR_LEN];\r\noptions = le16_to_cpu(fw_ddb_entry->options);\r\nconn->is_fw_assigned_ipv6 = test_bit(OPT_IS_FW_ASSIGNED_IPV6, &options);\r\nsess->auto_snd_tgt_disable = test_bit(OPT_AUTO_SENDTGTS_DISABLE,\r\n&options);\r\nsess->discovery_sess = test_bit(OPT_DISC_SESSION, &options);\r\noptions = le16_to_cpu(fw_ddb_entry->iscsi_options);\r\nconn->hdrdgst_en = test_bit(ISCSIOPT_HEADER_DIGEST_EN, &options);\r\nconn->datadgst_en = test_bit(ISCSIOPT_DATA_DIGEST_EN, &options);\r\nsess->imm_data_en = test_bit(ISCSIOPT_IMMEDIATE_DATA_EN, &options);\r\nsess->initial_r2t_en = test_bit(ISCSIOPT_INITIAL_R2T_EN, &options);\r\nsess->dataseq_inorder_en = test_bit(ISCSIOPT_DATA_SEQ_IN_ORDER,\r\n&options);\r\nsess->pdu_inorder_en = test_bit(ISCSIOPT_DATA_PDU_IN_ORDER, &options);\r\nsess->chap_auth_en = test_bit(ISCSIOPT_CHAP_AUTH_EN, &options);\r\nsess->discovery_logout_en = test_bit(ISCSIOPT_DISCOVERY_LOGOUT_EN,\r\n&options);\r\nsess->bidi_chap_en = test_bit(ISCSIOPT_BIDI_CHAP_EN, &options);\r\nsess->discovery_auth_optional =\r\ntest_bit(ISCSIOPT_DISCOVERY_AUTH_OPTIONAL, &options);\r\nif (test_bit(ISCSIOPT_ERL1, &options))\r\nsess->erl |= BIT_1;\r\nif (test_bit(ISCSIOPT_ERL0, &options))\r\nsess->erl |= BIT_0;\r\noptions = le16_to_cpu(fw_ddb_entry->tcp_options);\r\nconn->tcp_timestamp_stat = test_bit(TCPOPT_TIMESTAMP_STAT, &options);\r\nconn->tcp_nagle_disable = test_bit(TCPOPT_NAGLE_DISABLE, &options);\r\nconn->tcp_wsf_disable = test_bit(TCPOPT_WSF_DISABLE, &options);\r\nif (test_bit(TCPOPT_TIMER_SCALE3, &options))\r\nconn->tcp_timer_scale |= BIT_3;\r\nif (test_bit(TCPOPT_TIMER_SCALE2, &options))\r\nconn->tcp_timer_scale |= BIT_2;\r\nif (test_bit(TCPOPT_TIMER_SCALE1, &options))\r\nconn->tcp_timer_scale |= BIT_1;\r\nconn->tcp_timer_scale >>= 1;\r\nconn->tcp_timestamp_en = test_bit(TCPOPT_TIMESTAMP_EN, &options);\r\noptions = le16_to_cpu(fw_ddb_entry->ip_options);\r\nconn->fragment_disable = test_bit(IPOPT_FRAGMENT_DISABLE, &options);\r\nconn->max_recv_dlength = BYTE_UNITS *\r\nle16_to_cpu(fw_ddb_entry->iscsi_max_rcv_data_seg_len);\r\nconn->max_xmit_dlength = BYTE_UNITS *\r\nle16_to_cpu(fw_ddb_entry->iscsi_max_snd_data_seg_len);\r\nsess->max_r2t = le16_to_cpu(fw_ddb_entry->iscsi_max_outsnd_r2t);\r\nsess->first_burst = BYTE_UNITS *\r\nle16_to_cpu(fw_ddb_entry->iscsi_first_burst_len);\r\nsess->max_burst = BYTE_UNITS *\r\nle16_to_cpu(fw_ddb_entry->iscsi_max_burst_len);\r\nsess->time2wait = le16_to_cpu(fw_ddb_entry->iscsi_def_time2wait);\r\nsess->time2retain = le16_to_cpu(fw_ddb_entry->iscsi_def_time2retain);\r\nsess->tpgt = le32_to_cpu(fw_ddb_entry->tgt_portal_grp);\r\nconn->max_segment_size = le16_to_cpu(fw_ddb_entry->mss);\r\nconn->tcp_xmit_wsf = fw_ddb_entry->tcp_xmt_wsf;\r\nconn->tcp_recv_wsf = fw_ddb_entry->tcp_rcv_wsf;\r\nconn->ipv4_tos = fw_ddb_entry->ipv4_tos;\r\nconn->keepalive_tmo = le16_to_cpu(fw_ddb_entry->ka_timeout);\r\nconn->local_port = le16_to_cpu(fw_ddb_entry->lcl_port);\r\nconn->statsn = le32_to_cpu(fw_ddb_entry->stat_sn);\r\nconn->exp_statsn = le32_to_cpu(fw_ddb_entry->exp_stat_sn);\r\nsess->tsid = le16_to_cpu(fw_ddb_entry->tsid);\r\nCOPY_ISID(sess->isid, fw_ddb_entry->isid);\r\nddb_link = le16_to_cpu(fw_ddb_entry->ddb_link);\r\nif (ddb_link == DDB_ISNS)\r\ndisc_parent = ISCSI_DISC_PARENT_ISNS;\r\nelse if (ddb_link == DDB_NO_LINK)\r\ndisc_parent = ISCSI_DISC_PARENT_UNKNOWN;\r\nelse if (ddb_link < MAX_DDB_ENTRIES)\r\ndisc_parent = ISCSI_DISC_PARENT_SENDTGT;\r\nelse\r\ndisc_parent = ISCSI_DISC_PARENT_UNKNOWN;\r\niscsi_set_param(conn->cls_conn, ISCSI_PARAM_DISCOVERY_PARENT_TYPE,\r\niscsi_get_discovery_parent_name(disc_parent), 0);\r\niscsi_set_param(conn->cls_conn, ISCSI_PARAM_TARGET_ALIAS,\r\n(char *)fw_ddb_entry->iscsi_alias, 0);\r\noptions = le16_to_cpu(fw_ddb_entry->options);\r\nif (options & DDB_OPT_IPV6_DEVICE) {\r\nmemset(ip_addr, 0, sizeof(ip_addr));\r\nsprintf(ip_addr, "%pI6", fw_ddb_entry->link_local_ipv6_addr);\r\niscsi_set_param(conn->cls_conn, ISCSI_PARAM_LOCAL_IPADDR,\r\n(char *)ip_addr, 0);\r\n}\r\n}\r\nstatic void qla4xxx_copy_fwddb_param(struct scsi_qla_host *ha,\r\nstruct dev_db_entry *fw_ddb_entry,\r\nstruct iscsi_cls_session *cls_sess,\r\nstruct iscsi_cls_conn *cls_conn)\r\n{\r\nint buflen = 0;\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb_entry;\r\nstruct ql4_chap_table chap_tbl;\r\nstruct iscsi_conn *conn;\r\nchar ip_addr[DDB_IPADDR_LEN];\r\nuint16_t options = 0;\r\nsess = cls_sess->dd_data;\r\nddb_entry = sess->dd_data;\r\nconn = cls_conn->dd_data;\r\nmemset(&chap_tbl, 0, sizeof(chap_tbl));\r\nddb_entry->chap_tbl_idx = le16_to_cpu(fw_ddb_entry->chap_tbl_idx);\r\nqla4xxx_copy_to_sess_conn_params(conn, sess, fw_ddb_entry);\r\nsess->def_taskmgmt_tmo = le16_to_cpu(fw_ddb_entry->def_timeout);\r\nconn->persistent_port = le16_to_cpu(fw_ddb_entry->port);\r\nmemset(ip_addr, 0, sizeof(ip_addr));\r\noptions = le16_to_cpu(fw_ddb_entry->options);\r\nif (options & DDB_OPT_IPV6_DEVICE) {\r\niscsi_set_param(cls_conn, ISCSI_PARAM_PORTAL_TYPE, "ipv6", 4);\r\nmemset(ip_addr, 0, sizeof(ip_addr));\r\nsprintf(ip_addr, "%pI6", fw_ddb_entry->ip_addr);\r\n} else {\r\niscsi_set_param(cls_conn, ISCSI_PARAM_PORTAL_TYPE, "ipv4", 4);\r\nsprintf(ip_addr, "%pI4", fw_ddb_entry->ip_addr);\r\n}\r\niscsi_set_param(cls_conn, ISCSI_PARAM_PERSISTENT_ADDRESS,\r\n(char *)ip_addr, buflen);\r\niscsi_set_param(cls_conn, ISCSI_PARAM_TARGET_NAME,\r\n(char *)fw_ddb_entry->iscsi_name, buflen);\r\niscsi_set_param(cls_conn, ISCSI_PARAM_INITIATOR_NAME,\r\n(char *)ha->name_string, buflen);\r\nif (ddb_entry->chap_tbl_idx != INVALID_ENTRY) {\r\nif (!qla4xxx_get_uni_chap_at_index(ha, chap_tbl.name,\r\nchap_tbl.secret,\r\nddb_entry->chap_tbl_idx)) {\r\niscsi_set_param(cls_conn, ISCSI_PARAM_USERNAME,\r\n(char *)chap_tbl.name,\r\nstrlen((char *)chap_tbl.name));\r\niscsi_set_param(cls_conn, ISCSI_PARAM_PASSWORD,\r\n(char *)chap_tbl.secret,\r\nchap_tbl.secret_len);\r\n}\r\n}\r\n}\r\nvoid qla4xxx_update_session_conn_fwddb_param(struct scsi_qla_host *ha,\r\nstruct ddb_entry *ddb_entry)\r\n{\r\nstruct iscsi_cls_session *cls_sess;\r\nstruct iscsi_cls_conn *cls_conn;\r\nuint32_t ddb_state;\r\ndma_addr_t fw_ddb_entry_dma;\r\nstruct dev_db_entry *fw_ddb_entry;\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (!fw_ddb_entry) {\r\nql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer\n", __func__);\r\ngoto exit_session_conn_fwddb_param;\r\n}\r\nif (qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index, fw_ddb_entry,\r\nfw_ddb_entry_dma, NULL, NULL, &ddb_state,\r\nNULL, NULL, NULL) == QLA_ERROR) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "scsi%ld: %s: failed "\r\n"get_ddb_entry for fw_ddb_index %d\n",\r\nha->host_no, __func__,\r\nddb_entry->fw_ddb_index));\r\ngoto exit_session_conn_fwddb_param;\r\n}\r\ncls_sess = ddb_entry->sess;\r\ncls_conn = ddb_entry->conn;\r\nqla4xxx_copy_fwddb_param(ha, fw_ddb_entry, cls_sess, cls_conn);\r\nexit_session_conn_fwddb_param:\r\nif (fw_ddb_entry)\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\nfw_ddb_entry, fw_ddb_entry_dma);\r\n}\r\nvoid qla4xxx_update_session_conn_param(struct scsi_qla_host *ha,\r\nstruct ddb_entry *ddb_entry)\r\n{\r\nstruct iscsi_cls_session *cls_sess;\r\nstruct iscsi_cls_conn *cls_conn;\r\nstruct iscsi_session *sess;\r\nstruct iscsi_conn *conn;\r\nuint32_t ddb_state;\r\ndma_addr_t fw_ddb_entry_dma;\r\nstruct dev_db_entry *fw_ddb_entry;\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (!fw_ddb_entry) {\r\nql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer\n", __func__);\r\ngoto exit_session_conn_param;\r\n}\r\nif (qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index, fw_ddb_entry,\r\nfw_ddb_entry_dma, NULL, NULL, &ddb_state,\r\nNULL, NULL, NULL) == QLA_ERROR) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "scsi%ld: %s: failed "\r\n"get_ddb_entry for fw_ddb_index %d\n",\r\nha->host_no, __func__,\r\nddb_entry->fw_ddb_index));\r\ngoto exit_session_conn_param;\r\n}\r\ncls_sess = ddb_entry->sess;\r\nsess = cls_sess->dd_data;\r\ncls_conn = ddb_entry->conn;\r\nconn = cls_conn->dd_data;\r\nddb_entry->default_relogin_timeout =\r\n(le16_to_cpu(fw_ddb_entry->def_timeout) > LOGIN_TOV) &&\r\n(le16_to_cpu(fw_ddb_entry->def_timeout) < LOGIN_TOV * 10) ?\r\nle16_to_cpu(fw_ddb_entry->def_timeout) : LOGIN_TOV;\r\nddb_entry->default_time2wait =\r\nle16_to_cpu(fw_ddb_entry->iscsi_def_time2wait);\r\nddb_entry->chap_tbl_idx = le16_to_cpu(fw_ddb_entry->chap_tbl_idx);\r\nqla4xxx_copy_to_sess_conn_params(conn, sess, fw_ddb_entry);\r\nmemcpy(sess->initiatorname, ha->name_string,\r\nmin(sizeof(ha->name_string), sizeof(sess->initiatorname)));\r\nexit_session_conn_param:\r\nif (fw_ddb_entry)\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\nfw_ddb_entry, fw_ddb_entry_dma);\r\n}\r\nstatic void qla4xxx_start_timer(struct scsi_qla_host *ha, void *func,\r\nunsigned long interval)\r\n{\r\nDEBUG(printk("scsi: %s: Starting timer thread for adapter %d\n",\r\n__func__, ha->host->host_no));\r\ninit_timer(&ha->timer);\r\nha->timer.expires = jiffies + interval * HZ;\r\nha->timer.data = (unsigned long)ha;\r\nha->timer.function = (void (*)(unsigned long))func;\r\nadd_timer(&ha->timer);\r\nha->timer_active = 1;\r\n}\r\nstatic void qla4xxx_stop_timer(struct scsi_qla_host *ha)\r\n{\r\ndel_timer_sync(&ha->timer);\r\nha->timer_active = 0;\r\n}\r\nvoid qla4xxx_mark_device_missing(struct iscsi_cls_session *cls_session)\r\n{\r\niscsi_block_session(cls_session);\r\n}\r\nvoid qla4xxx_mark_all_devices_missing(struct scsi_qla_host *ha)\r\n{\r\niscsi_host_for_each_session(ha->host, qla4xxx_mark_device_missing);\r\n}\r\nstatic struct srb* qla4xxx_get_new_srb(struct scsi_qla_host *ha,\r\nstruct ddb_entry *ddb_entry,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct srb *srb;\r\nsrb = mempool_alloc(ha->srb_mempool, GFP_ATOMIC);\r\nif (!srb)\r\nreturn srb;\r\nkref_init(&srb->srb_ref);\r\nsrb->ha = ha;\r\nsrb->ddb = ddb_entry;\r\nsrb->cmd = cmd;\r\nsrb->flags = 0;\r\nCMD_SP(cmd) = (void *)srb;\r\nreturn srb;\r\n}\r\nstatic void qla4xxx_srb_free_dma(struct scsi_qla_host *ha, struct srb *srb)\r\n{\r\nstruct scsi_cmnd *cmd = srb->cmd;\r\nif (srb->flags & SRB_DMA_VALID) {\r\nscsi_dma_unmap(cmd);\r\nsrb->flags &= ~SRB_DMA_VALID;\r\n}\r\nCMD_SP(cmd) = NULL;\r\n}\r\nvoid qla4xxx_srb_compl(struct kref *ref)\r\n{\r\nstruct srb *srb = container_of(ref, struct srb, srb_ref);\r\nstruct scsi_cmnd *cmd = srb->cmd;\r\nstruct scsi_qla_host *ha = srb->ha;\r\nqla4xxx_srb_free_dma(ha, srb);\r\nmempool_free(srb, ha->srb_mempool);\r\ncmd->scsi_done(cmd);\r\n}\r\nstatic int qla4xxx_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct ddb_entry *ddb_entry = cmd->device->hostdata;\r\nstruct iscsi_cls_session *sess = ddb_entry->sess;\r\nstruct srb *srb;\r\nint rval;\r\nif (test_bit(AF_EEH_BUSY, &ha->flags)) {\r\nif (test_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags))\r\ncmd->result = DID_NO_CONNECT << 16;\r\nelse\r\ncmd->result = DID_REQUEUE << 16;\r\ngoto qc_fail_command;\r\n}\r\nif (!sess) {\r\ncmd->result = DID_IMM_RETRY << 16;\r\ngoto qc_fail_command;\r\n}\r\nrval = iscsi_session_chkready(sess);\r\nif (rval) {\r\ncmd->result = rval;\r\ngoto qc_fail_command;\r\n}\r\nif (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_ACTIVE, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_HA, &ha->dpc_flags) ||\r\ntest_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags) ||\r\ntest_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags) ||\r\n!test_bit(AF_ONLINE, &ha->flags) ||\r\n!test_bit(AF_LINK_UP, &ha->flags) ||\r\ntest_bit(AF_LOOPBACK, &ha->flags) ||\r\ntest_bit(DPC_POST_IDC_ACK, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESTORE_ACB, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags))\r\ngoto qc_host_busy;\r\nsrb = qla4xxx_get_new_srb(ha, ddb_entry, cmd);\r\nif (!srb)\r\ngoto qc_host_busy;\r\nrval = qla4xxx_send_command_to_isp(ha, srb);\r\nif (rval != QLA_SUCCESS)\r\ngoto qc_host_busy_free_sp;\r\nreturn 0;\r\nqc_host_busy_free_sp:\r\nqla4xxx_srb_free_dma(ha, srb);\r\nmempool_free(srb, ha->srb_mempool);\r\nqc_host_busy:\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nqc_fail_command:\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\nstatic void qla4xxx_mem_free(struct scsi_qla_host *ha)\r\n{\r\nif (ha->queues)\r\ndma_free_coherent(&ha->pdev->dev, ha->queues_len, ha->queues,\r\nha->queues_dma);\r\nif (ha->fw_dump)\r\nvfree(ha->fw_dump);\r\nha->queues_len = 0;\r\nha->queues = NULL;\r\nha->queues_dma = 0;\r\nha->request_ring = NULL;\r\nha->request_dma = 0;\r\nha->response_ring = NULL;\r\nha->response_dma = 0;\r\nha->shadow_regs = NULL;\r\nha->shadow_regs_dma = 0;\r\nha->fw_dump = NULL;\r\nha->fw_dump_size = 0;\r\nif (ha->srb_mempool)\r\nmempool_destroy(ha->srb_mempool);\r\nha->srb_mempool = NULL;\r\nif (ha->chap_dma_pool)\r\ndma_pool_destroy(ha->chap_dma_pool);\r\nif (ha->chap_list)\r\nvfree(ha->chap_list);\r\nha->chap_list = NULL;\r\nif (ha->fw_ddb_dma_pool)\r\ndma_pool_destroy(ha->fw_ddb_dma_pool);\r\nif (is_qla8022(ha)) {\r\nif (ha->nx_pcibase)\r\niounmap(\r\n(struct device_reg_82xx __iomem *)ha->nx_pcibase);\r\n} else if (is_qla8032(ha) || is_qla8042(ha)) {\r\nif (ha->nx_pcibase)\r\niounmap(\r\n(struct device_reg_83xx __iomem *)ha->nx_pcibase);\r\n} else if (ha->reg) {\r\niounmap(ha->reg);\r\n}\r\nif (ha->reset_tmplt.buff)\r\nvfree(ha->reset_tmplt.buff);\r\npci_release_regions(ha->pdev);\r\n}\r\nstatic int qla4xxx_mem_alloc(struct scsi_qla_host *ha)\r\n{\r\nunsigned long align;\r\nha->queues_len = ((REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +\r\n(RESPONSE_QUEUE_DEPTH * QUEUE_SIZE) +\r\nsizeof(struct shadow_regs) +\r\nMEM_ALIGN_VALUE +\r\n(PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);\r\nha->queues = dma_alloc_coherent(&ha->pdev->dev, ha->queues_len,\r\n&ha->queues_dma, GFP_KERNEL);\r\nif (ha->queues == NULL) {\r\nql4_printk(KERN_WARNING, ha,\r\n"Memory Allocation failed - queues.\n");\r\ngoto mem_alloc_error_exit;\r\n}\r\nmemset(ha->queues, 0, ha->queues_len);\r\nalign = 0;\r\nif ((unsigned long)ha->queues_dma & (MEM_ALIGN_VALUE - 1))\r\nalign = MEM_ALIGN_VALUE - ((unsigned long)ha->queues_dma &\r\n(MEM_ALIGN_VALUE - 1));\r\nha->request_dma = ha->queues_dma + align;\r\nha->request_ring = (struct queue_entry *) (ha->queues + align);\r\nha->response_dma = ha->queues_dma + align +\r\n(REQUEST_QUEUE_DEPTH * QUEUE_SIZE);\r\nha->response_ring = (struct queue_entry *) (ha->queues + align +\r\n(REQUEST_QUEUE_DEPTH *\r\nQUEUE_SIZE));\r\nha->shadow_regs_dma = ha->queues_dma + align +\r\n(REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +\r\n(RESPONSE_QUEUE_DEPTH * QUEUE_SIZE);\r\nha->shadow_regs = (struct shadow_regs *) (ha->queues + align +\r\n(REQUEST_QUEUE_DEPTH *\r\nQUEUE_SIZE) +\r\n(RESPONSE_QUEUE_DEPTH *\r\nQUEUE_SIZE));\r\nha->srb_mempool = mempool_create(SRB_MIN_REQ, mempool_alloc_slab,\r\nmempool_free_slab, srb_cachep);\r\nif (ha->srb_mempool == NULL) {\r\nql4_printk(KERN_WARNING, ha,\r\n"Memory Allocation failed - SRB Pool.\n");\r\ngoto mem_alloc_error_exit;\r\n}\r\nha->chap_dma_pool = dma_pool_create("ql4_chap", &ha->pdev->dev,\r\nCHAP_DMA_BLOCK_SIZE, 8, 0);\r\nif (ha->chap_dma_pool == NULL) {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s: chap_dma_pool allocation failed..\n", __func__);\r\ngoto mem_alloc_error_exit;\r\n}\r\nha->fw_ddb_dma_pool = dma_pool_create("ql4_fw_ddb", &ha->pdev->dev,\r\nDDB_DMA_BLOCK_SIZE, 8, 0);\r\nif (ha->fw_ddb_dma_pool == NULL) {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s: fw_ddb_dma_pool allocation failed..\n",\r\n__func__);\r\ngoto mem_alloc_error_exit;\r\n}\r\nreturn QLA_SUCCESS;\r\nmem_alloc_error_exit:\r\nqla4xxx_mem_free(ha);\r\nreturn QLA_ERROR;\r\n}\r\nstatic int qla4_8xxx_check_temp(struct scsi_qla_host *ha)\r\n{\r\nuint32_t temp, temp_state, temp_val;\r\nint status = QLA_SUCCESS;\r\ntemp = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_TEMP_STATE);\r\ntemp_state = qla82xx_get_temp_state(temp);\r\ntemp_val = qla82xx_get_temp_val(temp);\r\nif (temp_state == QLA82XX_TEMP_PANIC) {\r\nql4_printk(KERN_WARNING, ha, "Device temperature %d degrees C"\r\n" exceeds maximum allowed. Hardware has been shut"\r\n" down.\n", temp_val);\r\nstatus = QLA_ERROR;\r\n} else if (temp_state == QLA82XX_TEMP_WARN) {\r\nif (ha->temperature == QLA82XX_TEMP_NORMAL)\r\nql4_printk(KERN_WARNING, ha, "Device temperature %d"\r\n" degrees C exceeds operating range."\r\n" Immediate action needed.\n", temp_val);\r\n} else {\r\nif (ha->temperature == QLA82XX_TEMP_WARN)\r\nql4_printk(KERN_INFO, ha, "Device temperature is"\r\n" now %d degrees C in normal range.\n",\r\ntemp_val);\r\n}\r\nha->temperature = temp_state;\r\nreturn status;\r\n}\r\nstatic int qla4_8xxx_check_fw_alive(struct scsi_qla_host *ha)\r\n{\r\nuint32_t fw_heartbeat_counter;\r\nint status = QLA_SUCCESS;\r\nfw_heartbeat_counter = qla4_8xxx_rd_direct(ha,\r\nQLA8XXX_PEG_ALIVE_COUNTER);\r\nif (fw_heartbeat_counter == 0xffffffff) {\r\nDEBUG2(printk(KERN_WARNING "scsi%ld: %s: Device in frozen "\r\n"state, QLA82XX_PEG_ALIVE_COUNTER is 0xffffffff\n",\r\nha->host_no, __func__));\r\nreturn status;\r\n}\r\nif (ha->fw_heartbeat_counter == fw_heartbeat_counter) {\r\nha->seconds_since_last_heartbeat++;\r\nif (ha->seconds_since_last_heartbeat == 2) {\r\nha->seconds_since_last_heartbeat = 0;\r\nqla4_8xxx_dump_peg_reg(ha);\r\nstatus = QLA_ERROR;\r\n}\r\n} else\r\nha->seconds_since_last_heartbeat = 0;\r\nha->fw_heartbeat_counter = fw_heartbeat_counter;\r\nreturn status;\r\n}\r\nstatic void qla4_8xxx_process_fw_error(struct scsi_qla_host *ha)\r\n{\r\nuint32_t halt_status;\r\nint halt_status_unrecoverable = 0;\r\nhalt_status = qla4_8xxx_rd_direct(ha, QLA8XXX_PEG_HALT_STATUS1);\r\nif (is_qla8022(ha)) {\r\nql4_printk(KERN_INFO, ha, "%s: disabling pause transmit on port 0 & 1.\n",\r\n__func__);\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x98,\r\nCRB_NIU_XG_PAUSE_CTL_P0 |\r\nCRB_NIU_XG_PAUSE_CTL_P1);\r\nif (QLA82XX_FWERROR_CODE(halt_status) == 0x67)\r\nql4_printk(KERN_ERR, ha, "%s: Firmware aborted with error code 0x00006700. Device is being reset\n",\r\n__func__);\r\nif (halt_status & HALT_STATUS_UNRECOVERABLE)\r\nhalt_status_unrecoverable = 1;\r\n} else if (is_qla8032(ha) || is_qla8042(ha)) {\r\nif (halt_status & QLA83XX_HALT_STATUS_FW_RESET)\r\nql4_printk(KERN_ERR, ha, "%s: Firmware error detected device is being reset\n",\r\n__func__);\r\nelse if (halt_status & QLA83XX_HALT_STATUS_UNRECOVERABLE)\r\nhalt_status_unrecoverable = 1;\r\n}\r\nif (halt_status_unrecoverable) {\r\nset_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags);\r\n} else {\r\nql4_printk(KERN_INFO, ha, "%s: detect abort needed!\n",\r\n__func__);\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\n}\r\nqla4xxx_mailbox_premature_completion(ha);\r\nqla4xxx_wake_dpc(ha);\r\n}\r\nvoid qla4_8xxx_watchdog(struct scsi_qla_host *ha)\r\n{\r\nuint32_t dev_state;\r\nuint32_t idc_ctrl;\r\nif (is_qla8032(ha) &&\r\n(qla4_83xx_is_detached(ha) == QLA_SUCCESS))\r\nWARN_ONCE(1, "%s: iSCSI function %d marked invisible\n",\r\n__func__, ha->func_num);\r\nif (!(test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_HA, &ha->dpc_flags) ||\r\ntest_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags))) {\r\ndev_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE);\r\nif (qla4_8xxx_check_temp(ha)) {\r\nif (is_qla8022(ha)) {\r\nql4_printk(KERN_INFO, ha, "disabling pause transmit on port 0 & 1.\n");\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x98,\r\nCRB_NIU_XG_PAUSE_CTL_P0 |\r\nCRB_NIU_XG_PAUSE_CTL_P1);\r\n}\r\nset_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags);\r\nqla4xxx_wake_dpc(ha);\r\n} else if (dev_state == QLA8XXX_DEV_NEED_RESET &&\r\n!test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\r\nql4_printk(KERN_INFO, ha, "%s: HW State: NEED RESET!\n",\r\n__func__);\r\nif (is_qla8032(ha) || is_qla8042(ha)) {\r\nidc_ctrl = qla4_83xx_rd_reg(ha,\r\nQLA83XX_IDC_DRV_CTRL);\r\nif (!(idc_ctrl & GRACEFUL_RESET_BIT1)) {\r\nql4_printk(KERN_INFO, ha, "%s: Graceful reset bit is not set\n",\r\n__func__);\r\nqla4xxx_mailbox_premature_completion(\r\nha);\r\n}\r\n}\r\nif ((is_qla8032(ha) || is_qla8042(ha)) ||\r\n(is_qla8022(ha) && !ql4xdontresethba)) {\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nqla4xxx_wake_dpc(ha);\r\n}\r\n} else if (dev_state == QLA8XXX_DEV_NEED_QUIESCENT &&\r\n!test_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags)) {\r\nql4_printk(KERN_INFO, ha, "%s: HW State: NEED QUIES!\n",\r\n__func__);\r\nset_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags);\r\nqla4xxx_wake_dpc(ha);\r\n} else {\r\nif (qla4_8xxx_check_fw_alive(ha))\r\nqla4_8xxx_process_fw_error(ha);\r\n}\r\n}\r\n}\r\nstatic void qla4xxx_check_relogin_flash_ddb(struct iscsi_cls_session *cls_sess)\r\n{\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb_entry;\r\nstruct scsi_qla_host *ha;\r\nsess = cls_sess->dd_data;\r\nddb_entry = sess->dd_data;\r\nha = ddb_entry->ha;\r\nif (!(ddb_entry->ddb_type == FLASH_DDB))\r\nreturn;\r\nif (adapter_up(ha) && !test_bit(DF_RELOGIN, &ddb_entry->flags) &&\r\n!iscsi_is_session_online(cls_sess)) {\r\nif (atomic_read(&ddb_entry->retry_relogin_timer) !=\r\nINVALID_ENTRY) {\r\nif (atomic_read(&ddb_entry->retry_relogin_timer) ==\r\n0) {\r\natomic_set(&ddb_entry->retry_relogin_timer,\r\nINVALID_ENTRY);\r\nset_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags);\r\nset_bit(DF_RELOGIN, &ddb_entry->flags);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: index [%d] login device\n",\r\n__func__, ddb_entry->fw_ddb_index));\r\n} else\r\natomic_dec(&ddb_entry->retry_relogin_timer);\r\n}\r\n}\r\nif (atomic_read(&ddb_entry->relogin_timer) &&\r\n(atomic_dec_and_test(&ddb_entry->relogin_timer) != 0)) {\r\nif (!iscsi_is_session_online(cls_sess)) {\r\natomic_inc(&ddb_entry->relogin_retry_count);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: index[%d] relogin timed out-retrying"\r\n" relogin (%d), retry (%d)\n", __func__,\r\nddb_entry->fw_ddb_index,\r\natomic_read(&ddb_entry->relogin_retry_count),\r\nddb_entry->default_time2wait + 4));\r\nset_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags);\r\natomic_set(&ddb_entry->retry_relogin_timer,\r\nddb_entry->default_time2wait + 4);\r\n}\r\n}\r\n}\r\nstatic void qla4xxx_timer(struct scsi_qla_host *ha)\r\n{\r\nint start_dpc = 0;\r\nuint16_t w;\r\niscsi_host_for_each_session(ha->host, qla4xxx_check_relogin_flash_ddb);\r\nif (test_bit(AF_EEH_BUSY, &ha->flags)) {\r\nmod_timer(&ha->timer, jiffies + HZ);\r\nreturn;\r\n}\r\nif (!pci_channel_offline(ha->pdev))\r\npci_read_config_word(ha->pdev, PCI_VENDOR_ID, &w);\r\nif (is_qla80XX(ha))\r\nqla4_8xxx_watchdog(ha);\r\nif (is_qla40XX(ha)) {\r\nif (ha->firmware_options & FWOPT_HEARTBEAT_ENABLE &&\r\nha->heartbeat_interval != 0) {\r\nha->seconds_since_last_heartbeat++;\r\nif (ha->seconds_since_last_heartbeat >\r\nha->heartbeat_interval + 2)\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\n}\r\n}\r\nif (!list_empty(&ha->work_list))\r\nstart_dpc++;\r\nif (start_dpc ||\r\ntest_bit(DPC_RESET_HA, &ha->dpc_flags) ||\r\ntest_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags) ||\r\ntest_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||\r\ntest_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags) ||\r\ntest_bit(DPC_LINK_CHANGED, &ha->dpc_flags) ||\r\ntest_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags) ||\r\ntest_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags) ||\r\ntest_bit(DPC_SYSFS_DDB_EXPORT, &ha->dpc_flags) ||\r\ntest_bit(DPC_AEN, &ha->dpc_flags)) {\r\nDEBUG2(printk("scsi%ld: %s: scheduling dpc routine"\r\n" - dpc flags = 0x%lx\n",\r\nha->host_no, __func__, ha->dpc_flags));\r\nqla4xxx_wake_dpc(ha);\r\n}\r\nmod_timer(&ha->timer, jiffies + HZ);\r\nDEBUG2(ha->seconds_since_last_intr++);\r\n}\r\nstatic int qla4xxx_cmd_wait(struct scsi_qla_host *ha)\r\n{\r\nuint32_t index = 0;\r\nunsigned long flags;\r\nstruct scsi_cmnd *cmd;\r\nunsigned long wtime;\r\nuint32_t wtmo;\r\nif (is_qla40XX(ha))\r\nwtmo = WAIT_CMD_TOV;\r\nelse\r\nwtmo = ha->nx_reset_timeout / 2;\r\nwtime = jiffies + (wtmo * HZ);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Wait up to %u seconds for cmds to complete\n",\r\nwtmo));\r\nwhile (!time_after_eq(jiffies, wtime)) {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nfor (index = 0; index < ha->host->can_queue; index++) {\r\ncmd = scsi_host_find_tag(ha->host, index);\r\nif (cmd != NULL && CMD_SP(cmd))\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (index == ha->host->can_queue)\r\nreturn QLA_SUCCESS;\r\nmsleep(1000);\r\n}\r\nreturn QLA_ERROR;\r\n}\r\nint qla4xxx_hw_reset(struct scsi_qla_host *ha)\r\n{\r\nuint32_t ctrl_status;\r\nunsigned long flags = 0;\r\nDEBUG2(printk(KERN_ERR "scsi%ld: %s\n", ha->host_no, __func__));\r\nif (ql4xxx_lock_drvr_wait(ha) != QLA_SUCCESS)\r\nreturn QLA_ERROR;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nctrl_status = readw(&ha->reg->ctrl_status);\r\nif ((ctrl_status & CSR_SCSI_RESET_INTR) != 0)\r\nwritel(set_rmask(CSR_SCSI_RESET_INTR), &ha->reg->ctrl_status);\r\nwritel(set_rmask(CSR_SOFT_RESET), &ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_SUCCESS;\r\n}\r\nint qla4xxx_soft_reset(struct scsi_qla_host *ha)\r\n{\r\nuint32_t max_wait_time;\r\nunsigned long flags = 0;\r\nint status;\r\nuint32_t ctrl_status;\r\nstatus = qla4xxx_hw_reset(ha);\r\nif (status != QLA_SUCCESS)\r\nreturn status;\r\nstatus = QLA_ERROR;\r\nmax_wait_time = RESET_INTR_TOV;\r\ndo {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nctrl_status = readw(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif ((ctrl_status & CSR_NET_RESET_INTR) == 0)\r\nbreak;\r\nmsleep(1000);\r\n} while ((--max_wait_time));\r\nif ((ctrl_status & CSR_NET_RESET_INTR) != 0) {\r\nDEBUG2(printk(KERN_WARNING\r\n"scsi%ld: Network Reset Intr not cleared by "\r\n"Network function, clearing it now!\n",\r\nha->host_no));\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nwritel(set_rmask(CSR_NET_RESET_INTR), &ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nmax_wait_time = SOFT_RESET_TOV;\r\ndo {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nctrl_status = readw(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif ((ctrl_status & CSR_SOFT_RESET) == 0) {\r\nstatus = QLA_SUCCESS;\r\nbreak;\r\n}\r\nmsleep(1000);\r\n} while ((--max_wait_time));\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nctrl_status = readw(&ha->reg->ctrl_status);\r\nif ((ctrl_status & CSR_SCSI_RESET_INTR) != 0) {\r\nwritel(set_rmask(CSR_SCSI_RESET_INTR), &ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (max_wait_time == 0) {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nwritel(set_rmask(CSR_FORCE_SOFT_RESET), &ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nmax_wait_time = SOFT_RESET_TOV;\r\ndo {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nctrl_status = readw(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif ((ctrl_status & CSR_FORCE_SOFT_RESET) == 0) {\r\nstatus = QLA_SUCCESS;\r\nbreak;\r\n}\r\nmsleep(1000);\r\n} while ((--max_wait_time));\r\n}\r\nreturn status;\r\n}\r\nstatic void qla4xxx_abort_active_cmds(struct scsi_qla_host *ha, int res)\r\n{\r\nstruct srb *srb;\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nfor (i = 0; i < ha->host->can_queue; i++) {\r\nsrb = qla4xxx_del_from_active_array(ha, i);\r\nif (srb != NULL) {\r\nsrb->cmd->result = res;\r\nkref_put(&srb->srb_ref, qla4xxx_srb_compl);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nvoid qla4xxx_dead_adapter_cleanup(struct scsi_qla_host *ha)\r\n{\r\nclear_bit(AF_ONLINE, &ha->flags);\r\nql4_printk(KERN_INFO, ha, "Disabling the board\n");\r\nqla4xxx_abort_active_cmds(ha, DID_NO_CONNECT << 16);\r\nqla4xxx_mark_all_devices_missing(ha);\r\nclear_bit(AF_INIT_DONE, &ha->flags);\r\n}\r\nstatic void qla4xxx_fail_session(struct iscsi_cls_session *cls_session)\r\n{\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb_entry;\r\nsess = cls_session->dd_data;\r\nddb_entry = sess->dd_data;\r\nddb_entry->fw_ddb_device_state = DDB_DS_SESSION_FAILED;\r\nif (ddb_entry->ddb_type == FLASH_DDB)\r\niscsi_block_session(ddb_entry->sess);\r\nelse\r\niscsi_session_failure(cls_session->dd_data,\r\nISCSI_ERR_CONN_FAILED);\r\n}\r\nstatic int qla4xxx_recover_adapter(struct scsi_qla_host *ha)\r\n{\r\nint status = QLA_ERROR;\r\nuint8_t reset_chip = 0;\r\nuint32_t dev_state;\r\nunsigned long wait;\r\nscsi_block_requests(ha->host);\r\nclear_bit(AF_ONLINE, &ha->flags);\r\nclear_bit(AF_LINK_UP, &ha->flags);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: adapter OFFLINE\n", __func__));\r\nset_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\r\nif ((is_qla8032(ha) || is_qla8042(ha)) &&\r\n!test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags)) {\r\nql4_printk(KERN_INFO, ha, "%s: disabling pause transmit on port 0 & 1.\n",\r\n__func__);\r\nqla4_83xx_disable_pause(ha);\r\n}\r\niscsi_host_for_each_session(ha->host, qla4xxx_fail_session);\r\nif (test_bit(DPC_RESET_HA, &ha->dpc_flags))\r\nreset_chip = 1;\r\nif (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {\r\nstatus = QLA_SUCCESS;\r\ngoto recover_ha_init_adapter;\r\n}\r\nif (is_qla80XX(ha) && !reset_chip &&\r\ntest_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"scsi%ld: %s - Performing stop_firmware...\n",\r\nha->host_no, __func__));\r\nstatus = ha->isp_ops->reset_firmware(ha);\r\nif (status == QLA_SUCCESS) {\r\nha->isp_ops->disable_intrs(ha);\r\nqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\r\nqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\r\n} else {\r\nreset_chip = 1;\r\nclear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\n}\r\n}\r\nif (is_qla40XX(ha) || reset_chip) {\r\nif (is_qla40XX(ha))\r\ngoto chip_reset;\r\nif (test_bit(AF_FW_RECOVERY, &ha->flags))\r\ngoto chip_reset;\r\nwait = jiffies + (FW_ALIVE_WAIT_TOV * HZ);\r\nwhile (time_before(jiffies, wait)) {\r\nif (qla4_8xxx_check_fw_alive(ha)) {\r\nqla4xxx_mailbox_premature_completion(ha);\r\nbreak;\r\n}\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(HZ);\r\n}\r\nchip_reset:\r\nif (!test_bit(AF_FW_RECOVERY, &ha->flags))\r\nqla4xxx_cmd_wait(ha);\r\nqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"scsi%ld: %s - Performing chip reset..\n",\r\nha->host_no, __func__));\r\nstatus = ha->isp_ops->reset_chip(ha);\r\nqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\r\n}\r\nqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\r\nrecover_ha_init_adapter:\r\nif (status == QLA_SUCCESS) {\r\nif (is_qla40XX(ha) && (ha->mac_index == 3))\r\nssleep(6);\r\nstatus = qla4xxx_initialize_adapter(ha, RESET_ADAPTER);\r\nif (is_qla80XX(ha) && (status == QLA_ERROR)) {\r\nstatus = qla4_8xxx_check_init_adapter_retry(ha);\r\nif (status == QLA_ERROR) {\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: Don't retry recover adapter\n",\r\nha->host_no, __func__);\r\nqla4xxx_dead_adapter_cleanup(ha);\r\nclear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\r\nclear_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nclear_bit(DPC_RESET_HA_FW_CONTEXT,\r\n&ha->dpc_flags);\r\ngoto exit_recover;\r\n}\r\n}\r\n}\r\nif (!test_bit(AF_ONLINE, &ha->flags) &&\r\n!test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {\r\nif (is_qla80XX(ha)) {\r\nha->isp_ops->idc_lock(ha);\r\ndev_state = qla4_8xxx_rd_direct(ha,\r\nQLA8XXX_CRB_DEV_STATE);\r\nha->isp_ops->idc_unlock(ha);\r\nif (dev_state == QLA8XXX_DEV_FAILED) {\r\nql4_printk(KERN_INFO, ha, "%s: don't retry "\r\n"recover adapter. H/W is in Failed "\r\n"state\n", __func__);\r\nqla4xxx_dead_adapter_cleanup(ha);\r\nclear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\r\nclear_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nclear_bit(DPC_RESET_HA_FW_CONTEXT,\r\n&ha->dpc_flags);\r\nstatus = QLA_ERROR;\r\ngoto exit_recover;\r\n}\r\n}\r\nif (!test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags)) {\r\nha->retry_reset_ha_cnt = MAX_RESET_HA_RETRIES;\r\nDEBUG2(printk("scsi%ld: recover adapter - retrying "\r\n"(%d) more times\n", ha->host_no,\r\nha->retry_reset_ha_cnt));\r\nset_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\r\nstatus = QLA_ERROR;\r\n} else {\r\nif (ha->retry_reset_ha_cnt > 0) {\r\nha->retry_reset_ha_cnt--;\r\nDEBUG2(printk("scsi%ld: recover adapter - "\r\n"retry remaining %d\n",\r\nha->host_no,\r\nha->retry_reset_ha_cnt));\r\nstatus = QLA_ERROR;\r\n}\r\nif (ha->retry_reset_ha_cnt == 0) {\r\nDEBUG2(printk("scsi%ld: recover adapter "\r\n"failed - board disabled\n",\r\nha->host_no));\r\nqla4xxx_dead_adapter_cleanup(ha);\r\nclear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\r\nclear_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nclear_bit(DPC_RESET_HA_FW_CONTEXT,\r\n&ha->dpc_flags);\r\nstatus = QLA_ERROR;\r\n}\r\n}\r\n} else {\r\nclear_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nclear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\r\nclear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\r\n}\r\nexit_recover:\r\nha->adapter_error_count++;\r\nif (test_bit(AF_ONLINE, &ha->flags))\r\nha->isp_ops->enable_intrs(ha);\r\nscsi_unblock_requests(ha->host);\r\nclear_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\r\nDEBUG2(printk("scsi%ld: recover adapter: %s\n", ha->host_no,\r\nstatus == QLA_ERROR ? "FAILED" : "SUCCEEDED"));\r\nreturn status;\r\n}\r\nstatic void qla4xxx_relogin_devices(struct iscsi_cls_session *cls_session)\r\n{\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb_entry;\r\nstruct scsi_qla_host *ha;\r\nsess = cls_session->dd_data;\r\nddb_entry = sess->dd_data;\r\nha = ddb_entry->ha;\r\nif (!iscsi_is_session_online(cls_session)) {\r\nif (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE) {\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: ddb[%d]"\r\n" unblock session\n", ha->host_no, __func__,\r\nddb_entry->fw_ddb_index);\r\niscsi_unblock_session(ddb_entry->sess);\r\n} else {\r\nif (ddb_entry->ddb_type == FLASH_DDB) {\r\nif (!(test_bit(DF_RELOGIN, &ddb_entry->flags) ||\r\ntest_bit(DF_DISABLE_RELOGIN,\r\n&ddb_entry->flags)))\r\nqla4xxx_arm_relogin_timer(ddb_entry);\r\n} else\r\niscsi_session_failure(cls_session->dd_data,\r\nISCSI_ERR_CONN_FAILED);\r\n}\r\n}\r\n}\r\nint qla4xxx_unblock_flash_ddb(struct iscsi_cls_session *cls_session)\r\n{\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb_entry;\r\nstruct scsi_qla_host *ha;\r\nsess = cls_session->dd_data;\r\nddb_entry = sess->dd_data;\r\nha = ddb_entry->ha;\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: ddb[%d]"\r\n" unblock session\n", ha->host_no, __func__,\r\nddb_entry->fw_ddb_index);\r\niscsi_unblock_session(ddb_entry->sess);\r\nif (test_bit(AF_ONLINE, &ha->flags)) {\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: ddb[%d]"\r\n" start scan\n", ha->host_no, __func__,\r\nddb_entry->fw_ddb_index);\r\nscsi_queue_work(ha->host, &ddb_entry->sess->scan_work);\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nint qla4xxx_unblock_ddb(struct iscsi_cls_session *cls_session)\r\n{\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb_entry;\r\nstruct scsi_qla_host *ha;\r\nint status = QLA_SUCCESS;\r\nsess = cls_session->dd_data;\r\nddb_entry = sess->dd_data;\r\nha = ddb_entry->ha;\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: ddb[%d]"\r\n" unblock user space session\n", ha->host_no, __func__,\r\nddb_entry->fw_ddb_index);\r\nif (!iscsi_is_session_online(cls_session)) {\r\niscsi_conn_start(ddb_entry->conn);\r\niscsi_conn_login_event(ddb_entry->conn,\r\nISCSI_CONN_STATE_LOGGED_IN);\r\n} else {\r\nql4_printk(KERN_INFO, ha,\r\n"scsi%ld: %s: ddb[%d] session [%d] already logged in\n",\r\nha->host_no, __func__, ddb_entry->fw_ddb_index,\r\ncls_session->sid);\r\nstatus = QLA_ERROR;\r\n}\r\nreturn status;\r\n}\r\nstatic void qla4xxx_relogin_all_devices(struct scsi_qla_host *ha)\r\n{\r\niscsi_host_for_each_session(ha->host, qla4xxx_relogin_devices);\r\n}\r\nstatic void qla4xxx_relogin_flash_ddb(struct iscsi_cls_session *cls_sess)\r\n{\r\nuint16_t relogin_timer;\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb_entry;\r\nstruct scsi_qla_host *ha;\r\nsess = cls_sess->dd_data;\r\nddb_entry = sess->dd_data;\r\nha = ddb_entry->ha;\r\nrelogin_timer = max(ddb_entry->default_relogin_timeout,\r\n(uint16_t)RELOGIN_TOV);\r\natomic_set(&ddb_entry->relogin_timer, relogin_timer);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"scsi%ld: Relogin index [%d]. TOV=%d\n", ha->host_no,\r\nddb_entry->fw_ddb_index, relogin_timer));\r\nqla4xxx_login_flash_ddb(cls_sess);\r\n}\r\nstatic void qla4xxx_dpc_relogin(struct iscsi_cls_session *cls_sess)\r\n{\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb_entry;\r\nstruct scsi_qla_host *ha;\r\nsess = cls_sess->dd_data;\r\nddb_entry = sess->dd_data;\r\nha = ddb_entry->ha;\r\nif (!(ddb_entry->ddb_type == FLASH_DDB))\r\nreturn;\r\nif (test_bit(DF_DISABLE_RELOGIN, &ddb_entry->flags))\r\nreturn;\r\nif (test_and_clear_bit(DF_RELOGIN, &ddb_entry->flags) &&\r\n!iscsi_is_session_online(cls_sess)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"relogin issued\n"));\r\nqla4xxx_relogin_flash_ddb(cls_sess);\r\n}\r\n}\r\nvoid qla4xxx_wake_dpc(struct scsi_qla_host *ha)\r\n{\r\nif (ha->dpc_thread)\r\nqueue_work(ha->dpc_thread, &ha->dpc_work);\r\n}\r\nstatic struct qla4_work_evt *\r\nqla4xxx_alloc_work(struct scsi_qla_host *ha, uint32_t data_size,\r\nenum qla4_work_type type)\r\n{\r\nstruct qla4_work_evt *e;\r\nuint32_t size = sizeof(struct qla4_work_evt) + data_size;\r\ne = kzalloc(size, GFP_ATOMIC);\r\nif (!e)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&e->list);\r\ne->type = type;\r\nreturn e;\r\n}\r\nstatic void qla4xxx_post_work(struct scsi_qla_host *ha,\r\nstruct qla4_work_evt *e)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->work_lock, flags);\r\nlist_add_tail(&e->list, &ha->work_list);\r\nspin_unlock_irqrestore(&ha->work_lock, flags);\r\nqla4xxx_wake_dpc(ha);\r\n}\r\nint qla4xxx_post_aen_work(struct scsi_qla_host *ha,\r\nenum iscsi_host_event_code aen_code,\r\nuint32_t data_size, uint8_t *data)\r\n{\r\nstruct qla4_work_evt *e;\r\ne = qla4xxx_alloc_work(ha, data_size, QLA4_EVENT_AEN);\r\nif (!e)\r\nreturn QLA_ERROR;\r\ne->u.aen.code = aen_code;\r\ne->u.aen.data_size = data_size;\r\nmemcpy(e->u.aen.data, data, data_size);\r\nqla4xxx_post_work(ha, e);\r\nreturn QLA_SUCCESS;\r\n}\r\nint qla4xxx_post_ping_evt_work(struct scsi_qla_host *ha,\r\nuint32_t status, uint32_t pid,\r\nuint32_t data_size, uint8_t *data)\r\n{\r\nstruct qla4_work_evt *e;\r\ne = qla4xxx_alloc_work(ha, data_size, QLA4_EVENT_PING_STATUS);\r\nif (!e)\r\nreturn QLA_ERROR;\r\ne->u.ping.status = status;\r\ne->u.ping.pid = pid;\r\ne->u.ping.data_size = data_size;\r\nmemcpy(e->u.ping.data, data, data_size);\r\nqla4xxx_post_work(ha, e);\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic void qla4xxx_do_work(struct scsi_qla_host *ha)\r\n{\r\nstruct qla4_work_evt *e, *tmp;\r\nunsigned long flags;\r\nLIST_HEAD(work);\r\nspin_lock_irqsave(&ha->work_lock, flags);\r\nlist_splice_init(&ha->work_list, &work);\r\nspin_unlock_irqrestore(&ha->work_lock, flags);\r\nlist_for_each_entry_safe(e, tmp, &work, list) {\r\nlist_del_init(&e->list);\r\nswitch (e->type) {\r\ncase QLA4_EVENT_AEN:\r\niscsi_post_host_event(ha->host_no,\r\n&qla4xxx_iscsi_transport,\r\ne->u.aen.code,\r\ne->u.aen.data_size,\r\ne->u.aen.data);\r\nbreak;\r\ncase QLA4_EVENT_PING_STATUS:\r\niscsi_ping_comp_event(ha->host_no,\r\n&qla4xxx_iscsi_transport,\r\ne->u.ping.status,\r\ne->u.ping.pid,\r\ne->u.ping.data_size,\r\ne->u.ping.data);\r\nbreak;\r\ndefault:\r\nql4_printk(KERN_WARNING, ha, "event type: 0x%x not "\r\n"supported", e->type);\r\n}\r\nkfree(e);\r\n}\r\n}\r\nstatic void qla4xxx_do_dpc(struct work_struct *work)\r\n{\r\nstruct scsi_qla_host *ha =\r\ncontainer_of(work, struct scsi_qla_host, dpc_work);\r\nint status = QLA_ERROR;\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"scsi%ld: %s: DPC handler waking up. flags = 0x%08lx, dpc_flags = 0x%08lx\n",\r\nha->host_no, __func__, ha->flags, ha->dpc_flags));\r\nif (!test_bit(AF_INIT_DONE, &ha->flags))\r\nreturn;\r\nif (test_bit(AF_EEH_BUSY, &ha->flags)) {\r\nDEBUG2(printk(KERN_INFO "scsi%ld: %s: flags = %lx\n",\r\nha->host_no, __func__, ha->flags));\r\nreturn;\r\n}\r\nqla4xxx_do_work(ha);\r\nif (is_qla80XX(ha)) {\r\nif (test_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags)) {\r\nif (is_qla8032(ha) || is_qla8042(ha)) {\r\nql4_printk(KERN_INFO, ha, "%s: disabling pause transmit on port 0 & 1.\n",\r\n__func__);\r\nqla4_83xx_disable_pause(ha);\r\n}\r\nha->isp_ops->idc_lock(ha);\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\r\nQLA8XXX_DEV_FAILED);\r\nha->isp_ops->idc_unlock(ha);\r\nql4_printk(KERN_INFO, ha, "HW State: FAILED\n");\r\nqla4_8xxx_device_state_handler(ha);\r\n}\r\nif (test_bit(DPC_POST_IDC_ACK, &ha->dpc_flags)) {\r\nif (is_qla8042(ha)) {\r\nif (ha->idc_info.info2 &\r\nENABLE_INTERNAL_LOOPBACK) {\r\nql4_printk(KERN_INFO, ha, "%s: Disabling ACB\n",\r\n__func__);\r\nstatus = qla4_84xx_config_acb(ha,\r\nACB_CONFIG_DISABLE);\r\nif (status != QLA_SUCCESS) {\r\nql4_printk(KERN_INFO, ha, "%s: ACB config failed\n",\r\n__func__);\r\n}\r\n}\r\n}\r\nqla4_83xx_post_idc_ack(ha);\r\nclear_bit(DPC_POST_IDC_ACK, &ha->dpc_flags);\r\n}\r\nif (is_qla8042(ha) &&\r\ntest_bit(DPC_RESTORE_ACB, &ha->dpc_flags)) {\r\nql4_printk(KERN_INFO, ha, "%s: Restoring ACB\n",\r\n__func__);\r\nif (qla4_84xx_config_acb(ha, ACB_CONFIG_SET) !=\r\nQLA_SUCCESS) {\r\nql4_printk(KERN_INFO, ha, "%s: ACB config failed ",\r\n__func__);\r\n}\r\nclear_bit(DPC_RESTORE_ACB, &ha->dpc_flags);\r\n}\r\nif (test_and_clear_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags)) {\r\nqla4_8xxx_need_qsnt_handler(ha);\r\n}\r\n}\r\nif (!test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags) &&\r\n(test_bit(DPC_RESET_HA, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags))) {\r\nif ((is_qla8022(ha) && ql4xdontresethba) ||\r\n((is_qla8032(ha) || is_qla8042(ha)) &&\r\nqla4_83xx_idc_dontreset(ha))) {\r\nDEBUG2(printk("scsi%ld: %s: Don't Reset HBA\n",\r\nha->host_no, __func__));\r\nclear_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nclear_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);\r\nclear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\r\ngoto dpc_post_reset_ha;\r\n}\r\nif (test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_HA, &ha->dpc_flags))\r\nqla4xxx_recover_adapter(ha);\r\nif (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {\r\nuint8_t wait_time = RESET_INTR_TOV;\r\nwhile ((readw(&ha->reg->ctrl_status) &\r\n(CSR_SOFT_RESET | CSR_FORCE_SOFT_RESET)) != 0) {\r\nif (--wait_time == 0)\r\nbreak;\r\nmsleep(1000);\r\n}\r\nif (wait_time == 0)\r\nDEBUG2(printk("scsi%ld: %s: SR|FSR "\r\n"bit not cleared-- resetting\n",\r\nha->host_no, __func__));\r\nqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\r\nif (ql4xxx_lock_drvr_wait(ha) == QLA_SUCCESS) {\r\nqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\r\nstatus = qla4xxx_recover_adapter(ha);\r\n}\r\nclear_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);\r\nif (status == QLA_SUCCESS)\r\nha->isp_ops->enable_intrs(ha);\r\n}\r\n}\r\ndpc_post_reset_ha:\r\nif (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))\r\nqla4xxx_process_aen(ha, PROCESS_ALL_AENS);\r\nif (test_and_clear_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags))\r\nqla4xxx_get_dhcp_ip_address(ha);\r\nif (adapter_up(ha) &&\r\ntest_and_clear_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags)) {\r\niscsi_host_for_each_session(ha->host, qla4xxx_dpc_relogin);\r\n}\r\nif (!test_bit(AF_LOOPBACK, &ha->flags) &&\r\ntest_and_clear_bit(DPC_LINK_CHANGED, &ha->dpc_flags)) {\r\nif (!test_bit(AF_LINK_UP, &ha->flags)) {\r\nqla4xxx_mark_all_devices_missing(ha);\r\n} else {\r\nif (test_and_clear_bit(AF_BUILD_DDB_LIST, &ha->flags)) {\r\nqla4xxx_build_ddb_list(ha, ha->is_reset);\r\niscsi_host_for_each_session(ha->host,\r\nqla4xxx_login_flash_ddb);\r\n} else\r\nqla4xxx_relogin_all_devices(ha);\r\n}\r\n}\r\nif (test_and_clear_bit(DPC_SYSFS_DDB_EXPORT, &ha->dpc_flags)) {\r\nif (qla4xxx_sysfs_ddb_export(ha))\r\nql4_printk(KERN_ERR, ha, "%s: Error exporting ddb to sysfs\n",\r\n__func__);\r\n}\r\n}\r\nstatic void qla4xxx_free_adapter(struct scsi_qla_host *ha)\r\n{\r\nqla4xxx_abort_active_cmds(ha, DID_NO_CONNECT << 16);\r\nha->isp_ops->disable_intrs(ha);\r\nif (is_qla40XX(ha)) {\r\nwritel(set_rmask(CSR_SCSI_PROCESSOR_INTR),\r\n&ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\n} else if (is_qla8022(ha)) {\r\nwritel(0, &ha->qla4_82xx_reg->host_int);\r\nreadl(&ha->qla4_82xx_reg->host_int);\r\n} else if (is_qla8032(ha) || is_qla8042(ha)) {\r\nwritel(0, &ha->qla4_83xx_reg->risc_intr);\r\nreadl(&ha->qla4_83xx_reg->risc_intr);\r\n}\r\nif (ha->timer_active)\r\nqla4xxx_stop_timer(ha);\r\nif (ha->dpc_thread)\r\ndestroy_workqueue(ha->dpc_thread);\r\nif (ha->task_wq)\r\ndestroy_workqueue(ha->task_wq);\r\nha->isp_ops->reset_firmware(ha);\r\nif (is_qla80XX(ha)) {\r\nha->isp_ops->idc_lock(ha);\r\nqla4_8xxx_clear_drv_active(ha);\r\nha->isp_ops->idc_unlock(ha);\r\n}\r\nqla4xxx_free_irqs(ha);\r\nqla4xxx_mem_free(ha);\r\n}\r\nint qla4_8xxx_iospace_config(struct scsi_qla_host *ha)\r\n{\r\nint status = 0;\r\nunsigned long mem_base, mem_len, db_base, db_len;\r\nstruct pci_dev *pdev = ha->pdev;\r\nstatus = pci_request_regions(pdev, DRIVER_NAME);\r\nif (status) {\r\nprintk(KERN_WARNING\r\n"scsi(%ld) Failed to reserve PIO regions (%s) "\r\n"status=%d\n", ha->host_no, pci_name(pdev), status);\r\ngoto iospace_error_exit;\r\n}\r\nDEBUG2(printk(KERN_INFO "%s: revision-id=%d\n",\r\n__func__, pdev->revision));\r\nha->revision_id = pdev->revision;\r\nmem_base = pci_resource_start(pdev, 0);\r\nmem_len = pci_resource_len(pdev, 0);\r\nDEBUG2(printk(KERN_INFO "%s: ioremap from %lx a size of %lx\n",\r\n__func__, mem_base, mem_len));\r\nha->nx_pcibase = (unsigned long)ioremap(mem_base, mem_len);\r\nif (!ha->nx_pcibase) {\r\nprintk(KERN_ERR\r\n"cannot remap MMIO (%s), aborting\n", pci_name(pdev));\r\npci_release_regions(ha->pdev);\r\ngoto iospace_error_exit;\r\n}\r\nif (is_qla8022(ha)) {\r\nha->qla4_82xx_reg = (struct device_reg_82xx __iomem *)\r\n((uint8_t *)ha->nx_pcibase + 0xbc000 +\r\n(ha->pdev->devfn << 11));\r\nha->nx_db_wr_ptr = (ha->pdev->devfn == 4 ? QLA82XX_CAM_RAM_DB1 :\r\nQLA82XX_CAM_RAM_DB2);\r\n} else if (is_qla8032(ha) || is_qla8042(ha)) {\r\nha->qla4_83xx_reg = (struct device_reg_83xx __iomem *)\r\n((uint8_t *)ha->nx_pcibase);\r\n}\r\ndb_base = pci_resource_start(pdev, 4);\r\ndb_len = pci_resource_len(pdev, 4);\r\nreturn 0;\r\niospace_error_exit:\r\nreturn -ENOMEM;\r\n}\r\nint qla4xxx_iospace_config(struct scsi_qla_host *ha)\r\n{\r\nunsigned long pio, pio_len, pio_flags;\r\nunsigned long mmio, mmio_len, mmio_flags;\r\npio = pci_resource_start(ha->pdev, 0);\r\npio_len = pci_resource_len(ha->pdev, 0);\r\npio_flags = pci_resource_flags(ha->pdev, 0);\r\nif (pio_flags & IORESOURCE_IO) {\r\nif (pio_len < MIN_IOBASE_LEN) {\r\nql4_printk(KERN_WARNING, ha,\r\n"Invalid PCI I/O region size\n");\r\npio = 0;\r\n}\r\n} else {\r\nql4_printk(KERN_WARNING, ha, "region #0 not a PIO resource\n");\r\npio = 0;\r\n}\r\nmmio = pci_resource_start(ha->pdev, 1);\r\nmmio_len = pci_resource_len(ha->pdev, 1);\r\nmmio_flags = pci_resource_flags(ha->pdev, 1);\r\nif (!(mmio_flags & IORESOURCE_MEM)) {\r\nql4_printk(KERN_ERR, ha,\r\n"region #0 not an MMIO resource, aborting\n");\r\ngoto iospace_error_exit;\r\n}\r\nif (mmio_len < MIN_IOBASE_LEN) {\r\nql4_printk(KERN_ERR, ha,\r\n"Invalid PCI mem region size, aborting\n");\r\ngoto iospace_error_exit;\r\n}\r\nif (pci_request_regions(ha->pdev, DRIVER_NAME)) {\r\nql4_printk(KERN_WARNING, ha,\r\n"Failed to reserve PIO/MMIO regions\n");\r\ngoto iospace_error_exit;\r\n}\r\nha->pio_address = pio;\r\nha->pio_length = pio_len;\r\nha->reg = ioremap(mmio, MIN_IOBASE_LEN);\r\nif (!ha->reg) {\r\nql4_printk(KERN_ERR, ha,\r\n"cannot remap MMIO, aborting\n");\r\ngoto iospace_error_exit;\r\n}\r\nreturn 0;\r\niospace_error_exit:\r\nreturn -ENOMEM;\r\n}\r\nuint16_t qla4xxx_rd_shdw_req_q_out(struct scsi_qla_host *ha)\r\n{\r\nreturn (uint16_t)le32_to_cpu(ha->shadow_regs->req_q_out);\r\n}\r\nuint16_t qla4_82xx_rd_shdw_req_q_out(struct scsi_qla_host *ha)\r\n{\r\nreturn (uint16_t)le32_to_cpu(readl(&ha->qla4_82xx_reg->req_q_out));\r\n}\r\nuint16_t qla4xxx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha)\r\n{\r\nreturn (uint16_t)le32_to_cpu(ha->shadow_regs->rsp_q_in);\r\n}\r\nuint16_t qla4_82xx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha)\r\n{\r\nreturn (uint16_t)le32_to_cpu(readl(&ha->qla4_82xx_reg->rsp_q_in));\r\n}\r\nstatic ssize_t qla4xxx_show_boot_eth_info(void *data, int type, char *buf)\r\n{\r\nstruct scsi_qla_host *ha = data;\r\nchar *str = buf;\r\nint rc;\r\nswitch (type) {\r\ncase ISCSI_BOOT_ETH_FLAGS:\r\nrc = sprintf(str, "%d\n", SYSFS_FLAG_FW_SEL_BOOT);\r\nbreak;\r\ncase ISCSI_BOOT_ETH_INDEX:\r\nrc = sprintf(str, "0\n");\r\nbreak;\r\ncase ISCSI_BOOT_ETH_MAC:\r\nrc = sysfs_format_mac(str, ha->my_mac,\r\nMAC_ADDR_LEN);\r\nbreak;\r\ndefault:\r\nrc = -ENOSYS;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic umode_t qla4xxx_eth_get_attr_visibility(void *data, int type)\r\n{\r\nint rc;\r\nswitch (type) {\r\ncase ISCSI_BOOT_ETH_FLAGS:\r\ncase ISCSI_BOOT_ETH_MAC:\r\ncase ISCSI_BOOT_ETH_INDEX:\r\nrc = S_IRUGO;\r\nbreak;\r\ndefault:\r\nrc = 0;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t qla4xxx_show_boot_ini_info(void *data, int type, char *buf)\r\n{\r\nstruct scsi_qla_host *ha = data;\r\nchar *str = buf;\r\nint rc;\r\nswitch (type) {\r\ncase ISCSI_BOOT_INI_INITIATOR_NAME:\r\nrc = sprintf(str, "%s\n", ha->name_string);\r\nbreak;\r\ndefault:\r\nrc = -ENOSYS;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic umode_t qla4xxx_ini_get_attr_visibility(void *data, int type)\r\n{\r\nint rc;\r\nswitch (type) {\r\ncase ISCSI_BOOT_INI_INITIATOR_NAME:\r\nrc = S_IRUGO;\r\nbreak;\r\ndefault:\r\nrc = 0;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\nqla4xxx_show_boot_tgt_info(struct ql4_boot_session_info *boot_sess, int type,\r\nchar *buf)\r\n{\r\nstruct ql4_conn_info *boot_conn = &boot_sess->conn_list[0];\r\nchar *str = buf;\r\nint rc;\r\nswitch (type) {\r\ncase ISCSI_BOOT_TGT_NAME:\r\nrc = sprintf(buf, "%s\n", (char *)&boot_sess->target_name);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_IP_ADDR:\r\nif (boot_sess->conn_list[0].dest_ipaddr.ip_type == 0x1)\r\nrc = sprintf(buf, "%pI4\n",\r\n&boot_conn->dest_ipaddr.ip_address);\r\nelse\r\nrc = sprintf(str, "%pI6\n",\r\n&boot_conn->dest_ipaddr.ip_address);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_PORT:\r\nrc = sprintf(str, "%d\n", boot_conn->dest_port);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_CHAP_NAME:\r\nrc = sprintf(str, "%.*s\n",\r\nboot_conn->chap.target_chap_name_length,\r\n(char *)&boot_conn->chap.target_chap_name);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_CHAP_SECRET:\r\nrc = sprintf(str, "%.*s\n",\r\nboot_conn->chap.target_secret_length,\r\n(char *)&boot_conn->chap.target_secret);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_REV_CHAP_NAME:\r\nrc = sprintf(str, "%.*s\n",\r\nboot_conn->chap.intr_chap_name_length,\r\n(char *)&boot_conn->chap.intr_chap_name);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_REV_CHAP_SECRET:\r\nrc = sprintf(str, "%.*s\n",\r\nboot_conn->chap.intr_secret_length,\r\n(char *)&boot_conn->chap.intr_secret);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_FLAGS:\r\nrc = sprintf(str, "%d\n", SYSFS_FLAG_FW_SEL_BOOT);\r\nbreak;\r\ncase ISCSI_BOOT_TGT_NIC_ASSOC:\r\nrc = sprintf(str, "0\n");\r\nbreak;\r\ndefault:\r\nrc = -ENOSYS;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t qla4xxx_show_boot_tgt_pri_info(void *data, int type, char *buf)\r\n{\r\nstruct scsi_qla_host *ha = data;\r\nstruct ql4_boot_session_info *boot_sess = &(ha->boot_tgt.boot_pri_sess);\r\nreturn qla4xxx_show_boot_tgt_info(boot_sess, type, buf);\r\n}\r\nstatic ssize_t qla4xxx_show_boot_tgt_sec_info(void *data, int type, char *buf)\r\n{\r\nstruct scsi_qla_host *ha = data;\r\nstruct ql4_boot_session_info *boot_sess = &(ha->boot_tgt.boot_sec_sess);\r\nreturn qla4xxx_show_boot_tgt_info(boot_sess, type, buf);\r\n}\r\nstatic umode_t qla4xxx_tgt_get_attr_visibility(void *data, int type)\r\n{\r\nint rc;\r\nswitch (type) {\r\ncase ISCSI_BOOT_TGT_NAME:\r\ncase ISCSI_BOOT_TGT_IP_ADDR:\r\ncase ISCSI_BOOT_TGT_PORT:\r\ncase ISCSI_BOOT_TGT_CHAP_NAME:\r\ncase ISCSI_BOOT_TGT_CHAP_SECRET:\r\ncase ISCSI_BOOT_TGT_REV_CHAP_NAME:\r\ncase ISCSI_BOOT_TGT_REV_CHAP_SECRET:\r\ncase ISCSI_BOOT_TGT_NIC_ASSOC:\r\ncase ISCSI_BOOT_TGT_FLAGS:\r\nrc = S_IRUGO;\r\nbreak;\r\ndefault:\r\nrc = 0;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic void qla4xxx_boot_release(void *data)\r\n{\r\nstruct scsi_qla_host *ha = data;\r\nscsi_host_put(ha->host);\r\n}\r\nstatic int get_fw_boot_info(struct scsi_qla_host *ha, uint16_t ddb_index[])\r\n{\r\ndma_addr_t buf_dma;\r\nuint32_t addr, pri_addr, sec_addr;\r\nuint32_t offset;\r\nuint16_t func_num;\r\nuint8_t val;\r\nuint8_t *buf = NULL;\r\nsize_t size = 13 * sizeof(uint8_t);\r\nint ret = QLA_SUCCESS;\r\nfunc_num = PCI_FUNC(ha->pdev->devfn);\r\nql4_printk(KERN_INFO, ha, "%s: Get FW boot info for 0x%x func %d\n",\r\n__func__, ha->pdev->device, func_num);\r\nif (is_qla40XX(ha)) {\r\nif (func_num == 1) {\r\naddr = NVRAM_PORT0_BOOT_MODE;\r\npri_addr = NVRAM_PORT0_BOOT_PRI_TGT;\r\nsec_addr = NVRAM_PORT0_BOOT_SEC_TGT;\r\n} else if (func_num == 3) {\r\naddr = NVRAM_PORT1_BOOT_MODE;\r\npri_addr = NVRAM_PORT1_BOOT_PRI_TGT;\r\nsec_addr = NVRAM_PORT1_BOOT_SEC_TGT;\r\n} else {\r\nret = QLA_ERROR;\r\ngoto exit_boot_info;\r\n}\r\nval = rd_nvram_byte(ha, addr);\r\nif (!(val & 0x07)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: Adapter boot "\r\n"options : 0x%x\n", __func__, val));\r\nret = QLA_ERROR;\r\ngoto exit_boot_info;\r\n}\r\nval = rd_nvram_byte(ha, pri_addr);\r\nif (val & BIT_7)\r\nddb_index[0] = (val & 0x7f);\r\nval = rd_nvram_byte(ha, sec_addr);\r\nif (val & BIT_7)\r\nddb_index[1] = (val & 0x7f);\r\n} else if (is_qla80XX(ha)) {\r\nbuf = dma_alloc_coherent(&ha->pdev->dev, size,\r\n&buf_dma, GFP_KERNEL);\r\nif (!buf) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer\n",\r\n__func__));\r\nret = QLA_ERROR;\r\ngoto exit_boot_info;\r\n}\r\nif (ha->port_num == 0)\r\noffset = BOOT_PARAM_OFFSET_PORT0;\r\nelse if (ha->port_num == 1)\r\noffset = BOOT_PARAM_OFFSET_PORT1;\r\nelse {\r\nret = QLA_ERROR;\r\ngoto exit_boot_info_free;\r\n}\r\naddr = FLASH_RAW_ACCESS_ADDR + (ha->hw.flt_iscsi_param * 4) +\r\noffset;\r\nif (qla4xxx_get_flash(ha, buf_dma, addr,\r\n13 * sizeof(uint8_t)) != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "scsi%ld: %s: Get Flash"\r\n" failed\n", ha->host_no, __func__));\r\nret = QLA_ERROR;\r\ngoto exit_boot_info_free;\r\n}\r\nif (!(buf[1] & 0x07)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Firmware boot options"\r\n" : 0x%x\n", buf[1]));\r\nret = QLA_ERROR;\r\ngoto exit_boot_info_free;\r\n}\r\nif (buf[2] & BIT_7)\r\nddb_index[0] = buf[2] & 0x7f;\r\nif (buf[11] & BIT_7)\r\nddb_index[1] = buf[11] & 0x7f;\r\n} else {\r\nret = QLA_ERROR;\r\ngoto exit_boot_info;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: Primary target ID %d, Secondary"\r\n" target ID %d\n", __func__, ddb_index[0],\r\nddb_index[1]));\r\nexit_boot_info_free:\r\ndma_free_coherent(&ha->pdev->dev, size, buf, buf_dma);\r\nexit_boot_info:\r\nha->pri_ddb_idx = ddb_index[0];\r\nha->sec_ddb_idx = ddb_index[1];\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_get_bidi_chap(struct scsi_qla_host *ha, char *username,\r\nchar *password)\r\n{\r\nint i, ret = -EINVAL;\r\nint max_chap_entries = 0;\r\nstruct ql4_chap_table *chap_table;\r\nif (is_qla80XX(ha))\r\nmax_chap_entries = (ha->hw.flt_chap_size / 2) /\r\nsizeof(struct ql4_chap_table);\r\nelse\r\nmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\r\nif (!ha->chap_list) {\r\nql4_printk(KERN_ERR, ha, "Do not have CHAP table cache\n");\r\nreturn ret;\r\n}\r\nmutex_lock(&ha->chap_sem);\r\nfor (i = 0; i < max_chap_entries; i++) {\r\nchap_table = (struct ql4_chap_table *)ha->chap_list + i;\r\nif (chap_table->cookie !=\r\n__constant_cpu_to_le16(CHAP_VALID_COOKIE)) {\r\ncontinue;\r\n}\r\nif (chap_table->flags & BIT_7)\r\ncontinue;\r\nif (!(chap_table->flags & BIT_6))\r\ncontinue;\r\nstrlcpy(password, chap_table->secret, QL4_CHAP_MAX_SECRET_LEN);\r\nstrlcpy(username, chap_table->name, QL4_CHAP_MAX_NAME_LEN);\r\nret = 0;\r\nbreak;\r\n}\r\nmutex_unlock(&ha->chap_sem);\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_get_boot_target(struct scsi_qla_host *ha,\r\nstruct ql4_boot_session_info *boot_sess,\r\nuint16_t ddb_index)\r\n{\r\nstruct ql4_conn_info *boot_conn = &boot_sess->conn_list[0];\r\nstruct dev_db_entry *fw_ddb_entry;\r\ndma_addr_t fw_ddb_entry_dma;\r\nuint16_t idx;\r\nuint16_t options;\r\nint ret = QLA_SUCCESS;\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (!fw_ddb_entry) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer.\n",\r\n__func__));\r\nret = QLA_ERROR;\r\nreturn ret;\r\n}\r\nif (qla4xxx_bootdb_by_index(ha, fw_ddb_entry,\r\nfw_ddb_entry_dma, ddb_index)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: No Flash DDB found at "\r\n"index [%d]\n", __func__, ddb_index));\r\nret = QLA_ERROR;\r\ngoto exit_boot_target;\r\n}\r\nmemcpy(boot_sess->target_name, fw_ddb_entry->iscsi_name,\r\nmin(sizeof(boot_sess->target_name),\r\nsizeof(fw_ddb_entry->iscsi_name)));\r\noptions = le16_to_cpu(fw_ddb_entry->options);\r\nif (options & DDB_OPT_IPV6_DEVICE) {\r\nmemcpy(&boot_conn->dest_ipaddr.ip_address,\r\n&fw_ddb_entry->ip_addr[0], IPv6_ADDR_LEN);\r\n} else {\r\nboot_conn->dest_ipaddr.ip_type = 0x1;\r\nmemcpy(&boot_conn->dest_ipaddr.ip_address,\r\n&fw_ddb_entry->ip_addr[0], IP_ADDR_LEN);\r\n}\r\nboot_conn->dest_port = le16_to_cpu(fw_ddb_entry->port);\r\nidx = __le16_to_cpu(fw_ddb_entry->chap_tbl_idx);\r\nif (BIT_7 & le16_to_cpu(fw_ddb_entry->iscsi_options)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Setting chap\n"));\r\nret = qla4xxx_get_chap(ha, (char *)&boot_conn->chap.\r\ntarget_chap_name,\r\n(char *)&boot_conn->chap.target_secret,\r\nidx);\r\nif (ret) {\r\nql4_printk(KERN_ERR, ha, "Failed to set chap\n");\r\nret = QLA_ERROR;\r\ngoto exit_boot_target;\r\n}\r\nboot_conn->chap.target_chap_name_length = QL4_CHAP_MAX_NAME_LEN;\r\nboot_conn->chap.target_secret_length = QL4_CHAP_MAX_SECRET_LEN;\r\n}\r\nif (BIT_4 & le16_to_cpu(fw_ddb_entry->iscsi_options)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Setting BIDI chap\n"));\r\nret = qla4xxx_get_bidi_chap(ha,\r\n(char *)&boot_conn->chap.intr_chap_name,\r\n(char *)&boot_conn->chap.intr_secret);\r\nif (ret) {\r\nql4_printk(KERN_ERR, ha, "Failed to set BIDI chap\n");\r\nret = QLA_ERROR;\r\ngoto exit_boot_target;\r\n}\r\nboot_conn->chap.intr_chap_name_length = QL4_CHAP_MAX_NAME_LEN;\r\nboot_conn->chap.intr_secret_length = QL4_CHAP_MAX_SECRET_LEN;\r\n}\r\nexit_boot_target:\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\nfw_ddb_entry, fw_ddb_entry_dma);\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_get_boot_info(struct scsi_qla_host *ha)\r\n{\r\nuint16_t ddb_index[2];\r\nint ret = QLA_ERROR;\r\nint rval;\r\nmemset(ddb_index, 0, sizeof(ddb_index));\r\nddb_index[0] = 0xffff;\r\nddb_index[1] = 0xffff;\r\nret = get_fw_boot_info(ha, ddb_index);\r\nif (ret != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: No boot target configured.\n", __func__));\r\nreturn ret;\r\n}\r\nif (ql4xdisablesysfsboot)\r\nreturn QLA_SUCCESS;\r\nif (ddb_index[0] == 0xffff)\r\ngoto sec_target;\r\nrval = qla4xxx_get_boot_target(ha, &(ha->boot_tgt.boot_pri_sess),\r\nddb_index[0]);\r\nif (rval != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: Primary boot target not "\r\n"configured\n", __func__));\r\n} else\r\nret = QLA_SUCCESS;\r\nsec_target:\r\nif (ddb_index[1] == 0xffff)\r\ngoto exit_get_boot_info;\r\nrval = qla4xxx_get_boot_target(ha, &(ha->boot_tgt.boot_sec_sess),\r\nddb_index[1]);\r\nif (rval != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: Secondary boot target not"\r\n" configured\n", __func__));\r\n} else\r\nret = QLA_SUCCESS;\r\nexit_get_boot_info:\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_setup_boot_info(struct scsi_qla_host *ha)\r\n{\r\nstruct iscsi_boot_kobj *boot_kobj;\r\nif (qla4xxx_get_boot_info(ha) != QLA_SUCCESS)\r\nreturn QLA_ERROR;\r\nif (ql4xdisablesysfsboot) {\r\nql4_printk(KERN_INFO, ha,\r\n"%s: syfsboot disabled - driver will trigger login "\r\n"and publish session for discovery .\n", __func__);\r\nreturn QLA_SUCCESS;\r\n}\r\nha->boot_kset = iscsi_boot_create_host_kset(ha->host->host_no);\r\nif (!ha->boot_kset)\r\ngoto kset_free;\r\nif (!scsi_host_get(ha->host))\r\ngoto kset_free;\r\nboot_kobj = iscsi_boot_create_target(ha->boot_kset, 0, ha,\r\nqla4xxx_show_boot_tgt_pri_info,\r\nqla4xxx_tgt_get_attr_visibility,\r\nqla4xxx_boot_release);\r\nif (!boot_kobj)\r\ngoto put_host;\r\nif (!scsi_host_get(ha->host))\r\ngoto kset_free;\r\nboot_kobj = iscsi_boot_create_target(ha->boot_kset, 1, ha,\r\nqla4xxx_show_boot_tgt_sec_info,\r\nqla4xxx_tgt_get_attr_visibility,\r\nqla4xxx_boot_release);\r\nif (!boot_kobj)\r\ngoto put_host;\r\nif (!scsi_host_get(ha->host))\r\ngoto kset_free;\r\nboot_kobj = iscsi_boot_create_initiator(ha->boot_kset, 0, ha,\r\nqla4xxx_show_boot_ini_info,\r\nqla4xxx_ini_get_attr_visibility,\r\nqla4xxx_boot_release);\r\nif (!boot_kobj)\r\ngoto put_host;\r\nif (!scsi_host_get(ha->host))\r\ngoto kset_free;\r\nboot_kobj = iscsi_boot_create_ethernet(ha->boot_kset, 0, ha,\r\nqla4xxx_show_boot_eth_info,\r\nqla4xxx_eth_get_attr_visibility,\r\nqla4xxx_boot_release);\r\nif (!boot_kobj)\r\ngoto put_host;\r\nreturn QLA_SUCCESS;\r\nput_host:\r\nscsi_host_put(ha->host);\r\nkset_free:\r\niscsi_boot_destroy_kset(ha->boot_kset);\r\nreturn -ENOMEM;\r\n}\r\nstatic void qla4xxx_get_param_ddb(struct ddb_entry *ddb_entry,\r\nstruct ql4_tuple_ddb *tddb)\r\n{\r\nstruct scsi_qla_host *ha;\r\nstruct iscsi_cls_session *cls_sess;\r\nstruct iscsi_cls_conn *cls_conn;\r\nstruct iscsi_session *sess;\r\nstruct iscsi_conn *conn;\r\nDEBUG2(printk(KERN_INFO "Func: %s\n", __func__));\r\nha = ddb_entry->ha;\r\ncls_sess = ddb_entry->sess;\r\nsess = cls_sess->dd_data;\r\ncls_conn = ddb_entry->conn;\r\nconn = cls_conn->dd_data;\r\ntddb->tpgt = sess->tpgt;\r\ntddb->port = conn->persistent_port;\r\nstrlcpy(tddb->iscsi_name, sess->targetname, ISCSI_NAME_SIZE);\r\nstrlcpy(tddb->ip_addr, conn->persistent_address, DDB_IPADDR_LEN);\r\n}\r\nstatic void qla4xxx_convert_param_ddb(struct dev_db_entry *fw_ddb_entry,\r\nstruct ql4_tuple_ddb *tddb,\r\nuint8_t *flash_isid)\r\n{\r\nuint16_t options = 0;\r\ntddb->tpgt = le32_to_cpu(fw_ddb_entry->tgt_portal_grp);\r\nmemcpy(&tddb->iscsi_name[0], &fw_ddb_entry->iscsi_name[0],\r\nmin(sizeof(tddb->iscsi_name), sizeof(fw_ddb_entry->iscsi_name)));\r\noptions = le16_to_cpu(fw_ddb_entry->options);\r\nif (options & DDB_OPT_IPV6_DEVICE)\r\nsprintf(tddb->ip_addr, "%pI6", fw_ddb_entry->ip_addr);\r\nelse\r\nsprintf(tddb->ip_addr, "%pI4", fw_ddb_entry->ip_addr);\r\ntddb->port = le16_to_cpu(fw_ddb_entry->port);\r\nif (flash_isid == NULL)\r\nmemcpy(&tddb->isid[0], &fw_ddb_entry->isid[0],\r\nsizeof(tddb->isid));\r\nelse\r\nmemcpy(&tddb->isid[0], &flash_isid[0], sizeof(tddb->isid));\r\n}\r\nstatic int qla4xxx_compare_tuple_ddb(struct scsi_qla_host *ha,\r\nstruct ql4_tuple_ddb *old_tddb,\r\nstruct ql4_tuple_ddb *new_tddb,\r\nuint8_t is_isid_compare)\r\n{\r\nif (strcmp(old_tddb->iscsi_name, new_tddb->iscsi_name))\r\nreturn QLA_ERROR;\r\nif (strcmp(old_tddb->ip_addr, new_tddb->ip_addr))\r\nreturn QLA_ERROR;\r\nif (old_tddb->port != new_tddb->port)\r\nreturn QLA_ERROR;\r\nif (is_isid_compare) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: old ISID [%pmR] New ISID [%pmR]\n",\r\n__func__, old_tddb->isid, new_tddb->isid));\r\nif (memcmp(&old_tddb->isid[0], &new_tddb->isid[0],\r\nsizeof(old_tddb->isid)))\r\nreturn QLA_ERROR;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Match Found, fw[%d,%d,%s,%s], [%d,%d,%s,%s]",\r\nold_tddb->port, old_tddb->tpgt, old_tddb->ip_addr,\r\nold_tddb->iscsi_name, new_tddb->port, new_tddb->tpgt,\r\nnew_tddb->ip_addr, new_tddb->iscsi_name));\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic int qla4xxx_is_session_exists(struct scsi_qla_host *ha,\r\nstruct dev_db_entry *fw_ddb_entry,\r\nuint32_t *index)\r\n{\r\nstruct ddb_entry *ddb_entry;\r\nstruct ql4_tuple_ddb *fw_tddb = NULL;\r\nstruct ql4_tuple_ddb *tmp_tddb = NULL;\r\nint idx;\r\nint ret = QLA_ERROR;\r\nfw_tddb = vzalloc(sizeof(*fw_tddb));\r\nif (!fw_tddb) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha,\r\n"Memory Allocation failed.\n"));\r\nret = QLA_SUCCESS;\r\ngoto exit_check;\r\n}\r\ntmp_tddb = vzalloc(sizeof(*tmp_tddb));\r\nif (!tmp_tddb) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha,\r\n"Memory Allocation failed.\n"));\r\nret = QLA_SUCCESS;\r\ngoto exit_check;\r\n}\r\nqla4xxx_convert_param_ddb(fw_ddb_entry, fw_tddb, NULL);\r\nfor (idx = 0; idx < MAX_DDB_ENTRIES; idx++) {\r\nddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\r\nif (ddb_entry == NULL)\r\ncontinue;\r\nqla4xxx_get_param_ddb(ddb_entry, tmp_tddb);\r\nif (!qla4xxx_compare_tuple_ddb(ha, fw_tddb, tmp_tddb, false)) {\r\nret = QLA_SUCCESS;\r\nif (index != NULL)\r\n*index = idx;\r\ngoto exit_check;\r\n}\r\n}\r\nexit_check:\r\nif (fw_tddb)\r\nvfree(fw_tddb);\r\nif (tmp_tddb)\r\nvfree(tmp_tddb);\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_check_existing_isid(struct list_head *list_nt, uint8_t *isid)\r\n{\r\nstruct qla_ddb_index *nt_ddb_idx, *nt_ddb_idx_tmp;\r\nstruct dev_db_entry *fw_ddb_entry;\r\nlist_for_each_entry_safe(nt_ddb_idx, nt_ddb_idx_tmp, list_nt, list) {\r\nfw_ddb_entry = &nt_ddb_idx->fw_ddb;\r\nif (memcmp(&fw_ddb_entry->isid[0], &isid[0],\r\nsizeof(nt_ddb_idx->fw_ddb.isid)) == 0) {\r\nreturn QLA_SUCCESS;\r\n}\r\n}\r\nreturn QLA_ERROR;\r\n}\r\nstatic int qla4xxx_update_isid(struct scsi_qla_host *ha,\r\nstruct list_head *list_nt,\r\nstruct dev_db_entry *fw_ddb_entry)\r\n{\r\nuint8_t base_value, i;\r\nbase_value = fw_ddb_entry->isid[1] & 0x1f;\r\nfor (i = 0; i < 8; i++) {\r\nfw_ddb_entry->isid[1] = (base_value | (i << 5));\r\nif (qla4xxx_check_existing_isid(list_nt, fw_ddb_entry->isid))\r\nbreak;\r\n}\r\nif (!qla4xxx_check_existing_isid(list_nt, fw_ddb_entry->isid))\r\nreturn QLA_ERROR;\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic int qla4xxx_should_update_isid(struct scsi_qla_host *ha,\r\nstruct ql4_tuple_ddb *old_tddb,\r\nstruct ql4_tuple_ddb *new_tddb)\r\n{\r\nif (strcmp(old_tddb->ip_addr, new_tddb->ip_addr) == 0) {\r\nif (old_tddb->port == new_tddb->port)\r\nreturn QLA_ERROR;\r\n}\r\nif (strcmp(old_tddb->iscsi_name, new_tddb->iscsi_name))\r\nreturn QLA_ERROR;\r\nif (memcmp(&old_tddb->isid[0], &new_tddb->isid[0],\r\nsizeof(old_tddb->isid)))\r\nreturn QLA_ERROR;\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic int qla4xxx_is_flash_ddb_exists(struct scsi_qla_host *ha,\r\nstruct list_head *list_nt,\r\nstruct dev_db_entry *fw_ddb_entry)\r\n{\r\nstruct qla_ddb_index *nt_ddb_idx, *nt_ddb_idx_tmp;\r\nstruct ql4_tuple_ddb *fw_tddb = NULL;\r\nstruct ql4_tuple_ddb *tmp_tddb = NULL;\r\nint rval, ret = QLA_ERROR;\r\nfw_tddb = vzalloc(sizeof(*fw_tddb));\r\nif (!fw_tddb) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha,\r\n"Memory Allocation failed.\n"));\r\nret = QLA_SUCCESS;\r\ngoto exit_check;\r\n}\r\ntmp_tddb = vzalloc(sizeof(*tmp_tddb));\r\nif (!tmp_tddb) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha,\r\n"Memory Allocation failed.\n"));\r\nret = QLA_SUCCESS;\r\ngoto exit_check;\r\n}\r\nqla4xxx_convert_param_ddb(fw_ddb_entry, fw_tddb, NULL);\r\nlist_for_each_entry_safe(nt_ddb_idx, nt_ddb_idx_tmp, list_nt, list) {\r\nqla4xxx_convert_param_ddb(&nt_ddb_idx->fw_ddb, tmp_tddb,\r\nnt_ddb_idx->flash_isid);\r\nret = qla4xxx_compare_tuple_ddb(ha, fw_tddb, tmp_tddb, true);\r\nif (ret == QLA_SUCCESS)\r\ngoto exit_check;\r\n}\r\nlist_for_each_entry_safe(nt_ddb_idx, nt_ddb_idx_tmp, list_nt, list) {\r\nqla4xxx_convert_param_ddb(&nt_ddb_idx->fw_ddb, tmp_tddb, NULL);\r\nret = qla4xxx_should_update_isid(ha, tmp_tddb, fw_tddb);\r\nif (ret == QLA_SUCCESS) {\r\nrval = qla4xxx_update_isid(ha, list_nt, fw_ddb_entry);\r\nif (rval == QLA_SUCCESS)\r\nret = QLA_ERROR;\r\nelse\r\nret = QLA_SUCCESS;\r\ngoto exit_check;\r\n}\r\n}\r\nexit_check:\r\nif (fw_tddb)\r\nvfree(fw_tddb);\r\nif (tmp_tddb)\r\nvfree(tmp_tddb);\r\nreturn ret;\r\n}\r\nstatic void qla4xxx_free_ddb_list(struct list_head *list_ddb)\r\n{\r\nstruct qla_ddb_index *ddb_idx, *ddb_idx_tmp;\r\nlist_for_each_entry_safe(ddb_idx, ddb_idx_tmp, list_ddb, list) {\r\nlist_del_init(&ddb_idx->list);\r\nvfree(ddb_idx);\r\n}\r\n}\r\nstatic struct iscsi_endpoint *qla4xxx_get_ep_fwdb(struct scsi_qla_host *ha,\r\nstruct dev_db_entry *fw_ddb_entry)\r\n{\r\nstruct iscsi_endpoint *ep;\r\nstruct sockaddr_in *addr;\r\nstruct sockaddr_in6 *addr6;\r\nstruct sockaddr *t_addr;\r\nstruct sockaddr_storage *dst_addr;\r\nchar *ip;\r\ndst_addr = vmalloc(sizeof(*dst_addr));\r\nif (!dst_addr)\r\nreturn NULL;\r\nif (fw_ddb_entry->options & DDB_OPT_IPV6_DEVICE) {\r\nt_addr = (struct sockaddr *)dst_addr;\r\nt_addr->sa_family = AF_INET6;\r\naddr6 = (struct sockaddr_in6 *)dst_addr;\r\nip = (char *)&addr6->sin6_addr;\r\nmemcpy(ip, fw_ddb_entry->ip_addr, IPv6_ADDR_LEN);\r\naddr6->sin6_port = htons(le16_to_cpu(fw_ddb_entry->port));\r\n} else {\r\nt_addr = (struct sockaddr *)dst_addr;\r\nt_addr->sa_family = AF_INET;\r\naddr = (struct sockaddr_in *)dst_addr;\r\nip = (char *)&addr->sin_addr;\r\nmemcpy(ip, fw_ddb_entry->ip_addr, IP_ADDR_LEN);\r\naddr->sin_port = htons(le16_to_cpu(fw_ddb_entry->port));\r\n}\r\nep = qla4xxx_ep_connect(ha->host, (struct sockaddr *)dst_addr, 0);\r\nvfree(dst_addr);\r\nreturn ep;\r\n}\r\nstatic int qla4xxx_verify_boot_idx(struct scsi_qla_host *ha, uint16_t idx)\r\n{\r\nif (ql4xdisablesysfsboot)\r\nreturn QLA_SUCCESS;\r\nif (idx == ha->pri_ddb_idx || idx == ha->sec_ddb_idx)\r\nreturn QLA_ERROR;\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic void qla4xxx_setup_flash_ddb_entry(struct scsi_qla_host *ha,\r\nstruct ddb_entry *ddb_entry,\r\nuint16_t idx)\r\n{\r\nuint16_t def_timeout;\r\nddb_entry->ddb_type = FLASH_DDB;\r\nddb_entry->fw_ddb_index = INVALID_ENTRY;\r\nddb_entry->fw_ddb_device_state = DDB_DS_NO_CONNECTION_ACTIVE;\r\nddb_entry->ha = ha;\r\nddb_entry->unblock_sess = qla4xxx_unblock_flash_ddb;\r\nddb_entry->ddb_change = qla4xxx_flash_ddb_change;\r\nddb_entry->chap_tbl_idx = INVALID_ENTRY;\r\natomic_set(&ddb_entry->retry_relogin_timer, INVALID_ENTRY);\r\natomic_set(&ddb_entry->relogin_timer, 0);\r\natomic_set(&ddb_entry->relogin_retry_count, 0);\r\ndef_timeout = le16_to_cpu(ddb_entry->fw_ddb_entry.def_timeout);\r\nddb_entry->default_relogin_timeout =\r\n(def_timeout > LOGIN_TOV) && (def_timeout < LOGIN_TOV * 10) ?\r\ndef_timeout : LOGIN_TOV;\r\nddb_entry->default_time2wait =\r\nle16_to_cpu(ddb_entry->fw_ddb_entry.iscsi_def_time2wait);\r\nif (ql4xdisablesysfsboot &&\r\n(idx == ha->pri_ddb_idx || idx == ha->sec_ddb_idx))\r\nset_bit(DF_BOOT_TGT, &ddb_entry->flags);\r\n}\r\nstatic void qla4xxx_wait_for_ip_configuration(struct scsi_qla_host *ha)\r\n{\r\nuint32_t idx = 0;\r\nuint32_t ip_idx[IP_ADDR_COUNT] = {0, 1, 2, 3};\r\nuint32_t sts[MBOX_REG_COUNT];\r\nuint32_t ip_state;\r\nunsigned long wtime;\r\nint ret;\r\nwtime = jiffies + (HZ * IP_CONFIG_TOV);\r\ndo {\r\nfor (idx = 0; idx < IP_ADDR_COUNT; idx++) {\r\nif (ip_idx[idx] == -1)\r\ncontinue;\r\nret = qla4xxx_get_ip_state(ha, 0, ip_idx[idx], sts);\r\nif (ret == QLA_ERROR) {\r\nip_idx[idx] = -1;\r\ncontinue;\r\n}\r\nip_state = (sts[1] & IP_STATE_MASK) >> IP_STATE_SHIFT;\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Waiting for IP state for idx = %d, state = 0x%x\n",\r\nip_idx[idx], ip_state));\r\nif (ip_state == IP_ADDRSTATE_UNCONFIGURED ||\r\nip_state == IP_ADDRSTATE_INVALID ||\r\nip_state == IP_ADDRSTATE_PREFERRED ||\r\nip_state == IP_ADDRSTATE_DEPRICATED ||\r\nip_state == IP_ADDRSTATE_DISABLING)\r\nip_idx[idx] = -1;\r\n}\r\nif ((ip_idx[0] == -1) &&\r\n(ip_idx[1] == -1) &&\r\n(ip_idx[2] == -1) &&\r\n(ip_idx[3] == -1))\r\nbreak;\r\nschedule_timeout_uninterruptible(HZ);\r\n} while (time_after(wtime, jiffies));\r\n}\r\nstatic int qla4xxx_cmp_fw_stentry(struct dev_db_entry *fw_ddb_entry,\r\nstruct dev_db_entry *flash_ddb_entry)\r\n{\r\nuint16_t options = 0;\r\nsize_t ip_len = IP_ADDR_LEN;\r\noptions = le16_to_cpu(fw_ddb_entry->options);\r\nif (options & DDB_OPT_IPV6_DEVICE)\r\nip_len = IPv6_ADDR_LEN;\r\nif (memcmp(fw_ddb_entry->ip_addr, flash_ddb_entry->ip_addr, ip_len))\r\nreturn QLA_ERROR;\r\nif (memcmp(&fw_ddb_entry->isid[0], &flash_ddb_entry->isid[0],\r\nsizeof(fw_ddb_entry->isid)))\r\nreturn QLA_ERROR;\r\nif (memcmp(&fw_ddb_entry->port, &flash_ddb_entry->port,\r\nsizeof(fw_ddb_entry->port)))\r\nreturn QLA_ERROR;\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic int qla4xxx_find_flash_st_idx(struct scsi_qla_host *ha,\r\nstruct dev_db_entry *fw_ddb_entry,\r\nuint32_t fw_idx, uint32_t *flash_index)\r\n{\r\nstruct dev_db_entry *flash_ddb_entry;\r\ndma_addr_t flash_ddb_entry_dma;\r\nuint32_t idx = 0;\r\nint max_ddbs;\r\nint ret = QLA_ERROR, status;\r\nmax_ddbs = is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\r\nMAX_DEV_DB_ENTRIES;\r\nflash_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\r\n&flash_ddb_entry_dma);\r\nif (flash_ddb_entry == NULL || fw_ddb_entry == NULL) {\r\nql4_printk(KERN_ERR, ha, "Out of memory\n");\r\ngoto exit_find_st_idx;\r\n}\r\nstatus = qla4xxx_flashdb_by_index(ha, flash_ddb_entry,\r\nflash_ddb_entry_dma, fw_idx);\r\nif (status == QLA_SUCCESS) {\r\nstatus = qla4xxx_cmp_fw_stentry(fw_ddb_entry, flash_ddb_entry);\r\nif (status == QLA_SUCCESS) {\r\n*flash_index = fw_idx;\r\nret = QLA_SUCCESS;\r\ngoto exit_find_st_idx;\r\n}\r\n}\r\nfor (idx = 0; idx < max_ddbs; idx++) {\r\nstatus = qla4xxx_flashdb_by_index(ha, flash_ddb_entry,\r\nflash_ddb_entry_dma, idx);\r\nif (status == QLA_ERROR)\r\ncontinue;\r\nstatus = qla4xxx_cmp_fw_stentry(fw_ddb_entry, flash_ddb_entry);\r\nif (status == QLA_SUCCESS) {\r\n*flash_index = idx;\r\nret = QLA_SUCCESS;\r\ngoto exit_find_st_idx;\r\n}\r\n}\r\nif (idx == max_ddbs)\r\nql4_printk(KERN_ERR, ha, "Failed to find ST [%d] in flash\n",\r\nfw_idx);\r\nexit_find_st_idx:\r\nif (flash_ddb_entry)\r\ndma_pool_free(ha->fw_ddb_dma_pool, flash_ddb_entry,\r\nflash_ddb_entry_dma);\r\nreturn ret;\r\n}\r\nstatic void qla4xxx_build_st_list(struct scsi_qla_host *ha,\r\nstruct list_head *list_st)\r\n{\r\nstruct qla_ddb_index *st_ddb_idx;\r\nint max_ddbs;\r\nint fw_idx_size;\r\nstruct dev_db_entry *fw_ddb_entry;\r\ndma_addr_t fw_ddb_dma;\r\nint ret;\r\nuint32_t idx = 0, next_idx = 0;\r\nuint32_t state = 0, conn_err = 0;\r\nuint32_t flash_index = -1;\r\nuint16_t conn_id = 0;\r\nfw_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\r\n&fw_ddb_dma);\r\nif (fw_ddb_entry == NULL) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "Out of memory\n"));\r\ngoto exit_st_list;\r\n}\r\nmax_ddbs = is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\r\nMAX_DEV_DB_ENTRIES;\r\nfw_idx_size = sizeof(struct qla_ddb_index);\r\nfor (idx = 0; idx < max_ddbs; idx = next_idx) {\r\nret = qla4xxx_get_fwddb_entry(ha, idx, fw_ddb_entry, fw_ddb_dma,\r\nNULL, &next_idx, &state,\r\n&conn_err, NULL, &conn_id);\r\nif (ret == QLA_ERROR)\r\nbreak;\r\nif (state == DDB_DS_UNASSIGNED)\r\ngoto continue_next_st;\r\nif (strlen((char *) fw_ddb_entry->iscsi_name) != 0)\r\ngoto continue_next_st;\r\nst_ddb_idx = vzalloc(fw_idx_size);\r\nif (!st_ddb_idx)\r\nbreak;\r\nret = qla4xxx_find_flash_st_idx(ha, fw_ddb_entry, idx,\r\n&flash_index);\r\nif (ret == QLA_ERROR) {\r\nql4_printk(KERN_ERR, ha,\r\n"No flash entry for ST at idx [%d]\n", idx);\r\nst_ddb_idx->flash_ddb_idx = idx;\r\n} else {\r\nql4_printk(KERN_INFO, ha,\r\n"ST at idx [%d] is stored at flash [%d]\n",\r\nidx, flash_index);\r\nst_ddb_idx->flash_ddb_idx = flash_index;\r\n}\r\nst_ddb_idx->fw_ddb_idx = idx;\r\nlist_add_tail(&st_ddb_idx->list, list_st);\r\ncontinue_next_st:\r\nif (next_idx == 0)\r\nbreak;\r\n}\r\nexit_st_list:\r\nif (fw_ddb_entry)\r\ndma_pool_free(ha->fw_ddb_dma_pool, fw_ddb_entry, fw_ddb_dma);\r\n}\r\nstatic void qla4xxx_remove_failed_ddb(struct scsi_qla_host *ha,\r\nstruct list_head *list_ddb)\r\n{\r\nstruct qla_ddb_index *ddb_idx, *ddb_idx_tmp;\r\nuint32_t next_idx = 0;\r\nuint32_t state = 0, conn_err = 0;\r\nint ret;\r\nlist_for_each_entry_safe(ddb_idx, ddb_idx_tmp, list_ddb, list) {\r\nret = qla4xxx_get_fwddb_entry(ha, ddb_idx->fw_ddb_idx,\r\nNULL, 0, NULL, &next_idx, &state,\r\n&conn_err, NULL, NULL);\r\nif (ret == QLA_ERROR)\r\ncontinue;\r\nif (state == DDB_DS_NO_CONNECTION_ACTIVE ||\r\nstate == DDB_DS_SESSION_FAILED) {\r\nlist_del_init(&ddb_idx->list);\r\nvfree(ddb_idx);\r\n}\r\n}\r\n}\r\nstatic void qla4xxx_update_sess_disc_idx(struct scsi_qla_host *ha,\r\nstruct ddb_entry *ddb_entry,\r\nstruct dev_db_entry *fw_ddb_entry)\r\n{\r\nstruct iscsi_cls_session *cls_sess;\r\nstruct iscsi_session *sess;\r\nuint32_t max_ddbs = 0;\r\nuint16_t ddb_link = -1;\r\nmax_ddbs = is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\r\nMAX_DEV_DB_ENTRIES;\r\ncls_sess = ddb_entry->sess;\r\nsess = cls_sess->dd_data;\r\nddb_link = le16_to_cpu(fw_ddb_entry->ddb_link);\r\nif (ddb_link < max_ddbs)\r\nsess->discovery_parent_idx = ddb_link;\r\nelse\r\nsess->discovery_parent_idx = DDB_NO_LINK;\r\n}\r\nstatic int qla4xxx_sess_conn_setup(struct scsi_qla_host *ha,\r\nstruct dev_db_entry *fw_ddb_entry,\r\nint is_reset, uint16_t idx)\r\n{\r\nstruct iscsi_cls_session *cls_sess;\r\nstruct iscsi_session *sess;\r\nstruct iscsi_cls_conn *cls_conn;\r\nstruct iscsi_endpoint *ep;\r\nuint16_t cmds_max = 32;\r\nuint16_t conn_id = 0;\r\nuint32_t initial_cmdsn = 0;\r\nint ret = QLA_SUCCESS;\r\nstruct ddb_entry *ddb_entry = NULL;\r\ncls_sess = iscsi_session_setup(&qla4xxx_iscsi_transport, ha->host,\r\ncmds_max, sizeof(struct ddb_entry),\r\nsizeof(struct ql4_task_data),\r\ninitial_cmdsn, INVALID_ENTRY);\r\nif (!cls_sess) {\r\nret = QLA_ERROR;\r\ngoto exit_setup;\r\n}\r\nmodule_put(qla4xxx_iscsi_transport.owner);\r\nsess = cls_sess->dd_data;\r\nddb_entry = sess->dd_data;\r\nddb_entry->sess = cls_sess;\r\ncls_sess->recovery_tmo = ql4xsess_recovery_tmo;\r\nmemcpy(&ddb_entry->fw_ddb_entry, fw_ddb_entry,\r\nsizeof(struct dev_db_entry));\r\nqla4xxx_setup_flash_ddb_entry(ha, ddb_entry, idx);\r\ncls_conn = iscsi_conn_setup(cls_sess, sizeof(struct qla_conn), conn_id);\r\nif (!cls_conn) {\r\nret = QLA_ERROR;\r\ngoto exit_setup;\r\n}\r\nddb_entry->conn = cls_conn;\r\nep = qla4xxx_get_ep_fwdb(ha, fw_ddb_entry);\r\nif (ep) {\r\nep->conn = cls_conn;\r\ncls_conn->ep = ep;\r\n} else {\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "Unable to get ep\n"));\r\nret = QLA_ERROR;\r\ngoto exit_setup;\r\n}\r\nqla4xxx_copy_fwddb_param(ha, fw_ddb_entry, cls_sess, cls_conn);\r\nqla4xxx_update_sess_disc_idx(ha, ddb_entry, fw_ddb_entry);\r\nif (is_reset == RESET_ADAPTER) {\r\niscsi_block_session(cls_sess);\r\nset_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags);\r\nset_bit(DF_RELOGIN, &ddb_entry->flags);\r\n}\r\nexit_setup:\r\nreturn ret;\r\n}\r\nstatic void qla4xxx_update_fw_ddb_link(struct scsi_qla_host *ha,\r\nstruct list_head *list_ddb,\r\nstruct dev_db_entry *fw_ddb_entry)\r\n{\r\nstruct qla_ddb_index *ddb_idx, *ddb_idx_tmp;\r\nuint16_t ddb_link;\r\nddb_link = le16_to_cpu(fw_ddb_entry->ddb_link);\r\nlist_for_each_entry_safe(ddb_idx, ddb_idx_tmp, list_ddb, list) {\r\nif (ddb_idx->fw_ddb_idx == ddb_link) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Updating NT parent idx from [%d] to [%d]\n",\r\nddb_link, ddb_idx->flash_ddb_idx));\r\nfw_ddb_entry->ddb_link =\r\ncpu_to_le16(ddb_idx->flash_ddb_idx);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void qla4xxx_build_nt_list(struct scsi_qla_host *ha,\r\nstruct list_head *list_nt,\r\nstruct list_head *list_st,\r\nint is_reset)\r\n{\r\nstruct dev_db_entry *fw_ddb_entry;\r\nstruct ddb_entry *ddb_entry = NULL;\r\ndma_addr_t fw_ddb_dma;\r\nint max_ddbs;\r\nint fw_idx_size;\r\nint ret;\r\nuint32_t idx = 0, next_idx = 0;\r\nuint32_t state = 0, conn_err = 0;\r\nuint32_t ddb_idx = -1;\r\nuint16_t conn_id = 0;\r\nuint16_t ddb_link = -1;\r\nstruct qla_ddb_index *nt_ddb_idx;\r\nfw_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\r\n&fw_ddb_dma);\r\nif (fw_ddb_entry == NULL) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "Out of memory\n"));\r\ngoto exit_nt_list;\r\n}\r\nmax_ddbs = is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\r\nMAX_DEV_DB_ENTRIES;\r\nfw_idx_size = sizeof(struct qla_ddb_index);\r\nfor (idx = 0; idx < max_ddbs; idx = next_idx) {\r\nret = qla4xxx_get_fwddb_entry(ha, idx, fw_ddb_entry, fw_ddb_dma,\r\nNULL, &next_idx, &state,\r\n&conn_err, NULL, &conn_id);\r\nif (ret == QLA_ERROR)\r\nbreak;\r\nif (qla4xxx_verify_boot_idx(ha, idx) != QLA_SUCCESS)\r\ngoto continue_next_nt;\r\nif (strlen((char *) fw_ddb_entry->iscsi_name) == 0)\r\ngoto continue_next_nt;\r\nddb_link = le16_to_cpu(fw_ddb_entry->ddb_link);\r\nif (ddb_link < max_ddbs)\r\nqla4xxx_update_fw_ddb_link(ha, list_st, fw_ddb_entry);\r\nif (!(state == DDB_DS_NO_CONNECTION_ACTIVE ||\r\nstate == DDB_DS_SESSION_FAILED) &&\r\n(is_reset == INIT_ADAPTER))\r\ngoto continue_next_nt;\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Adding DDB to session = 0x%x\n", idx));\r\nif (is_reset == INIT_ADAPTER) {\r\nnt_ddb_idx = vmalloc(fw_idx_size);\r\nif (!nt_ddb_idx)\r\nbreak;\r\nnt_ddb_idx->fw_ddb_idx = idx;\r\nmemcpy(&nt_ddb_idx->flash_isid[0],\r\n&fw_ddb_entry->isid[0],\r\nsizeof(nt_ddb_idx->flash_isid));\r\nret = qla4xxx_is_flash_ddb_exists(ha, list_nt,\r\nfw_ddb_entry);\r\nif (ret == QLA_SUCCESS) {\r\nvfree(nt_ddb_idx);\r\ngoto continue_next_nt;\r\n}\r\nmemcpy(&nt_ddb_idx->fw_ddb, fw_ddb_entry,\r\nsizeof(struct dev_db_entry));\r\nlist_add_tail(&nt_ddb_idx->list, list_nt);\r\n} else if (is_reset == RESET_ADAPTER) {\r\nret = qla4xxx_is_session_exists(ha, fw_ddb_entry,\r\n&ddb_idx);\r\nif (ret == QLA_SUCCESS) {\r\nddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha,\r\nddb_idx);\r\nif (ddb_entry != NULL)\r\nqla4xxx_update_sess_disc_idx(ha,\r\nddb_entry,\r\nfw_ddb_entry);\r\ngoto continue_next_nt;\r\n}\r\n}\r\nret = qla4xxx_sess_conn_setup(ha, fw_ddb_entry, is_reset, idx);\r\nif (ret == QLA_ERROR)\r\ngoto exit_nt_list;\r\ncontinue_next_nt:\r\nif (next_idx == 0)\r\nbreak;\r\n}\r\nexit_nt_list:\r\nif (fw_ddb_entry)\r\ndma_pool_free(ha->fw_ddb_dma_pool, fw_ddb_entry, fw_ddb_dma);\r\n}\r\nstatic void qla4xxx_build_new_nt_list(struct scsi_qla_host *ha,\r\nstruct list_head *list_nt,\r\nuint16_t target_id)\r\n{\r\nstruct dev_db_entry *fw_ddb_entry;\r\ndma_addr_t fw_ddb_dma;\r\nint max_ddbs;\r\nint fw_idx_size;\r\nint ret;\r\nuint32_t idx = 0, next_idx = 0;\r\nuint32_t state = 0, conn_err = 0;\r\nuint16_t conn_id = 0;\r\nstruct qla_ddb_index *nt_ddb_idx;\r\nfw_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\r\n&fw_ddb_dma);\r\nif (fw_ddb_entry == NULL) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "Out of memory\n"));\r\ngoto exit_new_nt_list;\r\n}\r\nmax_ddbs = is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\r\nMAX_DEV_DB_ENTRIES;\r\nfw_idx_size = sizeof(struct qla_ddb_index);\r\nfor (idx = 0; idx < max_ddbs; idx = next_idx) {\r\nret = qla4xxx_get_fwddb_entry(ha, idx, fw_ddb_entry, fw_ddb_dma,\r\nNULL, &next_idx, &state,\r\n&conn_err, NULL, &conn_id);\r\nif (ret == QLA_ERROR)\r\nbreak;\r\nif (strlen((char *)fw_ddb_entry->iscsi_name) == 0)\r\ngoto continue_next_new_nt;\r\nif (!(state == DDB_DS_NO_CONNECTION_ACTIVE))\r\ngoto continue_next_new_nt;\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Adding DDB to session = 0x%x\n", idx));\r\nnt_ddb_idx = vmalloc(fw_idx_size);\r\nif (!nt_ddb_idx)\r\nbreak;\r\nnt_ddb_idx->fw_ddb_idx = idx;\r\nret = qla4xxx_is_session_exists(ha, fw_ddb_entry, NULL);\r\nif (ret == QLA_SUCCESS) {\r\nvfree(nt_ddb_idx);\r\ngoto continue_next_new_nt;\r\n}\r\nif (target_id < max_ddbs)\r\nfw_ddb_entry->ddb_link = cpu_to_le16(target_id);\r\nlist_add_tail(&nt_ddb_idx->list, list_nt);\r\nret = qla4xxx_sess_conn_setup(ha, fw_ddb_entry, RESET_ADAPTER,\r\nidx);\r\nif (ret == QLA_ERROR)\r\ngoto exit_new_nt_list;\r\ncontinue_next_new_nt:\r\nif (next_idx == 0)\r\nbreak;\r\n}\r\nexit_new_nt_list:\r\nif (fw_ddb_entry)\r\ndma_pool_free(ha->fw_ddb_dma_pool, fw_ddb_entry, fw_ddb_dma);\r\n}\r\nstatic int qla4xxx_sysfs_ddb_is_non_persistent(struct device *dev, void *data)\r\n{\r\nstruct iscsi_bus_flash_session *fnode_sess;\r\nif (!iscsi_flashnode_bus_match(dev, NULL))\r\nreturn 0;\r\nfnode_sess = iscsi_dev_to_flash_session(dev);\r\nreturn (fnode_sess->flash_state == DEV_DB_NON_PERSISTENT);\r\n}\r\nstatic int qla4xxx_sysfs_ddb_tgt_create(struct scsi_qla_host *ha,\r\nstruct dev_db_entry *fw_ddb_entry,\r\nuint16_t *idx, int user)\r\n{\r\nstruct iscsi_bus_flash_session *fnode_sess = NULL;\r\nstruct iscsi_bus_flash_conn *fnode_conn = NULL;\r\nint rc = QLA_ERROR;\r\nfnode_sess = iscsi_create_flashnode_sess(ha->host, *idx,\r\n&qla4xxx_iscsi_transport, 0);\r\nif (!fnode_sess) {\r\nql4_printk(KERN_ERR, ha,\r\n"%s: Unable to create session sysfs entry for flashnode %d of host%lu\n",\r\n__func__, *idx, ha->host_no);\r\ngoto exit_tgt_create;\r\n}\r\nfnode_conn = iscsi_create_flashnode_conn(ha->host, fnode_sess,\r\n&qla4xxx_iscsi_transport, 0);\r\nif (!fnode_conn) {\r\nql4_printk(KERN_ERR, ha,\r\n"%s: Unable to create conn sysfs entry for flashnode %d of host%lu\n",\r\n__func__, *idx, ha->host_no);\r\ngoto free_sess;\r\n}\r\nif (user) {\r\nfnode_sess->flash_state = DEV_DB_NON_PERSISTENT;\r\n} else {\r\nfnode_sess->flash_state = DEV_DB_PERSISTENT;\r\nif (*idx == ha->pri_ddb_idx || *idx == ha->sec_ddb_idx)\r\nfnode_sess->is_boot_target = 1;\r\nelse\r\nfnode_sess->is_boot_target = 0;\r\n}\r\nrc = qla4xxx_copy_from_fwddb_param(fnode_sess, fnode_conn,\r\nfw_ddb_entry);\r\nql4_printk(KERN_INFO, ha, "%s: sysfs entry %s created\n",\r\n__func__, fnode_sess->dev.kobj.name);\r\nql4_printk(KERN_INFO, ha, "%s: sysfs entry %s created\n",\r\n__func__, fnode_conn->dev.kobj.name);\r\nreturn QLA_SUCCESS;\r\nfree_sess:\r\niscsi_destroy_flashnode_sess(fnode_sess);\r\nexit_tgt_create:\r\nreturn QLA_ERROR;\r\n}\r\nstatic int qla4xxx_sysfs_ddb_add(struct Scsi_Host *shost, const char *buf,\r\nint len)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nstruct dev_db_entry *fw_ddb_entry = NULL;\r\ndma_addr_t fw_ddb_entry_dma;\r\nstruct device *dev;\r\nuint16_t idx = 0;\r\nuint16_t max_ddbs = 0;\r\nuint32_t options = 0;\r\nuint32_t rval = QLA_ERROR;\r\nif (strncasecmp(PORTAL_TYPE_IPV4, buf, 4) &&\r\nstrncasecmp(PORTAL_TYPE_IPV6, buf, 4)) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "%s: Invalid portal type\n",\r\n__func__));\r\ngoto exit_ddb_add;\r\n}\r\nmax_ddbs = is_qla40XX(ha) ? MAX_PRST_DEV_DB_ENTRIES :\r\nMAX_DEV_DB_ENTRIES;\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (!fw_ddb_entry) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer\n",\r\n__func__));\r\ngoto exit_ddb_add;\r\n}\r\ndev = iscsi_find_flashnode_sess(ha->host, NULL,\r\nqla4xxx_sysfs_ddb_is_non_persistent);\r\nif (dev) {\r\nql4_printk(KERN_ERR, ha,\r\n"%s: A non-persistent entry %s found\n",\r\n__func__, dev->kobj.name);\r\nput_device(dev);\r\ngoto exit_ddb_add;\r\n}\r\nfor (idx = 2; idx < max_ddbs; idx++) {\r\nif (qla4xxx_flashdb_by_index(ha, fw_ddb_entry,\r\nfw_ddb_entry_dma, idx))\r\nbreak;\r\n}\r\nif (idx == max_ddbs)\r\ngoto exit_ddb_add;\r\nif (!strncasecmp("ipv6", buf, 4))\r\noptions |= IPV6_DEFAULT_DDB_ENTRY;\r\nrval = qla4xxx_get_default_ddb(ha, options, fw_ddb_entry_dma);\r\nif (rval == QLA_ERROR)\r\ngoto exit_ddb_add;\r\nrval = qla4xxx_sysfs_ddb_tgt_create(ha, fw_ddb_entry, &idx, 1);\r\nexit_ddb_add:\r\nif (fw_ddb_entry)\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\nfw_ddb_entry, fw_ddb_entry_dma);\r\nif (rval == QLA_SUCCESS)\r\nreturn idx;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int qla4xxx_sysfs_ddb_apply(struct iscsi_bus_flash_session *fnode_sess,\r\nstruct iscsi_bus_flash_conn *fnode_conn)\r\n{\r\nstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nuint32_t dev_db_start_offset = FLASH_OFFSET_DB_INFO;\r\nstruct dev_db_entry *fw_ddb_entry = NULL;\r\ndma_addr_t fw_ddb_entry_dma;\r\nuint32_t options = 0;\r\nint rval = 0;\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (!fw_ddb_entry) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer\n",\r\n__func__));\r\nrval = -ENOMEM;\r\ngoto exit_ddb_apply;\r\n}\r\nif (!strncasecmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\r\noptions |= IPV6_DEFAULT_DDB_ENTRY;\r\nrval = qla4xxx_get_default_ddb(ha, options, fw_ddb_entry_dma);\r\nif (rval == QLA_ERROR)\r\ngoto exit_ddb_apply;\r\ndev_db_start_offset += (fnode_sess->target_id *\r\nsizeof(*fw_ddb_entry));\r\nqla4xxx_copy_to_fwddb_param(fnode_sess, fnode_conn, fw_ddb_entry);\r\nfw_ddb_entry->cookie = DDB_VALID_COOKIE;\r\nrval = qla4xxx_set_flash(ha, fw_ddb_entry_dma, dev_db_start_offset,\r\nsizeof(*fw_ddb_entry), FLASH_OPT_RMW_COMMIT);\r\nif (rval == QLA_SUCCESS) {\r\nfnode_sess->flash_state = DEV_DB_PERSISTENT;\r\nql4_printk(KERN_INFO, ha,\r\n"%s: flash node %u of host %lu written to flash\n",\r\n__func__, fnode_sess->target_id, ha->host_no);\r\n} else {\r\nrval = -EIO;\r\nql4_printk(KERN_ERR, ha,\r\n"%s: Error while writing flash node %u of host %lu to flash\n",\r\n__func__, fnode_sess->target_id, ha->host_no);\r\n}\r\nexit_ddb_apply:\r\nif (fw_ddb_entry)\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\nfw_ddb_entry, fw_ddb_entry_dma);\r\nreturn rval;\r\n}\r\nstatic ssize_t qla4xxx_sysfs_ddb_conn_open(struct scsi_qla_host *ha,\r\nstruct dev_db_entry *fw_ddb_entry,\r\nuint16_t idx)\r\n{\r\nstruct dev_db_entry *ddb_entry = NULL;\r\ndma_addr_t ddb_entry_dma;\r\nunsigned long wtime;\r\nuint32_t mbx_sts = 0;\r\nuint32_t state = 0, conn_err = 0;\r\nuint16_t tmo = 0;\r\nint ret = 0;\r\nddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*ddb_entry),\r\n&ddb_entry_dma, GFP_KERNEL);\r\nif (!ddb_entry) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer\n",\r\n__func__));\r\nreturn QLA_ERROR;\r\n}\r\nmemcpy(ddb_entry, fw_ddb_entry, sizeof(*ddb_entry));\r\nret = qla4xxx_set_ddb_entry(ha, idx, ddb_entry_dma, &mbx_sts);\r\nif (ret != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha,\r\n"%s: Unable to set ddb entry for index %d\n",\r\n__func__, idx));\r\ngoto exit_ddb_conn_open;\r\n}\r\nqla4xxx_conn_open(ha, idx);\r\ntmo = ((ha->def_timeout > LOGIN_TOV) &&\r\n(ha->def_timeout < LOGIN_TOV * 10) ?\r\nha->def_timeout : LOGIN_TOV);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Default time to wait for login to ddb %d\n", tmo));\r\nwtime = jiffies + (HZ * tmo);\r\ndo {\r\nret = qla4xxx_get_fwddb_entry(ha, idx, NULL, 0, NULL,\r\nNULL, &state, &conn_err, NULL,\r\nNULL);\r\nif (ret == QLA_ERROR)\r\ncontinue;\r\nif (state == DDB_DS_NO_CONNECTION_ACTIVE ||\r\nstate == DDB_DS_SESSION_FAILED)\r\nbreak;\r\nschedule_timeout_uninterruptible(HZ / 10);\r\n} while (time_after(wtime, jiffies));\r\nexit_ddb_conn_open:\r\nif (ddb_entry)\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*ddb_entry),\r\nddb_entry, ddb_entry_dma);\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_ddb_login_st(struct scsi_qla_host *ha,\r\nstruct dev_db_entry *fw_ddb_entry,\r\nuint16_t target_id)\r\n{\r\nstruct qla_ddb_index *ddb_idx, *ddb_idx_tmp;\r\nstruct list_head list_nt;\r\nuint16_t ddb_index;\r\nint ret = 0;\r\nif (test_bit(AF_ST_DISCOVERY_IN_PROGRESS, &ha->flags)) {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s: A discovery already in progress!\n", __func__);\r\nreturn QLA_ERROR;\r\n}\r\nINIT_LIST_HEAD(&list_nt);\r\nset_bit(AF_ST_DISCOVERY_IN_PROGRESS, &ha->flags);\r\nret = qla4xxx_get_ddb_index(ha, &ddb_index);\r\nif (ret == QLA_ERROR)\r\ngoto exit_login_st_clr_bit;\r\nret = qla4xxx_sysfs_ddb_conn_open(ha, fw_ddb_entry, ddb_index);\r\nif (ret == QLA_ERROR)\r\ngoto exit_login_st;\r\nqla4xxx_build_new_nt_list(ha, &list_nt, target_id);\r\nlist_for_each_entry_safe(ddb_idx, ddb_idx_tmp, &list_nt, list) {\r\nlist_del_init(&ddb_idx->list);\r\nqla4xxx_clear_ddb_entry(ha, ddb_idx->fw_ddb_idx);\r\nvfree(ddb_idx);\r\n}\r\nexit_login_st:\r\nif (qla4xxx_clear_ddb_entry(ha, ddb_index) == QLA_ERROR) {\r\nql4_printk(KERN_ERR, ha,\r\n"Unable to clear DDB index = 0x%x\n", ddb_index);\r\n}\r\nclear_bit(ddb_index, ha->ddb_idx_map);\r\nexit_login_st_clr_bit:\r\nclear_bit(AF_ST_DISCOVERY_IN_PROGRESS, &ha->flags);\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_ddb_login_nt(struct scsi_qla_host *ha,\r\nstruct dev_db_entry *fw_ddb_entry,\r\nuint16_t idx)\r\n{\r\nint ret = QLA_ERROR;\r\nret = qla4xxx_is_session_exists(ha, fw_ddb_entry, NULL);\r\nif (ret != QLA_SUCCESS)\r\nret = qla4xxx_sess_conn_setup(ha, fw_ddb_entry, RESET_ADAPTER,\r\nidx);\r\nelse\r\nret = -EPERM;\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_sysfs_ddb_login(struct iscsi_bus_flash_session *fnode_sess,\r\nstruct iscsi_bus_flash_conn *fnode_conn)\r\n{\r\nstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nstruct dev_db_entry *fw_ddb_entry = NULL;\r\ndma_addr_t fw_ddb_entry_dma;\r\nuint32_t options = 0;\r\nint ret = 0;\r\nif (fnode_sess->flash_state == DEV_DB_NON_PERSISTENT) {\r\nql4_printk(KERN_ERR, ha,\r\n"%s: Target info is not persistent\n", __func__);\r\nret = -EIO;\r\ngoto exit_ddb_login;\r\n}\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (!fw_ddb_entry) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer\n",\r\n__func__));\r\nret = -ENOMEM;\r\ngoto exit_ddb_login;\r\n}\r\nif (!strncasecmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\r\noptions |= IPV6_DEFAULT_DDB_ENTRY;\r\nret = qla4xxx_get_default_ddb(ha, options, fw_ddb_entry_dma);\r\nif (ret == QLA_ERROR)\r\ngoto exit_ddb_login;\r\nqla4xxx_copy_to_fwddb_param(fnode_sess, fnode_conn, fw_ddb_entry);\r\nfw_ddb_entry->cookie = DDB_VALID_COOKIE;\r\nif (strlen((char *)fw_ddb_entry->iscsi_name) == 0)\r\nret = qla4xxx_ddb_login_st(ha, fw_ddb_entry,\r\nfnode_sess->target_id);\r\nelse\r\nret = qla4xxx_ddb_login_nt(ha, fw_ddb_entry,\r\nfnode_sess->target_id);\r\nif (ret > 0)\r\nret = -EIO;\r\nexit_ddb_login:\r\nif (fw_ddb_entry)\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\nfw_ddb_entry, fw_ddb_entry_dma);\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_sysfs_ddb_logout_sid(struct iscsi_cls_session *cls_sess)\r\n{\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb_entry = NULL;\r\nstruct scsi_qla_host *ha;\r\nstruct dev_db_entry *fw_ddb_entry = NULL;\r\ndma_addr_t fw_ddb_entry_dma;\r\nunsigned long flags;\r\nunsigned long wtime;\r\nuint32_t ddb_state;\r\nint options;\r\nint ret = 0;\r\nsess = cls_sess->dd_data;\r\nddb_entry = sess->dd_data;\r\nha = ddb_entry->ha;\r\nif (ddb_entry->ddb_type != FLASH_DDB) {\r\nql4_printk(KERN_ERR, ha, "%s: Not a flash node session\n",\r\n__func__);\r\nret = -ENXIO;\r\ngoto exit_ddb_logout;\r\n}\r\nif (test_bit(DF_BOOT_TGT, &ddb_entry->flags)) {\r\nql4_printk(KERN_ERR, ha,\r\n"%s: Logout from boot target entry is not permitted.\n",\r\n__func__);\r\nret = -EPERM;\r\ngoto exit_ddb_logout;\r\n}\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (!fw_ddb_entry) {\r\nql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer\n", __func__);\r\nret = -ENOMEM;\r\ngoto exit_ddb_logout;\r\n}\r\nif (test_and_set_bit(DF_DISABLE_RELOGIN, &ddb_entry->flags))\r\ngoto ddb_logout_init;\r\nret = qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index,\r\nfw_ddb_entry, fw_ddb_entry_dma,\r\nNULL, NULL, &ddb_state, NULL,\r\nNULL, NULL);\r\nif (ret == QLA_ERROR)\r\ngoto ddb_logout_init;\r\nif (ddb_state == DDB_DS_SESSION_ACTIVE)\r\ngoto ddb_logout_init;\r\nwtime = jiffies + (HZ * RELOGIN_TOV);\r\ndo {\r\nif (test_and_clear_bit(DF_RELOGIN, &ddb_entry->flags))\r\ngoto ddb_logout_init;\r\nschedule_timeout_uninterruptible(HZ);\r\n} while ((time_after(wtime, jiffies)));\r\nddb_logout_init:\r\natomic_set(&ddb_entry->retry_relogin_timer, INVALID_ENTRY);\r\natomic_set(&ddb_entry->relogin_timer, 0);\r\noptions = LOGOUT_OPTION_CLOSE_SESSION;\r\nqla4xxx_session_logout_ddb(ha, ddb_entry, options);\r\nmemset(fw_ddb_entry, 0, sizeof(*fw_ddb_entry));\r\nwtime = jiffies + (HZ * LOGOUT_TOV);\r\ndo {\r\nret = qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index,\r\nfw_ddb_entry, fw_ddb_entry_dma,\r\nNULL, NULL, &ddb_state, NULL,\r\nNULL, NULL);\r\nif (ret == QLA_ERROR)\r\ngoto ddb_logout_clr_sess;\r\nif ((ddb_state == DDB_DS_NO_CONNECTION_ACTIVE) ||\r\n(ddb_state == DDB_DS_SESSION_FAILED))\r\ngoto ddb_logout_clr_sess;\r\nschedule_timeout_uninterruptible(HZ);\r\n} while ((time_after(wtime, jiffies)));\r\nddb_logout_clr_sess:\r\nqla4xxx_clear_ddb_entry(ha, ddb_entry->fw_ddb_index);\r\ntry_module_get(qla4xxx_iscsi_transport.owner);\r\niscsi_destroy_endpoint(ddb_entry->conn->ep);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nqla4xxx_free_ddb(ha, ddb_entry);\r\nclear_bit(ddb_entry->fw_ddb_index, ha->ddb_idx_map);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\niscsi_session_teardown(ddb_entry->sess);\r\nclear_bit(DF_DISABLE_RELOGIN, &ddb_entry->flags);\r\nret = QLA_SUCCESS;\r\nexit_ddb_logout:\r\nif (fw_ddb_entry)\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\nfw_ddb_entry, fw_ddb_entry_dma);\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_sysfs_ddb_logout(struct iscsi_bus_flash_session *fnode_sess,\r\nstruct iscsi_bus_flash_conn *fnode_conn)\r\n{\r\nstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nstruct ql4_tuple_ddb *flash_tddb = NULL;\r\nstruct ql4_tuple_ddb *tmp_tddb = NULL;\r\nstruct dev_db_entry *fw_ddb_entry = NULL;\r\nstruct ddb_entry *ddb_entry = NULL;\r\ndma_addr_t fw_ddb_dma;\r\nuint32_t next_idx = 0;\r\nuint32_t state = 0, conn_err = 0;\r\nuint16_t conn_id = 0;\r\nint idx, index;\r\nint status, ret = 0;\r\nfw_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\r\n&fw_ddb_dma);\r\nif (fw_ddb_entry == NULL) {\r\nql4_printk(KERN_ERR, ha, "%s:Out of memory\n", __func__);\r\nret = -ENOMEM;\r\ngoto exit_ddb_logout;\r\n}\r\nflash_tddb = vzalloc(sizeof(*flash_tddb));\r\nif (!flash_tddb) {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s:Memory Allocation failed.\n", __func__);\r\nret = -ENOMEM;\r\ngoto exit_ddb_logout;\r\n}\r\ntmp_tddb = vzalloc(sizeof(*tmp_tddb));\r\nif (!tmp_tddb) {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s:Memory Allocation failed.\n", __func__);\r\nret = -ENOMEM;\r\ngoto exit_ddb_logout;\r\n}\r\nif (!fnode_sess->targetname) {\r\nql4_printk(KERN_ERR, ha,\r\n"%s:Cannot logout from SendTarget entry\n",\r\n__func__);\r\nret = -EPERM;\r\ngoto exit_ddb_logout;\r\n}\r\nif (fnode_sess->is_boot_target) {\r\nql4_printk(KERN_ERR, ha,\r\n"%s: Logout from boot target entry is not permitted.\n",\r\n__func__);\r\nret = -EPERM;\r\ngoto exit_ddb_logout;\r\n}\r\nstrlcpy(flash_tddb->iscsi_name, fnode_sess->targetname,\r\nISCSI_NAME_SIZE);\r\nif (!strncmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\r\nsprintf(flash_tddb->ip_addr, "%pI6", fnode_conn->ipaddress);\r\nelse\r\nsprintf(flash_tddb->ip_addr, "%pI4", fnode_conn->ipaddress);\r\nflash_tddb->tpgt = fnode_sess->tpgt;\r\nflash_tddb->port = fnode_conn->port;\r\nCOPY_ISID(flash_tddb->isid, fnode_sess->isid);\r\nfor (idx = 0; idx < MAX_DDB_ENTRIES; idx++) {\r\nddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\r\nif (ddb_entry == NULL)\r\ncontinue;\r\nif (ddb_entry->ddb_type != FLASH_DDB)\r\ncontinue;\r\nindex = ddb_entry->sess->target_id;\r\nstatus = qla4xxx_get_fwddb_entry(ha, index, fw_ddb_entry,\r\nfw_ddb_dma, NULL, &next_idx,\r\n&state, &conn_err, NULL,\r\n&conn_id);\r\nif (status == QLA_ERROR) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nqla4xxx_convert_param_ddb(fw_ddb_entry, tmp_tddb, NULL);\r\nstatus = qla4xxx_compare_tuple_ddb(ha, flash_tddb, tmp_tddb,\r\ntrue);\r\nif (status == QLA_SUCCESS) {\r\nret = qla4xxx_sysfs_ddb_logout_sid(ddb_entry->sess);\r\nbreak;\r\n}\r\n}\r\nif (idx == MAX_DDB_ENTRIES)\r\nret = -ESRCH;\r\nexit_ddb_logout:\r\nif (flash_tddb)\r\nvfree(flash_tddb);\r\nif (tmp_tddb)\r\nvfree(tmp_tddb);\r\nif (fw_ddb_entry)\r\ndma_pool_free(ha->fw_ddb_dma_pool, fw_ddb_entry, fw_ddb_dma);\r\nreturn ret;\r\n}\r\nstatic int\r\nqla4xxx_sysfs_ddb_get_param(struct iscsi_bus_flash_session *fnode_sess,\r\nint param, char *buf)\r\n{\r\nstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nstruct iscsi_bus_flash_conn *fnode_conn;\r\nstruct ql4_chap_table chap_tbl;\r\nstruct device *dev;\r\nint parent_type;\r\nint rc = 0;\r\ndev = iscsi_find_flashnode_conn(fnode_sess);\r\nif (!dev)\r\nreturn -EIO;\r\nfnode_conn = iscsi_dev_to_flash_conn(dev);\r\nswitch (param) {\r\ncase ISCSI_FLASHNODE_IS_FW_ASSIGNED_IPV6:\r\nrc = sprintf(buf, "%u\n", fnode_conn->is_fw_assigned_ipv6);\r\nbreak;\r\ncase ISCSI_FLASHNODE_PORTAL_TYPE:\r\nrc = sprintf(buf, "%s\n", fnode_sess->portal_type);\r\nbreak;\r\ncase ISCSI_FLASHNODE_AUTO_SND_TGT_DISABLE:\r\nrc = sprintf(buf, "%u\n", fnode_sess->auto_snd_tgt_disable);\r\nbreak;\r\ncase ISCSI_FLASHNODE_DISCOVERY_SESS:\r\nrc = sprintf(buf, "%u\n", fnode_sess->discovery_sess);\r\nbreak;\r\ncase ISCSI_FLASHNODE_ENTRY_EN:\r\nrc = sprintf(buf, "%u\n", fnode_sess->entry_state);\r\nbreak;\r\ncase ISCSI_FLASHNODE_HDR_DGST_EN:\r\nrc = sprintf(buf, "%u\n", fnode_conn->hdrdgst_en);\r\nbreak;\r\ncase ISCSI_FLASHNODE_DATA_DGST_EN:\r\nrc = sprintf(buf, "%u\n", fnode_conn->datadgst_en);\r\nbreak;\r\ncase ISCSI_FLASHNODE_IMM_DATA_EN:\r\nrc = sprintf(buf, "%u\n", fnode_sess->imm_data_en);\r\nbreak;\r\ncase ISCSI_FLASHNODE_INITIAL_R2T_EN:\r\nrc = sprintf(buf, "%u\n", fnode_sess->initial_r2t_en);\r\nbreak;\r\ncase ISCSI_FLASHNODE_DATASEQ_INORDER:\r\nrc = sprintf(buf, "%u\n", fnode_sess->dataseq_inorder_en);\r\nbreak;\r\ncase ISCSI_FLASHNODE_PDU_INORDER:\r\nrc = sprintf(buf, "%u\n", fnode_sess->pdu_inorder_en);\r\nbreak;\r\ncase ISCSI_FLASHNODE_CHAP_AUTH_EN:\r\nrc = sprintf(buf, "%u\n", fnode_sess->chap_auth_en);\r\nbreak;\r\ncase ISCSI_FLASHNODE_SNACK_REQ_EN:\r\nrc = sprintf(buf, "%u\n", fnode_conn->snack_req_en);\r\nbreak;\r\ncase ISCSI_FLASHNODE_DISCOVERY_LOGOUT_EN:\r\nrc = sprintf(buf, "%u\n", fnode_sess->discovery_logout_en);\r\nbreak;\r\ncase ISCSI_FLASHNODE_BIDI_CHAP_EN:\r\nrc = sprintf(buf, "%u\n", fnode_sess->bidi_chap_en);\r\nbreak;\r\ncase ISCSI_FLASHNODE_DISCOVERY_AUTH_OPTIONAL:\r\nrc = sprintf(buf, "%u\n", fnode_sess->discovery_auth_optional);\r\nbreak;\r\ncase ISCSI_FLASHNODE_ERL:\r\nrc = sprintf(buf, "%u\n", fnode_sess->erl);\r\nbreak;\r\ncase ISCSI_FLASHNODE_TCP_TIMESTAMP_STAT:\r\nrc = sprintf(buf, "%u\n", fnode_conn->tcp_timestamp_stat);\r\nbreak;\r\ncase ISCSI_FLASHNODE_TCP_NAGLE_DISABLE:\r\nrc = sprintf(buf, "%u\n", fnode_conn->tcp_nagle_disable);\r\nbreak;\r\ncase ISCSI_FLASHNODE_TCP_WSF_DISABLE:\r\nrc = sprintf(buf, "%u\n", fnode_conn->tcp_wsf_disable);\r\nbreak;\r\ncase ISCSI_FLASHNODE_TCP_TIMER_SCALE:\r\nrc = sprintf(buf, "%u\n", fnode_conn->tcp_timer_scale);\r\nbreak;\r\ncase ISCSI_FLASHNODE_TCP_TIMESTAMP_EN:\r\nrc = sprintf(buf, "%u\n", fnode_conn->tcp_timestamp_en);\r\nbreak;\r\ncase ISCSI_FLASHNODE_IP_FRAG_DISABLE:\r\nrc = sprintf(buf, "%u\n", fnode_conn->fragment_disable);\r\nbreak;\r\ncase ISCSI_FLASHNODE_MAX_RECV_DLENGTH:\r\nrc = sprintf(buf, "%u\n", fnode_conn->max_recv_dlength);\r\nbreak;\r\ncase ISCSI_FLASHNODE_MAX_XMIT_DLENGTH:\r\nrc = sprintf(buf, "%u\n", fnode_conn->max_xmit_dlength);\r\nbreak;\r\ncase ISCSI_FLASHNODE_FIRST_BURST:\r\nrc = sprintf(buf, "%u\n", fnode_sess->first_burst);\r\nbreak;\r\ncase ISCSI_FLASHNODE_DEF_TIME2WAIT:\r\nrc = sprintf(buf, "%u\n", fnode_sess->time2wait);\r\nbreak;\r\ncase ISCSI_FLASHNODE_DEF_TIME2RETAIN:\r\nrc = sprintf(buf, "%u\n", fnode_sess->time2retain);\r\nbreak;\r\ncase ISCSI_FLASHNODE_MAX_R2T:\r\nrc = sprintf(buf, "%u\n", fnode_sess->max_r2t);\r\nbreak;\r\ncase ISCSI_FLASHNODE_KEEPALIVE_TMO:\r\nrc = sprintf(buf, "%u\n", fnode_conn->keepalive_timeout);\r\nbreak;\r\ncase ISCSI_FLASHNODE_ISID:\r\nrc = sprintf(buf, "%pm\n", fnode_sess->isid);\r\nbreak;\r\ncase ISCSI_FLASHNODE_TSID:\r\nrc = sprintf(buf, "%u\n", fnode_sess->tsid);\r\nbreak;\r\ncase ISCSI_FLASHNODE_PORT:\r\nrc = sprintf(buf, "%d\n", fnode_conn->port);\r\nbreak;\r\ncase ISCSI_FLASHNODE_MAX_BURST:\r\nrc = sprintf(buf, "%u\n", fnode_sess->max_burst);\r\nbreak;\r\ncase ISCSI_FLASHNODE_DEF_TASKMGMT_TMO:\r\nrc = sprintf(buf, "%u\n",\r\nfnode_sess->default_taskmgmt_timeout);\r\nbreak;\r\ncase ISCSI_FLASHNODE_IPADDR:\r\nif (!strncmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\r\nrc = sprintf(buf, "%pI6\n", fnode_conn->ipaddress);\r\nelse\r\nrc = sprintf(buf, "%pI4\n", fnode_conn->ipaddress);\r\nbreak;\r\ncase ISCSI_FLASHNODE_ALIAS:\r\nif (fnode_sess->targetalias)\r\nrc = sprintf(buf, "%s\n", fnode_sess->targetalias);\r\nelse\r\nrc = sprintf(buf, "\n");\r\nbreak;\r\ncase ISCSI_FLASHNODE_REDIRECT_IPADDR:\r\nif (!strncmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\r\nrc = sprintf(buf, "%pI6\n",\r\nfnode_conn->redirect_ipaddr);\r\nelse\r\nrc = sprintf(buf, "%pI4\n",\r\nfnode_conn->redirect_ipaddr);\r\nbreak;\r\ncase ISCSI_FLASHNODE_MAX_SEGMENT_SIZE:\r\nrc = sprintf(buf, "%u\n", fnode_conn->max_segment_size);\r\nbreak;\r\ncase ISCSI_FLASHNODE_LOCAL_PORT:\r\nrc = sprintf(buf, "%u\n", fnode_conn->local_port);\r\nbreak;\r\ncase ISCSI_FLASHNODE_IPV4_TOS:\r\nrc = sprintf(buf, "%u\n", fnode_conn->ipv4_tos);\r\nbreak;\r\ncase ISCSI_FLASHNODE_IPV6_TC:\r\nif (!strncmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\r\nrc = sprintf(buf, "%u\n",\r\nfnode_conn->ipv6_traffic_class);\r\nelse\r\nrc = sprintf(buf, "\n");\r\nbreak;\r\ncase ISCSI_FLASHNODE_IPV6_FLOW_LABEL:\r\nrc = sprintf(buf, "%u\n", fnode_conn->ipv6_flow_label);\r\nbreak;\r\ncase ISCSI_FLASHNODE_LINK_LOCAL_IPV6:\r\nif (!strncmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\r\nrc = sprintf(buf, "%pI6\n",\r\nfnode_conn->link_local_ipv6_addr);\r\nelse\r\nrc = sprintf(buf, "\n");\r\nbreak;\r\ncase ISCSI_FLASHNODE_DISCOVERY_PARENT_IDX:\r\nrc = sprintf(buf, "%u\n", fnode_sess->discovery_parent_idx);\r\nbreak;\r\ncase ISCSI_FLASHNODE_DISCOVERY_PARENT_TYPE:\r\nif (fnode_sess->discovery_parent_type == DDB_ISNS)\r\nparent_type = ISCSI_DISC_PARENT_ISNS;\r\nelse if (fnode_sess->discovery_parent_type == DDB_NO_LINK)\r\nparent_type = ISCSI_DISC_PARENT_UNKNOWN;\r\nelse if (fnode_sess->discovery_parent_type < MAX_DDB_ENTRIES)\r\nparent_type = ISCSI_DISC_PARENT_SENDTGT;\r\nelse\r\nparent_type = ISCSI_DISC_PARENT_UNKNOWN;\r\nrc = sprintf(buf, "%s\n",\r\niscsi_get_discovery_parent_name(parent_type));\r\nbreak;\r\ncase ISCSI_FLASHNODE_NAME:\r\nif (fnode_sess->targetname)\r\nrc = sprintf(buf, "%s\n", fnode_sess->targetname);\r\nelse\r\nrc = sprintf(buf, "\n");\r\nbreak;\r\ncase ISCSI_FLASHNODE_TPGT:\r\nrc = sprintf(buf, "%u\n", fnode_sess->tpgt);\r\nbreak;\r\ncase ISCSI_FLASHNODE_TCP_XMIT_WSF:\r\nrc = sprintf(buf, "%u\n", fnode_conn->tcp_xmit_wsf);\r\nbreak;\r\ncase ISCSI_FLASHNODE_TCP_RECV_WSF:\r\nrc = sprintf(buf, "%u\n", fnode_conn->tcp_recv_wsf);\r\nbreak;\r\ncase ISCSI_FLASHNODE_CHAP_OUT_IDX:\r\nrc = sprintf(buf, "%u\n", fnode_sess->chap_out_idx);\r\nbreak;\r\ncase ISCSI_FLASHNODE_USERNAME:\r\nif (fnode_sess->chap_auth_en) {\r\nqla4xxx_get_uni_chap_at_index(ha,\r\nchap_tbl.name,\r\nchap_tbl.secret,\r\nfnode_sess->chap_out_idx);\r\nrc = sprintf(buf, "%s\n", chap_tbl.name);\r\n} else {\r\nrc = sprintf(buf, "\n");\r\n}\r\nbreak;\r\ncase ISCSI_FLASHNODE_PASSWORD:\r\nif (fnode_sess->chap_auth_en) {\r\nqla4xxx_get_uni_chap_at_index(ha,\r\nchap_tbl.name,\r\nchap_tbl.secret,\r\nfnode_sess->chap_out_idx);\r\nrc = sprintf(buf, "%s\n", chap_tbl.secret);\r\n} else {\r\nrc = sprintf(buf, "\n");\r\n}\r\nbreak;\r\ncase ISCSI_FLASHNODE_STATSN:\r\nrc = sprintf(buf, "%u\n", fnode_conn->statsn);\r\nbreak;\r\ncase ISCSI_FLASHNODE_EXP_STATSN:\r\nrc = sprintf(buf, "%u\n", fnode_conn->exp_statsn);\r\nbreak;\r\ncase ISCSI_FLASHNODE_IS_BOOT_TGT:\r\nrc = sprintf(buf, "%u\n", fnode_sess->is_boot_target);\r\nbreak;\r\ndefault:\r\nrc = -ENOSYS;\r\nbreak;\r\n}\r\nput_device(dev);\r\nreturn rc;\r\n}\r\nstatic int\r\nqla4xxx_sysfs_ddb_set_param(struct iscsi_bus_flash_session *fnode_sess,\r\nstruct iscsi_bus_flash_conn *fnode_conn,\r\nvoid *data, int len)\r\n{\r\nstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nstruct iscsi_flashnode_param_info *fnode_param;\r\nstruct ql4_chap_table chap_tbl;\r\nstruct nlattr *attr;\r\nuint16_t chap_out_idx = INVALID_ENTRY;\r\nint rc = QLA_ERROR;\r\nuint32_t rem = len;\r\nmemset((void *)&chap_tbl, 0, sizeof(chap_tbl));\r\nnla_for_each_attr(attr, data, len, rem) {\r\nfnode_param = nla_data(attr);\r\nswitch (fnode_param->param) {\r\ncase ISCSI_FLASHNODE_IS_FW_ASSIGNED_IPV6:\r\nfnode_conn->is_fw_assigned_ipv6 = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_PORTAL_TYPE:\r\nmemcpy(fnode_sess->portal_type, fnode_param->value,\r\nstrlen(fnode_sess->portal_type));\r\nbreak;\r\ncase ISCSI_FLASHNODE_AUTO_SND_TGT_DISABLE:\r\nfnode_sess->auto_snd_tgt_disable =\r\nfnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_DISCOVERY_SESS:\r\nfnode_sess->discovery_sess = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_ENTRY_EN:\r\nfnode_sess->entry_state = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_HDR_DGST_EN:\r\nfnode_conn->hdrdgst_en = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_DATA_DGST_EN:\r\nfnode_conn->datadgst_en = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_IMM_DATA_EN:\r\nfnode_sess->imm_data_en = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_INITIAL_R2T_EN:\r\nfnode_sess->initial_r2t_en = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_DATASEQ_INORDER:\r\nfnode_sess->dataseq_inorder_en = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_PDU_INORDER:\r\nfnode_sess->pdu_inorder_en = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_CHAP_AUTH_EN:\r\nfnode_sess->chap_auth_en = fnode_param->value[0];\r\nif (!fnode_sess->chap_auth_en)\r\nfnode_sess->chap_out_idx = INVALID_ENTRY;\r\nbreak;\r\ncase ISCSI_FLASHNODE_SNACK_REQ_EN:\r\nfnode_conn->snack_req_en = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_DISCOVERY_LOGOUT_EN:\r\nfnode_sess->discovery_logout_en = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_BIDI_CHAP_EN:\r\nfnode_sess->bidi_chap_en = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_DISCOVERY_AUTH_OPTIONAL:\r\nfnode_sess->discovery_auth_optional =\r\nfnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_ERL:\r\nfnode_sess->erl = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_TCP_TIMESTAMP_STAT:\r\nfnode_conn->tcp_timestamp_stat = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_TCP_NAGLE_DISABLE:\r\nfnode_conn->tcp_nagle_disable = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_TCP_WSF_DISABLE:\r\nfnode_conn->tcp_wsf_disable = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_TCP_TIMER_SCALE:\r\nfnode_conn->tcp_timer_scale = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_TCP_TIMESTAMP_EN:\r\nfnode_conn->tcp_timestamp_en = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_IP_FRAG_DISABLE:\r\nfnode_conn->fragment_disable = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_MAX_RECV_DLENGTH:\r\nfnode_conn->max_recv_dlength =\r\n*(unsigned *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_MAX_XMIT_DLENGTH:\r\nfnode_conn->max_xmit_dlength =\r\n*(unsigned *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_FIRST_BURST:\r\nfnode_sess->first_burst =\r\n*(unsigned *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_DEF_TIME2WAIT:\r\nfnode_sess->time2wait = *(uint16_t *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_DEF_TIME2RETAIN:\r\nfnode_sess->time2retain =\r\n*(uint16_t *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_MAX_R2T:\r\nfnode_sess->max_r2t =\r\n*(uint16_t *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_KEEPALIVE_TMO:\r\nfnode_conn->keepalive_timeout =\r\n*(uint16_t *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_ISID:\r\nmemcpy(fnode_sess->isid, fnode_param->value,\r\nsizeof(fnode_sess->isid));\r\nbreak;\r\ncase ISCSI_FLASHNODE_TSID:\r\nfnode_sess->tsid = *(uint16_t *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_PORT:\r\nfnode_conn->port = *(uint16_t *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_MAX_BURST:\r\nfnode_sess->max_burst = *(unsigned *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_DEF_TASKMGMT_TMO:\r\nfnode_sess->default_taskmgmt_timeout =\r\n*(uint16_t *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_IPADDR:\r\nmemcpy(fnode_conn->ipaddress, fnode_param->value,\r\nIPv6_ADDR_LEN);\r\nbreak;\r\ncase ISCSI_FLASHNODE_ALIAS:\r\nrc = iscsi_switch_str_param(&fnode_sess->targetalias,\r\n(char *)fnode_param->value);\r\nbreak;\r\ncase ISCSI_FLASHNODE_REDIRECT_IPADDR:\r\nmemcpy(fnode_conn->redirect_ipaddr, fnode_param->value,\r\nIPv6_ADDR_LEN);\r\nbreak;\r\ncase ISCSI_FLASHNODE_MAX_SEGMENT_SIZE:\r\nfnode_conn->max_segment_size =\r\n*(unsigned *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_LOCAL_PORT:\r\nfnode_conn->local_port =\r\n*(uint16_t *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_IPV4_TOS:\r\nfnode_conn->ipv4_tos = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_IPV6_TC:\r\nfnode_conn->ipv6_traffic_class = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_IPV6_FLOW_LABEL:\r\nfnode_conn->ipv6_flow_label = fnode_param->value[0];\r\nbreak;\r\ncase ISCSI_FLASHNODE_NAME:\r\nrc = iscsi_switch_str_param(&fnode_sess->targetname,\r\n(char *)fnode_param->value);\r\nbreak;\r\ncase ISCSI_FLASHNODE_TPGT:\r\nfnode_sess->tpgt = *(uint16_t *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_LINK_LOCAL_IPV6:\r\nmemcpy(fnode_conn->link_local_ipv6_addr,\r\nfnode_param->value, IPv6_ADDR_LEN);\r\nbreak;\r\ncase ISCSI_FLASHNODE_DISCOVERY_PARENT_IDX:\r\nfnode_sess->discovery_parent_idx =\r\n*(uint16_t *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_TCP_XMIT_WSF:\r\nfnode_conn->tcp_xmit_wsf =\r\n*(uint8_t *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_TCP_RECV_WSF:\r\nfnode_conn->tcp_recv_wsf =\r\n*(uint8_t *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_STATSN:\r\nfnode_conn->statsn = *(uint32_t *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_EXP_STATSN:\r\nfnode_conn->exp_statsn =\r\n*(uint32_t *)fnode_param->value;\r\nbreak;\r\ncase ISCSI_FLASHNODE_CHAP_OUT_IDX:\r\nchap_out_idx = *(uint16_t *)fnode_param->value;\r\nif (!qla4xxx_get_uni_chap_at_index(ha,\r\nchap_tbl.name,\r\nchap_tbl.secret,\r\nchap_out_idx)) {\r\nfnode_sess->chap_out_idx = chap_out_idx;\r\nfnode_sess->chap_auth_en = QL4_PARAM_ENABLE;\r\n}\r\nbreak;\r\ndefault:\r\nql4_printk(KERN_ERR, ha,\r\n"%s: No such sysfs attribute\n", __func__);\r\nrc = -ENOSYS;\r\ngoto exit_set_param;\r\n}\r\n}\r\nrc = qla4xxx_sysfs_ddb_apply(fnode_sess, fnode_conn);\r\nexit_set_param:\r\nreturn rc;\r\n}\r\nstatic int qla4xxx_sysfs_ddb_delete(struct iscsi_bus_flash_session *fnode_sess)\r\n{\r\nstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nuint32_t dev_db_start_offset;\r\nuint32_t dev_db_end_offset;\r\nstruct dev_db_entry *fw_ddb_entry = NULL;\r\ndma_addr_t fw_ddb_entry_dma;\r\nuint16_t *ddb_cookie = NULL;\r\nsize_t ddb_size = 0;\r\nvoid *pddb = NULL;\r\nint target_id;\r\nint rc = 0;\r\nif (fnode_sess->is_boot_target) {\r\nrc = -EPERM;\r\nDEBUG2(ql4_printk(KERN_ERR, ha,\r\n"%s: Deletion of boot target entry is not permitted.\n",\r\n__func__));\r\ngoto exit_ddb_del;\r\n}\r\nif (fnode_sess->flash_state == DEV_DB_NON_PERSISTENT)\r\ngoto sysfs_ddb_del;\r\nif (is_qla40XX(ha)) {\r\ndev_db_start_offset = FLASH_OFFSET_DB_INFO;\r\ndev_db_end_offset = FLASH_OFFSET_DB_END;\r\ndev_db_start_offset += (fnode_sess->target_id *\r\nsizeof(*fw_ddb_entry));\r\nddb_size = sizeof(*fw_ddb_entry);\r\n} else {\r\ndev_db_start_offset = FLASH_RAW_ACCESS_ADDR +\r\n(ha->hw.flt_region_ddb << 2);\r\nif (ha->port_num == 1)\r\ndev_db_start_offset += (ha->hw.flt_ddb_size / 2);\r\ndev_db_end_offset = dev_db_start_offset +\r\n(ha->hw.flt_ddb_size / 2);\r\ndev_db_start_offset += (fnode_sess->target_id *\r\nsizeof(*fw_ddb_entry));\r\ndev_db_start_offset += offsetof(struct dev_db_entry, cookie);\r\nddb_size = sizeof(*ddb_cookie);\r\n}\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "%s: start offset=%u, end offset=%u\n",\r\n__func__, dev_db_start_offset, dev_db_end_offset));\r\nif (dev_db_start_offset > dev_db_end_offset) {\r\nrc = -EIO;\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "%s:Invalid DDB index %u\n",\r\n__func__, fnode_sess->target_id));\r\ngoto exit_ddb_del;\r\n}\r\npddb = dma_alloc_coherent(&ha->pdev->dev, ddb_size,\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (!pddb) {\r\nrc = -ENOMEM;\r\nDEBUG2(ql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer\n",\r\n__func__));\r\ngoto exit_ddb_del;\r\n}\r\nif (is_qla40XX(ha)) {\r\nfw_ddb_entry = pddb;\r\nmemset(fw_ddb_entry, 0, ddb_size);\r\nddb_cookie = &fw_ddb_entry->cookie;\r\n} else {\r\nddb_cookie = pddb;\r\n}\r\n*ddb_cookie = 0xFFEE;\r\nqla4xxx_set_flash(ha, fw_ddb_entry_dma, dev_db_start_offset,\r\nddb_size, FLASH_OPT_RMW_COMMIT);\r\nsysfs_ddb_del:\r\ntarget_id = fnode_sess->target_id;\r\niscsi_destroy_flashnode_sess(fnode_sess);\r\nql4_printk(KERN_INFO, ha,\r\n"%s: session and conn entries for flashnode %u of host %lu deleted\n",\r\n__func__, target_id, ha->host_no);\r\nexit_ddb_del:\r\nif (pddb)\r\ndma_free_coherent(&ha->pdev->dev, ddb_size, pddb,\r\nfw_ddb_entry_dma);\r\nreturn rc;\r\n}\r\nint qla4xxx_sysfs_ddb_export(struct scsi_qla_host *ha)\r\n{\r\nstruct dev_db_entry *fw_ddb_entry = NULL;\r\ndma_addr_t fw_ddb_entry_dma;\r\nuint16_t max_ddbs;\r\nuint16_t idx = 0;\r\nint ret = QLA_SUCCESS;\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev,\r\nsizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (!fw_ddb_entry) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer\n",\r\n__func__));\r\nreturn -ENOMEM;\r\n}\r\nmax_ddbs = is_qla40XX(ha) ? MAX_PRST_DEV_DB_ENTRIES :\r\nMAX_DEV_DB_ENTRIES;\r\nfor (idx = 0; idx < max_ddbs; idx++) {\r\nif (qla4xxx_flashdb_by_index(ha, fw_ddb_entry, fw_ddb_entry_dma,\r\nidx))\r\ncontinue;\r\nret = qla4xxx_sysfs_ddb_tgt_create(ha, fw_ddb_entry, &idx, 0);\r\nif (ret) {\r\nret = -EIO;\r\nbreak;\r\n}\r\n}\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry), fw_ddb_entry,\r\nfw_ddb_entry_dma);\r\nreturn ret;\r\n}\r\nstatic void qla4xxx_sysfs_ddb_remove(struct scsi_qla_host *ha)\r\n{\r\niscsi_destroy_all_flashnode(ha->host);\r\n}\r\nvoid qla4xxx_build_ddb_list(struct scsi_qla_host *ha, int is_reset)\r\n{\r\nuint16_t tmo = 0;\r\nstruct list_head list_st, list_nt;\r\nstruct qla_ddb_index *st_ddb_idx, *st_ddb_idx_tmp;\r\nunsigned long wtime;\r\nif (!test_bit(AF_LINK_UP, &ha->flags)) {\r\nset_bit(AF_BUILD_DDB_LIST, &ha->flags);\r\nha->is_reset = is_reset;\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&list_st);\r\nINIT_LIST_HEAD(&list_nt);\r\nqla4xxx_build_st_list(ha, &list_st);\r\nqla4xxx_wait_for_ip_configuration(ha);\r\nlist_for_each_entry_safe(st_ddb_idx, st_ddb_idx_tmp, &list_st, list) {\r\nqla4xxx_conn_open(ha, st_ddb_idx->fw_ddb_idx);\r\n}\r\ntmo = ((ha->def_timeout > LOGIN_TOV) &&\r\n(ha->def_timeout < LOGIN_TOV * 10) ?\r\nha->def_timeout : LOGIN_TOV);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Default time to wait for build ddb %d\n", tmo));\r\nwtime = jiffies + (HZ * tmo);\r\ndo {\r\nif (list_empty(&list_st))\r\nbreak;\r\nqla4xxx_remove_failed_ddb(ha, &list_st);\r\nschedule_timeout_uninterruptible(HZ / 10);\r\n} while (time_after(wtime, jiffies));\r\nqla4xxx_build_nt_list(ha, &list_nt, &list_st, is_reset);\r\nqla4xxx_free_ddb_list(&list_st);\r\nqla4xxx_free_ddb_list(&list_nt);\r\nqla4xxx_free_ddb_index(ha);\r\n}\r\nstatic void qla4xxx_wait_login_resp_boot_tgt(struct scsi_qla_host *ha)\r\n{\r\nstruct ddb_entry *ddb_entry;\r\nstruct dev_db_entry *fw_ddb_entry = NULL;\r\ndma_addr_t fw_ddb_entry_dma;\r\nunsigned long wtime;\r\nuint32_t ddb_state;\r\nint max_ddbs, idx, ret;\r\nmax_ddbs = is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\r\nMAX_DEV_DB_ENTRIES;\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (!fw_ddb_entry) {\r\nql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer\n", __func__);\r\ngoto exit_login_resp;\r\n}\r\nwtime = jiffies + (HZ * BOOT_LOGIN_RESP_TOV);\r\nfor (idx = 0; idx < max_ddbs; idx++) {\r\nddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\r\nif (ddb_entry == NULL)\r\ncontinue;\r\nif (test_bit(DF_BOOT_TGT, &ddb_entry->flags)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: DDB index [%d]\n", __func__,\r\nddb_entry->fw_ddb_index));\r\ndo {\r\nret = qla4xxx_get_fwddb_entry(ha,\r\nddb_entry->fw_ddb_index,\r\nfw_ddb_entry, fw_ddb_entry_dma,\r\nNULL, NULL, &ddb_state, NULL,\r\nNULL, NULL);\r\nif (ret == QLA_ERROR)\r\ngoto exit_login_resp;\r\nif ((ddb_state == DDB_DS_SESSION_ACTIVE) ||\r\n(ddb_state == DDB_DS_SESSION_FAILED))\r\nbreak;\r\nschedule_timeout_uninterruptible(HZ);\r\n} while ((time_after(wtime, jiffies)));\r\nif (!time_after(wtime, jiffies)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Login response wait timer expired\n",\r\n__func__));\r\ngoto exit_login_resp;\r\n}\r\n}\r\n}\r\nexit_login_resp:\r\nif (fw_ddb_entry)\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\nfw_ddb_entry, fw_ddb_entry_dma);\r\n}\r\nstatic int qla4xxx_probe_adapter(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint ret = -ENODEV, status;\r\nstruct Scsi_Host *host;\r\nstruct scsi_qla_host *ha;\r\nuint8_t init_retry_count = 0;\r\nchar buf[34];\r\nstruct qla4_8xxx_legacy_intr_set *nx_legacy_intr;\r\nuint32_t dev_state;\r\nif (pci_enable_device(pdev))\r\nreturn -1;\r\nhost = iscsi_host_alloc(&qla4xxx_driver_template, sizeof(*ha), 0);\r\nif (host == NULL) {\r\nprintk(KERN_WARNING\r\n"qla4xxx: Couldn't allocate host from scsi layer!\n");\r\ngoto probe_disable_device;\r\n}\r\nha = to_qla_host(host);\r\nmemset(ha, 0, sizeof(*ha));\r\nha->pdev = pdev;\r\nha->host = host;\r\nha->host_no = host->host_no;\r\nha->func_num = PCI_FUNC(ha->pdev->devfn);\r\npci_enable_pcie_error_reporting(pdev);\r\nif (is_qla8022(ha)) {\r\nha->isp_ops = &qla4_82xx_isp_ops;\r\nha->reg_tbl = (uint32_t *) qla4_82xx_reg_tbl;\r\nha->qdr_sn_window = -1;\r\nha->ddr_mn_window = -1;\r\nha->curr_window = 255;\r\nnx_legacy_intr = &legacy_intr[ha->func_num];\r\nha->nx_legacy_intr.int_vec_bit = nx_legacy_intr->int_vec_bit;\r\nha->nx_legacy_intr.tgt_status_reg =\r\nnx_legacy_intr->tgt_status_reg;\r\nha->nx_legacy_intr.tgt_mask_reg = nx_legacy_intr->tgt_mask_reg;\r\nha->nx_legacy_intr.pci_int_reg = nx_legacy_intr->pci_int_reg;\r\n} else if (is_qla8032(ha) || is_qla8042(ha)) {\r\nha->isp_ops = &qla4_83xx_isp_ops;\r\nha->reg_tbl = (uint32_t *)qla4_83xx_reg_tbl;\r\n} else {\r\nha->isp_ops = &qla4xxx_isp_ops;\r\n}\r\nif (is_qla80XX(ha)) {\r\nrwlock_init(&ha->hw_lock);\r\nha->pf_bit = ha->func_num << 16;\r\npdev->needs_freset = 1;\r\n}\r\nret = ha->isp_ops->iospace_config(ha);\r\nif (ret)\r\ngoto probe_failed_ioconfig;\r\nql4_printk(KERN_INFO, ha, "Found an ISP%04x, irq %d, iobase 0x%p\n",\r\npdev->device, pdev->irq, ha->reg);\r\nqla4xxx_config_dma_addressing(ha);\r\nINIT_LIST_HEAD(&ha->free_srb_q);\r\nmutex_init(&ha->mbox_sem);\r\nmutex_init(&ha->chap_sem);\r\ninit_completion(&ha->mbx_intr_comp);\r\ninit_completion(&ha->disable_acb_comp);\r\ninit_completion(&ha->idc_comp);\r\ninit_completion(&ha->link_up_comp);\r\nspin_lock_init(&ha->hardware_lock);\r\nspin_lock_init(&ha->work_lock);\r\nINIT_LIST_HEAD(&ha->work_list);\r\nif (qla4xxx_mem_alloc(ha)) {\r\nql4_printk(KERN_WARNING, ha,\r\n"[ERROR] Failed to allocate memory for adapter\n");\r\nret = -ENOMEM;\r\ngoto probe_failed;\r\n}\r\nhost->cmd_per_lun = 3;\r\nhost->max_channel = 0;\r\nhost->max_lun = MAX_LUNS - 1;\r\nhost->max_id = MAX_TARGETS;\r\nhost->max_cmd_len = IOCB_MAX_CDB_LEN;\r\nhost->can_queue = MAX_SRBS ;\r\nhost->transportt = qla4xxx_scsi_transport;\r\npci_set_drvdata(pdev, ha);\r\nret = scsi_add_host(host, &pdev->dev);\r\nif (ret)\r\ngoto probe_failed;\r\nif (is_qla80XX(ha))\r\nqla4_8xxx_get_flash_info(ha);\r\nif (is_qla8032(ha) || is_qla8042(ha)) {\r\nqla4_83xx_read_reset_template(ha);\r\nif (ql4xdontresethba == 1)\r\nqla4_83xx_set_idc_dontreset(ha);\r\n}\r\nstatus = qla4xxx_initialize_adapter(ha, INIT_ADAPTER);\r\nif (is_qla80XX(ha) && (status == QLA_ERROR))\r\ngoto skip_retry_init;\r\nwhile ((!test_bit(AF_ONLINE, &ha->flags)) &&\r\ninit_retry_count++ < MAX_INIT_RETRIES) {\r\nif (is_qla80XX(ha)) {\r\nha->isp_ops->idc_lock(ha);\r\ndev_state = qla4_8xxx_rd_direct(ha,\r\nQLA8XXX_CRB_DEV_STATE);\r\nha->isp_ops->idc_unlock(ha);\r\nif (dev_state == QLA8XXX_DEV_FAILED) {\r\nql4_printk(KERN_WARNING, ha, "%s: don't retry "\r\n"initialize adapter. H/W is in failed state\n",\r\n__func__);\r\nbreak;\r\n}\r\n}\r\nDEBUG2(printk("scsi: %s: retrying adapter initialization "\r\n"(%d)\n", __func__, init_retry_count));\r\nif (ha->isp_ops->reset_chip(ha) == QLA_ERROR)\r\ncontinue;\r\nstatus = qla4xxx_initialize_adapter(ha, INIT_ADAPTER);\r\nif (is_qla80XX(ha) && (status == QLA_ERROR)) {\r\nif (qla4_8xxx_check_init_adapter_retry(ha) == QLA_ERROR)\r\ngoto skip_retry_init;\r\n}\r\n}\r\nskip_retry_init:\r\nif (!test_bit(AF_ONLINE, &ha->flags)) {\r\nql4_printk(KERN_WARNING, ha, "Failed to initialize adapter\n");\r\nif ((is_qla8022(ha) && ql4xdontresethba) ||\r\n((is_qla8032(ha) || is_qla8042(ha)) &&\r\nqla4_83xx_idc_dontreset(ha))) {\r\nDEBUG2(printk(KERN_ERR "HW STATE: FAILED\n"));\r\nha->isp_ops->idc_lock(ha);\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\r\nQLA8XXX_DEV_FAILED);\r\nha->isp_ops->idc_unlock(ha);\r\n}\r\nret = -ENODEV;\r\ngoto remove_host;\r\n}\r\nDEBUG2(printk("scsi: %s: Starting kernel thread for "\r\n"qla4xxx_dpc\n", __func__));\r\nsprintf(buf, "qla4xxx_%lu_dpc", ha->host_no);\r\nha->dpc_thread = create_singlethread_workqueue(buf);\r\nif (!ha->dpc_thread) {\r\nql4_printk(KERN_WARNING, ha, "Unable to start DPC thread!\n");\r\nret = -ENODEV;\r\ngoto remove_host;\r\n}\r\nINIT_WORK(&ha->dpc_work, qla4xxx_do_dpc);\r\nha->task_wq = alloc_workqueue("qla4xxx_%lu_task", WQ_MEM_RECLAIM, 1,\r\nha->host_no);\r\nif (!ha->task_wq) {\r\nql4_printk(KERN_WARNING, ha, "Unable to start task thread!\n");\r\nret = -ENODEV;\r\ngoto remove_host;\r\n}\r\nif (is_qla40XX(ha)) {\r\nret = qla4xxx_request_irqs(ha);\r\nif (ret) {\r\nql4_printk(KERN_WARNING, ha, "Failed to reserve "\r\n"interrupt %d already in use.\n", pdev->irq);\r\ngoto remove_host;\r\n}\r\n}\r\npci_save_state(ha->pdev);\r\nha->isp_ops->enable_intrs(ha);\r\nqla4xxx_start_timer(ha, qla4xxx_timer, 1);\r\nset_bit(AF_INIT_DONE, &ha->flags);\r\nqla4_8xxx_alloc_sysfs_attr(ha);\r\nprintk(KERN_INFO\r\n" QLogic iSCSI HBA Driver version: %s\n"\r\n" QLogic ISP%04x @ %s, host#=%ld, fw=%02d.%02d.%02d.%02d\n",\r\nqla4xxx_version_str, ha->pdev->device, pci_name(ha->pdev),\r\nha->host_no, ha->fw_info.fw_major, ha->fw_info.fw_minor,\r\nha->fw_info.fw_patch, ha->fw_info.fw_build);\r\nif (is_qla80XX(ha))\r\nqla4_8xxx_set_param(ha, SET_DRVR_VERSION);\r\nif (qla4xxx_setup_boot_info(ha))\r\nql4_printk(KERN_ERR, ha,\r\n"%s: No iSCSI boot target configured\n", __func__);\r\nset_bit(DPC_SYSFS_DDB_EXPORT, &ha->dpc_flags);\r\nqla4xxx_build_ddb_list(ha, INIT_ADAPTER);\r\niscsi_host_for_each_session(ha->host, qla4xxx_login_flash_ddb);\r\nqla4xxx_wait_login_resp_boot_tgt(ha);\r\nqla4xxx_create_chap_list(ha);\r\nqla4xxx_create_ifaces(ha);\r\nreturn 0;\r\nremove_host:\r\nscsi_remove_host(ha->host);\r\nprobe_failed:\r\nqla4xxx_free_adapter(ha);\r\nprobe_failed_ioconfig:\r\npci_disable_pcie_error_reporting(pdev);\r\nscsi_host_put(ha->host);\r\nprobe_disable_device:\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}\r\nstatic void qla4xxx_prevent_other_port_reinit(struct scsi_qla_host *ha)\r\n{\r\nstruct scsi_qla_host *other_ha = NULL;\r\nstruct pci_dev *other_pdev = NULL;\r\nint fn = ISP4XXX_PCI_FN_2;\r\nif (PCI_FUNC(ha->pdev->devfn) & BIT_1)\r\nfn = ISP4XXX_PCI_FN_1;\r\nother_pdev =\r\npci_get_domain_bus_and_slot(pci_domain_nr(ha->pdev->bus),\r\nha->pdev->bus->number, PCI_DEVFN(PCI_SLOT(ha->pdev->devfn),\r\nfn));\r\nif (other_pdev) {\r\nif (atomic_read(&other_pdev->enable_cnt)) {\r\nother_ha = pci_get_drvdata(other_pdev);\r\nif (other_ha) {\r\nset_bit(AF_HA_REMOVAL, &other_ha->flags);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: "\r\n"Prevent %s reinit\n", __func__,\r\ndev_name(&other_ha->pdev->dev)));\r\n}\r\n}\r\npci_dev_put(other_pdev);\r\n}\r\n}\r\nstatic void qla4xxx_destroy_ddb(struct scsi_qla_host *ha,\r\nstruct ddb_entry *ddb_entry)\r\n{\r\nstruct dev_db_entry *fw_ddb_entry = NULL;\r\ndma_addr_t fw_ddb_entry_dma;\r\nunsigned long wtime;\r\nuint32_t ddb_state;\r\nint options;\r\nint status;\r\noptions = LOGOUT_OPTION_CLOSE_SESSION;\r\nif (qla4xxx_session_logout_ddb(ha, ddb_entry, options) == QLA_ERROR) {\r\nql4_printk(KERN_ERR, ha, "%s: Logout failed\n", __func__);\r\ngoto clear_ddb;\r\n}\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (!fw_ddb_entry) {\r\nql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer\n", __func__);\r\ngoto clear_ddb;\r\n}\r\nwtime = jiffies + (HZ * LOGOUT_TOV);\r\ndo {\r\nstatus = qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index,\r\nfw_ddb_entry, fw_ddb_entry_dma,\r\nNULL, NULL, &ddb_state, NULL,\r\nNULL, NULL);\r\nif (status == QLA_ERROR)\r\ngoto free_ddb;\r\nif ((ddb_state == DDB_DS_NO_CONNECTION_ACTIVE) ||\r\n(ddb_state == DDB_DS_SESSION_FAILED))\r\ngoto free_ddb;\r\nschedule_timeout_uninterruptible(HZ);\r\n} while ((time_after(wtime, jiffies)));\r\nfree_ddb:\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\nfw_ddb_entry, fw_ddb_entry_dma);\r\nclear_ddb:\r\nqla4xxx_clear_ddb_entry(ha, ddb_entry->fw_ddb_index);\r\n}\r\nstatic void qla4xxx_destroy_fw_ddb_session(struct scsi_qla_host *ha)\r\n{\r\nstruct ddb_entry *ddb_entry;\r\nint idx;\r\nfor (idx = 0; idx < MAX_DDB_ENTRIES; idx++) {\r\nddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\r\nif ((ddb_entry != NULL) &&\r\n(ddb_entry->ddb_type == FLASH_DDB)) {\r\nqla4xxx_destroy_ddb(ha, ddb_entry);\r\ntry_module_get(qla4xxx_iscsi_transport.owner);\r\niscsi_destroy_endpoint(ddb_entry->conn->ep);\r\nqla4xxx_free_ddb(ha, ddb_entry);\r\niscsi_session_teardown(ddb_entry->sess);\r\n}\r\n}\r\n}\r\nstatic void qla4xxx_remove_adapter(struct pci_dev *pdev)\r\n{\r\nstruct scsi_qla_host *ha;\r\nif (!pci_is_enabled(pdev))\r\nreturn;\r\nha = pci_get_drvdata(pdev);\r\nif (is_qla40XX(ha))\r\nqla4xxx_prevent_other_port_reinit(ha);\r\nqla4xxx_destroy_ifaces(ha);\r\nif ((!ql4xdisablesysfsboot) && ha->boot_kset)\r\niscsi_boot_destroy_kset(ha->boot_kset);\r\nqla4xxx_destroy_fw_ddb_session(ha);\r\nqla4_8xxx_free_sysfs_attr(ha);\r\nqla4xxx_sysfs_ddb_remove(ha);\r\nscsi_remove_host(ha->host);\r\nqla4xxx_free_adapter(ha);\r\nscsi_host_put(ha->host);\r\npci_disable_pcie_error_reporting(pdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic void qla4xxx_config_dma_addressing(struct scsi_qla_host *ha)\r\n{\r\nint retval;\r\nif (pci_set_dma_mask(ha->pdev, DMA_BIT_MASK(64)) == 0) {\r\nif (pci_set_consistent_dma_mask(ha->pdev, DMA_BIT_MASK(64))) {\r\ndev_dbg(&ha->pdev->dev,\r\n"Failed to set 64 bit PCI consistent mask; "\r\n"using 32 bit.\n");\r\nretval = pci_set_consistent_dma_mask(ha->pdev,\r\nDMA_BIT_MASK(32));\r\n}\r\n} else\r\nretval = pci_set_dma_mask(ha->pdev, DMA_BIT_MASK(32));\r\n}\r\nstatic int qla4xxx_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct iscsi_cls_session *cls_sess;\r\nstruct iscsi_session *sess;\r\nstruct ddb_entry *ddb;\r\nint queue_depth = QL4_DEF_QDEPTH;\r\ncls_sess = starget_to_session(sdev->sdev_target);\r\nsess = cls_sess->dd_data;\r\nddb = sess->dd_data;\r\nsdev->hostdata = ddb;\r\nif (ql4xmaxqdepth != 0 && ql4xmaxqdepth <= 0xffffU)\r\nqueue_depth = ql4xmaxqdepth;\r\nscsi_change_queue_depth(sdev, queue_depth);\r\nreturn 0;\r\n}\r\nstruct srb *qla4xxx_del_from_active_array(struct scsi_qla_host *ha,\r\nuint32_t index)\r\n{\r\nstruct srb *srb = NULL;\r\nstruct scsi_cmnd *cmd = NULL;\r\ncmd = scsi_host_find_tag(ha->host, index);\r\nif (!cmd)\r\nreturn srb;\r\nsrb = (struct srb *)CMD_SP(cmd);\r\nif (!srb)\r\nreturn srb;\r\nif (srb->flags & SRB_DMA_VALID) {\r\nha->iocb_cnt -= srb->iocb_cnt;\r\nif (srb->cmd)\r\nsrb->cmd->host_scribble =\r\n(unsigned char *)(unsigned long) MAX_SRBS;\r\n}\r\nreturn srb;\r\n}\r\nstatic int qla4xxx_eh_wait_on_command(struct scsi_qla_host *ha,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nint done = 0;\r\nstruct srb *rp;\r\nuint32_t max_wait_time = EH_WAIT_CMD_TOV;\r\nint ret = SUCCESS;\r\nif (unlikely(pci_channel_offline(ha->pdev)) ||\r\n(test_bit(AF_EEH_BUSY, &ha->flags))) {\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: Return from %s\n",\r\nha->host_no, __func__);\r\nreturn ret;\r\n}\r\ndo {\r\nrp = (struct srb *) CMD_SP(cmd);\r\nif (rp == NULL) {\r\ndone++;\r\nbreak;\r\n}\r\nmsleep(2000);\r\n} while (max_wait_time--);\r\nreturn done;\r\n}\r\nstatic int qla4xxx_wait_for_hba_online(struct scsi_qla_host *ha)\r\n{\r\nunsigned long wait_online;\r\nwait_online = jiffies + (HBA_ONLINE_TOV * HZ);\r\nwhile (time_before(jiffies, wait_online)) {\r\nif (adapter_up(ha))\r\nreturn QLA_SUCCESS;\r\nmsleep(2000);\r\n}\r\nreturn QLA_ERROR;\r\n}\r\nstatic int qla4xxx_eh_wait_for_commands(struct scsi_qla_host *ha,\r\nstruct scsi_target *stgt,\r\nstruct scsi_device *sdev)\r\n{\r\nint cnt;\r\nint status = 0;\r\nstruct scsi_cmnd *cmd;\r\nfor (cnt = 0; cnt < ha->host->can_queue; cnt++) {\r\ncmd = scsi_host_find_tag(ha->host, cnt);\r\nif (cmd && stgt == scsi_target(cmd->device) &&\r\n(!sdev || sdev == cmd->device)) {\r\nif (!qla4xxx_eh_wait_on_command(ha, cmd)) {\r\nstatus++;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int qla4xxx_eh_abort(struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(cmd->device->host);\r\nunsigned int id = cmd->device->id;\r\nuint64_t lun = cmd->device->lun;\r\nunsigned long flags;\r\nstruct srb *srb = NULL;\r\nint ret = SUCCESS;\r\nint wait = 0;\r\nql4_printk(KERN_INFO, ha, "scsi%ld:%d:%llu: Abort command issued cmd=%p, cdb=0x%x\n",\r\nha->host_no, id, lun, cmd, cmd->cmnd[0]);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nsrb = (struct srb *) CMD_SP(cmd);\r\nif (!srb) {\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nql4_printk(KERN_INFO, ha, "scsi%ld:%d:%llu: Specified command has already completed.\n",\r\nha->host_no, id, lun);\r\nreturn SUCCESS;\r\n}\r\nkref_get(&srb->srb_ref);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (qla4xxx_abort_task(ha, srb) != QLA_SUCCESS) {\r\nDEBUG3(printk("scsi%ld:%d:%llu: Abort_task mbx failed.\n",\r\nha->host_no, id, lun));\r\nret = FAILED;\r\n} else {\r\nDEBUG3(printk("scsi%ld:%d:%llu: Abort_task mbx success.\n",\r\nha->host_no, id, lun));\r\nwait = 1;\r\n}\r\nkref_put(&srb->srb_ref, qla4xxx_srb_compl);\r\nif (wait) {\r\nif (!qla4xxx_eh_wait_on_command(ha, cmd)) {\r\nDEBUG2(printk("scsi%ld:%d:%llu: Abort handler timed out\n",\r\nha->host_no, id, lun));\r\nret = FAILED;\r\n}\r\n}\r\nql4_printk(KERN_INFO, ha,\r\n"scsi%ld:%d:%llu: Abort command - %s\n",\r\nha->host_no, id, lun, (ret == SUCCESS) ? "succeeded" : "failed");\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(cmd->device->host);\r\nstruct ddb_entry *ddb_entry = cmd->device->hostdata;\r\nint ret = FAILED, stat;\r\nif (!ddb_entry)\r\nreturn ret;\r\nret = iscsi_block_scsi_eh(cmd);\r\nif (ret)\r\nreturn ret;\r\nret = FAILED;\r\nql4_printk(KERN_INFO, ha,\r\n"scsi%ld:%d:%d:%llu: DEVICE RESET ISSUED.\n", ha->host_no,\r\ncmd->device->channel, cmd->device->id, cmd->device->lun);\r\nDEBUG2(printk(KERN_INFO\r\n"scsi%ld: DEVICE_RESET cmd=%p jiffies = 0x%lx, to=%x,"\r\n"dpc_flags=%lx, status=%x allowed=%d\n", ha->host_no,\r\ncmd, jiffies, cmd->request->timeout / HZ,\r\nha->dpc_flags, cmd->result, cmd->allowed));\r\nstat = qla4xxx_reset_lun(ha, ddb_entry, cmd->device->lun);\r\nif (stat != QLA_SUCCESS) {\r\nql4_printk(KERN_INFO, ha, "DEVICE RESET FAILED. %d\n", stat);\r\ngoto eh_dev_reset_done;\r\n}\r\nif (qla4xxx_eh_wait_for_commands(ha, scsi_target(cmd->device),\r\ncmd->device)) {\r\nql4_printk(KERN_INFO, ha,\r\n"DEVICE RESET FAILED - waiting for "\r\n"commands.\n");\r\ngoto eh_dev_reset_done;\r\n}\r\nif (qla4xxx_send_marker_iocb(ha, ddb_entry, cmd->device->lun,\r\nMM_LUN_RESET) != QLA_SUCCESS)\r\ngoto eh_dev_reset_done;\r\nql4_printk(KERN_INFO, ha,\r\n"scsi(%ld:%d:%d:%llu): DEVICE RESET SUCCEEDED.\n",\r\nha->host_no, cmd->device->channel, cmd->device->id,\r\ncmd->device->lun);\r\nret = SUCCESS;\r\neh_dev_reset_done:\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_eh_target_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(cmd->device->host);\r\nstruct ddb_entry *ddb_entry = cmd->device->hostdata;\r\nint stat, ret;\r\nif (!ddb_entry)\r\nreturn FAILED;\r\nret = iscsi_block_scsi_eh(cmd);\r\nif (ret)\r\nreturn ret;\r\nstarget_printk(KERN_INFO, scsi_target(cmd->device),\r\n"WARM TARGET RESET ISSUED.\n");\r\nDEBUG2(printk(KERN_INFO\r\n"scsi%ld: TARGET_DEVICE_RESET cmd=%p jiffies = 0x%lx, "\r\n"to=%x,dpc_flags=%lx, status=%x allowed=%d\n",\r\nha->host_no, cmd, jiffies, cmd->request->timeout / HZ,\r\nha->dpc_flags, cmd->result, cmd->allowed));\r\nstat = qla4xxx_reset_target(ha, ddb_entry);\r\nif (stat != QLA_SUCCESS) {\r\nstarget_printk(KERN_INFO, scsi_target(cmd->device),\r\n"WARM TARGET RESET FAILED.\n");\r\nreturn FAILED;\r\n}\r\nif (qla4xxx_eh_wait_for_commands(ha, scsi_target(cmd->device),\r\nNULL)) {\r\nstarget_printk(KERN_INFO, scsi_target(cmd->device),\r\n"WARM TARGET DEVICE RESET FAILED - "\r\n"waiting for commands.\n");\r\nreturn FAILED;\r\n}\r\nif (qla4xxx_send_marker_iocb(ha, ddb_entry, cmd->device->lun,\r\nMM_TGT_WARM_RESET) != QLA_SUCCESS) {\r\nstarget_printk(KERN_INFO, scsi_target(cmd->device),\r\n"WARM TARGET DEVICE RESET FAILED - "\r\n"marker iocb failed.\n");\r\nreturn FAILED;\r\n}\r\nstarget_printk(KERN_INFO, scsi_target(cmd->device),\r\n"WARM TARGET RESET SUCCEEDED.\n");\r\nreturn SUCCESS;\r\n}\r\nstatic int qla4xxx_is_eh_active(struct Scsi_Host *shost)\r\n{\r\nif (shost->shost_state == SHOST_RECOVERY)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int qla4xxx_eh_host_reset(struct scsi_cmnd *cmd)\r\n{\r\nint return_status = FAILED;\r\nstruct scsi_qla_host *ha;\r\nha = to_qla_host(cmd->device->host);\r\nif ((is_qla8032(ha) || is_qla8042(ha)) && ql4xdontresethba)\r\nqla4_83xx_set_idc_dontreset(ha);\r\nif (ql4xdontresethba ||\r\n((is_qla8032(ha) || is_qla8042(ha)) &&\r\nqla4_83xx_idc_dontreset(ha))) {\r\nDEBUG2(printk("scsi%ld: %s: Don't Reset HBA\n",\r\nha->host_no, __func__));\r\nif (qla4xxx_is_eh_active(cmd->device->host))\r\nqla4xxx_abort_active_cmds(ha, DID_ABORT << 16);\r\nreturn FAILED;\r\n}\r\nql4_printk(KERN_INFO, ha,\r\n"scsi(%ld:%d:%d:%llu): HOST RESET ISSUED.\n", ha->host_no,\r\ncmd->device->channel, cmd->device->id, cmd->device->lun);\r\nif (qla4xxx_wait_for_hba_online(ha) != QLA_SUCCESS) {\r\nDEBUG2(printk("scsi%ld:%d: %s: Unable to reset host. Adapter "\r\n"DEAD.\n", ha->host_no, cmd->device->channel,\r\n__func__));\r\nreturn FAILED;\r\n}\r\nif (!test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\r\nif (is_qla80XX(ha))\r\nset_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\r\nelse\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\n}\r\nif (qla4xxx_recover_adapter(ha) == QLA_SUCCESS)\r\nreturn_status = SUCCESS;\r\nql4_printk(KERN_INFO, ha, "HOST RESET %s.\n",\r\nreturn_status == FAILED ? "FAILED" : "SUCCEEDED");\r\nreturn return_status;\r\n}\r\nstatic int qla4xxx_context_reset(struct scsi_qla_host *ha)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nstruct addr_ctrl_blk_def *acb = NULL;\r\nuint32_t acb_len = sizeof(struct addr_ctrl_blk_def);\r\nint rval = QLA_SUCCESS;\r\ndma_addr_t acb_dma;\r\nacb = dma_alloc_coherent(&ha->pdev->dev,\r\nsizeof(struct addr_ctrl_blk_def),\r\n&acb_dma, GFP_KERNEL);\r\nif (!acb) {\r\nql4_printk(KERN_ERR, ha, "%s: Unable to alloc acb\n",\r\n__func__);\r\nrval = -ENOMEM;\r\ngoto exit_port_reset;\r\n}\r\nmemset(acb, 0, acb_len);\r\nrval = qla4xxx_get_acb(ha, acb_dma, PRIMARI_ACB, acb_len);\r\nif (rval != QLA_SUCCESS) {\r\nrval = -EIO;\r\ngoto exit_free_acb;\r\n}\r\nrval = qla4xxx_disable_acb(ha);\r\nif (rval != QLA_SUCCESS) {\r\nrval = -EIO;\r\ngoto exit_free_acb;\r\n}\r\nwait_for_completion_timeout(&ha->disable_acb_comp,\r\nDISABLE_ACB_TOV * HZ);\r\nrval = qla4xxx_set_acb(ha, &mbox_cmd[0], &mbox_sts[0], acb_dma);\r\nif (rval != QLA_SUCCESS) {\r\nrval = -EIO;\r\ngoto exit_free_acb;\r\n}\r\nexit_free_acb:\r\ndma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk_def),\r\nacb, acb_dma);\r\nexit_port_reset:\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s %s\n", __func__,\r\nrval == QLA_SUCCESS ? "SUCCEEDED" : "FAILED"));\r\nreturn rval;\r\n}\r\nstatic int qla4xxx_host_reset(struct Scsi_Host *shost, int reset_type)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nint rval = QLA_SUCCESS;\r\nuint32_t idc_ctrl;\r\nif (ql4xdontresethba) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: Don't Reset HBA\n",\r\n__func__));\r\nrval = -EPERM;\r\ngoto exit_host_reset;\r\n}\r\nif (test_bit(DPC_RESET_HA, &ha->dpc_flags))\r\ngoto recover_adapter;\r\nswitch (reset_type) {\r\ncase SCSI_ADAPTER_RESET:\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nbreak;\r\ncase SCSI_FIRMWARE_RESET:\r\nif (!test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\r\nif (is_qla80XX(ha))\r\nset_bit(DPC_RESET_HA_FW_CONTEXT,\r\n&ha->dpc_flags);\r\nelse {\r\nrval = qla4xxx_context_reset(ha);\r\ngoto exit_host_reset;\r\n}\r\n}\r\nbreak;\r\n}\r\nrecover_adapter:\r\nif ((is_qla8032(ha) || is_qla8042(ha)) &&\r\ntest_bit(DPC_RESET_HA, &ha->dpc_flags)) {\r\nidc_ctrl = qla4_83xx_rd_reg(ha, QLA83XX_IDC_DRV_CTRL);\r\nqla4_83xx_wr_reg(ha, QLA83XX_IDC_DRV_CTRL,\r\n(idc_ctrl | GRACEFUL_RESET_BIT1));\r\n}\r\nrval = qla4xxx_recover_adapter(ha);\r\nif (rval != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: recover adapter fail\n",\r\n__func__));\r\nrval = -EIO;\r\n}\r\nexit_host_reset:\r\nreturn rval;\r\n}\r\nstatic pci_ers_result_t\r\nqla4xxx_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)\r\n{\r\nstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: %s: error detected:state %x\n",\r\nha->host_no, __func__, state);\r\nif (!is_aer_supported(ha))\r\nreturn PCI_ERS_RESULT_NONE;\r\nswitch (state) {\r\ncase pci_channel_io_normal:\r\nclear_bit(AF_EEH_BUSY, &ha->flags);\r\nreturn PCI_ERS_RESULT_CAN_RECOVER;\r\ncase pci_channel_io_frozen:\r\nset_bit(AF_EEH_BUSY, &ha->flags);\r\nqla4xxx_mailbox_premature_completion(ha);\r\nqla4xxx_free_irqs(ha);\r\npci_disable_device(pdev);\r\nqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\ncase pci_channel_io_perm_failure:\r\nset_bit(AF_EEH_BUSY, &ha->flags);\r\nset_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags);\r\nqla4xxx_abort_active_cmds(ha, DID_NO_CONNECT << 16);\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t\r\nqla4xxx_pci_mmio_enabled(struct pci_dev *pdev)\r\n{\r\nstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\r\nif (!is_aer_supported(ha))\r\nreturn PCI_ERS_RESULT_NONE;\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\n}\r\nstatic uint32_t qla4_8xxx_error_recovery(struct scsi_qla_host *ha)\r\n{\r\nuint32_t rval = QLA_ERROR;\r\nint fn;\r\nstruct pci_dev *other_pdev = NULL;\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: In %s\n", ha->host_no, __func__);\r\nset_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\r\nif (test_bit(AF_ONLINE, &ha->flags)) {\r\nclear_bit(AF_ONLINE, &ha->flags);\r\nclear_bit(AF_LINK_UP, &ha->flags);\r\niscsi_host_for_each_session(ha->host, qla4xxx_fail_session);\r\nqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\r\n}\r\nfn = PCI_FUNC(ha->pdev->devfn);\r\nif (is_qla8022(ha)) {\r\nwhile (fn > 0) {\r\nfn--;\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: Finding PCI device at func %x\n",\r\nha->host_no, __func__, fn);\r\nother_pdev = pci_get_domain_bus_and_slot(\r\npci_domain_nr(ha->pdev->bus),\r\nha->pdev->bus->number,\r\nPCI_DEVFN(PCI_SLOT(ha->pdev->devfn),\r\nfn));\r\nif (!other_pdev)\r\ncontinue;\r\nif (atomic_read(&other_pdev->enable_cnt)) {\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: Found PCI func in enabled state%x\n",\r\nha->host_no, __func__, fn);\r\npci_dev_put(other_pdev);\r\nbreak;\r\n}\r\npci_dev_put(other_pdev);\r\n}\r\n} else {\r\nif (qla4_83xx_can_perform_reset(ha)) {\r\nfn = 0;\r\n}\r\n}\r\nif (!fn) {\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: devfn being reset "\r\n"0x%x is the owner\n", ha->host_no, __func__,\r\nha->pdev->devfn);\r\nha->isp_ops->idc_lock(ha);\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\r\nQLA8XXX_DEV_COLD);\r\nha->isp_ops->idc_unlock(ha);\r\nrval = qla4_8xxx_update_idc_reg(ha);\r\nif (rval == QLA_ERROR) {\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: HW State: FAILED\n",\r\nha->host_no, __func__);\r\nha->isp_ops->idc_lock(ha);\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\r\nQLA8XXX_DEV_FAILED);\r\nha->isp_ops->idc_unlock(ha);\r\ngoto exit_error_recovery;\r\n}\r\nclear_bit(AF_FW_RECOVERY, &ha->flags);\r\nrval = qla4xxx_initialize_adapter(ha, RESET_ADAPTER);\r\nif (rval != QLA_SUCCESS) {\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: HW State: "\r\n"FAILED\n", ha->host_no, __func__);\r\nqla4xxx_free_irqs(ha);\r\nha->isp_ops->idc_lock(ha);\r\nqla4_8xxx_clear_drv_active(ha);\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\r\nQLA8XXX_DEV_FAILED);\r\nha->isp_ops->idc_unlock(ha);\r\n} else {\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: HW State: "\r\n"READY\n", ha->host_no, __func__);\r\nha->isp_ops->idc_lock(ha);\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\r\nQLA8XXX_DEV_READY);\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_STATE, 0);\r\nqla4_8xxx_set_drv_active(ha);\r\nha->isp_ops->idc_unlock(ha);\r\nha->isp_ops->enable_intrs(ha);\r\n}\r\n} else {\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: devfn 0x%x is not "\r\n"the reset owner\n", ha->host_no, __func__,\r\nha->pdev->devfn);\r\nif ((qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE) ==\r\nQLA8XXX_DEV_READY)) {\r\nclear_bit(AF_FW_RECOVERY, &ha->flags);\r\nrval = qla4xxx_initialize_adapter(ha, RESET_ADAPTER);\r\nif (rval == QLA_SUCCESS)\r\nha->isp_ops->enable_intrs(ha);\r\nelse\r\nqla4xxx_free_irqs(ha);\r\nha->isp_ops->idc_lock(ha);\r\nqla4_8xxx_set_drv_active(ha);\r\nha->isp_ops->idc_unlock(ha);\r\n}\r\n}\r\nexit_error_recovery:\r\nclear_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\r\nreturn rval;\r\n}\r\nstatic pci_ers_result_t\r\nqla4xxx_pci_slot_reset(struct pci_dev *pdev)\r\n{\r\npci_ers_result_t ret = PCI_ERS_RESULT_DISCONNECT;\r\nstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\r\nint rc;\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: %s: slot_reset\n",\r\nha->host_no, __func__);\r\nif (!is_aer_supported(ha))\r\nreturn PCI_ERS_RESULT_NONE;\r\npci_restore_state(pdev);\r\npci_save_state(pdev);\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: %s: Can't re-enable "\r\n"device after reset\n", ha->host_no, __func__);\r\ngoto exit_slot_reset;\r\n}\r\nha->isp_ops->disable_intrs(ha);\r\nif (is_qla80XX(ha)) {\r\nif (qla4_8xxx_error_recovery(ha) == QLA_SUCCESS) {\r\nret = PCI_ERS_RESULT_RECOVERED;\r\ngoto exit_slot_reset;\r\n} else\r\ngoto exit_slot_reset;\r\n}\r\nexit_slot_reset:\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: %s: Return=%x\n"\r\n"device after reset\n", ha->host_no, __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void\r\nqla4xxx_pci_resume(struct pci_dev *pdev)\r\n{\r\nstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\r\nint ret;\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: %s: pci_resume\n",\r\nha->host_no, __func__);\r\nret = qla4xxx_wait_for_hba_online(ha);\r\nif (ret != QLA_SUCCESS) {\r\nql4_printk(KERN_ERR, ha, "scsi%ld: %s: the device failed to "\r\n"resume I/O from slot/link_reset\n", ha->host_no,\r\n__func__);\r\n}\r\npci_cleanup_aer_uncorrect_error_status(pdev);\r\nclear_bit(AF_EEH_BUSY, &ha->flags);\r\n}\r\nstatic int __init qla4xxx_module_init(void)\r\n{\r\nint ret;\r\nif (ql4xqfulltracking)\r\nqla4xxx_driver_template.track_queue_depth = 1;\r\nsrb_cachep = kmem_cache_create("qla4xxx_srbs", sizeof(struct srb), 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (srb_cachep == NULL) {\r\nprintk(KERN_ERR\r\n"%s: Unable to allocate SRB cache..."\r\n"Failing load!\n", DRIVER_NAME);\r\nret = -ENOMEM;\r\ngoto no_srp_cache;\r\n}\r\nstrcpy(qla4xxx_version_str, QLA4XXX_DRIVER_VERSION);\r\nif (ql4xextended_error_logging)\r\nstrcat(qla4xxx_version_str, "-debug");\r\nqla4xxx_scsi_transport =\r\niscsi_register_transport(&qla4xxx_iscsi_transport);\r\nif (!qla4xxx_scsi_transport){\r\nret = -ENODEV;\r\ngoto release_srb_cache;\r\n}\r\nret = pci_register_driver(&qla4xxx_pci_driver);\r\nif (ret)\r\ngoto unregister_transport;\r\nprintk(KERN_INFO "QLogic iSCSI HBA Driver\n");\r\nreturn 0;\r\nunregister_transport:\r\niscsi_unregister_transport(&qla4xxx_iscsi_transport);\r\nrelease_srb_cache:\r\nkmem_cache_destroy(srb_cachep);\r\nno_srp_cache:\r\nreturn ret;\r\n}\r\nstatic void __exit qla4xxx_module_exit(void)\r\n{\r\npci_unregister_driver(&qla4xxx_pci_driver);\r\niscsi_unregister_transport(&qla4xxx_iscsi_transport);\r\nkmem_cache_destroy(srb_cachep);\r\n}
