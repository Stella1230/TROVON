static int efi_pstore_open(struct pstore_info *psi)\r\n{\r\npsi->data = NULL;\r\nreturn 0;\r\n}\r\nstatic int efi_pstore_close(struct pstore_info *psi)\r\n{\r\npsi->data = NULL;\r\nreturn 0;\r\n}\r\nstatic inline u64 generic_id(unsigned long timestamp,\r\nunsigned int part, int count)\r\n{\r\nreturn ((u64) timestamp * 100 + part) * 1000 + count;\r\n}\r\nstatic int efi_pstore_read_func(struct efivar_entry *entry,\r\nstruct pstore_record *record)\r\n{\r\nefi_guid_t vendor = LINUX_EFI_CRASH_GUID;\r\nchar name[DUMP_NAME_LEN], data_type;\r\nint i;\r\nint cnt;\r\nunsigned int part;\r\nunsigned long time, size;\r\nif (efi_guidcmp(entry->var.VendorGuid, vendor))\r\nreturn 0;\r\nfor (i = 0; i < DUMP_NAME_LEN; i++)\r\nname[i] = entry->var.VariableName[i];\r\nif (sscanf(name, "dump-type%u-%u-%d-%lu-%c",\r\n&record->type, &part, &cnt, &time, &data_type) == 5) {\r\nrecord->id = generic_id(time, part, cnt);\r\nrecord->part = part;\r\nrecord->count = cnt;\r\nrecord->time.tv_sec = time;\r\nrecord->time.tv_nsec = 0;\r\nif (data_type == 'C')\r\nrecord->compressed = true;\r\nelse\r\nrecord->compressed = false;\r\nrecord->ecc_notice_size = 0;\r\n} else if (sscanf(name, "dump-type%u-%u-%d-%lu",\r\n&record->type, &part, &cnt, &time) == 4) {\r\nrecord->id = generic_id(time, part, cnt);\r\nrecord->part = part;\r\nrecord->count = cnt;\r\nrecord->time.tv_sec = time;\r\nrecord->time.tv_nsec = 0;\r\nrecord->compressed = false;\r\nrecord->ecc_notice_size = 0;\r\n} else if (sscanf(name, "dump-type%u-%u-%lu",\r\n&record->type, &part, &time) == 3) {\r\nrecord->id = generic_id(time, part, 0);\r\nrecord->part = part;\r\nrecord->count = 0;\r\nrecord->time.tv_sec = time;\r\nrecord->time.tv_nsec = 0;\r\nrecord->compressed = false;\r\nrecord->ecc_notice_size = 0;\r\n} else\r\nreturn 0;\r\nentry->var.DataSize = 1024;\r\n__efivar_entry_get(entry, &entry->var.Attributes,\r\n&entry->var.DataSize, entry->var.Data);\r\nsize = entry->var.DataSize;\r\nmemcpy(record->buf, entry->var.Data,\r\n(size_t)min_t(unsigned long, EFIVARS_DATA_SIZE_MAX, size));\r\nreturn size;\r\n}\r\nstatic void efi_pstore_scan_sysfs_enter(struct efivar_entry *pos,\r\nstruct efivar_entry *next,\r\nstruct list_head *head)\r\n{\r\npos->scanning = true;\r\nif (&next->list != head)\r\nnext->scanning = true;\r\n}\r\nstatic inline int __efi_pstore_scan_sysfs_exit(struct efivar_entry *entry,\r\nbool turn_off_scanning)\r\n{\r\nif (entry->deleting) {\r\nlist_del(&entry->list);\r\nefivar_entry_iter_end();\r\nefivar_unregister(entry);\r\nif (efivar_entry_iter_begin())\r\nreturn -EINTR;\r\n} else if (turn_off_scanning)\r\nentry->scanning = false;\r\nreturn 0;\r\n}\r\nstatic int efi_pstore_scan_sysfs_exit(struct efivar_entry *pos,\r\nstruct efivar_entry *next,\r\nstruct list_head *head, bool stop)\r\n{\r\nint ret = __efi_pstore_scan_sysfs_exit(pos, true);\r\nif (ret)\r\nreturn ret;\r\nif (stop)\r\nret = __efi_pstore_scan_sysfs_exit(next, &next->list != head);\r\nreturn ret;\r\n}\r\nstatic int efi_pstore_sysfs_entry_iter(struct pstore_record *record)\r\n{\r\nstruct efivar_entry **pos = (struct efivar_entry **)&record->psi->data;\r\nstruct efivar_entry *entry, *n;\r\nstruct list_head *head = &efivar_sysfs_list;\r\nint size = 0;\r\nint ret;\r\nif (!*pos) {\r\nlist_for_each_entry_safe(entry, n, head, list) {\r\nefi_pstore_scan_sysfs_enter(entry, n, head);\r\nsize = efi_pstore_read_func(entry, record);\r\nret = efi_pstore_scan_sysfs_exit(entry, n, head,\r\nsize < 0);\r\nif (ret)\r\nreturn ret;\r\nif (size)\r\nbreak;\r\n}\r\n*pos = n;\r\nreturn size;\r\n}\r\nlist_for_each_entry_safe_from((*pos), n, head, list) {\r\nefi_pstore_scan_sysfs_enter((*pos), n, head);\r\nsize = efi_pstore_read_func((*pos), record);\r\nret = efi_pstore_scan_sysfs_exit((*pos), n, head, size < 0);\r\nif (ret)\r\nreturn ret;\r\nif (size)\r\nbreak;\r\n}\r\n*pos = n;\r\nreturn size;\r\n}\r\nstatic ssize_t efi_pstore_read(struct pstore_record *record)\r\n{\r\nssize_t size;\r\nrecord->buf = kzalloc(EFIVARS_DATA_SIZE_MAX, GFP_KERNEL);\r\nif (!record->buf)\r\nreturn -ENOMEM;\r\nif (efivar_entry_iter_begin()) {\r\nsize = -EINTR;\r\ngoto out;\r\n}\r\nsize = efi_pstore_sysfs_entry_iter(record);\r\nefivar_entry_iter_end();\r\nout:\r\nif (size <= 0) {\r\nkfree(record->buf);\r\nrecord->buf = NULL;\r\n}\r\nreturn size;\r\n}\r\nstatic int efi_pstore_write(struct pstore_record *record)\r\n{\r\nchar name[DUMP_NAME_LEN];\r\nefi_char16_t efi_name[DUMP_NAME_LEN];\r\nefi_guid_t vendor = LINUX_EFI_CRASH_GUID;\r\nint i, ret = 0;\r\nrecord->id = generic_id(record->time.tv_sec, record->part,\r\nrecord->count);\r\nmemset(name, 0, sizeof(name));\r\nsnprintf(name, sizeof(name), "dump-type%u-%u-%d-%lu-%c",\r\nrecord->type, record->part, record->count,\r\nrecord->time.tv_sec, record->compressed ? 'C' : 'D');\r\nfor (i = 0; i < DUMP_NAME_LEN; i++)\r\nefi_name[i] = name[i];\r\nret = efivar_entry_set_safe(efi_name, vendor, PSTORE_EFI_ATTRIBUTES,\r\n!pstore_cannot_block_path(record->reason),\r\nrecord->size, record->psi->buf);\r\nif (record->reason == KMSG_DUMP_OOPS)\r\nefivar_run_worker();\r\nreturn ret;\r\n}\r\nstatic int efi_pstore_erase_func(struct efivar_entry *entry, void *data)\r\n{\r\nefi_char16_t *efi_name = data;\r\nefi_guid_t vendor = LINUX_EFI_CRASH_GUID;\r\nunsigned long ucs2_len = ucs2_strlen(efi_name);\r\nif (efi_guidcmp(entry->var.VendorGuid, vendor))\r\nreturn 0;\r\nif (ucs2_strncmp(entry->var.VariableName, efi_name, (size_t)ucs2_len))\r\nreturn 0;\r\nif (entry->scanning) {\r\nentry->deleting = true;\r\n} else\r\nlist_del(&entry->list);\r\n__efivar_entry_delete(entry);\r\nreturn 1;\r\n}\r\nstatic int efi_pstore_erase_name(const char *name)\r\n{\r\nstruct efivar_entry *entry = NULL;\r\nefi_char16_t efi_name[DUMP_NAME_LEN];\r\nint found, i;\r\nfor (i = 0; i < DUMP_NAME_LEN; i++) {\r\nefi_name[i] = name[i];\r\nif (name[i] == '\0')\r\nbreak;\r\n}\r\nif (efivar_entry_iter_begin())\r\nreturn -EINTR;\r\nfound = __efivar_entry_iter(efi_pstore_erase_func, &efivar_sysfs_list,\r\nefi_name, &entry);\r\nefivar_entry_iter_end();\r\nif (found && !entry->scanning)\r\nefivar_unregister(entry);\r\nreturn found ? 0 : -ENOENT;\r\n}\r\nstatic int efi_pstore_erase(struct pstore_record *record)\r\n{\r\nchar name[DUMP_NAME_LEN];\r\nint ret;\r\nsnprintf(name, sizeof(name), "dump-type%u-%u-%d-%lu",\r\nrecord->type, record->part, record->count,\r\nrecord->time.tv_sec);\r\nret = efi_pstore_erase_name(name);\r\nif (ret != -ENOENT)\r\nreturn ret;\r\nsnprintf(name, sizeof(name), "dump-type%u-%u-%lu",\r\nrecord->type, record->part, record->time.tv_sec);\r\nret = efi_pstore_erase_name(name);\r\nreturn ret;\r\n}\r\nstatic __init int efivars_pstore_init(void)\r\n{\r\nif (!efi_enabled(EFI_RUNTIME_SERVICES))\r\nreturn 0;\r\nif (!efivars_kobject())\r\nreturn 0;\r\nif (efivars_pstore_disable)\r\nreturn 0;\r\nefi_pstore_info.buf = kmalloc(4096, GFP_KERNEL);\r\nif (!efi_pstore_info.buf)\r\nreturn -ENOMEM;\r\nefi_pstore_info.bufsize = 1024;\r\nspin_lock_init(&efi_pstore_info.buf_lock);\r\nif (pstore_register(&efi_pstore_info)) {\r\nkfree(efi_pstore_info.buf);\r\nefi_pstore_info.buf = NULL;\r\nefi_pstore_info.bufsize = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic __exit void efivars_pstore_exit(void)\r\n{\r\nif (!efi_pstore_info.bufsize)\r\nreturn;\r\npstore_unregister(&efi_pstore_info);\r\nkfree(efi_pstore_info.buf);\r\nefi_pstore_info.buf = NULL;\r\nefi_pstore_info.bufsize = 0;\r\n}
