static void number_of_connections(struct mei_cl_device *cldev)\r\n{\r\ndev_dbg(&cldev->dev, "running hook %s\n", __func__);\r\nif (cldev->me_cl->props.max_number_of_connections > 1)\r\ncldev->do_match = 0;\r\n}\r\nstatic void blacklist(struct mei_cl_device *cldev)\r\n{\r\ndev_dbg(&cldev->dev, "running hook %s\n", __func__);\r\ncldev->do_match = 0;\r\n}\r\nstatic int mei_osver(struct mei_cl_device *cldev)\r\n{\r\nconst size_t size = MKHI_OSVER_BUF_LEN;\r\nchar buf[MKHI_OSVER_BUF_LEN];\r\nstruct mkhi_msg *req;\r\nstruct mkhi_fwcaps *fwcaps;\r\nstruct mei_os_ver *os_ver;\r\nunsigned int mode = MEI_CL_IO_TX_BLOCKING | MEI_CL_IO_TX_INTERNAL;\r\nmemset(buf, 0, size);\r\nreq = (struct mkhi_msg *)buf;\r\nreq->hdr.group_id = MKHI_FWCAPS_GROUP_ID;\r\nreq->hdr.command = MKHI_FWCAPS_SET_OS_VER_APP_RULE_CMD;\r\nfwcaps = (struct mkhi_fwcaps *)req->data;\r\nfwcaps->id.rule_type = 0x0;\r\nfwcaps->id.feature_id = MKHI_FEATURE_PTT;\r\nfwcaps->len = sizeof(*os_ver);\r\nos_ver = (struct mei_os_ver *)fwcaps->data;\r\nos_ver->os_type = OSTYPE_LINUX;\r\nreturn __mei_cl_send(cldev->cl, buf, size, mode);\r\n}\r\nstatic void mei_mkhi_fix(struct mei_cl_device *cldev)\r\n{\r\nint ret;\r\nif (!cldev->bus->hbm_f_os_supported)\r\nreturn;\r\nret = mei_cldev_enable(cldev);\r\nif (ret)\r\nreturn;\r\nret = mei_osver(cldev);\r\nif (ret < 0)\r\ndev_err(&cldev->dev, "OS version command failed %d\n", ret);\r\nmei_cldev_disable(cldev);\r\n}\r\nstatic void mei_wd(struct mei_cl_device *cldev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(cldev->dev.parent);\r\ndev_dbg(&cldev->dev, "running hook %s\n", __func__);\r\nif (pdev->device == MEI_DEV_ID_WPT_LP ||\r\npdev->device == MEI_DEV_ID_SPT ||\r\npdev->device == MEI_DEV_ID_SPT_H)\r\ncldev->me_cl->props.protocol_version = 0x2;\r\ncldev->do_match = 1;\r\n}\r\nstatic inline void mei_wd(struct mei_cl_device *cldev) {}\r\nstatic int mei_nfc_if_version(struct mei_cl *cl,\r\nstruct mei_nfc_if_version *ver)\r\n{\r\nstruct mei_device *bus;\r\nstruct mei_nfc_cmd cmd = {\r\n.command = MEI_NFC_CMD_MAINTENANCE,\r\n.data_size = 1,\r\n.sub_command = MEI_NFC_SUBCMD_IF_VERSION,\r\n};\r\nstruct mei_nfc_reply *reply = NULL;\r\nsize_t if_version_length;\r\nint bytes_recv, ret;\r\nbus = cl->dev;\r\nWARN_ON(mutex_is_locked(&bus->device_lock));\r\nret = __mei_cl_send(cl, (u8 *)&cmd, sizeof(struct mei_nfc_cmd),\r\nMEI_CL_IO_TX_BLOCKING);\r\nif (ret < 0) {\r\ndev_err(bus->dev, "Could not send IF version cmd\n");\r\nreturn ret;\r\n}\r\nif_version_length = sizeof(struct mei_nfc_reply) +\r\nsizeof(struct mei_nfc_if_version);\r\nreply = kzalloc(if_version_length, GFP_KERNEL);\r\nif (!reply)\r\nreturn -ENOMEM;\r\nret = 0;\r\nbytes_recv = __mei_cl_recv(cl, (u8 *)reply, if_version_length, 0);\r\nif (bytes_recv < if_version_length) {\r\ndev_err(bus->dev, "Could not read IF version\n");\r\nret = -EIO;\r\ngoto err;\r\n}\r\nmemcpy(ver, reply->data, sizeof(struct mei_nfc_if_version));\r\ndev_info(bus->dev, "NFC MEI VERSION: IVN 0x%x Vendor ID 0x%x Type 0x%x\n",\r\nver->fw_ivn, ver->vendor_id, ver->radio_type);\r\nerr:\r\nkfree(reply);\r\nreturn ret;\r\n}\r\nstatic const char *mei_nfc_radio_name(struct mei_nfc_if_version *ver)\r\n{\r\nif (ver->vendor_id == MEI_NFC_VENDOR_INSIDE) {\r\nif (ver->radio_type == MEI_NFC_VENDOR_INSIDE_UREAD)\r\nreturn "microread";\r\n}\r\nif (ver->vendor_id == MEI_NFC_VENDOR_NXP) {\r\nif (ver->radio_type == MEI_NFC_VENDOR_NXP_PN544)\r\nreturn "pn544";\r\n}\r\nreturn NULL;\r\n}\r\nstatic void mei_nfc(struct mei_cl_device *cldev)\r\n{\r\nstruct mei_device *bus;\r\nstruct mei_cl *cl;\r\nstruct mei_me_client *me_cl = NULL;\r\nstruct mei_nfc_if_version ver;\r\nconst char *radio_name = NULL;\r\nint ret;\r\nbus = cldev->bus;\r\ndev_dbg(&cldev->dev, "running hook %s\n", __func__);\r\nmutex_lock(&bus->device_lock);\r\ncl = mei_cl_alloc_linked(bus);\r\nif (IS_ERR(cl)) {\r\nret = PTR_ERR(cl);\r\ncl = NULL;\r\ndev_err(bus->dev, "nfc hook alloc failed %d\n", ret);\r\ngoto out;\r\n}\r\nme_cl = mei_me_cl_by_uuid(bus, &mei_nfc_info_guid);\r\nif (!me_cl) {\r\nret = -ENOTTY;\r\ndev_err(bus->dev, "Cannot find nfc info %d\n", ret);\r\ngoto out;\r\n}\r\nret = mei_cl_connect(cl, me_cl, NULL);\r\nif (ret < 0) {\r\ndev_err(&cldev->dev, "Can't connect to the NFC INFO ME ret = %d\n",\r\nret);\r\ngoto out;\r\n}\r\nmutex_unlock(&bus->device_lock);\r\nret = mei_nfc_if_version(cl, &ver);\r\nif (ret)\r\ngoto disconnect;\r\nradio_name = mei_nfc_radio_name(&ver);\r\nif (!radio_name) {\r\nret = -ENOENT;\r\ndev_err(&cldev->dev, "Can't get the NFC interface version ret = %d\n",\r\nret);\r\ngoto disconnect;\r\n}\r\ndev_dbg(bus->dev, "nfc radio %s\n", radio_name);\r\nstrlcpy(cldev->name, radio_name, sizeof(cldev->name));\r\ndisconnect:\r\nmutex_lock(&bus->device_lock);\r\nif (mei_cl_disconnect(cl) < 0)\r\ndev_err(bus->dev, "Can't disconnect the NFC INFO ME\n");\r\nmei_cl_flush_queues(cl, NULL);\r\nout:\r\nmei_cl_unlink(cl);\r\nmutex_unlock(&bus->device_lock);\r\nmei_me_cl_put(me_cl);\r\nkfree(cl);\r\nif (ret)\r\ncldev->do_match = 0;\r\ndev_dbg(bus->dev, "end of fixup match = %d\n", cldev->do_match);\r\n}\r\nvoid mei_cl_bus_dev_fixup(struct mei_cl_device *cldev)\r\n{\r\nstruct mei_fixup *f;\r\nconst uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mei_fixups); i++) {\r\nf = &mei_fixups[i];\r\nif (uuid_le_cmp(f->uuid, MEI_UUID_ANY) == 0 ||\r\nuuid_le_cmp(f->uuid, *uuid) == 0)\r\nf->hook(cldev);\r\n}\r\n}
