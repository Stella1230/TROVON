static int vimc_create_links(struct vimc_device *vimc)\r\n{\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < vimc->pipe_cfg->num_links; i++) {\r\nconst struct vimc_ent_link *link = &vimc->pipe_cfg->links[i];\r\nstruct vimc_ent_device *ved_src =\r\nplatform_get_drvdata(vimc->subdevs[link->src_ent]);\r\nstruct vimc_ent_device *ved_sink =\r\nplatform_get_drvdata(vimc->subdevs[link->sink_ent]);\r\nret = media_create_pad_link(ved_src->ent, link->src_pad,\r\nved_sink->ent, link->sink_pad,\r\nlink->flags);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vimc_comp_bind(struct device *master)\r\n{\r\nstruct vimc_device *vimc = container_of(to_platform_device(master),\r\nstruct vimc_device, pdev);\r\nint ret;\r\ndev_dbg(master, "bind");\r\nret = v4l2_device_register(vimc->mdev.dev, &vimc->v4l2_dev);\r\nif (ret) {\r\ndev_err(vimc->mdev.dev,\r\n"v4l2 device register failed (err=%d)\n", ret);\r\nreturn ret;\r\n}\r\nret = component_bind_all(master, &vimc->v4l2_dev);\r\nif (ret)\r\ngoto err_v4l2_unregister;\r\nret = vimc_create_links(vimc);\r\nif (ret)\r\ngoto err_comp_unbind_all;\r\nret = media_device_register(&vimc->mdev);\r\nif (ret) {\r\ndev_err(vimc->mdev.dev,\r\n"media device register failed (err=%d)\n", ret);\r\ngoto err_comp_unbind_all;\r\n}\r\nret = v4l2_device_register_subdev_nodes(&vimc->v4l2_dev);\r\nif (ret) {\r\ndev_err(vimc->mdev.dev,\r\n"vimc subdev nodes registration failed (err=%d)\n",\r\nret);\r\ngoto err_mdev_unregister;\r\n}\r\nreturn 0;\r\nerr_mdev_unregister:\r\nmedia_device_unregister(&vimc->mdev);\r\nerr_comp_unbind_all:\r\ncomponent_unbind_all(master, NULL);\r\nerr_v4l2_unregister:\r\nv4l2_device_unregister(&vimc->v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic void vimc_comp_unbind(struct device *master)\r\n{\r\nstruct vimc_device *vimc = container_of(to_platform_device(master),\r\nstruct vimc_device, pdev);\r\ndev_dbg(master, "unbind");\r\nmedia_device_unregister(&vimc->mdev);\r\ncomponent_unbind_all(master, NULL);\r\nv4l2_device_unregister(&vimc->v4l2_dev);\r\n}\r\nstatic int vimc_comp_compare(struct device *comp, void *data)\r\n{\r\nconst struct platform_device *pdev = to_platform_device(comp);\r\nconst char *name = data;\r\nreturn !strcmp(pdev->dev.platform_data, name);\r\n}\r\nstatic struct component_match *vimc_add_subdevs(struct vimc_device *vimc)\r\n{\r\nstruct component_match *match = NULL;\r\nstruct vimc_platform_data pdata;\r\nint i;\r\nfor (i = 0; i < vimc->pipe_cfg->num_ents; i++) {\r\ndev_dbg(&vimc->pdev.dev, "new pdev for %s\n",\r\nvimc->pipe_cfg->ents[i].drv);\r\nstrlcpy(pdata.entity_name, vimc->pipe_cfg->ents[i].name,\r\nsizeof(pdata.entity_name));\r\nvimc->subdevs[i] = platform_device_register_data(&vimc->pdev.dev,\r\nvimc->pipe_cfg->ents[i].drv,\r\nPLATFORM_DEVID_AUTO,\r\n&pdata,\r\nsizeof(pdata));\r\nif (!vimc->subdevs[i]) {\r\nwhile (--i >= 0)\r\nplatform_device_unregister(vimc->subdevs[i]);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ncomponent_match_add(&vimc->pdev.dev, &match, vimc_comp_compare,\r\n(void *)vimc->pipe_cfg->ents[i].name);\r\n}\r\nreturn match;\r\n}\r\nstatic void vimc_rm_subdevs(struct vimc_device *vimc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < vimc->pipe_cfg->num_ents; i++)\r\nplatform_device_unregister(vimc->subdevs[i]);\r\n}\r\nstatic int vimc_probe(struct platform_device *pdev)\r\n{\r\nstruct vimc_device *vimc = container_of(pdev, struct vimc_device, pdev);\r\nstruct component_match *match = NULL;\r\nint ret;\r\ndev_dbg(&pdev->dev, "probe");\r\nvimc->subdevs = devm_kcalloc(&vimc->pdev.dev, vimc->pipe_cfg->num_ents,\r\nsizeof(*vimc->subdevs), GFP_KERNEL);\r\nif (!vimc->subdevs)\r\nreturn -ENOMEM;\r\nmatch = vimc_add_subdevs(vimc);\r\nif (IS_ERR(match))\r\nreturn PTR_ERR(match);\r\nvimc->v4l2_dev.mdev = &vimc->mdev;\r\nstrlcpy(vimc->mdev.model, VIMC_MDEV_MODEL_NAME,\r\nsizeof(vimc->mdev.model));\r\nvimc->mdev.dev = &pdev->dev;\r\nmedia_device_init(&vimc->mdev);\r\nret = component_master_add_with_match(&pdev->dev, &vimc_comp_ops,\r\nmatch);\r\nif (ret) {\r\nmedia_device_cleanup(&vimc->mdev);\r\nvimc_rm_subdevs(vimc);\r\nkfree(vimc);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vimc_remove(struct platform_device *pdev)\r\n{\r\nstruct vimc_device *vimc = container_of(pdev, struct vimc_device, pdev);\r\ndev_dbg(&pdev->dev, "remove");\r\ncomponent_master_del(&pdev->dev, &vimc_comp_ops);\r\nvimc_rm_subdevs(vimc);\r\nreturn 0;\r\n}\r\nstatic void vimc_dev_release(struct device *dev)\r\n{\r\n}\r\nstatic int __init vimc_init(void)\r\n{\r\nint ret;\r\nret = platform_device_register(&vimc_dev.pdev);\r\nif (ret) {\r\ndev_err(&vimc_dev.pdev.dev,\r\n"platform device registration failed (err=%d)\n", ret);\r\nreturn ret;\r\n}\r\nret = platform_driver_register(&vimc_pdrv);\r\nif (ret) {\r\ndev_err(&vimc_dev.pdev.dev,\r\n"platform driver registration failed (err=%d)\n", ret);\r\nplatform_driver_unregister(&vimc_pdrv);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit vimc_exit(void)\r\n{\r\nplatform_driver_unregister(&vimc_pdrv);\r\nplatform_device_unregister(&vimc_dev.pdev);\r\n}
