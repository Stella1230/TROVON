static int electra_cf_present(struct electra_cf_socket *cf)\r\n{\r\nunsigned int gpio;\r\ngpio = in_le32(cf->gpio_base+0x40);\r\nreturn !(gpio & (1 << cf->gpio_detect));\r\n}\r\nstatic int electra_cf_ss_init(struct pcmcia_socket *s)\r\n{\r\nreturn 0;\r\n}\r\nstatic void electra_cf_timer(unsigned long _cf)\r\n{\r\nstruct electra_cf_socket *cf = (void *) _cf;\r\nint present = electra_cf_present(cf);\r\nif (present != cf->present) {\r\ncf->present = present;\r\npcmcia_parse_events(&cf->socket, SS_DETECT);\r\n}\r\nif (cf->active)\r\nmod_timer(&cf->timer, jiffies + POLL_INTERVAL);\r\n}\r\nstatic irqreturn_t electra_cf_irq(int irq, void *_cf)\r\n{\r\nelectra_cf_timer((unsigned long)_cf);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int electra_cf_get_status(struct pcmcia_socket *s, u_int *sp)\r\n{\r\nstruct electra_cf_socket *cf;\r\nif (!sp)\r\nreturn -EINVAL;\r\ncf = container_of(s, struct electra_cf_socket, socket);\r\nif (electra_cf_present(cf)) {\r\n*sp = SS_READY | SS_DETECT | SS_POWERON | SS_3VCARD;\r\ns->pci_irq = cf->irq;\r\n} else\r\n*sp = 0;\r\nreturn 0;\r\n}\r\nstatic int electra_cf_set_socket(struct pcmcia_socket *sock,\r\nstruct socket_state_t *s)\r\n{\r\nunsigned int gpio;\r\nunsigned int vcc;\r\nstruct electra_cf_socket *cf;\r\ncf = container_of(sock, struct electra_cf_socket, socket);\r\nvcc = (s->flags & SS_RESET) ? 0 : s->Vcc;\r\nswitch (vcc) {\r\ncase 0:\r\ngpio = 0;\r\nbreak;\r\ncase 33:\r\ngpio = (1 << cf->gpio_3v);\r\nbreak;\r\ncase 5:\r\ngpio = (1 << cf->gpio_5v);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ngpio |= 1 << (cf->gpio_3v + 16);\r\ngpio |= 1 << (cf->gpio_5v + 16);\r\nout_le32(cf->gpio_base+0x90, gpio);\r\npr_debug("%s: Vcc %d, io_irq %d, flags %04x csc %04x\n",\r\ndriver_name, s->Vcc, s->io_irq, s->flags, s->csc_mask);\r\nreturn 0;\r\n}\r\nstatic int electra_cf_set_io_map(struct pcmcia_socket *s,\r\nstruct pccard_io_map *io)\r\n{\r\nreturn 0;\r\n}\r\nstatic int electra_cf_set_mem_map(struct pcmcia_socket *s,\r\nstruct pccard_mem_map *map)\r\n{\r\nstruct electra_cf_socket *cf;\r\nif (map->card_start)\r\nreturn -EINVAL;\r\ncf = container_of(s, struct electra_cf_socket, socket);\r\nmap->static_start = cf->mem_phys;\r\nmap->flags &= MAP_ACTIVE|MAP_ATTRIB;\r\nif (!(map->flags & MAP_ATTRIB))\r\nmap->static_start += 0x800;\r\nreturn 0;\r\n}\r\nstatic int electra_cf_probe(struct platform_device *ofdev)\r\n{\r\nstruct device *device = &ofdev->dev;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct electra_cf_socket *cf;\r\nstruct resource mem, io;\r\nint status;\r\nconst unsigned int *prop;\r\nint err;\r\nstruct vm_struct *area;\r\nerr = of_address_to_resource(np, 0, &mem);\r\nif (err)\r\nreturn -EINVAL;\r\nerr = of_address_to_resource(np, 1, &io);\r\nif (err)\r\nreturn -EINVAL;\r\ncf = kzalloc(sizeof(*cf), GFP_KERNEL);\r\nif (!cf)\r\nreturn -ENOMEM;\r\nsetup_timer(&cf->timer, electra_cf_timer, (unsigned long)cf);\r\ncf->irq = 0;\r\ncf->ofdev = ofdev;\r\ncf->mem_phys = mem.start;\r\ncf->mem_size = PAGE_ALIGN(resource_size(&mem));\r\ncf->mem_base = ioremap(cf->mem_phys, cf->mem_size);\r\ncf->io_size = PAGE_ALIGN(resource_size(&io));\r\narea = __get_vm_area(cf->io_size, 0, PHB_IO_BASE, PHB_IO_END);\r\nif (area == NULL) {\r\nstatus = -ENOMEM;\r\ngoto fail1;\r\n}\r\ncf->io_virt = (void __iomem *)(area->addr);\r\ncf->gpio_base = ioremap(0xfc103000, 0x1000);\r\ndev_set_drvdata(device, cf);\r\nif (!cf->mem_base || !cf->io_virt || !cf->gpio_base ||\r\n(__ioremap_at(io.start, cf->io_virt, cf->io_size,\r\npgprot_val(pgprot_noncached(__pgprot(0)))) == NULL)) {\r\ndev_err(device, "can't ioremap ranges\n");\r\nstatus = -ENOMEM;\r\ngoto fail1;\r\n}\r\ncf->io_base = (unsigned long)cf->io_virt - VMALLOC_END;\r\ncf->iomem.start = (unsigned long)cf->mem_base;\r\ncf->iomem.end = (unsigned long)cf->mem_base + (mem.end - mem.start);\r\ncf->iomem.flags = IORESOURCE_MEM;\r\ncf->irq = irq_of_parse_and_map(np, 0);\r\nstatus = request_irq(cf->irq, electra_cf_irq, IRQF_SHARED,\r\ndriver_name, cf);\r\nif (status < 0) {\r\ndev_err(device, "request_irq failed\n");\r\ngoto fail1;\r\n}\r\ncf->socket.pci_irq = cf->irq;\r\nprop = of_get_property(np, "card-detect-gpio", NULL);\r\nif (!prop)\r\ngoto fail1;\r\ncf->gpio_detect = *prop;\r\nprop = of_get_property(np, "card-vsense-gpio", NULL);\r\nif (!prop)\r\ngoto fail1;\r\ncf->gpio_vsense = *prop;\r\nprop = of_get_property(np, "card-3v-gpio", NULL);\r\nif (!prop)\r\ngoto fail1;\r\ncf->gpio_3v = *prop;\r\nprop = of_get_property(np, "card-5v-gpio", NULL);\r\nif (!prop)\r\ngoto fail1;\r\ncf->gpio_5v = *prop;\r\ncf->socket.io_offset = cf->io_base;\r\nif (!request_mem_region(cf->mem_phys, cf->mem_size, driver_name)) {\r\nstatus = -ENXIO;\r\ndev_err(device, "Can't claim memory region\n");\r\ngoto fail1;\r\n}\r\nif (!request_region(cf->io_base, cf->io_size, driver_name)) {\r\nstatus = -ENXIO;\r\ndev_err(device, "Can't claim I/O region\n");\r\ngoto fail2;\r\n}\r\ncf->socket.owner = THIS_MODULE;\r\ncf->socket.dev.parent = &ofdev->dev;\r\ncf->socket.ops = &electra_cf_ops;\r\ncf->socket.resource_ops = &pccard_static_ops;\r\ncf->socket.features = SS_CAP_PCCARD | SS_CAP_STATIC_MAP |\r\nSS_CAP_MEM_ALIGN;\r\ncf->socket.map_size = 0x800;\r\nstatus = pcmcia_register_socket(&cf->socket);\r\nif (status < 0) {\r\ndev_err(device, "pcmcia_register_socket failed\n");\r\ngoto fail3;\r\n}\r\ndev_info(device, "at mem 0x%lx io 0x%llx irq %d\n",\r\ncf->mem_phys, io.start, cf->irq);\r\ncf->active = 1;\r\nelectra_cf_timer((unsigned long)cf);\r\nreturn 0;\r\nfail3:\r\nrelease_region(cf->io_base, cf->io_size);\r\nfail2:\r\nrelease_mem_region(cf->mem_phys, cf->mem_size);\r\nfail1:\r\nif (cf->irq)\r\nfree_irq(cf->irq, cf);\r\nif (cf->io_virt)\r\n__iounmap_at(cf->io_virt, cf->io_size);\r\nif (cf->mem_base)\r\niounmap(cf->mem_base);\r\nif (cf->gpio_base)\r\niounmap(cf->gpio_base);\r\nif (area)\r\ndevice_init_wakeup(&ofdev->dev, 0);\r\nkfree(cf);\r\nreturn status;\r\n}\r\nstatic int electra_cf_remove(struct platform_device *ofdev)\r\n{\r\nstruct device *device = &ofdev->dev;\r\nstruct electra_cf_socket *cf;\r\ncf = dev_get_drvdata(device);\r\ncf->active = 0;\r\npcmcia_unregister_socket(&cf->socket);\r\nfree_irq(cf->irq, cf);\r\ndel_timer_sync(&cf->timer);\r\n__iounmap_at(cf->io_virt, cf->io_size);\r\niounmap(cf->mem_base);\r\niounmap(cf->gpio_base);\r\nrelease_mem_region(cf->mem_phys, cf->mem_size);\r\nrelease_region(cf->io_base, cf->io_size);\r\nkfree(cf);\r\nreturn 0;\r\n}
