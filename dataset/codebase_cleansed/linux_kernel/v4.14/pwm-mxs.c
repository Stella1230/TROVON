static int mxs_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct mxs_pwm_chip *mxs = to_mxs_pwm_chip(chip);\r\nint ret, div = 0;\r\nunsigned int period_cycles, duty_cycles;\r\nunsigned long rate;\r\nunsigned long long c;\r\nrate = clk_get_rate(mxs->clk);\r\nwhile (1) {\r\nc = rate / cdiv[div];\r\nc = c * period_ns;\r\ndo_div(c, 1000000000);\r\nif (c < PERIOD_PERIOD_MAX)\r\nbreak;\r\ndiv++;\r\nif (div >= PERIOD_CDIV_MAX)\r\nreturn -EINVAL;\r\n}\r\nperiod_cycles = c;\r\nc *= duty_ns;\r\ndo_div(c, period_ns);\r\nduty_cycles = c;\r\nif (!pwm_is_enabled(pwm)) {\r\nret = clk_prepare_enable(mxs->clk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nwritel(duty_cycles << 16,\r\nmxs->base + PWM_ACTIVE0 + pwm->hwpwm * 0x20);\r\nwritel(PERIOD_PERIOD(period_cycles) | PERIOD_ACTIVE_HIGH |\r\nPERIOD_INACTIVE_LOW | PERIOD_CDIV(div),\r\nmxs->base + PWM_PERIOD0 + pwm->hwpwm * 0x20);\r\nif (!pwm_is_enabled(pwm))\r\nclk_disable_unprepare(mxs->clk);\r\nreturn 0;\r\n}\r\nstatic int mxs_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct mxs_pwm_chip *mxs = to_mxs_pwm_chip(chip);\r\nint ret;\r\nret = clk_prepare_enable(mxs->clk);\r\nif (ret)\r\nreturn ret;\r\nwritel(1 << pwm->hwpwm, mxs->base + PWM_CTRL + SET);\r\nreturn 0;\r\n}\r\nstatic void mxs_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct mxs_pwm_chip *mxs = to_mxs_pwm_chip(chip);\r\nwritel(1 << pwm->hwpwm, mxs->base + PWM_CTRL + CLR);\r\nclk_disable_unprepare(mxs->clk);\r\n}\r\nstatic int mxs_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct mxs_pwm_chip *mxs;\r\nstruct resource *res;\r\nint ret;\r\nmxs = devm_kzalloc(&pdev->dev, sizeof(*mxs), GFP_KERNEL);\r\nif (!mxs)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmxs->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mxs->base))\r\nreturn PTR_ERR(mxs->base);\r\nmxs->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(mxs->clk))\r\nreturn PTR_ERR(mxs->clk);\r\nmxs->chip.dev = &pdev->dev;\r\nmxs->chip.ops = &mxs_pwm_ops;\r\nmxs->chip.base = -1;\r\nret = of_property_read_u32(np, "fsl,pwm-number", &mxs->chip.npwm);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get pwm number: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = pwmchip_add(&mxs->chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to add pwm chip %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, mxs);\r\nret = stmp_reset_block(mxs->base);\r\nif (ret)\r\ngoto pwm_remove;\r\nreturn 0;\r\npwm_remove:\r\npwmchip_remove(&mxs->chip);\r\nreturn ret;\r\n}\r\nstatic int mxs_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct mxs_pwm_chip *mxs = platform_get_drvdata(pdev);\r\nreturn pwmchip_remove(&mxs->chip);\r\n}
