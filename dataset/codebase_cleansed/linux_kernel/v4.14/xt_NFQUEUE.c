static unsigned int\r\nnfqueue_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_NFQ_info *tinfo = par->targinfo;\r\nreturn NF_QUEUE_NR(tinfo->queuenum);\r\n}\r\nstatic unsigned int\r\nnfqueue_tg_v1(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_NFQ_info_v1 *info = par->targinfo;\r\nu32 queue = info->queuenum;\r\nif (info->queues_total > 1) {\r\nqueue = nfqueue_hash(skb, queue, info->queues_total,\r\nxt_family(par), jhash_initval);\r\n}\r\nreturn NF_QUEUE_NR(queue);\r\n}\r\nstatic unsigned int\r\nnfqueue_tg_v2(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_NFQ_info_v2 *info = par->targinfo;\r\nunsigned int ret = nfqueue_tg_v1(skb, par);\r\nif (info->bypass)\r\nret |= NF_VERDICT_FLAG_QUEUE_BYPASS;\r\nreturn ret;\r\n}\r\nstatic int nfqueue_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct xt_NFQ_info_v3 *info = par->targinfo;\r\nu32 maxid;\r\ninit_hashrandom(&jhash_initval);\r\nif (info->queues_total == 0) {\r\npr_err("NFQUEUE: number of total queues is 0\n");\r\nreturn -EINVAL;\r\n}\r\nmaxid = info->queues_total - 1 + info->queuenum;\r\nif (maxid > 0xffff) {\r\npr_err("NFQUEUE: number of queues (%u) out of range (got %u)\n",\r\ninfo->queues_total, maxid);\r\nreturn -ERANGE;\r\n}\r\nif (par->target->revision == 2 && info->flags > 1)\r\nreturn -EINVAL;\r\nif (par->target->revision == 3 && info->flags & ~NFQ_FLAG_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\nnfqueue_tg_v3(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_NFQ_info_v3 *info = par->targinfo;\r\nu32 queue = info->queuenum;\r\nint ret;\r\nif (info->queues_total > 1) {\r\nif (info->flags & NFQ_FLAG_CPU_FANOUT) {\r\nint cpu = smp_processor_id();\r\nqueue = info->queuenum + cpu % info->queues_total;\r\n} else {\r\nqueue = nfqueue_hash(skb, queue, info->queues_total,\r\nxt_family(par), jhash_initval);\r\n}\r\n}\r\nret = NF_QUEUE_NR(queue);\r\nif (info->flags & NFQ_FLAG_BYPASS)\r\nret |= NF_VERDICT_FLAG_QUEUE_BYPASS;\r\nreturn ret;\r\n}\r\nstatic int __init nfqueue_tg_init(void)\r\n{\r\nreturn xt_register_targets(nfqueue_tg_reg, ARRAY_SIZE(nfqueue_tg_reg));\r\n}\r\nstatic void __exit nfqueue_tg_exit(void)\r\n{\r\nxt_unregister_targets(nfqueue_tg_reg, ARRAY_SIZE(nfqueue_tg_reg));\r\n}
