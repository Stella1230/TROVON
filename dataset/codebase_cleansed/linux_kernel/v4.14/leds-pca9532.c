static int pca9532_calcpwm(struct i2c_client *client, int pwm, int blink,\r\nenum led_brightness value)\r\n{\r\nint a = 0, b = 0, i = 0;\r\nstruct pca9532_data *data = i2c_get_clientdata(client);\r\nfor (i = 0; i < data->chip_info->num_leds; i++) {\r\nif (data->leds[i].type == PCA9532_TYPE_LED &&\r\ndata->leds[i].state == PCA9532_PWM0+pwm) {\r\na++;\r\nb += data->leds[i].ldev.brightness;\r\n}\r\n}\r\nif (a == 0) {\r\ndev_err(&client->dev,\r\n"fear of division by zero %d/%d, wanted %d\n",\r\nb, a, value);\r\nreturn -EINVAL;\r\n}\r\nb = b/a;\r\nif (b > 0xFF)\r\nreturn -EINVAL;\r\ndata->pwm[pwm] = b;\r\ndata->psc[pwm] = blink;\r\nreturn 0;\r\n}\r\nstatic int pca9532_setpwm(struct i2c_client *client, int pwm)\r\n{\r\nstruct pca9532_data *data = i2c_get_clientdata(client);\r\nu8 maxleds = data->chip_info->num_leds;\r\nmutex_lock(&data->update_lock);\r\ni2c_smbus_write_byte_data(client, PCA9532_REG_PWM(maxleds, pwm),\r\ndata->pwm[pwm]);\r\ni2c_smbus_write_byte_data(client, PCA9532_REG_PSC(maxleds, pwm),\r\ndata->psc[pwm]);\r\nmutex_unlock(&data->update_lock);\r\nreturn 0;\r\n}\r\nstatic void pca9532_setled(struct pca9532_led *led)\r\n{\r\nstruct i2c_client *client = led->client;\r\nstruct pca9532_data *data = i2c_get_clientdata(client);\r\nu8 maxleds = data->chip_info->num_leds;\r\nchar reg;\r\nmutex_lock(&data->update_lock);\r\nreg = i2c_smbus_read_byte_data(client, LED_REG(maxleds, led->id));\r\nreg = reg & ~(0x3<<LED_NUM(led->id)*2);\r\nreg = reg | (led->state << LED_NUM(led->id)*2);\r\ni2c_smbus_write_byte_data(client, LED_REG(maxleds, led->id), reg);\r\nmutex_unlock(&data->update_lock);\r\n}\r\nstatic int pca9532_set_brightness(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nint err = 0;\r\nstruct pca9532_led *led = ldev_to_led(led_cdev);\r\nif (value == LED_OFF)\r\nled->state = PCA9532_OFF;\r\nelse if (value == LED_FULL)\r\nled->state = PCA9532_ON;\r\nelse {\r\nled->state = PCA9532_PWM0;\r\nerr = pca9532_calcpwm(led->client, 0, 0, value);\r\nif (err)\r\nreturn err;\r\n}\r\nif (led->state == PCA9532_PWM0)\r\npca9532_setpwm(led->client, 0);\r\npca9532_setled(led);\r\nreturn err;\r\n}\r\nstatic int pca9532_set_blink(struct led_classdev *led_cdev,\r\nunsigned long *delay_on, unsigned long *delay_off)\r\n{\r\nstruct pca9532_led *led = ldev_to_led(led_cdev);\r\nstruct i2c_client *client = led->client;\r\nint psc;\r\nint err = 0;\r\nif (*delay_on == 0 && *delay_off == 0) {\r\n*delay_on = 1000;\r\n*delay_off = 1000;\r\n}\r\nif (*delay_on != *delay_off || *delay_on > 1690 || *delay_on < 6)\r\nreturn -EINVAL;\r\npsc = (*delay_on * 152-1)/1000;\r\nerr = pca9532_calcpwm(client, 0, psc, led_cdev->brightness);\r\nif (err)\r\nreturn err;\r\nif (led->state == PCA9532_PWM0)\r\npca9532_setpwm(led->client, 0);\r\npca9532_setled(led);\r\nreturn 0;\r\n}\r\nstatic int pca9532_event(struct input_dev *dev, unsigned int type,\r\nunsigned int code, int value)\r\n{\r\nstruct pca9532_data *data = input_get_drvdata(dev);\r\nif (!(type == EV_SND && (code == SND_BELL || code == SND_TONE)))\r\nreturn -1;\r\nif (value > 1 && value < 32767)\r\ndata->pwm[1] = 127;\r\nelse\r\ndata->pwm[1] = 0;\r\nschedule_work(&data->work);\r\nreturn 0;\r\n}\r\nstatic void pca9532_input_work(struct work_struct *work)\r\n{\r\nstruct pca9532_data *data =\r\ncontainer_of(work, struct pca9532_data, work);\r\nu8 maxleds = data->chip_info->num_leds;\r\nmutex_lock(&data->update_lock);\r\ni2c_smbus_write_byte_data(data->client, PCA9532_REG_PWM(maxleds, 1),\r\ndata->pwm[1]);\r\nmutex_unlock(&data->update_lock);\r\n}\r\nstatic enum pca9532_state pca9532_getled(struct pca9532_led *led)\r\n{\r\nstruct i2c_client *client = led->client;\r\nstruct pca9532_data *data = i2c_get_clientdata(client);\r\nu8 maxleds = data->chip_info->num_leds;\r\nchar reg;\r\nenum pca9532_state ret;\r\nmutex_lock(&data->update_lock);\r\nreg = i2c_smbus_read_byte_data(client, LED_REG(maxleds, led->id));\r\nret = reg >> LED_NUM(led->id)/2;\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int pca9532_gpio_request_pin(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pca9532_data *data = gpiochip_get_data(gc);\r\nstruct pca9532_led *led = &data->leds[offset];\r\nif (led->type == PCA9532_TYPE_GPIO)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic void pca9532_gpio_set_value(struct gpio_chip *gc, unsigned offset, int val)\r\n{\r\nstruct pca9532_data *data = gpiochip_get_data(gc);\r\nstruct pca9532_led *led = &data->leds[offset];\r\nif (val)\r\nled->state = PCA9532_ON;\r\nelse\r\nled->state = PCA9532_OFF;\r\npca9532_setled(led);\r\n}\r\nstatic int pca9532_gpio_get_value(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pca9532_data *data = gpiochip_get_data(gc);\r\nunsigned char reg;\r\nreg = i2c_smbus_read_byte_data(data->client, PCA9532_REG_INPUT(offset));\r\nreturn !!(reg & (1 << (offset % 8)));\r\n}\r\nstatic int pca9532_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\npca9532_gpio_set_value(gc, offset, 0);\r\nreturn 0;\r\n}\r\nstatic int pca9532_gpio_direction_output(struct gpio_chip *gc, unsigned offset, int val)\r\n{\r\npca9532_gpio_set_value(gc, offset, val);\r\nreturn 0;\r\n}\r\nstatic int pca9532_destroy_devices(struct pca9532_data *data, int n_devs)\r\n{\r\nint i = n_devs;\r\nif (!data)\r\nreturn -EINVAL;\r\nwhile (--i >= 0) {\r\nswitch (data->leds[i].type) {\r\ncase PCA9532_TYPE_NONE:\r\ncase PCA9532_TYPE_GPIO:\r\nbreak;\r\ncase PCA9532_TYPE_LED:\r\nled_classdev_unregister(&data->leds[i].ldev);\r\nbreak;\r\ncase PCA9532_TYPE_N2100_BEEP:\r\nif (data->idev != NULL) {\r\ncancel_work_sync(&data->work);\r\ndata->idev = NULL;\r\n}\r\nbreak;\r\n}\r\n}\r\n#ifdef CONFIG_LEDS_PCA9532_GPIO\r\nif (data->gpio.parent)\r\ngpiochip_remove(&data->gpio);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int pca9532_configure(struct i2c_client *client,\r\nstruct pca9532_data *data, struct pca9532_platform_data *pdata)\r\n{\r\nint i, err = 0;\r\nint gpios = 0;\r\nu8 maxleds = data->chip_info->num_leds;\r\nfor (i = 0; i < 2; i++) {\r\ndata->pwm[i] = pdata->pwm[i];\r\ndata->psc[i] = pdata->psc[i];\r\ni2c_smbus_write_byte_data(client, PCA9532_REG_PWM(maxleds, i),\r\ndata->pwm[i]);\r\ni2c_smbus_write_byte_data(client, PCA9532_REG_PSC(maxleds, i),\r\ndata->psc[i]);\r\n}\r\nfor (i = 0; i < data->chip_info->num_leds; i++) {\r\nstruct pca9532_led *led = &data->leds[i];\r\nstruct pca9532_led *pled = &pdata->leds[i];\r\nled->client = client;\r\nled->id = i;\r\nled->type = pled->type;\r\nswitch (led->type) {\r\ncase PCA9532_TYPE_NONE:\r\nbreak;\r\ncase PCA9532_TYPE_GPIO:\r\ngpios++;\r\nbreak;\r\ncase PCA9532_TYPE_LED:\r\nif (pled->state == PCA9532_KEEP)\r\nled->state = pca9532_getled(led);\r\nelse\r\nled->state = pled->state;\r\nled->name = pled->name;\r\nled->ldev.name = led->name;\r\nled->ldev.default_trigger = pled->default_trigger;\r\nled->ldev.brightness = LED_OFF;\r\nled->ldev.brightness_set_blocking =\r\npca9532_set_brightness;\r\nled->ldev.blink_set = pca9532_set_blink;\r\nerr = led_classdev_register(&client->dev, &led->ldev);\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"couldn't register LED %s\n",\r\nled->name);\r\ngoto exit;\r\n}\r\npca9532_setled(led);\r\nbreak;\r\ncase PCA9532_TYPE_N2100_BEEP:\r\nBUG_ON(data->idev);\r\nled->state = PCA9532_PWM1;\r\npca9532_setled(led);\r\ndata->idev = devm_input_allocate_device(&client->dev);\r\nif (data->idev == NULL) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ndata->idev->name = pled->name;\r\ndata->idev->phys = "i2c/pca9532";\r\ndata->idev->id.bustype = BUS_HOST;\r\ndata->idev->id.vendor = 0x001f;\r\ndata->idev->id.product = 0x0001;\r\ndata->idev->id.version = 0x0100;\r\ndata->idev->evbit[0] = BIT_MASK(EV_SND);\r\ndata->idev->sndbit[0] = BIT_MASK(SND_BELL) |\r\nBIT_MASK(SND_TONE);\r\ndata->idev->event = pca9532_event;\r\ninput_set_drvdata(data->idev, data);\r\nINIT_WORK(&data->work, pca9532_input_work);\r\nerr = input_register_device(data->idev);\r\nif (err) {\r\ncancel_work_sync(&data->work);\r\ndata->idev = NULL;\r\ngoto exit;\r\n}\r\nbreak;\r\n}\r\n}\r\n#ifdef CONFIG_LEDS_PCA9532_GPIO\r\nif (gpios) {\r\ndata->gpio.label = "gpio-pca9532";\r\ndata->gpio.direction_input = pca9532_gpio_direction_input;\r\ndata->gpio.direction_output = pca9532_gpio_direction_output;\r\ndata->gpio.set = pca9532_gpio_set_value;\r\ndata->gpio.get = pca9532_gpio_get_value;\r\ndata->gpio.request = pca9532_gpio_request_pin;\r\ndata->gpio.can_sleep = 1;\r\ndata->gpio.base = pdata->gpio_base;\r\ndata->gpio.ngpio = data->chip_info->num_leds;\r\ndata->gpio.parent = &client->dev;\r\ndata->gpio.owner = THIS_MODULE;\r\nerr = gpiochip_add_data(&data->gpio, data);\r\nif (err) {\r\ndata->gpio.parent = NULL;\r\ndev_warn(&client->dev, "could not add gpiochip\n");\r\n} else {\r\ndev_info(&client->dev, "gpios %i...%i\n",\r\ndata->gpio.base, data->gpio.base +\r\ndata->gpio.ngpio - 1);\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\nexit:\r\npca9532_destroy_devices(data, i);\r\nreturn err;\r\n}\r\nstatic struct pca9532_platform_data *\r\npca9532_of_populate_pdata(struct device *dev, struct device_node *np)\r\n{\r\nstruct pca9532_platform_data *pdata;\r\nstruct device_node *child;\r\nconst struct of_device_id *match;\r\nint devid, maxleds;\r\nint i = 0;\r\nconst char *state;\r\nmatch = of_match_device(of_pca9532_leds_match, dev);\r\nif (!match)\r\nreturn ERR_PTR(-ENODEV);\r\ndevid = (int)(uintptr_t)match->data;\r\nmaxleds = pca9532_chip_info_tbl[devid].num_leds;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor_each_child_of_node(np, child) {\r\nif (of_property_read_string(child, "label",\r\n&pdata->leds[i].name))\r\npdata->leds[i].name = child->name;\r\nof_property_read_u32(child, "type", &pdata->leds[i].type);\r\nof_property_read_string(child, "linux,default-trigger",\r\n&pdata->leds[i].default_trigger);\r\nif (!of_property_read_string(child, "default-state", &state)) {\r\nif (!strcmp(state, "on"))\r\npdata->leds[i].state = PCA9532_ON;\r\nelse if (!strcmp(state, "keep"))\r\npdata->leds[i].state = PCA9532_KEEP;\r\n}\r\nif (++i >= maxleds) {\r\nof_node_put(child);\r\nbreak;\r\n}\r\n}\r\nreturn pdata;\r\n}\r\nstatic int pca9532_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint devid;\r\nstruct pca9532_data *data = i2c_get_clientdata(client);\r\nstruct pca9532_platform_data *pca9532_pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct device_node *np = client->dev.of_node;\r\nif (!pca9532_pdata) {\r\nif (np) {\r\npca9532_pdata =\r\npca9532_of_populate_pdata(&client->dev, np);\r\nif (IS_ERR(pca9532_pdata))\r\nreturn PTR_ERR(pca9532_pdata);\r\n} else {\r\ndev_err(&client->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\ndevid = (int)(uintptr_t)of_match_device(\r\nof_pca9532_leds_match, &client->dev)->data;\r\n} else {\r\ndevid = id->driver_data;\r\n}\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\ndata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->chip_info = &pca9532_chip_info_tbl[devid];\r\ndev_info(&client->dev, "setting platform data\n");\r\ni2c_set_clientdata(client, data);\r\ndata->client = client;\r\nmutex_init(&data->update_lock);\r\nreturn pca9532_configure(client, data, pca9532_pdata);\r\n}\r\nstatic int pca9532_remove(struct i2c_client *client)\r\n{\r\nstruct pca9532_data *data = i2c_get_clientdata(client);\r\nint err;\r\nerr = pca9532_destroy_devices(data, data->chip_info->num_leds);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}
