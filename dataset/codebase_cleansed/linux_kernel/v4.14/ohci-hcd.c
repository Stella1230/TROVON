static int number_of_tds(struct urb *urb)\r\n{\r\nint len, i, num, this_sg_len;\r\nstruct scatterlist *sg;\r\nlen = urb->transfer_buffer_length;\r\ni = urb->num_mapped_sgs;\r\nif (len > 0 && i > 0) {\r\nnum = 0;\r\nsg = urb->sg;\r\nfor (;;) {\r\nthis_sg_len = min_t(int, sg_dma_len(sg), len);\r\nnum += DIV_ROUND_UP(this_sg_len, 4096);\r\nlen -= this_sg_len;\r\nif (--i <= 0 || len <= 0)\r\nbreak;\r\nsg = sg_next(sg);\r\n}\r\n} else {\r\nnum = DIV_ROUND_UP(len, 4096);\r\n}\r\nreturn num;\r\n}\r\nstatic int ohci_urb_enqueue (\r\nstruct usb_hcd *hcd,\r\nstruct urb *urb,\r\ngfp_t mem_flags\r\n) {\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nstruct ed *ed;\r\nurb_priv_t *urb_priv;\r\nunsigned int pipe = urb->pipe;\r\nint i, size = 0;\r\nunsigned long flags;\r\nint retval = 0;\r\ned = ed_get(ohci, urb->ep, urb->dev, pipe, urb->interval);\r\nif (! ed)\r\nreturn -ENOMEM;\r\nswitch (ed->type) {\r\ncase PIPE_CONTROL:\r\nif (urb->transfer_buffer_length > 4096)\r\nreturn -EMSGSIZE;\r\nsize = 2;\r\ndefault:\r\nsize += number_of_tds(urb);\r\nif (size == 0)\r\nsize++;\r\nelse if ((urb->transfer_flags & URB_ZERO_PACKET) != 0\r\n&& (urb->transfer_buffer_length\r\n% usb_maxpacket (urb->dev, pipe,\r\nusb_pipeout (pipe))) == 0)\r\nsize++;\r\nbreak;\r\ncase PIPE_ISOCHRONOUS:\r\nsize = urb->number_of_packets;\r\nbreak;\r\n}\r\nurb_priv = kzalloc (sizeof (urb_priv_t) + size * sizeof (struct td *),\r\nmem_flags);\r\nif (!urb_priv)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD (&urb_priv->pending);\r\nurb_priv->length = size;\r\nurb_priv->ed = ed;\r\nfor (i = 0; i < size; i++) {\r\nurb_priv->td [i] = td_alloc (ohci, mem_flags);\r\nif (!urb_priv->td [i]) {\r\nurb_priv->length = i;\r\nurb_free_priv (ohci, urb_priv);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nspin_lock_irqsave (&ohci->lock, flags);\r\nif (!HCD_HW_ACCESSIBLE(hcd)) {\r\nretval = -ENODEV;\r\ngoto fail;\r\n}\r\nif (ohci->rh_state != OHCI_RH_RUNNING) {\r\nretval = -ENODEV;\r\ngoto fail;\r\n}\r\nretval = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (retval)\r\ngoto fail;\r\nif (ed->state == ED_IDLE) {\r\nretval = ed_schedule (ohci, ed);\r\nif (retval < 0) {\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\ngoto fail;\r\n}\r\nif (!timer_pending(&ohci->io_watchdog) &&\r\nlist_empty(&ohci->eds_in_use) &&\r\n!(ohci->flags & OHCI_QUIRK_QEMU)) {\r\nohci->prev_frame_no = ohci_frame_no(ohci);\r\nmod_timer(&ohci->io_watchdog,\r\njiffies + IO_WATCHDOG_DELAY);\r\n}\r\nlist_add(&ed->in_use_list, &ohci->eds_in_use);\r\nif (ed->type == PIPE_ISOCHRONOUS) {\r\nu16 frame = ohci_frame_no(ohci);\r\nframe += max_t (u16, 8, ed->interval);\r\nframe &= ~(ed->interval - 1);\r\nframe |= ed->branch;\r\nurb->start_frame = frame;\r\ned->last_iso = frame + ed->interval * (size - 1);\r\n}\r\n} else if (ed->type == PIPE_ISOCHRONOUS) {\r\nu16 next = ohci_frame_no(ohci) + 1;\r\nu16 frame = ed->last_iso + ed->interval;\r\nu16 length = ed->interval * (size - 1);\r\nif (unlikely(tick_before(frame, next))) {\r\nif (urb->transfer_flags & URB_ISO_ASAP) {\r\nframe += (next - frame + ed->interval - 1) &\r\n-ed->interval;\r\n} else {\r\nurb_priv->td_cnt = DIV_ROUND_UP(\r\n(u16) (next - frame),\r\ned->interval);\r\nif (urb_priv->td_cnt >= urb_priv->length) {\r\n++urb_priv->td_cnt;\r\nohci_dbg(ohci, "iso underrun %p (%u+%u < %u)\n",\r\nurb, frame, length,\r\nnext);\r\n}\r\n}\r\n}\r\nurb->start_frame = frame;\r\ned->last_iso = frame + length;\r\n}\r\nurb->hcpriv = urb_priv;\r\ntd_submit_urb (ohci, urb);\r\nfail:\r\nif (retval)\r\nurb_free_priv (ohci, urb_priv);\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nunsigned long flags;\r\nint rc;\r\nurb_priv_t *urb_priv;\r\nspin_lock_irqsave (&ohci->lock, flags);\r\nrc = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (rc == 0) {\r\nurb_priv = urb->hcpriv;\r\nif (urb_priv->ed->state == ED_OPER)\r\nstart_ed_unlink(ohci, urb_priv->ed);\r\nif (ohci->rh_state != OHCI_RH_RUNNING) {\r\nohci_work(ohci);\r\n}\r\n}\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void\r\nohci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nunsigned long flags;\r\nstruct ed *ed = ep->hcpriv;\r\nunsigned limit = 1000;\r\nif (!ed)\r\nreturn;\r\nrescan:\r\nspin_lock_irqsave (&ohci->lock, flags);\r\nif (ohci->rh_state != OHCI_RH_RUNNING) {\r\nsanitize:\r\ned->state = ED_IDLE;\r\nohci_work(ohci);\r\n}\r\nswitch (ed->state) {\r\ncase ED_UNLINK:\r\nif (limit-- == 0) {\r\nohci_warn(ohci, "ED unlink timeout\n");\r\ngoto sanitize;\r\n}\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\nschedule_timeout_uninterruptible(1);\r\ngoto rescan;\r\ncase ED_IDLE:\r\nif (list_empty (&ed->td_list)) {\r\ntd_free (ohci, ed->dummy);\r\ned_free (ohci, ed);\r\nbreak;\r\n}\r\ndefault:\r\nohci_err (ohci, "leak ed %p (#%02x) state %d%s\n",\r\ned, ep->desc.bEndpointAddress, ed->state,\r\nlist_empty (&ed->td_list) ? "" : " (has tds)");\r\ntd_free (ohci, ed->dummy);\r\nbreak;\r\n}\r\nep->hcpriv = NULL;\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\n}\r\nstatic int ohci_get_frame (struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nreturn ohci_frame_no(ohci);\r\n}\r\nstatic void ohci_usb_reset (struct ohci_hcd *ohci)\r\n{\r\nohci->hc_control = ohci_readl (ohci, &ohci->regs->control);\r\nohci->hc_control &= OHCI_CTRL_RWC;\r\nohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\r\nohci->rh_state = OHCI_RH_HALTED;\r\n}\r\nstatic void\r\nohci_shutdown (struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci;\r\nohci = hcd_to_ohci (hcd);\r\nohci_writel(ohci, (u32) ~0, &ohci->regs->intrdisable);\r\nohci_writel(ohci, OHCI_HCR, &ohci->regs->cmdstatus);\r\nohci_readl(ohci, &ohci->regs->cmdstatus);\r\nudelay(10);\r\nohci_writel(ohci, ohci->fminterval, &ohci->regs->fminterval);\r\nohci->rh_state = OHCI_RH_HALTED;\r\n}\r\nstatic int ohci_init (struct ohci_hcd *ohci)\r\n{\r\nint ret;\r\nstruct usb_hcd *hcd = ohci_to_hcd(ohci);\r\nhcd->self.sg_tablesize = ~0;\r\nif (distrust_firmware)\r\nohci->flags |= OHCI_QUIRK_HUB_POWER;\r\nohci->rh_state = OHCI_RH_HALTED;\r\nohci->regs = hcd->regs;\r\n#ifndef IR_DISABLE\r\nif (!no_handshake && ohci_readl (ohci,\r\n&ohci->regs->control) & OHCI_CTRL_IR) {\r\nu32 temp;\r\nohci_dbg (ohci, "USB HC TakeOver from BIOS/SMM\n");\r\ntemp = 500;\r\nohci_writel (ohci, OHCI_INTR_OC, &ohci->regs->intrenable);\r\nohci_writel (ohci, OHCI_OCR, &ohci->regs->cmdstatus);\r\nwhile (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_IR) {\r\nmsleep (10);\r\nif (--temp == 0) {\r\nohci_err (ohci, "USB HC takeover failed!"\r\n" (BIOS/SMM bug)\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nohci_usb_reset (ohci);\r\n}\r\n#endif\r\nohci_writel (ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);\r\nif (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_RWC)\r\nohci->hc_control |= OHCI_CTRL_RWC;\r\nif (ohci->num_ports == 0)\r\nohci->num_ports = roothub_a(ohci) & RH_A_NDP;\r\nif (ohci->hcca)\r\nreturn 0;\r\nsetup_timer(&ohci->io_watchdog, io_watchdog_func,\r\n(unsigned long) ohci);\r\nohci->hcca = dma_alloc_coherent (hcd->self.controller,\r\nsizeof(*ohci->hcca), &ohci->hcca_dma, GFP_KERNEL);\r\nif (!ohci->hcca)\r\nreturn -ENOMEM;\r\nif ((ret = ohci_mem_init (ohci)) < 0)\r\nohci_stop (hcd);\r\nelse {\r\ncreate_debug_files (ohci);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ohci_run (struct ohci_hcd *ohci)\r\n{\r\nu32 mask, val;\r\nint first = ohci->fminterval == 0;\r\nstruct usb_hcd *hcd = ohci_to_hcd(ohci);\r\nohci->rh_state = OHCI_RH_HALTED;\r\nif (first) {\r\nval = ohci_readl (ohci, &ohci->regs->fminterval);\r\nohci->fminterval = val & 0x3fff;\r\nif (ohci->fminterval != FI)\r\nohci_dbg (ohci, "fminterval delta %d\n",\r\nohci->fminterval - FI);\r\nohci->fminterval |= FSMP (ohci->fminterval) << 16;\r\n}\r\nif ((ohci->hc_control & OHCI_CTRL_RWC) != 0)\r\ndevice_set_wakeup_capable(hcd->self.controller, 1);\r\nswitch (ohci->hc_control & OHCI_CTRL_HCFS) {\r\ncase OHCI_USB_OPER:\r\nval = 0;\r\nbreak;\r\ncase OHCI_USB_SUSPEND:\r\ncase OHCI_USB_RESUME:\r\nohci->hc_control &= OHCI_CTRL_RWC;\r\nohci->hc_control |= OHCI_USB_RESUME;\r\nval = 10 ;\r\nbreak;\r\ndefault:\r\nohci->hc_control &= OHCI_CTRL_RWC;\r\nohci->hc_control |= OHCI_USB_RESET;\r\nval = 50 ;\r\nbreak;\r\n}\r\nohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\nmsleep(val);\r\nmemset (ohci->hcca, 0, sizeof (struct ohci_hcca));\r\nspin_lock_irq (&ohci->lock);\r\nretry:\r\nohci_writel (ohci, OHCI_HCR, &ohci->regs->cmdstatus);\r\nval = 30;\r\nwhile ((ohci_readl (ohci, &ohci->regs->cmdstatus) & OHCI_HCR) != 0) {\r\nif (--val == 0) {\r\nspin_unlock_irq (&ohci->lock);\r\nohci_err (ohci, "USB HC reset timed out!\n");\r\nreturn -1;\r\n}\r\nudelay (1);\r\n}\r\nif (ohci->flags & OHCI_QUIRK_INITRESET) {\r\nohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\n}\r\nohci_writel (ohci, 0, &ohci->regs->ed_controlhead);\r\nohci_writel (ohci, 0, &ohci->regs->ed_bulkhead);\r\nohci_writel (ohci, (u32) ohci->hcca_dma, &ohci->regs->hcca);\r\nperiodic_reinit (ohci);\r\nif ((ohci_readl (ohci, &ohci->regs->fminterval) & 0x3fff0000) == 0\r\n|| !ohci_readl (ohci, &ohci->regs->periodicstart)) {\r\nif (!(ohci->flags & OHCI_QUIRK_INITRESET)) {\r\nohci->flags |= OHCI_QUIRK_INITRESET;\r\nohci_dbg (ohci, "enabling initreset quirk\n");\r\ngoto retry;\r\n}\r\nspin_unlock_irq (&ohci->lock);\r\nohci_err (ohci, "init err (%08x %04x)\n",\r\nohci_readl (ohci, &ohci->regs->fminterval),\r\nohci_readl (ohci, &ohci->regs->periodicstart));\r\nreturn -EOVERFLOW;\r\n}\r\nset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\nhcd->uses_new_polling = 1;\r\nohci->hc_control &= OHCI_CTRL_RWC;\r\nohci->hc_control |= OHCI_CONTROL_INIT | OHCI_USB_OPER;\r\nohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\r\nohci->rh_state = OHCI_RH_RUNNING;\r\nohci_writel (ohci, RH_HS_DRWE, &ohci->regs->roothub.status);\r\nmask = OHCI_INTR_INIT;\r\nohci_writel (ohci, ~0, &ohci->regs->intrstatus);\r\nohci_writel (ohci, mask, &ohci->regs->intrenable);\r\nval = roothub_a (ohci);\r\nval &= ~(RH_A_PSM | RH_A_OCPM);\r\nif (ohci->flags & OHCI_QUIRK_SUPERIO) {\r\nval |= RH_A_NOCP;\r\nval &= ~(RH_A_POTPGT | RH_A_NPS);\r\nohci_writel (ohci, val, &ohci->regs->roothub.a);\r\n} else if ((ohci->flags & OHCI_QUIRK_AMD756) ||\r\n(ohci->flags & OHCI_QUIRK_HUB_POWER)) {\r\nval |= RH_A_NPS;\r\nohci_writel (ohci, val, &ohci->regs->roothub.a);\r\n}\r\nohci_writel (ohci, RH_HS_LPSC, &ohci->regs->roothub.status);\r\nohci_writel (ohci, (val & RH_A_NPS) ? 0 : RH_B_PPCM,\r\n&ohci->regs->roothub.b);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\nohci->next_statechange = jiffies + STATECHANGE_DELAY;\r\nspin_unlock_irq (&ohci->lock);\r\nmdelay ((val >> 23) & 0x1fe);\r\nohci_dump(ohci);\r\nreturn 0;\r\n}\r\nint ohci_setup(struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nohci_hcd_init(ohci);\r\nreturn ohci_init(ohci);\r\n}\r\nstatic int ohci_start(struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nint ret;\r\nret = ohci_run(ohci);\r\nif (ret < 0) {\r\nohci_err(ohci, "can't start\n");\r\nohci_stop(hcd);\r\n}\r\nreturn ret;\r\n}\r\nstatic void io_watchdog_func(unsigned long _ohci)\r\n{\r\nstruct ohci_hcd *ohci = (struct ohci_hcd *) _ohci;\r\nbool takeback_all_pending = false;\r\nu32 status;\r\nu32 head;\r\nstruct ed *ed;\r\nstruct td *td, *td_start, *td_next;\r\nunsigned frame_no;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ohci->lock, flags);\r\nstatus = ohci_readl(ohci, &ohci->regs->intrstatus);\r\nif (!(status & OHCI_INTR_WDH) && ohci->wdh_cnt == ohci->prev_wdh_cnt) {\r\nif (ohci->prev_donehead) {\r\nohci_err(ohci, "HcDoneHead not written back; disabled\n");\r\ndied:\r\nusb_hc_died(ohci_to_hcd(ohci));\r\nohci_dump(ohci);\r\nohci_shutdown(ohci_to_hcd(ohci));\r\ngoto done;\r\n} else {\r\ntakeback_all_pending = true;\r\n}\r\n}\r\nlist_for_each_entry(ed, &ohci->eds_in_use, in_use_list) {\r\nif (ed->pending_td) {\r\nif (takeback_all_pending ||\r\nOKAY_TO_TAKEBACK(ohci, ed)) {\r\nunsigned tmp = hc32_to_cpu(ohci, ed->hwINFO);\r\nohci_dbg(ohci, "takeback pending TD for dev %d ep 0x%x\n",\r\n0x007f & tmp,\r\n(0x000f & (tmp >> 7)) +\r\n((tmp & ED_IN) >> 5));\r\nadd_to_done_list(ohci, ed->pending_td);\r\n}\r\n}\r\ntd = ed->pending_td;\r\nif (!td) {\r\nlist_for_each_entry(td_next, &ed->td_list, td_list) {\r\nif (!td_next->next_dl_td)\r\nbreak;\r\ntd = td_next;\r\n}\r\n}\r\nhead = hc32_to_cpu(ohci, ACCESS_ONCE(ed->hwHeadP)) & TD_MASK;\r\ntd_start = td;\r\ntd_next = list_prepare_entry(td, &ed->td_list, td_list);\r\nlist_for_each_entry_continue(td_next, &ed->td_list, td_list) {\r\nif (head == (u32) td_next->td_dma)\r\nbreak;\r\ntd = td_next;\r\n}\r\nif (td != td_start) {\r\ned->takeback_wdh_cnt = ohci->wdh_cnt + 2;\r\ned->pending_td = td;\r\n}\r\n}\r\nohci_work(ohci);\r\nif (ohci->rh_state == OHCI_RH_RUNNING) {\r\nframe_no = ohci_frame_no(ohci);\r\nif (frame_no == ohci->prev_frame_no) {\r\nint active_cnt = 0;\r\nint i;\r\nunsigned tmp;\r\nfor (i = 0; i < ohci->num_ports; ++i) {\r\ntmp = roothub_portstatus(ohci, i);\r\nif ((tmp & RH_PS_PES) && !(tmp & RH_PS_PSS))\r\n++active_cnt;\r\n}\r\nif (active_cnt > 0) {\r\nohci_err(ohci, "frame counter not updating; disabled\n");\r\ngoto died;\r\n}\r\n}\r\nif (!list_empty(&ohci->eds_in_use)) {\r\nohci->prev_frame_no = frame_no;\r\nohci->prev_wdh_cnt = ohci->wdh_cnt;\r\nohci->prev_donehead = ohci_readl(ohci,\r\n&ohci->regs->donehead);\r\nmod_timer(&ohci->io_watchdog,\r\njiffies + IO_WATCHDOG_DELAY);\r\n}\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&ohci->lock, flags);\r\n}\r\nstatic irqreturn_t ohci_irq (struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nstruct ohci_regs __iomem *regs = ohci->regs;\r\nint ints;\r\nints = ohci_readl(ohci, &regs->intrstatus);\r\nif (ints == ~(u32)0) {\r\nohci->rh_state = OHCI_RH_HALTED;\r\nohci_dbg (ohci, "device removed!\n");\r\nusb_hc_died(hcd);\r\nreturn IRQ_HANDLED;\r\n}\r\nints &= ohci_readl(ohci, &regs->intrenable);\r\nif (ints == 0 || unlikely(ohci->rh_state == OHCI_RH_HALTED))\r\nreturn IRQ_NOTMINE;\r\nif (ints & OHCI_INTR_UE) {\r\nif (quirk_nec(ohci)) {\r\nohci_err (ohci, "OHCI Unrecoverable Error, scheduling NEC chip restart\n");\r\nohci_writel (ohci, OHCI_INTR_UE, &regs->intrdisable);\r\nschedule_work (&ohci->nec_work);\r\n} else {\r\nohci_err (ohci, "OHCI Unrecoverable Error, disabled\n");\r\nohci->rh_state = OHCI_RH_HALTED;\r\nusb_hc_died(hcd);\r\n}\r\nohci_dump(ohci);\r\nohci_usb_reset (ohci);\r\n}\r\nif (ints & OHCI_INTR_RHSC) {\r\nohci_dbg(ohci, "rhsc\n");\r\nohci->next_statechange = jiffies + STATECHANGE_DELAY;\r\nohci_writel(ohci, OHCI_INTR_RD | OHCI_INTR_RHSC,\r\n&regs->intrstatus);\r\nohci_writel(ohci, OHCI_INTR_RHSC, &regs->intrdisable);\r\nusb_hcd_poll_rh_status(hcd);\r\n}\r\nelse if (ints & OHCI_INTR_RD) {\r\nohci_dbg(ohci, "resume detect\n");\r\nohci_writel(ohci, OHCI_INTR_RD, &regs->intrstatus);\r\nset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\nif (ohci->autostop) {\r\nspin_lock (&ohci->lock);\r\nohci_rh_resume (ohci);\r\nspin_unlock (&ohci->lock);\r\n} else\r\nusb_hcd_resume_root_hub(hcd);\r\n}\r\nspin_lock(&ohci->lock);\r\nif (ints & OHCI_INTR_WDH)\r\nupdate_done_list(ohci);\r\nohci_work(ohci);\r\nif ((ints & OHCI_INTR_SF) != 0 && !ohci->ed_rm_list\r\n&& ohci->rh_state == OHCI_RH_RUNNING)\r\nohci_writel (ohci, OHCI_INTR_SF, &regs->intrdisable);\r\nif (ohci->rh_state == OHCI_RH_RUNNING) {\r\nohci_writel (ohci, ints, &regs->intrstatus);\r\nif (ints & OHCI_INTR_WDH)\r\n++ohci->wdh_cnt;\r\nohci_writel (ohci, OHCI_INTR_MIE, &regs->intrenable);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\n}\r\nspin_unlock(&ohci->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ohci_stop (struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nohci_dump(ohci);\r\nif (quirk_nec(ohci))\r\nflush_work(&ohci->nec_work);\r\ndel_timer_sync(&ohci->io_watchdog);\r\nohci_writel (ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);\r\nohci_usb_reset(ohci);\r\nfree_irq(hcd->irq, hcd);\r\nhcd->irq = 0;\r\nif (quirk_amdiso(ohci))\r\nusb_amd_dev_put();\r\nremove_debug_files (ohci);\r\nohci_mem_cleanup (ohci);\r\nif (ohci->hcca) {\r\ndma_free_coherent (hcd->self.controller,\r\nsizeof *ohci->hcca,\r\nohci->hcca, ohci->hcca_dma);\r\nohci->hcca = NULL;\r\nohci->hcca_dma = 0;\r\n}\r\n}\r\nint ohci_restart(struct ohci_hcd *ohci)\r\n{\r\nint temp;\r\nint i;\r\nstruct urb_priv *priv;\r\nohci_init(ohci);\r\nspin_lock_irq(&ohci->lock);\r\nohci->rh_state = OHCI_RH_HALTED;\r\nif (!list_empty (&ohci->pending))\r\nohci_dbg(ohci, "abort schedule...\n");\r\nlist_for_each_entry (priv, &ohci->pending, pending) {\r\nstruct urb *urb = priv->td[0]->urb;\r\nstruct ed *ed = priv->ed;\r\nswitch (ed->state) {\r\ncase ED_OPER:\r\ned->state = ED_UNLINK;\r\ned->hwINFO |= cpu_to_hc32(ohci, ED_DEQUEUE);\r\ned_deschedule (ohci, ed);\r\ned->ed_next = ohci->ed_rm_list;\r\ned->ed_prev = NULL;\r\nohci->ed_rm_list = ed;\r\ncase ED_UNLINK:\r\nbreak;\r\ndefault:\r\nohci_dbg(ohci, "bogus ed %p state %d\n",\r\ned, ed->state);\r\n}\r\nif (!urb->unlinked)\r\nurb->unlinked = -ESHUTDOWN;\r\n}\r\nohci_work(ohci);\r\nspin_unlock_irq(&ohci->lock);\r\nfor (i = 0; i < NUM_INTS; i++) ohci->load [i] = 0;\r\nfor (i = 0; i < NUM_INTS; i++) ohci->hcca->int_table [i] = 0;\r\nohci->ed_rm_list = NULL;\r\nohci->ed_controltail = NULL;\r\nohci->ed_bulktail = NULL;\r\nif ((temp = ohci_run (ohci)) < 0) {\r\nohci_err (ohci, "can't restart, %d\n", temp);\r\nreturn temp;\r\n}\r\nohci_dbg(ohci, "restart complete\n");\r\nreturn 0;\r\n}\r\nint ohci_suspend(struct usb_hcd *hcd, bool do_wakeup)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave (&ohci->lock, flags);\r\nohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);\r\n(void)ohci_readl(ohci, &ohci->regs->intrdisable);\r\nclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\nsynchronize_irq(hcd->irq);\r\nif (do_wakeup && HCD_WAKEUP_PENDING(hcd)) {\r\nohci_resume(hcd, false);\r\nrc = -EBUSY;\r\n}\r\nreturn rc;\r\n}\r\nint ohci_resume(struct usb_hcd *hcd, bool hibernated)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nint port;\r\nbool need_reinit = false;\r\nset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nif (hibernated)\r\nohci_usb_reset(ohci);\r\nohci->hc_control = ohci_readl(ohci, &ohci->regs->control);\r\nif (ohci->hc_control & (OHCI_CTRL_IR | OHCI_SCHED_ENABLES)) {\r\nneed_reinit = true;\r\n} else {\r\nswitch (ohci->hc_control & OHCI_CTRL_HCFS) {\r\ncase OHCI_USB_OPER:\r\ncase OHCI_USB_RESET:\r\nneed_reinit = true;\r\n}\r\n}\r\nif (need_reinit) {\r\nspin_lock_irq(&ohci->lock);\r\nohci_rh_resume(ohci);\r\nohci_rh_suspend(ohci, 0);\r\nspin_unlock_irq(&ohci->lock);\r\n}\r\nelse {\r\nohci_dbg(ohci, "powerup ports\n");\r\nfor (port = 0; port < ohci->num_ports; port++)\r\nohci_writel(ohci, RH_PS_PPS,\r\n&ohci->regs->roothub.portstatus[port]);\r\nohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrenable);\r\nohci_readl(ohci, &ohci->regs->intrenable);\r\nmsleep(20);\r\n}\r\nusb_hcd_resume_root_hub(hcd);\r\nreturn 0;\r\n}\r\nvoid ohci_init_driver(struct hc_driver *drv,\r\nconst struct ohci_driver_overrides *over)\r\n{\r\n*drv = ohci_hc_driver;\r\nif (over) {\r\ndrv->product_desc = over->product_desc;\r\ndrv->hcd_priv_size += over->extra_priv_size;\r\nif (over->reset)\r\ndrv->reset = over->reset;\r\n}\r\n}\r\nstatic int __init ohci_hcd_mod_init(void)\r\n{\r\nint retval = 0;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "%s: " DRIVER_DESC "\n", hcd_name);\r\npr_debug ("%s: block sizes: ed %zd td %zd\n", hcd_name,\r\nsizeof (struct ed), sizeof (struct td));\r\nset_bit(USB_OHCI_LOADED, &usb_hcds_loaded);\r\nohci_debug_root = debugfs_create_dir("ohci", usb_debug_root);\r\nif (!ohci_debug_root) {\r\nretval = -ENOENT;\r\ngoto error_debug;\r\n}\r\n#ifdef PS3_SYSTEM_BUS_DRIVER\r\nretval = ps3_ohci_driver_register(&PS3_SYSTEM_BUS_DRIVER);\r\nif (retval < 0)\r\ngoto error_ps3;\r\n#endif\r\n#ifdef PLATFORM_DRIVER\r\nretval = platform_driver_register(&PLATFORM_DRIVER);\r\nif (retval < 0)\r\ngoto error_platform;\r\n#endif\r\n#ifdef OF_PLATFORM_DRIVER\r\nretval = platform_driver_register(&OF_PLATFORM_DRIVER);\r\nif (retval < 0)\r\ngoto error_of_platform;\r\n#endif\r\n#ifdef SA1111_DRIVER\r\nretval = sa1111_driver_register(&SA1111_DRIVER);\r\nif (retval < 0)\r\ngoto error_sa1111;\r\n#endif\r\n#ifdef SM501_OHCI_DRIVER\r\nretval = platform_driver_register(&SM501_OHCI_DRIVER);\r\nif (retval < 0)\r\ngoto error_sm501;\r\n#endif\r\n#ifdef TMIO_OHCI_DRIVER\r\nretval = platform_driver_register(&TMIO_OHCI_DRIVER);\r\nif (retval < 0)\r\ngoto error_tmio;\r\n#endif\r\nreturn retval;\r\n#ifdef TMIO_OHCI_DRIVER\r\nplatform_driver_unregister(&TMIO_OHCI_DRIVER);\r\nerror_tmio:\r\n#endif\r\n#ifdef SM501_OHCI_DRIVER\r\nplatform_driver_unregister(&SM501_OHCI_DRIVER);\r\nerror_sm501:\r\n#endif\r\n#ifdef SA1111_DRIVER\r\nsa1111_driver_unregister(&SA1111_DRIVER);\r\nerror_sa1111:\r\n#endif\r\n#ifdef OF_PLATFORM_DRIVER\r\nplatform_driver_unregister(&OF_PLATFORM_DRIVER);\r\nerror_of_platform:\r\n#endif\r\n#ifdef PLATFORM_DRIVER\r\nplatform_driver_unregister(&PLATFORM_DRIVER);\r\nerror_platform:\r\n#endif\r\n#ifdef PS3_SYSTEM_BUS_DRIVER\r\nps3_ohci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);\r\nerror_ps3:\r\n#endif\r\ndebugfs_remove(ohci_debug_root);\r\nohci_debug_root = NULL;\r\nerror_debug:\r\nclear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);\r\nreturn retval;\r\n}\r\nstatic void __exit ohci_hcd_mod_exit(void)\r\n{\r\n#ifdef TMIO_OHCI_DRIVER\r\nplatform_driver_unregister(&TMIO_OHCI_DRIVER);\r\n#endif\r\n#ifdef SM501_OHCI_DRIVER\r\nplatform_driver_unregister(&SM501_OHCI_DRIVER);\r\n#endif\r\n#ifdef SA1111_DRIVER\r\nsa1111_driver_unregister(&SA1111_DRIVER);\r\n#endif\r\n#ifdef OF_PLATFORM_DRIVER\r\nplatform_driver_unregister(&OF_PLATFORM_DRIVER);\r\n#endif\r\n#ifdef PLATFORM_DRIVER\r\nplatform_driver_unregister(&PLATFORM_DRIVER);\r\n#endif\r\n#ifdef PS3_SYSTEM_BUS_DRIVER\r\nps3_ohci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);\r\n#endif\r\ndebugfs_remove(ohci_debug_root);\r\nclear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);\r\n}
