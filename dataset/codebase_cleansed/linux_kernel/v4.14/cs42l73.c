static bool cs42l73_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS42L73_IS1:\r\ncase CS42L73_IS2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool cs42l73_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS42L73_DEVID_AB ... CS42L73_DEVID_E:\r\ncase CS42L73_REVID ... CS42L73_IM2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int cs42l73_spklo_spk_amp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct cs42l73_private *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMD:\r\npriv->shutdwn_delay = 150;\r\nbreak;\r\ndefault:\r\npr_err("Invalid event = 0x%x\n", event);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l73_ear_amp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct cs42l73_private *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMD:\r\nif (priv->shutdwn_delay < 50)\r\npriv->shutdwn_delay = 50;\r\nbreak;\r\ndefault:\r\npr_err("Invalid event = 0x%x\n", event);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l73_hp_amp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct cs42l73_private *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMD:\r\nif (priv->shutdwn_delay < 30)\r\npriv->shutdwn_delay = 30;\r\nbreak;\r\ndefault:\r\npr_err("Invalid event = 0x%x\n", event);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l73_get_mclkx_coeff(int mclkx)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cs42l73_mclkx_coeffs); i++) {\r\nif (cs42l73_mclkx_coeffs[i].mclkx == mclkx)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cs42l73_get_mclk_coeff(int mclk, int srate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cs42l73_mclk_coeffs); i++) {\r\nif (cs42l73_mclk_coeffs[i].mclk == mclk &&\r\ncs42l73_mclk_coeffs[i].srate == srate)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cs42l73_set_mclk(struct snd_soc_dai *dai, unsigned int freq)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs42l73_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint mclkx_coeff;\r\nu32 mclk = 0;\r\nu8 dmmcc = 0;\r\nmclkx_coeff = cs42l73_get_mclkx_coeff(freq);\r\nif (mclkx_coeff < 0)\r\nreturn mclkx_coeff;\r\nmclk = cs42l73_mclkx_coeffs[mclkx_coeff].mclkx /\r\ncs42l73_mclkx_coeffs[mclkx_coeff].ratio;\r\ndev_dbg(codec->dev, "MCLK%u %u <-> internal MCLK %u\n",\r\npriv->mclksel + 1, cs42l73_mclkx_coeffs[mclkx_coeff].mclkx,\r\nmclk);\r\ndmmcc = (priv->mclksel << 4) |\r\n(cs42l73_mclkx_coeffs[mclkx_coeff].mclkdiv << 1);\r\nsnd_soc_write(codec, CS42L73_DMMCC, dmmcc);\r\npriv->sysclk = mclkx_coeff;\r\npriv->mclk = mclk;\r\nreturn 0;\r\n}\r\nstatic int cs42l73_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs42l73_private *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (clk_id) {\r\ncase CS42L73_CLKID_MCLK1:\r\nbreak;\r\ncase CS42L73_CLKID_MCLK2:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((cs42l73_set_mclk(dai, freq)) < 0) {\r\ndev_err(codec->dev, "Unable to set MCLK for dai %s\n",\r\ndai->name);\r\nreturn -EINVAL;\r\n}\r\npriv->mclksel = clk_id;\r\nreturn 0;\r\n}\r\nstatic int cs42l73_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs42l73_private *priv = snd_soc_codec_get_drvdata(codec);\r\nu8 id = codec_dai->id;\r\nunsigned int inv, format;\r\nu8 spc, mmcc;\r\nspc = snd_soc_read(codec, CS42L73_SPC(id));\r\nmmcc = snd_soc_read(codec, CS42L73_MMCC(id));\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmmcc |= CS42L73_MS_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmmcc &= ~CS42L73_MS_MASTER;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nformat = (fmt & SND_SOC_DAIFMT_FORMAT_MASK);\r\ninv = (fmt & SND_SOC_DAIFMT_INV_MASK);\r\nswitch (format) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nspc &= ~CS42L73_SPDIF_PCM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nif (mmcc & CS42L73_MS_MASTER) {\r\ndev_err(codec->dev,\r\n"PCM format in slave mode only\n");\r\nreturn -EINVAL;\r\n}\r\nif (id == CS42L73_ASP) {\r\ndev_err(codec->dev,\r\n"PCM format is not supported on ASP port\n");\r\nreturn -EINVAL;\r\n}\r\nspc |= CS42L73_SPDIF_PCM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (spc & CS42L73_SPDIF_PCM) {\r\nspc &= ~(CS42L73_PCM_MODE_MASK | CS42L73_PCM_BIT_ORDER);\r\nswitch (format) {\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nif (inv == SND_SOC_DAIFMT_IB_IF)\r\nspc |= CS42L73_PCM_MODE0;\r\nif (inv == SND_SOC_DAIFMT_IB_NF)\r\nspc |= CS42L73_PCM_MODE1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nif (inv == SND_SOC_DAIFMT_IB_IF)\r\nspc |= CS42L73_PCM_MODE1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\npriv->config[id].spc = spc;\r\npriv->config[id].mmcc = mmcc;\r\nreturn 0;\r\n}\r\nstatic unsigned int cs42l73_get_xspfs_coeff(u32 rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cs42l73_asrc_rates); i++) {\r\nif (cs42l73_asrc_rates[i] == rate)\r\nreturn i + 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cs42l73_update_asrc(struct snd_soc_codec *codec, int id, int srate)\r\n{\r\nu8 spfs = 0;\r\nif (srate > 0)\r\nspfs = cs42l73_get_xspfs_coeff(srate);\r\nswitch (id) {\r\ncase CS42L73_XSP:\r\nsnd_soc_update_bits(codec, CS42L73_VXSPFS, 0x0f, spfs);\r\nbreak;\r\ncase CS42L73_ASP:\r\nsnd_soc_update_bits(codec, CS42L73_ASPC, 0x3c, spfs << 2);\r\nbreak;\r\ncase CS42L73_VSP:\r\nsnd_soc_update_bits(codec, CS42L73_VXSPFS, 0xf0, spfs << 4);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int cs42l73_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs42l73_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint id = dai->id;\r\nint mclk_coeff;\r\nint srate = params_rate(params);\r\nif (priv->config[id].mmcc & CS42L73_MS_MASTER) {\r\nmclk_coeff =\r\ncs42l73_get_mclk_coeff(priv->mclk, srate);\r\nif (mclk_coeff < 0)\r\nreturn -EINVAL;\r\ndev_dbg(codec->dev,\r\n"DAI[%d]: MCLK %u, srate %u, MMCC[5:0] = %x\n",\r\nid, priv->mclk, srate,\r\ncs42l73_mclk_coeffs[mclk_coeff].mmcc);\r\npriv->config[id].mmcc &= 0xC0;\r\npriv->config[id].mmcc |= cs42l73_mclk_coeffs[mclk_coeff].mmcc;\r\npriv->config[id].spc &= 0xFC;\r\nif (priv->mclk >= 6400000)\r\npriv->config[id].spc |= CS42L73_MCK_SCLK_64FS;\r\nelse\r\npriv->config[id].spc |= CS42L73_MCK_SCLK_MCLK;\r\n} else {\r\npriv->config[id].spc &= 0xFC;\r\npriv->config[id].spc |= CS42L73_MCK_SCLK_64FS;\r\n}\r\npriv->config[id].srate = srate;\r\nsnd_soc_write(codec, CS42L73_SPC(id), priv->config[id].spc);\r\nsnd_soc_write(codec, CS42L73_MMCC(id), priv->config[id].mmcc);\r\ncs42l73_update_asrc(codec, id, srate);\r\nreturn 0;\r\n}\r\nstatic int cs42l73_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct cs42l73_private *cs42l73 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nsnd_soc_update_bits(codec, CS42L73_DMMCC, CS42L73_MCLKDIS, 0);\r\nsnd_soc_update_bits(codec, CS42L73_PWRCTL1, CS42L73_PDN, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nregcache_cache_only(cs42l73->regmap, false);\r\nregcache_sync(cs42l73->regmap);\r\n}\r\nsnd_soc_update_bits(codec, CS42L73_PWRCTL1, CS42L73_PDN, 1);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, CS42L73_PWRCTL1, CS42L73_PDN, 1);\r\nif (cs42l73->shutdwn_delay > 0) {\r\nmdelay(cs42l73->shutdwn_delay);\r\ncs42l73->shutdwn_delay = 0;\r\n} else {\r\nmdelay(15);\r\n}\r\nsnd_soc_update_bits(codec, CS42L73_DMMCC, CS42L73_MCLKDIS, 1);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l73_set_tristate(struct snd_soc_dai *dai, int tristate)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint id = dai->id;\r\nreturn snd_soc_update_bits(codec, CS42L73_SPC(id), CS42L73_SP_3ST,\r\ntristate << 7);\r\n}\r\nstatic int cs42l73_pcm_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nsnd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\n&constraints_12_24);\r\nreturn 0;\r\n}\r\nstatic int cs42l73_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct cs42l73_private *cs42l73 = snd_soc_codec_get_drvdata(codec);\r\nif (cs42l73->pdata.chgfreq)\r\nsnd_soc_update_bits(codec, CS42L73_CPFCHC,\r\nCS42L73_CHARGEPUMP_MASK,\r\ncs42l73->pdata.chgfreq << 4);\r\ncs42l73->mclksel = CS42L73_CLKID_MCLK1;\r\ncs42l73->mclk = 0;\r\nreturn 0;\r\n}\r\nstatic int cs42l73_i2c_probe(struct i2c_client *i2c_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct cs42l73_private *cs42l73;\r\nstruct cs42l73_platform_data *pdata = dev_get_platdata(&i2c_client->dev);\r\nint ret;\r\nunsigned int devid = 0;\r\nunsigned int reg;\r\nu32 val32;\r\ncs42l73 = devm_kzalloc(&i2c_client->dev, sizeof(struct cs42l73_private),\r\nGFP_KERNEL);\r\nif (!cs42l73)\r\nreturn -ENOMEM;\r\ncs42l73->regmap = devm_regmap_init_i2c(i2c_client, &cs42l73_regmap);\r\nif (IS_ERR(cs42l73->regmap)) {\r\nret = PTR_ERR(cs42l73->regmap);\r\ndev_err(&i2c_client->dev, "regmap_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (pdata) {\r\ncs42l73->pdata = *pdata;\r\n} else {\r\npdata = devm_kzalloc(&i2c_client->dev,\r\nsizeof(struct cs42l73_platform_data),\r\nGFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(&i2c_client->dev, "could not allocate pdata\n");\r\nreturn -ENOMEM;\r\n}\r\nif (i2c_client->dev.of_node) {\r\nif (of_property_read_u32(i2c_client->dev.of_node,\r\n"chgfreq", &val32) >= 0)\r\npdata->chgfreq = val32;\r\n}\r\npdata->reset_gpio = of_get_named_gpio(i2c_client->dev.of_node,\r\n"reset-gpio", 0);\r\ncs42l73->pdata = *pdata;\r\n}\r\ni2c_set_clientdata(i2c_client, cs42l73);\r\nif (cs42l73->pdata.reset_gpio) {\r\nret = devm_gpio_request_one(&i2c_client->dev,\r\ncs42l73->pdata.reset_gpio,\r\nGPIOF_OUT_INIT_HIGH,\r\n"CS42L73 /RST");\r\nif (ret < 0) {\r\ndev_err(&i2c_client->dev, "Failed to request /RST %d: %d\n",\r\ncs42l73->pdata.reset_gpio, ret);\r\nreturn ret;\r\n}\r\ngpio_set_value_cansleep(cs42l73->pdata.reset_gpio, 0);\r\ngpio_set_value_cansleep(cs42l73->pdata.reset_gpio, 1);\r\n}\r\nret = regmap_read(cs42l73->regmap, CS42L73_DEVID_AB, &reg);\r\ndevid = (reg & 0xFF) << 12;\r\nret = regmap_read(cs42l73->regmap, CS42L73_DEVID_CD, &reg);\r\ndevid |= (reg & 0xFF) << 4;\r\nret = regmap_read(cs42l73->regmap, CS42L73_DEVID_E, &reg);\r\ndevid |= (reg & 0xF0) >> 4;\r\nif (devid != CS42L73_DEVID) {\r\nret = -ENODEV;\r\ndev_err(&i2c_client->dev,\r\n"CS42L73 Device ID (%X). Expected %X\n",\r\ndevid, CS42L73_DEVID);\r\nreturn ret;\r\n}\r\nret = regmap_read(cs42l73->regmap, CS42L73_REVID, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c_client->dev, "Get Revision ID failed\n");\r\nreturn ret;;\r\n}\r\ndev_info(&i2c_client->dev,\r\n"Cirrus Logic CS42L73, Revision: %02X\n", reg & 0xFF);\r\nret = snd_soc_register_codec(&i2c_client->dev,\r\n&soc_codec_dev_cs42l73, cs42l73_dai,\r\nARRAY_SIZE(cs42l73_dai));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int cs42l73_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
