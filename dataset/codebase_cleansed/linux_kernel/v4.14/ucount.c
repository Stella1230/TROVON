static struct ctl_table_set *\r\nset_lookup(struct ctl_table_root *root)\r\n{\r\nreturn &current_user_ns()->set;\r\n}\r\nstatic int set_is_seen(struct ctl_table_set *set)\r\n{\r\nreturn &current_user_ns()->set == set;\r\n}\r\nstatic int set_permissions(struct ctl_table_header *head,\r\nstruct ctl_table *table)\r\n{\r\nstruct user_namespace *user_ns =\r\ncontainer_of(head->set, struct user_namespace, set);\r\nint mode;\r\nif (ns_capable(user_ns, CAP_SYS_RESOURCE))\r\nmode = (table->mode & S_IRWXU) >> 6;\r\nelse\r\nmode = table->mode & S_IROTH;\r\nreturn (mode << 6) | (mode << 3) | mode;\r\n}\r\nbool setup_userns_sysctls(struct user_namespace *ns)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nstruct ctl_table *tbl;\r\nsetup_sysctl_set(&ns->set, &set_root, set_is_seen);\r\ntbl = kmemdup(user_table, sizeof(user_table), GFP_KERNEL);\r\nif (tbl) {\r\nint i;\r\nfor (i = 0; i < UCOUNT_COUNTS; i++) {\r\ntbl[i].data = &ns->ucount_max[i];\r\n}\r\nns->sysctls = __register_sysctl_table(&ns->set, "user", tbl);\r\n}\r\nif (!ns->sysctls) {\r\nkfree(tbl);\r\nretire_sysctl_set(&ns->set);\r\nreturn false;\r\n}\r\n#endif\r\nreturn true;\r\n}\r\nvoid retire_userns_sysctls(struct user_namespace *ns)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nstruct ctl_table *tbl;\r\ntbl = ns->sysctls->ctl_table_arg;\r\nunregister_sysctl_table(ns->sysctls);\r\nretire_sysctl_set(&ns->set);\r\nkfree(tbl);\r\n#endif\r\n}\r\nstatic struct ucounts *find_ucounts(struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent)\r\n{\r\nstruct ucounts *ucounts;\r\nhlist_for_each_entry(ucounts, hashent, node) {\r\nif (uid_eq(ucounts->uid, uid) && (ucounts->ns == ns))\r\nreturn ucounts;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\r\n{\r\nstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\r\nstruct ucounts *ucounts, *new;\r\nspin_lock_irq(&ucounts_lock);\r\nucounts = find_ucounts(ns, uid, hashent);\r\nif (!ucounts) {\r\nspin_unlock_irq(&ucounts_lock);\r\nnew = kzalloc(sizeof(*new), GFP_KERNEL);\r\nif (!new)\r\nreturn NULL;\r\nnew->ns = ns;\r\nnew->uid = uid;\r\nnew->count = 0;\r\nspin_lock_irq(&ucounts_lock);\r\nucounts = find_ucounts(ns, uid, hashent);\r\nif (ucounts) {\r\nkfree(new);\r\n} else {\r\nhlist_add_head(&new->node, hashent);\r\nucounts = new;\r\n}\r\n}\r\nif (ucounts->count == INT_MAX)\r\nucounts = NULL;\r\nelse\r\nucounts->count += 1;\r\nspin_unlock_irq(&ucounts_lock);\r\nreturn ucounts;\r\n}\r\nstatic void put_ucounts(struct ucounts *ucounts)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ucounts_lock, flags);\r\nucounts->count -= 1;\r\nif (!ucounts->count)\r\nhlist_del_init(&ucounts->node);\r\nelse\r\nucounts = NULL;\r\nspin_unlock_irqrestore(&ucounts_lock, flags);\r\nkfree(ucounts);\r\n}\r\nstatic inline bool atomic_inc_below(atomic_t *v, int u)\r\n{\r\nint c, old;\r\nc = atomic_read(v);\r\nfor (;;) {\r\nif (unlikely(c >= u))\r\nreturn false;\r\nold = atomic_cmpxchg(v, c, c+1);\r\nif (likely(old == c))\r\nreturn true;\r\nc = old;\r\n}\r\n}\r\nstruct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid,\r\nenum ucount_type type)\r\n{\r\nstruct ucounts *ucounts, *iter, *bad;\r\nstruct user_namespace *tns;\r\nucounts = get_ucounts(ns, uid);\r\nfor (iter = ucounts; iter; iter = tns->ucounts) {\r\nint max;\r\ntns = iter->ns;\r\nmax = READ_ONCE(tns->ucount_max[type]);\r\nif (!atomic_inc_below(&iter->ucount[type], max))\r\ngoto fail;\r\n}\r\nreturn ucounts;\r\nfail:\r\nbad = iter;\r\nfor (iter = ucounts; iter != bad; iter = iter->ns->ucounts)\r\natomic_dec(&iter->ucount[type]);\r\nput_ucounts(ucounts);\r\nreturn NULL;\r\n}\r\nvoid dec_ucount(struct ucounts *ucounts, enum ucount_type type)\r\n{\r\nstruct ucounts *iter;\r\nfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\r\nint dec = atomic_dec_if_positive(&iter->ucount[type]);\r\nWARN_ON_ONCE(dec < 0);\r\n}\r\nput_ucounts(ucounts);\r\n}\r\nstatic __init int user_namespace_sysctl_init(void)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nstatic struct ctl_table_header *user_header;\r\nstatic struct ctl_table empty[1];\r\nuser_header = register_sysctl("user", empty);\r\nkmemleak_ignore(user_header);\r\nBUG_ON(!user_header);\r\nBUG_ON(!setup_userns_sysctls(&init_user_ns));\r\n#endif\r\nreturn 0;\r\n}
