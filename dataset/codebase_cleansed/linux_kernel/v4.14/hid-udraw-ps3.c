static int clamp_accel(int axis, int offset)\r\n{\r\naxis = clamp(axis,\r\naccel_limits[offset].min,\r\naccel_limits[offset].max);\r\naxis = (axis - accel_limits[offset].min) /\r\n((accel_limits[offset].max -\r\naccel_limits[offset].min) * 0xFF);\r\nreturn axis;\r\n}\r\nstatic int udraw_raw_event(struct hid_device *hdev, struct hid_report *report,\r\nu8 *data, int len)\r\n{\r\nstruct udraw *udraw = hid_get_drvdata(hdev);\r\nint touch;\r\nint x, y, z;\r\nif (len != 27)\r\nreturn 0;\r\nif (data[11] == 0x00)\r\ntouch = TOUCH_NONE;\r\nelse if (data[11] == 0x40)\r\ntouch = TOUCH_PEN;\r\nelse if (data[11] == 0x80)\r\ntouch = TOUCH_FINGER;\r\nelse\r\ntouch = TOUCH_TWOFINGER;\r\ninput_report_key(udraw->joy_input_dev, BTN_WEST, data[0] & 1);\r\ninput_report_key(udraw->joy_input_dev, BTN_SOUTH, !!(data[0] & 2));\r\ninput_report_key(udraw->joy_input_dev, BTN_EAST, !!(data[0] & 4));\r\ninput_report_key(udraw->joy_input_dev, BTN_NORTH, !!(data[0] & 8));\r\ninput_report_key(udraw->joy_input_dev, BTN_SELECT, !!(data[1] & 1));\r\ninput_report_key(udraw->joy_input_dev, BTN_START, !!(data[1] & 2));\r\ninput_report_key(udraw->joy_input_dev, BTN_MODE, !!(data[1] & 16));\r\nx = y = 0;\r\nswitch (data[2]) {\r\ncase 0x0:\r\ny = -127;\r\nbreak;\r\ncase 0x1:\r\ny = -127;\r\nx = 127;\r\nbreak;\r\ncase 0x2:\r\nx = 127;\r\nbreak;\r\ncase 0x3:\r\ny = 127;\r\nx = 127;\r\nbreak;\r\ncase 0x4:\r\ny = 127;\r\nbreak;\r\ncase 0x5:\r\ny = 127;\r\nx = -127;\r\nbreak;\r\ncase 0x6:\r\nx = -127;\r\nbreak;\r\ncase 0x7:\r\ny = -127;\r\nx = -127;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ninput_report_abs(udraw->joy_input_dev, ABS_X, x);\r\ninput_report_abs(udraw->joy_input_dev, ABS_Y, y);\r\ninput_sync(udraw->joy_input_dev);\r\nx = y = 0;\r\nif (touch != TOUCH_NONE) {\r\nif (data[15] != 0x0F)\r\nx = data[15] * 256 + data[17];\r\nif (data[16] != 0x0F)\r\ny = data[16] * 256 + data[18];\r\n}\r\nif (touch == TOUCH_FINGER) {\r\nudraw->last_one_finger_x = x;\r\nudraw->last_one_finger_y = y;\r\nudraw->last_two_finger_x = -1;\r\nudraw->last_two_finger_y = -1;\r\n} else if (touch == TOUCH_TWOFINGER) {\r\nif (udraw->last_two_finger_x == -1) {\r\nudraw->last_two_finger_x = x;\r\nudraw->last_two_finger_y = y;\r\nx = udraw->last_one_finger_x;\r\ny = udraw->last_one_finger_y;\r\n} else {\r\nx = x - (udraw->last_two_finger_x\r\n- udraw->last_one_finger_x);\r\ny = y - (udraw->last_two_finger_y\r\n- udraw->last_one_finger_y);\r\n}\r\n}\r\nif (touch == TOUCH_FINGER || touch == TOUCH_TWOFINGER) {\r\ninput_report_key(udraw->touch_input_dev, BTN_TOUCH, 1);\r\ninput_report_key(udraw->touch_input_dev, BTN_TOOL_FINGER,\r\ntouch == TOUCH_FINGER);\r\ninput_report_key(udraw->touch_input_dev, BTN_TOOL_DOUBLETAP,\r\ntouch == TOUCH_TWOFINGER);\r\ninput_report_abs(udraw->touch_input_dev, ABS_X, x);\r\ninput_report_abs(udraw->touch_input_dev, ABS_Y, y);\r\n} else {\r\ninput_report_key(udraw->touch_input_dev, BTN_TOUCH, 0);\r\ninput_report_key(udraw->touch_input_dev, BTN_TOOL_FINGER, 0);\r\ninput_report_key(udraw->touch_input_dev, BTN_TOOL_DOUBLETAP, 0);\r\n}\r\ninput_sync(udraw->touch_input_dev);\r\nif (touch == TOUCH_PEN) {\r\nint level;\r\nlevel = clamp(data[13] - PRESSURE_OFFSET,\r\n0, MAX_PRESSURE);\r\ninput_report_key(udraw->pen_input_dev, BTN_TOUCH, (level != 0));\r\ninput_report_key(udraw->pen_input_dev, BTN_TOOL_PEN, 1);\r\ninput_report_abs(udraw->pen_input_dev, ABS_PRESSURE, level);\r\ninput_report_abs(udraw->pen_input_dev, ABS_X, x);\r\ninput_report_abs(udraw->pen_input_dev, ABS_Y, y);\r\n} else {\r\ninput_report_key(udraw->pen_input_dev, BTN_TOUCH, 0);\r\ninput_report_key(udraw->pen_input_dev, BTN_TOOL_PEN, 0);\r\ninput_report_abs(udraw->pen_input_dev, ABS_PRESSURE, 0);\r\n}\r\ninput_sync(udraw->pen_input_dev);\r\nx = (data[19] + (data[20] << 8));\r\nx = clamp_accel(x, AXIS_X);\r\ny = (data[21] + (data[22] << 8));\r\ny = clamp_accel(y, AXIS_Y);\r\nz = (data[23] + (data[24] << 8));\r\nz = clamp_accel(z, AXIS_Z);\r\ninput_report_abs(udraw->accel_input_dev, ABS_X, x);\r\ninput_report_abs(udraw->accel_input_dev, ABS_Y, y);\r\ninput_report_abs(udraw->accel_input_dev, ABS_Z, z);\r\ninput_sync(udraw->accel_input_dev);\r\nreturn 0;\r\n}\r\nstatic int udraw_open(struct input_dev *dev)\r\n{\r\nstruct udraw *udraw = input_get_drvdata(dev);\r\nreturn hid_hw_open(udraw->hdev);\r\n}\r\nstatic void udraw_close(struct input_dev *dev)\r\n{\r\nstruct udraw *udraw = input_get_drvdata(dev);\r\nhid_hw_close(udraw->hdev);\r\n}\r\nstatic struct input_dev *allocate_and_setup(struct hid_device *hdev,\r\nconst char *name)\r\n{\r\nstruct input_dev *input_dev;\r\ninput_dev = devm_input_allocate_device(&hdev->dev);\r\nif (!input_dev)\r\nreturn NULL;\r\ninput_dev->name = name;\r\ninput_dev->phys = hdev->phys;\r\ninput_dev->dev.parent = &hdev->dev;\r\ninput_dev->open = udraw_open;\r\ninput_dev->close = udraw_close;\r\ninput_dev->uniq = hdev->uniq;\r\ninput_dev->id.bustype = hdev->bus;\r\ninput_dev->id.vendor = hdev->vendor;\r\ninput_dev->id.product = hdev->product;\r\ninput_dev->id.version = hdev->version;\r\ninput_set_drvdata(input_dev, hid_get_drvdata(hdev));\r\nreturn input_dev;\r\n}\r\nstatic bool udraw_setup_touch(struct udraw *udraw,\r\nstruct hid_device *hdev)\r\n{\r\nstruct input_dev *input_dev;\r\ninput_dev = allocate_and_setup(hdev, DEVICE_NAME " Touchpad");\r\nif (!input_dev)\r\nreturn false;\r\ninput_dev->evbit[0] = BIT(EV_ABS) | BIT(EV_KEY);\r\ninput_set_abs_params(input_dev, ABS_X, 0, RES_X, 1, 0);\r\ninput_abs_set_res(input_dev, ABS_X, RES_X / WIDTH);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, RES_Y, 1, 0);\r\ninput_abs_set_res(input_dev, ABS_Y, RES_Y / HEIGHT);\r\nset_bit(BTN_TOUCH, input_dev->keybit);\r\nset_bit(BTN_TOOL_FINGER, input_dev->keybit);\r\nset_bit(BTN_TOOL_DOUBLETAP, input_dev->keybit);\r\nset_bit(INPUT_PROP_POINTER, input_dev->propbit);\r\nudraw->touch_input_dev = input_dev;\r\nreturn true;\r\n}\r\nstatic bool udraw_setup_pen(struct udraw *udraw,\r\nstruct hid_device *hdev)\r\n{\r\nstruct input_dev *input_dev;\r\ninput_dev = allocate_and_setup(hdev, DEVICE_NAME " Pen");\r\nif (!input_dev)\r\nreturn false;\r\ninput_dev->evbit[0] = BIT(EV_ABS) | BIT(EV_KEY);\r\ninput_set_abs_params(input_dev, ABS_X, 0, RES_X, 1, 0);\r\ninput_abs_set_res(input_dev, ABS_X, RES_X / WIDTH);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, RES_Y, 1, 0);\r\ninput_abs_set_res(input_dev, ABS_Y, RES_Y / HEIGHT);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE,\r\n0, MAX_PRESSURE, 0, 0);\r\nset_bit(BTN_TOUCH, input_dev->keybit);\r\nset_bit(BTN_TOOL_PEN, input_dev->keybit);\r\nset_bit(INPUT_PROP_POINTER, input_dev->propbit);\r\nudraw->pen_input_dev = input_dev;\r\nreturn true;\r\n}\r\nstatic bool udraw_setup_accel(struct udraw *udraw,\r\nstruct hid_device *hdev)\r\n{\r\nstruct input_dev *input_dev;\r\ninput_dev = allocate_and_setup(hdev, DEVICE_NAME " Accelerometer");\r\nif (!input_dev)\r\nreturn false;\r\ninput_dev->evbit[0] = BIT(EV_ABS);\r\ninput_set_abs_params(input_dev, ABS_X, -512, 512, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, -512, 512, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Z, -512, 512, 0, 0);\r\nset_bit(INPUT_PROP_ACCELEROMETER, input_dev->propbit);\r\nudraw->accel_input_dev = input_dev;\r\nreturn true;\r\n}\r\nstatic bool udraw_setup_joypad(struct udraw *udraw,\r\nstruct hid_device *hdev)\r\n{\r\nstruct input_dev *input_dev;\r\ninput_dev = allocate_and_setup(hdev, DEVICE_NAME " Joypad");\r\nif (!input_dev)\r\nreturn false;\r\ninput_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);\r\nset_bit(BTN_SOUTH, input_dev->keybit);\r\nset_bit(BTN_NORTH, input_dev->keybit);\r\nset_bit(BTN_EAST, input_dev->keybit);\r\nset_bit(BTN_WEST, input_dev->keybit);\r\nset_bit(BTN_SELECT, input_dev->keybit);\r\nset_bit(BTN_START, input_dev->keybit);\r\nset_bit(BTN_MODE, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_X, -127, 127, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, -127, 127, 0, 0);\r\nudraw->joy_input_dev = input_dev;\r\nreturn true;\r\n}\r\nstatic int udraw_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nstruct udraw *udraw;\r\nint ret;\r\nudraw = devm_kzalloc(&hdev->dev, sizeof(struct udraw), GFP_KERNEL);\r\nif (!udraw)\r\nreturn -ENOMEM;\r\nudraw->hdev = hdev;\r\nudraw->last_two_finger_x = -1;\r\nudraw->last_two_finger_y = -1;\r\nhid_set_drvdata(hdev, udraw);\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\nreturn ret;\r\n}\r\nif (!udraw_setup_joypad(udraw, hdev) ||\r\n!udraw_setup_touch(udraw, hdev) ||\r\n!udraw_setup_pen(udraw, hdev) ||\r\n!udraw_setup_accel(udraw, hdev)) {\r\nhid_err(hdev, "could not allocate interfaces\n");\r\nreturn -ENOMEM;\r\n}\r\nret = input_register_device(udraw->joy_input_dev) ||\r\ninput_register_device(udraw->touch_input_dev) ||\r\ninput_register_device(udraw->pen_input_dev) ||\r\ninput_register_device(udraw->accel_input_dev);\r\nif (ret) {\r\nhid_err(hdev, "failed to register interfaces\n");\r\nreturn ret;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_HIDRAW | HID_CONNECT_DRIVER);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
