static unsigned ehci_moschip_read_frame_index(struct ehci_hcd *ehci)\r\n{\r\nunsigned uf;\r\nuf = ehci_readl(ehci, &ehci->regs->frame_index);\r\nif (unlikely((uf & 7) == 0))\r\nuf = ehci_readl(ehci, &ehci->regs->frame_index);\r\nreturn uf;\r\n}\r\nstatic inline unsigned ehci_read_frame_index(struct ehci_hcd *ehci)\r\n{\r\nif (ehci->frame_index_bug)\r\nreturn ehci_moschip_read_frame_index(ehci);\r\nreturn ehci_readl(ehci, &ehci->regs->frame_index);\r\n}\r\nint ehci_handshake(struct ehci_hcd *ehci, void __iomem *ptr,\r\nu32 mask, u32 done, int usec)\r\n{\r\nu32 result;\r\ndo {\r\nresult = ehci_readl(ehci, ptr);\r\nif (result == ~(u32)0)\r\nreturn -ENODEV;\r\nresult &= mask;\r\nif (result == done)\r\nreturn 0;\r\nudelay (1);\r\nusec--;\r\n} while (usec > 0);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int tdi_in_host_mode (struct ehci_hcd *ehci)\r\n{\r\nu32 tmp;\r\ntmp = ehci_readl(ehci, &ehci->regs->usbmode);\r\nreturn (tmp & 3) == USBMODE_CM_HC;\r\n}\r\nstatic int ehci_halt (struct ehci_hcd *ehci)\r\n{\r\nu32 temp;\r\nspin_lock_irq(&ehci->lock);\r\nehci_writel(ehci, 0, &ehci->regs->intr_enable);\r\nif (ehci_is_TDI(ehci) && !tdi_in_host_mode(ehci)) {\r\nspin_unlock_irq(&ehci->lock);\r\nreturn 0;\r\n}\r\nehci->command &= ~CMD_RUN;\r\ntemp = ehci_readl(ehci, &ehci->regs->command);\r\ntemp &= ~(CMD_RUN | CMD_IAAD);\r\nehci_writel(ehci, temp, &ehci->regs->command);\r\nspin_unlock_irq(&ehci->lock);\r\nsynchronize_irq(ehci_to_hcd(ehci)->irq);\r\nreturn ehci_handshake(ehci, &ehci->regs->status,\r\nSTS_HALT, STS_HALT, 16 * 125);\r\n}\r\nstatic void tdi_reset (struct ehci_hcd *ehci)\r\n{\r\nu32 tmp;\r\ntmp = ehci_readl(ehci, &ehci->regs->usbmode);\r\ntmp |= USBMODE_CM_HC;\r\nif (ehci_big_endian_mmio(ehci))\r\ntmp |= USBMODE_BE;\r\nehci_writel(ehci, tmp, &ehci->regs->usbmode);\r\n}\r\nint ehci_reset(struct ehci_hcd *ehci)\r\n{\r\nint retval;\r\nu32 command = ehci_readl(ehci, &ehci->regs->command);\r\nif (ehci->debug && !dbgp_reset_prep(ehci_to_hcd(ehci)))\r\nehci->debug = NULL;\r\ncommand |= CMD_RESET;\r\ndbg_cmd (ehci, "reset", command);\r\nehci_writel(ehci, command, &ehci->regs->command);\r\nehci->rh_state = EHCI_RH_HALTED;\r\nehci->next_statechange = jiffies;\r\nretval = ehci_handshake(ehci, &ehci->regs->command,\r\nCMD_RESET, 0, 250 * 1000);\r\nif (ehci->has_hostpc) {\r\nehci_writel(ehci, USBMODE_EX_HC | USBMODE_EX_VBPS,\r\n&ehci->regs->usbmode_ex);\r\nehci_writel(ehci, TXFIFO_DEFAULT, &ehci->regs->txfill_tuning);\r\n}\r\nif (retval)\r\nreturn retval;\r\nif (ehci_is_TDI(ehci))\r\ntdi_reset (ehci);\r\nif (ehci->debug)\r\ndbgp_external_startup(ehci_to_hcd(ehci));\r\nehci->port_c_suspend = ehci->suspended_ports =\r\nehci->resuming_ports = 0;\r\nreturn retval;\r\n}\r\nstatic void ehci_quiesce (struct ehci_hcd *ehci)\r\n{\r\nu32 temp;\r\nif (ehci->rh_state != EHCI_RH_RUNNING)\r\nreturn;\r\ntemp = (ehci->command << 10) & (STS_ASS | STS_PSS);\r\nehci_handshake(ehci, &ehci->regs->status, STS_ASS | STS_PSS, temp,\r\n16 * 125);\r\nspin_lock_irq(&ehci->lock);\r\nehci->command &= ~(CMD_ASE | CMD_PSE);\r\nehci_writel(ehci, ehci->command, &ehci->regs->command);\r\nspin_unlock_irq(&ehci->lock);\r\nehci_handshake(ehci, &ehci->regs->status, STS_ASS | STS_PSS, 0,\r\n16 * 125);\r\n}\r\nstatic void ehci_turn_off_all_ports(struct ehci_hcd *ehci)\r\n{\r\nint port = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nspin_unlock_irq(&ehci->lock);\r\nehci_port_power(ehci, port, false);\r\nspin_lock_irq(&ehci->lock);\r\nehci_writel(ehci, PORT_RWC_BITS,\r\n&ehci->regs->port_status[port]);\r\n}\r\n}\r\nstatic void ehci_silence_controller(struct ehci_hcd *ehci)\r\n{\r\nehci_halt(ehci);\r\nspin_lock_irq(&ehci->lock);\r\nehci->rh_state = EHCI_RH_HALTED;\r\nehci_turn_off_all_ports(ehci);\r\nehci_writel(ehci, 0, &ehci->regs->configured_flag);\r\nehci_readl(ehci, &ehci->regs->configured_flag);\r\nspin_unlock_irq(&ehci->lock);\r\n}\r\nstatic void ehci_shutdown(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nif (!ehci->sbrn)\r\nreturn;\r\nspin_lock_irq(&ehci->lock);\r\nehci->shutdown = true;\r\nehci->rh_state = EHCI_RH_STOPPING;\r\nehci->enabled_hrtimer_events = 0;\r\nspin_unlock_irq(&ehci->lock);\r\nehci_silence_controller(ehci);\r\nhrtimer_cancel(&ehci->hrtimer);\r\n}\r\nstatic void ehci_work (struct ehci_hcd *ehci)\r\n{\r\nif (ehci->scanning) {\r\nehci->need_rescan = true;\r\nreturn;\r\n}\r\nehci->scanning = true;\r\nrescan:\r\nehci->need_rescan = false;\r\nif (ehci->async_count)\r\nscan_async(ehci);\r\nif (ehci->intr_count > 0)\r\nscan_intr(ehci);\r\nif (ehci->isoc_count > 0)\r\nscan_isoc(ehci);\r\nif (ehci->need_rescan)\r\ngoto rescan;\r\nehci->scanning = false;\r\nturn_on_io_watchdog(ehci);\r\n}\r\nstatic void ehci_stop (struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci (hcd);\r\nehci_dbg (ehci, "stop\n");\r\nspin_lock_irq(&ehci->lock);\r\nehci->enabled_hrtimer_events = 0;\r\nspin_unlock_irq(&ehci->lock);\r\nehci_quiesce(ehci);\r\nehci_silence_controller(ehci);\r\nehci_reset (ehci);\r\nhrtimer_cancel(&ehci->hrtimer);\r\nremove_sysfs_files(ehci);\r\nremove_debug_files (ehci);\r\nspin_lock_irq (&ehci->lock);\r\nend_free_itds(ehci);\r\nspin_unlock_irq (&ehci->lock);\r\nehci_mem_cleanup (ehci);\r\nif (ehci->amd_pll_fix == 1)\r\nusb_amd_dev_put();\r\ndbg_status (ehci, "ehci_stop completed",\r\nehci_readl(ehci, &ehci->regs->status));\r\n}\r\nstatic int ehci_init(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nu32 temp;\r\nint retval;\r\nu32 hcc_params;\r\nstruct ehci_qh_hw *hw;\r\nspin_lock_init(&ehci->lock);\r\nehci->need_io_watchdog = 1;\r\nhrtimer_init(&ehci->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\nehci->hrtimer.function = ehci_hrtimer_func;\r\nehci->next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;\r\nhcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);\r\nehci->uframe_periodic_max = 100;\r\nehci->periodic_size = DEFAULT_I_TDPS;\r\nINIT_LIST_HEAD(&ehci->async_unlink);\r\nINIT_LIST_HEAD(&ehci->async_idle);\r\nINIT_LIST_HEAD(&ehci->intr_unlink_wait);\r\nINIT_LIST_HEAD(&ehci->intr_unlink);\r\nINIT_LIST_HEAD(&ehci->intr_qh_list);\r\nINIT_LIST_HEAD(&ehci->cached_itd_list);\r\nINIT_LIST_HEAD(&ehci->cached_sitd_list);\r\nINIT_LIST_HEAD(&ehci->tt_list);\r\nif (HCC_PGM_FRAMELISTLEN(hcc_params)) {\r\nswitch (EHCI_TUNE_FLS) {\r\ncase 0: ehci->periodic_size = 1024; break;\r\ncase 1: ehci->periodic_size = 512; break;\r\ncase 2: ehci->periodic_size = 256; break;\r\ndefault: BUG();\r\n}\r\n}\r\nif ((retval = ehci_mem_init(ehci, GFP_KERNEL)) < 0)\r\nreturn retval;\r\nif (HCC_ISOC_CACHE(hcc_params))\r\nehci->i_thresh = 0;\r\nelse\r\nehci->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);\r\nehci->async->qh_next.qh = NULL;\r\nhw = ehci->async->hw;\r\nhw->hw_next = QH_NEXT(ehci, ehci->async->qh_dma);\r\nhw->hw_info1 = cpu_to_hc32(ehci, QH_HEAD);\r\n#if defined(CONFIG_PPC_PS3)\r\nhw->hw_info1 |= cpu_to_hc32(ehci, QH_INACTIVATE);\r\n#endif\r\nhw->hw_token = cpu_to_hc32(ehci, QTD_STS_HALT);\r\nhw->hw_qtd_next = EHCI_LIST_END(ehci);\r\nehci->async->qh_state = QH_STATE_LINKED;\r\nhw->hw_alt_next = QTD_NEXT(ehci, ehci->async->dummy->qtd_dma);\r\nif (log2_irq_thresh < 0 || log2_irq_thresh > 6)\r\nlog2_irq_thresh = 0;\r\ntemp = 1 << (16 + log2_irq_thresh);\r\nif (HCC_PER_PORT_CHANGE_EVENT(hcc_params)) {\r\nehci->has_ppcd = 1;\r\nehci_dbg(ehci, "enable per-port change event\n");\r\ntemp |= CMD_PPCEE;\r\n}\r\nif (HCC_CANPARK(hcc_params)) {\r\nif (park) {\r\npark = min(park, (unsigned) 3);\r\ntemp |= CMD_PARK;\r\ntemp |= park << 8;\r\n}\r\nehci_dbg(ehci, "park %d\n", park);\r\n}\r\nif (HCC_PGM_FRAMELISTLEN(hcc_params)) {\r\ntemp &= ~(3 << 2);\r\ntemp |= (EHCI_TUNE_FLS << 2);\r\n}\r\nehci->command = temp;\r\nif (!(hcd->driver->flags & HCD_LOCAL_MEM))\r\nhcd->self.sg_tablesize = ~0;\r\nehci->old_current = ~0;\r\nreturn 0;\r\n}\r\nstatic int ehci_run (struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci (hcd);\r\nu32 temp;\r\nu32 hcc_params;\r\nhcd->uses_new_polling = 1;\r\nehci_writel(ehci, ehci->periodic_dma, &ehci->regs->frame_list);\r\nehci_writel(ehci, (u32)ehci->async->qh_dma, &ehci->regs->async_next);\r\nhcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);\r\nif (HCC_64BIT_ADDR(hcc_params)) {\r\nehci_writel(ehci, 0, &ehci->regs->segment);\r\n#if 0\r\nif (!dma_set_mask(hcd->self.controller, DMA_BIT_MASK(64)))\r\nehci_info(ehci, "enabled 64bit DMA\n");\r\n#endif\r\n}\r\nehci->command &= ~(CMD_LRESET|CMD_IAAD|CMD_PSE|CMD_ASE|CMD_RESET);\r\nehci->command |= CMD_RUN;\r\nehci_writel(ehci, ehci->command, &ehci->regs->command);\r\ndbg_cmd (ehci, "init", ehci->command);\r\ndown_write(&ehci_cf_port_reset_rwsem);\r\nehci->rh_state = EHCI_RH_RUNNING;\r\nehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);\r\nehci_readl(ehci, &ehci->regs->command);\r\nmsleep(5);\r\nup_write(&ehci_cf_port_reset_rwsem);\r\nehci->last_periodic_enable = ktime_get_real();\r\ntemp = HC_VERSION(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));\r\nehci_info (ehci,\r\n"USB %x.%x started, EHCI %x.%02x%s\n",\r\n((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),\r\ntemp >> 8, temp & 0xff,\r\nignore_oc ? ", overcurrent ignored" : "");\r\nehci_writel(ehci, INTR_MASK,\r\n&ehci->regs->intr_enable);\r\ncreate_debug_files(ehci);\r\ncreate_sysfs_files(ehci);\r\nreturn 0;\r\n}\r\nint ehci_setup(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nint retval;\r\nehci->regs = (void __iomem *)ehci->caps +\r\nHC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));\r\ndbg_hcs_params(ehci, "reset");\r\ndbg_hcc_params(ehci, "reset");\r\nehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);\r\nehci->sbrn = HCD_USB2;\r\nretval = ehci_init(hcd);\r\nif (retval)\r\nreturn retval;\r\nretval = ehci_halt(ehci);\r\nif (retval) {\r\nehci_mem_cleanup(ehci);\r\nreturn retval;\r\n}\r\nehci_reset(ehci);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ehci_irq (struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci (hcd);\r\nu32 status, masked_status, pcd_status = 0, cmd;\r\nint bh;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nstatus = ehci_readl(ehci, &ehci->regs->status);\r\nif (status == ~(u32) 0) {\r\nehci_dbg (ehci, "device removed\n");\r\ngoto dead;\r\n}\r\nmasked_status = status & (INTR_MASK | STS_FLR);\r\nif (!masked_status || unlikely(ehci->rh_state == EHCI_RH_HALTED)) {\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nehci_writel(ehci, masked_status, &ehci->regs->status);\r\ncmd = ehci_readl(ehci, &ehci->regs->command);\r\nbh = 0;\r\nif (likely ((status & (STS_INT|STS_ERR)) != 0)) {\r\nif (likely ((status & STS_ERR) == 0))\r\nCOUNT (ehci->stats.normal);\r\nelse\r\nCOUNT (ehci->stats.error);\r\nbh = 1;\r\n}\r\nif (status & STS_IAA) {\r\nehci->enabled_hrtimer_events &= ~BIT(EHCI_HRTIMER_IAA_WATCHDOG);\r\nif (ehci->next_hrtimer_event == EHCI_HRTIMER_IAA_WATCHDOG)\r\n++ehci->next_hrtimer_event;\r\nif (cmd & CMD_IAAD)\r\nehci_dbg(ehci, "IAA with IAAD still set?\n");\r\nif (ehci->iaa_in_progress)\r\nCOUNT(ehci->stats.iaa);\r\nend_iaa_cycle(ehci);\r\n}\r\nif (status & STS_PCD) {\r\nunsigned i = HCS_N_PORTS (ehci->hcs_params);\r\nu32 ppcd = ~0;\r\npcd_status = status;\r\nif (ehci->rh_state == EHCI_RH_SUSPENDED)\r\nusb_hcd_resume_root_hub(hcd);\r\nif (ehci->has_ppcd)\r\nppcd = status >> 16;\r\nwhile (i--) {\r\nint pstatus;\r\nif (!(ppcd & (1 << i)))\r\ncontinue;\r\npstatus = ehci_readl(ehci,\r\n&ehci->regs->port_status[i]);\r\nif (pstatus & PORT_OWNER)\r\ncontinue;\r\nif (!(test_bit(i, &ehci->suspended_ports) &&\r\n((pstatus & PORT_RESUME) ||\r\n!(pstatus & PORT_SUSPEND)) &&\r\n(pstatus & PORT_PE) &&\r\nehci->reset_done[i] == 0))\r\ncontinue;\r\nehci->reset_done[i] = jiffies +\r\nmsecs_to_jiffies(USB_RESUME_TIMEOUT);\r\nset_bit(i, &ehci->resuming_ports);\r\nehci_dbg (ehci, "port %d remote wakeup\n", i + 1);\r\nusb_hcd_start_port_resume(&hcd->self, i);\r\nmod_timer(&hcd->rh_timer, ehci->reset_done[i]);\r\n}\r\n}\r\nif (unlikely ((status & STS_FATAL) != 0)) {\r\nehci_err(ehci, "fatal error\n");\r\ndbg_cmd(ehci, "fatal", cmd);\r\ndbg_status(ehci, "fatal", status);\r\ndead:\r\nusb_hc_died(hcd);\r\nehci->shutdown = true;\r\nehci->rh_state = EHCI_RH_STOPPING;\r\nehci->command &= ~(CMD_RUN | CMD_ASE | CMD_PSE);\r\nehci_writel(ehci, ehci->command, &ehci->regs->command);\r\nehci_writel(ehci, 0, &ehci->regs->intr_enable);\r\nehci_handle_controller_death(ehci);\r\nbh = 0;\r\n}\r\nif (bh)\r\nehci_work (ehci);\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nif (pcd_status)\r\nusb_hcd_poll_rh_status(hcd);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ehci_urb_enqueue (\r\nstruct usb_hcd *hcd,\r\nstruct urb *urb,\r\ngfp_t mem_flags\r\n) {\r\nstruct ehci_hcd *ehci = hcd_to_ehci (hcd);\r\nstruct list_head qtd_list;\r\nINIT_LIST_HEAD (&qtd_list);\r\nswitch (usb_pipetype (urb->pipe)) {\r\ncase PIPE_CONTROL:\r\nif (urb->transfer_buffer_length > (16 * 1024))\r\nreturn -EMSGSIZE;\r\ndefault:\r\nif (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))\r\nreturn -ENOMEM;\r\nreturn submit_async(ehci, urb, &qtd_list, mem_flags);\r\ncase PIPE_INTERRUPT:\r\nif (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))\r\nreturn -ENOMEM;\r\nreturn intr_submit(ehci, urb, &qtd_list, mem_flags);\r\ncase PIPE_ISOCHRONOUS:\r\nif (urb->dev->speed == USB_SPEED_HIGH)\r\nreturn itd_submit (ehci, urb, mem_flags);\r\nelse\r\nreturn sitd_submit (ehci, urb, mem_flags);\r\n}\r\n}\r\nstatic int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci (hcd);\r\nstruct ehci_qh *qh;\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nrc = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (rc)\r\ngoto done;\r\nif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\r\n} else {\r\nqh = (struct ehci_qh *) urb->hcpriv;\r\nqh->unlink_reason |= QH_UNLINK_REQUESTED;\r\nswitch (qh->qh_state) {\r\ncase QH_STATE_LINKED:\r\nif (usb_pipetype(urb->pipe) == PIPE_INTERRUPT)\r\nstart_unlink_intr(ehci, qh);\r\nelse\r\nstart_unlink_async(ehci, qh);\r\nbreak;\r\ncase QH_STATE_COMPLETING:\r\nqh->dequeue_during_giveback = 1;\r\nbreak;\r\ncase QH_STATE_UNLINK:\r\ncase QH_STATE_UNLINK_WAIT:\r\nbreak;\r\ncase QH_STATE_IDLE:\r\nqh_completions(ehci, qh);\r\nbreak;\r\n}\r\n}\r\ndone:\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void\r\nehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci (hcd);\r\nunsigned long flags;\r\nstruct ehci_qh *qh;\r\nrescan:\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nqh = ep->hcpriv;\r\nif (!qh)\r\ngoto done;\r\nif (qh->hw == NULL) {\r\nstruct ehci_iso_stream *stream = ep->hcpriv;\r\nif (!list_empty(&stream->td_list))\r\ngoto idle_timeout;\r\nreserve_release_iso_bandwidth(ehci, stream, -1);\r\nkfree(stream);\r\ngoto done;\r\n}\r\nqh->unlink_reason |= QH_UNLINK_REQUESTED;\r\nswitch (qh->qh_state) {\r\ncase QH_STATE_LINKED:\r\nif (list_empty(&qh->qtd_list))\r\nqh->unlink_reason |= QH_UNLINK_QUEUE_EMPTY;\r\nelse\r\nWARN_ON(1);\r\nif (usb_endpoint_type(&ep->desc) != USB_ENDPOINT_XFER_INT)\r\nstart_unlink_async(ehci, qh);\r\nelse\r\nstart_unlink_intr(ehci, qh);\r\ncase QH_STATE_COMPLETING:\r\ncase QH_STATE_UNLINK:\r\ncase QH_STATE_UNLINK_WAIT:\r\nidle_timeout:\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nschedule_timeout_uninterruptible(1);\r\ngoto rescan;\r\ncase QH_STATE_IDLE:\r\nif (qh->clearing_tt)\r\ngoto idle_timeout;\r\nif (list_empty (&qh->qtd_list)) {\r\nif (qh->ps.bw_uperiod)\r\nreserve_release_intr_bandwidth(ehci, qh, -1);\r\nqh_destroy(ehci, qh);\r\nbreak;\r\n}\r\ndefault:\r\nehci_err (ehci, "qh %p (#%02x) state %d%s\n",\r\nqh, ep->desc.bEndpointAddress, qh->qh_state,\r\nlist_empty (&qh->qtd_list) ? "" : "(has tds)");\r\nbreak;\r\n}\r\ndone:\r\nep->hcpriv = NULL;\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\n}\r\nstatic void\r\nehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct ehci_qh *qh;\r\nint eptype = usb_endpoint_type(&ep->desc);\r\nint epnum = usb_endpoint_num(&ep->desc);\r\nint is_out = usb_endpoint_dir_out(&ep->desc);\r\nunsigned long flags;\r\nif (eptype != USB_ENDPOINT_XFER_BULK && eptype != USB_ENDPOINT_XFER_INT)\r\nreturn;\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nqh = ep->hcpriv;\r\nif (qh) {\r\nif (!list_empty(&qh->qtd_list)) {\r\nWARN_ONCE(1, "clear_halt for a busy endpoint\n");\r\n} else {\r\nusb_settoggle(qh->ps.udev, epnum, is_out, 0);\r\nqh->unlink_reason |= QH_UNLINK_REQUESTED;\r\nif (eptype == USB_ENDPOINT_XFER_BULK)\r\nstart_unlink_async(ehci, qh);\r\nelse\r\nstart_unlink_intr(ehci, qh);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\n}\r\nstatic int ehci_get_frame (struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci (hcd);\r\nreturn (ehci_read_frame_index(ehci) >> 3) % ehci->periodic_size;\r\n}\r\nstatic void ehci_remove_device(struct usb_hcd *hcd, struct usb_device *udev)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nspin_lock_irq(&ehci->lock);\r\ndrop_tt(udev);\r\nspin_unlock_irq(&ehci->lock);\r\n}\r\nint ehci_suspend(struct usb_hcd *hcd, bool do_wakeup)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nif (time_before(jiffies, ehci->next_statechange))\r\nmsleep(10);\r\nehci_prepare_ports_for_controller_suspend(ehci, do_wakeup);\r\nspin_lock_irq(&ehci->lock);\r\nehci_writel(ehci, 0, &ehci->regs->intr_enable);\r\n(void) ehci_readl(ehci, &ehci->regs->intr_enable);\r\nclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nspin_unlock_irq(&ehci->lock);\r\nsynchronize_irq(hcd->irq);\r\nif (do_wakeup && HCD_WAKEUP_PENDING(hcd)) {\r\nehci_resume(hcd, false);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nint ehci_resume(struct usb_hcd *hcd, bool force_reset)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nif (time_before(jiffies, ehci->next_statechange))\r\nmsleep(100);\r\nset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nif (ehci->shutdown)\r\nreturn 0;\r\nif (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF &&\r\n!force_reset) {\r\nint mask = INTR_MASK;\r\nehci_prepare_ports_for_controller_resume(ehci);\r\nspin_lock_irq(&ehci->lock);\r\nif (ehci->shutdown)\r\ngoto skip;\r\nif (!hcd->self.root_hub->do_remote_wakeup)\r\nmask &= ~STS_PCD;\r\nehci_writel(ehci, mask, &ehci->regs->intr_enable);\r\nehci_readl(ehci, &ehci->regs->intr_enable);\r\nskip:\r\nspin_unlock_irq(&ehci->lock);\r\nreturn 0;\r\n}\r\nusb_root_hub_lost_power(hcd->self.root_hub);\r\n(void) ehci_halt(ehci);\r\n(void) ehci_reset(ehci);\r\nspin_lock_irq(&ehci->lock);\r\nif (ehci->shutdown)\r\ngoto skip;\r\nehci_writel(ehci, ehci->command, &ehci->regs->command);\r\nehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);\r\nehci_readl(ehci, &ehci->regs->command);\r\nehci->rh_state = EHCI_RH_SUSPENDED;\r\nspin_unlock_irq(&ehci->lock);\r\nreturn 1;\r\n}\r\nvoid ehci_init_driver(struct hc_driver *drv,\r\nconst struct ehci_driver_overrides *over)\r\n{\r\n*drv = ehci_hc_driver;\r\nif (over) {\r\ndrv->hcd_priv_size += over->extra_priv_size;\r\nif (over->reset)\r\ndrv->reset = over->reset;\r\nif (over->port_power)\r\ndrv->port_power = over->port_power;\r\n}\r\n}\r\nstatic int __init ehci_hcd_init(void)\r\n{\r\nint retval = 0;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "%s: " DRIVER_DESC "\n", hcd_name);\r\nset_bit(USB_EHCI_LOADED, &usb_hcds_loaded);\r\nif (test_bit(USB_UHCI_LOADED, &usb_hcds_loaded) ||\r\ntest_bit(USB_OHCI_LOADED, &usb_hcds_loaded))\r\nprintk(KERN_WARNING "Warning! ehci_hcd should always be loaded"\r\n" before uhci_hcd and ohci_hcd, not after\n");\r\npr_debug("%s: block sizes: qh %zd qtd %zd itd %zd sitd %zd\n",\r\nhcd_name,\r\nsizeof(struct ehci_qh), sizeof(struct ehci_qtd),\r\nsizeof(struct ehci_itd), sizeof(struct ehci_sitd));\r\n#ifdef CONFIG_DYNAMIC_DEBUG\r\nehci_debug_root = debugfs_create_dir("ehci", usb_debug_root);\r\nif (!ehci_debug_root) {\r\nretval = -ENOENT;\r\ngoto err_debug;\r\n}\r\n#endif\r\n#ifdef PLATFORM_DRIVER\r\nretval = platform_driver_register(&PLATFORM_DRIVER);\r\nif (retval < 0)\r\ngoto clean0;\r\n#endif\r\n#ifdef PS3_SYSTEM_BUS_DRIVER\r\nretval = ps3_ehci_driver_register(&PS3_SYSTEM_BUS_DRIVER);\r\nif (retval < 0)\r\ngoto clean2;\r\n#endif\r\n#ifdef OF_PLATFORM_DRIVER\r\nretval = platform_driver_register(&OF_PLATFORM_DRIVER);\r\nif (retval < 0)\r\ngoto clean3;\r\n#endif\r\n#ifdef XILINX_OF_PLATFORM_DRIVER\r\nretval = platform_driver_register(&XILINX_OF_PLATFORM_DRIVER);\r\nif (retval < 0)\r\ngoto clean4;\r\n#endif\r\nreturn retval;\r\n#ifdef XILINX_OF_PLATFORM_DRIVER\r\nclean4:\r\n#endif\r\n#ifdef OF_PLATFORM_DRIVER\r\nplatform_driver_unregister(&OF_PLATFORM_DRIVER);\r\nclean3:\r\n#endif\r\n#ifdef PS3_SYSTEM_BUS_DRIVER\r\nps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);\r\nclean2:\r\n#endif\r\n#ifdef PLATFORM_DRIVER\r\nplatform_driver_unregister(&PLATFORM_DRIVER);\r\nclean0:\r\n#endif\r\n#ifdef CONFIG_DYNAMIC_DEBUG\r\ndebugfs_remove(ehci_debug_root);\r\nehci_debug_root = NULL;\r\nerr_debug:\r\n#endif\r\nclear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);\r\nreturn retval;\r\n}\r\nstatic void __exit ehci_hcd_cleanup(void)\r\n{\r\n#ifdef XILINX_OF_PLATFORM_DRIVER\r\nplatform_driver_unregister(&XILINX_OF_PLATFORM_DRIVER);\r\n#endif\r\n#ifdef OF_PLATFORM_DRIVER\r\nplatform_driver_unregister(&OF_PLATFORM_DRIVER);\r\n#endif\r\n#ifdef PLATFORM_DRIVER\r\nplatform_driver_unregister(&PLATFORM_DRIVER);\r\n#endif\r\n#ifdef PS3_SYSTEM_BUS_DRIVER\r\nps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);\r\n#endif\r\n#ifdef CONFIG_DYNAMIC_DEBUG\r\ndebugfs_remove(ehci_debug_root);\r\n#endif\r\nclear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);\r\n}
