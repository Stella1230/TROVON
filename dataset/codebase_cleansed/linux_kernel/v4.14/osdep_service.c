u8 *_rtw_malloc(u32 sz)\r\n{\r\nreturn kmalloc(sz, in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);\r\n}\r\nvoid *rtw_malloc2d(int h, int w, int size)\r\n{\r\nint j;\r\nvoid **a = kzalloc(h * sizeof(void *) + h * w * size, GFP_KERNEL);\r\nif (!a)\r\ngoto out;\r\nfor (j = 0; j < h; j++)\r\na[j] = ((char *)(a + h)) + j * w * size;\r\nout:\r\nreturn a;\r\n}\r\nvoid _rtw_init_queue(struct __queue *pqueue)\r\n{\r\nINIT_LIST_HEAD(&pqueue->queue);\r\nspin_lock_init(&pqueue->lock);\r\n}\r\nstruct net_device *rtw_alloc_etherdev_with_old_priv(void *old_priv)\r\n{\r\nstruct net_device *pnetdev;\r\nstruct rtw_netdev_priv_indicator *pnpi;\r\npnetdev = alloc_etherdev_mq(sizeof(struct rtw_netdev_priv_indicator), 4);\r\nif (!pnetdev)\r\ngoto RETURN;\r\npnpi = netdev_priv(pnetdev);\r\npnpi->priv = old_priv;\r\nRETURN:\r\nreturn pnetdev;\r\n}\r\nvoid rtw_free_netdev(struct net_device *netdev)\r\n{\r\nstruct rtw_netdev_priv_indicator *pnpi;\r\nif (!netdev)\r\ngoto RETURN;\r\npnpi = netdev_priv(netdev);\r\nif (!pnpi->priv)\r\ngoto RETURN;\r\nvfree(pnpi->priv);\r\nfree_netdev(netdev);\r\nRETURN:\r\nreturn;\r\n}\r\nu64 rtw_modular64(u64 x, u64 y)\r\n{\r\nreturn do_div(x, y);\r\n}\r\nvoid rtw_buf_free(u8 **buf, u32 *buf_len)\r\n{\r\n*buf_len = 0;\r\nkfree(*buf);\r\n*buf = NULL;\r\n}\r\nvoid rtw_buf_update(u8 **buf, u32 *buf_len, u8 *src, u32 src_len)\r\n{\r\nu32 dup_len = 0;\r\nu8 *ori = NULL;\r\nu8 *dup = NULL;\r\nif (!buf || !buf_len)\r\nreturn;\r\nif (!src || !src_len)\r\ngoto keep_ori;\r\ndup = rtw_malloc(src_len);\r\nif (dup) {\r\ndup_len = src_len;\r\nmemcpy(dup, src, dup_len);\r\n}\r\nkeep_ori:\r\nori = *buf;\r\n*buf_len = 0;\r\n*buf = dup;\r\n*buf_len = dup_len;\r\nkfree(ori);\r\n}
