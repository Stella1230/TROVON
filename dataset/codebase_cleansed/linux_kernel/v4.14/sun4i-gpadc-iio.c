static unsigned int sun4i_gpadc_chan_select(unsigned int chan)\r\n{\r\nreturn SUN4I_GPADC_CTRL1_ADC_CHAN_SELECT(chan);\r\n}\r\nstatic unsigned int sun6i_gpadc_chan_select(unsigned int chan)\r\n{\r\nreturn SUN6I_GPADC_CTRL1_ADC_CHAN_SELECT(chan);\r\n}\r\nstatic int sun4i_prepare_for_irq(struct iio_dev *indio_dev, int channel,\r\nunsigned int irq)\r\n{\r\nstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\r\nint ret;\r\nu32 reg;\r\npm_runtime_get_sync(indio_dev->dev.parent);\r\nreinit_completion(&info->completion);\r\nret = regmap_write(info->regmap, SUN4I_GPADC_INT_FIFOC,\r\nSUN4I_GPADC_INT_FIFOC_TP_FIFO_TRIG_LEVEL(1) |\r\nSUN4I_GPADC_INT_FIFOC_TP_FIFO_FLUSH);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_read(info->regmap, SUN4I_GPADC_CTRL1, &reg);\r\nif (ret)\r\nreturn ret;\r\nif (irq == info->fifo_data_irq) {\r\nret = regmap_write(info->regmap, SUN4I_GPADC_CTRL1,\r\ninfo->data->tp_mode_en |\r\ninfo->data->tp_adc_select |\r\ninfo->data->adc_chan_select(channel));\r\nif ((reg & info->data->adc_chan_mask) !=\r\ninfo->data->adc_chan_select(channel))\r\nmdelay(10);\r\n} else {\r\nret = regmap_write(info->regmap, SUN4I_GPADC_CTRL1,\r\ninfo->data->tp_mode_en);\r\n}\r\nif (ret)\r\nreturn ret;\r\nif ((reg & info->data->tp_adc_select) != info->data->tp_adc_select)\r\nmdelay(100);\r\nreturn 0;\r\n}\r\nstatic int sun4i_gpadc_read(struct iio_dev *indio_dev, int channel, int *val,\r\nunsigned int irq)\r\n{\r\nstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&info->mutex);\r\nret = sun4i_prepare_for_irq(indio_dev, channel, irq);\r\nif (ret)\r\ngoto err;\r\nenable_irq(irq);\r\nif (!wait_for_completion_timeout(&info->completion,\r\nmsecs_to_jiffies(1000))) {\r\nret = -ETIMEDOUT;\r\ngoto err;\r\n}\r\nif (irq == info->fifo_data_irq)\r\n*val = info->adc_data;\r\nelse\r\n*val = info->temp_data;\r\nret = 0;\r\npm_runtime_mark_last_busy(indio_dev->dev.parent);\r\nerr:\r\npm_runtime_put_autosuspend(indio_dev->dev.parent);\r\ndisable_irq(irq);\r\nmutex_unlock(&info->mutex);\r\nreturn ret;\r\n}\r\nstatic int sun4i_gpadc_adc_read(struct iio_dev *indio_dev, int channel,\r\nint *val)\r\n{\r\nstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\r\nreturn sun4i_gpadc_read(indio_dev, channel, val, info->fifo_data_irq);\r\n}\r\nstatic int sun4i_gpadc_temp_read(struct iio_dev *indio_dev, int *val)\r\n{\r\nstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\r\nif (info->no_irq) {\r\npm_runtime_get_sync(indio_dev->dev.parent);\r\nregmap_read(info->regmap, SUN4I_GPADC_TEMP_DATA, val);\r\npm_runtime_mark_last_busy(indio_dev->dev.parent);\r\npm_runtime_put_autosuspend(indio_dev->dev.parent);\r\nreturn 0;\r\n}\r\nreturn sun4i_gpadc_read(indio_dev, 0, val, info->temp_data_irq);\r\n}\r\nstatic int sun4i_gpadc_temp_offset(struct iio_dev *indio_dev, int *val)\r\n{\r\nstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\r\n*val = info->data->temp_offset;\r\nreturn 0;\r\n}\r\nstatic int sun4i_gpadc_temp_scale(struct iio_dev *indio_dev, int *val)\r\n{\r\nstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\r\n*val = info->data->temp_scale;\r\nreturn 0;\r\n}\r\nstatic int sun4i_gpadc_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val,\r\nint *val2, long mask)\r\n{\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_OFFSET:\r\nret = sun4i_gpadc_temp_offset(indio_dev, val);\r\nif (ret)\r\nreturn ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_RAW:\r\nif (chan->type == IIO_VOLTAGE)\r\nret = sun4i_gpadc_adc_read(indio_dev, chan->channel,\r\nval);\r\nelse\r\nret = sun4i_gpadc_temp_read(indio_dev, val);\r\nif (ret)\r\nreturn ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (chan->type == IIO_VOLTAGE) {\r\n*val = 0;\r\n*val2 = 732421875;\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\n}\r\nret = sun4i_gpadc_temp_scale(indio_dev, val);\r\nif (ret)\r\nreturn ret;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic irqreturn_t sun4i_gpadc_temp_data_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct sun4i_gpadc_iio *info = dev_id;\r\nif (atomic_read(&info->ignore_temp_data_irq))\r\ngoto out;\r\nif (!regmap_read(info->regmap, SUN4I_GPADC_TEMP_DATA, &info->temp_data))\r\ncomplete(&info->completion);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sun4i_gpadc_fifo_data_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct sun4i_gpadc_iio *info = dev_id;\r\nif (atomic_read(&info->ignore_fifo_data_irq))\r\ngoto out;\r\nif (!regmap_read(info->regmap, SUN4I_GPADC_DATA, &info->adc_data))\r\ncomplete(&info->completion);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sun4i_gpadc_runtime_suspend(struct device *dev)\r\n{\r\nstruct sun4i_gpadc_iio *info = iio_priv(dev_get_drvdata(dev));\r\nregmap_write(info->regmap, SUN4I_GPADC_CTRL1, 0);\r\nregmap_write(info->regmap, SUN4I_GPADC_TPR, 0);\r\nreturn 0;\r\n}\r\nstatic int sun4i_gpadc_runtime_resume(struct device *dev)\r\n{\r\nstruct sun4i_gpadc_iio *info = iio_priv(dev_get_drvdata(dev));\r\nregmap_write(info->regmap, SUN4I_GPADC_CTRL0,\r\nSUN4I_GPADC_CTRL0_ADC_CLK_DIVIDER(2) |\r\nSUN4I_GPADC_CTRL0_FS_DIV(7) |\r\nSUN4I_GPADC_CTRL0_T_ACQ(63));\r\nregmap_write(info->regmap, SUN4I_GPADC_CTRL1, info->data->tp_mode_en);\r\nregmap_write(info->regmap, SUN4I_GPADC_CTRL3,\r\nSUN4I_GPADC_CTRL3_FILTER_EN |\r\nSUN4I_GPADC_CTRL3_FILTER_TYPE(1));\r\nregmap_write(info->regmap, SUN4I_GPADC_TPR,\r\nSUN4I_GPADC_TPR_TEMP_ENABLE |\r\nSUN4I_GPADC_TPR_TEMP_PERIOD(800));\r\nreturn 0;\r\n}\r\nstatic int sun4i_gpadc_get_temp(void *data, int *temp)\r\n{\r\nstruct sun4i_gpadc_iio *info = data;\r\nint val, scale, offset;\r\nif (sun4i_gpadc_temp_read(info->indio_dev, &val))\r\nreturn -ETIMEDOUT;\r\nsun4i_gpadc_temp_scale(info->indio_dev, &scale);\r\nsun4i_gpadc_temp_offset(info->indio_dev, &offset);\r\n*temp = (val + offset) * scale;\r\nreturn 0;\r\n}\r\nstatic int sun4i_irq_init(struct platform_device *pdev, const char *name,\r\nirq_handler_t handler, const char *devname,\r\nunsigned int *irq, atomic_t *atomic)\r\n{\r\nint ret;\r\nstruct sun4i_gpadc_dev *mfd_dev = dev_get_drvdata(pdev->dev.parent);\r\nstruct sun4i_gpadc_iio *info = iio_priv(dev_get_drvdata(&pdev->dev));\r\natomic_set(atomic, 1);\r\nret = platform_get_irq_byname(pdev, name);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "no %s interrupt registered\n", name);\r\nreturn ret;\r\n}\r\nret = regmap_irq_get_virq(mfd_dev->regmap_irqc, ret);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get virq for irq %s\n", name);\r\nreturn ret;\r\n}\r\n*irq = ret;\r\nret = devm_request_any_context_irq(&pdev->dev, *irq, handler, 0,\r\ndevname, info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "could not request %s interrupt: %d\n",\r\nname, ret);\r\nreturn ret;\r\n}\r\ndisable_irq(*irq);\r\natomic_set(atomic, 0);\r\nreturn 0;\r\n}\r\nstatic int sun4i_gpadc_probe_dt(struct platform_device *pdev,\r\nstruct iio_dev *indio_dev)\r\n{\r\nstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\r\nconst struct of_device_id *of_dev;\r\nstruct resource *mem;\r\nvoid __iomem *base;\r\nint ret;\r\nof_dev = of_match_device(sun4i_gpadc_of_id, &pdev->dev);\r\nif (!of_dev)\r\nreturn -ENODEV;\r\ninfo->no_irq = true;\r\ninfo->data = (struct gpadc_data *)of_dev->data;\r\nindio_dev->num_channels = ARRAY_SIZE(sun8i_a33_gpadc_channels);\r\nindio_dev->channels = sun8i_a33_gpadc_channels;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ninfo->regmap = devm_regmap_init_mmio(&pdev->dev, base,\r\n&sun4i_gpadc_regmap_config);\r\nif (IS_ERR(info->regmap)) {\r\nret = PTR_ERR(info->regmap);\r\ndev_err(&pdev->dev, "failed to init regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (!IS_ENABLED(CONFIG_THERMAL_OF))\r\nreturn 0;\r\ninfo->sensor_device = &pdev->dev;\r\ninfo->tzd = thermal_zone_of_sensor_register(info->sensor_device, 0,\r\ninfo, &sun4i_ts_tz_ops);\r\nif (IS_ERR(info->tzd))\r\ndev_err(&pdev->dev, "could not register thermal sensor: %ld\n",\r\nPTR_ERR(info->tzd));\r\nreturn PTR_ERR_OR_ZERO(info->tzd);\r\n}\r\nstatic int sun4i_gpadc_probe_mfd(struct platform_device *pdev,\r\nstruct iio_dev *indio_dev)\r\n{\r\nstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\r\nstruct sun4i_gpadc_dev *sun4i_gpadc_dev =\r\ndev_get_drvdata(pdev->dev.parent);\r\nint ret;\r\ninfo->no_irq = false;\r\ninfo->regmap = sun4i_gpadc_dev->regmap;\r\nindio_dev->num_channels = ARRAY_SIZE(sun4i_gpadc_channels);\r\nindio_dev->channels = sun4i_gpadc_channels;\r\ninfo->data = (struct gpadc_data *)platform_get_device_id(pdev)->driver_data;\r\nif (IS_ENABLED(CONFIG_THERMAL_OF)) {\r\ninfo->sensor_device = pdev->dev.parent;\r\ninfo->tzd = thermal_zone_of_sensor_register(info->sensor_device,\r\n0, info,\r\n&sun4i_ts_tz_ops);\r\nif (IS_ERR(info->tzd)) {\r\ndev_err(&pdev->dev,\r\n"could not register thermal sensor: %ld\n",\r\nPTR_ERR(info->tzd));\r\nreturn PTR_ERR(info->tzd);\r\n}\r\n} else {\r\nindio_dev->num_channels =\r\nARRAY_SIZE(sun4i_gpadc_channels_no_temp);\r\nindio_dev->channels = sun4i_gpadc_channels_no_temp;\r\n}\r\nif (IS_ENABLED(CONFIG_THERMAL_OF)) {\r\nret = sun4i_irq_init(pdev, "TEMP_DATA_PENDING",\r\nsun4i_gpadc_temp_data_irq_handler,\r\n"temp_data", &info->temp_data_irq,\r\n&info->ignore_temp_data_irq);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = sun4i_irq_init(pdev, "FIFO_DATA_PENDING",\r\nsun4i_gpadc_fifo_data_irq_handler, "fifo_data",\r\n&info->fifo_data_irq, &info->ignore_fifo_data_irq);\r\nif (ret < 0)\r\nreturn ret;\r\nif (IS_ENABLED(CONFIG_THERMAL_OF)) {\r\nret = iio_map_array_register(indio_dev, sun4i_gpadc_hwmon_maps);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"failed to register iio map array\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sun4i_gpadc_probe(struct platform_device *pdev)\r\n{\r\nstruct sun4i_gpadc_iio *info;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*info));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ninfo = iio_priv(indio_dev);\r\nplatform_set_drvdata(pdev, indio_dev);\r\nmutex_init(&info->mutex);\r\ninfo->indio_dev = indio_dev;\r\ninit_completion(&info->completion);\r\nindio_dev->name = dev_name(&pdev->dev);\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->dev.of_node = pdev->dev.of_node;\r\nindio_dev->info = &sun4i_gpadc_iio_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nif (pdev->dev.of_node)\r\nret = sun4i_gpadc_probe_dt(pdev, indio_dev);\r\nelse\r\nret = sun4i_gpadc_probe_mfd(pdev, indio_dev);\r\nif (ret)\r\nreturn ret;\r\npm_runtime_set_autosuspend_delay(&pdev->dev,\r\nSUN4I_GPADC_AUTOSUSPEND_DELAY);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_set_suspended(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nret = devm_iio_device_register(&pdev->dev, indio_dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "could not register the device\n");\r\ngoto err_map;\r\n}\r\nreturn 0;\r\nerr_map:\r\nif (!info->no_irq && IS_ENABLED(CONFIG_THERMAL_OF))\r\niio_map_array_unregister(indio_dev);\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int sun4i_gpadc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct sun4i_gpadc_iio *info = iio_priv(indio_dev);\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nif (!IS_ENABLED(CONFIG_THERMAL_OF))\r\nreturn 0;\r\nthermal_zone_of_sensor_unregister(info->sensor_device, info->tzd);\r\nif (!info->no_irq)\r\niio_map_array_unregister(indio_dev);\r\nreturn 0;\r\n}
