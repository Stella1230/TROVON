int octeon_mbox_read(struct octeon_mbox *mbox)\r\n{\r\nunion octeon_mbox_message msg;\r\nint ret = 0;\r\nspin_lock(&mbox->lock);\r\nmsg.u64 = readq(mbox->mbox_read_reg);\r\nif ((msg.u64 == OCTEON_PFVFACK) || (msg.u64 == OCTEON_PFVFSIG)) {\r\nspin_unlock(&mbox->lock);\r\nreturn 0;\r\n}\r\nif (mbox->state & OCTEON_MBOX_STATE_REQUEST_RECEIVING) {\r\nmbox->mbox_req.data[mbox->mbox_req.recv_len - 1] = msg.u64;\r\nmbox->mbox_req.recv_len++;\r\n} else {\r\nif (mbox->state & OCTEON_MBOX_STATE_RESPONSE_RECEIVING) {\r\nmbox->mbox_resp.data[mbox->mbox_resp.recv_len - 1] =\r\nmsg.u64;\r\nmbox->mbox_resp.recv_len++;\r\n} else {\r\nif ((mbox->state & OCTEON_MBOX_STATE_IDLE) &&\r\n(msg.s.type == OCTEON_MBOX_REQUEST)) {\r\nmbox->state &= ~OCTEON_MBOX_STATE_IDLE;\r\nmbox->state |=\r\nOCTEON_MBOX_STATE_REQUEST_RECEIVING;\r\nmbox->mbox_req.msg.u64 = msg.u64;\r\nmbox->mbox_req.q_no = mbox->q_no;\r\nmbox->mbox_req.recv_len = 1;\r\n} else {\r\nif ((mbox->state &\r\nOCTEON_MBOX_STATE_RESPONSE_PENDING) &&\r\n(msg.s.type == OCTEON_MBOX_RESPONSE)) {\r\nmbox->state &=\r\n~OCTEON_MBOX_STATE_RESPONSE_PENDING;\r\nmbox->state |=\r\nOCTEON_MBOX_STATE_RESPONSE_RECEIVING\r\n;\r\nmbox->mbox_resp.msg.u64 = msg.u64;\r\nmbox->mbox_resp.q_no = mbox->q_no;\r\nmbox->mbox_resp.recv_len = 1;\r\n} else {\r\nwriteq(OCTEON_PFVFERR,\r\nmbox->mbox_read_reg);\r\nmbox->state |= OCTEON_MBOX_STATE_ERROR;\r\nspin_unlock(&mbox->lock);\r\nreturn 1;\r\n}\r\n}\r\n}\r\n}\r\nif (mbox->state & OCTEON_MBOX_STATE_REQUEST_RECEIVING) {\r\nif (mbox->mbox_req.recv_len < msg.s.len) {\r\nret = 0;\r\n} else {\r\nmbox->state &= ~OCTEON_MBOX_STATE_REQUEST_RECEIVING;\r\nmbox->state |= OCTEON_MBOX_STATE_REQUEST_RECEIVED;\r\nret = 1;\r\n}\r\n} else {\r\nif (mbox->state & OCTEON_MBOX_STATE_RESPONSE_RECEIVING) {\r\nif (mbox->mbox_resp.recv_len < msg.s.len) {\r\nret = 0;\r\n} else {\r\nmbox->state &=\r\n~OCTEON_MBOX_STATE_RESPONSE_RECEIVING;\r\nmbox->state |=\r\nOCTEON_MBOX_STATE_RESPONSE_RECEIVED;\r\nret = 1;\r\n}\r\n} else {\r\nWARN_ON(1);\r\n}\r\n}\r\nwriteq(OCTEON_PFVFACK, mbox->mbox_read_reg);\r\nspin_unlock(&mbox->lock);\r\nreturn ret;\r\n}\r\nint octeon_mbox_write(struct octeon_device *oct,\r\nstruct octeon_mbox_cmd *mbox_cmd)\r\n{\r\nstruct octeon_mbox *mbox = oct->mbox[mbox_cmd->q_no];\r\nu32 count, i, ret = OCTEON_MBOX_STATUS_SUCCESS;\r\nlong timeout = LIO_MBOX_WRITE_WAIT_TIME;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mbox->lock, flags);\r\nif ((mbox_cmd->msg.s.type == OCTEON_MBOX_RESPONSE) &&\r\n!(mbox->state & OCTEON_MBOX_STATE_REQUEST_RECEIVED)) {\r\nspin_unlock_irqrestore(&mbox->lock, flags);\r\nreturn OCTEON_MBOX_STATUS_FAILED;\r\n}\r\nif ((mbox_cmd->msg.s.type == OCTEON_MBOX_REQUEST) &&\r\n!(mbox->state & OCTEON_MBOX_STATE_IDLE)) {\r\nspin_unlock_irqrestore(&mbox->lock, flags);\r\nreturn OCTEON_MBOX_STATUS_BUSY;\r\n}\r\nif (mbox_cmd->msg.s.type == OCTEON_MBOX_REQUEST) {\r\nmemcpy(&mbox->mbox_resp, mbox_cmd,\r\nsizeof(struct octeon_mbox_cmd));\r\nmbox->state = OCTEON_MBOX_STATE_RESPONSE_PENDING;\r\n}\r\nspin_unlock_irqrestore(&mbox->lock, flags);\r\ncount = 0;\r\nwhile (readq(mbox->mbox_write_reg) != OCTEON_PFVFSIG) {\r\nschedule_timeout_uninterruptible(timeout);\r\nif (count++ == LIO_MBOX_WRITE_WAIT_CNT) {\r\nret = OCTEON_MBOX_STATUS_FAILED;\r\nbreak;\r\n}\r\n}\r\nif (ret == OCTEON_MBOX_STATUS_SUCCESS) {\r\nwriteq(mbox_cmd->msg.u64, mbox->mbox_write_reg);\r\nfor (i = 0; i < (u32)(mbox_cmd->msg.s.len - 1); i++) {\r\ncount = 0;\r\nwhile (readq(mbox->mbox_write_reg) !=\r\nOCTEON_PFVFACK) {\r\nschedule_timeout_uninterruptible(timeout);\r\nif (count++ == LIO_MBOX_WRITE_WAIT_CNT) {\r\nret = OCTEON_MBOX_STATUS_FAILED;\r\nbreak;\r\n}\r\n}\r\nif (ret == OCTEON_MBOX_STATUS_SUCCESS)\r\nwriteq(mbox_cmd->data[i], mbox->mbox_write_reg);\r\nelse\r\nbreak;\r\n}\r\n}\r\nspin_lock_irqsave(&mbox->lock, flags);\r\nif (mbox_cmd->msg.s.type == OCTEON_MBOX_RESPONSE) {\r\nmbox->state = OCTEON_MBOX_STATE_IDLE;\r\nwriteq(OCTEON_PFVFSIG, mbox->mbox_read_reg);\r\n} else {\r\nif ((!mbox_cmd->msg.s.resp_needed) ||\r\n(ret == OCTEON_MBOX_STATUS_FAILED)) {\r\nmbox->state &= ~OCTEON_MBOX_STATE_RESPONSE_PENDING;\r\nif (!(mbox->state &\r\n(OCTEON_MBOX_STATE_REQUEST_RECEIVING |\r\nOCTEON_MBOX_STATE_REQUEST_RECEIVED)))\r\nmbox->state = OCTEON_MBOX_STATE_IDLE;\r\n}\r\n}\r\nspin_unlock_irqrestore(&mbox->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int octeon_mbox_process_cmd(struct octeon_mbox *mbox,\r\nstruct octeon_mbox_cmd *mbox_cmd)\r\n{\r\nstruct octeon_device *oct = mbox->oct_dev;\r\nswitch (mbox_cmd->msg.s.cmd) {\r\ncase OCTEON_VF_ACTIVE:\r\ndev_dbg(&oct->pci_dev->dev, "got vfactive sending data back\n");\r\nmbox_cmd->msg.s.type = OCTEON_MBOX_RESPONSE;\r\nmbox_cmd->msg.s.resp_needed = 1;\r\nmbox_cmd->msg.s.len = 2;\r\nmbox_cmd->data[0] = 0;\r\n((struct lio_version *)&mbox_cmd->data[0])->major =\r\nLIQUIDIO_BASE_MAJOR_VERSION;\r\n((struct lio_version *)&mbox_cmd->data[0])->minor =\r\nLIQUIDIO_BASE_MINOR_VERSION;\r\n((struct lio_version *)&mbox_cmd->data[0])->micro =\r\nLIQUIDIO_BASE_MICRO_VERSION;\r\nmemcpy(mbox_cmd->msg.s.params, (uint8_t *)&oct->pfvf_hsword, 6);\r\nocteon_mbox_write(oct, mbox_cmd);\r\nbreak;\r\ncase OCTEON_VF_FLR_REQUEST:\r\ndev_info(&oct->pci_dev->dev,\r\n"got a request for FLR from VF that owns DPI ring %u\n",\r\nmbox->q_no);\r\npcie_capability_set_word(\r\noct->sriov_info.dpiring_to_vfpcidev_lut[mbox->q_no],\r\nPCI_EXP_DEVCTL, PCI_EXP_DEVCTL_BCR_FLR);\r\nbreak;\r\ncase OCTEON_PF_CHANGED_VF_MACADDR:\r\nif (OCTEON_CN23XX_VF(oct))\r\nocteon_pf_changed_vf_macaddr(oct,\r\nmbox_cmd->msg.s.params);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint octeon_mbox_process_message(struct octeon_mbox *mbox)\r\n{\r\nstruct octeon_mbox_cmd mbox_cmd;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mbox->lock, flags);\r\nif (mbox->state & OCTEON_MBOX_STATE_ERROR) {\r\nif (mbox->state & (OCTEON_MBOX_STATE_RESPONSE_PENDING |\r\nOCTEON_MBOX_STATE_RESPONSE_RECEIVING)) {\r\nmemcpy(&mbox_cmd, &mbox->mbox_resp,\r\nsizeof(struct octeon_mbox_cmd));\r\nmbox->state = OCTEON_MBOX_STATE_IDLE;\r\nwriteq(OCTEON_PFVFSIG, mbox->mbox_read_reg);\r\nspin_unlock_irqrestore(&mbox->lock, flags);\r\nmbox_cmd.recv_status = 1;\r\nif (mbox_cmd.fn)\r\nmbox_cmd.fn(mbox->oct_dev, &mbox_cmd,\r\nmbox_cmd.fn_arg);\r\nreturn 0;\r\n}\r\nmbox->state = OCTEON_MBOX_STATE_IDLE;\r\nwriteq(OCTEON_PFVFSIG, mbox->mbox_read_reg);\r\nspin_unlock_irqrestore(&mbox->lock, flags);\r\nreturn 0;\r\n}\r\nif (mbox->state & OCTEON_MBOX_STATE_RESPONSE_RECEIVED) {\r\nmemcpy(&mbox_cmd, &mbox->mbox_resp,\r\nsizeof(struct octeon_mbox_cmd));\r\nmbox->state = OCTEON_MBOX_STATE_IDLE;\r\nwriteq(OCTEON_PFVFSIG, mbox->mbox_read_reg);\r\nspin_unlock_irqrestore(&mbox->lock, flags);\r\nmbox_cmd.recv_status = 0;\r\nif (mbox_cmd.fn)\r\nmbox_cmd.fn(mbox->oct_dev, &mbox_cmd, mbox_cmd.fn_arg);\r\nreturn 0;\r\n}\r\nif (mbox->state & OCTEON_MBOX_STATE_REQUEST_RECEIVED) {\r\nmemcpy(&mbox_cmd, &mbox->mbox_req,\r\nsizeof(struct octeon_mbox_cmd));\r\nif (!mbox_cmd.msg.s.resp_needed) {\r\nmbox->state &= ~OCTEON_MBOX_STATE_REQUEST_RECEIVED;\r\nif (!(mbox->state &\r\nOCTEON_MBOX_STATE_RESPONSE_PENDING))\r\nmbox->state = OCTEON_MBOX_STATE_IDLE;\r\nwriteq(OCTEON_PFVFSIG, mbox->mbox_read_reg);\r\n}\r\nspin_unlock_irqrestore(&mbox->lock, flags);\r\nocteon_mbox_process_cmd(mbox, &mbox_cmd);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&mbox->lock, flags);\r\nWARN_ON(1);\r\nreturn 0;\r\n}
