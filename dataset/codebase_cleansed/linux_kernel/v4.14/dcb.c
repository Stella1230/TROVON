u16\r\ndcb_table(struct nvkm_bios *bios, u8 *ver, u8 *hdr, u8 *cnt, u8 *len)\r\n{\r\nstruct nvkm_subdev *subdev = &bios->subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nu16 dcb = 0x0000;\r\nif (device->card_type > NV_04)\r\ndcb = nvbios_rd16(bios, 0x36);\r\nif (!dcb) {\r\nnvkm_warn(subdev, "DCB table not found\n");\r\nreturn dcb;\r\n}\r\n*ver = nvbios_rd08(bios, dcb);\r\nif (*ver >= 0x42) {\r\nnvkm_warn(subdev, "DCB version 0x%02x unknown\n", *ver);\r\nreturn 0x0000;\r\n} else\r\nif (*ver >= 0x30) {\r\nif (nvbios_rd32(bios, dcb + 6) == 0x4edcbdcb) {\r\n*hdr = nvbios_rd08(bios, dcb + 1);\r\n*cnt = nvbios_rd08(bios, dcb + 2);\r\n*len = nvbios_rd08(bios, dcb + 3);\r\nreturn dcb;\r\n}\r\n} else\r\nif (*ver >= 0x20) {\r\nif (nvbios_rd32(bios, dcb + 4) == 0x4edcbdcb) {\r\nu16 i2c = nvbios_rd16(bios, dcb + 2);\r\n*hdr = 8;\r\n*cnt = (i2c - dcb) / 8;\r\n*len = 8;\r\nreturn dcb;\r\n}\r\n} else\r\nif (*ver >= 0x15) {\r\nif (!nvbios_memcmp(bios, dcb - 7, "DEV_REC", 7)) {\r\nu16 i2c = nvbios_rd16(bios, dcb + 2);\r\n*hdr = 4;\r\n*cnt = (i2c - dcb) / 10;\r\n*len = 10;\r\nreturn dcb;\r\n}\r\n} else {\r\nnvkm_debug(subdev, "DCB contains no useful data\n");\r\nreturn 0x0000;\r\n}\r\nnvkm_warn(subdev, "DCB header validation failed\n");\r\nreturn 0x0000;\r\n}\r\nu16\r\ndcb_outp(struct nvkm_bios *bios, u8 idx, u8 *ver, u8 *len)\r\n{\r\nu8 hdr, cnt;\r\nu16 dcb = dcb_table(bios, ver, &hdr, &cnt, len);\r\nif (dcb && idx < cnt)\r\nreturn dcb + hdr + (idx * *len);\r\nreturn 0x0000;\r\n}\r\nstatic inline u16\r\ndcb_outp_hasht(struct dcb_output *outp)\r\n{\r\nreturn (outp->extdev << 8) | (outp->location << 4) | outp->type;\r\n}\r\nstatic inline u16\r\ndcb_outp_hashm(struct dcb_output *outp)\r\n{\r\nreturn (outp->heads << 8) | (outp->link << 6) | outp->or;\r\n}\r\nu16\r\ndcb_outp_parse(struct nvkm_bios *bios, u8 idx, u8 *ver, u8 *len,\r\nstruct dcb_output *outp)\r\n{\r\nu16 dcb = dcb_outp(bios, idx, ver, len);\r\nmemset(outp, 0x00, sizeof(*outp));\r\nif (dcb) {\r\nif (*ver >= 0x20) {\r\nu32 conn = nvbios_rd32(bios, dcb + 0x00);\r\noutp->or = (conn & 0x0f000000) >> 24;\r\noutp->location = (conn & 0x00300000) >> 20;\r\noutp->bus = (conn & 0x000f0000) >> 16;\r\noutp->connector = (conn & 0x0000f000) >> 12;\r\noutp->heads = (conn & 0x00000f00) >> 8;\r\noutp->i2c_index = (conn & 0x000000f0) >> 4;\r\noutp->type = (conn & 0x0000000f);\r\noutp->link = 0;\r\n} else {\r\ndcb = 0x0000;\r\n}\r\nif (*ver >= 0x40) {\r\nu32 conf = nvbios_rd32(bios, dcb + 0x04);\r\nswitch (outp->type) {\r\ncase DCB_OUTPUT_DP:\r\nswitch (conf & 0x00e00000) {\r\ncase 0x00000000:\r\noutp->dpconf.link_bw = 0x06;\r\nbreak;\r\ncase 0x00200000:\r\noutp->dpconf.link_bw = 0x0a;\r\nbreak;\r\ncase 0x00400000:\r\noutp->dpconf.link_bw = 0x14;\r\nbreak;\r\ncase 0x00600000:\r\ndefault:\r\noutp->dpconf.link_bw = 0x1e;\r\nbreak;\r\n}\r\nswitch ((conf & 0x0f000000) >> 24) {\r\ncase 0xf:\r\ncase 0x4:\r\noutp->dpconf.link_nr = 4;\r\nbreak;\r\ncase 0x3:\r\ncase 0x2:\r\noutp->dpconf.link_nr = 2;\r\nbreak;\r\ncase 0x1:\r\ndefault:\r\noutp->dpconf.link_nr = 1;\r\nbreak;\r\n}\r\ncase DCB_OUTPUT_TMDS:\r\ncase DCB_OUTPUT_LVDS:\r\noutp->link = (conf & 0x00000030) >> 4;\r\noutp->sorconf.link = outp->link;\r\noutp->extdev = 0x00;\r\nif (outp->location != 0)\r\noutp->extdev = (conf & 0x0000ff00) >> 8;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\noutp->hasht = dcb_outp_hasht(outp);\r\noutp->hashm = dcb_outp_hashm(outp);\r\n}\r\nreturn dcb;\r\n}\r\nu16\r\ndcb_outp_match(struct nvkm_bios *bios, u16 type, u16 mask,\r\nu8 *ver, u8 *len, struct dcb_output *outp)\r\n{\r\nu16 dcb, idx = 0;\r\nwhile ((dcb = dcb_outp_parse(bios, idx++, ver, len, outp))) {\r\nif ((dcb_outp_hasht(outp) & 0x00ff) == (type & 0x00ff)) {\r\nif ((dcb_outp_hashm(outp) & mask) == mask)\r\nbreak;\r\n}\r\n}\r\nreturn dcb;\r\n}\r\nint\r\ndcb_outp_foreach(struct nvkm_bios *bios, void *data,\r\nint (*exec)(struct nvkm_bios *, void *, int, u16))\r\n{\r\nint ret, idx = -1;\r\nu8 ver, len;\r\nu16 outp;\r\nwhile ((outp = dcb_outp(bios, ++idx, &ver, &len))) {\r\nif (nvbios_rd32(bios, outp) == 0x00000000)\r\nbreak;\r\nif (nvbios_rd32(bios, outp) == 0xffffffff)\r\nbreak;\r\nif (nvbios_rd08(bios, outp) == DCB_OUTPUT_UNUSED)\r\ncontinue;\r\nif (nvbios_rd08(bios, outp) == DCB_OUTPUT_EOL)\r\nbreak;\r\nret = exec(bios, data, idx, outp);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
