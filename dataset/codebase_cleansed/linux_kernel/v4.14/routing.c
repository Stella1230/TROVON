static void _batadv_update_route(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_hard_iface *recv_if,\r\nstruct batadv_neigh_node *neigh_node)\r\n{\r\nstruct batadv_orig_ifinfo *orig_ifinfo;\r\nstruct batadv_neigh_node *curr_router;\r\norig_ifinfo = batadv_orig_ifinfo_get(orig_node, recv_if);\r\nif (!orig_ifinfo)\r\nreturn;\r\nspin_lock_bh(&orig_node->neigh_list_lock);\r\ncurr_router = rcu_dereference_protected(orig_ifinfo->router, true);\r\nif (neigh_node)\r\nkref_get(&neigh_node->refcount);\r\nrcu_assign_pointer(orig_ifinfo->router, neigh_node);\r\nspin_unlock_bh(&orig_node->neigh_list_lock);\r\nbatadv_orig_ifinfo_put(orig_ifinfo);\r\nif ((curr_router) && (!neigh_node)) {\r\nbatadv_dbg(BATADV_DBG_ROUTES, bat_priv,\r\n"Deleting route towards: %pM\n", orig_node->orig);\r\nbatadv_tt_global_del_orig(bat_priv, orig_node, -1,\r\n"Deleted route towards originator");\r\n} else if ((!curr_router) && (neigh_node)) {\r\nbatadv_dbg(BATADV_DBG_ROUTES, bat_priv,\r\n"Adding route towards: %pM (via %pM)\n",\r\norig_node->orig, neigh_node->addr);\r\n} else if (neigh_node && curr_router) {\r\nbatadv_dbg(BATADV_DBG_ROUTES, bat_priv,\r\n"Changing route towards: %pM (now via %pM - was via %pM)\n",\r\norig_node->orig, neigh_node->addr,\r\ncurr_router->addr);\r\n}\r\nif (curr_router)\r\nbatadv_neigh_node_put(curr_router);\r\n}\r\nvoid batadv_update_route(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_hard_iface *recv_if,\r\nstruct batadv_neigh_node *neigh_node)\r\n{\r\nstruct batadv_neigh_node *router = NULL;\r\nif (!orig_node)\r\ngoto out;\r\nrouter = batadv_orig_router_get(orig_node, recv_if);\r\nif (router != neigh_node)\r\n_batadv_update_route(bat_priv, orig_node, recv_if, neigh_node);\r\nout:\r\nif (router)\r\nbatadv_neigh_node_put(router);\r\n}\r\nbool batadv_window_protected(struct batadv_priv *bat_priv, s32 seq_num_diff,\r\ns32 seq_old_max_diff, unsigned long *last_reset,\r\nbool *protection_started)\r\n{\r\nif (seq_num_diff <= -seq_old_max_diff ||\r\nseq_num_diff >= BATADV_EXPECTED_SEQNO_RANGE) {\r\nif (!batadv_has_timed_out(*last_reset,\r\nBATADV_RESET_PROTECTION_MS))\r\nreturn true;\r\n*last_reset = jiffies;\r\nif (protection_started)\r\n*protection_started = true;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"old packet received, start protection\n");\r\n}\r\nreturn false;\r\n}\r\nbool batadv_check_management_packet(struct sk_buff *skb,\r\nstruct batadv_hard_iface *hard_iface,\r\nint header_len)\r\n{\r\nstruct ethhdr *ethhdr;\r\nif (unlikely(!pskb_may_pull(skb, header_len)))\r\nreturn false;\r\nethhdr = eth_hdr(skb);\r\nif (!is_broadcast_ether_addr(ethhdr->h_dest))\r\nreturn false;\r\nif (!is_valid_ether_addr(ethhdr->h_source))\r\nreturn false;\r\nif (skb_cow(skb, 0) < 0)\r\nreturn false;\r\nif (skb_linearize(skb) < 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int batadv_recv_my_icmp_packet(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nstruct batadv_orig_node *orig_node = NULL;\r\nstruct batadv_icmp_header *icmph;\r\nint res, ret = NET_RX_DROP;\r\nicmph = (struct batadv_icmp_header *)skb->data;\r\nswitch (icmph->msg_type) {\r\ncase BATADV_ECHO_REPLY:\r\ncase BATADV_DESTINATION_UNREACHABLE:\r\ncase BATADV_TTL_EXCEEDED:\r\nif (skb_linearize(skb) < 0)\r\nbreak;\r\nbatadv_socket_receive_packet(icmph, skb->len);\r\nbreak;\r\ncase BATADV_ECHO_REQUEST:\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\norig_node = batadv_orig_hash_find(bat_priv, icmph->orig);\r\nif (!orig_node)\r\ngoto out;\r\nif (skb_cow(skb, ETH_HLEN) < 0)\r\ngoto out;\r\nicmph = (struct batadv_icmp_header *)skb->data;\r\nether_addr_copy(icmph->dst, icmph->orig);\r\nether_addr_copy(icmph->orig, primary_if->net_dev->dev_addr);\r\nicmph->msg_type = BATADV_ECHO_REPLY;\r\nicmph->ttl = BATADV_TTL;\r\nres = batadv_send_skb_to_orig(skb, orig_node, NULL);\r\nif (res == NET_XMIT_SUCCESS)\r\nret = NET_RX_SUCCESS;\r\nskb = NULL;\r\nbreak;\r\ncase BATADV_TP:\r\nif (!pskb_may_pull(skb, sizeof(struct batadv_icmp_tp_packet)))\r\ngoto out;\r\nbatadv_tp_meter_recv(bat_priv, skb);\r\nret = NET_RX_SUCCESS;\r\nskb = NULL;\r\ngoto out;\r\ndefault:\r\ngoto out;\r\n}\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\nif (orig_node)\r\nbatadv_orig_node_put(orig_node);\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int batadv_recv_icmp_ttl_exceeded(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nstruct batadv_orig_node *orig_node = NULL;\r\nstruct batadv_icmp_packet *icmp_packet;\r\nint res, ret = NET_RX_DROP;\r\nicmp_packet = (struct batadv_icmp_packet *)skb->data;\r\nif (icmp_packet->msg_type != BATADV_ECHO_REQUEST) {\r\npr_debug("Warning - can't forward icmp packet from %pM to %pM: ttl exceeded\n",\r\nicmp_packet->orig, icmp_packet->dst);\r\ngoto out;\r\n}\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\norig_node = batadv_orig_hash_find(bat_priv, icmp_packet->orig);\r\nif (!orig_node)\r\ngoto out;\r\nif (skb_cow(skb, ETH_HLEN) < 0)\r\ngoto out;\r\nicmp_packet = (struct batadv_icmp_packet *)skb->data;\r\nether_addr_copy(icmp_packet->dst, icmp_packet->orig);\r\nether_addr_copy(icmp_packet->orig, primary_if->net_dev->dev_addr);\r\nicmp_packet->msg_type = BATADV_TTL_EXCEEDED;\r\nicmp_packet->ttl = BATADV_TTL;\r\nres = batadv_send_skb_to_orig(skb, orig_node, NULL);\r\nif (res == NET_RX_SUCCESS)\r\nret = NET_XMIT_SUCCESS;\r\nskb = NULL;\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\nif (orig_node)\r\nbatadv_orig_node_put(orig_node);\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nint batadv_recv_icmp_packet(struct sk_buff *skb,\r\nstruct batadv_hard_iface *recv_if)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\r\nstruct batadv_icmp_header *icmph;\r\nstruct batadv_icmp_packet_rr *icmp_packet_rr;\r\nstruct ethhdr *ethhdr;\r\nstruct batadv_orig_node *orig_node = NULL;\r\nint hdr_size = sizeof(struct batadv_icmp_header);\r\nint res, ret = NET_RX_DROP;\r\nif (unlikely(!pskb_may_pull(skb, hdr_size)))\r\ngoto free_skb;\r\nethhdr = eth_hdr(skb);\r\nif (!is_valid_ether_addr(ethhdr->h_dest))\r\ngoto free_skb;\r\nif (is_multicast_ether_addr(ethhdr->h_source))\r\ngoto free_skb;\r\nif (!batadv_is_my_mac(bat_priv, ethhdr->h_dest))\r\ngoto free_skb;\r\nicmph = (struct batadv_icmp_header *)skb->data;\r\nif ((icmph->msg_type == BATADV_ECHO_REPLY ||\r\nicmph->msg_type == BATADV_ECHO_REQUEST) &&\r\n(skb->len >= sizeof(struct batadv_icmp_packet_rr))) {\r\nif (skb_linearize(skb) < 0)\r\ngoto free_skb;\r\nif (skb_cow(skb, ETH_HLEN) < 0)\r\ngoto free_skb;\r\nethhdr = eth_hdr(skb);\r\nicmph = (struct batadv_icmp_header *)skb->data;\r\nicmp_packet_rr = (struct batadv_icmp_packet_rr *)icmph;\r\nif (icmp_packet_rr->rr_cur >= BATADV_RR_LEN)\r\ngoto free_skb;\r\nether_addr_copy(icmp_packet_rr->rr[icmp_packet_rr->rr_cur],\r\nethhdr->h_dest);\r\nicmp_packet_rr->rr_cur++;\r\n}\r\nif (batadv_is_my_mac(bat_priv, icmph->dst))\r\nreturn batadv_recv_my_icmp_packet(bat_priv, skb);\r\nif (icmph->ttl < 2)\r\nreturn batadv_recv_icmp_ttl_exceeded(bat_priv, skb);\r\norig_node = batadv_orig_hash_find(bat_priv, icmph->dst);\r\nif (!orig_node)\r\ngoto free_skb;\r\nif (skb_cow(skb, ETH_HLEN) < 0)\r\ngoto put_orig_node;\r\nicmph = (struct batadv_icmp_header *)skb->data;\r\nicmph->ttl--;\r\nres = batadv_send_skb_to_orig(skb, orig_node, recv_if);\r\nif (res == NET_XMIT_SUCCESS)\r\nret = NET_RX_SUCCESS;\r\nskb = NULL;\r\nput_orig_node:\r\nif (orig_node)\r\nbatadv_orig_node_put(orig_node);\r\nfree_skb:\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int batadv_check_unicast_packet(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb, int hdr_size)\r\n{\r\nstruct ethhdr *ethhdr;\r\nif (unlikely(!pskb_may_pull(skb, hdr_size)))\r\nreturn -ENODATA;\r\nethhdr = eth_hdr(skb);\r\nif (!is_valid_ether_addr(ethhdr->h_dest))\r\nreturn -EBADR;\r\nif (is_multicast_ether_addr(ethhdr->h_source))\r\nreturn -EBADR;\r\nif (!batadv_is_my_mac(bat_priv, ethhdr->h_dest))\r\nreturn -EREMOTE;\r\nreturn 0;\r\n}\r\nstatic struct batadv_orig_ifinfo *\r\nbatadv_last_bonding_get(struct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_orig_ifinfo *last_bonding_candidate;\r\nspin_lock_bh(&orig_node->neigh_list_lock);\r\nlast_bonding_candidate = orig_node->last_bonding_candidate;\r\nif (last_bonding_candidate)\r\nkref_get(&last_bonding_candidate->refcount);\r\nspin_unlock_bh(&orig_node->neigh_list_lock);\r\nreturn last_bonding_candidate;\r\n}\r\nstatic void\r\nbatadv_last_bonding_replace(struct batadv_orig_node *orig_node,\r\nstruct batadv_orig_ifinfo *new_candidate)\r\n{\r\nstruct batadv_orig_ifinfo *old_candidate;\r\nspin_lock_bh(&orig_node->neigh_list_lock);\r\nold_candidate = orig_node->last_bonding_candidate;\r\nif (new_candidate)\r\nkref_get(&new_candidate->refcount);\r\norig_node->last_bonding_candidate = new_candidate;\r\nspin_unlock_bh(&orig_node->neigh_list_lock);\r\nif (old_candidate)\r\nbatadv_orig_ifinfo_put(old_candidate);\r\n}\r\nstruct batadv_neigh_node *\r\nbatadv_find_router(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_hard_iface *recv_if)\r\n{\r\nstruct batadv_algo_ops *bao = bat_priv->algo_ops;\r\nstruct batadv_neigh_node *first_candidate_router = NULL;\r\nstruct batadv_neigh_node *next_candidate_router = NULL;\r\nstruct batadv_neigh_node *router, *cand_router = NULL;\r\nstruct batadv_neigh_node *last_cand_router = NULL;\r\nstruct batadv_orig_ifinfo *cand, *first_candidate = NULL;\r\nstruct batadv_orig_ifinfo *next_candidate = NULL;\r\nstruct batadv_orig_ifinfo *last_candidate;\r\nbool last_candidate_found = false;\r\nif (!orig_node)\r\nreturn NULL;\r\nrouter = batadv_orig_router_get(orig_node, recv_if);\r\nif (!router)\r\nreturn router;\r\nif (!(recv_if == BATADV_IF_DEFAULT && atomic_read(&bat_priv->bonding)))\r\nreturn router;\r\nrcu_read_lock();\r\nlast_candidate = batadv_last_bonding_get(orig_node);\r\nif (last_candidate)\r\nlast_cand_router = rcu_dereference(last_candidate->router);\r\nhlist_for_each_entry_rcu(cand, &orig_node->ifinfo_list, list) {\r\nif (!kref_get_unless_zero(&cand->refcount))\r\ncontinue;\r\ncand_router = rcu_dereference(cand->router);\r\nif (!cand_router)\r\ngoto next;\r\nif (!kref_get_unless_zero(&cand_router->refcount)) {\r\ncand_router = NULL;\r\ngoto next;\r\n}\r\nif (!bao->neigh.is_similar_or_better(cand_router,\r\ncand->if_outgoing, router,\r\nrecv_if))\r\ngoto next;\r\nif (last_cand_router == cand_router)\r\ngoto next;\r\nif (!first_candidate) {\r\nkref_get(&cand_router->refcount);\r\nkref_get(&cand->refcount);\r\nfirst_candidate = cand;\r\nfirst_candidate_router = cand_router;\r\n}\r\nif (!last_candidate || last_candidate_found) {\r\nnext_candidate = cand;\r\nnext_candidate_router = cand_router;\r\nbreak;\r\n}\r\nif (last_candidate == cand)\r\nlast_candidate_found = true;\r\nnext:\r\nif (cand_router) {\r\nbatadv_neigh_node_put(cand_router);\r\ncand_router = NULL;\r\n}\r\nbatadv_orig_ifinfo_put(cand);\r\n}\r\nrcu_read_unlock();\r\nif (next_candidate) {\r\nbatadv_neigh_node_put(router);\r\nkref_get(&next_candidate_router->refcount);\r\nrouter = next_candidate_router;\r\nbatadv_last_bonding_replace(orig_node, next_candidate);\r\n} else if (first_candidate) {\r\nbatadv_neigh_node_put(router);\r\nkref_get(&first_candidate_router->refcount);\r\nrouter = first_candidate_router;\r\nbatadv_last_bonding_replace(orig_node, first_candidate);\r\n} else {\r\nbatadv_last_bonding_replace(orig_node, NULL);\r\n}\r\nif (first_candidate) {\r\nbatadv_neigh_node_put(first_candidate_router);\r\nbatadv_orig_ifinfo_put(first_candidate);\r\n}\r\nif (next_candidate) {\r\nbatadv_neigh_node_put(next_candidate_router);\r\nbatadv_orig_ifinfo_put(next_candidate);\r\n}\r\nif (last_candidate)\r\nbatadv_orig_ifinfo_put(last_candidate);\r\nreturn router;\r\n}\r\nstatic int batadv_route_unicast_packet(struct sk_buff *skb,\r\nstruct batadv_hard_iface *recv_if)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\r\nstruct batadv_orig_node *orig_node = NULL;\r\nstruct batadv_unicast_packet *unicast_packet;\r\nstruct ethhdr *ethhdr = eth_hdr(skb);\r\nint res, hdr_len, ret = NET_RX_DROP;\r\nunsigned int len;\r\nunicast_packet = (struct batadv_unicast_packet *)skb->data;\r\nif (unicast_packet->ttl < 2) {\r\npr_debug("Warning - can't forward unicast packet from %pM to %pM: ttl exceeded\n",\r\nethhdr->h_source, unicast_packet->dest);\r\ngoto free_skb;\r\n}\r\norig_node = batadv_orig_hash_find(bat_priv, unicast_packet->dest);\r\nif (!orig_node)\r\ngoto free_skb;\r\nif (skb_cow(skb, ETH_HLEN) < 0)\r\ngoto put_orig_node;\r\nunicast_packet = (struct batadv_unicast_packet *)skb->data;\r\nunicast_packet->ttl--;\r\nswitch (unicast_packet->packet_type) {\r\ncase BATADV_UNICAST_4ADDR:\r\nhdr_len = sizeof(struct batadv_unicast_4addr_packet);\r\nbreak;\r\ncase BATADV_UNICAST:\r\nhdr_len = sizeof(struct batadv_unicast_packet);\r\nbreak;\r\ndefault:\r\nhdr_len = -1;\r\nbreak;\r\n}\r\nif (hdr_len > 0)\r\nbatadv_skb_set_priority(skb, hdr_len);\r\nlen = skb->len;\r\nres = batadv_send_skb_to_orig(skb, orig_node, recv_if);\r\nif (res == NET_XMIT_SUCCESS) {\r\nret = NET_RX_SUCCESS;\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_FORWARD);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_FORWARD_BYTES,\r\nlen + ETH_HLEN);\r\n}\r\nskb = NULL;\r\nput_orig_node:\r\nbatadv_orig_node_put(orig_node);\r\nfree_skb:\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic bool\r\nbatadv_reroute_unicast_packet(struct batadv_priv *bat_priv,\r\nstruct batadv_unicast_packet *unicast_packet,\r\nu8 *dst_addr, unsigned short vid)\r\n{\r\nstruct batadv_orig_node *orig_node = NULL;\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nbool ret = false;\r\nu8 *orig_addr, orig_ttvn;\r\nif (batadv_is_my_client(bat_priv, dst_addr, vid)) {\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\norig_addr = primary_if->net_dev->dev_addr;\r\norig_ttvn = (u8)atomic_read(&bat_priv->tt.vn);\r\n} else {\r\norig_node = batadv_transtable_search(bat_priv, NULL, dst_addr,\r\nvid);\r\nif (!orig_node)\r\ngoto out;\r\nif (batadv_compare_eth(orig_node->orig, unicast_packet->dest))\r\ngoto out;\r\norig_addr = orig_node->orig;\r\norig_ttvn = (u8)atomic_read(&orig_node->last_ttvn);\r\n}\r\nether_addr_copy(unicast_packet->dest, orig_addr);\r\nunicast_packet->ttvn = orig_ttvn;\r\nret = true;\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\nif (orig_node)\r\nbatadv_orig_node_put(orig_node);\r\nreturn ret;\r\n}\r\nstatic bool batadv_check_unicast_ttvn(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb, int hdr_len)\r\n{\r\nstruct batadv_unicast_packet *unicast_packet;\r\nstruct batadv_hard_iface *primary_if;\r\nstruct batadv_orig_node *orig_node;\r\nu8 curr_ttvn, old_ttvn;\r\nstruct ethhdr *ethhdr;\r\nunsigned short vid;\r\nint is_old_ttvn;\r\nif (!pskb_may_pull(skb, hdr_len + ETH_HLEN))\r\nreturn false;\r\nif (skb_cow(skb, sizeof(*unicast_packet)) < 0)\r\nreturn false;\r\nunicast_packet = (struct batadv_unicast_packet *)skb->data;\r\nvid = batadv_get_vid(skb, hdr_len);\r\nethhdr = (struct ethhdr *)(skb->data + hdr_len);\r\nif (batadv_tt_local_client_is_roaming(bat_priv, ethhdr->h_dest, vid)) {\r\nif (batadv_reroute_unicast_packet(bat_priv, unicast_packet,\r\nethhdr->h_dest, vid))\r\nbatadv_dbg_ratelimited(BATADV_DBG_TT,\r\nbat_priv,\r\n"Rerouting unicast packet to %pM (dst=%pM): Local Roaming\n",\r\nunicast_packet->dest,\r\nethhdr->h_dest);\r\nreturn true;\r\n}\r\ncurr_ttvn = (u8)atomic_read(&bat_priv->tt.vn);\r\nif (!batadv_is_my_mac(bat_priv, unicast_packet->dest)) {\r\norig_node = batadv_orig_hash_find(bat_priv,\r\nunicast_packet->dest);\r\nif (!orig_node)\r\nreturn false;\r\ncurr_ttvn = (u8)atomic_read(&orig_node->last_ttvn);\r\nbatadv_orig_node_put(orig_node);\r\n}\r\nis_old_ttvn = batadv_seq_before(unicast_packet->ttvn, curr_ttvn);\r\nif (!is_old_ttvn)\r\nreturn true;\r\nold_ttvn = unicast_packet->ttvn;\r\nif (batadv_reroute_unicast_packet(bat_priv, unicast_packet,\r\nethhdr->h_dest, vid)) {\r\nbatadv_dbg_ratelimited(BATADV_DBG_TT, bat_priv,\r\n"Rerouting unicast packet to %pM (dst=%pM): TTVN mismatch old_ttvn=%u new_ttvn=%u\n",\r\nunicast_packet->dest, ethhdr->h_dest,\r\nold_ttvn, curr_ttvn);\r\nreturn true;\r\n}\r\nif (!batadv_is_my_client(bat_priv, ethhdr->h_dest, vid))\r\nreturn false;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\nreturn false;\r\nether_addr_copy(unicast_packet->dest, primary_if->net_dev->dev_addr);\r\nbatadv_hardif_put(primary_if);\r\nunicast_packet->ttvn = curr_ttvn;\r\nreturn true;\r\n}\r\nint batadv_recv_unhandled_unicast_packet(struct sk_buff *skb,\r\nstruct batadv_hard_iface *recv_if)\r\n{\r\nstruct batadv_unicast_packet *unicast_packet;\r\nstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\r\nint check, hdr_size = sizeof(*unicast_packet);\r\ncheck = batadv_check_unicast_packet(bat_priv, skb, hdr_size);\r\nif (check < 0)\r\ngoto free_skb;\r\nunicast_packet = (struct batadv_unicast_packet *)skb->data;\r\nif (batadv_is_my_mac(bat_priv, unicast_packet->dest))\r\ngoto free_skb;\r\nreturn batadv_route_unicast_packet(skb, recv_if);\r\nfree_skb:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nint batadv_recv_unicast_packet(struct sk_buff *skb,\r\nstruct batadv_hard_iface *recv_if)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\r\nstruct batadv_unicast_packet *unicast_packet;\r\nstruct batadv_unicast_4addr_packet *unicast_4addr_packet;\r\nu8 *orig_addr, *orig_addr_gw;\r\nstruct batadv_orig_node *orig_node = NULL, *orig_node_gw = NULL;\r\nint check, hdr_size = sizeof(*unicast_packet);\r\nenum batadv_subtype subtype;\r\nstruct ethhdr *ethhdr;\r\nint ret = NET_RX_DROP;\r\nbool is4addr, is_gw;\r\nunicast_packet = (struct batadv_unicast_packet *)skb->data;\r\nunicast_4addr_packet = (struct batadv_unicast_4addr_packet *)skb->data;\r\nethhdr = eth_hdr(skb);\r\nis4addr = unicast_packet->packet_type == BATADV_UNICAST_4ADDR;\r\nif (is4addr)\r\nhdr_size = sizeof(*unicast_4addr_packet);\r\ncheck = batadv_check_unicast_packet(bat_priv, skb, hdr_size);\r\nif (check == -EREMOTE)\r\nbatadv_nc_skb_store_sniffed_unicast(bat_priv, skb);\r\nif (check < 0)\r\ngoto free_skb;\r\nif (!batadv_check_unicast_ttvn(bat_priv, skb, hdr_size))\r\ngoto free_skb;\r\nif (batadv_is_my_mac(bat_priv, unicast_packet->dest)) {\r\norig_addr_gw = ethhdr->h_source;\r\norig_node_gw = batadv_orig_hash_find(bat_priv, orig_addr_gw);\r\nif (orig_node_gw) {\r\nis_gw = batadv_bla_is_backbone_gw(skb, orig_node_gw,\r\nhdr_size);\r\nbatadv_orig_node_put(orig_node_gw);\r\nif (is_gw) {\r\nbatadv_dbg(BATADV_DBG_BLA, bat_priv,\r\n"%s(): Dropped unicast pkt received from another backbone gw %pM.\n",\r\n__func__, orig_addr_gw);\r\ngoto free_skb;\r\n}\r\n}\r\nif (is4addr) {\r\nsubtype = unicast_4addr_packet->subtype;\r\nbatadv_dat_inc_counter(bat_priv, subtype);\r\nif (subtype == BATADV_P_DATA) {\r\norig_addr = unicast_4addr_packet->src;\r\norig_node = batadv_orig_hash_find(bat_priv,\r\norig_addr);\r\n}\r\n}\r\nif (batadv_dat_snoop_incoming_arp_request(bat_priv, skb,\r\nhdr_size))\r\ngoto rx_success;\r\nif (batadv_dat_snoop_incoming_arp_reply(bat_priv, skb,\r\nhdr_size))\r\ngoto rx_success;\r\nbatadv_interface_rx(recv_if->soft_iface, skb, hdr_size,\r\norig_node);\r\nrx_success:\r\nif (orig_node)\r\nbatadv_orig_node_put(orig_node);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nret = batadv_route_unicast_packet(skb, recv_if);\r\nskb = NULL;\r\nfree_skb:\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nint batadv_recv_unicast_tvlv(struct sk_buff *skb,\r\nstruct batadv_hard_iface *recv_if)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\r\nstruct batadv_unicast_tvlv_packet *unicast_tvlv_packet;\r\nunsigned char *tvlv_buff;\r\nu16 tvlv_buff_len;\r\nint hdr_size = sizeof(*unicast_tvlv_packet);\r\nint ret = NET_RX_DROP;\r\nif (batadv_check_unicast_packet(bat_priv, skb, hdr_size) < 0)\r\ngoto free_skb;\r\nif (skb_cow(skb, hdr_size) < 0)\r\ngoto free_skb;\r\nif (skb_linearize(skb) < 0)\r\ngoto free_skb;\r\nunicast_tvlv_packet = (struct batadv_unicast_tvlv_packet *)skb->data;\r\ntvlv_buff = (unsigned char *)(skb->data + hdr_size);\r\ntvlv_buff_len = ntohs(unicast_tvlv_packet->tvlv_len);\r\nif (tvlv_buff_len > skb->len - hdr_size)\r\ngoto free_skb;\r\nret = batadv_tvlv_containers_process(bat_priv, false, NULL,\r\nunicast_tvlv_packet->src,\r\nunicast_tvlv_packet->dst,\r\ntvlv_buff, tvlv_buff_len);\r\nif (ret != NET_RX_SUCCESS) {\r\nret = batadv_route_unicast_packet(skb, recv_if);\r\nskb = NULL;\r\n}\r\nfree_skb:\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nint batadv_recv_frag_packet(struct sk_buff *skb,\r\nstruct batadv_hard_iface *recv_if)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\r\nstruct batadv_orig_node *orig_node_src = NULL;\r\nstruct batadv_frag_packet *frag_packet;\r\nint ret = NET_RX_DROP;\r\nif (batadv_check_unicast_packet(bat_priv, skb,\r\nsizeof(*frag_packet)) < 0)\r\ngoto free_skb;\r\nfrag_packet = (struct batadv_frag_packet *)skb->data;\r\norig_node_src = batadv_orig_hash_find(bat_priv, frag_packet->orig);\r\nif (!orig_node_src)\r\ngoto free_skb;\r\nskb->priority = frag_packet->priority + 256;\r\nif (!batadv_is_my_mac(bat_priv, frag_packet->dest) &&\r\nbatadv_frag_skb_fwd(skb, recv_if, orig_node_src)) {\r\nskb = NULL;\r\nret = NET_RX_SUCCESS;\r\ngoto put_orig_node;\r\n}\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_FRAG_RX);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_FRAG_RX_BYTES, skb->len);\r\nif (!batadv_frag_skb_buffer(&skb, orig_node_src))\r\ngoto put_orig_node;\r\nif (skb) {\r\nbatadv_batman_skb_recv(skb, recv_if->net_dev,\r\n&recv_if->batman_adv_ptype, NULL);\r\nskb = NULL;\r\n}\r\nret = NET_RX_SUCCESS;\r\nput_orig_node:\r\nbatadv_orig_node_put(orig_node_src);\r\nfree_skb:\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nint batadv_recv_bcast_packet(struct sk_buff *skb,\r\nstruct batadv_hard_iface *recv_if)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\r\nstruct batadv_orig_node *orig_node = NULL;\r\nstruct batadv_bcast_packet *bcast_packet;\r\nstruct ethhdr *ethhdr;\r\nint hdr_size = sizeof(*bcast_packet);\r\nint ret = NET_RX_DROP;\r\ns32 seq_diff;\r\nu32 seqno;\r\nif (unlikely(!pskb_may_pull(skb, hdr_size)))\r\ngoto free_skb;\r\nethhdr = eth_hdr(skb);\r\nif (!is_broadcast_ether_addr(ethhdr->h_dest))\r\ngoto free_skb;\r\nif (is_multicast_ether_addr(ethhdr->h_source))\r\ngoto free_skb;\r\nif (batadv_is_my_mac(bat_priv, ethhdr->h_source))\r\ngoto free_skb;\r\nbcast_packet = (struct batadv_bcast_packet *)skb->data;\r\nif (batadv_is_my_mac(bat_priv, bcast_packet->orig))\r\ngoto free_skb;\r\nif (bcast_packet->ttl < 2)\r\ngoto free_skb;\r\norig_node = batadv_orig_hash_find(bat_priv, bcast_packet->orig);\r\nif (!orig_node)\r\ngoto free_skb;\r\nspin_lock_bh(&orig_node->bcast_seqno_lock);\r\nseqno = ntohl(bcast_packet->seqno);\r\nif (batadv_test_bit(orig_node->bcast_bits, orig_node->last_bcast_seqno,\r\nseqno))\r\ngoto spin_unlock;\r\nseq_diff = seqno - orig_node->last_bcast_seqno;\r\nif (batadv_window_protected(bat_priv, seq_diff,\r\nBATADV_BCAST_MAX_AGE,\r\n&orig_node->bcast_seqno_reset, NULL))\r\ngoto spin_unlock;\r\nif (batadv_bit_get_packet(bat_priv, orig_node->bcast_bits, seq_diff, 1))\r\norig_node->last_bcast_seqno = seqno;\r\nspin_unlock_bh(&orig_node->bcast_seqno_lock);\r\nif (batadv_bla_check_bcast_duplist(bat_priv, skb))\r\ngoto free_skb;\r\nbatadv_skb_set_priority(skb, sizeof(struct batadv_bcast_packet));\r\nbatadv_add_bcast_packet_to_list(bat_priv, skb, 1, false);\r\nif (batadv_bla_is_backbone_gw(skb, orig_node, hdr_size))\r\ngoto free_skb;\r\nif (batadv_dat_snoop_incoming_arp_request(bat_priv, skb, hdr_size))\r\ngoto rx_success;\r\nif (batadv_dat_snoop_incoming_arp_reply(bat_priv, skb, hdr_size))\r\ngoto rx_success;\r\nbatadv_interface_rx(recv_if->soft_iface, skb, hdr_size, orig_node);\r\nrx_success:\r\nret = NET_RX_SUCCESS;\r\ngoto out;\r\nspin_unlock:\r\nspin_unlock_bh(&orig_node->bcast_seqno_lock);\r\nfree_skb:\r\nkfree_skb(skb);\r\nout:\r\nif (orig_node)\r\nbatadv_orig_node_put(orig_node);\r\nreturn ret;\r\n}
