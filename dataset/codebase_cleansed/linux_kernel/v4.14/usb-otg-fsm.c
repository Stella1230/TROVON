static int otg_set_protocol(struct otg_fsm *fsm, int protocol)\r\n{\r\nint ret = 0;\r\nif (fsm->protocol != protocol) {\r\nVDBG("Changing role fsm->protocol= %d; new protocol= %d\n",\r\nfsm->protocol, protocol);\r\nif (fsm->protocol == PROTO_HOST)\r\nret = otg_start_host(fsm, 0);\r\nelse if (fsm->protocol == PROTO_GADGET)\r\nret = otg_start_gadget(fsm, 0);\r\nif (ret)\r\nreturn ret;\r\nif (protocol == PROTO_HOST)\r\nret = otg_start_host(fsm, 1);\r\nelse if (protocol == PROTO_GADGET)\r\nret = otg_start_gadget(fsm, 1);\r\nif (ret)\r\nreturn ret;\r\nfsm->protocol = protocol;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void otg_leave_state(struct otg_fsm *fsm, enum usb_otg_state old_state)\r\n{\r\nswitch (old_state) {\r\ncase OTG_STATE_B_IDLE:\r\notg_del_timer(fsm, B_SE0_SRP);\r\nfsm->b_se0_srp = 0;\r\nfsm->adp_sns = 0;\r\nfsm->adp_prb = 0;\r\nbreak;\r\ncase OTG_STATE_B_SRP_INIT:\r\nfsm->data_pulse = 0;\r\nfsm->b_srp_done = 0;\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\nif (fsm->otg->gadget)\r\nfsm->otg->gadget->host_request_flag = 0;\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\notg_del_timer(fsm, B_ASE0_BRST);\r\nfsm->b_ase0_brst_tmout = 0;\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\nbreak;\r\ncase OTG_STATE_A_IDLE:\r\nfsm->adp_prb = 0;\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VRISE:\r\notg_del_timer(fsm, A_WAIT_VRISE);\r\nfsm->a_wait_vrise_tmout = 0;\r\nbreak;\r\ncase OTG_STATE_A_WAIT_BCON:\r\notg_del_timer(fsm, A_WAIT_BCON);\r\nfsm->a_wait_bcon_tmout = 0;\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\notg_del_timer(fsm, A_WAIT_ENUM);\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\notg_del_timer(fsm, A_AIDL_BDIS);\r\nfsm->a_aidl_bdis_tmout = 0;\r\nfsm->a_suspend_req_inf = 0;\r\nbreak;\r\ncase OTG_STATE_A_PERIPHERAL:\r\notg_del_timer(fsm, A_BIDL_ADIS);\r\nfsm->a_bidl_adis_tmout = 0;\r\nif (fsm->otg->gadget)\r\nfsm->otg->gadget->host_request_flag = 0;\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\notg_del_timer(fsm, A_WAIT_VFALL);\r\nfsm->a_wait_vfall_tmout = 0;\r\notg_del_timer(fsm, A_WAIT_VRISE);\r\nbreak;\r\ncase OTG_STATE_A_VBUS_ERR:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void otg_hnp_polling_work(struct work_struct *work)\r\n{\r\nstruct otg_fsm *fsm = container_of(to_delayed_work(work),\r\nstruct otg_fsm, hnp_polling_work);\r\nstruct usb_device *udev;\r\nenum usb_otg_state state = fsm->otg->state;\r\nu8 flag;\r\nint retval;\r\nif (state != OTG_STATE_A_HOST && state != OTG_STATE_B_HOST)\r\nreturn;\r\nudev = usb_hub_find_child(fsm->otg->host->root_hub, 1);\r\nif (!udev) {\r\ndev_err(fsm->otg->host->controller,\r\n"no usb dev connected, can't start HNP polling\n");\r\nreturn;\r\n}\r\n*fsm->host_req_flag = 0;\r\nretval = usb_control_msg(udev,\r\nusb_rcvctrlpipe(udev, 0),\r\nUSB_REQ_GET_STATUS,\r\nUSB_DIR_IN | USB_RECIP_DEVICE,\r\n0,\r\nOTG_STS_SELECTOR,\r\nfsm->host_req_flag,\r\n1,\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (retval != 1) {\r\ndev_err(&udev->dev, "Get one byte OTG status failed\n");\r\nreturn;\r\n}\r\nflag = *fsm->host_req_flag;\r\nif (flag == 0) {\r\nschedule_delayed_work(&fsm->hnp_polling_work,\r\nmsecs_to_jiffies(T_HOST_REQ_POLL));\r\nreturn;\r\n} else if (flag != HOST_REQUEST_FLAG) {\r\ndev_err(&udev->dev, "host request flag %d is invalid\n", flag);\r\nreturn;\r\n}\r\nif (state == OTG_STATE_A_HOST) {\r\nif (!fsm->otg->host->b_hnp_enable) {\r\nretval = usb_control_msg(udev,\r\nusb_sndctrlpipe(udev, 0),\r\nUSB_REQ_SET_FEATURE, 0,\r\nUSB_DEVICE_B_HNP_ENABLE,\r\n0, NULL, 0,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (retval >= 0)\r\nfsm->otg->host->b_hnp_enable = 1;\r\n}\r\nfsm->a_bus_req = 0;\r\n} else if (state == OTG_STATE_B_HOST) {\r\nfsm->b_bus_req = 0;\r\n}\r\notg_statemachine(fsm);\r\n}\r\nstatic void otg_start_hnp_polling(struct otg_fsm *fsm)\r\n{\r\nif (!fsm->host_req_flag)\r\nreturn;\r\nINIT_DELAYED_WORK(&fsm->hnp_polling_work, otg_hnp_polling_work);\r\nschedule_delayed_work(&fsm->hnp_polling_work,\r\nmsecs_to_jiffies(T_HOST_REQ_POLL));\r\n}\r\nstatic int otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)\r\n{\r\nif (fsm->otg->state == new_state)\r\nreturn 0;\r\nVDBG("Set state: %s\n", usb_otg_state_string(new_state));\r\notg_leave_state(fsm, fsm->otg->state);\r\nswitch (new_state) {\r\ncase OTG_STATE_B_IDLE:\r\notg_drv_vbus(fsm, 0);\r\notg_chrg_vbus(fsm, 0);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_start_adp_sns(fsm);\r\notg_set_protocol(fsm, PROTO_UNDEF);\r\notg_add_timer(fsm, B_SE0_SRP);\r\nbreak;\r\ncase OTG_STATE_B_SRP_INIT:\r\notg_start_pulse(fsm);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_UNDEF);\r\notg_add_timer(fsm, B_SRP_FAIL);\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\notg_chrg_vbus(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_GADGET);\r\notg_loc_conn(fsm, 1);\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\notg_chrg_vbus(fsm, 0);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_HOST);\r\notg_add_timer(fsm, B_ASE0_BRST);\r\nfsm->a_bus_suspend = 0;\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\notg_chrg_vbus(fsm, 0);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 1);\r\notg_set_protocol(fsm, PROTO_HOST);\r\nusb_bus_start_enum(fsm->otg->host,\r\nfsm->otg->host->otg_port);\r\notg_start_hnp_polling(fsm);\r\nbreak;\r\ncase OTG_STATE_A_IDLE:\r\notg_drv_vbus(fsm, 0);\r\notg_chrg_vbus(fsm, 0);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_start_adp_prb(fsm);\r\notg_set_protocol(fsm, PROTO_HOST);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VRISE:\r\notg_drv_vbus(fsm, 1);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_HOST);\r\notg_add_timer(fsm, A_WAIT_VRISE);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_BCON:\r\notg_drv_vbus(fsm, 1);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_HOST);\r\notg_add_timer(fsm, A_WAIT_BCON);\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\notg_drv_vbus(fsm, 1);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 1);\r\notg_set_protocol(fsm, PROTO_HOST);\r\nif (!fsm->a_bus_req || fsm->a_suspend_req_inf)\r\notg_add_timer(fsm, A_WAIT_ENUM);\r\notg_start_hnp_polling(fsm);\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\notg_drv_vbus(fsm, 1);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_HOST);\r\notg_add_timer(fsm, A_AIDL_BDIS);\r\nbreak;\r\ncase OTG_STATE_A_PERIPHERAL:\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_GADGET);\r\notg_drv_vbus(fsm, 1);\r\notg_loc_conn(fsm, 1);\r\notg_add_timer(fsm, A_BIDL_ADIS);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\notg_drv_vbus(fsm, 0);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_HOST);\r\notg_add_timer(fsm, A_WAIT_VFALL);\r\nbreak;\r\ncase OTG_STATE_A_VBUS_ERR:\r\notg_drv_vbus(fsm, 0);\r\notg_loc_conn(fsm, 0);\r\notg_loc_sof(fsm, 0);\r\notg_set_protocol(fsm, PROTO_UNDEF);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfsm->otg->state = new_state;\r\nfsm->state_changed = 1;\r\nreturn 0;\r\n}\r\nint otg_statemachine(struct otg_fsm *fsm)\r\n{\r\nenum usb_otg_state state;\r\nmutex_lock(&fsm->lock);\r\nstate = fsm->otg->state;\r\nfsm->state_changed = 0;\r\nswitch (state) {\r\ncase OTG_STATE_UNDEFINED:\r\nVDBG("fsm->id = %d\n", fsm->id);\r\nif (fsm->id)\r\notg_set_state(fsm, OTG_STATE_B_IDLE);\r\nelse\r\notg_set_state(fsm, OTG_STATE_A_IDLE);\r\nbreak;\r\ncase OTG_STATE_B_IDLE:\r\nif (!fsm->id)\r\notg_set_state(fsm, OTG_STATE_A_IDLE);\r\nelse if (fsm->b_sess_vld && fsm->otg->gadget)\r\notg_set_state(fsm, OTG_STATE_B_PERIPHERAL);\r\nelse if ((fsm->b_bus_req || fsm->adp_change || fsm->power_up) &&\r\nfsm->b_ssend_srp && fsm->b_se0_srp)\r\notg_set_state(fsm, OTG_STATE_B_SRP_INIT);\r\nbreak;\r\ncase OTG_STATE_B_SRP_INIT:\r\nif (!fsm->id || fsm->b_srp_done)\r\notg_set_state(fsm, OTG_STATE_B_IDLE);\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\nif (!fsm->id || !fsm->b_sess_vld)\r\notg_set_state(fsm, OTG_STATE_B_IDLE);\r\nelse if (fsm->b_bus_req && fsm->otg->\r\ngadget->b_hnp_enable && fsm->a_bus_suspend)\r\notg_set_state(fsm, OTG_STATE_B_WAIT_ACON);\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\nif (fsm->a_conn)\r\notg_set_state(fsm, OTG_STATE_B_HOST);\r\nelse if (!fsm->id || !fsm->b_sess_vld)\r\notg_set_state(fsm, OTG_STATE_B_IDLE);\r\nelse if (fsm->a_bus_resume || fsm->b_ase0_brst_tmout) {\r\nfsm->b_ase0_brst_tmout = 0;\r\notg_set_state(fsm, OTG_STATE_B_PERIPHERAL);\r\n}\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\nif (!fsm->id || !fsm->b_sess_vld)\r\notg_set_state(fsm, OTG_STATE_B_IDLE);\r\nelse if (!fsm->b_bus_req || !fsm->a_conn || fsm->test_device)\r\notg_set_state(fsm, OTG_STATE_B_PERIPHERAL);\r\nbreak;\r\ncase OTG_STATE_A_IDLE:\r\nif (fsm->id)\r\notg_set_state(fsm, OTG_STATE_B_IDLE);\r\nelse if (!fsm->a_bus_drop && (fsm->a_bus_req ||\r\nfsm->a_srp_det || fsm->adp_change || fsm->power_up))\r\notg_set_state(fsm, OTG_STATE_A_WAIT_VRISE);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VRISE:\r\nif (fsm->a_vbus_vld)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_BCON);\r\nelse if (fsm->id || fsm->a_bus_drop ||\r\nfsm->a_wait_vrise_tmout)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_BCON:\r\nif (!fsm->a_vbus_vld)\r\notg_set_state(fsm, OTG_STATE_A_VBUS_ERR);\r\nelse if (fsm->b_conn)\r\notg_set_state(fsm, OTG_STATE_A_HOST);\r\nelse if (fsm->id || fsm->a_bus_drop || fsm->a_wait_bcon_tmout)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\nif (fsm->id || fsm->a_bus_drop)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\r\nelse if ((!fsm->a_bus_req || fsm->a_suspend_req_inf) &&\r\nfsm->otg->host->b_hnp_enable)\r\notg_set_state(fsm, OTG_STATE_A_SUSPEND);\r\nelse if (!fsm->b_conn)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_BCON);\r\nelse if (!fsm->a_vbus_vld)\r\notg_set_state(fsm, OTG_STATE_A_VBUS_ERR);\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\nif (!fsm->b_conn && fsm->otg->host->b_hnp_enable)\r\notg_set_state(fsm, OTG_STATE_A_PERIPHERAL);\r\nelse if (!fsm->b_conn && !fsm->otg->host->b_hnp_enable)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_BCON);\r\nelse if (fsm->a_bus_req || fsm->b_bus_resume)\r\notg_set_state(fsm, OTG_STATE_A_HOST);\r\nelse if (fsm->id || fsm->a_bus_drop || fsm->a_aidl_bdis_tmout)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\r\nelse if (!fsm->a_vbus_vld)\r\notg_set_state(fsm, OTG_STATE_A_VBUS_ERR);\r\nbreak;\r\ncase OTG_STATE_A_PERIPHERAL:\r\nif (fsm->id || fsm->a_bus_drop)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\r\nelse if (fsm->a_bidl_adis_tmout || fsm->b_bus_suspend)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_BCON);\r\nelse if (!fsm->a_vbus_vld)\r\notg_set_state(fsm, OTG_STATE_A_VBUS_ERR);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nif (fsm->a_wait_vfall_tmout)\r\notg_set_state(fsm, OTG_STATE_A_IDLE);\r\nbreak;\r\ncase OTG_STATE_A_VBUS_ERR:\r\nif (fsm->id || fsm->a_bus_drop || fsm->a_clr_err)\r\notg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&fsm->lock);\r\nVDBG("quit statemachine, changed = %d\n", fsm->state_changed);\r\nreturn fsm->state_changed;\r\n}
