static void i2c_dw_configure_fifo_master(struct dw_i2c_dev *dev)\r\n{\r\ndw_writel(dev, dev->tx_fifo_depth / 2, DW_IC_TX_TL);\r\ndw_writel(dev, 0, DW_IC_RX_TL);\r\ndw_writel(dev, dev->master_cfg, DW_IC_CON);\r\n}\r\nstatic int i2c_dw_init_master(struct dw_i2c_dev *dev)\r\n{\r\nu32 hcnt, lcnt;\r\nu32 reg, comp_param1;\r\nu32 sda_falling_time, scl_falling_time;\r\nint ret;\r\nret = i2c_dw_acquire_lock(dev);\r\nif (ret)\r\nreturn ret;\r\nreg = dw_readl(dev, DW_IC_COMP_TYPE);\r\nif (reg == ___constant_swab32(DW_IC_COMP_TYPE_VALUE)) {\r\ndev->flags |= ACCESS_SWAP;\r\n} else if (reg == (DW_IC_COMP_TYPE_VALUE & 0x0000ffff)) {\r\ndev->flags |= ACCESS_16BIT;\r\n} else if (reg != DW_IC_COMP_TYPE_VALUE) {\r\ndev_err(dev->dev,\r\n"Unknown Synopsys component type: 0x%08x\n", reg);\r\ni2c_dw_release_lock(dev);\r\nreturn -ENODEV;\r\n}\r\ncomp_param1 = dw_readl(dev, DW_IC_COMP_PARAM_1);\r\n__i2c_dw_enable_and_wait(dev, false);\r\nsda_falling_time = dev->sda_falling_time ?: 300;\r\nscl_falling_time = dev->scl_falling_time ?: 300;\r\nif (dev->ss_hcnt && dev->ss_lcnt) {\r\nhcnt = dev->ss_hcnt;\r\nlcnt = dev->ss_lcnt;\r\n} else {\r\nhcnt = i2c_dw_scl_hcnt(i2c_dw_clk_rate(dev),\r\n4000,\r\nsda_falling_time,\r\n0,\r\n0);\r\nlcnt = i2c_dw_scl_lcnt(i2c_dw_clk_rate(dev),\r\n4700,\r\nscl_falling_time,\r\n0);\r\n}\r\ndw_writel(dev, hcnt, DW_IC_SS_SCL_HCNT);\r\ndw_writel(dev, lcnt, DW_IC_SS_SCL_LCNT);\r\ndev_dbg(dev->dev, "Standard-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);\r\nif ((dev->clk_freq == 1000000) && dev->fp_hcnt && dev->fp_lcnt) {\r\nhcnt = dev->fp_hcnt;\r\nlcnt = dev->fp_lcnt;\r\n} else if (dev->fs_hcnt && dev->fs_lcnt) {\r\nhcnt = dev->fs_hcnt;\r\nlcnt = dev->fs_lcnt;\r\n} else {\r\nhcnt = i2c_dw_scl_hcnt(i2c_dw_clk_rate(dev),\r\n600,\r\nsda_falling_time,\r\n0,\r\n0);\r\nlcnt = i2c_dw_scl_lcnt(i2c_dw_clk_rate(dev),\r\n1300,\r\nscl_falling_time,\r\n0);\r\n}\r\ndw_writel(dev, hcnt, DW_IC_FS_SCL_HCNT);\r\ndw_writel(dev, lcnt, DW_IC_FS_SCL_LCNT);\r\ndev_dbg(dev->dev, "Fast-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);\r\nif ((dev->master_cfg & DW_IC_CON_SPEED_MASK) ==\r\nDW_IC_CON_SPEED_HIGH) {\r\nif ((comp_param1 & DW_IC_COMP_PARAM_1_SPEED_MODE_MASK)\r\n!= DW_IC_COMP_PARAM_1_SPEED_MODE_HIGH) {\r\ndev_err(dev->dev, "High Speed not supported!\n");\r\ndev->master_cfg &= ~DW_IC_CON_SPEED_MASK;\r\ndev->master_cfg |= DW_IC_CON_SPEED_FAST;\r\n} else if (dev->hs_hcnt && dev->hs_lcnt) {\r\nhcnt = dev->hs_hcnt;\r\nlcnt = dev->hs_lcnt;\r\ndw_writel(dev, hcnt, DW_IC_HS_SCL_HCNT);\r\ndw_writel(dev, lcnt, DW_IC_HS_SCL_LCNT);\r\ndev_dbg(dev->dev, "HighSpeed-mode HCNT:LCNT = %d:%d\n",\r\nhcnt, lcnt);\r\n}\r\n}\r\nreg = dw_readl(dev, DW_IC_COMP_VERSION);\r\nif (reg >= DW_IC_SDA_HOLD_MIN_VERS) {\r\nif (!dev->sda_hold_time) {\r\ndev->sda_hold_time = dw_readl(dev, DW_IC_SDA_HOLD);\r\n}\r\nif (!(dev->sda_hold_time & DW_IC_SDA_HOLD_RX_MASK))\r\ndev->sda_hold_time |= 1 << DW_IC_SDA_HOLD_RX_SHIFT;\r\ndw_writel(dev, dev->sda_hold_time, DW_IC_SDA_HOLD);\r\n} else {\r\ndev_warn(dev->dev,\r\n"Hardware too old to adjust SDA hold time.\n");\r\n}\r\ni2c_dw_configure_fifo_master(dev);\r\ni2c_dw_release_lock(dev);\r\nreturn 0;\r\n}\r\nstatic void i2c_dw_xfer_init(struct dw_i2c_dev *dev)\r\n{\r\nstruct i2c_msg *msgs = dev->msgs;\r\nu32 ic_con, ic_tar = 0;\r\n__i2c_dw_enable_and_wait(dev, false);\r\nic_con = dw_readl(dev, DW_IC_CON);\r\nif (msgs[dev->msg_write_idx].flags & I2C_M_TEN) {\r\nic_con |= DW_IC_CON_10BITADDR_MASTER;\r\nic_tar = DW_IC_TAR_10BITADDR_MASTER;\r\n} else {\r\nic_con &= ~DW_IC_CON_10BITADDR_MASTER;\r\n}\r\ndw_writel(dev, ic_con, DW_IC_CON);\r\ndw_writel(dev, msgs[dev->msg_write_idx].addr | ic_tar, DW_IC_TAR);\r\ni2c_dw_disable_int(dev);\r\n__i2c_dw_enable(dev, true);\r\ndw_readl(dev, DW_IC_CLR_INTR);\r\ndw_writel(dev, DW_IC_INTR_MASTER_MASK, DW_IC_INTR_MASK);\r\n}\r\nstatic void\r\ni2c_dw_xfer_msg(struct dw_i2c_dev *dev)\r\n{\r\nstruct i2c_msg *msgs = dev->msgs;\r\nu32 intr_mask;\r\nint tx_limit, rx_limit;\r\nu32 addr = msgs[dev->msg_write_idx].addr;\r\nu32 buf_len = dev->tx_buf_len;\r\nu8 *buf = dev->tx_buf;\r\nbool need_restart = false;\r\nintr_mask = DW_IC_INTR_MASTER_MASK;\r\nfor (; dev->msg_write_idx < dev->msgs_num; dev->msg_write_idx++) {\r\nu32 flags = msgs[dev->msg_write_idx].flags;\r\nif (msgs[dev->msg_write_idx].addr != addr) {\r\ndev_err(dev->dev,\r\n"%s: invalid target address\n", __func__);\r\ndev->msg_err = -EINVAL;\r\nbreak;\r\n}\r\nif (msgs[dev->msg_write_idx].len == 0) {\r\ndev_err(dev->dev,\r\n"%s: invalid message length\n", __func__);\r\ndev->msg_err = -EINVAL;\r\nbreak;\r\n}\r\nif (!(dev->status & STATUS_WRITE_IN_PROGRESS)) {\r\nbuf = msgs[dev->msg_write_idx].buf;\r\nbuf_len = msgs[dev->msg_write_idx].len;\r\nif ((dev->master_cfg & DW_IC_CON_RESTART_EN) &&\r\n(dev->msg_write_idx > 0))\r\nneed_restart = true;\r\n}\r\ntx_limit = dev->tx_fifo_depth - dw_readl(dev, DW_IC_TXFLR);\r\nrx_limit = dev->rx_fifo_depth - dw_readl(dev, DW_IC_RXFLR);\r\nwhile (buf_len > 0 && tx_limit > 0 && rx_limit > 0) {\r\nu32 cmd = 0;\r\nif (dev->msg_write_idx == dev->msgs_num - 1 &&\r\nbuf_len == 1 && !(flags & I2C_M_RECV_LEN))\r\ncmd |= BIT(9);\r\nif (need_restart) {\r\ncmd |= BIT(10);\r\nneed_restart = false;\r\n}\r\nif (msgs[dev->msg_write_idx].flags & I2C_M_RD) {\r\nif (dev->rx_outstanding >= dev->rx_fifo_depth)\r\nbreak;\r\ndw_writel(dev, cmd | 0x100, DW_IC_DATA_CMD);\r\nrx_limit--;\r\ndev->rx_outstanding++;\r\n} else\r\ndw_writel(dev, cmd | *buf++, DW_IC_DATA_CMD);\r\ntx_limit--; buf_len--;\r\n}\r\ndev->tx_buf = buf;\r\ndev->tx_buf_len = buf_len;\r\nif (buf_len > 0 || flags & I2C_M_RECV_LEN) {\r\ndev->status |= STATUS_WRITE_IN_PROGRESS;\r\nbreak;\r\n} else\r\ndev->status &= ~STATUS_WRITE_IN_PROGRESS;\r\n}\r\nif (dev->msg_write_idx == dev->msgs_num)\r\nintr_mask &= ~DW_IC_INTR_TX_EMPTY;\r\nif (dev->msg_err)\r\nintr_mask = 0;\r\ndw_writel(dev, intr_mask, DW_IC_INTR_MASK);\r\n}\r\nstatic u8\r\ni2c_dw_recv_len(struct dw_i2c_dev *dev, u8 len)\r\n{\r\nstruct i2c_msg *msgs = dev->msgs;\r\nu32 flags = msgs[dev->msg_read_idx].flags;\r\nlen += (flags & I2C_CLIENT_PEC) ? 2 : 1;\r\ndev->tx_buf_len = len - min_t(u8, len, dev->rx_outstanding);\r\nmsgs[dev->msg_read_idx].len = len;\r\nmsgs[dev->msg_read_idx].flags &= ~I2C_M_RECV_LEN;\r\nreturn len;\r\n}\r\nstatic void\r\ni2c_dw_read(struct dw_i2c_dev *dev)\r\n{\r\nstruct i2c_msg *msgs = dev->msgs;\r\nint rx_valid;\r\nfor (; dev->msg_read_idx < dev->msgs_num; dev->msg_read_idx++) {\r\nu32 len;\r\nu8 *buf;\r\nif (!(msgs[dev->msg_read_idx].flags & I2C_M_RD))\r\ncontinue;\r\nif (!(dev->status & STATUS_READ_IN_PROGRESS)) {\r\nlen = msgs[dev->msg_read_idx].len;\r\nbuf = msgs[dev->msg_read_idx].buf;\r\n} else {\r\nlen = dev->rx_buf_len;\r\nbuf = dev->rx_buf;\r\n}\r\nrx_valid = dw_readl(dev, DW_IC_RXFLR);\r\nfor (; len > 0 && rx_valid > 0; len--, rx_valid--) {\r\nu32 flags = msgs[dev->msg_read_idx].flags;\r\n*buf = dw_readl(dev, DW_IC_DATA_CMD);\r\nif (flags & I2C_M_RECV_LEN &&\r\n*buf <= I2C_SMBUS_BLOCK_MAX && *buf > 0) {\r\nlen = i2c_dw_recv_len(dev, *buf);\r\n}\r\nbuf++;\r\ndev->rx_outstanding--;\r\n}\r\nif (len > 0) {\r\ndev->status |= STATUS_READ_IN_PROGRESS;\r\ndev->rx_buf_len = len;\r\ndev->rx_buf = buf;\r\nreturn;\r\n} else\r\ndev->status &= ~STATUS_READ_IN_PROGRESS;\r\n}\r\n}\r\nstatic int\r\ni2c_dw_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\r\n{\r\nstruct dw_i2c_dev *dev = i2c_get_adapdata(adap);\r\nint ret;\r\ndev_dbg(dev->dev, "%s: msgs: %d\n", __func__, num);\r\npm_runtime_get_sync(dev->dev);\r\nreinit_completion(&dev->cmd_complete);\r\ndev->msgs = msgs;\r\ndev->msgs_num = num;\r\ndev->cmd_err = 0;\r\ndev->msg_write_idx = 0;\r\ndev->msg_read_idx = 0;\r\ndev->msg_err = 0;\r\ndev->status = STATUS_IDLE;\r\ndev->abort_source = 0;\r\ndev->rx_outstanding = 0;\r\nret = i2c_dw_acquire_lock(dev);\r\nif (ret)\r\ngoto done_nolock;\r\nret = i2c_dw_wait_bus_not_busy(dev);\r\nif (ret < 0)\r\ngoto done;\r\ni2c_dw_xfer_init(dev);\r\nif (!wait_for_completion_timeout(&dev->cmd_complete, adap->timeout)) {\r\ndev_err(dev->dev, "controller timed out\n");\r\ni2c_dw_init_master(dev);\r\nret = -ETIMEDOUT;\r\ngoto done;\r\n}\r\n__i2c_dw_enable(dev, false);\r\nif (dev->msg_err) {\r\nret = dev->msg_err;\r\ngoto done;\r\n}\r\nif (likely(!dev->cmd_err && !dev->status)) {\r\nret = num;\r\ngoto done;\r\n}\r\nif (dev->cmd_err == DW_IC_ERR_TX_ABRT) {\r\nret = i2c_dw_handle_tx_abort(dev);\r\ngoto done;\r\n}\r\nif (dev->status)\r\ndev_err(dev->dev,\r\n"transfer terminated early - interrupt latency too high?\n");\r\nret = -EIO;\r\ndone:\r\ni2c_dw_release_lock(dev);\r\ndone_nolock:\r\npm_runtime_mark_last_busy(dev->dev);\r\npm_runtime_put_autosuspend(dev->dev);\r\nreturn ret;\r\n}\r\nstatic u32 i2c_dw_read_clear_intrbits(struct dw_i2c_dev *dev)\r\n{\r\nu32 stat;\r\nstat = dw_readl(dev, DW_IC_INTR_STAT);\r\nif (stat & DW_IC_INTR_RX_UNDER)\r\ndw_readl(dev, DW_IC_CLR_RX_UNDER);\r\nif (stat & DW_IC_INTR_RX_OVER)\r\ndw_readl(dev, DW_IC_CLR_RX_OVER);\r\nif (stat & DW_IC_INTR_TX_OVER)\r\ndw_readl(dev, DW_IC_CLR_TX_OVER);\r\nif (stat & DW_IC_INTR_RD_REQ)\r\ndw_readl(dev, DW_IC_CLR_RD_REQ);\r\nif (stat & DW_IC_INTR_TX_ABRT) {\r\ndev->abort_source = dw_readl(dev, DW_IC_TX_ABRT_SOURCE);\r\ndw_readl(dev, DW_IC_CLR_TX_ABRT);\r\n}\r\nif (stat & DW_IC_INTR_RX_DONE)\r\ndw_readl(dev, DW_IC_CLR_RX_DONE);\r\nif (stat & DW_IC_INTR_ACTIVITY)\r\ndw_readl(dev, DW_IC_CLR_ACTIVITY);\r\nif (stat & DW_IC_INTR_STOP_DET)\r\ndw_readl(dev, DW_IC_CLR_STOP_DET);\r\nif (stat & DW_IC_INTR_START_DET)\r\ndw_readl(dev, DW_IC_CLR_START_DET);\r\nif (stat & DW_IC_INTR_GEN_CALL)\r\ndw_readl(dev, DW_IC_CLR_GEN_CALL);\r\nreturn stat;\r\n}\r\nstatic int i2c_dw_irq_handler_master(struct dw_i2c_dev *dev)\r\n{\r\nu32 stat;\r\nstat = i2c_dw_read_clear_intrbits(dev);\r\nif (stat & DW_IC_INTR_TX_ABRT) {\r\ndev->cmd_err |= DW_IC_ERR_TX_ABRT;\r\ndev->status = STATUS_IDLE;\r\ndw_writel(dev, 0, DW_IC_INTR_MASK);\r\ngoto tx_aborted;\r\n}\r\nif (stat & DW_IC_INTR_RX_FULL)\r\ni2c_dw_read(dev);\r\nif (stat & DW_IC_INTR_TX_EMPTY)\r\ni2c_dw_xfer_msg(dev);\r\ntx_aborted:\r\nif ((stat & (DW_IC_INTR_TX_ABRT | DW_IC_INTR_STOP_DET)) || dev->msg_err)\r\ncomplete(&dev->cmd_complete);\r\nelse if (unlikely(dev->flags & ACCESS_INTR_MASK)) {\r\nstat = dw_readl(dev, DW_IC_INTR_MASK);\r\ni2c_dw_disable_int(dev);\r\ndw_writel(dev, stat, DW_IC_INTR_MASK);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t i2c_dw_isr(int this_irq, void *dev_id)\r\n{\r\nstruct dw_i2c_dev *dev = dev_id;\r\nu32 stat, enabled;\r\nenabled = dw_readl(dev, DW_IC_ENABLE);\r\nstat = dw_readl(dev, DW_IC_RAW_INTR_STAT);\r\ndev_dbg(dev->dev, "enabled=%#x stat=%#x\n", enabled, stat);\r\nif (!enabled || !(stat & ~DW_IC_INTR_ACTIVITY))\r\nreturn IRQ_NONE;\r\ni2c_dw_irq_handler_master(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nint i2c_dw_probe(struct dw_i2c_dev *dev)\r\n{\r\nstruct i2c_adapter *adap = &dev->adapter;\r\nunsigned long irq_flags;\r\nint ret;\r\ninit_completion(&dev->cmd_complete);\r\ndev->init = i2c_dw_init_master;\r\ndev->disable = i2c_dw_disable;\r\ndev->disable_int = i2c_dw_disable_int;\r\nret = dev->init(dev);\r\nif (ret)\r\nreturn ret;\r\nsnprintf(adap->name, sizeof(adap->name),\r\n"Synopsys DesignWare I2C adapter");\r\nadap->retries = 3;\r\nadap->algo = &i2c_dw_algo;\r\nadap->dev.parent = dev->dev;\r\ni2c_set_adapdata(adap, dev);\r\nif (dev->pm_disabled) {\r\ndev_pm_syscore_device(dev->dev, true);\r\nirq_flags = IRQF_NO_SUSPEND;\r\n} else {\r\nirq_flags = IRQF_SHARED | IRQF_COND_SUSPEND;\r\n}\r\ni2c_dw_disable_int(dev);\r\nret = devm_request_irq(dev->dev, dev->irq, i2c_dw_isr, irq_flags,\r\ndev_name(dev->dev), dev);\r\nif (ret) {\r\ndev_err(dev->dev, "failure requesting irq %i: %d\n",\r\ndev->irq, ret);\r\nreturn ret;\r\n}\r\npm_runtime_get_noresume(dev->dev);\r\nret = i2c_add_numbered_adapter(adap);\r\nif (ret)\r\ndev_err(dev->dev, "failure adding adapter: %d\n", ret);\r\npm_runtime_put_noidle(dev->dev);\r\nreturn ret;\r\n}
