int snd_dg00x_stream_get_local_rate(struct snd_dg00x *dg00x, unsigned int *rate)\r\n{\r\nu32 data;\r\n__be32 reg;\r\nint err;\r\nerr = snd_fw_transaction(dg00x->unit, TCODE_READ_QUADLET_REQUEST,\r\nDG00X_ADDR_BASE + DG00X_OFFSET_LOCAL_RATE,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\nreturn err;\r\ndata = be32_to_cpu(reg) & 0x0f;\r\nif (data < ARRAY_SIZE(snd_dg00x_stream_rates))\r\n*rate = snd_dg00x_stream_rates[data];\r\nelse\r\nerr = -EIO;\r\nreturn err;\r\n}\r\nint snd_dg00x_stream_set_local_rate(struct snd_dg00x *dg00x, unsigned int rate)\r\n{\r\n__be32 reg;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(snd_dg00x_stream_rates); i++) {\r\nif (rate == snd_dg00x_stream_rates[i])\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(snd_dg00x_stream_rates))\r\nreturn -EINVAL;\r\nreg = cpu_to_be32(i);\r\nreturn snd_fw_transaction(dg00x->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nDG00X_ADDR_BASE + DG00X_OFFSET_LOCAL_RATE,\r\n&reg, sizeof(reg), 0);\r\n}\r\nint snd_dg00x_stream_get_clock(struct snd_dg00x *dg00x,\r\nenum snd_dg00x_clock *clock)\r\n{\r\n__be32 reg;\r\nint err;\r\nerr = snd_fw_transaction(dg00x->unit, TCODE_READ_QUADLET_REQUEST,\r\nDG00X_ADDR_BASE + DG00X_OFFSET_CLOCK_SOURCE,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\nreturn err;\r\n*clock = be32_to_cpu(reg) & 0x0f;\r\nif (*clock >= SND_DG00X_CLOCK_COUNT)\r\nerr = -EIO;\r\nreturn err;\r\n}\r\nint snd_dg00x_stream_check_external_clock(struct snd_dg00x *dg00x, bool *detect)\r\n{\r\n__be32 reg;\r\nint err;\r\nerr = snd_fw_transaction(dg00x->unit, TCODE_READ_QUADLET_REQUEST,\r\nDG00X_ADDR_BASE + DG00X_OFFSET_DETECT_EXTERNAL,\r\n&reg, sizeof(reg), 0);\r\nif (err >= 0)\r\n*detect = be32_to_cpu(reg) > 0;\r\nreturn err;\r\n}\r\nint snd_dg00x_stream_get_external_rate(struct snd_dg00x *dg00x,\r\nunsigned int *rate)\r\n{\r\nu32 data;\r\n__be32 reg;\r\nint err;\r\nerr = snd_fw_transaction(dg00x->unit, TCODE_READ_QUADLET_REQUEST,\r\nDG00X_ADDR_BASE + DG00X_OFFSET_EXTERNAL_RATE,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\nreturn err;\r\ndata = be32_to_cpu(reg) & 0x0f;\r\nif (data < ARRAY_SIZE(snd_dg00x_stream_rates))\r\n*rate = snd_dg00x_stream_rates[data];\r\nelse\r\nerr = -EBUSY;\r\nreturn err;\r\n}\r\nstatic void finish_session(struct snd_dg00x *dg00x)\r\n{\r\n__be32 data = cpu_to_be32(0x00000003);\r\nsnd_fw_transaction(dg00x->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nDG00X_ADDR_BASE + DG00X_OFFSET_STREAMING_SET,\r\n&data, sizeof(data), 0);\r\n}\r\nstatic int begin_session(struct snd_dg00x *dg00x)\r\n{\r\n__be32 data;\r\nu32 curr;\r\nint err;\r\nerr = snd_fw_transaction(dg00x->unit, TCODE_READ_QUADLET_REQUEST,\r\nDG00X_ADDR_BASE + DG00X_OFFSET_STREAMING_STATE,\r\n&data, sizeof(data), 0);\r\nif (err < 0)\r\ngoto error;\r\ncurr = be32_to_cpu(data);\r\nif (curr == 0)\r\ncurr = 2;\r\ncurr--;\r\nwhile (curr > 0) {\r\ndata = cpu_to_be32(curr);\r\nerr = snd_fw_transaction(dg00x->unit,\r\nTCODE_WRITE_QUADLET_REQUEST,\r\nDG00X_ADDR_BASE +\r\nDG00X_OFFSET_STREAMING_SET,\r\n&data, sizeof(data), 0);\r\nif (err < 0)\r\ngoto error;\r\nmsleep(20);\r\ncurr--;\r\n}\r\nreturn 0;\r\nerror:\r\nfinish_session(dg00x);\r\nreturn err;\r\n}\r\nstatic void release_resources(struct snd_dg00x *dg00x)\r\n{\r\n__be32 data = 0;\r\nsnd_fw_transaction(dg00x->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nDG00X_ADDR_BASE + DG00X_OFFSET_ISOC_CHANNELS,\r\n&data, sizeof(data), 0);\r\nfw_iso_resources_free(&dg00x->tx_resources);\r\nfw_iso_resources_free(&dg00x->rx_resources);\r\n}\r\nstatic int keep_resources(struct snd_dg00x *dg00x, unsigned int rate)\r\n{\r\nunsigned int i;\r\n__be32 data;\r\nint err;\r\nfor (i = 0; i < SND_DG00X_RATE_COUNT; i++) {\r\nif (snd_dg00x_stream_rates[i] == rate)\r\nbreak;\r\n}\r\nif (i == SND_DG00X_RATE_COUNT)\r\nreturn -EINVAL;\r\nerr = amdtp_dot_set_parameters(&dg00x->rx_stream, rate,\r\nsnd_dg00x_stream_pcm_channels[i]);\r\nif (err < 0)\r\nreturn err;\r\nerr = fw_iso_resources_allocate(&dg00x->rx_resources,\r\namdtp_stream_get_max_payload(&dg00x->rx_stream),\r\nfw_parent_device(dg00x->unit)->max_speed);\r\nif (err < 0)\r\nreturn err;\r\nerr = amdtp_dot_set_parameters(&dg00x->tx_stream, rate,\r\nsnd_dg00x_stream_pcm_channels[i]);\r\nif (err < 0)\r\nreturn err;\r\nerr = fw_iso_resources_allocate(&dg00x->tx_resources,\r\namdtp_stream_get_max_payload(&dg00x->tx_stream),\r\nfw_parent_device(dg00x->unit)->max_speed);\r\nif (err < 0)\r\ngoto error;\r\ndata = cpu_to_be32((dg00x->tx_resources.channel << 16) |\r\ndg00x->rx_resources.channel);\r\nerr = snd_fw_transaction(dg00x->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nDG00X_ADDR_BASE + DG00X_OFFSET_ISOC_CHANNELS,\r\n&data, sizeof(data), 0);\r\nif (err < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nrelease_resources(dg00x);\r\nreturn err;\r\n}\r\nint snd_dg00x_stream_init_duplex(struct snd_dg00x *dg00x)\r\n{\r\nint err;\r\nerr = fw_iso_resources_init(&dg00x->rx_resources, dg00x->unit);\r\nif (err < 0)\r\ngoto error;\r\nerr = amdtp_dot_init(&dg00x->rx_stream, dg00x->unit, AMDTP_OUT_STREAM);\r\nif (err < 0)\r\ngoto error;\r\nerr = fw_iso_resources_init(&dg00x->tx_resources, dg00x->unit);\r\nif (err < 0)\r\ngoto error;\r\nerr = amdtp_dot_init(&dg00x->tx_stream, dg00x->unit, AMDTP_IN_STREAM);\r\nif (err < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nsnd_dg00x_stream_destroy_duplex(dg00x);\r\nreturn err;\r\n}\r\nvoid snd_dg00x_stream_destroy_duplex(struct snd_dg00x *dg00x)\r\n{\r\namdtp_stream_destroy(&dg00x->rx_stream);\r\nfw_iso_resources_destroy(&dg00x->rx_resources);\r\namdtp_stream_destroy(&dg00x->tx_stream);\r\nfw_iso_resources_destroy(&dg00x->tx_resources);\r\n}\r\nint snd_dg00x_stream_start_duplex(struct snd_dg00x *dg00x, unsigned int rate)\r\n{\r\nunsigned int curr_rate;\r\nint err = 0;\r\nif (dg00x->substreams_counter == 0)\r\ngoto end;\r\nerr = snd_dg00x_stream_get_local_rate(dg00x, &curr_rate);\r\nif (err < 0)\r\ngoto error;\r\nif (rate == 0)\r\nrate = curr_rate;\r\nif (curr_rate != rate ||\r\namdtp_streaming_error(&dg00x->tx_stream) ||\r\namdtp_streaming_error(&dg00x->rx_stream)) {\r\nfinish_session(dg00x);\r\namdtp_stream_stop(&dg00x->tx_stream);\r\namdtp_stream_stop(&dg00x->rx_stream);\r\nrelease_resources(dg00x);\r\n}\r\nif (!amdtp_stream_running(&dg00x->rx_stream)) {\r\nerr = snd_dg00x_stream_set_local_rate(dg00x, rate);\r\nif (err < 0)\r\ngoto error;\r\nerr = keep_resources(dg00x, rate);\r\nif (err < 0)\r\ngoto error;\r\nerr = begin_session(dg00x);\r\nif (err < 0)\r\ngoto error;\r\nerr = amdtp_stream_start(&dg00x->rx_stream,\r\ndg00x->rx_resources.channel,\r\nfw_parent_device(dg00x->unit)->max_speed);\r\nif (err < 0)\r\ngoto error;\r\nif (!amdtp_stream_wait_callback(&dg00x->rx_stream,\r\nCALLBACK_TIMEOUT)) {\r\nerr = -ETIMEDOUT;\r\ngoto error;\r\n}\r\n}\r\nif (!amdtp_stream_running(&dg00x->tx_stream)) {\r\nerr = amdtp_stream_start(&dg00x->tx_stream,\r\ndg00x->tx_resources.channel,\r\nfw_parent_device(dg00x->unit)->max_speed);\r\nif (err < 0)\r\ngoto error;\r\nif (!amdtp_stream_wait_callback(&dg00x->tx_stream,\r\nCALLBACK_TIMEOUT)) {\r\nerr = -ETIMEDOUT;\r\ngoto error;\r\n}\r\n}\r\nend:\r\nreturn err;\r\nerror:\r\nfinish_session(dg00x);\r\namdtp_stream_stop(&dg00x->tx_stream);\r\namdtp_stream_stop(&dg00x->rx_stream);\r\nrelease_resources(dg00x);\r\nreturn err;\r\n}\r\nvoid snd_dg00x_stream_stop_duplex(struct snd_dg00x *dg00x)\r\n{\r\nif (dg00x->substreams_counter > 0)\r\nreturn;\r\namdtp_stream_stop(&dg00x->tx_stream);\r\namdtp_stream_stop(&dg00x->rx_stream);\r\nfinish_session(dg00x);\r\nrelease_resources(dg00x);\r\nmsleep(50);\r\n}\r\nvoid snd_dg00x_stream_update_duplex(struct snd_dg00x *dg00x)\r\n{\r\nfw_iso_resources_update(&dg00x->tx_resources);\r\nfw_iso_resources_update(&dg00x->rx_resources);\r\namdtp_stream_update(&dg00x->tx_stream);\r\namdtp_stream_update(&dg00x->rx_stream);\r\n}\r\nvoid snd_dg00x_stream_lock_changed(struct snd_dg00x *dg00x)\r\n{\r\ndg00x->dev_lock_changed = true;\r\nwake_up(&dg00x->hwdep_wait);\r\n}\r\nint snd_dg00x_stream_lock_try(struct snd_dg00x *dg00x)\r\n{\r\nint err;\r\nspin_lock_irq(&dg00x->lock);\r\nif (dg00x->dev_lock_count < 0) {\r\nerr = -EBUSY;\r\ngoto end;\r\n}\r\nif (dg00x->dev_lock_count++ == 0)\r\nsnd_dg00x_stream_lock_changed(dg00x);\r\nerr = 0;\r\nend:\r\nspin_unlock_irq(&dg00x->lock);\r\nreturn err;\r\n}\r\nvoid snd_dg00x_stream_lock_release(struct snd_dg00x *dg00x)\r\n{\r\nspin_lock_irq(&dg00x->lock);\r\nif (WARN_ON(dg00x->dev_lock_count <= 0))\r\ngoto end;\r\nif (--dg00x->dev_lock_count == 0)\r\nsnd_dg00x_stream_lock_changed(dg00x);\r\nend:\r\nspin_unlock_irq(&dg00x->lock);\r\n}
