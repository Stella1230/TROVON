struct drm_crtc *drm_crtc_from_index(struct drm_device *dev, int idx)\r\n{\r\nstruct drm_crtc *crtc;\r\ndrm_for_each_crtc(crtc, dev)\r\nif (idx == crtc->index)\r\nreturn crtc;\r\nreturn NULL;\r\n}\r\nint drm_crtc_force_disable(struct drm_crtc *crtc)\r\n{\r\nstruct drm_mode_set set = {\r\n.crtc = crtc,\r\n};\r\nWARN_ON(drm_drv_uses_atomic_modeset(crtc->dev));\r\nreturn drm_mode_set_config_internal(&set);\r\n}\r\nint drm_crtc_force_disable_all(struct drm_device *dev)\r\n{\r\nstruct drm_crtc *crtc;\r\nint ret = 0;\r\ndrm_modeset_lock_all(dev);\r\ndrm_for_each_crtc(crtc, dev)\r\nif (crtc->enabled) {\r\nret = drm_crtc_force_disable(crtc);\r\nif (ret)\r\ngoto out;\r\n}\r\nout:\r\ndrm_modeset_unlock_all(dev);\r\nreturn ret;\r\n}\r\nstatic unsigned int drm_num_crtcs(struct drm_device *dev)\r\n{\r\nunsigned int num = 0;\r\nstruct drm_crtc *tmp;\r\ndrm_for_each_crtc(tmp, dev) {\r\nnum++;\r\n}\r\nreturn num;\r\n}\r\nint drm_crtc_register_all(struct drm_device *dev)\r\n{\r\nstruct drm_crtc *crtc;\r\nint ret = 0;\r\ndrm_for_each_crtc(crtc, dev) {\r\nif (drm_debugfs_crtc_add(crtc))\r\nDRM_ERROR("Failed to initialize debugfs entry for CRTC '%s'.\n",\r\ncrtc->name);\r\nif (crtc->funcs->late_register)\r\nret = crtc->funcs->late_register(crtc);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid drm_crtc_unregister_all(struct drm_device *dev)\r\n{\r\nstruct drm_crtc *crtc;\r\ndrm_for_each_crtc(crtc, dev) {\r\nif (crtc->funcs->early_unregister)\r\ncrtc->funcs->early_unregister(crtc);\r\ndrm_debugfs_crtc_remove(crtc);\r\n}\r\n}\r\nstatic int drm_crtc_crc_init(struct drm_crtc *crtc)\r\n{\r\n#ifdef CONFIG_DEBUG_FS\r\nspin_lock_init(&crtc->crc.lock);\r\ninit_waitqueue_head(&crtc->crc.wq);\r\ncrtc->crc.source = kstrdup("auto", GFP_KERNEL);\r\nif (!crtc->crc.source)\r\nreturn -ENOMEM;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void drm_crtc_crc_fini(struct drm_crtc *crtc)\r\n{\r\n#ifdef CONFIG_DEBUG_FS\r\nkfree(crtc->crc.source);\r\n#endif\r\n}\r\nstatic struct drm_crtc *fence_to_crtc(struct dma_fence *fence)\r\n{\r\nBUG_ON(fence->ops != &drm_crtc_fence_ops);\r\nreturn container_of(fence->lock, struct drm_crtc, fence_lock);\r\n}\r\nstatic const char *drm_crtc_fence_get_driver_name(struct dma_fence *fence)\r\n{\r\nstruct drm_crtc *crtc = fence_to_crtc(fence);\r\nreturn crtc->dev->driver->name;\r\n}\r\nstatic const char *drm_crtc_fence_get_timeline_name(struct dma_fence *fence)\r\n{\r\nstruct drm_crtc *crtc = fence_to_crtc(fence);\r\nreturn crtc->timeline_name;\r\n}\r\nstatic bool drm_crtc_fence_enable_signaling(struct dma_fence *fence)\r\n{\r\nreturn true;\r\n}\r\nstruct dma_fence *drm_crtc_create_fence(struct drm_crtc *crtc)\r\n{\r\nstruct dma_fence *fence;\r\nfence = kzalloc(sizeof(*fence), GFP_KERNEL);\r\nif (!fence)\r\nreturn NULL;\r\ndma_fence_init(fence, &drm_crtc_fence_ops, &crtc->fence_lock,\r\ncrtc->fence_context, ++crtc->fence_seqno);\r\nreturn fence;\r\n}\r\nint drm_crtc_init_with_planes(struct drm_device *dev, struct drm_crtc *crtc,\r\nstruct drm_plane *primary,\r\nstruct drm_plane *cursor,\r\nconst struct drm_crtc_funcs *funcs,\r\nconst char *name, ...)\r\n{\r\nstruct drm_mode_config *config = &dev->mode_config;\r\nint ret;\r\nWARN_ON(primary && primary->type != DRM_PLANE_TYPE_PRIMARY);\r\nWARN_ON(cursor && cursor->type != DRM_PLANE_TYPE_CURSOR);\r\ncrtc->dev = dev;\r\ncrtc->funcs = funcs;\r\nINIT_LIST_HEAD(&crtc->commit_list);\r\nspin_lock_init(&crtc->commit_lock);\r\ndrm_modeset_lock_init(&crtc->mutex);\r\nret = drm_mode_object_add(dev, &crtc->base, DRM_MODE_OBJECT_CRTC);\r\nif (ret)\r\nreturn ret;\r\nif (name) {\r\nva_list ap;\r\nva_start(ap, name);\r\ncrtc->name = kvasprintf(GFP_KERNEL, name, ap);\r\nva_end(ap);\r\n} else {\r\ncrtc->name = kasprintf(GFP_KERNEL, "crtc-%d",\r\ndrm_num_crtcs(dev));\r\n}\r\nif (!crtc->name) {\r\ndrm_mode_object_unregister(dev, &crtc->base);\r\nreturn -ENOMEM;\r\n}\r\ncrtc->fence_context = dma_fence_context_alloc(1);\r\nspin_lock_init(&crtc->fence_lock);\r\nsnprintf(crtc->timeline_name, sizeof(crtc->timeline_name),\r\n"CRTC:%d-%s", crtc->base.id, crtc->name);\r\ncrtc->base.properties = &crtc->properties;\r\nlist_add_tail(&crtc->head, &config->crtc_list);\r\ncrtc->index = config->num_crtc++;\r\ncrtc->primary = primary;\r\ncrtc->cursor = cursor;\r\nif (primary && !primary->possible_crtcs)\r\nprimary->possible_crtcs = 1 << drm_crtc_index(crtc);\r\nif (cursor && !cursor->possible_crtcs)\r\ncursor->possible_crtcs = 1 << drm_crtc_index(crtc);\r\nret = drm_crtc_crc_init(crtc);\r\nif (ret) {\r\ndrm_mode_object_unregister(dev, &crtc->base);\r\nreturn ret;\r\n}\r\nif (drm_core_check_feature(dev, DRIVER_ATOMIC)) {\r\ndrm_object_attach_property(&crtc->base, config->prop_active, 0);\r\ndrm_object_attach_property(&crtc->base, config->prop_mode_id, 0);\r\ndrm_object_attach_property(&crtc->base,\r\nconfig->prop_out_fence_ptr, 0);\r\n}\r\nreturn 0;\r\n}\r\nvoid drm_crtc_cleanup(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\ndrm_crtc_crc_fini(crtc);\r\nkfree(crtc->gamma_store);\r\ncrtc->gamma_store = NULL;\r\ndrm_modeset_lock_fini(&crtc->mutex);\r\ndrm_mode_object_unregister(dev, &crtc->base);\r\nlist_del(&crtc->head);\r\ndev->mode_config.num_crtc--;\r\nWARN_ON(crtc->state && !crtc->funcs->atomic_destroy_state);\r\nif (crtc->state && crtc->funcs->atomic_destroy_state)\r\ncrtc->funcs->atomic_destroy_state(crtc, crtc->state);\r\nkfree(crtc->name);\r\nmemset(crtc, 0, sizeof(*crtc));\r\n}\r\nint drm_mode_getcrtc(struct drm_device *dev,\r\nvoid *data, struct drm_file *file_priv)\r\n{\r\nstruct drm_mode_crtc *crtc_resp = data;\r\nstruct drm_crtc *crtc;\r\nif (!drm_core_check_feature(dev, DRIVER_MODESET))\r\nreturn -EINVAL;\r\ncrtc = drm_crtc_find(dev, crtc_resp->crtc_id);\r\nif (!crtc)\r\nreturn -ENOENT;\r\ncrtc_resp->gamma_size = crtc->gamma_size;\r\ndrm_modeset_lock(&crtc->primary->mutex, NULL);\r\nif (crtc->primary->state && crtc->primary->state->fb)\r\ncrtc_resp->fb_id = crtc->primary->state->fb->base.id;\r\nelse if (!crtc->primary->state && crtc->primary->fb)\r\ncrtc_resp->fb_id = crtc->primary->fb->base.id;\r\nelse\r\ncrtc_resp->fb_id = 0;\r\nif (crtc->primary->state) {\r\ncrtc_resp->x = crtc->primary->state->src_x >> 16;\r\ncrtc_resp->y = crtc->primary->state->src_y >> 16;\r\n}\r\ndrm_modeset_unlock(&crtc->primary->mutex);\r\ndrm_modeset_lock(&crtc->mutex, NULL);\r\nif (crtc->state) {\r\nif (crtc->state->enable) {\r\ndrm_mode_convert_to_umode(&crtc_resp->mode, &crtc->state->mode);\r\ncrtc_resp->mode_valid = 1;\r\n} else {\r\ncrtc_resp->mode_valid = 0;\r\n}\r\n} else {\r\ncrtc_resp->x = crtc->x;\r\ncrtc_resp->y = crtc->y;\r\nif (crtc->enabled) {\r\ndrm_mode_convert_to_umode(&crtc_resp->mode, &crtc->mode);\r\ncrtc_resp->mode_valid = 1;\r\n} else {\r\ncrtc_resp->mode_valid = 0;\r\n}\r\n}\r\ndrm_modeset_unlock(&crtc->mutex);\r\nreturn 0;\r\n}\r\nstatic int __drm_mode_set_config_internal(struct drm_mode_set *set,\r\nstruct drm_modeset_acquire_ctx *ctx)\r\n{\r\nstruct drm_crtc *crtc = set->crtc;\r\nstruct drm_framebuffer *fb;\r\nstruct drm_crtc *tmp;\r\nint ret;\r\ndrm_for_each_crtc(tmp, crtc->dev)\r\ntmp->primary->old_fb = tmp->primary->fb;\r\nfb = set->fb;\r\nret = crtc->funcs->set_config(set, ctx);\r\nif (ret == 0) {\r\ncrtc->primary->crtc = crtc;\r\ncrtc->primary->fb = fb;\r\n}\r\ndrm_for_each_crtc(tmp, crtc->dev) {\r\nif (tmp->primary->fb)\r\ndrm_framebuffer_get(tmp->primary->fb);\r\nif (tmp->primary->old_fb)\r\ndrm_framebuffer_put(tmp->primary->old_fb);\r\ntmp->primary->old_fb = NULL;\r\n}\r\nreturn ret;\r\n}\r\nint drm_mode_set_config_internal(struct drm_mode_set *set)\r\n{\r\nWARN_ON(drm_drv_uses_atomic_modeset(set->crtc->dev));\r\nreturn __drm_mode_set_config_internal(set, NULL);\r\n}\r\nint drm_crtc_check_viewport(const struct drm_crtc *crtc,\r\nint x, int y,\r\nconst struct drm_display_mode *mode,\r\nconst struct drm_framebuffer *fb)\r\n{\r\nint hdisplay, vdisplay;\r\ndrm_mode_get_hv_timing(mode, &hdisplay, &vdisplay);\r\nif (crtc->state &&\r\ndrm_rotation_90_or_270(crtc->primary->state->rotation))\r\nswap(hdisplay, vdisplay);\r\nreturn drm_framebuffer_check_src_coords(x << 16, y << 16,\r\nhdisplay << 16, vdisplay << 16,\r\nfb);\r\n}\r\nint drm_mode_setcrtc(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_mode_config *config = &dev->mode_config;\r\nstruct drm_mode_crtc *crtc_req = data;\r\nstruct drm_crtc *crtc;\r\nstruct drm_connector **connector_set = NULL, *connector;\r\nstruct drm_framebuffer *fb = NULL;\r\nstruct drm_display_mode *mode = NULL;\r\nstruct drm_mode_set set;\r\nuint32_t __user *set_connectors_ptr;\r\nstruct drm_modeset_acquire_ctx ctx;\r\nint ret;\r\nint i;\r\nif (!drm_core_check_feature(dev, DRIVER_MODESET))\r\nreturn -EINVAL;\r\nif (crtc_req->x & 0xffff0000 || crtc_req->y & 0xffff0000)\r\nreturn -ERANGE;\r\ncrtc = drm_crtc_find(dev, crtc_req->crtc_id);\r\nif (!crtc) {\r\nDRM_DEBUG_KMS("Unknown CRTC ID %d\n", crtc_req->crtc_id);\r\nreturn -ENOENT;\r\n}\r\nDRM_DEBUG_KMS("[CRTC:%d:%s]\n", crtc->base.id, crtc->name);\r\nmutex_lock(&crtc->dev->mode_config.mutex);\r\ndrm_modeset_acquire_init(&ctx, 0);\r\nretry:\r\nret = drm_modeset_lock_all_ctx(crtc->dev, &ctx);\r\nif (ret)\r\ngoto out;\r\nif (crtc_req->mode_valid) {\r\nif (crtc_req->fb_id == -1) {\r\nif (!crtc->primary->fb) {\r\nDRM_DEBUG_KMS("CRTC doesn't have current FB\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nfb = crtc->primary->fb;\r\ndrm_framebuffer_get(fb);\r\n} else {\r\nfb = drm_framebuffer_lookup(dev, crtc_req->fb_id);\r\nif (!fb) {\r\nDRM_DEBUG_KMS("Unknown FB ID%d\n",\r\ncrtc_req->fb_id);\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\n}\r\nmode = drm_mode_create(dev);\r\nif (!mode) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = drm_mode_convert_umode(mode, &crtc_req->mode);\r\nif (ret) {\r\nDRM_DEBUG_KMS("Invalid mode\n");\r\ngoto out;\r\n}\r\nif (!crtc->primary->format_default) {\r\nret = drm_plane_check_pixel_format(crtc->primary,\r\nfb->format->format);\r\nif (ret) {\r\nstruct drm_format_name_buf format_name;\r\nDRM_DEBUG_KMS("Invalid pixel format %s\n",\r\ndrm_get_format_name(fb->format->format,\r\n&format_name));\r\ngoto out;\r\n}\r\n}\r\nret = drm_crtc_check_viewport(crtc, crtc_req->x, crtc_req->y,\r\nmode, fb);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (crtc_req->count_connectors == 0 && mode) {\r\nDRM_DEBUG_KMS("Count connectors is 0 but mode set\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (crtc_req->count_connectors > 0 && (!mode || !fb)) {\r\nDRM_DEBUG_KMS("Count connectors is %d but no mode or fb set\n",\r\ncrtc_req->count_connectors);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (crtc_req->count_connectors > 0) {\r\nu32 out_id;\r\nif (crtc_req->count_connectors > config->num_connector) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nconnector_set = kmalloc_array(crtc_req->count_connectors,\r\nsizeof(struct drm_connector *),\r\nGFP_KERNEL);\r\nif (!connector_set) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < crtc_req->count_connectors; i++) {\r\nconnector_set[i] = NULL;\r\nset_connectors_ptr = (uint32_t __user *)(unsigned long)crtc_req->set_connectors_ptr;\r\nif (get_user(out_id, &set_connectors_ptr[i])) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nconnector = drm_connector_lookup(dev, out_id);\r\nif (!connector) {\r\nDRM_DEBUG_KMS("Connector id %d unknown\n",\r\nout_id);\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",\r\nconnector->base.id,\r\nconnector->name);\r\nconnector_set[i] = connector;\r\n}\r\n}\r\nset.crtc = crtc;\r\nset.x = crtc_req->x;\r\nset.y = crtc_req->y;\r\nset.mode = mode;\r\nset.connectors = connector_set;\r\nset.num_connectors = crtc_req->count_connectors;\r\nset.fb = fb;\r\nret = __drm_mode_set_config_internal(&set, &ctx);\r\nout:\r\nif (fb)\r\ndrm_framebuffer_put(fb);\r\nif (connector_set) {\r\nfor (i = 0; i < crtc_req->count_connectors; i++) {\r\nif (connector_set[i])\r\ndrm_connector_put(connector_set[i]);\r\n}\r\n}\r\nkfree(connector_set);\r\ndrm_mode_destroy(dev, mode);\r\nif (ret == -EDEADLK) {\r\ndrm_modeset_backoff(&ctx);\r\ngoto retry;\r\n}\r\ndrm_modeset_drop_locks(&ctx);\r\ndrm_modeset_acquire_fini(&ctx);\r\nmutex_unlock(&crtc->dev->mode_config.mutex);\r\nreturn ret;\r\n}\r\nint drm_mode_crtc_set_obj_prop(struct drm_mode_object *obj,\r\nstruct drm_property *property,\r\nuint64_t value)\r\n{\r\nint ret = -EINVAL;\r\nstruct drm_crtc *crtc = obj_to_crtc(obj);\r\nif (crtc->funcs->set_property)\r\nret = crtc->funcs->set_property(crtc, property, value);\r\nif (!ret)\r\ndrm_object_property_set_value(obj, property, value);\r\nreturn ret;\r\n}
