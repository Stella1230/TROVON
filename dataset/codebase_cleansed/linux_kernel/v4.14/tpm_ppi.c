static inline union acpi_object *\r\ntpm_eval_dsm(acpi_handle ppi_handle, int func, acpi_object_type type,\r\nunion acpi_object *argv4)\r\n{\r\nBUG_ON(!ppi_handle);\r\nreturn acpi_evaluate_dsm_typed(ppi_handle, &tpm_ppi_guid,\r\nTPM_PPI_REVISION_ID,\r\nfunc, argv4, type);\r\n}\r\nstatic ssize_t tpm_show_ppi_version(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct tpm_chip *chip = to_tpm_chip(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", chip->ppi_version);\r\n}\r\nstatic ssize_t tpm_show_ppi_request(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nssize_t size = -EINVAL;\r\nunion acpi_object *obj;\r\nstruct tpm_chip *chip = to_tpm_chip(dev);\r\nobj = tpm_eval_dsm(chip->acpi_dev_handle, TPM_PPI_FN_GETREQ,\r\nACPI_TYPE_PACKAGE, NULL);\r\nif (!obj)\r\nreturn -ENXIO;\r\nif (obj->package.count == 2 &&\r\nobj->package.elements[0].type == ACPI_TYPE_INTEGER &&\r\nobj->package.elements[1].type == ACPI_TYPE_INTEGER) {\r\nif (obj->package.elements[0].integer.value)\r\nsize = -EFAULT;\r\nelse\r\nsize = scnprintf(buf, PAGE_SIZE, "%llu\n",\r\nobj->package.elements[1].integer.value);\r\n}\r\nACPI_FREE(obj);\r\nreturn size;\r\n}\r\nstatic ssize_t tpm_store_ppi_request(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nu32 req;\r\nu64 ret;\r\nint func = TPM_PPI_FN_SUBREQ;\r\nunion acpi_object *obj, tmp;\r\nunion acpi_object argv4 = ACPI_INIT_DSM_ARGV4(1, &tmp);\r\nstruct tpm_chip *chip = to_tpm_chip(dev);\r\nif (acpi_check_dsm(chip->acpi_dev_handle, &tpm_ppi_guid,\r\nTPM_PPI_REVISION_ID, 1 << TPM_PPI_FN_SUBREQ2))\r\nfunc = TPM_PPI_FN_SUBREQ2;\r\nif (strcmp(chip->ppi_version, "1.2") < 0) {\r\nif (sscanf(buf, "%d", &req) != 1)\r\nreturn -EINVAL;\r\nargv4.type = ACPI_TYPE_BUFFER;\r\nargv4.buffer.length = sizeof(req);\r\nargv4.buffer.pointer = (u8 *)&req;\r\n} else {\r\ntmp.type = ACPI_TYPE_INTEGER;\r\nif (sscanf(buf, "%llu", &tmp.integer.value) != 1)\r\nreturn -EINVAL;\r\n}\r\nobj = tpm_eval_dsm(chip->acpi_dev_handle, func, ACPI_TYPE_INTEGER,\r\n&argv4);\r\nif (!obj) {\r\nreturn -ENXIO;\r\n} else {\r\nret = obj->integer.value;\r\nACPI_FREE(obj);\r\n}\r\nif (ret == 0)\r\nreturn (acpi_status)count;\r\nreturn (ret == 1) ? -EPERM : -EFAULT;\r\n}\r\nstatic ssize_t tpm_show_ppi_transition_action(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu32 ret;\r\nacpi_status status;\r\nunion acpi_object *obj = NULL;\r\nunion acpi_object tmp = {\r\n.buffer.type = ACPI_TYPE_BUFFER,\r\n.buffer.length = 0,\r\n.buffer.pointer = NULL\r\n};\r\nstruct tpm_chip *chip = to_tpm_chip(dev);\r\nstatic char *info[] = {\r\n"None",\r\n"Shutdown",\r\n"Reboot",\r\n"OS Vendor-specific",\r\n"Error",\r\n};\r\nif (strcmp(chip->ppi_version, "1.2") < 0)\r\nobj = &tmp;\r\nobj = tpm_eval_dsm(chip->acpi_dev_handle, TPM_PPI_FN_GETACT,\r\nACPI_TYPE_INTEGER, obj);\r\nif (!obj) {\r\nreturn -ENXIO;\r\n} else {\r\nret = obj->integer.value;\r\nACPI_FREE(obj);\r\n}\r\nif (ret < ARRAY_SIZE(info) - 1)\r\nstatus = scnprintf(buf, PAGE_SIZE, "%d: %s\n", ret, info[ret]);\r\nelse\r\nstatus = scnprintf(buf, PAGE_SIZE, "%d: %s\n", ret,\r\ninfo[ARRAY_SIZE(info)-1]);\r\nreturn status;\r\n}\r\nstatic ssize_t tpm_show_ppi_response(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nacpi_status status = -EINVAL;\r\nunion acpi_object *obj, *ret_obj;\r\nu64 req, res;\r\nstruct tpm_chip *chip = to_tpm_chip(dev);\r\nobj = tpm_eval_dsm(chip->acpi_dev_handle, TPM_PPI_FN_GETRSP,\r\nACPI_TYPE_PACKAGE, NULL);\r\nif (!obj)\r\nreturn -ENXIO;\r\nret_obj = obj->package.elements;\r\nif (obj->package.count < 3 ||\r\nret_obj[0].type != ACPI_TYPE_INTEGER ||\r\nret_obj[1].type != ACPI_TYPE_INTEGER ||\r\nret_obj[2].type != ACPI_TYPE_INTEGER)\r\ngoto cleanup;\r\nif (ret_obj[0].integer.value) {\r\nstatus = -EFAULT;\r\ngoto cleanup;\r\n}\r\nreq = ret_obj[1].integer.value;\r\nres = ret_obj[2].integer.value;\r\nif (req) {\r\nif (res == 0)\r\nstatus = scnprintf(buf, PAGE_SIZE, "%llu %s\n", req,\r\n"0: Success");\r\nelse if (res == 0xFFFFFFF0)\r\nstatus = scnprintf(buf, PAGE_SIZE, "%llu %s\n", req,\r\n"0xFFFFFFF0: User Abort");\r\nelse if (res == 0xFFFFFFF1)\r\nstatus = scnprintf(buf, PAGE_SIZE, "%llu %s\n", req,\r\n"0xFFFFFFF1: BIOS Failure");\r\nelse if (res >= 1 && res <= 0x00000FFF)\r\nstatus = scnprintf(buf, PAGE_SIZE, "%llu %llu: %s\n",\r\nreq, res, "Corresponding TPM error");\r\nelse\r\nstatus = scnprintf(buf, PAGE_SIZE, "%llu %llu: %s\n",\r\nreq, res, "Error");\r\n} else {\r\nstatus = scnprintf(buf, PAGE_SIZE, "%llu: %s\n",\r\nreq, "No Recent Request");\r\n}\r\ncleanup:\r\nACPI_FREE(obj);\r\nreturn status;\r\n}\r\nstatic ssize_t show_ppi_operations(acpi_handle dev_handle, char *buf, u32 start,\r\nu32 end)\r\n{\r\nint i;\r\nu32 ret;\r\nchar *str = buf;\r\nunion acpi_object *obj, tmp;\r\nunion acpi_object argv = ACPI_INIT_DSM_ARGV4(1, &tmp);\r\nstatic char *info[] = {\r\n"Not implemented",\r\n"BIOS only",\r\n"Blocked for OS by BIOS",\r\n"User required",\r\n"User not required",\r\n};\r\nif (!acpi_check_dsm(dev_handle, &tpm_ppi_guid, TPM_PPI_REVISION_ID,\r\n1 << TPM_PPI_FN_GETOPR))\r\nreturn -EPERM;\r\ntmp.integer.type = ACPI_TYPE_INTEGER;\r\nfor (i = start; i <= end; i++) {\r\ntmp.integer.value = i;\r\nobj = tpm_eval_dsm(dev_handle, TPM_PPI_FN_GETOPR,\r\nACPI_TYPE_INTEGER, &argv);\r\nif (!obj) {\r\nreturn -ENOMEM;\r\n} else {\r\nret = obj->integer.value;\r\nACPI_FREE(obj);\r\n}\r\nif (ret > 0 && ret < ARRAY_SIZE(info))\r\nstr += scnprintf(str, PAGE_SIZE, "%d %d: %s\n",\r\ni, ret, info[ret]);\r\n}\r\nreturn str - buf;\r\n}\r\nstatic ssize_t tpm_show_ppi_tcg_operations(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tpm_chip *chip = to_tpm_chip(dev);\r\nreturn show_ppi_operations(chip->acpi_dev_handle, buf, 0,\r\nPPI_TPM_REQ_MAX);\r\n}\r\nstatic ssize_t tpm_show_ppi_vs_operations(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tpm_chip *chip = to_tpm_chip(dev);\r\nreturn show_ppi_operations(chip->acpi_dev_handle, buf, PPI_VS_REQ_START,\r\nPPI_VS_REQ_END);\r\n}\r\nvoid tpm_add_ppi(struct tpm_chip *chip)\r\n{\r\nunion acpi_object *obj;\r\nif (!chip->acpi_dev_handle)\r\nreturn;\r\nif (!acpi_check_dsm(chip->acpi_dev_handle, &tpm_ppi_guid,\r\nTPM_PPI_REVISION_ID, 1 << TPM_PPI_FN_VERSION))\r\nreturn;\r\nobj = acpi_evaluate_dsm_typed(chip->acpi_dev_handle, &tpm_ppi_guid,\r\nTPM_PPI_REVISION_ID, TPM_PPI_FN_VERSION,\r\nNULL, ACPI_TYPE_STRING);\r\nif (obj) {\r\nstrlcpy(chip->ppi_version, obj->string.pointer,\r\nsizeof(chip->ppi_version));\r\nACPI_FREE(obj);\r\n}\r\nchip->groups[chip->groups_cnt++] = &ppi_attr_grp;\r\n}
