static u32 psb_intel_lvds_get_max_backlight(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 ret;\r\nif (gma_power_begin(dev, false)) {\r\nret = REG_READ(BLC_PWM_CTL);\r\ngma_power_end(dev);\r\n} else\r\nret = dev_priv->regs.saveBLC_PWM_CTL;\r\nret = (ret & BACKLIGHT_MODULATION_FREQ_MASK) >>\r\nBACKLIGHT_MODULATION_FREQ_SHIFT;\r\nret *= 2;\r\nif (ret == 0)\r\ndev_err(dev->dev, "BL bug: Reg %08x save %08X\n",\r\nREG_READ(BLC_PWM_CTL), dev_priv->regs.saveBLC_PWM_CTL);\r\nreturn ret;\r\n}\r\nstatic int psb_lvds_i2c_set_brightness(struct drm_device *dev,\r\nunsigned int level)\r\n{\r\nstruct drm_psb_private *dev_priv =\r\n(struct drm_psb_private *)dev->dev_private;\r\nstruct psb_intel_i2c_chan *lvds_i2c_bus = dev_priv->lvds_i2c_bus;\r\nu8 out_buf[2];\r\nunsigned int blc_i2c_brightness;\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = lvds_i2c_bus->slave_addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = out_buf,\r\n}\r\n};\r\nblc_i2c_brightness = BRIGHTNESS_MASK & ((unsigned int)level *\r\nBRIGHTNESS_MASK /\r\nBRIGHTNESS_MAX_LEVEL);\r\nif (dev_priv->lvds_bl->pol == BLC_POLARITY_INVERSE)\r\nblc_i2c_brightness = BRIGHTNESS_MASK - blc_i2c_brightness;\r\nout_buf[0] = dev_priv->lvds_bl->brightnesscmd;\r\nout_buf[1] = (u8)blc_i2c_brightness;\r\nif (i2c_transfer(&lvds_i2c_bus->adapter, msgs, 1) == 1) {\r\ndev_dbg(dev->dev, "I2C set brightness.(command, value) (%d, %d)\n",\r\ndev_priv->lvds_bl->brightnesscmd,\r\nblc_i2c_brightness);\r\nreturn 0;\r\n}\r\ndev_err(dev->dev, "I2C transfer error\n");\r\nreturn -1;\r\n}\r\nstatic int psb_lvds_pwm_set_brightness(struct drm_device *dev, int level)\r\n{\r\nstruct drm_psb_private *dev_priv =\r\n(struct drm_psb_private *)dev->dev_private;\r\nu32 max_pwm_blc;\r\nu32 blc_pwm_duty_cycle;\r\nmax_pwm_blc = psb_intel_lvds_get_max_backlight(dev);\r\nBUG_ON(max_pwm_blc == 0);\r\nblc_pwm_duty_cycle = level * max_pwm_blc / BRIGHTNESS_MAX_LEVEL;\r\nif (dev_priv->lvds_bl->pol == BLC_POLARITY_INVERSE)\r\nblc_pwm_duty_cycle = max_pwm_blc - blc_pwm_duty_cycle;\r\nblc_pwm_duty_cycle &= PSB_BACKLIGHT_PWM_POLARITY_BIT_CLEAR;\r\nREG_WRITE(BLC_PWM_CTL,\r\n(max_pwm_blc << PSB_BACKLIGHT_PWM_CTL_SHIFT) |\r\n(blc_pwm_duty_cycle));\r\ndev_info(dev->dev, "Backlight lvds set brightness %08x\n",\r\n(max_pwm_blc << PSB_BACKLIGHT_PWM_CTL_SHIFT) |\r\n(blc_pwm_duty_cycle));\r\nreturn 0;\r\n}\r\nvoid psb_intel_lvds_set_brightness(struct drm_device *dev, int level)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\ndev_dbg(dev->dev, "backlight level is %d\n", level);\r\nif (!dev_priv->lvds_bl) {\r\ndev_err(dev->dev, "NO LVDS backlight info\n");\r\nreturn;\r\n}\r\nif (dev_priv->lvds_bl->type == BLC_I2C_TYPE)\r\npsb_lvds_i2c_set_brightness(dev, level);\r\nelse\r\npsb_lvds_pwm_set_brightness(dev, level);\r\n}\r\nstatic void psb_intel_lvds_set_backlight(struct drm_device *dev, int level)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 blc_pwm_ctl;\r\nif (gma_power_begin(dev, false)) {\r\nblc_pwm_ctl = REG_READ(BLC_PWM_CTL);\r\nblc_pwm_ctl &= ~BACKLIGHT_DUTY_CYCLE_MASK;\r\nREG_WRITE(BLC_PWM_CTL,\r\n(blc_pwm_ctl |\r\n(level << BACKLIGHT_DUTY_CYCLE_SHIFT)));\r\ndev_priv->regs.saveBLC_PWM_CTL = (blc_pwm_ctl |\r\n(level << BACKLIGHT_DUTY_CYCLE_SHIFT));\r\ngma_power_end(dev);\r\n} else {\r\nblc_pwm_ctl = dev_priv->regs.saveBLC_PWM_CTL &\r\n~BACKLIGHT_DUTY_CYCLE_MASK;\r\ndev_priv->regs.saveBLC_PWM_CTL = (blc_pwm_ctl |\r\n(level << BACKLIGHT_DUTY_CYCLE_SHIFT));\r\n}\r\n}\r\nstatic void psb_intel_lvds_set_power(struct drm_device *dev, bool on)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\r\nu32 pp_status;\r\nif (!gma_power_begin(dev, true)) {\r\ndev_err(dev->dev, "set power, chip off!\n");\r\nreturn;\r\n}\r\nif (on) {\r\nREG_WRITE(PP_CONTROL, REG_READ(PP_CONTROL) |\r\nPOWER_TARGET_ON);\r\ndo {\r\npp_status = REG_READ(PP_STATUS);\r\n} while ((pp_status & PP_ON) == 0);\r\npsb_intel_lvds_set_backlight(dev,\r\nmode_dev->backlight_duty_cycle);\r\n} else {\r\npsb_intel_lvds_set_backlight(dev, 0);\r\nREG_WRITE(PP_CONTROL, REG_READ(PP_CONTROL) &\r\n~POWER_TARGET_ON);\r\ndo {\r\npp_status = REG_READ(PP_STATUS);\r\n} while (pp_status & PP_ON);\r\n}\r\ngma_power_end(dev);\r\n}\r\nstatic void psb_intel_lvds_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nif (mode == DRM_MODE_DPMS_ON)\r\npsb_intel_lvds_set_power(dev, true);\r\nelse\r\npsb_intel_lvds_set_power(dev, false);\r\n}\r\nstatic void psb_intel_lvds_save(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_psb_private *dev_priv =\r\n(struct drm_psb_private *)dev->dev_private;\r\nstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\r\nstruct psb_intel_lvds_priv *lvds_priv =\r\n(struct psb_intel_lvds_priv *)gma_encoder->dev_priv;\r\nlvds_priv->savePP_ON = REG_READ(LVDSPP_ON);\r\nlvds_priv->savePP_OFF = REG_READ(LVDSPP_OFF);\r\nlvds_priv->saveLVDS = REG_READ(LVDS);\r\nlvds_priv->savePP_CONTROL = REG_READ(PP_CONTROL);\r\nlvds_priv->savePP_CYCLE = REG_READ(PP_CYCLE);\r\nlvds_priv->saveBLC_PWM_CTL = REG_READ(BLC_PWM_CTL);\r\nlvds_priv->savePFIT_CONTROL = REG_READ(PFIT_CONTROL);\r\nlvds_priv->savePFIT_PGM_RATIOS = REG_READ(PFIT_PGM_RATIOS);\r\ndev_priv->backlight_duty_cycle = (dev_priv->regs.saveBLC_PWM_CTL &\r\nBACKLIGHT_DUTY_CYCLE_MASK);\r\nif (dev_priv->backlight_duty_cycle == 0)\r\ndev_priv->backlight_duty_cycle =\r\npsb_intel_lvds_get_max_backlight(dev);\r\ndev_dbg(dev->dev, "(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n",\r\nlvds_priv->savePP_ON,\r\nlvds_priv->savePP_OFF,\r\nlvds_priv->saveLVDS,\r\nlvds_priv->savePP_CONTROL,\r\nlvds_priv->savePP_CYCLE,\r\nlvds_priv->saveBLC_PWM_CTL);\r\n}\r\nstatic void psb_intel_lvds_restore(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nu32 pp_status;\r\nstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\r\nstruct psb_intel_lvds_priv *lvds_priv =\r\n(struct psb_intel_lvds_priv *)gma_encoder->dev_priv;\r\ndev_dbg(dev->dev, "(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n",\r\nlvds_priv->savePP_ON,\r\nlvds_priv->savePP_OFF,\r\nlvds_priv->saveLVDS,\r\nlvds_priv->savePP_CONTROL,\r\nlvds_priv->savePP_CYCLE,\r\nlvds_priv->saveBLC_PWM_CTL);\r\nREG_WRITE(BLC_PWM_CTL, lvds_priv->saveBLC_PWM_CTL);\r\nREG_WRITE(PFIT_CONTROL, lvds_priv->savePFIT_CONTROL);\r\nREG_WRITE(PFIT_PGM_RATIOS, lvds_priv->savePFIT_PGM_RATIOS);\r\nREG_WRITE(LVDSPP_ON, lvds_priv->savePP_ON);\r\nREG_WRITE(LVDSPP_OFF, lvds_priv->savePP_OFF);\r\nREG_WRITE(PP_CYCLE, lvds_priv->savePP_CYCLE);\r\nREG_WRITE(PP_CONTROL, lvds_priv->savePP_CONTROL);\r\nREG_WRITE(LVDS, lvds_priv->saveLVDS);\r\nif (lvds_priv->savePP_CONTROL & POWER_TARGET_ON) {\r\nREG_WRITE(PP_CONTROL, REG_READ(PP_CONTROL) |\r\nPOWER_TARGET_ON);\r\ndo {\r\npp_status = REG_READ(PP_STATUS);\r\n} while ((pp_status & PP_ON) == 0);\r\n} else {\r\nREG_WRITE(PP_CONTROL, REG_READ(PP_CONTROL) &\r\n~POWER_TARGET_ON);\r\ndo {\r\npp_status = REG_READ(PP_STATUS);\r\n} while (pp_status & PP_ON);\r\n}\r\n}\r\nint psb_intel_lvds_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_psb_private *dev_priv = connector->dev->dev_private;\r\nstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\r\nstruct drm_display_mode *fixed_mode =\r\ndev_priv->mode_dev.panel_fixed_mode;\r\nif (gma_encoder->type == INTEL_OUTPUT_MIPI2)\r\nfixed_mode = dev_priv->mode_dev.panel_fixed_mode2;\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nreturn MODE_NO_DBLESCAN;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nreturn MODE_NO_INTERLACE;\r\nif (fixed_mode) {\r\nif (mode->hdisplay > fixed_mode->hdisplay)\r\nreturn MODE_PANEL;\r\nif (mode->vdisplay > fixed_mode->vdisplay)\r\nreturn MODE_PANEL;\r\n}\r\nreturn MODE_OK;\r\n}\r\nbool psb_intel_lvds_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(encoder->crtc);\r\nstruct drm_encoder *tmp_encoder;\r\nstruct drm_display_mode *panel_fixed_mode = mode_dev->panel_fixed_mode;\r\nstruct gma_encoder *gma_encoder = to_gma_encoder(encoder);\r\nif (gma_encoder->type == INTEL_OUTPUT_MIPI2)\r\npanel_fixed_mode = mode_dev->panel_fixed_mode2;\r\nif (!IS_MRST(dev) && gma_crtc->pipe == 0) {\r\npr_err("Can't support LVDS on pipe A\n");\r\nreturn false;\r\n}\r\nif (IS_MRST(dev) && gma_crtc->pipe != 0) {\r\npr_err("Must use PIPE A\n");\r\nreturn false;\r\n}\r\nlist_for_each_entry(tmp_encoder, &dev->mode_config.encoder_list,\r\nhead) {\r\nif (tmp_encoder != encoder\r\n&& tmp_encoder->crtc == encoder->crtc) {\r\npr_err("Can't enable LVDS and another encoder on the same pipe\n");\r\nreturn false;\r\n}\r\n}\r\nif (panel_fixed_mode != NULL) {\r\nadjusted_mode->hdisplay = panel_fixed_mode->hdisplay;\r\nadjusted_mode->hsync_start = panel_fixed_mode->hsync_start;\r\nadjusted_mode->hsync_end = panel_fixed_mode->hsync_end;\r\nadjusted_mode->htotal = panel_fixed_mode->htotal;\r\nadjusted_mode->vdisplay = panel_fixed_mode->vdisplay;\r\nadjusted_mode->vsync_start = panel_fixed_mode->vsync_start;\r\nadjusted_mode->vsync_end = panel_fixed_mode->vsync_end;\r\nadjusted_mode->vtotal = panel_fixed_mode->vtotal;\r\nadjusted_mode->clock = panel_fixed_mode->clock;\r\ndrm_mode_set_crtcinfo(adjusted_mode,\r\nCRTC_INTERLACE_HALVE_V);\r\n}\r\nreturn true;\r\n}\r\nstatic void psb_intel_lvds_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\r\nif (!gma_power_begin(dev, true))\r\nreturn;\r\nmode_dev->saveBLC_PWM_CTL = REG_READ(BLC_PWM_CTL);\r\nmode_dev->backlight_duty_cycle = (mode_dev->saveBLC_PWM_CTL &\r\nBACKLIGHT_DUTY_CYCLE_MASK);\r\npsb_intel_lvds_set_power(dev, false);\r\ngma_power_end(dev);\r\n}\r\nstatic void psb_intel_lvds_commit(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\r\nif (mode_dev->backlight_duty_cycle == 0)\r\nmode_dev->backlight_duty_cycle =\r\npsb_intel_lvds_get_max_backlight(dev);\r\npsb_intel_lvds_set_power(dev, true);\r\n}\r\nstatic void psb_intel_lvds_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 pfit_control;\r\nif (mode->hdisplay != adjusted_mode->hdisplay ||\r\nmode->vdisplay != adjusted_mode->vdisplay)\r\npfit_control = (PFIT_ENABLE | VERT_AUTO_SCALE |\r\nHORIZ_AUTO_SCALE | VERT_INTERP_BILINEAR |\r\nHORIZ_INTERP_BILINEAR);\r\nelse\r\npfit_control = 0;\r\nif (dev_priv->lvds_dither)\r\npfit_control |= PANEL_8TO6_DITHER_ENABLE;\r\nREG_WRITE(PFIT_CONTROL, pfit_control);\r\n}\r\nstatic int psb_intel_lvds_get_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\r\nstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\r\nstruct psb_intel_lvds_priv *lvds_priv = gma_encoder->dev_priv;\r\nint ret = 0;\r\nif (!IS_MRST(dev))\r\nret = psb_intel_ddc_get_modes(connector, &lvds_priv->i2c_bus->adapter);\r\nif (ret)\r\nreturn ret;\r\nif (mode_dev->panel_fixed_mode != NULL) {\r\nstruct drm_display_mode *mode =\r\ndrm_mode_duplicate(dev, mode_dev->panel_fixed_mode);\r\ndrm_mode_probed_add(connector, mode);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid psb_intel_lvds_destroy(struct drm_connector *connector)\r\n{\r\nstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\r\nstruct psb_intel_lvds_priv *lvds_priv = gma_encoder->dev_priv;\r\npsb_intel_i2c_destroy(lvds_priv->ddc_bus);\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nint psb_intel_lvds_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t value)\r\n{\r\nstruct drm_encoder *encoder = connector->encoder;\r\nif (!encoder)\r\nreturn -1;\r\nif (!strcmp(property->name, "scaling mode")) {\r\nstruct gma_crtc *crtc = to_gma_crtc(encoder->crtc);\r\nuint64_t curval;\r\nif (!crtc)\r\ngoto set_prop_error;\r\nswitch (value) {\r\ncase DRM_MODE_SCALE_FULLSCREEN:\r\nbreak;\r\ncase DRM_MODE_SCALE_NO_SCALE:\r\nbreak;\r\ncase DRM_MODE_SCALE_ASPECT:\r\nbreak;\r\ndefault:\r\ngoto set_prop_error;\r\n}\r\nif (drm_object_property_get_value(&connector->base,\r\nproperty,\r\n&curval))\r\ngoto set_prop_error;\r\nif (curval == value)\r\ngoto set_prop_done;\r\nif (drm_object_property_set_value(&connector->base,\r\nproperty,\r\nvalue))\r\ngoto set_prop_error;\r\nif (crtc->saved_mode.hdisplay != 0 &&\r\ncrtc->saved_mode.vdisplay != 0) {\r\nif (!drm_crtc_helper_set_mode(encoder->crtc,\r\n&crtc->saved_mode,\r\nencoder->crtc->x,\r\nencoder->crtc->y,\r\nencoder->crtc->primary->fb))\r\ngoto set_prop_error;\r\n}\r\n} else if (!strcmp(property->name, "backlight")) {\r\nif (drm_object_property_set_value(&connector->base,\r\nproperty,\r\nvalue))\r\ngoto set_prop_error;\r\nelse\r\ngma_backlight_set(encoder->dev, value);\r\n} else if (!strcmp(property->name, "DPMS")) {\r\nconst struct drm_encoder_helper_funcs *hfuncs\r\n= encoder->helper_private;\r\nhfuncs->dpms(encoder, value);\r\n}\r\nset_prop_done:\r\nreturn 0;\r\nset_prop_error:\r\nreturn -1;\r\n}\r\nstatic void psb_intel_lvds_enc_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\n}\r\nvoid psb_intel_lvds_init(struct drm_device *dev,\r\nstruct psb_intel_mode_device *mode_dev)\r\n{\r\nstruct gma_encoder *gma_encoder;\r\nstruct gma_connector *gma_connector;\r\nstruct psb_intel_lvds_priv *lvds_priv;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nstruct drm_display_mode *scan;\r\nstruct drm_crtc *crtc;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 lvds;\r\nint pipe;\r\ngma_encoder = kzalloc(sizeof(struct gma_encoder), GFP_KERNEL);\r\nif (!gma_encoder) {\r\ndev_err(dev->dev, "gma_encoder allocation error\n");\r\nreturn;\r\n}\r\ngma_connector = kzalloc(sizeof(struct gma_connector), GFP_KERNEL);\r\nif (!gma_connector) {\r\ndev_err(dev->dev, "gma_connector allocation error\n");\r\ngoto failed_encoder;\r\n}\r\nlvds_priv = kzalloc(sizeof(struct psb_intel_lvds_priv), GFP_KERNEL);\r\nif (!lvds_priv) {\r\ndev_err(dev->dev, "LVDS private allocation error\n");\r\ngoto failed_connector;\r\n}\r\ngma_encoder->dev_priv = lvds_priv;\r\nconnector = &gma_connector->base;\r\ngma_connector->save = psb_intel_lvds_save;\r\ngma_connector->restore = psb_intel_lvds_restore;\r\nencoder = &gma_encoder->base;\r\ndrm_connector_init(dev, connector,\r\n&psb_intel_lvds_connector_funcs,\r\nDRM_MODE_CONNECTOR_LVDS);\r\ndrm_encoder_init(dev, encoder,\r\n&psb_intel_lvds_enc_funcs,\r\nDRM_MODE_ENCODER_LVDS, NULL);\r\ngma_connector_attach_encoder(gma_connector, gma_encoder);\r\ngma_encoder->type = INTEL_OUTPUT_LVDS;\r\ndrm_encoder_helper_add(encoder, &psb_intel_lvds_helper_funcs);\r\ndrm_connector_helper_add(connector,\r\n&psb_intel_lvds_connector_helper_funcs);\r\nconnector->display_info.subpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_FULLSCREEN);\r\ndrm_object_attach_property(&connector->base,\r\ndev_priv->backlight_property,\r\nBRIGHTNESS_MAX_LEVEL);\r\nlvds_priv->i2c_bus = psb_intel_i2c_create(dev, GPIOB, "LVDSBLC_B");\r\nif (!lvds_priv->i2c_bus) {\r\ndev_printk(KERN_ERR,\r\n&dev->pdev->dev, "I2C bus registration failed.\n");\r\ngoto failed_blc_i2c;\r\n}\r\nlvds_priv->i2c_bus->slave_addr = 0x2C;\r\ndev_priv->lvds_i2c_bus = lvds_priv->i2c_bus;\r\nlvds_priv->ddc_bus = psb_intel_i2c_create(dev, GPIOC, "LVDSDDC_C");\r\nif (!lvds_priv->ddc_bus) {\r\ndev_printk(KERN_ERR, &dev->pdev->dev,\r\n"DDC bus registration " "failed.\n");\r\ngoto failed_ddc;\r\n}\r\nmutex_lock(&dev->mode_config.mutex);\r\npsb_intel_ddc_get_modes(connector, &lvds_priv->ddc_bus->adapter);\r\nlist_for_each_entry(scan, &connector->probed_modes, head) {\r\nif (scan->type & DRM_MODE_TYPE_PREFERRED) {\r\nmode_dev->panel_fixed_mode =\r\ndrm_mode_duplicate(dev, scan);\r\nDRM_DEBUG_KMS("Using mode from DDC\n");\r\ngoto out;\r\n}\r\n}\r\nif (dev_priv->lfp_lvds_vbt_mode) {\r\nmode_dev->panel_fixed_mode =\r\ndrm_mode_duplicate(dev, dev_priv->lfp_lvds_vbt_mode);\r\nif (mode_dev->panel_fixed_mode) {\r\nmode_dev->panel_fixed_mode->type |=\r\nDRM_MODE_TYPE_PREFERRED;\r\nDRM_DEBUG_KMS("Using mode from VBT\n");\r\ngoto out;\r\n}\r\n}\r\nlvds = REG_READ(LVDS);\r\npipe = (lvds & LVDS_PIPEB_SELECT) ? 1 : 0;\r\ncrtc = psb_intel_get_crtc_from_pipe(dev, pipe);\r\nif (crtc && (lvds & LVDS_PORT_EN)) {\r\nmode_dev->panel_fixed_mode =\r\npsb_intel_crtc_mode_get(dev, crtc);\r\nif (mode_dev->panel_fixed_mode) {\r\nmode_dev->panel_fixed_mode->type |=\r\nDRM_MODE_TYPE_PREFERRED;\r\nDRM_DEBUG_KMS("Using pre-programmed mode\n");\r\ngoto out;\r\n}\r\n}\r\nif (!mode_dev->panel_fixed_mode) {\r\ndev_err(dev->dev, "Found no modes on the lvds, ignoring the LVDS\n");\r\ngoto failed_find;\r\n}\r\nout:\r\nmutex_unlock(&dev->mode_config.mutex);\r\ndrm_connector_register(connector);\r\nreturn;\r\nfailed_find:\r\nmutex_unlock(&dev->mode_config.mutex);\r\npsb_intel_i2c_destroy(lvds_priv->ddc_bus);\r\nfailed_ddc:\r\npsb_intel_i2c_destroy(lvds_priv->i2c_bus);\r\nfailed_blc_i2c:\r\ndrm_encoder_cleanup(encoder);\r\ndrm_connector_cleanup(connector);\r\nfailed_connector:\r\nkfree(gma_connector);\r\nfailed_encoder:\r\nkfree(gma_encoder);\r\n}
