static void blogic_announce_drvr(struct blogic_adapter *adapter)\r\n{\r\nblogic_announce("***** BusLogic SCSI Driver Version " blogic_drvr_version " of " blogic_drvr_date " *****\n", adapter);\r\nblogic_announce("Copyright 1995-1998 by Leonard N. Zubkoff " "<lnz@dandelion.com>\n", adapter);\r\n}\r\nstatic const char *blogic_drvr_info(struct Scsi_Host *host)\r\n{\r\nstruct blogic_adapter *adapter =\r\n(struct blogic_adapter *) host->hostdata;\r\nreturn adapter->full_model;\r\n}\r\nstatic void blogic_init_ccbs(struct blogic_adapter *adapter, void *blk_pointer,\r\nint blk_size, dma_addr_t blkp)\r\n{\r\nstruct blogic_ccb *ccb = (struct blogic_ccb *) blk_pointer;\r\nunsigned int offset = 0;\r\nmemset(blk_pointer, 0, blk_size);\r\nccb->allocgrp_head = blkp;\r\nccb->allocgrp_size = blk_size;\r\nwhile ((blk_size -= sizeof(struct blogic_ccb)) >= 0) {\r\nccb->status = BLOGIC_CCB_FREE;\r\nccb->adapter = adapter;\r\nccb->dma_handle = (u32) blkp + offset;\r\nif (blogic_flashpoint_type(adapter)) {\r\nccb->callback = blogic_qcompleted_ccb;\r\nccb->base_addr = adapter->fpinfo.base_addr;\r\n}\r\nccb->next = adapter->free_ccbs;\r\nccb->next_all = adapter->all_ccbs;\r\nadapter->free_ccbs = ccb;\r\nadapter->all_ccbs = ccb;\r\nadapter->alloc_ccbs++;\r\nccb++;\r\noffset += sizeof(struct blogic_ccb);\r\n}\r\n}\r\nstatic bool __init blogic_create_initccbs(struct blogic_adapter *adapter)\r\n{\r\nint blk_size = BLOGIC_CCB_GRP_ALLOCSIZE * sizeof(struct blogic_ccb);\r\nvoid *blk_pointer;\r\ndma_addr_t blkp;\r\nwhile (adapter->alloc_ccbs < adapter->initccbs) {\r\nblk_pointer = pci_alloc_consistent(adapter->pci_device,\r\nblk_size, &blkp);\r\nif (blk_pointer == NULL) {\r\nblogic_err("UNABLE TO ALLOCATE CCB GROUP - DETACHING\n",\r\nadapter);\r\nreturn false;\r\n}\r\nblogic_init_ccbs(adapter, blk_pointer, blk_size, blkp);\r\n}\r\nreturn true;\r\n}\r\nstatic void blogic_destroy_ccbs(struct blogic_adapter *adapter)\r\n{\r\nstruct blogic_ccb *next_ccb = adapter->all_ccbs, *ccb, *lastccb = NULL;\r\nadapter->all_ccbs = NULL;\r\nadapter->free_ccbs = NULL;\r\nwhile ((ccb = next_ccb) != NULL) {\r\nnext_ccb = ccb->next_all;\r\nif (ccb->allocgrp_head) {\r\nif (lastccb)\r\npci_free_consistent(adapter->pci_device,\r\nlastccb->allocgrp_size, lastccb,\r\nlastccb->allocgrp_head);\r\nlastccb = ccb;\r\n}\r\n}\r\nif (lastccb)\r\npci_free_consistent(adapter->pci_device, lastccb->allocgrp_size,\r\nlastccb, lastccb->allocgrp_head);\r\n}\r\nstatic void blogic_create_addlccbs(struct blogic_adapter *adapter,\r\nint addl_ccbs, bool print_success)\r\n{\r\nint blk_size = BLOGIC_CCB_GRP_ALLOCSIZE * sizeof(struct blogic_ccb);\r\nint prev_alloc = adapter->alloc_ccbs;\r\nvoid *blk_pointer;\r\ndma_addr_t blkp;\r\nif (addl_ccbs <= 0)\r\nreturn;\r\nwhile (adapter->alloc_ccbs - prev_alloc < addl_ccbs) {\r\nblk_pointer = pci_alloc_consistent(adapter->pci_device,\r\nblk_size, &blkp);\r\nif (blk_pointer == NULL)\r\nbreak;\r\nblogic_init_ccbs(adapter, blk_pointer, blk_size, blkp);\r\n}\r\nif (adapter->alloc_ccbs > prev_alloc) {\r\nif (print_success)\r\nblogic_notice("Allocated %d additional CCBs (total now %d)\n", adapter, adapter->alloc_ccbs - prev_alloc, adapter->alloc_ccbs);\r\nreturn;\r\n}\r\nblogic_notice("Failed to allocate additional CCBs\n", adapter);\r\nif (adapter->drvr_qdepth > adapter->alloc_ccbs - adapter->tgt_count) {\r\nadapter->drvr_qdepth = adapter->alloc_ccbs - adapter->tgt_count;\r\nadapter->scsi_host->can_queue = adapter->drvr_qdepth;\r\n}\r\n}\r\nstatic struct blogic_ccb *blogic_alloc_ccb(struct blogic_adapter *adapter)\r\n{\r\nstatic unsigned long serial;\r\nstruct blogic_ccb *ccb;\r\nccb = adapter->free_ccbs;\r\nif (ccb != NULL) {\r\nccb->serial = ++serial;\r\nadapter->free_ccbs = ccb->next;\r\nccb->next = NULL;\r\nif (adapter->free_ccbs == NULL)\r\nblogic_create_addlccbs(adapter, adapter->inc_ccbs,\r\ntrue);\r\nreturn ccb;\r\n}\r\nblogic_create_addlccbs(adapter, adapter->inc_ccbs, true);\r\nccb = adapter->free_ccbs;\r\nif (ccb == NULL)\r\nreturn NULL;\r\nccb->serial = ++serial;\r\nadapter->free_ccbs = ccb->next;\r\nccb->next = NULL;\r\nreturn ccb;\r\n}\r\nstatic void blogic_dealloc_ccb(struct blogic_ccb *ccb, int dma_unmap)\r\n{\r\nstruct blogic_adapter *adapter = ccb->adapter;\r\nif (ccb->command != NULL)\r\nscsi_dma_unmap(ccb->command);\r\nif (dma_unmap)\r\npci_unmap_single(adapter->pci_device, ccb->sensedata,\r\nccb->sense_datalen, PCI_DMA_FROMDEVICE);\r\nccb->command = NULL;\r\nccb->status = BLOGIC_CCB_FREE;\r\nccb->next = adapter->free_ccbs;\r\nadapter->free_ccbs = ccb;\r\n}\r\nstatic int blogic_cmd(struct blogic_adapter *adapter, enum blogic_opcode opcode,\r\nvoid *param, int paramlen, void *reply, int replylen)\r\n{\r\nunsigned char *param_p = (unsigned char *) param;\r\nunsigned char *reply_p = (unsigned char *) reply;\r\nunion blogic_stat_reg statusreg;\r\nunion blogic_int_reg intreg;\r\nunsigned long processor_flag = 0;\r\nint reply_b = 0, result;\r\nlong timeout;\r\nif (replylen > 0)\r\nmemset(reply, 0, replylen);\r\nif (!adapter->irq_acquired)\r\nlocal_irq_save(processor_flag);\r\ntimeout = 10000;\r\nwhile (--timeout >= 0) {\r\nstatusreg.all = blogic_rdstatus(adapter);\r\nif (statusreg.sr.adapter_ready && !statusreg.sr.cmd_param_busy)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (timeout < 0) {\r\nblogic_cmd_failure_reason =\r\n"Timeout waiting for Host Adapter Ready";\r\nresult = -2;\r\ngoto done;\r\n}\r\nadapter->adapter_cmd_complete = false;\r\nblogic_setcmdparam(adapter, opcode);\r\ntimeout = 10000;\r\nwhile (paramlen > 0 && --timeout >= 0) {\r\nudelay(100);\r\nintreg.all = blogic_rdint(adapter);\r\nstatusreg.all = blogic_rdstatus(adapter);\r\nif (intreg.ir.cmd_complete)\r\nbreak;\r\nif (adapter->adapter_cmd_complete)\r\nbreak;\r\nif (statusreg.sr.datain_ready)\r\nbreak;\r\nif (statusreg.sr.cmd_param_busy)\r\ncontinue;\r\nblogic_setcmdparam(adapter, *param_p++);\r\nparamlen--;\r\n}\r\nif (timeout < 0) {\r\nblogic_cmd_failure_reason =\r\n"Timeout waiting for Parameter Acceptance";\r\nresult = -2;\r\ngoto done;\r\n}\r\nif (opcode == BLOGIC_MOD_IOADDR) {\r\nstatusreg.all = blogic_rdstatus(adapter);\r\nif (statusreg.sr.cmd_invalid) {\r\nblogic_cmd_failure_reason =\r\n"Modify I/O Address Invalid";\r\nresult = -1;\r\ngoto done;\r\n}\r\nif (blogic_global_options.trace_config)\r\nblogic_notice("blogic_cmd(%02X) Status = %02X: " "(Modify I/O Address)\n", adapter, opcode, statusreg.all);\r\nresult = 0;\r\ngoto done;\r\n}\r\nswitch (opcode) {\r\ncase BLOGIC_INQ_DEV0TO7:\r\ncase BLOGIC_INQ_DEV8TO15:\r\ncase BLOGIC_INQ_DEV:\r\ntimeout = 60 * 10000;\r\nbreak;\r\ndefault:\r\ntimeout = 10000;\r\nbreak;\r\n}\r\nwhile (--timeout >= 0) {\r\nintreg.all = blogic_rdint(adapter);\r\nstatusreg.all = blogic_rdstatus(adapter);\r\nif (intreg.ir.cmd_complete)\r\nbreak;\r\nif (adapter->adapter_cmd_complete)\r\nbreak;\r\nif (statusreg.sr.datain_ready) {\r\nif (++reply_b <= replylen)\r\n*reply_p++ = blogic_rddatain(adapter);\r\nelse\r\nblogic_rddatain(adapter);\r\n}\r\nif (opcode == BLOGIC_FETCH_LOCALRAM &&\r\nstatusreg.sr.adapter_ready)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (timeout < 0) {\r\nblogic_cmd_failure_reason =\r\n"Timeout waiting for Command Complete";\r\nresult = -2;\r\ngoto done;\r\n}\r\nblogic_intreset(adapter);\r\nif (blogic_global_options.trace_config) {\r\nint i;\r\nblogic_notice("blogic_cmd(%02X) Status = %02X: %2d ==> %2d:",\r\nadapter, opcode, statusreg.all, replylen,\r\nreply_b);\r\nif (replylen > reply_b)\r\nreplylen = reply_b;\r\nfor (i = 0; i < replylen; i++)\r\nblogic_notice(" %02X", adapter,\r\n((unsigned char *) reply)[i]);\r\nblogic_notice("\n", adapter);\r\n}\r\nif (statusreg.sr.cmd_invalid) {\r\nudelay(1000);\r\nstatusreg.all = blogic_rdstatus(adapter);\r\nif (statusreg.sr.cmd_invalid || statusreg.sr.rsvd ||\r\nstatusreg.sr.datain_ready ||\r\nstatusreg.sr.cmd_param_busy ||\r\n!statusreg.sr.adapter_ready ||\r\n!statusreg.sr.init_reqd ||\r\nstatusreg.sr.diag_active ||\r\nstatusreg.sr.diag_failed) {\r\nblogic_softreset(adapter);\r\nudelay(1000);\r\n}\r\nblogic_cmd_failure_reason = "Command Invalid";\r\nresult = -1;\r\ngoto done;\r\n}\r\nif (paramlen > 0) {\r\nblogic_cmd_failure_reason = "Excess Parameters Supplied";\r\nresult = -1;\r\ngoto done;\r\n}\r\nblogic_cmd_failure_reason = NULL;\r\nresult = reply_b;\r\ndone:\r\nif (!adapter->irq_acquired)\r\nlocal_irq_restore(processor_flag);\r\nreturn result;\r\n}\r\nstatic void __init blogic_add_probeaddr_isa(unsigned long io_addr)\r\n{\r\nstruct blogic_probeinfo *probeinfo;\r\nif (blogic_probeinfo_count >= BLOGIC_MAX_ADAPTERS)\r\nreturn;\r\nprobeinfo = &blogic_probeinfo_list[blogic_probeinfo_count++];\r\nprobeinfo->adapter_type = BLOGIC_MULTIMASTER;\r\nprobeinfo->adapter_bus_type = BLOGIC_ISA_BUS;\r\nprobeinfo->io_addr = io_addr;\r\nprobeinfo->pci_device = NULL;\r\n}\r\nstatic void __init blogic_init_probeinfo_isa(struct blogic_adapter *adapter)\r\n{\r\nif (blogic_probe_options.noprobe_isa)\r\nreturn;\r\nif (!blogic_probe_options.limited_isa || blogic_probe_options.probe330)\r\nblogic_add_probeaddr_isa(0x330);\r\nif (!blogic_probe_options.limited_isa || blogic_probe_options.probe334)\r\nblogic_add_probeaddr_isa(0x334);\r\nif (!blogic_probe_options.limited_isa || blogic_probe_options.probe230)\r\nblogic_add_probeaddr_isa(0x230);\r\nif (!blogic_probe_options.limited_isa || blogic_probe_options.probe234)\r\nblogic_add_probeaddr_isa(0x234);\r\nif (!blogic_probe_options.limited_isa || blogic_probe_options.probe130)\r\nblogic_add_probeaddr_isa(0x130);\r\nif (!blogic_probe_options.limited_isa || blogic_probe_options.probe134)\r\nblogic_add_probeaddr_isa(0x134);\r\n}\r\nstatic void __init blogic_sort_probeinfo(struct blogic_probeinfo\r\n*probeinfo_list, int probeinfo_cnt)\r\n{\r\nint last_exchange = probeinfo_cnt - 1, bound, j;\r\nwhile (last_exchange > 0) {\r\nbound = last_exchange;\r\nlast_exchange = 0;\r\nfor (j = 0; j < bound; j++) {\r\nstruct blogic_probeinfo *probeinfo1 =\r\n&probeinfo_list[j];\r\nstruct blogic_probeinfo *probeinfo2 =\r\n&probeinfo_list[j + 1];\r\nif (probeinfo1->bus > probeinfo2->bus ||\r\n(probeinfo1->bus == probeinfo2->bus &&\r\n(probeinfo1->dev > probeinfo2->dev))) {\r\nstruct blogic_probeinfo tmp_probeinfo;\r\nmemcpy(&tmp_probeinfo, probeinfo1,\r\nsizeof(struct blogic_probeinfo));\r\nmemcpy(probeinfo1, probeinfo2,\r\nsizeof(struct blogic_probeinfo));\r\nmemcpy(probeinfo2, &tmp_probeinfo,\r\nsizeof(struct blogic_probeinfo));\r\nlast_exchange = j;\r\n}\r\n}\r\n}\r\n}\r\nstatic int __init blogic_init_mm_probeinfo(struct blogic_adapter *adapter)\r\n{\r\nstruct blogic_probeinfo *pr_probeinfo =\r\n&blogic_probeinfo_list[blogic_probeinfo_count];\r\nint nonpr_mmindex = blogic_probeinfo_count + 1;\r\nint nonpr_mmcount = 0, mmcount = 0;\r\nbool force_scan_order = false;\r\nbool force_scan_order_checked = false;\r\nbool addr_seen[6];\r\nstruct pci_dev *pci_device = NULL;\r\nint i;\r\nif (blogic_probeinfo_count >= BLOGIC_MAX_ADAPTERS)\r\nreturn 0;\r\nblogic_probeinfo_count++;\r\nfor (i = 0; i < 6; i++)\r\naddr_seen[i] = false;\r\npr_probeinfo->io_addr = 0;\r\nwhile ((pci_device = pci_get_device(PCI_VENDOR_ID_BUSLOGIC,\r\nPCI_DEVICE_ID_BUSLOGIC_MULTIMASTER,\r\npci_device)) != NULL) {\r\nstruct blogic_adapter *host_adapter = adapter;\r\nstruct blogic_adapter_info adapter_info;\r\nenum blogic_isa_ioport mod_ioaddr_req;\r\nunsigned char bus;\r\nunsigned char device;\r\nunsigned int irq_ch;\r\nunsigned long base_addr0;\r\nunsigned long base_addr1;\r\nunsigned long io_addr;\r\nunsigned long pci_addr;\r\nif (pci_enable_device(pci_device))\r\ncontinue;\r\nif (pci_set_dma_mask(pci_device, DMA_BIT_MASK(32)))\r\ncontinue;\r\nbus = pci_device->bus->number;\r\ndevice = pci_device->devfn >> 3;\r\nirq_ch = pci_device->irq;\r\nio_addr = base_addr0 = pci_resource_start(pci_device, 0);\r\npci_addr = base_addr1 = pci_resource_start(pci_device, 1);\r\nif (pci_resource_flags(pci_device, 0) & IORESOURCE_MEM) {\r\nblogic_err("BusLogic: Base Address0 0x%X not I/O for " "MultiMaster Host Adapter\n", NULL, base_addr0);\r\nblogic_err("at PCI Bus %d Device %d I/O Address 0x%X\n", NULL, bus, device, io_addr);\r\ncontinue;\r\n}\r\nif (pci_resource_flags(pci_device, 1) & IORESOURCE_IO) {\r\nblogic_err("BusLogic: Base Address1 0x%X not Memory for " "MultiMaster Host Adapter\n", NULL, base_addr1);\r\nblogic_err("at PCI Bus %d Device %d PCI Address 0x%X\n", NULL, bus, device, pci_addr);\r\ncontinue;\r\n}\r\nif (irq_ch == 0) {\r\nblogic_err("BusLogic: IRQ Channel %d invalid for " "MultiMaster Host Adapter\n", NULL, irq_ch);\r\nblogic_err("at PCI Bus %d Device %d I/O Address 0x%X\n", NULL, bus, device, io_addr);\r\ncontinue;\r\n}\r\nif (blogic_global_options.trace_probe) {\r\nblogic_notice("BusLogic: PCI MultiMaster Host Adapter " "detected at\n", NULL);\r\nblogic_notice("BusLogic: PCI Bus %d Device %d I/O Address " "0x%X PCI Address 0x%X\n", NULL, bus, device, io_addr, pci_addr);\r\n}\r\nhost_adapter->io_addr = io_addr;\r\nblogic_intreset(host_adapter);\r\nif (blogic_cmd(host_adapter, BLOGIC_INQ_PCI_INFO, NULL, 0,\r\n&adapter_info, sizeof(adapter_info)) ==\r\nsizeof(adapter_info)) {\r\nif (adapter_info.isa_port < 6)\r\naddr_seen[adapter_info.isa_port] = true;\r\n} else\r\nadapter_info.isa_port = BLOGIC_IO_DISABLE;\r\nmod_ioaddr_req = BLOGIC_IO_DISABLE;\r\nblogic_cmd(host_adapter, BLOGIC_MOD_IOADDR, &mod_ioaddr_req,\r\nsizeof(mod_ioaddr_req), NULL, 0);\r\nif (!force_scan_order_checked) {\r\nstruct blogic_fetch_localram fetch_localram;\r\nstruct blogic_autoscsi_byte45 autoscsi_byte45;\r\nstruct blogic_board_id id;\r\nfetch_localram.offset = BLOGIC_AUTOSCSI_BASE + 45;\r\nfetch_localram.count = sizeof(autoscsi_byte45);\r\nblogic_cmd(host_adapter, BLOGIC_FETCH_LOCALRAM,\r\n&fetch_localram, sizeof(fetch_localram),\r\n&autoscsi_byte45,\r\nsizeof(autoscsi_byte45));\r\nblogic_cmd(host_adapter, BLOGIC_GET_BOARD_ID, NULL, 0,\r\n&id, sizeof(id));\r\nif (id.fw_ver_digit1 == '5')\r\nforce_scan_order =\r\nautoscsi_byte45.force_scan_order;\r\nforce_scan_order_checked = true;\r\n}\r\nif (adapter_info.isa_port == BLOGIC_IO_330) {\r\npr_probeinfo->adapter_type = BLOGIC_MULTIMASTER;\r\npr_probeinfo->adapter_bus_type = BLOGIC_PCI_BUS;\r\npr_probeinfo->io_addr = io_addr;\r\npr_probeinfo->pci_addr = pci_addr;\r\npr_probeinfo->bus = bus;\r\npr_probeinfo->dev = device;\r\npr_probeinfo->irq_ch = irq_ch;\r\npr_probeinfo->pci_device = pci_dev_get(pci_device);\r\nmmcount++;\r\n} else if (blogic_probeinfo_count < BLOGIC_MAX_ADAPTERS) {\r\nstruct blogic_probeinfo *probeinfo =\r\n&blogic_probeinfo_list[blogic_probeinfo_count++];\r\nprobeinfo->adapter_type = BLOGIC_MULTIMASTER;\r\nprobeinfo->adapter_bus_type = BLOGIC_PCI_BUS;\r\nprobeinfo->io_addr = io_addr;\r\nprobeinfo->pci_addr = pci_addr;\r\nprobeinfo->bus = bus;\r\nprobeinfo->dev = device;\r\nprobeinfo->irq_ch = irq_ch;\r\nprobeinfo->pci_device = pci_dev_get(pci_device);\r\nnonpr_mmcount++;\r\nmmcount++;\r\n} else\r\nblogic_warn("BusLogic: Too many Host Adapters " "detected\n", NULL);\r\n}\r\nif (force_scan_order)\r\nblogic_sort_probeinfo(&blogic_probeinfo_list[nonpr_mmindex],\r\nnonpr_mmcount);\r\nif (!blogic_probe_options.noprobe_isa)\r\nif (pr_probeinfo->io_addr == 0 &&\r\n(!blogic_probe_options.limited_isa ||\r\nblogic_probe_options.probe330)) {\r\npr_probeinfo->adapter_type = BLOGIC_MULTIMASTER;\r\npr_probeinfo->adapter_bus_type = BLOGIC_ISA_BUS;\r\npr_probeinfo->io_addr = 0x330;\r\n}\r\nif (!blogic_probe_options.noprobe_isa) {\r\nif (!addr_seen[1] &&\r\n(!blogic_probe_options.limited_isa ||\r\nblogic_probe_options.probe334))\r\nblogic_add_probeaddr_isa(0x334);\r\nif (!addr_seen[2] &&\r\n(!blogic_probe_options.limited_isa ||\r\nblogic_probe_options.probe230))\r\nblogic_add_probeaddr_isa(0x230);\r\nif (!addr_seen[3] &&\r\n(!blogic_probe_options.limited_isa ||\r\nblogic_probe_options.probe234))\r\nblogic_add_probeaddr_isa(0x234);\r\nif (!addr_seen[4] &&\r\n(!blogic_probe_options.limited_isa ||\r\nblogic_probe_options.probe130))\r\nblogic_add_probeaddr_isa(0x130);\r\nif (!addr_seen[5] &&\r\n(!blogic_probe_options.limited_isa ||\r\nblogic_probe_options.probe134))\r\nblogic_add_probeaddr_isa(0x134);\r\n}\r\npci_device = NULL;\r\nwhile ((pci_device = pci_get_device(PCI_VENDOR_ID_BUSLOGIC,\r\nPCI_DEVICE_ID_BUSLOGIC_MULTIMASTER_NC,\r\npci_device)) != NULL) {\r\nunsigned char bus;\r\nunsigned char device;\r\nunsigned int irq_ch;\r\nunsigned long io_addr;\r\nif (pci_enable_device(pci_device))\r\ncontinue;\r\nif (pci_set_dma_mask(pci_device, DMA_BIT_MASK(32)))\r\ncontinue;\r\nbus = pci_device->bus->number;\r\ndevice = pci_device->devfn >> 3;\r\nirq_ch = pci_device->irq;\r\nio_addr = pci_resource_start(pci_device, 0);\r\nif (io_addr == 0 || irq_ch == 0)\r\ncontinue;\r\nfor (i = 0; i < blogic_probeinfo_count; i++) {\r\nstruct blogic_probeinfo *probeinfo =\r\n&blogic_probeinfo_list[i];\r\nif (probeinfo->io_addr == io_addr &&\r\nprobeinfo->adapter_type == BLOGIC_MULTIMASTER) {\r\nprobeinfo->adapter_bus_type = BLOGIC_PCI_BUS;\r\nprobeinfo->pci_addr = 0;\r\nprobeinfo->bus = bus;\r\nprobeinfo->dev = device;\r\nprobeinfo->irq_ch = irq_ch;\r\nprobeinfo->pci_device = pci_dev_get(pci_device);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn mmcount;\r\n}\r\nstatic int __init blogic_init_fp_probeinfo(struct blogic_adapter *adapter)\r\n{\r\nint fpindex = blogic_probeinfo_count, fpcount = 0;\r\nstruct pci_dev *pci_device = NULL;\r\nwhile ((pci_device = pci_get_device(PCI_VENDOR_ID_BUSLOGIC,\r\nPCI_DEVICE_ID_BUSLOGIC_FLASHPOINT,\r\npci_device)) != NULL) {\r\nunsigned char bus;\r\nunsigned char device;\r\nunsigned int irq_ch;\r\nunsigned long base_addr0;\r\nunsigned long base_addr1;\r\nunsigned long io_addr;\r\nunsigned long pci_addr;\r\nif (pci_enable_device(pci_device))\r\ncontinue;\r\nif (pci_set_dma_mask(pci_device, DMA_BIT_MASK(32)))\r\ncontinue;\r\nbus = pci_device->bus->number;\r\ndevice = pci_device->devfn >> 3;\r\nirq_ch = pci_device->irq;\r\nio_addr = base_addr0 = pci_resource_start(pci_device, 0);\r\npci_addr = base_addr1 = pci_resource_start(pci_device, 1);\r\n#ifdef CONFIG_SCSI_FLASHPOINT\r\nif (pci_resource_flags(pci_device, 0) & IORESOURCE_MEM) {\r\nblogic_err("BusLogic: Base Address0 0x%X not I/O for " "FlashPoint Host Adapter\n", NULL, base_addr0);\r\nblogic_err("at PCI Bus %d Device %d I/O Address 0x%X\n", NULL, bus, device, io_addr);\r\ncontinue;\r\n}\r\nif (pci_resource_flags(pci_device, 1) & IORESOURCE_IO) {\r\nblogic_err("BusLogic: Base Address1 0x%X not Memory for " "FlashPoint Host Adapter\n", NULL, base_addr1);\r\nblogic_err("at PCI Bus %d Device %d PCI Address 0x%X\n", NULL, bus, device, pci_addr);\r\ncontinue;\r\n}\r\nif (irq_ch == 0) {\r\nblogic_err("BusLogic: IRQ Channel %d invalid for " "FlashPoint Host Adapter\n", NULL, irq_ch);\r\nblogic_err("at PCI Bus %d Device %d I/O Address 0x%X\n", NULL, bus, device, io_addr);\r\ncontinue;\r\n}\r\nif (blogic_global_options.trace_probe) {\r\nblogic_notice("BusLogic: FlashPoint Host Adapter " "detected at\n", NULL);\r\nblogic_notice("BusLogic: PCI Bus %d Device %d I/O Address " "0x%X PCI Address 0x%X\n", NULL, bus, device, io_addr, pci_addr);\r\n}\r\nif (blogic_probeinfo_count < BLOGIC_MAX_ADAPTERS) {\r\nstruct blogic_probeinfo *probeinfo =\r\n&blogic_probeinfo_list[blogic_probeinfo_count++];\r\nprobeinfo->adapter_type = BLOGIC_FLASHPOINT;\r\nprobeinfo->adapter_bus_type = BLOGIC_PCI_BUS;\r\nprobeinfo->io_addr = io_addr;\r\nprobeinfo->pci_addr = pci_addr;\r\nprobeinfo->bus = bus;\r\nprobeinfo->dev = device;\r\nprobeinfo->irq_ch = irq_ch;\r\nprobeinfo->pci_device = pci_dev_get(pci_device);\r\nfpcount++;\r\n} else\r\nblogic_warn("BusLogic: Too many Host Adapters " "detected\n", NULL);\r\n#else\r\nblogic_err("BusLogic: FlashPoint Host Adapter detected at " "PCI Bus %d Device %d\n", NULL, bus, device);\r\nblogic_err("BusLogic: I/O Address 0x%X PCI Address 0x%X, irq %d, " "but FlashPoint\n", NULL, io_addr, pci_addr, irq_ch);\r\nblogic_err("BusLogic: support was omitted in this kernel " "configuration.\n", NULL);\r\n#endif\r\n}\r\nblogic_sort_probeinfo(&blogic_probeinfo_list[fpindex], fpcount);\r\nreturn fpcount;\r\n}\r\nstatic void __init blogic_init_probeinfo_list(struct blogic_adapter *adapter)\r\n{\r\nif (!blogic_probe_options.noprobe_pci) {\r\nif (blogic_probe_options.multimaster_first) {\r\nblogic_init_mm_probeinfo(adapter);\r\nblogic_init_fp_probeinfo(adapter);\r\n} else if (blogic_probe_options.flashpoint_first) {\r\nblogic_init_fp_probeinfo(adapter);\r\nblogic_init_mm_probeinfo(adapter);\r\n} else {\r\nint fpcount = blogic_init_fp_probeinfo(adapter);\r\nint mmcount = blogic_init_mm_probeinfo(adapter);\r\nif (fpcount > 0 && mmcount > 0) {\r\nstruct blogic_probeinfo *probeinfo =\r\n&blogic_probeinfo_list[fpcount];\r\nstruct blogic_adapter *myadapter = adapter;\r\nstruct blogic_fetch_localram fetch_localram;\r\nstruct blogic_bios_drvmap d0_mapbyte;\r\nwhile (probeinfo->adapter_bus_type !=\r\nBLOGIC_PCI_BUS)\r\nprobeinfo++;\r\nmyadapter->io_addr = probeinfo->io_addr;\r\nfetch_localram.offset =\r\nBLOGIC_BIOS_BASE + BLOGIC_BIOS_DRVMAP;\r\nfetch_localram.count = sizeof(d0_mapbyte);\r\nblogic_cmd(myadapter, BLOGIC_FETCH_LOCALRAM,\r\n&fetch_localram,\r\nsizeof(fetch_localram),\r\n&d0_mapbyte,\r\nsizeof(d0_mapbyte));\r\nif (d0_mapbyte.diskgeom != BLOGIC_BIOS_NODISK) {\r\nstruct blogic_probeinfo saved_probeinfo[BLOGIC_MAX_ADAPTERS];\r\nint mmcount = blogic_probeinfo_count - fpcount;\r\nmemcpy(saved_probeinfo,\r\nblogic_probeinfo_list,\r\nblogic_probeinfo_count * sizeof(struct blogic_probeinfo));\r\nmemcpy(&blogic_probeinfo_list[0],\r\n&saved_probeinfo[fpcount],\r\nmmcount * sizeof(struct blogic_probeinfo));\r\nmemcpy(&blogic_probeinfo_list[mmcount],\r\n&saved_probeinfo[0],\r\nfpcount * sizeof(struct blogic_probeinfo));\r\n}\r\n}\r\n}\r\n} else {\r\nblogic_init_probeinfo_isa(adapter);\r\n}\r\n}\r\nstatic bool blogic_failure(struct blogic_adapter *adapter, char *msg)\r\n{\r\nblogic_announce_drvr(adapter);\r\nif (adapter->adapter_bus_type == BLOGIC_PCI_BUS) {\r\nblogic_err("While configuring BusLogic PCI Host Adapter at\n",\r\nadapter);\r\nblogic_err("Bus %d Device %d I/O Address 0x%X PCI Address 0x%X:\n", adapter, adapter->bus, adapter->dev, adapter->io_addr, adapter->pci_addr);\r\n} else\r\nblogic_err("While configuring BusLogic Host Adapter at " "I/O Address 0x%X:\n", adapter, adapter->io_addr);\r\nblogic_err("%s FAILED - DETACHING\n", adapter, msg);\r\nif (blogic_cmd_failure_reason != NULL)\r\nblogic_err("ADDITIONAL FAILURE INFO - %s\n", adapter,\r\nblogic_cmd_failure_reason);\r\nreturn false;\r\n}\r\nstatic bool __init blogic_probe(struct blogic_adapter *adapter)\r\n{\r\nunion blogic_stat_reg statusreg;\r\nunion blogic_int_reg intreg;\r\nunion blogic_geo_reg georeg;\r\nif (blogic_flashpoint_type(adapter)) {\r\nstruct fpoint_info *fpinfo = &adapter->fpinfo;\r\nfpinfo->base_addr = (u32) adapter->io_addr;\r\nfpinfo->irq_ch = adapter->irq_ch;\r\nfpinfo->present = false;\r\nif (!(FlashPoint_ProbeHostAdapter(fpinfo) == 0 &&\r\nfpinfo->present)) {\r\nblogic_err("BusLogic: FlashPoint Host Adapter detected at " "PCI Bus %d Device %d\n", adapter, adapter->bus, adapter->dev);\r\nblogic_err("BusLogic: I/O Address 0x%X PCI Address 0x%X, " "but FlashPoint\n", adapter, adapter->io_addr, adapter->pci_addr);\r\nblogic_err("BusLogic: Probe Function failed to validate it.\n", adapter);\r\nreturn false;\r\n}\r\nif (blogic_global_options.trace_probe)\r\nblogic_notice("BusLogic_Probe(0x%X): FlashPoint Found\n", adapter, adapter->io_addr);\r\nreturn true;\r\n}\r\nstatusreg.all = blogic_rdstatus(adapter);\r\nintreg.all = blogic_rdint(adapter);\r\ngeoreg.all = blogic_rdgeom(adapter);\r\nif (blogic_global_options.trace_probe)\r\nblogic_notice("BusLogic_Probe(0x%X): Status 0x%02X, Interrupt 0x%02X, " "Geometry 0x%02X\n", adapter, adapter->io_addr, statusreg.all, intreg.all, georeg.all);\r\nif (statusreg.all == 0 || statusreg.sr.diag_active ||\r\nstatusreg.sr.cmd_param_busy || statusreg.sr.rsvd ||\r\nstatusreg.sr.cmd_invalid || intreg.ir.rsvd != 0)\r\nreturn false;\r\nif (georeg.all == 0xFF)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool blogic_hwreset(struct blogic_adapter *adapter, bool hard_reset)\r\n{\r\nunion blogic_stat_reg statusreg;\r\nint timeout;\r\nif (blogic_flashpoint_type(adapter)) {\r\nstruct fpoint_info *fpinfo = &adapter->fpinfo;\r\nfpinfo->softreset = !hard_reset;\r\nfpinfo->report_underrun = true;\r\nadapter->cardhandle =\r\nFlashPoint_HardwareResetHostAdapter(fpinfo);\r\nif (adapter->cardhandle == (void *)FPOINT_BADCARD_HANDLE)\r\nreturn false;\r\nreturn true;\r\n}\r\nif (hard_reset)\r\nblogic_hardreset(adapter);\r\nelse\r\nblogic_softreset(adapter);\r\ntimeout = 5 * 10000;\r\nwhile (--timeout >= 0) {\r\nstatusreg.all = blogic_rdstatus(adapter);\r\nif (statusreg.sr.diag_active)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (blogic_global_options.trace_hw_reset)\r\nblogic_notice("BusLogic_HardwareReset(0x%X): Diagnostic Active, " "Status 0x%02X\n", adapter, adapter->io_addr, statusreg.all);\r\nif (timeout < 0)\r\nreturn false;\r\nudelay(100);\r\ntimeout = 10 * 10000;\r\nwhile (--timeout >= 0) {\r\nstatusreg.all = blogic_rdstatus(adapter);\r\nif (!statusreg.sr.diag_active)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (blogic_global_options.trace_hw_reset)\r\nblogic_notice("BusLogic_HardwareReset(0x%X): Diagnostic Completed, " "Status 0x%02X\n", adapter, adapter->io_addr, statusreg.all);\r\nif (timeout < 0)\r\nreturn false;\r\ntimeout = 10000;\r\nwhile (--timeout >= 0) {\r\nstatusreg.all = blogic_rdstatus(adapter);\r\nif (statusreg.sr.diag_failed || statusreg.sr.adapter_ready ||\r\nstatusreg.sr.datain_ready)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (blogic_global_options.trace_hw_reset)\r\nblogic_notice("BusLogic_HardwareReset(0x%X): Host Adapter Ready, " "Status 0x%02X\n", adapter, adapter->io_addr, statusreg.all);\r\nif (timeout < 0)\r\nreturn false;\r\nif (statusreg.sr.diag_failed || !statusreg.sr.adapter_ready) {\r\nblogic_cmd_failure_reason = NULL;\r\nblogic_failure(adapter, "HARD RESET DIAGNOSTICS");\r\nblogic_err("HOST ADAPTER STATUS REGISTER = %02X\n", adapter,\r\nstatusreg.all);\r\nif (statusreg.sr.datain_ready)\r\nblogic_err("HOST ADAPTER ERROR CODE = %d\n", adapter,\r\nblogic_rddatain(adapter));\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool __init blogic_checkadapter(struct blogic_adapter *adapter)\r\n{\r\nstruct blogic_ext_setup ext_setupinfo;\r\nunsigned char req_replylen;\r\nbool result = true;\r\nif (blogic_flashpoint_type(adapter))\r\nreturn true;\r\nreq_replylen = sizeof(ext_setupinfo);\r\nif (blogic_cmd(adapter, BLOGIC_INQ_EXTSETUP, &req_replylen,\r\nsizeof(req_replylen), &ext_setupinfo,\r\nsizeof(ext_setupinfo)) != sizeof(ext_setupinfo))\r\nresult = false;\r\nif (blogic_global_options.trace_probe)\r\nblogic_notice("BusLogic_Check(0x%X): MultiMaster %s\n", adapter,\r\nadapter->io_addr,\r\n(result ? "Found" : "Not Found"));\r\nreturn result;\r\n}\r\nstatic bool __init blogic_rdconfig(struct blogic_adapter *adapter)\r\n{\r\nstruct blogic_board_id id;\r\nstruct blogic_config config;\r\nstruct blogic_setup_info setupinfo;\r\nstruct blogic_ext_setup ext_setupinfo;\r\nunsigned char model[5];\r\nunsigned char fw_ver_digit3;\r\nunsigned char fw_ver_letter;\r\nstruct blogic_adapter_info adapter_info;\r\nstruct blogic_fetch_localram fetch_localram;\r\nstruct blogic_autoscsi autoscsi;\r\nunion blogic_geo_reg georeg;\r\nunsigned char req_replylen;\r\nunsigned char *tgt, ch;\r\nint tgt_id, i;\r\nif (blogic_flashpoint_type(adapter)) {\r\nstruct fpoint_info *fpinfo = &adapter->fpinfo;\r\ntgt = adapter->model;\r\n*tgt++ = 'B';\r\n*tgt++ = 'T';\r\n*tgt++ = '-';\r\nfor (i = 0; i < sizeof(fpinfo->model); i++)\r\n*tgt++ = fpinfo->model[i];\r\n*tgt++ = '\0';\r\nstrcpy(adapter->fw_ver, FLASHPOINT_FW_VER);\r\nadapter->scsi_id = fpinfo->scsi_id;\r\nadapter->ext_trans_enable = fpinfo->ext_trans_enable;\r\nadapter->parity = fpinfo->parity;\r\nadapter->reset_enabled = !fpinfo->softreset;\r\nadapter->level_int = true;\r\nadapter->wide = fpinfo->wide;\r\nadapter->differential = false;\r\nadapter->scam = true;\r\nadapter->ultra = true;\r\nadapter->ext_lun = true;\r\nadapter->terminfo_valid = true;\r\nadapter->low_term = fpinfo->low_term;\r\nadapter->high_term = fpinfo->high_term;\r\nadapter->scam_enabled = fpinfo->scam_enabled;\r\nadapter->scam_lev2 = fpinfo->scam_lev2;\r\nadapter->drvr_sglimit = BLOGIC_SG_LIMIT;\r\nadapter->maxdev = (adapter->wide ? 16 : 8);\r\nadapter->maxlun = 32;\r\nadapter->initccbs = 4 * BLOGIC_CCB_GRP_ALLOCSIZE;\r\nadapter->inc_ccbs = BLOGIC_CCB_GRP_ALLOCSIZE;\r\nadapter->drvr_qdepth = 255;\r\nadapter->adapter_qdepth = adapter->drvr_qdepth;\r\nadapter->sync_ok = fpinfo->sync_ok;\r\nadapter->fast_ok = fpinfo->fast_ok;\r\nadapter->ultra_ok = fpinfo->ultra_ok;\r\nadapter->wide_ok = fpinfo->wide_ok;\r\nadapter->discon_ok = fpinfo->discon_ok;\r\nadapter->tagq_ok = 0xFFFF;\r\ngoto common;\r\n}\r\nif (blogic_cmd(adapter, BLOGIC_GET_BOARD_ID, NULL, 0, &id,\r\nsizeof(id)) != sizeof(id))\r\nreturn blogic_failure(adapter, "INQUIRE BOARD ID");\r\nif (blogic_cmd(adapter, BLOGIC_INQ_CONFIG, NULL, 0, &config,\r\nsizeof(config))\r\n!= sizeof(config))\r\nreturn blogic_failure(adapter, "INQUIRE CONFIGURATION");\r\nreq_replylen = sizeof(setupinfo);\r\nif (blogic_cmd(adapter, BLOGIC_INQ_SETUPINFO, &req_replylen,\r\nsizeof(req_replylen), &setupinfo,\r\nsizeof(setupinfo)) != sizeof(setupinfo))\r\nreturn blogic_failure(adapter, "INQUIRE SETUP INFORMATION");\r\nreq_replylen = sizeof(ext_setupinfo);\r\nif (blogic_cmd(adapter, BLOGIC_INQ_EXTSETUP, &req_replylen,\r\nsizeof(req_replylen), &ext_setupinfo,\r\nsizeof(ext_setupinfo)) != sizeof(ext_setupinfo))\r\nreturn blogic_failure(adapter,\r\n"INQUIRE EXTENDED SETUP INFORMATION");\r\nfw_ver_digit3 = '\0';\r\nif (id.fw_ver_digit1 > '0')\r\nif (blogic_cmd(adapter, BLOGIC_INQ_FWVER_D3, NULL, 0,\r\n&fw_ver_digit3,\r\nsizeof(fw_ver_digit3)) != sizeof(fw_ver_digit3))\r\nreturn blogic_failure(adapter,\r\n"INQUIRE FIRMWARE 3RD DIGIT");\r\nif (ext_setupinfo.bus_type == 'A' && id.fw_ver_digit1 == '2')\r\nstrcpy(model, "542B");\r\nelse if (ext_setupinfo.bus_type == 'E' && id.fw_ver_digit1 == '2' &&\r\n(id.fw_ver_digit2 <= '1' || (id.fw_ver_digit2 == '2' &&\r\nfw_ver_digit3 == '0')))\r\nstrcpy(model, "742A");\r\nelse if (ext_setupinfo.bus_type == 'E' && id.fw_ver_digit1 == '0')\r\nstrcpy(model, "747A");\r\nelse {\r\nreq_replylen = sizeof(model);\r\nif (blogic_cmd(adapter, BLOGIC_INQ_MODELNO, &req_replylen,\r\nsizeof(req_replylen), &model,\r\nsizeof(model)) != sizeof(model))\r\nreturn blogic_failure(adapter,\r\n"INQUIRE HOST ADAPTER MODEL NUMBER");\r\n}\r\ntgt = adapter->model;\r\n*tgt++ = 'B';\r\n*tgt++ = 'T';\r\n*tgt++ = '-';\r\nfor (i = 0; i < sizeof(model); i++) {\r\nch = model[i];\r\nif (ch == ' ' || ch == '\0')\r\nbreak;\r\n*tgt++ = ch;\r\n}\r\n*tgt++ = '\0';\r\ntgt = adapter->fw_ver;\r\n*tgt++ = id.fw_ver_digit1;\r\n*tgt++ = '.';\r\n*tgt++ = id.fw_ver_digit2;\r\nif (fw_ver_digit3 != ' ' && fw_ver_digit3 != '\0')\r\n*tgt++ = fw_ver_digit3;\r\n*tgt = '\0';\r\nif (strcmp(adapter->fw_ver, "3.3") >= 0) {\r\nif (blogic_cmd(adapter, BLOGIC_INQ_FWVER_LETTER, NULL, 0,\r\n&fw_ver_letter,\r\nsizeof(fw_ver_letter)) != sizeof(fw_ver_letter))\r\nreturn blogic_failure(adapter,\r\n"INQUIRE FIRMWARE VERSION LETTER");\r\nif (fw_ver_letter != ' ' && fw_ver_letter != '\0')\r\n*tgt++ = fw_ver_letter;\r\n*tgt = '\0';\r\n}\r\nadapter->scsi_id = config.id;\r\nadapter->adapter_bus_type =\r\nblogic_adater_bus_types[adapter->model[3] - '4'];\r\nif (adapter->irq_ch == 0) {\r\nif (config.irq_ch9)\r\nadapter->irq_ch = 9;\r\nelse if (config.irq_ch10)\r\nadapter->irq_ch = 10;\r\nelse if (config.irq_ch11)\r\nadapter->irq_ch = 11;\r\nelse if (config.irq_ch12)\r\nadapter->irq_ch = 12;\r\nelse if (config.irq_ch14)\r\nadapter->irq_ch = 14;\r\nelse if (config.irq_ch15)\r\nadapter->irq_ch = 15;\r\n}\r\nif (adapter->adapter_bus_type == BLOGIC_ISA_BUS) {\r\nif (config.dma_ch5)\r\nadapter->dma_ch = 5;\r\nelse if (config.dma_ch6)\r\nadapter->dma_ch = 6;\r\nelse if (config.dma_ch7)\r\nadapter->dma_ch = 7;\r\n}\r\ngeoreg.all = blogic_rdgeom(adapter);\r\nadapter->ext_trans_enable = georeg.gr.ext_trans_enable;\r\nadapter->adapter_sglimit = ext_setupinfo.sg_limit;\r\nadapter->drvr_sglimit = adapter->adapter_sglimit;\r\nif (adapter->adapter_sglimit > BLOGIC_SG_LIMIT)\r\nadapter->drvr_sglimit = BLOGIC_SG_LIMIT;\r\nif (ext_setupinfo.misc.level_int)\r\nadapter->level_int = true;\r\nadapter->wide = ext_setupinfo.wide;\r\nadapter->differential = ext_setupinfo.differential;\r\nadapter->scam = ext_setupinfo.scam;\r\nadapter->ultra = ext_setupinfo.ultra;\r\nif (adapter->fw_ver[0] == '5' || (adapter->fw_ver[0] == '4' &&\r\nadapter->wide))\r\nadapter->ext_lun = true;\r\nif (adapter->fw_ver[0] == '5') {\r\nif (blogic_cmd(adapter, BLOGIC_INQ_PCI_INFO, NULL, 0,\r\n&adapter_info,\r\nsizeof(adapter_info)) != sizeof(adapter_info))\r\nreturn blogic_failure(adapter,\r\n"INQUIRE PCI HOST ADAPTER INFORMATION");\r\nif (adapter_info.genericinfo_valid) {\r\nadapter->terminfo_valid = true;\r\nadapter->low_term = adapter_info.low_term;\r\nadapter->high_term = adapter_info.high_term;\r\n}\r\n}\r\nif (adapter->fw_ver[0] >= '4') {\r\nfetch_localram.offset = BLOGIC_AUTOSCSI_BASE;\r\nfetch_localram.count = sizeof(autoscsi);\r\nif (blogic_cmd(adapter, BLOGIC_FETCH_LOCALRAM, &fetch_localram,\r\nsizeof(fetch_localram), &autoscsi,\r\nsizeof(autoscsi)) != sizeof(autoscsi))\r\nreturn blogic_failure(adapter,\r\n"FETCH HOST ADAPTER LOCAL RAM");\r\nadapter->parity = autoscsi.parity;\r\nadapter->reset_enabled = autoscsi.reset_enabled;\r\nif (adapter->fw_ver[0] == '4') {\r\nadapter->terminfo_valid = true;\r\nadapter->low_term = autoscsi.low_term;\r\nadapter->high_term = autoscsi.high_term;\r\n}\r\nadapter->wide_ok = autoscsi.wide_ok;\r\nadapter->fast_ok = autoscsi.fast_ok;\r\nadapter->sync_ok = autoscsi.sync_ok;\r\nadapter->discon_ok = autoscsi.discon_ok;\r\nif (adapter->ultra)\r\nadapter->ultra_ok = autoscsi.ultra_ok;\r\nif (adapter->scam) {\r\nadapter->scam_enabled = autoscsi.scam_enabled;\r\nadapter->scam_lev2 = autoscsi.scam_lev2;\r\n}\r\n}\r\nif (adapter->fw_ver[0] < '4') {\r\nif (setupinfo.sync) {\r\nadapter->sync_ok = 0xFF;\r\nif (adapter->adapter_bus_type == BLOGIC_EISA_BUS) {\r\nif (ext_setupinfo.misc.fast_on_eisa)\r\nadapter->fast_ok = 0xFF;\r\nif (strcmp(adapter->model, "BT-757") == 0)\r\nadapter->wide_ok = 0xFF;\r\n}\r\n}\r\nadapter->discon_ok = 0xFF;\r\nadapter->parity = setupinfo.parity;\r\nadapter->reset_enabled = true;\r\n}\r\nadapter->maxdev = (adapter->wide ? 16 : 8);\r\nadapter->maxlun = (adapter->ext_lun ? 32 : 8);\r\nif (adapter->fw_ver[0] == '5')\r\nadapter->adapter_qdepth = 192;\r\nelse if (adapter->fw_ver[0] == '4')\r\nadapter->adapter_qdepth = (adapter->adapter_bus_type !=\r\nBLOGIC_ISA_BUS ? 100 : 50);\r\nelse\r\nadapter->adapter_qdepth = 30;\r\nif (strcmp(adapter->fw_ver, "3.31") >= 0) {\r\nadapter->strict_rr = true;\r\nadapter->mbox_count = BLOGIC_MAX_MAILBOX;\r\n} else {\r\nadapter->strict_rr = false;\r\nadapter->mbox_count = 32;\r\n}\r\nadapter->drvr_qdepth = adapter->mbox_count;\r\nadapter->initccbs = 4 * BLOGIC_CCB_GRP_ALLOCSIZE;\r\nadapter->inc_ccbs = BLOGIC_CCB_GRP_ALLOCSIZE;\r\nadapter->tagq_ok = 0;\r\nswitch (adapter->fw_ver[0]) {\r\ncase '5':\r\nadapter->tagq_ok = 0xFFFF;\r\nbreak;\r\ncase '4':\r\nif (strcmp(adapter->fw_ver, "4.22") >= 0)\r\nadapter->tagq_ok = 0xFFFF;\r\nbreak;\r\ncase '3':\r\nif (strcmp(adapter->fw_ver, "3.35") >= 0)\r\nadapter->tagq_ok = 0xFFFF;\r\nbreak;\r\n}\r\nadapter->bios_addr = ext_setupinfo.bios_addr << 12;\r\nif (adapter->adapter_bus_type == BLOGIC_ISA_BUS &&\r\n(void *) high_memory > (void *) MAX_DMA_ADDRESS)\r\nadapter->need_bouncebuf = true;\r\nif (adapter->bios_addr > 0 && strcmp(adapter->model, "BT-445S") == 0 &&\r\nstrcmp(adapter->fw_ver, "3.37") < 0 &&\r\n(void *) high_memory > (void *) MAX_DMA_ADDRESS)\r\nadapter->need_bouncebuf = true;\r\ncommon:\r\nstrcpy(adapter->full_model, "BusLogic ");\r\nstrcat(adapter->full_model, adapter->model);\r\nfor (tgt_id = 0; tgt_id < BLOGIC_MAXDEV; tgt_id++) {\r\nunsigned char qdepth = 0;\r\nif (adapter->drvr_opts != NULL &&\r\nadapter->drvr_opts->qdepth[tgt_id] > 0)\r\nqdepth = adapter->drvr_opts->qdepth[tgt_id];\r\nelse if (adapter->need_bouncebuf)\r\nqdepth = BLOGIC_TAG_DEPTH_BB;\r\nadapter->qdepth[tgt_id] = qdepth;\r\n}\r\nif (adapter->need_bouncebuf)\r\nadapter->untag_qdepth = BLOGIC_UNTAG_DEPTH_BB;\r\nelse\r\nadapter->untag_qdepth = BLOGIC_UNTAG_DEPTH;\r\nif (adapter->drvr_opts != NULL)\r\nadapter->common_qdepth = adapter->drvr_opts->common_qdepth;\r\nif (adapter->common_qdepth > 0 &&\r\nadapter->common_qdepth < adapter->untag_qdepth)\r\nadapter->untag_qdepth = adapter->common_qdepth;\r\nadapter->tagq_ok &= adapter->discon_ok;\r\nif (adapter->drvr_opts != NULL)\r\nadapter->tagq_ok = (adapter->drvr_opts->tagq_ok &\r\nadapter->drvr_opts->tagq_ok_mask) |\r\n(adapter->tagq_ok & ~adapter->drvr_opts->tagq_ok_mask);\r\nif (adapter->drvr_opts != NULL &&\r\nadapter->drvr_opts->bus_settle_time > 0)\r\nadapter->bus_settle_time = adapter->drvr_opts->bus_settle_time;\r\nelse\r\nadapter->bus_settle_time = BLOGIC_BUS_SETTLE_TIME;\r\nreturn true;\r\n}\r\nstatic bool __init blogic_reportconfig(struct blogic_adapter *adapter)\r\n{\r\nunsigned short alltgt_mask = (1 << adapter->maxdev) - 1;\r\nunsigned short sync_ok, fast_ok;\r\nunsigned short ultra_ok, wide_ok;\r\nunsigned short discon_ok, tagq_ok;\r\nbool common_syncneg, common_tagq_depth;\r\nchar syncstr[BLOGIC_MAXDEV + 1];\r\nchar widestr[BLOGIC_MAXDEV + 1];\r\nchar discon_str[BLOGIC_MAXDEV + 1];\r\nchar tagq_str[BLOGIC_MAXDEV + 1];\r\nchar *syncmsg = syncstr;\r\nchar *widemsg = widestr;\r\nchar *discon_msg = discon_str;\r\nchar *tagq_msg = tagq_str;\r\nint tgt_id;\r\nblogic_info("Configuring BusLogic Model %s %s%s%s%s SCSI Host Adapter\n", adapter, adapter->model, blogic_adapter_busnames[adapter->adapter_bus_type], (adapter->wide ? " Wide" : ""), (adapter->differential ? " Differential" : ""), (adapter->ultra ? " Ultra" : ""));\r\nblogic_info(" Firmware Version: %s, I/O Address: 0x%X, " "IRQ Channel: %d/%s\n", adapter, adapter->fw_ver, adapter->io_addr, adapter->irq_ch, (adapter->level_int ? "Level" : "Edge"));\r\nif (adapter->adapter_bus_type != BLOGIC_PCI_BUS) {\r\nblogic_info(" DMA Channel: ", adapter);\r\nif (adapter->dma_ch > 0)\r\nblogic_info("%d, ", adapter, adapter->dma_ch);\r\nelse\r\nblogic_info("None, ", adapter);\r\nif (adapter->bios_addr > 0)\r\nblogic_info("BIOS Address: 0x%X, ", adapter,\r\nadapter->bios_addr);\r\nelse\r\nblogic_info("BIOS Address: None, ", adapter);\r\n} else {\r\nblogic_info(" PCI Bus: %d, Device: %d, Address: ", adapter,\r\nadapter->bus, adapter->dev);\r\nif (adapter->pci_addr > 0)\r\nblogic_info("0x%X, ", adapter, adapter->pci_addr);\r\nelse\r\nblogic_info("Unassigned, ", adapter);\r\n}\r\nblogic_info("Host Adapter SCSI ID: %d\n", adapter, adapter->scsi_id);\r\nblogic_info(" Parity Checking: %s, Extended Translation: %s\n",\r\nadapter, (adapter->parity ? "Enabled" : "Disabled"),\r\n(adapter->ext_trans_enable ? "Enabled" : "Disabled"));\r\nalltgt_mask &= ~(1 << adapter->scsi_id);\r\nsync_ok = adapter->sync_ok & alltgt_mask;\r\nfast_ok = adapter->fast_ok & alltgt_mask;\r\nultra_ok = adapter->ultra_ok & alltgt_mask;\r\nif ((blogic_multimaster_type(adapter) &&\r\n(adapter->fw_ver[0] >= '4' ||\r\nadapter->adapter_bus_type == BLOGIC_EISA_BUS)) ||\r\nblogic_flashpoint_type(adapter)) {\r\ncommon_syncneg = false;\r\nif (sync_ok == 0) {\r\nsyncmsg = "Disabled";\r\ncommon_syncneg = true;\r\n} else if (sync_ok == alltgt_mask) {\r\nif (fast_ok == 0) {\r\nsyncmsg = "Slow";\r\ncommon_syncneg = true;\r\n} else if (fast_ok == alltgt_mask) {\r\nif (ultra_ok == 0) {\r\nsyncmsg = "Fast";\r\ncommon_syncneg = true;\r\n} else if (ultra_ok == alltgt_mask) {\r\nsyncmsg = "Ultra";\r\ncommon_syncneg = true;\r\n}\r\n}\r\n}\r\nif (!common_syncneg) {\r\nfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\r\nsyncstr[tgt_id] = ((!(sync_ok & (1 << tgt_id))) ? 'N' : (!(fast_ok & (1 << tgt_id)) ? 'S' : (!(ultra_ok & (1 << tgt_id)) ? 'F' : 'U')));\r\nsyncstr[adapter->scsi_id] = '#';\r\nsyncstr[adapter->maxdev] = '\0';\r\n}\r\n} else\r\nsyncmsg = (sync_ok == 0 ? "Disabled" : "Enabled");\r\nwide_ok = adapter->wide_ok & alltgt_mask;\r\nif (wide_ok == 0)\r\nwidemsg = "Disabled";\r\nelse if (wide_ok == alltgt_mask)\r\nwidemsg = "Enabled";\r\nelse {\r\nfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\r\nwidestr[tgt_id] = ((wide_ok & (1 << tgt_id)) ? 'Y' : 'N');\r\nwidestr[adapter->scsi_id] = '#';\r\nwidestr[adapter->maxdev] = '\0';\r\n}\r\ndiscon_ok = adapter->discon_ok & alltgt_mask;\r\nif (discon_ok == 0)\r\ndiscon_msg = "Disabled";\r\nelse if (discon_ok == alltgt_mask)\r\ndiscon_msg = "Enabled";\r\nelse {\r\nfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\r\ndiscon_str[tgt_id] = ((discon_ok & (1 << tgt_id)) ? 'Y' : 'N');\r\ndiscon_str[adapter->scsi_id] = '#';\r\ndiscon_str[adapter->maxdev] = '\0';\r\n}\r\ntagq_ok = adapter->tagq_ok & alltgt_mask;\r\nif (tagq_ok == 0)\r\ntagq_msg = "Disabled";\r\nelse if (tagq_ok == alltgt_mask)\r\ntagq_msg = "Enabled";\r\nelse {\r\nfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\r\ntagq_str[tgt_id] = ((tagq_ok & (1 << tgt_id)) ? 'Y' : 'N');\r\ntagq_str[adapter->scsi_id] = '#';\r\ntagq_str[adapter->maxdev] = '\0';\r\n}\r\nblogic_info(" Synchronous Negotiation: %s, Wide Negotiation: %s\n",\r\nadapter, syncmsg, widemsg);\r\nblogic_info(" Disconnect/Reconnect: %s, Tagged Queuing: %s\n", adapter,\r\ndiscon_msg, tagq_msg);\r\nif (blogic_multimaster_type(adapter)) {\r\nblogic_info(" Scatter/Gather Limit: %d of %d segments, " "Mailboxes: %d\n", adapter, adapter->drvr_sglimit, adapter->adapter_sglimit, adapter->mbox_count);\r\nblogic_info(" Driver Queue Depth: %d, " "Host Adapter Queue Depth: %d\n", adapter, adapter->drvr_qdepth, adapter->adapter_qdepth);\r\n} else\r\nblogic_info(" Driver Queue Depth: %d, " "Scatter/Gather Limit: %d segments\n", adapter, adapter->drvr_qdepth, adapter->drvr_sglimit);\r\nblogic_info(" Tagged Queue Depth: ", adapter);\r\ncommon_tagq_depth = true;\r\nfor (tgt_id = 1; tgt_id < adapter->maxdev; tgt_id++)\r\nif (adapter->qdepth[tgt_id] != adapter->qdepth[0]) {\r\ncommon_tagq_depth = false;\r\nbreak;\r\n}\r\nif (common_tagq_depth) {\r\nif (adapter->qdepth[0] > 0)\r\nblogic_info("%d", adapter, adapter->qdepth[0]);\r\nelse\r\nblogic_info("Automatic", adapter);\r\n} else\r\nblogic_info("Individual", adapter);\r\nblogic_info(", Untagged Queue Depth: %d\n", adapter,\r\nadapter->untag_qdepth);\r\nif (adapter->terminfo_valid) {\r\nif (adapter->wide)\r\nblogic_info(" SCSI Bus Termination: %s", adapter,\r\n(adapter->low_term ? (adapter->high_term ? "Both Enabled" : "Low Enabled") : (adapter->high_term ? "High Enabled" : "Both Disabled")));\r\nelse\r\nblogic_info(" SCSI Bus Termination: %s", adapter,\r\n(adapter->low_term ? "Enabled" : "Disabled"));\r\nif (adapter->scam)\r\nblogic_info(", SCAM: %s", adapter,\r\n(adapter->scam_enabled ? (adapter->scam_lev2 ? "Enabled, Level 2" : "Enabled, Level 1") : "Disabled"));\r\nblogic_info("\n", adapter);\r\n}\r\nreturn true;\r\n}\r\nstatic bool __init blogic_getres(struct blogic_adapter *adapter)\r\n{\r\nif (adapter->irq_ch == 0) {\r\nblogic_err("NO LEGAL INTERRUPT CHANNEL ASSIGNED - DETACHING\n",\r\nadapter);\r\nreturn false;\r\n}\r\nif (request_irq(adapter->irq_ch, blogic_inthandler, IRQF_SHARED,\r\nadapter->full_model, adapter) < 0) {\r\nblogic_err("UNABLE TO ACQUIRE IRQ CHANNEL %d - DETACHING\n",\r\nadapter, adapter->irq_ch);\r\nreturn false;\r\n}\r\nadapter->irq_acquired = true;\r\nif (adapter->dma_ch > 0) {\r\nif (request_dma(adapter->dma_ch, adapter->full_model) < 0) {\r\nblogic_err("UNABLE TO ACQUIRE DMA CHANNEL %d - DETACHING\n", adapter, adapter->dma_ch);\r\nreturn false;\r\n}\r\nset_dma_mode(adapter->dma_ch, DMA_MODE_CASCADE);\r\nenable_dma(adapter->dma_ch);\r\nadapter->dma_chan_acquired = true;\r\n}\r\nreturn true;\r\n}\r\nstatic void blogic_relres(struct blogic_adapter *adapter)\r\n{\r\nif (adapter->irq_acquired)\r\nfree_irq(adapter->irq_ch, adapter);\r\nif (adapter->dma_chan_acquired)\r\nfree_dma(adapter->dma_ch);\r\nif (adapter->mbox_space)\r\npci_free_consistent(adapter->pci_device, adapter->mbox_sz,\r\nadapter->mbox_space, adapter->mbox_space_handle);\r\npci_dev_put(adapter->pci_device);\r\nadapter->mbox_space = NULL;\r\nadapter->mbox_space_handle = 0;\r\nadapter->mbox_sz = 0;\r\n}\r\nstatic bool blogic_initadapter(struct blogic_adapter *adapter)\r\n{\r\nstruct blogic_extmbox_req extmbox_req;\r\nenum blogic_rr_req rr_req;\r\nenum blogic_setccb_fmt setccb_fmt;\r\nint tgt_id;\r\nadapter->firstccb = NULL;\r\nadapter->lastccb = NULL;\r\nfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++) {\r\nadapter->bdr_pend[tgt_id] = NULL;\r\nadapter->tgt_flags[tgt_id].tagq_active = false;\r\nadapter->tgt_flags[tgt_id].cmd_good = false;\r\nadapter->active_cmds[tgt_id] = 0;\r\nadapter->cmds_since_rst[tgt_id] = 0;\r\n}\r\nif (blogic_flashpoint_type(adapter))\r\ngoto done;\r\nadapter->mbox_sz = adapter->mbox_count * (sizeof(struct blogic_outbox) + sizeof(struct blogic_inbox));\r\nadapter->mbox_space = pci_alloc_consistent(adapter->pci_device,\r\nadapter->mbox_sz, &adapter->mbox_space_handle);\r\nif (adapter->mbox_space == NULL)\r\nreturn blogic_failure(adapter, "MAILBOX ALLOCATION");\r\nadapter->first_outbox = (struct blogic_outbox *) adapter->mbox_space;\r\nadapter->last_outbox = adapter->first_outbox + adapter->mbox_count - 1;\r\nadapter->next_outbox = adapter->first_outbox;\r\nadapter->first_inbox = (struct blogic_inbox *) (adapter->last_outbox + 1);\r\nadapter->last_inbox = adapter->first_inbox + adapter->mbox_count - 1;\r\nadapter->next_inbox = adapter->first_inbox;\r\nmemset(adapter->first_outbox, 0,\r\nadapter->mbox_count * sizeof(struct blogic_outbox));\r\nmemset(adapter->first_inbox, 0,\r\nadapter->mbox_count * sizeof(struct blogic_inbox));\r\nextmbox_req.mbox_count = adapter->mbox_count;\r\nextmbox_req.base_mbox_addr = (u32) adapter->mbox_space_handle;\r\nif (blogic_cmd(adapter, BLOGIC_INIT_EXT_MBOX, &extmbox_req,\r\nsizeof(extmbox_req), NULL, 0) < 0)\r\nreturn blogic_failure(adapter, "MAILBOX INITIALIZATION");\r\nif (adapter->strict_rr) {\r\nrr_req = BLOGIC_STRICT_RR_MODE;\r\nif (blogic_cmd(adapter, BLOGIC_STRICT_RR, &rr_req,\r\nsizeof(rr_req), NULL, 0) < 0)\r\nreturn blogic_failure(adapter,\r\n"ENABLE STRICT ROUND ROBIN MODE");\r\n}\r\nif (adapter->ext_lun) {\r\nsetccb_fmt = BLOGIC_EXT_LUN_CCB;\r\nif (blogic_cmd(adapter, BLOGIC_SETCCB_FMT, &setccb_fmt,\r\nsizeof(setccb_fmt), NULL, 0) < 0)\r\nreturn blogic_failure(adapter, "SET CCB FORMAT");\r\n}\r\ndone:\r\nif (!adapter->adapter_initd) {\r\nblogic_info("*** %s Initialized Successfully ***\n", adapter,\r\nadapter->full_model);\r\nblogic_info("\n", adapter);\r\n} else\r\nblogic_warn("*** %s Initialized Successfully ***\n", adapter,\r\nadapter->full_model);\r\nadapter->adapter_initd = true;\r\nreturn true;\r\n}\r\nstatic bool __init blogic_inquiry(struct blogic_adapter *adapter)\r\n{\r\nu16 installed_devs;\r\nu8 installed_devs0to7[8];\r\nstruct blogic_setup_info setupinfo;\r\nu8 sync_period[BLOGIC_MAXDEV];\r\nunsigned char req_replylen;\r\nint tgt_id;\r\nblogic_delay(adapter->bus_settle_time);\r\nif (blogic_flashpoint_type(adapter))\r\nreturn true;\r\nif (adapter->drvr_opts != NULL && adapter->drvr_opts->stop_tgt_inquiry)\r\nreturn true;\r\nif (strcmp(adapter->fw_ver, "4.25") >= 0) {\r\nif (blogic_cmd(adapter, BLOGIC_INQ_DEV, NULL, 0,\r\n&installed_devs, sizeof(installed_devs))\r\n!= sizeof(installed_devs))\r\nreturn blogic_failure(adapter, "INQUIRE TARGET DEVICES");\r\nfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\r\nadapter->tgt_flags[tgt_id].tgt_exists =\r\n(installed_devs & (1 << tgt_id) ? true : false);\r\n} else {\r\nif (blogic_cmd(adapter, BLOGIC_INQ_DEV0TO7, NULL, 0,\r\n&installed_devs0to7, sizeof(installed_devs0to7))\r\n!= sizeof(installed_devs0to7))\r\nreturn blogic_failure(adapter,\r\n"INQUIRE INSTALLED DEVICES ID 0 TO 7");\r\nfor (tgt_id = 0; tgt_id < 8; tgt_id++)\r\nadapter->tgt_flags[tgt_id].tgt_exists =\r\n(installed_devs0to7[tgt_id] != 0 ? true : false);\r\n}\r\nreq_replylen = sizeof(setupinfo);\r\nif (blogic_cmd(adapter, BLOGIC_INQ_SETUPINFO, &req_replylen,\r\nsizeof(req_replylen), &setupinfo, sizeof(setupinfo))\r\n!= sizeof(setupinfo))\r\nreturn blogic_failure(adapter, "INQUIRE SETUP INFORMATION");\r\nfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\r\nadapter->sync_offset[tgt_id] = (tgt_id < 8 ? setupinfo.sync0to7[tgt_id].offset : setupinfo.sync8to15[tgt_id - 8].offset);\r\nif (strcmp(adapter->fw_ver, "5.06L") >= 0)\r\nfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\r\nadapter->tgt_flags[tgt_id].wide_active = (tgt_id < 8 ? (setupinfo.wide_tx_active0to7 & (1 << tgt_id) ? true : false) : (setupinfo.wide_tx_active8to15 & (1 << (tgt_id - 8)) ? true : false));\r\nif (adapter->fw_ver[0] >= '3') {\r\nreq_replylen = sizeof(sync_period);\r\nif (blogic_cmd(adapter, BLOGIC_INQ_SYNC_PERIOD, &req_replylen,\r\nsizeof(req_replylen), &sync_period,\r\nsizeof(sync_period)) != sizeof(sync_period))\r\nreturn blogic_failure(adapter,\r\n"INQUIRE SYNCHRONOUS PERIOD");\r\nfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\r\nadapter->sync_period[tgt_id] = sync_period[tgt_id];\r\n} else\r\nfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\r\nif (setupinfo.sync0to7[tgt_id].offset > 0)\r\nadapter->sync_period[tgt_id] = 20 + 5 * setupinfo.sync0to7[tgt_id].tx_period;\r\nreturn true;\r\n}\r\nstatic void __init blogic_inithoststruct(struct blogic_adapter *adapter,\r\nstruct Scsi_Host *host)\r\n{\r\nhost->max_id = adapter->maxdev;\r\nhost->max_lun = adapter->maxlun;\r\nhost->max_channel = 0;\r\nhost->unique_id = adapter->io_addr;\r\nhost->this_id = adapter->scsi_id;\r\nhost->can_queue = adapter->drvr_qdepth;\r\nhost->sg_tablesize = adapter->drvr_sglimit;\r\nhost->unchecked_isa_dma = adapter->need_bouncebuf;\r\nhost->cmd_per_lun = adapter->untag_qdepth;\r\n}\r\nstatic int blogic_slaveconfig(struct scsi_device *dev)\r\n{\r\nstruct blogic_adapter *adapter =\r\n(struct blogic_adapter *) dev->host->hostdata;\r\nint tgt_id = dev->id;\r\nint qdepth = adapter->qdepth[tgt_id];\r\nif (adapter->tgt_flags[tgt_id].tagq_ok &&\r\n(adapter->tagq_ok & (1 << tgt_id))) {\r\nif (qdepth == 0)\r\nqdepth = BLOGIC_MAX_AUTO_TAG_DEPTH;\r\nadapter->qdepth[tgt_id] = qdepth;\r\nscsi_change_queue_depth(dev, qdepth);\r\n} else {\r\nadapter->tagq_ok &= ~(1 << tgt_id);\r\nqdepth = adapter->untag_qdepth;\r\nadapter->qdepth[tgt_id] = qdepth;\r\nscsi_change_queue_depth(dev, qdepth);\r\n}\r\nqdepth = 0;\r\nfor (tgt_id = 0; tgt_id < adapter->maxdev; tgt_id++)\r\nif (adapter->tgt_flags[tgt_id].tgt_exists)\r\nqdepth += adapter->qdepth[tgt_id];\r\nif (qdepth > adapter->alloc_ccbs)\r\nblogic_create_addlccbs(adapter, qdepth - adapter->alloc_ccbs,\r\nfalse);\r\nreturn 0;\r\n}\r\nstatic int __init blogic_init(void)\r\n{\r\nint adapter_count = 0, drvr_optindex = 0, probeindex;\r\nstruct blogic_adapter *adapter;\r\nint ret = 0;\r\n#ifdef MODULE\r\nif (BusLogic)\r\nblogic_setup(BusLogic);\r\n#endif\r\nif (blogic_probe_options.noprobe)\r\nreturn -ENODEV;\r\nblogic_probeinfo_list =\r\nkzalloc(BLOGIC_MAX_ADAPTERS * sizeof(struct blogic_probeinfo),\r\nGFP_KERNEL);\r\nif (blogic_probeinfo_list == NULL) {\r\nblogic_err("BusLogic: Unable to allocate Probe Info List\n",\r\nNULL);\r\nreturn -ENOMEM;\r\n}\r\nadapter = kzalloc(sizeof(struct blogic_adapter), GFP_KERNEL);\r\nif (adapter == NULL) {\r\nkfree(blogic_probeinfo_list);\r\nblogic_err("BusLogic: Unable to allocate Prototype Host Adapter\n", NULL);\r\nreturn -ENOMEM;\r\n}\r\n#ifdef MODULE\r\nif (BusLogic != NULL)\r\nblogic_setup(BusLogic);\r\n#endif\r\nblogic_init_probeinfo_list(adapter);\r\nfor (probeindex = 0; probeindex < blogic_probeinfo_count; probeindex++) {\r\nstruct blogic_probeinfo *probeinfo =\r\n&blogic_probeinfo_list[probeindex];\r\nstruct blogic_adapter *myadapter = adapter;\r\nstruct Scsi_Host *host;\r\nif (probeinfo->io_addr == 0)\r\ncontinue;\r\nmemset(myadapter, 0, sizeof(struct blogic_adapter));\r\nmyadapter->adapter_type = probeinfo->adapter_type;\r\nmyadapter->adapter_bus_type = probeinfo->adapter_bus_type;\r\nmyadapter->io_addr = probeinfo->io_addr;\r\nmyadapter->pci_addr = probeinfo->pci_addr;\r\nmyadapter->bus = probeinfo->bus;\r\nmyadapter->dev = probeinfo->dev;\r\nmyadapter->pci_device = probeinfo->pci_device;\r\nmyadapter->irq_ch = probeinfo->irq_ch;\r\nmyadapter->addr_count =\r\nblogic_adapter_addr_count[myadapter->adapter_type];\r\nif (!request_region(myadapter->io_addr, myadapter->addr_count,\r\n"BusLogic"))\r\ncontinue;\r\nif (!blogic_probe(myadapter)) {\r\nrelease_region(myadapter->io_addr,\r\nmyadapter->addr_count);\r\ncontinue;\r\n}\r\nif (!blogic_hwreset(myadapter, true)) {\r\nrelease_region(myadapter->io_addr,\r\nmyadapter->addr_count);\r\ncontinue;\r\n}\r\nif (!blogic_checkadapter(myadapter)) {\r\nrelease_region(myadapter->io_addr,\r\nmyadapter->addr_count);\r\ncontinue;\r\n}\r\nif (drvr_optindex < blogic_drvr_options_count)\r\nmyadapter->drvr_opts =\r\n&blogic_drvr_options[drvr_optindex++];\r\nblogic_announce_drvr(myadapter);\r\nhost = scsi_host_alloc(&blogic_template,\r\nsizeof(struct blogic_adapter));\r\nif (host == NULL) {\r\nrelease_region(myadapter->io_addr,\r\nmyadapter->addr_count);\r\ncontinue;\r\n}\r\nmyadapter = (struct blogic_adapter *) host->hostdata;\r\nmemcpy(myadapter, adapter, sizeof(struct blogic_adapter));\r\nmyadapter->scsi_host = host;\r\nmyadapter->host_no = host->host_no;\r\nlist_add_tail(&myadapter->host_list, &blogic_host_list);\r\nif (blogic_rdconfig(myadapter) &&\r\nblogic_reportconfig(myadapter) &&\r\nblogic_getres(myadapter) &&\r\nblogic_create_initccbs(myadapter) &&\r\nblogic_initadapter(myadapter) &&\r\nblogic_inquiry(myadapter)) {\r\nrelease_region(myadapter->io_addr,\r\nmyadapter->addr_count);\r\nif (!request_region(myadapter->io_addr,\r\nmyadapter->addr_count,\r\nmyadapter->full_model)) {\r\nprintk(KERN_WARNING\r\n"BusLogic: Release and re-register of "\r\n"port 0x%04lx failed \n",\r\n(unsigned long)myadapter->io_addr);\r\nblogic_destroy_ccbs(myadapter);\r\nblogic_relres(myadapter);\r\nlist_del(&myadapter->host_list);\r\nscsi_host_put(host);\r\nret = -ENOMEM;\r\n} else {\r\nblogic_inithoststruct(myadapter,\r\nhost);\r\nif (scsi_add_host(host, myadapter->pci_device\r\n? &myadapter->pci_device->dev\r\n: NULL)) {\r\nprintk(KERN_WARNING\r\n"BusLogic: scsi_add_host()"\r\n"failed!\n");\r\nblogic_destroy_ccbs(myadapter);\r\nblogic_relres(myadapter);\r\nlist_del(&myadapter->host_list);\r\nscsi_host_put(host);\r\nret = -ENODEV;\r\n} else {\r\nscsi_scan_host(host);\r\nadapter_count++;\r\n}\r\n}\r\n} else {\r\nblogic_destroy_ccbs(myadapter);\r\nblogic_relres(myadapter);\r\nlist_del(&myadapter->host_list);\r\nscsi_host_put(host);\r\nret = -ENODEV;\r\n}\r\n}\r\nkfree(adapter);\r\nkfree(blogic_probeinfo_list);\r\nblogic_probeinfo_list = NULL;\r\nreturn ret;\r\n}\r\nstatic int __exit blogic_deladapter(struct blogic_adapter *adapter)\r\n{\r\nstruct Scsi_Host *host = adapter->scsi_host;\r\nscsi_remove_host(host);\r\nif (blogic_flashpoint_type(adapter))\r\nFlashPoint_ReleaseHostAdapter(adapter->cardhandle);\r\nblogic_destroy_ccbs(adapter);\r\nblogic_relres(adapter);\r\nrelease_region(adapter->io_addr, adapter->addr_count);\r\nlist_del(&adapter->host_list);\r\nscsi_host_put(host);\r\nreturn 0;\r\n}\r\nstatic void blogic_qcompleted_ccb(struct blogic_ccb *ccb)\r\n{\r\nstruct blogic_adapter *adapter = ccb->adapter;\r\nccb->status = BLOGIC_CCB_COMPLETE;\r\nccb->next = NULL;\r\nif (adapter->firstccb == NULL) {\r\nadapter->firstccb = ccb;\r\nadapter->lastccb = ccb;\r\n} else {\r\nadapter->lastccb->next = ccb;\r\nadapter->lastccb = ccb;\r\n}\r\nadapter->active_cmds[ccb->tgt_id]--;\r\n}\r\nstatic int blogic_resultcode(struct blogic_adapter *adapter,\r\nenum blogic_adapter_status adapter_status,\r\nenum blogic_tgt_status tgt_status)\r\n{\r\nint hoststatus;\r\nswitch (adapter_status) {\r\ncase BLOGIC_CMD_CMPLT_NORMAL:\r\ncase BLOGIC_LINK_CMD_CMPLT:\r\ncase BLOGIC_LINK_CMD_CMPLT_FLAG:\r\nhoststatus = DID_OK;\r\nbreak;\r\ncase BLOGIC_SELECT_TIMEOUT:\r\nhoststatus = DID_TIME_OUT;\r\nbreak;\r\ncase BLOGIC_INVALID_OUTBOX_CODE:\r\ncase BLOGIC_INVALID_CMD_CODE:\r\ncase BLOGIC_BAD_CMD_PARAM:\r\nblogic_warn("BusLogic Driver Protocol Error 0x%02X\n",\r\nadapter, adapter_status);\r\ncase BLOGIC_DATA_UNDERRUN:\r\ncase BLOGIC_DATA_OVERRUN:\r\ncase BLOGIC_NOEXPECT_BUSFREE:\r\ncase BLOGIC_LINKCCB_BADLUN:\r\ncase BLOGIC_AUTOREQSENSE_FAIL:\r\ncase BLOGIC_TAGQUEUE_REJECT:\r\ncase BLOGIC_BAD_MSG_RCVD:\r\ncase BLOGIC_HW_FAIL:\r\ncase BLOGIC_BAD_RECONNECT:\r\ncase BLOGIC_ABRT_QUEUE:\r\ncase BLOGIC_ADAPTER_SW_ERROR:\r\ncase BLOGIC_HW_TIMEOUT:\r\ncase BLOGIC_PARITY_ERR:\r\nhoststatus = DID_ERROR;\r\nbreak;\r\ncase BLOGIC_INVALID_BUSPHASE:\r\ncase BLOGIC_NORESPONSE_TO_ATN:\r\ncase BLOGIC_HW_RESET:\r\ncase BLOGIC_RST_FROM_OTHERDEV:\r\ncase BLOGIC_HW_BDR:\r\nhoststatus = DID_RESET;\r\nbreak;\r\ndefault:\r\nblogic_warn("Unknown Host Adapter Status 0x%02X\n", adapter,\r\nadapter_status);\r\nhoststatus = DID_ERROR;\r\nbreak;\r\n}\r\nreturn (hoststatus << 16) | tgt_status;\r\n}\r\nstatic void blogic_scan_inbox(struct blogic_adapter *adapter)\r\n{\r\nstruct blogic_inbox *next_inbox = adapter->next_inbox;\r\nenum blogic_cmplt_code comp_code;\r\nwhile ((comp_code = next_inbox->comp_code) != BLOGIC_INBOX_FREE) {\r\nstruct blogic_ccb *ccb =\r\n(struct blogic_ccb *) bus_to_virt(next_inbox->ccb);\r\nif (comp_code != BLOGIC_CMD_NOTFOUND) {\r\nif (ccb->status == BLOGIC_CCB_ACTIVE ||\r\nccb->status == BLOGIC_CCB_RESET) {\r\nccb->comp_code = comp_code;\r\nblogic_qcompleted_ccb(ccb);\r\n} else {\r\nblogic_warn("Illegal CCB #%ld status %d in " "Incoming Mailbox\n", adapter, ccb->serial, ccb->status);\r\n}\r\n}\r\nnext_inbox->comp_code = BLOGIC_INBOX_FREE;\r\nif (++next_inbox > adapter->last_inbox)\r\nnext_inbox = adapter->first_inbox;\r\n}\r\nadapter->next_inbox = next_inbox;\r\n}\r\nstatic void blogic_process_ccbs(struct blogic_adapter *adapter)\r\n{\r\nif (adapter->processing_ccbs)\r\nreturn;\r\nadapter->processing_ccbs = true;\r\nwhile (adapter->firstccb != NULL) {\r\nstruct blogic_ccb *ccb = adapter->firstccb;\r\nstruct scsi_cmnd *command = ccb->command;\r\nadapter->firstccb = ccb->next;\r\nif (adapter->firstccb == NULL)\r\nadapter->lastccb = NULL;\r\nif (ccb->opcode == BLOGIC_BDR) {\r\nint tgt_id = ccb->tgt_id;\r\nblogic_warn("Bus Device Reset CCB #%ld to Target " "%d Completed\n", adapter, ccb->serial, tgt_id);\r\nblogic_inc_count(&adapter->tgt_stats[tgt_id].bdr_done);\r\nadapter->tgt_flags[tgt_id].tagq_active = false;\r\nadapter->cmds_since_rst[tgt_id] = 0;\r\nadapter->last_resetdone[tgt_id] = jiffies;\r\nblogic_dealloc_ccb(ccb, 1);\r\n#if 0\r\nwhile (command != NULL) {\r\nstruct scsi_cmnd *nxt_cmd =\r\ncommand->reset_chain;\r\ncommand->reset_chain = NULL;\r\ncommand->result = DID_RESET << 16;\r\ncommand->scsi_done(command);\r\ncommand = nxt_cmd;\r\n}\r\n#endif\r\nfor (ccb = adapter->all_ccbs; ccb != NULL;\r\nccb = ccb->next_all)\r\nif (ccb->status == BLOGIC_CCB_RESET &&\r\nccb->tgt_id == tgt_id) {\r\ncommand = ccb->command;\r\nblogic_dealloc_ccb(ccb, 1);\r\nadapter->active_cmds[tgt_id]--;\r\ncommand->result = DID_RESET << 16;\r\ncommand->scsi_done(command);\r\n}\r\nadapter->bdr_pend[tgt_id] = NULL;\r\n} else {\r\nswitch (ccb->comp_code) {\r\ncase BLOGIC_INBOX_FREE:\r\ncase BLOGIC_CMD_NOTFOUND:\r\ncase BLOGIC_INVALID_CCB:\r\nblogic_warn("CCB #%ld to Target %d Impossible State\n", adapter, ccb->serial, ccb->tgt_id);\r\nbreak;\r\ncase BLOGIC_CMD_COMPLETE_GOOD:\r\nadapter->tgt_stats[ccb->tgt_id]\r\n.cmds_complete++;\r\nadapter->tgt_flags[ccb->tgt_id]\r\n.cmd_good = true;\r\ncommand->result = DID_OK << 16;\r\nbreak;\r\ncase BLOGIC_CMD_ABORT_BY_HOST:\r\nblogic_warn("CCB #%ld to Target %d Aborted\n",\r\nadapter, ccb->serial, ccb->tgt_id);\r\nblogic_inc_count(&adapter->tgt_stats[ccb->tgt_id].aborts_done);\r\ncommand->result = DID_ABORT << 16;\r\nbreak;\r\ncase BLOGIC_CMD_COMPLETE_ERROR:\r\ncommand->result = blogic_resultcode(adapter,\r\nccb->adapter_status, ccb->tgt_status);\r\nif (ccb->adapter_status != BLOGIC_SELECT_TIMEOUT) {\r\nadapter->tgt_stats[ccb->tgt_id]\r\n.cmds_complete++;\r\nif (blogic_global_options.trace_err) {\r\nint i;\r\nblogic_notice("CCB #%ld Target %d: Result %X Host "\r\n"Adapter Status %02X " "Target Status %02X\n", adapter, ccb->serial, ccb->tgt_id, command->result, ccb->adapter_status, ccb->tgt_status);\r\nblogic_notice("CDB ", adapter);\r\nfor (i = 0; i < ccb->cdblen; i++)\r\nblogic_notice(" %02X", adapter, ccb->cdb[i]);\r\nblogic_notice("\n", adapter);\r\nblogic_notice("Sense ", adapter);\r\nfor (i = 0; i < ccb->sense_datalen; i++)\r\nblogic_notice(" %02X", adapter, command->sense_buffer[i]);\r\nblogic_notice("\n", adapter);\r\n}\r\n}\r\nbreak;\r\n}\r\nif (ccb->cdb[0] == INQUIRY && ccb->cdb[1] == 0 &&\r\nccb->adapter_status == BLOGIC_CMD_CMPLT_NORMAL) {\r\nstruct blogic_tgt_flags *tgt_flags =\r\n&adapter->tgt_flags[ccb->tgt_id];\r\nstruct scsi_inquiry *inquiry =\r\n(struct scsi_inquiry *) scsi_sglist(command);\r\ntgt_flags->tgt_exists = true;\r\ntgt_flags->tagq_ok = inquiry->CmdQue;\r\ntgt_flags->wide_ok = inquiry->WBus16;\r\n}\r\nblogic_dealloc_ccb(ccb, 1);\r\ncommand->scsi_done(command);\r\n}\r\n}\r\nadapter->processing_ccbs = false;\r\n}\r\nstatic irqreturn_t blogic_inthandler(int irq_ch, void *devid)\r\n{\r\nstruct blogic_adapter *adapter = (struct blogic_adapter *) devid;\r\nunsigned long processor_flag;\r\nspin_lock_irqsave(adapter->scsi_host->host_lock, processor_flag);\r\nif (blogic_multimaster_type(adapter)) {\r\nunion blogic_int_reg intreg;\r\nintreg.all = blogic_rdint(adapter);\r\nif (intreg.ir.int_valid) {\r\nblogic_intreset(adapter);\r\nif (intreg.ir.ext_busreset)\r\nadapter->adapter_extreset = true;\r\nelse if (intreg.ir.mailin_loaded)\r\nblogic_scan_inbox(adapter);\r\nelse if (intreg.ir.cmd_complete)\r\nadapter->adapter_cmd_complete = true;\r\n}\r\n} else {\r\nif (FlashPoint_InterruptPending(adapter->cardhandle))\r\nswitch (FlashPoint_HandleInterrupt(adapter->cardhandle)) {\r\ncase FPOINT_NORMAL_INT:\r\nbreak;\r\ncase FPOINT_EXT_RESET:\r\nadapter->adapter_extreset = true;\r\nbreak;\r\ncase FPOINT_INTERN_ERR:\r\nblogic_warn("Internal FlashPoint Error detected - Resetting Host Adapter\n", adapter);\r\nadapter->adapter_intern_err = true;\r\nbreak;\r\n}\r\n}\r\nif (adapter->firstccb != NULL)\r\nblogic_process_ccbs(adapter);\r\nif (adapter->adapter_extreset) {\r\nblogic_warn("Resetting %s due to External SCSI Bus Reset\n", adapter, adapter->full_model);\r\nblogic_inc_count(&adapter->ext_resets);\r\nblogic_resetadapter(adapter, false);\r\nadapter->adapter_extreset = false;\r\n} else if (adapter->adapter_intern_err) {\r\nblogic_warn("Resetting %s due to Host Adapter Internal Error\n", adapter, adapter->full_model);\r\nblogic_inc_count(&adapter->adapter_intern_errors);\r\nblogic_resetadapter(adapter, true);\r\nadapter->adapter_intern_err = false;\r\n}\r\nspin_unlock_irqrestore(adapter->scsi_host->host_lock, processor_flag);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic bool blogic_write_outbox(struct blogic_adapter *adapter,\r\nenum blogic_action action, struct blogic_ccb *ccb)\r\n{\r\nstruct blogic_outbox *next_outbox;\r\nnext_outbox = adapter->next_outbox;\r\nif (next_outbox->action == BLOGIC_OUTBOX_FREE) {\r\nccb->status = BLOGIC_CCB_ACTIVE;\r\nnext_outbox->ccb = ccb->dma_handle;\r\nnext_outbox->action = action;\r\nblogic_execmbox(adapter);\r\nif (++next_outbox > adapter->last_outbox)\r\nnext_outbox = adapter->first_outbox;\r\nadapter->next_outbox = next_outbox;\r\nif (action == BLOGIC_MBOX_START) {\r\nadapter->active_cmds[ccb->tgt_id]++;\r\nif (ccb->opcode != BLOGIC_BDR)\r\nadapter->tgt_stats[ccb->tgt_id].cmds_tried++;\r\n}\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int blogic_hostreset(struct scsi_cmnd *SCpnt)\r\n{\r\nstruct blogic_adapter *adapter =\r\n(struct blogic_adapter *) SCpnt->device->host->hostdata;\r\nunsigned int id = SCpnt->device->id;\r\nstruct blogic_tgt_stats *stats = &adapter->tgt_stats[id];\r\nint rc;\r\nspin_lock_irq(SCpnt->device->host->host_lock);\r\nblogic_inc_count(&stats->adapter_reset_req);\r\nrc = blogic_resetadapter(adapter, false);\r\nspin_unlock_irq(SCpnt->device->host->host_lock);\r\nreturn rc;\r\n}\r\nstatic int blogic_qcmd_lck(struct scsi_cmnd *command,\r\nvoid (*comp_cb) (struct scsi_cmnd *))\r\n{\r\nstruct blogic_adapter *adapter =\r\n(struct blogic_adapter *) command->device->host->hostdata;\r\nstruct blogic_tgt_flags *tgt_flags =\r\n&adapter->tgt_flags[command->device->id];\r\nstruct blogic_tgt_stats *tgt_stats = adapter->tgt_stats;\r\nunsigned char *cdb = command->cmnd;\r\nint cdblen = command->cmd_len;\r\nint tgt_id = command->device->id;\r\nint lun = command->device->lun;\r\nint buflen = scsi_bufflen(command);\r\nint count;\r\nstruct blogic_ccb *ccb;\r\ndma_addr_t sense_buf;\r\nif (cdb[0] == REQUEST_SENSE && command->sense_buffer[0] != 0) {\r\ncommand->result = DID_OK << 16;\r\ncomp_cb(command);\r\nreturn 0;\r\n}\r\nccb = blogic_alloc_ccb(adapter);\r\nif (ccb == NULL) {\r\nspin_unlock_irq(adapter->scsi_host->host_lock);\r\nblogic_delay(1);\r\nspin_lock_irq(adapter->scsi_host->host_lock);\r\nccb = blogic_alloc_ccb(adapter);\r\nif (ccb == NULL) {\r\ncommand->result = DID_ERROR << 16;\r\ncomp_cb(command);\r\nreturn 0;\r\n}\r\n}\r\ncount = scsi_dma_map(command);\r\nBUG_ON(count < 0);\r\nif (count) {\r\nstruct scatterlist *sg;\r\nint i;\r\nccb->opcode = BLOGIC_INITIATOR_CCB_SG;\r\nccb->datalen = count * sizeof(struct blogic_sg_seg);\r\nif (blogic_multimaster_type(adapter))\r\nccb->data = (void *)((unsigned int) ccb->dma_handle +\r\n((unsigned long) &ccb->sglist -\r\n(unsigned long) ccb));\r\nelse\r\nccb->data = ccb->sglist;\r\nscsi_for_each_sg(command, sg, count, i) {\r\nccb->sglist[i].segbytes = sg_dma_len(sg);\r\nccb->sglist[i].segdata = sg_dma_address(sg);\r\n}\r\n} else if (!count) {\r\nccb->opcode = BLOGIC_INITIATOR_CCB;\r\nccb->datalen = buflen;\r\nccb->data = 0;\r\n}\r\nswitch (cdb[0]) {\r\ncase READ_6:\r\ncase READ_10:\r\nccb->datadir = BLOGIC_DATAIN_CHECKED;\r\ntgt_stats[tgt_id].read_cmds++;\r\nblogic_addcount(&tgt_stats[tgt_id].bytesread, buflen);\r\nblogic_incszbucket(tgt_stats[tgt_id].read_sz_buckets, buflen);\r\nbreak;\r\ncase WRITE_6:\r\ncase WRITE_10:\r\nccb->datadir = BLOGIC_DATAOUT_CHECKED;\r\ntgt_stats[tgt_id].write_cmds++;\r\nblogic_addcount(&tgt_stats[tgt_id].byteswritten, buflen);\r\nblogic_incszbucket(tgt_stats[tgt_id].write_sz_buckets, buflen);\r\nbreak;\r\ndefault:\r\nccb->datadir = BLOGIC_UNCHECKED_TX;\r\nbreak;\r\n}\r\nccb->cdblen = cdblen;\r\nccb->adapter_status = 0;\r\nccb->tgt_status = 0;\r\nccb->tgt_id = tgt_id;\r\nccb->lun = lun;\r\nccb->tag_enable = false;\r\nccb->legacytag_enable = false;\r\nif (adapter->cmds_since_rst[tgt_id]++ >= BLOGIC_MAX_TAG_DEPTH &&\r\n!tgt_flags->tagq_active &&\r\nadapter->active_cmds[tgt_id] == 0\r\n&& tgt_flags->tagq_ok &&\r\n(adapter->tagq_ok & (1 << tgt_id))) {\r\ntgt_flags->tagq_active = true;\r\nblogic_notice("Tagged Queuing now active for Target %d\n",\r\nadapter, tgt_id);\r\n}\r\nif (tgt_flags->tagq_active) {\r\nenum blogic_queuetag queuetag = BLOGIC_SIMPLETAG;\r\nif (adapter->active_cmds[tgt_id] == 0)\r\nadapter->last_seqpoint[tgt_id] = jiffies;\r\nelse if (time_after(jiffies,\r\nadapter->last_seqpoint[tgt_id] + 4 * HZ)) {\r\nadapter->last_seqpoint[tgt_id] = jiffies;\r\nqueuetag = BLOGIC_ORDEREDTAG;\r\n}\r\nif (adapter->ext_lun) {\r\nccb->tag_enable = true;\r\nccb->queuetag = queuetag;\r\n} else {\r\nccb->legacytag_enable = true;\r\nccb->legacy_tag = queuetag;\r\n}\r\n}\r\nmemcpy(ccb->cdb, cdb, cdblen);\r\nccb->sense_datalen = SCSI_SENSE_BUFFERSIZE;\r\nccb->command = command;\r\nsense_buf = pci_map_single(adapter->pci_device,\r\ncommand->sense_buffer, ccb->sense_datalen,\r\nPCI_DMA_FROMDEVICE);\r\nif (dma_mapping_error(&adapter->pci_device->dev, sense_buf)) {\r\nblogic_err("DMA mapping for sense data buffer failed\n",\r\nadapter);\r\nblogic_dealloc_ccb(ccb, 0);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nccb->sensedata = sense_buf;\r\ncommand->scsi_done = comp_cb;\r\nif (blogic_multimaster_type(adapter)) {\r\nif (!blogic_write_outbox(adapter, BLOGIC_MBOX_START, ccb)) {\r\nspin_unlock_irq(adapter->scsi_host->host_lock);\r\nblogic_warn("Unable to write Outgoing Mailbox - " "Pausing for 1 second\n", adapter);\r\nblogic_delay(1);\r\nspin_lock_irq(adapter->scsi_host->host_lock);\r\nif (!blogic_write_outbox(adapter, BLOGIC_MBOX_START,\r\nccb)) {\r\nblogic_warn("Still unable to write Outgoing Mailbox - " "Host Adapter Dead?\n", adapter);\r\nblogic_dealloc_ccb(ccb, 1);\r\ncommand->result = DID_ERROR << 16;\r\ncommand->scsi_done(command);\r\n}\r\n}\r\n} else {\r\nccb->status = BLOGIC_CCB_ACTIVE;\r\nadapter->active_cmds[tgt_id]++;\r\ntgt_stats[tgt_id].cmds_tried++;\r\nFlashPoint_StartCCB(adapter->cardhandle, ccb);\r\nif (ccb->status == BLOGIC_CCB_COMPLETE)\r\nblogic_process_ccbs(adapter);\r\n}\r\nreturn 0;\r\n}\r\nint blogic_diskparam(struct scsi_device *sdev, struct block_device *dev,\r\nsector_t capacity, int *params)\r\n{\r\nstruct blogic_adapter *adapter =\r\n(struct blogic_adapter *) sdev->host->hostdata;\r\nstruct bios_diskparam *diskparam = (struct bios_diskparam *) params;\r\nunsigned char *buf;\r\nif (adapter->ext_trans_enable && capacity >= 2 * 1024 * 1024 ) {\r\nif (capacity >= 4 * 1024 * 1024 ) {\r\ndiskparam->heads = 255;\r\ndiskparam->sectors = 63;\r\n} else {\r\ndiskparam->heads = 128;\r\ndiskparam->sectors = 32;\r\n}\r\n} else {\r\ndiskparam->heads = 64;\r\ndiskparam->sectors = 32;\r\n}\r\ndiskparam->cylinders = (unsigned long) capacity / (diskparam->heads * diskparam->sectors);\r\nbuf = scsi_bios_ptable(dev);\r\nif (buf == NULL)\r\nreturn 0;\r\nif (*(unsigned short *) (buf + 64) == 0xAA55) {\r\nstruct partition *part1_entry = (struct partition *) buf;\r\nstruct partition *part_entry = part1_entry;\r\nint saved_cyl = diskparam->cylinders, part_no;\r\nunsigned char part_end_head = 0, part_end_sector = 0;\r\nfor (part_no = 0; part_no < 4; part_no++) {\r\npart_end_head = part_entry->end_head;\r\npart_end_sector = part_entry->end_sector & 0x3F;\r\nif (part_end_head == 64 - 1) {\r\ndiskparam->heads = 64;\r\ndiskparam->sectors = 32;\r\nbreak;\r\n} else if (part_end_head == 128 - 1) {\r\ndiskparam->heads = 128;\r\ndiskparam->sectors = 32;\r\nbreak;\r\n} else if (part_end_head == 255 - 1) {\r\ndiskparam->heads = 255;\r\ndiskparam->sectors = 63;\r\nbreak;\r\n}\r\npart_entry++;\r\n}\r\nif (part_no == 4) {\r\npart_end_head = part1_entry->end_head;\r\npart_end_sector = part1_entry->end_sector & 0x3F;\r\n}\r\ndiskparam->cylinders = (unsigned long) capacity / (diskparam->heads * diskparam->sectors);\r\nif (part_no < 4 && part_end_sector == diskparam->sectors) {\r\nif (diskparam->cylinders != saved_cyl)\r\nblogic_warn("Adopting Geometry %d/%d from Partition Table\n", adapter, diskparam->heads, diskparam->sectors);\r\n} else if (part_end_head > 0 || part_end_sector > 0) {\r\nblogic_warn("Warning: Partition Table appears to " "have Geometry %d/%d which is\n", adapter, part_end_head + 1, part_end_sector);\r\nblogic_warn("not compatible with current BusLogic " "Host Adapter Geometry %d/%d\n", adapter, diskparam->heads, diskparam->sectors);\r\n}\r\n}\r\nkfree(buf);\r\nreturn 0;\r\n}\r\nstatic int blogic_write_info(struct Scsi_Host *shost, char *procbuf,\r\nint bytes_avail)\r\n{\r\nstruct blogic_adapter *adapter =\r\n(struct blogic_adapter *) shost->hostdata;\r\nstruct blogic_tgt_stats *tgt_stats;\r\ntgt_stats = adapter->tgt_stats;\r\nadapter->ext_resets = 0;\r\nadapter->adapter_intern_errors = 0;\r\nmemset(tgt_stats, 0, BLOGIC_MAXDEV * sizeof(struct blogic_tgt_stats));\r\nreturn 0;\r\n}\r\nstatic int blogic_show_info(struct seq_file *m, struct Scsi_Host *shost)\r\n{\r\nstruct blogic_adapter *adapter = (struct blogic_adapter *) shost->hostdata;\r\nstruct blogic_tgt_stats *tgt_stats;\r\nint tgt;\r\ntgt_stats = adapter->tgt_stats;\r\nseq_write(m, adapter->msgbuf, adapter->msgbuflen);\r\nseq_printf(m, "\n\\r\nCurrent Driver Queue Depth: %d\n\\r\nCurrently Allocated CCBs: %d\n", adapter->drvr_qdepth, adapter->alloc_ccbs);\r\nseq_puts(m, "\n\n\\r\nDATA TRANSFER STATISTICS\n\\r\n\n\\r\nTarget Tagged Queuing Queue Depth Active Attempted Completed\n\\r\n====== ============== =========== ====== ========= =========\n");\r\nfor (tgt = 0; tgt < adapter->maxdev; tgt++) {\r\nstruct blogic_tgt_flags *tgt_flags = &adapter->tgt_flags[tgt];\r\nif (!tgt_flags->tgt_exists)\r\ncontinue;\r\nseq_printf(m, " %2d %s", tgt, (tgt_flags->tagq_ok ? (tgt_flags->tagq_active ? " Active" : (adapter->tagq_ok & (1 << tgt)\r\n? " Permitted" : " Disabled"))\r\n: "Not Supported"));\r\nseq_printf(m,\r\n" %3d %3u %9u %9u\n", adapter->qdepth[tgt], adapter->active_cmds[tgt], tgt_stats[tgt].cmds_tried, tgt_stats[tgt].cmds_complete);\r\n}\r\nseq_puts(m, "\n\\r\nTarget Read Commands Write Commands Total Bytes Read Total Bytes Written\n\\r\n====== ============= ============== =================== ===================\n");\r\nfor (tgt = 0; tgt < adapter->maxdev; tgt++) {\r\nstruct blogic_tgt_flags *tgt_flags = &adapter->tgt_flags[tgt];\r\nif (!tgt_flags->tgt_exists)\r\ncontinue;\r\nseq_printf(m, " %2d %9u %9u", tgt, tgt_stats[tgt].read_cmds, tgt_stats[tgt].write_cmds);\r\nif (tgt_stats[tgt].bytesread.billions > 0)\r\nseq_printf(m, " %9u%09u", tgt_stats[tgt].bytesread.billions, tgt_stats[tgt].bytesread.units);\r\nelse\r\nseq_printf(m, " %9u", tgt_stats[tgt].bytesread.units);\r\nif (tgt_stats[tgt].byteswritten.billions > 0)\r\nseq_printf(m, " %9u%09u\n", tgt_stats[tgt].byteswritten.billions, tgt_stats[tgt].byteswritten.units);\r\nelse\r\nseq_printf(m, " %9u\n", tgt_stats[tgt].byteswritten.units);\r\n}\r\nseq_puts(m, "\n\\r\nTarget Command 0-1KB 1-2KB 2-4KB 4-8KB 8-16KB\n\\r\n====== ======= ========= ========= ========= ========= =========\n");\r\nfor (tgt = 0; tgt < adapter->maxdev; tgt++) {\r\nstruct blogic_tgt_flags *tgt_flags = &adapter->tgt_flags[tgt];\r\nif (!tgt_flags->tgt_exists)\r\ncontinue;\r\nseq_printf(m,\r\n" %2d Read %9u %9u %9u %9u %9u\n", tgt,\r\ntgt_stats[tgt].read_sz_buckets[0],\r\ntgt_stats[tgt].read_sz_buckets[1], tgt_stats[tgt].read_sz_buckets[2], tgt_stats[tgt].read_sz_buckets[3], tgt_stats[tgt].read_sz_buckets[4]);\r\nseq_printf(m,\r\n" %2d Write %9u %9u %9u %9u %9u\n", tgt,\r\ntgt_stats[tgt].write_sz_buckets[0],\r\ntgt_stats[tgt].write_sz_buckets[1], tgt_stats[tgt].write_sz_buckets[2], tgt_stats[tgt].write_sz_buckets[3], tgt_stats[tgt].write_sz_buckets[4]);\r\n}\r\nseq_puts(m, "\n\\r\nTarget Command 16-32KB 32-64KB 64-128KB 128-256KB 256KB+\n\\r\n====== ======= ========= ========= ========= ========= =========\n");\r\nfor (tgt = 0; tgt < adapter->maxdev; tgt++) {\r\nstruct blogic_tgt_flags *tgt_flags = &adapter->tgt_flags[tgt];\r\nif (!tgt_flags->tgt_exists)\r\ncontinue;\r\nseq_printf(m,\r\n" %2d Read %9u %9u %9u %9u %9u\n", tgt,\r\ntgt_stats[tgt].read_sz_buckets[5],\r\ntgt_stats[tgt].read_sz_buckets[6], tgt_stats[tgt].read_sz_buckets[7], tgt_stats[tgt].read_sz_buckets[8], tgt_stats[tgt].read_sz_buckets[9]);\r\nseq_printf(m,\r\n" %2d Write %9u %9u %9u %9u %9u\n", tgt,\r\ntgt_stats[tgt].write_sz_buckets[5],\r\ntgt_stats[tgt].write_sz_buckets[6], tgt_stats[tgt].write_sz_buckets[7], tgt_stats[tgt].write_sz_buckets[8], tgt_stats[tgt].write_sz_buckets[9]);\r\n}\r\nseq_puts(m, "\n\n\\r\nERROR RECOVERY STATISTICS\n\\r\n\n\\r\nCommand Aborts Bus Device Resets Host Adapter Resets\n\\r\nTarget Requested Completed Requested Completed Requested Completed\n\\r\nID \\\\\\\\ Attempted //// \\\\\\\\ Attempted //// \\\\\\\\ Attempted ////\n\\r\n====== ===== ===== ===== ===== ===== ===== ===== ===== =====\n");\r\nfor (tgt = 0; tgt < adapter->maxdev; tgt++) {\r\nstruct blogic_tgt_flags *tgt_flags = &adapter->tgt_flags[tgt];\r\nif (!tgt_flags->tgt_exists)\r\ncontinue;\r\nseq_printf(m, " %2d %5d %5d %5d %5d %5d %5d %5d %5d %5d\n",\r\ntgt, tgt_stats[tgt].aborts_request,\r\ntgt_stats[tgt].aborts_tried,\r\ntgt_stats[tgt].aborts_done,\r\ntgt_stats[tgt].bdr_request,\r\ntgt_stats[tgt].bdr_tried,\r\ntgt_stats[tgt].bdr_done,\r\ntgt_stats[tgt].adapter_reset_req,\r\ntgt_stats[tgt].adapter_reset_attempt,\r\ntgt_stats[tgt].adapter_reset_done);\r\n}\r\nseq_printf(m, "\nExternal Host Adapter Resets: %d\n", adapter->ext_resets);\r\nseq_printf(m, "Host Adapter Internal Errors: %d\n", adapter->adapter_intern_errors);\r\nreturn 0;\r\n}\r\nstatic void blogic_msg(enum blogic_msglevel msglevel, char *fmt,\r\nstruct blogic_adapter *adapter, ...)\r\n{\r\nstatic char buf[BLOGIC_LINEBUF_SIZE];\r\nstatic bool begin = true;\r\nva_list args;\r\nint len = 0;\r\nva_start(args, adapter);\r\nlen = vsprintf(buf, fmt, args);\r\nva_end(args);\r\nif (msglevel == BLOGIC_ANNOUNCE_LEVEL) {\r\nstatic int msglines = 0;\r\nstrcpy(&adapter->msgbuf[adapter->msgbuflen], buf);\r\nadapter->msgbuflen += len;\r\nif (++msglines <= 2)\r\nprintk("%sscsi: %s", blogic_msglevelmap[msglevel], buf);\r\n} else if (msglevel == BLOGIC_INFO_LEVEL) {\r\nstrcpy(&adapter->msgbuf[adapter->msgbuflen], buf);\r\nadapter->msgbuflen += len;\r\nif (begin) {\r\nif (buf[0] != '\n' || len > 1)\r\nprintk("%sscsi%d: %s", blogic_msglevelmap[msglevel], adapter->host_no, buf);\r\n} else\r\nprintk("%s", buf);\r\n} else {\r\nif (begin) {\r\nif (adapter != NULL && adapter->adapter_initd)\r\nprintk("%sscsi%d: %s", blogic_msglevelmap[msglevel], adapter->host_no, buf);\r\nelse\r\nprintk("%s%s", blogic_msglevelmap[msglevel], buf);\r\n} else\r\nprintk("%s", buf);\r\n}\r\nbegin = (buf[len - 1] == '\n');\r\n}\r\nstatic bool __init blogic_parse(char **str, char *keyword)\r\n{\r\nchar *pointer = *str;\r\nwhile (*keyword != '\0') {\r\nchar strch = *pointer++;\r\nchar keywordch = *keyword++;\r\nif (strch >= 'A' && strch <= 'Z')\r\nstrch += 'a' - 'Z';\r\nif (keywordch >= 'A' && keywordch <= 'Z')\r\nkeywordch += 'a' - 'Z';\r\nif (strch != keywordch)\r\nreturn false;\r\n}\r\n*str = pointer;\r\nreturn true;\r\n}\r\nstatic int __init blogic_parseopts(char *options)\r\n{\r\nwhile (true) {\r\nstruct blogic_drvr_options *drvr_opts =\r\n&blogic_drvr_options[blogic_drvr_options_count++];\r\nint tgt_id;\r\nmemset(drvr_opts, 0, sizeof(struct blogic_drvr_options));\r\nwhile (*options != '\0' && *options != ';') {\r\nif (blogic_parse(&options, "IO:")) {\r\nunsigned long io_addr = simple_strtoul(options,\r\n&options, 0);\r\nblogic_probe_options.limited_isa = true;\r\nswitch (io_addr) {\r\ncase 0x330:\r\nblogic_probe_options.probe330 = true;\r\nbreak;\r\ncase 0x334:\r\nblogic_probe_options.probe334 = true;\r\nbreak;\r\ncase 0x230:\r\nblogic_probe_options.probe230 = true;\r\nbreak;\r\ncase 0x234:\r\nblogic_probe_options.probe234 = true;\r\nbreak;\r\ncase 0x130:\r\nblogic_probe_options.probe130 = true;\r\nbreak;\r\ncase 0x134:\r\nblogic_probe_options.probe134 = true;\r\nbreak;\r\ndefault:\r\nblogic_err("BusLogic: Invalid Driver Options " "(invalid I/O Address 0x%X)\n", NULL, io_addr);\r\nreturn 0;\r\n}\r\n} else if (blogic_parse(&options, "NoProbeISA"))\r\nblogic_probe_options.noprobe_isa = true;\r\nelse if (blogic_parse(&options, "NoProbePCI"))\r\nblogic_probe_options.noprobe_pci = true;\r\nelse if (blogic_parse(&options, "NoProbe"))\r\nblogic_probe_options.noprobe = true;\r\nelse if (blogic_parse(&options, "NoSortPCI"))\r\nblogic_probe_options.nosort_pci = true;\r\nelse if (blogic_parse(&options, "MultiMasterFirst"))\r\nblogic_probe_options.multimaster_first = true;\r\nelse if (blogic_parse(&options, "FlashPointFirst"))\r\nblogic_probe_options.flashpoint_first = true;\r\nelse if (blogic_parse(&options, "QueueDepth:[") ||\r\nblogic_parse(&options, "QD:[")) {\r\nfor (tgt_id = 0; tgt_id < BLOGIC_MAXDEV; tgt_id++) {\r\nunsigned short qdepth = simple_strtoul(options, &options, 0);\r\nif (qdepth > BLOGIC_MAX_TAG_DEPTH) {\r\nblogic_err("BusLogic: Invalid Driver Options " "(invalid Queue Depth %d)\n", NULL, qdepth);\r\nreturn 0;\r\n}\r\ndrvr_opts->qdepth[tgt_id] = qdepth;\r\nif (*options == ',')\r\noptions++;\r\nelse if (*options == ']')\r\nbreak;\r\nelse {\r\nblogic_err("BusLogic: Invalid Driver Options " "(',' or ']' expected at '%s')\n", NULL, options);\r\nreturn 0;\r\n}\r\n}\r\nif (*options != ']') {\r\nblogic_err("BusLogic: Invalid Driver Options " "(']' expected at '%s')\n", NULL, options);\r\nreturn 0;\r\n} else\r\noptions++;\r\n} else if (blogic_parse(&options, "QueueDepth:") || blogic_parse(&options, "QD:")) {\r\nunsigned short qdepth = simple_strtoul(options, &options, 0);\r\nif (qdepth == 0 ||\r\nqdepth > BLOGIC_MAX_TAG_DEPTH) {\r\nblogic_err("BusLogic: Invalid Driver Options " "(invalid Queue Depth %d)\n", NULL, qdepth);\r\nreturn 0;\r\n}\r\ndrvr_opts->common_qdepth = qdepth;\r\nfor (tgt_id = 0; tgt_id < BLOGIC_MAXDEV; tgt_id++)\r\ndrvr_opts->qdepth[tgt_id] = qdepth;\r\n} else if (blogic_parse(&options, "TaggedQueuing:") ||\r\nblogic_parse(&options, "TQ:")) {\r\nif (blogic_parse(&options, "Default")) {\r\ndrvr_opts->tagq_ok = 0x0000;\r\ndrvr_opts->tagq_ok_mask = 0x0000;\r\n} else if (blogic_parse(&options, "Enable")) {\r\ndrvr_opts->tagq_ok = 0xFFFF;\r\ndrvr_opts->tagq_ok_mask = 0xFFFF;\r\n} else if (blogic_parse(&options, "Disable")) {\r\ndrvr_opts->tagq_ok = 0x0000;\r\ndrvr_opts->tagq_ok_mask = 0xFFFF;\r\n} else {\r\nunsigned short tgt_bit;\r\nfor (tgt_id = 0, tgt_bit = 1;\r\ntgt_id < BLOGIC_MAXDEV;\r\ntgt_id++, tgt_bit <<= 1)\r\nswitch (*options++) {\r\ncase 'Y':\r\ndrvr_opts->tagq_ok |= tgt_bit;\r\ndrvr_opts->tagq_ok_mask |= tgt_bit;\r\nbreak;\r\ncase 'N':\r\ndrvr_opts->tagq_ok &= ~tgt_bit;\r\ndrvr_opts->tagq_ok_mask |= tgt_bit;\r\nbreak;\r\ncase 'X':\r\nbreak;\r\ndefault:\r\noptions--;\r\ntgt_id = BLOGIC_MAXDEV;\r\nbreak;\r\n}\r\n}\r\n}\r\nelse if (blogic_parse(&options, "BusSettleTime:") ||\r\nblogic_parse(&options, "BST:")) {\r\nunsigned short bus_settle_time =\r\nsimple_strtoul(options, &options, 0);\r\nif (bus_settle_time > 5 * 60) {\r\nblogic_err("BusLogic: Invalid Driver Options " "(invalid Bus Settle Time %d)\n", NULL, bus_settle_time);\r\nreturn 0;\r\n}\r\ndrvr_opts->bus_settle_time = bus_settle_time;\r\n} else if (blogic_parse(&options,\r\n"InhibitTargetInquiry"))\r\ndrvr_opts->stop_tgt_inquiry = true;\r\nelse if (blogic_parse(&options, "TraceProbe"))\r\nblogic_global_options.trace_probe = true;\r\nelse if (blogic_parse(&options, "TraceHardwareReset"))\r\nblogic_global_options.trace_hw_reset = true;\r\nelse if (blogic_parse(&options, "TraceConfiguration"))\r\nblogic_global_options.trace_config = true;\r\nelse if (blogic_parse(&options, "TraceErrors"))\r\nblogic_global_options.trace_err = true;\r\nelse if (blogic_parse(&options, "Debug")) {\r\nblogic_global_options.trace_probe = true;\r\nblogic_global_options.trace_hw_reset = true;\r\nblogic_global_options.trace_config = true;\r\nblogic_global_options.trace_err = true;\r\n}\r\nif (*options == ',')\r\noptions++;\r\nelse if (*options != ';' && *options != '\0') {\r\nblogic_err("BusLogic: Unexpected Driver Option '%s' " "ignored\n", NULL, options);\r\n*options = '\0';\r\n}\r\n}\r\nif (!(blogic_drvr_options_count == 0 ||\r\nblogic_probeinfo_count == 0 ||\r\nblogic_drvr_options_count == blogic_probeinfo_count)) {\r\nblogic_err("BusLogic: Invalid Driver Options " "(all or no I/O Addresses must be specified)\n", NULL);\r\nreturn 0;\r\n}\r\nfor (tgt_id = 0; tgt_id < BLOGIC_MAXDEV; tgt_id++)\r\nif (drvr_opts->qdepth[tgt_id] == 1) {\r\nunsigned short tgt_bit = 1 << tgt_id;\r\ndrvr_opts->tagq_ok &= ~tgt_bit;\r\ndrvr_opts->tagq_ok_mask |= tgt_bit;\r\n}\r\nif (*options == ';')\r\noptions++;\r\nif (*options == '\0')\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init blogic_setup(char *str)\r\n{\r\nint ints[3];\r\n(void) get_options(str, ARRAY_SIZE(ints), ints);\r\nif (ints[0] != 0) {\r\nblogic_err("BusLogic: Obsolete Command Line Entry " "Format Ignored\n", NULL);\r\nreturn 0;\r\n}\r\nif (str == NULL || *str == '\0')\r\nreturn 0;\r\nreturn blogic_parseopts(str);\r\n}\r\nstatic void __exit blogic_exit(void)\r\n{\r\nstruct blogic_adapter *ha, *next;\r\nlist_for_each_entry_safe(ha, next, &blogic_host_list, host_list)\r\nblogic_deladapter(ha);\r\n}
