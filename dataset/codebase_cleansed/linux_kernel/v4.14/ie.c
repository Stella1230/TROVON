struct uwb_ie_hdr *uwb_ie_next(void **ptr, size_t *len)\r\n{\r\nstruct uwb_ie_hdr *hdr;\r\nsize_t ie_len;\r\nif (*len < sizeof(struct uwb_ie_hdr))\r\nreturn NULL;\r\nhdr = *ptr;\r\nie_len = sizeof(struct uwb_ie_hdr) + hdr->length;\r\nif (*len < ie_len)\r\nreturn NULL;\r\n*ptr += ie_len;\r\n*len -= ie_len;\r\nreturn hdr;\r\n}\r\nint uwb_ie_dump_hex(const struct uwb_ie_hdr *ies, size_t len,\r\nchar *buf, size_t size)\r\n{\r\nvoid *ptr;\r\nconst struct uwb_ie_hdr *ie;\r\nint r = 0;\r\nu8 *d;\r\nptr = (void *)ies;\r\nfor (;;) {\r\nie = uwb_ie_next(&ptr, &len);\r\nif (!ie)\r\nbreak;\r\nr += scnprintf(buf + r, size - r, "%02x %02x",\r\n(unsigned)ie->element_id,\r\n(unsigned)ie->length);\r\nd = (uint8_t *)ie + sizeof(struct uwb_ie_hdr);\r\nwhile (d != ptr && r < size)\r\nr += scnprintf(buf + r, size - r, " %02x", (unsigned)*d++);\r\nif (r < size)\r\nbuf[r++] = '\n';\r\n};\r\nreturn r;\r\n}\r\nstatic\r\nssize_t uwb_rc_get_ie(struct uwb_rc *uwb_rc, struct uwb_rc_evt_get_ie **pget_ie)\r\n{\r\nssize_t result;\r\nstruct device *dev = &uwb_rc->uwb_dev.dev;\r\nstruct uwb_rccb *cmd = NULL;\r\nstruct uwb_rceb *reply = NULL;\r\nstruct uwb_rc_evt_get_ie *get_ie;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->bCommandType = UWB_RC_CET_GENERAL;\r\ncmd->wCommand = cpu_to_le16(UWB_RC_CMD_GET_IE);\r\nresult = uwb_rc_vcmd(uwb_rc, "GET_IE", cmd, sizeof(*cmd),\r\nUWB_RC_CET_GENERAL, UWB_RC_CMD_GET_IE,\r\n&reply);\r\nkfree(cmd);\r\nif (result < 0)\r\nreturn result;\r\nget_ie = container_of(reply, struct uwb_rc_evt_get_ie, rceb);\r\nif (result < sizeof(*get_ie)) {\r\ndev_err(dev, "not enough data returned for decoding GET IE "\r\n"(%zu bytes received vs %zu needed)\n",\r\nresult, sizeof(*get_ie));\r\nreturn -EINVAL;\r\n} else if (result < sizeof(*get_ie) + le16_to_cpu(get_ie->wIELength)) {\r\ndev_err(dev, "not enough data returned for decoding GET IE "\r\n"payload (%zu bytes received vs %zu needed)\n", result,\r\nsizeof(*get_ie) + le16_to_cpu(get_ie->wIELength));\r\nreturn -EINVAL;\r\n}\r\n*pget_ie = get_ie;\r\nreturn result;\r\n}\r\nint uwb_rc_set_ie(struct uwb_rc *rc, struct uwb_rc_cmd_set_ie *cmd)\r\n{\r\nint result;\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nstruct uwb_rc_evt_set_ie reply;\r\nreply.rceb.bEventType = UWB_RC_CET_GENERAL;\r\nreply.rceb.wEvent = UWB_RC_CMD_SET_IE;\r\nresult = uwb_rc_cmd(rc, "SET-IE", &cmd->rccb,\r\nsizeof(*cmd) + le16_to_cpu(cmd->wIELength),\r\n&reply.rceb, sizeof(reply));\r\nif (result < 0)\r\ngoto error_cmd;\r\nelse if (result != sizeof(reply)) {\r\ndev_err(dev, "SET-IE: not enough data to decode reply "\r\n"(%d bytes received vs %zu needed)\n",\r\nresult, sizeof(reply));\r\nresult = -EIO;\r\n} else if (reply.bResultCode != UWB_RC_RES_SUCCESS) {\r\ndev_err(dev, "SET-IE: command execution failed: %s (%d)\n",\r\nuwb_rc_strerror(reply.bResultCode), reply.bResultCode);\r\nresult = -EIO;\r\n} else\r\nresult = 0;\r\nerror_cmd:\r\nreturn result;\r\n}\r\nvoid uwb_rc_ie_init(struct uwb_rc *uwb_rc)\r\n{\r\nmutex_init(&uwb_rc->ies_mutex);\r\n}\r\nint uwb_rc_ie_setup(struct uwb_rc *uwb_rc)\r\n{\r\nstruct uwb_rc_evt_get_ie *ie_info = NULL;\r\nint capacity;\r\ncapacity = uwb_rc_get_ie(uwb_rc, &ie_info);\r\nif (capacity < 0)\r\nreturn capacity;\r\nmutex_lock(&uwb_rc->ies_mutex);\r\nuwb_rc->ies = (struct uwb_rc_cmd_set_ie *)ie_info;\r\nuwb_rc->ies->rccb.bCommandType = UWB_RC_CET_GENERAL;\r\nuwb_rc->ies->rccb.wCommand = cpu_to_le16(UWB_RC_CMD_SET_IE);\r\nuwb_rc->ies_capacity = capacity;\r\nmutex_unlock(&uwb_rc->ies_mutex);\r\nreturn 0;\r\n}\r\nvoid uwb_rc_ie_release(struct uwb_rc *uwb_rc)\r\n{\r\nkfree(uwb_rc->ies);\r\nuwb_rc->ies = NULL;\r\nuwb_rc->ies_capacity = 0;\r\n}\r\nstatic int uwb_rc_ie_add_one(struct uwb_rc *rc, const struct uwb_ie_hdr *new_ie)\r\n{\r\nstruct uwb_rc_cmd_set_ie *new_ies;\r\nvoid *ptr, *prev_ie;\r\nstruct uwb_ie_hdr *ie;\r\nsize_t length, new_ie_len, new_capacity, size, prev_size;\r\nlength = le16_to_cpu(rc->ies->wIELength);\r\nnew_ie_len = sizeof(struct uwb_ie_hdr) + new_ie->length;\r\nnew_capacity = sizeof(struct uwb_rc_cmd_set_ie) + length + new_ie_len;\r\nif (new_capacity > rc->ies_capacity) {\r\nnew_ies = krealloc(rc->ies, new_capacity, GFP_KERNEL);\r\nif (!new_ies)\r\nreturn -ENOMEM;\r\nrc->ies = new_ies;\r\n}\r\nptr = rc->ies->IEData;\r\nsize = length;\r\nfor (;;) {\r\nprev_ie = ptr;\r\nprev_size = size;\r\nie = uwb_ie_next(&ptr, &size);\r\nif (!ie || ie->element_id > new_ie->element_id)\r\nbreak;\r\n}\r\nmemmove(prev_ie + new_ie_len, prev_ie, prev_size);\r\nmemcpy(prev_ie, new_ie, new_ie_len);\r\nrc->ies->wIELength = cpu_to_le16(length + new_ie_len);\r\nreturn 0;\r\n}\r\nint uwb_rc_ie_add(struct uwb_rc *uwb_rc,\r\nconst struct uwb_ie_hdr *ies, size_t size)\r\n{\r\nint result = 0;\r\nvoid *ptr;\r\nconst struct uwb_ie_hdr *ie;\r\nmutex_lock(&uwb_rc->ies_mutex);\r\nptr = (void *)ies;\r\nfor (;;) {\r\nie = uwb_ie_next(&ptr, &size);\r\nif (!ie)\r\nbreak;\r\nresult = uwb_rc_ie_add_one(uwb_rc, ie);\r\nif (result < 0)\r\nbreak;\r\n}\r\nif (result >= 0) {\r\nif (size == 0) {\r\nif (uwb_rc->beaconing != -1)\r\nresult = uwb_rc_set_ie(uwb_rc, uwb_rc->ies);\r\n} else\r\nresult = -EINVAL;\r\n}\r\nmutex_unlock(&uwb_rc->ies_mutex);\r\nreturn result;\r\n}\r\nstatic\r\nvoid uwb_rc_ie_cache_rm(struct uwb_rc *uwb_rc, enum uwb_ie to_remove)\r\n{\r\nstruct uwb_ie_hdr *ie;\r\nsize_t len = le16_to_cpu(uwb_rc->ies->wIELength);\r\nvoid *ptr;\r\nsize_t size;\r\nptr = uwb_rc->ies->IEData;\r\nsize = len;\r\nfor (;;) {\r\nie = uwb_ie_next(&ptr, &size);\r\nif (!ie)\r\nbreak;\r\nif (ie->element_id == to_remove) {\r\nlen -= sizeof(struct uwb_ie_hdr) + ie->length;\r\nmemmove(ie, ptr, size);\r\nptr = ie;\r\n}\r\n}\r\nuwb_rc->ies->wIELength = cpu_to_le16(len);\r\n}\r\nint uwb_rc_ie_rm(struct uwb_rc *uwb_rc, enum uwb_ie element_id)\r\n{\r\nint result = 0;\r\nmutex_lock(&uwb_rc->ies_mutex);\r\nuwb_rc_ie_cache_rm(uwb_rc, element_id);\r\nif (uwb_rc->beaconing != -1)\r\nresult = uwb_rc_set_ie(uwb_rc, uwb_rc->ies);\r\nmutex_unlock(&uwb_rc->ies_mutex);\r\nreturn result;\r\n}
