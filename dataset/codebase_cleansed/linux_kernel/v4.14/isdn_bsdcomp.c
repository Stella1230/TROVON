static void bsd_clear(struct bsd_db *db)\r\n{\r\ndb->clear_count++;\r\ndb->max_ent = FIRST - 1;\r\ndb->n_bits = BSD_INIT_BITS;\r\ndb->bytes_out = 0;\r\ndb->in_count = 0;\r\ndb->incomp_count = 0;\r\ndb->ratio = 0;\r\ndb->checkpoint = CHECK_GAP;\r\n}\r\nstatic int bsd_check(struct bsd_db *db)\r\n{\r\nunsigned int new_ratio;\r\nif (db->in_count >= db->checkpoint)\r\n{\r\nif (db->in_count >= RATIO_MAX || db->bytes_out >= RATIO_MAX)\r\n{\r\ndb->in_count -= (db->in_count >> 2);\r\ndb->bytes_out -= (db->bytes_out >> 2);\r\n}\r\ndb->checkpoint = db->in_count + CHECK_GAP;\r\nif (db->max_ent >= db->maxmaxcode)\r\n{\r\nnew_ratio = db->in_count << RATIO_SCALE_LOG;\r\nif (db->bytes_out != 0)\r\n{\r\nnew_ratio /= db->bytes_out;\r\n}\r\nif (new_ratio < db->ratio || new_ratio < 1 * RATIO_SCALE)\r\n{\r\nbsd_clear(db);\r\nreturn 1;\r\n}\r\ndb->ratio = new_ratio;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void bsd_stats(void *state, struct compstat *stats)\r\n{\r\nstruct bsd_db *db = (struct bsd_db *) state;\r\nstats->unc_bytes = db->uncomp_bytes;\r\nstats->unc_packets = db->uncomp_count;\r\nstats->comp_bytes = db->comp_bytes;\r\nstats->comp_packets = db->comp_count;\r\nstats->inc_bytes = db->incomp_bytes;\r\nstats->inc_packets = db->incomp_count;\r\nstats->in_count = db->in_count;\r\nstats->bytes_out = db->bytes_out;\r\n}\r\nstatic void bsd_reset(void *state, unsigned char code, unsigned char id,\r\nunsigned char *data, unsigned len,\r\nstruct isdn_ppp_resetparams *rsparm)\r\n{\r\nstruct bsd_db *db = (struct bsd_db *) state;\r\nbsd_clear(db);\r\ndb->seqno = 0;\r\ndb->clear_count = 0;\r\n}\r\nstatic void bsd_free(void *state)\r\n{\r\nstruct bsd_db *db = (struct bsd_db *) state;\r\nif (db) {\r\nvfree(db->dict);\r\ndb->dict = NULL;\r\nvfree(db->lens);\r\ndb->lens = NULL;\r\nkfree(db);\r\n}\r\n}\r\nstatic void *bsd_alloc(struct isdn_ppp_comp_data *data)\r\n{\r\nint bits;\r\nunsigned int hsize, hshift, maxmaxcode;\r\nstruct bsd_db *db;\r\nint decomp;\r\nstatic unsigned int htab[][2] = {\r\n{ 5003 , 4 } , { 5003 , 4 } , { 5003 , 4 } , { 5003 , 4 } ,\r\n{ 9001 , 5 } , { 18013 , 6 } , { 35023 , 7 } , { 69001 , 8 }\r\n};\r\nif (data->optlen != 1 || data->num != CI_BSD_COMPRESS\r\n|| BSD_VERSION(data->options[0]) != BSD_CURRENT_VERSION)\r\nreturn NULL;\r\nbits = BSD_NBITS(data->options[0]);\r\nif (bits < 9 || bits > 15)\r\nreturn NULL;\r\nhsize = htab[bits - 9][0];\r\nhshift = htab[bits - 9][1];\r\nmaxmaxcode = MAXCODE(bits);\r\ndb = kzalloc(sizeof(struct bsd_db), GFP_KERNEL);\r\nif (!db)\r\nreturn NULL;\r\ndb->xmit = data->flags & IPPP_COMP_FLAG_XMIT;\r\ndecomp = db->xmit ? 0 : 1;\r\ndb->dict = vmalloc(hsize * sizeof(struct bsd_dict));\r\nif (!db->dict) {\r\nbsd_free(db);\r\nreturn NULL;\r\n}\r\nif (!decomp)\r\ndb->lens = NULL;\r\nelse {\r\ndb->lens = vmalloc((maxmaxcode + 1) * sizeof(db->lens[0]));\r\nif (!db->lens) {\r\nbsd_free(db);\r\nreturn (NULL);\r\n}\r\n}\r\ndb->totlen = sizeof(struct bsd_db) + (sizeof(struct bsd_dict) * hsize);\r\ndb->hsize = hsize;\r\ndb->hshift = hshift;\r\ndb->maxmaxcode = maxmaxcode;\r\ndb->maxbits = bits;\r\nreturn (void *)db;\r\n}\r\nstatic int bsd_init(void *state, struct isdn_ppp_comp_data *data, int unit, int debug)\r\n{\r\nstruct bsd_db *db = state;\r\nint indx;\r\nint decomp;\r\nif (!state || !data) {\r\nprintk(KERN_ERR "isdn_bsd_init: [%d] ERR, state %lx data %lx\n", unit, (long)state, (long)data);\r\nreturn 0;\r\n}\r\ndecomp = db->xmit ? 0 : 1;\r\nif (data->optlen != 1 || data->num != CI_BSD_COMPRESS\r\n|| (BSD_VERSION(data->options[0]) != BSD_CURRENT_VERSION)\r\n|| (BSD_NBITS(data->options[0]) != db->maxbits)\r\n|| (decomp && db->lens == NULL)) {\r\nprintk(KERN_ERR "isdn_bsd: %d %d %d %d %lx\n", data->optlen, data->num, data->options[0], decomp, (unsigned long)db->lens);\r\nreturn 0;\r\n}\r\nif (decomp)\r\nfor (indx = LAST; indx >= 0; indx--)\r\ndb->lens[indx] = 1;\r\nindx = db->hsize;\r\nwhile (indx-- != 0) {\r\ndb->dict[indx].codem1 = BADCODEM1;\r\ndb->dict[indx].cptr = 0;\r\n}\r\ndb->unit = unit;\r\ndb->mru = 0;\r\ndb->debug = 1;\r\nbsd_reset(db, 0, 0, NULL, 0, NULL);\r\nreturn 1;\r\n}\r\nstatic unsigned short *lens_ptr(struct bsd_db *db, int idx)\r\n{\r\nif ((unsigned int) idx > (unsigned int) db->maxmaxcode) {\r\nprintk(KERN_DEBUG "<9>ppp: lens_ptr(%d) > max\n", idx);\r\nidx = 0;\r\n}\r\nreturn lens_ptrx(db, idx);\r\n}\r\nstatic struct bsd_dict *dict_ptr(struct bsd_db *db, int idx)\r\n{\r\nif ((unsigned int) idx >= (unsigned int) db->hsize) {\r\nprintk(KERN_DEBUG "<9>ppp: dict_ptr(%d) > max\n", idx);\r\nidx = 0;\r\n}\r\nreturn dict_ptrx(db, idx);\r\n}\r\nstatic int bsd_compress(void *state, struct sk_buff *skb_in, struct sk_buff *skb_out, int proto)\r\n{\r\nstruct bsd_db *db;\r\nint hshift;\r\nunsigned int max_ent;\r\nunsigned int n_bits;\r\nunsigned int bitno;\r\nunsigned long accm;\r\nint ent;\r\nunsigned long fcode;\r\nstruct bsd_dict *dictp;\r\nunsigned char c;\r\nint hval, disp, ilen, mxcode;\r\nunsigned char *rptr = skb_in->data;\r\nint isize = skb_in->len;\r\n#define OUTPUT(ent) \\r\n{ \\r\nbitno -= n_bits; \\r\naccm |= ((ent) << bitno); \\r\ndo { \\r\nif (skb_out && skb_tailroom(skb_out) > 0) \\r\nskb_put_u8(skb_out, (u8)(accm >> 24)); \\r\naccm <<= 8; \\r\nbitno += 8; \\r\n} while (bitno <= 24); \\r\n}\r\nprintk(KERN_DEBUG "bsd_compress called with %x\n", proto);\r\nent = proto;\r\nif (proto < 0x21 || proto > 0xf9 || !(proto & 0x1))\r\nreturn 0;\r\ndb = (struct bsd_db *) state;\r\nhshift = db->hshift;\r\nmax_ent = db->max_ent;\r\nn_bits = db->n_bits;\r\nbitno = 32;\r\naccm = 0;\r\nmxcode = MAXCODE(n_bits);\r\nif (skb_out && skb_tailroom(skb_out) >= 2) {\r\nchar *v = skb_put(skb_out, 2);\r\nv[0] = db->seqno >> 8;\r\nv[1] = db->seqno;\r\n}\r\nilen = ++isize;\r\nwhile (--ilen > 0) {\r\nc = *rptr++;\r\nfcode = BSD_KEY(ent, c);\r\nhval = BSD_HASH(ent, c, hshift);\r\ndictp = dict_ptr(db, hval);\r\nif (dictp->codem1 >= max_ent)\r\ngoto nomatch;\r\nif (dictp->fcode == fcode) {\r\nent = dictp->codem1 + 1;\r\ncontinue;\r\n}\r\ndisp = (hval == 0) ? 1 : hval;\r\ndo {\r\nhval += disp;\r\nif (hval >= db->hsize)\r\nhval -= db->hsize;\r\ndictp = dict_ptr(db, hval);\r\nif (dictp->codem1 >= max_ent)\r\ngoto nomatch;\r\n} while (dictp->fcode != fcode);\r\nent = dictp->codem1 + 1;\r\ncontinue;\r\nnomatch:\r\nOUTPUT(ent);\r\nif (max_ent < db->maxmaxcode) {\r\nstruct bsd_dict *dictp2;\r\nstruct bsd_dict *dictp3;\r\nint indx;\r\nif (max_ent >= mxcode) {\r\ndb->n_bits = ++n_bits;\r\nmxcode = MAXCODE(n_bits);\r\n}\r\ndictp2 = dict_ptr(db, max_ent + 1);\r\nindx = dictp2->cptr;\r\ndictp3 = dict_ptr(db, indx);\r\nif (dictp3->codem1 == max_ent)\r\ndictp3->codem1 = BADCODEM1;\r\ndictp2->cptr = hval;\r\ndictp->codem1 = max_ent;\r\ndictp->fcode = fcode;\r\ndb->max_ent = ++max_ent;\r\nif (db->lens) {\r\nunsigned short *len1 = lens_ptr(db, max_ent);\r\nunsigned short *len2 = lens_ptr(db, ent);\r\n*len1 = *len2 + 1;\r\n}\r\n}\r\nent = c;\r\n}\r\nOUTPUT(ent);\r\nif (skb_out)\r\ndb->bytes_out += skb_out->len;\r\ndb->uncomp_bytes += isize;\r\ndb->in_count += isize;\r\n++db->uncomp_count;\r\n++db->seqno;\r\nif (bitno < 32)\r\n++db->bytes_out;\r\nif (bsd_check(db))\r\nOUTPUT(CLEAR);\r\nif (bitno < 32 && skb_out && skb_tailroom(skb_out) > 0)\r\nskb_put_u8(skb_out,\r\n(unsigned char)((accm | (0xff << (bitno - 8))) >> 24));\r\nif (max_ent >= mxcode && max_ent < db->maxmaxcode)\r\ndb->n_bits++;\r\nif (!skb_out || skb_out->len >= skb_in->len) {\r\n++db->incomp_count;\r\ndb->incomp_bytes += isize;\r\nreturn 0;\r\n}\r\n++db->comp_count;\r\ndb->comp_bytes += skb_out->len;\r\nreturn skb_out->len;\r\n#undef OUTPUT\r\n}\r\nstatic void bsd_incomp(void *state, struct sk_buff *skb_in, int proto)\r\n{\r\nbsd_compress(state, skb_in, NULL, proto);\r\n}\r\nstatic int bsd_decompress(void *state, struct sk_buff *skb_in, struct sk_buff *skb_out,\r\nstruct isdn_ppp_resetparams *rsparm)\r\n{\r\nstruct bsd_db *db;\r\nunsigned int max_ent;\r\nunsigned long accm;\r\nunsigned int bitno;\r\nunsigned int n_bits;\r\nunsigned int tgtbitno;\r\nstruct bsd_dict *dictp;\r\nint seq;\r\nunsigned int incode;\r\nunsigned int oldcode;\r\nunsigned int finchar;\r\nunsigned char *p, *ibuf;\r\nint ilen;\r\nint codelen;\r\nint extra;\r\ndb = (struct bsd_db *) state;\r\nmax_ent = db->max_ent;\r\naccm = 0;\r\nbitno = 32;\r\nn_bits = db->n_bits;\r\ntgtbitno = 32 - n_bits;\r\nprintk(KERN_DEBUG "bsd_decompress called\n");\r\nif (!skb_in || !skb_out) {\r\nprintk(KERN_ERR "bsd_decompress called with NULL parameter\n");\r\nreturn DECOMP_ERROR;\r\n}\r\nif ((p = skb_pull(skb_in, 2)) == NULL) {\r\nreturn DECOMP_ERROR;\r\n}\r\np -= 2;\r\nseq = (p[0] << 8) + p[1];\r\nilen = skb_in->len;\r\nibuf = skb_in->data;\r\nif (seq != db->seqno) {\r\nif (db->debug) {\r\nprintk(KERN_DEBUG "bsd_decomp%d: bad sequence # %d, expected %d\n",\r\ndb->unit, seq, db->seqno - 1);\r\n}\r\nreturn DECOMP_ERROR;\r\n}\r\n++db->seqno;\r\ndb->bytes_out += ilen;\r\nif (skb_tailroom(skb_out) > 0)\r\nskb_put_u8(skb_out, 0);\r\nelse\r\nreturn DECOMP_ERR_NOMEM;\r\noldcode = CLEAR;\r\nfor (;;) {\r\nif (ilen-- <= 0) {\r\ndb->in_count += (skb_out->len - 1);\r\nbreak;\r\n}\r\nbitno -= 8;\r\naccm |= *ibuf++ << bitno;\r\nif (tgtbitno < bitno)\r\ncontinue;\r\nincode = accm >> tgtbitno;\r\naccm <<= n_bits;\r\nbitno += n_bits;\r\nif (incode == CLEAR) {\r\nif (ilen > 0) {\r\nif (db->debug)\r\nprintk(KERN_DEBUG "bsd_decomp%d: bad CLEAR\n", db->unit);\r\nreturn DECOMP_FATALERROR;\r\n}\r\nbsd_clear(db);\r\nbreak;\r\n}\r\nif ((incode > max_ent + 2) || (incode > db->maxmaxcode)\r\n|| (incode > max_ent && oldcode == CLEAR)) {\r\nif (db->debug) {\r\nprintk(KERN_DEBUG "bsd_decomp%d: bad code 0x%x oldcode=0x%x ",\r\ndb->unit, incode, oldcode);\r\nprintk(KERN_DEBUG "max_ent=0x%x skb->Len=%d seqno=%d\n",\r\nmax_ent, skb_out->len, db->seqno);\r\n}\r\nreturn DECOMP_FATALERROR;\r\n}\r\nif (incode > max_ent) {\r\nfinchar = oldcode;\r\nextra = 1;\r\n} else {\r\nfinchar = incode;\r\nextra = 0;\r\n}\r\ncodelen = *(lens_ptr(db, finchar));\r\nif (skb_tailroom(skb_out) < codelen + extra) {\r\nif (db->debug) {\r\nprintk(KERN_DEBUG "bsd_decomp%d: ran out of mru\n", db->unit);\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG " len=%d, finchar=0x%x, codelen=%d,skblen=%d\n",\r\nilen, finchar, codelen, skb_out->len);\r\n#endif\r\n}\r\nreturn DECOMP_FATALERROR;\r\n}\r\np = skb_put(skb_out, codelen);\r\np += codelen;\r\nwhile (finchar > LAST) {\r\nstruct bsd_dict *dictp2 = dict_ptr(db, finchar);\r\ndictp = dict_ptr(db, dictp2->cptr);\r\n#ifdef DEBUG\r\nif (--codelen <= 0 || dictp->codem1 != finchar - 1) {\r\nif (codelen <= 0) {\r\nprintk(KERN_ERR "bsd_decomp%d: fell off end of chain ", db->unit);\r\nprintk(KERN_ERR "0x%x at 0x%x by 0x%x, max_ent=0x%x\n", incode, finchar, dictp2->cptr, max_ent);\r\n} else {\r\nif (dictp->codem1 != finchar - 1) {\r\nprintk(KERN_ERR "bsd_decomp%d: bad code chain 0x%x finchar=0x%x ", db->unit, incode, finchar);\r\nprintk(KERN_ERR "oldcode=0x%x cptr=0x%x codem1=0x%x\n", oldcode, dictp2->cptr, dictp->codem1);\r\n}\r\n}\r\nreturn DECOMP_FATALERROR;\r\n}\r\n#endif\r\n{\r\nu32 fcode = dictp->fcode;\r\n*--p = (fcode >> 16) & 0xff;\r\nfinchar = fcode & 0xffff;\r\n}\r\n}\r\n*--p = finchar;\r\n#ifdef DEBUG\r\nif (--codelen != 0)\r\nprintk(KERN_ERR "bsd_decomp%d: short by %d after code 0x%x, max_ent=0x%x\n", db->unit, codelen, incode, max_ent);\r\n#endif\r\nif (extra)\r\nskb_put_u8(skb_out, finchar);\r\nif (oldcode != CLEAR && max_ent < db->maxmaxcode) {\r\nstruct bsd_dict *dictp2, *dictp3;\r\nu16 *lens1, *lens2;\r\nunsigned long fcode;\r\nint hval, disp, indx;\r\nfcode = BSD_KEY(oldcode, finchar);\r\nhval = BSD_HASH(oldcode, finchar, db->hshift);\r\ndictp = dict_ptr(db, hval);\r\nif (dictp->codem1 < max_ent) {\r\ndisp = (hval == 0) ? 1 : hval;\r\ndo {\r\nhval += disp;\r\nif (hval >= db->hsize)\r\nhval -= db->hsize;\r\ndictp = dict_ptr(db, hval);\r\n} while (dictp->codem1 < max_ent);\r\n}\r\ndictp2 = dict_ptr(db, max_ent + 1);\r\nindx = dictp2->cptr;\r\ndictp3 = dict_ptr(db, indx);\r\nif (dictp3->codem1 == max_ent)\r\ndictp3->codem1 = BADCODEM1;\r\ndictp2->cptr = hval;\r\ndictp->codem1 = max_ent;\r\ndictp->fcode = fcode;\r\ndb->max_ent = ++max_ent;\r\nlens1 = lens_ptr(db, max_ent);\r\nlens2 = lens_ptr(db, oldcode);\r\n*lens1 = *lens2 + 1;\r\nif (max_ent >= MAXCODE(n_bits) && max_ent < db->maxmaxcode) {\r\ndb->n_bits = ++n_bits;\r\ntgtbitno = 32-n_bits;\r\n}\r\n}\r\noldcode = incode;\r\n}\r\n++db->comp_count;\r\n++db->uncomp_count;\r\ndb->comp_bytes += skb_in->len - BSD_OVHD;\r\ndb->uncomp_bytes += skb_out->len;\r\nif (bsd_check(db)) {\r\nif (db->debug)\r\nprintk(KERN_DEBUG "bsd_decomp%d: peer should have cleared dictionary on %d\n",\r\ndb->unit, db->seqno - 1);\r\n}\r\nreturn skb_out->len;\r\n}\r\nstatic int __init isdn_bsdcomp_init(void)\r\n{\r\nint answer = isdn_ppp_register_compressor(&ippp_bsd_compress);\r\nif (answer == 0)\r\nprintk(KERN_INFO "PPP BSD Compression module registered\n");\r\nreturn answer;\r\n}\r\nstatic void __exit isdn_bsdcomp_exit(void)\r\n{\r\nisdn_ppp_unregister_compressor(&ippp_bsd_compress);\r\n}
