static void __storm_memset_dma_mapping(struct bnx2x *bp,\r\nu32 addr, dma_addr_t mapping)\r\n{\r\nREG_WR(bp, addr, U64_LO(mapping));\r\nREG_WR(bp, addr + 4, U64_HI(mapping));\r\n}\r\nstatic void storm_memset_spq_addr(struct bnx2x *bp,\r\ndma_addr_t mapping, u16 abs_fid)\r\n{\r\nu32 addr = XSEM_REG_FAST_MEMORY +\r\nXSTORM_SPQ_PAGE_BASE_OFFSET(abs_fid);\r\n__storm_memset_dma_mapping(bp, addr, mapping);\r\n}\r\nstatic void storm_memset_vf_to_pf(struct bnx2x *bp, u16 abs_fid,\r\nu16 pf_id)\r\n{\r\nREG_WR8(bp, BAR_XSTRORM_INTMEM + XSTORM_VF_TO_PF_OFFSET(abs_fid),\r\npf_id);\r\nREG_WR8(bp, BAR_CSTRORM_INTMEM + CSTORM_VF_TO_PF_OFFSET(abs_fid),\r\npf_id);\r\nREG_WR8(bp, BAR_TSTRORM_INTMEM + TSTORM_VF_TO_PF_OFFSET(abs_fid),\r\npf_id);\r\nREG_WR8(bp, BAR_USTRORM_INTMEM + USTORM_VF_TO_PF_OFFSET(abs_fid),\r\npf_id);\r\n}\r\nstatic void storm_memset_func_en(struct bnx2x *bp, u16 abs_fid,\r\nu8 enable)\r\n{\r\nREG_WR8(bp, BAR_XSTRORM_INTMEM + XSTORM_FUNC_EN_OFFSET(abs_fid),\r\nenable);\r\nREG_WR8(bp, BAR_CSTRORM_INTMEM + CSTORM_FUNC_EN_OFFSET(abs_fid),\r\nenable);\r\nREG_WR8(bp, BAR_TSTRORM_INTMEM + TSTORM_FUNC_EN_OFFSET(abs_fid),\r\nenable);\r\nREG_WR8(bp, BAR_USTRORM_INTMEM + USTORM_FUNC_EN_OFFSET(abs_fid),\r\nenable);\r\n}\r\nstatic void storm_memset_eq_data(struct bnx2x *bp,\r\nstruct event_ring_data *eq_data,\r\nu16 pfid)\r\n{\r\nsize_t size = sizeof(struct event_ring_data);\r\nu32 addr = BAR_CSTRORM_INTMEM + CSTORM_EVENT_RING_DATA_OFFSET(pfid);\r\n__storm_memset_struct(bp, addr, size, (u32 *)eq_data);\r\n}\r\nstatic void storm_memset_eq_prod(struct bnx2x *bp, u16 eq_prod,\r\nu16 pfid)\r\n{\r\nu32 addr = BAR_CSTRORM_INTMEM + CSTORM_EVENT_RING_PROD_OFFSET(pfid);\r\nREG_WR16(bp, addr, eq_prod);\r\n}\r\nstatic void bnx2x_reg_wr_ind(struct bnx2x *bp, u32 addr, u32 val)\r\n{\r\npci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS, addr);\r\npci_write_config_dword(bp->pdev, PCICFG_GRC_DATA, val);\r\npci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS,\r\nPCICFG_VENDOR_ID_OFFSET);\r\n}\r\nstatic u32 bnx2x_reg_rd_ind(struct bnx2x *bp, u32 addr)\r\n{\r\nu32 val;\r\npci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS, addr);\r\npci_read_config_dword(bp->pdev, PCICFG_GRC_DATA, &val);\r\npci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS,\r\nPCICFG_VENDOR_ID_OFFSET);\r\nreturn val;\r\n}\r\nstatic void bnx2x_dp_dmae(struct bnx2x *bp,\r\nstruct dmae_command *dmae, int msglvl)\r\n{\r\nu32 src_type = dmae->opcode & DMAE_COMMAND_SRC;\r\nint i;\r\nswitch (dmae->opcode & DMAE_COMMAND_DST) {\r\ncase DMAE_CMD_DST_PCI:\r\nif (src_type == DMAE_CMD_SRC_PCI)\r\nDP(msglvl, "DMAE: opcode 0x%08x\n"\r\n"src [%x:%08x], len [%d*4], dst [%x:%08x]\n"\r\n"comp_addr [%x:%08x], comp_val 0x%08x\n",\r\ndmae->opcode, dmae->src_addr_hi, dmae->src_addr_lo,\r\ndmae->len, dmae->dst_addr_hi, dmae->dst_addr_lo,\r\ndmae->comp_addr_hi, dmae->comp_addr_lo,\r\ndmae->comp_val);\r\nelse\r\nDP(msglvl, "DMAE: opcode 0x%08x\n"\r\n"src [%08x], len [%d*4], dst [%x:%08x]\n"\r\n"comp_addr [%x:%08x], comp_val 0x%08x\n",\r\ndmae->opcode, dmae->src_addr_lo >> 2,\r\ndmae->len, dmae->dst_addr_hi, dmae->dst_addr_lo,\r\ndmae->comp_addr_hi, dmae->comp_addr_lo,\r\ndmae->comp_val);\r\nbreak;\r\ncase DMAE_CMD_DST_GRC:\r\nif (src_type == DMAE_CMD_SRC_PCI)\r\nDP(msglvl, "DMAE: opcode 0x%08x\n"\r\n"src [%x:%08x], len [%d*4], dst_addr [%08x]\n"\r\n"comp_addr [%x:%08x], comp_val 0x%08x\n",\r\ndmae->opcode, dmae->src_addr_hi, dmae->src_addr_lo,\r\ndmae->len, dmae->dst_addr_lo >> 2,\r\ndmae->comp_addr_hi, dmae->comp_addr_lo,\r\ndmae->comp_val);\r\nelse\r\nDP(msglvl, "DMAE: opcode 0x%08x\n"\r\n"src [%08x], len [%d*4], dst [%08x]\n"\r\n"comp_addr [%x:%08x], comp_val 0x%08x\n",\r\ndmae->opcode, dmae->src_addr_lo >> 2,\r\ndmae->len, dmae->dst_addr_lo >> 2,\r\ndmae->comp_addr_hi, dmae->comp_addr_lo,\r\ndmae->comp_val);\r\nbreak;\r\ndefault:\r\nif (src_type == DMAE_CMD_SRC_PCI)\r\nDP(msglvl, "DMAE: opcode 0x%08x\n"\r\n"src_addr [%x:%08x] len [%d * 4] dst_addr [none]\n"\r\n"comp_addr [%x:%08x] comp_val 0x%08x\n",\r\ndmae->opcode, dmae->src_addr_hi, dmae->src_addr_lo,\r\ndmae->len, dmae->comp_addr_hi, dmae->comp_addr_lo,\r\ndmae->comp_val);\r\nelse\r\nDP(msglvl, "DMAE: opcode 0x%08x\n"\r\n"src_addr [%08x] len [%d * 4] dst_addr [none]\n"\r\n"comp_addr [%x:%08x] comp_val 0x%08x\n",\r\ndmae->opcode, dmae->src_addr_lo >> 2,\r\ndmae->len, dmae->comp_addr_hi, dmae->comp_addr_lo,\r\ndmae->comp_val);\r\nbreak;\r\n}\r\nfor (i = 0; i < (sizeof(struct dmae_command)/4); i++)\r\nDP(msglvl, "DMAE RAW [%02d]: 0x%08x\n",\r\ni, *(((u32 *)dmae) + i));\r\n}\r\nvoid bnx2x_post_dmae(struct bnx2x *bp, struct dmae_command *dmae, int idx)\r\n{\r\nu32 cmd_offset;\r\nint i;\r\ncmd_offset = (DMAE_REG_CMD_MEM + sizeof(struct dmae_command) * idx);\r\nfor (i = 0; i < (sizeof(struct dmae_command)/4); i++) {\r\nREG_WR(bp, cmd_offset + i*4, *(((u32 *)dmae) + i));\r\n}\r\nREG_WR(bp, dmae_reg_go_c[idx], 1);\r\n}\r\nu32 bnx2x_dmae_opcode_add_comp(u32 opcode, u8 comp_type)\r\n{\r\nreturn opcode | ((comp_type << DMAE_COMMAND_C_DST_SHIFT) |\r\nDMAE_CMD_C_ENABLE);\r\n}\r\nu32 bnx2x_dmae_opcode_clr_src_reset(u32 opcode)\r\n{\r\nreturn opcode & ~DMAE_CMD_SRC_RESET;\r\n}\r\nu32 bnx2x_dmae_opcode(struct bnx2x *bp, u8 src_type, u8 dst_type,\r\nbool with_comp, u8 comp_type)\r\n{\r\nu32 opcode = 0;\r\nopcode |= ((src_type << DMAE_COMMAND_SRC_SHIFT) |\r\n(dst_type << DMAE_COMMAND_DST_SHIFT));\r\nopcode |= (DMAE_CMD_SRC_RESET | DMAE_CMD_DST_RESET);\r\nopcode |= (BP_PORT(bp) ? DMAE_CMD_PORT_1 : DMAE_CMD_PORT_0);\r\nopcode |= ((BP_VN(bp) << DMAE_CMD_E1HVN_SHIFT) |\r\n(BP_VN(bp) << DMAE_COMMAND_DST_VN_SHIFT));\r\nopcode |= (DMAE_COM_SET_ERR << DMAE_COMMAND_ERR_POLICY_SHIFT);\r\n#ifdef __BIG_ENDIAN\r\nopcode |= DMAE_CMD_ENDIANITY_B_DW_SWAP;\r\n#else\r\nopcode |= DMAE_CMD_ENDIANITY_DW_SWAP;\r\n#endif\r\nif (with_comp)\r\nopcode = bnx2x_dmae_opcode_add_comp(opcode, comp_type);\r\nreturn opcode;\r\n}\r\nvoid bnx2x_prep_dmae_with_comp(struct bnx2x *bp,\r\nstruct dmae_command *dmae,\r\nu8 src_type, u8 dst_type)\r\n{\r\nmemset(dmae, 0, sizeof(struct dmae_command));\r\ndmae->opcode = bnx2x_dmae_opcode(bp, src_type, dst_type,\r\ntrue, DMAE_COMP_PCI);\r\ndmae->comp_addr_lo = U64_LO(bnx2x_sp_mapping(bp, wb_comp));\r\ndmae->comp_addr_hi = U64_HI(bnx2x_sp_mapping(bp, wb_comp));\r\ndmae->comp_val = DMAE_COMP_VAL;\r\n}\r\nint bnx2x_issue_dmae_with_comp(struct bnx2x *bp, struct dmae_command *dmae,\r\nu32 *comp)\r\n{\r\nint cnt = CHIP_REV_IS_SLOW(bp) ? (400000) : 4000;\r\nint rc = 0;\r\nbnx2x_dp_dmae(bp, dmae, BNX2X_MSG_DMAE);\r\nspin_lock_bh(&bp->dmae_lock);\r\n*comp = 0;\r\nbnx2x_post_dmae(bp, dmae, INIT_DMAE_C(bp));\r\nudelay(5);\r\nwhile ((*comp & ~DMAE_PCI_ERR_FLAG) != DMAE_COMP_VAL) {\r\nif (!cnt ||\r\n(bp->recovery_state != BNX2X_RECOVERY_DONE &&\r\nbp->recovery_state != BNX2X_RECOVERY_NIC_LOADING)) {\r\nBNX2X_ERR("DMAE timeout!\n");\r\nrc = DMAE_TIMEOUT;\r\ngoto unlock;\r\n}\r\ncnt--;\r\nudelay(50);\r\n}\r\nif (*comp & DMAE_PCI_ERR_FLAG) {\r\nBNX2X_ERR("DMAE PCI error!\n");\r\nrc = DMAE_PCI_ERROR;\r\n}\r\nunlock:\r\nspin_unlock_bh(&bp->dmae_lock);\r\nreturn rc;\r\n}\r\nvoid bnx2x_write_dmae(struct bnx2x *bp, dma_addr_t dma_addr, u32 dst_addr,\r\nu32 len32)\r\n{\r\nint rc;\r\nstruct dmae_command dmae;\r\nif (!bp->dmae_ready) {\r\nu32 *data = bnx2x_sp(bp, wb_data[0]);\r\nif (CHIP_IS_E1(bp))\r\nbnx2x_init_ind_wr(bp, dst_addr, data, len32);\r\nelse\r\nbnx2x_init_str_wr(bp, dst_addr, data, len32);\r\nreturn;\r\n}\r\nbnx2x_prep_dmae_with_comp(bp, &dmae, DMAE_SRC_PCI, DMAE_DST_GRC);\r\ndmae.src_addr_lo = U64_LO(dma_addr);\r\ndmae.src_addr_hi = U64_HI(dma_addr);\r\ndmae.dst_addr_lo = dst_addr >> 2;\r\ndmae.dst_addr_hi = 0;\r\ndmae.len = len32;\r\nrc = bnx2x_issue_dmae_with_comp(bp, &dmae, bnx2x_sp(bp, wb_comp));\r\nif (rc) {\r\nBNX2X_ERR("DMAE returned failure %d\n", rc);\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nbnx2x_panic();\r\n#endif\r\n}\r\n}\r\nvoid bnx2x_read_dmae(struct bnx2x *bp, u32 src_addr, u32 len32)\r\n{\r\nint rc;\r\nstruct dmae_command dmae;\r\nif (!bp->dmae_ready) {\r\nu32 *data = bnx2x_sp(bp, wb_data[0]);\r\nint i;\r\nif (CHIP_IS_E1(bp))\r\nfor (i = 0; i < len32; i++)\r\ndata[i] = bnx2x_reg_rd_ind(bp, src_addr + i*4);\r\nelse\r\nfor (i = 0; i < len32; i++)\r\ndata[i] = REG_RD(bp, src_addr + i*4);\r\nreturn;\r\n}\r\nbnx2x_prep_dmae_with_comp(bp, &dmae, DMAE_SRC_GRC, DMAE_DST_PCI);\r\ndmae.src_addr_lo = src_addr >> 2;\r\ndmae.src_addr_hi = 0;\r\ndmae.dst_addr_lo = U64_LO(bnx2x_sp_mapping(bp, wb_data));\r\ndmae.dst_addr_hi = U64_HI(bnx2x_sp_mapping(bp, wb_data));\r\ndmae.len = len32;\r\nrc = bnx2x_issue_dmae_with_comp(bp, &dmae, bnx2x_sp(bp, wb_comp));\r\nif (rc) {\r\nBNX2X_ERR("DMAE returned failure %d\n", rc);\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nbnx2x_panic();\r\n#endif\r\n}\r\n}\r\nstatic void bnx2x_write_dmae_phys_len(struct bnx2x *bp, dma_addr_t phys_addr,\r\nu32 addr, u32 len)\r\n{\r\nint dmae_wr_max = DMAE_LEN32_WR_MAX(bp);\r\nint offset = 0;\r\nwhile (len > dmae_wr_max) {\r\nbnx2x_write_dmae(bp, phys_addr + offset,\r\naddr + offset, dmae_wr_max);\r\noffset += dmae_wr_max * 4;\r\nlen -= dmae_wr_max;\r\n}\r\nbnx2x_write_dmae(bp, phys_addr + offset, addr + offset, len);\r\n}\r\nstatic inline int bnx2x_get_assert_list_entry(struct bnx2x *bp,\r\nenum storms storm,\r\nint entry)\r\n{\r\nswitch (storm) {\r\ncase XSTORM:\r\nreturn XSTORM_ASSERT_LIST_OFFSET(entry);\r\ncase TSTORM:\r\nreturn TSTORM_ASSERT_LIST_OFFSET(entry);\r\ncase CSTORM:\r\nreturn CSTORM_ASSERT_LIST_OFFSET(entry);\r\ncase USTORM:\r\nreturn USTORM_ASSERT_LIST_OFFSET(entry);\r\ncase MAX_STORMS:\r\ndefault:\r\nBNX2X_ERR("unknown storm\n");\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int bnx2x_mc_assert(struct bnx2x *bp)\r\n{\r\nchar last_idx;\r\nint i, j, rc = 0;\r\nenum storms storm;\r\nu32 regs[REGS_IN_ENTRY];\r\nu32 bar_storm_intmem[STORMS_NUM] = {\r\nBAR_XSTRORM_INTMEM,\r\nBAR_TSTRORM_INTMEM,\r\nBAR_CSTRORM_INTMEM,\r\nBAR_USTRORM_INTMEM\r\n};\r\nu32 storm_assert_list_index[STORMS_NUM] = {\r\nXSTORM_ASSERT_LIST_INDEX_OFFSET,\r\nTSTORM_ASSERT_LIST_INDEX_OFFSET,\r\nCSTORM_ASSERT_LIST_INDEX_OFFSET,\r\nUSTORM_ASSERT_LIST_INDEX_OFFSET\r\n};\r\nchar *storms_string[STORMS_NUM] = {\r\n"XSTORM",\r\n"TSTORM",\r\n"CSTORM",\r\n"USTORM"\r\n};\r\nfor (storm = XSTORM; storm < MAX_STORMS; storm++) {\r\nlast_idx = REG_RD8(bp, bar_storm_intmem[storm] +\r\nstorm_assert_list_index[storm]);\r\nif (last_idx)\r\nBNX2X_ERR("%s_ASSERT_LIST_INDEX 0x%x\n",\r\nstorms_string[storm], last_idx);\r\nfor (i = 0; i < STROM_ASSERT_ARRAY_SIZE; i++) {\r\nfor (j = 0; j < REGS_IN_ENTRY; j++)\r\nregs[j] = REG_RD(bp, bar_storm_intmem[storm] +\r\nbnx2x_get_assert_list_entry(bp,\r\nstorm,\r\ni) +\r\nsizeof(u32) * j);\r\nif (regs[0] != COMMON_ASM_INVALID_ASSERT_OPCODE) {\r\nBNX2X_ERR("%s_ASSERT_INDEX 0x%x = 0x%08x 0x%08x 0x%08x 0x%08x\n",\r\nstorms_string[storm], i, regs[3],\r\nregs[2], regs[1], regs[0]);\r\nrc++;\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\nBNX2X_ERR("Chip Revision: %s, FW Version: %d_%d_%d\n",\r\nCHIP_IS_E1(bp) ? "everest1" :\r\nCHIP_IS_E1H(bp) ? "everest1h" :\r\nCHIP_IS_E2(bp) ? "everest2" : "everest3",\r\nBCM_5710_FW_MAJOR_VERSION,\r\nBCM_5710_FW_MINOR_VERSION,\r\nBCM_5710_FW_REVISION_VERSION);\r\nreturn rc;\r\n}\r\nvoid bnx2x_fw_dump_lvl(struct bnx2x *bp, const char *lvl)\r\n{\r\nu32 addr, val;\r\nu32 mark, offset;\r\n__be32 data[9];\r\nint word;\r\nu32 trace_shmem_base;\r\nif (BP_NOMCP(bp)) {\r\nBNX2X_ERR("NO MCP - can not dump\n");\r\nreturn;\r\n}\r\nnetdev_printk(lvl, bp->dev, "bc %d.%d.%d\n",\r\n(bp->common.bc_ver & 0xff0000) >> 16,\r\n(bp->common.bc_ver & 0xff00) >> 8,\r\n(bp->common.bc_ver & 0xff));\r\nif (pci_channel_offline(bp->pdev)) {\r\nBNX2X_ERR("Cannot dump MCP info while in PCI error\n");\r\nreturn;\r\n}\r\nval = REG_RD(bp, MCP_REG_MCPR_CPU_PROGRAM_COUNTER);\r\nif (val == REG_RD(bp, MCP_REG_MCPR_CPU_PROGRAM_COUNTER))\r\nBNX2X_ERR("%s" "MCP PC at 0x%x\n", lvl, val);\r\nif (BP_PATH(bp) == 0)\r\ntrace_shmem_base = bp->common.shmem_base;\r\nelse\r\ntrace_shmem_base = SHMEM2_RD(bp, other_shmem_base_addr);\r\nif (trace_shmem_base < MCPR_SCRATCH_BASE(bp) + MCPR_TRACE_BUFFER_SIZE ||\r\ntrace_shmem_base >= MCPR_SCRATCH_BASE(bp) +\r\nSCRATCH_BUFFER_SIZE(bp)) {\r\nBNX2X_ERR("Unable to dump trace buffer (mark %x)\n",\r\ntrace_shmem_base);\r\nreturn;\r\n}\r\naddr = trace_shmem_base - MCPR_TRACE_BUFFER_SIZE;\r\nmark = REG_RD(bp, addr);\r\nif (mark != MFW_TRACE_SIGNATURE) {\r\nBNX2X_ERR("Trace buffer signature is missing.");\r\nreturn ;\r\n}\r\naddr += 4;\r\nmark = REG_RD(bp, addr);\r\nmark = MCPR_SCRATCH_BASE(bp) + ((mark + 0x3) & ~0x3) - 0x08000000;\r\nif (mark >= trace_shmem_base || mark < addr + 4) {\r\nBNX2X_ERR("Mark doesn't fall inside Trace Buffer\n");\r\nreturn;\r\n}\r\nprintk("%s" "begin fw dump (mark 0x%x)\n", lvl, mark);\r\nprintk("%s", lvl);\r\nfor (offset = mark; offset < trace_shmem_base; offset += 0x8*4) {\r\nfor (word = 0; word < 8; word++)\r\ndata[word] = htonl(REG_RD(bp, offset + 4*word));\r\ndata[8] = 0x0;\r\npr_cont("%s", (char *)data);\r\n}\r\nfor (offset = addr + 4; offset <= mark; offset += 0x8*4) {\r\nfor (word = 0; word < 8; word++)\r\ndata[word] = htonl(REG_RD(bp, offset + 4*word));\r\ndata[8] = 0x0;\r\npr_cont("%s", (char *)data);\r\n}\r\nprintk("%s" "end of fw dump\n", lvl);\r\n}\r\nstatic void bnx2x_fw_dump(struct bnx2x *bp)\r\n{\r\nbnx2x_fw_dump_lvl(bp, KERN_ERR);\r\n}\r\nstatic void bnx2x_hc_int_disable(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nu32 addr = port ? HC_REG_CONFIG_1 : HC_REG_CONFIG_0;\r\nu32 val = REG_RD(bp, addr);\r\nif (CHIP_IS_E1(bp)) {\r\nREG_WR(bp, HC_REG_INT_MASK + port*4, 0);\r\nval &= ~(HC_CONFIG_0_REG_SINGLE_ISR_EN_0 |\r\nHC_CONFIG_0_REG_INT_LINE_EN_0 |\r\nHC_CONFIG_0_REG_ATTN_BIT_EN_0);\r\n} else\r\nval &= ~(HC_CONFIG_0_REG_SINGLE_ISR_EN_0 |\r\nHC_CONFIG_0_REG_MSI_MSIX_INT_EN_0 |\r\nHC_CONFIG_0_REG_INT_LINE_EN_0 |\r\nHC_CONFIG_0_REG_ATTN_BIT_EN_0);\r\nDP(NETIF_MSG_IFDOWN,\r\n"write %x to HC %d (addr 0x%x)\n",\r\nval, port, addr);\r\nmmiowb();\r\nREG_WR(bp, addr, val);\r\nif (REG_RD(bp, addr) != val)\r\nBNX2X_ERR("BUG! Proper val not read from IGU!\n");\r\n}\r\nstatic void bnx2x_igu_int_disable(struct bnx2x *bp)\r\n{\r\nu32 val = REG_RD(bp, IGU_REG_PF_CONFIGURATION);\r\nval &= ~(IGU_PF_CONF_MSI_MSIX_EN |\r\nIGU_PF_CONF_INT_LINE_EN |\r\nIGU_PF_CONF_ATTN_BIT_EN);\r\nDP(NETIF_MSG_IFDOWN, "write %x to IGU\n", val);\r\nmmiowb();\r\nREG_WR(bp, IGU_REG_PF_CONFIGURATION, val);\r\nif (REG_RD(bp, IGU_REG_PF_CONFIGURATION) != val)\r\nBNX2X_ERR("BUG! Proper val not read from IGU!\n");\r\n}\r\nstatic void bnx2x_int_disable(struct bnx2x *bp)\r\n{\r\nif (bp->common.int_block == INT_BLOCK_HC)\r\nbnx2x_hc_int_disable(bp);\r\nelse\r\nbnx2x_igu_int_disable(bp);\r\n}\r\nvoid bnx2x_panic_dump(struct bnx2x *bp, bool disable_int)\r\n{\r\nint i;\r\nu16 j;\r\nstruct hc_sp_status_block_data sp_sb_data;\r\nint func = BP_FUNC(bp);\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nu16 start = 0, end = 0;\r\nu8 cos;\r\n#endif\r\nif (IS_PF(bp) && disable_int)\r\nbnx2x_int_disable(bp);\r\nbp->stats_state = STATS_STATE_DISABLED;\r\nbp->eth_stats.unrecoverable_error++;\r\nDP(BNX2X_MSG_STATS, "stats_state - DISABLED\n");\r\nBNX2X_ERR("begin crash dump -----------------\n");\r\nif (IS_PF(bp)) {\r\nstruct host_sp_status_block *def_sb = bp->def_status_blk;\r\nint data_size, cstorm_offset;\r\nBNX2X_ERR("def_idx(0x%x) def_att_idx(0x%x) attn_state(0x%x) spq_prod_idx(0x%x) next_stats_cnt(0x%x)\n",\r\nbp->def_idx, bp->def_att_idx, bp->attn_state,\r\nbp->spq_prod_idx, bp->stats_counter);\r\nBNX2X_ERR("DSB: attn bits(0x%x) ack(0x%x) id(0x%x) idx(0x%x)\n",\r\ndef_sb->atten_status_block.attn_bits,\r\ndef_sb->atten_status_block.attn_bits_ack,\r\ndef_sb->atten_status_block.status_block_id,\r\ndef_sb->atten_status_block.attn_bits_index);\r\nBNX2X_ERR(" def (");\r\nfor (i = 0; i < HC_SP_SB_MAX_INDICES; i++)\r\npr_cont("0x%x%s",\r\ndef_sb->sp_sb.index_values[i],\r\n(i == HC_SP_SB_MAX_INDICES - 1) ? ") " : " ");\r\ndata_size = sizeof(struct hc_sp_status_block_data) /\r\nsizeof(u32);\r\ncstorm_offset = CSTORM_SP_STATUS_BLOCK_DATA_OFFSET(func);\r\nfor (i = 0; i < data_size; i++)\r\n*((u32 *)&sp_sb_data + i) =\r\nREG_RD(bp, BAR_CSTRORM_INTMEM + cstorm_offset +\r\ni * sizeof(u32));\r\npr_cont("igu_sb_id(0x%x) igu_seg_id(0x%x) pf_id(0x%x) vnic_id(0x%x) vf_id(0x%x) vf_valid (0x%x) state(0x%x)\n",\r\nsp_sb_data.igu_sb_id,\r\nsp_sb_data.igu_seg_id,\r\nsp_sb_data.p_func.pf_id,\r\nsp_sb_data.p_func.vnic_id,\r\nsp_sb_data.p_func.vf_id,\r\nsp_sb_data.p_func.vf_valid,\r\nsp_sb_data.state);\r\n}\r\nfor_each_eth_queue(bp, i) {\r\nstruct bnx2x_fastpath *fp = &bp->fp[i];\r\nint loop;\r\nstruct hc_status_block_data_e2 sb_data_e2;\r\nstruct hc_status_block_data_e1x sb_data_e1x;\r\nstruct hc_status_block_sm *hc_sm_p =\r\nCHIP_IS_E1x(bp) ?\r\nsb_data_e1x.common.state_machine :\r\nsb_data_e2.common.state_machine;\r\nstruct hc_index_data *hc_index_p =\r\nCHIP_IS_E1x(bp) ?\r\nsb_data_e1x.index_data :\r\nsb_data_e2.index_data;\r\nu8 data_size, cos;\r\nu32 *sb_data_p;\r\nstruct bnx2x_fp_txdata txdata;\r\nif (!bp->fp)\r\nbreak;\r\nif (!fp->rx_cons_sb)\r\ncontinue;\r\nBNX2X_ERR("fp%d: rx_bd_prod(0x%x) rx_bd_cons(0x%x) rx_comp_prod(0x%x) rx_comp_cons(0x%x) *rx_cons_sb(0x%x)\n",\r\ni, fp->rx_bd_prod, fp->rx_bd_cons,\r\nfp->rx_comp_prod,\r\nfp->rx_comp_cons, le16_to_cpu(*fp->rx_cons_sb));\r\nBNX2X_ERR(" rx_sge_prod(0x%x) last_max_sge(0x%x) fp_hc_idx(0x%x)\n",\r\nfp->rx_sge_prod, fp->last_max_sge,\r\nle16_to_cpu(fp->fp_hc_idx));\r\nfor_each_cos_in_tx_queue(fp, cos)\r\n{\r\nif (!fp->txdata_ptr[cos])\r\nbreak;\r\ntxdata = *fp->txdata_ptr[cos];\r\nif (!txdata.tx_cons_sb)\r\ncontinue;\r\nBNX2X_ERR("fp%d: tx_pkt_prod(0x%x) tx_pkt_cons(0x%x) tx_bd_prod(0x%x) tx_bd_cons(0x%x) *tx_cons_sb(0x%x)\n",\r\ni, txdata.tx_pkt_prod,\r\ntxdata.tx_pkt_cons, txdata.tx_bd_prod,\r\ntxdata.tx_bd_cons,\r\nle16_to_cpu(*txdata.tx_cons_sb));\r\n}\r\nloop = CHIP_IS_E1x(bp) ?\r\nHC_SB_MAX_INDICES_E1X : HC_SB_MAX_INDICES_E2;\r\nif (IS_FCOE_FP(fp))\r\ncontinue;\r\nBNX2X_ERR(" run indexes (");\r\nfor (j = 0; j < HC_SB_MAX_SM; j++)\r\npr_cont("0x%x%s",\r\nfp->sb_running_index[j],\r\n(j == HC_SB_MAX_SM - 1) ? ")" : " ");\r\nBNX2X_ERR(" indexes (");\r\nfor (j = 0; j < loop; j++)\r\npr_cont("0x%x%s",\r\nfp->sb_index_values[j],\r\n(j == loop - 1) ? ")" : " ");\r\nif (IS_VF(bp))\r\ncontinue;\r\ndata_size = CHIP_IS_E1x(bp) ?\r\nsizeof(struct hc_status_block_data_e1x) :\r\nsizeof(struct hc_status_block_data_e2);\r\ndata_size /= sizeof(u32);\r\nsb_data_p = CHIP_IS_E1x(bp) ?\r\n(u32 *)&sb_data_e1x :\r\n(u32 *)&sb_data_e2;\r\nfor (j = 0; j < data_size; j++)\r\n*(sb_data_p + j) = REG_RD(bp, BAR_CSTRORM_INTMEM +\r\nCSTORM_STATUS_BLOCK_DATA_OFFSET(fp->fw_sb_id) +\r\nj * sizeof(u32));\r\nif (!CHIP_IS_E1x(bp)) {\r\npr_cont("pf_id(0x%x) vf_id(0x%x) vf_valid(0x%x) vnic_id(0x%x) same_igu_sb_1b(0x%x) state(0x%x)\n",\r\nsb_data_e2.common.p_func.pf_id,\r\nsb_data_e2.common.p_func.vf_id,\r\nsb_data_e2.common.p_func.vf_valid,\r\nsb_data_e2.common.p_func.vnic_id,\r\nsb_data_e2.common.same_igu_sb_1b,\r\nsb_data_e2.common.state);\r\n} else {\r\npr_cont("pf_id(0x%x) vf_id(0x%x) vf_valid(0x%x) vnic_id(0x%x) same_igu_sb_1b(0x%x) state(0x%x)\n",\r\nsb_data_e1x.common.p_func.pf_id,\r\nsb_data_e1x.common.p_func.vf_id,\r\nsb_data_e1x.common.p_func.vf_valid,\r\nsb_data_e1x.common.p_func.vnic_id,\r\nsb_data_e1x.common.same_igu_sb_1b,\r\nsb_data_e1x.common.state);\r\n}\r\nfor (j = 0; j < HC_SB_MAX_SM; j++) {\r\npr_cont("SM[%d] __flags (0x%x) igu_sb_id (0x%x) igu_seg_id(0x%x) time_to_expire (0x%x) timer_value(0x%x)\n",\r\nj, hc_sm_p[j].__flags,\r\nhc_sm_p[j].igu_sb_id,\r\nhc_sm_p[j].igu_seg_id,\r\nhc_sm_p[j].time_to_expire,\r\nhc_sm_p[j].timer_value);\r\n}\r\nfor (j = 0; j < loop; j++) {\r\npr_cont("INDEX[%d] flags (0x%x) timeout (0x%x)\n", j,\r\nhc_index_p[j].flags,\r\nhc_index_p[j].timeout);\r\n}\r\n}\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nif (IS_PF(bp)) {\r\nBNX2X_ERR("eq cons %x prod %x\n", bp->eq_cons, bp->eq_prod);\r\nfor (i = 0; i < NUM_EQ_DESC; i++) {\r\nu32 *data = (u32 *)&bp->eq_ring[i].message.data;\r\nBNX2X_ERR("event queue [%d]: header: opcode %d, error %d\n",\r\ni, bp->eq_ring[i].message.opcode,\r\nbp->eq_ring[i].message.error);\r\nBNX2X_ERR("data: %x %x %x\n",\r\ndata[0], data[1], data[2]);\r\n}\r\n}\r\nfor_each_valid_rx_queue(bp, i) {\r\nstruct bnx2x_fastpath *fp = &bp->fp[i];\r\nif (!bp->fp)\r\nbreak;\r\nif (!fp->rx_cons_sb)\r\ncontinue;\r\nstart = RX_BD(le16_to_cpu(*fp->rx_cons_sb) - 10);\r\nend = RX_BD(le16_to_cpu(*fp->rx_cons_sb) + 503);\r\nfor (j = start; j != end; j = RX_BD(j + 1)) {\r\nu32 *rx_bd = (u32 *)&fp->rx_desc_ring[j];\r\nstruct sw_rx_bd *sw_bd = &fp->rx_buf_ring[j];\r\nBNX2X_ERR("fp%d: rx_bd[%x]=[%x:%x] sw_bd=[%p]\n",\r\ni, j, rx_bd[1], rx_bd[0], sw_bd->data);\r\n}\r\nstart = RX_SGE(fp->rx_sge_prod);\r\nend = RX_SGE(fp->last_max_sge);\r\nfor (j = start; j != end; j = RX_SGE(j + 1)) {\r\nu32 *rx_sge = (u32 *)&fp->rx_sge_ring[j];\r\nstruct sw_rx_page *sw_page = &fp->rx_page_ring[j];\r\nBNX2X_ERR("fp%d: rx_sge[%x]=[%x:%x] sw_page=[%p]\n",\r\ni, j, rx_sge[1], rx_sge[0], sw_page->page);\r\n}\r\nstart = RCQ_BD(fp->rx_comp_cons - 10);\r\nend = RCQ_BD(fp->rx_comp_cons + 503);\r\nfor (j = start; j != end; j = RCQ_BD(j + 1)) {\r\nu32 *cqe = (u32 *)&fp->rx_comp_ring[j];\r\nBNX2X_ERR("fp%d: cqe[%x]=[%x:%x:%x:%x]\n",\r\ni, j, cqe[0], cqe[1], cqe[2], cqe[3]);\r\n}\r\n}\r\nfor_each_valid_tx_queue(bp, i) {\r\nstruct bnx2x_fastpath *fp = &bp->fp[i];\r\nif (!bp->fp)\r\nbreak;\r\nfor_each_cos_in_tx_queue(fp, cos) {\r\nstruct bnx2x_fp_txdata *txdata = fp->txdata_ptr[cos];\r\nif (!fp->txdata_ptr[cos])\r\nbreak;\r\nif (!txdata->tx_cons_sb)\r\ncontinue;\r\nstart = TX_BD(le16_to_cpu(*txdata->tx_cons_sb) - 10);\r\nend = TX_BD(le16_to_cpu(*txdata->tx_cons_sb) + 245);\r\nfor (j = start; j != end; j = TX_BD(j + 1)) {\r\nstruct sw_tx_bd *sw_bd =\r\n&txdata->tx_buf_ring[j];\r\nBNX2X_ERR("fp%d: txdata %d, packet[%x]=[%p,%x]\n",\r\ni, cos, j, sw_bd->skb,\r\nsw_bd->first_bd);\r\n}\r\nstart = TX_BD(txdata->tx_bd_cons - 10);\r\nend = TX_BD(txdata->tx_bd_cons + 254);\r\nfor (j = start; j != end; j = TX_BD(j + 1)) {\r\nu32 *tx_bd = (u32 *)&txdata->tx_desc_ring[j];\r\nBNX2X_ERR("fp%d: txdata %d, tx_bd[%x]=[%x:%x:%x:%x]\n",\r\ni, cos, j, tx_bd[0], tx_bd[1],\r\ntx_bd[2], tx_bd[3]);\r\n}\r\n}\r\n}\r\n#endif\r\nif (IS_PF(bp)) {\r\nbnx2x_fw_dump(bp);\r\nbnx2x_mc_assert(bp);\r\n}\r\nBNX2X_ERR("end crash dump -----------------\n");\r\n}\r\nstatic void bnx2x_pbf_pN_buf_flushed(struct bnx2x *bp,\r\nstruct pbf_pN_buf_regs *regs,\r\nu32 poll_count)\r\n{\r\nu32 init_crd, crd, crd_start, crd_freed, crd_freed_start;\r\nu32 cur_cnt = poll_count;\r\ncrd_freed = crd_freed_start = REG_RD(bp, regs->crd_freed);\r\ncrd = crd_start = REG_RD(bp, regs->crd);\r\ninit_crd = REG_RD(bp, regs->init_crd);\r\nDP(BNX2X_MSG_SP, "INIT CREDIT[%d] : %x\n", regs->pN, init_crd);\r\nDP(BNX2X_MSG_SP, "CREDIT[%d] : s:%x\n", regs->pN, crd);\r\nDP(BNX2X_MSG_SP, "CREDIT_FREED[%d]: s:%x\n", regs->pN, crd_freed);\r\nwhile ((crd != init_crd) && ((u32)SUB_S32(crd_freed, crd_freed_start) <\r\n(init_crd - crd_start))) {\r\nif (cur_cnt--) {\r\nudelay(FLR_WAIT_INTERVAL);\r\ncrd = REG_RD(bp, regs->crd);\r\ncrd_freed = REG_RD(bp, regs->crd_freed);\r\n} else {\r\nDP(BNX2X_MSG_SP, "PBF tx buffer[%d] timed out\n",\r\nregs->pN);\r\nDP(BNX2X_MSG_SP, "CREDIT[%d] : c:%x\n",\r\nregs->pN, crd);\r\nDP(BNX2X_MSG_SP, "CREDIT_FREED[%d]: c:%x\n",\r\nregs->pN, crd_freed);\r\nbreak;\r\n}\r\n}\r\nDP(BNX2X_MSG_SP, "Waited %d*%d usec for PBF tx buffer[%d]\n",\r\npoll_count-cur_cnt, FLR_WAIT_INTERVAL, regs->pN);\r\n}\r\nstatic void bnx2x_pbf_pN_cmd_flushed(struct bnx2x *bp,\r\nstruct pbf_pN_cmd_regs *regs,\r\nu32 poll_count)\r\n{\r\nu32 occup, to_free, freed, freed_start;\r\nu32 cur_cnt = poll_count;\r\noccup = to_free = REG_RD(bp, regs->lines_occup);\r\nfreed = freed_start = REG_RD(bp, regs->lines_freed);\r\nDP(BNX2X_MSG_SP, "OCCUPANCY[%d] : s:%x\n", regs->pN, occup);\r\nDP(BNX2X_MSG_SP, "LINES_FREED[%d] : s:%x\n", regs->pN, freed);\r\nwhile (occup && ((u32)SUB_S32(freed, freed_start) < to_free)) {\r\nif (cur_cnt--) {\r\nudelay(FLR_WAIT_INTERVAL);\r\noccup = REG_RD(bp, regs->lines_occup);\r\nfreed = REG_RD(bp, regs->lines_freed);\r\n} else {\r\nDP(BNX2X_MSG_SP, "PBF cmd queue[%d] timed out\n",\r\nregs->pN);\r\nDP(BNX2X_MSG_SP, "OCCUPANCY[%d] : s:%x\n",\r\nregs->pN, occup);\r\nDP(BNX2X_MSG_SP, "LINES_FREED[%d] : s:%x\n",\r\nregs->pN, freed);\r\nbreak;\r\n}\r\n}\r\nDP(BNX2X_MSG_SP, "Waited %d*%d usec for PBF cmd queue[%d]\n",\r\npoll_count-cur_cnt, FLR_WAIT_INTERVAL, regs->pN);\r\n}\r\nstatic u32 bnx2x_flr_clnup_reg_poll(struct bnx2x *bp, u32 reg,\r\nu32 expected, u32 poll_count)\r\n{\r\nu32 cur_cnt = poll_count;\r\nu32 val;\r\nwhile ((val = REG_RD(bp, reg)) != expected && cur_cnt--)\r\nudelay(FLR_WAIT_INTERVAL);\r\nreturn val;\r\n}\r\nint bnx2x_flr_clnup_poll_hw_counter(struct bnx2x *bp, u32 reg,\r\nchar *msg, u32 poll_cnt)\r\n{\r\nu32 val = bnx2x_flr_clnup_reg_poll(bp, reg, 0, poll_cnt);\r\nif (val != 0) {\r\nBNX2X_ERR("%s usage count=%d\n", msg, val);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nu32 bnx2x_flr_clnup_poll_count(struct bnx2x *bp)\r\n{\r\nif (CHIP_REV_IS_EMUL(bp))\r\nreturn FLR_POLL_CNT * 2000;\r\nif (CHIP_REV_IS_FPGA(bp))\r\nreturn FLR_POLL_CNT * 120;\r\nreturn FLR_POLL_CNT;\r\n}\r\nvoid bnx2x_tx_hw_flushed(struct bnx2x *bp, u32 poll_count)\r\n{\r\nstruct pbf_pN_cmd_regs cmd_regs[] = {\r\n{0, (CHIP_IS_E3B0(bp)) ?\r\nPBF_REG_TQ_OCCUPANCY_Q0 :\r\nPBF_REG_P0_TQ_OCCUPANCY,\r\n(CHIP_IS_E3B0(bp)) ?\r\nPBF_REG_TQ_LINES_FREED_CNT_Q0 :\r\nPBF_REG_P0_TQ_LINES_FREED_CNT},\r\n{1, (CHIP_IS_E3B0(bp)) ?\r\nPBF_REG_TQ_OCCUPANCY_Q1 :\r\nPBF_REG_P1_TQ_OCCUPANCY,\r\n(CHIP_IS_E3B0(bp)) ?\r\nPBF_REG_TQ_LINES_FREED_CNT_Q1 :\r\nPBF_REG_P1_TQ_LINES_FREED_CNT},\r\n{4, (CHIP_IS_E3B0(bp)) ?\r\nPBF_REG_TQ_OCCUPANCY_LB_Q :\r\nPBF_REG_P4_TQ_OCCUPANCY,\r\n(CHIP_IS_E3B0(bp)) ?\r\nPBF_REG_TQ_LINES_FREED_CNT_LB_Q :\r\nPBF_REG_P4_TQ_LINES_FREED_CNT}\r\n};\r\nstruct pbf_pN_buf_regs buf_regs[] = {\r\n{0, (CHIP_IS_E3B0(bp)) ?\r\nPBF_REG_INIT_CRD_Q0 :\r\nPBF_REG_P0_INIT_CRD ,\r\n(CHIP_IS_E3B0(bp)) ?\r\nPBF_REG_CREDIT_Q0 :\r\nPBF_REG_P0_CREDIT,\r\n(CHIP_IS_E3B0(bp)) ?\r\nPBF_REG_INTERNAL_CRD_FREED_CNT_Q0 :\r\nPBF_REG_P0_INTERNAL_CRD_FREED_CNT},\r\n{1, (CHIP_IS_E3B0(bp)) ?\r\nPBF_REG_INIT_CRD_Q1 :\r\nPBF_REG_P1_INIT_CRD,\r\n(CHIP_IS_E3B0(bp)) ?\r\nPBF_REG_CREDIT_Q1 :\r\nPBF_REG_P1_CREDIT,\r\n(CHIP_IS_E3B0(bp)) ?\r\nPBF_REG_INTERNAL_CRD_FREED_CNT_Q1 :\r\nPBF_REG_P1_INTERNAL_CRD_FREED_CNT},\r\n{4, (CHIP_IS_E3B0(bp)) ?\r\nPBF_REG_INIT_CRD_LB_Q :\r\nPBF_REG_P4_INIT_CRD,\r\n(CHIP_IS_E3B0(bp)) ?\r\nPBF_REG_CREDIT_LB_Q :\r\nPBF_REG_P4_CREDIT,\r\n(CHIP_IS_E3B0(bp)) ?\r\nPBF_REG_INTERNAL_CRD_FREED_CNT_LB_Q :\r\nPBF_REG_P4_INTERNAL_CRD_FREED_CNT},\r\n};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cmd_regs); i++)\r\nbnx2x_pbf_pN_cmd_flushed(bp, &cmd_regs[i], poll_count);\r\nfor (i = 0; i < ARRAY_SIZE(buf_regs); i++)\r\nbnx2x_pbf_pN_buf_flushed(bp, &buf_regs[i], poll_count);\r\n}\r\nint bnx2x_send_final_clnup(struct bnx2x *bp, u8 clnup_func, u32 poll_cnt)\r\n{\r\nu32 op_gen_command = 0;\r\nu32 comp_addr = BAR_CSTRORM_INTMEM +\r\nCSTORM_FINAL_CLEANUP_COMPLETE_OFFSET(clnup_func);\r\nint ret = 0;\r\nif (REG_RD(bp, comp_addr)) {\r\nBNX2X_ERR("Cleanup complete was not 0 before sending\n");\r\nreturn 1;\r\n}\r\nop_gen_command |= OP_GEN_PARAM(XSTORM_AGG_INT_FINAL_CLEANUP_INDEX);\r\nop_gen_command |= OP_GEN_TYPE(XSTORM_AGG_INT_FINAL_CLEANUP_COMP_TYPE);\r\nop_gen_command |= OP_GEN_AGG_VECT(clnup_func);\r\nop_gen_command |= 1 << SDM_OP_GEN_AGG_VECT_IDX_VALID_SHIFT;\r\nDP(BNX2X_MSG_SP, "sending FW Final cleanup\n");\r\nREG_WR(bp, XSDM_REG_OPERATION_GEN, op_gen_command);\r\nif (bnx2x_flr_clnup_reg_poll(bp, comp_addr, 1, poll_cnt) != 1) {\r\nBNX2X_ERR("FW final cleanup did not succeed\n");\r\nDP(BNX2X_MSG_SP, "At timeout completion address contained %x\n",\r\n(REG_RD(bp, comp_addr)));\r\nbnx2x_panic();\r\nreturn 1;\r\n}\r\nREG_WR(bp, comp_addr, 0);\r\nreturn ret;\r\n}\r\nu8 bnx2x_is_pcie_pending(struct pci_dev *dev)\r\n{\r\nu16 status;\r\npcie_capability_read_word(dev, PCI_EXP_DEVSTA, &status);\r\nreturn status & PCI_EXP_DEVSTA_TRPND;\r\n}\r\nstatic int bnx2x_poll_hw_usage_counters(struct bnx2x *bp, u32 poll_cnt)\r\n{\r\nif (bnx2x_flr_clnup_poll_hw_counter(bp,\r\nCFC_REG_NUM_LCIDS_INSIDE_PF,\r\n"CFC PF usage counter timed out",\r\npoll_cnt))\r\nreturn 1;\r\nif (bnx2x_flr_clnup_poll_hw_counter(bp,\r\nDORQ_REG_PF_USAGE_CNT,\r\n"DQ PF usage counter timed out",\r\npoll_cnt))\r\nreturn 1;\r\nif (bnx2x_flr_clnup_poll_hw_counter(bp,\r\nQM_REG_PF_USG_CNT_0 + 4*BP_FUNC(bp),\r\n"QM PF usage counter timed out",\r\npoll_cnt))\r\nreturn 1;\r\nif (bnx2x_flr_clnup_poll_hw_counter(bp,\r\nTM_REG_LIN0_VNIC_UC + 4*BP_PORT(bp),\r\n"Timers VNIC usage counter timed out",\r\npoll_cnt))\r\nreturn 1;\r\nif (bnx2x_flr_clnup_poll_hw_counter(bp,\r\nTM_REG_LIN0_NUM_SCANS + 4*BP_PORT(bp),\r\n"Timers NUM_SCANS usage counter timed out",\r\npoll_cnt))\r\nreturn 1;\r\nif (bnx2x_flr_clnup_poll_hw_counter(bp,\r\ndmae_reg_go_c[INIT_DMAE_C(bp)],\r\n"DMAE command register timed out",\r\npoll_cnt))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void bnx2x_hw_enable_status(struct bnx2x *bp)\r\n{\r\nu32 val;\r\nval = REG_RD(bp, CFC_REG_WEAK_ENABLE_PF);\r\nDP(BNX2X_MSG_SP, "CFC_REG_WEAK_ENABLE_PF is 0x%x\n", val);\r\nval = REG_RD(bp, PBF_REG_DISABLE_PF);\r\nDP(BNX2X_MSG_SP, "PBF_REG_DISABLE_PF is 0x%x\n", val);\r\nval = REG_RD(bp, IGU_REG_PCI_PF_MSI_EN);\r\nDP(BNX2X_MSG_SP, "IGU_REG_PCI_PF_MSI_EN is 0x%x\n", val);\r\nval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_EN);\r\nDP(BNX2X_MSG_SP, "IGU_REG_PCI_PF_MSIX_EN is 0x%x\n", val);\r\nval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_FUNC_MASK);\r\nDP(BNX2X_MSG_SP, "IGU_REG_PCI_PF_MSIX_FUNC_MASK is 0x%x\n", val);\r\nval = REG_RD(bp, PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR);\r\nDP(BNX2X_MSG_SP, "PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR is 0x%x\n", val);\r\nval = REG_RD(bp, PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR);\r\nDP(BNX2X_MSG_SP, "PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR is 0x%x\n", val);\r\nval = REG_RD(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER);\r\nDP(BNX2X_MSG_SP, "PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER is 0x%x\n",\r\nval);\r\n}\r\nstatic int bnx2x_pf_flr_clnup(struct bnx2x *bp)\r\n{\r\nu32 poll_cnt = bnx2x_flr_clnup_poll_count(bp);\r\nDP(BNX2X_MSG_SP, "Cleanup after FLR PF[%d]\n", BP_ABS_FUNC(bp));\r\nREG_WR(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_TARGET_READ, 1);\r\nDP(BNX2X_MSG_SP, "Polling usage counters\n");\r\nif (bnx2x_poll_hw_usage_counters(bp, poll_cnt))\r\nreturn -EBUSY;\r\nif (bnx2x_send_final_clnup(bp, (u8)BP_FUNC(bp), poll_cnt))\r\nreturn -EBUSY;\r\nbnx2x_tx_hw_flushed(bp, poll_cnt);\r\nmsleep(100);\r\nif (bnx2x_is_pcie_pending(bp->pdev))\r\nBNX2X_ERR("PCIE Transactions still pending\n");\r\nbnx2x_hw_enable_status(bp);\r\nREG_WR(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER, 1);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_hc_int_enable(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nu32 addr = port ? HC_REG_CONFIG_1 : HC_REG_CONFIG_0;\r\nu32 val = REG_RD(bp, addr);\r\nbool msix = (bp->flags & USING_MSIX_FLAG) ? true : false;\r\nbool single_msix = (bp->flags & USING_SINGLE_MSIX_FLAG) ? true : false;\r\nbool msi = (bp->flags & USING_MSI_FLAG) ? true : false;\r\nif (msix) {\r\nval &= ~(HC_CONFIG_0_REG_SINGLE_ISR_EN_0 |\r\nHC_CONFIG_0_REG_INT_LINE_EN_0);\r\nval |= (HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0 |\r\nHC_CONFIG_0_REG_ATTN_BIT_EN_0);\r\nif (single_msix)\r\nval |= HC_CONFIG_0_REG_SINGLE_ISR_EN_0;\r\n} else if (msi) {\r\nval &= ~HC_CONFIG_0_REG_INT_LINE_EN_0;\r\nval |= (HC_CONFIG_0_REG_SINGLE_ISR_EN_0 |\r\nHC_CONFIG_0_REG_MSI_MSIX_INT_EN_0 |\r\nHC_CONFIG_0_REG_ATTN_BIT_EN_0);\r\n} else {\r\nval |= (HC_CONFIG_0_REG_SINGLE_ISR_EN_0 |\r\nHC_CONFIG_0_REG_MSI_MSIX_INT_EN_0 |\r\nHC_CONFIG_0_REG_INT_LINE_EN_0 |\r\nHC_CONFIG_0_REG_ATTN_BIT_EN_0);\r\nif (!CHIP_IS_E1(bp)) {\r\nDP(NETIF_MSG_IFUP,\r\n"write %x to HC %d (addr 0x%x)\n", val, port, addr);\r\nREG_WR(bp, addr, val);\r\nval &= ~HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0;\r\n}\r\n}\r\nif (CHIP_IS_E1(bp))\r\nREG_WR(bp, HC_REG_INT_MASK + port*4, 0x1FFFF);\r\nDP(NETIF_MSG_IFUP,\r\n"write %x to HC %d (addr 0x%x) mode %s\n", val, port, addr,\r\n(msix ? "MSI-X" : (msi ? "MSI" : "INTx")));\r\nREG_WR(bp, addr, val);\r\nmmiowb();\r\nbarrier();\r\nif (!CHIP_IS_E1(bp)) {\r\nif (IS_MF(bp)) {\r\nval = (0xee0f | (1 << (BP_VN(bp) + 4)));\r\nif (bp->port.pmf)\r\nval |= 0x1100;\r\n} else\r\nval = 0xffff;\r\nREG_WR(bp, HC_REG_TRAILING_EDGE_0 + port*8, val);\r\nREG_WR(bp, HC_REG_LEADING_EDGE_0 + port*8, val);\r\n}\r\nmmiowb();\r\n}\r\nstatic void bnx2x_igu_int_enable(struct bnx2x *bp)\r\n{\r\nu32 val;\r\nbool msix = (bp->flags & USING_MSIX_FLAG) ? true : false;\r\nbool single_msix = (bp->flags & USING_SINGLE_MSIX_FLAG) ? true : false;\r\nbool msi = (bp->flags & USING_MSI_FLAG) ? true : false;\r\nval = REG_RD(bp, IGU_REG_PF_CONFIGURATION);\r\nif (msix) {\r\nval &= ~(IGU_PF_CONF_INT_LINE_EN |\r\nIGU_PF_CONF_SINGLE_ISR_EN);\r\nval |= (IGU_PF_CONF_MSI_MSIX_EN |\r\nIGU_PF_CONF_ATTN_BIT_EN);\r\nif (single_msix)\r\nval |= IGU_PF_CONF_SINGLE_ISR_EN;\r\n} else if (msi) {\r\nval &= ~IGU_PF_CONF_INT_LINE_EN;\r\nval |= (IGU_PF_CONF_MSI_MSIX_EN |\r\nIGU_PF_CONF_ATTN_BIT_EN |\r\nIGU_PF_CONF_SINGLE_ISR_EN);\r\n} else {\r\nval &= ~IGU_PF_CONF_MSI_MSIX_EN;\r\nval |= (IGU_PF_CONF_INT_LINE_EN |\r\nIGU_PF_CONF_ATTN_BIT_EN |\r\nIGU_PF_CONF_SINGLE_ISR_EN);\r\n}\r\nif ((!msix) || single_msix) {\r\nREG_WR(bp, IGU_REG_PF_CONFIGURATION, val);\r\nbnx2x_ack_int(bp);\r\n}\r\nval |= IGU_PF_CONF_FUNC_EN;\r\nDP(NETIF_MSG_IFUP, "write 0x%x to IGU mode %s\n",\r\nval, (msix ? "MSI-X" : (msi ? "MSI" : "INTx")));\r\nREG_WR(bp, IGU_REG_PF_CONFIGURATION, val);\r\nif (val & IGU_PF_CONF_INT_LINE_EN)\r\npci_intx(bp->pdev, true);\r\nbarrier();\r\nif (IS_MF(bp)) {\r\nval = (0xee0f | (1 << (BP_VN(bp) + 4)));\r\nif (bp->port.pmf)\r\nval |= 0x1100;\r\n} else\r\nval = 0xffff;\r\nREG_WR(bp, IGU_REG_TRAILING_EDGE_LATCH, val);\r\nREG_WR(bp, IGU_REG_LEADING_EDGE_LATCH, val);\r\nmmiowb();\r\n}\r\nvoid bnx2x_int_enable(struct bnx2x *bp)\r\n{\r\nif (bp->common.int_block == INT_BLOCK_HC)\r\nbnx2x_hc_int_enable(bp);\r\nelse\r\nbnx2x_igu_int_enable(bp);\r\n}\r\nvoid bnx2x_int_disable_sync(struct bnx2x *bp, int disable_hw)\r\n{\r\nint msix = (bp->flags & USING_MSIX_FLAG) ? 1 : 0;\r\nint i, offset;\r\nif (disable_hw)\r\nbnx2x_int_disable(bp);\r\nif (msix) {\r\nsynchronize_irq(bp->msix_table[0].vector);\r\noffset = 1;\r\nif (CNIC_SUPPORT(bp))\r\noffset++;\r\nfor_each_eth_queue(bp, i)\r\nsynchronize_irq(bp->msix_table[offset++].vector);\r\n} else\r\nsynchronize_irq(bp->pdev->irq);\r\ncancel_delayed_work(&bp->sp_task);\r\ncancel_delayed_work(&bp->period_task);\r\nflush_workqueue(bnx2x_wq);\r\n}\r\nstatic bool bnx2x_trylock_hw_lock(struct bnx2x *bp, u32 resource)\r\n{\r\nu32 lock_status;\r\nu32 resource_bit = (1 << resource);\r\nint func = BP_FUNC(bp);\r\nu32 hw_lock_control_reg;\r\nDP(NETIF_MSG_HW | NETIF_MSG_IFUP,\r\n"Trying to take a lock on resource %d\n", resource);\r\nif (resource > HW_LOCK_MAX_RESOURCE_VALUE) {\r\nDP(NETIF_MSG_HW | NETIF_MSG_IFUP,\r\n"resource(0x%x) > HW_LOCK_MAX_RESOURCE_VALUE(0x%x)\n",\r\nresource, HW_LOCK_MAX_RESOURCE_VALUE);\r\nreturn false;\r\n}\r\nif (func <= 5)\r\nhw_lock_control_reg = (MISC_REG_DRIVER_CONTROL_1 + func*8);\r\nelse\r\nhw_lock_control_reg =\r\n(MISC_REG_DRIVER_CONTROL_7 + (func - 6)*8);\r\nREG_WR(bp, hw_lock_control_reg + 4, resource_bit);\r\nlock_status = REG_RD(bp, hw_lock_control_reg);\r\nif (lock_status & resource_bit)\r\nreturn true;\r\nDP(NETIF_MSG_HW | NETIF_MSG_IFUP,\r\n"Failed to get a lock on resource %d\n", resource);\r\nreturn false;\r\n}\r\nstatic int bnx2x_get_leader_lock_resource(struct bnx2x *bp)\r\n{\r\nif (BP_PATH(bp))\r\nreturn HW_LOCK_RESOURCE_RECOVERY_LEADER_1;\r\nelse\r\nreturn HW_LOCK_RESOURCE_RECOVERY_LEADER_0;\r\n}\r\nstatic bool bnx2x_trylock_leader_lock(struct bnx2x *bp)\r\n{\r\nreturn bnx2x_trylock_hw_lock(bp, bnx2x_get_leader_lock_resource(bp));\r\n}\r\nstatic int bnx2x_schedule_sp_task(struct bnx2x *bp)\r\n{\r\natomic_set(&bp->interrupt_occurred, 1);\r\nsmp_wmb();\r\nreturn queue_delayed_work(bnx2x_wq, &bp->sp_task, 0);\r\n}\r\nvoid bnx2x_sp_event(struct bnx2x_fastpath *fp, union eth_rx_cqe *rr_cqe)\r\n{\r\nstruct bnx2x *bp = fp->bp;\r\nint cid = SW_CID(rr_cqe->ramrod_cqe.conn_and_cmd_data);\r\nint command = CQE_CMD(rr_cqe->ramrod_cqe.conn_and_cmd_data);\r\nenum bnx2x_queue_cmd drv_cmd = BNX2X_Q_CMD_MAX;\r\nstruct bnx2x_queue_sp_obj *q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\r\nDP(BNX2X_MSG_SP,\r\n"fp %d cid %d got ramrod #%d state is %x type is %d\n",\r\nfp->index, cid, command, bp->state,\r\nrr_cqe->ramrod_cqe.ramrod_type);\r\nif (cid >= BNX2X_FIRST_VF_CID &&\r\ncid < BNX2X_FIRST_VF_CID + BNX2X_VF_CIDS)\r\nbnx2x_iov_set_queue_sp_obj(bp, cid, &q_obj);\r\nswitch (command) {\r\ncase (RAMROD_CMD_ID_ETH_CLIENT_UPDATE):\r\nDP(BNX2X_MSG_SP, "got UPDATE ramrod. CID %d\n", cid);\r\ndrv_cmd = BNX2X_Q_CMD_UPDATE;\r\nbreak;\r\ncase (RAMROD_CMD_ID_ETH_CLIENT_SETUP):\r\nDP(BNX2X_MSG_SP, "got MULTI[%d] setup ramrod\n", cid);\r\ndrv_cmd = BNX2X_Q_CMD_SETUP;\r\nbreak;\r\ncase (RAMROD_CMD_ID_ETH_TX_QUEUE_SETUP):\r\nDP(BNX2X_MSG_SP, "got MULTI[%d] tx-only setup ramrod\n", cid);\r\ndrv_cmd = BNX2X_Q_CMD_SETUP_TX_ONLY;\r\nbreak;\r\ncase (RAMROD_CMD_ID_ETH_HALT):\r\nDP(BNX2X_MSG_SP, "got MULTI[%d] halt ramrod\n", cid);\r\ndrv_cmd = BNX2X_Q_CMD_HALT;\r\nbreak;\r\ncase (RAMROD_CMD_ID_ETH_TERMINATE):\r\nDP(BNX2X_MSG_SP, "got MULTI[%d] terminate ramrod\n", cid);\r\ndrv_cmd = BNX2X_Q_CMD_TERMINATE;\r\nbreak;\r\ncase (RAMROD_CMD_ID_ETH_EMPTY):\r\nDP(BNX2X_MSG_SP, "got MULTI[%d] empty ramrod\n", cid);\r\ndrv_cmd = BNX2X_Q_CMD_EMPTY;\r\nbreak;\r\ncase (RAMROD_CMD_ID_ETH_TPA_UPDATE):\r\nDP(BNX2X_MSG_SP, "got tpa update ramrod CID=%d\n", cid);\r\ndrv_cmd = BNX2X_Q_CMD_UPDATE_TPA;\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("unexpected MC reply (%d) on fp[%d]\n",\r\ncommand, fp->index);\r\nreturn;\r\n}\r\nif ((drv_cmd != BNX2X_Q_CMD_MAX) &&\r\nq_obj->complete_cmd(bp, q_obj, drv_cmd))\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nbnx2x_panic();\r\n#else\r\nreturn;\r\n#endif\r\nsmp_mb__before_atomic();\r\natomic_inc(&bp->cq_spq_left);\r\nsmp_mb__after_atomic();\r\nDP(BNX2X_MSG_SP, "bp->cq_spq_left %x\n", atomic_read(&bp->cq_spq_left));\r\nif ((drv_cmd == BNX2X_Q_CMD_UPDATE) && (IS_FCOE_FP(fp)) &&\r\n(!!test_bit(BNX2X_AFEX_FCOE_Q_UPDATE_PENDING, &bp->sp_state))) {\r\nsmp_mb__before_atomic();\r\nset_bit(BNX2X_AFEX_PENDING_VIFSET_MCP_ACK, &bp->sp_state);\r\nwmb();\r\nclear_bit(BNX2X_AFEX_FCOE_Q_UPDATE_PENDING, &bp->sp_state);\r\nsmp_mb__after_atomic();\r\nbnx2x_schedule_sp_task(bp);\r\n}\r\nreturn;\r\n}\r\nirqreturn_t bnx2x_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev_instance);\r\nu16 status = bnx2x_ack_int(bp);\r\nu16 mask;\r\nint i;\r\nu8 cos;\r\nif (unlikely(status == 0)) {\r\nDP(NETIF_MSG_INTR, "not our interrupt!\n");\r\nreturn IRQ_NONE;\r\n}\r\nDP(NETIF_MSG_INTR, "got an interrupt status 0x%x\n", status);\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nif (unlikely(bp->panic))\r\nreturn IRQ_HANDLED;\r\n#endif\r\nfor_each_eth_queue(bp, i) {\r\nstruct bnx2x_fastpath *fp = &bp->fp[i];\r\nmask = 0x2 << (fp->index + CNIC_SUPPORT(bp));\r\nif (status & mask) {\r\nfor_each_cos_in_tx_queue(fp, cos)\r\nprefetch(fp->txdata_ptr[cos]->tx_cons_sb);\r\nprefetch(&fp->sb_running_index[SM_RX_ID]);\r\nnapi_schedule_irqoff(&bnx2x_fp(bp, fp->index, napi));\r\nstatus &= ~mask;\r\n}\r\n}\r\nif (CNIC_SUPPORT(bp)) {\r\nmask = 0x2;\r\nif (status & (mask | 0x1)) {\r\nstruct cnic_ops *c_ops = NULL;\r\nrcu_read_lock();\r\nc_ops = rcu_dereference(bp->cnic_ops);\r\nif (c_ops && (bp->cnic_eth_dev.drv_state &\r\nCNIC_DRV_STATE_HANDLES_IRQ))\r\nc_ops->cnic_handler(bp->cnic_data, NULL);\r\nrcu_read_unlock();\r\nstatus &= ~mask;\r\n}\r\n}\r\nif (unlikely(status & 0x1)) {\r\nbnx2x_schedule_sp_task(bp);\r\nstatus &= ~0x1;\r\nif (!status)\r\nreturn IRQ_HANDLED;\r\n}\r\nif (unlikely(status))\r\nDP(NETIF_MSG_INTR, "got an unknown interrupt! (status 0x%x)\n",\r\nstatus);\r\nreturn IRQ_HANDLED;\r\n}\r\nint bnx2x_acquire_hw_lock(struct bnx2x *bp, u32 resource)\r\n{\r\nu32 lock_status;\r\nu32 resource_bit = (1 << resource);\r\nint func = BP_FUNC(bp);\r\nu32 hw_lock_control_reg;\r\nint cnt;\r\nif (resource > HW_LOCK_MAX_RESOURCE_VALUE) {\r\nBNX2X_ERR("resource(0x%x) > HW_LOCK_MAX_RESOURCE_VALUE(0x%x)\n",\r\nresource, HW_LOCK_MAX_RESOURCE_VALUE);\r\nreturn -EINVAL;\r\n}\r\nif (func <= 5) {\r\nhw_lock_control_reg = (MISC_REG_DRIVER_CONTROL_1 + func*8);\r\n} else {\r\nhw_lock_control_reg =\r\n(MISC_REG_DRIVER_CONTROL_7 + (func - 6)*8);\r\n}\r\nlock_status = REG_RD(bp, hw_lock_control_reg);\r\nif (lock_status & resource_bit) {\r\nBNX2X_ERR("lock_status 0x%x resource_bit 0x%x\n",\r\nlock_status, resource_bit);\r\nreturn -EEXIST;\r\n}\r\nfor (cnt = 0; cnt < 1000; cnt++) {\r\nREG_WR(bp, hw_lock_control_reg + 4, resource_bit);\r\nlock_status = REG_RD(bp, hw_lock_control_reg);\r\nif (lock_status & resource_bit)\r\nreturn 0;\r\nusleep_range(5000, 10000);\r\n}\r\nBNX2X_ERR("Timeout\n");\r\nreturn -EAGAIN;\r\n}\r\nint bnx2x_release_leader_lock(struct bnx2x *bp)\r\n{\r\nreturn bnx2x_release_hw_lock(bp, bnx2x_get_leader_lock_resource(bp));\r\n}\r\nint bnx2x_release_hw_lock(struct bnx2x *bp, u32 resource)\r\n{\r\nu32 lock_status;\r\nu32 resource_bit = (1 << resource);\r\nint func = BP_FUNC(bp);\r\nu32 hw_lock_control_reg;\r\nif (resource > HW_LOCK_MAX_RESOURCE_VALUE) {\r\nBNX2X_ERR("resource(0x%x) > HW_LOCK_MAX_RESOURCE_VALUE(0x%x)\n",\r\nresource, HW_LOCK_MAX_RESOURCE_VALUE);\r\nreturn -EINVAL;\r\n}\r\nif (func <= 5) {\r\nhw_lock_control_reg = (MISC_REG_DRIVER_CONTROL_1 + func*8);\r\n} else {\r\nhw_lock_control_reg =\r\n(MISC_REG_DRIVER_CONTROL_7 + (func - 6)*8);\r\n}\r\nlock_status = REG_RD(bp, hw_lock_control_reg);\r\nif (!(lock_status & resource_bit)) {\r\nBNX2X_ERR("lock_status 0x%x resource_bit 0x%x. Unlock was called but lock wasn't taken!\n",\r\nlock_status, resource_bit);\r\nreturn -EFAULT;\r\n}\r\nREG_WR(bp, hw_lock_control_reg, resource_bit);\r\nreturn 0;\r\n}\r\nint bnx2x_get_gpio(struct bnx2x *bp, int gpio_num, u8 port)\r\n{\r\nint gpio_port = (REG_RD(bp, NIG_REG_PORT_SWAP) &&\r\nREG_RD(bp, NIG_REG_STRAP_OVERRIDE)) ^ port;\r\nint gpio_shift = gpio_num +\r\n(gpio_port ? MISC_REGISTERS_GPIO_PORT_SHIFT : 0);\r\nu32 gpio_mask = (1 << gpio_shift);\r\nu32 gpio_reg;\r\nint value;\r\nif (gpio_num > MISC_REGISTERS_GPIO_3) {\r\nBNX2X_ERR("Invalid GPIO %d\n", gpio_num);\r\nreturn -EINVAL;\r\n}\r\ngpio_reg = REG_RD(bp, MISC_REG_GPIO);\r\nif ((gpio_reg & gpio_mask) == gpio_mask)\r\nvalue = 1;\r\nelse\r\nvalue = 0;\r\nreturn value;\r\n}\r\nint bnx2x_set_gpio(struct bnx2x *bp, int gpio_num, u32 mode, u8 port)\r\n{\r\nint gpio_port = (REG_RD(bp, NIG_REG_PORT_SWAP) &&\r\nREG_RD(bp, NIG_REG_STRAP_OVERRIDE)) ^ port;\r\nint gpio_shift = gpio_num +\r\n(gpio_port ? MISC_REGISTERS_GPIO_PORT_SHIFT : 0);\r\nu32 gpio_mask = (1 << gpio_shift);\r\nu32 gpio_reg;\r\nif (gpio_num > MISC_REGISTERS_GPIO_3) {\r\nBNX2X_ERR("Invalid GPIO %d\n", gpio_num);\r\nreturn -EINVAL;\r\n}\r\nbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);\r\ngpio_reg = (REG_RD(bp, MISC_REG_GPIO) & MISC_REGISTERS_GPIO_FLOAT);\r\nswitch (mode) {\r\ncase MISC_REGISTERS_GPIO_OUTPUT_LOW:\r\nDP(NETIF_MSG_LINK,\r\n"Set GPIO %d (shift %d) -> output low\n",\r\ngpio_num, gpio_shift);\r\ngpio_reg &= ~(gpio_mask << MISC_REGISTERS_GPIO_FLOAT_POS);\r\ngpio_reg |= (gpio_mask << MISC_REGISTERS_GPIO_CLR_POS);\r\nbreak;\r\ncase MISC_REGISTERS_GPIO_OUTPUT_HIGH:\r\nDP(NETIF_MSG_LINK,\r\n"Set GPIO %d (shift %d) -> output high\n",\r\ngpio_num, gpio_shift);\r\ngpio_reg &= ~(gpio_mask << MISC_REGISTERS_GPIO_FLOAT_POS);\r\ngpio_reg |= (gpio_mask << MISC_REGISTERS_GPIO_SET_POS);\r\nbreak;\r\ncase MISC_REGISTERS_GPIO_INPUT_HI_Z:\r\nDP(NETIF_MSG_LINK,\r\n"Set GPIO %d (shift %d) -> input\n",\r\ngpio_num, gpio_shift);\r\ngpio_reg |= (gpio_mask << MISC_REGISTERS_GPIO_FLOAT_POS);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nREG_WR(bp, MISC_REG_GPIO, gpio_reg);\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);\r\nreturn 0;\r\n}\r\nint bnx2x_set_mult_gpio(struct bnx2x *bp, u8 pins, u32 mode)\r\n{\r\nu32 gpio_reg = 0;\r\nint rc = 0;\r\nbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);\r\ngpio_reg = REG_RD(bp, MISC_REG_GPIO);\r\ngpio_reg &= ~(pins << MISC_REGISTERS_GPIO_FLOAT_POS);\r\ngpio_reg &= ~(pins << MISC_REGISTERS_GPIO_CLR_POS);\r\ngpio_reg &= ~(pins << MISC_REGISTERS_GPIO_SET_POS);\r\nswitch (mode) {\r\ncase MISC_REGISTERS_GPIO_OUTPUT_LOW:\r\nDP(NETIF_MSG_LINK, "Set GPIO 0x%x -> output low\n", pins);\r\ngpio_reg |= (pins << MISC_REGISTERS_GPIO_CLR_POS);\r\nbreak;\r\ncase MISC_REGISTERS_GPIO_OUTPUT_HIGH:\r\nDP(NETIF_MSG_LINK, "Set GPIO 0x%x -> output high\n", pins);\r\ngpio_reg |= (pins << MISC_REGISTERS_GPIO_SET_POS);\r\nbreak;\r\ncase MISC_REGISTERS_GPIO_INPUT_HI_Z:\r\nDP(NETIF_MSG_LINK, "Set GPIO 0x%x -> input\n", pins);\r\ngpio_reg |= (pins << MISC_REGISTERS_GPIO_FLOAT_POS);\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Invalid GPIO mode assignment %d\n", mode);\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nif (rc == 0)\r\nREG_WR(bp, MISC_REG_GPIO, gpio_reg);\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);\r\nreturn rc;\r\n}\r\nint bnx2x_set_gpio_int(struct bnx2x *bp, int gpio_num, u32 mode, u8 port)\r\n{\r\nint gpio_port = (REG_RD(bp, NIG_REG_PORT_SWAP) &&\r\nREG_RD(bp, NIG_REG_STRAP_OVERRIDE)) ^ port;\r\nint gpio_shift = gpio_num +\r\n(gpio_port ? MISC_REGISTERS_GPIO_PORT_SHIFT : 0);\r\nu32 gpio_mask = (1 << gpio_shift);\r\nu32 gpio_reg;\r\nif (gpio_num > MISC_REGISTERS_GPIO_3) {\r\nBNX2X_ERR("Invalid GPIO %d\n", gpio_num);\r\nreturn -EINVAL;\r\n}\r\nbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);\r\ngpio_reg = REG_RD(bp, MISC_REG_GPIO_INT);\r\nswitch (mode) {\r\ncase MISC_REGISTERS_GPIO_INT_OUTPUT_CLR:\r\nDP(NETIF_MSG_LINK,\r\n"Clear GPIO INT %d (shift %d) -> output low\n",\r\ngpio_num, gpio_shift);\r\ngpio_reg &= ~(gpio_mask << MISC_REGISTERS_GPIO_INT_SET_POS);\r\ngpio_reg |= (gpio_mask << MISC_REGISTERS_GPIO_INT_CLR_POS);\r\nbreak;\r\ncase MISC_REGISTERS_GPIO_INT_OUTPUT_SET:\r\nDP(NETIF_MSG_LINK,\r\n"Set GPIO INT %d (shift %d) -> output high\n",\r\ngpio_num, gpio_shift);\r\ngpio_reg &= ~(gpio_mask << MISC_REGISTERS_GPIO_INT_CLR_POS);\r\ngpio_reg |= (gpio_mask << MISC_REGISTERS_GPIO_INT_SET_POS);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nREG_WR(bp, MISC_REG_GPIO_INT, gpio_reg);\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_set_spio(struct bnx2x *bp, int spio, u32 mode)\r\n{\r\nu32 spio_reg;\r\nif ((spio != MISC_SPIO_SPIO4) && (spio != MISC_SPIO_SPIO5)) {\r\nBNX2X_ERR("Invalid SPIO 0x%x\n", spio);\r\nreturn -EINVAL;\r\n}\r\nbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_SPIO);\r\nspio_reg = (REG_RD(bp, MISC_REG_SPIO) & MISC_SPIO_FLOAT);\r\nswitch (mode) {\r\ncase MISC_SPIO_OUTPUT_LOW:\r\nDP(NETIF_MSG_HW, "Set SPIO 0x%x -> output low\n", spio);\r\nspio_reg &= ~(spio << MISC_SPIO_FLOAT_POS);\r\nspio_reg |= (spio << MISC_SPIO_CLR_POS);\r\nbreak;\r\ncase MISC_SPIO_OUTPUT_HIGH:\r\nDP(NETIF_MSG_HW, "Set SPIO 0x%x -> output high\n", spio);\r\nspio_reg &= ~(spio << MISC_SPIO_FLOAT_POS);\r\nspio_reg |= (spio << MISC_SPIO_SET_POS);\r\nbreak;\r\ncase MISC_SPIO_INPUT_HI_Z:\r\nDP(NETIF_MSG_HW, "Set SPIO 0x%x -> input\n", spio);\r\nspio_reg |= (spio << MISC_SPIO_FLOAT_POS);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nREG_WR(bp, MISC_REG_SPIO, spio_reg);\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_SPIO);\r\nreturn 0;\r\n}\r\nvoid bnx2x_calc_fc_adv(struct bnx2x *bp)\r\n{\r\nu8 cfg_idx = bnx2x_get_link_cfg_idx(bp);\r\nbp->port.advertising[cfg_idx] &= ~(ADVERTISED_Asym_Pause |\r\nADVERTISED_Pause);\r\nswitch (bp->link_vars.ieee_fc &\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK) {\r\ncase MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH:\r\nbp->port.advertising[cfg_idx] |= (ADVERTISED_Asym_Pause |\r\nADVERTISED_Pause);\r\nbreak;\r\ncase MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC:\r\nbp->port.advertising[cfg_idx] |= ADVERTISED_Asym_Pause;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void bnx2x_set_requested_fc(struct bnx2x *bp)\r\n{\r\nif (CHIP_IS_E1x(bp) && (bp->dev->mtu > 5000))\r\nbp->link_params.req_fc_auto_adv = BNX2X_FLOW_CTRL_TX;\r\nelse\r\nbp->link_params.req_fc_auto_adv = BNX2X_FLOW_CTRL_BOTH;\r\n}\r\nstatic void bnx2x_init_dropless_fc(struct bnx2x *bp)\r\n{\r\nu32 pause_enabled = 0;\r\nif (!CHIP_IS_E1(bp) && bp->dropless_fc && bp->link_vars.link_up) {\r\nif (bp->link_vars.flow_ctrl & BNX2X_FLOW_CTRL_TX)\r\npause_enabled = 1;\r\nREG_WR(bp, BAR_USTRORM_INTMEM +\r\nUSTORM_ETH_PAUSE_ENABLED_OFFSET(BP_PORT(bp)),\r\npause_enabled);\r\n}\r\nDP(NETIF_MSG_IFUP | NETIF_MSG_LINK, "dropless_fc is %s\n",\r\npause_enabled ? "enabled" : "disabled");\r\n}\r\nint bnx2x_initial_phy_init(struct bnx2x *bp, int load_mode)\r\n{\r\nint rc, cfx_idx = bnx2x_get_link_cfg_idx(bp);\r\nu16 req_line_speed = bp->link_params.req_line_speed[cfx_idx];\r\nif (!BP_NOMCP(bp)) {\r\nbnx2x_set_requested_fc(bp);\r\nbnx2x_acquire_phy_lock(bp);\r\nif (load_mode == LOAD_DIAG) {\r\nstruct link_params *lp = &bp->link_params;\r\nlp->loopback_mode = LOOPBACK_XGXS;\r\nif (lp->req_line_speed[cfx_idx] < SPEED_20000) {\r\nif (lp->speed_cap_mask[cfx_idx] &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_20G)\r\nlp->req_line_speed[cfx_idx] =\r\nSPEED_20000;\r\nelse if (lp->speed_cap_mask[cfx_idx] &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10G)\r\nlp->req_line_speed[cfx_idx] =\r\nSPEED_10000;\r\nelse\r\nlp->req_line_speed[cfx_idx] =\r\nSPEED_1000;\r\n}\r\n}\r\nif (load_mode == LOAD_LOOPBACK_EXT) {\r\nstruct link_params *lp = &bp->link_params;\r\nlp->loopback_mode = LOOPBACK_EXT;\r\n}\r\nrc = bnx2x_phy_init(&bp->link_params, &bp->link_vars);\r\nbnx2x_release_phy_lock(bp);\r\nbnx2x_init_dropless_fc(bp);\r\nbnx2x_calc_fc_adv(bp);\r\nif (bp->link_vars.link_up) {\r\nbnx2x_stats_handle(bp, STATS_EVENT_LINK_UP);\r\nbnx2x_link_report(bp);\r\n}\r\nqueue_delayed_work(bnx2x_wq, &bp->period_task, 0);\r\nbp->link_params.req_line_speed[cfx_idx] = req_line_speed;\r\nreturn rc;\r\n}\r\nBNX2X_ERR("Bootcode is missing - can not initialize link\n");\r\nreturn -EINVAL;\r\n}\r\nvoid bnx2x_link_set(struct bnx2x *bp)\r\n{\r\nif (!BP_NOMCP(bp)) {\r\nbnx2x_acquire_phy_lock(bp);\r\nbnx2x_phy_init(&bp->link_params, &bp->link_vars);\r\nbnx2x_release_phy_lock(bp);\r\nbnx2x_init_dropless_fc(bp);\r\nbnx2x_calc_fc_adv(bp);\r\n} else\r\nBNX2X_ERR("Bootcode is missing - can not set link\n");\r\n}\r\nstatic void bnx2x__link_reset(struct bnx2x *bp)\r\n{\r\nif (!BP_NOMCP(bp)) {\r\nbnx2x_acquire_phy_lock(bp);\r\nbnx2x_lfa_reset(&bp->link_params, &bp->link_vars);\r\nbnx2x_release_phy_lock(bp);\r\n} else\r\nBNX2X_ERR("Bootcode is missing - can not reset link\n");\r\n}\r\nvoid bnx2x_force_link_reset(struct bnx2x *bp)\r\n{\r\nbnx2x_acquire_phy_lock(bp);\r\nbnx2x_link_reset(&bp->link_params, &bp->link_vars, 1);\r\nbnx2x_release_phy_lock(bp);\r\n}\r\nu8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)\r\n{\r\nu8 rc = 0;\r\nif (!BP_NOMCP(bp)) {\r\nbnx2x_acquire_phy_lock(bp);\r\nrc = bnx2x_test_link(&bp->link_params, &bp->link_vars,\r\nis_serdes);\r\nbnx2x_release_phy_lock(bp);\r\n} else\r\nBNX2X_ERR("Bootcode is missing - can not test link\n");\r\nreturn rc;\r\n}\r\nstatic void bnx2x_calc_vn_min(struct bnx2x *bp,\r\nstruct cmng_init_input *input)\r\n{\r\nint all_zero = 1;\r\nint vn;\r\nfor (vn = VN_0; vn < BP_MAX_VN_NUM(bp); vn++) {\r\nu32 vn_cfg = bp->mf_config[vn];\r\nu32 vn_min_rate = ((vn_cfg & FUNC_MF_CFG_MIN_BW_MASK) >>\r\nFUNC_MF_CFG_MIN_BW_SHIFT) * 100;\r\nif (vn_cfg & FUNC_MF_CFG_FUNC_HIDE)\r\nvn_min_rate = 0;\r\nelse if (!vn_min_rate)\r\nvn_min_rate = DEF_MIN_RATE;\r\nelse\r\nall_zero = 0;\r\ninput->vnic_min_rate[vn] = vn_min_rate;\r\n}\r\nif (BNX2X_IS_ETS_ENABLED(bp)) {\r\ninput->flags.cmng_enables &=\r\n~CMNG_FLAGS_PER_PORT_FAIRNESS_VN;\r\nDP(NETIF_MSG_IFUP, "Fairness will be disabled due to ETS\n");\r\n} else if (all_zero) {\r\ninput->flags.cmng_enables &=\r\n~CMNG_FLAGS_PER_PORT_FAIRNESS_VN;\r\nDP(NETIF_MSG_IFUP,\r\n"All MIN values are zeroes fairness will be disabled\n");\r\n} else\r\ninput->flags.cmng_enables |=\r\nCMNG_FLAGS_PER_PORT_FAIRNESS_VN;\r\n}\r\nstatic void bnx2x_calc_vn_max(struct bnx2x *bp, int vn,\r\nstruct cmng_init_input *input)\r\n{\r\nu16 vn_max_rate;\r\nu32 vn_cfg = bp->mf_config[vn];\r\nif (vn_cfg & FUNC_MF_CFG_FUNC_HIDE)\r\nvn_max_rate = 0;\r\nelse {\r\nu32 maxCfg = bnx2x_extract_max_cfg(bp, vn_cfg);\r\nif (IS_MF_PERCENT_BW(bp)) {\r\nvn_max_rate = (bp->link_vars.line_speed * maxCfg) / 100;\r\n} else\r\nvn_max_rate = maxCfg * 100;\r\n}\r\nDP(NETIF_MSG_IFUP, "vn %d: vn_max_rate %d\n", vn, vn_max_rate);\r\ninput->vnic_max_rate[vn] = vn_max_rate;\r\n}\r\nstatic int bnx2x_get_cmng_fns_mode(struct bnx2x *bp)\r\n{\r\nif (CHIP_REV_IS_SLOW(bp))\r\nreturn CMNG_FNS_NONE;\r\nif (IS_MF(bp))\r\nreturn CMNG_FNS_MINMAX;\r\nreturn CMNG_FNS_NONE;\r\n}\r\nvoid bnx2x_read_mf_cfg(struct bnx2x *bp)\r\n{\r\nint vn, n = (CHIP_MODE_IS_4_PORT(bp) ? 2 : 1);\r\nif (BP_NOMCP(bp))\r\nreturn;\r\nfor (vn = VN_0; vn < BP_MAX_VN_NUM(bp); vn++) {\r\nint func = n * (2 * vn + BP_PORT(bp)) + BP_PATH(bp);\r\nif (func >= E1H_FUNC_MAX)\r\nbreak;\r\nbp->mf_config[vn] =\r\nMF_CFG_RD(bp, func_mf_config[func].config);\r\n}\r\nif (bp->mf_config[BP_VN(bp)] & FUNC_MF_CFG_FUNC_DISABLED) {\r\nDP(NETIF_MSG_IFUP, "mf_cfg function disabled\n");\r\nbp->flags |= MF_FUNC_DIS;\r\n} else {\r\nDP(NETIF_MSG_IFUP, "mf_cfg function enabled\n");\r\nbp->flags &= ~MF_FUNC_DIS;\r\n}\r\n}\r\nstatic void bnx2x_cmng_fns_init(struct bnx2x *bp, u8 read_cfg, u8 cmng_type)\r\n{\r\nstruct cmng_init_input input;\r\nmemset(&input, 0, sizeof(struct cmng_init_input));\r\ninput.port_rate = bp->link_vars.line_speed;\r\nif (cmng_type == CMNG_FNS_MINMAX && input.port_rate) {\r\nint vn;\r\nif (read_cfg)\r\nbnx2x_read_mf_cfg(bp);\r\nbnx2x_calc_vn_min(bp, &input);\r\nif (bp->port.pmf)\r\nfor (vn = VN_0; vn < BP_MAX_VN_NUM(bp); vn++)\r\nbnx2x_calc_vn_max(bp, vn, &input);\r\ninput.flags.cmng_enables |=\r\nCMNG_FLAGS_PER_PORT_RATE_SHAPING_VN;\r\nbnx2x_init_cmng(&input, &bp->cmng);\r\nreturn;\r\n}\r\nDP(NETIF_MSG_IFUP,\r\n"rate shaping and fairness are disabled\n");\r\n}\r\nstatic void storm_memset_cmng(struct bnx2x *bp,\r\nstruct cmng_init *cmng,\r\nu8 port)\r\n{\r\nint vn;\r\nsize_t size = sizeof(struct cmng_struct_per_port);\r\nu32 addr = BAR_XSTRORM_INTMEM +\r\nXSTORM_CMNG_PER_PORT_VARS_OFFSET(port);\r\n__storm_memset_struct(bp, addr, size, (u32 *)&cmng->port);\r\nfor (vn = VN_0; vn < BP_MAX_VN_NUM(bp); vn++) {\r\nint func = func_by_vn(bp, vn);\r\naddr = BAR_XSTRORM_INTMEM +\r\nXSTORM_RATE_SHAPING_PER_VN_VARS_OFFSET(func);\r\nsize = sizeof(struct rate_shaping_vars_per_vn);\r\n__storm_memset_struct(bp, addr, size,\r\n(u32 *)&cmng->vnic.vnic_max_rate[vn]);\r\naddr = BAR_XSTRORM_INTMEM +\r\nXSTORM_FAIRNESS_PER_VN_VARS_OFFSET(func);\r\nsize = sizeof(struct fairness_vars_per_vn);\r\n__storm_memset_struct(bp, addr, size,\r\n(u32 *)&cmng->vnic.vnic_min_rate[vn]);\r\n}\r\n}\r\nvoid bnx2x_set_local_cmng(struct bnx2x *bp)\r\n{\r\nint cmng_fns = bnx2x_get_cmng_fns_mode(bp);\r\nif (cmng_fns != CMNG_FNS_NONE) {\r\nbnx2x_cmng_fns_init(bp, false, cmng_fns);\r\nstorm_memset_cmng(bp, &bp->cmng, BP_PORT(bp));\r\n} else {\r\nDP(NETIF_MSG_IFUP,\r\n"single function mode without fairness\n");\r\n}\r\n}\r\nstatic void bnx2x_link_attn(struct bnx2x *bp)\r\n{\r\nbnx2x_stats_handle(bp, STATS_EVENT_STOP);\r\nbnx2x_link_update(&bp->link_params, &bp->link_vars);\r\nbnx2x_init_dropless_fc(bp);\r\nif (bp->link_vars.link_up) {\r\nif (bp->link_vars.mac_type != MAC_TYPE_EMAC) {\r\nstruct host_port_stats *pstats;\r\npstats = bnx2x_sp(bp, port_stats);\r\nmemset(&(pstats->mac_stx[0]), 0,\r\nsizeof(struct mac_stx));\r\n}\r\nif (bp->state == BNX2X_STATE_OPEN)\r\nbnx2x_stats_handle(bp, STATS_EVENT_LINK_UP);\r\n}\r\nif (bp->link_vars.link_up && bp->link_vars.line_speed)\r\nbnx2x_set_local_cmng(bp);\r\n__bnx2x_link_report(bp);\r\nif (IS_MF(bp))\r\nbnx2x_link_sync_notify(bp);\r\n}\r\nvoid bnx2x__link_status_update(struct bnx2x *bp)\r\n{\r\nif (bp->state != BNX2X_STATE_OPEN)\r\nreturn;\r\nif (IS_PF(bp)) {\r\nbnx2x_dcbx_pmf_update(bp);\r\nbnx2x_link_status_update(&bp->link_params, &bp->link_vars);\r\nif (bp->link_vars.link_up)\r\nbnx2x_stats_handle(bp, STATS_EVENT_LINK_UP);\r\nelse\r\nbnx2x_stats_handle(bp, STATS_EVENT_STOP);\r\nbnx2x_link_report(bp);\r\n} else {\r\nbp->port.supported[0] |= (SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_1000baseT_Full |\r\nSUPPORTED_2500baseX_Full |\r\nSUPPORTED_10000baseT_Full |\r\nSUPPORTED_TP |\r\nSUPPORTED_FIBRE |\r\nSUPPORTED_Autoneg |\r\nSUPPORTED_Pause |\r\nSUPPORTED_Asym_Pause);\r\nbp->port.advertising[0] = bp->port.supported[0];\r\nbp->link_params.bp = bp;\r\nbp->link_params.port = BP_PORT(bp);\r\nbp->link_params.req_duplex[0] = DUPLEX_FULL;\r\nbp->link_params.req_flow_ctrl[0] = BNX2X_FLOW_CTRL_NONE;\r\nbp->link_params.req_line_speed[0] = SPEED_10000;\r\nbp->link_params.speed_cap_mask[0] = 0x7f0000;\r\nbp->link_params.switch_cfg = SWITCH_CFG_10G;\r\nbp->link_vars.mac_type = MAC_TYPE_BMAC;\r\nbp->link_vars.line_speed = SPEED_10000;\r\nbp->link_vars.link_status =\r\n(LINK_STATUS_LINK_UP |\r\nLINK_STATUS_SPEED_AND_DUPLEX_10GTFD);\r\nbp->link_vars.link_up = 1;\r\nbp->link_vars.duplex = DUPLEX_FULL;\r\nbp->link_vars.flow_ctrl = BNX2X_FLOW_CTRL_NONE;\r\n__bnx2x_link_report(bp);\r\nbnx2x_sample_bulletin(bp);\r\nbnx2x_stats_handle(bp, STATS_EVENT_LINK_UP);\r\n}\r\n}\r\nstatic int bnx2x_afex_func_update(struct bnx2x *bp, u16 vifid,\r\nu16 vlan_val, u8 allowed_prio)\r\n{\r\nstruct bnx2x_func_state_params func_params = {NULL};\r\nstruct bnx2x_func_afex_update_params *f_update_params =\r\n&func_params.params.afex_update;\r\nfunc_params.f_obj = &bp->func_obj;\r\nfunc_params.cmd = BNX2X_F_CMD_AFEX_UPDATE;\r\nf_update_params->vif_id = vifid;\r\nf_update_params->afex_default_vlan = vlan_val;\r\nf_update_params->allowed_priorities = allowed_prio;\r\nif (bnx2x_func_state_change(bp, &func_params) < 0)\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_VIFSET_ACK, 0);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_afex_handle_vif_list_cmd(struct bnx2x *bp, u8 cmd_type,\r\nu16 vif_index, u8 func_bit_map)\r\n{\r\nstruct bnx2x_func_state_params func_params = {NULL};\r\nstruct bnx2x_func_afex_viflists_params *update_params =\r\n&func_params.params.afex_viflists;\r\nint rc;\r\nu32 drv_msg_code;\r\nif ((cmd_type != VIF_LIST_RULE_GET) && (cmd_type != VIF_LIST_RULE_SET))\r\nBNX2X_ERR("BUG! afex_handle_vif_list_cmd invalid type 0x%x\n",\r\ncmd_type);\r\nfunc_params.f_obj = &bp->func_obj;\r\nfunc_params.cmd = BNX2X_F_CMD_AFEX_VIFLISTS;\r\nupdate_params->afex_vif_list_command = cmd_type;\r\nupdate_params->vif_list_index = vif_index;\r\nupdate_params->func_bit_map =\r\n(cmd_type == VIF_LIST_RULE_GET) ? 0 : func_bit_map;\r\nupdate_params->func_to_clear = 0;\r\ndrv_msg_code =\r\n(cmd_type == VIF_LIST_RULE_GET) ?\r\nDRV_MSG_CODE_AFEX_LISTGET_ACK :\r\nDRV_MSG_CODE_AFEX_LISTSET_ACK;\r\nrc = bnx2x_func_state_change(bp, &func_params);\r\nif (rc < 0)\r\nbnx2x_fw_command(bp, drv_msg_code, 0);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_handle_afex_cmd(struct bnx2x *bp, u32 cmd)\r\n{\r\nstruct afex_stats afex_stats;\r\nu32 func = BP_ABS_FUNC(bp);\r\nu32 mf_config;\r\nu16 vlan_val;\r\nu32 vlan_prio;\r\nu16 vif_id;\r\nu8 allowed_prio;\r\nu8 vlan_mode;\r\nu32 addr_to_write, vifid, addrs, stats_type, i;\r\nif (cmd & DRV_STATUS_AFEX_LISTGET_REQ) {\r\nvifid = SHMEM2_RD(bp, afex_param1_to_driver[BP_FW_MB_IDX(bp)]);\r\nDP(BNX2X_MSG_MCP,\r\n"afex: got MCP req LISTGET_REQ for vifid 0x%x\n", vifid);\r\nbnx2x_afex_handle_vif_list_cmd(bp, VIF_LIST_RULE_GET, vifid, 0);\r\n}\r\nif (cmd & DRV_STATUS_AFEX_LISTSET_REQ) {\r\nvifid = SHMEM2_RD(bp, afex_param1_to_driver[BP_FW_MB_IDX(bp)]);\r\naddrs = SHMEM2_RD(bp, afex_param2_to_driver[BP_FW_MB_IDX(bp)]);\r\nDP(BNX2X_MSG_MCP,\r\n"afex: got MCP req LISTSET_REQ for vifid 0x%x addrs 0x%x\n",\r\nvifid, addrs);\r\nbnx2x_afex_handle_vif_list_cmd(bp, VIF_LIST_RULE_SET, vifid,\r\naddrs);\r\n}\r\nif (cmd & DRV_STATUS_AFEX_STATSGET_REQ) {\r\naddr_to_write = SHMEM2_RD(bp,\r\nafex_scratchpad_addr_to_write[BP_FW_MB_IDX(bp)]);\r\nstats_type = SHMEM2_RD(bp,\r\nafex_param1_to_driver[BP_FW_MB_IDX(bp)]);\r\nDP(BNX2X_MSG_MCP,\r\n"afex: got MCP req STATSGET_REQ, write to addr 0x%x\n",\r\naddr_to_write);\r\nbnx2x_afex_collect_stats(bp, (void *)&afex_stats, stats_type);\r\nfor (i = 0; i < (sizeof(struct afex_stats)/sizeof(u32)); i++)\r\nREG_WR(bp, addr_to_write + i*sizeof(u32),\r\n*(((u32 *)(&afex_stats))+i));\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_STATSGET_ACK, 0);\r\n}\r\nif (cmd & DRV_STATUS_AFEX_VIFSET_REQ) {\r\nmf_config = MF_CFG_RD(bp, func_mf_config[func].config);\r\nbp->mf_config[BP_VN(bp)] = mf_config;\r\nDP(BNX2X_MSG_MCP,\r\n"afex: got MCP req VIFSET_REQ, mf_config 0x%x\n",\r\nmf_config);\r\nif (!(mf_config & FUNC_MF_CFG_FUNC_DISABLED)) {\r\nstruct cmng_init_input cmng_input;\r\nstruct rate_shaping_vars_per_vn m_rs_vn;\r\nsize_t size = sizeof(struct rate_shaping_vars_per_vn);\r\nu32 addr = BAR_XSTRORM_INTMEM +\r\nXSTORM_RATE_SHAPING_PER_VN_VARS_OFFSET(BP_FUNC(bp));\r\nbp->mf_config[BP_VN(bp)] = mf_config;\r\nbnx2x_calc_vn_max(bp, BP_VN(bp), &cmng_input);\r\nm_rs_vn.vn_counter.rate =\r\ncmng_input.vnic_max_rate[BP_VN(bp)];\r\nm_rs_vn.vn_counter.quota =\r\n(m_rs_vn.vn_counter.rate *\r\nRS_PERIODIC_TIMEOUT_USEC) / 8;\r\n__storm_memset_struct(bp, addr, size, (u32 *)&m_rs_vn);\r\nvif_id =\r\n(MF_CFG_RD(bp, func_mf_config[func].e1hov_tag) &\r\nFUNC_MF_CFG_E1HOV_TAG_MASK) >>\r\nFUNC_MF_CFG_E1HOV_TAG_SHIFT;\r\nvlan_val =\r\n(MF_CFG_RD(bp, func_mf_config[func].e1hov_tag) &\r\nFUNC_MF_CFG_AFEX_VLAN_MASK) >>\r\nFUNC_MF_CFG_AFEX_VLAN_SHIFT;\r\nvlan_prio = (mf_config &\r\nFUNC_MF_CFG_TRANSMIT_PRIORITY_MASK) >>\r\nFUNC_MF_CFG_TRANSMIT_PRIORITY_SHIFT;\r\nvlan_val |= (vlan_prio << VLAN_PRIO_SHIFT);\r\nvlan_mode =\r\n(MF_CFG_RD(bp,\r\nfunc_mf_config[func].afex_config) &\r\nFUNC_MF_CFG_AFEX_VLAN_MODE_MASK) >>\r\nFUNC_MF_CFG_AFEX_VLAN_MODE_SHIFT;\r\nallowed_prio =\r\n(MF_CFG_RD(bp,\r\nfunc_mf_config[func].afex_config) &\r\nFUNC_MF_CFG_AFEX_COS_FILTER_MASK) >>\r\nFUNC_MF_CFG_AFEX_COS_FILTER_SHIFT;\r\nif (bnx2x_afex_func_update(bp, vif_id, vlan_val,\r\nallowed_prio))\r\nreturn;\r\nbp->afex_def_vlan_tag = vlan_val;\r\nbp->afex_vlan_mode = vlan_mode;\r\n} else {\r\nbnx2x_link_report(bp);\r\nbnx2x_afex_func_update(bp, 0xFFFF, 0, 0);\r\nbp->afex_def_vlan_tag = -1;\r\n}\r\n}\r\n}\r\nstatic void bnx2x_handle_update_svid_cmd(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_func_switch_update_params *switch_update_params;\r\nstruct bnx2x_func_state_params func_params;\r\nmemset(&func_params, 0, sizeof(struct bnx2x_func_state_params));\r\nswitch_update_params = &func_params.params.switch_update;\r\nfunc_params.f_obj = &bp->func_obj;\r\nfunc_params.cmd = BNX2X_F_CMD_SWITCH_UPDATE;\r\nif (IS_MF_UFP(bp) || IS_MF_BD(bp)) {\r\nint func = BP_ABS_FUNC(bp);\r\nu32 val;\r\nval = MF_CFG_RD(bp, func_mf_config[func].e1hov_tag) &\r\nFUNC_MF_CFG_E1HOV_TAG_MASK;\r\nif (val != FUNC_MF_CFG_E1HOV_TAG_DEFAULT) {\r\nbp->mf_ov = val;\r\n} else {\r\nBNX2X_ERR("Got an SVID event, but no tag is configured in shmem\n");\r\ngoto fail;\r\n}\r\nREG_WR(bp, NIG_REG_LLH0_FUNC_VLAN_ID + BP_PORT(bp) * 8,\r\nbp->mf_ov);\r\n__set_bit(BNX2X_F_UPDATE_SD_VLAN_TAG_CHNG,\r\n&switch_update_params->changes);\r\nswitch_update_params->vlan = bp->mf_ov;\r\nif (bnx2x_func_state_change(bp, &func_params) < 0) {\r\nBNX2X_ERR("Failed to configure FW of S-tag Change to %02x\n",\r\nbp->mf_ov);\r\ngoto fail;\r\n} else {\r\nDP(BNX2X_MSG_MCP, "Configured S-tag %02x\n",\r\nbp->mf_ov);\r\n}\r\n} else {\r\ngoto fail;\r\n}\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_OEM_UPDATE_SVID_OK, 0);\r\nreturn;\r\nfail:\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_OEM_UPDATE_SVID_FAILURE, 0);\r\n}\r\nstatic void bnx2x_pmf_update(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nu32 val;\r\nbp->port.pmf = 1;\r\nDP(BNX2X_MSG_MCP, "pmf %d\n", bp->port.pmf);\r\nsmp_mb();\r\nqueue_delayed_work(bnx2x_wq, &bp->period_task, 0);\r\nbnx2x_dcbx_pmf_update(bp);\r\nval = (0xff0f | (1 << (BP_VN(bp) + 4)));\r\nif (bp->common.int_block == INT_BLOCK_HC) {\r\nREG_WR(bp, HC_REG_TRAILING_EDGE_0 + port*8, val);\r\nREG_WR(bp, HC_REG_LEADING_EDGE_0 + port*8, val);\r\n} else if (!CHIP_IS_E1x(bp)) {\r\nREG_WR(bp, IGU_REG_TRAILING_EDGE_LATCH, val);\r\nREG_WR(bp, IGU_REG_LEADING_EDGE_LATCH, val);\r\n}\r\nbnx2x_stats_handle(bp, STATS_EVENT_PMF);\r\n}\r\nu32 bnx2x_fw_command(struct bnx2x *bp, u32 command, u32 param)\r\n{\r\nint mb_idx = BP_FW_MB_IDX(bp);\r\nu32 seq;\r\nu32 rc = 0;\r\nu32 cnt = 1;\r\nu8 delay = CHIP_REV_IS_SLOW(bp) ? 100 : 10;\r\nmutex_lock(&bp->fw_mb_mutex);\r\nseq = ++bp->fw_seq;\r\nSHMEM_WR(bp, func_mb[mb_idx].drv_mb_param, param);\r\nSHMEM_WR(bp, func_mb[mb_idx].drv_mb_header, (command | seq));\r\nDP(BNX2X_MSG_MCP, "wrote command (%x) to FW MB param 0x%08x\n",\r\n(command | seq), param);\r\ndo {\r\nmsleep(delay);\r\nrc = SHMEM_RD(bp, func_mb[mb_idx].fw_mb_header);\r\n} while ((seq != (rc & FW_MSG_SEQ_NUMBER_MASK)) && (cnt++ < 500));\r\nDP(BNX2X_MSG_MCP, "[after %d ms] read (%x) seq is (%x) from FW MB\n",\r\ncnt*delay, rc, seq);\r\nif (seq == (rc & FW_MSG_SEQ_NUMBER_MASK))\r\nrc &= FW_MSG_CODE_MASK;\r\nelse {\r\nBNX2X_ERR("FW failed to respond!\n");\r\nbnx2x_fw_dump(bp);\r\nrc = 0;\r\n}\r\nmutex_unlock(&bp->fw_mb_mutex);\r\nreturn rc;\r\n}\r\nstatic void storm_memset_func_cfg(struct bnx2x *bp,\r\nstruct tstorm_eth_function_common_config *tcfg,\r\nu16 abs_fid)\r\n{\r\nsize_t size = sizeof(struct tstorm_eth_function_common_config);\r\nu32 addr = BAR_TSTRORM_INTMEM +\r\nTSTORM_FUNCTION_COMMON_CONFIG_OFFSET(abs_fid);\r\n__storm_memset_struct(bp, addr, size, (u32 *)tcfg);\r\n}\r\nvoid bnx2x_func_init(struct bnx2x *bp, struct bnx2x_func_init_params *p)\r\n{\r\nif (CHIP_IS_E1x(bp)) {\r\nstruct tstorm_eth_function_common_config tcfg = {0};\r\nstorm_memset_func_cfg(bp, &tcfg, p->func_id);\r\n}\r\nstorm_memset_vf_to_pf(bp, p->func_id, p->pf_id);\r\nstorm_memset_func_en(bp, p->func_id, 1);\r\nif (p->spq_active) {\r\nstorm_memset_spq_addr(bp, p->spq_map, p->func_id);\r\nREG_WR(bp, XSEM_REG_FAST_MEMORY +\r\nXSTORM_SPQ_PROD_OFFSET(p->func_id), p->spq_prod);\r\n}\r\n}\r\nstatic unsigned long bnx2x_get_common_flags(struct bnx2x *bp,\r\nstruct bnx2x_fastpath *fp,\r\nbool zero_stats)\r\n{\r\nunsigned long flags = 0;\r\n__set_bit(BNX2X_Q_FLG_ACTIVE, &flags);\r\n__set_bit(BNX2X_Q_FLG_STATS, &flags);\r\nif (zero_stats)\r\n__set_bit(BNX2X_Q_FLG_ZERO_STATS, &flags);\r\nif (bp->flags & TX_SWITCHING)\r\n__set_bit(BNX2X_Q_FLG_TX_SWITCH, &flags);\r\n__set_bit(BNX2X_Q_FLG_PCSUM_ON_PKT, &flags);\r\n__set_bit(BNX2X_Q_FLG_TUN_INC_INNER_IP_ID, &flags);\r\n#ifdef BNX2X_STOP_ON_ERROR\r\n__set_bit(BNX2X_Q_FLG_TX_SEC, &flags);\r\n#endif\r\nreturn flags;\r\n}\r\nstatic unsigned long bnx2x_get_q_flags(struct bnx2x *bp,\r\nstruct bnx2x_fastpath *fp,\r\nbool leading)\r\n{\r\nunsigned long flags = 0;\r\nif (IS_MF_SD(bp))\r\n__set_bit(BNX2X_Q_FLG_OV, &flags);\r\nif (IS_FCOE_FP(fp)) {\r\n__set_bit(BNX2X_Q_FLG_FCOE, &flags);\r\n__set_bit(BNX2X_Q_FLG_FORCE_DEFAULT_PRI, &flags);\r\n}\r\nif (fp->mode != TPA_MODE_DISABLED) {\r\n__set_bit(BNX2X_Q_FLG_TPA, &flags);\r\n__set_bit(BNX2X_Q_FLG_TPA_IPV6, &flags);\r\nif (fp->mode == TPA_MODE_GRO)\r\n__set_bit(BNX2X_Q_FLG_TPA_GRO, &flags);\r\n}\r\nif (leading) {\r\n__set_bit(BNX2X_Q_FLG_LEADING_RSS, &flags);\r\n__set_bit(BNX2X_Q_FLG_MCAST, &flags);\r\n}\r\n__set_bit(BNX2X_Q_FLG_VLAN, &flags);\r\nif (IS_MF_AFEX(bp))\r\n__set_bit(BNX2X_Q_FLG_SILENT_VLAN_REM, &flags);\r\nreturn flags | bnx2x_get_common_flags(bp, fp, true);\r\n}\r\nstatic void bnx2x_pf_q_prep_general(struct bnx2x *bp,\r\nstruct bnx2x_fastpath *fp, struct bnx2x_general_setup_params *gen_init,\r\nu8 cos)\r\n{\r\ngen_init->stat_id = bnx2x_stats_id(fp);\r\ngen_init->spcl_id = fp->cl_id;\r\nif (IS_FCOE_FP(fp))\r\ngen_init->mtu = BNX2X_FCOE_MINI_JUMBO_MTU;\r\nelse\r\ngen_init->mtu = bp->dev->mtu;\r\ngen_init->cos = cos;\r\ngen_init->fp_hsi = ETH_FP_HSI_VERSION;\r\n}\r\nstatic void bnx2x_pf_rx_q_prep(struct bnx2x *bp,\r\nstruct bnx2x_fastpath *fp, struct rxq_pause_params *pause,\r\nstruct bnx2x_rxq_setup_params *rxq_init)\r\n{\r\nu8 max_sge = 0;\r\nu16 sge_sz = 0;\r\nu16 tpa_agg_size = 0;\r\nif (fp->mode != TPA_MODE_DISABLED) {\r\npause->sge_th_lo = SGE_TH_LO(bp);\r\npause->sge_th_hi = SGE_TH_HI(bp);\r\nWARN_ON(bp->dropless_fc &&\r\npause->sge_th_hi + FW_PREFETCH_CNT >\r\nMAX_RX_SGE_CNT * NUM_RX_SGE_PAGES);\r\ntpa_agg_size = TPA_AGG_SIZE;\r\nmax_sge = SGE_PAGE_ALIGN(bp->dev->mtu) >>\r\nSGE_PAGE_SHIFT;\r\nmax_sge = ((max_sge + PAGES_PER_SGE - 1) &\r\n(~(PAGES_PER_SGE-1))) >> PAGES_PER_SGE_SHIFT;\r\nsge_sz = (u16)min_t(u32, SGE_PAGES, 0xffff);\r\n}\r\nif (!CHIP_IS_E1(bp)) {\r\npause->bd_th_lo = BD_TH_LO(bp);\r\npause->bd_th_hi = BD_TH_HI(bp);\r\npause->rcq_th_lo = RCQ_TH_LO(bp);\r\npause->rcq_th_hi = RCQ_TH_HI(bp);\r\nWARN_ON(bp->dropless_fc &&\r\npause->bd_th_hi + FW_PREFETCH_CNT >\r\nbp->rx_ring_size);\r\nWARN_ON(bp->dropless_fc &&\r\npause->rcq_th_hi + FW_PREFETCH_CNT >\r\nNUM_RCQ_RINGS * MAX_RCQ_DESC_CNT);\r\npause->pri_map = 1;\r\n}\r\nrxq_init->dscr_map = fp->rx_desc_mapping;\r\nrxq_init->sge_map = fp->rx_sge_mapping;\r\nrxq_init->rcq_map = fp->rx_comp_mapping;\r\nrxq_init->rcq_np_map = fp->rx_comp_mapping + BCM_PAGE_SIZE;\r\nrxq_init->buf_sz = fp->rx_buf_size - BNX2X_FW_RX_ALIGN_START -\r\nBNX2X_FW_RX_ALIGN_END - IP_HEADER_ALIGNMENT_PADDING;\r\nrxq_init->cl_qzone_id = fp->cl_qzone_id;\r\nrxq_init->tpa_agg_sz = tpa_agg_size;\r\nrxq_init->sge_buf_sz = sge_sz;\r\nrxq_init->max_sges_pkt = max_sge;\r\nrxq_init->rss_engine_id = BP_FUNC(bp);\r\nrxq_init->mcast_engine_id = BP_FUNC(bp);\r\nrxq_init->max_tpa_queues = MAX_AGG_QS(bp);\r\nrxq_init->cache_line_log = BNX2X_RX_ALIGN_SHIFT;\r\nrxq_init->fw_sb_id = fp->fw_sb_id;\r\nif (IS_FCOE_FP(fp))\r\nrxq_init->sb_cq_index = HC_SP_INDEX_ETH_FCOE_RX_CQ_CONS;\r\nelse\r\nrxq_init->sb_cq_index = HC_INDEX_ETH_RX_CQ_CONS;\r\nif (IS_MF_AFEX(bp)) {\r\nrxq_init->silent_removal_value = bp->afex_def_vlan_tag;\r\nrxq_init->silent_removal_mask = VLAN_VID_MASK;\r\n}\r\n}\r\nstatic void bnx2x_pf_tx_q_prep(struct bnx2x *bp,\r\nstruct bnx2x_fastpath *fp, struct bnx2x_txq_setup_params *txq_init,\r\nu8 cos)\r\n{\r\ntxq_init->dscr_map = fp->txdata_ptr[cos]->tx_desc_mapping;\r\ntxq_init->sb_cq_index = HC_INDEX_ETH_FIRST_TX_CQ_CONS + cos;\r\ntxq_init->traffic_type = LLFC_TRAFFIC_TYPE_NW;\r\ntxq_init->fw_sb_id = fp->fw_sb_id;\r\ntxq_init->tss_leading_cl_id = bnx2x_fp(bp, 0, cl_id);\r\nif (IS_FCOE_FP(fp)) {\r\ntxq_init->sb_cq_index = HC_SP_INDEX_ETH_FCOE_TX_CQ_CONS;\r\ntxq_init->traffic_type = LLFC_TRAFFIC_TYPE_FCOE;\r\n}\r\n}\r\nstatic void bnx2x_pf_init(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_func_init_params func_init = {0};\r\nstruct event_ring_data eq_data = { {0} };\r\nif (!CHIP_IS_E1x(bp)) {\r\nREG_WR(bp, IGU_REG_STATISTIC_NUM_MESSAGE_SENT +\r\nBNX2X_IGU_STAS_MSG_VF_CNT*4 +\r\n(CHIP_MODE_IS_4_PORT(bp) ?\r\nBP_FUNC(bp) : BP_VN(bp))*4, 0);\r\nREG_WR(bp, IGU_REG_STATISTIC_NUM_MESSAGE_SENT +\r\nBNX2X_IGU_STAS_MSG_VF_CNT*4 +\r\nBNX2X_IGU_STAS_MSG_PF_CNT*4 +\r\n(CHIP_MODE_IS_4_PORT(bp) ?\r\nBP_FUNC(bp) : BP_VN(bp))*4, 0);\r\n}\r\nfunc_init.spq_active = true;\r\nfunc_init.pf_id = BP_FUNC(bp);\r\nfunc_init.func_id = BP_FUNC(bp);\r\nfunc_init.spq_map = bp->spq_mapping;\r\nfunc_init.spq_prod = bp->spq_prod_idx;\r\nbnx2x_func_init(bp, &func_init);\r\nmemset(&(bp->cmng), 0, sizeof(struct cmng_struct_per_port));\r\nbp->link_vars.line_speed = SPEED_10000;\r\nbnx2x_cmng_fns_init(bp, true, bnx2x_get_cmng_fns_mode(bp));\r\nif (bp->port.pmf)\r\nstorm_memset_cmng(bp, &bp->cmng, BP_PORT(bp));\r\neq_data.base_addr.hi = U64_HI(bp->eq_mapping);\r\neq_data.base_addr.lo = U64_LO(bp->eq_mapping);\r\neq_data.producer = bp->eq_prod;\r\neq_data.index_id = HC_SP_INDEX_EQ_CONS;\r\neq_data.sb_id = DEF_SB_ID;\r\nstorm_memset_eq_data(bp, &eq_data, BP_FUNC(bp));\r\n}\r\nstatic void bnx2x_e1h_disable(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nbnx2x_tx_disable(bp);\r\nREG_WR(bp, NIG_REG_LLH0_FUNC_EN + port*8, 0);\r\n}\r\nstatic void bnx2x_e1h_enable(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nif (!(IS_MF_UFP(bp) && BNX2X_IS_MF_SD_PROTOCOL_FCOE(bp)))\r\nREG_WR(bp, NIG_REG_LLH0_FUNC_EN + port * 8, 1);\r\nnetif_tx_wake_all_queues(bp->dev);\r\n}\r\nstatic void bnx2x_drv_info_ether_stat(struct bnx2x *bp)\r\n{\r\nstruct eth_stats_info *ether_stat =\r\n&bp->slowpath->drv_info_to_mcp.ether_stat;\r\nstruct bnx2x_vlan_mac_obj *mac_obj =\r\n&bp->sp_objs->mac_obj;\r\nint i;\r\nstrlcpy(ether_stat->version, DRV_MODULE_VERSION,\r\nETH_STAT_INFO_VERSION_LEN);\r\nfor (i = 0; i < DRV_INFO_ETH_STAT_NUM_MACS_REQUIRED; i++)\r\nmemset(ether_stat->mac_local + i, 0,\r\nsizeof(ether_stat->mac_local[0]));\r\nmac_obj->get_n_elements(bp, &bp->sp_objs[0].mac_obj,\r\nDRV_INFO_ETH_STAT_NUM_MACS_REQUIRED,\r\nether_stat->mac_local + MAC_PAD, MAC_PAD,\r\nETH_ALEN);\r\nether_stat->mtu_size = bp->dev->mtu;\r\nif (bp->dev->features & NETIF_F_RXCSUM)\r\nether_stat->feature_flags |= FEATURE_ETH_CHKSUM_OFFLOAD_MASK;\r\nif (bp->dev->features & NETIF_F_TSO)\r\nether_stat->feature_flags |= FEATURE_ETH_LSO_MASK;\r\nether_stat->feature_flags |= bp->common.boot_mode;\r\nether_stat->promiscuous_mode = (bp->dev->flags & IFF_PROMISC) ? 1 : 0;\r\nether_stat->txq_size = bp->tx_ring_size;\r\nether_stat->rxq_size = bp->rx_ring_size;\r\n#ifdef CONFIG_BNX2X_SRIOV\r\nether_stat->vf_cnt = IS_SRIOV(bp) ? bp->vfdb->sriov.nr_virtfn : 0;\r\n#endif\r\n}\r\nstatic void bnx2x_drv_info_fcoe_stat(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_dcbx_app_params *app = &bp->dcbx_port_params.app;\r\nstruct fcoe_stats_info *fcoe_stat =\r\n&bp->slowpath->drv_info_to_mcp.fcoe_stat;\r\nif (!CNIC_LOADED(bp))\r\nreturn;\r\nmemcpy(fcoe_stat->mac_local + MAC_PAD, bp->fip_mac, ETH_ALEN);\r\nfcoe_stat->qos_priority =\r\napp->traffic_type_priority[LLFC_TRAFFIC_TYPE_FCOE];\r\nif (!NO_FCOE(bp)) {\r\nstruct tstorm_per_queue_stats *fcoe_q_tstorm_stats =\r\n&bp->fw_stats_data->queue_stats[FCOE_IDX(bp)].\r\ntstorm_queue_statistics;\r\nstruct xstorm_per_queue_stats *fcoe_q_xstorm_stats =\r\n&bp->fw_stats_data->queue_stats[FCOE_IDX(bp)].\r\nxstorm_queue_statistics;\r\nstruct fcoe_statistics_params *fw_fcoe_stat =\r\n&bp->fw_stats_data->fcoe;\r\nADD_64_LE(fcoe_stat->rx_bytes_hi, LE32_0,\r\nfcoe_stat->rx_bytes_lo,\r\nfw_fcoe_stat->rx_stat0.fcoe_rx_byte_cnt);\r\nADD_64_LE(fcoe_stat->rx_bytes_hi,\r\nfcoe_q_tstorm_stats->rcv_ucast_bytes.hi,\r\nfcoe_stat->rx_bytes_lo,\r\nfcoe_q_tstorm_stats->rcv_ucast_bytes.lo);\r\nADD_64_LE(fcoe_stat->rx_bytes_hi,\r\nfcoe_q_tstorm_stats->rcv_bcast_bytes.hi,\r\nfcoe_stat->rx_bytes_lo,\r\nfcoe_q_tstorm_stats->rcv_bcast_bytes.lo);\r\nADD_64_LE(fcoe_stat->rx_bytes_hi,\r\nfcoe_q_tstorm_stats->rcv_mcast_bytes.hi,\r\nfcoe_stat->rx_bytes_lo,\r\nfcoe_q_tstorm_stats->rcv_mcast_bytes.lo);\r\nADD_64_LE(fcoe_stat->rx_frames_hi, LE32_0,\r\nfcoe_stat->rx_frames_lo,\r\nfw_fcoe_stat->rx_stat0.fcoe_rx_pkt_cnt);\r\nADD_64_LE(fcoe_stat->rx_frames_hi, LE32_0,\r\nfcoe_stat->rx_frames_lo,\r\nfcoe_q_tstorm_stats->rcv_ucast_pkts);\r\nADD_64_LE(fcoe_stat->rx_frames_hi, LE32_0,\r\nfcoe_stat->rx_frames_lo,\r\nfcoe_q_tstorm_stats->rcv_bcast_pkts);\r\nADD_64_LE(fcoe_stat->rx_frames_hi, LE32_0,\r\nfcoe_stat->rx_frames_lo,\r\nfcoe_q_tstorm_stats->rcv_mcast_pkts);\r\nADD_64_LE(fcoe_stat->tx_bytes_hi, LE32_0,\r\nfcoe_stat->tx_bytes_lo,\r\nfw_fcoe_stat->tx_stat.fcoe_tx_byte_cnt);\r\nADD_64_LE(fcoe_stat->tx_bytes_hi,\r\nfcoe_q_xstorm_stats->ucast_bytes_sent.hi,\r\nfcoe_stat->tx_bytes_lo,\r\nfcoe_q_xstorm_stats->ucast_bytes_sent.lo);\r\nADD_64_LE(fcoe_stat->tx_bytes_hi,\r\nfcoe_q_xstorm_stats->bcast_bytes_sent.hi,\r\nfcoe_stat->tx_bytes_lo,\r\nfcoe_q_xstorm_stats->bcast_bytes_sent.lo);\r\nADD_64_LE(fcoe_stat->tx_bytes_hi,\r\nfcoe_q_xstorm_stats->mcast_bytes_sent.hi,\r\nfcoe_stat->tx_bytes_lo,\r\nfcoe_q_xstorm_stats->mcast_bytes_sent.lo);\r\nADD_64_LE(fcoe_stat->tx_frames_hi, LE32_0,\r\nfcoe_stat->tx_frames_lo,\r\nfw_fcoe_stat->tx_stat.fcoe_tx_pkt_cnt);\r\nADD_64_LE(fcoe_stat->tx_frames_hi, LE32_0,\r\nfcoe_stat->tx_frames_lo,\r\nfcoe_q_xstorm_stats->ucast_pkts_sent);\r\nADD_64_LE(fcoe_stat->tx_frames_hi, LE32_0,\r\nfcoe_stat->tx_frames_lo,\r\nfcoe_q_xstorm_stats->bcast_pkts_sent);\r\nADD_64_LE(fcoe_stat->tx_frames_hi, LE32_0,\r\nfcoe_stat->tx_frames_lo,\r\nfcoe_q_xstorm_stats->mcast_pkts_sent);\r\n}\r\nbnx2x_cnic_notify(bp, CNIC_CTL_FCOE_STATS_GET_CMD);\r\n}\r\nstatic void bnx2x_drv_info_iscsi_stat(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_dcbx_app_params *app = &bp->dcbx_port_params.app;\r\nstruct iscsi_stats_info *iscsi_stat =\r\n&bp->slowpath->drv_info_to_mcp.iscsi_stat;\r\nif (!CNIC_LOADED(bp))\r\nreturn;\r\nmemcpy(iscsi_stat->mac_local + MAC_PAD, bp->cnic_eth_dev.iscsi_mac,\r\nETH_ALEN);\r\niscsi_stat->qos_priority =\r\napp->traffic_type_priority[LLFC_TRAFFIC_TYPE_ISCSI];\r\nbnx2x_cnic_notify(bp, CNIC_CTL_ISCSI_STATS_GET_CMD);\r\n}\r\nstatic void bnx2x_config_mf_bw(struct bnx2x *bp)\r\n{\r\nif (bp->link_vars.link_up) {\r\nbnx2x_cmng_fns_init(bp, true, CMNG_FNS_MINMAX);\r\nbnx2x_link_sync_notify(bp);\r\n}\r\nstorm_memset_cmng(bp, &bp->cmng, BP_PORT(bp));\r\n}\r\nstatic void bnx2x_set_mf_bw(struct bnx2x *bp)\r\n{\r\nbnx2x_config_mf_bw(bp);\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_SET_MF_BW_ACK, 0);\r\n}\r\nstatic void bnx2x_handle_eee_event(struct bnx2x *bp)\r\n{\r\nDP(BNX2X_MSG_MCP, "EEE - LLDP event\n");\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_EEE_RESULTS_ACK, 0);\r\n}\r\nstatic void bnx2x_handle_drv_info_req(struct bnx2x *bp)\r\n{\r\nenum drv_info_opcode op_code;\r\nu32 drv_info_ctl = SHMEM2_RD(bp, drv_info_control);\r\nbool release = false;\r\nint wait;\r\nif ((drv_info_ctl & DRV_INFO_CONTROL_VER_MASK) != DRV_INFO_CUR_VER) {\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_DRV_INFO_NACK, 0);\r\nreturn;\r\n}\r\nop_code = (drv_info_ctl & DRV_INFO_CONTROL_OP_CODE_MASK) >>\r\nDRV_INFO_CONTROL_OP_CODE_SHIFT;\r\nmutex_lock(&bp->drv_info_mutex);\r\nmemset(&bp->slowpath->drv_info_to_mcp, 0,\r\nsizeof(union drv_info_to_mcp));\r\nswitch (op_code) {\r\ncase ETH_STATS_OPCODE:\r\nbnx2x_drv_info_ether_stat(bp);\r\nbreak;\r\ncase FCOE_STATS_OPCODE:\r\nbnx2x_drv_info_fcoe_stat(bp);\r\nbreak;\r\ncase ISCSI_STATS_OPCODE:\r\nbnx2x_drv_info_iscsi_stat(bp);\r\nbreak;\r\ndefault:\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_DRV_INFO_NACK, 0);\r\ngoto out;\r\n}\r\nSHMEM2_WR(bp, drv_info_host_addr_lo,\r\nU64_LO(bnx2x_sp_mapping(bp, drv_info_to_mcp)));\r\nSHMEM2_WR(bp, drv_info_host_addr_hi,\r\nU64_HI(bnx2x_sp_mapping(bp, drv_info_to_mcp)));\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_DRV_INFO_ACK, 0);\r\nif (!SHMEM2_HAS(bp, mfw_drv_indication)) {\r\nDP(BNX2X_MSG_MCP, "Management does not support indication\n");\r\n} else if (!bp->drv_info_mng_owner) {\r\nu32 bit = MFW_DRV_IND_READ_DONE_OFFSET((BP_ABS_FUNC(bp) >> 1));\r\nfor (wait = 0; wait < BNX2X_UPDATE_DRV_INFO_IND_COUNT; wait++) {\r\nu32 indication = SHMEM2_RD(bp, mfw_drv_indication);\r\nif (indication & bit) {\r\nSHMEM2_WR(bp, mfw_drv_indication,\r\nindication & ~bit);\r\nrelease = true;\r\nbreak;\r\n}\r\nmsleep(BNX2X_UPDATE_DRV_INFO_IND_LENGTH);\r\n}\r\n}\r\nif (!release) {\r\nDP(BNX2X_MSG_MCP, "Management did not release indication\n");\r\nbp->drv_info_mng_owner = true;\r\n}\r\nout:\r\nmutex_unlock(&bp->drv_info_mutex);\r\n}\r\nstatic u32 bnx2x_update_mng_version_utility(u8 *version, bool bnx2x_format)\r\n{\r\nu8 vals[4];\r\nint i = 0;\r\nif (bnx2x_format) {\r\ni = sscanf(version, "1.%c%hhd.%hhd.%hhd",\r\n&vals[0], &vals[1], &vals[2], &vals[3]);\r\nif (i > 0)\r\nvals[0] -= '0';\r\n} else {\r\ni = sscanf(version, "%hhd.%hhd.%hhd.%hhd",\r\n&vals[0], &vals[1], &vals[2], &vals[3]);\r\n}\r\nwhile (i < 4)\r\nvals[i++] = 0;\r\nreturn (vals[0] << 24) | (vals[1] << 16) | (vals[2] << 8) | vals[3];\r\n}\r\nvoid bnx2x_update_mng_version(struct bnx2x *bp)\r\n{\r\nu32 iscsiver = DRV_VER_NOT_LOADED;\r\nu32 fcoever = DRV_VER_NOT_LOADED;\r\nu32 ethver = DRV_VER_NOT_LOADED;\r\nint idx = BP_FW_MB_IDX(bp);\r\nu8 *version;\r\nif (!SHMEM2_HAS(bp, func_os_drv_ver))\r\nreturn;\r\nmutex_lock(&bp->drv_info_mutex);\r\nif (bp->drv_info_mng_owner)\r\ngoto out;\r\nif (bp->state != BNX2X_STATE_OPEN)\r\ngoto out;\r\nethver = bnx2x_update_mng_version_utility(DRV_MODULE_VERSION, true);\r\nif (!CNIC_LOADED(bp))\r\ngoto out;\r\nmemset(&bp->slowpath->drv_info_to_mcp, 0,\r\nsizeof(union drv_info_to_mcp));\r\nbnx2x_drv_info_iscsi_stat(bp);\r\nversion = bp->slowpath->drv_info_to_mcp.iscsi_stat.version;\r\niscsiver = bnx2x_update_mng_version_utility(version, false);\r\nmemset(&bp->slowpath->drv_info_to_mcp, 0,\r\nsizeof(union drv_info_to_mcp));\r\nbnx2x_drv_info_fcoe_stat(bp);\r\nversion = bp->slowpath->drv_info_to_mcp.fcoe_stat.version;\r\nfcoever = bnx2x_update_mng_version_utility(version, false);\r\nout:\r\nSHMEM2_WR(bp, func_os_drv_ver[idx].versions[DRV_PERS_ETHERNET], ethver);\r\nSHMEM2_WR(bp, func_os_drv_ver[idx].versions[DRV_PERS_ISCSI], iscsiver);\r\nSHMEM2_WR(bp, func_os_drv_ver[idx].versions[DRV_PERS_FCOE], fcoever);\r\nmutex_unlock(&bp->drv_info_mutex);\r\nDP(BNX2X_MSG_MCP, "Setting driver version: ETH [%08x] iSCSI [%08x] FCoE [%08x]\n",\r\nethver, iscsiver, fcoever);\r\n}\r\nvoid bnx2x_update_mfw_dump(struct bnx2x *bp)\r\n{\r\nu32 drv_ver;\r\nu32 valid_dump;\r\nif (!SHMEM2_HAS(bp, drv_info))\r\nreturn;\r\nSHMEM2_WR(bp, drv_info.epoc, (u32)ktime_get_real_seconds());\r\ndrv_ver = bnx2x_update_mng_version_utility(DRV_MODULE_VERSION, true);\r\nSHMEM2_WR(bp, drv_info.drv_ver, drv_ver);\r\nSHMEM2_WR(bp, drv_info.fw_ver, REG_RD(bp, XSEM_REG_PRAM));\r\nvalid_dump = SHMEM2_RD(bp, drv_info.valid_dump);\r\nif (valid_dump & FIRST_DUMP_VALID)\r\nDP(NETIF_MSG_IFUP, "A valid On-Chip MFW dump found on 1st partition\n");\r\nif (valid_dump & SECOND_DUMP_VALID)\r\nDP(NETIF_MSG_IFUP, "A valid On-Chip MFW dump found on 2nd partition\n");\r\n}\r\nstatic void bnx2x_oem_event(struct bnx2x *bp, u32 event)\r\n{\r\nu32 cmd_ok, cmd_fail;\r\nif (event & DRV_STATUS_DCC_EVENT_MASK &&\r\nevent & DRV_STATUS_OEM_EVENT_MASK) {\r\nBNX2X_ERR("Received simultaneous events %08x\n", event);\r\nreturn;\r\n}\r\nif (event & DRV_STATUS_DCC_EVENT_MASK) {\r\ncmd_fail = DRV_MSG_CODE_DCC_FAILURE;\r\ncmd_ok = DRV_MSG_CODE_DCC_OK;\r\n} else {\r\ncmd_fail = DRV_MSG_CODE_OEM_FAILURE;\r\ncmd_ok = DRV_MSG_CODE_OEM_OK;\r\n}\r\nDP(BNX2X_MSG_MCP, "oem_event 0x%x\n", event);\r\nif (event & (DRV_STATUS_DCC_DISABLE_ENABLE_PF |\r\nDRV_STATUS_OEM_DISABLE_ENABLE_PF)) {\r\nif (bp->mf_config[BP_VN(bp)] & FUNC_MF_CFG_FUNC_DISABLED) {\r\nDP(BNX2X_MSG_MCP, "mf_cfg function disabled\n");\r\nbp->flags |= MF_FUNC_DIS;\r\nbnx2x_e1h_disable(bp);\r\n} else {\r\nDP(BNX2X_MSG_MCP, "mf_cfg function enabled\n");\r\nbp->flags &= ~MF_FUNC_DIS;\r\nbnx2x_e1h_enable(bp);\r\n}\r\nevent &= ~(DRV_STATUS_DCC_DISABLE_ENABLE_PF |\r\nDRV_STATUS_OEM_DISABLE_ENABLE_PF);\r\n}\r\nif (event & (DRV_STATUS_DCC_BANDWIDTH_ALLOCATION |\r\nDRV_STATUS_OEM_BANDWIDTH_ALLOCATION)) {\r\nbnx2x_config_mf_bw(bp);\r\nevent &= ~(DRV_STATUS_DCC_BANDWIDTH_ALLOCATION |\r\nDRV_STATUS_OEM_BANDWIDTH_ALLOCATION);\r\n}\r\nif (event)\r\nbnx2x_fw_command(bp, cmd_fail, 0);\r\nelse\r\nbnx2x_fw_command(bp, cmd_ok, 0);\r\n}\r\nstatic struct eth_spe *bnx2x_sp_get_next(struct bnx2x *bp)\r\n{\r\nstruct eth_spe *next_spe = bp->spq_prod_bd;\r\nif (bp->spq_prod_bd == bp->spq_last_bd) {\r\nbp->spq_prod_bd = bp->spq;\r\nbp->spq_prod_idx = 0;\r\nDP(BNX2X_MSG_SP, "end of spq\n");\r\n} else {\r\nbp->spq_prod_bd++;\r\nbp->spq_prod_idx++;\r\n}\r\nreturn next_spe;\r\n}\r\nstatic void bnx2x_sp_prod_update(struct bnx2x *bp)\r\n{\r\nint func = BP_FUNC(bp);\r\nmb();\r\nREG_WR16(bp, BAR_XSTRORM_INTMEM + XSTORM_SPQ_PROD_OFFSET(func),\r\nbp->spq_prod_idx);\r\nmmiowb();\r\n}\r\nstatic bool bnx2x_is_contextless_ramrod(int cmd, int cmd_type)\r\n{\r\nif ((cmd_type == NONE_CONNECTION_TYPE) ||\r\n(cmd == RAMROD_CMD_ID_ETH_FORWARD_SETUP) ||\r\n(cmd == RAMROD_CMD_ID_ETH_CLASSIFICATION_RULES) ||\r\n(cmd == RAMROD_CMD_ID_ETH_FILTER_RULES) ||\r\n(cmd == RAMROD_CMD_ID_ETH_MULTICAST_RULES) ||\r\n(cmd == RAMROD_CMD_ID_ETH_SET_MAC) ||\r\n(cmd == RAMROD_CMD_ID_ETH_RSS_UPDATE))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nint bnx2x_sp_post(struct bnx2x *bp, int command, int cid,\r\nu32 data_hi, u32 data_lo, int cmd_type)\r\n{\r\nstruct eth_spe *spe;\r\nu16 type;\r\nbool common = bnx2x_is_contextless_ramrod(command, cmd_type);\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nif (unlikely(bp->panic)) {\r\nBNX2X_ERR("Can't post SP when there is panic\n");\r\nreturn -EIO;\r\n}\r\n#endif\r\nspin_lock_bh(&bp->spq_lock);\r\nif (common) {\r\nif (!atomic_read(&bp->eq_spq_left)) {\r\nBNX2X_ERR("BUG! EQ ring full!\n");\r\nspin_unlock_bh(&bp->spq_lock);\r\nbnx2x_panic();\r\nreturn -EBUSY;\r\n}\r\n} else if (!atomic_read(&bp->cq_spq_left)) {\r\nBNX2X_ERR("BUG! SPQ ring full!\n");\r\nspin_unlock_bh(&bp->spq_lock);\r\nbnx2x_panic();\r\nreturn -EBUSY;\r\n}\r\nspe = bnx2x_sp_get_next(bp);\r\nspe->hdr.conn_and_cmd_data =\r\ncpu_to_le32((command << SPE_HDR_CMD_ID_SHIFT) |\r\nHW_CID(bp, cid));\r\nif (!(cmd_type & SPE_HDR_FUNCTION_ID)) {\r\ntype = (cmd_type << SPE_HDR_CONN_TYPE_SHIFT) &\r\nSPE_HDR_CONN_TYPE;\r\ntype |= ((BP_FUNC(bp) << SPE_HDR_FUNCTION_ID_SHIFT) &\r\nSPE_HDR_FUNCTION_ID);\r\n} else {\r\ntype = cmd_type;\r\n}\r\nspe->hdr.type = cpu_to_le16(type);\r\nspe->data.update_data_addr.hi = cpu_to_le32(data_hi);\r\nspe->data.update_data_addr.lo = cpu_to_le32(data_lo);\r\nif (common)\r\natomic_dec(&bp->eq_spq_left);\r\nelse\r\natomic_dec(&bp->cq_spq_left);\r\nDP(BNX2X_MSG_SP,\r\n"SPQE[%x] (%x:%x) (cmd, common?) (%d,%d) hw_cid %x data (%x:%x) type(0x%x) left (CQ, EQ) (%x,%x)\n",\r\nbp->spq_prod_idx, (u32)U64_HI(bp->spq_mapping),\r\n(u32)(U64_LO(bp->spq_mapping) +\r\n(void *)bp->spq_prod_bd - (void *)bp->spq), command, common,\r\nHW_CID(bp, cid), data_hi, data_lo, type,\r\natomic_read(&bp->cq_spq_left), atomic_read(&bp->eq_spq_left));\r\nbnx2x_sp_prod_update(bp);\r\nspin_unlock_bh(&bp->spq_lock);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_acquire_alr(struct bnx2x *bp)\r\n{\r\nu32 j, val;\r\nint rc = 0;\r\nmight_sleep();\r\nfor (j = 0; j < 1000; j++) {\r\nREG_WR(bp, MCP_REG_MCPR_ACCESS_LOCK, MCPR_ACCESS_LOCK_LOCK);\r\nval = REG_RD(bp, MCP_REG_MCPR_ACCESS_LOCK);\r\nif (val & MCPR_ACCESS_LOCK_LOCK)\r\nbreak;\r\nusleep_range(5000, 10000);\r\n}\r\nif (!(val & MCPR_ACCESS_LOCK_LOCK)) {\r\nBNX2X_ERR("Cannot acquire MCP access lock register\n");\r\nrc = -EBUSY;\r\n}\r\nreturn rc;\r\n}\r\nstatic void bnx2x_release_alr(struct bnx2x *bp)\r\n{\r\nREG_WR(bp, MCP_REG_MCPR_ACCESS_LOCK, 0);\r\n}\r\nstatic u16 bnx2x_update_dsb_idx(struct bnx2x *bp)\r\n{\r\nstruct host_sp_status_block *def_sb = bp->def_status_blk;\r\nu16 rc = 0;\r\nbarrier();\r\nif (bp->def_att_idx != def_sb->atten_status_block.attn_bits_index) {\r\nbp->def_att_idx = def_sb->atten_status_block.attn_bits_index;\r\nrc |= BNX2X_DEF_SB_ATT_IDX;\r\n}\r\nif (bp->def_idx != def_sb->sp_sb.running_index) {\r\nbp->def_idx = def_sb->sp_sb.running_index;\r\nrc |= BNX2X_DEF_SB_IDX;\r\n}\r\nbarrier();\r\nreturn rc;\r\n}\r\nstatic void bnx2x_attn_int_asserted(struct bnx2x *bp, u32 asserted)\r\n{\r\nint port = BP_PORT(bp);\r\nu32 aeu_addr = port ? MISC_REG_AEU_MASK_ATTN_FUNC_1 :\r\nMISC_REG_AEU_MASK_ATTN_FUNC_0;\r\nu32 nig_int_mask_addr = port ? NIG_REG_MASK_INTERRUPT_PORT1 :\r\nNIG_REG_MASK_INTERRUPT_PORT0;\r\nu32 aeu_mask;\r\nu32 nig_mask = 0;\r\nu32 reg_addr;\r\nif (bp->attn_state & asserted)\r\nBNX2X_ERR("IGU ERROR\n");\r\nbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_PORT0_ATT_MASK + port);\r\naeu_mask = REG_RD(bp, aeu_addr);\r\nDP(NETIF_MSG_HW, "aeu_mask %x newly asserted %x\n",\r\naeu_mask, asserted);\r\naeu_mask &= ~(asserted & 0x3ff);\r\nDP(NETIF_MSG_HW, "new mask %x\n", aeu_mask);\r\nREG_WR(bp, aeu_addr, aeu_mask);\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_PORT0_ATT_MASK + port);\r\nDP(NETIF_MSG_HW, "attn_state %x\n", bp->attn_state);\r\nbp->attn_state |= asserted;\r\nDP(NETIF_MSG_HW, "new state %x\n", bp->attn_state);\r\nif (asserted & ATTN_HARD_WIRED_MASK) {\r\nif (asserted & ATTN_NIG_FOR_FUNC) {\r\nbnx2x_acquire_phy_lock(bp);\r\nnig_mask = REG_RD(bp, nig_int_mask_addr);\r\nif (nig_mask) {\r\nREG_WR(bp, nig_int_mask_addr, 0);\r\nbnx2x_link_attn(bp);\r\n}\r\n}\r\nif (asserted & ATTN_SW_TIMER_4_FUNC)\r\nDP(NETIF_MSG_HW, "ATTN_SW_TIMER_4_FUNC!\n");\r\nif (asserted & GPIO_2_FUNC)\r\nDP(NETIF_MSG_HW, "GPIO_2_FUNC!\n");\r\nif (asserted & GPIO_3_FUNC)\r\nDP(NETIF_MSG_HW, "GPIO_3_FUNC!\n");\r\nif (asserted & GPIO_4_FUNC)\r\nDP(NETIF_MSG_HW, "GPIO_4_FUNC!\n");\r\nif (port == 0) {\r\nif (asserted & ATTN_GENERAL_ATTN_1) {\r\nDP(NETIF_MSG_HW, "ATTN_GENERAL_ATTN_1!\n");\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_1, 0x0);\r\n}\r\nif (asserted & ATTN_GENERAL_ATTN_2) {\r\nDP(NETIF_MSG_HW, "ATTN_GENERAL_ATTN_2!\n");\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_2, 0x0);\r\n}\r\nif (asserted & ATTN_GENERAL_ATTN_3) {\r\nDP(NETIF_MSG_HW, "ATTN_GENERAL_ATTN_3!\n");\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_3, 0x0);\r\n}\r\n} else {\r\nif (asserted & ATTN_GENERAL_ATTN_4) {\r\nDP(NETIF_MSG_HW, "ATTN_GENERAL_ATTN_4!\n");\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_4, 0x0);\r\n}\r\nif (asserted & ATTN_GENERAL_ATTN_5) {\r\nDP(NETIF_MSG_HW, "ATTN_GENERAL_ATTN_5!\n");\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_5, 0x0);\r\n}\r\nif (asserted & ATTN_GENERAL_ATTN_6) {\r\nDP(NETIF_MSG_HW, "ATTN_GENERAL_ATTN_6!\n");\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_6, 0x0);\r\n}\r\n}\r\n}\r\nif (bp->common.int_block == INT_BLOCK_HC)\r\nreg_addr = (HC_REG_COMMAND_REG + port*32 +\r\nCOMMAND_REG_ATTN_BITS_SET);\r\nelse\r\nreg_addr = (BAR_IGU_INTMEM + IGU_CMD_ATTN_BIT_SET_UPPER*8);\r\nDP(NETIF_MSG_HW, "about to mask 0x%08x at %s addr 0x%x\n", asserted,\r\n(bp->common.int_block == INT_BLOCK_HC) ? "HC" : "IGU", reg_addr);\r\nREG_WR(bp, reg_addr, asserted);\r\nif (asserted & ATTN_NIG_FOR_FUNC) {\r\nif (bp->common.int_block != INT_BLOCK_HC) {\r\nu32 cnt = 0, igu_acked;\r\ndo {\r\nigu_acked = REG_RD(bp,\r\nIGU_REG_ATTENTION_ACK_BITS);\r\n} while (((igu_acked & ATTN_NIG_FOR_FUNC) == 0) &&\r\n(++cnt < MAX_IGU_ATTN_ACK_TO));\r\nif (!igu_acked)\r\nDP(NETIF_MSG_HW,\r\n"Failed to verify IGU ack on time\n");\r\nbarrier();\r\n}\r\nREG_WR(bp, nig_int_mask_addr, nig_mask);\r\nbnx2x_release_phy_lock(bp);\r\n}\r\n}\r\nstatic void bnx2x_fan_failure(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nu32 ext_phy_config;\r\next_phy_config =\r\nSHMEM_RD(bp,\r\ndev_info.port_hw_config[port].external_phy_config);\r\next_phy_config &= ~PORT_HW_CFG_XGXS_EXT_PHY_TYPE_MASK;\r\next_phy_config |= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE;\r\nSHMEM_WR(bp, dev_info.port_hw_config[port].external_phy_config,\r\next_phy_config);\r\nnetdev_err(bp->dev, "Fan Failure on Network Controller has caused the driver to shutdown the card to prevent permanent damage.\n"\r\n"Please contact OEM Support for assistance\n");\r\nbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_FAN_FAILURE, 0);\r\n}\r\nstatic void bnx2x_attn_int_deasserted0(struct bnx2x *bp, u32 attn)\r\n{\r\nint port = BP_PORT(bp);\r\nint reg_offset;\r\nu32 val;\r\nreg_offset = (port ? MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0 :\r\nMISC_REG_AEU_ENABLE1_FUNC_0_OUT_0);\r\nif (attn & AEU_INPUTS_ATTN_BITS_SPIO5) {\r\nval = REG_RD(bp, reg_offset);\r\nval &= ~AEU_INPUTS_ATTN_BITS_SPIO5;\r\nREG_WR(bp, reg_offset, val);\r\nBNX2X_ERR("SPIO5 hw attention\n");\r\nbnx2x_hw_reset_phy(&bp->link_params);\r\nbnx2x_fan_failure(bp);\r\n}\r\nif ((attn & bp->link_vars.aeu_int_mask) && bp->port.pmf) {\r\nbnx2x_acquire_phy_lock(bp);\r\nbnx2x_handle_module_detect_int(&bp->link_params);\r\nbnx2x_release_phy_lock(bp);\r\n}\r\nif (attn & HW_INTERRUPT_ASSERT_SET_0) {\r\nval = REG_RD(bp, reg_offset);\r\nval &= ~(attn & HW_INTERRUPT_ASSERT_SET_0);\r\nREG_WR(bp, reg_offset, val);\r\nBNX2X_ERR("FATAL HW block attention set0 0x%x\n",\r\n(u32)(attn & HW_INTERRUPT_ASSERT_SET_0));\r\nbnx2x_panic();\r\n}\r\n}\r\nstatic void bnx2x_attn_int_deasserted1(struct bnx2x *bp, u32 attn)\r\n{\r\nu32 val;\r\nif (attn & AEU_INPUTS_ATTN_BITS_DOORBELLQ_HW_INTERRUPT) {\r\nval = REG_RD(bp, DORQ_REG_DORQ_INT_STS_CLR);\r\nBNX2X_ERR("DB hw attention 0x%x\n", val);\r\nif (val & 0x2)\r\nBNX2X_ERR("FATAL error from DORQ\n");\r\n}\r\nif (attn & HW_INTERRUPT_ASSERT_SET_1) {\r\nint port = BP_PORT(bp);\r\nint reg_offset;\r\nreg_offset = (port ? MISC_REG_AEU_ENABLE1_FUNC_1_OUT_1 :\r\nMISC_REG_AEU_ENABLE1_FUNC_0_OUT_1);\r\nval = REG_RD(bp, reg_offset);\r\nval &= ~(attn & HW_INTERRUPT_ASSERT_SET_1);\r\nREG_WR(bp, reg_offset, val);\r\nBNX2X_ERR("FATAL HW block attention set1 0x%x\n",\r\n(u32)(attn & HW_INTERRUPT_ASSERT_SET_1));\r\nbnx2x_panic();\r\n}\r\n}\r\nstatic void bnx2x_attn_int_deasserted2(struct bnx2x *bp, u32 attn)\r\n{\r\nu32 val;\r\nif (attn & AEU_INPUTS_ATTN_BITS_CFC_HW_INTERRUPT) {\r\nval = REG_RD(bp, CFC_REG_CFC_INT_STS_CLR);\r\nBNX2X_ERR("CFC hw attention 0x%x\n", val);\r\nif (val & 0x2)\r\nBNX2X_ERR("FATAL error from CFC\n");\r\n}\r\nif (attn & AEU_INPUTS_ATTN_BITS_PXP_HW_INTERRUPT) {\r\nval = REG_RD(bp, PXP_REG_PXP_INT_STS_CLR_0);\r\nBNX2X_ERR("PXP hw attention-0 0x%x\n", val);\r\nif (val & 0x18000)\r\nBNX2X_ERR("FATAL error from PXP\n");\r\nif (!CHIP_IS_E1x(bp)) {\r\nval = REG_RD(bp, PXP_REG_PXP_INT_STS_CLR_1);\r\nBNX2X_ERR("PXP hw attention-1 0x%x\n", val);\r\n}\r\n}\r\nif (attn & HW_INTERRUPT_ASSERT_SET_2) {\r\nint port = BP_PORT(bp);\r\nint reg_offset;\r\nreg_offset = (port ? MISC_REG_AEU_ENABLE1_FUNC_1_OUT_2 :\r\nMISC_REG_AEU_ENABLE1_FUNC_0_OUT_2);\r\nval = REG_RD(bp, reg_offset);\r\nval &= ~(attn & HW_INTERRUPT_ASSERT_SET_2);\r\nREG_WR(bp, reg_offset, val);\r\nBNX2X_ERR("FATAL HW block attention set2 0x%x\n",\r\n(u32)(attn & HW_INTERRUPT_ASSERT_SET_2));\r\nbnx2x_panic();\r\n}\r\n}\r\nstatic void bnx2x_attn_int_deasserted3(struct bnx2x *bp, u32 attn)\r\n{\r\nu32 val;\r\nif (attn & EVEREST_GEN_ATTN_IN_USE_MASK) {\r\nif (attn & BNX2X_PMF_LINK_ASSERT) {\r\nint func = BP_FUNC(bp);\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_12 + func*4, 0);\r\nbnx2x_read_mf_cfg(bp);\r\nbp->mf_config[BP_VN(bp)] = MF_CFG_RD(bp,\r\nfunc_mf_config[BP_ABS_FUNC(bp)].config);\r\nval = SHMEM_RD(bp,\r\nfunc_mb[BP_FW_MB_IDX(bp)].drv_status);\r\nif (val & (DRV_STATUS_DCC_EVENT_MASK |\r\nDRV_STATUS_OEM_EVENT_MASK))\r\nbnx2x_oem_event(bp,\r\n(val & (DRV_STATUS_DCC_EVENT_MASK |\r\nDRV_STATUS_OEM_EVENT_MASK)));\r\nif (val & DRV_STATUS_SET_MF_BW)\r\nbnx2x_set_mf_bw(bp);\r\nif (val & DRV_STATUS_DRV_INFO_REQ)\r\nbnx2x_handle_drv_info_req(bp);\r\nif (val & DRV_STATUS_VF_DISABLED)\r\nbnx2x_schedule_iov_task(bp,\r\nBNX2X_IOV_HANDLE_FLR);\r\nif ((bp->port.pmf == 0) && (val & DRV_STATUS_PMF))\r\nbnx2x_pmf_update(bp);\r\nif (bp->port.pmf &&\r\n(val & DRV_STATUS_DCBX_NEGOTIATION_RESULTS) &&\r\nbp->dcbx_enabled > 0)\r\nbnx2x_dcbx_set_params(bp,\r\nBNX2X_DCBX_STATE_NEG_RECEIVED);\r\nif (val & DRV_STATUS_AFEX_EVENT_MASK)\r\nbnx2x_handle_afex_cmd(bp,\r\nval & DRV_STATUS_AFEX_EVENT_MASK);\r\nif (val & DRV_STATUS_EEE_NEGOTIATION_RESULTS)\r\nbnx2x_handle_eee_event(bp);\r\nif (val & DRV_STATUS_OEM_UPDATE_SVID)\r\nbnx2x_handle_update_svid_cmd(bp);\r\nif (bp->link_vars.periodic_flags &\r\nPERIODIC_FLAGS_LINK_EVENT) {\r\nbnx2x_acquire_phy_lock(bp);\r\nbp->link_vars.periodic_flags &=\r\n~PERIODIC_FLAGS_LINK_EVENT;\r\nbnx2x_release_phy_lock(bp);\r\nif (IS_MF(bp))\r\nbnx2x_link_sync_notify(bp);\r\nbnx2x_link_report(bp);\r\n}\r\nbnx2x__link_status_update(bp);\r\n} else if (attn & BNX2X_MC_ASSERT_BITS) {\r\nBNX2X_ERR("MC assert!\n");\r\nbnx2x_mc_assert(bp);\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_10, 0);\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_9, 0);\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_8, 0);\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_7, 0);\r\nbnx2x_panic();\r\n} else if (attn & BNX2X_MCP_ASSERT) {\r\nBNX2X_ERR("MCP assert!\n");\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_11, 0);\r\nbnx2x_fw_dump(bp);\r\n} else\r\nBNX2X_ERR("Unknown HW assert! (attn 0x%x)\n", attn);\r\n}\r\nif (attn & EVEREST_LATCHED_ATTN_IN_USE_MASK) {\r\nBNX2X_ERR("LATCHED attention 0x%08x (masked)\n", attn);\r\nif (attn & BNX2X_GRC_TIMEOUT) {\r\nval = CHIP_IS_E1(bp) ? 0 :\r\nREG_RD(bp, MISC_REG_GRC_TIMEOUT_ATTN);\r\nBNX2X_ERR("GRC time-out 0x%08x\n", val);\r\n}\r\nif (attn & BNX2X_GRC_RSV) {\r\nval = CHIP_IS_E1(bp) ? 0 :\r\nREG_RD(bp, MISC_REG_GRC_RSV_ATTN);\r\nBNX2X_ERR("GRC reserved 0x%08x\n", val);\r\n}\r\nREG_WR(bp, MISC_REG_AEU_CLR_LATCH_SIGNAL, 0x7ff);\r\n}\r\n}\r\nvoid bnx2x_set_reset_global(struct bnx2x *bp)\r\n{\r\nu32 val;\r\nbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\r\nval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\r\nREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val | BNX2X_GLOBAL_RESET_BIT);\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\r\n}\r\nstatic void bnx2x_clear_reset_global(struct bnx2x *bp)\r\n{\r\nu32 val;\r\nbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\r\nval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\r\nREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val & (~BNX2X_GLOBAL_RESET_BIT));\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\r\n}\r\nstatic bool bnx2x_reset_is_global(struct bnx2x *bp)\r\n{\r\nu32 val = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\r\nDP(NETIF_MSG_HW, "GEN_REG_VAL=0x%08x\n", val);\r\nreturn (val & BNX2X_GLOBAL_RESET_BIT) ? true : false;\r\n}\r\nstatic void bnx2x_set_reset_done(struct bnx2x *bp)\r\n{\r\nu32 val;\r\nu32 bit = BP_PATH(bp) ?\r\nBNX2X_PATH1_RST_IN_PROG_BIT : BNX2X_PATH0_RST_IN_PROG_BIT;\r\nbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\r\nval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\r\nval &= ~bit;\r\nREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val);\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\r\n}\r\nvoid bnx2x_set_reset_in_progress(struct bnx2x *bp)\r\n{\r\nu32 val;\r\nu32 bit = BP_PATH(bp) ?\r\nBNX2X_PATH1_RST_IN_PROG_BIT : BNX2X_PATH0_RST_IN_PROG_BIT;\r\nbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\r\nval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\r\nval |= bit;\r\nREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val);\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\r\n}\r\nbool bnx2x_reset_is_done(struct bnx2x *bp, int engine)\r\n{\r\nu32 val = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\r\nu32 bit = engine ?\r\nBNX2X_PATH1_RST_IN_PROG_BIT : BNX2X_PATH0_RST_IN_PROG_BIT;\r\nreturn (val & bit) ? false : true;\r\n}\r\nvoid bnx2x_set_pf_load(struct bnx2x *bp)\r\n{\r\nu32 val1, val;\r\nu32 mask = BP_PATH(bp) ? BNX2X_PATH1_LOAD_CNT_MASK :\r\nBNX2X_PATH0_LOAD_CNT_MASK;\r\nu32 shift = BP_PATH(bp) ? BNX2X_PATH1_LOAD_CNT_SHIFT :\r\nBNX2X_PATH0_LOAD_CNT_SHIFT;\r\nbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\r\nval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\r\nDP(NETIF_MSG_IFUP, "Old GEN_REG_VAL=0x%08x\n", val);\r\nval1 = (val & mask) >> shift;\r\nval1 |= (1 << bp->pf_num);\r\nval &= ~mask;\r\nval |= ((val1 << shift) & mask);\r\nREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val);\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\r\n}\r\nbool bnx2x_clear_pf_load(struct bnx2x *bp)\r\n{\r\nu32 val1, val;\r\nu32 mask = BP_PATH(bp) ? BNX2X_PATH1_LOAD_CNT_MASK :\r\nBNX2X_PATH0_LOAD_CNT_MASK;\r\nu32 shift = BP_PATH(bp) ? BNX2X_PATH1_LOAD_CNT_SHIFT :\r\nBNX2X_PATH0_LOAD_CNT_SHIFT;\r\nbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\r\nval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\r\nDP(NETIF_MSG_IFDOWN, "Old GEN_REG_VAL=0x%08x\n", val);\r\nval1 = (val & mask) >> shift;\r\nval1 &= ~(1 << bp->pf_num);\r\nval &= ~mask;\r\nval |= ((val1 << shift) & mask);\r\nREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val);\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\r\nreturn val1 != 0;\r\n}\r\nstatic bool bnx2x_get_load_status(struct bnx2x *bp, int engine)\r\n{\r\nu32 mask = (engine ? BNX2X_PATH1_LOAD_CNT_MASK :\r\nBNX2X_PATH0_LOAD_CNT_MASK);\r\nu32 shift = (engine ? BNX2X_PATH1_LOAD_CNT_SHIFT :\r\nBNX2X_PATH0_LOAD_CNT_SHIFT);\r\nu32 val = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\r\nDP(NETIF_MSG_HW | NETIF_MSG_IFUP, "GLOB_REG=0x%08x\n", val);\r\nval = (val & mask) >> shift;\r\nDP(NETIF_MSG_HW | NETIF_MSG_IFUP, "load mask for engine %d = 0x%x\n",\r\nengine, val);\r\nreturn val != 0;\r\n}\r\nstatic void _print_parity(struct bnx2x *bp, u32 reg)\r\n{\r\npr_cont(" [0x%08x] ", REG_RD(bp, reg));\r\n}\r\nstatic void _print_next_block(int idx, const char *blk)\r\n{\r\npr_cont("%s%s", idx ? ", " : "", blk);\r\n}\r\nstatic bool bnx2x_check_blocks_with_parity0(struct bnx2x *bp, u32 sig,\r\nint *par_num, bool print)\r\n{\r\nu32 cur_bit;\r\nbool res;\r\nint i;\r\nres = false;\r\nfor (i = 0; sig; i++) {\r\ncur_bit = (0x1UL << i);\r\nif (sig & cur_bit) {\r\nres |= true;\r\nif (print) {\r\nswitch (cur_bit) {\r\ncase AEU_INPUTS_ATTN_BITS_BRB_PARITY_ERROR:\r\n_print_next_block((*par_num)++, "BRB");\r\n_print_parity(bp,\r\nBRB1_REG_BRB1_PRTY_STS);\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_PARSER_PARITY_ERROR:\r\n_print_next_block((*par_num)++,\r\n"PARSER");\r\n_print_parity(bp, PRS_REG_PRS_PRTY_STS);\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_TSDM_PARITY_ERROR:\r\n_print_next_block((*par_num)++, "TSDM");\r\n_print_parity(bp,\r\nTSDM_REG_TSDM_PRTY_STS);\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_SEARCHER_PARITY_ERROR:\r\n_print_next_block((*par_num)++,\r\n"SEARCHER");\r\n_print_parity(bp, SRC_REG_SRC_PRTY_STS);\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_TCM_PARITY_ERROR:\r\n_print_next_block((*par_num)++, "TCM");\r\n_print_parity(bp, TCM_REG_TCM_PRTY_STS);\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_TSEMI_PARITY_ERROR:\r\n_print_next_block((*par_num)++,\r\n"TSEMI");\r\n_print_parity(bp,\r\nTSEM_REG_TSEM_PRTY_STS_0);\r\n_print_parity(bp,\r\nTSEM_REG_TSEM_PRTY_STS_1);\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_PBCLIENT_PARITY_ERROR:\r\n_print_next_block((*par_num)++, "XPB");\r\n_print_parity(bp, GRCBASE_XPB +\r\nPB_REG_PB_PRTY_STS);\r\nbreak;\r\n}\r\n}\r\nsig &= ~cur_bit;\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic bool bnx2x_check_blocks_with_parity1(struct bnx2x *bp, u32 sig,\r\nint *par_num, bool *global,\r\nbool print)\r\n{\r\nu32 cur_bit;\r\nbool res;\r\nint i;\r\nres = false;\r\nfor (i = 0; sig; i++) {\r\ncur_bit = (0x1UL << i);\r\nif (sig & cur_bit) {\r\nres |= true;\r\nswitch (cur_bit) {\r\ncase AEU_INPUTS_ATTN_BITS_PBF_PARITY_ERROR:\r\nif (print) {\r\n_print_next_block((*par_num)++, "PBF");\r\n_print_parity(bp, PBF_REG_PBF_PRTY_STS);\r\n}\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_QM_PARITY_ERROR:\r\nif (print) {\r\n_print_next_block((*par_num)++, "QM");\r\n_print_parity(bp, QM_REG_QM_PRTY_STS);\r\n}\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_TIMERS_PARITY_ERROR:\r\nif (print) {\r\n_print_next_block((*par_num)++, "TM");\r\n_print_parity(bp, TM_REG_TM_PRTY_STS);\r\n}\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_XSDM_PARITY_ERROR:\r\nif (print) {\r\n_print_next_block((*par_num)++, "XSDM");\r\n_print_parity(bp,\r\nXSDM_REG_XSDM_PRTY_STS);\r\n}\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_XCM_PARITY_ERROR:\r\nif (print) {\r\n_print_next_block((*par_num)++, "XCM");\r\n_print_parity(bp, XCM_REG_XCM_PRTY_STS);\r\n}\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_XSEMI_PARITY_ERROR:\r\nif (print) {\r\n_print_next_block((*par_num)++,\r\n"XSEMI");\r\n_print_parity(bp,\r\nXSEM_REG_XSEM_PRTY_STS_0);\r\n_print_parity(bp,\r\nXSEM_REG_XSEM_PRTY_STS_1);\r\n}\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_DOORBELLQ_PARITY_ERROR:\r\nif (print) {\r\n_print_next_block((*par_num)++,\r\n"DOORBELLQ");\r\n_print_parity(bp,\r\nDORQ_REG_DORQ_PRTY_STS);\r\n}\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_NIG_PARITY_ERROR:\r\nif (print) {\r\n_print_next_block((*par_num)++, "NIG");\r\nif (CHIP_IS_E1x(bp)) {\r\n_print_parity(bp,\r\nNIG_REG_NIG_PRTY_STS);\r\n} else {\r\n_print_parity(bp,\r\nNIG_REG_NIG_PRTY_STS_0);\r\n_print_parity(bp,\r\nNIG_REG_NIG_PRTY_STS_1);\r\n}\r\n}\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_VAUX_PCI_CORE_PARITY_ERROR:\r\nif (print)\r\n_print_next_block((*par_num)++,\r\n"VAUX PCI CORE");\r\n*global = true;\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_DEBUG_PARITY_ERROR:\r\nif (print) {\r\n_print_next_block((*par_num)++,\r\n"DEBUG");\r\n_print_parity(bp, DBG_REG_DBG_PRTY_STS);\r\n}\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_USDM_PARITY_ERROR:\r\nif (print) {\r\n_print_next_block((*par_num)++, "USDM");\r\n_print_parity(bp,\r\nUSDM_REG_USDM_PRTY_STS);\r\n}\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_UCM_PARITY_ERROR:\r\nif (print) {\r\n_print_next_block((*par_num)++, "UCM");\r\n_print_parity(bp, UCM_REG_UCM_PRTY_STS);\r\n}\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_USEMI_PARITY_ERROR:\r\nif (print) {\r\n_print_next_block((*par_num)++,\r\n"USEMI");\r\n_print_parity(bp,\r\nUSEM_REG_USEM_PRTY_STS_0);\r\n_print_parity(bp,\r\nUSEM_REG_USEM_PRTY_STS_1);\r\n}\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_UPB_PARITY_ERROR:\r\nif (print) {\r\n_print_next_block((*par_num)++, "UPB");\r\n_print_parity(bp, GRCBASE_UPB +\r\nPB_REG_PB_PRTY_STS);\r\n}\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_CSDM_PARITY_ERROR:\r\nif (print) {\r\n_print_next_block((*par_num)++, "CSDM");\r\n_print_parity(bp,\r\nCSDM_REG_CSDM_PRTY_STS);\r\n}\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_CCM_PARITY_ERROR:\r\nif (print) {\r\n_print_next_block((*par_num)++, "CCM");\r\n_print_parity(bp, CCM_REG_CCM_PRTY_STS);\r\n}\r\nbreak;\r\n}\r\nsig &= ~cur_bit;\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic bool bnx2x_check_blocks_with_parity2(struct bnx2x *bp, u32 sig,\r\nint *par_num, bool print)\r\n{\r\nu32 cur_bit;\r\nbool res;\r\nint i;\r\nres = false;\r\nfor (i = 0; sig; i++) {\r\ncur_bit = (0x1UL << i);\r\nif (sig & cur_bit) {\r\nres = true;\r\nif (print) {\r\nswitch (cur_bit) {\r\ncase AEU_INPUTS_ATTN_BITS_CSEMI_PARITY_ERROR:\r\n_print_next_block((*par_num)++,\r\n"CSEMI");\r\n_print_parity(bp,\r\nCSEM_REG_CSEM_PRTY_STS_0);\r\n_print_parity(bp,\r\nCSEM_REG_CSEM_PRTY_STS_1);\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_PXP_PARITY_ERROR:\r\n_print_next_block((*par_num)++, "PXP");\r\n_print_parity(bp, PXP_REG_PXP_PRTY_STS);\r\n_print_parity(bp,\r\nPXP2_REG_PXP2_PRTY_STS_0);\r\n_print_parity(bp,\r\nPXP2_REG_PXP2_PRTY_STS_1);\r\nbreak;\r\ncase AEU_IN_ATTN_BITS_PXPPCICLOCKCLIENT_PARITY_ERROR:\r\n_print_next_block((*par_num)++,\r\n"PXPPCICLOCKCLIENT");\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_CFC_PARITY_ERROR:\r\n_print_next_block((*par_num)++, "CFC");\r\n_print_parity(bp,\r\nCFC_REG_CFC_PRTY_STS);\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_CDU_PARITY_ERROR:\r\n_print_next_block((*par_num)++, "CDU");\r\n_print_parity(bp, CDU_REG_CDU_PRTY_STS);\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_DMAE_PARITY_ERROR:\r\n_print_next_block((*par_num)++, "DMAE");\r\n_print_parity(bp,\r\nDMAE_REG_DMAE_PRTY_STS);\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_IGU_PARITY_ERROR:\r\n_print_next_block((*par_num)++, "IGU");\r\nif (CHIP_IS_E1x(bp))\r\n_print_parity(bp,\r\nHC_REG_HC_PRTY_STS);\r\nelse\r\n_print_parity(bp,\r\nIGU_REG_IGU_PRTY_STS);\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_MISC_PARITY_ERROR:\r\n_print_next_block((*par_num)++, "MISC");\r\n_print_parity(bp,\r\nMISC_REG_MISC_PRTY_STS);\r\nbreak;\r\n}\r\n}\r\nsig &= ~cur_bit;\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic bool bnx2x_check_blocks_with_parity3(struct bnx2x *bp, u32 sig,\r\nint *par_num, bool *global,\r\nbool print)\r\n{\r\nbool res = false;\r\nu32 cur_bit;\r\nint i;\r\nfor (i = 0; sig; i++) {\r\ncur_bit = (0x1UL << i);\r\nif (sig & cur_bit) {\r\nswitch (cur_bit) {\r\ncase AEU_INPUTS_ATTN_BITS_MCP_LATCHED_ROM_PARITY:\r\nif (print)\r\n_print_next_block((*par_num)++,\r\n"MCP ROM");\r\n*global = true;\r\nres = true;\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_RX_PARITY:\r\nif (print)\r\n_print_next_block((*par_num)++,\r\n"MCP UMP RX");\r\n*global = true;\r\nres = true;\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_TX_PARITY:\r\nif (print)\r\n_print_next_block((*par_num)++,\r\n"MCP UMP TX");\r\n*global = true;\r\nres = true;\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY:\r\n(*par_num)++;\r\nREG_WR(bp, MISC_REG_AEU_CLR_LATCH_SIGNAL,\r\n1UL << 10);\r\nbreak;\r\n}\r\nsig &= ~cur_bit;\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic bool bnx2x_check_blocks_with_parity4(struct bnx2x *bp, u32 sig,\r\nint *par_num, bool print)\r\n{\r\nu32 cur_bit;\r\nbool res;\r\nint i;\r\nres = false;\r\nfor (i = 0; sig; i++) {\r\ncur_bit = (0x1UL << i);\r\nif (sig & cur_bit) {\r\nres = true;\r\nif (print) {\r\nswitch (cur_bit) {\r\ncase AEU_INPUTS_ATTN_BITS_PGLUE_PARITY_ERROR:\r\n_print_next_block((*par_num)++,\r\n"PGLUE_B");\r\n_print_parity(bp,\r\nPGLUE_B_REG_PGLUE_B_PRTY_STS);\r\nbreak;\r\ncase AEU_INPUTS_ATTN_BITS_ATC_PARITY_ERROR:\r\n_print_next_block((*par_num)++, "ATC");\r\n_print_parity(bp,\r\nATC_REG_ATC_PRTY_STS);\r\nbreak;\r\n}\r\n}\r\nsig &= ~cur_bit;\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic bool bnx2x_parity_attn(struct bnx2x *bp, bool *global, bool print,\r\nu32 *sig)\r\n{\r\nbool res = false;\r\nif ((sig[0] & HW_PRTY_ASSERT_SET_0) ||\r\n(sig[1] & HW_PRTY_ASSERT_SET_1) ||\r\n(sig[2] & HW_PRTY_ASSERT_SET_2) ||\r\n(sig[3] & HW_PRTY_ASSERT_SET_3) ||\r\n(sig[4] & HW_PRTY_ASSERT_SET_4)) {\r\nint par_num = 0;\r\nDP(NETIF_MSG_HW, "Was parity error: HW block parity attention:\n"\r\n"[0]:0x%08x [1]:0x%08x [2]:0x%08x [3]:0x%08x [4]:0x%08x\n",\r\nsig[0] & HW_PRTY_ASSERT_SET_0,\r\nsig[1] & HW_PRTY_ASSERT_SET_1,\r\nsig[2] & HW_PRTY_ASSERT_SET_2,\r\nsig[3] & HW_PRTY_ASSERT_SET_3,\r\nsig[4] & HW_PRTY_ASSERT_SET_4);\r\nif (print) {\r\nif (((sig[0] & HW_PRTY_ASSERT_SET_0) ||\r\n(sig[1] & HW_PRTY_ASSERT_SET_1) ||\r\n(sig[2] & HW_PRTY_ASSERT_SET_2) ||\r\n(sig[4] & HW_PRTY_ASSERT_SET_4)) ||\r\n(sig[3] & HW_PRTY_ASSERT_SET_3_WITHOUT_SCPAD)) {\r\nnetdev_err(bp->dev,\r\n"Parity errors detected in blocks: ");\r\n} else {\r\nprint = false;\r\n}\r\n}\r\nres |= bnx2x_check_blocks_with_parity0(bp,\r\nsig[0] & HW_PRTY_ASSERT_SET_0, &par_num, print);\r\nres |= bnx2x_check_blocks_with_parity1(bp,\r\nsig[1] & HW_PRTY_ASSERT_SET_1, &par_num, global, print);\r\nres |= bnx2x_check_blocks_with_parity2(bp,\r\nsig[2] & HW_PRTY_ASSERT_SET_2, &par_num, print);\r\nres |= bnx2x_check_blocks_with_parity3(bp,\r\nsig[3] & HW_PRTY_ASSERT_SET_3, &par_num, global, print);\r\nres |= bnx2x_check_blocks_with_parity4(bp,\r\nsig[4] & HW_PRTY_ASSERT_SET_4, &par_num, print);\r\nif (print)\r\npr_cont("\n");\r\n}\r\nreturn res;\r\n}\r\nbool bnx2x_chk_parity_attn(struct bnx2x *bp, bool *global, bool print)\r\n{\r\nstruct attn_route attn = { {0} };\r\nint port = BP_PORT(bp);\r\nattn.sig[0] = REG_RD(bp,\r\nMISC_REG_AEU_AFTER_INVERT_1_FUNC_0 +\r\nport*4);\r\nattn.sig[1] = REG_RD(bp,\r\nMISC_REG_AEU_AFTER_INVERT_2_FUNC_0 +\r\nport*4);\r\nattn.sig[2] = REG_RD(bp,\r\nMISC_REG_AEU_AFTER_INVERT_3_FUNC_0 +\r\nport*4);\r\nattn.sig[3] = REG_RD(bp,\r\nMISC_REG_AEU_AFTER_INVERT_4_FUNC_0 +\r\nport*4);\r\nattn.sig[3] &= ((REG_RD(bp,\r\n!port ? MISC_REG_AEU_ENABLE4_FUNC_0_OUT_0\r\n: MISC_REG_AEU_ENABLE4_FUNC_1_OUT_0) &\r\nMISC_AEU_ENABLE_MCP_PRTY_BITS) |\r\n~MISC_AEU_ENABLE_MCP_PRTY_BITS);\r\nif (!CHIP_IS_E1x(bp))\r\nattn.sig[4] = REG_RD(bp,\r\nMISC_REG_AEU_AFTER_INVERT_5_FUNC_0 +\r\nport*4);\r\nreturn bnx2x_parity_attn(bp, global, print, attn.sig);\r\n}\r\nstatic void bnx2x_attn_int_deasserted4(struct bnx2x *bp, u32 attn)\r\n{\r\nu32 val;\r\nif (attn & AEU_INPUTS_ATTN_BITS_PGLUE_HW_INTERRUPT) {\r\nval = REG_RD(bp, PGLUE_B_REG_PGLUE_B_INT_STS_CLR);\r\nBNX2X_ERR("PGLUE hw attention 0x%x\n", val);\r\nif (val & PGLUE_B_PGLUE_B_INT_STS_REG_ADDRESS_ERROR)\r\nBNX2X_ERR("PGLUE_B_PGLUE_B_INT_STS_REG_ADDRESS_ERROR\n");\r\nif (val & PGLUE_B_PGLUE_B_INT_STS_REG_INCORRECT_RCV_BEHAVIOR)\r\nBNX2X_ERR("PGLUE_B_PGLUE_B_INT_STS_REG_INCORRECT_RCV_BEHAVIOR\n");\r\nif (val & PGLUE_B_PGLUE_B_INT_STS_REG_WAS_ERROR_ATTN)\r\nBNX2X_ERR("PGLUE_B_PGLUE_B_INT_STS_REG_WAS_ERROR_ATTN\n");\r\nif (val & PGLUE_B_PGLUE_B_INT_STS_REG_VF_LENGTH_VIOLATION_ATTN)\r\nBNX2X_ERR("PGLUE_B_PGLUE_B_INT_STS_REG_VF_LENGTH_VIOLATION_ATTN\n");\r\nif (val &\r\nPGLUE_B_PGLUE_B_INT_STS_REG_VF_GRC_SPACE_VIOLATION_ATTN)\r\nBNX2X_ERR("PGLUE_B_PGLUE_B_INT_STS_REG_VF_GRC_SPACE_VIOLATION_ATTN\n");\r\nif (val &\r\nPGLUE_B_PGLUE_B_INT_STS_REG_VF_MSIX_BAR_VIOLATION_ATTN)\r\nBNX2X_ERR("PGLUE_B_PGLUE_B_INT_STS_REG_VF_MSIX_BAR_VIOLATION_ATTN\n");\r\nif (val & PGLUE_B_PGLUE_B_INT_STS_REG_TCPL_ERROR_ATTN)\r\nBNX2X_ERR("PGLUE_B_PGLUE_B_INT_STS_REG_TCPL_ERROR_ATTN\n");\r\nif (val & PGLUE_B_PGLUE_B_INT_STS_REG_TCPL_IN_TWO_RCBS_ATTN)\r\nBNX2X_ERR("PGLUE_B_PGLUE_B_INT_STS_REG_TCPL_IN_TWO_RCBS_ATTN\n");\r\nif (val & PGLUE_B_PGLUE_B_INT_STS_REG_CSSNOOP_FIFO_OVERFLOW)\r\nBNX2X_ERR("PGLUE_B_PGLUE_B_INT_STS_REG_CSSNOOP_FIFO_OVERFLOW\n");\r\n}\r\nif (attn & AEU_INPUTS_ATTN_BITS_ATC_HW_INTERRUPT) {\r\nval = REG_RD(bp, ATC_REG_ATC_INT_STS_CLR);\r\nBNX2X_ERR("ATC hw attention 0x%x\n", val);\r\nif (val & ATC_ATC_INT_STS_REG_ADDRESS_ERROR)\r\nBNX2X_ERR("ATC_ATC_INT_STS_REG_ADDRESS_ERROR\n");\r\nif (val & ATC_ATC_INT_STS_REG_ATC_TCPL_TO_NOT_PEND)\r\nBNX2X_ERR("ATC_ATC_INT_STS_REG_ATC_TCPL_TO_NOT_PEND\n");\r\nif (val & ATC_ATC_INT_STS_REG_ATC_GPA_MULTIPLE_HITS)\r\nBNX2X_ERR("ATC_ATC_INT_STS_REG_ATC_GPA_MULTIPLE_HITS\n");\r\nif (val & ATC_ATC_INT_STS_REG_ATC_RCPL_TO_EMPTY_CNT)\r\nBNX2X_ERR("ATC_ATC_INT_STS_REG_ATC_RCPL_TO_EMPTY_CNT\n");\r\nif (val & ATC_ATC_INT_STS_REG_ATC_TCPL_ERROR)\r\nBNX2X_ERR("ATC_ATC_INT_STS_REG_ATC_TCPL_ERROR\n");\r\nif (val & ATC_ATC_INT_STS_REG_ATC_IREQ_LESS_THAN_STU)\r\nBNX2X_ERR("ATC_ATC_INT_STS_REG_ATC_IREQ_LESS_THAN_STU\n");\r\n}\r\nif (attn & (AEU_INPUTS_ATTN_BITS_PGLUE_PARITY_ERROR |\r\nAEU_INPUTS_ATTN_BITS_ATC_PARITY_ERROR)) {\r\nBNX2X_ERR("FATAL parity attention set4 0x%x\n",\r\n(u32)(attn & (AEU_INPUTS_ATTN_BITS_PGLUE_PARITY_ERROR |\r\nAEU_INPUTS_ATTN_BITS_ATC_PARITY_ERROR)));\r\n}\r\n}\r\nstatic void bnx2x_attn_int_deasserted(struct bnx2x *bp, u32 deasserted)\r\n{\r\nstruct attn_route attn, *group_mask;\r\nint port = BP_PORT(bp);\r\nint index;\r\nu32 reg_addr;\r\nu32 val;\r\nu32 aeu_mask;\r\nbool global = false;\r\nbnx2x_acquire_alr(bp);\r\nif (bnx2x_chk_parity_attn(bp, &global, true)) {\r\n#ifndef BNX2X_STOP_ON_ERROR\r\nbp->recovery_state = BNX2X_RECOVERY_INIT;\r\nschedule_delayed_work(&bp->sp_rtnl_task, 0);\r\nbnx2x_int_disable(bp);\r\n#else\r\nbnx2x_panic();\r\n#endif\r\nbnx2x_release_alr(bp);\r\nreturn;\r\n}\r\nattn.sig[0] = REG_RD(bp, MISC_REG_AEU_AFTER_INVERT_1_FUNC_0 + port*4);\r\nattn.sig[1] = REG_RD(bp, MISC_REG_AEU_AFTER_INVERT_2_FUNC_0 + port*4);\r\nattn.sig[2] = REG_RD(bp, MISC_REG_AEU_AFTER_INVERT_3_FUNC_0 + port*4);\r\nattn.sig[3] = REG_RD(bp, MISC_REG_AEU_AFTER_INVERT_4_FUNC_0 + port*4);\r\nif (!CHIP_IS_E1x(bp))\r\nattn.sig[4] =\r\nREG_RD(bp, MISC_REG_AEU_AFTER_INVERT_5_FUNC_0 + port*4);\r\nelse\r\nattn.sig[4] = 0;\r\nDP(NETIF_MSG_HW, "attn: %08x %08x %08x %08x %08x\n",\r\nattn.sig[0], attn.sig[1], attn.sig[2], attn.sig[3], attn.sig[4]);\r\nfor (index = 0; index < MAX_DYNAMIC_ATTN_GRPS; index++) {\r\nif (deasserted & (1 << index)) {\r\ngroup_mask = &bp->attn_group[index];\r\nDP(NETIF_MSG_HW, "group[%d]: %08x %08x %08x %08x %08x\n",\r\nindex,\r\ngroup_mask->sig[0], group_mask->sig[1],\r\ngroup_mask->sig[2], group_mask->sig[3],\r\ngroup_mask->sig[4]);\r\nbnx2x_attn_int_deasserted4(bp,\r\nattn.sig[4] & group_mask->sig[4]);\r\nbnx2x_attn_int_deasserted3(bp,\r\nattn.sig[3] & group_mask->sig[3]);\r\nbnx2x_attn_int_deasserted1(bp,\r\nattn.sig[1] & group_mask->sig[1]);\r\nbnx2x_attn_int_deasserted2(bp,\r\nattn.sig[2] & group_mask->sig[2]);\r\nbnx2x_attn_int_deasserted0(bp,\r\nattn.sig[0] & group_mask->sig[0]);\r\n}\r\n}\r\nbnx2x_release_alr(bp);\r\nif (bp->common.int_block == INT_BLOCK_HC)\r\nreg_addr = (HC_REG_COMMAND_REG + port*32 +\r\nCOMMAND_REG_ATTN_BITS_CLR);\r\nelse\r\nreg_addr = (BAR_IGU_INTMEM + IGU_CMD_ATTN_BIT_CLR_UPPER*8);\r\nval = ~deasserted;\r\nDP(NETIF_MSG_HW, "about to mask 0x%08x at %s addr 0x%x\n", val,\r\n(bp->common.int_block == INT_BLOCK_HC) ? "HC" : "IGU", reg_addr);\r\nREG_WR(bp, reg_addr, val);\r\nif (~bp->attn_state & deasserted)\r\nBNX2X_ERR("IGU ERROR\n");\r\nreg_addr = port ? MISC_REG_AEU_MASK_ATTN_FUNC_1 :\r\nMISC_REG_AEU_MASK_ATTN_FUNC_0;\r\nbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_PORT0_ATT_MASK + port);\r\naeu_mask = REG_RD(bp, reg_addr);\r\nDP(NETIF_MSG_HW, "aeu_mask %x newly deasserted %x\n",\r\naeu_mask, deasserted);\r\naeu_mask |= (deasserted & 0x3ff);\r\nDP(NETIF_MSG_HW, "new mask %x\n", aeu_mask);\r\nREG_WR(bp, reg_addr, aeu_mask);\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_PORT0_ATT_MASK + port);\r\nDP(NETIF_MSG_HW, "attn_state %x\n", bp->attn_state);\r\nbp->attn_state &= ~deasserted;\r\nDP(NETIF_MSG_HW, "new state %x\n", bp->attn_state);\r\n}\r\nstatic void bnx2x_attn_int(struct bnx2x *bp)\r\n{\r\nu32 attn_bits = le32_to_cpu(bp->def_status_blk->atten_status_block.\r\nattn_bits);\r\nu32 attn_ack = le32_to_cpu(bp->def_status_blk->atten_status_block.\r\nattn_bits_ack);\r\nu32 attn_state = bp->attn_state;\r\nu32 asserted = attn_bits & ~attn_ack & ~attn_state;\r\nu32 deasserted = ~attn_bits & attn_ack & attn_state;\r\nDP(NETIF_MSG_HW,\r\n"attn_bits %x attn_ack %x asserted %x deasserted %x\n",\r\nattn_bits, attn_ack, asserted, deasserted);\r\nif (~(attn_bits ^ attn_ack) & (attn_bits ^ attn_state))\r\nBNX2X_ERR("BAD attention state\n");\r\nif (asserted)\r\nbnx2x_attn_int_asserted(bp, asserted);\r\nif (deasserted)\r\nbnx2x_attn_int_deasserted(bp, deasserted);\r\n}\r\nvoid bnx2x_igu_ack_sb(struct bnx2x *bp, u8 igu_sb_id, u8 segment,\r\nu16 index, u8 op, u8 update)\r\n{\r\nu32 igu_addr = bp->igu_base_addr;\r\nigu_addr += (IGU_CMD_INT_ACK_BASE + igu_sb_id)*8;\r\nbnx2x_igu_ack_sb_gen(bp, igu_sb_id, segment, index, op, update,\r\nigu_addr);\r\n}\r\nstatic void bnx2x_update_eq_prod(struct bnx2x *bp, u16 prod)\r\n{\r\nstorm_memset_eq_prod(bp, prod, BP_FUNC(bp));\r\nmmiowb();\r\n}\r\nstatic int bnx2x_cnic_handle_cfc_del(struct bnx2x *bp, u32 cid,\r\nunion event_ring_elem *elem)\r\n{\r\nu8 err = elem->message.error;\r\nif (!bp->cnic_eth_dev.starting_cid ||\r\n(cid < bp->cnic_eth_dev.starting_cid &&\r\ncid != bp->cnic_eth_dev.iscsi_l2_cid))\r\nreturn 1;\r\nDP(BNX2X_MSG_SP, "got delete ramrod for CNIC CID %d\n", cid);\r\nif (unlikely(err)) {\r\nBNX2X_ERR("got delete ramrod for CNIC CID %d with error!\n",\r\ncid);\r\nbnx2x_panic_dump(bp, false);\r\n}\r\nbnx2x_cnic_cfc_comp(bp, cid, err);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_handle_mcast_eqe(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_mcast_ramrod_params rparam;\r\nint rc;\r\nmemset(&rparam, 0, sizeof(rparam));\r\nrparam.mcast_obj = &bp->mcast_obj;\r\nnetif_addr_lock_bh(bp->dev);\r\nbp->mcast_obj.raw.clear_pending(&bp->mcast_obj.raw);\r\nif (bp->mcast_obj.check_pending(&bp->mcast_obj)) {\r\nrc = bnx2x_config_mcast(bp, &rparam, BNX2X_MCAST_CMD_CONT);\r\nif (rc < 0)\r\nBNX2X_ERR("Failed to send pending mcast commands: %d\n",\r\nrc);\r\n}\r\nnetif_addr_unlock_bh(bp->dev);\r\n}\r\nstatic void bnx2x_handle_classification_eqe(struct bnx2x *bp,\r\nunion event_ring_elem *elem)\r\n{\r\nunsigned long ramrod_flags = 0;\r\nint rc = 0;\r\nu32 echo = le32_to_cpu(elem->message.data.eth_event.echo);\r\nu32 cid = echo & BNX2X_SWCID_MASK;\r\nstruct bnx2x_vlan_mac_obj *vlan_mac_obj;\r\n__set_bit(RAMROD_CONT, &ramrod_flags);\r\nswitch (echo >> BNX2X_SWCID_SHIFT) {\r\ncase BNX2X_FILTER_MAC_PENDING:\r\nDP(BNX2X_MSG_SP, "Got SETUP_MAC completions\n");\r\nif (CNIC_LOADED(bp) && (cid == BNX2X_ISCSI_ETH_CID(bp)))\r\nvlan_mac_obj = &bp->iscsi_l2_mac_obj;\r\nelse\r\nvlan_mac_obj = &bp->sp_objs[cid].mac_obj;\r\nbreak;\r\ncase BNX2X_FILTER_VLAN_PENDING:\r\nDP(BNX2X_MSG_SP, "Got SETUP_VLAN completions\n");\r\nvlan_mac_obj = &bp->sp_objs[cid].vlan_obj;\r\nbreak;\r\ncase BNX2X_FILTER_MCAST_PENDING:\r\nDP(BNX2X_MSG_SP, "Got SETUP_MCAST completions\n");\r\nbnx2x_handle_mcast_eqe(bp);\r\nreturn;\r\ndefault:\r\nBNX2X_ERR("Unsupported classification command: 0x%x\n", echo);\r\nreturn;\r\n}\r\nrc = vlan_mac_obj->complete(bp, vlan_mac_obj, elem, &ramrod_flags);\r\nif (rc < 0)\r\nBNX2X_ERR("Failed to schedule new commands: %d\n", rc);\r\nelse if (rc > 0)\r\nDP(BNX2X_MSG_SP, "Scheduled next pending commands...\n");\r\n}\r\nstatic void bnx2x_handle_rx_mode_eqe(struct bnx2x *bp)\r\n{\r\nnetif_addr_lock_bh(bp->dev);\r\nclear_bit(BNX2X_FILTER_RX_MODE_PENDING, &bp->sp_state);\r\nif (test_and_clear_bit(BNX2X_FILTER_RX_MODE_SCHED, &bp->sp_state))\r\nbnx2x_set_storm_rx_mode(bp);\r\nelse if (test_and_clear_bit(BNX2X_FILTER_ISCSI_ETH_START_SCHED,\r\n&bp->sp_state))\r\nbnx2x_set_iscsi_eth_rx_mode(bp, true);\r\nelse if (test_and_clear_bit(BNX2X_FILTER_ISCSI_ETH_STOP_SCHED,\r\n&bp->sp_state))\r\nbnx2x_set_iscsi_eth_rx_mode(bp, false);\r\nnetif_addr_unlock_bh(bp->dev);\r\n}\r\nstatic void bnx2x_after_afex_vif_lists(struct bnx2x *bp,\r\nunion event_ring_elem *elem)\r\n{\r\nif (elem->message.data.vif_list_event.echo == VIF_LIST_RULE_GET) {\r\nDP(BNX2X_MSG_SP,\r\n"afex: ramrod completed VIF LIST_GET, addrs 0x%x\n",\r\nelem->message.data.vif_list_event.func_bit_map);\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_LISTGET_ACK,\r\nelem->message.data.vif_list_event.func_bit_map);\r\n} else if (elem->message.data.vif_list_event.echo ==\r\nVIF_LIST_RULE_SET) {\r\nDP(BNX2X_MSG_SP, "afex: ramrod completed VIF LIST_SET\n");\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_LISTSET_ACK, 0);\r\n}\r\n}\r\nstatic void bnx2x_after_function_update(struct bnx2x *bp)\r\n{\r\nint q, rc;\r\nstruct bnx2x_fastpath *fp;\r\nstruct bnx2x_queue_state_params queue_params = {NULL};\r\nstruct bnx2x_queue_update_params *q_update_params =\r\n&queue_params.params.update;\r\nqueue_params.cmd = BNX2X_Q_CMD_UPDATE;\r\n__set_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM_CHNG,\r\n&q_update_params->update_flags);\r\n__set_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM,\r\n&q_update_params->update_flags);\r\n__set_bit(RAMROD_COMP_WAIT, &queue_params.ramrod_flags);\r\nif (bp->afex_vlan_mode == FUNC_MF_CFG_AFEX_VLAN_ACCESS_MODE) {\r\nq_update_params->silent_removal_value = 0;\r\nq_update_params->silent_removal_mask = 0;\r\n} else {\r\nq_update_params->silent_removal_value =\r\n(bp->afex_def_vlan_tag & VLAN_VID_MASK);\r\nq_update_params->silent_removal_mask = VLAN_VID_MASK;\r\n}\r\nfor_each_eth_queue(bp, q) {\r\nfp = &bp->fp[q];\r\nqueue_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\r\nrc = bnx2x_queue_state_change(bp, &queue_params);\r\nif (rc < 0)\r\nBNX2X_ERR("Failed to config silent vlan rem for Q %d\n",\r\nq);\r\n}\r\nif (!NO_FCOE(bp) && CNIC_ENABLED(bp)) {\r\nfp = &bp->fp[FCOE_IDX(bp)];\r\nqueue_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\r\n__clear_bit(RAMROD_COMP_WAIT, &queue_params.ramrod_flags);\r\nsmp_mb__before_atomic();\r\nset_bit(BNX2X_AFEX_FCOE_Q_UPDATE_PENDING, &bp->sp_state);\r\nsmp_mb__after_atomic();\r\nrc = bnx2x_queue_state_change(bp, &queue_params);\r\nif (rc < 0)\r\nBNX2X_ERR("Failed to config silent vlan rem for Q %d\n",\r\nq);\r\n} else {\r\nbnx2x_link_report(bp);\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_VIFSET_ACK, 0);\r\n}\r\n}\r\nstatic struct bnx2x_queue_sp_obj *bnx2x_cid_to_q_obj(\r\nstruct bnx2x *bp, u32 cid)\r\n{\r\nDP(BNX2X_MSG_SP, "retrieving fp from cid %d\n", cid);\r\nif (CNIC_LOADED(bp) && (cid == BNX2X_FCOE_ETH_CID(bp)))\r\nreturn &bnx2x_fcoe_sp_obj(bp, q_obj);\r\nelse\r\nreturn &bp->sp_objs[CID_TO_FP(cid, bp)].q_obj;\r\n}\r\nstatic void bnx2x_eq_int(struct bnx2x *bp)\r\n{\r\nu16 hw_cons, sw_cons, sw_prod;\r\nunion event_ring_elem *elem;\r\nu8 echo;\r\nu32 cid;\r\nu8 opcode;\r\nint rc, spqe_cnt = 0;\r\nstruct bnx2x_queue_sp_obj *q_obj;\r\nstruct bnx2x_func_sp_obj *f_obj = &bp->func_obj;\r\nstruct bnx2x_raw_obj *rss_raw = &bp->rss_conf_obj.raw;\r\nhw_cons = le16_to_cpu(*bp->eq_cons_sb);\r\nif ((hw_cons & EQ_DESC_MAX_PAGE) == EQ_DESC_MAX_PAGE)\r\nhw_cons++;\r\nsw_cons = bp->eq_cons;\r\nsw_prod = bp->eq_prod;\r\nDP(BNX2X_MSG_SP, "EQ: hw_cons %u sw_cons %u bp->eq_spq_left %x\n",\r\nhw_cons, sw_cons, atomic_read(&bp->eq_spq_left));\r\nfor (; sw_cons != hw_cons;\r\nsw_prod = NEXT_EQ_IDX(sw_prod), sw_cons = NEXT_EQ_IDX(sw_cons)) {\r\nelem = &bp->eq_ring[EQ_DESC(sw_cons)];\r\nrc = bnx2x_iov_eq_sp_event(bp, elem);\r\nif (!rc) {\r\nDP(BNX2X_MSG_IOV, "bnx2x_iov_eq_sp_event returned %d\n",\r\nrc);\r\ngoto next_spqe;\r\n}\r\nopcode = elem->message.opcode;\r\nswitch (opcode) {\r\ncase EVENT_RING_OPCODE_VF_PF_CHANNEL:\r\nbnx2x_vf_mbx_schedule(bp,\r\n&elem->message.data.vf_pf_event);\r\ncontinue;\r\ncase EVENT_RING_OPCODE_STAT_QUERY:\r\nDP_AND((BNX2X_MSG_SP | BNX2X_MSG_STATS),\r\n"got statistics comp event %d\n",\r\nbp->stats_comp++);\r\ngoto next_spqe;\r\ncase EVENT_RING_OPCODE_CFC_DEL:\r\ncid = SW_CID(elem->message.data.cfc_del_event.cid);\r\nDP(BNX2X_MSG_SP,\r\n"got delete ramrod for MULTI[%d]\n", cid);\r\nif (CNIC_LOADED(bp) &&\r\n!bnx2x_cnic_handle_cfc_del(bp, cid, elem))\r\ngoto next_spqe;\r\nq_obj = bnx2x_cid_to_q_obj(bp, cid);\r\nif (q_obj->complete_cmd(bp, q_obj, BNX2X_Q_CMD_CFC_DEL))\r\nbreak;\r\ngoto next_spqe;\r\ncase EVENT_RING_OPCODE_STOP_TRAFFIC:\r\nDP(BNX2X_MSG_SP | BNX2X_MSG_DCB, "got STOP TRAFFIC\n");\r\nbnx2x_dcbx_set_params(bp, BNX2X_DCBX_STATE_TX_PAUSED);\r\nif (f_obj->complete_cmd(bp, f_obj,\r\nBNX2X_F_CMD_TX_STOP))\r\nbreak;\r\ngoto next_spqe;\r\ncase EVENT_RING_OPCODE_START_TRAFFIC:\r\nDP(BNX2X_MSG_SP | BNX2X_MSG_DCB, "got START TRAFFIC\n");\r\nbnx2x_dcbx_set_params(bp, BNX2X_DCBX_STATE_TX_RELEASED);\r\nif (f_obj->complete_cmd(bp, f_obj,\r\nBNX2X_F_CMD_TX_START))\r\nbreak;\r\ngoto next_spqe;\r\ncase EVENT_RING_OPCODE_FUNCTION_UPDATE:\r\necho = elem->message.data.function_update_event.echo;\r\nif (echo == SWITCH_UPDATE) {\r\nDP(BNX2X_MSG_SP | NETIF_MSG_IFUP,\r\n"got FUNC_SWITCH_UPDATE ramrod\n");\r\nif (f_obj->complete_cmd(\r\nbp, f_obj, BNX2X_F_CMD_SWITCH_UPDATE))\r\nbreak;\r\n} else {\r\nint cmd = BNX2X_SP_RTNL_AFEX_F_UPDATE;\r\nDP(BNX2X_MSG_SP | BNX2X_MSG_MCP,\r\n"AFEX: ramrod completed FUNCTION_UPDATE\n");\r\nf_obj->complete_cmd(bp, f_obj,\r\nBNX2X_F_CMD_AFEX_UPDATE);\r\nbnx2x_schedule_sp_rtnl(bp, cmd, 0);\r\n}\r\ngoto next_spqe;\r\ncase EVENT_RING_OPCODE_AFEX_VIF_LISTS:\r\nf_obj->complete_cmd(bp, f_obj,\r\nBNX2X_F_CMD_AFEX_VIFLISTS);\r\nbnx2x_after_afex_vif_lists(bp, elem);\r\ngoto next_spqe;\r\ncase EVENT_RING_OPCODE_FUNCTION_START:\r\nDP(BNX2X_MSG_SP | NETIF_MSG_IFUP,\r\n"got FUNC_START ramrod\n");\r\nif (f_obj->complete_cmd(bp, f_obj, BNX2X_F_CMD_START))\r\nbreak;\r\ngoto next_spqe;\r\ncase EVENT_RING_OPCODE_FUNCTION_STOP:\r\nDP(BNX2X_MSG_SP | NETIF_MSG_IFUP,\r\n"got FUNC_STOP ramrod\n");\r\nif (f_obj->complete_cmd(bp, f_obj, BNX2X_F_CMD_STOP))\r\nbreak;\r\ngoto next_spqe;\r\ncase EVENT_RING_OPCODE_SET_TIMESYNC:\r\nDP(BNX2X_MSG_SP | BNX2X_MSG_PTP,\r\n"got set_timesync ramrod completion\n");\r\nif (f_obj->complete_cmd(bp, f_obj,\r\nBNX2X_F_CMD_SET_TIMESYNC))\r\nbreak;\r\ngoto next_spqe;\r\n}\r\nswitch (opcode | bp->state) {\r\ncase (EVENT_RING_OPCODE_RSS_UPDATE_RULES |\r\nBNX2X_STATE_OPEN):\r\ncase (EVENT_RING_OPCODE_RSS_UPDATE_RULES |\r\nBNX2X_STATE_OPENING_WAIT4_PORT):\r\ncase (EVENT_RING_OPCODE_RSS_UPDATE_RULES |\r\nBNX2X_STATE_CLOSING_WAIT4_HALT):\r\nDP(BNX2X_MSG_SP, "got RSS_UPDATE ramrod. CID %d\n",\r\nSW_CID(elem->message.data.eth_event.echo));\r\nrss_raw->clear_pending(rss_raw);\r\nbreak;\r\ncase (EVENT_RING_OPCODE_SET_MAC | BNX2X_STATE_OPEN):\r\ncase (EVENT_RING_OPCODE_SET_MAC | BNX2X_STATE_DIAG):\r\ncase (EVENT_RING_OPCODE_SET_MAC |\r\nBNX2X_STATE_CLOSING_WAIT4_HALT):\r\ncase (EVENT_RING_OPCODE_CLASSIFICATION_RULES |\r\nBNX2X_STATE_OPEN):\r\ncase (EVENT_RING_OPCODE_CLASSIFICATION_RULES |\r\nBNX2X_STATE_DIAG):\r\ncase (EVENT_RING_OPCODE_CLASSIFICATION_RULES |\r\nBNX2X_STATE_CLOSING_WAIT4_HALT):\r\nDP(BNX2X_MSG_SP, "got (un)set vlan/mac ramrod\n");\r\nbnx2x_handle_classification_eqe(bp, elem);\r\nbreak;\r\ncase (EVENT_RING_OPCODE_MULTICAST_RULES |\r\nBNX2X_STATE_OPEN):\r\ncase (EVENT_RING_OPCODE_MULTICAST_RULES |\r\nBNX2X_STATE_DIAG):\r\ncase (EVENT_RING_OPCODE_MULTICAST_RULES |\r\nBNX2X_STATE_CLOSING_WAIT4_HALT):\r\nDP(BNX2X_MSG_SP, "got mcast ramrod\n");\r\nbnx2x_handle_mcast_eqe(bp);\r\nbreak;\r\ncase (EVENT_RING_OPCODE_FILTERS_RULES |\r\nBNX2X_STATE_OPEN):\r\ncase (EVENT_RING_OPCODE_FILTERS_RULES |\r\nBNX2X_STATE_DIAG):\r\ncase (EVENT_RING_OPCODE_FILTERS_RULES |\r\nBNX2X_STATE_CLOSING_WAIT4_HALT):\r\nDP(BNX2X_MSG_SP, "got rx_mode ramrod\n");\r\nbnx2x_handle_rx_mode_eqe(bp);\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Unknown EQ event %d, bp->state 0x%x\n",\r\nelem->message.opcode, bp->state);\r\n}\r\nnext_spqe:\r\nspqe_cnt++;\r\n}\r\nsmp_mb__before_atomic();\r\natomic_add(spqe_cnt, &bp->eq_spq_left);\r\nbp->eq_cons = sw_cons;\r\nbp->eq_prod = sw_prod;\r\nsmp_wmb();\r\nbnx2x_update_eq_prod(bp, bp->eq_prod);\r\n}\r\nstatic void bnx2x_sp_task(struct work_struct *work)\r\n{\r\nstruct bnx2x *bp = container_of(work, struct bnx2x, sp_task.work);\r\nDP(BNX2X_MSG_SP, "sp task invoked\n");\r\nsmp_rmb();\r\nif (atomic_read(&bp->interrupt_occurred)) {\r\nu16 status = bnx2x_update_dsb_idx(bp);\r\nDP(BNX2X_MSG_SP, "status %x\n", status);\r\nDP(BNX2X_MSG_SP, "setting interrupt_occurred to 0\n");\r\natomic_set(&bp->interrupt_occurred, 0);\r\nif (status & BNX2X_DEF_SB_ATT_IDX) {\r\nbnx2x_attn_int(bp);\r\nstatus &= ~BNX2X_DEF_SB_ATT_IDX;\r\n}\r\nif (status & BNX2X_DEF_SB_IDX) {\r\nstruct bnx2x_fastpath *fp = bnx2x_fcoe_fp(bp);\r\nif (FCOE_INIT(bp) &&\r\n(bnx2x_has_rx_work(fp) || bnx2x_has_tx_work(fp))) {\r\nlocal_bh_disable();\r\nnapi_schedule(&bnx2x_fcoe(bp, napi));\r\nlocal_bh_enable();\r\n}\r\nbnx2x_eq_int(bp);\r\nbnx2x_ack_sb(bp, bp->igu_dsb_id, USTORM_ID,\r\nle16_to_cpu(bp->def_idx), IGU_INT_NOP, 1);\r\nstatus &= ~BNX2X_DEF_SB_IDX;\r\n}\r\nif (unlikely(status))\r\nDP(BNX2X_MSG_SP,\r\n"got an unknown interrupt! (status 0x%x)\n", status);\r\nbnx2x_ack_sb(bp, bp->igu_dsb_id, ATTENTION_ID,\r\nle16_to_cpu(bp->def_att_idx), IGU_INT_ENABLE, 1);\r\n}\r\nif (test_and_clear_bit(BNX2X_AFEX_PENDING_VIFSET_MCP_ACK,\r\n&bp->sp_state)) {\r\nbnx2x_link_report(bp);\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_VIFSET_ACK, 0);\r\n}\r\n}\r\nirqreturn_t bnx2x_msix_sp_int(int irq, void *dev_instance)\r\n{\r\nstruct net_device *dev = dev_instance;\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nbnx2x_ack_sb(bp, bp->igu_dsb_id, USTORM_ID, 0,\r\nIGU_INT_DISABLE, 0);\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nif (unlikely(bp->panic))\r\nreturn IRQ_HANDLED;\r\n#endif\r\nif (CNIC_LOADED(bp)) {\r\nstruct cnic_ops *c_ops;\r\nrcu_read_lock();\r\nc_ops = rcu_dereference(bp->cnic_ops);\r\nif (c_ops)\r\nc_ops->cnic_handler(bp->cnic_data, NULL);\r\nrcu_read_unlock();\r\n}\r\nbnx2x_schedule_sp_task(bp);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid bnx2x_drv_pulse(struct bnx2x *bp)\r\n{\r\nSHMEM_WR(bp, func_mb[BP_FW_MB_IDX(bp)].drv_pulse_mb,\r\nbp->fw_drv_pulse_wr_seq);\r\n}\r\nstatic void bnx2x_timer(unsigned long data)\r\n{\r\nstruct bnx2x *bp = (struct bnx2x *) data;\r\nif (!netif_running(bp->dev))\r\nreturn;\r\nif (IS_PF(bp) &&\r\n!BP_NOMCP(bp)) {\r\nint mb_idx = BP_FW_MB_IDX(bp);\r\nu16 drv_pulse;\r\nu16 mcp_pulse;\r\n++bp->fw_drv_pulse_wr_seq;\r\nbp->fw_drv_pulse_wr_seq &= DRV_PULSE_SEQ_MASK;\r\ndrv_pulse = bp->fw_drv_pulse_wr_seq;\r\nbnx2x_drv_pulse(bp);\r\nmcp_pulse = (SHMEM_RD(bp, func_mb[mb_idx].mcp_pulse_mb) &\r\nMCP_PULSE_SEQ_MASK);\r\nif (((drv_pulse - mcp_pulse) & MCP_PULSE_SEQ_MASK) > 5)\r\nBNX2X_ERR("MFW seems hanged: drv_pulse (0x%x) != mcp_pulse (0x%x)\n",\r\ndrv_pulse, mcp_pulse);\r\n}\r\nif (bp->state == BNX2X_STATE_OPEN)\r\nbnx2x_stats_handle(bp, STATS_EVENT_UPDATE);\r\nif (IS_VF(bp))\r\nbnx2x_timer_sriov(bp);\r\nmod_timer(&bp->timer, jiffies + bp->current_interval);\r\n}\r\nstatic void bnx2x_fill(struct bnx2x *bp, u32 addr, int fill, u32 len)\r\n{\r\nu32 i;\r\nif (!(len%4) && !(addr%4))\r\nfor (i = 0; i < len; i += 4)\r\nREG_WR(bp, addr + i, fill);\r\nelse\r\nfor (i = 0; i < len; i++)\r\nREG_WR8(bp, addr + i, fill);\r\n}\r\nstatic void bnx2x_wr_fp_sb_data(struct bnx2x *bp,\r\nint fw_sb_id,\r\nu32 *sb_data_p,\r\nu32 data_size)\r\n{\r\nint index;\r\nfor (index = 0; index < data_size; index++)\r\nREG_WR(bp, BAR_CSTRORM_INTMEM +\r\nCSTORM_STATUS_BLOCK_DATA_OFFSET(fw_sb_id) +\r\nsizeof(u32)*index,\r\n*(sb_data_p + index));\r\n}\r\nstatic void bnx2x_zero_fp_sb(struct bnx2x *bp, int fw_sb_id)\r\n{\r\nu32 *sb_data_p;\r\nu32 data_size = 0;\r\nstruct hc_status_block_data_e2 sb_data_e2;\r\nstruct hc_status_block_data_e1x sb_data_e1x;\r\nif (!CHIP_IS_E1x(bp)) {\r\nmemset(&sb_data_e2, 0, sizeof(struct hc_status_block_data_e2));\r\nsb_data_e2.common.state = SB_DISABLED;\r\nsb_data_e2.common.p_func.vf_valid = false;\r\nsb_data_p = (u32 *)&sb_data_e2;\r\ndata_size = sizeof(struct hc_status_block_data_e2)/sizeof(u32);\r\n} else {\r\nmemset(&sb_data_e1x, 0,\r\nsizeof(struct hc_status_block_data_e1x));\r\nsb_data_e1x.common.state = SB_DISABLED;\r\nsb_data_e1x.common.p_func.vf_valid = false;\r\nsb_data_p = (u32 *)&sb_data_e1x;\r\ndata_size = sizeof(struct hc_status_block_data_e1x)/sizeof(u32);\r\n}\r\nbnx2x_wr_fp_sb_data(bp, fw_sb_id, sb_data_p, data_size);\r\nbnx2x_fill(bp, BAR_CSTRORM_INTMEM +\r\nCSTORM_STATUS_BLOCK_OFFSET(fw_sb_id), 0,\r\nCSTORM_STATUS_BLOCK_SIZE);\r\nbnx2x_fill(bp, BAR_CSTRORM_INTMEM +\r\nCSTORM_SYNC_BLOCK_OFFSET(fw_sb_id), 0,\r\nCSTORM_SYNC_BLOCK_SIZE);\r\n}\r\nstatic void bnx2x_wr_sp_sb_data(struct bnx2x *bp,\r\nstruct hc_sp_status_block_data *sp_sb_data)\r\n{\r\nint func = BP_FUNC(bp);\r\nint i;\r\nfor (i = 0; i < sizeof(struct hc_sp_status_block_data)/sizeof(u32); i++)\r\nREG_WR(bp, BAR_CSTRORM_INTMEM +\r\nCSTORM_SP_STATUS_BLOCK_DATA_OFFSET(func) +\r\ni*sizeof(u32),\r\n*((u32 *)sp_sb_data + i));\r\n}\r\nstatic void bnx2x_zero_sp_sb(struct bnx2x *bp)\r\n{\r\nint func = BP_FUNC(bp);\r\nstruct hc_sp_status_block_data sp_sb_data;\r\nmemset(&sp_sb_data, 0, sizeof(struct hc_sp_status_block_data));\r\nsp_sb_data.state = SB_DISABLED;\r\nsp_sb_data.p_func.vf_valid = false;\r\nbnx2x_wr_sp_sb_data(bp, &sp_sb_data);\r\nbnx2x_fill(bp, BAR_CSTRORM_INTMEM +\r\nCSTORM_SP_STATUS_BLOCK_OFFSET(func), 0,\r\nCSTORM_SP_STATUS_BLOCK_SIZE);\r\nbnx2x_fill(bp, BAR_CSTRORM_INTMEM +\r\nCSTORM_SP_SYNC_BLOCK_OFFSET(func), 0,\r\nCSTORM_SP_SYNC_BLOCK_SIZE);\r\n}\r\nstatic void bnx2x_setup_ndsb_state_machine(struct hc_status_block_sm *hc_sm,\r\nint igu_sb_id, int igu_seg_id)\r\n{\r\nhc_sm->igu_sb_id = igu_sb_id;\r\nhc_sm->igu_seg_id = igu_seg_id;\r\nhc_sm->timer_value = 0xFF;\r\nhc_sm->time_to_expire = 0xFFFFFFFF;\r\n}\r\nstatic void bnx2x_map_sb_state_machines(struct hc_index_data *index_data)\r\n{\r\nindex_data[HC_INDEX_ETH_RX_CQ_CONS].flags &= ~HC_INDEX_DATA_SM_ID;\r\nindex_data[HC_INDEX_OOO_TX_CQ_CONS].flags &= ~HC_INDEX_DATA_SM_ID;\r\nindex_data[HC_INDEX_ETH_TX_CQ_CONS_COS0].flags &= ~HC_INDEX_DATA_SM_ID;\r\nindex_data[HC_INDEX_ETH_TX_CQ_CONS_COS1].flags &= ~HC_INDEX_DATA_SM_ID;\r\nindex_data[HC_INDEX_ETH_TX_CQ_CONS_COS2].flags &= ~HC_INDEX_DATA_SM_ID;\r\nindex_data[HC_INDEX_ETH_RX_CQ_CONS].flags |=\r\nSM_RX_ID << HC_INDEX_DATA_SM_ID_SHIFT;\r\nindex_data[HC_INDEX_OOO_TX_CQ_CONS].flags |=\r\nSM_TX_ID << HC_INDEX_DATA_SM_ID_SHIFT;\r\nindex_data[HC_INDEX_ETH_TX_CQ_CONS_COS0].flags |=\r\nSM_TX_ID << HC_INDEX_DATA_SM_ID_SHIFT;\r\nindex_data[HC_INDEX_ETH_TX_CQ_CONS_COS1].flags |=\r\nSM_TX_ID << HC_INDEX_DATA_SM_ID_SHIFT;\r\nindex_data[HC_INDEX_ETH_TX_CQ_CONS_COS2].flags |=\r\nSM_TX_ID << HC_INDEX_DATA_SM_ID_SHIFT;\r\n}\r\nvoid bnx2x_init_sb(struct bnx2x *bp, dma_addr_t mapping, int vfid,\r\nu8 vf_valid, int fw_sb_id, int igu_sb_id)\r\n{\r\nint igu_seg_id;\r\nstruct hc_status_block_data_e2 sb_data_e2;\r\nstruct hc_status_block_data_e1x sb_data_e1x;\r\nstruct hc_status_block_sm *hc_sm_p;\r\nint data_size;\r\nu32 *sb_data_p;\r\nif (CHIP_INT_MODE_IS_BC(bp))\r\nigu_seg_id = HC_SEG_ACCESS_NORM;\r\nelse\r\nigu_seg_id = IGU_SEG_ACCESS_NORM;\r\nbnx2x_zero_fp_sb(bp, fw_sb_id);\r\nif (!CHIP_IS_E1x(bp)) {\r\nmemset(&sb_data_e2, 0, sizeof(struct hc_status_block_data_e2));\r\nsb_data_e2.common.state = SB_ENABLED;\r\nsb_data_e2.common.p_func.pf_id = BP_FUNC(bp);\r\nsb_data_e2.common.p_func.vf_id = vfid;\r\nsb_data_e2.common.p_func.vf_valid = vf_valid;\r\nsb_data_e2.common.p_func.vnic_id = BP_VN(bp);\r\nsb_data_e2.common.same_igu_sb_1b = true;\r\nsb_data_e2.common.host_sb_addr.hi = U64_HI(mapping);\r\nsb_data_e2.common.host_sb_addr.lo = U64_LO(mapping);\r\nhc_sm_p = sb_data_e2.common.state_machine;\r\nsb_data_p = (u32 *)&sb_data_e2;\r\ndata_size = sizeof(struct hc_status_block_data_e2)/sizeof(u32);\r\nbnx2x_map_sb_state_machines(sb_data_e2.index_data);\r\n} else {\r\nmemset(&sb_data_e1x, 0,\r\nsizeof(struct hc_status_block_data_e1x));\r\nsb_data_e1x.common.state = SB_ENABLED;\r\nsb_data_e1x.common.p_func.pf_id = BP_FUNC(bp);\r\nsb_data_e1x.common.p_func.vf_id = 0xff;\r\nsb_data_e1x.common.p_func.vf_valid = false;\r\nsb_data_e1x.common.p_func.vnic_id = BP_VN(bp);\r\nsb_data_e1x.common.same_igu_sb_1b = true;\r\nsb_data_e1x.common.host_sb_addr.hi = U64_HI(mapping);\r\nsb_data_e1x.common.host_sb_addr.lo = U64_LO(mapping);\r\nhc_sm_p = sb_data_e1x.common.state_machine;\r\nsb_data_p = (u32 *)&sb_data_e1x;\r\ndata_size = sizeof(struct hc_status_block_data_e1x)/sizeof(u32);\r\nbnx2x_map_sb_state_machines(sb_data_e1x.index_data);\r\n}\r\nbnx2x_setup_ndsb_state_machine(&hc_sm_p[SM_RX_ID],\r\nigu_sb_id, igu_seg_id);\r\nbnx2x_setup_ndsb_state_machine(&hc_sm_p[SM_TX_ID],\r\nigu_sb_id, igu_seg_id);\r\nDP(NETIF_MSG_IFUP, "Init FW SB %d\n", fw_sb_id);\r\nbnx2x_wr_fp_sb_data(bp, fw_sb_id, sb_data_p, data_size);\r\n}\r\nstatic void bnx2x_update_coalesce_sb(struct bnx2x *bp, u8 fw_sb_id,\r\nu16 tx_usec, u16 rx_usec)\r\n{\r\nbnx2x_update_coalesce_sb_index(bp, fw_sb_id, HC_INDEX_ETH_RX_CQ_CONS,\r\nfalse, rx_usec);\r\nbnx2x_update_coalesce_sb_index(bp, fw_sb_id,\r\nHC_INDEX_ETH_TX_CQ_CONS_COS0, false,\r\ntx_usec);\r\nbnx2x_update_coalesce_sb_index(bp, fw_sb_id,\r\nHC_INDEX_ETH_TX_CQ_CONS_COS1, false,\r\ntx_usec);\r\nbnx2x_update_coalesce_sb_index(bp, fw_sb_id,\r\nHC_INDEX_ETH_TX_CQ_CONS_COS2, false,\r\ntx_usec);\r\n}\r\nstatic void bnx2x_init_def_sb(struct bnx2x *bp)\r\n{\r\nstruct host_sp_status_block *def_sb = bp->def_status_blk;\r\ndma_addr_t mapping = bp->def_status_blk_mapping;\r\nint igu_sp_sb_index;\r\nint igu_seg_id;\r\nint port = BP_PORT(bp);\r\nint func = BP_FUNC(bp);\r\nint reg_offset, reg_offset_en5;\r\nu64 section;\r\nint index;\r\nstruct hc_sp_status_block_data sp_sb_data;\r\nmemset(&sp_sb_data, 0, sizeof(struct hc_sp_status_block_data));\r\nif (CHIP_INT_MODE_IS_BC(bp)) {\r\nigu_sp_sb_index = DEF_SB_IGU_ID;\r\nigu_seg_id = HC_SEG_ACCESS_DEF;\r\n} else {\r\nigu_sp_sb_index = bp->igu_dsb_id;\r\nigu_seg_id = IGU_SEG_ACCESS_DEF;\r\n}\r\nsection = ((u64)mapping) + offsetof(struct host_sp_status_block,\r\natten_status_block);\r\ndef_sb->atten_status_block.status_block_id = igu_sp_sb_index;\r\nbp->attn_state = 0;\r\nreg_offset = (port ? MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0 :\r\nMISC_REG_AEU_ENABLE1_FUNC_0_OUT_0);\r\nreg_offset_en5 = (port ? MISC_REG_AEU_ENABLE5_FUNC_1_OUT_0 :\r\nMISC_REG_AEU_ENABLE5_FUNC_0_OUT_0);\r\nfor (index = 0; index < MAX_DYNAMIC_ATTN_GRPS; index++) {\r\nint sindex;\r\nfor (sindex = 0; sindex < 4; sindex++)\r\nbp->attn_group[index].sig[sindex] =\r\nREG_RD(bp, reg_offset + sindex*0x4 + 0x10*index);\r\nif (!CHIP_IS_E1x(bp))\r\nbp->attn_group[index].sig[4] = REG_RD(bp,\r\nreg_offset_en5 + 0x4*index);\r\nelse\r\nbp->attn_group[index].sig[4] = 0;\r\n}\r\nif (bp->common.int_block == INT_BLOCK_HC) {\r\nreg_offset = (port ? HC_REG_ATTN_MSG1_ADDR_L :\r\nHC_REG_ATTN_MSG0_ADDR_L);\r\nREG_WR(bp, reg_offset, U64_LO(section));\r\nREG_WR(bp, reg_offset + 4, U64_HI(section));\r\n} else if (!CHIP_IS_E1x(bp)) {\r\nREG_WR(bp, IGU_REG_ATTN_MSG_ADDR_L, U64_LO(section));\r\nREG_WR(bp, IGU_REG_ATTN_MSG_ADDR_H, U64_HI(section));\r\n}\r\nsection = ((u64)mapping) + offsetof(struct host_sp_status_block,\r\nsp_sb);\r\nbnx2x_zero_sp_sb(bp);\r\nsp_sb_data.state = SB_ENABLED;\r\nsp_sb_data.host_sb_addr.lo = U64_LO(section);\r\nsp_sb_data.host_sb_addr.hi = U64_HI(section);\r\nsp_sb_data.igu_sb_id = igu_sp_sb_index;\r\nsp_sb_data.igu_seg_id = igu_seg_id;\r\nsp_sb_data.p_func.pf_id = func;\r\nsp_sb_data.p_func.vnic_id = BP_VN(bp);\r\nsp_sb_data.p_func.vf_id = 0xff;\r\nbnx2x_wr_sp_sb_data(bp, &sp_sb_data);\r\nbnx2x_ack_sb(bp, bp->igu_dsb_id, USTORM_ID, 0, IGU_INT_ENABLE, 0);\r\n}\r\nvoid bnx2x_update_coalesce(struct bnx2x *bp)\r\n{\r\nint i;\r\nfor_each_eth_queue(bp, i)\r\nbnx2x_update_coalesce_sb(bp, bp->fp[i].fw_sb_id,\r\nbp->tx_ticks, bp->rx_ticks);\r\n}\r\nstatic void bnx2x_init_sp_ring(struct bnx2x *bp)\r\n{\r\nspin_lock_init(&bp->spq_lock);\r\natomic_set(&bp->cq_spq_left, MAX_SPQ_PENDING);\r\nbp->spq_prod_idx = 0;\r\nbp->dsb_sp_prod = BNX2X_SP_DSB_INDEX;\r\nbp->spq_prod_bd = bp->spq;\r\nbp->spq_last_bd = bp->spq_prod_bd + MAX_SP_DESC_CNT;\r\n}\r\nstatic void bnx2x_init_eq_ring(struct bnx2x *bp)\r\n{\r\nint i;\r\nfor (i = 1; i <= NUM_EQ_PAGES; i++) {\r\nunion event_ring_elem *elem =\r\n&bp->eq_ring[EQ_DESC_CNT_PAGE * i - 1];\r\nelem->next_page.addr.hi =\r\ncpu_to_le32(U64_HI(bp->eq_mapping +\r\nBCM_PAGE_SIZE * (i % NUM_EQ_PAGES)));\r\nelem->next_page.addr.lo =\r\ncpu_to_le32(U64_LO(bp->eq_mapping +\r\nBCM_PAGE_SIZE*(i % NUM_EQ_PAGES)));\r\n}\r\nbp->eq_cons = 0;\r\nbp->eq_prod = NUM_EQ_DESC;\r\nbp->eq_cons_sb = BNX2X_EQ_INDEX;\r\natomic_set(&bp->eq_spq_left,\r\nmin_t(int, MAX_SP_DESC_CNT - MAX_SPQ_PENDING, NUM_EQ_DESC) - 1);\r\n}\r\nstatic int bnx2x_set_q_rx_mode(struct bnx2x *bp, u8 cl_id,\r\nunsigned long rx_mode_flags,\r\nunsigned long rx_accept_flags,\r\nunsigned long tx_accept_flags,\r\nunsigned long ramrod_flags)\r\n{\r\nstruct bnx2x_rx_mode_ramrod_params ramrod_param;\r\nint rc;\r\nmemset(&ramrod_param, 0, sizeof(ramrod_param));\r\nramrod_param.cid = 0;\r\nramrod_param.cl_id = cl_id;\r\nramrod_param.rx_mode_obj = &bp->rx_mode_obj;\r\nramrod_param.func_id = BP_FUNC(bp);\r\nramrod_param.pstate = &bp->sp_state;\r\nramrod_param.state = BNX2X_FILTER_RX_MODE_PENDING;\r\nramrod_param.rdata = bnx2x_sp(bp, rx_mode_rdata);\r\nramrod_param.rdata_mapping = bnx2x_sp_mapping(bp, rx_mode_rdata);\r\nset_bit(BNX2X_FILTER_RX_MODE_PENDING, &bp->sp_state);\r\nramrod_param.ramrod_flags = ramrod_flags;\r\nramrod_param.rx_mode_flags = rx_mode_flags;\r\nramrod_param.rx_accept_flags = rx_accept_flags;\r\nramrod_param.tx_accept_flags = tx_accept_flags;\r\nrc = bnx2x_config_rx_mode(bp, &ramrod_param);\r\nif (rc < 0) {\r\nBNX2X_ERR("Set rx_mode %d failed\n", bp->rx_mode);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_fill_accept_flags(struct bnx2x *bp, u32 rx_mode,\r\nunsigned long *rx_accept_flags,\r\nunsigned long *tx_accept_flags)\r\n{\r\n*rx_accept_flags = 0;\r\n*tx_accept_flags = 0;\r\nswitch (rx_mode) {\r\ncase BNX2X_RX_MODE_NONE:\r\nbreak;\r\ncase BNX2X_RX_MODE_NORMAL:\r\n__set_bit(BNX2X_ACCEPT_UNICAST, rx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_MULTICAST, rx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_BROADCAST, rx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_UNICAST, tx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_MULTICAST, tx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_BROADCAST, tx_accept_flags);\r\nif (bp->accept_any_vlan) {\r\n__set_bit(BNX2X_ACCEPT_ANY_VLAN, rx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_ANY_VLAN, tx_accept_flags);\r\n}\r\nbreak;\r\ncase BNX2X_RX_MODE_ALLMULTI:\r\n__set_bit(BNX2X_ACCEPT_UNICAST, rx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_ALL_MULTICAST, rx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_BROADCAST, rx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_UNICAST, tx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_ALL_MULTICAST, tx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_BROADCAST, tx_accept_flags);\r\nif (bp->accept_any_vlan) {\r\n__set_bit(BNX2X_ACCEPT_ANY_VLAN, rx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_ANY_VLAN, tx_accept_flags);\r\n}\r\nbreak;\r\ncase BNX2X_RX_MODE_PROMISC:\r\n__set_bit(BNX2X_ACCEPT_UNMATCHED, rx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_UNICAST, rx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_ALL_MULTICAST, rx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_BROADCAST, rx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_ALL_MULTICAST, tx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_BROADCAST, tx_accept_flags);\r\nif (IS_MF_SI(bp))\r\n__set_bit(BNX2X_ACCEPT_ALL_UNICAST, tx_accept_flags);\r\nelse\r\n__set_bit(BNX2X_ACCEPT_UNICAST, tx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_ANY_VLAN, rx_accept_flags);\r\n__set_bit(BNX2X_ACCEPT_ANY_VLAN, tx_accept_flags);\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Unknown rx_mode: %d\n", rx_mode);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_set_storm_rx_mode(struct bnx2x *bp)\r\n{\r\nunsigned long rx_mode_flags = 0, ramrod_flags = 0;\r\nunsigned long rx_accept_flags = 0, tx_accept_flags = 0;\r\nint rc;\r\nif (!NO_FCOE(bp))\r\n__set_bit(BNX2X_RX_MODE_FCOE_ETH, &rx_mode_flags);\r\nrc = bnx2x_fill_accept_flags(bp, bp->rx_mode, &rx_accept_flags,\r\n&tx_accept_flags);\r\nif (rc)\r\nreturn rc;\r\n__set_bit(RAMROD_RX, &ramrod_flags);\r\n__set_bit(RAMROD_TX, &ramrod_flags);\r\nreturn bnx2x_set_q_rx_mode(bp, bp->fp->cl_id, rx_mode_flags,\r\nrx_accept_flags, tx_accept_flags,\r\nramrod_flags);\r\n}\r\nstatic void bnx2x_init_internal_common(struct bnx2x *bp)\r\n{\r\nint i;\r\nfor (i = 0; i < (USTORM_AGG_DATA_SIZE >> 2); i++)\r\nREG_WR(bp, BAR_USTRORM_INTMEM +\r\nUSTORM_AGG_DATA_OFFSET + i * 4, 0);\r\nif (!CHIP_IS_E1x(bp)) {\r\nREG_WR8(bp, BAR_CSTRORM_INTMEM + CSTORM_IGU_MODE_OFFSET,\r\nCHIP_INT_MODE_IS_BC(bp) ?\r\nHC_IGU_BC_MODE : HC_IGU_NBC_MODE);\r\n}\r\n}\r\nstatic void bnx2x_init_internal(struct bnx2x *bp, u32 load_code)\r\n{\r\nswitch (load_code) {\r\ncase FW_MSG_CODE_DRV_LOAD_COMMON:\r\ncase FW_MSG_CODE_DRV_LOAD_COMMON_CHIP:\r\nbnx2x_init_internal_common(bp);\r\ncase FW_MSG_CODE_DRV_LOAD_PORT:\r\ncase FW_MSG_CODE_DRV_LOAD_FUNCTION:\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Unknown load_code (0x%x) from MCP\n", load_code);\r\nbreak;\r\n}\r\n}\r\nstatic inline u8 bnx2x_fp_igu_sb_id(struct bnx2x_fastpath *fp)\r\n{\r\nreturn fp->bp->igu_base_sb + fp->index + CNIC_SUPPORT(fp->bp);\r\n}\r\nstatic inline u8 bnx2x_fp_fw_sb_id(struct bnx2x_fastpath *fp)\r\n{\r\nreturn fp->bp->base_fw_ndsb + fp->index + CNIC_SUPPORT(fp->bp);\r\n}\r\nstatic u8 bnx2x_fp_cl_id(struct bnx2x_fastpath *fp)\r\n{\r\nif (CHIP_IS_E1x(fp->bp))\r\nreturn BP_L_ID(fp->bp) + fp->index;\r\nelse\r\nreturn bnx2x_fp_igu_sb_id(fp);\r\n}\r\nstatic void bnx2x_init_eth_fp(struct bnx2x *bp, int fp_idx)\r\n{\r\nstruct bnx2x_fastpath *fp = &bp->fp[fp_idx];\r\nu8 cos;\r\nunsigned long q_type = 0;\r\nu32 cids[BNX2X_MULTI_TX_COS] = { 0 };\r\nfp->rx_queue = fp_idx;\r\nfp->cid = fp_idx;\r\nfp->cl_id = bnx2x_fp_cl_id(fp);\r\nfp->fw_sb_id = bnx2x_fp_fw_sb_id(fp);\r\nfp->igu_sb_id = bnx2x_fp_igu_sb_id(fp);\r\nfp->cl_qzone_id = bnx2x_fp_qzone_id(fp);\r\nfp->ustorm_rx_prods_offset = bnx2x_rx_ustorm_prods_offset(fp);\r\nfp->rx_cons_sb = BNX2X_RX_SB_INDEX;\r\n__set_bit(BNX2X_Q_TYPE_HAS_RX, &q_type);\r\n__set_bit(BNX2X_Q_TYPE_HAS_TX, &q_type);\r\nBUG_ON(fp->max_cos > BNX2X_MULTI_TX_COS);\r\nfor_each_cos_in_tx_queue(fp, cos) {\r\nbnx2x_init_txdata(bp, fp->txdata_ptr[cos],\r\nCID_COS_TO_TX_ONLY_CID(fp->cid, cos, bp),\r\nFP_COS_TO_TXQ(fp, cos, bp),\r\nBNX2X_TX_SB_INDEX_BASE + cos, fp);\r\ncids[cos] = fp->txdata_ptr[cos]->cid;\r\n}\r\nif (IS_VF(bp))\r\nreturn;\r\nbnx2x_init_sb(bp, fp->status_blk_mapping, BNX2X_VF_ID_INVALID, false,\r\nfp->fw_sb_id, fp->igu_sb_id);\r\nbnx2x_update_fpsb_idx(fp);\r\nbnx2x_init_queue_obj(bp, &bnx2x_sp_obj(bp, fp).q_obj, fp->cl_id, cids,\r\nfp->max_cos, BP_FUNC(bp), bnx2x_sp(bp, q_rdata),\r\nbnx2x_sp_mapping(bp, q_rdata), q_type);\r\nbnx2x_init_vlan_mac_fp_objs(fp, BNX2X_OBJ_TYPE_RX_TX);\r\nDP(NETIF_MSG_IFUP,\r\n"queue[%d]: bnx2x_init_sb(%p,%p) cl_id %d fw_sb %d igu_sb %d\n",\r\nfp_idx, bp, fp->status_blk.e2_sb, fp->cl_id, fp->fw_sb_id,\r\nfp->igu_sb_id);\r\n}\r\nstatic void bnx2x_init_tx_ring_one(struct bnx2x_fp_txdata *txdata)\r\n{\r\nint i;\r\nfor (i = 1; i <= NUM_TX_RINGS; i++) {\r\nstruct eth_tx_next_bd *tx_next_bd =\r\n&txdata->tx_desc_ring[TX_DESC_CNT * i - 1].next_bd;\r\ntx_next_bd->addr_hi =\r\ncpu_to_le32(U64_HI(txdata->tx_desc_mapping +\r\nBCM_PAGE_SIZE*(i % NUM_TX_RINGS)));\r\ntx_next_bd->addr_lo =\r\ncpu_to_le32(U64_LO(txdata->tx_desc_mapping +\r\nBCM_PAGE_SIZE*(i % NUM_TX_RINGS)));\r\n}\r\n*txdata->tx_cons_sb = cpu_to_le16(0);\r\nSET_FLAG(txdata->tx_db.data.header.header, DOORBELL_HDR_DB_TYPE, 1);\r\ntxdata->tx_db.data.zero_fill1 = 0;\r\ntxdata->tx_db.data.prod = 0;\r\ntxdata->tx_pkt_prod = 0;\r\ntxdata->tx_pkt_cons = 0;\r\ntxdata->tx_bd_prod = 0;\r\ntxdata->tx_bd_cons = 0;\r\ntxdata->tx_pkt = 0;\r\n}\r\nstatic void bnx2x_init_tx_rings_cnic(struct bnx2x *bp)\r\n{\r\nint i;\r\nfor_each_tx_queue_cnic(bp, i)\r\nbnx2x_init_tx_ring_one(bp->fp[i].txdata_ptr[0]);\r\n}\r\nstatic void bnx2x_init_tx_rings(struct bnx2x *bp)\r\n{\r\nint i;\r\nu8 cos;\r\nfor_each_eth_queue(bp, i)\r\nfor_each_cos_in_tx_queue(&bp->fp[i], cos)\r\nbnx2x_init_tx_ring_one(bp->fp[i].txdata_ptr[cos]);\r\n}\r\nstatic void bnx2x_init_fcoe_fp(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_fastpath *fp = bnx2x_fcoe_fp(bp);\r\nunsigned long q_type = 0;\r\nbnx2x_fcoe(bp, rx_queue) = BNX2X_NUM_ETH_QUEUES(bp);\r\nbnx2x_fcoe(bp, cl_id) = bnx2x_cnic_eth_cl_id(bp,\r\nBNX2X_FCOE_ETH_CL_ID_IDX);\r\nbnx2x_fcoe(bp, cid) = BNX2X_FCOE_ETH_CID(bp);\r\nbnx2x_fcoe(bp, fw_sb_id) = DEF_SB_ID;\r\nbnx2x_fcoe(bp, igu_sb_id) = bp->igu_dsb_id;\r\nbnx2x_fcoe(bp, rx_cons_sb) = BNX2X_FCOE_L2_RX_INDEX;\r\nbnx2x_init_txdata(bp, bnx2x_fcoe(bp, txdata_ptr[0]),\r\nfp->cid, FCOE_TXQ_IDX(bp), BNX2X_FCOE_L2_TX_INDEX,\r\nfp);\r\nDP(NETIF_MSG_IFUP, "created fcoe tx data (fp index %d)\n", fp->index);\r\nbnx2x_fcoe(bp, cl_qzone_id) = bnx2x_fp_qzone_id(fp);\r\nbnx2x_fcoe(bp, ustorm_rx_prods_offset) =\r\nbnx2x_rx_ustorm_prods_offset(fp);\r\n__set_bit(BNX2X_Q_TYPE_HAS_RX, &q_type);\r\n__set_bit(BNX2X_Q_TYPE_HAS_TX, &q_type);\r\nBUG_ON(fp->max_cos != 1);\r\nbnx2x_init_queue_obj(bp, &bnx2x_sp_obj(bp, fp).q_obj, fp->cl_id,\r\n&fp->cid, 1, BP_FUNC(bp), bnx2x_sp(bp, q_rdata),\r\nbnx2x_sp_mapping(bp, q_rdata), q_type);\r\nDP(NETIF_MSG_IFUP,\r\n"queue[%d]: bnx2x_init_sb(%p,%p) cl_id %d fw_sb %d igu_sb %d\n",\r\nfp->index, bp, fp->status_blk.e2_sb, fp->cl_id, fp->fw_sb_id,\r\nfp->igu_sb_id);\r\n}\r\nvoid bnx2x_nic_init_cnic(struct bnx2x *bp)\r\n{\r\nif (!NO_FCOE(bp))\r\nbnx2x_init_fcoe_fp(bp);\r\nbnx2x_init_sb(bp, bp->cnic_sb_mapping,\r\nBNX2X_VF_ID_INVALID, false,\r\nbnx2x_cnic_fw_sb_id(bp), bnx2x_cnic_igu_sb_id(bp));\r\nrmb();\r\nbnx2x_init_rx_rings_cnic(bp);\r\nbnx2x_init_tx_rings_cnic(bp);\r\nmb();\r\nmmiowb();\r\n}\r\nvoid bnx2x_pre_irq_nic_init(struct bnx2x *bp)\r\n{\r\nint i;\r\nfor_each_eth_queue(bp, i)\r\nbnx2x_init_eth_fp(bp, i);\r\nrmb();\r\nbnx2x_init_rx_rings(bp);\r\nbnx2x_init_tx_rings(bp);\r\nif (IS_PF(bp)) {\r\nbnx2x_init_mod_abs_int(bp, &bp->link_vars, bp->common.chip_id,\r\nbp->common.shmem_base,\r\nbp->common.shmem2_base, BP_PORT(bp));\r\nbnx2x_init_def_sb(bp);\r\nbnx2x_update_dsb_idx(bp);\r\nbnx2x_init_sp_ring(bp);\r\n} else {\r\nbnx2x_memset_stats(bp);\r\n}\r\n}\r\nvoid bnx2x_post_irq_nic_init(struct bnx2x *bp, u32 load_code)\r\n{\r\nbnx2x_init_eq_ring(bp);\r\nbnx2x_init_internal(bp, load_code);\r\nbnx2x_pf_init(bp);\r\nbnx2x_stats_init(bp);\r\nmb();\r\nmmiowb();\r\nbnx2x_int_enable(bp);\r\nbnx2x_attn_int_deasserted0(bp,\r\nREG_RD(bp, MISC_REG_AEU_AFTER_INVERT_1_FUNC_0 + BP_PORT(bp)*4) &\r\nAEU_INPUTS_ATTN_BITS_SPIO5);\r\n}\r\nstatic int bnx2x_gunzip_init(struct bnx2x *bp)\r\n{\r\nbp->gunzip_buf = dma_alloc_coherent(&bp->pdev->dev, FW_BUF_SIZE,\r\n&bp->gunzip_mapping, GFP_KERNEL);\r\nif (bp->gunzip_buf == NULL)\r\ngoto gunzip_nomem1;\r\nbp->strm = kmalloc(sizeof(*bp->strm), GFP_KERNEL);\r\nif (bp->strm == NULL)\r\ngoto gunzip_nomem2;\r\nbp->strm->workspace = vmalloc(zlib_inflate_workspacesize());\r\nif (bp->strm->workspace == NULL)\r\ngoto gunzip_nomem3;\r\nreturn 0;\r\ngunzip_nomem3:\r\nkfree(bp->strm);\r\nbp->strm = NULL;\r\ngunzip_nomem2:\r\ndma_free_coherent(&bp->pdev->dev, FW_BUF_SIZE, bp->gunzip_buf,\r\nbp->gunzip_mapping);\r\nbp->gunzip_buf = NULL;\r\ngunzip_nomem1:\r\nBNX2X_ERR("Cannot allocate firmware buffer for un-compression\n");\r\nreturn -ENOMEM;\r\n}\r\nstatic void bnx2x_gunzip_end(struct bnx2x *bp)\r\n{\r\nif (bp->strm) {\r\nvfree(bp->strm->workspace);\r\nkfree(bp->strm);\r\nbp->strm = NULL;\r\n}\r\nif (bp->gunzip_buf) {\r\ndma_free_coherent(&bp->pdev->dev, FW_BUF_SIZE, bp->gunzip_buf,\r\nbp->gunzip_mapping);\r\nbp->gunzip_buf = NULL;\r\n}\r\n}\r\nstatic int bnx2x_gunzip(struct bnx2x *bp, const u8 *zbuf, int len)\r\n{\r\nint n, rc;\r\nif ((zbuf[0] != 0x1f) || (zbuf[1] != 0x8b) || (zbuf[2] != Z_DEFLATED)) {\r\nBNX2X_ERR("Bad gzip header\n");\r\nreturn -EINVAL;\r\n}\r\nn = 10;\r\n#define FNAME 0x8\r\nif (zbuf[3] & FNAME)\r\nwhile ((zbuf[n++] != 0) && (n < len));\r\nbp->strm->next_in = (typeof(bp->strm->next_in))zbuf + n;\r\nbp->strm->avail_in = len - n;\r\nbp->strm->next_out = bp->gunzip_buf;\r\nbp->strm->avail_out = FW_BUF_SIZE;\r\nrc = zlib_inflateInit2(bp->strm, -MAX_WBITS);\r\nif (rc != Z_OK)\r\nreturn rc;\r\nrc = zlib_inflate(bp->strm, Z_FINISH);\r\nif ((rc != Z_OK) && (rc != Z_STREAM_END))\r\nnetdev_err(bp->dev, "Firmware decompression error: %s\n",\r\nbp->strm->msg);\r\nbp->gunzip_outlen = (FW_BUF_SIZE - bp->strm->avail_out);\r\nif (bp->gunzip_outlen & 0x3)\r\nnetdev_err(bp->dev,\r\n"Firmware decompression error: gunzip_outlen (%d) not aligned\n",\r\nbp->gunzip_outlen);\r\nbp->gunzip_outlen >>= 2;\r\nzlib_inflateEnd(bp->strm);\r\nif (rc == Z_STREAM_END)\r\nreturn 0;\r\nreturn rc;\r\n}\r\nstatic void bnx2x_lb_pckt(struct bnx2x *bp)\r\n{\r\nu32 wb_write[3];\r\nwb_write[0] = 0x55555555;\r\nwb_write[1] = 0x55555555;\r\nwb_write[2] = 0x20;\r\nREG_WR_DMAE(bp, NIG_REG_DEBUG_PACKET_LB, wb_write, 3);\r\nwb_write[0] = 0x09000000;\r\nwb_write[1] = 0x55555555;\r\nwb_write[2] = 0x10;\r\nREG_WR_DMAE(bp, NIG_REG_DEBUG_PACKET_LB, wb_write, 3);\r\n}\r\nstatic int bnx2x_int_mem_test(struct bnx2x *bp)\r\n{\r\nint factor;\r\nint count, i;\r\nu32 val = 0;\r\nif (CHIP_REV_IS_FPGA(bp))\r\nfactor = 120;\r\nelse if (CHIP_REV_IS_EMUL(bp))\r\nfactor = 200;\r\nelse\r\nfactor = 1;\r\nREG_WR(bp, TSDM_REG_ENABLE_IN1, 0x0);\r\nREG_WR(bp, TCM_REG_PRS_IFEN, 0x0);\r\nREG_WR(bp, CFC_REG_DEBUG0, 0x1);\r\nREG_WR(bp, NIG_REG_PRS_REQ_IN_EN, 0x0);\r\nREG_WR(bp, PRS_REG_CFC_SEARCH_INITIAL_CREDIT, 0x0);\r\nbnx2x_lb_pckt(bp);\r\ncount = 1000 * factor;\r\nwhile (count) {\r\nbnx2x_read_dmae(bp, NIG_REG_STAT2_BRB_OCTET, 2);\r\nval = *bnx2x_sp(bp, wb_data[0]);\r\nif (val == 0x10)\r\nbreak;\r\nusleep_range(10000, 20000);\r\ncount--;\r\n}\r\nif (val != 0x10) {\r\nBNX2X_ERR("NIG timeout val = 0x%x\n", val);\r\nreturn -1;\r\n}\r\ncount = 1000 * factor;\r\nwhile (count) {\r\nval = REG_RD(bp, PRS_REG_NUM_OF_PACKETS);\r\nif (val == 1)\r\nbreak;\r\nusleep_range(10000, 20000);\r\ncount--;\r\n}\r\nif (val != 0x1) {\r\nBNX2X_ERR("PRS timeout val = 0x%x\n", val);\r\nreturn -2;\r\n}\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR, 0x03);\r\nmsleep(50);\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET, 0x03);\r\nmsleep(50);\r\nbnx2x_init_block(bp, BLOCK_BRB1, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_PRS, PHASE_COMMON);\r\nDP(NETIF_MSG_HW, "part2\n");\r\nREG_WR(bp, TSDM_REG_ENABLE_IN1, 0x0);\r\nREG_WR(bp, TCM_REG_PRS_IFEN, 0x0);\r\nREG_WR(bp, CFC_REG_DEBUG0, 0x1);\r\nREG_WR(bp, NIG_REG_PRS_REQ_IN_EN, 0x0);\r\nREG_WR(bp, PRS_REG_CFC_SEARCH_INITIAL_CREDIT, 0x0);\r\nfor (i = 0; i < 10; i++)\r\nbnx2x_lb_pckt(bp);\r\ncount = 1000 * factor;\r\nwhile (count) {\r\nbnx2x_read_dmae(bp, NIG_REG_STAT2_BRB_OCTET, 2);\r\nval = *bnx2x_sp(bp, wb_data[0]);\r\nif (val == 0xb0)\r\nbreak;\r\nusleep_range(10000, 20000);\r\ncount--;\r\n}\r\nif (val != 0xb0) {\r\nBNX2X_ERR("NIG timeout val = 0x%x\n", val);\r\nreturn -3;\r\n}\r\nval = REG_RD(bp, PRS_REG_NUM_OF_PACKETS);\r\nif (val != 2)\r\nBNX2X_ERR("PRS timeout val = 0x%x\n", val);\r\nREG_WR(bp, PRS_REG_CFC_SEARCH_INITIAL_CREDIT, 0x1);\r\nmsleep(10 * factor);\r\nval = REG_RD(bp, PRS_REG_NUM_OF_PACKETS);\r\nif (val != 3)\r\nBNX2X_ERR("PRS timeout val = 0x%x\n", val);\r\nfor (i = 0; i < 11; i++)\r\nREG_RD(bp, NIG_REG_INGRESS_EOP_LB_FIFO);\r\nval = REG_RD(bp, NIG_REG_INGRESS_EOP_LB_EMPTY);\r\nif (val != 1) {\r\nBNX2X_ERR("clear of NIG failed\n");\r\nreturn -4;\r\n}\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR, 0x03);\r\nmsleep(50);\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET, 0x03);\r\nmsleep(50);\r\nbnx2x_init_block(bp, BLOCK_BRB1, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_PRS, PHASE_COMMON);\r\nif (!CNIC_SUPPORT(bp))\r\nREG_WR(bp, PRS_REG_NIC_MODE, 1);\r\nREG_WR(bp, TSDM_REG_ENABLE_IN1, 0x7fffffff);\r\nREG_WR(bp, TCM_REG_PRS_IFEN, 0x1);\r\nREG_WR(bp, CFC_REG_DEBUG0, 0x0);\r\nREG_WR(bp, NIG_REG_PRS_REQ_IN_EN, 0x1);\r\nDP(NETIF_MSG_HW, "done\n");\r\nreturn 0;\r\n}\r\nstatic void bnx2x_enable_blocks_attention(struct bnx2x *bp)\r\n{\r\nu32 val;\r\nREG_WR(bp, PXP_REG_PXP_INT_MASK_0, 0);\r\nif (!CHIP_IS_E1x(bp))\r\nREG_WR(bp, PXP_REG_PXP_INT_MASK_1, 0x40);\r\nelse\r\nREG_WR(bp, PXP_REG_PXP_INT_MASK_1, 0);\r\nREG_WR(bp, DORQ_REG_DORQ_INT_MASK, 0);\r\nREG_WR(bp, CFC_REG_CFC_INT_MASK, 0);\r\nREG_WR(bp, BRB1_REG_BRB1_INT_MASK, 0xFC00);\r\nREG_WR(bp, QM_REG_QM_INT_MASK, 0);\r\nREG_WR(bp, TM_REG_TM_INT_MASK, 0);\r\nREG_WR(bp, XSDM_REG_XSDM_INT_MASK_0, 0);\r\nREG_WR(bp, XSDM_REG_XSDM_INT_MASK_1, 0);\r\nREG_WR(bp, XCM_REG_XCM_INT_MASK, 0);\r\nREG_WR(bp, USDM_REG_USDM_INT_MASK_0, 0);\r\nREG_WR(bp, USDM_REG_USDM_INT_MASK_1, 0);\r\nREG_WR(bp, UCM_REG_UCM_INT_MASK, 0);\r\nREG_WR(bp, GRCBASE_UPB + PB_REG_PB_INT_MASK, 0);\r\nREG_WR(bp, CSDM_REG_CSDM_INT_MASK_0, 0);\r\nREG_WR(bp, CSDM_REG_CSDM_INT_MASK_1, 0);\r\nREG_WR(bp, CCM_REG_CCM_INT_MASK, 0);\r\nval = PXP2_PXP2_INT_MASK_0_REG_PGL_CPL_AFT |\r\nPXP2_PXP2_INT_MASK_0_REG_PGL_CPL_OF |\r\nPXP2_PXP2_INT_MASK_0_REG_PGL_PCIE_ATTN;\r\nif (!CHIP_IS_E1x(bp))\r\nval |= PXP2_PXP2_INT_MASK_0_REG_PGL_READ_BLOCKED |\r\nPXP2_PXP2_INT_MASK_0_REG_PGL_WRITE_BLOCKED;\r\nREG_WR(bp, PXP2_REG_PXP2_INT_MASK_0, val);\r\nREG_WR(bp, TSDM_REG_TSDM_INT_MASK_0, 0);\r\nREG_WR(bp, TSDM_REG_TSDM_INT_MASK_1, 0);\r\nREG_WR(bp, TCM_REG_TCM_INT_MASK, 0);\r\nif (!CHIP_IS_E1x(bp))\r\nREG_WR(bp, TSEM_REG_TSEM_INT_MASK_1, 0x07ff);\r\nREG_WR(bp, CDU_REG_CDU_INT_MASK, 0);\r\nREG_WR(bp, DMAE_REG_DMAE_INT_MASK, 0);\r\nREG_WR(bp, PBF_REG_PBF_INT_MASK, 0x18);\r\n}\r\nstatic void bnx2x_reset_common(struct bnx2x *bp)\r\n{\r\nu32 val = 0x1400;\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR,\r\n0xd3ffff7f);\r\nif (CHIP_IS_E3(bp)) {\r\nval |= MISC_REGISTERS_RESET_REG_2_MSTAT0;\r\nval |= MISC_REGISTERS_RESET_REG_2_MSTAT1;\r\n}\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR, val);\r\n}\r\nstatic void bnx2x_setup_dmae(struct bnx2x *bp)\r\n{\r\nbp->dmae_ready = 0;\r\nspin_lock_init(&bp->dmae_lock);\r\n}\r\nstatic void bnx2x_init_pxp(struct bnx2x *bp)\r\n{\r\nu16 devctl;\r\nint r_order, w_order;\r\npcie_capability_read_word(bp->pdev, PCI_EXP_DEVCTL, &devctl);\r\nDP(NETIF_MSG_HW, "read 0x%x from devctl\n", devctl);\r\nw_order = ((devctl & PCI_EXP_DEVCTL_PAYLOAD) >> 5);\r\nif (bp->mrrs == -1)\r\nr_order = ((devctl & PCI_EXP_DEVCTL_READRQ) >> 12);\r\nelse {\r\nDP(NETIF_MSG_HW, "force read order to %d\n", bp->mrrs);\r\nr_order = bp->mrrs;\r\n}\r\nbnx2x_init_pxp_arb(bp, r_order, w_order);\r\n}\r\nstatic void bnx2x_setup_fan_failure_detection(struct bnx2x *bp)\r\n{\r\nint is_required;\r\nu32 val;\r\nint port;\r\nif (BP_NOMCP(bp))\r\nreturn;\r\nis_required = 0;\r\nval = SHMEM_RD(bp, dev_info.shared_hw_config.config2) &\r\nSHARED_HW_CFG_FAN_FAILURE_MASK;\r\nif (val == SHARED_HW_CFG_FAN_FAILURE_ENABLED)\r\nis_required = 1;\r\nelse if (val == SHARED_HW_CFG_FAN_FAILURE_PHY_TYPE)\r\nfor (port = PORT_0; port < PORT_MAX; port++) {\r\nis_required |=\r\nbnx2x_fan_failure_det_req(\r\nbp,\r\nbp->common.shmem_base,\r\nbp->common.shmem2_base,\r\nport);\r\n}\r\nDP(NETIF_MSG_HW, "fan detection setting: %d\n", is_required);\r\nif (is_required == 0)\r\nreturn;\r\nbnx2x_set_spio(bp, MISC_SPIO_SPIO5, MISC_SPIO_INPUT_HI_Z);\r\nval = REG_RD(bp, MISC_REG_SPIO_INT);\r\nval |= (MISC_SPIO_SPIO5 << MISC_SPIO_INT_OLD_SET_POS);\r\nREG_WR(bp, MISC_REG_SPIO_INT, val);\r\nval = REG_RD(bp, MISC_REG_SPIO_EVENT_EN);\r\nval |= MISC_SPIO_SPIO5;\r\nREG_WR(bp, MISC_REG_SPIO_EVENT_EN, val);\r\n}\r\nvoid bnx2x_pf_disable(struct bnx2x *bp)\r\n{\r\nu32 val = REG_RD(bp, IGU_REG_PF_CONFIGURATION);\r\nval &= ~IGU_PF_CONF_FUNC_EN;\r\nREG_WR(bp, IGU_REG_PF_CONFIGURATION, val);\r\nREG_WR(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER, 0);\r\nREG_WR(bp, CFC_REG_WEAK_ENABLE_PF, 0);\r\n}\r\nstatic void bnx2x__common_init_phy(struct bnx2x *bp)\r\n{\r\nu32 shmem_base[2], shmem2_base[2];\r\nif (SHMEM2_RD(bp, size) >\r\n(u32)offsetof(struct shmem2_region, lfa_host_addr[BP_PORT(bp)]))\r\nreturn;\r\nshmem_base[0] = bp->common.shmem_base;\r\nshmem2_base[0] = bp->common.shmem2_base;\r\nif (!CHIP_IS_E1x(bp)) {\r\nshmem_base[1] =\r\nSHMEM2_RD(bp, other_shmem_base_addr);\r\nshmem2_base[1] =\r\nSHMEM2_RD(bp, other_shmem2_base_addr);\r\n}\r\nbnx2x_acquire_phy_lock(bp);\r\nbnx2x_common_init_phy(bp, shmem_base, shmem2_base,\r\nbp->common.chip_id);\r\nbnx2x_release_phy_lock(bp);\r\n}\r\nstatic void bnx2x_config_endianity(struct bnx2x *bp, u32 val)\r\n{\r\nREG_WR(bp, PXP2_REG_RQ_QM_ENDIAN_M, val);\r\nREG_WR(bp, PXP2_REG_RQ_TM_ENDIAN_M, val);\r\nREG_WR(bp, PXP2_REG_RQ_SRC_ENDIAN_M, val);\r\nREG_WR(bp, PXP2_REG_RQ_CDU_ENDIAN_M, val);\r\nREG_WR(bp, PXP2_REG_RQ_DBG_ENDIAN_M, val);\r\nREG_WR(bp, PXP2_REG_RQ_HC_ENDIAN_M, 0);\r\nREG_WR(bp, PXP2_REG_RD_QM_SWAP_MODE, val);\r\nREG_WR(bp, PXP2_REG_RD_TM_SWAP_MODE, val);\r\nREG_WR(bp, PXP2_REG_RD_SRC_SWAP_MODE, val);\r\nREG_WR(bp, PXP2_REG_RD_CDURD_SWAP_MODE, val);\r\n}\r\nstatic void bnx2x_set_endianity(struct bnx2x *bp)\r\n{\r\n#ifdef __BIG_ENDIAN\r\nbnx2x_config_endianity(bp, 1);\r\n#else\r\nbnx2x_config_endianity(bp, 0);\r\n#endif\r\n}\r\nstatic void bnx2x_reset_endianity(struct bnx2x *bp)\r\n{\r\nbnx2x_config_endianity(bp, 0);\r\n}\r\nstatic int bnx2x_init_hw_common(struct bnx2x *bp)\r\n{\r\nu32 val;\r\nDP(NETIF_MSG_HW, "starting common init func %d\n", BP_ABS_FUNC(bp));\r\nbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RESET);\r\nbnx2x_reset_common(bp);\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET, 0xffffffff);\r\nval = 0xfffc;\r\nif (CHIP_IS_E3(bp)) {\r\nval |= MISC_REGISTERS_RESET_REG_2_MSTAT0;\r\nval |= MISC_REGISTERS_RESET_REG_2_MSTAT1;\r\n}\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET, val);\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RESET);\r\nbnx2x_init_block(bp, BLOCK_MISC, PHASE_COMMON);\r\nif (!CHIP_IS_E1x(bp)) {\r\nu8 abs_func_id;\r\nfor (abs_func_id = BP_PATH(bp);\r\nabs_func_id < E2_FUNC_MAX*2; abs_func_id += 2) {\r\nif (abs_func_id == BP_ABS_FUNC(bp)) {\r\nREG_WR(bp,\r\nPGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER,\r\n1);\r\ncontinue;\r\n}\r\nbnx2x_pretend_func(bp, abs_func_id);\r\nbnx2x_pf_disable(bp);\r\nbnx2x_pretend_func(bp, BP_ABS_FUNC(bp));\r\n}\r\n}\r\nbnx2x_init_block(bp, BLOCK_PXP, PHASE_COMMON);\r\nif (CHIP_IS_E1(bp)) {\r\nREG_WR(bp, PXP_REG_PXP_INT_MASK_0, 0);\r\n}\r\nbnx2x_init_block(bp, BLOCK_PXP2, PHASE_COMMON);\r\nbnx2x_init_pxp(bp);\r\nbnx2x_set_endianity(bp);\r\nbnx2x_ilt_init_page_size(bp, INITOP_SET);\r\nif (CHIP_REV_IS_FPGA(bp) && CHIP_IS_E1H(bp))\r\nREG_WR(bp, PXP2_REG_PGL_TAGS_LIMIT, 0x1);\r\nmsleep(100);\r\nval = REG_RD(bp, PXP2_REG_RQ_CFG_DONE);\r\nif (val != 1) {\r\nBNX2X_ERR("PXP2 CFG failed\n");\r\nreturn -EBUSY;\r\n}\r\nval = REG_RD(bp, PXP2_REG_RD_INIT_DONE);\r\nif (val != 1) {\r\nBNX2X_ERR("PXP2 RD_INIT failed\n");\r\nreturn -EBUSY;\r\n}\r\nif (!CHIP_IS_E1x(bp)) {\r\nstruct ilt_client_info ilt_cli;\r\nstruct bnx2x_ilt ilt;\r\nmemset(&ilt_cli, 0, sizeof(struct ilt_client_info));\r\nmemset(&ilt, 0, sizeof(struct bnx2x_ilt));\r\nilt_cli.start = 0;\r\nilt_cli.end = ILT_NUM_PAGE_ENTRIES - 1;\r\nilt_cli.client_num = ILT_CLIENT_TM;\r\nbnx2x_pretend_func(bp, (BP_PATH(bp) + 6));\r\nbnx2x_ilt_client_init_op_ilt(bp, &ilt, &ilt_cli, INITOP_CLEAR);\r\nbnx2x_pretend_func(bp, BP_ABS_FUNC(bp));\r\nREG_WR(bp, PXP2_REG_RQ_DRAM_ALIGN, BNX2X_PXP_DRAM_ALIGN);\r\nREG_WR(bp, PXP2_REG_RQ_DRAM_ALIGN_RD, BNX2X_PXP_DRAM_ALIGN);\r\nREG_WR(bp, PXP2_REG_RQ_DRAM_ALIGN_SEL, 1);\r\n}\r\nREG_WR(bp, PXP2_REG_RQ_DISABLE_INPUTS, 0);\r\nREG_WR(bp, PXP2_REG_RD_DISABLE_INPUTS, 0);\r\nif (!CHIP_IS_E1x(bp)) {\r\nint factor = CHIP_REV_IS_EMUL(bp) ? 1000 :\r\n(CHIP_REV_IS_FPGA(bp) ? 400 : 0);\r\nbnx2x_init_block(bp, BLOCK_PGLUE_B, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_ATC, PHASE_COMMON);\r\ndo {\r\nmsleep(200);\r\nval = REG_RD(bp, ATC_REG_ATC_INIT_DONE);\r\n} while (factor-- && (val != 1));\r\nif (val != 1) {\r\nBNX2X_ERR("ATC_INIT failed\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nbnx2x_init_block(bp, BLOCK_DMAE, PHASE_COMMON);\r\nbnx2x_iov_init_dmae(bp);\r\nbp->dmae_ready = 1;\r\nbnx2x_init_fill(bp, TSEM_REG_PRAM, 0, 8, 1);\r\nbnx2x_init_block(bp, BLOCK_TCM, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_UCM, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_CCM, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_XCM, PHASE_COMMON);\r\nbnx2x_read_dmae(bp, XSEM_REG_PASSIVE_BUFFER, 3);\r\nbnx2x_read_dmae(bp, CSEM_REG_PASSIVE_BUFFER, 3);\r\nbnx2x_read_dmae(bp, TSEM_REG_PASSIVE_BUFFER, 3);\r\nbnx2x_read_dmae(bp, USEM_REG_PASSIVE_BUFFER, 3);\r\nbnx2x_init_block(bp, BLOCK_QM, PHASE_COMMON);\r\nbnx2x_qm_init_ptr_table(bp, bp->qm_cid_count, INITOP_SET);\r\nREG_WR(bp, QM_REG_SOFT_RESET, 1);\r\nREG_WR(bp, QM_REG_SOFT_RESET, 0);\r\nif (CNIC_SUPPORT(bp))\r\nbnx2x_init_block(bp, BLOCK_TM, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_DORQ, PHASE_COMMON);\r\nif (!CHIP_REV_IS_SLOW(bp))\r\nREG_WR(bp, DORQ_REG_DORQ_INT_MASK, 0);\r\nbnx2x_init_block(bp, BLOCK_BRB1, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_PRS, PHASE_COMMON);\r\nREG_WR(bp, PRS_REG_A_PRSU_20, 0xf);\r\nif (!CHIP_IS_E1(bp))\r\nREG_WR(bp, PRS_REG_E1HOV_MODE, bp->path_has_ovlan);\r\nif (!CHIP_IS_E1x(bp) && !CHIP_IS_E3B0(bp)) {\r\nif (IS_MF_AFEX(bp)) {\r\nREG_WR(bp, PRS_REG_HDRS_AFTER_BASIC, 0xE);\r\nREG_WR(bp, PRS_REG_MUST_HAVE_HDRS, 0xA);\r\nREG_WR(bp, PRS_REG_HDRS_AFTER_TAG_0, 0x6);\r\nREG_WR(bp, PRS_REG_TAG_ETHERTYPE_0, 0x8926);\r\nREG_WR(bp, PRS_REG_TAG_LEN_0, 0x4);\r\n} else {\r\nREG_WR(bp, PRS_REG_HDRS_AFTER_BASIC,\r\nbp->path_has_ovlan ? 7 : 6);\r\n}\r\n}\r\nbnx2x_init_block(bp, BLOCK_TSDM, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_CSDM, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_USDM, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_XSDM, PHASE_COMMON);\r\nif (!CHIP_IS_E1x(bp)) {\r\nREG_WR(bp, TSEM_REG_FAST_MEMORY + VFC_REG_MEMORIES_RST,\r\nVFC_MEMORIES_RST_REG_CAM_RST |\r\nVFC_MEMORIES_RST_REG_RAM_RST);\r\nREG_WR(bp, XSEM_REG_FAST_MEMORY + VFC_REG_MEMORIES_RST,\r\nVFC_MEMORIES_RST_REG_CAM_RST |\r\nVFC_MEMORIES_RST_REG_RAM_RST);\r\nmsleep(20);\r\n}\r\nbnx2x_init_block(bp, BLOCK_TSEM, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_USEM, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_CSEM, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_XSEM, PHASE_COMMON);\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR,\r\n0x80000000);\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET,\r\n0x80000000);\r\nbnx2x_init_block(bp, BLOCK_UPB, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_XPB, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_PBF, PHASE_COMMON);\r\nif (!CHIP_IS_E1x(bp)) {\r\nif (IS_MF_AFEX(bp)) {\r\nREG_WR(bp, PBF_REG_HDRS_AFTER_BASIC, 0xE);\r\nREG_WR(bp, PBF_REG_MUST_HAVE_HDRS, 0xA);\r\nREG_WR(bp, PBF_REG_HDRS_AFTER_TAG_0, 0x6);\r\nREG_WR(bp, PBF_REG_TAG_ETHERTYPE_0, 0x8926);\r\nREG_WR(bp, PBF_REG_TAG_LEN_0, 0x4);\r\n} else {\r\nREG_WR(bp, PBF_REG_HDRS_AFTER_BASIC,\r\nbp->path_has_ovlan ? 7 : 6);\r\n}\r\n}\r\nREG_WR(bp, SRC_REG_SOFT_RST, 1);\r\nbnx2x_init_block(bp, BLOCK_SRC, PHASE_COMMON);\r\nif (CNIC_SUPPORT(bp)) {\r\nREG_WR(bp, SRC_REG_KEYSEARCH_0, 0x63285672);\r\nREG_WR(bp, SRC_REG_KEYSEARCH_1, 0x24b8f2cc);\r\nREG_WR(bp, SRC_REG_KEYSEARCH_2, 0x223aef9b);\r\nREG_WR(bp, SRC_REG_KEYSEARCH_3, 0x26001e3a);\r\nREG_WR(bp, SRC_REG_KEYSEARCH_4, 0x7ae91116);\r\nREG_WR(bp, SRC_REG_KEYSEARCH_5, 0x5ce5230b);\r\nREG_WR(bp, SRC_REG_KEYSEARCH_6, 0x298d8adf);\r\nREG_WR(bp, SRC_REG_KEYSEARCH_7, 0x6eb0ff09);\r\nREG_WR(bp, SRC_REG_KEYSEARCH_8, 0x1830f82f);\r\nREG_WR(bp, SRC_REG_KEYSEARCH_9, 0x01e46be7);\r\n}\r\nREG_WR(bp, SRC_REG_SOFT_RST, 0);\r\nif (sizeof(union cdu_context) != 1024)\r\ndev_alert(&bp->pdev->dev,\r\n"please adjust the size of cdu_context(%ld)\n",\r\n(long)sizeof(union cdu_context));\r\nbnx2x_init_block(bp, BLOCK_CDU, PHASE_COMMON);\r\nval = (4 << 24) + (0 << 12) + 1024;\r\nREG_WR(bp, CDU_REG_CDU_GLOBAL_PARAMS, val);\r\nbnx2x_init_block(bp, BLOCK_CFC, PHASE_COMMON);\r\nREG_WR(bp, CFC_REG_INIT_REG, 0x7FF);\r\nREG_WR(bp, CFC_REG_CFC_INT_MASK, 0);\r\nREG_WR(bp, CFC_REG_DEBUG0, 0x20020000);\r\nbnx2x_init_block(bp, BLOCK_HC, PHASE_COMMON);\r\nif (!CHIP_IS_E1x(bp) && BP_NOMCP(bp))\r\nREG_WR(bp, IGU_REG_RESET_MEMORIES, 0x36);\r\nbnx2x_init_block(bp, BLOCK_IGU, PHASE_COMMON);\r\nbnx2x_init_block(bp, BLOCK_MISC_AEU, PHASE_COMMON);\r\nREG_WR(bp, 0x2814, 0xffffffff);\r\nREG_WR(bp, 0x3820, 0xffffffff);\r\nif (!CHIP_IS_E1x(bp)) {\r\nREG_WR(bp, PCICFG_OFFSET + PXPCS_TL_CONTROL_5,\r\n(PXPCS_TL_CONTROL_5_ERR_UNSPPORT1 |\r\nPXPCS_TL_CONTROL_5_ERR_UNSPPORT));\r\nREG_WR(bp, PCICFG_OFFSET + PXPCS_TL_FUNC345_STAT,\r\n(PXPCS_TL_FUNC345_STAT_ERR_UNSPPORT4 |\r\nPXPCS_TL_FUNC345_STAT_ERR_UNSPPORT3 |\r\nPXPCS_TL_FUNC345_STAT_ERR_UNSPPORT2));\r\nREG_WR(bp, PCICFG_OFFSET + PXPCS_TL_FUNC678_STAT,\r\n(PXPCS_TL_FUNC678_STAT_ERR_UNSPPORT7 |\r\nPXPCS_TL_FUNC678_STAT_ERR_UNSPPORT6 |\r\nPXPCS_TL_FUNC678_STAT_ERR_UNSPPORT5));\r\n}\r\nbnx2x_init_block(bp, BLOCK_NIG, PHASE_COMMON);\r\nif (!CHIP_IS_E1(bp)) {\r\nif (!CHIP_IS_E3(bp))\r\nREG_WR(bp, NIG_REG_LLH_MF_MODE, IS_MF(bp));\r\n}\r\nif (CHIP_IS_E1H(bp))\r\nREG_WR(bp, NIG_REG_LLH_E1HOV_MODE, IS_MF_SD(bp));\r\nif (CHIP_REV_IS_SLOW(bp))\r\nmsleep(200);\r\nval = reg_poll(bp, CFC_REG_LL_INIT_DONE, 1, 100, 10);\r\nif (val != 1) {\r\nBNX2X_ERR("CFC LL_INIT failed\n");\r\nreturn -EBUSY;\r\n}\r\nval = reg_poll(bp, CFC_REG_AC_INIT_DONE, 1, 100, 10);\r\nif (val != 1) {\r\nBNX2X_ERR("CFC AC_INIT failed\n");\r\nreturn -EBUSY;\r\n}\r\nval = reg_poll(bp, CFC_REG_CAM_INIT_DONE, 1, 100, 10);\r\nif (val != 1) {\r\nBNX2X_ERR("CFC CAM_INIT failed\n");\r\nreturn -EBUSY;\r\n}\r\nREG_WR(bp, CFC_REG_DEBUG0, 0);\r\nif (CHIP_IS_E1(bp)) {\r\nbnx2x_read_dmae(bp, NIG_REG_STAT2_BRB_OCTET, 2);\r\nval = *bnx2x_sp(bp, wb_data[0]);\r\nif ((val == 0) && bnx2x_int_mem_test(bp)) {\r\nBNX2X_ERR("internal mem self test failed\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nbnx2x_setup_fan_failure_detection(bp);\r\nREG_RD(bp, PXP2_REG_PXP2_INT_STS_CLR_0);\r\nbnx2x_enable_blocks_attention(bp);\r\nbnx2x_enable_blocks_parity(bp);\r\nif (!BP_NOMCP(bp)) {\r\nif (CHIP_IS_E1x(bp))\r\nbnx2x__common_init_phy(bp);\r\n} else\r\nBNX2X_ERR("Bootcode is missing - can not initialize link\n");\r\nif (SHMEM2_HAS(bp, netproc_fw_ver))\r\nSHMEM2_WR(bp, netproc_fw_ver, REG_RD(bp, XSEM_REG_PRAM));\r\nreturn 0;\r\n}\r\nstatic int bnx2x_init_hw_common_chip(struct bnx2x *bp)\r\n{\r\nint rc = bnx2x_init_hw_common(bp);\r\nif (rc)\r\nreturn rc;\r\nif (!BP_NOMCP(bp))\r\nbnx2x__common_init_phy(bp);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_init_hw_port(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nint init_phase = port ? PHASE_PORT1 : PHASE_PORT0;\r\nu32 low, high;\r\nu32 val, reg;\r\nDP(NETIF_MSG_HW, "starting port init port %d\n", port);\r\nREG_WR(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4, 0);\r\nbnx2x_init_block(bp, BLOCK_MISC, init_phase);\r\nbnx2x_init_block(bp, BLOCK_PXP, init_phase);\r\nbnx2x_init_block(bp, BLOCK_PXP2, init_phase);\r\nif (!CHIP_IS_E1x(bp))\r\nREG_WR(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER, 1);\r\nbnx2x_init_block(bp, BLOCK_ATC, init_phase);\r\nbnx2x_init_block(bp, BLOCK_DMAE, init_phase);\r\nbnx2x_init_block(bp, BLOCK_PGLUE_B, init_phase);\r\nbnx2x_init_block(bp, BLOCK_QM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_TCM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_UCM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_CCM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_XCM, init_phase);\r\nbnx2x_qm_init_cid_count(bp, bp->qm_cid_count, INITOP_SET);\r\nif (CNIC_SUPPORT(bp)) {\r\nbnx2x_init_block(bp, BLOCK_TM, init_phase);\r\nREG_WR(bp, TM_REG_LIN0_SCAN_TIME + port*4, 20);\r\nREG_WR(bp, TM_REG_LIN0_MAX_ACTIVE_CID + port*4, 31);\r\n}\r\nbnx2x_init_block(bp, BLOCK_DORQ, init_phase);\r\nbnx2x_init_block(bp, BLOCK_BRB1, init_phase);\r\nif (CHIP_IS_E1(bp) || CHIP_IS_E1H(bp)) {\r\nif (IS_MF(bp))\r\nlow = ((bp->flags & ONE_PORT_FLAG) ? 160 : 246);\r\nelse if (bp->dev->mtu > 4096) {\r\nif (bp->flags & ONE_PORT_FLAG)\r\nlow = 160;\r\nelse {\r\nval = bp->dev->mtu;\r\nlow = 96 + (val/64) +\r\n((val % 64) ? 1 : 0);\r\n}\r\n} else\r\nlow = ((bp->flags & ONE_PORT_FLAG) ? 80 : 160);\r\nhigh = low + 56;\r\nREG_WR(bp, BRB1_REG_PAUSE_LOW_THRESHOLD_0 + port*4, low);\r\nREG_WR(bp, BRB1_REG_PAUSE_HIGH_THRESHOLD_0 + port*4, high);\r\n}\r\nif (CHIP_MODE_IS_4_PORT(bp))\r\nREG_WR(bp, (BP_PORT(bp) ?\r\nBRB1_REG_MAC_GUARANTIED_1 :\r\nBRB1_REG_MAC_GUARANTIED_0), 40);\r\nbnx2x_init_block(bp, BLOCK_PRS, init_phase);\r\nif (CHIP_IS_E3B0(bp)) {\r\nif (IS_MF_AFEX(bp)) {\r\nREG_WR(bp, BP_PORT(bp) ?\r\nPRS_REG_HDRS_AFTER_BASIC_PORT_1 :\r\nPRS_REG_HDRS_AFTER_BASIC_PORT_0, 0xE);\r\nREG_WR(bp, BP_PORT(bp) ?\r\nPRS_REG_HDRS_AFTER_TAG_0_PORT_1 :\r\nPRS_REG_HDRS_AFTER_TAG_0_PORT_0, 0x6);\r\nREG_WR(bp, BP_PORT(bp) ?\r\nPRS_REG_MUST_HAVE_HDRS_PORT_1 :\r\nPRS_REG_MUST_HAVE_HDRS_PORT_0, 0xA);\r\n} else {\r\nREG_WR(bp, BP_PORT(bp) ?\r\nPRS_REG_HDRS_AFTER_BASIC_PORT_1 :\r\nPRS_REG_HDRS_AFTER_BASIC_PORT_0,\r\n(bp->path_has_ovlan ? 7 : 6));\r\n}\r\n}\r\nbnx2x_init_block(bp, BLOCK_TSDM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_CSDM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_USDM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_XSDM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_TSEM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_USEM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_CSEM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_XSEM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_UPB, init_phase);\r\nbnx2x_init_block(bp, BLOCK_XPB, init_phase);\r\nbnx2x_init_block(bp, BLOCK_PBF, init_phase);\r\nif (CHIP_IS_E1x(bp)) {\r\nREG_WR(bp, PBF_REG_P0_PAUSE_ENABLE + port*4, 0);\r\nREG_WR(bp, PBF_REG_P0_ARB_THRSH + port*4, (9040/16));\r\nREG_WR(bp, PBF_REG_P0_INIT_CRD + port*4, (9040/16) + 553 - 22);\r\nREG_WR(bp, PBF_REG_INIT_P0 + port*4, 1);\r\nudelay(50);\r\nREG_WR(bp, PBF_REG_INIT_P0 + port*4, 0);\r\n}\r\nif (CNIC_SUPPORT(bp))\r\nbnx2x_init_block(bp, BLOCK_SRC, init_phase);\r\nbnx2x_init_block(bp, BLOCK_CDU, init_phase);\r\nbnx2x_init_block(bp, BLOCK_CFC, init_phase);\r\nif (CHIP_IS_E1(bp)) {\r\nREG_WR(bp, HC_REG_LEADING_EDGE_0 + port*8, 0);\r\nREG_WR(bp, HC_REG_TRAILING_EDGE_0 + port*8, 0);\r\n}\r\nbnx2x_init_block(bp, BLOCK_HC, init_phase);\r\nbnx2x_init_block(bp, BLOCK_IGU, init_phase);\r\nbnx2x_init_block(bp, BLOCK_MISC_AEU, init_phase);\r\nval = IS_MF(bp) ? 0xF7 : 0x7;\r\nval |= CHIP_IS_E1(bp) ? 0 : 0x10;\r\nREG_WR(bp, MISC_REG_AEU_MASK_ATTN_FUNC_0 + port*4, val);\r\nreg = port ? MISC_REG_AEU_ENABLE4_NIG_1 : MISC_REG_AEU_ENABLE4_NIG_0;\r\nREG_WR(bp, reg,\r\nREG_RD(bp, reg) &\r\n~AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY);\r\nreg = port ? MISC_REG_AEU_ENABLE4_PXP_1 : MISC_REG_AEU_ENABLE4_PXP_0;\r\nREG_WR(bp, reg,\r\nREG_RD(bp, reg) &\r\n~AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY);\r\nbnx2x_init_block(bp, BLOCK_NIG, init_phase);\r\nif (!CHIP_IS_E1x(bp)) {\r\nif (IS_MF_AFEX(bp))\r\nREG_WR(bp, BP_PORT(bp) ?\r\nNIG_REG_P1_HDRS_AFTER_BASIC :\r\nNIG_REG_P0_HDRS_AFTER_BASIC, 0xE);\r\nelse\r\nREG_WR(bp, BP_PORT(bp) ?\r\nNIG_REG_P1_HDRS_AFTER_BASIC :\r\nNIG_REG_P0_HDRS_AFTER_BASIC,\r\nIS_MF_SD(bp) ? 7 : 6);\r\nif (CHIP_IS_E3(bp))\r\nREG_WR(bp, BP_PORT(bp) ?\r\nNIG_REG_LLH1_MF_MODE :\r\nNIG_REG_LLH_MF_MODE, IS_MF(bp));\r\n}\r\nif (!CHIP_IS_E3(bp))\r\nREG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL + port*4, 1);\r\nif (!CHIP_IS_E1(bp)) {\r\nREG_WR(bp, NIG_REG_LLH0_BRB1_DRV_MASK_MF + port*4,\r\n(IS_MF_SD(bp) ? 0x1 : 0x2));\r\nif (!CHIP_IS_E1x(bp)) {\r\nval = 0;\r\nswitch (bp->mf_mode) {\r\ncase MULTI_FUNCTION_SD:\r\nval = 1;\r\nbreak;\r\ncase MULTI_FUNCTION_SI:\r\ncase MULTI_FUNCTION_AFEX:\r\nval = 2;\r\nbreak;\r\n}\r\nREG_WR(bp, (BP_PORT(bp) ? NIG_REG_LLH1_CLS_TYPE :\r\nNIG_REG_LLH0_CLS_TYPE), val);\r\n}\r\n{\r\nREG_WR(bp, NIG_REG_LLFC_ENABLE_0 + port*4, 0);\r\nREG_WR(bp, NIG_REG_LLFC_OUT_EN_0 + port*4, 0);\r\nREG_WR(bp, NIG_REG_PAUSE_ENABLE_0 + port*4, 1);\r\n}\r\n}\r\nval = REG_RD(bp, MISC_REG_SPIO_EVENT_EN);\r\nif (val & MISC_SPIO_SPIO5) {\r\nu32 reg_addr = (port ? MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0 :\r\nMISC_REG_AEU_ENABLE1_FUNC_0_OUT_0);\r\nval = REG_RD(bp, reg_addr);\r\nval |= AEU_INPUTS_ATTN_BITS_SPIO5;\r\nREG_WR(bp, reg_addr, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_ilt_wr(struct bnx2x *bp, u32 index, dma_addr_t addr)\r\n{\r\nint reg;\r\nu32 wb_write[2];\r\nif (CHIP_IS_E1(bp))\r\nreg = PXP2_REG_RQ_ONCHIP_AT + index*8;\r\nelse\r\nreg = PXP2_REG_RQ_ONCHIP_AT_B0 + index*8;\r\nwb_write[0] = ONCHIP_ADDR1(addr);\r\nwb_write[1] = ONCHIP_ADDR2(addr);\r\nREG_WR_DMAE(bp, reg, wb_write, 2);\r\n}\r\nvoid bnx2x_igu_clear_sb_gen(struct bnx2x *bp, u8 func, u8 idu_sb_id, bool is_pf)\r\n{\r\nu32 data, ctl, cnt = 100;\r\nu32 igu_addr_data = IGU_REG_COMMAND_REG_32LSB_DATA;\r\nu32 igu_addr_ctl = IGU_REG_COMMAND_REG_CTRL;\r\nu32 igu_addr_ack = IGU_REG_CSTORM_TYPE_0_SB_CLEANUP + (idu_sb_id/32)*4;\r\nu32 sb_bit = 1 << (idu_sb_id%32);\r\nu32 func_encode = func | (is_pf ? 1 : 0) << IGU_FID_ENCODE_IS_PF_SHIFT;\r\nu32 addr_encode = IGU_CMD_E2_PROD_UPD_BASE + idu_sb_id;\r\nif (CHIP_INT_MODE_IS_BC(bp))\r\nreturn;\r\ndata = (IGU_USE_REGISTER_cstorm_type_0_sb_cleanup\r\n<< IGU_REGULAR_CLEANUP_TYPE_SHIFT) |\r\nIGU_REGULAR_CLEANUP_SET |\r\nIGU_REGULAR_BCLEANUP;\r\nctl = addr_encode << IGU_CTRL_REG_ADDRESS_SHIFT |\r\nfunc_encode << IGU_CTRL_REG_FID_SHIFT |\r\nIGU_CTRL_CMD_TYPE_WR << IGU_CTRL_REG_TYPE_SHIFT;\r\nDP(NETIF_MSG_HW, "write 0x%08x to IGU(via GRC) addr 0x%x\n",\r\ndata, igu_addr_data);\r\nREG_WR(bp, igu_addr_data, data);\r\nmmiowb();\r\nbarrier();\r\nDP(NETIF_MSG_HW, "write 0x%08x to IGU(via GRC) addr 0x%x\n",\r\nctl, igu_addr_ctl);\r\nREG_WR(bp, igu_addr_ctl, ctl);\r\nmmiowb();\r\nbarrier();\r\nwhile (!(REG_RD(bp, igu_addr_ack) & sb_bit) && --cnt)\r\nmsleep(20);\r\nif (!(REG_RD(bp, igu_addr_ack) & sb_bit)) {\r\nDP(NETIF_MSG_HW,\r\n"Unable to finish IGU cleanup: idu_sb_id %d offset %d bit %d (cnt %d)\n",\r\nidu_sb_id, idu_sb_id/32, idu_sb_id%32, cnt);\r\n}\r\n}\r\nstatic void bnx2x_igu_clear_sb(struct bnx2x *bp, u8 idu_sb_id)\r\n{\r\nbnx2x_igu_clear_sb_gen(bp, BP_FUNC(bp), idu_sb_id, true );\r\n}\r\nstatic void bnx2x_clear_func_ilt(struct bnx2x *bp, u32 func)\r\n{\r\nu32 i, base = FUNC_ILT_BASE(func);\r\nfor (i = base; i < base + ILT_PER_FUNC; i++)\r\nbnx2x_ilt_wr(bp, i, 0);\r\n}\r\nstatic void bnx2x_init_searcher(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nbnx2x_src_init_t2(bp, bp->t2, bp->t2_mapping, SRC_CONN_NUM);\r\nREG_WR(bp, SRC_REG_NUMBER_HASH_BITS0 + port*4, SRC_HASH_BITS);\r\n}\r\nstatic inline int bnx2x_func_switch_update(struct bnx2x *bp, int suspend)\r\n{\r\nint rc;\r\nstruct bnx2x_func_state_params func_params = {NULL};\r\nstruct bnx2x_func_switch_update_params *switch_update_params =\r\n&func_params.params.switch_update;\r\n__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\r\n__set_bit(RAMROD_RETRY, &func_params.ramrod_flags);\r\nfunc_params.f_obj = &bp->func_obj;\r\nfunc_params.cmd = BNX2X_F_CMD_SWITCH_UPDATE;\r\n__set_bit(BNX2X_F_UPDATE_TX_SWITCH_SUSPEND_CHNG,\r\n&switch_update_params->changes);\r\nif (suspend)\r\n__set_bit(BNX2X_F_UPDATE_TX_SWITCH_SUSPEND,\r\n&switch_update_params->changes);\r\nrc = bnx2x_func_state_change(bp, &func_params);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_reset_nic_mode(struct bnx2x *bp)\r\n{\r\nint rc, i, port = BP_PORT(bp);\r\nint vlan_en = 0, mac_en[NUM_MACS];\r\nif (bp->mf_mode == SINGLE_FUNCTION) {\r\nbnx2x_set_rx_filter(&bp->link_params, 0);\r\n} else {\r\nvlan_en = REG_RD(bp, port ? NIG_REG_LLH1_FUNC_EN :\r\nNIG_REG_LLH0_FUNC_EN);\r\nREG_WR(bp, port ? NIG_REG_LLH1_FUNC_EN :\r\nNIG_REG_LLH0_FUNC_EN, 0);\r\nfor (i = 0; i < NUM_MACS; i++) {\r\nmac_en[i] = REG_RD(bp, port ?\r\n(NIG_REG_LLH1_FUNC_MEM_ENABLE +\r\n4 * i) :\r\n(NIG_REG_LLH0_FUNC_MEM_ENABLE +\r\n4 * i));\r\nREG_WR(bp, port ? (NIG_REG_LLH1_FUNC_MEM_ENABLE +\r\n4 * i) :\r\n(NIG_REG_LLH0_FUNC_MEM_ENABLE + 4 * i), 0);\r\n}\r\n}\r\nREG_WR(bp, port ? NIG_REG_P0_TX_MNG_HOST_ENABLE :\r\nNIG_REG_P1_TX_MNG_HOST_ENABLE, 0);\r\nrc = bnx2x_func_switch_update(bp, 1);\r\nif (rc) {\r\nBNX2X_ERR("Can't suspend tx-switching!\n");\r\nreturn rc;\r\n}\r\nREG_WR(bp, PRS_REG_NIC_MODE, 0);\r\nif (bp->mf_mode == SINGLE_FUNCTION) {\r\nbnx2x_set_rx_filter(&bp->link_params, 1);\r\n} else {\r\nREG_WR(bp, port ? NIG_REG_LLH1_FUNC_EN :\r\nNIG_REG_LLH0_FUNC_EN, vlan_en);\r\nfor (i = 0; i < NUM_MACS; i++) {\r\nREG_WR(bp, port ? (NIG_REG_LLH1_FUNC_MEM_ENABLE +\r\n4 * i) :\r\n(NIG_REG_LLH0_FUNC_MEM_ENABLE + 4 * i),\r\nmac_en[i]);\r\n}\r\n}\r\nREG_WR(bp, port ? NIG_REG_P0_TX_MNG_HOST_ENABLE :\r\nNIG_REG_P1_TX_MNG_HOST_ENABLE, 1);\r\nrc = bnx2x_func_switch_update(bp, 0);\r\nif (rc) {\r\nBNX2X_ERR("Can't resume tx-switching!\n");\r\nreturn rc;\r\n}\r\nDP(NETIF_MSG_IFUP, "NIC MODE disabled\n");\r\nreturn 0;\r\n}\r\nint bnx2x_init_hw_func_cnic(struct bnx2x *bp)\r\n{\r\nint rc;\r\nbnx2x_ilt_init_op_cnic(bp, INITOP_SET);\r\nif (CONFIGURE_NIC_MODE(bp)) {\r\nbnx2x_init_searcher(bp);\r\nrc = bnx2x_reset_nic_mode(bp);\r\nif (rc)\r\nBNX2X_ERR("Can't change NIC mode!\n");\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_clean_pglue_errors(struct bnx2x *bp)\r\n{\r\nif (!CHIP_IS_E1x(bp))\r\nREG_WR(bp, PGLUE_B_REG_WAS_ERROR_PF_7_0_CLR,\r\n1 << BP_ABS_FUNC(bp));\r\n}\r\nstatic int bnx2x_init_hw_func(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nint func = BP_FUNC(bp);\r\nint init_phase = PHASE_PF0 + func;\r\nstruct bnx2x_ilt *ilt = BP_ILT(bp);\r\nu16 cdu_ilt_start;\r\nu32 addr, val;\r\nu32 main_mem_base, main_mem_size, main_mem_prty_clr;\r\nint i, main_mem_width, rc;\r\nDP(NETIF_MSG_HW, "starting func init func %d\n", func);\r\nif (!CHIP_IS_E1x(bp)) {\r\nrc = bnx2x_pf_flr_clnup(bp);\r\nif (rc) {\r\nbnx2x_fw_dump(bp);\r\nreturn rc;\r\n}\r\n}\r\nif (bp->common.int_block == INT_BLOCK_HC) {\r\naddr = (port ? HC_REG_CONFIG_1 : HC_REG_CONFIG_0);\r\nval = REG_RD(bp, addr);\r\nval |= HC_CONFIG_0_REG_MSI_ATTN_EN_0;\r\nREG_WR(bp, addr, val);\r\n}\r\nbnx2x_init_block(bp, BLOCK_PXP, init_phase);\r\nbnx2x_init_block(bp, BLOCK_PXP2, init_phase);\r\nilt = BP_ILT(bp);\r\ncdu_ilt_start = ilt->clients[ILT_CLIENT_CDU].start;\r\nif (IS_SRIOV(bp))\r\ncdu_ilt_start += BNX2X_FIRST_VF_CID/ILT_PAGE_CIDS;\r\ncdu_ilt_start = bnx2x_iov_init_ilt(bp, cdu_ilt_start);\r\ncdu_ilt_start = ilt->clients[ILT_CLIENT_CDU].start;\r\nfor (i = 0; i < L2_ILT_LINES(bp); i++) {\r\nilt->lines[cdu_ilt_start + i].page = bp->context[i].vcxt;\r\nilt->lines[cdu_ilt_start + i].page_mapping =\r\nbp->context[i].cxt_mapping;\r\nilt->lines[cdu_ilt_start + i].size = bp->context[i].size;\r\n}\r\nbnx2x_ilt_init_op(bp, INITOP_SET);\r\nif (!CONFIGURE_NIC_MODE(bp)) {\r\nbnx2x_init_searcher(bp);\r\nREG_WR(bp, PRS_REG_NIC_MODE, 0);\r\nDP(NETIF_MSG_IFUP, "NIC MODE disabled\n");\r\n} else {\r\nREG_WR(bp, PRS_REG_NIC_MODE, 1);\r\nDP(NETIF_MSG_IFUP, "NIC MODE configured\n");\r\n}\r\nif (!CHIP_IS_E1x(bp)) {\r\nu32 pf_conf = IGU_PF_CONF_FUNC_EN;\r\nif (!(bp->flags & USING_MSIX_FLAG))\r\npf_conf |= IGU_PF_CONF_SINGLE_ISR_EN;\r\nmsleep(20);\r\nREG_WR(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER, 1);\r\nREG_WR(bp, IGU_REG_PF_CONFIGURATION, pf_conf);\r\n}\r\nbp->dmae_ready = 1;\r\nbnx2x_init_block(bp, BLOCK_PGLUE_B, init_phase);\r\nbnx2x_clean_pglue_errors(bp);\r\nbnx2x_init_block(bp, BLOCK_ATC, init_phase);\r\nbnx2x_init_block(bp, BLOCK_DMAE, init_phase);\r\nbnx2x_init_block(bp, BLOCK_NIG, init_phase);\r\nbnx2x_init_block(bp, BLOCK_SRC, init_phase);\r\nbnx2x_init_block(bp, BLOCK_MISC, init_phase);\r\nbnx2x_init_block(bp, BLOCK_TCM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_UCM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_CCM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_XCM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_TSEM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_USEM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_CSEM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_XSEM, init_phase);\r\nif (!CHIP_IS_E1x(bp))\r\nREG_WR(bp, QM_REG_PF_EN, 1);\r\nif (!CHIP_IS_E1x(bp)) {\r\nREG_WR(bp, TSEM_REG_VFPF_ERR_NUM, BNX2X_MAX_NUM_OF_VFS + func);\r\nREG_WR(bp, USEM_REG_VFPF_ERR_NUM, BNX2X_MAX_NUM_OF_VFS + func);\r\nREG_WR(bp, CSEM_REG_VFPF_ERR_NUM, BNX2X_MAX_NUM_OF_VFS + func);\r\nREG_WR(bp, XSEM_REG_VFPF_ERR_NUM, BNX2X_MAX_NUM_OF_VFS + func);\r\n}\r\nbnx2x_init_block(bp, BLOCK_QM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_TM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_DORQ, init_phase);\r\nREG_WR(bp, DORQ_REG_MODE_ACT, 1);\r\nbnx2x_iov_init_dq(bp);\r\nbnx2x_init_block(bp, BLOCK_BRB1, init_phase);\r\nbnx2x_init_block(bp, BLOCK_PRS, init_phase);\r\nbnx2x_init_block(bp, BLOCK_TSDM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_CSDM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_USDM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_XSDM, init_phase);\r\nbnx2x_init_block(bp, BLOCK_UPB, init_phase);\r\nbnx2x_init_block(bp, BLOCK_XPB, init_phase);\r\nbnx2x_init_block(bp, BLOCK_PBF, init_phase);\r\nif (!CHIP_IS_E1x(bp))\r\nREG_WR(bp, PBF_REG_DISABLE_PF, 0);\r\nbnx2x_init_block(bp, BLOCK_CDU, init_phase);\r\nbnx2x_init_block(bp, BLOCK_CFC, init_phase);\r\nif (!CHIP_IS_E1x(bp))\r\nREG_WR(bp, CFC_REG_WEAK_ENABLE_PF, 1);\r\nif (IS_MF(bp)) {\r\nif (!(IS_MF_UFP(bp) && BNX2X_IS_MF_SD_PROTOCOL_FCOE(bp))) {\r\nREG_WR(bp, NIG_REG_LLH0_FUNC_EN + port * 8, 1);\r\nREG_WR(bp, NIG_REG_LLH0_FUNC_VLAN_ID + port * 8,\r\nbp->mf_ov);\r\n}\r\n}\r\nbnx2x_init_block(bp, BLOCK_MISC_AEU, init_phase);\r\nif (bp->common.int_block == INT_BLOCK_HC) {\r\nif (CHIP_IS_E1H(bp)) {\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_12 + func*4, 0);\r\nREG_WR(bp, HC_REG_LEADING_EDGE_0 + port*8, 0);\r\nREG_WR(bp, HC_REG_TRAILING_EDGE_0 + port*8, 0);\r\n}\r\nbnx2x_init_block(bp, BLOCK_HC, init_phase);\r\n} else {\r\nint num_segs, sb_idx, prod_offset;\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_12 + func*4, 0);\r\nif (!CHIP_IS_E1x(bp)) {\r\nREG_WR(bp, IGU_REG_LEADING_EDGE_LATCH, 0);\r\nREG_WR(bp, IGU_REG_TRAILING_EDGE_LATCH, 0);\r\n}\r\nbnx2x_init_block(bp, BLOCK_IGU, init_phase);\r\nif (!CHIP_IS_E1x(bp)) {\r\nint dsb_idx = 0;\r\nnum_segs = CHIP_INT_MODE_IS_BC(bp) ?\r\nIGU_BC_NDSB_NUM_SEGS : IGU_NORM_NDSB_NUM_SEGS;\r\nfor (sb_idx = 0; sb_idx < bp->igu_sb_cnt; sb_idx++) {\r\nprod_offset = (bp->igu_base_sb + sb_idx) *\r\nnum_segs;\r\nfor (i = 0; i < num_segs; i++) {\r\naddr = IGU_REG_PROD_CONS_MEMORY +\r\n(prod_offset + i) * 4;\r\nREG_WR(bp, addr, 0);\r\n}\r\nbnx2x_ack_sb(bp, bp->igu_base_sb + sb_idx,\r\nUSTORM_ID, 0, IGU_INT_NOP, 1);\r\nbnx2x_igu_clear_sb(bp,\r\nbp->igu_base_sb + sb_idx);\r\n}\r\nnum_segs = CHIP_INT_MODE_IS_BC(bp) ?\r\nIGU_BC_DSB_NUM_SEGS : IGU_NORM_DSB_NUM_SEGS;\r\nif (CHIP_MODE_IS_4_PORT(bp))\r\ndsb_idx = BP_FUNC(bp);\r\nelse\r\ndsb_idx = BP_VN(bp);\r\nprod_offset = (CHIP_INT_MODE_IS_BC(bp) ?\r\nIGU_BC_BASE_DSB_PROD + dsb_idx :\r\nIGU_NORM_BASE_DSB_PROD + dsb_idx);\r\nfor (i = 0; i < (num_segs * E1HVN_MAX);\r\ni += E1HVN_MAX) {\r\naddr = IGU_REG_PROD_CONS_MEMORY +\r\n(prod_offset + i)*4;\r\nREG_WR(bp, addr, 0);\r\n}\r\nif (CHIP_INT_MODE_IS_BC(bp)) {\r\nbnx2x_ack_sb(bp, bp->igu_dsb_id,\r\nUSTORM_ID, 0, IGU_INT_NOP, 1);\r\nbnx2x_ack_sb(bp, bp->igu_dsb_id,\r\nCSTORM_ID, 0, IGU_INT_NOP, 1);\r\nbnx2x_ack_sb(bp, bp->igu_dsb_id,\r\nXSTORM_ID, 0, IGU_INT_NOP, 1);\r\nbnx2x_ack_sb(bp, bp->igu_dsb_id,\r\nTSTORM_ID, 0, IGU_INT_NOP, 1);\r\nbnx2x_ack_sb(bp, bp->igu_dsb_id,\r\nATTENTION_ID, 0, IGU_INT_NOP, 1);\r\n} else {\r\nbnx2x_ack_sb(bp, bp->igu_dsb_id,\r\nUSTORM_ID, 0, IGU_INT_NOP, 1);\r\nbnx2x_ack_sb(bp, bp->igu_dsb_id,\r\nATTENTION_ID, 0, IGU_INT_NOP, 1);\r\n}\r\nbnx2x_igu_clear_sb(bp, bp->igu_dsb_id);\r\nREG_WR(bp, IGU_REG_SB_INT_BEFORE_MASK_LSB, 0);\r\nREG_WR(bp, IGU_REG_SB_INT_BEFORE_MASK_MSB, 0);\r\nREG_WR(bp, IGU_REG_SB_MASK_LSB, 0);\r\nREG_WR(bp, IGU_REG_SB_MASK_MSB, 0);\r\nREG_WR(bp, IGU_REG_PBA_STATUS_LSB, 0);\r\nREG_WR(bp, IGU_REG_PBA_STATUS_MSB, 0);\r\n}\r\n}\r\nREG_WR(bp, 0x2114, 0xffffffff);\r\nREG_WR(bp, 0x2120, 0xffffffff);\r\nif (CHIP_IS_E1x(bp)) {\r\nmain_mem_size = HC_REG_MAIN_MEMORY_SIZE / 2;\r\nmain_mem_base = HC_REG_MAIN_MEMORY +\r\nBP_PORT(bp) * (main_mem_size * 4);\r\nmain_mem_prty_clr = HC_REG_HC_PRTY_STS_CLR;\r\nmain_mem_width = 8;\r\nval = REG_RD(bp, main_mem_prty_clr);\r\nif (val)\r\nDP(NETIF_MSG_HW,\r\n"Hmmm... Parity errors in HC block during function init (0x%x)!\n",\r\nval);\r\nfor (i = main_mem_base;\r\ni < main_mem_base + main_mem_size * 4;\r\ni += main_mem_width) {\r\nbnx2x_read_dmae(bp, i, main_mem_width / 4);\r\nbnx2x_write_dmae(bp, bnx2x_sp_mapping(bp, wb_data),\r\ni, main_mem_width / 4);\r\n}\r\nREG_RD(bp, main_mem_prty_clr);\r\n}\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nREG_WR8(bp, BAR_USTRORM_INTMEM +\r\nUSTORM_RECORD_SLOW_PATH_OFFSET(BP_FUNC(bp)), 1);\r\nREG_WR8(bp, BAR_TSTRORM_INTMEM +\r\nTSTORM_RECORD_SLOW_PATH_OFFSET(BP_FUNC(bp)), 1);\r\nREG_WR8(bp, BAR_CSTRORM_INTMEM +\r\nCSTORM_RECORD_SLOW_PATH_OFFSET(BP_FUNC(bp)), 1);\r\nREG_WR8(bp, BAR_XSTRORM_INTMEM +\r\nXSTORM_RECORD_SLOW_PATH_OFFSET(BP_FUNC(bp)), 1);\r\n#endif\r\nbnx2x_phy_probe(&bp->link_params);\r\nreturn 0;\r\n}\r\nvoid bnx2x_free_mem_cnic(struct bnx2x *bp)\r\n{\r\nbnx2x_ilt_mem_op_cnic(bp, ILT_MEMOP_FREE);\r\nif (!CHIP_IS_E1x(bp))\r\nBNX2X_PCI_FREE(bp->cnic_sb.e2_sb, bp->cnic_sb_mapping,\r\nsizeof(struct host_hc_status_block_e2));\r\nelse\r\nBNX2X_PCI_FREE(bp->cnic_sb.e1x_sb, bp->cnic_sb_mapping,\r\nsizeof(struct host_hc_status_block_e1x));\r\nBNX2X_PCI_FREE(bp->t2, bp->t2_mapping, SRC_T2_SZ);\r\n}\r\nvoid bnx2x_free_mem(struct bnx2x *bp)\r\n{\r\nint i;\r\nBNX2X_PCI_FREE(bp->fw_stats, bp->fw_stats_mapping,\r\nbp->fw_stats_data_sz + bp->fw_stats_req_sz);\r\nif (IS_VF(bp))\r\nreturn;\r\nBNX2X_PCI_FREE(bp->def_status_blk, bp->def_status_blk_mapping,\r\nsizeof(struct host_sp_status_block));\r\nBNX2X_PCI_FREE(bp->slowpath, bp->slowpath_mapping,\r\nsizeof(struct bnx2x_slowpath));\r\nfor (i = 0; i < L2_ILT_LINES(bp); i++)\r\nBNX2X_PCI_FREE(bp->context[i].vcxt, bp->context[i].cxt_mapping,\r\nbp->context[i].size);\r\nbnx2x_ilt_mem_op(bp, ILT_MEMOP_FREE);\r\nBNX2X_FREE(bp->ilt->lines);\r\nBNX2X_PCI_FREE(bp->spq, bp->spq_mapping, BCM_PAGE_SIZE);\r\nBNX2X_PCI_FREE(bp->eq_ring, bp->eq_mapping,\r\nBCM_PAGE_SIZE * NUM_EQ_PAGES);\r\nBNX2X_PCI_FREE(bp->t2, bp->t2_mapping, SRC_T2_SZ);\r\nbnx2x_iov_free_mem(bp);\r\n}\r\nint bnx2x_alloc_mem_cnic(struct bnx2x *bp)\r\n{\r\nif (!CHIP_IS_E1x(bp)) {\r\nbp->cnic_sb.e2_sb = BNX2X_PCI_ALLOC(&bp->cnic_sb_mapping,\r\nsizeof(struct host_hc_status_block_e2));\r\nif (!bp->cnic_sb.e2_sb)\r\ngoto alloc_mem_err;\r\n} else {\r\nbp->cnic_sb.e1x_sb = BNX2X_PCI_ALLOC(&bp->cnic_sb_mapping,\r\nsizeof(struct host_hc_status_block_e1x));\r\nif (!bp->cnic_sb.e1x_sb)\r\ngoto alloc_mem_err;\r\n}\r\nif (CONFIGURE_NIC_MODE(bp) && !bp->t2) {\r\nbp->t2 = BNX2X_PCI_ALLOC(&bp->t2_mapping, SRC_T2_SZ);\r\nif (!bp->t2)\r\ngoto alloc_mem_err;\r\n}\r\nbp->cnic_eth_dev.addr_drv_info_to_mcp =\r\n&bp->slowpath->drv_info_to_mcp;\r\nif (bnx2x_ilt_mem_op_cnic(bp, ILT_MEMOP_ALLOC))\r\ngoto alloc_mem_err;\r\nreturn 0;\r\nalloc_mem_err:\r\nbnx2x_free_mem_cnic(bp);\r\nBNX2X_ERR("Can't allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nint bnx2x_alloc_mem(struct bnx2x *bp)\r\n{\r\nint i, allocated, context_size;\r\nif (!CONFIGURE_NIC_MODE(bp) && !bp->t2) {\r\nbp->t2 = BNX2X_PCI_ALLOC(&bp->t2_mapping, SRC_T2_SZ);\r\nif (!bp->t2)\r\ngoto alloc_mem_err;\r\n}\r\nbp->def_status_blk = BNX2X_PCI_ALLOC(&bp->def_status_blk_mapping,\r\nsizeof(struct host_sp_status_block));\r\nif (!bp->def_status_blk)\r\ngoto alloc_mem_err;\r\nbp->slowpath = BNX2X_PCI_ALLOC(&bp->slowpath_mapping,\r\nsizeof(struct bnx2x_slowpath));\r\nif (!bp->slowpath)\r\ngoto alloc_mem_err;\r\ncontext_size = sizeof(union cdu_context) * BNX2X_L2_CID_COUNT(bp);\r\nfor (i = 0, allocated = 0; allocated < context_size; i++) {\r\nbp->context[i].size = min(CDU_ILT_PAGE_SZ,\r\n(context_size - allocated));\r\nbp->context[i].vcxt = BNX2X_PCI_ALLOC(&bp->context[i].cxt_mapping,\r\nbp->context[i].size);\r\nif (!bp->context[i].vcxt)\r\ngoto alloc_mem_err;\r\nallocated += bp->context[i].size;\r\n}\r\nbp->ilt->lines = kcalloc(ILT_MAX_LINES, sizeof(struct ilt_line),\r\nGFP_KERNEL);\r\nif (!bp->ilt->lines)\r\ngoto alloc_mem_err;\r\nif (bnx2x_ilt_mem_op(bp, ILT_MEMOP_ALLOC))\r\ngoto alloc_mem_err;\r\nif (bnx2x_iov_alloc_mem(bp))\r\ngoto alloc_mem_err;\r\nbp->spq = BNX2X_PCI_ALLOC(&bp->spq_mapping, BCM_PAGE_SIZE);\r\nif (!bp->spq)\r\ngoto alloc_mem_err;\r\nbp->eq_ring = BNX2X_PCI_ALLOC(&bp->eq_mapping,\r\nBCM_PAGE_SIZE * NUM_EQ_PAGES);\r\nif (!bp->eq_ring)\r\ngoto alloc_mem_err;\r\nreturn 0;\r\nalloc_mem_err:\r\nbnx2x_free_mem(bp);\r\nBNX2X_ERR("Can't allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nint bnx2x_set_mac_one(struct bnx2x *bp, u8 *mac,\r\nstruct bnx2x_vlan_mac_obj *obj, bool set,\r\nint mac_type, unsigned long *ramrod_flags)\r\n{\r\nint rc;\r\nstruct bnx2x_vlan_mac_ramrod_params ramrod_param;\r\nmemset(&ramrod_param, 0, sizeof(ramrod_param));\r\nramrod_param.vlan_mac_obj = obj;\r\nramrod_param.ramrod_flags = *ramrod_flags;\r\nif (!test_bit(RAMROD_CONT, ramrod_flags)) {\r\nmemcpy(ramrod_param.user_req.u.mac.mac, mac, ETH_ALEN);\r\n__set_bit(mac_type, &ramrod_param.user_req.vlan_mac_flags);\r\nif (set)\r\nramrod_param.user_req.cmd = BNX2X_VLAN_MAC_ADD;\r\nelse\r\nramrod_param.user_req.cmd = BNX2X_VLAN_MAC_DEL;\r\n}\r\nrc = bnx2x_config_vlan_mac(bp, &ramrod_param);\r\nif (rc == -EEXIST) {\r\nDP(BNX2X_MSG_SP, "Failed to schedule ADD operations: %d\n", rc);\r\nrc = 0;\r\n} else if (rc < 0)\r\nBNX2X_ERR("%s MAC failed\n", (set ? "Set" : "Del"));\r\nreturn rc;\r\n}\r\nint bnx2x_set_vlan_one(struct bnx2x *bp, u16 vlan,\r\nstruct bnx2x_vlan_mac_obj *obj, bool set,\r\nunsigned long *ramrod_flags)\r\n{\r\nint rc;\r\nstruct bnx2x_vlan_mac_ramrod_params ramrod_param;\r\nmemset(&ramrod_param, 0, sizeof(ramrod_param));\r\nramrod_param.vlan_mac_obj = obj;\r\nramrod_param.ramrod_flags = *ramrod_flags;\r\nif (!test_bit(RAMROD_CONT, ramrod_flags)) {\r\nramrod_param.user_req.u.vlan.vlan = vlan;\r\nif (set)\r\nramrod_param.user_req.cmd = BNX2X_VLAN_MAC_ADD;\r\nelse\r\nramrod_param.user_req.cmd = BNX2X_VLAN_MAC_DEL;\r\n}\r\nrc = bnx2x_config_vlan_mac(bp, &ramrod_param);\r\nif (rc == -EEXIST) {\r\nDP(BNX2X_MSG_SP, "Failed to schedule ADD operations: %d\n", rc);\r\nrc = 0;\r\n} else if (rc < 0) {\r\nBNX2X_ERR("%s VLAN failed\n", (set ? "Set" : "Del"));\r\n}\r\nreturn rc;\r\n}\r\nint bnx2x_del_all_macs(struct bnx2x *bp,\r\nstruct bnx2x_vlan_mac_obj *mac_obj,\r\nint mac_type, bool wait_for_comp)\r\n{\r\nint rc;\r\nunsigned long ramrod_flags = 0, vlan_mac_flags = 0;\r\nif (wait_for_comp)\r\n__set_bit(RAMROD_COMP_WAIT, &ramrod_flags);\r\n__set_bit(mac_type, &vlan_mac_flags);\r\nrc = mac_obj->delete_all(bp, mac_obj, &vlan_mac_flags, &ramrod_flags);\r\nif (rc < 0)\r\nBNX2X_ERR("Failed to delete MACs: %d\n", rc);\r\nreturn rc;\r\n}\r\nint bnx2x_set_eth_mac(struct bnx2x *bp, bool set)\r\n{\r\nif (IS_PF(bp)) {\r\nunsigned long ramrod_flags = 0;\r\nDP(NETIF_MSG_IFUP, "Adding Eth MAC\n");\r\n__set_bit(RAMROD_COMP_WAIT, &ramrod_flags);\r\nreturn bnx2x_set_mac_one(bp, bp->dev->dev_addr,\r\n&bp->sp_objs->mac_obj, set,\r\nBNX2X_ETH_MAC, &ramrod_flags);\r\n} else {\r\nreturn bnx2x_vfpf_config_mac(bp, bp->dev->dev_addr,\r\nbp->fp->index, set);\r\n}\r\n}\r\nint bnx2x_setup_leading(struct bnx2x *bp)\r\n{\r\nif (IS_PF(bp))\r\nreturn bnx2x_setup_queue(bp, &bp->fp[0], true);\r\nelse\r\nreturn bnx2x_vfpf_setup_q(bp, &bp->fp[0], true);\r\n}\r\nint bnx2x_set_int_mode(struct bnx2x *bp)\r\n{\r\nint rc = 0;\r\nif (IS_VF(bp) && int_mode != BNX2X_INT_MODE_MSIX) {\r\nBNX2X_ERR("VF not loaded since interrupt mode not msix\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (int_mode) {\r\ncase BNX2X_INT_MODE_MSIX:\r\nrc = bnx2x_enable_msix(bp);\r\nif (!rc)\r\nreturn 0;\r\nif (rc && IS_VF(bp))\r\nreturn rc;\r\nBNX2X_DEV_INFO("Failed to enable multiple MSI-X (%d), set number of queues to %d\n",\r\nbp->num_queues,\r\n1 + bp->num_cnic_queues);\r\ncase BNX2X_INT_MODE_MSI:\r\nbnx2x_enable_msi(bp);\r\ncase BNX2X_INT_MODE_INTX:\r\nbp->num_ethernet_queues = 1;\r\nbp->num_queues = bp->num_ethernet_queues + bp->num_cnic_queues;\r\nBNX2X_DEV_INFO("set number of queues to 1\n");\r\nbreak;\r\ndefault:\r\nBNX2X_DEV_INFO("unknown value in int_mode module parameter\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u16 bnx2x_cid_ilt_lines(struct bnx2x *bp)\r\n{\r\nif (IS_SRIOV(bp))\r\nreturn (BNX2X_FIRST_VF_CID + BNX2X_VF_CIDS)/ILT_PAGE_CIDS;\r\nreturn L2_ILT_LINES(bp);\r\n}\r\nvoid bnx2x_ilt_set_info(struct bnx2x *bp)\r\n{\r\nstruct ilt_client_info *ilt_client;\r\nstruct bnx2x_ilt *ilt = BP_ILT(bp);\r\nu16 line = 0;\r\nilt->start_line = FUNC_ILT_BASE(BP_FUNC(bp));\r\nDP(BNX2X_MSG_SP, "ilt starts at line %d\n", ilt->start_line);\r\nilt_client = &ilt->clients[ILT_CLIENT_CDU];\r\nilt_client->client_num = ILT_CLIENT_CDU;\r\nilt_client->page_size = CDU_ILT_PAGE_SZ;\r\nilt_client->flags = ILT_CLIENT_SKIP_MEM;\r\nilt_client->start = line;\r\nline += bnx2x_cid_ilt_lines(bp);\r\nif (CNIC_SUPPORT(bp))\r\nline += CNIC_ILT_LINES;\r\nilt_client->end = line - 1;\r\nDP(NETIF_MSG_IFUP, "ilt client[CDU]: start %d, end %d, psz 0x%x, flags 0x%x, hw psz %d\n",\r\nilt_client->start,\r\nilt_client->end,\r\nilt_client->page_size,\r\nilt_client->flags,\r\nilog2(ilt_client->page_size >> 12));\r\nif (QM_INIT(bp->qm_cid_count)) {\r\nilt_client = &ilt->clients[ILT_CLIENT_QM];\r\nilt_client->client_num = ILT_CLIENT_QM;\r\nilt_client->page_size = QM_ILT_PAGE_SZ;\r\nilt_client->flags = 0;\r\nilt_client->start = line;\r\nline += DIV_ROUND_UP(bp->qm_cid_count * QM_QUEUES_PER_FUNC * 4,\r\nQM_ILT_PAGE_SZ);\r\nilt_client->end = line - 1;\r\nDP(NETIF_MSG_IFUP,\r\n"ilt client[QM]: start %d, end %d, psz 0x%x, flags 0x%x, hw psz %d\n",\r\nilt_client->start,\r\nilt_client->end,\r\nilt_client->page_size,\r\nilt_client->flags,\r\nilog2(ilt_client->page_size >> 12));\r\n}\r\nif (CNIC_SUPPORT(bp)) {\r\nilt_client = &ilt->clients[ILT_CLIENT_SRC];\r\nilt_client->client_num = ILT_CLIENT_SRC;\r\nilt_client->page_size = SRC_ILT_PAGE_SZ;\r\nilt_client->flags = 0;\r\nilt_client->start = line;\r\nline += SRC_ILT_LINES;\r\nilt_client->end = line - 1;\r\nDP(NETIF_MSG_IFUP,\r\n"ilt client[SRC]: start %d, end %d, psz 0x%x, flags 0x%x, hw psz %d\n",\r\nilt_client->start,\r\nilt_client->end,\r\nilt_client->page_size,\r\nilt_client->flags,\r\nilog2(ilt_client->page_size >> 12));\r\nilt_client = &ilt->clients[ILT_CLIENT_TM];\r\nilt_client->client_num = ILT_CLIENT_TM;\r\nilt_client->page_size = TM_ILT_PAGE_SZ;\r\nilt_client->flags = 0;\r\nilt_client->start = line;\r\nline += TM_ILT_LINES;\r\nilt_client->end = line - 1;\r\nDP(NETIF_MSG_IFUP,\r\n"ilt client[TM]: start %d, end %d, psz 0x%x, flags 0x%x, hw psz %d\n",\r\nilt_client->start,\r\nilt_client->end,\r\nilt_client->page_size,\r\nilt_client->flags,\r\nilog2(ilt_client->page_size >> 12));\r\n}\r\nBUG_ON(line > ILT_MAX_LINES);\r\n}\r\nstatic void bnx2x_pf_q_prep_init(struct bnx2x *bp,\r\nstruct bnx2x_fastpath *fp, struct bnx2x_queue_init_params *init_params)\r\n{\r\nu8 cos;\r\nint cxt_index, cxt_offset;\r\nif (!IS_FCOE_FP(fp)) {\r\n__set_bit(BNX2X_Q_FLG_HC, &init_params->rx.flags);\r\n__set_bit(BNX2X_Q_FLG_HC, &init_params->tx.flags);\r\n__set_bit(BNX2X_Q_FLG_HC_EN, &init_params->rx.flags);\r\n__set_bit(BNX2X_Q_FLG_HC_EN, &init_params->tx.flags);\r\ninit_params->rx.hc_rate = bp->rx_ticks ?\r\n(1000000 / bp->rx_ticks) : 0;\r\ninit_params->tx.hc_rate = bp->tx_ticks ?\r\n(1000000 / bp->tx_ticks) : 0;\r\ninit_params->rx.fw_sb_id = init_params->tx.fw_sb_id =\r\nfp->fw_sb_id;\r\ninit_params->rx.sb_cq_index = HC_INDEX_ETH_RX_CQ_CONS;\r\ninit_params->tx.sb_cq_index = HC_INDEX_ETH_FIRST_TX_CQ_CONS;\r\n}\r\ninit_params->max_cos = fp->max_cos;\r\nDP(NETIF_MSG_IFUP, "fp: %d setting queue params max cos to: %d\n",\r\nfp->index, init_params->max_cos);\r\nfor (cos = FIRST_TX_COS_INDEX; cos < init_params->max_cos; cos++) {\r\ncxt_index = fp->txdata_ptr[cos]->cid / ILT_PAGE_CIDS;\r\ncxt_offset = fp->txdata_ptr[cos]->cid - (cxt_index *\r\nILT_PAGE_CIDS);\r\ninit_params->cxts[cos] =\r\n&bp->context[cxt_index].vcxt[cxt_offset].eth;\r\n}\r\n}\r\nstatic int bnx2x_setup_tx_only(struct bnx2x *bp, struct bnx2x_fastpath *fp,\r\nstruct bnx2x_queue_state_params *q_params,\r\nstruct bnx2x_queue_setup_tx_only_params *tx_only_params,\r\nint tx_index, bool leading)\r\n{\r\nmemset(tx_only_params, 0, sizeof(*tx_only_params));\r\nq_params->cmd = BNX2X_Q_CMD_SETUP_TX_ONLY;\r\ntx_only_params->flags = bnx2x_get_common_flags(bp, fp, false);\r\ntx_only_params->cid_index = tx_index;\r\nbnx2x_pf_q_prep_general(bp, fp, &tx_only_params->gen_params, tx_index);\r\nbnx2x_pf_tx_q_prep(bp, fp, &tx_only_params->txq_params, tx_index);\r\nDP(NETIF_MSG_IFUP,\r\n"preparing to send tx-only ramrod for connection: cos %d, primary cid %d, cid %d, client id %d, sp-client id %d, flags %lx\n",\r\ntx_index, q_params->q_obj->cids[FIRST_TX_COS_INDEX],\r\nq_params->q_obj->cids[tx_index], q_params->q_obj->cl_id,\r\ntx_only_params->gen_params.spcl_id, tx_only_params->flags);\r\nreturn bnx2x_queue_state_change(bp, q_params);\r\n}\r\nint bnx2x_setup_queue(struct bnx2x *bp, struct bnx2x_fastpath *fp,\r\nbool leading)\r\n{\r\nstruct bnx2x_queue_state_params q_params = {NULL};\r\nstruct bnx2x_queue_setup_params *setup_params =\r\n&q_params.params.setup;\r\nstruct bnx2x_queue_setup_tx_only_params *tx_only_params =\r\n&q_params.params.tx_only;\r\nint rc;\r\nu8 tx_index;\r\nDP(NETIF_MSG_IFUP, "setting up queue %d\n", fp->index);\r\nif (!IS_FCOE_FP(fp))\r\nbnx2x_ack_sb(bp, fp->igu_sb_id, USTORM_ID, 0,\r\nIGU_INT_ENABLE, 0);\r\nq_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\r\n__set_bit(RAMROD_COMP_WAIT, &q_params.ramrod_flags);\r\nbnx2x_pf_q_prep_init(bp, fp, &q_params.params.init);\r\nq_params.cmd = BNX2X_Q_CMD_INIT;\r\nrc = bnx2x_queue_state_change(bp, &q_params);\r\nif (rc) {\r\nBNX2X_ERR("Queue(%d) INIT failed\n", fp->index);\r\nreturn rc;\r\n}\r\nDP(NETIF_MSG_IFUP, "init complete\n");\r\nmemset(setup_params, 0, sizeof(*setup_params));\r\nsetup_params->flags = bnx2x_get_q_flags(bp, fp, leading);\r\nbnx2x_pf_q_prep_general(bp, fp, &setup_params->gen_params,\r\nFIRST_TX_COS_INDEX);\r\nbnx2x_pf_rx_q_prep(bp, fp, &setup_params->pause_params,\r\n&setup_params->rxq_params);\r\nbnx2x_pf_tx_q_prep(bp, fp, &setup_params->txq_params,\r\nFIRST_TX_COS_INDEX);\r\nq_params.cmd = BNX2X_Q_CMD_SETUP;\r\nif (IS_FCOE_FP(fp))\r\nbp->fcoe_init = true;\r\nrc = bnx2x_queue_state_change(bp, &q_params);\r\nif (rc) {\r\nBNX2X_ERR("Queue(%d) SETUP failed\n", fp->index);\r\nreturn rc;\r\n}\r\nfor (tx_index = FIRST_TX_ONLY_COS_INDEX;\r\ntx_index < fp->max_cos;\r\ntx_index++) {\r\nrc = bnx2x_setup_tx_only(bp, fp, &q_params,\r\ntx_only_params, tx_index, leading);\r\nif (rc) {\r\nBNX2X_ERR("Queue(%d.%d) TX_ONLY_SETUP failed\n",\r\nfp->index, tx_index);\r\nreturn rc;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int bnx2x_stop_queue(struct bnx2x *bp, int index)\r\n{\r\nstruct bnx2x_fastpath *fp = &bp->fp[index];\r\nstruct bnx2x_fp_txdata *txdata;\r\nstruct bnx2x_queue_state_params q_params = {NULL};\r\nint rc, tx_index;\r\nDP(NETIF_MSG_IFDOWN, "stopping queue %d cid %d\n", index, fp->cid);\r\nq_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\r\n__set_bit(RAMROD_COMP_WAIT, &q_params.ramrod_flags);\r\nfor (tx_index = FIRST_TX_ONLY_COS_INDEX;\r\ntx_index < fp->max_cos;\r\ntx_index++){\r\ntxdata = fp->txdata_ptr[tx_index];\r\nDP(NETIF_MSG_IFDOWN, "stopping tx-only queue %d\n",\r\ntxdata->txq_index);\r\nq_params.cmd = BNX2X_Q_CMD_TERMINATE;\r\nmemset(&q_params.params.terminate, 0,\r\nsizeof(q_params.params.terminate));\r\nq_params.params.terminate.cid_index = tx_index;\r\nrc = bnx2x_queue_state_change(bp, &q_params);\r\nif (rc)\r\nreturn rc;\r\nq_params.cmd = BNX2X_Q_CMD_CFC_DEL;\r\nmemset(&q_params.params.cfc_del, 0,\r\nsizeof(q_params.params.cfc_del));\r\nq_params.params.cfc_del.cid_index = tx_index;\r\nrc = bnx2x_queue_state_change(bp, &q_params);\r\nif (rc)\r\nreturn rc;\r\n}\r\nq_params.cmd = BNX2X_Q_CMD_HALT;\r\nrc = bnx2x_queue_state_change(bp, &q_params);\r\nif (rc)\r\nreturn rc;\r\nq_params.cmd = BNX2X_Q_CMD_TERMINATE;\r\nmemset(&q_params.params.terminate, 0,\r\nsizeof(q_params.params.terminate));\r\nq_params.params.terminate.cid_index = FIRST_TX_COS_INDEX;\r\nrc = bnx2x_queue_state_change(bp, &q_params);\r\nif (rc)\r\nreturn rc;\r\nq_params.cmd = BNX2X_Q_CMD_CFC_DEL;\r\nmemset(&q_params.params.cfc_del, 0,\r\nsizeof(q_params.params.cfc_del));\r\nq_params.params.cfc_del.cid_index = FIRST_TX_COS_INDEX;\r\nreturn bnx2x_queue_state_change(bp, &q_params);\r\n}\r\nstatic void bnx2x_reset_func(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nint func = BP_FUNC(bp);\r\nint i;\r\nREG_WR8(bp, BAR_XSTRORM_INTMEM + XSTORM_FUNC_EN_OFFSET(func), 0);\r\nREG_WR8(bp, BAR_CSTRORM_INTMEM + CSTORM_FUNC_EN_OFFSET(func), 0);\r\nREG_WR8(bp, BAR_TSTRORM_INTMEM + TSTORM_FUNC_EN_OFFSET(func), 0);\r\nREG_WR8(bp, BAR_USTRORM_INTMEM + USTORM_FUNC_EN_OFFSET(func), 0);\r\nfor_each_eth_queue(bp, i) {\r\nstruct bnx2x_fastpath *fp = &bp->fp[i];\r\nREG_WR8(bp, BAR_CSTRORM_INTMEM +\r\nCSTORM_STATUS_BLOCK_DATA_STATE_OFFSET(fp->fw_sb_id),\r\nSB_DISABLED);\r\n}\r\nif (CNIC_LOADED(bp))\r\nREG_WR8(bp, BAR_CSTRORM_INTMEM +\r\nCSTORM_STATUS_BLOCK_DATA_STATE_OFFSET\r\n(bnx2x_cnic_fw_sb_id(bp)), SB_DISABLED);\r\nREG_WR8(bp, BAR_CSTRORM_INTMEM +\r\nCSTORM_SP_STATUS_BLOCK_DATA_STATE_OFFSET(func),\r\nSB_DISABLED);\r\nfor (i = 0; i < XSTORM_SPQ_DATA_SIZE / 4; i++)\r\nREG_WR(bp, BAR_XSTRORM_INTMEM + XSTORM_SPQ_DATA_OFFSET(func),\r\n0);\r\nif (bp->common.int_block == INT_BLOCK_HC) {\r\nREG_WR(bp, HC_REG_LEADING_EDGE_0 + port*8, 0);\r\nREG_WR(bp, HC_REG_TRAILING_EDGE_0 + port*8, 0);\r\n} else {\r\nREG_WR(bp, IGU_REG_LEADING_EDGE_LATCH, 0);\r\nREG_WR(bp, IGU_REG_TRAILING_EDGE_LATCH, 0);\r\n}\r\nif (CNIC_LOADED(bp)) {\r\nREG_WR(bp, TM_REG_EN_LINEAR0_TIMER + port*4, 0);\r\nfor (i = 0; i < 200; i++) {\r\nusleep_range(10000, 20000);\r\nif (!REG_RD(bp, TM_REG_LIN0_SCAN_ON + port*4))\r\nbreak;\r\n}\r\n}\r\nbnx2x_clear_func_ilt(bp, func);\r\nif (!CHIP_IS_E1x(bp) && BP_VN(bp) == 3) {\r\nstruct ilt_client_info ilt_cli;\r\nmemset(&ilt_cli, 0, sizeof(struct ilt_client_info));\r\nilt_cli.start = 0;\r\nilt_cli.end = ILT_NUM_PAGE_ENTRIES - 1;\r\nilt_cli.client_num = ILT_CLIENT_TM;\r\nbnx2x_ilt_boundry_init_op(bp, &ilt_cli, 0, INITOP_CLEAR);\r\n}\r\nif (!CHIP_IS_E1x(bp))\r\nbnx2x_pf_disable(bp);\r\nbp->dmae_ready = 0;\r\n}\r\nstatic void bnx2x_reset_port(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nu32 val;\r\nbnx2x__link_reset(bp);\r\nREG_WR(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4, 0);\r\nREG_WR(bp, NIG_REG_LLH0_BRB1_DRV_MASK + port*4, 0x0);\r\nREG_WR(bp, (port ? NIG_REG_LLH1_BRB1_NOT_MCP :\r\nNIG_REG_LLH0_BRB1_NOT_MCP), 0x0);\r\nREG_WR(bp, MISC_REG_AEU_MASK_ATTN_FUNC_0 + port*4, 0);\r\nmsleep(100);\r\nval = REG_RD(bp, BRB1_REG_PORT_NUM_OCC_BLOCKS_0 + port*4);\r\nif (val)\r\nDP(NETIF_MSG_IFDOWN,\r\n"BRB1 is not empty %d blocks are occupied\n", val);\r\n}\r\nstatic int bnx2x_reset_hw(struct bnx2x *bp, u32 load_code)\r\n{\r\nstruct bnx2x_func_state_params func_params = {NULL};\r\n__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\r\nfunc_params.f_obj = &bp->func_obj;\r\nfunc_params.cmd = BNX2X_F_CMD_HW_RESET;\r\nfunc_params.params.hw_init.load_phase = load_code;\r\nreturn bnx2x_func_state_change(bp, &func_params);\r\n}\r\nstatic int bnx2x_func_stop(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_func_state_params func_params = {NULL};\r\nint rc;\r\n__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\r\nfunc_params.f_obj = &bp->func_obj;\r\nfunc_params.cmd = BNX2X_F_CMD_STOP;\r\nrc = bnx2x_func_state_change(bp, &func_params);\r\nif (rc) {\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nreturn rc;\r\n#else\r\nBNX2X_ERR("FUNC_STOP ramrod failed. Running a dry transaction\n");\r\n__set_bit(RAMROD_DRV_CLR_ONLY, &func_params.ramrod_flags);\r\nreturn bnx2x_func_state_change(bp, &func_params);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nu32 bnx2x_send_unload_req(struct bnx2x *bp, int unload_mode)\r\n{\r\nu32 reset_code = 0;\r\nint port = BP_PORT(bp);\r\nif (unload_mode == UNLOAD_NORMAL)\r\nreset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS;\r\nelse if (bp->flags & NO_WOL_FLAG)\r\nreset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP;\r\nelse if (bp->wol) {\r\nu32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\r\nu8 *mac_addr = bp->dev->dev_addr;\r\nstruct pci_dev *pdev = bp->pdev;\r\nu32 val;\r\nu16 pmc;\r\nu8 entry = (BP_VN(bp) + 1)*8;\r\nval = (mac_addr[0] << 8) | mac_addr[1];\r\nEMAC_WR(bp, EMAC_REG_EMAC_MAC_MATCH + entry, val);\r\nval = (mac_addr[2] << 24) | (mac_addr[3] << 16) |\r\n(mac_addr[4] << 8) | mac_addr[5];\r\nEMAC_WR(bp, EMAC_REG_EMAC_MAC_MATCH + entry + 4, val);\r\npci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &pmc);\r\npmc |= PCI_PM_CTRL_PME_ENABLE | PCI_PM_CTRL_PME_STATUS;\r\npci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, pmc);\r\nreset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_EN;\r\n} else\r\nreset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS;\r\nif (!BP_NOMCP(bp))\r\nreset_code = bnx2x_fw_command(bp, reset_code, 0);\r\nelse {\r\nint path = BP_PATH(bp);\r\nDP(NETIF_MSG_IFDOWN, "NO MCP - load counts[%d] %d, %d, %d\n",\r\npath, bnx2x_load_count[path][0], bnx2x_load_count[path][1],\r\nbnx2x_load_count[path][2]);\r\nbnx2x_load_count[path][0]--;\r\nbnx2x_load_count[path][1 + port]--;\r\nDP(NETIF_MSG_IFDOWN, "NO MCP - new load counts[%d] %d, %d, %d\n",\r\npath, bnx2x_load_count[path][0], bnx2x_load_count[path][1],\r\nbnx2x_load_count[path][2]);\r\nif (bnx2x_load_count[path][0] == 0)\r\nreset_code = FW_MSG_CODE_DRV_UNLOAD_COMMON;\r\nelse if (bnx2x_load_count[path][1 + port] == 0)\r\nreset_code = FW_MSG_CODE_DRV_UNLOAD_PORT;\r\nelse\r\nreset_code = FW_MSG_CODE_DRV_UNLOAD_FUNCTION;\r\n}\r\nreturn reset_code;\r\n}\r\nvoid bnx2x_send_unload_done(struct bnx2x *bp, bool keep_link)\r\n{\r\nu32 reset_param = keep_link ? DRV_MSG_CODE_UNLOAD_SKIP_LINK_RESET : 0;\r\nif (!BP_NOMCP(bp))\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE, reset_param);\r\n}\r\nstatic int bnx2x_func_wait_started(struct bnx2x *bp)\r\n{\r\nint tout = 50;\r\nint msix = (bp->flags & USING_MSIX_FLAG) ? 1 : 0;\r\nif (!bp->port.pmf)\r\nreturn 0;\r\nif (msix)\r\nsynchronize_irq(bp->msix_table[0].vector);\r\nelse\r\nsynchronize_irq(bp->pdev->irq);\r\nflush_workqueue(bnx2x_wq);\r\nflush_workqueue(bnx2x_iov_wq);\r\nwhile (bnx2x_func_get_state(bp, &bp->func_obj) !=\r\nBNX2X_F_STATE_STARTED && tout--)\r\nmsleep(20);\r\nif (bnx2x_func_get_state(bp, &bp->func_obj) !=\r\nBNX2X_F_STATE_STARTED) {\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nBNX2X_ERR("Wrong function state\n");\r\nreturn -EBUSY;\r\n#else\r\nstruct bnx2x_func_state_params func_params = {NULL};\r\nDP(NETIF_MSG_IFDOWN,\r\n"Hmmm... Unexpected function state! Forcing STARTED-->TX_STOPPED-->STARTED\n");\r\nfunc_params.f_obj = &bp->func_obj;\r\n__set_bit(RAMROD_DRV_CLR_ONLY,\r\n&func_params.ramrod_flags);\r\nfunc_params.cmd = BNX2X_F_CMD_TX_STOP;\r\nbnx2x_func_state_change(bp, &func_params);\r\nfunc_params.cmd = BNX2X_F_CMD_TX_START;\r\nreturn bnx2x_func_state_change(bp, &func_params);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_disable_ptp(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_TO_HOST :\r\nNIG_REG_P0_LLH_PTP_TO_HOST, 0x0);\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_PARAM_MASK :\r\nNIG_REG_P0_LLH_PTP_PARAM_MASK, 0x7FF);\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_RULE_MASK :\r\nNIG_REG_P0_LLH_PTP_RULE_MASK, 0x3FFF);\r\nREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_PARAM_MASK :\r\nNIG_REG_P0_TLLH_PTP_PARAM_MASK, 0x7FF);\r\nREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_RULE_MASK :\r\nNIG_REG_P0_TLLH_PTP_RULE_MASK, 0x3FFF);\r\nREG_WR(bp, port ? NIG_REG_P1_PTP_EN :\r\nNIG_REG_P0_PTP_EN, 0x0);\r\n}\r\nstatic void bnx2x_stop_ptp(struct bnx2x *bp)\r\n{\r\ncancel_work_sync(&bp->ptp_task);\r\nif (bp->ptp_tx_skb) {\r\ndev_kfree_skb_any(bp->ptp_tx_skb);\r\nbp->ptp_tx_skb = NULL;\r\n}\r\nbnx2x_disable_ptp(bp);\r\nDP(BNX2X_MSG_PTP, "PTP stop ended successfully\n");\r\n}\r\nvoid bnx2x_chip_cleanup(struct bnx2x *bp, int unload_mode, bool keep_link)\r\n{\r\nint port = BP_PORT(bp);\r\nint i, rc = 0;\r\nu8 cos;\r\nstruct bnx2x_mcast_ramrod_params rparam = {NULL};\r\nu32 reset_code;\r\nfor_each_tx_queue(bp, i) {\r\nstruct bnx2x_fastpath *fp = &bp->fp[i];\r\nfor_each_cos_in_tx_queue(fp, cos)\r\nrc = bnx2x_clean_tx_queue(bp, fp->txdata_ptr[cos]);\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nif (rc)\r\nreturn;\r\n#endif\r\n}\r\nusleep_range(1000, 2000);\r\nrc = bnx2x_del_all_macs(bp, &bp->sp_objs[0].mac_obj, BNX2X_ETH_MAC,\r\nfalse);\r\nif (rc < 0)\r\nBNX2X_ERR("Failed to delete all ETH macs: %d\n", rc);\r\nrc = bnx2x_del_all_macs(bp, &bp->sp_objs[0].mac_obj, BNX2X_UC_LIST_MAC,\r\ntrue);\r\nif (rc < 0)\r\nBNX2X_ERR("Failed to schedule DEL commands for UC MACs list: %d\n",\r\nrc);\r\nif (!CHIP_IS_E1(bp))\r\nREG_WR(bp, NIG_REG_LLH0_FUNC_EN + port*8, 0);\r\nnetif_addr_lock_bh(bp->dev);\r\nif (test_bit(BNX2X_FILTER_RX_MODE_PENDING, &bp->sp_state))\r\nset_bit(BNX2X_FILTER_RX_MODE_SCHED, &bp->sp_state);\r\nelse\r\nbnx2x_set_storm_rx_mode(bp);\r\nrparam.mcast_obj = &bp->mcast_obj;\r\nrc = bnx2x_config_mcast(bp, &rparam, BNX2X_MCAST_CMD_DEL);\r\nif (rc < 0)\r\nBNX2X_ERR("Failed to send DEL multicast command: %d\n", rc);\r\nnetif_addr_unlock_bh(bp->dev);\r\nbnx2x_iov_chip_cleanup(bp);\r\nreset_code = bnx2x_send_unload_req(bp, unload_mode);\r\nrc = bnx2x_func_wait_started(bp);\r\nif (rc) {\r\nBNX2X_ERR("bnx2x_func_wait_started failed\n");\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nreturn;\r\n#endif\r\n}\r\nfor_each_eth_queue(bp, i)\r\nif (bnx2x_stop_queue(bp, i))\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nreturn;\r\n#else\r\ngoto unload_error;\r\n#endif\r\nif (CNIC_LOADED(bp)) {\r\nfor_each_cnic_queue(bp, i)\r\nif (bnx2x_stop_queue(bp, i))\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nreturn;\r\n#else\r\ngoto unload_error;\r\n#endif\r\n}\r\nif (!bnx2x_wait_sp_comp(bp, ~0x0UL))\r\nBNX2X_ERR("Hmmm... Common slow path ramrods got stuck!\n");\r\n#ifndef BNX2X_STOP_ON_ERROR\r\nunload_error:\r\n#endif\r\nrc = bnx2x_func_stop(bp);\r\nif (rc) {\r\nBNX2X_ERR("Function stop failed!\n");\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nreturn;\r\n#endif\r\n}\r\nif (bp->flags & PTP_SUPPORTED)\r\nbnx2x_stop_ptp(bp);\r\nbnx2x_netif_stop(bp, 1);\r\nbnx2x_del_all_napi(bp);\r\nif (CNIC_LOADED(bp))\r\nbnx2x_del_all_napi_cnic(bp);\r\nbnx2x_free_irq(bp);\r\nif (!pci_channel_offline(bp->pdev)) {\r\nrc = bnx2x_reset_hw(bp, reset_code);\r\nif (rc)\r\nBNX2X_ERR("HW_RESET failed\n");\r\n}\r\nbnx2x_send_unload_done(bp, keep_link);\r\n}\r\nvoid bnx2x_disable_close_the_gate(struct bnx2x *bp)\r\n{\r\nu32 val;\r\nDP(NETIF_MSG_IFDOWN, "Disabling \"close the gates\"\n");\r\nif (CHIP_IS_E1(bp)) {\r\nint port = BP_PORT(bp);\r\nu32 addr = port ? MISC_REG_AEU_MASK_ATTN_FUNC_1 :\r\nMISC_REG_AEU_MASK_ATTN_FUNC_0;\r\nval = REG_RD(bp, addr);\r\nval &= ~(0x300);\r\nREG_WR(bp, addr, val);\r\n} else {\r\nval = REG_RD(bp, MISC_REG_AEU_GENERAL_MASK);\r\nval &= ~(MISC_AEU_GENERAL_MASK_REG_AEU_PXP_CLOSE_MASK |\r\nMISC_AEU_GENERAL_MASK_REG_AEU_NIG_CLOSE_MASK);\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_MASK, val);\r\n}\r\n}\r\nstatic void bnx2x_set_234_gates(struct bnx2x *bp, bool close)\r\n{\r\nu32 val;\r\nif (!CHIP_IS_E1(bp)) {\r\nREG_WR(bp, PXP_REG_HST_DISCARD_DOORBELLS, !!close);\r\nREG_WR(bp, PXP_REG_HST_DISCARD_INTERNAL_WRITES, !!close);\r\n}\r\nif (CHIP_IS_E1x(bp)) {\r\nval = REG_RD(bp, HC_REG_CONFIG_1);\r\nREG_WR(bp, HC_REG_CONFIG_1,\r\n(!close) ? (val | HC_CONFIG_1_REG_BLOCK_DISABLE_1) :\r\n(val & ~(u32)HC_CONFIG_1_REG_BLOCK_DISABLE_1));\r\nval = REG_RD(bp, HC_REG_CONFIG_0);\r\nREG_WR(bp, HC_REG_CONFIG_0,\r\n(!close) ? (val | HC_CONFIG_0_REG_BLOCK_DISABLE_0) :\r\n(val & ~(u32)HC_CONFIG_0_REG_BLOCK_DISABLE_0));\r\n} else {\r\nval = REG_RD(bp, IGU_REG_BLOCK_CONFIGURATION);\r\nREG_WR(bp, IGU_REG_BLOCK_CONFIGURATION,\r\n(!close) ?\r\n(val | IGU_BLOCK_CONFIGURATION_REG_BLOCK_ENABLE) :\r\n(val & ~(u32)IGU_BLOCK_CONFIGURATION_REG_BLOCK_ENABLE));\r\n}\r\nDP(NETIF_MSG_HW | NETIF_MSG_IFUP, "%s gates #2, #3 and #4\n",\r\nclose ? "closing" : "opening");\r\nmmiowb();\r\n}\r\nstatic void bnx2x_clp_reset_prep(struct bnx2x *bp, u32 *magic_val)\r\n{\r\nu32 val = MF_CFG_RD(bp, shared_mf_config.clp_mb);\r\n*magic_val = val & SHARED_MF_CLP_MAGIC;\r\nMF_CFG_WR(bp, shared_mf_config.clp_mb, val | SHARED_MF_CLP_MAGIC);\r\n}\r\nstatic void bnx2x_clp_reset_done(struct bnx2x *bp, u32 magic_val)\r\n{\r\nu32 val = MF_CFG_RD(bp, shared_mf_config.clp_mb);\r\nMF_CFG_WR(bp, shared_mf_config.clp_mb,\r\n(val & (~SHARED_MF_CLP_MAGIC)) | magic_val);\r\n}\r\nstatic void bnx2x_reset_mcp_prep(struct bnx2x *bp, u32 *magic_val)\r\n{\r\nu32 shmem;\r\nu32 validity_offset;\r\nDP(NETIF_MSG_HW | NETIF_MSG_IFUP, "Starting\n");\r\nif (!CHIP_IS_E1(bp))\r\nbnx2x_clp_reset_prep(bp, magic_val);\r\nshmem = REG_RD(bp, MISC_REG_SHARED_MEM_ADDR);\r\nvalidity_offset =\r\noffsetof(struct shmem_region, validity_map[BP_PORT(bp)]);\r\nif (shmem > 0)\r\nREG_WR(bp, shmem + validity_offset, 0);\r\n}\r\nstatic void bnx2x_mcp_wait_one(struct bnx2x *bp)\r\n{\r\nif (CHIP_REV_IS_SLOW(bp))\r\nmsleep(MCP_ONE_TIMEOUT*10);\r\nelse\r\nmsleep(MCP_ONE_TIMEOUT);\r\n}\r\nstatic int bnx2x_init_shmem(struct bnx2x *bp)\r\n{\r\nint cnt = 0;\r\nu32 val = 0;\r\ndo {\r\nbp->common.shmem_base = REG_RD(bp, MISC_REG_SHARED_MEM_ADDR);\r\nif (bp->common.shmem_base) {\r\nval = SHMEM_RD(bp, validity_map[BP_PORT(bp)]);\r\nif (val & SHR_MEM_VALIDITY_MB)\r\nreturn 0;\r\n}\r\nbnx2x_mcp_wait_one(bp);\r\n} while (cnt++ < (MCP_TIMEOUT / MCP_ONE_TIMEOUT));\r\nBNX2X_ERR("BAD MCP validity signature\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int bnx2x_reset_mcp_comp(struct bnx2x *bp, u32 magic_val)\r\n{\r\nint rc = bnx2x_init_shmem(bp);\r\nif (!CHIP_IS_E1(bp))\r\nbnx2x_clp_reset_done(bp, magic_val);\r\nreturn rc;\r\n}\r\nstatic void bnx2x_pxp_prep(struct bnx2x *bp)\r\n{\r\nif (!CHIP_IS_E1(bp)) {\r\nREG_WR(bp, PXP2_REG_RD_START_INIT, 0);\r\nREG_WR(bp, PXP2_REG_RQ_RBC_DONE, 0);\r\nmmiowb();\r\n}\r\n}\r\nstatic void bnx2x_process_kill_chip_reset(struct bnx2x *bp, bool global)\r\n{\r\nu32 not_reset_mask1, reset_mask1, not_reset_mask2, reset_mask2;\r\nu32 global_bits2, stay_reset2;\r\nglobal_bits2 =\r\nMISC_REGISTERS_RESET_REG_2_RST_MCP_N_RESET_CMN_CPU |\r\nMISC_REGISTERS_RESET_REG_2_RST_MCP_N_RESET_CMN_CORE;\r\nnot_reset_mask1 =\r\nMISC_REGISTERS_RESET_REG_1_RST_HC |\r\nMISC_REGISTERS_RESET_REG_1_RST_PXPV |\r\nMISC_REGISTERS_RESET_REG_1_RST_PXP;\r\nnot_reset_mask2 =\r\nMISC_REGISTERS_RESET_REG_2_RST_PCI_MDIO |\r\nMISC_REGISTERS_RESET_REG_2_RST_EMAC0_HARD_CORE |\r\nMISC_REGISTERS_RESET_REG_2_RST_EMAC1_HARD_CORE |\r\nMISC_REGISTERS_RESET_REG_2_RST_MISC_CORE |\r\nMISC_REGISTERS_RESET_REG_2_RST_RBCN |\r\nMISC_REGISTERS_RESET_REG_2_RST_GRC |\r\nMISC_REGISTERS_RESET_REG_2_RST_MCP_N_RESET_REG_HARD_CORE |\r\nMISC_REGISTERS_RESET_REG_2_RST_MCP_N_HARD_CORE_RST_B |\r\nMISC_REGISTERS_RESET_REG_2_RST_ATC |\r\nMISC_REGISTERS_RESET_REG_2_PGLC |\r\nMISC_REGISTERS_RESET_REG_2_RST_BMAC0 |\r\nMISC_REGISTERS_RESET_REG_2_RST_BMAC1 |\r\nMISC_REGISTERS_RESET_REG_2_RST_EMAC0 |\r\nMISC_REGISTERS_RESET_REG_2_RST_EMAC1 |\r\nMISC_REGISTERS_RESET_REG_2_UMAC0 |\r\nMISC_REGISTERS_RESET_REG_2_UMAC1;\r\nstay_reset2 =\r\nMISC_REGISTERS_RESET_REG_2_XMAC |\r\nMISC_REGISTERS_RESET_REG_2_XMAC_SOFT;\r\nreset_mask1 = 0xffffffff;\r\nif (CHIP_IS_E1(bp))\r\nreset_mask2 = 0xffff;\r\nelse if (CHIP_IS_E1H(bp))\r\nreset_mask2 = 0x1ffff;\r\nelse if (CHIP_IS_E2(bp))\r\nreset_mask2 = 0xfffff;\r\nelse\r\nreset_mask2 = 0x3ffffff;\r\nif (!global)\r\nreset_mask2 &= ~global_bits2;\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\r\nreset_mask2 & (~not_reset_mask2));\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR,\r\nreset_mask1 & (~not_reset_mask1));\r\nbarrier();\r\nmmiowb();\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\r\nreset_mask2 & (~stay_reset2));\r\nbarrier();\r\nmmiowb();\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET, reset_mask1);\r\nmmiowb();\r\n}\r\nstatic int bnx2x_er_poll_igu_vq(struct bnx2x *bp)\r\n{\r\nu32 cnt = 1000;\r\nu32 pend_bits = 0;\r\ndo {\r\npend_bits = REG_RD(bp, IGU_REG_PENDING_BITS_STATUS);\r\nif (pend_bits == 0)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n} while (cnt-- > 0);\r\nif (cnt <= 0) {\r\nBNX2X_ERR("Still pending IGU requests pend_bits=%x!\n",\r\npend_bits);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_process_kill(struct bnx2x *bp, bool global)\r\n{\r\nint cnt = 1000;\r\nu32 val = 0;\r\nu32 sr_cnt, blk_cnt, port_is_idle_0, port_is_idle_1, pgl_exp_rom2;\r\nu32 tags_63_32 = 0;\r\ndo {\r\nsr_cnt = REG_RD(bp, PXP2_REG_RD_SR_CNT);\r\nblk_cnt = REG_RD(bp, PXP2_REG_RD_BLK_CNT);\r\nport_is_idle_0 = REG_RD(bp, PXP2_REG_RD_PORT_IS_IDLE_0);\r\nport_is_idle_1 = REG_RD(bp, PXP2_REG_RD_PORT_IS_IDLE_1);\r\npgl_exp_rom2 = REG_RD(bp, PXP2_REG_PGL_EXP_ROM2);\r\nif (CHIP_IS_E3(bp))\r\ntags_63_32 = REG_RD(bp, PGLUE_B_REG_TAGS_63_32);\r\nif ((sr_cnt == 0x7e) && (blk_cnt == 0xa0) &&\r\n((port_is_idle_0 & 0x1) == 0x1) &&\r\n((port_is_idle_1 & 0x1) == 0x1) &&\r\n(pgl_exp_rom2 == 0xffffffff) &&\r\n(!CHIP_IS_E3(bp) || (tags_63_32 == 0xffffffff)))\r\nbreak;\r\nusleep_range(1000, 2000);\r\n} while (cnt-- > 0);\r\nif (cnt <= 0) {\r\nBNX2X_ERR("Tetris buffer didn't get empty or there are still outstanding read requests after 1s!\n");\r\nBNX2X_ERR("sr_cnt=0x%08x, blk_cnt=0x%08x, port_is_idle_0=0x%08x, port_is_idle_1=0x%08x, pgl_exp_rom2=0x%08x\n",\r\nsr_cnt, blk_cnt, port_is_idle_0, port_is_idle_1,\r\npgl_exp_rom2);\r\nreturn -EAGAIN;\r\n}\r\nbarrier();\r\nbnx2x_set_234_gates(bp, true);\r\nif (!CHIP_IS_E1x(bp) && bnx2x_er_poll_igu_vq(bp))\r\nreturn -EAGAIN;\r\nREG_WR(bp, MISC_REG_UNPREPARED, 0);\r\nbarrier();\r\nmmiowb();\r\nusleep_range(1000, 2000);\r\nif (global)\r\nbnx2x_reset_mcp_prep(bp, &val);\r\nbnx2x_pxp_prep(bp);\r\nbarrier();\r\nbnx2x_process_kill_chip_reset(bp, global);\r\nbarrier();\r\nif (!CHIP_IS_E1x(bp))\r\nREG_WR(bp, PGLUE_B_REG_LATCHED_ERRORS_CLR, 0x7f);\r\nif (global && bnx2x_reset_mcp_comp(bp, val))\r\nreturn -EAGAIN;\r\nbnx2x_set_234_gates(bp, false);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_leader_reset(struct bnx2x *bp)\r\n{\r\nint rc = 0;\r\nbool global = bnx2x_reset_is_global(bp);\r\nu32 load_code;\r\nif (!global && !BP_NOMCP(bp)) {\r\nload_code = bnx2x_fw_command(bp, DRV_MSG_CODE_LOAD_REQ,\r\nDRV_MSG_CODE_LOAD_REQ_WITH_LFA);\r\nif (!load_code) {\r\nBNX2X_ERR("MCP response failure, aborting\n");\r\nrc = -EAGAIN;\r\ngoto exit_leader_reset;\r\n}\r\nif ((load_code != FW_MSG_CODE_DRV_LOAD_COMMON_CHIP) &&\r\n(load_code != FW_MSG_CODE_DRV_LOAD_COMMON)) {\r\nBNX2X_ERR("MCP unexpected resp, aborting\n");\r\nrc = -EAGAIN;\r\ngoto exit_leader_reset2;\r\n}\r\nload_code = bnx2x_fw_command(bp, DRV_MSG_CODE_LOAD_DONE, 0);\r\nif (!load_code) {\r\nBNX2X_ERR("MCP response failure, aborting\n");\r\nrc = -EAGAIN;\r\ngoto exit_leader_reset2;\r\n}\r\n}\r\nif (bnx2x_process_kill(bp, global)) {\r\nBNX2X_ERR("Something bad had happen on engine %d! Aii!\n",\r\nBP_PATH(bp));\r\nrc = -EAGAIN;\r\ngoto exit_leader_reset2;\r\n}\r\nbnx2x_set_reset_done(bp);\r\nif (global)\r\nbnx2x_clear_reset_global(bp);\r\nexit_leader_reset2:\r\nif (!global && !BP_NOMCP(bp)) {\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP, 0);\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE, 0);\r\n}\r\nexit_leader_reset:\r\nbp->is_leader = 0;\r\nbnx2x_release_leader_lock(bp);\r\nsmp_mb();\r\nreturn rc;\r\n}\r\nstatic void bnx2x_recovery_failed(struct bnx2x *bp)\r\n{\r\nnetdev_err(bp->dev, "Recovery has failed. Power cycle is needed.\n");\r\nnetif_device_detach(bp->dev);\r\nbnx2x_set_reset_in_progress(bp);\r\nbnx2x_set_power_state(bp, PCI_D3hot);\r\nbp->recovery_state = BNX2X_RECOVERY_FAILED;\r\nsmp_mb();\r\n}\r\nstatic void bnx2x_parity_recover(struct bnx2x *bp)\r\n{\r\nbool global = false;\r\nu32 error_recovered, error_unrecovered;\r\nbool is_parity;\r\nDP(NETIF_MSG_HW, "Handling parity\n");\r\nwhile (1) {\r\nswitch (bp->recovery_state) {\r\ncase BNX2X_RECOVERY_INIT:\r\nDP(NETIF_MSG_HW, "State is BNX2X_RECOVERY_INIT\n");\r\nis_parity = bnx2x_chk_parity_attn(bp, &global, false);\r\nWARN_ON(!is_parity);\r\nif (bnx2x_trylock_leader_lock(bp)) {\r\nbnx2x_set_reset_in_progress(bp);\r\nif (global)\r\nbnx2x_set_reset_global(bp);\r\nbp->is_leader = 1;\r\n}\r\nif (bnx2x_nic_unload(bp, UNLOAD_RECOVERY, false))\r\nreturn;\r\nbp->recovery_state = BNX2X_RECOVERY_WAIT;\r\nsmp_mb();\r\nbreak;\r\ncase BNX2X_RECOVERY_WAIT:\r\nDP(NETIF_MSG_HW, "State is BNX2X_RECOVERY_WAIT\n");\r\nif (bp->is_leader) {\r\nint other_engine = BP_PATH(bp) ? 0 : 1;\r\nbool other_load_status =\r\nbnx2x_get_load_status(bp, other_engine);\r\nbool load_status =\r\nbnx2x_get_load_status(bp, BP_PATH(bp));\r\nglobal = bnx2x_reset_is_global(bp);\r\nif (load_status ||\r\n(global && other_load_status)) {\r\nschedule_delayed_work(&bp->sp_rtnl_task,\r\nHZ/10);\r\nreturn;\r\n} else {\r\nif (bnx2x_leader_reset(bp)) {\r\nbnx2x_recovery_failed(bp);\r\nreturn;\r\n}\r\nbreak;\r\n}\r\n} else {\r\nif (!bnx2x_reset_is_done(bp, BP_PATH(bp))) {\r\nif (bnx2x_trylock_leader_lock(bp)) {\r\nbp->is_leader = 1;\r\nbreak;\r\n}\r\nschedule_delayed_work(&bp->sp_rtnl_task,\r\nHZ/10);\r\nreturn;\r\n} else {\r\nif (bnx2x_reset_is_global(bp)) {\r\nschedule_delayed_work(\r\n&bp->sp_rtnl_task,\r\nHZ/10);\r\nreturn;\r\n}\r\nerror_recovered =\r\nbp->eth_stats.recoverable_error;\r\nerror_unrecovered =\r\nbp->eth_stats.unrecoverable_error;\r\nbp->recovery_state =\r\nBNX2X_RECOVERY_NIC_LOADING;\r\nif (bnx2x_nic_load(bp, LOAD_NORMAL)) {\r\nerror_unrecovered++;\r\nnetdev_err(bp->dev,\r\n"Recovery failed. Power cycle needed\n");\r\nnetif_device_detach(bp->dev);\r\nbnx2x_set_power_state(\r\nbp, PCI_D3hot);\r\nsmp_mb();\r\n} else {\r\nbp->recovery_state =\r\nBNX2X_RECOVERY_DONE;\r\nerror_recovered++;\r\nsmp_mb();\r\n}\r\nbp->eth_stats.recoverable_error =\r\nerror_recovered;\r\nbp->eth_stats.unrecoverable_error =\r\nerror_unrecovered;\r\nreturn;\r\n}\r\n}\r\ndefault:\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int bnx2x_udp_port_update(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_func_switch_update_params *switch_update_params;\r\nstruct bnx2x_func_state_params func_params = {NULL};\r\nstruct bnx2x_udp_tunnel *udp_tunnel;\r\nu16 vxlan_port = 0, geneve_port = 0;\r\nint rc;\r\nswitch_update_params = &func_params.params.switch_update;\r\n__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\r\n__set_bit(RAMROD_RETRY, &func_params.ramrod_flags);\r\nfunc_params.f_obj = &bp->func_obj;\r\nfunc_params.cmd = BNX2X_F_CMD_SWITCH_UPDATE;\r\n__set_bit(BNX2X_F_UPDATE_TUNNEL_CFG_CHNG,\r\n&switch_update_params->changes);\r\nif (bp->udp_tunnel_ports[BNX2X_UDP_PORT_GENEVE].count) {\r\nudp_tunnel = &bp->udp_tunnel_ports[BNX2X_UDP_PORT_GENEVE];\r\ngeneve_port = udp_tunnel->dst_port;\r\nswitch_update_params->geneve_dst_port = geneve_port;\r\n}\r\nif (bp->udp_tunnel_ports[BNX2X_UDP_PORT_VXLAN].count) {\r\nudp_tunnel = &bp->udp_tunnel_ports[BNX2X_UDP_PORT_VXLAN];\r\nvxlan_port = udp_tunnel->dst_port;\r\nswitch_update_params->vxlan_dst_port = vxlan_port;\r\n}\r\n__set_bit(BNX2X_F_UPDATE_TUNNEL_INNER_RSS,\r\n&switch_update_params->changes);\r\nrc = bnx2x_func_state_change(bp, &func_params);\r\nif (rc)\r\nBNX2X_ERR("failed to set UDP dst port to %04x %04x (rc = 0x%x)\n",\r\nvxlan_port, geneve_port, rc);\r\nelse\r\nDP(BNX2X_MSG_SP,\r\n"Configured UDP ports: Vxlan [%04x] Geneve [%04x]\n",\r\nvxlan_port, geneve_port);\r\nreturn rc;\r\n}\r\nstatic void __bnx2x_add_udp_port(struct bnx2x *bp, u16 port,\r\nenum bnx2x_udp_port_type type)\r\n{\r\nstruct bnx2x_udp_tunnel *udp_port = &bp->udp_tunnel_ports[type];\r\nif (!netif_running(bp->dev) || !IS_PF(bp) || CHIP_IS_E1x(bp))\r\nreturn;\r\nif (udp_port->count && udp_port->dst_port == port) {\r\nudp_port->count++;\r\nreturn;\r\n}\r\nif (udp_port->count) {\r\nDP(BNX2X_MSG_SP,\r\n"UDP tunnel [%d] - destination port limit reached\n",\r\ntype);\r\nreturn;\r\n}\r\nudp_port->dst_port = port;\r\nudp_port->count = 1;\r\nbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_CHANGE_UDP_PORT, 0);\r\n}\r\nstatic void __bnx2x_del_udp_port(struct bnx2x *bp, u16 port,\r\nenum bnx2x_udp_port_type type)\r\n{\r\nstruct bnx2x_udp_tunnel *udp_port = &bp->udp_tunnel_ports[type];\r\nif (!IS_PF(bp) || CHIP_IS_E1x(bp))\r\nreturn;\r\nif (!udp_port->count || udp_port->dst_port != port) {\r\nDP(BNX2X_MSG_SP, "Invalid UDP tunnel [%d] port\n",\r\ntype);\r\nreturn;\r\n}\r\nudp_port->count--;\r\nif (udp_port->count)\r\nreturn;\r\nudp_port->dst_port = 0;\r\nif (netif_running(bp->dev))\r\nbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_CHANGE_UDP_PORT, 0);\r\nelse\r\nDP(BNX2X_MSG_SP, "Deleted UDP tunnel [%d] port %d\n",\r\ntype, port);\r\n}\r\nstatic void bnx2x_udp_tunnel_add(struct net_device *netdev,\r\nstruct udp_tunnel_info *ti)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nu16 t_port = ntohs(ti->port);\r\nswitch (ti->type) {\r\ncase UDP_TUNNEL_TYPE_VXLAN:\r\n__bnx2x_add_udp_port(bp, t_port, BNX2X_UDP_PORT_VXLAN);\r\nbreak;\r\ncase UDP_TUNNEL_TYPE_GENEVE:\r\n__bnx2x_add_udp_port(bp, t_port, BNX2X_UDP_PORT_GENEVE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void bnx2x_udp_tunnel_del(struct net_device *netdev,\r\nstruct udp_tunnel_info *ti)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nu16 t_port = ntohs(ti->port);\r\nswitch (ti->type) {\r\ncase UDP_TUNNEL_TYPE_VXLAN:\r\n__bnx2x_del_udp_port(bp, t_port, BNX2X_UDP_PORT_VXLAN);\r\nbreak;\r\ncase UDP_TUNNEL_TYPE_GENEVE:\r\n__bnx2x_del_udp_port(bp, t_port, BNX2X_UDP_PORT_GENEVE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void bnx2x_sp_rtnl_task(struct work_struct *work)\r\n{\r\nstruct bnx2x *bp = container_of(work, struct bnx2x, sp_rtnl_task.work);\r\nrtnl_lock();\r\nif (!netif_running(bp->dev)) {\r\nrtnl_unlock();\r\nreturn;\r\n}\r\nif (unlikely(bp->recovery_state != BNX2X_RECOVERY_DONE)) {\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nBNX2X_ERR("recovery flow called but STOP_ON_ERROR defined so reset not done to allow debug dump,\n"\r\n"you will need to reboot when done\n");\r\ngoto sp_rtnl_not_reset;\r\n#endif\r\nbp->sp_rtnl_state = 0;\r\nsmp_mb();\r\nbnx2x_parity_recover(bp);\r\nrtnl_unlock();\r\nreturn;\r\n}\r\nif (test_and_clear_bit(BNX2X_SP_RTNL_TX_TIMEOUT, &bp->sp_rtnl_state)) {\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nBNX2X_ERR("recovery flow called but STOP_ON_ERROR defined so reset not done to allow debug dump,\n"\r\n"you will need to reboot when done\n");\r\ngoto sp_rtnl_not_reset;\r\n#endif\r\nbp->sp_rtnl_state = 0;\r\nsmp_mb();\r\nbnx2x_nic_unload(bp, UNLOAD_NORMAL, true);\r\nbnx2x_nic_load(bp, LOAD_NORMAL);\r\nrtnl_unlock();\r\nreturn;\r\n}\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nsp_rtnl_not_reset:\r\n#endif\r\nif (test_and_clear_bit(BNX2X_SP_RTNL_SETUP_TC, &bp->sp_rtnl_state))\r\nbnx2x_setup_tc(bp->dev, bp->dcbx_port_params.ets.num_of_cos);\r\nif (test_and_clear_bit(BNX2X_SP_RTNL_AFEX_F_UPDATE, &bp->sp_rtnl_state))\r\nbnx2x_after_function_update(bp);\r\nif (test_and_clear_bit(BNX2X_SP_RTNL_FAN_FAILURE, &bp->sp_rtnl_state)) {\r\nDP(NETIF_MSG_HW, "fan failure detected. Unloading driver\n");\r\nnetif_device_detach(bp->dev);\r\nbnx2x_close(bp->dev);\r\nrtnl_unlock();\r\nreturn;\r\n}\r\nif (test_and_clear_bit(BNX2X_SP_RTNL_VFPF_MCAST, &bp->sp_rtnl_state)) {\r\nDP(BNX2X_MSG_SP,\r\n"sending set mcast vf pf channel message from rtnl sp-task\n");\r\nbnx2x_vfpf_set_mcast(bp->dev);\r\n}\r\nif (test_and_clear_bit(BNX2X_SP_RTNL_VFPF_CHANNEL_DOWN,\r\n&bp->sp_rtnl_state)){\r\nif (netif_carrier_ok(bp->dev)) {\r\nbnx2x_tx_disable(bp);\r\nBNX2X_ERR("PF indicated channel is not servicable anymore. This means this VF device is no longer operational\n");\r\n}\r\n}\r\nif (test_and_clear_bit(BNX2X_SP_RTNL_RX_MODE, &bp->sp_rtnl_state)) {\r\nDP(BNX2X_MSG_SP, "Handling Rx Mode setting\n");\r\nbnx2x_set_rx_mode_inner(bp);\r\n}\r\nif (test_and_clear_bit(BNX2X_SP_RTNL_HYPERVISOR_VLAN,\r\n&bp->sp_rtnl_state))\r\nbnx2x_pf_set_vfs_vlan(bp);\r\nif (test_and_clear_bit(BNX2X_SP_RTNL_TX_STOP, &bp->sp_rtnl_state)) {\r\nbnx2x_dcbx_stop_hw_tx(bp);\r\nbnx2x_dcbx_resume_hw_tx(bp);\r\n}\r\nif (test_and_clear_bit(BNX2X_SP_RTNL_GET_DRV_VERSION,\r\n&bp->sp_rtnl_state))\r\nbnx2x_update_mng_version(bp);\r\nif (test_and_clear_bit(BNX2X_SP_RTNL_CHANGE_UDP_PORT,\r\n&bp->sp_rtnl_state)) {\r\nif (bnx2x_udp_port_update(bp)) {\r\nmemset(bp->udp_tunnel_ports, 0,\r\nsizeof(struct bnx2x_udp_tunnel) *\r\nBNX2X_UDP_PORT_MAX);\r\n} else {\r\nif (!bp->udp_tunnel_ports[BNX2X_UDP_PORT_VXLAN].count &&\r\n!bp->udp_tunnel_ports[BNX2X_UDP_PORT_GENEVE].count)\r\nudp_tunnel_get_rx_info(bp->dev);\r\n}\r\n}\r\nrtnl_unlock();\r\nif (IS_SRIOV(bp) && test_and_clear_bit(BNX2X_SP_RTNL_ENABLE_SRIOV,\r\n&bp->sp_rtnl_state)) {\r\nbnx2x_disable_sriov(bp);\r\nbnx2x_enable_sriov(bp);\r\n}\r\n}\r\nstatic void bnx2x_period_task(struct work_struct *work)\r\n{\r\nstruct bnx2x *bp = container_of(work, struct bnx2x, period_task.work);\r\nif (!netif_running(bp->dev))\r\ngoto period_task_exit;\r\nif (CHIP_REV_IS_SLOW(bp)) {\r\nBNX2X_ERR("period task called on emulation, ignoring\n");\r\ngoto period_task_exit;\r\n}\r\nbnx2x_acquire_phy_lock(bp);\r\nsmp_mb();\r\nif (bp->port.pmf) {\r\nbnx2x_period_func(&bp->link_params, &bp->link_vars);\r\nqueue_delayed_work(bnx2x_wq, &bp->period_task, 1*HZ);\r\n}\r\nbnx2x_release_phy_lock(bp);\r\nperiod_task_exit:\r\nreturn;\r\n}\r\nstatic u32 bnx2x_get_pretend_reg(struct bnx2x *bp)\r\n{\r\nu32 base = PXP2_REG_PGL_PRETEND_FUNC_F0;\r\nu32 stride = PXP2_REG_PGL_PRETEND_FUNC_F1 - base;\r\nreturn base + (BP_ABS_FUNC(bp)) * stride;\r\n}\r\nstatic bool bnx2x_prev_unload_close_umac(struct bnx2x *bp,\r\nu8 port, u32 reset_reg,\r\nstruct bnx2x_mac_vals *vals)\r\n{\r\nu32 mask = MISC_REGISTERS_RESET_REG_2_UMAC0 << port;\r\nu32 base_addr;\r\nif (!(mask & reset_reg))\r\nreturn false;\r\nBNX2X_DEV_INFO("Disable umac Rx %02x\n", port);\r\nbase_addr = port ? GRCBASE_UMAC1 : GRCBASE_UMAC0;\r\nvals->umac_addr[port] = base_addr + UMAC_REG_COMMAND_CONFIG;\r\nvals->umac_val[port] = REG_RD(bp, vals->umac_addr[port]);\r\nREG_WR(bp, vals->umac_addr[port], 0);\r\nreturn true;\r\n}\r\nstatic void bnx2x_prev_unload_close_mac(struct bnx2x *bp,\r\nstruct bnx2x_mac_vals *vals)\r\n{\r\nu32 val, base_addr, offset, mask, reset_reg;\r\nbool mac_stopped = false;\r\nu8 port = BP_PORT(bp);\r\nmemset(vals, 0, sizeof(*vals));\r\nreset_reg = REG_RD(bp, MISC_REG_RESET_REG_2);\r\nif (!CHIP_IS_E3(bp)) {\r\nval = REG_RD(bp, NIG_REG_BMAC0_REGS_OUT_EN + port * 4);\r\nmask = MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port;\r\nif ((mask & reset_reg) && val) {\r\nu32 wb_data[2];\r\nBNX2X_DEV_INFO("Disable bmac Rx\n");\r\nbase_addr = BP_PORT(bp) ? NIG_REG_INGRESS_BMAC1_MEM\r\n: NIG_REG_INGRESS_BMAC0_MEM;\r\noffset = CHIP_IS_E2(bp) ? BIGMAC2_REGISTER_BMAC_CONTROL\r\n: BIGMAC_REGISTER_BMAC_CONTROL;\r\nwb_data[0] = REG_RD(bp, base_addr + offset);\r\nwb_data[1] = REG_RD(bp, base_addr + offset + 0x4);\r\nvals->bmac_addr = base_addr + offset;\r\nvals->bmac_val[0] = wb_data[0];\r\nvals->bmac_val[1] = wb_data[1];\r\nwb_data[0] &= ~BMAC_CONTROL_RX_ENABLE;\r\nREG_WR(bp, vals->bmac_addr, wb_data[0]);\r\nREG_WR(bp, vals->bmac_addr + 0x4, wb_data[1]);\r\n}\r\nBNX2X_DEV_INFO("Disable emac Rx\n");\r\nvals->emac_addr = NIG_REG_NIG_EMAC0_EN + BP_PORT(bp)*4;\r\nvals->emac_val = REG_RD(bp, vals->emac_addr);\r\nREG_WR(bp, vals->emac_addr, 0);\r\nmac_stopped = true;\r\n} else {\r\nif (reset_reg & MISC_REGISTERS_RESET_REG_2_XMAC) {\r\nBNX2X_DEV_INFO("Disable xmac Rx\n");\r\nbase_addr = BP_PORT(bp) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\r\nval = REG_RD(bp, base_addr + XMAC_REG_PFC_CTRL_HI);\r\nREG_WR(bp, base_addr + XMAC_REG_PFC_CTRL_HI,\r\nval & ~(1 << 1));\r\nREG_WR(bp, base_addr + XMAC_REG_PFC_CTRL_HI,\r\nval | (1 << 1));\r\nvals->xmac_addr = base_addr + XMAC_REG_CTRL;\r\nvals->xmac_val = REG_RD(bp, vals->xmac_addr);\r\nREG_WR(bp, vals->xmac_addr, 0);\r\nmac_stopped = true;\r\n}\r\nmac_stopped |= bnx2x_prev_unload_close_umac(bp, 0,\r\nreset_reg, vals);\r\nmac_stopped |= bnx2x_prev_unload_close_umac(bp, 1,\r\nreset_reg, vals);\r\n}\r\nif (mac_stopped)\r\nmsleep(20);\r\n}\r\nstatic bool bnx2x_prev_is_after_undi(struct bnx2x *bp)\r\n{\r\nif (!(REG_RD(bp, MISC_REG_RESET_REG_1) &\r\nMISC_REGISTERS_RESET_REG_1_RST_DORQ))\r\nreturn false;\r\nif (REG_RD(bp, DORQ_REG_NORM_CID_OFST) == 0x7) {\r\nBNX2X_DEV_INFO("UNDI previously loaded\n");\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void bnx2x_prev_unload_undi_inc(struct bnx2x *bp, u8 inc)\r\n{\r\nu16 rcq, bd;\r\nu32 addr, tmp_reg;\r\nif (BP_FUNC(bp) < 2)\r\naddr = BNX2X_PREV_UNDI_PROD_ADDR(BP_PORT(bp));\r\nelse\r\naddr = BNX2X_PREV_UNDI_PROD_ADDR_H(BP_FUNC(bp) - 2);\r\ntmp_reg = REG_RD(bp, addr);\r\nrcq = BNX2X_PREV_UNDI_RCQ(tmp_reg) + inc;\r\nbd = BNX2X_PREV_UNDI_BD(tmp_reg) + inc;\r\ntmp_reg = BNX2X_PREV_UNDI_PROD(rcq, bd);\r\nREG_WR(bp, addr, tmp_reg);\r\nBNX2X_DEV_INFO("UNDI producer [%d/%d][%08x] rings bd -> 0x%04x, rcq -> 0x%04x\n",\r\nBP_PORT(bp), BP_FUNC(bp), addr, bd, rcq);\r\n}\r\nstatic int bnx2x_prev_mcp_done(struct bnx2x *bp)\r\n{\r\nu32 rc = bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE,\r\nDRV_MSG_CODE_UNLOAD_SKIP_LINK_RESET);\r\nif (!rc) {\r\nBNX2X_ERR("MCP response failure, aborting\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct bnx2x_prev_path_list *\r\nbnx2x_prev_path_get_entry(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_prev_path_list *tmp_list;\r\nlist_for_each_entry(tmp_list, &bnx2x_prev_list, list)\r\nif (PCI_SLOT(bp->pdev->devfn) == tmp_list->slot &&\r\nbp->pdev->bus->number == tmp_list->bus &&\r\nBP_PATH(bp) == tmp_list->path)\r\nreturn tmp_list;\r\nreturn NULL;\r\n}\r\nstatic int bnx2x_prev_path_mark_eeh(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_prev_path_list *tmp_list;\r\nint rc;\r\nrc = down_interruptible(&bnx2x_prev_sem);\r\nif (rc) {\r\nBNX2X_ERR("Received %d when tried to take lock\n", rc);\r\nreturn rc;\r\n}\r\ntmp_list = bnx2x_prev_path_get_entry(bp);\r\nif (tmp_list) {\r\ntmp_list->aer = 1;\r\nrc = 0;\r\n} else {\r\nBNX2X_ERR("path %d: Entry does not exist for eeh; Flow occurs before initial insmod is over ?\n",\r\nBP_PATH(bp));\r\n}\r\nup(&bnx2x_prev_sem);\r\nreturn rc;\r\n}\r\nstatic bool bnx2x_prev_is_path_marked(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_prev_path_list *tmp_list;\r\nbool rc = false;\r\nif (down_trylock(&bnx2x_prev_sem))\r\nreturn false;\r\ntmp_list = bnx2x_prev_path_get_entry(bp);\r\nif (tmp_list) {\r\nif (tmp_list->aer) {\r\nDP(NETIF_MSG_HW, "Path %d was marked by AER\n",\r\nBP_PATH(bp));\r\n} else {\r\nrc = true;\r\nBNX2X_DEV_INFO("Path %d was already cleaned from previous drivers\n",\r\nBP_PATH(bp));\r\n}\r\n}\r\nup(&bnx2x_prev_sem);\r\nreturn rc;\r\n}\r\nbool bnx2x_port_after_undi(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_prev_path_list *entry;\r\nbool val;\r\ndown(&bnx2x_prev_sem);\r\nentry = bnx2x_prev_path_get_entry(bp);\r\nval = !!(entry && (entry->undi & (1 << BP_PORT(bp))));\r\nup(&bnx2x_prev_sem);\r\nreturn val;\r\n}\r\nstatic int bnx2x_prev_mark_path(struct bnx2x *bp, bool after_undi)\r\n{\r\nstruct bnx2x_prev_path_list *tmp_list;\r\nint rc;\r\nrc = down_interruptible(&bnx2x_prev_sem);\r\nif (rc) {\r\nBNX2X_ERR("Received %d when tried to take lock\n", rc);\r\nreturn rc;\r\n}\r\ntmp_list = bnx2x_prev_path_get_entry(bp);\r\nif (tmp_list) {\r\nif (!tmp_list->aer) {\r\nBNX2X_ERR("Re-Marking the path.\n");\r\n} else {\r\nDP(NETIF_MSG_HW, "Removing AER indication from path %d\n",\r\nBP_PATH(bp));\r\ntmp_list->aer = 0;\r\n}\r\nup(&bnx2x_prev_sem);\r\nreturn 0;\r\n}\r\nup(&bnx2x_prev_sem);\r\ntmp_list = kmalloc(sizeof(struct bnx2x_prev_path_list), GFP_KERNEL);\r\nif (!tmp_list) {\r\nBNX2X_ERR("Failed to allocate 'bnx2x_prev_path_list'\n");\r\nreturn -ENOMEM;\r\n}\r\ntmp_list->bus = bp->pdev->bus->number;\r\ntmp_list->slot = PCI_SLOT(bp->pdev->devfn);\r\ntmp_list->path = BP_PATH(bp);\r\ntmp_list->aer = 0;\r\ntmp_list->undi = after_undi ? (1 << BP_PORT(bp)) : 0;\r\nrc = down_interruptible(&bnx2x_prev_sem);\r\nif (rc) {\r\nBNX2X_ERR("Received %d when tried to take lock\n", rc);\r\nkfree(tmp_list);\r\n} else {\r\nDP(NETIF_MSG_HW, "Marked path [%d] - finished previous unload\n",\r\nBP_PATH(bp));\r\nlist_add(&tmp_list->list, &bnx2x_prev_list);\r\nup(&bnx2x_prev_sem);\r\n}\r\nreturn rc;\r\n}\r\nstatic int bnx2x_do_flr(struct bnx2x *bp)\r\n{\r\nstruct pci_dev *dev = bp->pdev;\r\nif (CHIP_IS_E1x(bp)) {\r\nBNX2X_DEV_INFO("FLR not supported in E1/E1H\n");\r\nreturn -EINVAL;\r\n}\r\nif (bp->common.bc_ver < REQ_BC_VER_4_INITIATE_FLR) {\r\nBNX2X_ERR("FLR not supported by BC_VER: 0x%x\n",\r\nbp->common.bc_ver);\r\nreturn -EINVAL;\r\n}\r\nif (!pci_wait_for_pending_transaction(dev))\r\ndev_err(&dev->dev, "transaction is not cleared; proceeding with reset anyway\n");\r\nBNX2X_DEV_INFO("Initiating FLR\n");\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_INITIATE_FLR, 0);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_prev_unload_uncommon(struct bnx2x *bp)\r\n{\r\nint rc;\r\nBNX2X_DEV_INFO("Uncommon unload Flow\n");\r\nif (bnx2x_prev_is_path_marked(bp))\r\nreturn bnx2x_prev_mcp_done(bp);\r\nBNX2X_DEV_INFO("Path is unmarked\n");\r\nif (bnx2x_prev_is_after_undi(bp))\r\ngoto out;\r\nrc = bnx2x_compare_fw_ver(bp, FW_MSG_CODE_DRV_LOAD_FUNCTION, false);\r\nif (!rc) {\r\nBNX2X_DEV_INFO("FW version matches our own. Attempting FLR\n");\r\nrc = bnx2x_do_flr(bp);\r\n}\r\nif (!rc) {\r\nBNX2X_DEV_INFO("FLR successful\n");\r\nreturn 0;\r\n}\r\nBNX2X_DEV_INFO("Could not FLR\n");\r\nout:\r\nrc = bnx2x_prev_mcp_done(bp);\r\nif (!rc)\r\nrc = BNX2X_PREV_WAIT_NEEDED;\r\nreturn rc;\r\n}\r\nstatic int bnx2x_prev_unload_common(struct bnx2x *bp)\r\n{\r\nu32 reset_reg, tmp_reg = 0, rc;\r\nbool prev_undi = false;\r\nstruct bnx2x_mac_vals mac_vals;\r\nBNX2X_DEV_INFO("Common unload Flow\n");\r\nmemset(&mac_vals, 0, sizeof(mac_vals));\r\nif (bnx2x_prev_is_path_marked(bp))\r\nreturn bnx2x_prev_mcp_done(bp);\r\nreset_reg = REG_RD(bp, MISC_REG_RESET_REG_1);\r\nif (reset_reg & MISC_REGISTERS_RESET_REG_1_RST_BRB1) {\r\nu32 timer_count = 1000;\r\nbnx2x_prev_unload_close_mac(bp, &mac_vals);\r\nbnx2x_set_rx_filter(&bp->link_params, 0);\r\nbp->link_params.port ^= 1;\r\nbnx2x_set_rx_filter(&bp->link_params, 0);\r\nbp->link_params.port ^= 1;\r\nif (bnx2x_prev_is_after_undi(bp)) {\r\nprev_undi = true;\r\nREG_WR(bp, DORQ_REG_NORM_CID_OFST, 0);\r\nREG_RD(bp, NIG_REG_NIG_INT_STS_CLR_0);\r\n}\r\nif (!CHIP_IS_E1x(bp))\r\nREG_WR(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER, 0);\r\ntmp_reg = REG_RD(bp, BRB1_REG_NUM_OF_FULL_BLOCKS);\r\nwhile (timer_count) {\r\nu32 prev_brb = tmp_reg;\r\ntmp_reg = REG_RD(bp, BRB1_REG_NUM_OF_FULL_BLOCKS);\r\nif (!tmp_reg)\r\nbreak;\r\nBNX2X_DEV_INFO("BRB still has 0x%08x\n", tmp_reg);\r\nif (prev_brb > tmp_reg)\r\ntimer_count = 1000;\r\nelse\r\ntimer_count--;\r\nif (prev_undi)\r\nbnx2x_prev_unload_undi_inc(bp, 1);\r\nudelay(10);\r\n}\r\nif (!timer_count)\r\nBNX2X_ERR("Failed to empty BRB, hope for the best\n");\r\n}\r\nbnx2x_reset_common(bp);\r\nif (mac_vals.xmac_addr)\r\nREG_WR(bp, mac_vals.xmac_addr, mac_vals.xmac_val);\r\nif (mac_vals.umac_addr[0])\r\nREG_WR(bp, mac_vals.umac_addr[0], mac_vals.umac_val[0]);\r\nif (mac_vals.umac_addr[1])\r\nREG_WR(bp, mac_vals.umac_addr[1], mac_vals.umac_val[1]);\r\nif (mac_vals.emac_addr)\r\nREG_WR(bp, mac_vals.emac_addr, mac_vals.emac_val);\r\nif (mac_vals.bmac_addr) {\r\nREG_WR(bp, mac_vals.bmac_addr, mac_vals.bmac_val[0]);\r\nREG_WR(bp, mac_vals.bmac_addr + 4, mac_vals.bmac_val[1]);\r\n}\r\nrc = bnx2x_prev_mark_path(bp, prev_undi);\r\nif (rc) {\r\nbnx2x_prev_mcp_done(bp);\r\nreturn rc;\r\n}\r\nreturn bnx2x_prev_mcp_done(bp);\r\n}\r\nstatic int bnx2x_prev_unload(struct bnx2x *bp)\r\n{\r\nint time_counter = 10;\r\nu32 rc, fw, hw_lock_reg, hw_lock_val;\r\nBNX2X_DEV_INFO("Entering Previous Unload Flow\n");\r\nbnx2x_clean_pglue_errors(bp);\r\nhw_lock_reg = (BP_FUNC(bp) <= 5) ?\r\n(MISC_REG_DRIVER_CONTROL_1 + BP_FUNC(bp) * 8) :\r\n(MISC_REG_DRIVER_CONTROL_7 + (BP_FUNC(bp) - 6) * 8);\r\nhw_lock_val = REG_RD(bp, hw_lock_reg);\r\nif (hw_lock_val) {\r\nif (hw_lock_val & HW_LOCK_RESOURCE_NVRAM) {\r\nBNX2X_DEV_INFO("Release Previously held NVRAM lock\n");\r\nREG_WR(bp, MCP_REG_MCPR_NVM_SW_ARB,\r\n(MCPR_NVM_SW_ARB_ARB_REQ_CLR1 << BP_PORT(bp)));\r\n}\r\nBNX2X_DEV_INFO("Release Previously held hw lock\n");\r\nREG_WR(bp, hw_lock_reg, 0xffffffff);\r\n} else\r\nBNX2X_DEV_INFO("No need to release hw/nvram locks\n");\r\nif (MCPR_ACCESS_LOCK_LOCK & REG_RD(bp, MCP_REG_MCPR_ACCESS_LOCK)) {\r\nBNX2X_DEV_INFO("Release previously held alr\n");\r\nbnx2x_release_alr(bp);\r\n}\r\ndo {\r\nint aer = 0;\r\nfw = bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS, 0);\r\nif (!fw) {\r\nBNX2X_ERR("MCP response failure, aborting\n");\r\nrc = -EBUSY;\r\nbreak;\r\n}\r\nrc = down_interruptible(&bnx2x_prev_sem);\r\nif (rc) {\r\nBNX2X_ERR("Cannot check for AER; Received %d when tried to take lock\n",\r\nrc);\r\n} else {\r\naer = !!(bnx2x_prev_path_get_entry(bp) &&\r\nbnx2x_prev_path_get_entry(bp)->aer);\r\nup(&bnx2x_prev_sem);\r\n}\r\nif (fw == FW_MSG_CODE_DRV_UNLOAD_COMMON || aer) {\r\nrc = bnx2x_prev_unload_common(bp);\r\nbreak;\r\n}\r\nrc = bnx2x_prev_unload_uncommon(bp);\r\nif (rc != BNX2X_PREV_WAIT_NEEDED)\r\nbreak;\r\nmsleep(20);\r\n} while (--time_counter);\r\nif (!time_counter || rc) {\r\nBNX2X_DEV_INFO("Unloading previous driver did not occur, Possibly due to MF UNDI\n");\r\nrc = -EPROBE_DEFER;\r\n}\r\nif (bnx2x_port_after_undi(bp))\r\nbp->link_params.feature_config_flags |=\r\nFEATURE_CONFIG_BOOT_FROM_SAN;\r\nBNX2X_DEV_INFO("Finished Previous Unload Flow [%d]\n", rc);\r\nreturn rc;\r\n}\r\nstatic void bnx2x_get_common_hwinfo(struct bnx2x *bp)\r\n{\r\nu32 val, val2, val3, val4, id, boot_mode;\r\nu16 pmc;\r\nval = REG_RD(bp, MISC_REG_CHIP_NUM);\r\nid = ((val & 0xffff) << 16);\r\nval = REG_RD(bp, MISC_REG_CHIP_REV);\r\nid |= ((val & 0xf) << 12);\r\nval = REG_RD(bp, PCICFG_OFFSET + PCI_ID_VAL3);\r\nid |= (((val >> 24) & 0xf) << 4);\r\nval = REG_RD(bp, MISC_REG_BOND_ID);\r\nid |= (val & 0xf);\r\nbp->common.chip_id = id;\r\nif (REG_RD(bp, MISC_REG_CHIP_TYPE) & MISC_REG_CHIP_TYPE_57811_MASK) {\r\nif (CHIP_IS_57810(bp))\r\nbp->common.chip_id = (CHIP_NUM_57811 << 16) |\r\n(bp->common.chip_id & 0x0000FFFF);\r\nelse if (CHIP_IS_57810_MF(bp))\r\nbp->common.chip_id = (CHIP_NUM_57811_MF << 16) |\r\n(bp->common.chip_id & 0x0000FFFF);\r\nbp->common.chip_id |= 0x1;\r\n}\r\nbp->db_size = (1 << BNX2X_DB_SHIFT);\r\nif (!CHIP_IS_E1x(bp)) {\r\nval = REG_RD(bp, MISC_REG_PORT4MODE_EN_OVWR);\r\nif ((val & 1) == 0)\r\nval = REG_RD(bp, MISC_REG_PORT4MODE_EN);\r\nelse\r\nval = (val >> 1) & 1;\r\nBNX2X_DEV_INFO("chip is in %s\n", val ? "4_PORT_MODE" :\r\n"2_PORT_MODE");\r\nbp->common.chip_port_mode = val ? CHIP_4_PORT_MODE :\r\nCHIP_2_PORT_MODE;\r\nif (CHIP_MODE_IS_4_PORT(bp))\r\nbp->pfid = (bp->pf_num >> 1);\r\nelse\r\nbp->pfid = (bp->pf_num & 0x6);\r\n} else {\r\nbp->common.chip_port_mode = CHIP_PORT_MODE_NONE;\r\nbp->pfid = bp->pf_num;\r\n}\r\nBNX2X_DEV_INFO("pf_id: %x", bp->pfid);\r\nbp->link_params.chip_id = bp->common.chip_id;\r\nBNX2X_DEV_INFO("chip ID is 0x%x\n", id);\r\nval = (REG_RD(bp, 0x2874) & 0x55);\r\nif ((bp->common.chip_id & 0x1) ||\r\n(CHIP_IS_E1(bp) && val) || (CHIP_IS_E1H(bp) && (val == 0x55))) {\r\nbp->flags |= ONE_PORT_FLAG;\r\nBNX2X_DEV_INFO("single port device\n");\r\n}\r\nval = REG_RD(bp, MCP_REG_MCPR_NVM_CFG4);\r\nbp->common.flash_size = (BNX2X_NVRAM_1MB_SIZE <<\r\n(val & MCPR_NVM_CFG4_FLASH_SIZE));\r\nBNX2X_DEV_INFO("flash_size 0x%x (%d)\n",\r\nbp->common.flash_size, bp->common.flash_size);\r\nbnx2x_init_shmem(bp);\r\nbp->common.shmem2_base = REG_RD(bp, (BP_PATH(bp) ?\r\nMISC_REG_GENERIC_CR_1 :\r\nMISC_REG_GENERIC_CR_0));\r\nbp->link_params.shmem_base = bp->common.shmem_base;\r\nbp->link_params.shmem2_base = bp->common.shmem2_base;\r\nif (SHMEM2_RD(bp, size) >\r\n(u32)offsetof(struct shmem2_region, lfa_host_addr[BP_PORT(bp)]))\r\nbp->link_params.lfa_base =\r\nREG_RD(bp, bp->common.shmem2_base +\r\n(u32)offsetof(struct shmem2_region,\r\nlfa_host_addr[BP_PORT(bp)]));\r\nelse\r\nbp->link_params.lfa_base = 0;\r\nBNX2X_DEV_INFO("shmem offset 0x%x shmem2 offset 0x%x\n",\r\nbp->common.shmem_base, bp->common.shmem2_base);\r\nif (!bp->common.shmem_base) {\r\nBNX2X_DEV_INFO("MCP not active\n");\r\nbp->flags |= NO_MCP_FLAG;\r\nreturn;\r\n}\r\nbp->common.hw_config = SHMEM_RD(bp, dev_info.shared_hw_config.config);\r\nBNX2X_DEV_INFO("hw_config 0x%08x\n", bp->common.hw_config);\r\nbp->link_params.hw_led_mode = ((bp->common.hw_config &\r\nSHARED_HW_CFG_LED_MODE_MASK) >>\r\nSHARED_HW_CFG_LED_MODE_SHIFT);\r\nbp->link_params.feature_config_flags = 0;\r\nval = SHMEM_RD(bp, dev_info.shared_feature_config.config);\r\nif (val & SHARED_FEAT_CFG_OVERRIDE_PREEMPHASIS_CFG_ENABLED)\r\nbp->link_params.feature_config_flags |=\r\nFEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED;\r\nelse\r\nbp->link_params.feature_config_flags &=\r\n~FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED;\r\nval = SHMEM_RD(bp, dev_info.bc_rev) >> 8;\r\nbp->common.bc_ver = val;\r\nBNX2X_DEV_INFO("bc_ver %X\n", val);\r\nif (val < BNX2X_BC_VER) {\r\nBNX2X_ERR("This driver needs bc_ver %X but found %X, please upgrade BC\n",\r\nBNX2X_BC_VER, val);\r\n}\r\nbp->link_params.feature_config_flags |=\r\n(val >= REQ_BC_VER_4_VRFY_FIRST_PHY_OPT_MDL) ?\r\nFEATURE_CONFIG_BC_SUPPORTS_OPT_MDL_VRFY : 0;\r\nbp->link_params.feature_config_flags |=\r\n(val >= REQ_BC_VER_4_VRFY_SPECIFIC_PHY_OPT_MDL) ?\r\nFEATURE_CONFIG_BC_SUPPORTS_DUAL_PHY_OPT_MDL_VRFY : 0;\r\nbp->link_params.feature_config_flags |=\r\n(val >= REQ_BC_VER_4_VRFY_AFEX_SUPPORTED) ?\r\nFEATURE_CONFIG_BC_SUPPORTS_AFEX : 0;\r\nbp->link_params.feature_config_flags |=\r\n(val >= REQ_BC_VER_4_SFP_TX_DISABLE_SUPPORTED) ?\r\nFEATURE_CONFIG_BC_SUPPORTS_SFP_TX_DISABLED : 0;\r\nbp->link_params.feature_config_flags |=\r\n(val >= REQ_BC_VER_4_MT_SUPPORTED) ?\r\nFEATURE_CONFIG_MT_SUPPORT : 0;\r\nbp->flags |= (val >= REQ_BC_VER_4_PFC_STATS_SUPPORTED) ?\r\nBC_SUPPORTS_PFC_STATS : 0;\r\nbp->flags |= (val >= REQ_BC_VER_4_FCOE_FEATURES) ?\r\nBC_SUPPORTS_FCOE_FEATURES : 0;\r\nbp->flags |= (val >= REQ_BC_VER_4_DCBX_ADMIN_MSG_NON_PMF) ?\r\nBC_SUPPORTS_DCBX_MSG_NON_PMF : 0;\r\nbp->flags |= (val >= REQ_BC_VER_4_RMMOD_CMD) ?\r\nBC_SUPPORTS_RMMOD_CMD : 0;\r\nboot_mode = SHMEM_RD(bp,\r\ndev_info.port_feature_config[BP_PORT(bp)].mba_config) &\r\nPORT_FEATURE_MBA_BOOT_AGENT_TYPE_MASK;\r\nswitch (boot_mode) {\r\ncase PORT_FEATURE_MBA_BOOT_AGENT_TYPE_PXE:\r\nbp->common.boot_mode = FEATURE_ETH_BOOTMODE_PXE;\r\nbreak;\r\ncase PORT_FEATURE_MBA_BOOT_AGENT_TYPE_ISCSIB:\r\nbp->common.boot_mode = FEATURE_ETH_BOOTMODE_ISCSI;\r\nbreak;\r\ncase PORT_FEATURE_MBA_BOOT_AGENT_TYPE_FCOE_BOOT:\r\nbp->common.boot_mode = FEATURE_ETH_BOOTMODE_FCOE;\r\nbreak;\r\ncase PORT_FEATURE_MBA_BOOT_AGENT_TYPE_NONE:\r\nbp->common.boot_mode = FEATURE_ETH_BOOTMODE_NONE;\r\nbreak;\r\n}\r\npci_read_config_word(bp->pdev, bp->pdev->pm_cap + PCI_PM_PMC, &pmc);\r\nbp->flags |= (pmc & PCI_PM_CAP_PME_D3cold) ? 0 : NO_WOL_FLAG;\r\nBNX2X_DEV_INFO("%sWoL capable\n",\r\n(bp->flags & NO_WOL_FLAG) ? "not " : "");\r\nval = SHMEM_RD(bp, dev_info.shared_hw_config.part_num);\r\nval2 = SHMEM_RD(bp, dev_info.shared_hw_config.part_num[4]);\r\nval3 = SHMEM_RD(bp, dev_info.shared_hw_config.part_num[8]);\r\nval4 = SHMEM_RD(bp, dev_info.shared_hw_config.part_num[12]);\r\ndev_info(&bp->pdev->dev, "part number %X-%X-%X-%X\n",\r\nval, val2, val3, val4);\r\n}\r\nstatic int bnx2x_get_igu_cam_info(struct bnx2x *bp)\r\n{\r\nint pfid = BP_FUNC(bp);\r\nint igu_sb_id;\r\nu32 val;\r\nu8 fid, igu_sb_cnt = 0;\r\nbp->igu_base_sb = 0xff;\r\nif (CHIP_INT_MODE_IS_BC(bp)) {\r\nint vn = BP_VN(bp);\r\nigu_sb_cnt = bp->igu_sb_cnt;\r\nbp->igu_base_sb = (CHIP_MODE_IS_4_PORT(bp) ? pfid : vn) *\r\nFP_SB_MAX_E1x;\r\nbp->igu_dsb_id = E1HVN_MAX * FP_SB_MAX_E1x +\r\n(CHIP_MODE_IS_4_PORT(bp) ? pfid : vn);\r\nreturn 0;\r\n}\r\nfor (igu_sb_id = 0; igu_sb_id < IGU_REG_MAPPING_MEMORY_SIZE;\r\nigu_sb_id++) {\r\nval = REG_RD(bp, IGU_REG_MAPPING_MEMORY + igu_sb_id * 4);\r\nif (!(val & IGU_REG_MAPPING_MEMORY_VALID))\r\ncontinue;\r\nfid = IGU_FID(val);\r\nif ((fid & IGU_FID_ENCODE_IS_PF)) {\r\nif ((fid & IGU_FID_PF_NUM_MASK) != pfid)\r\ncontinue;\r\nif (IGU_VEC(val) == 0)\r\nbp->igu_dsb_id = igu_sb_id;\r\nelse {\r\nif (bp->igu_base_sb == 0xff)\r\nbp->igu_base_sb = igu_sb_id;\r\nigu_sb_cnt++;\r\n}\r\n}\r\n}\r\n#ifdef CONFIG_PCI_MSI\r\nbp->igu_sb_cnt = min_t(int, bp->igu_sb_cnt, igu_sb_cnt);\r\n#endif\r\nif (igu_sb_cnt == 0) {\r\nBNX2X_ERR("CAM configuration error\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_link_settings_supported(struct bnx2x *bp, u32 switch_cfg)\r\n{\r\nint cfg_size = 0, idx, port = BP_PORT(bp);\r\nbp->port.supported[0] = 0;\r\nbp->port.supported[1] = 0;\r\nswitch (bp->link_params.num_phys) {\r\ncase 1:\r\nbp->port.supported[0] = bp->link_params.phy[INT_PHY].supported;\r\ncfg_size = 1;\r\nbreak;\r\ncase 2:\r\nbp->port.supported[0] = bp->link_params.phy[EXT_PHY1].supported;\r\ncfg_size = 1;\r\nbreak;\r\ncase 3:\r\nif (bp->link_params.multi_phy_config &\r\nPORT_HW_CFG_PHY_SWAPPED_ENABLED) {\r\nbp->port.supported[1] =\r\nbp->link_params.phy[EXT_PHY1].supported;\r\nbp->port.supported[0] =\r\nbp->link_params.phy[EXT_PHY2].supported;\r\n} else {\r\nbp->port.supported[0] =\r\nbp->link_params.phy[EXT_PHY1].supported;\r\nbp->port.supported[1] =\r\nbp->link_params.phy[EXT_PHY2].supported;\r\n}\r\ncfg_size = 2;\r\nbreak;\r\n}\r\nif (!(bp->port.supported[0] || bp->port.supported[1])) {\r\nBNX2X_ERR("NVRAM config error. BAD phy config. PHY1 config 0x%x, PHY2 config 0x%x\n",\r\nSHMEM_RD(bp,\r\ndev_info.port_hw_config[port].external_phy_config),\r\nSHMEM_RD(bp,\r\ndev_info.port_hw_config[port].external_phy_config2));\r\nreturn;\r\n}\r\nif (CHIP_IS_E3(bp))\r\nbp->port.phy_addr = REG_RD(bp, MISC_REG_WC0_CTRL_PHY_ADDR);\r\nelse {\r\nswitch (switch_cfg) {\r\ncase SWITCH_CFG_1G:\r\nbp->port.phy_addr = REG_RD(\r\nbp, NIG_REG_SERDES0_CTRL_PHY_ADDR + port*0x10);\r\nbreak;\r\ncase SWITCH_CFG_10G:\r\nbp->port.phy_addr = REG_RD(\r\nbp, NIG_REG_XGXS0_CTRL_PHY_ADDR + port*0x18);\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("BAD switch_cfg link_config 0x%x\n",\r\nbp->port.link_config[0]);\r\nreturn;\r\n}\r\n}\r\nBNX2X_DEV_INFO("phy_addr 0x%x\n", bp->port.phy_addr);\r\nfor (idx = 0; idx < cfg_size; idx++) {\r\nif (!(bp->link_params.speed_cap_mask[idx] &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF))\r\nbp->port.supported[idx] &= ~SUPPORTED_10baseT_Half;\r\nif (!(bp->link_params.speed_cap_mask[idx] &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL))\r\nbp->port.supported[idx] &= ~SUPPORTED_10baseT_Full;\r\nif (!(bp->link_params.speed_cap_mask[idx] &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF))\r\nbp->port.supported[idx] &= ~SUPPORTED_100baseT_Half;\r\nif (!(bp->link_params.speed_cap_mask[idx] &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL))\r\nbp->port.supported[idx] &= ~SUPPORTED_100baseT_Full;\r\nif (!(bp->link_params.speed_cap_mask[idx] &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_1G))\r\nbp->port.supported[idx] &= ~(SUPPORTED_1000baseT_Half |\r\nSUPPORTED_1000baseT_Full);\r\nif (!(bp->link_params.speed_cap_mask[idx] &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G))\r\nbp->port.supported[idx] &= ~SUPPORTED_2500baseX_Full;\r\nif (!(bp->link_params.speed_cap_mask[idx] &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10G))\r\nbp->port.supported[idx] &= ~SUPPORTED_10000baseT_Full;\r\nif (!(bp->link_params.speed_cap_mask[idx] &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_20G))\r\nbp->port.supported[idx] &= ~SUPPORTED_20000baseKR2_Full;\r\n}\r\nBNX2X_DEV_INFO("supported 0x%x 0x%x\n", bp->port.supported[0],\r\nbp->port.supported[1]);\r\n}\r\nstatic void bnx2x_link_settings_requested(struct bnx2x *bp)\r\n{\r\nu32 link_config, idx, cfg_size = 0;\r\nbp->port.advertising[0] = 0;\r\nbp->port.advertising[1] = 0;\r\nswitch (bp->link_params.num_phys) {\r\ncase 1:\r\ncase 2:\r\ncfg_size = 1;\r\nbreak;\r\ncase 3:\r\ncfg_size = 2;\r\nbreak;\r\n}\r\nfor (idx = 0; idx < cfg_size; idx++) {\r\nbp->link_params.req_duplex[idx] = DUPLEX_FULL;\r\nlink_config = bp->port.link_config[idx];\r\nswitch (link_config & PORT_FEATURE_LINK_SPEED_MASK) {\r\ncase PORT_FEATURE_LINK_SPEED_AUTO:\r\nif (bp->port.supported[idx] & SUPPORTED_Autoneg) {\r\nbp->link_params.req_line_speed[idx] =\r\nSPEED_AUTO_NEG;\r\nbp->port.advertising[idx] |=\r\nbp->port.supported[idx];\r\nif (bp->link_params.phy[EXT_PHY1].type ==\r\nPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833)\r\nbp->port.advertising[idx] |=\r\n(SUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full);\r\n} else {\r\nbp->link_params.req_line_speed[idx] =\r\nSPEED_10000;\r\nbp->port.advertising[idx] |=\r\n(ADVERTISED_10000baseT_Full |\r\nADVERTISED_FIBRE);\r\ncontinue;\r\n}\r\nbreak;\r\ncase PORT_FEATURE_LINK_SPEED_10M_FULL:\r\nif (bp->port.supported[idx] & SUPPORTED_10baseT_Full) {\r\nbp->link_params.req_line_speed[idx] =\r\nSPEED_10;\r\nbp->port.advertising[idx] |=\r\n(ADVERTISED_10baseT_Full |\r\nADVERTISED_TP);\r\n} else {\r\nBNX2X_ERR("NVRAM config error. Invalid link_config 0x%x speed_cap_mask 0x%x\n",\r\nlink_config,\r\nbp->link_params.speed_cap_mask[idx]);\r\nreturn;\r\n}\r\nbreak;\r\ncase PORT_FEATURE_LINK_SPEED_10M_HALF:\r\nif (bp->port.supported[idx] & SUPPORTED_10baseT_Half) {\r\nbp->link_params.req_line_speed[idx] =\r\nSPEED_10;\r\nbp->link_params.req_duplex[idx] =\r\nDUPLEX_HALF;\r\nbp->port.advertising[idx] |=\r\n(ADVERTISED_10baseT_Half |\r\nADVERTISED_TP);\r\n} else {\r\nBNX2X_ERR("NVRAM config error. Invalid link_config 0x%x speed_cap_mask 0x%x\n",\r\nlink_config,\r\nbp->link_params.speed_cap_mask[idx]);\r\nreturn;\r\n}\r\nbreak;\r\ncase PORT_FEATURE_LINK_SPEED_100M_FULL:\r\nif (bp->port.supported[idx] &\r\nSUPPORTED_100baseT_Full) {\r\nbp->link_params.req_line_speed[idx] =\r\nSPEED_100;\r\nbp->port.advertising[idx] |=\r\n(ADVERTISED_100baseT_Full |\r\nADVERTISED_TP);\r\n} else {\r\nBNX2X_ERR("NVRAM config error. Invalid link_config 0x%x speed_cap_mask 0x%x\n",\r\nlink_config,\r\nbp->link_params.speed_cap_mask[idx]);\r\nreturn;\r\n}\r\nbreak;\r\ncase PORT_FEATURE_LINK_SPEED_100M_HALF:\r\nif (bp->port.supported[idx] &\r\nSUPPORTED_100baseT_Half) {\r\nbp->link_params.req_line_speed[idx] =\r\nSPEED_100;\r\nbp->link_params.req_duplex[idx] =\r\nDUPLEX_HALF;\r\nbp->port.advertising[idx] |=\r\n(ADVERTISED_100baseT_Half |\r\nADVERTISED_TP);\r\n} else {\r\nBNX2X_ERR("NVRAM config error. Invalid link_config 0x%x speed_cap_mask 0x%x\n",\r\nlink_config,\r\nbp->link_params.speed_cap_mask[idx]);\r\nreturn;\r\n}\r\nbreak;\r\ncase PORT_FEATURE_LINK_SPEED_1G:\r\nif (bp->port.supported[idx] &\r\nSUPPORTED_1000baseT_Full) {\r\nbp->link_params.req_line_speed[idx] =\r\nSPEED_1000;\r\nbp->port.advertising[idx] |=\r\n(ADVERTISED_1000baseT_Full |\r\nADVERTISED_TP);\r\n} else if (bp->port.supported[idx] &\r\nSUPPORTED_1000baseKX_Full) {\r\nbp->link_params.req_line_speed[idx] =\r\nSPEED_1000;\r\nbp->port.advertising[idx] |=\r\nADVERTISED_1000baseKX_Full;\r\n} else {\r\nBNX2X_ERR("NVRAM config error. Invalid link_config 0x%x speed_cap_mask 0x%x\n",\r\nlink_config,\r\nbp->link_params.speed_cap_mask[idx]);\r\nreturn;\r\n}\r\nbreak;\r\ncase PORT_FEATURE_LINK_SPEED_2_5G:\r\nif (bp->port.supported[idx] &\r\nSUPPORTED_2500baseX_Full) {\r\nbp->link_params.req_line_speed[idx] =\r\nSPEED_2500;\r\nbp->port.advertising[idx] |=\r\n(ADVERTISED_2500baseX_Full |\r\nADVERTISED_TP);\r\n} else {\r\nBNX2X_ERR("NVRAM config error. Invalid link_config 0x%x speed_cap_mask 0x%x\n",\r\nlink_config,\r\nbp->link_params.speed_cap_mask[idx]);\r\nreturn;\r\n}\r\nbreak;\r\ncase PORT_FEATURE_LINK_SPEED_10G_CX4:\r\nif (bp->port.supported[idx] &\r\nSUPPORTED_10000baseT_Full) {\r\nbp->link_params.req_line_speed[idx] =\r\nSPEED_10000;\r\nbp->port.advertising[idx] |=\r\n(ADVERTISED_10000baseT_Full |\r\nADVERTISED_FIBRE);\r\n} else if (bp->port.supported[idx] &\r\nSUPPORTED_10000baseKR_Full) {\r\nbp->link_params.req_line_speed[idx] =\r\nSPEED_10000;\r\nbp->port.advertising[idx] |=\r\n(ADVERTISED_10000baseKR_Full |\r\nADVERTISED_FIBRE);\r\n} else {\r\nBNX2X_ERR("NVRAM config error. Invalid link_config 0x%x speed_cap_mask 0x%x\n",\r\nlink_config,\r\nbp->link_params.speed_cap_mask[idx]);\r\nreturn;\r\n}\r\nbreak;\r\ncase PORT_FEATURE_LINK_SPEED_20G:\r\nbp->link_params.req_line_speed[idx] = SPEED_20000;\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("NVRAM config error. BAD link speed link_config 0x%x\n",\r\nlink_config);\r\nbp->link_params.req_line_speed[idx] =\r\nSPEED_AUTO_NEG;\r\nbp->port.advertising[idx] =\r\nbp->port.supported[idx];\r\nbreak;\r\n}\r\nbp->link_params.req_flow_ctrl[idx] = (link_config &\r\nPORT_FEATURE_FLOW_CONTROL_MASK);\r\nif (bp->link_params.req_flow_ctrl[idx] ==\r\nBNX2X_FLOW_CTRL_AUTO) {\r\nif (!(bp->port.supported[idx] & SUPPORTED_Autoneg))\r\nbp->link_params.req_flow_ctrl[idx] =\r\nBNX2X_FLOW_CTRL_NONE;\r\nelse\r\nbnx2x_set_requested_fc(bp);\r\n}\r\nBNX2X_DEV_INFO("req_line_speed %d req_duplex %d req_flow_ctrl 0x%x advertising 0x%x\n",\r\nbp->link_params.req_line_speed[idx],\r\nbp->link_params.req_duplex[idx],\r\nbp->link_params.req_flow_ctrl[idx],\r\nbp->port.advertising[idx]);\r\n}\r\n}\r\nstatic void bnx2x_set_mac_buf(u8 *mac_buf, u32 mac_lo, u16 mac_hi)\r\n{\r\n__be16 mac_hi_be = cpu_to_be16(mac_hi);\r\n__be32 mac_lo_be = cpu_to_be32(mac_lo);\r\nmemcpy(mac_buf, &mac_hi_be, sizeof(mac_hi_be));\r\nmemcpy(mac_buf + sizeof(mac_hi_be), &mac_lo_be, sizeof(mac_lo_be));\r\n}\r\nstatic void bnx2x_get_port_hwinfo(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nu32 config;\r\nu32 ext_phy_type, ext_phy_config, eee_mode;\r\nbp->link_params.bp = bp;\r\nbp->link_params.port = port;\r\nbp->link_params.lane_config =\r\nSHMEM_RD(bp, dev_info.port_hw_config[port].lane_config);\r\nbp->link_params.speed_cap_mask[0] =\r\nSHMEM_RD(bp,\r\ndev_info.port_hw_config[port].speed_capability_mask) &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_MASK;\r\nbp->link_params.speed_cap_mask[1] =\r\nSHMEM_RD(bp,\r\ndev_info.port_hw_config[port].speed_capability_mask2) &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_MASK;\r\nbp->port.link_config[0] =\r\nSHMEM_RD(bp, dev_info.port_feature_config[port].link_config);\r\nbp->port.link_config[1] =\r\nSHMEM_RD(bp, dev_info.port_feature_config[port].link_config2);\r\nbp->link_params.multi_phy_config =\r\nSHMEM_RD(bp, dev_info.port_hw_config[port].multi_phy_config);\r\nconfig = SHMEM_RD(bp, dev_info.port_feature_config[port].config);\r\nbp->wol = (!(bp->flags & NO_WOL_FLAG) &&\r\n(config & PORT_FEATURE_WOL_ENABLED));\r\nif ((config & PORT_FEAT_CFG_STORAGE_PERSONALITY_MASK) ==\r\nPORT_FEAT_CFG_STORAGE_PERSONALITY_FCOE && !IS_MF(bp))\r\nbp->flags |= NO_ISCSI_FLAG;\r\nif ((config & PORT_FEAT_CFG_STORAGE_PERSONALITY_MASK) ==\r\nPORT_FEAT_CFG_STORAGE_PERSONALITY_ISCSI && !(IS_MF(bp)))\r\nbp->flags |= NO_FCOE_FLAG;\r\nBNX2X_DEV_INFO("lane_config 0x%08x speed_cap_mask0 0x%08x link_config0 0x%08x\n",\r\nbp->link_params.lane_config,\r\nbp->link_params.speed_cap_mask[0],\r\nbp->port.link_config[0]);\r\nbp->link_params.switch_cfg = (bp->port.link_config[0] &\r\nPORT_FEATURE_CONNECTED_SWITCH_MASK);\r\nbnx2x_phy_probe(&bp->link_params);\r\nbnx2x_link_settings_supported(bp, bp->link_params.switch_cfg);\r\nbnx2x_link_settings_requested(bp);\r\next_phy_config =\r\nSHMEM_RD(bp,\r\ndev_info.port_hw_config[port].external_phy_config);\r\next_phy_type = XGXS_EXT_PHY_TYPE(ext_phy_config);\r\nif (ext_phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT)\r\nbp->mdio.prtad = bp->port.phy_addr;\r\nelse if ((ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE) &&\r\n(ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN))\r\nbp->mdio.prtad =\r\nXGXS_EXT_PHY_ADDR(ext_phy_config);\r\neee_mode = (((SHMEM_RD(bp, dev_info.\r\nport_feature_config[port].eee_power_mode)) &\r\nPORT_FEAT_CFG_EEE_POWER_MODE_MASK) >>\r\nPORT_FEAT_CFG_EEE_POWER_MODE_SHIFT);\r\nif (eee_mode != PORT_FEAT_CFG_EEE_POWER_MODE_DISABLED) {\r\nbp->link_params.eee_mode = EEE_MODE_ADV_LPI |\r\nEEE_MODE_ENABLE_LPI |\r\nEEE_MODE_OUTPUT_TIME;\r\n} else {\r\nbp->link_params.eee_mode = 0;\r\n}\r\n}\r\nvoid bnx2x_get_iscsi_info(struct bnx2x *bp)\r\n{\r\nu32 no_flags = NO_ISCSI_FLAG;\r\nint port = BP_PORT(bp);\r\nu32 max_iscsi_conn = FW_ENCODE_32BIT_PATTERN ^ SHMEM_RD(bp,\r\ndrv_lic_key[port].max_iscsi_conn);\r\nif (!CNIC_SUPPORT(bp)) {\r\nbp->flags |= no_flags;\r\nreturn;\r\n}\r\nbp->cnic_eth_dev.max_iscsi_conn =\r\n(max_iscsi_conn & BNX2X_MAX_ISCSI_INIT_CONN_MASK) >>\r\nBNX2X_MAX_ISCSI_INIT_CONN_SHIFT;\r\nBNX2X_DEV_INFO("max_iscsi_conn 0x%x\n",\r\nbp->cnic_eth_dev.max_iscsi_conn);\r\nif (!bp->cnic_eth_dev.max_iscsi_conn)\r\nbp->flags |= no_flags;\r\n}\r\nstatic void bnx2x_get_ext_wwn_info(struct bnx2x *bp, int func)\r\n{\r\nbp->cnic_eth_dev.fcoe_wwn_port_name_hi =\r\nMF_CFG_RD(bp, func_ext_config[func].fcoe_wwn_port_name_upper);\r\nbp->cnic_eth_dev.fcoe_wwn_port_name_lo =\r\nMF_CFG_RD(bp, func_ext_config[func].fcoe_wwn_port_name_lower);\r\nbp->cnic_eth_dev.fcoe_wwn_node_name_hi =\r\nMF_CFG_RD(bp, func_ext_config[func].fcoe_wwn_node_name_upper);\r\nbp->cnic_eth_dev.fcoe_wwn_node_name_lo =\r\nMF_CFG_RD(bp, func_ext_config[func].fcoe_wwn_node_name_lower);\r\n}\r\nstatic int bnx2x_shared_fcoe_funcs(struct bnx2x *bp)\r\n{\r\nu8 count = 0;\r\nif (IS_MF(bp)) {\r\nu8 fid;\r\nfor (fid = BP_PATH(bp); fid < E2_FUNC_MAX * 2; fid += 2) {\r\nif (IS_MF_SD(bp)) {\r\nu32 cfg = MF_CFG_RD(bp,\r\nfunc_mf_config[fid].config);\r\nif (!(cfg & FUNC_MF_CFG_FUNC_HIDE) &&\r\n((cfg & FUNC_MF_CFG_PROTOCOL_MASK) ==\r\nFUNC_MF_CFG_PROTOCOL_FCOE))\r\ncount++;\r\n} else {\r\nu32 cfg = MF_CFG_RD(bp,\r\nfunc_ext_config[fid].\r\nfunc_cfg);\r\nif ((cfg & MACP_FUNC_CFG_FLAGS_ENABLED) &&\r\n(cfg & MACP_FUNC_CFG_FLAGS_FCOE_OFFLOAD))\r\ncount++;\r\n}\r\n}\r\n} else {\r\nint port, port_cnt = CHIP_MODE_IS_4_PORT(bp) ? 2 : 1;\r\nfor (port = 0; port < port_cnt; port++) {\r\nu32 lic = SHMEM_RD(bp,\r\ndrv_lic_key[port].max_fcoe_conn) ^\r\nFW_ENCODE_32BIT_PATTERN;\r\nif (lic)\r\ncount++;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic void bnx2x_get_fcoe_info(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nint func = BP_ABS_FUNC(bp);\r\nu32 max_fcoe_conn = FW_ENCODE_32BIT_PATTERN ^ SHMEM_RD(bp,\r\ndrv_lic_key[port].max_fcoe_conn);\r\nu8 num_fcoe_func = bnx2x_shared_fcoe_funcs(bp);\r\nif (!CNIC_SUPPORT(bp)) {\r\nbp->flags |= NO_FCOE_FLAG;\r\nreturn;\r\n}\r\nbp->cnic_eth_dev.max_fcoe_conn =\r\n(max_fcoe_conn & BNX2X_MAX_FCOE_INIT_CONN_MASK) >>\r\nBNX2X_MAX_FCOE_INIT_CONN_SHIFT;\r\nbp->cnic_eth_dev.max_fcoe_exchanges = MAX_NUM_FCOE_TASKS_PER_ENGINE;\r\nif (num_fcoe_func)\r\nbp->cnic_eth_dev.max_fcoe_exchanges /= num_fcoe_func;\r\nif (!IS_MF(bp)) {\r\nbp->cnic_eth_dev.fcoe_wwn_port_name_hi =\r\nSHMEM_RD(bp,\r\ndev_info.port_hw_config[port].\r\nfcoe_wwn_port_name_upper);\r\nbp->cnic_eth_dev.fcoe_wwn_port_name_lo =\r\nSHMEM_RD(bp,\r\ndev_info.port_hw_config[port].\r\nfcoe_wwn_port_name_lower);\r\nbp->cnic_eth_dev.fcoe_wwn_node_name_hi =\r\nSHMEM_RD(bp,\r\ndev_info.port_hw_config[port].\r\nfcoe_wwn_node_name_upper);\r\nbp->cnic_eth_dev.fcoe_wwn_node_name_lo =\r\nSHMEM_RD(bp,\r\ndev_info.port_hw_config[port].\r\nfcoe_wwn_node_name_lower);\r\n} else if (!IS_MF_SD(bp)) {\r\nif (BNX2X_HAS_MF_EXT_PROTOCOL_FCOE(bp))\r\nbnx2x_get_ext_wwn_info(bp, func);\r\n} else {\r\nif (BNX2X_IS_MF_SD_PROTOCOL_FCOE(bp) && !CHIP_IS_E1x(bp))\r\nbnx2x_get_ext_wwn_info(bp, func);\r\n}\r\nBNX2X_DEV_INFO("max_fcoe_conn 0x%x\n", bp->cnic_eth_dev.max_fcoe_conn);\r\nif (!bp->cnic_eth_dev.max_fcoe_conn)\r\nbp->flags |= NO_FCOE_FLAG;\r\n}\r\nstatic void bnx2x_get_cnic_info(struct bnx2x *bp)\r\n{\r\nbnx2x_get_iscsi_info(bp);\r\nbnx2x_get_fcoe_info(bp);\r\n}\r\nstatic void bnx2x_get_cnic_mac_hwinfo(struct bnx2x *bp)\r\n{\r\nu32 val, val2;\r\nint func = BP_ABS_FUNC(bp);\r\nint port = BP_PORT(bp);\r\nu8 *iscsi_mac = bp->cnic_eth_dev.iscsi_mac;\r\nu8 *fip_mac = bp->fip_mac;\r\nif (IS_MF(bp)) {\r\nif (!IS_MF_SD(bp)) {\r\nu32 cfg = MF_CFG_RD(bp, func_ext_config[func].func_cfg);\r\nif (cfg & MACP_FUNC_CFG_FLAGS_ISCSI_OFFLOAD) {\r\nval2 = MF_CFG_RD(bp, func_ext_config[func].\r\niscsi_mac_addr_upper);\r\nval = MF_CFG_RD(bp, func_ext_config[func].\r\niscsi_mac_addr_lower);\r\nbnx2x_set_mac_buf(iscsi_mac, val, val2);\r\nBNX2X_DEV_INFO\r\n("Read iSCSI MAC: %pM\n", iscsi_mac);\r\n} else {\r\nbp->flags |= NO_ISCSI_OOO_FLAG | NO_ISCSI_FLAG;\r\n}\r\nif (cfg & MACP_FUNC_CFG_FLAGS_FCOE_OFFLOAD) {\r\nval2 = MF_CFG_RD(bp, func_ext_config[func].\r\nfcoe_mac_addr_upper);\r\nval = MF_CFG_RD(bp, func_ext_config[func].\r\nfcoe_mac_addr_lower);\r\nbnx2x_set_mac_buf(fip_mac, val, val2);\r\nBNX2X_DEV_INFO\r\n("Read FCoE L2 MAC: %pM\n", fip_mac);\r\n} else {\r\nbp->flags |= NO_FCOE_FLAG;\r\n}\r\nbp->mf_ext_config = cfg;\r\n} else {\r\nif (BNX2X_IS_MF_SD_PROTOCOL_ISCSI(bp)) {\r\nmemcpy(iscsi_mac, bp->dev->dev_addr, ETH_ALEN);\r\nBNX2X_DEV_INFO("SD ISCSI MODE\n");\r\nBNX2X_DEV_INFO\r\n("Read iSCSI MAC: %pM\n", iscsi_mac);\r\n} else if (BNX2X_IS_MF_SD_PROTOCOL_FCOE(bp)) {\r\nmemcpy(fip_mac, bp->dev->dev_addr, ETH_ALEN);\r\nBNX2X_DEV_INFO("SD FCoE MODE\n");\r\nBNX2X_DEV_INFO\r\n("Read FIP MAC: %pM\n", fip_mac);\r\n}\r\n}\r\nif (IS_MF_FCOE_AFEX(bp))\r\nmemcpy(bp->dev->dev_addr, fip_mac, ETH_ALEN);\r\n} else {\r\nval2 = SHMEM_RD(bp, dev_info.port_hw_config[port].\r\niscsi_mac_upper);\r\nval = SHMEM_RD(bp, dev_info.port_hw_config[port].\r\niscsi_mac_lower);\r\nbnx2x_set_mac_buf(iscsi_mac, val, val2);\r\nval2 = SHMEM_RD(bp, dev_info.port_hw_config[port].\r\nfcoe_fip_mac_upper);\r\nval = SHMEM_RD(bp, dev_info.port_hw_config[port].\r\nfcoe_fip_mac_lower);\r\nbnx2x_set_mac_buf(fip_mac, val, val2);\r\n}\r\nif (!is_valid_ether_addr(iscsi_mac)) {\r\nbp->flags |= NO_ISCSI_OOO_FLAG | NO_ISCSI_FLAG;\r\neth_zero_addr(iscsi_mac);\r\n}\r\nif (!is_valid_ether_addr(fip_mac)) {\r\nbp->flags |= NO_FCOE_FLAG;\r\neth_zero_addr(bp->fip_mac);\r\n}\r\n}\r\nstatic void bnx2x_get_mac_hwinfo(struct bnx2x *bp)\r\n{\r\nu32 val, val2;\r\nint func = BP_ABS_FUNC(bp);\r\nint port = BP_PORT(bp);\r\neth_zero_addr(bp->dev->dev_addr);\r\nif (BP_NOMCP(bp)) {\r\nBNX2X_ERROR("warning: random MAC workaround active\n");\r\neth_hw_addr_random(bp->dev);\r\n} else if (IS_MF(bp)) {\r\nval2 = MF_CFG_RD(bp, func_mf_config[func].mac_upper);\r\nval = MF_CFG_RD(bp, func_mf_config[func].mac_lower);\r\nif ((val2 != FUNC_MF_CFG_UPPERMAC_DEFAULT) &&\r\n(val != FUNC_MF_CFG_LOWERMAC_DEFAULT))\r\nbnx2x_set_mac_buf(bp->dev->dev_addr, val, val2);\r\nif (CNIC_SUPPORT(bp))\r\nbnx2x_get_cnic_mac_hwinfo(bp);\r\n} else {\r\nval2 = SHMEM_RD(bp, dev_info.port_hw_config[port].mac_upper);\r\nval = SHMEM_RD(bp, dev_info.port_hw_config[port].mac_lower);\r\nbnx2x_set_mac_buf(bp->dev->dev_addr, val, val2);\r\nif (CNIC_SUPPORT(bp))\r\nbnx2x_get_cnic_mac_hwinfo(bp);\r\n}\r\nif (!BP_NOMCP(bp)) {\r\nval2 = SHMEM_RD(bp, dev_info.port_hw_config[port].mac_upper);\r\nval = SHMEM_RD(bp, dev_info.port_hw_config[port].mac_lower);\r\nbnx2x_set_mac_buf(bp->phys_port_id, val, val2);\r\nbp->flags |= HAS_PHYS_PORT_ID;\r\n}\r\nmemcpy(bp->link_params.mac_addr, bp->dev->dev_addr, ETH_ALEN);\r\nif (!is_valid_ether_addr(bp->dev->dev_addr))\r\ndev_err(&bp->pdev->dev,\r\n"bad Ethernet MAC address configuration: %pM\n"\r\n"change it manually before bringing up the appropriate network interface\n",\r\nbp->dev->dev_addr);\r\n}\r\nstatic bool bnx2x_get_dropless_info(struct bnx2x *bp)\r\n{\r\nint tmp;\r\nu32 cfg;\r\nif (IS_VF(bp))\r\nreturn false;\r\nif (IS_MF(bp) && !CHIP_IS_E1x(bp)) {\r\ntmp = BP_ABS_FUNC(bp);\r\ncfg = MF_CFG_RD(bp, func_ext_config[tmp].func_cfg);\r\ncfg = !!(cfg & MACP_FUNC_CFG_PAUSE_ON_HOST_RING);\r\n} else {\r\ntmp = BP_PORT(bp);\r\ncfg = SHMEM_RD(bp,\r\ndev_info.port_hw_config[tmp].generic_features);\r\ncfg = !!(cfg & PORT_HW_CFG_PAUSE_ON_HOST_RING_ENABLED);\r\n}\r\nreturn cfg;\r\n}\r\nstatic void validate_set_si_mode(struct bnx2x *bp)\r\n{\r\nu8 func = BP_ABS_FUNC(bp);\r\nu32 val;\r\nval = MF_CFG_RD(bp, func_mf_config[func].mac_upper);\r\nif (val != 0xffff) {\r\nbp->mf_mode = MULTI_FUNCTION_SI;\r\nbp->mf_config[BP_VN(bp)] =\r\nMF_CFG_RD(bp, func_mf_config[func].config);\r\n} else\r\nBNX2X_DEV_INFO("illegal MAC address for SI\n");\r\n}\r\nstatic int bnx2x_get_hwinfo(struct bnx2x *bp)\r\n{\r\nint func = BP_ABS_FUNC(bp);\r\nint vn, mfw_vn;\r\nu32 val = 0, val2 = 0;\r\nint rc = 0;\r\nif (REG_RD(bp, MISC_REG_CHIP_NUM) == 0xffffffff) {\r\ndev_err(&bp->pdev->dev,\r\n"Chip read returns all Fs. Preventing probe from continuing\n");\r\nreturn -EINVAL;\r\n}\r\nbnx2x_get_common_hwinfo(bp);\r\nif (CHIP_IS_E1x(bp)) {\r\nbp->common.int_block = INT_BLOCK_HC;\r\nbp->igu_dsb_id = DEF_SB_IGU_ID;\r\nbp->igu_base_sb = 0;\r\n} else {\r\nbp->common.int_block = INT_BLOCK_IGU;\r\nbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RESET);\r\nval = REG_RD(bp, IGU_REG_BLOCK_CONFIGURATION);\r\nif (val & IGU_BLOCK_CONFIGURATION_REG_BACKWARD_COMP_EN) {\r\nint tout = 5000;\r\nBNX2X_DEV_INFO("FORCING Normal Mode\n");\r\nval &= ~(IGU_BLOCK_CONFIGURATION_REG_BACKWARD_COMP_EN);\r\nREG_WR(bp, IGU_REG_BLOCK_CONFIGURATION, val);\r\nREG_WR(bp, IGU_REG_RESET_MEMORIES, 0x7f);\r\nwhile (tout && REG_RD(bp, IGU_REG_RESET_MEMORIES)) {\r\ntout--;\r\nusleep_range(1000, 2000);\r\n}\r\nif (REG_RD(bp, IGU_REG_RESET_MEMORIES)) {\r\ndev_err(&bp->pdev->dev,\r\n"FORCING Normal Mode failed!!!\n");\r\nbnx2x_release_hw_lock(bp,\r\nHW_LOCK_RESOURCE_RESET);\r\nreturn -EPERM;\r\n}\r\n}\r\nif (val & IGU_BLOCK_CONFIGURATION_REG_BACKWARD_COMP_EN) {\r\nBNX2X_DEV_INFO("IGU Backward Compatible Mode\n");\r\nbp->common.int_block |= INT_BLOCK_MODE_BW_COMP;\r\n} else\r\nBNX2X_DEV_INFO("IGU Normal Mode\n");\r\nrc = bnx2x_get_igu_cam_info(bp);\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RESET);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (CHIP_IS_E1x(bp))\r\nbp->base_fw_ndsb = BP_PORT(bp) * FP_SB_MAX_E1x + BP_L_ID(bp);\r\nelse\r\nbp->base_fw_ndsb = bp->igu_base_sb;\r\nBNX2X_DEV_INFO("igu_dsb_id %d igu_base_sb %d igu_sb_cnt %d\n"\r\n"base_fw_ndsb %d\n", bp->igu_dsb_id, bp->igu_base_sb,\r\nbp->igu_sb_cnt, bp->base_fw_ndsb);\r\nbp->mf_ov = 0;\r\nbp->mf_mode = 0;\r\nbp->mf_sub_mode = 0;\r\nvn = BP_VN(bp);\r\nmfw_vn = BP_FW_MB_IDX(bp);\r\nif (!CHIP_IS_E1(bp) && !BP_NOMCP(bp)) {\r\nBNX2X_DEV_INFO("shmem2base 0x%x, size %d, mfcfg offset %d\n",\r\nbp->common.shmem2_base, SHMEM2_RD(bp, size),\r\n(u32)offsetof(struct shmem2_region, mf_cfg_addr));\r\nif (SHMEM2_HAS(bp, mf_cfg_addr))\r\nbp->common.mf_cfg_base = SHMEM2_RD(bp, mf_cfg_addr);\r\nelse\r\nbp->common.mf_cfg_base = bp->common.shmem_base +\r\noffsetof(struct shmem_region, func_mb) +\r\nE1H_FUNC_MAX * sizeof(struct drv_func_mb);\r\nif (bp->common.mf_cfg_base != SHMEM_MF_CFG_ADDR_NONE) {\r\nval = SHMEM_RD(bp,\r\ndev_info.shared_feature_config.config);\r\nval &= SHARED_FEAT_CFG_FORCE_SF_MODE_MASK;\r\nswitch (val) {\r\ncase SHARED_FEAT_CFG_FORCE_SF_MODE_SWITCH_INDEPT:\r\nvalidate_set_si_mode(bp);\r\nbreak;\r\ncase SHARED_FEAT_CFG_FORCE_SF_MODE_AFEX_MODE:\r\nif ((!CHIP_IS_E1x(bp)) &&\r\n(MF_CFG_RD(bp, func_mf_config[func].\r\nmac_upper) != 0xffff) &&\r\n(SHMEM2_HAS(bp,\r\nafex_driver_support))) {\r\nbp->mf_mode = MULTI_FUNCTION_AFEX;\r\nbp->mf_config[vn] = MF_CFG_RD(bp,\r\nfunc_mf_config[func].config);\r\n} else {\r\nBNX2X_DEV_INFO("can not configure afex mode\n");\r\n}\r\nbreak;\r\ncase SHARED_FEAT_CFG_FORCE_SF_MODE_MF_ALLOWED:\r\nval = MF_CFG_RD(bp,\r\nfunc_mf_config[FUNC_0].e1hov_tag);\r\nval &= FUNC_MF_CFG_E1HOV_TAG_MASK;\r\nif (val != FUNC_MF_CFG_E1HOV_TAG_DEFAULT) {\r\nbp->mf_mode = MULTI_FUNCTION_SD;\r\nbp->mf_config[vn] = MF_CFG_RD(bp,\r\nfunc_mf_config[func].config);\r\n} else\r\nBNX2X_DEV_INFO("illegal OV for SD\n");\r\nbreak;\r\ncase SHARED_FEAT_CFG_FORCE_SF_MODE_BD_MODE:\r\nbp->mf_mode = MULTI_FUNCTION_SD;\r\nbp->mf_sub_mode = SUB_MF_MODE_BD;\r\nbp->mf_config[vn] =\r\nMF_CFG_RD(bp,\r\nfunc_mf_config[func].config);\r\nif (SHMEM2_HAS(bp, mtu_size)) {\r\nint mtu_idx = BP_FW_MB_IDX(bp);\r\nu16 mtu_size;\r\nu32 mtu;\r\nmtu = SHMEM2_RD(bp, mtu_size[mtu_idx]);\r\nmtu_size = (u16)mtu;\r\nDP(NETIF_MSG_IFUP, "Read MTU size %04x [%08x]\n",\r\nmtu_size, mtu);\r\nif ((mtu_size >= ETH_MIN_PACKET_SIZE) &&\r\n(mtu_size <=\r\nETH_MAX_JUMBO_PACKET_SIZE))\r\nbp->dev->mtu = mtu_size;\r\n}\r\nbreak;\r\ncase SHARED_FEAT_CFG_FORCE_SF_MODE_UFP_MODE:\r\nbp->mf_mode = MULTI_FUNCTION_SD;\r\nbp->mf_sub_mode = SUB_MF_MODE_UFP;\r\nbp->mf_config[vn] =\r\nMF_CFG_RD(bp,\r\nfunc_mf_config[func].config);\r\nbreak;\r\ncase SHARED_FEAT_CFG_FORCE_SF_MODE_FORCED_SF:\r\nbp->mf_config[vn] = 0;\r\nbreak;\r\ncase SHARED_FEAT_CFG_FORCE_SF_MODE_EXTENDED_MODE:\r\nval2 = SHMEM_RD(bp,\r\ndev_info.shared_hw_config.config_3);\r\nval2 &= SHARED_HW_CFG_EXTENDED_MF_MODE_MASK;\r\nswitch (val2) {\r\ncase SHARED_HW_CFG_EXTENDED_MF_MODE_NPAR1_DOT_5:\r\nvalidate_set_si_mode(bp);\r\nbp->mf_sub_mode =\r\nSUB_MF_MODE_NPAR1_DOT_5;\r\nbreak;\r\ndefault:\r\nbp->mf_config[vn] = 0;\r\nBNX2X_DEV_INFO("unknown extended MF mode 0x%x\n",\r\nval);\r\n}\r\nbreak;\r\ndefault:\r\nbp->mf_config[vn] = 0;\r\nBNX2X_DEV_INFO("unknown MF mode 0x%x\n", val);\r\n}\r\n}\r\nBNX2X_DEV_INFO("%s function mode\n",\r\nIS_MF(bp) ? "multi" : "single");\r\nswitch (bp->mf_mode) {\r\ncase MULTI_FUNCTION_SD:\r\nval = MF_CFG_RD(bp, func_mf_config[func].e1hov_tag) &\r\nFUNC_MF_CFG_E1HOV_TAG_MASK;\r\nif (val != FUNC_MF_CFG_E1HOV_TAG_DEFAULT) {\r\nbp->mf_ov = val;\r\nbp->path_has_ovlan = true;\r\nBNX2X_DEV_INFO("MF OV for func %d is %d (0x%04x)\n",\r\nfunc, bp->mf_ov, bp->mf_ov);\r\n} else if ((bp->mf_sub_mode == SUB_MF_MODE_UFP) ||\r\n(bp->mf_sub_mode == SUB_MF_MODE_BD)) {\r\ndev_err(&bp->pdev->dev,\r\n"Unexpected - no valid MF OV for func %d in UFP/BD mode\n",\r\nfunc);\r\nbp->path_has_ovlan = true;\r\n} else {\r\ndev_err(&bp->pdev->dev,\r\n"No valid MF OV for func %d, aborting\n",\r\nfunc);\r\nreturn -EPERM;\r\n}\r\nbreak;\r\ncase MULTI_FUNCTION_AFEX:\r\nBNX2X_DEV_INFO("func %d is in MF afex mode\n", func);\r\nbreak;\r\ncase MULTI_FUNCTION_SI:\r\nBNX2X_DEV_INFO("func %d is in MF switch-independent mode\n",\r\nfunc);\r\nbreak;\r\ndefault:\r\nif (vn) {\r\ndev_err(&bp->pdev->dev,\r\n"VN %d is in a single function mode, aborting\n",\r\nvn);\r\nreturn -EPERM;\r\n}\r\nbreak;\r\n}\r\nif (CHIP_MODE_IS_4_PORT(bp) &&\r\n!bp->path_has_ovlan &&\r\n!IS_MF(bp) &&\r\nbp->common.mf_cfg_base != SHMEM_MF_CFG_ADDR_NONE) {\r\nu8 other_port = !BP_PORT(bp);\r\nu8 other_func = BP_PATH(bp) + 2*other_port;\r\nval = MF_CFG_RD(bp,\r\nfunc_mf_config[other_func].e1hov_tag);\r\nif (val != FUNC_MF_CFG_E1HOV_TAG_DEFAULT)\r\nbp->path_has_ovlan = true;\r\n}\r\n}\r\nif (CHIP_IS_E1H(bp) && IS_MF(bp))\r\nbp->igu_sb_cnt = min_t(u8, bp->igu_sb_cnt, E1H_MAX_MF_SB_COUNT);\r\nbnx2x_get_port_hwinfo(bp);\r\nbnx2x_get_mac_hwinfo(bp);\r\nbnx2x_get_cnic_info(bp);\r\nreturn rc;\r\n}\r\nstatic void bnx2x_read_fwinfo(struct bnx2x *bp)\r\n{\r\nint cnt, i, block_end, rodi;\r\nchar vpd_start[BNX2X_VPD_LEN+1];\r\nchar str_id_reg[VENDOR_ID_LEN+1];\r\nchar str_id_cap[VENDOR_ID_LEN+1];\r\nchar *vpd_data;\r\nchar *vpd_extended_data = NULL;\r\nu8 len;\r\ncnt = pci_read_vpd(bp->pdev, 0, BNX2X_VPD_LEN, vpd_start);\r\nmemset(bp->fw_ver, 0, sizeof(bp->fw_ver));\r\nif (cnt < BNX2X_VPD_LEN)\r\ngoto out_not_found;\r\ni = pci_vpd_find_tag(vpd_start, 0, BNX2X_VPD_LEN,\r\nPCI_VPD_LRDT_RO_DATA);\r\nif (i < 0)\r\ngoto out_not_found;\r\nblock_end = i + PCI_VPD_LRDT_TAG_SIZE +\r\npci_vpd_lrdt_size(&vpd_start[i]);\r\ni += PCI_VPD_LRDT_TAG_SIZE;\r\nif (block_end > BNX2X_VPD_LEN) {\r\nvpd_extended_data = kmalloc(block_end, GFP_KERNEL);\r\nif (vpd_extended_data == NULL)\r\ngoto out_not_found;\r\nmemcpy(vpd_extended_data, vpd_start, BNX2X_VPD_LEN);\r\ncnt = pci_read_vpd(bp->pdev, BNX2X_VPD_LEN,\r\nblock_end - BNX2X_VPD_LEN,\r\nvpd_extended_data + BNX2X_VPD_LEN);\r\nif (cnt < (block_end - BNX2X_VPD_LEN))\r\ngoto out_not_found;\r\nvpd_data = vpd_extended_data;\r\n} else\r\nvpd_data = vpd_start;\r\nrodi = pci_vpd_find_info_keyword(vpd_data, i, block_end,\r\nPCI_VPD_RO_KEYWORD_MFR_ID);\r\nif (rodi < 0)\r\ngoto out_not_found;\r\nlen = pci_vpd_info_field_size(&vpd_data[rodi]);\r\nif (len != VENDOR_ID_LEN)\r\ngoto out_not_found;\r\nrodi += PCI_VPD_INFO_FLD_HDR_SIZE;\r\nsnprintf(str_id_reg, VENDOR_ID_LEN + 1, "%04x", PCI_VENDOR_ID_DELL);\r\nsnprintf(str_id_cap, VENDOR_ID_LEN + 1, "%04X", PCI_VENDOR_ID_DELL);\r\nif (!strncmp(str_id_reg, &vpd_data[rodi], VENDOR_ID_LEN) ||\r\n!strncmp(str_id_cap, &vpd_data[rodi], VENDOR_ID_LEN)) {\r\nrodi = pci_vpd_find_info_keyword(vpd_data, i, block_end,\r\nPCI_VPD_RO_KEYWORD_VENDOR0);\r\nif (rodi >= 0) {\r\nlen = pci_vpd_info_field_size(&vpd_data[rodi]);\r\nrodi += PCI_VPD_INFO_FLD_HDR_SIZE;\r\nif (len < 32 && (len + rodi) <= BNX2X_VPD_LEN) {\r\nmemcpy(bp->fw_ver, &vpd_data[rodi], len);\r\nbp->fw_ver[len] = ' ';\r\n}\r\n}\r\nkfree(vpd_extended_data);\r\nreturn;\r\n}\r\nout_not_found:\r\nkfree(vpd_extended_data);\r\nreturn;\r\n}\r\nstatic void bnx2x_set_modes_bitmap(struct bnx2x *bp)\r\n{\r\nu32 flags = 0;\r\nif (CHIP_REV_IS_FPGA(bp))\r\nSET_FLAGS(flags, MODE_FPGA);\r\nelse if (CHIP_REV_IS_EMUL(bp))\r\nSET_FLAGS(flags, MODE_EMUL);\r\nelse\r\nSET_FLAGS(flags, MODE_ASIC);\r\nif (CHIP_MODE_IS_4_PORT(bp))\r\nSET_FLAGS(flags, MODE_PORT4);\r\nelse\r\nSET_FLAGS(flags, MODE_PORT2);\r\nif (CHIP_IS_E2(bp))\r\nSET_FLAGS(flags, MODE_E2);\r\nelse if (CHIP_IS_E3(bp)) {\r\nSET_FLAGS(flags, MODE_E3);\r\nif (CHIP_REV(bp) == CHIP_REV_Ax)\r\nSET_FLAGS(flags, MODE_E3_A0);\r\nelse\r\nSET_FLAGS(flags, MODE_E3_B0 | MODE_COS3);\r\n}\r\nif (IS_MF(bp)) {\r\nSET_FLAGS(flags, MODE_MF);\r\nswitch (bp->mf_mode) {\r\ncase MULTI_FUNCTION_SD:\r\nSET_FLAGS(flags, MODE_MF_SD);\r\nbreak;\r\ncase MULTI_FUNCTION_SI:\r\nSET_FLAGS(flags, MODE_MF_SI);\r\nbreak;\r\ncase MULTI_FUNCTION_AFEX:\r\nSET_FLAGS(flags, MODE_MF_AFEX);\r\nbreak;\r\n}\r\n} else\r\nSET_FLAGS(flags, MODE_SF);\r\n#if defined(__LITTLE_ENDIAN)\r\nSET_FLAGS(flags, MODE_LITTLE_ENDIAN);\r\n#else\r\nSET_FLAGS(flags, MODE_BIG_ENDIAN);\r\n#endif\r\nINIT_MODE_FLAGS(bp) = flags;\r\n}\r\nstatic int bnx2x_init_bp(struct bnx2x *bp)\r\n{\r\nint func;\r\nint rc;\r\nmutex_init(&bp->port.phy_mutex);\r\nmutex_init(&bp->fw_mb_mutex);\r\nmutex_init(&bp->drv_info_mutex);\r\nsema_init(&bp->stats_lock, 1);\r\nbp->drv_info_mng_owner = false;\r\nINIT_LIST_HEAD(&bp->vlan_reg);\r\nINIT_DELAYED_WORK(&bp->sp_task, bnx2x_sp_task);\r\nINIT_DELAYED_WORK(&bp->sp_rtnl_task, bnx2x_sp_rtnl_task);\r\nINIT_DELAYED_WORK(&bp->period_task, bnx2x_period_task);\r\nINIT_DELAYED_WORK(&bp->iov_task, bnx2x_iov_task);\r\nif (IS_PF(bp)) {\r\nrc = bnx2x_get_hwinfo(bp);\r\nif (rc)\r\nreturn rc;\r\n} else {\r\neth_zero_addr(bp->dev->dev_addr);\r\n}\r\nbnx2x_set_modes_bitmap(bp);\r\nrc = bnx2x_alloc_mem_bp(bp);\r\nif (rc)\r\nreturn rc;\r\nbnx2x_read_fwinfo(bp);\r\nfunc = BP_FUNC(bp);\r\nif (IS_PF(bp) && !BP_NOMCP(bp)) {\r\nbp->fw_seq =\r\nSHMEM_RD(bp, func_mb[BP_FW_MB_IDX(bp)].drv_mb_header) &\r\nDRV_MSG_SEQ_NUMBER_MASK;\r\nBNX2X_DEV_INFO("fw_seq 0x%08x\n", bp->fw_seq);\r\nrc = bnx2x_prev_unload(bp);\r\nif (rc) {\r\nbnx2x_free_mem_bp(bp);\r\nreturn rc;\r\n}\r\n}\r\nif (CHIP_REV_IS_FPGA(bp))\r\ndev_err(&bp->pdev->dev, "FPGA detected\n");\r\nif (BP_NOMCP(bp) && (func == 0))\r\ndev_err(&bp->pdev->dev, "MCP disabled, must load devices in order!\n");\r\nbp->disable_tpa = disable_tpa;\r\nbp->disable_tpa |= !!IS_MF_STORAGE_ONLY(bp);\r\nbp->disable_tpa |= is_kdump_kernel();\r\nif (bp->disable_tpa) {\r\nbp->dev->hw_features &= ~NETIF_F_LRO;\r\nbp->dev->features &= ~NETIF_F_LRO;\r\n}\r\nif (CHIP_IS_E1(bp))\r\nbp->dropless_fc = 0;\r\nelse\r\nbp->dropless_fc = dropless_fc | bnx2x_get_dropless_info(bp);\r\nbp->mrrs = mrrs;\r\nbp->tx_ring_size = IS_MF_STORAGE_ONLY(bp) ? 0 : MAX_TX_AVAIL;\r\nif (IS_VF(bp))\r\nbp->rx_ring_size = MAX_RX_AVAIL;\r\nbp->tx_ticks = (50 / BNX2X_BTR) * BNX2X_BTR;\r\nbp->rx_ticks = (25 / BNX2X_BTR) * BNX2X_BTR;\r\nbp->current_interval = CHIP_REV_IS_SLOW(bp) ? 5*HZ : HZ;\r\ninit_timer(&bp->timer);\r\nbp->timer.expires = jiffies + bp->current_interval;\r\nbp->timer.data = (unsigned long) bp;\r\nbp->timer.function = bnx2x_timer;\r\nif (SHMEM2_HAS(bp, dcbx_lldp_params_offset) &&\r\nSHMEM2_HAS(bp, dcbx_lldp_dcbx_stat_offset) &&\r\nSHMEM2_HAS(bp, dcbx_en) &&\r\nSHMEM2_RD(bp, dcbx_lldp_params_offset) &&\r\nSHMEM2_RD(bp, dcbx_lldp_dcbx_stat_offset) &&\r\nSHMEM2_RD(bp, dcbx_en[BP_PORT(bp)])) {\r\nbnx2x_dcbx_set_state(bp, true, BNX2X_DCBX_ENABLED_ON_NEG_ON);\r\nbnx2x_dcbx_init_params(bp);\r\n} else {\r\nbnx2x_dcbx_set_state(bp, false, BNX2X_DCBX_ENABLED_OFF);\r\n}\r\nif (CHIP_IS_E1x(bp))\r\nbp->cnic_base_cl_id = FP_SB_MAX_E1x;\r\nelse\r\nbp->cnic_base_cl_id = FP_SB_MAX_E2;\r\nif (IS_VF(bp))\r\nbp->max_cos = 1;\r\nelse if (CHIP_IS_E1x(bp))\r\nbp->max_cos = BNX2X_MULTI_TX_COS_E1X;\r\nelse if (CHIP_IS_E2(bp) || CHIP_IS_E3A0(bp))\r\nbp->max_cos = BNX2X_MULTI_TX_COS_E2_E3A0;\r\nelse if (CHIP_IS_E3B0(bp))\r\nbp->max_cos = BNX2X_MULTI_TX_COS_E3B0;\r\nelse\r\nBNX2X_ERR("unknown chip %x revision %x\n",\r\nCHIP_NUM(bp), CHIP_REV(bp));\r\nBNX2X_DEV_INFO("set bp->max_cos to %d\n", bp->max_cos);\r\nif (IS_VF(bp))\r\nbp->min_msix_vec_cnt = 1;\r\nelse if (CNIC_SUPPORT(bp))\r\nbp->min_msix_vec_cnt = 3;\r\nelse\r\nbp->min_msix_vec_cnt = 2;\r\nBNX2X_DEV_INFO("bp->min_msix_vec_cnt %d", bp->min_msix_vec_cnt);\r\nbp->dump_preset_idx = 1;\r\nif (CHIP_IS_E3B0(bp))\r\nbp->flags |= PTP_SUPPORTED;\r\nreturn rc;\r\n}\r\nstatic int bnx2x_open(struct net_device *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nint rc;\r\nbp->stats_init = true;\r\nnetif_carrier_off(dev);\r\nbnx2x_set_power_state(bp, PCI_D0);\r\nif (IS_PF(bp)) {\r\nint other_engine = BP_PATH(bp) ? 0 : 1;\r\nbool other_load_status, load_status;\r\nbool global = false;\r\nother_load_status = bnx2x_get_load_status(bp, other_engine);\r\nload_status = bnx2x_get_load_status(bp, BP_PATH(bp));\r\nif (!bnx2x_reset_is_done(bp, BP_PATH(bp)) ||\r\nbnx2x_chk_parity_attn(bp, &global, true)) {\r\ndo {\r\nif (global)\r\nbnx2x_set_reset_global(bp);\r\nif ((!load_status &&\r\n(!global || !other_load_status)) &&\r\nbnx2x_trylock_leader_lock(bp) &&\r\n!bnx2x_leader_reset(bp)) {\r\nnetdev_info(bp->dev,\r\n"Recovered in open\n");\r\nbreak;\r\n}\r\nbnx2x_set_power_state(bp, PCI_D3hot);\r\nbp->recovery_state = BNX2X_RECOVERY_FAILED;\r\nBNX2X_ERR("Recovery flow hasn't been properly completed yet. Try again later.\n"\r\n"If you still see this message after a few retries then power cycle is required.\n");\r\nreturn -EAGAIN;\r\n} while (0);\r\n}\r\n}\r\nbp->recovery_state = BNX2X_RECOVERY_DONE;\r\nrc = bnx2x_nic_load(bp, LOAD_OPEN);\r\nif (rc)\r\nreturn rc;\r\nif (IS_PF(bp))\r\nudp_tunnel_get_rx_info(dev);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_close(struct net_device *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nbnx2x_nic_unload(bp, UNLOAD_CLOSE, false);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_free_mcast_macs_list(struct list_head *mcast_group_list)\r\n{\r\nstruct bnx2x_mcast_list_elem_group *current_mcast_group;\r\nwhile (!list_empty(mcast_group_list)) {\r\ncurrent_mcast_group = list_first_entry(mcast_group_list,\r\nstruct bnx2x_mcast_list_elem_group,\r\nmcast_group_link);\r\nlist_del(&current_mcast_group->mcast_group_link);\r\nfree_page((unsigned long)current_mcast_group);\r\n}\r\n}\r\nstatic int bnx2x_init_mcast_macs_list(struct bnx2x *bp,\r\nstruct bnx2x_mcast_ramrod_params *p,\r\nstruct list_head *mcast_group_list)\r\n{\r\nstruct bnx2x_mcast_list_elem *mc_mac;\r\nstruct netdev_hw_addr *ha;\r\nstruct bnx2x_mcast_list_elem_group *current_mcast_group = NULL;\r\nint mc_count = netdev_mc_count(bp->dev);\r\nint offset = 0;\r\nINIT_LIST_HEAD(&p->mcast_list);\r\nnetdev_for_each_mc_addr(ha, bp->dev) {\r\nif (!offset) {\r\ncurrent_mcast_group =\r\n(struct bnx2x_mcast_list_elem_group *)\r\n__get_free_page(GFP_ATOMIC);\r\nif (!current_mcast_group) {\r\nbnx2x_free_mcast_macs_list(mcast_group_list);\r\nBNX2X_ERR("Failed to allocate mc MAC list\n");\r\nreturn -ENOMEM;\r\n}\r\nlist_add(&current_mcast_group->mcast_group_link,\r\nmcast_group_list);\r\n}\r\nmc_mac = &current_mcast_group->mcast_elems[offset];\r\nmc_mac->mac = bnx2x_mc_addr(ha);\r\nlist_add_tail(&mc_mac->link, &p->mcast_list);\r\noffset++;\r\nif (offset == MCAST_ELEMS_PER_PG)\r\noffset = 0;\r\n}\r\np->mcast_list_len = mc_count;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_set_uc_list(struct bnx2x *bp)\r\n{\r\nint rc;\r\nstruct net_device *dev = bp->dev;\r\nstruct netdev_hw_addr *ha;\r\nstruct bnx2x_vlan_mac_obj *mac_obj = &bp->sp_objs->mac_obj;\r\nunsigned long ramrod_flags = 0;\r\nrc = bnx2x_del_all_macs(bp, mac_obj, BNX2X_UC_LIST_MAC, false);\r\nif (rc < 0) {\r\nBNX2X_ERR("Failed to schedule DELETE operations: %d\n", rc);\r\nreturn rc;\r\n}\r\nnetdev_for_each_uc_addr(ha, dev) {\r\nrc = bnx2x_set_mac_one(bp, bnx2x_uc_addr(ha), mac_obj, true,\r\nBNX2X_UC_LIST_MAC, &ramrod_flags);\r\nif (rc == -EEXIST) {\r\nDP(BNX2X_MSG_SP,\r\n"Failed to schedule ADD operations: %d\n", rc);\r\nrc = 0;\r\n} else if (rc < 0) {\r\nBNX2X_ERR("Failed to schedule ADD operations: %d\n",\r\nrc);\r\nreturn rc;\r\n}\r\n}\r\n__set_bit(RAMROD_CONT, &ramrod_flags);\r\nreturn bnx2x_set_mac_one(bp, NULL, mac_obj, false ,\r\nBNX2X_UC_LIST_MAC, &ramrod_flags);\r\n}\r\nstatic int bnx2x_set_mc_list_e1x(struct bnx2x *bp)\r\n{\r\nLIST_HEAD(mcast_group_list);\r\nstruct net_device *dev = bp->dev;\r\nstruct bnx2x_mcast_ramrod_params rparam = {NULL};\r\nint rc = 0;\r\nrparam.mcast_obj = &bp->mcast_obj;\r\nrc = bnx2x_config_mcast(bp, &rparam, BNX2X_MCAST_CMD_DEL);\r\nif (rc < 0) {\r\nBNX2X_ERR("Failed to clear multicast configuration: %d\n", rc);\r\nreturn rc;\r\n}\r\nif (netdev_mc_count(dev)) {\r\nrc = bnx2x_init_mcast_macs_list(bp, &rparam, &mcast_group_list);\r\nif (rc)\r\nreturn rc;\r\nrc = bnx2x_config_mcast(bp, &rparam,\r\nBNX2X_MCAST_CMD_ADD);\r\nif (rc < 0)\r\nBNX2X_ERR("Failed to set a new multicast configuration: %d\n",\r\nrc);\r\nbnx2x_free_mcast_macs_list(&mcast_group_list);\r\n}\r\nreturn rc;\r\n}\r\nstatic int bnx2x_set_mc_list(struct bnx2x *bp)\r\n{\r\nLIST_HEAD(mcast_group_list);\r\nstruct bnx2x_mcast_ramrod_params rparam = {NULL};\r\nstruct net_device *dev = bp->dev;\r\nint rc = 0;\r\nif (CHIP_IS_E1x(bp))\r\nreturn bnx2x_set_mc_list_e1x(bp);\r\nrparam.mcast_obj = &bp->mcast_obj;\r\nif (netdev_mc_count(dev)) {\r\nrc = bnx2x_init_mcast_macs_list(bp, &rparam, &mcast_group_list);\r\nif (rc)\r\nreturn rc;\r\nrc = bnx2x_config_mcast(bp, &rparam,\r\nBNX2X_MCAST_CMD_SET);\r\nif (rc < 0)\r\nBNX2X_ERR("Failed to set a new multicast configuration: %d\n",\r\nrc);\r\nbnx2x_free_mcast_macs_list(&mcast_group_list);\r\n} else {\r\nrc = bnx2x_config_mcast(bp, &rparam, BNX2X_MCAST_CMD_DEL);\r\nif (rc < 0)\r\nBNX2X_ERR("Failed to clear multicast configuration %d\n",\r\nrc);\r\n}\r\nreturn rc;\r\n}\r\nstatic void bnx2x_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nif (bp->state != BNX2X_STATE_OPEN) {\r\nDP(NETIF_MSG_IFUP, "state is %x, returning\n", bp->state);\r\nreturn;\r\n} else {\r\nbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_RX_MODE,\r\nNETIF_MSG_IFUP);\r\n}\r\n}\r\nvoid bnx2x_set_rx_mode_inner(struct bnx2x *bp)\r\n{\r\nu32 rx_mode = BNX2X_RX_MODE_NORMAL;\r\nDP(NETIF_MSG_IFUP, "dev->flags = %x\n", bp->dev->flags);\r\nnetif_addr_lock_bh(bp->dev);\r\nif (bp->dev->flags & IFF_PROMISC) {\r\nrx_mode = BNX2X_RX_MODE_PROMISC;\r\n} else if ((bp->dev->flags & IFF_ALLMULTI) ||\r\n((netdev_mc_count(bp->dev) > BNX2X_MAX_MULTICAST) &&\r\nCHIP_IS_E1(bp))) {\r\nrx_mode = BNX2X_RX_MODE_ALLMULTI;\r\n} else {\r\nif (IS_PF(bp)) {\r\nif (bnx2x_set_mc_list(bp) < 0)\r\nrx_mode = BNX2X_RX_MODE_ALLMULTI;\r\nnetif_addr_unlock_bh(bp->dev);\r\nif (bnx2x_set_uc_list(bp) < 0)\r\nrx_mode = BNX2X_RX_MODE_PROMISC;\r\nnetif_addr_lock_bh(bp->dev);\r\n} else {\r\nbnx2x_schedule_sp_rtnl(bp,\r\nBNX2X_SP_RTNL_VFPF_MCAST, 0);\r\n}\r\n}\r\nbp->rx_mode = rx_mode;\r\nif (IS_MF_ISCSI_ONLY(bp))\r\nbp->rx_mode = BNX2X_RX_MODE_NONE;\r\nif (test_bit(BNX2X_FILTER_RX_MODE_PENDING, &bp->sp_state)) {\r\nset_bit(BNX2X_FILTER_RX_MODE_SCHED, &bp->sp_state);\r\nnetif_addr_unlock_bh(bp->dev);\r\nreturn;\r\n}\r\nif (IS_PF(bp)) {\r\nbnx2x_set_storm_rx_mode(bp);\r\nnetif_addr_unlock_bh(bp->dev);\r\n} else {\r\nnetif_addr_unlock_bh(bp->dev);\r\nbnx2x_vfpf_storm_rx_mode(bp);\r\n}\r\n}\r\nstatic int bnx2x_mdio_read(struct net_device *netdev, int prtad,\r\nint devad, u16 addr)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nu16 value;\r\nint rc;\r\nDP(NETIF_MSG_LINK, "mdio_read: prtad 0x%x, devad 0x%x, addr 0x%x\n",\r\nprtad, devad, addr);\r\ndevad = (devad == MDIO_DEVAD_NONE) ? DEFAULT_PHY_DEV_ADDR : devad;\r\nbnx2x_acquire_phy_lock(bp);\r\nrc = bnx2x_phy_read(&bp->link_params, prtad, devad, addr, &value);\r\nbnx2x_release_phy_lock(bp);\r\nDP(NETIF_MSG_LINK, "mdio_read_val 0x%x rc = 0x%x\n", value, rc);\r\nif (!rc)\r\nrc = value;\r\nreturn rc;\r\n}\r\nstatic int bnx2x_mdio_write(struct net_device *netdev, int prtad, int devad,\r\nu16 addr, u16 value)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nint rc;\r\nDP(NETIF_MSG_LINK,\r\n"mdio_write: prtad 0x%x, devad 0x%x, addr 0x%x, value 0x%x\n",\r\nprtad, devad, addr, value);\r\ndevad = (devad == MDIO_DEVAD_NONE) ? DEFAULT_PHY_DEV_ADDR : devad;\r\nbnx2x_acquire_phy_lock(bp);\r\nrc = bnx2x_phy_write(&bp->link_params, prtad, devad, addr, value);\r\nbnx2x_release_phy_lock(bp);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nstruct mii_ioctl_data *mdio = if_mii(ifr);\r\nif (!netif_running(dev))\r\nreturn -EAGAIN;\r\nswitch (cmd) {\r\ncase SIOCSHWTSTAMP:\r\nreturn bnx2x_hwtstamp_ioctl(bp, ifr);\r\ndefault:\r\nDP(NETIF_MSG_LINK, "ioctl: phy id 0x%x, reg 0x%x, val_in 0x%x\n",\r\nmdio->phy_id, mdio->reg_num, mdio->val_in);\r\nreturn mdio_mii_ioctl(&bp->mdio, mdio, cmd);\r\n}\r\n}\r\nstatic void poll_bnx2x(struct net_device *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nint i;\r\nfor_each_eth_queue(bp, i) {\r\nstruct bnx2x_fastpath *fp = &bp->fp[i];\r\nnapi_schedule(&bnx2x_fp(bp, fp->index, napi));\r\n}\r\n}\r\nstatic int bnx2x_validate_addr(struct net_device *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nif (IS_VF(bp))\r\nbnx2x_sample_bulletin(bp);\r\nif (!is_valid_ether_addr(dev->dev_addr)) {\r\nBNX2X_ERR("Non-valid Ethernet address\n");\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_get_phys_port_id(struct net_device *netdev,\r\nstruct netdev_phys_item_id *ppid)\r\n{\r\nstruct bnx2x *bp = netdev_priv(netdev);\r\nif (!(bp->flags & HAS_PHYS_PORT_ID))\r\nreturn -EOPNOTSUPP;\r\nppid->id_len = sizeof(bp->phys_port_id);\r\nmemcpy(ppid->id, bp->phys_port_id, ppid->id_len);\r\nreturn 0;\r\n}\r\nstatic netdev_features_t bnx2x_features_check(struct sk_buff *skb,\r\nstruct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nfeatures = vlan_features_check(skb, features);\r\nreturn vxlan_features_check(skb, features);\r\n}\r\nstatic int __bnx2x_vlan_configure_vid(struct bnx2x *bp, u16 vid, bool add)\r\n{\r\nint rc;\r\nif (IS_PF(bp)) {\r\nunsigned long ramrod_flags = 0;\r\n__set_bit(RAMROD_COMP_WAIT, &ramrod_flags);\r\nrc = bnx2x_set_vlan_one(bp, vid, &bp->sp_objs->vlan_obj,\r\nadd, &ramrod_flags);\r\n} else {\r\nrc = bnx2x_vfpf_update_vlan(bp, vid, bp->fp->index, add);\r\n}\r\nreturn rc;\r\n}\r\nstatic int bnx2x_vlan_configure_vid_list(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_vlan_entry *vlan;\r\nint rc = 0;\r\nlist_for_each_entry(vlan, &bp->vlan_reg, link) {\r\nif (vlan->hw)\r\ncontinue;\r\nif (bp->vlan_cnt >= bp->vlan_credit)\r\nreturn -ENOBUFS;\r\nrc = __bnx2x_vlan_configure_vid(bp, vlan->vid, true);\r\nif (rc) {\r\nBNX2X_ERR("Unable to config VLAN %d\n", vlan->vid);\r\nreturn rc;\r\n}\r\nDP(NETIF_MSG_IFUP, "HW configured for VLAN %d\n", vlan->vid);\r\nvlan->hw = true;\r\nbp->vlan_cnt++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_vlan_configure(struct bnx2x *bp, bool set_rx_mode)\r\n{\r\nbool need_accept_any_vlan;\r\nneed_accept_any_vlan = !!bnx2x_vlan_configure_vid_list(bp);\r\nif (bp->accept_any_vlan != need_accept_any_vlan) {\r\nbp->accept_any_vlan = need_accept_any_vlan;\r\nDP(NETIF_MSG_IFUP, "Accept all VLAN %s\n",\r\nbp->accept_any_vlan ? "raised" : "cleared");\r\nif (set_rx_mode) {\r\nif (IS_PF(bp))\r\nbnx2x_set_rx_mode_inner(bp);\r\nelse\r\nbnx2x_vfpf_storm_rx_mode(bp);\r\n}\r\n}\r\n}\r\nint bnx2x_vlan_reconfigure_vid(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_vlan_entry *vlan;\r\nlist_for_each_entry(vlan, &bp->vlan_reg, link)\r\nvlan->hw = false;\r\nbp->vlan_cnt = 0;\r\nbnx2x_vlan_configure(bp, false);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nstruct bnx2x_vlan_entry *vlan;\r\nDP(NETIF_MSG_IFUP, "Adding VLAN %d\n", vid);\r\nvlan = kmalloc(sizeof(*vlan), GFP_KERNEL);\r\nif (!vlan)\r\nreturn -ENOMEM;\r\nvlan->vid = vid;\r\nvlan->hw = false;\r\nlist_add_tail(&vlan->link, &bp->vlan_reg);\r\nif (netif_running(dev))\r\nbnx2x_vlan_configure(bp, true);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nstruct bnx2x_vlan_entry *vlan;\r\nbool found = false;\r\nint rc = 0;\r\nDP(NETIF_MSG_IFUP, "Removing VLAN %d\n", vid);\r\nlist_for_each_entry(vlan, &bp->vlan_reg, link)\r\nif (vlan->vid == vid) {\r\nfound = true;\r\nbreak;\r\n}\r\nif (!found) {\r\nBNX2X_ERR("Unable to kill VLAN %d - not found\n", vid);\r\nreturn -EINVAL;\r\n}\r\nif (netif_running(dev) && vlan->hw) {\r\nrc = __bnx2x_vlan_configure_vid(bp, vid, false);\r\nDP(NETIF_MSG_IFUP, "HW deconfigured for VLAN %d\n", vid);\r\nbp->vlan_cnt--;\r\n}\r\nlist_del(&vlan->link);\r\nkfree(vlan);\r\nif (netif_running(dev))\r\nbnx2x_vlan_configure(bp, true);\r\nDP(NETIF_MSG_IFUP, "Removing VLAN result %d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_set_coherency_mask(struct bnx2x *bp)\r\n{\r\nstruct device *dev = &bp->pdev->dev;\r\nif (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64)) != 0 &&\r\ndma_set_mask_and_coherent(dev, DMA_BIT_MASK(32)) != 0) {\r\ndev_err(dev, "System does not support DMA, aborting\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_disable_pcie_error_reporting(struct bnx2x *bp)\r\n{\r\nif (bp->flags & AER_ENABLED) {\r\npci_disable_pcie_error_reporting(bp->pdev);\r\nbp->flags &= ~AER_ENABLED;\r\n}\r\n}\r\nstatic int bnx2x_init_dev(struct bnx2x *bp, struct pci_dev *pdev,\r\nstruct net_device *dev, unsigned long board_type)\r\n{\r\nint rc;\r\nu32 pci_cfg_dword;\r\nbool chip_is_e1x = (board_type == BCM57710 ||\r\nboard_type == BCM57711 ||\r\nboard_type == BCM57711E);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nbp->dev = dev;\r\nbp->pdev = pdev;\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\ndev_err(&bp->pdev->dev,\r\n"Cannot enable PCI device, aborting\n");\r\ngoto err_out;\r\n}\r\nif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\r\ndev_err(&bp->pdev->dev,\r\n"Cannot find PCI device base address, aborting\n");\r\nrc = -ENODEV;\r\ngoto err_out_disable;\r\n}\r\nif (IS_PF(bp) && !(pci_resource_flags(pdev, 2) & IORESOURCE_MEM)) {\r\ndev_err(&bp->pdev->dev, "Cannot find second PCI device base address, aborting\n");\r\nrc = -ENODEV;\r\ngoto err_out_disable;\r\n}\r\npci_read_config_dword(pdev, PCICFG_REVISION_ID_OFFSET, &pci_cfg_dword);\r\nif ((pci_cfg_dword & PCICFG_REVESION_ID_MASK) ==\r\nPCICFG_REVESION_ID_ERROR_VAL) {\r\npr_err("PCI device error, probably due to fan failure, aborting\n");\r\nrc = -ENODEV;\r\ngoto err_out_disable;\r\n}\r\nif (atomic_read(&pdev->enable_cnt) == 1) {\r\nrc = pci_request_regions(pdev, DRV_MODULE_NAME);\r\nif (rc) {\r\ndev_err(&bp->pdev->dev,\r\n"Cannot obtain PCI resources, aborting\n");\r\ngoto err_out_disable;\r\n}\r\npci_set_master(pdev);\r\npci_save_state(pdev);\r\n}\r\nif (IS_PF(bp)) {\r\nif (!pdev->pm_cap) {\r\ndev_err(&bp->pdev->dev,\r\n"Cannot find power management capability, aborting\n");\r\nrc = -EIO;\r\ngoto err_out_release;\r\n}\r\n}\r\nif (!pci_is_pcie(pdev)) {\r\ndev_err(&bp->pdev->dev, "Not PCI Express, aborting\n");\r\nrc = -EIO;\r\ngoto err_out_release;\r\n}\r\nrc = bnx2x_set_coherency_mask(bp);\r\nif (rc)\r\ngoto err_out_release;\r\ndev->mem_start = pci_resource_start(pdev, 0);\r\ndev->base_addr = dev->mem_start;\r\ndev->mem_end = pci_resource_end(pdev, 0);\r\ndev->irq = pdev->irq;\r\nbp->regview = pci_ioremap_bar(pdev, 0);\r\nif (!bp->regview) {\r\ndev_err(&bp->pdev->dev,\r\n"Cannot map register space, aborting\n");\r\nrc = -ENOMEM;\r\ngoto err_out_release;\r\n}\r\nif (chip_is_e1x) {\r\nbp->pf_num = PCI_FUNC(pdev->devfn);\r\n} else {\r\npci_read_config_dword(bp->pdev,\r\nPCICFG_ME_REGISTER, &pci_cfg_dword);\r\nbp->pf_num = (u8)((pci_cfg_dword & ME_REG_ABS_PF_NUM) >>\r\nME_REG_ABS_PF_NUM_SHIFT);\r\n}\r\nBNX2X_DEV_INFO("me reg PF num: %d\n", bp->pf_num);\r\npci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS,\r\nPCICFG_VENDOR_ID_OFFSET);\r\npdev->needs_freset = 1;\r\nrc = pci_enable_pcie_error_reporting(pdev);\r\nif (!rc)\r\nbp->flags |= AER_ENABLED;\r\nelse\r\nBNX2X_DEV_INFO("Failed To configure PCIe AER [%d]\n", rc);\r\nif (IS_PF(bp)) {\r\nREG_WR(bp, PXP2_REG_PGL_ADDR_88_F0, 0);\r\nREG_WR(bp, PXP2_REG_PGL_ADDR_8C_F0, 0);\r\nREG_WR(bp, PXP2_REG_PGL_ADDR_90_F0, 0);\r\nREG_WR(bp, PXP2_REG_PGL_ADDR_94_F0, 0);\r\nif (chip_is_e1x) {\r\nREG_WR(bp, PXP2_REG_PGL_ADDR_88_F1, 0);\r\nREG_WR(bp, PXP2_REG_PGL_ADDR_8C_F1, 0);\r\nREG_WR(bp, PXP2_REG_PGL_ADDR_90_F1, 0);\r\nREG_WR(bp, PXP2_REG_PGL_ADDR_94_F1, 0);\r\n}\r\nif (!chip_is_e1x)\r\nREG_WR(bp,\r\nPGLUE_B_REG_INTERNAL_PFID_ENABLE_TARGET_READ, 1);\r\n}\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\ndev->netdev_ops = &bnx2x_netdev_ops;\r\nbnx2x_set_ethtool_ops(bp, dev);\r\ndev->priv_flags |= IFF_UNICAST_FLT;\r\ndev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\r\nNETIF_F_TSO | NETIF_F_TSO_ECN | NETIF_F_TSO6 |\r\nNETIF_F_RXCSUM | NETIF_F_LRO | NETIF_F_GRO |\r\nNETIF_F_RXHASH | NETIF_F_HW_VLAN_CTAG_TX;\r\nif (!chip_is_e1x) {\r\ndev->hw_features |= NETIF_F_GSO_GRE | NETIF_F_GSO_GRE_CSUM |\r\nNETIF_F_GSO_IPXIP4 |\r\nNETIF_F_GSO_UDP_TUNNEL |\r\nNETIF_F_GSO_UDP_TUNNEL_CSUM |\r\nNETIF_F_GSO_PARTIAL;\r\ndev->hw_enc_features =\r\nNETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | NETIF_F_SG |\r\nNETIF_F_TSO | NETIF_F_TSO_ECN | NETIF_F_TSO6 |\r\nNETIF_F_GSO_IPXIP4 |\r\nNETIF_F_GSO_GRE | NETIF_F_GSO_GRE_CSUM |\r\nNETIF_F_GSO_UDP_TUNNEL | NETIF_F_GSO_UDP_TUNNEL_CSUM |\r\nNETIF_F_GSO_PARTIAL;\r\ndev->gso_partial_features = NETIF_F_GSO_GRE_CSUM |\r\nNETIF_F_GSO_UDP_TUNNEL_CSUM;\r\n}\r\ndev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\r\nNETIF_F_TSO | NETIF_F_TSO_ECN | NETIF_F_TSO6 | NETIF_F_HIGHDMA;\r\nif (IS_PF(bp)) {\r\nif (chip_is_e1x)\r\nbp->accept_any_vlan = true;\r\nelse\r\ndev->hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;\r\n}\r\ndev->features |= dev->hw_features | NETIF_F_HW_VLAN_CTAG_RX;\r\ndev->features |= NETIF_F_HIGHDMA;\r\ndev->hw_features |= NETIF_F_LOOPBACK;\r\n#ifdef BCM_DCBNL\r\ndev->dcbnl_ops = &bnx2x_dcbnl_ops;\r\n#endif\r\ndev->min_mtu = ETH_MIN_PACKET_SIZE;\r\ndev->max_mtu = ETH_MAX_JUMBO_PACKET_SIZE;\r\nbp->mdio.prtad = MDIO_PRTAD_NONE;\r\nbp->mdio.mmds = 0;\r\nbp->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;\r\nbp->mdio.dev = dev;\r\nbp->mdio.mdio_read = bnx2x_mdio_read;\r\nbp->mdio.mdio_write = bnx2x_mdio_write;\r\nreturn 0;\r\nerr_out_release:\r\nif (atomic_read(&pdev->enable_cnt) == 1)\r\npci_release_regions(pdev);\r\nerr_out_disable:\r\npci_disable_device(pdev);\r\nerr_out:\r\nreturn rc;\r\n}\r\nstatic int bnx2x_check_firmware(struct bnx2x *bp)\r\n{\r\nconst struct firmware *firmware = bp->firmware;\r\nstruct bnx2x_fw_file_hdr *fw_hdr;\r\nstruct bnx2x_fw_file_section *sections;\r\nu32 offset, len, num_ops;\r\n__be16 *ops_offsets;\r\nint i;\r\nconst u8 *fw_ver;\r\nif (firmware->size < sizeof(struct bnx2x_fw_file_hdr)) {\r\nBNX2X_ERR("Wrong FW size\n");\r\nreturn -EINVAL;\r\n}\r\nfw_hdr = (struct bnx2x_fw_file_hdr *)firmware->data;\r\nsections = (struct bnx2x_fw_file_section *)fw_hdr;\r\nfor (i = 0; i < sizeof(*fw_hdr) / sizeof(*sections); i++) {\r\noffset = be32_to_cpu(sections[i].offset);\r\nlen = be32_to_cpu(sections[i].len);\r\nif (offset + len > firmware->size) {\r\nBNX2X_ERR("Section %d length is out of bounds\n", i);\r\nreturn -EINVAL;\r\n}\r\n}\r\noffset = be32_to_cpu(fw_hdr->init_ops_offsets.offset);\r\nops_offsets = (__force __be16 *)(firmware->data + offset);\r\nnum_ops = be32_to_cpu(fw_hdr->init_ops.len) / sizeof(struct raw_op);\r\nfor (i = 0; i < be32_to_cpu(fw_hdr->init_ops_offsets.len) / 2; i++) {\r\nif (be16_to_cpu(ops_offsets[i]) > num_ops) {\r\nBNX2X_ERR("Section offset %d is out of bounds\n", i);\r\nreturn -EINVAL;\r\n}\r\n}\r\noffset = be32_to_cpu(fw_hdr->fw_version.offset);\r\nfw_ver = firmware->data + offset;\r\nif ((fw_ver[0] != BCM_5710_FW_MAJOR_VERSION) ||\r\n(fw_ver[1] != BCM_5710_FW_MINOR_VERSION) ||\r\n(fw_ver[2] != BCM_5710_FW_REVISION_VERSION) ||\r\n(fw_ver[3] != BCM_5710_FW_ENGINEERING_VERSION)) {\r\nBNX2X_ERR("Bad FW version:%d.%d.%d.%d. Should be %d.%d.%d.%d\n",\r\nfw_ver[0], fw_ver[1], fw_ver[2], fw_ver[3],\r\nBCM_5710_FW_MAJOR_VERSION,\r\nBCM_5710_FW_MINOR_VERSION,\r\nBCM_5710_FW_REVISION_VERSION,\r\nBCM_5710_FW_ENGINEERING_VERSION);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void be32_to_cpu_n(const u8 *_source, u8 *_target, u32 n)\r\n{\r\nconst __be32 *source = (const __be32 *)_source;\r\nu32 *target = (u32 *)_target;\r\nu32 i;\r\nfor (i = 0; i < n/4; i++)\r\ntarget[i] = be32_to_cpu(source[i]);\r\n}\r\nstatic void bnx2x_prep_ops(const u8 *_source, u8 *_target, u32 n)\r\n{\r\nconst __be32 *source = (const __be32 *)_source;\r\nstruct raw_op *target = (struct raw_op *)_target;\r\nu32 i, j, tmp;\r\nfor (i = 0, j = 0; i < n/8; i++, j += 2) {\r\ntmp = be32_to_cpu(source[j]);\r\ntarget[i].op = (tmp >> 24) & 0xff;\r\ntarget[i].offset = tmp & 0xffffff;\r\ntarget[i].raw_data = be32_to_cpu(source[j + 1]);\r\n}\r\n}\r\nstatic void bnx2x_prep_iro(const u8 *_source, u8 *_target, u32 n)\r\n{\r\nconst __be32 *source = (const __be32 *)_source;\r\nstruct iro *target = (struct iro *)_target;\r\nu32 i, j, tmp;\r\nfor (i = 0, j = 0; i < n/sizeof(struct iro); i++) {\r\ntarget[i].base = be32_to_cpu(source[j]);\r\nj++;\r\ntmp = be32_to_cpu(source[j]);\r\ntarget[i].m1 = (tmp >> 16) & 0xffff;\r\ntarget[i].m2 = tmp & 0xffff;\r\nj++;\r\ntmp = be32_to_cpu(source[j]);\r\ntarget[i].m3 = (tmp >> 16) & 0xffff;\r\ntarget[i].size = tmp & 0xffff;\r\nj++;\r\n}\r\n}\r\nstatic void be16_to_cpu_n(const u8 *_source, u8 *_target, u32 n)\r\n{\r\nconst __be16 *source = (const __be16 *)_source;\r\nu16 *target = (u16 *)_target;\r\nu32 i;\r\nfor (i = 0; i < n/2; i++)\r\ntarget[i] = be16_to_cpu(source[i]);\r\n}\r\nstatic int bnx2x_init_firmware(struct bnx2x *bp)\r\n{\r\nconst char *fw_file_name;\r\nstruct bnx2x_fw_file_hdr *fw_hdr;\r\nint rc;\r\nif (bp->firmware)\r\nreturn 0;\r\nif (CHIP_IS_E1(bp))\r\nfw_file_name = FW_FILE_NAME_E1;\r\nelse if (CHIP_IS_E1H(bp))\r\nfw_file_name = FW_FILE_NAME_E1H;\r\nelse if (!CHIP_IS_E1x(bp))\r\nfw_file_name = FW_FILE_NAME_E2;\r\nelse {\r\nBNX2X_ERR("Unsupported chip revision\n");\r\nreturn -EINVAL;\r\n}\r\nBNX2X_DEV_INFO("Loading %s\n", fw_file_name);\r\nrc = request_firmware(&bp->firmware, fw_file_name, &bp->pdev->dev);\r\nif (rc) {\r\nBNX2X_ERR("Can't load firmware file %s\n",\r\nfw_file_name);\r\ngoto request_firmware_exit;\r\n}\r\nrc = bnx2x_check_firmware(bp);\r\nif (rc) {\r\nBNX2X_ERR("Corrupt firmware file %s\n", fw_file_name);\r\ngoto request_firmware_exit;\r\n}\r\nfw_hdr = (struct bnx2x_fw_file_hdr *)bp->firmware->data;\r\nrc = -ENOMEM;\r\nBNX2X_ALLOC_AND_SET(init_data, request_firmware_exit, be32_to_cpu_n);\r\nBNX2X_ALLOC_AND_SET(init_ops, init_ops_alloc_err, bnx2x_prep_ops);\r\nBNX2X_ALLOC_AND_SET(init_ops_offsets, init_offsets_alloc_err,\r\nbe16_to_cpu_n);\r\nINIT_TSEM_INT_TABLE_DATA(bp) = bp->firmware->data +\r\nbe32_to_cpu(fw_hdr->tsem_int_table_data.offset);\r\nINIT_TSEM_PRAM_DATA(bp) = bp->firmware->data +\r\nbe32_to_cpu(fw_hdr->tsem_pram_data.offset);\r\nINIT_USEM_INT_TABLE_DATA(bp) = bp->firmware->data +\r\nbe32_to_cpu(fw_hdr->usem_int_table_data.offset);\r\nINIT_USEM_PRAM_DATA(bp) = bp->firmware->data +\r\nbe32_to_cpu(fw_hdr->usem_pram_data.offset);\r\nINIT_XSEM_INT_TABLE_DATA(bp) = bp->firmware->data +\r\nbe32_to_cpu(fw_hdr->xsem_int_table_data.offset);\r\nINIT_XSEM_PRAM_DATA(bp) = bp->firmware->data +\r\nbe32_to_cpu(fw_hdr->xsem_pram_data.offset);\r\nINIT_CSEM_INT_TABLE_DATA(bp) = bp->firmware->data +\r\nbe32_to_cpu(fw_hdr->csem_int_table_data.offset);\r\nINIT_CSEM_PRAM_DATA(bp) = bp->firmware->data +\r\nbe32_to_cpu(fw_hdr->csem_pram_data.offset);\r\nBNX2X_ALLOC_AND_SET(iro_arr, iro_alloc_err, bnx2x_prep_iro);\r\nreturn 0;\r\niro_alloc_err:\r\nkfree(bp->init_ops_offsets);\r\ninit_offsets_alloc_err:\r\nkfree(bp->init_ops);\r\ninit_ops_alloc_err:\r\nkfree(bp->init_data);\r\nrequest_firmware_exit:\r\nrelease_firmware(bp->firmware);\r\nbp->firmware = NULL;\r\nreturn rc;\r\n}\r\nstatic void bnx2x_release_firmware(struct bnx2x *bp)\r\n{\r\nkfree(bp->init_ops_offsets);\r\nkfree(bp->init_ops);\r\nkfree(bp->init_data);\r\nrelease_firmware(bp->firmware);\r\nbp->firmware = NULL;\r\n}\r\nvoid bnx2x__init_func_obj(struct bnx2x *bp)\r\n{\r\nbnx2x_setup_dmae(bp);\r\nbnx2x_init_func_obj(bp, &bp->func_obj,\r\nbnx2x_sp(bp, func_rdata),\r\nbnx2x_sp_mapping(bp, func_rdata),\r\nbnx2x_sp(bp, func_afex_rdata),\r\nbnx2x_sp_mapping(bp, func_afex_rdata),\r\n&bnx2x_func_sp_drv);\r\n}\r\nstatic int bnx2x_set_qm_cid_count(struct bnx2x *bp)\r\n{\r\nint cid_count = BNX2X_L2_MAX_CID(bp);\r\nif (IS_SRIOV(bp))\r\ncid_count += BNX2X_VF_CIDS;\r\nif (CNIC_SUPPORT(bp))\r\ncid_count += CNIC_CID_MAX;\r\nreturn roundup(cid_count, QM_CID_ROUND);\r\n}\r\nstatic int bnx2x_get_num_non_def_sbs(struct pci_dev *pdev, int cnic_cnt)\r\n{\r\nint index;\r\nu16 control = 0;\r\nif (!pdev->msix_cap) {\r\ndev_info(&pdev->dev, "no msix capability found\n");\r\nreturn 1 + cnic_cnt;\r\n}\r\ndev_info(&pdev->dev, "msix capability found\n");\r\npci_read_config_word(pdev, pdev->msix_cap + PCI_MSIX_FLAGS, &control);\r\nindex = control & PCI_MSIX_FLAGS_QSIZE;\r\nreturn index;\r\n}\r\nstatic int set_max_cos_est(int chip_id)\r\n{\r\nswitch (chip_id) {\r\ncase BCM57710:\r\ncase BCM57711:\r\ncase BCM57711E:\r\nreturn BNX2X_MULTI_TX_COS_E1X;\r\ncase BCM57712:\r\ncase BCM57712_MF:\r\nreturn BNX2X_MULTI_TX_COS_E2_E3A0;\r\ncase BCM57800:\r\ncase BCM57800_MF:\r\ncase BCM57810:\r\ncase BCM57810_MF:\r\ncase BCM57840_4_10:\r\ncase BCM57840_2_20:\r\ncase BCM57840_O:\r\ncase BCM57840_MFO:\r\ncase BCM57840_MF:\r\ncase BCM57811:\r\ncase BCM57811_MF:\r\nreturn BNX2X_MULTI_TX_COS_E3B0;\r\ncase BCM57712_VF:\r\ncase BCM57800_VF:\r\ncase BCM57810_VF:\r\ncase BCM57840_VF:\r\ncase BCM57811_VF:\r\nreturn 1;\r\ndefault:\r\npr_err("Unknown board_type (%d), aborting\n", chip_id);\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic int set_is_vf(int chip_id)\r\n{\r\nswitch (chip_id) {\r\ncase BCM57712_VF:\r\ncase BCM57800_VF:\r\ncase BCM57810_VF:\r\ncase BCM57840_VF:\r\ncase BCM57811_VF:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int bnx2x_send_update_drift_ramrod(struct bnx2x *bp, int drift_dir,\r\nint best_val, int best_period)\r\n{\r\nstruct bnx2x_func_state_params func_params = {NULL};\r\nstruct bnx2x_func_set_timesync_params *set_timesync_params =\r\n&func_params.params.set_timesync;\r\n__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\r\n__set_bit(RAMROD_RETRY, &func_params.ramrod_flags);\r\nfunc_params.f_obj = &bp->func_obj;\r\nfunc_params.cmd = BNX2X_F_CMD_SET_TIMESYNC;\r\nset_timesync_params->drift_adjust_cmd = TS_DRIFT_ADJUST_SET;\r\nset_timesync_params->offset_cmd = TS_OFFSET_KEEP;\r\nset_timesync_params->add_sub_drift_adjust_value =\r\ndrift_dir ? TS_ADD_VALUE : TS_SUB_VALUE;\r\nset_timesync_params->drift_adjust_value = best_val;\r\nset_timesync_params->drift_adjust_period = best_period;\r\nreturn bnx2x_func_state_change(bp, &func_params);\r\n}\r\nstatic int bnx2x_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nstruct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);\r\nint rc;\r\nint drift_dir = 1;\r\nint val, period, period1, period2, dif, dif1, dif2;\r\nint best_dif = BNX2X_MAX_PHC_DRIFT, best_period = 0, best_val = 0;\r\nDP(BNX2X_MSG_PTP, "PTP adjfreq called, ppb = %d\n", ppb);\r\nif (!netif_running(bp->dev)) {\r\nDP(BNX2X_MSG_PTP,\r\n"PTP adjfreq called while the interface is down\n");\r\nreturn -ENETDOWN;\r\n}\r\nif (ppb < 0) {\r\nppb = -ppb;\r\ndrift_dir = 0;\r\n}\r\nif (ppb == 0) {\r\nbest_val = 1;\r\nbest_period = 0x1FFFFFF;\r\n} else if (ppb >= BNX2X_MAX_PHC_DRIFT) {\r\nbest_val = 31;\r\nbest_period = 1;\r\n} else {\r\nfor (val = 0; val <= 31; val++) {\r\nif ((val & 0x7) == 0)\r\ncontinue;\r\nperiod1 = val * 1000000 / ppb;\r\nperiod2 = period1 + 1;\r\nif (period1 != 0)\r\ndif1 = ppb - (val * 1000000 / period1);\r\nelse\r\ndif1 = BNX2X_MAX_PHC_DRIFT;\r\nif (dif1 < 0)\r\ndif1 = -dif1;\r\ndif2 = ppb - (val * 1000000 / period2);\r\nif (dif2 < 0)\r\ndif2 = -dif2;\r\ndif = (dif1 < dif2) ? dif1 : dif2;\r\nperiod = (dif1 < dif2) ? period1 : period2;\r\nif (dif < best_dif) {\r\nbest_dif = dif;\r\nbest_val = val;\r\nbest_period = period;\r\n}\r\n}\r\n}\r\nrc = bnx2x_send_update_drift_ramrod(bp, drift_dir, best_val,\r\nbest_period);\r\nif (rc) {\r\nBNX2X_ERR("Failed to set drift\n");\r\nreturn -EFAULT;\r\n}\r\nDP(BNX2X_MSG_PTP, "Configured val = %d, period = %d\n", best_val,\r\nbest_period);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);\r\nif (!netif_running(bp->dev)) {\r\nDP(BNX2X_MSG_PTP,\r\n"PTP adjtime called while the interface is down\n");\r\nreturn -ENETDOWN;\r\n}\r\nDP(BNX2X_MSG_PTP, "PTP adjtime called, delta = %llx\n", delta);\r\ntimecounter_adjtime(&bp->timecounter, delta);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\r\n{\r\nstruct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);\r\nu64 ns;\r\nif (!netif_running(bp->dev)) {\r\nDP(BNX2X_MSG_PTP,\r\n"PTP gettime called while the interface is down\n");\r\nreturn -ENETDOWN;\r\n}\r\nns = timecounter_read(&bp->timecounter);\r\nDP(BNX2X_MSG_PTP, "PTP gettime called, ns = %llu\n", ns);\r\n*ts = ns_to_timespec64(ns);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_ptp_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);\r\nu64 ns;\r\nif (!netif_running(bp->dev)) {\r\nDP(BNX2X_MSG_PTP,\r\n"PTP settime called while the interface is down\n");\r\nreturn -ENETDOWN;\r\n}\r\nns = timespec64_to_ns(ts);\r\nDP(BNX2X_MSG_PTP, "PTP settime called, ns = %llu\n", ns);\r\ntimecounter_init(&bp->timecounter, &bp->cyclecounter, ns);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_ptp_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nstruct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);\r\nBNX2X_ERR("PHC ancillary features are not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nstatic void bnx2x_register_phc(struct bnx2x *bp)\r\n{\r\nbp->ptp_clock_info.owner = THIS_MODULE;\r\nsnprintf(bp->ptp_clock_info.name, 16, "%s", bp->dev->name);\r\nbp->ptp_clock_info.max_adj = BNX2X_MAX_PHC_DRIFT;\r\nbp->ptp_clock_info.n_alarm = 0;\r\nbp->ptp_clock_info.n_ext_ts = 0;\r\nbp->ptp_clock_info.n_per_out = 0;\r\nbp->ptp_clock_info.pps = 0;\r\nbp->ptp_clock_info.adjfreq = bnx2x_ptp_adjfreq;\r\nbp->ptp_clock_info.adjtime = bnx2x_ptp_adjtime;\r\nbp->ptp_clock_info.gettime64 = bnx2x_ptp_gettime;\r\nbp->ptp_clock_info.settime64 = bnx2x_ptp_settime;\r\nbp->ptp_clock_info.enable = bnx2x_ptp_enable;\r\nbp->ptp_clock = ptp_clock_register(&bp->ptp_clock_info, &bp->pdev->dev);\r\nif (IS_ERR(bp->ptp_clock)) {\r\nbp->ptp_clock = NULL;\r\nBNX2X_ERR("PTP clock registeration failed\n");\r\n}\r\n}\r\nstatic int bnx2x_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev = NULL;\r\nstruct bnx2x *bp;\r\nenum pcie_link_width pcie_width;\r\nenum pci_bus_speed pcie_speed;\r\nint rc, max_non_def_sbs;\r\nint rx_count, tx_count, rss_count, doorbell_size;\r\nint max_cos_est;\r\nbool is_vf;\r\nint cnic_cnt;\r\nif (is_kdump_kernel()) {\r\nktime_t now = ktime_get_boottime();\r\nktime_t fw_ready_time = ktime_set(5, 0);\r\nif (ktime_before(now, fw_ready_time))\r\nmsleep(ktime_ms_delta(fw_ready_time, now));\r\n}\r\nmax_cos_est = set_max_cos_est(ent->driver_data);\r\nif (max_cos_est < 0)\r\nreturn max_cos_est;\r\nis_vf = set_is_vf(ent->driver_data);\r\ncnic_cnt = is_vf ? 0 : 1;\r\nmax_non_def_sbs = bnx2x_get_num_non_def_sbs(pdev, cnic_cnt);\r\nmax_non_def_sbs += is_vf ? 1 : 0;\r\nrss_count = max_non_def_sbs - cnic_cnt;\r\nif (rss_count < 1)\r\nreturn -EINVAL;\r\nrx_count = rss_count + cnic_cnt;\r\ntx_count = rss_count * max_cos_est + cnic_cnt;\r\ndev = alloc_etherdev_mqs(sizeof(*bp), tx_count, rx_count);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nbp = netdev_priv(dev);\r\nbp->flags = 0;\r\nif (is_vf)\r\nbp->flags |= IS_VF_FLAG;\r\nbp->igu_sb_cnt = max_non_def_sbs;\r\nbp->igu_base_addr = IS_VF(bp) ? PXP_VF_ADDR_IGU_START : BAR_IGU_INTMEM;\r\nbp->msg_enable = debug;\r\nbp->cnic_support = cnic_cnt;\r\nbp->cnic_probe = bnx2x_cnic_probe;\r\npci_set_drvdata(pdev, dev);\r\nrc = bnx2x_init_dev(bp, pdev, dev, ent->driver_data);\r\nif (rc < 0) {\r\nfree_netdev(dev);\r\nreturn rc;\r\n}\r\nBNX2X_DEV_INFO("This is a %s function\n",\r\nIS_PF(bp) ? "physical" : "virtual");\r\nBNX2X_DEV_INFO("Cnic support is %s\n", CNIC_SUPPORT(bp) ? "on" : "off");\r\nBNX2X_DEV_INFO("Max num of status blocks %d\n", max_non_def_sbs);\r\nBNX2X_DEV_INFO("Allocated netdev with %d tx and %d rx queues\n",\r\ntx_count, rx_count);\r\nrc = bnx2x_init_bp(bp);\r\nif (rc)\r\ngoto init_one_exit;\r\nif (IS_VF(bp)) {\r\nbp->doorbells = bnx2x_vf_doorbells(bp);\r\nrc = bnx2x_vf_pci_alloc(bp);\r\nif (rc)\r\ngoto init_one_freemem;\r\n} else {\r\ndoorbell_size = BNX2X_L2_MAX_CID(bp) * (1 << BNX2X_DB_SHIFT);\r\nif (doorbell_size > pci_resource_len(pdev, 2)) {\r\ndev_err(&bp->pdev->dev,\r\n"Cannot map doorbells, bar size too small, aborting\n");\r\nrc = -ENOMEM;\r\ngoto init_one_freemem;\r\n}\r\nbp->doorbells = ioremap_nocache(pci_resource_start(pdev, 2),\r\ndoorbell_size);\r\n}\r\nif (!bp->doorbells) {\r\ndev_err(&bp->pdev->dev,\r\n"Cannot map doorbell space, aborting\n");\r\nrc = -ENOMEM;\r\ngoto init_one_freemem;\r\n}\r\nif (IS_VF(bp)) {\r\nrc = bnx2x_vfpf_acquire(bp, tx_count, rx_count);\r\nif (rc)\r\ngoto init_one_freemem;\r\n#ifdef CONFIG_BNX2X_SRIOV\r\nif (bp->acquire_resp.pfdev_info.pf_cap & PFVF_CAP_VLAN_FILTER) {\r\ndev->hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;\r\ndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\r\n}\r\n#endif\r\n}\r\nrc = bnx2x_iov_init_one(bp, int_mode, BNX2X_MAX_NUM_OF_VFS);\r\nif (rc)\r\ngoto init_one_freemem;\r\nbp->qm_cid_count = bnx2x_set_qm_cid_count(bp);\r\nBNX2X_DEV_INFO("qm_cid_count %d\n", bp->qm_cid_count);\r\nif (CHIP_IS_E1x(bp))\r\nbp->flags |= NO_FCOE_FLAG;\r\nbnx2x_set_num_queues(bp);\r\nrc = bnx2x_set_int_mode(bp);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Cannot set interrupts\n");\r\ngoto init_one_freemem;\r\n}\r\nBNX2X_DEV_INFO("set interrupts successfully\n");\r\nrc = register_netdev(dev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Cannot register net device\n");\r\ngoto init_one_freemem;\r\n}\r\nBNX2X_DEV_INFO("device name after netdev register %s\n", dev->name);\r\nif (!NO_FCOE(bp)) {\r\nrtnl_lock();\r\ndev_addr_add(bp->dev, bp->fip_mac, NETDEV_HW_ADDR_T_SAN);\r\nrtnl_unlock();\r\n}\r\nif (pcie_get_minimum_link(bp->pdev, &pcie_speed, &pcie_width) ||\r\npcie_speed == PCI_SPEED_UNKNOWN ||\r\npcie_width == PCIE_LNK_WIDTH_UNKNOWN)\r\nBNX2X_DEV_INFO("Failed to determine PCI Express Bandwidth\n");\r\nelse\r\nBNX2X_DEV_INFO(\r\n"%s (%c%d) PCI-E x%d %s found at mem %lx, IRQ %d, node addr %pM\n",\r\nboard_info[ent->driver_data].name,\r\n(CHIP_REV(bp) >> 12) + 'A', (CHIP_METAL(bp) >> 4),\r\npcie_width,\r\npcie_speed == PCIE_SPEED_2_5GT ? "2.5GHz" :\r\npcie_speed == PCIE_SPEED_5_0GT ? "5.0GHz" :\r\npcie_speed == PCIE_SPEED_8_0GT ? "8.0GHz" :\r\n"Unknown",\r\ndev->base_addr, bp->pdev->irq, dev->dev_addr);\r\nbnx2x_register_phc(bp);\r\nif (!IS_MF_SD_STORAGE_PERSONALITY_ONLY(bp))\r\nbnx2x_set_os_driver_state(bp, OS_DRIVER_STATE_DISABLED);\r\nreturn 0;\r\ninit_one_freemem:\r\nbnx2x_free_mem_bp(bp);\r\ninit_one_exit:\r\nbnx2x_disable_pcie_error_reporting(bp);\r\nif (bp->regview)\r\niounmap(bp->regview);\r\nif (IS_PF(bp) && bp->doorbells)\r\niounmap(bp->doorbells);\r\nfree_netdev(dev);\r\nif (atomic_read(&pdev->enable_cnt) == 1)\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nreturn rc;\r\n}\r\nstatic void __bnx2x_remove(struct pci_dev *pdev,\r\nstruct net_device *dev,\r\nstruct bnx2x *bp,\r\nbool remove_netdev)\r\n{\r\nif (bp->ptp_clock) {\r\nptp_clock_unregister(bp->ptp_clock);\r\nbp->ptp_clock = NULL;\r\n}\r\nif (!NO_FCOE(bp)) {\r\nrtnl_lock();\r\ndev_addr_del(bp->dev, bp->fip_mac, NETDEV_HW_ADDR_T_SAN);\r\nrtnl_unlock();\r\n}\r\n#ifdef BCM_DCBNL\r\nbnx2x_dcbnl_update_applist(bp, true);\r\n#endif\r\nif (IS_PF(bp) &&\r\n!BP_NOMCP(bp) &&\r\n(bp->flags & BC_SUPPORTS_RMMOD_CMD))\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_RMMOD, 0);\r\nif (remove_netdev) {\r\nunregister_netdev(dev);\r\n} else {\r\nrtnl_lock();\r\ndev_close(dev);\r\nrtnl_unlock();\r\n}\r\nbnx2x_iov_remove_one(bp);\r\nif (IS_PF(bp)) {\r\nbnx2x_set_power_state(bp, PCI_D0);\r\nbnx2x_set_os_driver_state(bp, OS_DRIVER_STATE_NOT_LOADED);\r\nbnx2x_reset_endianity(bp);\r\n}\r\nbnx2x_disable_msi(bp);\r\nif (IS_PF(bp))\r\nbnx2x_set_power_state(bp, PCI_D3hot);\r\ncancel_delayed_work_sync(&bp->sp_rtnl_task);\r\nif (IS_VF(bp))\r\nbnx2x_vfpf_release(bp);\r\nif (system_state == SYSTEM_POWER_OFF) {\r\npci_wake_from_d3(pdev, bp->wol);\r\npci_set_power_state(pdev, PCI_D3hot);\r\n}\r\nbnx2x_disable_pcie_error_reporting(bp);\r\nif (remove_netdev) {\r\nif (bp->regview)\r\niounmap(bp->regview);\r\nif (IS_PF(bp)) {\r\nif (bp->doorbells)\r\niounmap(bp->doorbells);\r\nbnx2x_release_firmware(bp);\r\n} else {\r\nbnx2x_vf_pci_dealloc(bp);\r\n}\r\nbnx2x_free_mem_bp(bp);\r\nfree_netdev(dev);\r\nif (atomic_read(&pdev->enable_cnt) == 1)\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\n}\r\nstatic void bnx2x_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct bnx2x *bp;\r\nif (!dev) {\r\ndev_err(&pdev->dev, "BAD net device from bnx2x_init_one\n");\r\nreturn;\r\n}\r\nbp = netdev_priv(dev);\r\n__bnx2x_remove(pdev, dev, bp, true);\r\n}\r\nstatic int bnx2x_eeh_nic_unload(struct bnx2x *bp)\r\n{\r\nbp->state = BNX2X_STATE_CLOSING_WAIT4_HALT;\r\nbp->rx_mode = BNX2X_RX_MODE_NONE;\r\nif (CNIC_LOADED(bp))\r\nbnx2x_cnic_notify(bp, CNIC_CTL_STOP_CMD);\r\nbnx2x_tx_disable(bp);\r\nbnx2x_del_all_napi(bp);\r\nif (CNIC_LOADED(bp))\r\nbnx2x_del_all_napi_cnic(bp);\r\nnetdev_reset_tc(bp->dev);\r\ndel_timer_sync(&bp->timer);\r\ncancel_delayed_work_sync(&bp->sp_task);\r\ncancel_delayed_work_sync(&bp->period_task);\r\nif (!down_timeout(&bp->stats_lock, HZ / 10)) {\r\nbp->stats_state = STATS_STATE_DISABLED;\r\nup(&bp->stats_lock);\r\n}\r\nbnx2x_save_statistics(bp);\r\nnetif_carrier_off(bp->dev);\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t bnx2x_io_error_detected(struct pci_dev *pdev,\r\npci_channel_state_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nrtnl_lock();\r\nBNX2X_ERR("IO error detected\n");\r\nnetif_device_detach(dev);\r\nif (state == pci_channel_io_perm_failure) {\r\nrtnl_unlock();\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\nif (netif_running(dev))\r\nbnx2x_eeh_nic_unload(bp);\r\nbnx2x_prev_path_mark_eeh(bp);\r\npci_disable_device(pdev);\r\nrtnl_unlock();\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t bnx2x_io_slot_reset(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nint i;\r\nrtnl_lock();\r\nBNX2X_ERR("IO slot reset initializing...\n");\r\nif (pci_enable_device(pdev)) {\r\ndev_err(&pdev->dev,\r\n"Cannot re-enable PCI device after reset\n");\r\nrtnl_unlock();\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\npci_set_master(pdev);\r\npci_restore_state(pdev);\r\npci_save_state(pdev);\r\nif (netif_running(dev))\r\nbnx2x_set_power_state(bp, PCI_D0);\r\nif (netif_running(dev)) {\r\nBNX2X_ERR("IO slot reset --> driver unload\n");\r\nbnx2x_init_shmem(bp);\r\nif (IS_PF(bp) && SHMEM2_HAS(bp, drv_capabilities_flag)) {\r\nu32 v;\r\nv = SHMEM2_RD(bp,\r\ndrv_capabilities_flag[BP_FW_MB_IDX(bp)]);\r\nSHMEM2_WR(bp, drv_capabilities_flag[BP_FW_MB_IDX(bp)],\r\nv & ~DRV_FLAGS_CAPABILITIES_LOADED_L2);\r\n}\r\nbnx2x_drain_tx_queues(bp);\r\nbnx2x_send_unload_req(bp, UNLOAD_RECOVERY);\r\nbnx2x_netif_stop(bp, 1);\r\nbnx2x_free_irq(bp);\r\nbnx2x_send_unload_done(bp, true);\r\nbp->sp_state = 0;\r\nbp->port.pmf = 0;\r\nbnx2x_prev_unload(bp);\r\nbnx2x_squeeze_objects(bp);\r\nbnx2x_free_skbs(bp);\r\nfor_each_rx_queue(bp, i)\r\nbnx2x_free_rx_sge_range(bp, bp->fp + i, NUM_RX_SGE);\r\nbnx2x_free_fp_mem(bp);\r\nbnx2x_free_mem(bp);\r\nbp->state = BNX2X_STATE_CLOSED;\r\n}\r\nrtnl_unlock();\r\nif (bp->flags & AER_ENABLED) {\r\nif (pci_cleanup_aer_uncorrect_error_status(pdev))\r\nBNX2X_ERR("pci_cleanup_aer_uncorrect_error_status failed\n");\r\nelse\r\nDP(NETIF_MSG_HW, "pci_cleanup_aer_uncorrect_error_status succeeded\n");\r\n}\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\n}\r\nstatic void bnx2x_io_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nif (bp->recovery_state != BNX2X_RECOVERY_DONE) {\r\nnetdev_err(bp->dev, "Handling parity error recovery. Try again later\n");\r\nreturn;\r\n}\r\nrtnl_lock();\r\nbp->fw_seq = SHMEM_RD(bp, func_mb[BP_FW_MB_IDX(bp)].drv_mb_header) &\r\nDRV_MSG_SEQ_NUMBER_MASK;\r\nif (netif_running(dev))\r\nbnx2x_nic_load(bp, LOAD_NORMAL);\r\nnetif_device_attach(dev);\r\nrtnl_unlock();\r\n}\r\nstatic void bnx2x_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct bnx2x *bp;\r\nif (!dev)\r\nreturn;\r\nbp = netdev_priv(dev);\r\nif (!bp)\r\nreturn;\r\nrtnl_lock();\r\nnetif_device_detach(dev);\r\nrtnl_unlock();\r\n__bnx2x_remove(pdev, dev, bp, false);\r\n}\r\nstatic int __init bnx2x_init(void)\r\n{\r\nint ret;\r\npr_info("%s", version);\r\nbnx2x_wq = create_singlethread_workqueue("bnx2x");\r\nif (bnx2x_wq == NULL) {\r\npr_err("Cannot create workqueue\n");\r\nreturn -ENOMEM;\r\n}\r\nbnx2x_iov_wq = create_singlethread_workqueue("bnx2x_iov");\r\nif (!bnx2x_iov_wq) {\r\npr_err("Cannot create iov workqueue\n");\r\ndestroy_workqueue(bnx2x_wq);\r\nreturn -ENOMEM;\r\n}\r\nret = pci_register_driver(&bnx2x_pci_driver);\r\nif (ret) {\r\npr_err("Cannot register driver\n");\r\ndestroy_workqueue(bnx2x_wq);\r\ndestroy_workqueue(bnx2x_iov_wq);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit bnx2x_cleanup(void)\r\n{\r\nstruct list_head *pos, *q;\r\npci_unregister_driver(&bnx2x_pci_driver);\r\ndestroy_workqueue(bnx2x_wq);\r\ndestroy_workqueue(bnx2x_iov_wq);\r\nlist_for_each_safe(pos, q, &bnx2x_prev_list) {\r\nstruct bnx2x_prev_path_list *tmp =\r\nlist_entry(pos, struct bnx2x_prev_path_list, list);\r\nlist_del(pos);\r\nkfree(tmp);\r\n}\r\n}\r\nvoid bnx2x_notify_link_changed(struct bnx2x *bp)\r\n{\r\nREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_12 + BP_FUNC(bp)*sizeof(u32), 1);\r\n}\r\nstatic int bnx2x_set_iscsi_eth_mac_addr(struct bnx2x *bp)\r\n{\r\nunsigned long ramrod_flags = 0;\r\n__set_bit(RAMROD_COMP_WAIT, &ramrod_flags);\r\nreturn bnx2x_set_mac_one(bp, bp->cnic_eth_dev.iscsi_mac,\r\n&bp->iscsi_l2_mac_obj, true,\r\nBNX2X_ISCSI_ETH_MAC, &ramrod_flags);\r\n}\r\nstatic void bnx2x_cnic_sp_post(struct bnx2x *bp, int count)\r\n{\r\nstruct eth_spe *spe;\r\nint cxt_index, cxt_offset;\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nif (unlikely(bp->panic))\r\nreturn;\r\n#endif\r\nspin_lock_bh(&bp->spq_lock);\r\nBUG_ON(bp->cnic_spq_pending < count);\r\nbp->cnic_spq_pending -= count;\r\nfor (; bp->cnic_kwq_pending; bp->cnic_kwq_pending--) {\r\nu16 type = (le16_to_cpu(bp->cnic_kwq_cons->hdr.type)\r\n& SPE_HDR_CONN_TYPE) >>\r\nSPE_HDR_CONN_TYPE_SHIFT;\r\nu8 cmd = (le32_to_cpu(bp->cnic_kwq_cons->hdr.conn_and_cmd_data)\r\n>> SPE_HDR_CMD_ID_SHIFT) & 0xff;\r\nif (type == ETH_CONNECTION_TYPE) {\r\nif (cmd == RAMROD_CMD_ID_ETH_CLIENT_SETUP) {\r\ncxt_index = BNX2X_ISCSI_ETH_CID(bp) /\r\nILT_PAGE_CIDS;\r\ncxt_offset = BNX2X_ISCSI_ETH_CID(bp) -\r\n(cxt_index * ILT_PAGE_CIDS);\r\nbnx2x_set_ctx_validation(bp,\r\n&bp->context[cxt_index].\r\nvcxt[cxt_offset].eth,\r\nBNX2X_ISCSI_ETH_CID(bp));\r\n}\r\n}\r\nif (type == ETH_CONNECTION_TYPE) {\r\nif (!atomic_read(&bp->cq_spq_left))\r\nbreak;\r\nelse\r\natomic_dec(&bp->cq_spq_left);\r\n} else if (type == NONE_CONNECTION_TYPE) {\r\nif (!atomic_read(&bp->eq_spq_left))\r\nbreak;\r\nelse\r\natomic_dec(&bp->eq_spq_left);\r\n} else if ((type == ISCSI_CONNECTION_TYPE) ||\r\n(type == FCOE_CONNECTION_TYPE)) {\r\nif (bp->cnic_spq_pending >=\r\nbp->cnic_eth_dev.max_kwqe_pending)\r\nbreak;\r\nelse\r\nbp->cnic_spq_pending++;\r\n} else {\r\nBNX2X_ERR("Unknown SPE type: %d\n", type);\r\nbnx2x_panic();\r\nbreak;\r\n}\r\nspe = bnx2x_sp_get_next(bp);\r\n*spe = *bp->cnic_kwq_cons;\r\nDP(BNX2X_MSG_SP, "pending on SPQ %d, on KWQ %d count %d\n",\r\nbp->cnic_spq_pending, bp->cnic_kwq_pending, count);\r\nif (bp->cnic_kwq_cons == bp->cnic_kwq_last)\r\nbp->cnic_kwq_cons = bp->cnic_kwq;\r\nelse\r\nbp->cnic_kwq_cons++;\r\n}\r\nbnx2x_sp_prod_update(bp);\r\nspin_unlock_bh(&bp->spq_lock);\r\n}\r\nstatic int bnx2x_cnic_sp_queue(struct net_device *dev,\r\nstruct kwqe_16 *kwqes[], u32 count)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nint i;\r\n#ifdef BNX2X_STOP_ON_ERROR\r\nif (unlikely(bp->panic)) {\r\nBNX2X_ERR("Can't post to SP queue while panic\n");\r\nreturn -EIO;\r\n}\r\n#endif\r\nif ((bp->recovery_state != BNX2X_RECOVERY_DONE) &&\r\n(bp->recovery_state != BNX2X_RECOVERY_NIC_LOADING)) {\r\nBNX2X_ERR("Handling parity error recovery. Try again later\n");\r\nreturn -EAGAIN;\r\n}\r\nspin_lock_bh(&bp->spq_lock);\r\nfor (i = 0; i < count; i++) {\r\nstruct eth_spe *spe = (struct eth_spe *)kwqes[i];\r\nif (bp->cnic_kwq_pending == MAX_SP_DESC_CNT)\r\nbreak;\r\n*bp->cnic_kwq_prod = *spe;\r\nbp->cnic_kwq_pending++;\r\nDP(BNX2X_MSG_SP, "L5 SPQE %x %x %x:%x pos %d\n",\r\nspe->hdr.conn_and_cmd_data, spe->hdr.type,\r\nspe->data.update_data_addr.hi,\r\nspe->data.update_data_addr.lo,\r\nbp->cnic_kwq_pending);\r\nif (bp->cnic_kwq_prod == bp->cnic_kwq_last)\r\nbp->cnic_kwq_prod = bp->cnic_kwq;\r\nelse\r\nbp->cnic_kwq_prod++;\r\n}\r\nspin_unlock_bh(&bp->spq_lock);\r\nif (bp->cnic_spq_pending < bp->cnic_eth_dev.max_kwqe_pending)\r\nbnx2x_cnic_sp_post(bp, 0);\r\nreturn i;\r\n}\r\nstatic int bnx2x_cnic_ctl_send(struct bnx2x *bp, struct cnic_ctl_info *ctl)\r\n{\r\nstruct cnic_ops *c_ops;\r\nint rc = 0;\r\nmutex_lock(&bp->cnic_mutex);\r\nc_ops = rcu_dereference_protected(bp->cnic_ops,\r\nlockdep_is_held(&bp->cnic_mutex));\r\nif (c_ops)\r\nrc = c_ops->cnic_ctl(bp->cnic_data, ctl);\r\nmutex_unlock(&bp->cnic_mutex);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_cnic_ctl_send_bh(struct bnx2x *bp, struct cnic_ctl_info *ctl)\r\n{\r\nstruct cnic_ops *c_ops;\r\nint rc = 0;\r\nrcu_read_lock();\r\nc_ops = rcu_dereference(bp->cnic_ops);\r\nif (c_ops)\r\nrc = c_ops->cnic_ctl(bp->cnic_data, ctl);\r\nrcu_read_unlock();\r\nreturn rc;\r\n}\r\nint bnx2x_cnic_notify(struct bnx2x *bp, int cmd)\r\n{\r\nstruct cnic_ctl_info ctl = {0};\r\nctl.cmd = cmd;\r\nreturn bnx2x_cnic_ctl_send(bp, &ctl);\r\n}\r\nstatic void bnx2x_cnic_cfc_comp(struct bnx2x *bp, int cid, u8 err)\r\n{\r\nstruct cnic_ctl_info ctl = {0};\r\nctl.cmd = CNIC_CTL_COMPLETION_CMD;\r\nctl.data.comp.cid = cid;\r\nctl.data.comp.error = err;\r\nbnx2x_cnic_ctl_send_bh(bp, &ctl);\r\nbnx2x_cnic_sp_post(bp, 0);\r\n}\r\nstatic void bnx2x_set_iscsi_eth_rx_mode(struct bnx2x *bp, bool start)\r\n{\r\nunsigned long accept_flags = 0, ramrod_flags = 0;\r\nu8 cl_id = bnx2x_cnic_eth_cl_id(bp, BNX2X_ISCSI_ETH_CL_ID_IDX);\r\nint sched_state = BNX2X_FILTER_ISCSI_ETH_STOP_SCHED;\r\nif (start) {\r\n__set_bit(BNX2X_ACCEPT_UNICAST, &accept_flags);\r\n__set_bit(BNX2X_ACCEPT_ALL_MULTICAST, &accept_flags);\r\n__set_bit(BNX2X_ACCEPT_BROADCAST, &accept_flags);\r\n__set_bit(BNX2X_ACCEPT_ANY_VLAN, &accept_flags);\r\nclear_bit(BNX2X_FILTER_ISCSI_ETH_STOP_SCHED, &bp->sp_state);\r\nsched_state = BNX2X_FILTER_ISCSI_ETH_START_SCHED;\r\n} else\r\nclear_bit(BNX2X_FILTER_ISCSI_ETH_START_SCHED, &bp->sp_state);\r\nif (test_bit(BNX2X_FILTER_RX_MODE_PENDING, &bp->sp_state))\r\nset_bit(sched_state, &bp->sp_state);\r\nelse {\r\n__set_bit(RAMROD_RX, &ramrod_flags);\r\nbnx2x_set_q_rx_mode(bp, cl_id, 0, accept_flags, 0,\r\nramrod_flags);\r\n}\r\n}\r\nstatic int bnx2x_drv_ctl(struct net_device *dev, struct drv_ctl_info *ctl)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nint rc = 0;\r\nswitch (ctl->cmd) {\r\ncase DRV_CTL_CTXTBL_WR_CMD: {\r\nu32 index = ctl->data.io.offset;\r\ndma_addr_t addr = ctl->data.io.dma_addr;\r\nbnx2x_ilt_wr(bp, index, addr);\r\nbreak;\r\n}\r\ncase DRV_CTL_RET_L5_SPQ_CREDIT_CMD: {\r\nint count = ctl->data.credit.credit_count;\r\nbnx2x_cnic_sp_post(bp, count);\r\nbreak;\r\n}\r\ncase DRV_CTL_START_L2_CMD: {\r\nstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\r\nunsigned long sp_bits = 0;\r\nbnx2x_init_mac_obj(bp, &bp->iscsi_l2_mac_obj,\r\ncp->iscsi_l2_client_id,\r\ncp->iscsi_l2_cid, BP_FUNC(bp),\r\nbnx2x_sp(bp, mac_rdata),\r\nbnx2x_sp_mapping(bp, mac_rdata),\r\nBNX2X_FILTER_MAC_PENDING,\r\n&bp->sp_state, BNX2X_OBJ_TYPE_RX,\r\n&bp->macs_pool);\r\nrc = bnx2x_set_iscsi_eth_mac_addr(bp);\r\nif (rc)\r\nbreak;\r\nmmiowb();\r\nbarrier();\r\nnetif_addr_lock_bh(dev);\r\nbnx2x_set_iscsi_eth_rx_mode(bp, true);\r\nnetif_addr_unlock_bh(dev);\r\n__set_bit(BNX2X_FILTER_RX_MODE_PENDING, &sp_bits);\r\n__set_bit(BNX2X_FILTER_ISCSI_ETH_START_SCHED, &sp_bits);\r\nif (!bnx2x_wait_sp_comp(bp, sp_bits))\r\nBNX2X_ERR("rx_mode completion timed out!\n");\r\nbreak;\r\n}\r\ncase DRV_CTL_STOP_L2_CMD: {\r\nunsigned long sp_bits = 0;\r\nnetif_addr_lock_bh(dev);\r\nbnx2x_set_iscsi_eth_rx_mode(bp, false);\r\nnetif_addr_unlock_bh(dev);\r\n__set_bit(BNX2X_FILTER_RX_MODE_PENDING, &sp_bits);\r\n__set_bit(BNX2X_FILTER_ISCSI_ETH_STOP_SCHED, &sp_bits);\r\nif (!bnx2x_wait_sp_comp(bp, sp_bits))\r\nBNX2X_ERR("rx_mode completion timed out!\n");\r\nmmiowb();\r\nbarrier();\r\nrc = bnx2x_del_all_macs(bp, &bp->iscsi_l2_mac_obj,\r\nBNX2X_ISCSI_ETH_MAC, true);\r\nbreak;\r\n}\r\ncase DRV_CTL_RET_L2_SPQ_CREDIT_CMD: {\r\nint count = ctl->data.credit.credit_count;\r\nsmp_mb__before_atomic();\r\natomic_add(count, &bp->cq_spq_left);\r\nsmp_mb__after_atomic();\r\nbreak;\r\n}\r\ncase DRV_CTL_ULP_REGISTER_CMD: {\r\nint ulp_type = ctl->data.register_data.ulp_type;\r\nif (CHIP_IS_E3(bp)) {\r\nint idx = BP_FW_MB_IDX(bp);\r\nu32 cap = SHMEM2_RD(bp, drv_capabilities_flag[idx]);\r\nint path = BP_PATH(bp);\r\nint port = BP_PORT(bp);\r\nint i;\r\nu32 scratch_offset;\r\nu32 *host_addr;\r\nif (ulp_type == CNIC_ULP_ISCSI)\r\ncap |= DRV_FLAGS_CAPABILITIES_LOADED_ISCSI;\r\nelse if (ulp_type == CNIC_ULP_FCOE)\r\ncap |= DRV_FLAGS_CAPABILITIES_LOADED_FCOE;\r\nSHMEM2_WR(bp, drv_capabilities_flag[idx], cap);\r\nif ((ulp_type != CNIC_ULP_FCOE) ||\r\n(!SHMEM2_HAS(bp, ncsi_oem_data_addr)) ||\r\n(!(bp->flags & BC_SUPPORTS_FCOE_FEATURES)))\r\nbreak;\r\nscratch_offset = SHMEM2_RD(bp, ncsi_oem_data_addr);\r\nif (!scratch_offset)\r\nbreak;\r\nscratch_offset += offsetof(struct glob_ncsi_oem_data,\r\nfcoe_features[path][port]);\r\nhost_addr = (u32 *) &(ctl->data.register_data.\r\nfcoe_features);\r\nfor (i = 0; i < sizeof(struct fcoe_capabilities);\r\ni += 4)\r\nREG_WR(bp, scratch_offset + i,\r\n*(host_addr + i/4));\r\n}\r\nbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_GET_DRV_VERSION, 0);\r\nbreak;\r\n}\r\ncase DRV_CTL_ULP_UNREGISTER_CMD: {\r\nint ulp_type = ctl->data.ulp_type;\r\nif (CHIP_IS_E3(bp)) {\r\nint idx = BP_FW_MB_IDX(bp);\r\nu32 cap;\r\ncap = SHMEM2_RD(bp, drv_capabilities_flag[idx]);\r\nif (ulp_type == CNIC_ULP_ISCSI)\r\ncap &= ~DRV_FLAGS_CAPABILITIES_LOADED_ISCSI;\r\nelse if (ulp_type == CNIC_ULP_FCOE)\r\ncap &= ~DRV_FLAGS_CAPABILITIES_LOADED_FCOE;\r\nSHMEM2_WR(bp, drv_capabilities_flag[idx], cap);\r\n}\r\nbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_GET_DRV_VERSION, 0);\r\nbreak;\r\n}\r\ndefault:\r\nBNX2X_ERR("unknown command %x\n", ctl->cmd);\r\nrc = -EINVAL;\r\n}\r\nif (IS_MF_SD_STORAGE_PERSONALITY_ONLY(bp)) {\r\nswitch (ctl->drv_state) {\r\ncase DRV_NOP:\r\nbreak;\r\ncase DRV_ACTIVE:\r\nbnx2x_set_os_driver_state(bp,\r\nOS_DRIVER_STATE_ACTIVE);\r\nbreak;\r\ncase DRV_INACTIVE:\r\nbnx2x_set_os_driver_state(bp,\r\nOS_DRIVER_STATE_DISABLED);\r\nbreak;\r\ncase DRV_UNLOADED:\r\nbnx2x_set_os_driver_state(bp,\r\nOS_DRIVER_STATE_NOT_LOADED);\r\nbreak;\r\ndefault:\r\nBNX2X_ERR("Unknown cnic driver state: %d\n", ctl->drv_state);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int bnx2x_get_fc_npiv(struct net_device *dev,\r\nstruct cnic_fc_npiv_tbl *cnic_tbl)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nstruct bdn_fc_npiv_tbl *tbl = NULL;\r\nu32 offset, entries;\r\nint rc = -EINVAL;\r\nint i;\r\nif (!SHMEM2_HAS(bp, fc_npiv_nvram_tbl_addr[0]))\r\ngoto out;\r\nDP(BNX2X_MSG_MCP, "About to read the FC-NPIV table\n");\r\ntbl = kmalloc(sizeof(*tbl), GFP_KERNEL);\r\nif (!tbl) {\r\nBNX2X_ERR("Failed to allocate fc_npiv table\n");\r\ngoto out;\r\n}\r\noffset = SHMEM2_RD(bp, fc_npiv_nvram_tbl_addr[BP_PORT(bp)]);\r\nif (!offset) {\r\nDP(BNX2X_MSG_MCP, "No FC-NPIV in NVRAM\n");\r\ngoto out;\r\n}\r\nDP(BNX2X_MSG_MCP, "Offset of FC-NPIV in NVRAM: %08x\n", offset);\r\nif (bnx2x_nvram_read(bp, offset, (u8 *)tbl, sizeof(*tbl))) {\r\nBNX2X_ERR("Failed to read FC-NPIV table\n");\r\ngoto out;\r\n}\r\nentries = tbl->fc_npiv_cfg.num_of_npiv;\r\nentries = (__force u32)be32_to_cpu((__force __be32)entries);\r\ntbl->fc_npiv_cfg.num_of_npiv = entries;\r\nif (!tbl->fc_npiv_cfg.num_of_npiv) {\r\nDP(BNX2X_MSG_MCP,\r\n"No FC-NPIV table [valid, simply not present]\n");\r\ngoto out;\r\n} else if (tbl->fc_npiv_cfg.num_of_npiv > MAX_NUMBER_NPIV) {\r\nBNX2X_ERR("FC-NPIV table with bad length 0x%08x\n",\r\ntbl->fc_npiv_cfg.num_of_npiv);\r\ngoto out;\r\n} else {\r\nDP(BNX2X_MSG_MCP, "Read 0x%08x entries from NVRAM\n",\r\ntbl->fc_npiv_cfg.num_of_npiv);\r\n}\r\ncnic_tbl->count = tbl->fc_npiv_cfg.num_of_npiv;\r\nfor (i = 0; i < cnic_tbl->count; i++) {\r\nmemcpy(cnic_tbl->wwpn[i], tbl->settings[i].npiv_wwpn, 8);\r\nmemcpy(cnic_tbl->wwnn[i], tbl->settings[i].npiv_wwnn, 8);\r\n}\r\nrc = 0;\r\nout:\r\nkfree(tbl);\r\nreturn rc;\r\n}\r\nvoid bnx2x_setup_cnic_irq_info(struct bnx2x *bp)\r\n{\r\nstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\r\nif (bp->flags & USING_MSIX_FLAG) {\r\ncp->drv_state |= CNIC_DRV_STATE_USING_MSIX;\r\ncp->irq_arr[0].irq_flags |= CNIC_IRQ_FL_MSIX;\r\ncp->irq_arr[0].vector = bp->msix_table[1].vector;\r\n} else {\r\ncp->drv_state &= ~CNIC_DRV_STATE_USING_MSIX;\r\ncp->irq_arr[0].irq_flags &= ~CNIC_IRQ_FL_MSIX;\r\n}\r\nif (!CHIP_IS_E1x(bp))\r\ncp->irq_arr[0].status_blk = (void *)bp->cnic_sb.e2_sb;\r\nelse\r\ncp->irq_arr[0].status_blk = (void *)bp->cnic_sb.e1x_sb;\r\ncp->irq_arr[0].status_blk_num = bnx2x_cnic_fw_sb_id(bp);\r\ncp->irq_arr[0].status_blk_num2 = bnx2x_cnic_igu_sb_id(bp);\r\ncp->irq_arr[1].status_blk = bp->def_status_blk;\r\ncp->irq_arr[1].status_blk_num = DEF_SB_ID;\r\ncp->irq_arr[1].status_blk_num2 = DEF_SB_IGU_ID;\r\ncp->num_irq = 2;\r\n}\r\nvoid bnx2x_setup_cnic_info(struct bnx2x *bp)\r\n{\r\nstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\r\ncp->ctx_tbl_offset = FUNC_ILT_BASE(BP_FUNC(bp)) +\r\nbnx2x_cid_ilt_lines(bp);\r\ncp->starting_cid = bnx2x_cid_ilt_lines(bp) * ILT_PAGE_CIDS;\r\ncp->fcoe_init_cid = BNX2X_FCOE_ETH_CID(bp);\r\ncp->iscsi_l2_cid = BNX2X_ISCSI_ETH_CID(bp);\r\nDP(NETIF_MSG_IFUP, "BNX2X_1st_NON_L2_ETH_CID(bp) %x, cp->starting_cid %x, cp->fcoe_init_cid %x, cp->iscsi_l2_cid %x\n",\r\nBNX2X_1st_NON_L2_ETH_CID(bp), cp->starting_cid, cp->fcoe_init_cid,\r\ncp->iscsi_l2_cid);\r\nif (NO_ISCSI_OOO(bp))\r\ncp->drv_state |= CNIC_DRV_STATE_NO_ISCSI_OOO;\r\n}\r\nstatic int bnx2x_register_cnic(struct net_device *dev, struct cnic_ops *ops,\r\nvoid *data)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\r\nint rc;\r\nDP(NETIF_MSG_IFUP, "Register_cnic called\n");\r\nif (ops == NULL) {\r\nBNX2X_ERR("NULL ops received\n");\r\nreturn -EINVAL;\r\n}\r\nif (!CNIC_SUPPORT(bp)) {\r\nBNX2X_ERR("Can't register CNIC when not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (!CNIC_LOADED(bp)) {\r\nrc = bnx2x_load_cnic(bp);\r\nif (rc) {\r\nBNX2X_ERR("CNIC-related load failed\n");\r\nreturn rc;\r\n}\r\n}\r\nbp->cnic_enabled = true;\r\nbp->cnic_kwq = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!bp->cnic_kwq)\r\nreturn -ENOMEM;\r\nbp->cnic_kwq_cons = bp->cnic_kwq;\r\nbp->cnic_kwq_prod = bp->cnic_kwq;\r\nbp->cnic_kwq_last = bp->cnic_kwq + MAX_SP_DESC_CNT;\r\nbp->cnic_spq_pending = 0;\r\nbp->cnic_kwq_pending = 0;\r\nbp->cnic_data = data;\r\ncp->num_irq = 0;\r\ncp->drv_state |= CNIC_DRV_STATE_REGD;\r\ncp->iro_arr = bp->iro_arr;\r\nbnx2x_setup_cnic_irq_info(bp);\r\nrcu_assign_pointer(bp->cnic_ops, ops);\r\nbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_GET_DRV_VERSION, 0);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_unregister_cnic(struct net_device *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\r\nmutex_lock(&bp->cnic_mutex);\r\ncp->drv_state = 0;\r\nRCU_INIT_POINTER(bp->cnic_ops, NULL);\r\nmutex_unlock(&bp->cnic_mutex);\r\nsynchronize_rcu();\r\nbp->cnic_enabled = false;\r\nkfree(bp->cnic_kwq);\r\nbp->cnic_kwq = NULL;\r\nreturn 0;\r\n}\r\nstatic struct cnic_eth_dev *bnx2x_cnic_probe(struct net_device *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\r\nif (NO_ISCSI(bp) && NO_FCOE(bp))\r\nreturn NULL;\r\ncp->drv_owner = THIS_MODULE;\r\ncp->chip_id = CHIP_ID(bp);\r\ncp->pdev = bp->pdev;\r\ncp->io_base = bp->regview;\r\ncp->io_base2 = bp->doorbells;\r\ncp->max_kwqe_pending = 8;\r\ncp->ctx_blk_size = CDU_ILT_PAGE_SZ;\r\ncp->ctx_tbl_offset = FUNC_ILT_BASE(BP_FUNC(bp)) +\r\nbnx2x_cid_ilt_lines(bp);\r\ncp->ctx_tbl_len = CNIC_ILT_LINES;\r\ncp->starting_cid = bnx2x_cid_ilt_lines(bp) * ILT_PAGE_CIDS;\r\ncp->drv_submit_kwqes_16 = bnx2x_cnic_sp_queue;\r\ncp->drv_ctl = bnx2x_drv_ctl;\r\ncp->drv_get_fc_npiv_tbl = bnx2x_get_fc_npiv;\r\ncp->drv_register_cnic = bnx2x_register_cnic;\r\ncp->drv_unregister_cnic = bnx2x_unregister_cnic;\r\ncp->fcoe_init_cid = BNX2X_FCOE_ETH_CID(bp);\r\ncp->iscsi_l2_client_id =\r\nbnx2x_cnic_eth_cl_id(bp, BNX2X_ISCSI_ETH_CL_ID_IDX);\r\ncp->iscsi_l2_cid = BNX2X_ISCSI_ETH_CID(bp);\r\nif (NO_ISCSI_OOO(bp))\r\ncp->drv_state |= CNIC_DRV_STATE_NO_ISCSI_OOO;\r\nif (NO_ISCSI(bp))\r\ncp->drv_state |= CNIC_DRV_STATE_NO_ISCSI;\r\nif (NO_FCOE(bp))\r\ncp->drv_state |= CNIC_DRV_STATE_NO_FCOE;\r\nBNX2X_DEV_INFO(\r\n"page_size %d, tbl_offset %d, tbl_lines %d, starting cid %d\n",\r\ncp->ctx_blk_size,\r\ncp->ctx_tbl_offset,\r\ncp->ctx_tbl_len,\r\ncp->starting_cid);\r\nreturn cp;\r\n}\r\nstatic u32 bnx2x_rx_ustorm_prods_offset(struct bnx2x_fastpath *fp)\r\n{\r\nstruct bnx2x *bp = fp->bp;\r\nu32 offset = BAR_USTRORM_INTMEM;\r\nif (IS_VF(bp))\r\nreturn bnx2x_vf_ustorm_prods_offset(bp, fp);\r\nelse if (!CHIP_IS_E1x(bp))\r\noffset += USTORM_RX_PRODS_E2_OFFSET(fp->cl_qzone_id);\r\nelse\r\noffset += USTORM_RX_PRODS_E1X_OFFSET(BP_PORT(bp), fp->cl_id);\r\nreturn offset;\r\n}\r\nint bnx2x_pretend_func(struct bnx2x *bp, u16 pretend_func_val)\r\n{\r\nu32 pretend_reg;\r\nif (CHIP_IS_E1H(bp) && pretend_func_val >= E1H_FUNC_MAX)\r\nreturn -1;\r\npretend_reg = bnx2x_get_pretend_reg(bp);\r\nREG_WR(bp, pretend_reg, pretend_func_val);\r\nREG_RD(bp, pretend_reg);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_ptp_task(struct work_struct *work)\r\n{\r\nstruct bnx2x *bp = container_of(work, struct bnx2x, ptp_task);\r\nint port = BP_PORT(bp);\r\nu32 val_seq;\r\nu64 timestamp, ns;\r\nstruct skb_shared_hwtstamps shhwtstamps;\r\nval_seq = REG_RD(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_SEQID :\r\nNIG_REG_P0_TLLH_PTP_BUF_SEQID);\r\nif (val_seq & 0x10000) {\r\ntimestamp = REG_RD(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_TS_MSB :\r\nNIG_REG_P0_TLLH_PTP_BUF_TS_MSB);\r\ntimestamp <<= 32;\r\ntimestamp |= REG_RD(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_TS_LSB :\r\nNIG_REG_P0_TLLH_PTP_BUF_TS_LSB);\r\nREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_SEQID :\r\nNIG_REG_P0_TLLH_PTP_BUF_SEQID, 0x10000);\r\nns = timecounter_cyc2time(&bp->timecounter, timestamp);\r\nmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\r\nshhwtstamps.hwtstamp = ns_to_ktime(ns);\r\nskb_tstamp_tx(bp->ptp_tx_skb, &shhwtstamps);\r\ndev_kfree_skb_any(bp->ptp_tx_skb);\r\nbp->ptp_tx_skb = NULL;\r\nDP(BNX2X_MSG_PTP, "Tx timestamp, timestamp cycles = %llu, ns = %llu\n",\r\ntimestamp, ns);\r\n} else {\r\nDP(BNX2X_MSG_PTP, "There is no valid Tx timestamp yet\n");\r\nschedule_work(&bp->ptp_task);\r\n}\r\n}\r\nvoid bnx2x_set_rx_ts(struct bnx2x *bp, struct sk_buff *skb)\r\n{\r\nint port = BP_PORT(bp);\r\nu64 timestamp, ns;\r\ntimestamp = REG_RD(bp, port ? NIG_REG_P1_LLH_PTP_HOST_BUF_TS_MSB :\r\nNIG_REG_P0_LLH_PTP_HOST_BUF_TS_MSB);\r\ntimestamp <<= 32;\r\ntimestamp |= REG_RD(bp, port ? NIG_REG_P1_LLH_PTP_HOST_BUF_TS_LSB :\r\nNIG_REG_P0_LLH_PTP_HOST_BUF_TS_LSB);\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_HOST_BUF_SEQID :\r\nNIG_REG_P0_LLH_PTP_HOST_BUF_SEQID, 0x10000);\r\nns = timecounter_cyc2time(&bp->timecounter, timestamp);\r\nskb_hwtstamps(skb)->hwtstamp = ns_to_ktime(ns);\r\nDP(BNX2X_MSG_PTP, "Rx timestamp, timestamp cycles = %llu, ns = %llu\n",\r\ntimestamp, ns);\r\n}\r\nstatic u64 bnx2x_cyclecounter_read(const struct cyclecounter *cc)\r\n{\r\nstruct bnx2x *bp = container_of(cc, struct bnx2x, cyclecounter);\r\nint port = BP_PORT(bp);\r\nu32 wb_data[2];\r\nu64 phc_cycles;\r\nREG_RD_DMAE(bp, port ? NIG_REG_TIMESYNC_GEN_REG + tsgen_synctime_t1 :\r\nNIG_REG_TIMESYNC_GEN_REG + tsgen_synctime_t0, wb_data, 2);\r\nphc_cycles = wb_data[1];\r\nphc_cycles = (phc_cycles << 32) + wb_data[0];\r\nDP(BNX2X_MSG_PTP, "PHC read cycles = %llu\n", phc_cycles);\r\nreturn phc_cycles;\r\n}\r\nstatic void bnx2x_init_cyclecounter(struct bnx2x *bp)\r\n{\r\nmemset(&bp->cyclecounter, 0, sizeof(bp->cyclecounter));\r\nbp->cyclecounter.read = bnx2x_cyclecounter_read;\r\nbp->cyclecounter.mask = CYCLECOUNTER_MASK(64);\r\nbp->cyclecounter.shift = 0;\r\nbp->cyclecounter.mult = 1;\r\n}\r\nstatic int bnx2x_send_reset_timesync_ramrod(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_func_state_params func_params = {NULL};\r\nstruct bnx2x_func_set_timesync_params *set_timesync_params =\r\n&func_params.params.set_timesync;\r\n__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\r\n__set_bit(RAMROD_RETRY, &func_params.ramrod_flags);\r\nfunc_params.f_obj = &bp->func_obj;\r\nfunc_params.cmd = BNX2X_F_CMD_SET_TIMESYNC;\r\nset_timesync_params->drift_adjust_cmd = TS_DRIFT_ADJUST_RESET;\r\nset_timesync_params->offset_cmd = TS_OFFSET_KEEP;\r\nreturn bnx2x_func_state_change(bp, &func_params);\r\n}\r\nstatic int bnx2x_enable_ptp_packets(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_queue_state_params q_params;\r\nint rc, i;\r\nmemset(&q_params, 0, sizeof(q_params));\r\n__set_bit(RAMROD_COMP_WAIT, &q_params.ramrod_flags);\r\nq_params.cmd = BNX2X_Q_CMD_UPDATE;\r\n__set_bit(BNX2X_Q_UPDATE_PTP_PKTS_CHNG,\r\n&q_params.params.update.update_flags);\r\n__set_bit(BNX2X_Q_UPDATE_PTP_PKTS,\r\n&q_params.params.update.update_flags);\r\nfor_each_eth_queue(bp, i) {\r\nstruct bnx2x_fastpath *fp = &bp->fp[i];\r\nq_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\r\nrc = bnx2x_queue_state_change(bp, &q_params);\r\nif (rc) {\r\nBNX2X_ERR("Failed to enable PTP packets\n");\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint bnx2x_configure_ptp_filters(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nint rc;\r\nif (!bp->hwtstamp_ioctl_called)\r\nreturn 0;\r\nswitch (bp->tx_type) {\r\ncase HWTSTAMP_TX_ON:\r\nbp->flags |= TX_TIMESTAMPING_EN;\r\nREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_PARAM_MASK :\r\nNIG_REG_P0_TLLH_PTP_PARAM_MASK, 0x6AA);\r\nREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_RULE_MASK :\r\nNIG_REG_P0_TLLH_PTP_RULE_MASK, 0x3EEE);\r\nbreak;\r\ncase HWTSTAMP_TX_ONESTEP_SYNC:\r\nBNX2X_ERR("One-step timestamping is not supported\n");\r\nreturn -ERANGE;\r\n}\r\nswitch (bp->rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\nbreak;\r\ncase HWTSTAMP_FILTER_ALL:\r\ncase HWTSTAMP_FILTER_SOME:\r\ncase HWTSTAMP_FILTER_NTP_ALL:\r\nbp->rx_filter = HWTSTAMP_FILTER_NONE;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\nbp->rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_PARAM_MASK :\r\nNIG_REG_P0_LLH_PTP_PARAM_MASK, 0x7EE);\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_RULE_MASK :\r\nNIG_REG_P0_LLH_PTP_RULE_MASK, 0x3FFE);\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\nbp->rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_PARAM_MASK :\r\nNIG_REG_P0_LLH_PTP_PARAM_MASK, 0x7EA);\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_RULE_MASK :\r\nNIG_REG_P0_LLH_PTP_RULE_MASK, 0x3FEE);\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\nbp->rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_PARAM_MASK :\r\nNIG_REG_P0_LLH_PTP_PARAM_MASK, 0x6BF);\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_RULE_MASK :\r\nNIG_REG_P0_LLH_PTP_RULE_MASK, 0x3EFF);\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\nbp->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_PARAM_MASK :\r\nNIG_REG_P0_LLH_PTP_PARAM_MASK, 0x6AA);\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_RULE_MASK :\r\nNIG_REG_P0_LLH_PTP_RULE_MASK, 0x3EEE);\r\nbreak;\r\n}\r\nrc = bnx2x_enable_ptp_packets(bp);\r\nif (rc)\r\nreturn rc;\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_TO_HOST :\r\nNIG_REG_P0_LLH_PTP_TO_HOST, 0x1);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_hwtstamp_ioctl(struct bnx2x *bp, struct ifreq *ifr)\r\n{\r\nstruct hwtstamp_config config;\r\nint rc;\r\nDP(BNX2X_MSG_PTP, "HWTSTAMP IOCTL called\n");\r\nif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\r\nreturn -EFAULT;\r\nDP(BNX2X_MSG_PTP, "Requested tx_type: %d, requested rx_filters = %d\n",\r\nconfig.tx_type, config.rx_filter);\r\nif (config.flags) {\r\nBNX2X_ERR("config.flags is reserved for future use\n");\r\nreturn -EINVAL;\r\n}\r\nbp->hwtstamp_ioctl_called = 1;\r\nbp->tx_type = config.tx_type;\r\nbp->rx_filter = config.rx_filter;\r\nrc = bnx2x_configure_ptp_filters(bp);\r\nif (rc)\r\nreturn rc;\r\nconfig.rx_filter = bp->rx_filter;\r\nreturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\r\n-EFAULT : 0;\r\n}\r\nstatic int bnx2x_configure_ptp(struct bnx2x *bp)\r\n{\r\nint rc, port = BP_PORT(bp);\r\nu32 wb_data[2];\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_PARAM_MASK :\r\nNIG_REG_P0_LLH_PTP_PARAM_MASK, 0x7FF);\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_RULE_MASK :\r\nNIG_REG_P0_LLH_PTP_RULE_MASK, 0x3FFF);\r\nREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_PARAM_MASK :\r\nNIG_REG_P0_TLLH_PTP_PARAM_MASK, 0x7FF);\r\nREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_RULE_MASK :\r\nNIG_REG_P0_TLLH_PTP_RULE_MASK, 0x3FFF);\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_TO_HOST :\r\nNIG_REG_P0_LLH_PTP_TO_HOST, 0x0);\r\nREG_WR(bp, port ? NIG_REG_P1_PTP_EN :\r\nNIG_REG_P0_PTP_EN, 0x3F);\r\nwb_data[0] = 0;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, NIG_REG_TIMESYNC_GEN_REG + tsgen_ctrl, wb_data, 2);\r\nrc = bnx2x_send_reset_timesync_ramrod(bp);\r\nif (rc) {\r\nBNX2X_ERR("Failed to reset PHC drift register\n");\r\nreturn -EFAULT;\r\n}\r\nREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_HOST_BUF_SEQID :\r\nNIG_REG_P0_LLH_PTP_HOST_BUF_SEQID, 0x10000);\r\nREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_SEQID :\r\nNIG_REG_P0_TLLH_PTP_BUF_SEQID, 0x10000);\r\nreturn 0;\r\n}\r\nvoid bnx2x_init_ptp(struct bnx2x *bp)\r\n{\r\nint rc;\r\nrc = bnx2x_configure_ptp(bp);\r\nif (rc) {\r\nBNX2X_ERR("Stopping PTP initialization\n");\r\nreturn;\r\n}\r\nINIT_WORK(&bp->ptp_task, bnx2x_ptp_task);\r\nif (!bp->timecounter_init_done) {\r\nbnx2x_init_cyclecounter(bp);\r\ntimecounter_init(&bp->timecounter, &bp->cyclecounter,\r\nktime_to_ns(ktime_get_real()));\r\nbp->timecounter_init_done = 1;\r\n}\r\nDP(BNX2X_MSG_PTP, "PTP initialization ended successfully\n");\r\n}
