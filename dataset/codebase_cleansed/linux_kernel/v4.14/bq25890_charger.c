static int bq25890_field_read(struct bq25890_device *bq,\r\nenum bq25890_fields field_id)\r\n{\r\nint ret;\r\nint val;\r\nret = regmap_field_read(bq->rmap_fields[field_id], &val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn val;\r\n}\r\nstatic int bq25890_field_write(struct bq25890_device *bq,\r\nenum bq25890_fields field_id, u8 val)\r\n{\r\nreturn regmap_field_write(bq->rmap_fields[field_id], val);\r\n}\r\nstatic u8 bq25890_find_idx(u32 value, enum bq25890_table_ids id)\r\n{\r\nu8 idx;\r\nif (id >= TBL_TREG) {\r\nconst u32 *tbl = bq25890_tables[id].lt.tbl;\r\nu32 tbl_size = bq25890_tables[id].lt.size;\r\nfor (idx = 1; idx < tbl_size && tbl[idx] <= value; idx++)\r\n;\r\n} else {\r\nconst struct bq25890_range *rtbl = &bq25890_tables[id].rt;\r\nu8 rtbl_size;\r\nrtbl_size = (rtbl->max - rtbl->min) / rtbl->step + 1;\r\nfor (idx = 1;\r\nidx < rtbl_size && (idx * rtbl->step + rtbl->min <= value);\r\nidx++)\r\n;\r\n}\r\nreturn idx - 1;\r\n}\r\nstatic u32 bq25890_find_val(u8 idx, enum bq25890_table_ids id)\r\n{\r\nconst struct bq25890_range *rtbl;\r\nif (id >= TBL_TREG)\r\nreturn bq25890_tables[id].lt.tbl[idx];\r\nrtbl = &bq25890_tables[id].rt;\r\nreturn (rtbl->min + idx * rtbl->step);\r\n}\r\nstatic int bq25890_power_supply_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nint ret;\r\nstruct bq25890_device *bq = power_supply_get_drvdata(psy);\r\nstruct bq25890_state state;\r\nmutex_lock(&bq->lock);\r\nstate = bq->state;\r\nmutex_unlock(&bq->lock);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (!state.online)\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse if (state.chrg_status == STATUS_NOT_CHARGING)\r\nval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse if (state.chrg_status == STATUS_PRE_CHARGING ||\r\nstate.chrg_status == STATUS_FAST_CHARGING)\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nelse if (state.chrg_status == STATUS_TERMINATION_DONE)\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MANUFACTURER:\r\nval->strval = BQ25890_MANUFACTURER;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = state.online;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nif (!state.chrg_fault && !state.bat_fault && !state.boost_fault)\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\nelse if (state.bat_fault)\r\nval->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\r\nelse if (state.chrg_fault == CHRG_FAULT_TIMER_EXPIRED)\r\nval->intval = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;\r\nelse if (state.chrg_fault == CHRG_FAULT_THERMAL_SHUTDOWN)\r\nval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nelse\r\nval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\r\nret = bq25890_field_read(bq, F_ICHGR);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = ret * 50000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\r\nval->intval = bq25890_tables[TBL_ICHG].rt.max;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\r\nif (!state.online) {\r\nval->intval = 0;\r\nbreak;\r\n}\r\nret = bq25890_field_read(bq, F_BATV);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = 2304000 + ret * 20000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\r\nval->intval = bq25890_tables[TBL_VREG].rt.max;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\r\nval->intval = bq25890_find_val(bq->init_data.iterm, TBL_ITERM);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bq25890_get_chip_state(struct bq25890_device *bq,\r\nstruct bq25890_state *state)\r\n{\r\nint i, ret;\r\nstruct {\r\nenum bq25890_fields id;\r\nu8 *data;\r\n} state_fields[] = {\r\n{F_CHG_STAT, &state->chrg_status},\r\n{F_PG_STAT, &state->online},\r\n{F_VSYS_STAT, &state->vsys_status},\r\n{F_BOOST_FAULT, &state->boost_fault},\r\n{F_BAT_FAULT, &state->bat_fault},\r\n{F_CHG_FAULT, &state->chrg_fault}\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(state_fields); i++) {\r\nret = bq25890_field_read(bq, state_fields[i].id);\r\nif (ret < 0)\r\nreturn ret;\r\n*state_fields[i].data = ret;\r\n}\r\ndev_dbg(bq->dev, "S:CHG/PG/VSYS=%d/%d/%d, F:CHG/BOOST/BAT=%d/%d/%d\n",\r\nstate->chrg_status, state->online, state->vsys_status,\r\nstate->chrg_fault, state->boost_fault, state->bat_fault);\r\nreturn 0;\r\n}\r\nstatic bool bq25890_state_changed(struct bq25890_device *bq,\r\nstruct bq25890_state *new_state)\r\n{\r\nstruct bq25890_state old_state;\r\nmutex_lock(&bq->lock);\r\nold_state = bq->state;\r\nmutex_unlock(&bq->lock);\r\nreturn (old_state.chrg_status != new_state->chrg_status ||\r\nold_state.chrg_fault != new_state->chrg_fault ||\r\nold_state.online != new_state->online ||\r\nold_state.bat_fault != new_state->bat_fault ||\r\nold_state.boost_fault != new_state->boost_fault ||\r\nold_state.vsys_status != new_state->vsys_status);\r\n}\r\nstatic void bq25890_handle_state_change(struct bq25890_device *bq,\r\nstruct bq25890_state *new_state)\r\n{\r\nint ret;\r\nstruct bq25890_state old_state;\r\nmutex_lock(&bq->lock);\r\nold_state = bq->state;\r\nmutex_unlock(&bq->lock);\r\nif (!new_state->online) {\r\nret = bq25890_field_write(bq, F_CONV_START, 0);\r\nif (ret < 0)\r\ngoto error;\r\n} else if (!old_state.online) {\r\nret = bq25890_field_write(bq, F_CONV_START, 1);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nreturn;\r\nerror:\r\ndev_err(bq->dev, "Error communicating with the chip.\n");\r\n}\r\nstatic irqreturn_t bq25890_irq_handler_thread(int irq, void *private)\r\n{\r\nstruct bq25890_device *bq = private;\r\nint ret;\r\nstruct bq25890_state state;\r\nret = bq25890_get_chip_state(bq, &state);\r\nif (ret < 0)\r\ngoto handled;\r\nif (!bq25890_state_changed(bq, &state))\r\ngoto handled;\r\nbq25890_handle_state_change(bq, &state);\r\nmutex_lock(&bq->lock);\r\nbq->state = state;\r\nmutex_unlock(&bq->lock);\r\npower_supply_changed(bq->charger);\r\nhandled:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bq25890_chip_reset(struct bq25890_device *bq)\r\n{\r\nint ret;\r\nint rst_check_counter = 10;\r\nret = bq25890_field_write(bq, F_REG_RST, 1);\r\nif (ret < 0)\r\nreturn ret;\r\ndo {\r\nret = bq25890_field_read(bq, F_REG_RST);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(5, 10);\r\n} while (ret == 1 && --rst_check_counter);\r\nif (!rst_check_counter)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int bq25890_hw_init(struct bq25890_device *bq)\r\n{\r\nint ret;\r\nint i;\r\nstruct bq25890_state state;\r\nconst struct {\r\nenum bq25890_fields id;\r\nu32 value;\r\n} init_data[] = {\r\n{F_ICHG, bq->init_data.ichg},\r\n{F_VREG, bq->init_data.vreg},\r\n{F_ITERM, bq->init_data.iterm},\r\n{F_IPRECHG, bq->init_data.iprechg},\r\n{F_SYSVMIN, bq->init_data.sysvmin},\r\n{F_BOOSTV, bq->init_data.boostv},\r\n{F_BOOSTI, bq->init_data.boosti},\r\n{F_BOOSTF, bq->init_data.boostf},\r\n{F_EN_ILIM, bq->init_data.ilim_en},\r\n{F_TREG, bq->init_data.treg}\r\n};\r\nret = bq25890_chip_reset(bq);\r\nif (ret < 0)\r\nreturn ret;\r\nret = bq25890_field_write(bq, F_WD, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(init_data); i++) {\r\nret = bq25890_field_write(bq, init_data[i].id,\r\ninit_data[i].value);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = bq25890_field_write(bq, F_CONV_RATE, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = bq25890_get_chip_state(bq, &state);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&bq->lock);\r\nbq->state = state;\r\nmutex_unlock(&bq->lock);\r\nreturn 0;\r\n}\r\nstatic int bq25890_power_supply_init(struct bq25890_device *bq)\r\n{\r\nstruct power_supply_config psy_cfg = { .drv_data = bq, };\r\npsy_cfg.supplied_to = bq25890_charger_supplied_to;\r\npsy_cfg.num_supplicants = ARRAY_SIZE(bq25890_charger_supplied_to);\r\nbq->charger = power_supply_register(bq->dev, &bq25890_power_supply_desc,\r\n&psy_cfg);\r\nreturn PTR_ERR_OR_ZERO(bq->charger);\r\n}\r\nstatic void bq25890_usb_work(struct work_struct *data)\r\n{\r\nint ret;\r\nstruct bq25890_device *bq =\r\ncontainer_of(data, struct bq25890_device, usb_work);\r\nswitch (bq->usb_event) {\r\ncase USB_EVENT_ID:\r\nret = bq25890_field_write(bq, F_OTG_CFG, 1);\r\nif (ret < 0)\r\ngoto error;\r\nbreak;\r\ncase USB_EVENT_NONE:\r\nret = bq25890_field_write(bq, F_OTG_CFG, 0);\r\nif (ret < 0)\r\ngoto error;\r\npower_supply_changed(bq->charger);\r\nbreak;\r\n}\r\nreturn;\r\nerror:\r\ndev_err(bq->dev, "Error switching to boost/charger mode.\n");\r\n}\r\nstatic int bq25890_usb_notifier(struct notifier_block *nb, unsigned long val,\r\nvoid *priv)\r\n{\r\nstruct bq25890_device *bq =\r\ncontainer_of(nb, struct bq25890_device, usb_nb);\r\nbq->usb_event = val;\r\nqueue_work(system_power_efficient_wq, &bq->usb_work);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int bq25890_irq_probe(struct bq25890_device *bq)\r\n{\r\nstruct gpio_desc *irq;\r\nirq = devm_gpiod_get(bq->dev, BQ25890_IRQ_PIN, GPIOD_IN);\r\nif (IS_ERR(irq)) {\r\ndev_err(bq->dev, "Could not probe irq pin.\n");\r\nreturn PTR_ERR(irq);\r\n}\r\nreturn gpiod_to_irq(irq);\r\n}\r\nstatic int bq25890_fw_read_u32_props(struct bq25890_device *bq)\r\n{\r\nint ret;\r\nu32 property;\r\nint i;\r\nstruct bq25890_init_data *init = &bq->init_data;\r\nstruct {\r\nchar *name;\r\nbool optional;\r\nenum bq25890_table_ids tbl_id;\r\nu8 *conv_data;\r\n} props[] = {\r\n{"ti,charge-current", false, TBL_ICHG, &init->ichg},\r\n{"ti,battery-regulation-voltage", false, TBL_VREG, &init->vreg},\r\n{"ti,termination-current", false, TBL_ITERM, &init->iterm},\r\n{"ti,precharge-current", false, TBL_ITERM, &init->iprechg},\r\n{"ti,minimum-sys-voltage", false, TBL_SYSVMIN, &init->sysvmin},\r\n{"ti,boost-voltage", false, TBL_BOOSTV, &init->boostv},\r\n{"ti,boost-max-current", false, TBL_BOOSTI, &init->boosti},\r\n{"ti,thermal-regulation-threshold", true, TBL_TREG, &init->treg}\r\n};\r\ninit->treg = 3;\r\nfor (i = 0; i < ARRAY_SIZE(props); i++) {\r\nret = device_property_read_u32(bq->dev, props[i].name,\r\n&property);\r\nif (ret < 0) {\r\nif (props[i].optional)\r\ncontinue;\r\nreturn ret;\r\n}\r\n*props[i].conv_data = bq25890_find_idx(property,\r\nprops[i].tbl_id);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bq25890_fw_probe(struct bq25890_device *bq)\r\n{\r\nint ret;\r\nstruct bq25890_init_data *init = &bq->init_data;\r\nret = bq25890_fw_read_u32_props(bq);\r\nif (ret < 0)\r\nreturn ret;\r\ninit->ilim_en = device_property_read_bool(bq->dev, "ti,use-ilim-pin");\r\ninit->boostf = device_property_read_bool(bq->dev, "ti,boost-low-freq");\r\nreturn 0;\r\n}\r\nstatic int bq25890_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct device *dev = &client->dev;\r\nstruct bq25890_device *bq;\r\nint ret;\r\nint i;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(dev, "No support for SMBUS_BYTE_DATA\n");\r\nreturn -ENODEV;\r\n}\r\nbq = devm_kzalloc(dev, sizeof(*bq), GFP_KERNEL);\r\nif (!bq)\r\nreturn -ENOMEM;\r\nbq->client = client;\r\nbq->dev = dev;\r\nmutex_init(&bq->lock);\r\nbq->rmap = devm_regmap_init_i2c(client, &bq25890_regmap_config);\r\nif (IS_ERR(bq->rmap)) {\r\ndev_err(dev, "failed to allocate register map\n");\r\nreturn PTR_ERR(bq->rmap);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(bq25890_reg_fields); i++) {\r\nconst struct reg_field *reg_fields = bq25890_reg_fields;\r\nbq->rmap_fields[i] = devm_regmap_field_alloc(dev, bq->rmap,\r\nreg_fields[i]);\r\nif (IS_ERR(bq->rmap_fields[i])) {\r\ndev_err(dev, "cannot allocate regmap field\n");\r\nreturn PTR_ERR(bq->rmap_fields[i]);\r\n}\r\n}\r\ni2c_set_clientdata(client, bq);\r\nbq->chip_id = bq25890_field_read(bq, F_PN);\r\nif (bq->chip_id < 0) {\r\ndev_err(dev, "Cannot read chip ID.\n");\r\nreturn bq->chip_id;\r\n}\r\nif (bq->chip_id != BQ25890_ID) {\r\ndev_err(dev, "Chip with ID=%d, not supported!\n", bq->chip_id);\r\nreturn -ENODEV;\r\n}\r\nif (!dev->platform_data) {\r\nret = bq25890_fw_probe(bq);\r\nif (ret < 0) {\r\ndev_err(dev, "Cannot read device properties.\n");\r\nreturn ret;\r\n}\r\n} else {\r\nreturn -ENODEV;\r\n}\r\nret = bq25890_hw_init(bq);\r\nif (ret < 0) {\r\ndev_err(dev, "Cannot initialize the chip.\n");\r\nreturn ret;\r\n}\r\nif (client->irq <= 0)\r\nclient->irq = bq25890_irq_probe(bq);\r\nif (client->irq < 0) {\r\ndev_err(dev, "No irq resource found.\n");\r\nreturn client->irq;\r\n}\r\nbq->usb_phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);\r\nif (!IS_ERR_OR_NULL(bq->usb_phy)) {\r\nINIT_WORK(&bq->usb_work, bq25890_usb_work);\r\nbq->usb_nb.notifier_call = bq25890_usb_notifier;\r\nusb_register_notifier(bq->usb_phy, &bq->usb_nb);\r\n}\r\nret = devm_request_threaded_irq(dev, client->irq, NULL,\r\nbq25890_irq_handler_thread,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\nBQ25890_IRQ_PIN, bq);\r\nif (ret)\r\ngoto irq_fail;\r\nret = bq25890_power_supply_init(bq);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to register power supply\n");\r\ngoto irq_fail;\r\n}\r\nreturn 0;\r\nirq_fail:\r\nif (!IS_ERR_OR_NULL(bq->usb_phy))\r\nusb_unregister_notifier(bq->usb_phy, &bq->usb_nb);\r\nreturn ret;\r\n}\r\nstatic int bq25890_remove(struct i2c_client *client)\r\n{\r\nstruct bq25890_device *bq = i2c_get_clientdata(client);\r\npower_supply_unregister(bq->charger);\r\nif (!IS_ERR_OR_NULL(bq->usb_phy))\r\nusb_unregister_notifier(bq->usb_phy, &bq->usb_nb);\r\nbq25890_chip_reset(bq);\r\nreturn 0;\r\n}\r\nstatic int bq25890_suspend(struct device *dev)\r\n{\r\nstruct bq25890_device *bq = dev_get_drvdata(dev);\r\nreturn bq25890_field_write(bq, F_CONV_START, 0);\r\n}\r\nstatic int bq25890_resume(struct device *dev)\r\n{\r\nint ret;\r\nstruct bq25890_state state;\r\nstruct bq25890_device *bq = dev_get_drvdata(dev);\r\nret = bq25890_get_chip_state(bq, &state);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&bq->lock);\r\nbq->state = state;\r\nmutex_unlock(&bq->lock);\r\nif (state.online) {\r\nret = bq25890_field_write(bq, F_CONV_START, 1);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\npower_supply_changed(bq->charger);\r\nreturn 0;\r\n}
