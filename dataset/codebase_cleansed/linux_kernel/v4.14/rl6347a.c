int rl6347a_hw_write(void *context, unsigned int reg, unsigned int value)\r\n{\r\nstruct i2c_client *client = context;\r\nstruct rl6347a_priv *rl6347a = i2c_get_clientdata(client);\r\nu8 data[4];\r\nint ret, i;\r\nif (reg <= 0xff) {\r\nrl6347a_hw_write(client, RL6347A_COEF_INDEX, reg);\r\nfor (i = 0; i < rl6347a->index_cache_size; i++) {\r\nif (reg == rl6347a->index_cache[i].reg) {\r\nrl6347a->index_cache[i].def = value;\r\nbreak;\r\n}\r\n}\r\nreg = RL6347A_PROC_COEF;\r\n}\r\ndata[0] = (reg >> 24) & 0xff;\r\ndata[1] = (reg >> 16) & 0xff;\r\ndata[2] = ((reg >> 8) & 0xff) | ((value >> 8) & 0xff);\r\ndata[3] = value & 0xff;\r\nret = i2c_master_send(client, data, 4);\r\nif (ret == 4)\r\nreturn 0;\r\nelse\r\ndev_err(&client->dev, "I2C error %d\n", ret);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\nint rl6347a_hw_read(void *context, unsigned int reg, unsigned int *value)\r\n{\r\nstruct i2c_client *client = context;\r\nstruct i2c_msg xfer[2];\r\nint ret;\r\n__be32 be_reg;\r\nunsigned int index, vid, buf = 0x0;\r\nif (reg <= 0xff) {\r\nrl6347a_hw_write(client, RL6347A_COEF_INDEX, reg);\r\nreg = RL6347A_PROC_COEF;\r\n}\r\nreg = reg | 0x80000;\r\nvid = (reg >> 8) & 0xfff;\r\nif (AC_VERB_GET_AMP_GAIN_MUTE == (vid & 0xf00)) {\r\nindex = (reg >> 8) & 0xf;\r\nreg = (reg & ~0xf0f) | index;\r\n}\r\nbe_reg = cpu_to_be32(reg);\r\nxfer[0].addr = client->addr;\r\nxfer[0].flags = 0;\r\nxfer[0].len = 4;\r\nxfer[0].buf = (u8 *)&be_reg;\r\nxfer[1].addr = client->addr;\r\nxfer[1].flags = I2C_M_RD;\r\nxfer[1].len = 4;\r\nxfer[1].buf = (u8 *)&buf;\r\nret = i2c_transfer(client->adapter, xfer, 2);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret != 2)\r\nreturn -EIO;\r\n*value = be32_to_cpu(buf);\r\nreturn 0;\r\n}
