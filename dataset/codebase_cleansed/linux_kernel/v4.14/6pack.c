static void sp_xmit_on_air(unsigned long channel)\r\n{\r\nstruct sixpack *sp = (struct sixpack *) channel;\r\nint actual, when = sp->slottime;\r\nstatic unsigned char random;\r\nrandom = random * 17 + 41;\r\nif (((sp->status1 & SIXP_DCD_MASK) == 0) && (random < sp->persistence)) {\r\nsp->led_state = 0x70;\r\nsp->tty->ops->write(sp->tty, &sp->led_state, 1);\r\nsp->tx_enable = 1;\r\nactual = sp->tty->ops->write(sp->tty, sp->xbuff, sp->status2);\r\nsp->xleft -= actual;\r\nsp->xhead += actual;\r\nsp->led_state = 0x60;\r\nsp->tty->ops->write(sp->tty, &sp->led_state, 1);\r\nsp->status2 = 0;\r\n} else\r\nmod_timer(&sp->tx_t, jiffies + ((when + 1) * HZ) / 100);\r\n}\r\nstatic void sp_encaps(struct sixpack *sp, unsigned char *icp, int len)\r\n{\r\nunsigned char *msg, *p = icp;\r\nint actual, count;\r\nif (len > sp->mtu) {\r\nmsg = "oversized transmit packet!";\r\ngoto out_drop;\r\n}\r\nif (len > sp->mtu) {\r\nmsg = "oversized transmit packet!";\r\ngoto out_drop;\r\n}\r\nif (p[0] > 5) {\r\nmsg = "invalid KISS command";\r\ngoto out_drop;\r\n}\r\nif ((p[0] != 0) && (len > 2)) {\r\nmsg = "KISS control packet too long";\r\ngoto out_drop;\r\n}\r\nif ((p[0] == 0) && (len < 15)) {\r\nmsg = "bad AX.25 packet to transmit";\r\ngoto out_drop;\r\n}\r\ncount = encode_sixpack(p, sp->xbuff, len, sp->tx_delay);\r\nset_bit(TTY_DO_WRITE_WAKEUP, &sp->tty->flags);\r\nswitch (p[0]) {\r\ncase 1: sp->tx_delay = p[1];\r\nreturn;\r\ncase 2: sp->persistence = p[1];\r\nreturn;\r\ncase 3: sp->slottime = p[1];\r\nreturn;\r\ncase 4:\r\nreturn;\r\ncase 5: sp->duplex = p[1];\r\nreturn;\r\n}\r\nif (p[0] != 0)\r\nreturn;\r\nif (sp->duplex == 1) {\r\nsp->led_state = 0x70;\r\nsp->tty->ops->write(sp->tty, &sp->led_state, 1);\r\nsp->tx_enable = 1;\r\nactual = sp->tty->ops->write(sp->tty, sp->xbuff, count);\r\nsp->xleft = count - actual;\r\nsp->xhead = sp->xbuff + actual;\r\nsp->led_state = 0x60;\r\nsp->tty->ops->write(sp->tty, &sp->led_state, 1);\r\n} else {\r\nsp->xleft = count;\r\nsp->xhead = sp->xbuff;\r\nsp->status2 = count;\r\nsp_xmit_on_air((unsigned long)sp);\r\n}\r\nreturn;\r\nout_drop:\r\nsp->dev->stats.tx_dropped++;\r\nnetif_start_queue(sp->dev);\r\nif (net_ratelimit())\r\nprintk(KERN_DEBUG "%s: %s - dropped.\n", sp->dev->name, msg);\r\n}\r\nstatic netdev_tx_t sp_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct sixpack *sp = netdev_priv(dev);\r\nif (skb->protocol == htons(ETH_P_IP))\r\nreturn ax25_ip_xmit(skb);\r\nspin_lock_bh(&sp->lock);\r\nnetif_stop_queue(dev);\r\ndev->stats.tx_bytes += skb->len;\r\nsp_encaps(sp, skb->data, skb->len);\r\nspin_unlock_bh(&sp->lock);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int sp_open_dev(struct net_device *dev)\r\n{\r\nstruct sixpack *sp = netdev_priv(dev);\r\nif (sp->tty == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int sp_close(struct net_device *dev)\r\n{\r\nstruct sixpack *sp = netdev_priv(dev);\r\nspin_lock_bh(&sp->lock);\r\nif (sp->tty) {\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &sp->tty->flags);\r\n}\r\nnetif_stop_queue(dev);\r\nspin_unlock_bh(&sp->lock);\r\nreturn 0;\r\n}\r\nstatic int sp_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr_ax25 *sa = addr;\r\nnetif_tx_lock_bh(dev);\r\nnetif_addr_lock(dev);\r\nmemcpy(dev->dev_addr, &sa->sax25_call, AX25_ADDR_LEN);\r\nnetif_addr_unlock(dev);\r\nnetif_tx_unlock_bh(dev);\r\nreturn 0;\r\n}\r\nstatic void sp_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &sp_netdev_ops;\r\ndev->needs_free_netdev = true;\r\ndev->mtu = SIXP_MTU;\r\ndev->hard_header_len = AX25_MAX_HEADER_LEN;\r\ndev->header_ops = &ax25_header_ops;\r\ndev->addr_len = AX25_ADDR_LEN;\r\ndev->type = ARPHRD_AX25;\r\ndev->tx_queue_len = 10;\r\nmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\r\nmemcpy(dev->dev_addr, &ax25_defaddr, AX25_ADDR_LEN);\r\ndev->flags = 0;\r\n}\r\nstatic void sp_bump(struct sixpack *sp, char cmd)\r\n{\r\nstruct sk_buff *skb;\r\nint count;\r\nunsigned char *ptr;\r\ncount = sp->rcount + 1;\r\nsp->dev->stats.rx_bytes += count;\r\nif ((skb = dev_alloc_skb(count)) == NULL)\r\ngoto out_mem;\r\nptr = skb_put(skb, count);\r\n*ptr++ = cmd;\r\nmemcpy(ptr, sp->cooked_buf + 1, count);\r\nskb->protocol = ax25_type_trans(skb, sp->dev);\r\nnetif_rx(skb);\r\nsp->dev->stats.rx_packets++;\r\nreturn;\r\nout_mem:\r\nsp->dev->stats.rx_dropped++;\r\n}\r\nstatic struct sixpack *sp_get(struct tty_struct *tty)\r\n{\r\nstruct sixpack *sp;\r\nread_lock(&disc_data_lock);\r\nsp = tty->disc_data;\r\nif (sp)\r\natomic_inc(&sp->refcnt);\r\nread_unlock(&disc_data_lock);\r\nreturn sp;\r\n}\r\nstatic void sp_put(struct sixpack *sp)\r\n{\r\nif (atomic_dec_and_test(&sp->refcnt))\r\nup(&sp->dead_sem);\r\n}\r\nstatic void sixpack_write_wakeup(struct tty_struct *tty)\r\n{\r\nstruct sixpack *sp = sp_get(tty);\r\nint actual;\r\nif (!sp)\r\nreturn;\r\nif (sp->xleft <= 0) {\r\nsp->dev->stats.tx_packets++;\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nsp->tx_enable = 0;\r\nnetif_wake_queue(sp->dev);\r\ngoto out;\r\n}\r\nif (sp->tx_enable) {\r\nactual = tty->ops->write(tty, sp->xhead, sp->xleft);\r\nsp->xleft -= actual;\r\nsp->xhead += actual;\r\n}\r\nout:\r\nsp_put(sp);\r\n}\r\nstatic void sixpack_receive_buf(struct tty_struct *tty,\r\nconst unsigned char *cp, char *fp, int count)\r\n{\r\nstruct sixpack *sp;\r\nint count1;\r\nif (!count)\r\nreturn;\r\nsp = sp_get(tty);\r\nif (!sp)\r\nreturn;\r\ncount1 = count;\r\nwhile (count) {\r\ncount--;\r\nif (fp && *fp++) {\r\nif (!test_and_set_bit(SIXPF_ERROR, &sp->flags))\r\nsp->dev->stats.rx_errors++;\r\ncontinue;\r\n}\r\n}\r\nsixpack_decode(sp, cp, count1);\r\nsp_put(sp);\r\ntty_unthrottle(tty);\r\n}\r\nstatic void __tnc_set_sync_state(struct sixpack *sp, int new_tnc_state)\r\n{\r\nchar *msg;\r\nswitch (new_tnc_state) {\r\ndefault:\r\ncase TNC_UNSYNC_STARTUP:\r\nmsg = "Synchronizing with TNC";\r\nbreak;\r\ncase TNC_UNSYNCED:\r\nmsg = "Lost synchronization with TNC\n";\r\nbreak;\r\ncase TNC_IN_SYNC:\r\nmsg = "Found TNC";\r\nbreak;\r\n}\r\nsp->tnc_state = new_tnc_state;\r\nprintk(KERN_INFO "%s: %s\n", sp->dev->name, msg);\r\n}\r\nstatic inline void tnc_set_sync_state(struct sixpack *sp, int new_tnc_state)\r\n{\r\nint old_tnc_state = sp->tnc_state;\r\nif (old_tnc_state != new_tnc_state)\r\n__tnc_set_sync_state(sp, new_tnc_state);\r\n}\r\nstatic void resync_tnc(unsigned long channel)\r\n{\r\nstruct sixpack *sp = (struct sixpack *) channel;\r\nstatic char resync_cmd = 0xe8;\r\nsp->rx_count = 0;\r\nsp->rx_count_cooked = 0;\r\nsp->status = 1;\r\nsp->status1 = 1;\r\nsp->status2 = 0;\r\nsp->led_state = 0x60;\r\nsp->tty->ops->write(sp->tty, &sp->led_state, 1);\r\nsp->tty->ops->write(sp->tty, &resync_cmd, 1);\r\ndel_timer(&sp->resync_t);\r\nsp->resync_t.data = (unsigned long) sp;\r\nsp->resync_t.function = resync_tnc;\r\nsp->resync_t.expires = jiffies + SIXP_RESYNC_TIMEOUT;\r\nadd_timer(&sp->resync_t);\r\n}\r\nstatic inline int tnc_init(struct sixpack *sp)\r\n{\r\nunsigned char inbyte = 0xe8;\r\ntnc_set_sync_state(sp, TNC_UNSYNC_STARTUP);\r\nsp->tty->ops->write(sp->tty, &inbyte, 1);\r\ndel_timer(&sp->resync_t);\r\nsp->resync_t.data = (unsigned long) sp;\r\nsp->resync_t.function = resync_tnc;\r\nsp->resync_t.expires = jiffies + SIXP_RESYNC_TIMEOUT;\r\nadd_timer(&sp->resync_t);\r\nreturn 0;\r\n}\r\nstatic int sixpack_open(struct tty_struct *tty)\r\n{\r\nchar *rbuff = NULL, *xbuff = NULL;\r\nstruct net_device *dev;\r\nstruct sixpack *sp;\r\nunsigned long len;\r\nint err = 0;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (tty->ops->write == NULL)\r\nreturn -EOPNOTSUPP;\r\ndev = alloc_netdev(sizeof(struct sixpack), "sp%d", NET_NAME_UNKNOWN,\r\nsp_setup);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nsp = netdev_priv(dev);\r\nsp->dev = dev;\r\nspin_lock_init(&sp->lock);\r\natomic_set(&sp->refcnt, 1);\r\nsema_init(&sp->dead_sem, 0);\r\nlen = dev->mtu * 2;\r\nrbuff = kmalloc(len + 4, GFP_KERNEL);\r\nxbuff = kmalloc(len + 4, GFP_KERNEL);\r\nif (rbuff == NULL || xbuff == NULL) {\r\nerr = -ENOBUFS;\r\ngoto out_free;\r\n}\r\nspin_lock_bh(&sp->lock);\r\nsp->tty = tty;\r\nsp->rbuff = rbuff;\r\nsp->xbuff = xbuff;\r\nsp->mtu = AX25_MTU + 73;\r\nsp->buffsize = len;\r\nsp->rcount = 0;\r\nsp->rx_count = 0;\r\nsp->rx_count_cooked = 0;\r\nsp->xleft = 0;\r\nsp->flags = 0;\r\nsp->duplex = 0;\r\nsp->tx_delay = SIXP_TXDELAY;\r\nsp->persistence = SIXP_PERSIST;\r\nsp->slottime = SIXP_SLOTTIME;\r\nsp->led_state = 0x60;\r\nsp->status = 1;\r\nsp->status1 = 1;\r\nsp->status2 = 0;\r\nsp->tx_enable = 0;\r\nnetif_start_queue(dev);\r\ninit_timer(&sp->tx_t);\r\nsp->tx_t.function = sp_xmit_on_air;\r\nsp->tx_t.data = (unsigned long) sp;\r\ninit_timer(&sp->resync_t);\r\nspin_unlock_bh(&sp->lock);\r\ntty->disc_data = sp;\r\ntty->receive_room = 65536;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out_free;\r\ntnc_init(sp);\r\nreturn 0;\r\nout_free:\r\nkfree(xbuff);\r\nkfree(rbuff);\r\nfree_netdev(dev);\r\nout:\r\nreturn err;\r\n}\r\nstatic void sixpack_close(struct tty_struct *tty)\r\n{\r\nstruct sixpack *sp;\r\nwrite_lock_bh(&disc_data_lock);\r\nsp = tty->disc_data;\r\ntty->disc_data = NULL;\r\nwrite_unlock_bh(&disc_data_lock);\r\nif (!sp)\r\nreturn;\r\nif (!atomic_dec_and_test(&sp->refcnt))\r\ndown(&sp->dead_sem);\r\nnetif_stop_queue(sp->dev);\r\ndel_timer_sync(&sp->tx_t);\r\ndel_timer_sync(&sp->resync_t);\r\nkfree(sp->rbuff);\r\nkfree(sp->xbuff);\r\nunregister_netdev(sp->dev);\r\n}\r\nstatic int sixpack_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct sixpack *sp = sp_get(tty);\r\nstruct net_device *dev;\r\nunsigned int tmp, err;\r\nif (!sp)\r\nreturn -ENXIO;\r\ndev = sp->dev;\r\nswitch(cmd) {\r\ncase SIOCGIFNAME:\r\nerr = copy_to_user((void __user *) arg, dev->name,\r\nstrlen(dev->name) + 1) ? -EFAULT : 0;\r\nbreak;\r\ncase SIOCGIFENCAP:\r\nerr = put_user(0, (int __user *) arg);\r\nbreak;\r\ncase SIOCSIFENCAP:\r\nif (get_user(tmp, (int __user *) arg)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nsp->mode = tmp;\r\ndev->addr_len = AX25_ADDR_LEN;\r\ndev->hard_header_len = AX25_KISS_HEADER_LEN +\r\nAX25_MAX_HEADER_LEN + 3;\r\ndev->type = ARPHRD_AX25;\r\nerr = 0;\r\nbreak;\r\ncase SIOCSIFHWADDR: {\r\nchar addr[AX25_ADDR_LEN];\r\nif (copy_from_user(&addr,\r\n(void __user *) arg, AX25_ADDR_LEN)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nnetif_tx_lock_bh(dev);\r\nmemcpy(dev->dev_addr, &addr, AX25_ADDR_LEN);\r\nnetif_tx_unlock_bh(dev);\r\nerr = 0;\r\nbreak;\r\n}\r\ndefault:\r\nerr = tty_mode_ioctl(tty, file, cmd, arg);\r\n}\r\nsp_put(sp);\r\nreturn err;\r\n}\r\nstatic long sixpack_compat_ioctl(struct tty_struct * tty, struct file * file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase SIOCGIFNAME:\r\ncase SIOCGIFENCAP:\r\ncase SIOCSIFENCAP:\r\ncase SIOCSIFHWADDR:\r\nreturn sixpack_ioctl(tty, file, cmd,\r\n(unsigned long)compat_ptr(arg));\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int __init sixpack_init_driver(void)\r\n{\r\nint status;\r\nprintk(msg_banner);\r\nif ((status = tty_register_ldisc(N_6PACK, &sp_ldisc)) != 0)\r\nprintk(msg_regfail, status);\r\nreturn status;\r\n}\r\nstatic void __exit sixpack_exit_driver(void)\r\n{\r\nint ret;\r\nif ((ret = tty_unregister_ldisc(N_6PACK)))\r\nprintk(msg_unregfail, ret);\r\n}\r\nstatic int encode_sixpack(unsigned char *tx_buf, unsigned char *tx_buf_raw,\r\nint length, unsigned char tx_delay)\r\n{\r\nint count = 0;\r\nunsigned char checksum = 0, buf[400];\r\nint raw_count = 0;\r\ntx_buf_raw[raw_count++] = SIXP_PRIO_CMD_MASK | SIXP_TX_MASK;\r\ntx_buf_raw[raw_count++] = SIXP_SEOF;\r\nbuf[0] = tx_delay;\r\nfor (count = 1; count < length; count++)\r\nbuf[count] = tx_buf[count];\r\nfor (count = 0; count < length; count++)\r\nchecksum += buf[count];\r\nbuf[length] = (unsigned char) 0xff - checksum;\r\nfor (count = 0; count <= length; count++) {\r\nif ((count % 3) == 0) {\r\ntx_buf_raw[raw_count++] = (buf[count] & 0x3f);\r\ntx_buf_raw[raw_count] = ((buf[count] >> 2) & 0x30);\r\n} else if ((count % 3) == 1) {\r\ntx_buf_raw[raw_count++] |= (buf[count] & 0x0f);\r\ntx_buf_raw[raw_count] = ((buf[count] >> 2) & 0x3c);\r\n} else {\r\ntx_buf_raw[raw_count++] |= (buf[count] & 0x03);\r\ntx_buf_raw[raw_count++] = (buf[count] >> 2);\r\n}\r\n}\r\nif ((length % 3) != 2)\r\nraw_count++;\r\ntx_buf_raw[raw_count++] = SIXP_SEOF;\r\nreturn raw_count;\r\n}\r\nstatic void decode_data(struct sixpack *sp, unsigned char inbyte)\r\n{\r\nunsigned char *buf;\r\nif (sp->rx_count != 3) {\r\nsp->raw_buf[sp->rx_count++] = inbyte;\r\nreturn;\r\n}\r\nbuf = sp->raw_buf;\r\nsp->cooked_buf[sp->rx_count_cooked++] =\r\nbuf[0] | ((buf[1] << 2) & 0xc0);\r\nsp->cooked_buf[sp->rx_count_cooked++] =\r\n(buf[1] & 0x0f) | ((buf[2] << 2) & 0xf0);\r\nsp->cooked_buf[sp->rx_count_cooked++] =\r\n(buf[2] & 0x03) | (inbyte << 2);\r\nsp->rx_count = 0;\r\n}\r\nstatic void decode_prio_command(struct sixpack *sp, unsigned char cmd)\r\n{\r\nunsigned char channel;\r\nint actual;\r\nchannel = cmd & SIXP_CHN_MASK;\r\nif ((cmd & SIXP_PRIO_DATA_MASK) != 0) {\r\nif (((sp->status & SIXP_DCD_MASK) == 0) &&\r\n((cmd & SIXP_RX_DCD_MASK) == SIXP_RX_DCD_MASK)) {\r\nif (sp->status != 1)\r\nprintk(KERN_DEBUG "6pack: protocol violation\n");\r\nelse\r\nsp->status = 0;\r\ncmd &= ~SIXP_RX_DCD_MASK;\r\n}\r\nsp->status = cmd & SIXP_PRIO_DATA_MASK;\r\n} else {\r\nif ((sp->status2 != 0) && (sp->duplex == 1)) {\r\nsp->led_state = 0x70;\r\nsp->tty->ops->write(sp->tty, &sp->led_state, 1);\r\nsp->tx_enable = 1;\r\nactual = sp->tty->ops->write(sp->tty, sp->xbuff, sp->status2);\r\nsp->xleft -= actual;\r\nsp->xhead += actual;\r\nsp->led_state = 0x60;\r\nsp->status2 = 0;\r\n}\r\n}\r\nsp->tty->ops->write(sp->tty, &sp->led_state, 1);\r\nif (sp->tnc_state == TNC_IN_SYNC) {\r\ndel_timer(&sp->resync_t);\r\nsp->resync_t.data = (unsigned long) sp;\r\nsp->resync_t.function = resync_tnc;\r\nsp->resync_t.expires = jiffies + SIXP_INIT_RESYNC_TIMEOUT;\r\nadd_timer(&sp->resync_t);\r\n}\r\nsp->status1 = cmd & SIXP_PRIO_DATA_MASK;\r\n}\r\nstatic void decode_std_command(struct sixpack *sp, unsigned char cmd)\r\n{\r\nunsigned char checksum = 0, rest = 0, channel;\r\nshort i;\r\nchannel = cmd & SIXP_CHN_MASK;\r\nswitch (cmd & SIXP_CMD_MASK) {\r\ncase SIXP_SEOF:\r\nif ((sp->rx_count == 0) && (sp->rx_count_cooked == 0)) {\r\nif ((sp->status & SIXP_RX_DCD_MASK) ==\r\nSIXP_RX_DCD_MASK) {\r\nsp->led_state = 0x68;\r\nsp->tty->ops->write(sp->tty, &sp->led_state, 1);\r\n}\r\n} else {\r\nsp->led_state = 0x60;\r\nsp->tty->ops->write(sp->tty, &sp->led_state, 1);\r\nrest = sp->rx_count;\r\nif (rest != 0)\r\nfor (i = rest; i <= 3; i++)\r\ndecode_data(sp, 0);\r\nif (rest == 2)\r\nsp->rx_count_cooked -= 2;\r\nelse if (rest == 3)\r\nsp->rx_count_cooked -= 1;\r\nfor (i = 0; i < sp->rx_count_cooked; i++)\r\nchecksum += sp->cooked_buf[i];\r\nif (checksum != SIXP_CHKSUM) {\r\nprintk(KERN_DEBUG "6pack: bad checksum %2.2x\n", checksum);\r\n} else {\r\nsp->rcount = sp->rx_count_cooked-2;\r\nsp_bump(sp, 0);\r\n}\r\nsp->rx_count_cooked = 0;\r\n}\r\nbreak;\r\ncase SIXP_TX_URUN: printk(KERN_DEBUG "6pack: TX underrun\n");\r\nbreak;\r\ncase SIXP_RX_ORUN: printk(KERN_DEBUG "6pack: RX overrun\n");\r\nbreak;\r\ncase SIXP_RX_BUF_OVL:\r\nprintk(KERN_DEBUG "6pack: RX buffer overflow\n");\r\n}\r\n}\r\nstatic void\r\nsixpack_decode(struct sixpack *sp, const unsigned char *pre_rbuff, int count)\r\n{\r\nunsigned char inbyte;\r\nint count1;\r\nfor (count1 = 0; count1 < count; count1++) {\r\ninbyte = pre_rbuff[count1];\r\nif (inbyte == SIXP_FOUND_TNC) {\r\ntnc_set_sync_state(sp, TNC_IN_SYNC);\r\ndel_timer(&sp->resync_t);\r\n}\r\nif ((inbyte & SIXP_PRIO_CMD_MASK) != 0)\r\ndecode_prio_command(sp, inbyte);\r\nelse if ((inbyte & SIXP_STD_CMD_MASK) != 0)\r\ndecode_std_command(sp, inbyte);\r\nelse if ((sp->status & SIXP_RX_DCD_MASK) == SIXP_RX_DCD_MASK)\r\ndecode_data(sp, inbyte);\r\n}\r\n}
