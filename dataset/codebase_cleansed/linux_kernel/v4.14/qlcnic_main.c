static u32 qlcnic_vlan_tx_check(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nif (adapter->pdev->device == PCI_DEVICE_ID_QLOGIC_QLE824X)\r\nreturn ahw->capabilities & QLCNIC_FW_CAPABILITY_FVLANTX;\r\nelse\r\nreturn 1;\r\n}\r\ninline void qlcnic_update_cmd_producer(struct qlcnic_host_tx_ring *tx_ring)\r\n{\r\nwritel(tx_ring->producer, tx_ring->crb_cmd_producer);\r\n}\r\nint qlcnic_alloc_sds_rings(struct qlcnic_recv_context *recv_ctx, int count)\r\n{\r\nint size = sizeof(struct qlcnic_host_sds_ring) * count;\r\nrecv_ctx->sds_rings = kzalloc(size, GFP_KERNEL);\r\nreturn recv_ctx->sds_rings == NULL;\r\n}\r\nvoid qlcnic_free_sds_rings(struct qlcnic_recv_context *recv_ctx)\r\n{\r\nkfree(recv_ctx->sds_rings);\r\nrecv_ctx->sds_rings = NULL;\r\n}\r\nint qlcnic_read_mac_addr(struct qlcnic_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nu8 mac_addr[ETH_ALEN];\r\nint ret;\r\nret = qlcnic_get_mac_address(adapter, mac_addr,\r\nadapter->ahw->pci_func);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(netdev->dev_addr, mac_addr, ETH_ALEN);\r\nmemcpy(adapter->mac_addr, netdev->dev_addr, netdev->addr_len);\r\nif (!is_valid_ether_addr(netdev->dev_addr))\r\ndev_warn(&pdev->dev, "Bad MAC address %pM.\n",\r\nnetdev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic void qlcnic_delete_adapter_mac(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_mac_vlan_list *cur;\r\nstruct list_head *head;\r\nlist_for_each(head, &adapter->mac_list) {\r\ncur = list_entry(head, struct qlcnic_mac_vlan_list, list);\r\nif (ether_addr_equal_unaligned(adapter->mac_addr, cur->mac_addr)) {\r\nqlcnic_sre_macaddr_change(adapter, cur->mac_addr,\r\n0, QLCNIC_MAC_DEL);\r\nlist_del(&cur->list);\r\nkfree(cur);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int qlcnic_set_mac(struct net_device *netdev, void *p)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct sockaddr *addr = p;\r\nif (qlcnic_sriov_vf_check(adapter))\r\nreturn -EINVAL;\r\nif ((adapter->flags & QLCNIC_MAC_OVERRIDE_DISABLED))\r\nreturn -EOPNOTSUPP;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EINVAL;\r\nif (ether_addr_equal_unaligned(adapter->mac_addr, addr->sa_data) &&\r\nether_addr_equal_unaligned(netdev->dev_addr, addr->sa_data))\r\nreturn 0;\r\nif (test_bit(__QLCNIC_DEV_UP, &adapter->state)) {\r\nnetif_device_detach(netdev);\r\nqlcnic_napi_disable(adapter);\r\n}\r\nqlcnic_delete_adapter_mac(adapter);\r\nmemcpy(adapter->mac_addr, addr->sa_data, netdev->addr_len);\r\nmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\r\nqlcnic_set_multi(adapter->netdev);\r\nif (test_bit(__QLCNIC_DEV_UP, &adapter->state)) {\r\nnetif_device_attach(netdev);\r\nqlcnic_napi_enable(adapter);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_fdb_del(struct ndmsg *ndm, struct nlattr *tb[],\r\nstruct net_device *netdev,\r\nconst unsigned char *addr, u16 vid)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint err = -EOPNOTSUPP;\r\nif (!adapter->fdb_mac_learn)\r\nreturn ndo_dflt_fdb_del(ndm, tb, netdev, addr, vid);\r\nif ((adapter->flags & QLCNIC_ESWITCH_ENABLED) ||\r\nqlcnic_sriov_check(adapter)) {\r\nif (is_unicast_ether_addr(addr)) {\r\nerr = dev_uc_del(netdev, addr);\r\nif (!err)\r\nerr = qlcnic_nic_del_mac(adapter, addr);\r\n} else if (is_multicast_ether_addr(addr)) {\r\nerr = dev_mc_del(netdev, addr);\r\n} else {\r\nerr = -EINVAL;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int qlcnic_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],\r\nstruct net_device *netdev,\r\nconst unsigned char *addr, u16 vid, u16 flags)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint err = 0;\r\nif (!adapter->fdb_mac_learn)\r\nreturn ndo_dflt_fdb_add(ndm, tb, netdev, addr, vid, flags);\r\nif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED) &&\r\n!qlcnic_sriov_check(adapter)) {\r\npr_info("%s: FDB e-switch is not enabled\n", __func__);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (ether_addr_equal(addr, adapter->mac_addr))\r\nreturn err;\r\nif (is_unicast_ether_addr(addr)) {\r\nif (netdev_uc_count(netdev) < adapter->ahw->max_uc_count)\r\nerr = dev_uc_add_excl(netdev, addr);\r\nelse\r\nerr = -ENOMEM;\r\n} else if (is_multicast_ether_addr(addr)) {\r\nerr = dev_mc_add_excl(netdev, addr);\r\n} else {\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int qlcnic_fdb_dump(struct sk_buff *skb, struct netlink_callback *ncb,\r\nstruct net_device *netdev,\r\nstruct net_device *filter_dev, int *idx)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint err = 0;\r\nif (!adapter->fdb_mac_learn)\r\nreturn ndo_dflt_fdb_dump(skb, ncb, netdev, filter_dev, idx);\r\nif ((adapter->flags & QLCNIC_ESWITCH_ENABLED) ||\r\nqlcnic_sriov_check(adapter))\r\nerr = ndo_dflt_fdb_dump(skb, ncb, netdev, filter_dev, idx);\r\nreturn err;\r\n}\r\nstatic void qlcnic_82xx_cancel_idc_work(struct qlcnic_adapter *adapter)\r\n{\r\nwhile (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\r\nusleep_range(10000, 11000);\r\nif (!adapter->fw_work.work.func)\r\nreturn;\r\ncancel_delayed_work_sync(&adapter->fw_work);\r\n}\r\nstatic int qlcnic_get_phys_port_id(struct net_device *netdev,\r\nstruct netdev_phys_item_id *ppid)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nif (!(adapter->flags & QLCNIC_HAS_PHYS_PORT_ID))\r\nreturn -EOPNOTSUPP;\r\nppid->id_len = sizeof(ahw->phys_port_id);\r\nmemcpy(ppid->id, ahw->phys_port_id, ppid->id_len);\r\nreturn 0;\r\n}\r\nstatic void qlcnic_add_vxlan_port(struct net_device *netdev,\r\nstruct udp_tunnel_info *ti)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nif (ti->type != UDP_TUNNEL_TYPE_VXLAN)\r\nreturn;\r\nif (!qlcnic_encap_rx_offload(adapter))\r\nreturn;\r\nif (!ahw->vxlan_port_count) {\r\nahw->vxlan_port_count = 1;\r\nahw->vxlan_port = ntohs(ti->port);\r\nadapter->flags |= QLCNIC_ADD_VXLAN_PORT;\r\nreturn;\r\n}\r\nif (ahw->vxlan_port == ntohs(ti->port))\r\nahw->vxlan_port_count++;\r\n}\r\nstatic void qlcnic_del_vxlan_port(struct net_device *netdev,\r\nstruct udp_tunnel_info *ti)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nif (ti->type != UDP_TUNNEL_TYPE_VXLAN)\r\nreturn;\r\nif (!qlcnic_encap_rx_offload(adapter) || !ahw->vxlan_port_count ||\r\n(ahw->vxlan_port != ntohs(ti->port)))\r\nreturn;\r\nahw->vxlan_port_count--;\r\nif (!ahw->vxlan_port_count)\r\nadapter->flags |= QLCNIC_DEL_VXLAN_PORT;\r\n}\r\nstatic netdev_features_t qlcnic_features_check(struct sk_buff *skb,\r\nstruct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nfeatures = vlan_features_check(skb, features);\r\nreturn vxlan_features_check(skb, features);\r\n}\r\nstatic int qlcnic_check_multi_tx_capability(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nif (qlcnic_82xx_check(adapter) &&\r\n(ahw->extra_capability[0] & QLCNIC_FW_CAPABILITY_2_MULTI_TX)) {\r\ntest_and_set_bit(__QLCNIC_MULTI_TX_UNIQUE, &adapter->state);\r\nreturn 0;\r\n} else {\r\nreturn 1;\r\n}\r\n}\r\nstatic int qlcnic_max_rings(struct qlcnic_adapter *adapter, u8 ring_cnt,\r\nint queue_type)\r\n{\r\nint num_rings, max_rings = QLCNIC_MAX_SDS_RINGS;\r\nif (queue_type == QLCNIC_RX_QUEUE)\r\nmax_rings = adapter->max_sds_rings;\r\nelse if (queue_type == QLCNIC_TX_QUEUE)\r\nmax_rings = adapter->max_tx_rings;\r\nnum_rings = rounddown_pow_of_two(min_t(int, num_online_cpus(),\r\nmax_rings));\r\nif (ring_cnt > num_rings)\r\nreturn num_rings;\r\nelse\r\nreturn ring_cnt;\r\n}\r\nvoid qlcnic_set_tx_ring_count(struct qlcnic_adapter *adapter, u8 tx_cnt)\r\n{\r\nif (adapter->max_tx_rings)\r\nadapter->drv_tx_rings = qlcnic_max_rings(adapter, tx_cnt,\r\nQLCNIC_TX_QUEUE);\r\nelse\r\nadapter->drv_tx_rings = tx_cnt;\r\n}\r\nvoid qlcnic_set_sds_ring_count(struct qlcnic_adapter *adapter, u8 rx_cnt)\r\n{\r\nif (adapter->max_sds_rings)\r\nadapter->drv_sds_rings = qlcnic_max_rings(adapter, rx_cnt,\r\nQLCNIC_RX_QUEUE);\r\nelse\r\nadapter->drv_sds_rings = rx_cnt;\r\n}\r\nint qlcnic_setup_tss_rss_intr(struct qlcnic_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint num_msix = 0, err = 0, vector;\r\nadapter->flags &= ~QLCNIC_TSS_RSS;\r\nif (adapter->drv_tss_rings > 0)\r\nnum_msix += adapter->drv_tss_rings;\r\nelse\r\nnum_msix += adapter->drv_tx_rings;\r\nif (adapter->drv_rss_rings > 0)\r\nnum_msix += adapter->drv_rss_rings;\r\nelse\r\nnum_msix += adapter->drv_sds_rings;\r\nif (qlcnic_83xx_check(adapter))\r\nnum_msix += 1;\r\nif (!adapter->msix_entries) {\r\nadapter->msix_entries = kcalloc(num_msix,\r\nsizeof(struct msix_entry),\r\nGFP_KERNEL);\r\nif (!adapter->msix_entries)\r\nreturn -ENOMEM;\r\n}\r\nfor (vector = 0; vector < num_msix; vector++)\r\nadapter->msix_entries[vector].entry = vector;\r\nrestore:\r\nerr = pci_enable_msix_exact(pdev, adapter->msix_entries, num_msix);\r\nif (err == -ENOSPC) {\r\nif (!adapter->drv_tss_rings && !adapter->drv_rss_rings)\r\nreturn err;\r\nnetdev_info(adapter->netdev,\r\n"Unable to allocate %d MSI-X vectors, Available vectors %d\n",\r\nnum_msix, err);\r\nnum_msix = adapter->drv_tx_rings + adapter->drv_sds_rings;\r\nadapter->drv_tss_rings = 0;\r\nadapter->drv_rss_rings = 0;\r\nif (qlcnic_83xx_check(adapter))\r\nnum_msix += 1;\r\nnetdev_info(adapter->netdev,\r\n"Restoring %d Tx, %d SDS rings for total %d vectors.\n",\r\nadapter->drv_tx_rings, adapter->drv_sds_rings,\r\nnum_msix);\r\ngoto restore;\r\n} else if (err < 0) {\r\nreturn err;\r\n}\r\nadapter->ahw->num_msix = num_msix;\r\nif (adapter->drv_tss_rings > 0)\r\nadapter->drv_tx_rings = adapter->drv_tss_rings;\r\nif (adapter->drv_rss_rings > 0)\r\nadapter->drv_sds_rings = adapter->drv_rss_rings;\r\nreturn 0;\r\n}\r\nint qlcnic_enable_msix(struct qlcnic_adapter *adapter, u32 num_msix)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint err, vector;\r\nif (!adapter->msix_entries) {\r\nadapter->msix_entries = kcalloc(num_msix,\r\nsizeof(struct msix_entry),\r\nGFP_KERNEL);\r\nif (!adapter->msix_entries)\r\nreturn -ENOMEM;\r\n}\r\nadapter->flags &= ~(QLCNIC_MSI_ENABLED | QLCNIC_MSIX_ENABLED);\r\nif (adapter->ahw->msix_supported) {\r\nenable_msix:\r\nfor (vector = 0; vector < num_msix; vector++)\r\nadapter->msix_entries[vector].entry = vector;\r\nerr = pci_enable_msix_range(pdev,\r\nadapter->msix_entries, 1, num_msix);\r\nif (err == num_msix) {\r\nadapter->flags |= QLCNIC_MSIX_ENABLED;\r\nadapter->ahw->num_msix = num_msix;\r\ndev_info(&pdev->dev, "using msi-x interrupts\n");\r\nreturn 0;\r\n} else if (err > 0) {\r\npci_disable_msix(pdev);\r\ndev_info(&pdev->dev,\r\n"Unable to allocate %d MSI-X vectors, Available vectors %d\n",\r\nnum_msix, err);\r\nif (qlcnic_82xx_check(adapter)) {\r\nnum_msix = rounddown_pow_of_two(err);\r\nif (err < QLCNIC_82XX_MINIMUM_VECTOR)\r\nreturn -ENOSPC;\r\n} else {\r\nnum_msix = rounddown_pow_of_two(err - 1);\r\nnum_msix += 1;\r\nif (err < QLCNIC_83XX_MINIMUM_VECTOR)\r\nreturn -ENOSPC;\r\n}\r\nif (qlcnic_82xx_check(adapter) &&\r\n!qlcnic_check_multi_tx(adapter)) {\r\nadapter->drv_sds_rings = num_msix;\r\nadapter->drv_tx_rings = QLCNIC_SINGLE_RING;\r\n} else {\r\nadapter->drv_tx_rings = num_msix / 2;\r\nadapter->drv_sds_rings = adapter->drv_tx_rings;\r\n}\r\nif (num_msix) {\r\ndev_info(&pdev->dev,\r\n"Trying to allocate %d MSI-X interrupt vectors\n",\r\nnum_msix);\r\ngoto enable_msix;\r\n}\r\n} else {\r\ndev_info(&pdev->dev,\r\n"Unable to allocate %d MSI-X vectors, err=%d\n",\r\nnum_msix, err);\r\nreturn err;\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int qlcnic_82xx_calculate_msix_vector(struct qlcnic_adapter *adapter)\r\n{\r\nint num_msix;\r\nnum_msix = adapter->drv_sds_rings;\r\nif (qlcnic_check_multi_tx(adapter))\r\nnum_msix += adapter->drv_tx_rings;\r\nelse\r\nnum_msix += QLCNIC_SINGLE_RING;\r\nreturn num_msix;\r\n}\r\nstatic int qlcnic_enable_msi_legacy(struct qlcnic_adapter *adapter)\r\n{\r\nint err = 0;\r\nu32 offset, mask_reg;\r\nconst struct qlcnic_legacy_intr_set *legacy_intrp;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nif (qlcnic_use_msi && !pci_enable_msi(pdev)) {\r\nadapter->flags |= QLCNIC_MSI_ENABLED;\r\noffset = msi_tgt_status[adapter->ahw->pci_func];\r\nadapter->tgt_status_reg = qlcnic_get_ioaddr(adapter->ahw,\r\noffset);\r\ndev_info(&pdev->dev, "using msi interrupts\n");\r\nadapter->msix_entries[0].vector = pdev->irq;\r\nreturn err;\r\n}\r\nif (qlcnic_use_msi || qlcnic_use_msi_x)\r\nreturn -EOPNOTSUPP;\r\nlegacy_intrp = &legacy_intr[adapter->ahw->pci_func];\r\nadapter->ahw->int_vec_bit = legacy_intrp->int_vec_bit;\r\noffset = legacy_intrp->tgt_status_reg;\r\nadapter->tgt_status_reg = qlcnic_get_ioaddr(ahw, offset);\r\nmask_reg = legacy_intrp->tgt_mask_reg;\r\nadapter->tgt_mask_reg = qlcnic_get_ioaddr(ahw, mask_reg);\r\nadapter->isr_int_vec = qlcnic_get_ioaddr(ahw, ISR_INT_VECTOR);\r\nadapter->crb_int_state_reg = qlcnic_get_ioaddr(ahw, ISR_INT_STATE_REG);\r\ndev_info(&pdev->dev, "using legacy interrupts\n");\r\nadapter->msix_entries[0].vector = pdev->irq;\r\nreturn err;\r\n}\r\nstatic int qlcnic_82xx_setup_intr(struct qlcnic_adapter *adapter)\r\n{\r\nint num_msix, err = 0;\r\nif (adapter->flags & QLCNIC_TSS_RSS) {\r\nerr = qlcnic_setup_tss_rss_intr(adapter);\r\nif (err < 0)\r\nreturn err;\r\nnum_msix = adapter->ahw->num_msix;\r\n} else {\r\nnum_msix = qlcnic_82xx_calculate_msix_vector(adapter);\r\nerr = qlcnic_enable_msix(adapter, num_msix);\r\nif (err == -ENOMEM)\r\nreturn err;\r\nif (!(adapter->flags & QLCNIC_MSIX_ENABLED)) {\r\nqlcnic_disable_multi_tx(adapter);\r\nadapter->drv_sds_rings = QLCNIC_SINGLE_RING;\r\nerr = qlcnic_enable_msi_legacy(adapter);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint qlcnic_82xx_mq_intrpt(struct qlcnic_adapter *adapter, int op_type)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint err, i;\r\nif (qlcnic_check_multi_tx(adapter) &&\r\n!ahw->diag_test &&\r\n(adapter->flags & QLCNIC_MSIX_ENABLED)) {\r\nahw->intr_tbl = vzalloc(ahw->num_msix *\r\nsizeof(struct qlcnic_intrpt_config));\r\nif (!ahw->intr_tbl)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ahw->num_msix; i++) {\r\nahw->intr_tbl[i].type = QLCNIC_INTRPT_MSIX;\r\nahw->intr_tbl[i].id = i;\r\nahw->intr_tbl[i].src = 0;\r\n}\r\nerr = qlcnic_82xx_config_intrpt(adapter, 1);\r\nif (err)\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to configure Interrupt for %d vector\n",\r\nahw->num_msix);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nvoid qlcnic_teardown_intr(struct qlcnic_adapter *adapter)\r\n{\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED)\r\npci_disable_msix(adapter->pdev);\r\nif (adapter->flags & QLCNIC_MSI_ENABLED)\r\npci_disable_msi(adapter->pdev);\r\nkfree(adapter->msix_entries);\r\nadapter->msix_entries = NULL;\r\nif (adapter->ahw->intr_tbl) {\r\nvfree(adapter->ahw->intr_tbl);\r\nadapter->ahw->intr_tbl = NULL;\r\n}\r\n}\r\nstatic void qlcnic_cleanup_pci_map(struct qlcnic_hardware_context *ahw)\r\n{\r\nif (ahw->pci_base0 != NULL)\r\niounmap(ahw->pci_base0);\r\n}\r\nstatic int qlcnic_get_act_pci_func(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_pci_info *pci_info;\r\nint ret;\r\nif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED)) {\r\nswitch (ahw->port_type) {\r\ncase QLCNIC_GBE:\r\nahw->total_nic_func = QLCNIC_NIU_MAX_GBE_PORTS;\r\nbreak;\r\ncase QLCNIC_XGBE:\r\nahw->total_nic_func = QLCNIC_NIU_MAX_XG_PORTS;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nif (ahw->op_mode == QLCNIC_MGMT_FUNC)\r\nreturn 0;\r\npci_info = kcalloc(ahw->max_vnic_func, sizeof(*pci_info), GFP_KERNEL);\r\nif (!pci_info)\r\nreturn -ENOMEM;\r\nret = qlcnic_get_pci_info(adapter, pci_info);\r\nkfree(pci_info);\r\nreturn ret;\r\n}\r\nstatic bool qlcnic_port_eswitch_cfg_capability(struct qlcnic_adapter *adapter)\r\n{\r\nbool ret = false;\r\nif (qlcnic_84xx_check(adapter)) {\r\nret = true;\r\n} else if (qlcnic_83xx_check(adapter)) {\r\nif (adapter->ahw->extra_capability[0] &\r\nQLCNIC_FW_CAPABILITY_2_PER_PORT_ESWITCH_CFG)\r\nret = true;\r\nelse\r\nret = false;\r\n}\r\nreturn ret;\r\n}\r\nint qlcnic_init_pci_info(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_pci_info *pci_info;\r\nint i, id = 0, ret = 0, j = 0;\r\nu16 act_pci_func;\r\nu8 pfn;\r\npci_info = kcalloc(ahw->max_vnic_func, sizeof(*pci_info), GFP_KERNEL);\r\nif (!pci_info)\r\nreturn -ENOMEM;\r\nret = qlcnic_get_pci_info(adapter, pci_info);\r\nif (ret)\r\ngoto err_pci_info;\r\nact_pci_func = ahw->total_nic_func;\r\nadapter->npars = kzalloc(sizeof(struct qlcnic_npar_info) *\r\nact_pci_func, GFP_KERNEL);\r\nif (!adapter->npars) {\r\nret = -ENOMEM;\r\ngoto err_pci_info;\r\n}\r\nadapter->eswitch = kzalloc(sizeof(struct qlcnic_eswitch) *\r\nQLCNIC_NIU_MAX_XG_PORTS, GFP_KERNEL);\r\nif (!adapter->eswitch) {\r\nret = -ENOMEM;\r\ngoto err_npars;\r\n}\r\nfor (i = 0; i < ahw->max_vnic_func; i++) {\r\npfn = pci_info[i].id;\r\nif (pfn >= ahw->max_vnic_func) {\r\nret = -EINVAL;\r\ndev_err(&adapter->pdev->dev, "%s: Invalid function 0x%x, max 0x%x\n",\r\n__func__, pfn, ahw->max_vnic_func);\r\ngoto err_eswitch;\r\n}\r\nif (!pci_info[i].active ||\r\n(pci_info[i].type != QLCNIC_TYPE_NIC))\r\ncontinue;\r\nif (qlcnic_port_eswitch_cfg_capability(adapter)) {\r\nif (!qlcnic_83xx_set_port_eswitch_status(adapter, pfn,\r\n&id))\r\nadapter->npars[j].eswitch_status = true;\r\nelse\r\ncontinue;\r\n} else {\r\nadapter->npars[j].eswitch_status = true;\r\n}\r\nadapter->npars[j].pci_func = pfn;\r\nadapter->npars[j].active = (u8)pci_info[i].active;\r\nadapter->npars[j].type = (u8)pci_info[i].type;\r\nadapter->npars[j].phy_port = (u8)pci_info[i].default_port;\r\nadapter->npars[j].min_bw = pci_info[i].tx_min_bw;\r\nadapter->npars[j].max_bw = pci_info[i].tx_max_bw;\r\nmemcpy(&adapter->npars[j].mac, &pci_info[i].mac, ETH_ALEN);\r\nj++;\r\n}\r\nif (!qlcnic_port_eswitch_cfg_capability(adapter)) {\r\nfor (i = 0; i < QLCNIC_NIU_MAX_XG_PORTS; i++)\r\nadapter->eswitch[i].flags |= QLCNIC_SWITCH_ENABLE;\r\n}\r\nkfree(pci_info);\r\nreturn 0;\r\nerr_eswitch:\r\nkfree(adapter->eswitch);\r\nadapter->eswitch = NULL;\r\nerr_npars:\r\nkfree(adapter->npars);\r\nadapter->npars = NULL;\r\nerr_pci_info:\r\nkfree(pci_info);\r\nreturn ret;\r\n}\r\nstatic int\r\nqlcnic_set_function_modes(struct qlcnic_adapter *adapter)\r\n{\r\nu8 id;\r\nint ret;\r\nu32 data = QLCNIC_MGMT_FUNC;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nret = qlcnic_api_lock(adapter);\r\nif (ret)\r\ngoto err_lock;\r\nid = ahw->pci_func;\r\ndata = QLC_SHARED_REG_RD32(adapter, QLCNIC_DRV_OP_MODE);\r\ndata = (data & ~QLC_DEV_SET_DRV(0xf, id)) |\r\nQLC_DEV_SET_DRV(QLCNIC_MGMT_FUNC, id);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_DRV_OP_MODE, data);\r\nqlcnic_api_unlock(adapter);\r\nerr_lock:\r\nreturn ret;\r\n}\r\nstatic void qlcnic_check_vf(struct qlcnic_adapter *adapter,\r\nconst struct pci_device_id *ent)\r\n{\r\nu32 op_mode, priv_level;\r\nadapter->ahw->fw_hal_version = QLC_SHARED_REG_RD32(adapter,\r\nQLCNIC_FW_API);\r\nqlcnic_get_func_no(adapter);\r\nop_mode = QLC_SHARED_REG_RD32(adapter, QLCNIC_DRV_OP_MODE);\r\nif (op_mode == QLC_DEV_DRV_DEFAULT)\r\npriv_level = QLCNIC_MGMT_FUNC;\r\nelse\r\npriv_level = QLC_DEV_GET_DRV(op_mode, adapter->ahw->pci_func);\r\nif (priv_level == QLCNIC_NON_PRIV_FUNC) {\r\nadapter->ahw->op_mode = QLCNIC_NON_PRIV_FUNC;\r\ndev_info(&adapter->pdev->dev,\r\n"HAL Version: %d Non Privileged function\n",\r\nadapter->ahw->fw_hal_version);\r\nadapter->nic_ops = &qlcnic_vf_ops;\r\n} else\r\nadapter->nic_ops = &qlcnic_ops;\r\n}\r\nstatic void qlcnic_get_bar_length(u32 dev_id, ulong *bar)\r\n{\r\nswitch (dev_id) {\r\ncase PCI_DEVICE_ID_QLOGIC_QLE824X:\r\n*bar = QLCNIC_82XX_BAR0_LENGTH;\r\nbreak;\r\ncase PCI_DEVICE_ID_QLOGIC_QLE834X:\r\ncase PCI_DEVICE_ID_QLOGIC_QLE8830:\r\ncase PCI_DEVICE_ID_QLOGIC_QLE844X:\r\ncase PCI_DEVICE_ID_QLOGIC_VF_QLE834X:\r\ncase PCI_DEVICE_ID_QLOGIC_VF_QLE844X:\r\ncase PCI_DEVICE_ID_QLOGIC_VF_QLE8C30:\r\n*bar = QLCNIC_83XX_BAR0_LENGTH;\r\nbreak;\r\ndefault:\r\n*bar = 0;\r\n}\r\n}\r\nstatic int qlcnic_setup_pci_map(struct pci_dev *pdev,\r\nstruct qlcnic_hardware_context *ahw)\r\n{\r\nu32 offset;\r\nvoid __iomem *mem_ptr0 = NULL;\r\nunsigned long mem_len, pci_len0 = 0, bar0_len;\r\nmem_len = pci_resource_len(pdev, 0);\r\nqlcnic_get_bar_length(pdev->device, &bar0_len);\r\nif (mem_len >= bar0_len) {\r\nmem_ptr0 = pci_ioremap_bar(pdev, 0);\r\nif (mem_ptr0 == NULL) {\r\ndev_err(&pdev->dev, "failed to map PCI bar 0\n");\r\nreturn -EIO;\r\n}\r\npci_len0 = mem_len;\r\n} else {\r\nreturn -EIO;\r\n}\r\ndev_info(&pdev->dev, "%dKB memory map\n", (int)(mem_len >> 10));\r\nahw->pci_base0 = mem_ptr0;\r\nahw->pci_len0 = pci_len0;\r\noffset = QLCNIC_PCIX_PS_REG(PCIX_OCM_WINDOW_REG(ahw->pci_func));\r\nqlcnic_get_ioaddr(ahw, offset);\r\nreturn 0;\r\n}\r\nstatic bool qlcnic_validate_subsystem_id(struct qlcnic_adapter *adapter,\r\nint index)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nunsigned short subsystem_vendor;\r\nbool ret = true;\r\nsubsystem_vendor = pdev->subsystem_vendor;\r\nif (pdev->device == PCI_DEVICE_ID_QLOGIC_QLE824X ||\r\npdev->device == PCI_DEVICE_ID_QLOGIC_QLE834X) {\r\nif (qlcnic_boards[index].sub_vendor == subsystem_vendor &&\r\nqlcnic_boards[index].sub_device == pdev->subsystem_device)\r\nret = true;\r\nelse\r\nret = false;\r\n}\r\nreturn ret;\r\n}\r\nstatic void qlcnic_get_board_name(struct qlcnic_adapter *adapter, char *name)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint i, found = 0;\r\nfor (i = 0; i < NUM_SUPPORTED_BOARDS; ++i) {\r\nif (qlcnic_boards[i].vendor == pdev->vendor &&\r\nqlcnic_boards[i].device == pdev->device &&\r\nqlcnic_validate_subsystem_id(adapter, i)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nsprintf(name, "%pM Gigabit Ethernet", adapter->mac_addr);\r\nelse\r\nsprintf(name, "%pM: %s" , adapter->mac_addr,\r\nqlcnic_boards[i].short_name);\r\n}\r\nstatic void\r\nqlcnic_check_options(struct qlcnic_adapter *adapter)\r\n{\r\nint err;\r\nu32 fw_major, fw_minor, fw_build, prev_fw_version;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_fw_dump *fw_dump = &ahw->fw_dump;\r\nprev_fw_version = adapter->fw_version;\r\nfw_major = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MAJOR);\r\nfw_minor = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MINOR);\r\nfw_build = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_SUB);\r\nadapter->fw_version = QLCNIC_VERSION_CODE(fw_major, fw_minor, fw_build);\r\nerr = qlcnic_get_board_info(adapter);\r\nif (err) {\r\ndev_err(&pdev->dev, "Error getting board config info.\n");\r\nreturn;\r\n}\r\nif (ahw->op_mode != QLCNIC_NON_PRIV_FUNC) {\r\nif (fw_dump->tmpl_hdr == NULL ||\r\nadapter->fw_version > prev_fw_version) {\r\nvfree(fw_dump->tmpl_hdr);\r\nif (!qlcnic_fw_cmd_get_minidump_temp(adapter))\r\ndev_info(&pdev->dev,\r\n"Supports FW dump capability\n");\r\n}\r\n}\r\ndev_info(&pdev->dev, "Driver v%s, firmware v%d.%d.%d\n",\r\nQLCNIC_LINUX_VERSIONID, fw_major, fw_minor, fw_build);\r\nif (adapter->ahw->port_type == QLCNIC_XGBE) {\r\nif (adapter->flags & QLCNIC_ESWITCH_ENABLED) {\r\nadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_VF;\r\nadapter->max_rxd = MAX_RCV_DESCRIPTORS_VF;\r\n} else {\r\nadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_10G;\r\nadapter->max_rxd = MAX_RCV_DESCRIPTORS_10G;\r\n}\r\nadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_10G;\r\nadapter->max_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_10G;\r\n} else if (adapter->ahw->port_type == QLCNIC_GBE) {\r\nadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_1G;\r\nadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_1G;\r\nadapter->max_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_1G;\r\nadapter->max_rxd = MAX_RCV_DESCRIPTORS_1G;\r\n}\r\nadapter->ahw->msix_supported = !!qlcnic_use_msi_x;\r\nadapter->num_txd = MAX_CMD_DESCRIPTORS;\r\nadapter->max_rds_rings = MAX_RDS_RINGS;\r\n}\r\nstatic int\r\nqlcnic_initialize_nic(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_info nic_info;\r\nint err = 0;\r\nmemset(&nic_info, 0, sizeof(struct qlcnic_info));\r\nerr = qlcnic_get_nic_info(adapter, &nic_info, adapter->ahw->pci_func);\r\nif (err)\r\nreturn err;\r\nadapter->ahw->physical_port = (u8)nic_info.phys_port;\r\nadapter->ahw->switch_mode = nic_info.switch_mode;\r\nadapter->ahw->max_tx_ques = nic_info.max_tx_ques;\r\nadapter->ahw->max_rx_ques = nic_info.max_rx_ques;\r\nadapter->ahw->capabilities = nic_info.capabilities;\r\nif (adapter->ahw->capabilities & QLCNIC_FW_CAPABILITY_MORE_CAPS) {\r\nu32 temp;\r\ntemp = QLCRD32(adapter, CRB_FW_CAPABILITIES_2, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nadapter->ahw->extra_capability[0] = temp;\r\n} else {\r\nadapter->ahw->extra_capability[0] = 0;\r\n}\r\nadapter->ahw->max_mac_filters = nic_info.max_mac_filters;\r\nadapter->ahw->max_mtu = nic_info.max_mtu;\r\nif (adapter->ahw->capabilities & BIT_6) {\r\nadapter->flags |= QLCNIC_ESWITCH_ENABLED;\r\nadapter->ahw->nic_mode = QLCNIC_VNIC_MODE;\r\nadapter->max_tx_rings = QLCNIC_MAX_HW_VNIC_TX_RINGS;\r\nadapter->max_sds_rings = QLCNIC_MAX_VNIC_SDS_RINGS;\r\ndev_info(&adapter->pdev->dev, "vNIC mode enabled.\n");\r\n} else {\r\nadapter->ahw->nic_mode = QLCNIC_DEFAULT_MODE;\r\nadapter->max_tx_rings = QLCNIC_MAX_HW_TX_RINGS;\r\nadapter->max_sds_rings = QLCNIC_MAX_SDS_RINGS;\r\nadapter->flags &= ~QLCNIC_ESWITCH_ENABLED;\r\n}\r\nreturn err;\r\n}\r\nvoid qlcnic_set_vlan_config(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_esw_func_cfg *esw_cfg)\r\n{\r\nif (esw_cfg->discard_tagged)\r\nadapter->flags &= ~QLCNIC_TAGGING_ENABLED;\r\nelse\r\nadapter->flags |= QLCNIC_TAGGING_ENABLED;\r\nif (esw_cfg->vlan_id) {\r\nadapter->rx_pvid = esw_cfg->vlan_id;\r\nadapter->tx_pvid = esw_cfg->vlan_id;\r\n} else {\r\nadapter->rx_pvid = 0;\r\nadapter->tx_pvid = 0;\r\n}\r\n}\r\nstatic int\r\nqlcnic_vlan_rx_add(struct net_device *netdev, __be16 proto, u16 vid)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint err;\r\nif (qlcnic_sriov_vf_check(adapter)) {\r\nerr = qlcnic_sriov_cfg_vf_guest_vlan(adapter, vid, 1);\r\nif (err) {\r\nnetdev_err(netdev,\r\n"Cannot add VLAN filter for VLAN id %d, err=%d",\r\nvid, err);\r\nreturn err;\r\n}\r\n}\r\nset_bit(vid, adapter->vlans);\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_vlan_rx_del(struct net_device *netdev, __be16 proto, u16 vid)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint err;\r\nif (qlcnic_sriov_vf_check(adapter)) {\r\nerr = qlcnic_sriov_cfg_vf_guest_vlan(adapter, vid, 0);\r\nif (err) {\r\nnetdev_err(netdev,\r\n"Cannot delete VLAN filter for VLAN id %d, err=%d",\r\nvid, err);\r\nreturn err;\r\n}\r\n}\r\nqlcnic_restore_indev_addr(netdev, NETDEV_DOWN);\r\nclear_bit(vid, adapter->vlans);\r\nreturn 0;\r\n}\r\nvoid qlcnic_set_eswitch_port_features(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_esw_func_cfg *esw_cfg)\r\n{\r\nadapter->flags &= ~(QLCNIC_MACSPOOF | QLCNIC_MAC_OVERRIDE_DISABLED |\r\nQLCNIC_PROMISC_DISABLED);\r\nif (esw_cfg->mac_anti_spoof)\r\nadapter->flags |= QLCNIC_MACSPOOF;\r\nif (!esw_cfg->mac_override)\r\nadapter->flags |= QLCNIC_MAC_OVERRIDE_DISABLED;\r\nif (!esw_cfg->promisc_mode)\r\nadapter->flags |= QLCNIC_PROMISC_DISABLED;\r\n}\r\nint qlcnic_set_eswitch_port_config(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_esw_func_cfg esw_cfg;\r\nif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED))\r\nreturn 0;\r\nesw_cfg.pci_func = adapter->ahw->pci_func;\r\nif (qlcnic_get_eswitch_port_config(adapter, &esw_cfg))\r\nreturn -EIO;\r\nqlcnic_set_vlan_config(adapter, &esw_cfg);\r\nqlcnic_set_eswitch_port_features(adapter, &esw_cfg);\r\nqlcnic_set_netdev_features(adapter, &esw_cfg);\r\nreturn 0;\r\n}\r\nvoid qlcnic_set_netdev_features(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_esw_func_cfg *esw_cfg)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nif (qlcnic_83xx_check(adapter))\r\nreturn;\r\nadapter->offload_flags = esw_cfg->offload_flags;\r\nadapter->flags |= QLCNIC_APP_CHANGED_FLAGS;\r\nnetdev_update_features(netdev);\r\nadapter->flags &= ~QLCNIC_APP_CHANGED_FLAGS;\r\n}\r\nstatic int\r\nqlcnic_check_eswitch_mode(struct qlcnic_adapter *adapter)\r\n{\r\nu32 op_mode, priv_level;\r\nint err = 0;\r\nerr = qlcnic_initialize_nic(adapter);\r\nif (err)\r\nreturn err;\r\nif (adapter->flags & QLCNIC_ADAPTER_INITIALIZED)\r\nreturn 0;\r\nop_mode = QLC_SHARED_REG_RD32(adapter, QLCNIC_DRV_OP_MODE);\r\npriv_level = QLC_DEV_GET_DRV(op_mode, adapter->ahw->pci_func);\r\nif (op_mode == QLC_DEV_DRV_DEFAULT)\r\npriv_level = QLCNIC_MGMT_FUNC;\r\nelse\r\npriv_level = QLC_DEV_GET_DRV(op_mode, adapter->ahw->pci_func);\r\nif (adapter->flags & QLCNIC_ESWITCH_ENABLED) {\r\nif (priv_level == QLCNIC_MGMT_FUNC) {\r\nadapter->ahw->op_mode = QLCNIC_MGMT_FUNC;\r\nerr = qlcnic_init_pci_info(adapter);\r\nif (err)\r\nreturn err;\r\nqlcnic_set_function_modes(adapter);\r\ndev_info(&adapter->pdev->dev,\r\n"HAL Version: %d, Management function\n",\r\nadapter->ahw->fw_hal_version);\r\n} else if (priv_level == QLCNIC_PRIV_FUNC) {\r\nadapter->ahw->op_mode = QLCNIC_PRIV_FUNC;\r\ndev_info(&adapter->pdev->dev,\r\n"HAL Version: %d, Privileged function\n",\r\nadapter->ahw->fw_hal_version);\r\n}\r\n} else {\r\nadapter->ahw->nic_mode = QLCNIC_DEFAULT_MODE;\r\n}\r\nadapter->flags |= QLCNIC_ADAPTER_INITIALIZED;\r\nreturn err;\r\n}\r\nint qlcnic_set_default_offload_settings(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_esw_func_cfg esw_cfg;\r\nstruct qlcnic_npar_info *npar;\r\nu8 i;\r\nif (adapter->need_fw_reset)\r\nreturn 0;\r\nfor (i = 0; i < adapter->ahw->total_nic_func; i++) {\r\nif (!adapter->npars[i].eswitch_status)\r\ncontinue;\r\nmemset(&esw_cfg, 0, sizeof(struct qlcnic_esw_func_cfg));\r\nesw_cfg.pci_func = adapter->npars[i].pci_func;\r\nesw_cfg.mac_override = BIT_0;\r\nesw_cfg.promisc_mode = BIT_0;\r\nif (qlcnic_82xx_check(adapter)) {\r\nesw_cfg.offload_flags = BIT_0;\r\nif (QLCNIC_IS_TSO_CAPABLE(adapter))\r\nesw_cfg.offload_flags |= (BIT_1 | BIT_2);\r\n}\r\nif (qlcnic_config_switch_port(adapter, &esw_cfg))\r\nreturn -EIO;\r\nnpar = &adapter->npars[i];\r\nnpar->pvid = esw_cfg.vlan_id;\r\nnpar->mac_override = esw_cfg.mac_override;\r\nnpar->mac_anti_spoof = esw_cfg.mac_anti_spoof;\r\nnpar->discard_tagged = esw_cfg.discard_tagged;\r\nnpar->promisc_mode = esw_cfg.promisc_mode;\r\nnpar->offload_flags = esw_cfg.offload_flags;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_reset_eswitch_config(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_npar_info *npar, int pci_func)\r\n{\r\nstruct qlcnic_esw_func_cfg esw_cfg;\r\nesw_cfg.op_mode = QLCNIC_PORT_DEFAULTS;\r\nesw_cfg.pci_func = pci_func;\r\nesw_cfg.vlan_id = npar->pvid;\r\nesw_cfg.mac_override = npar->mac_override;\r\nesw_cfg.discard_tagged = npar->discard_tagged;\r\nesw_cfg.mac_anti_spoof = npar->mac_anti_spoof;\r\nesw_cfg.offload_flags = npar->offload_flags;\r\nesw_cfg.promisc_mode = npar->promisc_mode;\r\nif (qlcnic_config_switch_port(adapter, &esw_cfg))\r\nreturn -EIO;\r\nesw_cfg.op_mode = QLCNIC_ADD_VLAN;\r\nif (qlcnic_config_switch_port(adapter, &esw_cfg))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint qlcnic_reset_npar_config(struct qlcnic_adapter *adapter)\r\n{\r\nint i, err;\r\nstruct qlcnic_npar_info *npar;\r\nstruct qlcnic_info nic_info;\r\nu8 pci_func;\r\nif (qlcnic_82xx_check(adapter))\r\nif (!adapter->need_fw_reset)\r\nreturn 0;\r\nfor (i = 0; i < adapter->ahw->total_nic_func; i++) {\r\nnpar = &adapter->npars[i];\r\npci_func = npar->pci_func;\r\nif (!adapter->npars[i].eswitch_status)\r\ncontinue;\r\nmemset(&nic_info, 0, sizeof(struct qlcnic_info));\r\nerr = qlcnic_get_nic_info(adapter, &nic_info, pci_func);\r\nif (err)\r\nreturn err;\r\nnic_info.min_tx_bw = npar->min_bw;\r\nnic_info.max_tx_bw = npar->max_bw;\r\nerr = qlcnic_set_nic_info(adapter, &nic_info);\r\nif (err)\r\nreturn err;\r\nif (npar->enable_pm) {\r\nerr = qlcnic_config_port_mirroring(adapter,\r\nnpar->dest_npar, 1,\r\npci_func);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = qlcnic_reset_eswitch_config(adapter, npar, pci_func);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_check_npar_opertional(struct qlcnic_adapter *adapter)\r\n{\r\nu8 npar_opt_timeo = QLCNIC_DEV_NPAR_OPER_TIMEO;\r\nu32 npar_state;\r\nif (adapter->ahw->op_mode == QLCNIC_MGMT_FUNC)\r\nreturn 0;\r\nnpar_state = QLC_SHARED_REG_RD32(adapter,\r\nQLCNIC_CRB_DEV_NPAR_STATE);\r\nwhile (npar_state != QLCNIC_DEV_NPAR_OPER && --npar_opt_timeo) {\r\nmsleep(1000);\r\nnpar_state = QLC_SHARED_REG_RD32(adapter,\r\nQLCNIC_CRB_DEV_NPAR_STATE);\r\n}\r\nif (!npar_opt_timeo) {\r\ndev_err(&adapter->pdev->dev,\r\n"Waiting for NPAR state to operational timeout\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_set_mgmt_operations(struct qlcnic_adapter *adapter)\r\n{\r\nint err;\r\nif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED) ||\r\nadapter->ahw->op_mode != QLCNIC_MGMT_FUNC)\r\nreturn 0;\r\nerr = qlcnic_set_default_offload_settings(adapter);\r\nif (err)\r\nreturn err;\r\nerr = qlcnic_reset_npar_config(adapter);\r\nif (err)\r\nreturn err;\r\nqlcnic_dev_set_npar_ready(adapter);\r\nreturn err;\r\n}\r\nstatic int qlcnic_82xx_start_firmware(struct qlcnic_adapter *adapter)\r\n{\r\nint err;\r\nerr = qlcnic_can_start_firmware(adapter);\r\nif (err < 0)\r\nreturn err;\r\nelse if (!err)\r\ngoto check_fw_status;\r\nif (qlcnic_load_fw_file)\r\nqlcnic_request_firmware(adapter);\r\nelse {\r\nerr = qlcnic_check_flash_fw_ver(adapter);\r\nif (err)\r\ngoto err_out;\r\nadapter->ahw->fw_type = QLCNIC_FLASH_ROMIMAGE;\r\n}\r\nerr = qlcnic_need_fw_reset(adapter);\r\nif (err == 0)\r\ngoto check_fw_status;\r\nerr = qlcnic_pinit_from_rom(adapter);\r\nif (err)\r\ngoto err_out;\r\nerr = qlcnic_load_firmware(adapter);\r\nif (err)\r\ngoto err_out;\r\nqlcnic_release_firmware(adapter);\r\nQLCWR32(adapter, CRB_DRIVER_VERSION, QLCNIC_DRIVER_VERSION);\r\ncheck_fw_status:\r\nerr = qlcnic_check_fw_status(adapter);\r\nif (err)\r\ngoto err_out;\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE, QLCNIC_DEV_READY);\r\nqlcnic_idc_debug_info(adapter, 1);\r\nerr = qlcnic_check_eswitch_mode(adapter);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"Memory allocation failed for eswitch\n");\r\ngoto err_out;\r\n}\r\nerr = qlcnic_set_mgmt_operations(adapter);\r\nif (err)\r\ngoto err_out;\r\nqlcnic_check_options(adapter);\r\nadapter->need_fw_reset = 0;\r\nqlcnic_release_firmware(adapter);\r\nreturn 0;\r\nerr_out:\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE, QLCNIC_DEV_FAILED);\r\ndev_err(&adapter->pdev->dev, "Device state set to failed\n");\r\nqlcnic_release_firmware(adapter);\r\nreturn err;\r\n}\r\nstatic int\r\nqlcnic_request_irq(struct qlcnic_adapter *adapter)\r\n{\r\nirq_handler_t handler;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\nint err, ring, num_sds_rings;\r\nunsigned long flags = 0;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nif (adapter->ahw->diag_test == QLCNIC_INTERRUPT_TEST) {\r\nif (qlcnic_82xx_check(adapter))\r\nhandler = qlcnic_tmp_intr;\r\nelse\r\nhandler = qlcnic_83xx_tmp_intr;\r\nif (!QLCNIC_IS_MSI_FAMILY(adapter))\r\nflags |= IRQF_SHARED;\r\n} else {\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED)\r\nhandler = qlcnic_msix_intr;\r\nelse if (adapter->flags & QLCNIC_MSI_ENABLED)\r\nhandler = qlcnic_msi_intr;\r\nelse {\r\nflags |= IRQF_SHARED;\r\nif (qlcnic_82xx_check(adapter))\r\nhandler = qlcnic_intr;\r\nelse\r\nhandler = qlcnic_83xx_intr;\r\n}\r\n}\r\nadapter->irq = netdev->irq;\r\nif (adapter->ahw->diag_test != QLCNIC_LOOPBACK_TEST) {\r\nif (qlcnic_82xx_check(adapter) ||\r\n(qlcnic_83xx_check(adapter) &&\r\n(adapter->flags & QLCNIC_MSIX_ENABLED))) {\r\nnum_sds_rings = adapter->drv_sds_rings;\r\nfor (ring = 0; ring < num_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nif (qlcnic_82xx_check(adapter) &&\r\n!qlcnic_check_multi_tx(adapter) &&\r\n(ring == (num_sds_rings - 1))) {\r\nif (!(adapter->flags &\r\nQLCNIC_MSIX_ENABLED))\r\nsnprintf(sds_ring->name,\r\nsizeof(sds_ring->name),\r\n"qlcnic");\r\nelse\r\nsnprintf(sds_ring->name,\r\nsizeof(sds_ring->name),\r\n"%s-tx-0-rx-%d",\r\nnetdev->name, ring);\r\n} else {\r\nsnprintf(sds_ring->name,\r\nsizeof(sds_ring->name),\r\n"%s-rx-%d",\r\nnetdev->name, ring);\r\n}\r\nerr = request_irq(sds_ring->irq, handler, flags,\r\nsds_ring->name, sds_ring);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nif ((qlcnic_82xx_check(adapter) &&\r\nqlcnic_check_multi_tx(adapter)) ||\r\n(qlcnic_83xx_check(adapter) &&\r\n(adapter->flags & QLCNIC_MSIX_ENABLED) &&\r\n!(adapter->flags & QLCNIC_TX_INTR_SHARED))) {\r\nhandler = qlcnic_msix_tx_intr;\r\nfor (ring = 0; ring < adapter->drv_tx_rings;\r\nring++) {\r\ntx_ring = &adapter->tx_ring[ring];\r\nsnprintf(tx_ring->name, sizeof(tx_ring->name),\r\n"%s-tx-%d", netdev->name, ring);\r\nerr = request_irq(tx_ring->irq, handler, flags,\r\ntx_ring->name, tx_ring);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nqlcnic_free_irq(struct qlcnic_adapter *adapter)\r\n{\r\nint ring;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nif (adapter->ahw->diag_test != QLCNIC_LOOPBACK_TEST) {\r\nif (qlcnic_82xx_check(adapter) ||\r\n(qlcnic_83xx_check(adapter) &&\r\n(adapter->flags & QLCNIC_MSIX_ENABLED))) {\r\nfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nfree_irq(sds_ring->irq, sds_ring);\r\n}\r\n}\r\nif ((qlcnic_83xx_check(adapter) &&\r\n!(adapter->flags & QLCNIC_TX_INTR_SHARED)) ||\r\n(qlcnic_82xx_check(adapter) &&\r\nqlcnic_check_multi_tx(adapter))) {\r\nfor (ring = 0; ring < adapter->drv_tx_rings;\r\nring++) {\r\ntx_ring = &adapter->tx_ring[ring];\r\nif (tx_ring->irq)\r\nfree_irq(tx_ring->irq, tx_ring);\r\n}\r\n}\r\n}\r\n}\r\nstatic void qlcnic_get_lro_mss_capability(struct qlcnic_adapter *adapter)\r\n{\r\nu32 capab = 0;\r\nif (qlcnic_82xx_check(adapter)) {\r\nif (adapter->ahw->extra_capability[0] &\r\nQLCNIC_FW_CAPABILITY_2_LRO_MAX_TCP_SEG)\r\nadapter->flags |= QLCNIC_FW_LRO_MSS_CAP;\r\n} else {\r\ncapab = adapter->ahw->capabilities;\r\nif (QLC_83XX_GET_FW_LRO_MSS_CAPABILITY(capab))\r\nadapter->flags |= QLCNIC_FW_LRO_MSS_CAP;\r\n}\r\n}\r\nstatic int qlcnic_config_def_intr_coalesce(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint err;\r\nahw->coal.flag = QLCNIC_INTR_DEFAULT;\r\nif (qlcnic_83xx_check(adapter)) {\r\nahw->coal.type = QLCNIC_INTR_COAL_TYPE_RX_TX;\r\nahw->coal.tx_time_us = QLCNIC_DEF_INTR_COALESCE_TX_TIME_US;\r\nahw->coal.tx_packets = QLCNIC_DEF_INTR_COALESCE_TX_PACKETS;\r\nahw->coal.rx_time_us = QLCNIC_DEF_INTR_COALESCE_RX_TIME_US;\r\nahw->coal.rx_packets = QLCNIC_DEF_INTR_COALESCE_RX_PACKETS;\r\nerr = qlcnic_83xx_set_rx_tx_intr_coal(adapter);\r\n} else {\r\nahw->coal.type = QLCNIC_INTR_COAL_TYPE_RX;\r\nahw->coal.rx_time_us = QLCNIC_DEF_INTR_COALESCE_RX_TIME_US;\r\nahw->coal.rx_packets = QLCNIC_DEF_INTR_COALESCE_RX_PACKETS;\r\nerr = qlcnic_82xx_set_rx_coalesce(adapter);\r\n}\r\nreturn err;\r\n}\r\nint __qlcnic_up(struct qlcnic_adapter *adapter, struct net_device *netdev)\r\n{\r\nint ring;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nif (adapter->is_up != QLCNIC_ADAPTER_UP_MAGIC)\r\nreturn -EIO;\r\nif (test_bit(__QLCNIC_DEV_UP, &adapter->state))\r\nreturn 0;\r\nif (qlcnic_set_eswitch_port_config(adapter))\r\nreturn -EIO;\r\nqlcnic_get_lro_mss_capability(adapter);\r\nif (qlcnic_fw_create_ctx(adapter))\r\nreturn -EIO;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &adapter->recv_ctx->rds_rings[ring];\r\nqlcnic_post_rx_buffers(adapter, rds_ring, ring);\r\n}\r\nqlcnic_set_multi(netdev);\r\nqlcnic_fw_cmd_set_mtu(adapter, netdev->mtu);\r\nadapter->ahw->linkup = 0;\r\nif (adapter->drv_sds_rings > 1)\r\nqlcnic_config_rss(adapter, 1);\r\nqlcnic_config_def_intr_coalesce(adapter);\r\nif (netdev->features & NETIF_F_LRO)\r\nqlcnic_config_hw_lro(adapter, QLCNIC_LRO_ENABLED);\r\nset_bit(__QLCNIC_DEV_UP, &adapter->state);\r\nqlcnic_napi_enable(adapter);\r\nqlcnic_linkevent_request(adapter, 1);\r\nadapter->ahw->reset_context = 0;\r\nnetif_tx_start_all_queues(netdev);\r\nreturn 0;\r\n}\r\nint qlcnic_up(struct qlcnic_adapter *adapter, struct net_device *netdev)\r\n{\r\nint err = 0;\r\nrtnl_lock();\r\nif (netif_running(netdev))\r\nerr = __qlcnic_up(adapter, netdev);\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nvoid __qlcnic_down(struct qlcnic_adapter *adapter, struct net_device *netdev)\r\n{\r\nint ring;\r\nif (adapter->is_up != QLCNIC_ADAPTER_UP_MAGIC)\r\nreturn;\r\nif (!test_and_clear_bit(__QLCNIC_DEV_UP, &adapter->state))\r\nreturn;\r\nsmp_mb();\r\nnetif_carrier_off(netdev);\r\nadapter->ahw->linkup = 0;\r\nnetif_tx_disable(netdev);\r\nqlcnic_free_mac_list(adapter);\r\nif (adapter->fhash.fnum)\r\nqlcnic_delete_lb_filters(adapter);\r\nqlcnic_nic_set_promisc(adapter, QLCNIC_NIU_NON_PROMISC_MODE);\r\nif (qlcnic_sriov_vf_check(adapter))\r\nqlcnic_sriov_cleanup_async_list(&adapter->ahw->sriov->bc);\r\nqlcnic_napi_disable(adapter);\r\nqlcnic_fw_destroy_ctx(adapter);\r\nadapter->flags &= ~QLCNIC_FW_LRO_MSS_CAP;\r\nqlcnic_reset_rx_buffers_list(adapter);\r\nfor (ring = 0; ring < adapter->drv_tx_rings; ring++)\r\nqlcnic_release_tx_buffers(adapter, &adapter->tx_ring[ring]);\r\n}\r\nvoid qlcnic_down(struct qlcnic_adapter *adapter, struct net_device *netdev)\r\n{\r\nrtnl_lock();\r\nif (netif_running(netdev))\r\n__qlcnic_down(adapter, netdev);\r\nrtnl_unlock();\r\n}\r\nint\r\nqlcnic_attach(struct qlcnic_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint err;\r\nif (adapter->is_up == QLCNIC_ADAPTER_UP_MAGIC)\r\nreturn 0;\r\nerr = qlcnic_napi_add(adapter, netdev);\r\nif (err)\r\nreturn err;\r\nerr = qlcnic_alloc_sw_resources(adapter);\r\nif (err) {\r\ndev_err(&pdev->dev, "Error in setting sw resources\n");\r\ngoto err_out_napi_del;\r\n}\r\nerr = qlcnic_alloc_hw_resources(adapter);\r\nif (err) {\r\ndev_err(&pdev->dev, "Error in setting hw resources\n");\r\ngoto err_out_free_sw;\r\n}\r\nerr = qlcnic_request_irq(adapter);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to setup interrupt\n");\r\ngoto err_out_free_hw;\r\n}\r\nqlcnic_create_sysfs_entries(adapter);\r\nif (qlcnic_encap_rx_offload(adapter))\r\nudp_tunnel_get_rx_info(netdev);\r\nadapter->is_up = QLCNIC_ADAPTER_UP_MAGIC;\r\nreturn 0;\r\nerr_out_free_hw:\r\nqlcnic_free_hw_resources(adapter);\r\nerr_out_free_sw:\r\nqlcnic_free_sw_resources(adapter);\r\nerr_out_napi_del:\r\nqlcnic_napi_del(adapter);\r\nreturn err;\r\n}\r\nvoid qlcnic_detach(struct qlcnic_adapter *adapter)\r\n{\r\nif (adapter->is_up != QLCNIC_ADAPTER_UP_MAGIC)\r\nreturn;\r\nqlcnic_remove_sysfs_entries(adapter);\r\nqlcnic_free_hw_resources(adapter);\r\nqlcnic_release_rx_buffers(adapter);\r\nqlcnic_free_irq(adapter);\r\nqlcnic_napi_del(adapter);\r\nqlcnic_free_sw_resources(adapter);\r\nadapter->is_up = 0;\r\n}\r\nvoid qlcnic_diag_free_res(struct net_device *netdev, int drv_sds_rings)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nint drv_tx_rings = adapter->drv_tx_rings;\r\nint ring;\r\nclear_bit(__QLCNIC_DEV_UP, &adapter->state);\r\nif (adapter->ahw->diag_test == QLCNIC_INTERRUPT_TEST) {\r\nfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\r\nsds_ring = &adapter->recv_ctx->sds_rings[ring];\r\nqlcnic_disable_sds_intr(adapter, sds_ring);\r\n}\r\n}\r\nqlcnic_fw_destroy_ctx(adapter);\r\nqlcnic_detach(adapter);\r\nadapter->ahw->diag_test = 0;\r\nadapter->drv_sds_rings = drv_sds_rings;\r\nadapter->drv_tx_rings = drv_tx_rings;\r\nif (qlcnic_attach(adapter))\r\ngoto out;\r\nif (netif_running(netdev))\r\n__qlcnic_up(adapter, netdev);\r\nout:\r\nnetif_device_attach(netdev);\r\n}\r\nstatic int qlcnic_alloc_adapter_resources(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint err = 0;\r\nadapter->recv_ctx = kzalloc(sizeof(struct qlcnic_recv_context),\r\nGFP_KERNEL);\r\nif (!adapter->recv_ctx) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nif (qlcnic_83xx_check(adapter)) {\r\nahw->coal.type = QLCNIC_INTR_COAL_TYPE_RX_TX;\r\nahw->coal.tx_time_us = QLCNIC_DEF_INTR_COALESCE_TX_TIME_US;\r\nahw->coal.tx_packets = QLCNIC_DEF_INTR_COALESCE_TX_PACKETS;\r\nahw->coal.rx_time_us = QLCNIC_DEF_INTR_COALESCE_RX_TIME_US;\r\nahw->coal.rx_packets = QLCNIC_DEF_INTR_COALESCE_RX_PACKETS;\r\n} else {\r\nahw->coal.type = QLCNIC_INTR_COAL_TYPE_RX;\r\nahw->coal.rx_time_us = QLCNIC_DEF_INTR_COALESCE_RX_TIME_US;\r\nahw->coal.rx_packets = QLCNIC_DEF_INTR_COALESCE_RX_PACKETS;\r\n}\r\nmemset(&adapter->stats, 0, sizeof(adapter->stats));\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic void qlcnic_free_adapter_resources(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\r\nkfree(adapter->recv_ctx);\r\nadapter->recv_ctx = NULL;\r\nif (fw_dump->tmpl_hdr) {\r\nvfree(fw_dump->tmpl_hdr);\r\nfw_dump->tmpl_hdr = NULL;\r\n}\r\nif (fw_dump->dma_buffer) {\r\ndma_free_coherent(&adapter->pdev->dev, QLC_PEX_DMA_READ_SIZE,\r\nfw_dump->dma_buffer, fw_dump->phys_addr);\r\nfw_dump->dma_buffer = NULL;\r\n}\r\nkfree(adapter->ahw->reset.buff);\r\nadapter->ahw->fw_dump.tmpl_hdr = NULL;\r\n}\r\nint qlcnic_diag_alloc_res(struct net_device *netdev, int test)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nint ring;\r\nint ret;\r\nnetif_device_detach(netdev);\r\nif (netif_running(netdev))\r\n__qlcnic_down(adapter, netdev);\r\nqlcnic_detach(adapter);\r\nadapter->drv_sds_rings = QLCNIC_SINGLE_RING;\r\nadapter->ahw->diag_test = test;\r\nadapter->ahw->linkup = 0;\r\nret = qlcnic_attach(adapter);\r\nif (ret) {\r\nnetif_device_attach(netdev);\r\nreturn ret;\r\n}\r\nret = qlcnic_fw_create_ctx(adapter);\r\nif (ret) {\r\nqlcnic_detach(adapter);\r\nnetif_device_attach(netdev);\r\nreturn ret;\r\n}\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &adapter->recv_ctx->rds_rings[ring];\r\nqlcnic_post_rx_buffers(adapter, rds_ring, ring);\r\n}\r\nif (adapter->ahw->diag_test == QLCNIC_INTERRUPT_TEST) {\r\nfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\r\nsds_ring = &adapter->recv_ctx->sds_rings[ring];\r\nqlcnic_enable_sds_intr(adapter, sds_ring);\r\n}\r\n}\r\nif (adapter->ahw->diag_test == QLCNIC_LOOPBACK_TEST) {\r\nadapter->ahw->loopback_state = 0;\r\nqlcnic_linkevent_request(adapter, 1);\r\n}\r\nset_bit(__QLCNIC_DEV_UP, &adapter->state);\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_reset_hw_context(struct qlcnic_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nif (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\r\nreturn -EBUSY;\r\nnetif_device_detach(netdev);\r\nqlcnic_down(adapter, netdev);\r\nqlcnic_up(adapter, netdev);\r\nnetif_device_attach(netdev);\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nnetdev_info(adapter->netdev, "%s: soft reset complete\n", __func__);\r\nreturn 0;\r\n}\r\nint\r\nqlcnic_reset_context(struct qlcnic_adapter *adapter)\r\n{\r\nint err = 0;\r\nstruct net_device *netdev = adapter->netdev;\r\nif (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\r\nreturn -EBUSY;\r\nif (adapter->is_up == QLCNIC_ADAPTER_UP_MAGIC) {\r\nnetif_device_detach(netdev);\r\nif (netif_running(netdev))\r\n__qlcnic_down(adapter, netdev);\r\nqlcnic_detach(adapter);\r\nif (netif_running(netdev)) {\r\nerr = qlcnic_attach(adapter);\r\nif (!err) {\r\n__qlcnic_up(adapter, netdev);\r\nqlcnic_restore_indev_addr(netdev, NETDEV_UP);\r\n}\r\n}\r\nnetif_device_attach(netdev);\r\n}\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nreturn err;\r\n}\r\nstatic void qlcnic_82xx_set_mac_filter_count(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nu16 act_pci_fn = ahw->total_nic_func;\r\nu16 count;\r\nahw->max_mc_count = QLCNIC_MAX_MC_COUNT;\r\nif (act_pci_fn <= 2)\r\ncount = (QLCNIC_MAX_UC_COUNT - QLCNIC_MAX_MC_COUNT) /\r\nact_pci_fn;\r\nelse\r\ncount = (QLCNIC_LB_MAX_FILTERS - QLCNIC_MAX_MC_COUNT) /\r\nact_pci_fn;\r\nahw->max_uc_count = count;\r\n}\r\nstatic int qlcnic_set_real_num_queues(struct qlcnic_adapter *adapter,\r\nu8 tx_queues, u8 rx_queues)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nint err = 0;\r\nif (tx_queues) {\r\nerr = netif_set_real_num_tx_queues(netdev, tx_queues);\r\nif (err) {\r\nnetdev_err(netdev, "failed to set %d Tx queues\n",\r\ntx_queues);\r\nreturn err;\r\n}\r\n}\r\nif (rx_queues) {\r\nerr = netif_set_real_num_rx_queues(netdev, rx_queues);\r\nif (err)\r\nnetdev_err(netdev, "failed to set %d Rx queues\n",\r\nrx_queues);\r\n}\r\nreturn err;\r\n}\r\nint\r\nqlcnic_setup_netdev(struct qlcnic_adapter *adapter, struct net_device *netdev,\r\nint pci_using_dac)\r\n{\r\nint err;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nadapter->rx_csum = 1;\r\nadapter->ahw->mc_enabled = 0;\r\nqlcnic_set_mac_filter_count(adapter);\r\nnetdev->netdev_ops = &qlcnic_netdev_ops;\r\nnetdev->watchdog_timeo = QLCNIC_WATCHDOG_TIMEOUTVALUE * HZ;\r\nqlcnic_change_mtu(netdev, netdev->mtu);\r\nnetdev->ethtool_ops = (qlcnic_sriov_vf_check(adapter)) ?\r\n&qlcnic_sriov_vf_ethtool_ops : &qlcnic_ethtool_ops;\r\nnetdev->features |= (NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_RXCSUM |\r\nNETIF_F_IPV6_CSUM | NETIF_F_GRO |\r\nNETIF_F_HW_VLAN_CTAG_RX);\r\nnetdev->vlan_features |= (NETIF_F_SG | NETIF_F_IP_CSUM |\r\nNETIF_F_IPV6_CSUM);\r\nif (QLCNIC_IS_TSO_CAPABLE(adapter)) {\r\nnetdev->features |= (NETIF_F_TSO | NETIF_F_TSO6);\r\nnetdev->vlan_features |= (NETIF_F_TSO | NETIF_F_TSO6);\r\n}\r\nif (pci_using_dac) {\r\nnetdev->features |= NETIF_F_HIGHDMA;\r\nnetdev->vlan_features |= NETIF_F_HIGHDMA;\r\n}\r\nif (qlcnic_vlan_tx_check(adapter))\r\nnetdev->features |= (NETIF_F_HW_VLAN_CTAG_TX);\r\nif (qlcnic_sriov_vf_check(adapter))\r\nnetdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\r\nif (adapter->ahw->capabilities & QLCNIC_FW_CAPABILITY_HW_LRO)\r\nnetdev->features |= NETIF_F_LRO;\r\nif (qlcnic_encap_tx_offload(adapter)) {\r\nnetdev->features |= NETIF_F_GSO_UDP_TUNNEL;\r\nnetdev->hw_enc_features = NETIF_F_IP_CSUM |\r\nNETIF_F_GSO_UDP_TUNNEL |\r\nNETIF_F_TSO |\r\nNETIF_F_TSO6;\r\n}\r\nif (qlcnic_encap_rx_offload(adapter))\r\nnetdev->hw_enc_features |= NETIF_F_RXCSUM;\r\nnetdev->hw_features = netdev->features;\r\nnetdev->priv_flags |= IFF_UNICAST_FLT;\r\nnetdev->irq = adapter->msix_entries[0].vector;\r\nnetdev->min_mtu = P3P_MIN_MTU;\r\nnetdev->max_mtu = P3P_MAX_MTU;\r\nerr = qlcnic_set_real_num_queues(adapter, adapter->drv_tx_rings,\r\nadapter->drv_sds_rings);\r\nif (err)\r\nreturn err;\r\nqlcnic_dcb_init_dcbnl_ops(adapter->dcb);\r\nerr = register_netdev(netdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to register net device\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_set_dma_mask(struct pci_dev *pdev, int *pci_using_dac)\r\n{\r\nif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) &&\r\n!pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64)))\r\n*pci_using_dac = 1;\r\nelse if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) &&\r\n!pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32)))\r\n*pci_using_dac = 0;\r\nelse {\r\ndev_err(&pdev->dev, "Unable to set DMA mask, aborting\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nvoid qlcnic_free_tx_rings(struct qlcnic_adapter *adapter)\r\n{\r\nint ring;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\nfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\r\ntx_ring = &adapter->tx_ring[ring];\r\nif (tx_ring) {\r\nvfree(tx_ring->cmd_buf_arr);\r\ntx_ring->cmd_buf_arr = NULL;\r\n}\r\n}\r\nkfree(adapter->tx_ring);\r\n}\r\nint qlcnic_alloc_tx_rings(struct qlcnic_adapter *adapter,\r\nstruct net_device *netdev)\r\n{\r\nint ring, vector, index;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\nstruct qlcnic_cmd_buffer *cmd_buf_arr;\r\ntx_ring = kcalloc(adapter->drv_tx_rings,\r\nsizeof(struct qlcnic_host_tx_ring), GFP_KERNEL);\r\nif (tx_ring == NULL)\r\nreturn -ENOMEM;\r\nadapter->tx_ring = tx_ring;\r\nfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\r\ntx_ring = &adapter->tx_ring[ring];\r\ntx_ring->num_desc = adapter->num_txd;\r\ntx_ring->txq = netdev_get_tx_queue(netdev, ring);\r\ncmd_buf_arr = vzalloc(TX_BUFF_RINGSIZE(tx_ring));\r\nif (cmd_buf_arr == NULL) {\r\nqlcnic_free_tx_rings(adapter);\r\nreturn -ENOMEM;\r\n}\r\ntx_ring->cmd_buf_arr = cmd_buf_arr;\r\nspin_lock_init(&tx_ring->tx_clean_lock);\r\n}\r\nif (qlcnic_83xx_check(adapter) ||\r\n(qlcnic_82xx_check(adapter) && qlcnic_check_multi_tx(adapter))) {\r\nfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\r\ntx_ring = &adapter->tx_ring[ring];\r\ntx_ring->adapter = adapter;\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED) {\r\nindex = adapter->drv_sds_rings + ring;\r\nvector = adapter->msix_entries[index].vector;\r\ntx_ring->irq = vector;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid qlcnic_set_drv_version(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nu32 fw_cmd = 0;\r\nif (qlcnic_82xx_check(adapter))\r\nfw_cmd = QLCNIC_CMD_82XX_SET_DRV_VER;\r\nelse if (qlcnic_83xx_check(adapter))\r\nfw_cmd = QLCNIC_CMD_83XX_SET_DRV_VER;\r\nif (ahw->extra_capability[0] & QLCNIC_FW_CAPABILITY_SET_DRV_VER)\r\nqlcnic_fw_cmd_set_drv_version(adapter, fw_cmd);\r\n}\r\nstatic void qlcnic_reset_api_lock(struct qlcnic_adapter *adapter)\r\n{\r\nqlcnic_api_lock(adapter);\r\nqlcnic_api_unlock(adapter);\r\n}\r\nstatic int\r\nqlcnic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct net_device *netdev = NULL;\r\nstruct qlcnic_adapter *adapter = NULL;\r\nstruct qlcnic_hardware_context *ahw;\r\nint err, pci_using_dac = -1;\r\nchar board_name[QLCNIC_MAX_BOARD_NAME_LEN + 19];\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\nreturn err;\r\nif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\r\nerr = -ENODEV;\r\ngoto err_out_disable_pdev;\r\n}\r\nerr = qlcnic_set_dma_mask(pdev, &pci_using_dac);\r\nif (err)\r\ngoto err_out_disable_pdev;\r\nerr = pci_request_regions(pdev, qlcnic_driver_name);\r\nif (err)\r\ngoto err_out_disable_pdev;\r\npci_set_master(pdev);\r\npci_enable_pcie_error_reporting(pdev);\r\nahw = kzalloc(sizeof(struct qlcnic_hardware_context), GFP_KERNEL);\r\nif (!ahw) {\r\nerr = -ENOMEM;\r\ngoto err_out_free_res;\r\n}\r\nswitch (ent->device) {\r\ncase PCI_DEVICE_ID_QLOGIC_QLE824X:\r\nahw->hw_ops = &qlcnic_hw_ops;\r\nahw->reg_tbl = (u32 *) qlcnic_reg_tbl;\r\nbreak;\r\ncase PCI_DEVICE_ID_QLOGIC_QLE834X:\r\ncase PCI_DEVICE_ID_QLOGIC_QLE8830:\r\ncase PCI_DEVICE_ID_QLOGIC_QLE844X:\r\nqlcnic_83xx_register_map(ahw);\r\nbreak;\r\ncase PCI_DEVICE_ID_QLOGIC_VF_QLE834X:\r\ncase PCI_DEVICE_ID_QLOGIC_VF_QLE8C30:\r\ncase PCI_DEVICE_ID_QLOGIC_VF_QLE844X:\r\nqlcnic_sriov_vf_register_map(ahw);\r\nbreak;\r\ndefault:\r\ngoto err_out_free_hw_res;\r\n}\r\nerr = qlcnic_setup_pci_map(pdev, ahw);\r\nif (err)\r\ngoto err_out_free_hw_res;\r\nnetdev = alloc_etherdev_mq(sizeof(struct qlcnic_adapter),\r\nQLCNIC_MAX_TX_RINGS);\r\nif (!netdev) {\r\nerr = -ENOMEM;\r\ngoto err_out_iounmap;\r\n}\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\nadapter = netdev_priv(netdev);\r\nadapter->netdev = netdev;\r\nadapter->pdev = pdev;\r\nadapter->ahw = ahw;\r\nadapter->qlcnic_wq = create_singlethread_workqueue("qlcnic");\r\nif (adapter->qlcnic_wq == NULL) {\r\nerr = -ENOMEM;\r\ndev_err(&pdev->dev, "Failed to create workqueue\n");\r\ngoto err_out_free_netdev;\r\n}\r\nerr = qlcnic_alloc_adapter_resources(adapter);\r\nif (err)\r\ngoto err_out_free_wq;\r\nadapter->dev_rst_time = jiffies;\r\nahw->revision_id = pdev->revision;\r\nahw->max_vnic_func = qlcnic_get_vnic_func_count(adapter);\r\nif (qlcnic_mac_learn == FDB_MAC_LEARN)\r\nadapter->fdb_mac_learn = true;\r\nelse if (qlcnic_mac_learn == DRV_MAC_LEARN)\r\nadapter->drv_mac_learn = true;\r\nrwlock_init(&adapter->ahw->crb_lock);\r\nmutex_init(&adapter->ahw->mem_lock);\r\nINIT_LIST_HEAD(&adapter->mac_list);\r\nqlcnic_register_dcb(adapter);\r\nif (qlcnic_82xx_check(adapter)) {\r\nqlcnic_check_vf(adapter, ent);\r\nadapter->portnum = adapter->ahw->pci_func;\r\nqlcnic_reset_api_lock(adapter);\r\nerr = qlcnic_start_firmware(adapter);\r\nif (err) {\r\ndev_err(&pdev->dev, "Loading fw failed.Please Reboot\n"\r\n"\t\tIf reboot doesn't help, try flashing the card\n");\r\ngoto err_out_maintenance_mode;\r\n}\r\nif (adapter->ahw->msix_supported) {\r\nif (qlcnic_check_multi_tx_capability(adapter) == 1)\r\nqlcnic_set_tx_ring_count(adapter,\r\nQLCNIC_SINGLE_RING);\r\nelse\r\nqlcnic_set_tx_ring_count(adapter,\r\nQLCNIC_DEF_TX_RINGS);\r\nqlcnic_set_sds_ring_count(adapter,\r\nQLCNIC_DEF_SDS_RINGS);\r\n} else {\r\nqlcnic_set_tx_ring_count(adapter, QLCNIC_SINGLE_RING);\r\nqlcnic_set_sds_ring_count(adapter, QLCNIC_SINGLE_RING);\r\n}\r\nerr = qlcnic_setup_idc_param(adapter);\r\nif (err)\r\ngoto err_out_free_hw;\r\nadapter->flags |= QLCNIC_NEED_FLR;\r\n} else if (qlcnic_83xx_check(adapter)) {\r\nqlcnic_83xx_check_vf(adapter, ent);\r\nadapter->portnum = adapter->ahw->pci_func;\r\nerr = qlcnic_83xx_init(adapter, pci_using_dac);\r\nif (err) {\r\nswitch (err) {\r\ncase -ENOTRECOVERABLE:\r\ndev_err(&pdev->dev, "Adapter initialization failed due to a faulty hardware\n");\r\ndev_err(&pdev->dev, "Please replace the adapter with new one and return the faulty adapter for repair\n");\r\ngoto err_out_free_hw;\r\ncase -ENOMEM:\r\ndev_err(&pdev->dev, "Adapter initialization failed. Please reboot\n");\r\ngoto err_out_free_hw;\r\ncase -EOPNOTSUPP:\r\ndev_err(&pdev->dev, "Adapter initialization failed\n");\r\ngoto err_out_free_hw;\r\ndefault:\r\ndev_err(&pdev->dev, "Adapter initialization failed. Driver will load in maintenance mode to recover the adapter using the application\n");\r\ngoto err_out_maintenance_mode;\r\n}\r\n}\r\nif (qlcnic_sriov_vf_check(adapter))\r\nreturn 0;\r\n} else {\r\ndev_err(&pdev->dev,\r\n"%s: failed. Please Reboot\n", __func__);\r\nerr = -ENODEV;\r\ngoto err_out_free_hw;\r\n}\r\nif (qlcnic_read_mac_addr(adapter))\r\ndev_warn(&pdev->dev, "failed to read mac addr\n");\r\nqlcnic_read_phys_port_id(adapter);\r\nif (adapter->portnum == 0) {\r\nqlcnic_get_board_name(adapter, board_name);\r\npr_info("%s: %s Board Chip rev 0x%x\n",\r\nmodule_name(THIS_MODULE),\r\nboard_name, adapter->ahw->revision_id);\r\n}\r\nif (qlcnic_83xx_check(adapter) && !qlcnic_use_msi_x &&\r\n!!qlcnic_use_msi)\r\ndev_warn(&pdev->dev,\r\n"Device does not support MSI interrupts\n");\r\nif (qlcnic_82xx_check(adapter)) {\r\nqlcnic_dcb_enable(adapter->dcb);\r\nqlcnic_dcb_get_info(adapter->dcb);\r\nerr = qlcnic_setup_intr(adapter);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to setup interrupt\n");\r\ngoto err_out_disable_msi;\r\n}\r\n}\r\nerr = qlcnic_get_act_pci_func(adapter);\r\nif (err)\r\ngoto err_out_disable_mbx_intr;\r\nif (adapter->portnum == 0)\r\nqlcnic_set_drv_version(adapter);\r\nerr = qlcnic_setup_netdev(adapter, netdev, pci_using_dac);\r\nif (err)\r\ngoto err_out_disable_mbx_intr;\r\npci_set_drvdata(pdev, adapter);\r\nif (qlcnic_82xx_check(adapter))\r\nqlcnic_schedule_work(adapter, qlcnic_fw_poll_work,\r\nFW_POLL_DELAY);\r\nswitch (adapter->ahw->port_type) {\r\ncase QLCNIC_GBE:\r\ndev_info(&adapter->pdev->dev, "%s: GbE port initialized\n",\r\nadapter->netdev->name);\r\nbreak;\r\ncase QLCNIC_XGBE:\r\ndev_info(&adapter->pdev->dev, "%s: XGbE port initialized\n",\r\nadapter->netdev->name);\r\nbreak;\r\n}\r\nif (adapter->drv_mac_learn)\r\nqlcnic_alloc_lb_filters_mem(adapter);\r\nqlcnic_add_sysfs(adapter);\r\nqlcnic_register_hwmon_dev(adapter);\r\nreturn 0;\r\nerr_out_disable_mbx_intr:\r\nif (qlcnic_83xx_check(adapter))\r\nqlcnic_83xx_free_mbx_intr(adapter);\r\nerr_out_disable_msi:\r\nqlcnic_teardown_intr(adapter);\r\nqlcnic_cancel_idc_work(adapter);\r\nqlcnic_clr_all_drv_state(adapter, 0);\r\nerr_out_free_hw:\r\nqlcnic_free_adapter_resources(adapter);\r\nerr_out_free_wq:\r\ndestroy_workqueue(adapter->qlcnic_wq);\r\nerr_out_free_netdev:\r\nfree_netdev(netdev);\r\nerr_out_iounmap:\r\nqlcnic_cleanup_pci_map(ahw);\r\nerr_out_free_hw_res:\r\nkfree(ahw);\r\nerr_out_free_res:\r\npci_release_regions(pdev);\r\nerr_out_disable_pdev:\r\npci_disable_device(pdev);\r\nreturn err;\r\nerr_out_maintenance_mode:\r\nset_bit(__QLCNIC_MAINTENANCE_MODE, &adapter->state);\r\nnetdev->netdev_ops = &qlcnic_netdev_failed_ops;\r\nnetdev->ethtool_ops = &qlcnic_ethtool_failed_ops;\r\nahw->port_type = QLCNIC_XGBE;\r\nif (qlcnic_83xx_check(adapter))\r\nadapter->tgt_status_reg = NULL;\r\nelse\r\nahw->board_type = QLCNIC_BRDTYPE_P3P_10G_SFP_PLUS;\r\nerr = register_netdev(netdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to register net device\n");\r\nqlcnic_clr_all_drv_state(adapter, 0);\r\ngoto err_out_free_hw;\r\n}\r\npci_set_drvdata(pdev, adapter);\r\nqlcnic_add_sysfs(adapter);\r\nreturn 0;\r\n}\r\nstatic void qlcnic_remove(struct pci_dev *pdev)\r\n{\r\nstruct qlcnic_adapter *adapter;\r\nstruct net_device *netdev;\r\nstruct qlcnic_hardware_context *ahw;\r\nadapter = pci_get_drvdata(pdev);\r\nif (adapter == NULL)\r\nreturn;\r\nnetdev = adapter->netdev;\r\nqlcnic_cancel_idc_work(adapter);\r\nqlcnic_sriov_pf_disable(adapter);\r\nahw = adapter->ahw;\r\nunregister_netdev(netdev);\r\nqlcnic_sriov_cleanup(adapter);\r\nif (qlcnic_83xx_check(adapter)) {\r\nqlcnic_83xx_initialize_nic(adapter, 0);\r\ncancel_delayed_work_sync(&adapter->idc_aen_work);\r\nqlcnic_83xx_free_mbx_intr(adapter);\r\nqlcnic_83xx_detach_mailbox_work(adapter);\r\nqlcnic_83xx_free_mailbox(ahw->mailbox);\r\nkfree(ahw->fw_info);\r\n}\r\nqlcnic_dcb_free(adapter->dcb);\r\nqlcnic_detach(adapter);\r\nkfree(adapter->npars);\r\nkfree(adapter->eswitch);\r\nif (qlcnic_82xx_check(adapter))\r\nqlcnic_clr_all_drv_state(adapter, 0);\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nqlcnic_free_lb_filters_mem(adapter);\r\nqlcnic_teardown_intr(adapter);\r\nqlcnic_remove_sysfs(adapter);\r\nqlcnic_unregister_hwmon_dev(adapter);\r\nqlcnic_cleanup_pci_map(adapter->ahw);\r\nqlcnic_release_firmware(adapter);\r\npci_disable_pcie_error_reporting(pdev);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nif (adapter->qlcnic_wq) {\r\ndestroy_workqueue(adapter->qlcnic_wq);\r\nadapter->qlcnic_wq = NULL;\r\n}\r\nqlcnic_free_adapter_resources(adapter);\r\nkfree(ahw);\r\nfree_netdev(netdev);\r\n}\r\nstatic void qlcnic_shutdown(struct pci_dev *pdev)\r\n{\r\nif (__qlcnic_shutdown(pdev))\r\nreturn;\r\npci_disable_device(pdev);\r\n}\r\nstatic int qlcnic_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nint retval;\r\nretval = __qlcnic_shutdown(pdev);\r\nif (retval)\r\nreturn retval;\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int qlcnic_resume(struct pci_dev *pdev)\r\n{\r\nstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\r\nint err;\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\nreturn err;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_set_master(pdev);\r\npci_restore_state(pdev);\r\nreturn __qlcnic_resume(adapter);\r\n}\r\nstatic int qlcnic_open(struct net_device *netdev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint err;\r\nif (test_bit(__QLCNIC_MAINTENANCE_MODE, &adapter->state)) {\r\nnetdev_err(netdev, "%s: Device is in non-operational state\n",\r\n__func__);\r\nreturn -EIO;\r\n}\r\nnetif_carrier_off(netdev);\r\nerr = qlcnic_attach(adapter);\r\nif (err)\r\nreturn err;\r\nerr = __qlcnic_up(adapter, netdev);\r\nif (err)\r\nqlcnic_detach(adapter);\r\nreturn err;\r\n}\r\nstatic int qlcnic_close(struct net_device *netdev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\n__qlcnic_down(adapter, netdev);\r\nreturn 0;\r\n}\r\nvoid qlcnic_alloc_lb_filters_mem(struct qlcnic_adapter *adapter)\r\n{\r\nvoid *head;\r\nint i;\r\nstruct net_device *netdev = adapter->netdev;\r\nu32 filter_size = 0;\r\nu16 act_pci_func = 0;\r\nif (adapter->fhash.fmax && adapter->fhash.fhead)\r\nreturn;\r\nact_pci_func = adapter->ahw->total_nic_func;\r\nspin_lock_init(&adapter->mac_learn_lock);\r\nspin_lock_init(&adapter->rx_mac_learn_lock);\r\nif (qlcnic_sriov_vf_check(adapter)) {\r\nfilter_size = QLCNIC_83XX_SRIOV_VF_MAX_MAC - 1;\r\nadapter->fhash.fbucket_size = QLCNIC_VF_LB_BUCKET_SIZE;\r\n} else if (qlcnic_82xx_check(adapter)) {\r\nfilter_size = QLCNIC_LB_MAX_FILTERS;\r\nadapter->fhash.fbucket_size = QLCNIC_LB_BUCKET_SIZE;\r\n} else {\r\nfilter_size = QLC_83XX_LB_MAX_FILTERS;\r\nadapter->fhash.fbucket_size = QLC_83XX_LB_BUCKET_SIZE;\r\n}\r\nhead = kcalloc(adapter->fhash.fbucket_size,\r\nsizeof(struct hlist_head), GFP_ATOMIC);\r\nif (!head)\r\nreturn;\r\nadapter->fhash.fmax = (filter_size / act_pci_func);\r\nadapter->fhash.fhead = head;\r\nnetdev_info(netdev, "active nic func = %d, mac filter size=%d\n",\r\nact_pci_func, adapter->fhash.fmax);\r\nfor (i = 0; i < adapter->fhash.fbucket_size; i++)\r\nINIT_HLIST_HEAD(&adapter->fhash.fhead[i]);\r\nadapter->rx_fhash.fbucket_size = adapter->fhash.fbucket_size;\r\nhead = kcalloc(adapter->rx_fhash.fbucket_size,\r\nsizeof(struct hlist_head), GFP_ATOMIC);\r\nif (!head)\r\nreturn;\r\nadapter->rx_fhash.fmax = (filter_size / act_pci_func);\r\nadapter->rx_fhash.fhead = head;\r\nfor (i = 0; i < adapter->rx_fhash.fbucket_size; i++)\r\nINIT_HLIST_HEAD(&adapter->rx_fhash.fhead[i]);\r\n}\r\nstatic void qlcnic_free_lb_filters_mem(struct qlcnic_adapter *adapter)\r\n{\r\nif (adapter->fhash.fmax)\r\nkfree(adapter->fhash.fhead);\r\nadapter->fhash.fhead = NULL;\r\nadapter->fhash.fmax = 0;\r\nif (adapter->rx_fhash.fmax)\r\nkfree(adapter->rx_fhash.fhead);\r\nadapter->rx_fhash.fmax = 0;\r\nadapter->rx_fhash.fhead = NULL;\r\n}\r\nint qlcnic_check_temp(struct qlcnic_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nu32 temp_state, temp_val, temp = 0;\r\nint rv = 0;\r\nif (qlcnic_83xx_check(adapter))\r\ntemp = QLCRDX(adapter->ahw, QLC_83XX_ASIC_TEMP);\r\nif (qlcnic_82xx_check(adapter))\r\ntemp = QLC_SHARED_REG_RD32(adapter, QLCNIC_ASIC_TEMP);\r\ntemp_state = qlcnic_get_temp_state(temp);\r\ntemp_val = qlcnic_get_temp_val(temp);\r\nif (temp_state == QLCNIC_TEMP_PANIC) {\r\ndev_err(&netdev->dev,\r\n"Device temperature %d degrees C exceeds"\r\n" maximum allowed. Hardware has been shut down.\n",\r\ntemp_val);\r\nrv = 1;\r\n} else if (temp_state == QLCNIC_TEMP_WARN) {\r\nif (adapter->ahw->temp == QLCNIC_TEMP_NORMAL) {\r\ndev_err(&netdev->dev,\r\n"Device temperature %d degrees C "\r\n"exceeds operating range."\r\n" Immediate action needed.\n",\r\ntemp_val);\r\n}\r\n} else {\r\nif (adapter->ahw->temp == QLCNIC_TEMP_WARN) {\r\ndev_info(&netdev->dev,\r\n"Device temperature is now %d degrees C"\r\n" in normal range.\n", temp_val);\r\n}\r\n}\r\nadapter->ahw->temp = temp_state;\r\nreturn rv;\r\n}\r\nstatic inline void dump_tx_ring_desc(struct qlcnic_host_tx_ring *tx_ring)\r\n{\r\nint i;\r\nstruct cmd_desc_type0 *tx_desc_info;\r\nfor (i = 0; i < tx_ring->num_desc; i++) {\r\ntx_desc_info = &tx_ring->desc_head[i];\r\npr_info("TX Desc: %d\n", i);\r\nprint_hex_dump(KERN_INFO, "TX: ", DUMP_PREFIX_OFFSET, 16, 1,\r\n&tx_ring->desc_head[i],\r\nsizeof(struct cmd_desc_type0), true);\r\n}\r\n}\r\nstatic void qlcnic_dump_rings(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\nint ring;\r\nif (!netdev || !netif_running(netdev))\r\nreturn;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nif (!rds_ring)\r\ncontinue;\r\nnetdev_info(netdev,\r\n"rds_ring=%d crb_rcv_producer=%d producer=%u num_desc=%u\n",\r\nring, readl(rds_ring->crb_rcv_producer),\r\nrds_ring->producer, rds_ring->num_desc);\r\n}\r\nfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\r\nsds_ring = &(recv_ctx->sds_rings[ring]);\r\nif (!sds_ring)\r\ncontinue;\r\nnetdev_info(netdev,\r\n"sds_ring=%d crb_sts_consumer=%d consumer=%u crb_intr_mask=%d num_desc=%u\n",\r\nring, readl(sds_ring->crb_sts_consumer),\r\nsds_ring->consumer, readl(sds_ring->crb_intr_mask),\r\nsds_ring->num_desc);\r\n}\r\nfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\r\ntx_ring = &adapter->tx_ring[ring];\r\nif (!tx_ring)\r\ncontinue;\r\nnetdev_info(netdev, "Tx ring=%d Context Id=0x%x\n",\r\nring, tx_ring->ctx_id);\r\nnetdev_info(netdev,\r\n"xmit_finished=%llu, xmit_called=%llu, xmit_on=%llu, xmit_off=%llu\n",\r\ntx_ring->tx_stats.xmit_finished,\r\ntx_ring->tx_stats.xmit_called,\r\ntx_ring->tx_stats.xmit_on,\r\ntx_ring->tx_stats.xmit_off);\r\nif (tx_ring->crb_intr_mask)\r\nnetdev_info(netdev, "crb_intr_mask=%d\n",\r\nreadl(tx_ring->crb_intr_mask));\r\nnetdev_info(netdev,\r\n"hw_producer=%d, sw_producer=%d sw_consumer=%d, hw_consumer=%d\n",\r\nreadl(tx_ring->crb_cmd_producer),\r\ntx_ring->producer, tx_ring->sw_consumer,\r\nle32_to_cpu(*(tx_ring->hw_consumer)));\r\nnetdev_info(netdev, "Total desc=%d, Available desc=%d\n",\r\ntx_ring->num_desc, qlcnic_tx_avail(tx_ring));\r\nif (netif_msg_tx_err(adapter->ahw))\r\ndump_tx_ring_desc(tx_ring);\r\n}\r\n}\r\nstatic void qlcnic_tx_timeout(struct net_device *netdev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state))\r\nreturn;\r\nqlcnic_dump_rings(adapter);\r\nif (++adapter->tx_timeo_cnt >= QLCNIC_MAX_TX_TIMEOUTS ||\r\nnetif_msg_tx_err(adapter->ahw)) {\r\nnetdev_err(netdev, "Tx timeout, reset the adapter.\n");\r\nif (qlcnic_82xx_check(adapter))\r\nadapter->need_fw_reset = 1;\r\nelse if (qlcnic_83xx_check(adapter))\r\nqlcnic_83xx_idc_request_reset(adapter,\r\nQLCNIC_FORCE_FW_DUMP_KEY);\r\n} else {\r\nnetdev_err(netdev, "Tx timeout, reset adapter context.\n");\r\nadapter->ahw->reset_context = 1;\r\n}\r\n}\r\nstatic struct net_device_stats *qlcnic_get_stats(struct net_device *netdev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct net_device_stats *stats = &netdev->stats;\r\nif (test_bit(__QLCNIC_DEV_UP, &adapter->state))\r\nqlcnic_update_stats(adapter);\r\nstats->rx_packets = adapter->stats.rx_pkts + adapter->stats.lro_pkts;\r\nstats->tx_packets = adapter->stats.xmitfinished;\r\nstats->rx_bytes = adapter->stats.rxbytes + adapter->stats.lrobytes;\r\nstats->tx_bytes = adapter->stats.txbytes;\r\nstats->rx_dropped = adapter->stats.rxdropped;\r\nstats->tx_dropped = adapter->stats.txdropped;\r\nreturn stats;\r\n}\r\nstatic irqreturn_t qlcnic_82xx_clear_legacy_intr(struct qlcnic_adapter *adapter)\r\n{\r\nu32 status;\r\nstatus = readl(adapter->isr_int_vec);\r\nif (!(status & adapter->ahw->int_vec_bit))\r\nreturn IRQ_NONE;\r\nstatus = readl(adapter->crb_int_state_reg);\r\nif (!ISR_LEGACY_INT_TRIGGERED(status))\r\nreturn IRQ_NONE;\r\nwritel(0xffffffff, adapter->tgt_status_reg);\r\nreadl(adapter->isr_int_vec);\r\nreadl(adapter->isr_int_vec);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t qlcnic_tmp_intr(int irq, void *data)\r\n{\r\nstruct qlcnic_host_sds_ring *sds_ring = data;\r\nstruct qlcnic_adapter *adapter = sds_ring->adapter;\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED)\r\ngoto done;\r\nelse if (adapter->flags & QLCNIC_MSI_ENABLED) {\r\nwritel(0xffffffff, adapter->tgt_status_reg);\r\ngoto done;\r\n}\r\nif (qlcnic_clear_legacy_intr(adapter) == IRQ_NONE)\r\nreturn IRQ_NONE;\r\ndone:\r\nadapter->ahw->diag_cnt++;\r\nqlcnic_enable_sds_intr(adapter, sds_ring);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t qlcnic_intr(int irq, void *data)\r\n{\r\nstruct qlcnic_host_sds_ring *sds_ring = data;\r\nstruct qlcnic_adapter *adapter = sds_ring->adapter;\r\nif (qlcnic_clear_legacy_intr(adapter) == IRQ_NONE)\r\nreturn IRQ_NONE;\r\nnapi_schedule(&sds_ring->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t qlcnic_msi_intr(int irq, void *data)\r\n{\r\nstruct qlcnic_host_sds_ring *sds_ring = data;\r\nstruct qlcnic_adapter *adapter = sds_ring->adapter;\r\nwritel(0xffffffff, adapter->tgt_status_reg);\r\nnapi_schedule(&sds_ring->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t qlcnic_msix_intr(int irq, void *data)\r\n{\r\nstruct qlcnic_host_sds_ring *sds_ring = data;\r\nnapi_schedule(&sds_ring->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t qlcnic_msix_tx_intr(int irq, void *data)\r\n{\r\nstruct qlcnic_host_tx_ring *tx_ring = data;\r\nnapi_schedule(&tx_ring->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void qlcnic_poll_controller(struct net_device *netdev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_recv_context *recv_ctx;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\nint ring;\r\nif (!test_bit(__QLCNIC_DEV_UP, &adapter->state))\r\nreturn;\r\nrecv_ctx = adapter->recv_ctx;\r\nfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nqlcnic_disable_sds_intr(adapter, sds_ring);\r\nnapi_schedule(&sds_ring->napi);\r\n}\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED) {\r\nif ((qlcnic_83xx_check(adapter) &&\r\n(adapter->flags & QLCNIC_TX_INTR_SHARED)) ||\r\n(qlcnic_82xx_check(adapter) &&\r\n!qlcnic_check_multi_tx(adapter)))\r\nreturn;\r\nfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\r\ntx_ring = &adapter->tx_ring[ring];\r\nqlcnic_disable_tx_intr(adapter, tx_ring);\r\nnapi_schedule(&tx_ring->napi);\r\n}\r\n}\r\n}\r\nstatic void\r\nqlcnic_idc_debug_info(struct qlcnic_adapter *adapter, u8 encoding)\r\n{\r\nu32 val;\r\nval = adapter->portnum & 0xf;\r\nval |= encoding << 7;\r\nval |= (jiffies - adapter->dev_rst_time) << 8;\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_SCRATCH, val);\r\nadapter->dev_rst_time = jiffies;\r\n}\r\nstatic int\r\nqlcnic_set_drv_state(struct qlcnic_adapter *adapter, u8 state)\r\n{\r\nu32 val;\r\nWARN_ON(state != QLCNIC_DEV_NEED_RESET &&\r\nstate != QLCNIC_DEV_NEED_QUISCENT);\r\nif (qlcnic_api_lock(adapter))\r\nreturn -EIO;\r\nval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_STATE);\r\nif (state == QLCNIC_DEV_NEED_RESET)\r\nQLC_DEV_SET_RST_RDY(val, adapter->portnum);\r\nelse if (state == QLCNIC_DEV_NEED_QUISCENT)\r\nQLC_DEV_SET_QSCNT_RDY(val, adapter->portnum);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_STATE, val);\r\nqlcnic_api_unlock(adapter);\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_clr_drv_state(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val;\r\nif (qlcnic_api_lock(adapter))\r\nreturn -EBUSY;\r\nval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_STATE);\r\nQLC_DEV_CLR_RST_QSCNT(val, adapter->portnum);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_STATE, val);\r\nqlcnic_api_unlock(adapter);\r\nreturn 0;\r\n}\r\nvoid qlcnic_clr_all_drv_state(struct qlcnic_adapter *adapter, u8 failed)\r\n{\r\nu32 val;\r\nif (qlcnic_api_lock(adapter))\r\ngoto err;\r\nval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_ACTIVE);\r\nQLC_DEV_CLR_REF_CNT(val, adapter->portnum);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_ACTIVE, val);\r\nif (failed) {\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE,\r\nQLCNIC_DEV_FAILED);\r\ndev_info(&adapter->pdev->dev,\r\n"Device state set to Failed. Please Reboot\n");\r\n} else if (!(val & 0x11111111))\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE,\r\nQLCNIC_DEV_COLD);\r\nval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_STATE);\r\nQLC_DEV_CLR_RST_QSCNT(val, adapter->portnum);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_STATE, val);\r\nqlcnic_api_unlock(adapter);\r\nerr:\r\nadapter->fw_fail_cnt = 0;\r\nadapter->flags &= ~QLCNIC_FW_HANG;\r\nclear_bit(__QLCNIC_START_FW, &adapter->state);\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\n}\r\nstatic int\r\nqlcnic_check_drv_state(struct qlcnic_adapter *adapter)\r\n{\r\nint act, state, active_mask;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstate = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_STATE);\r\nact = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_ACTIVE);\r\nif (adapter->flags & QLCNIC_FW_RESET_OWNER) {\r\nactive_mask = (~(1 << (ahw->pci_func * 4)));\r\nact = act & active_mask;\r\n}\r\nif (((state & 0x11111111) == (act & 0x11111111)) ||\r\n((act & 0x11111111) == ((state >> 1) & 0x11111111)))\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int qlcnic_check_idc_ver(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_IDC_VER);\r\nif (val != QLCNIC_DRV_IDC_VER) {\r\ndev_warn(&adapter->pdev->dev, "IDC Version mismatch, driver's"\r\n" idc ver = %x; reqd = %x\n", QLCNIC_DRV_IDC_VER, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_can_start_firmware(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val, prev_state;\r\nu8 dev_init_timeo = adapter->dev_init_timeo;\r\nu8 portnum = adapter->portnum;\r\nu8 ret;\r\nif (test_and_clear_bit(__QLCNIC_START_FW, &adapter->state))\r\nreturn 1;\r\nif (qlcnic_api_lock(adapter))\r\nreturn -1;\r\nval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_ACTIVE);\r\nif (!(val & (1 << (portnum * 4)))) {\r\nQLC_DEV_SET_REF_CNT(val, portnum);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_ACTIVE, val);\r\n}\r\nprev_state = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\r\nQLCDB(adapter, HW, "Device state = %u\n", prev_state);\r\nswitch (prev_state) {\r\ncase QLCNIC_DEV_COLD:\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE,\r\nQLCNIC_DEV_INITIALIZING);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_IDC_VER,\r\nQLCNIC_DRV_IDC_VER);\r\nqlcnic_idc_debug_info(adapter, 0);\r\nqlcnic_api_unlock(adapter);\r\nreturn 1;\r\ncase QLCNIC_DEV_READY:\r\nret = qlcnic_check_idc_ver(adapter);\r\nqlcnic_api_unlock(adapter);\r\nreturn ret;\r\ncase QLCNIC_DEV_NEED_RESET:\r\nval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_STATE);\r\nQLC_DEV_SET_RST_RDY(val, portnum);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_STATE, val);\r\nbreak;\r\ncase QLCNIC_DEV_NEED_QUISCENT:\r\nval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_STATE);\r\nQLC_DEV_SET_QSCNT_RDY(val, portnum);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_STATE, val);\r\nbreak;\r\ncase QLCNIC_DEV_FAILED:\r\ndev_err(&adapter->pdev->dev, "Device in failed state.\n");\r\nqlcnic_api_unlock(adapter);\r\nreturn -1;\r\ncase QLCNIC_DEV_INITIALIZING:\r\ncase QLCNIC_DEV_QUISCENT:\r\nbreak;\r\n}\r\nqlcnic_api_unlock(adapter);\r\ndo {\r\nmsleep(1000);\r\nprev_state = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\r\nif (prev_state == QLCNIC_DEV_QUISCENT)\r\ncontinue;\r\n} while ((prev_state != QLCNIC_DEV_READY) && --dev_init_timeo);\r\nif (!dev_init_timeo) {\r\ndev_err(&adapter->pdev->dev,\r\n"Waiting for device to initialize timeout\n");\r\nreturn -1;\r\n}\r\nif (qlcnic_api_lock(adapter))\r\nreturn -1;\r\nval = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DRV_STATE);\r\nQLC_DEV_CLR_RST_QSCNT(val, portnum);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DRV_STATE, val);\r\nret = qlcnic_check_idc_ver(adapter);\r\nqlcnic_api_unlock(adapter);\r\nreturn ret;\r\n}\r\nstatic void\r\nqlcnic_fwinit_work(struct work_struct *work)\r\n{\r\nstruct qlcnic_adapter *adapter = container_of(work,\r\nstruct qlcnic_adapter, fw_work.work);\r\nu32 dev_state = 0xf;\r\nu32 val;\r\nif (qlcnic_api_lock(adapter))\r\ngoto err_ret;\r\ndev_state = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\r\nif (dev_state == QLCNIC_DEV_QUISCENT ||\r\ndev_state == QLCNIC_DEV_NEED_QUISCENT) {\r\nqlcnic_api_unlock(adapter);\r\nqlcnic_schedule_work(adapter, qlcnic_fwinit_work,\r\nFW_POLL_DELAY * 2);\r\nreturn;\r\n}\r\nif (adapter->ahw->op_mode == QLCNIC_NON_PRIV_FUNC) {\r\nqlcnic_api_unlock(adapter);\r\ngoto wait_npar;\r\n}\r\nif (dev_state == QLCNIC_DEV_INITIALIZING ||\r\ndev_state == QLCNIC_DEV_READY) {\r\ndev_info(&adapter->pdev->dev, "Detected state change from "\r\n"DEV_NEED_RESET, skipping ack check\n");\r\ngoto skip_ack_check;\r\n}\r\nif (adapter->fw_wait_cnt++ > adapter->reset_ack_timeo) {\r\ndev_info(&adapter->pdev->dev, "Reset:Failed to get ack %d sec\n",\r\nadapter->reset_ack_timeo);\r\ngoto skip_ack_check;\r\n}\r\nif (!qlcnic_check_drv_state(adapter)) {\r\nskip_ack_check:\r\ndev_state = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\r\nif (dev_state == QLCNIC_DEV_NEED_RESET) {\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE,\r\nQLCNIC_DEV_INITIALIZING);\r\nset_bit(__QLCNIC_START_FW, &adapter->state);\r\nQLCDB(adapter, DRV, "Restarting fw\n");\r\nqlcnic_idc_debug_info(adapter, 0);\r\nval = QLC_SHARED_REG_RD32(adapter,\r\nQLCNIC_CRB_DRV_STATE);\r\nQLC_DEV_SET_RST_RDY(val, adapter->portnum);\r\nQLC_SHARED_REG_WR32(adapter,\r\nQLCNIC_CRB_DRV_STATE, val);\r\n}\r\nqlcnic_api_unlock(adapter);\r\nrtnl_lock();\r\nif (qlcnic_check_fw_dump_state(adapter) &&\r\n(adapter->flags & QLCNIC_FW_RESET_OWNER)) {\r\nQLCDB(adapter, DRV, "Take FW dump\n");\r\nqlcnic_dump_fw(adapter);\r\nadapter->flags |= QLCNIC_FW_HANG;\r\n}\r\nrtnl_unlock();\r\nadapter->flags &= ~QLCNIC_FW_RESET_OWNER;\r\nif (!adapter->nic_ops->start_firmware(adapter)) {\r\nqlcnic_schedule_work(adapter, qlcnic_attach_work, 0);\r\nadapter->fw_wait_cnt = 0;\r\nreturn;\r\n}\r\ngoto err_ret;\r\n}\r\nqlcnic_api_unlock(adapter);\r\nwait_npar:\r\ndev_state = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\r\nQLCDB(adapter, HW, "Func waiting: Device state=%u\n", dev_state);\r\nswitch (dev_state) {\r\ncase QLCNIC_DEV_READY:\r\nif (!qlcnic_start_firmware(adapter)) {\r\nqlcnic_schedule_work(adapter, qlcnic_attach_work, 0);\r\nadapter->fw_wait_cnt = 0;\r\nreturn;\r\n}\r\ncase QLCNIC_DEV_FAILED:\r\nbreak;\r\ndefault:\r\nqlcnic_schedule_work(adapter,\r\nqlcnic_fwinit_work, FW_POLL_DELAY);\r\nreturn;\r\n}\r\nerr_ret:\r\ndev_err(&adapter->pdev->dev, "Fwinit work failed state=%u "\r\n"fw_wait_cnt=%u\n", dev_state, adapter->fw_wait_cnt);\r\nnetif_device_attach(adapter->netdev);\r\nqlcnic_clr_all_drv_state(adapter, 0);\r\n}\r\nstatic void\r\nqlcnic_detach_work(struct work_struct *work)\r\n{\r\nstruct qlcnic_adapter *adapter = container_of(work,\r\nstruct qlcnic_adapter, fw_work.work);\r\nstruct net_device *netdev = adapter->netdev;\r\nu32 status;\r\nnetif_device_detach(netdev);\r\nif (adapter->dev_state == QLCNIC_DEV_NEED_QUISCENT) {\r\nif (netif_running(netdev))\r\n__qlcnic_down(adapter, netdev);\r\n} else\r\nqlcnic_down(adapter, netdev);\r\nstatus = QLC_SHARED_REG_RD32(adapter, QLCNIC_PEG_HALT_STATUS1);\r\nif (status & QLCNIC_RCODE_FATAL_ERROR) {\r\ndev_err(&adapter->pdev->dev,\r\n"Detaching the device: peg halt status1=0x%x\n",\r\nstatus);\r\nif (QLCNIC_FWERROR_CODE(status) == QLCNIC_FWERROR_FAN_FAILURE) {\r\ndev_err(&adapter->pdev->dev,\r\n"On board active cooling fan failed. "\r\n"Device has been halted.\n");\r\ndev_err(&adapter->pdev->dev,\r\n"Replace the adapter.\n");\r\n}\r\ngoto err_ret;\r\n}\r\nif (adapter->ahw->temp == QLCNIC_TEMP_PANIC) {\r\ndev_err(&adapter->pdev->dev, "Detaching the device: temp=%d\n",\r\nadapter->ahw->temp);\r\ngoto err_ret;\r\n}\r\nif (!(adapter->flags & QLCNIC_FW_RESET_OWNER)) {\r\nif (qlcnic_set_drv_state(adapter, adapter->dev_state)) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to set driver state,"\r\n"detaching the device.\n");\r\ngoto err_ret;\r\n}\r\n}\r\nadapter->fw_wait_cnt = 0;\r\nqlcnic_schedule_work(adapter, qlcnic_fwinit_work, FW_POLL_DELAY);\r\nreturn;\r\nerr_ret:\r\nnetif_device_attach(netdev);\r\nqlcnic_clr_all_drv_state(adapter, 1);\r\n}\r\nstatic void\r\nqlcnic_set_npar_non_operational(struct qlcnic_adapter *adapter)\r\n{\r\nu32 state;\r\nstate = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_NPAR_STATE);\r\nif (state == QLCNIC_DEV_NPAR_NON_OPER)\r\nreturn;\r\nif (qlcnic_api_lock(adapter))\r\nreturn;\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_NPAR_STATE,\r\nQLCNIC_DEV_NPAR_NON_OPER);\r\nqlcnic_api_unlock(adapter);\r\n}\r\nstatic void qlcnic_82xx_dev_request_reset(struct qlcnic_adapter *adapter,\r\nu32 key)\r\n{\r\nu32 state, xg_val = 0, gb_val = 0;\r\nqlcnic_xg_set_xg0_mask(xg_val);\r\nqlcnic_xg_set_xg1_mask(xg_val);\r\nQLCWR32(adapter, QLCNIC_NIU_XG_PAUSE_CTL, xg_val);\r\nqlcnic_gb_set_gb0_mask(gb_val);\r\nqlcnic_gb_set_gb1_mask(gb_val);\r\nqlcnic_gb_set_gb2_mask(gb_val);\r\nqlcnic_gb_set_gb3_mask(gb_val);\r\nQLCWR32(adapter, QLCNIC_NIU_GB_PAUSE_CTL, gb_val);\r\ndev_info(&adapter->pdev->dev, "Pause control frames disabled"\r\n" on all ports\n");\r\nadapter->need_fw_reset = 1;\r\nif (qlcnic_api_lock(adapter))\r\nreturn;\r\nstate = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\r\nif (test_bit(__QLCNIC_MAINTENANCE_MODE, &adapter->state)) {\r\nnetdev_err(adapter->netdev, "%s: Device is in non-operational state\n",\r\n__func__);\r\nqlcnic_api_unlock(adapter);\r\nreturn;\r\n}\r\nif (state == QLCNIC_DEV_READY) {\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE,\r\nQLCNIC_DEV_NEED_RESET);\r\nadapter->flags |= QLCNIC_FW_RESET_OWNER;\r\nQLCDB(adapter, DRV, "NEED_RESET state set\n");\r\nqlcnic_idc_debug_info(adapter, 0);\r\n}\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_NPAR_STATE,\r\nQLCNIC_DEV_NPAR_NON_OPER);\r\nqlcnic_api_unlock(adapter);\r\n}\r\nstatic void\r\nqlcnic_dev_set_npar_ready(struct qlcnic_adapter *adapter)\r\n{\r\nif (qlcnic_api_lock(adapter))\r\nreturn;\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_NPAR_STATE,\r\nQLCNIC_DEV_NPAR_OPER);\r\nQLCDB(adapter, DRV, "NPAR operational state set\n");\r\nqlcnic_api_unlock(adapter);\r\n}\r\nvoid qlcnic_schedule_work(struct qlcnic_adapter *adapter,\r\nwork_func_t func, int delay)\r\n{\r\nif (test_bit(__QLCNIC_AER, &adapter->state))\r\nreturn;\r\nINIT_DELAYED_WORK(&adapter->fw_work, func);\r\nqueue_delayed_work(adapter->qlcnic_wq, &adapter->fw_work,\r\nround_jiffies_relative(delay));\r\n}\r\nstatic void\r\nqlcnic_attach_work(struct work_struct *work)\r\n{\r\nstruct qlcnic_adapter *adapter = container_of(work,\r\nstruct qlcnic_adapter, fw_work.work);\r\nstruct net_device *netdev = adapter->netdev;\r\nu32 npar_state;\r\nif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC) {\r\nnpar_state = QLC_SHARED_REG_RD32(adapter,\r\nQLCNIC_CRB_DEV_NPAR_STATE);\r\nif (adapter->fw_wait_cnt++ > QLCNIC_DEV_NPAR_OPER_TIMEO)\r\nqlcnic_clr_all_drv_state(adapter, 0);\r\nelse if (npar_state != QLCNIC_DEV_NPAR_OPER)\r\nqlcnic_schedule_work(adapter, qlcnic_attach_work,\r\nFW_POLL_DELAY);\r\nelse\r\ngoto attach;\r\nQLCDB(adapter, DRV, "Waiting for NPAR state to operational\n");\r\nreturn;\r\n}\r\nattach:\r\nqlcnic_dcb_get_info(adapter->dcb);\r\nif (netif_running(netdev)) {\r\nif (qlcnic_up(adapter, netdev))\r\ngoto done;\r\nqlcnic_restore_indev_addr(netdev, NETDEV_UP);\r\n}\r\ndone:\r\nnetif_device_attach(netdev);\r\nadapter->fw_fail_cnt = 0;\r\nadapter->flags &= ~QLCNIC_FW_HANG;\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nif (adapter->portnum == 0)\r\nqlcnic_set_drv_version(adapter);\r\nif (!qlcnic_clr_drv_state(adapter))\r\nqlcnic_schedule_work(adapter, qlcnic_fw_poll_work,\r\nFW_POLL_DELAY);\r\n}\r\nstatic int\r\nqlcnic_check_health(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_fw_dump *fw_dump = &ahw->fw_dump;\r\nu32 state = 0, heartbeat;\r\nu32 peg_status;\r\nint err = 0;\r\nif (qlcnic_check_temp(adapter))\r\ngoto detach;\r\nif (adapter->need_fw_reset)\r\nqlcnic_dev_request_reset(adapter, 0);\r\nstate = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\r\nif (state == QLCNIC_DEV_NEED_RESET) {\r\nqlcnic_set_npar_non_operational(adapter);\r\nadapter->need_fw_reset = 1;\r\n} else if (state == QLCNIC_DEV_NEED_QUISCENT)\r\ngoto detach;\r\nheartbeat = QLC_SHARED_REG_RD32(adapter, QLCNIC_PEG_ALIVE_COUNTER);\r\nif (heartbeat != adapter->heartbeat) {\r\nadapter->heartbeat = heartbeat;\r\nadapter->fw_fail_cnt = 0;\r\nif (adapter->need_fw_reset)\r\ngoto detach;\r\nif (ahw->reset_context && qlcnic_auto_fw_reset)\r\nqlcnic_reset_hw_context(adapter);\r\nreturn 0;\r\n}\r\nif (++adapter->fw_fail_cnt < FW_FAIL_THRESH)\r\nreturn 0;\r\nadapter->flags |= QLCNIC_FW_HANG;\r\nqlcnic_dev_request_reset(adapter, 0);\r\nif (qlcnic_auto_fw_reset)\r\nclear_bit(__QLCNIC_FW_ATTACHED, &adapter->state);\r\ndev_err(&adapter->pdev->dev, "firmware hang detected\n");\r\npeg_status = QLC_SHARED_REG_RD32(adapter, QLCNIC_PEG_HALT_STATUS1);\r\ndev_err(&adapter->pdev->dev, "Dumping hw/fw registers\n"\r\n"PEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,\n"\r\n"PEG_NET_0_PC: 0x%x, PEG_NET_1_PC: 0x%x,\n"\r\n"PEG_NET_2_PC: 0x%x, PEG_NET_3_PC: 0x%x,\n"\r\n"PEG_NET_4_PC: 0x%x\n",\r\npeg_status,\r\nQLC_SHARED_REG_RD32(adapter, QLCNIC_PEG_HALT_STATUS2),\r\nQLCRD32(adapter, QLCNIC_CRB_PEG_NET_0 + 0x3c, &err),\r\nQLCRD32(adapter, QLCNIC_CRB_PEG_NET_1 + 0x3c, &err),\r\nQLCRD32(adapter, QLCNIC_CRB_PEG_NET_2 + 0x3c, &err),\r\nQLCRD32(adapter, QLCNIC_CRB_PEG_NET_3 + 0x3c, &err),\r\nQLCRD32(adapter, QLCNIC_CRB_PEG_NET_4 + 0x3c, &err));\r\nif (QLCNIC_FWERROR_CODE(peg_status) == 0x67)\r\ndev_err(&adapter->pdev->dev,\r\n"Firmware aborted with error code 0x00006700. "\r\n"Device is being reset.\n");\r\ndetach:\r\nadapter->dev_state = (state == QLCNIC_DEV_NEED_QUISCENT) ? state :\r\nQLCNIC_DEV_NEED_RESET;\r\nif (qlcnic_auto_fw_reset && !test_and_set_bit(__QLCNIC_RESETTING,\r\n&adapter->state)) {\r\nqlcnic_schedule_work(adapter, qlcnic_detach_work, 0);\r\nQLCDB(adapter, DRV, "fw recovery scheduled.\n");\r\n} else if (!qlcnic_auto_fw_reset && fw_dump->enable &&\r\nadapter->flags & QLCNIC_FW_RESET_OWNER) {\r\nqlcnic_dump_fw(adapter);\r\n}\r\nreturn 1;\r\n}\r\nvoid qlcnic_fw_poll_work(struct work_struct *work)\r\n{\r\nstruct qlcnic_adapter *adapter = container_of(work,\r\nstruct qlcnic_adapter, fw_work.work);\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state))\r\ngoto reschedule;\r\nif (qlcnic_check_health(adapter))\r\nreturn;\r\nif (adapter->fhash.fnum)\r\nqlcnic_prune_lb_filters(adapter);\r\nreschedule:\r\nqlcnic_schedule_work(adapter, qlcnic_fw_poll_work, FW_POLL_DELAY);\r\n}\r\nstatic int qlcnic_is_first_func(struct pci_dev *pdev)\r\n{\r\nstruct pci_dev *oth_pdev;\r\nint val = pdev->devfn;\r\nwhile (val-- > 0) {\r\noth_pdev = pci_get_domain_bus_and_slot(pci_domain_nr\r\n(pdev->bus), pdev->bus->number,\r\nPCI_DEVFN(PCI_SLOT(pdev->devfn), val));\r\nif (!oth_pdev)\r\ncontinue;\r\nif (oth_pdev->current_state != PCI_D3cold) {\r\npci_dev_put(oth_pdev);\r\nreturn 0;\r\n}\r\npci_dev_put(oth_pdev);\r\n}\r\nreturn 1;\r\n}\r\nstatic int qlcnic_attach_func(struct pci_dev *pdev)\r\n{\r\nint err, first_func;\r\nstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\r\nstruct net_device *netdev = adapter->netdev;\r\npdev->error_state = pci_channel_io_normal;\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\nreturn err;\r\npci_set_master(pdev);\r\npci_restore_state(pdev);\r\nfirst_func = qlcnic_is_first_func(pdev);\r\nif (qlcnic_api_lock(adapter))\r\nreturn -EINVAL;\r\nif (adapter->ahw->op_mode != QLCNIC_NON_PRIV_FUNC && first_func) {\r\nadapter->need_fw_reset = 1;\r\nset_bit(__QLCNIC_START_FW, &adapter->state);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_CRB_DEV_STATE,\r\nQLCNIC_DEV_INITIALIZING);\r\nQLCDB(adapter, DRV, "Restarting fw\n");\r\n}\r\nqlcnic_api_unlock(adapter);\r\nerr = qlcnic_start_firmware(adapter);\r\nif (err)\r\nreturn err;\r\nqlcnic_clr_drv_state(adapter);\r\nkfree(adapter->msix_entries);\r\nadapter->msix_entries = NULL;\r\nerr = qlcnic_setup_intr(adapter);\r\nif (err) {\r\nkfree(adapter->msix_entries);\r\nnetdev_err(netdev, "failed to setup interrupt\n");\r\nreturn err;\r\n}\r\nif (netif_running(netdev)) {\r\nerr = qlcnic_attach(adapter);\r\nif (err) {\r\nqlcnic_clr_all_drv_state(adapter, 1);\r\nclear_bit(__QLCNIC_AER, &adapter->state);\r\nnetif_device_attach(netdev);\r\nreturn err;\r\n}\r\nerr = qlcnic_up(adapter, netdev);\r\nif (err)\r\ngoto done;\r\nqlcnic_restore_indev_addr(netdev, NETDEV_UP);\r\n}\r\ndone:\r\nnetif_device_attach(netdev);\r\nreturn err;\r\n}\r\nstatic pci_ers_result_t qlcnic_82xx_io_error_detected(struct pci_dev *pdev,\r\npci_channel_state_t state)\r\n{\r\nstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\r\nstruct net_device *netdev = adapter->netdev;\r\nif (state == pci_channel_io_perm_failure)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\nif (state == pci_channel_io_normal)\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\nset_bit(__QLCNIC_AER, &adapter->state);\r\nnetif_device_detach(netdev);\r\ncancel_delayed_work_sync(&adapter->fw_work);\r\nif (netif_running(netdev))\r\nqlcnic_down(adapter, netdev);\r\nqlcnic_detach(adapter);\r\nqlcnic_teardown_intr(adapter);\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t qlcnic_82xx_io_slot_reset(struct pci_dev *pdev)\r\n{\r\npci_ers_result_t res;\r\nrtnl_lock();\r\nres = qlcnic_attach_func(pdev) ? PCI_ERS_RESULT_DISCONNECT :\r\nPCI_ERS_RESULT_RECOVERED;\r\nrtnl_unlock();\r\nreturn res;\r\n}\r\nstatic void qlcnic_82xx_io_resume(struct pci_dev *pdev)\r\n{\r\nu32 state;\r\nstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\r\npci_cleanup_aer_uncorrect_error_status(pdev);\r\nstate = QLC_SHARED_REG_RD32(adapter, QLCNIC_CRB_DEV_STATE);\r\nif (state == QLCNIC_DEV_READY && test_and_clear_bit(__QLCNIC_AER,\r\n&adapter->state))\r\nqlcnic_schedule_work(adapter, qlcnic_fw_poll_work,\r\nFW_POLL_DELAY);\r\n}\r\nstatic pci_ers_result_t qlcnic_io_error_detected(struct pci_dev *pdev,\r\npci_channel_state_t state)\r\n{\r\nstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\r\nstruct qlcnic_hardware_ops *hw_ops = adapter->ahw->hw_ops;\r\nif (hw_ops->io_error_detected) {\r\nreturn hw_ops->io_error_detected(pdev, state);\r\n} else {\r\ndev_err(&pdev->dev, "AER error_detected handler not registered.\n");\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\n}\r\nstatic pci_ers_result_t qlcnic_io_slot_reset(struct pci_dev *pdev)\r\n{\r\nstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\r\nstruct qlcnic_hardware_ops *hw_ops = adapter->ahw->hw_ops;\r\nif (hw_ops->io_slot_reset) {\r\nreturn hw_ops->io_slot_reset(pdev);\r\n} else {\r\ndev_err(&pdev->dev, "AER slot_reset handler not registered.\n");\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\n}\r\nstatic void qlcnic_io_resume(struct pci_dev *pdev)\r\n{\r\nstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\r\nstruct qlcnic_hardware_ops *hw_ops = adapter->ahw->hw_ops;\r\nif (hw_ops->io_resume)\r\nhw_ops->io_resume(pdev);\r\nelse\r\ndev_err(&pdev->dev, "AER resume handler not registered.\n");\r\n}\r\nstatic int\r\nqlcnicvf_start_firmware(struct qlcnic_adapter *adapter)\r\n{\r\nint err;\r\nerr = qlcnic_can_start_firmware(adapter);\r\nif (err)\r\nreturn err;\r\nerr = qlcnic_check_npar_opertional(adapter);\r\nif (err)\r\nreturn err;\r\nerr = qlcnic_initialize_nic(adapter);\r\nif (err)\r\nreturn err;\r\nqlcnic_check_options(adapter);\r\nerr = qlcnic_set_eswitch_port_config(adapter);\r\nif (err)\r\nreturn err;\r\nadapter->need_fw_reset = 0;\r\nreturn err;\r\n}\r\nint qlcnic_validate_rings(struct qlcnic_adapter *adapter, __u32 ring_cnt,\r\nint queue_type)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nu8 max_hw_rings = 0;\r\nchar buf[8];\r\nint cur_rings;\r\nif (queue_type == QLCNIC_RX_QUEUE) {\r\nmax_hw_rings = adapter->max_sds_rings;\r\ncur_rings = adapter->drv_sds_rings;\r\nstrcpy(buf, "SDS");\r\n} else if (queue_type == QLCNIC_TX_QUEUE) {\r\nmax_hw_rings = adapter->max_tx_rings;\r\ncur_rings = adapter->drv_tx_rings;\r\nstrcpy(buf, "Tx");\r\n}\r\nif (!is_power_of_2(ring_cnt)) {\r\nnetdev_err(netdev, "%s rings value should be a power of 2\n",\r\nbuf);\r\nreturn -EINVAL;\r\n}\r\nif (qlcnic_82xx_check(adapter) && (queue_type == QLCNIC_TX_QUEUE) &&\r\n!qlcnic_check_multi_tx(adapter)) {\r\nnetdev_err(netdev, "No Multi Tx queue support\n");\r\nreturn -EINVAL;\r\n}\r\nif (ring_cnt > num_online_cpus()) {\r\nnetdev_err(netdev,\r\n"%s value[%u] should not be higher than, number of online CPUs\n",\r\nbuf, num_online_cpus());\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint qlcnic_setup_rings(struct qlcnic_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nu8 tx_rings, rx_rings;\r\nint err;\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state))\r\nreturn -EBUSY;\r\ntx_rings = adapter->drv_tss_rings;\r\nrx_rings = adapter->drv_rss_rings;\r\nnetif_device_detach(netdev);\r\nerr = qlcnic_set_real_num_queues(adapter, tx_rings, rx_rings);\r\nif (err)\r\ngoto done;\r\nif (netif_running(netdev))\r\n__qlcnic_down(adapter, netdev);\r\nqlcnic_detach(adapter);\r\nif (qlcnic_83xx_check(adapter)) {\r\nqlcnic_83xx_free_mbx_intr(adapter);\r\nqlcnic_83xx_enable_mbx_poll(adapter);\r\n}\r\nqlcnic_teardown_intr(adapter);\r\nerr = qlcnic_setup_intr(adapter);\r\nif (err) {\r\nkfree(adapter->msix_entries);\r\nnetdev_err(netdev, "failed to setup interrupt\n");\r\nreturn err;\r\n}\r\nif ((tx_rings != adapter->drv_tx_rings) ||\r\n(rx_rings != adapter->drv_sds_rings)) {\r\nerr = qlcnic_set_real_num_queues(adapter,\r\nadapter->drv_tx_rings,\r\nadapter->drv_sds_rings);\r\nif (err)\r\ngoto done;\r\n}\r\nif (qlcnic_83xx_check(adapter)) {\r\nqlcnic_83xx_initialize_nic(adapter, 1);\r\nerr = qlcnic_83xx_setup_mbx_intr(adapter);\r\nqlcnic_83xx_disable_mbx_poll(adapter);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"failed to setup mbx interrupt\n");\r\ngoto done;\r\n}\r\n}\r\nif (netif_running(netdev)) {\r\nerr = qlcnic_attach(adapter);\r\nif (err)\r\ngoto done;\r\nerr = __qlcnic_up(adapter, netdev);\r\nif (err)\r\ngoto done;\r\nqlcnic_restore_indev_addr(netdev, NETDEV_UP);\r\n}\r\ndone:\r\nnetif_device_attach(netdev);\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nreturn err;\r\n}\r\nstatic void\r\nqlcnic_config_indev_addr(struct qlcnic_adapter *adapter,\r\nstruct net_device *dev, unsigned long event)\r\n{\r\nstruct in_device *indev;\r\nindev = in_dev_get(dev);\r\nif (!indev)\r\nreturn;\r\nfor_ifa(indev) {\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nqlcnic_config_ipaddr(adapter,\r\nifa->ifa_address, QLCNIC_IP_UP);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nqlcnic_config_ipaddr(adapter,\r\nifa->ifa_address, QLCNIC_IP_DOWN);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} endfor_ifa(indev);\r\nin_dev_put(indev);\r\n}\r\nvoid qlcnic_restore_indev_addr(struct net_device *netdev, unsigned long event)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct net_device *dev;\r\nu16 vid;\r\nqlcnic_config_indev_addr(adapter, netdev, event);\r\nrcu_read_lock();\r\nfor_each_set_bit(vid, adapter->vlans, VLAN_N_VID) {\r\ndev = __vlan_find_dev_deep_rcu(netdev, htons(ETH_P_8021Q), vid);\r\nif (!dev)\r\ncontinue;\r\nqlcnic_config_indev_addr(adapter, dev, event);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int qlcnic_netdev_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct qlcnic_adapter *adapter;\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nrecheck:\r\nif (dev == NULL)\r\ngoto done;\r\nif (is_vlan_dev(dev)) {\r\ndev = vlan_dev_real_dev(dev);\r\ngoto recheck;\r\n}\r\nif (!is_qlcnic_netdev(dev))\r\ngoto done;\r\nadapter = netdev_priv(dev);\r\nif (!adapter)\r\ngoto done;\r\nif (!test_bit(__QLCNIC_DEV_UP, &adapter->state))\r\ngoto done;\r\nqlcnic_config_indev_addr(adapter, dev, event);\r\ndone:\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int\r\nqlcnic_inetaddr_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct qlcnic_adapter *adapter;\r\nstruct net_device *dev;\r\nstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\r\ndev = ifa->ifa_dev ? ifa->ifa_dev->dev : NULL;\r\nrecheck:\r\nif (dev == NULL)\r\ngoto done;\r\nif (is_vlan_dev(dev)) {\r\ndev = vlan_dev_real_dev(dev);\r\ngoto recheck;\r\n}\r\nif (!is_qlcnic_netdev(dev))\r\ngoto done;\r\nadapter = netdev_priv(dev);\r\nif (!adapter)\r\ngoto done;\r\nif (!test_bit(__QLCNIC_DEV_UP, &adapter->state))\r\ngoto done;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nqlcnic_config_ipaddr(adapter, ifa->ifa_address, QLCNIC_IP_UP);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nqlcnic_config_ipaddr(adapter, ifa->ifa_address, QLCNIC_IP_DOWN);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndone:\r\nreturn NOTIFY_DONE;\r\n}\r\nvoid qlcnic_restore_indev_addr(struct net_device *dev, unsigned long event)\r\n{ }\r\nstatic int __init qlcnic_init_module(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "%s\n", qlcnic_driver_string);\r\n#ifdef CONFIG_INET\r\nregister_netdevice_notifier(&qlcnic_netdev_cb);\r\nregister_inetaddr_notifier(&qlcnic_inetaddr_cb);\r\n#endif\r\nret = pci_register_driver(&qlcnic_driver);\r\nif (ret) {\r\n#ifdef CONFIG_INET\r\nunregister_inetaddr_notifier(&qlcnic_inetaddr_cb);\r\nunregister_netdevice_notifier(&qlcnic_netdev_cb);\r\n#endif\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit qlcnic_exit_module(void)\r\n{\r\npci_unregister_driver(&qlcnic_driver);\r\n#ifdef CONFIG_INET\r\nunregister_inetaddr_notifier(&qlcnic_inetaddr_cb);\r\nunregister_netdevice_notifier(&qlcnic_netdev_cb);\r\n#endif\r\n}
