int ip6_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nvoid (*edemux)(struct sk_buff *skb);\r\nskb = l3mdev_ip6_rcv(skb);\r\nif (!skb)\r\nreturn NET_RX_SUCCESS;\r\nif (net->ipv4.sysctl_ip_early_demux && !skb_dst(skb) && skb->sk == NULL) {\r\nconst struct inet6_protocol *ipprot;\r\nipprot = rcu_dereference(inet6_protos[ipv6_hdr(skb)->nexthdr]);\r\nif (ipprot && (edemux = READ_ONCE(ipprot->early_demux)))\r\nedemux(skb);\r\n}\r\nif (!skb_valid_dst(skb))\r\nip6_route_input(skb);\r\nreturn dst_input(skb);\r\n}\r\nint ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nconst struct ipv6hdr *hdr;\r\nu32 pkt_len;\r\nstruct inet6_dev *idev;\r\nstruct net *net = dev_net(skb->dev);\r\nif (skb->pkt_type == PACKET_OTHERHOST) {\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nrcu_read_lock();\r\nidev = __in6_dev_get(skb->dev);\r\n__IP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_IN, skb->len);\r\nif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL ||\r\n!idev || unlikely(idev->cnf.disable_ipv6)) {\r\n__IP6_INC_STATS(net, idev, IPSTATS_MIB_INDISCARDS);\r\ngoto drop;\r\n}\r\nmemset(IP6CB(skb), 0, sizeof(struct inet6_skb_parm));\r\nIP6CB(skb)->iif = skb_valid_dst(skb) ? ip6_dst_idev(skb_dst(skb))->dev->ifindex : dev->ifindex;\r\nif (unlikely(!pskb_may_pull(skb, sizeof(*hdr))))\r\ngoto err;\r\nhdr = ipv6_hdr(skb);\r\nif (hdr->version != 6)\r\ngoto err;\r\n__IP6_ADD_STATS(net, idev,\r\nIPSTATS_MIB_NOECTPKTS +\r\n(ipv6_get_dsfield(hdr) & INET_ECN_MASK),\r\nmax_t(unsigned short, 1, skb_shinfo(skb)->gso_segs));\r\nif ((ipv6_addr_loopback(&hdr->saddr) ||\r\nipv6_addr_loopback(&hdr->daddr)) &&\r\n!(dev->flags & IFF_LOOPBACK))\r\ngoto err;\r\nif (!(skb->pkt_type == PACKET_LOOPBACK ||\r\ndev->flags & IFF_LOOPBACK) &&\r\nipv6_addr_is_multicast(&hdr->daddr) &&\r\nIPV6_ADDR_MC_SCOPE(&hdr->daddr) == 1)\r\ngoto err;\r\nif (!ipv6_addr_is_multicast(&hdr->daddr) &&\r\n(skb->pkt_type == PACKET_BROADCAST ||\r\nskb->pkt_type == PACKET_MULTICAST) &&\r\nidev->cnf.drop_unicast_in_l2_multicast)\r\ngoto err;\r\nif (ipv6_addr_is_multicast(&hdr->daddr) &&\r\nIPV6_ADDR_MC_SCOPE(&hdr->daddr) == 0)\r\ngoto err;\r\nif (ipv6_addr_is_multicast(&hdr->saddr))\r\ngoto err;\r\nskb->transport_header = skb->network_header + sizeof(*hdr);\r\nIP6CB(skb)->nhoff = offsetof(struct ipv6hdr, nexthdr);\r\npkt_len = ntohs(hdr->payload_len);\r\nif (pkt_len || hdr->nexthdr != NEXTHDR_HOP) {\r\nif (pkt_len + sizeof(struct ipv6hdr) > skb->len) {\r\n__IP6_INC_STATS(net,\r\nidev, IPSTATS_MIB_INTRUNCATEDPKTS);\r\ngoto drop;\r\n}\r\nif (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr))) {\r\n__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\r\ngoto drop;\r\n}\r\nhdr = ipv6_hdr(skb);\r\n}\r\nif (hdr->nexthdr == NEXTHDR_HOP) {\r\nif (ipv6_parse_hopopts(skb) < 0) {\r\n__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\r\nrcu_read_unlock();\r\nreturn NET_RX_DROP;\r\n}\r\n}\r\nrcu_read_unlock();\r\nskb_orphan(skb);\r\nreturn NF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING,\r\nnet, NULL, skb, dev, NULL,\r\nip6_rcv_finish);\r\nerr:\r\n__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\r\ndrop:\r\nrcu_read_unlock();\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int ip6_input_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nconst struct inet6_protocol *ipprot;\r\nstruct inet6_dev *idev;\r\nunsigned int nhoff;\r\nint nexthdr;\r\nbool raw;\r\nbool have_final = false;\r\nrcu_read_lock();\r\nresubmit:\r\nidev = ip6_dst_idev(skb_dst(skb));\r\nif (!pskb_pull(skb, skb_transport_offset(skb)))\r\ngoto discard;\r\nnhoff = IP6CB(skb)->nhoff;\r\nnexthdr = skb_network_header(skb)[nhoff];\r\nresubmit_final:\r\nraw = raw6_local_deliver(skb, nexthdr);\r\nipprot = rcu_dereference(inet6_protos[nexthdr]);\r\nif (ipprot) {\r\nint ret;\r\nif (have_final) {\r\nif (!(ipprot->flags & INET6_PROTO_FINAL)) {\r\ngoto discard;\r\n}\r\n} else if (ipprot->flags & INET6_PROTO_FINAL) {\r\nconst struct ipv6hdr *hdr;\r\nhave_final = true;\r\nnf_reset(skb);\r\nskb_postpull_rcsum(skb, skb_network_header(skb),\r\nskb_network_header_len(skb));\r\nhdr = ipv6_hdr(skb);\r\nif (ipv6_addr_is_multicast(&hdr->daddr) &&\r\n!ipv6_chk_mcast_addr(skb->dev, &hdr->daddr,\r\n&hdr->saddr) &&\r\n!ipv6_is_mld(skb, nexthdr, skb_network_header_len(skb)))\r\ngoto discard;\r\n}\r\nif (!(ipprot->flags & INET6_PROTO_NOPOLICY) &&\r\n!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\r\ngoto discard;\r\nret = ipprot->handler(skb);\r\nif (ret > 0) {\r\nif (ipprot->flags & INET6_PROTO_FINAL) {\r\nnexthdr = ret;\r\ngoto resubmit_final;\r\n} else {\r\ngoto resubmit;\r\n}\r\n} else if (ret == 0) {\r\n__IP6_INC_STATS(net, idev, IPSTATS_MIB_INDELIVERS);\r\n}\r\n} else {\r\nif (!raw) {\r\nif (xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\r\n__IP6_INC_STATS(net, idev,\r\nIPSTATS_MIB_INUNKNOWNPROTOS);\r\nicmpv6_send(skb, ICMPV6_PARAMPROB,\r\nICMPV6_UNK_NEXTHDR, nhoff);\r\n}\r\nkfree_skb(skb);\r\n} else {\r\n__IP6_INC_STATS(net, idev, IPSTATS_MIB_INDELIVERS);\r\nconsume_skb(skb);\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\ndiscard:\r\n__IP6_INC_STATS(net, idev, IPSTATS_MIB_INDISCARDS);\r\nrcu_read_unlock();\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint ip6_input(struct sk_buff *skb)\r\n{\r\nreturn NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_IN,\r\ndev_net(skb->dev), NULL, skb, skb->dev, NULL,\r\nip6_input_finish);\r\n}\r\nint ip6_mc_input(struct sk_buff *skb)\r\n{\r\nconst struct ipv6hdr *hdr;\r\nbool deliver;\r\n__IP6_UPD_PO_STATS(dev_net(skb_dst(skb)->dev),\r\nip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_INMCAST,\r\nskb->len);\r\nhdr = ipv6_hdr(skb);\r\ndeliver = ipv6_chk_mcast_addr(skb->dev, &hdr->daddr, NULL);\r\n#ifdef CONFIG_IPV6_MROUTE\r\nif (dev_net(skb->dev)->ipv6.devconf_all->mc_forwarding &&\r\n!(ipv6_addr_type(&hdr->daddr) &\r\n(IPV6_ADDR_LOOPBACK|IPV6_ADDR_LINKLOCAL)) &&\r\nlikely(!(IP6CB(skb)->flags & IP6SKB_FORWARDED))) {\r\nstruct sk_buff *skb2;\r\nstruct inet6_skb_parm *opt = IP6CB(skb);\r\nif (unlikely(opt->flags & IP6SKB_ROUTERALERT)) {\r\nu8 nexthdr = hdr->nexthdr;\r\n__be16 frag_off;\r\nint offset;\r\nif (opt->ra == htons(IPV6_OPT_ROUTERALERT_MLD)) {\r\ndeliver = false;\r\nif (!ipv6_ext_hdr(nexthdr)) {\r\ngoto out;\r\n}\r\noffset = ipv6_skip_exthdr(skb, sizeof(*hdr),\r\n&nexthdr, &frag_off);\r\nif (offset < 0)\r\ngoto out;\r\nif (ipv6_is_mld(skb, nexthdr, offset))\r\ndeliver = true;\r\ngoto out;\r\n}\r\n}\r\nif (deliver)\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nelse {\r\nskb2 = skb;\r\nskb = NULL;\r\n}\r\nif (skb2) {\r\nip6_mr_input(skb2);\r\n}\r\n}\r\nout:\r\n#endif\r\nif (likely(deliver))\r\nip6_input(skb);\r\nelse {\r\nkfree_skb(skb);\r\n}\r\nreturn 0;\r\n}
