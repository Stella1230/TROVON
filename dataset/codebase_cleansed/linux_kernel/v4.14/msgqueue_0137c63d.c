static struct nvkm_msgqueue_queue *\r\nmsgqueue_0137c63d_cmd_queue(struct nvkm_msgqueue *queue,\r\nenum msgqueue_msg_priority priority)\r\n{\r\nstruct msgqueue_0137c63d *priv = msgqueue_0137c63d(queue);\r\nconst struct nvkm_subdev *subdev = priv->base.falcon->owner;\r\nswitch (priority) {\r\ncase MSGQUEUE_MSG_PRIORITY_HIGH:\r\nreturn &priv->queue[MSGQUEUE_0137C63D_COMMAND_QUEUE_HPQ];\r\ncase MSGQUEUE_MSG_PRIORITY_LOW:\r\nreturn &priv->queue[MSGQUEUE_0137C63D_COMMAND_QUEUE_LPQ];\r\ndefault:\r\nnvkm_error(subdev, "invalid command queue!\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\nstatic void\r\nmsgqueue_0137c63d_process_msgs(struct nvkm_msgqueue *queue)\r\n{\r\nstruct msgqueue_0137c63d *priv = msgqueue_0137c63d(queue);\r\nstruct nvkm_msgqueue_queue *q_queue =\r\n&priv->queue[MSGQUEUE_0137C63D_MESSAGE_QUEUE];\r\nnvkm_msgqueue_process_msgs(&priv->base, q_queue);\r\n}\r\nstatic void\r\ninit_gen_cmdline(struct nvkm_msgqueue *queue, void *buf)\r\n{\r\nstruct {\r\nu32 reserved;\r\nu32 freq_hz;\r\nu32 trace_size;\r\nu32 trace_dma_base;\r\nu16 trace_dma_base1;\r\nu8 trace_dma_offset;\r\nu32 trace_dma_idx;\r\nbool secure_mode;\r\nbool raise_priv_sec;\r\nstruct {\r\nu32 dma_base;\r\nu16 dma_base1;\r\nu8 dma_offset;\r\nu16 fb_size;\r\nu8 dma_idx;\r\n} gc6_ctx;\r\nu8 pad;\r\n} *args = buf;\r\nargs->secure_mode = 1;\r\n}\r\nstatic int\r\ninit_callback(struct nvkm_msgqueue *_queue, struct nvkm_msgqueue_hdr *hdr)\r\n{\r\nstruct msgqueue_0137c63d *priv = msgqueue_0137c63d(_queue);\r\nstruct {\r\nstruct nvkm_msgqueue_msg base;\r\nu8 pad;\r\nu16 os_debug_entry_point;\r\nstruct {\r\nu16 size;\r\nu16 offset;\r\nu8 index;\r\nu8 pad;\r\n} queue_info[MSGQUEUE_0137C63D_NUM_QUEUES];\r\nu16 sw_managed_area_offset;\r\nu16 sw_managed_area_size;\r\n} *init = (void *)hdr;\r\nconst struct nvkm_subdev *subdev = _queue->falcon->owner;\r\nint i;\r\nif (init->base.hdr.unit_id != MSGQUEUE_0137C63D_UNIT_INIT) {\r\nnvkm_error(subdev, "expected message from init unit\n");\r\nreturn -EINVAL;\r\n}\r\nif (init->base.msg_type != INIT_MSG_INIT) {\r\nnvkm_error(subdev, "expected PMU init msg\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < MSGQUEUE_0137C63D_NUM_QUEUES; i++) {\r\nstruct nvkm_msgqueue_queue *queue = &priv->queue[i];\r\nmutex_init(&queue->mutex);\r\nqueue->index = init->queue_info[i].index;\r\nqueue->offset = init->queue_info[i].offset;\r\nqueue->size = init->queue_info[i].size;\r\nif (i != MSGQUEUE_0137C63D_MESSAGE_QUEUE) {\r\nqueue->head_reg = 0x4a0 + (queue->index * 4);\r\nqueue->tail_reg = 0x4b0 + (queue->index * 4);\r\n} else {\r\nqueue->head_reg = 0x4c8;\r\nqueue->tail_reg = 0x4cc;\r\n}\r\nnvkm_debug(subdev,\r\n"queue %d: index %d, offset 0x%08x, size 0x%08x\n",\r\ni, queue->index, queue->offset, queue->size);\r\n}\r\nreturn acr_init_wpr(&priv->base);\r\n}\r\nstatic void\r\nacr_init_wpr_callback(struct nvkm_msgqueue *queue,\r\nstruct nvkm_msgqueue_hdr *hdr)\r\n{\r\nstruct {\r\nstruct nvkm_msgqueue_msg base;\r\nu32 error_code;\r\n} *msg = (void *)hdr;\r\nconst struct nvkm_subdev *subdev = queue->falcon->owner;\r\nif (msg->error_code) {\r\nnvkm_error(subdev, "ACR WPR init failure: %d\n",\r\nmsg->error_code);\r\nreturn;\r\n}\r\nnvkm_debug(subdev, "ACR WPR init complete\n");\r\ncomplete_all(&queue->init_done);\r\n}\r\nstatic int\r\nacr_init_wpr(struct nvkm_msgqueue *queue)\r\n{\r\nstruct {\r\nstruct nvkm_msgqueue_hdr hdr;\r\nu8 cmd_type;\r\nu32 region_id;\r\nu32 wpr_offset;\r\n} cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.hdr.unit_id = MSGQUEUE_0137C63D_UNIT_ACR;\r\ncmd.hdr.size = sizeof(cmd);\r\ncmd.cmd_type = ACR_CMD_INIT_WPR_REGION;\r\ncmd.region_id = 0x01;\r\ncmd.wpr_offset = 0x00;\r\nnvkm_msgqueue_post(queue, MSGQUEUE_MSG_PRIORITY_HIGH, &cmd.hdr,\r\nacr_init_wpr_callback, NULL, false);\r\nreturn 0;\r\n}\r\nstatic void\r\nacr_boot_falcon_callback(struct nvkm_msgqueue *priv,\r\nstruct nvkm_msgqueue_hdr *hdr)\r\n{\r\nstruct acr_bootstrap_falcon_msg {\r\nstruct nvkm_msgqueue_msg base;\r\nu32 falcon_id;\r\n} *msg = (void *)hdr;\r\nconst struct nvkm_subdev *subdev = priv->falcon->owner;\r\nu32 falcon_id = msg->falcon_id;\r\nif (falcon_id >= NVKM_SECBOOT_FALCON_END) {\r\nnvkm_error(subdev, "in bootstrap falcon callback:\n");\r\nnvkm_error(subdev, "invalid falcon ID 0x%x\n", falcon_id);\r\nreturn;\r\n}\r\nnvkm_debug(subdev, "%s booted\n", nvkm_secboot_falcon_name[falcon_id]);\r\n}\r\nstatic int\r\nacr_boot_falcon(struct nvkm_msgqueue *priv, enum nvkm_secboot_falcon falcon)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(completed);\r\nstruct {\r\nstruct nvkm_msgqueue_hdr hdr;\r\nu8 cmd_type;\r\nu32 flags;\r\nu32 falcon_id;\r\n} cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.hdr.unit_id = MSGQUEUE_0137C63D_UNIT_ACR;\r\ncmd.hdr.size = sizeof(cmd);\r\ncmd.cmd_type = ACR_CMD_BOOTSTRAP_FALCON;\r\ncmd.flags = ACR_CMD_BOOTSTRAP_FALCON_FLAGS_RESET_YES;\r\ncmd.falcon_id = falcon;\r\nnvkm_msgqueue_post(priv, MSGQUEUE_MSG_PRIORITY_HIGH, &cmd.hdr,\r\nacr_boot_falcon_callback, &completed, true);\r\nif (!wait_for_completion_timeout(&completed, msecs_to_jiffies(1000)))\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic void\r\nacr_boot_multiple_falcons_callback(struct nvkm_msgqueue *priv,\r\nstruct nvkm_msgqueue_hdr *hdr)\r\n{\r\nstruct acr_bootstrap_falcon_msg {\r\nstruct nvkm_msgqueue_msg base;\r\nu32 falcon_mask;\r\n} *msg = (void *)hdr;\r\nconst struct nvkm_subdev *subdev = priv->falcon->owner;\r\nunsigned long falcon_mask = msg->falcon_mask;\r\nu32 falcon_id, falcon_treated = 0;\r\nfor_each_set_bit(falcon_id, &falcon_mask, NVKM_SECBOOT_FALCON_END) {\r\nnvkm_debug(subdev, "%s booted\n",\r\nnvkm_secboot_falcon_name[falcon_id]);\r\nfalcon_treated |= BIT(falcon_id);\r\n}\r\nif (falcon_treated != msg->falcon_mask) {\r\nnvkm_error(subdev, "in bootstrap falcon callback:\n");\r\nnvkm_error(subdev, "invalid falcon mask 0x%x\n",\r\nmsg->falcon_mask);\r\nreturn;\r\n}\r\n}\r\nstatic int\r\nacr_boot_multiple_falcons(struct nvkm_msgqueue *priv, unsigned long falcon_mask)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(completed);\r\nstruct {\r\nstruct nvkm_msgqueue_hdr hdr;\r\nu8 cmd_type;\r\nu32 flags;\r\nu32 falcon_mask;\r\nu32 use_va_mask;\r\nu32 wpr_lo;\r\nu32 wpr_hi;\r\n} cmd;\r\nstruct msgqueue_0137bca5 *queue = msgqueue_0137bca5(priv);\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.hdr.unit_id = MSGQUEUE_0137C63D_UNIT_ACR;\r\ncmd.hdr.size = sizeof(cmd);\r\ncmd.cmd_type = ACR_CMD_BOOTSTRAP_MULTIPLE_FALCONS;\r\ncmd.flags = ACR_CMD_BOOTSTRAP_FALCON_FLAGS_RESET_YES;\r\ncmd.falcon_mask = falcon_mask;\r\ncmd.wpr_lo = lower_32_bits(queue->wpr_addr);\r\ncmd.wpr_hi = upper_32_bits(queue->wpr_addr);\r\nnvkm_msgqueue_post(priv, MSGQUEUE_MSG_PRIORITY_HIGH, &cmd.hdr,\r\nacr_boot_multiple_falcons_callback, &completed, true);\r\nif (!wait_for_completion_timeout(&completed, msecs_to_jiffies(1000)))\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic void\r\nmsgqueue_0137c63d_dtor(struct nvkm_msgqueue *queue)\r\n{\r\nkfree(msgqueue_0137c63d(queue));\r\n}\r\nint\r\nmsgqueue_0137c63d_new(struct nvkm_falcon *falcon, const struct nvkm_secboot *sb,\r\nstruct nvkm_msgqueue **queue)\r\n{\r\nstruct msgqueue_0137c63d *ret;\r\nret = kzalloc(sizeof(*ret), GFP_KERNEL);\r\nif (!ret)\r\nreturn -ENOMEM;\r\n*queue = &ret->base;\r\nnvkm_msgqueue_ctor(&msgqueue_0137c63d_func, falcon, &ret->base);\r\nreturn 0;\r\n}\r\nint\r\nmsgqueue_0137bca5_new(struct nvkm_falcon *falcon, const struct nvkm_secboot *sb,\r\nstruct nvkm_msgqueue **queue)\r\n{\r\nstruct msgqueue_0137bca5 *ret;\r\nret = kzalloc(sizeof(*ret), GFP_KERNEL);\r\nif (!ret)\r\nreturn -ENOMEM;\r\n*queue = &ret->base.base;\r\nnvkm_msgqueue_ctor(&msgqueue_0137bca5_func, falcon, &ret->base.base);\r\nreturn 0;\r\n}
