static int soc_button_lookup_gpio(struct device *dev, int acpi_index)\r\n{\r\nstruct gpio_desc *desc;\r\nint gpio;\r\ndesc = gpiod_get_index(dev, NULL, acpi_index, GPIOD_ASIS);\r\nif (IS_ERR(desc))\r\nreturn PTR_ERR(desc);\r\ngpio = desc_to_gpio(desc);\r\ngpiod_put(desc);\r\nreturn gpio;\r\n}\r\nstatic struct platform_device *\r\nsoc_button_device_create(struct platform_device *pdev,\r\nconst struct soc_button_info *button_info,\r\nbool autorepeat)\r\n{\r\nconst struct soc_button_info *info;\r\nstruct platform_device *pd;\r\nstruct gpio_keys_button *gpio_keys;\r\nstruct gpio_keys_platform_data *gpio_keys_pdata;\r\nint n_buttons = 0;\r\nint gpio;\r\nint error;\r\nfor (info = button_info; info->name; info++)\r\nif (info->autorepeat == autorepeat)\r\nn_buttons++;\r\ngpio_keys_pdata = devm_kzalloc(&pdev->dev,\r\nsizeof(*gpio_keys_pdata) +\r\nsizeof(*gpio_keys) * n_buttons,\r\nGFP_KERNEL);\r\nif (!gpio_keys_pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\ngpio_keys = (void *)(gpio_keys_pdata + 1);\r\nn_buttons = 0;\r\nfor (info = button_info; info->name; info++) {\r\nif (info->autorepeat != autorepeat)\r\ncontinue;\r\ngpio = soc_button_lookup_gpio(&pdev->dev, info->acpi_index);\r\nif (!gpio_is_valid(gpio))\r\ncontinue;\r\ngpio_keys[n_buttons].type = info->event_type;\r\ngpio_keys[n_buttons].code = info->event_code;\r\ngpio_keys[n_buttons].gpio = gpio;\r\ngpio_keys[n_buttons].active_low = 1;\r\ngpio_keys[n_buttons].desc = info->name;\r\ngpio_keys[n_buttons].wakeup = info->wakeup;\r\ngpio_keys[n_buttons].debounce_interval = 50;\r\nn_buttons++;\r\n}\r\nif (n_buttons == 0) {\r\nerror = -ENODEV;\r\ngoto err_free_mem;\r\n}\r\ngpio_keys_pdata->buttons = gpio_keys;\r\ngpio_keys_pdata->nbuttons = n_buttons;\r\ngpio_keys_pdata->rep = autorepeat;\r\npd = platform_device_alloc("gpio-keys", PLATFORM_DEVID_AUTO);\r\nif (!pd) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nerror = platform_device_add_data(pd, gpio_keys_pdata,\r\nsizeof(*gpio_keys_pdata));\r\nif (error)\r\ngoto err_free_pdev;\r\nerror = platform_device_add(pd);\r\nif (error)\r\ngoto err_free_pdev;\r\nreturn pd;\r\nerr_free_pdev:\r\nplatform_device_put(pd);\r\nerr_free_mem:\r\ndevm_kfree(&pdev->dev, gpio_keys_pdata);\r\nreturn ERR_PTR(error);\r\n}\r\nstatic int soc_button_get_acpi_object_int(const union acpi_object *obj)\r\n{\r\nif (obj->type != ACPI_TYPE_INTEGER)\r\nreturn -1;\r\nreturn obj->integer.value;\r\n}\r\nstatic int soc_button_parse_btn_desc(struct device *dev,\r\nconst union acpi_object *desc,\r\nint collection_uid,\r\nstruct soc_button_info *info)\r\n{\r\nint upage, usage;\r\nif (desc->type != ACPI_TYPE_PACKAGE ||\r\ndesc->package.count != 5 ||\r\nsoc_button_get_acpi_object_int(&desc->package.elements[0]) != 1 ||\r\nsoc_button_get_acpi_object_int(&desc->package.elements[2]) !=\r\ncollection_uid) {\r\ndev_err(dev, "Invalid ACPI Button Descriptor\n");\r\nreturn -ENODEV;\r\n}\r\ninfo->event_type = EV_KEY;\r\ninfo->acpi_index =\r\nsoc_button_get_acpi_object_int(&desc->package.elements[1]);\r\nupage = soc_button_get_acpi_object_int(&desc->package.elements[3]);\r\nusage = soc_button_get_acpi_object_int(&desc->package.elements[4]);\r\nif (upage == 0x01 && usage == 0x81) {\r\ninfo->name = "power";\r\ninfo->event_code = KEY_POWER;\r\ninfo->wakeup = true;\r\n} else if (upage == 0x07 && usage == 0xe3) {\r\ninfo->name = "home";\r\ninfo->event_code = KEY_LEFTMETA;\r\ninfo->wakeup = true;\r\n} else if (upage == 0x0c && usage == 0xe9) {\r\ninfo->name = "volume_up";\r\ninfo->event_code = KEY_VOLUMEUP;\r\ninfo->autorepeat = true;\r\n} else if (upage == 0x0c && usage == 0xea) {\r\ninfo->name = "volume_down";\r\ninfo->event_code = KEY_VOLUMEDOWN;\r\ninfo->autorepeat = true;\r\n} else {\r\ndev_warn(dev, "Unknown button index %d upage %02x usage %02x, ignoring\n",\r\ninfo->acpi_index, upage, usage);\r\ninfo->name = "unknown";\r\ninfo->event_code = KEY_RESERVED;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct soc_button_info *soc_button_get_button_info(struct device *dev)\r\n{\r\nstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };\r\nconst union acpi_object *desc, *el0, *uuid, *btns_desc = NULL;\r\nstruct soc_button_info *button_info;\r\nacpi_status status;\r\nint i, btn, collection_uid = -1;\r\nstatus = acpi_evaluate_object_typed(ACPI_HANDLE(dev), "_DSD", NULL,\r\n&buf, ACPI_TYPE_PACKAGE);\r\nif (ACPI_FAILURE(status)) {\r\ndev_err(dev, "ACPI _DSD object not found\n");\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\ndesc = buf.pointer;\r\nfor (i = 0; (i + 1) < desc->package.count; i += 2) {\r\nuuid = &desc->package.elements[i];\r\nif (uuid->type != ACPI_TYPE_BUFFER ||\r\nuuid->buffer.length != 16 ||\r\ndesc->package.elements[i + 1].type != ACPI_TYPE_PACKAGE) {\r\nbreak;\r\n}\r\nif (memcmp(uuid->buffer.pointer, btns_desc_uuid, 16) == 0) {\r\nbtns_desc = &desc->package.elements[i + 1];\r\nbreak;\r\n}\r\n}\r\nif (!btns_desc) {\r\ndev_err(dev, "ACPI Button Descriptors not found\n");\r\nbutton_info = ERR_PTR(-ENODEV);\r\ngoto out;\r\n}\r\nel0 = &btns_desc->package.elements[0];\r\nif (el0->type == ACPI_TYPE_PACKAGE &&\r\nel0->package.count == 5 &&\r\nsoc_button_get_acpi_object_int(&el0->package.elements[0]) == 0 &&\r\nsoc_button_get_acpi_object_int(&el0->package.elements[2]) == 0) {\r\ncollection_uid = soc_button_get_acpi_object_int(\r\n&el0->package.elements[1]);\r\n}\r\nif (collection_uid == -1) {\r\ndev_err(dev, "Invalid Button Collection Descriptor\n");\r\nbutton_info = ERR_PTR(-ENODEV);\r\ngoto out;\r\n}\r\nbutton_info = devm_kcalloc(dev, btns_desc->package.count,\r\nsizeof(*button_info), GFP_KERNEL);\r\nif (!button_info) {\r\nbutton_info = ERR_PTR(-ENOMEM);\r\ngoto out;\r\n}\r\nfor (i = 1, btn = 0; i < btns_desc->package.count; i++, btn++) {\r\nif (soc_button_parse_btn_desc(dev,\r\n&btns_desc->package.elements[i],\r\ncollection_uid,\r\n&button_info[btn])) {\r\nbutton_info = ERR_PTR(-ENODEV);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nkfree(buf.pointer);\r\nreturn button_info;\r\n}\r\nstatic int soc_button_remove(struct platform_device *pdev)\r\n{\r\nstruct soc_button_data *priv = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < BUTTON_TYPES; i++)\r\nif (priv->children[i])\r\nplatform_device_unregister(priv->children[i]);\r\nreturn 0;\r\n}\r\nstatic int soc_button_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct acpi_device_id *id;\r\nstruct soc_button_info *button_info;\r\nstruct soc_button_data *priv;\r\nstruct platform_device *pd;\r\nint i;\r\nint error;\r\nid = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!id)\r\nreturn -ENODEV;\r\nif (!id->driver_data) {\r\nbutton_info = soc_button_get_button_info(dev);\r\nif (IS_ERR(button_info))\r\nreturn PTR_ERR(button_info);\r\n} else {\r\nbutton_info = (struct soc_button_info *)id->driver_data;\r\n}\r\nerror = gpiod_count(dev, NULL);\r\nif (error < 0) {\r\ndev_dbg(dev, "no GPIO attached, ignoring...\n");\r\nreturn -ENODEV;\r\n}\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, priv);\r\nfor (i = 0; i < BUTTON_TYPES; i++) {\r\npd = soc_button_device_create(pdev, button_info, i == 0);\r\nif (IS_ERR(pd)) {\r\nerror = PTR_ERR(pd);\r\nif (error != -ENODEV) {\r\nsoc_button_remove(pdev);\r\nreturn error;\r\n}\r\ncontinue;\r\n}\r\npriv->children[i] = pd;\r\n}\r\nif (!priv->children[0] && !priv->children[1])\r\nreturn -ENODEV;\r\nif (!id->driver_data)\r\ndevm_kfree(dev, button_info);\r\nreturn 0;\r\n}
