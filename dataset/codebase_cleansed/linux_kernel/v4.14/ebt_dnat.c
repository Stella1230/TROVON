static unsigned int\r\nebt_dnat_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct ebt_nat_info *info = par->targinfo;\r\nstruct net_device *dev;\r\nif (!skb_make_writable(skb, 0))\r\nreturn EBT_DROP;\r\nether_addr_copy(eth_hdr(skb)->h_dest, info->mac);\r\nif (is_multicast_ether_addr(info->mac)) {\r\nif (is_broadcast_ether_addr(info->mac))\r\nskb->pkt_type = PACKET_BROADCAST;\r\nelse\r\nskb->pkt_type = PACKET_MULTICAST;\r\n} else {\r\nif (xt_hooknum(par) != NF_BR_BROUTING)\r\ndev = br_port_get_rcu(xt_in(par))->br->dev;\r\nelse\r\ndev = xt_in(par);\r\nif (ether_addr_equal(info->mac, dev->dev_addr))\r\nskb->pkt_type = PACKET_HOST;\r\nelse\r\nskb->pkt_type = PACKET_OTHERHOST;\r\n}\r\nreturn info->target;\r\n}\r\nstatic int ebt_dnat_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct ebt_nat_info *info = par->targinfo;\r\nunsigned int hook_mask;\r\nif (BASE_CHAIN && info->target == EBT_RETURN)\r\nreturn -EINVAL;\r\nhook_mask = par->hook_mask & ~(1 << NF_BR_NUMHOOKS);\r\nif ((strcmp(par->table, "nat") != 0 ||\r\n(hook_mask & ~((1 << NF_BR_PRE_ROUTING) |\r\n(1 << NF_BR_LOCAL_OUT)))) &&\r\n(strcmp(par->table, "broute") != 0 ||\r\nhook_mask & ~(1 << NF_BR_BROUTING)))\r\nreturn -EINVAL;\r\nif (ebt_invalid_target(info->target))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __init ebt_dnat_init(void)\r\n{\r\nreturn xt_register_target(&ebt_dnat_tg_reg);\r\n}\r\nstatic void __exit ebt_dnat_fini(void)\r\n{\r\nxt_unregister_target(&ebt_dnat_tg_reg);\r\n}
