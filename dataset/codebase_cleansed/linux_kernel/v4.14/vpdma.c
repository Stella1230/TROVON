static u32 read_reg(struct vpdma_data *vpdma, int offset)\r\n{\r\nreturn ioread32(vpdma->base + offset);\r\n}\r\nstatic void write_reg(struct vpdma_data *vpdma, int offset, u32 value)\r\n{\r\niowrite32(value, vpdma->base + offset);\r\n}\r\nstatic int read_field_reg(struct vpdma_data *vpdma, int offset,\r\nu32 mask, int shift)\r\n{\r\nreturn (read_reg(vpdma, offset) & (mask << shift)) >> shift;\r\n}\r\nstatic void write_field_reg(struct vpdma_data *vpdma, int offset, u32 field,\r\nu32 mask, int shift)\r\n{\r\nu32 val = read_reg(vpdma, offset);\r\nval &= ~(mask << shift);\r\nval |= (field & mask) << shift;\r\nwrite_reg(vpdma, offset, val);\r\n}\r\nvoid vpdma_dump_regs(struct vpdma_data *vpdma)\r\n{\r\nstruct device *dev = &vpdma->pdev->dev;\r\n#define DUMPREG(r) dev_dbg(dev, "%-35s %08x\n", #r, read_reg(vpdma, VPDMA_##r))\r\ndev_dbg(dev, "VPDMA Registers:\n");\r\nDUMPREG(PID);\r\nDUMPREG(LIST_ADDR);\r\nDUMPREG(LIST_ATTR);\r\nDUMPREG(LIST_STAT_SYNC);\r\nDUMPREG(BG_RGB);\r\nDUMPREG(BG_YUV);\r\nDUMPREG(SETUP);\r\nDUMPREG(MAX_SIZE1);\r\nDUMPREG(MAX_SIZE2);\r\nDUMPREG(MAX_SIZE3);\r\nDUMPREG(INT_CHAN_STAT(0));\r\nDUMPREG(INT_CHAN_MASK(0));\r\nDUMPREG(INT_CHAN_STAT(3));\r\nDUMPREG(INT_CHAN_MASK(3));\r\nDUMPREG(INT_CLIENT0_STAT);\r\nDUMPREG(INT_CLIENT0_MASK);\r\nDUMPREG(INT_CLIENT1_STAT);\r\nDUMPREG(INT_CLIENT1_MASK);\r\nDUMPREG(INT_LIST0_STAT);\r\nDUMPREG(INT_LIST0_MASK);\r\nDUMPREG(DEI_CHROMA1_CSTAT);\r\nDUMPREG(DEI_LUMA1_CSTAT);\r\nDUMPREG(DEI_CHROMA2_CSTAT);\r\nDUMPREG(DEI_LUMA2_CSTAT);\r\nDUMPREG(DEI_CHROMA3_CSTAT);\r\nDUMPREG(DEI_LUMA3_CSTAT);\r\nDUMPREG(DEI_MV_IN_CSTAT);\r\nDUMPREG(DEI_MV_OUT_CSTAT);\r\nDUMPREG(VIP_UP_Y_CSTAT);\r\nDUMPREG(VIP_UP_UV_CSTAT);\r\nDUMPREG(VPI_CTL_CSTAT);\r\n}\r\nint vpdma_alloc_desc_buf(struct vpdma_buf *buf, size_t size)\r\n{\r\nbuf->size = size;\r\nbuf->mapped = false;\r\nbuf->addr = kzalloc(size, GFP_KERNEL);\r\nif (!buf->addr)\r\nreturn -ENOMEM;\r\nWARN_ON(((unsigned long)buf->addr & VPDMA_DESC_ALIGN) != 0);\r\nreturn 0;\r\n}\r\nvoid vpdma_free_desc_buf(struct vpdma_buf *buf)\r\n{\r\nWARN_ON(buf->mapped);\r\nkfree(buf->addr);\r\nbuf->addr = NULL;\r\nbuf->size = 0;\r\n}\r\nint vpdma_map_desc_buf(struct vpdma_data *vpdma, struct vpdma_buf *buf)\r\n{\r\nstruct device *dev = &vpdma->pdev->dev;\r\nWARN_ON(buf->mapped);\r\nbuf->dma_addr = dma_map_single(dev, buf->addr, buf->size,\r\nDMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(dev, buf->dma_addr)) {\r\ndev_err(dev, "failed to map buffer\n");\r\nreturn -EINVAL;\r\n}\r\nbuf->mapped = true;\r\nreturn 0;\r\n}\r\nvoid vpdma_unmap_desc_buf(struct vpdma_data *vpdma, struct vpdma_buf *buf)\r\n{\r\nstruct device *dev = &vpdma->pdev->dev;\r\nif (buf->mapped)\r\ndma_unmap_single(dev, buf->dma_addr, buf->size,\r\nDMA_BIDIRECTIONAL);\r\nbuf->mapped = false;\r\n}\r\nint vpdma_list_cleanup(struct vpdma_data *vpdma, int list_num,\r\nint *channels, int size)\r\n{\r\nstruct vpdma_desc_list abort_list;\r\nint i, ret, timeout = 500;\r\nwrite_reg(vpdma, VPDMA_LIST_ATTR,\r\n(list_num << VPDMA_LIST_NUM_SHFT) |\r\n(1 << VPDMA_LIST_STOP_SHFT));\r\nif (size <= 0 || !channels)\r\nreturn 0;\r\nret = vpdma_create_desc_list(&abort_list,\r\nsize * sizeof(struct vpdma_dtd), VPDMA_LIST_TYPE_NORMAL);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < size; i++)\r\nvpdma_add_abort_channel_ctd(&abort_list, channels[i]);\r\nret = vpdma_map_desc_buf(vpdma, &abort_list.buf);\r\nif (ret)\r\nreturn ret;\r\nret = vpdma_submit_descs(vpdma, &abort_list, list_num);\r\nif (ret)\r\nreturn ret;\r\nwhile (vpdma_list_busy(vpdma, list_num) && --timeout)\r\n;\r\nif (timeout == 0) {\r\ndev_err(&vpdma->pdev->dev, "Timed out cleaning up VPDMA list\n");\r\nreturn -EBUSY;\r\n}\r\nvpdma_unmap_desc_buf(vpdma, &abort_list.buf);\r\nvpdma_free_desc_buf(&abort_list.buf);\r\nreturn 0;\r\n}\r\nint vpdma_create_desc_list(struct vpdma_desc_list *list, size_t size, int type)\r\n{\r\nint r;\r\nr = vpdma_alloc_desc_buf(&list->buf, size);\r\nif (r)\r\nreturn r;\r\nlist->next = list->buf.addr;\r\nlist->type = type;\r\nreturn 0;\r\n}\r\nvoid vpdma_reset_desc_list(struct vpdma_desc_list *list)\r\n{\r\nlist->next = list->buf.addr;\r\n}\r\nvoid vpdma_free_desc_list(struct vpdma_desc_list *list)\r\n{\r\nvpdma_free_desc_buf(&list->buf);\r\nlist->next = NULL;\r\n}\r\nbool vpdma_list_busy(struct vpdma_data *vpdma, int list_num)\r\n{\r\nreturn read_reg(vpdma, VPDMA_LIST_STAT_SYNC) & BIT(list_num + 16);\r\n}\r\nint vpdma_submit_descs(struct vpdma_data *vpdma,\r\nstruct vpdma_desc_list *list, int list_num)\r\n{\r\nint list_size;\r\nunsigned long flags;\r\nif (vpdma_list_busy(vpdma, list_num))\r\nreturn -EBUSY;\r\nlist_size = (list->next - list->buf.addr) >> 4;\r\nspin_lock_irqsave(&vpdma->lock, flags);\r\nwrite_reg(vpdma, VPDMA_LIST_ADDR, (u32) list->buf.dma_addr);\r\nwrite_reg(vpdma, VPDMA_LIST_ATTR,\r\n(list_num << VPDMA_LIST_NUM_SHFT) |\r\n(list->type << VPDMA_LIST_TYPE_SHFT) |\r\nlist_size);\r\nspin_unlock_irqrestore(&vpdma->lock, flags);\r\nreturn 0;\r\n}\r\nvoid vpdma_update_dma_addr(struct vpdma_data *vpdma,\r\nstruct vpdma_desc_list *list, dma_addr_t dma_addr,\r\nvoid *write_dtd, int drop, int idx)\r\n{\r\nstruct vpdma_dtd *dtd = list->buf.addr;\r\ndma_addr_t write_desc_addr;\r\nint offset;\r\ndtd += idx;\r\nvpdma_unmap_desc_buf(vpdma, &list->buf);\r\ndtd->start_addr = dma_addr;\r\noffset = (void *)write_dtd - list->buf.addr;\r\nwrite_desc_addr = list->buf.dma_addr + offset;\r\nif (drop)\r\ndtd->desc_write_addr = dtd_desc_write_addr(write_desc_addr,\r\n1, 1, 0);\r\nelse\r\ndtd->desc_write_addr = dtd_desc_write_addr(write_desc_addr,\r\n1, 0, 0);\r\nvpdma_map_desc_buf(vpdma, &list->buf);\r\ndump_dtd(dtd);\r\n}\r\nvoid vpdma_set_max_size(struct vpdma_data *vpdma, int reg_addr,\r\nu32 width, u32 height)\r\n{\r\nif (reg_addr != VPDMA_MAX_SIZE1 && reg_addr != VPDMA_MAX_SIZE2 &&\r\nreg_addr != VPDMA_MAX_SIZE3)\r\nreg_addr = VPDMA_MAX_SIZE1;\r\nwrite_field_reg(vpdma, reg_addr, width - 1,\r\nVPDMA_MAX_SIZE_WIDTH_MASK, VPDMA_MAX_SIZE_WIDTH_SHFT);\r\nwrite_field_reg(vpdma, reg_addr, height - 1,\r\nVPDMA_MAX_SIZE_HEIGHT_MASK, VPDMA_MAX_SIZE_HEIGHT_SHFT);\r\n}\r\nstatic void dump_cfd(struct vpdma_cfd *cfd)\r\n{\r\nint class;\r\nclass = cfd_get_class(cfd);\r\npr_debug("config descriptor of payload class: %s\n",\r\nclass == CFD_CLS_BLOCK ? "simple block" :\r\n"address data block");\r\nif (class == CFD_CLS_BLOCK)\r\npr_debug("word0: dst_addr_offset = 0x%08x\n",\r\ncfd->dest_addr_offset);\r\nif (class == CFD_CLS_BLOCK)\r\npr_debug("word1: num_data_wrds = %d\n", cfd->block_len);\r\npr_debug("word2: payload_addr = 0x%08x\n", cfd->payload_addr);\r\npr_debug("word3: pkt_type = %d, direct = %d, class = %d, dest = %d, payload_len = %d\n",\r\ncfd_get_pkt_type(cfd),\r\ncfd_get_direct(cfd), class, cfd_get_dest(cfd),\r\ncfd_get_payload_len(cfd));\r\n}\r\nvoid vpdma_add_cfd_block(struct vpdma_desc_list *list, int client,\r\nstruct vpdma_buf *blk, u32 dest_offset)\r\n{\r\nstruct vpdma_cfd *cfd;\r\nint len = blk->size;\r\nWARN_ON(blk->dma_addr & VPDMA_DESC_ALIGN);\r\ncfd = list->next;\r\nWARN_ON((void *)(cfd + 1) > (list->buf.addr + list->buf.size));\r\ncfd->dest_addr_offset = dest_offset;\r\ncfd->block_len = len;\r\ncfd->payload_addr = (u32) blk->dma_addr;\r\ncfd->ctl_payload_len = cfd_pkt_payload_len(CFD_INDIRECT, CFD_CLS_BLOCK,\r\nclient, len >> 4);\r\nlist->next = cfd + 1;\r\ndump_cfd(cfd);\r\n}\r\nvoid vpdma_add_cfd_adb(struct vpdma_desc_list *list, int client,\r\nstruct vpdma_buf *adb)\r\n{\r\nstruct vpdma_cfd *cfd;\r\nunsigned int len = adb->size;\r\nWARN_ON(len & VPDMA_ADB_SIZE_ALIGN);\r\nWARN_ON(adb->dma_addr & VPDMA_DESC_ALIGN);\r\ncfd = list->next;\r\nBUG_ON((void *)(cfd + 1) > (list->buf.addr + list->buf.size));\r\ncfd->w0 = 0;\r\ncfd->w1 = 0;\r\ncfd->payload_addr = (u32) adb->dma_addr;\r\ncfd->ctl_payload_len = cfd_pkt_payload_len(CFD_INDIRECT, CFD_CLS_ADB,\r\nclient, len >> 4);\r\nlist->next = cfd + 1;\r\ndump_cfd(cfd);\r\n}\r\nstatic void dump_ctd(struct vpdma_ctd *ctd)\r\n{\r\npr_debug("control descriptor\n");\r\npr_debug("word3: pkt_type = %d, source = %d, ctl_type = %d\n",\r\nctd_get_pkt_type(ctd), ctd_get_source(ctd), ctd_get_ctl(ctd));\r\n}\r\nvoid vpdma_add_sync_on_channel_ctd(struct vpdma_desc_list *list,\r\nenum vpdma_channel chan)\r\n{\r\nstruct vpdma_ctd *ctd;\r\nctd = list->next;\r\nWARN_ON((void *)(ctd + 1) > (list->buf.addr + list->buf.size));\r\nctd->w0 = 0;\r\nctd->w1 = 0;\r\nctd->w2 = 0;\r\nctd->type_source_ctl = ctd_type_source_ctl(chan_info[chan].num,\r\nCTD_TYPE_SYNC_ON_CHANNEL);\r\nlist->next = ctd + 1;\r\ndump_ctd(ctd);\r\n}\r\nvoid vpdma_add_abort_channel_ctd(struct vpdma_desc_list *list,\r\nint chan_num)\r\n{\r\nstruct vpdma_ctd *ctd;\r\nctd = list->next;\r\nWARN_ON((void *)(ctd + 1) > (list->buf.addr + list->buf.size));\r\nctd->w0 = 0;\r\nctd->w1 = 0;\r\nctd->w2 = 0;\r\nctd->type_source_ctl = ctd_type_source_ctl(chan_num,\r\nCTD_TYPE_ABORT_CHANNEL);\r\nlist->next = ctd + 1;\r\ndump_ctd(ctd);\r\n}\r\nstatic void dump_dtd(struct vpdma_dtd *dtd)\r\n{\r\nint dir, chan;\r\ndir = dtd_get_dir(dtd);\r\nchan = dtd_get_chan(dtd);\r\npr_debug("%s data transfer descriptor for channel %d\n",\r\ndir == DTD_DIR_OUT ? "outbound" : "inbound", chan);\r\npr_debug("word0: data_type = %d, notify = %d, field = %d, 1D = %d, even_ln_skp = %d, odd_ln_skp = %d, line_stride = %d\n",\r\ndtd_get_data_type(dtd), dtd_get_notify(dtd), dtd_get_field(dtd),\r\ndtd_get_1d(dtd), dtd_get_even_line_skip(dtd),\r\ndtd_get_odd_line_skip(dtd), dtd_get_line_stride(dtd));\r\nif (dir == DTD_DIR_IN)\r\npr_debug("word1: line_length = %d, xfer_height = %d\n",\r\ndtd_get_line_length(dtd), dtd_get_xfer_height(dtd));\r\npr_debug("word2: start_addr = %pad\n", &dtd->start_addr);\r\npr_debug("word3: pkt_type = %d, mode = %d, dir = %d, chan = %d, pri = %d, next_chan = %d\n",\r\ndtd_get_pkt_type(dtd),\r\ndtd_get_mode(dtd), dir, chan, dtd_get_priority(dtd),\r\ndtd_get_next_chan(dtd));\r\nif (dir == DTD_DIR_IN)\r\npr_debug("word4: frame_width = %d, frame_height = %d\n",\r\ndtd_get_frame_width(dtd), dtd_get_frame_height(dtd));\r\nelse\r\npr_debug("word4: desc_write_addr = 0x%08x, write_desc = %d, drp_data = %d, use_desc_reg = %d\n",\r\ndtd_get_desc_write_addr(dtd), dtd_get_write_desc(dtd),\r\ndtd_get_drop_data(dtd), dtd_get_use_desc(dtd));\r\nif (dir == DTD_DIR_IN)\r\npr_debug("word5: hor_start = %d, ver_start = %d\n",\r\ndtd_get_h_start(dtd), dtd_get_v_start(dtd));\r\nelse\r\npr_debug("word5: max_width %d, max_height %d\n",\r\ndtd_get_max_width(dtd), dtd_get_max_height(dtd));\r\npr_debug("word6: client specific attr0 = 0x%08x\n", dtd->client_attr0);\r\npr_debug("word7: client specific attr1 = 0x%08x\n", dtd->client_attr1);\r\n}\r\nvoid vpdma_add_out_dtd(struct vpdma_desc_list *list, int width,\r\nint stride, const struct v4l2_rect *c_rect,\r\nconst struct vpdma_data_format *fmt, dma_addr_t dma_addr,\r\nint max_w, int max_h, enum vpdma_channel chan, u32 flags)\r\n{\r\nvpdma_rawchan_add_out_dtd(list, width, stride, c_rect, fmt, dma_addr,\r\nmax_w, max_h, chan_info[chan].num, flags);\r\n}\r\nvoid vpdma_rawchan_add_out_dtd(struct vpdma_desc_list *list, int width,\r\nint stride, const struct v4l2_rect *c_rect,\r\nconst struct vpdma_data_format *fmt, dma_addr_t dma_addr,\r\nint max_w, int max_h, int raw_vpdma_chan, u32 flags)\r\n{\r\nint priority = 0;\r\nint field = 0;\r\nint notify = 1;\r\nint channel, next_chan;\r\nstruct v4l2_rect rect = *c_rect;\r\nint depth = fmt->depth;\r\nstruct vpdma_dtd *dtd;\r\nchannel = next_chan = raw_vpdma_chan;\r\nif (fmt->type == VPDMA_DATA_FMT_TYPE_YUV &&\r\nfmt->data_type == DATA_TYPE_C420) {\r\nrect.height >>= 1;\r\nrect.top >>= 1;\r\ndepth = 8;\r\n}\r\ndma_addr += rect.top * stride + (rect.left * depth >> 3);\r\ndtd = list->next;\r\nWARN_ON((void *)(dtd + 1) > (list->buf.addr + list->buf.size));\r\ndtd->type_ctl_stride = dtd_type_ctl_stride(fmt->data_type,\r\nnotify,\r\nfield,\r\n!!(flags & VPDMA_DATA_FRAME_1D),\r\n!!(flags & VPDMA_DATA_EVEN_LINE_SKIP),\r\n!!(flags & VPDMA_DATA_ODD_LINE_SKIP),\r\nstride);\r\ndtd->w1 = 0;\r\ndtd->start_addr = (u32) dma_addr;\r\ndtd->pkt_ctl = dtd_pkt_ctl(!!(flags & VPDMA_DATA_MODE_TILED),\r\nDTD_DIR_OUT, channel, priority, next_chan);\r\ndtd->desc_write_addr = dtd_desc_write_addr(0, 0, 0, 0);\r\ndtd->max_width_height = dtd_max_width_height(max_w, max_h);\r\ndtd->client_attr0 = 0;\r\ndtd->client_attr1 = 0;\r\nlist->next = dtd + 1;\r\ndump_dtd(dtd);\r\n}\r\nvoid vpdma_add_in_dtd(struct vpdma_desc_list *list, int width,\r\nint stride, const struct v4l2_rect *c_rect,\r\nconst struct vpdma_data_format *fmt, dma_addr_t dma_addr,\r\nenum vpdma_channel chan, int field, u32 flags, int frame_width,\r\nint frame_height, int start_h, int start_v)\r\n{\r\nint priority = 0;\r\nint notify = 1;\r\nint depth = fmt->depth;\r\nint channel, next_chan;\r\nstruct v4l2_rect rect = *c_rect;\r\nstruct vpdma_dtd *dtd;\r\nchannel = next_chan = chan_info[chan].num;\r\nif (fmt->type == VPDMA_DATA_FMT_TYPE_YUV &&\r\nfmt->data_type == DATA_TYPE_C420) {\r\nrect.height >>= 1;\r\nrect.top >>= 1;\r\ndepth = 8;\r\n}\r\ndma_addr += rect.top * stride + (rect.left * depth >> 3);\r\ndtd = list->next;\r\nWARN_ON((void *)(dtd + 1) > (list->buf.addr + list->buf.size));\r\ndtd->type_ctl_stride = dtd_type_ctl_stride(fmt->data_type,\r\nnotify,\r\nfield,\r\n!!(flags & VPDMA_DATA_FRAME_1D),\r\n!!(flags & VPDMA_DATA_EVEN_LINE_SKIP),\r\n!!(flags & VPDMA_DATA_ODD_LINE_SKIP),\r\nstride);\r\ndtd->xfer_length_height = dtd_xfer_length_height(rect.width,\r\nrect.height);\r\ndtd->start_addr = (u32) dma_addr;\r\ndtd->pkt_ctl = dtd_pkt_ctl(!!(flags & VPDMA_DATA_MODE_TILED),\r\nDTD_DIR_IN, channel, priority, next_chan);\r\ndtd->frame_width_height = dtd_frame_width_height(frame_width,\r\nframe_height);\r\ndtd->start_h_v = dtd_start_h_v(start_h, start_v);\r\ndtd->client_attr0 = 0;\r\ndtd->client_attr1 = 0;\r\nlist->next = dtd + 1;\r\ndump_dtd(dtd);\r\n}\r\nint vpdma_hwlist_alloc(struct vpdma_data *vpdma, void *priv)\r\n{\r\nint i, list_num = -1;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vpdma->lock, flags);\r\nfor (i = 0; i < VPDMA_MAX_NUM_LIST &&\r\nvpdma->hwlist_used[i] == true; i++)\r\n;\r\nif (i < VPDMA_MAX_NUM_LIST) {\r\nlist_num = i;\r\nvpdma->hwlist_used[i] = true;\r\nvpdma->hwlist_priv[i] = priv;\r\n}\r\nspin_unlock_irqrestore(&vpdma->lock, flags);\r\nreturn list_num;\r\n}\r\nvoid *vpdma_hwlist_get_priv(struct vpdma_data *vpdma, int list_num)\r\n{\r\nif (!vpdma || list_num >= VPDMA_MAX_NUM_LIST)\r\nreturn NULL;\r\nreturn vpdma->hwlist_priv[list_num];\r\n}\r\nvoid *vpdma_hwlist_release(struct vpdma_data *vpdma, int list_num)\r\n{\r\nvoid *priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vpdma->lock, flags);\r\nvpdma->hwlist_used[list_num] = false;\r\npriv = vpdma->hwlist_priv;\r\nspin_unlock_irqrestore(&vpdma->lock, flags);\r\nreturn priv;\r\n}\r\nvoid vpdma_enable_list_complete_irq(struct vpdma_data *vpdma, int irq_num,\r\nint list_num, bool enable)\r\n{\r\nu32 reg_addr = VPDMA_INT_LIST0_MASK + VPDMA_INTX_OFFSET * irq_num;\r\nu32 val;\r\nval = read_reg(vpdma, reg_addr);\r\nif (enable)\r\nval |= (1 << (list_num * 2));\r\nelse\r\nval &= ~(1 << (list_num * 2));\r\nwrite_reg(vpdma, reg_addr, val);\r\n}\r\nunsigned int vpdma_get_list_stat(struct vpdma_data *vpdma, int irq_num)\r\n{\r\nu32 reg_addr = VPDMA_INT_LIST0_STAT + VPDMA_INTX_OFFSET * irq_num;\r\nreturn read_reg(vpdma, reg_addr);\r\n}\r\nunsigned int vpdma_get_list_mask(struct vpdma_data *vpdma, int irq_num)\r\n{\r\nu32 reg_addr = VPDMA_INT_LIST0_MASK + VPDMA_INTX_OFFSET * irq_num;\r\nreturn read_reg(vpdma, reg_addr);\r\n}\r\nvoid vpdma_clear_list_stat(struct vpdma_data *vpdma, int irq_num,\r\nint list_num)\r\n{\r\nu32 reg_addr = VPDMA_INT_LIST0_STAT + VPDMA_INTX_OFFSET * irq_num;\r\nwrite_reg(vpdma, reg_addr, 3 << (list_num * 2));\r\n}\r\nvoid vpdma_set_bg_color(struct vpdma_data *vpdma,\r\nstruct vpdma_data_format *fmt, u32 color)\r\n{\r\nif (fmt->type == VPDMA_DATA_FMT_TYPE_RGB)\r\nwrite_reg(vpdma, VPDMA_BG_RGB, color);\r\nelse if (fmt->type == VPDMA_DATA_FMT_TYPE_YUV)\r\nwrite_reg(vpdma, VPDMA_BG_YUV, color);\r\n}\r\nvoid vpdma_set_line_mode(struct vpdma_data *vpdma, int line_mode,\r\nenum vpdma_channel chan)\r\n{\r\nint client_cstat = chan_info[chan].cstat_offset;\r\nwrite_field_reg(vpdma, client_cstat, line_mode,\r\nVPDMA_CSTAT_LINE_MODE_MASK, VPDMA_CSTAT_LINE_MODE_SHIFT);\r\n}\r\nvoid vpdma_set_frame_start_event(struct vpdma_data *vpdma,\r\nenum vpdma_frame_start_event fs_event,\r\nenum vpdma_channel chan)\r\n{\r\nint client_cstat = chan_info[chan].cstat_offset;\r\nwrite_field_reg(vpdma, client_cstat, fs_event,\r\nVPDMA_CSTAT_FRAME_START_MASK, VPDMA_CSTAT_FRAME_START_SHIFT);\r\n}\r\nstatic void vpdma_firmware_cb(const struct firmware *f, void *context)\r\n{\r\nstruct vpdma_data *vpdma = context;\r\nstruct vpdma_buf fw_dma_buf;\r\nint i, r;\r\ndev_dbg(&vpdma->pdev->dev, "firmware callback\n");\r\nif (!f || !f->data) {\r\ndev_err(&vpdma->pdev->dev, "couldn't get firmware\n");\r\nreturn;\r\n}\r\nif (read_field_reg(vpdma, VPDMA_LIST_ATTR, VPDMA_LIST_RDY_MASK,\r\nVPDMA_LIST_RDY_SHFT)) {\r\nvpdma->cb(vpdma->pdev);\r\nreturn;\r\n}\r\nr = vpdma_alloc_desc_buf(&fw_dma_buf, f->size);\r\nif (r) {\r\ndev_err(&vpdma->pdev->dev,\r\n"failed to allocate dma buffer for firmware\n");\r\ngoto rel_fw;\r\n}\r\nmemcpy(fw_dma_buf.addr, f->data, f->size);\r\nvpdma_map_desc_buf(vpdma, &fw_dma_buf);\r\nwrite_reg(vpdma, VPDMA_LIST_ADDR, (u32) fw_dma_buf.dma_addr);\r\nfor (i = 0; i < 100; i++) {\r\nmsleep_interruptible(10);\r\nif (read_field_reg(vpdma, VPDMA_LIST_ATTR, VPDMA_LIST_RDY_MASK,\r\nVPDMA_LIST_RDY_SHFT))\r\nbreak;\r\n}\r\nif (i == 100) {\r\ndev_err(&vpdma->pdev->dev, "firmware upload failed\n");\r\ngoto free_buf;\r\n}\r\nvpdma->cb(vpdma->pdev);\r\nfree_buf:\r\nvpdma_unmap_desc_buf(vpdma, &fw_dma_buf);\r\nvpdma_free_desc_buf(&fw_dma_buf);\r\nrel_fw:\r\nrelease_firmware(f);\r\n}\r\nstatic int vpdma_load_firmware(struct vpdma_data *vpdma)\r\n{\r\nint r;\r\nstruct device *dev = &vpdma->pdev->dev;\r\nr = request_firmware_nowait(THIS_MODULE, 1,\r\n(const char *) VPDMA_FIRMWARE, dev, GFP_KERNEL, vpdma,\r\nvpdma_firmware_cb);\r\nif (r) {\r\ndev_err(dev, "firmware not available %s\n", VPDMA_FIRMWARE);\r\nreturn r;\r\n} else {\r\ndev_info(dev, "loading firmware %s\n", VPDMA_FIRMWARE);\r\n}\r\nreturn 0;\r\n}\r\nint vpdma_create(struct platform_device *pdev, struct vpdma_data *vpdma,\r\nvoid (*cb)(struct platform_device *pdev))\r\n{\r\nstruct resource *res;\r\nint r;\r\ndev_dbg(&pdev->dev, "vpdma_create\n");\r\nvpdma->pdev = pdev;\r\nvpdma->cb = cb;\r\nspin_lock_init(&vpdma->lock);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "vpdma");\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "missing platform resources data\n");\r\nreturn -ENODEV;\r\n}\r\nvpdma->base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (!vpdma->base) {\r\ndev_err(&pdev->dev, "failed to ioremap\n");\r\nreturn -ENOMEM;\r\n}\r\nr = vpdma_load_firmware(vpdma);\r\nif (r) {\r\npr_err("failed to load firmware %s\n", VPDMA_FIRMWARE);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}
