int register_vt_notifier(struct notifier_block *nb)\r\n{\r\nreturn atomic_notifier_chain_register(&vt_notifier_list, nb);\r\n}\r\nint unregister_vt_notifier(struct notifier_block *nb)\r\n{\r\nreturn atomic_notifier_chain_unregister(&vt_notifier_list, nb);\r\n}\r\nstatic void notify_write(struct vc_data *vc, unsigned int unicode)\r\n{\r\nstruct vt_notifier_param param = { .vc = vc, .c = unicode };\r\natomic_notifier_call_chain(&vt_notifier_list, VT_WRITE, &param);\r\n}\r\nstatic void notify_update(struct vc_data *vc)\r\n{\r\nstruct vt_notifier_param param = { .vc = vc };\r\natomic_notifier_call_chain(&vt_notifier_list, VT_UPDATE, &param);\r\n}\r\nstatic inline bool con_is_fg(const struct vc_data *vc)\r\n{\r\nreturn vc->vc_num == fg_console;\r\n}\r\nstatic inline bool con_should_update(const struct vc_data *vc)\r\n{\r\nreturn con_is_visible(vc) && !console_blanked;\r\n}\r\nstatic inline unsigned short *screenpos(struct vc_data *vc, int offset, int viewed)\r\n{\r\nunsigned short *p;\r\nif (!viewed)\r\np = (unsigned short *)(vc->vc_origin + offset);\r\nelse if (!vc->vc_sw->con_screen_pos)\r\np = (unsigned short *)(vc->vc_visible_origin + offset);\r\nelse\r\np = vc->vc_sw->con_screen_pos(vc, offset);\r\nreturn p;\r\n}\r\nstatic inline void scrolldelta(int lines)\r\n{\r\nscrollback_delta += lines;\r\nschedule_console_callback();\r\n}\r\nvoid schedule_console_callback(void)\r\n{\r\nschedule_work(&console_work);\r\n}\r\nstatic void con_scroll(struct vc_data *vc, unsigned int t, unsigned int b,\r\nenum con_scroll dir, unsigned int nr)\r\n{\r\nu16 *clear, *d, *s;\r\nif (t + nr >= b)\r\nnr = b - t - 1;\r\nif (b > vc->vc_rows || t >= b || nr < 1)\r\nreturn;\r\nif (con_is_visible(vc) && vc->vc_sw->con_scroll(vc, t, b, dir, nr))\r\nreturn;\r\ns = clear = (u16 *)(vc->vc_origin + vc->vc_size_row * t);\r\nd = (u16 *)(vc->vc_origin + vc->vc_size_row * (t + nr));\r\nif (dir == SM_UP) {\r\nclear = s + (b - t - nr) * vc->vc_cols;\r\nswap(s, d);\r\n}\r\nscr_memmovew(d, s, (b - t - nr) * vc->vc_size_row);\r\nscr_memsetw(clear, vc->vc_video_erase_char, vc->vc_size_row * nr);\r\n}\r\nstatic void do_update_region(struct vc_data *vc, unsigned long start, int count)\r\n{\r\nunsigned int xx, yy, offset;\r\nu16 *p;\r\np = (u16 *) start;\r\nif (!vc->vc_sw->con_getxy) {\r\noffset = (start - vc->vc_origin) / 2;\r\nxx = offset % vc->vc_cols;\r\nyy = offset / vc->vc_cols;\r\n} else {\r\nint nxx, nyy;\r\nstart = vc->vc_sw->con_getxy(vc, start, &nxx, &nyy);\r\nxx = nxx; yy = nyy;\r\n}\r\nfor(;;) {\r\nu16 attrib = scr_readw(p) & 0xff00;\r\nint startx = xx;\r\nu16 *q = p;\r\nwhile (xx < vc->vc_cols && count) {\r\nif (attrib != (scr_readw(p) & 0xff00)) {\r\nif (p > q)\r\nvc->vc_sw->con_putcs(vc, q, p-q, yy, startx);\r\nstartx = xx;\r\nq = p;\r\nattrib = scr_readw(p) & 0xff00;\r\n}\r\np++;\r\nxx++;\r\ncount--;\r\n}\r\nif (p > q)\r\nvc->vc_sw->con_putcs(vc, q, p-q, yy, startx);\r\nif (!count)\r\nbreak;\r\nxx = 0;\r\nyy++;\r\nif (vc->vc_sw->con_getxy) {\r\np = (u16 *)start;\r\nstart = vc->vc_sw->con_getxy(vc, start, NULL, NULL);\r\n}\r\n}\r\n}\r\nvoid update_region(struct vc_data *vc, unsigned long start, int count)\r\n{\r\nWARN_CONSOLE_UNLOCKED();\r\nif (con_should_update(vc)) {\r\nhide_cursor(vc);\r\ndo_update_region(vc, start, count);\r\nset_cursor(vc);\r\n}\r\n}\r\nstatic u8 build_attr(struct vc_data *vc, u8 _color, u8 _intensity, u8 _blink,\r\nu8 _underline, u8 _reverse, u8 _italic)\r\n{\r\nif (vc->vc_sw->con_build_attr)\r\nreturn vc->vc_sw->con_build_attr(vc, _color, _intensity,\r\n_blink, _underline, _reverse, _italic);\r\n{\r\nu8 a = _color;\r\nif (!vc->vc_can_do_color)\r\nreturn _intensity |\r\n(_italic ? 2 : 0) |\r\n(_underline ? 4 : 0) |\r\n(_reverse ? 8 : 0) |\r\n(_blink ? 0x80 : 0);\r\nif (_italic)\r\na = (a & 0xF0) | vc->vc_itcolor;\r\nelse if (_underline)\r\na = (a & 0xf0) | vc->vc_ulcolor;\r\nelse if (_intensity == 0)\r\na = (a & 0xf0) | vc->vc_halfcolor;\r\nif (_reverse)\r\na = ((a) & 0x88) | ((((a) >> 4) | ((a) << 4)) & 0x77);\r\nif (_blink)\r\na ^= 0x80;\r\nif (_intensity == 2)\r\na ^= 0x08;\r\nif (vc->vc_hi_font_mask == 0x100)\r\na <<= 1;\r\nreturn a;\r\n}\r\n}\r\nstatic void update_attr(struct vc_data *vc)\r\n{\r\nvc->vc_attr = build_attr(vc, vc->vc_color, vc->vc_intensity,\r\nvc->vc_blink, vc->vc_underline,\r\nvc->vc_reverse ^ vc->vc_decscnm, vc->vc_italic);\r\nvc->vc_video_erase_char = (build_attr(vc, vc->vc_color, 1, vc->vc_blink, 0, vc->vc_decscnm, 0) << 8) | ' ';\r\n}\r\nvoid invert_screen(struct vc_data *vc, int offset, int count, int viewed)\r\n{\r\nunsigned short *p;\r\nWARN_CONSOLE_UNLOCKED();\r\ncount /= 2;\r\np = screenpos(vc, offset, viewed);\r\nif (vc->vc_sw->con_invert_region) {\r\nvc->vc_sw->con_invert_region(vc, p, count);\r\n} else {\r\nu16 *q = p;\r\nint cnt = count;\r\nu16 a;\r\nif (!vc->vc_can_do_color) {\r\nwhile (cnt--) {\r\na = scr_readw(q);\r\na ^= 0x0800;\r\nscr_writew(a, q);\r\nq++;\r\n}\r\n} else if (vc->vc_hi_font_mask == 0x100) {\r\nwhile (cnt--) {\r\na = scr_readw(q);\r\na = ((a) & 0x11ff) | (((a) & 0xe000) >> 4) | (((a) & 0x0e00) << 4);\r\nscr_writew(a, q);\r\nq++;\r\n}\r\n} else {\r\nwhile (cnt--) {\r\na = scr_readw(q);\r\na = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) | (((a) & 0x0700) << 4);\r\nscr_writew(a, q);\r\nq++;\r\n}\r\n}\r\n}\r\nif (con_should_update(vc))\r\ndo_update_region(vc, (unsigned long) p, count);\r\nnotify_update(vc);\r\n}\r\nvoid complement_pos(struct vc_data *vc, int offset)\r\n{\r\nstatic int old_offset = -1;\r\nstatic unsigned short old;\r\nstatic unsigned short oldx, oldy;\r\nWARN_CONSOLE_UNLOCKED();\r\nif (old_offset != -1 && old_offset >= 0 &&\r\nold_offset < vc->vc_screenbuf_size) {\r\nscr_writew(old, screenpos(vc, old_offset, 1));\r\nif (con_should_update(vc))\r\nvc->vc_sw->con_putc(vc, old, oldy, oldx);\r\nnotify_update(vc);\r\n}\r\nold_offset = offset;\r\nif (offset != -1 && offset >= 0 &&\r\noffset < vc->vc_screenbuf_size) {\r\nunsigned short new;\r\nunsigned short *p;\r\np = screenpos(vc, offset, 1);\r\nold = scr_readw(p);\r\nnew = old ^ vc->vc_complement_mask;\r\nscr_writew(new, p);\r\nif (con_should_update(vc)) {\r\noldx = (offset >> 1) % vc->vc_cols;\r\noldy = (offset >> 1) / vc->vc_cols;\r\nvc->vc_sw->con_putc(vc, new, oldy, oldx);\r\n}\r\nnotify_update(vc);\r\n}\r\n}\r\nstatic void insert_char(struct vc_data *vc, unsigned int nr)\r\n{\r\nunsigned short *p = (unsigned short *) vc->vc_pos;\r\nscr_memmovew(p + nr, p, (vc->vc_cols - vc->vc_x - nr) * 2);\r\nscr_memsetw(p, vc->vc_video_erase_char, nr * 2);\r\nvc->vc_need_wrap = 0;\r\nif (con_should_update(vc))\r\ndo_update_region(vc, (unsigned long) p,\r\nvc->vc_cols - vc->vc_x);\r\n}\r\nstatic void delete_char(struct vc_data *vc, unsigned int nr)\r\n{\r\nunsigned short *p = (unsigned short *) vc->vc_pos;\r\nscr_memcpyw(p, p + nr, (vc->vc_cols - vc->vc_x - nr) * 2);\r\nscr_memsetw(p + vc->vc_cols - vc->vc_x - nr, vc->vc_video_erase_char,\r\nnr * 2);\r\nvc->vc_need_wrap = 0;\r\nif (con_should_update(vc))\r\ndo_update_region(vc, (unsigned long) p,\r\nvc->vc_cols - vc->vc_x);\r\n}\r\nstatic void add_softcursor(struct vc_data *vc)\r\n{\r\nint i = scr_readw((u16 *) vc->vc_pos);\r\nu32 type = vc->vc_cursor_type;\r\nif (! (type & 0x10)) return;\r\nif (softcursor_original != -1) return;\r\nsoftcursor_original = i;\r\ni |= ((type >> 8) & 0xff00 );\r\ni ^= ((type) & 0xff00 );\r\nif ((type & 0x20) && ((softcursor_original & 0x7000) == (i & 0x7000))) i ^= 0x7000;\r\nif ((type & 0x40) && ((i & 0x700) == ((i & 0x7000) >> 4))) i ^= 0x0700;\r\nscr_writew(i, (u16 *) vc->vc_pos);\r\nif (con_should_update(vc))\r\nvc->vc_sw->con_putc(vc, i, vc->vc_y, vc->vc_x);\r\n}\r\nstatic void hide_softcursor(struct vc_data *vc)\r\n{\r\nif (softcursor_original != -1) {\r\nscr_writew(softcursor_original, (u16 *)vc->vc_pos);\r\nif (con_should_update(vc))\r\nvc->vc_sw->con_putc(vc, softcursor_original,\r\nvc->vc_y, vc->vc_x);\r\nsoftcursor_original = -1;\r\n}\r\n}\r\nstatic void hide_cursor(struct vc_data *vc)\r\n{\r\nif (vc == sel_cons)\r\nclear_selection();\r\nvc->vc_sw->con_cursor(vc, CM_ERASE);\r\nhide_softcursor(vc);\r\n}\r\nstatic void set_cursor(struct vc_data *vc)\r\n{\r\nif (!con_is_fg(vc) || console_blanked || vc->vc_mode == KD_GRAPHICS)\r\nreturn;\r\nif (vc->vc_deccm) {\r\nif (vc == sel_cons)\r\nclear_selection();\r\nadd_softcursor(vc);\r\nif ((vc->vc_cursor_type & 0x0f) != 1)\r\nvc->vc_sw->con_cursor(vc, CM_DRAW);\r\n} else\r\nhide_cursor(vc);\r\n}\r\nstatic void set_origin(struct vc_data *vc)\r\n{\r\nWARN_CONSOLE_UNLOCKED();\r\nif (!con_is_visible(vc) ||\r\n!vc->vc_sw->con_set_origin ||\r\n!vc->vc_sw->con_set_origin(vc))\r\nvc->vc_origin = (unsigned long)vc->vc_screenbuf;\r\nvc->vc_visible_origin = vc->vc_origin;\r\nvc->vc_scr_end = vc->vc_origin + vc->vc_screenbuf_size;\r\nvc->vc_pos = vc->vc_origin + vc->vc_size_row * vc->vc_y + 2 * vc->vc_x;\r\n}\r\nstatic void save_screen(struct vc_data *vc)\r\n{\r\nWARN_CONSOLE_UNLOCKED();\r\nif (vc->vc_sw->con_save_screen)\r\nvc->vc_sw->con_save_screen(vc);\r\n}\r\nstatic void flush_scrollback(struct vc_data *vc)\r\n{\r\nWARN_CONSOLE_UNLOCKED();\r\nif (vc->vc_sw->con_flush_scrollback)\r\nvc->vc_sw->con_flush_scrollback(vc);\r\n}\r\nvoid clear_buffer_attributes(struct vc_data *vc)\r\n{\r\nunsigned short *p = (unsigned short *)vc->vc_origin;\r\nint count = vc->vc_screenbuf_size / 2;\r\nint mask = vc->vc_hi_font_mask | 0xff;\r\nfor (; count > 0; count--, p++) {\r\nscr_writew((scr_readw(p)&mask) | (vc->vc_video_erase_char & ~mask), p);\r\n}\r\n}\r\nvoid redraw_screen(struct vc_data *vc, int is_switch)\r\n{\r\nint redraw = 0;\r\nWARN_CONSOLE_UNLOCKED();\r\nif (!vc) {\r\nreturn;\r\n}\r\nif (is_switch) {\r\nstruct vc_data *old_vc = vc_cons[fg_console].d;\r\nif (old_vc == vc)\r\nreturn;\r\nif (!con_is_visible(vc))\r\nredraw = 1;\r\n*vc->vc_display_fg = vc;\r\nfg_console = vc->vc_num;\r\nhide_cursor(old_vc);\r\nif (!con_is_visible(old_vc)) {\r\nsave_screen(old_vc);\r\nset_origin(old_vc);\r\n}\r\nif (tty0dev)\r\nsysfs_notify(&tty0dev->kobj, NULL, "active");\r\n} else {\r\nhide_cursor(vc);\r\nredraw = 1;\r\n}\r\nif (redraw) {\r\nint update;\r\nint old_was_color = vc->vc_can_do_color;\r\nset_origin(vc);\r\nupdate = vc->vc_sw->con_switch(vc);\r\nset_palette(vc);\r\nif (old_was_color != vc->vc_can_do_color) {\r\nupdate_attr(vc);\r\nclear_buffer_attributes(vc);\r\n}\r\nif ((update && vc->vc_mode != KD_GRAPHICS) ||\r\nvt_force_oops_output(vc))\r\ndo_update_region(vc, vc->vc_origin, vc->vc_screenbuf_size / 2);\r\n}\r\nset_cursor(vc);\r\nif (is_switch) {\r\nset_leds();\r\ncompute_shiftstate();\r\nnotify_update(vc);\r\n}\r\n}\r\nint vc_cons_allocated(unsigned int i)\r\n{\r\nreturn (i < MAX_NR_CONSOLES && vc_cons[i].d);\r\n}\r\nstatic void visual_init(struct vc_data *vc, int num, int init)\r\n{\r\nif (vc->vc_sw)\r\nmodule_put(vc->vc_sw->owner);\r\nvc->vc_sw = conswitchp;\r\n#ifndef VT_SINGLE_DRIVER\r\nif (con_driver_map[num])\r\nvc->vc_sw = con_driver_map[num];\r\n#endif\r\n__module_get(vc->vc_sw->owner);\r\nvc->vc_num = num;\r\nvc->vc_display_fg = &master_display_fg;\r\nif (vc->vc_uni_pagedir_loc)\r\ncon_free_unimap(vc);\r\nvc->vc_uni_pagedir_loc = &vc->vc_uni_pagedir;\r\nvc->vc_uni_pagedir = NULL;\r\nvc->vc_hi_font_mask = 0;\r\nvc->vc_complement_mask = 0;\r\nvc->vc_can_do_color = 0;\r\nvc->vc_panic_force_write = false;\r\nvc->vc_cur_blink_ms = DEFAULT_CURSOR_BLINK_MS;\r\nvc->vc_sw->con_init(vc, init);\r\nif (!vc->vc_complement_mask)\r\nvc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;\r\nvc->vc_s_complement_mask = vc->vc_complement_mask;\r\nvc->vc_size_row = vc->vc_cols << 1;\r\nvc->vc_screenbuf_size = vc->vc_rows * vc->vc_size_row;\r\n}\r\nint vc_allocate(unsigned int currcons)\r\n{\r\nstruct vt_notifier_param param;\r\nstruct vc_data *vc;\r\nWARN_CONSOLE_UNLOCKED();\r\nif (currcons >= MAX_NR_CONSOLES)\r\nreturn -ENXIO;\r\nif (vc_cons[currcons].d)\r\nreturn 0;\r\nparam.vc = vc = kzalloc(sizeof(struct vc_data), GFP_KERNEL);\r\nif (!vc)\r\nreturn -ENOMEM;\r\nvc_cons[currcons].d = vc;\r\ntty_port_init(&vc->port);\r\nINIT_WORK(&vc_cons[currcons].SAK_work, vc_SAK);\r\nvisual_init(vc, currcons, 1);\r\nif (!*vc->vc_uni_pagedir_loc)\r\ncon_set_default_unimap(vc);\r\nvc->vc_screenbuf = kmalloc(vc->vc_screenbuf_size, GFP_KERNEL);\r\nif (!vc->vc_screenbuf)\r\ngoto err_free;\r\nif (global_cursor_default == -1)\r\nglobal_cursor_default = 1;\r\nvc_init(vc, vc->vc_rows, vc->vc_cols, 1);\r\nvcs_make_sysfs(currcons);\r\natomic_notifier_call_chain(&vt_notifier_list, VT_ALLOCATE, &param);\r\nreturn 0;\r\nerr_free:\r\nkfree(vc);\r\nvc_cons[currcons].d = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic inline int resize_screen(struct vc_data *vc, int width, int height,\r\nint user)\r\n{\r\nint err = 0;\r\nif (vc->vc_mode != KD_GRAPHICS && vc->vc_sw->con_resize)\r\nerr = vc->vc_sw->con_resize(vc, width, height, user);\r\nreturn err;\r\n}\r\nstatic int vc_do_resize(struct tty_struct *tty, struct vc_data *vc,\r\nunsigned int cols, unsigned int lines)\r\n{\r\nunsigned long old_origin, new_origin, new_scr_end, rlth, rrem, err = 0;\r\nunsigned long end;\r\nunsigned int old_rows, old_row_size;\r\nunsigned int new_cols, new_rows, new_row_size, new_screen_size;\r\nunsigned int user;\r\nunsigned short *newscreen;\r\nWARN_CONSOLE_UNLOCKED();\r\nif (!vc)\r\nreturn -ENXIO;\r\nuser = vc->vc_resize_user;\r\nvc->vc_resize_user = 0;\r\nif (cols > VC_RESIZE_MAXCOL || lines > VC_RESIZE_MAXROW)\r\nreturn -EINVAL;\r\nnew_cols = (cols ? cols : vc->vc_cols);\r\nnew_rows = (lines ? lines : vc->vc_rows);\r\nnew_row_size = new_cols << 1;\r\nnew_screen_size = new_row_size * new_rows;\r\nif (new_cols == vc->vc_cols && new_rows == vc->vc_rows)\r\nreturn 0;\r\nif (new_screen_size > (4 << 20))\r\nreturn -EINVAL;\r\nnewscreen = kmalloc(new_screen_size, GFP_USER);\r\nif (!newscreen)\r\nreturn -ENOMEM;\r\nif (vc == sel_cons)\r\nclear_selection();\r\nold_rows = vc->vc_rows;\r\nold_row_size = vc->vc_size_row;\r\nerr = resize_screen(vc, new_cols, new_rows, user);\r\nif (err) {\r\nkfree(newscreen);\r\nreturn err;\r\n}\r\nvc->vc_rows = new_rows;\r\nvc->vc_cols = new_cols;\r\nvc->vc_size_row = new_row_size;\r\nvc->vc_screenbuf_size = new_screen_size;\r\nrlth = min(old_row_size, new_row_size);\r\nrrem = new_row_size - rlth;\r\nold_origin = vc->vc_origin;\r\nnew_origin = (long) newscreen;\r\nnew_scr_end = new_origin + new_screen_size;\r\nif (vc->vc_y > new_rows) {\r\nif (old_rows - vc->vc_y < new_rows) {\r\nold_origin += (old_rows - new_rows) * old_row_size;\r\n} else {\r\nold_origin += (vc->vc_y - new_rows/2) * old_row_size;\r\n}\r\n}\r\nend = old_origin + old_row_size * min(old_rows, new_rows);\r\nupdate_attr(vc);\r\nwhile (old_origin < end) {\r\nscr_memcpyw((unsigned short *) new_origin,\r\n(unsigned short *) old_origin, rlth);\r\nif (rrem)\r\nscr_memsetw((void *)(new_origin + rlth),\r\nvc->vc_video_erase_char, rrem);\r\nold_origin += old_row_size;\r\nnew_origin += new_row_size;\r\n}\r\nif (new_scr_end > new_origin)\r\nscr_memsetw((void *)new_origin, vc->vc_video_erase_char,\r\nnew_scr_end - new_origin);\r\nkfree(vc->vc_screenbuf);\r\nvc->vc_screenbuf = newscreen;\r\nvc->vc_screenbuf_size = new_screen_size;\r\nset_origin(vc);\r\nvc->vc_top = 0;\r\nvc->vc_bottom = vc->vc_rows;\r\ngotoxy(vc, vc->vc_x, vc->vc_y);\r\nsave_cur(vc);\r\nif (tty) {\r\nstruct winsize ws;\r\nmemset(&ws, 0, sizeof(ws));\r\nws.ws_row = vc->vc_rows;\r\nws.ws_col = vc->vc_cols;\r\nws.ws_ypixel = vc->vc_scan_lines;\r\ntty_do_resize(tty, &ws);\r\n}\r\nif (con_is_visible(vc))\r\nupdate_screen(vc);\r\nvt_event_post(VT_EVENT_RESIZE, vc->vc_num, vc->vc_num);\r\nreturn err;\r\n}\r\nint vc_resize(struct vc_data *vc, unsigned int cols, unsigned int rows)\r\n{\r\nreturn vc_do_resize(vc->port.tty, vc, cols, rows);\r\n}\r\nstatic int vt_resize(struct tty_struct *tty, struct winsize *ws)\r\n{\r\nstruct vc_data *vc = tty->driver_data;\r\nint ret;\r\nconsole_lock();\r\nret = vc_do_resize(tty, vc, ws->ws_col, ws->ws_row);\r\nconsole_unlock();\r\nreturn ret;\r\n}\r\nstruct vc_data *vc_deallocate(unsigned int currcons)\r\n{\r\nstruct vc_data *vc = NULL;\r\nWARN_CONSOLE_UNLOCKED();\r\nif (vc_cons_allocated(currcons)) {\r\nstruct vt_notifier_param param;\r\nparam.vc = vc = vc_cons[currcons].d;\r\natomic_notifier_call_chain(&vt_notifier_list, VT_DEALLOCATE, &param);\r\nvcs_remove_sysfs(currcons);\r\nvc->vc_sw->con_deinit(vc);\r\nput_pid(vc->vt_pid);\r\nmodule_put(vc->vc_sw->owner);\r\nkfree(vc->vc_screenbuf);\r\nvc_cons[currcons].d = NULL;\r\n}\r\nreturn vc;\r\n}\r\nstatic void gotoxy(struct vc_data *vc, int new_x, int new_y)\r\n{\r\nint min_y, max_y;\r\nif (new_x < 0)\r\nvc->vc_x = 0;\r\nelse {\r\nif (new_x >= vc->vc_cols)\r\nvc->vc_x = vc->vc_cols - 1;\r\nelse\r\nvc->vc_x = new_x;\r\n}\r\nif (vc->vc_decom) {\r\nmin_y = vc->vc_top;\r\nmax_y = vc->vc_bottom;\r\n} else {\r\nmin_y = 0;\r\nmax_y = vc->vc_rows;\r\n}\r\nif (new_y < min_y)\r\nvc->vc_y = min_y;\r\nelse if (new_y >= max_y)\r\nvc->vc_y = max_y - 1;\r\nelse\r\nvc->vc_y = new_y;\r\nvc->vc_pos = vc->vc_origin + vc->vc_y * vc->vc_size_row + (vc->vc_x<<1);\r\nvc->vc_need_wrap = 0;\r\n}\r\nstatic void gotoxay(struct vc_data *vc, int new_x, int new_y)\r\n{\r\ngotoxy(vc, new_x, vc->vc_decom ? (vc->vc_top + new_y) : new_y);\r\n}\r\nvoid scrollback(struct vc_data *vc)\r\n{\r\nscrolldelta(-(vc->vc_rows / 2));\r\n}\r\nvoid scrollfront(struct vc_data *vc, int lines)\r\n{\r\nif (!lines)\r\nlines = vc->vc_rows / 2;\r\nscrolldelta(lines);\r\n}\r\nstatic void lf(struct vc_data *vc)\r\n{\r\nif (vc->vc_y + 1 == vc->vc_bottom)\r\ncon_scroll(vc, vc->vc_top, vc->vc_bottom, SM_UP, 1);\r\nelse if (vc->vc_y < vc->vc_rows - 1) {\r\nvc->vc_y++;\r\nvc->vc_pos += vc->vc_size_row;\r\n}\r\nvc->vc_need_wrap = 0;\r\nnotify_write(vc, '\n');\r\n}\r\nstatic void ri(struct vc_data *vc)\r\n{\r\nif (vc->vc_y == vc->vc_top)\r\ncon_scroll(vc, vc->vc_top, vc->vc_bottom, SM_DOWN, 1);\r\nelse if (vc->vc_y > 0) {\r\nvc->vc_y--;\r\nvc->vc_pos -= vc->vc_size_row;\r\n}\r\nvc->vc_need_wrap = 0;\r\n}\r\nstatic inline void cr(struct vc_data *vc)\r\n{\r\nvc->vc_pos -= vc->vc_x << 1;\r\nvc->vc_need_wrap = vc->vc_x = 0;\r\nnotify_write(vc, '\r');\r\n}\r\nstatic inline void bs(struct vc_data *vc)\r\n{\r\nif (vc->vc_x) {\r\nvc->vc_pos -= 2;\r\nvc->vc_x--;\r\nvc->vc_need_wrap = 0;\r\nnotify_write(vc, '\b');\r\n}\r\n}\r\nstatic inline void del(struct vc_data *vc)\r\n{\r\n}\r\nstatic void csi_J(struct vc_data *vc, int vpar)\r\n{\r\nunsigned int count;\r\nunsigned short * start;\r\nswitch (vpar) {\r\ncase 0:\r\ncount = (vc->vc_scr_end - vc->vc_pos) >> 1;\r\nstart = (unsigned short *)vc->vc_pos;\r\nbreak;\r\ncase 1:\r\ncount = ((vc->vc_pos - vc->vc_origin) >> 1) + 1;\r\nstart = (unsigned short *)vc->vc_origin;\r\nbreak;\r\ncase 3:\r\nscr_memsetw(vc->vc_screenbuf, vc->vc_video_erase_char,\r\nvc->vc_screenbuf_size);\r\nflush_scrollback(vc);\r\nset_origin(vc);\r\nif (con_is_visible(vc))\r\nupdate_screen(vc);\r\ncase 2:\r\ncount = vc->vc_cols * vc->vc_rows;\r\nstart = (unsigned short *)vc->vc_origin;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nscr_memsetw(start, vc->vc_video_erase_char, 2 * count);\r\nif (con_should_update(vc))\r\ndo_update_region(vc, (unsigned long) start, count);\r\nvc->vc_need_wrap = 0;\r\n}\r\nstatic void csi_K(struct vc_data *vc, int vpar)\r\n{\r\nunsigned int count;\r\nunsigned short * start;\r\nswitch (vpar) {\r\ncase 0:\r\ncount = vc->vc_cols - vc->vc_x;\r\nstart = (unsigned short *)vc->vc_pos;\r\nbreak;\r\ncase 1:\r\nstart = (unsigned short *)(vc->vc_pos - (vc->vc_x << 1));\r\ncount = vc->vc_x + 1;\r\nbreak;\r\ncase 2:\r\nstart = (unsigned short *)(vc->vc_pos - (vc->vc_x << 1));\r\ncount = vc->vc_cols;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nscr_memsetw(start, vc->vc_video_erase_char, 2 * count);\r\nvc->vc_need_wrap = 0;\r\nif (con_should_update(vc))\r\ndo_update_region(vc, (unsigned long) start, count);\r\n}\r\nstatic void csi_X(struct vc_data *vc, int vpar)\r\n{\r\nint count;\r\nif (!vpar)\r\nvpar++;\r\ncount = (vpar > vc->vc_cols - vc->vc_x) ? (vc->vc_cols - vc->vc_x) : vpar;\r\nscr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);\r\nif (con_should_update(vc))\r\nvc->vc_sw->con_clear(vc, vc->vc_y, vc->vc_x, 1, count);\r\nvc->vc_need_wrap = 0;\r\n}\r\nstatic void default_attr(struct vc_data *vc)\r\n{\r\nvc->vc_intensity = 1;\r\nvc->vc_italic = 0;\r\nvc->vc_underline = 0;\r\nvc->vc_reverse = 0;\r\nvc->vc_blink = 0;\r\nvc->vc_color = vc->vc_def_color;\r\n}\r\nstatic void rgb_from_256(int i, struct rgb *c)\r\n{\r\nif (i < 8) {\r\nc->r = i&1 ? 0xaa : 0x00;\r\nc->g = i&2 ? 0xaa : 0x00;\r\nc->b = i&4 ? 0xaa : 0x00;\r\n} else if (i < 16) {\r\nc->r = i&1 ? 0xff : 0x55;\r\nc->g = i&2 ? 0xff : 0x55;\r\nc->b = i&4 ? 0xff : 0x55;\r\n} else if (i < 232) {\r\nc->r = (i - 16) / 36 * 85 / 2;\r\nc->g = (i - 16) / 6 % 6 * 85 / 2;\r\nc->b = (i - 16) % 6 * 85 / 2;\r\n} else\r\nc->r = c->g = c->b = i * 10 - 2312;\r\n}\r\nstatic void rgb_foreground(struct vc_data *vc, const struct rgb *c)\r\n{\r\nu8 hue = 0, max = max3(c->r, c->g, c->b);\r\nif (c->r > max / 2)\r\nhue |= 4;\r\nif (c->g > max / 2)\r\nhue |= 2;\r\nif (c->b > max / 2)\r\nhue |= 1;\r\nif (hue == 7 && max <= 0x55) {\r\nhue = 0;\r\nvc->vc_intensity = 2;\r\n} else if (max > 0xaa)\r\nvc->vc_intensity = 2;\r\nelse\r\nvc->vc_intensity = 1;\r\nvc->vc_color = (vc->vc_color & 0xf0) | hue;\r\n}\r\nstatic void rgb_background(struct vc_data *vc, const struct rgb *c)\r\n{\r\nvc->vc_color = (vc->vc_color & 0x0f)\r\n| (c->r&0x80) >> 1 | (c->g&0x80) >> 2 | (c->b&0x80) >> 3;\r\n}\r\nstatic int vc_t416_color(struct vc_data *vc, int i,\r\nvoid(*set_color)(struct vc_data *vc, const struct rgb *c))\r\n{\r\nstruct rgb c;\r\ni++;\r\nif (i > vc->vc_npar)\r\nreturn i;\r\nif (vc->vc_par[i] == 5 && i + 1 <= vc->vc_npar) {\r\ni++;\r\nrgb_from_256(vc->vc_par[i], &c);\r\n} else if (vc->vc_par[i] == 2 && i + 3 <= vc->vc_npar) {\r\nc.r = vc->vc_par[i + 1];\r\nc.g = vc->vc_par[i + 2];\r\nc.b = vc->vc_par[i + 3];\r\ni += 3;\r\n} else\r\nreturn i;\r\nset_color(vc, &c);\r\nreturn i;\r\n}\r\nstatic void csi_m(struct vc_data *vc)\r\n{\r\nint i;\r\nfor (i = 0; i <= vc->vc_npar; i++)\r\nswitch (vc->vc_par[i]) {\r\ncase 0:\r\ndefault_attr(vc);\r\nbreak;\r\ncase 1:\r\nvc->vc_intensity = 2;\r\nbreak;\r\ncase 2:\r\nvc->vc_intensity = 0;\r\nbreak;\r\ncase 3:\r\nvc->vc_italic = 1;\r\nbreak;\r\ncase 4:\r\nvc->vc_underline = 1;\r\nbreak;\r\ncase 5:\r\nvc->vc_blink = 1;\r\nbreak;\r\ncase 7:\r\nvc->vc_reverse = 1;\r\nbreak;\r\ncase 10:\r\nvc->vc_translate = set_translate(vc->vc_charset == 0\r\n? vc->vc_G0_charset\r\n: vc->vc_G1_charset, vc);\r\nvc->vc_disp_ctrl = 0;\r\nvc->vc_toggle_meta = 0;\r\nbreak;\r\ncase 11:\r\nvc->vc_translate = set_translate(IBMPC_MAP, vc);\r\nvc->vc_disp_ctrl = 1;\r\nvc->vc_toggle_meta = 0;\r\nbreak;\r\ncase 12:\r\nvc->vc_translate = set_translate(IBMPC_MAP, vc);\r\nvc->vc_disp_ctrl = 1;\r\nvc->vc_toggle_meta = 1;\r\nbreak;\r\ncase 21:\r\ncase 22:\r\nvc->vc_intensity = 1;\r\nbreak;\r\ncase 23:\r\nvc->vc_italic = 0;\r\nbreak;\r\ncase 24:\r\nvc->vc_underline = 0;\r\nbreak;\r\ncase 25:\r\nvc->vc_blink = 0;\r\nbreak;\r\ncase 27:\r\nvc->vc_reverse = 0;\r\nbreak;\r\ncase 38:\r\ni = vc_t416_color(vc, i, rgb_foreground);\r\nbreak;\r\ncase 48:\r\ni = vc_t416_color(vc, i, rgb_background);\r\nbreak;\r\ncase 39:\r\nvc->vc_color = (vc->vc_def_color & 0x0f) |\r\n(vc->vc_color & 0xf0);\r\nbreak;\r\ncase 49:\r\nvc->vc_color = (vc->vc_def_color & 0xf0) |\r\n(vc->vc_color & 0x0f);\r\nbreak;\r\ndefault:\r\nif (vc->vc_par[i] >= 90 && vc->vc_par[i] <= 107) {\r\nif (vc->vc_par[i] < 100)\r\nvc->vc_intensity = 2;\r\nvc->vc_par[i] -= 60;\r\n}\r\nif (vc->vc_par[i] >= 30 && vc->vc_par[i] <= 37)\r\nvc->vc_color = color_table[vc->vc_par[i] - 30]\r\n| (vc->vc_color & 0xf0);\r\nelse if (vc->vc_par[i] >= 40 && vc->vc_par[i] <= 47)\r\nvc->vc_color = (color_table[vc->vc_par[i] - 40] << 4)\r\n| (vc->vc_color & 0x0f);\r\nbreak;\r\n}\r\nupdate_attr(vc);\r\n}\r\nstatic void respond_string(const char *p, struct tty_port *port)\r\n{\r\nwhile (*p) {\r\ntty_insert_flip_char(port, *p, 0);\r\np++;\r\n}\r\ntty_schedule_flip(port);\r\n}\r\nstatic void cursor_report(struct vc_data *vc, struct tty_struct *tty)\r\n{\r\nchar buf[40];\r\nsprintf(buf, "\033[%d;%dR", vc->vc_y + (vc->vc_decom ? vc->vc_top + 1 : 1), vc->vc_x + 1);\r\nrespond_string(buf, tty->port);\r\n}\r\nstatic inline void status_report(struct tty_struct *tty)\r\n{\r\nrespond_string("\033[0n", tty->port);\r\n}\r\nstatic inline void respond_ID(struct tty_struct *tty)\r\n{\r\nrespond_string(VT102ID, tty->port);\r\n}\r\nvoid mouse_report(struct tty_struct *tty, int butt, int mrx, int mry)\r\n{\r\nchar buf[8];\r\nsprintf(buf, "\033[M%c%c%c", (char)(' ' + butt), (char)('!' + mrx),\r\n(char)('!' + mry));\r\nrespond_string(buf, tty->port);\r\n}\r\nint mouse_reporting(void)\r\n{\r\nreturn vc_cons[fg_console].d->vc_report_mouse;\r\n}\r\nstatic void set_mode(struct vc_data *vc, int on_off)\r\n{\r\nint i;\r\nfor (i = 0; i <= vc->vc_npar; i++)\r\nif (vc->vc_ques) {\r\nswitch(vc->vc_par[i]) {\r\ncase 1:\r\nif (on_off)\r\nset_kbd(vc, decckm);\r\nelse\r\nclr_kbd(vc, decckm);\r\nbreak;\r\ncase 3:\r\n#if 0\r\nvc_resize(deccolm ? 132 : 80, vc->vc_rows);\r\n#endif\r\nbreak;\r\ncase 5:\r\nif (vc->vc_decscnm != on_off) {\r\nvc->vc_decscnm = on_off;\r\ninvert_screen(vc, 0, vc->vc_screenbuf_size, 0);\r\nupdate_attr(vc);\r\n}\r\nbreak;\r\ncase 6:\r\nvc->vc_decom = on_off;\r\ngotoxay(vc, 0, 0);\r\nbreak;\r\ncase 7:\r\nvc->vc_decawm = on_off;\r\nbreak;\r\ncase 8:\r\nif (on_off)\r\nset_kbd(vc, decarm);\r\nelse\r\nclr_kbd(vc, decarm);\r\nbreak;\r\ncase 9:\r\nvc->vc_report_mouse = on_off ? 1 : 0;\r\nbreak;\r\ncase 25:\r\nvc->vc_deccm = on_off;\r\nbreak;\r\ncase 1000:\r\nvc->vc_report_mouse = on_off ? 2 : 0;\r\nbreak;\r\n}\r\n} else {\r\nswitch(vc->vc_par[i]) {\r\ncase 3:\r\nvc->vc_disp_ctrl = on_off;\r\nbreak;\r\ncase 4:\r\nvc->vc_decim = on_off;\r\nbreak;\r\ncase 20:\r\nif (on_off)\r\nset_kbd(vc, lnm);\r\nelse\r\nclr_kbd(vc, lnm);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void setterm_command(struct vc_data *vc)\r\n{\r\nswitch(vc->vc_par[0]) {\r\ncase 1:\r\nif (vc->vc_can_do_color &&\r\nvc->vc_par[1] < 16) {\r\nvc->vc_ulcolor = color_table[vc->vc_par[1]];\r\nif (vc->vc_underline)\r\nupdate_attr(vc);\r\n}\r\nbreak;\r\ncase 2:\r\nif (vc->vc_can_do_color &&\r\nvc->vc_par[1] < 16) {\r\nvc->vc_halfcolor = color_table[vc->vc_par[1]];\r\nif (vc->vc_intensity == 0)\r\nupdate_attr(vc);\r\n}\r\nbreak;\r\ncase 8:\r\nvc->vc_def_color = vc->vc_attr;\r\nif (vc->vc_hi_font_mask == 0x100)\r\nvc->vc_def_color >>= 1;\r\ndefault_attr(vc);\r\nupdate_attr(vc);\r\nbreak;\r\ncase 9:\r\nblankinterval = ((vc->vc_par[1] < 60) ? vc->vc_par[1] : 60) * 60;\r\npoke_blanked_console();\r\nbreak;\r\ncase 10:\r\nif (vc->vc_npar >= 1)\r\nvc->vc_bell_pitch = vc->vc_par[1];\r\nelse\r\nvc->vc_bell_pitch = DEFAULT_BELL_PITCH;\r\nbreak;\r\ncase 11:\r\nif (vc->vc_npar >= 1)\r\nvc->vc_bell_duration = (vc->vc_par[1] < 2000) ?\r\nmsecs_to_jiffies(vc->vc_par[1]) : 0;\r\nelse\r\nvc->vc_bell_duration = DEFAULT_BELL_DURATION;\r\nbreak;\r\ncase 12:\r\nif (vc->vc_par[1] >= 1 && vc_cons_allocated(vc->vc_par[1] - 1))\r\nset_console(vc->vc_par[1] - 1);\r\nbreak;\r\ncase 13:\r\npoke_blanked_console();\r\nbreak;\r\ncase 14:\r\nvesa_off_interval = ((vc->vc_par[1] < 60) ? vc->vc_par[1] : 60) * 60 * HZ;\r\nbreak;\r\ncase 15:\r\nset_console(last_console);\r\nbreak;\r\ncase 16:\r\nif (vc->vc_npar >= 1 && vc->vc_par[1] >= 50 &&\r\nvc->vc_par[1] <= USHRT_MAX)\r\nvc->vc_cur_blink_ms = vc->vc_par[1];\r\nelse\r\nvc->vc_cur_blink_ms = DEFAULT_CURSOR_BLINK_MS;\r\nbreak;\r\n}\r\n}\r\nstatic void csi_at(struct vc_data *vc, unsigned int nr)\r\n{\r\nif (nr > vc->vc_cols - vc->vc_x)\r\nnr = vc->vc_cols - vc->vc_x;\r\nelse if (!nr)\r\nnr = 1;\r\ninsert_char(vc, nr);\r\n}\r\nstatic void csi_L(struct vc_data *vc, unsigned int nr)\r\n{\r\nif (nr > vc->vc_rows - vc->vc_y)\r\nnr = vc->vc_rows - vc->vc_y;\r\nelse if (!nr)\r\nnr = 1;\r\ncon_scroll(vc, vc->vc_y, vc->vc_bottom, SM_DOWN, nr);\r\nvc->vc_need_wrap = 0;\r\n}\r\nstatic void csi_P(struct vc_data *vc, unsigned int nr)\r\n{\r\nif (nr > vc->vc_cols - vc->vc_x)\r\nnr = vc->vc_cols - vc->vc_x;\r\nelse if (!nr)\r\nnr = 1;\r\ndelete_char(vc, nr);\r\n}\r\nstatic void csi_M(struct vc_data *vc, unsigned int nr)\r\n{\r\nif (nr > vc->vc_rows - vc->vc_y)\r\nnr = vc->vc_rows - vc->vc_y;\r\nelse if (!nr)\r\nnr=1;\r\ncon_scroll(vc, vc->vc_y, vc->vc_bottom, SM_UP, nr);\r\nvc->vc_need_wrap = 0;\r\n}\r\nstatic void save_cur(struct vc_data *vc)\r\n{\r\nvc->vc_saved_x = vc->vc_x;\r\nvc->vc_saved_y = vc->vc_y;\r\nvc->vc_s_intensity = vc->vc_intensity;\r\nvc->vc_s_italic = vc->vc_italic;\r\nvc->vc_s_underline = vc->vc_underline;\r\nvc->vc_s_blink = vc->vc_blink;\r\nvc->vc_s_reverse = vc->vc_reverse;\r\nvc->vc_s_charset = vc->vc_charset;\r\nvc->vc_s_color = vc->vc_color;\r\nvc->vc_saved_G0 = vc->vc_G0_charset;\r\nvc->vc_saved_G1 = vc->vc_G1_charset;\r\n}\r\nstatic void restore_cur(struct vc_data *vc)\r\n{\r\ngotoxy(vc, vc->vc_saved_x, vc->vc_saved_y);\r\nvc->vc_intensity = vc->vc_s_intensity;\r\nvc->vc_italic = vc->vc_s_italic;\r\nvc->vc_underline = vc->vc_s_underline;\r\nvc->vc_blink = vc->vc_s_blink;\r\nvc->vc_reverse = vc->vc_s_reverse;\r\nvc->vc_charset = vc->vc_s_charset;\r\nvc->vc_color = vc->vc_s_color;\r\nvc->vc_G0_charset = vc->vc_saved_G0;\r\nvc->vc_G1_charset = vc->vc_saved_G1;\r\nvc->vc_translate = set_translate(vc->vc_charset ? vc->vc_G1_charset : vc->vc_G0_charset, vc);\r\nupdate_attr(vc);\r\nvc->vc_need_wrap = 0;\r\n}\r\nstatic void reset_terminal(struct vc_data *vc, int do_clear)\r\n{\r\nvc->vc_top = 0;\r\nvc->vc_bottom = vc->vc_rows;\r\nvc->vc_state = ESnormal;\r\nvc->vc_ques = 0;\r\nvc->vc_translate = set_translate(LAT1_MAP, vc);\r\nvc->vc_G0_charset = LAT1_MAP;\r\nvc->vc_G1_charset = GRAF_MAP;\r\nvc->vc_charset = 0;\r\nvc->vc_need_wrap = 0;\r\nvc->vc_report_mouse = 0;\r\nvc->vc_utf = default_utf8;\r\nvc->vc_utf_count = 0;\r\nvc->vc_disp_ctrl = 0;\r\nvc->vc_toggle_meta = 0;\r\nvc->vc_decscnm = 0;\r\nvc->vc_decom = 0;\r\nvc->vc_decawm = 1;\r\nvc->vc_deccm = global_cursor_default;\r\nvc->vc_decim = 0;\r\nvt_reset_keyboard(vc->vc_num);\r\nvc->vc_cursor_type = cur_default;\r\nvc->vc_complement_mask = vc->vc_s_complement_mask;\r\ndefault_attr(vc);\r\nupdate_attr(vc);\r\nvc->vc_tab_stop[0] = 0x01010100;\r\nvc->vc_tab_stop[1] =\r\nvc->vc_tab_stop[2] =\r\nvc->vc_tab_stop[3] =\r\nvc->vc_tab_stop[4] =\r\nvc->vc_tab_stop[5] =\r\nvc->vc_tab_stop[6] =\r\nvc->vc_tab_stop[7] = 0x01010101;\r\nvc->vc_bell_pitch = DEFAULT_BELL_PITCH;\r\nvc->vc_bell_duration = DEFAULT_BELL_DURATION;\r\nvc->vc_cur_blink_ms = DEFAULT_CURSOR_BLINK_MS;\r\ngotoxy(vc, 0, 0);\r\nsave_cur(vc);\r\nif (do_clear)\r\ncsi_J(vc, 2);\r\n}\r\nstatic void do_con_trol(struct tty_struct *tty, struct vc_data *vc, int c)\r\n{\r\nif (vc->vc_state == ESosc && c>=8 && c<=13)\r\nreturn;\r\nswitch (c) {\r\ncase 0:\r\nreturn;\r\ncase 7:\r\nif (vc->vc_state == ESosc)\r\nvc->vc_state = ESnormal;\r\nelse if (vc->vc_bell_duration)\r\nkd_mksound(vc->vc_bell_pitch, vc->vc_bell_duration);\r\nreturn;\r\ncase 8:\r\nbs(vc);\r\nreturn;\r\ncase 9:\r\nvc->vc_pos -= (vc->vc_x << 1);\r\nwhile (vc->vc_x < vc->vc_cols - 1) {\r\nvc->vc_x++;\r\nif (vc->vc_tab_stop[vc->vc_x >> 5] & (1 << (vc->vc_x & 31)))\r\nbreak;\r\n}\r\nvc->vc_pos += (vc->vc_x << 1);\r\nnotify_write(vc, '\t');\r\nreturn;\r\ncase 10: case 11: case 12:\r\nlf(vc);\r\nif (!is_kbd(vc, lnm))\r\nreturn;\r\ncase 13:\r\ncr(vc);\r\nreturn;\r\ncase 14:\r\nvc->vc_charset = 1;\r\nvc->vc_translate = set_translate(vc->vc_G1_charset, vc);\r\nvc->vc_disp_ctrl = 1;\r\nreturn;\r\ncase 15:\r\nvc->vc_charset = 0;\r\nvc->vc_translate = set_translate(vc->vc_G0_charset, vc);\r\nvc->vc_disp_ctrl = 0;\r\nreturn;\r\ncase 24: case 26:\r\nvc->vc_state = ESnormal;\r\nreturn;\r\ncase 27:\r\nvc->vc_state = ESesc;\r\nreturn;\r\ncase 127:\r\ndel(vc);\r\nreturn;\r\ncase 128+27:\r\nvc->vc_state = ESsquare;\r\nreturn;\r\n}\r\nswitch(vc->vc_state) {\r\ncase ESesc:\r\nvc->vc_state = ESnormal;\r\nswitch (c) {\r\ncase '[':\r\nvc->vc_state = ESsquare;\r\nreturn;\r\ncase ']':\r\nvc->vc_state = ESnonstd;\r\nreturn;\r\ncase '%':\r\nvc->vc_state = ESpercent;\r\nreturn;\r\ncase 'E':\r\ncr(vc);\r\nlf(vc);\r\nreturn;\r\ncase 'M':\r\nri(vc);\r\nreturn;\r\ncase 'D':\r\nlf(vc);\r\nreturn;\r\ncase 'H':\r\nvc->vc_tab_stop[vc->vc_x >> 5] |= (1 << (vc->vc_x & 31));\r\nreturn;\r\ncase 'Z':\r\nrespond_ID(tty);\r\nreturn;\r\ncase '7':\r\nsave_cur(vc);\r\nreturn;\r\ncase '8':\r\nrestore_cur(vc);\r\nreturn;\r\ncase '(':\r\nvc->vc_state = ESsetG0;\r\nreturn;\r\ncase ')':\r\nvc->vc_state = ESsetG1;\r\nreturn;\r\ncase '#':\r\nvc->vc_state = EShash;\r\nreturn;\r\ncase 'c':\r\nreset_terminal(vc, 1);\r\nreturn;\r\ncase '>':\r\nclr_kbd(vc, kbdapplic);\r\nreturn;\r\ncase '=':\r\nset_kbd(vc, kbdapplic);\r\nreturn;\r\n}\r\nreturn;\r\ncase ESnonstd:\r\nif (c=='P') {\r\nfor (vc->vc_npar = 0; vc->vc_npar < NPAR; vc->vc_npar++)\r\nvc->vc_par[vc->vc_npar] = 0;\r\nvc->vc_npar = 0;\r\nvc->vc_state = ESpalette;\r\nreturn;\r\n} else if (c=='R') {\r\nreset_palette(vc);\r\nvc->vc_state = ESnormal;\r\n} else if (c>='0' && c<='9')\r\nvc->vc_state = ESosc;\r\nelse\r\nvc->vc_state = ESnormal;\r\nreturn;\r\ncase ESpalette:\r\nif (isxdigit(c)) {\r\nvc->vc_par[vc->vc_npar++] = hex_to_bin(c);\r\nif (vc->vc_npar == 7) {\r\nint i = vc->vc_par[0] * 3, j = 1;\r\nvc->vc_palette[i] = 16 * vc->vc_par[j++];\r\nvc->vc_palette[i++] += vc->vc_par[j++];\r\nvc->vc_palette[i] = 16 * vc->vc_par[j++];\r\nvc->vc_palette[i++] += vc->vc_par[j++];\r\nvc->vc_palette[i] = 16 * vc->vc_par[j++];\r\nvc->vc_palette[i] += vc->vc_par[j];\r\nset_palette(vc);\r\nvc->vc_state = ESnormal;\r\n}\r\n} else\r\nvc->vc_state = ESnormal;\r\nreturn;\r\ncase ESsquare:\r\nfor (vc->vc_npar = 0; vc->vc_npar < NPAR; vc->vc_npar++)\r\nvc->vc_par[vc->vc_npar] = 0;\r\nvc->vc_npar = 0;\r\nvc->vc_state = ESgetpars;\r\nif (c == '[') {\r\nvc->vc_state=ESfunckey;\r\nreturn;\r\n}\r\nvc->vc_ques = (c == '?');\r\nif (vc->vc_ques)\r\nreturn;\r\ncase ESgetpars:\r\nif (c == ';' && vc->vc_npar < NPAR - 1) {\r\nvc->vc_npar++;\r\nreturn;\r\n} else if (c>='0' && c<='9') {\r\nvc->vc_par[vc->vc_npar] *= 10;\r\nvc->vc_par[vc->vc_npar] += c - '0';\r\nreturn;\r\n}\r\nvc->vc_state = ESnormal;\r\nswitch(c) {\r\ncase 'h':\r\nset_mode(vc, 1);\r\nreturn;\r\ncase 'l':\r\nset_mode(vc, 0);\r\nreturn;\r\ncase 'c':\r\nif (vc->vc_ques) {\r\nif (vc->vc_par[0])\r\nvc->vc_cursor_type = vc->vc_par[0] | (vc->vc_par[1] << 8) | (vc->vc_par[2] << 16);\r\nelse\r\nvc->vc_cursor_type = cur_default;\r\nreturn;\r\n}\r\nbreak;\r\ncase 'm':\r\nif (vc->vc_ques) {\r\nclear_selection();\r\nif (vc->vc_par[0])\r\nvc->vc_complement_mask = vc->vc_par[0] << 8 | vc->vc_par[1];\r\nelse\r\nvc->vc_complement_mask = vc->vc_s_complement_mask;\r\nreturn;\r\n}\r\nbreak;\r\ncase 'n':\r\nif (!vc->vc_ques) {\r\nif (vc->vc_par[0] == 5)\r\nstatus_report(tty);\r\nelse if (vc->vc_par[0] == 6)\r\ncursor_report(vc, tty);\r\n}\r\nreturn;\r\n}\r\nif (vc->vc_ques) {\r\nvc->vc_ques = 0;\r\nreturn;\r\n}\r\nswitch(c) {\r\ncase 'G': case '`':\r\nif (vc->vc_par[0])\r\nvc->vc_par[0]--;\r\ngotoxy(vc, vc->vc_par[0], vc->vc_y);\r\nreturn;\r\ncase 'A':\r\nif (!vc->vc_par[0])\r\nvc->vc_par[0]++;\r\ngotoxy(vc, vc->vc_x, vc->vc_y - vc->vc_par[0]);\r\nreturn;\r\ncase 'B': case 'e':\r\nif (!vc->vc_par[0])\r\nvc->vc_par[0]++;\r\ngotoxy(vc, vc->vc_x, vc->vc_y + vc->vc_par[0]);\r\nreturn;\r\ncase 'C': case 'a':\r\nif (!vc->vc_par[0])\r\nvc->vc_par[0]++;\r\ngotoxy(vc, vc->vc_x + vc->vc_par[0], vc->vc_y);\r\nreturn;\r\ncase 'D':\r\nif (!vc->vc_par[0])\r\nvc->vc_par[0]++;\r\ngotoxy(vc, vc->vc_x - vc->vc_par[0], vc->vc_y);\r\nreturn;\r\ncase 'E':\r\nif (!vc->vc_par[0])\r\nvc->vc_par[0]++;\r\ngotoxy(vc, 0, vc->vc_y + vc->vc_par[0]);\r\nreturn;\r\ncase 'F':\r\nif (!vc->vc_par[0])\r\nvc->vc_par[0]++;\r\ngotoxy(vc, 0, vc->vc_y - vc->vc_par[0]);\r\nreturn;\r\ncase 'd':\r\nif (vc->vc_par[0])\r\nvc->vc_par[0]--;\r\ngotoxay(vc, vc->vc_x ,vc->vc_par[0]);\r\nreturn;\r\ncase 'H': case 'f':\r\nif (vc->vc_par[0])\r\nvc->vc_par[0]--;\r\nif (vc->vc_par[1])\r\nvc->vc_par[1]--;\r\ngotoxay(vc, vc->vc_par[1], vc->vc_par[0]);\r\nreturn;\r\ncase 'J':\r\ncsi_J(vc, vc->vc_par[0]);\r\nreturn;\r\ncase 'K':\r\ncsi_K(vc, vc->vc_par[0]);\r\nreturn;\r\ncase 'L':\r\ncsi_L(vc, vc->vc_par[0]);\r\nreturn;\r\ncase 'M':\r\ncsi_M(vc, vc->vc_par[0]);\r\nreturn;\r\ncase 'P':\r\ncsi_P(vc, vc->vc_par[0]);\r\nreturn;\r\ncase 'c':\r\nif (!vc->vc_par[0])\r\nrespond_ID(tty);\r\nreturn;\r\ncase 'g':\r\nif (!vc->vc_par[0])\r\nvc->vc_tab_stop[vc->vc_x >> 5] &= ~(1 << (vc->vc_x & 31));\r\nelse if (vc->vc_par[0] == 3) {\r\nvc->vc_tab_stop[0] =\r\nvc->vc_tab_stop[1] =\r\nvc->vc_tab_stop[2] =\r\nvc->vc_tab_stop[3] =\r\nvc->vc_tab_stop[4] =\r\nvc->vc_tab_stop[5] =\r\nvc->vc_tab_stop[6] =\r\nvc->vc_tab_stop[7] = 0;\r\n}\r\nreturn;\r\ncase 'm':\r\ncsi_m(vc);\r\nreturn;\r\ncase 'q':\r\nif (vc->vc_par[0] < 4)\r\nvt_set_led_state(vc->vc_num,\r\n(vc->vc_par[0] < 3) ? vc->vc_par[0] : 4);\r\nreturn;\r\ncase 'r':\r\nif (!vc->vc_par[0])\r\nvc->vc_par[0]++;\r\nif (!vc->vc_par[1])\r\nvc->vc_par[1] = vc->vc_rows;\r\nif (vc->vc_par[0] < vc->vc_par[1] &&\r\nvc->vc_par[1] <= vc->vc_rows) {\r\nvc->vc_top = vc->vc_par[0] - 1;\r\nvc->vc_bottom = vc->vc_par[1];\r\ngotoxay(vc, 0, 0);\r\n}\r\nreturn;\r\ncase 's':\r\nsave_cur(vc);\r\nreturn;\r\ncase 'u':\r\nrestore_cur(vc);\r\nreturn;\r\ncase 'X':\r\ncsi_X(vc, vc->vc_par[0]);\r\nreturn;\r\ncase '@':\r\ncsi_at(vc, vc->vc_par[0]);\r\nreturn;\r\ncase ']':\r\nsetterm_command(vc);\r\nreturn;\r\n}\r\nreturn;\r\ncase ESpercent:\r\nvc->vc_state = ESnormal;\r\nswitch (c) {\r\ncase '@':\r\nvc->vc_utf = 0;\r\nreturn;\r\ncase 'G':\r\ncase '8':\r\nvc->vc_utf = 1;\r\nreturn;\r\n}\r\nreturn;\r\ncase ESfunckey:\r\nvc->vc_state = ESnormal;\r\nreturn;\r\ncase EShash:\r\nvc->vc_state = ESnormal;\r\nif (c == '8') {\r\nvc->vc_video_erase_char =\r\n(vc->vc_video_erase_char & 0xff00) | 'E';\r\ncsi_J(vc, 2);\r\nvc->vc_video_erase_char =\r\n(vc->vc_video_erase_char & 0xff00) | ' ';\r\ndo_update_region(vc, vc->vc_origin, vc->vc_screenbuf_size / 2);\r\n}\r\nreturn;\r\ncase ESsetG0:\r\nif (c == '0')\r\nvc->vc_G0_charset = GRAF_MAP;\r\nelse if (c == 'B')\r\nvc->vc_G0_charset = LAT1_MAP;\r\nelse if (c == 'U')\r\nvc->vc_G0_charset = IBMPC_MAP;\r\nelse if (c == 'K')\r\nvc->vc_G0_charset = USER_MAP;\r\nif (vc->vc_charset == 0)\r\nvc->vc_translate = set_translate(vc->vc_G0_charset, vc);\r\nvc->vc_state = ESnormal;\r\nreturn;\r\ncase ESsetG1:\r\nif (c == '0')\r\nvc->vc_G1_charset = GRAF_MAP;\r\nelse if (c == 'B')\r\nvc->vc_G1_charset = LAT1_MAP;\r\nelse if (c == 'U')\r\nvc->vc_G1_charset = IBMPC_MAP;\r\nelse if (c == 'K')\r\nvc->vc_G1_charset = USER_MAP;\r\nif (vc->vc_charset == 1)\r\nvc->vc_translate = set_translate(vc->vc_G1_charset, vc);\r\nvc->vc_state = ESnormal;\r\nreturn;\r\ncase ESosc:\r\nreturn;\r\ndefault:\r\nvc->vc_state = ESnormal;\r\n}\r\n}\r\nstatic int bisearch(uint32_t ucs, const struct interval *table, int max)\r\n{\r\nint min = 0;\r\nint mid;\r\nif (ucs < table[0].first || ucs > table[max].last)\r\nreturn 0;\r\nwhile (max >= min) {\r\nmid = (min + max) / 2;\r\nif (ucs > table[mid].last)\r\nmin = mid + 1;\r\nelse if (ucs < table[mid].first)\r\nmax = mid - 1;\r\nelse\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int is_double_width(uint32_t ucs)\r\n{\r\nstatic const struct interval double_width[] = {\r\n{ 0x1100, 0x115F }, { 0x2329, 0x232A }, { 0x2E80, 0x303E },\r\n{ 0x3040, 0xA4CF }, { 0xAC00, 0xD7A3 }, { 0xF900, 0xFAFF },\r\n{ 0xFE10, 0xFE19 }, { 0xFE30, 0xFE6F }, { 0xFF00, 0xFF60 },\r\n{ 0xFFE0, 0xFFE6 }, { 0x20000, 0x2FFFD }, { 0x30000, 0x3FFFD }\r\n};\r\nreturn bisearch(ucs, double_width, ARRAY_SIZE(double_width) - 1);\r\n}\r\nstatic void con_flush(struct vc_data *vc, unsigned long draw_from,\r\nunsigned long draw_to, int *draw_x)\r\n{\r\nif (*draw_x < 0)\r\nreturn;\r\nvc->vc_sw->con_putcs(vc, (u16 *)draw_from,\r\n(u16 *)draw_to - (u16 *)draw_from, vc->vc_y, *draw_x);\r\n*draw_x = -1;\r\n}\r\nstatic int do_con_write(struct tty_struct *tty, const unsigned char *buf, int count)\r\n{\r\nint c, tc, ok, n = 0, draw_x = -1;\r\nunsigned int currcons;\r\nunsigned long draw_from = 0, draw_to = 0;\r\nstruct vc_data *vc;\r\nunsigned char vc_attr;\r\nstruct vt_notifier_param param;\r\nuint8_t rescan;\r\nuint8_t inverse;\r\nuint8_t width;\r\nu16 himask, charmask;\r\nif (in_interrupt())\r\nreturn count;\r\nmight_sleep();\r\nconsole_lock();\r\nvc = tty->driver_data;\r\nif (vc == NULL) {\r\nprintk(KERN_ERR "vt: argh, driver_data is NULL !\n");\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\ncurrcons = vc->vc_num;\r\nif (!vc_cons_allocated(currcons)) {\r\npr_warn_once("con_write: tty %d not allocated\n", currcons+1);\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nhimask = vc->vc_hi_font_mask;\r\ncharmask = himask ? 0x1ff : 0xff;\r\nif (con_is_fg(vc))\r\nhide_cursor(vc);\r\nparam.vc = vc;\r\nwhile (!tty->stopped && count) {\r\nint orig = *buf;\r\nc = orig;\r\nbuf++;\r\nn++;\r\ncount--;\r\nrescan = 0;\r\ninverse = 0;\r\nwidth = 1;\r\nif (vc->vc_state != ESnormal) {\r\ntc = c;\r\n} else if (vc->vc_utf && !vc->vc_disp_ctrl) {\r\nrescan_last_byte:\r\nif ((c & 0xc0) == 0x80) {\r\nstatic const uint32_t utf8_length_changes[] = { 0x0000007f, 0x000007ff, 0x0000ffff, 0x001fffff, 0x03ffffff, 0x7fffffff };\r\nif (vc->vc_utf_count) {\r\nvc->vc_utf_char = (vc->vc_utf_char << 6) | (c & 0x3f);\r\nvc->vc_npar++;\r\nif (--vc->vc_utf_count) {\r\ncontinue;\r\n}\r\nc = vc->vc_utf_char;\r\nif (c <= utf8_length_changes[vc->vc_npar - 1] ||\r\nc > utf8_length_changes[vc->vc_npar])\r\nc = 0xfffd;\r\n} else {\r\nvc->vc_utf_count = 0;\r\nc = 0xfffd;\r\n}\r\n} else {\r\nif (vc->vc_utf_count) {\r\nrescan = 1;\r\nvc->vc_utf_count = 0;\r\nc = 0xfffd;\r\n} else if (c > 0x7f) {\r\nvc->vc_npar = 0;\r\nif ((c & 0xe0) == 0xc0) {\r\nvc->vc_utf_count = 1;\r\nvc->vc_utf_char = (c & 0x1f);\r\n} else if ((c & 0xf0) == 0xe0) {\r\nvc->vc_utf_count = 2;\r\nvc->vc_utf_char = (c & 0x0f);\r\n} else if ((c & 0xf8) == 0xf0) {\r\nvc->vc_utf_count = 3;\r\nvc->vc_utf_char = (c & 0x07);\r\n} else if ((c & 0xfc) == 0xf8) {\r\nvc->vc_utf_count = 4;\r\nvc->vc_utf_char = (c & 0x03);\r\n} else if ((c & 0xfe) == 0xfc) {\r\nvc->vc_utf_count = 5;\r\nvc->vc_utf_char = (c & 0x01);\r\n} else {\r\nc = 0xfffd;\r\n}\r\nif (vc->vc_utf_count) {\r\ncontinue;\r\n}\r\n}\r\n}\r\nif ((c >= 0xd800 && c <= 0xdfff) || c == 0xfffe || c == 0xffff)\r\nc = 0xfffd;\r\ntc = c;\r\n} else {\r\ntc = vc_translate(vc, c);\r\n}\r\nparam.c = tc;\r\nif (atomic_notifier_call_chain(&vt_notifier_list, VT_PREWRITE,\r\n&param) == NOTIFY_STOP)\r\ncontinue;\r\nok = tc && (c >= 32 ||\r\n!(vc->vc_disp_ctrl ? (CTRL_ALWAYS >> c) & 1 :\r\nvc->vc_utf || ((CTRL_ACTION >> c) & 1)))\r\n&& (c != 127 || vc->vc_disp_ctrl)\r\n&& (c != 128+27);\r\nif (vc->vc_state == ESnormal && ok) {\r\nif (vc->vc_utf && !vc->vc_disp_ctrl) {\r\nif (is_double_width(c))\r\nwidth = 2;\r\n}\r\ntc = conv_uni_to_pc(vc, tc);\r\nif (tc & ~charmask) {\r\nif (tc == -1 || tc == -2) {\r\ncontinue;\r\n}\r\nif ((!(vc->vc_utf && !vc->vc_disp_ctrl) || c < 128) && !(c & ~charmask)) {\r\ntc = c;\r\n} else {\r\ntc = conv_uni_to_pc(vc, 0xfffd);\r\nif (tc < 0) {\r\ninverse = 1;\r\ntc = conv_uni_to_pc(vc, '?');\r\nif (tc < 0) tc = '?';\r\n}\r\n}\r\n}\r\nif (!inverse) {\r\nvc_attr = vc->vc_attr;\r\n} else {\r\nif (!vc->vc_can_do_color) {\r\nvc_attr = (vc->vc_attr) ^ 0x08;\r\n} else if (vc->vc_hi_font_mask == 0x100) {\r\nvc_attr = ((vc->vc_attr) & 0x11) | (((vc->vc_attr) & 0xe0) >> 4) | (((vc->vc_attr) & 0x0e) << 4);\r\n} else {\r\nvc_attr = ((vc->vc_attr) & 0x88) | (((vc->vc_attr) & 0x70) >> 4) | (((vc->vc_attr) & 0x07) << 4);\r\n}\r\ncon_flush(vc, draw_from, draw_to, &draw_x);\r\n}\r\nwhile (1) {\r\nif (vc->vc_need_wrap || vc->vc_decim)\r\ncon_flush(vc, draw_from, draw_to,\r\n&draw_x);\r\nif (vc->vc_need_wrap) {\r\ncr(vc);\r\nlf(vc);\r\n}\r\nif (vc->vc_decim)\r\ninsert_char(vc, 1);\r\nscr_writew(himask ?\r\n((vc_attr << 8) & ~himask) + ((tc & 0x100) ? himask : 0) + (tc & 0xff) :\r\n(vc_attr << 8) + tc,\r\n(u16 *) vc->vc_pos);\r\nif (con_should_update(vc) && draw_x < 0) {\r\ndraw_x = vc->vc_x;\r\ndraw_from = vc->vc_pos;\r\n}\r\nif (vc->vc_x == vc->vc_cols - 1) {\r\nvc->vc_need_wrap = vc->vc_decawm;\r\ndraw_to = vc->vc_pos + 2;\r\n} else {\r\nvc->vc_x++;\r\ndraw_to = (vc->vc_pos += 2);\r\n}\r\nif (!--width) break;\r\ntc = conv_uni_to_pc(vc, ' ');\r\nif (tc < 0) tc = ' ';\r\n}\r\nnotify_write(vc, c);\r\nif (inverse)\r\ncon_flush(vc, draw_from, draw_to, &draw_x);\r\nif (rescan) {\r\nrescan = 0;\r\ninverse = 0;\r\nwidth = 1;\r\nc = orig;\r\ngoto rescan_last_byte;\r\n}\r\ncontinue;\r\n}\r\ncon_flush(vc, draw_from, draw_to, &draw_x);\r\ndo_con_trol(tty, vc, orig);\r\n}\r\ncon_flush(vc, draw_from, draw_to, &draw_x);\r\nconsole_conditional_schedule();\r\nconsole_unlock();\r\nnotify_update(vc);\r\nreturn n;\r\n}\r\nstatic void console_callback(struct work_struct *ignored)\r\n{\r\nconsole_lock();\r\nif (want_console >= 0) {\r\nif (want_console != fg_console &&\r\nvc_cons_allocated(want_console)) {\r\nhide_cursor(vc_cons[fg_console].d);\r\nchange_console(vc_cons[want_console].d);\r\n}\r\nwant_console = -1;\r\n}\r\nif (do_poke_blanked_console) {\r\ndo_poke_blanked_console = 0;\r\npoke_blanked_console();\r\n}\r\nif (scrollback_delta) {\r\nstruct vc_data *vc = vc_cons[fg_console].d;\r\nclear_selection();\r\nif (vc->vc_mode == KD_TEXT && vc->vc_sw->con_scrolldelta)\r\nvc->vc_sw->con_scrolldelta(vc, scrollback_delta);\r\nscrollback_delta = 0;\r\n}\r\nif (blank_timer_expired) {\r\ndo_blank_screen(0);\r\nblank_timer_expired = 0;\r\n}\r\nnotify_update(vc_cons[fg_console].d);\r\nconsole_unlock();\r\n}\r\nint set_console(int nr)\r\n{\r\nstruct vc_data *vc = vc_cons[fg_console].d;\r\nif (!vc_cons_allocated(nr) || vt_dont_switch ||\r\n(vc->vt_mode.mode == VT_AUTO && vc->vc_mode == KD_GRAPHICS)) {\r\nreturn -EINVAL;\r\n}\r\nwant_console = nr;\r\nschedule_console_callback();\r\nreturn 0;\r\n}\r\nint vt_kmsg_redirect(int new)\r\n{\r\nstatic int kmsg_con;\r\nif (new != -1)\r\nreturn xchg(&kmsg_con, new);\r\nelse\r\nreturn kmsg_con;\r\n}\r\nstatic void vt_console_print(struct console *co, const char *b, unsigned count)\r\n{\r\nstruct vc_data *vc = vc_cons[fg_console].d;\r\nunsigned char c;\r\nstatic DEFINE_SPINLOCK(printing_lock);\r\nconst ushort *start;\r\nushort cnt = 0;\r\nushort myx;\r\nint kmsg_console;\r\nif (!printable)\r\nreturn;\r\nif (!spin_trylock(&printing_lock))\r\nreturn;\r\nkmsg_console = vt_get_kmsg_redirect();\r\nif (kmsg_console && vc_cons_allocated(kmsg_console - 1))\r\nvc = vc_cons[kmsg_console - 1].d;\r\nmyx = vc->vc_x;\r\nif (!vc_cons_allocated(fg_console)) {\r\ngoto quit;\r\n}\r\nif (vc->vc_mode != KD_TEXT && !vt_force_oops_output(vc))\r\ngoto quit;\r\nif (con_is_fg(vc))\r\nhide_cursor(vc);\r\nstart = (ushort *)vc->vc_pos;\r\nwhile (count--) {\r\nc = *b++;\r\nif (c == 10 || c == 13 || c == 8 || vc->vc_need_wrap) {\r\nif (cnt > 0) {\r\nif (con_is_visible(vc))\r\nvc->vc_sw->con_putcs(vc, start, cnt, vc->vc_y, vc->vc_x);\r\nvc->vc_x += cnt;\r\nif (vc->vc_need_wrap)\r\nvc->vc_x--;\r\ncnt = 0;\r\n}\r\nif (c == 8) {\r\nbs(vc);\r\nstart = (ushort *)vc->vc_pos;\r\nmyx = vc->vc_x;\r\ncontinue;\r\n}\r\nif (c != 13)\r\nlf(vc);\r\ncr(vc);\r\nstart = (ushort *)vc->vc_pos;\r\nmyx = vc->vc_x;\r\nif (c == 10 || c == 13)\r\ncontinue;\r\n}\r\nscr_writew((vc->vc_attr << 8) + c, (unsigned short *)vc->vc_pos);\r\nnotify_write(vc, c);\r\ncnt++;\r\nif (myx == vc->vc_cols - 1) {\r\nvc->vc_need_wrap = 1;\r\ncontinue;\r\n}\r\nvc->vc_pos += 2;\r\nmyx++;\r\n}\r\nif (cnt > 0) {\r\nif (con_is_visible(vc))\r\nvc->vc_sw->con_putcs(vc, start, cnt, vc->vc_y, vc->vc_x);\r\nvc->vc_x += cnt;\r\nif (vc->vc_x == vc->vc_cols) {\r\nvc->vc_x--;\r\nvc->vc_need_wrap = 1;\r\n}\r\n}\r\nset_cursor(vc);\r\nnotify_update(vc);\r\nquit:\r\nspin_unlock(&printing_lock);\r\n}\r\nstatic struct tty_driver *vt_console_device(struct console *c, int *index)\r\n{\r\n*index = c->index ? c->index-1 : fg_console;\r\nreturn console_driver;\r\n}\r\nint tioclinux(struct tty_struct *tty, unsigned long arg)\r\n{\r\nchar type, data;\r\nchar __user *p = (char __user *)arg;\r\nint lines;\r\nint ret;\r\nif (current->signal->tty != tty && !capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (get_user(type, p))\r\nreturn -EFAULT;\r\nret = 0;\r\nswitch (type)\r\n{\r\ncase TIOCL_SETSEL:\r\nconsole_lock();\r\nret = set_selection((struct tiocl_selection __user *)(p+1), tty);\r\nconsole_unlock();\r\nbreak;\r\ncase TIOCL_PASTESEL:\r\nret = paste_selection(tty);\r\nbreak;\r\ncase TIOCL_UNBLANKSCREEN:\r\nconsole_lock();\r\nunblank_screen();\r\nconsole_unlock();\r\nbreak;\r\ncase TIOCL_SELLOADLUT:\r\nconsole_lock();\r\nret = sel_loadlut(p);\r\nconsole_unlock();\r\nbreak;\r\ncase TIOCL_GETSHIFTSTATE:\r\ndata = vt_get_shift_state();\r\nret = put_user(data, p);\r\nbreak;\r\ncase TIOCL_GETMOUSEREPORTING:\r\nconsole_lock();\r\ndata = mouse_reporting();\r\nconsole_unlock();\r\nret = put_user(data, p);\r\nbreak;\r\ncase TIOCL_SETVESABLANK:\r\nconsole_lock();\r\nret = set_vesa_blanking(p);\r\nconsole_unlock();\r\nbreak;\r\ncase TIOCL_GETKMSGREDIRECT:\r\ndata = vt_get_kmsg_redirect();\r\nret = put_user(data, p);\r\nbreak;\r\ncase TIOCL_SETKMSGREDIRECT:\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nret = -EPERM;\r\n} else {\r\nif (get_user(data, p+1))\r\nret = -EFAULT;\r\nelse\r\nvt_kmsg_redirect(data);\r\n}\r\nbreak;\r\ncase TIOCL_GETFGCONSOLE:\r\nret = fg_console;\r\nbreak;\r\ncase TIOCL_SCROLLCONSOLE:\r\nif (get_user(lines, (s32 __user *)(p+4))) {\r\nret = -EFAULT;\r\n} else {\r\nconsole_lock();\r\nscrollfront(vc_cons[fg_console].d, lines);\r\nconsole_unlock();\r\nret = 0;\r\n}\r\nbreak;\r\ncase TIOCL_BLANKSCREEN:\r\nconsole_lock();\r\nignore_poke = 1;\r\ndo_blank_screen(0);\r\nconsole_unlock();\r\nbreak;\r\ncase TIOCL_BLANKEDSCREEN:\r\nret = console_blanked;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int con_write(struct tty_struct *tty, const unsigned char *buf, int count)\r\n{\r\nint retval;\r\nretval = do_con_write(tty, buf, count);\r\ncon_flush_chars(tty);\r\nreturn retval;\r\n}\r\nstatic int con_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nif (in_interrupt())\r\nreturn 0;\r\nreturn do_con_write(tty, &ch, 1);\r\n}\r\nstatic int con_write_room(struct tty_struct *tty)\r\n{\r\nif (tty->stopped)\r\nreturn 0;\r\nreturn 32768;\r\n}\r\nstatic int con_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nreturn 0;\r\n}\r\nstatic void con_throttle(struct tty_struct *tty)\r\n{\r\n}\r\nstatic void con_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct vc_data *vc = tty->driver_data;\r\nwake_up_interruptible(&vc->paste_wait);\r\n}\r\nstatic void con_stop(struct tty_struct *tty)\r\n{\r\nint console_num;\r\nif (!tty)\r\nreturn;\r\nconsole_num = tty->index;\r\nif (!vc_cons_allocated(console_num))\r\nreturn;\r\nvt_kbd_con_stop(console_num);\r\n}\r\nstatic void con_start(struct tty_struct *tty)\r\n{\r\nint console_num;\r\nif (!tty)\r\nreturn;\r\nconsole_num = tty->index;\r\nif (!vc_cons_allocated(console_num))\r\nreturn;\r\nvt_kbd_con_start(console_num);\r\n}\r\nstatic void con_flush_chars(struct tty_struct *tty)\r\n{\r\nstruct vc_data *vc;\r\nif (in_interrupt())\r\nreturn;\r\nconsole_lock();\r\nvc = tty->driver_data;\r\nif (vc)\r\nset_cursor(vc);\r\nconsole_unlock();\r\n}\r\nstatic int con_install(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nunsigned int currcons = tty->index;\r\nstruct vc_data *vc;\r\nint ret;\r\nconsole_lock();\r\nret = vc_allocate(currcons);\r\nif (ret)\r\ngoto unlock;\r\nvc = vc_cons[currcons].d;\r\nif (vc->port.tty) {\r\nret = -ERESTARTSYS;\r\ngoto unlock;\r\n}\r\nret = tty_port_install(&vc->port, driver, tty);\r\nif (ret)\r\ngoto unlock;\r\ntty->driver_data = vc;\r\nvc->port.tty = tty;\r\nif (!tty->winsize.ws_row && !tty->winsize.ws_col) {\r\ntty->winsize.ws_row = vc_cons[currcons].d->vc_rows;\r\ntty->winsize.ws_col = vc_cons[currcons].d->vc_cols;\r\n}\r\nif (vc->vc_utf)\r\ntty->termios.c_iflag |= IUTF8;\r\nelse\r\ntty->termios.c_iflag &= ~IUTF8;\r\nunlock:\r\nconsole_unlock();\r\nreturn ret;\r\n}\r\nstatic int con_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nreturn 0;\r\n}\r\nstatic void con_close(struct tty_struct *tty, struct file *filp)\r\n{\r\n}\r\nstatic void con_shutdown(struct tty_struct *tty)\r\n{\r\nstruct vc_data *vc = tty->driver_data;\r\nBUG_ON(vc == NULL);\r\nconsole_lock();\r\nvc->port.tty = NULL;\r\nconsole_unlock();\r\n}\r\nstatic void vc_init(struct vc_data *vc, unsigned int rows,\r\nunsigned int cols, int do_clear)\r\n{\r\nint j, k ;\r\nvc->vc_cols = cols;\r\nvc->vc_rows = rows;\r\nvc->vc_size_row = cols << 1;\r\nvc->vc_screenbuf_size = vc->vc_rows * vc->vc_size_row;\r\nset_origin(vc);\r\nvc->vc_pos = vc->vc_origin;\r\nreset_vc(vc);\r\nfor (j=k=0; j<16; j++) {\r\nvc->vc_palette[k++] = default_red[j] ;\r\nvc->vc_palette[k++] = default_grn[j] ;\r\nvc->vc_palette[k++] = default_blu[j] ;\r\n}\r\nvc->vc_def_color = default_color;\r\nvc->vc_ulcolor = default_underline_color;\r\nvc->vc_itcolor = default_italic_color;\r\nvc->vc_halfcolor = 0x08;\r\ninit_waitqueue_head(&vc->paste_wait);\r\nreset_terminal(vc, do_clear);\r\n}\r\nstatic int __init con_init(void)\r\n{\r\nconst char *display_desc = NULL;\r\nstruct vc_data *vc;\r\nunsigned int currcons = 0, i;\r\nconsole_lock();\r\nif (conswitchp)\r\ndisplay_desc = conswitchp->con_startup();\r\nif (!display_desc) {\r\nfg_console = 0;\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\r\nstruct con_driver *con_driver = &registered_con_driver[i];\r\nif (con_driver->con == NULL) {\r\ncon_driver->con = conswitchp;\r\ncon_driver->desc = display_desc;\r\ncon_driver->flag = CON_DRIVER_FLAG_INIT;\r\ncon_driver->first = 0;\r\ncon_driver->last = MAX_NR_CONSOLES - 1;\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++)\r\ncon_driver_map[i] = conswitchp;\r\nif (blankinterval) {\r\nblank_state = blank_normal_wait;\r\nmod_timer(&console_timer, jiffies + (blankinterval * HZ));\r\n}\r\nfor (currcons = 0; currcons < MIN_NR_CONSOLES; currcons++) {\r\nvc_cons[currcons].d = vc = kzalloc(sizeof(struct vc_data), GFP_NOWAIT);\r\nINIT_WORK(&vc_cons[currcons].SAK_work, vc_SAK);\r\ntty_port_init(&vc->port);\r\nvisual_init(vc, currcons, 1);\r\nvc->vc_screenbuf = kzalloc(vc->vc_screenbuf_size, GFP_NOWAIT);\r\nvc_init(vc, vc->vc_rows, vc->vc_cols,\r\ncurrcons || !vc->vc_sw->con_save_screen);\r\n}\r\ncurrcons = fg_console = 0;\r\nmaster_display_fg = vc = vc_cons[currcons].d;\r\nset_origin(vc);\r\nsave_screen(vc);\r\ngotoxy(vc, vc->vc_x, vc->vc_y);\r\ncsi_J(vc, 0);\r\nupdate_screen(vc);\r\npr_info("Console: %s %s %dx%d\n",\r\nvc->vc_can_do_color ? "colour" : "mono",\r\ndisplay_desc, vc->vc_cols, vc->vc_rows);\r\nprintable = 1;\r\nconsole_unlock();\r\n#ifdef CONFIG_VT_CONSOLE\r\nregister_console(&vt_console_driver);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic ssize_t show_tty_active(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "tty%d\n", fg_console + 1);\r\n}\r\nint __init vty_init(const struct file_operations *console_fops)\r\n{\r\ncdev_init(&vc0_cdev, console_fops);\r\nif (cdev_add(&vc0_cdev, MKDEV(TTY_MAJOR, 0), 1) ||\r\nregister_chrdev_region(MKDEV(TTY_MAJOR, 0), 1, "/dev/vc/0") < 0)\r\npanic("Couldn't register /dev/tty0 driver\n");\r\ntty0dev = device_create_with_groups(tty_class, NULL,\r\nMKDEV(TTY_MAJOR, 0), NULL,\r\nvt_dev_groups, "tty0");\r\nif (IS_ERR(tty0dev))\r\ntty0dev = NULL;\r\nvcs_init();\r\nconsole_driver = alloc_tty_driver(MAX_NR_CONSOLES);\r\nif (!console_driver)\r\npanic("Couldn't allocate console driver\n");\r\nconsole_driver->name = "tty";\r\nconsole_driver->name_base = 1;\r\nconsole_driver->major = TTY_MAJOR;\r\nconsole_driver->minor_start = 1;\r\nconsole_driver->type = TTY_DRIVER_TYPE_CONSOLE;\r\nconsole_driver->init_termios = tty_std_termios;\r\nif (default_utf8)\r\nconsole_driver->init_termios.c_iflag |= IUTF8;\r\nconsole_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_RESET_TERMIOS;\r\ntty_set_operations(console_driver, &con_ops);\r\nif (tty_register_driver(console_driver))\r\npanic("Couldn't register console driver\n");\r\nkbd_init();\r\nconsole_map_init();\r\n#ifdef CONFIG_MDA_CONSOLE\r\nmda_console_init();\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int do_bind_con_driver(const struct consw *csw, int first, int last,\r\nint deflt)\r\n{\r\nstruct module *owner = csw->owner;\r\nconst char *desc = NULL;\r\nstruct con_driver *con_driver;\r\nint i, j = -1, k = -1, retval = -ENODEV;\r\nif (!try_module_get(owner))\r\nreturn -ENODEV;\r\nWARN_CONSOLE_UNLOCKED();\r\nfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\r\ncon_driver = &registered_con_driver[i];\r\nif (con_driver->con == csw) {\r\ndesc = con_driver->desc;\r\nretval = 0;\r\nbreak;\r\n}\r\n}\r\nif (retval)\r\ngoto err;\r\nif (!(con_driver->flag & CON_DRIVER_FLAG_INIT)) {\r\ncsw->con_startup();\r\ncon_driver->flag |= CON_DRIVER_FLAG_INIT;\r\n}\r\nif (deflt) {\r\nif (conswitchp)\r\nmodule_put(conswitchp->owner);\r\n__module_get(owner);\r\nconswitchp = csw;\r\n}\r\nfirst = max(first, con_driver->first);\r\nlast = min(last, con_driver->last);\r\nfor (i = first; i <= last; i++) {\r\nint old_was_color;\r\nstruct vc_data *vc = vc_cons[i].d;\r\nif (con_driver_map[i])\r\nmodule_put(con_driver_map[i]->owner);\r\n__module_get(owner);\r\ncon_driver_map[i] = csw;\r\nif (!vc || !vc->vc_sw)\r\ncontinue;\r\nj = i;\r\nif (con_is_visible(vc)) {\r\nk = i;\r\nsave_screen(vc);\r\n}\r\nold_was_color = vc->vc_can_do_color;\r\nvc->vc_sw->con_deinit(vc);\r\nvc->vc_origin = (unsigned long)vc->vc_screenbuf;\r\nvisual_init(vc, i, 0);\r\nset_origin(vc);\r\nupdate_attr(vc);\r\nif (old_was_color != vc->vc_can_do_color)\r\nclear_buffer_attributes(vc);\r\n}\r\npr_info("Console: switching ");\r\nif (!deflt)\r\nprintk(KERN_CONT "consoles %d-%d ", first+1, last+1);\r\nif (j >= 0) {\r\nstruct vc_data *vc = vc_cons[j].d;\r\nprintk(KERN_CONT "to %s %s %dx%d\n",\r\nvc->vc_can_do_color ? "colour" : "mono",\r\ndesc, vc->vc_cols, vc->vc_rows);\r\nif (k >= 0) {\r\nvc = vc_cons[k].d;\r\nupdate_screen(vc);\r\n}\r\n} else\r\nprintk(KERN_CONT "to %s\n", desc);\r\nretval = 0;\r\nerr:\r\nmodule_put(owner);\r\nreturn retval;\r\n}\r\nint do_unbind_con_driver(const struct consw *csw, int first, int last, int deflt)\r\n{\r\nstruct module *owner = csw->owner;\r\nconst struct consw *defcsw = NULL;\r\nstruct con_driver *con_driver = NULL, *con_back = NULL;\r\nint i, retval = -ENODEV;\r\nif (!try_module_get(owner))\r\nreturn -ENODEV;\r\nWARN_CONSOLE_UNLOCKED();\r\nfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\r\ncon_driver = &registered_con_driver[i];\r\nif (con_driver->con == csw &&\r\ncon_driver->flag & CON_DRIVER_FLAG_MODULE) {\r\nretval = 0;\r\nbreak;\r\n}\r\n}\r\nif (retval)\r\ngoto err;\r\nretval = -ENODEV;\r\nfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\r\ncon_back = &registered_con_driver[i];\r\nif (con_back->con && con_back->con != csw) {\r\ndefcsw = con_back->con;\r\nretval = 0;\r\nbreak;\r\n}\r\n}\r\nif (retval)\r\ngoto err;\r\nif (!con_is_bound(csw))\r\ngoto err;\r\nfirst = max(first, con_driver->first);\r\nlast = min(last, con_driver->last);\r\nfor (i = first; i <= last; i++) {\r\nif (con_driver_map[i] == csw) {\r\nmodule_put(csw->owner);\r\ncon_driver_map[i] = NULL;\r\n}\r\n}\r\nif (!con_is_bound(defcsw)) {\r\nconst struct consw *defconsw = conswitchp;\r\ndefcsw->con_startup();\r\ncon_back->flag |= CON_DRIVER_FLAG_INIT;\r\nconswitchp = defconsw;\r\n}\r\nif (!con_is_bound(csw))\r\ncon_driver->flag &= ~CON_DRIVER_FLAG_INIT;\r\ndo_bind_con_driver(defcsw, first, last, deflt);\r\nerr:\r\nmodule_put(owner);\r\nreturn retval;\r\n}\r\nstatic int vt_bind(struct con_driver *con)\r\n{\r\nconst struct consw *defcsw = NULL, *csw = NULL;\r\nint i, more = 1, first = -1, last = -1, deflt = 0;\r\nif (!con->con || !(con->flag & CON_DRIVER_FLAG_MODULE))\r\ngoto err;\r\ncsw = con->con;\r\nfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\r\nstruct con_driver *con = &registered_con_driver[i];\r\nif (con->con && !(con->flag & CON_DRIVER_FLAG_MODULE)) {\r\ndefcsw = con->con;\r\nbreak;\r\n}\r\n}\r\nif (!defcsw)\r\ngoto err;\r\nwhile (more) {\r\nmore = 0;\r\nfor (i = con->first; i <= con->last; i++) {\r\nif (con_driver_map[i] == defcsw) {\r\nif (first == -1)\r\nfirst = i;\r\nlast = i;\r\nmore = 1;\r\n} else if (first != -1)\r\nbreak;\r\n}\r\nif (first == 0 && last == MAX_NR_CONSOLES -1)\r\ndeflt = 1;\r\nif (first != -1)\r\ndo_bind_con_driver(csw, first, last, deflt);\r\nfirst = -1;\r\nlast = -1;\r\ndeflt = 0;\r\n}\r\nerr:\r\nreturn 0;\r\n}\r\nstatic int vt_unbind(struct con_driver *con)\r\n{\r\nconst struct consw *csw = NULL;\r\nint i, more = 1, first = -1, last = -1, deflt = 0;\r\nint ret;\r\nif (!con->con || !(con->flag & CON_DRIVER_FLAG_MODULE))\r\ngoto err;\r\ncsw = con->con;\r\nwhile (more) {\r\nmore = 0;\r\nfor (i = con->first; i <= con->last; i++) {\r\nif (con_driver_map[i] == csw) {\r\nif (first == -1)\r\nfirst = i;\r\nlast = i;\r\nmore = 1;\r\n} else if (first != -1)\r\nbreak;\r\n}\r\nif (first == 0 && last == MAX_NR_CONSOLES -1)\r\ndeflt = 1;\r\nif (first != -1) {\r\nret = do_unbind_con_driver(csw, first, last, deflt);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nfirst = -1;\r\nlast = -1;\r\ndeflt = 0;\r\n}\r\nerr:\r\nreturn 0;\r\n}\r\nstatic inline int vt_bind(struct con_driver *con)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int vt_unbind(struct con_driver *con)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t store_bind(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct con_driver *con = dev_get_drvdata(dev);\r\nint bind = simple_strtoul(buf, NULL, 0);\r\nconsole_lock();\r\nif (bind)\r\nvt_bind(con);\r\nelse\r\nvt_unbind(con);\r\nconsole_unlock();\r\nreturn count;\r\n}\r\nstatic ssize_t show_bind(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct con_driver *con = dev_get_drvdata(dev);\r\nint bind = con_is_bound(con->con);\r\nreturn snprintf(buf, PAGE_SIZE, "%i\n", bind);\r\n}\r\nstatic ssize_t show_name(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct con_driver *con = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s %s\n",\r\n(con->flag & CON_DRIVER_FLAG_MODULE) ? "(M)" : "(S)",\r\ncon->desc);\r\n}\r\nstatic int vtconsole_init_device(struct con_driver *con)\r\n{\r\ncon->flag |= CON_DRIVER_FLAG_ATTR;\r\nreturn 0;\r\n}\r\nstatic void vtconsole_deinit_device(struct con_driver *con)\r\n{\r\ncon->flag &= ~CON_DRIVER_FLAG_ATTR;\r\n}\r\nint con_is_bound(const struct consw *csw)\r\n{\r\nint i, bound = 0;\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++) {\r\nif (con_driver_map[i] == csw) {\r\nbound = 1;\r\nbreak;\r\n}\r\n}\r\nreturn bound;\r\n}\r\nint con_debug_enter(struct vc_data *vc)\r\n{\r\nint ret = 0;\r\nsaved_fg_console = fg_console;\r\nsaved_last_console = last_console;\r\nsaved_want_console = want_console;\r\nsaved_vc_mode = vc->vc_mode;\r\nsaved_console_blanked = console_blanked;\r\nvc->vc_mode = KD_TEXT;\r\nconsole_blanked = 0;\r\nif (vc->vc_sw->con_debug_enter)\r\nret = vc->vc_sw->con_debug_enter(vc);\r\n#ifdef CONFIG_KGDB_KDB\r\nif (vc->vc_rows < 999) {\r\nint linecount;\r\nchar lns[4];\r\nconst char *setargs[3] = {\r\n"set",\r\n"LINES",\r\nlns,\r\n};\r\nif (kdbgetintenv(setargs[0], &linecount)) {\r\nsnprintf(lns, 4, "%i", vc->vc_rows);\r\nkdb_set(2, setargs);\r\n}\r\n}\r\nif (vc->vc_cols < 999) {\r\nint colcount;\r\nchar cols[4];\r\nconst char *setargs[3] = {\r\n"set",\r\n"COLUMNS",\r\ncols,\r\n};\r\nif (kdbgetintenv(setargs[0], &colcount)) {\r\nsnprintf(cols, 4, "%i", vc->vc_cols);\r\nkdb_set(2, setargs);\r\n}\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nint con_debug_leave(void)\r\n{\r\nstruct vc_data *vc;\r\nint ret = 0;\r\nfg_console = saved_fg_console;\r\nlast_console = saved_last_console;\r\nwant_console = saved_want_console;\r\nconsole_blanked = saved_console_blanked;\r\nvc_cons[fg_console].d->vc_mode = saved_vc_mode;\r\nvc = vc_cons[fg_console].d;\r\nif (vc->vc_sw->con_debug_leave)\r\nret = vc->vc_sw->con_debug_leave(vc);\r\nreturn ret;\r\n}\r\nstatic int do_register_con_driver(const struct consw *csw, int first, int last)\r\n{\r\nstruct module *owner = csw->owner;\r\nstruct con_driver *con_driver;\r\nconst char *desc;\r\nint i, retval;\r\nWARN_CONSOLE_UNLOCKED();\r\nif (!try_module_get(owner))\r\nreturn -ENODEV;\r\nfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\r\ncon_driver = &registered_con_driver[i];\r\nif (con_driver->con == csw) {\r\nretval = -EBUSY;\r\ngoto err;\r\n}\r\n}\r\ndesc = csw->con_startup();\r\nif (!desc) {\r\nretval = -ENODEV;\r\ngoto err;\r\n}\r\nretval = -EINVAL;\r\nfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\r\ncon_driver = &registered_con_driver[i];\r\nif (con_driver->con == NULL &&\r\n!(con_driver->flag & CON_DRIVER_FLAG_ZOMBIE)) {\r\ncon_driver->con = csw;\r\ncon_driver->desc = desc;\r\ncon_driver->node = i;\r\ncon_driver->flag = CON_DRIVER_FLAG_MODULE |\r\nCON_DRIVER_FLAG_INIT;\r\ncon_driver->first = first;\r\ncon_driver->last = last;\r\nretval = 0;\r\nbreak;\r\n}\r\n}\r\nif (retval)\r\ngoto err;\r\ncon_driver->dev =\r\ndevice_create_with_groups(vtconsole_class, NULL,\r\nMKDEV(0, con_driver->node),\r\ncon_driver, con_dev_groups,\r\n"vtcon%i", con_driver->node);\r\nif (IS_ERR(con_driver->dev)) {\r\nprintk(KERN_WARNING "Unable to create device for %s; "\r\n"errno = %ld\n", con_driver->desc,\r\nPTR_ERR(con_driver->dev));\r\ncon_driver->dev = NULL;\r\n} else {\r\nvtconsole_init_device(con_driver);\r\n}\r\nerr:\r\nmodule_put(owner);\r\nreturn retval;\r\n}\r\nint do_unregister_con_driver(const struct consw *csw)\r\n{\r\nint i;\r\nif (con_is_bound(csw))\r\nreturn -EBUSY;\r\nif (csw == conswitchp)\r\nreturn -EINVAL;\r\nfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\r\nstruct con_driver *con_driver = &registered_con_driver[i];\r\nif (con_driver->con == csw) {\r\ncon_driver->con = NULL;\r\ncon_driver->flag = CON_DRIVER_FLAG_ZOMBIE;\r\nschedule_work(&con_driver_unregister_work);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void con_driver_unregister_callback(struct work_struct *ignored)\r\n{\r\nint i;\r\nconsole_lock();\r\nfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\r\nstruct con_driver *con_driver = &registered_con_driver[i];\r\nif (!(con_driver->flag & CON_DRIVER_FLAG_ZOMBIE))\r\ncontinue;\r\nconsole_unlock();\r\nvtconsole_deinit_device(con_driver);\r\ndevice_destroy(vtconsole_class, MKDEV(0, con_driver->node));\r\nconsole_lock();\r\nif (WARN_ON_ONCE(con_driver->con))\r\ncon_driver->con = NULL;\r\ncon_driver->desc = NULL;\r\ncon_driver->dev = NULL;\r\ncon_driver->node = 0;\r\nWARN_ON_ONCE(con_driver->flag != CON_DRIVER_FLAG_ZOMBIE);\r\ncon_driver->flag = 0;\r\ncon_driver->first = 0;\r\ncon_driver->last = 0;\r\n}\r\nconsole_unlock();\r\n}\r\nint do_take_over_console(const struct consw *csw, int first, int last, int deflt)\r\n{\r\nint err;\r\nerr = do_register_con_driver(csw, first, last);\r\nif (err == -EBUSY)\r\nerr = 0;\r\nif (!err)\r\ndo_bind_con_driver(csw, first, last, deflt);\r\nreturn err;\r\n}\r\nvoid give_up_console(const struct consw *csw)\r\n{\r\nconsole_lock();\r\ndo_unregister_con_driver(csw);\r\nconsole_unlock();\r\n}\r\nstatic int __init vtconsole_class_init(void)\r\n{\r\nint i;\r\nvtconsole_class = class_create(THIS_MODULE, "vtconsole");\r\nif (IS_ERR(vtconsole_class)) {\r\nprintk(KERN_WARNING "Unable to create vt console class; "\r\n"errno = %ld\n", PTR_ERR(vtconsole_class));\r\nvtconsole_class = NULL;\r\n}\r\nfor (i = 0; i < MAX_NR_CON_DRIVER; i++) {\r\nstruct con_driver *con = &registered_con_driver[i];\r\nif (con->con && !con->dev) {\r\ncon->dev =\r\ndevice_create_with_groups(vtconsole_class, NULL,\r\nMKDEV(0, con->node),\r\ncon, con_dev_groups,\r\n"vtcon%i", con->node);\r\nif (IS_ERR(con->dev)) {\r\nprintk(KERN_WARNING "Unable to create "\r\n"device for %s; errno = %ld\n",\r\ncon->desc, PTR_ERR(con->dev));\r\ncon->dev = NULL;\r\n} else {\r\nvtconsole_init_device(con);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_vesa_blanking(char __user *p)\r\n{\r\nunsigned int mode;\r\nif (get_user(mode, p + 1))\r\nreturn -EFAULT;\r\nvesa_blank_mode = (mode < 4) ? mode : 0;\r\nreturn 0;\r\n}\r\nvoid do_blank_screen(int entering_gfx)\r\n{\r\nstruct vc_data *vc = vc_cons[fg_console].d;\r\nint i;\r\nWARN_CONSOLE_UNLOCKED();\r\nif (console_blanked) {\r\nif (blank_state == blank_vesa_wait) {\r\nblank_state = blank_off;\r\nvc->vc_sw->con_blank(vc, vesa_blank_mode + 1, 0);\r\n}\r\nreturn;\r\n}\r\nif (entering_gfx) {\r\nhide_cursor(vc);\r\nsave_screen(vc);\r\nvc->vc_sw->con_blank(vc, -1, 1);\r\nconsole_blanked = fg_console + 1;\r\nblank_state = blank_off;\r\nset_origin(vc);\r\nreturn;\r\n}\r\nif (blank_state != blank_normal_wait)\r\nreturn;\r\nblank_state = blank_off;\r\nif (vc->vc_mode != KD_TEXT) {\r\nconsole_blanked = fg_console + 1;\r\nreturn;\r\n}\r\nhide_cursor(vc);\r\ndel_timer_sync(&console_timer);\r\nblank_timer_expired = 0;\r\nsave_screen(vc);\r\ni = vc->vc_sw->con_blank(vc, vesa_off_interval ? 1 : (vesa_blank_mode + 1), 0);\r\nconsole_blanked = fg_console + 1;\r\nif (i)\r\nset_origin(vc);\r\nif (console_blank_hook && console_blank_hook(1))\r\nreturn;\r\nif (vesa_off_interval && vesa_blank_mode) {\r\nblank_state = blank_vesa_wait;\r\nmod_timer(&console_timer, jiffies + vesa_off_interval);\r\n}\r\nvt_event_post(VT_EVENT_BLANK, vc->vc_num, vc->vc_num);\r\n}\r\nvoid do_unblank_screen(int leaving_gfx)\r\n{\r\nstruct vc_data *vc;\r\nif (!oops_in_progress)\r\nmight_sleep();\r\nWARN_CONSOLE_UNLOCKED();\r\nignore_poke = 0;\r\nif (!console_blanked)\r\nreturn;\r\nif (!vc_cons_allocated(fg_console)) {\r\npr_warn("unblank_screen: tty %d not allocated ??\n",\r\nfg_console + 1);\r\nreturn;\r\n}\r\nvc = vc_cons[fg_console].d;\r\nif (vc->vc_mode != KD_TEXT && !vt_force_oops_output(vc))\r\nreturn;\r\nif (blankinterval) {\r\nmod_timer(&console_timer, jiffies + (blankinterval * HZ));\r\nblank_state = blank_normal_wait;\r\n}\r\nconsole_blanked = 0;\r\nif (vc->vc_sw->con_blank(vc, 0, leaving_gfx) || vt_force_oops_output(vc))\r\nupdate_screen(vc);\r\nif (console_blank_hook)\r\nconsole_blank_hook(0);\r\nset_palette(vc);\r\nset_cursor(vc);\r\nvt_event_post(VT_EVENT_UNBLANK, vc->vc_num, vc->vc_num);\r\n}\r\nvoid unblank_screen(void)\r\n{\r\ndo_unblank_screen(0);\r\n}\r\nstatic void blank_screen_t(unsigned long dummy)\r\n{\r\nblank_timer_expired = 1;\r\nschedule_work(&console_work);\r\n}\r\nvoid poke_blanked_console(void)\r\n{\r\nWARN_CONSOLE_UNLOCKED();\r\nmight_sleep();\r\ndel_timer(&console_timer);\r\nblank_timer_expired = 0;\r\nif (ignore_poke || !vc_cons[fg_console].d || vc_cons[fg_console].d->vc_mode == KD_GRAPHICS)\r\nreturn;\r\nif (console_blanked)\r\nunblank_screen();\r\nelse if (blankinterval) {\r\nmod_timer(&console_timer, jiffies + (blankinterval * HZ));\r\nblank_state = blank_normal_wait;\r\n}\r\n}\r\nstatic void set_palette(struct vc_data *vc)\r\n{\r\nWARN_CONSOLE_UNLOCKED();\r\nif (vc->vc_mode != KD_GRAPHICS && vc->vc_sw->con_set_palette)\r\nvc->vc_sw->con_set_palette(vc, color_table);\r\n}\r\nint con_set_cmap(unsigned char __user *arg)\r\n{\r\nint i, j, k;\r\nunsigned char colormap[3*16];\r\nif (copy_from_user(colormap, arg, sizeof(colormap)))\r\nreturn -EFAULT;\r\nconsole_lock();\r\nfor (i = k = 0; i < 16; i++) {\r\ndefault_red[i] = colormap[k++];\r\ndefault_grn[i] = colormap[k++];\r\ndefault_blu[i] = colormap[k++];\r\n}\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++) {\r\nif (!vc_cons_allocated(i))\r\ncontinue;\r\nfor (j = k = 0; j < 16; j++) {\r\nvc_cons[i].d->vc_palette[k++] = default_red[j];\r\nvc_cons[i].d->vc_palette[k++] = default_grn[j];\r\nvc_cons[i].d->vc_palette[k++] = default_blu[j];\r\n}\r\nset_palette(vc_cons[i].d);\r\n}\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nint con_get_cmap(unsigned char __user *arg)\r\n{\r\nint i, k;\r\nunsigned char colormap[3*16];\r\nconsole_lock();\r\nfor (i = k = 0; i < 16; i++) {\r\ncolormap[k++] = default_red[i];\r\ncolormap[k++] = default_grn[i];\r\ncolormap[k++] = default_blu[i];\r\n}\r\nconsole_unlock();\r\nif (copy_to_user(arg, colormap, sizeof(colormap)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nvoid reset_palette(struct vc_data *vc)\r\n{\r\nint j, k;\r\nfor (j=k=0; j<16; j++) {\r\nvc->vc_palette[k++] = default_red[j];\r\nvc->vc_palette[k++] = default_grn[j];\r\nvc->vc_palette[k++] = default_blu[j];\r\n}\r\nset_palette(vc);\r\n}\r\nstatic int con_font_get(struct vc_data *vc, struct console_font_op *op)\r\n{\r\nstruct console_font font;\r\nint rc = -EINVAL;\r\nint c;\r\nif (op->data) {\r\nfont.data = kmalloc(max_font_size, GFP_KERNEL);\r\nif (!font.data)\r\nreturn -ENOMEM;\r\n} else\r\nfont.data = NULL;\r\nconsole_lock();\r\nif (vc->vc_mode != KD_TEXT)\r\nrc = -EINVAL;\r\nelse if (vc->vc_sw->con_font_get)\r\nrc = vc->vc_sw->con_font_get(vc, &font);\r\nelse\r\nrc = -ENOSYS;\r\nconsole_unlock();\r\nif (rc)\r\ngoto out;\r\nc = (font.width+7)/8 * 32 * font.charcount;\r\nif (op->data && font.charcount > op->charcount)\r\nrc = -ENOSPC;\r\nif (!(op->flags & KD_FONT_FLAG_OLD)) {\r\nif (font.width > op->width || font.height > op->height)\r\nrc = -ENOSPC;\r\n} else {\r\nif (font.width != 8)\r\nrc = -EIO;\r\nelse if ((op->height && font.height > op->height) ||\r\nfont.height > 32)\r\nrc = -ENOSPC;\r\n}\r\nif (rc)\r\ngoto out;\r\nop->height = font.height;\r\nop->width = font.width;\r\nop->charcount = font.charcount;\r\nif (op->data && copy_to_user(op->data, font.data, c))\r\nrc = -EFAULT;\r\nout:\r\nkfree(font.data);\r\nreturn rc;\r\n}\r\nstatic int con_font_set(struct vc_data *vc, struct console_font_op *op)\r\n{\r\nstruct console_font font;\r\nint rc = -EINVAL;\r\nint size;\r\nif (vc->vc_mode != KD_TEXT)\r\nreturn -EINVAL;\r\nif (!op->data)\r\nreturn -EINVAL;\r\nif (op->charcount > 512)\r\nreturn -EINVAL;\r\nif (!op->height) {\r\nint h, i;\r\nu8 __user *charmap = op->data;\r\nu8 tmp;\r\nif (!(op->flags & KD_FONT_FLAG_OLD))\r\nreturn -EINVAL;\r\nfor (h = 32; h > 0; h--)\r\nfor (i = 0; i < op->charcount; i++) {\r\nif (get_user(tmp, &charmap[32*i+h-1]))\r\nreturn -EFAULT;\r\nif (tmp)\r\ngoto nonzero;\r\n}\r\nreturn -EINVAL;\r\nnonzero:\r\nop->height = h;\r\n}\r\nif (op->width <= 0 || op->width > 32 || op->height > 32)\r\nreturn -EINVAL;\r\nsize = (op->width+7)/8 * 32 * op->charcount;\r\nif (size > max_font_size)\r\nreturn -ENOSPC;\r\nfont.charcount = op->charcount;\r\nfont.height = op->height;\r\nfont.width = op->width;\r\nfont.data = memdup_user(op->data, size);\r\nif (IS_ERR(font.data))\r\nreturn PTR_ERR(font.data);\r\nconsole_lock();\r\nif (vc->vc_mode != KD_TEXT)\r\nrc = -EINVAL;\r\nelse if (vc->vc_sw->con_font_set)\r\nrc = vc->vc_sw->con_font_set(vc, &font, op->flags);\r\nelse\r\nrc = -ENOSYS;\r\nconsole_unlock();\r\nkfree(font.data);\r\nreturn rc;\r\n}\r\nstatic int con_font_default(struct vc_data *vc, struct console_font_op *op)\r\n{\r\nstruct console_font font = {.width = op->width, .height = op->height};\r\nchar name[MAX_FONT_NAME];\r\nchar *s = name;\r\nint rc;\r\nif (!op->data)\r\ns = NULL;\r\nelse if (strncpy_from_user(name, op->data, MAX_FONT_NAME - 1) < 0)\r\nreturn -EFAULT;\r\nelse\r\nname[MAX_FONT_NAME - 1] = 0;\r\nconsole_lock();\r\nif (vc->vc_mode != KD_TEXT) {\r\nconsole_unlock();\r\nreturn -EINVAL;\r\n}\r\nif (vc->vc_sw->con_font_default)\r\nrc = vc->vc_sw->con_font_default(vc, &font, s);\r\nelse\r\nrc = -ENOSYS;\r\nconsole_unlock();\r\nif (!rc) {\r\nop->width = font.width;\r\nop->height = font.height;\r\n}\r\nreturn rc;\r\n}\r\nstatic int con_font_copy(struct vc_data *vc, struct console_font_op *op)\r\n{\r\nint con = op->height;\r\nint rc;\r\nconsole_lock();\r\nif (vc->vc_mode != KD_TEXT)\r\nrc = -EINVAL;\r\nelse if (!vc->vc_sw->con_font_copy)\r\nrc = -ENOSYS;\r\nelse if (con < 0 || !vc_cons_allocated(con))\r\nrc = -ENOTTY;\r\nelse if (con == vc->vc_num)\r\nrc = 0;\r\nelse\r\nrc = vc->vc_sw->con_font_copy(vc, con);\r\nconsole_unlock();\r\nreturn rc;\r\n}\r\nint con_font_op(struct vc_data *vc, struct console_font_op *op)\r\n{\r\nswitch (op->op) {\r\ncase KD_FONT_OP_SET:\r\nreturn con_font_set(vc, op);\r\ncase KD_FONT_OP_GET:\r\nreturn con_font_get(vc, op);\r\ncase KD_FONT_OP_SET_DEFAULT:\r\nreturn con_font_default(vc, op);\r\ncase KD_FONT_OP_COPY:\r\nreturn con_font_copy(vc, op);\r\n}\r\nreturn -ENOSYS;\r\n}\r\nu16 screen_glyph(struct vc_data *vc, int offset)\r\n{\r\nu16 w = scr_readw(screenpos(vc, offset, 1));\r\nu16 c = w & 0xff;\r\nif (w & vc->vc_hi_font_mask)\r\nc |= 0x100;\r\nreturn c;\r\n}\r\nunsigned short *screen_pos(struct vc_data *vc, int w_offset, int viewed)\r\n{\r\nreturn screenpos(vc, 2 * w_offset, viewed);\r\n}\r\nvoid getconsxy(struct vc_data *vc, unsigned char *p)\r\n{\r\np[0] = vc->vc_x;\r\np[1] = vc->vc_y;\r\n}\r\nvoid putconsxy(struct vc_data *vc, unsigned char *p)\r\n{\r\nhide_cursor(vc);\r\ngotoxy(vc, p[0], p[1]);\r\nset_cursor(vc);\r\n}\r\nu16 vcs_scr_readw(struct vc_data *vc, const u16 *org)\r\n{\r\nif ((unsigned long)org == vc->vc_pos && softcursor_original != -1)\r\nreturn softcursor_original;\r\nreturn scr_readw(org);\r\n}\r\nvoid vcs_scr_writew(struct vc_data *vc, u16 val, u16 *org)\r\n{\r\nscr_writew(val, org);\r\nif ((unsigned long)org == vc->vc_pos) {\r\nsoftcursor_original = -1;\r\nadd_softcursor(vc);\r\n}\r\n}\r\nvoid vcs_scr_updated(struct vc_data *vc)\r\n{\r\nnotify_update(vc);\r\n}\r\nvoid vc_scrolldelta_helper(struct vc_data *c, int lines,\r\nunsigned int rolled_over, void *base, unsigned int size)\r\n{\r\nunsigned long ubase = (unsigned long)base;\r\nptrdiff_t scr_end = (void *)c->vc_scr_end - base;\r\nptrdiff_t vorigin = (void *)c->vc_visible_origin - base;\r\nptrdiff_t origin = (void *)c->vc_origin - base;\r\nint margin = c->vc_size_row * 4;\r\nint from, wrap, from_off, avail;\r\nif (!lines) {\r\nc->vc_visible_origin = c->vc_origin;\r\nreturn;\r\n}\r\nif (rolled_over > scr_end + margin) {\r\nfrom = scr_end;\r\nwrap = rolled_over + c->vc_size_row;\r\n} else {\r\nfrom = 0;\r\nwrap = size;\r\n}\r\nfrom_off = (vorigin - from + wrap) % wrap + lines * c->vc_size_row;\r\navail = (origin - from + wrap) % wrap;\r\nif (avail < 2 * margin)\r\nmargin = 0;\r\nif (from_off < margin)\r\nfrom_off = 0;\r\nif (from_off > avail - margin)\r\nfrom_off = avail;\r\nc->vc_visible_origin = ubase + (from + from_off) % wrap;\r\n}
