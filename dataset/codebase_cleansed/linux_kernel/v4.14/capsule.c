bool efi_capsule_pending(int *reset_type)\r\n{\r\nif (!capsule_pending)\r\nreturn false;\r\nif (reset_type)\r\n*reset_type = efi_reset_type;\r\nreturn true;\r\n}\r\nint efi_capsule_supported(efi_guid_t guid, u32 flags, size_t size, int *reset)\r\n{\r\nefi_capsule_header_t capsule;\r\nefi_capsule_header_t *cap_list[] = { &capsule };\r\nefi_status_t status;\r\nu64 max_size;\r\nif (flags & ~EFI_CAPSULE_SUPPORTED_FLAG_MASK)\r\nreturn -EINVAL;\r\ncapsule.headersize = capsule.imagesize = sizeof(capsule);\r\nmemcpy(&capsule.guid, &guid, sizeof(efi_guid_t));\r\ncapsule.flags = flags;\r\nstatus = efi.query_capsule_caps(cap_list, 1, &max_size, reset);\r\nif (status != EFI_SUCCESS)\r\nreturn efi_status_to_err(status);\r\nif (size > max_size)\r\nreturn -ENOSPC;\r\nreturn 0;\r\n}\r\nstatic inline unsigned int sg_pages_num(unsigned int count)\r\n{\r\nreturn DIV_ROUND_UP(count, SGLIST_PER_PAGE);\r\n}\r\nstatic int\r\nefi_capsule_update_locked(efi_capsule_header_t *capsule,\r\nstruct page **sg_pages, int reset)\r\n{\r\nefi_physical_addr_t sglist_phys;\r\nefi_status_t status;\r\nlockdep_assert_held(&capsule_mutex);\r\nif (efi_reset_type >= 0 && efi_reset_type != reset) {\r\npr_err("Conflicting capsule reset type %d (%d).\n",\r\nreset, efi_reset_type);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(stop_capsules)) {\r\npr_warn("Capsule update raced with reboot, aborting.\n");\r\nreturn -EINVAL;\r\n}\r\nsglist_phys = page_to_phys(sg_pages[0]);\r\nstatus = efi.update_capsule(&capsule, 1, sglist_phys);\r\nif (status == EFI_SUCCESS) {\r\ncapsule_pending = true;\r\nefi_reset_type = reset;\r\n}\r\nreturn efi_status_to_err(status);\r\n}\r\nint efi_capsule_update(efi_capsule_header_t *capsule, phys_addr_t *pages)\r\n{\r\nu32 imagesize = capsule->imagesize;\r\nefi_guid_t guid = capsule->guid;\r\nunsigned int count, sg_count;\r\nu32 flags = capsule->flags;\r\nstruct page **sg_pages;\r\nint rv, reset_type;\r\nint i, j;\r\nrv = efi_capsule_supported(guid, flags, imagesize, &reset_type);\r\nif (rv)\r\nreturn rv;\r\ncount = DIV_ROUND_UP(imagesize, PAGE_SIZE);\r\nsg_count = sg_pages_num(count);\r\nsg_pages = kzalloc(sg_count * sizeof(*sg_pages), GFP_KERNEL);\r\nif (!sg_pages)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < sg_count; i++) {\r\nsg_pages[i] = alloc_page(GFP_KERNEL);\r\nif (!sg_pages[i]) {\r\nrv = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < sg_count; i++) {\r\nefi_capsule_block_desc_t *sglist;\r\nsglist = kmap(sg_pages[i]);\r\nfor (j = 0; j < SGLIST_PER_PAGE && count > 0; j++) {\r\nu64 sz = min_t(u64, imagesize,\r\nPAGE_SIZE - (u64)*pages % PAGE_SIZE);\r\nsglist[j].length = sz;\r\nsglist[j].data = *pages++;\r\nimagesize -= sz;\r\ncount--;\r\n}\r\nsglist[j].length = 0;\r\nif (i + 1 == sg_count)\r\nsglist[j].data = 0;\r\nelse\r\nsglist[j].data = page_to_phys(sg_pages[i + 1]);\r\nkunmap(sg_pages[i]);\r\n}\r\nmutex_lock(&capsule_mutex);\r\nrv = efi_capsule_update_locked(capsule, sg_pages, reset_type);\r\nmutex_unlock(&capsule_mutex);\r\nout:\r\nfor (i = 0; rv && i < sg_count; i++) {\r\nif (sg_pages[i])\r\n__free_page(sg_pages[i]);\r\n}\r\nkfree(sg_pages);\r\nreturn rv;\r\n}\r\nstatic int capsule_reboot_notify(struct notifier_block *nb, unsigned long event, void *cmd)\r\n{\r\nmutex_lock(&capsule_mutex);\r\nstop_capsules = true;\r\nmutex_unlock(&capsule_mutex);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init capsule_reboot_register(void)\r\n{\r\nreturn register_reboot_notifier(&capsule_reboot_nb);\r\n}
