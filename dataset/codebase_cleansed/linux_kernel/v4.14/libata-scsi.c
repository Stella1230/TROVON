static ssize_t ata_scsi_lpm_store(struct device *device,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(device);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nstruct ata_link *link;\r\nstruct ata_device *dev;\r\nenum ata_lpm_policy policy;\r\nunsigned long flags;\r\nfor (policy = ATA_LPM_MAX_POWER;\r\npolicy < ARRAY_SIZE(ata_lpm_policy_names); policy++) {\r\nconst char *name = ata_lpm_policy_names[policy];\r\nif (strncmp(name, buf, strlen(name)) == 0)\r\nbreak;\r\n}\r\nif (policy == ARRAY_SIZE(ata_lpm_policy_names))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(ap->lock, flags);\r\nata_for_each_link(link, ap, EDGE) {\r\nata_for_each_dev(dev, &ap->link, ENABLED) {\r\nif (dev->horkage & ATA_HORKAGE_NOLPM) {\r\ncount = -EOPNOTSUPP;\r\ngoto out_unlock;\r\n}\r\n}\r\n}\r\nap->target_lpm_policy = policy;\r\nata_port_schedule_eh(ap);\r\nout_unlock:\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nreturn count;\r\n}\r\nstatic ssize_t ata_scsi_lpm_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nif (ap->target_lpm_policy >= ARRAY_SIZE(ata_lpm_policy_names))\r\nreturn -EINVAL;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nata_lpm_policy_names[ap->target_lpm_policy]);\r\n}\r\nstatic ssize_t ata_scsi_park_show(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(device);\r\nstruct ata_port *ap;\r\nstruct ata_link *link;\r\nstruct ata_device *dev;\r\nunsigned long now;\r\nunsigned int uninitialized_var(msecs);\r\nint rc = 0;\r\nap = ata_shost_to_port(sdev->host);\r\nspin_lock_irq(ap->lock);\r\ndev = ata_scsi_find_dev(ap, sdev);\r\nif (!dev) {\r\nrc = -ENODEV;\r\ngoto unlock;\r\n}\r\nif (dev->flags & ATA_DFLAG_NO_UNLOAD) {\r\nrc = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\nlink = dev->link;\r\nnow = jiffies;\r\nif (ap->pflags & ATA_PFLAG_EH_IN_PROGRESS &&\r\nlink->eh_context.unloaded_mask & (1 << dev->devno) &&\r\ntime_after(dev->unpark_deadline, now))\r\nmsecs = jiffies_to_msecs(dev->unpark_deadline - now);\r\nelse\r\nmsecs = 0;\r\nunlock:\r\nspin_unlock_irq(ap->lock);\r\nreturn rc ? rc : snprintf(buf, 20, "%u\n", msecs);\r\n}\r\nstatic ssize_t ata_scsi_park_store(struct device *device,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(device);\r\nstruct ata_port *ap;\r\nstruct ata_device *dev;\r\nlong int input;\r\nunsigned long flags;\r\nint rc;\r\nrc = kstrtol(buf, 10, &input);\r\nif (rc)\r\nreturn rc;\r\nif (input < -2)\r\nreturn -EINVAL;\r\nif (input > ATA_TMOUT_MAX_PARK) {\r\nrc = -EOVERFLOW;\r\ninput = ATA_TMOUT_MAX_PARK;\r\n}\r\nap = ata_shost_to_port(sdev->host);\r\nspin_lock_irqsave(ap->lock, flags);\r\ndev = ata_scsi_find_dev(ap, sdev);\r\nif (unlikely(!dev)) {\r\nrc = -ENODEV;\r\ngoto unlock;\r\n}\r\nif (dev->class != ATA_DEV_ATA &&\r\ndev->class != ATA_DEV_ZAC) {\r\nrc = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\nif (input >= 0) {\r\nif (dev->flags & ATA_DFLAG_NO_UNLOAD) {\r\nrc = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\ndev->unpark_deadline = ata_deadline(jiffies, input);\r\ndev->link->eh_info.dev_action[dev->devno] |= ATA_EH_PARK;\r\nata_port_schedule_eh(ap);\r\ncomplete(&ap->park_req_pending);\r\n} else {\r\nswitch (input) {\r\ncase -1:\r\ndev->flags &= ~ATA_DFLAG_NO_UNLOAD;\r\nbreak;\r\ncase -2:\r\ndev->flags |= ATA_DFLAG_NO_UNLOAD;\r\nbreak;\r\n}\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nreturn rc ? rc : len;\r\n}\r\nstatic ssize_t ata_ncq_prio_enable_show(struct device *device,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(device);\r\nstruct ata_port *ap;\r\nstruct ata_device *dev;\r\nbool ncq_prio_enable;\r\nint rc = 0;\r\nap = ata_shost_to_port(sdev->host);\r\nspin_lock_irq(ap->lock);\r\ndev = ata_scsi_find_dev(ap, sdev);\r\nif (!dev) {\r\nrc = -ENODEV;\r\ngoto unlock;\r\n}\r\nncq_prio_enable = dev->flags & ATA_DFLAG_NCQ_PRIO_ENABLE;\r\nunlock:\r\nspin_unlock_irq(ap->lock);\r\nreturn rc ? rc : snprintf(buf, 20, "%u\n", ncq_prio_enable);\r\n}\r\nstatic ssize_t ata_ncq_prio_enable_store(struct device *device,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(device);\r\nstruct ata_port *ap;\r\nstruct ata_device *dev;\r\nlong int input;\r\nint rc;\r\nrc = kstrtol(buf, 10, &input);\r\nif (rc)\r\nreturn rc;\r\nif ((input < 0) || (input > 1))\r\nreturn -EINVAL;\r\nap = ata_shost_to_port(sdev->host);\r\ndev = ata_scsi_find_dev(ap, sdev);\r\nif (unlikely(!dev))\r\nreturn -ENODEV;\r\nspin_lock_irq(ap->lock);\r\nif (input)\r\ndev->flags |= ATA_DFLAG_NCQ_PRIO_ENABLE;\r\nelse\r\ndev->flags &= ~ATA_DFLAG_NCQ_PRIO_ENABLE;\r\ndev->link->eh_info.action |= ATA_EH_REVALIDATE;\r\ndev->link->eh_info.flags |= ATA_EHI_QUIET;\r\nata_port_schedule_eh(ap);\r\nspin_unlock_irq(ap->lock);\r\nata_port_wait_eh(ap);\r\nif (input) {\r\nspin_lock_irq(ap->lock);\r\nif (!(dev->flags & ATA_DFLAG_NCQ_PRIO)) {\r\ndev->flags &= ~ATA_DFLAG_NCQ_PRIO_ENABLE;\r\nrc = -EIO;\r\n}\r\nspin_unlock_irq(ap->lock);\r\n}\r\nreturn rc ? rc : len;\r\n}\r\nvoid ata_scsi_set_sense(struct ata_device *dev, struct scsi_cmnd *cmd,\r\nu8 sk, u8 asc, u8 ascq)\r\n{\r\nbool d_sense = (dev->flags & ATA_DFLAG_D_SENSE);\r\nif (!cmd)\r\nreturn;\r\ncmd->result = (DRIVER_SENSE << 24) | SAM_STAT_CHECK_CONDITION;\r\nscsi_build_sense_buffer(d_sense, cmd->sense_buffer, sk, asc, ascq);\r\n}\r\nvoid ata_scsi_set_sense_information(struct ata_device *dev,\r\nstruct scsi_cmnd *cmd,\r\nconst struct ata_taskfile *tf)\r\n{\r\nu64 information;\r\nif (!cmd)\r\nreturn;\r\ninformation = ata_tf_read_block(tf, dev);\r\nif (information == U64_MAX)\r\nreturn;\r\nscsi_set_sense_information(cmd->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE, information);\r\n}\r\nstatic void ata_scsi_set_invalid_field(struct ata_device *dev,\r\nstruct scsi_cmnd *cmd, u16 field, u8 bit)\r\n{\r\nata_scsi_set_sense(dev, cmd, ILLEGAL_REQUEST, 0x24, 0x0);\r\nscsi_set_sense_field_pointer(cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE,\r\nfield, bit, 1);\r\n}\r\nstatic void ata_scsi_set_invalid_parameter(struct ata_device *dev,\r\nstruct scsi_cmnd *cmd, u16 field)\r\n{\r\nata_scsi_set_sense(dev, cmd, ILLEGAL_REQUEST, 0x26, 0x0);\r\nscsi_set_sense_field_pointer(cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE,\r\nfield, 0xff, 0);\r\n}\r\nstatic ssize_t\r\nata_scsi_em_message_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nif (ap->ops->em_store && (ap->flags & ATA_FLAG_EM))\r\nreturn ap->ops->em_store(ap, buf, count);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t\r\nata_scsi_em_message_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nif (ap->ops->em_show && (ap->flags & ATA_FLAG_EM))\r\nreturn ap->ops->em_show(ap, buf);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t\r\nata_scsi_em_message_type_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nreturn snprintf(buf, 23, "%d\n", ap->em_message_type);\r\n}\r\nstatic ssize_t\r\nata_scsi_activity_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nstruct ata_port *ap = ata_shost_to_port(sdev->host);\r\nstruct ata_device *atadev = ata_scsi_find_dev(ap, sdev);\r\nif (atadev && ap->ops->sw_activity_show &&\r\n(ap->flags & ATA_FLAG_SW_ACTIVITY))\r\nreturn ap->ops->sw_activity_show(atadev, buf);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t\r\nata_scsi_activity_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nstruct ata_port *ap = ata_shost_to_port(sdev->host);\r\nstruct ata_device *atadev = ata_scsi_find_dev(ap, sdev);\r\nenum sw_activity val;\r\nint rc;\r\nif (atadev && ap->ops->sw_activity_store &&\r\n(ap->flags & ATA_FLAG_SW_ACTIVITY)) {\r\nval = simple_strtoul(buf, NULL, 0);\r\nswitch (val) {\r\ncase OFF: case BLINK_ON: case BLINK_OFF:\r\nrc = ap->ops->sw_activity_store(atadev, val);\r\nif (!rc)\r\nreturn count;\r\nelse\r\nreturn rc;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint ata_std_bios_param(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int geom[])\r\n{\r\ngeom[0] = 255;\r\ngeom[1] = 63;\r\nsector_div(capacity, 255*63);\r\ngeom[2] = capacity;\r\nreturn 0;\r\n}\r\nvoid ata_scsi_unlock_native_capacity(struct scsi_device *sdev)\r\n{\r\nstruct ata_port *ap = ata_shost_to_port(sdev->host);\r\nstruct ata_device *dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(ap->lock, flags);\r\ndev = ata_scsi_find_dev(ap, sdev);\r\nif (dev && dev->n_sectors < dev->n_native_sectors) {\r\ndev->flags |= ATA_DFLAG_UNLOCK_HPA;\r\ndev->link->eh_info.action |= ATA_EH_RESET;\r\nata_port_schedule_eh(ap);\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nata_port_wait_eh(ap);\r\n}\r\nstatic int ata_get_identity(struct ata_port *ap, struct scsi_device *sdev,\r\nvoid __user *arg)\r\n{\r\nstruct ata_device *dev = ata_scsi_find_dev(ap, sdev);\r\nu16 __user *dst = arg;\r\nchar buf[40];\r\nif (!dev)\r\nreturn -ENOMSG;\r\nif (copy_to_user(dst, dev->id, ATA_ID_WORDS * sizeof(u16)))\r\nreturn -EFAULT;\r\nata_id_string(dev->id, buf, ATA_ID_PROD, ATA_ID_PROD_LEN);\r\nif (copy_to_user(dst + ATA_ID_PROD, buf, ATA_ID_PROD_LEN))\r\nreturn -EFAULT;\r\nata_id_string(dev->id, buf, ATA_ID_FW_REV, ATA_ID_FW_REV_LEN);\r\nif (copy_to_user(dst + ATA_ID_FW_REV, buf, ATA_ID_FW_REV_LEN))\r\nreturn -EFAULT;\r\nata_id_string(dev->id, buf, ATA_ID_SERNO, ATA_ID_SERNO_LEN);\r\nif (copy_to_user(dst + ATA_ID_SERNO, buf, ATA_ID_SERNO_LEN))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg)\r\n{\r\nint rc = 0;\r\nu8 scsi_cmd[MAX_COMMAND_SIZE];\r\nu8 args[4], *argbuf = NULL, *sensebuf = NULL;\r\nint argsize = 0;\r\nenum dma_data_direction data_dir;\r\nstruct scsi_sense_hdr sshdr;\r\nint cmd_result;\r\nif (arg == NULL)\r\nreturn -EINVAL;\r\nif (copy_from_user(args, arg, sizeof(args)))\r\nreturn -EFAULT;\r\nsensebuf = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_NOIO);\r\nif (!sensebuf)\r\nreturn -ENOMEM;\r\nmemset(scsi_cmd, 0, sizeof(scsi_cmd));\r\nif (args[3]) {\r\nargsize = ATA_SECT_SIZE * args[3];\r\nargbuf = kmalloc(argsize, GFP_KERNEL);\r\nif (argbuf == NULL) {\r\nrc = -ENOMEM;\r\ngoto error;\r\n}\r\nscsi_cmd[1] = (4 << 1);\r\nscsi_cmd[2] = 0x0e;\r\ndata_dir = DMA_FROM_DEVICE;\r\n} else {\r\nscsi_cmd[1] = (3 << 1);\r\nscsi_cmd[2] = 0x20;\r\ndata_dir = DMA_NONE;\r\n}\r\nscsi_cmd[0] = ATA_16;\r\nscsi_cmd[4] = args[2];\r\nif (args[0] == ATA_CMD_SMART) {\r\nscsi_cmd[6] = args[3];\r\nscsi_cmd[8] = args[1];\r\nscsi_cmd[10] = 0x4f;\r\nscsi_cmd[12] = 0xc2;\r\n} else {\r\nscsi_cmd[6] = args[1];\r\n}\r\nscsi_cmd[14] = args[0];\r\ncmd_result = scsi_execute(scsidev, scsi_cmd, data_dir, argbuf, argsize,\r\nsensebuf, &sshdr, (10*HZ), 5, 0, 0, NULL);\r\nif (driver_byte(cmd_result) == DRIVER_SENSE) {\r\nu8 *desc = sensebuf + 8;\r\ncmd_result &= ~(0xFF<<24);\r\nif (cmd_result & SAM_STAT_CHECK_CONDITION) {\r\nif (sshdr.sense_key == RECOVERED_ERROR &&\r\nsshdr.asc == 0 && sshdr.ascq == 0x1d)\r\ncmd_result &= ~SAM_STAT_CHECK_CONDITION;\r\n}\r\nif (sensebuf[0] == 0x72 &&\r\ndesc[0] == 0x09) {\r\nargs[0] = desc[13];\r\nargs[1] = desc[3];\r\nargs[2] = desc[5];\r\nif (copy_to_user(arg, args, sizeof(args)))\r\nrc = -EFAULT;\r\n}\r\n}\r\nif (cmd_result) {\r\nrc = -EIO;\r\ngoto error;\r\n}\r\nif ((argbuf)\r\n&& copy_to_user(arg + sizeof(args), argbuf, argsize))\r\nrc = -EFAULT;\r\nerror:\r\nkfree(sensebuf);\r\nkfree(argbuf);\r\nreturn rc;\r\n}\r\nint ata_task_ioctl(struct scsi_device *scsidev, void __user *arg)\r\n{\r\nint rc = 0;\r\nu8 scsi_cmd[MAX_COMMAND_SIZE];\r\nu8 args[7], *sensebuf = NULL;\r\nstruct scsi_sense_hdr sshdr;\r\nint cmd_result;\r\nif (arg == NULL)\r\nreturn -EINVAL;\r\nif (copy_from_user(args, arg, sizeof(args)))\r\nreturn -EFAULT;\r\nsensebuf = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_NOIO);\r\nif (!sensebuf)\r\nreturn -ENOMEM;\r\nmemset(scsi_cmd, 0, sizeof(scsi_cmd));\r\nscsi_cmd[0] = ATA_16;\r\nscsi_cmd[1] = (3 << 1);\r\nscsi_cmd[2] = 0x20;\r\nscsi_cmd[4] = args[1];\r\nscsi_cmd[6] = args[2];\r\nscsi_cmd[8] = args[3];\r\nscsi_cmd[10] = args[4];\r\nscsi_cmd[12] = args[5];\r\nscsi_cmd[13] = args[6] & 0x4f;\r\nscsi_cmd[14] = args[0];\r\ncmd_result = scsi_execute(scsidev, scsi_cmd, DMA_NONE, NULL, 0,\r\nsensebuf, &sshdr, (10*HZ), 5, 0, 0, NULL);\r\nif (driver_byte(cmd_result) == DRIVER_SENSE) {\r\nu8 *desc = sensebuf + 8;\r\ncmd_result &= ~(0xFF<<24);\r\nif (cmd_result & SAM_STAT_CHECK_CONDITION) {\r\nif (sshdr.sense_key == RECOVERED_ERROR &&\r\nsshdr.asc == 0 && sshdr.ascq == 0x1d)\r\ncmd_result &= ~SAM_STAT_CHECK_CONDITION;\r\n}\r\nif (sensebuf[0] == 0x72 &&\r\ndesc[0] == 0x09) {\r\nargs[0] = desc[13];\r\nargs[1] = desc[3];\r\nargs[2] = desc[5];\r\nargs[3] = desc[7];\r\nargs[4] = desc[9];\r\nargs[5] = desc[11];\r\nargs[6] = desc[12];\r\nif (copy_to_user(arg, args, sizeof(args)))\r\nrc = -EFAULT;\r\n}\r\n}\r\nif (cmd_result) {\r\nrc = -EIO;\r\ngoto error;\r\n}\r\nerror:\r\nkfree(sensebuf);\r\nreturn rc;\r\n}\r\nstatic int ata_ioc32(struct ata_port *ap)\r\n{\r\nif (ap->flags & ATA_FLAG_PIO_DMA)\r\nreturn 1;\r\nif (ap->pflags & ATA_PFLAG_PIO32)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *scsidev,\r\nint cmd, void __user *arg)\r\n{\r\nunsigned long val;\r\nint rc = -EINVAL;\r\nunsigned long flags;\r\nswitch (cmd) {\r\ncase HDIO_GET_32BIT:\r\nspin_lock_irqsave(ap->lock, flags);\r\nval = ata_ioc32(ap);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nreturn put_user(val, (unsigned long __user *)arg);\r\ncase HDIO_SET_32BIT:\r\nval = (unsigned long) arg;\r\nrc = 0;\r\nspin_lock_irqsave(ap->lock, flags);\r\nif (ap->pflags & ATA_PFLAG_PIO32CHANGE) {\r\nif (val)\r\nap->pflags |= ATA_PFLAG_PIO32;\r\nelse\r\nap->pflags &= ~ATA_PFLAG_PIO32;\r\n} else {\r\nif (val != ata_ioc32(ap))\r\nrc = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nreturn rc;\r\ncase HDIO_GET_IDENTITY:\r\nreturn ata_get_identity(ap, scsidev, arg);\r\ncase HDIO_DRIVE_CMD:\r\nif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nreturn ata_cmd_ioctl(scsidev, arg);\r\ncase HDIO_DRIVE_TASK:\r\nif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nreturn ata_task_ioctl(scsidev, arg);\r\ndefault:\r\nrc = -ENOTTY;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint ata_scsi_ioctl(struct scsi_device *scsidev, int cmd, void __user *arg)\r\n{\r\nreturn ata_sas_scsi_ioctl(ata_shost_to_port(scsidev->host),\r\nscsidev, cmd, arg);\r\n}\r\nstatic struct ata_queued_cmd *ata_scsi_qc_new(struct ata_device *dev,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct ata_queued_cmd *qc;\r\nqc = ata_qc_new_init(dev, cmd->request->tag);\r\nif (qc) {\r\nqc->scsicmd = cmd;\r\nqc->scsidone = cmd->scsi_done;\r\nqc->sg = scsi_sglist(cmd);\r\nqc->n_elem = scsi_sg_count(cmd);\r\n} else {\r\ncmd->result = (DID_OK << 16) | (QUEUE_FULL << 1);\r\ncmd->scsi_done(cmd);\r\n}\r\nreturn qc;\r\n}\r\nstatic void ata_qc_set_pc_nbytes(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nqc->extrabytes = scmd->request->extra_len;\r\nqc->nbytes = scsi_bufflen(scmd) + qc->extrabytes;\r\n}\r\nstatic void ata_dump_status(unsigned id, struct ata_taskfile *tf)\r\n{\r\nu8 stat = tf->command, err = tf->feature;\r\npr_warn("ata%u: status=0x%02x { ", id, stat);\r\nif (stat & ATA_BUSY) {\r\npr_cont("Busy }\n");\r\n} else {\r\nif (stat & ATA_DRDY) pr_cont("DriveReady ");\r\nif (stat & ATA_DF) pr_cont("DeviceFault ");\r\nif (stat & ATA_DSC) pr_cont("SeekComplete ");\r\nif (stat & ATA_DRQ) pr_cont("DataRequest ");\r\nif (stat & ATA_CORR) pr_cont("CorrectedError ");\r\nif (stat & ATA_SENSE) pr_cont("Sense ");\r\nif (stat & ATA_ERR) pr_cont("Error ");\r\npr_cont("}\n");\r\nif (err) {\r\npr_warn("ata%u: error=0x%02x { ", id, err);\r\nif (err & ATA_ABORTED) pr_cont("DriveStatusError ");\r\nif (err & ATA_ICRC) {\r\nif (err & ATA_ABORTED)\r\npr_cont("BadCRC ");\r\nelse pr_cont("Sector ");\r\n}\r\nif (err & ATA_UNC) pr_cont("UncorrectableError ");\r\nif (err & ATA_IDNF) pr_cont("SectorIdNotFound ");\r\nif (err & ATA_TRK0NF) pr_cont("TrackZeroNotFound ");\r\nif (err & ATA_AMNF) pr_cont("AddrMarkNotFound ");\r\npr_cont("}\n");\r\n}\r\n}\r\n}\r\nstatic void ata_to_sense_error(unsigned id, u8 drv_stat, u8 drv_err, u8 *sk,\r\nu8 *asc, u8 *ascq, int verbose)\r\n{\r\nint i;\r\nstatic const unsigned char sense_table[][4] = {\r\n{0xd1, ABORTED_COMMAND, 0x00, 0x00},\r\n{0xd0, ABORTED_COMMAND, 0x00, 0x00},\r\n{0x61, HARDWARE_ERROR, 0x00, 0x00},\r\n{0x84, ABORTED_COMMAND, 0x47, 0x00},\r\n{0x37, NOT_READY, 0x04, 0x00},\r\n{0x09, NOT_READY, 0x04, 0x00},\r\n{0x01, MEDIUM_ERROR, 0x13, 0x00},\r\n{0x02, HARDWARE_ERROR, 0x00, 0x00},\r\n{0x08, NOT_READY, 0x04, 0x00},\r\n{0x10, ILLEGAL_REQUEST, 0x21, 0x00},\r\n{0x20, UNIT_ATTENTION, 0x28, 0x00},\r\n{0x40, MEDIUM_ERROR, 0x11, 0x04},\r\n{0x80, MEDIUM_ERROR, 0x11, 0x04},\r\n{0xFF, 0xFF, 0xFF, 0xFF},\r\n};\r\nstatic const unsigned char stat_table[][4] = {\r\n{0x80, ABORTED_COMMAND, 0x47, 0x00},\r\n{0x40, ILLEGAL_REQUEST, 0x21, 0x04},\r\n{0x20, HARDWARE_ERROR, 0x44, 0x00},\r\n{0x08, ABORTED_COMMAND, 0x47, 0x00},\r\n{0x04, RECOVERED_ERROR, 0x11, 0x00},\r\n{0xFF, 0xFF, 0xFF, 0xFF},\r\n};\r\nif (drv_stat & ATA_BUSY) {\r\ndrv_err = 0;\r\n}\r\nif (drv_err) {\r\nfor (i = 0; sense_table[i][0] != 0xFF; i++) {\r\nif ((sense_table[i][0] & drv_err) ==\r\nsense_table[i][0]) {\r\n*sk = sense_table[i][1];\r\n*asc = sense_table[i][2];\r\n*ascq = sense_table[i][3];\r\ngoto translate_done;\r\n}\r\n}\r\n}\r\nfor (i = 0; stat_table[i][0] != 0xFF; i++) {\r\nif (stat_table[i][0] & drv_stat) {\r\n*sk = stat_table[i][1];\r\n*asc = stat_table[i][2];\r\n*ascq = stat_table[i][3];\r\ngoto translate_done;\r\n}\r\n}\r\n*sk = ABORTED_COMMAND;\r\n*asc = 0x00;\r\n*ascq = 0x00;\r\ntranslate_done:\r\nif (verbose)\r\npr_err("ata%u: translated ATA stat/err 0x%02x/%02x to SCSI SK/ASC/ASCQ 0x%x/%02x/%02x\n",\r\nid, drv_stat, drv_err, *sk, *asc, *ascq);\r\nreturn;\r\n}\r\nstatic void ata_gen_passthru_sense(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *cmd = qc->scsicmd;\r\nstruct ata_taskfile *tf = &qc->result_tf;\r\nunsigned char *sb = cmd->sense_buffer;\r\nunsigned char *desc = sb + 8;\r\nint verbose = qc->ap->ops->error_handler == NULL;\r\nu8 sense_key, asc, ascq;\r\nmemset(sb, 0, SCSI_SENSE_BUFFERSIZE);\r\ncmd->result = (DRIVER_SENSE << 24) | SAM_STAT_CHECK_CONDITION;\r\nif (qc->err_mask ||\r\ntf->command & (ATA_BUSY | ATA_DF | ATA_ERR | ATA_DRQ)) {\r\nata_to_sense_error(qc->ap->print_id, tf->command, tf->feature,\r\n&sense_key, &asc, &ascq, verbose);\r\nata_scsi_set_sense(qc->dev, cmd, sense_key, asc, ascq);\r\n} else {\r\nscsi_build_sense_buffer(1, cmd->sense_buffer,\r\nRECOVERED_ERROR, 0, 0x1D);\r\n}\r\nif ((cmd->sense_buffer[0] & 0x7f) >= 0x72) {\r\nu8 len;\r\nlen = sb[7];\r\ndesc = (char *)scsi_sense_desc_find(sb, len + 8, 9);\r\nif (!desc) {\r\nif (SCSI_SENSE_BUFFERSIZE < len + 14)\r\nreturn;\r\nsb[7] = len + 14;\r\ndesc = sb + 8 + len;\r\n}\r\ndesc[0] = 9;\r\ndesc[1] = 12;\r\ndesc[2] = 0x00;\r\ndesc[3] = tf->feature;\r\ndesc[5] = tf->nsect;\r\ndesc[7] = tf->lbal;\r\ndesc[9] = tf->lbam;\r\ndesc[11] = tf->lbah;\r\ndesc[12] = tf->device;\r\ndesc[13] = tf->command;\r\nif (tf->flags & ATA_TFLAG_LBA48) {\r\ndesc[2] |= 0x01;\r\ndesc[4] = tf->hob_nsect;\r\ndesc[6] = tf->hob_lbal;\r\ndesc[8] = tf->hob_lbam;\r\ndesc[10] = tf->hob_lbah;\r\n}\r\n} else {\r\ndesc[0] = tf->feature;\r\ndesc[1] = tf->command;\r\ndesc[2] = tf->device;\r\ndesc[3] = tf->nsect;\r\ndesc[7] = 0;\r\nif (tf->flags & ATA_TFLAG_LBA48) {\r\ndesc[8] |= 0x80;\r\nif (tf->hob_nsect)\r\ndesc[8] |= 0x40;\r\nif (tf->hob_lbal || tf->hob_lbam || tf->hob_lbah)\r\ndesc[8] |= 0x20;\r\n}\r\ndesc[9] = tf->lbal;\r\ndesc[10] = tf->lbam;\r\ndesc[11] = tf->lbah;\r\n}\r\n}\r\nstatic void ata_gen_ata_sense(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_device *dev = qc->dev;\r\nstruct scsi_cmnd *cmd = qc->scsicmd;\r\nstruct ata_taskfile *tf = &qc->result_tf;\r\nunsigned char *sb = cmd->sense_buffer;\r\nint verbose = qc->ap->ops->error_handler == NULL;\r\nu64 block;\r\nu8 sense_key, asc, ascq;\r\nmemset(sb, 0, SCSI_SENSE_BUFFERSIZE);\r\ncmd->result = (DRIVER_SENSE << 24) | SAM_STAT_CHECK_CONDITION;\r\nif (ata_dev_disabled(dev)) {\r\nata_scsi_set_sense(dev, cmd, NOT_READY, 0x04, 0x21);\r\nreturn;\r\n}\r\nif (qc->err_mask ||\r\ntf->command & (ATA_BUSY | ATA_DF | ATA_ERR | ATA_DRQ)) {\r\nata_to_sense_error(qc->ap->print_id, tf->command, tf->feature,\r\n&sense_key, &asc, &ascq, verbose);\r\nata_scsi_set_sense(dev, cmd, sense_key, asc, ascq);\r\n} else {\r\nata_dev_warn(dev, "could not decode error status 0x%x err_mask 0x%x\n",\r\ntf->command, qc->err_mask);\r\nata_scsi_set_sense(dev, cmd, ABORTED_COMMAND, 0, 0);\r\nreturn;\r\n}\r\nblock = ata_tf_read_block(&qc->result_tf, dev);\r\nif (block == U64_MAX)\r\nreturn;\r\nscsi_set_sense_information(sb, SCSI_SENSE_BUFFERSIZE, block);\r\n}\r\nstatic void ata_scsi_sdev_config(struct scsi_device *sdev)\r\n{\r\nsdev->use_10_for_rw = 1;\r\nsdev->use_10_for_ms = 1;\r\nsdev->no_write_same = 1;\r\nsdev->max_device_blocked = 1;\r\n}\r\nstatic int atapi_drain_needed(struct request *rq)\r\n{\r\nif (likely(!blk_rq_is_passthrough(rq)))\r\nreturn 0;\r\nif (!blk_rq_bytes(rq) || op_is_write(req_op(rq)))\r\nreturn 0;\r\nreturn atapi_cmd_type(scsi_req(rq)->cmd[0]) == ATAPI_MISC;\r\n}\r\nstatic int ata_scsi_dev_config(struct scsi_device *sdev,\r\nstruct ata_device *dev)\r\n{\r\nstruct request_queue *q = sdev->request_queue;\r\nif (!ata_id_has_unload(dev->id))\r\ndev->flags |= ATA_DFLAG_NO_UNLOAD;\r\nblk_queue_max_hw_sectors(q, dev->max_sectors);\r\nif (dev->class == ATA_DEV_ATAPI) {\r\nvoid *buf;\r\nsdev->sector_size = ATA_SECT_SIZE;\r\nblk_queue_update_dma_pad(q, ATA_DMA_PAD_SZ - 1);\r\nbuf = kmalloc(ATAPI_MAX_DRAIN, q->bounce_gfp | GFP_KERNEL);\r\nif (!buf) {\r\nata_dev_err(dev, "drain buffer allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nblk_queue_dma_drain(q, atapi_drain_needed, buf, ATAPI_MAX_DRAIN);\r\n} else {\r\nsdev->sector_size = ata_id_logical_sector_size(dev->id);\r\nsdev->manage_start_stop = 1;\r\n}\r\nif (sdev->sector_size > PAGE_SIZE)\r\nata_dev_warn(dev,\r\n"sector_size=%u > PAGE_SIZE, PIO may malfunction\n",\r\nsdev->sector_size);\r\nblk_queue_update_dma_alignment(q, sdev->sector_size - 1);\r\nif (dev->flags & ATA_DFLAG_AN)\r\nset_bit(SDEV_EVT_MEDIA_CHANGE, sdev->supported_events);\r\nif (dev->flags & ATA_DFLAG_NCQ) {\r\nint depth;\r\ndepth = min(sdev->host->can_queue, ata_id_queue_depth(dev->id));\r\ndepth = min(ATA_MAX_QUEUE - 1, depth);\r\nscsi_change_queue_depth(sdev, depth);\r\n}\r\nblk_queue_flush_queueable(q, false);\r\nif (dev->flags & ATA_DFLAG_TRUSTED)\r\nsdev->security_supported = 1;\r\ndev->sdev = sdev;\r\nreturn 0;\r\n}\r\nint ata_scsi_slave_config(struct scsi_device *sdev)\r\n{\r\nstruct ata_port *ap = ata_shost_to_port(sdev->host);\r\nstruct ata_device *dev = __ata_scsi_find_dev(ap, sdev);\r\nint rc = 0;\r\nata_scsi_sdev_config(sdev);\r\nif (dev)\r\nrc = ata_scsi_dev_config(sdev, dev);\r\nreturn rc;\r\n}\r\nvoid ata_scsi_slave_destroy(struct scsi_device *sdev)\r\n{\r\nstruct ata_port *ap = ata_shost_to_port(sdev->host);\r\nstruct request_queue *q = sdev->request_queue;\r\nunsigned long flags;\r\nstruct ata_device *dev;\r\nif (!ap->ops->error_handler)\r\nreturn;\r\nspin_lock_irqsave(ap->lock, flags);\r\ndev = __ata_scsi_find_dev(ap, sdev);\r\nif (dev && dev->sdev) {\r\ndev->sdev = NULL;\r\ndev->flags |= ATA_DFLAG_DETACH;\r\nata_port_schedule_eh(ap);\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nkfree(q->dma_drain_buffer);\r\nq->dma_drain_buffer = NULL;\r\nq->dma_drain_size = 0;\r\n}\r\nint __ata_change_queue_depth(struct ata_port *ap, struct scsi_device *sdev,\r\nint queue_depth)\r\n{\r\nstruct ata_device *dev;\r\nunsigned long flags;\r\nif (queue_depth < 1 || queue_depth == sdev->queue_depth)\r\nreturn sdev->queue_depth;\r\ndev = ata_scsi_find_dev(ap, sdev);\r\nif (!dev || !ata_dev_enabled(dev))\r\nreturn sdev->queue_depth;\r\nspin_lock_irqsave(ap->lock, flags);\r\ndev->flags &= ~ATA_DFLAG_NCQ_OFF;\r\nif (queue_depth == 1 || !ata_ncq_enabled(dev)) {\r\ndev->flags |= ATA_DFLAG_NCQ_OFF;\r\nqueue_depth = 1;\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nqueue_depth = min(queue_depth, sdev->host->can_queue);\r\nqueue_depth = min(queue_depth, ata_id_queue_depth(dev->id));\r\nqueue_depth = min(queue_depth, ATA_MAX_QUEUE - 1);\r\nif (sdev->queue_depth == queue_depth)\r\nreturn -EINVAL;\r\nreturn scsi_change_queue_depth(sdev, queue_depth);\r\n}\r\nint ata_scsi_change_queue_depth(struct scsi_device *sdev, int queue_depth)\r\n{\r\nstruct ata_port *ap = ata_shost_to_port(sdev->host);\r\nreturn __ata_change_queue_depth(ap, sdev, queue_depth);\r\n}\r\nstatic unsigned int ata_scsi_start_stop_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nstruct ata_taskfile *tf = &qc->tf;\r\nconst u8 *cdb = scmd->cmnd;\r\nu16 fp;\r\nu8 bp = 0xff;\r\nif (scmd->cmd_len < 5) {\r\nfp = 4;\r\ngoto invalid_fld;\r\n}\r\ntf->flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR;\r\ntf->protocol = ATA_PROT_NODATA;\r\nif (cdb[1] & 0x1) {\r\n;\r\n}\r\nif (cdb[4] & 0x2) {\r\nfp = 4;\r\nbp = 1;\r\ngoto invalid_fld;\r\n}\r\nif (((cdb[4] >> 4) & 0xf) != 0) {\r\nfp = 4;\r\nbp = 3;\r\ngoto invalid_fld;\r\n}\r\nif (cdb[4] & 0x1) {\r\ntf->nsect = 1;\r\nif (qc->dev->flags & ATA_DFLAG_LBA) {\r\ntf->flags |= ATA_TFLAG_LBA;\r\ntf->lbah = 0x0;\r\ntf->lbam = 0x0;\r\ntf->lbal = 0x0;\r\ntf->device |= ATA_LBA;\r\n} else {\r\ntf->lbal = 0x1;\r\ntf->lbam = 0x0;\r\ntf->lbah = 0x0;\r\n}\r\ntf->command = ATA_CMD_VERIFY;\r\n} else {\r\nif ((qc->ap->flags & ATA_FLAG_NO_POWEROFF_SPINDOWN) &&\r\nsystem_state == SYSTEM_POWER_OFF)\r\ngoto skip;\r\nif ((qc->ap->flags & ATA_FLAG_NO_HIBERNATE_SPINDOWN) &&\r\nsystem_entering_hibernation())\r\ngoto skip;\r\ntf->command = ATA_CMD_STANDBYNOW1;\r\n}\r\nreturn 0;\r\ninvalid_fld:\r\nata_scsi_set_invalid_field(qc->dev, scmd, fp, bp);\r\nreturn 1;\r\nskip:\r\nscmd->result = SAM_STAT_GOOD;\r\nreturn 1;\r\n}\r\nstatic unsigned int ata_scsi_flush_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_taskfile *tf = &qc->tf;\r\ntf->flags |= ATA_TFLAG_DEVICE;\r\ntf->protocol = ATA_PROT_NODATA;\r\nif (qc->dev->flags & ATA_DFLAG_FLUSH_EXT)\r\ntf->command = ATA_CMD_FLUSH_EXT;\r\nelse\r\ntf->command = ATA_CMD_FLUSH;\r\nqc->flags |= ATA_QCFLAG_IO;\r\nreturn 0;\r\n}\r\nstatic void scsi_6_lba_len(const u8 *cdb, u64 *plba, u32 *plen)\r\n{\r\nu64 lba = 0;\r\nu32 len;\r\nVPRINTK("six-byte command\n");\r\nlba |= ((u64)(cdb[1] & 0x1f)) << 16;\r\nlba |= ((u64)cdb[2]) << 8;\r\nlba |= ((u64)cdb[3]);\r\nlen = cdb[4];\r\n*plba = lba;\r\n*plen = len;\r\n}\r\nstatic void scsi_10_lba_len(const u8 *cdb, u64 *plba, u32 *plen)\r\n{\r\nu64 lba = 0;\r\nu32 len = 0;\r\nVPRINTK("ten-byte command\n");\r\nlba |= ((u64)cdb[2]) << 24;\r\nlba |= ((u64)cdb[3]) << 16;\r\nlba |= ((u64)cdb[4]) << 8;\r\nlba |= ((u64)cdb[5]);\r\nlen |= ((u32)cdb[7]) << 8;\r\nlen |= ((u32)cdb[8]);\r\n*plba = lba;\r\n*plen = len;\r\n}\r\nstatic void scsi_16_lba_len(const u8 *cdb, u64 *plba, u32 *plen)\r\n{\r\nu64 lba = 0;\r\nu32 len = 0;\r\nVPRINTK("sixteen-byte command\n");\r\nlba |= ((u64)cdb[2]) << 56;\r\nlba |= ((u64)cdb[3]) << 48;\r\nlba |= ((u64)cdb[4]) << 40;\r\nlba |= ((u64)cdb[5]) << 32;\r\nlba |= ((u64)cdb[6]) << 24;\r\nlba |= ((u64)cdb[7]) << 16;\r\nlba |= ((u64)cdb[8]) << 8;\r\nlba |= ((u64)cdb[9]);\r\nlen |= ((u32)cdb[10]) << 24;\r\nlen |= ((u32)cdb[11]) << 16;\r\nlen |= ((u32)cdb[12]) << 8;\r\nlen |= ((u32)cdb[13]);\r\n*plba = lba;\r\n*plen = len;\r\n}\r\nstatic unsigned int ata_scsi_verify_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nstruct ata_taskfile *tf = &qc->tf;\r\nstruct ata_device *dev = qc->dev;\r\nu64 dev_sectors = qc->dev->n_sectors;\r\nconst u8 *cdb = scmd->cmnd;\r\nu64 block;\r\nu32 n_block;\r\nu16 fp;\r\ntf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\r\ntf->protocol = ATA_PROT_NODATA;\r\nif (cdb[0] == VERIFY) {\r\nif (scmd->cmd_len < 10) {\r\nfp = 9;\r\ngoto invalid_fld;\r\n}\r\nscsi_10_lba_len(cdb, &block, &n_block);\r\n} else if (cdb[0] == VERIFY_16) {\r\nif (scmd->cmd_len < 16) {\r\nfp = 15;\r\ngoto invalid_fld;\r\n}\r\nscsi_16_lba_len(cdb, &block, &n_block);\r\n} else {\r\nfp = 0;\r\ngoto invalid_fld;\r\n}\r\nif (!n_block)\r\ngoto nothing_to_do;\r\nif (block >= dev_sectors)\r\ngoto out_of_range;\r\nif ((block + n_block) > dev_sectors)\r\ngoto out_of_range;\r\nif (dev->flags & ATA_DFLAG_LBA) {\r\ntf->flags |= ATA_TFLAG_LBA;\r\nif (lba_28_ok(block, n_block)) {\r\ntf->command = ATA_CMD_VERIFY;\r\ntf->device |= (block >> 24) & 0xf;\r\n} else if (lba_48_ok(block, n_block)) {\r\nif (!(dev->flags & ATA_DFLAG_LBA48))\r\ngoto out_of_range;\r\ntf->flags |= ATA_TFLAG_LBA48;\r\ntf->command = ATA_CMD_VERIFY_EXT;\r\ntf->hob_nsect = (n_block >> 8) & 0xff;\r\ntf->hob_lbah = (block >> 40) & 0xff;\r\ntf->hob_lbam = (block >> 32) & 0xff;\r\ntf->hob_lbal = (block >> 24) & 0xff;\r\n} else\r\ngoto out_of_range;\r\ntf->nsect = n_block & 0xff;\r\ntf->lbah = (block >> 16) & 0xff;\r\ntf->lbam = (block >> 8) & 0xff;\r\ntf->lbal = block & 0xff;\r\ntf->device |= ATA_LBA;\r\n} else {\r\nu32 sect, head, cyl, track;\r\nif (!lba_28_ok(block, n_block))\r\ngoto out_of_range;\r\ntrack = (u32)block / dev->sectors;\r\ncyl = track / dev->heads;\r\nhead = track % dev->heads;\r\nsect = (u32)block % dev->sectors + 1;\r\nDPRINTK("block %u track %u cyl %u head %u sect %u\n",\r\n(u32)block, track, cyl, head, sect);\r\nif ((cyl >> 16) || (head >> 4) || (sect >> 8) || (!sect))\r\ngoto out_of_range;\r\ntf->command = ATA_CMD_VERIFY;\r\ntf->nsect = n_block & 0xff;\r\ntf->lbal = sect;\r\ntf->lbam = cyl;\r\ntf->lbah = cyl >> 8;\r\ntf->device |= head;\r\n}\r\nreturn 0;\r\ninvalid_fld:\r\nata_scsi_set_invalid_field(qc->dev, scmd, fp, 0xff);\r\nreturn 1;\r\nout_of_range:\r\nata_scsi_set_sense(qc->dev, scmd, ILLEGAL_REQUEST, 0x21, 0x0);\r\nreturn 1;\r\nnothing_to_do:\r\nscmd->result = SAM_STAT_GOOD;\r\nreturn 1;\r\n}\r\nstatic unsigned int ata_scsi_rw_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nconst u8 *cdb = scmd->cmnd;\r\nstruct request *rq = scmd->request;\r\nint class = IOPRIO_PRIO_CLASS(req_get_ioprio(rq));\r\nunsigned int tf_flags = 0;\r\nu64 block;\r\nu32 n_block;\r\nint rc;\r\nu16 fp = 0;\r\nif (cdb[0] == WRITE_10 || cdb[0] == WRITE_6 || cdb[0] == WRITE_16)\r\ntf_flags |= ATA_TFLAG_WRITE;\r\nswitch (cdb[0]) {\r\ncase READ_10:\r\ncase WRITE_10:\r\nif (unlikely(scmd->cmd_len < 10)) {\r\nfp = 9;\r\ngoto invalid_fld;\r\n}\r\nscsi_10_lba_len(cdb, &block, &n_block);\r\nif (cdb[1] & (1 << 3))\r\ntf_flags |= ATA_TFLAG_FUA;\r\nbreak;\r\ncase READ_6:\r\ncase WRITE_6:\r\nif (unlikely(scmd->cmd_len < 6)) {\r\nfp = 5;\r\ngoto invalid_fld;\r\n}\r\nscsi_6_lba_len(cdb, &block, &n_block);\r\nif (!n_block)\r\nn_block = 256;\r\nbreak;\r\ncase READ_16:\r\ncase WRITE_16:\r\nif (unlikely(scmd->cmd_len < 16)) {\r\nfp = 15;\r\ngoto invalid_fld;\r\n}\r\nscsi_16_lba_len(cdb, &block, &n_block);\r\nif (cdb[1] & (1 << 3))\r\ntf_flags |= ATA_TFLAG_FUA;\r\nbreak;\r\ndefault:\r\nDPRINTK("no-byte command\n");\r\nfp = 0;\r\ngoto invalid_fld;\r\n}\r\nif (!n_block)\r\ngoto nothing_to_do;\r\nqc->flags |= ATA_QCFLAG_IO;\r\nqc->nbytes = n_block * scmd->device->sector_size;\r\nrc = ata_build_rw_tf(&qc->tf, qc->dev, block, n_block, tf_flags,\r\nqc->tag, class);\r\nif (likely(rc == 0))\r\nreturn 0;\r\nif (rc == -ERANGE)\r\ngoto out_of_range;\r\ninvalid_fld:\r\nata_scsi_set_invalid_field(qc->dev, scmd, fp, 0xff);\r\nreturn 1;\r\nout_of_range:\r\nata_scsi_set_sense(qc->dev, scmd, ILLEGAL_REQUEST, 0x21, 0x0);\r\nreturn 1;\r\nnothing_to_do:\r\nscmd->result = SAM_STAT_GOOD;\r\nreturn 1;\r\n}\r\nstatic void ata_qc_done(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *cmd = qc->scsicmd;\r\nvoid (*done)(struct scsi_cmnd *) = qc->scsidone;\r\nata_qc_free(qc);\r\ndone(cmd);\r\n}\r\nstatic void ata_scsi_qc_complete(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct scsi_cmnd *cmd = qc->scsicmd;\r\nu8 *cdb = cmd->cmnd;\r\nint need_sense = (qc->err_mask != 0);\r\nif (((cdb[0] == ATA_16) || (cdb[0] == ATA_12)) &&\r\n((cdb[2] & 0x20) || need_sense))\r\nata_gen_passthru_sense(qc);\r\nelse if (qc->flags & ATA_QCFLAG_SENSE_VALID)\r\ncmd->result = SAM_STAT_CHECK_CONDITION;\r\nelse if (need_sense)\r\nata_gen_ata_sense(qc);\r\nelse\r\ncmd->result = SAM_STAT_GOOD;\r\nif (need_sense && !ap->ops->error_handler)\r\nata_dump_status(ap->print_id, &qc->result_tf);\r\nata_qc_done(qc);\r\n}\r\nstatic int ata_scsi_translate(struct ata_device *dev, struct scsi_cmnd *cmd,\r\nata_xlat_func_t xlat_func)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nstruct ata_queued_cmd *qc;\r\nint rc;\r\nVPRINTK("ENTER\n");\r\nqc = ata_scsi_qc_new(dev, cmd);\r\nif (!qc)\r\ngoto err_mem;\r\nif (cmd->sc_data_direction == DMA_FROM_DEVICE ||\r\ncmd->sc_data_direction == DMA_TO_DEVICE) {\r\nif (unlikely(scsi_bufflen(cmd) < 1)) {\r\nata_dev_warn(dev, "WARNING: zero len r/w req\n");\r\ngoto err_did;\r\n}\r\nata_sg_init(qc, scsi_sglist(cmd), scsi_sg_count(cmd));\r\nqc->dma_dir = cmd->sc_data_direction;\r\n}\r\nqc->complete_fn = ata_scsi_qc_complete;\r\nif (xlat_func(qc))\r\ngoto early_finish;\r\nif (ap->ops->qc_defer) {\r\nif ((rc = ap->ops->qc_defer(qc)))\r\ngoto defer;\r\n}\r\nata_qc_issue(qc);\r\nVPRINTK("EXIT\n");\r\nreturn 0;\r\nearly_finish:\r\nata_qc_free(qc);\r\ncmd->scsi_done(cmd);\r\nDPRINTK("EXIT - early finish (good or error)\n");\r\nreturn 0;\r\nerr_did:\r\nata_qc_free(qc);\r\ncmd->result = (DID_ERROR << 16);\r\ncmd->scsi_done(cmd);\r\nerr_mem:\r\nDPRINTK("EXIT - internal\n");\r\nreturn 0;\r\ndefer:\r\nata_qc_free(qc);\r\nDPRINTK("EXIT - defer\n");\r\nif (rc == ATA_DEFER_LINK)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\nelse\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nstatic void *ata_scsi_rbuf_get(struct scsi_cmnd *cmd, bool copy_in,\r\nunsigned long *flags)\r\n{\r\nspin_lock_irqsave(&ata_scsi_rbuf_lock, *flags);\r\nmemset(ata_scsi_rbuf, 0, ATA_SCSI_RBUF_SIZE);\r\nif (copy_in)\r\nsg_copy_to_buffer(scsi_sglist(cmd), scsi_sg_count(cmd),\r\nata_scsi_rbuf, ATA_SCSI_RBUF_SIZE);\r\nreturn ata_scsi_rbuf;\r\n}\r\nstatic inline void ata_scsi_rbuf_put(struct scsi_cmnd *cmd, bool copy_out,\r\nunsigned long *flags)\r\n{\r\nif (copy_out)\r\nsg_copy_from_buffer(scsi_sglist(cmd), scsi_sg_count(cmd),\r\nata_scsi_rbuf, ATA_SCSI_RBUF_SIZE);\r\nspin_unlock_irqrestore(&ata_scsi_rbuf_lock, *flags);\r\n}\r\nstatic unsigned int ata_scsiop_inq_std(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nconst u8 versions[] = {\r\n0x00,\r\n0x60,\r\n0x03,\r\n0x20,\r\n0x03,\r\n0x00\r\n};\r\nconst u8 versions_zbc[] = {\r\n0x00,\r\n0xA0,\r\n0x06,\r\n0x00,\r\n0x05,\r\n0xC0,\r\n0x60,\r\n0x24,\r\n};\r\nu8 hdr[] = {\r\nTYPE_DISK,\r\n0,\r\n0x5,\r\n2,\r\n95 - 4,\r\n0,\r\n0,\r\n2\r\n};\r\nVPRINTK("ENTER\n");\r\nif (ata_id_removable(args->id) ||\r\n(args->dev->link->ap->pflags & ATA_PFLAG_EXTERNAL))\r\nhdr[1] |= (1 << 7);\r\nif (args->dev->class == ATA_DEV_ZAC) {\r\nhdr[0] = TYPE_ZBC;\r\nhdr[2] = 0x7;\r\n}\r\nmemcpy(rbuf, hdr, sizeof(hdr));\r\nmemcpy(&rbuf[8], "ATA ", 8);\r\nata_id_string(args->id, &rbuf[16], ATA_ID_PROD, 16);\r\nata_id_string(args->id, &rbuf[32], ATA_ID_FW_REV + 2, 4);\r\nif (strncmp(&rbuf[32], " ", 4) == 0)\r\nata_id_string(args->id, &rbuf[32], ATA_ID_FW_REV, 4);\r\nif (rbuf[32] == 0 || rbuf[32] == ' ')\r\nmemcpy(&rbuf[32], "n/a ", 4);\r\nif (ata_id_zoned_cap(args->id) || args->dev->class == ATA_DEV_ZAC)\r\nmemcpy(rbuf + 58, versions_zbc, sizeof(versions_zbc));\r\nelse\r\nmemcpy(rbuf + 58, versions, sizeof(versions));\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_inq_00(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nint num_pages;\r\nconst u8 pages[] = {\r\n0x00,\r\n0x80,\r\n0x83,\r\n0x89,\r\n0xb0,\r\n0xb1,\r\n0xb2,\r\n0xb6,\r\n};\r\nnum_pages = sizeof(pages);\r\nif (!(args->dev->flags & ATA_DFLAG_ZAC))\r\nnum_pages--;\r\nrbuf[3] = num_pages;\r\nmemcpy(rbuf + 4, pages, num_pages);\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_inq_80(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nconst u8 hdr[] = {\r\n0,\r\n0x80,\r\n0,\r\nATA_ID_SERNO_LEN,\r\n};\r\nmemcpy(rbuf, hdr, sizeof(hdr));\r\nata_id_string(args->id, (unsigned char *) &rbuf[4],\r\nATA_ID_SERNO, ATA_ID_SERNO_LEN);\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_inq_83(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nconst int sat_model_serial_desc_len = 68;\r\nint num;\r\nrbuf[1] = 0x83;\r\nnum = 4;\r\nrbuf[num + 0] = 2;\r\nrbuf[num + 3] = ATA_ID_SERNO_LEN;\r\nnum += 4;\r\nata_id_string(args->id, (unsigned char *) rbuf + num,\r\nATA_ID_SERNO, ATA_ID_SERNO_LEN);\r\nnum += ATA_ID_SERNO_LEN;\r\nrbuf[num + 0] = 2;\r\nrbuf[num + 1] = 1;\r\nrbuf[num + 3] = sat_model_serial_desc_len;\r\nnum += 4;\r\nmemcpy(rbuf + num, "ATA ", 8);\r\nnum += 8;\r\nata_id_string(args->id, (unsigned char *) rbuf + num, ATA_ID_PROD,\r\nATA_ID_PROD_LEN);\r\nnum += ATA_ID_PROD_LEN;\r\nata_id_string(args->id, (unsigned char *) rbuf + num, ATA_ID_SERNO,\r\nATA_ID_SERNO_LEN);\r\nnum += ATA_ID_SERNO_LEN;\r\nif (ata_id_has_wwn(args->id)) {\r\nrbuf[num + 0] = 1;\r\nrbuf[num + 1] = 3;\r\nrbuf[num + 3] = ATA_ID_WWN_LEN;\r\nnum += 4;\r\nata_id_string(args->id, (unsigned char *) rbuf + num,\r\nATA_ID_WWN, ATA_ID_WWN_LEN);\r\nnum += ATA_ID_WWN_LEN;\r\n}\r\nrbuf[3] = num - 4;\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_inq_89(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nstruct ata_taskfile tf;\r\nmemset(&tf, 0, sizeof(tf));\r\nrbuf[1] = 0x89;\r\nrbuf[2] = (0x238 >> 8);\r\nrbuf[3] = (0x238 & 0xff);\r\nmemcpy(&rbuf[8], "linux ", 8);\r\nmemcpy(&rbuf[16], "libata ", 16);\r\nmemcpy(&rbuf[32], DRV_VERSION, 4);\r\ntf.command = ATA_DRDY;\r\ntf.lbal = 0x1;\r\ntf.nsect = 0x1;\r\nata_tf_to_fis(&tf, 0, 1, &rbuf[36]);\r\nrbuf[36] = 0x34;\r\nrbuf[56] = ATA_CMD_ID_ATA;\r\nmemcpy(&rbuf[60], &args->id[0], 512);\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_inq_b0(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nu16 min_io_sectors;\r\nrbuf[1] = 0xb0;\r\nrbuf[3] = 0x3c;\r\nmin_io_sectors = 1 << ata_id_log2_per_physical_sector(args->id);\r\nput_unaligned_be16(min_io_sectors, &rbuf[6]);\r\nif (ata_id_has_trim(args->id)) {\r\nput_unaligned_be64(65535 * ATA_MAX_TRIM_RNUM, &rbuf[36]);\r\nput_unaligned_be32(1, &rbuf[28]);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_inq_b1(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nint form_factor = ata_id_form_factor(args->id);\r\nint media_rotation_rate = ata_id_rotation_rate(args->id);\r\nu8 zoned = ata_id_zoned_cap(args->id);\r\nrbuf[1] = 0xb1;\r\nrbuf[3] = 0x3c;\r\nrbuf[4] = media_rotation_rate >> 8;\r\nrbuf[5] = media_rotation_rate;\r\nrbuf[7] = form_factor;\r\nif (zoned)\r\nrbuf[8] = (zoned << 4);\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_inq_b2(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nrbuf[1] = 0xb2;\r\nrbuf[3] = 0x4;\r\nrbuf[5] = 1 << 6;\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_inq_b6(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nrbuf[1] = 0xb6;\r\nrbuf[3] = 0x3C;\r\nif (args->dev->zac_zoned_cap & 1)\r\nrbuf[4] |= 1;\r\nput_unaligned_be32(args->dev->zac_zones_optimal_open, &rbuf[8]);\r\nput_unaligned_be32(args->dev->zac_zones_optimal_nonseq, &rbuf[12]);\r\nput_unaligned_be32(args->dev->zac_zones_max_open, &rbuf[16]);\r\nreturn 0;\r\n}\r\nstatic void modecpy(u8 *dest, const u8 *src, int n, bool changeable)\r\n{\r\nif (changeable) {\r\nmemcpy(dest, src, 2);\r\nmemset(dest + 2, 0, n - 2);\r\n} else {\r\nmemcpy(dest, src, n);\r\n}\r\n}\r\nstatic unsigned int ata_msense_caching(u16 *id, u8 *buf, bool changeable)\r\n{\r\nmodecpy(buf, def_cache_mpage, sizeof(def_cache_mpage), changeable);\r\nif (changeable) {\r\nbuf[2] |= (1 << 2);\r\n} else {\r\nbuf[2] |= (ata_id_wcache_enabled(id) << 2);\r\nbuf[12] |= (!ata_id_rahead_enabled(id) << 5);\r\n}\r\nreturn sizeof(def_cache_mpage);\r\n}\r\nstatic unsigned int ata_msense_control(struct ata_device *dev, u8 *buf,\r\nbool changeable)\r\n{\r\nmodecpy(buf, def_control_mpage, sizeof(def_control_mpage), changeable);\r\nif (changeable) {\r\nbuf[2] |= (1 << 2);\r\n} else {\r\nbool d_sense = (dev->flags & ATA_DFLAG_D_SENSE);\r\nbuf[2] |= (d_sense << 2);\r\n}\r\nreturn sizeof(def_control_mpage);\r\n}\r\nstatic unsigned int ata_msense_rw_recovery(u8 *buf, bool changeable)\r\n{\r\nmodecpy(buf, def_rw_recovery_mpage, sizeof(def_rw_recovery_mpage),\r\nchangeable);\r\nreturn sizeof(def_rw_recovery_mpage);\r\n}\r\nstatic int ata_dev_supports_fua(u16 *id)\r\n{\r\nunsigned char model[ATA_ID_PROD_LEN + 1], fw[ATA_ID_FW_REV_LEN + 1];\r\nif (!libata_fua)\r\nreturn 0;\r\nif (!ata_id_has_fua(id))\r\nreturn 0;\r\nata_id_c_string(id, model, ATA_ID_PROD, sizeof(model));\r\nata_id_c_string(id, fw, ATA_ID_FW_REV, sizeof(fw));\r\nif (strcmp(model, "Maxtor"))\r\nreturn 1;\r\nif (strcmp(fw, "BANC1G10"))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_mode_sense(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nstruct ata_device *dev = args->dev;\r\nu8 *scsicmd = args->cmd->cmnd, *p = rbuf;\r\nconst u8 sat_blk_desc[] = {\r\n0, 0, 0, 0,\r\n0,\r\n0, 0x2, 0x0\r\n};\r\nu8 pg, spg;\r\nunsigned int ebd, page_control, six_byte;\r\nu8 dpofua, bp = 0xff;\r\nu16 fp;\r\nVPRINTK("ENTER\n");\r\nsix_byte = (scsicmd[0] == MODE_SENSE);\r\nebd = !(scsicmd[1] & 0x8);\r\npage_control = scsicmd[2] >> 6;\r\nswitch (page_control) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\nbreak;\r\ncase 3:\r\ngoto saving_not_supp;\r\ndefault:\r\nfp = 2;\r\nbp = 6;\r\ngoto invalid_fld;\r\n}\r\nif (six_byte)\r\np += 4 + (ebd ? 8 : 0);\r\nelse\r\np += 8 + (ebd ? 8 : 0);\r\npg = scsicmd[2] & 0x3f;\r\nspg = scsicmd[3];\r\nif (spg && (spg != ALL_SUB_MPAGES)) {\r\nfp = 3;\r\ngoto invalid_fld;\r\n}\r\nswitch(pg) {\r\ncase RW_RECOVERY_MPAGE:\r\np += ata_msense_rw_recovery(p, page_control == 1);\r\nbreak;\r\ncase CACHE_MPAGE:\r\np += ata_msense_caching(args->id, p, page_control == 1);\r\nbreak;\r\ncase CONTROL_MPAGE:\r\np += ata_msense_control(args->dev, p, page_control == 1);\r\nbreak;\r\ncase ALL_MPAGES:\r\np += ata_msense_rw_recovery(p, page_control == 1);\r\np += ata_msense_caching(args->id, p, page_control == 1);\r\np += ata_msense_control(args->dev, p, page_control == 1);\r\nbreak;\r\ndefault:\r\nfp = 2;\r\ngoto invalid_fld;\r\n}\r\ndpofua = 0;\r\nif (ata_dev_supports_fua(args->id) && (dev->flags & ATA_DFLAG_LBA48) &&\r\n(!(dev->flags & ATA_DFLAG_PIO) || dev->multi_count))\r\ndpofua = 1 << 4;\r\nif (six_byte) {\r\nrbuf[0] = p - rbuf - 1;\r\nrbuf[2] |= dpofua;\r\nif (ebd) {\r\nrbuf[3] = sizeof(sat_blk_desc);\r\nmemcpy(rbuf + 4, sat_blk_desc, sizeof(sat_blk_desc));\r\n}\r\n} else {\r\nunsigned int output_len = p - rbuf - 2;\r\nrbuf[0] = output_len >> 8;\r\nrbuf[1] = output_len;\r\nrbuf[3] |= dpofua;\r\nif (ebd) {\r\nrbuf[7] = sizeof(sat_blk_desc);\r\nmemcpy(rbuf + 8, sat_blk_desc, sizeof(sat_blk_desc));\r\n}\r\n}\r\nreturn 0;\r\ninvalid_fld:\r\nata_scsi_set_invalid_field(dev, args->cmd, fp, bp);\r\nreturn 1;\r\nsaving_not_supp:\r\nata_scsi_set_sense(dev, args->cmd, ILLEGAL_REQUEST, 0x39, 0x0);\r\nreturn 1;\r\n}\r\nstatic unsigned int ata_scsiop_read_cap(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nstruct ata_device *dev = args->dev;\r\nu64 last_lba = dev->n_sectors - 1;\r\nu32 sector_size;\r\nu8 log2_per_phys;\r\nu16 lowest_aligned;\r\nsector_size = ata_id_logical_sector_size(dev->id);\r\nlog2_per_phys = ata_id_log2_per_physical_sector(dev->id);\r\nlowest_aligned = ata_id_logical_sector_offset(dev->id, log2_per_phys);\r\nVPRINTK("ENTER\n");\r\nif (args->cmd->cmnd[0] == READ_CAPACITY) {\r\nif (last_lba >= 0xffffffffULL)\r\nlast_lba = 0xffffffff;\r\nrbuf[0] = last_lba >> (8 * 3);\r\nrbuf[1] = last_lba >> (8 * 2);\r\nrbuf[2] = last_lba >> (8 * 1);\r\nrbuf[3] = last_lba;\r\nrbuf[4] = sector_size >> (8 * 3);\r\nrbuf[5] = sector_size >> (8 * 2);\r\nrbuf[6] = sector_size >> (8 * 1);\r\nrbuf[7] = sector_size;\r\n} else {\r\nrbuf[0] = last_lba >> (8 * 7);\r\nrbuf[1] = last_lba >> (8 * 6);\r\nrbuf[2] = last_lba >> (8 * 5);\r\nrbuf[3] = last_lba >> (8 * 4);\r\nrbuf[4] = last_lba >> (8 * 3);\r\nrbuf[5] = last_lba >> (8 * 2);\r\nrbuf[6] = last_lba >> (8 * 1);\r\nrbuf[7] = last_lba;\r\nrbuf[ 8] = sector_size >> (8 * 3);\r\nrbuf[ 9] = sector_size >> (8 * 2);\r\nrbuf[10] = sector_size >> (8 * 1);\r\nrbuf[11] = sector_size;\r\nrbuf[12] = 0;\r\nrbuf[13] = log2_per_phys;\r\nrbuf[14] = (lowest_aligned >> 8) & 0x3f;\r\nrbuf[15] = lowest_aligned;\r\nif (ata_id_has_trim(args->id) &&\r\n!(dev->horkage & ATA_HORKAGE_NOTRIM)) {\r\nrbuf[14] |= 0x80;\r\nif (ata_id_has_zero_after_trim(args->id) &&\r\ndev->horkage & ATA_HORKAGE_ZERO_AFTER_TRIM) {\r\nata_dev_info(dev, "Enabling discard_zeroes_data\n");\r\nrbuf[14] |= 0x40;\r\n}\r\n}\r\nif (ata_id_zoned_cap(args->id) ||\r\nargs->dev->class == ATA_DEV_ZAC)\r\nrbuf[12] = (1 << 4);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_report_luns(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nVPRINTK("ENTER\n");\r\nrbuf[3] = 8;\r\nreturn 0;\r\n}\r\nstatic void atapi_sense_complete(struct ata_queued_cmd *qc)\r\n{\r\nif (qc->err_mask && ((qc->err_mask & AC_ERR_DEV) == 0)) {\r\nata_gen_passthru_sense(qc);\r\n}\r\nata_qc_done(qc);\r\n}\r\nstatic inline int ata_pio_use_silly(struct ata_port *ap)\r\n{\r\nreturn (ap->flags & ATA_FLAG_PIO_DMA);\r\n}\r\nstatic void atapi_request_sense(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct scsi_cmnd *cmd = qc->scsicmd;\r\nDPRINTK("ATAPI request sense\n");\r\nmemset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\r\n#ifdef CONFIG_ATA_SFF\r\nif (ap->ops->sff_tf_read)\r\nap->ops->sff_tf_read(ap, &qc->tf);\r\n#endif\r\ncmd->sense_buffer[0] = 0x70;\r\ncmd->sense_buffer[2] = qc->tf.feature >> 4;\r\nata_qc_reinit(qc);\r\nsg_init_one(&qc->sgent, cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE);\r\nata_sg_init(qc, &qc->sgent, 1);\r\nqc->dma_dir = DMA_FROM_DEVICE;\r\nmemset(&qc->cdb, 0, qc->dev->cdb_len);\r\nqc->cdb[0] = REQUEST_SENSE;\r\nqc->cdb[4] = SCSI_SENSE_BUFFERSIZE;\r\nqc->tf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\r\nqc->tf.command = ATA_CMD_PACKET;\r\nif (ata_pio_use_silly(ap)) {\r\nqc->tf.protocol = ATAPI_PROT_DMA;\r\nqc->tf.feature |= ATAPI_PKT_DMA;\r\n} else {\r\nqc->tf.protocol = ATAPI_PROT_PIO;\r\nqc->tf.lbam = SCSI_SENSE_BUFFERSIZE;\r\nqc->tf.lbah = 0;\r\n}\r\nqc->nbytes = SCSI_SENSE_BUFFERSIZE;\r\nqc->complete_fn = atapi_sense_complete;\r\nata_qc_issue(qc);\r\nDPRINTK("EXIT\n");\r\n}\r\nstatic void atapi_fixup_inquiry(struct scsi_cmnd *cmd)\r\n{\r\nu8 buf[4];\r\nsg_copy_to_buffer(scsi_sglist(cmd), scsi_sg_count(cmd), buf, 4);\r\nif (buf[2] == 0) {\r\nbuf[2] = 0x5;\r\nbuf[3] = 0x32;\r\n}\r\nsg_copy_from_buffer(scsi_sglist(cmd), scsi_sg_count(cmd), buf, 4);\r\n}\r\nstatic void atapi_qc_complete(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *cmd = qc->scsicmd;\r\nunsigned int err_mask = qc->err_mask;\r\nVPRINTK("ENTER, err_mask 0x%X\n", err_mask);\r\nif (unlikely(qc->ap->ops->error_handler &&\r\n(err_mask || qc->flags & ATA_QCFLAG_SENSE_VALID))) {\r\nif (!(qc->flags & ATA_QCFLAG_SENSE_VALID)) {\r\nata_gen_passthru_sense(qc);\r\n}\r\nif (qc->cdb[0] == ALLOW_MEDIUM_REMOVAL && qc->dev->sdev)\r\nqc->dev->sdev->locked = 0;\r\nqc->scsicmd->result = SAM_STAT_CHECK_CONDITION;\r\nata_qc_done(qc);\r\nreturn;\r\n}\r\nif (unlikely(err_mask & AC_ERR_DEV)) {\r\ncmd->result = SAM_STAT_CHECK_CONDITION;\r\natapi_request_sense(qc);\r\nreturn;\r\n} else if (unlikely(err_mask)) {\r\nata_gen_passthru_sense(qc);\r\n} else {\r\nif (cmd->cmnd[0] == INQUIRY && (cmd->cmnd[1] & 0x03) == 0)\r\natapi_fixup_inquiry(cmd);\r\ncmd->result = SAM_STAT_GOOD;\r\n}\r\nata_qc_done(qc);\r\n}\r\nstatic unsigned int atapi_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nstruct ata_device *dev = qc->dev;\r\nint nodata = (scmd->sc_data_direction == DMA_NONE);\r\nint using_pio = !nodata && (dev->flags & ATA_DFLAG_PIO);\r\nunsigned int nbytes;\r\nmemset(qc->cdb, 0, dev->cdb_len);\r\nmemcpy(qc->cdb, scmd->cmnd, scmd->cmd_len);\r\nqc->complete_fn = atapi_qc_complete;\r\nqc->tf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\r\nif (scmd->sc_data_direction == DMA_TO_DEVICE) {\r\nqc->tf.flags |= ATA_TFLAG_WRITE;\r\nDPRINTK("direction: write\n");\r\n}\r\nqc->tf.command = ATA_CMD_PACKET;\r\nata_qc_set_pc_nbytes(qc);\r\nif (!nodata && !using_pio && atapi_check_dma(qc))\r\nusing_pio = 1;\r\nnbytes = min(ata_qc_raw_nbytes(qc), (unsigned int)63 * 1024);\r\nif (nbytes & 0x1)\r\nnbytes++;\r\nqc->tf.lbam = (nbytes & 0xFF);\r\nqc->tf.lbah = (nbytes >> 8);\r\nif (nodata)\r\nqc->tf.protocol = ATAPI_PROT_NODATA;\r\nelse if (using_pio)\r\nqc->tf.protocol = ATAPI_PROT_PIO;\r\nelse {\r\nqc->tf.protocol = ATAPI_PROT_DMA;\r\nqc->tf.feature |= ATAPI_PKT_DMA;\r\nif ((dev->flags & ATA_DFLAG_DMADIR) &&\r\n(scmd->sc_data_direction != DMA_TO_DEVICE))\r\nqc->tf.feature |= ATAPI_DMADIR;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct ata_device *ata_find_dev(struct ata_port *ap, int devno)\r\n{\r\nif (!sata_pmp_attached(ap)) {\r\nif (likely(devno >= 0 &&\r\ndevno < ata_link_max_devices(&ap->link)))\r\nreturn &ap->link.device[devno];\r\n} else {\r\nif (likely(devno >= 0 &&\r\ndevno < ap->nr_pmp_links))\r\nreturn &ap->pmp_link[devno].device[0];\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ata_device *__ata_scsi_find_dev(struct ata_port *ap,\r\nconst struct scsi_device *scsidev)\r\n{\r\nint devno;\r\nif (!sata_pmp_attached(ap)) {\r\nif (unlikely(scsidev->channel || scsidev->lun))\r\nreturn NULL;\r\ndevno = scsidev->id;\r\n} else {\r\nif (unlikely(scsidev->id || scsidev->lun))\r\nreturn NULL;\r\ndevno = scsidev->channel;\r\n}\r\nreturn ata_find_dev(ap, devno);\r\n}\r\nstatic struct ata_device *\r\nata_scsi_find_dev(struct ata_port *ap, const struct scsi_device *scsidev)\r\n{\r\nstruct ata_device *dev = __ata_scsi_find_dev(ap, scsidev);\r\nif (unlikely(!dev || !ata_dev_enabled(dev)))\r\nreturn NULL;\r\nreturn dev;\r\n}\r\nstatic u8\r\nata_scsi_map_proto(u8 byte1)\r\n{\r\nswitch((byte1 & 0x1e) >> 1) {\r\ncase 3:\r\nreturn ATA_PROT_NODATA;\r\ncase 6:\r\ncase 10:\r\ncase 11:\r\nreturn ATA_PROT_DMA;\r\ncase 4:\r\ncase 5:\r\nreturn ATA_PROT_PIO;\r\ncase 12:\r\nreturn ATA_PROT_NCQ;\r\ncase 0:\r\ncase 1:\r\ncase 8:\r\ncase 9:\r\ncase 7:\r\ncase 15:\r\ndefault:\r\nbreak;\r\n}\r\nreturn ATA_PROT_UNKNOWN;\r\n}\r\nstatic unsigned int ata_scsi_pass_thru(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_taskfile *tf = &(qc->tf);\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nstruct ata_device *dev = qc->dev;\r\nconst u8 *cdb = scmd->cmnd;\r\nu16 fp;\r\nu16 cdb_offset = 0;\r\nif (cdb[0] == VARIABLE_LENGTH_CMD)\r\ncdb_offset = 9;\r\ntf->protocol = ata_scsi_map_proto(cdb[1 + cdb_offset]);\r\nif (tf->protocol == ATA_PROT_UNKNOWN) {\r\nfp = 1;\r\ngoto invalid_fld;\r\n}\r\nif (ata_is_ncq(tf->protocol) && (cdb[2 + cdb_offset] & 0x3) == 0)\r\ntf->protocol = ATA_PROT_NCQ_NODATA;\r\ntf->flags |= ATA_TFLAG_LBA;\r\nif (cdb[0] == ATA_16) {\r\nif (cdb[1] & 0x01) {\r\ntf->hob_feature = cdb[3];\r\ntf->hob_nsect = cdb[5];\r\ntf->hob_lbal = cdb[7];\r\ntf->hob_lbam = cdb[9];\r\ntf->hob_lbah = cdb[11];\r\ntf->flags |= ATA_TFLAG_LBA48;\r\n} else\r\ntf->flags &= ~ATA_TFLAG_LBA48;\r\ntf->feature = cdb[4];\r\ntf->nsect = cdb[6];\r\ntf->lbal = cdb[8];\r\ntf->lbam = cdb[10];\r\ntf->lbah = cdb[12];\r\ntf->device = cdb[13];\r\ntf->command = cdb[14];\r\n} else if (cdb[0] == ATA_12) {\r\ntf->flags &= ~ATA_TFLAG_LBA48;\r\ntf->feature = cdb[3];\r\ntf->nsect = cdb[4];\r\ntf->lbal = cdb[5];\r\ntf->lbam = cdb[6];\r\ntf->lbah = cdb[7];\r\ntf->device = cdb[8];\r\ntf->command = cdb[9];\r\n} else {\r\nif (cdb[10] & 0x01) {\r\ntf->hob_feature = cdb[20];\r\ntf->hob_nsect = cdb[22];\r\ntf->hob_lbal = cdb[16];\r\ntf->hob_lbam = cdb[15];\r\ntf->hob_lbah = cdb[14];\r\ntf->flags |= ATA_TFLAG_LBA48;\r\n} else\r\ntf->flags &= ~ATA_TFLAG_LBA48;\r\ntf->feature = cdb[21];\r\ntf->nsect = cdb[23];\r\ntf->lbal = cdb[19];\r\ntf->lbam = cdb[18];\r\ntf->lbah = cdb[17];\r\ntf->device = cdb[24];\r\ntf->command = cdb[25];\r\ntf->auxiliary = get_unaligned_be32(&cdb[28]);\r\n}\r\nif (ata_is_ncq(tf->protocol))\r\ntf->nsect = qc->tag << 3;\r\ntf->device = dev->devno ?\r\ntf->device | ATA_DEV1 : tf->device & ~ATA_DEV1;\r\nswitch (tf->command) {\r\ncase ATA_CMD_READ_LONG:\r\ncase ATA_CMD_READ_LONG_ONCE:\r\ncase ATA_CMD_WRITE_LONG:\r\ncase ATA_CMD_WRITE_LONG_ONCE:\r\nif (tf->protocol != ATA_PROT_PIO || tf->nsect != 1) {\r\nfp = 1;\r\ngoto invalid_fld;\r\n}\r\nqc->sect_size = scsi_bufflen(scmd);\r\nbreak;\r\ncase ATA_CMD_CFA_WRITE_NE:\r\ncase ATA_CMD_CFA_TRANS_SECT:\r\ncase ATA_CMD_CFA_WRITE_MULT_NE:\r\ncase ATA_CMD_READ:\r\ncase ATA_CMD_READ_EXT:\r\ncase ATA_CMD_READ_QUEUED:\r\ncase ATA_CMD_FPDMA_READ:\r\ncase ATA_CMD_READ_MULTI:\r\ncase ATA_CMD_READ_MULTI_EXT:\r\ncase ATA_CMD_PIO_READ:\r\ncase ATA_CMD_PIO_READ_EXT:\r\ncase ATA_CMD_READ_STREAM_DMA_EXT:\r\ncase ATA_CMD_READ_STREAM_EXT:\r\ncase ATA_CMD_VERIFY:\r\ncase ATA_CMD_VERIFY_EXT:\r\ncase ATA_CMD_WRITE:\r\ncase ATA_CMD_WRITE_EXT:\r\ncase ATA_CMD_WRITE_FUA_EXT:\r\ncase ATA_CMD_WRITE_QUEUED:\r\ncase ATA_CMD_WRITE_QUEUED_FUA_EXT:\r\ncase ATA_CMD_FPDMA_WRITE:\r\ncase ATA_CMD_WRITE_MULTI:\r\ncase ATA_CMD_WRITE_MULTI_EXT:\r\ncase ATA_CMD_WRITE_MULTI_FUA_EXT:\r\ncase ATA_CMD_PIO_WRITE:\r\ncase ATA_CMD_PIO_WRITE_EXT:\r\ncase ATA_CMD_WRITE_STREAM_DMA_EXT:\r\ncase ATA_CMD_WRITE_STREAM_EXT:\r\nqc->sect_size = scmd->device->sector_size;\r\nbreak;\r\ndefault:\r\nqc->sect_size = ATA_SECT_SIZE;\r\n}\r\ntf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\r\nif (scmd->sc_data_direction == DMA_TO_DEVICE)\r\ntf->flags |= ATA_TFLAG_WRITE;\r\nqc->flags |= ATA_QCFLAG_RESULT_TF | ATA_QCFLAG_QUIET;\r\nata_qc_set_pc_nbytes(qc);\r\nif (tf->protocol == ATA_PROT_DMA && dev->dma_mode == 0) {\r\nfp = 1;\r\ngoto invalid_fld;\r\n}\r\nif ((cdb[1] & 0xe0) && !is_multi_taskfile(tf)) {\r\nfp = 1;\r\ngoto invalid_fld;\r\n}\r\nif (is_multi_taskfile(tf)) {\r\nunsigned int multi_count = 1 << (cdb[1] >> 5);\r\nif (multi_count != dev->multi_count)\r\nata_dev_warn(dev, "invalid multi_count %u ignored\n",\r\nmulti_count);\r\n}\r\nif (tf->command == ATA_CMD_SET_FEATURES &&\r\ntf->feature == SETFEATURES_XFER) {\r\nfp = (cdb[0] == ATA_16) ? 4 : 3;\r\ngoto invalid_fld;\r\n}\r\nif (tf->command >= 0x5C && tf->command <= 0x5F && !libata_allow_tpm) {\r\nfp = (cdb[0] == ATA_16) ? 14 : 9;\r\ngoto invalid_fld;\r\n}\r\nreturn 0;\r\ninvalid_fld:\r\nata_scsi_set_invalid_field(dev, scmd, fp, 0xff);\r\nreturn 1;\r\n}\r\nstatic size_t ata_format_dsm_trim_descr(struct scsi_cmnd *cmd, u32 trmax,\r\nu64 sector, u32 count)\r\n{\r\nstruct scsi_device *sdp = cmd->device;\r\nsize_t len = sdp->sector_size;\r\nsize_t r;\r\n__le64 *buf;\r\nu32 i = 0;\r\nunsigned long flags;\r\nWARN_ON(len > ATA_SCSI_RBUF_SIZE);\r\nif (len > ATA_SCSI_RBUF_SIZE)\r\nlen = ATA_SCSI_RBUF_SIZE;\r\nspin_lock_irqsave(&ata_scsi_rbuf_lock, flags);\r\nbuf = ((void *)ata_scsi_rbuf);\r\nmemset(buf, 0, len);\r\nwhile (i < trmax) {\r\nu64 entry = sector |\r\n((u64)(count > 0xffff ? 0xffff : count) << 48);\r\nbuf[i++] = __cpu_to_le64(entry);\r\nif (count <= 0xffff)\r\nbreak;\r\ncount -= 0xffff;\r\nsector += 0xffff;\r\n}\r\nr = sg_copy_from_buffer(scsi_sglist(cmd), scsi_sg_count(cmd), buf, len);\r\nspin_unlock_irqrestore(&ata_scsi_rbuf_lock, flags);\r\nreturn r;\r\n}\r\nstatic unsigned int ata_scsi_write_same_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_taskfile *tf = &qc->tf;\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nstruct scsi_device *sdp = scmd->device;\r\nsize_t len = sdp->sector_size;\r\nstruct ata_device *dev = qc->dev;\r\nconst u8 *cdb = scmd->cmnd;\r\nu64 block;\r\nu32 n_block;\r\nconst u32 trmax = len >> 3;\r\nu32 size;\r\nu16 fp;\r\nu8 bp = 0xff;\r\nu8 unmap = cdb[1] & 0x8;\r\nif (unlikely(!dev->dma_mode))\r\ngoto invalid_opcode;\r\nif (unlikely(blk_rq_is_passthrough(scmd->request)))\r\ngoto invalid_opcode;\r\nif (unlikely(scmd->cmd_len < 16)) {\r\nfp = 15;\r\ngoto invalid_fld;\r\n}\r\nscsi_16_lba_len(cdb, &block, &n_block);\r\nif (!unmap ||\r\n(dev->horkage & ATA_HORKAGE_NOTRIM) ||\r\n!ata_id_has_trim(dev->id)) {\r\nfp = 1;\r\nbp = 3;\r\ngoto invalid_fld;\r\n}\r\nif (n_block > 0xffff * trmax) {\r\nfp = 2;\r\ngoto invalid_fld;\r\n}\r\nif (!scsi_sg_count(scmd))\r\ngoto invalid_param_len;\r\nsize = ata_format_dsm_trim_descr(scmd, trmax, block, n_block);\r\nif (size != len)\r\ngoto invalid_param_len;\r\nif (ata_ncq_enabled(dev) && ata_fpdma_dsm_supported(dev)) {\r\ntf->protocol = ATA_PROT_NCQ;\r\ntf->command = ATA_CMD_FPDMA_SEND;\r\ntf->hob_nsect = ATA_SUBCMD_FPDMA_SEND_DSM & 0x1f;\r\ntf->nsect = qc->tag << 3;\r\ntf->hob_feature = (size / 512) >> 8;\r\ntf->feature = size / 512;\r\ntf->auxiliary = 1;\r\n} else {\r\ntf->protocol = ATA_PROT_DMA;\r\ntf->hob_feature = 0;\r\ntf->feature = ATA_DSM_TRIM;\r\ntf->hob_nsect = (size / 512) >> 8;\r\ntf->nsect = size / 512;\r\ntf->command = ATA_CMD_DSM;\r\n}\r\ntf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE | ATA_TFLAG_LBA48 |\r\nATA_TFLAG_WRITE;\r\nata_qc_set_pc_nbytes(qc);\r\nreturn 0;\r\ninvalid_fld:\r\nata_scsi_set_invalid_field(dev, scmd, fp, bp);\r\nreturn 1;\r\ninvalid_param_len:\r\nata_scsi_set_sense(dev, scmd, ILLEGAL_REQUEST, 0x1a, 0x0);\r\nreturn 1;\r\ninvalid_opcode:\r\nata_scsi_set_sense(dev, scmd, ILLEGAL_REQUEST, 0x20, 0x0);\r\nreturn 1;\r\n}\r\nstatic unsigned int ata_scsiop_maint_in(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nstruct ata_device *dev = args->dev;\r\nu8 *cdb = args->cmd->cmnd;\r\nu8 supported = 0;\r\nunsigned int err = 0;\r\nif (cdb[2] != 1) {\r\nata_dev_warn(dev, "invalid command format %d\n", cdb[2]);\r\nerr = 2;\r\ngoto out;\r\n}\r\nswitch (cdb[3]) {\r\ncase INQUIRY:\r\ncase MODE_SENSE:\r\ncase MODE_SENSE_10:\r\ncase READ_CAPACITY:\r\ncase SERVICE_ACTION_IN_16:\r\ncase REPORT_LUNS:\r\ncase REQUEST_SENSE:\r\ncase SYNCHRONIZE_CACHE:\r\ncase REZERO_UNIT:\r\ncase SEEK_6:\r\ncase SEEK_10:\r\ncase TEST_UNIT_READY:\r\ncase SEND_DIAGNOSTIC:\r\ncase MAINTENANCE_IN:\r\ncase READ_6:\r\ncase READ_10:\r\ncase READ_16:\r\ncase WRITE_6:\r\ncase WRITE_10:\r\ncase WRITE_16:\r\ncase ATA_12:\r\ncase ATA_16:\r\ncase VERIFY:\r\ncase VERIFY_16:\r\ncase MODE_SELECT:\r\ncase MODE_SELECT_10:\r\ncase START_STOP:\r\nsupported = 3;\r\nbreak;\r\ncase ZBC_IN:\r\ncase ZBC_OUT:\r\nif (ata_id_zoned_cap(dev->id) ||\r\ndev->class == ATA_DEV_ZAC)\r\nsupported = 3;\r\nbreak;\r\ncase SECURITY_PROTOCOL_IN:\r\ncase SECURITY_PROTOCOL_OUT:\r\nif (dev->flags & ATA_DFLAG_TRUSTED)\r\nsupported = 3;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nrbuf[1] = supported;\r\nreturn err;\r\n}\r\nstatic void ata_scsi_report_zones_complete(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nstruct sg_mapping_iter miter;\r\nunsigned long flags;\r\nunsigned int bytes = 0;\r\nsg_miter_start(&miter, scsi_sglist(scmd), scsi_sg_count(scmd),\r\nSG_MITER_TO_SG | SG_MITER_ATOMIC);\r\nlocal_irq_save(flags);\r\nwhile (sg_miter_next(&miter)) {\r\nunsigned int offset = 0;\r\nif (bytes == 0) {\r\nchar *hdr;\r\nu32 list_length;\r\nu64 max_lba, opt_lba;\r\nu16 same;\r\nhdr = miter.addr;\r\nlist_length = get_unaligned_le32(&hdr[0]);\r\nsame = get_unaligned_le16(&hdr[4]);\r\nmax_lba = get_unaligned_le64(&hdr[8]);\r\nopt_lba = get_unaligned_le64(&hdr[16]);\r\nput_unaligned_be32(list_length, &hdr[0]);\r\nhdr[4] = same & 0xf;\r\nput_unaligned_be64(max_lba, &hdr[8]);\r\nput_unaligned_be64(opt_lba, &hdr[16]);\r\noffset += 64;\r\nbytes += 64;\r\n}\r\nwhile (offset < miter.length) {\r\nchar *rec;\r\nu8 cond, type, non_seq, reset;\r\nu64 size, start, wp;\r\nrec = miter.addr + offset;\r\ntype = rec[0] & 0xf;\r\ncond = (rec[1] >> 4) & 0xf;\r\nnon_seq = (rec[1] & 2);\r\nreset = (rec[1] & 1);\r\nsize = get_unaligned_le64(&rec[8]);\r\nstart = get_unaligned_le64(&rec[16]);\r\nwp = get_unaligned_le64(&rec[24]);\r\nrec[0] = type;\r\nrec[1] = (cond << 4) | non_seq | reset;\r\nput_unaligned_be64(size, &rec[8]);\r\nput_unaligned_be64(start, &rec[16]);\r\nput_unaligned_be64(wp, &rec[24]);\r\nWARN_ON(offset + 64 > miter.length);\r\noffset += 64;\r\nbytes += 64;\r\n}\r\n}\r\nsg_miter_stop(&miter);\r\nlocal_irq_restore(flags);\r\nata_scsi_qc_complete(qc);\r\n}\r\nstatic unsigned int ata_scsi_zbc_in_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_taskfile *tf = &qc->tf;\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nconst u8 *cdb = scmd->cmnd;\r\nu16 sect, fp = (u16)-1;\r\nu8 sa, options, bp = 0xff;\r\nu64 block;\r\nu32 n_block;\r\nif (unlikely(scmd->cmd_len < 16)) {\r\nata_dev_warn(qc->dev, "invalid cdb length %d\n",\r\nscmd->cmd_len);\r\nfp = 15;\r\ngoto invalid_fld;\r\n}\r\nscsi_16_lba_len(cdb, &block, &n_block);\r\nif (n_block != scsi_bufflen(scmd)) {\r\nata_dev_warn(qc->dev, "non-matching transfer count (%d/%d)\n",\r\nn_block, scsi_bufflen(scmd));\r\ngoto invalid_param_len;\r\n}\r\nsa = cdb[1] & 0x1f;\r\nif (sa != ZI_REPORT_ZONES) {\r\nata_dev_warn(qc->dev, "invalid service action %d\n", sa);\r\nfp = 1;\r\ngoto invalid_fld;\r\n}\r\nif ((n_block / 512) > 0xffff || n_block < 512 || (n_block % 512)) {\r\nata_dev_warn(qc->dev, "invalid transfer count %d\n", n_block);\r\ngoto invalid_param_len;\r\n}\r\nsect = n_block / 512;\r\noptions = cdb[14] & 0xbf;\r\nif (ata_ncq_enabled(qc->dev) &&\r\nata_fpdma_zac_mgmt_in_supported(qc->dev)) {\r\ntf->protocol = ATA_PROT_NCQ;\r\ntf->command = ATA_CMD_FPDMA_RECV;\r\ntf->hob_nsect = ATA_SUBCMD_FPDMA_RECV_ZAC_MGMT_IN & 0x1f;\r\ntf->nsect = qc->tag << 3;\r\ntf->feature = sect & 0xff;\r\ntf->hob_feature = (sect >> 8) & 0xff;\r\ntf->auxiliary = ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES | (options << 8);\r\n} else {\r\ntf->command = ATA_CMD_ZAC_MGMT_IN;\r\ntf->feature = ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES;\r\ntf->protocol = ATA_PROT_DMA;\r\ntf->hob_feature = options;\r\ntf->hob_nsect = (sect >> 8) & 0xff;\r\ntf->nsect = sect & 0xff;\r\n}\r\ntf->device = ATA_LBA;\r\ntf->lbah = (block >> 16) & 0xff;\r\ntf->lbam = (block >> 8) & 0xff;\r\ntf->lbal = block & 0xff;\r\ntf->hob_lbah = (block >> 40) & 0xff;\r\ntf->hob_lbam = (block >> 32) & 0xff;\r\ntf->hob_lbal = (block >> 24) & 0xff;\r\ntf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE | ATA_TFLAG_LBA48;\r\nqc->flags |= ATA_QCFLAG_RESULT_TF;\r\nata_qc_set_pc_nbytes(qc);\r\nqc->complete_fn = ata_scsi_report_zones_complete;\r\nreturn 0;\r\ninvalid_fld:\r\nata_scsi_set_invalid_field(qc->dev, scmd, fp, bp);\r\nreturn 1;\r\ninvalid_param_len:\r\nata_scsi_set_sense(qc->dev, scmd, ILLEGAL_REQUEST, 0x1a, 0x0);\r\nreturn 1;\r\n}\r\nstatic unsigned int ata_scsi_zbc_out_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_taskfile *tf = &qc->tf;\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nstruct ata_device *dev = qc->dev;\r\nconst u8 *cdb = scmd->cmnd;\r\nu8 all, sa;\r\nu64 block;\r\nu32 n_block;\r\nu16 fp = (u16)-1;\r\nif (unlikely(scmd->cmd_len < 16)) {\r\nfp = 15;\r\ngoto invalid_fld;\r\n}\r\nsa = cdb[1] & 0x1f;\r\nif ((sa != ZO_CLOSE_ZONE) && (sa != ZO_FINISH_ZONE) &&\r\n(sa != ZO_OPEN_ZONE) && (sa != ZO_RESET_WRITE_POINTER)) {\r\nfp = 1;\r\ngoto invalid_fld;\r\n}\r\nscsi_16_lba_len(cdb, &block, &n_block);\r\nif (n_block) {\r\ngoto invalid_param_len;\r\n}\r\nif (block > dev->n_sectors)\r\ngoto out_of_range;\r\nall = cdb[14] & 0x1;\r\nif (ata_ncq_enabled(qc->dev) &&\r\nata_fpdma_zac_mgmt_out_supported(qc->dev)) {\r\ntf->protocol = ATA_PROT_NCQ_NODATA;\r\ntf->command = ATA_CMD_NCQ_NON_DATA;\r\ntf->feature = ATA_SUBCMD_NCQ_NON_DATA_ZAC_MGMT_OUT;\r\ntf->nsect = qc->tag << 3;\r\ntf->auxiliary = sa | ((u16)all << 8);\r\n} else {\r\ntf->protocol = ATA_PROT_NODATA;\r\ntf->command = ATA_CMD_ZAC_MGMT_OUT;\r\ntf->feature = sa;\r\ntf->hob_feature = all;\r\n}\r\ntf->lbah = (block >> 16) & 0xff;\r\ntf->lbam = (block >> 8) & 0xff;\r\ntf->lbal = block & 0xff;\r\ntf->hob_lbah = (block >> 40) & 0xff;\r\ntf->hob_lbam = (block >> 32) & 0xff;\r\ntf->hob_lbal = (block >> 24) & 0xff;\r\ntf->device = ATA_LBA;\r\ntf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE | ATA_TFLAG_LBA48;\r\nreturn 0;\r\ninvalid_fld:\r\nata_scsi_set_invalid_field(qc->dev, scmd, fp, 0xff);\r\nreturn 1;\r\nout_of_range:\r\nata_scsi_set_sense(qc->dev, scmd, ILLEGAL_REQUEST, 0x21, 0x00);\r\nreturn 1;\r\ninvalid_param_len:\r\nata_scsi_set_sense(qc->dev, scmd, ILLEGAL_REQUEST, 0x1a, 0x0);\r\nreturn 1;\r\n}\r\nstatic int ata_mselect_caching(struct ata_queued_cmd *qc,\r\nconst u8 *buf, int len, u16 *fp)\r\n{\r\nstruct ata_taskfile *tf = &qc->tf;\r\nstruct ata_device *dev = qc->dev;\r\nu8 mpage[CACHE_MPAGE_LEN];\r\nu8 wce;\r\nint i;\r\nif (len != CACHE_MPAGE_LEN - 2) {\r\nif (len < CACHE_MPAGE_LEN - 2)\r\n*fp = len;\r\nelse\r\n*fp = CACHE_MPAGE_LEN - 2;\r\nreturn -EINVAL;\r\n}\r\nwce = buf[0] & (1 << 2);\r\nata_msense_caching(dev->id, mpage, false);\r\nfor (i = 0; i < CACHE_MPAGE_LEN - 2; i++) {\r\nif (i == 0)\r\ncontinue;\r\nif (mpage[i + 2] != buf[i]) {\r\n*fp = i;\r\nreturn -EINVAL;\r\n}\r\n}\r\ntf->flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR;\r\ntf->protocol = ATA_PROT_NODATA;\r\ntf->nsect = 0;\r\ntf->command = ATA_CMD_SET_FEATURES;\r\ntf->feature = wce ? SETFEATURES_WC_ON : SETFEATURES_WC_OFF;\r\nreturn 0;\r\n}\r\nstatic int ata_mselect_control(struct ata_queued_cmd *qc,\r\nconst u8 *buf, int len, u16 *fp)\r\n{\r\nstruct ata_device *dev = qc->dev;\r\nu8 mpage[CONTROL_MPAGE_LEN];\r\nu8 d_sense;\r\nint i;\r\nif (len != CONTROL_MPAGE_LEN - 2) {\r\nif (len < CONTROL_MPAGE_LEN - 2)\r\n*fp = len;\r\nelse\r\n*fp = CONTROL_MPAGE_LEN - 2;\r\nreturn -EINVAL;\r\n}\r\nd_sense = buf[0] & (1 << 2);\r\nata_msense_control(dev, mpage, false);\r\nfor (i = 0; i < CONTROL_MPAGE_LEN - 2; i++) {\r\nif (i == 0)\r\ncontinue;\r\nif (mpage[2 + i] != buf[i]) {\r\n*fp = i;\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (d_sense & (1 << 2))\r\ndev->flags |= ATA_DFLAG_D_SENSE;\r\nelse\r\ndev->flags &= ~ATA_DFLAG_D_SENSE;\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsi_mode_select_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nconst u8 *cdb = scmd->cmnd;\r\nconst u8 *p;\r\nu8 pg, spg;\r\nunsigned six_byte, pg_len, hdr_len, bd_len;\r\nint len;\r\nu16 fp = (u16)-1;\r\nu8 bp = 0xff;\r\nVPRINTK("ENTER\n");\r\nsix_byte = (cdb[0] == MODE_SELECT);\r\nif (six_byte) {\r\nif (scmd->cmd_len < 5) {\r\nfp = 4;\r\ngoto invalid_fld;\r\n}\r\nlen = cdb[4];\r\nhdr_len = 4;\r\n} else {\r\nif (scmd->cmd_len < 9) {\r\nfp = 8;\r\ngoto invalid_fld;\r\n}\r\nlen = (cdb[7] << 8) + cdb[8];\r\nhdr_len = 8;\r\n}\r\nif ((cdb[1] & 0x11) != 0x10) {\r\nfp = 1;\r\nbp = (cdb[1] & 0x01) ? 1 : 5;\r\ngoto invalid_fld;\r\n}\r\nif (!scsi_sg_count(scmd) || scsi_sglist(scmd)->length < len)\r\ngoto invalid_param_len;\r\np = page_address(sg_page(scsi_sglist(scmd)));\r\nif (len < hdr_len)\r\ngoto invalid_param_len;\r\nif (six_byte)\r\nbd_len = p[3];\r\nelse\r\nbd_len = (p[6] << 8) + p[7];\r\nlen -= hdr_len;\r\np += hdr_len;\r\nif (len < bd_len)\r\ngoto invalid_param_len;\r\nif (bd_len != 0 && bd_len != 8) {\r\nfp = (six_byte) ? 3 : 6;\r\nfp += bd_len + hdr_len;\r\ngoto invalid_param;\r\n}\r\nlen -= bd_len;\r\np += bd_len;\r\nif (len == 0)\r\ngoto skip;\r\npg = p[0] & 0x3f;\r\nif (p[0] & 0x40) {\r\nif (len < 4)\r\ngoto invalid_param_len;\r\nspg = p[1];\r\npg_len = (p[2] << 8) | p[3];\r\np += 4;\r\nlen -= 4;\r\n} else {\r\nif (len < 2)\r\ngoto invalid_param_len;\r\nspg = 0;\r\npg_len = p[1];\r\np += 2;\r\nlen -= 2;\r\n}\r\nif (spg && (spg != ALL_SUB_MPAGES)) {\r\nfp = (p[0] & 0x40) ? 1 : 0;\r\nfp += hdr_len + bd_len;\r\ngoto invalid_param;\r\n}\r\nif (pg_len > len)\r\ngoto invalid_param_len;\r\nswitch (pg) {\r\ncase CACHE_MPAGE:\r\nif (ata_mselect_caching(qc, p, pg_len, &fp) < 0) {\r\nfp += hdr_len + bd_len;\r\ngoto invalid_param;\r\n}\r\nbreak;\r\ncase CONTROL_MPAGE:\r\nif (ata_mselect_control(qc, p, pg_len, &fp) < 0) {\r\nfp += hdr_len + bd_len;\r\ngoto invalid_param;\r\n} else {\r\ngoto skip;\r\n}\r\nbreak;\r\ndefault:\r\nfp = bd_len + hdr_len;\r\ngoto invalid_param;\r\n}\r\nif (len > pg_len)\r\ngoto invalid_param;\r\nreturn 0;\r\ninvalid_fld:\r\nata_scsi_set_invalid_field(qc->dev, scmd, fp, bp);\r\nreturn 1;\r\ninvalid_param:\r\nata_scsi_set_invalid_parameter(qc->dev, scmd, fp);\r\nreturn 1;\r\ninvalid_param_len:\r\nata_scsi_set_sense(qc->dev, scmd, ILLEGAL_REQUEST, 0x1a, 0x0);\r\nreturn 1;\r\nskip:\r\nscmd->result = SAM_STAT_GOOD;\r\nreturn 1;\r\n}\r\nstatic u8 ata_scsi_trusted_op(u32 len, bool send, bool dma)\r\n{\r\nif (len == 0)\r\nreturn ATA_CMD_TRUSTED_NONDATA;\r\nelse if (send)\r\nreturn dma ? ATA_CMD_TRUSTED_SND_DMA : ATA_CMD_TRUSTED_SND;\r\nelse\r\nreturn dma ? ATA_CMD_TRUSTED_RCV_DMA : ATA_CMD_TRUSTED_RCV;\r\n}\r\nstatic unsigned int ata_scsi_security_inout_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nconst u8 *cdb = scmd->cmnd;\r\nstruct ata_taskfile *tf = &qc->tf;\r\nu8 secp = cdb[1];\r\nbool send = (cdb[0] == SECURITY_PROTOCOL_OUT);\r\nu16 spsp = get_unaligned_be16(&cdb[2]);\r\nu32 len = get_unaligned_be32(&cdb[6]);\r\nbool dma = !(qc->dev->flags & ATA_DFLAG_PIO);\r\nif (secp == 0xef) {\r\nata_scsi_set_invalid_field(qc->dev, scmd, 1, 0);\r\nreturn 1;\r\n}\r\nif (cdb[4] & 7) {\r\nif (len > 0xffff) {\r\nata_scsi_set_invalid_field(qc->dev, scmd, 6, 0);\r\nreturn 1;\r\n}\r\n} else {\r\nif (len > 0x01fffe00) {\r\nata_scsi_set_invalid_field(qc->dev, scmd, 6, 0);\r\nreturn 1;\r\n}\r\nlen = (len + 511) / 512;\r\n}\r\ntf->protocol = dma ? ATA_PROT_DMA : ATA_PROT_PIO;\r\ntf->flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR | ATA_TFLAG_LBA;\r\nif (send)\r\ntf->flags |= ATA_TFLAG_WRITE;\r\ntf->command = ata_scsi_trusted_op(len, send, dma);\r\ntf->feature = secp;\r\ntf->lbam = spsp & 0xff;\r\ntf->lbah = spsp >> 8;\r\nif (len) {\r\ntf->nsect = len & 0xff;\r\ntf->lbal = len >> 8;\r\n} else {\r\nif (!send)\r\ntf->lbah = (1 << 7);\r\n}\r\nata_qc_set_pc_nbytes(qc);\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsi_var_len_cdb_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nconst u8 *cdb = scmd->cmnd;\r\nconst u16 sa = get_unaligned_be16(&cdb[8]);\r\nif (sa == ATA_32)\r\nreturn ata_scsi_pass_thru(qc);\r\nreturn 1;\r\n}\r\nstatic inline ata_xlat_func_t ata_get_xlat_func(struct ata_device *dev, u8 cmd)\r\n{\r\nswitch (cmd) {\r\ncase READ_6:\r\ncase READ_10:\r\ncase READ_16:\r\ncase WRITE_6:\r\ncase WRITE_10:\r\ncase WRITE_16:\r\nreturn ata_scsi_rw_xlat;\r\ncase WRITE_SAME_16:\r\nreturn ata_scsi_write_same_xlat;\r\ncase SYNCHRONIZE_CACHE:\r\nif (ata_try_flush_cache(dev))\r\nreturn ata_scsi_flush_xlat;\r\nbreak;\r\ncase VERIFY:\r\ncase VERIFY_16:\r\nreturn ata_scsi_verify_xlat;\r\ncase ATA_12:\r\ncase ATA_16:\r\nreturn ata_scsi_pass_thru;\r\ncase VARIABLE_LENGTH_CMD:\r\nreturn ata_scsi_var_len_cdb_xlat;\r\ncase MODE_SELECT:\r\ncase MODE_SELECT_10:\r\nreturn ata_scsi_mode_select_xlat;\r\nbreak;\r\ncase ZBC_IN:\r\nreturn ata_scsi_zbc_in_xlat;\r\ncase ZBC_OUT:\r\nreturn ata_scsi_zbc_out_xlat;\r\ncase SECURITY_PROTOCOL_IN:\r\ncase SECURITY_PROTOCOL_OUT:\r\nif (!(dev->flags & ATA_DFLAG_TRUSTED))\r\nbreak;\r\nreturn ata_scsi_security_inout_xlat;\r\ncase START_STOP:\r\nreturn ata_scsi_start_stop_xlat;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void ata_scsi_dump_cdb(struct ata_port *ap,\r\nstruct scsi_cmnd *cmd)\r\n{\r\n#ifdef ATA_DEBUG\r\nstruct scsi_device *scsidev = cmd->device;\r\nDPRINTK("CDB (%u:%d,%d,%d) %9ph\n",\r\nap->print_id,\r\nscsidev->channel, scsidev->id, scsidev->lun,\r\ncmd->cmnd);\r\n#endif\r\n}\r\nstatic inline int __ata_scsi_queuecmd(struct scsi_cmnd *scmd,\r\nstruct ata_device *dev)\r\n{\r\nu8 scsi_op = scmd->cmnd[0];\r\nata_xlat_func_t xlat_func;\r\nint rc = 0;\r\nif (dev->class == ATA_DEV_ATA || dev->class == ATA_DEV_ZAC) {\r\nif (unlikely(!scmd->cmd_len || scmd->cmd_len > dev->cdb_len))\r\ngoto bad_cdb_len;\r\nxlat_func = ata_get_xlat_func(dev, scsi_op);\r\n} else {\r\nif (unlikely(!scmd->cmd_len))\r\ngoto bad_cdb_len;\r\nxlat_func = NULL;\r\nif (likely((scsi_op != ATA_16) || !atapi_passthru16)) {\r\nint len = COMMAND_SIZE(scsi_op);\r\nif (unlikely(len > scmd->cmd_len || len > dev->cdb_len))\r\ngoto bad_cdb_len;\r\nxlat_func = atapi_xlat;\r\n} else {\r\nif (unlikely(scmd->cmd_len > 16))\r\ngoto bad_cdb_len;\r\nxlat_func = ata_get_xlat_func(dev, scsi_op);\r\n}\r\n}\r\nif (xlat_func)\r\nrc = ata_scsi_translate(dev, scmd, xlat_func);\r\nelse\r\nata_scsi_simulate(dev, scmd);\r\nreturn rc;\r\nbad_cdb_len:\r\nDPRINTK("bad CDB len=%u, scsi_op=0x%02x, max=%u\n",\r\nscmd->cmd_len, scsi_op, dev->cdb_len);\r\nscmd->result = DID_ERROR << 16;\r\nscmd->scsi_done(scmd);\r\nreturn 0;\r\n}\r\nint ata_scsi_queuecmd(struct Scsi_Host *shost, struct scsi_cmnd *cmd)\r\n{\r\nstruct ata_port *ap;\r\nstruct ata_device *dev;\r\nstruct scsi_device *scsidev = cmd->device;\r\nint rc = 0;\r\nunsigned long irq_flags;\r\nap = ata_shost_to_port(shost);\r\nspin_lock_irqsave(ap->lock, irq_flags);\r\nata_scsi_dump_cdb(ap, cmd);\r\ndev = ata_scsi_find_dev(ap, scsidev);\r\nif (likely(dev))\r\nrc = __ata_scsi_queuecmd(cmd, dev);\r\nelse {\r\ncmd->result = (DID_BAD_TARGET << 16);\r\ncmd->scsi_done(cmd);\r\n}\r\nspin_unlock_irqrestore(ap->lock, irq_flags);\r\nreturn rc;\r\n}\r\nvoid ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd)\r\n{\r\nstruct ata_scsi_args args;\r\nconst u8 *scsicmd = cmd->cmnd;\r\nu8 tmp8;\r\nargs.dev = dev;\r\nargs.id = dev->id;\r\nargs.cmd = cmd;\r\nswitch(scsicmd[0]) {\r\ncase INQUIRY:\r\nif (scsicmd[1] & 2)\r\nata_scsi_set_invalid_field(dev, cmd, 1, 0xff);\r\nelse if ((scsicmd[1] & 1) == 0)\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_std);\r\nelse switch (scsicmd[2]) {\r\ncase 0x00:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_00);\r\nbreak;\r\ncase 0x80:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_80);\r\nbreak;\r\ncase 0x83:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_83);\r\nbreak;\r\ncase 0x89:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_89);\r\nbreak;\r\ncase 0xb0:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_b0);\r\nbreak;\r\ncase 0xb1:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_b1);\r\nbreak;\r\ncase 0xb2:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_b2);\r\nbreak;\r\ncase 0xb6:\r\nif (dev->flags & ATA_DFLAG_ZAC) {\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_b6);\r\nbreak;\r\n}\r\ndefault:\r\nata_scsi_set_invalid_field(dev, cmd, 2, 0xff);\r\nbreak;\r\n}\r\nbreak;\r\ncase MODE_SENSE:\r\ncase MODE_SENSE_10:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_mode_sense);\r\nbreak;\r\ncase READ_CAPACITY:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_read_cap);\r\nbreak;\r\ncase SERVICE_ACTION_IN_16:\r\nif ((scsicmd[1] & 0x1f) == SAI_READ_CAPACITY_16)\r\nata_scsi_rbuf_fill(&args, ata_scsiop_read_cap);\r\nelse\r\nata_scsi_set_invalid_field(dev, cmd, 1, 0xff);\r\nbreak;\r\ncase REPORT_LUNS:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_report_luns);\r\nbreak;\r\ncase REQUEST_SENSE:\r\nata_scsi_set_sense(dev, cmd, 0, 0, 0);\r\ncmd->result = (DRIVER_SENSE << 24);\r\nbreak;\r\ncase SYNCHRONIZE_CACHE:\r\ncase REZERO_UNIT:\r\ncase SEEK_6:\r\ncase SEEK_10:\r\ncase TEST_UNIT_READY:\r\nbreak;\r\ncase SEND_DIAGNOSTIC:\r\ntmp8 = scsicmd[1] & ~(1 << 3);\r\nif (tmp8 != 0x4 || scsicmd[3] || scsicmd[4])\r\nata_scsi_set_invalid_field(dev, cmd, 1, 0xff);\r\nbreak;\r\ncase MAINTENANCE_IN:\r\nif (scsicmd[1] == MI_REPORT_SUPPORTED_OPERATION_CODES)\r\nata_scsi_rbuf_fill(&args, ata_scsiop_maint_in);\r\nelse\r\nata_scsi_set_invalid_field(dev, cmd, 1, 0xff);\r\nbreak;\r\ndefault:\r\nata_scsi_set_sense(dev, cmd, ILLEGAL_REQUEST, 0x20, 0x0);\r\nbreak;\r\n}\r\ncmd->scsi_done(cmd);\r\n}\r\nint ata_scsi_add_hosts(struct ata_host *host, struct scsi_host_template *sht)\r\n{\r\nint i, rc;\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nstruct Scsi_Host *shost;\r\nrc = -ENOMEM;\r\nshost = scsi_host_alloc(sht, sizeof(struct ata_port *));\r\nif (!shost)\r\ngoto err_alloc;\r\nshost->eh_noresume = 1;\r\n*(struct ata_port **)&shost->hostdata[0] = ap;\r\nap->scsi_host = shost;\r\nshost->transportt = ata_scsi_transport_template;\r\nshost->unique_id = ap->print_id;\r\nshost->max_id = 16;\r\nshost->max_lun = 1;\r\nshost->max_channel = 1;\r\nshost->max_cmd_len = 32;\r\nshost->max_host_blocked = 1;\r\nrc = scsi_add_host_with_dma(ap->scsi_host,\r\n&ap->tdev, ap->host->dev);\r\nif (rc)\r\ngoto err_add;\r\n}\r\nreturn 0;\r\nerr_add:\r\nscsi_host_put(host->ports[i]->scsi_host);\r\nerr_alloc:\r\nwhile (--i >= 0) {\r\nstruct Scsi_Host *shost = host->ports[i]->scsi_host;\r\nscsi_remove_host(shost);\r\nscsi_host_put(shost);\r\n}\r\nreturn rc;\r\n}\r\nvoid ata_scsi_scan_host(struct ata_port *ap, int sync)\r\n{\r\nint tries = 5;\r\nstruct ata_device *last_failed_dev = NULL;\r\nstruct ata_link *link;\r\nstruct ata_device *dev;\r\nrepeat:\r\nata_for_each_link(link, ap, EDGE) {\r\nata_for_each_dev(dev, link, ENABLED) {\r\nstruct scsi_device *sdev;\r\nint channel = 0, id = 0;\r\nif (dev->sdev)\r\ncontinue;\r\nif (ata_is_host_link(link))\r\nid = dev->devno;\r\nelse\r\nchannel = link->pmp;\r\nsdev = __scsi_add_device(ap->scsi_host, channel, id, 0,\r\nNULL);\r\nif (!IS_ERR(sdev)) {\r\ndev->sdev = sdev;\r\nscsi_device_put(sdev);\r\n} else {\r\ndev->sdev = NULL;\r\n}\r\n}\r\n}\r\nata_for_each_link(link, ap, EDGE) {\r\nata_for_each_dev(dev, link, ENABLED) {\r\nif (!dev->sdev)\r\ngoto exit_loop;\r\n}\r\n}\r\nexit_loop:\r\nif (!link)\r\nreturn;\r\nif (sync) {\r\nif (dev != last_failed_dev) {\r\nmsleep(100);\r\nlast_failed_dev = dev;\r\ngoto repeat;\r\n}\r\nif (--tries) {\r\nmsleep(100);\r\ngoto repeat;\r\n}\r\nata_port_err(ap,\r\n"WARNING: synchronous SCSI scan failed without making any progress, switching to async\n");\r\n}\r\nqueue_delayed_work(system_long_wq, &ap->hotplug_task,\r\nround_jiffies_relative(HZ));\r\n}\r\nint ata_scsi_offline_dev(struct ata_device *dev)\r\n{\r\nif (dev->sdev) {\r\nscsi_device_set_state(dev->sdev, SDEV_OFFLINE);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ata_scsi_remove_dev(struct ata_device *dev)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nstruct scsi_device *sdev;\r\nunsigned long flags;\r\nmutex_lock(&ap->scsi_host->scan_mutex);\r\nspin_lock_irqsave(ap->lock, flags);\r\nsdev = dev->sdev;\r\ndev->sdev = NULL;\r\nif (sdev) {\r\nif (scsi_device_get(sdev) == 0) {\r\nscsi_device_set_state(sdev, SDEV_OFFLINE);\r\n} else {\r\nWARN_ON(1);\r\nsdev = NULL;\r\n}\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nmutex_unlock(&ap->scsi_host->scan_mutex);\r\nif (sdev) {\r\nata_dev_info(dev, "detaching (SCSI %s)\n",\r\ndev_name(&sdev->sdev_gendev));\r\nscsi_remove_device(sdev);\r\nscsi_device_put(sdev);\r\n}\r\n}\r\nstatic void ata_scsi_handle_link_detach(struct ata_link *link)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_device *dev;\r\nata_for_each_dev(dev, link, ALL) {\r\nunsigned long flags;\r\nif (!(dev->flags & ATA_DFLAG_DETACHED))\r\ncontinue;\r\nspin_lock_irqsave(ap->lock, flags);\r\ndev->flags &= ~ATA_DFLAG_DETACHED;\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nif (zpodd_dev_enabled(dev))\r\nzpodd_exit(dev);\r\nata_scsi_remove_dev(dev);\r\n}\r\n}\r\nvoid ata_scsi_media_change_notify(struct ata_device *dev)\r\n{\r\nif (dev->sdev)\r\nsdev_evt_send_simple(dev->sdev, SDEV_EVT_MEDIA_CHANGE,\r\nGFP_ATOMIC);\r\n}\r\nvoid ata_scsi_hotplug(struct work_struct *work)\r\n{\r\nstruct ata_port *ap =\r\ncontainer_of(work, struct ata_port, hotplug_task.work);\r\nint i;\r\nif (ap->pflags & ATA_PFLAG_UNLOADING) {\r\nDPRINTK("ENTER/EXIT - unloading\n");\r\nreturn;\r\n}\r\n#ifdef CONFIG_FREEZER\r\nwhile (pm_freezing)\r\nmsleep(10);\r\n#endif\r\nDPRINTK("ENTER\n");\r\nmutex_lock(&ap->scsi_scan_mutex);\r\nata_scsi_handle_link_detach(&ap->link);\r\nif (ap->pmp_link)\r\nfor (i = 0; i < SATA_PMP_MAX_PORTS; i++)\r\nata_scsi_handle_link_detach(&ap->pmp_link[i]);\r\nata_scsi_scan_host(ap, 0);\r\nmutex_unlock(&ap->scsi_scan_mutex);\r\nDPRINTK("EXIT\n");\r\n}\r\nint ata_scsi_user_scan(struct Scsi_Host *shost, unsigned int channel,\r\nunsigned int id, u64 lun)\r\n{\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nunsigned long flags;\r\nint devno, rc = 0;\r\nif (!ap->ops->error_handler)\r\nreturn -EOPNOTSUPP;\r\nif (lun != SCAN_WILD_CARD && lun)\r\nreturn -EINVAL;\r\nif (!sata_pmp_attached(ap)) {\r\nif (channel != SCAN_WILD_CARD && channel)\r\nreturn -EINVAL;\r\ndevno = id;\r\n} else {\r\nif (id != SCAN_WILD_CARD && id)\r\nreturn -EINVAL;\r\ndevno = channel;\r\n}\r\nspin_lock_irqsave(ap->lock, flags);\r\nif (devno == SCAN_WILD_CARD) {\r\nstruct ata_link *link;\r\nata_for_each_link(link, ap, EDGE) {\r\nstruct ata_eh_info *ehi = &link->eh_info;\r\nehi->probe_mask |= ATA_ALL_DEVICES;\r\nehi->action |= ATA_EH_RESET;\r\n}\r\n} else {\r\nstruct ata_device *dev = ata_find_dev(ap, devno);\r\nif (dev) {\r\nstruct ata_eh_info *ehi = &dev->link->eh_info;\r\nehi->probe_mask |= 1 << dev->devno;\r\nehi->action |= ATA_EH_RESET;\r\n} else\r\nrc = -EINVAL;\r\n}\r\nif (rc == 0) {\r\nata_port_schedule_eh(ap);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nata_port_wait_eh(ap);\r\n} else\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nreturn rc;\r\n}\r\nvoid ata_scsi_dev_rescan(struct work_struct *work)\r\n{\r\nstruct ata_port *ap =\r\ncontainer_of(work, struct ata_port, scsi_rescan_task);\r\nstruct ata_link *link;\r\nstruct ata_device *dev;\r\nunsigned long flags;\r\nmutex_lock(&ap->scsi_scan_mutex);\r\nspin_lock_irqsave(ap->lock, flags);\r\nata_for_each_link(link, ap, EDGE) {\r\nata_for_each_dev(dev, link, ENABLED) {\r\nstruct scsi_device *sdev = dev->sdev;\r\nif (!sdev)\r\ncontinue;\r\nif (scsi_device_get(sdev))\r\ncontinue;\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nscsi_rescan_device(&(sdev->sdev_gendev));\r\nscsi_device_put(sdev);\r\nspin_lock_irqsave(ap->lock, flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nmutex_unlock(&ap->scsi_scan_mutex);\r\n}\r\nstruct ata_port *ata_sas_port_alloc(struct ata_host *host,\r\nstruct ata_port_info *port_info,\r\nstruct Scsi_Host *shost)\r\n{\r\nstruct ata_port *ap;\r\nap = ata_port_alloc(host);\r\nif (!ap)\r\nreturn NULL;\r\nap->port_no = 0;\r\nap->lock = &host->lock;\r\nap->pio_mask = port_info->pio_mask;\r\nap->mwdma_mask = port_info->mwdma_mask;\r\nap->udma_mask = port_info->udma_mask;\r\nap->flags |= port_info->flags;\r\nap->ops = port_info->port_ops;\r\nap->cbl = ATA_CBL_SATA;\r\nreturn ap;\r\n}\r\nint ata_sas_port_start(struct ata_port *ap)\r\n{\r\nif (!ap->ops->error_handler)\r\nap->pflags &= ~ATA_PFLAG_FROZEN;\r\nreturn 0;\r\n}\r\nvoid ata_sas_port_stop(struct ata_port *ap)\r\n{\r\n}\r\nvoid ata_sas_async_probe(struct ata_port *ap)\r\n{\r\n__ata_port_probe(ap);\r\n}\r\nint ata_sas_sync_probe(struct ata_port *ap)\r\n{\r\nreturn ata_port_probe(ap);\r\n}\r\nint ata_sas_port_init(struct ata_port *ap)\r\n{\r\nint rc = ap->ops->port_start(ap);\r\nif (rc)\r\nreturn rc;\r\nap->print_id = atomic_inc_return(&ata_print_id);\r\nreturn 0;\r\n}\r\nvoid ata_sas_port_destroy(struct ata_port *ap)\r\n{\r\nif (ap->ops->port_stop)\r\nap->ops->port_stop(ap);\r\nkfree(ap);\r\n}\r\nint ata_sas_slave_configure(struct scsi_device *sdev, struct ata_port *ap)\r\n{\r\nata_scsi_sdev_config(sdev);\r\nata_scsi_dev_config(sdev, ap->link.device);\r\nreturn 0;\r\n}\r\nint ata_sas_queuecmd(struct scsi_cmnd *cmd, struct ata_port *ap)\r\n{\r\nint rc = 0;\r\nata_scsi_dump_cdb(ap, cmd);\r\nif (likely(ata_dev_enabled(ap->link.device)))\r\nrc = __ata_scsi_queuecmd(cmd, ap->link.device);\r\nelse {\r\ncmd->result = (DID_BAD_TARGET << 16);\r\ncmd->scsi_done(cmd);\r\n}\r\nreturn rc;\r\n}\r\nint ata_sas_allocate_tag(struct ata_port *ap)\r\n{\r\nunsigned int max_queue = ap->host->n_tags;\r\nunsigned int i, tag;\r\nfor (i = 0, tag = ap->sas_last_tag + 1; i < max_queue; i++, tag++) {\r\ntag = tag < max_queue ? tag : 0;\r\nif (tag == ATA_TAG_INTERNAL)\r\ncontinue;\r\nif (!test_and_set_bit(tag, &ap->sas_tag_allocated)) {\r\nap->sas_last_tag = tag;\r\nreturn tag;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nvoid ata_sas_free_tag(unsigned int tag, struct ata_port *ap)\r\n{\r\nclear_bit(tag, &ap->sas_tag_allocated);\r\n}
