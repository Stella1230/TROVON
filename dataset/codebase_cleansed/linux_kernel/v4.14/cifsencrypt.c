static int\r\ncifs_crypto_shash_md5_allocate(struct TCP_Server_Info *server)\r\n{\r\nint rc;\r\nunsigned int size;\r\nif (server->secmech.sdescmd5 != NULL)\r\nreturn 0;\r\nserver->secmech.md5 = crypto_alloc_shash("md5", 0, 0);\r\nif (IS_ERR(server->secmech.md5)) {\r\ncifs_dbg(VFS, "could not allocate crypto md5\n");\r\nrc = PTR_ERR(server->secmech.md5);\r\nserver->secmech.md5 = NULL;\r\nreturn rc;\r\n}\r\nsize = sizeof(struct shash_desc) +\r\ncrypto_shash_descsize(server->secmech.md5);\r\nserver->secmech.sdescmd5 = kmalloc(size, GFP_KERNEL);\r\nif (!server->secmech.sdescmd5) {\r\ncrypto_free_shash(server->secmech.md5);\r\nserver->secmech.md5 = NULL;\r\nreturn -ENOMEM;\r\n}\r\nserver->secmech.sdescmd5->shash.tfm = server->secmech.md5;\r\nserver->secmech.sdescmd5->shash.flags = 0x0;\r\nreturn 0;\r\n}\r\nint __cifs_calc_signature(struct smb_rqst *rqst,\r\nstruct TCP_Server_Info *server, char *signature,\r\nstruct shash_desc *shash)\r\n{\r\nint i;\r\nint rc;\r\nstruct kvec *iov = rqst->rq_iov;\r\nint n_vec = rqst->rq_nvec;\r\nif (n_vec < 2 || iov[0].iov_len != 4)\r\nreturn -EIO;\r\nfor (i = 1; i < n_vec; i++) {\r\nif (iov[i].iov_len == 0)\r\ncontinue;\r\nif (iov[i].iov_base == NULL) {\r\ncifs_dbg(VFS, "null iovec entry\n");\r\nreturn -EIO;\r\n}\r\nif (i == 1 && iov[1].iov_len <= 4)\r\nbreak;\r\nrc = crypto_shash_update(shash,\r\niov[i].iov_base, iov[i].iov_len);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with payload\n",\r\n__func__);\r\nreturn rc;\r\n}\r\n}\r\nfor (i = 0; i < rqst->rq_npages; i++) {\r\nvoid *kaddr = kmap(rqst->rq_pages[i]);\r\nsize_t len = rqst->rq_pagesz;\r\nif (i == rqst->rq_npages - 1)\r\nlen = rqst->rq_tailsz;\r\ncrypto_shash_update(shash, kaddr, len);\r\nkunmap(rqst->rq_pages[i]);\r\n}\r\nrc = crypto_shash_final(shash, signature);\r\nif (rc)\r\ncifs_dbg(VFS, "%s: Could not generate hash\n", __func__);\r\nreturn rc;\r\n}\r\nstatic int cifs_calc_signature(struct smb_rqst *rqst,\r\nstruct TCP_Server_Info *server, char *signature)\r\n{\r\nint rc;\r\nif (!rqst->rq_iov || !signature || !server)\r\nreturn -EINVAL;\r\nif (!server->secmech.sdescmd5) {\r\nrc = cifs_crypto_shash_md5_allocate(server);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Can't alloc md5 crypto\n", __func__);\r\nreturn -1;\r\n}\r\n}\r\nrc = crypto_shash_init(&server->secmech.sdescmd5->shash);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not init md5\n", __func__);\r\nreturn rc;\r\n}\r\nrc = crypto_shash_update(&server->secmech.sdescmd5->shash,\r\nserver->session_key.response, server->session_key.len);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with response\n", __func__);\r\nreturn rc;\r\n}\r\nreturn __cifs_calc_signature(rqst, server, signature,\r\n&server->secmech.sdescmd5->shash);\r\n}\r\nint cifs_sign_rqst(struct smb_rqst *rqst, struct TCP_Server_Info *server,\r\n__u32 *pexpected_response_sequence_number)\r\n{\r\nint rc = 0;\r\nchar smb_signature[20];\r\nstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\r\nif (rqst->rq_iov[0].iov_len != 4 ||\r\nrqst->rq_iov[0].iov_base + 4 != rqst->rq_iov[1].iov_base)\r\nreturn -EIO;\r\nif ((cifs_pdu == NULL) || (server == NULL))\r\nreturn -EINVAL;\r\nif (!(cifs_pdu->Flags2 & SMBFLG2_SECURITY_SIGNATURE) ||\r\nserver->tcpStatus == CifsNeedNegotiate)\r\nreturn rc;\r\nif (!server->session_estab) {\r\nmemcpy(cifs_pdu->Signature.SecuritySignature, "BSRSPYL", 8);\r\nreturn rc;\r\n}\r\ncifs_pdu->Signature.Sequence.SequenceNumber =\r\ncpu_to_le32(server->sequence_number);\r\ncifs_pdu->Signature.Sequence.Reserved = 0;\r\n*pexpected_response_sequence_number = ++server->sequence_number;\r\n++server->sequence_number;\r\nrc = cifs_calc_signature(rqst, server, smb_signature);\r\nif (rc)\r\nmemset(cifs_pdu->Signature.SecuritySignature, 0, 8);\r\nelse\r\nmemcpy(cifs_pdu->Signature.SecuritySignature, smb_signature, 8);\r\nreturn rc;\r\n}\r\nint cifs_sign_smbv(struct kvec *iov, int n_vec, struct TCP_Server_Info *server,\r\n__u32 *pexpected_response_sequence)\r\n{\r\nstruct smb_rqst rqst = { .rq_iov = iov,\r\n.rq_nvec = n_vec };\r\nreturn cifs_sign_rqst(&rqst, server, pexpected_response_sequence);\r\n}\r\nint cifs_sign_smb(struct smb_hdr *cifs_pdu, struct TCP_Server_Info *server,\r\n__u32 *pexpected_response_sequence_number)\r\n{\r\nstruct kvec iov[2];\r\niov[0].iov_base = cifs_pdu;\r\niov[0].iov_len = 4;\r\niov[1].iov_base = (char *)cifs_pdu + 4;\r\niov[1].iov_len = be32_to_cpu(cifs_pdu->smb_buf_length);\r\nreturn cifs_sign_smbv(iov, 2, server,\r\npexpected_response_sequence_number);\r\n}\r\nint cifs_verify_signature(struct smb_rqst *rqst,\r\nstruct TCP_Server_Info *server,\r\n__u32 expected_sequence_number)\r\n{\r\nunsigned int rc;\r\nchar server_response_sig[8];\r\nchar what_we_think_sig_should_be[20];\r\nstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\r\nif (rqst->rq_iov[0].iov_len != 4 ||\r\nrqst->rq_iov[0].iov_base + 4 != rqst->rq_iov[1].iov_base)\r\nreturn -EIO;\r\nif (cifs_pdu == NULL || server == NULL)\r\nreturn -EINVAL;\r\nif (!server->session_estab)\r\nreturn 0;\r\nif (cifs_pdu->Command == SMB_COM_LOCKING_ANDX) {\r\nstruct smb_com_lock_req *pSMB =\r\n(struct smb_com_lock_req *)cifs_pdu;\r\nif (pSMB->LockType & LOCKING_ANDX_OPLOCK_RELEASE)\r\nreturn 0;\r\n}\r\nif (memcmp(cifs_pdu->Signature.SecuritySignature, "BSRSPYL ", 8) == 0)\r\ncifs_dbg(FYI, "dummy signature received for smb command 0x%x\n",\r\ncifs_pdu->Command);\r\nmemcpy(server_response_sig, cifs_pdu->Signature.SecuritySignature, 8);\r\ncifs_pdu->Signature.Sequence.SequenceNumber =\r\ncpu_to_le32(expected_sequence_number);\r\ncifs_pdu->Signature.Sequence.Reserved = 0;\r\nmutex_lock(&server->srv_mutex);\r\nrc = cifs_calc_signature(rqst, server, what_we_think_sig_should_be);\r\nmutex_unlock(&server->srv_mutex);\r\nif (rc)\r\nreturn rc;\r\nif (memcmp(server_response_sig, what_we_think_sig_should_be, 8))\r\nreturn -EACCES;\r\nelse\r\nreturn 0;\r\n}\r\nint setup_ntlm_response(struct cifs_ses *ses, const struct nls_table *nls_cp)\r\n{\r\nint rc = 0;\r\nunsigned int temp_len = CIFS_SESS_KEY_SIZE + CIFS_AUTH_RESP_SIZE;\r\nchar temp_key[CIFS_SESS_KEY_SIZE];\r\nif (!ses)\r\nreturn -EINVAL;\r\nses->auth_key.response = kmalloc(temp_len, GFP_KERNEL);\r\nif (!ses->auth_key.response)\r\nreturn -ENOMEM;\r\nses->auth_key.len = temp_len;\r\nrc = SMBNTencrypt(ses->password, ses->server->cryptkey,\r\nses->auth_key.response + CIFS_SESS_KEY_SIZE, nls_cp);\r\nif (rc) {\r\ncifs_dbg(FYI, "%s Can't generate NTLM response, error: %d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nrc = E_md4hash(ses->password, temp_key, nls_cp);\r\nif (rc) {\r\ncifs_dbg(FYI, "%s Can't generate NT hash, error: %d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nrc = mdfour(ses->auth_key.response, temp_key, CIFS_SESS_KEY_SIZE);\r\nif (rc)\r\ncifs_dbg(FYI, "%s Can't generate NTLM session key, error: %d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nint calc_lanman_hash(const char *password, const char *cryptkey, bool encrypt,\r\nchar *lnm_session_key)\r\n{\r\nint i;\r\nint rc;\r\nchar password_with_pad[CIFS_ENCPWD_SIZE];\r\nmemset(password_with_pad, 0, CIFS_ENCPWD_SIZE);\r\nif (password)\r\nstrncpy(password_with_pad, password, CIFS_ENCPWD_SIZE);\r\nif (!encrypt && global_secflags & CIFSSEC_MAY_PLNTXT) {\r\nmemcpy(lnm_session_key, password_with_pad,\r\nCIFS_ENCPWD_SIZE);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < CIFS_ENCPWD_SIZE; i++)\r\npassword_with_pad[i] = toupper(password_with_pad[i]);\r\nrc = SMBencrypt(password_with_pad, cryptkey, lnm_session_key);\r\nreturn rc;\r\n}\r\nstatic int\r\nbuild_avpair_blob(struct cifs_ses *ses, const struct nls_table *nls_cp)\r\n{\r\nunsigned int dlen;\r\nunsigned int size = 2 * sizeof(struct ntlmssp2_name);\r\nchar *defdmname = "WORKGROUP";\r\nunsigned char *blobptr;\r\nstruct ntlmssp2_name *attrptr;\r\nif (!ses->domainName) {\r\nses->domainName = kstrdup(defdmname, GFP_KERNEL);\r\nif (!ses->domainName)\r\nreturn -ENOMEM;\r\n}\r\ndlen = strlen(ses->domainName);\r\nses->auth_key.len = size + 2 * dlen;\r\nses->auth_key.response = kzalloc(ses->auth_key.len, GFP_KERNEL);\r\nif (!ses->auth_key.response) {\r\nses->auth_key.len = 0;\r\nreturn -ENOMEM;\r\n}\r\nblobptr = ses->auth_key.response;\r\nattrptr = (struct ntlmssp2_name *) blobptr;\r\nattrptr->type = cpu_to_le16(NTLMSSP_AV_NB_DOMAIN_NAME);\r\nattrptr->length = cpu_to_le16(2 * dlen);\r\nblobptr = (unsigned char *)attrptr + sizeof(struct ntlmssp2_name);\r\ncifs_strtoUTF16((__le16 *)blobptr, ses->domainName, dlen, nls_cp);\r\nreturn 0;\r\n}\r\nstatic int\r\nfind_domain_name(struct cifs_ses *ses, const struct nls_table *nls_cp)\r\n{\r\nunsigned int attrsize;\r\nunsigned int type;\r\nunsigned int onesize = sizeof(struct ntlmssp2_name);\r\nunsigned char *blobptr;\r\nunsigned char *blobend;\r\nstruct ntlmssp2_name *attrptr;\r\nif (!ses->auth_key.len || !ses->auth_key.response)\r\nreturn 0;\r\nblobptr = ses->auth_key.response;\r\nblobend = blobptr + ses->auth_key.len;\r\nwhile (blobptr + onesize < blobend) {\r\nattrptr = (struct ntlmssp2_name *) blobptr;\r\ntype = le16_to_cpu(attrptr->type);\r\nif (type == NTLMSSP_AV_EOL)\r\nbreak;\r\nblobptr += 2;\r\nattrsize = le16_to_cpu(attrptr->length);\r\nblobptr += 2;\r\nif (blobptr + attrsize > blobend)\r\nbreak;\r\nif (type == NTLMSSP_AV_NB_DOMAIN_NAME) {\r\nif (!attrsize || attrsize >= CIFS_MAX_DOMAINNAME_LEN)\r\nbreak;\r\nif (!ses->domainName) {\r\nses->domainName =\r\nkmalloc(attrsize + 1, GFP_KERNEL);\r\nif (!ses->domainName)\r\nreturn -ENOMEM;\r\ncifs_from_utf16(ses->domainName,\r\n(__le16 *)blobptr, attrsize, attrsize,\r\nnls_cp, NO_MAP_UNI_RSVD);\r\nbreak;\r\n}\r\n}\r\nblobptr += attrsize;\r\n}\r\nreturn 0;\r\n}\r\nstatic __le64\r\nfind_timestamp(struct cifs_ses *ses)\r\n{\r\nunsigned int attrsize;\r\nunsigned int type;\r\nunsigned int onesize = sizeof(struct ntlmssp2_name);\r\nunsigned char *blobptr;\r\nunsigned char *blobend;\r\nstruct ntlmssp2_name *attrptr;\r\nstruct timespec ts;\r\nif (!ses->auth_key.len || !ses->auth_key.response)\r\nreturn 0;\r\nblobptr = ses->auth_key.response;\r\nblobend = blobptr + ses->auth_key.len;\r\nwhile (blobptr + onesize < blobend) {\r\nattrptr = (struct ntlmssp2_name *) blobptr;\r\ntype = le16_to_cpu(attrptr->type);\r\nif (type == NTLMSSP_AV_EOL)\r\nbreak;\r\nblobptr += 2;\r\nattrsize = le16_to_cpu(attrptr->length);\r\nblobptr += 2;\r\nif (blobptr + attrsize > blobend)\r\nbreak;\r\nif (type == NTLMSSP_AV_TIMESTAMP) {\r\nif (attrsize == sizeof(u64))\r\nreturn *((__le64 *)blobptr);\r\n}\r\nblobptr += attrsize;\r\n}\r\nktime_get_real_ts(&ts);\r\nreturn cpu_to_le64(cifs_UnixTimeToNT(ts));\r\n}\r\nstatic int calc_ntlmv2_hash(struct cifs_ses *ses, char *ntlmv2_hash,\r\nconst struct nls_table *nls_cp)\r\n{\r\nint rc = 0;\r\nint len;\r\nchar nt_hash[CIFS_NTHASH_SIZE];\r\n__le16 *user;\r\nwchar_t *domain;\r\nwchar_t *server;\r\nif (!ses->server->secmech.sdeschmacmd5) {\r\ncifs_dbg(VFS, "%s: can't generate ntlmv2 hash\n", __func__);\r\nreturn -1;\r\n}\r\nE_md4hash(ses->password, nt_hash, nls_cp);\r\nrc = crypto_shash_setkey(ses->server->secmech.hmacmd5, nt_hash,\r\nCIFS_NTHASH_SIZE);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not set NT Hash as a key\n", __func__);\r\nreturn rc;\r\n}\r\nrc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: could not init hmacmd5\n", __func__);\r\nreturn rc;\r\n}\r\nlen = ses->user_name ? strlen(ses->user_name) : 0;\r\nuser = kmalloc(2 + (len * 2), GFP_KERNEL);\r\nif (user == NULL) {\r\nrc = -ENOMEM;\r\nreturn rc;\r\n}\r\nif (len) {\r\nlen = cifs_strtoUTF16(user, ses->user_name, len, nls_cp);\r\nUniStrupr(user);\r\n} else {\r\nmemset(user, '\0', 2);\r\n}\r\nrc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\r\n(char *)user, 2 * len);\r\nkfree(user);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with user\n", __func__);\r\nreturn rc;\r\n}\r\nif (ses->domainName) {\r\nlen = strlen(ses->domainName);\r\ndomain = kmalloc(2 + (len * 2), GFP_KERNEL);\r\nif (domain == NULL) {\r\nrc = -ENOMEM;\r\nreturn rc;\r\n}\r\nlen = cifs_strtoUTF16((__le16 *)domain, ses->domainName, len,\r\nnls_cp);\r\nrc =\r\ncrypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\r\n(char *)domain, 2 * len);\r\nkfree(domain);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with domain\n",\r\n__func__);\r\nreturn rc;\r\n}\r\n} else {\r\nlen = strlen(ses->serverName);\r\nserver = kmalloc(2 + (len * 2), GFP_KERNEL);\r\nif (server == NULL) {\r\nrc = -ENOMEM;\r\nreturn rc;\r\n}\r\nlen = cifs_strtoUTF16((__le16 *)server, ses->serverName, len,\r\nnls_cp);\r\nrc =\r\ncrypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\r\n(char *)server, 2 * len);\r\nkfree(server);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with server\n",\r\n__func__);\r\nreturn rc;\r\n}\r\n}\r\nrc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\r\nntlmv2_hash);\r\nif (rc)\r\ncifs_dbg(VFS, "%s: Could not generate md5 hash\n", __func__);\r\nreturn rc;\r\n}\r\nstatic int\r\nCalcNTLMv2_response(const struct cifs_ses *ses, char *ntlmv2_hash)\r\n{\r\nint rc;\r\nstruct ntlmv2_resp *ntlmv2 = (struct ntlmv2_resp *)\r\n(ses->auth_key.response + CIFS_SESS_KEY_SIZE);\r\nunsigned int hash_len;\r\nhash_len = ses->auth_key.len - (CIFS_SESS_KEY_SIZE +\r\noffsetof(struct ntlmv2_resp, challenge.key[0]));\r\nif (!ses->server->secmech.sdeschmacmd5) {\r\ncifs_dbg(VFS, "%s: can't generate ntlmv2 hash\n", __func__);\r\nreturn -1;\r\n}\r\nrc = crypto_shash_setkey(ses->server->secmech.hmacmd5,\r\nntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not set NTLMV2 Hash as a key\n",\r\n__func__);\r\nreturn rc;\r\n}\r\nrc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: could not init hmacmd5\n", __func__);\r\nreturn rc;\r\n}\r\nif (ses->server->negflavor == CIFS_NEGFLAVOR_EXTENDED)\r\nmemcpy(ntlmv2->challenge.key,\r\nses->ntlmssp->cryptkey, CIFS_SERVER_CHALLENGE_SIZE);\r\nelse\r\nmemcpy(ntlmv2->challenge.key,\r\nses->server->cryptkey, CIFS_SERVER_CHALLENGE_SIZE);\r\nrc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\r\nntlmv2->challenge.key, hash_len);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with response\n", __func__);\r\nreturn rc;\r\n}\r\nrc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\r\nntlmv2->ntlmv2_hash);\r\nif (rc)\r\ncifs_dbg(VFS, "%s: Could not generate md5 hash\n", __func__);\r\nreturn rc;\r\n}\r\nstatic int crypto_hmacmd5_alloc(struct TCP_Server_Info *server)\r\n{\r\nint rc;\r\nunsigned int size;\r\nif (server->secmech.sdeschmacmd5)\r\nreturn 0;\r\nserver->secmech.hmacmd5 = crypto_alloc_shash("hmac(md5)", 0, 0);\r\nif (IS_ERR(server->secmech.hmacmd5)) {\r\ncifs_dbg(VFS, "could not allocate crypto hmacmd5\n");\r\nrc = PTR_ERR(server->secmech.hmacmd5);\r\nserver->secmech.hmacmd5 = NULL;\r\nreturn rc;\r\n}\r\nsize = sizeof(struct shash_desc) +\r\ncrypto_shash_descsize(server->secmech.hmacmd5);\r\nserver->secmech.sdeschmacmd5 = kmalloc(size, GFP_KERNEL);\r\nif (!server->secmech.sdeschmacmd5) {\r\ncrypto_free_shash(server->secmech.hmacmd5);\r\nserver->secmech.hmacmd5 = NULL;\r\nreturn -ENOMEM;\r\n}\r\nserver->secmech.sdeschmacmd5->shash.tfm = server->secmech.hmacmd5;\r\nserver->secmech.sdeschmacmd5->shash.flags = 0x0;\r\nreturn 0;\r\n}\r\nint\r\nsetup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)\r\n{\r\nint rc;\r\nint baselen;\r\nunsigned int tilen;\r\nstruct ntlmv2_resp *ntlmv2;\r\nchar ntlmv2_hash[16];\r\nunsigned char *tiblob = NULL;\r\n__le64 rsp_timestamp;\r\nif (ses->server->negflavor == CIFS_NEGFLAVOR_EXTENDED) {\r\nif (!ses->domainName) {\r\nif (ses->domainAuto) {\r\nrc = find_domain_name(ses, nls_cp);\r\nif (rc) {\r\ncifs_dbg(VFS, "error %d finding domain name\n",\r\nrc);\r\ngoto setup_ntlmv2_rsp_ret;\r\n}\r\n} else {\r\nses->domainName = kstrdup("", GFP_KERNEL);\r\n}\r\n}\r\n} else {\r\nrc = build_avpair_blob(ses, nls_cp);\r\nif (rc) {\r\ncifs_dbg(VFS, "error %d building av pair blob\n", rc);\r\ngoto setup_ntlmv2_rsp_ret;\r\n}\r\n}\r\nrsp_timestamp = find_timestamp(ses);\r\nbaselen = CIFS_SESS_KEY_SIZE + sizeof(struct ntlmv2_resp);\r\ntilen = ses->auth_key.len;\r\ntiblob = ses->auth_key.response;\r\nses->auth_key.response = kmalloc(baselen + tilen, GFP_KERNEL);\r\nif (!ses->auth_key.response) {\r\nrc = -ENOMEM;\r\nses->auth_key.len = 0;\r\ngoto setup_ntlmv2_rsp_ret;\r\n}\r\nses->auth_key.len += baselen;\r\nntlmv2 = (struct ntlmv2_resp *)\r\n(ses->auth_key.response + CIFS_SESS_KEY_SIZE);\r\nntlmv2->blob_signature = cpu_to_le32(0x00000101);\r\nntlmv2->reserved = 0;\r\nntlmv2->time = rsp_timestamp;\r\nget_random_bytes(&ntlmv2->client_chal, sizeof(ntlmv2->client_chal));\r\nntlmv2->reserved2 = 0;\r\nmemcpy(ses->auth_key.response + baselen, tiblob, tilen);\r\nmutex_lock(&ses->server->srv_mutex);\r\nrc = crypto_hmacmd5_alloc(ses->server);\r\nif (rc) {\r\ncifs_dbg(VFS, "could not crypto alloc hmacmd5 rc %d\n", rc);\r\ngoto unlock;\r\n}\r\nrc = calc_ntlmv2_hash(ses, ntlmv2_hash, nls_cp);\r\nif (rc) {\r\ncifs_dbg(VFS, "could not get v2 hash rc %d\n", rc);\r\ngoto unlock;\r\n}\r\nrc = CalcNTLMv2_response(ses, ntlmv2_hash);\r\nif (rc) {\r\ncifs_dbg(VFS, "Could not calculate CR1 rc: %d\n", rc);\r\ngoto unlock;\r\n}\r\nrc = crypto_shash_setkey(ses->server->secmech.hmacmd5,\r\nntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not set NTLMV2 Hash as a key\n",\r\n__func__);\r\ngoto unlock;\r\n}\r\nrc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not init hmacmd5\n", __func__);\r\ngoto unlock;\r\n}\r\nrc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\r\nntlmv2->ntlmv2_hash,\r\nCIFS_HMAC_MD5_HASH_SIZE);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with response\n", __func__);\r\ngoto unlock;\r\n}\r\nrc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\r\nses->auth_key.response);\r\nif (rc)\r\ncifs_dbg(VFS, "%s: Could not generate md5 hash\n", __func__);\r\nunlock:\r\nmutex_unlock(&ses->server->srv_mutex);\r\nsetup_ntlmv2_rsp_ret:\r\nkfree(tiblob);\r\nreturn rc;\r\n}\r\nint\r\ncalc_seckey(struct cifs_ses *ses)\r\n{\r\nint rc;\r\nstruct crypto_skcipher *tfm_arc4;\r\nstruct scatterlist sgin, sgout;\r\nstruct skcipher_request *req;\r\nunsigned char *sec_key;\r\nsec_key = kmalloc(CIFS_SESS_KEY_SIZE, GFP_KERNEL);\r\nif (sec_key == NULL)\r\nreturn -ENOMEM;\r\nget_random_bytes(sec_key, CIFS_SESS_KEY_SIZE);\r\ntfm_arc4 = crypto_alloc_skcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm_arc4)) {\r\nrc = PTR_ERR(tfm_arc4);\r\ncifs_dbg(VFS, "could not allocate crypto API arc4\n");\r\ngoto out;\r\n}\r\nrc = crypto_skcipher_setkey(tfm_arc4, ses->auth_key.response,\r\nCIFS_SESS_KEY_SIZE);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not set response as a key\n",\r\n__func__);\r\ngoto out_free_cipher;\r\n}\r\nreq = skcipher_request_alloc(tfm_arc4, GFP_KERNEL);\r\nif (!req) {\r\nrc = -ENOMEM;\r\ncifs_dbg(VFS, "could not allocate crypto API arc4 request\n");\r\ngoto out_free_cipher;\r\n}\r\nsg_init_one(&sgin, sec_key, CIFS_SESS_KEY_SIZE);\r\nsg_init_one(&sgout, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, &sgin, &sgout, CIFS_CPHTXT_SIZE, NULL);\r\nrc = crypto_skcipher_encrypt(req);\r\nskcipher_request_free(req);\r\nif (rc) {\r\ncifs_dbg(VFS, "could not encrypt session key rc: %d\n", rc);\r\ngoto out_free_cipher;\r\n}\r\nmemcpy(ses->auth_key.response, sec_key, CIFS_SESS_KEY_SIZE);\r\nses->auth_key.len = CIFS_SESS_KEY_SIZE;\r\nout_free_cipher:\r\ncrypto_free_skcipher(tfm_arc4);\r\nout:\r\nkfree(sec_key);\r\nreturn rc;\r\n}\r\nvoid\r\ncifs_crypto_secmech_release(struct TCP_Server_Info *server)\r\n{\r\nif (server->secmech.cmacaes) {\r\ncrypto_free_shash(server->secmech.cmacaes);\r\nserver->secmech.cmacaes = NULL;\r\n}\r\nif (server->secmech.hmacsha256) {\r\ncrypto_free_shash(server->secmech.hmacsha256);\r\nserver->secmech.hmacsha256 = NULL;\r\n}\r\nif (server->secmech.md5) {\r\ncrypto_free_shash(server->secmech.md5);\r\nserver->secmech.md5 = NULL;\r\n}\r\nif (server->secmech.hmacmd5) {\r\ncrypto_free_shash(server->secmech.hmacmd5);\r\nserver->secmech.hmacmd5 = NULL;\r\n}\r\nif (server->secmech.ccmaesencrypt) {\r\ncrypto_free_aead(server->secmech.ccmaesencrypt);\r\nserver->secmech.ccmaesencrypt = NULL;\r\n}\r\nif (server->secmech.ccmaesdecrypt) {\r\ncrypto_free_aead(server->secmech.ccmaesdecrypt);\r\nserver->secmech.ccmaesdecrypt = NULL;\r\n}\r\nkfree(server->secmech.sdesccmacaes);\r\nserver->secmech.sdesccmacaes = NULL;\r\nkfree(server->secmech.sdeschmacsha256);\r\nserver->secmech.sdeschmacsha256 = NULL;\r\nkfree(server->secmech.sdeschmacmd5);\r\nserver->secmech.sdeschmacmd5 = NULL;\r\nkfree(server->secmech.sdescmd5);\r\nserver->secmech.sdescmd5 = NULL;\r\n}
