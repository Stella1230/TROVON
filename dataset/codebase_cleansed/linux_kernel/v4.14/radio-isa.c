static int radio_isa_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstruct radio_isa_card *isa = video_drvdata(file);\r\nstrlcpy(v->driver, isa->drv->driver.driver.name, sizeof(v->driver));\r\nstrlcpy(v->card, isa->drv->card, sizeof(v->card));\r\nsnprintf(v->bus_info, sizeof(v->bus_info), "ISA:%s", isa->v4l2_dev.name);\r\nv->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\r\nv->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int radio_isa_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct radio_isa_card *isa = video_drvdata(file);\r\nconst struct radio_isa_ops *ops = isa->drv->ops;\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(v->name, "FM", sizeof(v->name));\r\nv->type = V4L2_TUNER_RADIO;\r\nv->rangelow = FREQ_LOW;\r\nv->rangehigh = FREQ_HIGH;\r\nv->capability = V4L2_TUNER_CAP_LOW;\r\nif (isa->drv->has_stereo)\r\nv->capability |= V4L2_TUNER_CAP_STEREO;\r\nif (ops->g_rxsubchans)\r\nv->rxsubchans = ops->g_rxsubchans(isa);\r\nelse\r\nv->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;\r\nv->audmode = isa->stereo ? V4L2_TUNER_MODE_STEREO : V4L2_TUNER_MODE_MONO;\r\nif (ops->g_signal)\r\nv->signal = ops->g_signal(isa);\r\nelse\r\nv->signal = (v->rxsubchans & V4L2_TUNER_SUB_STEREO) ?\r\n0xffff : 0;\r\nreturn 0;\r\n}\r\nstatic int radio_isa_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *v)\r\n{\r\nstruct radio_isa_card *isa = video_drvdata(file);\r\nconst struct radio_isa_ops *ops = isa->drv->ops;\r\nif (v->index)\r\nreturn -EINVAL;\r\nif (ops->s_stereo) {\r\nisa->stereo = (v->audmode == V4L2_TUNER_MODE_STEREO);\r\nreturn ops->s_stereo(isa, isa->stereo);\r\n}\r\nreturn 0;\r\n}\r\nstatic int radio_isa_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct radio_isa_card *isa = video_drvdata(file);\r\nu32 freq = f->frequency;\r\nint res;\r\nif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nfreq = clamp(freq, FREQ_LOW, FREQ_HIGH);\r\nres = isa->drv->ops->s_frequency(isa, freq);\r\nif (res == 0)\r\nisa->freq = freq;\r\nreturn res;\r\n}\r\nstatic int radio_isa_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct radio_isa_card *isa = video_drvdata(file);\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = isa->freq;\r\nreturn 0;\r\n}\r\nstatic int radio_isa_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct radio_isa_card *isa =\r\ncontainer_of(ctrl->handler, struct radio_isa_card, hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nreturn isa->drv->ops->s_mute_volume(isa, ctrl->val,\r\nisa->volume ? isa->volume->val : 0);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int radio_isa_log_status(struct file *file, void *priv)\r\n{\r\nstruct radio_isa_card *isa = video_drvdata(file);\r\nv4l2_info(&isa->v4l2_dev, "I/O Port = 0x%03x\n", isa->io);\r\nv4l2_ctrl_handler_log_status(&isa->hdl, isa->v4l2_dev.name);\r\nreturn 0;\r\n}\r\nint radio_isa_match(struct device *pdev, unsigned int dev)\r\n{\r\nstruct radio_isa_driver *drv = pdev->platform_data;\r\nreturn drv->probe || drv->io_params[dev] >= 0;\r\n}\r\nstatic bool radio_isa_valid_io(const struct radio_isa_driver *drv, int io)\r\n{\r\nint i;\r\nfor (i = 0; i < drv->num_of_io_ports; i++)\r\nif (drv->io_ports[i] == io)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic struct radio_isa_card *radio_isa_alloc(struct radio_isa_driver *drv,\r\nstruct device *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev;\r\nstruct radio_isa_card *isa = drv->ops->alloc();\r\nif (!isa)\r\nreturn NULL;\r\ndev_set_drvdata(pdev, isa);\r\nisa->drv = drv;\r\nv4l2_dev = &isa->v4l2_dev;\r\nstrlcpy(v4l2_dev->name, dev_name(pdev), sizeof(v4l2_dev->name));\r\nreturn isa;\r\n}\r\nstatic int radio_isa_common_probe(struct radio_isa_card *isa,\r\nstruct device *pdev,\r\nint radio_nr, unsigned region_size)\r\n{\r\nconst struct radio_isa_driver *drv = isa->drv;\r\nconst struct radio_isa_ops *ops = drv->ops;\r\nstruct v4l2_device *v4l2_dev = &isa->v4l2_dev;\r\nint res;\r\nif (!request_region(isa->io, region_size, v4l2_dev->name)) {\r\nv4l2_err(v4l2_dev, "port 0x%x already in use\n", isa->io);\r\nkfree(isa);\r\nreturn -EBUSY;\r\n}\r\nres = v4l2_device_register(pdev, v4l2_dev);\r\nif (res < 0) {\r\nv4l2_err(v4l2_dev, "Could not register v4l2_device\n");\r\ngoto err_dev_reg;\r\n}\r\nv4l2_ctrl_handler_init(&isa->hdl, 1);\r\nisa->mute = v4l2_ctrl_new_std(&isa->hdl, &radio_isa_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\r\nif (drv->max_volume)\r\nisa->volume = v4l2_ctrl_new_std(&isa->hdl, &radio_isa_ctrl_ops,\r\nV4L2_CID_AUDIO_VOLUME, 0, drv->max_volume, 1,\r\ndrv->max_volume);\r\nv4l2_dev->ctrl_handler = &isa->hdl;\r\nif (isa->hdl.error) {\r\nres = isa->hdl.error;\r\nv4l2_err(v4l2_dev, "Could not register controls\n");\r\ngoto err_hdl;\r\n}\r\nif (drv->max_volume)\r\nv4l2_ctrl_cluster(2, &isa->mute);\r\nv4l2_dev->ctrl_handler = &isa->hdl;\r\nmutex_init(&isa->lock);\r\nisa->vdev.lock = &isa->lock;\r\nstrlcpy(isa->vdev.name, v4l2_dev->name, sizeof(isa->vdev.name));\r\nisa->vdev.v4l2_dev = v4l2_dev;\r\nisa->vdev.fops = &radio_isa_fops;\r\nisa->vdev.ioctl_ops = &radio_isa_ioctl_ops;\r\nisa->vdev.release = video_device_release_empty;\r\nvideo_set_drvdata(&isa->vdev, isa);\r\nisa->freq = FREQ_LOW;\r\nisa->stereo = drv->has_stereo;\r\nif (ops->init)\r\nres = ops->init(isa);\r\nif (!res)\r\nres = v4l2_ctrl_handler_setup(&isa->hdl);\r\nif (!res)\r\nres = ops->s_frequency(isa, isa->freq);\r\nif (!res && ops->s_stereo)\r\nres = ops->s_stereo(isa, isa->stereo);\r\nif (res < 0) {\r\nv4l2_err(v4l2_dev, "Could not setup card\n");\r\ngoto err_hdl;\r\n}\r\nres = video_register_device(&isa->vdev, VFL_TYPE_RADIO, radio_nr);\r\nif (res < 0) {\r\nv4l2_err(v4l2_dev, "Could not register device node\n");\r\ngoto err_hdl;\r\n}\r\nv4l2_info(v4l2_dev, "Initialized radio card %s on port 0x%03x\n",\r\ndrv->card, isa->io);\r\nreturn 0;\r\nerr_hdl:\r\nv4l2_ctrl_handler_free(&isa->hdl);\r\nerr_dev_reg:\r\nrelease_region(isa->io, region_size);\r\nkfree(isa);\r\nreturn res;\r\n}\r\nstatic int radio_isa_common_remove(struct radio_isa_card *isa,\r\nunsigned region_size)\r\n{\r\nconst struct radio_isa_ops *ops = isa->drv->ops;\r\nops->s_mute_volume(isa, true, isa->volume ? isa->volume->cur.val : 0);\r\nvideo_unregister_device(&isa->vdev);\r\nv4l2_ctrl_handler_free(&isa->hdl);\r\nv4l2_device_unregister(&isa->v4l2_dev);\r\nrelease_region(isa->io, region_size);\r\nv4l2_info(&isa->v4l2_dev, "Removed radio card %s\n", isa->drv->card);\r\nkfree(isa);\r\nreturn 0;\r\n}\r\nint radio_isa_probe(struct device *pdev, unsigned int dev)\r\n{\r\nstruct radio_isa_driver *drv = pdev->platform_data;\r\nconst struct radio_isa_ops *ops = drv->ops;\r\nstruct v4l2_device *v4l2_dev;\r\nstruct radio_isa_card *isa;\r\nisa = radio_isa_alloc(drv, pdev);\r\nif (!isa)\r\nreturn -ENOMEM;\r\nisa->io = drv->io_params[dev];\r\nv4l2_dev = &isa->v4l2_dev;\r\nif (drv->probe && ops->probe) {\r\nint i;\r\nfor (i = 0; i < drv->num_of_io_ports; ++i) {\r\nint io = drv->io_ports[i];\r\nif (request_region(io, drv->region_size, v4l2_dev->name)) {\r\nbool found = ops->probe(isa, io);\r\nrelease_region(io, drv->region_size);\r\nif (found) {\r\nisa->io = io;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif (!radio_isa_valid_io(drv, isa->io)) {\r\nint i;\r\nif (isa->io < 0)\r\nreturn -ENODEV;\r\nv4l2_err(v4l2_dev, "you must set an I/O address with io=0x%03x",\r\ndrv->io_ports[0]);\r\nfor (i = 1; i < drv->num_of_io_ports; i++)\r\nprintk(KERN_CONT "/0x%03x", drv->io_ports[i]);\r\nprintk(KERN_CONT ".\n");\r\nkfree(isa);\r\nreturn -EINVAL;\r\n}\r\nreturn radio_isa_common_probe(isa, pdev, drv->radio_nr_params[dev],\r\ndrv->region_size);\r\n}\r\nint radio_isa_remove(struct device *pdev, unsigned int dev)\r\n{\r\nstruct radio_isa_card *isa = dev_get_drvdata(pdev);\r\nreturn radio_isa_common_remove(isa, isa->drv->region_size);\r\n}\r\nint radio_isa_pnp_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)\r\n{\r\nstruct pnp_driver *pnp_drv = to_pnp_driver(dev->dev.driver);\r\nstruct radio_isa_driver *drv = container_of(pnp_drv,\r\nstruct radio_isa_driver, pnp_driver);\r\nstruct radio_isa_card *isa;\r\nif (!pnp_port_valid(dev, 0))\r\nreturn -ENODEV;\r\nisa = radio_isa_alloc(drv, &dev->dev);\r\nif (!isa)\r\nreturn -ENOMEM;\r\nisa->io = pnp_port_start(dev, 0);\r\nreturn radio_isa_common_probe(isa, &dev->dev, drv->radio_nr_params[0],\r\npnp_port_len(dev, 0));\r\n}\r\nvoid radio_isa_pnp_remove(struct pnp_dev *dev)\r\n{\r\nstruct radio_isa_card *isa = dev_get_drvdata(&dev->dev);\r\nradio_isa_common_remove(isa, pnp_port_len(dev, 0));\r\n}
