int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,\r\nconst struct hdac_bus_ops *ops,\r\nconst struct hdac_io_ops *io_ops)\r\n{\r\nmemset(bus, 0, sizeof(*bus));\r\nbus->dev = dev;\r\nif (ops)\r\nbus->ops = ops;\r\nelse\r\nbus->ops = &default_ops;\r\nbus->io_ops = io_ops;\r\nINIT_LIST_HEAD(&bus->stream_list);\r\nINIT_LIST_HEAD(&bus->codec_list);\r\nINIT_WORK(&bus->unsol_work, process_unsol_events);\r\nspin_lock_init(&bus->reg_lock);\r\nmutex_init(&bus->cmd_mutex);\r\nbus->irq = -1;\r\nreturn 0;\r\n}\r\nvoid snd_hdac_bus_exit(struct hdac_bus *bus)\r\n{\r\nWARN_ON(!list_empty(&bus->stream_list));\r\nWARN_ON(!list_empty(&bus->codec_list));\r\ncancel_work_sync(&bus->unsol_work);\r\n}\r\nint snd_hdac_bus_exec_verb(struct hdac_bus *bus, unsigned int addr,\r\nunsigned int cmd, unsigned int *res)\r\n{\r\nint err;\r\nmutex_lock(&bus->cmd_mutex);\r\nerr = snd_hdac_bus_exec_verb_unlocked(bus, addr, cmd, res);\r\nmutex_unlock(&bus->cmd_mutex);\r\nreturn err;\r\n}\r\nint snd_hdac_bus_exec_verb_unlocked(struct hdac_bus *bus, unsigned int addr,\r\nunsigned int cmd, unsigned int *res)\r\n{\r\nunsigned int tmp;\r\nint err;\r\nif (cmd == ~0)\r\nreturn -EINVAL;\r\nif (res)\r\n*res = -1;\r\nelse if (bus->sync_write)\r\nres = &tmp;\r\nfor (;;) {\r\ntrace_hda_send_cmd(bus, cmd);\r\nerr = bus->ops->command(bus, cmd);\r\nif (err != -EAGAIN)\r\nbreak;\r\nerr = bus->ops->get_response(bus, addr, &tmp);\r\nif (err)\r\nbreak;\r\n}\r\nif (!err && res) {\r\nerr = bus->ops->get_response(bus, addr, res);\r\ntrace_hda_get_response(bus, addr, *res);\r\n}\r\nreturn err;\r\n}\r\nvoid snd_hdac_bus_queue_event(struct hdac_bus *bus, u32 res, u32 res_ex)\r\n{\r\nunsigned int wp;\r\nif (!bus)\r\nreturn;\r\ntrace_hda_unsol_event(bus, res, res_ex);\r\nwp = (bus->unsol_wp + 1) % HDA_UNSOL_QUEUE_SIZE;\r\nbus->unsol_wp = wp;\r\nwp <<= 1;\r\nbus->unsol_queue[wp] = res;\r\nbus->unsol_queue[wp + 1] = res_ex;\r\nschedule_work(&bus->unsol_work);\r\n}\r\nstatic void process_unsol_events(struct work_struct *work)\r\n{\r\nstruct hdac_bus *bus = container_of(work, struct hdac_bus, unsol_work);\r\nstruct hdac_device *codec;\r\nstruct hdac_driver *drv;\r\nunsigned int rp, caddr, res;\r\nwhile (bus->unsol_rp != bus->unsol_wp) {\r\nrp = (bus->unsol_rp + 1) % HDA_UNSOL_QUEUE_SIZE;\r\nbus->unsol_rp = rp;\r\nrp <<= 1;\r\nres = bus->unsol_queue[rp];\r\ncaddr = bus->unsol_queue[rp + 1];\r\nif (!(caddr & (1 << 4)))\r\ncontinue;\r\ncodec = bus->caddr_tbl[caddr & 0x0f];\r\nif (!codec || !codec->dev.driver)\r\ncontinue;\r\ndrv = drv_to_hdac_driver(codec->dev.driver);\r\nif (drv->unsol_event)\r\ndrv->unsol_event(codec, res);\r\n}\r\n}\r\nint snd_hdac_bus_add_device(struct hdac_bus *bus, struct hdac_device *codec)\r\n{\r\nif (bus->caddr_tbl[codec->addr]) {\r\ndev_err(bus->dev, "address 0x%x is already occupied\n",\r\ncodec->addr);\r\nreturn -EBUSY;\r\n}\r\nlist_add_tail(&codec->list, &bus->codec_list);\r\nbus->caddr_tbl[codec->addr] = codec;\r\nset_bit(codec->addr, &bus->codec_powered);\r\nbus->num_codecs++;\r\nreturn 0;\r\n}\r\nvoid snd_hdac_bus_remove_device(struct hdac_bus *bus,\r\nstruct hdac_device *codec)\r\n{\r\nWARN_ON(bus != codec->bus);\r\nif (list_empty(&codec->list))\r\nreturn;\r\nlist_del_init(&codec->list);\r\nbus->caddr_tbl[codec->addr] = NULL;\r\nclear_bit(codec->addr, &bus->codec_powered);\r\nbus->num_codecs--;\r\nflush_work(&bus->unsol_work);\r\n}
