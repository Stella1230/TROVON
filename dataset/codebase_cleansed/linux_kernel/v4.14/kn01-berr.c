static inline void dec_kn01_be_ack(void)\r\n{\r\nvolatile u16 *csr = (void *)CKSEG1ADDR(KN01_SLOT_BASE + KN01_CSR);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&kn01_lock, flags);\r\n*csr = cached_kn01_csr | KN01_CSR_MEMERR;\r\niob();\r\nraw_spin_unlock_irqrestore(&kn01_lock, flags);\r\n}\r\nstatic int dec_kn01_be_backend(struct pt_regs *regs, int is_fixup, int invoker)\r\n{\r\nvolatile u32 *kn01_erraddr = (void *)CKSEG1ADDR(KN01_SLOT_BASE +\r\nKN01_ERRADDR);\r\nstatic const char excstr[] = "exception";\r\nstatic const char intstr[] = "interrupt";\r\nstatic const char cpustr[] = "CPU";\r\nstatic const char mreadstr[] = "memory read";\r\nstatic const char readstr[] = "read";\r\nstatic const char writestr[] = "write";\r\nstatic const char timestr[] = "timeout";\r\nstatic const char paritystr[] = "parity error";\r\nint data = regs->cp0_cause & 4;\r\nunsigned int __user *pc = (unsigned int __user *)regs->cp0_epc +\r\n((regs->cp0_cause & CAUSEF_BD) != 0);\r\nunion mips_instruction insn;\r\nunsigned long entrylo, offset;\r\nlong asid, entryhi, vaddr;\r\nconst char *kind, *agent, *cycle, *event;\r\nunsigned long address;\r\nu32 erraddr = *kn01_erraddr;\r\nint action = MIPS_BE_FATAL;\r\ndec_kn01_be_ack();\r\nkind = invoker ? intstr : excstr;\r\nagent = cpustr;\r\nif (invoker)\r\naddress = erraddr;\r\nelse {\r\nif (data) {\r\n__get_user(insn.word, pc);\r\nvaddr = regs->regs[insn.i_format.rs] +\r\ninsn.i_format.simmediate;\r\n} else\r\nvaddr = (long)pc;\r\nif (KSEGX(vaddr) == CKSEG0 || KSEGX(vaddr) == CKSEG1)\r\naddress = CPHYSADDR(vaddr);\r\nelse {\r\nasid = read_c0_entryhi();\r\nentryhi = asid & (PAGE_SIZE - 1);\r\nentryhi |= vaddr & ~(PAGE_SIZE - 1);\r\nwrite_c0_entryhi(entryhi);\r\nBARRIER;\r\ntlb_probe();\r\ntlb_read();\r\nentrylo = read_c0_entrylo0();\r\nwrite_c0_entryhi(asid);\r\noffset = vaddr & (PAGE_SIZE - 1);\r\naddress = (entrylo & ~(PAGE_SIZE - 1)) | offset;\r\n}\r\n}\r\nif (address < 0x10000000) {\r\ncycle = mreadstr;\r\nevent = paritystr;\r\n} else {\r\ncycle = invoker ? writestr : readstr;\r\nevent = timestr;\r\n}\r\nif (is_fixup)\r\naction = MIPS_BE_FIXUP;\r\nif (action != MIPS_BE_FIXUP)\r\nprintk(KERN_ALERT "Bus error %s: %s %s %s at %#010lx\n",\r\nkind, agent, cycle, event, address);\r\nreturn action;\r\n}\r\nint dec_kn01_be_handler(struct pt_regs *regs, int is_fixup)\r\n{\r\nreturn dec_kn01_be_backend(regs, is_fixup, 0);\r\n}\r\nirqreturn_t dec_kn01_be_interrupt(int irq, void *dev_id)\r\n{\r\nvolatile u16 *csr = (void *)CKSEG1ADDR(KN01_SLOT_BASE + KN01_CSR);\r\nstruct pt_regs *regs = get_irq_regs();\r\nint action;\r\nif (!(*csr & KN01_CSR_MEMERR))\r\nreturn IRQ_NONE;\r\naction = dec_kn01_be_backend(regs, 0, 1);\r\nif (action == MIPS_BE_DISCARD)\r\nreturn IRQ_HANDLED;\r\nprintk(KERN_ALERT "Fatal bus interrupt, epc == %08lx, ra == %08lx\n",\r\nregs->cp0_epc, regs->regs[31]);\r\ndie("Unrecoverable bus error", regs);\r\n}\r\nvoid __init dec_kn01_be_init(void)\r\n{\r\nvolatile u16 *csr = (void *)CKSEG1ADDR(KN01_SLOT_BASE + KN01_CSR);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&kn01_lock, flags);\r\ncached_kn01_csr = *csr;\r\ncached_kn01_csr &= KN01_CSR_STATUS | KN01_CSR_PARDIS | KN01_CSR_TXDIS;\r\ncached_kn01_csr |= KN01_CSR_LEDS;\r\ncached_kn01_csr &= ~KN01_CSR_PARDIS;\r\n*csr = cached_kn01_csr;\r\niob();\r\nraw_spin_unlock_irqrestore(&kn01_lock, flags);\r\ndec_kn01_be_ack();\r\n}
