static int cros_ec_light_prox_read(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct cros_ec_light_prox_state *st = iio_priv(indio_dev);\r\nu16 data = 0;\r\ns64 val64;\r\nint ret = IIO_VAL_INT;\r\nint idx = chan->scan_index;\r\nmutex_lock(&st->core.cmd_lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (chan->type == IIO_PROXIMITY) {\r\nif (cros_ec_sensors_read_cmd(indio_dev, 1 << idx,\r\n(s16 *)&data) < 0) {\r\nret = -EIO;\r\nbreak;\r\n}\r\n*val = data;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nif (chan->type == IIO_LIGHT) {\r\nif (cros_ec_sensors_read_cmd(indio_dev, 1 << idx,\r\n(s16 *)&data) < 0) {\r\nret = -EIO;\r\nbreak;\r\n}\r\n*val = data;\r\nret = IIO_VAL_INT;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nst->core.param.cmd = MOTIONSENSE_CMD_SENSOR_OFFSET;\r\nst->core.param.sensor_offset.flags = 0;\r\nif (cros_ec_motion_send_host_cmd(&st->core, 0)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nst->core.calib[0] = st->core.resp->sensor_offset.offset[0];\r\n*val = st->core.calib[idx];\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nst->core.param.cmd = MOTIONSENSE_CMD_SENSOR_RANGE;\r\nst->core.param.sensor_range.data = EC_MOTION_SENSE_NO_VALUE;\r\nif (cros_ec_motion_send_host_cmd(&st->core, 0)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nval64 = st->core.resp->sensor_range.ret;\r\n*val = val64 >> 16;\r\n*val2 = (val64 & 0xffff) * 100;\r\nret = IIO_VAL_INT_PLUS_MICRO;\r\nbreak;\r\ndefault:\r\nret = cros_ec_sensors_core_read(&st->core, chan, val, val2,\r\nmask);\r\nbreak;\r\n}\r\nmutex_unlock(&st->core.cmd_lock);\r\nreturn ret;\r\n}\r\nstatic int cros_ec_light_prox_write(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct cros_ec_light_prox_state *st = iio_priv(indio_dev);\r\nint ret = 0;\r\nint idx = chan->scan_index;\r\nmutex_lock(&st->core.cmd_lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nst->core.calib[idx] = val;\r\nst->core.param.cmd = MOTIONSENSE_CMD_SENSOR_OFFSET;\r\nst->core.param.sensor_offset.flags = MOTION_SENSE_SET_OFFSET;\r\nst->core.param.sensor_offset.offset[0] = st->core.calib[0];\r\nst->core.param.sensor_offset.temp =\r\nEC_MOTION_SENSE_INVALID_CALIB_TEMP;\r\nif (cros_ec_motion_send_host_cmd(&st->core, 0))\r\nret = -EIO;\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nst->core.param.cmd = MOTIONSENSE_CMD_SENSOR_RANGE;\r\nst->core.param.sensor_range.data = (val << 16) | (val2 / 100);\r\nif (cros_ec_motion_send_host_cmd(&st->core, 0))\r\nret = -EIO;\r\nbreak;\r\ndefault:\r\nret = cros_ec_sensors_core_write(&st->core, chan, val, val2,\r\nmask);\r\nbreak;\r\n}\r\nmutex_unlock(&st->core.cmd_lock);\r\nreturn ret;\r\n}\r\nstatic int cros_ec_light_prox_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct cros_ec_dev *ec_dev = dev_get_drvdata(dev->parent);\r\nstruct cros_ec_device *ec_device;\r\nstruct iio_dev *indio_dev;\r\nstruct cros_ec_light_prox_state *state;\r\nstruct iio_chan_spec *channel;\r\nint ret;\r\nif (!ec_dev || !ec_dev->ec_dev) {\r\ndev_warn(dev, "No CROS EC device found.\n");\r\nreturn -EINVAL;\r\n}\r\nec_device = ec_dev->ec_dev;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(*state));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nret = cros_ec_sensors_core_init(pdev, indio_dev, true);\r\nif (ret)\r\nreturn ret;\r\nindio_dev->info = &cros_ec_light_prox_info;\r\nstate = iio_priv(indio_dev);\r\nstate->core.type = state->core.resp->info.type;\r\nstate->core.loc = state->core.resp->info.location;\r\nchannel = state->channels;\r\nchannel->info_mask_shared_by_all =\r\nBIT(IIO_CHAN_INFO_SAMP_FREQ) |\r\nBIT(IIO_CHAN_INFO_FREQUENCY);\r\nchannel->scan_type.realbits = CROS_EC_SENSOR_BITS;\r\nchannel->scan_type.storagebits = CROS_EC_SENSOR_BITS;\r\nchannel->scan_type.shift = 0;\r\nchannel->scan_index = 0;\r\nchannel->ext_info = cros_ec_sensors_ext_info;\r\nchannel->scan_type.sign = 'u';\r\nstate->core.calib[0] = 0;\r\nswitch (state->core.type) {\r\ncase MOTIONSENSE_TYPE_LIGHT:\r\nchannel->type = IIO_LIGHT;\r\nchannel->info_mask_separate =\r\nBIT(IIO_CHAN_INFO_PROCESSED) |\r\nBIT(IIO_CHAN_INFO_CALIBBIAS) |\r\nBIT(IIO_CHAN_INFO_CALIBSCALE);\r\nbreak;\r\ncase MOTIONSENSE_TYPE_PROX:\r\nchannel->type = IIO_PROXIMITY;\r\nchannel->info_mask_separate =\r\nBIT(IIO_CHAN_INFO_RAW) |\r\nBIT(IIO_CHAN_INFO_CALIBBIAS) |\r\nBIT(IIO_CHAN_INFO_CALIBSCALE);\r\nbreak;\r\ndefault:\r\ndev_warn(dev, "Unknown motion sensor\n");\r\nreturn -EINVAL;\r\n}\r\nchannel++;\r\nchannel->type = IIO_TIMESTAMP;\r\nchannel->channel = -1;\r\nchannel->scan_index = 1;\r\nchannel->scan_type.sign = 's';\r\nchannel->scan_type.realbits = 64;\r\nchannel->scan_type.storagebits = 64;\r\nindio_dev->channels = state->channels;\r\nindio_dev->num_channels = CROS_EC_LIGHT_PROX_MAX_CHANNELS;\r\nstate->core.read_ec_sensors_data = cros_ec_sensors_read_cmd;\r\nret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,\r\ncros_ec_sensors_capture, NULL);\r\nif (ret)\r\nreturn ret;\r\nreturn devm_iio_device_register(dev, indio_dev);\r\n}
