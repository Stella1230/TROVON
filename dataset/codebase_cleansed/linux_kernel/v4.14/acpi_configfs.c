static ssize_t acpi_table_aml_write(struct config_item *cfg,\r\nconst void *data, size_t size)\r\n{\r\nconst struct acpi_table_header *header = data;\r\nstruct acpi_table *table;\r\nint ret;\r\ntable = container_of(cfg, struct acpi_table, cfg);\r\nif (table->header) {\r\npr_err("table already loaded\n");\r\nreturn -EBUSY;\r\n}\r\nif (header->length != size) {\r\npr_err("invalid table length\n");\r\nreturn -EINVAL;\r\n}\r\nif (memcmp(header->signature, ACPI_SIG_SSDT, 4)) {\r\npr_err("invalid table signature\n");\r\nreturn -EINVAL;\r\n}\r\ntable = container_of(cfg, struct acpi_table, cfg);\r\ntable->header = kmemdup(header, header->length, GFP_KERNEL);\r\nif (!table->header)\r\nreturn -ENOMEM;\r\nACPI_INFO(("Host-directed Dynamic ACPI Table Load:"));\r\nret = acpi_tb_install_and_load_table(\r\nACPI_PTR_TO_PHYSADDR(table->header),\r\nACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL, FALSE,\r\n&table->index);\r\nif (ret) {\r\nkfree(table->header);\r\ntable->header = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline struct acpi_table_header *get_header(struct config_item *cfg)\r\n{\r\nstruct acpi_table *table = container_of(cfg, struct acpi_table, cfg);\r\nif (!table->header)\r\npr_err("table not loaded\n");\r\nreturn table->header;\r\n}\r\nstatic ssize_t acpi_table_aml_read(struct config_item *cfg,\r\nvoid *data, size_t size)\r\n{\r\nstruct acpi_table_header *h = get_header(cfg);\r\nif (!h)\r\nreturn -EINVAL;\r\nif (data)\r\nmemcpy(data, h, h->length);\r\nreturn h->length;\r\n}\r\nssize_t acpi_table_signature_show(struct config_item *cfg, char *str)\r\n{\r\nstruct acpi_table_header *h = get_header(cfg);\r\nif (!h)\r\nreturn -EINVAL;\r\nreturn sprintf(str, "%.*s\n", ACPI_NAME_SIZE, h->signature);\r\n}\r\nssize_t acpi_table_length_show(struct config_item *cfg, char *str)\r\n{\r\nstruct acpi_table_header *h = get_header(cfg);\r\nif (!h)\r\nreturn -EINVAL;\r\nreturn sprintf(str, "%d\n", h->length);\r\n}\r\nssize_t acpi_table_revision_show(struct config_item *cfg, char *str)\r\n{\r\nstruct acpi_table_header *h = get_header(cfg);\r\nif (!h)\r\nreturn -EINVAL;\r\nreturn sprintf(str, "%d\n", h->revision);\r\n}\r\nssize_t acpi_table_oem_id_show(struct config_item *cfg, char *str)\r\n{\r\nstruct acpi_table_header *h = get_header(cfg);\r\nif (!h)\r\nreturn -EINVAL;\r\nreturn sprintf(str, "%.*s\n", ACPI_OEM_ID_SIZE, h->oem_id);\r\n}\r\nssize_t acpi_table_oem_table_id_show(struct config_item *cfg, char *str)\r\n{\r\nstruct acpi_table_header *h = get_header(cfg);\r\nif (!h)\r\nreturn -EINVAL;\r\nreturn sprintf(str, "%.*s\n", ACPI_OEM_TABLE_ID_SIZE, h->oem_table_id);\r\n}\r\nssize_t acpi_table_oem_revision_show(struct config_item *cfg, char *str)\r\n{\r\nstruct acpi_table_header *h = get_header(cfg);\r\nif (!h)\r\nreturn -EINVAL;\r\nreturn sprintf(str, "%d\n", h->oem_revision);\r\n}\r\nssize_t acpi_table_asl_compiler_id_show(struct config_item *cfg, char *str)\r\n{\r\nstruct acpi_table_header *h = get_header(cfg);\r\nif (!h)\r\nreturn -EINVAL;\r\nreturn sprintf(str, "%.*s\n", ACPI_NAME_SIZE, h->asl_compiler_id);\r\n}\r\nssize_t acpi_table_asl_compiler_revision_show(struct config_item *cfg,\r\nchar *str)\r\n{\r\nstruct acpi_table_header *h = get_header(cfg);\r\nif (!h)\r\nreturn -EINVAL;\r\nreturn sprintf(str, "%d\n", h->asl_compiler_revision);\r\n}\r\nstatic struct config_item *acpi_table_make_item(struct config_group *group,\r\nconst char *name)\r\n{\r\nstruct acpi_table *table;\r\ntable = kzalloc(sizeof(*table), GFP_KERNEL);\r\nif (!table)\r\nreturn ERR_PTR(-ENOMEM);\r\nconfig_item_init_type_name(&table->cfg, name, &acpi_table_type);\r\nreturn &table->cfg;\r\n}\r\nstatic void acpi_table_drop_item(struct config_group *group,\r\nstruct config_item *cfg)\r\n{\r\nstruct acpi_table *table = container_of(cfg, struct acpi_table, cfg);\r\nACPI_INFO(("Host-directed Dynamic ACPI Table Unload"));\r\nacpi_tb_unload_table(table->index);\r\n}\r\nstatic int __init acpi_configfs_init(void)\r\n{\r\nint ret;\r\nstruct config_group *root = &acpi_configfs.su_group;\r\nconfig_group_init(root);\r\nret = configfs_register_subsystem(&acpi_configfs);\r\nif (ret)\r\nreturn ret;\r\nacpi_table_group = configfs_register_default_group(root, "table",\r\n&acpi_tables_type);\r\nreturn PTR_ERR_OR_ZERO(acpi_table_group);\r\n}\r\nstatic void __exit acpi_configfs_exit(void)\r\n{\r\nconfigfs_unregister_default_group(acpi_table_group);\r\nconfigfs_unregister_subsystem(&acpi_configfs);\r\n}
