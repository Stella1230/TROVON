static int afs_vlocation_access_vl_by_name(struct afs_vlocation *vl,\r\nstruct key *key,\r\nstruct afs_cache_vlocation *vldb)\r\n{\r\nstruct afs_cell *cell = vl->cell;\r\nstruct in_addr addr;\r\nint count, ret;\r\n_enter("%s,%s", cell->name, vl->vldb.name);\r\ndown_write(&vl->cell->vl_sem);\r\nret = -ENOMEDIUM;\r\nfor (count = cell->vl_naddrs; count > 0; count--) {\r\naddr = cell->vl_addrs[cell->vl_curr_svix];\r\n_debug("CellServ[%hu]: %08x", cell->vl_curr_svix, addr.s_addr);\r\nret = afs_vl_get_entry_by_name(&addr, key, vl->vldb.name, vldb,\r\nfalse);\r\nswitch (ret) {\r\ncase 0:\r\ngoto out;\r\ncase -ENOMEM:\r\ncase -ENONET:\r\ncase -ENETUNREACH:\r\ncase -EHOSTUNREACH:\r\ncase -ECONNREFUSED:\r\nif (ret == -ENOMEM || ret == -ENONET)\r\ngoto out;\r\ngoto rotate;\r\ncase -ENOMEDIUM:\r\ncase -EKEYREJECTED:\r\ncase -EKEYEXPIRED:\r\ngoto out;\r\ndefault:\r\nret = -EIO;\r\ngoto rotate;\r\n}\r\nrotate:\r\ncell->vl_curr_svix++;\r\ncell->vl_curr_svix %= cell->vl_naddrs;\r\n}\r\nout:\r\nup_write(&vl->cell->vl_sem);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int afs_vlocation_access_vl_by_id(struct afs_vlocation *vl,\r\nstruct key *key,\r\nafs_volid_t volid,\r\nafs_voltype_t voltype,\r\nstruct afs_cache_vlocation *vldb)\r\n{\r\nstruct afs_cell *cell = vl->cell;\r\nstruct in_addr addr;\r\nint count, ret;\r\n_enter("%s,%x,%d,", cell->name, volid, voltype);\r\ndown_write(&vl->cell->vl_sem);\r\nret = -ENOMEDIUM;\r\nfor (count = cell->vl_naddrs; count > 0; count--) {\r\naddr = cell->vl_addrs[cell->vl_curr_svix];\r\n_debug("CellServ[%hu]: %08x", cell->vl_curr_svix, addr.s_addr);\r\nret = afs_vl_get_entry_by_id(&addr, key, volid, voltype, vldb,\r\nfalse);\r\nswitch (ret) {\r\ncase 0:\r\ngoto out;\r\ncase -ENOMEM:\r\ncase -ENONET:\r\ncase -ENETUNREACH:\r\ncase -EHOSTUNREACH:\r\ncase -ECONNREFUSED:\r\nif (ret == -ENOMEM || ret == -ENONET)\r\ngoto out;\r\ngoto rotate;\r\ncase -EBUSY:\r\nvl->upd_busy_cnt++;\r\nif (vl->upd_busy_cnt <= 3) {\r\nif (vl->upd_busy_cnt > 1) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(1);\r\n}\r\ncontinue;\r\n}\r\nbreak;\r\ncase -ENOMEDIUM:\r\nvl->upd_rej_cnt++;\r\ngoto rotate;\r\ndefault:\r\nret = -EIO;\r\ngoto rotate;\r\n}\r\nrotate:\r\ncell->vl_curr_svix++;\r\ncell->vl_curr_svix %= cell->vl_naddrs;\r\nvl->upd_busy_cnt = 0;\r\n}\r\nout:\r\nif (ret < 0 && vl->upd_rej_cnt > 0) {\r\nprintk(KERN_NOTICE "kAFS:"\r\n" Active volume no longer valid '%s'\n",\r\nvl->vldb.name);\r\nvl->valid = 0;\r\nret = -ENOMEDIUM;\r\n}\r\nup_write(&vl->cell->vl_sem);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic struct afs_vlocation *afs_vlocation_alloc(struct afs_cell *cell,\r\nconst char *name,\r\nsize_t namesz)\r\n{\r\nstruct afs_vlocation *vl;\r\nvl = kzalloc(sizeof(struct afs_vlocation), GFP_KERNEL);\r\nif (vl) {\r\nvl->cell = cell;\r\nvl->state = AFS_VL_NEW;\r\natomic_set(&vl->usage, 1);\r\nINIT_LIST_HEAD(&vl->link);\r\nINIT_LIST_HEAD(&vl->grave);\r\nINIT_LIST_HEAD(&vl->update);\r\ninit_waitqueue_head(&vl->waitq);\r\nspin_lock_init(&vl->lock);\r\nmemcpy(vl->vldb.name, name, namesz);\r\n}\r\n_leave(" = %p", vl);\r\nreturn vl;\r\n}\r\nstatic int afs_vlocation_update_record(struct afs_vlocation *vl,\r\nstruct key *key,\r\nstruct afs_cache_vlocation *vldb)\r\n{\r\nafs_voltype_t voltype;\r\nafs_volid_t vid;\r\nint ret;\r\n_debug("Locally Cached: %s %02x { %08x(%x) %08x(%x) %08x(%x) }",\r\nvl->vldb.name,\r\nvl->vldb.vidmask,\r\nntohl(vl->vldb.servers[0].s_addr),\r\nvl->vldb.srvtmask[0],\r\nntohl(vl->vldb.servers[1].s_addr),\r\nvl->vldb.srvtmask[1],\r\nntohl(vl->vldb.servers[2].s_addr),\r\nvl->vldb.srvtmask[2]);\r\n_debug("Vids: %08x %08x %08x",\r\nvl->vldb.vid[0],\r\nvl->vldb.vid[1],\r\nvl->vldb.vid[2]);\r\nif (vl->vldb.vidmask & AFS_VOL_VTM_RW) {\r\nvid = vl->vldb.vid[0];\r\nvoltype = AFSVL_RWVOL;\r\n} else if (vl->vldb.vidmask & AFS_VOL_VTM_RO) {\r\nvid = vl->vldb.vid[1];\r\nvoltype = AFSVL_ROVOL;\r\n} else if (vl->vldb.vidmask & AFS_VOL_VTM_BAK) {\r\nvid = vl->vldb.vid[2];\r\nvoltype = AFSVL_BACKVOL;\r\n} else {\r\nBUG();\r\nvid = 0;\r\nvoltype = 0;\r\n}\r\nret = afs_vlocation_access_vl_by_id(vl, key, vid, voltype, vldb);\r\nswitch (ret) {\r\ndefault:\r\nprintk(KERN_WARNING "kAFS:"\r\n" failed to update volume '%s' (%x) up in '%s': %d\n",\r\nvl->vldb.name, vid, vl->cell->name, ret);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\ncase 0:\r\n_leave(" = 0");\r\nreturn 0;\r\ncase -ENOMEDIUM:\r\nprintk(KERN_ERR "kAFS:"\r\n" volume '%s' (%x) does not exist '%s'\n",\r\nvl->vldb.name, vid, vl->cell->name);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\n}\r\nstatic void afs_vlocation_apply_update(struct afs_vlocation *vl,\r\nstruct afs_cache_vlocation *vldb)\r\n{\r\n_debug("Done VL Lookup: %s %02x { %08x(%x) %08x(%x) %08x(%x) }",\r\nvldb->name, vldb->vidmask,\r\nntohl(vldb->servers[0].s_addr), vldb->srvtmask[0],\r\nntohl(vldb->servers[1].s_addr), vldb->srvtmask[1],\r\nntohl(vldb->servers[2].s_addr), vldb->srvtmask[2]);\r\n_debug("Vids: %08x %08x %08x",\r\nvldb->vid[0], vldb->vid[1], vldb->vid[2]);\r\nif (strcmp(vldb->name, vl->vldb.name) != 0)\r\nprintk(KERN_NOTICE "kAFS:"\r\n" name of volume '%s' changed to '%s' on server\n",\r\nvl->vldb.name, vldb->name);\r\nvl->vldb = *vldb;\r\n#ifdef CONFIG_AFS_FSCACHE\r\nfscache_update_cookie(vl->cache);\r\n#endif\r\n}\r\nstatic int afs_vlocation_fill_in_record(struct afs_vlocation *vl,\r\nstruct key *key)\r\n{\r\nstruct afs_cache_vlocation vldb;\r\nint ret;\r\n_enter("");\r\nASSERTCMP(vl->valid, ==, 0);\r\nmemset(&vldb, 0, sizeof(vldb));\r\n#ifdef CONFIG_AFS_FSCACHE\r\nvl->cache = fscache_acquire_cookie(vl->cell->cache,\r\n&afs_vlocation_cache_index_def, vl,\r\ntrue);\r\n#endif\r\nif (vl->valid) {\r\n_debug("found in cache");\r\nret = afs_vlocation_update_record(vl, key, &vldb);\r\n} else {\r\nret = afs_vlocation_access_vl_by_name(vl, key, &vldb);\r\nif (ret < 0) {\r\nprintk("kAFS: failed to locate '%s' in cell '%s'\n",\r\nvl->vldb.name, vl->cell->name);\r\nreturn ret;\r\n}\r\n}\r\nafs_vlocation_apply_update(vl, &vldb);\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic void afs_vlocation_queue_for_updates(struct afs_vlocation *vl)\r\n{\r\nstruct afs_vlocation *xvl;\r\nvl->update_at = ktime_get_real_seconds() +\r\nafs_vlocation_update_timeout;\r\nspin_lock(&afs_vlocation_updates_lock);\r\nif (!list_empty(&afs_vlocation_updates)) {\r\nxvl = list_entry(afs_vlocation_updates.prev,\r\nstruct afs_vlocation, update);\r\nif (vl->update_at <= xvl->update_at)\r\nvl->update_at = xvl->update_at + 1;\r\n} else {\r\nqueue_delayed_work(afs_vlocation_update_worker,\r\n&afs_vlocation_update,\r\nafs_vlocation_update_timeout * HZ);\r\n}\r\nlist_add_tail(&vl->update, &afs_vlocation_updates);\r\nspin_unlock(&afs_vlocation_updates_lock);\r\n}\r\nstruct afs_vlocation *afs_vlocation_lookup(struct afs_cell *cell,\r\nstruct key *key,\r\nconst char *name,\r\nsize_t namesz)\r\n{\r\nstruct afs_vlocation *vl;\r\nint ret;\r\n_enter("{%s},{%x},%*.*s,%zu",\r\ncell->name, key_serial(key),\r\n(int) namesz, (int) namesz, name, namesz);\r\nif (namesz >= sizeof(vl->vldb.name)) {\r\n_leave(" = -ENAMETOOLONG");\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\n}\r\ndown_write(&cell->vl_sem);\r\nspin_lock(&cell->vl_lock);\r\nlist_for_each_entry(vl, &cell->vl_list, link) {\r\nif (vl->vldb.name[namesz] != '\0')\r\ncontinue;\r\nif (memcmp(vl->vldb.name, name, namesz) == 0)\r\ngoto found_in_memory;\r\n}\r\nspin_unlock(&cell->vl_lock);\r\nvl = afs_vlocation_alloc(cell, name, namesz);\r\nif (!vl) {\r\nup_write(&cell->vl_sem);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nafs_get_cell(cell);\r\nlist_add_tail(&vl->link, &cell->vl_list);\r\nvl->state = AFS_VL_CREATING;\r\nup_write(&cell->vl_sem);\r\nfill_in_record:\r\nret = afs_vlocation_fill_in_record(vl, key);\r\nif (ret < 0)\r\ngoto error_abandon;\r\nspin_lock(&vl->lock);\r\nvl->state = AFS_VL_VALID;\r\nspin_unlock(&vl->lock);\r\nwake_up(&vl->waitq);\r\n#ifdef CONFIG_AFS_FSCACHE\r\nfscache_update_cookie(vl->cache);\r\n#endif\r\nafs_vlocation_queue_for_updates(vl);\r\ngoto success;\r\nfound_in_memory:\r\n_debug("found in memory");\r\natomic_inc(&vl->usage);\r\nspin_unlock(&cell->vl_lock);\r\nif (!list_empty(&vl->grave)) {\r\nspin_lock(&afs_vlocation_graveyard_lock);\r\nlist_del_init(&vl->grave);\r\nspin_unlock(&afs_vlocation_graveyard_lock);\r\n}\r\nup_write(&cell->vl_sem);\r\nspin_lock(&vl->lock);\r\nwhile (vl->state != AFS_VL_VALID) {\r\nafs_vlocation_state_t state = vl->state;\r\n_debug("invalid [state %d]", state);\r\nif (state == AFS_VL_NEW || state == AFS_VL_NO_VOLUME) {\r\nvl->state = AFS_VL_CREATING;\r\nspin_unlock(&vl->lock);\r\ngoto fill_in_record;\r\n}\r\n_debug("wait");\r\nspin_unlock(&vl->lock);\r\nret = wait_event_interruptible(vl->waitq,\r\nvl->state == AFS_VL_NEW ||\r\nvl->state == AFS_VL_VALID ||\r\nvl->state == AFS_VL_NO_VOLUME);\r\nif (ret < 0)\r\ngoto error;\r\nspin_lock(&vl->lock);\r\n}\r\nspin_unlock(&vl->lock);\r\nsuccess:\r\n_leave(" = %p", vl);\r\nreturn vl;\r\nerror_abandon:\r\nspin_lock(&vl->lock);\r\nvl->state = AFS_VL_NEW;\r\nspin_unlock(&vl->lock);\r\nwake_up(&vl->waitq);\r\nerror:\r\nASSERT(vl != NULL);\r\nafs_put_vlocation(vl);\r\n_leave(" = %d", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid afs_put_vlocation(struct afs_vlocation *vl)\r\n{\r\nif (!vl)\r\nreturn;\r\n_enter("%s", vl->vldb.name);\r\nASSERTCMP(atomic_read(&vl->usage), >, 0);\r\nif (likely(!atomic_dec_and_test(&vl->usage))) {\r\n_leave("");\r\nreturn;\r\n}\r\nspin_lock(&afs_vlocation_graveyard_lock);\r\nif (atomic_read(&vl->usage) == 0) {\r\n_debug("buried");\r\nlist_move_tail(&vl->grave, &afs_vlocation_graveyard);\r\nvl->time_of_death = ktime_get_real_seconds();\r\nqueue_delayed_work(afs_wq, &afs_vlocation_reap,\r\nafs_vlocation_timeout * HZ);\r\nif (!list_empty(&vl->update)) {\r\nspin_lock(&afs_vlocation_updates_lock);\r\nlist_del_init(&vl->update);\r\nspin_unlock(&afs_vlocation_updates_lock);\r\n}\r\n}\r\nspin_unlock(&afs_vlocation_graveyard_lock);\r\n_leave(" [killed?]");\r\n}\r\nstatic void afs_vlocation_destroy(struct afs_vlocation *vl)\r\n{\r\n_enter("%p", vl);\r\n#ifdef CONFIG_AFS_FSCACHE\r\nfscache_relinquish_cookie(vl->cache, 0);\r\n#endif\r\nafs_put_cell(vl->cell);\r\nkfree(vl);\r\n}\r\nstatic void afs_vlocation_reaper(struct work_struct *work)\r\n{\r\nLIST_HEAD(corpses);\r\nstruct afs_vlocation *vl;\r\nunsigned long delay, expiry;\r\ntime64_t now;\r\n_enter("");\r\nnow = ktime_get_real_seconds();\r\nspin_lock(&afs_vlocation_graveyard_lock);\r\nwhile (!list_empty(&afs_vlocation_graveyard)) {\r\nvl = list_entry(afs_vlocation_graveyard.next,\r\nstruct afs_vlocation, grave);\r\n_debug("check %p", vl);\r\nexpiry = vl->time_of_death + afs_vlocation_timeout;\r\nif (expiry > now) {\r\ndelay = (expiry - now) * HZ;\r\n_debug("delay %lu", delay);\r\nmod_delayed_work(afs_wq, &afs_vlocation_reap, delay);\r\nbreak;\r\n}\r\nspin_lock(&vl->cell->vl_lock);\r\nif (atomic_read(&vl->usage) > 0) {\r\n_debug("no reap");\r\nlist_del_init(&vl->grave);\r\n} else {\r\n_debug("reap");\r\nlist_move_tail(&vl->grave, &corpses);\r\nlist_del_init(&vl->link);\r\n}\r\nspin_unlock(&vl->cell->vl_lock);\r\n}\r\nspin_unlock(&afs_vlocation_graveyard_lock);\r\nwhile (!list_empty(&corpses)) {\r\nvl = list_entry(corpses.next, struct afs_vlocation, grave);\r\nlist_del(&vl->grave);\r\nafs_vlocation_destroy(vl);\r\n}\r\n_leave("");\r\n}\r\nint __init afs_vlocation_update_init(void)\r\n{\r\nafs_vlocation_update_worker = alloc_workqueue("kafs_vlupdated",\r\nWQ_MEM_RECLAIM, 0);\r\nreturn afs_vlocation_update_worker ? 0 : -ENOMEM;\r\n}\r\nvoid afs_vlocation_purge(void)\r\n{\r\nafs_vlocation_timeout = 0;\r\nspin_lock(&afs_vlocation_updates_lock);\r\nlist_del_init(&afs_vlocation_updates);\r\nspin_unlock(&afs_vlocation_updates_lock);\r\nmod_delayed_work(afs_vlocation_update_worker, &afs_vlocation_update, 0);\r\ndestroy_workqueue(afs_vlocation_update_worker);\r\nmod_delayed_work(afs_wq, &afs_vlocation_reap, 0);\r\n}\r\nstatic void afs_vlocation_updater(struct work_struct *work)\r\n{\r\nstruct afs_cache_vlocation vldb;\r\nstruct afs_vlocation *vl, *xvl;\r\ntime64_t now;\r\nlong timeout;\r\nint ret;\r\n_enter("");\r\nnow = ktime_get_real_seconds();\r\nspin_lock(&afs_vlocation_updates_lock);\r\nfor (;;) {\r\nif (list_empty(&afs_vlocation_updates)) {\r\nspin_unlock(&afs_vlocation_updates_lock);\r\n_leave(" [nothing]");\r\nreturn;\r\n}\r\nvl = list_entry(afs_vlocation_updates.next,\r\nstruct afs_vlocation, update);\r\nif (atomic_read(&vl->usage) > 0)\r\nbreak;\r\nlist_del_init(&vl->update);\r\n}\r\ntimeout = vl->update_at - now;\r\nif (timeout > 0) {\r\nqueue_delayed_work(afs_vlocation_update_worker,\r\n&afs_vlocation_update, timeout * HZ);\r\nspin_unlock(&afs_vlocation_updates_lock);\r\n_leave(" [nothing]");\r\nreturn;\r\n}\r\nlist_del_init(&vl->update);\r\natomic_inc(&vl->usage);\r\nspin_unlock(&afs_vlocation_updates_lock);\r\n_debug("update %s", vl->vldb.name);\r\nvl->state = AFS_VL_UPDATING;\r\nvl->upd_rej_cnt = 0;\r\nvl->upd_busy_cnt = 0;\r\nret = afs_vlocation_update_record(vl, NULL, &vldb);\r\nspin_lock(&vl->lock);\r\nswitch (ret) {\r\ncase 0:\r\nafs_vlocation_apply_update(vl, &vldb);\r\nvl->state = AFS_VL_VALID;\r\nbreak;\r\ncase -ENOMEDIUM:\r\nvl->state = AFS_VL_VOLUME_DELETED;\r\nbreak;\r\ndefault:\r\nvl->state = AFS_VL_UNCERTAIN;\r\nbreak;\r\n}\r\nspin_unlock(&vl->lock);\r\nwake_up(&vl->waitq);\r\n_debug("reschedule");\r\nvl->update_at = ktime_get_real_seconds() +\r\nafs_vlocation_update_timeout;\r\nspin_lock(&afs_vlocation_updates_lock);\r\nif (!list_empty(&afs_vlocation_updates)) {\r\nxvl = list_entry(afs_vlocation_updates.prev,\r\nstruct afs_vlocation, update);\r\nif (vl->update_at <= xvl->update_at)\r\nvl->update_at = xvl->update_at + 1;\r\nxvl = list_entry(afs_vlocation_updates.next,\r\nstruct afs_vlocation, update);\r\ntimeout = xvl->update_at - now;\r\nif (timeout < 0)\r\ntimeout = 0;\r\n} else {\r\ntimeout = afs_vlocation_update_timeout;\r\n}\r\nASSERT(list_empty(&vl->update));\r\nlist_add_tail(&vl->update, &afs_vlocation_updates);\r\n_debug("timeout %ld", timeout);\r\nqueue_delayed_work(afs_vlocation_update_worker,\r\n&afs_vlocation_update, timeout * HZ);\r\nspin_unlock(&afs_vlocation_updates_lock);\r\nafs_put_vlocation(vl);\r\n}
