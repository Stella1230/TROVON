static irqreturn_t egalax_ts_interrupt(int irq, void *dev_id)\r\n{\r\nstruct egalax_ts *ts = dev_id;\r\nstruct input_dev *input_dev = ts->input_dev;\r\nstruct i2c_client *client = ts->client;\r\nu8 buf[MAX_I2C_DATA_LEN];\r\nint id, ret, x, y, z;\r\nint tries = 0;\r\nbool down, valid;\r\nu8 state;\r\ndo {\r\nret = i2c_master_recv(client, buf, MAX_I2C_DATA_LEN);\r\n} while (ret == -EAGAIN && tries++ < EGALAX_MAX_TRIES);\r\nif (ret < 0)\r\nreturn IRQ_HANDLED;\r\nif (buf[0] != REPORT_MODE_MTTOUCH) {\r\nreturn IRQ_HANDLED;\r\n}\r\nstate = buf[1];\r\nx = (buf[3] << 8) | buf[2];\r\ny = (buf[5] << 8) | buf[4];\r\nz = (buf[7] << 8) | buf[6];\r\nvalid = state & EVENT_VALID_MASK;\r\nid = (state & EVENT_ID_MASK) >> EVENT_ID_OFFSET;\r\ndown = state & EVENT_DOWN_UP;\r\nif (!valid || id > MAX_SUPPORT_POINTS) {\r\ndev_dbg(&client->dev, "point invalid\n");\r\nreturn IRQ_HANDLED;\r\n}\r\ninput_mt_slot(input_dev, id);\r\ninput_mt_report_slot_state(input_dev, MT_TOOL_FINGER, down);\r\ndev_dbg(&client->dev, "%s id:%d x:%d y:%d z:%d",\r\ndown ? "down" : "up", id, x, y, z);\r\nif (down) {\r\ninput_report_abs(input_dev, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input_dev, ABS_MT_POSITION_Y, y);\r\ninput_report_abs(input_dev, ABS_MT_PRESSURE, z);\r\n}\r\ninput_mt_report_pointer_emulation(input_dev, true);\r\ninput_sync(input_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int egalax_wake_up_device(struct i2c_client *client)\r\n{\r\nstruct device_node *np = client->dev.of_node;\r\nint gpio;\r\nint ret;\r\nif (!np)\r\nreturn -ENODEV;\r\ngpio = of_get_named_gpio(np, "wakeup-gpios", 0);\r\nif (!gpio_is_valid(gpio))\r\nreturn -ENODEV;\r\nret = gpio_request(gpio, "egalax_irq");\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"request gpio failed, cannot wake up controller: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ngpio_direction_output(gpio, 0);\r\ngpio_set_value(gpio, 1);\r\ngpio_direction_input(gpio);\r\ngpio_free(gpio);\r\nreturn 0;\r\n}\r\nstatic int egalax_firmware_version(struct i2c_client *client)\r\n{\r\nstatic const u8 cmd[MAX_I2C_DATA_LEN] = { 0x03, 0x03, 0xa, 0x01, 0x41 };\r\nint ret;\r\nret = i2c_master_send(client, cmd, MAX_I2C_DATA_LEN);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int egalax_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct egalax_ts *ts;\r\nstruct input_dev *input_dev;\r\nint error;\r\nts = devm_kzalloc(&client->dev, sizeof(struct egalax_ts), GFP_KERNEL);\r\nif (!ts) {\r\ndev_err(&client->dev, "Failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\ninput_dev = devm_input_allocate_device(&client->dev);\r\nif (!input_dev) {\r\ndev_err(&client->dev, "Failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nts->client = client;\r\nts->input_dev = input_dev;\r\nerror = egalax_wake_up_device(client);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to wake up the controller\n");\r\nreturn error;\r\n}\r\nerror = egalax_firmware_version(client);\r\nif (error < 0) {\r\ndev_err(&client->dev, "Failed to read firmware version\n");\r\nreturn error;\r\n}\r\ninput_dev->name = "EETI eGalax Touch Screen";\r\ninput_dev->id.bustype = BUS_I2C;\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_X, 0, EGALAX_MAX_X, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, EGALAX_MAX_Y, 0, 0);\r\ninput_set_abs_params(input_dev,\r\nABS_MT_POSITION_X, 0, EGALAX_MAX_X, 0, 0);\r\ninput_set_abs_params(input_dev,\r\nABS_MT_POSITION_Y, 0, EGALAX_MAX_Y, 0, 0);\r\ninput_mt_init_slots(input_dev, MAX_SUPPORT_POINTS, 0);\r\nerror = devm_request_threaded_irq(&client->dev, client->irq, NULL,\r\negalax_ts_interrupt,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"egalax_ts", ts);\r\nif (error < 0) {\r\ndev_err(&client->dev, "Failed to register interrupt\n");\r\nreturn error;\r\n}\r\nerror = input_register_device(ts->input_dev);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused egalax_ts_suspend(struct device *dev)\r\n{\r\nstatic const u8 suspend_cmd[MAX_I2C_DATA_LEN] = {\r\n0x3, 0x6, 0xa, 0x3, 0x36, 0x3f, 0x2, 0, 0, 0\r\n};\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint ret;\r\nret = i2c_master_send(client, suspend_cmd, MAX_I2C_DATA_LEN);\r\nreturn ret > 0 ? 0 : ret;\r\n}\r\nstatic int __maybe_unused egalax_ts_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nreturn egalax_wake_up_device(client);\r\n}
