static int hi655x_is_enabled(struct regulator_dev *rdev)\r\n{\r\nunsigned int value = 0;\r\nstruct hi655x_regulator *regulator = rdev_get_drvdata(rdev);\r\nregmap_read(rdev->regmap, regulator->status_reg, &value);\r\nreturn (value & BIT(regulator->ctrl_mask));\r\n}\r\nstatic int hi655x_disable(struct regulator_dev *rdev)\r\n{\r\nint ret = 0;\r\nstruct hi655x_regulator *regulator = rdev_get_drvdata(rdev);\r\nret = regmap_write(rdev->regmap, regulator->disable_reg,\r\nBIT(regulator->ctrl_mask));\r\nreturn ret;\r\n}\r\nstatic int hi655x_regulator_probe(struct platform_device *pdev)\r\n{\r\nunsigned int i;\r\nstruct hi655x_regulator *regulator;\r\nstruct hi655x_pmic *pmic;\r\nstruct regulator_config config = { };\r\nstruct regulator_dev *rdev;\r\npmic = dev_get_drvdata(pdev->dev.parent);\r\nif (!pmic) {\r\ndev_err(&pdev->dev, "no pmic in the regulator parent node\n");\r\nreturn -ENODEV;\r\n}\r\nregulator = devm_kzalloc(&pdev->dev, sizeof(*regulator), GFP_KERNEL);\r\nif (!regulator)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, regulator);\r\nconfig.dev = pdev->dev.parent;\r\nconfig.regmap = pmic->regmap;\r\nconfig.driver_data = regulator;\r\nfor (i = 0; i < ARRAY_SIZE(regulators); i++) {\r\nrdev = devm_regulator_register(&pdev->dev,\r\n&regulators[i].rdesc,\r\n&config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "failed to register regulator %s\n",\r\nregulator->rdesc.name);\r\nreturn PTR_ERR(rdev);\r\n}\r\n}\r\nreturn 0;\r\n}
