static void stb6000_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\n}\r\nstatic int stb6000_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct stb6000_priv *priv = fe->tuner_priv;\r\nint ret;\r\nu8 buf[] = { 10, 0 };\r\nstruct i2c_msg msg = {\r\n.addr = priv->i2c_address,\r\n.flags = 0,\r\n.buf = buf,\r\n.len = 2\r\n};\r\ndprintk("%s:\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = i2c_transfer(priv->i2c, &msg, 1);\r\nif (ret != 1)\r\ndprintk("%s: i2c error\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn (ret == 1) ? 0 : ret;\r\n}\r\nstatic int stb6000_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct stb6000_priv *priv = fe->tuner_priv;\r\nunsigned int n, m;\r\nint ret;\r\nu32 freq_mhz;\r\nint bandwidth;\r\nu8 buf[12];\r\nstruct i2c_msg msg = {\r\n.addr = priv->i2c_address,\r\n.flags = 0,\r\n.buf = buf,\r\n.len = 12\r\n};\r\ndprintk("%s:\n", __func__);\r\nfreq_mhz = p->frequency / 1000;\r\nbandwidth = p->symbol_rate / 1000000;\r\nif (bandwidth > 31)\r\nbandwidth = 31;\r\nif ((freq_mhz > 949) && (freq_mhz < 2151)) {\r\nbuf[0] = 0x01;\r\nbuf[1] = 0xac;\r\nif (freq_mhz < 1950)\r\nbuf[1] = 0xaa;\r\nif (freq_mhz < 1800)\r\nbuf[1] = 0xa8;\r\nif (freq_mhz < 1650)\r\nbuf[1] = 0xa6;\r\nif (freq_mhz < 1530)\r\nbuf[1] = 0xa5;\r\nif (freq_mhz < 1470)\r\nbuf[1] = 0xa4;\r\nif (freq_mhz < 1370)\r\nbuf[1] = 0xa2;\r\nif (freq_mhz < 1300)\r\nbuf[1] = 0xa1;\r\nif (freq_mhz < 1200)\r\nbuf[1] = 0xa0;\r\nif (freq_mhz < 1075)\r\nbuf[1] = 0xbc;\r\nif (freq_mhz < 1000)\r\nbuf[1] = 0xba;\r\nif (freq_mhz < 1075) {\r\nn = freq_mhz / 8;\r\nm = 2;\r\n} else {\r\nn = freq_mhz / 16;\r\nm = 1;\r\n}\r\nbuf[2] = n >> 1;\r\nbuf[3] = (unsigned char)(((n & 1) << 7) |\r\n(m * freq_mhz - n * 16) | 0x60);\r\nbuf[4] = 0x04;\r\nbuf[5] = 0x0e;\r\nbuf[6] = (unsigned char)(bandwidth);\r\nbuf[7] = 0xd8;\r\nbuf[8] = 0xd0;\r\nbuf[9] = 0x50;\r\nbuf[10] = 0xeb;\r\nbuf[11] = 0x4f;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = i2c_transfer(priv->i2c, &msg, 1);\r\nif (ret != 1)\r\ndprintk("%s: i2c error\n", __func__);\r\nudelay(10);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nbuf[0] = 0x07;\r\nbuf[1] = 0xdf;\r\nbuf[2] = 0xd0;\r\nbuf[3] = 0x50;\r\nbuf[4] = 0xfb;\r\nmsg.len = 5;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = i2c_transfer(priv->i2c, &msg, 1);\r\nif (ret != 1)\r\ndprintk("%s: i2c error\n", __func__);\r\nudelay(10);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\npriv->frequency = freq_mhz * 1000;\r\nreturn (ret == 1) ? 0 : ret;\r\n}\r\nreturn -1;\r\n}\r\nstatic int stb6000_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct stb6000_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *stb6000_attach(struct dvb_frontend *fe, int addr,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct stb6000_priv *priv = NULL;\r\nu8 b0[] = { 0 };\r\nu8 b1[] = { 0, 0 };\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = addr,\r\n.flags = 0,\r\n.buf = b0,\r\n.len = 0\r\n}, {\r\n.addr = addr,\r\n.flags = I2C_M_RD,\r\n.buf = b1,\r\n.len = 2\r\n}\r\n};\r\nint ret;\r\ndprintk("%s:\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = i2c_transfer(i2c, msg, 2);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (ret != 2)\r\nreturn NULL;\r\npriv = kzalloc(sizeof(struct stb6000_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->i2c_address = addr;\r\npriv->i2c = i2c;\r\nmemcpy(&fe->ops.tuner_ops, &stb6000_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = priv;\r\nreturn fe;\r\n}
