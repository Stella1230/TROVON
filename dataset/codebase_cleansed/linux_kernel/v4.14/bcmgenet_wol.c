void bcmgenet_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct bcmgenet_priv *priv = netdev_priv(dev);\r\nu32 reg;\r\nwol->supported = WAKE_MAGIC | WAKE_MAGICSECURE;\r\nwol->wolopts = priv->wolopts;\r\nmemset(wol->sopass, 0, sizeof(wol->sopass));\r\nif (wol->wolopts & WAKE_MAGICSECURE) {\r\nreg = bcmgenet_umac_readl(priv, UMAC_MPD_PW_MS);\r\nput_unaligned_be16(reg, &wol->sopass[0]);\r\nreg = bcmgenet_umac_readl(priv, UMAC_MPD_PW_LS);\r\nput_unaligned_be32(reg, &wol->sopass[2]);\r\n}\r\n}\r\nint bcmgenet_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct bcmgenet_priv *priv = netdev_priv(dev);\r\nstruct device *kdev = &priv->pdev->dev;\r\nu32 reg;\r\nif (!device_can_wakeup(kdev))\r\nreturn -ENOTSUPP;\r\nif (wol->wolopts & ~(WAKE_MAGIC | WAKE_MAGICSECURE))\r\nreturn -EINVAL;\r\nreg = bcmgenet_umac_readl(priv, UMAC_MPD_CTRL);\r\nif (wol->wolopts & WAKE_MAGICSECURE) {\r\nbcmgenet_umac_writel(priv, get_unaligned_be16(&wol->sopass[0]),\r\nUMAC_MPD_PW_MS);\r\nbcmgenet_umac_writel(priv, get_unaligned_be32(&wol->sopass[2]),\r\nUMAC_MPD_PW_LS);\r\nreg |= MPD_PW_EN;\r\n} else {\r\nreg &= ~MPD_PW_EN;\r\n}\r\nbcmgenet_umac_writel(priv, reg, UMAC_MPD_CTRL);\r\nif (wol->wolopts) {\r\ndevice_set_wakeup_enable(kdev, 1);\r\nif (priv->wol_irq_disabled)\r\nenable_irq_wake(priv->wol_irq);\r\npriv->wol_irq_disabled = false;\r\n} else {\r\ndevice_set_wakeup_enable(kdev, 0);\r\nif (!priv->wol_irq_disabled)\r\ndisable_irq_wake(priv->wol_irq);\r\npriv->wol_irq_disabled = true;\r\n}\r\npriv->wolopts = wol->wolopts;\r\nreturn 0;\r\n}\r\nstatic int bcmgenet_poll_wol_status(struct bcmgenet_priv *priv)\r\n{\r\nstruct net_device *dev = priv->dev;\r\nint retries = 0;\r\nwhile (!(bcmgenet_rbuf_readl(priv, RBUF_STATUS)\r\n& RBUF_STATUS_WOL)) {\r\nretries++;\r\nif (retries > 5) {\r\nnetdev_crit(dev, "polling wol mode timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmdelay(1);\r\n}\r\nreturn retries;\r\n}\r\nint bcmgenet_wol_power_down_cfg(struct bcmgenet_priv *priv,\r\nenum bcmgenet_power_mode mode)\r\n{\r\nstruct net_device *dev = priv->dev;\r\nint retries = 0;\r\nu32 reg;\r\nif (mode != GENET_POWER_WOL_MAGIC) {\r\nnetif_err(priv, wol, dev, "unsupported mode: %d\n", mode);\r\nreturn -EINVAL;\r\n}\r\nreg = bcmgenet_umac_readl(priv, UMAC_CMD);\r\nreg &= ~CMD_RX_EN;\r\nbcmgenet_umac_writel(priv, reg, UMAC_CMD);\r\nmdelay(10);\r\nreg = bcmgenet_umac_readl(priv, UMAC_MPD_CTRL);\r\nreg |= MPD_EN;\r\nbcmgenet_umac_writel(priv, reg, UMAC_MPD_CTRL);\r\nretries = bcmgenet_poll_wol_status(priv);\r\nif (retries < 0) {\r\nreg = bcmgenet_umac_readl(priv, UMAC_MPD_CTRL);\r\nreg &= ~MPD_EN;\r\nbcmgenet_umac_writel(priv, reg, UMAC_MPD_CTRL);\r\nreturn retries;\r\n}\r\nnetif_dbg(priv, wol, dev, "MPD WOL-ready status set after %d msec\n",\r\nretries);\r\nreg = bcmgenet_umac_readl(priv, UMAC_CMD);\r\npriv->crc_fwd_en = 1;\r\nreg |= CMD_CRC_FWD;\r\nreg |= CMD_RX_EN;\r\nbcmgenet_umac_writel(priv, reg, UMAC_CMD);\r\nif (priv->hw_params->flags & GENET_HAS_EXT) {\r\nreg = bcmgenet_ext_readl(priv, EXT_EXT_PWR_MGMT);\r\nreg &= ~EXT_ENERGY_DET_MASK;\r\nbcmgenet_ext_writel(priv, reg, EXT_EXT_PWR_MGMT);\r\n}\r\nreturn 0;\r\n}\r\nvoid bcmgenet_wol_power_up_cfg(struct bcmgenet_priv *priv,\r\nenum bcmgenet_power_mode mode)\r\n{\r\nu32 reg;\r\nif (mode != GENET_POWER_WOL_MAGIC) {\r\nnetif_err(priv, wol, priv->dev, "invalid mode: %d\n", mode);\r\nreturn;\r\n}\r\nreg = bcmgenet_umac_readl(priv, UMAC_MPD_CTRL);\r\nreg &= ~MPD_EN;\r\nbcmgenet_umac_writel(priv, reg, UMAC_MPD_CTRL);\r\nreg = bcmgenet_umac_readl(priv, UMAC_CMD);\r\nreg &= ~CMD_CRC_FWD;\r\nbcmgenet_umac_writel(priv, reg, UMAC_CMD);\r\npriv->crc_fwd_en = 0;\r\n}
