static inline int qlcnic_82xx_statistics(struct qlcnic_adapter *adapter)\r\n{\r\nreturn ARRAY_SIZE(qlcnic_gstrings_stats) +\r\nARRAY_SIZE(qlcnic_83xx_mac_stats_strings) +\r\nQLCNIC_TX_STATS_LEN * adapter->drv_tx_rings;\r\n}\r\nstatic inline int qlcnic_83xx_statistics(struct qlcnic_adapter *adapter)\r\n{\r\nreturn ARRAY_SIZE(qlcnic_gstrings_stats) +\r\nARRAY_SIZE(qlcnic_83xx_tx_stats_strings) +\r\nARRAY_SIZE(qlcnic_83xx_mac_stats_strings) +\r\nARRAY_SIZE(qlcnic_83xx_rx_stats_strings) +\r\nQLCNIC_TX_STATS_LEN * adapter->drv_tx_rings;\r\n}\r\nstatic int qlcnic_dev_statistics_len(struct qlcnic_adapter *adapter)\r\n{\r\nint len = -1;\r\nif (qlcnic_82xx_check(adapter)) {\r\nlen = qlcnic_82xx_statistics(adapter);\r\nif (adapter->flags & QLCNIC_ESWITCH_ENABLED)\r\nlen += ARRAY_SIZE(qlcnic_device_gstrings_stats);\r\n} else if (qlcnic_83xx_check(adapter)) {\r\nlen = qlcnic_83xx_statistics(adapter);\r\n}\r\nreturn len;\r\n}\r\nstatic inline int qlcnic_get_ring_regs_len(struct qlcnic_adapter *adapter)\r\n{\r\nint ring_regs_cnt = (adapter->drv_tx_rings * 5) +\r\n(adapter->max_rds_rings * 2) +\r\n(adapter->drv_sds_rings * 3) + 5;\r\nreturn ring_regs_cnt * sizeof(u32);\r\n}\r\nstatic int qlcnic_get_regs_len(struct net_device *dev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nu32 len;\r\nif (qlcnic_83xx_check(adapter))\r\nlen = qlcnic_83xx_get_regs_len(adapter);\r\nelse\r\nlen = sizeof(ext_diag_registers) + sizeof(diag_registers);\r\nlen += ((QLCNIC_DEV_INFO_SIZE + 2) * sizeof(u32));\r\nlen += qlcnic_get_ring_regs_len(adapter);\r\nreturn len;\r\n}\r\nstatic int qlcnic_get_eeprom_len(struct net_device *dev)\r\n{\r\nreturn QLCNIC_FLASH_TOTAL_SIZE;\r\n}\r\nstatic void\r\nqlcnic_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nu32 fw_major, fw_minor, fw_build;\r\nfw_major = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MAJOR);\r\nfw_minor = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MINOR);\r\nfw_build = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_SUB);\r\nsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\r\n"%d.%d.%d", fw_major, fw_minor, fw_build);\r\nstrlcpy(drvinfo->bus_info, pci_name(adapter->pdev),\r\nsizeof(drvinfo->bus_info));\r\nstrlcpy(drvinfo->driver, qlcnic_driver_name, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, QLCNIC_LINUX_VERSIONID,\r\nsizeof(drvinfo->version));\r\n}\r\nstatic int qlcnic_82xx_get_link_ksettings(struct qlcnic_adapter *adapter,\r\nstruct ethtool_link_ksettings *ecmd)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nu32 speed, reg;\r\nint check_sfp_module = 0, err = 0;\r\nu16 pcifn = ahw->pci_func;\r\nu32 supported, advertising;\r\nif (adapter->ahw->port_type == QLCNIC_GBE) {\r\nsupported = (SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_1000baseT_Half |\r\nSUPPORTED_1000baseT_Full);\r\nadvertising = (ADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_1000baseT_Half |\r\nADVERTISED_1000baseT_Full);\r\necmd->base.speed = adapter->ahw->link_speed;\r\necmd->base.duplex = adapter->ahw->link_duplex;\r\necmd->base.autoneg = adapter->ahw->link_autoneg;\r\n} else if (adapter->ahw->port_type == QLCNIC_XGBE) {\r\nu32 val = 0;\r\nval = QLCRD32(adapter, QLCNIC_PORT_MODE_ADDR, &err);\r\nif (val == QLCNIC_PORT_MODE_802_3_AP) {\r\nsupported = SUPPORTED_1000baseT_Full;\r\nadvertising = ADVERTISED_1000baseT_Full;\r\n} else {\r\nsupported = SUPPORTED_10000baseT_Full;\r\nadvertising = ADVERTISED_10000baseT_Full;\r\n}\r\nif (netif_running(adapter->netdev) && ahw->has_link_events) {\r\nif (ahw->linkup) {\r\nreg = QLCRD32(adapter,\r\nP3P_LINK_SPEED_REG(pcifn), &err);\r\nspeed = P3P_LINK_SPEED_VAL(pcifn, reg);\r\nahw->link_speed = speed * P3P_LINK_SPEED_MHZ;\r\n}\r\necmd->base.speed = ahw->link_speed;\r\necmd->base.autoneg = ahw->link_autoneg;\r\necmd->base.duplex = ahw->link_duplex;\r\ngoto skip;\r\n}\r\necmd->base.speed = SPEED_UNKNOWN;\r\necmd->base.duplex = DUPLEX_UNKNOWN;\r\necmd->base.autoneg = AUTONEG_DISABLE;\r\n} else\r\nreturn -EIO;\r\nskip:\r\necmd->base.phy_address = adapter->ahw->physical_port;\r\nswitch (adapter->ahw->board_type) {\r\ncase QLCNIC_BRDTYPE_P3P_REF_QG:\r\ncase QLCNIC_BRDTYPE_P3P_4_GB:\r\ncase QLCNIC_BRDTYPE_P3P_4_GB_MM:\r\nsupported |= SUPPORTED_Autoneg;\r\nadvertising |= ADVERTISED_Autoneg;\r\ncase QLCNIC_BRDTYPE_P3P_10G_CX4:\r\ncase QLCNIC_BRDTYPE_P3P_10G_CX4_LP:\r\ncase QLCNIC_BRDTYPE_P3P_10000_BASE_T:\r\nsupported |= SUPPORTED_TP;\r\nadvertising |= ADVERTISED_TP;\r\necmd->base.port = PORT_TP;\r\necmd->base.autoneg = adapter->ahw->link_autoneg;\r\nbreak;\r\ncase QLCNIC_BRDTYPE_P3P_IMEZ:\r\ncase QLCNIC_BRDTYPE_P3P_XG_LOM:\r\ncase QLCNIC_BRDTYPE_P3P_HMEZ:\r\nsupported |= SUPPORTED_MII;\r\nadvertising |= ADVERTISED_MII;\r\necmd->base.port = PORT_MII;\r\necmd->base.autoneg = AUTONEG_DISABLE;\r\nbreak;\r\ncase QLCNIC_BRDTYPE_P3P_10G_SFP_PLUS:\r\ncase QLCNIC_BRDTYPE_P3P_10G_SFP_CT:\r\ncase QLCNIC_BRDTYPE_P3P_10G_SFP_QT:\r\nadvertising |= ADVERTISED_TP;\r\nsupported |= SUPPORTED_TP;\r\ncheck_sfp_module = netif_running(adapter->netdev) &&\r\nahw->has_link_events;\r\ncase QLCNIC_BRDTYPE_P3P_10G_XFP:\r\nsupported |= SUPPORTED_FIBRE;\r\nadvertising |= ADVERTISED_FIBRE;\r\necmd->base.port = PORT_FIBRE;\r\necmd->base.autoneg = AUTONEG_DISABLE;\r\nbreak;\r\ncase QLCNIC_BRDTYPE_P3P_10G_TP:\r\nif (adapter->ahw->port_type == QLCNIC_XGBE) {\r\necmd->base.autoneg = AUTONEG_DISABLE;\r\nsupported |= (SUPPORTED_FIBRE | SUPPORTED_TP);\r\nadvertising |=\r\n(ADVERTISED_FIBRE | ADVERTISED_TP);\r\necmd->base.port = PORT_FIBRE;\r\ncheck_sfp_module = netif_running(adapter->netdev) &&\r\nahw->has_link_events;\r\n} else {\r\necmd->base.autoneg = AUTONEG_ENABLE;\r\nsupported |= (SUPPORTED_TP | SUPPORTED_Autoneg);\r\nadvertising |=\r\n(ADVERTISED_TP | ADVERTISED_Autoneg);\r\necmd->base.port = PORT_TP;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&adapter->pdev->dev, "Unsupported board model %d\n",\r\nadapter->ahw->board_type);\r\nreturn -EIO;\r\n}\r\nif (check_sfp_module) {\r\nswitch (adapter->ahw->module_type) {\r\ncase LINKEVENT_MODULE_OPTICAL_UNKNOWN:\r\ncase LINKEVENT_MODULE_OPTICAL_SRLR:\r\ncase LINKEVENT_MODULE_OPTICAL_LRM:\r\ncase LINKEVENT_MODULE_OPTICAL_SFP_1G:\r\necmd->base.port = PORT_FIBRE;\r\nbreak;\r\ncase LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLE:\r\ncase LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLELEN:\r\ncase LINKEVENT_MODULE_TWINAX:\r\necmd->base.port = PORT_TP;\r\nbreak;\r\ndefault:\r\necmd->base.port = PORT_OTHER;\r\n}\r\n}\r\nethtool_convert_legacy_u32_to_link_mode(ecmd->link_modes.supported,\r\nsupported);\r\nethtool_convert_legacy_u32_to_link_mode(ecmd->link_modes.advertising,\r\nadvertising);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_get_link_ksettings(struct net_device *dev,\r\nstruct ethtool_link_ksettings *ecmd)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nif (qlcnic_82xx_check(adapter))\r\nreturn qlcnic_82xx_get_link_ksettings(adapter, ecmd);\r\nelse if (qlcnic_83xx_check(adapter))\r\nreturn qlcnic_83xx_get_link_ksettings(adapter, ecmd);\r\nreturn -EIO;\r\n}\r\nstatic int qlcnic_set_port_config(struct qlcnic_adapter *adapter,\r\nconst struct ethtool_link_ksettings *ecmd)\r\n{\r\nu32 ret = 0, config = 0;\r\nif (ecmd->base.duplex)\r\nconfig |= 0x1;\r\nif (ecmd->base.autoneg)\r\nconfig |= 0x2;\r\nswitch (ecmd->base.speed) {\r\ncase SPEED_10:\r\nconfig |= (0 << 8);\r\nbreak;\r\ncase SPEED_100:\r\nconfig |= (1 << 8);\r\nbreak;\r\ncase SPEED_1000:\r\nconfig |= (10 << 8);\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\nret = qlcnic_fw_cmd_set_port(adapter, config);\r\nif (ret == QLCNIC_RCODE_NOT_SUPPORTED)\r\nreturn -EOPNOTSUPP;\r\nelse if (ret)\r\nreturn -EIO;\r\nreturn ret;\r\n}\r\nstatic int qlcnic_set_link_ksettings(struct net_device *dev,\r\nconst struct ethtool_link_ksettings *ecmd)\r\n{\r\nu32 ret = 0;\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nif (qlcnic_83xx_check(adapter))\r\nqlcnic_83xx_get_port_type(adapter);\r\nif (adapter->ahw->port_type != QLCNIC_GBE)\r\nreturn -EOPNOTSUPP;\r\nif (qlcnic_83xx_check(adapter))\r\nret = qlcnic_83xx_set_link_ksettings(adapter, ecmd);\r\nelse\r\nret = qlcnic_set_port_config(adapter, ecmd);\r\nif (!ret)\r\nreturn ret;\r\nadapter->ahw->link_speed = ecmd->base.speed;\r\nadapter->ahw->link_duplex = ecmd->base.duplex;\r\nadapter->ahw->link_autoneg = ecmd->base.autoneg;\r\nif (!netif_running(dev))\r\nreturn 0;\r\ndev->netdev_ops->ndo_stop(dev);\r\nreturn dev->netdev_ops->ndo_open(dev);\r\n}\r\nstatic int qlcnic_82xx_get_registers(struct qlcnic_adapter *adapter,\r\nu32 *regs_buff)\r\n{\r\nint i, j = 0, err = 0;\r\nfor (i = QLCNIC_DEV_INFO_SIZE + 1; diag_registers[j] != -1; j++, i++)\r\nregs_buff[i] = QLC_SHARED_REG_RD32(adapter, diag_registers[j]);\r\nj = 0;\r\nwhile (ext_diag_registers[j] != -1)\r\nregs_buff[i++] = QLCRD32(adapter, ext_diag_registers[j++],\r\n&err);\r\nreturn i;\r\n}\r\nstatic void\r\nqlcnic_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *p)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_host_rds_ring *rds_rings;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\nu32 *regs_buff = p;\r\nint ring, i = 0;\r\nmemset(p, 0, qlcnic_get_regs_len(dev));\r\nregs->version = (QLCNIC_ETHTOOL_REGS_VER << 24) |\r\n(adapter->ahw->revision_id << 16) | (adapter->pdev)->device;\r\nregs_buff[0] = (0xcafe0000 | (QLCNIC_DEV_INFO_SIZE & 0xffff));\r\nregs_buff[1] = QLCNIC_MGMT_API_VERSION;\r\nif (adapter->ahw->capabilities & QLC_83XX_ESWITCH_CAPABILITY)\r\nregs_buff[2] = adapter->ahw->max_vnic_func;\r\nif (qlcnic_82xx_check(adapter))\r\ni = qlcnic_82xx_get_registers(adapter, regs_buff);\r\nelse\r\ni = qlcnic_83xx_get_registers(adapter, regs_buff);\r\nif (!test_bit(__QLCNIC_DEV_UP, &adapter->state))\r\nreturn;\r\nregs_buff[i++] = 0xFFEFCDAB;\r\nregs_buff[i++] = adapter->drv_tx_rings;\r\nfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\r\ntx_ring = &adapter->tx_ring[ring];\r\nregs_buff[i++] = le32_to_cpu(*(tx_ring->hw_consumer));\r\nregs_buff[i++] = tx_ring->sw_consumer;\r\nregs_buff[i++] = readl(tx_ring->crb_cmd_producer);\r\nregs_buff[i++] = tx_ring->producer;\r\nif (tx_ring->crb_intr_mask)\r\nregs_buff[i++] = readl(tx_ring->crb_intr_mask);\r\nelse\r\nregs_buff[i++] = QLCNIC_TX_INTR_NOT_CONFIGURED;\r\n}\r\nregs_buff[i++] = adapter->max_rds_rings;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_rings = &recv_ctx->rds_rings[ring];\r\nregs_buff[i++] = readl(rds_rings->crb_rcv_producer);\r\nregs_buff[i++] = rds_rings->producer;\r\n}\r\nregs_buff[i++] = adapter->drv_sds_rings;\r\nfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\r\nsds_ring = &(recv_ctx->sds_rings[ring]);\r\nregs_buff[i++] = readl(sds_ring->crb_sts_consumer);\r\nregs_buff[i++] = sds_ring->consumer;\r\nregs_buff[i++] = readl(sds_ring->crb_intr_mask);\r\n}\r\n}\r\nstatic u32 qlcnic_test_link(struct net_device *dev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nint err = 0;\r\nu32 val;\r\nif (qlcnic_83xx_check(adapter)) {\r\nval = qlcnic_83xx_test_link(adapter);\r\nreturn (val & 1) ? 0 : 1;\r\n}\r\nval = QLCRD32(adapter, CRB_XG_STATE_P3P, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nval = XG_LINK_STATE_P3P(adapter->ahw->pci_func, val);\r\nreturn (val == XG_LINK_UP_P3P) ? 0 : 1;\r\n}\r\nstatic int\r\nqlcnic_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\r\nu8 *bytes)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nint offset;\r\nint ret = -1;\r\nif (qlcnic_83xx_check(adapter))\r\nreturn 0;\r\nif (eeprom->len == 0)\r\nreturn -EINVAL;\r\neeprom->magic = (adapter->pdev)->vendor |\r\n((adapter->pdev)->device << 16);\r\noffset = eeprom->offset;\r\nif (qlcnic_82xx_check(adapter))\r\nret = qlcnic_rom_fast_read_words(adapter, offset, bytes,\r\neeprom->len);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void\r\nqlcnic_get_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nring->rx_pending = adapter->num_rxd;\r\nring->rx_jumbo_pending = adapter->num_jumbo_rxd;\r\nring->tx_pending = adapter->num_txd;\r\nring->rx_max_pending = adapter->max_rxd;\r\nring->rx_jumbo_max_pending = adapter->max_jumbo_rxd;\r\nring->tx_max_pending = MAX_CMD_DESCRIPTORS;\r\n}\r\nstatic u32\r\nqlcnic_validate_ringparam(u32 val, u32 min, u32 max, char *r_name)\r\n{\r\nu32 num_desc;\r\nnum_desc = max(val, min);\r\nnum_desc = min(num_desc, max);\r\nnum_desc = roundup_pow_of_two(num_desc);\r\nif (val != num_desc) {\r\nprintk(KERN_INFO "%s: setting %s ring size %d instead of %d\n",\r\nqlcnic_driver_name, r_name, num_desc, val);\r\n}\r\nreturn num_desc;\r\n}\r\nstatic int\r\nqlcnic_set_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nu16 num_rxd, num_jumbo_rxd, num_txd;\r\nif (ring->rx_mini_pending)\r\nreturn -EOPNOTSUPP;\r\nnum_rxd = qlcnic_validate_ringparam(ring->rx_pending,\r\nMIN_RCV_DESCRIPTORS, adapter->max_rxd, "rx");\r\nnum_jumbo_rxd = qlcnic_validate_ringparam(ring->rx_jumbo_pending,\r\nMIN_JUMBO_DESCRIPTORS, adapter->max_jumbo_rxd,\r\n"rx jumbo");\r\nnum_txd = qlcnic_validate_ringparam(ring->tx_pending,\r\nMIN_CMD_DESCRIPTORS, MAX_CMD_DESCRIPTORS, "tx");\r\nif (num_rxd == adapter->num_rxd && num_txd == adapter->num_txd &&\r\nnum_jumbo_rxd == adapter->num_jumbo_rxd)\r\nreturn 0;\r\nadapter->num_rxd = num_rxd;\r\nadapter->num_jumbo_rxd = num_jumbo_rxd;\r\nadapter->num_txd = num_txd;\r\nreturn qlcnic_reset_context(adapter);\r\n}\r\nstatic int qlcnic_validate_ring_count(struct qlcnic_adapter *adapter,\r\nu8 rx_ring, u8 tx_ring)\r\n{\r\nif (rx_ring == 0 || tx_ring == 0)\r\nreturn -EINVAL;\r\nif (rx_ring != 0) {\r\nif (rx_ring > adapter->max_sds_rings) {\r\nnetdev_err(adapter->netdev,\r\n"Invalid ring count, SDS ring count %d should not be greater than max %d driver sds rings.\n",\r\nrx_ring, adapter->max_sds_rings);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (tx_ring != 0) {\r\nif (tx_ring > adapter->max_tx_rings) {\r\nnetdev_err(adapter->netdev,\r\n"Invalid ring count, Tx ring count %d should not be greater than max %d driver Tx rings.\n",\r\ntx_ring, adapter->max_tx_rings);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void qlcnic_get_channels(struct net_device *dev,\r\nstruct ethtool_channels *channel)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nchannel->max_rx = adapter->max_sds_rings;\r\nchannel->max_tx = adapter->max_tx_rings;\r\nchannel->rx_count = adapter->drv_sds_rings;\r\nchannel->tx_count = adapter->drv_tx_rings;\r\n}\r\nstatic int qlcnic_set_channels(struct net_device *dev,\r\nstruct ethtool_channels *channel)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nint err;\r\nif (!(adapter->flags & QLCNIC_MSIX_ENABLED)) {\r\nnetdev_err(dev, "No RSS/TSS support in non MSI-X mode\n");\r\nreturn -EINVAL;\r\n}\r\nif (channel->other_count || channel->combined_count)\r\nreturn -EINVAL;\r\nerr = qlcnic_validate_ring_count(adapter, channel->rx_count,\r\nchannel->tx_count);\r\nif (err)\r\nreturn err;\r\nif (adapter->drv_sds_rings != channel->rx_count) {\r\nerr = qlcnic_validate_rings(adapter, channel->rx_count,\r\nQLCNIC_RX_QUEUE);\r\nif (err) {\r\nnetdev_err(dev, "Unable to configure %u SDS rings\n",\r\nchannel->rx_count);\r\nreturn err;\r\n}\r\nadapter->drv_rss_rings = channel->rx_count;\r\n}\r\nif (adapter->drv_tx_rings != channel->tx_count) {\r\nerr = qlcnic_validate_rings(adapter, channel->tx_count,\r\nQLCNIC_TX_QUEUE);\r\nif (err) {\r\nnetdev_err(dev, "Unable to configure %u Tx rings\n",\r\nchannel->tx_count);\r\nreturn err;\r\n}\r\nadapter->drv_tss_rings = channel->tx_count;\r\n}\r\nadapter->flags |= QLCNIC_TSS_RSS;\r\nerr = qlcnic_setup_rings(adapter);\r\nnetdev_info(dev, "Allocated %d SDS rings and %d Tx rings\n",\r\nadapter->drv_sds_rings, adapter->drv_tx_rings);\r\nreturn err;\r\n}\r\nstatic void\r\nqlcnic_get_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint port = adapter->ahw->physical_port;\r\nint err = 0;\r\n__u32 val;\r\nif (qlcnic_83xx_check(adapter)) {\r\nqlcnic_83xx_get_pauseparam(adapter, pause);\r\nreturn;\r\n}\r\nif (adapter->ahw->port_type == QLCNIC_GBE) {\r\nif ((port < 0) || (port > QLCNIC_NIU_MAX_GBE_PORTS))\r\nreturn;\r\nval = QLCRD32(adapter, QLCNIC_NIU_GB_MAC_CONFIG_0(port), &err);\r\nif (err == -EIO)\r\nreturn;\r\npause->rx_pause = qlcnic_gb_get_rx_flowctl(val);\r\nval = QLCRD32(adapter, QLCNIC_NIU_GB_PAUSE_CTL, &err);\r\nif (err == -EIO)\r\nreturn;\r\nswitch (port) {\r\ncase 0:\r\npause->tx_pause = !(qlcnic_gb_get_gb0_mask(val));\r\nbreak;\r\ncase 1:\r\npause->tx_pause = !(qlcnic_gb_get_gb1_mask(val));\r\nbreak;\r\ncase 2:\r\npause->tx_pause = !(qlcnic_gb_get_gb2_mask(val));\r\nbreak;\r\ncase 3:\r\ndefault:\r\npause->tx_pause = !(qlcnic_gb_get_gb3_mask(val));\r\nbreak;\r\n}\r\n} else if (adapter->ahw->port_type == QLCNIC_XGBE) {\r\nif ((port < 0) || (port > QLCNIC_NIU_MAX_XG_PORTS))\r\nreturn;\r\npause->rx_pause = 1;\r\nval = QLCRD32(adapter, QLCNIC_NIU_XG_PAUSE_CTL, &err);\r\nif (err == -EIO)\r\nreturn;\r\nif (port == 0)\r\npause->tx_pause = !(qlcnic_xg_get_xg0_mask(val));\r\nelse\r\npause->tx_pause = !(qlcnic_xg_get_xg1_mask(val));\r\n} else {\r\ndev_err(&netdev->dev, "Unknown board type: %x\n",\r\nadapter->ahw->port_type);\r\n}\r\n}\r\nstatic int\r\nqlcnic_set_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint port = adapter->ahw->physical_port;\r\nint err = 0;\r\n__u32 val;\r\nif (qlcnic_83xx_check(adapter))\r\nreturn qlcnic_83xx_set_pauseparam(adapter, pause);\r\nif (adapter->ahw->port_type == QLCNIC_GBE) {\r\nif ((port < 0) || (port > QLCNIC_NIU_MAX_GBE_PORTS))\r\nreturn -EIO;\r\nval = QLCRD32(adapter, QLCNIC_NIU_GB_MAC_CONFIG_0(port), &err);\r\nif (err == -EIO)\r\nreturn err;\r\nif (pause->rx_pause)\r\nqlcnic_gb_rx_flowctl(val);\r\nelse\r\nqlcnic_gb_unset_rx_flowctl(val);\r\nQLCWR32(adapter, QLCNIC_NIU_GB_MAC_CONFIG_0(port),\r\nval);\r\nQLCWR32(adapter, QLCNIC_NIU_GB_MAC_CONFIG_0(port), val);\r\nval = QLCRD32(adapter, QLCNIC_NIU_GB_PAUSE_CTL, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nswitch (port) {\r\ncase 0:\r\nif (pause->tx_pause)\r\nqlcnic_gb_unset_gb0_mask(val);\r\nelse\r\nqlcnic_gb_set_gb0_mask(val);\r\nbreak;\r\ncase 1:\r\nif (pause->tx_pause)\r\nqlcnic_gb_unset_gb1_mask(val);\r\nelse\r\nqlcnic_gb_set_gb1_mask(val);\r\nbreak;\r\ncase 2:\r\nif (pause->tx_pause)\r\nqlcnic_gb_unset_gb2_mask(val);\r\nelse\r\nqlcnic_gb_set_gb2_mask(val);\r\nbreak;\r\ncase 3:\r\ndefault:\r\nif (pause->tx_pause)\r\nqlcnic_gb_unset_gb3_mask(val);\r\nelse\r\nqlcnic_gb_set_gb3_mask(val);\r\nbreak;\r\n}\r\nQLCWR32(adapter, QLCNIC_NIU_GB_PAUSE_CTL, val);\r\n} else if (adapter->ahw->port_type == QLCNIC_XGBE) {\r\nif (!pause->rx_pause || pause->autoneg)\r\nreturn -EOPNOTSUPP;\r\nif ((port < 0) || (port > QLCNIC_NIU_MAX_XG_PORTS))\r\nreturn -EIO;\r\nval = QLCRD32(adapter, QLCNIC_NIU_XG_PAUSE_CTL, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nif (port == 0) {\r\nif (pause->tx_pause)\r\nqlcnic_xg_unset_xg0_mask(val);\r\nelse\r\nqlcnic_xg_set_xg0_mask(val);\r\n} else {\r\nif (pause->tx_pause)\r\nqlcnic_xg_unset_xg1_mask(val);\r\nelse\r\nqlcnic_xg_set_xg1_mask(val);\r\n}\r\nQLCWR32(adapter, QLCNIC_NIU_XG_PAUSE_CTL, val);\r\n} else {\r\ndev_err(&netdev->dev, "Unknown board type: %x\n",\r\nadapter->ahw->port_type);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_reg_test(struct net_device *dev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nu32 data_read;\r\nint err = 0;\r\nif (qlcnic_83xx_check(adapter))\r\nreturn qlcnic_83xx_reg_test(adapter);\r\ndata_read = QLCRD32(adapter, QLCNIC_PCIX_PH_REG(0), &err);\r\nif (err == -EIO)\r\nreturn err;\r\nif ((data_read & 0xffff) != adapter->pdev->vendor)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_eeprom_test(struct net_device *dev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nif (qlcnic_82xx_check(adapter))\r\nreturn 0;\r\nreturn qlcnic_83xx_flash_test(adapter);\r\n}\r\nstatic int qlcnic_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nswitch (sset) {\r\ncase ETH_SS_TEST:\r\nreturn QLCNIC_TEST_LEN;\r\ncase ETH_SS_STATS:\r\nreturn qlcnic_dev_statistics_len(adapter);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int qlcnic_irq_test(struct net_device *netdev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_cmd_args cmd;\r\nint ret, drv_sds_rings = adapter->drv_sds_rings;\r\nint drv_tx_rings = adapter->drv_tx_rings;\r\nif (qlcnic_83xx_check(adapter))\r\nreturn qlcnic_83xx_interrupt_test(netdev);\r\nif (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\r\nreturn -EIO;\r\nret = qlcnic_diag_alloc_res(netdev, QLCNIC_INTERRUPT_TEST);\r\nif (ret)\r\ngoto clear_diag_irq;\r\nahw->diag_cnt = 0;\r\nret = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_INTRPT_TEST);\r\nif (ret)\r\ngoto free_diag_res;\r\ncmd.req.arg[1] = ahw->pci_func;\r\nret = qlcnic_issue_cmd(adapter, &cmd);\r\nif (ret)\r\ngoto done;\r\nusleep_range(1000, 12000);\r\nret = !ahw->diag_cnt;\r\ndone:\r\nqlcnic_free_mbx_args(&cmd);\r\nfree_diag_res:\r\nqlcnic_diag_free_res(netdev, drv_sds_rings);\r\nclear_diag_irq:\r\nadapter->drv_sds_rings = drv_sds_rings;\r\nadapter->drv_tx_rings = drv_tx_rings;\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nreturn ret;\r\n}\r\nstatic void qlcnic_create_loopback_buff(unsigned char *data, u8 mac[])\r\n{\r\nunsigned char random_data[] = {0xa8, 0x06, 0x45, 0x00};\r\nmemset(data, 0x4e, QLCNIC_ILB_PKT_SIZE);\r\nmemcpy(data, mac, ETH_ALEN);\r\nmemcpy(data + ETH_ALEN, mac, ETH_ALEN);\r\nmemcpy(data + 2 * ETH_ALEN, random_data, sizeof(random_data));\r\n}\r\nint qlcnic_check_loopback_buff(unsigned char *data, u8 mac[])\r\n{\r\nunsigned char buff[QLCNIC_ILB_PKT_SIZE];\r\nqlcnic_create_loopback_buff(buff, mac);\r\nreturn memcmp(data, buff, QLCNIC_ILB_PKT_SIZE);\r\n}\r\nint qlcnic_do_lb_test(struct qlcnic_adapter *adapter, u8 mode)\r\n{\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nstruct qlcnic_host_sds_ring *sds_ring = &recv_ctx->sds_rings[0];\r\nstruct sk_buff *skb;\r\nint i, loop, cnt = 0;\r\nfor (i = 0; i < QLCNIC_NUM_ILB_PKT; i++) {\r\nskb = netdev_alloc_skb(adapter->netdev, QLCNIC_ILB_PKT_SIZE);\r\nqlcnic_create_loopback_buff(skb->data, adapter->mac_addr);\r\nskb_put(skb, QLCNIC_ILB_PKT_SIZE);\r\nadapter->ahw->diag_cnt = 0;\r\nqlcnic_xmit_frame(skb, adapter->netdev);\r\nloop = 0;\r\ndo {\r\nmsleep(QLCNIC_LB_PKT_POLL_DELAY_MSEC);\r\nqlcnic_process_rcv_ring_diag(sds_ring);\r\nif (loop++ > QLCNIC_LB_PKT_POLL_COUNT)\r\nbreak;\r\n} while (!adapter->ahw->diag_cnt);\r\ndev_kfree_skb_any(skb);\r\nif (!adapter->ahw->diag_cnt)\r\ndev_warn(&adapter->pdev->dev,\r\n"LB Test: packet #%d was not received\n",\r\ni + 1);\r\nelse\r\ncnt++;\r\n}\r\nif (cnt != i) {\r\ndev_err(&adapter->pdev->dev,\r\n"LB Test: failed, TX[%d], RX[%d]\n", i, cnt);\r\nif (mode != QLCNIC_ILB_MODE)\r\ndev_warn(&adapter->pdev->dev,\r\n"WARNING: Please check loopback cable\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_loopback_test(struct net_device *netdev, u8 mode)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint drv_tx_rings = adapter->drv_tx_rings;\r\nint drv_sds_rings = adapter->drv_sds_rings;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint loop = 0;\r\nint ret;\r\nif (qlcnic_83xx_check(adapter))\r\nreturn qlcnic_83xx_loopback_test(netdev, mode);\r\nif (!(ahw->capabilities & QLCNIC_FW_CAPABILITY_MULTI_LOOPBACK)) {\r\ndev_info(&adapter->pdev->dev,\r\n"Firmware do not support loopback test\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\ndev_warn(&adapter->pdev->dev, "%s loopback test in progress\n",\r\nmode == QLCNIC_ILB_MODE ? "internal" : "external");\r\nif (ahw->op_mode == QLCNIC_NON_PRIV_FUNC) {\r\ndev_warn(&adapter->pdev->dev,\r\n"Loopback test not supported in nonprivileged mode\n");\r\nreturn 0;\r\n}\r\nif (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\r\nreturn -EBUSY;\r\nret = qlcnic_diag_alloc_res(netdev, QLCNIC_LOOPBACK_TEST);\r\nif (ret)\r\ngoto clear_it;\r\nsds_ring = &adapter->recv_ctx->sds_rings[0];\r\nret = qlcnic_set_lb_mode(adapter, mode);\r\nif (ret)\r\ngoto free_res;\r\nahw->diag_cnt = 0;\r\ndo {\r\nmsleep(500);\r\nqlcnic_process_rcv_ring_diag(sds_ring);\r\nif (loop++ > QLCNIC_ILB_MAX_RCV_LOOP) {\r\nnetdev_info(netdev,\r\n"Firmware didn't sent link up event to loopback request\n");\r\nret = -ETIMEDOUT;\r\ngoto free_res;\r\n} else if (adapter->ahw->diag_cnt) {\r\nret = adapter->ahw->diag_cnt;\r\ngoto free_res;\r\n}\r\n} while (!QLCNIC_IS_LB_CONFIGURED(ahw->loopback_state));\r\nret = qlcnic_do_lb_test(adapter, mode);\r\nqlcnic_clear_lb_mode(adapter, mode);\r\nfree_res:\r\nqlcnic_diag_free_res(netdev, drv_sds_rings);\r\nclear_it:\r\nadapter->drv_sds_rings = drv_sds_rings;\r\nadapter->drv_tx_rings = drv_tx_rings;\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nreturn ret;\r\n}\r\nstatic void\r\nqlcnic_diag_test(struct net_device *dev, struct ethtool_test *eth_test,\r\nu64 *data)\r\n{\r\nmemset(data, 0, sizeof(u64) * QLCNIC_TEST_LEN);\r\ndata[0] = qlcnic_reg_test(dev);\r\nif (data[0])\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\ndata[1] = (u64) qlcnic_test_link(dev);\r\nif (data[1])\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nif (eth_test->flags & ETH_TEST_FL_OFFLINE) {\r\ndata[2] = qlcnic_irq_test(dev);\r\nif (data[2])\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\ndata[3] = qlcnic_loopback_test(dev, QLCNIC_ILB_MODE);\r\nif (data[3])\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nif (eth_test->flags & ETH_TEST_FL_EXTERNAL_LB) {\r\ndata[4] = qlcnic_loopback_test(dev, QLCNIC_ELB_MODE);\r\nif (data[4])\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\neth_test->flags |= ETH_TEST_FL_EXTERNAL_LB_DONE;\r\n}\r\ndata[5] = qlcnic_eeprom_test(dev);\r\nif (data[5])\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\n}\r\n}\r\nstatic void\r\nqlcnic_get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nint index, i, num_stats;\r\nswitch (stringset) {\r\ncase ETH_SS_TEST:\r\nmemcpy(data, *qlcnic_gstrings_test,\r\nQLCNIC_TEST_LEN * ETH_GSTRING_LEN);\r\nbreak;\r\ncase ETH_SS_STATS:\r\nnum_stats = ARRAY_SIZE(qlcnic_tx_queue_stats_strings);\r\nfor (i = 0; i < adapter->drv_tx_rings; i++) {\r\nfor (index = 0; index < num_stats; index++) {\r\nsprintf(data, "tx_queue_%d %s", i,\r\nqlcnic_tx_queue_stats_strings[index]);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\n}\r\nfor (index = 0; index < QLCNIC_STATS_LEN; index++) {\r\nmemcpy(data + index * ETH_GSTRING_LEN,\r\nqlcnic_gstrings_stats[index].stat_string,\r\nETH_GSTRING_LEN);\r\n}\r\nif (qlcnic_83xx_check(adapter)) {\r\nnum_stats = ARRAY_SIZE(qlcnic_83xx_tx_stats_strings);\r\nfor (i = 0; i < num_stats; i++, index++)\r\nmemcpy(data + index * ETH_GSTRING_LEN,\r\nqlcnic_83xx_tx_stats_strings[i],\r\nETH_GSTRING_LEN);\r\nnum_stats = ARRAY_SIZE(qlcnic_83xx_mac_stats_strings);\r\nfor (i = 0; i < num_stats; i++, index++)\r\nmemcpy(data + index * ETH_GSTRING_LEN,\r\nqlcnic_83xx_mac_stats_strings[i],\r\nETH_GSTRING_LEN);\r\nnum_stats = ARRAY_SIZE(qlcnic_83xx_rx_stats_strings);\r\nfor (i = 0; i < num_stats; i++, index++)\r\nmemcpy(data + index * ETH_GSTRING_LEN,\r\nqlcnic_83xx_rx_stats_strings[i],\r\nETH_GSTRING_LEN);\r\nreturn;\r\n} else {\r\nnum_stats = ARRAY_SIZE(qlcnic_83xx_mac_stats_strings);\r\nfor (i = 0; i < num_stats; i++, index++)\r\nmemcpy(data + index * ETH_GSTRING_LEN,\r\nqlcnic_83xx_mac_stats_strings[i],\r\nETH_GSTRING_LEN);\r\n}\r\nif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED))\r\nreturn;\r\nnum_stats = ARRAY_SIZE(qlcnic_device_gstrings_stats);\r\nfor (i = 0; i < num_stats; index++, i++) {\r\nmemcpy(data + index * ETH_GSTRING_LEN,\r\nqlcnic_device_gstrings_stats[i],\r\nETH_GSTRING_LEN);\r\n}\r\n}\r\n}\r\nstatic u64 *qlcnic_fill_stats(u64 *data, void *stats, int type)\r\n{\r\nif (type == QLCNIC_MAC_STATS) {\r\nstruct qlcnic_mac_statistics *mac_stats =\r\n(struct qlcnic_mac_statistics *)stats;\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_frames);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_bytes);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_mcast_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_bcast_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_pause_cnt);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_ctrl_pkt);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_64b_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_127b_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_255b_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_511b_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_1023b_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_1518b_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_tx_gt_1518b_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_frames);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_bytes);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_mcast_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_bcast_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_pause_cnt);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_ctrl_pkt);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_64b_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_127b_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_255b_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_511b_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_1023b_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_1518b_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_gt_1518b_pkts);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_length_error);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_length_small);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_length_large);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_jabber);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_dropped);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_rx_crc_error);\r\n*data++ = QLCNIC_FILL_STATS(mac_stats->mac_align_error);\r\n} else if (type == QLCNIC_ESW_STATS) {\r\nstruct __qlcnic_esw_statistics *esw_stats =\r\n(struct __qlcnic_esw_statistics *)stats;\r\n*data++ = QLCNIC_FILL_STATS(esw_stats->unicast_frames);\r\n*data++ = QLCNIC_FILL_STATS(esw_stats->multicast_frames);\r\n*data++ = QLCNIC_FILL_STATS(esw_stats->broadcast_frames);\r\n*data++ = QLCNIC_FILL_STATS(esw_stats->dropped_frames);\r\n*data++ = QLCNIC_FILL_STATS(esw_stats->errors);\r\n*data++ = QLCNIC_FILL_STATS(esw_stats->local_frames);\r\n*data++ = QLCNIC_FILL_STATS(esw_stats->numbytes);\r\n}\r\nreturn data;\r\n}\r\nvoid qlcnic_update_stats(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_tx_queue_stats tx_stats;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\nint ring;\r\nmemset(&tx_stats, 0, sizeof(tx_stats));\r\nfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\r\ntx_ring = &adapter->tx_ring[ring];\r\ntx_stats.xmit_on += tx_ring->tx_stats.xmit_on;\r\ntx_stats.xmit_off += tx_ring->tx_stats.xmit_off;\r\ntx_stats.xmit_called += tx_ring->tx_stats.xmit_called;\r\ntx_stats.xmit_finished += tx_ring->tx_stats.xmit_finished;\r\ntx_stats.tx_bytes += tx_ring->tx_stats.tx_bytes;\r\n}\r\nadapter->stats.xmit_on = tx_stats.xmit_on;\r\nadapter->stats.xmit_off = tx_stats.xmit_off;\r\nadapter->stats.xmitcalled = tx_stats.xmit_called;\r\nadapter->stats.xmitfinished = tx_stats.xmit_finished;\r\nadapter->stats.txbytes = tx_stats.tx_bytes;\r\n}\r\nstatic u64 *qlcnic_fill_tx_queue_stats(u64 *data, void *stats)\r\n{\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\ntx_ring = (struct qlcnic_host_tx_ring *)stats;\r\n*data++ = QLCNIC_FILL_STATS(tx_ring->tx_stats.xmit_on);\r\n*data++ = QLCNIC_FILL_STATS(tx_ring->tx_stats.xmit_off);\r\n*data++ = QLCNIC_FILL_STATS(tx_ring->tx_stats.xmit_called);\r\n*data++ = QLCNIC_FILL_STATS(tx_ring->tx_stats.xmit_finished);\r\n*data++ = QLCNIC_FILL_STATS(tx_ring->tx_stats.tx_bytes);\r\nreturn data;\r\n}\r\nstatic void qlcnic_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\nstruct qlcnic_esw_statistics port_stats;\r\nstruct qlcnic_mac_statistics mac_stats;\r\nint index, ret, length, size, ring;\r\nchar *p;\r\nmemset(data, 0, stats->n_stats * sizeof(u64));\r\nfor (ring = 0, index = 0; ring < adapter->drv_tx_rings; ring++) {\r\nif (adapter->is_up == QLCNIC_ADAPTER_UP_MAGIC) {\r\ntx_ring = &adapter->tx_ring[ring];\r\ndata = qlcnic_fill_tx_queue_stats(data, tx_ring);\r\nqlcnic_update_stats(adapter);\r\n} else {\r\ndata += QLCNIC_TX_STATS_LEN;\r\n}\r\n}\r\nlength = QLCNIC_STATS_LEN;\r\nfor (index = 0; index < length; index++) {\r\np = (char *)adapter + qlcnic_gstrings_stats[index].stat_offset;\r\nsize = qlcnic_gstrings_stats[index].sizeof_stat;\r\n*data++ = (size == sizeof(u64)) ? (*(u64 *)p) : ((*(u32 *)p));\r\n}\r\nif (qlcnic_83xx_check(adapter)) {\r\nif (adapter->ahw->linkup)\r\nqlcnic_83xx_get_stats(adapter, data);\r\nreturn;\r\n} else {\r\nmemset(&mac_stats, 0, sizeof(struct qlcnic_mac_statistics));\r\nqlcnic_get_mac_stats(adapter, &mac_stats);\r\ndata = qlcnic_fill_stats(data, &mac_stats, QLCNIC_MAC_STATS);\r\n}\r\nif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED))\r\nreturn;\r\nmemset(&port_stats, 0, sizeof(struct qlcnic_esw_statistics));\r\nret = qlcnic_get_port_stats(adapter, adapter->ahw->pci_func,\r\nQLCNIC_QUERY_RX_COUNTER, &port_stats.rx);\r\nif (ret)\r\nreturn;\r\ndata = qlcnic_fill_stats(data, &port_stats.rx, QLCNIC_ESW_STATS);\r\nret = qlcnic_get_port_stats(adapter, adapter->ahw->pci_func,\r\nQLCNIC_QUERY_TX_COUNTER, &port_stats.tx);\r\nif (ret)\r\nreturn;\r\nqlcnic_fill_stats(data, &port_stats.tx, QLCNIC_ESW_STATS);\r\n}\r\nstatic int qlcnic_set_led(struct net_device *dev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nint drv_sds_rings = adapter->drv_sds_rings;\r\nint err = -EIO, active = 1;\r\nif (qlcnic_83xx_check(adapter))\r\nreturn qlcnic_83xx_set_led(dev, state);\r\nif (adapter->ahw->op_mode == QLCNIC_NON_PRIV_FUNC) {\r\nnetdev_warn(dev, "LED test not supported for non "\r\n"privilege function\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nif (test_and_set_bit(__QLCNIC_LED_ENABLE, &adapter->state))\r\nreturn -EBUSY;\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state))\r\nbreak;\r\nif (!test_bit(__QLCNIC_DEV_UP, &adapter->state)) {\r\nif (qlcnic_diag_alloc_res(dev, QLCNIC_LED_TEST))\r\nbreak;\r\nset_bit(__QLCNIC_DIAG_RES_ALLOC, &adapter->state);\r\n}\r\nif (adapter->nic_ops->config_led(adapter, 1, 0xf) == 0) {\r\nerr = 0;\r\nbreak;\r\n}\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to set LED blink state.\n");\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\nactive = 0;\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state))\r\nbreak;\r\nif (!test_bit(__QLCNIC_DEV_UP, &adapter->state)) {\r\nif (qlcnic_diag_alloc_res(dev, QLCNIC_LED_TEST))\r\nbreak;\r\nset_bit(__QLCNIC_DIAG_RES_ALLOC, &adapter->state);\r\n}\r\nif (adapter->nic_ops->config_led(adapter, 0, 0xf))\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to reset LED blink state.\n");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (test_and_clear_bit(__QLCNIC_DIAG_RES_ALLOC, &adapter->state))\r\nqlcnic_diag_free_res(dev, drv_sds_rings);\r\nif (!active || err)\r\nclear_bit(__QLCNIC_LED_ENABLE, &adapter->state);\r\nreturn err;\r\n}\r\nstatic void\r\nqlcnic_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nu32 wol_cfg;\r\nint err = 0;\r\nif (qlcnic_83xx_check(adapter))\r\nreturn;\r\nwol->supported = 0;\r\nwol->wolopts = 0;\r\nwol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG_NV, &err);\r\nif (err == -EIO)\r\nreturn;\r\nif (wol_cfg & (1UL << adapter->portnum))\r\nwol->supported |= WAKE_MAGIC;\r\nwol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG, &err);\r\nif (wol_cfg & (1UL << adapter->portnum))\r\nwol->wolopts |= WAKE_MAGIC;\r\n}\r\nstatic int\r\nqlcnic_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nu32 wol_cfg;\r\nint err = 0;\r\nif (qlcnic_83xx_check(adapter))\r\nreturn -EOPNOTSUPP;\r\nif (wol->wolopts & ~WAKE_MAGIC)\r\nreturn -EINVAL;\r\nwol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG_NV, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nif (!(wol_cfg & (1 << adapter->portnum)))\r\nreturn -EOPNOTSUPP;\r\nwol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nif (wol->wolopts & WAKE_MAGIC)\r\nwol_cfg |= 1UL << adapter->portnum;\r\nelse\r\nwol_cfg &= ~(1UL << adapter->portnum);\r\nQLCWR32(adapter, QLCNIC_WOL_CONFIG, wol_cfg);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_set_intr_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ethcoal)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint err;\r\nif (!test_bit(__QLCNIC_DEV_UP, &adapter->state))\r\nreturn -EINVAL;\r\nif (ethcoal->rx_coalesce_usecs > 0xffff ||\r\nethcoal->rx_max_coalesced_frames > 0xffff ||\r\nethcoal->tx_coalesce_usecs > 0xffff ||\r\nethcoal->tx_max_coalesced_frames > 0xffff ||\r\nethcoal->rx_coalesce_usecs_irq ||\r\nethcoal->rx_max_coalesced_frames_irq ||\r\nethcoal->tx_coalesce_usecs_irq ||\r\nethcoal->tx_max_coalesced_frames_irq ||\r\nethcoal->stats_block_coalesce_usecs ||\r\nethcoal->use_adaptive_rx_coalesce ||\r\nethcoal->use_adaptive_tx_coalesce ||\r\nethcoal->pkt_rate_low ||\r\nethcoal->rx_coalesce_usecs_low ||\r\nethcoal->rx_max_coalesced_frames_low ||\r\nethcoal->tx_coalesce_usecs_low ||\r\nethcoal->tx_max_coalesced_frames_low ||\r\nethcoal->pkt_rate_high ||\r\nethcoal->rx_coalesce_usecs_high ||\r\nethcoal->rx_max_coalesced_frames_high ||\r\nethcoal->tx_coalesce_usecs_high ||\r\nethcoal->tx_max_coalesced_frames_high)\r\nreturn -EINVAL;\r\nerr = qlcnic_config_intr_coalesce(adapter, ethcoal);\r\nreturn err;\r\n}\r\nstatic int qlcnic_get_intr_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ethcoal)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nif (adapter->is_up != QLCNIC_ADAPTER_UP_MAGIC)\r\nreturn -EINVAL;\r\nethcoal->rx_coalesce_usecs = adapter->ahw->coal.rx_time_us;\r\nethcoal->rx_max_coalesced_frames = adapter->ahw->coal.rx_packets;\r\nethcoal->tx_coalesce_usecs = adapter->ahw->coal.tx_time_us;\r\nethcoal->tx_max_coalesced_frames = adapter->ahw->coal.tx_packets;\r\nreturn 0;\r\n}\r\nstatic u32 qlcnic_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nreturn adapter->ahw->msg_enable;\r\n}\r\nstatic void qlcnic_set_msglevel(struct net_device *netdev, u32 msglvl)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nadapter->ahw->msg_enable = msglvl;\r\n}\r\nint qlcnic_enable_fw_dump_state(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\r\nu32 val;\r\nif (qlcnic_84xx_check(adapter)) {\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EBUSY;\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\r\nval &= ~QLC_83XX_IDC_DISABLE_FW_DUMP;\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_CTRL, val);\r\nqlcnic_83xx_unlock_driver(adapter);\r\n} else {\r\nfw_dump->enable = true;\r\n}\r\ndev_info(&adapter->pdev->dev, "FW dump enabled\n");\r\nreturn 0;\r\n}\r\nstatic int qlcnic_disable_fw_dump_state(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\r\nu32 val;\r\nif (qlcnic_84xx_check(adapter)) {\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EBUSY;\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\r\nval |= QLC_83XX_IDC_DISABLE_FW_DUMP;\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_CTRL, val);\r\nqlcnic_83xx_unlock_driver(adapter);\r\n} else {\r\nfw_dump->enable = false;\r\n}\r\ndev_info(&adapter->pdev->dev, "FW dump disabled\n");\r\nreturn 0;\r\n}\r\nbool qlcnic_check_fw_dump_state(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\r\nbool state;\r\nu32 val;\r\nif (qlcnic_84xx_check(adapter)) {\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\r\nstate = (val & QLC_83XX_IDC_DISABLE_FW_DUMP) ? false : true;\r\n} else {\r\nstate = fw_dump->enable;\r\n}\r\nreturn state;\r\n}\r\nstatic int\r\nqlcnic_get_dump_flag(struct net_device *netdev, struct ethtool_dump *dump)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\r\nif (!fw_dump->tmpl_hdr) {\r\nnetdev_err(adapter->netdev, "FW Dump not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (fw_dump->clr)\r\ndump->len = fw_dump->tmpl_hdr_size + fw_dump->size;\r\nelse\r\ndump->len = 0;\r\nif (!qlcnic_check_fw_dump_state(adapter))\r\ndump->flag = ETH_FW_DUMP_DISABLE;\r\nelse\r\ndump->flag = fw_dump->cap_mask;\r\ndump->version = adapter->fw_version;\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_get_dump_data(struct net_device *netdev, struct ethtool_dump *dump,\r\nvoid *buffer)\r\n{\r\nint i, copy_sz;\r\nu32 *hdr_ptr;\r\n__le32 *data;\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\r\nif (!fw_dump->tmpl_hdr) {\r\nnetdev_err(netdev, "FW Dump not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (!fw_dump->clr) {\r\nnetdev_info(netdev, "Dump not available\n");\r\nreturn -EINVAL;\r\n}\r\ncopy_sz = fw_dump->tmpl_hdr_size;\r\nhdr_ptr = (u32 *)fw_dump->tmpl_hdr;\r\ndata = buffer;\r\nfor (i = 0; i < copy_sz/sizeof(u32); i++)\r\n*data++ = cpu_to_le32(*hdr_ptr++);\r\nmemcpy(buffer + copy_sz, fw_dump->data, fw_dump->size);\r\ndump->len = copy_sz + fw_dump->size;\r\ndump->flag = fw_dump->cap_mask;\r\nvfree(fw_dump->data);\r\nfw_dump->data = NULL;\r\nfw_dump->clr = 0;\r\nnetdev_info(netdev, "extracted the FW dump Successfully\n");\r\nreturn 0;\r\n}\r\nstatic int qlcnic_set_dump_mask(struct qlcnic_adapter *adapter, u32 mask)\r\n{\r\nstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\r\nstruct net_device *netdev = adapter->netdev;\r\nif (!qlcnic_check_fw_dump_state(adapter)) {\r\nnetdev_info(netdev,\r\n"Can not change driver mask to 0x%x. FW dump not enabled\n",\r\nmask);\r\nreturn -EOPNOTSUPP;\r\n}\r\nfw_dump->cap_mask = mask;\r\nqlcnic_store_cap_mask(adapter, fw_dump->tmpl_hdr, mask);\r\nnetdev_info(netdev, "Driver mask changed to: 0x%x\n", mask);\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_set_dump(struct net_device *netdev, struct ethtool_dump *val)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\r\nbool valid_mask = false;\r\nint i, ret = 0;\r\nswitch (val->flag) {\r\ncase QLCNIC_FORCE_FW_DUMP_KEY:\r\nif (!fw_dump->tmpl_hdr) {\r\nnetdev_err(netdev, "FW dump not supported\n");\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (!qlcnic_check_fw_dump_state(adapter)) {\r\nnetdev_info(netdev, "FW dump not enabled\n");\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (fw_dump->clr) {\r\nnetdev_info(netdev,\r\n"Previous dump not cleared, not forcing dump\n");\r\nbreak;\r\n}\r\nnetdev_info(netdev, "Forcing a FW dump\n");\r\nqlcnic_dev_request_reset(adapter, val->flag);\r\nbreak;\r\ncase QLCNIC_DISABLE_FW_DUMP:\r\nif (!fw_dump->tmpl_hdr) {\r\nnetdev_err(netdev, "FW dump not supported\n");\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nret = qlcnic_disable_fw_dump_state(adapter);\r\nbreak;\r\ncase QLCNIC_ENABLE_FW_DUMP:\r\nif (!fw_dump->tmpl_hdr) {\r\nnetdev_err(netdev, "FW dump not supported\n");\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nret = qlcnic_enable_fw_dump_state(adapter);\r\nbreak;\r\ncase QLCNIC_FORCE_FW_RESET:\r\nnetdev_info(netdev, "Forcing a FW reset\n");\r\nqlcnic_dev_request_reset(adapter, val->flag);\r\nadapter->flags &= ~QLCNIC_FW_RESET_OWNER;\r\nbreak;\r\ncase QLCNIC_SET_QUIESCENT:\r\ncase QLCNIC_RESET_QUIESCENT:\r\nif (test_bit(__QLCNIC_MAINTENANCE_MODE, &adapter->state))\r\nnetdev_info(netdev, "Device is in non-operational state\n");\r\nbreak;\r\ndefault:\r\nif (!fw_dump->tmpl_hdr) {\r\nnetdev_err(netdev, "FW dump not supported\n");\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(qlcnic_fw_dump_level); i++) {\r\nif (val->flag == qlcnic_fw_dump_level[i]) {\r\nvalid_mask = true;\r\nbreak;\r\n}\r\n}\r\nif (valid_mask) {\r\nret = qlcnic_set_dump_mask(adapter, val->flag);\r\n} else {\r\nnetdev_info(netdev, "Invalid dump level: 0x%x\n",\r\nval->flag);\r\nret = -EINVAL;\r\n}\r\n}\r\nreturn ret;\r\n}
