struct device *mdev_parent_dev(struct mdev_device *mdev)\r\n{\r\nreturn mdev->parent->dev;\r\n}\r\nvoid *mdev_get_drvdata(struct mdev_device *mdev)\r\n{\r\nreturn mdev->driver_data;\r\n}\r\nvoid mdev_set_drvdata(struct mdev_device *mdev, void *data)\r\n{\r\nmdev->driver_data = data;\r\n}\r\nstruct device *mdev_dev(struct mdev_device *mdev)\r\n{\r\nreturn &mdev->dev;\r\n}\r\nstruct mdev_device *mdev_from_dev(struct device *dev)\r\n{\r\nreturn dev_is_mdev(dev) ? to_mdev_device(dev) : NULL;\r\n}\r\nuuid_le mdev_uuid(struct mdev_device *mdev)\r\n{\r\nreturn mdev->uuid;\r\n}\r\nstatic int _find_mdev_device(struct device *dev, void *data)\r\n{\r\nstruct mdev_device *mdev;\r\nif (!dev_is_mdev(dev))\r\nreturn 0;\r\nmdev = to_mdev_device(dev);\r\nif (uuid_le_cmp(mdev->uuid, *(uuid_le *)data) == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic bool mdev_device_exist(struct mdev_parent *parent, uuid_le uuid)\r\n{\r\nstruct device *dev;\r\ndev = device_find_child(parent->dev, &uuid, _find_mdev_device);\r\nif (dev) {\r\nput_device(dev);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic struct mdev_parent *__find_parent_device(struct device *dev)\r\n{\r\nstruct mdev_parent *parent;\r\nlist_for_each_entry(parent, &parent_list, next) {\r\nif (parent->dev == dev)\r\nreturn parent;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void mdev_release_parent(struct kref *kref)\r\n{\r\nstruct mdev_parent *parent = container_of(kref, struct mdev_parent,\r\nref);\r\nstruct device *dev = parent->dev;\r\nkfree(parent);\r\nput_device(dev);\r\n}\r\nstatic\r\ninline struct mdev_parent *mdev_get_parent(struct mdev_parent *parent)\r\n{\r\nif (parent)\r\nkref_get(&parent->ref);\r\nreturn parent;\r\n}\r\nstatic inline void mdev_put_parent(struct mdev_parent *parent)\r\n{\r\nif (parent)\r\nkref_put(&parent->ref, mdev_release_parent);\r\n}\r\nstatic int mdev_device_create_ops(struct kobject *kobj,\r\nstruct mdev_device *mdev)\r\n{\r\nstruct mdev_parent *parent = mdev->parent;\r\nint ret;\r\nret = parent->ops->create(kobj, mdev);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_groups(&mdev->dev.kobj,\r\nparent->ops->mdev_attr_groups);\r\nif (ret)\r\nparent->ops->remove(mdev);\r\nreturn ret;\r\n}\r\nstatic int mdev_device_remove_ops(struct mdev_device *mdev, bool force_remove)\r\n{\r\nstruct mdev_parent *parent = mdev->parent;\r\nint ret;\r\nret = parent->ops->remove(mdev);\r\nif (ret && !force_remove)\r\nreturn -EBUSY;\r\nsysfs_remove_groups(&mdev->dev.kobj, parent->ops->mdev_attr_groups);\r\nreturn 0;\r\n}\r\nstatic int mdev_device_remove_cb(struct device *dev, void *data)\r\n{\r\nif (!dev_is_mdev(dev))\r\nreturn 0;\r\nreturn mdev_device_remove(dev, data ? *(bool *)data : true);\r\n}\r\nint mdev_register_device(struct device *dev, const struct mdev_parent_ops *ops)\r\n{\r\nint ret;\r\nstruct mdev_parent *parent;\r\nif (!ops || !ops->create || !ops->remove || !ops->supported_type_groups)\r\nreturn -EINVAL;\r\ndev = get_device(dev);\r\nif (!dev)\r\nreturn -EINVAL;\r\nmutex_lock(&parent_list_lock);\r\nparent = __find_parent_device(dev);\r\nif (parent) {\r\nret = -EEXIST;\r\ngoto add_dev_err;\r\n}\r\nparent = kzalloc(sizeof(*parent), GFP_KERNEL);\r\nif (!parent) {\r\nret = -ENOMEM;\r\ngoto add_dev_err;\r\n}\r\nkref_init(&parent->ref);\r\nmutex_init(&parent->lock);\r\nparent->dev = dev;\r\nparent->ops = ops;\r\nif (!mdev_bus_compat_class) {\r\nmdev_bus_compat_class = class_compat_register("mdev_bus");\r\nif (!mdev_bus_compat_class) {\r\nret = -ENOMEM;\r\ngoto add_dev_err;\r\n}\r\n}\r\nret = parent_create_sysfs_files(parent);\r\nif (ret)\r\ngoto add_dev_err;\r\nret = class_compat_create_link(mdev_bus_compat_class, dev, NULL);\r\nif (ret)\r\ndev_warn(dev, "Failed to create compatibility class link\n");\r\nlist_add(&parent->next, &parent_list);\r\nmutex_unlock(&parent_list_lock);\r\ndev_info(dev, "MDEV: Registered\n");\r\nreturn 0;\r\nadd_dev_err:\r\nmutex_unlock(&parent_list_lock);\r\nif (parent)\r\nmdev_put_parent(parent);\r\nelse\r\nput_device(dev);\r\nreturn ret;\r\n}\r\nvoid mdev_unregister_device(struct device *dev)\r\n{\r\nstruct mdev_parent *parent;\r\nbool force_remove = true;\r\nmutex_lock(&parent_list_lock);\r\nparent = __find_parent_device(dev);\r\nif (!parent) {\r\nmutex_unlock(&parent_list_lock);\r\nreturn;\r\n}\r\ndev_info(dev, "MDEV: Unregistering\n");\r\nlist_del(&parent->next);\r\nclass_compat_remove_link(mdev_bus_compat_class, dev, NULL);\r\ndevice_for_each_child(dev, (void *)&force_remove,\r\nmdev_device_remove_cb);\r\nparent_remove_sysfs_files(parent);\r\nmutex_unlock(&parent_list_lock);\r\nmdev_put_parent(parent);\r\n}\r\nstatic void mdev_device_release(struct device *dev)\r\n{\r\nstruct mdev_device *mdev = to_mdev_device(dev);\r\ndev_dbg(&mdev->dev, "MDEV: destroying\n");\r\nkfree(mdev);\r\n}\r\nint mdev_device_create(struct kobject *kobj, struct device *dev, uuid_le uuid)\r\n{\r\nint ret;\r\nstruct mdev_device *mdev;\r\nstruct mdev_parent *parent;\r\nstruct mdev_type *type = to_mdev_type(kobj);\r\nparent = mdev_get_parent(type->parent);\r\nif (!parent)\r\nreturn -EINVAL;\r\nmutex_lock(&parent->lock);\r\nif (mdev_device_exist(parent, uuid)) {\r\nret = -EEXIST;\r\ngoto create_err;\r\n}\r\nmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\r\nif (!mdev) {\r\nret = -ENOMEM;\r\ngoto create_err;\r\n}\r\nmemcpy(&mdev->uuid, &uuid, sizeof(uuid_le));\r\nmdev->parent = parent;\r\nkref_init(&mdev->ref);\r\nmdev->dev.parent = dev;\r\nmdev->dev.bus = &mdev_bus_type;\r\nmdev->dev.release = mdev_device_release;\r\ndev_set_name(&mdev->dev, "%pUl", uuid.b);\r\nret = device_register(&mdev->dev);\r\nif (ret) {\r\nput_device(&mdev->dev);\r\ngoto create_err;\r\n}\r\nret = mdev_device_create_ops(kobj, mdev);\r\nif (ret)\r\ngoto create_failed;\r\nret = mdev_create_sysfs_files(&mdev->dev, type);\r\nif (ret) {\r\nmdev_device_remove_ops(mdev, true);\r\ngoto create_failed;\r\n}\r\nmdev->type_kobj = kobj;\r\ndev_dbg(&mdev->dev, "MDEV: created\n");\r\nmutex_unlock(&parent->lock);\r\nmutex_lock(&mdev_list_lock);\r\nlist_add(&mdev->next, &mdev_list);\r\nmutex_unlock(&mdev_list_lock);\r\nreturn ret;\r\ncreate_failed:\r\ndevice_unregister(&mdev->dev);\r\ncreate_err:\r\nmutex_unlock(&parent->lock);\r\nmdev_put_parent(parent);\r\nreturn ret;\r\n}\r\nint mdev_device_remove(struct device *dev, bool force_remove)\r\n{\r\nstruct mdev_device *mdev, *tmp;\r\nstruct mdev_parent *parent;\r\nstruct mdev_type *type;\r\nint ret;\r\nbool found = false;\r\nmdev = to_mdev_device(dev);\r\nmutex_lock(&mdev_list_lock);\r\nlist_for_each_entry(tmp, &mdev_list, next) {\r\nif (tmp == mdev) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (found)\r\nlist_del(&mdev->next);\r\nmutex_unlock(&mdev_list_lock);\r\nif (!found)\r\nreturn -ENODEV;\r\ntype = to_mdev_type(mdev->type_kobj);\r\nparent = mdev->parent;\r\nmutex_lock(&parent->lock);\r\nret = mdev_device_remove_ops(mdev, force_remove);\r\nif (ret) {\r\nmutex_unlock(&parent->lock);\r\nmutex_lock(&mdev_list_lock);\r\nlist_add(&mdev->next, &mdev_list);\r\nmutex_unlock(&mdev_list_lock);\r\nreturn ret;\r\n}\r\nmdev_remove_sysfs_files(dev, type);\r\ndevice_unregister(dev);\r\nmutex_unlock(&parent->lock);\r\nmdev_put_parent(parent);\r\nreturn 0;\r\n}\r\nstatic int __init mdev_init(void)\r\n{\r\nreturn mdev_bus_register();\r\n}\r\nstatic void __exit mdev_exit(void)\r\n{\r\nif (mdev_bus_compat_class)\r\nclass_compat_unregister(mdev_bus_compat_class);\r\nmdev_bus_unregister();\r\n}
