static void log_quirks(struct device *dev)\r\n{\r\nif (cht_rt5645_quirk & CHT_RT5645_SSP2_AIF2)\r\ndev_info(dev, "quirk SSP2_AIF2 enabled");\r\nif (cht_rt5645_quirk & CHT_RT5645_SSP0_AIF1)\r\ndev_info(dev, "quirk SSP0_AIF1 enabled");\r\nif (cht_rt5645_quirk & CHT_RT5645_SSP0_AIF2)\r\ndev_info(dev, "quirk SSP0_AIF2 enabled");\r\n}\r\nstatic inline struct snd_soc_dai *cht_get_codec_dai(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd;\r\nlist_for_each_entry(rtd, &card->rtd_list, list) {\r\nif (!strncmp(rtd->codec_dai->name, CHT_CODEC_DAI1,\r\nstrlen(CHT_CODEC_DAI1)))\r\nreturn rtd->codec_dai;\r\nif (!strncmp(rtd->codec_dai->name, CHT_CODEC_DAI2,\r\nstrlen(CHT_CODEC_DAI2)))\r\nreturn rtd->codec_dai;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int platform_clock_control(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nstruct snd_soc_dapm_context *dapm = w->dapm;\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct snd_soc_dai *codec_dai;\r\nstruct cht_mc_private *ctx = snd_soc_card_get_drvdata(card);\r\nint ret;\r\ncodec_dai = cht_get_codec_dai(card);\r\nif (!codec_dai) {\r\ndev_err(card->dev, "Codec dai not found; Unable to set platform clock\n");\r\nreturn -EIO;\r\n}\r\nif (SND_SOC_DAPM_EVENT_ON(event)) {\r\nif (ctx->mclk) {\r\nret = clk_prepare_enable(ctx->mclk);\r\nif (ret < 0) {\r\ndev_err(card->dev,\r\n"could not configure MCLK state");\r\nreturn ret;\r\n}\r\n}\r\n} else {\r\nret = snd_soc_dai_set_sysclk(codec_dai, RT5645_SCLK_S_RCCLK,\r\n48000 * 512, SND_SOC_CLOCK_IN);\r\nif (ret < 0) {\r\ndev_err(card->dev, "can't set codec sysclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (ctx->mclk)\r\nclk_disable_unprepare(ctx->mclk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cht_aif1_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nint ret;\r\nret = snd_soc_dai_set_pll(codec_dai, 0, RT5645_PLL1_S_MCLK,\r\nCHT_PLAT_CLK_3_HZ, params_rate(params) * 512);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set codec pll: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_dai_set_sysclk(codec_dai, RT5645_SCLK_S_PLL1,\r\nparams_rate(params) * 512, SND_SOC_CLOCK_IN);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set codec sysclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cht_codec_init(struct snd_soc_pcm_runtime *runtime)\r\n{\r\nint ret;\r\nint jack_type;\r\nstruct snd_soc_codec *codec = runtime->codec;\r\nstruct snd_soc_card *card = runtime->card;\r\nstruct cht_mc_private *ctx = snd_soc_card_get_drvdata(runtime->card);\r\nif ((cht_rt5645_quirk & CHT_RT5645_SSP2_AIF2) ||\r\n(cht_rt5645_quirk & CHT_RT5645_SSP0_AIF2)) {\r\nrt5645_sel_asrc_clk_src(codec,\r\nRT5645_DA_STEREO_FILTER |\r\nRT5645_DA_MONO_L_FILTER |\r\nRT5645_DA_MONO_R_FILTER |\r\nRT5645_AD_STEREO_FILTER,\r\nRT5645_CLK_SEL_I2S2_ASRC);\r\n} else {\r\nrt5645_sel_asrc_clk_src(codec,\r\nRT5645_DA_STEREO_FILTER |\r\nRT5645_DA_MONO_L_FILTER |\r\nRT5645_DA_MONO_R_FILTER |\r\nRT5645_AD_STEREO_FILTER,\r\nRT5645_CLK_SEL_I2S1_ASRC);\r\n}\r\nif (cht_rt5645_quirk & CHT_RT5645_SSP2_AIF2) {\r\nret = snd_soc_dapm_add_routes(&card->dapm,\r\ncht_rt5645_ssp2_aif2_map,\r\nARRAY_SIZE(cht_rt5645_ssp2_aif2_map));\r\n} else if (cht_rt5645_quirk & CHT_RT5645_SSP0_AIF1) {\r\nret = snd_soc_dapm_add_routes(&card->dapm,\r\ncht_rt5645_ssp0_aif1_map,\r\nARRAY_SIZE(cht_rt5645_ssp0_aif1_map));\r\n} else if (cht_rt5645_quirk & CHT_RT5645_SSP0_AIF2) {\r\nret = snd_soc_dapm_add_routes(&card->dapm,\r\ncht_rt5645_ssp0_aif2_map,\r\nARRAY_SIZE(cht_rt5645_ssp0_aif2_map));\r\n} else {\r\nret = snd_soc_dapm_add_routes(&card->dapm,\r\ncht_rt5645_ssp2_aif1_map,\r\nARRAY_SIZE(cht_rt5645_ssp2_aif1_map));\r\n}\r\nif (ret)\r\nreturn ret;\r\nif (ctx->acpi_card->codec_type == CODEC_TYPE_RT5650)\r\njack_type = SND_JACK_HEADPHONE | SND_JACK_MICROPHONE |\r\nSND_JACK_BTN_0 | SND_JACK_BTN_1 |\r\nSND_JACK_BTN_2 | SND_JACK_BTN_3;\r\nelse\r\njack_type = SND_JACK_HEADPHONE | SND_JACK_MICROPHONE;\r\nret = snd_soc_card_jack_new(runtime->card, "Headset",\r\njack_type, &ctx->jack,\r\ncht_bsw_jack_pins, ARRAY_SIZE(cht_bsw_jack_pins));\r\nif (ret) {\r\ndev_err(runtime->dev, "Headset jack creation failed %d\n", ret);\r\nreturn ret;\r\n}\r\nrt5645_set_jack_detect(codec, &ctx->jack, &ctx->jack, &ctx->jack);\r\nif (ctx->mclk) {\r\nret = clk_prepare_enable(ctx->mclk);\r\nif (!ret)\r\nclk_disable_unprepare(ctx->mclk);\r\nret = clk_set_rate(ctx->mclk, CHT_PLAT_CLK_3_HZ);\r\nif (ret)\r\ndev_err(runtime->dev, "unable to set MCLK rate\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int cht_codec_fixup(struct snd_soc_pcm_runtime *rtd,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nint ret;\r\nstruct snd_interval *rate = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval *channels = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nrate->min = rate->max = 48000;\r\nchannels->min = channels->max = 2;\r\nif ((cht_rt5645_quirk & CHT_RT5645_SSP0_AIF1) ||\r\n(cht_rt5645_quirk & CHT_RT5645_SSP0_AIF2)) {\r\nparams_set_format(params, SNDRV_PCM_FORMAT_S16_LE);\r\nret = snd_soc_dai_set_fmt(rtd->cpu_dai,\r\nSND_SOC_DAIFMT_I2S |\r\nSND_SOC_DAIFMT_NB_NF |\r\nSND_SOC_DAIFMT_CBS_CFS\r\n);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set format to I2S, err %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_dai_set_fmt(rtd->codec_dai,\r\nSND_SOC_DAIFMT_I2S |\r\nSND_SOC_DAIFMT_NB_NF |\r\nSND_SOC_DAIFMT_CBS_CFS\r\n);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set format to I2S, err %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_dai_set_tdm_slot(rtd->cpu_dai, 0x3, 0x3, 2, 16);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set I2S config, err %d\n", ret);\r\nreturn ret;\r\n}\r\n} else {\r\nparams_set_format(params, SNDRV_PCM_FORMAT_S24_LE);\r\nret = snd_soc_dai_set_fmt(rtd->codec_dai,\r\nSND_SOC_DAIFMT_DSP_B |\r\nSND_SOC_DAIFMT_IB_NF |\r\nSND_SOC_DAIFMT_CBS_CFS);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set format to TDM %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_dai_set_tdm_slot(rtd->codec_dai, 0xF, 0xF, 4, 24);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set codec TDM slot %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cht_aif1_startup(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_hw_constraint_single(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE, 48000);\r\n}\r\nstatic bool is_valleyview(void)\r\n{\r\nstatic const struct x86_cpu_id cpu_ids[] = {\r\n{ X86_VENDOR_INTEL, 6, 55 },\r\n{}\r\n};\r\nif (!x86_match_cpu(cpu_ids))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int snd_cht_mc_probe(struct platform_device *pdev)\r\n{\r\nint ret_val = 0;\r\nint i;\r\nstruct cht_mc_private *drv;\r\nstruct snd_soc_card *card = snd_soc_cards[0].soc_card;\r\nstruct sst_acpi_mach *mach;\r\nconst char *i2c_name = NULL;\r\nint dai_index = 0;\r\nbool found = false;\r\nbool is_bytcr = false;\r\ndrv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_ATOMIC);\r\nif (!drv)\r\nreturn -ENOMEM;\r\nmach = (&pdev->dev)->platform_data;\r\nfor (i = 0; i < ARRAY_SIZE(snd_soc_cards); i++) {\r\nif (acpi_dev_found(snd_soc_cards[i].codec_id) &&\r\n(!strncmp(snd_soc_cards[i].codec_id, mach->id, 8))) {\r\ndev_dbg(&pdev->dev,\r\n"found codec %s\n", snd_soc_cards[i].codec_id);\r\ncard = snd_soc_cards[i].soc_card;\r\ndrv->acpi_card = &snd_soc_cards[i];\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\ndev_err(&pdev->dev, "No matching HID found in supported list\n");\r\nreturn -ENODEV;\r\n}\r\ncard->dev = &pdev->dev;\r\nsprintf(drv->codec_name, "i2c-%s:00", drv->acpi_card->codec_id);\r\nfor (i = 0; i < ARRAY_SIZE(cht_dailink); i++)\r\nif (!strcmp(card->dai_link[i].codec_name, "i2c-10EC5645:00")) {\r\ncard->dai_link[i].codec_name = drv->codec_name;\r\ndai_index = i;\r\n}\r\ni2c_name = sst_acpi_find_name_from_hid(mach->id);\r\nif (i2c_name != NULL) {\r\nsnprintf(cht_rt5645_codec_name, sizeof(cht_rt5645_codec_name),\r\n"%s%s", "i2c-", i2c_name);\r\ncht_dailink[dai_index].codec_name = cht_rt5645_codec_name;\r\n}\r\nif (is_valleyview()) {\r\nstruct sst_platform_info *p_info = mach->pdata;\r\nconst struct sst_res_info *res_info = p_info->res_info;\r\nif (res_info->acpi_ipc_irq_index == 0)\r\nis_bytcr = true;\r\n}\r\nif (is_bytcr) {\r\nstruct acpi_chan_package chan_package;\r\nstruct acpi_buffer format = {sizeof("NN"), "NN"};\r\nstruct acpi_buffer state = {0, NULL};\r\nstruct sst_acpi_package_context pkg_ctx;\r\nbool pkg_found = false;\r\nstate.length = sizeof(chan_package);\r\nstate.pointer = &chan_package;\r\npkg_ctx.name = "CHAN";\r\npkg_ctx.length = 2;\r\npkg_ctx.format = &format;\r\npkg_ctx.state = &state;\r\npkg_ctx.data_valid = false;\r\npkg_found = sst_acpi_find_package_from_hid(mach->id, &pkg_ctx);\r\nif (pkg_found) {\r\nif (chan_package.aif_value == 1) {\r\ndev_info(&pdev->dev, "BIOS Routing: AIF1 connected\n");\r\ncht_rt5645_quirk |= CHT_RT5645_SSP0_AIF1;\r\n} else if (chan_package.aif_value == 2) {\r\ndev_info(&pdev->dev, "BIOS Routing: AIF2 connected\n");\r\ncht_rt5645_quirk |= CHT_RT5645_SSP0_AIF2;\r\n} else {\r\ndev_info(&pdev->dev, "BIOS Routing isn't valid, ignored\n");\r\npkg_found = false;\r\n}\r\n}\r\nif (!pkg_found) {\r\ncht_rt5645_quirk |= CHT_RT5645_SSP0_AIF2;\r\n}\r\n}\r\ndmi_check_system(cht_rt5645_quirk_table);\r\nlog_quirks(&pdev->dev);\r\nif ((cht_rt5645_quirk & CHT_RT5645_SSP2_AIF2) ||\r\n(cht_rt5645_quirk & CHT_RT5645_SSP0_AIF2)) {\r\nsnprintf(cht_rt5645_codec_aif_name,\r\nsizeof(cht_rt5645_codec_aif_name),\r\n"%s", "rt5645-aif2");\r\ncht_dailink[dai_index].codec_dai_name =\r\ncht_rt5645_codec_aif_name;\r\n}\r\nif ((cht_rt5645_quirk & CHT_RT5645_SSP0_AIF1) ||\r\n(cht_rt5645_quirk & CHT_RT5645_SSP0_AIF2)) {\r\nsnprintf(cht_rt5645_cpu_dai_name,\r\nsizeof(cht_rt5645_cpu_dai_name),\r\n"%s", "ssp0-port");\r\ncht_dailink[dai_index].cpu_dai_name =\r\ncht_rt5645_cpu_dai_name;\r\n}\r\nif (is_valleyview()) {\r\ndrv->mclk = devm_clk_get(&pdev->dev, "pmc_plt_clk_3");\r\nif (IS_ERR(drv->mclk)) {\r\ndev_err(&pdev->dev,\r\n"Failed to get MCLK from pmc_plt_clk_3: %ld\n",\r\nPTR_ERR(drv->mclk));\r\nreturn PTR_ERR(drv->mclk);\r\n}\r\n}\r\nsnd_soc_card_set_drvdata(card, drv);\r\nret_val = devm_snd_soc_register_card(&pdev->dev, card);\r\nif (ret_val) {\r\ndev_err(&pdev->dev,\r\n"snd_soc_register_card failed %d\n", ret_val);\r\nreturn ret_val;\r\n}\r\nplatform_set_drvdata(pdev, card);\r\nreturn ret_val;\r\n}
