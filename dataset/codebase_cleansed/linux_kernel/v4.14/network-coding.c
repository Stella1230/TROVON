int __init batadv_nc_init(void)\r\n{\r\nint ret;\r\nret = batadv_recv_handler_register(BATADV_CODED,\r\nbatadv_nc_recv_coded_packet);\r\nreturn ret;\r\n}\r\nstatic void batadv_nc_start_timer(struct batadv_priv *bat_priv)\r\n{\r\nqueue_delayed_work(batadv_event_workqueue, &bat_priv->nc.work,\r\nmsecs_to_jiffies(10));\r\n}\r\nstatic void batadv_nc_tvlv_container_update(struct batadv_priv *bat_priv)\r\n{\r\nchar nc_mode;\r\nnc_mode = atomic_read(&bat_priv->network_coding);\r\nswitch (nc_mode) {\r\ncase 0:\r\nbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_NC, 1);\r\nbreak;\r\ncase 1:\r\nbatadv_tvlv_container_register(bat_priv, BATADV_TVLV_NC, 1,\r\nNULL, 0);\r\nbreak;\r\n}\r\n}\r\nvoid batadv_nc_status_update(struct net_device *net_dev)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(net_dev);\r\nbatadv_nc_tvlv_container_update(bat_priv);\r\n}\r\nstatic void batadv_nc_tvlv_ogm_handler_v1(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig,\r\nu8 flags,\r\nvoid *tvlv_value, u16 tvlv_value_len)\r\n{\r\nif (flags & BATADV_TVLV_HANDLER_OGM_CIFNOTFND)\r\nclear_bit(BATADV_ORIG_CAPA_HAS_NC, &orig->capabilities);\r\nelse\r\nset_bit(BATADV_ORIG_CAPA_HAS_NC, &orig->capabilities);\r\n}\r\nint batadv_nc_mesh_init(struct batadv_priv *bat_priv)\r\n{\r\nbat_priv->nc.timestamp_fwd_flush = jiffies;\r\nbat_priv->nc.timestamp_sniffed_purge = jiffies;\r\nif (bat_priv->nc.coding_hash || bat_priv->nc.decoding_hash)\r\nreturn 0;\r\nbat_priv->nc.coding_hash = batadv_hash_new(128);\r\nif (!bat_priv->nc.coding_hash)\r\ngoto err;\r\nbatadv_hash_set_lock_class(bat_priv->nc.coding_hash,\r\n&batadv_nc_coding_hash_lock_class_key);\r\nbat_priv->nc.decoding_hash = batadv_hash_new(128);\r\nif (!bat_priv->nc.decoding_hash)\r\ngoto err;\r\nbatadv_hash_set_lock_class(bat_priv->nc.decoding_hash,\r\n&batadv_nc_decoding_hash_lock_class_key);\r\nINIT_DELAYED_WORK(&bat_priv->nc.work, batadv_nc_worker);\r\nbatadv_nc_start_timer(bat_priv);\r\nbatadv_tvlv_handler_register(bat_priv, batadv_nc_tvlv_ogm_handler_v1,\r\nNULL, BATADV_TVLV_NC, 1,\r\nBATADV_TVLV_HANDLER_OGM_CIFNOTFND);\r\nbatadv_nc_tvlv_container_update(bat_priv);\r\nreturn 0;\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nvoid batadv_nc_init_bat_priv(struct batadv_priv *bat_priv)\r\n{\r\natomic_set(&bat_priv->network_coding, 0);\r\nbat_priv->nc.min_tq = 200;\r\nbat_priv->nc.max_fwd_delay = 10;\r\nbat_priv->nc.max_buffer_time = 200;\r\n}\r\nvoid batadv_nc_init_orig(struct batadv_orig_node *orig_node)\r\n{\r\nINIT_LIST_HEAD(&orig_node->in_coding_list);\r\nINIT_LIST_HEAD(&orig_node->out_coding_list);\r\nspin_lock_init(&orig_node->in_coding_list_lock);\r\nspin_lock_init(&orig_node->out_coding_list_lock);\r\n}\r\nstatic void batadv_nc_node_release(struct kref *ref)\r\n{\r\nstruct batadv_nc_node *nc_node;\r\nnc_node = container_of(ref, struct batadv_nc_node, refcount);\r\nbatadv_orig_node_put(nc_node->orig_node);\r\nkfree_rcu(nc_node, rcu);\r\n}\r\nstatic void batadv_nc_node_put(struct batadv_nc_node *nc_node)\r\n{\r\nkref_put(&nc_node->refcount, batadv_nc_node_release);\r\n}\r\nstatic void batadv_nc_path_release(struct kref *ref)\r\n{\r\nstruct batadv_nc_path *nc_path;\r\nnc_path = container_of(ref, struct batadv_nc_path, refcount);\r\nkfree_rcu(nc_path, rcu);\r\n}\r\nstatic void batadv_nc_path_put(struct batadv_nc_path *nc_path)\r\n{\r\nkref_put(&nc_path->refcount, batadv_nc_path_release);\r\n}\r\nstatic void batadv_nc_packet_free(struct batadv_nc_packet *nc_packet,\r\nbool dropped)\r\n{\r\nif (dropped)\r\nkfree_skb(nc_packet->skb);\r\nelse\r\nconsume_skb(nc_packet->skb);\r\nbatadv_nc_path_put(nc_packet->nc_path);\r\nkfree(nc_packet);\r\n}\r\nstatic bool batadv_nc_to_purge_nc_node(struct batadv_priv *bat_priv,\r\nstruct batadv_nc_node *nc_node)\r\n{\r\nif (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)\r\nreturn true;\r\nreturn batadv_has_timed_out(nc_node->last_seen, BATADV_NC_NODE_TIMEOUT);\r\n}\r\nstatic bool batadv_nc_to_purge_nc_path_coding(struct batadv_priv *bat_priv,\r\nstruct batadv_nc_path *nc_path)\r\n{\r\nif (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)\r\nreturn true;\r\nreturn batadv_has_timed_out(nc_path->last_valid,\r\nbat_priv->nc.max_fwd_delay * 10);\r\n}\r\nstatic bool batadv_nc_to_purge_nc_path_decoding(struct batadv_priv *bat_priv,\r\nstruct batadv_nc_path *nc_path)\r\n{\r\nif (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)\r\nreturn true;\r\nreturn batadv_has_timed_out(nc_path->last_valid,\r\nbat_priv->nc.max_buffer_time * 10);\r\n}\r\nstatic void\r\nbatadv_nc_purge_orig_nc_nodes(struct batadv_priv *bat_priv,\r\nstruct list_head *list,\r\nspinlock_t *lock,\r\nbool (*to_purge)(struct batadv_priv *,\r\nstruct batadv_nc_node *))\r\n{\r\nstruct batadv_nc_node *nc_node, *nc_node_tmp;\r\nspin_lock_bh(lock);\r\nlist_for_each_entry_safe(nc_node, nc_node_tmp, list, list) {\r\nif (to_purge && !to_purge(bat_priv, nc_node))\r\ncontinue;\r\nbatadv_dbg(BATADV_DBG_NC, bat_priv,\r\n"Removing nc_node %pM -> %pM\n",\r\nnc_node->addr, nc_node->orig_node->orig);\r\nlist_del_rcu(&nc_node->list);\r\nbatadv_nc_node_put(nc_node);\r\n}\r\nspin_unlock_bh(lock);\r\n}\r\nvoid batadv_nc_purge_orig(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nbool (*to_purge)(struct batadv_priv *,\r\nstruct batadv_nc_node *))\r\n{\r\nbatadv_nc_purge_orig_nc_nodes(bat_priv, &orig_node->in_coding_list,\r\n&orig_node->in_coding_list_lock,\r\nto_purge);\r\nbatadv_nc_purge_orig_nc_nodes(bat_priv, &orig_node->out_coding_list,\r\n&orig_node->out_coding_list_lock,\r\nto_purge);\r\n}\r\nstatic void batadv_nc_purge_orig_hash(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nstruct hlist_head *head;\r\nstruct batadv_orig_node *orig_node;\r\nu32 i;\r\nif (!hash)\r\nreturn;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(orig_node, head, hash_entry)\r\nbatadv_nc_purge_orig(bat_priv, orig_node,\r\nbatadv_nc_to_purge_nc_node);\r\nrcu_read_unlock();\r\n}\r\n}\r\nstatic void batadv_nc_purge_paths(struct batadv_priv *bat_priv,\r\nstruct batadv_hashtable *hash,\r\nbool (*to_purge)(struct batadv_priv *,\r\nstruct batadv_nc_path *))\r\n{\r\nstruct hlist_head *head;\r\nstruct hlist_node *node_tmp;\r\nstruct batadv_nc_path *nc_path;\r\nspinlock_t *lock;\r\nu32 i;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlock = &hash->list_locks[i];\r\nspin_lock_bh(lock);\r\nhlist_for_each_entry_safe(nc_path, node_tmp, head, hash_entry) {\r\nif (to_purge && !to_purge(bat_priv, nc_path))\r\ncontinue;\r\nif (!unlikely(list_empty(&nc_path->packet_list))) {\r\nnet_ratelimited_function(printk,\r\nKERN_WARNING\r\n"Skipping free of non-empty nc_path (%pM -> %pM)!\n",\r\nnc_path->prev_hop,\r\nnc_path->next_hop);\r\ncontinue;\r\n}\r\nbatadv_dbg(BATADV_DBG_NC, bat_priv,\r\n"Remove nc_path %pM -> %pM\n",\r\nnc_path->prev_hop, nc_path->next_hop);\r\nhlist_del_rcu(&nc_path->hash_entry);\r\nbatadv_nc_path_put(nc_path);\r\n}\r\nspin_unlock_bh(lock);\r\n}\r\n}\r\nstatic void batadv_nc_hash_key_gen(struct batadv_nc_path *key, const char *src,\r\nconst char *dst)\r\n{\r\nmemcpy(key->prev_hop, src, sizeof(key->prev_hop));\r\nmemcpy(key->next_hop, dst, sizeof(key->next_hop));\r\n}\r\nstatic u32 batadv_nc_hash_choose(const void *data, u32 size)\r\n{\r\nconst struct batadv_nc_path *nc_path = data;\r\nu32 hash = 0;\r\nhash = jhash(&nc_path->prev_hop, sizeof(nc_path->prev_hop), hash);\r\nhash = jhash(&nc_path->next_hop, sizeof(nc_path->next_hop), hash);\r\nreturn hash % size;\r\n}\r\nstatic bool batadv_nc_hash_compare(const struct hlist_node *node,\r\nconst void *data2)\r\n{\r\nconst struct batadv_nc_path *nc_path1, *nc_path2;\r\nnc_path1 = container_of(node, struct batadv_nc_path, hash_entry);\r\nnc_path2 = data2;\r\nif (!batadv_compare_eth(nc_path1->prev_hop, nc_path2->prev_hop))\r\nreturn false;\r\nif (!batadv_compare_eth(nc_path1->next_hop, nc_path2->next_hop))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic struct batadv_nc_path *\r\nbatadv_nc_hash_find(struct batadv_hashtable *hash,\r\nvoid *data)\r\n{\r\nstruct hlist_head *head;\r\nstruct batadv_nc_path *nc_path, *nc_path_tmp = NULL;\r\nint index;\r\nif (!hash)\r\nreturn NULL;\r\nindex = batadv_nc_hash_choose(data, hash->size);\r\nhead = &hash->table[index];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(nc_path, head, hash_entry) {\r\nif (!batadv_nc_hash_compare(&nc_path->hash_entry, data))\r\ncontinue;\r\nif (!kref_get_unless_zero(&nc_path->refcount))\r\ncontinue;\r\nnc_path_tmp = nc_path;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn nc_path_tmp;\r\n}\r\nstatic void batadv_nc_send_packet(struct batadv_nc_packet *nc_packet)\r\n{\r\nbatadv_send_unicast_skb(nc_packet->skb, nc_packet->neigh_node);\r\nnc_packet->skb = NULL;\r\nbatadv_nc_packet_free(nc_packet, false);\r\n}\r\nstatic bool batadv_nc_sniffed_purge(struct batadv_priv *bat_priv,\r\nstruct batadv_nc_path *nc_path,\r\nstruct batadv_nc_packet *nc_packet)\r\n{\r\nunsigned long timeout = bat_priv->nc.max_buffer_time;\r\nbool res = false;\r\nlockdep_assert_held(&nc_path->packet_list_lock);\r\nif (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_ACTIVE &&\r\n!batadv_has_timed_out(nc_packet->timestamp, timeout))\r\ngoto out;\r\nlist_del(&nc_packet->list);\r\nbatadv_nc_packet_free(nc_packet, true);\r\nres = true;\r\nout:\r\nreturn res;\r\n}\r\nstatic bool batadv_nc_fwd_flush(struct batadv_priv *bat_priv,\r\nstruct batadv_nc_path *nc_path,\r\nstruct batadv_nc_packet *nc_packet)\r\n{\r\nunsigned long timeout = bat_priv->nc.max_fwd_delay;\r\nlockdep_assert_held(&nc_path->packet_list_lock);\r\nif (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_ACTIVE &&\r\n!batadv_has_timed_out(nc_packet->timestamp, timeout))\r\nreturn false;\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_FORWARD);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_FORWARD_BYTES,\r\nnc_packet->skb->len + ETH_HLEN);\r\nlist_del(&nc_packet->list);\r\nbatadv_nc_send_packet(nc_packet);\r\nreturn true;\r\n}\r\nstatic void\r\nbatadv_nc_process_nc_paths(struct batadv_priv *bat_priv,\r\nstruct batadv_hashtable *hash,\r\nbool (*process_fn)(struct batadv_priv *,\r\nstruct batadv_nc_path *,\r\nstruct batadv_nc_packet *))\r\n{\r\nstruct hlist_head *head;\r\nstruct batadv_nc_packet *nc_packet, *nc_packet_tmp;\r\nstruct batadv_nc_path *nc_path;\r\nbool ret;\r\nint i;\r\nif (!hash)\r\nreturn;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(nc_path, head, hash_entry) {\r\nspin_lock_bh(&nc_path->packet_list_lock);\r\nlist_for_each_entry_safe(nc_packet, nc_packet_tmp,\r\n&nc_path->packet_list, list) {\r\nret = process_fn(bat_priv, nc_path, nc_packet);\r\nif (!ret)\r\nbreak;\r\n}\r\nspin_unlock_bh(&nc_path->packet_list_lock);\r\n}\r\nrcu_read_unlock();\r\n}\r\n}\r\nstatic void batadv_nc_worker(struct work_struct *work)\r\n{\r\nstruct delayed_work *delayed_work;\r\nstruct batadv_priv_nc *priv_nc;\r\nstruct batadv_priv *bat_priv;\r\nunsigned long timeout;\r\ndelayed_work = to_delayed_work(work);\r\npriv_nc = container_of(delayed_work, struct batadv_priv_nc, work);\r\nbat_priv = container_of(priv_nc, struct batadv_priv, nc);\r\nbatadv_nc_purge_orig_hash(bat_priv);\r\nbatadv_nc_purge_paths(bat_priv, bat_priv->nc.coding_hash,\r\nbatadv_nc_to_purge_nc_path_coding);\r\nbatadv_nc_purge_paths(bat_priv, bat_priv->nc.decoding_hash,\r\nbatadv_nc_to_purge_nc_path_decoding);\r\ntimeout = bat_priv->nc.max_fwd_delay;\r\nif (batadv_has_timed_out(bat_priv->nc.timestamp_fwd_flush, timeout)) {\r\nbatadv_nc_process_nc_paths(bat_priv, bat_priv->nc.coding_hash,\r\nbatadv_nc_fwd_flush);\r\nbat_priv->nc.timestamp_fwd_flush = jiffies;\r\n}\r\nif (batadv_has_timed_out(bat_priv->nc.timestamp_sniffed_purge,\r\nbat_priv->nc.max_buffer_time)) {\r\nbatadv_nc_process_nc_paths(bat_priv, bat_priv->nc.decoding_hash,\r\nbatadv_nc_sniffed_purge);\r\nbat_priv->nc.timestamp_sniffed_purge = jiffies;\r\n}\r\nbatadv_nc_start_timer(bat_priv);\r\n}\r\nstatic bool batadv_can_nc_with_orig(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_ogm_packet *ogm_packet)\r\n{\r\nstruct batadv_orig_ifinfo *orig_ifinfo;\r\nu32 last_real_seqno;\r\nu8 last_ttl;\r\norig_ifinfo = batadv_orig_ifinfo_get(orig_node, BATADV_IF_DEFAULT);\r\nif (!orig_ifinfo)\r\nreturn false;\r\nlast_ttl = orig_ifinfo->last_ttl;\r\nlast_real_seqno = orig_ifinfo->last_real_seqno;\r\nbatadv_orig_ifinfo_put(orig_ifinfo);\r\nif (last_real_seqno != ntohl(ogm_packet->seqno))\r\nreturn false;\r\nif (last_ttl != ogm_packet->ttl + 1)\r\nreturn false;\r\nif (!batadv_compare_eth(ogm_packet->orig, ogm_packet->prev_sender))\r\nreturn false;\r\nif (ogm_packet->tq < bat_priv->nc.min_tq)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic struct batadv_nc_node *\r\nbatadv_nc_find_nc_node(struct batadv_orig_node *orig_node,\r\nstruct batadv_orig_node *orig_neigh_node,\r\nbool in_coding)\r\n{\r\nstruct batadv_nc_node *nc_node, *nc_node_out = NULL;\r\nstruct list_head *list;\r\nif (in_coding)\r\nlist = &orig_neigh_node->in_coding_list;\r\nelse\r\nlist = &orig_neigh_node->out_coding_list;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(nc_node, list, list) {\r\nif (!batadv_compare_eth(nc_node->addr, orig_node->orig))\r\ncontinue;\r\nif (!kref_get_unless_zero(&nc_node->refcount))\r\ncontinue;\r\nnc_node_out = nc_node;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn nc_node_out;\r\n}\r\nstatic struct batadv_nc_node *\r\nbatadv_nc_get_nc_node(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_orig_node *orig_neigh_node,\r\nbool in_coding)\r\n{\r\nstruct batadv_nc_node *nc_node;\r\nspinlock_t *lock;\r\nstruct list_head *list;\r\nnc_node = batadv_nc_find_nc_node(orig_node, orig_neigh_node, in_coding);\r\nif (nc_node)\r\nreturn nc_node;\r\nnc_node = kzalloc(sizeof(*nc_node), GFP_ATOMIC);\r\nif (!nc_node)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&nc_node->list);\r\nkref_init(&nc_node->refcount);\r\nether_addr_copy(nc_node->addr, orig_node->orig);\r\nkref_get(&orig_neigh_node->refcount);\r\nnc_node->orig_node = orig_neigh_node;\r\nif (in_coding) {\r\nlock = &orig_neigh_node->in_coding_list_lock;\r\nlist = &orig_neigh_node->in_coding_list;\r\n} else {\r\nlock = &orig_neigh_node->out_coding_list_lock;\r\nlist = &orig_neigh_node->out_coding_list;\r\n}\r\nbatadv_dbg(BATADV_DBG_NC, bat_priv, "Adding nc_node %pM -> %pM\n",\r\nnc_node->addr, nc_node->orig_node->orig);\r\nspin_lock_bh(lock);\r\nkref_get(&nc_node->refcount);\r\nlist_add_tail_rcu(&nc_node->list, list);\r\nspin_unlock_bh(lock);\r\nreturn nc_node;\r\n}\r\nvoid batadv_nc_update_nc_node(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_orig_node *orig_neigh_node,\r\nstruct batadv_ogm_packet *ogm_packet,\r\nint is_single_hop_neigh)\r\n{\r\nstruct batadv_nc_node *in_nc_node = NULL;\r\nstruct batadv_nc_node *out_nc_node = NULL;\r\nif (!atomic_read(&bat_priv->network_coding))\r\ngoto out;\r\nif (!test_bit(BATADV_ORIG_CAPA_HAS_NC, &orig_node->capabilities))\r\ngoto out;\r\nif (!batadv_can_nc_with_orig(bat_priv, orig_node, ogm_packet) &&\r\n!is_single_hop_neigh)\r\ngoto out;\r\nin_nc_node = batadv_nc_get_nc_node(bat_priv, orig_node,\r\norig_neigh_node, true);\r\nif (!in_nc_node)\r\ngoto out;\r\nin_nc_node->last_seen = jiffies;\r\nout_nc_node = batadv_nc_get_nc_node(bat_priv, orig_neigh_node,\r\norig_node, false);\r\nif (!out_nc_node)\r\ngoto out;\r\nout_nc_node->last_seen = jiffies;\r\nout:\r\nif (in_nc_node)\r\nbatadv_nc_node_put(in_nc_node);\r\nif (out_nc_node)\r\nbatadv_nc_node_put(out_nc_node);\r\n}\r\nstatic struct batadv_nc_path *batadv_nc_get_path(struct batadv_priv *bat_priv,\r\nstruct batadv_hashtable *hash,\r\nu8 *src,\r\nu8 *dst)\r\n{\r\nint hash_added;\r\nstruct batadv_nc_path *nc_path, nc_path_key;\r\nbatadv_nc_hash_key_gen(&nc_path_key, src, dst);\r\nnc_path = batadv_nc_hash_find(hash, (void *)&nc_path_key);\r\nif (nc_path) {\r\nnc_path->last_valid = jiffies;\r\nreturn nc_path;\r\n}\r\nnc_path = kzalloc(sizeof(*nc_path), GFP_ATOMIC);\r\nif (!nc_path)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&nc_path->packet_list);\r\nspin_lock_init(&nc_path->packet_list_lock);\r\nkref_init(&nc_path->refcount);\r\nnc_path->last_valid = jiffies;\r\nether_addr_copy(nc_path->next_hop, dst);\r\nether_addr_copy(nc_path->prev_hop, src);\r\nbatadv_dbg(BATADV_DBG_NC, bat_priv, "Adding nc_path %pM -> %pM\n",\r\nnc_path->prev_hop,\r\nnc_path->next_hop);\r\nkref_get(&nc_path->refcount);\r\nhash_added = batadv_hash_add(hash, batadv_nc_hash_compare,\r\nbatadv_nc_hash_choose, &nc_path_key,\r\n&nc_path->hash_entry);\r\nif (hash_added < 0) {\r\nkfree(nc_path);\r\nreturn NULL;\r\n}\r\nreturn nc_path;\r\n}\r\nstatic u8 batadv_nc_random_weight_tq(u8 tq)\r\n{\r\nu8 rand_val, rand_tq;\r\nget_random_bytes(&rand_val, sizeof(rand_val));\r\nrand_tq = rand_val * (BATADV_TQ_MAX_VALUE - tq);\r\nrand_tq /= BATADV_TQ_MAX_VALUE;\r\nreturn BATADV_TQ_MAX_VALUE - rand_tq;\r\n}\r\nstatic void batadv_nc_memxor(char *dst, const char *src, unsigned int len)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < len; ++i)\r\ndst[i] ^= src[i];\r\n}\r\nstatic bool batadv_nc_code_packets(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb,\r\nstruct ethhdr *ethhdr,\r\nstruct batadv_nc_packet *nc_packet,\r\nstruct batadv_neigh_node *neigh_node)\r\n{\r\nu8 tq_weighted_neigh, tq_weighted_coding, tq_tmp;\r\nstruct sk_buff *skb_dest, *skb_src;\r\nstruct batadv_unicast_packet *packet1;\r\nstruct batadv_unicast_packet *packet2;\r\nstruct batadv_coded_packet *coded_packet;\r\nstruct batadv_neigh_node *neigh_tmp, *router_neigh, *first_dest;\r\nstruct batadv_neigh_node *router_coding = NULL, *second_dest;\r\nstruct batadv_neigh_ifinfo *router_neigh_ifinfo = NULL;\r\nstruct batadv_neigh_ifinfo *router_coding_ifinfo = NULL;\r\nu8 *first_source, *second_source;\r\n__be32 packet_id1, packet_id2;\r\nsize_t count;\r\nbool res = false;\r\nint coding_len;\r\nint unicast_size = sizeof(*packet1);\r\nint coded_size = sizeof(*coded_packet);\r\nint header_add = coded_size - unicast_size;\r\nrouter_neigh = batadv_orig_router_get(neigh_node->orig_node,\r\nBATADV_IF_DEFAULT);\r\nif (!router_neigh)\r\ngoto out;\r\nrouter_neigh_ifinfo = batadv_neigh_ifinfo_get(router_neigh,\r\nBATADV_IF_DEFAULT);\r\nif (!router_neigh_ifinfo)\r\ngoto out;\r\nneigh_tmp = nc_packet->neigh_node;\r\nrouter_coding = batadv_orig_router_get(neigh_tmp->orig_node,\r\nBATADV_IF_DEFAULT);\r\nif (!router_coding)\r\ngoto out;\r\nrouter_coding_ifinfo = batadv_neigh_ifinfo_get(router_coding,\r\nBATADV_IF_DEFAULT);\r\nif (!router_coding_ifinfo)\r\ngoto out;\r\ntq_tmp = router_neigh_ifinfo->bat_iv.tq_avg;\r\ntq_weighted_neigh = batadv_nc_random_weight_tq(tq_tmp);\r\ntq_tmp = router_coding_ifinfo->bat_iv.tq_avg;\r\ntq_weighted_coding = batadv_nc_random_weight_tq(tq_tmp);\r\nif (tq_weighted_neigh >= tq_weighted_coding) {\r\nfirst_dest = nc_packet->neigh_node;\r\nfirst_source = nc_packet->nc_path->prev_hop;\r\nsecond_dest = neigh_node;\r\nsecond_source = ethhdr->h_source;\r\npacket1 = (struct batadv_unicast_packet *)nc_packet->skb->data;\r\npacket2 = (struct batadv_unicast_packet *)skb->data;\r\npacket_id1 = nc_packet->packet_id;\r\npacket_id2 = batadv_skb_crc32(skb,\r\nskb->data + sizeof(*packet2));\r\n} else {\r\nfirst_dest = neigh_node;\r\nfirst_source = ethhdr->h_source;\r\nsecond_dest = nc_packet->neigh_node;\r\nsecond_source = nc_packet->nc_path->prev_hop;\r\npacket1 = (struct batadv_unicast_packet *)skb->data;\r\npacket2 = (struct batadv_unicast_packet *)nc_packet->skb->data;\r\npacket_id1 = batadv_skb_crc32(skb,\r\nskb->data + sizeof(*packet1));\r\npacket_id2 = nc_packet->packet_id;\r\n}\r\nif (skb->len <= nc_packet->skb->len) {\r\nskb_dest = nc_packet->skb;\r\nskb_src = skb;\r\n} else {\r\nskb_dest = skb;\r\nskb_src = nc_packet->skb;\r\n}\r\ncoding_len = skb_src->len - unicast_size;\r\nif (skb_linearize(skb_dest) < 0 || skb_linearize(skb_src) < 0)\r\ngoto out;\r\nskb_push(skb_dest, header_add);\r\ncoded_packet = (struct batadv_coded_packet *)skb_dest->data;\r\nskb_reset_mac_header(skb_dest);\r\ncoded_packet->packet_type = BATADV_CODED;\r\ncoded_packet->version = BATADV_COMPAT_VERSION;\r\ncoded_packet->ttl = packet1->ttl;\r\nether_addr_copy(coded_packet->first_source, first_source);\r\nether_addr_copy(coded_packet->first_orig_dest, packet1->dest);\r\ncoded_packet->first_crc = packet_id1;\r\ncoded_packet->first_ttvn = packet1->ttvn;\r\nether_addr_copy(coded_packet->second_dest, second_dest->addr);\r\nether_addr_copy(coded_packet->second_source, second_source);\r\nether_addr_copy(coded_packet->second_orig_dest, packet2->dest);\r\ncoded_packet->second_crc = packet_id2;\r\ncoded_packet->second_ttl = packet2->ttl;\r\ncoded_packet->second_ttvn = packet2->ttvn;\r\ncoded_packet->coded_len = htons(coding_len);\r\nbatadv_nc_memxor(skb_dest->data + coded_size,\r\nskb_src->data + unicast_size, coding_len);\r\nif (BATADV_SKB_CB(skb_src)->decoded &&\r\nBATADV_SKB_CB(skb_dest)->decoded) {\r\ncount = skb_src->len + ETH_HLEN;\r\ncount += skb_dest->len + ETH_HLEN;\r\nbatadv_add_counter(bat_priv, BATADV_CNT_NC_RECODE, 2);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_NC_RECODE_BYTES, count);\r\n} else if (!BATADV_SKB_CB(skb_src)->decoded &&\r\n!BATADV_SKB_CB(skb_dest)->decoded) {\r\ncount = skb_src->len + ETH_HLEN;\r\ncount += skb_dest->len + ETH_HLEN;\r\nbatadv_add_counter(bat_priv, BATADV_CNT_NC_CODE, 2);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_NC_CODE_BYTES, count);\r\n} else if (BATADV_SKB_CB(skb_src)->decoded &&\r\n!BATADV_SKB_CB(skb_dest)->decoded) {\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_NC_RECODE);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_NC_RECODE_BYTES,\r\nskb_src->len + ETH_HLEN);\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_NC_CODE);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_NC_CODE_BYTES,\r\nskb_dest->len + ETH_HLEN);\r\n} else if (!BATADV_SKB_CB(skb_src)->decoded &&\r\nBATADV_SKB_CB(skb_dest)->decoded) {\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_NC_CODE);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_NC_CODE_BYTES,\r\nskb_src->len + ETH_HLEN);\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_NC_RECODE);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_NC_RECODE_BYTES,\r\nskb_dest->len + ETH_HLEN);\r\n}\r\nconsume_skb(skb_src);\r\nnc_packet->skb = NULL;\r\nbatadv_nc_packet_free(nc_packet, false);\r\nbatadv_send_unicast_skb(skb_dest, first_dest);\r\nres = true;\r\nout:\r\nif (router_neigh)\r\nbatadv_neigh_node_put(router_neigh);\r\nif (router_coding)\r\nbatadv_neigh_node_put(router_coding);\r\nif (router_neigh_ifinfo)\r\nbatadv_neigh_ifinfo_put(router_neigh_ifinfo);\r\nif (router_coding_ifinfo)\r\nbatadv_neigh_ifinfo_put(router_coding_ifinfo);\r\nreturn res;\r\n}\r\nstatic bool batadv_nc_skb_coding_possible(struct sk_buff *skb, u8 *dst, u8 *src)\r\n{\r\nif (BATADV_SKB_CB(skb)->decoded && !batadv_compare_eth(dst, src))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic struct batadv_nc_packet *\r\nbatadv_nc_path_search(struct batadv_priv *bat_priv,\r\nstruct batadv_nc_node *in_nc_node,\r\nstruct batadv_nc_node *out_nc_node,\r\nstruct sk_buff *skb,\r\nu8 *eth_dst)\r\n{\r\nstruct batadv_nc_path *nc_path, nc_path_key;\r\nstruct batadv_nc_packet *nc_packet_out = NULL;\r\nstruct batadv_nc_packet *nc_packet, *nc_packet_tmp;\r\nstruct batadv_hashtable *hash = bat_priv->nc.coding_hash;\r\nint idx;\r\nif (!hash)\r\nreturn NULL;\r\nbatadv_nc_hash_key_gen(&nc_path_key, in_nc_node->addr,\r\nout_nc_node->addr);\r\nidx = batadv_nc_hash_choose(&nc_path_key, hash->size);\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(nc_path, &hash->table[idx], hash_entry) {\r\nif (!batadv_compare_eth(nc_path->prev_hop, in_nc_node->addr))\r\ncontinue;\r\nif (!batadv_compare_eth(nc_path->next_hop, out_nc_node->addr))\r\ncontinue;\r\nspin_lock_bh(&nc_path->packet_list_lock);\r\nif (list_empty(&nc_path->packet_list)) {\r\nspin_unlock_bh(&nc_path->packet_list_lock);\r\ncontinue;\r\n}\r\nlist_for_each_entry_safe(nc_packet, nc_packet_tmp,\r\n&nc_path->packet_list, list) {\r\nif (!batadv_nc_skb_coding_possible(nc_packet->skb,\r\neth_dst,\r\nin_nc_node->addr))\r\ncontinue;\r\nlist_del(&nc_packet->list);\r\nnc_packet_out = nc_packet;\r\nbreak;\r\n}\r\nspin_unlock_bh(&nc_path->packet_list_lock);\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn nc_packet_out;\r\n}\r\nstatic struct batadv_nc_packet *\r\nbatadv_nc_skb_src_search(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb,\r\nu8 *eth_dst,\r\nu8 *eth_src,\r\nstruct batadv_nc_node *in_nc_node)\r\n{\r\nstruct batadv_orig_node *orig_node;\r\nstruct batadv_nc_node *out_nc_node;\r\nstruct batadv_nc_packet *nc_packet = NULL;\r\norig_node = batadv_orig_hash_find(bat_priv, eth_src);\r\nif (!orig_node)\r\nreturn NULL;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(out_nc_node,\r\n&orig_node->out_coding_list, list) {\r\nif (!batadv_nc_skb_coding_possible(skb,\r\nout_nc_node->addr, eth_src))\r\ncontinue;\r\nnc_packet = batadv_nc_path_search(bat_priv, in_nc_node,\r\nout_nc_node, skb, eth_dst);\r\nif (nc_packet)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nbatadv_orig_node_put(orig_node);\r\nreturn nc_packet;\r\n}\r\nstatic void batadv_nc_skb_store_before_coding(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb,\r\nu8 *eth_dst_new)\r\n{\r\nstruct ethhdr *ethhdr;\r\nskb = pskb_copy_for_clone(skb, GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nethhdr = eth_hdr(skb);\r\nether_addr_copy(ethhdr->h_source, ethhdr->h_dest);\r\nether_addr_copy(ethhdr->h_dest, eth_dst_new);\r\nskb_push(skb, ETH_HLEN);\r\nbatadv_nc_skb_store_for_decoding(bat_priv, skb);\r\nconsume_skb(skb);\r\n}\r\nstatic bool batadv_nc_skb_dst_search(struct sk_buff *skb,\r\nstruct batadv_neigh_node *neigh_node,\r\nstruct ethhdr *ethhdr)\r\n{\r\nstruct net_device *netdev = neigh_node->if_incoming->soft_iface;\r\nstruct batadv_priv *bat_priv = netdev_priv(netdev);\r\nstruct batadv_orig_node *orig_node = neigh_node->orig_node;\r\nstruct batadv_nc_node *nc_node;\r\nstruct batadv_nc_packet *nc_packet = NULL;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(nc_node, &orig_node->in_coding_list, list) {\r\nnc_packet = batadv_nc_skb_src_search(bat_priv, skb,\r\nneigh_node->addr,\r\nethhdr->h_source, nc_node);\r\nif (nc_packet)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (!nc_packet)\r\nreturn false;\r\nbatadv_nc_skb_store_before_coding(bat_priv, skb,\r\nneigh_node->addr);\r\nbatadv_nc_skb_store_before_coding(bat_priv, nc_packet->skb,\r\nnc_packet->neigh_node->addr);\r\nif (batadv_nc_code_packets(bat_priv, skb, ethhdr, nc_packet,\r\nneigh_node))\r\nreturn true;\r\nbatadv_nc_send_packet(nc_packet);\r\nreturn false;\r\n}\r\nstatic bool batadv_nc_skb_add_to_path(struct sk_buff *skb,\r\nstruct batadv_nc_path *nc_path,\r\nstruct batadv_neigh_node *neigh_node,\r\n__be32 packet_id)\r\n{\r\nstruct batadv_nc_packet *nc_packet;\r\nnc_packet = kzalloc(sizeof(*nc_packet), GFP_ATOMIC);\r\nif (!nc_packet)\r\nreturn false;\r\nnc_packet->timestamp = jiffies;\r\nnc_packet->packet_id = packet_id;\r\nnc_packet->skb = skb;\r\nnc_packet->neigh_node = neigh_node;\r\nnc_packet->nc_path = nc_path;\r\nspin_lock_bh(&nc_path->packet_list_lock);\r\nlist_add_tail(&nc_packet->list, &nc_path->packet_list);\r\nspin_unlock_bh(&nc_path->packet_list_lock);\r\nreturn true;\r\n}\r\nbool batadv_nc_skb_forward(struct sk_buff *skb,\r\nstruct batadv_neigh_node *neigh_node)\r\n{\r\nconst struct net_device *netdev = neigh_node->if_incoming->soft_iface;\r\nstruct batadv_priv *bat_priv = netdev_priv(netdev);\r\nstruct batadv_unicast_packet *packet;\r\nstruct batadv_nc_path *nc_path;\r\nstruct ethhdr *ethhdr = eth_hdr(skb);\r\n__be32 packet_id;\r\nu8 *payload;\r\nif (!atomic_read(&bat_priv->network_coding))\r\ngoto out;\r\npayload = skb_network_header(skb);\r\npacket = (struct batadv_unicast_packet *)payload;\r\nif (packet->packet_type != BATADV_UNICAST)\r\ngoto out;\r\nif (batadv_nc_skb_dst_search(skb, neigh_node, ethhdr))\r\nreturn true;\r\nnc_path = batadv_nc_get_path(bat_priv,\r\nbat_priv->nc.coding_hash,\r\nethhdr->h_source,\r\nneigh_node->addr);\r\nif (!nc_path)\r\ngoto out;\r\npacket_id = batadv_skb_crc32(skb, payload + sizeof(*packet));\r\nif (!batadv_nc_skb_add_to_path(skb, nc_path, neigh_node, packet_id))\r\ngoto free_nc_path;\r\nreturn true;\r\nfree_nc_path:\r\nbatadv_nc_path_put(nc_path);\r\nout:\r\nreturn false;\r\n}\r\nvoid batadv_nc_skb_store_for_decoding(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct batadv_unicast_packet *packet;\r\nstruct batadv_nc_path *nc_path;\r\nstruct ethhdr *ethhdr = eth_hdr(skb);\r\n__be32 packet_id;\r\nu8 *payload;\r\nif (!atomic_read(&bat_priv->network_coding))\r\ngoto out;\r\npayload = skb_network_header(skb);\r\npacket = (struct batadv_unicast_packet *)payload;\r\nif (packet->packet_type != BATADV_UNICAST)\r\ngoto out;\r\nnc_path = batadv_nc_get_path(bat_priv,\r\nbat_priv->nc.decoding_hash,\r\nethhdr->h_source,\r\nethhdr->h_dest);\r\nif (!nc_path)\r\ngoto out;\r\nskb = skb_clone(skb, GFP_ATOMIC);\r\nif (unlikely(!skb))\r\ngoto free_nc_path;\r\nif (unlikely(!pskb_may_pull(skb, ETH_HLEN)))\r\ngoto free_skb;\r\nif (unlikely(!skb_pull_rcsum(skb, ETH_HLEN)))\r\ngoto free_skb;\r\npacket_id = batadv_skb_crc32(skb, payload + sizeof(*packet));\r\nif (!batadv_nc_skb_add_to_path(skb, nc_path, NULL, packet_id))\r\ngoto free_skb;\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_NC_BUFFER);\r\nreturn;\r\nfree_skb:\r\nkfree_skb(skb);\r\nfree_nc_path:\r\nbatadv_nc_path_put(nc_path);\r\nout:\r\nreturn;\r\n}\r\nvoid batadv_nc_skb_store_sniffed_unicast(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ethhdr *ethhdr = eth_hdr(skb);\r\nif (batadv_is_my_mac(bat_priv, ethhdr->h_dest))\r\nreturn;\r\nskb_push(skb, ETH_HLEN);\r\nbatadv_nc_skb_store_for_decoding(bat_priv, skb);\r\n}\r\nstatic struct batadv_unicast_packet *\r\nbatadv_nc_skb_decode_packet(struct batadv_priv *bat_priv, struct sk_buff *skb,\r\nstruct batadv_nc_packet *nc_packet)\r\n{\r\nconst int h_size = sizeof(struct batadv_unicast_packet);\r\nconst int h_diff = sizeof(struct batadv_coded_packet) - h_size;\r\nstruct batadv_unicast_packet *unicast_packet;\r\nstruct batadv_coded_packet coded_packet_tmp;\r\nstruct ethhdr *ethhdr, ethhdr_tmp;\r\nu8 *orig_dest, ttl, ttvn;\r\nunsigned int coding_len;\r\nint err;\r\nmemcpy(&coded_packet_tmp, skb->data, sizeof(coded_packet_tmp));\r\nmemcpy(&ethhdr_tmp, skb_mac_header(skb), sizeof(ethhdr_tmp));\r\nif (skb_cow(skb, 0) < 0)\r\nreturn NULL;\r\nif (unlikely(!skb_pull_rcsum(skb, h_diff)))\r\nreturn NULL;\r\nskb_set_mac_header(skb, -ETH_HLEN);\r\nskb_reset_network_header(skb);\r\nethhdr = eth_hdr(skb);\r\n*ethhdr = ethhdr_tmp;\r\nif (batadv_is_my_mac(bat_priv, coded_packet_tmp.second_dest)) {\r\nether_addr_copy(ethhdr->h_dest, coded_packet_tmp.second_dest);\r\nskb->pkt_type = PACKET_HOST;\r\norig_dest = coded_packet_tmp.second_orig_dest;\r\nttl = coded_packet_tmp.second_ttl;\r\nttvn = coded_packet_tmp.second_ttvn;\r\n} else {\r\norig_dest = coded_packet_tmp.first_orig_dest;\r\nttl = coded_packet_tmp.ttl;\r\nttvn = coded_packet_tmp.first_ttvn;\r\n}\r\ncoding_len = ntohs(coded_packet_tmp.coded_len);\r\nif (coding_len > skb->len)\r\nreturn NULL;\r\nbatadv_nc_memxor(skb->data + h_size,\r\nnc_packet->skb->data + h_size,\r\ncoding_len);\r\nif (nc_packet->skb->len > coding_len + h_size) {\r\nerr = pskb_trim_rcsum(skb, coding_len + h_size);\r\nif (err)\r\nreturn NULL;\r\n}\r\nunicast_packet = (struct batadv_unicast_packet *)skb->data;\r\nunicast_packet->packet_type = BATADV_UNICAST;\r\nunicast_packet->version = BATADV_COMPAT_VERSION;\r\nunicast_packet->ttl = ttl;\r\nether_addr_copy(unicast_packet->dest, orig_dest);\r\nunicast_packet->ttvn = ttvn;\r\nbatadv_nc_packet_free(nc_packet, false);\r\nreturn unicast_packet;\r\n}\r\nstatic struct batadv_nc_packet *\r\nbatadv_nc_find_decoding_packet(struct batadv_priv *bat_priv,\r\nstruct ethhdr *ethhdr,\r\nstruct batadv_coded_packet *coded)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->nc.decoding_hash;\r\nstruct batadv_nc_packet *tmp_nc_packet, *nc_packet = NULL;\r\nstruct batadv_nc_path *nc_path, nc_path_key;\r\nu8 *dest, *source;\r\n__be32 packet_id;\r\nint index;\r\nif (!hash)\r\nreturn NULL;\r\ndest = ethhdr->h_source;\r\nif (!batadv_is_my_mac(bat_priv, coded->second_dest)) {\r\nsource = coded->second_source;\r\npacket_id = coded->second_crc;\r\n} else {\r\nsource = coded->first_source;\r\npacket_id = coded->first_crc;\r\n}\r\nbatadv_nc_hash_key_gen(&nc_path_key, source, dest);\r\nindex = batadv_nc_hash_choose(&nc_path_key, hash->size);\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(nc_path, &hash->table[index], hash_entry) {\r\nspin_lock_bh(&nc_path->packet_list_lock);\r\nlist_for_each_entry(tmp_nc_packet,\r\n&nc_path->packet_list, list) {\r\nif (packet_id == tmp_nc_packet->packet_id) {\r\nlist_del(&tmp_nc_packet->list);\r\nnc_packet = tmp_nc_packet;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&nc_path->packet_list_lock);\r\nif (nc_packet)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (!nc_packet)\r\nbatadv_dbg(BATADV_DBG_NC, bat_priv,\r\n"No decoding packet found for %u\n", packet_id);\r\nreturn nc_packet;\r\n}\r\nstatic int batadv_nc_recv_coded_packet(struct sk_buff *skb,\r\nstruct batadv_hard_iface *recv_if)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);\r\nstruct batadv_unicast_packet *unicast_packet;\r\nstruct batadv_coded_packet *coded_packet;\r\nstruct batadv_nc_packet *nc_packet;\r\nstruct ethhdr *ethhdr;\r\nint hdr_size = sizeof(*coded_packet);\r\nif (!atomic_read(&bat_priv->network_coding))\r\ngoto free_skb;\r\nif (unlikely(!pskb_may_pull(skb, hdr_size)))\r\ngoto free_skb;\r\ncoded_packet = (struct batadv_coded_packet *)skb->data;\r\nethhdr = eth_hdr(skb);\r\nif (!batadv_is_my_mac(bat_priv, ethhdr->h_dest) &&\r\n!batadv_is_my_mac(bat_priv, coded_packet->second_dest))\r\ngoto free_skb;\r\nif (batadv_is_my_mac(bat_priv, coded_packet->second_dest))\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_NC_SNIFFED);\r\nnc_packet = batadv_nc_find_decoding_packet(bat_priv, ethhdr,\r\ncoded_packet);\r\nif (!nc_packet) {\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_NC_DECODE_FAILED);\r\ngoto free_skb;\r\n}\r\nif (skb_linearize(skb) < 0)\r\ngoto free_nc_packet;\r\nif (skb_linearize(nc_packet->skb) < 0)\r\ngoto free_nc_packet;\r\nunicast_packet = batadv_nc_skb_decode_packet(bat_priv, skb, nc_packet);\r\nif (!unicast_packet) {\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_NC_DECODE_FAILED);\r\ngoto free_nc_packet;\r\n}\r\nBATADV_SKB_CB(skb)->decoded = true;\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_NC_DECODE);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_NC_DECODE_BYTES,\r\nskb->len + ETH_HLEN);\r\nreturn batadv_recv_unicast_packet(skb, recv_if);\r\nfree_nc_packet:\r\nbatadv_nc_packet_free(nc_packet, true);\r\nfree_skb:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nvoid batadv_nc_mesh_free(struct batadv_priv *bat_priv)\r\n{\r\nbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_NC, 1);\r\nbatadv_tvlv_handler_unregister(bat_priv, BATADV_TVLV_NC, 1);\r\ncancel_delayed_work_sync(&bat_priv->nc.work);\r\nbatadv_nc_purge_paths(bat_priv, bat_priv->nc.coding_hash, NULL);\r\nbatadv_hash_destroy(bat_priv->nc.coding_hash);\r\nbatadv_nc_purge_paths(bat_priv, bat_priv->nc.decoding_hash, NULL);\r\nbatadv_hash_destroy(bat_priv->nc.decoding_hash);\r\n}\r\nint batadv_nc_nodes_seq_print_text(struct seq_file *seq, void *offset)\r\n{\r\nstruct net_device *net_dev = (struct net_device *)seq->private;\r\nstruct batadv_priv *bat_priv = netdev_priv(net_dev);\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nstruct batadv_hard_iface *primary_if;\r\nstruct hlist_head *head;\r\nstruct batadv_orig_node *orig_node;\r\nstruct batadv_nc_node *nc_node;\r\nint i;\r\nprimary_if = batadv_seq_print_text_primary_if_get(seq);\r\nif (!primary_if)\r\ngoto out;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(orig_node, head, hash_entry) {\r\nif (list_empty(&orig_node->in_coding_list) &&\r\nlist_empty(&orig_node->out_coding_list))\r\ncontinue;\r\nseq_printf(seq, "Node: %pM\n", orig_node->orig);\r\nseq_puts(seq, " Ingoing: ");\r\nlist_for_each_entry_rcu(nc_node,\r\n&orig_node->in_coding_list,\r\nlist)\r\nseq_printf(seq, "%pM ",\r\nnc_node->addr);\r\nseq_puts(seq, "\n Outgoing: ");\r\nlist_for_each_entry_rcu(nc_node,\r\n&orig_node->out_coding_list,\r\nlist)\r\nseq_printf(seq, "%pM ",\r\nnc_node->addr);\r\nseq_puts(seq, "\n\n");\r\n}\r\nrcu_read_unlock();\r\n}\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\nreturn 0;\r\n}\r\nint batadv_nc_init_debugfs(struct batadv_priv *bat_priv)\r\n{\r\nstruct dentry *nc_dir, *file;\r\nnc_dir = debugfs_create_dir("nc", bat_priv->debug_dir);\r\nif (!nc_dir)\r\ngoto out;\r\nfile = debugfs_create_u8("min_tq", 0644, nc_dir, &bat_priv->nc.min_tq);\r\nif (!file)\r\ngoto out;\r\nfile = debugfs_create_u32("max_fwd_delay", 0644, nc_dir,\r\n&bat_priv->nc.max_fwd_delay);\r\nif (!file)\r\ngoto out;\r\nfile = debugfs_create_u32("max_buffer_time", 0644, nc_dir,\r\n&bat_priv->nc.max_buffer_time);\r\nif (!file)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nreturn -ENOMEM;\r\n}
