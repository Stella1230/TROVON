static void iwlagn_tx_cmd_protection(struct iwl_priv *priv,\r\nstruct ieee80211_tx_info *info,\r\n__le16 fc, __le32 *tx_flags)\r\n{\r\nif (info->control.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS ||\r\ninfo->control.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT ||\r\ninfo->flags & IEEE80211_TX_CTL_AMPDU)\r\n*tx_flags |= TX_CMD_FLG_PROT_REQUIRE_MSK;\r\n}\r\nstatic void iwlagn_tx_cmd_build_basic(struct iwl_priv *priv,\r\nstruct sk_buff *skb,\r\nstruct iwl_tx_cmd *tx_cmd,\r\nstruct ieee80211_tx_info *info,\r\nstruct ieee80211_hdr *hdr, u8 sta_id)\r\n{\r\n__le16 fc = hdr->frame_control;\r\n__le32 tx_flags = tx_cmd->tx_flags;\r\ntx_cmd->stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\r\nif (!(info->flags & IEEE80211_TX_CTL_NO_ACK))\r\ntx_flags |= TX_CMD_FLG_ACK_MSK;\r\nelse\r\ntx_flags &= ~TX_CMD_FLG_ACK_MSK;\r\nif (ieee80211_is_probe_resp(fc))\r\ntx_flags |= TX_CMD_FLG_TSF_MSK;\r\nelse if (ieee80211_is_back_req(fc))\r\ntx_flags |= TX_CMD_FLG_ACK_MSK | TX_CMD_FLG_IMM_BA_RSP_MASK;\r\nelse if (info->band == NL80211_BAND_2GHZ &&\r\npriv->lib->bt_params &&\r\npriv->lib->bt_params->advanced_bt_coexist &&\r\n(ieee80211_is_auth(fc) || ieee80211_is_assoc_req(fc) ||\r\nieee80211_is_reassoc_req(fc) ||\r\ninfo->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))\r\ntx_flags |= TX_CMD_FLG_IGNORE_BT;\r\ntx_cmd->sta_id = sta_id;\r\nif (ieee80211_has_morefrags(fc))\r\ntx_flags |= TX_CMD_FLG_MORE_FRAG_MSK;\r\nif (ieee80211_is_data_qos(fc)) {\r\nu8 *qc = ieee80211_get_qos_ctl(hdr);\r\ntx_cmd->tid_tspec = qc[0] & 0xf;\r\ntx_flags &= ~TX_CMD_FLG_SEQ_CTL_MSK;\r\n} else {\r\ntx_cmd->tid_tspec = IWL_TID_NON_QOS;\r\nif (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ)\r\ntx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\r\nelse\r\ntx_flags &= ~TX_CMD_FLG_SEQ_CTL_MSK;\r\n}\r\niwlagn_tx_cmd_protection(priv, info, fc, &tx_flags);\r\ntx_flags &= ~(TX_CMD_FLG_ANT_SEL_MSK);\r\nif (ieee80211_is_mgmt(fc)) {\r\nif (ieee80211_is_assoc_req(fc) || ieee80211_is_reassoc_req(fc))\r\ntx_cmd->timeout.pm_frame_timeout = cpu_to_le16(3);\r\nelse\r\ntx_cmd->timeout.pm_frame_timeout = cpu_to_le16(2);\r\n} else {\r\ntx_cmd->timeout.pm_frame_timeout = 0;\r\n}\r\ntx_cmd->driver_txop = 0;\r\ntx_cmd->tx_flags = tx_flags;\r\ntx_cmd->next_frame_len = 0;\r\n}\r\nstatic void iwlagn_tx_cmd_build_rate(struct iwl_priv *priv,\r\nstruct iwl_tx_cmd *tx_cmd,\r\nstruct ieee80211_tx_info *info,\r\nstruct ieee80211_sta *sta,\r\n__le16 fc)\r\n{\r\nu32 rate_flags;\r\nint rate_idx;\r\nu8 rts_retry_limit;\r\nu8 data_retry_limit;\r\nu8 rate_plcp;\r\nif (priv->wowlan) {\r\nrts_retry_limit = IWLAGN_LOW_RETRY_LIMIT;\r\ndata_retry_limit = IWLAGN_LOW_RETRY_LIMIT;\r\n} else {\r\nrts_retry_limit = IWLAGN_RTS_DFAULT_RETRY_LIMIT;\r\nif (ieee80211_is_probe_resp(fc)) {\r\ndata_retry_limit = IWLAGN_MGMT_DFAULT_RETRY_LIMIT;\r\nrts_retry_limit =\r\nmin(data_retry_limit, rts_retry_limit);\r\n} else if (ieee80211_is_back_req(fc))\r\ndata_retry_limit = IWLAGN_BAR_DFAULT_RETRY_LIMIT;\r\nelse\r\ndata_retry_limit = IWLAGN_DEFAULT_TX_RETRY;\r\n}\r\ntx_cmd->data_retry_limit = data_retry_limit;\r\ntx_cmd->rts_retry_limit = rts_retry_limit;\r\nif (ieee80211_is_data(fc)) {\r\ntx_cmd->initial_rate_index = 0;\r\ntx_cmd->tx_flags |= TX_CMD_FLG_STA_RATE_MSK;\r\nreturn;\r\n} else if (ieee80211_is_back_req(fc))\r\ntx_cmd->tx_flags |= TX_CMD_FLG_STA_RATE_MSK;\r\nrate_idx = info->control.rates[0].idx;\r\nif (info->control.rates[0].flags & IEEE80211_TX_RC_MCS ||\r\n(rate_idx < 0) || (rate_idx > IWL_RATE_COUNT_LEGACY))\r\nrate_idx = rate_lowest_index(\r\n&priv->nvm_data->bands[info->band], sta);\r\nif (info->band == NL80211_BAND_5GHZ)\r\nrate_idx += IWL_FIRST_OFDM_RATE;\r\nrate_plcp = iwl_rates[rate_idx].plcp;\r\nrate_flags = 0;\r\nif ((rate_idx >= IWL_FIRST_CCK_RATE) && (rate_idx <= IWL_LAST_CCK_RATE))\r\nrate_flags |= RATE_MCS_CCK_MSK;\r\nif (priv->lib->bt_params &&\r\npriv->lib->bt_params->advanced_bt_coexist &&\r\npriv->bt_full_concurrent) {\r\npriv->mgmt_tx_ant = iwl_toggle_tx_ant(priv, priv->mgmt_tx_ant,\r\nfirst_antenna(priv->nvm_data->valid_tx_ant));\r\n} else\r\npriv->mgmt_tx_ant = iwl_toggle_tx_ant(\r\npriv, priv->mgmt_tx_ant,\r\npriv->nvm_data->valid_tx_ant);\r\nrate_flags |= iwl_ant_idx_to_flags(priv->mgmt_tx_ant);\r\ntx_cmd->rate_n_flags = iwl_hw_set_rate_n_flags(rate_plcp, rate_flags);\r\n}\r\nstatic void iwlagn_tx_cmd_build_hwcrypto(struct iwl_priv *priv,\r\nstruct ieee80211_tx_info *info,\r\nstruct iwl_tx_cmd *tx_cmd,\r\nstruct sk_buff *skb_frag)\r\n{\r\nstruct ieee80211_key_conf *keyconf = info->control.hw_key;\r\nswitch (keyconf->cipher) {\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\ntx_cmd->sec_ctl = TX_CMD_SEC_CCM;\r\nmemcpy(tx_cmd->key, keyconf->key, keyconf->keylen);\r\nif (info->flags & IEEE80211_TX_CTL_AMPDU)\r\ntx_cmd->tx_flags |= TX_CMD_FLG_AGG_CCMP_MSK;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\ntx_cmd->sec_ctl = TX_CMD_SEC_TKIP;\r\nieee80211_get_tkip_p2k(keyconf, skb_frag, tx_cmd->key);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\ntx_cmd->sec_ctl |= TX_CMD_SEC_KEY128;\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ntx_cmd->sec_ctl |= (TX_CMD_SEC_WEP |\r\n(keyconf->keyidx & TX_CMD_SEC_MSK) << TX_CMD_SEC_SHIFT);\r\nmemcpy(&tx_cmd->key[3], keyconf->key, keyconf->keylen);\r\nIWL_DEBUG_TX(priv, "Configuring packet for WEP encryption "\r\n"with key %d\n", keyconf->keyidx);\r\nbreak;\r\ndefault:\r\nIWL_ERR(priv, "Unknown encode cipher %x\n", keyconf->cipher);\r\nbreak;\r\n}\r\n}\r\nstatic int iwl_sta_id_or_broadcast(struct iwl_rxon_context *context,\r\nstruct ieee80211_sta *sta)\r\n{\r\nint sta_id;\r\nif (!sta)\r\nreturn context->bcast_sta_id;\r\nsta_id = iwl_sta_id(sta);\r\nWARN_ON(sta_id == IWL_INVALID_STATION);\r\nreturn sta_id;\r\n}\r\nint iwlagn_tx_skb(struct iwl_priv *priv,\r\nstruct ieee80211_sta *sta,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct iwl_station_priv *sta_priv = NULL;\r\nstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\r\nstruct iwl_device_cmd *dev_cmd;\r\nstruct iwl_tx_cmd *tx_cmd;\r\n__le16 fc;\r\nu8 hdr_len;\r\nu16 len, seq_number = 0;\r\nu8 sta_id, tid = IWL_MAX_TID_COUNT;\r\nbool is_agg = false, is_data_qos = false;\r\nint txq_id;\r\nif (info->control.vif)\r\nctx = iwl_rxon_ctx_from_vif(info->control.vif);\r\nif (iwl_is_rfkill(priv)) {\r\nIWL_DEBUG_DROP(priv, "Dropping - RF KILL\n");\r\ngoto drop_unlock_priv;\r\n}\r\nfc = hdr->frame_control;\r\n#ifdef CONFIG_IWLWIFI_DEBUG\r\nif (ieee80211_is_auth(fc))\r\nIWL_DEBUG_TX(priv, "Sending AUTH frame\n");\r\nelse if (ieee80211_is_assoc_req(fc))\r\nIWL_DEBUG_TX(priv, "Sending ASSOC frame\n");\r\nelse if (ieee80211_is_reassoc_req(fc))\r\nIWL_DEBUG_TX(priv, "Sending REASSOC frame\n");\r\n#endif\r\nif (unlikely(ieee80211_is_probe_resp(fc))) {\r\nstruct iwl_wipan_noa_data *noa_data =\r\nrcu_dereference(priv->noa_data);\r\nif (noa_data &&\r\npskb_expand_head(skb, 0, noa_data->length,\r\nGFP_ATOMIC) == 0) {\r\nskb_put_data(skb, noa_data->data, noa_data->length);\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\n}\r\n}\r\nhdr_len = ieee80211_hdrlen(fc);\r\nif (!ieee80211_is_data(fc))\r\nsta_id = ctx->bcast_sta_id;\r\nelse {\r\nsta_id = iwl_sta_id_or_broadcast(ctx, sta);\r\nif (sta_id == IWL_INVALID_STATION) {\r\nIWL_DEBUG_DROP(priv, "Dropping - INVALID STATION: %pM\n",\r\nhdr->addr1);\r\ngoto drop_unlock_priv;\r\n}\r\n}\r\nif (sta)\r\nsta_priv = (void *)sta->drv_priv;\r\nif (sta_priv && sta_priv->asleep &&\r\n(info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER)) {\r\niwl_sta_modify_sleep_tx_count(priv, sta_id, 1);\r\n}\r\ndev_cmd = iwl_trans_alloc_tx_cmd(priv->trans);\r\nif (unlikely(!dev_cmd))\r\ngoto drop_unlock_priv;\r\nmemset(dev_cmd, 0, sizeof(*dev_cmd));\r\ndev_cmd->hdr.cmd = REPLY_TX;\r\ntx_cmd = (struct iwl_tx_cmd *) dev_cmd->payload;\r\nlen = (u16)skb->len;\r\ntx_cmd->len = cpu_to_le16(len);\r\nif (info->control.hw_key)\r\niwlagn_tx_cmd_build_hwcrypto(priv, info, tx_cmd, skb);\r\niwlagn_tx_cmd_build_basic(priv, skb, tx_cmd, info, hdr, sta_id);\r\niwlagn_tx_cmd_build_rate(priv, tx_cmd, info, sta, fc);\r\nmemset(&info->status, 0, sizeof(info->status));\r\nmemset(info->driver_data, 0, sizeof(info->driver_data));\r\ninfo->driver_data[0] = ctx;\r\ninfo->driver_data[1] = dev_cmd;\r\nspin_lock(&priv->sta_lock);\r\nif (ieee80211_is_data_qos(fc) && !ieee80211_is_qos_nullfunc(fc)) {\r\nu8 *qc = NULL;\r\nstruct iwl_tid_data *tid_data;\r\nqc = ieee80211_get_qos_ctl(hdr);\r\ntid = qc[0] & IEEE80211_QOS_CTL_TID_MASK;\r\nif (WARN_ON_ONCE(tid >= IWL_MAX_TID_COUNT))\r\ngoto drop_unlock_sta;\r\ntid_data = &priv->tid_data[sta_id][tid];\r\nif (info->flags & IEEE80211_TX_CTL_AMPDU &&\r\ntid_data->agg.state != IWL_AGG_ON) {\r\nIWL_ERR(priv,\r\n"TX_CTL_AMPDU while not in AGG: Tx flags = 0x%08x, agg.state = %d\n",\r\ninfo->flags, tid_data->agg.state);\r\nIWL_ERR(priv, "sta_id = %d, tid = %d seq_num = %d\n",\r\nsta_id, tid,\r\nIEEE80211_SEQ_TO_SN(tid_data->seq_number));\r\ngoto drop_unlock_sta;\r\n}\r\nif (WARN_ONCE(tid_data->agg.state != IWL_AGG_ON &&\r\ntid_data->agg.state != IWL_AGG_OFF,\r\n"Tx while agg.state = %d\n", tid_data->agg.state))\r\ngoto drop_unlock_sta;\r\nseq_number = tid_data->seq_number;\r\nseq_number &= IEEE80211_SCTL_SEQ;\r\nhdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\r\nhdr->seq_ctrl |= cpu_to_le16(seq_number);\r\nseq_number += 0x10;\r\nif (info->flags & IEEE80211_TX_CTL_AMPDU)\r\nis_agg = true;\r\nis_data_qos = true;\r\n}\r\nmemcpy(tx_cmd->hdr, hdr, hdr_len);\r\ntxq_id = info->hw_queue;\r\nif (is_agg)\r\ntxq_id = priv->tid_data[sta_id][tid].agg.txq_id;\r\nelse if (info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) {\r\nhdr->frame_control |=\r\ncpu_to_le16(IEEE80211_FCTL_MOREDATA);\r\n}\r\nWARN_ON_ONCE(is_agg &&\r\npriv->queue_to_mac80211[txq_id] != info->hw_queue);\r\nIWL_DEBUG_TX(priv, "TX to [%d|%d] Q:%d - seq: 0x%x\n", sta_id, tid,\r\ntxq_id, seq_number);\r\nif (iwl_trans_tx(priv->trans, skb, dev_cmd, txq_id))\r\ngoto drop_unlock_sta;\r\nif (is_data_qos && !ieee80211_has_morefrags(fc))\r\npriv->tid_data[sta_id][tid].seq_number = seq_number;\r\nspin_unlock(&priv->sta_lock);\r\nif (sta_priv && sta_priv->client && !is_agg)\r\natomic_inc(&sta_priv->pending_frames);\r\nreturn 0;\r\ndrop_unlock_sta:\r\nif (dev_cmd)\r\niwl_trans_free_tx_cmd(priv->trans, dev_cmd);\r\nspin_unlock(&priv->sta_lock);\r\ndrop_unlock_priv:\r\nreturn -1;\r\n}\r\nstatic int iwlagn_alloc_agg_txq(struct iwl_priv *priv, int mq)\r\n{\r\nint q;\r\nfor (q = IWLAGN_FIRST_AMPDU_QUEUE;\r\nq < priv->cfg->base_params->num_of_queues; q++) {\r\nif (!test_and_set_bit(q, priv->agg_q_alloc)) {\r\npriv->queue_to_mac80211[q] = mq;\r\nreturn q;\r\n}\r\n}\r\nreturn -ENOSPC;\r\n}\r\nstatic void iwlagn_dealloc_agg_txq(struct iwl_priv *priv, int q)\r\n{\r\nclear_bit(q, priv->agg_q_alloc);\r\npriv->queue_to_mac80211[q] = IWL_INVALID_MAC80211_QUEUE;\r\n}\r\nint iwlagn_tx_agg_stop(struct iwl_priv *priv, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta, u16 tid)\r\n{\r\nstruct iwl_tid_data *tid_data;\r\nint sta_id, txq_id;\r\nenum iwl_agg_state agg_state;\r\nsta_id = iwl_sta_id(sta);\r\nif (sta_id == IWL_INVALID_STATION) {\r\nIWL_ERR(priv, "Invalid station for AGG tid %d\n", tid);\r\nreturn -ENXIO;\r\n}\r\nspin_lock_bh(&priv->sta_lock);\r\ntid_data = &priv->tid_data[sta_id][tid];\r\ntxq_id = tid_data->agg.txq_id;\r\nswitch (tid_data->agg.state) {\r\ncase IWL_EMPTYING_HW_QUEUE_ADDBA:\r\nIWL_DEBUG_HT(priv, "AGG stop before setup done\n");\r\ngoto turn_off;\r\ncase IWL_AGG_STARTING:\r\nIWL_DEBUG_HT(priv, "AGG stop before AGG became operational\n");\r\ngoto turn_off;\r\ncase IWL_AGG_ON:\r\nbreak;\r\ndefault:\r\nIWL_WARN(priv,\r\n"Stopping AGG while state not ON or starting for %d on %d (%d)\n",\r\nsta_id, tid, tid_data->agg.state);\r\nspin_unlock_bh(&priv->sta_lock);\r\nreturn 0;\r\n}\r\ntid_data->agg.ssn = IEEE80211_SEQ_TO_SN(tid_data->seq_number);\r\nif (!test_bit(txq_id, priv->agg_q_alloc)) {\r\nIWL_DEBUG_TX_QUEUES(priv,\r\n"stopping AGG on STA/TID %d/%d but hwq %d not used\n",\r\nsta_id, tid, txq_id);\r\n} else if (tid_data->agg.ssn != tid_data->next_reclaimed) {\r\nIWL_DEBUG_TX_QUEUES(priv,\r\n"Can't proceed: ssn %d, next_recl = %d\n",\r\ntid_data->agg.ssn,\r\ntid_data->next_reclaimed);\r\ntid_data->agg.state = IWL_EMPTYING_HW_QUEUE_DELBA;\r\nspin_unlock_bh(&priv->sta_lock);\r\nreturn 0;\r\n}\r\nIWL_DEBUG_TX_QUEUES(priv, "Can proceed: ssn = next_recl = %d\n",\r\ntid_data->agg.ssn);\r\nturn_off:\r\nagg_state = tid_data->agg.state;\r\ntid_data->agg.state = IWL_AGG_OFF;\r\nspin_unlock_bh(&priv->sta_lock);\r\nif (test_bit(txq_id, priv->agg_q_alloc)) {\r\nif (agg_state == IWL_AGG_ON)\r\niwl_trans_txq_disable(priv->trans, txq_id, true);\r\nelse\r\nIWL_DEBUG_TX_QUEUES(priv, "Don't disable tx agg: %d\n",\r\nagg_state);\r\niwlagn_dealloc_agg_txq(priv, txq_id);\r\n}\r\nieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\r\nreturn 0;\r\n}\r\nint iwlagn_tx_agg_start(struct iwl_priv *priv, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta, u16 tid, u16 *ssn)\r\n{\r\nstruct iwl_rxon_context *ctx = iwl_rxon_ctx_from_vif(vif);\r\nstruct iwl_tid_data *tid_data;\r\nint sta_id, txq_id, ret;\r\nIWL_DEBUG_HT(priv, "TX AGG request on ra = %pM tid = %d\n",\r\nsta->addr, tid);\r\nsta_id = iwl_sta_id(sta);\r\nif (sta_id == IWL_INVALID_STATION) {\r\nIWL_ERR(priv, "Start AGG on invalid station\n");\r\nreturn -ENXIO;\r\n}\r\nif (unlikely(tid >= IWL_MAX_TID_COUNT))\r\nreturn -EINVAL;\r\nif (priv->tid_data[sta_id][tid].agg.state != IWL_AGG_OFF) {\r\nIWL_ERR(priv, "Start AGG when state is not IWL_AGG_OFF !\n");\r\nreturn -ENXIO;\r\n}\r\ntxq_id = iwlagn_alloc_agg_txq(priv, ctx->ac_to_queue[tid_to_ac[tid]]);\r\nif (txq_id < 0) {\r\nIWL_DEBUG_TX_QUEUES(priv,\r\n"No free aggregation queue for %pM/%d\n",\r\nsta->addr, tid);\r\nreturn txq_id;\r\n}\r\nret = iwl_sta_tx_modify_enable_tid(priv, sta_id, tid);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_bh(&priv->sta_lock);\r\ntid_data = &priv->tid_data[sta_id][tid];\r\ntid_data->agg.ssn = IEEE80211_SEQ_TO_SN(tid_data->seq_number);\r\ntid_data->agg.txq_id = txq_id;\r\n*ssn = tid_data->agg.ssn;\r\nif (*ssn == tid_data->next_reclaimed) {\r\nIWL_DEBUG_TX_QUEUES(priv, "Can proceed: ssn = next_recl = %d\n",\r\ntid_data->agg.ssn);\r\ntid_data->agg.state = IWL_AGG_STARTING;\r\nieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);\r\n} else {\r\nIWL_DEBUG_TX_QUEUES(priv, "Can't proceed: ssn %d, "\r\n"next_reclaimed = %d\n",\r\ntid_data->agg.ssn,\r\ntid_data->next_reclaimed);\r\ntid_data->agg.state = IWL_EMPTYING_HW_QUEUE_ADDBA;\r\n}\r\nspin_unlock_bh(&priv->sta_lock);\r\nreturn ret;\r\n}\r\nint iwlagn_tx_agg_flush(struct iwl_priv *priv, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta, u16 tid)\r\n{\r\nstruct iwl_tid_data *tid_data;\r\nenum iwl_agg_state agg_state;\r\nint sta_id, txq_id;\r\nsta_id = iwl_sta_id(sta);\r\nspin_lock_bh(&priv->sta_lock);\r\ntid_data = &priv->tid_data[sta_id][tid];\r\ntxq_id = tid_data->agg.txq_id;\r\nagg_state = tid_data->agg.state;\r\nIWL_DEBUG_TX_QUEUES(priv, "Flush AGG: sta %d tid %d q %d state %d\n",\r\nsta_id, tid, txq_id, tid_data->agg.state);\r\ntid_data->agg.state = IWL_AGG_OFF;\r\nspin_unlock_bh(&priv->sta_lock);\r\nif (iwlagn_txfifo_flush(priv, BIT(txq_id)))\r\nIWL_ERR(priv, "Couldn't flush the AGG queue\n");\r\nif (test_bit(txq_id, priv->agg_q_alloc)) {\r\nif (agg_state == IWL_AGG_ON)\r\niwl_trans_txq_disable(priv->trans, txq_id, true);\r\nelse\r\nIWL_DEBUG_TX_QUEUES(priv, "Don't disable tx agg: %d\n",\r\nagg_state);\r\niwlagn_dealloc_agg_txq(priv, txq_id);\r\n}\r\nreturn 0;\r\n}\r\nint iwlagn_tx_agg_oper(struct iwl_priv *priv, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta, u16 tid, u8 buf_size)\r\n{\r\nstruct iwl_station_priv *sta_priv = (void *) sta->drv_priv;\r\nstruct iwl_rxon_context *ctx = iwl_rxon_ctx_from_vif(vif);\r\nint q, fifo;\r\nu16 ssn;\r\nbuf_size = min_t(int, buf_size, LINK_QUAL_AGG_FRAME_LIMIT_DEF);\r\nspin_lock_bh(&priv->sta_lock);\r\nssn = priv->tid_data[sta_priv->sta_id][tid].agg.ssn;\r\nq = priv->tid_data[sta_priv->sta_id][tid].agg.txq_id;\r\npriv->tid_data[sta_priv->sta_id][tid].agg.state = IWL_AGG_ON;\r\nspin_unlock_bh(&priv->sta_lock);\r\nfifo = ctx->ac_to_fifo[tid_to_ac[tid]];\r\niwl_trans_txq_enable(priv->trans, q, fifo, sta_priv->sta_id, tid,\r\nbuf_size, ssn, 0);\r\nif (sta_priv->max_agg_bufsize == 0)\r\nsta_priv->max_agg_bufsize =\r\nLINK_QUAL_AGG_FRAME_LIMIT_DEF;\r\nsta_priv->max_agg_bufsize =\r\nmin(sta_priv->max_agg_bufsize, buf_size);\r\nif (priv->hw_params.use_rts_for_aggregation) {\r\nsta_priv->lq_sta.lq.general_params.flags |=\r\nLINK_QUAL_FLAGS_SET_STA_TLC_RTS_MSK;\r\n}\r\npriv->agg_tids_count++;\r\nIWL_DEBUG_HT(priv, "priv->agg_tids_count = %u\n",\r\npriv->agg_tids_count);\r\nsta_priv->lq_sta.lq.agg_params.agg_frame_cnt_limit =\r\nsta_priv->max_agg_bufsize;\r\nIWL_DEBUG_HT(priv, "Tx aggregation enabled on ra = %pM tid = %d\n",\r\nsta->addr, tid);\r\nreturn iwl_send_lq_cmd(priv, ctx,\r\n&sta_priv->lq_sta.lq, CMD_ASYNC, false);\r\n}\r\nstatic void iwlagn_check_ratid_empty(struct iwl_priv *priv, int sta_id, u8 tid)\r\n{\r\nstruct iwl_tid_data *tid_data = &priv->tid_data[sta_id][tid];\r\nenum iwl_rxon_context_id ctx;\r\nstruct ieee80211_vif *vif;\r\nu8 *addr;\r\nlockdep_assert_held(&priv->sta_lock);\r\naddr = priv->stations[sta_id].sta.sta.addr;\r\nctx = priv->stations[sta_id].ctxid;\r\nvif = priv->contexts[ctx].vif;\r\nswitch (priv->tid_data[sta_id][tid].agg.state) {\r\ncase IWL_EMPTYING_HW_QUEUE_DELBA:\r\nif (tid_data->agg.ssn == tid_data->next_reclaimed) {\r\nIWL_DEBUG_TX_QUEUES(priv,\r\n"Can continue DELBA flow ssn = next_recl = %d\n",\r\ntid_data->next_reclaimed);\r\niwl_trans_txq_disable(priv->trans,\r\ntid_data->agg.txq_id, true);\r\niwlagn_dealloc_agg_txq(priv, tid_data->agg.txq_id);\r\ntid_data->agg.state = IWL_AGG_OFF;\r\nieee80211_stop_tx_ba_cb_irqsafe(vif, addr, tid);\r\n}\r\nbreak;\r\ncase IWL_EMPTYING_HW_QUEUE_ADDBA:\r\nif (tid_data->agg.ssn == tid_data->next_reclaimed) {\r\nIWL_DEBUG_TX_QUEUES(priv,\r\n"Can continue ADDBA flow ssn = next_recl = %d\n",\r\ntid_data->next_reclaimed);\r\ntid_data->agg.state = IWL_AGG_STARTING;\r\nieee80211_start_tx_ba_cb_irqsafe(vif, addr, tid);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void iwlagn_non_agg_tx_status(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx,\r\nconst u8 *addr1)\r\n{\r\nstruct ieee80211_sta *sta;\r\nstruct iwl_station_priv *sta_priv;\r\nrcu_read_lock();\r\nsta = ieee80211_find_sta(ctx->vif, addr1);\r\nif (sta) {\r\nsta_priv = (void *)sta->drv_priv;\r\nif (sta_priv->client &&\r\natomic_dec_return(&sta_priv->pending_frames) == 0)\r\nieee80211_sta_block_awake(priv->hw, sta, false);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void iwlagn_hwrate_to_tx_control(struct iwl_priv *priv, u32 rate_n_flags,\r\nstruct ieee80211_tx_info *info)\r\n{\r\nstruct ieee80211_tx_rate *r = &info->status.rates[0];\r\ninfo->status.antenna =\r\n((rate_n_flags & RATE_MCS_ANT_ABC_MSK) >> RATE_MCS_ANT_POS);\r\nif (rate_n_flags & RATE_MCS_HT_MSK)\r\nr->flags |= IEEE80211_TX_RC_MCS;\r\nif (rate_n_flags & RATE_MCS_GF_MSK)\r\nr->flags |= IEEE80211_TX_RC_GREEN_FIELD;\r\nif (rate_n_flags & RATE_MCS_HT40_MSK)\r\nr->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\r\nif (rate_n_flags & RATE_MCS_DUP_MSK)\r\nr->flags |= IEEE80211_TX_RC_DUP_DATA;\r\nif (rate_n_flags & RATE_MCS_SGI_MSK)\r\nr->flags |= IEEE80211_TX_RC_SHORT_GI;\r\nr->idx = iwlagn_hwrate_to_mac80211_idx(rate_n_flags, info->band);\r\n}\r\nconst char *iwl_get_tx_fail_reason(u32 status)\r\n{\r\n#define TX_STATUS_FAIL(x) case TX_STATUS_FAIL_ ## x: return #x\r\n#define TX_STATUS_POSTPONE(x) case TX_STATUS_POSTPONE_ ## x: return #x\r\nswitch (status & TX_STATUS_MSK) {\r\ncase TX_STATUS_SUCCESS:\r\nreturn "SUCCESS";\r\nTX_STATUS_POSTPONE(DELAY);\r\nTX_STATUS_POSTPONE(FEW_BYTES);\r\nTX_STATUS_POSTPONE(BT_PRIO);\r\nTX_STATUS_POSTPONE(QUIET_PERIOD);\r\nTX_STATUS_POSTPONE(CALC_TTAK);\r\nTX_STATUS_FAIL(INTERNAL_CROSSED_RETRY);\r\nTX_STATUS_FAIL(SHORT_LIMIT);\r\nTX_STATUS_FAIL(LONG_LIMIT);\r\nTX_STATUS_FAIL(FIFO_UNDERRUN);\r\nTX_STATUS_FAIL(DRAIN_FLOW);\r\nTX_STATUS_FAIL(RFKILL_FLUSH);\r\nTX_STATUS_FAIL(LIFE_EXPIRE);\r\nTX_STATUS_FAIL(DEST_PS);\r\nTX_STATUS_FAIL(HOST_ABORTED);\r\nTX_STATUS_FAIL(BT_RETRY);\r\nTX_STATUS_FAIL(STA_INVALID);\r\nTX_STATUS_FAIL(FRAG_DROPPED);\r\nTX_STATUS_FAIL(TID_DISABLE);\r\nTX_STATUS_FAIL(FIFO_FLUSHED);\r\nTX_STATUS_FAIL(INSUFFICIENT_CF_POLL);\r\nTX_STATUS_FAIL(PASSIVE_NO_RX);\r\nTX_STATUS_FAIL(NO_BEACON_ON_RADAR);\r\n}\r\nreturn "UNKNOWN";\r\n#undef TX_STATUS_FAIL\r\n#undef TX_STATUS_POSTPONE\r\n}\r\nstatic void iwlagn_count_agg_tx_err_status(struct iwl_priv *priv, u16 status)\r\n{\r\nstatus &= AGG_TX_STATUS_MSK;\r\nswitch (status) {\r\ncase AGG_TX_STATE_UNDERRUN_MSK:\r\npriv->reply_agg_tx_stats.underrun++;\r\nbreak;\r\ncase AGG_TX_STATE_BT_PRIO_MSK:\r\npriv->reply_agg_tx_stats.bt_prio++;\r\nbreak;\r\ncase AGG_TX_STATE_FEW_BYTES_MSK:\r\npriv->reply_agg_tx_stats.few_bytes++;\r\nbreak;\r\ncase AGG_TX_STATE_ABORT_MSK:\r\npriv->reply_agg_tx_stats.abort++;\r\nbreak;\r\ncase AGG_TX_STATE_LAST_SENT_TTL_MSK:\r\npriv->reply_agg_tx_stats.last_sent_ttl++;\r\nbreak;\r\ncase AGG_TX_STATE_LAST_SENT_TRY_CNT_MSK:\r\npriv->reply_agg_tx_stats.last_sent_try++;\r\nbreak;\r\ncase AGG_TX_STATE_LAST_SENT_BT_KILL_MSK:\r\npriv->reply_agg_tx_stats.last_sent_bt_kill++;\r\nbreak;\r\ncase AGG_TX_STATE_SCD_QUERY_MSK:\r\npriv->reply_agg_tx_stats.scd_query++;\r\nbreak;\r\ncase AGG_TX_STATE_TEST_BAD_CRC32_MSK:\r\npriv->reply_agg_tx_stats.bad_crc32++;\r\nbreak;\r\ncase AGG_TX_STATE_RESPONSE_MSK:\r\npriv->reply_agg_tx_stats.response++;\r\nbreak;\r\ncase AGG_TX_STATE_DUMP_TX_MSK:\r\npriv->reply_agg_tx_stats.dump_tx++;\r\nbreak;\r\ncase AGG_TX_STATE_DELAY_TX_MSK:\r\npriv->reply_agg_tx_stats.delay_tx++;\r\nbreak;\r\ndefault:\r\npriv->reply_agg_tx_stats.unknown++;\r\nbreak;\r\n}\r\n}\r\nstatic inline u32 iwlagn_get_scd_ssn(struct iwlagn_tx_resp *tx_resp)\r\n{\r\nreturn le32_to_cpup((__le32 *)&tx_resp->status +\r\ntx_resp->frame_count) & IEEE80211_MAX_SN;\r\n}\r\nstatic void iwl_rx_reply_tx_agg(struct iwl_priv *priv,\r\nstruct iwlagn_tx_resp *tx_resp)\r\n{\r\nstruct agg_tx_status *frame_status = &tx_resp->status;\r\nint tid = (tx_resp->ra_tid & IWLAGN_TX_RES_TID_MSK) >>\r\nIWLAGN_TX_RES_TID_POS;\r\nint sta_id = (tx_resp->ra_tid & IWLAGN_TX_RES_RA_MSK) >>\r\nIWLAGN_TX_RES_RA_POS;\r\nstruct iwl_ht_agg *agg = &priv->tid_data[sta_id][tid].agg;\r\nu32 status = le16_to_cpu(tx_resp->status.status);\r\nint i;\r\nWARN_ON(tid == IWL_TID_NON_QOS);\r\nif (agg->wait_for_ba)\r\nIWL_DEBUG_TX_REPLY(priv,\r\n"got tx response w/o block-ack\n");\r\nagg->rate_n_flags = le32_to_cpu(tx_resp->rate_n_flags);\r\nagg->wait_for_ba = (tx_resp->frame_count > 1);\r\nif (tx_resp->bt_kill_count && tx_resp->frame_count == 1 &&\r\npriv->lib->bt_params &&\r\npriv->lib->bt_params->advanced_bt_coexist) {\r\nIWL_DEBUG_COEX(priv, "receive reply tx w/ bt_kill\n");\r\n}\r\nif (tx_resp->frame_count == 1)\r\nreturn;\r\nIWL_DEBUG_TX_REPLY(priv, "TXQ %d initial_rate 0x%x ssn %d frm_cnt %d\n",\r\nagg->txq_id,\r\nle32_to_cpu(tx_resp->rate_n_flags),\r\niwlagn_get_scd_ssn(tx_resp), tx_resp->frame_count);\r\nfor (i = 0; i < tx_resp->frame_count; i++) {\r\nu16 fstatus = le16_to_cpu(frame_status[i].status);\r\nu8 retry_cnt = (fstatus & AGG_TX_TRY_MSK) >> AGG_TX_TRY_POS;\r\nif (status & AGG_TX_STATUS_MSK)\r\niwlagn_count_agg_tx_err_status(priv, fstatus);\r\nif (status & (AGG_TX_STATE_FEW_BYTES_MSK |\r\nAGG_TX_STATE_ABORT_MSK))\r\ncontinue;\r\nif (status & AGG_TX_STATUS_MSK || retry_cnt > 1)\r\nIWL_DEBUG_TX_REPLY(priv,\r\n"%d: status %s (0x%04x), try-count (0x%01x)\n",\r\ni,\r\niwl_get_agg_tx_fail_reason(fstatus),\r\nfstatus & AGG_TX_STATUS_MSK,\r\nretry_cnt);\r\n}\r\n}\r\nconst char *iwl_get_agg_tx_fail_reason(u16 status)\r\n{\r\nstatus &= AGG_TX_STATUS_MSK;\r\nswitch (status) {\r\ncase AGG_TX_STATE_TRANSMITTED:\r\nreturn "SUCCESS";\r\nAGG_TX_STATE_FAIL(UNDERRUN_MSK);\r\nAGG_TX_STATE_FAIL(BT_PRIO_MSK);\r\nAGG_TX_STATE_FAIL(FEW_BYTES_MSK);\r\nAGG_TX_STATE_FAIL(ABORT_MSK);\r\nAGG_TX_STATE_FAIL(LAST_SENT_TTL_MSK);\r\nAGG_TX_STATE_FAIL(LAST_SENT_TRY_CNT_MSK);\r\nAGG_TX_STATE_FAIL(LAST_SENT_BT_KILL_MSK);\r\nAGG_TX_STATE_FAIL(SCD_QUERY_MSK);\r\nAGG_TX_STATE_FAIL(TEST_BAD_CRC32_MSK);\r\nAGG_TX_STATE_FAIL(RESPONSE_MSK);\r\nAGG_TX_STATE_FAIL(DUMP_TX_MSK);\r\nAGG_TX_STATE_FAIL(DELAY_TX_MSK);\r\n}\r\nreturn "UNKNOWN";\r\n}\r\nstatic void iwlagn_count_tx_err_status(struct iwl_priv *priv, u16 status)\r\n{\r\nstatus &= TX_STATUS_MSK;\r\nswitch (status) {\r\ncase TX_STATUS_POSTPONE_DELAY:\r\npriv->reply_tx_stats.pp_delay++;\r\nbreak;\r\ncase TX_STATUS_POSTPONE_FEW_BYTES:\r\npriv->reply_tx_stats.pp_few_bytes++;\r\nbreak;\r\ncase TX_STATUS_POSTPONE_BT_PRIO:\r\npriv->reply_tx_stats.pp_bt_prio++;\r\nbreak;\r\ncase TX_STATUS_POSTPONE_QUIET_PERIOD:\r\npriv->reply_tx_stats.pp_quiet_period++;\r\nbreak;\r\ncase TX_STATUS_POSTPONE_CALC_TTAK:\r\npriv->reply_tx_stats.pp_calc_ttak++;\r\nbreak;\r\ncase TX_STATUS_FAIL_INTERNAL_CROSSED_RETRY:\r\npriv->reply_tx_stats.int_crossed_retry++;\r\nbreak;\r\ncase TX_STATUS_FAIL_SHORT_LIMIT:\r\npriv->reply_tx_stats.short_limit++;\r\nbreak;\r\ncase TX_STATUS_FAIL_LONG_LIMIT:\r\npriv->reply_tx_stats.long_limit++;\r\nbreak;\r\ncase TX_STATUS_FAIL_FIFO_UNDERRUN:\r\npriv->reply_tx_stats.fifo_underrun++;\r\nbreak;\r\ncase TX_STATUS_FAIL_DRAIN_FLOW:\r\npriv->reply_tx_stats.drain_flow++;\r\nbreak;\r\ncase TX_STATUS_FAIL_RFKILL_FLUSH:\r\npriv->reply_tx_stats.rfkill_flush++;\r\nbreak;\r\ncase TX_STATUS_FAIL_LIFE_EXPIRE:\r\npriv->reply_tx_stats.life_expire++;\r\nbreak;\r\ncase TX_STATUS_FAIL_DEST_PS:\r\npriv->reply_tx_stats.dest_ps++;\r\nbreak;\r\ncase TX_STATUS_FAIL_HOST_ABORTED:\r\npriv->reply_tx_stats.host_abort++;\r\nbreak;\r\ncase TX_STATUS_FAIL_BT_RETRY:\r\npriv->reply_tx_stats.bt_retry++;\r\nbreak;\r\ncase TX_STATUS_FAIL_STA_INVALID:\r\npriv->reply_tx_stats.sta_invalid++;\r\nbreak;\r\ncase TX_STATUS_FAIL_FRAG_DROPPED:\r\npriv->reply_tx_stats.frag_drop++;\r\nbreak;\r\ncase TX_STATUS_FAIL_TID_DISABLE:\r\npriv->reply_tx_stats.tid_disable++;\r\nbreak;\r\ncase TX_STATUS_FAIL_FIFO_FLUSHED:\r\npriv->reply_tx_stats.fifo_flush++;\r\nbreak;\r\ncase TX_STATUS_FAIL_INSUFFICIENT_CF_POLL:\r\npriv->reply_tx_stats.insuff_cf_poll++;\r\nbreak;\r\ncase TX_STATUS_FAIL_PASSIVE_NO_RX:\r\npriv->reply_tx_stats.fail_hw_drop++;\r\nbreak;\r\ncase TX_STATUS_FAIL_NO_BEACON_ON_RADAR:\r\npriv->reply_tx_stats.sta_color_mismatch++;\r\nbreak;\r\ndefault:\r\npriv->reply_tx_stats.unknown++;\r\nbreak;\r\n}\r\n}\r\nstatic void iwlagn_set_tx_status(struct iwl_priv *priv,\r\nstruct ieee80211_tx_info *info,\r\nstruct iwlagn_tx_resp *tx_resp)\r\n{\r\nu16 status = le16_to_cpu(tx_resp->status.status);\r\ninfo->flags &= ~IEEE80211_TX_CTL_AMPDU;\r\ninfo->status.rates[0].count = tx_resp->failure_frame + 1;\r\ninfo->flags |= iwl_tx_status_to_mac80211(status);\r\niwlagn_hwrate_to_tx_control(priv, le32_to_cpu(tx_resp->rate_n_flags),\r\ninfo);\r\nif (!iwl_is_tx_success(status))\r\niwlagn_count_tx_err_status(priv, status);\r\n}\r\nstatic void iwl_check_abort_status(struct iwl_priv *priv,\r\nu8 frame_count, u32 status)\r\n{\r\nif (frame_count == 1 && status == TX_STATUS_FAIL_RFKILL_FLUSH) {\r\nIWL_ERR(priv, "Tx flush command to flush out all frames\n");\r\nif (!test_bit(STATUS_EXIT_PENDING, &priv->status))\r\nqueue_work(priv->workqueue, &priv->tx_flush);\r\n}\r\n}\r\nvoid iwlagn_rx_reply_tx(struct iwl_priv *priv, struct iwl_rx_cmd_buffer *rxb)\r\n{\r\nstruct iwl_rx_packet *pkt = rxb_addr(rxb);\r\nu16 sequence = le16_to_cpu(pkt->hdr.sequence);\r\nint txq_id = SEQ_TO_QUEUE(sequence);\r\nint cmd_index __maybe_unused = SEQ_TO_INDEX(sequence);\r\nstruct iwlagn_tx_resp *tx_resp = (void *)pkt->data;\r\nstruct ieee80211_hdr *hdr;\r\nu32 status = le16_to_cpu(tx_resp->status.status);\r\nu16 ssn = iwlagn_get_scd_ssn(tx_resp);\r\nint tid;\r\nint sta_id;\r\nint freed;\r\nstruct ieee80211_tx_info *info;\r\nstruct sk_buff_head skbs;\r\nstruct sk_buff *skb;\r\nstruct iwl_rxon_context *ctx;\r\nbool is_agg = (txq_id >= IWLAGN_FIRST_AMPDU_QUEUE);\r\ntid = (tx_resp->ra_tid & IWLAGN_TX_RES_TID_MSK) >>\r\nIWLAGN_TX_RES_TID_POS;\r\nsta_id = (tx_resp->ra_tid & IWLAGN_TX_RES_RA_MSK) >>\r\nIWLAGN_TX_RES_RA_POS;\r\nspin_lock_bh(&priv->sta_lock);\r\nif (is_agg) {\r\nWARN_ON_ONCE(sta_id >= IWLAGN_STATION_COUNT ||\r\ntid >= IWL_MAX_TID_COUNT);\r\nif (txq_id != priv->tid_data[sta_id][tid].agg.txq_id)\r\nIWL_ERR(priv, "txq_id mismatch: %d %d\n", txq_id,\r\npriv->tid_data[sta_id][tid].agg.txq_id);\r\niwl_rx_reply_tx_agg(priv, tx_resp);\r\n}\r\n__skb_queue_head_init(&skbs);\r\nif (tx_resp->frame_count == 1) {\r\nu16 next_reclaimed = le16_to_cpu(tx_resp->seq_ctl);\r\nnext_reclaimed = IEEE80211_SEQ_TO_SN(next_reclaimed + 0x10);\r\nif (is_agg) {\r\nnext_reclaimed = ssn;\r\n}\r\nif (tid != IWL_TID_NON_QOS) {\r\npriv->tid_data[sta_id][tid].next_reclaimed =\r\nnext_reclaimed;\r\nIWL_DEBUG_TX_REPLY(priv, "Next reclaimed packet:%d\n",\r\nnext_reclaimed);\r\niwlagn_check_ratid_empty(priv, sta_id, tid);\r\n}\r\niwl_trans_reclaim(priv->trans, txq_id, ssn, &skbs);\r\nfreed = 0;\r\nskb_queue_walk(&skbs, skb) {\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nif (!ieee80211_is_data_qos(hdr->frame_control))\r\npriv->last_seq_ctl = tx_resp->seq_ctl;\r\ninfo = IEEE80211_SKB_CB(skb);\r\nctx = info->driver_data[0];\r\niwl_trans_free_tx_cmd(priv->trans,\r\ninfo->driver_data[1]);\r\nmemset(&info->status, 0, sizeof(info->status));\r\nif (status == TX_STATUS_FAIL_PASSIVE_NO_RX &&\r\nctx->vif &&\r\nctx->vif->type == NL80211_IFTYPE_STATION) {\r\npriv->passive_no_rx = true;\r\nIWL_DEBUG_TX_QUEUES(priv,\r\n"stop all queues: passive channel\n");\r\nieee80211_stop_queues(priv->hw);\r\nIWL_DEBUG_TX_REPLY(priv,\r\n"TXQ %d status %s (0x%08x) "\r\n"rate_n_flags 0x%x retries %d\n",\r\ntxq_id,\r\niwl_get_tx_fail_reason(status),\r\nstatus,\r\nle32_to_cpu(tx_resp->rate_n_flags),\r\ntx_resp->failure_frame);\r\nIWL_DEBUG_TX_REPLY(priv,\r\n"FrameCnt = %d, idx=%d\n",\r\ntx_resp->frame_count, cmd_index);\r\n}\r\nif (is_agg && !iwl_is_tx_success(status))\r\ninfo->flags |= IEEE80211_TX_STAT_AMPDU_NO_BACK;\r\niwlagn_set_tx_status(priv, IEEE80211_SKB_CB(skb),\r\ntx_resp);\r\nif (!is_agg)\r\niwlagn_non_agg_tx_status(priv, ctx, hdr->addr1);\r\nfreed++;\r\n}\r\nif (tid != IWL_TID_NON_QOS) {\r\npriv->tid_data[sta_id][tid].next_reclaimed =\r\nnext_reclaimed;\r\nIWL_DEBUG_TX_REPLY(priv, "Next reclaimed packet:%d\n",\r\nnext_reclaimed);\r\n}\r\nif (!is_agg && freed != 1)\r\nIWL_ERR(priv, "Q: %d, freed %d\n", txq_id, freed);\r\nIWL_DEBUG_TX_REPLY(priv, "TXQ %d status %s (0x%08x)\n", txq_id,\r\niwl_get_tx_fail_reason(status), status);\r\nIWL_DEBUG_TX_REPLY(priv,\r\n"\t\t\t\tinitial_rate 0x%x retries %d, idx=%d ssn=%d seq_ctl=0x%x\n",\r\nle32_to_cpu(tx_resp->rate_n_flags),\r\ntx_resp->failure_frame,\r\nSEQ_TO_INDEX(sequence), ssn,\r\nle16_to_cpu(tx_resp->seq_ctl));\r\n}\r\niwl_check_abort_status(priv, tx_resp->frame_count, status);\r\nspin_unlock_bh(&priv->sta_lock);\r\nwhile (!skb_queue_empty(&skbs)) {\r\nskb = __skb_dequeue(&skbs);\r\nieee80211_tx_status(priv->hw, skb);\r\n}\r\n}\r\nvoid iwlagn_rx_reply_compressed_ba(struct iwl_priv *priv,\r\nstruct iwl_rx_cmd_buffer *rxb)\r\n{\r\nstruct iwl_rx_packet *pkt = rxb_addr(rxb);\r\nstruct iwl_compressed_ba_resp *ba_resp = (void *)pkt->data;\r\nstruct iwl_ht_agg *agg;\r\nstruct sk_buff_head reclaimed_skbs;\r\nstruct sk_buff *skb;\r\nint sta_id;\r\nint tid;\r\nint freed;\r\nu16 scd_flow = le16_to_cpu(ba_resp->scd_flow);\r\nu16 ba_resp_scd_ssn = le16_to_cpu(ba_resp->scd_ssn);\r\nif (scd_flow >= priv->cfg->base_params->num_of_queues) {\r\nIWL_ERR(priv,\r\n"BUG_ON scd_flow is bigger than number of queues\n");\r\nreturn;\r\n}\r\nsta_id = ba_resp->sta_id;\r\ntid = ba_resp->tid;\r\nagg = &priv->tid_data[sta_id][tid].agg;\r\nspin_lock_bh(&priv->sta_lock);\r\nif (unlikely(!agg->wait_for_ba)) {\r\nif (unlikely(ba_resp->bitmap))\r\nIWL_ERR(priv, "Received BA when not expected\n");\r\nspin_unlock_bh(&priv->sta_lock);\r\nreturn;\r\n}\r\nif (unlikely(scd_flow != agg->txq_id)) {\r\nIWL_DEBUG_TX_QUEUES(priv,\r\n"Bad queue mapping txq_id=%d, agg_txq[sta:%d,tid:%d]=%d\n",\r\nscd_flow, sta_id, tid, agg->txq_id);\r\nspin_unlock_bh(&priv->sta_lock);\r\nreturn;\r\n}\r\n__skb_queue_head_init(&reclaimed_skbs);\r\niwl_trans_reclaim(priv->trans, scd_flow, ba_resp_scd_ssn,\r\n&reclaimed_skbs);\r\nIWL_DEBUG_TX_REPLY(priv, "REPLY_COMPRESSED_BA [%d] Received from %pM, "\r\n"sta_id = %d\n",\r\nagg->wait_for_ba,\r\n(u8 *) &ba_resp->sta_addr_lo32,\r\nba_resp->sta_id);\r\nIWL_DEBUG_TX_REPLY(priv, "TID = %d, SeqCtl = %d, bitmap = 0x%llx, "\r\n"scd_flow = %d, scd_ssn = %d sent:%d, acked:%d\n",\r\nba_resp->tid, le16_to_cpu(ba_resp->seq_ctl),\r\n(unsigned long long)le64_to_cpu(ba_resp->bitmap),\r\nscd_flow, ba_resp_scd_ssn, ba_resp->txed,\r\nba_resp->txed_2_done);\r\nagg->wait_for_ba = false;\r\nif (ba_resp->txed_2_done > ba_resp->txed) {\r\nIWL_DEBUG_TX_REPLY(priv,\r\n"bogus sent(%d) and ack(%d) count\n",\r\nba_resp->txed, ba_resp->txed_2_done);\r\nba_resp->txed = ba_resp->txed_2_done;\r\n}\r\npriv->tid_data[sta_id][tid].next_reclaimed = ba_resp_scd_ssn;\r\niwlagn_check_ratid_empty(priv, sta_id, tid);\r\nfreed = 0;\r\nskb_queue_walk(&reclaimed_skbs, skb) {\r\nstruct ieee80211_hdr *hdr = (void *)skb->data;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nif (ieee80211_is_data_qos(hdr->frame_control))\r\nfreed++;\r\nelse\r\nWARN_ON_ONCE(1);\r\niwl_trans_free_tx_cmd(priv->trans, info->driver_data[1]);\r\nmemset(&info->status, 0, sizeof(info->status));\r\ninfo->flags |= IEEE80211_TX_STAT_ACK;\r\nif (freed == 1) {\r\ninfo = IEEE80211_SKB_CB(skb);\r\nmemset(&info->status, 0, sizeof(info->status));\r\ninfo->flags |= IEEE80211_TX_STAT_AMPDU;\r\ninfo->status.ampdu_ack_len = ba_resp->txed_2_done;\r\ninfo->status.ampdu_len = ba_resp->txed;\r\niwlagn_hwrate_to_tx_control(priv, agg->rate_n_flags,\r\ninfo);\r\n}\r\n}\r\nspin_unlock_bh(&priv->sta_lock);\r\nwhile (!skb_queue_empty(&reclaimed_skbs)) {\r\nskb = __skb_dequeue(&reclaimed_skbs);\r\nieee80211_tx_status(priv->hw, skb);\r\n}\r\n}
