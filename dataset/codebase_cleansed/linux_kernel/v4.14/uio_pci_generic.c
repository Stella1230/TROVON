static inline struct uio_pci_generic_dev *\r\nto_uio_pci_generic_dev(struct uio_info *info)\r\n{\r\nreturn container_of(info, struct uio_pci_generic_dev, info);\r\n}\r\nstatic irqreturn_t irqhandler(int irq, struct uio_info *info)\r\n{\r\nstruct uio_pci_generic_dev *gdev = to_uio_pci_generic_dev(info);\r\nif (!pci_check_and_mask_intx(gdev->pdev))\r\nreturn IRQ_NONE;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct uio_pci_generic_dev *gdev;\r\nint err;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "%s: pci_enable_device failed: %d\n",\r\n__func__, err);\r\nreturn err;\r\n}\r\nif (pdev->irq && !pci_intx_mask_supported(pdev)) {\r\nerr = -ENODEV;\r\ngoto err_verify;\r\n}\r\ngdev = kzalloc(sizeof(struct uio_pci_generic_dev), GFP_KERNEL);\r\nif (!gdev) {\r\nerr = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\ngdev->info.name = "uio_pci_generic";\r\ngdev->info.version = DRIVER_VERSION;\r\ngdev->pdev = pdev;\r\nif (pdev->irq) {\r\ngdev->info.irq = pdev->irq;\r\ngdev->info.irq_flags = IRQF_SHARED;\r\ngdev->info.handler = irqhandler;\r\n} else {\r\ndev_warn(&pdev->dev, "No IRQ assigned to device: "\r\n"no support for interrupts?\n");\r\n}\r\nerr = uio_register_device(&pdev->dev, &gdev->info);\r\nif (err)\r\ngoto err_register;\r\npci_set_drvdata(pdev, gdev);\r\nreturn 0;\r\nerr_register:\r\nkfree(gdev);\r\nerr_alloc:\r\nerr_verify:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void remove(struct pci_dev *pdev)\r\n{\r\nstruct uio_pci_generic_dev *gdev = pci_get_drvdata(pdev);\r\nuio_unregister_device(&gdev->info);\r\npci_disable_device(pdev);\r\nkfree(gdev);\r\n}
