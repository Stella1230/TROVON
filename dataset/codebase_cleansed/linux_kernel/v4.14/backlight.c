static int fb_notifier_callback(struct notifier_block *self,\r\nunsigned long event, void *data)\r\n{\r\nstruct backlight_device *bd;\r\nstruct fb_event *evdata = data;\r\nint node = evdata->info->node;\r\nint fb_blank = 0;\r\nif (event != FB_EVENT_BLANK && event != FB_EVENT_CONBLANK)\r\nreturn 0;\r\nbd = container_of(self, struct backlight_device, fb_notif);\r\nmutex_lock(&bd->ops_lock);\r\nif (bd->ops)\r\nif (!bd->ops->check_fb ||\r\nbd->ops->check_fb(bd, evdata->info)) {\r\nfb_blank = *(int *)evdata->data;\r\nif (fb_blank == FB_BLANK_UNBLANK &&\r\n!bd->fb_bl_on[node]) {\r\nbd->fb_bl_on[node] = true;\r\nif (!bd->use_count++) {\r\nbd->props.state &= ~BL_CORE_FBBLANK;\r\nbd->props.fb_blank = FB_BLANK_UNBLANK;\r\nbacklight_update_status(bd);\r\n}\r\n} else if (fb_blank != FB_BLANK_UNBLANK &&\r\nbd->fb_bl_on[node]) {\r\nbd->fb_bl_on[node] = false;\r\nif (!(--bd->use_count)) {\r\nbd->props.state |= BL_CORE_FBBLANK;\r\nbd->props.fb_blank = fb_blank;\r\nbacklight_update_status(bd);\r\n}\r\n}\r\n}\r\nmutex_unlock(&bd->ops_lock);\r\nreturn 0;\r\n}\r\nstatic int backlight_register_fb(struct backlight_device *bd)\r\n{\r\nmemset(&bd->fb_notif, 0, sizeof(bd->fb_notif));\r\nbd->fb_notif.notifier_call = fb_notifier_callback;\r\nreturn fb_register_client(&bd->fb_notif);\r\n}\r\nstatic void backlight_unregister_fb(struct backlight_device *bd)\r\n{\r\nfb_unregister_client(&bd->fb_notif);\r\n}\r\nstatic inline int backlight_register_fb(struct backlight_device *bd)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void backlight_unregister_fb(struct backlight_device *bd)\r\n{\r\n}\r\nstatic void backlight_generate_event(struct backlight_device *bd,\r\nenum backlight_update_reason reason)\r\n{\r\nchar *envp[2];\r\nswitch (reason) {\r\ncase BACKLIGHT_UPDATE_SYSFS:\r\nenvp[0] = "SOURCE=sysfs";\r\nbreak;\r\ncase BACKLIGHT_UPDATE_HOTKEY:\r\nenvp[0] = "SOURCE=hotkey";\r\nbreak;\r\ndefault:\r\nenvp[0] = "SOURCE=unknown";\r\nbreak;\r\n}\r\nenvp[1] = NULL;\r\nkobject_uevent_env(&bd->dev.kobj, KOBJ_CHANGE, envp);\r\nsysfs_notify(&bd->dev.kobj, NULL, "actual_brightness");\r\n}\r\nstatic ssize_t bl_power_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct backlight_device *bd = to_backlight_device(dev);\r\nreturn sprintf(buf, "%d\n", bd->props.power);\r\n}\r\nstatic ssize_t bl_power_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint rc;\r\nstruct backlight_device *bd = to_backlight_device(dev);\r\nunsigned long power, old_power;\r\nrc = kstrtoul(buf, 0, &power);\r\nif (rc)\r\nreturn rc;\r\nrc = -ENXIO;\r\nmutex_lock(&bd->ops_lock);\r\nif (bd->ops) {\r\npr_debug("set power to %lu\n", power);\r\nif (bd->props.power != power) {\r\nold_power = bd->props.power;\r\nbd->props.power = power;\r\nrc = backlight_update_status(bd);\r\nif (rc)\r\nbd->props.power = old_power;\r\nelse\r\nrc = count;\r\n} else {\r\nrc = count;\r\n}\r\n}\r\nmutex_unlock(&bd->ops_lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t brightness_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct backlight_device *bd = to_backlight_device(dev);\r\nreturn sprintf(buf, "%d\n", bd->props.brightness);\r\n}\r\nint backlight_device_set_brightness(struct backlight_device *bd,\r\nunsigned long brightness)\r\n{\r\nint rc = -ENXIO;\r\nmutex_lock(&bd->ops_lock);\r\nif (bd->ops) {\r\nif (brightness > bd->props.max_brightness)\r\nrc = -EINVAL;\r\nelse {\r\npr_debug("set brightness to %lu\n", brightness);\r\nbd->props.brightness = brightness;\r\nrc = backlight_update_status(bd);\r\n}\r\n}\r\nmutex_unlock(&bd->ops_lock);\r\nbacklight_generate_event(bd, BACKLIGHT_UPDATE_SYSFS);\r\nreturn rc;\r\n}\r\nstatic ssize_t brightness_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint rc;\r\nstruct backlight_device *bd = to_backlight_device(dev);\r\nunsigned long brightness;\r\nrc = kstrtoul(buf, 0, &brightness);\r\nif (rc)\r\nreturn rc;\r\nrc = backlight_device_set_brightness(bd, brightness);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t type_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct backlight_device *bd = to_backlight_device(dev);\r\nreturn sprintf(buf, "%s\n", backlight_types[bd->props.type]);\r\n}\r\nstatic ssize_t max_brightness_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct backlight_device *bd = to_backlight_device(dev);\r\nreturn sprintf(buf, "%d\n", bd->props.max_brightness);\r\n}\r\nstatic ssize_t actual_brightness_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint rc = -ENXIO;\r\nstruct backlight_device *bd = to_backlight_device(dev);\r\nmutex_lock(&bd->ops_lock);\r\nif (bd->ops && bd->ops->get_brightness)\r\nrc = sprintf(buf, "%d\n", bd->ops->get_brightness(bd));\r\nelse\r\nrc = sprintf(buf, "%d\n", bd->props.brightness);\r\nmutex_unlock(&bd->ops_lock);\r\nreturn rc;\r\n}\r\nstatic int backlight_suspend(struct device *dev)\r\n{\r\nstruct backlight_device *bd = to_backlight_device(dev);\r\nmutex_lock(&bd->ops_lock);\r\nif (bd->ops && bd->ops->options & BL_CORE_SUSPENDRESUME) {\r\nbd->props.state |= BL_CORE_SUSPENDED;\r\nbacklight_update_status(bd);\r\n}\r\nmutex_unlock(&bd->ops_lock);\r\nreturn 0;\r\n}\r\nstatic int backlight_resume(struct device *dev)\r\n{\r\nstruct backlight_device *bd = to_backlight_device(dev);\r\nmutex_lock(&bd->ops_lock);\r\nif (bd->ops && bd->ops->options & BL_CORE_SUSPENDRESUME) {\r\nbd->props.state &= ~BL_CORE_SUSPENDED;\r\nbacklight_update_status(bd);\r\n}\r\nmutex_unlock(&bd->ops_lock);\r\nreturn 0;\r\n}\r\nstatic void bl_device_release(struct device *dev)\r\n{\r\nstruct backlight_device *bd = to_backlight_device(dev);\r\nkfree(bd);\r\n}\r\nvoid backlight_force_update(struct backlight_device *bd,\r\nenum backlight_update_reason reason)\r\n{\r\nmutex_lock(&bd->ops_lock);\r\nif (bd->ops && bd->ops->get_brightness)\r\nbd->props.brightness = bd->ops->get_brightness(bd);\r\nmutex_unlock(&bd->ops_lock);\r\nbacklight_generate_event(bd, reason);\r\n}\r\nstruct backlight_device *backlight_device_register(const char *name,\r\nstruct device *parent, void *devdata, const struct backlight_ops *ops,\r\nconst struct backlight_properties *props)\r\n{\r\nstruct backlight_device *new_bd;\r\nint rc;\r\npr_debug("backlight_device_register: name=%s\n", name);\r\nnew_bd = kzalloc(sizeof(struct backlight_device), GFP_KERNEL);\r\nif (!new_bd)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&new_bd->update_lock);\r\nmutex_init(&new_bd->ops_lock);\r\nnew_bd->dev.class = backlight_class;\r\nnew_bd->dev.parent = parent;\r\nnew_bd->dev.release = bl_device_release;\r\ndev_set_name(&new_bd->dev, "%s", name);\r\ndev_set_drvdata(&new_bd->dev, devdata);\r\nif (props) {\r\nmemcpy(&new_bd->props, props,\r\nsizeof(struct backlight_properties));\r\nif (props->type <= 0 || props->type >= BACKLIGHT_TYPE_MAX) {\r\nWARN(1, "%s: invalid backlight type", name);\r\nnew_bd->props.type = BACKLIGHT_RAW;\r\n}\r\n} else {\r\nnew_bd->props.type = BACKLIGHT_RAW;\r\n}\r\nrc = device_register(&new_bd->dev);\r\nif (rc) {\r\nput_device(&new_bd->dev);\r\nreturn ERR_PTR(rc);\r\n}\r\nrc = backlight_register_fb(new_bd);\r\nif (rc) {\r\ndevice_unregister(&new_bd->dev);\r\nreturn ERR_PTR(rc);\r\n}\r\nnew_bd->ops = ops;\r\n#ifdef CONFIG_PMAC_BACKLIGHT\r\nmutex_lock(&pmac_backlight_mutex);\r\nif (!pmac_backlight)\r\npmac_backlight = new_bd;\r\nmutex_unlock(&pmac_backlight_mutex);\r\n#endif\r\nmutex_lock(&backlight_dev_list_mutex);\r\nlist_add(&new_bd->entry, &backlight_dev_list);\r\nmutex_unlock(&backlight_dev_list_mutex);\r\nblocking_notifier_call_chain(&backlight_notifier,\r\nBACKLIGHT_REGISTERED, new_bd);\r\nreturn new_bd;\r\n}\r\nstruct backlight_device *backlight_device_get_by_type(enum backlight_type type)\r\n{\r\nbool found = false;\r\nstruct backlight_device *bd;\r\nmutex_lock(&backlight_dev_list_mutex);\r\nlist_for_each_entry(bd, &backlight_dev_list, entry) {\r\nif (bd->props.type == type) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&backlight_dev_list_mutex);\r\nreturn found ? bd : NULL;\r\n}\r\nvoid backlight_device_unregister(struct backlight_device *bd)\r\n{\r\nif (!bd)\r\nreturn;\r\nmutex_lock(&backlight_dev_list_mutex);\r\nlist_del(&bd->entry);\r\nmutex_unlock(&backlight_dev_list_mutex);\r\n#ifdef CONFIG_PMAC_BACKLIGHT\r\nmutex_lock(&pmac_backlight_mutex);\r\nif (pmac_backlight == bd)\r\npmac_backlight = NULL;\r\nmutex_unlock(&pmac_backlight_mutex);\r\n#endif\r\nblocking_notifier_call_chain(&backlight_notifier,\r\nBACKLIGHT_UNREGISTERED, bd);\r\nmutex_lock(&bd->ops_lock);\r\nbd->ops = NULL;\r\nmutex_unlock(&bd->ops_lock);\r\nbacklight_unregister_fb(bd);\r\ndevice_unregister(&bd->dev);\r\n}\r\nstatic void devm_backlight_device_release(struct device *dev, void *res)\r\n{\r\nstruct backlight_device *backlight = *(struct backlight_device **)res;\r\nbacklight_device_unregister(backlight);\r\n}\r\nstatic int devm_backlight_device_match(struct device *dev, void *res,\r\nvoid *data)\r\n{\r\nstruct backlight_device **r = res;\r\nreturn *r == data;\r\n}\r\nint backlight_register_notifier(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_register(&backlight_notifier, nb);\r\n}\r\nint backlight_unregister_notifier(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_unregister(&backlight_notifier, nb);\r\n}\r\nstruct backlight_device *devm_backlight_device_register(struct device *dev,\r\nconst char *name, struct device *parent, void *devdata,\r\nconst struct backlight_ops *ops,\r\nconst struct backlight_properties *props)\r\n{\r\nstruct backlight_device **ptr, *backlight;\r\nptr = devres_alloc(devm_backlight_device_release, sizeof(*ptr),\r\nGFP_KERNEL);\r\nif (!ptr)\r\nreturn ERR_PTR(-ENOMEM);\r\nbacklight = backlight_device_register(name, parent, devdata, ops,\r\nprops);\r\nif (!IS_ERR(backlight)) {\r\n*ptr = backlight;\r\ndevres_add(dev, ptr);\r\n} else {\r\ndevres_free(ptr);\r\n}\r\nreturn backlight;\r\n}\r\nvoid devm_backlight_device_unregister(struct device *dev,\r\nstruct backlight_device *bd)\r\n{\r\nint rc;\r\nrc = devres_release(dev, devm_backlight_device_release,\r\ndevm_backlight_device_match, bd);\r\nWARN_ON(rc);\r\n}\r\nstatic int of_parent_match(struct device *dev, const void *data)\r\n{\r\nreturn dev->parent && dev->parent->of_node == data;\r\n}\r\nstruct backlight_device *of_find_backlight_by_node(struct device_node *node)\r\n{\r\nstruct device *dev;\r\ndev = class_find_device(backlight_class, NULL, node, of_parent_match);\r\nreturn dev ? to_backlight_device(dev) : NULL;\r\n}\r\nstatic void __exit backlight_class_exit(void)\r\n{\r\nclass_destroy(backlight_class);\r\n}\r\nstatic int __init backlight_class_init(void)\r\n{\r\nbacklight_class = class_create(THIS_MODULE, "backlight");\r\nif (IS_ERR(backlight_class)) {\r\npr_warn("Unable to create backlight class; errno = %ld\n",\r\nPTR_ERR(backlight_class));\r\nreturn PTR_ERR(backlight_class);\r\n}\r\nbacklight_class->dev_groups = bl_device_groups;\r\nbacklight_class->pm = &backlight_class_dev_pm_ops;\r\nINIT_LIST_HEAD(&backlight_dev_list);\r\nmutex_init(&backlight_dev_list_mutex);\r\nBLOCKING_INIT_NOTIFIER_HEAD(&backlight_notifier);\r\nreturn 0;\r\n}
