static void reg_init(struct sim_dev_reg *reg)\r\n{\r\npci_direct_conf1.read(0, 1, reg->dev_func, reg->reg, 4,\r\n&reg->sim_reg.value);\r\n}\r\nstatic void reg_read(struct sim_dev_reg *reg, u32 *value)\r\n{\r\n*value = reg->sim_reg.value;\r\n}\r\nstatic void reg_write(struct sim_dev_reg *reg, u32 value)\r\n{\r\nreg->sim_reg.value = (value & reg->sim_reg.mask) |\r\n(reg->sim_reg.value & ~reg->sim_reg.mask);\r\n}\r\nstatic void sata_reg_init(struct sim_dev_reg *reg)\r\n{\r\npci_direct_conf1.read(0, 1, PCI_DEVFN(14, 0), 0x10, 4,\r\n&reg->sim_reg.value);\r\nreg->sim_reg.value += 0x400;\r\n}\r\nstatic void ehci_reg_read(struct sim_dev_reg *reg, u32 *value)\r\n{\r\nreg_read(reg, value);\r\nif (*value != reg->sim_reg.mask)\r\n*value |= 0x100;\r\n}\r\nvoid sata_revid_init(struct sim_dev_reg *reg)\r\n{\r\nreg->sim_reg.value = 0x01060100;\r\nreg->sim_reg.mask = 0;\r\n}\r\nstatic void sata_revid_read(struct sim_dev_reg *reg, u32 *value)\r\n{\r\nreg_read(reg, value);\r\n}\r\nstatic void reg_noirq_read(struct sim_dev_reg *reg, u32 *value)\r\n{\r\n*value = reg->sim_reg.value & 0xfff00ff;\r\n}\r\nstatic void __init init_sim_regs(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(bus1_fixups); i++) {\r\nif (bus1_fixups[i].init)\r\nbus1_fixups[i].init(&bus1_fixups[i]);\r\n}\r\n}\r\nstatic inline void extract_bytes(u32 *value, int reg, int len)\r\n{\r\nuint32_t mask;\r\n*value >>= ((reg & 3) * 8);\r\nmask = 0xFFFFFFFF >> ((4 - len) * 8);\r\n*value &= mask;\r\n}\r\nint bridge_read(unsigned int devfn, int reg, int len, u32 *value)\r\n{\r\nu32 av_bridge_base, av_bridge_limit;\r\nint retval = 0;\r\nswitch (reg) {\r\ncase PCI_BASE_ADDRESS_0:\r\ncase PCI_BASE_ADDRESS_0 + 1:\r\ncase PCI_BASE_ADDRESS_0 + 2:\r\ncase PCI_BASE_ADDRESS_0 + 3:\r\n*value = 0;\r\nbreak;\r\ncase PCI_PRIMARY_BUS:\r\nif (len == 4)\r\n*value = 0x00010100;\r\nbreak;\r\ncase PCI_SUBORDINATE_BUS:\r\n*value = 1;\r\nbreak;\r\ncase PCI_MEMORY_BASE:\r\ncase PCI_MEMORY_LIMIT:\r\npci_direct_conf1.read(0, 0, devfn,\r\nPCI_BASE_ADDRESS_0, 4, &av_bridge_base);\r\nav_bridge_limit = av_bridge_base + (512*MB - 1);\r\nav_bridge_limit >>= 16;\r\nav_bridge_limit &= 0xFFF0;\r\nav_bridge_base >>= 16;\r\nav_bridge_base &= 0xFFF0;\r\nif (reg == PCI_MEMORY_LIMIT)\r\n*value = av_bridge_limit;\r\nelse if (len == 2)\r\n*value = av_bridge_base;\r\nelse\r\n*value = (av_bridge_limit << 16) | av_bridge_base;\r\nbreak;\r\ncase PCI_PREF_MEMORY_BASE:\r\n*value = 0xFFF0;\r\nbreak;\r\ncase PCI_PREF_MEMORY_LIMIT:\r\n*value = 0x0;\r\nbreak;\r\ncase PCI_IO_BASE:\r\n*value = 0xF0;\r\nbreak;\r\ncase PCI_IO_LIMIT:\r\n*value = 0;\r\nbreak;\r\ndefault:\r\nretval = 1;\r\n}\r\nreturn retval;\r\n}\r\nstatic int ce4100_bus1_read(unsigned int devfn, int reg, int len, u32 *value)\r\n{\r\nunsigned long flags;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(bus1_fixups); i++) {\r\nif (bus1_fixups[i].dev_func == devfn &&\r\nbus1_fixups[i].reg == (reg & ~3) &&\r\nbus1_fixups[i].read) {\r\nraw_spin_lock_irqsave(&pci_config_lock, flags);\r\nbus1_fixups[i].read(&(bus1_fixups[i]), value);\r\nraw_spin_unlock_irqrestore(&pci_config_lock, flags);\r\nextract_bytes(value, reg, len);\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int ce4100_conf_read(unsigned int seg, unsigned int bus,\r\nunsigned int devfn, int reg, int len, u32 *value)\r\n{\r\nWARN_ON(seg);\r\nif (bus == 1 && !ce4100_bus1_read(devfn, reg, len, value))\r\nreturn 0;\r\nif (bus == 0 && (PCI_DEVFN(1, 0) == devfn) &&\r\n!bridge_read(devfn, reg, len, value))\r\nreturn 0;\r\nreturn pci_direct_conf1.read(seg, bus, devfn, reg, len, value);\r\n}\r\nstatic int ce4100_bus1_write(unsigned int devfn, int reg, int len, u32 value)\r\n{\r\nunsigned long flags;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(bus1_fixups); i++) {\r\nif (bus1_fixups[i].dev_func == devfn &&\r\nbus1_fixups[i].reg == (reg & ~3) &&\r\nbus1_fixups[i].write) {\r\nraw_spin_lock_irqsave(&pci_config_lock, flags);\r\nbus1_fixups[i].write(&(bus1_fixups[i]), value);\r\nraw_spin_unlock_irqrestore(&pci_config_lock, flags);\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int ce4100_conf_write(unsigned int seg, unsigned int bus,\r\nunsigned int devfn, int reg, int len, u32 value)\r\n{\r\nWARN_ON(seg);\r\nif (bus == 1 && !ce4100_bus1_write(devfn, reg, len, value))\r\nreturn 0;\r\nif (bus == 0 && PCI_DEVFN(1, 0) == devfn &&\r\n((reg & ~3) == PCI_BASE_ADDRESS_0))\r\nreturn 0;\r\nreturn pci_direct_conf1.write(seg, bus, devfn, reg, len, value);\r\n}\r\nint __init ce4100_pci_init(void)\r\n{\r\ninit_sim_regs();\r\nraw_pci_ops = &ce4100_pci_conf;\r\nreturn 1;\r\n}
