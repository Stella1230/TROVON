static void write_clkset1_for_usb_extal(struct rcar_gen3_usb3 *r, bool reset)\r\n{\r\nu16 val = CLKSET1_USB30_PLL_MULTI_USB_EXTAL |\r\nCLKSET1_REF_CLKDIV | CLKSET1_PRIVATE_2_1;\r\nif (reset)\r\nval |= CLKSET1_PHYRESET;\r\nwritew(val, r->base + USB30_CLKSET1);\r\n}\r\nstatic void rcar_gen3_phy_usb3_enable_ssc(struct rcar_gen3_usb3 *r)\r\n{\r\nu16 val = SSC_SET_SSC_EN;\r\nswitch (r->ssc_range) {\r\ncase 4980:\r\nval |= SSC_SET_RANGE_4980;\r\nbreak;\r\ncase 4492:\r\nval |= SSC_SET_RANGE_4492;\r\nbreak;\r\ncase 4003:\r\nval |= SSC_SET_RANGE_4003;\r\nbreak;\r\ndefault:\r\ndev_err(&r->phy->dev, "%s: unsupported range (%x)\n", __func__,\r\nr->ssc_range);\r\nreturn;\r\n}\r\nwritew(val, r->base + USB30_SSC_SET);\r\n}\r\nstatic void rcar_gen3_phy_usb3_select_usb_extal(struct rcar_gen3_usb3 *r)\r\n{\r\nwrite_clkset1_for_usb_extal(r, false);\r\nif (r->ssc_range)\r\nrcar_gen3_phy_usb3_enable_ssc(r);\r\nwritew(CLKSET0_PRIVATE | CLKSET0_USB30_FSEL_USB_EXTAL,\r\nr->base + USB30_CLKSET0);\r\nwritew(PHY_ENABLE_RESET_EN, r->base + USB30_PHY_ENABLE);\r\nwrite_clkset1_for_usb_extal(r, true);\r\nusleep_range(10, 20);\r\nwrite_clkset1_for_usb_extal(r, false);\r\n}\r\nstatic int rcar_gen3_phy_usb3_init(struct phy *p)\r\n{\r\nstruct rcar_gen3_usb3 *r = phy_get_drvdata(p);\r\ndev_vdbg(&r->phy->dev, "%s: enter (%d, %d, %d)\n", __func__,\r\nr->usb3s_clk, r->usb_extal, r->ssc_range);\r\nif (!r->usb3s_clk && r->usb_extal)\r\nrcar_gen3_phy_usb3_select_usb_extal(r);\r\nwritew(VBUS_EN_VBUS_EN, r->base + USB30_VBUS_EN);\r\nreturn 0;\r\n}\r\nstatic int rcar_gen3_phy_usb3_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct rcar_gen3_usb3 *r;\r\nstruct phy_provider *provider;\r\nstruct resource *res;\r\nint ret = 0;\r\nstruct clk *clk;\r\nif (!dev->of_node) {\r\ndev_err(dev, "This driver needs device tree\n");\r\nreturn -EINVAL;\r\n}\r\nr = devm_kzalloc(dev, sizeof(*r), GFP_KERNEL);\r\nif (!r)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nr->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(r->base))\r\nreturn PTR_ERR(r->base);\r\nclk = devm_clk_get(dev, "usb3s_clk");\r\nif (!IS_ERR(clk) && !clk_prepare_enable(clk)) {\r\nr->usb3s_clk = !!clk_get_rate(clk);\r\nclk_disable_unprepare(clk);\r\n}\r\nclk = devm_clk_get(dev, "usb_extal");\r\nif (!IS_ERR(clk) && !clk_prepare_enable(clk)) {\r\nr->usb_extal = !!clk_get_rate(clk);\r\nclk_disable_unprepare(clk);\r\n}\r\nif (!r->usb3s_clk && !r->usb_extal) {\r\ndev_err(dev, "This driver needs usb3s_clk and/or usb_extal\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\npm_runtime_enable(dev);\r\nr->phy = devm_phy_create(dev, NULL, &rcar_gen3_phy_usb3_ops);\r\nif (IS_ERR(r->phy)) {\r\ndev_err(dev, "Failed to create USB3 PHY\n");\r\nret = PTR_ERR(r->phy);\r\ngoto error;\r\n}\r\nof_property_read_u32(dev->of_node, "renesas,ssc-range", &r->ssc_range);\r\nplatform_set_drvdata(pdev, r);\r\nphy_set_drvdata(r->phy, r);\r\nprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nif (IS_ERR(provider)) {\r\ndev_err(dev, "Failed to register PHY provider\n");\r\nret = PTR_ERR(provider);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int rcar_gen3_phy_usb3_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
