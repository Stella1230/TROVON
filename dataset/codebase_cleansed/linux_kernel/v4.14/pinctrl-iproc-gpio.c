static inline unsigned iproc_pin_to_gpio(unsigned pin)\r\n{\r\nreturn pin;\r\n}\r\nstatic inline void iproc_set_bit(struct iproc_gpio *chip, unsigned int reg,\r\nunsigned gpio, bool set)\r\n{\r\nunsigned int offset = IPROC_GPIO_REG(gpio, reg);\r\nunsigned int shift = IPROC_GPIO_SHIFT(gpio);\r\nu32 val;\r\nval = readl(chip->base + offset);\r\nif (set)\r\nval |= BIT(shift);\r\nelse\r\nval &= ~BIT(shift);\r\nwritel(val, chip->base + offset);\r\n}\r\nstatic inline bool iproc_get_bit(struct iproc_gpio *chip, unsigned int reg,\r\nunsigned gpio)\r\n{\r\nunsigned int offset = IPROC_GPIO_REG(gpio, reg);\r\nunsigned int shift = IPROC_GPIO_SHIFT(gpio);\r\nreturn !!(readl(chip->base + offset) & BIT(shift));\r\n}\r\nstatic void iproc_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nstruct iproc_gpio *chip = gpiochip_get_data(gc);\r\nstruct irq_chip *irq_chip = irq_desc_get_chip(desc);\r\nint i, bit;\r\nchained_irq_enter(irq_chip, desc);\r\nfor (i = 0; i < chip->num_banks; i++) {\r\nunsigned long val = readl(chip->base + (i * GPIO_BANK_SIZE) +\r\nIPROC_GPIO_INT_MSTAT_OFFSET);\r\nfor_each_set_bit(bit, &val, NGPIOS_PER_BANK) {\r\nunsigned pin = NGPIOS_PER_BANK * i + bit;\r\nint child_irq = irq_find_mapping(gc->irqdomain, pin);\r\nwritel(BIT(bit), chip->base + (i * GPIO_BANK_SIZE) +\r\nIPROC_GPIO_INT_CLR_OFFSET);\r\ngeneric_handle_irq(child_irq);\r\n}\r\n}\r\nchained_irq_exit(irq_chip, desc);\r\n}\r\nstatic void iproc_gpio_irq_ack(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct iproc_gpio *chip = gpiochip_get_data(gc);\r\nunsigned gpio = d->hwirq;\r\nunsigned int offset = IPROC_GPIO_REG(gpio,\r\nIPROC_GPIO_INT_CLR_OFFSET);\r\nunsigned int shift = IPROC_GPIO_SHIFT(gpio);\r\nu32 val = BIT(shift);\r\nwritel(val, chip->base + offset);\r\n}\r\nstatic void iproc_gpio_irq_set_mask(struct irq_data *d, bool unmask)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct iproc_gpio *chip = gpiochip_get_data(gc);\r\nunsigned gpio = d->hwirq;\r\niproc_set_bit(chip, IPROC_GPIO_INT_MSK_OFFSET, gpio, unmask);\r\n}\r\nstatic void iproc_gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct iproc_gpio *chip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\niproc_gpio_irq_set_mask(d, false);\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nstatic void iproc_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct iproc_gpio *chip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\niproc_gpio_irq_set_mask(d, true);\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nstatic int iproc_gpio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct iproc_gpio *chip = gpiochip_get_data(gc);\r\nunsigned gpio = d->hwirq;\r\nbool level_triggered = false;\r\nbool dual_edge = false;\r\nbool rising_or_high = false;\r\nunsigned long flags;\r\nswitch (type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nrising_or_high = true;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\ndual_edge = true;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nlevel_triggered = true;\r\nrising_or_high = true;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nlevel_triggered = true;\r\nbreak;\r\ndefault:\r\ndev_err(chip->dev, "invalid GPIO IRQ type 0x%x\n",\r\ntype);\r\nreturn -EINVAL;\r\n}\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\niproc_set_bit(chip, IPROC_GPIO_INT_TYPE_OFFSET, gpio,\r\nlevel_triggered);\r\niproc_set_bit(chip, IPROC_GPIO_INT_DE_OFFSET, gpio, dual_edge);\r\niproc_set_bit(chip, IPROC_GPIO_INT_EDGE_OFFSET, gpio,\r\nrising_or_high);\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\ndev_dbg(chip->dev,\r\n"gpio:%u level_triggered:%d dual_edge:%d rising_or_high:%d\n",\r\ngpio, level_triggered, dual_edge, rising_or_high);\r\nreturn 0;\r\n}\r\nstatic int iproc_gpio_request(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct iproc_gpio *chip = gpiochip_get_data(gc);\r\nunsigned gpio = gc->base + offset;\r\nif (!chip->pinmux_is_supported)\r\nreturn 0;\r\nreturn pinctrl_request_gpio(gpio);\r\n}\r\nstatic void iproc_gpio_free(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct iproc_gpio *chip = gpiochip_get_data(gc);\r\nunsigned gpio = gc->base + offset;\r\nif (!chip->pinmux_is_supported)\r\nreturn;\r\npinctrl_free_gpio(gpio);\r\n}\r\nstatic int iproc_gpio_direction_input(struct gpio_chip *gc, unsigned gpio)\r\n{\r\nstruct iproc_gpio *chip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\niproc_set_bit(chip, IPROC_GPIO_OUT_EN_OFFSET, gpio, false);\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\ndev_dbg(chip->dev, "gpio:%u set input\n", gpio);\r\nreturn 0;\r\n}\r\nstatic int iproc_gpio_direction_output(struct gpio_chip *gc, unsigned gpio,\r\nint val)\r\n{\r\nstruct iproc_gpio *chip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\niproc_set_bit(chip, IPROC_GPIO_OUT_EN_OFFSET, gpio, true);\r\niproc_set_bit(chip, IPROC_GPIO_DATA_OUT_OFFSET, gpio, !!(val));\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\ndev_dbg(chip->dev, "gpio:%u set output, value:%d\n", gpio, val);\r\nreturn 0;\r\n}\r\nstatic void iproc_gpio_set(struct gpio_chip *gc, unsigned gpio, int val)\r\n{\r\nstruct iproc_gpio *chip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\niproc_set_bit(chip, IPROC_GPIO_DATA_OUT_OFFSET, gpio, !!(val));\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\ndev_dbg(chip->dev, "gpio:%u set, value:%d\n", gpio, val);\r\n}\r\nstatic int iproc_gpio_get(struct gpio_chip *gc, unsigned gpio)\r\n{\r\nstruct iproc_gpio *chip = gpiochip_get_data(gc);\r\nunsigned int offset = IPROC_GPIO_REG(gpio,\r\nIPROC_GPIO_DATA_IN_OFFSET);\r\nunsigned int shift = IPROC_GPIO_SHIFT(gpio);\r\nreturn !!(readl(chip->base + offset) & BIT(shift));\r\n}\r\nstatic bool iproc_pinconf_param_is_disabled(struct iproc_gpio *chip,\r\nenum pin_config_param param)\r\n{\r\nunsigned int i;\r\nif (!chip->nr_pinconf_disable)\r\nreturn false;\r\nfor (i = 0; i < chip->nr_pinconf_disable; i++)\r\nif (chip->pinconf_disable[i] == param)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int iproc_pinconf_disable_map_create(struct iproc_gpio *chip,\r\nunsigned long disable_mask)\r\n{\r\nunsigned int map_size = ARRAY_SIZE(iproc_pinconf_disable_map);\r\nunsigned int bit, nbits = 0;\r\nfor_each_set_bit(bit, &disable_mask, map_size)\r\nnbits++;\r\nif (!nbits)\r\nreturn 0;\r\nchip->pinconf_disable = devm_kcalloc(chip->dev, nbits,\r\nsizeof(*chip->pinconf_disable),\r\nGFP_KERNEL);\r\nif (!chip->pinconf_disable)\r\nreturn -ENOMEM;\r\nchip->nr_pinconf_disable = nbits;\r\nnbits = 0;\r\nfor_each_set_bit(bit, &disable_mask, map_size)\r\nchip->pinconf_disable[nbits++] = iproc_pinconf_disable_map[bit];\r\nreturn 0;\r\n}\r\nstatic int iproc_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn 1;\r\n}\r\nstatic const char *iproc_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nreturn "gpio_grp";\r\n}\r\nstatic int iproc_gpio_set_pull(struct iproc_gpio *chip, unsigned gpio,\r\nbool disable, bool pull_up)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\nif (disable) {\r\niproc_set_bit(chip, IPROC_GPIO_RES_EN_OFFSET, gpio, false);\r\n} else {\r\niproc_set_bit(chip, IPROC_GPIO_PAD_RES_OFFSET, gpio,\r\npull_up);\r\niproc_set_bit(chip, IPROC_GPIO_RES_EN_OFFSET, gpio, true);\r\n}\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\ndev_dbg(chip->dev, "gpio:%u set pullup:%d\n", gpio, pull_up);\r\nreturn 0;\r\n}\r\nstatic void iproc_gpio_get_pull(struct iproc_gpio *chip, unsigned gpio,\r\nbool *disable, bool *pull_up)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\n*disable = !iproc_get_bit(chip, IPROC_GPIO_RES_EN_OFFSET, gpio);\r\n*pull_up = iproc_get_bit(chip, IPROC_GPIO_PAD_RES_OFFSET, gpio);\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nstatic int iproc_gpio_set_strength(struct iproc_gpio *chip, unsigned gpio,\r\nunsigned strength)\r\n{\r\nvoid __iomem *base;\r\nunsigned int i, offset, shift;\r\nu32 val;\r\nunsigned long flags;\r\nif (strength < 2 || strength > 16 || (strength % 2))\r\nreturn -ENOTSUPP;\r\nif (chip->io_ctrl) {\r\nbase = chip->io_ctrl;\r\noffset = IPROC_GPIO_DRV0_CTRL_OFFSET;\r\n} else {\r\nbase = chip->base;\r\noffset = IPROC_GPIO_REG(gpio,\r\nIPROC_GPIO_ASIU_DRV0_CTRL_OFFSET);\r\n}\r\nshift = IPROC_GPIO_SHIFT(gpio);\r\ndev_dbg(chip->dev, "gpio:%u set drive strength:%d mA\n", gpio,\r\nstrength);\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\nstrength = (strength / 2) - 1;\r\nfor (i = 0; i < GPIO_DRV_STRENGTH_BITS; i++) {\r\nval = readl(base + offset);\r\nval &= ~BIT(shift);\r\nval |= ((strength >> i) & 0x1) << shift;\r\nwritel(val, base + offset);\r\noffset += 4;\r\n}\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int iproc_gpio_get_strength(struct iproc_gpio *chip, unsigned gpio,\r\nu16 *strength)\r\n{\r\nvoid __iomem *base;\r\nunsigned int i, offset, shift;\r\nu32 val;\r\nunsigned long flags;\r\nif (chip->io_ctrl) {\r\nbase = chip->io_ctrl;\r\noffset = IPROC_GPIO_DRV0_CTRL_OFFSET;\r\n} else {\r\nbase = chip->base;\r\noffset = IPROC_GPIO_REG(gpio,\r\nIPROC_GPIO_ASIU_DRV0_CTRL_OFFSET);\r\n}\r\nshift = IPROC_GPIO_SHIFT(gpio);\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\n*strength = 0;\r\nfor (i = 0; i < GPIO_DRV_STRENGTH_BITS; i++) {\r\nval = readl(base + offset) & BIT(shift);\r\nval >>= shift;\r\n*strength += (val << i);\r\noffset += 4;\r\n}\r\n*strength = (*strength + 1) * 2;\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int iproc_pin_config_get(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *config)\r\n{\r\nstruct iproc_gpio *chip = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nunsigned gpio = iproc_pin_to_gpio(pin);\r\nu16 arg;\r\nbool disable, pull_up;\r\nint ret;\r\nif (iproc_pinconf_param_is_disabled(chip, param))\r\nreturn -ENOTSUPP;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\niproc_gpio_get_pull(chip, gpio, &disable, &pull_up);\r\nif (disable)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\niproc_gpio_get_pull(chip, gpio, &disable, &pull_up);\r\nif (!disable && pull_up)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\niproc_gpio_get_pull(chip, gpio, &disable, &pull_up);\r\nif (!disable && !pull_up)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nret = iproc_gpio_get_strength(chip, gpio, &arg);\r\nif (ret)\r\nreturn ret;\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int iproc_pin_config_set(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nstruct iproc_gpio *chip = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param;\r\nu32 arg;\r\nunsigned i, gpio = iproc_pin_to_gpio(pin);\r\nint ret = -ENOTSUPP;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\nif (iproc_pinconf_param_is_disabled(chip, param))\r\nreturn -ENOTSUPP;\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nret = iproc_gpio_set_pull(chip, gpio, true, false);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nret = iproc_gpio_set_pull(chip, gpio, false, true);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nret = iproc_gpio_set_pull(chip, gpio, false, false);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nret = iproc_gpio_set_strength(chip, gpio, arg);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ndefault:\r\ndev_err(chip->dev, "invalid configuration\n");\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int iproc_gpio_register_pinconf(struct iproc_gpio *chip)\r\n{\r\nstruct pinctrl_desc *pctldesc = &chip->pctldesc;\r\nstruct pinctrl_pin_desc *pins;\r\nstruct gpio_chip *gc = &chip->gc;\r\nint i;\r\npins = devm_kcalloc(chip->dev, gc->ngpio, sizeof(*pins), GFP_KERNEL);\r\nif (!pins)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < gc->ngpio; i++) {\r\npins[i].number = i;\r\npins[i].name = devm_kasprintf(chip->dev, GFP_KERNEL,\r\n"gpio-%d", i);\r\nif (!pins[i].name)\r\nreturn -ENOMEM;\r\n}\r\npctldesc->name = dev_name(chip->dev);\r\npctldesc->pctlops = &iproc_pctrl_ops;\r\npctldesc->pins = pins;\r\npctldesc->npins = gc->ngpio;\r\npctldesc->confops = &iproc_pconf_ops;\r\nchip->pctl = devm_pinctrl_register(chip->dev, pctldesc, chip);\r\nif (IS_ERR(chip->pctl)) {\r\ndev_err(chip->dev, "unable to register pinctrl device\n");\r\nreturn PTR_ERR(chip->pctl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iproc_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct iproc_gpio *chip;\r\nstruct gpio_chip *gc;\r\nu32 ngpios, pinconf_disable_mask = 0;\r\nint irq, ret;\r\nbool no_pinconf = false;\r\nif (of_device_is_compatible(dev->of_node, "brcm,iproc-nsp-gpio"))\r\npinconf_disable_mask = BIT(IPROC_PINCONF_DRIVE_STRENGTH);\r\nelse if (of_device_is_compatible(dev->of_node,\r\n"brcm,iproc-stingray-gpio"))\r\nno_pinconf = true;\r\nchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->dev = dev;\r\nplatform_set_drvdata(pdev, chip);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nchip->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(chip->base)) {\r\ndev_err(dev, "unable to map I/O memory\n");\r\nreturn PTR_ERR(chip->base);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (res) {\r\nchip->io_ctrl = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(chip->io_ctrl)) {\r\ndev_err(dev, "unable to map I/O memory\n");\r\nreturn PTR_ERR(chip->io_ctrl);\r\n}\r\n}\r\nif (of_property_read_u32(dev->of_node, "ngpios", &ngpios)) {\r\ndev_err(&pdev->dev, "missing ngpios DT property\n");\r\nreturn -ENODEV;\r\n}\r\nraw_spin_lock_init(&chip->lock);\r\ngc = &chip->gc;\r\ngc->base = -1;\r\ngc->ngpio = ngpios;\r\nchip->num_banks = (ngpios + NGPIOS_PER_BANK - 1) / NGPIOS_PER_BANK;\r\ngc->label = dev_name(dev);\r\ngc->parent = dev;\r\ngc->of_node = dev->of_node;\r\ngc->request = iproc_gpio_request;\r\ngc->free = iproc_gpio_free;\r\ngc->direction_input = iproc_gpio_direction_input;\r\ngc->direction_output = iproc_gpio_direction_output;\r\ngc->set = iproc_gpio_set;\r\ngc->get = iproc_gpio_get;\r\nchip->pinmux_is_supported = of_property_read_bool(dev->of_node,\r\n"gpio-ranges");\r\nret = gpiochip_add_data(gc, chip);\r\nif (ret < 0) {\r\ndev_err(dev, "unable to add GPIO chip\n");\r\nreturn ret;\r\n}\r\nif (!no_pinconf) {\r\nret = iproc_gpio_register_pinconf(chip);\r\nif (ret) {\r\ndev_err(dev, "unable to register pinconf\n");\r\ngoto err_rm_gpiochip;\r\n}\r\nif (pinconf_disable_mask) {\r\nret = iproc_pinconf_disable_map_create(chip,\r\npinconf_disable_mask);\r\nif (ret) {\r\ndev_err(dev,\r\n"unable to create pinconf disable map\n");\r\ngoto err_rm_gpiochip;\r\n}\r\n}\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq) {\r\nret = gpiochip_irqchip_add(gc, &iproc_gpio_irq_chip, 0,\r\nhandle_simple_irq, IRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(dev, "no GPIO irqchip\n");\r\ngoto err_rm_gpiochip;\r\n}\r\ngpiochip_set_chained_irqchip(gc, &iproc_gpio_irq_chip, irq,\r\niproc_gpio_irq_handler);\r\n}\r\nreturn 0;\r\nerr_rm_gpiochip:\r\ngpiochip_remove(gc);\r\nreturn ret;\r\n}\r\nstatic int __init iproc_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&iproc_gpio_driver);\r\n}
