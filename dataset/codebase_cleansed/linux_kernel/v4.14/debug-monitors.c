u8 debug_monitors_arch(void)\r\n{\r\nreturn cpuid_feature_extract_unsigned_field(read_sanitised_ftr_reg(SYS_ID_AA64DFR0_EL1),\r\nID_AA64DFR0_DEBUGVER_SHIFT);\r\n}\r\nstatic void mdscr_write(u32 mdscr)\r\n{\r\nunsigned long flags;\r\nlocal_dbg_save(flags);\r\nwrite_sysreg(mdscr, mdscr_el1);\r\nlocal_dbg_restore(flags);\r\n}\r\nstatic u32 mdscr_read(void)\r\n{\r\nreturn read_sysreg(mdscr_el1);\r\n}\r\nstatic int create_debug_debugfs_entry(void)\r\n{\r\ndebugfs_create_bool("debug_enabled", 0644, NULL, &debug_enabled);\r\nreturn 0;\r\n}\r\nstatic int __init early_debug_disable(char *buf)\r\n{\r\ndebug_enabled = false;\r\nreturn 0;\r\n}\r\nvoid enable_debug_monitors(enum dbg_active_el el)\r\n{\r\nu32 mdscr, enable = 0;\r\nWARN_ON(preemptible());\r\nif (this_cpu_inc_return(mde_ref_count) == 1)\r\nenable = DBG_MDSCR_MDE;\r\nif (el == DBG_ACTIVE_EL1 &&\r\nthis_cpu_inc_return(kde_ref_count) == 1)\r\nenable |= DBG_MDSCR_KDE;\r\nif (enable && debug_enabled) {\r\nmdscr = mdscr_read();\r\nmdscr |= enable;\r\nmdscr_write(mdscr);\r\n}\r\n}\r\nvoid disable_debug_monitors(enum dbg_active_el el)\r\n{\r\nu32 mdscr, disable = 0;\r\nWARN_ON(preemptible());\r\nif (this_cpu_dec_return(mde_ref_count) == 0)\r\ndisable = ~DBG_MDSCR_MDE;\r\nif (el == DBG_ACTIVE_EL1 &&\r\nthis_cpu_dec_return(kde_ref_count) == 0)\r\ndisable &= ~DBG_MDSCR_KDE;\r\nif (disable) {\r\nmdscr = mdscr_read();\r\nmdscr &= disable;\r\nmdscr_write(mdscr);\r\n}\r\n}\r\nstatic int clear_os_lock(unsigned int cpu)\r\n{\r\nwrite_sysreg(0, oslar_el1);\r\nisb();\r\nreturn 0;\r\n}\r\nstatic int debug_monitors_init(void)\r\n{\r\nreturn cpuhp_setup_state(CPUHP_AP_ARM64_DEBUG_MONITORS_STARTING,\r\n"arm64/debug_monitors:starting",\r\nclear_os_lock, NULL);\r\n}\r\nstatic void set_regs_spsr_ss(struct pt_regs *regs)\r\n{\r\nregs->pstate |= DBG_SPSR_SS;\r\n}\r\nstatic void clear_regs_spsr_ss(struct pt_regs *regs)\r\n{\r\nregs->pstate &= ~DBG_SPSR_SS;\r\n}\r\nvoid register_step_hook(struct step_hook *hook)\r\n{\r\nspin_lock(&step_hook_lock);\r\nlist_add_rcu(&hook->node, &step_hook);\r\nspin_unlock(&step_hook_lock);\r\n}\r\nvoid unregister_step_hook(struct step_hook *hook)\r\n{\r\nspin_lock(&step_hook_lock);\r\nlist_del_rcu(&hook->node);\r\nspin_unlock(&step_hook_lock);\r\nsynchronize_rcu();\r\n}\r\nstatic int call_step_hook(struct pt_regs *regs, unsigned int esr)\r\n{\r\nstruct step_hook *hook;\r\nint retval = DBG_HOOK_ERROR;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hook, &step_hook, node) {\r\nretval = hook->fn(regs, esr);\r\nif (retval == DBG_HOOK_HANDLED)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn retval;\r\n}\r\nstatic void send_user_sigtrap(int si_code)\r\n{\r\nstruct pt_regs *regs = current_pt_regs();\r\nsiginfo_t info = {\r\n.si_signo = SIGTRAP,\r\n.si_errno = 0,\r\n.si_code = si_code,\r\n.si_addr = (void __user *)instruction_pointer(regs),\r\n};\r\nif (WARN_ON(!user_mode(regs)))\r\nreturn;\r\nif (interrupts_enabled(regs))\r\nlocal_irq_enable();\r\nforce_sig_info(SIGTRAP, &info, current);\r\n}\r\nstatic int single_step_handler(unsigned long addr, unsigned int esr,\r\nstruct pt_regs *regs)\r\n{\r\nbool handler_found = false;\r\nif (!reinstall_suspended_bps(regs))\r\nreturn 0;\r\n#ifdef CONFIG_KPROBES\r\nif (kprobe_single_step_handler(regs, esr) == DBG_HOOK_HANDLED)\r\nhandler_found = true;\r\n#endif\r\nif (!handler_found && call_step_hook(regs, esr) == DBG_HOOK_HANDLED)\r\nhandler_found = true;\r\nif (!handler_found && user_mode(regs)) {\r\nsend_user_sigtrap(TRAP_TRACE);\r\nuser_rewind_single_step(current);\r\n} else if (!handler_found) {\r\npr_warn("Unexpected kernel single-step exception at EL1\n");\r\nset_regs_spsr_ss(regs);\r\n}\r\nreturn 0;\r\n}\r\nvoid register_break_hook(struct break_hook *hook)\r\n{\r\nspin_lock(&break_hook_lock);\r\nlist_add_rcu(&hook->node, &break_hook);\r\nspin_unlock(&break_hook_lock);\r\n}\r\nvoid unregister_break_hook(struct break_hook *hook)\r\n{\r\nspin_lock(&break_hook_lock);\r\nlist_del_rcu(&hook->node);\r\nspin_unlock(&break_hook_lock);\r\nsynchronize_rcu();\r\n}\r\nstatic int call_break_hook(struct pt_regs *regs, unsigned int esr)\r\n{\r\nstruct break_hook *hook;\r\nint (*fn)(struct pt_regs *regs, unsigned int esr) = NULL;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hook, &break_hook, node)\r\nif ((esr & hook->esr_mask) == hook->esr_val)\r\nfn = hook->fn;\r\nrcu_read_unlock();\r\nreturn fn ? fn(regs, esr) : DBG_HOOK_ERROR;\r\n}\r\nstatic int brk_handler(unsigned long addr, unsigned int esr,\r\nstruct pt_regs *regs)\r\n{\r\nbool handler_found = false;\r\n#ifdef CONFIG_KPROBES\r\nif ((esr & BRK64_ESR_MASK) == BRK64_ESR_KPROBES) {\r\nif (kprobe_breakpoint_handler(regs, esr) == DBG_HOOK_HANDLED)\r\nhandler_found = true;\r\n}\r\n#endif\r\nif (!handler_found && call_break_hook(regs, esr) == DBG_HOOK_HANDLED)\r\nhandler_found = true;\r\nif (!handler_found && user_mode(regs)) {\r\nsend_user_sigtrap(TRAP_BRKPT);\r\n} else if (!handler_found) {\r\npr_warn("Unexpected kernel BRK exception at EL1\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nint aarch32_break_handler(struct pt_regs *regs)\r\n{\r\nu32 arm_instr;\r\nu16 thumb_instr;\r\nbool bp = false;\r\nvoid __user *pc = (void __user *)instruction_pointer(regs);\r\nif (!compat_user_mode(regs))\r\nreturn -EFAULT;\r\nif (compat_thumb_mode(regs)) {\r\n__le16 instr;\r\nget_user(instr, (__le16 __user *)pc);\r\nthumb_instr = le16_to_cpu(instr);\r\nif (thumb_instr == AARCH32_BREAK_THUMB2_LO) {\r\nget_user(instr, (__le16 __user *)(pc + 2));\r\nthumb_instr = le16_to_cpu(instr);\r\nbp = thumb_instr == AARCH32_BREAK_THUMB2_HI;\r\n} else {\r\nbp = thumb_instr == AARCH32_BREAK_THUMB;\r\n}\r\n} else {\r\n__le32 instr;\r\nget_user(instr, (__le32 __user *)pc);\r\narm_instr = le32_to_cpu(instr);\r\nbp = (arm_instr & ~0xf0000000) == AARCH32_BREAK_ARM;\r\n}\r\nif (!bp)\r\nreturn -EFAULT;\r\nsend_user_sigtrap(TRAP_BRKPT);\r\nreturn 0;\r\n}\r\nstatic int __init debug_traps_init(void)\r\n{\r\nhook_debug_fault_code(DBG_ESR_EVT_HWSS, single_step_handler, SIGTRAP,\r\nTRAP_TRACE, "single-step handler");\r\nhook_debug_fault_code(DBG_ESR_EVT_BRK, brk_handler, SIGTRAP,\r\nTRAP_BRKPT, "ptrace BRK handler");\r\nreturn 0;\r\n}\r\nvoid user_rewind_single_step(struct task_struct *task)\r\n{\r\nif (test_ti_thread_flag(task_thread_info(task), TIF_SINGLESTEP))\r\nset_regs_spsr_ss(task_pt_regs(task));\r\n}\r\nvoid user_fastforward_single_step(struct task_struct *task)\r\n{\r\nif (test_ti_thread_flag(task_thread_info(task), TIF_SINGLESTEP))\r\nclear_regs_spsr_ss(task_pt_regs(task));\r\n}\r\nvoid kernel_enable_single_step(struct pt_regs *regs)\r\n{\r\nWARN_ON(!irqs_disabled());\r\nset_regs_spsr_ss(regs);\r\nmdscr_write(mdscr_read() | DBG_MDSCR_SS);\r\nenable_debug_monitors(DBG_ACTIVE_EL1);\r\n}\r\nvoid kernel_disable_single_step(void)\r\n{\r\nWARN_ON(!irqs_disabled());\r\nmdscr_write(mdscr_read() & ~DBG_MDSCR_SS);\r\ndisable_debug_monitors(DBG_ACTIVE_EL1);\r\n}\r\nint kernel_active_single_step(void)\r\n{\r\nWARN_ON(!irqs_disabled());\r\nreturn mdscr_read() & DBG_MDSCR_SS;\r\n}\r\nvoid user_enable_single_step(struct task_struct *task)\r\n{\r\nstruct thread_info *ti = task_thread_info(task);\r\nif (!test_and_set_ti_thread_flag(ti, TIF_SINGLESTEP))\r\nset_regs_spsr_ss(task_pt_regs(task));\r\n}\r\nvoid user_disable_single_step(struct task_struct *task)\r\n{\r\nclear_ti_thread_flag(task_thread_info(task), TIF_SINGLESTEP);\r\n}
