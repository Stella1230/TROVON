static int i2c_mux_reg_set(const struct regmux *mux, unsigned int chan_id)\r\n{\r\nif (!mux->data.reg)\r\nreturn -EINVAL;\r\nswitch (mux->data.reg_size) {\r\ncase 4:\r\nif (mux->data.little_endian)\r\niowrite32(chan_id, mux->data.reg);\r\nelse\r\niowrite32be(chan_id, mux->data.reg);\r\nif (!mux->data.write_only)\r\nioread32(mux->data.reg);\r\nbreak;\r\ncase 2:\r\nif (mux->data.little_endian)\r\niowrite16(chan_id, mux->data.reg);\r\nelse\r\niowrite16be(chan_id, mux->data.reg);\r\nif (!mux->data.write_only)\r\nioread16(mux->data.reg);\r\nbreak;\r\ncase 1:\r\niowrite8(chan_id, mux->data.reg);\r\nif (!mux->data.write_only)\r\nioread8(mux->data.reg);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_mux_reg_select(struct i2c_mux_core *muxc, u32 chan)\r\n{\r\nstruct regmux *mux = i2c_mux_priv(muxc);\r\nreturn i2c_mux_reg_set(mux, chan);\r\n}\r\nstatic int i2c_mux_reg_deselect(struct i2c_mux_core *muxc, u32 chan)\r\n{\r\nstruct regmux *mux = i2c_mux_priv(muxc);\r\nif (mux->data.idle_in_use)\r\nreturn i2c_mux_reg_set(mux, mux->data.idle);\r\nreturn 0;\r\n}\r\nstatic int i2c_mux_reg_probe_dt(struct regmux *mux,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *adapter_np, *child;\r\nstruct i2c_adapter *adapter;\r\nstruct resource res;\r\nunsigned *values;\r\nint i = 0;\r\nif (!np)\r\nreturn -ENODEV;\r\nadapter_np = of_parse_phandle(np, "i2c-parent", 0);\r\nif (!adapter_np) {\r\ndev_err(&pdev->dev, "Cannot parse i2c-parent\n");\r\nreturn -ENODEV;\r\n}\r\nadapter = of_find_i2c_adapter_by_node(adapter_np);\r\nof_node_put(adapter_np);\r\nif (!adapter)\r\nreturn -EPROBE_DEFER;\r\nmux->data.parent = i2c_adapter_id(adapter);\r\nput_device(&adapter->dev);\r\nmux->data.n_values = of_get_child_count(np);\r\nif (of_find_property(np, "little-endian", NULL)) {\r\nmux->data.little_endian = true;\r\n} else if (of_find_property(np, "big-endian", NULL)) {\r\nmux->data.little_endian = false;\r\n} else {\r\n#if defined(__BYTE_ORDER) ? __BYTE_ORDER == __LITTLE_ENDIAN : \\r\ndefined(__LITTLE_ENDIAN)\r\nmux->data.little_endian = true;\r\n#elif defined(__BYTE_ORDER) ? __BYTE_ORDER == __BIG_ENDIAN : \\r\ndefined(__BIG_ENDIAN)\r\nmux->data.little_endian = false;\r\n#else\r\n#error Endianness not defined?\r\n#endif\r\n}\r\nif (of_find_property(np, "write-only", NULL))\r\nmux->data.write_only = true;\r\nelse\r\nmux->data.write_only = false;\r\nvalues = devm_kzalloc(&pdev->dev,\r\nsizeof(*mux->data.values) * mux->data.n_values,\r\nGFP_KERNEL);\r\nif (!values) {\r\ndev_err(&pdev->dev, "Cannot allocate values array");\r\nreturn -ENOMEM;\r\n}\r\nfor_each_child_of_node(np, child) {\r\nof_property_read_u32(child, "reg", values + i);\r\ni++;\r\n}\r\nmux->data.values = values;\r\nif (!of_property_read_u32(np, "idle-state", &mux->data.idle))\r\nmux->data.idle_in_use = true;\r\nif (of_address_to_resource(np, 0, &res) == 0) {\r\nmux->data.reg_size = resource_size(&res);\r\nmux->data.reg = devm_ioremap_resource(&pdev->dev, &res);\r\nif (IS_ERR(mux->data.reg))\r\nreturn PTR_ERR(mux->data.reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_mux_reg_probe_dt(struct regmux *mux,\r\nstruct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int i2c_mux_reg_probe(struct platform_device *pdev)\r\n{\r\nstruct i2c_mux_core *muxc;\r\nstruct regmux *mux;\r\nstruct i2c_adapter *parent;\r\nstruct resource *res;\r\nunsigned int class;\r\nint i, ret, nr;\r\nmux = devm_kzalloc(&pdev->dev, sizeof(*mux), GFP_KERNEL);\r\nif (!mux)\r\nreturn -ENOMEM;\r\nif (dev_get_platdata(&pdev->dev)) {\r\nmemcpy(&mux->data, dev_get_platdata(&pdev->dev),\r\nsizeof(mux->data));\r\n} else {\r\nret = i2c_mux_reg_probe_dt(mux, pdev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Error parsing device tree");\r\nreturn ret;\r\n}\r\n}\r\nparent = i2c_get_adapter(mux->data.parent);\r\nif (!parent)\r\nreturn -EPROBE_DEFER;\r\nif (!mux->data.reg) {\r\ndev_info(&pdev->dev,\r\n"Register not set, using platform resource\n");\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmux->data.reg_size = resource_size(res);\r\nmux->data.reg = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mux->data.reg)) {\r\nret = PTR_ERR(mux->data.reg);\r\ngoto err_put_parent;\r\n}\r\n}\r\nif (mux->data.reg_size != 4 && mux->data.reg_size != 2 &&\r\nmux->data.reg_size != 1) {\r\ndev_err(&pdev->dev, "Invalid register size\n");\r\nret = -EINVAL;\r\ngoto err_put_parent;\r\n}\r\nmuxc = i2c_mux_alloc(parent, &pdev->dev, mux->data.n_values, 0, 0,\r\ni2c_mux_reg_select, NULL);\r\nif (!muxc) {\r\nret = -ENOMEM;\r\ngoto err_put_parent;\r\n}\r\nmuxc->priv = mux;\r\nplatform_set_drvdata(pdev, muxc);\r\nif (mux->data.idle_in_use)\r\nmuxc->deselect = i2c_mux_reg_deselect;\r\nfor (i = 0; i < mux->data.n_values; i++) {\r\nnr = mux->data.base_nr ? (mux->data.base_nr + i) : 0;\r\nclass = mux->data.classes ? mux->data.classes[i] : 0;\r\nret = i2c_mux_add_adapter(muxc, nr, mux->data.values[i], class);\r\nif (ret)\r\ngoto err_del_mux_adapters;\r\n}\r\ndev_dbg(&pdev->dev, "%d port mux on %s adapter\n",\r\nmux->data.n_values, muxc->parent->name);\r\nreturn 0;\r\nerr_del_mux_adapters:\r\ni2c_mux_del_adapters(muxc);\r\nerr_put_parent:\r\ni2c_put_adapter(parent);\r\nreturn ret;\r\n}\r\nstatic int i2c_mux_reg_remove(struct platform_device *pdev)\r\n{\r\nstruct i2c_mux_core *muxc = platform_get_drvdata(pdev);\r\ni2c_mux_del_adapters(muxc);\r\ni2c_put_adapter(muxc->parent);\r\nreturn 0;\r\n}
