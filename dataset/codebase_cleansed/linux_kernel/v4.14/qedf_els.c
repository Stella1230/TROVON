static int qedf_initiate_els(struct qedf_rport *fcport, unsigned int op,\r\nvoid *data, uint32_t data_len,\r\nvoid (*cb_func)(struct qedf_els_cb_arg *cb_arg),\r\nstruct qedf_els_cb_arg *cb_arg, uint32_t timer_msec)\r\n{\r\nstruct qedf_ctx *qedf = fcport->qedf;\r\nstruct fc_lport *lport = qedf->lport;\r\nstruct qedf_ioreq *els_req;\r\nstruct qedf_mp_req *mp_req;\r\nstruct fc_frame_header *fc_hdr;\r\nstruct fcoe_task_context *task;\r\nint rc = 0;\r\nuint32_t did, sid;\r\nuint16_t xid;\r\nuint32_t start_time = jiffies / HZ;\r\nuint32_t current_time;\r\nstruct fcoe_wqe *sqe;\r\nunsigned long flags;\r\nu16 sqe_idx;\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, "Sending ELS\n");\r\nrc = fc_remote_port_chkready(fcport->rport);\r\nif (rc) {\r\nQEDF_ERR(&(qedf->dbg_ctx), "els 0x%x: rport not ready\n", op);\r\nrc = -EAGAIN;\r\ngoto els_err;\r\n}\r\nif (lport->state != LPORT_ST_READY || !(lport->link_up)) {\r\nQEDF_ERR(&(qedf->dbg_ctx), "els 0x%x: link is not ready\n",\r\nop);\r\nrc = -EAGAIN;\r\ngoto els_err;\r\n}\r\nif (!test_bit(QEDF_RPORT_SESSION_READY, &fcport->flags)) {\r\nQEDF_ERR(&(qedf->dbg_ctx), "els 0x%x: fcport not ready\n", op);\r\nrc = -EINVAL;\r\ngoto els_err;\r\n}\r\nretry_els:\r\nels_req = qedf_alloc_cmd(fcport, QEDF_ELS);\r\nif (!els_req) {\r\ncurrent_time = jiffies / HZ;\r\nif ((current_time - start_time) > 10) {\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\r\n"els: Failed els 0x%x\n", op);\r\nrc = -ENOMEM;\r\ngoto els_err;\r\n}\r\nmdelay(20 * USEC_PER_MSEC);\r\ngoto retry_els;\r\n}\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, "initiate_els els_req = "\r\n"0x%p cb_arg = %p xid = %x\n", els_req, cb_arg,\r\nels_req->xid);\r\nels_req->sc_cmd = NULL;\r\nels_req->cmd_type = QEDF_ELS;\r\nels_req->fcport = fcport;\r\nels_req->cb_func = cb_func;\r\ncb_arg->io_req = els_req;\r\ncb_arg->op = op;\r\nels_req->cb_arg = cb_arg;\r\nels_req->data_xfer_len = data_len;\r\nels_req->cpu = smp_processor_id();\r\nmp_req = (struct qedf_mp_req *)&(els_req->mp_req);\r\nrc = qedf_init_mp_req(els_req);\r\nif (rc) {\r\nQEDF_ERR(&(qedf->dbg_ctx), "ELS MP request init failed\n");\r\nkref_put(&els_req->refcount, qedf_release_cmd);\r\ngoto els_err;\r\n} else {\r\nrc = 0;\r\n}\r\nif ((op >= ELS_LS_RJT) && (op <= ELS_AUTH_ELS)) {\r\nmemcpy(mp_req->req_buf, data, data_len);\r\n} else {\r\nQEDF_ERR(&(qedf->dbg_ctx), "Invalid ELS op 0x%x\n", op);\r\nels_req->cb_func = NULL;\r\nels_req->cb_arg = NULL;\r\nkref_put(&els_req->refcount, qedf_release_cmd);\r\nrc = -EINVAL;\r\n}\r\nif (rc)\r\ngoto els_err;\r\nfc_hdr = &(mp_req->req_fc_hdr);\r\ndid = fcport->rdata->ids.port_id;\r\nsid = fcport->sid;\r\n__fc_fill_fc_hdr(fc_hdr, FC_RCTL_ELS_REQ, did, sid,\r\nFC_TYPE_ELS, FC_FC_FIRST_SEQ | FC_FC_END_SEQ |\r\nFC_FC_SEQ_INIT, 0);\r\nxid = els_req->xid;\r\nspin_lock_irqsave(&fcport->rport_lock, flags);\r\nsqe_idx = qedf_get_sqe_idx(fcport);\r\nsqe = &fcport->sq[sqe_idx];\r\nmemset(sqe, 0, sizeof(struct fcoe_wqe));\r\ntask = qedf_get_task_mem(&qedf->tasks, xid);\r\nqedf_init_mp_task(els_req, task, sqe);\r\nif (timer_msec)\r\nqedf_cmd_timer_set(qedf, els_req, timer_msec);\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, "Ringing doorbell for ELS "\r\n"req\n");\r\nqedf_ring_doorbell(fcport);\r\nspin_unlock_irqrestore(&fcport->rport_lock, flags);\r\nels_err:\r\nreturn rc;\r\n}\r\nvoid qedf_process_els_compl(struct qedf_ctx *qedf, struct fcoe_cqe *cqe,\r\nstruct qedf_ioreq *els_req)\r\n{\r\nstruct fcoe_task_context *task_ctx;\r\nstruct scsi_cmnd *sc_cmd;\r\nuint16_t xid;\r\nstruct fcoe_cqe_midpath_info *mp_info;\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, "Entered with xid = 0x%x"\r\n" cmd_type = %d.\n", els_req->xid, els_req->cmd_type);\r\ncancel_delayed_work(&els_req->timeout_work);\r\nxid = els_req->xid;\r\ntask_ctx = qedf_get_task_mem(&qedf->tasks, xid);\r\nsc_cmd = els_req->sc_cmd;\r\nmp_info = &cqe->cqe_info.midpath_info;\r\nels_req->mp_req.resp_len = mp_info->data_placement_size;\r\nif ((els_req->cb_func) && (els_req->cb_arg)) {\r\nels_req->cb_func(els_req->cb_arg);\r\nels_req->cb_arg = NULL;\r\n}\r\nkref_put(&els_req->refcount, qedf_release_cmd);\r\n}\r\nstatic void qedf_rrq_compl(struct qedf_els_cb_arg *cb_arg)\r\n{\r\nstruct qedf_ioreq *orig_io_req;\r\nstruct qedf_ioreq *rrq_req;\r\nstruct qedf_ctx *qedf;\r\nint refcount;\r\nrrq_req = cb_arg->io_req;\r\nqedf = rrq_req->fcport->qedf;\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, "Entered.\n");\r\norig_io_req = cb_arg->aborted_io_req;\r\nif (!orig_io_req)\r\ngoto out_free;\r\nif (rrq_req->event != QEDF_IOREQ_EV_ELS_TMO &&\r\nrrq_req->event != QEDF_IOREQ_EV_ELS_ERR_DETECT)\r\ncancel_delayed_work_sync(&orig_io_req->timeout_work);\r\nrefcount = kref_read(&orig_io_req->refcount);\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, "rrq_compl: orig io = %p,"\r\n" orig xid = 0x%x, rrq_xid = 0x%x, refcount=%d\n",\r\norig_io_req, orig_io_req->xid, rrq_req->xid, refcount);\r\nif (orig_io_req)\r\nkref_put(&orig_io_req->refcount, qedf_release_cmd);\r\nout_free:\r\nkfree(cb_arg);\r\n}\r\nint qedf_send_rrq(struct qedf_ioreq *aborted_io_req)\r\n{\r\nstruct fc_els_rrq rrq;\r\nstruct qedf_rport *fcport;\r\nstruct fc_lport *lport;\r\nstruct qedf_els_cb_arg *cb_arg = NULL;\r\nstruct qedf_ctx *qedf;\r\nuint32_t sid;\r\nuint32_t r_a_tov;\r\nint rc;\r\nif (!aborted_io_req) {\r\nQEDF_ERR(NULL, "abort_io_req is NULL.\n");\r\nreturn -EINVAL;\r\n}\r\nfcport = aborted_io_req->fcport;\r\nif (!test_bit(QEDF_RPORT_SESSION_READY, &fcport->flags)) {\r\nQEDF_ERR(NULL, "fcport is no longer offloaded.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fcport->qedf) {\r\nQEDF_ERR(NULL, "fcport->qedf is NULL.\n");\r\nreturn -EINVAL;\r\n}\r\nqedf = fcport->qedf;\r\nlport = qedf->lport;\r\nsid = fcport->sid;\r\nr_a_tov = lport->r_a_tov;\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, "Sending RRQ orig "\r\n"io = %p, orig_xid = 0x%x\n", aborted_io_req,\r\naborted_io_req->xid);\r\nmemset(&rrq, 0, sizeof(rrq));\r\ncb_arg = kzalloc(sizeof(struct qedf_els_cb_arg), GFP_NOIO);\r\nif (!cb_arg) {\r\nQEDF_ERR(&(qedf->dbg_ctx), "Unable to allocate cb_arg for "\r\n"RRQ\n");\r\nrc = -ENOMEM;\r\ngoto rrq_err;\r\n}\r\ncb_arg->aborted_io_req = aborted_io_req;\r\nrrq.rrq_cmd = ELS_RRQ;\r\nhton24(rrq.rrq_s_id, sid);\r\nrrq.rrq_ox_id = htons(aborted_io_req->xid);\r\nrrq.rrq_rx_id =\r\nhtons(aborted_io_req->task->tstorm_st_context.read_write.rx_id);\r\nrc = qedf_initiate_els(fcport, ELS_RRQ, &rrq, sizeof(rrq),\r\nqedf_rrq_compl, cb_arg, r_a_tov);\r\nrrq_err:\r\nif (rc) {\r\nQEDF_ERR(&(qedf->dbg_ctx), "RRQ failed - release orig io "\r\n"req 0x%x\n", aborted_io_req->xid);\r\nkfree(cb_arg);\r\nkref_put(&aborted_io_req->refcount, qedf_release_cmd);\r\n}\r\nreturn rc;\r\n}\r\nstatic void qedf_process_l2_frame_compl(struct qedf_rport *fcport,\r\nstruct fc_frame *fp,\r\nu16 l2_oxid)\r\n{\r\nstruct fc_lport *lport = fcport->qedf->lport;\r\nstruct fc_frame_header *fh;\r\nu32 crc;\r\nfh = (struct fc_frame_header *)fc_frame_header_get(fp);\r\nif (l2_oxid != FC_XID_UNKNOWN)\r\nfh->fh_ox_id = htons(l2_oxid);\r\nfh->fh_r_ctl = FC_RCTL_ELS_REP;\r\nfh->fh_type = FC_TYPE_ELS;\r\nfh->fh_f_ctl[0] = 0x98;\r\nhton24(fh->fh_d_id, lport->port_id);\r\nhton24(fh->fh_s_id, fcport->rdata->ids.port_id);\r\nfh->fh_rx_id = 0xffff;\r\ncrc = fcoe_fc_crc(fp);\r\nfc_frame_init(fp);\r\nfr_dev(fp) = lport;\r\nfr_sof(fp) = FC_SOF_I3;\r\nfr_eof(fp) = FC_EOF_T;\r\nfr_crc(fp) = cpu_to_le32(~crc);\r\nfc_exch_recv(lport, fp);\r\n}\r\nvoid qedf_restart_rport(struct qedf_rport *fcport)\r\n{\r\nstruct fc_lport *lport;\r\nstruct fc_rport_priv *rdata;\r\nu32 port_id;\r\nif (!fcport)\r\nreturn;\r\nrdata = fcport->rdata;\r\nif (rdata) {\r\nlport = fcport->qedf->lport;\r\nport_id = rdata->ids.port_id;\r\nQEDF_ERR(&(fcport->qedf->dbg_ctx),\r\n"LOGO port_id=%x.\n", port_id);\r\nfc_rport_logoff(rdata);\r\nrdata = fc_rport_create(lport, port_id);\r\nif (rdata)\r\nfc_rport_login(rdata);\r\n}\r\n}\r\nstatic void qedf_l2_els_compl(struct qedf_els_cb_arg *cb_arg)\r\n{\r\nstruct qedf_ioreq *els_req;\r\nstruct qedf_rport *fcport;\r\nstruct qedf_mp_req *mp_req;\r\nstruct fc_frame *fp;\r\nstruct fc_frame_header *fh, *mp_fc_hdr;\r\nvoid *resp_buf, *fc_payload;\r\nu32 resp_len;\r\nu16 l2_oxid;\r\nl2_oxid = cb_arg->l2_oxid;\r\nels_req = cb_arg->io_req;\r\nif (!els_req) {\r\nQEDF_ERR(NULL, "els_req is NULL.\n");\r\ngoto free_arg;\r\n}\r\nif (els_req->event == QEDF_IOREQ_EV_ELS_FLUSH)\r\ngoto free_arg;\r\nfcport = els_req->fcport;\r\nmp_req = &(els_req->mp_req);\r\nmp_fc_hdr = &(mp_req->resp_fc_hdr);\r\nresp_len = mp_req->resp_len;\r\nresp_buf = mp_req->resp_buf;\r\nif (els_req->event == QEDF_IOREQ_EV_ELS_TMO) {\r\nif (cb_arg->op == ELS_ADISC)\r\nqedf_restart_rport(fcport);\r\nreturn;\r\n}\r\nif (sizeof(struct fc_frame_header) + resp_len > QEDF_PAGE_SIZE) {\r\nQEDF_ERR(&(fcport->qedf->dbg_ctx), "resp_len is "\r\n"beyond page size.\n");\r\ngoto free_arg;\r\n}\r\nfp = fc_frame_alloc(fcport->qedf->lport, resp_len);\r\nif (!fp) {\r\nQEDF_ERR(&(fcport->qedf->dbg_ctx),\r\n"fc_frame_alloc failure.\n");\r\nreturn;\r\n}\r\nfh = (struct fc_frame_header *)fc_frame_header_get(fp);\r\nmemcpy(fh, mp_fc_hdr, sizeof(struct fc_frame_header));\r\nfc_payload = fc_frame_payload_get(fp, resp_len);\r\nmemcpy(fc_payload, resp_buf, resp_len);\r\nQEDF_INFO(&(fcport->qedf->dbg_ctx), QEDF_LOG_ELS,\r\n"Completing OX_ID 0x%x back to libfc.\n", l2_oxid);\r\nqedf_process_l2_frame_compl(fcport, fp, l2_oxid);\r\nfree_arg:\r\nkfree(cb_arg);\r\n}\r\nint qedf_send_adisc(struct qedf_rport *fcport, struct fc_frame *fp)\r\n{\r\nstruct fc_els_adisc *adisc;\r\nstruct fc_frame_header *fh;\r\nstruct fc_lport *lport = fcport->qedf->lport;\r\nstruct qedf_els_cb_arg *cb_arg = NULL;\r\nstruct qedf_ctx *qedf;\r\nuint32_t r_a_tov = lport->r_a_tov;\r\nint rc;\r\nqedf = fcport->qedf;\r\nfh = fc_frame_header_get(fp);\r\ncb_arg = kzalloc(sizeof(struct qedf_els_cb_arg), GFP_NOIO);\r\nif (!cb_arg) {\r\nQEDF_ERR(&(qedf->dbg_ctx), "Unable to allocate cb_arg for "\r\n"ADISC\n");\r\nrc = -ENOMEM;\r\ngoto adisc_err;\r\n}\r\ncb_arg->l2_oxid = ntohs(fh->fh_ox_id);\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\r\n"Sending ADISC ox_id=0x%x.\n", cb_arg->l2_oxid);\r\nadisc = fc_frame_payload_get(fp, sizeof(*adisc));\r\nrc = qedf_initiate_els(fcport, ELS_ADISC, adisc, sizeof(*adisc),\r\nqedf_l2_els_compl, cb_arg, r_a_tov);\r\nadisc_err:\r\nif (rc) {\r\nQEDF_ERR(&(qedf->dbg_ctx), "ADISC failed.\n");\r\nkfree(cb_arg);\r\n}\r\nreturn rc;\r\n}\r\nstatic void qedf_srr_compl(struct qedf_els_cb_arg *cb_arg)\r\n{\r\nstruct qedf_ioreq *orig_io_req;\r\nstruct qedf_ioreq *srr_req;\r\nstruct qedf_mp_req *mp_req;\r\nstruct fc_frame_header *mp_fc_hdr, *fh;\r\nstruct fc_frame *fp;\r\nvoid *resp_buf, *fc_payload;\r\nu32 resp_len;\r\nstruct fc_lport *lport;\r\nstruct qedf_ctx *qedf;\r\nint refcount;\r\nu8 opcode;\r\nsrr_req = cb_arg->io_req;\r\nqedf = srr_req->fcport->qedf;\r\nlport = qedf->lport;\r\norig_io_req = cb_arg->aborted_io_req;\r\nif (!orig_io_req)\r\ngoto out_free;\r\nclear_bit(QEDF_CMD_SRR_SENT, &orig_io_req->flags);\r\nif (srr_req->event != QEDF_IOREQ_EV_ELS_TMO &&\r\nsrr_req->event != QEDF_IOREQ_EV_ELS_ERR_DETECT)\r\ncancel_delayed_work_sync(&orig_io_req->timeout_work);\r\nrefcount = kref_read(&orig_io_req->refcount);\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, "Entered: orig_io=%p,"\r\n" orig_io_xid=0x%x, rec_xid=0x%x, refcount=%d\n",\r\norig_io_req, orig_io_req->xid, srr_req->xid, refcount);\r\nif (srr_req->event == QEDF_IOREQ_EV_ELS_TMO)\r\ngoto out_put;\r\nmp_req = &(srr_req->mp_req);\r\nmp_fc_hdr = &(mp_req->resp_fc_hdr);\r\nresp_len = mp_req->resp_len;\r\nresp_buf = mp_req->resp_buf;\r\nfp = fc_frame_alloc(lport, resp_len);\r\nif (!fp) {\r\nQEDF_ERR(&(qedf->dbg_ctx),\r\n"fc_frame_alloc failure.\n");\r\ngoto out_put;\r\n}\r\nfh = (struct fc_frame_header *)fc_frame_header_get(fp);\r\nmemcpy(fh, mp_fc_hdr, sizeof(struct fc_frame_header));\r\nfc_payload = fc_frame_payload_get(fp, resp_len);\r\nmemcpy(fc_payload, resp_buf, resp_len);\r\nopcode = fc_frame_payload_op(fp);\r\nswitch (opcode) {\r\ncase ELS_LS_ACC:\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\r\n"SRR success.\n");\r\nbreak;\r\ncase ELS_LS_RJT:\r\nQEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_ELS,\r\n"SRR rejected.\n");\r\nqedf_initiate_abts(orig_io_req, true);\r\nbreak;\r\n}\r\nfc_frame_free(fp);\r\nout_put:\r\nkref_put(&orig_io_req->refcount, qedf_release_cmd);\r\nout_free:\r\nkfree(cb_arg);\r\n}\r\nstatic int qedf_send_srr(struct qedf_ioreq *orig_io_req, u32 offset, u8 r_ctl)\r\n{\r\nstruct fcp_srr srr;\r\nstruct qedf_ctx *qedf;\r\nstruct qedf_rport *fcport;\r\nstruct fc_lport *lport;\r\nstruct qedf_els_cb_arg *cb_arg = NULL;\r\nu32 sid, r_a_tov;\r\nint rc;\r\nif (!orig_io_req) {\r\nQEDF_ERR(NULL, "orig_io_req is NULL.\n");\r\nreturn -EINVAL;\r\n}\r\nfcport = orig_io_req->fcport;\r\nif (!test_bit(QEDF_RPORT_SESSION_READY, &fcport->flags)) {\r\nQEDF_ERR(NULL, "fcport is no longer offloaded.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fcport->qedf) {\r\nQEDF_ERR(NULL, "fcport->qedf is NULL.\n");\r\nreturn -EINVAL;\r\n}\r\nkref_get(&orig_io_req->refcount);\r\nqedf = fcport->qedf;\r\nlport = qedf->lport;\r\nsid = fcport->sid;\r\nr_a_tov = lport->r_a_tov;\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, "Sending SRR orig_io=%p, "\r\n"orig_xid=0x%x\n", orig_io_req, orig_io_req->xid);\r\nmemset(&srr, 0, sizeof(srr));\r\ncb_arg = kzalloc(sizeof(struct qedf_els_cb_arg), GFP_NOIO);\r\nif (!cb_arg) {\r\nQEDF_ERR(&(qedf->dbg_ctx), "Unable to allocate cb_arg for "\r\n"SRR\n");\r\nrc = -ENOMEM;\r\ngoto srr_err;\r\n}\r\ncb_arg->aborted_io_req = orig_io_req;\r\nsrr.srr_op = ELS_SRR;\r\nsrr.srr_ox_id = htons(orig_io_req->xid);\r\nsrr.srr_rx_id = htons(orig_io_req->rx_id);\r\nsrr.srr_rel_off = htonl(offset);\r\nsrr.srr_r_ctl = r_ctl;\r\nrc = qedf_initiate_els(fcport, ELS_SRR, &srr, sizeof(srr),\r\nqedf_srr_compl, cb_arg, r_a_tov);\r\nsrr_err:\r\nif (rc) {\r\nQEDF_ERR(&(qedf->dbg_ctx), "SRR failed - release orig_io_req"\r\n"=0x%x\n", orig_io_req->xid);\r\nkfree(cb_arg);\r\nqedf_initiate_abts(orig_io_req, true);\r\nkref_put(&orig_io_req->refcount, qedf_release_cmd);\r\n} else\r\nset_bit(QEDF_CMD_SRR_SENT, &orig_io_req->flags);\r\nreturn rc;\r\n}\r\nstatic void qedf_initiate_seq_cleanup(struct qedf_ioreq *orig_io_req,\r\nu32 offset, u8 r_ctl)\r\n{\r\nstruct qedf_rport *fcport;\r\nunsigned long flags;\r\nstruct qedf_els_cb_arg *cb_arg;\r\nstruct fcoe_wqe *sqe;\r\nu16 sqe_idx;\r\nfcport = orig_io_req->fcport;\r\nQEDF_INFO(&(fcport->qedf->dbg_ctx), QEDF_LOG_ELS,\r\n"Doing sequence cleanup for xid=0x%x offset=%u.\n",\r\norig_io_req->xid, offset);\r\ncb_arg = kzalloc(sizeof(struct qedf_els_cb_arg), GFP_NOIO);\r\nif (!cb_arg) {\r\nQEDF_ERR(&(fcport->qedf->dbg_ctx), "Unable to allocate cb_arg "\r\n"for sequence cleanup\n");\r\nreturn;\r\n}\r\nkref_get(&orig_io_req->refcount);\r\norig_io_req->cmd_type = QEDF_SEQ_CLEANUP;\r\ncb_arg->offset = offset;\r\ncb_arg->r_ctl = r_ctl;\r\norig_io_req->cb_arg = cb_arg;\r\nqedf_cmd_timer_set(fcport->qedf, orig_io_req,\r\nQEDF_CLEANUP_TIMEOUT * HZ);\r\nspin_lock_irqsave(&fcport->rport_lock, flags);\r\nsqe_idx = qedf_get_sqe_idx(fcport);\r\nsqe = &fcport->sq[sqe_idx];\r\nmemset(sqe, 0, sizeof(struct fcoe_wqe));\r\norig_io_req->task_params->sqe = sqe;\r\ninit_initiator_sequence_recovery_fcoe_task(orig_io_req->task_params,\r\noffset);\r\nqedf_ring_doorbell(fcport);\r\nspin_unlock_irqrestore(&fcport->rport_lock, flags);\r\n}\r\nvoid qedf_process_seq_cleanup_compl(struct qedf_ctx *qedf,\r\nstruct fcoe_cqe *cqe, struct qedf_ioreq *io_req)\r\n{\r\nint rc;\r\nstruct qedf_els_cb_arg *cb_arg;\r\ncb_arg = io_req->cb_arg;\r\nif (io_req->event == QEDF_IOREQ_EV_ELS_TMO || !cqe)\r\ngoto free;\r\ncancel_delayed_work_sync(&io_req->timeout_work);\r\nrc = qedf_send_srr(io_req, cb_arg->offset, cb_arg->r_ctl);\r\nif (rc)\r\nQEDF_ERR(&(qedf->dbg_ctx), "Unable to send SRR, I/O will "\r\n"abort, xid=0x%x.\n", io_req->xid);\r\nfree:\r\nkfree(cb_arg);\r\nkref_put(&io_req->refcount, qedf_release_cmd);\r\n}\r\nstatic bool qedf_requeue_io_req(struct qedf_ioreq *orig_io_req)\r\n{\r\nstruct qedf_rport *fcport;\r\nstruct qedf_ioreq *new_io_req;\r\nunsigned long flags;\r\nbool rc = false;\r\nfcport = orig_io_req->fcport;\r\nif (!fcport) {\r\nQEDF_ERR(NULL, "fcport is NULL.\n");\r\ngoto out;\r\n}\r\nif (!orig_io_req->sc_cmd) {\r\nQEDF_ERR(&(fcport->qedf->dbg_ctx), "sc_cmd is NULL for "\r\n"xid=0x%x.\n", orig_io_req->xid);\r\ngoto out;\r\n}\r\nnew_io_req = qedf_alloc_cmd(fcport, QEDF_SCSI_CMD);\r\nif (!new_io_req) {\r\nQEDF_ERR(&(fcport->qedf->dbg_ctx), "Could not allocate new "\r\n"io_req.\n");\r\ngoto out;\r\n}\r\nnew_io_req->sc_cmd = orig_io_req->sc_cmd;\r\norig_io_req->sc_cmd = NULL;\r\nkref_put(&orig_io_req->refcount, qedf_release_cmd);\r\nspin_lock_irqsave(&fcport->rport_lock, flags);\r\nif (qedf_post_io_req(fcport, new_io_req)) {\r\nQEDF_ERR(&(fcport->qedf->dbg_ctx), "Unable to post io_req\n");\r\natomic_inc(&fcport->free_sqes);\r\n} else {\r\nQEDF_INFO(&(fcport->qedf->dbg_ctx), QEDF_LOG_ELS,\r\n"Reissued SCSI command from orig_xid=0x%x on "\r\n"new_xid=0x%x.\n", orig_io_req->xid, new_io_req->xid);\r\nspin_unlock_irqrestore(&fcport->rport_lock, flags);\r\nqedf_initiate_abts(orig_io_req, false);\r\ngoto out;\r\n}\r\nspin_unlock_irqrestore(&fcport->rport_lock, flags);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void qedf_rec_compl(struct qedf_els_cb_arg *cb_arg)\r\n{\r\nstruct qedf_ioreq *orig_io_req;\r\nstruct qedf_ioreq *rec_req;\r\nstruct qedf_mp_req *mp_req;\r\nstruct fc_frame_header *mp_fc_hdr, *fh;\r\nstruct fc_frame *fp;\r\nvoid *resp_buf, *fc_payload;\r\nu32 resp_len;\r\nstruct fc_lport *lport;\r\nstruct qedf_ctx *qedf;\r\nint refcount;\r\nenum fc_rctl r_ctl;\r\nstruct fc_els_ls_rjt *rjt;\r\nstruct fc_els_rec_acc *acc;\r\nu8 opcode;\r\nu32 offset, e_stat;\r\nstruct scsi_cmnd *sc_cmd;\r\nbool srr_needed = false;\r\nrec_req = cb_arg->io_req;\r\nqedf = rec_req->fcport->qedf;\r\nlport = qedf->lport;\r\norig_io_req = cb_arg->aborted_io_req;\r\nif (!orig_io_req)\r\ngoto out_free;\r\nif (rec_req->event != QEDF_IOREQ_EV_ELS_TMO &&\r\nrec_req->event != QEDF_IOREQ_EV_ELS_ERR_DETECT)\r\ncancel_delayed_work_sync(&orig_io_req->timeout_work);\r\nrefcount = kref_read(&orig_io_req->refcount);\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, "Entered: orig_io=%p,"\r\n" orig_io_xid=0x%x, rec_xid=0x%x, refcount=%d\n",\r\norig_io_req, orig_io_req->xid, rec_req->xid, refcount);\r\nif (rec_req->event == QEDF_IOREQ_EV_ELS_TMO)\r\ngoto out_put;\r\nmp_req = &(rec_req->mp_req);\r\nmp_fc_hdr = &(mp_req->resp_fc_hdr);\r\nresp_len = mp_req->resp_len;\r\nacc = resp_buf = mp_req->resp_buf;\r\nfp = fc_frame_alloc(lport, resp_len);\r\nif (!fp) {\r\nQEDF_ERR(&(qedf->dbg_ctx),\r\n"fc_frame_alloc failure.\n");\r\ngoto out_put;\r\n}\r\nfh = (struct fc_frame_header *)fc_frame_header_get(fp);\r\nmemcpy(fh, mp_fc_hdr, sizeof(struct fc_frame_header));\r\nfc_payload = fc_frame_payload_get(fp, resp_len);\r\nmemcpy(fc_payload, resp_buf, resp_len);\r\nopcode = fc_frame_payload_op(fp);\r\nif (opcode == ELS_LS_RJT) {\r\nrjt = fc_frame_payload_get(fp, sizeof(*rjt));\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\r\n"Received LS_RJT for REC: er_reason=0x%x, "\r\n"er_explan=0x%x.\n", rjt->er_reason, rjt->er_explan);\r\nif ((rjt->er_reason == ELS_RJT_LOGIC ||\r\nrjt->er_reason == ELS_RJT_UNAB) &&\r\nrjt->er_explan == ELS_EXPL_OXID_RXID) {\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\r\n"Handle CMD LOST case.\n");\r\nqedf_requeue_io_req(orig_io_req);\r\n}\r\n} else if (opcode == ELS_LS_ACC) {\r\noffset = ntohl(acc->reca_fc4value);\r\ne_stat = ntohl(acc->reca_e_stat);\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\r\n"Received LS_ACC for REC: offset=0x%x, e_stat=0x%x.\n",\r\noffset, e_stat);\r\nif (e_stat & ESB_ST_SEQ_INIT) {\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\r\n"Target has the seq init\n");\r\ngoto out_free_frame;\r\n}\r\nsc_cmd = orig_io_req->sc_cmd;\r\nif (!sc_cmd) {\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\r\n"sc_cmd is NULL for xid=0x%x.\n",\r\norig_io_req->xid);\r\ngoto out_free_frame;\r\n}\r\nif (sc_cmd->sc_data_direction == DMA_TO_DEVICE) {\r\nif (offset == orig_io_req->data_xfer_len) {\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\r\n"WRITE - response lost.\n");\r\nr_ctl = FC_RCTL_DD_CMD_STATUS;\r\nsrr_needed = true;\r\noffset = 0;\r\n} else {\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\r\n"WRITE - XFER_RDY/DATA lost.\n");\r\nr_ctl = FC_RCTL_DD_DATA_DESC;\r\noffset = orig_io_req->tx_buf_off;\r\n}\r\n} else {\r\nif (orig_io_req->rx_buf_off ==\r\norig_io_req->data_xfer_len) {\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\r\n"READ - response lost.\n");\r\nsrr_needed = true;\r\nr_ctl = FC_RCTL_DD_CMD_STATUS;\r\noffset = 0;\r\n} else {\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\r\n"READ - DATA lost.\n");\r\noffset = 0;\r\nr_ctl = FC_RCTL_DD_SOL_DATA;\r\n}\r\n}\r\nif (srr_needed)\r\nqedf_send_srr(orig_io_req, offset, r_ctl);\r\nelse\r\nqedf_initiate_seq_cleanup(orig_io_req, offset, r_ctl);\r\n}\r\nout_free_frame:\r\nfc_frame_free(fp);\r\nout_put:\r\nkref_put(&orig_io_req->refcount, qedf_release_cmd);\r\nout_free:\r\nkfree(cb_arg);\r\n}\r\nint qedf_send_rec(struct qedf_ioreq *orig_io_req)\r\n{\r\nstruct fc_els_rec rec;\r\nstruct qedf_rport *fcport;\r\nstruct fc_lport *lport;\r\nstruct qedf_els_cb_arg *cb_arg = NULL;\r\nstruct qedf_ctx *qedf;\r\nuint32_t sid;\r\nuint32_t r_a_tov;\r\nint rc;\r\nif (!orig_io_req) {\r\nQEDF_ERR(NULL, "orig_io_req is NULL.\n");\r\nreturn -EINVAL;\r\n}\r\nfcport = orig_io_req->fcport;\r\nif (!test_bit(QEDF_RPORT_SESSION_READY, &fcport->flags)) {\r\nQEDF_ERR(NULL, "fcport is no longer offloaded.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fcport->qedf) {\r\nQEDF_ERR(NULL, "fcport->qedf is NULL.\n");\r\nreturn -EINVAL;\r\n}\r\nkref_get(&orig_io_req->refcount);\r\nqedf = fcport->qedf;\r\nlport = qedf->lport;\r\nsid = fcport->sid;\r\nr_a_tov = lport->r_a_tov;\r\nmemset(&rec, 0, sizeof(rec));\r\ncb_arg = kzalloc(sizeof(struct qedf_els_cb_arg), GFP_NOIO);\r\nif (!cb_arg) {\r\nQEDF_ERR(&(qedf->dbg_ctx), "Unable to allocate cb_arg for "\r\n"REC\n");\r\nrc = -ENOMEM;\r\ngoto rec_err;\r\n}\r\ncb_arg->aborted_io_req = orig_io_req;\r\nrec.rec_cmd = ELS_REC;\r\nhton24(rec.rec_s_id, sid);\r\nrec.rec_ox_id = htons(orig_io_req->xid);\r\nrec.rec_rx_id =\r\nhtons(orig_io_req->task->tstorm_st_context.read_write.rx_id);\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, "Sending REC orig_io=%p, "\r\n"orig_xid=0x%x rx_id=0x%x\n", orig_io_req,\r\norig_io_req->xid, rec.rec_rx_id);\r\nrc = qedf_initiate_els(fcport, ELS_REC, &rec, sizeof(rec),\r\nqedf_rec_compl, cb_arg, r_a_tov);\r\nrec_err:\r\nif (rc) {\r\nQEDF_ERR(&(qedf->dbg_ctx), "REC failed - release orig_io_req"\r\n"=0x%x\n", orig_io_req->xid);\r\nkfree(cb_arg);\r\nkref_put(&orig_io_req->refcount, qedf_release_cmd);\r\n}\r\nreturn rc;\r\n}
