static struct peak_canfd_priv *pucan_init_cmd(struct peak_canfd_priv *priv)\r\n{\r\npriv->cmd_len = 0;\r\nreturn priv;\r\n}\r\nstatic void *pucan_add_cmd(struct peak_canfd_priv *priv, int cmd_op)\r\n{\r\nstruct pucan_command *cmd;\r\nif (priv->cmd_len + sizeof(*cmd) > priv->cmd_maxlen)\r\nreturn NULL;\r\ncmd = priv->cmd_buffer + priv->cmd_len;\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->opcode_channel = pucan_cmd_opcode_channel(priv->index, cmd_op);\r\npriv->cmd_len += sizeof(*cmd);\r\nreturn cmd;\r\n}\r\nstatic int pucan_write_cmd(struct peak_canfd_priv *priv)\r\n{\r\nint err;\r\nif (priv->pre_cmd) {\r\nerr = priv->pre_cmd(priv);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = priv->write_cmd(priv);\r\nif (err)\r\nreturn err;\r\nif (priv->post_cmd)\r\nerr = priv->post_cmd(priv);\r\nreturn err;\r\n}\r\nstatic int pucan_set_reset_mode(struct peak_canfd_priv *priv)\r\n{\r\npucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_RESET_MODE);\r\nreturn pucan_write_cmd(priv);\r\n}\r\nstatic int pucan_set_normal_mode(struct peak_canfd_priv *priv)\r\n{\r\nint err;\r\npucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_NORMAL_MODE);\r\nerr = pucan_write_cmd(priv);\r\nif (!err)\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn err;\r\n}\r\nstatic int pucan_set_listen_only_mode(struct peak_canfd_priv *priv)\r\n{\r\nint err;\r\npucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_LISTEN_ONLY_MODE);\r\nerr = pucan_write_cmd(priv);\r\nif (!err)\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn err;\r\n}\r\nstatic int pucan_set_timing_slow(struct peak_canfd_priv *priv,\r\nconst struct can_bittiming *pbt)\r\n{\r\nstruct pucan_timing_slow *cmd;\r\ncmd = pucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_TIMING_SLOW);\r\ncmd->sjw_t = PUCAN_TSLOW_SJW_T(pbt->sjw - 1,\r\npriv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES);\r\ncmd->tseg1 = PUCAN_TSLOW_TSEG1(pbt->prop_seg + pbt->phase_seg1 - 1);\r\ncmd->tseg2 = PUCAN_TSLOW_TSEG2(pbt->phase_seg2 - 1);\r\ncmd->brp = cpu_to_le16(PUCAN_TSLOW_BRP(pbt->brp - 1));\r\ncmd->ewl = 96;\r\nnetdev_dbg(priv->ndev,\r\n"nominal: brp=%u tseg1=%u tseg2=%u sjw=%u\n",\r\nle16_to_cpu(cmd->brp), cmd->tseg1, cmd->tseg2, cmd->sjw_t);\r\nreturn pucan_write_cmd(priv);\r\n}\r\nstatic int pucan_set_timing_fast(struct peak_canfd_priv *priv,\r\nconst struct can_bittiming *pbt)\r\n{\r\nstruct pucan_timing_fast *cmd;\r\ncmd = pucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_TIMING_FAST);\r\ncmd->sjw = PUCAN_TFAST_SJW(pbt->sjw - 1);\r\ncmd->tseg1 = PUCAN_TFAST_TSEG1(pbt->prop_seg + pbt->phase_seg1 - 1);\r\ncmd->tseg2 = PUCAN_TFAST_TSEG2(pbt->phase_seg2 - 1);\r\ncmd->brp = cpu_to_le16(PUCAN_TFAST_BRP(pbt->brp - 1));\r\nnetdev_dbg(priv->ndev,\r\n"data: brp=%u tseg1=%u tseg2=%u sjw=%u\n",\r\nle16_to_cpu(cmd->brp), cmd->tseg1, cmd->tseg2, cmd->sjw);\r\nreturn pucan_write_cmd(priv);\r\n}\r\nstatic int pucan_set_std_filter(struct peak_canfd_priv *priv, u8 row, u32 mask)\r\n{\r\nstruct pucan_std_filter *cmd;\r\ncmd = pucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_SET_STD_FILTER);\r\ncmd->idx = row;\r\ncmd->mask = cpu_to_le32(mask);\r\nreturn pucan_write_cmd(priv);\r\n}\r\nstatic int pucan_tx_abort(struct peak_canfd_priv *priv, u16 flags)\r\n{\r\nstruct pucan_tx_abort *cmd;\r\ncmd = pucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_TX_ABORT);\r\ncmd->flags = cpu_to_le16(flags);\r\nreturn pucan_write_cmd(priv);\r\n}\r\nstatic int pucan_clr_err_counters(struct peak_canfd_priv *priv)\r\n{\r\nstruct pucan_wr_err_cnt *cmd;\r\ncmd = pucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_WR_ERR_CNT);\r\ncmd->sel_mask = cpu_to_le16(PUCAN_WRERRCNT_TE | PUCAN_WRERRCNT_RE);\r\ncmd->tx_counter = 0;\r\ncmd->rx_counter = 0;\r\nreturn pucan_write_cmd(priv);\r\n}\r\nstatic int pucan_set_options(struct peak_canfd_priv *priv, u16 opt_mask)\r\n{\r\nstruct pucan_options *cmd;\r\ncmd = pucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_SET_EN_OPTION);\r\ncmd->options = cpu_to_le16(opt_mask);\r\nreturn pucan_write_cmd(priv);\r\n}\r\nstatic int pucan_clr_options(struct peak_canfd_priv *priv, u16 opt_mask)\r\n{\r\nstruct pucan_options *cmd;\r\ncmd = pucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_CLR_DIS_OPTION);\r\ncmd->options = cpu_to_le16(opt_mask);\r\nreturn pucan_write_cmd(priv);\r\n}\r\nstatic int pucan_setup_rx_barrier(struct peak_canfd_priv *priv)\r\n{\r\npucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_RX_BARRIER);\r\nreturn pucan_write_cmd(priv);\r\n}\r\nstatic int pucan_handle_can_rx(struct peak_canfd_priv *priv,\r\nstruct pucan_rx_msg *msg)\r\n{\r\nstruct net_device_stats *stats = &priv->ndev->stats;\r\nstruct canfd_frame *cf;\r\nstruct sk_buff *skb;\r\nconst u16 rx_msg_flags = le16_to_cpu(msg->flags);\r\nu8 cf_len;\r\nif (rx_msg_flags & PUCAN_MSG_EXT_DATA_LEN)\r\ncf_len = can_dlc2len(get_canfd_dlc(pucan_msg_get_dlc(msg)));\r\nelse\r\ncf_len = get_can_dlc(pucan_msg_get_dlc(msg));\r\nif ((rx_msg_flags & PUCAN_MSG_LOOPED_BACK) &&\r\n!(rx_msg_flags & PUCAN_MSG_SELF_RECEIVE)) {\r\nint n;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->echo_lock, flags);\r\nn = can_get_echo_skb(priv->ndev, msg->client);\r\nspin_unlock_irqrestore(&priv->echo_lock, flags);\r\nstats->tx_bytes += cf_len;\r\nstats->tx_packets++;\r\nif (n) {\r\nnetif_wake_queue(priv->ndev);\r\n}\r\nreturn 0;\r\n}\r\nif (rx_msg_flags & PUCAN_MSG_EXT_DATA_LEN) {\r\nskb = alloc_canfd_skb(priv->ndev, &cf);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nif (rx_msg_flags & PUCAN_MSG_BITRATE_SWITCH)\r\ncf->flags |= CANFD_BRS;\r\nif (rx_msg_flags & PUCAN_MSG_ERROR_STATE_IND)\r\ncf->flags |= CANFD_ESI;\r\n} else {\r\nskb = alloc_can_skb(priv->ndev, (struct can_frame **)&cf);\r\nif (!skb)\r\nreturn -ENOMEM;\r\n}\r\ncf->can_id = le32_to_cpu(msg->can_id);\r\ncf->len = cf_len;\r\nif (rx_msg_flags & PUCAN_MSG_EXT_ID)\r\ncf->can_id |= CAN_EFF_FLAG;\r\nif (rx_msg_flags & PUCAN_MSG_RTR)\r\ncf->can_id |= CAN_RTR_FLAG;\r\nelse\r\nmemcpy(cf->data, msg->d, cf->len);\r\nstats->rx_bytes += cf->len;\r\nstats->rx_packets++;\r\nnetif_rx(skb);\r\nreturn 0;\r\n}\r\nstatic int pucan_handle_error(struct peak_canfd_priv *priv,\r\nstruct pucan_error_msg *msg)\r\n{\r\npriv->bec.txerr = msg->tx_err_cnt;\r\npriv->bec.rxerr = msg->rx_err_cnt;\r\nreturn 0;\r\n}\r\nstatic int pucan_handle_status(struct peak_canfd_priv *priv,\r\nstruct pucan_status_msg *msg)\r\n{\r\nstruct net_device *ndev = priv->ndev;\r\nstruct net_device_stats *stats = &ndev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nif (pucan_status_is_rx_barrier(msg)) {\r\nunsigned long flags;\r\nif (priv->enable_tx_path) {\r\nint err = priv->enable_tx_path(priv);\r\nif (err)\r\nreturn err;\r\n}\r\nspin_lock_irqsave(&priv->echo_lock, flags);\r\nif (!priv->can.echo_skb[priv->echo_idx]) {\r\nspin_unlock_irqrestore(&priv->echo_lock, flags);\r\nnetif_wake_queue(ndev);\r\n} else {\r\nspin_unlock_irqrestore(&priv->echo_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nskb = alloc_can_err_skb(ndev, &cf);\r\nif (pucan_status_is_busoff(msg)) {\r\nnetdev_dbg(ndev, "Bus-off entry status\n");\r\npriv->can.state = CAN_STATE_BUS_OFF;\r\npriv->can.can_stats.bus_off++;\r\ncan_bus_off(ndev);\r\nif (skb)\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\n} else if (pucan_status_is_passive(msg)) {\r\nnetdev_dbg(ndev, "Error passive status\n");\r\npriv->can.state = CAN_STATE_ERROR_PASSIVE;\r\npriv->can.can_stats.error_passive++;\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = (priv->bec.txerr > priv->bec.rxerr) ?\r\nCAN_ERR_CRTL_TX_PASSIVE :\r\nCAN_ERR_CRTL_RX_PASSIVE;\r\ncf->data[6] = priv->bec.txerr;\r\ncf->data[7] = priv->bec.rxerr;\r\n}\r\n} else if (pucan_status_is_warning(msg)) {\r\nnetdev_dbg(ndev, "Error warning status\n");\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\npriv->can.can_stats.error_warning++;\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = (priv->bec.txerr > priv->bec.rxerr) ?\r\nCAN_ERR_CRTL_TX_WARNING :\r\nCAN_ERR_CRTL_RX_WARNING;\r\ncf->data[6] = priv->bec.txerr;\r\ncf->data[7] = priv->bec.rxerr;\r\n}\r\n} else if (priv->can.state != CAN_STATE_ERROR_ACTIVE) {\r\nnetdev_dbg(ndev, "Error active status\n");\r\ncan_change_state(ndev, cf, CAN_STATE_ERROR_ACTIVE,\r\nCAN_STATE_ERROR_ACTIVE);\r\n} else {\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nif (!skb) {\r\nstats->rx_dropped++;\r\nreturn -ENOMEM;\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\nreturn 0;\r\n}\r\nstatic int pucan_handle_cache_critical(struct peak_canfd_priv *priv)\r\n{\r\nstruct net_device_stats *stats = &priv->ndev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\nskb = alloc_can_err_skb(priv->ndev, &cf);\r\nif (!skb) {\r\nstats->rx_dropped++;\r\nreturn -ENOMEM;\r\n}\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\ncf->data[6] = priv->bec.txerr;\r\ncf->data[7] = priv->bec.rxerr;\r\nstats->rx_bytes += cf->can_dlc;\r\nstats->rx_packets++;\r\nnetif_rx(skb);\r\nreturn 0;\r\n}\r\nint peak_canfd_handle_msg(struct peak_canfd_priv *priv,\r\nstruct pucan_rx_msg *msg)\r\n{\r\nu16 msg_type = le16_to_cpu(msg->type);\r\nint msg_size = le16_to_cpu(msg->size);\r\nint err;\r\nif (!msg_size || !msg_type) {\r\ngoto exit;\r\n}\r\nswitch (msg_type) {\r\ncase PUCAN_MSG_CAN_RX:\r\nerr = pucan_handle_can_rx(priv, (struct pucan_rx_msg *)msg);\r\nbreak;\r\ncase PUCAN_MSG_ERROR:\r\nerr = pucan_handle_error(priv, (struct pucan_error_msg *)msg);\r\nbreak;\r\ncase PUCAN_MSG_STATUS:\r\nerr = pucan_handle_status(priv, (struct pucan_status_msg *)msg);\r\nbreak;\r\ncase PUCAN_MSG_CACHE_CRITICAL:\r\nerr = pucan_handle_cache_critical(priv);\r\nbreak;\r\ndefault:\r\nerr = 0;\r\n}\r\nif (err < 0)\r\nreturn err;\r\nexit:\r\nreturn msg_size;\r\n}\r\nint peak_canfd_handle_msgs_list(struct peak_canfd_priv *priv,\r\nstruct pucan_rx_msg *msg_list, int msg_count)\r\n{\r\nvoid *msg_ptr = msg_list;\r\nint i, msg_size = 0;\r\nfor (i = 0; i < msg_count; i++) {\r\nmsg_size = peak_canfd_handle_msg(priv, msg_ptr);\r\nif (msg_size <= 0)\r\nbreak;\r\nmsg_ptr += msg_size;\r\n}\r\nif (msg_size < 0)\r\nreturn msg_size;\r\nreturn i;\r\n}\r\nstatic int peak_canfd_start(struct peak_canfd_priv *priv)\r\n{\r\nint err;\r\nerr = pucan_clr_err_counters(priv);\r\nif (err)\r\ngoto err_exit;\r\npriv->echo_idx = 0;\r\npriv->bec.txerr = 0;\r\npriv->bec.rxerr = 0;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\r\nerr = pucan_set_listen_only_mode(priv);\r\nelse\r\nerr = pucan_set_normal_mode(priv);\r\nerr_exit:\r\nreturn err;\r\n}\r\nstatic void peak_canfd_stop(struct peak_canfd_priv *priv)\r\n{\r\nint err;\r\nerr = pucan_set_reset_mode(priv);\r\nif (err) {\r\nnetdev_err(priv->ndev, "channel %u reset failed\n",\r\npriv->index);\r\n} else {\r\npucan_tx_abort(priv, PUCAN_TX_ABORT_FLUSH);\r\n}\r\n}\r\nstatic int peak_canfd_set_mode(struct net_device *ndev, enum can_mode mode)\r\n{\r\nstruct peak_canfd_priv *priv = netdev_priv(ndev);\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\npeak_canfd_start(priv);\r\nnetif_wake_queue(ndev);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int peak_canfd_get_berr_counter(const struct net_device *ndev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct peak_canfd_priv *priv = netdev_priv(ndev);\r\n*bec = priv->bec;\r\nreturn 0;\r\n}\r\nstatic int peak_canfd_open(struct net_device *ndev)\r\n{\r\nstruct peak_canfd_priv *priv = netdev_priv(ndev);\r\nint i, err = 0;\r\nerr = open_candev(ndev);\r\nif (err) {\r\nnetdev_err(ndev, "open_candev() failed, error %d\n", err);\r\ngoto err_exit;\r\n}\r\nerr = pucan_set_reset_mode(priv);\r\nif (err)\r\ngoto err_close;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_FD) {\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO)\r\nerr = pucan_clr_options(priv, PUCAN_OPTION_CANDFDISO);\r\nelse\r\nerr = pucan_set_options(priv, PUCAN_OPTION_CANDFDISO);\r\nif (err)\r\ngoto err_close;\r\n}\r\nerr = pucan_set_options(priv, PUCAN_OPTION_ERROR);\r\nif (err)\r\ngoto err_close;\r\nfor (i = 0; i <= PUCAN_FLTSTD_ROW_IDX_MAX; i++)\r\npucan_set_std_filter(priv, i, 0xffffffff);\r\nerr = peak_canfd_start(priv);\r\nif (err)\r\ngoto err_close;\r\nerr = pucan_setup_rx_barrier(priv);\r\nif (!err)\r\ngoto err_exit;\r\nerr_close:\r\nclose_candev(ndev);\r\nerr_exit:\r\nreturn err;\r\n}\r\nstatic int peak_canfd_set_bittiming(struct net_device *ndev)\r\n{\r\nstruct peak_canfd_priv *priv = netdev_priv(ndev);\r\nreturn pucan_set_timing_slow(priv, &priv->can.bittiming);\r\n}\r\nstatic int peak_canfd_set_data_bittiming(struct net_device *ndev)\r\n{\r\nstruct peak_canfd_priv *priv = netdev_priv(ndev);\r\nreturn pucan_set_timing_fast(priv, &priv->can.data_bittiming);\r\n}\r\nstatic int peak_canfd_close(struct net_device *ndev)\r\n{\r\nstruct peak_canfd_priv *priv = netdev_priv(ndev);\r\nnetif_stop_queue(ndev);\r\npeak_canfd_stop(priv);\r\nclose_candev(ndev);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t peak_canfd_start_xmit(struct sk_buff *skb,\r\nstruct net_device *ndev)\r\n{\r\nstruct peak_canfd_priv *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &ndev->stats;\r\nstruct canfd_frame *cf = (struct canfd_frame *)skb->data;\r\nstruct pucan_tx_msg *msg;\r\nu16 msg_size, msg_flags;\r\nunsigned long flags;\r\nbool should_stop_tx_queue;\r\nint room_left;\r\nu8 can_dlc;\r\nif (can_dropped_invalid_skb(ndev, skb))\r\nreturn NETDEV_TX_OK;\r\nmsg_size = ALIGN(sizeof(*msg) + cf->len, 4);\r\nmsg = priv->alloc_tx_msg(priv, msg_size, &room_left);\r\nif (!msg) {\r\nstats->tx_dropped++;\r\nnetif_stop_queue(ndev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nmsg->size = cpu_to_le16(msg_size);\r\nmsg->type = cpu_to_le16(PUCAN_MSG_CAN_TX);\r\nmsg_flags = 0;\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\nmsg_flags |= PUCAN_MSG_EXT_ID;\r\nmsg->can_id = cpu_to_le32(cf->can_id & CAN_EFF_MASK);\r\n} else {\r\nmsg->can_id = cpu_to_le32(cf->can_id & CAN_SFF_MASK);\r\n}\r\nif (can_is_canfd_skb(skb)) {\r\ncan_dlc = can_len2dlc(cf->len);\r\nmsg_flags |= PUCAN_MSG_EXT_DATA_LEN;\r\nif (cf->flags & CANFD_BRS)\r\nmsg_flags |= PUCAN_MSG_BITRATE_SWITCH;\r\nif (cf->flags & CANFD_ESI)\r\nmsg_flags |= PUCAN_MSG_ERROR_STATE_IND;\r\n} else {\r\ncan_dlc = cf->len;\r\nif (cf->can_id & CAN_RTR_FLAG)\r\nmsg_flags |= PUCAN_MSG_RTR;\r\n}\r\nmsg_flags |= PUCAN_MSG_LOOPED_BACK;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\r\nmsg_flags |= PUCAN_MSG_SELF_RECEIVE;\r\nmsg->flags = cpu_to_le16(msg_flags);\r\nmsg->channel_dlc = PUCAN_MSG_CHANNEL_DLC(priv->index, can_dlc);\r\nmemcpy(msg->d, cf->data, cf->len);\r\nmsg->client = priv->echo_idx;\r\nspin_lock_irqsave(&priv->echo_lock, flags);\r\ncan_put_echo_skb(skb, ndev, priv->echo_idx);\r\npriv->echo_idx = (priv->echo_idx + 1) % priv->can.echo_skb_max;\r\nshould_stop_tx_queue = !!(priv->can.echo_skb[priv->echo_idx]);\r\nspin_unlock_irqrestore(&priv->echo_lock, flags);\r\npriv->write_tx_msg(priv, msg);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_FD)\r\nshould_stop_tx_queue |= (room_left <\r\n(sizeof(*msg) + CANFD_MAX_DLEN));\r\nelse\r\nshould_stop_tx_queue |= (room_left <\r\n(sizeof(*msg) + CAN_MAX_DLEN));\r\nif (should_stop_tx_queue)\r\nnetif_stop_queue(ndev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstruct net_device *alloc_peak_canfd_dev(int sizeof_priv, int index,\r\nint echo_skb_max)\r\n{\r\nstruct net_device *ndev;\r\nstruct peak_canfd_priv *priv;\r\nif (echo_skb_max < 0)\r\necho_skb_max = PCANFD_ECHO_SKB_MAX;\r\nndev = alloc_candev(sizeof_priv, echo_skb_max);\r\nif (!ndev)\r\nreturn NULL;\r\npriv = netdev_priv(ndev);\r\npriv->can.state = CAN_STATE_STOPPED;\r\npriv->can.bittiming_const = &peak_canfd_nominal_const;\r\npriv->can.data_bittiming_const = &peak_canfd_data_const;\r\npriv->can.do_set_mode = peak_canfd_set_mode;\r\npriv->can.do_get_berr_counter = peak_canfd_get_berr_counter;\r\npriv->can.do_set_bittiming = peak_canfd_set_bittiming;\r\npriv->can.do_set_data_bittiming = peak_canfd_set_data_bittiming;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\r\nCAN_CTRLMODE_LISTENONLY |\r\nCAN_CTRLMODE_3_SAMPLES |\r\nCAN_CTRLMODE_FD |\r\nCAN_CTRLMODE_FD_NON_ISO |\r\nCAN_CTRLMODE_BERR_REPORTING;\r\npriv->ndev = ndev;\r\npriv->index = index;\r\npriv->cmd_len = 0;\r\nspin_lock_init(&priv->echo_lock);\r\nndev->flags |= IFF_ECHO;\r\nndev->netdev_ops = &peak_canfd_netdev_ops;\r\nndev->dev_id = index;\r\nreturn ndev;\r\n}
