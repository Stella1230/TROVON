static int suspend_8960(struct tsens_device *tmdev)\r\n{\r\nint ret;\r\nunsigned int mask;\r\nstruct regmap *map = tmdev->map;\r\nret = regmap_read(map, THRESHOLD_ADDR, &tmdev->ctx.threshold);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_read(map, CNTL_ADDR, &tmdev->ctx.control);\r\nif (ret)\r\nreturn ret;\r\nif (tmdev->num_sensors > 1)\r\nmask = SLP_CLK_ENA | EN;\r\nelse\r\nmask = SLP_CLK_ENA_8660 | EN;\r\nret = regmap_update_bits(map, CNTL_ADDR, mask, 0);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int resume_8960(struct tsens_device *tmdev)\r\n{\r\nint ret;\r\nstruct regmap *map = tmdev->map;\r\nret = regmap_update_bits(map, CNTL_ADDR, SW_RST, SW_RST);\r\nif (ret)\r\nreturn ret;\r\nif (tmdev->num_sensors > 1) {\r\nret = regmap_update_bits(map, CONFIG_ADDR, CONFIG_MASK, CONFIG);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = regmap_write(map, THRESHOLD_ADDR, tmdev->ctx.threshold);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(map, CNTL_ADDR, tmdev->ctx.control);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int enable_8960(struct tsens_device *tmdev, int id)\r\n{\r\nint ret;\r\nu32 reg, mask;\r\nret = regmap_read(tmdev->map, CNTL_ADDR, &reg);\r\nif (ret)\r\nreturn ret;\r\nmask = BIT(id + SENSOR0_SHIFT);\r\nret = regmap_write(tmdev->map, CNTL_ADDR, reg | SW_RST);\r\nif (ret)\r\nreturn ret;\r\nif (tmdev->num_sensors > 1)\r\nreg |= mask | SLP_CLK_ENA | EN;\r\nelse\r\nreg |= mask | SLP_CLK_ENA_8660 | EN;\r\nret = regmap_write(tmdev->map, CNTL_ADDR, reg);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void disable_8960(struct tsens_device *tmdev)\r\n{\r\nint ret;\r\nu32 reg_cntl;\r\nu32 mask;\r\nmask = GENMASK(tmdev->num_sensors - 1, 0);\r\nmask <<= SENSOR0_SHIFT;\r\nmask |= EN;\r\nret = regmap_read(tmdev->map, CNTL_ADDR, &reg_cntl);\r\nif (ret)\r\nreturn;\r\nreg_cntl &= ~mask;\r\nif (tmdev->num_sensors > 1)\r\nreg_cntl &= ~SLP_CLK_ENA;\r\nelse\r\nreg_cntl &= ~SLP_CLK_ENA_8660;\r\nregmap_write(tmdev->map, CNTL_ADDR, reg_cntl);\r\n}\r\nstatic int init_8960(struct tsens_device *tmdev)\r\n{\r\nint ret, i;\r\nu32 reg_cntl;\r\ntmdev->map = dev_get_regmap(tmdev->dev, NULL);\r\nif (!tmdev->map)\r\nreturn -ENODEV;\r\nfor (i = 0; i < tmdev->num_sensors; i++) {\r\nif (i >= 5)\r\ntmdev->sensor[i].status = S0_STATUS_ADDR + 40;\r\ntmdev->sensor[i].status += i * 4;\r\n}\r\nreg_cntl = SW_RST;\r\nret = regmap_update_bits(tmdev->map, CNTL_ADDR, SW_RST, reg_cntl);\r\nif (ret)\r\nreturn ret;\r\nif (tmdev->num_sensors > 1) {\r\nreg_cntl |= SLP_CLK_ENA | (MEASURE_PERIOD << 18);\r\nreg_cntl &= ~SW_RST;\r\nret = regmap_update_bits(tmdev->map, CONFIG_ADDR,\r\nCONFIG_MASK, CONFIG);\r\n} else {\r\nreg_cntl |= SLP_CLK_ENA_8660 | (MEASURE_PERIOD << 16);\r\nreg_cntl &= ~CONFIG_MASK_8660;\r\nreg_cntl |= CONFIG_8660 << CONFIG_SHIFT_8660;\r\n}\r\nreg_cntl |= GENMASK(tmdev->num_sensors - 1, 0) << SENSOR0_SHIFT;\r\nret = regmap_write(tmdev->map, CNTL_ADDR, reg_cntl);\r\nif (ret)\r\nreturn ret;\r\nreg_cntl |= EN;\r\nret = regmap_write(tmdev->map, CNTL_ADDR, reg_cntl);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int calibrate_8960(struct tsens_device *tmdev)\r\n{\r\nint i;\r\nchar *data;\r\nssize_t num_read = tmdev->num_sensors;\r\nstruct tsens_sensor *s = tmdev->sensor;\r\ndata = qfprom_read(tmdev->dev, "calib");\r\nif (IS_ERR(data))\r\ndata = qfprom_read(tmdev->dev, "calib_backup");\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nfor (i = 0; i < num_read; i++, s++)\r\ns->offset = data[i];\r\nreturn 0;\r\n}\r\nstatic inline int code_to_mdegC(u32 adc_code, const struct tsens_sensor *s)\r\n{\r\nint slope, offset;\r\nslope = thermal_zone_get_slope(s->tzd);\r\noffset = CAL_MDEGC - slope * s->offset;\r\nreturn adc_code * slope + offset;\r\n}\r\nstatic int get_temp_8960(struct tsens_device *tmdev, int id, int *temp)\r\n{\r\nint ret;\r\nu32 code, trdy;\r\nconst struct tsens_sensor *s = &tmdev->sensor[id];\r\nunsigned long timeout;\r\ntimeout = jiffies + usecs_to_jiffies(TIMEOUT_US);\r\ndo {\r\nret = regmap_read(tmdev->map, INT_STATUS_ADDR, &trdy);\r\nif (ret)\r\nreturn ret;\r\nif (!(trdy & TRDY_MASK))\r\ncontinue;\r\nret = regmap_read(tmdev->map, s->status, &code);\r\nif (ret)\r\nreturn ret;\r\n*temp = code_to_mdegC(code, s);\r\nreturn 0;\r\n} while (time_before(jiffies, timeout));\r\nreturn -ETIMEDOUT;\r\n}
