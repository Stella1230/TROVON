static int arcxcnn_update_field(struct arcxcnn *lp, u8 reg, u8 mask, u8 data)\r\n{\r\nint ret;\r\nu8 tmp;\r\nret = i2c_smbus_read_byte_data(lp->client, reg);\r\nif (ret < 0) {\r\ndev_err(lp->dev, "failed to read 0x%.2x\n", reg);\r\nreturn ret;\r\n}\r\ntmp = (u8)ret;\r\ntmp &= ~mask;\r\ntmp |= data & mask;\r\nreturn i2c_smbus_write_byte_data(lp->client, reg, tmp);\r\n}\r\nstatic int arcxcnn_set_brightness(struct arcxcnn *lp, u32 brightness)\r\n{\r\nint ret;\r\nu8 val;\r\nval = (brightness & 0xF) << ARCXCNN_WLED_ISET_LSB_SHIFT;\r\nret = i2c_smbus_write_byte_data(lp->client,\r\nARCXCNN_WLED_ISET_LSB, val);\r\nif (ret < 0)\r\nreturn ret;\r\nval = (brightness >> 4);\r\nreturn i2c_smbus_write_byte_data(lp->client,\r\nARCXCNN_WLED_ISET_MSB, val);\r\n}\r\nstatic int arcxcnn_bl_update_status(struct backlight_device *bl)\r\n{\r\nstruct arcxcnn *lp = bl_get_data(bl);\r\nu32 brightness = bl->props.brightness;\r\nint ret;\r\nif (bl->props.state & (BL_CORE_SUSPENDED | BL_CORE_FBBLANK))\r\nbrightness = 0;\r\nret = arcxcnn_set_brightness(lp, brightness);\r\nif (ret)\r\nreturn ret;\r\nreturn arcxcnn_update_field(lp, ARCXCNN_CMD, ARCXCNN_CMD_STDBY,\r\n(bl->props.power == 0) ? 0 : ARCXCNN_CMD_STDBY);\r\n}\r\nstatic int arcxcnn_backlight_register(struct arcxcnn *lp)\r\n{\r\nstruct backlight_properties *props;\r\nconst char *name = lp->pdata->name ? : "arctic_bl";\r\nprops = devm_kzalloc(lp->dev, sizeof(*props), GFP_KERNEL);\r\nif (!props)\r\nreturn -ENOMEM;\r\nprops->type = BACKLIGHT_PLATFORM;\r\nprops->max_brightness = MAX_BRIGHTNESS;\r\nif (lp->pdata->initial_brightness > props->max_brightness)\r\nlp->pdata->initial_brightness = props->max_brightness;\r\nprops->brightness = lp->pdata->initial_brightness;\r\nlp->bl = devm_backlight_device_register(lp->dev, name, lp->dev, lp,\r\n&arcxcnn_bl_ops, props);\r\nreturn PTR_ERR_OR_ZERO(lp->bl);\r\n}\r\nstatic void arcxcnn_parse_dt(struct arcxcnn *lp)\r\n{\r\nstruct device *dev = lp->dev;\r\nstruct device_node *node = dev->of_node;\r\nu32 prog_val, num_entry, entry, sources[ARCXCNN_LEDEN_BITS];\r\nint ret;\r\nif (!node)\r\nreturn;\r\nret = of_property_read_string(node, "label", &lp->pdata->name);\r\nif (ret < 0)\r\nlp->pdata->name = NULL;\r\nret = of_property_read_u32(node, "default-brightness", &prog_val);\r\nif (ret == 0)\r\nlp->pdata->initial_brightness = prog_val;\r\nret = of_property_read_u32(node, "arc,led-config-0", &prog_val);\r\nif (ret == 0)\r\nlp->pdata->led_config_0 = (u8)prog_val;\r\nret = of_property_read_u32(node, "arc,led-config-1", &prog_val);\r\nif (ret == 0)\r\nlp->pdata->led_config_1 = (u8)prog_val;\r\nret = of_property_read_u32(node, "arc,dim-freq", &prog_val);\r\nif (ret == 0)\r\nlp->pdata->dim_freq = (u8)prog_val;\r\nret = of_property_read_u32(node, "arc,comp-config", &prog_val);\r\nif (ret == 0)\r\nlp->pdata->comp_config = (u8)prog_val;\r\nret = of_property_read_u32(node, "arc,filter-config", &prog_val);\r\nif (ret == 0)\r\nlp->pdata->filter_config = (u8)prog_val;\r\nret = of_property_read_u32(node, "arc,trim-config", &prog_val);\r\nif (ret == 0)\r\nlp->pdata->trim_config = (u8)prog_val;\r\nret = of_property_count_u32_elems(node, "led-sources");\r\nif (ret < 0) {\r\nlp->pdata->leden = ARCXCNN_LEDEN_MASK;\r\n} else {\r\nnum_entry = ret;\r\nif (num_entry > ARCXCNN_LEDEN_BITS)\r\nnum_entry = ARCXCNN_LEDEN_BITS;\r\nret = of_property_read_u32_array(node, "led-sources", sources,\r\nnum_entry);\r\nif (ret < 0) {\r\ndev_err(dev, "led-sources node is invalid.\n");\r\nreturn;\r\n}\r\nlp->pdata->leden = 0;\r\nfor (entry = 0; entry < num_entry; entry++) {\r\nu8 onbit = 1 << sources[entry];\r\nlp->pdata->leden |= onbit;\r\n}\r\n}\r\n}\r\nstatic int arcxcnn_probe(struct i2c_client *cl, const struct i2c_device_id *id)\r\n{\r\nstruct arcxcnn *lp;\r\nint ret;\r\nif (!i2c_check_functionality(cl->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nlp = devm_kzalloc(&cl->dev, sizeof(*lp), GFP_KERNEL);\r\nif (!lp)\r\nreturn -ENOMEM;\r\nlp->client = cl;\r\nlp->dev = &cl->dev;\r\nlp->pdata = dev_get_platdata(&cl->dev);\r\nret = i2c_smbus_write_byte_data(lp->client,\r\nARCXCNN_CMD, ARCXCNN_CMD_RESET);\r\nif (ret)\r\ngoto probe_err;\r\nif (!lp->pdata) {\r\nlp->pdata = devm_kzalloc(lp->dev,\r\nsizeof(*lp->pdata), GFP_KERNEL);\r\nif (!lp->pdata)\r\nreturn -ENOMEM;\r\nlp->pdata->name = NULL;\r\nlp->pdata->initial_brightness = INIT_BRIGHT;\r\nlp->pdata->leden = ARCXCNN_LEDEN_MASK;\r\nlp->pdata->led_config_0 = i2c_smbus_read_byte_data(\r\nlp->client, ARCXCNN_FADECTRL);\r\nlp->pdata->led_config_1 = i2c_smbus_read_byte_data(\r\nlp->client, ARCXCNN_ILED_CONFIG);\r\nlp->pdata->led_config_1 |= ARCXCNN_ILED_DIM_INT;\r\nlp->pdata->dim_freq = i2c_smbus_read_byte_data(\r\nlp->client, ARCXCNN_DIMFREQ);\r\nlp->pdata->comp_config = i2c_smbus_read_byte_data(\r\nlp->client, ARCXCNN_COMP_CONFIG);\r\nlp->pdata->filter_config = i2c_smbus_read_byte_data(\r\nlp->client, ARCXCNN_FILT_CONFIG);\r\nlp->pdata->trim_config = i2c_smbus_read_byte_data(\r\nlp->client, ARCXCNN_IMAXTUNE);\r\nif (IS_ENABLED(CONFIG_OF))\r\narcxcnn_parse_dt(lp);\r\n}\r\ni2c_set_clientdata(cl, lp);\r\nif (lp->pdata->initial_brightness > MAX_BRIGHTNESS)\r\nlp->pdata->initial_brightness = MAX_BRIGHTNESS;\r\nret = arcxcnn_set_brightness(lp, lp->pdata->initial_brightness);\r\nif (ret)\r\ngoto probe_err;\r\nret = i2c_smbus_write_byte_data(lp->client, ARCXCNN_FADECTRL,\r\nlp->pdata->led_config_0);\r\nif (ret)\r\ngoto probe_err;\r\nret = i2c_smbus_write_byte_data(lp->client, ARCXCNN_ILED_CONFIG,\r\nlp->pdata->led_config_1);\r\nif (ret)\r\ngoto probe_err;\r\nret = i2c_smbus_write_byte_data(lp->client, ARCXCNN_DIMFREQ,\r\nlp->pdata->dim_freq);\r\nif (ret)\r\ngoto probe_err;\r\nret = i2c_smbus_write_byte_data(lp->client, ARCXCNN_COMP_CONFIG,\r\nlp->pdata->comp_config);\r\nif (ret)\r\ngoto probe_err;\r\nret = i2c_smbus_write_byte_data(lp->client, ARCXCNN_FILT_CONFIG,\r\nlp->pdata->filter_config);\r\nif (ret)\r\ngoto probe_err;\r\nret = i2c_smbus_write_byte_data(lp->client, ARCXCNN_IMAXTUNE,\r\nlp->pdata->trim_config);\r\nif (ret)\r\ngoto probe_err;\r\narcxcnn_update_field(lp, ARCXCNN_LEDEN,\r\nARCXCNN_LEDEN_MASK, lp->pdata->leden);\r\nret = arcxcnn_backlight_register(lp);\r\nif (ret)\r\ngoto probe_register_err;\r\nbacklight_update_status(lp->bl);\r\nreturn 0;\r\nprobe_register_err:\r\ndev_err(lp->dev,\r\n"failed to register backlight.\n");\r\nprobe_err:\r\ndev_err(lp->dev,\r\n"failure ret: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int arcxcnn_remove(struct i2c_client *cl)\r\n{\r\nstruct arcxcnn *lp = i2c_get_clientdata(cl);\r\ni2c_smbus_write_byte_data(lp->client,\r\nARCXCNN_LEDEN, 0x00);\r\ni2c_smbus_write_byte_data(lp->client,\r\nARCXCNN_CMD, ARCXCNN_CMD_RESET);\r\nlp->bl->props.brightness = 0;\r\nbacklight_update_status(lp->bl);\r\nreturn 0;\r\n}
