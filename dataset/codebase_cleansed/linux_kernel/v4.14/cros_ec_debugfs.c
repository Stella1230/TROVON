static void cros_ec_console_log_work(struct work_struct *__work)\r\n{\r\nstruct cros_ec_debugfs *debug_info =\r\ncontainer_of(to_delayed_work(__work),\r\nstruct cros_ec_debugfs,\r\nlog_poll_work);\r\nstruct cros_ec_dev *ec = debug_info->ec;\r\nstruct circ_buf *cb = &debug_info->log_buffer;\r\nstruct cros_ec_command snapshot_msg = {\r\n.command = EC_CMD_CONSOLE_SNAPSHOT + ec->cmd_offset,\r\n};\r\nstruct ec_params_console_read_v1 *read_params =\r\n(struct ec_params_console_read_v1 *)debug_info->read_msg->data;\r\nuint8_t *ec_buffer = (uint8_t *)debug_info->read_msg->data;\r\nint idx;\r\nint buf_space;\r\nint ret;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, &snapshot_msg);\r\nif (ret < 0) {\r\ndev_err(ec->dev, "EC communication failed\n");\r\ngoto resched;\r\n}\r\nif (snapshot_msg.result != EC_RES_SUCCESS) {\r\ndev_err(ec->dev, "EC failed to snapshot the console log\n");\r\ngoto resched;\r\n}\r\nmutex_lock(&debug_info->log_mutex);\r\nbuf_space = CIRC_SPACE(cb->head, cb->tail, LOG_SIZE);\r\nwhile (1) {\r\nif (!buf_space) {\r\ndev_info_once(ec->dev,\r\n"Some logs may have been dropped...\n");\r\nbreak;\r\n}\r\nmemset(read_params, '\0', sizeof(*read_params));\r\nread_params->subcmd = CONSOLE_READ_RECENT;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, debug_info->read_msg);\r\nif (ret < 0) {\r\ndev_err(ec->dev, "EC communication failed\n");\r\nbreak;\r\n}\r\nif (debug_info->read_msg->result != EC_RES_SUCCESS) {\r\ndev_err(ec->dev,\r\n"EC failed to read the console log\n");\r\nbreak;\r\n}\r\nif (ret == 0 || ec_buffer[0] == '\0')\r\nbreak;\r\nidx = 0;\r\nwhile (idx < ret && ec_buffer[idx] != '\0' && buf_space > 0) {\r\ncb->buf[cb->head] = ec_buffer[idx];\r\ncb->head = CIRC_ADD(cb->head, LOG_SIZE, 1);\r\nidx++;\r\nbuf_space--;\r\n}\r\nwake_up(&debug_info->log_wq);\r\n}\r\nmutex_unlock(&debug_info->log_mutex);\r\nresched:\r\nschedule_delayed_work(&debug_info->log_poll_work,\r\nmsecs_to_jiffies(LOG_POLL_SEC * 1000));\r\n}\r\nstatic int cros_ec_console_log_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = inode->i_private;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic ssize_t cros_ec_console_log_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct cros_ec_debugfs *debug_info = file->private_data;\r\nstruct circ_buf *cb = &debug_info->log_buffer;\r\nssize_t ret;\r\nmutex_lock(&debug_info->log_mutex);\r\nwhile (!CIRC_CNT(cb->head, cb->tail, LOG_SIZE)) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\ngoto error;\r\n}\r\nmutex_unlock(&debug_info->log_mutex);\r\nret = wait_event_interruptible(debug_info->log_wq,\r\nCIRC_CNT(cb->head, cb->tail, LOG_SIZE));\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&debug_info->log_mutex);\r\n}\r\nret = min_t(size_t, CIRC_CNT_TO_END(cb->head, cb->tail, LOG_SIZE),\r\ncount);\r\nif (copy_to_user(buf, cb->buf + cb->tail, ret)) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\ncb->tail = CIRC_ADD(cb->tail, LOG_SIZE, ret);\r\nerror:\r\nmutex_unlock(&debug_info->log_mutex);\r\nreturn ret;\r\n}\r\nstatic unsigned int cros_ec_console_log_poll(struct file *file,\r\npoll_table *wait)\r\n{\r\nstruct cros_ec_debugfs *debug_info = file->private_data;\r\nunsigned int mask = 0;\r\npoll_wait(file, &debug_info->log_wq, wait);\r\nmutex_lock(&debug_info->log_mutex);\r\nif (CIRC_CNT(debug_info->log_buffer.head,\r\ndebug_info->log_buffer.tail,\r\nLOG_SIZE))\r\nmask |= POLLIN | POLLRDNORM;\r\nmutex_unlock(&debug_info->log_mutex);\r\nreturn mask;\r\n}\r\nstatic int cros_ec_console_log_release(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ec_read_version_supported(struct cros_ec_dev *ec)\r\n{\r\nstruct ec_params_get_cmd_versions_v1 *params;\r\nstruct ec_response_get_cmd_versions *response;\r\nint ret;\r\nstruct cros_ec_command *msg;\r\nmsg = kzalloc(sizeof(*msg) + max(sizeof(*params), sizeof(*response)),\r\nGFP_KERNEL);\r\nif (!msg)\r\nreturn 0;\r\nmsg->command = EC_CMD_GET_CMD_VERSIONS + ec->cmd_offset;\r\nmsg->outsize = sizeof(*params);\r\nmsg->insize = sizeof(*response);\r\nparams = (struct ec_params_get_cmd_versions_v1 *)msg->data;\r\nparams->cmd = EC_CMD_CONSOLE_READ;\r\nresponse = (struct ec_response_get_cmd_versions *)msg->data;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg) >= 0 &&\r\nmsg->result == EC_RES_SUCCESS &&\r\n(response->version_mask & EC_VER_MASK(1));\r\nkfree(msg);\r\nreturn ret;\r\n}\r\nstatic int cros_ec_create_console_log(struct cros_ec_debugfs *debug_info)\r\n{\r\nstruct cros_ec_dev *ec = debug_info->ec;\r\nchar *buf;\r\nint read_params_size;\r\nint read_response_size;\r\nif (!ec_read_version_supported(ec)) {\r\ndev_warn(ec->dev,\r\n"device does not support reading the console log\n");\r\nreturn 0;\r\n}\r\nbuf = devm_kzalloc(ec->dev, LOG_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nread_params_size = sizeof(struct ec_params_console_read_v1);\r\nread_response_size = ec->ec_dev->max_response;\r\ndebug_info->read_msg = devm_kzalloc(ec->dev,\r\nsizeof(*debug_info->read_msg) +\r\nmax(read_params_size, read_response_size), GFP_KERNEL);\r\nif (!debug_info->read_msg)\r\nreturn -ENOMEM;\r\ndebug_info->read_msg->version = 1;\r\ndebug_info->read_msg->command = EC_CMD_CONSOLE_READ + ec->cmd_offset;\r\ndebug_info->read_msg->outsize = read_params_size;\r\ndebug_info->read_msg->insize = read_response_size;\r\ndebug_info->log_buffer.buf = buf;\r\ndebug_info->log_buffer.head = 0;\r\ndebug_info->log_buffer.tail = 0;\r\nmutex_init(&debug_info->log_mutex);\r\ninit_waitqueue_head(&debug_info->log_wq);\r\nif (!debugfs_create_file("console_log",\r\nS_IFREG | S_IRUGO,\r\ndebug_info->dir,\r\ndebug_info,\r\n&cros_ec_console_log_fops))\r\nreturn -ENOMEM;\r\nINIT_DELAYED_WORK(&debug_info->log_poll_work,\r\ncros_ec_console_log_work);\r\nschedule_delayed_work(&debug_info->log_poll_work, 0);\r\nreturn 0;\r\n}\r\nstatic void cros_ec_cleanup_console_log(struct cros_ec_debugfs *debug_info)\r\n{\r\nif (debug_info->log_buffer.buf) {\r\ncancel_delayed_work_sync(&debug_info->log_poll_work);\r\nmutex_destroy(&debug_info->log_mutex);\r\n}\r\n}\r\nstatic int cros_ec_create_panicinfo(struct cros_ec_debugfs *debug_info)\r\n{\r\nstruct cros_ec_device *ec_dev = debug_info->ec->ec_dev;\r\nint ret;\r\nstruct cros_ec_command *msg;\r\nint insize;\r\ninsize = ec_dev->max_response;\r\nmsg = devm_kzalloc(debug_info->ec->dev,\r\nsizeof(*msg) + insize, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->command = EC_CMD_GET_PANIC_INFO;\r\nmsg->insize = insize;\r\nret = cros_ec_cmd_xfer(ec_dev, msg);\r\nif (ret < 0) {\r\ndev_warn(debug_info->ec->dev, "Cannot read panicinfo.\n");\r\nret = 0;\r\ngoto free;\r\n}\r\nif (ret == 0)\r\ngoto free;\r\ndebug_info->panicinfo_blob.data = msg->data;\r\ndebug_info->panicinfo_blob.size = ret;\r\nif (!debugfs_create_blob("panicinfo",\r\nS_IFREG | S_IRUGO,\r\ndebug_info->dir,\r\n&debug_info->panicinfo_blob)) {\r\nret = -ENOMEM;\r\ngoto free;\r\n}\r\nreturn 0;\r\nfree:\r\ndevm_kfree(debug_info->ec->dev, msg);\r\nreturn ret;\r\n}\r\nint cros_ec_debugfs_init(struct cros_ec_dev *ec)\r\n{\r\nstruct cros_ec_platform *ec_platform = dev_get_platdata(ec->dev);\r\nconst char *name = ec_platform->ec_name;\r\nstruct cros_ec_debugfs *debug_info;\r\nint ret;\r\ndebug_info = devm_kzalloc(ec->dev, sizeof(*debug_info), GFP_KERNEL);\r\nif (!debug_info)\r\nreturn -ENOMEM;\r\ndebug_info->ec = ec;\r\ndebug_info->dir = debugfs_create_dir(name, NULL);\r\nif (!debug_info->dir)\r\nreturn -ENOMEM;\r\nret = cros_ec_create_panicinfo(debug_info);\r\nif (ret)\r\ngoto remove_debugfs;\r\nret = cros_ec_create_console_log(debug_info);\r\nif (ret)\r\ngoto remove_debugfs;\r\nec->debug_info = debug_info;\r\nreturn 0;\r\nremove_debugfs:\r\ndebugfs_remove_recursive(debug_info->dir);\r\nreturn ret;\r\n}\r\nvoid cros_ec_debugfs_remove(struct cros_ec_dev *ec)\r\n{\r\nif (!ec->debug_info)\r\nreturn;\r\ndebugfs_remove_recursive(ec->debug_info->dir);\r\ncros_ec_cleanup_console_log(ec->debug_info);\r\n}
