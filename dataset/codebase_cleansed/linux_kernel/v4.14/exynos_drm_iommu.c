static inline int configure_dma_max_seg_size(struct device *dev)\r\n{\r\nif (!dev->dma_parms)\r\ndev->dma_parms = kzalloc(sizeof(*dev->dma_parms), GFP_KERNEL);\r\nif (!dev->dma_parms)\r\nreturn -ENOMEM;\r\ndma_set_max_seg_size(dev, DMA_BIT_MASK(32));\r\nreturn 0;\r\n}\r\nstatic inline void clear_dma_max_seg_size(struct device *dev)\r\n{\r\nkfree(dev->dma_parms);\r\ndev->dma_parms = NULL;\r\n}\r\nint drm_create_iommu_mapping(struct drm_device *drm_dev)\r\n{\r\nstruct exynos_drm_private *priv = drm_dev->dev_private;\r\nreturn __exynos_iommu_create_mapping(priv, EXYNOS_DEV_ADDR_START,\r\nEXYNOS_DEV_ADDR_SIZE);\r\n}\r\nvoid drm_release_iommu_mapping(struct drm_device *drm_dev)\r\n{\r\nstruct exynos_drm_private *priv = drm_dev->dev_private;\r\n__exynos_iommu_release_mapping(priv);\r\n}\r\nint drm_iommu_attach_device(struct drm_device *drm_dev,\r\nstruct device *subdrv_dev)\r\n{\r\nstruct exynos_drm_private *priv = drm_dev->dev_private;\r\nint ret;\r\nif (get_dma_ops(priv->dma_dev) != get_dma_ops(subdrv_dev)) {\r\nDRM_ERROR("Device %s lacks support for IOMMU\n",\r\ndev_name(subdrv_dev));\r\nreturn -EINVAL;\r\n}\r\nret = configure_dma_max_seg_size(subdrv_dev);\r\nif (ret)\r\nreturn ret;\r\nret = __exynos_iommu_attach(priv, subdrv_dev);\r\nif (ret)\r\nclear_dma_max_seg_size(subdrv_dev);\r\nreturn 0;\r\n}\r\nvoid drm_iommu_detach_device(struct drm_device *drm_dev,\r\nstruct device *subdrv_dev)\r\n{\r\nstruct exynos_drm_private *priv = drm_dev->dev_private;\r\n__exynos_iommu_detach(priv, subdrv_dev);\r\nclear_dma_max_seg_size(subdrv_dev);\r\n}
