void ucc_fast_dump_regs(struct ucc_fast_private * uccf)\r\n{\r\nprintk(KERN_INFO "UCC%u Fast registers:\n", uccf->uf_info->ucc_num);\r\nprintk(KERN_INFO "Base address: 0x%p\n", uccf->uf_regs);\r\nprintk(KERN_INFO "gumr : addr=0x%p, val=0x%08x\n",\r\n&uccf->uf_regs->gumr, in_be32(&uccf->uf_regs->gumr));\r\nprintk(KERN_INFO "upsmr : addr=0x%p, val=0x%08x\n",\r\n&uccf->uf_regs->upsmr, in_be32(&uccf->uf_regs->upsmr));\r\nprintk(KERN_INFO "utodr : addr=0x%p, val=0x%04x\n",\r\n&uccf->uf_regs->utodr, in_be16(&uccf->uf_regs->utodr));\r\nprintk(KERN_INFO "udsr : addr=0x%p, val=0x%04x\n",\r\n&uccf->uf_regs->udsr, in_be16(&uccf->uf_regs->udsr));\r\nprintk(KERN_INFO "ucce : addr=0x%p, val=0x%08x\n",\r\n&uccf->uf_regs->ucce, in_be32(&uccf->uf_regs->ucce));\r\nprintk(KERN_INFO "uccm : addr=0x%p, val=0x%08x\n",\r\n&uccf->uf_regs->uccm, in_be32(&uccf->uf_regs->uccm));\r\nprintk(KERN_INFO "uccs : addr=0x%p, val=0x%02x\n",\r\n&uccf->uf_regs->uccs, in_8(&uccf->uf_regs->uccs));\r\nprintk(KERN_INFO "urfb : addr=0x%p, val=0x%08x\n",\r\n&uccf->uf_regs->urfb, in_be32(&uccf->uf_regs->urfb));\r\nprintk(KERN_INFO "urfs : addr=0x%p, val=0x%04x\n",\r\n&uccf->uf_regs->urfs, in_be16(&uccf->uf_regs->urfs));\r\nprintk(KERN_INFO "urfet : addr=0x%p, val=0x%04x\n",\r\n&uccf->uf_regs->urfet, in_be16(&uccf->uf_regs->urfet));\r\nprintk(KERN_INFO "urfset: addr=0x%p, val=0x%04x\n",\r\n&uccf->uf_regs->urfset, in_be16(&uccf->uf_regs->urfset));\r\nprintk(KERN_INFO "utfb : addr=0x%p, val=0x%08x\n",\r\n&uccf->uf_regs->utfb, in_be32(&uccf->uf_regs->utfb));\r\nprintk(KERN_INFO "utfs : addr=0x%p, val=0x%04x\n",\r\n&uccf->uf_regs->utfs, in_be16(&uccf->uf_regs->utfs));\r\nprintk(KERN_INFO "utfet : addr=0x%p, val=0x%04x\n",\r\n&uccf->uf_regs->utfet, in_be16(&uccf->uf_regs->utfet));\r\nprintk(KERN_INFO "utftt : addr=0x%p, val=0x%04x\n",\r\n&uccf->uf_regs->utftt, in_be16(&uccf->uf_regs->utftt));\r\nprintk(KERN_INFO "utpt : addr=0x%p, val=0x%04x\n",\r\n&uccf->uf_regs->utpt, in_be16(&uccf->uf_regs->utpt));\r\nprintk(KERN_INFO "urtry : addr=0x%p, val=0x%08x\n",\r\n&uccf->uf_regs->urtry, in_be32(&uccf->uf_regs->urtry));\r\nprintk(KERN_INFO "guemr : addr=0x%p, val=0x%02x\n",\r\n&uccf->uf_regs->guemr, in_8(&uccf->uf_regs->guemr));\r\n}\r\nu32 ucc_fast_get_qe_cr_subblock(int uccf_num)\r\n{\r\nswitch (uccf_num) {\r\ncase 0: return QE_CR_SUBBLOCK_UCCFAST1;\r\ncase 1: return QE_CR_SUBBLOCK_UCCFAST2;\r\ncase 2: return QE_CR_SUBBLOCK_UCCFAST3;\r\ncase 3: return QE_CR_SUBBLOCK_UCCFAST4;\r\ncase 4: return QE_CR_SUBBLOCK_UCCFAST5;\r\ncase 5: return QE_CR_SUBBLOCK_UCCFAST6;\r\ncase 6: return QE_CR_SUBBLOCK_UCCFAST7;\r\ncase 7: return QE_CR_SUBBLOCK_UCCFAST8;\r\ndefault: return QE_CR_SUBBLOCK_INVALID;\r\n}\r\n}\r\nvoid ucc_fast_transmit_on_demand(struct ucc_fast_private * uccf)\r\n{\r\nout_be16(&uccf->uf_regs->utodr, UCC_FAST_TOD);\r\n}\r\nvoid ucc_fast_enable(struct ucc_fast_private * uccf, enum comm_dir mode)\r\n{\r\nstruct ucc_fast __iomem *uf_regs;\r\nu32 gumr;\r\nuf_regs = uccf->uf_regs;\r\ngumr = in_be32(&uf_regs->gumr);\r\nif (mode & COMM_DIR_TX) {\r\ngumr |= UCC_FAST_GUMR_ENT;\r\nuccf->enabled_tx = 1;\r\n}\r\nif (mode & COMM_DIR_RX) {\r\ngumr |= UCC_FAST_GUMR_ENR;\r\nuccf->enabled_rx = 1;\r\n}\r\nout_be32(&uf_regs->gumr, gumr);\r\n}\r\nvoid ucc_fast_disable(struct ucc_fast_private * uccf, enum comm_dir mode)\r\n{\r\nstruct ucc_fast __iomem *uf_regs;\r\nu32 gumr;\r\nuf_regs = uccf->uf_regs;\r\ngumr = in_be32(&uf_regs->gumr);\r\nif (mode & COMM_DIR_TX) {\r\ngumr &= ~UCC_FAST_GUMR_ENT;\r\nuccf->enabled_tx = 0;\r\n}\r\nif (mode & COMM_DIR_RX) {\r\ngumr &= ~UCC_FAST_GUMR_ENR;\r\nuccf->enabled_rx = 0;\r\n}\r\nout_be32(&uf_regs->gumr, gumr);\r\n}\r\nint ucc_fast_init(struct ucc_fast_info * uf_info, struct ucc_fast_private ** uccf_ret)\r\n{\r\nstruct ucc_fast_private *uccf;\r\nstruct ucc_fast __iomem *uf_regs;\r\nu32 gumr;\r\nint ret;\r\nif (!uf_info)\r\nreturn -EINVAL;\r\nif ((uf_info->ucc_num < 0) || (uf_info->ucc_num > UCC_MAX_NUM - 1)) {\r\nprintk(KERN_ERR "%s: illegal UCC number\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (uf_info->max_rx_buf_length & (UCC_FAST_MRBLR_ALIGNMENT - 1)) {\r\nprintk(KERN_ERR "%s: max_rx_buf_length not aligned\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (uf_info->urfs < UCC_FAST_URFS_MIN_VAL) {\r\nprintk(KERN_ERR "%s: urfs is too small\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (uf_info->urfs & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {\r\nprintk(KERN_ERR "%s: urfs is not aligned\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (uf_info->urfet & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {\r\nprintk(KERN_ERR "%s: urfet is not aligned.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (uf_info->urfset & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {\r\nprintk(KERN_ERR "%s: urfset is not aligned\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (uf_info->utfs & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {\r\nprintk(KERN_ERR "%s: utfs is not aligned\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (uf_info->utfet & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {\r\nprintk(KERN_ERR "%s: utfet is not aligned\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (uf_info->utftt & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {\r\nprintk(KERN_ERR "%s: utftt is not aligned\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nuccf = kzalloc(sizeof(struct ucc_fast_private), GFP_KERNEL);\r\nif (!uccf) {\r\nprintk(KERN_ERR "%s: Cannot allocate private data\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nuccf->uf_info = uf_info;\r\nuccf->uf_regs = ioremap(uf_info->regs, sizeof(struct ucc_fast));\r\nif (uccf->uf_regs == NULL) {\r\nprintk(KERN_ERR "%s: Cannot map UCC registers\n", __func__);\r\nkfree(uccf);\r\nreturn -ENOMEM;\r\n}\r\nuccf->enabled_tx = 0;\r\nuccf->enabled_rx = 0;\r\nuccf->stopped_tx = 0;\r\nuccf->stopped_rx = 0;\r\nuf_regs = uccf->uf_regs;\r\nuccf->p_ucce = &uf_regs->ucce;\r\nuccf->p_uccm = &uf_regs->uccm;\r\n#ifdef CONFIG_UGETH_TX_ON_DEMAND\r\nuccf->p_utodr = &uf_regs->utodr;\r\n#endif\r\n#ifdef STATISTICS\r\nuccf->tx_frames = 0;\r\nuccf->rx_frames = 0;\r\nuccf->rx_discarded = 0;\r\n#endif\r\nret = ucc_set_type(uf_info->ucc_num, UCC_SPEED_TYPE_FAST);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: cannot set UCC type\n", __func__);\r\nucc_fast_free(uccf);\r\nreturn ret;\r\n}\r\nuccf->mrblr = uf_info->max_rx_buf_length;\r\ngumr = uf_info->ttx_trx;\r\nif (uf_info->tci)\r\ngumr |= UCC_FAST_GUMR_TCI;\r\nif (uf_info->cdp)\r\ngumr |= UCC_FAST_GUMR_CDP;\r\nif (uf_info->ctsp)\r\ngumr |= UCC_FAST_GUMR_CTSP;\r\nif (uf_info->cds)\r\ngumr |= UCC_FAST_GUMR_CDS;\r\nif (uf_info->ctss)\r\ngumr |= UCC_FAST_GUMR_CTSS;\r\nif (uf_info->txsy)\r\ngumr |= UCC_FAST_GUMR_TXSY;\r\nif (uf_info->rsyn)\r\ngumr |= UCC_FAST_GUMR_RSYN;\r\ngumr |= uf_info->synl;\r\nif (uf_info->rtsm)\r\ngumr |= UCC_FAST_GUMR_RTSM;\r\ngumr |= uf_info->renc;\r\nif (uf_info->revd)\r\ngumr |= UCC_FAST_GUMR_REVD;\r\ngumr |= uf_info->tenc;\r\ngumr |= uf_info->tcrc;\r\ngumr |= uf_info->mode;\r\nout_be32(&uf_regs->gumr, gumr);\r\nuccf->ucc_fast_tx_virtual_fifo_base_offset =\r\nqe_muram_alloc(uf_info->utfs, UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT);\r\nif (IS_ERR_VALUE(uccf->ucc_fast_tx_virtual_fifo_base_offset)) {\r\nprintk(KERN_ERR "%s: cannot allocate MURAM for TX FIFO\n",\r\n__func__);\r\nuccf->ucc_fast_tx_virtual_fifo_base_offset = 0;\r\nucc_fast_free(uccf);\r\nreturn -ENOMEM;\r\n}\r\nuccf->ucc_fast_rx_virtual_fifo_base_offset =\r\nqe_muram_alloc(uf_info->urfs +\r\nUCC_FAST_RECEIVE_VIRTUAL_FIFO_SIZE_FUDGE_FACTOR,\r\nUCC_FAST_VIRT_FIFO_REGS_ALIGNMENT);\r\nif (IS_ERR_VALUE(uccf->ucc_fast_rx_virtual_fifo_base_offset)) {\r\nprintk(KERN_ERR "%s: cannot allocate MURAM for RX FIFO\n",\r\n__func__);\r\nuccf->ucc_fast_rx_virtual_fifo_base_offset = 0;\r\nucc_fast_free(uccf);\r\nreturn -ENOMEM;\r\n}\r\nout_be16(&uf_regs->urfs, uf_info->urfs);\r\nout_be16(&uf_regs->urfet, uf_info->urfet);\r\nout_be16(&uf_regs->urfset, uf_info->urfset);\r\nout_be16(&uf_regs->utfs, uf_info->utfs);\r\nout_be16(&uf_regs->utfet, uf_info->utfet);\r\nout_be16(&uf_regs->utftt, uf_info->utftt);\r\nout_be32(&uf_regs->utfb, uccf->ucc_fast_tx_virtual_fifo_base_offset);\r\nout_be32(&uf_regs->urfb, uccf->ucc_fast_rx_virtual_fifo_base_offset);\r\nucc_set_qe_mux_grant(uf_info->ucc_num, uf_info->grant_support);\r\nucc_set_qe_mux_bkpt(uf_info->ucc_num, uf_info->brkpt_support);\r\nucc_set_qe_mux_tsa(uf_info->ucc_num, uf_info->tsa);\r\nif (!uf_info->tsa) {\r\nif ((uf_info->rx_clock != QE_CLK_NONE) &&\r\nucc_set_qe_mux_rxtx(uf_info->ucc_num, uf_info->rx_clock,\r\nCOMM_DIR_RX)) {\r\nprintk(KERN_ERR "%s: illegal value for RX clock\n",\r\n__func__);\r\nucc_fast_free(uccf);\r\nreturn -EINVAL;\r\n}\r\nif ((uf_info->tx_clock != QE_CLK_NONE) &&\r\nucc_set_qe_mux_rxtx(uf_info->ucc_num, uf_info->tx_clock,\r\nCOMM_DIR_TX)) {\r\nprintk(KERN_ERR "%s: illegal value for TX clock\n",\r\n__func__);\r\nucc_fast_free(uccf);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif ((uf_info->rx_clock != QE_CLK_NONE) &&\r\nucc_set_tdm_rxtx_clk(uf_info->tdm_num, uf_info->rx_clock,\r\nCOMM_DIR_RX)) {\r\npr_err("%s: illegal value for RX clock", __func__);\r\nucc_fast_free(uccf);\r\nreturn -EINVAL;\r\n}\r\nif ((uf_info->tx_clock != QE_CLK_NONE) &&\r\nucc_set_tdm_rxtx_clk(uf_info->tdm_num, uf_info->tx_clock,\r\nCOMM_DIR_TX)) {\r\npr_err("%s: illegal value for TX clock", __func__);\r\nucc_fast_free(uccf);\r\nreturn -EINVAL;\r\n}\r\nif ((uf_info->rx_sync != QE_CLK_NONE) &&\r\nucc_set_tdm_rxtx_sync(uf_info->tdm_num, uf_info->rx_sync,\r\nCOMM_DIR_RX)) {\r\npr_err("%s: illegal value for RX clock", __func__);\r\nucc_fast_free(uccf);\r\nreturn -EINVAL;\r\n}\r\nif ((uf_info->tx_sync != QE_CLK_NONE) &&\r\nucc_set_tdm_rxtx_sync(uf_info->tdm_num, uf_info->tx_sync,\r\nCOMM_DIR_TX)) {\r\npr_err("%s: illegal value for TX clock", __func__);\r\nucc_fast_free(uccf);\r\nreturn -EINVAL;\r\n}\r\n}\r\nout_be32(&uf_regs->uccm, uf_info->uccm_mask);\r\nout_be32(&uf_regs->ucce, 0xffffffff);\r\n*uccf_ret = uccf;\r\nreturn 0;\r\n}\r\nvoid ucc_fast_free(struct ucc_fast_private * uccf)\r\n{\r\nif (!uccf)\r\nreturn;\r\nif (uccf->ucc_fast_tx_virtual_fifo_base_offset)\r\nqe_muram_free(uccf->ucc_fast_tx_virtual_fifo_base_offset);\r\nif (uccf->ucc_fast_rx_virtual_fifo_base_offset)\r\nqe_muram_free(uccf->ucc_fast_rx_virtual_fifo_base_offset);\r\nif (uccf->uf_regs)\r\niounmap(uccf->uf_regs);\r\nkfree(uccf);\r\n}
