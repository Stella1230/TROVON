const struct isp_format_info *omap3isp_video_format_info(u32 code)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(formats); ++i) {\r\nif (formats[i].code == code)\r\nreturn &formats[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned int isp_video_mbus_to_pix(const struct isp_video *video,\r\nconst struct v4l2_mbus_framefmt *mbus,\r\nstruct v4l2_pix_format *pix)\r\n{\r\nunsigned int bpl = pix->bytesperline;\r\nunsigned int min_bpl;\r\nunsigned int i;\r\nmemset(pix, 0, sizeof(*pix));\r\npix->width = mbus->width;\r\npix->height = mbus->height;\r\nfor (i = 0; i < ARRAY_SIZE(formats); ++i) {\r\nif (formats[i].code == mbus->code)\r\nbreak;\r\n}\r\nif (WARN_ON(i == ARRAY_SIZE(formats)))\r\nreturn 0;\r\nmin_bpl = pix->width * formats[i].bpp;\r\nif (video->bpl_max)\r\nbpl = clamp(bpl, min_bpl, video->bpl_max);\r\nelse\r\nbpl = min_bpl;\r\nif (!video->bpl_zero_padding || bpl != min_bpl)\r\nbpl = ALIGN(bpl, video->bpl_alignment);\r\npix->pixelformat = formats[i].pixelformat;\r\npix->bytesperline = bpl;\r\npix->sizeimage = pix->bytesperline * pix->height;\r\npix->colorspace = mbus->colorspace;\r\npix->field = mbus->field;\r\nreturn bpl - min_bpl;\r\n}\r\nstatic void isp_video_pix_to_mbus(const struct v4l2_pix_format *pix,\r\nstruct v4l2_mbus_framefmt *mbus)\r\n{\r\nunsigned int i;\r\nmemset(mbus, 0, sizeof(*mbus));\r\nmbus->width = pix->width;\r\nmbus->height = pix->height;\r\nfor (i = 0; i < ARRAY_SIZE(formats) - 1; ++i) {\r\nif (formats[i].pixelformat == pix->pixelformat)\r\nbreak;\r\n}\r\nmbus->code = formats[i].code;\r\nmbus->colorspace = pix->colorspace;\r\nmbus->field = pix->field;\r\n}\r\nstatic struct v4l2_subdev *\r\nisp_video_remote_subdev(struct isp_video *video, u32 *pad)\r\n{\r\nstruct media_pad *remote;\r\nremote = media_entity_remote_pad(&video->pad);\r\nif (!remote || !is_media_entity_v4l2_subdev(remote->entity))\r\nreturn NULL;\r\nif (pad)\r\n*pad = remote->index;\r\nreturn media_entity_to_v4l2_subdev(remote->entity);\r\n}\r\nstatic int isp_video_get_graph_data(struct isp_video *video,\r\nstruct isp_pipeline *pipe)\r\n{\r\nstruct media_graph graph;\r\nstruct media_entity *entity = &video->video.entity;\r\nstruct media_device *mdev = entity->graph_obj.mdev;\r\nstruct isp_video *far_end = NULL;\r\nint ret;\r\nmutex_lock(&mdev->graph_mutex);\r\nret = media_graph_walk_init(&graph, mdev);\r\nif (ret) {\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn ret;\r\n}\r\nmedia_graph_walk_start(&graph, entity);\r\nwhile ((entity = media_graph_walk_next(&graph))) {\r\nstruct isp_video *__video;\r\nmedia_entity_enum_set(&pipe->ent_enum, entity);\r\nif (far_end != NULL)\r\ncontinue;\r\nif (entity == &video->video.entity)\r\ncontinue;\r\nif (!is_media_entity_v4l2_video_device(entity))\r\ncontinue;\r\n__video = to_isp_video(media_entity_to_video_device(entity));\r\nif (__video->type != video->type)\r\nfar_end = __video;\r\n}\r\nmutex_unlock(&mdev->graph_mutex);\r\nmedia_graph_walk_cleanup(&graph);\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\npipe->input = far_end;\r\npipe->output = video;\r\n} else {\r\nif (far_end == NULL)\r\nreturn -EPIPE;\r\npipe->input = video;\r\npipe->output = far_end;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\n__isp_video_get_format(struct isp_video *video, struct v4l2_format *format)\r\n{\r\nstruct v4l2_subdev_format fmt;\r\nstruct v4l2_subdev *subdev;\r\nu32 pad;\r\nint ret;\r\nsubdev = isp_video_remote_subdev(video, &pad);\r\nif (subdev == NULL)\r\nreturn -EINVAL;\r\nfmt.pad = pad;\r\nfmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nmutex_lock(&video->mutex);\r\nret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);\r\nmutex_unlock(&video->mutex);\r\nif (ret)\r\nreturn ret;\r\nformat->type = video->type;\r\nreturn isp_video_mbus_to_pix(video, &fmt.format, &format->fmt.pix);\r\n}\r\nstatic int\r\nisp_video_check_format(struct isp_video *video, struct isp_video_fh *vfh)\r\n{\r\nstruct v4l2_format format;\r\nint ret;\r\nmemcpy(&format, &vfh->format, sizeof(format));\r\nret = __isp_video_get_format(video, &format);\r\nif (ret < 0)\r\nreturn ret;\r\nif (vfh->format.fmt.pix.pixelformat != format.fmt.pix.pixelformat ||\r\nvfh->format.fmt.pix.height != format.fmt.pix.height ||\r\nvfh->format.fmt.pix.width != format.fmt.pix.width ||\r\nvfh->format.fmt.pix.bytesperline != format.fmt.pix.bytesperline ||\r\nvfh->format.fmt.pix.sizeimage != format.fmt.pix.sizeimage ||\r\nvfh->format.fmt.pix.field != format.fmt.pix.field)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int isp_video_queue_setup(struct vb2_queue *queue,\r\nunsigned int *count, unsigned int *num_planes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct isp_video_fh *vfh = vb2_get_drv_priv(queue);\r\nstruct isp_video *video = vfh->video;\r\n*num_planes = 1;\r\nsizes[0] = vfh->format.fmt.pix.sizeimage;\r\nif (sizes[0] == 0)\r\nreturn -EINVAL;\r\n*count = min(*count, video->capture_mem / PAGE_ALIGN(sizes[0]));\r\nreturn 0;\r\n}\r\nstatic int isp_video_buffer_prepare(struct vb2_buffer *buf)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(buf);\r\nstruct isp_video_fh *vfh = vb2_get_drv_priv(buf->vb2_queue);\r\nstruct isp_buffer *buffer = to_isp_buffer(vbuf);\r\nstruct isp_video *video = vfh->video;\r\ndma_addr_t addr;\r\nif (unlikely(video->error))\r\nreturn -EIO;\r\naddr = vb2_dma_contig_plane_dma_addr(buf, 0);\r\nif (!IS_ALIGNED(addr, 32)) {\r\ndev_dbg(video->isp->dev,\r\n"Buffer address must be aligned to 32 bytes boundary.\n");\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(&buffer->vb.vb2_buf, 0,\r\nvfh->format.fmt.pix.sizeimage);\r\nbuffer->dma = addr;\r\nreturn 0;\r\n}\r\nstatic void isp_video_buffer_queue(struct vb2_buffer *buf)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(buf);\r\nstruct isp_video_fh *vfh = vb2_get_drv_priv(buf->vb2_queue);\r\nstruct isp_buffer *buffer = to_isp_buffer(vbuf);\r\nstruct isp_video *video = vfh->video;\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&video->video.entity);\r\nenum isp_pipeline_state state;\r\nunsigned long flags;\r\nunsigned int empty;\r\nunsigned int start;\r\nspin_lock_irqsave(&video->irqlock, flags);\r\nif (unlikely(video->error)) {\r\nvb2_buffer_done(&buffer->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\nspin_unlock_irqrestore(&video->irqlock, flags);\r\nreturn;\r\n}\r\nempty = list_empty(&video->dmaqueue);\r\nlist_add_tail(&buffer->irqlist, &video->dmaqueue);\r\nspin_unlock_irqrestore(&video->irqlock, flags);\r\nif (empty) {\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nstate = ISP_PIPELINE_QUEUE_OUTPUT;\r\nelse\r\nstate = ISP_PIPELINE_QUEUE_INPUT;\r\nspin_lock_irqsave(&pipe->lock, flags);\r\npipe->state |= state;\r\nvideo->ops->queue(video, buffer);\r\nvideo->dmaqueue_flags |= ISP_VIDEO_DMAQUEUE_QUEUED;\r\nstart = isp_pipeline_ready(pipe);\r\nif (start)\r\npipe->state |= ISP_PIPELINE_STREAM;\r\nspin_unlock_irqrestore(&pipe->lock, flags);\r\nif (start)\r\nomap3isp_pipeline_set_stream(pipe,\r\nISP_PIPELINE_STREAM_SINGLESHOT);\r\n}\r\n}\r\nstatic void omap3isp_video_return_buffers(struct isp_video *video,\r\nenum vb2_buffer_state state)\r\n{\r\nwhile (!list_empty(&video->dmaqueue)) {\r\nstruct isp_buffer *buf;\r\nbuf = list_first_entry(&video->dmaqueue,\r\nstruct isp_buffer, irqlist);\r\nlist_del(&buf->irqlist);\r\nvb2_buffer_done(&buf->vb.vb2_buf, state);\r\n}\r\n}\r\nstatic int isp_video_start_streaming(struct vb2_queue *queue,\r\nunsigned int count)\r\n{\r\nstruct isp_video_fh *vfh = vb2_get_drv_priv(queue);\r\nstruct isp_video *video = vfh->video;\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&video->video.entity);\r\nunsigned long flags;\r\nint ret;\r\nif (pipe->input)\r\nreturn 0;\r\nret = omap3isp_pipeline_set_stream(pipe,\r\nISP_PIPELINE_STREAM_CONTINUOUS);\r\nif (ret < 0) {\r\nspin_lock_irqsave(&video->irqlock, flags);\r\nomap3isp_video_return_buffers(video, VB2_BUF_STATE_QUEUED);\r\nspin_unlock_irqrestore(&video->irqlock, flags);\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&video->irqlock, flags);\r\nif (list_empty(&video->dmaqueue))\r\nvideo->dmaqueue_flags |= ISP_VIDEO_DMAQUEUE_UNDERRUN;\r\nspin_unlock_irqrestore(&video->irqlock, flags);\r\nreturn 0;\r\n}\r\nstruct isp_buffer *omap3isp_video_buffer_next(struct isp_video *video)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&video->video.entity);\r\nenum vb2_buffer_state vb_state;\r\nstruct isp_buffer *buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&video->irqlock, flags);\r\nif (WARN_ON(list_empty(&video->dmaqueue))) {\r\nspin_unlock_irqrestore(&video->irqlock, flags);\r\nreturn NULL;\r\n}\r\nbuf = list_first_entry(&video->dmaqueue, struct isp_buffer,\r\nirqlist);\r\nlist_del(&buf->irqlist);\r\nspin_unlock_irqrestore(&video->irqlock, flags);\r\nbuf->vb.vb2_buf.timestamp = ktime_get_ns();\r\nif (video == pipe->output && !pipe->do_propagation)\r\nbuf->vb.sequence =\r\natomic_inc_return(&pipe->frame_number);\r\nelse\r\nbuf->vb.sequence = atomic_read(&pipe->frame_number);\r\nif (pipe->field != V4L2_FIELD_NONE)\r\nbuf->vb.sequence /= 2;\r\nbuf->vb.field = pipe->field;\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE && pipe->error) {\r\nvb_state = VB2_BUF_STATE_ERROR;\r\npipe->error = false;\r\n} else {\r\nvb_state = VB2_BUF_STATE_DONE;\r\n}\r\nvb2_buffer_done(&buf->vb.vb2_buf, vb_state);\r\nspin_lock_irqsave(&video->irqlock, flags);\r\nif (list_empty(&video->dmaqueue)) {\r\nenum isp_pipeline_state state;\r\nspin_unlock_irqrestore(&video->irqlock, flags);\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nstate = ISP_PIPELINE_QUEUE_OUTPUT\r\n| ISP_PIPELINE_STREAM;\r\nelse\r\nstate = ISP_PIPELINE_QUEUE_INPUT\r\n| ISP_PIPELINE_STREAM;\r\nspin_lock_irqsave(&pipe->lock, flags);\r\npipe->state &= ~state;\r\nif (video->pipe.stream_state == ISP_PIPELINE_STREAM_CONTINUOUS)\r\nvideo->dmaqueue_flags |= ISP_VIDEO_DMAQUEUE_UNDERRUN;\r\nspin_unlock_irqrestore(&pipe->lock, flags);\r\nreturn NULL;\r\n}\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE && pipe->input != NULL) {\r\nspin_lock(&pipe->lock);\r\npipe->state &= ~ISP_PIPELINE_STREAM;\r\nspin_unlock(&pipe->lock);\r\n}\r\nbuf = list_first_entry(&video->dmaqueue, struct isp_buffer,\r\nirqlist);\r\nspin_unlock_irqrestore(&video->irqlock, flags);\r\nreturn buf;\r\n}\r\nvoid omap3isp_video_cancel_stream(struct isp_video *video)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&video->irqlock, flags);\r\nomap3isp_video_return_buffers(video, VB2_BUF_STATE_ERROR);\r\nvideo->error = true;\r\nspin_unlock_irqrestore(&video->irqlock, flags);\r\n}\r\nvoid omap3isp_video_resume(struct isp_video *video, int continuous)\r\n{\r\nstruct isp_buffer *buf = NULL;\r\nif (continuous && video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nmutex_lock(&video->queue_lock);\r\nvb2_discard_done(video->queue);\r\nmutex_unlock(&video->queue_lock);\r\n}\r\nif (!list_empty(&video->dmaqueue)) {\r\nbuf = list_first_entry(&video->dmaqueue,\r\nstruct isp_buffer, irqlist);\r\nvideo->ops->queue(video, buf);\r\nvideo->dmaqueue_flags |= ISP_VIDEO_DMAQUEUE_QUEUED;\r\n} else {\r\nif (continuous)\r\nvideo->dmaqueue_flags |= ISP_VIDEO_DMAQUEUE_UNDERRUN;\r\n}\r\n}\r\nstatic int\r\nisp_video_querycap(struct file *file, void *fh, struct v4l2_capability *cap)\r\n{\r\nstruct isp_video *video = video_drvdata(file);\r\nstrlcpy(cap->driver, ISP_VIDEO_DRIVER_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, video->video.name, sizeof(cap->card));\r\nstrlcpy(cap->bus_info, "media", sizeof(cap->bus_info));\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT\r\n| V4L2_CAP_STREAMING | V4L2_CAP_DEVICE_CAPS;\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\nelse\r\ncap->device_caps = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int\r\nisp_video_get_format(struct file *file, void *fh, struct v4l2_format *format)\r\n{\r\nstruct isp_video_fh *vfh = to_isp_video_fh(fh);\r\nstruct isp_video *video = video_drvdata(file);\r\nif (format->type != video->type)\r\nreturn -EINVAL;\r\nmutex_lock(&video->mutex);\r\n*format = vfh->format;\r\nmutex_unlock(&video->mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\nisp_video_set_format(struct file *file, void *fh, struct v4l2_format *format)\r\n{\r\nstruct isp_video_fh *vfh = to_isp_video_fh(fh);\r\nstruct isp_video *video = video_drvdata(file);\r\nstruct v4l2_mbus_framefmt fmt;\r\nif (format->type != video->type)\r\nreturn -EINVAL;\r\nswitch (format->fmt.pix.field) {\r\ncase V4L2_FIELD_NONE:\r\nbreak;\r\ncase V4L2_FIELD_ALTERNATE:\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nformat->fmt.pix.field = V4L2_FIELD_NONE;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nformat->fmt.pix.field = V4L2_FIELD_INTERLACED_TB;\r\ncase V4L2_FIELD_INTERLACED_TB:\r\ncase V4L2_FIELD_INTERLACED_BT:\r\nif (video != &video->isp->isp_ccdc.video_out)\r\nformat->fmt.pix.field = V4L2_FIELD_NONE;\r\nbreak;\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\ncase V4L2_FIELD_SEQ_TB:\r\ncase V4L2_FIELD_SEQ_BT:\r\ndefault:\r\nformat->fmt.pix.field = V4L2_FIELD_NONE;\r\nbreak;\r\n}\r\nisp_video_pix_to_mbus(&format->fmt.pix, &fmt);\r\nisp_video_mbus_to_pix(video, &fmt, &format->fmt.pix);\r\nmutex_lock(&video->mutex);\r\nvfh->format = *format;\r\nmutex_unlock(&video->mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\nisp_video_try_format(struct file *file, void *fh, struct v4l2_format *format)\r\n{\r\nstruct isp_video *video = video_drvdata(file);\r\nstruct v4l2_subdev_format fmt;\r\nstruct v4l2_subdev *subdev;\r\nu32 pad;\r\nint ret;\r\nif (format->type != video->type)\r\nreturn -EINVAL;\r\nsubdev = isp_video_remote_subdev(video, &pad);\r\nif (subdev == NULL)\r\nreturn -EINVAL;\r\nisp_video_pix_to_mbus(&format->fmt.pix, &fmt.format);\r\nfmt.pad = pad;\r\nfmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);\r\nif (ret)\r\nreturn ret == -ENOIOCTLCMD ? -ENOTTY : ret;\r\nisp_video_mbus_to_pix(video, &fmt.format, &format->fmt.pix);\r\nreturn 0;\r\n}\r\nstatic int\r\nisp_video_get_selection(struct file *file, void *fh, struct v4l2_selection *sel)\r\n{\r\nstruct isp_video *video = video_drvdata(file);\r\nstruct v4l2_subdev_format format;\r\nstruct v4l2_subdev *subdev;\r\nstruct v4l2_subdev_selection sdsel = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.target = sel->target,\r\n};\r\nu32 pad;\r\nint ret;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsubdev = isp_video_remote_subdev(video, &pad);\r\nif (subdev == NULL)\r\nreturn -EINVAL;\r\nsdsel.pad = pad;\r\nret = v4l2_subdev_call(subdev, pad, get_selection, NULL, &sdsel);\r\nif (!ret)\r\nsel->r = sdsel.r;\r\nif (ret != -ENOIOCTLCMD)\r\nreturn ret;\r\nformat.pad = pad;\r\nformat.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &format);\r\nif (ret < 0)\r\nreturn ret == -ENOIOCTLCMD ? -ENOTTY : ret;\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = format.format.width;\r\nsel->r.height = format.format.height;\r\nreturn 0;\r\n}\r\nstatic int\r\nisp_video_set_selection(struct file *file, void *fh, struct v4l2_selection *sel)\r\n{\r\nstruct isp_video *video = video_drvdata(file);\r\nstruct v4l2_subdev *subdev;\r\nstruct v4l2_subdev_selection sdsel = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.target = sel->target,\r\n.flags = sel->flags,\r\n.r = sel->r,\r\n};\r\nu32 pad;\r\nint ret;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsubdev = isp_video_remote_subdev(video, &pad);\r\nif (subdev == NULL)\r\nreturn -EINVAL;\r\nsdsel.pad = pad;\r\nmutex_lock(&video->mutex);\r\nret = v4l2_subdev_call(subdev, pad, set_selection, NULL, &sdsel);\r\nmutex_unlock(&video->mutex);\r\nif (!ret)\r\nsel->r = sdsel.r;\r\nreturn ret == -ENOIOCTLCMD ? -ENOTTY : ret;\r\n}\r\nstatic int\r\nisp_video_get_param(struct file *file, void *fh, struct v4l2_streamparm *a)\r\n{\r\nstruct isp_video_fh *vfh = to_isp_video_fh(fh);\r\nstruct isp_video *video = video_drvdata(file);\r\nif (video->type != V4L2_BUF_TYPE_VIDEO_OUTPUT ||\r\nvideo->type != a->type)\r\nreturn -EINVAL;\r\nmemset(a, 0, sizeof(*a));\r\na->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\na->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\r\na->parm.output.timeperframe = vfh->timeperframe;\r\nreturn 0;\r\n}\r\nstatic int\r\nisp_video_set_param(struct file *file, void *fh, struct v4l2_streamparm *a)\r\n{\r\nstruct isp_video_fh *vfh = to_isp_video_fh(fh);\r\nstruct isp_video *video = video_drvdata(file);\r\nif (video->type != V4L2_BUF_TYPE_VIDEO_OUTPUT ||\r\nvideo->type != a->type)\r\nreturn -EINVAL;\r\nif (a->parm.output.timeperframe.denominator == 0)\r\na->parm.output.timeperframe.denominator = 1;\r\nvfh->timeperframe = a->parm.output.timeperframe;\r\nreturn 0;\r\n}\r\nstatic int\r\nisp_video_reqbufs(struct file *file, void *fh, struct v4l2_requestbuffers *rb)\r\n{\r\nstruct isp_video_fh *vfh = to_isp_video_fh(fh);\r\nstruct isp_video *video = video_drvdata(file);\r\nint ret;\r\nmutex_lock(&video->queue_lock);\r\nret = vb2_reqbufs(&vfh->queue, rb);\r\nmutex_unlock(&video->queue_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\nisp_video_querybuf(struct file *file, void *fh, struct v4l2_buffer *b)\r\n{\r\nstruct isp_video_fh *vfh = to_isp_video_fh(fh);\r\nstruct isp_video *video = video_drvdata(file);\r\nint ret;\r\nmutex_lock(&video->queue_lock);\r\nret = vb2_querybuf(&vfh->queue, b);\r\nmutex_unlock(&video->queue_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\nisp_video_qbuf(struct file *file, void *fh, struct v4l2_buffer *b)\r\n{\r\nstruct isp_video_fh *vfh = to_isp_video_fh(fh);\r\nstruct isp_video *video = video_drvdata(file);\r\nint ret;\r\nmutex_lock(&video->queue_lock);\r\nret = vb2_qbuf(&vfh->queue, b);\r\nmutex_unlock(&video->queue_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\nisp_video_dqbuf(struct file *file, void *fh, struct v4l2_buffer *b)\r\n{\r\nstruct isp_video_fh *vfh = to_isp_video_fh(fh);\r\nstruct isp_video *video = video_drvdata(file);\r\nint ret;\r\nmutex_lock(&video->queue_lock);\r\nret = vb2_dqbuf(&vfh->queue, b, file->f_flags & O_NONBLOCK);\r\nmutex_unlock(&video->queue_lock);\r\nreturn ret;\r\n}\r\nstatic int isp_video_check_external_subdevs(struct isp_video *video,\r\nstruct isp_pipeline *pipe)\r\n{\r\nstruct isp_device *isp = video->isp;\r\nstruct media_entity *ents[] = {\r\n&isp->isp_csi2a.subdev.entity,\r\n&isp->isp_csi2c.subdev.entity,\r\n&isp->isp_ccp2.subdev.entity,\r\n&isp->isp_ccdc.subdev.entity\r\n};\r\nstruct media_pad *source_pad;\r\nstruct media_entity *source = NULL;\r\nstruct media_entity *sink;\r\nstruct v4l2_subdev_format fmt;\r\nstruct v4l2_ext_controls ctrls;\r\nstruct v4l2_ext_control ctrl;\r\nunsigned int i;\r\nint ret;\r\nif (pipe->input != NULL)\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(ents); i++) {\r\nif (!media_entity_enum_test(&pipe->ent_enum, ents[i]))\r\ncontinue;\r\nsource_pad = media_entity_remote_pad(&ents[i]->pads[0]);\r\nif (source_pad == NULL)\r\ncontinue;\r\nsource = source_pad->entity;\r\nsink = ents[i];\r\nbreak;\r\n}\r\nif (!source) {\r\ndev_warn(isp->dev, "can't find source, failing now\n");\r\nreturn -EINVAL;\r\n}\r\nif (!is_media_entity_v4l2_subdev(source))\r\nreturn 0;\r\npipe->external = media_entity_to_v4l2_subdev(source);\r\nfmt.pad = source_pad->index;\r\nfmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(media_entity_to_v4l2_subdev(sink),\r\npad, get_fmt, NULL, &fmt);\r\nif (unlikely(ret < 0)) {\r\ndev_warn(isp->dev, "get_fmt returned null!\n");\r\nreturn ret;\r\n}\r\npipe->external_width =\r\nomap3isp_video_format_info(fmt.format.code)->width;\r\nmemset(&ctrls, 0, sizeof(ctrls));\r\nmemset(&ctrl, 0, sizeof(ctrl));\r\nctrl.id = V4L2_CID_PIXEL_RATE;\r\nctrls.count = 1;\r\nctrls.controls = &ctrl;\r\nret = v4l2_g_ext_ctrls(pipe->external->ctrl_handler, &ctrls);\r\nif (ret < 0) {\r\ndev_warn(isp->dev, "no pixel rate control in subdev %s\n",\r\npipe->external->name);\r\nreturn ret;\r\n}\r\npipe->external_rate = ctrl.value64;\r\nif (media_entity_enum_test(&pipe->ent_enum,\r\n&isp->isp_ccdc.subdev.entity)) {\r\nunsigned int rate = UINT_MAX;\r\nomap3isp_ccdc_max_rate(&isp->isp_ccdc, &rate);\r\nif (pipe->external_rate > rate)\r\nreturn -ENOSPC;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nisp_video_streamon(struct file *file, void *fh, enum v4l2_buf_type type)\r\n{\r\nstruct isp_video_fh *vfh = to_isp_video_fh(fh);\r\nstruct isp_video *video = video_drvdata(file);\r\nenum isp_pipeline_state state;\r\nstruct isp_pipeline *pipe;\r\nunsigned long flags;\r\nint ret;\r\nif (type != video->type)\r\nreturn -EINVAL;\r\nmutex_lock(&video->stream_lock);\r\npipe = video->video.entity.pipe\r\n? to_isp_pipeline(&video->video.entity) : &video->pipe;\r\nret = media_entity_enum_init(&pipe->ent_enum, &video->isp->media_dev);\r\nif (ret)\r\ngoto err_enum_init;\r\npipe->l3_ick = clk_get_rate(video->isp->clock[ISP_CLK_L3_ICK]);\r\npipe->max_rate = pipe->l3_ick;\r\nret = media_pipeline_start(&video->video.entity, &pipe->pipe);\r\nif (ret < 0)\r\ngoto err_pipeline_start;\r\nret = isp_video_check_format(video, vfh);\r\nif (ret < 0)\r\ngoto err_check_format;\r\nvideo->bpl_padding = ret;\r\nvideo->bpl_value = vfh->format.fmt.pix.bytesperline;\r\nret = isp_video_get_graph_data(video, pipe);\r\nif (ret < 0)\r\ngoto err_check_format;\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nstate = ISP_PIPELINE_STREAM_OUTPUT | ISP_PIPELINE_IDLE_OUTPUT;\r\nelse\r\nstate = ISP_PIPELINE_STREAM_INPUT | ISP_PIPELINE_IDLE_INPUT;\r\nret = isp_video_check_external_subdevs(video, pipe);\r\nif (ret < 0)\r\ngoto err_check_format;\r\npipe->error = false;\r\nspin_lock_irqsave(&pipe->lock, flags);\r\npipe->state &= ~ISP_PIPELINE_STREAM;\r\npipe->state |= state;\r\nspin_unlock_irqrestore(&pipe->lock, flags);\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\npipe->max_timeperframe = vfh->timeperframe;\r\nvideo->queue = &vfh->queue;\r\nINIT_LIST_HEAD(&video->dmaqueue);\r\natomic_set(&pipe->frame_number, -1);\r\npipe->field = vfh->format.fmt.pix.field;\r\nmutex_lock(&video->queue_lock);\r\nret = vb2_streamon(&vfh->queue, type);\r\nmutex_unlock(&video->queue_lock);\r\nif (ret < 0)\r\ngoto err_check_format;\r\nmutex_unlock(&video->stream_lock);\r\nreturn 0;\r\nerr_check_format:\r\nmedia_pipeline_stop(&video->video.entity);\r\nerr_pipeline_start:\r\nINIT_LIST_HEAD(&video->dmaqueue);\r\nvideo->queue = NULL;\r\nmedia_entity_enum_cleanup(&pipe->ent_enum);\r\nerr_enum_init:\r\nmutex_unlock(&video->stream_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\nisp_video_streamoff(struct file *file, void *fh, enum v4l2_buf_type type)\r\n{\r\nstruct isp_video_fh *vfh = to_isp_video_fh(fh);\r\nstruct isp_video *video = video_drvdata(file);\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&video->video.entity);\r\nenum isp_pipeline_state state;\r\nunsigned int streaming;\r\nunsigned long flags;\r\nif (type != video->type)\r\nreturn -EINVAL;\r\nmutex_lock(&video->stream_lock);\r\nmutex_lock(&video->queue_lock);\r\nstreaming = vb2_is_streaming(&vfh->queue);\r\nmutex_unlock(&video->queue_lock);\r\nif (!streaming)\r\ngoto done;\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nstate = ISP_PIPELINE_STREAM_OUTPUT\r\n| ISP_PIPELINE_QUEUE_OUTPUT;\r\nelse\r\nstate = ISP_PIPELINE_STREAM_INPUT\r\n| ISP_PIPELINE_QUEUE_INPUT;\r\nspin_lock_irqsave(&pipe->lock, flags);\r\npipe->state &= ~state;\r\nspin_unlock_irqrestore(&pipe->lock, flags);\r\nomap3isp_pipeline_set_stream(pipe, ISP_PIPELINE_STREAM_STOPPED);\r\nomap3isp_video_cancel_stream(video);\r\nmutex_lock(&video->queue_lock);\r\nvb2_streamoff(&vfh->queue, type);\r\nmutex_unlock(&video->queue_lock);\r\nvideo->queue = NULL;\r\nvideo->error = false;\r\nmedia_pipeline_stop(&video->video.entity);\r\nmedia_entity_enum_cleanup(&pipe->ent_enum);\r\ndone:\r\nmutex_unlock(&video->stream_lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nisp_video_enum_input(struct file *file, void *fh, struct v4l2_input *input)\r\n{\r\nif (input->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(input->name, "camera", sizeof(input->name));\r\ninput->type = V4L2_INPUT_TYPE_CAMERA;\r\nreturn 0;\r\n}\r\nstatic int\r\nisp_video_g_input(struct file *file, void *fh, unsigned int *input)\r\n{\r\n*input = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nisp_video_s_input(struct file *file, void *fh, unsigned int input)\r\n{\r\nreturn input == 0 ? 0 : -EINVAL;\r\n}\r\nstatic int isp_video_open(struct file *file)\r\n{\r\nstruct isp_video *video = video_drvdata(file);\r\nstruct isp_video_fh *handle;\r\nstruct vb2_queue *queue;\r\nint ret = 0;\r\nhandle = kzalloc(sizeof(*handle), GFP_KERNEL);\r\nif (handle == NULL)\r\nreturn -ENOMEM;\r\nv4l2_fh_init(&handle->vfh, &video->video);\r\nv4l2_fh_add(&handle->vfh);\r\nif (omap3isp_get(video->isp) == NULL) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nret = v4l2_pipeline_pm_use(&video->video.entity, 1);\r\nif (ret < 0) {\r\nomap3isp_put(video->isp);\r\ngoto done;\r\n}\r\nqueue = &handle->queue;\r\nqueue->type = video->type;\r\nqueue->io_modes = VB2_MMAP | VB2_USERPTR;\r\nqueue->drv_priv = handle;\r\nqueue->ops = &isp_video_queue_ops;\r\nqueue->mem_ops = &vb2_dma_contig_memops;\r\nqueue->buf_struct_size = sizeof(struct isp_buffer);\r\nqueue->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nqueue->dev = video->isp->dev;\r\nret = vb2_queue_init(&handle->queue);\r\nif (ret < 0) {\r\nomap3isp_put(video->isp);\r\ngoto done;\r\n}\r\nmemset(&handle->format, 0, sizeof(handle->format));\r\nhandle->format.type = video->type;\r\nhandle->timeperframe.denominator = 1;\r\nhandle->video = video;\r\nfile->private_data = &handle->vfh;\r\ndone:\r\nif (ret < 0) {\r\nv4l2_fh_del(&handle->vfh);\r\nv4l2_fh_exit(&handle->vfh);\r\nkfree(handle);\r\n}\r\nreturn ret;\r\n}\r\nstatic int isp_video_release(struct file *file)\r\n{\r\nstruct isp_video *video = video_drvdata(file);\r\nstruct v4l2_fh *vfh = file->private_data;\r\nstruct isp_video_fh *handle = to_isp_video_fh(vfh);\r\nisp_video_streamoff(file, vfh, video->type);\r\nmutex_lock(&video->queue_lock);\r\nvb2_queue_release(&handle->queue);\r\nmutex_unlock(&video->queue_lock);\r\nv4l2_pipeline_pm_use(&video->video.entity, 0);\r\nv4l2_fh_del(vfh);\r\nv4l2_fh_exit(vfh);\r\nkfree(handle);\r\nfile->private_data = NULL;\r\nomap3isp_put(video->isp);\r\nreturn 0;\r\n}\r\nstatic unsigned int isp_video_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct isp_video_fh *vfh = to_isp_video_fh(file->private_data);\r\nstruct isp_video *video = video_drvdata(file);\r\nint ret;\r\nmutex_lock(&video->queue_lock);\r\nret = vb2_poll(&vfh->queue, file, wait);\r\nmutex_unlock(&video->queue_lock);\r\nreturn ret;\r\n}\r\nstatic int isp_video_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct isp_video_fh *vfh = to_isp_video_fh(file->private_data);\r\nreturn vb2_mmap(&vfh->queue, vma);\r\n}\r\nint omap3isp_video_init(struct isp_video *video, const char *name)\r\n{\r\nconst char *direction;\r\nint ret;\r\nswitch (video->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\ndirection = "output";\r\nvideo->pad.flags = MEDIA_PAD_FL_SINK\r\n| MEDIA_PAD_FL_MUST_CONNECT;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\ndirection = "input";\r\nvideo->pad.flags = MEDIA_PAD_FL_SOURCE\r\n| MEDIA_PAD_FL_MUST_CONNECT;\r\nvideo->video.vfl_dir = VFL_DIR_TX;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = media_entity_pads_init(&video->video.entity, 1, &video->pad);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_init(&video->mutex);\r\natomic_set(&video->active, 0);\r\nspin_lock_init(&video->pipe.lock);\r\nmutex_init(&video->stream_lock);\r\nmutex_init(&video->queue_lock);\r\nspin_lock_init(&video->irqlock);\r\nif (video->ops == NULL)\r\nvideo->ops = &isp_video_dummy_ops;\r\nvideo->video.fops = &isp_video_fops;\r\nsnprintf(video->video.name, sizeof(video->video.name),\r\n"OMAP3 ISP %s %s", name, direction);\r\nvideo->video.vfl_type = VFL_TYPE_GRABBER;\r\nvideo->video.release = video_device_release_empty;\r\nvideo->video.ioctl_ops = &isp_video_ioctl_ops;\r\nvideo->pipe.stream_state = ISP_PIPELINE_STREAM_STOPPED;\r\nvideo_set_drvdata(&video->video, video);\r\nreturn 0;\r\n}\r\nvoid omap3isp_video_cleanup(struct isp_video *video)\r\n{\r\nmedia_entity_cleanup(&video->video.entity);\r\nmutex_destroy(&video->queue_lock);\r\nmutex_destroy(&video->stream_lock);\r\nmutex_destroy(&video->mutex);\r\n}\r\nint omap3isp_video_register(struct isp_video *video, struct v4l2_device *vdev)\r\n{\r\nint ret;\r\nvideo->video.v4l2_dev = vdev;\r\nret = video_register_device(&video->video, VFL_TYPE_GRABBER, -1);\r\nif (ret < 0)\r\ndev_err(video->isp->dev,\r\n"%s: could not register video device (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nvoid omap3isp_video_unregister(struct isp_video *video)\r\n{\r\nif (video_is_registered(&video->video))\r\nvideo_unregister_device(&video->video);\r\n}
