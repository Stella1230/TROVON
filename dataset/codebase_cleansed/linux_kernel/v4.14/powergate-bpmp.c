static inline struct tegra_powergate *\r\nto_tegra_powergate(struct generic_pm_domain *genpd)\r\n{\r\nreturn container_of(genpd, struct tegra_powergate, genpd);\r\n}\r\nstatic int tegra_bpmp_powergate_set_state(struct tegra_bpmp *bpmp,\r\nunsigned int id, u32 state)\r\n{\r\nstruct mrq_pg_request request;\r\nstruct tegra_bpmp_message msg;\r\nmemset(&request, 0, sizeof(request));\r\nrequest.cmd = CMD_PG_SET_STATE;\r\nrequest.id = id;\r\nrequest.set_state.state = state;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.mrq = MRQ_PG;\r\nmsg.tx.data = &request;\r\nmsg.tx.size = sizeof(request);\r\nreturn tegra_bpmp_transfer(bpmp, &msg);\r\n}\r\nstatic int tegra_bpmp_powergate_get_state(struct tegra_bpmp *bpmp,\r\nunsigned int id)\r\n{\r\nstruct mrq_pg_response response;\r\nstruct mrq_pg_request request;\r\nstruct tegra_bpmp_message msg;\r\nint err;\r\nmemset(&request, 0, sizeof(request));\r\nrequest.cmd = CMD_PG_GET_STATE;\r\nrequest.id = id;\r\nmemset(&response, 0, sizeof(response));\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.mrq = MRQ_PG;\r\nmsg.tx.data = &request;\r\nmsg.tx.size = sizeof(request);\r\nmsg.rx.data = &response;\r\nmsg.rx.size = sizeof(response);\r\nerr = tegra_bpmp_transfer(bpmp, &msg);\r\nif (err < 0)\r\nreturn PG_STATE_OFF;\r\nreturn response.get_state.state;\r\n}\r\nstatic int tegra_bpmp_powergate_get_max_id(struct tegra_bpmp *bpmp)\r\n{\r\nstruct mrq_pg_response response;\r\nstruct mrq_pg_request request;\r\nstruct tegra_bpmp_message msg;\r\nint err;\r\nmemset(&request, 0, sizeof(request));\r\nrequest.cmd = CMD_PG_GET_MAX_ID;\r\nmemset(&response, 0, sizeof(response));\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.mrq = MRQ_PG;\r\nmsg.tx.data = &request;\r\nmsg.tx.size = sizeof(request);\r\nmsg.rx.data = &response;\r\nmsg.rx.size = sizeof(response);\r\nerr = tegra_bpmp_transfer(bpmp, &msg);\r\nif (err < 0)\r\nreturn err;\r\nreturn response.get_max_id.max_id;\r\n}\r\nstatic char *tegra_bpmp_powergate_get_name(struct tegra_bpmp *bpmp,\r\nunsigned int id)\r\n{\r\nstruct mrq_pg_response response;\r\nstruct mrq_pg_request request;\r\nstruct tegra_bpmp_message msg;\r\nint err;\r\nmemset(&request, 0, sizeof(request));\r\nrequest.cmd = CMD_PG_GET_NAME;\r\nrequest.id = id;\r\nmemset(&response, 0, sizeof(response));\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.mrq = MRQ_PG;\r\nmsg.tx.data = &request;\r\nmsg.tx.size = sizeof(request);\r\nmsg.rx.data = &response;\r\nmsg.rx.size = sizeof(response);\r\nerr = tegra_bpmp_transfer(bpmp, &msg);\r\nif (err < 0)\r\nreturn NULL;\r\nreturn kstrdup(response.get_name.name, GFP_KERNEL);\r\n}\r\nstatic inline bool tegra_bpmp_powergate_is_powered(struct tegra_bpmp *bpmp,\r\nunsigned int id)\r\n{\r\nreturn tegra_bpmp_powergate_get_state(bpmp, id) != PG_STATE_OFF;\r\n}\r\nstatic int tegra_powergate_power_on(struct generic_pm_domain *domain)\r\n{\r\nstruct tegra_powergate *powergate = to_tegra_powergate(domain);\r\nstruct tegra_bpmp *bpmp = powergate->bpmp;\r\nreturn tegra_bpmp_powergate_set_state(bpmp, powergate->id,\r\nPG_STATE_ON);\r\n}\r\nstatic int tegra_powergate_power_off(struct generic_pm_domain *domain)\r\n{\r\nstruct tegra_powergate *powergate = to_tegra_powergate(domain);\r\nstruct tegra_bpmp *bpmp = powergate->bpmp;\r\nreturn tegra_bpmp_powergate_set_state(bpmp, powergate->id,\r\nPG_STATE_OFF);\r\n}\r\nstatic struct tegra_powergate *\r\ntegra_powergate_add(struct tegra_bpmp *bpmp,\r\nconst struct tegra_powergate_info *info)\r\n{\r\nstruct tegra_powergate *powergate;\r\nbool off;\r\nint err;\r\noff = !tegra_bpmp_powergate_is_powered(bpmp, info->id);\r\npowergate = devm_kzalloc(bpmp->dev, sizeof(*powergate), GFP_KERNEL);\r\nif (!powergate)\r\nreturn ERR_PTR(-ENOMEM);\r\npowergate->id = info->id;\r\npowergate->bpmp = bpmp;\r\npowergate->genpd.name = kstrdup(info->name, GFP_KERNEL);\r\npowergate->genpd.power_on = tegra_powergate_power_on;\r\npowergate->genpd.power_off = tegra_powergate_power_off;\r\nerr = pm_genpd_init(&powergate->genpd, NULL, off);\r\nif (err < 0) {\r\nkfree(powergate->genpd.name);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn powergate;\r\n}\r\nstatic void tegra_powergate_remove(struct tegra_powergate *powergate)\r\n{\r\nstruct generic_pm_domain *genpd = &powergate->genpd;\r\nstruct tegra_bpmp *bpmp = powergate->bpmp;\r\nint err;\r\nerr = pm_genpd_remove(genpd);\r\nif (err < 0)\r\ndev_err(bpmp->dev, "failed to remove power domain %s: %d\n",\r\ngenpd->name, err);\r\nkfree(genpd->name);\r\n}\r\nstatic int\r\ntegra_bpmp_probe_powergates(struct tegra_bpmp *bpmp,\r\nstruct tegra_powergate_info **powergatesp)\r\n{\r\nstruct tegra_powergate_info *powergates;\r\nunsigned int max_id, id, count = 0;\r\nunsigned int num_holes = 0;\r\nint err;\r\nerr = tegra_bpmp_powergate_get_max_id(bpmp);\r\nif (err < 0)\r\nreturn err;\r\nmax_id = err;\r\ndev_dbg(bpmp->dev, "maximum powergate ID: %u\n", max_id);\r\npowergates = kcalloc(max_id + 1, sizeof(*powergates), GFP_KERNEL);\r\nif (!powergates)\r\nreturn -ENOMEM;\r\nfor (id = 0; id <= max_id; id++) {\r\nstruct tegra_powergate_info *info = &powergates[count];\r\ninfo->name = tegra_bpmp_powergate_get_name(bpmp, id);\r\nif (!info->name || info->name[0] == '\0') {\r\nnum_holes++;\r\ncontinue;\r\n}\r\ninfo->id = id;\r\ncount++;\r\n}\r\ndev_dbg(bpmp->dev, "holes: %u\n", num_holes);\r\n*powergatesp = powergates;\r\nreturn count;\r\n}\r\nstatic int tegra_bpmp_add_powergates(struct tegra_bpmp *bpmp,\r\nstruct tegra_powergate_info *powergates,\r\nunsigned int count)\r\n{\r\nstruct genpd_onecell_data *genpd = &bpmp->genpd;\r\nstruct generic_pm_domain **domains;\r\nstruct tegra_powergate *powergate;\r\nunsigned int i;\r\nint err;\r\ndomains = kcalloc(count, sizeof(*domains), GFP_KERNEL);\r\nif (!domains)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < count; i++) {\r\npowergate = tegra_powergate_add(bpmp, &powergates[i]);\r\nif (IS_ERR(powergate)) {\r\nerr = PTR_ERR(powergate);\r\ngoto remove;\r\n}\r\ndev_dbg(bpmp->dev, "added power domain %s\n",\r\npowergate->genpd.name);\r\ndomains[i] = &powergate->genpd;\r\n}\r\ngenpd->num_domains = count;\r\ngenpd->domains = domains;\r\nreturn 0;\r\nremove:\r\nwhile (i--) {\r\npowergate = to_tegra_powergate(domains[i]);\r\ntegra_powergate_remove(powergate);\r\n}\r\nkfree(genpd->domains);\r\nreturn err;\r\n}\r\nstatic void tegra_bpmp_remove_powergates(struct tegra_bpmp *bpmp)\r\n{\r\nstruct genpd_onecell_data *genpd = &bpmp->genpd;\r\nunsigned int i = genpd->num_domains;\r\nstruct tegra_powergate *powergate;\r\nwhile (i--) {\r\ndev_dbg(bpmp->dev, "removing power domain %s\n",\r\ngenpd->domains[i]->name);\r\npowergate = to_tegra_powergate(genpd->domains[i]);\r\ntegra_powergate_remove(powergate);\r\n}\r\n}\r\nstatic struct generic_pm_domain *\r\ntegra_powergate_xlate(struct of_phandle_args *spec, void *data)\r\n{\r\nstruct generic_pm_domain *domain = ERR_PTR(-ENOENT);\r\nstruct genpd_onecell_data *genpd = data;\r\nunsigned int i;\r\nfor (i = 0; i < genpd->num_domains; i++) {\r\nstruct tegra_powergate *powergate;\r\npowergate = to_tegra_powergate(genpd->domains[i]);\r\nif (powergate->id == spec->args[0]) {\r\ndomain = &powergate->genpd;\r\nbreak;\r\n}\r\n}\r\nreturn domain;\r\n}\r\nint tegra_bpmp_init_powergates(struct tegra_bpmp *bpmp)\r\n{\r\nstruct device_node *np = bpmp->dev->of_node;\r\nstruct tegra_powergate_info *powergates;\r\nstruct device *dev = bpmp->dev;\r\nunsigned int count, i;\r\nint err;\r\nerr = tegra_bpmp_probe_powergates(bpmp, &powergates);\r\nif (err < 0)\r\nreturn err;\r\ncount = err;\r\ndev_dbg(dev, "%u power domains probed\n", count);\r\nerr = tegra_bpmp_add_powergates(bpmp, powergates, count);\r\nif (err < 0)\r\ngoto free;\r\nbpmp->genpd.xlate = tegra_powergate_xlate;\r\nerr = of_genpd_add_provider_onecell(np, &bpmp->genpd);\r\nif (err < 0) {\r\ndev_err(dev, "failed to add power domain provider: %d\n", err);\r\ntegra_bpmp_remove_powergates(bpmp);\r\n}\r\nfree:\r\nfor (i = 0; i < count; i++)\r\nkfree(powergates[i].name);\r\nkfree(powergates);\r\nreturn err;\r\n}
