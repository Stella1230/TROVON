static bool __ath6kl_cfg80211_sscan_stop(struct ath6kl_vif *vif)\r\n{\r\nstruct ath6kl *ar = vif->ar;\r\nif (!test_and_clear_bit(SCHED_SCANNING, &vif->flags))\r\nreturn false;\r\ndel_timer_sync(&vif->sched_scan_timer);\r\nif (ar->state == ATH6KL_STATE_RECOVERY)\r\nreturn true;\r\nath6kl_wmi_enable_sched_scan_cmd(ar->wmi, vif->fw_vif_idx, false);\r\nreturn true;\r\n}\r\nstatic void ath6kl_cfg80211_sscan_disable(struct ath6kl_vif *vif)\r\n{\r\nstruct ath6kl *ar = vif->ar;\r\nbool stopped;\r\nstopped = __ath6kl_cfg80211_sscan_stop(vif);\r\nif (!stopped)\r\nreturn;\r\ncfg80211_sched_scan_stopped(ar->wiphy, 0);\r\n}\r\nstatic int ath6kl_set_wpa_version(struct ath6kl_vif *vif,\r\nenum nl80211_wpa_versions wpa_version)\r\n{\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: %u\n", __func__, wpa_version);\r\nif (!wpa_version) {\r\nvif->auth_mode = NONE_AUTH;\r\n} else if (wpa_version & NL80211_WPA_VERSION_2) {\r\nvif->auth_mode = WPA2_AUTH;\r\n} else if (wpa_version & NL80211_WPA_VERSION_1) {\r\nvif->auth_mode = WPA_AUTH;\r\n} else {\r\nath6kl_err("%s: %u not supported\n", __func__, wpa_version);\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ath6kl_set_auth_type(struct ath6kl_vif *vif,\r\nenum nl80211_auth_type auth_type)\r\n{\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: 0x%x\n", __func__, auth_type);\r\nswitch (auth_type) {\r\ncase NL80211_AUTHTYPE_OPEN_SYSTEM:\r\nvif->dot11_auth_mode = OPEN_AUTH;\r\nbreak;\r\ncase NL80211_AUTHTYPE_SHARED_KEY:\r\nvif->dot11_auth_mode = SHARED_AUTH;\r\nbreak;\r\ncase NL80211_AUTHTYPE_NETWORK_EAP:\r\nvif->dot11_auth_mode = LEAP_AUTH;\r\nbreak;\r\ncase NL80211_AUTHTYPE_AUTOMATIC:\r\nvif->dot11_auth_mode = OPEN_AUTH | SHARED_AUTH;\r\nbreak;\r\ndefault:\r\nath6kl_err("%s: 0x%x not supported\n", __func__, auth_type);\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ath6kl_set_cipher(struct ath6kl_vif *vif, u32 cipher, bool ucast)\r\n{\r\nu8 *ar_cipher = ucast ? &vif->prwise_crypto : &vif->grp_crypto;\r\nu8 *ar_cipher_len = ucast ? &vif->prwise_crypto_len :\r\n&vif->grp_crypto_len;\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: cipher 0x%x, ucast %u\n",\r\n__func__, cipher, ucast);\r\nswitch (cipher) {\r\ncase 0:\r\n*ar_cipher = NONE_CRYPT;\r\n*ar_cipher_len = 0;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\n*ar_cipher = WEP_CRYPT;\r\n*ar_cipher_len = 5;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\n*ar_cipher = WEP_CRYPT;\r\n*ar_cipher_len = 13;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\n*ar_cipher = TKIP_CRYPT;\r\n*ar_cipher_len = 0;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\n*ar_cipher = AES_CRYPT;\r\n*ar_cipher_len = 0;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_SMS4:\r\n*ar_cipher = WAPI_CRYPT;\r\n*ar_cipher_len = 0;\r\nbreak;\r\ndefault:\r\nath6kl_err("cipher 0x%x not supported\n", cipher);\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ath6kl_set_key_mgmt(struct ath6kl_vif *vif, u32 key_mgmt)\r\n{\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: 0x%x\n", __func__, key_mgmt);\r\nif (key_mgmt == WLAN_AKM_SUITE_PSK) {\r\nif (vif->auth_mode == WPA_AUTH)\r\nvif->auth_mode = WPA_PSK_AUTH;\r\nelse if (vif->auth_mode == WPA2_AUTH)\r\nvif->auth_mode = WPA2_PSK_AUTH;\r\n} else if (key_mgmt == 0x00409600) {\r\nif (vif->auth_mode == WPA_AUTH)\r\nvif->auth_mode = WPA_AUTH_CCKM;\r\nelse if (vif->auth_mode == WPA2_AUTH)\r\nvif->auth_mode = WPA2_AUTH_CCKM;\r\n} else if (key_mgmt != WLAN_AKM_SUITE_8021X) {\r\nvif->auth_mode = NONE_AUTH;\r\n}\r\n}\r\nstatic bool ath6kl_cfg80211_ready(struct ath6kl_vif *vif)\r\n{\r\nstruct ath6kl *ar = vif->ar;\r\nif (!test_bit(WMI_READY, &ar->flag)) {\r\nath6kl_err("wmi is not ready\n");\r\nreturn false;\r\n}\r\nif (!test_bit(WLAN_ENABLED, &vif->flags)) {\r\nath6kl_err("wlan disabled\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool ath6kl_is_wpa_ie(const u8 *pos)\r\n{\r\nreturn pos[0] == WLAN_EID_VENDOR_SPECIFIC && pos[1] >= 4 &&\r\npos[2] == 0x00 && pos[3] == 0x50 &&\r\npos[4] == 0xf2 && pos[5] == 0x01;\r\n}\r\nstatic bool ath6kl_is_rsn_ie(const u8 *pos)\r\n{\r\nreturn pos[0] == WLAN_EID_RSN;\r\n}\r\nstatic bool ath6kl_is_wps_ie(const u8 *pos)\r\n{\r\nreturn (pos[0] == WLAN_EID_VENDOR_SPECIFIC &&\r\npos[1] >= 4 &&\r\npos[2] == 0x00 && pos[3] == 0x50 && pos[4] == 0xf2 &&\r\npos[5] == 0x04);\r\n}\r\nstatic int ath6kl_set_assoc_req_ies(struct ath6kl_vif *vif, const u8 *ies,\r\nsize_t ies_len)\r\n{\r\nstruct ath6kl *ar = vif->ar;\r\nconst u8 *pos;\r\nu8 *buf = NULL;\r\nsize_t len = 0;\r\nint ret;\r\nar->connect_ctrl_flags &= ~CONNECT_WPS_FLAG;\r\nif (ies && ies_len) {\r\nbuf = kmalloc(ies_len, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\npos = ies;\r\nwhile (pos + 1 < ies + ies_len) {\r\nif (pos + 2 + pos[1] > ies + ies_len)\r\nbreak;\r\nif (!(ath6kl_is_wpa_ie(pos) || ath6kl_is_rsn_ie(pos))) {\r\nmemcpy(buf + len, pos, 2 + pos[1]);\r\nlen += 2 + pos[1];\r\n}\r\nif (ath6kl_is_wps_ie(pos))\r\nar->connect_ctrl_flags |= CONNECT_WPS_FLAG;\r\npos += 2 + pos[1];\r\n}\r\n}\r\nret = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,\r\nWMI_FRAME_ASSOC_REQ, buf, len);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int ath6kl_nliftype_to_drv_iftype(enum nl80211_iftype type, u8 *nw_type)\r\n{\r\nswitch (type) {\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\n*nw_type = INFRA_NETWORK;\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\n*nw_type = ADHOC_NETWORK;\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_P2P_GO:\r\n*nw_type = AP_NETWORK;\r\nbreak;\r\ndefault:\r\nath6kl_err("invalid interface type %u\n", type);\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool ath6kl_is_valid_iftype(struct ath6kl *ar, enum nl80211_iftype type,\r\nu8 *if_idx, u8 *nw_type)\r\n{\r\nint i;\r\nif (ath6kl_nliftype_to_drv_iftype(type, nw_type))\r\nreturn false;\r\nif (ar->ibss_if_active || ((type == NL80211_IFTYPE_ADHOC) &&\r\nar->num_vif))\r\nreturn false;\r\nif (type == NL80211_IFTYPE_STATION ||\r\ntype == NL80211_IFTYPE_AP || type == NL80211_IFTYPE_ADHOC) {\r\nfor (i = 0; i < ar->vif_max; i++) {\r\nif ((ar->avail_idx_map) & BIT(i)) {\r\n*if_idx = i;\r\nreturn true;\r\n}\r\n}\r\n}\r\nif (type == NL80211_IFTYPE_P2P_CLIENT ||\r\ntype == NL80211_IFTYPE_P2P_GO) {\r\nfor (i = ar->max_norm_iface; i < ar->vif_max; i++) {\r\nif ((ar->avail_idx_map) & BIT(i)) {\r\n*if_idx = i;\r\nreturn true;\r\n}\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic bool ath6kl_is_tx_pending(struct ath6kl *ar)\r\n{\r\nreturn ar->tx_pending[ath6kl_wmi_get_control_ep(ar->wmi)] == 0;\r\n}\r\nstatic void ath6kl_cfg80211_sta_bmiss_enhance(struct ath6kl_vif *vif,\r\nbool enable)\r\n{\r\nint err;\r\nif (WARN_ON(!test_bit(WMI_READY, &vif->ar->flag)))\r\nreturn;\r\nif (vif->nw_type != INFRA_NETWORK)\r\nreturn;\r\nif (!test_bit(ATH6KL_FW_CAPABILITY_BMISS_ENHANCE,\r\nvif->ar->fw_capabilities))\r\nreturn;\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s fw bmiss enhance\n",\r\nenable ? "enable" : "disable");\r\nerr = ath6kl_wmi_sta_bmiss_enhance_cmd(vif->ar->wmi,\r\nvif->fw_vif_idx, enable);\r\nif (err)\r\nath6kl_err("failed to %s enhanced bmiss detection: %d\n",\r\nenable ? "enable" : "disable", err);\r\n}\r\nstatic int ath6kl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,\r\nstruct cfg80211_connect_params *sme)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(dev);\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nint status;\r\nu8 nw_subtype = (ar->p2p) ? SUBTYPE_P2PDEV : SUBTYPE_NONE;\r\nu16 interval;\r\nath6kl_cfg80211_sscan_disable(vif);\r\nvif->sme_state = SME_CONNECTING;\r\nif (!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nif (test_bit(DESTROY_IN_PROGRESS, &ar->flag)) {\r\nath6kl_err("destroy in progress\n");\r\nreturn -EBUSY;\r\n}\r\nif (test_bit(SKIP_SCAN, &ar->flag) &&\r\n((sme->channel && sme->channel->center_freq == 0) ||\r\n(sme->bssid && is_zero_ether_addr(sme->bssid)))) {\r\nath6kl_err("SkipScan: channel or bssid invalid\n");\r\nreturn -EINVAL;\r\n}\r\nif (down_interruptible(&ar->sem)) {\r\nath6kl_err("busy, couldn't get access\n");\r\nreturn -ERESTARTSYS;\r\n}\r\nif (test_bit(DESTROY_IN_PROGRESS, &ar->flag)) {\r\nath6kl_err("busy, destroy in progress\n");\r\nup(&ar->sem);\r\nreturn -EBUSY;\r\n}\r\nif (ar->tx_pending[ath6kl_wmi_get_control_ep(ar->wmi)]) {\r\nwait_event_interruptible_timeout(ar->event_wq,\r\nath6kl_is_tx_pending(ar),\r\nWMI_TIMEOUT);\r\nif (signal_pending(current)) {\r\nath6kl_err("cmd queue drain timeout\n");\r\nup(&ar->sem);\r\nreturn -EINTR;\r\n}\r\n}\r\nstatus = ath6kl_set_assoc_req_ies(vif, sme->ie, sme->ie_len);\r\nif (status) {\r\nup(&ar->sem);\r\nreturn status;\r\n}\r\nif (sme->ie == NULL || sme->ie_len == 0)\r\nar->connect_ctrl_flags &= ~CONNECT_WPS_FLAG;\r\nif (test_bit(CONNECTED, &vif->flags) &&\r\nvif->ssid_len == sme->ssid_len &&\r\n!memcmp(vif->ssid, sme->ssid, vif->ssid_len)) {\r\nvif->reconnect_flag = true;\r\nstatus = ath6kl_wmi_reconnect_cmd(ar->wmi, vif->fw_vif_idx,\r\nvif->req_bssid,\r\nvif->ch_hint);\r\nup(&ar->sem);\r\nif (status) {\r\nath6kl_err("wmi_reconnect_cmd failed\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n} else if (vif->ssid_len == sme->ssid_len &&\r\n!memcmp(vif->ssid, sme->ssid, vif->ssid_len)) {\r\nath6kl_disconnect(vif);\r\n}\r\nmemset(vif->ssid, 0, sizeof(vif->ssid));\r\nvif->ssid_len = sme->ssid_len;\r\nmemcpy(vif->ssid, sme->ssid, sme->ssid_len);\r\nif (sme->channel)\r\nvif->ch_hint = sme->channel->center_freq;\r\nmemset(vif->req_bssid, 0, sizeof(vif->req_bssid));\r\nif (sme->bssid && !is_broadcast_ether_addr(sme->bssid))\r\nmemcpy(vif->req_bssid, sme->bssid, sizeof(vif->req_bssid));\r\nath6kl_set_wpa_version(vif, sme->crypto.wpa_versions);\r\nstatus = ath6kl_set_auth_type(vif, sme->auth_type);\r\nif (status) {\r\nup(&ar->sem);\r\nreturn status;\r\n}\r\nif (sme->crypto.n_ciphers_pairwise)\r\nath6kl_set_cipher(vif, sme->crypto.ciphers_pairwise[0], true);\r\nelse\r\nath6kl_set_cipher(vif, 0, true);\r\nath6kl_set_cipher(vif, sme->crypto.cipher_group, false);\r\nif (sme->crypto.n_akm_suites)\r\nath6kl_set_key_mgmt(vif, sme->crypto.akm_suites[0]);\r\nif ((sme->key_len) &&\r\n(vif->auth_mode == NONE_AUTH) &&\r\n(vif->prwise_crypto == WEP_CRYPT)) {\r\nstruct ath6kl_key *key = NULL;\r\nif (sme->key_idx > WMI_MAX_KEY_INDEX) {\r\nath6kl_err("key index %d out of bounds\n",\r\nsme->key_idx);\r\nup(&ar->sem);\r\nreturn -ENOENT;\r\n}\r\nkey = &vif->keys[sme->key_idx];\r\nkey->key_len = sme->key_len;\r\nmemcpy(key->key, sme->key, key->key_len);\r\nkey->cipher = vif->prwise_crypto;\r\nvif->def_txkey_index = sme->key_idx;\r\nath6kl_wmi_addkey_cmd(ar->wmi, vif->fw_vif_idx, sme->key_idx,\r\nvif->prwise_crypto,\r\nGROUP_USAGE | TX_USAGE,\r\nkey->key_len,\r\nNULL, 0,\r\nkey->key, KEY_OP_INIT_VAL, NULL,\r\nNO_SYNC_WMIFLAG);\r\n}\r\nif (!ar->usr_bss_filter) {\r\nclear_bit(CLEAR_BSSFILTER_ON_BEACON, &vif->flags);\r\nif (ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,\r\nALL_BSS_FILTER, 0) != 0) {\r\nath6kl_err("couldn't set bss filtering\n");\r\nup(&ar->sem);\r\nreturn -EIO;\r\n}\r\n}\r\nvif->nw_type = vif->next_mode;\r\nath6kl_cfg80211_sta_bmiss_enhance(vif, true);\r\nif (vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)\r\nnw_subtype = SUBTYPE_P2PCLIENT;\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"%s: connect called with authmode %d dot11 auth %d"\r\n" PW crypto %d PW crypto len %d GRP crypto %d"\r\n" GRP crypto len %d channel hint %u\n",\r\n__func__,\r\nvif->auth_mode, vif->dot11_auth_mode, vif->prwise_crypto,\r\nvif->prwise_crypto_len, vif->grp_crypto,\r\nvif->grp_crypto_len, vif->ch_hint);\r\nvif->reconnect_flag = 0;\r\nif (vif->nw_type == INFRA_NETWORK) {\r\ninterval = max_t(u16, vif->listen_intvl_t,\r\nATH6KL_MAX_WOW_LISTEN_INTL);\r\nstatus = ath6kl_wmi_listeninterval_cmd(ar->wmi, vif->fw_vif_idx,\r\ninterval,\r\n0);\r\nif (status) {\r\nath6kl_err("couldn't set listen intervel\n");\r\nup(&ar->sem);\r\nreturn status;\r\n}\r\n}\r\nstatus = ath6kl_wmi_connect_cmd(ar->wmi, vif->fw_vif_idx, vif->nw_type,\r\nvif->dot11_auth_mode, vif->auth_mode,\r\nvif->prwise_crypto,\r\nvif->prwise_crypto_len,\r\nvif->grp_crypto, vif->grp_crypto_len,\r\nvif->ssid_len, vif->ssid,\r\nvif->req_bssid, vif->ch_hint,\r\nar->connect_ctrl_flags, nw_subtype);\r\nif (sme->bg_scan_period == 0) {\r\nsme->bg_scan_period = 0xffff;\r\n} else if (sme->bg_scan_period == -1) {\r\nsme->bg_scan_period = DEFAULT_BG_SCAN_PERIOD;\r\n}\r\nath6kl_wmi_scanparams_cmd(ar->wmi, vif->fw_vif_idx, 0, 0,\r\nsme->bg_scan_period, 0, 0, 0, 3, 0, 0, 0);\r\nup(&ar->sem);\r\nif (status == -EINVAL) {\r\nmemset(vif->ssid, 0, sizeof(vif->ssid));\r\nvif->ssid_len = 0;\r\nath6kl_err("invalid request\n");\r\nreturn -ENOENT;\r\n} else if (status) {\r\nath6kl_err("ath6kl_wmi_connect_cmd failed\n");\r\nreturn -EIO;\r\n}\r\nif ((!(ar->connect_ctrl_flags & CONNECT_DO_WPA_OFFLOAD)) &&\r\n((vif->auth_mode == WPA_PSK_AUTH) ||\r\n(vif->auth_mode == WPA2_PSK_AUTH))) {\r\nmod_timer(&vif->disconnect_timer,\r\njiffies + msecs_to_jiffies(DISCON_TIMER_INTVAL));\r\n}\r\nar->connect_ctrl_flags &= ~CONNECT_DO_WPA_OFFLOAD;\r\nset_bit(CONNECT_PEND, &vif->flags);\r\nreturn 0;\r\n}\r\nstatic struct cfg80211_bss *\r\nath6kl_add_bss_if_needed(struct ath6kl_vif *vif,\r\nenum network_type nw_type,\r\nconst u8 *bssid,\r\nstruct ieee80211_channel *chan,\r\nconst u8 *beacon_ie,\r\nsize_t beacon_ie_len)\r\n{\r\nstruct ath6kl *ar = vif->ar;\r\nstruct cfg80211_bss *bss;\r\nu16 cap_val;\r\nenum ieee80211_bss_type bss_type;\r\nu8 *ie;\r\nif (nw_type & ADHOC_NETWORK) {\r\ncap_val = WLAN_CAPABILITY_IBSS;\r\nbss_type = IEEE80211_BSS_TYPE_IBSS;\r\n} else {\r\ncap_val = WLAN_CAPABILITY_ESS;\r\nbss_type = IEEE80211_BSS_TYPE_ESS;\r\n}\r\nbss = cfg80211_get_bss(ar->wiphy, chan, bssid,\r\nvif->ssid, vif->ssid_len,\r\nbss_type, IEEE80211_PRIVACY_ANY);\r\nif (bss == NULL) {\r\nie = kmalloc(2 + vif->ssid_len + beacon_ie_len, GFP_KERNEL);\r\nif (ie == NULL)\r\nreturn NULL;\r\nie[0] = WLAN_EID_SSID;\r\nie[1] = vif->ssid_len;\r\nmemcpy(ie + 2, vif->ssid, vif->ssid_len);\r\nmemcpy(ie + 2 + vif->ssid_len, beacon_ie, beacon_ie_len);\r\nbss = cfg80211_inform_bss(ar->wiphy, chan,\r\nCFG80211_BSS_FTYPE_UNKNOWN,\r\nbssid, 0, cap_val, 100,\r\nie, 2 + vif->ssid_len + beacon_ie_len,\r\n0, GFP_KERNEL);\r\nif (bss)\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"added bss %pM to cfg80211\n", bssid);\r\nkfree(ie);\r\n} else {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "cfg80211 already has a bss\n");\r\n}\r\nreturn bss;\r\n}\r\nvoid ath6kl_cfg80211_connect_event(struct ath6kl_vif *vif, u16 channel,\r\nu8 *bssid, u16 listen_intvl,\r\nu16 beacon_intvl,\r\nenum network_type nw_type,\r\nu8 beacon_ie_len, u8 assoc_req_len,\r\nu8 assoc_resp_len, u8 *assoc_info)\r\n{\r\nstruct ieee80211_channel *chan;\r\nstruct ath6kl *ar = vif->ar;\r\nstruct cfg80211_bss *bss;\r\nu8 assoc_req_ie_offset = sizeof(u16) + sizeof(u16);\r\nu8 assoc_resp_ie_offset = sizeof(u16) + sizeof(u16) + sizeof(u16);\r\nu8 *assoc_req_ie = assoc_info + beacon_ie_len + assoc_req_ie_offset;\r\nu8 *assoc_resp_ie = assoc_info + beacon_ie_len + assoc_req_len +\r\nassoc_resp_ie_offset;\r\nassoc_req_len -= assoc_req_ie_offset;\r\nassoc_resp_len -= assoc_resp_ie_offset;\r\nvif->assoc_bss_beacon_int = beacon_intvl;\r\nclear_bit(DTIM_PERIOD_AVAIL, &vif->flags);\r\nif (nw_type & ADHOC_NETWORK) {\r\nif (vif->wdev.iftype != NL80211_IFTYPE_ADHOC) {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"%s: ath6k not in ibss mode\n", __func__);\r\nreturn;\r\n}\r\n}\r\nif (nw_type & INFRA_NETWORK) {\r\nif (vif->wdev.iftype != NL80211_IFTYPE_STATION &&\r\nvif->wdev.iftype != NL80211_IFTYPE_P2P_CLIENT) {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"%s: ath6k not in station mode\n", __func__);\r\nreturn;\r\n}\r\n}\r\nchan = ieee80211_get_channel(ar->wiphy, (int) channel);\r\nbss = ath6kl_add_bss_if_needed(vif, nw_type, bssid, chan,\r\nassoc_info, beacon_ie_len);\r\nif (!bss) {\r\nath6kl_err("could not add cfg80211 bss entry\n");\r\nreturn;\r\n}\r\nif (nw_type & ADHOC_NETWORK) {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "ad-hoc %s selected\n",\r\nnw_type & ADHOC_CREATOR ? "creator" : "joiner");\r\ncfg80211_ibss_joined(vif->ndev, bssid, chan, GFP_KERNEL);\r\ncfg80211_put_bss(ar->wiphy, bss);\r\nreturn;\r\n}\r\nif (vif->sme_state == SME_CONNECTING) {\r\nvif->sme_state = SME_CONNECTED;\r\ncfg80211_connect_result(vif->ndev, bssid,\r\nassoc_req_ie, assoc_req_len,\r\nassoc_resp_ie, assoc_resp_len,\r\nWLAN_STATUS_SUCCESS, GFP_KERNEL);\r\ncfg80211_put_bss(ar->wiphy, bss);\r\n} else if (vif->sme_state == SME_CONNECTED) {\r\nstruct cfg80211_roam_info roam_info = {\r\n.bss = bss,\r\n.req_ie = assoc_req_ie,\r\n.req_ie_len = assoc_req_len,\r\n.resp_ie = assoc_resp_ie,\r\n.resp_ie_len = assoc_resp_len,\r\n};\r\ncfg80211_roamed(vif->ndev, &roam_info, GFP_KERNEL);\r\n}\r\n}\r\nstatic int ath6kl_cfg80211_disconnect(struct wiphy *wiphy,\r\nstruct net_device *dev, u16 reason_code)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(dev);\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: reason=%u\n", __func__,\r\nreason_code);\r\nath6kl_cfg80211_sscan_disable(vif);\r\nif (!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nif (test_bit(DESTROY_IN_PROGRESS, &ar->flag)) {\r\nath6kl_err("busy, destroy in progress\n");\r\nreturn -EBUSY;\r\n}\r\nif (down_interruptible(&ar->sem)) {\r\nath6kl_err("busy, couldn't get access\n");\r\nreturn -ERESTARTSYS;\r\n}\r\nvif->reconnect_flag = 0;\r\nath6kl_disconnect(vif);\r\nmemset(vif->ssid, 0, sizeof(vif->ssid));\r\nvif->ssid_len = 0;\r\nif (!test_bit(SKIP_SCAN, &ar->flag))\r\nmemset(vif->req_bssid, 0, sizeof(vif->req_bssid));\r\nup(&ar->sem);\r\nreturn 0;\r\n}\r\nvoid ath6kl_cfg80211_disconnect_event(struct ath6kl_vif *vif, u8 reason,\r\nu8 *bssid, u8 assoc_resp_len,\r\nu8 *assoc_info, u16 proto_reason)\r\n{\r\nstruct ath6kl *ar = vif->ar;\r\nif (vif->scan_req) {\r\nstruct cfg80211_scan_info info = {\r\n.aborted = true,\r\n};\r\ncfg80211_scan_done(vif->scan_req, &info);\r\nvif->scan_req = NULL;\r\n}\r\nif (vif->nw_type & ADHOC_NETWORK) {\r\nif (vif->wdev.iftype != NL80211_IFTYPE_ADHOC)\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"%s: ath6k not in ibss mode\n", __func__);\r\nreturn;\r\n}\r\nif (vif->nw_type & INFRA_NETWORK) {\r\nif (vif->wdev.iftype != NL80211_IFTYPE_STATION &&\r\nvif->wdev.iftype != NL80211_IFTYPE_P2P_CLIENT) {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"%s: ath6k not in station mode\n", __func__);\r\nreturn;\r\n}\r\n}\r\nclear_bit(CONNECT_PEND, &vif->flags);\r\nif (vif->sme_state == SME_CONNECTING) {\r\ncfg80211_connect_result(vif->ndev,\r\nbssid, NULL, 0,\r\nNULL, 0,\r\nWLAN_STATUS_UNSPECIFIED_FAILURE,\r\nGFP_KERNEL);\r\n} else if (vif->sme_state == SME_CONNECTED) {\r\ncfg80211_disconnected(vif->ndev, proto_reason,\r\nNULL, 0, false, GFP_KERNEL);\r\n}\r\nvif->sme_state = SME_DISCONNECTED;\r\nif (reason != DISCONNECT_CMD)\r\nath6kl_wmi_disconnect_cmd(ar->wmi, vif->fw_vif_idx);\r\n}\r\nstatic int ath6kl_set_probed_ssids(struct ath6kl *ar,\r\nstruct ath6kl_vif *vif,\r\nstruct cfg80211_ssid *ssids, int n_ssids,\r\nstruct cfg80211_match_set *match_set,\r\nint n_match_ssid)\r\n{\r\nu8 i, j, index_to_add, ssid_found = false;\r\nstruct ath6kl_cfg80211_match_probe_ssid ssid_list[MAX_PROBED_SSIDS];\r\nmemset(ssid_list, 0, sizeof(ssid_list));\r\nif (n_ssids > MAX_PROBED_SSIDS ||\r\nn_match_ssid > MAX_PROBED_SSIDS)\r\nreturn -EINVAL;\r\nfor (i = 0; i < n_ssids; i++) {\r\nmemcpy(ssid_list[i].ssid.ssid,\r\nssids[i].ssid,\r\nssids[i].ssid_len);\r\nssid_list[i].ssid.ssid_len = ssids[i].ssid_len;\r\nif (ssids[i].ssid_len)\r\nssid_list[i].flag = SPECIFIC_SSID_FLAG;\r\nelse\r\nssid_list[i].flag = ANY_SSID_FLAG;\r\nif (n_match_ssid == 0)\r\nssid_list[i].flag |= MATCH_SSID_FLAG;\r\n}\r\nindex_to_add = i;\r\nfor (i = 0; i < n_match_ssid; i++) {\r\nssid_found = false;\r\nfor (j = 0; j < n_ssids; j++) {\r\nif ((match_set[i].ssid.ssid_len ==\r\nssid_list[j].ssid.ssid_len) &&\r\n(!memcmp(ssid_list[j].ssid.ssid,\r\nmatch_set[i].ssid.ssid,\r\nmatch_set[i].ssid.ssid_len))) {\r\nssid_list[j].flag |= MATCH_SSID_FLAG;\r\nssid_found = true;\r\nbreak;\r\n}\r\n}\r\nif (ssid_found)\r\ncontinue;\r\nif (index_to_add >= MAX_PROBED_SSIDS)\r\ncontinue;\r\nssid_list[index_to_add].ssid.ssid_len =\r\nmatch_set[i].ssid.ssid_len;\r\nmemcpy(ssid_list[index_to_add].ssid.ssid,\r\nmatch_set[i].ssid.ssid,\r\nmatch_set[i].ssid.ssid_len);\r\nssid_list[index_to_add].flag |= MATCH_SSID_FLAG;\r\nindex_to_add++;\r\n}\r\nfor (i = 0; i < index_to_add; i++) {\r\nath6kl_wmi_probedssid_cmd(ar->wmi, vif->fw_vif_idx, i,\r\nssid_list[i].flag,\r\nssid_list[i].ssid.ssid_len,\r\nssid_list[i].ssid.ssid);\r\n}\r\nfor (i = index_to_add; i < MAX_PROBED_SSIDS; i++) {\r\nath6kl_wmi_probedssid_cmd(ar->wmi, vif->fw_vif_idx, i,\r\nDISABLE_SSID_FLAG, 0, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ath6kl_cfg80211_scan(struct wiphy *wiphy,\r\nstruct cfg80211_scan_request *request)\r\n{\r\nstruct ath6kl_vif *vif = ath6kl_vif_from_wdev(request->wdev);\r\nstruct ath6kl *ar = ath6kl_priv(vif->ndev);\r\ns8 n_channels = 0;\r\nu16 *channels = NULL;\r\nint ret = 0;\r\nu32 force_fg_scan = 0;\r\nif (!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nath6kl_cfg80211_sscan_disable(vif);\r\nif (!ar->usr_bss_filter) {\r\nclear_bit(CLEAR_BSSFILTER_ON_BEACON, &vif->flags);\r\nret = ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,\r\nALL_BSS_FILTER, 0);\r\nif (ret) {\r\nath6kl_err("couldn't set bss filtering\n");\r\nreturn ret;\r\n}\r\n}\r\nret = ath6kl_set_probed_ssids(ar, vif, request->ssids,\r\nrequest->n_ssids, NULL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,\r\nWMI_FRAME_PROBE_REQ,\r\nrequest->ie, request->ie_len);\r\nif (ret) {\r\nath6kl_err("failed to set Probe Request appie for scan\n");\r\nreturn ret;\r\n}\r\nif (request->n_channels > 0 &&\r\nrequest->n_channels <= WMI_MAX_CHANNELS) {\r\nu8 i;\r\nn_channels = request->n_channels;\r\nchannels = kzalloc(n_channels * sizeof(u16), GFP_KERNEL);\r\nif (channels == NULL) {\r\nath6kl_warn("failed to set scan channels, scan all channels");\r\nn_channels = 0;\r\n}\r\nfor (i = 0; i < n_channels; i++)\r\nchannels[i] = request->channels[i]->center_freq;\r\n}\r\nif (test_bit(CONNECTED, &vif->flags))\r\nforce_fg_scan = 1;\r\nvif->scan_req = request;\r\nret = ath6kl_wmi_beginscan_cmd(ar->wmi, vif->fw_vif_idx,\r\nWMI_LONG_SCAN, force_fg_scan,\r\nfalse, 0,\r\nATH6KL_FG_SCAN_INTERVAL,\r\nn_channels, channels,\r\nrequest->no_cck,\r\nrequest->rates);\r\nif (ret) {\r\nath6kl_err("failed to start scan: %d\n", ret);\r\nvif->scan_req = NULL;\r\n}\r\nkfree(channels);\r\nreturn ret;\r\n}\r\nvoid ath6kl_cfg80211_scan_complete_event(struct ath6kl_vif *vif, bool aborted)\r\n{\r\nstruct ath6kl *ar = vif->ar;\r\nstruct cfg80211_scan_info info = {\r\n.aborted = aborted,\r\n};\r\nint i;\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: status%s\n", __func__,\r\naborted ? " aborted" : "");\r\nif (!vif->scan_req)\r\nreturn;\r\nif (aborted)\r\ngoto out;\r\nif (vif->scan_req->n_ssids && vif->scan_req->ssids[0].ssid_len) {\r\nfor (i = 0; i < vif->scan_req->n_ssids; i++) {\r\nath6kl_wmi_probedssid_cmd(ar->wmi, vif->fw_vif_idx,\r\ni + 1, DISABLE_SSID_FLAG,\r\n0, NULL);\r\n}\r\n}\r\nout:\r\ncfg80211_scan_done(vif->scan_req, &info);\r\nvif->scan_req = NULL;\r\n}\r\nvoid ath6kl_cfg80211_ch_switch_notify(struct ath6kl_vif *vif, int freq,\r\nenum wmi_phy_mode mode)\r\n{\r\nstruct cfg80211_chan_def chandef;\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"channel switch notify nw_type %d freq %d mode %d\n",\r\nvif->nw_type, freq, mode);\r\ncfg80211_chandef_create(&chandef,\r\nieee80211_get_channel(vif->ar->wiphy, freq),\r\n(mode == WMI_11G_HT20 &&\r\nath6kl_band_2ghz.ht_cap.ht_supported) ?\r\nNL80211_CHAN_HT20 : NL80211_CHAN_NO_HT);\r\nmutex_lock(&vif->wdev.mtx);\r\ncfg80211_ch_switch_notify(vif->ndev, &chandef);\r\nmutex_unlock(&vif->wdev.mtx);\r\n}\r\nstatic int ath6kl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_index, bool pairwise,\r\nconst u8 *mac_addr,\r\nstruct key_params *params)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(ndev);\r\nstruct ath6kl_vif *vif = netdev_priv(ndev);\r\nstruct ath6kl_key *key = NULL;\r\nint seq_len;\r\nu8 key_usage;\r\nu8 key_type;\r\nif (!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nif (params->cipher == CCKM_KRK_CIPHER_SUITE) {\r\nif (params->key_len != WMI_KRK_LEN)\r\nreturn -EINVAL;\r\nreturn ath6kl_wmi_add_krk_cmd(ar->wmi, vif->fw_vif_idx,\r\nparams->key);\r\n}\r\nif (key_index > WMI_MAX_KEY_INDEX) {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"%s: key index %d out of bounds\n", __func__,\r\nkey_index);\r\nreturn -ENOENT;\r\n}\r\nkey = &vif->keys[key_index];\r\nmemset(key, 0, sizeof(struct ath6kl_key));\r\nif (pairwise)\r\nkey_usage = PAIRWISE_USAGE;\r\nelse\r\nkey_usage = GROUP_USAGE;\r\nseq_len = params->seq_len;\r\nif (params->cipher == WLAN_CIPHER_SUITE_SMS4 &&\r\nseq_len > ATH6KL_KEY_SEQ_LEN) {\r\nseq_len = ATH6KL_KEY_SEQ_LEN;\r\n}\r\nif (params->key_len > WLAN_MAX_KEY_LEN ||\r\nseq_len > sizeof(key->seq))\r\nreturn -EINVAL;\r\nkey->key_len = params->key_len;\r\nmemcpy(key->key, params->key, key->key_len);\r\nkey->seq_len = seq_len;\r\nmemcpy(key->seq, params->seq, key->seq_len);\r\nkey->cipher = params->cipher;\r\nswitch (key->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nkey_type = WEP_CRYPT;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nkey_type = TKIP_CRYPT;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nkey_type = AES_CRYPT;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_SMS4:\r\nkey_type = WAPI_CRYPT;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nif (((vif->auth_mode == WPA_PSK_AUTH) ||\r\n(vif->auth_mode == WPA2_PSK_AUTH)) &&\r\n(key_usage & GROUP_USAGE))\r\ndel_timer(&vif->disconnect_timer);\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"%s: index %d, key_len %d, key_type 0x%x, key_usage 0x%x, seq_len %d\n",\r\n__func__, key_index, key->key_len, key_type,\r\nkey_usage, key->seq_len);\r\nif (vif->nw_type == AP_NETWORK && !pairwise &&\r\n(key_type == TKIP_CRYPT || key_type == AES_CRYPT ||\r\nkey_type == WAPI_CRYPT)) {\r\nar->ap_mode_bkey.valid = true;\r\nar->ap_mode_bkey.key_index = key_index;\r\nar->ap_mode_bkey.key_type = key_type;\r\nar->ap_mode_bkey.key_len = key->key_len;\r\nmemcpy(ar->ap_mode_bkey.key, key->key, key->key_len);\r\nif (!test_bit(CONNECTED, &vif->flags)) {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"Delay initial group key configuration until AP mode has been started\n");\r\nreturn 0;\r\n}\r\n}\r\nif (vif->next_mode == AP_NETWORK && key_type == WEP_CRYPT &&\r\n!test_bit(CONNECTED, &vif->flags)) {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"Delay WEP key configuration until AP mode has been started\n");\r\nvif->wep_key_list[key_index].key_len = key->key_len;\r\nmemcpy(vif->wep_key_list[key_index].key, key->key,\r\nkey->key_len);\r\nreturn 0;\r\n}\r\nreturn ath6kl_wmi_addkey_cmd(ar->wmi, vif->fw_vif_idx, key_index,\r\nkey_type, key_usage, key->key_len,\r\nkey->seq, key->seq_len, key->key,\r\nKEY_OP_INIT_VAL,\r\n(u8 *) mac_addr, SYNC_BOTH_WMIFLAG);\r\n}\r\nstatic int ath6kl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_index, bool pairwise,\r\nconst u8 *mac_addr)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(ndev);\r\nstruct ath6kl_vif *vif = netdev_priv(ndev);\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: index %d\n", __func__, key_index);\r\nif (!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nif (key_index > WMI_MAX_KEY_INDEX) {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"%s: key index %d out of bounds\n", __func__,\r\nkey_index);\r\nreturn -ENOENT;\r\n}\r\nif (!vif->keys[key_index].key_len) {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"%s: index %d is empty\n", __func__, key_index);\r\nreturn 0;\r\n}\r\nvif->keys[key_index].key_len = 0;\r\nreturn ath6kl_wmi_deletekey_cmd(ar->wmi, vif->fw_vif_idx, key_index);\r\n}\r\nstatic int ath6kl_cfg80211_get_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_index, bool pairwise,\r\nconst u8 *mac_addr, void *cookie,\r\nvoid (*callback) (void *cookie,\r\nstruct key_params *))\r\n{\r\nstruct ath6kl_vif *vif = netdev_priv(ndev);\r\nstruct ath6kl_key *key = NULL;\r\nstruct key_params params;\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: index %d\n", __func__, key_index);\r\nif (!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nif (key_index > WMI_MAX_KEY_INDEX) {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"%s: key index %d out of bounds\n", __func__,\r\nkey_index);\r\nreturn -ENOENT;\r\n}\r\nkey = &vif->keys[key_index];\r\nmemset(&params, 0, sizeof(params));\r\nparams.cipher = key->cipher;\r\nparams.key_len = key->key_len;\r\nparams.seq_len = key->seq_len;\r\nparams.seq = key->seq;\r\nparams.key = key->key;\r\ncallback(cookie, &params);\r\nreturn key->key_len ? 0 : -ENOENT;\r\n}\r\nstatic int ath6kl_cfg80211_set_default_key(struct wiphy *wiphy,\r\nstruct net_device *ndev,\r\nu8 key_index, bool unicast,\r\nbool multicast)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(ndev);\r\nstruct ath6kl_vif *vif = netdev_priv(ndev);\r\nstruct ath6kl_key *key = NULL;\r\nu8 key_usage;\r\nenum crypto_type key_type = NONE_CRYPT;\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: index %d\n", __func__, key_index);\r\nif (!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nif (key_index > WMI_MAX_KEY_INDEX) {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"%s: key index %d out of bounds\n",\r\n__func__, key_index);\r\nreturn -ENOENT;\r\n}\r\nif (!vif->keys[key_index].key_len) {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: invalid key index %d\n",\r\n__func__, key_index);\r\nreturn -EINVAL;\r\n}\r\nvif->def_txkey_index = key_index;\r\nkey = &vif->keys[vif->def_txkey_index];\r\nkey_usage = GROUP_USAGE;\r\nif (vif->prwise_crypto == WEP_CRYPT)\r\nkey_usage |= TX_USAGE;\r\nif (unicast)\r\nkey_type = vif->prwise_crypto;\r\nif (multicast)\r\nkey_type = vif->grp_crypto;\r\nif (vif->next_mode == AP_NETWORK && !test_bit(CONNECTED, &vif->flags))\r\nreturn 0;\r\nreturn ath6kl_wmi_addkey_cmd(ar->wmi, vif->fw_vif_idx,\r\nvif->def_txkey_index,\r\nkey_type, key_usage,\r\nkey->key_len, key->seq, key->seq_len,\r\nkey->key,\r\nKEY_OP_INIT_VAL, NULL,\r\nSYNC_BOTH_WMIFLAG);\r\n}\r\nvoid ath6kl_cfg80211_tkip_micerr_event(struct ath6kl_vif *vif, u8 keyid,\r\nbool ismcast)\r\n{\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"%s: keyid %d, ismcast %d\n", __func__, keyid, ismcast);\r\ncfg80211_michael_mic_failure(vif->ndev, vif->bssid,\r\n(ismcast ? NL80211_KEYTYPE_GROUP :\r\nNL80211_KEYTYPE_PAIRWISE), keyid, NULL,\r\nGFP_KERNEL);\r\n}\r\nstatic int ath6kl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)\r\n{\r\nstruct ath6kl *ar = (struct ath6kl *)wiphy_priv(wiphy);\r\nstruct ath6kl_vif *vif;\r\nint ret;\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: changed 0x%x\n", __func__,\r\nchanged);\r\nvif = ath6kl_vif_first(ar);\r\nif (!vif)\r\nreturn -EIO;\r\nif (!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nif (changed & WIPHY_PARAM_RTS_THRESHOLD) {\r\nret = ath6kl_wmi_set_rts_cmd(ar->wmi, wiphy->rts_threshold);\r\nif (ret != 0) {\r\nath6kl_err("ath6kl_wmi_set_rts_cmd failed\n");\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ath6kl_cfg80211_set_txpower(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nenum nl80211_tx_power_setting type,\r\nint mbm)\r\n{\r\nstruct ath6kl *ar = (struct ath6kl *)wiphy_priv(wiphy);\r\nstruct ath6kl_vif *vif;\r\nint dbm = MBM_TO_DBM(mbm);\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: type 0x%x, dbm %d\n", __func__,\r\ntype, dbm);\r\nvif = ath6kl_vif_first(ar);\r\nif (!vif)\r\nreturn -EIO;\r\nif (!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nswitch (type) {\r\ncase NL80211_TX_POWER_AUTOMATIC:\r\nreturn 0;\r\ncase NL80211_TX_POWER_LIMITED:\r\nar->tx_pwr = dbm;\r\nbreak;\r\ndefault:\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: type 0x%x not supported\n",\r\n__func__, type);\r\nreturn -EOPNOTSUPP;\r\n}\r\nath6kl_wmi_set_tx_pwr_cmd(ar->wmi, vif->fw_vif_idx, dbm);\r\nreturn 0;\r\n}\r\nstatic int ath6kl_cfg80211_get_txpower(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nint *dbm)\r\n{\r\nstruct ath6kl *ar = (struct ath6kl *)wiphy_priv(wiphy);\r\nstruct ath6kl_vif *vif;\r\nvif = ath6kl_vif_first(ar);\r\nif (!vif)\r\nreturn -EIO;\r\nif (!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nif (test_bit(CONNECTED, &vif->flags)) {\r\nar->tx_pwr = 255;\r\nif (ath6kl_wmi_get_tx_pwr_cmd(ar->wmi, vif->fw_vif_idx) != 0) {\r\nath6kl_err("ath6kl_wmi_get_tx_pwr_cmd failed\n");\r\nreturn -EIO;\r\n}\r\nwait_event_interruptible_timeout(ar->event_wq, ar->tx_pwr != 255,\r\n5 * HZ);\r\nif (signal_pending(current)) {\r\nath6kl_err("target did not respond\n");\r\nreturn -EINTR;\r\n}\r\n}\r\n*dbm = ar->tx_pwr;\r\nreturn 0;\r\n}\r\nstatic int ath6kl_cfg80211_set_power_mgmt(struct wiphy *wiphy,\r\nstruct net_device *dev,\r\nbool pmgmt, int timeout)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(dev);\r\nstruct wmi_power_mode_cmd mode;\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: pmgmt %d, timeout %d\n",\r\n__func__, pmgmt, timeout);\r\nif (!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nif (pmgmt) {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: rec power\n", __func__);\r\nmode.pwr_mode = REC_POWER;\r\n} else {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: max perf\n", __func__);\r\nmode.pwr_mode = MAX_PERF_POWER;\r\n}\r\nif (ath6kl_wmi_powermode_cmd(ar->wmi, vif->fw_vif_idx,\r\nmode.pwr_mode) != 0) {\r\nath6kl_err("wmi_powermode_cmd failed\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct wireless_dev *ath6kl_cfg80211_add_iface(struct wiphy *wiphy,\r\nconst char *name,\r\nunsigned char name_assign_type,\r\nenum nl80211_iftype type,\r\nstruct vif_params *params)\r\n{\r\nstruct ath6kl *ar = wiphy_priv(wiphy);\r\nstruct wireless_dev *wdev;\r\nu8 if_idx, nw_type;\r\nif (ar->num_vif == ar->vif_max) {\r\nath6kl_err("Reached maximum number of supported vif\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!ath6kl_is_valid_iftype(ar, type, &if_idx, &nw_type)) {\r\nath6kl_err("Not a supported interface type\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nwdev = ath6kl_interface_add(ar, name, name_assign_type, type, if_idx, nw_type);\r\nif (!wdev)\r\nreturn ERR_PTR(-ENOMEM);\r\nar->num_vif++;\r\nreturn wdev;\r\n}\r\nstatic int ath6kl_cfg80211_del_iface(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev)\r\n{\r\nstruct ath6kl *ar = wiphy_priv(wiphy);\r\nstruct ath6kl_vif *vif = netdev_priv(wdev->netdev);\r\nspin_lock_bh(&ar->list_lock);\r\nlist_del(&vif->list);\r\nspin_unlock_bh(&ar->list_lock);\r\nath6kl_cfg80211_vif_stop(vif, test_bit(WMI_READY, &ar->flag));\r\nrtnl_lock();\r\nath6kl_cfg80211_vif_cleanup(vif);\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nstatic int ath6kl_cfg80211_change_iface(struct wiphy *wiphy,\r\nstruct net_device *ndev,\r\nenum nl80211_iftype type,\r\nstruct vif_params *params)\r\n{\r\nstruct ath6kl_vif *vif = netdev_priv(ndev);\r\nint i;\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: type %u\n", __func__, type);\r\nif (!test_bit(ATH6KL_FW_CAPABILITY_STA_P2PDEV_DUPLEX,\r\nvif->ar->fw_capabilities) &&\r\n(type == NL80211_IFTYPE_P2P_CLIENT ||\r\ntype == NL80211_IFTYPE_P2P_GO)) {\r\nif (vif->ar->vif_max == 1) {\r\nif (vif->fw_vif_idx != 0)\r\nreturn -EINVAL;\r\nelse\r\ngoto set_iface_type;\r\n}\r\nfor (i = vif->ar->max_norm_iface; i < vif->ar->vif_max; i++) {\r\nif (i == vif->fw_vif_idx)\r\nbreak;\r\n}\r\nif (i == vif->ar->vif_max) {\r\nath6kl_err("Invalid interface to bring up P2P\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nath6kl_cfg80211_sta_bmiss_enhance(vif, false);\r\nset_iface_type:\r\nswitch (type) {\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\nvif->next_mode = INFRA_NETWORK;\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nvif->next_mode = ADHOC_NETWORK;\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_P2P_GO:\r\nvif->next_mode = AP_NETWORK;\r\nbreak;\r\ndefault:\r\nath6kl_err("invalid interface type %u\n", type);\r\nreturn -EOPNOTSUPP;\r\n}\r\nvif->wdev.iftype = type;\r\nreturn 0;\r\n}\r\nstatic int ath6kl_cfg80211_join_ibss(struct wiphy *wiphy,\r\nstruct net_device *dev,\r\nstruct cfg80211_ibss_params *ibss_param)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(dev);\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nint status;\r\nif (!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nvif->ssid_len = ibss_param->ssid_len;\r\nmemcpy(vif->ssid, ibss_param->ssid, vif->ssid_len);\r\nif (ibss_param->chandef.chan)\r\nvif->ch_hint = ibss_param->chandef.chan->center_freq;\r\nif (ibss_param->channel_fixed) {\r\nreturn -EOPNOTSUPP;\r\n}\r\nmemset(vif->req_bssid, 0, sizeof(vif->req_bssid));\r\nif (ibss_param->bssid && !is_broadcast_ether_addr(ibss_param->bssid))\r\nmemcpy(vif->req_bssid, ibss_param->bssid,\r\nsizeof(vif->req_bssid));\r\nath6kl_set_wpa_version(vif, 0);\r\nstatus = ath6kl_set_auth_type(vif, NL80211_AUTHTYPE_OPEN_SYSTEM);\r\nif (status)\r\nreturn status;\r\nif (ibss_param->privacy) {\r\nath6kl_set_cipher(vif, WLAN_CIPHER_SUITE_WEP40, true);\r\nath6kl_set_cipher(vif, WLAN_CIPHER_SUITE_WEP40, false);\r\n} else {\r\nath6kl_set_cipher(vif, 0, true);\r\nath6kl_set_cipher(vif, 0, false);\r\n}\r\nvif->nw_type = vif->next_mode;\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"%s: connect called with authmode %d dot11 auth %d"\r\n" PW crypto %d PW crypto len %d GRP crypto %d"\r\n" GRP crypto len %d channel hint %u\n",\r\n__func__,\r\nvif->auth_mode, vif->dot11_auth_mode, vif->prwise_crypto,\r\nvif->prwise_crypto_len, vif->grp_crypto,\r\nvif->grp_crypto_len, vif->ch_hint);\r\nstatus = ath6kl_wmi_connect_cmd(ar->wmi, vif->fw_vif_idx, vif->nw_type,\r\nvif->dot11_auth_mode, vif->auth_mode,\r\nvif->prwise_crypto,\r\nvif->prwise_crypto_len,\r\nvif->grp_crypto, vif->grp_crypto_len,\r\nvif->ssid_len, vif->ssid,\r\nvif->req_bssid, vif->ch_hint,\r\nar->connect_ctrl_flags, SUBTYPE_NONE);\r\nset_bit(CONNECT_PEND, &vif->flags);\r\nreturn 0;\r\n}\r\nstatic int ath6kl_cfg80211_leave_ibss(struct wiphy *wiphy,\r\nstruct net_device *dev)\r\n{\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nif (!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nath6kl_disconnect(vif);\r\nmemset(vif->ssid, 0, sizeof(vif->ssid));\r\nvif->ssid_len = 0;\r\nreturn 0;\r\n}\r\nstatic bool is_rate_legacy(s32 rate)\r\n{\r\nstatic const s32 legacy[] = { 1000, 2000, 5500, 11000,\r\n6000, 9000, 12000, 18000, 24000,\r\n36000, 48000, 54000\r\n};\r\nu8 i;\r\nfor (i = 0; i < ARRAY_SIZE(legacy); i++)\r\nif (rate == legacy[i])\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool is_rate_ht20(s32 rate, u8 *mcs, bool *sgi)\r\n{\r\nstatic const s32 ht20[] = { 6500, 13000, 19500, 26000, 39000,\r\n52000, 58500, 65000, 72200\r\n};\r\nu8 i;\r\nfor (i = 0; i < ARRAY_SIZE(ht20); i++) {\r\nif (rate == ht20[i]) {\r\nif (i == ARRAY_SIZE(ht20) - 1)\r\n*sgi = true;\r\nelse\r\n*sgi = false;\r\n*mcs = i;\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic bool is_rate_ht40(s32 rate, u8 *mcs, bool *sgi)\r\n{\r\nstatic const s32 ht40[] = { 13500, 27000, 40500, 54000,\r\n81000, 108000, 121500, 135000,\r\n150000\r\n};\r\nu8 i;\r\nfor (i = 0; i < ARRAY_SIZE(ht40); i++) {\r\nif (rate == ht40[i]) {\r\nif (i == ARRAY_SIZE(ht40) - 1)\r\n*sgi = true;\r\nelse\r\n*sgi = false;\r\n*mcs = i;\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic int ath6kl_get_station(struct wiphy *wiphy, struct net_device *dev,\r\nconst u8 *mac, struct station_info *sinfo)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(dev);\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nlong left;\r\nbool sgi;\r\ns32 rate;\r\nint ret;\r\nu8 mcs;\r\nif (memcmp(mac, vif->bssid, ETH_ALEN) != 0)\r\nreturn -ENOENT;\r\nif (down_interruptible(&ar->sem))\r\nreturn -EBUSY;\r\nset_bit(STATS_UPDATE_PEND, &vif->flags);\r\nret = ath6kl_wmi_get_stats_cmd(ar->wmi, vif->fw_vif_idx);\r\nif (ret != 0) {\r\nup(&ar->sem);\r\nreturn -EIO;\r\n}\r\nleft = wait_event_interruptible_timeout(ar->event_wq,\r\n!test_bit(STATS_UPDATE_PEND,\r\n&vif->flags),\r\nWMI_TIMEOUT);\r\nup(&ar->sem);\r\nif (left == 0)\r\nreturn -ETIMEDOUT;\r\nelse if (left < 0)\r\nreturn left;\r\nif (vif->target_stats.rx_byte) {\r\nsinfo->rx_bytes = vif->target_stats.rx_byte;\r\nsinfo->filled |= BIT(NL80211_STA_INFO_RX_BYTES64);\r\nsinfo->rx_packets = vif->target_stats.rx_pkt;\r\nsinfo->filled |= BIT(NL80211_STA_INFO_RX_PACKETS);\r\n}\r\nif (vif->target_stats.tx_byte) {\r\nsinfo->tx_bytes = vif->target_stats.tx_byte;\r\nsinfo->filled |= BIT(NL80211_STA_INFO_TX_BYTES64);\r\nsinfo->tx_packets = vif->target_stats.tx_pkt;\r\nsinfo->filled |= BIT(NL80211_STA_INFO_TX_PACKETS);\r\n}\r\nsinfo->signal = vif->target_stats.cs_rssi;\r\nsinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);\r\nrate = vif->target_stats.tx_ucast_rate;\r\nif (is_rate_legacy(rate)) {\r\nsinfo->txrate.legacy = rate / 100;\r\n} else if (is_rate_ht20(rate, &mcs, &sgi)) {\r\nif (sgi) {\r\nsinfo->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;\r\nsinfo->txrate.mcs = mcs - 1;\r\n} else {\r\nsinfo->txrate.mcs = mcs;\r\n}\r\nsinfo->txrate.flags |= RATE_INFO_FLAGS_MCS;\r\nsinfo->txrate.bw = RATE_INFO_BW_20;\r\n} else if (is_rate_ht40(rate, &mcs, &sgi)) {\r\nif (sgi) {\r\nsinfo->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;\r\nsinfo->txrate.mcs = mcs - 1;\r\n} else {\r\nsinfo->txrate.mcs = mcs;\r\n}\r\nsinfo->txrate.bw = RATE_INFO_BW_40;\r\nsinfo->txrate.flags |= RATE_INFO_FLAGS_MCS;\r\n} else {\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"invalid rate from stats: %d\n", rate);\r\nath6kl_debug_war(ar, ATH6KL_WAR_INVALID_RATE);\r\nreturn 0;\r\n}\r\nsinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);\r\nif (test_bit(CONNECTED, &vif->flags) &&\r\ntest_bit(DTIM_PERIOD_AVAIL, &vif->flags) &&\r\nvif->nw_type == INFRA_NETWORK) {\r\nsinfo->filled |= BIT(NL80211_STA_INFO_BSS_PARAM);\r\nsinfo->bss_param.flags = 0;\r\nsinfo->bss_param.dtim_period = vif->assoc_bss_dtim_period;\r\nsinfo->bss_param.beacon_interval = vif->assoc_bss_beacon_int;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ath6kl_set_pmksa(struct wiphy *wiphy, struct net_device *netdev,\r\nstruct cfg80211_pmksa *pmksa)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(netdev);\r\nstruct ath6kl_vif *vif = netdev_priv(netdev);\r\nreturn ath6kl_wmi_setpmkid_cmd(ar->wmi, vif->fw_vif_idx, pmksa->bssid,\r\npmksa->pmkid, true);\r\n}\r\nstatic int ath6kl_del_pmksa(struct wiphy *wiphy, struct net_device *netdev,\r\nstruct cfg80211_pmksa *pmksa)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(netdev);\r\nstruct ath6kl_vif *vif = netdev_priv(netdev);\r\nreturn ath6kl_wmi_setpmkid_cmd(ar->wmi, vif->fw_vif_idx, pmksa->bssid,\r\npmksa->pmkid, false);\r\n}\r\nstatic int ath6kl_flush_pmksa(struct wiphy *wiphy, struct net_device *netdev)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(netdev);\r\nstruct ath6kl_vif *vif = netdev_priv(netdev);\r\nif (test_bit(CONNECTED, &vif->flags))\r\nreturn ath6kl_wmi_setpmkid_cmd(ar->wmi, vif->fw_vif_idx,\r\nvif->bssid, NULL, false);\r\nreturn 0;\r\n}\r\nstatic int ath6kl_wow_usr(struct ath6kl *ar, struct ath6kl_vif *vif,\r\nstruct cfg80211_wowlan *wow, u32 *filter)\r\n{\r\nint ret, pos;\r\nu8 mask[WOW_PATTERN_SIZE];\r\nu16 i;\r\nfor (i = 0; i < wow->n_patterns; i++) {\r\nmemset(&mask, 0, sizeof(mask));\r\nfor (pos = 0; pos < wow->patterns[i].pattern_len; pos++) {\r\nif (wow->patterns[i].mask[pos / 8] & (0x1 << (pos % 8)))\r\nmask[pos] = 0xFF;\r\n}\r\nret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,\r\nvif->fw_vif_idx, WOW_LIST_ID,\r\nwow->patterns[i].pattern_len,\r\n0 ,\r\nwow->patterns[i].pattern, mask);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (wow->disconnect)\r\n*filter |= WOW_FILTER_OPTION_NWK_DISASSOC;\r\nif (wow->magic_pkt)\r\n*filter |= WOW_FILTER_OPTION_MAGIC_PACKET;\r\nif (wow->gtk_rekey_failure)\r\n*filter |= WOW_FILTER_OPTION_GTK_ERROR;\r\nif (wow->eap_identity_req)\r\n*filter |= WOW_FILTER_OPTION_EAP_REQ;\r\nif (wow->four_way_handshake)\r\n*filter |= WOW_FILTER_OPTION_8021X_4WAYHS;\r\nreturn 0;\r\n}\r\nstatic int ath6kl_wow_ap(struct ath6kl *ar, struct ath6kl_vif *vif)\r\n{\r\nstatic const u8 unicst_pattern[] = { 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x08 };\r\nstatic const u8 unicst_mask[] = { 0x01, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x7f };\r\nu8 unicst_offset = 0;\r\nstatic const u8 arp_pattern[] = { 0x08, 0x06 };\r\nstatic const u8 arp_mask[] = { 0xff, 0xff };\r\nu8 arp_offset = 20;\r\nstatic const u8 discvr_pattern[] = { 0xe0, 0x00, 0x00, 0xf8 };\r\nstatic const u8 discvr_mask[] = { 0xf0, 0x00, 0x00, 0xf8 };\r\nu8 discvr_offset = 38;\r\nstatic const u8 dhcp_pattern[] = { 0xff, 0xff, 0xff, 0xff,\r\n0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x43 };\r\nstatic const u8 dhcp_mask[] = { 0xff, 0xff, 0xff, 0xff,\r\n0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0xff, 0xff };\r\nu8 dhcp_offset = 0;\r\nint ret;\r\nret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,\r\nvif->fw_vif_idx, WOW_LIST_ID,\r\nsizeof(unicst_pattern), unicst_offset,\r\nunicst_pattern, unicst_mask);\r\nif (ret) {\r\nath6kl_err("failed to add WOW unicast IP pattern\n");\r\nreturn ret;\r\n}\r\nret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,\r\nvif->fw_vif_idx, WOW_LIST_ID,\r\nsizeof(arp_pattern), arp_offset,\r\narp_pattern, arp_mask);\r\nif (ret) {\r\nath6kl_err("failed to add WOW ARP pattern\n");\r\nreturn ret;\r\n}\r\nret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,\r\nvif->fw_vif_idx, WOW_LIST_ID,\r\nsizeof(discvr_pattern), discvr_offset,\r\ndiscvr_pattern, discvr_mask);\r\nif (ret) {\r\nath6kl_err("failed to add WOW mDNS/SSDP/LLMNR pattern\n");\r\nreturn ret;\r\n}\r\nret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,\r\nvif->fw_vif_idx, WOW_LIST_ID,\r\nsizeof(dhcp_pattern), dhcp_offset,\r\ndhcp_pattern, dhcp_mask);\r\nif (ret) {\r\nath6kl_err("failed to add WOW DHCP broadcast pattern\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ath6kl_wow_sta(struct ath6kl *ar, struct ath6kl_vif *vif)\r\n{\r\nstruct net_device *ndev = vif->ndev;\r\nstatic const u8 discvr_pattern[] = { 0xe0, 0x00, 0x00, 0xf8 };\r\nstatic const u8 discvr_mask[] = { 0xf0, 0x00, 0x00, 0xf8 };\r\nu8 discvr_offset = 38;\r\nu8 mac_mask[ETH_ALEN];\r\nint ret;\r\neth_broadcast_addr(mac_mask);\r\nret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,\r\nvif->fw_vif_idx, WOW_LIST_ID,\r\nETH_ALEN, 0, ndev->dev_addr,\r\nmac_mask);\r\nif (ret) {\r\nath6kl_err("failed to add WOW unicast pattern\n");\r\nreturn ret;\r\n}\r\nif ((ndev->flags & IFF_ALLMULTI) ||\r\n(ndev->flags & IFF_MULTICAST && netdev_mc_count(ndev) > 0)) {\r\nret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,\r\nvif->fw_vif_idx, WOW_LIST_ID,\r\nsizeof(discvr_pattern), discvr_offset,\r\ndiscvr_pattern, discvr_mask);\r\nif (ret) {\r\nath6kl_err("failed to add WOW mDNS/SSDP/LLMNR pattern\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int is_hsleep_mode_procsed(struct ath6kl_vif *vif)\r\n{\r\nreturn test_bit(HOST_SLEEP_MODE_CMD_PROCESSED, &vif->flags);\r\n}\r\nstatic bool is_ctrl_ep_empty(struct ath6kl *ar)\r\n{\r\nreturn !ar->tx_pending[ar->ctrl_ep];\r\n}\r\nstatic int ath6kl_cfg80211_host_sleep(struct ath6kl *ar, struct ath6kl_vif *vif)\r\n{\r\nint ret, left;\r\nclear_bit(HOST_SLEEP_MODE_CMD_PROCESSED, &vif->flags);\r\nret = ath6kl_wmi_set_host_sleep_mode_cmd(ar->wmi, vif->fw_vif_idx,\r\nATH6KL_HOST_MODE_ASLEEP);\r\nif (ret)\r\nreturn ret;\r\nleft = wait_event_interruptible_timeout(ar->event_wq,\r\nis_hsleep_mode_procsed(vif),\r\nWMI_TIMEOUT);\r\nif (left == 0) {\r\nath6kl_warn("timeout, didn't get host sleep cmd processed event\n");\r\nret = -ETIMEDOUT;\r\n} else if (left < 0) {\r\nath6kl_warn("error while waiting for host sleep cmd processed event %d\n",\r\nleft);\r\nret = left;\r\n}\r\nif (ar->tx_pending[ar->ctrl_ep]) {\r\nleft = wait_event_interruptible_timeout(ar->event_wq,\r\nis_ctrl_ep_empty(ar),\r\nWMI_TIMEOUT);\r\nif (left == 0) {\r\nath6kl_warn("clear wmi ctrl data timeout\n");\r\nret = -ETIMEDOUT;\r\n} else if (left < 0) {\r\nath6kl_warn("clear wmi ctrl data failed: %d\n", left);\r\nret = left;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ath6kl_wow_suspend_vif(struct ath6kl_vif *vif,\r\nstruct cfg80211_wowlan *wow, u32 *filter)\r\n{\r\nstruct ath6kl *ar = vif->ar;\r\nstruct in_device *in_dev;\r\nstruct in_ifaddr *ifa;\r\nint ret;\r\nu16 i, bmiss_time;\r\n__be32 ips[MAX_IP_ADDRS];\r\nu8 index = 0;\r\nif (!test_bit(NETDEV_MCAST_ALL_ON, &vif->flags) &&\r\ntest_bit(ATH6KL_FW_CAPABILITY_WOW_MULTICAST_FILTER,\r\nar->fw_capabilities)) {\r\nret = ath6kl_wmi_mcast_filter_cmd(vif->ar->wmi,\r\nvif->fw_vif_idx, false);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < WOW_MAX_FILTERS_PER_LIST; i++)\r\nath6kl_wmi_del_wow_pattern_cmd(ar->wmi, vif->fw_vif_idx,\r\nWOW_LIST_ID, i);\r\nif (wow)\r\nret = ath6kl_wow_usr(ar, vif, wow, filter);\r\nelse if (vif->nw_type == AP_NETWORK)\r\nret = ath6kl_wow_ap(ar, vif);\r\nelse\r\nret = ath6kl_wow_sta(ar, vif);\r\nif (ret)\r\nreturn ret;\r\nnetif_stop_queue(vif->ndev);\r\nif (vif->nw_type != AP_NETWORK) {\r\nret = ath6kl_wmi_listeninterval_cmd(ar->wmi, vif->fw_vif_idx,\r\nATH6KL_MAX_WOW_LISTEN_INTL,\r\n0);\r\nif (ret)\r\nreturn ret;\r\nbmiss_time = ATH6KL_MAX_WOW_LISTEN_INTL * 15;\r\nif (bmiss_time > ATH6KL_MAX_BMISS_TIME)\r\nbmiss_time = ATH6KL_MAX_BMISS_TIME;\r\nret = ath6kl_wmi_bmisstime_cmd(ar->wmi, vif->fw_vif_idx,\r\nbmiss_time, 0);\r\nif (ret)\r\nreturn ret;\r\nret = ath6kl_wmi_scanparams_cmd(ar->wmi, vif->fw_vif_idx,\r\n0xFFFF, 0, 0xFFFF, 0, 0, 0,\r\n0, 0, 0, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nin_dev = __in_dev_get_rtnl(vif->ndev);\r\nif (!in_dev)\r\nreturn 0;\r\nifa = in_dev->ifa_list;\r\nmemset(&ips, 0, sizeof(ips));\r\nwhile (index < MAX_IP_ADDRS && ifa) {\r\nips[index] = ifa->ifa_local;\r\nifa = ifa->ifa_next;\r\nindex++;\r\n}\r\nif (ifa) {\r\nath6kl_err("total IP addr count is exceeding fw limit\n");\r\nreturn -EINVAL;\r\n}\r\nret = ath6kl_wmi_set_ip_cmd(ar->wmi, vif->fw_vif_idx, ips[0], ips[1]);\r\nif (ret) {\r\nath6kl_err("fail to setup ip for arp agent\n");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ath6kl_wow_suspend(struct ath6kl *ar, struct cfg80211_wowlan *wow)\r\n{\r\nstruct ath6kl_vif *first_vif, *vif;\r\nint ret = 0;\r\nu32 filter = 0;\r\nbool connected = false;\r\nfirst_vif = ath6kl_vif_first(ar);\r\nif (WARN_ON(!first_vif) ||\r\n!ath6kl_cfg80211_ready(first_vif))\r\nreturn -EIO;\r\nif (wow && (wow->n_patterns > WOW_MAX_FILTERS_PER_LIST))\r\nreturn -EINVAL;\r\nspin_lock_bh(&ar->list_lock);\r\nlist_for_each_entry(vif, &ar->vif_list, list) {\r\nif (!test_bit(CONNECTED, &vif->flags) ||\r\n!ath6kl_cfg80211_ready(vif))\r\ncontinue;\r\nconnected = true;\r\nret = ath6kl_wow_suspend_vif(vif, wow, &filter);\r\nif (ret)\r\nbreak;\r\n}\r\nspin_unlock_bh(&ar->list_lock);\r\nif (!connected)\r\nreturn -ENOTCONN;\r\nelse if (ret)\r\nreturn ret;\r\nar->state = ATH6KL_STATE_SUSPENDING;\r\nret = ath6kl_wmi_set_wow_mode_cmd(ar->wmi, first_vif->fw_vif_idx,\r\nATH6KL_WOW_MODE_ENABLE,\r\nfilter,\r\nWOW_HOST_REQ_DELAY);\r\nif (ret)\r\nreturn ret;\r\nreturn ath6kl_cfg80211_host_sleep(ar, first_vif);\r\n}\r\nstatic int ath6kl_wow_resume_vif(struct ath6kl_vif *vif)\r\n{\r\nstruct ath6kl *ar = vif->ar;\r\nint ret;\r\nif (vif->nw_type != AP_NETWORK) {\r\nret = ath6kl_wmi_scanparams_cmd(ar->wmi, vif->fw_vif_idx,\r\n0, 0, 0, 0, 0, 0, 3, 0, 0, 0);\r\nif (ret)\r\nreturn ret;\r\nret = ath6kl_wmi_listeninterval_cmd(ar->wmi, vif->fw_vif_idx,\r\nvif->listen_intvl_t, 0);\r\nif (ret)\r\nreturn ret;\r\nret = ath6kl_wmi_bmisstime_cmd(ar->wmi, vif->fw_vif_idx,\r\nvif->bmiss_time_t, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!test_bit(NETDEV_MCAST_ALL_OFF, &vif->flags) &&\r\ntest_bit(ATH6KL_FW_CAPABILITY_WOW_MULTICAST_FILTER,\r\nar->fw_capabilities)) {\r\nret = ath6kl_wmi_mcast_filter_cmd(vif->ar->wmi,\r\nvif->fw_vif_idx, true);\r\nif (ret)\r\nreturn ret;\r\n}\r\nnetif_wake_queue(vif->ndev);\r\nreturn 0;\r\n}\r\nstatic int ath6kl_wow_resume(struct ath6kl *ar)\r\n{\r\nstruct ath6kl_vif *vif;\r\nint ret;\r\nvif = ath6kl_vif_first(ar);\r\nif (WARN_ON(!vif) ||\r\n!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nar->state = ATH6KL_STATE_RESUMING;\r\nret = ath6kl_wmi_set_host_sleep_mode_cmd(ar->wmi, vif->fw_vif_idx,\r\nATH6KL_HOST_MODE_AWAKE);\r\nif (ret) {\r\nath6kl_warn("Failed to configure host sleep mode for wow resume: %d\n",\r\nret);\r\ngoto cleanup;\r\n}\r\nspin_lock_bh(&ar->list_lock);\r\nlist_for_each_entry(vif, &ar->vif_list, list) {\r\nif (!test_bit(CONNECTED, &vif->flags) ||\r\n!ath6kl_cfg80211_ready(vif))\r\ncontinue;\r\nret = ath6kl_wow_resume_vif(vif);\r\nif (ret)\r\nbreak;\r\n}\r\nspin_unlock_bh(&ar->list_lock);\r\nif (ret)\r\ngoto cleanup;\r\nar->state = ATH6KL_STATE_ON;\r\nreturn 0;\r\ncleanup:\r\nar->state = ATH6KL_STATE_WOW;\r\nreturn ret;\r\n}\r\nstatic int ath6kl_cfg80211_deepsleep_suspend(struct ath6kl *ar)\r\n{\r\nstruct ath6kl_vif *vif;\r\nint ret;\r\nvif = ath6kl_vif_first(ar);\r\nif (!vif)\r\nreturn -EIO;\r\nif (!test_bit(WMI_READY, &ar->flag)) {\r\nath6kl_err("deepsleep failed as wmi is not ready\n");\r\nreturn -EIO;\r\n}\r\nath6kl_cfg80211_stop_all(ar);\r\nar->wmi->saved_pwr_mode = ar->wmi->pwr_mode;\r\nret = ath6kl_wmi_powermode_cmd(ar->wmi, 0, REC_POWER);\r\nif (ret)\r\nreturn ret;\r\nret = ath6kl_wmi_set_wow_mode_cmd(ar->wmi, vif->fw_vif_idx,\r\nATH6KL_WOW_MODE_DISABLE,\r\n0, 0);\r\nif (ret)\r\nreturn ret;\r\nath6kl_tx_data_cleanup(ar);\r\nret = ath6kl_cfg80211_host_sleep(ar, vif);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ath6kl_cfg80211_deepsleep_resume(struct ath6kl *ar)\r\n{\r\nstruct ath6kl_vif *vif;\r\nint ret;\r\nvif = ath6kl_vif_first(ar);\r\nif (!vif)\r\nreturn -EIO;\r\nif (ar->wmi->pwr_mode != ar->wmi->saved_pwr_mode) {\r\nret = ath6kl_wmi_powermode_cmd(ar->wmi, 0,\r\nar->wmi->saved_pwr_mode);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = ath6kl_wmi_set_host_sleep_mode_cmd(ar->wmi, vif->fw_vif_idx,\r\nATH6KL_HOST_MODE_AWAKE);\r\nif (ret)\r\nreturn ret;\r\nar->state = ATH6KL_STATE_ON;\r\nret = ath6kl_wmi_scanparams_cmd(ar->wmi, vif->fw_vif_idx,\r\n0, 0, 0, 0, 0, 0, 3, 0, 0, 0);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint ath6kl_cfg80211_suspend(struct ath6kl *ar,\r\nenum ath6kl_cfg_suspend_mode mode,\r\nstruct cfg80211_wowlan *wow)\r\n{\r\nstruct ath6kl_vif *vif;\r\nenum ath6kl_state prev_state;\r\nint ret;\r\nswitch (mode) {\r\ncase ATH6KL_CFG_SUSPEND_WOW:\r\nath6kl_dbg(ATH6KL_DBG_SUSPEND, "wow mode suspend\n");\r\nath6kl_tx_data_cleanup(ar);\r\nprev_state = ar->state;\r\nret = ath6kl_wow_suspend(ar, wow);\r\nif (ret) {\r\nar->state = prev_state;\r\nreturn ret;\r\n}\r\nar->state = ATH6KL_STATE_WOW;\r\nbreak;\r\ncase ATH6KL_CFG_SUSPEND_DEEPSLEEP:\r\nath6kl_dbg(ATH6KL_DBG_SUSPEND, "deep sleep suspend\n");\r\nret = ath6kl_cfg80211_deepsleep_suspend(ar);\r\nif (ret) {\r\nath6kl_err("deepsleep suspend failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nar->state = ATH6KL_STATE_DEEPSLEEP;\r\nbreak;\r\ncase ATH6KL_CFG_SUSPEND_CUTPOWER:\r\nath6kl_cfg80211_stop_all(ar);\r\nif (ar->state == ATH6KL_STATE_OFF) {\r\nath6kl_dbg(ATH6KL_DBG_SUSPEND,\r\n"suspend hw off, no action for cutpower\n");\r\nbreak;\r\n}\r\nath6kl_dbg(ATH6KL_DBG_SUSPEND, "suspend cutting power\n");\r\nret = ath6kl_init_hw_stop(ar);\r\nif (ret) {\r\nath6kl_warn("failed to stop hw during suspend: %d\n",\r\nret);\r\n}\r\nar->state = ATH6KL_STATE_CUTPOWER;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nlist_for_each_entry(vif, &ar->vif_list, list)\r\nath6kl_cfg80211_scan_complete_event(vif, true);\r\nreturn 0;\r\n}\r\nint ath6kl_cfg80211_resume(struct ath6kl *ar)\r\n{\r\nint ret;\r\nswitch (ar->state) {\r\ncase ATH6KL_STATE_WOW:\r\nath6kl_dbg(ATH6KL_DBG_SUSPEND, "wow mode resume\n");\r\nret = ath6kl_wow_resume(ar);\r\nif (ret) {\r\nath6kl_warn("wow mode resume failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nbreak;\r\ncase ATH6KL_STATE_DEEPSLEEP:\r\nath6kl_dbg(ATH6KL_DBG_SUSPEND, "deep sleep resume\n");\r\nret = ath6kl_cfg80211_deepsleep_resume(ar);\r\nif (ret) {\r\nath6kl_warn("deep sleep resume failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nbreak;\r\ncase ATH6KL_STATE_CUTPOWER:\r\nath6kl_dbg(ATH6KL_DBG_SUSPEND, "resume restoring power\n");\r\nret = ath6kl_init_hw_start(ar);\r\nif (ret) {\r\nath6kl_warn("Failed to boot hw in resume: %d\n", ret);\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __ath6kl_cfg80211_suspend(struct wiphy *wiphy,\r\nstruct cfg80211_wowlan *wow)\r\n{\r\nstruct ath6kl *ar = wiphy_priv(wiphy);\r\nath6kl_recovery_suspend(ar);\r\nreturn ath6kl_hif_suspend(ar, wow);\r\n}\r\nstatic int __ath6kl_cfg80211_resume(struct wiphy *wiphy)\r\n{\r\nstruct ath6kl *ar = wiphy_priv(wiphy);\r\nint err;\r\nerr = ath6kl_hif_resume(ar);\r\nif (err)\r\nreturn err;\r\nath6kl_recovery_resume(ar);\r\nreturn 0;\r\n}\r\nvoid ath6kl_check_wow_status(struct ath6kl *ar)\r\n{\r\nif (ar->state == ATH6KL_STATE_SUSPENDING)\r\nreturn;\r\nif (ar->state == ATH6KL_STATE_WOW)\r\nath6kl_cfg80211_resume(ar);\r\n}\r\nvoid ath6kl_check_wow_status(struct ath6kl *ar)\r\n{\r\n}\r\nstatic int ath6kl_set_htcap(struct ath6kl_vif *vif, enum nl80211_band band,\r\nbool ht_enable)\r\n{\r\nstruct ath6kl_htcap *htcap = &vif->htcap[band];\r\nif (htcap->ht_enable == ht_enable)\r\nreturn 0;\r\nif (ht_enable) {\r\nhtcap->ht_enable = true;\r\nhtcap->cap_info = (band == NL80211_BAND_2GHZ) ?\r\nath6kl_g_htcap : ath6kl_a_htcap;\r\nhtcap->ampdu_factor = IEEE80211_HT_MAX_AMPDU_16K;\r\n} else\r\nmemset(htcap, 0, sizeof(*htcap));\r\nreturn ath6kl_wmi_set_htcap_cmd(vif->ar->wmi, vif->fw_vif_idx,\r\nband, htcap);\r\n}\r\nstatic int ath6kl_restore_htcap(struct ath6kl_vif *vif)\r\n{\r\nstruct wiphy *wiphy = vif->ar->wiphy;\r\nint band, ret = 0;\r\nfor (band = 0; band < NUM_NL80211_BANDS; band++) {\r\nif (!wiphy->bands[band])\r\ncontinue;\r\nret = ath6kl_set_htcap(vif, band,\r\nwiphy->bands[band]->ht_cap.ht_supported);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool ath6kl_is_p2p_ie(const u8 *pos)\r\n{\r\nreturn pos[0] == WLAN_EID_VENDOR_SPECIFIC && pos[1] >= 4 &&\r\npos[2] == 0x50 && pos[3] == 0x6f &&\r\npos[4] == 0x9a && pos[5] == 0x09;\r\n}\r\nstatic int ath6kl_set_ap_probe_resp_ies(struct ath6kl_vif *vif,\r\nconst u8 *ies, size_t ies_len)\r\n{\r\nstruct ath6kl *ar = vif->ar;\r\nconst u8 *pos;\r\nu8 *buf = NULL;\r\nsize_t len = 0;\r\nint ret;\r\nif (ies && ies_len) {\r\nbuf = kmalloc(ies_len, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\npos = ies;\r\nwhile (pos + 1 < ies + ies_len) {\r\nif (pos + 2 + pos[1] > ies + ies_len)\r\nbreak;\r\nif (!ath6kl_is_p2p_ie(pos)) {\r\nmemcpy(buf + len, pos, 2 + pos[1]);\r\nlen += 2 + pos[1];\r\n}\r\npos += 2 + pos[1];\r\n}\r\n}\r\nret = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,\r\nWMI_FRAME_PROBE_RESP, buf, len);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int ath6kl_set_ies(struct ath6kl_vif *vif,\r\nstruct cfg80211_beacon_data *info)\r\n{\r\nstruct ath6kl *ar = vif->ar;\r\nint res;\r\nres = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,\r\nWMI_FRAME_BEACON,\r\ninfo->beacon_ies,\r\ninfo->beacon_ies_len);\r\nif (res)\r\nreturn res;\r\nres = ath6kl_set_ap_probe_resp_ies(vif, info->proberesp_ies,\r\ninfo->proberesp_ies_len);\r\nif (res)\r\nreturn res;\r\nres = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,\r\nWMI_FRAME_ASSOC_RESP,\r\ninfo->assocresp_ies,\r\ninfo->assocresp_ies_len);\r\nif (res)\r\nreturn res;\r\nreturn 0;\r\n}\r\nstatic int ath6kl_get_rsn_capab(struct cfg80211_beacon_data *beacon,\r\nu8 *rsn_capab)\r\n{\r\nconst u8 *rsn_ie;\r\nsize_t rsn_ie_len;\r\nu16 cnt;\r\nif (!beacon->tail)\r\nreturn -EINVAL;\r\nrsn_ie = cfg80211_find_ie(WLAN_EID_RSN, beacon->tail, beacon->tail_len);\r\nif (!rsn_ie)\r\nreturn -EINVAL;\r\nrsn_ie_len = *(rsn_ie + 1);\r\nrsn_ie += 2;\r\nif (rsn_ie_len < 2)\r\nreturn -EINVAL;\r\nrsn_ie += 2;\r\nrsn_ie_len -= 2;\r\nif (rsn_ie_len < 4)\r\nreturn 0;\r\nrsn_ie += 4;\r\nrsn_ie_len -= 4;\r\nif (rsn_ie_len < 2)\r\nreturn 0;\r\ncnt = get_unaligned_le16(rsn_ie);\r\nrsn_ie += (2 + cnt * 4);\r\nrsn_ie_len -= (2 + cnt * 4);\r\nif (rsn_ie_len < 2)\r\nreturn 0;\r\ncnt = get_unaligned_le16(rsn_ie);\r\nrsn_ie += (2 + cnt * 4);\r\nrsn_ie_len -= (2 + cnt * 4);\r\nif (rsn_ie_len < 2)\r\nreturn 0;\r\nmemcpy(rsn_capab, rsn_ie, 2);\r\nreturn 0;\r\n}\r\nstatic int ath6kl_start_ap(struct wiphy *wiphy, struct net_device *dev,\r\nstruct cfg80211_ap_settings *info)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(dev);\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nstruct ieee80211_mgmt *mgmt;\r\nbool hidden = false;\r\nu8 *ies;\r\nint ies_len;\r\nstruct wmi_connect_cmd p;\r\nint res;\r\nint i, ret;\r\nu16 rsn_capab = 0;\r\nint inactivity_timeout = 0;\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s:\n", __func__);\r\nif (!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nif (vif->next_mode != AP_NETWORK)\r\nreturn -EOPNOTSUPP;\r\nres = ath6kl_set_ies(vif, &info->beacon);\r\nar->ap_mode_bkey.valid = false;\r\nret = ath6kl_wmi_ap_set_beacon_intvl_cmd(ar->wmi, vif->fw_vif_idx,\r\ninfo->beacon_interval);\r\nif (ret)\r\nath6kl_warn("Failed to set beacon interval: %d\n", ret);\r\nret = ath6kl_wmi_ap_set_dtim_cmd(ar->wmi, vif->fw_vif_idx,\r\ninfo->dtim_period);\r\nif (ret)\r\nath6kl_warn("Failed to set dtim_period in beacon: %d\n", ret);\r\nif (info->beacon.head == NULL)\r\nreturn -EINVAL;\r\nmgmt = (struct ieee80211_mgmt *) info->beacon.head;\r\nies = mgmt->u.beacon.variable;\r\nif (ies > info->beacon.head + info->beacon.head_len)\r\nreturn -EINVAL;\r\nies_len = info->beacon.head + info->beacon.head_len - ies;\r\nif (info->ssid == NULL)\r\nreturn -EINVAL;\r\nmemcpy(vif->ssid, info->ssid, info->ssid_len);\r\nvif->ssid_len = info->ssid_len;\r\nif (info->hidden_ssid != NL80211_HIDDEN_SSID_NOT_IN_USE)\r\nhidden = true;\r\nres = ath6kl_wmi_ap_hidden_ssid(ar->wmi, vif->fw_vif_idx, hidden);\r\nif (res)\r\nreturn res;\r\nret = ath6kl_set_auth_type(vif, info->auth_type);\r\nif (ret)\r\nreturn ret;\r\nmemset(&p, 0, sizeof(p));\r\nfor (i = 0; i < info->crypto.n_akm_suites; i++) {\r\nswitch (info->crypto.akm_suites[i]) {\r\ncase WLAN_AKM_SUITE_8021X:\r\nif (info->crypto.wpa_versions & NL80211_WPA_VERSION_1)\r\np.auth_mode |= WPA_AUTH;\r\nif (info->crypto.wpa_versions & NL80211_WPA_VERSION_2)\r\np.auth_mode |= WPA2_AUTH;\r\nbreak;\r\ncase WLAN_AKM_SUITE_PSK:\r\nif (info->crypto.wpa_versions & NL80211_WPA_VERSION_1)\r\np.auth_mode |= WPA_PSK_AUTH;\r\nif (info->crypto.wpa_versions & NL80211_WPA_VERSION_2)\r\np.auth_mode |= WPA2_PSK_AUTH;\r\nbreak;\r\n}\r\n}\r\nif (p.auth_mode == 0)\r\np.auth_mode = NONE_AUTH;\r\nvif->auth_mode = p.auth_mode;\r\nfor (i = 0; i < info->crypto.n_ciphers_pairwise; i++) {\r\nswitch (info->crypto.ciphers_pairwise[i]) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\np.prwise_crypto_type |= WEP_CRYPT;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\np.prwise_crypto_type |= TKIP_CRYPT;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\np.prwise_crypto_type |= AES_CRYPT;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_SMS4:\r\np.prwise_crypto_type |= WAPI_CRYPT;\r\nbreak;\r\n}\r\n}\r\nif (p.prwise_crypto_type == 0) {\r\np.prwise_crypto_type = NONE_CRYPT;\r\nath6kl_set_cipher(vif, 0, true);\r\n} else if (info->crypto.n_ciphers_pairwise == 1) {\r\nath6kl_set_cipher(vif, info->crypto.ciphers_pairwise[0], true);\r\n}\r\nswitch (info->crypto.cipher_group) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\np.grp_crypto_type = WEP_CRYPT;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\np.grp_crypto_type = TKIP_CRYPT;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\np.grp_crypto_type = AES_CRYPT;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_SMS4:\r\np.grp_crypto_type = WAPI_CRYPT;\r\nbreak;\r\ndefault:\r\np.grp_crypto_type = NONE_CRYPT;\r\nbreak;\r\n}\r\nath6kl_set_cipher(vif, info->crypto.cipher_group, false);\r\np.nw_type = AP_NETWORK;\r\nvif->nw_type = vif->next_mode;\r\np.ssid_len = vif->ssid_len;\r\nmemcpy(p.ssid, vif->ssid, vif->ssid_len);\r\np.dot11_auth_mode = vif->dot11_auth_mode;\r\np.ch = cpu_to_le16(info->chandef.chan->center_freq);\r\nres = ath6kl_wmi_ap_set_apsd(ar->wmi, vif->fw_vif_idx, true);\r\nif (res < 0)\r\nreturn res;\r\nif (vif->wdev.iftype == NL80211_IFTYPE_P2P_GO) {\r\np.nw_subtype = SUBTYPE_P2PGO;\r\n} else {\r\np.nw_subtype = SUBTYPE_NONE;\r\n}\r\nif (info->inactivity_timeout) {\r\ninactivity_timeout = info->inactivity_timeout;\r\nif (test_bit(ATH6KL_FW_CAPABILITY_AP_INACTIVITY_MINS,\r\nar->fw_capabilities))\r\ninactivity_timeout = DIV_ROUND_UP(inactivity_timeout,\r\n60);\r\nres = ath6kl_wmi_set_inact_period(ar->wmi, vif->fw_vif_idx,\r\ninactivity_timeout);\r\nif (res < 0)\r\nreturn res;\r\n}\r\nif (ath6kl_set_htcap(vif, info->chandef.chan->band,\r\ncfg80211_get_chandef_type(&info->chandef)\r\n!= NL80211_CHAN_NO_HT))\r\nreturn -EIO;\r\nif (!ath6kl_get_rsn_capab(&info->beacon, (u8 *) &rsn_capab) &&\r\ntest_bit(ATH6KL_FW_CAPABILITY_RSN_CAP_OVERRIDE,\r\nar->fw_capabilities)) {\r\nres = ath6kl_wmi_set_ie_cmd(ar->wmi, vif->fw_vif_idx,\r\nWLAN_EID_RSN, WMI_RSN_IE_CAPB,\r\n(const u8 *) &rsn_capab,\r\nsizeof(rsn_capab));\r\nvif->rsn_capab = rsn_capab;\r\nif (res < 0)\r\nreturn res;\r\n}\r\nmemcpy(&vif->profile, &p, sizeof(p));\r\nres = ath6kl_wmi_ap_profile_commit(ar->wmi, vif->fw_vif_idx, &p);\r\nif (res < 0)\r\nreturn res;\r\nreturn 0;\r\n}\r\nstatic int ath6kl_change_beacon(struct wiphy *wiphy, struct net_device *dev,\r\nstruct cfg80211_beacon_data *beacon)\r\n{\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nif (!ath6kl_cfg80211_ready(vif))\r\nreturn -EIO;\r\nif (vif->next_mode != AP_NETWORK)\r\nreturn -EOPNOTSUPP;\r\nreturn ath6kl_set_ies(vif, beacon);\r\n}\r\nstatic int ath6kl_stop_ap(struct wiphy *wiphy, struct net_device *dev)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(dev);\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nif (vif->nw_type != AP_NETWORK)\r\nreturn -EOPNOTSUPP;\r\nif (!test_bit(CONNECTED, &vif->flags))\r\nreturn -ENOTCONN;\r\nath6kl_wmi_disconnect_cmd(ar->wmi, vif->fw_vif_idx);\r\nclear_bit(CONNECTED, &vif->flags);\r\nnetif_carrier_off(vif->ndev);\r\nreturn ath6kl_restore_htcap(vif);\r\n}\r\nstatic int ath6kl_del_station(struct wiphy *wiphy, struct net_device *dev,\r\nstruct station_del_parameters *params)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(dev);\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nconst u8 *addr = params->mac ? params->mac : bcast_addr;\r\nreturn ath6kl_wmi_ap_set_mlme(ar->wmi, vif->fw_vif_idx, WMI_AP_DEAUTH,\r\naddr, WLAN_REASON_PREV_AUTH_NOT_VALID);\r\n}\r\nstatic int ath6kl_change_station(struct wiphy *wiphy, struct net_device *dev,\r\nconst u8 *mac,\r\nstruct station_parameters *params)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(dev);\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nint err;\r\nif (vif->nw_type != AP_NETWORK)\r\nreturn -EOPNOTSUPP;\r\nerr = cfg80211_check_station_change(wiphy, params,\r\nCFG80211_STA_AP_MLME_CLIENT);\r\nif (err)\r\nreturn err;\r\nif (params->sta_flags_set & BIT(NL80211_STA_FLAG_AUTHORIZED))\r\nreturn ath6kl_wmi_ap_set_mlme(ar->wmi, vif->fw_vif_idx,\r\nWMI_AP_MLME_AUTHORIZE, mac, 0);\r\nreturn ath6kl_wmi_ap_set_mlme(ar->wmi, vif->fw_vif_idx,\r\nWMI_AP_MLME_UNAUTHORIZE, mac, 0);\r\n}\r\nstatic int ath6kl_remain_on_channel(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nstruct ieee80211_channel *chan,\r\nunsigned int duration,\r\nu64 *cookie)\r\n{\r\nstruct ath6kl_vif *vif = ath6kl_vif_from_wdev(wdev);\r\nstruct ath6kl *ar = ath6kl_priv(vif->ndev);\r\nu32 id;\r\nid = ++vif->last_roc_id;\r\nif (id == 0) {\r\nid = ++vif->last_roc_id;\r\n}\r\n*cookie = id;\r\nreturn ath6kl_wmi_remain_on_chnl_cmd(ar->wmi, vif->fw_vif_idx,\r\nchan->center_freq, duration);\r\n}\r\nstatic int ath6kl_cancel_remain_on_channel(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nu64 cookie)\r\n{\r\nstruct ath6kl_vif *vif = ath6kl_vif_from_wdev(wdev);\r\nstruct ath6kl *ar = ath6kl_priv(vif->ndev);\r\nif (cookie != vif->last_roc_id)\r\nreturn -ENOENT;\r\nvif->last_cancel_roc_id = cookie;\r\nreturn ath6kl_wmi_cancel_remain_on_chnl_cmd(ar->wmi, vif->fw_vif_idx);\r\n}\r\nstatic int ath6kl_send_go_probe_resp(struct ath6kl_vif *vif,\r\nconst u8 *buf, size_t len,\r\nunsigned int freq)\r\n{\r\nstruct ath6kl *ar = vif->ar;\r\nconst u8 *pos;\r\nu8 *p2p;\r\nint p2p_len;\r\nint ret;\r\nconst struct ieee80211_mgmt *mgmt;\r\nmgmt = (const struct ieee80211_mgmt *) buf;\r\np2p = kmalloc(len, GFP_KERNEL);\r\nif (p2p == NULL)\r\nreturn -ENOMEM;\r\np2p_len = 0;\r\npos = mgmt->u.probe_resp.variable;\r\nwhile (pos + 1 < buf + len) {\r\nif (pos + 2 + pos[1] > buf + len)\r\nbreak;\r\nif (ath6kl_is_p2p_ie(pos)) {\r\nmemcpy(p2p + p2p_len, pos, 2 + pos[1]);\r\np2p_len += 2 + pos[1];\r\n}\r\npos += 2 + pos[1];\r\n}\r\nret = ath6kl_wmi_send_probe_response_cmd(ar->wmi, vif->fw_vif_idx, freq,\r\nmgmt->da, p2p, p2p_len);\r\nkfree(p2p);\r\nreturn ret;\r\n}\r\nstatic bool ath6kl_mgmt_powersave_ap(struct ath6kl_vif *vif,\r\nu32 id,\r\nu32 freq,\r\nu32 wait,\r\nconst u8 *buf,\r\nsize_t len,\r\nbool *more_data,\r\nbool no_cck)\r\n{\r\nstruct ieee80211_mgmt *mgmt;\r\nstruct ath6kl_sta *conn;\r\nbool is_psq_empty = false;\r\nstruct ath6kl_mgmt_buff *mgmt_buf;\r\nsize_t mgmt_buf_size;\r\nstruct ath6kl *ar = vif->ar;\r\nmgmt = (struct ieee80211_mgmt *) buf;\r\nif (is_multicast_ether_addr(mgmt->da))\r\nreturn false;\r\nconn = ath6kl_find_sta(vif, mgmt->da);\r\nif (!conn)\r\nreturn false;\r\nif (conn->sta_flags & STA_PS_SLEEP) {\r\nif (!(conn->sta_flags & STA_PS_POLLED)) {\r\nmgmt_buf_size = len + sizeof(struct ath6kl_mgmt_buff);\r\nmgmt_buf = kmalloc(mgmt_buf_size, GFP_KERNEL);\r\nif (!mgmt_buf)\r\nreturn false;\r\nINIT_LIST_HEAD(&mgmt_buf->list);\r\nmgmt_buf->id = id;\r\nmgmt_buf->freq = freq;\r\nmgmt_buf->wait = wait;\r\nmgmt_buf->len = len;\r\nmgmt_buf->no_cck = no_cck;\r\nmemcpy(mgmt_buf->buf, buf, len);\r\nspin_lock_bh(&conn->psq_lock);\r\nis_psq_empty = skb_queue_empty(&conn->psq) &&\r\n(conn->mgmt_psq_len == 0);\r\nlist_add_tail(&mgmt_buf->list, &conn->mgmt_psq);\r\nconn->mgmt_psq_len++;\r\nspin_unlock_bh(&conn->psq_lock);\r\nif (is_psq_empty)\r\nath6kl_wmi_set_pvb_cmd(ar->wmi, vif->fw_vif_idx,\r\nconn->aid, 1);\r\nreturn true;\r\n}\r\nspin_lock_bh(&conn->psq_lock);\r\nif (!skb_queue_empty(&conn->psq) || (conn->mgmt_psq_len != 0))\r\n*more_data = true;\r\nspin_unlock_bh(&conn->psq_lock);\r\n}\r\nreturn false;\r\n}\r\nstatic bool ath6kl_is_p2p_go_ssid(const u8 *buf, size_t len)\r\n{\r\nconst struct ieee80211_mgmt *mgmt;\r\nmgmt = (const struct ieee80211_mgmt *) buf;\r\nif (buf + len >= &mgmt->u.probe_resp.variable[1] &&\r\n(mgmt->u.probe_resp.variable[1] > P2P_WILDCARD_SSID_LEN)) {\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int ath6kl_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\r\nstruct cfg80211_mgmt_tx_params *params, u64 *cookie)\r\n{\r\nstruct ath6kl_vif *vif = ath6kl_vif_from_wdev(wdev);\r\nstruct ath6kl *ar = ath6kl_priv(vif->ndev);\r\nstruct ieee80211_channel *chan = params->chan;\r\nconst u8 *buf = params->buf;\r\nsize_t len = params->len;\r\nunsigned int wait = params->wait;\r\nbool no_cck = params->no_cck;\r\nu32 id, freq;\r\nconst struct ieee80211_mgmt *mgmt;\r\nbool more_data, queued;\r\nfreq = vif->ch_hint;\r\nif (chan)\r\nfreq = chan->center_freq;\r\nif (WARN_ON(freq == 0))\r\nreturn -EINVAL;\r\nmgmt = (const struct ieee80211_mgmt *) buf;\r\nif (vif->nw_type == AP_NETWORK && test_bit(CONNECTED, &vif->flags) &&\r\nieee80211_is_probe_resp(mgmt->frame_control) &&\r\nath6kl_is_p2p_go_ssid(buf, len)) {\r\n*cookie = 0;\r\nreturn ath6kl_send_go_probe_resp(vif, buf, len, freq);\r\n}\r\nid = vif->send_action_id++;\r\nif (id == 0) {\r\nid = vif->send_action_id++;\r\n}\r\n*cookie = id;\r\nif (vif->nw_type == AP_NETWORK) {\r\nqueued = ath6kl_mgmt_powersave_ap(vif, id, freq, wait, buf, len,\r\n&more_data, no_cck);\r\nif (queued)\r\nreturn 0;\r\n}\r\nreturn ath6kl_wmi_send_mgmt_cmd(ar->wmi, vif->fw_vif_idx, id, freq,\r\nwait, buf, len, no_cck);\r\n}\r\nstatic int ath6kl_get_antenna(struct wiphy *wiphy,\r\nu32 *tx_ant, u32 *rx_ant)\r\n{\r\nstruct ath6kl *ar = wiphy_priv(wiphy);\r\n*tx_ant = ar->hw.tx_ant;\r\n*rx_ant = ar->hw.rx_ant;\r\nreturn 0;\r\n}\r\nstatic void ath6kl_mgmt_frame_register(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nu16 frame_type, bool reg)\r\n{\r\nstruct ath6kl_vif *vif = ath6kl_vif_from_wdev(wdev);\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: frame_type=0x%x reg=%d\n",\r\n__func__, frame_type, reg);\r\nif (frame_type == IEEE80211_STYPE_PROBE_REQ) {\r\nvif->probe_req_report = reg;\r\n}\r\n}\r\nstatic int ath6kl_cfg80211_sscan_start(struct wiphy *wiphy,\r\nstruct net_device *dev,\r\nstruct cfg80211_sched_scan_request *request)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(dev);\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nu16 interval;\r\nint ret, rssi_thold;\r\nint n_match_sets = request->n_match_sets;\r\nif (n_match_sets == 1 && !request->match_sets[0].ssid.ssid_len)\r\nn_match_sets = 0;\r\nif (ar->state != ATH6KL_STATE_ON)\r\nreturn -EIO;\r\nif (vif->sme_state != SME_DISCONNECTED)\r\nreturn -EBUSY;\r\nath6kl_cfg80211_scan_complete_event(vif, true);\r\nret = ath6kl_set_probed_ssids(ar, vif, request->ssids,\r\nrequest->n_ssids,\r\nrequest->match_sets,\r\nn_match_sets);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!n_match_sets) {\r\nret = ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,\r\nALL_BSS_FILTER, 0);\r\nif (ret < 0)\r\nreturn ret;\r\n} else {\r\nret = ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,\r\nMATCHED_SSID_FILTER, 0);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (test_bit(ATH6KL_FW_CAPABILITY_RSSI_SCAN_THOLD,\r\nar->fw_capabilities)) {\r\nif (request->min_rssi_thold <= NL80211_SCAN_RSSI_THOLD_OFF)\r\nrssi_thold = 0;\r\nelse if (request->min_rssi_thold < -127)\r\nrssi_thold = -127;\r\nelse\r\nrssi_thold = request->min_rssi_thold;\r\nret = ath6kl_wmi_set_rssi_filter_cmd(ar->wmi, vif->fw_vif_idx,\r\nrssi_thold);\r\nif (ret) {\r\nath6kl_err("failed to set RSSI threshold for scan\n");\r\nreturn ret;\r\n}\r\n}\r\ninterval = max_t(u16, 1, request->scan_plans[0].interval);\r\nath6kl_wmi_scanparams_cmd(ar->wmi, vif->fw_vif_idx,\r\ninterval, interval,\r\nvif->bg_scan_period, 0, 0, 0, 3, 0, 0, 0);\r\nret = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,\r\nWMI_FRAME_PROBE_REQ,\r\nrequest->ie, request->ie_len);\r\nif (ret) {\r\nath6kl_warn("Failed to set probe request IE for scheduled scan: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = ath6kl_wmi_enable_sched_scan_cmd(ar->wmi, vif->fw_vif_idx, true);\r\nif (ret)\r\nreturn ret;\r\nset_bit(SCHED_SCANNING, &vif->flags);\r\nreturn 0;\r\n}\r\nstatic int ath6kl_cfg80211_sscan_stop(struct wiphy *wiphy,\r\nstruct net_device *dev, u64 reqid)\r\n{\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nbool stopped;\r\nstopped = __ath6kl_cfg80211_sscan_stop(vif);\r\nif (!stopped)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int ath6kl_cfg80211_set_bitrate(struct wiphy *wiphy,\r\nstruct net_device *dev,\r\nconst u8 *addr,\r\nconst struct cfg80211_bitrate_mask *mask)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(dev);\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nreturn ath6kl_wmi_set_bitrate_mask(ar->wmi, vif->fw_vif_idx,\r\nmask);\r\n}\r\nstatic int ath6kl_cfg80211_set_txe_config(struct wiphy *wiphy,\r\nstruct net_device *dev,\r\nu32 rate, u32 pkts, u32 intvl)\r\n{\r\nstruct ath6kl *ar = ath6kl_priv(dev);\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nif (vif->nw_type != INFRA_NETWORK ||\r\n!test_bit(ATH6KL_FW_CAPABILITY_TX_ERR_NOTIFY, ar->fw_capabilities))\r\nreturn -EOPNOTSUPP;\r\nif (vif->sme_state != SME_CONNECTED)\r\nreturn -ENOTCONN;\r\nvif->txe_intvl = intvl;\r\nreturn ath6kl_wmi_set_txe_notify(ar->wmi, vif->fw_vif_idx,\r\nrate, pkts, intvl);\r\n}\r\nvoid ath6kl_cfg80211_stop(struct ath6kl_vif *vif)\r\n{\r\nath6kl_cfg80211_sscan_disable(vif);\r\nswitch (vif->sme_state) {\r\ncase SME_DISCONNECTED:\r\nbreak;\r\ncase SME_CONNECTING:\r\ncfg80211_connect_result(vif->ndev, vif->bssid, NULL, 0,\r\nNULL, 0,\r\nWLAN_STATUS_UNSPECIFIED_FAILURE,\r\nGFP_KERNEL);\r\nbreak;\r\ncase SME_CONNECTED:\r\ncfg80211_disconnected(vif->ndev, 0, NULL, 0, true, GFP_KERNEL);\r\nbreak;\r\n}\r\nif (vif->ar->state != ATH6KL_STATE_RECOVERY &&\r\n(test_bit(CONNECTED, &vif->flags) ||\r\ntest_bit(CONNECT_PEND, &vif->flags)))\r\nath6kl_wmi_disconnect_cmd(vif->ar->wmi, vif->fw_vif_idx);\r\nvif->sme_state = SME_DISCONNECTED;\r\nclear_bit(CONNECTED, &vif->flags);\r\nclear_bit(CONNECT_PEND, &vif->flags);\r\nnetif_stop_queue(vif->ndev);\r\nnetif_carrier_off(vif->ndev);\r\nif (vif->ar->state != ATH6KL_STATE_RECOVERY &&\r\nath6kl_wmi_scanparams_cmd(vif->ar->wmi, vif->fw_vif_idx, 0xFFFF,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0) != 0)\r\nath6kl_warn("failed to disable scan during stop\n");\r\nath6kl_cfg80211_scan_complete_event(vif, true);\r\n}\r\nvoid ath6kl_cfg80211_stop_all(struct ath6kl *ar)\r\n{\r\nstruct ath6kl_vif *vif;\r\nvif = ath6kl_vif_first(ar);\r\nif (!vif && ar->state != ATH6KL_STATE_RECOVERY) {\r\nar->wmi->saved_pwr_mode = ar->wmi->pwr_mode;\r\nif (ath6kl_wmi_powermode_cmd(ar->wmi, 0, REC_POWER) != 0)\r\nath6kl_warn("ath6kl_deep_sleep_enable: wmi_powermode_cmd failed\n");\r\nreturn;\r\n}\r\nlist_for_each_entry(vif, &ar->vif_list, list)\r\nath6kl_cfg80211_stop(vif);\r\n}\r\nstatic void ath6kl_cfg80211_reg_notify(struct wiphy *wiphy,\r\nstruct regulatory_request *request)\r\n{\r\nstruct ath6kl *ar = wiphy_priv(wiphy);\r\nu32 rates[NUM_NL80211_BANDS];\r\nint ret, i;\r\nath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\r\n"cfg reg_notify %c%c%s%s initiator %d hint_type %d\n",\r\nrequest->alpha2[0], request->alpha2[1],\r\nrequest->intersect ? " intersect" : "",\r\nrequest->processed ? " processed" : "",\r\nrequest->initiator, request->user_reg_hint_type);\r\nif (request->user_reg_hint_type != NL80211_USER_REG_HINT_CELL_BASE)\r\nreturn;\r\nret = ath6kl_wmi_set_regdomain_cmd(ar->wmi, request->alpha2);\r\nif (ret) {\r\nath6kl_err("failed to set regdomain: %d\n", ret);\r\nreturn;\r\n}\r\nfor (i = 0; i < NUM_NL80211_BANDS; i++)\r\nif (wiphy->bands[i])\r\nrates[i] = (1 << wiphy->bands[i]->n_bitrates) - 1;\r\nret = ath6kl_wmi_beginscan_cmd(ar->wmi, 0, WMI_LONG_SCAN, false,\r\nfalse, 0, ATH6KL_FG_SCAN_INTERVAL,\r\n0, NULL, false, rates);\r\nif (ret) {\r\nath6kl_err("failed to start scan for a regdomain change: %d\n",\r\nret);\r\nreturn;\r\n}\r\n}\r\nstatic int ath6kl_cfg80211_vif_init(struct ath6kl_vif *vif)\r\n{\r\nvif->aggr_cntxt = aggr_init(vif);\r\nif (!vif->aggr_cntxt) {\r\nath6kl_err("failed to initialize aggr\n");\r\nreturn -ENOMEM;\r\n}\r\nsetup_timer(&vif->disconnect_timer, disconnect_timer_handler,\r\n(unsigned long) vif->ndev);\r\nsetup_timer(&vif->sched_scan_timer, ath6kl_wmi_sscan_timer,\r\n(unsigned long) vif);\r\nset_bit(WMM_ENABLED, &vif->flags);\r\nspin_lock_init(&vif->if_lock);\r\nINIT_LIST_HEAD(&vif->mc_filter);\r\nreturn 0;\r\n}\r\nvoid ath6kl_cfg80211_vif_stop(struct ath6kl_vif *vif, bool wmi_ready)\r\n{\r\nstatic u8 bcast_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nbool discon_issued;\r\nnetif_stop_queue(vif->ndev);\r\nclear_bit(WLAN_ENABLED, &vif->flags);\r\nif (wmi_ready) {\r\ndiscon_issued = test_bit(CONNECTED, &vif->flags) ||\r\ntest_bit(CONNECT_PEND, &vif->flags);\r\nath6kl_disconnect(vif);\r\ndel_timer(&vif->disconnect_timer);\r\nif (discon_issued)\r\nath6kl_disconnect_event(vif, DISCONNECT_CMD,\r\n(vif->nw_type & AP_NETWORK) ?\r\nbcast_mac : vif->bssid,\r\n0, NULL, 0);\r\n}\r\nif (vif->scan_req) {\r\nstruct cfg80211_scan_info info = {\r\n.aborted = true,\r\n};\r\ncfg80211_scan_done(vif->scan_req, &info);\r\nvif->scan_req = NULL;\r\n}\r\nath6kl_cfg80211_sta_bmiss_enhance(vif, false);\r\n}\r\nvoid ath6kl_cfg80211_vif_cleanup(struct ath6kl_vif *vif)\r\n{\r\nstruct ath6kl *ar = vif->ar;\r\nstruct ath6kl_mc_filter *mc_filter, *tmp;\r\naggr_module_destroy(vif->aggr_cntxt);\r\nar->avail_idx_map |= BIT(vif->fw_vif_idx);\r\nif (vif->nw_type == ADHOC_NETWORK)\r\nar->ibss_if_active = false;\r\nlist_for_each_entry_safe(mc_filter, tmp, &vif->mc_filter, list) {\r\nlist_del(&mc_filter->list);\r\nkfree(mc_filter);\r\n}\r\nunregister_netdevice(vif->ndev);\r\nar->num_vif--;\r\n}\r\nstatic int ath6kl_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nint rv = 0;\r\nif (sset == ETH_SS_STATS)\r\nrv += ATH6KL_STATS_LEN;\r\nif (rv == 0)\r\nreturn -EOPNOTSUPP;\r\nreturn rv;\r\n}\r\nstatic void ath6kl_get_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats,\r\nu64 *data)\r\n{\r\nstruct ath6kl_vif *vif = netdev_priv(dev);\r\nstruct ath6kl *ar = vif->ar;\r\nint i = 0;\r\nstruct target_stats *tgt_stats;\r\nmemset(data, 0, sizeof(u64) * ATH6KL_STATS_LEN);\r\nath6kl_read_tgt_stats(ar, vif);\r\ntgt_stats = &vif->target_stats;\r\ndata[i++] = tgt_stats->tx_ucast_pkt + tgt_stats->tx_bcast_pkt;\r\ndata[i++] = tgt_stats->tx_ucast_byte + tgt_stats->tx_bcast_byte;\r\ndata[i++] = tgt_stats->rx_ucast_pkt + tgt_stats->rx_bcast_pkt;\r\ndata[i++] = tgt_stats->rx_ucast_byte + tgt_stats->rx_bcast_byte;\r\ndata[i++] = tgt_stats->tx_ucast_pkt;\r\ndata[i++] = tgt_stats->tx_bcast_pkt;\r\ndata[i++] = tgt_stats->tx_ucast_byte;\r\ndata[i++] = tgt_stats->tx_bcast_byte;\r\ndata[i++] = tgt_stats->tx_rts_success_cnt;\r\ndata[i++] = tgt_stats->tx_err;\r\ndata[i++] = tgt_stats->tx_fail_cnt;\r\ndata[i++] = tgt_stats->tx_retry_cnt;\r\ndata[i++] = tgt_stats->tx_mult_retry_cnt;\r\ndata[i++] = tgt_stats->tx_rts_fail_cnt;\r\ndata[i++] = tgt_stats->tkip_cnter_measures_invoked;\r\ndata[i++] = tgt_stats->rx_ucast_pkt;\r\ndata[i++] = tgt_stats->rx_ucast_rate;\r\ndata[i++] = tgt_stats->rx_bcast_pkt;\r\ndata[i++] = tgt_stats->rx_ucast_byte;\r\ndata[i++] = tgt_stats->rx_bcast_byte;\r\ndata[i++] = tgt_stats->rx_frgment_pkt;\r\ndata[i++] = tgt_stats->rx_err;\r\ndata[i++] = tgt_stats->rx_crc_err;\r\ndata[i++] = tgt_stats->rx_key_cache_miss;\r\ndata[i++] = tgt_stats->rx_decrypt_err;\r\ndata[i++] = tgt_stats->rx_dupl_frame;\r\ndata[i++] = tgt_stats->tkip_local_mic_fail;\r\ndata[i++] = tgt_stats->tkip_fmt_err;\r\ndata[i++] = tgt_stats->ccmp_fmt_err;\r\ndata[i++] = tgt_stats->ccmp_replays;\r\ndata[i++] = tgt_stats->cs_bmiss_cnt;\r\ndata[i++] = tgt_stats->cs_connect_cnt;\r\ndata[i++] = tgt_stats->cs_discon_cnt;\r\ndata[i++] = tgt_stats->cs_ave_beacon_rssi;\r\ndata[i++] = tgt_stats->arp_received;\r\ndata[i++] = tgt_stats->arp_matched;\r\ndata[i++] = tgt_stats->arp_replied;\r\nif (i != ATH6KL_STATS_LEN) {\r\nWARN_ON_ONCE(1);\r\nath6kl_err("ethtool stats error, i: %d STATS_LEN: %d\n",\r\ni, (int)ATH6KL_STATS_LEN);\r\n}\r\n}\r\nstatic void ath6kl_get_strings(struct net_device *dev, u32 sset, u8 *data)\r\n{\r\nint sz_sta_stats = 0;\r\nif (sset == ETH_SS_STATS) {\r\nsz_sta_stats = sizeof(ath6kl_gstrings_sta_stats);\r\nmemcpy(data, ath6kl_gstrings_sta_stats, sz_sta_stats);\r\n}\r\n}\r\nstruct wireless_dev *ath6kl_interface_add(struct ath6kl *ar, const char *name,\r\nunsigned char name_assign_type,\r\nenum nl80211_iftype type,\r\nu8 fw_vif_idx, u8 nw_type)\r\n{\r\nstruct net_device *ndev;\r\nstruct ath6kl_vif *vif;\r\nndev = alloc_netdev(sizeof(*vif), name, name_assign_type, ether_setup);\r\nif (!ndev)\r\nreturn NULL;\r\nvif = netdev_priv(ndev);\r\nndev->ieee80211_ptr = &vif->wdev;\r\nvif->wdev.wiphy = ar->wiphy;\r\nvif->ar = ar;\r\nvif->ndev = ndev;\r\nSET_NETDEV_DEV(ndev, wiphy_dev(vif->wdev.wiphy));\r\nvif->wdev.netdev = ndev;\r\nvif->wdev.iftype = type;\r\nvif->fw_vif_idx = fw_vif_idx;\r\nvif->nw_type = nw_type;\r\nvif->next_mode = nw_type;\r\nvif->listen_intvl_t = ATH6KL_DEFAULT_LISTEN_INTVAL;\r\nvif->bmiss_time_t = ATH6KL_DEFAULT_BMISS_TIME;\r\nvif->bg_scan_period = 0;\r\nvif->htcap[NL80211_BAND_2GHZ].ht_enable = true;\r\nvif->htcap[NL80211_BAND_5GHZ].ht_enable = true;\r\nmemcpy(ndev->dev_addr, ar->mac_addr, ETH_ALEN);\r\nif (fw_vif_idx != 0) {\r\nndev->dev_addr[0] = (ndev->dev_addr[0] ^ (1 << fw_vif_idx)) |\r\n0x2;\r\nif (test_bit(ATH6KL_FW_CAPABILITY_CUSTOM_MAC_ADDR,\r\nar->fw_capabilities))\r\nndev->dev_addr[4] ^= 0x80;\r\n}\r\ninit_netdev(ndev);\r\nath6kl_init_control_info(vif);\r\nif (ath6kl_cfg80211_vif_init(vif))\r\ngoto err;\r\nnetdev_set_default_ethtool_ops(ndev, &ath6kl_ethtool_ops);\r\nif (register_netdevice(ndev))\r\ngoto err;\r\nar->avail_idx_map &= ~BIT(fw_vif_idx);\r\nvif->sme_state = SME_DISCONNECTED;\r\nset_bit(WLAN_ENABLED, &vif->flags);\r\nar->wlan_pwr_state = WLAN_POWER_STATE_ON;\r\nif (type == NL80211_IFTYPE_ADHOC)\r\nar->ibss_if_active = true;\r\nspin_lock_bh(&ar->list_lock);\r\nlist_add_tail(&vif->list, &ar->vif_list);\r\nspin_unlock_bh(&ar->list_lock);\r\nreturn &vif->wdev;\r\nerr:\r\naggr_module_destroy(vif->aggr_cntxt);\r\nfree_netdev(ndev);\r\nreturn NULL;\r\n}\r\nint ath6kl_cfg80211_init(struct ath6kl *ar)\r\n{\r\nstruct wiphy *wiphy = ar->wiphy;\r\nbool band_2gig = false, band_5gig = false, ht = false;\r\nint ret;\r\nwiphy->mgmt_stypes = ath6kl_mgmt_stypes;\r\nwiphy->max_remain_on_channel_duration = 5000;\r\nset_wiphy_dev(wiphy, ar->dev);\r\nwiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\r\nBIT(NL80211_IFTYPE_ADHOC) |\r\nBIT(NL80211_IFTYPE_AP);\r\nif (ar->p2p) {\r\nwiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_GO) |\r\nBIT(NL80211_IFTYPE_P2P_CLIENT);\r\n}\r\nif (IS_ENABLED(CONFIG_ATH6KL_REGDOMAIN) &&\r\ntest_bit(ATH6KL_FW_CAPABILITY_REGDOMAIN, ar->fw_capabilities)) {\r\nwiphy->reg_notifier = ath6kl_cfg80211_reg_notify;\r\nar->wiphy->features |= NL80211_FEATURE_CELL_BASE_REG_HINTS;\r\n}\r\nwiphy->max_scan_ssids = MAX_PROBED_SSIDS;\r\nif (test_bit(ATH6KL_FW_CAPABILITY_SCHED_SCAN_MATCH_LIST,\r\nar->fw_capabilities))\r\nwiphy->max_match_sets = MAX_PROBED_SSIDS;\r\nwiphy->max_scan_ie_len = 1000;\r\nswitch (ar->hw.cap) {\r\ncase WMI_11AN_CAP:\r\nht = true;\r\ncase WMI_11A_CAP:\r\nband_5gig = true;\r\nbreak;\r\ncase WMI_11GN_CAP:\r\nht = true;\r\ncase WMI_11G_CAP:\r\nband_2gig = true;\r\nbreak;\r\ncase WMI_11AGN_CAP:\r\nht = true;\r\ncase WMI_11AG_CAP:\r\nband_2gig = true;\r\nband_5gig = true;\r\nbreak;\r\ndefault:\r\nath6kl_err("invalid phy capability!\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(ht &&\r\ntest_bit(ATH6KL_FW_CAPABILITY_RSN_CAP_OVERRIDE,\r\nar->fw_capabilities))) {\r\nath6kl_band_2ghz.ht_cap.cap = 0;\r\nath6kl_band_2ghz.ht_cap.ht_supported = false;\r\nath6kl_band_5ghz.ht_cap.cap = 0;\r\nath6kl_band_5ghz.ht_cap.ht_supported = false;\r\nif (ht)\r\nath6kl_err("Firmware lacks RSN-CAP-OVERRIDE, so HT (802.11n) is disabled.");\r\n}\r\nif (test_bit(ATH6KL_FW_CAPABILITY_64BIT_RATES,\r\nar->fw_capabilities)) {\r\nath6kl_band_2ghz.ht_cap.mcs.rx_mask[0] = 0xff;\r\nath6kl_band_5ghz.ht_cap.mcs.rx_mask[0] = 0xff;\r\nath6kl_band_2ghz.ht_cap.mcs.rx_mask[1] = 0xff;\r\nath6kl_band_5ghz.ht_cap.mcs.rx_mask[1] = 0xff;\r\nar->hw.tx_ant = 0x3;\r\nar->hw.rx_ant = 0x3;\r\n} else {\r\nath6kl_band_2ghz.ht_cap.mcs.rx_mask[0] = 0xff;\r\nath6kl_band_5ghz.ht_cap.mcs.rx_mask[0] = 0xff;\r\nar->hw.tx_ant = 1;\r\nar->hw.rx_ant = 1;\r\n}\r\nwiphy->available_antennas_tx = ar->hw.tx_ant;\r\nwiphy->available_antennas_rx = ar->hw.rx_ant;\r\nif (band_2gig)\r\nwiphy->bands[NL80211_BAND_2GHZ] = &ath6kl_band_2ghz;\r\nif (band_5gig)\r\nwiphy->bands[NL80211_BAND_5GHZ] = &ath6kl_band_5ghz;\r\nwiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\r\nwiphy->cipher_suites = cipher_suites;\r\nwiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);\r\n#ifdef CONFIG_PM\r\nwiphy->wowlan = &ath6kl_wowlan_support;\r\n#endif\r\nwiphy->max_sched_scan_ssids = MAX_PROBED_SSIDS;\r\nar->wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM |\r\nWIPHY_FLAG_HAVE_AP_SME |\r\nWIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |\r\nWIPHY_FLAG_AP_PROBE_RESP_OFFLOAD;\r\nif (test_bit(ATH6KL_FW_CAPABILITY_SCHED_SCAN_V2, ar->fw_capabilities))\r\nar->wiphy->max_sched_scan_reqs = 1;\r\nif (test_bit(ATH6KL_FW_CAPABILITY_INACTIVITY_TIMEOUT,\r\nar->fw_capabilities))\r\nar->wiphy->features |= NL80211_FEATURE_INACTIVITY_TIMER;\r\nar->wiphy->probe_resp_offload =\r\nNL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS |\r\nNL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2 |\r\nNL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P;\r\nret = wiphy_register(wiphy);\r\nif (ret < 0) {\r\nath6kl_err("couldn't register wiphy device\n");\r\nreturn ret;\r\n}\r\nar->wiphy_registered = true;\r\nreturn 0;\r\n}\r\nvoid ath6kl_cfg80211_cleanup(struct ath6kl *ar)\r\n{\r\nwiphy_unregister(ar->wiphy);\r\nar->wiphy_registered = false;\r\n}\r\nstruct ath6kl *ath6kl_cfg80211_create(void)\r\n{\r\nstruct ath6kl *ar;\r\nstruct wiphy *wiphy;\r\nwiphy = wiphy_new(&ath6kl_cfg80211_ops, sizeof(struct ath6kl));\r\nif (!wiphy) {\r\nath6kl_err("couldn't allocate wiphy device\n");\r\nreturn NULL;\r\n}\r\nar = wiphy_priv(wiphy);\r\nar->wiphy = wiphy;\r\nreturn ar;\r\n}\r\nvoid ath6kl_cfg80211_destroy(struct ath6kl *ar)\r\n{\r\nint i;\r\nfor (i = 0; i < AP_MAX_NUM_STA; i++)\r\nkfree(ar->sta_list[i].aggr_conn);\r\nwiphy_free(ar->wiphy);\r\n}
