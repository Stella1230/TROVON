static int iio_loop_thread(void *data)\r\n{\r\nstruct iio_trigger *trig = data;\r\nset_freezable();\r\ndo {\r\niio_trigger_poll_chained(trig);\r\n} while (likely(!kthread_freezable_should_stop(NULL)));\r\nreturn 0;\r\n}\r\nstatic int iio_loop_trigger_set_state(struct iio_trigger *trig, bool state)\r\n{\r\nstruct iio_loop_info *loop_trig = iio_trigger_get_drvdata(trig);\r\nif (state) {\r\nloop_trig->task = kthread_run(iio_loop_thread,\r\ntrig, trig->name);\r\nif (unlikely(IS_ERR(loop_trig->task))) {\r\ndev_err(&trig->dev,\r\n"failed to create trigger loop thread\n");\r\nreturn PTR_ERR(loop_trig->task);\r\n}\r\n} else {\r\nkthread_stop(loop_trig->task);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct iio_sw_trigger *iio_trig_loop_probe(const char *name)\r\n{\r\nstruct iio_loop_info *trig_info;\r\nint ret;\r\ntrig_info = kzalloc(sizeof(*trig_info), GFP_KERNEL);\r\nif (!trig_info)\r\nreturn ERR_PTR(-ENOMEM);\r\ntrig_info->swt.trigger = iio_trigger_alloc("%s", name);\r\nif (!trig_info->swt.trigger) {\r\nret = -ENOMEM;\r\ngoto err_free_trig_info;\r\n}\r\niio_trigger_set_drvdata(trig_info->swt.trigger, trig_info);\r\ntrig_info->swt.trigger->ops = &iio_loop_trigger_ops;\r\nret = iio_trigger_register(trig_info->swt.trigger);\r\nif (ret)\r\ngoto err_free_trigger;\r\niio_swt_group_init_type_name(&trig_info->swt, name, &iio_loop_type);\r\nreturn &trig_info->swt;\r\nerr_free_trigger:\r\niio_trigger_free(trig_info->swt.trigger);\r\nerr_free_trig_info:\r\nkfree(trig_info);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int iio_trig_loop_remove(struct iio_sw_trigger *swt)\r\n{\r\nstruct iio_loop_info *trig_info;\r\ntrig_info = iio_trigger_get_drvdata(swt->trigger);\r\niio_trigger_unregister(swt->trigger);\r\niio_trigger_free(swt->trigger);\r\nkfree(trig_info);\r\nreturn 0;\r\n}
