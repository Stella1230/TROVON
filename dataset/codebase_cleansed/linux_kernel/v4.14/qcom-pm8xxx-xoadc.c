static irqreturn_t pm8xxx_eoc_irq(int irq, void *d)\r\n{\r\nstruct iio_dev *indio_dev = d;\r\nstruct pm8xxx_xoadc *adc = iio_priv(indio_dev);\r\ncomplete(&adc->complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct pm8xxx_chan_info *\r\npm8xxx_get_channel(struct pm8xxx_xoadc *adc, u8 chan)\r\n{\r\nstruct pm8xxx_chan_info *ch;\r\nint i;\r\nfor (i = 0; i < adc->nchans; i++) {\r\nch = &adc->chans[i];\r\nif (ch->hwchan->amux_channel == chan)\r\nbreak;\r\n}\r\nif (i == adc->nchans)\r\nreturn NULL;\r\nreturn ch;\r\n}\r\nstatic int pm8xxx_read_channel_rsv(struct pm8xxx_xoadc *adc,\r\nconst struct pm8xxx_chan_info *ch,\r\nu8 rsv, u16 *adc_code,\r\nbool force_ratiometric)\r\n{\r\nint ret;\r\nunsigned int val;\r\nu8 rsvmask, rsvval;\r\nu8 lsb, msb;\r\ndev_dbg(adc->dev, "read channel \"%s\", amux %d, prescale/mux: %d, rsv %d\n",\r\nch->name, ch->hwchan->amux_channel, ch->hwchan->pre_scale_mux, rsv);\r\nmutex_lock(&adc->lock);\r\nval = ch->hwchan->amux_channel << ADC_AMUX_SEL_SHIFT;\r\nval |= ch->hwchan->pre_scale_mux << ADC_AMUX_PREMUX_SHIFT;\r\nret = regmap_write(adc->map, ADC_ARB_USRP_AMUX_CNTRL, val);\r\nif (ret)\r\ngoto unlock;\r\nrsvmask = (ADC_ARB_USRP_RSV_RST | ADC_ARB_USRP_RSV_DTEST0 |\r\nADC_ARB_USRP_RSV_DTEST1 | ADC_ARB_USRP_RSV_OP);\r\nif (adc->variant->broken_ratiometric && !force_ratiometric) {\r\nif (ch->hwchan->amux_channel == PM8XXX_CHANNEL_MUXOFF)\r\nrsvval = ADC_ARB_USRP_RSV_IP_SEL0;\r\nelse\r\nrsvval = ADC_ARB_USRP_RSV_IP_SEL1;\r\n} else {\r\nif (rsv == 0xff)\r\nrsvval = (ch->amux_ip_rsv << ADC_RSV_IP_SEL_SHIFT) |\r\nADC_ARB_USRP_RSV_TRM;\r\nelse\r\nrsvval = (rsv << ADC_RSV_IP_SEL_SHIFT) |\r\nADC_ARB_USRP_RSV_TRM;\r\n}\r\nret = regmap_update_bits(adc->map,\r\nADC_ARB_USRP_RSV,\r\n~rsvmask,\r\nrsvval);\r\nif (ret)\r\ngoto unlock;\r\nret = regmap_write(adc->map, ADC_ARB_USRP_ANA_PARAM,\r\nADC_ARB_USRP_ANA_PARAM_DIS);\r\nif (ret)\r\ngoto unlock;\r\nret = regmap_write(adc->map, ADC_ARB_USRP_DIG_PARAM,\r\nADC_ARB_USRP_DIG_PARAM_SEL_SHIFT0 |\r\nADC_ARB_USRP_DIG_PARAM_SEL_SHIFT1 |\r\nch->decimation << ADC_DIG_PARAM_DEC_SHIFT);\r\nif (ret)\r\ngoto unlock;\r\nret = regmap_write(adc->map, ADC_ARB_USRP_ANA_PARAM,\r\nADC_ARB_USRP_ANA_PARAM_EN);\r\nif (ret)\r\ngoto unlock;\r\nret = regmap_write(adc->map, ADC_ARB_USRP_CNTRL,\r\nADC_ARB_USRP_CNTRL_EN_ARB);\r\nif (ret)\r\ngoto unlock;\r\nret = regmap_write(adc->map, ADC_ARB_USRP_CNTRL,\r\nADC_ARB_USRP_CNTRL_EN_ARB);\r\nif (ret)\r\ngoto unlock;\r\nreinit_completion(&adc->complete);\r\nret = regmap_write(adc->map, ADC_ARB_USRP_CNTRL,\r\nADC_ARB_USRP_CNTRL_EN_ARB |\r\nADC_ARB_USRP_CNTRL_REQ);\r\nif (ret)\r\ngoto unlock;\r\nret = wait_for_completion_timeout(&adc->complete,\r\nVADC_CONV_TIME_MAX_US);\r\nif (!ret) {\r\ndev_err(adc->dev, "conversion timed out\n");\r\nret = -ETIMEDOUT;\r\ngoto unlock;\r\n}\r\nret = regmap_read(adc->map, ADC_ARB_USRP_DATA0, &val);\r\nif (ret)\r\ngoto unlock;\r\nlsb = val;\r\nret = regmap_read(adc->map, ADC_ARB_USRP_DATA1, &val);\r\nif (ret)\r\ngoto unlock;\r\nmsb = val;\r\n*adc_code = (msb << 8) | lsb;\r\nret = regmap_write(adc->map, ADC_ARB_USRP_CNTRL, 0);\r\nif (ret)\r\ngoto unlock;\r\nret = regmap_write(adc->map, ADC_ARB_USRP_CNTRL, 0);\r\nif (ret)\r\ngoto unlock;\r\nunlock:\r\nmutex_unlock(&adc->lock);\r\nreturn ret;\r\n}\r\nstatic int pm8xxx_read_channel(struct pm8xxx_xoadc *adc,\r\nconst struct pm8xxx_chan_info *ch,\r\nu16 *adc_code)\r\n{\r\nreturn pm8xxx_read_channel_rsv(adc, ch, 0xff, adc_code, false);\r\n}\r\nstatic int pm8xxx_calibrate_device(struct pm8xxx_xoadc *adc)\r\n{\r\nconst struct pm8xxx_chan_info *ch;\r\nu16 read_1250v;\r\nu16 read_0625v;\r\nu16 read_nomux_rsv5;\r\nu16 read_nomux_rsv4;\r\nint ret;\r\nadc->graph[VADC_CALIB_ABSOLUTE].dx = VADC_ABSOLUTE_RANGE_UV;\r\nadc->graph[VADC_CALIB_RATIOMETRIC].dx = VADC_RATIOMETRIC_RANGE;\r\nch = pm8xxx_get_channel(adc, PM8XXX_CHANNEL_125V);\r\nif (!ch)\r\nreturn -ENODEV;\r\nret = pm8xxx_read_channel(adc, ch, &read_1250v);\r\nif (ret) {\r\ndev_err(adc->dev, "could not read 1.25V reference channel\n");\r\nreturn -ENODEV;\r\n}\r\nch = pm8xxx_get_channel(adc, PM8XXX_CHANNEL_INTERNAL);\r\nif (!ch)\r\nreturn -ENODEV;\r\nret = pm8xxx_read_channel(adc, ch, &read_0625v);\r\nif (ret) {\r\ndev_err(adc->dev, "could not read 0.625V reference channel\n");\r\nreturn -ENODEV;\r\n}\r\nif (read_1250v == read_0625v) {\r\ndev_err(adc->dev, "read same ADC code for 1.25V and 0.625V\n");\r\nreturn -ENODEV;\r\n}\r\nadc->graph[VADC_CALIB_ABSOLUTE].dy = read_1250v - read_0625v;\r\nadc->graph[VADC_CALIB_ABSOLUTE].gnd = read_0625v;\r\ndev_info(adc->dev, "absolute calibration dx = %d uV, dy = %d units\n",\r\nVADC_ABSOLUTE_RANGE_UV, adc->graph[VADC_CALIB_ABSOLUTE].dy);\r\nch = pm8xxx_get_channel(adc, PM8XXX_CHANNEL_MUXOFF);\r\nif (!ch)\r\nreturn -ENODEV;\r\nret = pm8xxx_read_channel_rsv(adc, ch, AMUX_RSV5,\r\n&read_nomux_rsv5, true);\r\nif (ret) {\r\ndev_err(adc->dev, "could not read MUXOFF reference channel\n");\r\nreturn -ENODEV;\r\n}\r\nret = pm8xxx_read_channel_rsv(adc, ch, AMUX_RSV4,\r\n&read_nomux_rsv4, true);\r\nif (ret) {\r\ndev_err(adc->dev, "could not read MUXOFF reference channel\n");\r\nreturn -ENODEV;\r\n}\r\nadc->graph[VADC_CALIB_RATIOMETRIC].dy =\r\nread_nomux_rsv5 - read_nomux_rsv4;\r\nadc->graph[VADC_CALIB_RATIOMETRIC].gnd = read_nomux_rsv4;\r\ndev_info(adc->dev, "ratiometric calibration dx = %d, dy = %d units\n",\r\nVADC_RATIOMETRIC_RANGE,\r\nadc->graph[VADC_CALIB_RATIOMETRIC].dy);\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct pm8xxx_xoadc *adc = iio_priv(indio_dev);\r\nconst struct pm8xxx_chan_info *ch;\r\nu16 adc_code;\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nch = pm8xxx_get_channel(adc, chan->address);\r\nif (!ch) {\r\ndev_err(adc->dev, "no such channel %lu\n",\r\nchan->address);\r\nreturn -EINVAL;\r\n}\r\nret = pm8xxx_read_channel(adc, ch, &adc_code);\r\nif (ret)\r\nreturn ret;\r\nret = qcom_vadc_scale(ch->hwchan->scale_fn_type,\r\n&adc->graph[ch->calibration],\r\n&ch->hwchan->prescale,\r\n(ch->calibration == VADC_CALIB_ABSOLUTE),\r\nadc_code, val);\r\nif (ret)\r\nreturn ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_RAW:\r\nch = pm8xxx_get_channel(adc, chan->address);\r\nif (!ch) {\r\ndev_err(adc->dev, "no such channel %lu\n",\r\nchan->address);\r\nreturn -EINVAL;\r\n}\r\nret = pm8xxx_read_channel(adc, ch, &adc_code);\r\nif (ret)\r\nreturn ret;\r\n*val = (int)adc_code;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int pm8xxx_of_xlate(struct iio_dev *indio_dev,\r\nconst struct of_phandle_args *iiospec)\r\n{\r\nstruct pm8xxx_xoadc *adc = iio_priv(indio_dev);\r\nu8 pre_scale_mux;\r\nu8 amux_channel;\r\nunsigned int i;\r\nif (iiospec->args_count != 2) {\r\ndev_err(&indio_dev->dev, "wrong number of arguments for %s need 2 got %d\n",\r\niiospec->np->name,\r\niiospec->args_count);\r\nreturn -EINVAL;\r\n}\r\npre_scale_mux = (u8)iiospec->args[0];\r\namux_channel = (u8)iiospec->args[1];\r\ndev_dbg(&indio_dev->dev, "pre scale/mux: %02x, amux: %02x\n",\r\npre_scale_mux, amux_channel);\r\nfor (i = 0; i < adc->nchans; i++)\r\nif (adc->chans[i].hwchan->pre_scale_mux == pre_scale_mux &&\r\nadc->chans[i].hwchan->amux_channel == amux_channel)\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic int pm8xxx_xoadc_parse_channel(struct device *dev,\r\nstruct device_node *np,\r\nconst struct xoadc_channel *hw_channels,\r\nstruct iio_chan_spec *iio_chan,\r\nstruct pm8xxx_chan_info *ch)\r\n{\r\nconst char *name = np->name;\r\nconst struct xoadc_channel *hwchan;\r\nu32 pre_scale_mux, amux_channel;\r\nu32 rsv, dec;\r\nint ret;\r\nint chid;\r\nret = of_property_read_u32_index(np, "reg", 0, &pre_scale_mux);\r\nif (ret) {\r\ndev_err(dev, "invalid pre scale/mux number %s\n", name);\r\nreturn ret;\r\n}\r\nret = of_property_read_u32_index(np, "reg", 1, &amux_channel);\r\nif (ret) {\r\ndev_err(dev, "invalid amux channel number %s\n", name);\r\nreturn ret;\r\n}\r\nchid = 0;\r\nhwchan = &hw_channels[0];\r\nwhile (hwchan && hwchan->datasheet_name) {\r\nif (hwchan->pre_scale_mux == pre_scale_mux &&\r\nhwchan->amux_channel == amux_channel)\r\nbreak;\r\nhwchan++;\r\nchid++;\r\n}\r\nif (!hwchan->datasheet_name) {\r\ndev_err(dev, "could not locate channel %02x/%02x\n",\r\npre_scale_mux, amux_channel);\r\nreturn -EINVAL;\r\n}\r\nch->name = name;\r\nch->hwchan = hwchan;\r\nch->calibration = VADC_CALIB_ABSOLUTE;\r\nch->decimation = VADC_DEF_DECIMATION;\r\nif (!of_property_read_u32(np, "qcom,ratiometric", &rsv)) {\r\nch->calibration = VADC_CALIB_RATIOMETRIC;\r\nif (rsv > XOADC_RSV_MAX) {\r\ndev_err(dev, "%s too large RSV value %d\n", name, rsv);\r\nreturn -EINVAL;\r\n}\r\nif (rsv == AMUX_RSV3) {\r\ndev_err(dev, "%s invalid RSV value %d\n", name, rsv);\r\nreturn -EINVAL;\r\n}\r\n}\r\nret = of_property_read_u32(np, "qcom,decimation", &dec);\r\nif (!ret) {\r\nret = qcom_vadc_decimation_from_dt(dec);\r\nif (ret < 0) {\r\ndev_err(dev, "%s invalid decimation %d\n",\r\nname, dec);\r\nreturn ret;\r\n}\r\nch->decimation = ret;\r\n}\r\niio_chan->channel = chid;\r\niio_chan->address = hwchan->amux_channel;\r\niio_chan->datasheet_name = hwchan->datasheet_name;\r\niio_chan->type = hwchan->type;\r\niio_chan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\r\nBIT(IIO_CHAN_INFO_PROCESSED);\r\niio_chan->indexed = 1;\r\ndev_dbg(dev, "channel [PRESCALE/MUX: %02x AMUX: %02x] \"%s\" "\r\n"ref voltage: %d, decimation %d "\r\n"prescale %d/%d, scale function %d\n",\r\nhwchan->pre_scale_mux, hwchan->amux_channel, ch->name,\r\nch->amux_ip_rsv, ch->decimation, hwchan->prescale.num,\r\nhwchan->prescale.den, hwchan->scale_fn_type);\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_xoadc_parse_channels(struct pm8xxx_xoadc *adc,\r\nstruct device_node *np)\r\n{\r\nstruct device_node *child;\r\nstruct pm8xxx_chan_info *ch;\r\nint ret;\r\nint i;\r\nadc->nchans = of_get_available_child_count(np);\r\nif (!adc->nchans) {\r\ndev_err(adc->dev, "no channel children\n");\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(adc->dev, "found %d ADC channels\n", adc->nchans);\r\nadc->iio_chans = devm_kcalloc(adc->dev, adc->nchans,\r\nsizeof(*adc->iio_chans), GFP_KERNEL);\r\nif (!adc->iio_chans)\r\nreturn -ENOMEM;\r\nadc->chans = devm_kcalloc(adc->dev, adc->nchans,\r\nsizeof(*adc->chans), GFP_KERNEL);\r\nif (!adc->chans)\r\nreturn -ENOMEM;\r\ni = 0;\r\nfor_each_available_child_of_node(np, child) {\r\nch = &adc->chans[i];\r\nret = pm8xxx_xoadc_parse_channel(adc->dev, child,\r\nadc->variant->channels,\r\n&adc->iio_chans[i],\r\nch);\r\nif (ret) {\r\nof_node_put(child);\r\nreturn ret;\r\n}\r\ni++;\r\n}\r\nch = pm8xxx_get_channel(adc, PM8XXX_CHANNEL_125V);\r\nif (!ch) {\r\ndev_err(adc->dev, "missing 1.25V reference channel\n");\r\nreturn -ENODEV;\r\n}\r\nch = pm8xxx_get_channel(adc, PM8XXX_CHANNEL_INTERNAL);\r\nif (!ch) {\r\ndev_err(adc->dev, "missing 0.625V reference channel\n");\r\nreturn -ENODEV;\r\n}\r\nch = pm8xxx_get_channel(adc, PM8XXX_CHANNEL_MUXOFF);\r\nif (!ch) {\r\ndev_err(adc->dev, "missing MUXOFF reference channel\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_xoadc_probe(struct platform_device *pdev)\r\n{\r\nconst struct xoadc_variant *variant;\r\nstruct pm8xxx_xoadc *adc;\r\nstruct iio_dev *indio_dev;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct regmap *map;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nvariant = of_device_get_match_data(dev);\r\nif (!variant)\r\nreturn -ENODEV;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(*adc));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, indio_dev);\r\nadc = iio_priv(indio_dev);\r\nadc->dev = dev;\r\nadc->variant = variant;\r\ninit_completion(&adc->complete);\r\nmutex_init(&adc->lock);\r\nret = pm8xxx_xoadc_parse_channels(adc, np);\r\nif (ret)\r\nreturn ret;\r\nmap = dev_get_regmap(dev->parent, NULL);\r\nif (!map) {\r\ndev_err(dev, "parent regmap unavailable.\n");\r\nreturn -ENXIO;\r\n}\r\nadc->map = map;\r\nadc->vref = devm_regulator_get(dev, "xoadc-ref");\r\nif (IS_ERR(adc->vref)) {\r\ndev_err(dev, "failed to get XOADC VREF regulator\n");\r\nreturn PTR_ERR(adc->vref);\r\n}\r\nret = regulator_enable(adc->vref);\r\nif (ret) {\r\ndev_err(dev, "failed to enable XOADC VREF regulator\n");\r\nreturn ret;\r\n}\r\nret = devm_request_threaded_irq(dev, platform_get_irq(pdev, 0),\r\npm8xxx_eoc_irq, NULL, 0, variant->name, indio_dev);\r\nif (ret) {\r\ndev_err(dev, "unable to request IRQ\n");\r\ngoto out_disable_vref;\r\n}\r\nindio_dev->dev.parent = dev;\r\nindio_dev->dev.of_node = np;\r\nindio_dev->name = variant->name;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &pm8xxx_xoadc_info;\r\nindio_dev->channels = adc->iio_chans;\r\nindio_dev->num_channels = adc->nchans;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto out_disable_vref;\r\nret = pm8xxx_calibrate_device(adc);\r\nif (ret)\r\ngoto out_unreg_device;\r\ndev_info(dev, "%s XOADC driver enabled\n", variant->name);\r\nreturn 0;\r\nout_unreg_device:\r\niio_device_unregister(indio_dev);\r\nout_disable_vref:\r\nregulator_disable(adc->vref);\r\nreturn ret;\r\n}\r\nstatic int pm8xxx_xoadc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct pm8xxx_xoadc *adc = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nregulator_disable(adc->vref);\r\nreturn 0;\r\n}
