static int i2c_acpi_fill_info(struct acpi_resource *ares, void *data)\r\n{\r\nstruct i2c_acpi_lookup *lookup = data;\r\nstruct i2c_board_info *info = lookup->info;\r\nstruct acpi_resource_i2c_serialbus *sb;\r\nacpi_status status;\r\nif (info->addr || ares->type != ACPI_RESOURCE_TYPE_SERIAL_BUS)\r\nreturn 1;\r\nsb = &ares->data.i2c_serial_bus;\r\nif (sb->type != ACPI_RESOURCE_SERIAL_TYPE_I2C)\r\nreturn 1;\r\nif (lookup->index != -1 && lookup->n++ != lookup->index)\r\nreturn 1;\r\nstatus = acpi_get_handle(lookup->device_handle,\r\nsb->resource_source.string_ptr,\r\n&lookup->adapter_handle);\r\nif (!ACPI_SUCCESS(status))\r\nreturn 1;\r\ninfo->addr = sb->slave_address;\r\nlookup->speed = sb->connection_speed;\r\nif (sb->access_mode == ACPI_I2C_10BIT_MODE)\r\ninfo->flags |= I2C_CLIENT_TEN;\r\nreturn 1;\r\n}\r\nstatic int i2c_acpi_do_lookup(struct acpi_device *adev,\r\nstruct i2c_acpi_lookup *lookup)\r\n{\r\nstruct i2c_board_info *info = lookup->info;\r\nstruct list_head resource_list;\r\nint ret;\r\nif (acpi_bus_get_status(adev) || !adev->status.present ||\r\nacpi_device_enumerated(adev))\r\nreturn -EINVAL;\r\nif (acpi_match_device_ids(adev, i2c_acpi_ignored_device_ids) == 0)\r\nreturn -ENODEV;\r\nmemset(info, 0, sizeof(*info));\r\nlookup->device_handle = acpi_device_handle(adev);\r\nINIT_LIST_HEAD(&resource_list);\r\nret = acpi_dev_get_resources(adev, &resource_list,\r\ni2c_acpi_fill_info, lookup);\r\nacpi_dev_free_resource_list(&resource_list);\r\nif (ret < 0 || !info->addr)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int i2c_acpi_get_info(struct acpi_device *adev,\r\nstruct i2c_board_info *info,\r\nstruct i2c_adapter *adapter,\r\nacpi_handle *adapter_handle)\r\n{\r\nstruct list_head resource_list;\r\nstruct resource_entry *entry;\r\nstruct i2c_acpi_lookup lookup;\r\nint ret;\r\nmemset(&lookup, 0, sizeof(lookup));\r\nlookup.info = info;\r\nlookup.index = -1;\r\nret = i2c_acpi_do_lookup(adev, &lookup);\r\nif (ret)\r\nreturn ret;\r\nif (adapter) {\r\nif (ACPI_HANDLE(&adapter->dev) != lookup.adapter_handle)\r\nreturn -ENODEV;\r\n} else {\r\nstruct acpi_device *adapter_adev;\r\nif (acpi_bus_get_device(lookup.adapter_handle, &adapter_adev))\r\nreturn -ENODEV;\r\nif (acpi_bus_get_status(adapter_adev) ||\r\n!adapter_adev->status.present)\r\nreturn -ENODEV;\r\n}\r\ninfo->fwnode = acpi_fwnode_handle(adev);\r\nif (adapter_handle)\r\n*adapter_handle = lookup.adapter_handle;\r\nINIT_LIST_HEAD(&resource_list);\r\nret = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nresource_list_for_each_entry(entry, &resource_list) {\r\nif (resource_type(entry->res) == IORESOURCE_IRQ) {\r\ninfo->irq = entry->res->start;\r\nbreak;\r\n}\r\n}\r\nacpi_dev_free_resource_list(&resource_list);\r\nacpi_set_modalias(adev, dev_name(&adev->dev), info->type,\r\nsizeof(info->type));\r\nreturn 0;\r\n}\r\nstatic void i2c_acpi_register_device(struct i2c_adapter *adapter,\r\nstruct acpi_device *adev,\r\nstruct i2c_board_info *info)\r\n{\r\nadev->power.flags.ignore_parent = true;\r\nacpi_device_set_enumerated(adev);\r\nif (!i2c_new_device(adapter, info)) {\r\nadev->power.flags.ignore_parent = false;\r\ndev_err(&adapter->dev,\r\n"failed to add I2C device %s from ACPI\n",\r\ndev_name(&adev->dev));\r\n}\r\n}\r\nstatic acpi_status i2c_acpi_add_device(acpi_handle handle, u32 level,\r\nvoid *data, void **return_value)\r\n{\r\nstruct i2c_adapter *adapter = data;\r\nstruct acpi_device *adev;\r\nstruct i2c_board_info info;\r\nif (acpi_bus_get_device(handle, &adev))\r\nreturn AE_OK;\r\nif (i2c_acpi_get_info(adev, &info, adapter, NULL))\r\nreturn AE_OK;\r\ni2c_acpi_register_device(adapter, adev, &info);\r\nreturn AE_OK;\r\n}\r\nvoid i2c_acpi_register_devices(struct i2c_adapter *adap)\r\n{\r\nacpi_status status;\r\nif (!has_acpi_companion(&adap->dev))\r\nreturn;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nI2C_ACPI_MAX_SCAN_DEPTH,\r\ni2c_acpi_add_device, NULL,\r\nadap, NULL);\r\nif (ACPI_FAILURE(status))\r\ndev_warn(&adap->dev, "failed to enumerate I2C slaves\n");\r\n}\r\nconst struct acpi_device_id *\r\ni2c_acpi_match_device(const struct acpi_device_id *matches,\r\nstruct i2c_client *client)\r\n{\r\nif (!(client && matches))\r\nreturn NULL;\r\nreturn acpi_match_device(matches, &client->dev);\r\n}\r\nstatic acpi_status i2c_acpi_lookup_speed(acpi_handle handle, u32 level,\r\nvoid *data, void **return_value)\r\n{\r\nstruct i2c_acpi_lookup *lookup = data;\r\nstruct acpi_device *adev;\r\nif (acpi_bus_get_device(handle, &adev))\r\nreturn AE_OK;\r\nif (i2c_acpi_do_lookup(adev, lookup))\r\nreturn AE_OK;\r\nif (lookup->search_handle != lookup->adapter_handle)\r\nreturn AE_OK;\r\nif (lookup->speed <= lookup->min_speed)\r\nlookup->min_speed = lookup->speed;\r\nreturn AE_OK;\r\n}\r\nu32 i2c_acpi_find_bus_speed(struct device *dev)\r\n{\r\nstruct i2c_acpi_lookup lookup;\r\nstruct i2c_board_info dummy;\r\nacpi_status status;\r\nif (!has_acpi_companion(dev))\r\nreturn 0;\r\nmemset(&lookup, 0, sizeof(lookup));\r\nlookup.search_handle = ACPI_HANDLE(dev);\r\nlookup.min_speed = UINT_MAX;\r\nlookup.info = &dummy;\r\nlookup.index = -1;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nI2C_ACPI_MAX_SCAN_DEPTH,\r\ni2c_acpi_lookup_speed, NULL,\r\n&lookup, NULL);\r\nif (ACPI_FAILURE(status)) {\r\ndev_warn(dev, "unable to find I2C bus speed from ACPI\n");\r\nreturn 0;\r\n}\r\nreturn lookup.min_speed != UINT_MAX ? lookup.min_speed : 0;\r\n}\r\nstatic int i2c_acpi_find_match_adapter(struct device *dev, void *data)\r\n{\r\nstruct i2c_adapter *adapter = i2c_verify_adapter(dev);\r\nif (!adapter)\r\nreturn 0;\r\nreturn ACPI_HANDLE(dev) == (acpi_handle)data;\r\n}\r\nstatic int i2c_acpi_find_match_device(struct device *dev, void *data)\r\n{\r\nreturn ACPI_COMPANION(dev) == data;\r\n}\r\nstatic struct i2c_adapter *i2c_acpi_find_adapter_by_handle(acpi_handle handle)\r\n{\r\nstruct device *dev;\r\ndev = bus_find_device(&i2c_bus_type, NULL, handle,\r\ni2c_acpi_find_match_adapter);\r\nreturn dev ? i2c_verify_adapter(dev) : NULL;\r\n}\r\nstatic struct i2c_client *i2c_acpi_find_client_by_adev(struct acpi_device *adev)\r\n{\r\nstruct device *dev;\r\ndev = bus_find_device(&i2c_bus_type, NULL, adev,\r\ni2c_acpi_find_match_device);\r\nreturn dev ? i2c_verify_client(dev) : NULL;\r\n}\r\nstatic int i2c_acpi_notify(struct notifier_block *nb, unsigned long value,\r\nvoid *arg)\r\n{\r\nstruct acpi_device *adev = arg;\r\nstruct i2c_board_info info;\r\nacpi_handle adapter_handle;\r\nstruct i2c_adapter *adapter;\r\nstruct i2c_client *client;\r\nswitch (value) {\r\ncase ACPI_RECONFIG_DEVICE_ADD:\r\nif (i2c_acpi_get_info(adev, &info, NULL, &adapter_handle))\r\nbreak;\r\nadapter = i2c_acpi_find_adapter_by_handle(adapter_handle);\r\nif (!adapter)\r\nbreak;\r\ni2c_acpi_register_device(adapter, adev, &info);\r\nbreak;\r\ncase ACPI_RECONFIG_DEVICE_REMOVE:\r\nif (!acpi_device_enumerated(adev))\r\nbreak;\r\nclient = i2c_acpi_find_client_by_adev(adev);\r\nif (!client)\r\nbreak;\r\ni2c_unregister_device(client);\r\nput_device(&client->dev);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstruct i2c_client *i2c_acpi_new_device(struct device *dev, int index,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_acpi_lookup lookup;\r\nstruct i2c_adapter *adapter;\r\nstruct acpi_device *adev;\r\nLIST_HEAD(resource_list);\r\nint ret;\r\nadev = ACPI_COMPANION(dev);\r\nif (!adev)\r\nreturn NULL;\r\nmemset(&lookup, 0, sizeof(lookup));\r\nlookup.info = info;\r\nlookup.device_handle = acpi_device_handle(adev);\r\nlookup.index = index;\r\nret = acpi_dev_get_resources(adev, &resource_list,\r\ni2c_acpi_fill_info, &lookup);\r\nacpi_dev_free_resource_list(&resource_list);\r\nif (ret < 0 || !info->addr)\r\nreturn NULL;\r\nadapter = i2c_acpi_find_adapter_by_handle(lookup.adapter_handle);\r\nif (!adapter)\r\nreturn NULL;\r\nreturn i2c_new_device(adapter, info);\r\n}\r\nstatic int acpi_gsb_i2c_read_bytes(struct i2c_client *client,\r\nu8 cmd, u8 *data, u8 data_len)\r\n{\r\nstruct i2c_msg msgs[2];\r\nint ret;\r\nu8 *buffer;\r\nbuffer = kzalloc(data_len, GFP_KERNEL);\r\nif (!buffer)\r\nreturn AE_NO_MEMORY;\r\nmsgs[0].addr = client->addr;\r\nmsgs[0].flags = client->flags;\r\nmsgs[0].len = 1;\r\nmsgs[0].buf = &cmd;\r\nmsgs[1].addr = client->addr;\r\nmsgs[1].flags = client->flags | I2C_M_RD;\r\nmsgs[1].len = data_len;\r\nmsgs[1].buf = buffer;\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret < 0)\r\ndev_err(&client->adapter->dev, "i2c read failed\n");\r\nelse\r\nmemcpy(data, buffer, data_len);\r\nkfree(buffer);\r\nreturn ret;\r\n}\r\nstatic int acpi_gsb_i2c_write_bytes(struct i2c_client *client,\r\nu8 cmd, u8 *data, u8 data_len)\r\n{\r\nstruct i2c_msg msgs[1];\r\nu8 *buffer;\r\nint ret = AE_OK;\r\nbuffer = kzalloc(data_len + 1, GFP_KERNEL);\r\nif (!buffer)\r\nreturn AE_NO_MEMORY;\r\nbuffer[0] = cmd;\r\nmemcpy(buffer + 1, data, data_len);\r\nmsgs[0].addr = client->addr;\r\nmsgs[0].flags = client->flags;\r\nmsgs[0].len = data_len + 1;\r\nmsgs[0].buf = buffer;\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret < 0)\r\ndev_err(&client->adapter->dev, "i2c write failed\n");\r\nkfree(buffer);\r\nreturn ret;\r\n}\r\nstatic acpi_status\r\ni2c_acpi_space_handler(u32 function, acpi_physical_address command,\r\nu32 bits, u64 *value64,\r\nvoid *handler_context, void *region_context)\r\n{\r\nstruct gsb_buffer *gsb = (struct gsb_buffer *)value64;\r\nstruct i2c_acpi_handler_data *data = handler_context;\r\nstruct acpi_connection_info *info = &data->info;\r\nstruct acpi_resource_i2c_serialbus *sb;\r\nstruct i2c_adapter *adapter = data->adapter;\r\nstruct i2c_client *client;\r\nstruct acpi_resource *ares;\r\nu32 accessor_type = function >> 16;\r\nu8 action = function & ACPI_IO_MASK;\r\nacpi_status ret;\r\nint status;\r\nret = acpi_buffer_to_resource(info->connection, info->length, &ares);\r\nif (ACPI_FAILURE(ret))\r\nreturn ret;\r\nclient = kzalloc(sizeof(*client), GFP_KERNEL);\r\nif (!client) {\r\nret = AE_NO_MEMORY;\r\ngoto err;\r\n}\r\nif (!value64 || ares->type != ACPI_RESOURCE_TYPE_SERIAL_BUS) {\r\nret = AE_BAD_PARAMETER;\r\ngoto err;\r\n}\r\nsb = &ares->data.i2c_serial_bus;\r\nif (sb->type != ACPI_RESOURCE_SERIAL_TYPE_I2C) {\r\nret = AE_BAD_PARAMETER;\r\ngoto err;\r\n}\r\nclient->adapter = adapter;\r\nclient->addr = sb->slave_address;\r\nif (sb->access_mode == ACPI_I2C_10BIT_MODE)\r\nclient->flags |= I2C_CLIENT_TEN;\r\nswitch (accessor_type) {\r\ncase ACPI_GSB_ACCESS_ATTRIB_SEND_RCV:\r\nif (action == ACPI_READ) {\r\nstatus = i2c_smbus_read_byte(client);\r\nif (status >= 0) {\r\ngsb->bdata = status;\r\nstatus = 0;\r\n}\r\n} else {\r\nstatus = i2c_smbus_write_byte(client, gsb->bdata);\r\n}\r\nbreak;\r\ncase ACPI_GSB_ACCESS_ATTRIB_BYTE:\r\nif (action == ACPI_READ) {\r\nstatus = i2c_smbus_read_byte_data(client, command);\r\nif (status >= 0) {\r\ngsb->bdata = status;\r\nstatus = 0;\r\n}\r\n} else {\r\nstatus = i2c_smbus_write_byte_data(client, command,\r\ngsb->bdata);\r\n}\r\nbreak;\r\ncase ACPI_GSB_ACCESS_ATTRIB_WORD:\r\nif (action == ACPI_READ) {\r\nstatus = i2c_smbus_read_word_data(client, command);\r\nif (status >= 0) {\r\ngsb->wdata = status;\r\nstatus = 0;\r\n}\r\n} else {\r\nstatus = i2c_smbus_write_word_data(client, command,\r\ngsb->wdata);\r\n}\r\nbreak;\r\ncase ACPI_GSB_ACCESS_ATTRIB_BLOCK:\r\nif (action == ACPI_READ) {\r\nstatus = i2c_smbus_read_block_data(client, command,\r\ngsb->data);\r\nif (status >= 0) {\r\ngsb->len = status;\r\nstatus = 0;\r\n}\r\n} else {\r\nstatus = i2c_smbus_write_block_data(client, command,\r\ngsb->len, gsb->data);\r\n}\r\nbreak;\r\ncase ACPI_GSB_ACCESS_ATTRIB_MULTIBYTE:\r\nif (action == ACPI_READ) {\r\nstatus = acpi_gsb_i2c_read_bytes(client, command,\r\ngsb->data, info->access_length);\r\nif (status > 0)\r\nstatus = 0;\r\n} else {\r\nstatus = acpi_gsb_i2c_write_bytes(client, command,\r\ngsb->data, info->access_length);\r\n}\r\nbreak;\r\ndefault:\r\ndev_warn(&adapter->dev, "protocol 0x%02x not supported for client 0x%02x\n",\r\naccessor_type, client->addr);\r\nret = AE_BAD_PARAMETER;\r\ngoto err;\r\n}\r\ngsb->status = status;\r\nerr:\r\nkfree(client);\r\nACPI_FREE(ares);\r\nreturn ret;\r\n}\r\nint i2c_acpi_install_space_handler(struct i2c_adapter *adapter)\r\n{\r\nacpi_handle handle;\r\nstruct i2c_acpi_handler_data *data;\r\nacpi_status status;\r\nif (!adapter->dev.parent)\r\nreturn -ENODEV;\r\nhandle = ACPI_HANDLE(adapter->dev.parent);\r\nif (!handle)\r\nreturn -ENODEV;\r\ndata = kzalloc(sizeof(struct i2c_acpi_handler_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->adapter = adapter;\r\nstatus = acpi_bus_attach_private_data(handle, (void *)data);\r\nif (ACPI_FAILURE(status)) {\r\nkfree(data);\r\nreturn -ENOMEM;\r\n}\r\nstatus = acpi_install_address_space_handler(handle,\r\nACPI_ADR_SPACE_GSBUS,\r\n&i2c_acpi_space_handler,\r\nNULL,\r\ndata);\r\nif (ACPI_FAILURE(status)) {\r\ndev_err(&adapter->dev, "Error installing i2c space handler\n");\r\nacpi_bus_detach_private_data(handle);\r\nkfree(data);\r\nreturn -ENOMEM;\r\n}\r\nacpi_walk_dep_device_list(handle);\r\nreturn 0;\r\n}\r\nvoid i2c_acpi_remove_space_handler(struct i2c_adapter *adapter)\r\n{\r\nacpi_handle handle;\r\nstruct i2c_acpi_handler_data *data;\r\nacpi_status status;\r\nif (!adapter->dev.parent)\r\nreturn;\r\nhandle = ACPI_HANDLE(adapter->dev.parent);\r\nif (!handle)\r\nreturn;\r\nacpi_remove_address_space_handler(handle,\r\nACPI_ADR_SPACE_GSBUS,\r\n&i2c_acpi_space_handler);\r\nstatus = acpi_bus_get_private_data(handle, (void **)&data);\r\nif (ACPI_SUCCESS(status))\r\nkfree(data);\r\nacpi_bus_detach_private_data(handle);\r\n}
