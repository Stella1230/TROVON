static void skel_delete(struct kref *kref)\r\n{\r\nstruct usb_skel *dev = to_skel_dev(kref);\r\nusb_free_urb(dev->bulk_in_urb);\r\nusb_put_dev(dev->udev);\r\nkfree(dev->bulk_in_buffer);\r\nkfree(dev);\r\n}\r\nstatic int skel_open(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_skel *dev;\r\nstruct usb_interface *interface;\r\nint subminor;\r\nint retval = 0;\r\nsubminor = iminor(inode);\r\ninterface = usb_find_interface(&skel_driver, subminor);\r\nif (!interface) {\r\npr_err("%s - error, can't find device for minor %d\n",\r\n__func__, subminor);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\ndev = usb_get_intfdata(interface);\r\nif (!dev) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nretval = usb_autopm_get_interface(interface);\r\nif (retval)\r\ngoto exit;\r\nkref_get(&dev->kref);\r\nfile->private_data = dev;\r\nexit:\r\nreturn retval;\r\n}\r\nstatic int skel_release(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_skel *dev;\r\ndev = file->private_data;\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->io_mutex);\r\nif (dev->interface)\r\nusb_autopm_put_interface(dev->interface);\r\nmutex_unlock(&dev->io_mutex);\r\nkref_put(&dev->kref, skel_delete);\r\nreturn 0;\r\n}\r\nstatic int skel_flush(struct file *file, fl_owner_t id)\r\n{\r\nstruct usb_skel *dev;\r\nint res;\r\ndev = file->private_data;\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->io_mutex);\r\nskel_draw_down(dev);\r\nspin_lock_irq(&dev->err_lock);\r\nres = dev->errors ? (dev->errors == -EPIPE ? -EPIPE : -EIO) : 0;\r\ndev->errors = 0;\r\nspin_unlock_irq(&dev->err_lock);\r\nmutex_unlock(&dev->io_mutex);\r\nreturn res;\r\n}\r\nstatic void skel_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_skel *dev;\r\ndev = urb->context;\r\nspin_lock(&dev->err_lock);\r\nif (urb->status) {\r\nif (!(urb->status == -ENOENT ||\r\nurb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN))\r\ndev_err(&dev->interface->dev,\r\n"%s - nonzero write bulk status received: %d\n",\r\n__func__, urb->status);\r\ndev->errors = urb->status;\r\n} else {\r\ndev->bulk_in_filled = urb->actual_length;\r\n}\r\ndev->ongoing_read = 0;\r\nspin_unlock(&dev->err_lock);\r\nwake_up_interruptible(&dev->bulk_in_wait);\r\n}\r\nstatic int skel_do_read_io(struct usb_skel *dev, size_t count)\r\n{\r\nint rv;\r\nusb_fill_bulk_urb(dev->bulk_in_urb,\r\ndev->udev,\r\nusb_rcvbulkpipe(dev->udev,\r\ndev->bulk_in_endpointAddr),\r\ndev->bulk_in_buffer,\r\nmin(dev->bulk_in_size, count),\r\nskel_read_bulk_callback,\r\ndev);\r\nspin_lock_irq(&dev->err_lock);\r\ndev->ongoing_read = 1;\r\nspin_unlock_irq(&dev->err_lock);\r\ndev->bulk_in_filled = 0;\r\ndev->bulk_in_copied = 0;\r\nrv = usb_submit_urb(dev->bulk_in_urb, GFP_KERNEL);\r\nif (rv < 0) {\r\ndev_err(&dev->interface->dev,\r\n"%s - failed submitting read urb, error %d\n",\r\n__func__, rv);\r\nrv = (rv == -ENOMEM) ? rv : -EIO;\r\nspin_lock_irq(&dev->err_lock);\r\ndev->ongoing_read = 0;\r\nspin_unlock_irq(&dev->err_lock);\r\n}\r\nreturn rv;\r\n}\r\nstatic ssize_t skel_read(struct file *file, char *buffer, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct usb_skel *dev;\r\nint rv;\r\nbool ongoing_io;\r\ndev = file->private_data;\r\nif (!dev->bulk_in_urb || !count)\r\nreturn 0;\r\nrv = mutex_lock_interruptible(&dev->io_mutex);\r\nif (rv < 0)\r\nreturn rv;\r\nif (!dev->interface) {\r\nrv = -ENODEV;\r\ngoto exit;\r\n}\r\nretry:\r\nspin_lock_irq(&dev->err_lock);\r\nongoing_io = dev->ongoing_read;\r\nspin_unlock_irq(&dev->err_lock);\r\nif (ongoing_io) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nrv = -EAGAIN;\r\ngoto exit;\r\n}\r\nrv = wait_event_interruptible(dev->bulk_in_wait, (!dev->ongoing_read));\r\nif (rv < 0)\r\ngoto exit;\r\n}\r\nrv = dev->errors;\r\nif (rv < 0) {\r\ndev->errors = 0;\r\nrv = (rv == -EPIPE) ? rv : -EIO;\r\ngoto exit;\r\n}\r\nif (dev->bulk_in_filled) {\r\nsize_t available = dev->bulk_in_filled - dev->bulk_in_copied;\r\nsize_t chunk = min(available, count);\r\nif (!available) {\r\nrv = skel_do_read_io(dev, count);\r\nif (rv < 0)\r\ngoto exit;\r\nelse\r\ngoto retry;\r\n}\r\nif (copy_to_user(buffer,\r\ndev->bulk_in_buffer + dev->bulk_in_copied,\r\nchunk))\r\nrv = -EFAULT;\r\nelse\r\nrv = chunk;\r\ndev->bulk_in_copied += chunk;\r\nif (available < count)\r\nskel_do_read_io(dev, count - chunk);\r\n} else {\r\nrv = skel_do_read_io(dev, count);\r\nif (rv < 0)\r\ngoto exit;\r\nelse\r\ngoto retry;\r\n}\r\nexit:\r\nmutex_unlock(&dev->io_mutex);\r\nreturn rv;\r\n}\r\nstatic void skel_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_skel *dev;\r\ndev = urb->context;\r\nif (urb->status) {\r\nif (!(urb->status == -ENOENT ||\r\nurb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN))\r\ndev_err(&dev->interface->dev,\r\n"%s - nonzero write bulk status received: %d\n",\r\n__func__, urb->status);\r\nspin_lock(&dev->err_lock);\r\ndev->errors = urb->status;\r\nspin_unlock(&dev->err_lock);\r\n}\r\nusb_free_coherent(urb->dev, urb->transfer_buffer_length,\r\nurb->transfer_buffer, urb->transfer_dma);\r\nup(&dev->limit_sem);\r\n}\r\nstatic ssize_t skel_write(struct file *file, const char *user_buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct usb_skel *dev;\r\nint retval = 0;\r\nstruct urb *urb = NULL;\r\nchar *buf = NULL;\r\nsize_t writesize = min(count, (size_t)MAX_TRANSFER);\r\ndev = file->private_data;\r\nif (count == 0)\r\ngoto exit;\r\nif (!(file->f_flags & O_NONBLOCK)) {\r\nif (down_interruptible(&dev->limit_sem)) {\r\nretval = -ERESTARTSYS;\r\ngoto exit;\r\n}\r\n} else {\r\nif (down_trylock(&dev->limit_sem)) {\r\nretval = -EAGAIN;\r\ngoto exit;\r\n}\r\n}\r\nspin_lock_irq(&dev->err_lock);\r\nretval = dev->errors;\r\nif (retval < 0) {\r\ndev->errors = 0;\r\nretval = (retval == -EPIPE) ? retval : -EIO;\r\n}\r\nspin_unlock_irq(&dev->err_lock);\r\nif (retval < 0)\r\ngoto error;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nbuf = usb_alloc_coherent(dev->udev, writesize, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!buf) {\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nif (copy_from_user(buf, user_buffer, writesize)) {\r\nretval = -EFAULT;\r\ngoto error;\r\n}\r\nmutex_lock(&dev->io_mutex);\r\nif (!dev->interface) {\r\nmutex_unlock(&dev->io_mutex);\r\nretval = -ENODEV;\r\ngoto error;\r\n}\r\nusb_fill_bulk_urb(urb, dev->udev,\r\nusb_sndbulkpipe(dev->udev, dev->bulk_out_endpointAddr),\r\nbuf, writesize, skel_write_bulk_callback, dev);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(urb, &dev->submitted);\r\nretval = usb_submit_urb(urb, GFP_KERNEL);\r\nmutex_unlock(&dev->io_mutex);\r\nif (retval) {\r\ndev_err(&dev->interface->dev,\r\n"%s - failed submitting write urb, error %d\n",\r\n__func__, retval);\r\ngoto error_unanchor;\r\n}\r\nusb_free_urb(urb);\r\nreturn writesize;\r\nerror_unanchor:\r\nusb_unanchor_urb(urb);\r\nerror:\r\nif (urb) {\r\nusb_free_coherent(dev->udev, writesize, buf, urb->transfer_dma);\r\nusb_free_urb(urb);\r\n}\r\nup(&dev->limit_sem);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic int skel_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_skel *dev;\r\nstruct usb_endpoint_descriptor *bulk_in, *bulk_out;\r\nint retval;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nkref_init(&dev->kref);\r\nsema_init(&dev->limit_sem, WRITES_IN_FLIGHT);\r\nmutex_init(&dev->io_mutex);\r\nspin_lock_init(&dev->err_lock);\r\ninit_usb_anchor(&dev->submitted);\r\ninit_waitqueue_head(&dev->bulk_in_wait);\r\ndev->udev = usb_get_dev(interface_to_usbdev(interface));\r\ndev->interface = interface;\r\nretval = usb_find_common_endpoints(interface->cur_altsetting,\r\n&bulk_in, &bulk_out, NULL, NULL);\r\nif (retval) {\r\ndev_err(&interface->dev,\r\n"Could not find both bulk-in and bulk-out endpoints\n");\r\ngoto error;\r\n}\r\ndev->bulk_in_size = usb_endpoint_maxp(bulk_in);\r\ndev->bulk_in_endpointAddr = bulk_in->bEndpointAddress;\r\ndev->bulk_in_buffer = kmalloc(dev->bulk_in_size, GFP_KERNEL);\r\nif (!dev->bulk_in_buffer) {\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\ndev->bulk_in_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->bulk_in_urb) {\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\ndev->bulk_out_endpointAddr = bulk_out->bEndpointAddress;\r\nusb_set_intfdata(interface, dev);\r\nretval = usb_register_dev(interface, &skel_class);\r\nif (retval) {\r\ndev_err(&interface->dev,\r\n"Not able to get a minor for this device.\n");\r\nusb_set_intfdata(interface, NULL);\r\ngoto error;\r\n}\r\ndev_info(&interface->dev,\r\n"USB Skeleton device now attached to USBSkel-%d",\r\ninterface->minor);\r\nreturn 0;\r\nerror:\r\nkref_put(&dev->kref, skel_delete);\r\nreturn retval;\r\n}\r\nstatic void skel_disconnect(struct usb_interface *interface)\r\n{\r\nstruct usb_skel *dev;\r\nint minor = interface->minor;\r\ndev = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\nusb_deregister_dev(interface, &skel_class);\r\nmutex_lock(&dev->io_mutex);\r\ndev->interface = NULL;\r\nmutex_unlock(&dev->io_mutex);\r\nusb_kill_anchored_urbs(&dev->submitted);\r\nkref_put(&dev->kref, skel_delete);\r\ndev_info(&interface->dev, "USB Skeleton #%d now disconnected", minor);\r\n}\r\nstatic void skel_draw_down(struct usb_skel *dev)\r\n{\r\nint time;\r\ntime = usb_wait_anchor_empty_timeout(&dev->submitted, 1000);\r\nif (!time)\r\nusb_kill_anchored_urbs(&dev->submitted);\r\nusb_kill_urb(dev->bulk_in_urb);\r\n}\r\nstatic int skel_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct usb_skel *dev = usb_get_intfdata(intf);\r\nif (!dev)\r\nreturn 0;\r\nskel_draw_down(dev);\r\nreturn 0;\r\n}\r\nstatic int skel_resume(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}\r\nstatic int skel_pre_reset(struct usb_interface *intf)\r\n{\r\nstruct usb_skel *dev = usb_get_intfdata(intf);\r\nmutex_lock(&dev->io_mutex);\r\nskel_draw_down(dev);\r\nreturn 0;\r\n}\r\nstatic int skel_post_reset(struct usb_interface *intf)\r\n{\r\nstruct usb_skel *dev = usb_get_intfdata(intf);\r\ndev->errors = -EPIPE;\r\nmutex_unlock(&dev->io_mutex);\r\nreturn 0;\r\n}
