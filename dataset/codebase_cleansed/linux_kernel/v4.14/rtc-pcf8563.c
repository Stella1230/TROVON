static int pcf8563_read_block_data(struct i2c_client *client, unsigned char reg,\r\nunsigned char length, unsigned char *buf)\r\n{\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.len = 1,\r\n.buf = &reg,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = length,\r\n.buf = buf\r\n},\r\n};\r\nif ((i2c_transfer(client->adapter, msgs, 2)) != 2) {\r\ndev_err(&client->dev, "%s: read error\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcf8563_write_block_data(struct i2c_client *client,\r\nunsigned char reg, unsigned char length,\r\nunsigned char *buf)\r\n{\r\nint i, err;\r\nfor (i = 0; i < length; i++) {\r\nunsigned char data[2] = { reg + i, buf[i] };\r\nerr = i2c_master_send(client, data, sizeof(data));\r\nif (err != sizeof(data)) {\r\ndev_err(&client->dev,\r\n"%s: err=%d addr=%02x, data=%02x\n",\r\n__func__, err, data[0], data[1]);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcf8563_set_alarm_mode(struct i2c_client *client, bool on)\r\n{\r\nunsigned char buf;\r\nint err;\r\nerr = pcf8563_read_block_data(client, PCF8563_REG_ST2, 1, &buf);\r\nif (err < 0)\r\nreturn err;\r\nif (on)\r\nbuf |= PCF8563_BIT_AIE;\r\nelse\r\nbuf &= ~PCF8563_BIT_AIE;\r\nbuf &= ~(PCF8563_BIT_AF | PCF8563_BITS_ST2_N);\r\nerr = pcf8563_write_block_data(client, PCF8563_REG_ST2, 1, &buf);\r\nif (err < 0) {\r\ndev_err(&client->dev, "%s: write error\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcf8563_get_alarm_mode(struct i2c_client *client, unsigned char *en,\r\nunsigned char *pen)\r\n{\r\nunsigned char buf;\r\nint err;\r\nerr = pcf8563_read_block_data(client, PCF8563_REG_ST2, 1, &buf);\r\nif (err)\r\nreturn err;\r\nif (en)\r\n*en = !!(buf & PCF8563_BIT_AIE);\r\nif (pen)\r\n*pen = !!(buf & PCF8563_BIT_AF);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t pcf8563_irq(int irq, void *dev_id)\r\n{\r\nstruct pcf8563 *pcf8563 = i2c_get_clientdata(dev_id);\r\nint err;\r\nchar pending;\r\nerr = pcf8563_get_alarm_mode(pcf8563->client, NULL, &pending);\r\nif (err)\r\nreturn IRQ_NONE;\r\nif (pending) {\r\nrtc_update_irq(pcf8563->rtc, 1, RTC_IRQF | RTC_AF);\r\npcf8563_set_alarm_mode(pcf8563->client, 1);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int pcf8563_get_datetime(struct i2c_client *client, struct rtc_time *tm)\r\n{\r\nstruct pcf8563 *pcf8563 = i2c_get_clientdata(client);\r\nunsigned char buf[9];\r\nint err;\r\nerr = pcf8563_read_block_data(client, PCF8563_REG_ST1, 9, buf);\r\nif (err)\r\nreturn err;\r\nif (buf[PCF8563_REG_SC] & PCF8563_SC_LV) {\r\npcf8563->voltage_low = 1;\r\ndev_err(&client->dev,\r\n"low voltage detected, date/time is not reliable.\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&client->dev,\r\n"%s: raw data is st1=%02x, st2=%02x, sec=%02x, min=%02x, hr=%02x, "\r\n"mday=%02x, wday=%02x, mon=%02x, year=%02x\n",\r\n__func__,\r\nbuf[0], buf[1], buf[2], buf[3],\r\nbuf[4], buf[5], buf[6], buf[7],\r\nbuf[8]);\r\ntm->tm_sec = bcd2bin(buf[PCF8563_REG_SC] & 0x7F);\r\ntm->tm_min = bcd2bin(buf[PCF8563_REG_MN] & 0x7F);\r\ntm->tm_hour = bcd2bin(buf[PCF8563_REG_HR] & 0x3F);\r\ntm->tm_mday = bcd2bin(buf[PCF8563_REG_DM] & 0x3F);\r\ntm->tm_wday = buf[PCF8563_REG_DW] & 0x07;\r\ntm->tm_mon = bcd2bin(buf[PCF8563_REG_MO] & 0x1F) - 1;\r\ntm->tm_year = bcd2bin(buf[PCF8563_REG_YR]);\r\nif (tm->tm_year < 70)\r\ntm->tm_year += 100;\r\npcf8563->c_polarity = (buf[PCF8563_REG_MO] & PCF8563_MO_C) ?\r\n(tm->tm_year >= 100) : (tm->tm_year < 100);\r\ndev_dbg(&client->dev, "%s: tm is secs=%d, mins=%d, hours=%d, "\r\n"mday=%d, mon=%d, year=%d, wday=%d\n",\r\n__func__,\r\ntm->tm_sec, tm->tm_min, tm->tm_hour,\r\ntm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);\r\nreturn 0;\r\n}\r\nstatic int pcf8563_set_datetime(struct i2c_client *client, struct rtc_time *tm)\r\n{\r\nstruct pcf8563 *pcf8563 = i2c_get_clientdata(client);\r\nunsigned char buf[9];\r\ndev_dbg(&client->dev, "%s: secs=%d, mins=%d, hours=%d, "\r\n"mday=%d, mon=%d, year=%d, wday=%d\n",\r\n__func__,\r\ntm->tm_sec, tm->tm_min, tm->tm_hour,\r\ntm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);\r\nbuf[PCF8563_REG_SC] = bin2bcd(tm->tm_sec);\r\nbuf[PCF8563_REG_MN] = bin2bcd(tm->tm_min);\r\nbuf[PCF8563_REG_HR] = bin2bcd(tm->tm_hour);\r\nbuf[PCF8563_REG_DM] = bin2bcd(tm->tm_mday);\r\nbuf[PCF8563_REG_MO] = bin2bcd(tm->tm_mon + 1);\r\nbuf[PCF8563_REG_YR] = bin2bcd(tm->tm_year % 100);\r\nif (pcf8563->c_polarity ? (tm->tm_year >= 100) : (tm->tm_year < 100))\r\nbuf[PCF8563_REG_MO] |= PCF8563_MO_C;\r\nbuf[PCF8563_REG_DW] = tm->tm_wday & 0x07;\r\nreturn pcf8563_write_block_data(client, PCF8563_REG_SC,\r\n9 - PCF8563_REG_SC, buf + PCF8563_REG_SC);\r\n}\r\nstatic int pcf8563_rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct pcf8563 *pcf8563 = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct rtc_time tm;\r\nswitch (cmd) {\r\ncase RTC_VL_READ:\r\nif (pcf8563->voltage_low)\r\ndev_info(dev, "low voltage detected, date/time is not reliable.\n");\r\nif (copy_to_user((void __user *)arg, &pcf8563->voltage_low,\r\nsizeof(int)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase RTC_VL_CLR:\r\nif (pcf8563_get_datetime(to_i2c_client(dev), &tm))\r\npcf8563_set_datetime(to_i2c_client(dev), &tm);\r\npcf8563->voltage_low = 0;\r\nreturn 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int pcf8563_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn pcf8563_get_datetime(to_i2c_client(dev), tm);\r\n}\r\nstatic int pcf8563_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn pcf8563_set_datetime(to_i2c_client(dev), tm);\r\n}\r\nstatic int pcf8563_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *tm)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nunsigned char buf[4];\r\nint err;\r\nerr = pcf8563_read_block_data(client, PCF8563_REG_AMN, 4, buf);\r\nif (err)\r\nreturn err;\r\ndev_dbg(&client->dev,\r\n"%s: raw data is min=%02x, hr=%02x, mday=%02x, wday=%02x\n",\r\n__func__, buf[0], buf[1], buf[2], buf[3]);\r\ntm->time.tm_sec = 0;\r\ntm->time.tm_min = bcd2bin(buf[0] & 0x7F);\r\ntm->time.tm_hour = bcd2bin(buf[1] & 0x3F);\r\ntm->time.tm_mday = bcd2bin(buf[2] & 0x3F);\r\ntm->time.tm_wday = bcd2bin(buf[3] & 0x7);\r\nerr = pcf8563_get_alarm_mode(client, &tm->enabled, &tm->pending);\r\nif (err < 0)\r\nreturn err;\r\ndev_dbg(&client->dev, "%s: tm is mins=%d, hours=%d, mday=%d, wday=%d,"\r\n" enabled=%d, pending=%d\n", __func__, tm->time.tm_min,\r\ntm->time.tm_hour, tm->time.tm_mday, tm->time.tm_wday,\r\ntm->enabled, tm->pending);\r\nreturn 0;\r\n}\r\nstatic int pcf8563_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *tm)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nunsigned char buf[4];\r\nint err;\r\nif (tm->time.tm_sec) {\r\ntime64_t alarm_time = rtc_tm_to_time64(&tm->time);\r\nalarm_time += 60 - tm->time.tm_sec;\r\nrtc_time64_to_tm(alarm_time, &tm->time);\r\n}\r\ndev_dbg(dev, "%s, min=%d hour=%d wday=%d mday=%d "\r\n"enabled=%d pending=%d\n", __func__,\r\ntm->time.tm_min, tm->time.tm_hour, tm->time.tm_wday,\r\ntm->time.tm_mday, tm->enabled, tm->pending);\r\nbuf[0] = bin2bcd(tm->time.tm_min);\r\nbuf[1] = bin2bcd(tm->time.tm_hour);\r\nbuf[2] = bin2bcd(tm->time.tm_mday);\r\nbuf[3] = tm->time.tm_wday & 0x07;\r\nerr = pcf8563_write_block_data(client, PCF8563_REG_AMN, 4, buf);\r\nif (err)\r\nreturn err;\r\nreturn pcf8563_set_alarm_mode(client, 1);\r\n}\r\nstatic int pcf8563_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\ndev_dbg(dev, "%s: en=%d\n", __func__, enabled);\r\nreturn pcf8563_set_alarm_mode(to_i2c_client(dev), !!enabled);\r\n}\r\nstatic unsigned long pcf8563_clkout_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct pcf8563 *pcf8563 = clkout_hw_to_pcf8563(hw);\r\nstruct i2c_client *client = pcf8563->client;\r\nunsigned char buf;\r\nint ret = pcf8563_read_block_data(client, PCF8563_REG_CLKO, 1, &buf);\r\nif (ret < 0)\r\nreturn 0;\r\nbuf &= PCF8563_REG_CLKO_F_MASK;\r\nreturn clkout_rates[ret];\r\n}\r\nstatic long pcf8563_clkout_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(clkout_rates); i++)\r\nif (clkout_rates[i] <= rate)\r\nreturn clkout_rates[i];\r\nreturn 0;\r\n}\r\nstatic int pcf8563_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct pcf8563 *pcf8563 = clkout_hw_to_pcf8563(hw);\r\nstruct i2c_client *client = pcf8563->client;\r\nunsigned char buf;\r\nint ret = pcf8563_read_block_data(client, PCF8563_REG_CLKO, 1, &buf);\r\nint i;\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(clkout_rates); i++)\r\nif (clkout_rates[i] == rate) {\r\nbuf &= ~PCF8563_REG_CLKO_F_MASK;\r\nbuf |= i;\r\nret = pcf8563_write_block_data(client,\r\nPCF8563_REG_CLKO, 1,\r\n&buf);\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int pcf8563_clkout_control(struct clk_hw *hw, bool enable)\r\n{\r\nstruct pcf8563 *pcf8563 = clkout_hw_to_pcf8563(hw);\r\nstruct i2c_client *client = pcf8563->client;\r\nunsigned char buf;\r\nint ret = pcf8563_read_block_data(client, PCF8563_REG_CLKO, 1, &buf);\r\nif (ret < 0)\r\nreturn ret;\r\nif (enable)\r\nbuf |= PCF8563_REG_CLKO_FE;\r\nelse\r\nbuf &= ~PCF8563_REG_CLKO_FE;\r\nret = pcf8563_write_block_data(client, PCF8563_REG_CLKO, 1, &buf);\r\nreturn ret;\r\n}\r\nstatic int pcf8563_clkout_prepare(struct clk_hw *hw)\r\n{\r\nreturn pcf8563_clkout_control(hw, 1);\r\n}\r\nstatic void pcf8563_clkout_unprepare(struct clk_hw *hw)\r\n{\r\npcf8563_clkout_control(hw, 0);\r\n}\r\nstatic int pcf8563_clkout_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct pcf8563 *pcf8563 = clkout_hw_to_pcf8563(hw);\r\nstruct i2c_client *client = pcf8563->client;\r\nunsigned char buf;\r\nint ret = pcf8563_read_block_data(client, PCF8563_REG_CLKO, 1, &buf);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !!(buf & PCF8563_REG_CLKO_FE);\r\n}\r\nstatic struct clk *pcf8563_clkout_register_clk(struct pcf8563 *pcf8563)\r\n{\r\nstruct i2c_client *client = pcf8563->client;\r\nstruct device_node *node = client->dev.of_node;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nint ret;\r\nunsigned char buf;\r\nbuf = 0;\r\nret = pcf8563_write_block_data(client, PCF8563_REG_CLKO, 1, &buf);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\ninit.name = "pcf8563-clkout";\r\ninit.ops = &pcf8563_clkout_ops;\r\ninit.flags = 0;\r\ninit.parent_names = NULL;\r\ninit.num_parents = 0;\r\npcf8563->clkout_hw.init = &init;\r\nof_property_read_string(node, "clock-output-names", &init.name);\r\nclk = devm_clk_register(&client->dev, &pcf8563->clkout_hw);\r\nif (!IS_ERR(clk))\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nreturn clk;\r\n}\r\nstatic int pcf8563_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pcf8563 *pcf8563;\r\nint err;\r\nunsigned char buf;\r\nunsigned char alm_pending;\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nreturn -ENODEV;\r\npcf8563 = devm_kzalloc(&client->dev, sizeof(struct pcf8563),\r\nGFP_KERNEL);\r\nif (!pcf8563)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, pcf8563);\r\npcf8563->client = client;\r\ndevice_set_wakeup_capable(&client->dev, 1);\r\nbuf = PCF8563_TMRC_1_60;\r\nerr = pcf8563_write_block_data(client, PCF8563_REG_TMRC, 1, &buf);\r\nif (err < 0) {\r\ndev_err(&client->dev, "%s: write error\n", __func__);\r\nreturn err;\r\n}\r\nerr = pcf8563_get_alarm_mode(client, NULL, &alm_pending);\r\nif (err) {\r\ndev_err(&client->dev, "%s: read error\n", __func__);\r\nreturn err;\r\n}\r\nif (alm_pending)\r\npcf8563_set_alarm_mode(client, 0);\r\npcf8563->rtc = devm_rtc_device_register(&client->dev,\r\npcf8563_driver.driver.name,\r\n&pcf8563_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(pcf8563->rtc))\r\nreturn PTR_ERR(pcf8563->rtc);\r\nif (client->irq > 0) {\r\nerr = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, pcf8563_irq,\r\nIRQF_SHARED|IRQF_ONESHOT|IRQF_TRIGGER_FALLING,\r\npcf8563_driver.driver.name, client);\r\nif (err) {\r\ndev_err(&client->dev, "unable to request IRQ %d\n",\r\nclient->irq);\r\nreturn err;\r\n}\r\n}\r\n#ifdef CONFIG_COMMON_CLK\r\npcf8563_clkout_register_clk(pcf8563);\r\n#endif\r\npcf8563->rtc->uie_unsupported = 1;\r\nreturn 0;\r\n}
