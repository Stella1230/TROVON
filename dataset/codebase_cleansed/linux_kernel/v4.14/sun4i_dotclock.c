static inline struct sun4i_dclk *hw_to_dclk(struct clk_hw *hw)\r\n{\r\nreturn container_of(hw, struct sun4i_dclk, hw);\r\n}\r\nstatic void sun4i_dclk_disable(struct clk_hw *hw)\r\n{\r\nstruct sun4i_dclk *dclk = hw_to_dclk(hw);\r\nregmap_update_bits(dclk->regmap, SUN4I_TCON0_DCLK_REG,\r\nBIT(SUN4I_TCON0_DCLK_GATE_BIT), 0);\r\n}\r\nstatic int sun4i_dclk_enable(struct clk_hw *hw)\r\n{\r\nstruct sun4i_dclk *dclk = hw_to_dclk(hw);\r\nreturn regmap_update_bits(dclk->regmap, SUN4I_TCON0_DCLK_REG,\r\nBIT(SUN4I_TCON0_DCLK_GATE_BIT),\r\nBIT(SUN4I_TCON0_DCLK_GATE_BIT));\r\n}\r\nstatic int sun4i_dclk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct sun4i_dclk *dclk = hw_to_dclk(hw);\r\nu32 val;\r\nregmap_read(dclk->regmap, SUN4I_TCON0_DCLK_REG, &val);\r\nreturn val & BIT(SUN4I_TCON0_DCLK_GATE_BIT);\r\n}\r\nstatic unsigned long sun4i_dclk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct sun4i_dclk *dclk = hw_to_dclk(hw);\r\nu32 val;\r\nregmap_read(dclk->regmap, SUN4I_TCON0_DCLK_REG, &val);\r\nval >>= SUN4I_TCON0_DCLK_DIV_SHIFT;\r\nval &= (1 << SUN4I_TCON0_DCLK_DIV_WIDTH) - 1;\r\nif (!val)\r\nval = 1;\r\nreturn parent_rate / val;\r\n}\r\nstatic long sun4i_dclk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned long best_parent = 0;\r\nu8 best_div = 1;\r\nint i;\r\nfor (i = 6; i <= 127; i++) {\r\nunsigned long ideal = rate * i;\r\nunsigned long rounded;\r\nrounded = clk_hw_round_rate(clk_hw_get_parent(hw),\r\nideal);\r\nif (rounded == ideal) {\r\nbest_parent = rounded;\r\nbest_div = i;\r\ngoto out;\r\n}\r\nif (abs(rate - rounded / i) <\r\nabs(rate - best_parent / best_div)) {\r\nbest_parent = rounded;\r\nbest_div = i;\r\n}\r\n}\r\nout:\r\n*parent_rate = best_parent;\r\nreturn best_parent / best_div;\r\n}\r\nstatic int sun4i_dclk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct sun4i_dclk *dclk = hw_to_dclk(hw);\r\nu8 div = parent_rate / rate;\r\nreturn regmap_update_bits(dclk->regmap, SUN4I_TCON0_DCLK_REG,\r\nGENMASK(6, 0), div);\r\n}\r\nstatic int sun4i_dclk_get_phase(struct clk_hw *hw)\r\n{\r\nstruct sun4i_dclk *dclk = hw_to_dclk(hw);\r\nu32 val;\r\nregmap_read(dclk->regmap, SUN4I_TCON0_IO_POL_REG, &val);\r\nval >>= 28;\r\nval &= 3;\r\nreturn val * 120;\r\n}\r\nstatic int sun4i_dclk_set_phase(struct clk_hw *hw, int degrees)\r\n{\r\nstruct sun4i_dclk *dclk = hw_to_dclk(hw);\r\nregmap_update_bits(dclk->regmap, SUN4I_TCON0_IO_POL_REG,\r\nGENMASK(29, 28),\r\ndegrees / 120);\r\nreturn 0;\r\n}\r\nint sun4i_dclk_create(struct device *dev, struct sun4i_tcon *tcon)\r\n{\r\nconst char *clk_name, *parent_name;\r\nstruct clk_init_data init;\r\nstruct sun4i_dclk *dclk;\r\nint ret;\r\nparent_name = __clk_get_name(tcon->sclk0);\r\nret = of_property_read_string_index(dev->of_node,\r\n"clock-output-names", 0,\r\n&clk_name);\r\nif (ret)\r\nreturn ret;\r\ndclk = devm_kzalloc(dev, sizeof(*dclk), GFP_KERNEL);\r\nif (!dclk)\r\nreturn -ENOMEM;\r\ninit.name = clk_name;\r\ninit.ops = &sun4i_dclk_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\ninit.flags = CLK_SET_RATE_PARENT;\r\ndclk->regmap = tcon->regs;\r\ndclk->hw.init = &init;\r\ntcon->dclk = clk_register(dev, &dclk->hw);\r\nif (IS_ERR(tcon->dclk))\r\nreturn PTR_ERR(tcon->dclk);\r\nreturn 0;\r\n}\r\nint sun4i_dclk_free(struct sun4i_tcon *tcon)\r\n{\r\nclk_unregister(tcon->dclk);\r\nreturn 0;\r\n}
