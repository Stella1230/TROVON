static void rcar_drif_write(struct rcar_drif *ch, u32 offset, u32 data)\r\n{\r\nwritel(data, ch->base + offset);\r\n}\r\nstatic u32 rcar_drif_read(struct rcar_drif *ch, u32 offset)\r\n{\r\nreturn readl(ch->base + offset);\r\n}\r\nstatic void rcar_drif_release_dmachannels(struct rcar_drif_sdr *sdr)\r\n{\r\nunsigned int i;\r\nfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask)\r\nif (sdr->ch[i]->dmach) {\r\ndma_release_channel(sdr->ch[i]->dmach);\r\nsdr->ch[i]->dmach = NULL;\r\n}\r\n}\r\nstatic int rcar_drif_alloc_dmachannels(struct rcar_drif_sdr *sdr)\r\n{\r\nstruct dma_slave_config dma_cfg;\r\nunsigned int i;\r\nint ret = -ENODEV;\r\nfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\r\nstruct rcar_drif *ch = sdr->ch[i];\r\nch->dmach = dma_request_slave_channel(&ch->pdev->dev, "rx");\r\nif (!ch->dmach) {\r\nrdrif_err(sdr, "ch%u: dma channel req failed\n", i);\r\ngoto dmach_error;\r\n}\r\nmemset(&dma_cfg, 0, sizeof(dma_cfg));\r\ndma_cfg.src_addr = (phys_addr_t)(ch->start + RCAR_DRIF_SIRFDR);\r\ndma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nret = dmaengine_slave_config(ch->dmach, &dma_cfg);\r\nif (ret) {\r\nrdrif_err(sdr, "ch%u: dma slave config failed\n", i);\r\ngoto dmach_error;\r\n}\r\n}\r\nreturn 0;\r\ndmach_error:\r\nrcar_drif_release_dmachannels(sdr);\r\nreturn ret;\r\n}\r\nstatic void rcar_drif_release_queued_bufs(struct rcar_drif_sdr *sdr,\r\nenum vb2_buffer_state state)\r\n{\r\nstruct rcar_drif_frame_buf *fbuf, *tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sdr->queued_bufs_lock, flags);\r\nlist_for_each_entry_safe(fbuf, tmp, &sdr->queued_bufs, list) {\r\nlist_del(&fbuf->list);\r\nvb2_buffer_done(&fbuf->vb.vb2_buf, state);\r\n}\r\nspin_unlock_irqrestore(&sdr->queued_bufs_lock, flags);\r\n}\r\nstatic inline void rcar_drif_set_mdr1(struct rcar_drif_sdr *sdr)\r\n{\r\nunsigned int i;\r\nfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\r\nrcar_drif_write(sdr->ch[i], RCAR_DRIF_SITMDR1,\r\nRCAR_DRIF_SITMDR1_PCON);\r\nrcar_drif_write(sdr->ch[i], RCAR_DRIF_SIRMDR1, sdr->mdr1);\r\nrdrif_dbg(sdr, "ch%u: mdr1 = 0x%08x",\r\ni, rcar_drif_read(sdr->ch[i], RCAR_DRIF_SIRMDR1));\r\n}\r\n}\r\nstatic int rcar_drif_set_format(struct rcar_drif_sdr *sdr)\r\n{\r\nunsigned int i;\r\nrdrif_dbg(sdr, "setfmt: bitlen %u wdcnt %u num_ch %u\n",\r\nsdr->fmt->bitlen, sdr->fmt->wdcnt, sdr->fmt->num_ch);\r\nif (sdr->fmt->num_ch > sdr->num_cur_ch) {\r\nrdrif_err(sdr, "fmt num_ch %u cur_ch %u mismatch\n",\r\nsdr->fmt->num_ch, sdr->num_cur_ch);\r\nreturn -EINVAL;\r\n}\r\nfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\r\nu32 mdr;\r\nmdr = RCAR_DRIF_MDR_GRPCNT(2) |\r\nRCAR_DRIF_MDR_BITLEN(sdr->fmt->bitlen) |\r\nRCAR_DRIF_MDR_WDCNT(sdr->fmt->wdcnt);\r\nrcar_drif_write(sdr->ch[i], RCAR_DRIF_SIRMDR2, mdr);\r\nmdr = RCAR_DRIF_MDR_BITLEN(sdr->fmt->bitlen) |\r\nRCAR_DRIF_MDR_WDCNT(sdr->fmt->wdcnt);\r\nrcar_drif_write(sdr->ch[i], RCAR_DRIF_SIRMDR3, mdr);\r\nrdrif_dbg(sdr, "ch%u: new mdr[2,3] = 0x%08x, 0x%08x\n",\r\ni, rcar_drif_read(sdr->ch[i], RCAR_DRIF_SIRMDR2),\r\nrcar_drif_read(sdr->ch[i], RCAR_DRIF_SIRMDR3));\r\n}\r\nreturn 0;\r\n}\r\nstatic void rcar_drif_release_buf(struct rcar_drif_sdr *sdr)\r\n{\r\nunsigned int i;\r\nfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\r\nstruct rcar_drif *ch = sdr->ch[i];\r\nif (ch->buf[0].addr) {\r\ndma_free_coherent(&ch->pdev->dev,\r\nsdr->hwbuf_size * RCAR_DRIF_NUM_HWBUFS,\r\nch->buf[0].addr, ch->dma_handle);\r\nch->buf[0].addr = NULL;\r\n}\r\n}\r\n}\r\nstatic int rcar_drif_request_buf(struct rcar_drif_sdr *sdr)\r\n{\r\nint ret = -ENOMEM;\r\nunsigned int i, j;\r\nvoid *addr;\r\nfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\r\nstruct rcar_drif *ch = sdr->ch[i];\r\naddr = dma_alloc_coherent(&ch->pdev->dev,\r\nsdr->hwbuf_size * RCAR_DRIF_NUM_HWBUFS,\r\n&ch->dma_handle, GFP_KERNEL);\r\nif (!addr) {\r\nrdrif_err(sdr,\r\n"ch%u: dma alloc failed. num hwbufs %u size %u\n",\r\ni, RCAR_DRIF_NUM_HWBUFS, sdr->hwbuf_size);\r\ngoto error;\r\n}\r\nfor (j = 0; j < RCAR_DRIF_NUM_HWBUFS; j++) {\r\nch->buf[j].addr = addr + (j * sdr->hwbuf_size);\r\nch->buf[j].status = 0;\r\n}\r\n}\r\nreturn 0;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int rcar_drif_queue_setup(struct vb2_queue *vq,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct rcar_drif_sdr *sdr = vb2_get_drv_priv(vq);\r\nif (vq->num_buffers + *num_buffers < 16)\r\n*num_buffers = 16 - vq->num_buffers;\r\n*num_planes = 1;\r\nsizes[0] = PAGE_ALIGN(sdr->fmt->buffersize);\r\nrdrif_dbg(sdr, "num_bufs %d sizes[0] %d\n", *num_buffers, sizes[0]);\r\nreturn 0;\r\n}\r\nstatic void rcar_drif_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct rcar_drif_sdr *sdr = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct rcar_drif_frame_buf *fbuf =\r\ncontainer_of(vbuf, struct rcar_drif_frame_buf, vb);\r\nunsigned long flags;\r\nrdrif_dbg(sdr, "buf_queue idx %u\n", vb->index);\r\nspin_lock_irqsave(&sdr->queued_bufs_lock, flags);\r\nlist_add_tail(&fbuf->list, &sdr->queued_bufs);\r\nspin_unlock_irqrestore(&sdr->queued_bufs_lock, flags);\r\n}\r\nstatic struct rcar_drif_frame_buf *\r\nrcar_drif_get_fbuf(struct rcar_drif_sdr *sdr)\r\n{\r\nstruct rcar_drif_frame_buf *fbuf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sdr->queued_bufs_lock, flags);\r\nfbuf = list_first_entry_or_null(&sdr->queued_bufs, struct\r\nrcar_drif_frame_buf, list);\r\nif (!fbuf) {\r\nrdrif_dbg(sdr, "\napp late: prod %u\n", sdr->produced);\r\nspin_unlock_irqrestore(&sdr->queued_bufs_lock, flags);\r\nreturn NULL;\r\n}\r\nlist_del(&fbuf->list);\r\nspin_unlock_irqrestore(&sdr->queued_bufs_lock, flags);\r\nreturn fbuf;\r\n}\r\nstatic inline bool rcar_drif_bufs_done(struct rcar_drif_hwbuf **buf)\r\n{\r\nreturn (buf[0]->status & buf[1]->status & RCAR_DRIF_BUF_DONE);\r\n}\r\nstatic inline bool rcar_drif_bufs_overflow(struct rcar_drif_hwbuf **buf)\r\n{\r\nreturn ((buf[0]->status | buf[1]->status) & RCAR_DRIF_BUF_OVERFLOW);\r\n}\r\nstatic inline void rcar_drif_bufs_clear(struct rcar_drif_hwbuf **buf,\r\nunsigned int bit)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < RCAR_DRIF_MAX_CHANNEL; i++)\r\nbuf[i]->status &= ~bit;\r\n}\r\nstatic void rcar_drif_channel_complete(struct rcar_drif *ch, u32 idx)\r\n{\r\nu32 str;\r\nch->buf[idx].status |= RCAR_DRIF_BUF_DONE;\r\nstr = rcar_drif_read(ch, RCAR_DRIF_SISTR);\r\nif (unlikely(str & RCAR_DRIF_RFOVF)) {\r\nrcar_drif_write(ch, RCAR_DRIF_SISTR, str);\r\nch->buf[idx].status |= RCAR_DRIF_BUF_OVERFLOW;\r\n}\r\n}\r\nstatic void rcar_drif_dma_complete(void *dma_async_param)\r\n{\r\nstruct rcar_drif *ch = dma_async_param;\r\nstruct rcar_drif_sdr *sdr = ch->sdr;\r\nstruct rcar_drif_hwbuf *buf[RCAR_DRIF_MAX_CHANNEL];\r\nstruct rcar_drif_frame_buf *fbuf;\r\nbool overflow = false;\r\nu32 idx, produced;\r\nunsigned int i;\r\nspin_lock(&sdr->dma_lock);\r\nif (!vb2_is_streaming(&sdr->vb_queue)) {\r\nspin_unlock(&sdr->dma_lock);\r\nreturn;\r\n}\r\nidx = sdr->produced % RCAR_DRIF_NUM_HWBUFS;\r\nrcar_drif_channel_complete(ch, idx);\r\nif (sdr->num_cur_ch == RCAR_DRIF_MAX_CHANNEL) {\r\nbuf[0] = ch->num ? to_rcar_drif_buf_pair(sdr, ch->num, idx) :\r\n&ch->buf[idx];\r\nbuf[1] = ch->num ? &ch->buf[idx] :\r\nto_rcar_drif_buf_pair(sdr, ch->num, idx);\r\nif (!rcar_drif_bufs_done(buf)) {\r\nspin_unlock(&sdr->dma_lock);\r\nreturn;\r\n}\r\nrcar_drif_bufs_clear(buf, RCAR_DRIF_BUF_DONE);\r\nif (rcar_drif_bufs_overflow(buf)) {\r\noverflow = true;\r\nrcar_drif_bufs_clear(buf, RCAR_DRIF_BUF_OVERFLOW);\r\n}\r\n} else {\r\nbuf[0] = &ch->buf[idx];\r\nif (buf[0]->status & RCAR_DRIF_BUF_OVERFLOW) {\r\noverflow = true;\r\nbuf[0]->status &= ~RCAR_DRIF_BUF_OVERFLOW;\r\n}\r\n}\r\nproduced = sdr->produced++;\r\nspin_unlock(&sdr->dma_lock);\r\nrdrif_dbg(sdr, "ch%u: prod %u\n", ch->num, produced);\r\nfbuf = rcar_drif_get_fbuf(sdr);\r\nif (!fbuf)\r\nreturn;\r\nfor (i = 0; i < RCAR_DRIF_MAX_CHANNEL; i++)\r\nmemcpy(vb2_plane_vaddr(&fbuf->vb.vb2_buf, 0) +\r\ni * sdr->hwbuf_size, buf[i]->addr, sdr->hwbuf_size);\r\nfbuf->vb.field = V4L2_FIELD_NONE;\r\nfbuf->vb.sequence = produced;\r\nfbuf->vb.vb2_buf.timestamp = ktime_get_ns();\r\nvb2_set_plane_payload(&fbuf->vb.vb2_buf, 0, sdr->fmt->buffersize);\r\nvb2_buffer_done(&fbuf->vb.vb2_buf,\r\noverflow ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\r\n}\r\nstatic int rcar_drif_qbuf(struct rcar_drif *ch)\r\n{\r\nstruct rcar_drif_sdr *sdr = ch->sdr;\r\ndma_addr_t addr = ch->dma_handle;\r\nstruct dma_async_tx_descriptor *rxd;\r\ndma_cookie_t cookie;\r\nint ret = -EIO;\r\nrxd = dmaengine_prep_dma_cyclic(ch->dmach, addr,\r\nsdr->hwbuf_size * RCAR_DRIF_NUM_HWBUFS,\r\nsdr->hwbuf_size, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!rxd) {\r\nrdrif_err(sdr, "ch%u: prep dma cyclic failed\n", ch->num);\r\nreturn ret;\r\n}\r\nrxd->callback = rcar_drif_dma_complete;\r\nrxd->callback_param = ch;\r\ncookie = dmaengine_submit(rxd);\r\nif (dma_submit_error(cookie)) {\r\nrdrif_err(sdr, "ch%u: dma submit failed\n", ch->num);\r\nreturn ret;\r\n}\r\ndma_async_issue_pending(ch->dmach);\r\nreturn 0;\r\n}\r\nstatic int rcar_drif_enable_rx(struct rcar_drif_sdr *sdr)\r\n{\r\nunsigned int i;\r\nu32 ctr;\r\nint ret;\r\nfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\r\nctr = rcar_drif_read(sdr->ch[i], RCAR_DRIF_SICTR);\r\nctr |= (RCAR_DRIF_SICTR_RX_RISING_EDGE |\r\nRCAR_DRIF_SICTR_RX_EN);\r\nrcar_drif_write(sdr->ch[i], RCAR_DRIF_SICTR, ctr);\r\n}\r\nfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\r\nret = readl_poll_timeout(sdr->ch[i]->base + RCAR_DRIF_SICTR,\r\nctr, ctr & RCAR_DRIF_SICTR_RX_EN, 7, 100000);\r\nif (ret) {\r\nrdrif_err(sdr, "ch%u: rx en failed. ctr 0x%08x\n", i,\r\nrcar_drif_read(sdr->ch[i], RCAR_DRIF_SICTR));\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void rcar_drif_disable_rx(struct rcar_drif_sdr *sdr)\r\n{\r\nunsigned int i;\r\nu32 ctr;\r\nint ret;\r\nfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\r\nctr = rcar_drif_read(sdr->ch[i], RCAR_DRIF_SICTR);\r\nctr &= ~RCAR_DRIF_SICTR_RX_EN;\r\nrcar_drif_write(sdr->ch[i], RCAR_DRIF_SICTR, ctr);\r\n}\r\nfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\r\nret = readl_poll_timeout(sdr->ch[i]->base + RCAR_DRIF_SICTR,\r\nctr, !(ctr & RCAR_DRIF_SICTR_RX_EN), 7, 100000);\r\nif (ret)\r\ndev_warn(&sdr->vdev->dev,\r\n"ch%u: failed to disable rx. ctr 0x%08x\n",\r\ni, rcar_drif_read(sdr->ch[i], RCAR_DRIF_SICTR));\r\n}\r\n}\r\nstatic void rcar_drif_stop_channel(struct rcar_drif *ch)\r\n{\r\nrcar_drif_write(ch, RCAR_DRIF_SIIER, 0x00000000);\r\ndmaengine_terminate_sync(ch->dmach);\r\n}\r\nstatic void rcar_drif_stop(struct rcar_drif_sdr *sdr)\r\n{\r\nunsigned int i;\r\nrcar_drif_disable_rx(sdr);\r\nfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask)\r\nrcar_drif_stop_channel(sdr->ch[i]);\r\n}\r\nstatic int rcar_drif_start_channel(struct rcar_drif *ch)\r\n{\r\nstruct rcar_drif_sdr *sdr = ch->sdr;\r\nu32 ctr, str;\r\nint ret;\r\nrcar_drif_write(ch, RCAR_DRIF_SICTR, RCAR_DRIF_SICTR_RESET);\r\nret = readl_poll_timeout(ch->base + RCAR_DRIF_SICTR, ctr,\r\n!(ctr & RCAR_DRIF_SICTR_RESET), 7, 100000);\r\nif (ret) {\r\nrdrif_err(sdr, "ch%u: failed to reset rx. ctr 0x%08x\n",\r\nch->num, rcar_drif_read(ch, RCAR_DRIF_SICTR));\r\nreturn ret;\r\n}\r\nret = rcar_drif_qbuf(ch);\r\nif (ret)\r\nreturn ret;\r\nstr = RCAR_DRIF_RFFUL | RCAR_DRIF_REOF | RCAR_DRIF_RFSERR |\r\nRCAR_DRIF_RFUDF | RCAR_DRIF_RFOVF;\r\nrcar_drif_write(ch, RCAR_DRIF_SISTR, str);\r\nrcar_drif_write(ch, RCAR_DRIF_SIIER, 0x00009000);\r\nreturn ret;\r\n}\r\nstatic int rcar_drif_start(struct rcar_drif_sdr *sdr)\r\n{\r\nunsigned long enabled = 0;\r\nunsigned int i;\r\nint ret;\r\nfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\r\nret = rcar_drif_start_channel(sdr->ch[i]);\r\nif (ret)\r\ngoto start_error;\r\nenabled |= BIT(i);\r\n}\r\nret = rcar_drif_enable_rx(sdr);\r\nif (ret)\r\ngoto enable_error;\r\nsdr->produced = 0;\r\nreturn ret;\r\nenable_error:\r\nrcar_drif_disable_rx(sdr);\r\nstart_error:\r\nfor_each_rcar_drif_channel(i, &enabled)\r\nrcar_drif_stop_channel(sdr->ch[i]);\r\nreturn ret;\r\n}\r\nstatic int rcar_drif_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct rcar_drif_sdr *sdr = vb2_get_drv_priv(vq);\r\nunsigned long enabled = 0;\r\nunsigned int i;\r\nint ret;\r\nmutex_lock(&sdr->v4l2_mutex);\r\nfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\r\nret = clk_prepare_enable(sdr->ch[i]->clk);\r\nif (ret)\r\ngoto error;\r\nenabled |= BIT(i);\r\n}\r\nrcar_drif_set_mdr1(sdr);\r\nret = rcar_drif_set_format(sdr);\r\nif (ret)\r\ngoto error;\r\nif (sdr->num_cur_ch == RCAR_DRIF_MAX_CHANNEL)\r\nsdr->hwbuf_size = sdr->fmt->buffersize / RCAR_DRIF_MAX_CHANNEL;\r\nelse\r\nsdr->hwbuf_size = sdr->fmt->buffersize;\r\nrdrif_dbg(sdr, "num hwbufs %u, hwbuf_size %u\n",\r\nRCAR_DRIF_NUM_HWBUFS, sdr->hwbuf_size);\r\nret = rcar_drif_alloc_dmachannels(sdr);\r\nif (ret)\r\ngoto error;\r\nret = rcar_drif_request_buf(sdr);\r\nif (ret)\r\ngoto error;\r\nret = rcar_drif_start(sdr);\r\nif (ret)\r\ngoto error;\r\nmutex_unlock(&sdr->v4l2_mutex);\r\nreturn ret;\r\nerror:\r\nrcar_drif_release_queued_bufs(sdr, VB2_BUF_STATE_QUEUED);\r\nrcar_drif_release_buf(sdr);\r\nrcar_drif_release_dmachannels(sdr);\r\nfor_each_rcar_drif_channel(i, &enabled)\r\nclk_disable_unprepare(sdr->ch[i]->clk);\r\nmutex_unlock(&sdr->v4l2_mutex);\r\nreturn ret;\r\n}\r\nstatic void rcar_drif_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct rcar_drif_sdr *sdr = vb2_get_drv_priv(vq);\r\nunsigned int i;\r\nmutex_lock(&sdr->v4l2_mutex);\r\nrcar_drif_stop(sdr);\r\nrcar_drif_release_queued_bufs(sdr, VB2_BUF_STATE_ERROR);\r\nrcar_drif_release_buf(sdr);\r\nrcar_drif_release_dmachannels(sdr);\r\nfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask)\r\nclk_disable_unprepare(sdr->ch[i]->clk);\r\nmutex_unlock(&sdr->v4l2_mutex);\r\n}\r\nstatic int rcar_drif_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct rcar_drif_sdr *sdr = video_drvdata(file);\r\nstrlcpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, sdr->vdev->name, sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",\r\nsdr->vdev->name);\r\nreturn 0;\r\n}\r\nstatic int rcar_drif_set_default_format(struct rcar_drif_sdr *sdr)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(formats); i++) {\r\nif (sdr->num_hw_ch == formats[i].num_ch) {\r\nsdr->fmt = &formats[i];\r\nsdr->cur_ch_mask = sdr->hw_ch_mask;\r\nsdr->num_cur_ch = sdr->num_hw_ch;\r\ndev_dbg(sdr->dev, "default fmt[%u]: mask %lu num %u\n",\r\ni, sdr->cur_ch_mask, sdr->num_cur_ch);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int rcar_drif_enum_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index >= ARRAY_SIZE(formats))\r\nreturn -EINVAL;\r\nf->pixelformat = formats[f->index].pixelformat;\r\nreturn 0;\r\n}\r\nstatic int rcar_drif_g_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct rcar_drif_sdr *sdr = video_drvdata(file);\r\nf->fmt.sdr.pixelformat = sdr->fmt->pixelformat;\r\nf->fmt.sdr.buffersize = sdr->fmt->buffersize;\r\nreturn 0;\r\n}\r\nstatic int rcar_drif_s_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct rcar_drif_sdr *sdr = video_drvdata(file);\r\nstruct vb2_queue *q = &sdr->vb_queue;\r\nunsigned int i;\r\nif (vb2_is_busy(q))\r\nreturn -EBUSY;\r\nfor (i = 0; i < ARRAY_SIZE(formats); i++) {\r\nif (formats[i].pixelformat == f->fmt.sdr.pixelformat)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(formats))\r\ni = 0;\r\nsdr->fmt = &formats[i];\r\nf->fmt.sdr.pixelformat = sdr->fmt->pixelformat;\r\nf->fmt.sdr.buffersize = formats[i].buffersize;\r\nmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\r\nif (formats[i].num_ch < sdr->num_hw_ch) {\r\nsdr->cur_ch_mask = BIT(0);\r\nsdr->num_cur_ch = formats[i].num_ch;\r\n} else {\r\nsdr->cur_ch_mask = sdr->hw_ch_mask;\r\nsdr->num_cur_ch = sdr->num_hw_ch;\r\n}\r\nrdrif_dbg(sdr, "cur: idx %u mask %lu num %u\n",\r\ni, sdr->cur_ch_mask, sdr->num_cur_ch);\r\nreturn 0;\r\n}\r\nstatic int rcar_drif_try_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(formats); i++) {\r\nif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\r\nf->fmt.sdr.buffersize = formats[i].buffersize;\r\nreturn 0;\r\n}\r\n}\r\nf->fmt.sdr.pixelformat = formats[0].pixelformat;\r\nf->fmt.sdr.buffersize = formats[0].buffersize;\r\nmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\r\nreturn 0;\r\n}\r\nstatic int rcar_drif_enum_freq_bands(struct file *file, void *priv,\r\nstruct v4l2_frequency_band *band)\r\n{\r\nstruct rcar_drif_sdr *sdr = video_drvdata(file);\r\nreturn v4l2_subdev_call(sdr->ep.subdev, tuner, enum_freq_bands, band);\r\n}\r\nstatic int rcar_drif_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct rcar_drif_sdr *sdr = video_drvdata(file);\r\nreturn v4l2_subdev_call(sdr->ep.subdev, tuner, g_frequency, f);\r\n}\r\nstatic int rcar_drif_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct rcar_drif_sdr *sdr = video_drvdata(file);\r\nreturn v4l2_subdev_call(sdr->ep.subdev, tuner, s_frequency, f);\r\n}\r\nstatic int rcar_drif_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *vt)\r\n{\r\nstruct rcar_drif_sdr *sdr = video_drvdata(file);\r\nreturn v4l2_subdev_call(sdr->ep.subdev, tuner, g_tuner, vt);\r\n}\r\nstatic int rcar_drif_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *vt)\r\n{\r\nstruct rcar_drif_sdr *sdr = video_drvdata(file);\r\nreturn v4l2_subdev_call(sdr->ep.subdev, tuner, s_tuner, vt);\r\n}\r\nstatic int rcar_drif_sdr_register(struct rcar_drif_sdr *sdr)\r\n{\r\nint ret;\r\nsdr->vdev = video_device_alloc();\r\nif (!sdr->vdev)\r\nreturn -ENOMEM;\r\nsnprintf(sdr->vdev->name, sizeof(sdr->vdev->name), "R-Car DRIF");\r\nsdr->vdev->fops = &rcar_drif_fops;\r\nsdr->vdev->ioctl_ops = &rcar_drif_ioctl_ops;\r\nsdr->vdev->release = video_device_release;\r\nsdr->vdev->lock = &sdr->v4l2_mutex;\r\nsdr->vdev->queue = &sdr->vb_queue;\r\nsdr->vdev->queue->lock = &sdr->vb_queue_mutex;\r\nsdr->vdev->ctrl_handler = &sdr->ctrl_hdl;\r\nsdr->vdev->v4l2_dev = &sdr->v4l2_dev;\r\nsdr->vdev->device_caps = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_TUNER |\r\nV4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\r\nvideo_set_drvdata(sdr->vdev, sdr);\r\nret = video_register_device(sdr->vdev, VFL_TYPE_SDR, -1);\r\nif (ret) {\r\nvideo_device_release(sdr->vdev);\r\nsdr->vdev = NULL;\r\ndev_err(sdr->dev, "failed video_register_device (%d)\n", ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic void rcar_drif_sdr_unregister(struct rcar_drif_sdr *sdr)\r\n{\r\nvideo_unregister_device(sdr->vdev);\r\nsdr->vdev = NULL;\r\n}\r\nstatic int rcar_drif_notify_bound(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nstruct rcar_drif_sdr *sdr =\r\ncontainer_of(notifier, struct rcar_drif_sdr, notifier);\r\nif (sdr->ep.asd.match.fwnode.fwnode !=\r\nof_fwnode_handle(subdev->dev->of_node)) {\r\nrdrif_err(sdr, "subdev %s cannot bind\n", subdev->name);\r\nreturn -EINVAL;\r\n}\r\nv4l2_set_subdev_hostdata(subdev, sdr);\r\nsdr->ep.subdev = subdev;\r\nrdrif_dbg(sdr, "bound asd %s\n", subdev->name);\r\nreturn 0;\r\n}\r\nstatic void rcar_drif_notify_unbind(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nstruct rcar_drif_sdr *sdr =\r\ncontainer_of(notifier, struct rcar_drif_sdr, notifier);\r\nif (sdr->ep.subdev != subdev) {\r\nrdrif_err(sdr, "subdev %s is not bound\n", subdev->name);\r\nreturn;\r\n}\r\nv4l2_ctrl_handler_free(&sdr->ctrl_hdl);\r\nsdr->v4l2_dev.ctrl_handler = NULL;\r\nsdr->ep.subdev = NULL;\r\nrcar_drif_sdr_unregister(sdr);\r\nrdrif_dbg(sdr, "unbind asd %s\n", subdev->name);\r\n}\r\nstatic int rcar_drif_notify_complete(struct v4l2_async_notifier *notifier)\r\n{\r\nstruct rcar_drif_sdr *sdr =\r\ncontainer_of(notifier, struct rcar_drif_sdr, notifier);\r\nint ret;\r\nret = v4l2_ctrl_handler_init(&sdr->ctrl_hdl, 10);\r\nif (ret)\r\nreturn -ENOMEM;\r\nsdr->v4l2_dev.ctrl_handler = &sdr->ctrl_hdl;\r\nret = v4l2_device_register_subdev_nodes(&sdr->v4l2_dev);\r\nif (ret) {\r\nrdrif_err(sdr, "failed: register subdev nodes ret %d\n", ret);\r\ngoto error;\r\n}\r\nret = v4l2_ctrl_add_handler(&sdr->ctrl_hdl,\r\nsdr->ep.subdev->ctrl_handler, NULL);\r\nif (ret) {\r\nrdrif_err(sdr, "failed: ctrl add hdlr ret %d\n", ret);\r\ngoto error;\r\n}\r\nret = rcar_drif_sdr_register(sdr);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\nv4l2_ctrl_handler_free(&sdr->ctrl_hdl);\r\nreturn ret;\r\n}\r\nstatic void rcar_drif_get_ep_properties(struct rcar_drif_sdr *sdr,\r\nstruct fwnode_handle *fwnode)\r\n{\r\nu32 val;\r\nsdr->mdr1 = RCAR_DRIF_SIRMDR1_SYNCMD_LR | RCAR_DRIF_SIRMDR1_MSB_FIRST |\r\nRCAR_DRIF_SIRMDR1_DTDL_1 | RCAR_DRIF_SIRMDR1_SYNCDL_0;\r\nif (!fwnode_property_read_u32(fwnode, "sync-active", &val))\r\nsdr->mdr1 |= val ? RCAR_DRIF_SIRMDR1_SYNCAC_POL_HIGH :\r\nRCAR_DRIF_SIRMDR1_SYNCAC_POL_LOW;\r\nelse\r\nsdr->mdr1 |= RCAR_DRIF_SIRMDR1_SYNCAC_POL_HIGH;\r\ndev_dbg(sdr->dev, "mdr1 0x%08x\n", sdr->mdr1);\r\n}\r\nstatic int rcar_drif_parse_subdevs(struct rcar_drif_sdr *sdr)\r\n{\r\nstruct v4l2_async_notifier *notifier = &sdr->notifier;\r\nstruct fwnode_handle *fwnode, *ep;\r\nnotifier->subdevs = devm_kzalloc(sdr->dev, sizeof(*notifier->subdevs),\r\nGFP_KERNEL);\r\nif (!notifier->subdevs)\r\nreturn -ENOMEM;\r\nep = fwnode_graph_get_next_endpoint(of_fwnode_handle(sdr->dev->of_node),\r\nNULL);\r\nif (!ep)\r\nreturn 0;\r\nnotifier->subdevs[notifier->num_subdevs] = &sdr->ep.asd;\r\nfwnode = fwnode_graph_get_remote_port_parent(ep);\r\nif (!fwnode) {\r\ndev_warn(sdr->dev, "bad remote port parent\n");\r\nfwnode_handle_put(ep);\r\nreturn -EINVAL;\r\n}\r\nsdr->ep.asd.match.fwnode.fwnode = fwnode;\r\nsdr->ep.asd.match_type = V4L2_ASYNC_MATCH_FWNODE;\r\nnotifier->num_subdevs++;\r\nrcar_drif_get_ep_properties(sdr, ep);\r\nfwnode_handle_put(fwnode);\r\nfwnode_handle_put(ep);\r\nreturn 0;\r\n}\r\nstatic bool rcar_drif_primary_bond(struct platform_device *pdev)\r\n{\r\nreturn of_property_read_bool(pdev->dev.of_node, "renesas,primary-bond");\r\n}\r\nstatic struct device_node *rcar_drif_bond_enabled(struct platform_device *p)\r\n{\r\nstruct device_node *np;\r\nnp = of_parse_phandle(p->dev.of_node, "renesas,bonding", 0);\r\nif (np && of_device_is_available(np))\r\nreturn np;\r\nreturn NULL;\r\n}\r\nstatic int rcar_drif_bond_available(struct rcar_drif_sdr *sdr,\r\nstruct device_node *np)\r\n{\r\nstruct platform_device *pdev;\r\nstruct rcar_drif *ch;\r\nint ret = 0;\r\npdev = of_find_device_by_node(np);\r\nif (!pdev) {\r\ndev_err(sdr->dev, "failed to get bonded device from node\n");\r\nreturn -ENODEV;\r\n}\r\ndevice_lock(&pdev->dev);\r\nch = platform_get_drvdata(pdev);\r\nif (ch) {\r\nch->sdr = sdr;\r\nsdr->ch[ch->num] = ch;\r\nsdr->hw_ch_mask |= BIT(ch->num);\r\n} else {\r\ndev_info(sdr->dev, "defer probe\n");\r\nret = -EPROBE_DEFER;\r\n}\r\ndevice_unlock(&pdev->dev);\r\nput_device(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int rcar_drif_sdr_probe(struct rcar_drif_sdr *sdr)\r\n{\r\nint ret;\r\nret = rcar_drif_set_default_format(sdr);\r\nif (ret) {\r\ndev_err(sdr->dev, "failed to set default format\n");\r\nreturn ret;\r\n}\r\nsdr->hwbuf_size = RCAR_DRIF_DEFAULT_HWBUF_SIZE;\r\nmutex_init(&sdr->v4l2_mutex);\r\nmutex_init(&sdr->vb_queue_mutex);\r\nspin_lock_init(&sdr->queued_bufs_lock);\r\nspin_lock_init(&sdr->dma_lock);\r\nINIT_LIST_HEAD(&sdr->queued_bufs);\r\nsdr->vb_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;\r\nsdr->vb_queue.io_modes = VB2_READ | VB2_MMAP | VB2_DMABUF;\r\nsdr->vb_queue.drv_priv = sdr;\r\nsdr->vb_queue.buf_struct_size = sizeof(struct rcar_drif_frame_buf);\r\nsdr->vb_queue.ops = &rcar_drif_vb2_ops;\r\nsdr->vb_queue.mem_ops = &vb2_vmalloc_memops;\r\nsdr->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nret = vb2_queue_init(&sdr->vb_queue);\r\nif (ret) {\r\ndev_err(sdr->dev, "failed: vb2_queue_init ret %d\n", ret);\r\nreturn ret;\r\n}\r\nret = v4l2_device_register(sdr->dev, &sdr->v4l2_dev);\r\nif (ret) {\r\ndev_err(sdr->dev, "failed: v4l2_device_register ret %d\n", ret);\r\nreturn ret;\r\n}\r\nret = rcar_drif_parse_subdevs(sdr);\r\nif (ret)\r\ngoto error;\r\nsdr->notifier.bound = rcar_drif_notify_bound;\r\nsdr->notifier.unbind = rcar_drif_notify_unbind;\r\nsdr->notifier.complete = rcar_drif_notify_complete;\r\nret = v4l2_async_notifier_register(&sdr->v4l2_dev, &sdr->notifier);\r\nif (ret < 0) {\r\ndev_err(sdr->dev, "failed: notifier register ret %d\n", ret);\r\ngoto error;\r\n}\r\nreturn ret;\r\nerror:\r\nv4l2_device_unregister(&sdr->v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic void rcar_drif_sdr_remove(struct rcar_drif_sdr *sdr)\r\n{\r\nv4l2_async_notifier_unregister(&sdr->notifier);\r\nv4l2_device_unregister(&sdr->v4l2_dev);\r\n}\r\nstatic int rcar_drif_probe(struct platform_device *pdev)\r\n{\r\nstruct rcar_drif_sdr *sdr;\r\nstruct device_node *np;\r\nstruct rcar_drif *ch;\r\nstruct resource *res;\r\nint ret;\r\nch = devm_kzalloc(&pdev->dev, sizeof(*ch), GFP_KERNEL);\r\nif (!ch)\r\nreturn -ENOMEM;\r\nch->pdev = pdev;\r\nch->clk = devm_clk_get(&pdev->dev, "fck");\r\nif (IS_ERR(ch->clk)) {\r\nret = PTR_ERR(ch->clk);\r\ndev_err(&pdev->dev, "clk get failed (%d)\n", ret);\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nch->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ch->base)) {\r\nret = PTR_ERR(ch->base);\r\ndev_err(&pdev->dev, "ioremap failed (%d)\n", ret);\r\nreturn ret;\r\n}\r\nch->start = res->start;\r\nplatform_set_drvdata(pdev, ch);\r\nnp = rcar_drif_bond_enabled(pdev);\r\nif (np) {\r\nif (!rcar_drif_primary_bond(pdev)) {\r\nch->num = 1;\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\n}\r\nsdr = devm_kzalloc(&pdev->dev, sizeof(*sdr), GFP_KERNEL);\r\nif (!sdr) {\r\nof_node_put(np);\r\nreturn -ENOMEM;\r\n}\r\nch->sdr = sdr;\r\nsdr->dev = &pdev->dev;\r\nsdr->ch[ch->num] = ch;\r\nsdr->hw_ch_mask = BIT(ch->num);\r\nif (np) {\r\nret = rcar_drif_bond_available(sdr, np);\r\nof_node_put(np);\r\nif (ret)\r\nreturn ret;\r\n}\r\nsdr->num_hw_ch = hweight_long(sdr->hw_ch_mask);\r\nreturn rcar_drif_sdr_probe(sdr);\r\n}\r\nstatic int rcar_drif_remove(struct platform_device *pdev)\r\n{\r\nstruct rcar_drif *ch = platform_get_drvdata(pdev);\r\nstruct rcar_drif_sdr *sdr = ch->sdr;\r\nif (ch->num)\r\nreturn 0;\r\nrcar_drif_sdr_remove(sdr);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused rcar_drif_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused rcar_drif_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}
