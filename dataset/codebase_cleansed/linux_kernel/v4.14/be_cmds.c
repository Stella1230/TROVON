struct be_mcc_wrb *alloc_mcc_wrb(struct beiscsi_hba *phba,\r\nunsigned int *ref_tag)\r\n{\r\nstruct be_queue_info *mccq = &phba->ctrl.mcc_obj.q;\r\nstruct be_mcc_wrb *wrb = NULL;\r\nunsigned int tag;\r\nspin_lock(&phba->ctrl.mcc_lock);\r\nif (mccq->used == mccq->len) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT |\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BC_%d : MCC queue full: WRB used %u tag avail %u\n",\r\nmccq->used, phba->ctrl.mcc_tag_available);\r\ngoto alloc_failed;\r\n}\r\nif (!phba->ctrl.mcc_tag_available)\r\ngoto alloc_failed;\r\ntag = phba->ctrl.mcc_tag[phba->ctrl.mcc_alloc_index];\r\nif (!tag) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT |\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BC_%d : MCC tag 0 allocated: tag avail %u alloc index %u\n",\r\nphba->ctrl.mcc_tag_available,\r\nphba->ctrl.mcc_alloc_index);\r\ngoto alloc_failed;\r\n}\r\n*ref_tag = tag;\r\nphba->ctrl.mcc_tag[phba->ctrl.mcc_alloc_index] = 0;\r\nphba->ctrl.mcc_tag_status[tag] = 0;\r\nphba->ctrl.ptag_state[tag].tag_state = 0;\r\nphba->ctrl.ptag_state[tag].cbfn = NULL;\r\nphba->ctrl.mcc_tag_available--;\r\nif (phba->ctrl.mcc_alloc_index == (MAX_MCC_CMD - 1))\r\nphba->ctrl.mcc_alloc_index = 0;\r\nelse\r\nphba->ctrl.mcc_alloc_index++;\r\nwrb = queue_head_node(mccq);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nwrb->tag0 = tag;\r\nwrb->tag0 |= (mccq->head << MCC_Q_WRB_IDX_SHIFT) & MCC_Q_WRB_IDX_MASK;\r\nqueue_head_inc(mccq);\r\nmccq->used++;\r\nalloc_failed:\r\nspin_unlock(&phba->ctrl.mcc_lock);\r\nreturn wrb;\r\n}\r\nvoid free_mcc_wrb(struct be_ctrl_info *ctrl, unsigned int tag)\r\n{\r\nstruct be_queue_info *mccq = &ctrl->mcc_obj.q;\r\nspin_lock(&ctrl->mcc_lock);\r\ntag = tag & MCC_Q_CMD_TAG_MASK;\r\nctrl->mcc_tag[ctrl->mcc_free_index] = tag;\r\nif (ctrl->mcc_free_index == (MAX_MCC_CMD - 1))\r\nctrl->mcc_free_index = 0;\r\nelse\r\nctrl->mcc_free_index++;\r\nctrl->mcc_tag_available++;\r\nmccq->used--;\r\nspin_unlock(&ctrl->mcc_lock);\r\n}\r\nint __beiscsi_mcc_compl_status(struct beiscsi_hba *phba,\r\nunsigned int tag,\r\nstruct be_mcc_wrb **wrb,\r\nstruct be_dma_mem *mbx_cmd_mem)\r\n{\r\nstruct be_queue_info *mccq = &phba->ctrl.mcc_obj.q;\r\nuint16_t status = 0, addl_status = 0, wrb_num = 0;\r\nstruct be_cmd_resp_hdr *mbx_resp_hdr;\r\nstruct be_cmd_req_hdr *mbx_hdr;\r\nstruct be_mcc_wrb *temp_wrb;\r\nuint32_t mcc_tag_status;\r\nint rc = 0;\r\nmcc_tag_status = phba->ctrl.mcc_tag_status[tag];\r\nstatus = (mcc_tag_status & CQE_STATUS_MASK);\r\naddl_status = ((mcc_tag_status & CQE_STATUS_ADDL_MASK) >>\r\nCQE_STATUS_ADDL_SHIFT);\r\nif (mbx_cmd_mem) {\r\nmbx_hdr = (struct be_cmd_req_hdr *)mbx_cmd_mem->va;\r\n} else {\r\nwrb_num = (mcc_tag_status & CQE_STATUS_WRB_MASK) >>\r\nCQE_STATUS_WRB_SHIFT;\r\ntemp_wrb = (struct be_mcc_wrb *)queue_get_wrb(mccq, wrb_num);\r\nmbx_hdr = embedded_payload(temp_wrb);\r\nif (wrb)\r\n*wrb = temp_wrb;\r\n}\r\nif (status || addl_status) {\r\nbeiscsi_log(phba, KERN_WARNING,\r\nBEISCSI_LOG_INIT | BEISCSI_LOG_EH |\r\nBEISCSI_LOG_CONFIG,\r\n"BC_%d : MBX Cmd Failed for Subsys : %d Opcode : %d with Status : %d and Extd_Status : %d\n",\r\nmbx_hdr->subsystem, mbx_hdr->opcode,\r\nstatus, addl_status);\r\nrc = -EIO;\r\nif (status == MCC_STATUS_INSUFFICIENT_BUFFER) {\r\nmbx_resp_hdr = (struct be_cmd_resp_hdr *)mbx_hdr;\r\nbeiscsi_log(phba, KERN_WARNING,\r\nBEISCSI_LOG_INIT | BEISCSI_LOG_EH |\r\nBEISCSI_LOG_CONFIG,\r\n"BC_%d : Insufficient Buffer Error Resp_Len : %d Actual_Resp_Len : %d\n",\r\nmbx_resp_hdr->response_length,\r\nmbx_resp_hdr->actual_resp_len);\r\nrc = -EAGAIN;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nint beiscsi_mccq_compl_wait(struct beiscsi_hba *phba,\r\nunsigned int tag,\r\nstruct be_mcc_wrb **wrb,\r\nstruct be_dma_mem *mbx_cmd_mem)\r\n{\r\nint rc = 0;\r\nif (!tag || tag > MAX_MCC_CMD) {\r\n__beiscsi_log(phba, KERN_ERR,\r\n"BC_%d : invalid tag %u\n", tag);\r\nreturn -EINVAL;\r\n}\r\nif (beiscsi_hba_in_error(phba)) {\r\nclear_bit(MCC_TAG_STATE_RUNNING,\r\n&phba->ctrl.ptag_state[tag].tag_state);\r\nreturn -EIO;\r\n}\r\nrc = wait_event_interruptible_timeout(phba->ctrl.mcc_wait[tag],\r\nphba->ctrl.mcc_tag_status[tag],\r\nmsecs_to_jiffies(\r\nBEISCSI_HOST_MBX_TIMEOUT));\r\nif (!test_bit(BEISCSI_HBA_ONLINE, &phba->state)) {\r\nclear_bit(MCC_TAG_STATE_RUNNING,\r\n&phba->ctrl.ptag_state[tag].tag_state);\r\nreturn -EIO;\r\n}\r\nif (rc <= 0) {\r\nstruct be_dma_mem *tag_mem;\r\ntag_mem = &phba->ctrl.ptag_state[tag].tag_mem_state;\r\nif (mbx_cmd_mem) {\r\ntag_mem->size = mbx_cmd_mem->size;\r\ntag_mem->va = mbx_cmd_mem->va;\r\ntag_mem->dma = mbx_cmd_mem->dma;\r\n} else\r\ntag_mem->size = 0;\r\nwmb();\r\nset_bit(MCC_TAG_STATE_TIMEOUT,\r\n&phba->ctrl.ptag_state[tag].tag_state);\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_INIT | BEISCSI_LOG_EH |\r\nBEISCSI_LOG_CONFIG,\r\n"BC_%d : MBX Cmd Completion timed out\n");\r\nreturn -EBUSY;\r\n}\r\nrc = __beiscsi_mcc_compl_status(phba, tag, wrb, mbx_cmd_mem);\r\nfree_mcc_wrb(&phba->ctrl, tag);\r\nreturn rc;\r\n}\r\nstatic int beiscsi_process_mbox_compl(struct be_ctrl_info *ctrl,\r\nstruct be_mcc_compl *compl)\r\n{\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\r\nstruct be_cmd_req_hdr *hdr = embedded_payload(wrb);\r\nu16 compl_status, extd_status;\r\nif (!compl->flags) {\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BC_%d : BMBX busy, no completion\n");\r\nreturn -EBUSY;\r\n}\r\ncompl->flags = le32_to_cpu(compl->flags);\r\nWARN_ON((compl->flags & CQE_FLAGS_VALID_MASK) == 0);\r\nbe_dws_le_to_cpu(compl, 4);\r\ncompl_status = (compl->status >> CQE_STATUS_COMPL_SHIFT) &\r\nCQE_STATUS_COMPL_MASK;\r\nextd_status = (compl->status >> CQE_STATUS_EXTD_SHIFT) &\r\nCQE_STATUS_EXTD_MASK;\r\ncompl->flags = 0;\r\nif (compl_status == MCC_STATUS_SUCCESS)\r\nreturn 0;\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BC_%d : error in cmd completion: Subsystem : %d Opcode : %d status(compl/extd)=%d/%d\n",\r\nhdr->subsystem, hdr->opcode, compl_status, extd_status);\r\nreturn compl_status;\r\n}\r\nstatic void beiscsi_process_async_link(struct beiscsi_hba *phba,\r\nstruct be_mcc_compl *compl)\r\n{\r\nstruct be_async_event_link_state *evt;\r\nevt = (struct be_async_event_link_state *)compl;\r\nphba->port_speed = evt->port_speed;\r\nif (evt->port_link_status & BE_ASYNC_LINK_UP_MASK) {\r\nset_bit(BEISCSI_HBA_LINK_UP, &phba->state);\r\nif (test_bit(BEISCSI_HBA_BOOT_FOUND, &phba->state))\r\nbeiscsi_start_boot_work(phba, BE_BOOT_INVALID_SHANDLE);\r\n__beiscsi_log(phba, KERN_ERR,\r\n"BC_%d : Link Up on Port %d tag 0x%x\n",\r\nevt->physical_port, evt->event_tag);\r\n} else {\r\nclear_bit(BEISCSI_HBA_LINK_UP, &phba->state);\r\n__beiscsi_log(phba, KERN_ERR,\r\n"BC_%d : Link Down on Port %d tag 0x%x\n",\r\nevt->physical_port, evt->event_tag);\r\niscsi_host_for_each_session(phba->shost,\r\nbeiscsi_session_fail);\r\n}\r\n}\r\nstatic void beiscsi_process_async_sli(struct beiscsi_hba *phba,\r\nstruct be_mcc_compl *compl)\r\n{\r\nstruct be_async_event_sli *async_sli;\r\nu8 evt_type, state, old_state, le;\r\nchar *sev = KERN_WARNING;\r\nchar *msg = NULL;\r\nevt_type = compl->flags >> ASYNC_TRAILER_EVENT_TYPE_SHIFT;\r\nevt_type &= ASYNC_TRAILER_EVENT_TYPE_MASK;\r\nif (evt_type != ASYNC_SLI_EVENT_TYPE_MISCONFIGURED)\r\nreturn;\r\nasync_sli = (struct be_async_event_sli *)compl;\r\nstate = async_sli->event_data1 >>\r\n(phba->fw_config.phys_port * 8) & 0xff;\r\nle = async_sli->event_data2 >>\r\n(phba->fw_config.phys_port * 8) & 0xff;\r\nold_state = phba->optic_state;\r\nphba->optic_state = state;\r\nif (state >= ARRAY_SIZE(beiscsi_port_misconf_event_msg)) {\r\n__beiscsi_log(phba, KERN_ERR,\r\n"BC_%d : Port %c: Unrecognized optic state 0x%x\n",\r\nphba->port_name, async_sli->event_data1);\r\nreturn;\r\n}\r\nif (ASYNC_SLI_LINK_EFFECT_VALID(le)) {\r\nif (state > 3)\r\nmsg = (ASYNC_SLI_LINK_EFFECT_STATE(le)) ?\r\n" Link is non-operational." :\r\n" Link is operational.";\r\nif (ASYNC_SLI_LINK_EFFECT_SEV(le) == 1)\r\nsev = KERN_INFO;\r\nif (ASYNC_SLI_LINK_EFFECT_SEV(le) == 2)\r\nsev = KERN_ERR;\r\n}\r\nif (old_state != phba->optic_state)\r\n__beiscsi_log(phba, sev, "BC_%d : Port %c: %s%s\n",\r\nphba->port_name,\r\nbeiscsi_port_misconf_event_msg[state],\r\n!msg ? "" : msg);\r\n}\r\nvoid beiscsi_process_async_event(struct beiscsi_hba *phba,\r\nstruct be_mcc_compl *compl)\r\n{\r\nchar *sev = KERN_INFO;\r\nu8 evt_code;\r\nevt_code = compl->flags >> ASYNC_TRAILER_EVENT_CODE_SHIFT;\r\nevt_code &= ASYNC_TRAILER_EVENT_CODE_MASK;\r\nswitch (evt_code) {\r\ncase ASYNC_EVENT_CODE_LINK_STATE:\r\nbeiscsi_process_async_link(phba, compl);\r\nbreak;\r\ncase ASYNC_EVENT_CODE_ISCSI:\r\nif (test_bit(BEISCSI_HBA_BOOT_FOUND, &phba->state))\r\nbeiscsi_start_boot_work(phba, BE_BOOT_INVALID_SHANDLE);\r\nsev = KERN_ERR;\r\nbreak;\r\ncase ASYNC_EVENT_CODE_SLI:\r\nbeiscsi_process_async_sli(phba, compl);\r\nbreak;\r\ndefault:\r\nsev = KERN_ERR;\r\n}\r\nbeiscsi_log(phba, sev, BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BC_%d : ASYNC Event %x: status 0x%08x flags 0x%08x\n",\r\nevt_code, compl->status, compl->flags);\r\n}\r\nint beiscsi_process_mcc_compl(struct be_ctrl_info *ctrl,\r\nstruct be_mcc_compl *compl)\r\n{\r\nstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\r\nu16 compl_status, extd_status;\r\nstruct be_dma_mem *tag_mem;\r\nunsigned int tag, wrb_idx;\r\nbe_dws_le_to_cpu(compl, 4);\r\ntag = (compl->tag0 & MCC_Q_CMD_TAG_MASK);\r\nwrb_idx = (compl->tag0 & CQE_STATUS_WRB_MASK) >> CQE_STATUS_WRB_SHIFT;\r\nif (!test_bit(MCC_TAG_STATE_RUNNING,\r\n&ctrl->ptag_state[tag].tag_state)) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_MBOX |\r\nBEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,\r\n"BC_%d : MBX cmd completed but not posted\n");\r\nreturn 0;\r\n}\r\nclear_bit(MCC_TAG_STATE_RUNNING, &ctrl->ptag_state[tag].tag_state);\r\nif (test_bit(MCC_TAG_STATE_TIMEOUT, &ctrl->ptag_state[tag].tag_state)) {\r\nbeiscsi_log(phba, KERN_WARNING,\r\nBEISCSI_LOG_MBOX | BEISCSI_LOG_INIT |\r\nBEISCSI_LOG_CONFIG,\r\n"BC_%d : MBX Completion for timeout Command from FW\n");\r\ntag_mem = &ctrl->ptag_state[tag].tag_mem_state;\r\nif (tag_mem->size) {\r\npci_free_consistent(ctrl->pdev, tag_mem->size,\r\ntag_mem->va, tag_mem->dma);\r\ntag_mem->size = 0;\r\n}\r\nfree_mcc_wrb(ctrl, tag);\r\nreturn 0;\r\n}\r\ncompl_status = (compl->status >> CQE_STATUS_COMPL_SHIFT) &\r\nCQE_STATUS_COMPL_MASK;\r\nextd_status = (compl->status >> CQE_STATUS_EXTD_SHIFT) &\r\nCQE_STATUS_EXTD_MASK;\r\nctrl->mcc_tag_status[tag] = CQE_VALID_MASK;\r\nctrl->mcc_tag_status[tag] |= (wrb_idx << CQE_STATUS_WRB_SHIFT);\r\nctrl->mcc_tag_status[tag] |= (extd_status << CQE_STATUS_ADDL_SHIFT) &\r\nCQE_STATUS_ADDL_MASK;\r\nctrl->mcc_tag_status[tag] |= (compl_status & CQE_STATUS_MASK);\r\nif (test_bit(MCC_TAG_STATE_ASYNC, &ctrl->ptag_state[tag].tag_state)) {\r\nif (ctrl->ptag_state[tag].cbfn)\r\nctrl->ptag_state[tag].cbfn(phba, tag);\r\nelse\r\n__beiscsi_log(phba, KERN_ERR,\r\n"BC_%d : MBX ASYNC command with no callback\n");\r\nfree_mcc_wrb(ctrl, tag);\r\nreturn 0;\r\n}\r\nif (test_bit(MCC_TAG_STATE_IGNORE, &ctrl->ptag_state[tag].tag_state)) {\r\n__beiscsi_mcc_compl_status(phba, tag, NULL, NULL);\r\nfree_mcc_wrb(ctrl, tag);\r\nreturn 0;\r\n}\r\nwake_up_interruptible(&ctrl->mcc_wait[tag]);\r\nreturn 0;\r\n}\r\nvoid be_mcc_notify(struct beiscsi_hba *phba, unsigned int tag)\r\n{\r\nstruct be_queue_info *mccq = &phba->ctrl.mcc_obj.q;\r\nu32 val = 0;\r\nset_bit(MCC_TAG_STATE_RUNNING, &phba->ctrl.ptag_state[tag].tag_state);\r\nval |= mccq->id & DB_MCCQ_RING_ID_MASK;\r\nval |= 1 << DB_MCCQ_NUM_POSTED_SHIFT;\r\nwmb();\r\niowrite32(val, phba->db_va + DB_MCCQ_OFFSET);\r\n}\r\nstatic int be_mbox_db_ready_poll(struct be_ctrl_info *ctrl)\r\n{\r\n#define BEISCSI_MBX_RDY_BIT_TIMEOUT 30000\r\nvoid __iomem *db = ctrl->db + MPU_MAILBOX_DB_OFFSET;\r\nstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\r\nunsigned long timeout;\r\nu32 ready;\r\ntimeout = jiffies + msecs_to_jiffies(BEISCSI_MBX_RDY_BIT_TIMEOUT);\r\ndo {\r\nif (beiscsi_hba_in_error(phba))\r\nreturn -EIO;\r\nready = ioread32(db);\r\nif (ready == 0xffffffff)\r\nreturn -EIO;\r\nready &= MPU_MAILBOX_DB_RDY_MASK;\r\nif (ready)\r\nreturn 0;\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(1));\r\n} while (!ready);\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BC_%d : FW Timed Out\n");\r\nset_bit(BEISCSI_HBA_FW_TIMEOUT, &phba->state);\r\nreturn -EBUSY;\r\n}\r\nstatic int be_mbox_notify(struct be_ctrl_info *ctrl)\r\n{\r\nint status;\r\nu32 val = 0;\r\nvoid __iomem *db = ctrl->db + MPU_MAILBOX_DB_OFFSET;\r\nstruct be_dma_mem *mbox_mem = &ctrl->mbox_mem;\r\nstruct be_mcc_mailbox *mbox = mbox_mem->va;\r\nstatus = be_mbox_db_ready_poll(ctrl);\r\nif (status)\r\nreturn status;\r\nval &= ~MPU_MAILBOX_DB_RDY_MASK;\r\nval |= MPU_MAILBOX_DB_HI_MASK;\r\nval |= (upper_32_bits(mbox_mem->dma) >> 2) << 2;\r\niowrite32(val, db);\r\nstatus = be_mbox_db_ready_poll(ctrl);\r\nif (status)\r\nreturn status;\r\nval = 0;\r\nval &= ~MPU_MAILBOX_DB_RDY_MASK;\r\nval &= ~MPU_MAILBOX_DB_HI_MASK;\r\nval |= (u32) (mbox_mem->dma >> 4) << 2;\r\niowrite32(val, db);\r\nstatus = be_mbox_db_ready_poll(ctrl);\r\nif (status)\r\nreturn status;\r\nudelay(1);\r\nstatus = beiscsi_process_mbox_compl(ctrl, &mbox->compl);\r\nreturn status;\r\n}\r\nvoid be_wrb_hdr_prepare(struct be_mcc_wrb *wrb, int payload_len,\r\nbool embedded, u8 sge_cnt)\r\n{\r\nif (embedded)\r\nwrb->emb_sgecnt_special |= MCC_WRB_EMBEDDED_MASK;\r\nelse\r\nwrb->emb_sgecnt_special |= (sge_cnt & MCC_WRB_SGE_CNT_MASK) <<\r\nMCC_WRB_SGE_CNT_SHIFT;\r\nwrb->payload_length = payload_len;\r\nbe_dws_cpu_to_le(wrb, 8);\r\n}\r\nvoid be_cmd_hdr_prepare(struct be_cmd_req_hdr *req_hdr,\r\nu8 subsystem, u8 opcode, int cmd_len)\r\n{\r\nreq_hdr->opcode = opcode;\r\nreq_hdr->subsystem = subsystem;\r\nreq_hdr->request_length = cpu_to_le32(cmd_len - sizeof(*req_hdr));\r\nreq_hdr->timeout = BEISCSI_FW_MBX_TIMEOUT;\r\n}\r\nstatic void be_cmd_page_addrs_prepare(struct phys_addr *pages, u32 max_pages,\r\nstruct be_dma_mem *mem)\r\n{\r\nint i, buf_pages;\r\nu64 dma = (u64) mem->dma;\r\nbuf_pages = min(PAGES_4K_SPANNED(mem->va, mem->size), max_pages);\r\nfor (i = 0; i < buf_pages; i++) {\r\npages[i].lo = cpu_to_le32(dma & 0xFFFFFFFF);\r\npages[i].hi = cpu_to_le32(upper_32_bits(dma));\r\ndma += PAGE_SIZE_4K;\r\n}\r\n}\r\nstatic u32 eq_delay_to_mult(u32 usec_delay)\r\n{\r\n#define MAX_INTR_RATE 651042\r\nconst u32 round = 10;\r\nu32 multiplier;\r\nif (usec_delay == 0)\r\nmultiplier = 0;\r\nelse {\r\nu32 interrupt_rate = 1000000 / usec_delay;\r\nif (interrupt_rate == 0)\r\nmultiplier = 1023;\r\nelse {\r\nmultiplier = (MAX_INTR_RATE - interrupt_rate) * round;\r\nmultiplier /= interrupt_rate;\r\nmultiplier = (multiplier + round / 2) / round;\r\nmultiplier = min(multiplier, (u32) 1023);\r\n}\r\n}\r\nreturn multiplier;\r\n}\r\nstruct be_mcc_wrb *wrb_from_mbox(struct be_dma_mem *mbox_mem)\r\n{\r\nreturn &((struct be_mcc_mailbox *)(mbox_mem->va))->wrb;\r\n}\r\nint beiscsi_cmd_eq_create(struct be_ctrl_info *ctrl,\r\nstruct be_queue_info *eq, int eq_delay)\r\n{\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_cmd_req_eq_create *req = embedded_payload(wrb);\r\nstruct be_cmd_resp_eq_create *resp = embedded_payload(wrb);\r\nstruct be_dma_mem *q_mem = &eq->dma_mem;\r\nint status;\r\nmutex_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_EQ_CREATE, sizeof(*req));\r\nreq->num_pages = cpu_to_le16(PAGES_4K_SPANNED(q_mem->va, q_mem->size));\r\nAMAP_SET_BITS(struct amap_eq_context, func, req->context,\r\nPCI_FUNC(ctrl->pdev->devfn));\r\nAMAP_SET_BITS(struct amap_eq_context, valid, req->context, 1);\r\nAMAP_SET_BITS(struct amap_eq_context, size, req->context, 0);\r\nAMAP_SET_BITS(struct amap_eq_context, count, req->context,\r\n__ilog2_u32(eq->len / 256));\r\nAMAP_SET_BITS(struct amap_eq_context, delaymult, req->context,\r\neq_delay_to_mult(eq_delay));\r\nbe_dws_cpu_to_le(req->context, sizeof(req->context));\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nstatus = be_mbox_notify(ctrl);\r\nif (!status) {\r\neq->id = le16_to_cpu(resp->eq_id);\r\neq->created = true;\r\n}\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nint beiscsi_cmd_cq_create(struct be_ctrl_info *ctrl,\r\nstruct be_queue_info *cq, struct be_queue_info *eq,\r\nbool sol_evts, bool no_delay, int coalesce_wm)\r\n{\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_cmd_req_cq_create *req = embedded_payload(wrb);\r\nstruct be_cmd_resp_cq_create *resp = embedded_payload(wrb);\r\nstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\r\nstruct be_dma_mem *q_mem = &cq->dma_mem;\r\nvoid *ctxt = &req->context;\r\nint status;\r\nmutex_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_CQ_CREATE, sizeof(*req));\r\nreq->num_pages = cpu_to_le16(PAGES_4K_SPANNED(q_mem->va, q_mem->size));\r\nif (is_chip_be2_be3r(phba)) {\r\nAMAP_SET_BITS(struct amap_cq_context, coalescwm,\r\nctxt, coalesce_wm);\r\nAMAP_SET_BITS(struct amap_cq_context, nodelay, ctxt, no_delay);\r\nAMAP_SET_BITS(struct amap_cq_context, count, ctxt,\r\n__ilog2_u32(cq->len / 256));\r\nAMAP_SET_BITS(struct amap_cq_context, valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_cq_context, solevent, ctxt, sol_evts);\r\nAMAP_SET_BITS(struct amap_cq_context, eventable, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_cq_context, eqid, ctxt, eq->id);\r\nAMAP_SET_BITS(struct amap_cq_context, armed, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_cq_context, func, ctxt,\r\nPCI_FUNC(ctrl->pdev->devfn));\r\n} else {\r\nreq->hdr.version = MBX_CMD_VER2;\r\nreq->page_size = 1;\r\nAMAP_SET_BITS(struct amap_cq_context_v2, coalescwm,\r\nctxt, coalesce_wm);\r\nAMAP_SET_BITS(struct amap_cq_context_v2, nodelay,\r\nctxt, no_delay);\r\nAMAP_SET_BITS(struct amap_cq_context_v2, count, ctxt,\r\n__ilog2_u32(cq->len / 256));\r\nAMAP_SET_BITS(struct amap_cq_context_v2, valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_cq_context_v2, eventable, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_cq_context_v2, eqid, ctxt, eq->id);\r\nAMAP_SET_BITS(struct amap_cq_context_v2, armed, ctxt, 1);\r\n}\r\nbe_dws_cpu_to_le(ctxt, sizeof(req->context));\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nstatus = be_mbox_notify(ctrl);\r\nif (!status) {\r\ncq->id = le16_to_cpu(resp->cq_id);\r\ncq->created = true;\r\n} else\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\r\n"BC_%d : In be_cmd_cq_create, status=ox%08x\n",\r\nstatus);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nstatic u32 be_encoded_q_len(int q_len)\r\n{\r\nu32 len_encoded = fls(q_len);\r\nif (len_encoded == 16)\r\nlen_encoded = 0;\r\nreturn len_encoded;\r\n}\r\nint beiscsi_cmd_mccq_create(struct beiscsi_hba *phba,\r\nstruct be_queue_info *mccq,\r\nstruct be_queue_info *cq)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_mcc_create_ext *req;\r\nstruct be_dma_mem *q_mem = &mccq->dma_mem;\r\nstruct be_ctrl_info *ctrl;\r\nvoid *ctxt;\r\nint status;\r\nmutex_lock(&phba->ctrl.mbox_lock);\r\nctrl = &phba->ctrl;\r\nwrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nreq = embedded_payload(wrb);\r\nctxt = &req->context;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_MCC_CREATE_EXT, sizeof(*req));\r\nreq->num_pages = PAGES_4K_SPANNED(q_mem->va, q_mem->size);\r\nreq->async_evt_bitmap = 1 << ASYNC_EVENT_CODE_LINK_STATE;\r\nreq->async_evt_bitmap |= 1 << ASYNC_EVENT_CODE_ISCSI;\r\nreq->async_evt_bitmap |= 1 << ASYNC_EVENT_CODE_SLI;\r\nAMAP_SET_BITS(struct amap_mcc_context, fid, ctxt,\r\nPCI_FUNC(phba->pcidev->devfn));\r\nAMAP_SET_BITS(struct amap_mcc_context, valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_mcc_context, ring_size, ctxt,\r\nbe_encoded_q_len(mccq->len));\r\nAMAP_SET_BITS(struct amap_mcc_context, cq_id, ctxt, cq->id);\r\nbe_dws_cpu_to_le(ctxt, sizeof(req->context));\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nstatus = be_mbox_notify(ctrl);\r\nif (!status) {\r\nstruct be_cmd_resp_mcc_create *resp = embedded_payload(wrb);\r\nmccq->id = le16_to_cpu(resp->id);\r\nmccq->created = true;\r\n}\r\nmutex_unlock(&phba->ctrl.mbox_lock);\r\nreturn status;\r\n}\r\nint beiscsi_cmd_q_destroy(struct be_ctrl_info *ctrl, struct be_queue_info *q,\r\nint queue_type)\r\n{\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_cmd_req_q_destroy *req = embedded_payload(wrb);\r\nstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\r\nu8 subsys = 0, opcode = 0;\r\nint status;\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\r\n"BC_%d : In beiscsi_cmd_q_destroy "\r\n"queue_type : %d\n", queue_type);\r\nmutex_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nswitch (queue_type) {\r\ncase QTYPE_EQ:\r\nsubsys = CMD_SUBSYSTEM_COMMON;\r\nopcode = OPCODE_COMMON_EQ_DESTROY;\r\nbreak;\r\ncase QTYPE_CQ:\r\nsubsys = CMD_SUBSYSTEM_COMMON;\r\nopcode = OPCODE_COMMON_CQ_DESTROY;\r\nbreak;\r\ncase QTYPE_MCCQ:\r\nsubsys = CMD_SUBSYSTEM_COMMON;\r\nopcode = OPCODE_COMMON_MCC_DESTROY;\r\nbreak;\r\ncase QTYPE_WRBQ:\r\nsubsys = CMD_SUBSYSTEM_ISCSI;\r\nopcode = OPCODE_COMMON_ISCSI_WRBQ_DESTROY;\r\nbreak;\r\ncase QTYPE_DPDUQ:\r\nsubsys = CMD_SUBSYSTEM_ISCSI;\r\nopcode = OPCODE_COMMON_ISCSI_DEFQ_DESTROY;\r\nbreak;\r\ncase QTYPE_SGL:\r\nsubsys = CMD_SUBSYSTEM_ISCSI;\r\nopcode = OPCODE_COMMON_ISCSI_CFG_REMOVE_SGL_PAGES;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&ctrl->mbox_lock);\r\nBUG();\r\nreturn -ENXIO;\r\n}\r\nbe_cmd_hdr_prepare(&req->hdr, subsys, opcode, sizeof(*req));\r\nif (queue_type != QTYPE_SGL)\r\nreq->id = cpu_to_le16(q->id);\r\nstatus = be_mbox_notify(ctrl);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_create_default_pdu_queue(struct be_ctrl_info *ctrl,\r\nstruct be_queue_info *cq,\r\nstruct be_queue_info *dq, int length,\r\nint entry_size, uint8_t is_header,\r\nuint8_t ulp_num)\r\n{\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_defq_create_req *req = embedded_payload(wrb);\r\nstruct be_dma_mem *q_mem = &dq->dma_mem;\r\nstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\r\nvoid *ctxt = &req->context;\r\nint status;\r\nmutex_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_DEFQ_CREATE, sizeof(*req));\r\nreq->num_pages = PAGES_4K_SPANNED(q_mem->va, q_mem->size);\r\nif (phba->fw_config.dual_ulp_aware) {\r\nreq->ulp_num = ulp_num;\r\nreq->dua_feature |= (1 << BEISCSI_DUAL_ULP_AWARE_BIT);\r\nreq->dua_feature |= (1 << BEISCSI_BIND_Q_TO_ULP_BIT);\r\n}\r\nif (is_chip_be2_be3r(phba)) {\r\nAMAP_SET_BITS(struct amap_be_default_pdu_context,\r\nrx_pdid, ctxt, 0);\r\nAMAP_SET_BITS(struct amap_be_default_pdu_context,\r\nrx_pdid_valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_be_default_pdu_context,\r\npci_func_id, ctxt, PCI_FUNC(ctrl->pdev->devfn));\r\nAMAP_SET_BITS(struct amap_be_default_pdu_context,\r\nring_size, ctxt,\r\nbe_encoded_q_len(length /\r\nsizeof(struct phys_addr)));\r\nAMAP_SET_BITS(struct amap_be_default_pdu_context,\r\ndefault_buffer_size, ctxt, entry_size);\r\nAMAP_SET_BITS(struct amap_be_default_pdu_context,\r\ncq_id_recv, ctxt, cq->id);\r\n} else {\r\nAMAP_SET_BITS(struct amap_default_pdu_context_ext,\r\nrx_pdid, ctxt, 0);\r\nAMAP_SET_BITS(struct amap_default_pdu_context_ext,\r\nrx_pdid_valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_default_pdu_context_ext,\r\nring_size, ctxt,\r\nbe_encoded_q_len(length /\r\nsizeof(struct phys_addr)));\r\nAMAP_SET_BITS(struct amap_default_pdu_context_ext,\r\ndefault_buffer_size, ctxt, entry_size);\r\nAMAP_SET_BITS(struct amap_default_pdu_context_ext,\r\ncq_id_recv, ctxt, cq->id);\r\n}\r\nbe_dws_cpu_to_le(ctxt, sizeof(req->context));\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nstatus = be_mbox_notify(ctrl);\r\nif (!status) {\r\nstruct be_ring *defq_ring;\r\nstruct be_defq_create_resp *resp = embedded_payload(wrb);\r\ndq->id = le16_to_cpu(resp->id);\r\ndq->created = true;\r\nif (is_header)\r\ndefq_ring = &phba->phwi_ctrlr->default_pdu_hdr[ulp_num];\r\nelse\r\ndefq_ring = &phba->phwi_ctrlr->\r\ndefault_pdu_data[ulp_num];\r\ndefq_ring->id = dq->id;\r\nif (!phba->fw_config.dual_ulp_aware) {\r\ndefq_ring->ulp_num = BEISCSI_ULP0;\r\ndefq_ring->doorbell_offset = DB_RXULP0_OFFSET;\r\n} else {\r\ndefq_ring->ulp_num = resp->ulp_num;\r\ndefq_ring->doorbell_offset = resp->doorbell_offset;\r\n}\r\n}\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_wrbq_create(struct be_ctrl_info *ctrl,\r\nstruct be_dma_mem *q_mem,\r\nstruct be_queue_info *wrbq,\r\nstruct hwi_wrb_context *pwrb_context,\r\nuint8_t ulp_num)\r\n{\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_wrbq_create_req *req = embedded_payload(wrb);\r\nstruct be_wrbq_create_resp *resp = embedded_payload(wrb);\r\nstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\r\nint status;\r\nmutex_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_WRBQ_CREATE, sizeof(*req));\r\nreq->num_pages = PAGES_4K_SPANNED(q_mem->va, q_mem->size);\r\nif (phba->fw_config.dual_ulp_aware) {\r\nreq->ulp_num = ulp_num;\r\nreq->dua_feature |= (1 << BEISCSI_DUAL_ULP_AWARE_BIT);\r\nreq->dua_feature |= (1 << BEISCSI_BIND_Q_TO_ULP_BIT);\r\n}\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nstatus = be_mbox_notify(ctrl);\r\nif (!status) {\r\nwrbq->id = le16_to_cpu(resp->cid);\r\nwrbq->created = true;\r\npwrb_context->cid = wrbq->id;\r\nif (!phba->fw_config.dual_ulp_aware) {\r\npwrb_context->doorbell_offset = DB_TXULP0_OFFSET;\r\npwrb_context->ulp_num = BEISCSI_ULP0;\r\n} else {\r\npwrb_context->ulp_num = resp->ulp_num;\r\npwrb_context->doorbell_offset = resp->doorbell_offset;\r\n}\r\n}\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_iscsi_post_template_hdr(struct be_ctrl_info *ctrl,\r\nstruct be_dma_mem *q_mem)\r\n{\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_post_template_pages_req *req = embedded_payload(wrb);\r\nint status;\r\nmutex_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_ADD_TEMPLATE_HEADER_BUFFERS,\r\nsizeof(*req));\r\nreq->num_pages = PAGES_4K_SPANNED(q_mem->va, q_mem->size);\r\nreq->type = BEISCSI_TEMPLATE_HDR_TYPE_ISCSI;\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nstatus = be_mbox_notify(ctrl);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_iscsi_remove_template_hdr(struct be_ctrl_info *ctrl)\r\n{\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_remove_template_pages_req *req = embedded_payload(wrb);\r\nint status;\r\nmutex_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_REMOVE_TEMPLATE_HEADER_BUFFERS,\r\nsizeof(*req));\r\nreq->type = BEISCSI_TEMPLATE_HDR_TYPE_ISCSI;\r\nstatus = be_mbox_notify(ctrl);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_iscsi_post_sgl_pages(struct be_ctrl_info *ctrl,\r\nstruct be_dma_mem *q_mem,\r\nu32 page_offset, u32 num_pages)\r\n{\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_post_sgl_pages_req *req = embedded_payload(wrb);\r\nstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\r\nint status;\r\nunsigned int curr_pages;\r\nu32 internal_page_offset = 0;\r\nu32 temp_num_pages = num_pages;\r\nif (num_pages == 0xff)\r\nnum_pages = 1;\r\nmutex_lock(&ctrl->mbox_lock);\r\ndo {\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_CFG_POST_SGL_PAGES,\r\nsizeof(*req));\r\ncurr_pages = BE_NUMBER_OF_FIELD(struct be_post_sgl_pages_req,\r\npages);\r\nreq->num_pages = min(num_pages, curr_pages);\r\nreq->page_offset = page_offset;\r\nbe_cmd_page_addrs_prepare(req->pages, req->num_pages, q_mem);\r\nq_mem->dma = q_mem->dma + (req->num_pages * PAGE_SIZE);\r\ninternal_page_offset += req->num_pages;\r\npage_offset += req->num_pages;\r\nnum_pages -= req->num_pages;\r\nif (temp_num_pages == 0xff)\r\nreq->num_pages = temp_num_pages;\r\nstatus = be_mbox_notify(ctrl);\r\nif (status) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\r\n"BC_%d : FW CMD to map iscsi frags failed.\n");\r\ngoto error;\r\n}\r\n} while (num_pages > 0);\r\nerror:\r\nmutex_unlock(&ctrl->mbox_lock);\r\nif (status != 0)\r\nbeiscsi_cmd_q_destroy(ctrl, NULL, QTYPE_SGL);\r\nreturn status;\r\n}\r\nint be_cmd_set_vlan(struct beiscsi_hba *phba,\r\nuint16_t vlan_tag)\r\n{\r\nunsigned int tag;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_set_vlan_req *req;\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nif (mutex_lock_interruptible(&ctrl->mbox_lock))\r\nreturn 0;\r\nwrb = alloc_mcc_wrb(phba, &tag);\r\nif (!wrb) {\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn 0;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*wrb), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_NTWK_SET_VLAN,\r\nsizeof(*req));\r\nreq->interface_hndl = phba->interface_handle;\r\nreq->vlan_priority = vlan_tag;\r\nbe_mcc_notify(phba, tag);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nint beiscsi_check_supported_fw(struct be_ctrl_info *ctrl,\r\nstruct beiscsi_hba *phba)\r\n{\r\nstruct be_dma_mem nonemb_cmd;\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_mgmt_controller_attributes *req;\r\nstruct be_sge *sge = nonembedded_sgl(wrb);\r\nint status = 0;\r\nnonemb_cmd.va = pci_alloc_consistent(ctrl->pdev,\r\nsizeof(struct be_mgmt_controller_attributes),\r\n&nonemb_cmd.dma);\r\nif (nonemb_cmd.va == NULL) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\r\n"BG_%d : pci_alloc_consistent failed in %s\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nnonemb_cmd.size = sizeof(struct be_mgmt_controller_attributes);\r\nreq = nonemb_cmd.va;\r\nmemset(req, 0, sizeof(*req));\r\nmutex_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_CNTL_ATTRIBUTES, sizeof(*req));\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd.dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd.dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd.size);\r\nstatus = be_mbox_notify(ctrl);\r\nif (!status) {\r\nstruct be_mgmt_controller_attributes_resp *resp = nonemb_cmd.va;\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\r\n"BG_%d : Firmware Version of CMD : %s\n"\r\n"Firmware Version is : %s\n"\r\n"Developer Build, not performing version check...\n",\r\nresp->params.hba_attribs\r\n.flashrom_version_string,\r\nresp->params.hba_attribs.\r\nfirmware_version_string);\r\nphba->fw_config.iscsi_features =\r\nresp->params.hba_attribs.iscsi_features;\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\r\n"BM_%d : phba->fw_config.iscsi_features = %d\n",\r\nphba->fw_config.iscsi_features);\r\nmemcpy(phba->fw_ver_str, resp->params.hba_attribs.\r\nfirmware_version_string, BEISCSI_VER_STRLEN);\r\n} else\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\r\n"BG_%d : Failed in beiscsi_check_supported_fw\n");\r\nmutex_unlock(&ctrl->mbox_lock);\r\nif (nonemb_cmd.va)\r\npci_free_consistent(ctrl->pdev, nonemb_cmd.size,\r\nnonemb_cmd.va, nonemb_cmd.dma);\r\nreturn status;\r\n}\r\nint beiscsi_get_fw_config(struct be_ctrl_info *ctrl,\r\nstruct beiscsi_hba *phba)\r\n{\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_fw_cfg *pfw_cfg = embedded_payload(wrb);\r\nuint32_t cid_count, icd_count;\r\nint status = -EINVAL;\r\nuint8_t ulp_num = 0;\r\nmutex_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*pfw_cfg), true, 0);\r\nbe_cmd_hdr_prepare(&pfw_cfg->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_QUERY_FIRMWARE_CONFIG,\r\nEMBED_MBX_MAX_PAYLOAD_SIZE);\r\nif (be_mbox_notify(ctrl)) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\r\n"BG_%d : Failed in beiscsi_get_fw_config\n");\r\ngoto fail_init;\r\n}\r\nphba->fw_config.phys_port = pfw_cfg->phys_port;\r\nif (phba->fw_config.phys_port >= BEISCSI_PHYS_PORT_MAX) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\r\n"BG_%d : invalid physical port id %d\n",\r\nphba->fw_config.phys_port);\r\ngoto fail_init;\r\n}\r\nif (!is_chip_be2_be3r(phba)) {\r\nphba->fw_config.eqid_count = pfw_cfg->eqid_count;\r\nphba->fw_config.cqid_count = pfw_cfg->cqid_count;\r\nif (phba->fw_config.eqid_count == 0 ||\r\nphba->fw_config.eqid_count > 2048) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\r\n"BG_%d : invalid EQ count %d\n",\r\nphba->fw_config.eqid_count);\r\ngoto fail_init;\r\n}\r\nif (phba->fw_config.cqid_count == 0 ||\r\nphba->fw_config.cqid_count > 4096) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\r\n"BG_%d : invalid CQ count %d\n",\r\nphba->fw_config.cqid_count);\r\ngoto fail_init;\r\n}\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\r\n"BG_%d : EQ_Count : %d CQ_Count : %d\n",\r\nphba->fw_config.eqid_count,\r\nphba->fw_config.cqid_count);\r\n}\r\nfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\r\nif (pfw_cfg->ulp[ulp_num].ulp_mode &\r\nBEISCSI_ULP_ISCSI_INI_MODE) {\r\nset_bit(ulp_num, &phba->fw_config.ulp_supported);\r\nphba->fw_config.iscsi_cid_start[ulp_num] =\r\npfw_cfg->ulp[ulp_num].sq_base;\r\nphba->fw_config.iscsi_cid_count[ulp_num] =\r\npfw_cfg->ulp[ulp_num].sq_count;\r\nphba->fw_config.iscsi_icd_start[ulp_num] =\r\npfw_cfg->ulp[ulp_num].icd_base;\r\nphba->fw_config.iscsi_icd_count[ulp_num] =\r\npfw_cfg->ulp[ulp_num].icd_count;\r\nphba->fw_config.iscsi_chain_start[ulp_num] =\r\npfw_cfg->chain_icd[ulp_num].chain_base;\r\nphba->fw_config.iscsi_chain_count[ulp_num] =\r\npfw_cfg->chain_icd[ulp_num].chain_count;\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\r\n"BG_%d : Function loaded on ULP : %d\n"\r\n"\tiscsi_cid_count : %d\n"\r\n"\tiscsi_cid_start : %d\n"\r\n"\t iscsi_icd_count : %d\n"\r\n"\t iscsi_icd_start : %d\n",\r\nulp_num,\r\nphba->fw_config.\r\niscsi_cid_count[ulp_num],\r\nphba->fw_config.\r\niscsi_cid_start[ulp_num],\r\nphba->fw_config.\r\niscsi_icd_count[ulp_num],\r\nphba->fw_config.\r\niscsi_icd_start[ulp_num]);\r\n}\r\n}\r\nif (phba->fw_config.ulp_supported == 0) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\r\n"BG_%d : iSCSI initiator mode not set: ULP0 %x ULP1 %x\n",\r\npfw_cfg->ulp[BEISCSI_ULP0].ulp_mode,\r\npfw_cfg->ulp[BEISCSI_ULP1].ulp_mode);\r\ngoto fail_init;\r\n}\r\nfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++)\r\nif (test_bit(ulp_num, &phba->fw_config.ulp_supported))\r\nbreak;\r\nicd_count = phba->fw_config.iscsi_icd_count[ulp_num];\r\nif (icd_count == 0 || icd_count > 65536) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\r\n"BG_%d: invalid ICD count %d\n", icd_count);\r\ngoto fail_init;\r\n}\r\ncid_count = BEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP0) +\r\nBEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP1);\r\nif (cid_count == 0 || cid_count > 4096) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\r\n"BG_%d: invalid CID count %d\n", cid_count);\r\ngoto fail_init;\r\n}\r\nphba->fw_config.dual_ulp_aware = (pfw_cfg->function_mode &\r\nBEISCSI_FUNC_DUA_MODE);\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\r\n"BG_%d : DUA Mode : 0x%x\n",\r\nphba->fw_config.dual_ulp_aware);\r\nstatus = 0;\r\nfail_init:\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nint beiscsi_get_port_name(struct be_ctrl_info *ctrl, struct beiscsi_hba *phba)\r\n{\r\nint ret = 0;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_get_port_name *ioctl;\r\nmutex_lock(&ctrl->mbox_lock);\r\nwrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nioctl = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*ioctl), true, 0);\r\nbe_cmd_hdr_prepare(&ioctl->h.req_hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_PORT_NAME,\r\nEMBED_MBX_MAX_PAYLOAD_SIZE);\r\nret = be_mbox_notify(ctrl);\r\nphba->port_name = 0;\r\nif (!ret) {\r\nphba->port_name = ioctl->p.resp.port_names >>\r\n(phba->fw_config.phys_port * 8) & 0xff;\r\n} else {\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\r\n"BG_%d : GET_PORT_NAME ret 0x%x status 0x%x\n",\r\nret, ioctl->h.resp_hdr.status);\r\n}\r\nif (phba->port_name == 0)\r\nphba->port_name = '?';\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn ret;\r\n}\r\nint beiscsi_set_uer_feature(struct beiscsi_hba *phba)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_cmd_set_features *ioctl;\r\nstruct be_mcc_wrb *wrb;\r\nint ret = 0;\r\nmutex_lock(&ctrl->mbox_lock);\r\nwrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nioctl = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*ioctl), true, 0);\r\nbe_cmd_hdr_prepare(&ioctl->h.req_hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_FEATURES,\r\nEMBED_MBX_MAX_PAYLOAD_SIZE);\r\nioctl->feature = BE_CMD_SET_FEATURE_UER;\r\nioctl->param_len = sizeof(ioctl->param.req);\r\nioctl->param.req.uer = BE_CMD_UER_SUPP_BIT;\r\nret = be_mbox_notify(ctrl);\r\nif (!ret) {\r\nphba->ue2rp = ioctl->param.resp.ue2rp;\r\nset_bit(BEISCSI_HBA_UER_SUPP, &phba->state);\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\r\n"BG_%d : HBA error recovery supported\n");\r\n} else {\r\nif (ret == MCC_STATUS_ILLEGAL_REQUEST ||\r\nret == MCC_STATUS_INVALID_LENGTH)\r\n__beiscsi_log(phba, KERN_INFO,\r\n"BG_%d : HBA error recovery not supported\n");\r\n}\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn ret;\r\n}\r\nstatic u32 beiscsi_get_post_stage(struct beiscsi_hba *phba)\r\n{\r\nu32 sem;\r\nif (is_chip_be2_be3r(phba))\r\nsem = ioread32(phba->csr_va + SLIPORT_SEMAPHORE_OFFSET_BEx);\r\nelse\r\npci_read_config_dword(phba->pcidev,\r\nSLIPORT_SEMAPHORE_OFFSET_SH, &sem);\r\nreturn sem;\r\n}\r\nint beiscsi_check_fw_rdy(struct beiscsi_hba *phba)\r\n{\r\nu32 loop, post, rdy = 0;\r\nloop = 1000;\r\nwhile (loop--) {\r\npost = beiscsi_get_post_stage(phba);\r\nif (post & POST_ERROR_BIT)\r\nbreak;\r\nif ((post & POST_STAGE_MASK) == POST_STAGE_ARMFW_RDY) {\r\nrdy = 1;\r\nbreak;\r\n}\r\nmsleep(60);\r\n}\r\nif (!rdy) {\r\n__beiscsi_log(phba, KERN_ERR,\r\n"BC_%d : FW not ready 0x%x\n", post);\r\n}\r\nreturn rdy;\r\n}\r\nint beiscsi_cmd_function_reset(struct beiscsi_hba *phba)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_post_sgl_pages_req *req;\r\nint status;\r\nmutex_lock(&ctrl->mbox_lock);\r\nreq = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_FUNCTION_RESET, sizeof(*req));\r\nstatus = be_mbox_notify(ctrl);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nint beiscsi_cmd_special_wrb(struct be_ctrl_info *ctrl, u32 load)\r\n{\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\r\nu8 *endian_check;\r\nint status;\r\nmutex_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nendian_check = (u8 *) wrb;\r\nif (load) {\r\n*endian_check++ = 0xFF;\r\n*endian_check++ = 0x12;\r\n*endian_check++ = 0x34;\r\n*endian_check++ = 0xFF;\r\n*endian_check++ = 0xFF;\r\n*endian_check++ = 0x56;\r\n*endian_check++ = 0x78;\r\n*endian_check++ = 0xFF;\r\n} else {\r\n*endian_check++ = 0xFF;\r\n*endian_check++ = 0xAA;\r\n*endian_check++ = 0xBB;\r\n*endian_check++ = 0xFF;\r\n*endian_check++ = 0xFF;\r\n*endian_check++ = 0xCC;\r\n*endian_check++ = 0xDD;\r\n*endian_check = 0xFF;\r\n}\r\nbe_dws_cpu_to_le(wrb, sizeof(*wrb));\r\nstatus = be_mbox_notify(ctrl);\r\nif (status)\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\r\n"BC_%d : special WRB message failed\n");\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nint beiscsi_init_sliport(struct beiscsi_hba *phba)\r\n{\r\nint status;\r\nstatus = beiscsi_check_fw_rdy(phba);\r\nif (!status)\r\nreturn -EIO;\r\nphba->state &= ~BEISCSI_HBA_IN_ERR;\r\nphba->state &= ~BEISCSI_HBA_UER_SUPP;\r\nstatus = beiscsi_cmd_function_reset(phba);\r\nif (status) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\r\n"BC_%d : SLI Function Reset failed\n");\r\nreturn status;\r\n}\r\nreturn beiscsi_cmd_special_wrb(&phba->ctrl, 1);\r\n}\r\nint beiscsi_cmd_iscsi_cleanup(struct beiscsi_hba *phba, unsigned short ulp)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct iscsi_cleanup_req_v1 *req_v1;\r\nstruct iscsi_cleanup_req *req;\r\nu16 hdr_ring_id, data_ring_id;\r\nstruct be_mcc_wrb *wrb;\r\nint status;\r\nmutex_lock(&ctrl->mbox_lock);\r\nwrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nhdr_ring_id = HWI_GET_DEF_HDRQ_ID(phba, ulp);\r\ndata_ring_id = HWI_GET_DEF_BUFQ_ID(phba, ulp);\r\nif (is_chip_be2_be3r(phba)) {\r\nreq = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_CLEANUP, sizeof(*req));\r\nreq->chute = (1 << ulp);\r\nreq->hdr_ring_id = hdr_ring_id;\r\nreq->data_ring_id = data_ring_id;\r\n} else {\r\nreq_v1 = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req_v1), true, 0);\r\nbe_cmd_hdr_prepare(&req_v1->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_CLEANUP,\r\nsizeof(*req_v1));\r\nreq_v1->hdr.version = 1;\r\nreq_v1->chute = (1 << ulp);\r\nreq_v1->hdr_ring_id = cpu_to_le16(hdr_ring_id);\r\nreq_v1->data_ring_id = cpu_to_le16(data_ring_id);\r\n}\r\nstatus = be_mbox_notify(ctrl);\r\nif (status)\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,\r\n"BG_%d : %s failed %d\n", __func__, ulp);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nint beiscsi_detect_ue(struct beiscsi_hba *phba)\r\n{\r\nuint32_t ue_mask_hi = 0, ue_mask_lo = 0;\r\nuint32_t ue_hi = 0, ue_lo = 0;\r\nuint8_t i = 0;\r\nint ret = 0;\r\npci_read_config_dword(phba->pcidev,\r\nPCICFG_UE_STATUS_LOW, &ue_lo);\r\npci_read_config_dword(phba->pcidev,\r\nPCICFG_UE_STATUS_MASK_LOW,\r\n&ue_mask_lo);\r\npci_read_config_dword(phba->pcidev,\r\nPCICFG_UE_STATUS_HIGH,\r\n&ue_hi);\r\npci_read_config_dword(phba->pcidev,\r\nPCICFG_UE_STATUS_MASK_HI,\r\n&ue_mask_hi);\r\nue_lo = (ue_lo & ~ue_mask_lo);\r\nue_hi = (ue_hi & ~ue_mask_hi);\r\nif (ue_lo || ue_hi) {\r\nset_bit(BEISCSI_HBA_IN_UE, &phba->state);\r\n__beiscsi_log(phba, KERN_ERR,\r\n"BC_%d : HBA error detected\n");\r\nret = 1;\r\n}\r\nif (ue_lo) {\r\nfor (i = 0; ue_lo; ue_lo >>= 1, i++) {\r\nif (ue_lo & 1)\r\n__beiscsi_log(phba, KERN_ERR,\r\n"BC_%d : UE_LOW %s bit set\n",\r\ndesc_ue_status_low[i]);\r\n}\r\n}\r\nif (ue_hi) {\r\nfor (i = 0; ue_hi; ue_hi >>= 1, i++) {\r\nif (ue_hi & 1)\r\n__beiscsi_log(phba, KERN_ERR,\r\n"BC_%d : UE_HIGH %s bit set\n",\r\ndesc_ue_status_hi[i]);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint beiscsi_detect_tpe(struct beiscsi_hba *phba)\r\n{\r\nu32 post, status;\r\nint ret = 0;\r\npost = beiscsi_get_post_stage(phba);\r\nstatus = post & POST_STAGE_MASK;\r\nif ((status & POST_ERR_RECOVERY_CODE_MASK) ==\r\nPOST_STAGE_RECOVERABLE_ERR) {\r\nset_bit(BEISCSI_HBA_IN_TPE, &phba->state);\r\n__beiscsi_log(phba, KERN_INFO,\r\n"BC_%d : HBA error recoverable: 0x%x\n", post);\r\nret = 1;\r\n} else {\r\n__beiscsi_log(phba, KERN_INFO,\r\n"BC_%d : HBA in UE: 0x%x\n", post);\r\n}\r\nreturn ret;\r\n}
