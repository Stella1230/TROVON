void __init ixp4xx_map_io(void)\r\n{\r\niotable_init(ixp4xx_io_desc, ARRAY_SIZE(ixp4xx_io_desc));\r\n}\r\nstatic void gpio_line_config(u8 line, u32 direction)\r\n{\r\nif (direction == IXP4XX_GPIO_IN)\r\n*IXP4XX_GPIO_GPOER |= (1 << line);\r\nelse\r\n*IXP4XX_GPIO_GPOER &= ~(1 << line);\r\n}\r\nstatic void gpio_line_get(u8 line, int *value)\r\n{\r\n*value = (*IXP4XX_GPIO_GPINR >> line) & 0x1;\r\n}\r\nstatic void gpio_line_set(u8 line, int value)\r\n{\r\nif (value == IXP4XX_GPIO_HIGH)\r\n*IXP4XX_GPIO_GPOUTR |= (1 << line);\r\nelse if (value == IXP4XX_GPIO_LOW)\r\n*IXP4XX_GPIO_GPOUTR &= ~(1 << line);\r\n}\r\nstatic int ixp4xx_gpio_to_irq(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nint irq;\r\nfor (irq = 0; irq < 32; irq++) {\r\nif (irq2gpio[irq] == gpio)\r\nreturn irq;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ixp4xx_set_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nint line = irq2gpio[d->irq];\r\nu32 int_style;\r\nenum ixp4xx_irq_type irq_type;\r\nvolatile u32 *int_reg;\r\nif (line < 0)\r\nreturn -EINVAL;\r\nswitch (type){\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nint_style = IXP4XX_GPIO_STYLE_TRANSITIONAL;\r\nirq_type = IXP4XX_IRQ_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nint_style = IXP4XX_GPIO_STYLE_RISING_EDGE;\r\nirq_type = IXP4XX_IRQ_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nint_style = IXP4XX_GPIO_STYLE_FALLING_EDGE;\r\nirq_type = IXP4XX_IRQ_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nint_style = IXP4XX_GPIO_STYLE_ACTIVE_HIGH;\r\nirq_type = IXP4XX_IRQ_LEVEL;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nint_style = IXP4XX_GPIO_STYLE_ACTIVE_LOW;\r\nirq_type = IXP4XX_IRQ_LEVEL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (irq_type == IXP4XX_IRQ_EDGE)\r\nixp4xx_irq_edge |= (1 << d->irq);\r\nelse\r\nixp4xx_irq_edge &= ~(1 << d->irq);\r\nif (line >= 8) {\r\nline -= 8;\r\nint_reg = IXP4XX_GPIO_GPIT2R;\r\n} else {\r\nint_reg = IXP4XX_GPIO_GPIT1R;\r\n}\r\n*int_reg &= ~(IXP4XX_GPIO_STYLE_CLEAR <<\r\n(line * IXP4XX_GPIO_STYLE_SIZE));\r\n*IXP4XX_GPIO_GPISR = (1 << line);\r\n*int_reg |= (int_style << (line * IXP4XX_GPIO_STYLE_SIZE));\r\ngpio_line_config(irq2gpio[d->irq], IXP4XX_GPIO_IN);\r\nreturn 0;\r\n}\r\nstatic void ixp4xx_irq_mask(struct irq_data *d)\r\n{\r\nif ((cpu_is_ixp46x() || cpu_is_ixp43x()) && d->irq >= 32)\r\n*IXP4XX_ICMR2 &= ~(1 << (d->irq - 32));\r\nelse\r\n*IXP4XX_ICMR &= ~(1 << d->irq);\r\n}\r\nstatic void ixp4xx_irq_ack(struct irq_data *d)\r\n{\r\nint line = (d->irq < 32) ? irq2gpio[d->irq] : -1;\r\nif (line >= 0)\r\n*IXP4XX_GPIO_GPISR = (1 << line);\r\n}\r\nstatic void ixp4xx_irq_unmask(struct irq_data *d)\r\n{\r\nif (!(ixp4xx_irq_edge & (1 << d->irq)))\r\nixp4xx_irq_ack(d);\r\nif ((cpu_is_ixp46x() || cpu_is_ixp43x()) && d->irq >= 32)\r\n*IXP4XX_ICMR2 |= (1 << (d->irq - 32));\r\nelse\r\n*IXP4XX_ICMR |= (1 << d->irq);\r\n}\r\nvoid __init ixp4xx_init_irq(void)\r\n{\r\nint i = 0;\r\ncpu_idle_poll_ctrl(true);\r\n*IXP4XX_ICLR = 0x0;\r\n*IXP4XX_ICMR = 0x0;\r\nif (cpu_is_ixp46x() || cpu_is_ixp43x()) {\r\n*IXP4XX_ICLR2 = 0x00;\r\n*IXP4XX_ICMR2 = 0x00;\r\n}\r\nfor(i = 0; i < NR_IRQS; i++) {\r\nirq_set_chip_and_handler(i, &ixp4xx_irq_chip,\r\nhandle_level_irq);\r\nirq_clear_status_flags(i, IRQ_NOREQUEST);\r\n}\r\n}\r\nstatic irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\n*IXP4XX_OSST = IXP4XX_OSST_TIMER_1_PEND;\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid __init ixp4xx_timer_init(void)\r\n{\r\n*IXP4XX_OSRT1 = 0;\r\n*IXP4XX_OSST = IXP4XX_OSST_TIMER_1_PEND;\r\n*IXP4XX_OSTS = 0;\r\nsetup_irq(IRQ_IXP4XX_TIMER1, &ixp4xx_timer_irq);\r\nixp4xx_clocksource_init();\r\nixp4xx_clockevent_init();\r\n}\r\nvoid __init ixp4xx_set_udc_info(struct pxa2xx_udc_mach_info *info)\r\n{\r\nmemcpy(&ixp4xx_udc_info, info, sizeof *info);\r\n}\r\nstatic int ixp4xx_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)\r\n{\r\ngpio_line_config(gpio, IXP4XX_GPIO_IN);\r\nreturn 0;\r\n}\r\nstatic int ixp4xx_gpio_direction_output(struct gpio_chip *chip, unsigned gpio,\r\nint level)\r\n{\r\ngpio_line_set(gpio, level);\r\ngpio_line_config(gpio, IXP4XX_GPIO_OUT);\r\nreturn 0;\r\n}\r\nstatic int ixp4xx_gpio_get_value(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nint value;\r\ngpio_line_get(gpio, &value);\r\nreturn value;\r\n}\r\nstatic void ixp4xx_gpio_set_value(struct gpio_chip *chip, unsigned gpio,\r\nint value)\r\n{\r\ngpio_line_set(gpio, value);\r\n}\r\nvoid __init ixp4xx_sys_init(void)\r\n{\r\nixp4xx_exp_bus_size = SZ_16M;\r\nplatform_add_devices(ixp4xx_devices, ARRAY_SIZE(ixp4xx_devices));\r\ngpiochip_add_data(&ixp4xx_gpio_chip, NULL);\r\nif (cpu_is_ixp46x()) {\r\nint region;\r\nplatform_add_devices(ixp46x_devices,\r\nARRAY_SIZE(ixp46x_devices));\r\nfor (region = 0; region < 7; region++) {\r\nif((*(IXP4XX_EXP_REG(0x4 * region)) & 0x200)) {\r\nixp4xx_exp_bus_size = SZ_32M;\r\nbreak;\r\n}\r\n}\r\n}\r\nprintk("IXP4xx: Using %luMiB expansion bus window size\n",\r\nixp4xx_exp_bus_size >> 20);\r\n}\r\nstatic u64 notrace ixp4xx_read_sched_clock(void)\r\n{\r\nreturn *IXP4XX_OSTS;\r\n}\r\nstatic u64 ixp4xx_clocksource_read(struct clocksource *c)\r\n{\r\nreturn *IXP4XX_OSTS;\r\n}\r\nstatic void __init ixp4xx_clocksource_init(void)\r\n{\r\nsched_clock_register(ixp4xx_read_sched_clock, 32, ixp4xx_timer_freq);\r\nclocksource_mmio_init(NULL, "OSTS", ixp4xx_timer_freq, 200, 32,\r\nixp4xx_clocksource_read);\r\n}\r\nstatic int ixp4xx_set_next_event(unsigned long evt,\r\nstruct clock_event_device *unused)\r\n{\r\nunsigned long opts = *IXP4XX_OSRT1 & IXP4XX_OST_RELOAD_MASK;\r\n*IXP4XX_OSRT1 = (evt & ~IXP4XX_OST_RELOAD_MASK) | opts;\r\nreturn 0;\r\n}\r\nstatic int ixp4xx_shutdown(struct clock_event_device *evt)\r\n{\r\nunsigned long opts = *IXP4XX_OSRT1 & IXP4XX_OST_RELOAD_MASK;\r\nunsigned long osrt = *IXP4XX_OSRT1 & ~IXP4XX_OST_RELOAD_MASK;\r\nopts &= ~IXP4XX_OST_ENABLE;\r\n*IXP4XX_OSRT1 = osrt | opts;\r\nreturn 0;\r\n}\r\nstatic int ixp4xx_set_oneshot(struct clock_event_device *evt)\r\n{\r\nunsigned long opts = IXP4XX_OST_ENABLE | IXP4XX_OST_ONE_SHOT;\r\nunsigned long osrt = 0;\r\n*IXP4XX_OSRT1 = osrt | opts;\r\nreturn 0;\r\n}\r\nstatic int ixp4xx_set_periodic(struct clock_event_device *evt)\r\n{\r\nunsigned long opts = IXP4XX_OST_ENABLE;\r\nunsigned long osrt = IXP4XX_LATCH & ~IXP4XX_OST_RELOAD_MASK;\r\n*IXP4XX_OSRT1 = osrt | opts;\r\nreturn 0;\r\n}\r\nstatic int ixp4xx_resume(struct clock_event_device *evt)\r\n{\r\nunsigned long opts = *IXP4XX_OSRT1 & IXP4XX_OST_RELOAD_MASK;\r\nunsigned long osrt = *IXP4XX_OSRT1 & ~IXP4XX_OST_RELOAD_MASK;\r\nopts |= IXP4XX_OST_ENABLE;\r\n*IXP4XX_OSRT1 = osrt | opts;\r\nreturn 0;\r\n}\r\nstatic void __init ixp4xx_clockevent_init(void)\r\n{\r\nclockevent_ixp4xx.cpumask = cpumask_of(0);\r\nclockevents_config_and_register(&clockevent_ixp4xx, IXP4XX_TIMER_FREQ,\r\n0xf, 0xfffffffe);\r\n}\r\nvoid ixp4xx_restart(enum reboot_mode mode, const char *cmd)\r\n{\r\nif (mode == REBOOT_SOFT) {\r\nsoft_restart(0);\r\n} else {\r\n*IXP4XX_OSWK = IXP4XX_WDT_KEY;\r\n*IXP4XX_OSWT = 0;\r\n*IXP4XX_OSWE = IXP4XX_WDT_RESET_ENABLE | IXP4XX_WDT_COUNT_ENABLE;\r\n}\r\n}\r\nstatic int ixp4xx_needs_bounce(struct device *dev, dma_addr_t dma_addr, size_t size)\r\n{\r\nreturn (dma_addr + size) > SZ_64M;\r\n}\r\nstatic int ixp4xx_platform_notify_remove(struct device *dev)\r\n{\r\nif (dev_is_pci(dev))\r\ndmabounce_unregister_dev(dev);\r\nreturn 0;\r\n}\r\nstatic int ixp4xx_platform_notify(struct device *dev)\r\n{\r\ndev->dma_mask = &dev->coherent_dma_mask;\r\n#ifdef CONFIG_PCI\r\nif (dev_is_pci(dev)) {\r\ndev->coherent_dma_mask = DMA_BIT_MASK(28);\r\ndmabounce_register_dev(dev, 2048, 4096, ixp4xx_needs_bounce);\r\nreturn 0;\r\n}\r\n#endif\r\ndev->coherent_dma_mask = DMA_BIT_MASK(32);\r\nreturn 0;\r\n}\r\nint dma_set_coherent_mask(struct device *dev, u64 mask)\r\n{\r\nif (dev_is_pci(dev))\r\nmask &= DMA_BIT_MASK(28);\r\nif ((mask & DMA_BIT_MASK(28)) == DMA_BIT_MASK(28)) {\r\ndev->coherent_dma_mask = mask;\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void __iomem *ixp4xx_ioremap_caller(phys_addr_t addr, size_t size,\r\nunsigned int mtype, void *caller)\r\n{\r\nif (!is_pci_memory(addr))\r\nreturn __arm_ioremap_caller(addr, size, mtype, caller);\r\nreturn (void __iomem *)addr;\r\n}\r\nstatic void ixp4xx_iounmap(volatile void __iomem *addr)\r\n{\r\nif (!is_pci_memory((__force u32)addr))\r\n__iounmap(addr);\r\n}\r\nvoid __init ixp4xx_init_early(void)\r\n{\r\nplatform_notify = ixp4xx_platform_notify;\r\n#ifdef CONFIG_PCI\r\nplatform_notify_remove = ixp4xx_platform_notify_remove;\r\n#endif\r\n#ifdef CONFIG_IXP4XX_INDIRECT_PCI\r\narch_ioremap_caller = ixp4xx_ioremap_caller;\r\narch_iounmap = ixp4xx_iounmap;\r\n#endif\r\n}
