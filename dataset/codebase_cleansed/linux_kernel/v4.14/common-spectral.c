static s8 fix_rssi_inv_only(u8 rssi_val)\r\n{\r\nif (rssi_val == 128)\r\nrssi_val = 0;\r\nreturn (s8) rssi_val;\r\n}\r\nstatic void ath_debug_send_fft_sample(struct ath_spec_scan_priv *spec_priv,\r\nstruct fft_sample_tlv *fft_sample_tlv)\r\n{\r\nint length;\r\nif (!spec_priv->rfs_chan_spec_scan)\r\nreturn;\r\nlength = __be16_to_cpu(fft_sample_tlv->length) +\r\nsizeof(*fft_sample_tlv);\r\nrelay_write(spec_priv->rfs_chan_spec_scan, fft_sample_tlv, length);\r\n}\r\nstatic int\r\nath_cmn_max_idx_verify_ht20_fft(u8 *sample_end, int bytes_read)\r\n{\r\nstruct ath_ht20_mag_info *mag_info;\r\nu8 *sample;\r\nu16 max_magnitude;\r\nu8 max_index;\r\nu8 max_exp;\r\nif (bytes_read < SPECTRAL_HT20_SAMPLE_LEN - 1)\r\nreturn -1;\r\nmag_info = (struct ath_ht20_mag_info *) (sample_end -\r\nsizeof(struct ath_ht20_mag_info) + 1);\r\nsample = sample_end - SPECTRAL_HT20_SAMPLE_LEN + 1;\r\nmax_index = spectral_max_index(mag_info->all_bins,\r\nSPECTRAL_HT20_NUM_BINS);\r\nmax_magnitude = spectral_max_magnitude(mag_info->all_bins);\r\nmax_exp = mag_info->max_exp & 0xf;\r\nif (bytes_read < SPECTRAL_HT20_SAMPLE_LEN && max_index < 1)\r\nreturn -1;\r\nif (sample[max_index] != (max_magnitude >> max_exp))\r\nreturn -1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int\r\nath_cmn_max_idx_verify_ht20_40_fft(u8 *sample_end, int bytes_read)\r\n{\r\nstruct ath_ht20_40_mag_info *mag_info;\r\nu8 *sample;\r\nu16 lower_mag, upper_mag;\r\nu8 lower_max_index, upper_max_index;\r\nu8 max_exp;\r\nint dc_pos = SPECTRAL_HT20_40_NUM_BINS / 2;\r\nif (bytes_read < SPECTRAL_HT20_40_SAMPLE_LEN - 1)\r\nreturn -1;\r\nmag_info = (struct ath_ht20_40_mag_info *) (sample_end -\r\nsizeof(struct ath_ht20_40_mag_info) + 1);\r\nsample = sample_end - SPECTRAL_HT20_40_SAMPLE_LEN + 1;\r\nlower_mag = spectral_max_magnitude(mag_info->lower_bins);\r\nlower_max_index = spectral_max_index(mag_info->lower_bins,\r\nSPECTRAL_HT20_40_NUM_BINS);\r\nupper_mag = spectral_max_magnitude(mag_info->upper_bins);\r\nupper_max_index = spectral_max_index(mag_info->upper_bins,\r\nSPECTRAL_HT20_40_NUM_BINS);\r\nmax_exp = mag_info->max_exp & 0xf;\r\nif (bytes_read < SPECTRAL_HT20_40_SAMPLE_LEN &&\r\n((upper_max_index < 1) || (lower_max_index < 1)))\r\nreturn -1;\r\nif ((upper_max_index - dc_pos > 0) &&\r\n(sample[upper_max_index] == (upper_mag >> max_exp)))\r\nupper_max_index -= dc_pos;\r\nif ((lower_max_index - dc_pos > 0) &&\r\n(sample[lower_max_index - dc_pos] == (lower_mag >> max_exp)))\r\nlower_max_index -= dc_pos;\r\nif ((sample[upper_max_index + dc_pos] != (upper_mag >> max_exp)) ||\r\n(sample[lower_max_index] != (lower_mag >> max_exp)))\r\nreturn -1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int\r\nath_cmn_process_ht20_fft(struct ath_rx_status *rs,\r\nstruct ath_spec_scan_priv *spec_priv,\r\nu8 *sample_buf,\r\nu64 tsf, u16 freq, int chan_type)\r\n{\r\nstruct fft_sample_ht20 fft_sample_20;\r\nstruct ath_common *common = ath9k_hw_common(spec_priv->ah);\r\nstruct ath_hw *ah = spec_priv->ah;\r\nstruct ath_ht20_mag_info *mag_info;\r\nstruct fft_sample_tlv *tlv;\r\nint i = 0;\r\nint ret = 0;\r\nint dc_pos = SPECTRAL_HT20_NUM_BINS / 2;\r\nu16 magnitude, tmp_mag, length;\r\nu8 max_index, bitmap_w, max_exp;\r\nlength = sizeof(fft_sample_20) - sizeof(struct fft_sample_tlv);\r\nfft_sample_20.tlv.type = ATH_FFT_SAMPLE_HT20;\r\nfft_sample_20.tlv.length = __cpu_to_be16(length);\r\nfft_sample_20.freq = __cpu_to_be16(freq);\r\nfft_sample_20.rssi = fix_rssi_inv_only(rs->rs_rssi_ctl[0]);\r\nfft_sample_20.noise = ah->noise;\r\nmag_info = (struct ath_ht20_mag_info *) (sample_buf +\r\nSPECTRAL_HT20_NUM_BINS);\r\nmagnitude = spectral_max_magnitude(mag_info->all_bins);\r\nfft_sample_20.max_magnitude = __cpu_to_be16(magnitude);\r\nmax_index = spectral_max_index(mag_info->all_bins,\r\nSPECTRAL_HT20_NUM_BINS);\r\nfft_sample_20.max_index = max_index;\r\nbitmap_w = spectral_bitmap_weight(mag_info->all_bins);\r\nfft_sample_20.bitmap_weight = bitmap_w;\r\nmax_exp = mag_info->max_exp & 0xf;\r\nfft_sample_20.max_exp = max_exp;\r\nfft_sample_20.tsf = __cpu_to_be64(tsf);\r\nmemcpy(fft_sample_20.data, sample_buf, SPECTRAL_HT20_NUM_BINS);\r\nath_dbg(common, SPECTRAL_SCAN, "FFT HT20 frame: max mag 0x%X,"\r\n"max_mag_idx %i\n",\r\nmagnitude >> max_exp,\r\nmax_index);\r\nif (fft_sample_20.data[max_index] != (magnitude >> max_exp)) {\r\nath_dbg(common, SPECTRAL_SCAN, "Magnitude mismatch !\n");\r\nret = -1;\r\n}\r\nfft_sample_20.data[dc_pos] = (fft_sample_20.data[dc_pos + 1] +\r\nfft_sample_20.data[dc_pos - 1]) / 2;\r\nif (max_index == dc_pos) {\r\ntmp_mag = 0;\r\nfor (i = 0; i < dc_pos; i++) {\r\nif (fft_sample_20.data[i] > tmp_mag) {\r\ntmp_mag = fft_sample_20.data[i];\r\nfft_sample_20.max_index = i;\r\n}\r\n}\r\nmagnitude = tmp_mag << max_exp;\r\nfft_sample_20.max_magnitude = __cpu_to_be16(magnitude);\r\nath_dbg(common, SPECTRAL_SCAN,\r\n"Calculated new lower max 0x%X at %i\n",\r\ntmp_mag, fft_sample_20.max_index);\r\n} else\r\nfor (i = 0; i < SPECTRAL_HT20_NUM_BINS; i++) {\r\nif (fft_sample_20.data[i] == (magnitude >> max_exp))\r\nath_dbg(common, SPECTRAL_SCAN,\r\n"Got max: 0x%X at index %i\n",\r\nfft_sample_20.data[i], i);\r\nif (fft_sample_20.data[i] > (magnitude >> max_exp)) {\r\nath_dbg(common, SPECTRAL_SCAN,\r\n"Got bin %i greater than max: 0x%X\n",\r\ni, fft_sample_20.data[i]);\r\nret = -1;\r\n}\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\ntlv = (struct fft_sample_tlv *)&fft_sample_20;\r\nath_debug_send_fft_sample(spec_priv, tlv);\r\nreturn 0;\r\n}\r\nstatic int\r\nath_cmn_process_ht20_40_fft(struct ath_rx_status *rs,\r\nstruct ath_spec_scan_priv *spec_priv,\r\nu8 *sample_buf,\r\nu64 tsf, u16 freq, int chan_type)\r\n{\r\nstruct fft_sample_ht20_40 fft_sample_40;\r\nstruct ath_common *common = ath9k_hw_common(spec_priv->ah);\r\nstruct ath_hw *ah = spec_priv->ah;\r\nstruct ath9k_hw_cal_data *caldata = ah->caldata;\r\nstruct ath_ht20_40_mag_info *mag_info;\r\nstruct fft_sample_tlv *tlv;\r\nint dc_pos = SPECTRAL_HT20_40_NUM_BINS / 2;\r\nint i = 0;\r\nint ret = 0;\r\ns16 ext_nf;\r\nu16 lower_mag, upper_mag, tmp_mag, length;\r\ns8 lower_rssi, upper_rssi;\r\nu8 lower_max_index, upper_max_index;\r\nu8 lower_bitmap_w, upper_bitmap_w, max_exp;\r\nif (caldata)\r\next_nf = ath9k_hw_getchan_noise(ah, ah->curchan,\r\ncaldata->nfCalHist[3].privNF);\r\nelse\r\next_nf = ATH_DEFAULT_NOISE_FLOOR;\r\nlength = sizeof(fft_sample_40) - sizeof(struct fft_sample_tlv);\r\nfft_sample_40.tlv.type = ATH_FFT_SAMPLE_HT20_40;\r\nfft_sample_40.tlv.length = __cpu_to_be16(length);\r\nfft_sample_40.freq = __cpu_to_be16(freq);\r\nfft_sample_40.channel_type = chan_type;\r\nif (chan_type == NL80211_CHAN_HT40PLUS) {\r\nlower_rssi = fix_rssi_inv_only(rs->rs_rssi_ctl[0]);\r\nupper_rssi = fix_rssi_inv_only(rs->rs_rssi_ext[0]);\r\nfft_sample_40.lower_noise = ah->noise;\r\nfft_sample_40.upper_noise = ext_nf;\r\n} else {\r\nlower_rssi = fix_rssi_inv_only(rs->rs_rssi_ext[0]);\r\nupper_rssi = fix_rssi_inv_only(rs->rs_rssi_ctl[0]);\r\nfft_sample_40.lower_noise = ext_nf;\r\nfft_sample_40.upper_noise = ah->noise;\r\n}\r\nfft_sample_40.lower_rssi = lower_rssi;\r\nfft_sample_40.upper_rssi = upper_rssi;\r\nmag_info = (struct ath_ht20_40_mag_info *) (sample_buf +\r\nSPECTRAL_HT20_40_NUM_BINS);\r\nlower_mag = spectral_max_magnitude(mag_info->lower_bins);\r\nfft_sample_40.lower_max_magnitude = __cpu_to_be16(lower_mag);\r\nupper_mag = spectral_max_magnitude(mag_info->upper_bins);\r\nfft_sample_40.upper_max_magnitude = __cpu_to_be16(upper_mag);\r\nlower_max_index = spectral_max_index(mag_info->lower_bins,\r\nSPECTRAL_HT20_40_NUM_BINS);\r\nfft_sample_40.lower_max_index = lower_max_index;\r\nupper_max_index = spectral_max_index(mag_info->upper_bins,\r\nSPECTRAL_HT20_40_NUM_BINS);\r\nfft_sample_40.upper_max_index = upper_max_index;\r\nlower_bitmap_w = spectral_bitmap_weight(mag_info->lower_bins);\r\nfft_sample_40.lower_bitmap_weight = lower_bitmap_w;\r\nupper_bitmap_w = spectral_bitmap_weight(mag_info->upper_bins);\r\nfft_sample_40.upper_bitmap_weight = upper_bitmap_w;\r\nmax_exp = mag_info->max_exp & 0xf;\r\nfft_sample_40.max_exp = max_exp;\r\nfft_sample_40.tsf = __cpu_to_be64(tsf);\r\nmemcpy(fft_sample_40.data, sample_buf, SPECTRAL_HT20_40_NUM_BINS);\r\nath_dbg(common, SPECTRAL_SCAN, "FFT HT20/40 frame: lower mag 0x%X,"\r\n"lower_mag_idx %i, upper mag 0x%X,"\r\n"upper_mag_idx %i\n",\r\nlower_mag >> max_exp,\r\nlower_max_index,\r\nupper_mag >> max_exp,\r\nupper_max_index);\r\nif ((upper_max_index - dc_pos > 0) &&\r\n(fft_sample_40.data[upper_max_index] == (upper_mag >> max_exp))) {\r\nupper_max_index -= dc_pos;\r\nfft_sample_40.upper_max_index = upper_max_index;\r\n}\r\nif ((lower_max_index - dc_pos > 0) &&\r\n(fft_sample_40.data[lower_max_index - dc_pos] ==\r\n(lower_mag >> max_exp))) {\r\nlower_max_index -= dc_pos;\r\nfft_sample_40.lower_max_index = lower_max_index;\r\n}\r\nif ((fft_sample_40.data[upper_max_index + dc_pos]\r\n!= (upper_mag >> max_exp)) ||\r\n(fft_sample_40.data[lower_max_index]\r\n!= (lower_mag >> max_exp))) {\r\nath_dbg(common, SPECTRAL_SCAN, "Magnitude mismatch !\n");\r\nret = -1;\r\n}\r\nfft_sample_40.data[dc_pos] = (fft_sample_40.data[dc_pos + 1] +\r\nfft_sample_40.data[dc_pos - 1]) / 2;\r\nif (lower_max_index == dc_pos) {\r\ntmp_mag = 0;\r\nfor (i = 0; i < dc_pos; i++) {\r\nif (fft_sample_40.data[i] > tmp_mag) {\r\ntmp_mag = fft_sample_40.data[i];\r\nfft_sample_40.lower_max_index = i;\r\n}\r\n}\r\nlower_mag = tmp_mag << max_exp;\r\nfft_sample_40.lower_max_magnitude = __cpu_to_be16(lower_mag);\r\nath_dbg(common, SPECTRAL_SCAN,\r\n"Calculated new lower max 0x%X at %i\n",\r\ntmp_mag, fft_sample_40.lower_max_index);\r\n} else\r\nfor (i = 0; i < dc_pos; i++) {\r\nif (fft_sample_40.data[i] == (lower_mag >> max_exp))\r\nath_dbg(common, SPECTRAL_SCAN,\r\n"Got lower mag: 0x%X at index %i\n",\r\nfft_sample_40.data[i], i);\r\nif (fft_sample_40.data[i] > (lower_mag >> max_exp)) {\r\nath_dbg(common, SPECTRAL_SCAN,\r\n"Got lower bin %i higher than max: 0x%X\n",\r\ni, fft_sample_40.data[i]);\r\nret = -1;\r\n}\r\n}\r\nif (upper_max_index == dc_pos) {\r\ntmp_mag = 0;\r\nfor (i = dc_pos; i < SPECTRAL_HT20_40_NUM_BINS; i++) {\r\nif (fft_sample_40.data[i] > tmp_mag) {\r\ntmp_mag = fft_sample_40.data[i];\r\nfft_sample_40.upper_max_index = i;\r\n}\r\n}\r\nupper_mag = tmp_mag << max_exp;\r\nfft_sample_40.upper_max_magnitude = __cpu_to_be16(upper_mag);\r\nath_dbg(common, SPECTRAL_SCAN,\r\n"Calculated new upper max 0x%X at %i\n",\r\ntmp_mag, i);\r\n} else\r\nfor (i = dc_pos; i < SPECTRAL_HT20_40_NUM_BINS; i++) {\r\nif (fft_sample_40.data[i] == (upper_mag >> max_exp))\r\nath_dbg(common, SPECTRAL_SCAN,\r\n"Got upper mag: 0x%X at index %i\n",\r\nfft_sample_40.data[i], i);\r\nif (fft_sample_40.data[i] > (upper_mag >> max_exp)) {\r\nath_dbg(common, SPECTRAL_SCAN,\r\n"Got upper bin %i higher than max: 0x%X\n",\r\ni, fft_sample_40.data[i]);\r\nret = -1;\r\n}\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\ntlv = (struct fft_sample_tlv *)&fft_sample_40;\r\nath_debug_send_fft_sample(spec_priv, tlv);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nath_cmn_copy_fft_frame(u8 *in, u8 *out, int sample_len, int sample_bytes)\r\n{\r\nswitch (sample_bytes - sample_len) {\r\ncase -1:\r\nmemcpy(&out[1], in,\r\nsample_len - 1);\r\nbreak;\r\ncase 0:\r\nmemcpy(out, in, sample_len);\r\nbreak;\r\ncase 1:\r\nmemcpy(&out[1], in, 30);\r\nout[31] = in[31];\r\nmemcpy(&out[32], &in[33],\r\nsample_len - 32);\r\nbreak;\r\ncase 2:\r\nmemcpy(out, in, 30);\r\nout[30] = in[31];\r\nmemcpy(&out[31], &in[33],\r\nsample_len - 31);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nath_cmn_is_fft_buf_full(struct ath_spec_scan_priv *spec_priv)\r\n{\r\nint i = 0;\r\nint ret = 0;\r\nstruct rchan *rc = spec_priv->rfs_chan_spec_scan;\r\nfor_each_online_cpu(i)\r\nret += relay_buf_full(*per_cpu_ptr(rc->buf, i));\r\ni = num_online_cpus();\r\nif (ret == i)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nint ath_cmn_process_fft(struct ath_spec_scan_priv *spec_priv, struct ieee80211_hdr *hdr,\r\nstruct ath_rx_status *rs, u64 tsf)\r\n{\r\nu8 sample_buf[SPECTRAL_SAMPLE_MAX_LEN] = {0};\r\nstruct ath_hw *ah = spec_priv->ah;\r\nstruct ath_common *common = ath9k_hw_common(spec_priv->ah);\r\nu8 num_bins, *vdata = (u8 *)hdr;\r\nstruct ath_radar_info *radar_info;\r\nint len = rs->rs_datalen;\r\nint i;\r\nint got_slen = 0;\r\nu8 *sample_start;\r\nint sample_bytes = 0;\r\nint ret = 0;\r\nu16 fft_len, sample_len, freq = ah->curchan->chan->center_freq;\r\nenum nl80211_channel_type chan_type;\r\nath_cmn_fft_idx_validator *fft_idx_validator;\r\nath_cmn_fft_sample_handler *fft_handler;\r\nif (rs->rs_phyerr != ATH9K_PHYERR_RADAR &&\r\nrs->rs_phyerr != ATH9K_PHYERR_FALSE_RADAR_EXT &&\r\nrs->rs_phyerr != ATH9K_PHYERR_SPECTRAL)\r\nreturn 0;\r\nradar_info = ((struct ath_radar_info *)&vdata[len]) - 1;\r\nif (!(radar_info->pulse_bw_info & SPECTRAL_SCAN_BITMASK))\r\nreturn 0;\r\nif (!spec_priv->rfs_chan_spec_scan)\r\nreturn 1;\r\nret = ath_cmn_is_fft_buf_full(spec_priv);\r\nif (ret == 1) {\r\nath_dbg(common, SPECTRAL_SCAN, "FFT report ignored, no space "\r\n"left on output buffers\n");\r\nreturn 1;\r\n}\r\nchan_type = cfg80211_get_chandef_type(&common->hw->conf.chandef);\r\nif ((chan_type == NL80211_CHAN_HT40MINUS) ||\r\n(chan_type == NL80211_CHAN_HT40PLUS)) {\r\nfft_len = SPECTRAL_HT20_40_TOTAL_DATA_LEN;\r\nsample_len = SPECTRAL_HT20_40_SAMPLE_LEN;\r\nnum_bins = SPECTRAL_HT20_40_NUM_BINS;\r\nfft_idx_validator = &ath_cmn_max_idx_verify_ht20_40_fft;\r\nfft_handler = &ath_cmn_process_ht20_40_fft;\r\n} else {\r\nfft_len = SPECTRAL_HT20_TOTAL_DATA_LEN;\r\nsample_len = SPECTRAL_HT20_SAMPLE_LEN;\r\nnum_bins = SPECTRAL_HT20_NUM_BINS;\r\nfft_idx_validator = ath_cmn_max_idx_verify_ht20_fft;\r\nfft_handler = &ath_cmn_process_ht20_fft;\r\n}\r\nath_dbg(common, SPECTRAL_SCAN, "Got radar dump bw_info: 0x%X,"\r\n"len: %i fft_len: %i\n",\r\nradar_info->pulse_bw_info,\r\nlen,\r\nfft_len);\r\nsample_start = vdata;\r\nfor (i = 0; i < len - 2; i++) {\r\nsample_bytes++;\r\nif (len <= fft_len + 2) {\r\nsample_bytes = len - sizeof(struct ath_radar_info);\r\ngot_slen = 1;\r\n}\r\nif (vdata[i] <= 0x7 && sample_bytes >= sample_len - 1) {\r\nif ((sample_bytes > sample_len + 2) ||\r\n((sample_bytes > sample_len) &&\r\n(sample_start[31] != sample_start[32])))\r\nbreak;\r\nif (!fft_idx_validator(&vdata[i], i)) {\r\nath_dbg(common, SPECTRAL_SCAN,\r\n"Found valid fft frame at %i\n", i);\r\ngot_slen = 1;\r\n}\r\nelse if ((sample_start[31] == sample_start[32]) &&\r\n(sample_bytes >= sample_len) &&\r\n(sample_bytes < sample_len + 2) &&\r\n(vdata[i + 1] <= 0x7))\r\ncontinue;\r\nelse if ((sample_bytes == sample_len - 1) &&\r\n(vdata[i + 1] <= 0x7))\r\ncontinue;\r\ngot_slen = 1;\r\n}\r\nif (got_slen) {\r\nath_dbg(common, SPECTRAL_SCAN, "FFT frame len: %i\n",\r\nsample_bytes);\r\nif (sample_bytes != sample_len && len <= fft_len + 2) {\r\nath_cmn_copy_fft_frame(sample_start,\r\nsample_buf, sample_len,\r\nsample_bytes);\r\nfft_handler(rs, spec_priv, sample_buf,\r\ntsf, freq, chan_type);\r\nmemset(sample_buf, 0, SPECTRAL_SAMPLE_MAX_LEN);\r\nadd_device_randomness(sample_buf, num_bins);\r\n}\r\nif (sample_bytes == sample_len) {\r\nret = fft_handler(rs, spec_priv, sample_start,\r\ntsf, freq, chan_type);\r\nadd_device_randomness(sample_start, num_bins);\r\n}\r\nif (len <= fft_len + 2)\r\nbreak;\r\nsample_start = &vdata[i + 1];\r\nif (ret == 0) {\r\ni += num_bins - 2;\r\nsample_bytes = num_bins - 2;\r\n}\r\ngot_slen = 0;\r\n}\r\n}\r\ni -= num_bins - 2;\r\nif (len - i != sizeof(struct ath_radar_info))\r\nath_dbg(common, SPECTRAL_SCAN, "FFT report truncated"\r\n"(bytes left: %i)\n",\r\nlen - i);\r\nreturn 1;\r\n}\r\nstatic ssize_t read_file_spec_scan_ctl(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath_spec_scan_priv *spec_priv = file->private_data;\r\nchar *mode = "";\r\nunsigned int len;\r\nswitch (spec_priv->spectral_mode) {\r\ncase SPECTRAL_DISABLED:\r\nmode = "disable";\r\nbreak;\r\ncase SPECTRAL_BACKGROUND:\r\nmode = "background";\r\nbreak;\r\ncase SPECTRAL_CHANSCAN:\r\nmode = "chanscan";\r\nbreak;\r\ncase SPECTRAL_MANUAL:\r\nmode = "manual";\r\nbreak;\r\n}\r\nlen = strlen(mode);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, mode, len);\r\n}\r\nvoid ath9k_cmn_spectral_scan_trigger(struct ath_common *common,\r\nstruct ath_spec_scan_priv *spec_priv)\r\n{\r\nstruct ath_hw *ah = spec_priv->ah;\r\nu32 rxfilter;\r\nif (IS_ENABLED(CONFIG_ATH9K_TX99))\r\nreturn;\r\nif (!ath9k_hw_ops(ah)->spectral_scan_trigger) {\r\nath_err(common, "spectrum analyzer not implemented on this hardware\n");\r\nreturn;\r\n}\r\nif (!spec_priv->spec_config.enabled)\r\nreturn;\r\nath_ps_ops(common)->wakeup(common);\r\nrxfilter = ath9k_hw_getrxfilter(ah);\r\nath9k_hw_setrxfilter(ah, rxfilter |\r\nATH9K_RX_FILTER_PHYRADAR |\r\nATH9K_RX_FILTER_PHYERR);\r\nath9k_cmn_spectral_scan_config(common, spec_priv, spec_priv->spectral_mode);\r\nath9k_hw_ops(ah)->spectral_scan_trigger(ah);\r\nath_ps_ops(common)->restore(common);\r\n}\r\nint ath9k_cmn_spectral_scan_config(struct ath_common *common,\r\nstruct ath_spec_scan_priv *spec_priv,\r\nenum spectral_mode spectral_mode)\r\n{\r\nstruct ath_hw *ah = spec_priv->ah;\r\nif (!ath9k_hw_ops(ah)->spectral_scan_trigger) {\r\nath_err(common, "spectrum analyzer not implemented on this hardware\n");\r\nreturn -1;\r\n}\r\nswitch (spectral_mode) {\r\ncase SPECTRAL_DISABLED:\r\nspec_priv->spec_config.enabled = 0;\r\nbreak;\r\ncase SPECTRAL_BACKGROUND:\r\nspec_priv->spec_config.endless = 1;\r\nspec_priv->spec_config.enabled = 1;\r\nbreak;\r\ncase SPECTRAL_CHANSCAN:\r\ncase SPECTRAL_MANUAL:\r\nspec_priv->spec_config.endless = 0;\r\nspec_priv->spec_config.enabled = 1;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nath_ps_ops(common)->wakeup(common);\r\nath9k_hw_ops(ah)->spectral_scan_config(ah, &spec_priv->spec_config);\r\nath_ps_ops(common)->restore(common);\r\nspec_priv->spectral_mode = spectral_mode;\r\nreturn 0;\r\n}\r\nstatic ssize_t write_file_spec_scan_ctl(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath_spec_scan_priv *spec_priv = file->private_data;\r\nstruct ath_common *common = ath9k_hw_common(spec_priv->ah);\r\nchar buf[32];\r\nssize_t len;\r\nif (IS_ENABLED(CONFIG_ATH9K_TX99))\r\nreturn -EOPNOTSUPP;\r\nlen = min(count, sizeof(buf) - 1);\r\nif (copy_from_user(buf, user_buf, len))\r\nreturn -EFAULT;\r\nbuf[len] = '\0';\r\nif (strncmp("trigger", buf, 7) == 0) {\r\nath9k_cmn_spectral_scan_trigger(common, spec_priv);\r\n} else if (strncmp("background", buf, 10) == 0) {\r\nath9k_cmn_spectral_scan_config(common, spec_priv, SPECTRAL_BACKGROUND);\r\nath_dbg(common, CONFIG, "spectral scan: background mode enabled\n");\r\n} else if (strncmp("chanscan", buf, 8) == 0) {\r\nath9k_cmn_spectral_scan_config(common, spec_priv, SPECTRAL_CHANSCAN);\r\nath_dbg(common, CONFIG, "spectral scan: channel scan mode enabled\n");\r\n} else if (strncmp("manual", buf, 6) == 0) {\r\nath9k_cmn_spectral_scan_config(common, spec_priv, SPECTRAL_MANUAL);\r\nath_dbg(common, CONFIG, "spectral scan: manual mode enabled\n");\r\n} else if (strncmp("disable", buf, 7) == 0) {\r\nath9k_cmn_spectral_scan_config(common, spec_priv, SPECTRAL_DISABLED);\r\nath_dbg(common, CONFIG, "spectral scan: disabled\n");\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t read_file_spectral_short_repeat(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath_spec_scan_priv *spec_priv = file->private_data;\r\nchar buf[32];\r\nunsigned int len;\r\nlen = sprintf(buf, "%d\n", spec_priv->spec_config.short_repeat);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\n}\r\nstatic ssize_t write_file_spectral_short_repeat(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath_spec_scan_priv *spec_priv = file->private_data;\r\nunsigned long val;\r\nchar buf[32];\r\nssize_t len;\r\nlen = min(count, sizeof(buf) - 1);\r\nif (copy_from_user(buf, user_buf, len))\r\nreturn -EFAULT;\r\nbuf[len] = '\0';\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nif (val > 1)\r\nreturn -EINVAL;\r\nspec_priv->spec_config.short_repeat = val;\r\nreturn count;\r\n}\r\nstatic ssize_t read_file_spectral_count(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath_spec_scan_priv *spec_priv = file->private_data;\r\nchar buf[32];\r\nunsigned int len;\r\nlen = sprintf(buf, "%d\n", spec_priv->spec_config.count);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\n}\r\nstatic ssize_t write_file_spectral_count(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath_spec_scan_priv *spec_priv = file->private_data;\r\nunsigned long val;\r\nchar buf[32];\r\nssize_t len;\r\nlen = min(count, sizeof(buf) - 1);\r\nif (copy_from_user(buf, user_buf, len))\r\nreturn -EFAULT;\r\nbuf[len] = '\0';\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nif (val > 255)\r\nreturn -EINVAL;\r\nspec_priv->spec_config.count = val;\r\nreturn count;\r\n}\r\nstatic ssize_t read_file_spectral_period(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath_spec_scan_priv *spec_priv = file->private_data;\r\nchar buf[32];\r\nunsigned int len;\r\nlen = sprintf(buf, "%d\n", spec_priv->spec_config.period);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\n}\r\nstatic ssize_t write_file_spectral_period(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath_spec_scan_priv *spec_priv = file->private_data;\r\nunsigned long val;\r\nchar buf[32];\r\nssize_t len;\r\nlen = min(count, sizeof(buf) - 1);\r\nif (copy_from_user(buf, user_buf, len))\r\nreturn -EFAULT;\r\nbuf[len] = '\0';\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nif (val > 255)\r\nreturn -EINVAL;\r\nspec_priv->spec_config.period = val;\r\nreturn count;\r\n}\r\nstatic ssize_t read_file_spectral_fft_period(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath_spec_scan_priv *spec_priv = file->private_data;\r\nchar buf[32];\r\nunsigned int len;\r\nlen = sprintf(buf, "%d\n", spec_priv->spec_config.fft_period);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\n}\r\nstatic ssize_t write_file_spectral_fft_period(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath_spec_scan_priv *spec_priv = file->private_data;\r\nunsigned long val;\r\nchar buf[32];\r\nssize_t len;\r\nlen = min(count, sizeof(buf) - 1);\r\nif (copy_from_user(buf, user_buf, len))\r\nreturn -EFAULT;\r\nbuf[len] = '\0';\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nif (val > 15)\r\nreturn -EINVAL;\r\nspec_priv->spec_config.fft_period = val;\r\nreturn count;\r\n}\r\nstatic struct dentry *create_buf_file_handler(const char *filename,\r\nstruct dentry *parent,\r\numode_t mode,\r\nstruct rchan_buf *buf,\r\nint *is_global)\r\n{\r\nstruct dentry *buf_file;\r\nbuf_file = debugfs_create_file(filename, mode, parent, buf,\r\n&relay_file_operations);\r\n*is_global = 1;\r\nreturn buf_file;\r\n}\r\nstatic int remove_buf_file_handler(struct dentry *dentry)\r\n{\r\ndebugfs_remove(dentry);\r\nreturn 0;\r\n}\r\nvoid ath9k_cmn_spectral_deinit_debug(struct ath_spec_scan_priv *spec_priv)\r\n{\r\nif (spec_priv->rfs_chan_spec_scan) {\r\nrelay_close(spec_priv->rfs_chan_spec_scan);\r\nspec_priv->rfs_chan_spec_scan = NULL;\r\n}\r\n}\r\nvoid ath9k_cmn_spectral_init_debug(struct ath_spec_scan_priv *spec_priv,\r\nstruct dentry *debugfs_phy)\r\n{\r\nspec_priv->rfs_chan_spec_scan = relay_open("spectral_scan",\r\ndebugfs_phy,\r\n1024, 256, &rfs_spec_scan_cb,\r\nNULL);\r\nif (!spec_priv->rfs_chan_spec_scan)\r\nreturn;\r\ndebugfs_create_file("spectral_scan_ctl",\r\nS_IRUSR | S_IWUSR,\r\ndebugfs_phy, spec_priv,\r\n&fops_spec_scan_ctl);\r\ndebugfs_create_file("spectral_short_repeat",\r\nS_IRUSR | S_IWUSR,\r\ndebugfs_phy, spec_priv,\r\n&fops_spectral_short_repeat);\r\ndebugfs_create_file("spectral_count",\r\nS_IRUSR | S_IWUSR,\r\ndebugfs_phy, spec_priv,\r\n&fops_spectral_count);\r\ndebugfs_create_file("spectral_period",\r\nS_IRUSR | S_IWUSR,\r\ndebugfs_phy, spec_priv,\r\n&fops_spectral_period);\r\ndebugfs_create_file("spectral_fft_period",\r\nS_IRUSR | S_IWUSR,\r\ndebugfs_phy, spec_priv,\r\n&fops_spectral_fft_period);\r\n}
