static void\r\nnv50_disp_mthd_list(struct nv50_disp *disp, int debug, u32 base, int c,\r\nconst struct nv50_disp_mthd_list *list, int inst)\r\n{\r\nstruct nvkm_subdev *subdev = &disp->base.engine.subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nint i;\r\nfor (i = 0; list->data[i].mthd; i++) {\r\nif (list->data[i].addr) {\r\nu32 next = nvkm_rd32(device, list->data[i].addr + base + 0);\r\nu32 prev = nvkm_rd32(device, list->data[i].addr + base + c);\r\nu32 mthd = list->data[i].mthd + (list->mthd * inst);\r\nconst char *name = list->data[i].name;\r\nchar mods[16];\r\nif (prev != next)\r\nsnprintf(mods, sizeof(mods), "-> %08x", next);\r\nelse\r\nsnprintf(mods, sizeof(mods), "%13c", ' ');\r\nnvkm_printk_(subdev, debug, info,\r\n"\t%04x: %08x %s%s%s\n",\r\nmthd, prev, mods, name ? " // " : "",\r\nname ? name : "");\r\n}\r\n}\r\n}\r\nvoid\r\nnv50_disp_chan_mthd(struct nv50_disp_chan *chan, int debug)\r\n{\r\nstruct nv50_disp *disp = chan->root->disp;\r\nstruct nvkm_subdev *subdev = &disp->base.engine.subdev;\r\nconst struct nv50_disp_chan_mthd *mthd = chan->mthd;\r\nconst struct nv50_disp_mthd_list *list;\r\nint i, j;\r\nif (debug > subdev->debug)\r\nreturn;\r\nfor (i = 0; (list = mthd->data[i].mthd) != NULL; i++) {\r\nu32 base = chan->head * mthd->addr;\r\nfor (j = 0; j < mthd->data[i].nr; j++, base += list->addr) {\r\nconst char *cname = mthd->name;\r\nconst char *sname = "";\r\nchar cname_[16], sname_[16];\r\nif (mthd->addr) {\r\nsnprintf(cname_, sizeof(cname_), "%s %d",\r\nmthd->name, chan->chid.user);\r\ncname = cname_;\r\n}\r\nif (mthd->data[i].nr > 1) {\r\nsnprintf(sname_, sizeof(sname_), " - %s %d",\r\nmthd->data[i].name, j);\r\nsname = sname_;\r\n}\r\nnvkm_printk_(subdev, debug, info, "%s%s:\n", cname, sname);\r\nnv50_disp_mthd_list(disp, debug, base, mthd->prev,\r\nlist, j);\r\n}\r\n}\r\n}\r\nstatic void\r\nnv50_disp_chan_uevent_fini(struct nvkm_event *event, int type, int index)\r\n{\r\nstruct nv50_disp *disp = container_of(event, typeof(*disp), uevent);\r\nstruct nvkm_device *device = disp->base.engine.subdev.device;\r\nnvkm_mask(device, 0x610028, 0x00000001 << index, 0x00000000 << index);\r\nnvkm_wr32(device, 0x610020, 0x00000001 << index);\r\n}\r\nstatic void\r\nnv50_disp_chan_uevent_init(struct nvkm_event *event, int types, int index)\r\n{\r\nstruct nv50_disp *disp = container_of(event, typeof(*disp), uevent);\r\nstruct nvkm_device *device = disp->base.engine.subdev.device;\r\nnvkm_wr32(device, 0x610020, 0x00000001 << index);\r\nnvkm_mask(device, 0x610028, 0x00000001 << index, 0x00000001 << index);\r\n}\r\nvoid\r\nnv50_disp_chan_uevent_send(struct nv50_disp *disp, int chid)\r\n{\r\nstruct nvif_notify_uevent_rep {\r\n} rep;\r\nnvkm_event_send(&disp->uevent, 1, chid, &rep, sizeof(rep));\r\n}\r\nint\r\nnv50_disp_chan_uevent_ctor(struct nvkm_object *object, void *data, u32 size,\r\nstruct nvkm_notify *notify)\r\n{\r\nstruct nv50_disp_chan *chan = nv50_disp_chan(object);\r\nunion {\r\nstruct nvif_notify_uevent_req none;\r\n} *args = data;\r\nint ret = -ENOSYS;\r\nif (!(ret = nvif_unvers(ret, &data, &size, args->none))) {\r\nnotify->size = sizeof(struct nvif_notify_uevent_rep);\r\nnotify->types = 1;\r\nnotify->index = chan->chid.user;\r\nreturn 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnv50_disp_chan_rd32(struct nvkm_object *object, u64 addr, u32 *data)\r\n{\r\nstruct nv50_disp_chan *chan = nv50_disp_chan(object);\r\nstruct nv50_disp *disp = chan->root->disp;\r\nstruct nvkm_device *device = disp->base.engine.subdev.device;\r\n*data = nvkm_rd32(device, 0x640000 + (chan->chid.user * 0x1000) + addr);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_disp_chan_wr32(struct nvkm_object *object, u64 addr, u32 data)\r\n{\r\nstruct nv50_disp_chan *chan = nv50_disp_chan(object);\r\nstruct nv50_disp *disp = chan->root->disp;\r\nstruct nvkm_device *device = disp->base.engine.subdev.device;\r\nnvkm_wr32(device, 0x640000 + (chan->chid.user * 0x1000) + addr, data);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_disp_chan_ntfy(struct nvkm_object *object, u32 type,\r\nstruct nvkm_event **pevent)\r\n{\r\nstruct nv50_disp_chan *chan = nv50_disp_chan(object);\r\nstruct nv50_disp *disp = chan->root->disp;\r\nswitch (type) {\r\ncase NV50_DISP_CORE_CHANNEL_DMA_V0_NTFY_UEVENT:\r\n*pevent = &disp->uevent;\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nnv50_disp_chan_map(struct nvkm_object *object, u64 *addr, u32 *size)\r\n{\r\nstruct nv50_disp_chan *chan = nv50_disp_chan(object);\r\nstruct nv50_disp *disp = chan->root->disp;\r\nstruct nvkm_device *device = disp->base.engine.subdev.device;\r\n*addr = device->func->resource_addr(device, 0) +\r\n0x640000 + (chan->chid.user * 0x1000);\r\n*size = 0x001000;\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_disp_chan_child_new(const struct nvkm_oclass *oclass,\r\nvoid *data, u32 size, struct nvkm_object **pobject)\r\n{\r\nstruct nv50_disp_chan *chan = nv50_disp_chan(oclass->parent);\r\nreturn chan->func->child_new(chan, oclass, data, size, pobject);\r\n}\r\nstatic int\r\nnv50_disp_chan_child_get(struct nvkm_object *object, int index,\r\nstruct nvkm_oclass *oclass)\r\n{\r\nstruct nv50_disp_chan *chan = nv50_disp_chan(object);\r\nif (chan->func->child_get) {\r\nint ret = chan->func->child_get(chan, index, oclass);\r\nif (ret == 0)\r\noclass->ctor = nv50_disp_chan_child_new;\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nnv50_disp_chan_fini(struct nvkm_object *object, bool suspend)\r\n{\r\nstruct nv50_disp_chan *chan = nv50_disp_chan(object);\r\nchan->func->fini(chan);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_disp_chan_init(struct nvkm_object *object)\r\n{\r\nstruct nv50_disp_chan *chan = nv50_disp_chan(object);\r\nreturn chan->func->init(chan);\r\n}\r\nstatic void *\r\nnv50_disp_chan_dtor(struct nvkm_object *object)\r\n{\r\nstruct nv50_disp_chan *chan = nv50_disp_chan(object);\r\nstruct nv50_disp *disp = chan->root->disp;\r\nif (chan->chid.user >= 0)\r\ndisp->chan[chan->chid.user] = NULL;\r\nreturn chan->func->dtor ? chan->func->dtor(chan) : chan;\r\n}\r\nint\r\nnv50_disp_chan_ctor(const struct nv50_disp_chan_func *func,\r\nconst struct nv50_disp_chan_mthd *mthd,\r\nstruct nv50_disp_root *root, int ctrl, int user, int head,\r\nconst struct nvkm_oclass *oclass,\r\nstruct nv50_disp_chan *chan)\r\n{\r\nstruct nv50_disp *disp = root->disp;\r\nnvkm_object_ctor(&nv50_disp_chan, oclass, &chan->object);\r\nchan->func = func;\r\nchan->mthd = mthd;\r\nchan->root = root;\r\nchan->chid.ctrl = ctrl;\r\nchan->chid.user = user;\r\nchan->head = head;\r\nif (disp->chan[chan->chid.user]) {\r\nchan->chid.user = -1;\r\nreturn -EBUSY;\r\n}\r\ndisp->chan[chan->chid.user] = chan;\r\nreturn 0;\r\n}\r\nint\r\nnv50_disp_chan_new_(const struct nv50_disp_chan_func *func,\r\nconst struct nv50_disp_chan_mthd *mthd,\r\nstruct nv50_disp_root *root, int ctrl, int user, int head,\r\nconst struct nvkm_oclass *oclass,\r\nstruct nvkm_object **pobject)\r\n{\r\nstruct nv50_disp_chan *chan;\r\nif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*pobject = &chan->object;\r\nreturn nv50_disp_chan_ctor(func, mthd, root, ctrl, user,\r\nhead, oclass, chan);\r\n}
