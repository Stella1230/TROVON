static inline bool radeon_has_atpx(void) { return false; }\r\nvoid radeon_driver_unload_kms(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (rdev == NULL)\r\nreturn;\r\nif (rdev->rmmio == NULL)\r\ngoto done_free;\r\nif (radeon_is_px(dev)) {\r\npm_runtime_get_sync(dev->dev);\r\npm_runtime_forbid(dev->dev);\r\n}\r\nradeon_kfd_device_fini(rdev);\r\nradeon_acpi_fini(rdev);\r\nradeon_modeset_fini(rdev);\r\nradeon_device_fini(rdev);\r\ndone_free:\r\nkfree(rdev);\r\ndev->dev_private = NULL;\r\n}\r\nint radeon_driver_load_kms(struct drm_device *dev, unsigned long flags)\r\n{\r\nstruct radeon_device *rdev;\r\nint r, acpi_status;\r\nif (!radeon_si_support) {\r\nswitch (flags & RADEON_FAMILY_MASK) {\r\ncase CHIP_TAHITI:\r\ncase CHIP_PITCAIRN:\r\ncase CHIP_VERDE:\r\ncase CHIP_OLAND:\r\ncase CHIP_HAINAN:\r\ndev_info(dev->dev,\r\n"SI support disabled by module param\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (!radeon_cik_support) {\r\nswitch (flags & RADEON_FAMILY_MASK) {\r\ncase CHIP_KAVERI:\r\ncase CHIP_BONAIRE:\r\ncase CHIP_HAWAII:\r\ncase CHIP_KABINI:\r\ncase CHIP_MULLINS:\r\ndev_info(dev->dev,\r\n"CIK support disabled by module param\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nrdev = kzalloc(sizeof(struct radeon_device), GFP_KERNEL);\r\nif (rdev == NULL) {\r\nreturn -ENOMEM;\r\n}\r\ndev->dev_private = (void *)rdev;\r\nif (pci_find_capability(dev->pdev, PCI_CAP_ID_AGP)) {\r\nflags |= RADEON_IS_AGP;\r\n} else if (pci_is_pcie(dev->pdev)) {\r\nflags |= RADEON_IS_PCIE;\r\n} else {\r\nflags |= RADEON_IS_PCI;\r\n}\r\nif ((radeon_runtime_pm != 0) &&\r\nradeon_has_atpx() &&\r\n((flags & RADEON_IS_IGP) == 0) &&\r\n!pci_is_thunderbolt_attached(dev->pdev))\r\nflags |= RADEON_IS_PX;\r\nr = radeon_device_init(rdev, dev, dev->pdev, flags);\r\nif (r) {\r\ndev_err(&dev->pdev->dev, "Fatal error during GPU init\n");\r\ngoto out;\r\n}\r\nr = radeon_modeset_init(rdev);\r\nif (r)\r\ndev_err(&dev->pdev->dev, "Fatal error during modeset init\n");\r\nif (!r) {\r\nacpi_status = radeon_acpi_init(rdev);\r\nif (acpi_status)\r\ndev_dbg(&dev->pdev->dev,\r\n"Error during ACPI methods call\n");\r\n}\r\nradeon_kfd_device_probe(rdev);\r\nradeon_kfd_device_init(rdev);\r\nif (radeon_is_px(dev)) {\r\npm_runtime_use_autosuspend(dev->dev);\r\npm_runtime_set_autosuspend_delay(dev->dev, 5000);\r\npm_runtime_set_active(dev->dev);\r\npm_runtime_allow(dev->dev);\r\npm_runtime_mark_last_busy(dev->dev);\r\npm_runtime_put_autosuspend(dev->dev);\r\n}\r\nout:\r\nif (r)\r\nradeon_driver_unload_kms(dev);\r\nreturn r;\r\n}\r\nstatic void radeon_set_filp_rights(struct drm_device *dev,\r\nstruct drm_file **owner,\r\nstruct drm_file *applier,\r\nuint32_t *value)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nmutex_lock(&rdev->gem.mutex);\r\nif (*value == 1) {\r\nif (!*owner)\r\n*owner = applier;\r\n} else if (*value == 0) {\r\nif (*owner == applier)\r\n*owner = NULL;\r\n}\r\n*value = *owner == applier ? 1 : 0;\r\nmutex_unlock(&rdev->gem.mutex);\r\n}\r\nstatic int radeon_info_ioctl(struct drm_device *dev, void *data, struct drm_file *filp)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct drm_radeon_info *info = data;\r\nstruct radeon_mode_info *minfo = &rdev->mode_info;\r\nuint32_t *value, value_tmp, *value_ptr, value_size;\r\nuint64_t value64;\r\nstruct drm_crtc *crtc;\r\nint i, found;\r\nvalue_ptr = (uint32_t *)((unsigned long)info->value);\r\nvalue = &value_tmp;\r\nvalue_size = sizeof(uint32_t);\r\nswitch (info->request) {\r\ncase RADEON_INFO_DEVICE_ID:\r\n*value = dev->pdev->device;\r\nbreak;\r\ncase RADEON_INFO_NUM_GB_PIPES:\r\n*value = rdev->num_gb_pipes;\r\nbreak;\r\ncase RADEON_INFO_NUM_Z_PIPES:\r\n*value = rdev->num_z_pipes;\r\nbreak;\r\ncase RADEON_INFO_ACCEL_WORKING:\r\nif ((rdev->family >= CHIP_CEDAR) && (rdev->family <= CHIP_HEMLOCK))\r\n*value = false;\r\nelse\r\n*value = rdev->accel_working;\r\nbreak;\r\ncase RADEON_INFO_CRTC_FROM_ID:\r\nif (copy_from_user(value, value_ptr, sizeof(uint32_t))) {\r\nDRM_ERROR("copy_from_user %s:%u\n", __func__, __LINE__);\r\nreturn -EFAULT;\r\n}\r\nfor (i = 0, found = 0; i < rdev->num_crtc; i++) {\r\ncrtc = (struct drm_crtc *)minfo->crtcs[i];\r\nif (crtc && crtc->base.id == *value) {\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\n*value = radeon_crtc->crtc_id;\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nDRM_DEBUG_KMS("unknown crtc id %d\n", *value);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_INFO_ACCEL_WORKING2:\r\nif (rdev->family == CHIP_HAWAII) {\r\nif (rdev->accel_working) {\r\nif (rdev->new_fw)\r\n*value = 3;\r\nelse\r\n*value = 2;\r\n} else {\r\n*value = 0;\r\n}\r\n} else {\r\n*value = rdev->accel_working;\r\n}\r\nbreak;\r\ncase RADEON_INFO_TILING_CONFIG:\r\nif (rdev->family >= CHIP_BONAIRE)\r\n*value = rdev->config.cik.tile_config;\r\nelse if (rdev->family >= CHIP_TAHITI)\r\n*value = rdev->config.si.tile_config;\r\nelse if (rdev->family >= CHIP_CAYMAN)\r\n*value = rdev->config.cayman.tile_config;\r\nelse if (rdev->family >= CHIP_CEDAR)\r\n*value = rdev->config.evergreen.tile_config;\r\nelse if (rdev->family >= CHIP_RV770)\r\n*value = rdev->config.rv770.tile_config;\r\nelse if (rdev->family >= CHIP_R600)\r\n*value = rdev->config.r600.tile_config;\r\nelse {\r\nDRM_DEBUG_KMS("tiling config is r6xx+ only!\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_INFO_WANT_HYPERZ:\r\nif (copy_from_user(value, value_ptr, sizeof(uint32_t))) {\r\nDRM_ERROR("copy_from_user %s:%u\n", __func__, __LINE__);\r\nreturn -EFAULT;\r\n}\r\nif (*value >= 2) {\r\nDRM_DEBUG_KMS("WANT_HYPERZ: invalid value %d\n", *value);\r\nreturn -EINVAL;\r\n}\r\nradeon_set_filp_rights(dev, &rdev->hyperz_filp, filp, value);\r\nbreak;\r\ncase RADEON_INFO_WANT_CMASK:\r\nif (copy_from_user(value, value_ptr, sizeof(uint32_t))) {\r\nDRM_ERROR("copy_from_user %s:%u\n", __func__, __LINE__);\r\nreturn -EFAULT;\r\n}\r\nif (*value >= 2) {\r\nDRM_DEBUG_KMS("WANT_CMASK: invalid value %d\n", *value);\r\nreturn -EINVAL;\r\n}\r\nradeon_set_filp_rights(dev, &rdev->cmask_filp, filp, value);\r\nbreak;\r\ncase RADEON_INFO_CLOCK_CRYSTAL_FREQ:\r\nif (rdev->asic->get_xclk)\r\n*value = radeon_get_xclk(rdev) * 10;\r\nelse\r\n*value = rdev->clock.spll.reference_freq * 10;\r\nbreak;\r\ncase RADEON_INFO_NUM_BACKENDS:\r\nif (rdev->family >= CHIP_BONAIRE)\r\n*value = rdev->config.cik.max_backends_per_se *\r\nrdev->config.cik.max_shader_engines;\r\nelse if (rdev->family >= CHIP_TAHITI)\r\n*value = rdev->config.si.max_backends_per_se *\r\nrdev->config.si.max_shader_engines;\r\nelse if (rdev->family >= CHIP_CAYMAN)\r\n*value = rdev->config.cayman.max_backends_per_se *\r\nrdev->config.cayman.max_shader_engines;\r\nelse if (rdev->family >= CHIP_CEDAR)\r\n*value = rdev->config.evergreen.max_backends;\r\nelse if (rdev->family >= CHIP_RV770)\r\n*value = rdev->config.rv770.max_backends;\r\nelse if (rdev->family >= CHIP_R600)\r\n*value = rdev->config.r600.max_backends;\r\nelse {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_INFO_NUM_TILE_PIPES:\r\nif (rdev->family >= CHIP_BONAIRE)\r\n*value = rdev->config.cik.max_tile_pipes;\r\nelse if (rdev->family >= CHIP_TAHITI)\r\n*value = rdev->config.si.max_tile_pipes;\r\nelse if (rdev->family >= CHIP_CAYMAN)\r\n*value = rdev->config.cayman.max_tile_pipes;\r\nelse if (rdev->family >= CHIP_CEDAR)\r\n*value = rdev->config.evergreen.max_tile_pipes;\r\nelse if (rdev->family >= CHIP_RV770)\r\n*value = rdev->config.rv770.max_tile_pipes;\r\nelse if (rdev->family >= CHIP_R600)\r\n*value = rdev->config.r600.max_tile_pipes;\r\nelse {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_INFO_FUSION_GART_WORKING:\r\n*value = 1;\r\nbreak;\r\ncase RADEON_INFO_BACKEND_MAP:\r\nif (rdev->family >= CHIP_BONAIRE)\r\n*value = rdev->config.cik.backend_map;\r\nelse if (rdev->family >= CHIP_TAHITI)\r\n*value = rdev->config.si.backend_map;\r\nelse if (rdev->family >= CHIP_CAYMAN)\r\n*value = rdev->config.cayman.backend_map;\r\nelse if (rdev->family >= CHIP_CEDAR)\r\n*value = rdev->config.evergreen.backend_map;\r\nelse if (rdev->family >= CHIP_RV770)\r\n*value = rdev->config.rv770.backend_map;\r\nelse if (rdev->family >= CHIP_R600)\r\n*value = rdev->config.r600.backend_map;\r\nelse {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_INFO_VA_START:\r\nif (rdev->family < CHIP_CAYMAN)\r\nreturn -EINVAL;\r\n*value = RADEON_VA_RESERVED_SIZE;\r\nbreak;\r\ncase RADEON_INFO_IB_VM_MAX_SIZE:\r\nif (rdev->family < CHIP_CAYMAN)\r\nreturn -EINVAL;\r\n*value = RADEON_IB_VM_MAX_SIZE;\r\nbreak;\r\ncase RADEON_INFO_MAX_PIPES:\r\nif (rdev->family >= CHIP_BONAIRE)\r\n*value = rdev->config.cik.max_cu_per_sh;\r\nelse if (rdev->family >= CHIP_TAHITI)\r\n*value = rdev->config.si.max_cu_per_sh;\r\nelse if (rdev->family >= CHIP_CAYMAN)\r\n*value = rdev->config.cayman.max_pipes_per_simd;\r\nelse if (rdev->family >= CHIP_CEDAR)\r\n*value = rdev->config.evergreen.max_pipes;\r\nelse if (rdev->family >= CHIP_RV770)\r\n*value = rdev->config.rv770.max_pipes;\r\nelse if (rdev->family >= CHIP_R600)\r\n*value = rdev->config.r600.max_pipes;\r\nelse {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_INFO_TIMESTAMP:\r\nif (rdev->family < CHIP_R600) {\r\nDRM_DEBUG_KMS("timestamp is r6xx+ only!\n");\r\nreturn -EINVAL;\r\n}\r\nvalue = (uint32_t*)&value64;\r\nvalue_size = sizeof(uint64_t);\r\nvalue64 = radeon_get_gpu_clock_counter(rdev);\r\nbreak;\r\ncase RADEON_INFO_MAX_SE:\r\nif (rdev->family >= CHIP_BONAIRE)\r\n*value = rdev->config.cik.max_shader_engines;\r\nelse if (rdev->family >= CHIP_TAHITI)\r\n*value = rdev->config.si.max_shader_engines;\r\nelse if (rdev->family >= CHIP_CAYMAN)\r\n*value = rdev->config.cayman.max_shader_engines;\r\nelse if (rdev->family >= CHIP_CEDAR)\r\n*value = rdev->config.evergreen.num_ses;\r\nelse\r\n*value = 1;\r\nbreak;\r\ncase RADEON_INFO_MAX_SH_PER_SE:\r\nif (rdev->family >= CHIP_BONAIRE)\r\n*value = rdev->config.cik.max_sh_per_se;\r\nelse if (rdev->family >= CHIP_TAHITI)\r\n*value = rdev->config.si.max_sh_per_se;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase RADEON_INFO_FASTFB_WORKING:\r\n*value = rdev->fastfb_working;\r\nbreak;\r\ncase RADEON_INFO_RING_WORKING:\r\nif (copy_from_user(value, value_ptr, sizeof(uint32_t))) {\r\nDRM_ERROR("copy_from_user %s:%u\n", __func__, __LINE__);\r\nreturn -EFAULT;\r\n}\r\nswitch (*value) {\r\ncase RADEON_CS_RING_GFX:\r\ncase RADEON_CS_RING_COMPUTE:\r\n*value = rdev->ring[RADEON_RING_TYPE_GFX_INDEX].ready;\r\nbreak;\r\ncase RADEON_CS_RING_DMA:\r\n*value = rdev->ring[R600_RING_TYPE_DMA_INDEX].ready;\r\n*value |= rdev->ring[CAYMAN_RING_TYPE_DMA1_INDEX].ready;\r\nbreak;\r\ncase RADEON_CS_RING_UVD:\r\n*value = rdev->ring[R600_RING_TYPE_UVD_INDEX].ready;\r\nbreak;\r\ncase RADEON_CS_RING_VCE:\r\n*value = rdev->ring[TN_RING_TYPE_VCE1_INDEX].ready;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_INFO_SI_TILE_MODE_ARRAY:\r\nif (rdev->family >= CHIP_BONAIRE) {\r\nvalue = rdev->config.cik.tile_mode_array;\r\nvalue_size = sizeof(uint32_t)*32;\r\n} else if (rdev->family >= CHIP_TAHITI) {\r\nvalue = rdev->config.si.tile_mode_array;\r\nvalue_size = sizeof(uint32_t)*32;\r\n} else {\r\nDRM_DEBUG_KMS("tile mode array is si+ only!\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_INFO_CIK_MACROTILE_MODE_ARRAY:\r\nif (rdev->family >= CHIP_BONAIRE) {\r\nvalue = rdev->config.cik.macrotile_mode_array;\r\nvalue_size = sizeof(uint32_t)*16;\r\n} else {\r\nDRM_DEBUG_KMS("macrotile mode array is cik+ only!\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_INFO_SI_CP_DMA_COMPUTE:\r\n*value = 1;\r\nbreak;\r\ncase RADEON_INFO_SI_BACKEND_ENABLED_MASK:\r\nif (rdev->family >= CHIP_BONAIRE) {\r\n*value = rdev->config.cik.backend_enable_mask;\r\n} else if (rdev->family >= CHIP_TAHITI) {\r\n*value = rdev->config.si.backend_enable_mask;\r\n} else {\r\nDRM_DEBUG_KMS("BACKEND_ENABLED_MASK is si+ only!\n");\r\n}\r\nbreak;\r\ncase RADEON_INFO_MAX_SCLK:\r\nif ((rdev->pm.pm_method == PM_METHOD_DPM) &&\r\nrdev->pm.dpm_enabled)\r\n*value = rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.sclk * 10;\r\nelse\r\n*value = rdev->pm.default_sclk * 10;\r\nbreak;\r\ncase RADEON_INFO_VCE_FW_VERSION:\r\n*value = rdev->vce.fw_version;\r\nbreak;\r\ncase RADEON_INFO_VCE_FB_VERSION:\r\n*value = rdev->vce.fb_version;\r\nbreak;\r\ncase RADEON_INFO_NUM_BYTES_MOVED:\r\nvalue = (uint32_t*)&value64;\r\nvalue_size = sizeof(uint64_t);\r\nvalue64 = atomic64_read(&rdev->num_bytes_moved);\r\nbreak;\r\ncase RADEON_INFO_VRAM_USAGE:\r\nvalue = (uint32_t*)&value64;\r\nvalue_size = sizeof(uint64_t);\r\nvalue64 = atomic64_read(&rdev->vram_usage);\r\nbreak;\r\ncase RADEON_INFO_GTT_USAGE:\r\nvalue = (uint32_t*)&value64;\r\nvalue_size = sizeof(uint64_t);\r\nvalue64 = atomic64_read(&rdev->gtt_usage);\r\nbreak;\r\ncase RADEON_INFO_ACTIVE_CU_COUNT:\r\nif (rdev->family >= CHIP_BONAIRE)\r\n*value = rdev->config.cik.active_cus;\r\nelse if (rdev->family >= CHIP_TAHITI)\r\n*value = rdev->config.si.active_cus;\r\nelse if (rdev->family >= CHIP_CAYMAN)\r\n*value = rdev->config.cayman.active_simds;\r\nelse if (rdev->family >= CHIP_CEDAR)\r\n*value = rdev->config.evergreen.active_simds;\r\nelse if (rdev->family >= CHIP_RV770)\r\n*value = rdev->config.rv770.active_simds;\r\nelse if (rdev->family >= CHIP_R600)\r\n*value = rdev->config.r600.active_simds;\r\nelse\r\n*value = 1;\r\nbreak;\r\ncase RADEON_INFO_CURRENT_GPU_TEMP:\r\nif (rdev->asic->pm.get_temperature)\r\n*value = radeon_get_temperature(rdev);\r\nelse\r\n*value = 0;\r\nbreak;\r\ncase RADEON_INFO_CURRENT_GPU_SCLK:\r\nif (rdev->pm.dpm_enabled)\r\n*value = radeon_dpm_get_current_sclk(rdev) / 100;\r\nelse\r\n*value = rdev->pm.current_sclk / 100;\r\nbreak;\r\ncase RADEON_INFO_CURRENT_GPU_MCLK:\r\nif (rdev->pm.dpm_enabled)\r\n*value = radeon_dpm_get_current_mclk(rdev) / 100;\r\nelse\r\n*value = rdev->pm.current_mclk / 100;\r\nbreak;\r\ncase RADEON_INFO_READ_REG:\r\nif (copy_from_user(value, value_ptr, sizeof(uint32_t))) {\r\nDRM_ERROR("copy_from_user %s:%u\n", __func__, __LINE__);\r\nreturn -EFAULT;\r\n}\r\nif (radeon_get_allowed_info_register(rdev, *value, value))\r\nreturn -EINVAL;\r\nbreak;\r\ncase RADEON_INFO_VA_UNMAP_WORKING:\r\n*value = true;\r\nbreak;\r\ncase RADEON_INFO_GPU_RESET_COUNTER:\r\n*value = atomic_read(&rdev->gpu_reset_counter);\r\nbreak;\r\ndefault:\r\nDRM_DEBUG_KMS("Invalid request %d\n", info->request);\r\nreturn -EINVAL;\r\n}\r\nif (copy_to_user(value_ptr, (char*)value, value_size)) {\r\nDRM_ERROR("copy_to_user %s:%u\n", __func__, __LINE__);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nvoid radeon_driver_lastclose_kms(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nradeon_fbdev_restore_mode(rdev);\r\nvga_switcheroo_process_delayed_switch();\r\n}\r\nint radeon_driver_open_kms(struct drm_device *dev, struct drm_file *file_priv)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint r;\r\nfile_priv->driver_priv = NULL;\r\nr = pm_runtime_get_sync(dev->dev);\r\nif (r < 0)\r\nreturn r;\r\nif (rdev->family >= CHIP_CAYMAN) {\r\nstruct radeon_fpriv *fpriv;\r\nstruct radeon_vm *vm;\r\nfpriv = kzalloc(sizeof(*fpriv), GFP_KERNEL);\r\nif (unlikely(!fpriv)) {\r\nr = -ENOMEM;\r\ngoto out_suspend;\r\n}\r\nif (rdev->accel_working) {\r\nvm = &fpriv->vm;\r\nr = radeon_vm_init(rdev, vm);\r\nif (r) {\r\nkfree(fpriv);\r\ngoto out_suspend;\r\n}\r\nr = radeon_bo_reserve(rdev->ring_tmp_bo.bo, false);\r\nif (r) {\r\nradeon_vm_fini(rdev, vm);\r\nkfree(fpriv);\r\ngoto out_suspend;\r\n}\r\nvm->ib_bo_va = radeon_vm_bo_add(rdev, vm,\r\nrdev->ring_tmp_bo.bo);\r\nr = radeon_vm_bo_set_addr(rdev, vm->ib_bo_va,\r\nRADEON_VA_IB_OFFSET,\r\nRADEON_VM_PAGE_READABLE |\r\nRADEON_VM_PAGE_SNOOPED);\r\nif (r) {\r\nradeon_vm_fini(rdev, vm);\r\nkfree(fpriv);\r\ngoto out_suspend;\r\n}\r\n}\r\nfile_priv->driver_priv = fpriv;\r\n}\r\nout_suspend:\r\npm_runtime_mark_last_busy(dev->dev);\r\npm_runtime_put_autosuspend(dev->dev);\r\nreturn r;\r\n}\r\nvoid radeon_driver_postclose_kms(struct drm_device *dev,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\npm_runtime_get_sync(dev->dev);\r\nmutex_lock(&rdev->gem.mutex);\r\nif (rdev->hyperz_filp == file_priv)\r\nrdev->hyperz_filp = NULL;\r\nif (rdev->cmask_filp == file_priv)\r\nrdev->cmask_filp = NULL;\r\nmutex_unlock(&rdev->gem.mutex);\r\nradeon_uvd_free_handles(rdev, file_priv);\r\nradeon_vce_free_handles(rdev, file_priv);\r\nif (rdev->family >= CHIP_CAYMAN && file_priv->driver_priv) {\r\nstruct radeon_fpriv *fpriv = file_priv->driver_priv;\r\nstruct radeon_vm *vm = &fpriv->vm;\r\nint r;\r\nif (rdev->accel_working) {\r\nr = radeon_bo_reserve(rdev->ring_tmp_bo.bo, false);\r\nif (!r) {\r\nif (vm->ib_bo_va)\r\nradeon_vm_bo_rmv(rdev, vm->ib_bo_va);\r\nradeon_bo_unreserve(rdev->ring_tmp_bo.bo);\r\n}\r\nradeon_vm_fini(rdev, vm);\r\n}\r\nkfree(fpriv);\r\nfile_priv->driver_priv = NULL;\r\n}\r\npm_runtime_mark_last_busy(dev->dev);\r\npm_runtime_put_autosuspend(dev->dev);\r\n}\r\nu32 radeon_get_vblank_counter_kms(struct drm_device *dev, unsigned int pipe)\r\n{\r\nint vpos, hpos, stat;\r\nu32 count;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (pipe >= rdev->num_crtc) {\r\nDRM_ERROR("Invalid crtc %u\n", pipe);\r\nreturn -EINVAL;\r\n}\r\nif (rdev->mode_info.crtcs[pipe]) {\r\ndo {\r\ncount = radeon_get_vblank_counter(rdev, pipe);\r\nstat = radeon_get_crtc_scanoutpos(\r\ndev, pipe, GET_DISTANCE_TO_VBLANKSTART,\r\n&vpos, &hpos, NULL, NULL,\r\n&rdev->mode_info.crtcs[pipe]->base.hwmode);\r\n} while (count != radeon_get_vblank_counter(rdev, pipe));\r\nif (((stat & (DRM_SCANOUTPOS_VALID | DRM_SCANOUTPOS_ACCURATE)) !=\r\n(DRM_SCANOUTPOS_VALID | DRM_SCANOUTPOS_ACCURATE))) {\r\nDRM_DEBUG_VBL("Query failed! stat %d\n", stat);\r\n}\r\nelse {\r\nDRM_DEBUG_VBL("crtc %u: dist from vblank start %d\n",\r\npipe, vpos);\r\nif (vpos >= 0)\r\ncount++;\r\n}\r\n}\r\nelse {\r\ncount = radeon_get_vblank_counter(rdev, pipe);\r\nDRM_DEBUG_VBL("NULL mode info! Returned count may be wrong.\n");\r\n}\r\nreturn count;\r\n}\r\nint radeon_enable_vblank_kms(struct drm_device *dev, int crtc)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nunsigned long irqflags;\r\nint r;\r\nif (crtc < 0 || crtc >= rdev->num_crtc) {\r\nDRM_ERROR("Invalid crtc %d\n", crtc);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&rdev->irq.lock, irqflags);\r\nrdev->irq.crtc_vblank_int[crtc] = true;\r\nr = radeon_irq_set(rdev);\r\nspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\r\nreturn r;\r\n}\r\nvoid radeon_disable_vblank_kms(struct drm_device *dev, int crtc)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nunsigned long irqflags;\r\nif (crtc < 0 || crtc >= rdev->num_crtc) {\r\nDRM_ERROR("Invalid crtc %d\n", crtc);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&rdev->irq.lock, irqflags);\r\nrdev->irq.crtc_vblank_int[crtc] = false;\r\nradeon_irq_set(rdev);\r\nspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\r\n}
