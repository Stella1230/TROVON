int gre_add_protocol(const struct gre_protocol *proto, u8 version)\r\n{\r\nif (version >= GREPROTO_MAX)\r\nreturn -EINVAL;\r\nreturn (cmpxchg((const struct gre_protocol **)&gre_proto[version], NULL, proto) == NULL) ?\r\n0 : -EBUSY;\r\n}\r\nint gre_del_protocol(const struct gre_protocol *proto, u8 version)\r\n{\r\nint ret;\r\nif (version >= GREPROTO_MAX)\r\nreturn -EINVAL;\r\nret = (cmpxchg((const struct gre_protocol **)&gre_proto[version], proto, NULL) == proto) ?\r\n0 : -EBUSY;\r\nif (ret)\r\nreturn ret;\r\nsynchronize_rcu();\r\nreturn 0;\r\n}\r\nint gre_parse_header(struct sk_buff *skb, struct tnl_ptk_info *tpi,\r\nbool *csum_err, __be16 proto, int nhs)\r\n{\r\nconst struct gre_base_hdr *greh;\r\n__be32 *options;\r\nint hdr_len;\r\nif (unlikely(!pskb_may_pull(skb, nhs + sizeof(struct gre_base_hdr))))\r\nreturn -EINVAL;\r\ngreh = (struct gre_base_hdr *)(skb->data + nhs);\r\nif (unlikely(greh->flags & (GRE_VERSION | GRE_ROUTING)))\r\nreturn -EINVAL;\r\ntpi->flags = gre_flags_to_tnl_flags(greh->flags);\r\nhdr_len = gre_calc_hlen(tpi->flags);\r\nif (!pskb_may_pull(skb, nhs + hdr_len))\r\nreturn -EINVAL;\r\ngreh = (struct gre_base_hdr *)(skb->data + nhs);\r\ntpi->proto = greh->protocol;\r\noptions = (__be32 *)(greh + 1);\r\nif (greh->flags & GRE_CSUM) {\r\nif (skb_checksum_simple_validate(skb)) {\r\n*csum_err = true;\r\nreturn -EINVAL;\r\n}\r\nskb_checksum_try_convert(skb, IPPROTO_GRE, 0,\r\nnull_compute_pseudo);\r\noptions++;\r\n}\r\nif (greh->flags & GRE_KEY) {\r\ntpi->key = *options;\r\noptions++;\r\n} else {\r\ntpi->key = 0;\r\n}\r\nif (unlikely(greh->flags & GRE_SEQ)) {\r\ntpi->seq = *options;\r\noptions++;\r\n} else {\r\ntpi->seq = 0;\r\n}\r\nif (greh->flags == 0 && tpi->proto == htons(ETH_P_WCCP)) {\r\ntpi->proto = proto;\r\nif ((*(u8 *)options & 0xF0) != 0x40)\r\nhdr_len += 4;\r\n}\r\ntpi->hdr_len = hdr_len;\r\nreturn hdr_len;\r\n}\r\nstatic int gre_rcv(struct sk_buff *skb)\r\n{\r\nconst struct gre_protocol *proto;\r\nu8 ver;\r\nint ret;\r\nif (!pskb_may_pull(skb, 12))\r\ngoto drop;\r\nver = skb->data[1]&0x7f;\r\nif (ver >= GREPROTO_MAX)\r\ngoto drop;\r\nrcu_read_lock();\r\nproto = rcu_dereference(gre_proto[ver]);\r\nif (!proto || !proto->handler)\r\ngoto drop_unlock;\r\nret = proto->handler(skb);\r\nrcu_read_unlock();\r\nreturn ret;\r\ndrop_unlock:\r\nrcu_read_unlock();\r\ndrop:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic void gre_err(struct sk_buff *skb, u32 info)\r\n{\r\nconst struct gre_protocol *proto;\r\nconst struct iphdr *iph = (const struct iphdr *)skb->data;\r\nu8 ver = skb->data[(iph->ihl<<2) + 1]&0x7f;\r\nif (ver >= GREPROTO_MAX)\r\nreturn;\r\nrcu_read_lock();\r\nproto = rcu_dereference(gre_proto[ver]);\r\nif (proto && proto->err_handler)\r\nproto->err_handler(skb, info);\r\nrcu_read_unlock();\r\n}\r\nstatic int __init gre_init(void)\r\n{\r\npr_info("GRE over IPv4 demultiplexor driver\n");\r\nif (inet_add_protocol(&net_gre_protocol, IPPROTO_GRE) < 0) {\r\npr_err("can't add protocol\n");\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit gre_exit(void)\r\n{\r\ninet_del_protocol(&net_gre_protocol, IPPROTO_GRE);\r\n}
