static int m25p80_read_reg(struct spi_nor *nor, u8 code, u8 *val, int len)\r\n{\r\nstruct m25p *flash = nor->priv;\r\nstruct spi_device *spi = flash->spi;\r\nint ret;\r\nret = spi_write_then_read(spi, &code, 1, val, len);\r\nif (ret < 0)\r\ndev_err(&spi->dev, "error %d reading %x\n", ret, code);\r\nreturn ret;\r\n}\r\nstatic void m25p_addr2cmd(struct spi_nor *nor, unsigned int addr, u8 *cmd)\r\n{\r\ncmd[1] = addr >> (nor->addr_width * 8 - 8);\r\ncmd[2] = addr >> (nor->addr_width * 8 - 16);\r\ncmd[3] = addr >> (nor->addr_width * 8 - 24);\r\ncmd[4] = addr >> (nor->addr_width * 8 - 32);\r\n}\r\nstatic int m25p_cmdsz(struct spi_nor *nor)\r\n{\r\nreturn 1 + nor->addr_width;\r\n}\r\nstatic int m25p80_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\r\n{\r\nstruct m25p *flash = nor->priv;\r\nstruct spi_device *spi = flash->spi;\r\nflash->command[0] = opcode;\r\nif (buf)\r\nmemcpy(&flash->command[1], buf, len);\r\nreturn spi_write(spi, flash->command, len + 1);\r\n}\r\nstatic ssize_t m25p80_write(struct spi_nor *nor, loff_t to, size_t len,\r\nconst u_char *buf)\r\n{\r\nstruct m25p *flash = nor->priv;\r\nstruct spi_device *spi = flash->spi;\r\nunsigned int inst_nbits, addr_nbits, data_nbits, data_idx;\r\nstruct spi_transfer t[3] = {};\r\nstruct spi_message m;\r\nint cmd_sz = m25p_cmdsz(nor);\r\nssize_t ret;\r\ninst_nbits = spi_nor_get_protocol_inst_nbits(nor->write_proto);\r\naddr_nbits = spi_nor_get_protocol_addr_nbits(nor->write_proto);\r\ndata_nbits = spi_nor_get_protocol_data_nbits(nor->write_proto);\r\nspi_message_init(&m);\r\nif (nor->program_opcode == SPINOR_OP_AAI_WP && nor->sst_write_second)\r\ncmd_sz = 1;\r\nflash->command[0] = nor->program_opcode;\r\nm25p_addr2cmd(nor, to, flash->command);\r\nt[0].tx_buf = flash->command;\r\nt[0].tx_nbits = inst_nbits;\r\nt[0].len = cmd_sz;\r\nspi_message_add_tail(&t[0], &m);\r\ndata_idx = 1;\r\nif (addr_nbits != inst_nbits) {\r\nt[0].len = 1;\r\nt[1].tx_buf = &flash->command[1];\r\nt[1].tx_nbits = addr_nbits;\r\nt[1].len = cmd_sz - 1;\r\nspi_message_add_tail(&t[1], &m);\r\ndata_idx = 2;\r\n}\r\nt[data_idx].tx_buf = buf;\r\nt[data_idx].tx_nbits = data_nbits;\r\nt[data_idx].len = len;\r\nspi_message_add_tail(&t[data_idx], &m);\r\nret = spi_sync(spi, &m);\r\nif (ret)\r\nreturn ret;\r\nret = m.actual_length - cmd_sz;\r\nif (ret < 0)\r\nreturn -EIO;\r\nreturn ret;\r\n}\r\nstatic ssize_t m25p80_read(struct spi_nor *nor, loff_t from, size_t len,\r\nu_char *buf)\r\n{\r\nstruct m25p *flash = nor->priv;\r\nstruct spi_device *spi = flash->spi;\r\nunsigned int inst_nbits, addr_nbits, data_nbits, data_idx;\r\nstruct spi_transfer t[3];\r\nstruct spi_message m;\r\nunsigned int dummy = nor->read_dummy;\r\nssize_t ret;\r\nint cmd_sz;\r\ninst_nbits = spi_nor_get_protocol_inst_nbits(nor->read_proto);\r\naddr_nbits = spi_nor_get_protocol_addr_nbits(nor->read_proto);\r\ndata_nbits = spi_nor_get_protocol_data_nbits(nor->read_proto);\r\ndummy = (dummy * addr_nbits) / 8;\r\nif (spi_flash_read_supported(spi)) {\r\nstruct spi_flash_read_message msg;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.buf = buf;\r\nmsg.from = from;\r\nmsg.len = len;\r\nmsg.read_opcode = nor->read_opcode;\r\nmsg.addr_width = nor->addr_width;\r\nmsg.dummy_bytes = dummy;\r\nmsg.opcode_nbits = inst_nbits;\r\nmsg.addr_nbits = addr_nbits;\r\nmsg.data_nbits = data_nbits;\r\nret = spi_flash_read(spi, &msg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn msg.retlen;\r\n}\r\nspi_message_init(&m);\r\nmemset(t, 0, (sizeof t));\r\nflash->command[0] = nor->read_opcode;\r\nm25p_addr2cmd(nor, from, flash->command);\r\nt[0].tx_buf = flash->command;\r\nt[0].tx_nbits = inst_nbits;\r\nt[0].len = m25p_cmdsz(nor) + dummy;\r\nspi_message_add_tail(&t[0], &m);\r\ncmd_sz = t[0].len;\r\nmemset(flash->command + cmd_sz - dummy, 0xff, dummy);\r\ndata_idx = 1;\r\nif (addr_nbits != inst_nbits) {\r\nt[0].len = 1;\r\nt[1].tx_buf = &flash->command[1];\r\nt[1].tx_nbits = addr_nbits;\r\nt[1].len = cmd_sz - 1;\r\nspi_message_add_tail(&t[1], &m);\r\ndata_idx = 2;\r\n}\r\nt[data_idx].rx_buf = buf;\r\nt[data_idx].rx_nbits = data_nbits;\r\nt[data_idx].len = min3(len, spi_max_transfer_size(spi),\r\nspi_max_message_size(spi) - cmd_sz);\r\nspi_message_add_tail(&t[data_idx], &m);\r\nret = spi_sync(spi, &m);\r\nif (ret)\r\nreturn ret;\r\nret = m.actual_length - cmd_sz;\r\nif (ret < 0)\r\nreturn -EIO;\r\nreturn ret;\r\n}\r\nstatic int m25p_probe(struct spi_device *spi)\r\n{\r\nstruct flash_platform_data *data;\r\nstruct m25p *flash;\r\nstruct spi_nor *nor;\r\nstruct spi_nor_hwcaps hwcaps = {\r\n.mask = SNOR_HWCAPS_READ |\r\nSNOR_HWCAPS_READ_FAST |\r\nSNOR_HWCAPS_PP,\r\n};\r\nchar *flash_name;\r\nint ret;\r\ndata = dev_get_platdata(&spi->dev);\r\nflash = devm_kzalloc(&spi->dev, sizeof(*flash), GFP_KERNEL);\r\nif (!flash)\r\nreturn -ENOMEM;\r\nnor = &flash->spi_nor;\r\nnor->read = m25p80_read;\r\nnor->write = m25p80_write;\r\nnor->write_reg = m25p80_write_reg;\r\nnor->read_reg = m25p80_read_reg;\r\nnor->dev = &spi->dev;\r\nspi_nor_set_flash_node(nor, spi->dev.of_node);\r\nnor->priv = flash;\r\nspi_set_drvdata(spi, flash);\r\nflash->spi = spi;\r\nif (spi->mode & SPI_RX_QUAD) {\r\nhwcaps.mask |= SNOR_HWCAPS_READ_1_1_4;\r\nif (spi->mode & SPI_TX_QUAD)\r\nhwcaps.mask |= (SNOR_HWCAPS_READ_1_4_4 |\r\nSNOR_HWCAPS_PP_1_1_4 |\r\nSNOR_HWCAPS_PP_1_4_4);\r\n} else if (spi->mode & SPI_RX_DUAL) {\r\nhwcaps.mask |= SNOR_HWCAPS_READ_1_1_2;\r\nif (spi->mode & SPI_TX_DUAL)\r\nhwcaps.mask |= SNOR_HWCAPS_READ_1_2_2;\r\n}\r\nif (data && data->name)\r\nnor->mtd.name = data->name;\r\nif (data && data->type)\r\nflash_name = data->type;\r\nelse if (!strcmp(spi->modalias, "spi-nor"))\r\nflash_name = NULL;\r\nelse\r\nflash_name = spi->modalias;\r\nret = spi_nor_scan(nor, flash_name, &hwcaps);\r\nif (ret)\r\nreturn ret;\r\nreturn mtd_device_register(&nor->mtd, data ? data->parts : NULL,\r\ndata ? data->nr_parts : 0);\r\n}\r\nstatic int m25p_remove(struct spi_device *spi)\r\n{\r\nstruct m25p *flash = spi_get_drvdata(spi);\r\nreturn mtd_device_unregister(&flash->spi_nor.mtd);\r\n}
