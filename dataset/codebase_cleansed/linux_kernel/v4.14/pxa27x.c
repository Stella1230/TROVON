void pxa27x_clear_otgph(void)\r\n{\r\nif (cpu_is_pxa27x() && (PSSR & PSSR_OTGPH))\r\nPSSR |= PSSR_OTGPH;\r\n}\r\nvoid pxa27x_configure_ac97reset(int reset_gpio, bool to_gpio)\r\n{\r\nif (reset_gpio == 113)\r\npxa2xx_mfp_config(to_gpio ? &ac97_reset_config[0] :\r\n&ac97_reset_config[1], 1);\r\nif (reset_gpio == 95)\r\npxa2xx_mfp_config(to_gpio ? &ac97_reset_config[2] :\r\n&ac97_reset_config[3], 1);\r\n}\r\nint pxa27x_set_pwrmode(unsigned int mode)\r\n{\r\nswitch (mode) {\r\ncase PWRMODE_SLEEP:\r\ncase PWRMODE_DEEPSLEEP:\r\npwrmode = mode;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid pxa27x_cpu_pm_save(unsigned long *sleep_save)\r\n{\r\nsleep_save[SLEEP_SAVE_MDREFR] = __raw_readl(MDREFR);\r\nSAVE(PCFR);\r\nSAVE(PSTR);\r\n}\r\nvoid pxa27x_cpu_pm_restore(unsigned long *sleep_save)\r\n{\r\n__raw_writel(sleep_save[SLEEP_SAVE_MDREFR], MDREFR);\r\nRESTORE(PCFR);\r\nPSSR = PSSR_RDH | PSSR_PH;\r\nRESTORE(PSTR);\r\n}\r\nvoid pxa27x_cpu_pm_enter(suspend_state_t state)\r\n{\r\nextern void pxa_cpu_standby(void);\r\n#ifndef CONFIG_IWMMXT\r\nu64 acc0;\r\nasm volatile(".arch_extension xscale\n\t"\r\n"mra %Q0, %R0, acc0" : "=r" (acc0));\r\n#endif\r\nPCFR &= ~PCFR_FVC;\r\nPEDR = 0xDF12FE1B;\r\nRCSR = RCSR_HWR | RCSR_WDR | RCSR_SMR | RCSR_GPR;\r\nswitch (state) {\r\ncase PM_SUSPEND_STANDBY:\r\npxa_cpu_standby();\r\nbreak;\r\ncase PM_SUSPEND_MEM:\r\ncpu_suspend(pwrmode, pxa27x_finish_suspend);\r\n#ifndef CONFIG_IWMMXT\r\nasm volatile(".arch_extension xscale\n\t"\r\n"mar acc0, %Q0, %R0" : "=r" (acc0));\r\n#endif\r\nbreak;\r\n}\r\n}\r\nstatic int pxa27x_cpu_pm_valid(suspend_state_t state)\r\n{\r\nreturn state == PM_SUSPEND_MEM || state == PM_SUSPEND_STANDBY;\r\n}\r\nstatic int pxa27x_cpu_pm_prepare(void)\r\n{\r\nPSPR = __pa_symbol(cpu_resume);\r\nreturn 0;\r\n}\r\nstatic void pxa27x_cpu_pm_finish(void)\r\n{\r\nPSPR = 0;\r\n}\r\nstatic void __init pxa27x_init_pm(void)\r\n{\r\npxa_cpu_pm_fns = &pxa27x_cpu_pm_fns;\r\n}\r\nstatic inline void pxa27x_init_pm(void) {}\r\nstatic int pxa27x_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nint gpio = pxa_irq_to_gpio(d->irq);\r\nuint32_t mask;\r\nif (gpio >= 0 && gpio < 128)\r\nreturn gpio_set_wake(gpio, on);\r\nif (d->irq == IRQ_KEYPAD)\r\nreturn keypad_set_wake(on);\r\nswitch (d->irq) {\r\ncase IRQ_RTCAlrm:\r\nmask = PWER_RTC;\r\nbreak;\r\ncase IRQ_USB:\r\nmask = 1u << 26;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (on)\r\nPWER |= mask;\r\nelse\r\nPWER &=~mask;\r\nreturn 0;\r\n}\r\nvoid __init pxa27x_init_irq(void)\r\n{\r\npxa_init_irq(34, pxa27x_set_wake);\r\n}\r\nstatic int __init\r\npxa27x_dt_init_irq(struct device_node *node, struct device_node *parent)\r\n{\r\npxa_dt_irq_init(pxa27x_set_wake);\r\nset_handle_irq(ichp_handle_irq);\r\nreturn 0;\r\n}\r\nvoid __init pxa27x_map_io(void)\r\n{\r\npxa_map_io();\r\niotable_init(ARRAY_AND_SIZE(pxa27x_io_desc));\r\npxa27x_get_clk_frequency_khz(1);\r\n}\r\nvoid __init pxa27x_set_i2c_power_info(struct i2c_pxa_platform_data *info)\r\n{\r\nlocal_irq_disable();\r\nPCFR |= PCFR_PI2CEN;\r\nlocal_irq_enable();\r\npxa_register_device(&pxa27x_device_i2c_power, info);\r\n}\r\nstatic int __init pxa27x_init(void)\r\n{\r\nint ret = 0;\r\nif (cpu_is_pxa27x()) {\r\nreset_status = RCSR;\r\npxa27x_init_pm();\r\nregister_syscore_ops(&pxa_irq_syscore_ops);\r\nregister_syscore_ops(&pxa2xx_mfp_syscore_ops);\r\nif (!of_have_populated_dt()) {\r\npxa_register_device(&pxa27x_device_gpio,\r\n&pxa27x_gpio_info);\r\npxa2xx_set_dmac_info(32, 75);\r\nret = platform_add_devices(devices,\r\nARRAY_SIZE(devices));\r\n}\r\n}\r\nreturn ret;\r\n}
