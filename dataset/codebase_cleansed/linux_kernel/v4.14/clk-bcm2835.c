static inline void cprman_write(struct bcm2835_cprman *cprman, u32 reg, u32 val)\r\n{\r\nwritel(CM_PASSWORD | val, cprman->regs + reg);\r\n}\r\nstatic inline u32 cprman_read(struct bcm2835_cprman *cprman, u32 reg)\r\n{\r\nreturn readl(cprman->regs + reg);\r\n}\r\nstatic unsigned long bcm2835_measure_tcnt_mux(struct bcm2835_cprman *cprman,\r\nu32 tcnt_mux)\r\n{\r\nu32 osccount = 19200;\r\nu32 count;\r\nktime_t timeout;\r\nspin_lock(&cprman->regs_lock);\r\ncprman_write(cprman, CM_TCNTCTL, CM_KILL);\r\ncprman_write(cprman, CM_TCNTCTL,\r\n(tcnt_mux & CM_SRC_MASK) |\r\n(tcnt_mux >> CM_SRC_BITS) << CM_TCNT_SRC1_SHIFT);\r\ncprman_write(cprman, CM_OSCCOUNT, osccount);\r\nmdelay(1);\r\ntimeout = ktime_add_ns(ktime_get(), LOCK_TIMEOUT_NS);\r\nwhile (cprman_read(cprman, CM_OSCCOUNT)) {\r\nif (ktime_after(ktime_get(), timeout)) {\r\ndev_err(cprman->dev, "timeout waiting for OSCCOUNT\n");\r\ncount = 0;\r\ngoto out;\r\n}\r\ncpu_relax();\r\n}\r\ntimeout = ktime_add_ns(ktime_get(), LOCK_TIMEOUT_NS);\r\nwhile (cprman_read(cprman, CM_TCNTCTL) & CM_BUSY) {\r\nif (ktime_after(ktime_get(), timeout)) {\r\ndev_err(cprman->dev, "timeout waiting for !BUSY\n");\r\ncount = 0;\r\ngoto out;\r\n}\r\ncpu_relax();\r\n}\r\ncount = cprman_read(cprman, CM_TCNTCNT);\r\ncprman_write(cprman, CM_TCNTCTL, 0);\r\nout:\r\nspin_unlock(&cprman->regs_lock);\r\nreturn count * 1000;\r\n}\r\nstatic int bcm2835_debugfs_regset(struct bcm2835_cprman *cprman, u32 base,\r\nstruct debugfs_reg32 *regs, size_t nregs,\r\nstruct dentry *dentry)\r\n{\r\nstruct dentry *regdump;\r\nstruct debugfs_regset32 *regset;\r\nregset = devm_kzalloc(cprman->dev, sizeof(*regset), GFP_KERNEL);\r\nif (!regset)\r\nreturn -ENOMEM;\r\nregset->regs = regs;\r\nregset->nregs = nregs;\r\nregset->base = cprman->regs + base;\r\nregdump = debugfs_create_regset32("regdump", S_IRUGO, dentry,\r\nregset);\r\nreturn regdump ? 0 : -ENOMEM;\r\n}\r\nvoid __init bcm2835_init_clocks(void)\r\n{\r\nstruct clk_hw *hw;\r\nint ret;\r\nhw = clk_hw_register_fixed_rate(NULL, "apb_pclk", NULL, 0, 126000000);\r\nif (IS_ERR(hw))\r\npr_err("apb_pclk not registered\n");\r\nhw = clk_hw_register_fixed_rate(NULL, "uart0_pclk", NULL, 0, 3000000);\r\nif (IS_ERR(hw))\r\npr_err("uart0_pclk not registered\n");\r\nret = clk_hw_register_clkdev(hw, NULL, "20201000.uart");\r\nif (ret)\r\npr_err("uart0_pclk alias not registered\n");\r\nhw = clk_hw_register_fixed_rate(NULL, "uart1_pclk", NULL, 0, 125000000);\r\nif (IS_ERR(hw))\r\npr_err("uart1_pclk not registered\n");\r\nret = clk_hw_register_clkdev(hw, NULL, "20215000.uart");\r\nif (ret)\r\npr_err("uart1_pclk alias not registered\n");\r\n}\r\nstatic int bcm2835_pll_is_on(struct clk_hw *hw)\r\n{\r\nstruct bcm2835_pll *pll = container_of(hw, struct bcm2835_pll, hw);\r\nstruct bcm2835_cprman *cprman = pll->cprman;\r\nconst struct bcm2835_pll_data *data = pll->data;\r\nreturn cprman_read(cprman, data->a2w_ctrl_reg) &\r\nA2W_PLL_CTRL_PRST_DISABLE;\r\n}\r\nstatic void bcm2835_pll_choose_ndiv_and_fdiv(unsigned long rate,\r\nunsigned long parent_rate,\r\nu32 *ndiv, u32 *fdiv)\r\n{\r\nu64 div;\r\ndiv = (u64)rate << A2W_PLL_FRAC_BITS;\r\ndo_div(div, parent_rate);\r\n*ndiv = div >> A2W_PLL_FRAC_BITS;\r\n*fdiv = div & ((1 << A2W_PLL_FRAC_BITS) - 1);\r\n}\r\nstatic long bcm2835_pll_rate_from_divisors(unsigned long parent_rate,\r\nu32 ndiv, u32 fdiv, u32 pdiv)\r\n{\r\nu64 rate;\r\nif (pdiv == 0)\r\nreturn 0;\r\nrate = (u64)parent_rate * ((ndiv << A2W_PLL_FRAC_BITS) + fdiv);\r\ndo_div(rate, pdiv);\r\nreturn rate >> A2W_PLL_FRAC_BITS;\r\n}\r\nstatic long bcm2835_pll_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct bcm2835_pll *pll = container_of(hw, struct bcm2835_pll, hw);\r\nconst struct bcm2835_pll_data *data = pll->data;\r\nu32 ndiv, fdiv;\r\nrate = clamp(rate, data->min_rate, data->max_rate);\r\nbcm2835_pll_choose_ndiv_and_fdiv(rate, *parent_rate, &ndiv, &fdiv);\r\nreturn bcm2835_pll_rate_from_divisors(*parent_rate, ndiv, fdiv, 1);\r\n}\r\nstatic unsigned long bcm2835_pll_get_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct bcm2835_pll *pll = container_of(hw, struct bcm2835_pll, hw);\r\nstruct bcm2835_cprman *cprman = pll->cprman;\r\nconst struct bcm2835_pll_data *data = pll->data;\r\nu32 a2wctrl = cprman_read(cprman, data->a2w_ctrl_reg);\r\nu32 ndiv, pdiv, fdiv;\r\nbool using_prediv;\r\nif (parent_rate == 0)\r\nreturn 0;\r\nfdiv = cprman_read(cprman, data->frac_reg) & A2W_PLL_FRAC_MASK;\r\nndiv = (a2wctrl & A2W_PLL_CTRL_NDIV_MASK) >> A2W_PLL_CTRL_NDIV_SHIFT;\r\npdiv = (a2wctrl & A2W_PLL_CTRL_PDIV_MASK) >> A2W_PLL_CTRL_PDIV_SHIFT;\r\nusing_prediv = cprman_read(cprman, data->ana_reg_base + 4) &\r\ndata->ana->fb_prediv_mask;\r\nif (using_prediv) {\r\nndiv *= 2;\r\nfdiv *= 2;\r\n}\r\nreturn bcm2835_pll_rate_from_divisors(parent_rate, ndiv, fdiv, pdiv);\r\n}\r\nstatic void bcm2835_pll_off(struct clk_hw *hw)\r\n{\r\nstruct bcm2835_pll *pll = container_of(hw, struct bcm2835_pll, hw);\r\nstruct bcm2835_cprman *cprman = pll->cprman;\r\nconst struct bcm2835_pll_data *data = pll->data;\r\nspin_lock(&cprman->regs_lock);\r\ncprman_write(cprman, data->cm_ctrl_reg,\r\ncprman_read(cprman, data->cm_ctrl_reg) |\r\nCM_PLL_ANARST);\r\ncprman_write(cprman, data->a2w_ctrl_reg,\r\ncprman_read(cprman, data->a2w_ctrl_reg) |\r\nA2W_PLL_CTRL_PWRDN);\r\nspin_unlock(&cprman->regs_lock);\r\n}\r\nstatic int bcm2835_pll_on(struct clk_hw *hw)\r\n{\r\nstruct bcm2835_pll *pll = container_of(hw, struct bcm2835_pll, hw);\r\nstruct bcm2835_cprman *cprman = pll->cprman;\r\nconst struct bcm2835_pll_data *data = pll->data;\r\nktime_t timeout;\r\ncprman_write(cprman, data->a2w_ctrl_reg,\r\ncprman_read(cprman, data->a2w_ctrl_reg) &\r\n~A2W_PLL_CTRL_PWRDN);\r\ncprman_write(cprman, data->cm_ctrl_reg,\r\ncprman_read(cprman, data->cm_ctrl_reg) & ~CM_PLL_ANARST);\r\ntimeout = ktime_add_ns(ktime_get(), LOCK_TIMEOUT_NS);\r\nwhile (!(cprman_read(cprman, CM_LOCK) & data->lock_mask)) {\r\nif (ktime_after(ktime_get(), timeout)) {\r\ndev_err(cprman->dev, "%s: couldn't lock PLL\n",\r\nclk_hw_get_name(hw));\r\nreturn -ETIMEDOUT;\r\n}\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nbcm2835_pll_write_ana(struct bcm2835_cprman *cprman, u32 ana_reg_base, u32 *ana)\r\n{\r\nint i;\r\nfor (i = 3; i >= 0; i--)\r\ncprman_write(cprman, ana_reg_base + i * 4, ana[i]);\r\n}\r\nstatic int bcm2835_pll_set_rate(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate)\r\n{\r\nstruct bcm2835_pll *pll = container_of(hw, struct bcm2835_pll, hw);\r\nstruct bcm2835_cprman *cprman = pll->cprman;\r\nconst struct bcm2835_pll_data *data = pll->data;\r\nbool was_using_prediv, use_fb_prediv, do_ana_setup_first;\r\nu32 ndiv, fdiv, a2w_ctl;\r\nu32 ana[4];\r\nint i;\r\nif (rate > data->max_fb_rate) {\r\nuse_fb_prediv = true;\r\nrate /= 2;\r\n} else {\r\nuse_fb_prediv = false;\r\n}\r\nbcm2835_pll_choose_ndiv_and_fdiv(rate, parent_rate, &ndiv, &fdiv);\r\nfor (i = 3; i >= 0; i--)\r\nana[i] = cprman_read(cprman, data->ana_reg_base + i * 4);\r\nwas_using_prediv = ana[1] & data->ana->fb_prediv_mask;\r\nana[0] &= ~data->ana->mask0;\r\nana[0] |= data->ana->set0;\r\nana[1] &= ~data->ana->mask1;\r\nana[1] |= data->ana->set1;\r\nana[3] &= ~data->ana->mask3;\r\nana[3] |= data->ana->set3;\r\nif (was_using_prediv && !use_fb_prediv) {\r\nana[1] &= ~data->ana->fb_prediv_mask;\r\ndo_ana_setup_first = true;\r\n} else if (!was_using_prediv && use_fb_prediv) {\r\nana[1] |= data->ana->fb_prediv_mask;\r\ndo_ana_setup_first = false;\r\n} else {\r\ndo_ana_setup_first = true;\r\n}\r\ncprman_write(cprman, A2W_XOSC_CTRL,\r\ncprman_read(cprman, A2W_XOSC_CTRL) |\r\ndata->reference_enable_mask);\r\nif (do_ana_setup_first)\r\nbcm2835_pll_write_ana(cprman, data->ana_reg_base, ana);\r\ncprman_write(cprman, data->frac_reg, fdiv);\r\na2w_ctl = cprman_read(cprman, data->a2w_ctrl_reg);\r\na2w_ctl &= ~A2W_PLL_CTRL_NDIV_MASK;\r\na2w_ctl |= ndiv << A2W_PLL_CTRL_NDIV_SHIFT;\r\na2w_ctl &= ~A2W_PLL_CTRL_PDIV_MASK;\r\na2w_ctl |= 1 << A2W_PLL_CTRL_PDIV_SHIFT;\r\ncprman_write(cprman, data->a2w_ctrl_reg, a2w_ctl);\r\nif (!do_ana_setup_first)\r\nbcm2835_pll_write_ana(cprman, data->ana_reg_base, ana);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_pll_debug_init(struct clk_hw *hw,\r\nstruct dentry *dentry)\r\n{\r\nstruct bcm2835_pll *pll = container_of(hw, struct bcm2835_pll, hw);\r\nstruct bcm2835_cprman *cprman = pll->cprman;\r\nconst struct bcm2835_pll_data *data = pll->data;\r\nstruct debugfs_reg32 *regs;\r\nregs = devm_kzalloc(cprman->dev, 7 * sizeof(*regs), GFP_KERNEL);\r\nif (!regs)\r\nreturn -ENOMEM;\r\nregs[0].name = "cm_ctrl";\r\nregs[0].offset = data->cm_ctrl_reg;\r\nregs[1].name = "a2w_ctrl";\r\nregs[1].offset = data->a2w_ctrl_reg;\r\nregs[2].name = "frac";\r\nregs[2].offset = data->frac_reg;\r\nregs[3].name = "ana0";\r\nregs[3].offset = data->ana_reg_base + 0 * 4;\r\nregs[4].name = "ana1";\r\nregs[4].offset = data->ana_reg_base + 1 * 4;\r\nregs[5].name = "ana2";\r\nregs[5].offset = data->ana_reg_base + 2 * 4;\r\nregs[6].name = "ana3";\r\nregs[6].offset = data->ana_reg_base + 3 * 4;\r\nreturn bcm2835_debugfs_regset(cprman, 0, regs, 7, dentry);\r\n}\r\nstatic struct bcm2835_pll_divider *\r\nbcm2835_pll_divider_from_hw(struct clk_hw *hw)\r\n{\r\nreturn container_of(hw, struct bcm2835_pll_divider, div.hw);\r\n}\r\nstatic int bcm2835_pll_divider_is_on(struct clk_hw *hw)\r\n{\r\nstruct bcm2835_pll_divider *divider = bcm2835_pll_divider_from_hw(hw);\r\nstruct bcm2835_cprman *cprman = divider->cprman;\r\nconst struct bcm2835_pll_divider_data *data = divider->data;\r\nreturn !(cprman_read(cprman, data->a2w_reg) & A2W_PLL_CHANNEL_DISABLE);\r\n}\r\nstatic long bcm2835_pll_divider_round_rate(struct clk_hw *hw,\r\nunsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nreturn clk_divider_ops.round_rate(hw, rate, parent_rate);\r\n}\r\nstatic unsigned long bcm2835_pll_divider_get_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn clk_divider_ops.recalc_rate(hw, parent_rate);\r\n}\r\nstatic void bcm2835_pll_divider_off(struct clk_hw *hw)\r\n{\r\nstruct bcm2835_pll_divider *divider = bcm2835_pll_divider_from_hw(hw);\r\nstruct bcm2835_cprman *cprman = divider->cprman;\r\nconst struct bcm2835_pll_divider_data *data = divider->data;\r\nspin_lock(&cprman->regs_lock);\r\ncprman_write(cprman, data->cm_reg,\r\n(cprman_read(cprman, data->cm_reg) &\r\n~data->load_mask) | data->hold_mask);\r\ncprman_write(cprman, data->a2w_reg,\r\ncprman_read(cprman, data->a2w_reg) |\r\nA2W_PLL_CHANNEL_DISABLE);\r\nspin_unlock(&cprman->regs_lock);\r\n}\r\nstatic int bcm2835_pll_divider_on(struct clk_hw *hw)\r\n{\r\nstruct bcm2835_pll_divider *divider = bcm2835_pll_divider_from_hw(hw);\r\nstruct bcm2835_cprman *cprman = divider->cprman;\r\nconst struct bcm2835_pll_divider_data *data = divider->data;\r\nspin_lock(&cprman->regs_lock);\r\ncprman_write(cprman, data->a2w_reg,\r\ncprman_read(cprman, data->a2w_reg) &\r\n~A2W_PLL_CHANNEL_DISABLE);\r\ncprman_write(cprman, data->cm_reg,\r\ncprman_read(cprman, data->cm_reg) & ~data->hold_mask);\r\nspin_unlock(&cprman->regs_lock);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_pll_divider_set_rate(struct clk_hw *hw,\r\nunsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct bcm2835_pll_divider *divider = bcm2835_pll_divider_from_hw(hw);\r\nstruct bcm2835_cprman *cprman = divider->cprman;\r\nconst struct bcm2835_pll_divider_data *data = divider->data;\r\nu32 cm, div, max_div = 1 << A2W_PLL_DIV_BITS;\r\ndiv = DIV_ROUND_UP_ULL(parent_rate, rate);\r\ndiv = min(div, max_div);\r\nif (div == max_div)\r\ndiv = 0;\r\ncprman_write(cprman, data->a2w_reg, div);\r\ncm = cprman_read(cprman, data->cm_reg);\r\ncprman_write(cprman, data->cm_reg, cm | data->load_mask);\r\ncprman_write(cprman, data->cm_reg, cm & ~data->load_mask);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_pll_divider_debug_init(struct clk_hw *hw,\r\nstruct dentry *dentry)\r\n{\r\nstruct bcm2835_pll_divider *divider = bcm2835_pll_divider_from_hw(hw);\r\nstruct bcm2835_cprman *cprman = divider->cprman;\r\nconst struct bcm2835_pll_divider_data *data = divider->data;\r\nstruct debugfs_reg32 *regs;\r\nregs = devm_kzalloc(cprman->dev, 7 * sizeof(*regs), GFP_KERNEL);\r\nif (!regs)\r\nreturn -ENOMEM;\r\nregs[0].name = "cm";\r\nregs[0].offset = data->cm_reg;\r\nregs[1].name = "a2w";\r\nregs[1].offset = data->a2w_reg;\r\nreturn bcm2835_debugfs_regset(cprman, 0, regs, 2, dentry);\r\n}\r\nstatic struct bcm2835_clock *bcm2835_clock_from_hw(struct clk_hw *hw)\r\n{\r\nreturn container_of(hw, struct bcm2835_clock, hw);\r\n}\r\nstatic int bcm2835_clock_is_on(struct clk_hw *hw)\r\n{\r\nstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\r\nstruct bcm2835_cprman *cprman = clock->cprman;\r\nconst struct bcm2835_clock_data *data = clock->data;\r\nreturn (cprman_read(cprman, data->ctl_reg) & CM_ENABLE) != 0;\r\n}\r\nstatic u32 bcm2835_clock_choose_div(struct clk_hw *hw,\r\nunsigned long rate,\r\nunsigned long parent_rate,\r\nbool round_up)\r\n{\r\nstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\r\nconst struct bcm2835_clock_data *data = clock->data;\r\nu32 unused_frac_mask =\r\nGENMASK(CM_DIV_FRAC_BITS - data->frac_bits, 0) >> 1;\r\nu64 temp = (u64)parent_rate << CM_DIV_FRAC_BITS;\r\nu64 rem;\r\nu32 div, mindiv, maxdiv;\r\nrem = do_div(temp, rate);\r\ndiv = temp;\r\nif (round_up && ((div & unused_frac_mask) != 0 || rem != 0))\r\ndiv += unused_frac_mask + 1;\r\ndiv &= ~unused_frac_mask;\r\nif (data->is_mash_clock) {\r\nmindiv = 2 << CM_DIV_FRAC_BITS;\r\nmaxdiv = (BIT(data->int_bits) - 1) << CM_DIV_FRAC_BITS;\r\n} else {\r\nmindiv = 1 << CM_DIV_FRAC_BITS;\r\nmaxdiv = GENMASK(data->int_bits + CM_DIV_FRAC_BITS - 1,\r\nCM_DIV_FRAC_BITS - data->frac_bits);\r\n}\r\ndiv = max_t(u32, div, mindiv);\r\ndiv = min_t(u32, div, maxdiv);\r\nreturn div;\r\n}\r\nstatic long bcm2835_clock_rate_from_divisor(struct bcm2835_clock *clock,\r\nunsigned long parent_rate,\r\nu32 div)\r\n{\r\nconst struct bcm2835_clock_data *data = clock->data;\r\nu64 temp;\r\nif (data->int_bits == 0 && data->frac_bits == 0)\r\nreturn parent_rate;\r\ndiv >>= CM_DIV_FRAC_BITS - data->frac_bits;\r\ndiv &= (1 << (data->int_bits + data->frac_bits)) - 1;\r\nif (div == 0)\r\nreturn 0;\r\ntemp = (u64)parent_rate << data->frac_bits;\r\ndo_div(temp, div);\r\nreturn temp;\r\n}\r\nstatic unsigned long bcm2835_clock_get_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\r\nstruct bcm2835_cprman *cprman = clock->cprman;\r\nconst struct bcm2835_clock_data *data = clock->data;\r\nu32 div;\r\nif (data->int_bits == 0 && data->frac_bits == 0)\r\nreturn parent_rate;\r\ndiv = cprman_read(cprman, data->div_reg);\r\nreturn bcm2835_clock_rate_from_divisor(clock, parent_rate, div);\r\n}\r\nstatic void bcm2835_clock_wait_busy(struct bcm2835_clock *clock)\r\n{\r\nstruct bcm2835_cprman *cprman = clock->cprman;\r\nconst struct bcm2835_clock_data *data = clock->data;\r\nktime_t timeout = ktime_add_ns(ktime_get(), LOCK_TIMEOUT_NS);\r\nwhile (cprman_read(cprman, data->ctl_reg) & CM_BUSY) {\r\nif (ktime_after(ktime_get(), timeout)) {\r\ndev_err(cprman->dev, "%s: couldn't lock PLL\n",\r\nclk_hw_get_name(&clock->hw));\r\nreturn;\r\n}\r\ncpu_relax();\r\n}\r\n}\r\nstatic void bcm2835_clock_off(struct clk_hw *hw)\r\n{\r\nstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\r\nstruct bcm2835_cprman *cprman = clock->cprman;\r\nconst struct bcm2835_clock_data *data = clock->data;\r\nspin_lock(&cprman->regs_lock);\r\ncprman_write(cprman, data->ctl_reg,\r\ncprman_read(cprman, data->ctl_reg) & ~CM_ENABLE);\r\nspin_unlock(&cprman->regs_lock);\r\nbcm2835_clock_wait_busy(clock);\r\n}\r\nstatic int bcm2835_clock_on(struct clk_hw *hw)\r\n{\r\nstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\r\nstruct bcm2835_cprman *cprman = clock->cprman;\r\nconst struct bcm2835_clock_data *data = clock->data;\r\nspin_lock(&cprman->regs_lock);\r\ncprman_write(cprman, data->ctl_reg,\r\ncprman_read(cprman, data->ctl_reg) |\r\nCM_ENABLE |\r\nCM_GATE);\r\nspin_unlock(&cprman->regs_lock);\r\nif (data->tcnt_mux && false) {\r\ndev_info(cprman->dev,\r\n"clk %s: rate %ld, measure %ld\n",\r\ndata->name,\r\nclk_hw_get_rate(hw),\r\nbcm2835_measure_tcnt_mux(cprman, data->tcnt_mux));\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm2835_clock_set_rate(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate)\r\n{\r\nstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\r\nstruct bcm2835_cprman *cprman = clock->cprman;\r\nconst struct bcm2835_clock_data *data = clock->data;\r\nu32 div = bcm2835_clock_choose_div(hw, rate, parent_rate, false);\r\nu32 ctl;\r\nspin_lock(&cprman->regs_lock);\r\nctl = cprman_read(cprman, data->ctl_reg) & ~CM_FRAC;\r\nctl |= (div & CM_DIV_FRAC_MASK) ? CM_FRAC : 0;\r\ncprman_write(cprman, data->ctl_reg, ctl);\r\ncprman_write(cprman, data->div_reg, div);\r\nspin_unlock(&cprman->regs_lock);\r\nreturn 0;\r\n}\r\nstatic bool\r\nbcm2835_clk_is_pllc(struct clk_hw *hw)\r\n{\r\nif (!hw)\r\nreturn false;\r\nreturn strncmp(clk_hw_get_name(hw), "pllc", 4) == 0;\r\n}\r\nstatic unsigned long bcm2835_clock_choose_div_and_prate(struct clk_hw *hw,\r\nint parent_idx,\r\nunsigned long rate,\r\nu32 *div,\r\nunsigned long *prate,\r\nunsigned long *avgrate)\r\n{\r\nstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\r\nstruct bcm2835_cprman *cprman = clock->cprman;\r\nconst struct bcm2835_clock_data *data = clock->data;\r\nunsigned long best_rate = 0;\r\nu32 curdiv, mindiv, maxdiv;\r\nstruct clk_hw *parent;\r\nparent = clk_hw_get_parent_by_index(hw, parent_idx);\r\nif (!(BIT(parent_idx) & data->set_rate_parent)) {\r\n*prate = clk_hw_get_rate(parent);\r\n*div = bcm2835_clock_choose_div(hw, rate, *prate, true);\r\n*avgrate = bcm2835_clock_rate_from_divisor(clock, *prate, *div);\r\nif (data->low_jitter && (*div & CM_DIV_FRAC_MASK)) {\r\nunsigned long high, low;\r\nu32 int_div = *div & ~CM_DIV_FRAC_MASK;\r\nhigh = bcm2835_clock_rate_from_divisor(clock, *prate,\r\nint_div);\r\nint_div += CM_DIV_FRAC_MASK + 1;\r\nlow = bcm2835_clock_rate_from_divisor(clock, *prate,\r\nint_div);\r\nreturn *avgrate - max(*avgrate - low, high - *avgrate);\r\n}\r\nreturn *avgrate;\r\n}\r\nif (data->frac_bits)\r\ndev_warn(cprman->dev,\r\n"frac bits are not used when propagating rate change");\r\nmindiv = data->is_mash_clock ? 2 : 1;\r\nmaxdiv = BIT(data->int_bits) - 1;\r\nfor (curdiv = mindiv; curdiv <= maxdiv; curdiv++) {\r\nunsigned long tmp_rate;\r\ntmp_rate = clk_hw_round_rate(parent, rate * curdiv);\r\ntmp_rate /= curdiv;\r\nif (curdiv == mindiv ||\r\n(tmp_rate > best_rate && tmp_rate <= rate))\r\nbest_rate = tmp_rate;\r\nif (best_rate == rate)\r\nbreak;\r\n}\r\n*div = curdiv << CM_DIV_FRAC_BITS;\r\n*prate = curdiv * best_rate;\r\n*avgrate = best_rate;\r\nreturn best_rate;\r\n}\r\nstatic int bcm2835_clock_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_hw *parent, *best_parent = NULL;\r\nbool current_parent_is_pllc;\r\nunsigned long rate, best_rate = 0;\r\nunsigned long prate, best_prate = 0;\r\nunsigned long avgrate, best_avgrate = 0;\r\nsize_t i;\r\nu32 div;\r\ncurrent_parent_is_pllc = bcm2835_clk_is_pllc(clk_hw_get_parent(hw));\r\nfor (i = 0; i < clk_hw_get_num_parents(hw); ++i) {\r\nparent = clk_hw_get_parent_by_index(hw, i);\r\nif (!parent)\r\ncontinue;\r\nif (bcm2835_clk_is_pllc(parent) && !current_parent_is_pllc)\r\ncontinue;\r\nrate = bcm2835_clock_choose_div_and_prate(hw, i, req->rate,\r\n&div, &prate,\r\n&avgrate);\r\nif (rate > best_rate && rate <= req->rate) {\r\nbest_parent = parent;\r\nbest_prate = prate;\r\nbest_rate = rate;\r\nbest_avgrate = avgrate;\r\n}\r\n}\r\nif (!best_parent)\r\nreturn -EINVAL;\r\nreq->best_parent_hw = best_parent;\r\nreq->best_parent_rate = best_prate;\r\nreq->rate = best_avgrate;\r\nreturn 0;\r\n}\r\nstatic int bcm2835_clock_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\r\nstruct bcm2835_cprman *cprman = clock->cprman;\r\nconst struct bcm2835_clock_data *data = clock->data;\r\nu8 src = (index << CM_SRC_SHIFT) & CM_SRC_MASK;\r\ncprman_write(cprman, data->ctl_reg, src);\r\nreturn 0;\r\n}\r\nstatic u8 bcm2835_clock_get_parent(struct clk_hw *hw)\r\n{\r\nstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\r\nstruct bcm2835_cprman *cprman = clock->cprman;\r\nconst struct bcm2835_clock_data *data = clock->data;\r\nu32 src = cprman_read(cprman, data->ctl_reg);\r\nreturn (src & CM_SRC_MASK) >> CM_SRC_SHIFT;\r\n}\r\nstatic int bcm2835_clock_debug_init(struct clk_hw *hw,\r\nstruct dentry *dentry)\r\n{\r\nstruct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);\r\nstruct bcm2835_cprman *cprman = clock->cprman;\r\nconst struct bcm2835_clock_data *data = clock->data;\r\nreturn bcm2835_debugfs_regset(\r\ncprman, data->ctl_reg,\r\nbcm2835_debugfs_clock_reg32,\r\nARRAY_SIZE(bcm2835_debugfs_clock_reg32),\r\ndentry);\r\n}\r\nstatic int bcm2835_vpu_clock_is_on(struct clk_hw *hw)\r\n{\r\nreturn true;\r\n}\r\nstatic struct clk_hw *bcm2835_register_pll(struct bcm2835_cprman *cprman,\r\nconst struct bcm2835_pll_data *data)\r\n{\r\nstruct bcm2835_pll *pll;\r\nstruct clk_init_data init;\r\nint ret;\r\nmemset(&init, 0, sizeof(init));\r\ninit.parent_names = &cprman->real_parent_names[0];\r\ninit.num_parents = 1;\r\ninit.name = data->name;\r\ninit.ops = &bcm2835_pll_clk_ops;\r\ninit.flags = CLK_IGNORE_UNUSED;\r\npll = kzalloc(sizeof(*pll), GFP_KERNEL);\r\nif (!pll)\r\nreturn NULL;\r\npll->cprman = cprman;\r\npll->data = data;\r\npll->hw.init = &init;\r\nret = devm_clk_hw_register(cprman->dev, &pll->hw);\r\nif (ret)\r\nreturn NULL;\r\nreturn &pll->hw;\r\n}\r\nstatic struct clk_hw *\r\nbcm2835_register_pll_divider(struct bcm2835_cprman *cprman,\r\nconst struct bcm2835_pll_divider_data *data)\r\n{\r\nstruct bcm2835_pll_divider *divider;\r\nstruct clk_init_data init;\r\nconst char *divider_name;\r\nint ret;\r\nif (data->fixed_divider != 1) {\r\ndivider_name = devm_kasprintf(cprman->dev, GFP_KERNEL,\r\n"%s_prediv", data->name);\r\nif (!divider_name)\r\nreturn NULL;\r\n} else {\r\ndivider_name = data->name;\r\n}\r\nmemset(&init, 0, sizeof(init));\r\ninit.parent_names = &data->source_pll;\r\ninit.num_parents = 1;\r\ninit.name = divider_name;\r\ninit.ops = &bcm2835_pll_divider_clk_ops;\r\ninit.flags = data->flags | CLK_IGNORE_UNUSED;\r\ndivider = devm_kzalloc(cprman->dev, sizeof(*divider), GFP_KERNEL);\r\nif (!divider)\r\nreturn NULL;\r\ndivider->div.reg = cprman->regs + data->a2w_reg;\r\ndivider->div.shift = A2W_PLL_DIV_SHIFT;\r\ndivider->div.width = A2W_PLL_DIV_BITS;\r\ndivider->div.flags = CLK_DIVIDER_MAX_AT_ZERO;\r\ndivider->div.lock = &cprman->regs_lock;\r\ndivider->div.hw.init = &init;\r\ndivider->div.table = NULL;\r\ndivider->cprman = cprman;\r\ndivider->data = data;\r\nret = devm_clk_hw_register(cprman->dev, &divider->div.hw);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nif (data->fixed_divider != 1) {\r\nreturn clk_hw_register_fixed_factor(cprman->dev, data->name,\r\ndivider_name,\r\nCLK_SET_RATE_PARENT,\r\n1,\r\ndata->fixed_divider);\r\n}\r\nreturn &divider->div.hw;\r\n}\r\nstatic struct clk_hw *bcm2835_register_clock(struct bcm2835_cprman *cprman,\r\nconst struct bcm2835_clock_data *data)\r\n{\r\nstruct bcm2835_clock *clock;\r\nstruct clk_init_data init;\r\nconst char *parents[1 << CM_SRC_BITS];\r\nsize_t i, j;\r\nint ret;\r\nfor (i = 0; i < data->num_mux_parents; i++) {\r\nparents[i] = data->parents[i];\r\nfor (j = 0; j < ARRAY_SIZE(cprman_parent_names); j++) {\r\nif (strcmp(parents[i], cprman_parent_names[j]) == 0) {\r\nparents[i] = cprman->real_parent_names[j];\r\nbreak;\r\n}\r\n}\r\n}\r\nmemset(&init, 0, sizeof(init));\r\ninit.parent_names = parents;\r\ninit.num_parents = data->num_mux_parents;\r\ninit.name = data->name;\r\ninit.flags = data->flags | CLK_IGNORE_UNUSED;\r\nif (data->set_rate_parent)\r\ninit.flags |= CLK_SET_RATE_PARENT;\r\nif (data->is_vpu_clock) {\r\ninit.ops = &bcm2835_vpu_clock_clk_ops;\r\n} else {\r\ninit.ops = &bcm2835_clock_clk_ops;\r\ninit.flags |= CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\r\nif (!(cprman_read(cprman, data->ctl_reg) & CM_ENABLE))\r\ninit.flags &= ~CLK_IS_CRITICAL;\r\n}\r\nclock = devm_kzalloc(cprman->dev, sizeof(*clock), GFP_KERNEL);\r\nif (!clock)\r\nreturn NULL;\r\nclock->cprman = cprman;\r\nclock->data = data;\r\nclock->hw.init = &init;\r\nret = devm_clk_hw_register(cprman->dev, &clock->hw);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn &clock->hw;\r\n}\r\nstatic struct clk *bcm2835_register_gate(struct bcm2835_cprman *cprman,\r\nconst struct bcm2835_gate_data *data)\r\n{\r\nreturn clk_register_gate(cprman->dev, data->name, data->parent,\r\nCLK_IGNORE_UNUSED | CLK_SET_RATE_GATE,\r\ncprman->regs + data->ctl_reg,\r\nCM_GATE_BIT, 0, &cprman->regs_lock);\r\n}\r\nstatic int bcm2835_mark_sdc_parent_critical(struct clk *sdc)\r\n{\r\nstruct clk *parent = clk_get_parent(sdc);\r\nif (IS_ERR(parent))\r\nreturn PTR_ERR(parent);\r\nreturn clk_prepare_enable(parent);\r\n}\r\nstatic int bcm2835_clk_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct clk_hw **hws;\r\nstruct bcm2835_cprman *cprman;\r\nstruct resource *res;\r\nconst struct bcm2835_clk_desc *desc;\r\nconst size_t asize = ARRAY_SIZE(clk_desc_array);\r\nsize_t i;\r\nint ret;\r\ncprman = devm_kzalloc(dev, sizeof(*cprman) +\r\nsizeof(*cprman->onecell.hws) * asize,\r\nGFP_KERNEL);\r\nif (!cprman)\r\nreturn -ENOMEM;\r\nspin_lock_init(&cprman->regs_lock);\r\ncprman->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ncprman->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(cprman->regs))\r\nreturn PTR_ERR(cprman->regs);\r\nmemcpy(cprman->real_parent_names, cprman_parent_names,\r\nsizeof(cprman_parent_names));\r\nof_clk_parent_fill(dev->of_node, cprman->real_parent_names,\r\nARRAY_SIZE(cprman_parent_names));\r\nif (!cprman->real_parent_names[0])\r\nreturn -ENODEV;\r\nplatform_set_drvdata(pdev, cprman);\r\ncprman->onecell.num = asize;\r\nhws = cprman->onecell.hws;\r\nfor (i = 0; i < asize; i++) {\r\ndesc = &clk_desc_array[i];\r\nif (desc->clk_register && desc->data)\r\nhws[i] = desc->clk_register(cprman, desc->data);\r\n}\r\nret = bcm2835_mark_sdc_parent_critical(hws[BCM2835_CLOCK_SDRAM]->clk);\r\nif (ret)\r\nreturn ret;\r\nreturn of_clk_add_hw_provider(dev->of_node, of_clk_hw_onecell_get,\r\n&cprman->onecell);\r\n}
