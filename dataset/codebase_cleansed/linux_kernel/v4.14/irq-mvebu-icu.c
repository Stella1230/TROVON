static void mvebu_icu_write_msg(struct msi_desc *desc, struct msi_msg *msg)\r\n{\r\nstruct irq_data *d = irq_get_irq_data(desc->irq);\r\nstruct mvebu_icu_irq_data *icu_irqd = d->chip_data;\r\nstruct mvebu_icu *icu = icu_irqd->icu;\r\nunsigned int icu_int;\r\nif (msg->address_lo || msg->address_hi) {\r\nicu_int = msg->data | ICU_INT_ENABLE;\r\nif (icu_irqd->type & IRQ_TYPE_EDGE_RISING)\r\nicu_int |= ICU_IS_EDGE;\r\nicu_int |= icu_irqd->icu_group << ICU_GROUP_SHIFT;\r\n} else {\r\nicu_int = 0;\r\n}\r\nwritel_relaxed(icu_int, icu->base + ICU_INT_CFG(d->hwirq));\r\nif (d->hwirq == ICU_SATA0_ICU_ID || d->hwirq == ICU_SATA1_ICU_ID) {\r\nwritel_relaxed(icu_int,\r\nicu->base + ICU_INT_CFG(ICU_SATA0_ICU_ID));\r\nwritel_relaxed(icu_int,\r\nicu->base + ICU_INT_CFG(ICU_SATA1_ICU_ID));\r\n}\r\n}\r\nstatic int\r\nmvebu_icu_irq_domain_translate(struct irq_domain *d, struct irq_fwspec *fwspec,\r\nunsigned long *hwirq, unsigned int *type)\r\n{\r\nstruct mvebu_icu *icu = d->host_data;\r\nunsigned int icu_group;\r\nif (WARN_ON(fwspec->param_count < 3)) {\r\ndev_err(icu->dev, "wrong ICU parameter count %d\n",\r\nfwspec->param_count);\r\nreturn -EINVAL;\r\n}\r\nicu_group = fwspec->param[0];\r\nif (icu_group != ICU_GRP_NSR && icu_group != ICU_GRP_SR &&\r\nicu_group != ICU_GRP_SEI && icu_group != ICU_GRP_REI) {\r\ndev_err(icu->dev, "wrong ICU group type %x\n", icu_group);\r\nreturn -EINVAL;\r\n}\r\n*hwirq = fwspec->param[1];\r\nif (*hwirq >= ICU_MAX_IRQS) {\r\ndev_err(icu->dev, "invalid interrupt number %ld\n", *hwirq);\r\nreturn -EINVAL;\r\n}\r\n*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;\r\nreturn 0;\r\n}\r\nstatic int\r\nmvebu_icu_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\r\nunsigned int nr_irqs, void *args)\r\n{\r\nint err;\r\nunsigned long hwirq;\r\nstruct irq_fwspec *fwspec = args;\r\nstruct mvebu_icu *icu = platform_msi_get_host_data(domain);\r\nstruct mvebu_icu_irq_data *icu_irqd;\r\nicu_irqd = kmalloc(sizeof(*icu_irqd), GFP_KERNEL);\r\nif (!icu_irqd)\r\nreturn -ENOMEM;\r\nerr = mvebu_icu_irq_domain_translate(domain, fwspec, &hwirq,\r\n&icu_irqd->type);\r\nif (err) {\r\ndev_err(icu->dev, "failed to translate ICU parameters\n");\r\ngoto free_irqd;\r\n}\r\nicu_irqd->icu_group = fwspec->param[0];\r\nicu_irqd->icu = icu;\r\nerr = platform_msi_domain_alloc(domain, virq, nr_irqs);\r\nif (err) {\r\ndev_err(icu->dev, "failed to allocate ICU interrupt in parent domain\n");\r\ngoto free_irqd;\r\n}\r\nerr = irq_set_irqchip_state(virq, IRQCHIP_STATE_PENDING, false);\r\nif (err)\r\ngoto free_msi;\r\nerr = irq_domain_set_hwirq_and_chip(domain, virq, hwirq,\r\n&icu->irq_chip, icu_irqd);\r\nif (err) {\r\ndev_err(icu->dev, "failed to set the data to IRQ domain\n");\r\ngoto free_msi;\r\n}\r\nreturn 0;\r\nfree_msi:\r\nplatform_msi_domain_free(domain, virq, nr_irqs);\r\nfree_irqd:\r\nkfree(icu_irqd);\r\nreturn err;\r\n}\r\nstatic void\r\nmvebu_icu_irq_domain_free(struct irq_domain *domain, unsigned int virq,\r\nunsigned int nr_irqs)\r\n{\r\nstruct irq_data *d = irq_get_irq_data(virq);\r\nstruct mvebu_icu_irq_data *icu_irqd = d->chip_data;\r\nkfree(icu_irqd);\r\nplatform_msi_domain_free(domain, virq, nr_irqs);\r\n}\r\nstatic int mvebu_icu_probe(struct platform_device *pdev)\r\n{\r\nstruct mvebu_icu *icu;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device_node *gicp_dn;\r\nstruct resource *res;\r\nphys_addr_t setspi, clrspi;\r\nu32 i, icu_int;\r\nint ret;\r\nicu = devm_kzalloc(&pdev->dev, sizeof(struct mvebu_icu),\r\nGFP_KERNEL);\r\nif (!icu)\r\nreturn -ENOMEM;\r\nicu->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nicu->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(icu->base)) {\r\ndev_err(&pdev->dev, "Failed to map icu base address.\n");\r\nreturn PTR_ERR(icu->base);\r\n}\r\nicu->irq_chip.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\r\n"ICU.%x",\r\n(unsigned int)res->start);\r\nif (!icu->irq_chip.name)\r\nreturn -ENOMEM;\r\nicu->irq_chip.irq_mask = irq_chip_mask_parent;\r\nicu->irq_chip.irq_unmask = irq_chip_unmask_parent;\r\nicu->irq_chip.irq_eoi = irq_chip_eoi_parent;\r\nicu->irq_chip.irq_set_type = irq_chip_set_type_parent;\r\n#ifdef CONFIG_SMP\r\nicu->irq_chip.irq_set_affinity = irq_chip_set_affinity_parent;\r\n#endif\r\npdev->dev.msi_domain = of_msi_get_domain(&pdev->dev, node,\r\nDOMAIN_BUS_PLATFORM_MSI);\r\nif (!pdev->dev.msi_domain)\r\nreturn -EPROBE_DEFER;\r\ngicp_dn = irq_domain_get_of_node(pdev->dev.msi_domain);\r\nif (!gicp_dn)\r\nreturn -ENODEV;\r\nret = mvebu_gicp_get_doorbells(gicp_dn, &setspi, &clrspi);\r\nif (ret)\r\nreturn ret;\r\nwritel_relaxed(upper_32_bits(setspi), icu->base + ICU_SETSPI_NSR_AH);\r\nwritel_relaxed(lower_32_bits(setspi), icu->base + ICU_SETSPI_NSR_AL);\r\nwritel_relaxed(upper_32_bits(clrspi), icu->base + ICU_CLRSPI_NSR_AH);\r\nwritel_relaxed(lower_32_bits(clrspi), icu->base + ICU_CLRSPI_NSR_AL);\r\nfor (i = 0 ; i < ICU_MAX_IRQS ; i++) {\r\nicu_int = readl(icu->base + ICU_INT_CFG(i));\r\nif ((icu_int >> ICU_GROUP_SHIFT) == ICU_GRP_NSR)\r\nwritel_relaxed(0x0, icu->base + ICU_INT_CFG(i));\r\n}\r\nicu->domain =\r\nplatform_msi_create_device_domain(&pdev->dev, ICU_MAX_IRQS,\r\nmvebu_icu_write_msg,\r\n&mvebu_icu_domain_ops, icu);\r\nif (!icu->domain) {\r\ndev_err(&pdev->dev, "Failed to create ICU domain\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}
