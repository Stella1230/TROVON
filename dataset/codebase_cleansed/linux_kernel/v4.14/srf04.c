static irqreturn_t srf04_handle_irq(int irq, void *dev_id)\r\n{\r\nstruct iio_dev *indio_dev = dev_id;\r\nstruct srf04_data *data = iio_priv(indio_dev);\r\nktime_t now = ktime_get();\r\nif (gpiod_get_value(data->gpiod_echo)) {\r\ndata->ts_rising = now;\r\ncomplete(&data->rising);\r\n} else {\r\ndata->ts_falling = now;\r\ncomplete(&data->falling);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int srf04_read(struct srf04_data *data)\r\n{\r\nint ret;\r\nktime_t ktime_dt;\r\nu64 dt_ns;\r\nu32 time_ns, distance_mm;\r\nmutex_lock(&data->lock);\r\nreinit_completion(&data->rising);\r\nreinit_completion(&data->falling);\r\ngpiod_set_value(data->gpiod_trig, 1);\r\nudelay(10);\r\ngpiod_set_value(data->gpiod_trig, 0);\r\nret = wait_for_completion_killable_timeout(&data->rising, HZ/50);\r\nif (ret < 0) {\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n} else if (ret == 0) {\r\nmutex_unlock(&data->lock);\r\nreturn -ETIMEDOUT;\r\n}\r\nret = wait_for_completion_killable_timeout(&data->falling, HZ/50);\r\nif (ret < 0) {\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n} else if (ret == 0) {\r\nmutex_unlock(&data->lock);\r\nreturn -ETIMEDOUT;\r\n}\r\nktime_dt = ktime_sub(data->ts_falling, data->ts_rising);\r\nmutex_unlock(&data->lock);\r\ndt_ns = ktime_to_ns(ktime_dt);\r\nif (dt_ns > 9404389)\r\nreturn -EIO;\r\ntime_ns = dt_ns;\r\ndistance_mm = time_ns * 343 / 2000000;\r\nreturn distance_mm;\r\n}\r\nstatic int srf04_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *channel, int *val,\r\nint *val2, long info)\r\n{\r\nstruct srf04_data *data = iio_priv(indio_dev);\r\nint ret;\r\nif (channel->type != IIO_DISTANCE)\r\nreturn -EINVAL;\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = srf04_read(data);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = 0;\r\n*val2 = 1000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int srf04_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct srf04_data *data;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(struct srf04_data));\r\nif (!indio_dev) {\r\ndev_err(dev, "failed to allocate IIO device\n");\r\nreturn -ENOMEM;\r\n}\r\ndata = iio_priv(indio_dev);\r\ndata->dev = dev;\r\nmutex_init(&data->lock);\r\ninit_completion(&data->rising);\r\ninit_completion(&data->falling);\r\ndata->gpiod_trig = devm_gpiod_get(dev, "trig", GPIOD_OUT_LOW);\r\nif (IS_ERR(data->gpiod_trig)) {\r\ndev_err(dev, "failed to get trig-gpios: err=%ld\n",\r\nPTR_ERR(data->gpiod_trig));\r\nreturn PTR_ERR(data->gpiod_trig);\r\n}\r\ndata->gpiod_echo = devm_gpiod_get(dev, "echo", GPIOD_IN);\r\nif (IS_ERR(data->gpiod_echo)) {\r\ndev_err(dev, "failed to get echo-gpios: err=%ld\n",\r\nPTR_ERR(data->gpiod_echo));\r\nreturn PTR_ERR(data->gpiod_echo);\r\n}\r\nif (gpiod_cansleep(data->gpiod_echo)) {\r\ndev_err(data->dev, "cansleep-GPIOs not supported\n");\r\nreturn -ENODEV;\r\n}\r\ndata->irqnr = gpiod_to_irq(data->gpiod_echo);\r\nif (data->irqnr < 0) {\r\ndev_err(data->dev, "gpiod_to_irq: %d\n", data->irqnr);\r\nreturn data->irqnr;\r\n}\r\nret = devm_request_irq(dev, data->irqnr, srf04_handle_irq,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\npdev->name, indio_dev);\r\nif (ret < 0) {\r\ndev_err(data->dev, "request_irq: %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, indio_dev);\r\nindio_dev->name = "srf04";\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->info = &srf04_iio_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = srf04_chan_spec;\r\nindio_dev->num_channels = ARRAY_SIZE(srf04_chan_spec);\r\nreturn devm_iio_device_register(dev, indio_dev);\r\n}
