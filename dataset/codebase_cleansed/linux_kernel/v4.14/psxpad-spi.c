static int psxpad_command(struct psxpad *pad, const u8 sendcmdlen)\r\n{\r\nstruct spi_transfer xfers = {\r\n.tx_buf = pad->sendbuf,\r\n.rx_buf = pad->response,\r\n.len = sendcmdlen,\r\n};\r\nint err;\r\nerr = spi_sync_transfer(pad->spi, &xfers, 1);\r\nif (err) {\r\ndev_err(&pad->spi->dev,\r\n"%s: failed to SPI xfers mode: %d\n",\r\n__func__, err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void psxpad_control_motor(struct psxpad *pad,\r\nbool motor1enable, bool motor2enable)\r\n{\r\nint err;\r\npad->motor1enable = motor1enable;\r\npad->motor2enable = motor2enable;\r\nmemcpy(pad->sendbuf, PSX_CMD_ENTER_CFG, sizeof(PSX_CMD_ENTER_CFG));\r\nerr = psxpad_command(pad, sizeof(PSX_CMD_ENTER_CFG));\r\nif (err) {\r\ndev_err(&pad->spi->dev,\r\n"%s: failed to enter config mode: %d\n",\r\n__func__, err);\r\nreturn;\r\n}\r\nmemcpy(pad->sendbuf, PSX_CMD_ENABLE_MOTOR,\r\nsizeof(PSX_CMD_ENABLE_MOTOR));\r\npad->sendbuf[3] = pad->motor1enable ? 0x00 : 0xFF;\r\npad->sendbuf[4] = pad->motor2enable ? 0x80 : 0xFF;\r\nerr = psxpad_command(pad, sizeof(PSX_CMD_ENABLE_MOTOR));\r\nif (err) {\r\ndev_err(&pad->spi->dev,\r\n"%s: failed to enable motor mode: %d\n",\r\n__func__, err);\r\nreturn;\r\n}\r\nmemcpy(pad->sendbuf, PSX_CMD_EXIT_CFG, sizeof(PSX_CMD_EXIT_CFG));\r\nerr = psxpad_command(pad, sizeof(PSX_CMD_EXIT_CFG));\r\nif (err) {\r\ndev_err(&pad->spi->dev,\r\n"%s: failed to exit config mode: %d\n",\r\n__func__, err);\r\nreturn;\r\n}\r\n}\r\nstatic void psxpad_set_motor_level(struct psxpad *pad,\r\nu8 motor1level, u8 motor2level)\r\n{\r\npad->motor1level = motor1level ? 0xFF : 0x00;\r\npad->motor2level = REVERSE_BIT(motor2level);\r\n}\r\nstatic int psxpad_spi_play_effect(struct input_dev *idev,\r\nvoid *data, struct ff_effect *effect)\r\n{\r\nstruct input_polled_dev *pdev = input_get_drvdata(idev);\r\nstruct psxpad *pad = pdev->private;\r\nswitch (effect->type) {\r\ncase FF_RUMBLE:\r\npsxpad_set_motor_level(pad,\r\n(effect->u.rumble.weak_magnitude >> 8) & 0xFFU,\r\n(effect->u.rumble.strong_magnitude >> 8) & 0xFFU);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int psxpad_spi_init_ff(struct psxpad *pad)\r\n{\r\nint err;\r\ninput_set_capability(pad->pdev->input, EV_FF, FF_RUMBLE);\r\nerr = input_ff_create_memless(pad->pdev->input, NULL,\r\npsxpad_spi_play_effect);\r\nif (err) {\r\ndev_err(&pad->spi->dev,\r\n"input_ff_create_memless() failed: %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void psxpad_control_motor(struct psxpad *pad,\r\nbool motor1enable, bool motor2enable)\r\n{\r\n}\r\nstatic void psxpad_set_motor_level(struct psxpad *pad,\r\nu8 motor1level, u8 motor2level)\r\n{\r\n}\r\nstatic inline int psxpad_spi_init_ff(struct psxpad *pad)\r\n{\r\nreturn 0;\r\n}\r\nstatic void psxpad_spi_poll_open(struct input_polled_dev *pdev)\r\n{\r\nstruct psxpad *pad = pdev->private;\r\npm_runtime_get_sync(&pad->spi->dev);\r\n}\r\nstatic void psxpad_spi_poll_close(struct input_polled_dev *pdev)\r\n{\r\nstruct psxpad *pad = pdev->private;\r\npm_runtime_put_sync(&pad->spi->dev);\r\n}\r\nstatic void psxpad_spi_poll(struct input_polled_dev *pdev)\r\n{\r\nstruct psxpad *pad = pdev->private;\r\nstruct input_dev *input = pdev->input;\r\nu8 b_rsp3, b_rsp4;\r\nint err;\r\npsxpad_control_motor(pad, true, true);\r\nmemcpy(pad->sendbuf, PSX_CMD_POLL, sizeof(PSX_CMD_POLL));\r\npad->sendbuf[3] = pad->motor1enable ? pad->motor1level : 0x00;\r\npad->sendbuf[4] = pad->motor2enable ? pad->motor2level : 0x00;\r\nerr = psxpad_command(pad, sizeof(PSX_CMD_POLL));\r\nif (err) {\r\ndev_err(&pad->spi->dev,\r\n"%s: poll command failed mode: %d\n", __func__, err);\r\nreturn;\r\n}\r\nswitch (pad->response[1]) {\r\ncase 0xCE:\r\nb_rsp3 = ~pad->response[3];\r\nb_rsp4 = ~pad->response[4];\r\ninput_report_abs(input, ABS_X, REVERSE_BIT(pad->response[7]));\r\ninput_report_abs(input, ABS_Y, REVERSE_BIT(pad->response[8]));\r\ninput_report_abs(input, ABS_RX, REVERSE_BIT(pad->response[5]));\r\ninput_report_abs(input, ABS_RY, REVERSE_BIT(pad->response[6]));\r\ninput_report_key(input, BTN_DPAD_UP, b_rsp3 & BIT(3));\r\ninput_report_key(input, BTN_DPAD_DOWN, b_rsp3 & BIT(1));\r\ninput_report_key(input, BTN_DPAD_LEFT, b_rsp3 & BIT(0));\r\ninput_report_key(input, BTN_DPAD_RIGHT, b_rsp3 & BIT(2));\r\ninput_report_key(input, BTN_X, b_rsp4 & BIT(3));\r\ninput_report_key(input, BTN_A, b_rsp4 & BIT(2));\r\ninput_report_key(input, BTN_B, b_rsp4 & BIT(1));\r\ninput_report_key(input, BTN_Y, b_rsp4 & BIT(0));\r\ninput_report_key(input, BTN_TL, b_rsp4 & BIT(5));\r\ninput_report_key(input, BTN_TR, b_rsp4 & BIT(4));\r\ninput_report_key(input, BTN_TL2, b_rsp4 & BIT(7));\r\ninput_report_key(input, BTN_TR2, b_rsp4 & BIT(6));\r\ninput_report_key(input, BTN_THUMBL, b_rsp3 & BIT(6));\r\ninput_report_key(input, BTN_THUMBR, b_rsp3 & BIT(5));\r\ninput_report_key(input, BTN_SELECT, b_rsp3 & BIT(7));\r\ninput_report_key(input, BTN_START, b_rsp3 & BIT(4));\r\nbreak;\r\ncase 0x82:\r\nb_rsp3 = ~pad->response[3];\r\nb_rsp4 = ~pad->response[4];\r\ninput_report_abs(input, ABS_X, 0x80);\r\ninput_report_abs(input, ABS_Y, 0x80);\r\ninput_report_abs(input, ABS_RX, 0x80);\r\ninput_report_abs(input, ABS_RY, 0x80);\r\ninput_report_key(input, BTN_DPAD_UP, b_rsp3 & BIT(3));\r\ninput_report_key(input, BTN_DPAD_DOWN, b_rsp3 & BIT(1));\r\ninput_report_key(input, BTN_DPAD_LEFT, b_rsp3 & BIT(0));\r\ninput_report_key(input, BTN_DPAD_RIGHT, b_rsp3 & BIT(2));\r\ninput_report_key(input, BTN_X, b_rsp4 & BIT(3));\r\ninput_report_key(input, BTN_A, b_rsp4 & BIT(2));\r\ninput_report_key(input, BTN_B, b_rsp4 & BIT(1));\r\ninput_report_key(input, BTN_Y, b_rsp4 & BIT(0));\r\ninput_report_key(input, BTN_TL, b_rsp4 & BIT(5));\r\ninput_report_key(input, BTN_TR, b_rsp4 & BIT(4));\r\ninput_report_key(input, BTN_TL2, b_rsp4 & BIT(7));\r\ninput_report_key(input, BTN_TR2, b_rsp4 & BIT(6));\r\ninput_report_key(input, BTN_THUMBL, false);\r\ninput_report_key(input, BTN_THUMBR, false);\r\ninput_report_key(input, BTN_SELECT, b_rsp3 & BIT(7));\r\ninput_report_key(input, BTN_START, b_rsp3 & BIT(4));\r\nbreak;\r\n}\r\ninput_sync(input);\r\n}\r\nstatic int psxpad_spi_probe(struct spi_device *spi)\r\n{\r\nstruct psxpad *pad;\r\nstruct input_polled_dev *pdev;\r\nstruct input_dev *idev;\r\nint err;\r\npad = devm_kzalloc(&spi->dev, sizeof(struct psxpad), GFP_KERNEL);\r\nif (!pad)\r\nreturn -ENOMEM;\r\npdev = input_allocate_polled_device();\r\nif (!pdev) {\r\ndev_err(&spi->dev, "failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\npad->pdev = pdev;\r\npad->spi = spi;\r\npdev->private = pad;\r\npdev->open = psxpad_spi_poll_open;\r\npdev->close = psxpad_spi_poll_close;\r\npdev->poll = psxpad_spi_poll;\r\npdev->poll_interval = 16;\r\npdev->poll_interval_min = 8;\r\npdev->poll_interval_max = 32;\r\nidev = pdev->input;\r\nidev->name = "PlayStation 1/2 joypad";\r\nsnprintf(pad->phys, sizeof(pad->phys), "%s/input", dev_name(&spi->dev));\r\nidev->id.bustype = BUS_SPI;\r\ninput_set_abs_params(idev, ABS_X, 0, 255, 0, 0);\r\ninput_set_abs_params(idev, ABS_Y, 0, 255, 0, 0);\r\ninput_set_abs_params(idev, ABS_RX, 0, 255, 0, 0);\r\ninput_set_abs_params(idev, ABS_RY, 0, 255, 0, 0);\r\ninput_set_capability(idev, EV_KEY, BTN_DPAD_UP);\r\ninput_set_capability(idev, EV_KEY, BTN_DPAD_DOWN);\r\ninput_set_capability(idev, EV_KEY, BTN_DPAD_LEFT);\r\ninput_set_capability(idev, EV_KEY, BTN_DPAD_RIGHT);\r\ninput_set_capability(idev, EV_KEY, BTN_A);\r\ninput_set_capability(idev, EV_KEY, BTN_B);\r\ninput_set_capability(idev, EV_KEY, BTN_X);\r\ninput_set_capability(idev, EV_KEY, BTN_Y);\r\ninput_set_capability(idev, EV_KEY, BTN_TL);\r\ninput_set_capability(idev, EV_KEY, BTN_TR);\r\ninput_set_capability(idev, EV_KEY, BTN_TL2);\r\ninput_set_capability(idev, EV_KEY, BTN_TR2);\r\ninput_set_capability(idev, EV_KEY, BTN_THUMBL);\r\ninput_set_capability(idev, EV_KEY, BTN_THUMBR);\r\ninput_set_capability(idev, EV_KEY, BTN_SELECT);\r\ninput_set_capability(idev, EV_KEY, BTN_START);\r\nerr = psxpad_spi_init_ff(pad);\r\nif (err)\r\nreturn err;\r\nspi->mode = SPI_MODE_3;\r\nspi->bits_per_word = 8;\r\nspi->master->min_speed_hz = 125000;\r\nspi->master->max_speed_hz = 125000;\r\nspi_setup(spi);\r\npsxpad_set_motor_level(pad, 0, 0);\r\nerr = input_register_polled_device(pdev);\r\nif (err) {\r\ndev_err(&spi->dev,\r\n"failed to register input poll device: %d\n", err);\r\nreturn err;\r\n}\r\npm_runtime_enable(&spi->dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused psxpad_spi_suspend(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct psxpad *pad = spi_get_drvdata(spi);\r\npsxpad_set_motor_level(pad, 0, 0);\r\nreturn 0;\r\n}
