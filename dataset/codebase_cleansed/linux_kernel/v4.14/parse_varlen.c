static int tcp(void *data, uint64_t tp_off, void *data_end)\r\n{\r\nstruct tcphdr *tcp = data + tp_off;\r\nif (tcp + 1 > data_end)\r\nreturn 0;\r\nif (tcp->dest == htons(80) || tcp->source == htons(80))\r\nreturn TC_ACT_SHOT;\r\nreturn 0;\r\n}\r\nstatic int udp(void *data, uint64_t tp_off, void *data_end)\r\n{\r\nstruct udphdr *udp = data + tp_off;\r\nif (udp + 1 > data_end)\r\nreturn 0;\r\nif (udp->dest == htons(DEFAULT_PKTGEN_UDP_PORT) ||\r\nudp->source == htons(DEFAULT_PKTGEN_UDP_PORT)) {\r\nif (DEBUG) {\r\nchar fmt[] = "udp port 9 indeed\n";\r\nbpf_trace_printk(fmt, sizeof(fmt));\r\n}\r\nreturn TC_ACT_SHOT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_ipv4(void *data, uint64_t nh_off, void *data_end)\r\n{\r\nstruct iphdr *iph;\r\nuint64_t ihl_len;\r\niph = data + nh_off;\r\nif (iph + 1 > data_end)\r\nreturn 0;\r\nif (ip_is_fragment(iph))\r\nreturn 0;\r\nihl_len = iph->ihl * 4;\r\nif (iph->protocol == IPPROTO_IPIP) {\r\niph = data + nh_off + ihl_len;\r\nif (iph + 1 > data_end)\r\nreturn 0;\r\nihl_len += iph->ihl * 4;\r\n}\r\nif (iph->protocol == IPPROTO_TCP)\r\nreturn tcp(data, nh_off + ihl_len, data_end);\r\nelse if (iph->protocol == IPPROTO_UDP)\r\nreturn udp(data, nh_off + ihl_len, data_end);\r\nreturn 0;\r\n}\r\nstatic int parse_ipv6(void *data, uint64_t nh_off, void *data_end)\r\n{\r\nstruct ipv6hdr *ip6h;\r\nstruct iphdr *iph;\r\nuint64_t ihl_len = sizeof(struct ipv6hdr);\r\nuint64_t nexthdr;\r\nip6h = data + nh_off;\r\nif (ip6h + 1 > data_end)\r\nreturn 0;\r\nnexthdr = ip6h->nexthdr;\r\nif (nexthdr == IPPROTO_IPIP) {\r\niph = data + nh_off + ihl_len;\r\nif (iph + 1 > data_end)\r\nreturn 0;\r\nihl_len += iph->ihl * 4;\r\nnexthdr = iph->protocol;\r\n} else if (nexthdr == IPPROTO_IPV6) {\r\nip6h = data + nh_off + ihl_len;\r\nif (ip6h + 1 > data_end)\r\nreturn 0;\r\nihl_len += sizeof(struct ipv6hdr);\r\nnexthdr = ip6h->nexthdr;\r\n}\r\nif (nexthdr == IPPROTO_TCP)\r\nreturn tcp(data, nh_off + ihl_len, data_end);\r\nelse if (nexthdr == IPPROTO_UDP)\r\nreturn udp(data, nh_off + ihl_len, data_end);\r\nreturn 0;\r\n}\r\nint handle_ingress(struct __sk_buff *skb)\r\n{\r\nvoid *data = (void *)(long)skb->data;\r\nstruct ethhdr *eth = data;\r\nvoid *data_end = (void *)(long)skb->data_end;\r\nuint64_t h_proto, nh_off;\r\nnh_off = sizeof(*eth);\r\nif (data + nh_off > data_end)\r\nreturn 0;\r\nh_proto = eth->h_proto;\r\nif (h_proto == ETH_P_8021Q || h_proto == ETH_P_8021AD) {\r\nstruct vlan_hdr *vhdr;\r\nvhdr = data + nh_off;\r\nnh_off += sizeof(struct vlan_hdr);\r\nif (data + nh_off > data_end)\r\nreturn 0;\r\nh_proto = vhdr->h_vlan_encapsulated_proto;\r\n}\r\nif (h_proto == ETH_P_8021Q || h_proto == ETH_P_8021AD) {\r\nstruct vlan_hdr *vhdr;\r\nvhdr = data + nh_off;\r\nnh_off += sizeof(struct vlan_hdr);\r\nif (data + nh_off > data_end)\r\nreturn 0;\r\nh_proto = vhdr->h_vlan_encapsulated_proto;\r\n}\r\nif (h_proto == htons(ETH_P_IP))\r\nreturn parse_ipv4(data, nh_off, data_end);\r\nelse if (h_proto == htons(ETH_P_IPV6))\r\nreturn parse_ipv6(data, nh_off, data_end);\r\nreturn 0;\r\n}
