static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\r\n{\r\nva_list args;\r\nva_start(args, fmt);\r\nif (m)\r\nseq_vprintf(m, fmt, args);\r\nelse\r\nvprintk(fmt, args);\r\nva_end(args);\r\n}\r\nstatic void print_name_offset(struct seq_file *m, void *sym)\r\n{\r\nchar symname[KSYM_NAME_LEN];\r\nif (lookup_symbol_name((unsigned long)sym, symname) < 0)\r\nSEQ_printf(m, "<%pK>", sym);\r\nelse\r\nSEQ_printf(m, "%s", symname);\r\n}\r\nstatic void\r\nprint_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\r\nint idx, u64 now)\r\n{\r\nSEQ_printf(m, " #%d: ", idx);\r\nprint_name_offset(m, taddr);\r\nSEQ_printf(m, ", ");\r\nprint_name_offset(m, timer->function);\r\nSEQ_printf(m, ", S:%02x", timer->state);\r\nSEQ_printf(m, "\n");\r\nSEQ_printf(m, " # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\n",\r\n(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\r\n(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\r\n(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\r\n(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\r\n}\r\nstatic void\r\nprint_active_timers(struct seq_file *m, struct hrtimer_clock_base *base,\r\nu64 now)\r\n{\r\nstruct hrtimer *timer, tmp;\r\nunsigned long next = 0, i;\r\nstruct timerqueue_node *curr;\r\nunsigned long flags;\r\nnext_one:\r\ni = 0;\r\ntouch_nmi_watchdog();\r\nraw_spin_lock_irqsave(&base->cpu_base->lock, flags);\r\ncurr = timerqueue_getnext(&base->active);\r\nwhile (curr && i < next) {\r\ncurr = timerqueue_iterate_next(curr);\r\ni++;\r\n}\r\nif (curr) {\r\ntimer = container_of(curr, struct hrtimer, node);\r\ntmp = *timer;\r\nraw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\r\nprint_timer(m, timer, &tmp, i, now);\r\nnext++;\r\ngoto next_one;\r\n}\r\nraw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\r\n}\r\nstatic void\r\nprint_base(struct seq_file *m, struct hrtimer_clock_base *base, u64 now)\r\n{\r\nSEQ_printf(m, " .base: %pK\n", base);\r\nSEQ_printf(m, " .index: %d\n", base->index);\r\nSEQ_printf(m, " .resolution: %u nsecs\n", hrtimer_resolution);\r\nSEQ_printf(m, " .get_time: ");\r\nprint_name_offset(m, base->get_time);\r\nSEQ_printf(m, "\n");\r\n#ifdef CONFIG_HIGH_RES_TIMERS\r\nSEQ_printf(m, " .offset: %Lu nsecs\n",\r\n(unsigned long long) ktime_to_ns(base->offset));\r\n#endif\r\nSEQ_printf(m, "active timers:\n");\r\nprint_active_timers(m, base, now + ktime_to_ns(base->offset));\r\n}\r\nstatic void print_cpu(struct seq_file *m, int cpu, u64 now)\r\n{\r\nstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\r\nint i;\r\nSEQ_printf(m, "cpu: %d\n", cpu);\r\nfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\r\nSEQ_printf(m, " clock %d:\n", i);\r\nprint_base(m, cpu_base->clock_base + i, now);\r\n}\r\n#define P(x) \\r\nSEQ_printf(m, " .%-15s: %Lu\n", #x, \\r\n(unsigned long long)(cpu_base->x))\r\n#define P_ns(x) \\r\nSEQ_printf(m, " .%-15s: %Lu nsecs\n", #x, \\r\n(unsigned long long)(ktime_to_ns(cpu_base->x)))\r\n#ifdef CONFIG_HIGH_RES_TIMERS\r\nP_ns(expires_next);\r\nP(hres_active);\r\nP(nr_events);\r\nP(nr_retries);\r\nP(nr_hangs);\r\nP(max_hang_time);\r\n#endif\r\n#undef P\r\n#undef P_ns\r\n#ifdef CONFIG_TICK_ONESHOT\r\n# define P(x) \\r\nSEQ_printf(m, " .%-15s: %Lu\n", #x, \\r\n(unsigned long long)(ts->x))\r\n# define P_ns(x) \\r\nSEQ_printf(m, " .%-15s: %Lu nsecs\n", #x, \\r\n(unsigned long long)(ktime_to_ns(ts->x)))\r\n{\r\nstruct tick_sched *ts = tick_get_tick_sched(cpu);\r\nP(nohz_mode);\r\nP_ns(last_tick);\r\nP(tick_stopped);\r\nP(idle_jiffies);\r\nP(idle_calls);\r\nP(idle_sleeps);\r\nP_ns(idle_entrytime);\r\nP_ns(idle_waketime);\r\nP_ns(idle_exittime);\r\nP_ns(idle_sleeptime);\r\nP_ns(iowait_sleeptime);\r\nP(last_jiffies);\r\nP(next_timer);\r\nP_ns(idle_expires);\r\nSEQ_printf(m, "jiffies: %Lu\n",\r\n(unsigned long long)jiffies);\r\n}\r\n#endif\r\n#undef P\r\n#undef P_ns\r\nSEQ_printf(m, "\n");\r\n}\r\nstatic void\r\nprint_tickdevice(struct seq_file *m, struct tick_device *td, int cpu)\r\n{\r\nstruct clock_event_device *dev = td->evtdev;\r\ntouch_nmi_watchdog();\r\nSEQ_printf(m, "Tick Device: mode: %d\n", td->mode);\r\nif (cpu < 0)\r\nSEQ_printf(m, "Broadcast device\n");\r\nelse\r\nSEQ_printf(m, "Per CPU device: %d\n", cpu);\r\nSEQ_printf(m, "Clock Event Device: ");\r\nif (!dev) {\r\nSEQ_printf(m, "<NULL>\n");\r\nreturn;\r\n}\r\nSEQ_printf(m, "%s\n", dev->name);\r\nSEQ_printf(m, " max_delta_ns: %llu\n",\r\n(unsigned long long) dev->max_delta_ns);\r\nSEQ_printf(m, " min_delta_ns: %llu\n",\r\n(unsigned long long) dev->min_delta_ns);\r\nSEQ_printf(m, " mult: %u\n", dev->mult);\r\nSEQ_printf(m, " shift: %u\n", dev->shift);\r\nSEQ_printf(m, " mode: %d\n", clockevent_get_state(dev));\r\nSEQ_printf(m, " next_event: %Ld nsecs\n",\r\n(unsigned long long) ktime_to_ns(dev->next_event));\r\nSEQ_printf(m, " set_next_event: ");\r\nprint_name_offset(m, dev->set_next_event);\r\nSEQ_printf(m, "\n");\r\nif (dev->set_state_shutdown) {\r\nSEQ_printf(m, " shutdown: ");\r\nprint_name_offset(m, dev->set_state_shutdown);\r\nSEQ_printf(m, "\n");\r\n}\r\nif (dev->set_state_periodic) {\r\nSEQ_printf(m, " periodic: ");\r\nprint_name_offset(m, dev->set_state_periodic);\r\nSEQ_printf(m, "\n");\r\n}\r\nif (dev->set_state_oneshot) {\r\nSEQ_printf(m, " oneshot: ");\r\nprint_name_offset(m, dev->set_state_oneshot);\r\nSEQ_printf(m, "\n");\r\n}\r\nif (dev->set_state_oneshot_stopped) {\r\nSEQ_printf(m, " oneshot stopped: ");\r\nprint_name_offset(m, dev->set_state_oneshot_stopped);\r\nSEQ_printf(m, "\n");\r\n}\r\nif (dev->tick_resume) {\r\nSEQ_printf(m, " resume: ");\r\nprint_name_offset(m, dev->tick_resume);\r\nSEQ_printf(m, "\n");\r\n}\r\nSEQ_printf(m, " event_handler: ");\r\nprint_name_offset(m, dev->event_handler);\r\nSEQ_printf(m, "\n");\r\nSEQ_printf(m, " retries: %lu\n", dev->retries);\r\nSEQ_printf(m, "\n");\r\n}\r\nstatic void timer_list_show_tickdevices_header(struct seq_file *m)\r\n{\r\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\r\nprint_tickdevice(m, tick_get_broadcast_device(), -1);\r\nSEQ_printf(m, "tick_broadcast_mask: %*pb\n",\r\ncpumask_pr_args(tick_get_broadcast_mask()));\r\n#ifdef CONFIG_TICK_ONESHOT\r\nSEQ_printf(m, "tick_broadcast_oneshot_mask: %*pb\n",\r\ncpumask_pr_args(tick_get_broadcast_oneshot_mask()));\r\n#endif\r\nSEQ_printf(m, "\n");\r\n#endif\r\n}\r\nstatic inline void timer_list_header(struct seq_file *m, u64 now)\r\n{\r\nSEQ_printf(m, "Timer List Version: v0.8\n");\r\nSEQ_printf(m, "HRTIMER_MAX_CLOCK_BASES: %d\n", HRTIMER_MAX_CLOCK_BASES);\r\nSEQ_printf(m, "now at %Ld nsecs\n", (unsigned long long)now);\r\nSEQ_printf(m, "\n");\r\n}\r\nstatic int timer_list_show(struct seq_file *m, void *v)\r\n{\r\nstruct timer_list_iter *iter = v;\r\nif (iter->cpu == -1 && !iter->second_pass)\r\ntimer_list_header(m, iter->now);\r\nelse if (!iter->second_pass)\r\nprint_cpu(m, iter->cpu, iter->now);\r\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\r\nelse if (iter->cpu == -1 && iter->second_pass)\r\ntimer_list_show_tickdevices_header(m);\r\nelse\r\nprint_tickdevice(m, tick_get_device(iter->cpu), iter->cpu);\r\n#endif\r\nreturn 0;\r\n}\r\nvoid sysrq_timer_list_show(void)\r\n{\r\nu64 now = ktime_to_ns(ktime_get());\r\nint cpu;\r\ntimer_list_header(NULL, now);\r\nfor_each_online_cpu(cpu)\r\nprint_cpu(NULL, cpu, now);\r\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\r\ntimer_list_show_tickdevices_header(NULL);\r\nfor_each_online_cpu(cpu)\r\nprint_tickdevice(NULL, tick_get_device(cpu), cpu);\r\n#endif\r\nreturn;\r\n}\r\nstatic void *move_iter(struct timer_list_iter *iter, loff_t offset)\r\n{\r\nfor (; offset; offset--) {\r\niter->cpu = cpumask_next(iter->cpu, cpu_online_mask);\r\nif (iter->cpu >= nr_cpu_ids) {\r\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\r\nif (!iter->second_pass) {\r\niter->cpu = -1;\r\niter->second_pass = true;\r\n} else\r\nreturn NULL;\r\n#else\r\nreturn NULL;\r\n#endif\r\n}\r\n}\r\nreturn iter;\r\n}\r\nstatic void *timer_list_start(struct seq_file *file, loff_t *offset)\r\n{\r\nstruct timer_list_iter *iter = file->private;\r\nif (!*offset)\r\niter->now = ktime_to_ns(ktime_get());\r\niter->cpu = -1;\r\niter->second_pass = false;\r\nreturn move_iter(iter, *offset);\r\n}\r\nstatic void *timer_list_next(struct seq_file *file, void *v, loff_t *offset)\r\n{\r\nstruct timer_list_iter *iter = file->private;\r\n++*offset;\r\nreturn move_iter(iter, 1);\r\n}\r\nstatic void timer_list_stop(struct seq_file *seq, void *v)\r\n{\r\n}\r\nstatic int timer_list_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn seq_open_private(filp, &timer_list_sops,\r\nsizeof(struct timer_list_iter));\r\n}\r\nstatic int __init init_timer_list_procfs(void)\r\n{\r\nstruct proc_dir_entry *pe;\r\npe = proc_create("timer_list", 0444, NULL, &timer_list_fops);\r\nif (!pe)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}
