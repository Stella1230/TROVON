int\r\nxfs_rmap_lookup_le(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len,\r\nuint64_t owner,\r\nuint64_t offset,\r\nunsigned int flags,\r\nint *stat)\r\n{\r\ncur->bc_rec.r.rm_startblock = bno;\r\ncur->bc_rec.r.rm_blockcount = len;\r\ncur->bc_rec.r.rm_owner = owner;\r\ncur->bc_rec.r.rm_offset = offset;\r\ncur->bc_rec.r.rm_flags = flags;\r\nreturn xfs_btree_lookup(cur, XFS_LOOKUP_LE, stat);\r\n}\r\nint\r\nxfs_rmap_lookup_eq(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len,\r\nuint64_t owner,\r\nuint64_t offset,\r\nunsigned int flags,\r\nint *stat)\r\n{\r\ncur->bc_rec.r.rm_startblock = bno;\r\ncur->bc_rec.r.rm_blockcount = len;\r\ncur->bc_rec.r.rm_owner = owner;\r\ncur->bc_rec.r.rm_offset = offset;\r\ncur->bc_rec.r.rm_flags = flags;\r\nreturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\r\n}\r\nSTATIC int\r\nxfs_rmap_update(\r\nstruct xfs_btree_cur *cur,\r\nstruct xfs_rmap_irec *irec)\r\n{\r\nunion xfs_btree_rec rec;\r\nint error;\r\ntrace_xfs_rmap_update(cur->bc_mp, cur->bc_private.a.agno,\r\nirec->rm_startblock, irec->rm_blockcount,\r\nirec->rm_owner, irec->rm_offset, irec->rm_flags);\r\nrec.rmap.rm_startblock = cpu_to_be32(irec->rm_startblock);\r\nrec.rmap.rm_blockcount = cpu_to_be32(irec->rm_blockcount);\r\nrec.rmap.rm_owner = cpu_to_be64(irec->rm_owner);\r\nrec.rmap.rm_offset = cpu_to_be64(\r\nxfs_rmap_irec_offset_pack(irec));\r\nerror = xfs_btree_update(cur, &rec);\r\nif (error)\r\ntrace_xfs_rmap_update_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nint\r\nxfs_rmap_insert(\r\nstruct xfs_btree_cur *rcur,\r\nxfs_agblock_t agbno,\r\nxfs_extlen_t len,\r\nuint64_t owner,\r\nuint64_t offset,\r\nunsigned int flags)\r\n{\r\nint i;\r\nint error;\r\ntrace_xfs_rmap_insert(rcur->bc_mp, rcur->bc_private.a.agno, agbno,\r\nlen, owner, offset, flags);\r\nerror = xfs_rmap_lookup_eq(rcur, agbno, len, owner, offset, flags, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(rcur->bc_mp, i == 0, done);\r\nrcur->bc_rec.r.rm_startblock = agbno;\r\nrcur->bc_rec.r.rm_blockcount = len;\r\nrcur->bc_rec.r.rm_owner = owner;\r\nrcur->bc_rec.r.rm_offset = offset;\r\nrcur->bc_rec.r.rm_flags = flags;\r\nerror = xfs_btree_insert(rcur, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(rcur->bc_mp, i == 1, done);\r\ndone:\r\nif (error)\r\ntrace_xfs_rmap_insert_error(rcur->bc_mp,\r\nrcur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_rmap_delete(\r\nstruct xfs_btree_cur *rcur,\r\nxfs_agblock_t agbno,\r\nxfs_extlen_t len,\r\nuint64_t owner,\r\nuint64_t offset,\r\nunsigned int flags)\r\n{\r\nint i;\r\nint error;\r\ntrace_xfs_rmap_delete(rcur->bc_mp, rcur->bc_private.a.agno, agbno,\r\nlen, owner, offset, flags);\r\nerror = xfs_rmap_lookup_eq(rcur, agbno, len, owner, offset, flags, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(rcur->bc_mp, i == 1, done);\r\nerror = xfs_btree_delete(rcur, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(rcur->bc_mp, i == 1, done);\r\ndone:\r\nif (error)\r\ntrace_xfs_rmap_delete_error(rcur->bc_mp,\r\nrcur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nint\r\nxfs_rmap_btrec_to_irec(\r\nunion xfs_btree_rec *rec,\r\nstruct xfs_rmap_irec *irec)\r\n{\r\nirec->rm_flags = 0;\r\nirec->rm_startblock = be32_to_cpu(rec->rmap.rm_startblock);\r\nirec->rm_blockcount = be32_to_cpu(rec->rmap.rm_blockcount);\r\nirec->rm_owner = be64_to_cpu(rec->rmap.rm_owner);\r\nreturn xfs_rmap_irec_offset_unpack(be64_to_cpu(rec->rmap.rm_offset),\r\nirec);\r\n}\r\nint\r\nxfs_rmap_get_rec(\r\nstruct xfs_btree_cur *cur,\r\nstruct xfs_rmap_irec *irec,\r\nint *stat)\r\n{\r\nunion xfs_btree_rec *rec;\r\nint error;\r\nerror = xfs_btree_get_rec(cur, &rec, stat);\r\nif (error || !*stat)\r\nreturn error;\r\nreturn xfs_rmap_btrec_to_irec(rec, irec);\r\n}\r\nSTATIC int\r\nxfs_rmap_find_left_neighbor_helper(\r\nstruct xfs_btree_cur *cur,\r\nstruct xfs_rmap_irec *rec,\r\nvoid *priv)\r\n{\r\nstruct xfs_find_left_neighbor_info *info = priv;\r\ntrace_xfs_rmap_find_left_neighbor_candidate(cur->bc_mp,\r\ncur->bc_private.a.agno, rec->rm_startblock,\r\nrec->rm_blockcount, rec->rm_owner, rec->rm_offset,\r\nrec->rm_flags);\r\nif (rec->rm_owner != info->high.rm_owner)\r\nreturn XFS_BTREE_QUERY_RANGE_CONTINUE;\r\nif (!XFS_RMAP_NON_INODE_OWNER(rec->rm_owner) &&\r\n!(rec->rm_flags & XFS_RMAP_BMBT_BLOCK) &&\r\nrec->rm_offset + rec->rm_blockcount - 1 != info->high.rm_offset)\r\nreturn XFS_BTREE_QUERY_RANGE_CONTINUE;\r\n*info->irec = *rec;\r\n*info->stat = 1;\r\nreturn XFS_BTREE_QUERY_RANGE_ABORT;\r\n}\r\nint\r\nxfs_rmap_find_left_neighbor(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t bno,\r\nuint64_t owner,\r\nuint64_t offset,\r\nunsigned int flags,\r\nstruct xfs_rmap_irec *irec,\r\nint *stat)\r\n{\r\nstruct xfs_find_left_neighbor_info info;\r\nint error;\r\n*stat = 0;\r\nif (bno == 0)\r\nreturn 0;\r\ninfo.high.rm_startblock = bno - 1;\r\ninfo.high.rm_owner = owner;\r\nif (!XFS_RMAP_NON_INODE_OWNER(owner) &&\r\n!(flags & XFS_RMAP_BMBT_BLOCK)) {\r\nif (offset == 0)\r\nreturn 0;\r\ninfo.high.rm_offset = offset - 1;\r\n} else\r\ninfo.high.rm_offset = 0;\r\ninfo.high.rm_flags = flags;\r\ninfo.high.rm_blockcount = 0;\r\ninfo.irec = irec;\r\ninfo.stat = stat;\r\ntrace_xfs_rmap_find_left_neighbor_query(cur->bc_mp,\r\ncur->bc_private.a.agno, bno, 0, owner, offset, flags);\r\nerror = xfs_rmap_query_range(cur, &info.high, &info.high,\r\nxfs_rmap_find_left_neighbor_helper, &info);\r\nif (error == XFS_BTREE_QUERY_RANGE_ABORT)\r\nerror = 0;\r\nif (*stat)\r\ntrace_xfs_rmap_find_left_neighbor_result(cur->bc_mp,\r\ncur->bc_private.a.agno, irec->rm_startblock,\r\nirec->rm_blockcount, irec->rm_owner,\r\nirec->rm_offset, irec->rm_flags);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_rmap_lookup_le_range_helper(\r\nstruct xfs_btree_cur *cur,\r\nstruct xfs_rmap_irec *rec,\r\nvoid *priv)\r\n{\r\nstruct xfs_find_left_neighbor_info *info = priv;\r\ntrace_xfs_rmap_lookup_le_range_candidate(cur->bc_mp,\r\ncur->bc_private.a.agno, rec->rm_startblock,\r\nrec->rm_blockcount, rec->rm_owner, rec->rm_offset,\r\nrec->rm_flags);\r\nif (rec->rm_owner != info->high.rm_owner)\r\nreturn XFS_BTREE_QUERY_RANGE_CONTINUE;\r\nif (!XFS_RMAP_NON_INODE_OWNER(rec->rm_owner) &&\r\n!(rec->rm_flags & XFS_RMAP_BMBT_BLOCK) &&\r\n(rec->rm_offset > info->high.rm_offset ||\r\nrec->rm_offset + rec->rm_blockcount <= info->high.rm_offset))\r\nreturn XFS_BTREE_QUERY_RANGE_CONTINUE;\r\n*info->irec = *rec;\r\n*info->stat = 1;\r\nreturn XFS_BTREE_QUERY_RANGE_ABORT;\r\n}\r\nint\r\nxfs_rmap_lookup_le_range(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t bno,\r\nuint64_t owner,\r\nuint64_t offset,\r\nunsigned int flags,\r\nstruct xfs_rmap_irec *irec,\r\nint *stat)\r\n{\r\nstruct xfs_find_left_neighbor_info info;\r\nint error;\r\ninfo.high.rm_startblock = bno;\r\ninfo.high.rm_owner = owner;\r\nif (!XFS_RMAP_NON_INODE_OWNER(owner) && !(flags & XFS_RMAP_BMBT_BLOCK))\r\ninfo.high.rm_offset = offset;\r\nelse\r\ninfo.high.rm_offset = 0;\r\ninfo.high.rm_flags = flags;\r\ninfo.high.rm_blockcount = 0;\r\n*stat = 0;\r\ninfo.irec = irec;\r\ninfo.stat = stat;\r\ntrace_xfs_rmap_lookup_le_range(cur->bc_mp,\r\ncur->bc_private.a.agno, bno, 0, owner, offset, flags);\r\nerror = xfs_rmap_query_range(cur, &info.high, &info.high,\r\nxfs_rmap_lookup_le_range_helper, &info);\r\nif (error == XFS_BTREE_QUERY_RANGE_ABORT)\r\nerror = 0;\r\nif (*stat)\r\ntrace_xfs_rmap_lookup_le_range_result(cur->bc_mp,\r\ncur->bc_private.a.agno, irec->rm_startblock,\r\nirec->rm_blockcount, irec->rm_owner,\r\nirec->rm_offset, irec->rm_flags);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_rmap_unmap(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len,\r\nbool unwritten,\r\nstruct xfs_owner_info *oinfo)\r\n{\r\nstruct xfs_mount *mp = cur->bc_mp;\r\nstruct xfs_rmap_irec ltrec;\r\nuint64_t ltoff;\r\nint error = 0;\r\nint i;\r\nuint64_t owner;\r\nuint64_t offset;\r\nunsigned int flags;\r\nbool ignore_off;\r\nxfs_owner_info_unpack(oinfo, &owner, &offset, &flags);\r\nignore_off = XFS_RMAP_NON_INODE_OWNER(owner) ||\r\n(flags & XFS_RMAP_BMBT_BLOCK);\r\nif (unwritten)\r\nflags |= XFS_RMAP_UNWRITTEN;\r\ntrace_xfs_rmap_unmap(mp, cur->bc_private.a.agno, bno, len,\r\nunwritten, oinfo);\r\nerror = xfs_rmap_lookup_le(cur, bno, len, owner, offset, flags, &i);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, out_error);\r\nerror = xfs_rmap_get_rec(cur, &ltrec, &i);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, out_error);\r\ntrace_xfs_rmap_lookup_le_range_result(cur->bc_mp,\r\ncur->bc_private.a.agno, ltrec.rm_startblock,\r\nltrec.rm_blockcount, ltrec.rm_owner,\r\nltrec.rm_offset, ltrec.rm_flags);\r\nltoff = ltrec.rm_offset;\r\nif (owner == XFS_RMAP_OWN_NULL) {\r\nXFS_WANT_CORRUPTED_GOTO(mp, bno >= ltrec.rm_startblock +\r\nltrec.rm_blockcount, out_error);\r\ngoto out_done;\r\n}\r\nXFS_WANT_CORRUPTED_GOTO(mp, (flags & XFS_RMAP_UNWRITTEN) ==\r\n(ltrec.rm_flags & XFS_RMAP_UNWRITTEN), out_error);\r\nXFS_WANT_CORRUPTED_GOTO(mp, ltrec.rm_startblock <= bno &&\r\nltrec.rm_startblock + ltrec.rm_blockcount >=\r\nbno + len, out_error);\r\nXFS_WANT_CORRUPTED_GOTO(mp, owner == ltrec.rm_owner ||\r\nXFS_RMAP_NON_INODE_OWNER(owner), out_error);\r\nif (!XFS_RMAP_NON_INODE_OWNER(owner)) {\r\nif (flags & XFS_RMAP_BMBT_BLOCK) {\r\nXFS_WANT_CORRUPTED_GOTO(mp,\r\nltrec.rm_flags & XFS_RMAP_BMBT_BLOCK,\r\nout_error);\r\n} else {\r\nXFS_WANT_CORRUPTED_GOTO(mp,\r\nltrec.rm_offset <= offset, out_error);\r\nXFS_WANT_CORRUPTED_GOTO(mp,\r\nltoff + ltrec.rm_blockcount >= offset + len,\r\nout_error);\r\n}\r\n}\r\nif (ltrec.rm_startblock == bno && ltrec.rm_blockcount == len) {\r\ntrace_xfs_rmap_delete(mp, cur->bc_private.a.agno,\r\nltrec.rm_startblock, ltrec.rm_blockcount,\r\nltrec.rm_owner, ltrec.rm_offset,\r\nltrec.rm_flags);\r\nerror = xfs_btree_delete(cur, &i);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, out_error);\r\n} else if (ltrec.rm_startblock == bno) {\r\nltrec.rm_startblock += len;\r\nltrec.rm_blockcount -= len;\r\nif (!ignore_off)\r\nltrec.rm_offset += len;\r\nerror = xfs_rmap_update(cur, &ltrec);\r\nif (error)\r\ngoto out_error;\r\n} else if (ltrec.rm_startblock + ltrec.rm_blockcount == bno + len) {\r\nltrec.rm_blockcount -= len;\r\nerror = xfs_rmap_update(cur, &ltrec);\r\nif (error)\r\ngoto out_error;\r\n} else {\r\nxfs_extlen_t orig_len = ltrec.rm_blockcount;\r\nltrec.rm_blockcount = bno - ltrec.rm_startblock;\r\nerror = xfs_rmap_update(cur, &ltrec);\r\nif (error)\r\ngoto out_error;\r\nerror = xfs_btree_increment(cur, 0, &i);\r\nif (error)\r\ngoto out_error;\r\ncur->bc_rec.r.rm_startblock = bno + len;\r\ncur->bc_rec.r.rm_blockcount = orig_len - len -\r\nltrec.rm_blockcount;\r\ncur->bc_rec.r.rm_owner = ltrec.rm_owner;\r\nif (ignore_off)\r\ncur->bc_rec.r.rm_offset = 0;\r\nelse\r\ncur->bc_rec.r.rm_offset = offset + len;\r\ncur->bc_rec.r.rm_flags = flags;\r\ntrace_xfs_rmap_insert(mp, cur->bc_private.a.agno,\r\ncur->bc_rec.r.rm_startblock,\r\ncur->bc_rec.r.rm_blockcount,\r\ncur->bc_rec.r.rm_owner,\r\ncur->bc_rec.r.rm_offset,\r\ncur->bc_rec.r.rm_flags);\r\nerror = xfs_btree_insert(cur, &i);\r\nif (error)\r\ngoto out_error;\r\n}\r\nout_done:\r\ntrace_xfs_rmap_unmap_done(mp, cur->bc_private.a.agno, bno, len,\r\nunwritten, oinfo);\r\nout_error:\r\nif (error)\r\ntrace_xfs_rmap_unmap_error(mp, cur->bc_private.a.agno,\r\nerror, _RET_IP_);\r\nreturn error;\r\n}\r\nint\r\nxfs_rmap_free(\r\nstruct xfs_trans *tp,\r\nstruct xfs_buf *agbp,\r\nxfs_agnumber_t agno,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len,\r\nstruct xfs_owner_info *oinfo)\r\n{\r\nstruct xfs_mount *mp = tp->t_mountp;\r\nstruct xfs_btree_cur *cur;\r\nint error;\r\nif (!xfs_sb_version_hasrmapbt(&mp->m_sb))\r\nreturn 0;\r\ncur = xfs_rmapbt_init_cursor(mp, tp, agbp, agno);\r\nerror = xfs_rmap_unmap(cur, bno, len, false, oinfo);\r\nif (error)\r\ngoto out_error;\r\nxfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\r\nreturn 0;\r\nout_error:\r\nxfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\r\nreturn error;\r\n}\r\nstatic bool\r\nxfs_rmap_is_mergeable(\r\nstruct xfs_rmap_irec *irec,\r\nuint64_t owner,\r\nunsigned int flags)\r\n{\r\nif (irec->rm_owner == XFS_RMAP_OWN_NULL)\r\nreturn false;\r\nif (irec->rm_owner != owner)\r\nreturn false;\r\nif ((flags & XFS_RMAP_UNWRITTEN) ^\r\n(irec->rm_flags & XFS_RMAP_UNWRITTEN))\r\nreturn false;\r\nif ((flags & XFS_RMAP_ATTR_FORK) ^\r\n(irec->rm_flags & XFS_RMAP_ATTR_FORK))\r\nreturn false;\r\nif ((flags & XFS_RMAP_BMBT_BLOCK) ^\r\n(irec->rm_flags & XFS_RMAP_BMBT_BLOCK))\r\nreturn false;\r\nreturn true;\r\n}\r\nSTATIC int\r\nxfs_rmap_map(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len,\r\nbool unwritten,\r\nstruct xfs_owner_info *oinfo)\r\n{\r\nstruct xfs_mount *mp = cur->bc_mp;\r\nstruct xfs_rmap_irec ltrec;\r\nstruct xfs_rmap_irec gtrec;\r\nint have_gt;\r\nint have_lt;\r\nint error = 0;\r\nint i;\r\nuint64_t owner;\r\nuint64_t offset;\r\nunsigned int flags = 0;\r\nbool ignore_off;\r\nxfs_owner_info_unpack(oinfo, &owner, &offset, &flags);\r\nASSERT(owner != 0);\r\nignore_off = XFS_RMAP_NON_INODE_OWNER(owner) ||\r\n(flags & XFS_RMAP_BMBT_BLOCK);\r\nif (unwritten)\r\nflags |= XFS_RMAP_UNWRITTEN;\r\ntrace_xfs_rmap_map(mp, cur->bc_private.a.agno, bno, len,\r\nunwritten, oinfo);\r\nerror = xfs_rmap_lookup_le(cur, bno, len, owner, offset, flags,\r\n&have_lt);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(mp, have_lt == 1, out_error);\r\nerror = xfs_rmap_get_rec(cur, &ltrec, &have_lt);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(mp, have_lt == 1, out_error);\r\ntrace_xfs_rmap_lookup_le_range_result(cur->bc_mp,\r\ncur->bc_private.a.agno, ltrec.rm_startblock,\r\nltrec.rm_blockcount, ltrec.rm_owner,\r\nltrec.rm_offset, ltrec.rm_flags);\r\nif (!xfs_rmap_is_mergeable(&ltrec, owner, flags))\r\nhave_lt = 0;\r\nXFS_WANT_CORRUPTED_GOTO(mp,\r\nhave_lt == 0 ||\r\nltrec.rm_startblock + ltrec.rm_blockcount <= bno, out_error);\r\nerror = xfs_btree_increment(cur, 0, &have_gt);\r\nif (error)\r\ngoto out_error;\r\nif (have_gt) {\r\nerror = xfs_rmap_get_rec(cur, &gtrec, &have_gt);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(mp, have_gt == 1, out_error);\r\nXFS_WANT_CORRUPTED_GOTO(mp, bno + len <= gtrec.rm_startblock,\r\nout_error);\r\ntrace_xfs_rmap_find_right_neighbor_result(cur->bc_mp,\r\ncur->bc_private.a.agno, gtrec.rm_startblock,\r\ngtrec.rm_blockcount, gtrec.rm_owner,\r\ngtrec.rm_offset, gtrec.rm_flags);\r\nif (!xfs_rmap_is_mergeable(&gtrec, owner, flags))\r\nhave_gt = 0;\r\n}\r\nif (have_lt &&\r\nltrec.rm_startblock + ltrec.rm_blockcount == bno &&\r\n(ignore_off || ltrec.rm_offset + ltrec.rm_blockcount == offset)) {\r\nltrec.rm_blockcount += len;\r\nif (have_gt &&\r\nbno + len == gtrec.rm_startblock &&\r\n(ignore_off || offset + len == gtrec.rm_offset) &&\r\n(unsigned long)ltrec.rm_blockcount + len +\r\ngtrec.rm_blockcount <= XFS_RMAP_LEN_MAX) {\r\nltrec.rm_blockcount += gtrec.rm_blockcount;\r\ntrace_xfs_rmap_delete(mp, cur->bc_private.a.agno,\r\ngtrec.rm_startblock,\r\ngtrec.rm_blockcount,\r\ngtrec.rm_owner,\r\ngtrec.rm_offset,\r\ngtrec.rm_flags);\r\nerror = xfs_btree_delete(cur, &i);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, out_error);\r\n}\r\nerror = xfs_btree_decrement(cur, 0, &have_gt);\r\nif (error)\r\ngoto out_error;\r\nerror = xfs_rmap_update(cur, &ltrec);\r\nif (error)\r\ngoto out_error;\r\n} else if (have_gt &&\r\nbno + len == gtrec.rm_startblock &&\r\n(ignore_off || offset + len == gtrec.rm_offset)) {\r\ngtrec.rm_startblock = bno;\r\ngtrec.rm_blockcount += len;\r\nif (!ignore_off)\r\ngtrec.rm_offset = offset;\r\nerror = xfs_rmap_update(cur, &gtrec);\r\nif (error)\r\ngoto out_error;\r\n} else {\r\ncur->bc_rec.r.rm_startblock = bno;\r\ncur->bc_rec.r.rm_blockcount = len;\r\ncur->bc_rec.r.rm_owner = owner;\r\ncur->bc_rec.r.rm_offset = offset;\r\ncur->bc_rec.r.rm_flags = flags;\r\ntrace_xfs_rmap_insert(mp, cur->bc_private.a.agno, bno, len,\r\nowner, offset, flags);\r\nerror = xfs_btree_insert(cur, &i);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, out_error);\r\n}\r\ntrace_xfs_rmap_map_done(mp, cur->bc_private.a.agno, bno, len,\r\nunwritten, oinfo);\r\nout_error:\r\nif (error)\r\ntrace_xfs_rmap_map_error(mp, cur->bc_private.a.agno,\r\nerror, _RET_IP_);\r\nreturn error;\r\n}\r\nint\r\nxfs_rmap_alloc(\r\nstruct xfs_trans *tp,\r\nstruct xfs_buf *agbp,\r\nxfs_agnumber_t agno,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len,\r\nstruct xfs_owner_info *oinfo)\r\n{\r\nstruct xfs_mount *mp = tp->t_mountp;\r\nstruct xfs_btree_cur *cur;\r\nint error;\r\nif (!xfs_sb_version_hasrmapbt(&mp->m_sb))\r\nreturn 0;\r\ncur = xfs_rmapbt_init_cursor(mp, tp, agbp, agno);\r\nerror = xfs_rmap_map(cur, bno, len, false, oinfo);\r\nif (error)\r\ngoto out_error;\r\nxfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\r\nreturn 0;\r\nout_error:\r\nxfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_rmap_convert(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len,\r\nbool unwritten,\r\nstruct xfs_owner_info *oinfo)\r\n{\r\nstruct xfs_mount *mp = cur->bc_mp;\r\nstruct xfs_rmap_irec r[4];\r\nuint64_t owner;\r\nuint64_t offset;\r\nuint64_t new_endoff;\r\nunsigned int oldext;\r\nunsigned int newext;\r\nunsigned int flags = 0;\r\nint i;\r\nint state = 0;\r\nint error;\r\nxfs_owner_info_unpack(oinfo, &owner, &offset, &flags);\r\nASSERT(!(XFS_RMAP_NON_INODE_OWNER(owner) ||\r\n(flags & (XFS_RMAP_ATTR_FORK | XFS_RMAP_BMBT_BLOCK))));\r\noldext = unwritten ? XFS_RMAP_UNWRITTEN : 0;\r\nnew_endoff = offset + len;\r\ntrace_xfs_rmap_convert(mp, cur->bc_private.a.agno, bno, len,\r\nunwritten, oinfo);\r\nerror = xfs_rmap_lookup_le(cur, bno, len, owner, offset, oldext, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nerror = xfs_rmap_get_rec(cur, &PREV, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\ntrace_xfs_rmap_lookup_le_range_result(cur->bc_mp,\r\ncur->bc_private.a.agno, PREV.rm_startblock,\r\nPREV.rm_blockcount, PREV.rm_owner,\r\nPREV.rm_offset, PREV.rm_flags);\r\nASSERT(PREV.rm_offset <= offset);\r\nASSERT(PREV.rm_offset + PREV.rm_blockcount >= new_endoff);\r\nASSERT((PREV.rm_flags & XFS_RMAP_UNWRITTEN) == oldext);\r\nnewext = ~oldext & XFS_RMAP_UNWRITTEN;\r\nif (PREV.rm_offset == offset)\r\nstate |= RMAP_LEFT_FILLING;\r\nif (PREV.rm_offset + PREV.rm_blockcount == new_endoff)\r\nstate |= RMAP_RIGHT_FILLING;\r\nerror = xfs_btree_decrement(cur, 0, &i);\r\nif (error)\r\ngoto done;\r\nif (i) {\r\nstate |= RMAP_LEFT_VALID;\r\nerror = xfs_rmap_get_rec(cur, &LEFT, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nXFS_WANT_CORRUPTED_GOTO(mp,\r\nLEFT.rm_startblock + LEFT.rm_blockcount <= bno,\r\ndone);\r\ntrace_xfs_rmap_find_left_neighbor_result(cur->bc_mp,\r\ncur->bc_private.a.agno, LEFT.rm_startblock,\r\nLEFT.rm_blockcount, LEFT.rm_owner,\r\nLEFT.rm_offset, LEFT.rm_flags);\r\nif (LEFT.rm_startblock + LEFT.rm_blockcount == bno &&\r\nLEFT.rm_offset + LEFT.rm_blockcount == offset &&\r\nxfs_rmap_is_mergeable(&LEFT, owner, newext))\r\nstate |= RMAP_LEFT_CONTIG;\r\n}\r\nerror = xfs_btree_increment(cur, 0, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nerror = xfs_btree_increment(cur, 0, &i);\r\nif (error)\r\ngoto done;\r\nif (i) {\r\nstate |= RMAP_RIGHT_VALID;\r\nerror = xfs_rmap_get_rec(cur, &RIGHT, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nXFS_WANT_CORRUPTED_GOTO(mp, bno + len <= RIGHT.rm_startblock,\r\ndone);\r\ntrace_xfs_rmap_find_right_neighbor_result(cur->bc_mp,\r\ncur->bc_private.a.agno, RIGHT.rm_startblock,\r\nRIGHT.rm_blockcount, RIGHT.rm_owner,\r\nRIGHT.rm_offset, RIGHT.rm_flags);\r\nif (bno + len == RIGHT.rm_startblock &&\r\noffset + len == RIGHT.rm_offset &&\r\nxfs_rmap_is_mergeable(&RIGHT, owner, newext))\r\nstate |= RMAP_RIGHT_CONTIG;\r\n}\r\nif ((state & (RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\r\nRMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG)) ==\r\n(RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\r\nRMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG) &&\r\n(unsigned long)LEFT.rm_blockcount + len +\r\nRIGHT.rm_blockcount > XFS_RMAP_LEN_MAX)\r\nstate &= ~RMAP_RIGHT_CONTIG;\r\ntrace_xfs_rmap_convert_state(mp, cur->bc_private.a.agno, state,\r\n_RET_IP_);\r\nerror = xfs_rmap_lookup_le(cur, bno, len, owner, offset, oldext, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nswitch (state & (RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\r\nRMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG)) {\r\ncase RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\r\nRMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG:\r\nerror = xfs_btree_increment(cur, 0, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\ntrace_xfs_rmap_delete(mp, cur->bc_private.a.agno,\r\nRIGHT.rm_startblock, RIGHT.rm_blockcount,\r\nRIGHT.rm_owner, RIGHT.rm_offset,\r\nRIGHT.rm_flags);\r\nerror = xfs_btree_delete(cur, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nerror = xfs_btree_decrement(cur, 0, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\ntrace_xfs_rmap_delete(mp, cur->bc_private.a.agno,\r\nPREV.rm_startblock, PREV.rm_blockcount,\r\nPREV.rm_owner, PREV.rm_offset,\r\nPREV.rm_flags);\r\nerror = xfs_btree_delete(cur, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nerror = xfs_btree_decrement(cur, 0, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nNEW = LEFT;\r\nNEW.rm_blockcount += PREV.rm_blockcount + RIGHT.rm_blockcount;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase RMAP_LEFT_FILLING | RMAP_RIGHT_FILLING | RMAP_LEFT_CONTIG:\r\ntrace_xfs_rmap_delete(mp, cur->bc_private.a.agno,\r\nPREV.rm_startblock, PREV.rm_blockcount,\r\nPREV.rm_owner, PREV.rm_offset,\r\nPREV.rm_flags);\r\nerror = xfs_btree_delete(cur, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nerror = xfs_btree_decrement(cur, 0, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nNEW = LEFT;\r\nNEW.rm_blockcount += PREV.rm_blockcount;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase RMAP_LEFT_FILLING | RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG:\r\nerror = xfs_btree_increment(cur, 0, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\ntrace_xfs_rmap_delete(mp, cur->bc_private.a.agno,\r\nRIGHT.rm_startblock, RIGHT.rm_blockcount,\r\nRIGHT.rm_owner, RIGHT.rm_offset,\r\nRIGHT.rm_flags);\r\nerror = xfs_btree_delete(cur, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nerror = xfs_btree_decrement(cur, 0, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nNEW = PREV;\r\nNEW.rm_blockcount = len + RIGHT.rm_blockcount;\r\nNEW.rm_flags = newext;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase RMAP_LEFT_FILLING | RMAP_RIGHT_FILLING:\r\nNEW = PREV;\r\nNEW.rm_flags = newext;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG:\r\nNEW = PREV;\r\nNEW.rm_offset += len;\r\nNEW.rm_startblock += len;\r\nNEW.rm_blockcount -= len;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nerror = xfs_btree_decrement(cur, 0, &i);\r\nif (error)\r\ngoto done;\r\nNEW = LEFT;\r\nNEW.rm_blockcount += len;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase RMAP_LEFT_FILLING:\r\nNEW = PREV;\r\nNEW.rm_startblock += len;\r\nNEW.rm_offset += len;\r\nNEW.rm_blockcount -= len;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nNEW.rm_startblock = bno;\r\nNEW.rm_owner = owner;\r\nNEW.rm_offset = offset;\r\nNEW.rm_blockcount = len;\r\nNEW.rm_flags = newext;\r\ncur->bc_rec.r = NEW;\r\ntrace_xfs_rmap_insert(mp, cur->bc_private.a.agno, bno,\r\nlen, owner, offset, newext);\r\nerror = xfs_btree_insert(cur, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nbreak;\r\ncase RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG:\r\nNEW = PREV;\r\nNEW.rm_blockcount -= len;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nerror = xfs_btree_increment(cur, 0, &i);\r\nif (error)\r\ngoto done;\r\nNEW = RIGHT;\r\nNEW.rm_offset = offset;\r\nNEW.rm_startblock = bno;\r\nNEW.rm_blockcount += len;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase RMAP_RIGHT_FILLING:\r\nNEW = PREV;\r\nNEW.rm_blockcount -= len;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nerror = xfs_rmap_lookup_eq(cur, bno, len, owner, offset,\r\noldext, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 0, done);\r\nNEW.rm_startblock = bno;\r\nNEW.rm_owner = owner;\r\nNEW.rm_offset = offset;\r\nNEW.rm_blockcount = len;\r\nNEW.rm_flags = newext;\r\ncur->bc_rec.r = NEW;\r\ntrace_xfs_rmap_insert(mp, cur->bc_private.a.agno, bno,\r\nlen, owner, offset, newext);\r\nerror = xfs_btree_insert(cur, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nbreak;\r\ncase 0:\r\nNEW.rm_startblock = bno + len;\r\nNEW.rm_owner = owner;\r\nNEW.rm_offset = new_endoff;\r\nNEW.rm_blockcount = PREV.rm_offset + PREV.rm_blockcount -\r\nnew_endoff;\r\nNEW.rm_flags = PREV.rm_flags;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nNEW = PREV;\r\nNEW.rm_blockcount = offset - PREV.rm_offset;\r\ncur->bc_rec.r = NEW;\r\ntrace_xfs_rmap_insert(mp, cur->bc_private.a.agno,\r\nNEW.rm_startblock, NEW.rm_blockcount,\r\nNEW.rm_owner, NEW.rm_offset,\r\nNEW.rm_flags);\r\nerror = xfs_btree_insert(cur, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nerror = xfs_rmap_lookup_eq(cur, bno, len, owner, offset,\r\noldext, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 0, done);\r\ncur->bc_rec.r.rm_flags &= ~XFS_RMAP_UNWRITTEN;\r\ncur->bc_rec.r.rm_flags |= newext;\r\ntrace_xfs_rmap_insert(mp, cur->bc_private.a.agno, bno, len,\r\nowner, offset, newext);\r\nerror = xfs_btree_insert(cur, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nbreak;\r\ncase RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG | RMAP_RIGHT_CONTIG:\r\ncase RMAP_RIGHT_FILLING | RMAP_LEFT_CONTIG | RMAP_RIGHT_CONTIG:\r\ncase RMAP_LEFT_FILLING | RMAP_RIGHT_CONTIG:\r\ncase RMAP_RIGHT_FILLING | RMAP_LEFT_CONTIG:\r\ncase RMAP_LEFT_CONTIG | RMAP_RIGHT_CONTIG:\r\ncase RMAP_LEFT_CONTIG:\r\ncase RMAP_RIGHT_CONTIG:\r\nASSERT(0);\r\n}\r\ntrace_xfs_rmap_convert_done(mp, cur->bc_private.a.agno, bno, len,\r\nunwritten, oinfo);\r\ndone:\r\nif (error)\r\ntrace_xfs_rmap_convert_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_rmap_convert_shared(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len,\r\nbool unwritten,\r\nstruct xfs_owner_info *oinfo)\r\n{\r\nstruct xfs_mount *mp = cur->bc_mp;\r\nstruct xfs_rmap_irec r[4];\r\nuint64_t owner;\r\nuint64_t offset;\r\nuint64_t new_endoff;\r\nunsigned int oldext;\r\nunsigned int newext;\r\nunsigned int flags = 0;\r\nint i;\r\nint state = 0;\r\nint error;\r\nxfs_owner_info_unpack(oinfo, &owner, &offset, &flags);\r\nASSERT(!(XFS_RMAP_NON_INODE_OWNER(owner) ||\r\n(flags & (XFS_RMAP_ATTR_FORK | XFS_RMAP_BMBT_BLOCK))));\r\noldext = unwritten ? XFS_RMAP_UNWRITTEN : 0;\r\nnew_endoff = offset + len;\r\ntrace_xfs_rmap_convert(mp, cur->bc_private.a.agno, bno, len,\r\nunwritten, oinfo);\r\nerror = xfs_rmap_lookup_le_range(cur, bno, owner, offset, flags,\r\n&PREV, &i);\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nASSERT(PREV.rm_offset <= offset);\r\nASSERT(PREV.rm_offset + PREV.rm_blockcount >= new_endoff);\r\nASSERT((PREV.rm_flags & XFS_RMAP_UNWRITTEN) == oldext);\r\nnewext = ~oldext & XFS_RMAP_UNWRITTEN;\r\nif (PREV.rm_offset == offset)\r\nstate |= RMAP_LEFT_FILLING;\r\nif (PREV.rm_offset + PREV.rm_blockcount == new_endoff)\r\nstate |= RMAP_RIGHT_FILLING;\r\nerror = xfs_rmap_find_left_neighbor(cur, bno, owner, offset, newext,\r\n&LEFT, &i);\r\nif (error)\r\ngoto done;\r\nif (i) {\r\nstate |= RMAP_LEFT_VALID;\r\nXFS_WANT_CORRUPTED_GOTO(mp,\r\nLEFT.rm_startblock + LEFT.rm_blockcount <= bno,\r\ndone);\r\nif (xfs_rmap_is_mergeable(&LEFT, owner, newext))\r\nstate |= RMAP_LEFT_CONTIG;\r\n}\r\nerror = xfs_rmap_lookup_eq(cur, bno + len, len, owner, offset + len,\r\nnewext, &i);\r\nif (error)\r\ngoto done;\r\nif (i) {\r\nstate |= RMAP_RIGHT_VALID;\r\nerror = xfs_rmap_get_rec(cur, &RIGHT, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nXFS_WANT_CORRUPTED_GOTO(mp, bno + len <= RIGHT.rm_startblock,\r\ndone);\r\ntrace_xfs_rmap_find_right_neighbor_result(cur->bc_mp,\r\ncur->bc_private.a.agno, RIGHT.rm_startblock,\r\nRIGHT.rm_blockcount, RIGHT.rm_owner,\r\nRIGHT.rm_offset, RIGHT.rm_flags);\r\nif (xfs_rmap_is_mergeable(&RIGHT, owner, newext))\r\nstate |= RMAP_RIGHT_CONTIG;\r\n}\r\nif ((state & (RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\r\nRMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG)) ==\r\n(RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\r\nRMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG) &&\r\n(unsigned long)LEFT.rm_blockcount + len +\r\nRIGHT.rm_blockcount > XFS_RMAP_LEN_MAX)\r\nstate &= ~RMAP_RIGHT_CONTIG;\r\ntrace_xfs_rmap_convert_state(mp, cur->bc_private.a.agno, state,\r\n_RET_IP_);\r\nswitch (state & (RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\r\nRMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG)) {\r\ncase RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG |\r\nRMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG:\r\nerror = xfs_rmap_delete(cur, RIGHT.rm_startblock,\r\nRIGHT.rm_blockcount, RIGHT.rm_owner,\r\nRIGHT.rm_offset, RIGHT.rm_flags);\r\nif (error)\r\ngoto done;\r\nerror = xfs_rmap_delete(cur, PREV.rm_startblock,\r\nPREV.rm_blockcount, PREV.rm_owner,\r\nPREV.rm_offset, PREV.rm_flags);\r\nif (error)\r\ngoto done;\r\nNEW = LEFT;\r\nerror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner,\r\nNEW.rm_offset, NEW.rm_flags, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nNEW.rm_blockcount += PREV.rm_blockcount + RIGHT.rm_blockcount;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase RMAP_LEFT_FILLING | RMAP_RIGHT_FILLING | RMAP_LEFT_CONTIG:\r\nerror = xfs_rmap_delete(cur, PREV.rm_startblock,\r\nPREV.rm_blockcount, PREV.rm_owner,\r\nPREV.rm_offset, PREV.rm_flags);\r\nif (error)\r\ngoto done;\r\nNEW = LEFT;\r\nerror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner,\r\nNEW.rm_offset, NEW.rm_flags, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nNEW.rm_blockcount += PREV.rm_blockcount;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase RMAP_LEFT_FILLING | RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG:\r\nerror = xfs_rmap_delete(cur, RIGHT.rm_startblock,\r\nRIGHT.rm_blockcount, RIGHT.rm_owner,\r\nRIGHT.rm_offset, RIGHT.rm_flags);\r\nif (error)\r\ngoto done;\r\nNEW = PREV;\r\nerror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner,\r\nNEW.rm_offset, NEW.rm_flags, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nNEW.rm_blockcount += RIGHT.rm_blockcount;\r\nNEW.rm_flags = RIGHT.rm_flags;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase RMAP_LEFT_FILLING | RMAP_RIGHT_FILLING:\r\nNEW = PREV;\r\nerror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner,\r\nNEW.rm_offset, NEW.rm_flags, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nNEW.rm_flags = newext;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG:\r\nNEW = PREV;\r\nerror = xfs_rmap_delete(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner,\r\nNEW.rm_offset, NEW.rm_flags);\r\nif (error)\r\ngoto done;\r\nNEW.rm_offset += len;\r\nNEW.rm_startblock += len;\r\nNEW.rm_blockcount -= len;\r\nerror = xfs_rmap_insert(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner,\r\nNEW.rm_offset, NEW.rm_flags);\r\nif (error)\r\ngoto done;\r\nNEW = LEFT;\r\nerror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner,\r\nNEW.rm_offset, NEW.rm_flags, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nNEW.rm_blockcount += len;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase RMAP_LEFT_FILLING:\r\nNEW = PREV;\r\nerror = xfs_rmap_delete(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner,\r\nNEW.rm_offset, NEW.rm_flags);\r\nif (error)\r\ngoto done;\r\nNEW.rm_offset += len;\r\nNEW.rm_startblock += len;\r\nNEW.rm_blockcount -= len;\r\nerror = xfs_rmap_insert(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner,\r\nNEW.rm_offset, NEW.rm_flags);\r\nif (error)\r\ngoto done;\r\nerror = xfs_rmap_insert(cur, bno, len, owner, offset, newext);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase RMAP_RIGHT_FILLING | RMAP_RIGHT_CONTIG:\r\nNEW = PREV;\r\nerror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner,\r\nNEW.rm_offset, NEW.rm_flags, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nNEW.rm_blockcount = offset - NEW.rm_offset;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nNEW = RIGHT;\r\nerror = xfs_rmap_delete(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner,\r\nNEW.rm_offset, NEW.rm_flags);\r\nif (error)\r\ngoto done;\r\nNEW.rm_offset = offset;\r\nNEW.rm_startblock = bno;\r\nNEW.rm_blockcount += len;\r\nerror = xfs_rmap_insert(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner,\r\nNEW.rm_offset, NEW.rm_flags);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase RMAP_RIGHT_FILLING:\r\nNEW = PREV;\r\nerror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner,\r\nNEW.rm_offset, NEW.rm_flags, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nNEW.rm_blockcount -= len;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nerror = xfs_rmap_insert(cur, bno, len, owner, offset, newext);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase 0:\r\nNEW.rm_startblock = bno + len;\r\nNEW.rm_owner = owner;\r\nNEW.rm_offset = new_endoff;\r\nNEW.rm_blockcount = PREV.rm_offset + PREV.rm_blockcount -\r\nnew_endoff;\r\nNEW.rm_flags = PREV.rm_flags;\r\nerror = xfs_rmap_insert(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner, NEW.rm_offset,\r\nNEW.rm_flags);\r\nif (error)\r\ngoto done;\r\nNEW = PREV;\r\nerror = xfs_rmap_lookup_eq(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner,\r\nNEW.rm_offset, NEW.rm_flags, &i);\r\nif (error)\r\ngoto done;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);\r\nNEW.rm_blockcount = offset - NEW.rm_offset;\r\nerror = xfs_rmap_update(cur, &NEW);\r\nif (error)\r\ngoto done;\r\nNEW.rm_startblock = bno;\r\nNEW.rm_blockcount = len;\r\nNEW.rm_owner = owner;\r\nNEW.rm_offset = offset;\r\nNEW.rm_flags = newext;\r\nerror = xfs_rmap_insert(cur, NEW.rm_startblock,\r\nNEW.rm_blockcount, NEW.rm_owner, NEW.rm_offset,\r\nNEW.rm_flags);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase RMAP_LEFT_FILLING | RMAP_LEFT_CONTIG | RMAP_RIGHT_CONTIG:\r\ncase RMAP_RIGHT_FILLING | RMAP_LEFT_CONTIG | RMAP_RIGHT_CONTIG:\r\ncase RMAP_LEFT_FILLING | RMAP_RIGHT_CONTIG:\r\ncase RMAP_RIGHT_FILLING | RMAP_LEFT_CONTIG:\r\ncase RMAP_LEFT_CONTIG | RMAP_RIGHT_CONTIG:\r\ncase RMAP_LEFT_CONTIG:\r\ncase RMAP_RIGHT_CONTIG:\r\nASSERT(0);\r\n}\r\ntrace_xfs_rmap_convert_done(mp, cur->bc_private.a.agno, bno, len,\r\nunwritten, oinfo);\r\ndone:\r\nif (error)\r\ntrace_xfs_rmap_convert_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_rmap_unmap_shared(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len,\r\nbool unwritten,\r\nstruct xfs_owner_info *oinfo)\r\n{\r\nstruct xfs_mount *mp = cur->bc_mp;\r\nstruct xfs_rmap_irec ltrec;\r\nuint64_t ltoff;\r\nint error = 0;\r\nint i;\r\nuint64_t owner;\r\nuint64_t offset;\r\nunsigned int flags;\r\nxfs_owner_info_unpack(oinfo, &owner, &offset, &flags);\r\nif (unwritten)\r\nflags |= XFS_RMAP_UNWRITTEN;\r\ntrace_xfs_rmap_unmap(mp, cur->bc_private.a.agno, bno, len,\r\nunwritten, oinfo);\r\nerror = xfs_rmap_lookup_le_range(cur, bno, owner, offset, flags,\r\n&ltrec, &i);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, out_error);\r\nltoff = ltrec.rm_offset;\r\nXFS_WANT_CORRUPTED_GOTO(mp, ltrec.rm_startblock <= bno &&\r\nltrec.rm_startblock + ltrec.rm_blockcount >=\r\nbno + len, out_error);\r\nXFS_WANT_CORRUPTED_GOTO(mp, owner == ltrec.rm_owner, out_error);\r\nXFS_WANT_CORRUPTED_GOTO(mp, (flags & XFS_RMAP_UNWRITTEN) ==\r\n(ltrec.rm_flags & XFS_RMAP_UNWRITTEN), out_error);\r\nXFS_WANT_CORRUPTED_GOTO(mp, ltrec.rm_offset <= offset, out_error);\r\nXFS_WANT_CORRUPTED_GOTO(mp, offset <= ltoff + ltrec.rm_blockcount,\r\nout_error);\r\nif (ltrec.rm_startblock == bno && ltrec.rm_blockcount == len) {\r\nerror = xfs_rmap_delete(cur, ltrec.rm_startblock,\r\nltrec.rm_blockcount, ltrec.rm_owner,\r\nltrec.rm_offset, ltrec.rm_flags);\r\nif (error)\r\ngoto out_error;\r\n} else if (ltrec.rm_startblock == bno) {\r\nerror = xfs_rmap_delete(cur, ltrec.rm_startblock,\r\nltrec.rm_blockcount, ltrec.rm_owner,\r\nltrec.rm_offset, ltrec.rm_flags);\r\nif (error)\r\ngoto out_error;\r\nltrec.rm_startblock += len;\r\nltrec.rm_blockcount -= len;\r\nltrec.rm_offset += len;\r\nerror = xfs_rmap_insert(cur, ltrec.rm_startblock,\r\nltrec.rm_blockcount, ltrec.rm_owner,\r\nltrec.rm_offset, ltrec.rm_flags);\r\nif (error)\r\ngoto out_error;\r\n} else if (ltrec.rm_startblock + ltrec.rm_blockcount == bno + len) {\r\nerror = xfs_rmap_lookup_eq(cur, ltrec.rm_startblock,\r\nltrec.rm_blockcount, ltrec.rm_owner,\r\nltrec.rm_offset, ltrec.rm_flags, &i);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, out_error);\r\nltrec.rm_blockcount -= len;\r\nerror = xfs_rmap_update(cur, &ltrec);\r\nif (error)\r\ngoto out_error;\r\n} else {\r\nxfs_extlen_t orig_len = ltrec.rm_blockcount;\r\nerror = xfs_rmap_lookup_eq(cur, ltrec.rm_startblock,\r\nltrec.rm_blockcount, ltrec.rm_owner,\r\nltrec.rm_offset, ltrec.rm_flags, &i);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, out_error);\r\nltrec.rm_blockcount = bno - ltrec.rm_startblock;\r\nerror = xfs_rmap_update(cur, &ltrec);\r\nif (error)\r\ngoto out_error;\r\nerror = xfs_rmap_insert(cur, bno + len,\r\norig_len - len - ltrec.rm_blockcount,\r\nltrec.rm_owner, offset + len,\r\nltrec.rm_flags);\r\nif (error)\r\ngoto out_error;\r\n}\r\ntrace_xfs_rmap_unmap_done(mp, cur->bc_private.a.agno, bno, len,\r\nunwritten, oinfo);\r\nout_error:\r\nif (error)\r\ntrace_xfs_rmap_unmap_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_rmap_map_shared(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len,\r\nbool unwritten,\r\nstruct xfs_owner_info *oinfo)\r\n{\r\nstruct xfs_mount *mp = cur->bc_mp;\r\nstruct xfs_rmap_irec ltrec;\r\nstruct xfs_rmap_irec gtrec;\r\nint have_gt;\r\nint have_lt;\r\nint error = 0;\r\nint i;\r\nuint64_t owner;\r\nuint64_t offset;\r\nunsigned int flags = 0;\r\nxfs_owner_info_unpack(oinfo, &owner, &offset, &flags);\r\nif (unwritten)\r\nflags |= XFS_RMAP_UNWRITTEN;\r\ntrace_xfs_rmap_map(mp, cur->bc_private.a.agno, bno, len,\r\nunwritten, oinfo);\r\nerror = xfs_rmap_find_left_neighbor(cur, bno, owner, offset, flags,\r\n&ltrec, &have_lt);\r\nif (error)\r\ngoto out_error;\r\nif (have_lt &&\r\n!xfs_rmap_is_mergeable(&ltrec, owner, flags))\r\nhave_lt = 0;\r\nerror = xfs_rmap_lookup_eq(cur, bno + len, len, owner, offset + len,\r\nflags, &have_gt);\r\nif (error)\r\ngoto out_error;\r\nif (have_gt) {\r\nerror = xfs_rmap_get_rec(cur, &gtrec, &have_gt);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(mp, have_gt == 1, out_error);\r\ntrace_xfs_rmap_find_right_neighbor_result(cur->bc_mp,\r\ncur->bc_private.a.agno, gtrec.rm_startblock,\r\ngtrec.rm_blockcount, gtrec.rm_owner,\r\ngtrec.rm_offset, gtrec.rm_flags);\r\nif (!xfs_rmap_is_mergeable(&gtrec, owner, flags))\r\nhave_gt = 0;\r\n}\r\nif (have_lt &&\r\nltrec.rm_startblock + ltrec.rm_blockcount == bno &&\r\nltrec.rm_offset + ltrec.rm_blockcount == offset) {\r\nltrec.rm_blockcount += len;\r\nif (have_gt &&\r\nbno + len == gtrec.rm_startblock &&\r\noffset + len == gtrec.rm_offset) {\r\nltrec.rm_blockcount += gtrec.rm_blockcount;\r\nerror = xfs_rmap_delete(cur, gtrec.rm_startblock,\r\ngtrec.rm_blockcount, gtrec.rm_owner,\r\ngtrec.rm_offset, gtrec.rm_flags);\r\nif (error)\r\ngoto out_error;\r\n}\r\nerror = xfs_rmap_lookup_eq(cur, ltrec.rm_startblock,\r\nltrec.rm_blockcount, ltrec.rm_owner,\r\nltrec.rm_offset, ltrec.rm_flags, &i);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(mp, i == 1, out_error);\r\nerror = xfs_rmap_update(cur, &ltrec);\r\nif (error)\r\ngoto out_error;\r\n} else if (have_gt &&\r\nbno + len == gtrec.rm_startblock &&\r\noffset + len == gtrec.rm_offset) {\r\nerror = xfs_rmap_delete(cur, gtrec.rm_startblock,\r\ngtrec.rm_blockcount, gtrec.rm_owner,\r\ngtrec.rm_offset, gtrec.rm_flags);\r\nif (error)\r\ngoto out_error;\r\ngtrec.rm_startblock = bno;\r\ngtrec.rm_blockcount += len;\r\ngtrec.rm_offset = offset;\r\nerror = xfs_rmap_insert(cur, gtrec.rm_startblock,\r\ngtrec.rm_blockcount, gtrec.rm_owner,\r\ngtrec.rm_offset, gtrec.rm_flags);\r\nif (error)\r\ngoto out_error;\r\n} else {\r\nerror = xfs_rmap_insert(cur, bno, len, owner, offset, flags);\r\nif (error)\r\ngoto out_error;\r\n}\r\ntrace_xfs_rmap_map_done(mp, cur->bc_private.a.agno, bno, len,\r\nunwritten, oinfo);\r\nout_error:\r\nif (error)\r\ntrace_xfs_rmap_map_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_rmap_query_range_helper(\r\nstruct xfs_btree_cur *cur,\r\nunion xfs_btree_rec *rec,\r\nvoid *priv)\r\n{\r\nstruct xfs_rmap_query_range_info *query = priv;\r\nstruct xfs_rmap_irec irec;\r\nint error;\r\nerror = xfs_rmap_btrec_to_irec(rec, &irec);\r\nif (error)\r\nreturn error;\r\nreturn query->fn(cur, &irec, query->priv);\r\n}\r\nint\r\nxfs_rmap_query_range(\r\nstruct xfs_btree_cur *cur,\r\nstruct xfs_rmap_irec *low_rec,\r\nstruct xfs_rmap_irec *high_rec,\r\nxfs_rmap_query_range_fn fn,\r\nvoid *priv)\r\n{\r\nunion xfs_btree_irec low_brec;\r\nunion xfs_btree_irec high_brec;\r\nstruct xfs_rmap_query_range_info query;\r\nlow_brec.r = *low_rec;\r\nhigh_brec.r = *high_rec;\r\nquery.priv = priv;\r\nquery.fn = fn;\r\nreturn xfs_btree_query_range(cur, &low_brec, &high_brec,\r\nxfs_rmap_query_range_helper, &query);\r\n}\r\nint\r\nxfs_rmap_query_all(\r\nstruct xfs_btree_cur *cur,\r\nxfs_rmap_query_range_fn fn,\r\nvoid *priv)\r\n{\r\nstruct xfs_rmap_query_range_info query;\r\nquery.priv = priv;\r\nquery.fn = fn;\r\nreturn xfs_btree_query_all(cur, xfs_rmap_query_range_helper, &query);\r\n}\r\nvoid\r\nxfs_rmap_finish_one_cleanup(\r\nstruct xfs_trans *tp,\r\nstruct xfs_btree_cur *rcur,\r\nint error)\r\n{\r\nstruct xfs_buf *agbp;\r\nif (rcur == NULL)\r\nreturn;\r\nagbp = rcur->bc_private.a.agbp;\r\nxfs_btree_del_cursor(rcur, error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\r\nif (error)\r\nxfs_trans_brelse(tp, agbp);\r\n}\r\nint\r\nxfs_rmap_finish_one(\r\nstruct xfs_trans *tp,\r\nenum xfs_rmap_intent_type type,\r\nuint64_t owner,\r\nint whichfork,\r\nxfs_fileoff_t startoff,\r\nxfs_fsblock_t startblock,\r\nxfs_filblks_t blockcount,\r\nxfs_exntst_t state,\r\nstruct xfs_btree_cur **pcur)\r\n{\r\nstruct xfs_mount *mp = tp->t_mountp;\r\nstruct xfs_btree_cur *rcur;\r\nstruct xfs_buf *agbp = NULL;\r\nint error = 0;\r\nxfs_agnumber_t agno;\r\nstruct xfs_owner_info oinfo;\r\nxfs_agblock_t bno;\r\nbool unwritten;\r\nagno = XFS_FSB_TO_AGNO(mp, startblock);\r\nASSERT(agno != NULLAGNUMBER);\r\nbno = XFS_FSB_TO_AGBNO(mp, startblock);\r\ntrace_xfs_rmap_deferred(mp, agno, type, bno, owner, whichfork,\r\nstartoff, blockcount, state);\r\nif (XFS_TEST_ERROR(false, mp,\r\nXFS_ERRTAG_RMAP_FINISH_ONE))\r\nreturn -EIO;\r\nrcur = *pcur;\r\nif (rcur != NULL && rcur->bc_private.a.agno != agno) {\r\nxfs_rmap_finish_one_cleanup(tp, rcur, 0);\r\nrcur = NULL;\r\n*pcur = NULL;\r\n}\r\nif (rcur == NULL) {\r\nerror = xfs_free_extent_fix_freelist(tp, agno, &agbp);\r\nif (error)\r\nreturn error;\r\nif (!agbp)\r\nreturn -EFSCORRUPTED;\r\nrcur = xfs_rmapbt_init_cursor(mp, tp, agbp, agno);\r\nif (!rcur) {\r\nerror = -ENOMEM;\r\ngoto out_cur;\r\n}\r\n}\r\n*pcur = rcur;\r\nxfs_rmap_ino_owner(&oinfo, owner, whichfork, startoff);\r\nunwritten = state == XFS_EXT_UNWRITTEN;\r\nbno = XFS_FSB_TO_AGBNO(rcur->bc_mp, startblock);\r\nswitch (type) {\r\ncase XFS_RMAP_ALLOC:\r\ncase XFS_RMAP_MAP:\r\nerror = xfs_rmap_map(rcur, bno, blockcount, unwritten, &oinfo);\r\nbreak;\r\ncase XFS_RMAP_MAP_SHARED:\r\nerror = xfs_rmap_map_shared(rcur, bno, blockcount, unwritten,\r\n&oinfo);\r\nbreak;\r\ncase XFS_RMAP_FREE:\r\ncase XFS_RMAP_UNMAP:\r\nerror = xfs_rmap_unmap(rcur, bno, blockcount, unwritten,\r\n&oinfo);\r\nbreak;\r\ncase XFS_RMAP_UNMAP_SHARED:\r\nerror = xfs_rmap_unmap_shared(rcur, bno, blockcount, unwritten,\r\n&oinfo);\r\nbreak;\r\ncase XFS_RMAP_CONVERT:\r\nerror = xfs_rmap_convert(rcur, bno, blockcount, !unwritten,\r\n&oinfo);\r\nbreak;\r\ncase XFS_RMAP_CONVERT_SHARED:\r\nerror = xfs_rmap_convert_shared(rcur, bno, blockcount,\r\n!unwritten, &oinfo);\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\nerror = -EFSCORRUPTED;\r\n}\r\nreturn error;\r\nout_cur:\r\nxfs_trans_brelse(tp, agbp);\r\nreturn error;\r\n}\r\nstatic bool\r\nxfs_rmap_update_is_needed(\r\nstruct xfs_mount *mp,\r\nint whichfork)\r\n{\r\nreturn xfs_sb_version_hasrmapbt(&mp->m_sb) && whichfork != XFS_COW_FORK;\r\n}\r\nstatic int\r\n__xfs_rmap_add(\r\nstruct xfs_mount *mp,\r\nstruct xfs_defer_ops *dfops,\r\nenum xfs_rmap_intent_type type,\r\nuint64_t owner,\r\nint whichfork,\r\nstruct xfs_bmbt_irec *bmap)\r\n{\r\nstruct xfs_rmap_intent *ri;\r\ntrace_xfs_rmap_defer(mp, XFS_FSB_TO_AGNO(mp, bmap->br_startblock),\r\ntype,\r\nXFS_FSB_TO_AGBNO(mp, bmap->br_startblock),\r\nowner, whichfork,\r\nbmap->br_startoff,\r\nbmap->br_blockcount,\r\nbmap->br_state);\r\nri = kmem_alloc(sizeof(struct xfs_rmap_intent), KM_SLEEP | KM_NOFS);\r\nINIT_LIST_HEAD(&ri->ri_list);\r\nri->ri_type = type;\r\nri->ri_owner = owner;\r\nri->ri_whichfork = whichfork;\r\nri->ri_bmap = *bmap;\r\nxfs_defer_add(dfops, XFS_DEFER_OPS_TYPE_RMAP, &ri->ri_list);\r\nreturn 0;\r\n}\r\nint\r\nxfs_rmap_map_extent(\r\nstruct xfs_mount *mp,\r\nstruct xfs_defer_ops *dfops,\r\nstruct xfs_inode *ip,\r\nint whichfork,\r\nstruct xfs_bmbt_irec *PREV)\r\n{\r\nif (!xfs_rmap_update_is_needed(mp, whichfork))\r\nreturn 0;\r\nreturn __xfs_rmap_add(mp, dfops, xfs_is_reflink_inode(ip) ?\r\nXFS_RMAP_MAP_SHARED : XFS_RMAP_MAP, ip->i_ino,\r\nwhichfork, PREV);\r\n}\r\nint\r\nxfs_rmap_unmap_extent(\r\nstruct xfs_mount *mp,\r\nstruct xfs_defer_ops *dfops,\r\nstruct xfs_inode *ip,\r\nint whichfork,\r\nstruct xfs_bmbt_irec *PREV)\r\n{\r\nif (!xfs_rmap_update_is_needed(mp, whichfork))\r\nreturn 0;\r\nreturn __xfs_rmap_add(mp, dfops, xfs_is_reflink_inode(ip) ?\r\nXFS_RMAP_UNMAP_SHARED : XFS_RMAP_UNMAP, ip->i_ino,\r\nwhichfork, PREV);\r\n}\r\nint\r\nxfs_rmap_convert_extent(\r\nstruct xfs_mount *mp,\r\nstruct xfs_defer_ops *dfops,\r\nstruct xfs_inode *ip,\r\nint whichfork,\r\nstruct xfs_bmbt_irec *PREV)\r\n{\r\nif (!xfs_rmap_update_is_needed(mp, whichfork))\r\nreturn 0;\r\nreturn __xfs_rmap_add(mp, dfops, xfs_is_reflink_inode(ip) ?\r\nXFS_RMAP_CONVERT_SHARED : XFS_RMAP_CONVERT, ip->i_ino,\r\nwhichfork, PREV);\r\n}\r\nint\r\nxfs_rmap_alloc_extent(\r\nstruct xfs_mount *mp,\r\nstruct xfs_defer_ops *dfops,\r\nxfs_agnumber_t agno,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len,\r\nuint64_t owner)\r\n{\r\nstruct xfs_bmbt_irec bmap;\r\nif (!xfs_rmap_update_is_needed(mp, XFS_DATA_FORK))\r\nreturn 0;\r\nbmap.br_startblock = XFS_AGB_TO_FSB(mp, agno, bno);\r\nbmap.br_blockcount = len;\r\nbmap.br_startoff = 0;\r\nbmap.br_state = XFS_EXT_NORM;\r\nreturn __xfs_rmap_add(mp, dfops, XFS_RMAP_ALLOC, owner,\r\nXFS_DATA_FORK, &bmap);\r\n}\r\nint\r\nxfs_rmap_free_extent(\r\nstruct xfs_mount *mp,\r\nstruct xfs_defer_ops *dfops,\r\nxfs_agnumber_t agno,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len,\r\nuint64_t owner)\r\n{\r\nstruct xfs_bmbt_irec bmap;\r\nif (!xfs_rmap_update_is_needed(mp, XFS_DATA_FORK))\r\nreturn 0;\r\nbmap.br_startblock = XFS_AGB_TO_FSB(mp, agno, bno);\r\nbmap.br_blockcount = len;\r\nbmap.br_startoff = 0;\r\nbmap.br_state = XFS_EXT_NORM;\r\nreturn __xfs_rmap_add(mp, dfops, XFS_RMAP_FREE, owner,\r\nXFS_DATA_FORK, &bmap);\r\n}\r\nint\r\nxfs_rmap_compare(\r\nconst struct xfs_rmap_irec *a,\r\nconst struct xfs_rmap_irec *b)\r\n{\r\n__u64 oa;\r\n__u64 ob;\r\noa = xfs_rmap_irec_offset_pack(a);\r\nob = xfs_rmap_irec_offset_pack(b);\r\nif (a->rm_startblock < b->rm_startblock)\r\nreturn -1;\r\nelse if (a->rm_startblock > b->rm_startblock)\r\nreturn 1;\r\nelse if (a->rm_owner < b->rm_owner)\r\nreturn -1;\r\nelse if (a->rm_owner > b->rm_owner)\r\nreturn 1;\r\nelse if (oa < ob)\r\nreturn -1;\r\nelse if (oa > ob)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}
