static struct smbus_block_data *stub_find_block(struct device *dev,\r\nstruct stub_chip *chip,\r\nu8 command, bool create)\r\n{\r\nstruct smbus_block_data *b, *rb = NULL;\r\nlist_for_each_entry(b, &chip->smbus_blocks, node) {\r\nif (b->command == command) {\r\nrb = b;\r\nbreak;\r\n}\r\n}\r\nif (rb == NULL && create) {\r\nrb = devm_kzalloc(dev, sizeof(*rb), GFP_KERNEL);\r\nif (rb == NULL)\r\nreturn rb;\r\nrb->command = command;\r\nlist_add(&rb->node, &chip->smbus_blocks);\r\n}\r\nreturn rb;\r\n}\r\nstatic u16 *stub_get_wordp(struct stub_chip *chip, u8 offset)\r\n{\r\nif (chip->bank_sel &&\r\noffset >= chip->bank_start && offset <= chip->bank_end)\r\nreturn chip->bank_words +\r\n(chip->bank_sel - 1) * chip->bank_size +\r\noffset - chip->bank_start;\r\nelse\r\nreturn chip->words + offset;\r\n}\r\nstatic s32 stub_xfer(struct i2c_adapter *adap, u16 addr, unsigned short flags,\r\nchar read_write, u8 command, int size, union i2c_smbus_data *data)\r\n{\r\ns32 ret;\r\nint i, len;\r\nstruct stub_chip *chip = NULL;\r\nstruct smbus_block_data *b;\r\nu16 *wordp;\r\nfor (i = 0; i < stub_chips_nr; i++) {\r\nif (addr == chip_addr[i]) {\r\nchip = stub_chips + i;\r\nbreak;\r\n}\r\n}\r\nif (!chip)\r\nreturn -ENODEV;\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\ndev_dbg(&adap->dev, "smbus quick - addr 0x%02x\n", addr);\r\nret = 0;\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nchip->pointer = command;\r\ndev_dbg(&adap->dev,\r\n"smbus byte - addr 0x%02x, wrote 0x%02x.\n",\r\naddr, command);\r\n} else {\r\nwordp = stub_get_wordp(chip, chip->pointer++);\r\ndata->byte = *wordp & 0xff;\r\ndev_dbg(&adap->dev,\r\n"smbus byte - addr 0x%02x, read 0x%02x.\n",\r\naddr, data->byte);\r\n}\r\nret = 0;\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nwordp = stub_get_wordp(chip, command);\r\nif (read_write == I2C_SMBUS_WRITE) {\r\n*wordp &= 0xff00;\r\n*wordp |= data->byte;\r\ndev_dbg(&adap->dev,\r\n"smbus byte data - addr 0x%02x, wrote 0x%02x at 0x%02x.\n",\r\naddr, data->byte, command);\r\nif (chip->bank_words && command == chip->bank_reg) {\r\nchip->bank_sel =\r\n(data->byte >> chip->bank_shift)\r\n& chip->bank_mask;\r\ndev_dbg(&adap->dev,\r\n"switching to bank %u.\n",\r\nchip->bank_sel);\r\n}\r\n} else {\r\ndata->byte = *wordp & 0xff;\r\ndev_dbg(&adap->dev,\r\n"smbus byte data - addr 0x%02x, read 0x%02x at 0x%02x.\n",\r\naddr, data->byte, command);\r\n}\r\nchip->pointer = command + 1;\r\nret = 0;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\nwordp = stub_get_wordp(chip, command);\r\nif (read_write == I2C_SMBUS_WRITE) {\r\n*wordp = data->word;\r\ndev_dbg(&adap->dev,\r\n"smbus word data - addr 0x%02x, wrote 0x%04x at 0x%02x.\n",\r\naddr, data->word, command);\r\n} else {\r\ndata->word = *wordp;\r\ndev_dbg(&adap->dev,\r\n"smbus word data - addr 0x%02x, read 0x%04x at 0x%02x.\n",\r\naddr, data->word, command);\r\n}\r\nret = 0;\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nif (data->block[0] > 256 - command)\r\ndata->block[0] = 256 - command;\r\nlen = data->block[0];\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nfor (i = 0; i < len; i++) {\r\nchip->words[command + i] &= 0xff00;\r\nchip->words[command + i] |= data->block[1 + i];\r\n}\r\ndev_dbg(&adap->dev,\r\n"i2c block data - addr 0x%02x, wrote %d bytes at 0x%02x.\n",\r\naddr, len, command);\r\n} else {\r\nfor (i = 0; i < len; i++) {\r\ndata->block[1 + i] =\r\nchip->words[command + i] & 0xff;\r\n}\r\ndev_dbg(&adap->dev,\r\n"i2c block data - addr 0x%02x, read %d bytes at 0x%02x.\n",\r\naddr, len, command);\r\n}\r\nret = 0;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\nb = stub_find_block(&adap->dev, chip, command, false);\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nlen = data->block[0];\r\nif (len == 0 || len > I2C_SMBUS_BLOCK_MAX) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (b == NULL) {\r\nb = stub_find_block(&adap->dev, chip, command,\r\ntrue);\r\nif (b == NULL) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\n}\r\nif (len > b->len)\r\nb->len = len;\r\nfor (i = 0; i < len; i++)\r\nb->block[i] = data->block[i + 1];\r\nchip->words[command] = (b->block[0] << 8) | b->len;\r\ndev_dbg(&adap->dev,\r\n"smbus block data - addr 0x%02x, wrote %d bytes at 0x%02x.\n",\r\naddr, len, command);\r\n} else {\r\nif (b == NULL) {\r\ndev_dbg(&adap->dev,\r\n"SMBus block read command without prior block write not supported\n");\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nlen = b->len;\r\ndata->block[0] = len;\r\nfor (i = 0; i < len; i++)\r\ndata->block[i + 1] = b->block[i];\r\ndev_dbg(&adap->dev,\r\n"smbus block data - addr 0x%02x, read %d bytes at 0x%02x.\n",\r\naddr, len, command);\r\n}\r\nret = 0;\r\nbreak;\r\ndefault:\r\ndev_dbg(&adap->dev, "Unsupported I2C/SMBus command\n");\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic u32 stub_func(struct i2c_adapter *adapter)\r\n{\r\nreturn STUB_FUNC_ALL & functionality;\r\n}\r\nstatic int __init i2c_stub_allocate_banks(int i)\r\n{\r\nstruct stub_chip *chip = stub_chips + i;\r\nchip->bank_reg = bank_reg[i];\r\nchip->bank_start = bank_start[i];\r\nchip->bank_end = bank_end[i];\r\nchip->bank_size = bank_end[i] - bank_start[i] + 1;\r\nchip->bank_mask = bank_mask[i];\r\nwhile (!(chip->bank_mask & 1)) {\r\nchip->bank_shift++;\r\nchip->bank_mask >>= 1;\r\n}\r\nchip->bank_words = kzalloc(chip->bank_mask * chip->bank_size *\r\nsizeof(u16), GFP_KERNEL);\r\nif (!chip->bank_words)\r\nreturn -ENOMEM;\r\npr_debug("Allocated %u banks of %u words each (registers 0x%02x to 0x%02x)\n",\r\nchip->bank_mask, chip->bank_size, chip->bank_start,\r\nchip->bank_end);\r\nreturn 0;\r\n}\r\nstatic void i2c_stub_free(void)\r\n{\r\nint i;\r\nfor (i = 0; i < stub_chips_nr; i++)\r\nkfree(stub_chips[i].bank_words);\r\nkfree(stub_chips);\r\n}\r\nstatic int __init i2c_stub_init(void)\r\n{\r\nint i, ret;\r\nif (!chip_addr[0]) {\r\npr_err("Please specify a chip address\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < MAX_CHIPS && chip_addr[i]; i++) {\r\nif (chip_addr[i] < 0x03 || chip_addr[i] > 0x77) {\r\npr_err("Invalid chip address 0x%02x\n",\r\nchip_addr[i]);\r\nreturn -EINVAL;\r\n}\r\npr_info("Virtual chip at 0x%02x\n", chip_addr[i]);\r\n}\r\nstub_chips_nr = i;\r\nstub_chips = kcalloc(stub_chips_nr, sizeof(struct stub_chip),\r\nGFP_KERNEL);\r\nif (!stub_chips)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < stub_chips_nr; i++) {\r\nINIT_LIST_HEAD(&stub_chips[i].smbus_blocks);\r\nif (bank_mask[i]) {\r\nret = i2c_stub_allocate_banks(i);\r\nif (ret)\r\ngoto fail_free;\r\n}\r\n}\r\nret = i2c_add_adapter(&stub_adapter);\r\nif (ret)\r\ngoto fail_free;\r\nreturn 0;\r\nfail_free:\r\ni2c_stub_free();\r\nreturn ret;\r\n}\r\nstatic void __exit i2c_stub_exit(void)\r\n{\r\ni2c_del_adapter(&stub_adapter);\r\ni2c_stub_free();\r\n}
