static int dwc2_get_dr_mode(struct dwc2_hsotg *hsotg)\r\n{\r\nenum usb_dr_mode mode;\r\nhsotg->dr_mode = usb_get_dr_mode(hsotg->dev);\r\nif (hsotg->dr_mode == USB_DR_MODE_UNKNOWN)\r\nhsotg->dr_mode = USB_DR_MODE_OTG;\r\nmode = hsotg->dr_mode;\r\nif (dwc2_hw_is_device(hsotg)) {\r\nif (IS_ENABLED(CONFIG_USB_DWC2_HOST)) {\r\ndev_err(hsotg->dev,\r\n"Controller does not support host mode.\n");\r\nreturn -EINVAL;\r\n}\r\nmode = USB_DR_MODE_PERIPHERAL;\r\n} else if (dwc2_hw_is_host(hsotg)) {\r\nif (IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL)) {\r\ndev_err(hsotg->dev,\r\n"Controller does not support device mode.\n");\r\nreturn -EINVAL;\r\n}\r\nmode = USB_DR_MODE_HOST;\r\n} else {\r\nif (IS_ENABLED(CONFIG_USB_DWC2_HOST))\r\nmode = USB_DR_MODE_HOST;\r\nelse if (IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL))\r\nmode = USB_DR_MODE_PERIPHERAL;\r\n}\r\nif (mode != hsotg->dr_mode) {\r\ndev_warn(hsotg->dev,\r\n"Configuration mismatch. dr_mode forced to %s\n",\r\nmode == USB_DR_MODE_HOST ? "host" : "device");\r\nhsotg->dr_mode = mode;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)\r\n{\r\nstruct platform_device *pdev = to_platform_device(hsotg->dev);\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),\r\nhsotg->supplies);\r\nif (ret)\r\nreturn ret;\r\nif (hsotg->clk) {\r\nret = clk_prepare_enable(hsotg->clk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (hsotg->uphy) {\r\nret = usb_phy_init(hsotg->uphy);\r\n} else if (hsotg->plat && hsotg->plat->phy_init) {\r\nret = hsotg->plat->phy_init(pdev, hsotg->plat->phy_type);\r\n} else {\r\nret = phy_power_on(hsotg->phy);\r\nif (ret == 0)\r\nret = phy_init(hsotg->phy);\r\n}\r\nreturn ret;\r\n}\r\nint dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)\r\n{\r\nint ret = __dwc2_lowlevel_hw_enable(hsotg);\r\nif (ret == 0)\r\nhsotg->ll_hw_enabled = true;\r\nreturn ret;\r\n}\r\nstatic int __dwc2_lowlevel_hw_disable(struct dwc2_hsotg *hsotg)\r\n{\r\nstruct platform_device *pdev = to_platform_device(hsotg->dev);\r\nint ret = 0;\r\nif (hsotg->uphy) {\r\nusb_phy_shutdown(hsotg->uphy);\r\n} else if (hsotg->plat && hsotg->plat->phy_exit) {\r\nret = hsotg->plat->phy_exit(pdev, hsotg->plat->phy_type);\r\n} else {\r\nret = phy_exit(hsotg->phy);\r\nif (ret == 0)\r\nret = phy_power_off(hsotg->phy);\r\n}\r\nif (ret)\r\nreturn ret;\r\nif (hsotg->clk)\r\nclk_disable_unprepare(hsotg->clk);\r\nret = regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies),\r\nhsotg->supplies);\r\nreturn ret;\r\n}\r\nint dwc2_lowlevel_hw_disable(struct dwc2_hsotg *hsotg)\r\n{\r\nint ret = __dwc2_lowlevel_hw_disable(hsotg);\r\nif (ret == 0)\r\nhsotg->ll_hw_enabled = false;\r\nreturn ret;\r\n}\r\nstatic int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)\r\n{\r\nint i, ret;\r\nhsotg->reset = devm_reset_control_get_optional(hsotg->dev, "dwc2");\r\nif (IS_ERR(hsotg->reset)) {\r\nret = PTR_ERR(hsotg->reset);\r\ndev_err(hsotg->dev, "error getting reset control %d\n", ret);\r\nreturn ret;\r\n}\r\nreset_control_deassert(hsotg->reset);\r\nhsotg->phyif = GUSBCFG_PHYIF16;\r\nhsotg->phy = devm_phy_get(hsotg->dev, "usb2-phy");\r\nif (IS_ERR(hsotg->phy)) {\r\nret = PTR_ERR(hsotg->phy);\r\nswitch (ret) {\r\ncase -ENODEV:\r\ncase -ENOSYS:\r\nhsotg->phy = NULL;\r\nbreak;\r\ncase -EPROBE_DEFER:\r\nreturn ret;\r\ndefault:\r\ndev_err(hsotg->dev, "error getting phy %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (!hsotg->phy) {\r\nhsotg->uphy = devm_usb_get_phy(hsotg->dev, USB_PHY_TYPE_USB2);\r\nif (IS_ERR(hsotg->uphy)) {\r\nret = PTR_ERR(hsotg->uphy);\r\nswitch (ret) {\r\ncase -ENODEV:\r\ncase -ENXIO:\r\nhsotg->uphy = NULL;\r\nbreak;\r\ncase -EPROBE_DEFER:\r\nreturn ret;\r\ndefault:\r\ndev_err(hsotg->dev, "error getting usb phy %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nhsotg->plat = dev_get_platdata(hsotg->dev);\r\nif (hsotg->phy) {\r\nif (phy_get_bus_width(hsotg->phy) == 8)\r\nhsotg->phyif = GUSBCFG_PHYIF8;\r\n}\r\nhsotg->clk = devm_clk_get(hsotg->dev, "otg");\r\nif (IS_ERR(hsotg->clk)) {\r\nhsotg->clk = NULL;\r\ndev_dbg(hsotg->dev, "cannot get otg clock\n");\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(hsotg->supplies); i++)\r\nhsotg->supplies[i].supply = dwc2_hsotg_supply_names[i];\r\nret = devm_regulator_bulk_get(hsotg->dev, ARRAY_SIZE(hsotg->supplies),\r\nhsotg->supplies);\r\nif (ret) {\r\ndev_err(hsotg->dev, "failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dwc2_driver_remove(struct platform_device *dev)\r\n{\r\nstruct dwc2_hsotg *hsotg = platform_get_drvdata(dev);\r\ndwc2_debugfs_exit(hsotg);\r\nif (hsotg->hcd_enabled)\r\ndwc2_hcd_remove(hsotg);\r\nif (hsotg->gadget_enabled)\r\ndwc2_hsotg_remove(hsotg);\r\nif (hsotg->ll_hw_enabled)\r\ndwc2_lowlevel_hw_disable(hsotg);\r\nreset_control_assert(hsotg->reset);\r\nreturn 0;\r\n}\r\nstatic void dwc2_driver_shutdown(struct platform_device *dev)\r\n{\r\nstruct dwc2_hsotg *hsotg = platform_get_drvdata(dev);\r\ndisable_irq(hsotg->irq);\r\n}\r\nstatic int dwc2_driver_probe(struct platform_device *dev)\r\n{\r\nstruct dwc2_hsotg *hsotg;\r\nstruct resource *res;\r\nint retval;\r\nhsotg = devm_kzalloc(&dev->dev, sizeof(*hsotg), GFP_KERNEL);\r\nif (!hsotg)\r\nreturn -ENOMEM;\r\nhsotg->dev = &dev->dev;\r\nif (!dev->dev.dma_mask)\r\ndev->dev.dma_mask = &dev->dev.coherent_dma_mask;\r\nretval = dma_set_coherent_mask(&dev->dev, DMA_BIT_MASK(32));\r\nif (retval)\r\nreturn retval;\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nhsotg->regs = devm_ioremap_resource(&dev->dev, res);\r\nif (IS_ERR(hsotg->regs))\r\nreturn PTR_ERR(hsotg->regs);\r\ndev_dbg(&dev->dev, "mapped PA %08lx to VA %p\n",\r\n(unsigned long)res->start, hsotg->regs);\r\nretval = dwc2_lowlevel_hw_init(hsotg);\r\nif (retval)\r\nreturn retval;\r\nspin_lock_init(&hsotg->lock);\r\nhsotg->irq = platform_get_irq(dev, 0);\r\nif (hsotg->irq < 0) {\r\ndev_err(&dev->dev, "missing IRQ resource\n");\r\nreturn hsotg->irq;\r\n}\r\ndev_dbg(hsotg->dev, "registering common handler for irq%d\n",\r\nhsotg->irq);\r\nretval = devm_request_irq(hsotg->dev, hsotg->irq,\r\ndwc2_handle_common_intr, IRQF_SHARED,\r\ndev_name(hsotg->dev), hsotg);\r\nif (retval)\r\nreturn retval;\r\nretval = dwc2_lowlevel_hw_enable(hsotg);\r\nif (retval)\r\nreturn retval;\r\nretval = dwc2_get_dr_mode(hsotg);\r\nif (retval)\r\ngoto error;\r\ndwc2_core_reset_and_force_dr_mode(hsotg);\r\nretval = dwc2_get_hwparams(hsotg);\r\nif (retval)\r\ngoto error;\r\ndwc2_force_dr_mode(hsotg);\r\nretval = dwc2_init_params(hsotg);\r\nif (retval)\r\ngoto error;\r\nif (hsotg->dr_mode != USB_DR_MODE_HOST) {\r\nretval = dwc2_gadget_init(hsotg, hsotg->irq);\r\nif (retval)\r\ngoto error;\r\nhsotg->gadget_enabled = 1;\r\n}\r\nif (hsotg->dr_mode != USB_DR_MODE_PERIPHERAL) {\r\nretval = dwc2_hcd_init(hsotg);\r\nif (retval) {\r\nif (hsotg->gadget_enabled)\r\ndwc2_hsotg_remove(hsotg);\r\ngoto error;\r\n}\r\nhsotg->hcd_enabled = 1;\r\n}\r\nplatform_set_drvdata(dev, hsotg);\r\ndwc2_debugfs_init(hsotg);\r\nif (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)\r\ndwc2_lowlevel_hw_disable(hsotg);\r\nreturn 0;\r\nerror:\r\ndwc2_lowlevel_hw_disable(hsotg);\r\nreturn retval;\r\n}\r\nstatic int __maybe_unused dwc2_suspend(struct device *dev)\r\n{\r\nstruct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);\r\nint ret = 0;\r\nif (dwc2_is_device_mode(dwc2))\r\ndwc2_hsotg_suspend(dwc2);\r\nif (dwc2->ll_hw_enabled)\r\nret = __dwc2_lowlevel_hw_disable(dwc2);\r\nreturn ret;\r\n}\r\nstatic int __maybe_unused dwc2_resume(struct device *dev)\r\n{\r\nstruct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);\r\nint ret = 0;\r\nif (dwc2->ll_hw_enabled) {\r\nret = __dwc2_lowlevel_hw_enable(dwc2);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (dwc2_is_device_mode(dwc2))\r\nret = dwc2_hsotg_resume(dwc2);\r\nreturn ret;\r\n}
