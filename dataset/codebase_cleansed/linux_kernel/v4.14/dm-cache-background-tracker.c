struct background_tracker *btracker_create(unsigned max_work)\r\n{\r\nstruct background_tracker *b = kmalloc(sizeof(*b), GFP_KERNEL);\r\nif (!b) {\r\nDMERR("couldn't create background_tracker");\r\nreturn NULL;\r\n}\r\nb->max_work = max_work;\r\natomic_set(&b->pending_promotes, 0);\r\natomic_set(&b->pending_writebacks, 0);\r\natomic_set(&b->pending_demotes, 0);\r\nINIT_LIST_HEAD(&b->issued);\r\nINIT_LIST_HEAD(&b->queued);\r\nb->pending = RB_ROOT;\r\nb->work_cache = KMEM_CACHE(bt_work, 0);\r\nif (!b->work_cache) {\r\nDMERR("couldn't create mempool for background work items");\r\nkfree(b);\r\nb = NULL;\r\n}\r\nreturn b;\r\n}\r\nvoid btracker_destroy(struct background_tracker *b)\r\n{\r\nkmem_cache_destroy(b->work_cache);\r\nkfree(b);\r\n}\r\nstatic int cmp_oblock(dm_oblock_t lhs, dm_oblock_t rhs)\r\n{\r\nif (from_oblock(lhs) < from_oblock(rhs))\r\nreturn -1;\r\nif (from_oblock(rhs) < from_oblock(lhs))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic bool __insert_pending(struct background_tracker *b,\r\nstruct bt_work *nw)\r\n{\r\nint cmp;\r\nstruct bt_work *w;\r\nstruct rb_node **new = &b->pending.rb_node, *parent = NULL;\r\nwhile (*new) {\r\nw = container_of(*new, struct bt_work, node);\r\nparent = *new;\r\ncmp = cmp_oblock(w->work.oblock, nw->work.oblock);\r\nif (cmp < 0)\r\nnew = &((*new)->rb_left);\r\nelse if (cmp > 0)\r\nnew = &((*new)->rb_right);\r\nelse\r\nreturn false;\r\n}\r\nrb_link_node(&nw->node, parent, new);\r\nrb_insert_color(&nw->node, &b->pending);\r\nreturn true;\r\n}\r\nstatic struct bt_work *__find_pending(struct background_tracker *b,\r\ndm_oblock_t oblock)\r\n{\r\nint cmp;\r\nstruct bt_work *w;\r\nstruct rb_node **new = &b->pending.rb_node;\r\nwhile (*new) {\r\nw = container_of(*new, struct bt_work, node);\r\ncmp = cmp_oblock(w->work.oblock, oblock);\r\nif (cmp < 0)\r\nnew = &((*new)->rb_left);\r\nelse if (cmp > 0)\r\nnew = &((*new)->rb_right);\r\nelse\r\nbreak;\r\n}\r\nreturn *new ? w : NULL;\r\n}\r\nstatic void update_stats(struct background_tracker *b, struct policy_work *w, int delta)\r\n{\r\nswitch (w->op) {\r\ncase POLICY_PROMOTE:\r\natomic_add(delta, &b->pending_promotes);\r\nbreak;\r\ncase POLICY_DEMOTE:\r\natomic_add(delta, &b->pending_demotes);\r\nbreak;\r\ncase POLICY_WRITEBACK:\r\natomic_add(delta, &b->pending_writebacks);\r\nbreak;\r\n}\r\n}\r\nunsigned btracker_nr_writebacks_queued(struct background_tracker *b)\r\n{\r\nreturn atomic_read(&b->pending_writebacks);\r\n}\r\nunsigned btracker_nr_demotions_queued(struct background_tracker *b)\r\n{\r\nreturn atomic_read(&b->pending_demotes);\r\n}\r\nstatic bool max_work_reached(struct background_tracker *b)\r\n{\r\nreturn false;\r\n}\r\nint btracker_queue(struct background_tracker *b,\r\nstruct policy_work *work,\r\nstruct policy_work **pwork)\r\n{\r\nstruct bt_work *w;\r\nif (pwork)\r\n*pwork = NULL;\r\nif (max_work_reached(b))\r\nreturn -ENOMEM;\r\nw = kmem_cache_alloc(b->work_cache, GFP_NOWAIT);\r\nif (!w)\r\nreturn -ENOMEM;\r\nmemcpy(&w->work, work, sizeof(*work));\r\nif (!__insert_pending(b, w)) {\r\nkmem_cache_free(b->work_cache, w);\r\nreturn -EINVAL;\r\n}\r\nif (pwork) {\r\n*pwork = &w->work;\r\nlist_add(&w->list, &b->issued);\r\n} else\r\nlist_add(&w->list, &b->queued);\r\nupdate_stats(b, &w->work, 1);\r\nreturn 0;\r\n}\r\nint btracker_issue(struct background_tracker *b, struct policy_work **work)\r\n{\r\nstruct bt_work *w;\r\nif (list_empty(&b->queued))\r\nreturn -ENODATA;\r\nw = list_first_entry(&b->queued, struct bt_work, list);\r\nlist_move(&w->list, &b->issued);\r\n*work = &w->work;\r\nreturn 0;\r\n}\r\nvoid btracker_complete(struct background_tracker *b,\r\nstruct policy_work *op)\r\n{\r\nstruct bt_work *w = container_of(op, struct bt_work, work);\r\nupdate_stats(b, &w->work, -1);\r\nrb_erase(&w->node, &b->pending);\r\nlist_del(&w->list);\r\nkmem_cache_free(b->work_cache, w);\r\n}\r\nbool btracker_promotion_already_present(struct background_tracker *b,\r\ndm_oblock_t oblock)\r\n{\r\nreturn __find_pending(b, oblock) != NULL;\r\n}
