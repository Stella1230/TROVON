static void xlgmac_read_mac_addr(struct xlgmac_pdata *pdata)\r\n{\r\nstruct net_device *netdev = pdata->netdev;\r\nmemcpy(pdata->mac_addr, dev_addr, netdev->addr_len);\r\n}\r\nstatic void xlgmac_default_config(struct xlgmac_pdata *pdata)\r\n{\r\npdata->tx_osp_mode = DMA_OSP_ENABLE;\r\npdata->tx_sf_mode = MTL_TSF_ENABLE;\r\npdata->rx_sf_mode = MTL_RSF_DISABLE;\r\npdata->pblx8 = DMA_PBL_X8_ENABLE;\r\npdata->tx_pbl = DMA_PBL_32;\r\npdata->rx_pbl = DMA_PBL_32;\r\npdata->tx_threshold = MTL_TX_THRESHOLD_128;\r\npdata->rx_threshold = MTL_RX_THRESHOLD_128;\r\npdata->tx_pause = 1;\r\npdata->rx_pause = 1;\r\npdata->phy_speed = SPEED_25000;\r\npdata->sysclk_rate = XLGMAC_SYSCLOCK;\r\nstrlcpy(pdata->drv_name, XLGMAC_DRV_NAME, sizeof(pdata->drv_name));\r\nstrlcpy(pdata->drv_ver, XLGMAC_DRV_VERSION, sizeof(pdata->drv_ver));\r\n}\r\nstatic void xlgmac_init_all_ops(struct xlgmac_pdata *pdata)\r\n{\r\nxlgmac_init_desc_ops(&pdata->desc_ops);\r\nxlgmac_init_hw_ops(&pdata->hw_ops);\r\n}\r\nstatic int xlgmac_init(struct xlgmac_pdata *pdata)\r\n{\r\nstruct xlgmac_hw_ops *hw_ops = &pdata->hw_ops;\r\nstruct net_device *netdev = pdata->netdev;\r\nunsigned int i;\r\nint ret;\r\nxlgmac_default_config(pdata);\r\nnetdev->irq = pdata->dev_irq;\r\nnetdev->base_addr = (unsigned long)pdata->mac_regs;\r\nxlgmac_read_mac_addr(pdata);\r\nmemcpy(netdev->dev_addr, pdata->mac_addr, netdev->addr_len);\r\nxlgmac_init_all_ops(pdata);\r\nhw_ops->exit(pdata);\r\nxlgmac_get_all_hw_features(pdata);\r\nxlgmac_print_all_hw_features(pdata);\r\nret = dma_set_mask_and_coherent(pdata->dev,\r\nDMA_BIT_MASK(pdata->hw_feat.dma_width));\r\nif (ret) {\r\ndev_err(pdata->dev, "dma_set_mask_and_coherent failed\n");\r\nreturn ret;\r\n}\r\nBUILD_BUG_ON_NOT_POWER_OF_2(XLGMAC_TX_DESC_CNT);\r\npdata->tx_desc_count = XLGMAC_TX_DESC_CNT;\r\nif (pdata->tx_desc_count & (pdata->tx_desc_count - 1)) {\r\ndev_err(pdata->dev, "tx descriptor count (%d) is not valid\n",\r\npdata->tx_desc_count);\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nBUILD_BUG_ON_NOT_POWER_OF_2(XLGMAC_RX_DESC_CNT);\r\npdata->rx_desc_count = XLGMAC_RX_DESC_CNT;\r\nif (pdata->rx_desc_count & (pdata->rx_desc_count - 1)) {\r\ndev_err(pdata->dev, "rx descriptor count (%d) is not valid\n",\r\npdata->rx_desc_count);\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\npdata->tx_ring_count = min_t(unsigned int, num_online_cpus(),\r\npdata->hw_feat.tx_ch_cnt);\r\npdata->tx_ring_count = min_t(unsigned int, pdata->tx_ring_count,\r\npdata->hw_feat.tx_q_cnt);\r\npdata->tx_q_count = pdata->tx_ring_count;\r\nret = netif_set_real_num_tx_queues(netdev, pdata->tx_q_count);\r\nif (ret) {\r\ndev_err(pdata->dev, "error setting real tx queue count\n");\r\nreturn ret;\r\n}\r\npdata->rx_ring_count = min_t(unsigned int,\r\nnetif_get_num_default_rss_queues(),\r\npdata->hw_feat.rx_ch_cnt);\r\npdata->rx_ring_count = min_t(unsigned int, pdata->rx_ring_count,\r\npdata->hw_feat.rx_q_cnt);\r\npdata->rx_q_count = pdata->rx_ring_count;\r\nret = netif_set_real_num_rx_queues(netdev, pdata->rx_q_count);\r\nif (ret) {\r\ndev_err(pdata->dev, "error setting real rx queue count\n");\r\nreturn ret;\r\n}\r\npdata->channel_count =\r\nmax_t(unsigned int, pdata->tx_ring_count, pdata->rx_ring_count);\r\nnetdev_rss_key_fill(pdata->rss_key, sizeof(pdata->rss_key));\r\nfor (i = 0; i < XLGMAC_RSS_MAX_TABLE_SIZE; i++)\r\npdata->rss_table[i] = XLGMAC_SET_REG_BITS(\r\npdata->rss_table[i],\r\nMAC_RSSDR_DMCH_POS,\r\nMAC_RSSDR_DMCH_LEN,\r\ni % pdata->rx_ring_count);\r\npdata->rss_options = XLGMAC_SET_REG_BITS(\r\npdata->rss_options,\r\nMAC_RSSCR_IP2TE_POS,\r\nMAC_RSSCR_IP2TE_LEN, 1);\r\npdata->rss_options = XLGMAC_SET_REG_BITS(\r\npdata->rss_options,\r\nMAC_RSSCR_TCP4TE_POS,\r\nMAC_RSSCR_TCP4TE_LEN, 1);\r\npdata->rss_options = XLGMAC_SET_REG_BITS(\r\npdata->rss_options,\r\nMAC_RSSCR_UDP4TE_POS,\r\nMAC_RSSCR_UDP4TE_LEN, 1);\r\nnetdev->netdev_ops = xlgmac_get_netdev_ops();\r\nnetdev->ethtool_ops = xlgmac_get_ethtool_ops();\r\nif (pdata->hw_feat.tso) {\r\nnetdev->hw_features = NETIF_F_TSO;\r\nnetdev->hw_features |= NETIF_F_TSO6;\r\nnetdev->hw_features |= NETIF_F_SG;\r\nnetdev->hw_features |= NETIF_F_IP_CSUM;\r\nnetdev->hw_features |= NETIF_F_IPV6_CSUM;\r\n} else if (pdata->hw_feat.tx_coe) {\r\nnetdev->hw_features = NETIF_F_IP_CSUM;\r\nnetdev->hw_features |= NETIF_F_IPV6_CSUM;\r\n}\r\nif (pdata->hw_feat.rx_coe) {\r\nnetdev->hw_features |= NETIF_F_RXCSUM;\r\nnetdev->hw_features |= NETIF_F_GRO;\r\n}\r\nif (pdata->hw_feat.rss)\r\nnetdev->hw_features |= NETIF_F_RXHASH;\r\nnetdev->vlan_features |= netdev->hw_features;\r\nnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_RX;\r\nif (pdata->hw_feat.sa_vlan_ins)\r\nnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_TX;\r\nif (pdata->hw_feat.vlhash)\r\nnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;\r\nnetdev->features |= netdev->hw_features;\r\npdata->netdev_features = netdev->features;\r\nnetdev->priv_flags |= IFF_UNICAST_FLT;\r\nnetdev->watchdog_timeo = 0;\r\npdata->tx_usecs = XLGMAC_INIT_DMA_TX_USECS;\r\npdata->tx_frames = XLGMAC_INIT_DMA_TX_FRAMES;\r\npdata->rx_riwt = hw_ops->usec_to_riwt(pdata, XLGMAC_INIT_DMA_RX_USECS);\r\npdata->rx_usecs = XLGMAC_INIT_DMA_RX_USECS;\r\npdata->rx_frames = XLGMAC_INIT_DMA_RX_FRAMES;\r\nreturn 0;\r\n}\r\nint xlgmac_drv_probe(struct device *dev, struct xlgmac_resources *res)\r\n{\r\nstruct xlgmac_pdata *pdata;\r\nstruct net_device *netdev;\r\nint ret;\r\nnetdev = alloc_etherdev_mq(sizeof(struct xlgmac_pdata),\r\nXLGMAC_MAX_DMA_CHANNELS);\r\nif (!netdev) {\r\ndev_err(dev, "alloc_etherdev failed\n");\r\nreturn -ENOMEM;\r\n}\r\nSET_NETDEV_DEV(netdev, dev);\r\ndev_set_drvdata(dev, netdev);\r\npdata = netdev_priv(netdev);\r\npdata->dev = dev;\r\npdata->netdev = netdev;\r\npdata->dev_irq = res->irq;\r\npdata->mac_regs = res->addr;\r\nmutex_init(&pdata->rss_mutex);\r\npdata->msg_enable = netif_msg_init(debug, default_msg_level);\r\nret = xlgmac_init(pdata);\r\nif (ret) {\r\ndev_err(dev, "xlgmac init failed\n");\r\ngoto err_free_netdev;\r\n}\r\nret = register_netdev(netdev);\r\nif (ret) {\r\ndev_err(dev, "net device registration failed\n");\r\ngoto err_free_netdev;\r\n}\r\nreturn 0;\r\nerr_free_netdev:\r\nfree_netdev(netdev);\r\nreturn ret;\r\n}\r\nint xlgmac_drv_remove(struct device *dev)\r\n{\r\nstruct net_device *netdev = dev_get_drvdata(dev);\r\nunregister_netdev(netdev);\r\nfree_netdev(netdev);\r\nreturn 0;\r\n}\r\nvoid xlgmac_dump_tx_desc(struct xlgmac_pdata *pdata,\r\nstruct xlgmac_ring *ring,\r\nunsigned int idx,\r\nunsigned int count,\r\nunsigned int flag)\r\n{\r\nstruct xlgmac_desc_data *desc_data;\r\nstruct xlgmac_dma_desc *dma_desc;\r\nwhile (count--) {\r\ndesc_data = XLGMAC_GET_DESC_DATA(ring, idx);\r\ndma_desc = desc_data->dma_desc;\r\nnetdev_dbg(pdata->netdev, "TX: dma_desc=%p, dma_desc_addr=%pad\n",\r\ndesc_data->dma_desc, &desc_data->dma_desc_addr);\r\nnetdev_dbg(pdata->netdev,\r\n"TX_NORMAL_DESC[%d %s] = %08x:%08x:%08x:%08x\n", idx,\r\n(flag == 1) ? "QUEUED FOR TX" : "TX BY DEVICE",\r\nle32_to_cpu(dma_desc->desc0),\r\nle32_to_cpu(dma_desc->desc1),\r\nle32_to_cpu(dma_desc->desc2),\r\nle32_to_cpu(dma_desc->desc3));\r\nidx++;\r\n}\r\n}\r\nvoid xlgmac_dump_rx_desc(struct xlgmac_pdata *pdata,\r\nstruct xlgmac_ring *ring,\r\nunsigned int idx)\r\n{\r\nstruct xlgmac_desc_data *desc_data;\r\nstruct xlgmac_dma_desc *dma_desc;\r\ndesc_data = XLGMAC_GET_DESC_DATA(ring, idx);\r\ndma_desc = desc_data->dma_desc;\r\nnetdev_dbg(pdata->netdev, "RX: dma_desc=%p, dma_desc_addr=%pad\n",\r\ndesc_data->dma_desc, &desc_data->dma_desc_addr);\r\nnetdev_dbg(pdata->netdev,\r\n"RX_NORMAL_DESC[%d RX BY DEVICE] = %08x:%08x:%08x:%08x\n",\r\nidx,\r\nle32_to_cpu(dma_desc->desc0),\r\nle32_to_cpu(dma_desc->desc1),\r\nle32_to_cpu(dma_desc->desc2),\r\nle32_to_cpu(dma_desc->desc3));\r\n}\r\nvoid xlgmac_print_pkt(struct net_device *netdev,\r\nstruct sk_buff *skb, bool tx_rx)\r\n{\r\nstruct ethhdr *eth = (struct ethhdr *)skb->data;\r\nunsigned char *buf = skb->data;\r\nunsigned char buffer[128];\r\nunsigned int i, j;\r\nnetdev_dbg(netdev, "\n************** SKB dump ****************\n");\r\nnetdev_dbg(netdev, "%s packet of %d bytes\n",\r\n(tx_rx ? "TX" : "RX"), skb->len);\r\nnetdev_dbg(netdev, "Dst MAC addr: %pM\n", eth->h_dest);\r\nnetdev_dbg(netdev, "Src MAC addr: %pM\n", eth->h_source);\r\nnetdev_dbg(netdev, "Protocol: %#06hx\n", ntohs(eth->h_proto));\r\nfor (i = 0, j = 0; i < skb->len;) {\r\nj += snprintf(buffer + j, sizeof(buffer) - j, "%02hhx",\r\nbuf[i++]);\r\nif ((i % 32) == 0) {\r\nnetdev_dbg(netdev, " %#06x: %s\n", i - 32, buffer);\r\nj = 0;\r\n} else if ((i % 16) == 0) {\r\nbuffer[j++] = ' ';\r\nbuffer[j++] = ' ';\r\n} else if ((i % 4) == 0) {\r\nbuffer[j++] = ' ';\r\n}\r\n}\r\nif (i % 32)\r\nnetdev_dbg(netdev, " %#06x: %s\n", i - (i % 32), buffer);\r\nnetdev_dbg(netdev, "\n************** SKB dump ****************\n");\r\n}\r\nvoid xlgmac_get_all_hw_features(struct xlgmac_pdata *pdata)\r\n{\r\nstruct xlgmac_hw_features *hw_feat = &pdata->hw_feat;\r\nunsigned int mac_hfr0, mac_hfr1, mac_hfr2;\r\nmac_hfr0 = readl(pdata->mac_regs + MAC_HWF0R);\r\nmac_hfr1 = readl(pdata->mac_regs + MAC_HWF1R);\r\nmac_hfr2 = readl(pdata->mac_regs + MAC_HWF2R);\r\nmemset(hw_feat, 0, sizeof(*hw_feat));\r\nhw_feat->version = readl(pdata->mac_regs + MAC_VR);\r\nhw_feat->phyifsel = XLGMAC_GET_REG_BITS(mac_hfr0,\r\nMAC_HWF0R_PHYIFSEL_POS,\r\nMAC_HWF0R_PHYIFSEL_LEN);\r\nhw_feat->vlhash = XLGMAC_GET_REG_BITS(mac_hfr0,\r\nMAC_HWF0R_VLHASH_POS,\r\nMAC_HWF0R_VLHASH_LEN);\r\nhw_feat->sma = XLGMAC_GET_REG_BITS(mac_hfr0,\r\nMAC_HWF0R_SMASEL_POS,\r\nMAC_HWF0R_SMASEL_LEN);\r\nhw_feat->rwk = XLGMAC_GET_REG_BITS(mac_hfr0,\r\nMAC_HWF0R_RWKSEL_POS,\r\nMAC_HWF0R_RWKSEL_LEN);\r\nhw_feat->mgk = XLGMAC_GET_REG_BITS(mac_hfr0,\r\nMAC_HWF0R_MGKSEL_POS,\r\nMAC_HWF0R_MGKSEL_LEN);\r\nhw_feat->mmc = XLGMAC_GET_REG_BITS(mac_hfr0,\r\nMAC_HWF0R_MMCSEL_POS,\r\nMAC_HWF0R_MMCSEL_LEN);\r\nhw_feat->aoe = XLGMAC_GET_REG_BITS(mac_hfr0,\r\nMAC_HWF0R_ARPOFFSEL_POS,\r\nMAC_HWF0R_ARPOFFSEL_LEN);\r\nhw_feat->ts = XLGMAC_GET_REG_BITS(mac_hfr0,\r\nMAC_HWF0R_TSSEL_POS,\r\nMAC_HWF0R_TSSEL_LEN);\r\nhw_feat->eee = XLGMAC_GET_REG_BITS(mac_hfr0,\r\nMAC_HWF0R_EEESEL_POS,\r\nMAC_HWF0R_EEESEL_LEN);\r\nhw_feat->tx_coe = XLGMAC_GET_REG_BITS(mac_hfr0,\r\nMAC_HWF0R_TXCOESEL_POS,\r\nMAC_HWF0R_TXCOESEL_LEN);\r\nhw_feat->rx_coe = XLGMAC_GET_REG_BITS(mac_hfr0,\r\nMAC_HWF0R_RXCOESEL_POS,\r\nMAC_HWF0R_RXCOESEL_LEN);\r\nhw_feat->addn_mac = XLGMAC_GET_REG_BITS(mac_hfr0,\r\nMAC_HWF0R_ADDMACADRSEL_POS,\r\nMAC_HWF0R_ADDMACADRSEL_LEN);\r\nhw_feat->ts_src = XLGMAC_GET_REG_BITS(mac_hfr0,\r\nMAC_HWF0R_TSSTSSEL_POS,\r\nMAC_HWF0R_TSSTSSEL_LEN);\r\nhw_feat->sa_vlan_ins = XLGMAC_GET_REG_BITS(mac_hfr0,\r\nMAC_HWF0R_SAVLANINS_POS,\r\nMAC_HWF0R_SAVLANINS_LEN);\r\nhw_feat->rx_fifo_size = XLGMAC_GET_REG_BITS(mac_hfr1,\r\nMAC_HWF1R_RXFIFOSIZE_POS,\r\nMAC_HWF1R_RXFIFOSIZE_LEN);\r\nhw_feat->tx_fifo_size = XLGMAC_GET_REG_BITS(mac_hfr1,\r\nMAC_HWF1R_TXFIFOSIZE_POS,\r\nMAC_HWF1R_TXFIFOSIZE_LEN);\r\nhw_feat->adv_ts_hi = XLGMAC_GET_REG_BITS(mac_hfr1,\r\nMAC_HWF1R_ADVTHWORD_POS,\r\nMAC_HWF1R_ADVTHWORD_LEN);\r\nhw_feat->dma_width = XLGMAC_GET_REG_BITS(mac_hfr1,\r\nMAC_HWF1R_ADDR64_POS,\r\nMAC_HWF1R_ADDR64_LEN);\r\nhw_feat->dcb = XLGMAC_GET_REG_BITS(mac_hfr1,\r\nMAC_HWF1R_DCBEN_POS,\r\nMAC_HWF1R_DCBEN_LEN);\r\nhw_feat->sph = XLGMAC_GET_REG_BITS(mac_hfr1,\r\nMAC_HWF1R_SPHEN_POS,\r\nMAC_HWF1R_SPHEN_LEN);\r\nhw_feat->tso = XLGMAC_GET_REG_BITS(mac_hfr1,\r\nMAC_HWF1R_TSOEN_POS,\r\nMAC_HWF1R_TSOEN_LEN);\r\nhw_feat->dma_debug = XLGMAC_GET_REG_BITS(mac_hfr1,\r\nMAC_HWF1R_DBGMEMA_POS,\r\nMAC_HWF1R_DBGMEMA_LEN);\r\nhw_feat->rss = XLGMAC_GET_REG_BITS(mac_hfr1,\r\nMAC_HWF1R_RSSEN_POS,\r\nMAC_HWF1R_RSSEN_LEN);\r\nhw_feat->tc_cnt = XLGMAC_GET_REG_BITS(mac_hfr1,\r\nMAC_HWF1R_NUMTC_POS,\r\nMAC_HWF1R_NUMTC_LEN);\r\nhw_feat->hash_table_size = XLGMAC_GET_REG_BITS(mac_hfr1,\r\nMAC_HWF1R_HASHTBLSZ_POS,\r\nMAC_HWF1R_HASHTBLSZ_LEN);\r\nhw_feat->l3l4_filter_num = XLGMAC_GET_REG_BITS(mac_hfr1,\r\nMAC_HWF1R_L3L4FNUM_POS,\r\nMAC_HWF1R_L3L4FNUM_LEN);\r\nhw_feat->rx_q_cnt = XLGMAC_GET_REG_BITS(mac_hfr2,\r\nMAC_HWF2R_RXQCNT_POS,\r\nMAC_HWF2R_RXQCNT_LEN);\r\nhw_feat->tx_q_cnt = XLGMAC_GET_REG_BITS(mac_hfr2,\r\nMAC_HWF2R_TXQCNT_POS,\r\nMAC_HWF2R_TXQCNT_LEN);\r\nhw_feat->rx_ch_cnt = XLGMAC_GET_REG_BITS(mac_hfr2,\r\nMAC_HWF2R_RXCHCNT_POS,\r\nMAC_HWF2R_RXCHCNT_LEN);\r\nhw_feat->tx_ch_cnt = XLGMAC_GET_REG_BITS(mac_hfr2,\r\nMAC_HWF2R_TXCHCNT_POS,\r\nMAC_HWF2R_TXCHCNT_LEN);\r\nhw_feat->pps_out_num = XLGMAC_GET_REG_BITS(mac_hfr2,\r\nMAC_HWF2R_PPSOUTNUM_POS,\r\nMAC_HWF2R_PPSOUTNUM_LEN);\r\nhw_feat->aux_snap_num = XLGMAC_GET_REG_BITS(mac_hfr2,\r\nMAC_HWF2R_AUXSNAPNUM_POS,\r\nMAC_HWF2R_AUXSNAPNUM_LEN);\r\nswitch (hw_feat->hash_table_size) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nhw_feat->hash_table_size = 64;\r\nbreak;\r\ncase 2:\r\nhw_feat->hash_table_size = 128;\r\nbreak;\r\ncase 3:\r\nhw_feat->hash_table_size = 256;\r\nbreak;\r\n}\r\nswitch (hw_feat->dma_width) {\r\ncase 0:\r\nhw_feat->dma_width = 32;\r\nbreak;\r\ncase 1:\r\nhw_feat->dma_width = 40;\r\nbreak;\r\ncase 2:\r\nhw_feat->dma_width = 48;\r\nbreak;\r\ndefault:\r\nhw_feat->dma_width = 32;\r\n}\r\nhw_feat->rx_q_cnt++;\r\nhw_feat->tx_q_cnt++;\r\nhw_feat->rx_ch_cnt++;\r\nhw_feat->tx_ch_cnt++;\r\nhw_feat->tc_cnt++;\r\n}\r\nvoid xlgmac_print_all_hw_features(struct xlgmac_pdata *pdata)\r\n{\r\nchar *str = NULL;\r\nXLGMAC_PR("\n");\r\nXLGMAC_PR("=====================================================\n");\r\nXLGMAC_PR("\n");\r\nXLGMAC_PR("HW support following features\n");\r\nXLGMAC_PR("\n");\r\nXLGMAC_PR("VLAN Hash Filter Selected : %s\n",\r\npdata->hw_feat.vlhash ? "YES" : "NO");\r\nXLGMAC_PR("SMA (MDIO) Interface : %s\n",\r\npdata->hw_feat.sma ? "YES" : "NO");\r\nXLGMAC_PR("PMT Remote Wake-up Packet Enable : %s\n",\r\npdata->hw_feat.rwk ? "YES" : "NO");\r\nXLGMAC_PR("PMT Magic Packet Enable : %s\n",\r\npdata->hw_feat.mgk ? "YES" : "NO");\r\nXLGMAC_PR("RMON/MMC Module Enable : %s\n",\r\npdata->hw_feat.mmc ? "YES" : "NO");\r\nXLGMAC_PR("ARP Offload Enabled : %s\n",\r\npdata->hw_feat.aoe ? "YES" : "NO");\r\nXLGMAC_PR("IEEE 1588-2008 Timestamp Enabled : %s\n",\r\npdata->hw_feat.ts ? "YES" : "NO");\r\nXLGMAC_PR("Energy Efficient Ethernet Enabled : %s\n",\r\npdata->hw_feat.eee ? "YES" : "NO");\r\nXLGMAC_PR("Transmit Checksum Offload Enabled : %s\n",\r\npdata->hw_feat.tx_coe ? "YES" : "NO");\r\nXLGMAC_PR("Receive Checksum Offload Enabled : %s\n",\r\npdata->hw_feat.rx_coe ? "YES" : "NO");\r\nXLGMAC_PR("Additional MAC Addresses 1-31 Selected : %s\n",\r\npdata->hw_feat.addn_mac ? "YES" : "NO");\r\nswitch (pdata->hw_feat.ts_src) {\r\ncase 0:\r\nstr = "RESERVED";\r\nbreak;\r\ncase 1:\r\nstr = "INTERNAL";\r\nbreak;\r\ncase 2:\r\nstr = "EXTERNAL";\r\nbreak;\r\ncase 3:\r\nstr = "BOTH";\r\nbreak;\r\n}\r\nXLGMAC_PR("Timestamp System Time Source : %s\n", str);\r\nXLGMAC_PR("Source Address or VLAN Insertion Enable : %s\n",\r\npdata->hw_feat.sa_vlan_ins ? "YES" : "NO");\r\nswitch (pdata->hw_feat.rx_fifo_size) {\r\ncase 0:\r\nstr = "128 bytes";\r\nbreak;\r\ncase 1:\r\nstr = "256 bytes";\r\nbreak;\r\ncase 2:\r\nstr = "512 bytes";\r\nbreak;\r\ncase 3:\r\nstr = "1 KBytes";\r\nbreak;\r\ncase 4:\r\nstr = "2 KBytes";\r\nbreak;\r\ncase 5:\r\nstr = "4 KBytes";\r\nbreak;\r\ncase 6:\r\nstr = "8 KBytes";\r\nbreak;\r\ncase 7:\r\nstr = "16 KBytes";\r\nbreak;\r\ncase 8:\r\nstr = "32 kBytes";\r\nbreak;\r\ncase 9:\r\nstr = "64 KBytes";\r\nbreak;\r\ncase 10:\r\nstr = "128 KBytes";\r\nbreak;\r\ncase 11:\r\nstr = "256 KBytes";\r\nbreak;\r\ndefault:\r\nstr = "RESERVED";\r\n}\r\nXLGMAC_PR("MTL Receive FIFO Size : %s\n", str);\r\nswitch (pdata->hw_feat.tx_fifo_size) {\r\ncase 0:\r\nstr = "128 bytes";\r\nbreak;\r\ncase 1:\r\nstr = "256 bytes";\r\nbreak;\r\ncase 2:\r\nstr = "512 bytes";\r\nbreak;\r\ncase 3:\r\nstr = "1 KBytes";\r\nbreak;\r\ncase 4:\r\nstr = "2 KBytes";\r\nbreak;\r\ncase 5:\r\nstr = "4 KBytes";\r\nbreak;\r\ncase 6:\r\nstr = "8 KBytes";\r\nbreak;\r\ncase 7:\r\nstr = "16 KBytes";\r\nbreak;\r\ncase 8:\r\nstr = "32 kBytes";\r\nbreak;\r\ncase 9:\r\nstr = "64 KBytes";\r\nbreak;\r\ncase 10:\r\nstr = "128 KBytes";\r\nbreak;\r\ncase 11:\r\nstr = "256 KBytes";\r\nbreak;\r\ndefault:\r\nstr = "RESERVED";\r\n}\r\nXLGMAC_PR("MTL Transmit FIFO Size : %s\n", str);\r\nXLGMAC_PR("IEEE 1588 High Word Register Enable : %s\n",\r\npdata->hw_feat.adv_ts_hi ? "YES" : "NO");\r\nXLGMAC_PR("Address width : %u\n",\r\npdata->hw_feat.dma_width);\r\nXLGMAC_PR("DCB Feature Enable : %s\n",\r\npdata->hw_feat.dcb ? "YES" : "NO");\r\nXLGMAC_PR("Split Header Feature Enable : %s\n",\r\npdata->hw_feat.sph ? "YES" : "NO");\r\nXLGMAC_PR("TCP Segmentation Offload Enable : %s\n",\r\npdata->hw_feat.tso ? "YES" : "NO");\r\nXLGMAC_PR("DMA Debug Registers Enabled : %s\n",\r\npdata->hw_feat.dma_debug ? "YES" : "NO");\r\nXLGMAC_PR("RSS Feature Enabled : %s\n",\r\npdata->hw_feat.rss ? "YES" : "NO");\r\nXLGMAC_PR("Number of Traffic classes : %u\n",\r\n(pdata->hw_feat.tc_cnt));\r\nXLGMAC_PR("Hash Table Size : %u\n",\r\npdata->hw_feat.hash_table_size);\r\nXLGMAC_PR("Total number of L3 or L4 Filters : %u\n",\r\npdata->hw_feat.l3l4_filter_num);\r\nXLGMAC_PR("Number of MTL Receive Queues : %u\n",\r\npdata->hw_feat.rx_q_cnt);\r\nXLGMAC_PR("Number of MTL Transmit Queues : %u\n",\r\npdata->hw_feat.tx_q_cnt);\r\nXLGMAC_PR("Number of DMA Receive Channels : %u\n",\r\npdata->hw_feat.rx_ch_cnt);\r\nXLGMAC_PR("Number of DMA Transmit Channels : %u\n",\r\npdata->hw_feat.tx_ch_cnt);\r\nswitch (pdata->hw_feat.pps_out_num) {\r\ncase 0:\r\nstr = "No PPS output";\r\nbreak;\r\ncase 1:\r\nstr = "1 PPS output";\r\nbreak;\r\ncase 2:\r\nstr = "2 PPS output";\r\nbreak;\r\ncase 3:\r\nstr = "3 PPS output";\r\nbreak;\r\ncase 4:\r\nstr = "4 PPS output";\r\nbreak;\r\ndefault:\r\nstr = "RESERVED";\r\n}\r\nXLGMAC_PR("Number of PPS Outputs : %s\n", str);\r\nswitch (pdata->hw_feat.aux_snap_num) {\r\ncase 0:\r\nstr = "No auxiliary input";\r\nbreak;\r\ncase 1:\r\nstr = "1 auxiliary input";\r\nbreak;\r\ncase 2:\r\nstr = "2 auxiliary input";\r\nbreak;\r\ncase 3:\r\nstr = "3 auxiliary input";\r\nbreak;\r\ncase 4:\r\nstr = "4 auxiliary input";\r\nbreak;\r\ndefault:\r\nstr = "RESERVED";\r\n}\r\nXLGMAC_PR("Number of Auxiliary Snapshot Inputs : %s", str);\r\nXLGMAC_PR("\n");\r\nXLGMAC_PR("=====================================================\n");\r\nXLGMAC_PR("\n");\r\n}
