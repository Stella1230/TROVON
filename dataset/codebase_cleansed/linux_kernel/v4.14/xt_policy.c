static inline bool\r\nxt_addr_cmp(const union nf_inet_addr *a1, const union nf_inet_addr *m,\r\nconst union nf_inet_addr *a2, unsigned short family)\r\n{\r\nswitch (family) {\r\ncase NFPROTO_IPV4:\r\nreturn ((a1->ip ^ a2->ip) & m->ip) == 0;\r\ncase NFPROTO_IPV6:\r\nreturn ipv6_masked_addr_cmp(&a1->in6, &m->in6, &a2->in6) == 0;\r\n}\r\nreturn false;\r\n}\r\nstatic bool\r\nmatch_xfrm_state(const struct xfrm_state *x, const struct xt_policy_elem *e,\r\nunsigned short family)\r\n{\r\n#define MATCH_ADDR(x,y,z) (!e->match.x || \\r\n(xt_addr_cmp(&e->x, &e->y, (const union nf_inet_addr *)(z), family) \\r\n^ e->invert.x))\r\n#define MATCH(x,y) (!e->match.x || ((e->x == (y)) ^ e->invert.x))\r\nreturn MATCH_ADDR(saddr, smask, &x->props.saddr) &&\r\nMATCH_ADDR(daddr, dmask, &x->id.daddr) &&\r\nMATCH(proto, x->id.proto) &&\r\nMATCH(mode, x->props.mode) &&\r\nMATCH(spi, x->id.spi) &&\r\nMATCH(reqid, x->props.reqid);\r\n}\r\nstatic int\r\nmatch_policy_in(const struct sk_buff *skb, const struct xt_policy_info *info,\r\nunsigned short family)\r\n{\r\nconst struct xt_policy_elem *e;\r\nconst struct sec_path *sp = skb->sp;\r\nint strict = info->flags & XT_POLICY_MATCH_STRICT;\r\nint i, pos;\r\nif (sp == NULL)\r\nreturn -1;\r\nif (strict && info->len != sp->len)\r\nreturn 0;\r\nfor (i = sp->len - 1; i >= 0; i--) {\r\npos = strict ? i - sp->len + 1 : 0;\r\nif (pos >= info->len)\r\nreturn 0;\r\ne = &info->pol[pos];\r\nif (match_xfrm_state(sp->xvec[i], e, family)) {\r\nif (!strict)\r\nreturn 1;\r\n} else if (strict)\r\nreturn 0;\r\n}\r\nreturn strict ? 1 : 0;\r\n}\r\nstatic int\r\nmatch_policy_out(const struct sk_buff *skb, const struct xt_policy_info *info,\r\nunsigned short family)\r\n{\r\nconst struct xt_policy_elem *e;\r\nconst struct dst_entry *dst = skb_dst(skb);\r\nint strict = info->flags & XT_POLICY_MATCH_STRICT;\r\nint i, pos;\r\nif (dst->xfrm == NULL)\r\nreturn -1;\r\nfor (i = 0; dst && dst->xfrm; dst = dst->child, i++) {\r\npos = strict ? i : 0;\r\nif (pos >= info->len)\r\nreturn 0;\r\ne = &info->pol[pos];\r\nif (match_xfrm_state(dst->xfrm, e, family)) {\r\nif (!strict)\r\nreturn 1;\r\n} else if (strict)\r\nreturn 0;\r\n}\r\nreturn strict ? i == info->len : 0;\r\n}\r\nstatic bool\r\npolicy_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_policy_info *info = par->matchinfo;\r\nint ret;\r\nif (info->flags & XT_POLICY_MATCH_IN)\r\nret = match_policy_in(skb, info, xt_family(par));\r\nelse\r\nret = match_policy_out(skb, info, xt_family(par));\r\nif (ret < 0)\r\nret = info->flags & XT_POLICY_MATCH_NONE ? true : false;\r\nelse if (info->flags & XT_POLICY_MATCH_NONE)\r\nret = false;\r\nreturn ret;\r\n}\r\nstatic int policy_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_policy_info *info = par->matchinfo;\r\nif (!(info->flags & (XT_POLICY_MATCH_IN|XT_POLICY_MATCH_OUT))) {\r\npr_info("neither incoming nor outgoing policy selected\n");\r\nreturn -EINVAL;\r\n}\r\nif (par->hook_mask & ((1 << NF_INET_PRE_ROUTING) |\r\n(1 << NF_INET_LOCAL_IN)) && info->flags & XT_POLICY_MATCH_OUT) {\r\npr_info("output policy not valid in PREROUTING and INPUT\n");\r\nreturn -EINVAL;\r\n}\r\nif (par->hook_mask & ((1 << NF_INET_POST_ROUTING) |\r\n(1 << NF_INET_LOCAL_OUT)) && info->flags & XT_POLICY_MATCH_IN) {\r\npr_info("input policy not valid in POSTROUTING and OUTPUT\n");\r\nreturn -EINVAL;\r\n}\r\nif (info->len > XT_POLICY_MAX_ELEM) {\r\npr_info("too many policy elements\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init policy_mt_init(void)\r\n{\r\nreturn xt_register_matches(policy_mt_reg, ARRAY_SIZE(policy_mt_reg));\r\n}\r\nstatic void __exit policy_mt_exit(void)\r\n{\r\nxt_unregister_matches(policy_mt_reg, ARRAY_SIZE(policy_mt_reg));\r\n}
