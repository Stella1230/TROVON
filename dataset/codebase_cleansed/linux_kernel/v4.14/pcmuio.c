static inline unsigned long pcmuio_asic_iobase(struct comedi_device *dev,\r\nint asic)\r\n{\r\nreturn dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);\r\n}\r\nstatic inline int pcmuio_subdevice_to_asic(struct comedi_subdevice *s)\r\n{\r\nreturn s->index / 2;\r\n}\r\nstatic inline int pcmuio_subdevice_to_port(struct comedi_subdevice *s)\r\n{\r\nreturn (s->index % 2) ? 3 : 0;\r\n}\r\nstatic void pcmuio_write(struct comedi_device *dev, unsigned int val,\r\nint asic, int page, int port)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nunsigned long iobase = pcmuio_asic_iobase(dev, asic);\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->pagelock, flags);\r\nif (page == 0) {\r\noutb(val & 0xff, iobase + PCMUIO_PORT_REG(port + 0));\r\noutb((val >> 8) & 0xff, iobase + PCMUIO_PORT_REG(port + 1));\r\noutb((val >> 16) & 0xff, iobase + PCMUIO_PORT_REG(port + 2));\r\n} else {\r\noutb(PCMUIO_PAGE(page), iobase + PCMUIO_PAGE_LOCK_REG);\r\noutb(val & 0xff, iobase + PCMUIO_PAGE_REG(0));\r\noutb((val >> 8) & 0xff, iobase + PCMUIO_PAGE_REG(1));\r\noutb((val >> 16) & 0xff, iobase + PCMUIO_PAGE_REG(2));\r\n}\r\nspin_unlock_irqrestore(&chip->pagelock, flags);\r\n}\r\nstatic unsigned int pcmuio_read(struct comedi_device *dev,\r\nint asic, int page, int port)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nunsigned long iobase = pcmuio_asic_iobase(dev, asic);\r\nunsigned long flags;\r\nunsigned int val;\r\nspin_lock_irqsave(&chip->pagelock, flags);\r\nif (page == 0) {\r\nval = inb(iobase + PCMUIO_PORT_REG(port + 0));\r\nval |= (inb(iobase + PCMUIO_PORT_REG(port + 1)) << 8);\r\nval |= (inb(iobase + PCMUIO_PORT_REG(port + 2)) << 16);\r\n} else {\r\noutb(PCMUIO_PAGE(page), iobase + PCMUIO_PAGE_LOCK_REG);\r\nval = inb(iobase + PCMUIO_PAGE_REG(0));\r\nval |= (inb(iobase + PCMUIO_PAGE_REG(1)) << 8);\r\nval |= (inb(iobase + PCMUIO_PAGE_REG(2)) << 16);\r\n}\r\nspin_unlock_irqrestore(&chip->pagelock, flags);\r\nreturn val;\r\n}\r\nstatic int pcmuio_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nint port = pcmuio_subdevice_to_port(s);\r\nunsigned int chanmask = (1 << s->n_chan) - 1;\r\nunsigned int mask;\r\nunsigned int val;\r\nmask = comedi_dio_update_state(s, data);\r\nif (mask) {\r\nval = ~s->state & chanmask;\r\nval &= s->io_bits;\r\npcmuio_write(dev, val, asic, 0, port);\r\n}\r\nval = pcmuio_read(dev, asic, 0, port);\r\ndata[1] = ~val & chanmask;\r\nreturn insn->n;\r\n}\r\nstatic int pcmuio_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nint port = pcmuio_subdevice_to_port(s);\r\nint ret;\r\nret = comedi_dio_insn_config(dev, s, insn, data, 0);\r\nif (ret)\r\nreturn ret;\r\nif (data[0] == INSN_CONFIG_DIO_INPUT)\r\npcmuio_write(dev, s->io_bits, asic, 0, port);\r\nreturn insn->n;\r\n}\r\nstatic void pcmuio_reset(struct comedi_device *dev)\r\n{\r\nconst struct pcmuio_board *board = dev->board_ptr;\r\nint asic;\r\nfor (asic = 0; asic < board->num_asics; ++asic) {\r\npcmuio_write(dev, 0, asic, 0, 0);\r\npcmuio_write(dev, 0, asic, 0, 3);\r\npcmuio_write(dev, 0, asic, PCMUIO_PAGE_POL, 0);\r\npcmuio_write(dev, 0, asic, PCMUIO_PAGE_ENAB, 0);\r\npcmuio_write(dev, 0, asic, PCMUIO_PAGE_INT_ID, 0);\r\n}\r\n}\r\nstatic void pcmuio_stop_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nchip->enabled_mask = 0;\r\nchip->active = 0;\r\ns->async->inttrig = NULL;\r\npcmuio_write(dev, 0, asic, PCMUIO_PAGE_ENAB, 0);\r\n}\r\nstatic void pcmuio_handle_intr_subdev(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int triggered)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int val = 0;\r\nunsigned long flags;\r\nunsigned int i;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\nif (!chip->active)\r\ngoto done;\r\nif (!(triggered & chip->enabled_mask))\r\ngoto done;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nif (triggered & (1 << chan))\r\nval |= (1 << i);\r\n}\r\ncomedi_buf_write_samples(s, &val, 1);\r\nif (cmd->stop_src == TRIG_COUNT &&\r\ns->async->scans_done >= cmd->stop_arg)\r\ns->async->events |= COMEDI_CB_EOA;\r\ndone:\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\ncomedi_handle_events(dev, s);\r\n}\r\nstatic int pcmuio_handle_asic_interrupt(struct comedi_device *dev, int asic)\r\n{\r\nstruct comedi_subdevice *s = &dev->subdevices[asic * 2];\r\nunsigned long iobase = pcmuio_asic_iobase(dev, asic);\r\nunsigned int val;\r\nval = inb(iobase + PCMUIO_INT_PENDING_REG) & 0x07;\r\nif (!val)\r\nreturn 0;\r\nval = pcmuio_read(dev, asic, PCMUIO_PAGE_INT_ID, 0);\r\npcmuio_write(dev, 0, asic, PCMUIO_PAGE_INT_ID, 0);\r\npcmuio_handle_intr_subdev(dev, s, val);\r\nreturn 1;\r\n}\r\nstatic irqreturn_t pcmuio_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct pcmuio_private *devpriv = dev->private;\r\nint handled = 0;\r\nif (irq == dev->irq)\r\nhandled += pcmuio_handle_asic_interrupt(dev, 0);\r\nif (irq == devpriv->irq2)\r\nhandled += pcmuio_handle_asic_interrupt(dev, 1);\r\nreturn handled ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void pcmuio_start_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int bits = 0;\r\nunsigned int pol_bits = 0;\r\nint i;\r\nchip->enabled_mask = 0;\r\nchip->active = 1;\r\nif (cmd->chanlist) {\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int chanspec = cmd->chanlist[i];\r\nunsigned int chan = CR_CHAN(chanspec);\r\nunsigned int range = CR_RANGE(chanspec);\r\nunsigned int aref = CR_AREF(chanspec);\r\nbits |= (1 << chan);\r\npol_bits |= ((aref || range) ? 1 : 0) << chan;\r\n}\r\n}\r\nbits &= ((1 << s->n_chan) - 1);\r\nchip->enabled_mask = bits;\r\npcmuio_write(dev, pol_bits, asic, PCMUIO_PAGE_POL, 0);\r\npcmuio_write(dev, bits, asic, PCMUIO_PAGE_ENAB, 0);\r\n}\r\nstatic int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\nif (chip->active)\r\npcmuio_stop_intr(dev, s);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int pcmuio_inttrig_start_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nunsigned long flags;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\ns->async->inttrig = NULL;\r\nif (chip->active)\r\npcmuio_start_intr(dev, s);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nreturn 1;\r\n}\r\nstatic int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint asic = pcmuio_subdevice_to_asic(s);\r\nstruct pcmuio_asic *chip = &devpriv->asics[asic];\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\nchip->active = 1;\r\nif (cmd->start_src == TRIG_INT)\r\ns->async->inttrig = pcmuio_inttrig_start_intr;\r\nelse\r\npcmuio_start_intr(dev, s);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int pcmuio_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nstatic int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct pcmuio_board *board = dev->board_ptr;\r\nstruct comedi_subdevice *s;\r\nstruct pcmuio_private *devpriv;\r\nint ret;\r\nint i;\r\nret = comedi_request_region(dev, it->options[0],\r\nboard->num_asics * PCMUIO_ASIC_IOSIZE);\r\nif (ret)\r\nreturn ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < PCMUIO_MAX_ASICS; ++i) {\r\nstruct pcmuio_asic *chip = &devpriv->asics[i];\r\nspin_lock_init(&chip->pagelock);\r\nspin_lock_init(&chip->spinlock);\r\n}\r\npcmuio_reset(dev);\r\nif (it->options[1]) {\r\nret = request_irq(it->options[1], pcmuio_interrupt, 0,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = it->options[1];\r\n}\r\nif (board->num_asics == 2) {\r\nif (it->options[2] == dev->irq) {\r\ndevpriv->irq2 = it->options[2];\r\n} else if (it->options[2]) {\r\nret = request_irq(it->options[2], pcmuio_interrupt, 0,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndevpriv->irq2 = it->options[2];\r\n}\r\n}\r\nret = comedi_alloc_subdevices(dev, board->num_asics * 2);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < dev->n_subdevices; ++i) {\r\ns = &dev->subdevices[i];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 24;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pcmuio_dio_insn_bits;\r\ns->insn_config = pcmuio_dio_insn_config;\r\nif ((i == 0 && dev->irq) || (i == 2 && devpriv->irq2)) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ | SDF_LSAMPL |\r\nSDF_PACKED;\r\ns->len_chanlist = s->n_chan;\r\ns->cancel = pcmuio_cancel;\r\ns->do_cmd = pcmuio_cmd;\r\ns->do_cmdtest = pcmuio_cmdtest;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcmuio_detach(struct comedi_device *dev)\r\n{\r\nstruct pcmuio_private *devpriv = dev->private;\r\nif (devpriv) {\r\npcmuio_reset(dev);\r\nif (devpriv->irq2 && devpriv->irq2 != dev->irq)\r\nfree_irq(devpriv->irq2, dev);\r\n}\r\ncomedi_legacy_detach(dev);\r\n}
