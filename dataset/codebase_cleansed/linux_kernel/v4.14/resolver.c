static phandle live_tree_max_phandle(void)\r\n{\r\nstruct device_node *node;\r\nphandle phandle;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&devtree_lock, flags);\r\nphandle = 0;\r\nfor_each_of_allnodes(node) {\r\nif (node->phandle != OF_PHANDLE_ILLEGAL &&\r\nnode->phandle > phandle)\r\nphandle = node->phandle;\r\n}\r\nraw_spin_unlock_irqrestore(&devtree_lock, flags);\r\nreturn phandle;\r\n}\r\nstatic void adjust_overlay_phandles(struct device_node *overlay,\r\nint phandle_delta)\r\n{\r\nstruct device_node *child;\r\nstruct property *prop;\r\nphandle phandle;\r\nif (overlay->phandle != 0 && overlay->phandle != OF_PHANDLE_ILLEGAL)\r\noverlay->phandle += phandle_delta;\r\nfor_each_property_of_node(overlay, prop) {\r\nif (of_prop_cmp(prop->name, "phandle") &&\r\nof_prop_cmp(prop->name, "linux,phandle"))\r\ncontinue;\r\nif (prop->length < 4)\r\ncontinue;\r\nphandle = be32_to_cpup(prop->value);\r\nif (phandle == OF_PHANDLE_ILLEGAL)\r\ncontinue;\r\n*(__be32 *)prop->value = cpu_to_be32(overlay->phandle);\r\n}\r\nfor_each_child_of_node(overlay, child)\r\nadjust_overlay_phandles(child, phandle_delta);\r\n}\r\nstatic int update_usages_of_a_phandle_reference(struct device_node *overlay,\r\nstruct property *prop_fixup, phandle phandle)\r\n{\r\nstruct device_node *refnode;\r\nstruct property *prop;\r\nchar *value, *cur, *end, *node_path, *prop_name, *s;\r\nint offset, len;\r\nint err = 0;\r\nvalue = kmalloc(prop_fixup->length, GFP_KERNEL);\r\nif (!value)\r\nreturn -ENOMEM;\r\nmemcpy(value, prop_fixup->value, prop_fixup->length);\r\nend = value + prop_fixup->length;\r\nfor (cur = value; cur < end; cur += len + 1) {\r\nlen = strlen(cur);\r\nnode_path = cur;\r\ns = strchr(cur, ':');\r\nif (!s) {\r\nerr = -EINVAL;\r\ngoto err_fail;\r\n}\r\n*s++ = '\0';\r\nprop_name = s;\r\ns = strchr(s, ':');\r\nif (!s) {\r\nerr = -EINVAL;\r\ngoto err_fail;\r\n}\r\n*s++ = '\0';\r\nerr = kstrtoint(s, 10, &offset);\r\nif (err)\r\ngoto err_fail;\r\nrefnode = __of_find_node_by_full_path(of_node_get(overlay), node_path);\r\nif (!refnode)\r\ncontinue;\r\nfor_each_property_of_node(refnode, prop) {\r\nif (!of_prop_cmp(prop->name, prop_name))\r\nbreak;\r\n}\r\nof_node_put(refnode);\r\nif (!prop) {\r\nerr = -ENOENT;\r\ngoto err_fail;\r\n}\r\n*(__be32 *)(prop->value + offset) = cpu_to_be32(phandle);\r\n}\r\nerr_fail:\r\nkfree(value);\r\nreturn err;\r\n}\r\nstatic int node_name_cmp(const struct device_node *dn1,\r\nconst struct device_node *dn2)\r\n{\r\nconst char *n1 = kbasename(dn1->full_name);\r\nconst char *n2 = kbasename(dn2->full_name);\r\nreturn of_node_cmp(n1, n2);\r\n}\r\nstatic int adjust_local_phandle_references(struct device_node *local_fixups,\r\nstruct device_node *overlay, int phandle_delta)\r\n{\r\nstruct device_node *child, *overlay_child;\r\nstruct property *prop_fix, *prop;\r\nint err, i, count;\r\nunsigned int off;\r\nphandle phandle;\r\nif (!local_fixups)\r\nreturn 0;\r\nfor_each_property_of_node(local_fixups, prop_fix) {\r\nif (!of_prop_cmp(prop_fix->name, "name") ||\r\n!of_prop_cmp(prop_fix->name, "phandle") ||\r\n!of_prop_cmp(prop_fix->name, "linux,phandle"))\r\ncontinue;\r\nif ((prop_fix->length % 4) != 0 || prop_fix->length == 0)\r\nreturn -EINVAL;\r\ncount = prop_fix->length / sizeof(__be32);\r\nfor_each_property_of_node(overlay, prop) {\r\nif (!of_prop_cmp(prop->name, prop_fix->name))\r\nbreak;\r\n}\r\nif (!prop)\r\nreturn -EINVAL;\r\nfor (i = 0; i < count; i++) {\r\noff = be32_to_cpu(((__be32 *)prop_fix->value)[i]);\r\nif ((off + 4) > prop->length)\r\nreturn -EINVAL;\r\nphandle = be32_to_cpu(*(__be32 *)(prop->value + off));\r\nphandle += phandle_delta;\r\n*(__be32 *)(prop->value + off) = cpu_to_be32(phandle);\r\n}\r\n}\r\nfor_each_child_of_node(local_fixups, child) {\r\nfor_each_child_of_node(overlay, overlay_child)\r\nif (!node_name_cmp(child, overlay_child))\r\nbreak;\r\nif (!overlay_child)\r\nreturn -EINVAL;\r\nerr = adjust_local_phandle_references(child, overlay_child,\r\nphandle_delta);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint of_resolve_phandles(struct device_node *overlay)\r\n{\r\nstruct device_node *child, *local_fixups, *refnode;\r\nstruct device_node *tree_symbols, *overlay_fixups;\r\nstruct property *prop;\r\nconst char *refpath;\r\nphandle phandle, phandle_delta;\r\nint err;\r\ntree_symbols = NULL;\r\nif (!overlay) {\r\npr_err("null overlay\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (!of_node_check_flag(overlay, OF_DETACHED)) {\r\npr_err("overlay not detached\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nphandle_delta = live_tree_max_phandle() + 1;\r\nadjust_overlay_phandles(overlay, phandle_delta);\r\nfor_each_child_of_node(overlay, local_fixups)\r\nif (!of_node_cmp(local_fixups->name, "__local_fixups__"))\r\nbreak;\r\nerr = adjust_local_phandle_references(local_fixups, overlay, phandle_delta);\r\nif (err)\r\ngoto out;\r\noverlay_fixups = NULL;\r\nfor_each_child_of_node(overlay, child) {\r\nif (!of_node_cmp(child->name, "__fixups__"))\r\noverlay_fixups = child;\r\n}\r\nif (!overlay_fixups) {\r\nerr = 0;\r\ngoto out;\r\n}\r\ntree_symbols = of_find_node_by_path("/__symbols__");\r\nif (!tree_symbols) {\r\npr_err("no symbols in root of device tree.\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nfor_each_property_of_node(overlay_fixups, prop) {\r\nif (!of_prop_cmp(prop->name, "name"))\r\ncontinue;\r\nerr = of_property_read_string(tree_symbols,\r\nprop->name, &refpath);\r\nif (err)\r\ngoto out;\r\nrefnode = of_find_node_by_path(refpath);\r\nif (!refnode) {\r\nerr = -ENOENT;\r\ngoto out;\r\n}\r\nphandle = refnode->phandle;\r\nof_node_put(refnode);\r\nerr = update_usages_of_a_phandle_reference(overlay, prop, phandle);\r\nif (err)\r\nbreak;\r\n}\r\nout:\r\nif (err)\r\npr_err("overlay phandle fixup failed: %d\n", err);\r\nof_node_put(tree_symbols);\r\nreturn err;\r\n}
