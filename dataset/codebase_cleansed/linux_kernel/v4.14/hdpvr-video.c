static uint list_size(struct list_head *list)\r\n{\r\nstruct list_head *tmp;\r\nuint count = 0;\r\nlist_for_each(tmp, list) {\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic void hdpvr_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct hdpvr_buffer *buf = (struct hdpvr_buffer *)urb->context;\r\nstruct hdpvr_device *dev = buf->dev;\r\nbuf->status = BUFSTAT_READY;\r\nwake_up_interruptible(&dev->wait_data);\r\n}\r\nint hdpvr_cancel_queue(struct hdpvr_device *dev)\r\n{\r\nstruct hdpvr_buffer *buf;\r\nlist_for_each_entry(buf, &dev->rec_buff_list, buff_list) {\r\nusb_kill_urb(buf->urb);\r\nbuf->status = BUFSTAT_AVAILABLE;\r\n}\r\nlist_splice_init(&dev->rec_buff_list, dev->free_buff_list.prev);\r\nreturn 0;\r\n}\r\nstatic int hdpvr_free_queue(struct list_head *q)\r\n{\r\nstruct list_head *tmp;\r\nstruct list_head *p;\r\nstruct hdpvr_buffer *buf;\r\nstruct urb *urb;\r\nfor (p = q->next; p != q;) {\r\nbuf = list_entry(p, struct hdpvr_buffer, buff_list);\r\nurb = buf->urb;\r\nusb_free_coherent(urb->dev, urb->transfer_buffer_length,\r\nurb->transfer_buffer, urb->transfer_dma);\r\nusb_free_urb(urb);\r\ntmp = p->next;\r\nlist_del(p);\r\nkfree(buf);\r\np = tmp;\r\n}\r\nreturn 0;\r\n}\r\nint hdpvr_free_buffers(struct hdpvr_device *dev)\r\n{\r\nhdpvr_cancel_queue(dev);\r\nhdpvr_free_queue(&dev->free_buff_list);\r\nhdpvr_free_queue(&dev->rec_buff_list);\r\nreturn 0;\r\n}\r\nint hdpvr_alloc_buffers(struct hdpvr_device *dev, uint count)\r\n{\r\nuint i;\r\nint retval = -ENOMEM;\r\nu8 *mem;\r\nstruct hdpvr_buffer *buf;\r\nstruct urb *urb;\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"allocating %u buffers\n", count);\r\nfor (i = 0; i < count; i++) {\r\nbuf = kzalloc(sizeof(struct hdpvr_buffer), GFP_KERNEL);\r\nif (!buf) {\r\nv4l2_err(&dev->v4l2_dev, "cannot allocate buffer\n");\r\ngoto exit;\r\n}\r\nbuf->dev = dev;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\ngoto exit_urb;\r\nbuf->urb = urb;\r\nmem = usb_alloc_coherent(dev->udev, dev->bulk_in_size, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!mem) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"cannot allocate usb transfer buffer\n");\r\ngoto exit_urb_buffer;\r\n}\r\nusb_fill_bulk_urb(buf->urb, dev->udev,\r\nusb_rcvbulkpipe(dev->udev,\r\ndev->bulk_in_endpointAddr),\r\nmem, dev->bulk_in_size,\r\nhdpvr_read_bulk_callback, buf);\r\nbuf->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nbuf->status = BUFSTAT_AVAILABLE;\r\nlist_add_tail(&buf->buff_list, &dev->free_buff_list);\r\n}\r\nreturn 0;\r\nexit_urb_buffer:\r\nusb_free_urb(urb);\r\nexit_urb:\r\nkfree(buf);\r\nexit:\r\nhdpvr_free_buffers(dev);\r\nreturn retval;\r\n}\r\nstatic int hdpvr_submit_buffers(struct hdpvr_device *dev)\r\n{\r\nstruct hdpvr_buffer *buf;\r\nstruct urb *urb;\r\nint ret = 0, err_count = 0;\r\nmutex_lock(&dev->io_mutex);\r\nwhile (dev->status == STATUS_STREAMING &&\r\n!list_empty(&dev->free_buff_list)) {\r\nbuf = list_entry(dev->free_buff_list.next, struct hdpvr_buffer,\r\nbuff_list);\r\nif (buf->status != BUFSTAT_AVAILABLE) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"buffer not marked as available\n");\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nurb = buf->urb;\r\nurb->status = 0;\r\nurb->actual_length = 0;\r\nret = usb_submit_urb(urb, GFP_KERNEL);\r\nif (ret) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"usb_submit_urb in %s returned %d\n",\r\n__func__, ret);\r\nif (++err_count > 2)\r\nbreak;\r\ncontinue;\r\n}\r\nbuf->status = BUFSTAT_INPROGRESS;\r\nlist_move_tail(&buf->buff_list, &dev->rec_buff_list);\r\n}\r\nerr:\r\nprint_buffer_status();\r\nmutex_unlock(&dev->io_mutex);\r\nreturn ret;\r\n}\r\nstatic struct hdpvr_buffer *hdpvr_get_next_buffer(struct hdpvr_device *dev)\r\n{\r\nstruct hdpvr_buffer *buf;\r\nmutex_lock(&dev->io_mutex);\r\nif (list_empty(&dev->rec_buff_list)) {\r\nmutex_unlock(&dev->io_mutex);\r\nreturn NULL;\r\n}\r\nbuf = list_entry(dev->rec_buff_list.next, struct hdpvr_buffer,\r\nbuff_list);\r\nmutex_unlock(&dev->io_mutex);\r\nreturn buf;\r\n}\r\nstatic void hdpvr_transmit_buffers(struct work_struct *work)\r\n{\r\nstruct hdpvr_device *dev = container_of(work, struct hdpvr_device,\r\nworker);\r\nwhile (dev->status == STATUS_STREAMING) {\r\nif (hdpvr_submit_buffers(dev)) {\r\nv4l2_err(&dev->v4l2_dev, "couldn't submit buffers\n");\r\ngoto error;\r\n}\r\nif (wait_event_interruptible(dev->wait_buffer,\r\n!list_empty(&dev->free_buff_list) ||\r\ndev->status != STATUS_STREAMING))\r\ngoto error;\r\n}\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"transmit worker exited\n");\r\nreturn;\r\nerror:\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"transmit buffers errored\n");\r\ndev->status = STATUS_ERROR;\r\n}\r\nstatic int hdpvr_start_streaming(struct hdpvr_device *dev)\r\n{\r\nint ret;\r\nstruct hdpvr_video_info vidinf;\r\nif (dev->status == STATUS_STREAMING)\r\nreturn 0;\r\nif (dev->status != STATUS_IDLE)\r\nreturn -EAGAIN;\r\nret = get_video_info(dev, &vidinf);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!vidinf.valid) {\r\nmsleep(250);\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"no video signal at input %d\n", dev->options.video_input);\r\nreturn -EAGAIN;\r\n}\r\nv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\r\n"video signal: %dx%d@%dhz\n", vidinf.width,\r\nvidinf.height, vidinf.fps);\r\nret = usb_control_msg(dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\n0xb8, 0x38, 0x1, 0, NULL, 0, 8000);\r\nv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\r\n"encoder start control request returned %d\n", ret);\r\nif (ret < 0)\r\nreturn ret;\r\nret = hdpvr_config_call(dev, CTRL_START_STREAMING_VALUE, 0x00);\r\nif (ret)\r\nreturn ret;\r\ndev->status = STATUS_STREAMING;\r\nINIT_WORK(&dev->worker, hdpvr_transmit_buffers);\r\nschedule_work(&dev->worker);\r\nv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\r\n"streaming started\n");\r\nreturn 0;\r\n}\r\nstatic int hdpvr_stop_streaming(struct hdpvr_device *dev)\r\n{\r\nint actual_length;\r\nuint c = 0;\r\nu8 *buf;\r\nif (dev->status == STATUS_IDLE)\r\nreturn 0;\r\nelse if (dev->status != STATUS_STREAMING)\r\nreturn -EAGAIN;\r\nbuf = kmalloc(dev->bulk_in_size, GFP_KERNEL);\r\nif (!buf)\r\nv4l2_err(&dev->v4l2_dev, "failed to allocate temporary buffer for emptying the internal device buffer. Next capture start will be slow\n");\r\ndev->status = STATUS_SHUTTING_DOWN;\r\nhdpvr_config_call(dev, CTRL_STOP_STREAMING_VALUE, 0x00);\r\nmutex_unlock(&dev->io_mutex);\r\nwake_up_interruptible(&dev->wait_buffer);\r\nmsleep(50);\r\nflush_work(&dev->worker);\r\nmutex_lock(&dev->io_mutex);\r\nhdpvr_cancel_queue(dev);\r\nwhile (buf && ++c < 500 &&\r\n!usb_bulk_msg(dev->udev,\r\nusb_rcvbulkpipe(dev->udev,\r\ndev->bulk_in_endpointAddr),\r\nbuf, dev->bulk_in_size, &actual_length,\r\nBULK_URB_TIMEOUT)) {\r\nv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\r\n"%2d: got %d bytes\n", c, actual_length);\r\n}\r\nkfree(buf);\r\nv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\r\n"used %d urbs to empty device buffers\n", c-1);\r\nmsleep(10);\r\ndev->status = STATUS_IDLE;\r\nreturn 0;\r\n}\r\nstatic int hdpvr_open(struct file *file)\r\n{\r\nstruct hdpvr_fh *fh = kzalloc(sizeof(*fh), GFP_KERNEL);\r\nif (fh == NULL)\r\nreturn -ENOMEM;\r\nfh->legacy_mode = true;\r\nv4l2_fh_init(&fh->fh, video_devdata(file));\r\nv4l2_fh_add(&fh->fh);\r\nfile->private_data = fh;\r\nreturn 0;\r\n}\r\nstatic int hdpvr_release(struct file *file)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\nmutex_lock(&dev->io_mutex);\r\nif (file->private_data == dev->owner) {\r\nhdpvr_stop_streaming(dev);\r\ndev->owner = NULL;\r\n}\r\nmutex_unlock(&dev->io_mutex);\r\nreturn v4l2_fh_release(file);\r\n}\r\nstatic ssize_t hdpvr_read(struct file *file, char __user *buffer, size_t count,\r\nloff_t *pos)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\nstruct hdpvr_buffer *buf = NULL;\r\nstruct urb *urb;\r\nunsigned int ret = 0;\r\nint rem, cnt;\r\nif (*pos)\r\nreturn -ESPIPE;\r\nmutex_lock(&dev->io_mutex);\r\nif (dev->status == STATUS_IDLE) {\r\nif (hdpvr_start_streaming(dev)) {\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"start_streaming failed\n");\r\nret = -EIO;\r\nmsleep(200);\r\ndev->status = STATUS_IDLE;\r\nmutex_unlock(&dev->io_mutex);\r\ngoto err;\r\n}\r\ndev->owner = file->private_data;\r\nprint_buffer_status();\r\n}\r\nmutex_unlock(&dev->io_mutex);\r\nif (!(file->f_flags & O_NONBLOCK)) {\r\nif (wait_event_interruptible(dev->wait_data,\r\nhdpvr_get_next_buffer(dev)))\r\nreturn -ERESTARTSYS;\r\n}\r\nbuf = hdpvr_get_next_buffer(dev);\r\nwhile (count > 0 && buf) {\r\nif (buf->status != BUFSTAT_READY &&\r\ndev->status != STATUS_DISCONNECTED) {\r\nint err;\r\nif (file->f_flags & O_NONBLOCK) {\r\nif (!ret)\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nerr = wait_event_interruptible_timeout(dev->wait_data,\r\nbuf->status == BUFSTAT_READY,\r\nmsecs_to_jiffies(1000));\r\nif (err < 0) {\r\nret = err;\r\ngoto err;\r\n}\r\nif (!err) {\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"timeout: restart streaming\n");\r\nhdpvr_stop_streaming(dev);\r\nmsecs_to_jiffies(4000);\r\nerr = hdpvr_start_streaming(dev);\r\nif (err) {\r\nret = err;\r\ngoto err;\r\n}\r\n}\r\n}\r\nif (buf->status != BUFSTAT_READY)\r\nbreak;\r\nurb = buf->urb;\r\nrem = urb->actual_length - buf->pos;\r\ncnt = rem > count ? count : rem;\r\nif (copy_to_user(buffer, urb->transfer_buffer + buf->pos,\r\ncnt)) {\r\nv4l2_err(&dev->v4l2_dev, "read: copy_to_user failed\n");\r\nif (!ret)\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nbuf->pos += cnt;\r\ncount -= cnt;\r\nbuffer += cnt;\r\nret += cnt;\r\nif (buf->pos == urb->actual_length) {\r\nmutex_lock(&dev->io_mutex);\r\nbuf->pos = 0;\r\nbuf->status = BUFSTAT_AVAILABLE;\r\nlist_move_tail(&buf->buff_list, &dev->free_buff_list);\r\nprint_buffer_status();\r\nmutex_unlock(&dev->io_mutex);\r\nwake_up_interruptible(&dev->wait_buffer);\r\nbuf = hdpvr_get_next_buffer(dev);\r\n}\r\n}\r\nerr:\r\nif (!ret && !buf)\r\nret = -EAGAIN;\r\nreturn ret;\r\n}\r\nstatic unsigned int hdpvr_poll(struct file *filp, poll_table *wait)\r\n{\r\nunsigned long req_events = poll_requested_events(wait);\r\nstruct hdpvr_buffer *buf = NULL;\r\nstruct hdpvr_device *dev = video_drvdata(filp);\r\nunsigned int mask = v4l2_ctrl_poll(filp, wait);\r\nif (!(req_events & (POLLIN | POLLRDNORM)))\r\nreturn mask;\r\nmutex_lock(&dev->io_mutex);\r\nif (dev->status == STATUS_IDLE) {\r\nif (hdpvr_start_streaming(dev)) {\r\nv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\r\n"start_streaming failed\n");\r\ndev->status = STATUS_IDLE;\r\n} else {\r\ndev->owner = filp->private_data;\r\n}\r\nprint_buffer_status();\r\n}\r\nmutex_unlock(&dev->io_mutex);\r\nbuf = hdpvr_get_next_buffer(dev);\r\nif (!buf || buf->status != BUFSTAT_READY) {\r\npoll_wait(filp, &dev->wait_data, wait);\r\nbuf = hdpvr_get_next_buffer(dev);\r\n}\r\nif (buf && buf->status == BUFSTAT_READY)\r\nmask |= POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\nstrcpy(cap->driver, "hdpvr");\r\nstrcpy(cap->card, "Hauppauge HD PVR");\r\nusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_AUDIO |\r\nV4L2_CAP_READWRITE;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *_fh,\r\nv4l2_std_id std)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\nstruct hdpvr_fh *fh = _fh;\r\nu8 std_type = 1;\r\nif (!fh->legacy_mode && dev->options.video_input == HDPVR_COMPONENT)\r\nreturn -ENODATA;\r\nif (dev->status != STATUS_IDLE)\r\nreturn -EBUSY;\r\nif (std & V4L2_STD_525_60)\r\nstd_type = 0;\r\ndev->cur_std = std;\r\ndev->width = 720;\r\ndev->height = std_type ? 576 : 480;\r\nreturn hdpvr_config_call(dev, CTRL_VIDEO_STD_TYPE, std_type);\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *_fh,\r\nv4l2_std_id *std)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\nstruct hdpvr_fh *fh = _fh;\r\nif (!fh->legacy_mode && dev->options.video_input == HDPVR_COMPONENT)\r\nreturn -ENODATA;\r\n*std = dev->cur_std;\r\nreturn 0;\r\n}\r\nstatic int vidioc_querystd(struct file *file, void *_fh, v4l2_std_id *a)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\nstruct hdpvr_video_info vid_info;\r\nstruct hdpvr_fh *fh = _fh;\r\nint ret;\r\n*a = V4L2_STD_UNKNOWN;\r\nif (dev->options.video_input == HDPVR_COMPONENT)\r\nreturn fh->legacy_mode ? 0 : -ENODATA;\r\nret = get_video_info(dev, &vid_info);\r\nif (vid_info.valid && vid_info.width == 720 &&\r\n(vid_info.height == 480 || vid_info.height == 576)) {\r\n*a = (vid_info.height == 480) ?\r\nV4L2_STD_525_60 : V4L2_STD_625_50;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_s_dv_timings(struct file *file, void *_fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\nstruct hdpvr_fh *fh = _fh;\r\nint i;\r\nfh->legacy_mode = false;\r\nif (dev->options.video_input)\r\nreturn -ENODATA;\r\nif (dev->status != STATUS_IDLE)\r\nreturn -EBUSY;\r\nfor (i = 0; i < ARRAY_SIZE(hdpvr_dv_timings); i++)\r\nif (v4l2_match_dv_timings(timings, hdpvr_dv_timings + i, 0, false))\r\nbreak;\r\nif (i == ARRAY_SIZE(hdpvr_dv_timings))\r\nreturn -EINVAL;\r\ndev->cur_dv_timings = hdpvr_dv_timings[i];\r\ndev->width = hdpvr_dv_timings[i].bt.width;\r\ndev->height = hdpvr_dv_timings[i].bt.height;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_dv_timings(struct file *file, void *_fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\nstruct hdpvr_fh *fh = _fh;\r\nfh->legacy_mode = false;\r\nif (dev->options.video_input)\r\nreturn -ENODATA;\r\n*timings = dev->cur_dv_timings;\r\nreturn 0;\r\n}\r\nstatic int vidioc_query_dv_timings(struct file *file, void *_fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\nstruct hdpvr_fh *fh = _fh;\r\nstruct hdpvr_video_info vid_info;\r\nbool interlaced;\r\nint ret = 0;\r\nint i;\r\nfh->legacy_mode = false;\r\nif (dev->options.video_input)\r\nreturn -ENODATA;\r\nret = get_video_info(dev, &vid_info);\r\nif (ret)\r\nreturn ret;\r\nif (!vid_info.valid)\r\nreturn -ENOLCK;\r\ninterlaced = vid_info.fps <= 30;\r\nfor (i = 0; i < ARRAY_SIZE(hdpvr_dv_timings); i++) {\r\nconst struct v4l2_bt_timings *bt = &hdpvr_dv_timings[i].bt;\r\nunsigned hsize;\r\nunsigned vsize;\r\nunsigned fps;\r\nhsize = V4L2_DV_BT_FRAME_WIDTH(bt);\r\nvsize = V4L2_DV_BT_FRAME_HEIGHT(bt);\r\nfps = (unsigned)bt->pixelclock / (hsize * vsize);\r\nif (bt->width != vid_info.width ||\r\nbt->height != vid_info.height ||\r\nbt->interlaced != interlaced ||\r\n(fps != vid_info.fps && fps + 1 != vid_info.fps))\r\ncontinue;\r\n*timings = hdpvr_dv_timings[i];\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(hdpvr_dv_timings))\r\nret = -ERANGE;\r\nreturn ret;\r\n}\r\nstatic int vidioc_enum_dv_timings(struct file *file, void *_fh,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\nstruct hdpvr_fh *fh = _fh;\r\nfh->legacy_mode = false;\r\nmemset(timings->reserved, 0, sizeof(timings->reserved));\r\nif (dev->options.video_input)\r\nreturn -ENODATA;\r\nif (timings->index >= ARRAY_SIZE(hdpvr_dv_timings))\r\nreturn -EINVAL;\r\ntimings->timings = hdpvr_dv_timings[timings->index];\r\nreturn 0;\r\n}\r\nstatic int vidioc_dv_timings_cap(struct file *file, void *_fh,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\nstruct hdpvr_fh *fh = _fh;\r\nfh->legacy_mode = false;\r\nif (dev->options.video_input)\r\nreturn -ENODATA;\r\ncap->type = V4L2_DV_BT_656_1120;\r\ncap->bt.min_width = 720;\r\ncap->bt.max_width = 1920;\r\ncap->bt.min_height = 480;\r\ncap->bt.max_height = 1080;\r\ncap->bt.min_pixelclock = 27000000;\r\ncap->bt.max_pixelclock = 74250000;\r\ncap->bt.standards = V4L2_DV_BT_STD_CEA861;\r\ncap->bt.capabilities = V4L2_DV_BT_CAP_INTERLACED | V4L2_DV_BT_CAP_PROGRESSIVE;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *_fh, struct v4l2_input *i)\r\n{\r\nunsigned int n;\r\nn = i->index;\r\nif (n >= HDPVR_VIDEO_INPUTS)\r\nreturn -EINVAL;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrncpy(i->name, iname[n], sizeof(i->name) - 1);\r\ni->name[sizeof(i->name) - 1] = '\0';\r\ni->audioset = 1<<HDPVR_RCA_FRONT | 1<<HDPVR_RCA_BACK | 1<<HDPVR_SPDIF;\r\ni->capabilities = n ? V4L2_IN_CAP_STD : V4L2_IN_CAP_DV_TIMINGS;\r\ni->std = n ? V4L2_STD_ALL : 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *_fh,\r\nunsigned int index)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\nint retval;\r\nif (index >= HDPVR_VIDEO_INPUTS)\r\nreturn -EINVAL;\r\nif (dev->status != STATUS_IDLE)\r\nreturn -EBUSY;\r\nretval = hdpvr_config_call(dev, CTRL_VIDEO_INPUT_VALUE, index+1);\r\nif (!retval) {\r\ndev->options.video_input = index;\r\n}\r\nreturn retval;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *private_data,\r\nunsigned int *index)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\n*index = dev->options.video_input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enumaudio(struct file *file, void *priv,\r\nstruct v4l2_audio *audio)\r\n{\r\nunsigned int n;\r\nn = audio->index;\r\nif (n >= HDPVR_AUDIO_INPUTS)\r\nreturn -EINVAL;\r\naudio->capability = V4L2_AUDCAP_STEREO;\r\nstrncpy(audio->name, audio_iname[n], sizeof(audio->name) - 1);\r\naudio->name[sizeof(audio->name) - 1] = '\0';\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *private_data,\r\nconst struct v4l2_audio *audio)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\nint retval;\r\nif (audio->index >= HDPVR_AUDIO_INPUTS)\r\nreturn -EINVAL;\r\nif (dev->status != STATUS_IDLE)\r\nreturn -EBUSY;\r\nretval = hdpvr_set_audio(dev, audio->index+1, dev->options.audio_codec);\r\nif (!retval)\r\ndev->options.audio_input = audio->index;\r\nreturn retval;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *private_data,\r\nstruct v4l2_audio *audio)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\naudio->index = dev->options.audio_input;\r\naudio->capability = V4L2_AUDCAP_STEREO;\r\nstrncpy(audio->name, audio_iname[audio->index], sizeof(audio->name));\r\naudio->name[sizeof(audio->name) - 1] = '\0';\r\nreturn 0;\r\n}\r\nstatic int hdpvr_try_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct hdpvr_device *dev =\r\ncontainer_of(ctrl->handler, struct hdpvr_device, hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\nif (ctrl->val == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR &&\r\ndev->video_bitrate->val >= dev->video_bitrate_peak->val)\r\ndev->video_bitrate_peak->val =\r\ndev->video_bitrate->val + 100000;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdpvr_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct hdpvr_device *dev =\r\ncontainer_of(ctrl->handler, struct hdpvr_device, hdl);\r\nstruct hdpvr_options *opt = &dev->options;\r\nint ret = -EINVAL;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nret = hdpvr_config_call(dev, CTRL_BRIGHTNESS, ctrl->val);\r\nif (ret)\r\nbreak;\r\ndev->options.brightness = ctrl->val;\r\nreturn 0;\r\ncase V4L2_CID_CONTRAST:\r\nret = hdpvr_config_call(dev, CTRL_CONTRAST, ctrl->val);\r\nif (ret)\r\nbreak;\r\ndev->options.contrast = ctrl->val;\r\nreturn 0;\r\ncase V4L2_CID_SATURATION:\r\nret = hdpvr_config_call(dev, CTRL_SATURATION, ctrl->val);\r\nif (ret)\r\nbreak;\r\ndev->options.saturation = ctrl->val;\r\nreturn 0;\r\ncase V4L2_CID_HUE:\r\nret = hdpvr_config_call(dev, CTRL_HUE, ctrl->val);\r\nif (ret)\r\nbreak;\r\ndev->options.hue = ctrl->val;\r\nreturn 0;\r\ncase V4L2_CID_SHARPNESS:\r\nret = hdpvr_config_call(dev, CTRL_SHARPNESS, ctrl->val);\r\nif (ret)\r\nbreak;\r\ndev->options.sharpness = ctrl->val;\r\nreturn 0;\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\nif (dev->flags & HDPVR_FLAG_AC3_CAP) {\r\nopt->audio_codec = ctrl->val;\r\nreturn hdpvr_set_audio(dev, opt->audio_input + 1,\r\nopt->audio_codec);\r\n}\r\nreturn 0;\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nreturn 0;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE: {\r\nuint peak_bitrate = dev->video_bitrate_peak->val / 100000;\r\nuint bitrate = dev->video_bitrate->val / 100000;\r\nif (ctrl->is_new) {\r\nif (ctrl->val == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR)\r\nopt->bitrate_mode = HDPVR_CONSTANT;\r\nelse\r\nopt->bitrate_mode = HDPVR_VARIABLE_AVERAGE;\r\nhdpvr_config_call(dev, CTRL_BITRATE_MODE_VALUE,\r\nopt->bitrate_mode);\r\nv4l2_ctrl_activate(dev->video_bitrate_peak,\r\nctrl->val != V4L2_MPEG_VIDEO_BITRATE_MODE_CBR);\r\n}\r\nif (dev->video_bitrate_peak->is_new ||\r\ndev->video_bitrate->is_new) {\r\nopt->bitrate = bitrate;\r\nopt->peak_bitrate = peak_bitrate;\r\nhdpvr_set_bitrate(dev);\r\n}\r\nreturn 0;\r\n}\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *private_data,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index != 0)\r\nreturn -EINVAL;\r\nf->flags = V4L2_FMT_FLAG_COMPRESSED;\r\nstrncpy(f->description, "MPEG2-TS with AVC/AAC streams", 32);\r\nf->pixelformat = V4L2_PIX_FMT_MPEG;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *_fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\nstruct hdpvr_fh *fh = _fh;\r\nint ret;\r\nif (fh->legacy_mode) {\r\nstruct hdpvr_video_info vid_info;\r\nret = get_video_info(dev, &vid_info);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!vid_info.valid)\r\nreturn -EFAULT;\r\nf->fmt.pix.width = vid_info.width;\r\nf->fmt.pix.height = vid_info.height;\r\n} else {\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\n}\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.sizeimage = dev->bulk_in_size;\r\nf->fmt.pix.bytesperline = 0;\r\nif (f->fmt.pix.width == 720) {\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\n} else {\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_encoder_cmd(struct file *filp, void *priv,\r\nstruct v4l2_encoder_cmd *a)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(filp);\r\nint res = 0;\r\nmutex_lock(&dev->io_mutex);\r\na->flags = 0;\r\nswitch (a->cmd) {\r\ncase V4L2_ENC_CMD_START:\r\nif (dev->owner && filp->private_data != dev->owner) {\r\nres = -EBUSY;\r\nbreak;\r\n}\r\nif (dev->status == STATUS_STREAMING)\r\nbreak;\r\nres = hdpvr_start_streaming(dev);\r\nif (!res)\r\ndev->owner = filp->private_data;\r\nelse\r\ndev->status = STATUS_IDLE;\r\nbreak;\r\ncase V4L2_ENC_CMD_STOP:\r\nif (dev->owner && filp->private_data != dev->owner) {\r\nres = -EBUSY;\r\nbreak;\r\n}\r\nif (dev->status == STATUS_IDLE)\r\nbreak;\r\nres = hdpvr_stop_streaming(dev);\r\nif (!res)\r\ndev->owner = NULL;\r\nbreak;\r\ndefault:\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"Unsupported encoder cmd %d\n", a->cmd);\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&dev->io_mutex);\r\nreturn res;\r\n}\r\nstatic int vidioc_try_encoder_cmd(struct file *filp, void *priv,\r\nstruct v4l2_encoder_cmd *a)\r\n{\r\na->flags = 0;\r\nswitch (a->cmd) {\r\ncase V4L2_ENC_CMD_START:\r\ncase V4L2_ENC_CMD_STOP:\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void hdpvr_device_release(struct video_device *vdev)\r\n{\r\nstruct hdpvr_device *dev = video_get_drvdata(vdev);\r\nhdpvr_delete(dev);\r\nmutex_lock(&dev->io_mutex);\r\nflush_work(&dev->worker);\r\nmutex_unlock(&dev->io_mutex);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nv4l2_ctrl_handler_free(&dev->hdl);\r\n#if IS_ENABLED(CONFIG_I2C)\r\nmutex_lock(&dev->i2c_mutex);\r\ni2c_del_adapter(&dev->i2c_adapter);\r\nmutex_unlock(&dev->i2c_mutex);\r\n#endif\r\nkfree(dev->usbc_buf);\r\nkfree(dev);\r\n}\r\nint hdpvr_register_videodev(struct hdpvr_device *dev, struct device *parent,\r\nint devnum)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &dev->hdl;\r\nbool ac3 = dev->flags & HDPVR_FLAG_AC3_CAP;\r\nint res;\r\ndev->cur_std = V4L2_STD_525_60;\r\ndev->width = 720;\r\ndev->height = 480;\r\ndev->cur_dv_timings = hdpvr_dv_timings[HDPVR_DEF_DV_TIMINGS_IDX];\r\nv4l2_ctrl_handler_init(hdl, 11);\r\nif (dev->fw_ver > 0x15) {\r\nv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0x0, 0xff, 1, 0x80);\r\nv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0x0, 0xff, 1, 0x40);\r\nv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_SATURATION, 0x0, 0xff, 1, 0x40);\r\nv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_HUE, 0x0, 0x1e, 1, 0xf);\r\nv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_SHARPNESS, 0x0, 0xff, 1, 0x80);\r\n} else {\r\nv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0x0, 0xff, 1, 0x86);\r\nv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0x0, 0xff, 1, 0x80);\r\nv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_SATURATION, 0x0, 0xff, 1, 0x80);\r\nv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_HUE, 0x0, 0xff, 1, 0x80);\r\nv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_SHARPNESS, 0x0, 0xff, 1, 0x80);\r\n}\r\nv4l2_ctrl_new_std_menu(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_MPEG_STREAM_TYPE,\r\nV4L2_MPEG_STREAM_TYPE_MPEG2_TS,\r\n0x1, V4L2_MPEG_STREAM_TYPE_MPEG2_TS);\r\nv4l2_ctrl_new_std_menu(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_MPEG_AUDIO_ENCODING,\r\nac3 ? V4L2_MPEG_AUDIO_ENCODING_AC3 : V4L2_MPEG_AUDIO_ENCODING_AAC,\r\n0x7, ac3 ? dev->options.audio_codec : V4L2_MPEG_AUDIO_ENCODING_AAC);\r\nv4l2_ctrl_new_std_menu(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_ENCODING,\r\nV4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC, 0x3,\r\nV4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC);\r\ndev->video_mode = v4l2_ctrl_new_std_menu(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_BITRATE_MODE,\r\nV4L2_MPEG_VIDEO_BITRATE_MODE_CBR, 0,\r\nV4L2_MPEG_VIDEO_BITRATE_MODE_CBR);\r\ndev->video_bitrate = v4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_BITRATE,\r\n1000000, 13500000, 100000, 6500000);\r\ndev->video_bitrate_peak = v4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_BITRATE_PEAK,\r\n1100000, 20200000, 100000, 9000000);\r\ndev->v4l2_dev.ctrl_handler = hdl;\r\nif (hdl->error) {\r\nres = hdl->error;\r\nv4l2_err(&dev->v4l2_dev, "Could not register controls\n");\r\ngoto error;\r\n}\r\nv4l2_ctrl_cluster(3, &dev->video_mode);\r\nres = v4l2_ctrl_handler_setup(hdl);\r\nif (res < 0) {\r\nv4l2_err(&dev->v4l2_dev, "Could not setup controls\n");\r\ngoto error;\r\n}\r\ndev->video_dev = hdpvr_video_template;\r\nstrcpy(dev->video_dev.name, "Hauppauge HD PVR");\r\ndev->video_dev.v4l2_dev = &dev->v4l2_dev;\r\nvideo_set_drvdata(&dev->video_dev, dev);\r\nres = video_register_device(&dev->video_dev, VFL_TYPE_GRABBER, devnum);\r\nif (res < 0) {\r\nv4l2_err(&dev->v4l2_dev, "video_device registration failed\n");\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn res;\r\n}
