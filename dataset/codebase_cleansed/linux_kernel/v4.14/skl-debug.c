static ssize_t skl_print_pins(struct skl_module_pin *m_pin, char *buf,\r\nint max_pin, ssize_t size, bool direction)\r\n{\r\nint i;\r\nssize_t ret = 0;\r\nfor (i = 0; i < max_pin; i++)\r\nret += snprintf(buf + size, MOD_BUF - size,\r\n"%s %d\n\tModule %d\n\tInstance %d\n\t"\r\n"In-used %s\n\tType %s\n"\r\n"\tState %d\n\tIndex %d\n",\r\ndirection ? "Input Pin:" : "Output Pin:",\r\ni, m_pin[i].id.module_id,\r\nm_pin[i].id.instance_id,\r\nm_pin[i].in_use ? "Used" : "Unused",\r\nm_pin[i].is_dynamic ? "Dynamic" : "Static",\r\nm_pin[i].pin_state, i);\r\nreturn ret;\r\n}\r\nstatic ssize_t skl_print_fmt(struct skl_module_fmt *fmt, char *buf,\r\nssize_t size, bool direction)\r\n{\r\nreturn snprintf(buf + size, MOD_BUF - size,\r\n"%s\n\tCh %d\n\tFreq %d\n\tBit depth %d\n\t"\r\n"Valid bit depth %d\n\tCh config %#x\n\tInterleaving %d\n\t"\r\n"Sample Type %d\n\tCh Map %#x\n",\r\ndirection ? "Input Format:" : "Output Format:",\r\nfmt->channels, fmt->s_freq, fmt->bit_depth,\r\nfmt->valid_bit_depth, fmt->ch_cfg,\r\nfmt->interleaving_style, fmt->sample_type,\r\nfmt->ch_map);\r\n}\r\nstatic ssize_t module_read(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct skl_module_cfg *mconfig = file->private_data;\r\nchar *buf;\r\nssize_t ret;\r\nbuf = kzalloc(MOD_BUF, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = snprintf(buf, MOD_BUF, "Module:\n\tUUID %pUL\n\tModule id %d\n"\r\n"\tInstance id %d\n\tPvt_id %d\n", mconfig->guid,\r\nmconfig->id.module_id, mconfig->id.instance_id,\r\nmconfig->id.pvt_id);\r\nret += snprintf(buf + ret, MOD_BUF - ret,\r\n"Resources:\n\tMCPS %#x\n\tIBS %#x\n\tOBS %#x\t\n",\r\nmconfig->mcps, mconfig->ibs, mconfig->obs);\r\nret += snprintf(buf + ret, MOD_BUF - ret,\r\n"Module data:\n\tCore %d\n\tIn queue %d\n\t"\r\n"Out queue %d\n\tType %s\n",\r\nmconfig->core_id, mconfig->max_in_queue,\r\nmconfig->max_out_queue,\r\nmconfig->is_loadable ? "loadable" : "inbuilt");\r\nret += skl_print_fmt(mconfig->in_fmt, buf, ret, true);\r\nret += skl_print_fmt(mconfig->out_fmt, buf, ret, false);\r\nret += snprintf(buf + ret, MOD_BUF - ret,\r\n"Fixup:\n\tParams %#x\n\tConverter %#x\n",\r\nmconfig->params_fixup, mconfig->converter);\r\nret += snprintf(buf + ret, MOD_BUF - ret,\r\n"Module Gateway:\n\tType %#x\n\tVbus %#x\n\tHW conn %#x\n\tSlot %#x\n",\r\nmconfig->dev_type, mconfig->vbus_id,\r\nmconfig->hw_conn_type, mconfig->time_slot);\r\nret += snprintf(buf + ret, MOD_BUF - ret,\r\n"Pipeline:\n\tID %d\n\tPriority %d\n\tConn Type %d\n\t"\r\n"Pages %#x\n", mconfig->pipe->ppl_id,\r\nmconfig->pipe->pipe_priority, mconfig->pipe->conn_type,\r\nmconfig->pipe->memory_pages);\r\nret += snprintf(buf + ret, MOD_BUF - ret,\r\n"\tParams:\n\t\tHost DMA %d\n\t\tLink DMA %d\n",\r\nmconfig->pipe->p_params->host_dma_id,\r\nmconfig->pipe->p_params->link_dma_id);\r\nret += snprintf(buf + ret, MOD_BUF - ret,\r\n"\tPCM params:\n\t\tCh %d\n\t\tFreq %d\n\t\tFormat %d\n",\r\nmconfig->pipe->p_params->ch,\r\nmconfig->pipe->p_params->s_freq,\r\nmconfig->pipe->p_params->s_fmt);\r\nret += snprintf(buf + ret, MOD_BUF - ret,\r\n"\tLink %#x\n\tStream %#x\n",\r\nmconfig->pipe->p_params->linktype,\r\nmconfig->pipe->p_params->stream);\r\nret += snprintf(buf + ret, MOD_BUF - ret,\r\n"\tState %d\n\tPassthru %s\n",\r\nmconfig->pipe->state,\r\nmconfig->pipe->passthru ? "true" : "false");\r\nret += skl_print_pins(mconfig->m_in_pin, buf,\r\nmconfig->max_in_queue, ret, true);\r\nret += skl_print_pins(mconfig->m_out_pin, buf,\r\nmconfig->max_out_queue, ret, false);\r\nret += snprintf(buf + ret, MOD_BUF - ret,\r\n"Other:\n\tDomain %d\n\tHomogenous Input %s\n\t"\r\n"Homogenous Output %s\n\tIn Queue Mask %d\n\t"\r\n"Out Queue Mask %d\n\tDMA ID %d\n\tMem Pages %d\n\t"\r\n"Module Type %d\n\tModule State %d\n",\r\nmconfig->domain,\r\nmconfig->homogenous_inputs ? "true" : "false",\r\nmconfig->homogenous_outputs ? "true" : "false",\r\nmconfig->in_queue_mask, mconfig->out_queue_mask,\r\nmconfig->dma_id, mconfig->mem_pages, mconfig->m_state,\r\nmconfig->m_type);\r\nret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nvoid skl_debug_init_module(struct skl_debug *d,\r\nstruct snd_soc_dapm_widget *w,\r\nstruct skl_module_cfg *mconfig)\r\n{\r\nif (!debugfs_create_file(w->name, 0444,\r\nd->modules, mconfig,\r\n&mcfg_fops))\r\ndev_err(d->dev, "%s: module debugfs init failed\n", w->name);\r\n}\r\nstatic ssize_t fw_softreg_read(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct skl_debug *d = file->private_data;\r\nstruct sst_dsp *sst = d->skl->skl_sst->dsp;\r\nsize_t w0_stat_sz = sst->addr.w0_stat_sz;\r\nvoid __iomem *in_base = sst->mailbox.in_base;\r\nvoid __iomem *fw_reg_addr;\r\nunsigned int offset;\r\nchar *tmp;\r\nssize_t ret = 0;\r\ntmp = kzalloc(FW_REG_BUF, GFP_KERNEL);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nfw_reg_addr = in_base - w0_stat_sz;\r\nmemset(d->fw_read_buff, 0, FW_REG_BUF);\r\nif (w0_stat_sz > 0)\r\n__iowrite32_copy(d->fw_read_buff, fw_reg_addr, w0_stat_sz >> 2);\r\nfor (offset = 0; offset < FW_REG_SIZE; offset += 16) {\r\nret += snprintf(tmp + ret, FW_REG_BUF - ret, "%#.4x: ", offset);\r\nhex_dump_to_buffer(d->fw_read_buff + offset, 16, 16, 4,\r\ntmp + ret, FW_REG_BUF - ret, 0);\r\nret += strlen(tmp + ret);\r\nif (FW_REG_BUF - ret > 0)\r\ntmp[ret++] = '\n';\r\n}\r\nret = simple_read_from_buffer(user_buf, count, ppos, tmp, ret);\r\nkfree(tmp);\r\nreturn ret;\r\n}\r\nstruct skl_debug *skl_debugfs_init(struct skl *skl)\r\n{\r\nstruct skl_debug *d;\r\nd = devm_kzalloc(&skl->pci->dev, sizeof(*d), GFP_KERNEL);\r\nif (!d)\r\nreturn NULL;\r\nd->fs = debugfs_create_dir("dsp",\r\nskl->platform->component.debugfs_root);\r\nif (IS_ERR(d->fs) || !d->fs) {\r\ndev_err(&skl->pci->dev, "debugfs root creation failed\n");\r\nreturn NULL;\r\n}\r\nd->skl = skl;\r\nd->dev = &skl->pci->dev;\r\nd->modules = debugfs_create_dir("modules", d->fs);\r\nif (IS_ERR(d->modules) || !d->modules) {\r\ndev_err(&skl->pci->dev, "modules debugfs create failed\n");\r\ngoto err;\r\n}\r\nif (!debugfs_create_file("fw_soft_regs_rd", 0444, d->fs, d,\r\n&soft_regs_ctrl_fops)) {\r\ndev_err(d->dev, "fw soft regs control debugfs init failed\n");\r\ngoto err;\r\n}\r\nreturn d;\r\nerr:\r\ndebugfs_remove_recursive(d->fs);\r\nreturn NULL;\r\n}
