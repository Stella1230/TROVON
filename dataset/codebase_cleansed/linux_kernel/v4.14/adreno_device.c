static inline bool _rev_match(uint8_t entry, uint8_t id)\r\n{\r\nreturn (entry == ANY_ID) || (entry == id);\r\n}\r\nconst struct adreno_info *adreno_info(struct adreno_rev rev)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(gpulist); i++) {\r\nconst struct adreno_info *info = &gpulist[i];\r\nif (_rev_match(info->rev.core, rev.core) &&\r\n_rev_match(info->rev.major, rev.major) &&\r\n_rev_match(info->rev.minor, rev.minor) &&\r\n_rev_match(info->rev.patchid, rev.patchid))\r\nreturn info;\r\n}\r\nreturn NULL;\r\n}\r\nstruct msm_gpu *adreno_load_gpu(struct drm_device *dev)\r\n{\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct platform_device *pdev = priv->gpu_pdev;\r\nstruct adreno_platform_config *config;\r\nstruct adreno_rev rev;\r\nconst struct adreno_info *info;\r\nstruct msm_gpu *gpu = NULL;\r\nif (!pdev) {\r\ndev_err(dev->dev, "no adreno device\n");\r\nreturn NULL;\r\n}\r\nconfig = pdev->dev.platform_data;\r\nrev = config->rev;\r\ninfo = adreno_info(config->rev);\r\nif (!info) {\r\ndev_warn(dev->dev, "Unknown GPU revision: %u.%u.%u.%u\n",\r\nrev.core, rev.major, rev.minor, rev.patchid);\r\nreturn NULL;\r\n}\r\nDBG("Found GPU: %u.%u.%u.%u", rev.core, rev.major,\r\nrev.minor, rev.patchid);\r\ngpu = info->init(dev);\r\nif (IS_ERR(gpu)) {\r\ndev_warn(dev->dev, "failed to load adreno gpu\n");\r\ngpu = NULL;\r\n}\r\nif (gpu) {\r\nint ret;\r\npm_runtime_get_sync(&pdev->dev);\r\nmutex_lock(&dev->struct_mutex);\r\nret = msm_gpu_hw_init(gpu);\r\nmutex_unlock(&dev->struct_mutex);\r\npm_runtime_put_sync(&pdev->dev);\r\nif (ret) {\r\ndev_err(dev->dev, "gpu hw init failed: %d\n", ret);\r\ngpu->funcs->destroy(gpu);\r\ngpu = NULL;\r\n}\r\n}\r\nreturn gpu;\r\n}\r\nstatic void set_gpu_pdev(struct drm_device *dev,\r\nstruct platform_device *pdev)\r\n{\r\nstruct msm_drm_private *priv = dev->dev_private;\r\npriv->gpu_pdev = pdev;\r\n}\r\nstatic int find_chipid(struct device *dev, u32 *chipid)\r\n{\r\nstruct device_node *node = dev->of_node;\r\nconst char *compat;\r\nint ret;\r\nret = of_property_read_string_index(node, "compatible", 0, &compat);\r\nif (ret == 0) {\r\nunsigned rev, patch;\r\nif (sscanf(compat, "qcom,adreno-%u.%u", &rev, &patch) == 2) {\r\n*chipid = 0;\r\n*chipid |= (rev / 100) << 24;\r\nrev %= 100;\r\n*chipid |= (rev / 10) << 16;\r\nrev %= 10;\r\n*chipid |= rev << 8;\r\n*chipid |= patch;\r\nreturn 0;\r\n}\r\n}\r\nret = of_property_read_u32(node, "qcom,chipid", chipid);\r\nif (ret)\r\nreturn ret;\r\ndev_warn(dev, "Using legacy qcom,chipid binding!\n");\r\ndev_warn(dev, "Use compatible qcom,adreno-%u%u%u.%u instead.\n",\r\n(*chipid >> 24) & 0xff, (*chipid >> 16) & 0xff,\r\n(*chipid >> 8) & 0xff, *chipid & 0xff);\r\nreturn 0;\r\n}\r\nstatic int adreno_get_legacy_pwrlevels(struct device *dev)\r\n{\r\nstruct device_node *child, *node;\r\nint ret;\r\nnode = of_find_compatible_node(dev->of_node, NULL,\r\n"qcom,gpu-pwrlevels");\r\nif (!node) {\r\ndev_err(dev, "Could not find the GPU powerlevels\n");\r\nreturn -ENXIO;\r\n}\r\nfor_each_child_of_node(node, child) {\r\nunsigned int val;\r\nret = of_property_read_u32(child, "qcom,gpu-freq", &val);\r\nif (ret)\r\ncontinue;\r\nif (val != 27000000)\r\ndev_pm_opp_add(dev, val, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adreno_get_pwrlevels(struct device *dev,\r\nstruct adreno_platform_config *config)\r\n{\r\nunsigned long freq = ULONG_MAX;\r\nstruct dev_pm_opp *opp;\r\nint ret;\r\nif (!of_find_property(dev->of_node, "operating-points-v2", NULL))\r\nret = adreno_get_legacy_pwrlevels(dev);\r\nelse\r\nret = dev_pm_opp_of_add_table(dev);\r\nif (ret)\r\nreturn ret;\r\nopp = dev_pm_opp_find_freq_floor(dev, &freq);\r\nif (!IS_ERR(opp))\r\nconfig->fast_rate = dev_pm_opp_get_freq(opp);\r\nif (!config->fast_rate) {\r\nDRM_DEV_INFO(dev,\r\n"Could not find clock rate. Using default\n");\r\nconfig->fast_rate = 200000000;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adreno_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstatic struct adreno_platform_config config = {};\r\nu32 val;\r\nint ret;\r\nret = find_chipid(dev, &val);\r\nif (ret) {\r\ndev_err(dev, "could not find chipid: %d\n", ret);\r\nreturn ret;\r\n}\r\nconfig.rev = ADRENO_REV((val >> 24) & 0xff,\r\n(val >> 16) & 0xff, (val >> 8) & 0xff, val & 0xff);\r\nconfig.fast_rate = 0;\r\nret = adreno_get_pwrlevels(dev, &config);\r\nif (ret)\r\nreturn ret;\r\ndev->platform_data = &config;\r\nset_gpu_pdev(dev_get_drvdata(master), to_platform_device(dev));\r\nreturn 0;\r\n}\r\nstatic void adreno_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nset_gpu_pdev(dev_get_drvdata(master), NULL);\r\n}\r\nstatic int adreno_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &a3xx_ops);\r\n}\r\nstatic int adreno_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &a3xx_ops);\r\nreturn 0;\r\n}\r\nstatic int adreno_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct msm_gpu *gpu = platform_get_drvdata(pdev);\r\nreturn gpu->funcs->pm_resume(gpu);\r\n}\r\nstatic int adreno_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct msm_gpu *gpu = platform_get_drvdata(pdev);\r\nreturn gpu->funcs->pm_suspend(gpu);\r\n}\r\nvoid __init adreno_register(void)\r\n{\r\nplatform_driver_register(&adreno_driver);\r\n}\r\nvoid __exit adreno_unregister(void)\r\n{\r\nplatform_driver_unregister(&adreno_driver);\r\n}
