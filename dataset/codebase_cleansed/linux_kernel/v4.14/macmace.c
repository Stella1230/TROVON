static void mace_load_rxdma_base(struct net_device *dev, int set)\r\n{\r\nstruct mace_data *mp = netdev_priv(dev);\r\npsc_write_word(PSC_ENETRD_CMD + set, 0x0100);\r\npsc_write_long(PSC_ENETRD_ADDR + set, (u32) mp->rx_ring_phys);\r\npsc_write_long(PSC_ENETRD_LEN + set, N_RX_RING);\r\npsc_write_word(PSC_ENETRD_CMD + set, 0x9800);\r\nmp->rx_tail = 0;\r\n}\r\nstatic void mace_rxdma_reset(struct net_device *dev)\r\n{\r\nstruct mace_data *mp = netdev_priv(dev);\r\nvolatile struct mace *mace = mp->mace;\r\nu8 maccc = mace->maccc;\r\nmace->maccc = maccc & ~ENRCV;\r\npsc_write_word(PSC_ENETRD_CTL, 0x8800);\r\nmace_load_rxdma_base(dev, 0x00);\r\npsc_write_word(PSC_ENETRD_CTL, 0x0400);\r\npsc_write_word(PSC_ENETRD_CTL, 0x8800);\r\nmace_load_rxdma_base(dev, 0x10);\r\npsc_write_word(PSC_ENETRD_CTL, 0x0400);\r\nmace->maccc = maccc;\r\nmp->rx_slot = 0;\r\npsc_write_word(PSC_ENETRD_CMD + PSC_SET0, 0x9800);\r\npsc_write_word(PSC_ENETRD_CMD + PSC_SET1, 0x9800);\r\n}\r\nstatic void mace_txdma_reset(struct net_device *dev)\r\n{\r\nstruct mace_data *mp = netdev_priv(dev);\r\nvolatile struct mace *mace = mp->mace;\r\nu8 maccc;\r\npsc_write_word(PSC_ENETWR_CTL, 0x8800);\r\nmaccc = mace->maccc;\r\nmace->maccc = maccc & ~ENXMT;\r\nmp->tx_slot = mp->tx_sloti = 0;\r\nmp->tx_count = N_TX_RING;\r\npsc_write_word(PSC_ENETWR_CTL, 0x0400);\r\nmace->maccc = maccc;\r\n}\r\nstatic void mace_dma_off(struct net_device *dev)\r\n{\r\npsc_write_word(PSC_ENETRD_CTL, 0x8800);\r\npsc_write_word(PSC_ENETRD_CTL, 0x1000);\r\npsc_write_word(PSC_ENETRD_CMD + PSC_SET0, 0x1100);\r\npsc_write_word(PSC_ENETRD_CMD + PSC_SET1, 0x1100);\r\npsc_write_word(PSC_ENETWR_CTL, 0x8800);\r\npsc_write_word(PSC_ENETWR_CTL, 0x1000);\r\npsc_write_word(PSC_ENETWR_CMD + PSC_SET0, 0x1100);\r\npsc_write_word(PSC_ENETWR_CMD + PSC_SET1, 0x1100);\r\n}\r\nstatic int mace_probe(struct platform_device *pdev)\r\n{\r\nint j;\r\nstruct mace_data *mp;\r\nunsigned char *addr;\r\nstruct net_device *dev;\r\nunsigned char checksum = 0;\r\nint err;\r\ndev = alloc_etherdev(PRIV_BYTES);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nmp = netdev_priv(dev);\r\nmp->device = &pdev->dev;\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\ndev->base_addr = (u32)MACE_BASE;\r\nmp->mace = MACE_BASE;\r\ndev->irq = IRQ_MAC_MACE;\r\nmp->dma_intr = IRQ_MAC_MACE_DMA;\r\nmp->chipid = mp->mace->chipid_hi << 8 | mp->mace->chipid_lo;\r\naddr = MACE_PROM;\r\nfor (j = 0; j < 6; ++j) {\r\nu8 v = bitrev8(addr[j<<4]);\r\nchecksum ^= v;\r\ndev->dev_addr[j] = v;\r\n}\r\nfor (; j < 8; ++j) {\r\nchecksum ^= bitrev8(addr[j<<4]);\r\n}\r\nif (checksum != 0xFF) {\r\nfree_netdev(dev);\r\nreturn -ENODEV;\r\n}\r\ndev->netdev_ops = &mace_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nprintk(KERN_INFO "%s: 68K MACE, hardware address %pM\n",\r\ndev->name, dev->dev_addr);\r\nerr = register_netdev(dev);\r\nif (!err)\r\nreturn 0;\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic void mace_reset(struct net_device *dev)\r\n{\r\nstruct mace_data *mp = netdev_priv(dev);\r\nvolatile struct mace *mb = mp->mace;\r\nint i;\r\ni = 200;\r\nwhile (--i) {\r\nmb->biucc = SWRST;\r\nif (mb->biucc & SWRST) {\r\nudelay(10);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (!i) {\r\nprintk(KERN_ERR "macmace: cannot reset chip!\n");\r\nreturn;\r\n}\r\nmb->maccc = 0;\r\nmb->imr = 0xFF;\r\ni = mb->ir;\r\nmb->biucc = XMTSP_64;\r\nmb->utr = RTRD;\r\nmb->fifocc = XMTFW_8 | RCVFW_64 | XMTFWU | RCVFWU;\r\nmb->xmtfc = AUTO_PAD_XMIT;\r\nmb->rcvfc = 0;\r\n__mace_set_address(dev, dev->dev_addr);\r\nif (mp->chipid == BROKEN_ADDRCHG_REV)\r\nmb->iac = LOGADDR;\r\nelse {\r\nmb->iac = ADDRCHG | LOGADDR;\r\nwhile ((mb->iac & ADDRCHG) != 0)\r\n;\r\n}\r\nfor (i = 0; i < 8; ++i)\r\nmb->ladrf = 0;\r\nif (mp->chipid != BROKEN_ADDRCHG_REV)\r\nmb->iac = 0;\r\nmb->plscc = PORTSEL_AUI;\r\n}\r\nstatic void __mace_set_address(struct net_device *dev, void *addr)\r\n{\r\nstruct mace_data *mp = netdev_priv(dev);\r\nvolatile struct mace *mb = mp->mace;\r\nunsigned char *p = addr;\r\nint i;\r\nif (mp->chipid == BROKEN_ADDRCHG_REV)\r\nmb->iac = PHYADDR;\r\nelse {\r\nmb->iac = ADDRCHG | PHYADDR;\r\nwhile ((mb->iac & ADDRCHG) != 0)\r\n;\r\n}\r\nfor (i = 0; i < 6; ++i)\r\nmb->padr = dev->dev_addr[i] = p[i];\r\nif (mp->chipid != BROKEN_ADDRCHG_REV)\r\nmb->iac = 0;\r\n}\r\nstatic int mace_set_address(struct net_device *dev, void *addr)\r\n{\r\nstruct mace_data *mp = netdev_priv(dev);\r\nvolatile struct mace *mb = mp->mace;\r\nunsigned long flags;\r\nu8 maccc;\r\nlocal_irq_save(flags);\r\nmaccc = mb->maccc;\r\n__mace_set_address(dev, addr);\r\nmb->maccc = maccc;\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int mace_open(struct net_device *dev)\r\n{\r\nstruct mace_data *mp = netdev_priv(dev);\r\nvolatile struct mace *mb = mp->mace;\r\nmace_reset(dev);\r\nif (request_irq(dev->irq, mace_interrupt, 0, dev->name, dev)) {\r\nprintk(KERN_ERR "%s: can't get irq %d\n", dev->name, dev->irq);\r\nreturn -EAGAIN;\r\n}\r\nif (request_irq(mp->dma_intr, mace_dma_intr, 0, dev->name, dev)) {\r\nprintk(KERN_ERR "%s: can't get irq %d\n", dev->name, mp->dma_intr);\r\nfree_irq(dev->irq, dev);\r\nreturn -EAGAIN;\r\n}\r\nmp->tx_ring = dma_alloc_coherent(mp->device,\r\nN_TX_RING * MACE_BUFF_SIZE,\r\n&mp->tx_ring_phys, GFP_KERNEL);\r\nif (mp->tx_ring == NULL)\r\ngoto out1;\r\nmp->rx_ring = dma_alloc_coherent(mp->device,\r\nN_RX_RING * MACE_BUFF_SIZE,\r\n&mp->rx_ring_phys, GFP_KERNEL);\r\nif (mp->rx_ring == NULL)\r\ngoto out2;\r\nmace_dma_off(dev);\r\npsc_write_word(PSC_ENETWR_CTL, 0x9000);\r\npsc_write_word(PSC_ENETRD_CTL, 0x9000);\r\npsc_write_word(PSC_ENETWR_CTL, 0x0400);\r\npsc_write_word(PSC_ENETRD_CTL, 0x0400);\r\nmace_rxdma_reset(dev);\r\nmace_txdma_reset(dev);\r\nmb->maccc = ENXMT | ENRCV;\r\nmb->imr = RCVINT;\r\nreturn 0;\r\nout2:\r\ndma_free_coherent(mp->device, N_TX_RING * MACE_BUFF_SIZE,\r\nmp->tx_ring, mp->tx_ring_phys);\r\nout1:\r\nfree_irq(dev->irq, dev);\r\nfree_irq(mp->dma_intr, dev);\r\nreturn -ENOMEM;\r\n}\r\nstatic int mace_close(struct net_device *dev)\r\n{\r\nstruct mace_data *mp = netdev_priv(dev);\r\nvolatile struct mace *mb = mp->mace;\r\nmb->maccc = 0;\r\nmb->imr = 0xFF;\r\nmace_dma_off(dev);\r\nreturn 0;\r\n}\r\nstatic int mace_xmit_start(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct mace_data *mp = netdev_priv(dev);\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nnetif_stop_queue(dev);\r\nif (!mp->tx_count) {\r\nprintk(KERN_ERR "macmace: tx queue running but no free buffers.\n");\r\nlocal_irq_restore(flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nmp->tx_count--;\r\nlocal_irq_restore(flags);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nskb_copy_from_linear_data(skb, mp->tx_ring, skb->len);\r\npsc_write_long(PSC_ENETWR_ADDR + mp->tx_slot, (u32) mp->tx_ring_phys);\r\npsc_write_long(PSC_ENETWR_LEN + mp->tx_slot, skb->len);\r\npsc_write_word(PSC_ENETWR_CMD + mp->tx_slot, 0x9800);\r\nmp->tx_slot ^= 0x10;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void mace_set_multicast(struct net_device *dev)\r\n{\r\nstruct mace_data *mp = netdev_priv(dev);\r\nvolatile struct mace *mb = mp->mace;\r\nint i;\r\nu32 crc;\r\nu8 maccc;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nmaccc = mb->maccc;\r\nmb->maccc &= ~PROM;\r\nif (dev->flags & IFF_PROMISC) {\r\nmb->maccc |= PROM;\r\n} else {\r\nunsigned char multicast_filter[8];\r\nstruct netdev_hw_addr *ha;\r\nif (dev->flags & IFF_ALLMULTI) {\r\nfor (i = 0; i < 8; i++) {\r\nmulticast_filter[i] = 0xFF;\r\n}\r\n} else {\r\nfor (i = 0; i < 8; i++)\r\nmulticast_filter[i] = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc_le(6, ha->addr);\r\ni = crc >> 26;\r\nmulticast_filter[i >> 3] |= 1 << (i & 7);\r\n}\r\n}\r\nif (mp->chipid == BROKEN_ADDRCHG_REV)\r\nmb->iac = LOGADDR;\r\nelse {\r\nmb->iac = ADDRCHG | LOGADDR;\r\nwhile ((mb->iac & ADDRCHG) != 0)\r\n;\r\n}\r\nfor (i = 0; i < 8; ++i)\r\nmb->ladrf = multicast_filter[i];\r\nif (mp->chipid != BROKEN_ADDRCHG_REV)\r\nmb->iac = 0;\r\n}\r\nmb->maccc = maccc;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void mace_handle_misc_intrs(struct net_device *dev, int intr)\r\n{\r\nstruct mace_data *mp = netdev_priv(dev);\r\nvolatile struct mace *mb = mp->mace;\r\nstatic int mace_babbles, mace_jabbers;\r\nif (intr & MPCO)\r\ndev->stats.rx_missed_errors += 256;\r\ndev->stats.rx_missed_errors += mb->mpc;\r\nif (intr & RNTPCO)\r\ndev->stats.rx_length_errors += 256;\r\ndev->stats.rx_length_errors += mb->rntpc;\r\nif (intr & CERR)\r\n++dev->stats.tx_heartbeat_errors;\r\nif (intr & BABBLE)\r\nif (mace_babbles++ < 4)\r\nprintk(KERN_DEBUG "macmace: babbling transmitter\n");\r\nif (intr & JABBER)\r\nif (mace_jabbers++ < 4)\r\nprintk(KERN_DEBUG "macmace: jabbering transceiver\n");\r\n}\r\nstatic irqreturn_t mace_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_id;\r\nstruct mace_data *mp = netdev_priv(dev);\r\nvolatile struct mace *mb = mp->mace;\r\nint intr, fs;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nintr = mb->ir;\r\nmace_handle_misc_intrs(dev, intr);\r\nif (intr & XMTINT) {\r\nfs = mb->xmtfs;\r\nif ((fs & XMTSV) == 0) {\r\nprintk(KERN_ERR "macmace: xmtfs not valid! (fs=%x)\n", fs);\r\nmace_reset(dev);\r\n}\r\nif (!mp->tx_count) {\r\nprintk(KERN_DEBUG "macmace: tx ring ran out? (fs=%x)\n", fs);\r\n}\r\nif (fs & (UFLO|LCOL|LCAR|RTRY)) {\r\n++dev->stats.tx_errors;\r\nif (fs & LCAR)\r\n++dev->stats.tx_carrier_errors;\r\nelse if (fs & (UFLO|LCOL|RTRY)) {\r\n++dev->stats.tx_aborted_errors;\r\nif (mb->xmtfs & UFLO) {\r\nprintk(KERN_ERR "%s: DMA underrun.\n", dev->name);\r\ndev->stats.tx_fifo_errors++;\r\nmace_txdma_reset(dev);\r\n}\r\n}\r\n}\r\n}\r\nif (mp->tx_count)\r\nnetif_wake_queue(dev);\r\nlocal_irq_restore(flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mace_tx_timeout(struct net_device *dev)\r\n{\r\nstruct mace_data *mp = netdev_priv(dev);\r\nvolatile struct mace *mb = mp->mace;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nmb->maccc = 0;\r\nprintk(KERN_ERR "macmace: transmit timeout - resetting\n");\r\nmace_txdma_reset(dev);\r\nmace_reset(dev);\r\nmace_rxdma_reset(dev);\r\nmp->tx_count = N_TX_RING;\r\nnetif_wake_queue(dev);\r\nmb->maccc = ENXMT | ENRCV;\r\nmb->imr = RCVINT;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void mace_dma_rx_frame(struct net_device *dev, struct mace_frame *mf)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned int frame_status = mf->rcvsts;\r\nif (frame_status & (RS_OFLO | RS_CLSN | RS_FRAMERR | RS_FCSERR)) {\r\ndev->stats.rx_errors++;\r\nif (frame_status & RS_OFLO) {\r\nprintk(KERN_DEBUG "%s: fifo overflow.\n", dev->name);\r\ndev->stats.rx_fifo_errors++;\r\n}\r\nif (frame_status & RS_CLSN)\r\ndev->stats.collisions++;\r\nif (frame_status & RS_FRAMERR)\r\ndev->stats.rx_frame_errors++;\r\nif (frame_status & RS_FCSERR)\r\ndev->stats.rx_crc_errors++;\r\n} else {\r\nunsigned int frame_length = mf->rcvcnt + ((frame_status & 0x0F) << 8 );\r\nskb = netdev_alloc_skb(dev, frame_length + 2);\r\nif (!skb) {\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\nskb_put_data(skb, mf->data, frame_length);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += frame_length;\r\n}\r\n}\r\nstatic irqreturn_t mace_dma_intr(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_id;\r\nstruct mace_data *mp = netdev_priv(dev);\r\nint left, head;\r\nu16 status;\r\nu32 baka;\r\nwhile ((baka = psc_read_long(PSC_MYSTERY)) != psc_read_long(PSC_MYSTERY));\r\nif (!(baka & 0x60000000)) return IRQ_NONE;\r\nstatus = psc_read_word(PSC_ENETRD_CTL);\r\nif (status & 0x2000) {\r\nmace_rxdma_reset(dev);\r\n} else if (status & 0x0100) {\r\npsc_write_word(PSC_ENETRD_CMD + mp->rx_slot, 0x1100);\r\nleft = psc_read_long(PSC_ENETRD_LEN + mp->rx_slot);\r\nhead = N_RX_RING - left;\r\nwhile (mp->rx_tail < head) {\r\nmace_dma_rx_frame(dev, (struct mace_frame*) (mp->rx_ring\r\n+ (mp->rx_tail * MACE_BUFF_SIZE)));\r\nmp->rx_tail++;\r\n}\r\nif (!left) {\r\nmace_load_rxdma_base(dev, mp->rx_slot);\r\nmp->rx_slot ^= 0x10;\r\n} else {\r\npsc_write_word(PSC_ENETRD_CMD + mp->rx_slot, 0x9800);\r\n}\r\n}\r\nstatus = psc_read_word(PSC_ENETWR_CTL);\r\nif (status & 0x2000) {\r\nmace_txdma_reset(dev);\r\n} else if (status & 0x0100) {\r\npsc_write_word(PSC_ENETWR_CMD + mp->tx_sloti, 0x0100);\r\nmp->tx_sloti ^= 0x10;\r\nmp->tx_count++;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mac_mace_device_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct mace_data *mp = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nfree_irq(dev->irq, dev);\r\nfree_irq(IRQ_MAC_MACE_DMA, dev);\r\ndma_free_coherent(mp->device, N_RX_RING * MACE_BUFF_SIZE,\r\nmp->rx_ring, mp->rx_ring_phys);\r\ndma_free_coherent(mp->device, N_TX_RING * MACE_BUFF_SIZE,\r\nmp->tx_ring, mp->tx_ring_phys);\r\nfree_netdev(dev);\r\nreturn 0;\r\n}\r\nstatic int __init mac_mace_init_module(void)\r\n{\r\nif (!MACH_IS_MAC)\r\nreturn -ENODEV;\r\nreturn platform_driver_register(&mac_mace_driver);\r\n}\r\nstatic void __exit mac_mace_cleanup_module(void)\r\n{\r\nplatform_driver_unregister(&mac_mace_driver);\r\n}
