static int cp110_gate_enable(struct clk_hw *hw)\r\n{\r\nstruct cp110_gate_clk *gate = to_cp110_gate_clk(hw);\r\nregmap_update_bits(gate->regmap, CP110_PM_CLOCK_GATING_REG,\r\nBIT(gate->bit_idx), BIT(gate->bit_idx));\r\nreturn 0;\r\n}\r\nstatic void cp110_gate_disable(struct clk_hw *hw)\r\n{\r\nstruct cp110_gate_clk *gate = to_cp110_gate_clk(hw);\r\nregmap_update_bits(gate->regmap, CP110_PM_CLOCK_GATING_REG,\r\nBIT(gate->bit_idx), 0);\r\n}\r\nstatic int cp110_gate_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct cp110_gate_clk *gate = to_cp110_gate_clk(hw);\r\nu32 val;\r\nregmap_read(gate->regmap, CP110_PM_CLOCK_GATING_REG, &val);\r\nreturn val & BIT(gate->bit_idx);\r\n}\r\nstatic struct clk_hw *cp110_register_gate(const char *name,\r\nconst char *parent_name,\r\nstruct regmap *regmap, u8 bit_idx)\r\n{\r\nstruct cp110_gate_clk *gate;\r\nstruct clk_hw *hw;\r\nstruct clk_init_data init;\r\nint ret;\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate)\r\nreturn ERR_PTR(-ENOMEM);\r\nmemset(&init, 0, sizeof(init));\r\ninit.name = name;\r\ninit.ops = &cp110_gate_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\ngate->regmap = regmap;\r\ngate->bit_idx = bit_idx;\r\ngate->hw.init = &init;\r\nhw = &gate->hw;\r\nret = clk_hw_register(NULL, hw);\r\nif (ret) {\r\nkfree(gate);\r\nhw = ERR_PTR(ret);\r\n}\r\nreturn hw;\r\n}\r\nstatic void cp110_unregister_gate(struct clk_hw *hw)\r\n{\r\nclk_hw_unregister(hw);\r\nkfree(to_cp110_gate_clk(hw));\r\n}\r\nstatic struct clk_hw *cp110_of_clk_get(struct of_phandle_args *clkspec,\r\nvoid *data)\r\n{\r\nstruct clk_hw_onecell_data *clk_data = data;\r\nunsigned int type = clkspec->args[0];\r\nunsigned int idx = clkspec->args[1];\r\nif (type == CP110_CLK_TYPE_CORE) {\r\nif (idx > CP110_MAX_CORE_CLOCKS)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn clk_data->hws[idx];\r\n} else if (type == CP110_CLK_TYPE_GATABLE) {\r\nif (idx > CP110_MAX_GATABLE_CLOCKS)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn clk_data->hws[CP110_MAX_CORE_CLOCKS + idx];\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic char *cp110_unique_name(struct device *dev, struct device_node *np,\r\nconst char *name)\r\n{\r\nconst __be32 *reg;\r\nu64 addr;\r\nif (!name)\r\nreturn NULL;\r\nreg = of_get_property(np, "reg", NULL);\r\naddr = of_translate_address(np, reg);\r\nreturn devm_kasprintf(dev, GFP_KERNEL, "%llx-%s",\r\n(unsigned long long)addr, name);\r\n}\r\nstatic int cp110_syscon_common_probe(struct platform_device *pdev,\r\nstruct device_node *syscon_node)\r\n{\r\nstruct regmap *regmap;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nconst char *ppv2_name, *apll_name, *core_name, *eip_name, *nand_name,\r\n*sdio_name;\r\nstruct clk_hw_onecell_data *cp110_clk_data;\r\nstruct clk_hw *hw, **cp110_clks;\r\nu32 nand_clk_ctrl;\r\nint i, ret;\r\nchar *gate_name[ARRAY_SIZE(gate_base_names)];\r\nregmap = syscon_node_to_regmap(syscon_node);\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nret = regmap_read(regmap, CP110_NAND_FLASH_CLK_CTRL_REG,\r\n&nand_clk_ctrl);\r\nif (ret)\r\nreturn ret;\r\ncp110_clk_data = devm_kzalloc(dev, sizeof(*cp110_clk_data) +\r\nsizeof(struct clk_hw *) * CP110_CLK_NUM,\r\nGFP_KERNEL);\r\nif (!cp110_clk_data)\r\nreturn -ENOMEM;\r\ncp110_clks = cp110_clk_data->hws;\r\ncp110_clk_data->num = CP110_CLK_NUM;\r\napll_name = cp110_unique_name(dev, syscon_node, "apll");\r\nhw = clk_hw_register_fixed_rate(NULL, apll_name, NULL, 0,\r\n1000 * 1000 * 1000);\r\nif (IS_ERR(hw)) {\r\nret = PTR_ERR(hw);\r\ngoto fail_apll;\r\n}\r\ncp110_clks[CP110_CORE_APLL] = hw;\r\nppv2_name = cp110_unique_name(dev, syscon_node, "ppv2-core");\r\nhw = clk_hw_register_fixed_factor(NULL, ppv2_name, apll_name, 0, 1, 3);\r\nif (IS_ERR(hw)) {\r\nret = PTR_ERR(hw);\r\ngoto fail_ppv2;\r\n}\r\ncp110_clks[CP110_CORE_PPV2] = hw;\r\neip_name = cp110_unique_name(dev, syscon_node, "eip");\r\nhw = clk_hw_register_fixed_factor(NULL, eip_name, apll_name, 0, 1, 2);\r\nif (IS_ERR(hw)) {\r\nret = PTR_ERR(hw);\r\ngoto fail_eip;\r\n}\r\ncp110_clks[CP110_CORE_EIP] = hw;\r\ncore_name = cp110_unique_name(dev, syscon_node, "core");\r\nhw = clk_hw_register_fixed_factor(NULL, core_name, eip_name, 0, 1, 2);\r\nif (IS_ERR(hw)) {\r\nret = PTR_ERR(hw);\r\ngoto fail_core;\r\n}\r\ncp110_clks[CP110_CORE_CORE] = hw;\r\nnand_name = cp110_unique_name(dev, syscon_node, "nand-core");\r\nif (nand_clk_ctrl & NF_CLOCK_SEL_400_MASK)\r\nhw = clk_hw_register_fixed_factor(NULL, nand_name,\r\napll_name, 0, 2, 5);\r\nelse\r\nhw = clk_hw_register_fixed_factor(NULL, nand_name,\r\ncore_name, 0, 1, 1);\r\nif (IS_ERR(hw)) {\r\nret = PTR_ERR(hw);\r\ngoto fail_nand;\r\n}\r\ncp110_clks[CP110_CORE_NAND] = hw;\r\nsdio_name = cp110_unique_name(dev, syscon_node, "sdio-core");\r\nhw = clk_hw_register_fixed_factor(NULL, sdio_name,\r\napll_name, 0, 2, 5);\r\nif (IS_ERR(hw)) {\r\nret = PTR_ERR(hw);\r\ngoto fail_sdio;\r\n}\r\ncp110_clks[CP110_CORE_SDIO] = hw;\r\nfor (i = 0; i < ARRAY_SIZE(gate_base_names); i++)\r\ngate_name[i] = cp110_unique_name(dev, syscon_node,\r\ngate_base_names[i]);\r\nfor (i = 0; i < ARRAY_SIZE(gate_base_names); i++) {\r\nconst char *parent;\r\nif (gate_name[i] == NULL)\r\ncontinue;\r\nswitch (i) {\r\ncase CP110_GATE_AUDIO:\r\ncase CP110_GATE_COMM_UNIT:\r\ncase CP110_GATE_EIP150:\r\ncase CP110_GATE_EIP197:\r\ncase CP110_GATE_SLOW_IO:\r\nparent = gate_name[CP110_GATE_MAIN];\r\nbreak;\r\ncase CP110_GATE_MG:\r\nparent = gate_name[CP110_GATE_MG_CORE];\r\nbreak;\r\ncase CP110_GATE_NAND:\r\nparent = nand_name;\r\nbreak;\r\ncase CP110_GATE_PPV2:\r\nparent = ppv2_name;\r\nbreak;\r\ncase CP110_GATE_SDIO:\r\nparent = sdio_name;\r\nbreak;\r\ncase CP110_GATE_GOP_DP:\r\nparent = gate_name[CP110_GATE_SDMMC_GOP];\r\nbreak;\r\ncase CP110_GATE_XOR1:\r\ncase CP110_GATE_XOR0:\r\ncase CP110_GATE_PCIE_X1_0:\r\ncase CP110_GATE_PCIE_X1_1:\r\ncase CP110_GATE_PCIE_X4:\r\nparent = gate_name[CP110_GATE_PCIE_XOR];\r\nbreak;\r\ncase CP110_GATE_SATA:\r\ncase CP110_GATE_USB3H0:\r\ncase CP110_GATE_USB3H1:\r\ncase CP110_GATE_USB3DEV:\r\nparent = gate_name[CP110_GATE_SATA_USB];\r\nbreak;\r\ndefault:\r\nparent = core_name;\r\nbreak;\r\n}\r\nhw = cp110_register_gate(gate_name[i], parent, regmap, i);\r\nif (IS_ERR(hw)) {\r\nret = PTR_ERR(hw);\r\ngoto fail_gate;\r\n}\r\ncp110_clks[CP110_MAX_CORE_CLOCKS + i] = hw;\r\n}\r\nret = of_clk_add_hw_provider(np, cp110_of_clk_get, cp110_clk_data);\r\nif (ret)\r\ngoto fail_clk_add;\r\nplatform_set_drvdata(pdev, cp110_clks);\r\nreturn 0;\r\nfail_clk_add:\r\nfail_gate:\r\nfor (i = 0; i < CP110_MAX_GATABLE_CLOCKS; i++) {\r\nhw = cp110_clks[CP110_MAX_CORE_CLOCKS + i];\r\nif (hw)\r\ncp110_unregister_gate(hw);\r\n}\r\nclk_hw_unregister_fixed_factor(cp110_clks[CP110_CORE_SDIO]);\r\nfail_sdio:\r\nclk_hw_unregister_fixed_factor(cp110_clks[CP110_CORE_NAND]);\r\nfail_nand:\r\nclk_hw_unregister_fixed_factor(cp110_clks[CP110_CORE_CORE]);\r\nfail_core:\r\nclk_hw_unregister_fixed_factor(cp110_clks[CP110_CORE_EIP]);\r\nfail_eip:\r\nclk_hw_unregister_fixed_factor(cp110_clks[CP110_CORE_PPV2]);\r\nfail_ppv2:\r\nclk_hw_unregister_fixed_rate(cp110_clks[CP110_CORE_APLL]);\r\nfail_apll:\r\nreturn ret;\r\n}\r\nstatic int cp110_syscon_legacy_clk_probe(struct platform_device *pdev)\r\n{\r\ndev_warn(&pdev->dev, FW_WARN "Using legacy device tree binding\n");\r\ndev_warn(&pdev->dev, FW_WARN "Update your device tree:\n");\r\ndev_warn(&pdev->dev, FW_WARN\r\n"This binding won't be supported in future kernels\n");\r\nreturn cp110_syscon_common_probe(pdev, pdev->dev.of_node);\r\n}\r\nstatic int cp110_clk_probe(struct platform_device *pdev)\r\n{\r\nreturn cp110_syscon_common_probe(pdev, pdev->dev.of_node->parent);\r\n}
