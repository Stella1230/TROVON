static bool cpcap_charger_battery_found(struct cpcap_charger_ddata *ddata)\r\n{\r\nstruct iio_channel *channel;\r\nint error, value;\r\nchannel = ddata->channels[CPCAP_CHARGER_IIO_BATTDET];\r\nerror = iio_read_channel_raw(channel, &value);\r\nif (error < 0) {\r\ndev_warn(ddata->dev, "%s failed: %i\n", __func__, error);\r\nreturn false;\r\n}\r\nreturn value == 1;\r\n}\r\nstatic int cpcap_charger_get_charge_voltage(struct cpcap_charger_ddata *ddata)\r\n{\r\nstruct iio_channel *channel;\r\nint error, value = 0;\r\nchannel = ddata->channels[CPCAP_CHARGER_IIO_VOLTAGE];\r\nerror = iio_read_channel_processed(channel, &value);\r\nif (error < 0) {\r\ndev_warn(ddata->dev, "%s failed: %i\n", __func__, error);\r\nreturn 0;\r\n}\r\nreturn value;\r\n}\r\nstatic int cpcap_charger_get_charge_current(struct cpcap_charger_ddata *ddata)\r\n{\r\nstruct iio_channel *channel;\r\nint error, value = 0;\r\nchannel = ddata->channels[CPCAP_CHARGER_IIO_CHRG_CURRENT];\r\nerror = iio_read_channel_processed(channel, &value);\r\nif (error < 0) {\r\ndev_warn(ddata->dev, "%s failed: %i\n", __func__, error);\r\nreturn 0;\r\n}\r\nreturn value;\r\n}\r\nstatic int cpcap_charger_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct cpcap_charger_ddata *ddata = dev_get_drvdata(psy->dev.parent);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nval->intval = ddata->status;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nif (ddata->status == POWER_SUPPLY_STATUS_CHARGING)\r\nval->intval = cpcap_charger_get_charge_voltage(ddata) *\r\n1000;\r\nelse\r\nval->intval = 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nif (ddata->status == POWER_SUPPLY_STATUS_CHARGING)\r\nval->intval = cpcap_charger_get_charge_current(ddata) *\r\n1000;\r\nelse\r\nval->intval = 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = ddata->status == POWER_SUPPLY_STATUS_CHARGING;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cpcap_charger_set_cable_path(struct cpcap_charger_ddata *ddata,\r\nbool enabled)\r\n{\r\nif (!ddata->gpio[0])\r\nreturn;\r\ngpiod_set_value(ddata->gpio[0], enabled);\r\n}\r\nstatic void cpcap_charger_set_inductive_path(struct cpcap_charger_ddata *ddata,\r\nbool enabled)\r\n{\r\nif (!ddata->gpio[1])\r\nreturn;\r\ngpiod_set_value(ddata->gpio[1], enabled);\r\n}\r\nstatic int cpcap_charger_set_state(struct cpcap_charger_ddata *ddata,\r\nint max_voltage, int charge_current,\r\nint trickle_current)\r\n{\r\nbool enable;\r\nint error;\r\nenable = (charge_current || trickle_current);\r\ndev_dbg(ddata->dev, "%s enable: %i\n", __func__, enable);\r\nif (!enable) {\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_CRM,\r\n0x3fff,\r\nCPCAP_REG_CRM_FET_OVRD |\r\nCPCAP_REG_CRM_FET_CTRL);\r\nif (error) {\r\nddata->status = POWER_SUPPLY_STATUS_UNKNOWN;\r\ngoto out_err;\r\n}\r\nddata->status = POWER_SUPPLY_STATUS_DISCHARGING;\r\nreturn 0;\r\n}\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_CRM, 0x3fff,\r\nCPCAP_REG_CRM_CHRG_LED_EN |\r\ntrickle_current |\r\nCPCAP_REG_CRM_FET_OVRD |\r\nCPCAP_REG_CRM_FET_CTRL |\r\nmax_voltage |\r\ncharge_current);\r\nif (error) {\r\nddata->status = POWER_SUPPLY_STATUS_UNKNOWN;\r\ngoto out_err;\r\n}\r\nddata->status = POWER_SUPPLY_STATUS_CHARGING;\r\nreturn 0;\r\nout_err:\r\ndev_err(ddata->dev, "%s failed with %i\n", __func__, error);\r\nreturn error;\r\n}\r\nstatic bool cpcap_charger_vbus_valid(struct cpcap_charger_ddata *ddata)\r\n{\r\nint error, value = 0;\r\nstruct iio_channel *channel =\r\nddata->channels[CPCAP_CHARGER_IIO_VBUS];\r\nerror = iio_read_channel_processed(channel, &value);\r\nif (error >= 0)\r\nreturn value > 3900 ? true : false;\r\ndev_err(ddata->dev, "error reading VBUS: %i\n", error);\r\nreturn false;\r\n}\r\nstatic void cpcap_charger_vbus_work(struct work_struct *work)\r\n{\r\nstruct cpcap_charger_ddata *ddata;\r\nbool vbus = false;\r\nint error;\r\nddata = container_of(work, struct cpcap_charger_ddata,\r\nvbus_work.work);\r\nif (ddata->vbus_enabled) {\r\nvbus = cpcap_charger_vbus_valid(ddata);\r\nif (vbus) {\r\ndev_info(ddata->dev, "VBUS already provided\n");\r\nreturn;\r\n}\r\ncpcap_charger_set_cable_path(ddata, false);\r\ncpcap_charger_set_inductive_path(ddata, false);\r\nerror = cpcap_charger_set_state(ddata, 0, 0, 0);\r\nif (error)\r\ngoto out_err;\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_CRM,\r\nCPCAP_REG_CRM_RVRSMODE,\r\nCPCAP_REG_CRM_RVRSMODE);\r\nif (error)\r\ngoto out_err;\r\n} else {\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_CRM,\r\nCPCAP_REG_CRM_RVRSMODE, 0);\r\nif (error)\r\ngoto out_err;\r\ncpcap_charger_set_cable_path(ddata, true);\r\ncpcap_charger_set_inductive_path(ddata, true);\r\n}\r\nreturn;\r\nout_err:\r\ndev_err(ddata->dev, "%s could not %s vbus: %i\n", __func__,\r\nddata->vbus_enabled ? "enable" : "disable", error);\r\n}\r\nstatic int cpcap_charger_set_vbus(struct phy_companion *comparator,\r\nbool enabled)\r\n{\r\nstruct cpcap_charger_ddata *ddata =\r\ncontainer_of(comparator, struct cpcap_charger_ddata,\r\ncomparator);\r\nddata->vbus_enabled = enabled;\r\nschedule_delayed_work(&ddata->vbus_work, 0);\r\nreturn 0;\r\n}\r\nstatic int cpcap_charger_get_ints_state(struct cpcap_charger_ddata *ddata,\r\nstruct cpcap_charger_ints_state *s)\r\n{\r\nint val, error;\r\nerror = regmap_read(ddata->reg, CPCAP_REG_INTS1, &val);\r\nif (error)\r\nreturn error;\r\ns->chrg_det = val & BIT(13);\r\ns->rvrs_chrg = val & BIT(12);\r\ns->vbusov = val & BIT(11);\r\nerror = regmap_read(ddata->reg, CPCAP_REG_INTS2, &val);\r\nif (error)\r\nreturn error;\r\ns->chrg_se1b = val & BIT(13);\r\ns->rvrs_mode = val & BIT(6);\r\ns->chrgcurr1 = val & BIT(4);\r\ns->vbusvld = val & BIT(3);\r\nerror = regmap_read(ddata->reg, CPCAP_REG_INTS4, &val);\r\nif (error)\r\nreturn error;\r\ns->battdetb = val & BIT(6);\r\nreturn 0;\r\n}\r\nstatic void cpcap_usb_detect(struct work_struct *work)\r\n{\r\nstruct cpcap_charger_ddata *ddata;\r\nstruct cpcap_charger_ints_state s;\r\nint error;\r\nddata = container_of(work, struct cpcap_charger_ddata,\r\ndetect_work.work);\r\nerror = cpcap_charger_get_ints_state(ddata, &s);\r\nif (error)\r\nreturn;\r\nif (cpcap_charger_vbus_valid(ddata) && s.chrgcurr1) {\r\nint max_current;\r\nif (cpcap_charger_battery_found(ddata))\r\nmax_current = CPCAP_REG_CRM_ICHRG_1A596;\r\nelse\r\nmax_current = CPCAP_REG_CRM_ICHRG_0A532;\r\nerror = cpcap_charger_set_state(ddata,\r\nCPCAP_REG_CRM_VCHRG_4V35,\r\nmax_current, 0);\r\nif (error)\r\ngoto out_err;\r\n} else {\r\nerror = cpcap_charger_set_state(ddata, 0, 0, 0);\r\nif (error)\r\ngoto out_err;\r\n}\r\nreturn;\r\nout_err:\r\ndev_err(ddata->dev, "%s failed with %i\n", __func__, error);\r\n}\r\nstatic irqreturn_t cpcap_charger_irq_thread(int irq, void *data)\r\n{\r\nstruct cpcap_charger_ddata *ddata = data;\r\nif (!atomic_read(&ddata->active))\r\nreturn IRQ_NONE;\r\nschedule_delayed_work(&ddata->detect_work, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cpcap_usb_init_irq(struct platform_device *pdev,\r\nstruct cpcap_charger_ddata *ddata,\r\nconst char *name)\r\n{\r\nstruct cpcap_interrupt_desc *d;\r\nint irq, error;\r\nirq = platform_get_irq_byname(pdev, name);\r\nif (!irq)\r\nreturn -ENODEV;\r\nerror = devm_request_threaded_irq(ddata->dev, irq, NULL,\r\ncpcap_charger_irq_thread,\r\nIRQF_SHARED,\r\nname, ddata);\r\nif (error) {\r\ndev_err(ddata->dev, "could not get irq %s: %i\n",\r\nname, error);\r\nreturn error;\r\n}\r\nd = devm_kzalloc(ddata->dev, sizeof(*d), GFP_KERNEL);\r\nif (!d)\r\nreturn -ENOMEM;\r\nd->name = name;\r\nd->irq = irq;\r\nlist_add(&d->node, &ddata->irq_list);\r\nreturn 0;\r\n}\r\nstatic int cpcap_usb_init_interrupts(struct platform_device *pdev,\r\nstruct cpcap_charger_ddata *ddata)\r\n{\r\nint i, error;\r\nfor (i = 0; i < ARRAY_SIZE(cpcap_charger_irqs); i++) {\r\nerror = cpcap_usb_init_irq(pdev, ddata, cpcap_charger_irqs[i]);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cpcap_charger_init_optional_gpios(struct cpcap_charger_ddata *ddata)\r\n{\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nddata->gpio[i] = devm_gpiod_get_index(ddata->dev, "mode",\r\ni, GPIOD_OUT_HIGH);\r\nif (IS_ERR(ddata->gpio[i])) {\r\ndev_info(ddata->dev, "no mode change GPIO%i: %li\n",\r\ni, PTR_ERR(ddata->gpio[i]));\r\nddata->gpio[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic int cpcap_charger_init_iio(struct cpcap_charger_ddata *ddata)\r\n{\r\nconst char * const names[CPCAP_CHARGER_IIO_NR] = {\r\n"battdetb", "battp", "vbus", "chg_isense", "batti",\r\n};\r\nint error, i;\r\nfor (i = 0; i < CPCAP_CHARGER_IIO_NR; i++) {\r\nddata->channels[i] = devm_iio_channel_get(ddata->dev,\r\nnames[i]);\r\nif (IS_ERR(ddata->channels[i])) {\r\nerror = PTR_ERR(ddata->channels[i]);\r\ngoto out_err;\r\n}\r\nif (!ddata->channels[i]->indio_dev) {\r\nerror = -ENXIO;\r\ngoto out_err;\r\n}\r\n}\r\nreturn 0;\r\nout_err:\r\ndev_err(ddata->dev, "could not initialize VBUS or ID IIO: %i\n",\r\nerror);\r\nreturn error;\r\n}\r\nstatic int cpcap_charger_probe(struct platform_device *pdev)\r\n{\r\nstruct cpcap_charger_ddata *ddata;\r\nconst struct of_device_id *of_id;\r\nstruct power_supply_config psy_cfg = {};\r\nint error;\r\nof_id = of_match_device(of_match_ptr(cpcap_charger_id_table),\r\n&pdev->dev);\r\nif (!of_id)\r\nreturn -EINVAL;\r\nddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\r\nif (!ddata)\r\nreturn -ENOMEM;\r\nddata->dev = &pdev->dev;\r\nddata->reg = dev_get_regmap(ddata->dev->parent, NULL);\r\nif (!ddata->reg)\r\nreturn -ENODEV;\r\nINIT_LIST_HEAD(&ddata->irq_list);\r\nINIT_DELAYED_WORK(&ddata->detect_work, cpcap_usb_detect);\r\nINIT_DELAYED_WORK(&ddata->vbus_work, cpcap_charger_vbus_work);\r\nplatform_set_drvdata(pdev, ddata);\r\nerror = cpcap_charger_init_iio(ddata);\r\nif (error)\r\nreturn error;\r\natomic_set(&ddata->active, 1);\r\npsy_cfg.of_node = pdev->dev.of_node;\r\npsy_cfg.drv_data = ddata;\r\nddata->usb = devm_power_supply_register(ddata->dev,\r\n&cpcap_charger_usb_desc,\r\n&psy_cfg);\r\nif (IS_ERR(ddata->usb)) {\r\nerror = PTR_ERR(ddata->usb);\r\ndev_err(ddata->dev, "failed to register USB charger: %i\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = cpcap_usb_init_interrupts(pdev, ddata);\r\nif (error)\r\nreturn error;\r\nddata->comparator.set_vbus = cpcap_charger_set_vbus;\r\nerror = omap_usb2_set_comparator(&ddata->comparator);\r\nif (error == -ENODEV) {\r\ndev_info(ddata->dev, "charger needs phy, deferring probe\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\ncpcap_charger_init_optional_gpios(ddata);\r\nschedule_delayed_work(&ddata->detect_work, 0);\r\nreturn 0;\r\n}\r\nstatic int cpcap_charger_remove(struct platform_device *pdev)\r\n{\r\nstruct cpcap_charger_ddata *ddata = platform_get_drvdata(pdev);\r\nint error;\r\natomic_set(&ddata->active, 0);\r\nerror = omap_usb2_set_comparator(NULL);\r\nif (error)\r\ndev_warn(ddata->dev, "could not clear USB comparator: %i\n",\r\nerror);\r\nerror = cpcap_charger_set_state(ddata, 0, 0, 0);\r\nif (error)\r\ndev_warn(ddata->dev, "could not clear charger: %i\n",\r\nerror);\r\ncancel_delayed_work_sync(&ddata->vbus_work);\r\ncancel_delayed_work_sync(&ddata->detect_work);\r\nreturn 0;\r\n}
