static void stm32_rtc_wpr_unlock(struct stm32_rtc *rtc)\r\n{\r\nwritel_relaxed(RTC_WPR_1ST_KEY, rtc->base + STM32_RTC_WPR);\r\nwritel_relaxed(RTC_WPR_2ND_KEY, rtc->base + STM32_RTC_WPR);\r\n}\r\nstatic void stm32_rtc_wpr_lock(struct stm32_rtc *rtc)\r\n{\r\nwritel_relaxed(RTC_WPR_WRONG_KEY, rtc->base + STM32_RTC_WPR);\r\n}\r\nstatic int stm32_rtc_enter_init_mode(struct stm32_rtc *rtc)\r\n{\r\nunsigned int isr = readl_relaxed(rtc->base + STM32_RTC_ISR);\r\nif (!(isr & STM32_RTC_ISR_INITF)) {\r\nisr |= STM32_RTC_ISR_INIT;\r\nwritel_relaxed(isr, rtc->base + STM32_RTC_ISR);\r\nreturn readl_relaxed_poll_timeout_atomic(\r\nrtc->base + STM32_RTC_ISR,\r\nisr, (isr & STM32_RTC_ISR_INITF),\r\n10, 100000);\r\n}\r\nreturn 0;\r\n}\r\nstatic void stm32_rtc_exit_init_mode(struct stm32_rtc *rtc)\r\n{\r\nunsigned int isr = readl_relaxed(rtc->base + STM32_RTC_ISR);\r\nisr &= ~STM32_RTC_ISR_INIT;\r\nwritel_relaxed(isr, rtc->base + STM32_RTC_ISR);\r\n}\r\nstatic int stm32_rtc_wait_sync(struct stm32_rtc *rtc)\r\n{\r\nunsigned int isr = readl_relaxed(rtc->base + STM32_RTC_ISR);\r\nisr &= ~STM32_RTC_ISR_RSF;\r\nwritel_relaxed(isr, rtc->base + STM32_RTC_ISR);\r\nreturn readl_relaxed_poll_timeout_atomic(rtc->base + STM32_RTC_ISR,\r\nisr,\r\n(isr & STM32_RTC_ISR_RSF),\r\n10, 100000);\r\n}\r\nstatic irqreturn_t stm32_rtc_alarm_irq(int irq, void *dev_id)\r\n{\r\nstruct stm32_rtc *rtc = (struct stm32_rtc *)dev_id;\r\nunsigned int isr, cr;\r\nmutex_lock(&rtc->rtc_dev->ops_lock);\r\nisr = readl_relaxed(rtc->base + STM32_RTC_ISR);\r\ncr = readl_relaxed(rtc->base + STM32_RTC_CR);\r\nif ((isr & STM32_RTC_ISR_ALRAF) &&\r\n(cr & STM32_RTC_CR_ALRAIE)) {\r\ndev_dbg(&rtc->rtc_dev->dev, "Alarm occurred\n");\r\nrtc_update_irq(rtc->rtc_dev, 1, RTC_IRQF | RTC_AF);\r\nwritel_relaxed(isr & ~STM32_RTC_ISR_ALRAF,\r\nrtc->base + STM32_RTC_ISR);\r\n}\r\nmutex_unlock(&rtc->rtc_dev->ops_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tm2bcd(struct rtc_time *tm)\r\n{\r\ntm->tm_sec = bin2bcd(tm->tm_sec);\r\ntm->tm_min = bin2bcd(tm->tm_min);\r\ntm->tm_hour = bin2bcd(tm->tm_hour);\r\ntm->tm_mday = bin2bcd(tm->tm_mday);\r\ntm->tm_mon = bin2bcd(tm->tm_mon + 1);\r\ntm->tm_year = bin2bcd(tm->tm_year - 100);\r\ntm->tm_wday = (!tm->tm_wday) ? 7 : tm->tm_wday;\r\n}\r\nstatic void bcd2tm(struct rtc_time *tm)\r\n{\r\ntm->tm_sec = bcd2bin(tm->tm_sec);\r\ntm->tm_min = bcd2bin(tm->tm_min);\r\ntm->tm_hour = bcd2bin(tm->tm_hour);\r\ntm->tm_mday = bcd2bin(tm->tm_mday);\r\ntm->tm_mon = bcd2bin(tm->tm_mon) - 1;\r\ntm->tm_year = bcd2bin(tm->tm_year) + 100;\r\ntm->tm_wday %= 7;\r\n}\r\nstatic int stm32_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct stm32_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned int tr, dr;\r\ntr = readl_relaxed(rtc->base + STM32_RTC_TR);\r\ndr = readl_relaxed(rtc->base + STM32_RTC_DR);\r\ntm->tm_sec = (tr & STM32_RTC_TR_SEC) >> STM32_RTC_TR_SEC_SHIFT;\r\ntm->tm_min = (tr & STM32_RTC_TR_MIN) >> STM32_RTC_TR_MIN_SHIFT;\r\ntm->tm_hour = (tr & STM32_RTC_TR_HOUR) >> STM32_RTC_TR_HOUR_SHIFT;\r\ntm->tm_mday = (dr & STM32_RTC_DR_DATE) >> STM32_RTC_DR_DATE_SHIFT;\r\ntm->tm_mon = (dr & STM32_RTC_DR_MONTH) >> STM32_RTC_DR_MONTH_SHIFT;\r\ntm->tm_year = (dr & STM32_RTC_DR_YEAR) >> STM32_RTC_DR_YEAR_SHIFT;\r\ntm->tm_wday = (dr & STM32_RTC_DR_WDAY) >> STM32_RTC_DR_WDAY_SHIFT;\r\nbcd2tm(tm);\r\nreturn 0;\r\n}\r\nstatic int stm32_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct stm32_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned int tr, dr;\r\nint ret = 0;\r\ntm2bcd(tm);\r\ntr = ((tm->tm_sec << STM32_RTC_TR_SEC_SHIFT) & STM32_RTC_TR_SEC) |\r\n((tm->tm_min << STM32_RTC_TR_MIN_SHIFT) & STM32_RTC_TR_MIN) |\r\n((tm->tm_hour << STM32_RTC_TR_HOUR_SHIFT) & STM32_RTC_TR_HOUR);\r\ndr = ((tm->tm_mday << STM32_RTC_DR_DATE_SHIFT) & STM32_RTC_DR_DATE) |\r\n((tm->tm_mon << STM32_RTC_DR_MONTH_SHIFT) & STM32_RTC_DR_MONTH) |\r\n((tm->tm_year << STM32_RTC_DR_YEAR_SHIFT) & STM32_RTC_DR_YEAR) |\r\n((tm->tm_wday << STM32_RTC_DR_WDAY_SHIFT) & STM32_RTC_DR_WDAY);\r\nstm32_rtc_wpr_unlock(rtc);\r\nret = stm32_rtc_enter_init_mode(rtc);\r\nif (ret) {\r\ndev_err(dev, "Can't enter in init mode. Set time aborted.\n");\r\ngoto end;\r\n}\r\nwritel_relaxed(tr, rtc->base + STM32_RTC_TR);\r\nwritel_relaxed(dr, rtc->base + STM32_RTC_DR);\r\nstm32_rtc_exit_init_mode(rtc);\r\nret = stm32_rtc_wait_sync(rtc);\r\nend:\r\nstm32_rtc_wpr_lock(rtc);\r\nreturn ret;\r\n}\r\nstatic int stm32_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct stm32_rtc *rtc = dev_get_drvdata(dev);\r\nstruct rtc_time *tm = &alrm->time;\r\nunsigned int alrmar, cr, isr;\r\nalrmar = readl_relaxed(rtc->base + STM32_RTC_ALRMAR);\r\ncr = readl_relaxed(rtc->base + STM32_RTC_CR);\r\nisr = readl_relaxed(rtc->base + STM32_RTC_ISR);\r\nif (alrmar & STM32_RTC_ALRMXR_DATE_MASK) {\r\ntm->tm_mday = -1;\r\ntm->tm_wday = -1;\r\n} else {\r\nif (alrmar & STM32_RTC_ALRMXR_WDSEL) {\r\ntm->tm_mday = -1;\r\ntm->tm_wday = (alrmar & STM32_RTC_ALRMXR_WDAY) >>\r\nSTM32_RTC_ALRMXR_WDAY_SHIFT;\r\ntm->tm_wday %= 7;\r\n} else {\r\ntm->tm_wday = -1;\r\ntm->tm_mday = (alrmar & STM32_RTC_ALRMXR_DATE) >>\r\nSTM32_RTC_ALRMXR_DATE_SHIFT;\r\n}\r\n}\r\nif (alrmar & STM32_RTC_ALRMXR_HOUR_MASK) {\r\ntm->tm_hour = -1;\r\n} else {\r\ntm->tm_hour = (alrmar & STM32_RTC_ALRMXR_HOUR) >>\r\nSTM32_RTC_ALRMXR_HOUR_SHIFT;\r\nif (alrmar & STM32_RTC_ALRMXR_PM)\r\ntm->tm_hour += 12;\r\n}\r\nif (alrmar & STM32_RTC_ALRMXR_MIN_MASK) {\r\ntm->tm_min = -1;\r\n} else {\r\ntm->tm_min = (alrmar & STM32_RTC_ALRMXR_MIN) >>\r\nSTM32_RTC_ALRMXR_MIN_SHIFT;\r\n}\r\nif (alrmar & STM32_RTC_ALRMXR_SEC_MASK) {\r\ntm->tm_sec = -1;\r\n} else {\r\ntm->tm_sec = (alrmar & STM32_RTC_ALRMXR_SEC) >>\r\nSTM32_RTC_ALRMXR_SEC_SHIFT;\r\n}\r\nbcd2tm(tm);\r\nalrm->enabled = (cr & STM32_RTC_CR_ALRAE) ? 1 : 0;\r\nalrm->pending = (isr & STM32_RTC_ISR_ALRAF) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int stm32_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct stm32_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned int isr, cr;\r\ncr = readl_relaxed(rtc->base + STM32_RTC_CR);\r\nstm32_rtc_wpr_unlock(rtc);\r\nif (enabled)\r\ncr |= (STM32_RTC_CR_ALRAIE | STM32_RTC_CR_ALRAE);\r\nelse\r\ncr &= ~(STM32_RTC_CR_ALRAIE | STM32_RTC_CR_ALRAE);\r\nwritel_relaxed(cr, rtc->base + STM32_RTC_CR);\r\nisr = readl_relaxed(rtc->base + STM32_RTC_ISR);\r\nisr &= ~STM32_RTC_ISR_ALRAF;\r\nwritel_relaxed(isr, rtc->base + STM32_RTC_ISR);\r\nstm32_rtc_wpr_lock(rtc);\r\nreturn 0;\r\n}\r\nstatic int stm32_rtc_valid_alrm(struct stm32_rtc *rtc, struct rtc_time *tm)\r\n{\r\nint cur_day, cur_mon, cur_year, cur_hour, cur_min, cur_sec;\r\nunsigned int dr = readl_relaxed(rtc->base + STM32_RTC_DR);\r\nunsigned int tr = readl_relaxed(rtc->base + STM32_RTC_TR);\r\ncur_day = (dr & STM32_RTC_DR_DATE) >> STM32_RTC_DR_DATE_SHIFT;\r\ncur_mon = (dr & STM32_RTC_DR_MONTH) >> STM32_RTC_DR_MONTH_SHIFT;\r\ncur_year = (dr & STM32_RTC_DR_YEAR) >> STM32_RTC_DR_YEAR_SHIFT;\r\ncur_sec = (tr & STM32_RTC_TR_SEC) >> STM32_RTC_TR_SEC_SHIFT;\r\ncur_min = (tr & STM32_RTC_TR_MIN) >> STM32_RTC_TR_MIN_SHIFT;\r\ncur_hour = (tr & STM32_RTC_TR_HOUR) >> STM32_RTC_TR_HOUR_SHIFT;\r\nif ((((tm->tm_year > cur_year) &&\r\n(tm->tm_mon == 0x1) && (cur_mon == 0x12)) ||\r\n((tm->tm_year == cur_year) &&\r\n(tm->tm_mon <= cur_mon + 1))) &&\r\n((tm->tm_mday > cur_day) ||\r\n((tm->tm_mday == cur_day) &&\r\n((tm->tm_hour > cur_hour) ||\r\n((tm->tm_hour == cur_hour) && (tm->tm_min > cur_min)) ||\r\n((tm->tm_hour == cur_hour) && (tm->tm_min == cur_min) &&\r\n(tm->tm_sec >= cur_sec))))))\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int stm32_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct stm32_rtc *rtc = dev_get_drvdata(dev);\r\nstruct rtc_time *tm = &alrm->time;\r\nunsigned int cr, isr, alrmar;\r\nint ret = 0;\r\ntm2bcd(tm);\r\nif (stm32_rtc_valid_alrm(rtc, tm) < 0) {\r\ndev_err(dev, "Alarm can be set only on upcoming month.\n");\r\nreturn -EINVAL;\r\n}\r\nalrmar = 0;\r\nalrmar |= (tm->tm_mday << STM32_RTC_ALRMXR_DATE_SHIFT) &\r\nSTM32_RTC_ALRMXR_DATE;\r\nalrmar &= ~STM32_RTC_ALRMXR_PM;\r\nalrmar |= (tm->tm_hour << STM32_RTC_ALRMXR_HOUR_SHIFT) &\r\nSTM32_RTC_ALRMXR_HOUR;\r\nalrmar |= (tm->tm_min << STM32_RTC_ALRMXR_MIN_SHIFT) &\r\nSTM32_RTC_ALRMXR_MIN;\r\nalrmar |= (tm->tm_sec << STM32_RTC_ALRMXR_SEC_SHIFT) &\r\nSTM32_RTC_ALRMXR_SEC;\r\nstm32_rtc_wpr_unlock(rtc);\r\ncr = readl_relaxed(rtc->base + STM32_RTC_CR);\r\ncr &= ~STM32_RTC_CR_ALRAE;\r\nwritel_relaxed(cr, rtc->base + STM32_RTC_CR);\r\nret = readl_relaxed_poll_timeout_atomic(rtc->base + STM32_RTC_ISR,\r\nisr,\r\n(isr & STM32_RTC_ISR_ALRAWF),\r\n10, 100000);\r\nif (ret) {\r\ndev_err(dev, "Alarm update not allowed\n");\r\ngoto end;\r\n}\r\nwritel_relaxed(alrmar, rtc->base + STM32_RTC_ALRMAR);\r\nif (alrm->enabled)\r\nstm32_rtc_alarm_irq_enable(dev, 1);\r\nelse\r\nstm32_rtc_alarm_irq_enable(dev, 0);\r\nend:\r\nstm32_rtc_wpr_lock(rtc);\r\nreturn ret;\r\n}\r\nstatic int stm32_rtc_init(struct platform_device *pdev,\r\nstruct stm32_rtc *rtc)\r\n{\r\nunsigned int prer, pred_a, pred_s, pred_a_max, pred_s_max, cr;\r\nunsigned int rate;\r\nint ret = 0;\r\nrate = clk_get_rate(rtc->rtc_ck);\r\npred_a_max = STM32_RTC_PRER_PRED_A >> STM32_RTC_PRER_PRED_A_SHIFT;\r\npred_s_max = STM32_RTC_PRER_PRED_S >> STM32_RTC_PRER_PRED_S_SHIFT;\r\nfor (pred_a = pred_a_max; pred_a + 1 > 0; pred_a--) {\r\npred_s = (rate / (pred_a + 1)) - 1;\r\nif (((pred_s + 1) * (pred_a + 1)) == rate)\r\nbreak;\r\n}\r\nif ((pred_s > pred_s_max) || (pred_a > pred_a_max)) {\r\npred_a = pred_a_max;\r\npred_s = (rate / (pred_a + 1)) - 1;\r\ndev_warn(&pdev->dev, "rtc_ck is %s\n",\r\n(rate < ((pred_a + 1) * (pred_s + 1))) ?\r\n"fast" : "slow");\r\n}\r\nstm32_rtc_wpr_unlock(rtc);\r\nret = stm32_rtc_enter_init_mode(rtc);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Can't enter in init mode. Prescaler config failed.\n");\r\ngoto end;\r\n}\r\nprer = (pred_s << STM32_RTC_PRER_PRED_S_SHIFT) & STM32_RTC_PRER_PRED_S;\r\nwritel_relaxed(prer, rtc->base + STM32_RTC_PRER);\r\nprer |= (pred_a << STM32_RTC_PRER_PRED_A_SHIFT) & STM32_RTC_PRER_PRED_A;\r\nwritel_relaxed(prer, rtc->base + STM32_RTC_PRER);\r\ncr = readl_relaxed(rtc->base + STM32_RTC_CR);\r\ncr &= ~STM32_RTC_CR_FMT;\r\nwritel_relaxed(cr, rtc->base + STM32_RTC_CR);\r\nstm32_rtc_exit_init_mode(rtc);\r\nret = stm32_rtc_wait_sync(rtc);\r\nend:\r\nstm32_rtc_wpr_lock(rtc);\r\nreturn ret;\r\n}\r\nstatic int stm32_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct stm32_rtc *rtc;\r\nstruct resource *res;\r\nconst struct of_device_id *match;\r\nint ret;\r\nrtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\r\nif (!rtc)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrtc->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(rtc->base))\r\nreturn PTR_ERR(rtc->base);\r\nrtc->dbp = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"st,syscfg");\r\nif (IS_ERR(rtc->dbp)) {\r\ndev_err(&pdev->dev, "no st,syscfg\n");\r\nreturn PTR_ERR(rtc->dbp);\r\n}\r\nmatch = of_match_device(stm32_rtc_of_match, &pdev->dev);\r\nrtc->data = (struct stm32_rtc_data *)match->data;\r\nif (!rtc->data->has_pclk) {\r\nrtc->pclk = NULL;\r\nrtc->rtc_ck = devm_clk_get(&pdev->dev, NULL);\r\n} else {\r\nrtc->pclk = devm_clk_get(&pdev->dev, "pclk");\r\nif (IS_ERR(rtc->pclk)) {\r\ndev_err(&pdev->dev, "no pclk clock");\r\nreturn PTR_ERR(rtc->pclk);\r\n}\r\nrtc->rtc_ck = devm_clk_get(&pdev->dev, "rtc_ck");\r\n}\r\nif (IS_ERR(rtc->rtc_ck)) {\r\ndev_err(&pdev->dev, "no rtc_ck clock");\r\nreturn PTR_ERR(rtc->rtc_ck);\r\n}\r\nif (rtc->data->has_pclk) {\r\nret = clk_prepare_enable(rtc->pclk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(rtc->rtc_ck);\r\nif (ret)\r\ngoto err;\r\nregmap_update_bits(rtc->dbp, PWR_CR, PWR_CR_DBP, PWR_CR_DBP);\r\nret = stm32_rtc_init(pdev, rtc);\r\nif (ret)\r\ngoto err;\r\nrtc->irq_alarm = platform_get_irq(pdev, 0);\r\nif (rtc->irq_alarm <= 0) {\r\ndev_err(&pdev->dev, "no alarm irq\n");\r\nret = rtc->irq_alarm;\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, rtc);\r\nret = device_init_wakeup(&pdev->dev, true);\r\nif (ret)\r\ndev_warn(&pdev->dev,\r\n"alarm won't be able to wake up the system");\r\nrtc->rtc_dev = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&stm32_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc->rtc_dev)) {\r\nret = PTR_ERR(rtc->rtc_dev);\r\ndev_err(&pdev->dev, "rtc device registration failed, err=%d\n",\r\nret);\r\ngoto err;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, rtc->irq_alarm, NULL,\r\nstm32_rtc_alarm_irq,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\npdev->name, rtc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "IRQ%d (alarm interrupt) already claimed\n",\r\nrtc->irq_alarm);\r\ngoto err;\r\n}\r\nif (!(readl_relaxed(rtc->base + STM32_RTC_ISR) & STM32_RTC_ISR_INITS))\r\ndev_warn(&pdev->dev, "Date/Time must be initialized\n");\r\nreturn 0;\r\nerr:\r\nif (rtc->data->has_pclk)\r\nclk_disable_unprepare(rtc->pclk);\r\nclk_disable_unprepare(rtc->rtc_ck);\r\nregmap_update_bits(rtc->dbp, PWR_CR, PWR_CR_DBP, 0);\r\ndevice_init_wakeup(&pdev->dev, false);\r\nreturn ret;\r\n}\r\nstatic int stm32_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct stm32_rtc *rtc = platform_get_drvdata(pdev);\r\nunsigned int cr;\r\nstm32_rtc_wpr_unlock(rtc);\r\ncr = readl_relaxed(rtc->base + STM32_RTC_CR);\r\ncr &= ~STM32_RTC_CR_ALRAIE;\r\nwritel_relaxed(cr, rtc->base + STM32_RTC_CR);\r\nstm32_rtc_wpr_lock(rtc);\r\nclk_disable_unprepare(rtc->rtc_ck);\r\nif (rtc->data->has_pclk)\r\nclk_disable_unprepare(rtc->pclk);\r\nregmap_update_bits(rtc->dbp, PWR_CR, PWR_CR_DBP, 0);\r\ndevice_init_wakeup(&pdev->dev, false);\r\nreturn 0;\r\n}\r\nstatic int stm32_rtc_suspend(struct device *dev)\r\n{\r\nstruct stm32_rtc *rtc = dev_get_drvdata(dev);\r\nif (rtc->data->has_pclk)\r\nclk_disable_unprepare(rtc->pclk);\r\nif (device_may_wakeup(dev))\r\nreturn enable_irq_wake(rtc->irq_alarm);\r\nreturn 0;\r\n}\r\nstatic int stm32_rtc_resume(struct device *dev)\r\n{\r\nstruct stm32_rtc *rtc = dev_get_drvdata(dev);\r\nint ret = 0;\r\nif (rtc->data->has_pclk) {\r\nret = clk_prepare_enable(rtc->pclk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = stm32_rtc_wait_sync(rtc);\r\nif (ret < 0)\r\nreturn ret;\r\nif (device_may_wakeup(dev))\r\nreturn disable_irq_wake(rtc->irq_alarm);\r\nreturn ret;\r\n}
