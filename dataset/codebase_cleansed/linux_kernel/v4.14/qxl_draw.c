static int alloc_clips(struct qxl_device *qdev,\r\nstruct qxl_release *release,\r\nunsigned num_clips,\r\nstruct qxl_bo **clips_bo)\r\n{\r\nint size = sizeof(struct qxl_clip_rects) + sizeof(struct qxl_rect) * num_clips;\r\nreturn qxl_alloc_bo_reserved(qdev, release, size, clips_bo);\r\n}\r\nstatic struct qxl_rect *drawable_set_clipping(struct qxl_device *qdev,\r\nunsigned num_clips,\r\nstruct qxl_bo *clips_bo)\r\n{\r\nstruct qxl_clip_rects *dev_clips;\r\nint ret;\r\nret = qxl_bo_kmap(clips_bo, (void **)&dev_clips);\r\nif (ret) {\r\nreturn NULL;\r\n}\r\ndev_clips->num_rects = num_clips;\r\ndev_clips->chunk.next_chunk = 0;\r\ndev_clips->chunk.prev_chunk = 0;\r\ndev_clips->chunk.data_size = sizeof(struct qxl_rect) * num_clips;\r\nreturn (struct qxl_rect *)dev_clips->chunk.data;\r\n}\r\nstatic int\r\nalloc_drawable(struct qxl_device *qdev, struct qxl_release **release)\r\n{\r\nreturn qxl_alloc_release_reserved(qdev, sizeof(struct qxl_drawable),\r\nQXL_RELEASE_DRAWABLE, release, NULL);\r\n}\r\nstatic void\r\nfree_drawable(struct qxl_device *qdev, struct qxl_release *release)\r\n{\r\nqxl_release_free(qdev, release);\r\n}\r\nstatic int\r\nmake_drawable(struct qxl_device *qdev, int surface, uint8_t type,\r\nconst struct qxl_rect *rect,\r\nstruct qxl_release *release)\r\n{\r\nstruct qxl_drawable *drawable;\r\nint i;\r\ndrawable = (struct qxl_drawable *)qxl_release_map(qdev, release);\r\nif (!drawable)\r\nreturn -ENOMEM;\r\ndrawable->type = type;\r\ndrawable->surface_id = surface;\r\ndrawable->effect = QXL_EFFECT_OPAQUE;\r\ndrawable->self_bitmap = 0;\r\ndrawable->self_bitmap_area.top = 0;\r\ndrawable->self_bitmap_area.left = 0;\r\ndrawable->self_bitmap_area.bottom = 0;\r\ndrawable->self_bitmap_area.right = 0;\r\ndrawable->clip.type = SPICE_CLIP_TYPE_NONE;\r\nfor (i = 0; i < 3; ++i)\r\ndrawable->surfaces_dest[i] = -1;\r\nif (rect)\r\ndrawable->bbox = *rect;\r\ndrawable->mm_time = qdev->rom->mm_clock;\r\nqxl_release_unmap(qdev, release, &drawable->release_info);\r\nreturn 0;\r\n}\r\nstatic int alloc_palette_object(struct qxl_device *qdev,\r\nstruct qxl_release *release,\r\nstruct qxl_bo **palette_bo)\r\n{\r\nreturn qxl_alloc_bo_reserved(qdev, release,\r\nsizeof(struct qxl_palette) + sizeof(uint32_t) * 2,\r\npalette_bo);\r\n}\r\nstatic int qxl_palette_create_1bit(struct qxl_bo *palette_bo,\r\nstruct qxl_release *release,\r\nconst struct qxl_fb_image *qxl_fb_image)\r\n{\r\nconst struct fb_image *fb_image = &qxl_fb_image->fb_image;\r\nuint32_t visual = qxl_fb_image->visual;\r\nconst uint32_t *pseudo_palette = qxl_fb_image->pseudo_palette;\r\nstruct qxl_palette *pal;\r\nint ret;\r\nuint32_t fgcolor, bgcolor;\r\nstatic uint64_t unique;\r\nret = qxl_bo_kmap(palette_bo, (void **)&pal);\r\nif (ret)\r\nreturn ret;\r\npal->num_ents = 2;\r\npal->unique = unique++;\r\nif (visual == FB_VISUAL_TRUECOLOR || visual == FB_VISUAL_DIRECTCOLOR) {\r\nfgcolor = pseudo_palette[fb_image->fg_color];\r\nbgcolor = pseudo_palette[fb_image->bg_color];\r\n} else {\r\nfgcolor = fb_image->fg_color;\r\nbgcolor = fb_image->bg_color;\r\n}\r\npal->ents[0] = bgcolor;\r\npal->ents[1] = fgcolor;\r\nqxl_bo_kunmap(palette_bo);\r\nreturn 0;\r\n}\r\nvoid qxl_draw_opaque_fb(const struct qxl_fb_image *qxl_fb_image,\r\nint stride )\r\n{\r\nstruct qxl_device *qdev = qxl_fb_image->qdev;\r\nstruct qxl_drawable *drawable;\r\nstruct qxl_rect rect;\r\nconst struct fb_image *fb_image = &qxl_fb_image->fb_image;\r\nint x = fb_image->dx;\r\nint y = fb_image->dy;\r\nint width = fb_image->width;\r\nint height = fb_image->height;\r\nconst char *src = fb_image->data;\r\nint depth = fb_image->depth;\r\nstruct qxl_release *release;\r\nstruct qxl_image *image;\r\nint ret;\r\nstruct qxl_drm_image *dimage;\r\nstruct qxl_bo *palette_bo = NULL;\r\nif (stride == 0)\r\nstride = depth * width / 8;\r\nret = alloc_drawable(qdev, &release);\r\nif (ret)\r\nreturn;\r\nret = qxl_image_alloc_objects(qdev, release,\r\n&dimage,\r\nheight, stride);\r\nif (ret)\r\ngoto out_free_drawable;\r\nif (depth == 1) {\r\nret = alloc_palette_object(qdev, release, &palette_bo);\r\nif (ret)\r\ngoto out_free_image;\r\n}\r\nret = qxl_release_reserve_list(release, true);\r\nif (ret)\r\ngoto out_free_palette;\r\nrect.left = x;\r\nrect.right = x + width;\r\nrect.top = y;\r\nrect.bottom = y + height;\r\nret = make_drawable(qdev, 0, QXL_DRAW_COPY, &rect, release);\r\nif (ret) {\r\nqxl_release_backoff_reserve_list(release);\r\ngoto out_free_palette;\r\n}\r\nret = qxl_image_init(qdev, release, dimage,\r\n(const uint8_t *)src, 0, 0,\r\nwidth, height, depth, stride);\r\nif (ret) {\r\nqxl_release_backoff_reserve_list(release);\r\nqxl_release_free(qdev, release);\r\nreturn;\r\n}\r\nif (depth == 1) {\r\nvoid *ptr;\r\nret = qxl_palette_create_1bit(palette_bo, release, qxl_fb_image);\r\nptr = qxl_bo_kmap_atomic_page(qdev, dimage->bo, 0);\r\nimage = ptr;\r\nimage->u.bitmap.palette =\r\nqxl_bo_physical_address(qdev, palette_bo, 0);\r\nqxl_bo_kunmap_atomic_page(qdev, dimage->bo, ptr);\r\n}\r\ndrawable = (struct qxl_drawable *)qxl_release_map(qdev, release);\r\ndrawable->u.copy.src_area.top = 0;\r\ndrawable->u.copy.src_area.bottom = height;\r\ndrawable->u.copy.src_area.left = 0;\r\ndrawable->u.copy.src_area.right = width;\r\ndrawable->u.copy.rop_descriptor = SPICE_ROPD_OP_PUT;\r\ndrawable->u.copy.scale_mode = 0;\r\ndrawable->u.copy.mask.flags = 0;\r\ndrawable->u.copy.mask.pos.x = 0;\r\ndrawable->u.copy.mask.pos.y = 0;\r\ndrawable->u.copy.mask.bitmap = 0;\r\ndrawable->u.copy.src_bitmap =\r\nqxl_bo_physical_address(qdev, dimage->bo, 0);\r\nqxl_release_unmap(qdev, release, &drawable->release_info);\r\nqxl_push_command_ring_release(qdev, release, QXL_CMD_DRAW, false);\r\nqxl_release_fence_buffer_objects(release);\r\nout_free_palette:\r\nif (palette_bo)\r\nqxl_bo_unref(&palette_bo);\r\nout_free_image:\r\nqxl_image_free_objects(qdev, dimage);\r\nout_free_drawable:\r\nif (ret)\r\nfree_drawable(qdev, release);\r\n}\r\nvoid qxl_draw_dirty_fb(struct qxl_device *qdev,\r\nstruct qxl_framebuffer *qxl_fb,\r\nstruct qxl_bo *bo,\r\nunsigned flags, unsigned color,\r\nstruct drm_clip_rect *clips,\r\nunsigned num_clips, int inc)\r\n{\r\nstruct drm_clip_rect *clips_ptr;\r\nint i;\r\nint left, right, top, bottom;\r\nint width, height;\r\nstruct qxl_drawable *drawable;\r\nstruct qxl_rect drawable_rect;\r\nstruct qxl_rect *rects;\r\nint stride = qxl_fb->base.pitches[0];\r\nint depth = qxl_fb->base.format->cpp[0] * 8;\r\nuint8_t *surface_base;\r\nstruct qxl_release *release;\r\nstruct qxl_bo *clips_bo;\r\nstruct qxl_drm_image *dimage;\r\nint ret;\r\nret = alloc_drawable(qdev, &release);\r\nif (ret)\r\nreturn;\r\nleft = clips->x1;\r\nright = clips->x2;\r\ntop = clips->y1;\r\nbottom = clips->y2;\r\nfor (i = 1, clips_ptr = clips + inc;\r\ni < num_clips; i++, clips_ptr += inc) {\r\nleft = min_t(int, left, (int)clips_ptr->x1);\r\nright = max_t(int, right, (int)clips_ptr->x2);\r\ntop = min_t(int, top, (int)clips_ptr->y1);\r\nbottom = max_t(int, bottom, (int)clips_ptr->y2);\r\n}\r\nwidth = right - left;\r\nheight = bottom - top;\r\nret = alloc_clips(qdev, release, num_clips, &clips_bo);\r\nif (ret)\r\ngoto out_free_drawable;\r\nret = qxl_image_alloc_objects(qdev, release,\r\n&dimage,\r\nheight, stride);\r\nif (ret)\r\ngoto out_free_clips;\r\nret = qxl_release_reserve_list(release, true);\r\nif (ret)\r\ngoto out_free_image;\r\ndrawable_rect.left = left;\r\ndrawable_rect.right = right;\r\ndrawable_rect.top = top;\r\ndrawable_rect.bottom = bottom;\r\nret = make_drawable(qdev, 0, QXL_DRAW_COPY, &drawable_rect,\r\nrelease);\r\nif (ret)\r\ngoto out_release_backoff;\r\nret = qxl_bo_kmap(bo, (void **)&surface_base);\r\nif (ret)\r\ngoto out_release_backoff;\r\nret = qxl_image_init(qdev, release, dimage, surface_base,\r\nleft, top, width, height, depth, stride);\r\nqxl_bo_kunmap(bo);\r\nif (ret)\r\ngoto out_release_backoff;\r\nrects = drawable_set_clipping(qdev, num_clips, clips_bo);\r\nif (!rects)\r\ngoto out_release_backoff;\r\ndrawable = (struct qxl_drawable *)qxl_release_map(qdev, release);\r\ndrawable->clip.type = SPICE_CLIP_TYPE_RECTS;\r\ndrawable->clip.data = qxl_bo_physical_address(qdev,\r\nclips_bo, 0);\r\ndrawable->u.copy.src_area.top = 0;\r\ndrawable->u.copy.src_area.bottom = height;\r\ndrawable->u.copy.src_area.left = 0;\r\ndrawable->u.copy.src_area.right = width;\r\ndrawable->u.copy.rop_descriptor = SPICE_ROPD_OP_PUT;\r\ndrawable->u.copy.scale_mode = 0;\r\ndrawable->u.copy.mask.flags = 0;\r\ndrawable->u.copy.mask.pos.x = 0;\r\ndrawable->u.copy.mask.pos.y = 0;\r\ndrawable->u.copy.mask.bitmap = 0;\r\ndrawable->u.copy.src_bitmap = qxl_bo_physical_address(qdev, dimage->bo, 0);\r\nqxl_release_unmap(qdev, release, &drawable->release_info);\r\nclips_ptr = clips;\r\nfor (i = 0; i < num_clips; i++, clips_ptr += inc) {\r\nrects[i].left = clips_ptr->x1;\r\nrects[i].right = clips_ptr->x2;\r\nrects[i].top = clips_ptr->y1;\r\nrects[i].bottom = clips_ptr->y2;\r\n}\r\nqxl_bo_kunmap(clips_bo);\r\nqxl_push_command_ring_release(qdev, release, QXL_CMD_DRAW, false);\r\nqxl_release_fence_buffer_objects(release);\r\nout_release_backoff:\r\nif (ret)\r\nqxl_release_backoff_reserve_list(release);\r\nout_free_image:\r\nqxl_image_free_objects(qdev, dimage);\r\nout_free_clips:\r\nqxl_bo_unref(&clips_bo);\r\nout_free_drawable:\r\nif (ret)\r\nfree_drawable(qdev, release);\r\n}\r\nvoid qxl_draw_copyarea(struct qxl_device *qdev,\r\nu32 width, u32 height,\r\nu32 sx, u32 sy,\r\nu32 dx, u32 dy)\r\n{\r\nstruct qxl_drawable *drawable;\r\nstruct qxl_rect rect;\r\nstruct qxl_release *release;\r\nint ret;\r\nret = alloc_drawable(qdev, &release);\r\nif (ret)\r\nreturn;\r\nret = qxl_release_reserve_list(release, true);\r\nif (ret)\r\ngoto out_free_release;\r\nrect.left = dx;\r\nrect.top = dy;\r\nrect.right = dx + width;\r\nrect.bottom = dy + height;\r\nret = make_drawable(qdev, 0, QXL_COPY_BITS, &rect, release);\r\nif (ret) {\r\nqxl_release_backoff_reserve_list(release);\r\ngoto out_free_release;\r\n}\r\ndrawable = (struct qxl_drawable *)qxl_release_map(qdev, release);\r\ndrawable->u.copy_bits.src_pos.x = sx;\r\ndrawable->u.copy_bits.src_pos.y = sy;\r\nqxl_release_unmap(qdev, release, &drawable->release_info);\r\nqxl_push_command_ring_release(qdev, release, QXL_CMD_DRAW, false);\r\nqxl_release_fence_buffer_objects(release);\r\nout_free_release:\r\nif (ret)\r\nfree_drawable(qdev, release);\r\n}\r\nvoid qxl_draw_fill(struct qxl_draw_fill *qxl_draw_fill_rec)\r\n{\r\nstruct qxl_device *qdev = qxl_draw_fill_rec->qdev;\r\nstruct qxl_rect rect = qxl_draw_fill_rec->rect;\r\nuint32_t color = qxl_draw_fill_rec->color;\r\nuint16_t rop = qxl_draw_fill_rec->rop;\r\nstruct qxl_drawable *drawable;\r\nstruct qxl_release *release;\r\nint ret;\r\nret = alloc_drawable(qdev, &release);\r\nif (ret)\r\nreturn;\r\nret = qxl_release_reserve_list(release, true);\r\nif (ret)\r\ngoto out_free_release;\r\nret = make_drawable(qdev, 0, QXL_DRAW_FILL, &rect, release);\r\nif (ret) {\r\nqxl_release_backoff_reserve_list(release);\r\ngoto out_free_release;\r\n}\r\ndrawable = (struct qxl_drawable *)qxl_release_map(qdev, release);\r\ndrawable->u.fill.brush.type = SPICE_BRUSH_TYPE_SOLID;\r\ndrawable->u.fill.brush.u.color = color;\r\ndrawable->u.fill.rop_descriptor = rop;\r\ndrawable->u.fill.mask.flags = 0;\r\ndrawable->u.fill.mask.pos.x = 0;\r\ndrawable->u.fill.mask.pos.y = 0;\r\ndrawable->u.fill.mask.bitmap = 0;\r\nqxl_release_unmap(qdev, release, &drawable->release_info);\r\nqxl_push_command_ring_release(qdev, release, QXL_CMD_DRAW, false);\r\nqxl_release_fence_buffer_objects(release);\r\nout_free_release:\r\nif (ret)\r\nfree_drawable(qdev, release);\r\n}
