static void sata_rcar_gen1_phy_preinit(struct sata_rcar_priv *priv)\r\n{\r\nvoid __iomem *base = priv->base;\r\niowrite32(0, base + SATAPHYADDR_REG);\r\niowrite32(SATAPHYRESET_PHYRST, base + SATAPHYRESET_REG);\r\nudelay(10);\r\niowrite32(0, base + SATAPHYRESET_REG);\r\n}\r\nstatic void sata_rcar_gen1_phy_write(struct sata_rcar_priv *priv, u16 reg,\r\nu32 val, int group)\r\n{\r\nvoid __iomem *base = priv->base;\r\nint timeout;\r\niowrite32(0, base + SATAPHYRESET_REG);\r\niowrite32(SATAPHYACCEN_PHYLANE, base + SATAPHYACCEN_REG);\r\niowrite32(val, base + SATAPHYWDATA_REG);\r\nif (group)\r\nreg |= SATAPHYADDR_PHYRATEMODE;\r\niowrite32(SATAPHYADDR_PHYCMD_WRITE | reg, base + SATAPHYADDR_REG);\r\nfor (timeout = 0; timeout < 100; timeout++) {\r\nval = ioread32(base + SATAPHYACK_REG);\r\nif (val & SATAPHYACK_PHYACK)\r\nbreak;\r\n}\r\nif (timeout >= 100)\r\npr_err("%s timeout\n", __func__);\r\niowrite32(0, base + SATAPHYADDR_REG);\r\n}\r\nstatic void sata_rcar_gen1_phy_init(struct sata_rcar_priv *priv)\r\n{\r\nsata_rcar_gen1_phy_preinit(priv);\r\nsata_rcar_gen1_phy_write(priv, SATAPCTLR1_REG, 0x00200188, 0);\r\nsata_rcar_gen1_phy_write(priv, SATAPCTLR1_REG, 0x00200188, 1);\r\nsata_rcar_gen1_phy_write(priv, SATAPCTLR3_REG, 0x0000A061, 0);\r\nsata_rcar_gen1_phy_write(priv, SATAPCTLR2_REG, 0x20000000, 0);\r\nsata_rcar_gen1_phy_write(priv, SATAPCTLR2_REG, 0x20000000, 1);\r\nsata_rcar_gen1_phy_write(priv, SATAPCTLR4_REG, 0x28E80000, 0);\r\n}\r\nstatic void sata_rcar_gen2_phy_init(struct sata_rcar_priv *priv)\r\n{\r\nvoid __iomem *base = priv->base;\r\niowrite32(RCAR_GEN2_PHY_CTL1, base + RCAR_GEN2_PHY_CTL1_REG);\r\niowrite32(RCAR_GEN2_PHY_CTL2, base + RCAR_GEN2_PHY_CTL2_REG);\r\niowrite32(RCAR_GEN2_PHY_CTL3, base + RCAR_GEN2_PHY_CTL3_REG);\r\niowrite32(RCAR_GEN2_PHY_CTL4, base + RCAR_GEN2_PHY_CTL4_REG);\r\niowrite32(RCAR_GEN2_PHY_CTL5 | RCAR_GEN2_PHY_CTL5_DC |\r\nRCAR_GEN2_PHY_CTL5_TR, base + RCAR_GEN2_PHY_CTL5_REG);\r\n}\r\nstatic void sata_rcar_freeze(struct ata_port *ap)\r\n{\r\nstruct sata_rcar_priv *priv = ap->host->private_data;\r\niowrite32(0x7ff, priv->base + SATAINTMASK_REG);\r\nata_sff_freeze(ap);\r\n}\r\nstatic void sata_rcar_thaw(struct ata_port *ap)\r\n{\r\nstruct sata_rcar_priv *priv = ap->host->private_data;\r\nvoid __iomem *base = priv->base;\r\niowrite32(~(u32)SATA_RCAR_INT_MASK, base + SATAINTSTAT_REG);\r\nata_sff_thaw(ap);\r\niowrite32(0x7ff & ~SATA_RCAR_INT_MASK, base + SATAINTMASK_REG);\r\n}\r\nstatic void sata_rcar_ioread16_rep(void __iomem *reg, void *buffer, int count)\r\n{\r\nu16 *ptr = buffer;\r\nwhile (count--) {\r\nu16 data = ioread32(reg);\r\n*ptr++ = data;\r\n}\r\n}\r\nstatic void sata_rcar_iowrite16_rep(void __iomem *reg, void *buffer, int count)\r\n{\r\nconst u16 *ptr = buffer;\r\nwhile (count--)\r\niowrite32(*ptr++, reg);\r\n}\r\nstatic u8 sata_rcar_check_status(struct ata_port *ap)\r\n{\r\nreturn ioread32(ap->ioaddr.status_addr);\r\n}\r\nstatic u8 sata_rcar_check_altstatus(struct ata_port *ap)\r\n{\r\nreturn ioread32(ap->ioaddr.altstatus_addr);\r\n}\r\nstatic void sata_rcar_set_devctl(struct ata_port *ap, u8 ctl)\r\n{\r\niowrite32(ctl, ap->ioaddr.ctl_addr);\r\n}\r\nstatic void sata_rcar_dev_select(struct ata_port *ap, unsigned int device)\r\n{\r\niowrite32(ATA_DEVICE_OBS, ap->ioaddr.device_addr);\r\nata_sff_pause(ap);\r\n}\r\nstatic unsigned int sata_rcar_ata_devchk(struct ata_port *ap,\r\nunsigned int device)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nu8 nsect, lbal;\r\nsata_rcar_dev_select(ap, device);\r\niowrite32(0x55, ioaddr->nsect_addr);\r\niowrite32(0xaa, ioaddr->lbal_addr);\r\niowrite32(0xaa, ioaddr->nsect_addr);\r\niowrite32(0x55, ioaddr->lbal_addr);\r\niowrite32(0x55, ioaddr->nsect_addr);\r\niowrite32(0xaa, ioaddr->lbal_addr);\r\nnsect = ioread32(ioaddr->nsect_addr);\r\nlbal = ioread32(ioaddr->lbal_addr);\r\nif (nsect == 0x55 && lbal == 0xaa)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int sata_rcar_wait_after_reset(struct ata_link *link,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nata_msleep(ap, ATA_WAIT_AFTER_RESET);\r\nreturn ata_sff_wait_ready(link, deadline);\r\n}\r\nstatic int sata_rcar_bus_softreset(struct ata_port *ap, unsigned long deadline)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nDPRINTK("ata%u: bus reset via SRST\n", ap->print_id);\r\niowrite32(ap->ctl, ioaddr->ctl_addr);\r\nudelay(20);\r\niowrite32(ap->ctl | ATA_SRST, ioaddr->ctl_addr);\r\nudelay(20);\r\niowrite32(ap->ctl, ioaddr->ctl_addr);\r\nap->last_ctl = ap->ctl;\r\nreturn sata_rcar_wait_after_reset(&ap->link, deadline);\r\n}\r\nstatic int sata_rcar_softreset(struct ata_link *link, unsigned int *classes,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nunsigned int devmask = 0;\r\nint rc;\r\nu8 err;\r\nif (sata_rcar_ata_devchk(ap, 0))\r\ndevmask |= 1 << 0;\r\nDPRINTK("about to softreset, devmask=%x\n", devmask);\r\nrc = sata_rcar_bus_softreset(ap, deadline);\r\nif (rc && (rc != -ENODEV || sata_scr_valid(link))) {\r\nata_link_err(link, "SRST failed (errno=%d)\n", rc);\r\nreturn rc;\r\n}\r\nclasses[0] = ata_sff_dev_classify(&link->device[0], devmask, &err);\r\nDPRINTK("classes[0]=%u\n", classes[0]);\r\nreturn 0;\r\n}\r\nstatic void sata_rcar_tf_load(struct ata_port *ap,\r\nconst struct ata_taskfile *tf)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nunsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;\r\nif (tf->ctl != ap->last_ctl) {\r\niowrite32(tf->ctl, ioaddr->ctl_addr);\r\nap->last_ctl = tf->ctl;\r\nata_wait_idle(ap);\r\n}\r\nif (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {\r\niowrite32(tf->hob_feature, ioaddr->feature_addr);\r\niowrite32(tf->hob_nsect, ioaddr->nsect_addr);\r\niowrite32(tf->hob_lbal, ioaddr->lbal_addr);\r\niowrite32(tf->hob_lbam, ioaddr->lbam_addr);\r\niowrite32(tf->hob_lbah, ioaddr->lbah_addr);\r\nVPRINTK("hob: feat 0x%X nsect 0x%X, lba 0x%X 0x%X 0x%X\n",\r\ntf->hob_feature,\r\ntf->hob_nsect,\r\ntf->hob_lbal,\r\ntf->hob_lbam,\r\ntf->hob_lbah);\r\n}\r\nif (is_addr) {\r\niowrite32(tf->feature, ioaddr->feature_addr);\r\niowrite32(tf->nsect, ioaddr->nsect_addr);\r\niowrite32(tf->lbal, ioaddr->lbal_addr);\r\niowrite32(tf->lbam, ioaddr->lbam_addr);\r\niowrite32(tf->lbah, ioaddr->lbah_addr);\r\nVPRINTK("feat 0x%X nsect 0x%X lba 0x%X 0x%X 0x%X\n",\r\ntf->feature,\r\ntf->nsect,\r\ntf->lbal,\r\ntf->lbam,\r\ntf->lbah);\r\n}\r\nif (tf->flags & ATA_TFLAG_DEVICE) {\r\niowrite32(tf->device, ioaddr->device_addr);\r\nVPRINTK("device 0x%X\n", tf->device);\r\n}\r\nata_wait_idle(ap);\r\n}\r\nstatic void sata_rcar_tf_read(struct ata_port *ap, struct ata_taskfile *tf)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\ntf->command = sata_rcar_check_status(ap);\r\ntf->feature = ioread32(ioaddr->error_addr);\r\ntf->nsect = ioread32(ioaddr->nsect_addr);\r\ntf->lbal = ioread32(ioaddr->lbal_addr);\r\ntf->lbam = ioread32(ioaddr->lbam_addr);\r\ntf->lbah = ioread32(ioaddr->lbah_addr);\r\ntf->device = ioread32(ioaddr->device_addr);\r\nif (tf->flags & ATA_TFLAG_LBA48) {\r\niowrite32(tf->ctl | ATA_HOB, ioaddr->ctl_addr);\r\ntf->hob_feature = ioread32(ioaddr->error_addr);\r\ntf->hob_nsect = ioread32(ioaddr->nsect_addr);\r\ntf->hob_lbal = ioread32(ioaddr->lbal_addr);\r\ntf->hob_lbam = ioread32(ioaddr->lbam_addr);\r\ntf->hob_lbah = ioread32(ioaddr->lbah_addr);\r\niowrite32(tf->ctl, ioaddr->ctl_addr);\r\nap->last_ctl = tf->ctl;\r\n}\r\n}\r\nstatic void sata_rcar_exec_command(struct ata_port *ap,\r\nconst struct ata_taskfile *tf)\r\n{\r\nDPRINTK("ata%u: cmd 0x%X\n", ap->print_id, tf->command);\r\niowrite32(tf->command, ap->ioaddr.command_addr);\r\nata_sff_pause(ap);\r\n}\r\nstatic unsigned int sata_rcar_data_xfer(struct ata_queued_cmd *qc,\r\nunsigned char *buf,\r\nunsigned int buflen, int rw)\r\n{\r\nstruct ata_port *ap = qc->dev->link->ap;\r\nvoid __iomem *data_addr = ap->ioaddr.data_addr;\r\nunsigned int words = buflen >> 1;\r\nif (rw == READ)\r\nsata_rcar_ioread16_rep(data_addr, buf, words);\r\nelse\r\nsata_rcar_iowrite16_rep(data_addr, buf, words);\r\nif (unlikely(buflen & 0x01)) {\r\nunsigned char pad[2] = { };\r\nbuf += buflen - 1;\r\nif (rw == READ) {\r\nsata_rcar_ioread16_rep(data_addr, pad, 1);\r\n*buf = pad[0];\r\n} else {\r\npad[0] = *buf;\r\nsata_rcar_iowrite16_rep(data_addr, pad, 1);\r\n}\r\nwords++;\r\n}\r\nreturn words << 1;\r\n}\r\nstatic void sata_rcar_drain_fifo(struct ata_queued_cmd *qc)\r\n{\r\nint count;\r\nstruct ata_port *ap;\r\nif (qc == NULL || qc->dma_dir == DMA_TO_DEVICE)\r\nreturn;\r\nap = qc->ap;\r\nfor (count = 0; (ap->ops->sff_check_status(ap) & ATA_DRQ) &&\r\ncount < 65536; count += 2)\r\nioread32(ap->ioaddr.data_addr);\r\nif (count)\r\nata_port_dbg(ap, "drained %d bytes to clear DRQ\n", count);\r\n}\r\nstatic int sata_rcar_scr_read(struct ata_link *link, unsigned int sc_reg,\r\nu32 *val)\r\n{\r\nif (sc_reg > SCR_ACTIVE)\r\nreturn -EINVAL;\r\n*val = ioread32(link->ap->ioaddr.scr_addr + (sc_reg << 2));\r\nreturn 0;\r\n}\r\nstatic int sata_rcar_scr_write(struct ata_link *link, unsigned int sc_reg,\r\nu32 val)\r\n{\r\nif (sc_reg > SCR_ACTIVE)\r\nreturn -EINVAL;\r\niowrite32(val, link->ap->ioaddr.scr_addr + (sc_reg << 2));\r\nreturn 0;\r\n}\r\nstatic void sata_rcar_bmdma_fill_sg(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ata_bmdma_prd *prd = ap->bmdma_prd;\r\nstruct scatterlist *sg;\r\nunsigned int si;\r\nfor_each_sg(qc->sg, sg, qc->n_elem, si) {\r\nu32 addr, sg_len;\r\naddr = (u32)sg_dma_address(sg);\r\nsg_len = sg_dma_len(sg);\r\nprd[si].addr = cpu_to_le32(addr);\r\nprd[si].flags_len = cpu_to_le32(sg_len);\r\nVPRINTK("PRD[%u] = (0x%X, 0x%X)\n", si, addr, sg_len);\r\n}\r\nprd[si - 1].addr |= cpu_to_le32(SATA_RCAR_DTEND);\r\n}\r\nstatic void sata_rcar_qc_prep(struct ata_queued_cmd *qc)\r\n{\r\nif (!(qc->flags & ATA_QCFLAG_DMAMAP))\r\nreturn;\r\nsata_rcar_bmdma_fill_sg(qc);\r\n}\r\nstatic void sata_rcar_bmdma_setup(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nunsigned int rw = qc->tf.flags & ATA_TFLAG_WRITE;\r\nstruct sata_rcar_priv *priv = ap->host->private_data;\r\nvoid __iomem *base = priv->base;\r\nu32 dmactl;\r\nmb();\r\niowrite32(ap->bmdma_prd_dma, base + ATAPI_DTB_ADR_REG);\r\ndmactl = ioread32(base + ATAPI_CONTROL1_REG);\r\ndmactl &= ~(ATAPI_CONTROL1_RW | ATAPI_CONTROL1_STOP);\r\nif (dmactl & ATAPI_CONTROL1_START) {\r\ndmactl &= ~ATAPI_CONTROL1_START;\r\ndmactl |= ATAPI_CONTROL1_STOP;\r\n}\r\nif (!rw)\r\ndmactl |= ATAPI_CONTROL1_RW;\r\niowrite32(dmactl, base + ATAPI_CONTROL1_REG);\r\nap->ops->sff_exec_command(ap, &qc->tf);\r\n}\r\nstatic void sata_rcar_bmdma_start(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct sata_rcar_priv *priv = ap->host->private_data;\r\nvoid __iomem *base = priv->base;\r\nu32 dmactl;\r\ndmactl = ioread32(base + ATAPI_CONTROL1_REG);\r\ndmactl &= ~ATAPI_CONTROL1_STOP;\r\ndmactl |= ATAPI_CONTROL1_START;\r\niowrite32(dmactl, base + ATAPI_CONTROL1_REG);\r\n}\r\nstatic void sata_rcar_bmdma_stop(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct sata_rcar_priv *priv = ap->host->private_data;\r\nvoid __iomem *base = priv->base;\r\nu32 dmactl;\r\ndmactl = ioread32(base + ATAPI_CONTROL1_REG);\r\nif (dmactl & ATAPI_CONTROL1_START) {\r\ndmactl &= ~ATAPI_CONTROL1_START;\r\ndmactl |= ATAPI_CONTROL1_STOP;\r\niowrite32(dmactl, base + ATAPI_CONTROL1_REG);\r\n}\r\nata_sff_dma_pause(ap);\r\n}\r\nstatic u8 sata_rcar_bmdma_status(struct ata_port *ap)\r\n{\r\nstruct sata_rcar_priv *priv = ap->host->private_data;\r\nu8 host_stat = 0;\r\nu32 status;\r\nstatus = ioread32(priv->base + ATAPI_STATUS_REG);\r\nif (status & ATAPI_STATUS_DEVINT)\r\nhost_stat |= ATA_DMA_INTR;\r\nif (status & ATAPI_STATUS_ACT)\r\nhost_stat |= ATA_DMA_ACTIVE;\r\nreturn host_stat;\r\n}\r\nstatic void sata_rcar_serr_interrupt(struct ata_port *ap)\r\n{\r\nstruct sata_rcar_priv *priv = ap->host->private_data;\r\nstruct ata_eh_info *ehi = &ap->link.eh_info;\r\nint freeze = 0;\r\nu32 serror;\r\nserror = ioread32(priv->base + SCRSERR_REG);\r\nif (!serror)\r\nreturn;\r\nDPRINTK("SError @host_intr: 0x%x\n", serror);\r\nata_ehi_clear_desc(ehi);\r\nif (serror & (SERR_DEV_XCHG | SERR_PHYRDY_CHG)) {\r\nata_ehi_hotplugged(ehi);\r\nata_ehi_push_desc(ehi, "%s", "hotplug");\r\nfreeze = serror & SERR_COMM_WAKE ? 0 : 1;\r\n}\r\nif (freeze)\r\nata_port_freeze(ap);\r\nelse\r\nata_port_abort(ap);\r\n}\r\nstatic void sata_rcar_ata_interrupt(struct ata_port *ap)\r\n{\r\nstruct ata_queued_cmd *qc;\r\nint handled = 0;\r\nqc = ata_qc_from_tag(ap, ap->link.active_tag);\r\nif (qc)\r\nhandled |= ata_bmdma_port_intr(ap, qc);\r\nif (!handled)\r\nsata_rcar_check_status(ap);\r\n}\r\nstatic irqreturn_t sata_rcar_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct ata_host *host = dev_instance;\r\nstruct sata_rcar_priv *priv = host->private_data;\r\nvoid __iomem *base = priv->base;\r\nunsigned int handled = 0;\r\nstruct ata_port *ap;\r\nu32 sataintstat;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nsataintstat = ioread32(base + SATAINTSTAT_REG);\r\nsataintstat &= SATA_RCAR_INT_MASK;\r\nif (!sataintstat)\r\ngoto done;\r\niowrite32(~sataintstat & 0x7ff, base + SATAINTSTAT_REG);\r\nap = host->ports[0];\r\nif (sataintstat & SATAINTSTAT_ATA)\r\nsata_rcar_ata_interrupt(ap);\r\nif (sataintstat & SATAINTSTAT_SERR)\r\nsata_rcar_serr_interrupt(ap);\r\nhandled = 1;\r\ndone:\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void sata_rcar_setup_port(struct ata_host *host)\r\n{\r\nstruct ata_port *ap = host->ports[0];\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nstruct sata_rcar_priv *priv = host->private_data;\r\nvoid __iomem *base = priv->base;\r\nap->ops = &sata_rcar_port_ops;\r\nap->pio_mask = ATA_PIO4;\r\nap->udma_mask = ATA_UDMA6;\r\nap->flags |= ATA_FLAG_SATA;\r\nif (priv->type == RCAR_R8A7790_ES1_SATA)\r\nap->flags |= ATA_FLAG_NO_DIPM;\r\nioaddr->cmd_addr = base + SDATA_REG;\r\nioaddr->ctl_addr = base + SSDEVCON_REG;\r\nioaddr->scr_addr = base + SCRSSTS_REG;\r\nioaddr->altstatus_addr = ioaddr->ctl_addr;\r\nioaddr->data_addr = ioaddr->cmd_addr + (ATA_REG_DATA << 2);\r\nioaddr->error_addr = ioaddr->cmd_addr + (ATA_REG_ERR << 2);\r\nioaddr->feature_addr = ioaddr->cmd_addr + (ATA_REG_FEATURE << 2);\r\nioaddr->nsect_addr = ioaddr->cmd_addr + (ATA_REG_NSECT << 2);\r\nioaddr->lbal_addr = ioaddr->cmd_addr + (ATA_REG_LBAL << 2);\r\nioaddr->lbam_addr = ioaddr->cmd_addr + (ATA_REG_LBAM << 2);\r\nioaddr->lbah_addr = ioaddr->cmd_addr + (ATA_REG_LBAH << 2);\r\nioaddr->device_addr = ioaddr->cmd_addr + (ATA_REG_DEVICE << 2);\r\nioaddr->status_addr = ioaddr->cmd_addr + (ATA_REG_STATUS << 2);\r\nioaddr->command_addr = ioaddr->cmd_addr + (ATA_REG_CMD << 2);\r\n}\r\nstatic void sata_rcar_init_controller(struct ata_host *host)\r\n{\r\nstruct sata_rcar_priv *priv = host->private_data;\r\nvoid __iomem *base = priv->base;\r\nu32 val;\r\nswitch (priv->type) {\r\ncase RCAR_GEN1_SATA:\r\nsata_rcar_gen1_phy_init(priv);\r\nbreak;\r\ncase RCAR_GEN2_SATA:\r\ncase RCAR_R8A7790_ES1_SATA:\r\nsata_rcar_gen2_phy_init(priv);\r\nbreak;\r\ndefault:\r\ndev_warn(host->dev, "SATA phy is not initialized\n");\r\nbreak;\r\n}\r\nval = ioread32(base + ATAPI_CONTROL1_REG);\r\nval |= ATAPI_CONTROL1_RESET;\r\niowrite32(val, base + ATAPI_CONTROL1_REG);\r\nval = ioread32(base + ATAPI_CONTROL1_REG);\r\nval |= ATAPI_CONTROL1_ISM;\r\nval |= ATAPI_CONTROL1_DESE;\r\nval |= ATAPI_CONTROL1_DTA32M;\r\niowrite32(val, base + ATAPI_CONTROL1_REG);\r\nval = ioread32(base + ATAPI_CONTROL1_REG);\r\nval &= ~ATAPI_CONTROL1_RESET;\r\niowrite32(val, base + ATAPI_CONTROL1_REG);\r\niowrite32(0, base + SATAINTSTAT_REG);\r\niowrite32(0x7ff, base + SATAINTMASK_REG);\r\niowrite32(ATAPI_INT_ENABLE_SATAINT, base + ATAPI_INT_ENABLE_REG);\r\n}\r\nstatic int sata_rcar_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id;\r\nstruct ata_host *host;\r\nstruct sata_rcar_priv *priv;\r\nstruct resource *mem;\r\nint irq;\r\nint ret = 0;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0)\r\nreturn -EINVAL;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(struct sata_rcar_priv),\r\nGFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nof_id = of_match_device(sata_rcar_match, &pdev->dev);\r\nif (!of_id)\r\nreturn -ENODEV;\r\npriv->type = (enum sata_rcar_type)of_id->data;\r\npriv->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(&pdev->dev, "failed to get access to sata clock\n");\r\nreturn PTR_ERR(priv->clk);\r\n}\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret)\r\nreturn ret;\r\nhost = ata_host_alloc(&pdev->dev, 1);\r\nif (!host) {\r\ndev_err(&pdev->dev, "ata_host_alloc failed\n");\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nhost->private_data = priv;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(priv->base)) {\r\nret = PTR_ERR(priv->base);\r\ngoto cleanup;\r\n}\r\nsata_rcar_setup_port(host);\r\nsata_rcar_init_controller(host);\r\nret = ata_host_activate(host, irq, sata_rcar_interrupt, 0,\r\n&sata_rcar_sht);\r\nif (!ret)\r\nreturn 0;\r\ncleanup:\r\nclk_disable_unprepare(priv->clk);\r\nreturn ret;\r\n}\r\nstatic int sata_rcar_remove(struct platform_device *pdev)\r\n{\r\nstruct ata_host *host = platform_get_drvdata(pdev);\r\nstruct sata_rcar_priv *priv = host->private_data;\r\nvoid __iomem *base = priv->base;\r\nata_host_detach(host);\r\niowrite32(0, base + ATAPI_INT_ENABLE_REG);\r\niowrite32(0, base + SATAINTSTAT_REG);\r\niowrite32(0x7ff, base + SATAINTMASK_REG);\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}\r\nstatic int sata_rcar_suspend(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct sata_rcar_priv *priv = host->private_data;\r\nvoid __iomem *base = priv->base;\r\nint ret;\r\nret = ata_host_suspend(host, PMSG_SUSPEND);\r\nif (!ret) {\r\niowrite32(0, base + ATAPI_INT_ENABLE_REG);\r\niowrite32(0x7ff, base + SATAINTMASK_REG);\r\nclk_disable_unprepare(priv->clk);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sata_rcar_resume(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct sata_rcar_priv *priv = host->private_data;\r\nvoid __iomem *base = priv->base;\r\nint ret;\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret)\r\nreturn ret;\r\niowrite32(0, base + SATAINTSTAT_REG);\r\niowrite32(0x7ff, base + SATAINTMASK_REG);\r\niowrite32(ATAPI_INT_ENABLE_SATAINT, base + ATAPI_INT_ENABLE_REG);\r\nata_host_resume(host);\r\nreturn 0;\r\n}\r\nstatic int sata_rcar_restore(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct sata_rcar_priv *priv = host->private_data;\r\nint ret;\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret)\r\nreturn ret;\r\nsata_rcar_setup_port(host);\r\nsata_rcar_init_controller(host);\r\nata_host_resume(host);\r\nreturn 0;\r\n}
