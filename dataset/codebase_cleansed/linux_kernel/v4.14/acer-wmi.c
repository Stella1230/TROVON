static void __init set_quirks(void)\r\n{\r\nif (!interface)\r\nreturn;\r\nif (quirks->mailled)\r\ninterface->capability |= ACER_CAP_MAILLED;\r\nif (quirks->brightness)\r\ninterface->capability |= ACER_CAP_BRIGHTNESS;\r\n}\r\nstatic int __init dmi_matched(const struct dmi_system_id *dmi)\r\n{\r\nquirks = dmi->driver_data;\r\nreturn 1;\r\n}\r\nstatic int __init\r\nvideo_set_backlight_video_vendor(const struct dmi_system_id *d)\r\n{\r\ninterface->capability &= ~ACER_CAP_BRIGHTNESS;\r\npr_info("Brightness must be controlled by generic video driver\n");\r\nreturn 0;\r\n}\r\nstatic void __init find_quirks(void)\r\n{\r\nif (!force_series) {\r\ndmi_check_system(acer_quirks);\r\ndmi_check_system(non_acer_quirks);\r\n} else if (force_series == 2490) {\r\nquirks = &quirk_acer_travelmate_2490;\r\n}\r\nif (quirks == NULL)\r\nquirks = &quirk_unknown;\r\nset_quirks();\r\n}\r\nstatic bool has_cap(u32 cap)\r\n{\r\nif ((interface->capability & cap) != 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic acpi_status wmab_execute(struct wmab_args *regbuf,\r\nstruct acpi_buffer *result)\r\n{\r\nstruct acpi_buffer input;\r\nacpi_status status;\r\ninput.length = sizeof(struct wmab_args);\r\ninput.pointer = (u8 *)regbuf;\r\nstatus = wmi_evaluate_method(AMW0_GUID1, 0, 1, &input, result);\r\nreturn status;\r\n}\r\nstatic acpi_status AMW0_get_u32(u32 *value, u32 cap)\r\n{\r\nint err;\r\nu8 result;\r\nswitch (cap) {\r\ncase ACER_CAP_MAILLED:\r\nswitch (quirks->mailled) {\r\ndefault:\r\nerr = ec_read(0xA, &result);\r\nif (err)\r\nreturn AE_ERROR;\r\n*value = (result >> 7) & 0x1;\r\nreturn AE_OK;\r\n}\r\nbreak;\r\ncase ACER_CAP_WIRELESS:\r\nswitch (quirks->wireless) {\r\ncase 1:\r\nerr = ec_read(0x7B, &result);\r\nif (err)\r\nreturn AE_ERROR;\r\n*value = result & 0x1;\r\nreturn AE_OK;\r\ncase 2:\r\nerr = ec_read(0x71, &result);\r\nif (err)\r\nreturn AE_ERROR;\r\n*value = result & 0x1;\r\nreturn AE_OK;\r\ncase 3:\r\nerr = ec_read(0x78, &result);\r\nif (err)\r\nreturn AE_ERROR;\r\n*value = result & 0x1;\r\nreturn AE_OK;\r\ndefault:\r\nerr = ec_read(0xA, &result);\r\nif (err)\r\nreturn AE_ERROR;\r\n*value = (result >> 2) & 0x1;\r\nreturn AE_OK;\r\n}\r\nbreak;\r\ncase ACER_CAP_BLUETOOTH:\r\nswitch (quirks->bluetooth) {\r\ndefault:\r\nerr = ec_read(0xA, &result);\r\nif (err)\r\nreturn AE_ERROR;\r\n*value = (result >> 4) & 0x1;\r\nreturn AE_OK;\r\n}\r\nbreak;\r\ncase ACER_CAP_BRIGHTNESS:\r\nswitch (quirks->brightness) {\r\ndefault:\r\nerr = ec_read(0x83, &result);\r\nif (err)\r\nreturn AE_ERROR;\r\n*value = result;\r\nreturn AE_OK;\r\n}\r\nbreak;\r\ndefault:\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status AMW0_set_u32(u32 value, u32 cap)\r\n{\r\nstruct wmab_args args;\r\nargs.eax = ACER_AMW0_WRITE;\r\nargs.ebx = value ? (1<<8) : 0;\r\nargs.ecx = args.edx = 0;\r\nswitch (cap) {\r\ncase ACER_CAP_MAILLED:\r\nif (value > 1)\r\nreturn AE_BAD_PARAMETER;\r\nargs.ebx |= ACER_AMW0_MAILLED_MASK;\r\nbreak;\r\ncase ACER_CAP_WIRELESS:\r\nif (value > 1)\r\nreturn AE_BAD_PARAMETER;\r\nargs.ebx |= ACER_AMW0_WIRELESS_MASK;\r\nbreak;\r\ncase ACER_CAP_BLUETOOTH:\r\nif (value > 1)\r\nreturn AE_BAD_PARAMETER;\r\nargs.ebx |= ACER_AMW0_BLUETOOTH_MASK;\r\nbreak;\r\ncase ACER_CAP_BRIGHTNESS:\r\nif (value > max_brightness)\r\nreturn AE_BAD_PARAMETER;\r\nswitch (quirks->brightness) {\r\ndefault:\r\nreturn ec_write(0x83, value);\r\nbreak;\r\n}\r\ndefault:\r\nreturn AE_ERROR;\r\n}\r\nreturn wmab_execute(&args, NULL);\r\n}\r\nstatic acpi_status __init AMW0_find_mailled(void)\r\n{\r\nstruct wmab_args args;\r\nstruct wmab_ret ret;\r\nacpi_status status = AE_OK;\r\nstruct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nargs.eax = 0x86;\r\nargs.ebx = args.ecx = args.edx = 0;\r\nstatus = wmab_execute(&args, &out);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nobj = (union acpi_object *) out.pointer;\r\nif (obj && obj->type == ACPI_TYPE_BUFFER &&\r\nobj->buffer.length == sizeof(struct wmab_ret)) {\r\nret = *((struct wmab_ret *) obj->buffer.pointer);\r\n} else {\r\nkfree(out.pointer);\r\nreturn AE_ERROR;\r\n}\r\nif (ret.eex & 0x1)\r\ninterface->capability |= ACER_CAP_MAILLED;\r\nkfree(out.pointer);\r\nreturn AE_OK;\r\n}\r\nstatic int __init AMW0_set_cap_acpi_check_device(void)\r\n{\r\nconst struct acpi_device_id *id;\r\nfor (id = norfkill_ids; id->id[0]; id++)\r\nif (acpi_dev_found(id->id))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic acpi_status __init AMW0_set_capabilities(void)\r\n{\r\nstruct wmab_args args;\r\nstruct wmab_ret ret;\r\nacpi_status status;\r\nstruct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nif (wmi_has_guid(AMW0_GUID2)) {\r\nif ((quirks != &quirk_unknown) ||\r\n!AMW0_set_cap_acpi_check_device())\r\ninterface->capability |= ACER_CAP_WIRELESS;\r\nreturn AE_OK;\r\n}\r\nargs.eax = ACER_AMW0_WRITE;\r\nargs.ecx = args.edx = 0;\r\nargs.ebx = 0xa2 << 8;\r\nargs.ebx |= ACER_AMW0_WIRELESS_MASK;\r\nstatus = wmab_execute(&args, &out);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nobj = out.pointer;\r\nif (obj && obj->type == ACPI_TYPE_BUFFER &&\r\nobj->buffer.length == sizeof(struct wmab_ret)) {\r\nret = *((struct wmab_ret *) obj->buffer.pointer);\r\n} else {\r\nstatus = AE_ERROR;\r\ngoto out;\r\n}\r\nif (ret.eax & 0x1)\r\ninterface->capability |= ACER_CAP_WIRELESS;\r\nargs.ebx = 2 << 8;\r\nargs.ebx |= ACER_AMW0_BLUETOOTH_MASK;\r\nstatus = wmab_execute(&args, &out);\r\nif (ACPI_FAILURE(status))\r\ngoto out;\r\nobj = (union acpi_object *) out.pointer;\r\nif (obj && obj->type == ACPI_TYPE_BUFFER\r\n&& obj->buffer.length == sizeof(struct wmab_ret)) {\r\nret = *((struct wmab_ret *) obj->buffer.pointer);\r\n} else {\r\nstatus = AE_ERROR;\r\ngoto out;\r\n}\r\nif (ret.eax & 0x1)\r\ninterface->capability |= ACER_CAP_BLUETOOTH;\r\nif (quirks->brightness >= 0)\r\ninterface->capability |= ACER_CAP_BRIGHTNESS;\r\nstatus = AE_OK;\r\nout:\r\nkfree(out.pointer);\r\nreturn status;\r\n}\r\nstatic acpi_status\r\nWMI_execute_u32(u32 method_id, u32 in, u32 *out)\r\n{\r\nstruct acpi_buffer input = { (acpi_size) sizeof(u32), (void *)(&in) };\r\nstruct acpi_buffer result = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nu32 tmp = 0;\r\nacpi_status status;\r\nstatus = wmi_evaluate_method(WMID_GUID1, 0, method_id, &input, &result);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nobj = (union acpi_object *) result.pointer;\r\nif (obj) {\r\nif (obj->type == ACPI_TYPE_BUFFER &&\r\n(obj->buffer.length == sizeof(u32) ||\r\nobj->buffer.length == sizeof(u64))) {\r\ntmp = *((u32 *) obj->buffer.pointer);\r\n} else if (obj->type == ACPI_TYPE_INTEGER) {\r\ntmp = (u32) obj->integer.value;\r\n}\r\n}\r\nif (out)\r\n*out = tmp;\r\nkfree(result.pointer);\r\nreturn status;\r\n}\r\nstatic acpi_status WMID_get_u32(u32 *value, u32 cap)\r\n{\r\nacpi_status status;\r\nu8 tmp;\r\nu32 result, method_id = 0;\r\nswitch (cap) {\r\ncase ACER_CAP_WIRELESS:\r\nmethod_id = ACER_WMID_GET_WIRELESS_METHODID;\r\nbreak;\r\ncase ACER_CAP_BLUETOOTH:\r\nmethod_id = ACER_WMID_GET_BLUETOOTH_METHODID;\r\nbreak;\r\ncase ACER_CAP_BRIGHTNESS:\r\nmethod_id = ACER_WMID_GET_BRIGHTNESS_METHODID;\r\nbreak;\r\ncase ACER_CAP_THREEG:\r\nmethod_id = ACER_WMID_GET_THREEG_METHODID;\r\nbreak;\r\ncase ACER_CAP_MAILLED:\r\nif (quirks->mailled == 1) {\r\nec_read(0x9f, &tmp);\r\n*value = tmp & 0x1;\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn AE_ERROR;\r\n}\r\nstatus = WMI_execute_u32(method_id, 0, &result);\r\nif (ACPI_SUCCESS(status))\r\n*value = (u8)result;\r\nreturn status;\r\n}\r\nstatic acpi_status WMID_set_u32(u32 value, u32 cap)\r\n{\r\nu32 method_id = 0;\r\nchar param;\r\nswitch (cap) {\r\ncase ACER_CAP_BRIGHTNESS:\r\nif (value > max_brightness)\r\nreturn AE_BAD_PARAMETER;\r\nmethod_id = ACER_WMID_SET_BRIGHTNESS_METHODID;\r\nbreak;\r\ncase ACER_CAP_WIRELESS:\r\nif (value > 1)\r\nreturn AE_BAD_PARAMETER;\r\nmethod_id = ACER_WMID_SET_WIRELESS_METHODID;\r\nbreak;\r\ncase ACER_CAP_BLUETOOTH:\r\nif (value > 1)\r\nreturn AE_BAD_PARAMETER;\r\nmethod_id = ACER_WMID_SET_BLUETOOTH_METHODID;\r\nbreak;\r\ncase ACER_CAP_THREEG:\r\nif (value > 1)\r\nreturn AE_BAD_PARAMETER;\r\nmethod_id = ACER_WMID_SET_THREEG_METHODID;\r\nbreak;\r\ncase ACER_CAP_MAILLED:\r\nif (value > 1)\r\nreturn AE_BAD_PARAMETER;\r\nif (quirks->mailled == 1) {\r\nparam = value ? 0x92 : 0x93;\r\ni8042_lock_chip();\r\ni8042_command(&param, 0x1059);\r\ni8042_unlock_chip();\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nreturn AE_ERROR;\r\n}\r\nreturn WMI_execute_u32(method_id, (u32)value, NULL);\r\n}\r\nstatic acpi_status wmid3_get_device_status(u32 *value, u16 device)\r\n{\r\nstruct wmid3_gds_return_value return_value;\r\nacpi_status status;\r\nunion acpi_object *obj;\r\nstruct wmid3_gds_get_input_param params = {\r\n.function_num = 0x1,\r\n.hotkey_number = commun_fn_key_number,\r\n.devices = device,\r\n};\r\nstruct acpi_buffer input = {\r\nsizeof(struct wmid3_gds_get_input_param),\r\n&params\r\n};\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstatus = wmi_evaluate_method(WMID_GUID3, 0, 0x2, &input, &output);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nobj = output.pointer;\r\nif (!obj)\r\nreturn AE_ERROR;\r\nelse if (obj->type != ACPI_TYPE_BUFFER) {\r\nkfree(obj);\r\nreturn AE_ERROR;\r\n}\r\nif (obj->buffer.length != 8) {\r\npr_warn("Unknown buffer length %d\n", obj->buffer.length);\r\nkfree(obj);\r\nreturn AE_ERROR;\r\n}\r\nreturn_value = *((struct wmid3_gds_return_value *)obj->buffer.pointer);\r\nkfree(obj);\r\nif (return_value.error_code || return_value.ec_return_value)\r\npr_warn("Get 0x%x Device Status failed: 0x%x - 0x%x\n",\r\ndevice,\r\nreturn_value.error_code,\r\nreturn_value.ec_return_value);\r\nelse\r\n*value = !!(return_value.devices & device);\r\nreturn status;\r\n}\r\nstatic acpi_status wmid_v2_get_u32(u32 *value, u32 cap)\r\n{\r\nu16 device;\r\nswitch (cap) {\r\ncase ACER_CAP_WIRELESS:\r\ndevice = ACER_WMID3_GDS_WIRELESS;\r\nbreak;\r\ncase ACER_CAP_BLUETOOTH:\r\ndevice = ACER_WMID3_GDS_BLUETOOTH;\r\nbreak;\r\ncase ACER_CAP_THREEG:\r\ndevice = ACER_WMID3_GDS_THREEG;\r\nbreak;\r\ndefault:\r\nreturn AE_ERROR;\r\n}\r\nreturn wmid3_get_device_status(value, device);\r\n}\r\nstatic acpi_status wmid3_set_device_status(u32 value, u16 device)\r\n{\r\nstruct wmid3_gds_return_value return_value;\r\nacpi_status status;\r\nunion acpi_object *obj;\r\nu16 devices;\r\nstruct wmid3_gds_get_input_param get_params = {\r\n.function_num = 0x1,\r\n.hotkey_number = commun_fn_key_number,\r\n.devices = commun_func_bitmap,\r\n};\r\nstruct acpi_buffer get_input = {\r\nsizeof(struct wmid3_gds_get_input_param),\r\n&get_params\r\n};\r\nstruct wmid3_gds_set_input_param set_params = {\r\n.function_num = 0x2,\r\n.hotkey_number = commun_fn_key_number,\r\n.devices = commun_func_bitmap,\r\n};\r\nstruct acpi_buffer set_input = {\r\nsizeof(struct wmid3_gds_set_input_param),\r\n&set_params\r\n};\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_buffer output2 = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstatus = wmi_evaluate_method(WMID_GUID3, 0, 0x2, &get_input, &output);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nobj = output.pointer;\r\nif (!obj)\r\nreturn AE_ERROR;\r\nelse if (obj->type != ACPI_TYPE_BUFFER) {\r\nkfree(obj);\r\nreturn AE_ERROR;\r\n}\r\nif (obj->buffer.length != 8) {\r\npr_warn("Unknown buffer length %d\n", obj->buffer.length);\r\nkfree(obj);\r\nreturn AE_ERROR;\r\n}\r\nreturn_value = *((struct wmid3_gds_return_value *)obj->buffer.pointer);\r\nkfree(obj);\r\nif (return_value.error_code || return_value.ec_return_value) {\r\npr_warn("Get Current Device Status failed: 0x%x - 0x%x\n",\r\nreturn_value.error_code,\r\nreturn_value.ec_return_value);\r\nreturn status;\r\n}\r\ndevices = return_value.devices;\r\nset_params.devices = (value) ? (devices | device) : (devices & ~device);\r\nstatus = wmi_evaluate_method(WMID_GUID3, 0, 0x1, &set_input, &output2);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nobj = output2.pointer;\r\nif (!obj)\r\nreturn AE_ERROR;\r\nelse if (obj->type != ACPI_TYPE_BUFFER) {\r\nkfree(obj);\r\nreturn AE_ERROR;\r\n}\r\nif (obj->buffer.length != 4) {\r\npr_warn("Unknown buffer length %d\n", obj->buffer.length);\r\nkfree(obj);\r\nreturn AE_ERROR;\r\n}\r\nreturn_value = *((struct wmid3_gds_return_value *)obj->buffer.pointer);\r\nkfree(obj);\r\nif (return_value.error_code || return_value.ec_return_value)\r\npr_warn("Set Device Status failed: 0x%x - 0x%x\n",\r\nreturn_value.error_code,\r\nreturn_value.ec_return_value);\r\nreturn status;\r\n}\r\nstatic acpi_status wmid_v2_set_u32(u32 value, u32 cap)\r\n{\r\nu16 device;\r\nswitch (cap) {\r\ncase ACER_CAP_WIRELESS:\r\ndevice = ACER_WMID3_GDS_WIRELESS;\r\nbreak;\r\ncase ACER_CAP_BLUETOOTH:\r\ndevice = ACER_WMID3_GDS_BLUETOOTH;\r\nbreak;\r\ncase ACER_CAP_THREEG:\r\ndevice = ACER_WMID3_GDS_THREEG;\r\nbreak;\r\ndefault:\r\nreturn AE_ERROR;\r\n}\r\nreturn wmid3_set_device_status(value, device);\r\n}\r\nstatic void __init type_aa_dmi_decode(const struct dmi_header *header, void *d)\r\n{\r\nstruct hotkey_function_type_aa *type_aa;\r\nif (header->type != 0xAA)\r\nreturn;\r\nhas_type_aa = true;\r\ntype_aa = (struct hotkey_function_type_aa *) header;\r\npr_info("Function bitmap for Communication Button: 0x%x\n",\r\ntype_aa->commun_func_bitmap);\r\ncommun_func_bitmap = type_aa->commun_func_bitmap;\r\nif (type_aa->commun_func_bitmap & ACER_WMID3_GDS_WIRELESS)\r\ninterface->capability |= ACER_CAP_WIRELESS;\r\nif (type_aa->commun_func_bitmap & ACER_WMID3_GDS_THREEG)\r\ninterface->capability |= ACER_CAP_THREEG;\r\nif (type_aa->commun_func_bitmap & ACER_WMID3_GDS_BLUETOOTH)\r\ninterface->capability |= ACER_CAP_BLUETOOTH;\r\nif (type_aa->commun_func_bitmap & ACER_WMID3_GDS_RFBTN) {\r\ninterface->capability |= ACER_CAP_RFBTN;\r\ncommun_func_bitmap &= ~ACER_WMID3_GDS_RFBTN;\r\n}\r\ncommun_fn_key_number = type_aa->commun_fn_key_number;\r\n}\r\nstatic acpi_status __init WMID_set_capabilities(void)\r\n{\r\nstruct acpi_buffer out = {ACPI_ALLOCATE_BUFFER, NULL};\r\nunion acpi_object *obj;\r\nacpi_status status;\r\nu32 devices;\r\nstatus = wmi_query_block(WMID_GUID2, 0, &out);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nobj = (union acpi_object *) out.pointer;\r\nif (obj) {\r\nif (obj->type == ACPI_TYPE_BUFFER &&\r\n(obj->buffer.length == sizeof(u32) ||\r\nobj->buffer.length == sizeof(u64))) {\r\ndevices = *((u32 *) obj->buffer.pointer);\r\n} else if (obj->type == ACPI_TYPE_INTEGER) {\r\ndevices = (u32) obj->integer.value;\r\n} else {\r\nkfree(out.pointer);\r\nreturn AE_ERROR;\r\n}\r\n} else {\r\nkfree(out.pointer);\r\nreturn AE_ERROR;\r\n}\r\npr_info("Function bitmap for Communication Device: 0x%x\n", devices);\r\nif (devices & 0x07)\r\ninterface->capability |= ACER_CAP_WIRELESS;\r\nif (devices & 0x40)\r\ninterface->capability |= ACER_CAP_THREEG;\r\nif (devices & 0x10)\r\ninterface->capability |= ACER_CAP_BLUETOOTH;\r\nif (!(devices & 0x20))\r\nmax_brightness = 0x9;\r\nkfree(out.pointer);\r\nreturn status;\r\n}\r\nstatic acpi_status get_u32(u32 *value, u32 cap)\r\n{\r\nacpi_status status = AE_ERROR;\r\nswitch (interface->type) {\r\ncase ACER_AMW0:\r\nstatus = AMW0_get_u32(value, cap);\r\nbreak;\r\ncase ACER_AMW0_V2:\r\nif (cap == ACER_CAP_MAILLED) {\r\nstatus = AMW0_get_u32(value, cap);\r\nbreak;\r\n}\r\ncase ACER_WMID:\r\nstatus = WMID_get_u32(value, cap);\r\nbreak;\r\ncase ACER_WMID_v2:\r\nif (cap & (ACER_CAP_WIRELESS |\r\nACER_CAP_BLUETOOTH |\r\nACER_CAP_THREEG))\r\nstatus = wmid_v2_get_u32(value, cap);\r\nelse if (wmi_has_guid(WMID_GUID2))\r\nstatus = WMID_get_u32(value, cap);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic acpi_status set_u32(u32 value, u32 cap)\r\n{\r\nacpi_status status;\r\nif (interface->capability & cap) {\r\nswitch (interface->type) {\r\ncase ACER_AMW0:\r\nreturn AMW0_set_u32(value, cap);\r\ncase ACER_AMW0_V2:\r\nif (cap == ACER_CAP_MAILLED)\r\nreturn AMW0_set_u32(value, cap);\r\nif (cap == ACER_CAP_WIRELESS ||\r\ncap == ACER_CAP_BLUETOOTH) {\r\nstatus = WMID_set_u32(value, cap);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nreturn AMW0_set_u32(value, cap);\r\n}\r\ncase ACER_WMID:\r\nreturn WMID_set_u32(value, cap);\r\ncase ACER_WMID_v2:\r\nif (cap & (ACER_CAP_WIRELESS |\r\nACER_CAP_BLUETOOTH |\r\nACER_CAP_THREEG))\r\nreturn wmid_v2_set_u32(value, cap);\r\nelse if (wmi_has_guid(WMID_GUID2))\r\nreturn WMID_set_u32(value, cap);\r\ndefault:\r\nreturn AE_BAD_PARAMETER;\r\n}\r\n}\r\nreturn AE_BAD_PARAMETER;\r\n}\r\nstatic void __init acer_commandline_init(void)\r\n{\r\nif (mailled >= 0)\r\nset_u32(mailled, ACER_CAP_MAILLED);\r\nif (!has_type_aa && threeg >= 0)\r\nset_u32(threeg, ACER_CAP_THREEG);\r\nif (brightness >= 0)\r\nset_u32(brightness, ACER_CAP_BRIGHTNESS);\r\n}\r\nstatic void mail_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nset_u32(value, ACER_CAP_MAILLED);\r\n}\r\nstatic int acer_led_init(struct device *dev)\r\n{\r\nreturn led_classdev_register(dev, &mail_led);\r\n}\r\nstatic void acer_led_exit(void)\r\n{\r\nset_u32(LED_OFF, ACER_CAP_MAILLED);\r\nled_classdev_unregister(&mail_led);\r\n}\r\nstatic int read_brightness(struct backlight_device *bd)\r\n{\r\nu32 value;\r\nget_u32(&value, ACER_CAP_BRIGHTNESS);\r\nreturn value;\r\n}\r\nstatic int update_bl_status(struct backlight_device *bd)\r\n{\r\nint intensity = bd->props.brightness;\r\nif (bd->props.power != FB_BLANK_UNBLANK)\r\nintensity = 0;\r\nif (bd->props.fb_blank != FB_BLANK_UNBLANK)\r\nintensity = 0;\r\nset_u32(intensity, ACER_CAP_BRIGHTNESS);\r\nreturn 0;\r\n}\r\nstatic int acer_backlight_init(struct device *dev)\r\n{\r\nstruct backlight_properties props;\r\nstruct backlight_device *bd;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = max_brightness;\r\nbd = backlight_device_register("acer-wmi", dev, NULL, &acer_bl_ops,\r\n&props);\r\nif (IS_ERR(bd)) {\r\npr_err("Could not register Acer backlight device\n");\r\nacer_backlight_device = NULL;\r\nreturn PTR_ERR(bd);\r\n}\r\nacer_backlight_device = bd;\r\nbd->props.power = FB_BLANK_UNBLANK;\r\nbd->props.brightness = read_brightness(bd);\r\nbacklight_update_status(bd);\r\nreturn 0;\r\n}\r\nstatic void acer_backlight_exit(void)\r\n{\r\nbacklight_device_unregister(acer_backlight_device);\r\n}\r\nstatic int acer_gsensor_init(void)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer output;\r\nunion acpi_object out_obj;\r\noutput.length = sizeof(out_obj);\r\noutput.pointer = &out_obj;\r\nstatus = acpi_evaluate_object(gsensor_handle, "_INI", NULL, &output);\r\nif (ACPI_FAILURE(status))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int acer_gsensor_open(struct input_dev *input)\r\n{\r\nreturn acer_gsensor_init();\r\n}\r\nstatic int acer_gsensor_event(void)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer output;\r\nunion acpi_object out_obj[5];\r\nif (!has_cap(ACER_CAP_ACCEL))\r\nreturn -1;\r\noutput.length = sizeof(out_obj);\r\noutput.pointer = out_obj;\r\nstatus = acpi_evaluate_object(gsensor_handle, "RDVL", NULL, &output);\r\nif (ACPI_FAILURE(status))\r\nreturn -1;\r\nif (out_obj->package.count != 4)\r\nreturn -1;\r\ninput_report_abs(acer_wmi_accel_dev, ABS_X,\r\n(s16)out_obj->package.elements[0].integer.value);\r\ninput_report_abs(acer_wmi_accel_dev, ABS_Y,\r\n(s16)out_obj->package.elements[1].integer.value);\r\ninput_report_abs(acer_wmi_accel_dev, ABS_Z,\r\n(s16)out_obj->package.elements[2].integer.value);\r\ninput_sync(acer_wmi_accel_dev);\r\nreturn 0;\r\n}\r\nstatic void acer_rfkill_update(struct work_struct *ignored)\r\n{\r\nu32 state;\r\nacpi_status status;\r\nif (has_cap(ACER_CAP_WIRELESS)) {\r\nstatus = get_u32(&state, ACER_CAP_WIRELESS);\r\nif (ACPI_SUCCESS(status)) {\r\nif (quirks->wireless == 3)\r\nrfkill_set_hw_state(wireless_rfkill, !state);\r\nelse\r\nrfkill_set_sw_state(wireless_rfkill, !state);\r\n}\r\n}\r\nif (has_cap(ACER_CAP_BLUETOOTH)) {\r\nstatus = get_u32(&state, ACER_CAP_BLUETOOTH);\r\nif (ACPI_SUCCESS(status))\r\nrfkill_set_sw_state(bluetooth_rfkill, !state);\r\n}\r\nif (has_cap(ACER_CAP_THREEG) && wmi_has_guid(WMID_GUID3)) {\r\nstatus = get_u32(&state, ACER_WMID3_GDS_THREEG);\r\nif (ACPI_SUCCESS(status))\r\nrfkill_set_sw_state(threeg_rfkill, !state);\r\n}\r\nschedule_delayed_work(&acer_rfkill_work, round_jiffies_relative(HZ));\r\n}\r\nstatic int acer_rfkill_set(void *data, bool blocked)\r\n{\r\nacpi_status status;\r\nu32 cap = (unsigned long)data;\r\nif (rfkill_inited) {\r\nstatus = set_u32(!blocked, cap);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct rfkill *acer_rfkill_register(struct device *dev,\r\nenum rfkill_type type,\r\nchar *name, u32 cap)\r\n{\r\nint err;\r\nstruct rfkill *rfkill_dev;\r\nu32 state;\r\nacpi_status status;\r\nrfkill_dev = rfkill_alloc(name, dev, type,\r\n&acer_rfkill_ops,\r\n(void *)(unsigned long)cap);\r\nif (!rfkill_dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nstatus = get_u32(&state, cap);\r\nerr = rfkill_register(rfkill_dev);\r\nif (err) {\r\nrfkill_destroy(rfkill_dev);\r\nreturn ERR_PTR(err);\r\n}\r\nif (ACPI_SUCCESS(status))\r\nrfkill_set_sw_state(rfkill_dev, !state);\r\nreturn rfkill_dev;\r\n}\r\nstatic int acer_rfkill_init(struct device *dev)\r\n{\r\nint err;\r\nif (has_cap(ACER_CAP_WIRELESS)) {\r\nwireless_rfkill = acer_rfkill_register(dev, RFKILL_TYPE_WLAN,\r\n"acer-wireless", ACER_CAP_WIRELESS);\r\nif (IS_ERR(wireless_rfkill)) {\r\nerr = PTR_ERR(wireless_rfkill);\r\ngoto error_wireless;\r\n}\r\n}\r\nif (has_cap(ACER_CAP_BLUETOOTH)) {\r\nbluetooth_rfkill = acer_rfkill_register(dev,\r\nRFKILL_TYPE_BLUETOOTH, "acer-bluetooth",\r\nACER_CAP_BLUETOOTH);\r\nif (IS_ERR(bluetooth_rfkill)) {\r\nerr = PTR_ERR(bluetooth_rfkill);\r\ngoto error_bluetooth;\r\n}\r\n}\r\nif (has_cap(ACER_CAP_THREEG)) {\r\nthreeg_rfkill = acer_rfkill_register(dev,\r\nRFKILL_TYPE_WWAN, "acer-threeg",\r\nACER_CAP_THREEG);\r\nif (IS_ERR(threeg_rfkill)) {\r\nerr = PTR_ERR(threeg_rfkill);\r\ngoto error_threeg;\r\n}\r\n}\r\nrfkill_inited = true;\r\nif ((ec_raw_mode || !wmi_has_guid(ACERWMID_EVENT_GUID)) &&\r\nhas_cap(ACER_CAP_WIRELESS | ACER_CAP_BLUETOOTH | ACER_CAP_THREEG))\r\nschedule_delayed_work(&acer_rfkill_work,\r\nround_jiffies_relative(HZ));\r\nreturn 0;\r\nerror_threeg:\r\nif (has_cap(ACER_CAP_BLUETOOTH)) {\r\nrfkill_unregister(bluetooth_rfkill);\r\nrfkill_destroy(bluetooth_rfkill);\r\n}\r\nerror_bluetooth:\r\nif (has_cap(ACER_CAP_WIRELESS)) {\r\nrfkill_unregister(wireless_rfkill);\r\nrfkill_destroy(wireless_rfkill);\r\n}\r\nerror_wireless:\r\nreturn err;\r\n}\r\nstatic void acer_rfkill_exit(void)\r\n{\r\nif ((ec_raw_mode || !wmi_has_guid(ACERWMID_EVENT_GUID)) &&\r\nhas_cap(ACER_CAP_WIRELESS | ACER_CAP_BLUETOOTH | ACER_CAP_THREEG))\r\ncancel_delayed_work_sync(&acer_rfkill_work);\r\nif (has_cap(ACER_CAP_WIRELESS)) {\r\nrfkill_unregister(wireless_rfkill);\r\nrfkill_destroy(wireless_rfkill);\r\n}\r\nif (has_cap(ACER_CAP_BLUETOOTH)) {\r\nrfkill_unregister(bluetooth_rfkill);\r\nrfkill_destroy(bluetooth_rfkill);\r\n}\r\nif (has_cap(ACER_CAP_THREEG)) {\r\nrfkill_unregister(threeg_rfkill);\r\nrfkill_destroy(threeg_rfkill);\r\n}\r\nreturn;\r\n}\r\nstatic void acer_wmi_notify(u32 value, void *context)\r\n{\r\nstruct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nstruct event_return_value return_value;\r\nacpi_status status;\r\nu16 device_state;\r\nconst struct key_entry *key;\r\nu32 scancode;\r\nstatus = wmi_get_event_data(value, &response);\r\nif (status != AE_OK) {\r\npr_warn("bad event status 0x%x\n", status);\r\nreturn;\r\n}\r\nobj = (union acpi_object *)response.pointer;\r\nif (!obj)\r\nreturn;\r\nif (obj->type != ACPI_TYPE_BUFFER) {\r\npr_warn("Unknown response received %d\n", obj->type);\r\nkfree(obj);\r\nreturn;\r\n}\r\nif (obj->buffer.length != 8) {\r\npr_warn("Unknown buffer length %d\n", obj->buffer.length);\r\nkfree(obj);\r\nreturn;\r\n}\r\nreturn_value = *((struct event_return_value *)obj->buffer.pointer);\r\nkfree(obj);\r\nswitch (return_value.function) {\r\ncase WMID_HOTKEY_EVENT:\r\ndevice_state = return_value.device_state;\r\npr_debug("device state: 0x%x\n", device_state);\r\nkey = sparse_keymap_entry_from_scancode(acer_wmi_input_dev,\r\nreturn_value.key_num);\r\nif (!key) {\r\npr_warn("Unknown key number - 0x%x\n",\r\nreturn_value.key_num);\r\n} else {\r\nscancode = return_value.key_num;\r\nswitch (key->keycode) {\r\ncase KEY_WLAN:\r\ncase KEY_BLUETOOTH:\r\nif (has_cap(ACER_CAP_WIRELESS))\r\nrfkill_set_sw_state(wireless_rfkill,\r\n!(device_state & ACER_WMID3_GDS_WIRELESS));\r\nif (has_cap(ACER_CAP_THREEG))\r\nrfkill_set_sw_state(threeg_rfkill,\r\n!(device_state & ACER_WMID3_GDS_THREEG));\r\nif (has_cap(ACER_CAP_BLUETOOTH))\r\nrfkill_set_sw_state(bluetooth_rfkill,\r\n!(device_state & ACER_WMID3_GDS_BLUETOOTH));\r\nbreak;\r\ncase KEY_TOUCHPAD_TOGGLE:\r\nscancode = (device_state & ACER_WMID3_GDS_TOUCHPAD) ?\r\nKEY_TOUCHPAD_ON : KEY_TOUCHPAD_OFF;\r\n}\r\nsparse_keymap_report_event(acer_wmi_input_dev, scancode, 1, true);\r\n}\r\nbreak;\r\ncase WMID_ACCEL_EVENT:\r\nacer_gsensor_event();\r\nbreak;\r\ndefault:\r\npr_warn("Unknown function number - %d - %d\n",\r\nreturn_value.function, return_value.key_num);\r\nbreak;\r\n}\r\n}\r\nstatic acpi_status __init\r\nwmid3_set_function_mode(struct func_input_params *params,\r\nstruct func_return_value *return_value)\r\n{\r\nacpi_status status;\r\nunion acpi_object *obj;\r\nstruct acpi_buffer input = { sizeof(struct func_input_params), params };\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstatus = wmi_evaluate_method(WMID_GUID3, 0, 0x1, &input, &output);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nobj = output.pointer;\r\nif (!obj)\r\nreturn AE_ERROR;\r\nelse if (obj->type != ACPI_TYPE_BUFFER) {\r\nkfree(obj);\r\nreturn AE_ERROR;\r\n}\r\nif (obj->buffer.length != 4) {\r\npr_warn("Unknown buffer length %d\n", obj->buffer.length);\r\nkfree(obj);\r\nreturn AE_ERROR;\r\n}\r\n*return_value = *((struct func_return_value *)obj->buffer.pointer);\r\nkfree(obj);\r\nreturn status;\r\n}\r\nstatic int __init acer_wmi_enable_ec_raw(void)\r\n{\r\nstruct func_return_value return_value;\r\nacpi_status status;\r\nstruct func_input_params params = {\r\n.function_num = 0x1,\r\n.commun_devices = 0xFFFF,\r\n.devices = 0xFFFF,\r\n.app_status = 0x00,\r\n.app_mask = 0x01,\r\n};\r\nstatus = wmid3_set_function_mode(&params, &return_value);\r\nif (return_value.error_code || return_value.ec_return_value)\r\npr_warn("Enabling EC raw mode failed: 0x%x - 0x%x\n",\r\nreturn_value.error_code,\r\nreturn_value.ec_return_value);\r\nelse\r\npr_info("Enabled EC raw mode\n");\r\nreturn status;\r\n}\r\nstatic int __init acer_wmi_enable_lm(void)\r\n{\r\nstruct func_return_value return_value;\r\nacpi_status status;\r\nstruct func_input_params params = {\r\n.function_num = 0x1,\r\n.commun_devices = 0xFFFF,\r\n.devices = 0xFFFF,\r\n.app_status = 0x01,\r\n.app_mask = 0x01,\r\n};\r\nstatus = wmid3_set_function_mode(&params, &return_value);\r\nif (return_value.error_code || return_value.ec_return_value)\r\npr_warn("Enabling Launch Manager failed: 0x%x - 0x%x\n",\r\nreturn_value.error_code,\r\nreturn_value.ec_return_value);\r\nreturn status;\r\n}\r\nstatic int __init acer_wmi_enable_rf_button(void)\r\n{\r\nstruct func_return_value return_value;\r\nacpi_status status;\r\nstruct func_input_params params = {\r\n.function_num = 0x1,\r\n.commun_devices = 0xFFFF,\r\n.devices = 0xFFFF,\r\n.app_status = 0x10,\r\n.app_mask = 0x10,\r\n};\r\nstatus = wmid3_set_function_mode(&params, &return_value);\r\nif (return_value.error_code || return_value.ec_return_value)\r\npr_warn("Enabling RF Button failed: 0x%x - 0x%x\n",\r\nreturn_value.error_code,\r\nreturn_value.ec_return_value);\r\nreturn status;\r\n}\r\nstatic acpi_status __init acer_wmi_get_handle_cb(acpi_handle ah, u32 level,\r\nvoid *ctx, void **retval)\r\n{\r\nstruct acpi_device *dev;\r\nif (!strcmp(ctx, "SENR")) {\r\nif (acpi_bus_get_device(ah, &dev))\r\nreturn AE_OK;\r\nif (strcmp(ACER_WMID_ACCEL_HID, acpi_device_hid(dev)))\r\nreturn AE_OK;\r\n} else\r\nreturn AE_OK;\r\n*(acpi_handle *)retval = ah;\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nstatic int __init acer_wmi_get_handle(const char *name, const char *prop,\r\nacpi_handle *ah)\r\n{\r\nacpi_status status;\r\nacpi_handle handle;\r\nBUG_ON(!name || !ah);\r\nhandle = NULL;\r\nstatus = acpi_get_devices(prop, acer_wmi_get_handle_cb,\r\n(void *)name, &handle);\r\nif (ACPI_SUCCESS(status) && handle) {\r\n*ah = handle;\r\nreturn 0;\r\n} else {\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic int __init acer_wmi_accel_setup(void)\r\n{\r\nint err;\r\nerr = acer_wmi_get_handle("SENR", ACER_WMID_ACCEL_HID, &gsensor_handle);\r\nif (err)\r\nreturn err;\r\ninterface->capability |= ACER_CAP_ACCEL;\r\nacer_wmi_accel_dev = input_allocate_device();\r\nif (!acer_wmi_accel_dev)\r\nreturn -ENOMEM;\r\nacer_wmi_accel_dev->open = acer_gsensor_open;\r\nacer_wmi_accel_dev->name = "Acer BMA150 accelerometer";\r\nacer_wmi_accel_dev->phys = "wmi/input1";\r\nacer_wmi_accel_dev->id.bustype = BUS_HOST;\r\nacer_wmi_accel_dev->evbit[0] = BIT_MASK(EV_ABS);\r\ninput_set_abs_params(acer_wmi_accel_dev, ABS_X, -16384, 16384, 0, 0);\r\ninput_set_abs_params(acer_wmi_accel_dev, ABS_Y, -16384, 16384, 0, 0);\r\ninput_set_abs_params(acer_wmi_accel_dev, ABS_Z, -16384, 16384, 0, 0);\r\nerr = input_register_device(acer_wmi_accel_dev);\r\nif (err)\r\ngoto err_free_dev;\r\nreturn 0;\r\nerr_free_dev:\r\ninput_free_device(acer_wmi_accel_dev);\r\nreturn err;\r\n}\r\nstatic void acer_wmi_accel_destroy(void)\r\n{\r\ninput_unregister_device(acer_wmi_accel_dev);\r\n}\r\nstatic int __init acer_wmi_input_setup(void)\r\n{\r\nacpi_status status;\r\nint err;\r\nacer_wmi_input_dev = input_allocate_device();\r\nif (!acer_wmi_input_dev)\r\nreturn -ENOMEM;\r\nacer_wmi_input_dev->name = "Acer WMI hotkeys";\r\nacer_wmi_input_dev->phys = "wmi/input0";\r\nacer_wmi_input_dev->id.bustype = BUS_HOST;\r\nerr = sparse_keymap_setup(acer_wmi_input_dev, acer_wmi_keymap, NULL);\r\nif (err)\r\ngoto err_free_dev;\r\nstatus = wmi_install_notify_handler(ACERWMID_EVENT_GUID,\r\nacer_wmi_notify, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nerr = -EIO;\r\ngoto err_free_dev;\r\n}\r\nerr = input_register_device(acer_wmi_input_dev);\r\nif (err)\r\ngoto err_uninstall_notifier;\r\nreturn 0;\r\nerr_uninstall_notifier:\r\nwmi_remove_notify_handler(ACERWMID_EVENT_GUID);\r\nerr_free_dev:\r\ninput_free_device(acer_wmi_input_dev);\r\nreturn err;\r\n}\r\nstatic void acer_wmi_input_destroy(void)\r\n{\r\nwmi_remove_notify_handler(ACERWMID_EVENT_GUID);\r\ninput_unregister_device(acer_wmi_input_dev);\r\n}\r\nstatic u32 get_wmid_devices(void)\r\n{\r\nstruct acpi_buffer out = {ACPI_ALLOCATE_BUFFER, NULL};\r\nunion acpi_object *obj;\r\nacpi_status status;\r\nu32 devices = 0;\r\nstatus = wmi_query_block(WMID_GUID2, 0, &out);\r\nif (ACPI_FAILURE(status))\r\nreturn 0;\r\nobj = (union acpi_object *) out.pointer;\r\nif (obj) {\r\nif (obj->type == ACPI_TYPE_BUFFER &&\r\n(obj->buffer.length == sizeof(u32) ||\r\nobj->buffer.length == sizeof(u64))) {\r\ndevices = *((u32 *) obj->buffer.pointer);\r\n} else if (obj->type == ACPI_TYPE_INTEGER) {\r\ndevices = (u32) obj->integer.value;\r\n}\r\n}\r\nkfree(out.pointer);\r\nreturn devices;\r\n}\r\nstatic int acer_platform_probe(struct platform_device *device)\r\n{\r\nint err;\r\nif (has_cap(ACER_CAP_MAILLED)) {\r\nerr = acer_led_init(&device->dev);\r\nif (err)\r\ngoto error_mailled;\r\n}\r\nif (has_cap(ACER_CAP_BRIGHTNESS)) {\r\nerr = acer_backlight_init(&device->dev);\r\nif (err)\r\ngoto error_brightness;\r\n}\r\nerr = acer_rfkill_init(&device->dev);\r\nif (err)\r\ngoto error_rfkill;\r\nreturn err;\r\nerror_rfkill:\r\nif (has_cap(ACER_CAP_BRIGHTNESS))\r\nacer_backlight_exit();\r\nerror_brightness:\r\nif (has_cap(ACER_CAP_MAILLED))\r\nacer_led_exit();\r\nerror_mailled:\r\nreturn err;\r\n}\r\nstatic int acer_platform_remove(struct platform_device *device)\r\n{\r\nif (has_cap(ACER_CAP_MAILLED))\r\nacer_led_exit();\r\nif (has_cap(ACER_CAP_BRIGHTNESS))\r\nacer_backlight_exit();\r\nacer_rfkill_exit();\r\nreturn 0;\r\n}\r\nstatic int acer_suspend(struct device *dev)\r\n{\r\nu32 value;\r\nstruct acer_data *data = &interface->data;\r\nif (!data)\r\nreturn -ENOMEM;\r\nif (has_cap(ACER_CAP_MAILLED)) {\r\nget_u32(&value, ACER_CAP_MAILLED);\r\nset_u32(LED_OFF, ACER_CAP_MAILLED);\r\ndata->mailled = value;\r\n}\r\nif (has_cap(ACER_CAP_BRIGHTNESS)) {\r\nget_u32(&value, ACER_CAP_BRIGHTNESS);\r\ndata->brightness = value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acer_resume(struct device *dev)\r\n{\r\nstruct acer_data *data = &interface->data;\r\nif (!data)\r\nreturn -ENOMEM;\r\nif (has_cap(ACER_CAP_MAILLED))\r\nset_u32(data->mailled, ACER_CAP_MAILLED);\r\nif (has_cap(ACER_CAP_BRIGHTNESS))\r\nset_u32(data->brightness, ACER_CAP_BRIGHTNESS);\r\nif (has_cap(ACER_CAP_ACCEL))\r\nacer_gsensor_init();\r\nreturn 0;\r\n}\r\nstatic void acer_platform_shutdown(struct platform_device *device)\r\n{\r\nstruct acer_data *data = &interface->data;\r\nif (!data)\r\nreturn;\r\nif (has_cap(ACER_CAP_MAILLED))\r\nset_u32(LED_OFF, ACER_CAP_MAILLED);\r\n}\r\nstatic void remove_debugfs(void)\r\n{\r\ndebugfs_remove(interface->debug.devices);\r\ndebugfs_remove(interface->debug.root);\r\n}\r\nstatic int __init create_debugfs(void)\r\n{\r\ninterface->debug.root = debugfs_create_dir("acer-wmi", NULL);\r\nif (!interface->debug.root) {\r\npr_err("Failed to create debugfs directory");\r\nreturn -ENOMEM;\r\n}\r\ninterface->debug.devices = debugfs_create_u32("devices", S_IRUGO,\r\ninterface->debug.root,\r\n&interface->debug.wmid_devices);\r\nif (!interface->debug.devices)\r\ngoto error_debugfs;\r\nreturn 0;\r\nerror_debugfs:\r\nremove_debugfs();\r\nreturn -ENOMEM;\r\n}\r\nstatic int __init acer_wmi_init(void)\r\n{\r\nint err;\r\npr_info("Acer Laptop ACPI-WMI Extras\n");\r\nif (dmi_check_system(acer_blacklist)) {\r\npr_info("Blacklisted hardware detected - not loading\n");\r\nreturn -ENODEV;\r\n}\r\nfind_quirks();\r\nif (wmi_has_guid(AMW0_GUID1) &&\r\n!dmi_check_system(amw0_whitelist) &&\r\nquirks == &quirk_unknown) {\r\npr_err("Unsupported machine has AMW0_GUID1, unable to load\n");\r\nreturn -ENODEV;\r\n}\r\nif (wmi_has_guid(AMW0_GUID1) && wmi_has_guid(WMID_GUID1))\r\ninterface = &AMW0_V2_interface;\r\nif (!wmi_has_guid(AMW0_GUID1) && wmi_has_guid(WMID_GUID1))\r\ninterface = &wmid_interface;\r\nif (wmi_has_guid(WMID_GUID3))\r\ninterface = &wmid_v2_interface;\r\nif (interface)\r\ndmi_walk(type_aa_dmi_decode, NULL);\r\nif (wmi_has_guid(WMID_GUID2) && interface) {\r\nif (!has_type_aa && ACPI_FAILURE(WMID_set_capabilities())) {\r\npr_err("Unable to detect available WMID devices\n");\r\nreturn -ENODEV;\r\n}\r\ninterface->capability |= ACER_CAP_BRIGHTNESS;\r\n} else if (!wmi_has_guid(WMID_GUID2) && interface && !has_type_aa) {\r\npr_err("No WMID device detection method found\n");\r\nreturn -ENODEV;\r\n}\r\nif (wmi_has_guid(AMW0_GUID1) && !wmi_has_guid(WMID_GUID1)) {\r\ninterface = &AMW0_interface;\r\nif (ACPI_FAILURE(AMW0_set_capabilities())) {\r\npr_err("Unable to detect available AMW0 devices\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (wmi_has_guid(AMW0_GUID1))\r\nAMW0_find_mailled();\r\nif (!interface) {\r\npr_err("No or unsupported WMI interface, unable to load\n");\r\nreturn -ENODEV;\r\n}\r\nset_quirks();\r\nif (dmi_check_system(video_vendor_dmi_table))\r\nacpi_video_set_dmi_backlight_type(acpi_backlight_vendor);\r\nif (acpi_video_get_backlight_type() != acpi_backlight_vendor)\r\ninterface->capability &= ~ACER_CAP_BRIGHTNESS;\r\nif (wmi_has_guid(WMID_GUID3)) {\r\nif (ACPI_FAILURE(acer_wmi_enable_rf_button()))\r\npr_warn("Cannot enable RF Button Driver\n");\r\nif (ec_raw_mode) {\r\nif (ACPI_FAILURE(acer_wmi_enable_ec_raw())) {\r\npr_err("Cannot enable EC raw mode\n");\r\nreturn -ENODEV;\r\n}\r\n} else if (ACPI_FAILURE(acer_wmi_enable_lm())) {\r\npr_err("Cannot enable Launch Manager mode\n");\r\nreturn -ENODEV;\r\n}\r\n} else if (ec_raw_mode) {\r\npr_info("No WMID EC raw mode enable method\n");\r\n}\r\nif (wmi_has_guid(ACERWMID_EVENT_GUID)) {\r\nerr = acer_wmi_input_setup();\r\nif (err)\r\nreturn err;\r\nerr = acer_wmi_accel_setup();\r\nif (err && err != -ENODEV)\r\npr_warn("Cannot enable accelerometer\n");\r\n}\r\nerr = platform_driver_register(&acer_platform_driver);\r\nif (err) {\r\npr_err("Unable to register platform driver\n");\r\ngoto error_platform_register;\r\n}\r\nacer_platform_device = platform_device_alloc("acer-wmi", -1);\r\nif (!acer_platform_device) {\r\nerr = -ENOMEM;\r\ngoto error_device_alloc;\r\n}\r\nerr = platform_device_add(acer_platform_device);\r\nif (err)\r\ngoto error_device_add;\r\nif (wmi_has_guid(WMID_GUID2)) {\r\ninterface->debug.wmid_devices = get_wmid_devices();\r\nerr = create_debugfs();\r\nif (err)\r\ngoto error_create_debugfs;\r\n}\r\nacer_commandline_init();\r\nreturn 0;\r\nerror_create_debugfs:\r\nplatform_device_del(acer_platform_device);\r\nerror_device_add:\r\nplatform_device_put(acer_platform_device);\r\nerror_device_alloc:\r\nplatform_driver_unregister(&acer_platform_driver);\r\nerror_platform_register:\r\nif (wmi_has_guid(ACERWMID_EVENT_GUID))\r\nacer_wmi_input_destroy();\r\nif (has_cap(ACER_CAP_ACCEL))\r\nacer_wmi_accel_destroy();\r\nreturn err;\r\n}\r\nstatic void __exit acer_wmi_exit(void)\r\n{\r\nif (wmi_has_guid(ACERWMID_EVENT_GUID))\r\nacer_wmi_input_destroy();\r\nif (has_cap(ACER_CAP_ACCEL))\r\nacer_wmi_accel_destroy();\r\nremove_debugfs();\r\nplatform_device_unregister(acer_platform_device);\r\nplatform_driver_unregister(&acer_platform_driver);\r\npr_info("Acer Laptop WMI Extras unloaded\n");\r\nreturn;\r\n}
