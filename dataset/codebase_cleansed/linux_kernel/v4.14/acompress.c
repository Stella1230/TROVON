static int crypto_acomp_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nstruct crypto_report_acomp racomp;\r\nstrncpy(racomp.type, "acomp", sizeof(racomp.type));\r\nif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\r\nsizeof(struct crypto_report_acomp), &racomp))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int crypto_acomp_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic void crypto_acomp_show(struct seq_file *m, struct crypto_alg *alg)\r\n{\r\nseq_puts(m, "type : acomp\n");\r\n}\r\nstatic void crypto_acomp_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_acomp *acomp = __crypto_acomp_tfm(tfm);\r\nstruct acomp_alg *alg = crypto_acomp_alg(acomp);\r\nalg->exit(acomp);\r\n}\r\nstatic int crypto_acomp_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_acomp *acomp = __crypto_acomp_tfm(tfm);\r\nstruct acomp_alg *alg = crypto_acomp_alg(acomp);\r\nif (tfm->__crt_alg->cra_type != &crypto_acomp_type)\r\nreturn crypto_init_scomp_ops_async(tfm);\r\nacomp->compress = alg->compress;\r\nacomp->decompress = alg->decompress;\r\nacomp->dst_free = alg->dst_free;\r\nacomp->reqsize = alg->reqsize;\r\nif (alg->exit)\r\nacomp->base.exit = crypto_acomp_exit_tfm;\r\nif (alg->init)\r\nreturn alg->init(acomp);\r\nreturn 0;\r\n}\r\nstatic unsigned int crypto_acomp_extsize(struct crypto_alg *alg)\r\n{\r\nint extsize = crypto_alg_extsize(alg);\r\nif (alg->cra_type != &crypto_acomp_type)\r\nextsize += sizeof(struct crypto_scomp *);\r\nreturn extsize;\r\n}\r\nstruct crypto_acomp *crypto_alloc_acomp(const char *alg_name, u32 type,\r\nu32 mask)\r\n{\r\nreturn crypto_alloc_tfm(alg_name, &crypto_acomp_type, type, mask);\r\n}\r\nstruct acomp_req *acomp_request_alloc(struct crypto_acomp *acomp)\r\n{\r\nstruct crypto_tfm *tfm = crypto_acomp_tfm(acomp);\r\nstruct acomp_req *req;\r\nreq = __acomp_request_alloc(acomp);\r\nif (req && (tfm->__crt_alg->cra_type != &crypto_acomp_type))\r\nreturn crypto_acomp_scomp_alloc_ctx(req);\r\nreturn req;\r\n}\r\nvoid acomp_request_free(struct acomp_req *req)\r\n{\r\nstruct crypto_acomp *acomp = crypto_acomp_reqtfm(req);\r\nstruct crypto_tfm *tfm = crypto_acomp_tfm(acomp);\r\nif (tfm->__crt_alg->cra_type != &crypto_acomp_type)\r\ncrypto_acomp_scomp_free_ctx(req);\r\nif (req->flags & CRYPTO_ACOMP_ALLOC_OUTPUT) {\r\nacomp->dst_free(req->dst);\r\nreq->dst = NULL;\r\n}\r\n__acomp_request_free(req);\r\n}\r\nint crypto_register_acomp(struct acomp_alg *alg)\r\n{\r\nstruct crypto_alg *base = &alg->base;\r\nbase->cra_type = &crypto_acomp_type;\r\nbase->cra_flags &= ~CRYPTO_ALG_TYPE_MASK;\r\nbase->cra_flags |= CRYPTO_ALG_TYPE_ACOMPRESS;\r\nreturn crypto_register_alg(base);\r\n}\r\nint crypto_unregister_acomp(struct acomp_alg *alg)\r\n{\r\nreturn crypto_unregister_alg(&alg->base);\r\n}\r\nint crypto_register_acomps(struct acomp_alg *algs, int count)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < count; i++) {\r\nret = crypto_register_acomp(&algs[i]);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nfor (--i; i >= 0; --i)\r\ncrypto_unregister_acomp(&algs[i]);\r\nreturn ret;\r\n}\r\nvoid crypto_unregister_acomps(struct acomp_alg *algs, int count)\r\n{\r\nint i;\r\nfor (i = count - 1; i >= 0; --i)\r\ncrypto_unregister_acomp(&algs[i]);\r\n}
