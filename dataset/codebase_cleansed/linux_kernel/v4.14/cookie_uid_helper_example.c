static void maps_create(void)\r\n{\r\nmap_fd = bpf_create_map(BPF_MAP_TYPE_HASH, sizeof(uint32_t),\r\nsizeof(struct stats), 100, 0);\r\nif (map_fd < 0)\r\nerror(1, errno, "map create failed!\n");\r\n}\r\nstatic void prog_load(void)\r\n{\r\nstatic char log_buf[1 << 16];\r\nstruct bpf_insn prog[] = {\r\nBPF_MOV64_REG(BPF_REG_6, BPF_REG_1),\r\nBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,\r\nBPF_FUNC_get_socket_cookie),\r\nBPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -8),\r\nBPF_MOV64_REG(BPF_REG_7, BPF_REG_10),\r\nBPF_ALU64_IMM(BPF_ADD, BPF_REG_7, -8),\r\nBPF_LD_MAP_FD(BPF_REG_1, map_fd),\r\nBPF_MOV64_REG(BPF_REG_2, BPF_REG_7),\r\nBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,\r\nBPF_FUNC_map_lookup_elem),\r\nBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 14),\r\nBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\r\nBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,\r\nBPF_FUNC_get_socket_uid),\r\nBPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0,\r\n-32 + (__s16)offsetof(struct stats, uid)),\r\nBPF_ST_MEM(BPF_DW, BPF_REG_10,\r\n-32 + (__s16)offsetof(struct stats, packets), 1),\r\nBPF_LDX_MEM(BPF_W, BPF_REG_1, BPF_REG_6,\r\noffsetof(struct __sk_buff, len)),\r\nBPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_1,\r\n-32 + (__s16)offsetof(struct stats, bytes)),\r\nBPF_LD_MAP_FD(BPF_REG_1, map_fd),\r\nBPF_MOV64_REG(BPF_REG_2, BPF_REG_7),\r\nBPF_MOV64_REG(BPF_REG_3, BPF_REG_10),\r\nBPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -32),\r\nBPF_MOV64_IMM(BPF_REG_4, 0),\r\nBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,\r\nBPF_FUNC_map_update_elem),\r\nBPF_JMP_IMM(BPF_JA, 0, 0, 5),\r\nBPF_MOV64_REG(BPF_REG_9, BPF_REG_0),\r\nBPF_MOV64_IMM(BPF_REG_1, 1),\r\nBPF_STX_XADD(BPF_DW, BPF_REG_9, BPF_REG_1,\r\noffsetof(struct stats, packets)),\r\nBPF_LDX_MEM(BPF_W, BPF_REG_1, BPF_REG_6,\r\noffsetof(struct __sk_buff, len)),\r\nBPF_STX_XADD(BPF_DW, BPF_REG_9, BPF_REG_1,\r\noffsetof(struct stats, bytes)),\r\nBPF_LDX_MEM(BPF_W, BPF_REG_0, BPF_REG_6,\r\noffsetof(struct __sk_buff, len)),\r\nBPF_EXIT_INSN(),\r\n};\r\nprog_fd = bpf_load_program(BPF_PROG_TYPE_SOCKET_FILTER, prog,\r\nARRAY_SIZE(prog), "GPL", 0,\r\nlog_buf, sizeof(log_buf));\r\nif (prog_fd < 0)\r\nerror(1, errno, "failed to load prog\n%s\n", log_buf);\r\n}\r\nstatic void prog_attach_iptables(char *file)\r\n{\r\nint ret;\r\nchar rules[100];\r\nif (bpf_obj_pin(prog_fd, file))\r\nerror(1, errno, "bpf_obj_pin");\r\nif (strlen(file) > 50) {\r\nprintf("file path too long: %s\n", file);\r\nexit(1);\r\n}\r\nsprintf(rules, "iptables -A OUTPUT -m bpf --object-pinned %s -j ACCEPT",\r\nfile);\r\nret = system(rules);\r\nif (ret < 0) {\r\nprintf("iptables rule update failed: %d/n", WEXITSTATUS(ret));\r\nexit(1);\r\n}\r\n}\r\nstatic void print_table(void)\r\n{\r\nstruct stats curEntry;\r\nuint32_t curN = UINT32_MAX;\r\nuint32_t nextN;\r\nint res;\r\nwhile (bpf_map_get_next_key(map_fd, &curN, &nextN) > -1) {\r\ncurN = nextN;\r\nres = bpf_map_lookup_elem(map_fd, &curN, &curEntry);\r\nif (res < 0) {\r\nerror(1, errno, "fail to get entry value of Key: %u\n",\r\ncurN);\r\n} else {\r\nprintf("cookie: %u, uid: 0x%x, Packet Count: %lu,"\r\n" Bytes Count: %lu\n", curN, curEntry.uid,\r\ncurEntry.packets, curEntry.bytes);\r\n}\r\n}\r\n}\r\nstatic void udp_client(void)\r\n{\r\nstruct sockaddr_in si_other = {0};\r\nstruct sockaddr_in si_me = {0};\r\nstruct stats dataEntry;\r\nint s_rcv, s_send, i, recv_len;\r\nchar message = 'a';\r\nchar buf;\r\nuint64_t cookie;\r\nint res;\r\nsocklen_t cookie_len = sizeof(cookie);\r\nsocklen_t slen = sizeof(si_other);\r\ns_rcv = socket(PF_INET, SOCK_DGRAM, 0);\r\nif (s_rcv < 0)\r\nerror(1, errno, "rcv socket creat failed!\n");\r\nsi_other.sin_family = AF_INET;\r\nsi_other.sin_port = htons(PORT);\r\nif (inet_aton("127.0.0.1", &si_other.sin_addr) == 0)\r\nerror(1, errno, "inet_aton\n");\r\nif (bind(s_rcv, (struct sockaddr *)&si_other, sizeof(si_other)) == -1)\r\nerror(1, errno, "bind\n");\r\ns_send = socket(PF_INET, SOCK_DGRAM, 0);\r\nif (s_send < 0)\r\nerror(1, errno, "send socket creat failed!\n");\r\nres = getsockopt(s_send, SOL_SOCKET, SO_COOKIE, &cookie, &cookie_len);\r\nif (res < 0)\r\nprintf("get cookie failed: %s\n", strerror(errno));\r\nres = bpf_map_lookup_elem(map_fd, &cookie, &dataEntry);\r\nif (res != -1)\r\nerror(1, errno, "socket stat found while flow not active\n");\r\nfor (i = 0; i < 10; i++) {\r\nres = sendto(s_send, &message, sizeof(message), 0,\r\n(struct sockaddr *)&si_other, slen);\r\nif (res == -1)\r\nerror(1, errno, "send\n");\r\nif (res != sizeof(message))\r\nerror(1, 0, "%uB != %luB\n", res, sizeof(message));\r\nrecv_len = recvfrom(s_rcv, &buf, sizeof(buf), 0,\r\n(struct sockaddr *)&si_me, &slen);\r\nif (recv_len < 0)\r\nerror(1, errno, "revieve\n");\r\nres = memcmp(&(si_other.sin_addr), &(si_me.sin_addr),\r\nsizeof(si_me.sin_addr));\r\nif (res != 0)\r\nerror(1, EFAULT, "sender addr error: %d\n", res);\r\nprintf("Message received: %c\n", buf);\r\nres = bpf_map_lookup_elem(map_fd, &cookie, &dataEntry);\r\nif (res < 0)\r\nerror(1, errno, "lookup sk stat failed, cookie: %lu\n",\r\ncookie);\r\nprintf("cookie: %lu, uid: 0x%x, Packet Count: %lu,"\r\n" Bytes Count: %lu\n\n", cookie, dataEntry.uid,\r\ndataEntry.packets, dataEntry.bytes);\r\n}\r\nclose(s_send);\r\nclose(s_rcv);\r\n}\r\nstatic int usage(void)\r\n{\r\nprintf("Usage: ./run_cookie_uid_helper_example.sh"\r\n" bpfObjName -option\n"\r\n" -t traffic monitor test\n"\r\n" -s getsockopt cookie test\n");\r\nreturn 1;\r\n}\r\nstatic void finish(int ret)\r\n{\r\ntest_finish = true;\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nint opt;\r\nbool cfg_test_traffic = false;\r\nbool cfg_test_cookie = false;\r\nif (argc != 3)\r\nreturn usage();\r\nwhile ((opt = getopt(argc, argv, "ts")) != -1) {\r\nswitch (opt) {\r\ncase 't':\r\ncfg_test_traffic = true;\r\nbreak;\r\ncase 's':\r\ncfg_test_cookie = true;\r\nbreak;\r\ndefault:\r\nprintf("unknown option %c\n", opt);\r\nusage();\r\nreturn -1;\r\n}\r\n}\r\nmaps_create();\r\nprog_load();\r\nprog_attach_iptables(argv[2]);\r\nif (cfg_test_traffic) {\r\nif (signal(SIGINT, finish) == SIG_ERR)\r\nerror(1, errno, "register SIGINT handler failed");\r\nif (signal(SIGTERM, finish) == SIG_ERR)\r\nerror(1, errno, "register SIGTERM handler failed");\r\nwhile (!test_finish) {\r\nprint_table();\r\nprintf("\n");\r\nsleep(1);\r\n};\r\n} else if (cfg_test_cookie) {\r\nudp_client();\r\n}\r\nclose(prog_fd);\r\nclose(map_fd);\r\nreturn 0;\r\n}
