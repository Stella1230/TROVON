static void file_work(struct work_struct *work)\r\n{\r\nstruct atomisp_file_device *file_dev =\r\ncontainer_of(work, struct atomisp_file_device, work);\r\nstruct atomisp_device *isp = file_dev->isp;\r\nstruct atomisp_sub_device *asd = &isp->asd[0];\r\nstruct atomisp_video_pipe *out_pipe = &asd->video_in;\r\nunsigned short *buf = videobuf_to_vmalloc(out_pipe->outq.bufs[0]);\r\nstruct v4l2_mbus_framefmt isp_sink_fmt;\r\nif (asd->streaming != ATOMISP_DEVICE_STREAMING_ENABLED)\r\nreturn;\r\ndev_dbg(isp->dev, ">%s: ready to start streaming\n", __func__);\r\nisp_sink_fmt = *atomisp_subdev_get_ffmt(&asd->subdev, NULL,\r\nV4L2_SUBDEV_FORMAT_ACTIVE,\r\nATOMISP_SUBDEV_PAD_SINK);\r\nwhile (!atomisp_css_isp_has_started())\r\nusleep_range(1000, 1500);\r\natomisp_css_send_input_frame(asd, buf, isp_sink_fmt.width,\r\nisp_sink_fmt.height);\r\ndev_dbg(isp->dev, "<%s: streaming done\n", __func__);\r\n}\r\nstatic int file_input_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct atomisp_file_device *file_dev = v4l2_get_subdevdata(sd);\r\nstruct atomisp_device *isp = file_dev->isp;\r\nstruct atomisp_sub_device *asd = &isp->asd[0];\r\ndev_dbg(isp->dev, "%s: enable %d\n", __func__, enable);\r\nif (enable) {\r\nif (asd->streaming != ATOMISP_DEVICE_STREAMING_ENABLED)\r\nreturn 0;\r\nqueue_work(file_dev->work_queue, &file_dev->work);\r\nreturn 0;\r\n}\r\ncancel_work_sync(&file_dev->work);\r\nreturn 0;\r\n}\r\nstatic int file_input_g_parm(struct v4l2_subdev *sd,\r\nstruct v4l2_streamparm *param)\r\n{\r\nreturn 0;\r\n}\r\nstatic int file_input_s_parm(struct v4l2_subdev *sd,\r\nstruct v4l2_streamparm *param)\r\n{\r\nreturn 0;\r\n}\r\nstatic int file_input_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *fmt = &format->format;\r\nstruct atomisp_file_device *file_dev = v4l2_get_subdevdata(sd);\r\nstruct atomisp_device *isp = file_dev->isp;\r\nstruct atomisp_sub_device *asd = &isp->asd[0];\r\nstruct v4l2_mbus_framefmt *isp_sink_fmt;\r\nif (format->pad)\r\nreturn -EINVAL;\r\nisp_sink_fmt = atomisp_subdev_get_ffmt(&asd->subdev, NULL,\r\nV4L2_SUBDEV_FORMAT_ACTIVE,\r\nATOMISP_SUBDEV_PAD_SINK);\r\nfmt->width = isp_sink_fmt->width;\r\nfmt->height = isp_sink_fmt->height;\r\nfmt->code = isp_sink_fmt->code;\r\nreturn 0;\r\n}\r\nstatic int file_input_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *fmt = &format->format;\r\nif (format->pad)\r\nreturn -EINVAL;\r\nfile_input_get_fmt(sd, cfg, format);\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY)\r\ncfg->try_fmt = *fmt;\r\nreturn 0;\r\n}\r\nstatic int file_input_log_status(struct v4l2_subdev *sd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int file_input_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nreturn 0;\r\n}\r\nstatic int file_input_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nreturn 0;\r\n}\r\nstatic int file_input_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nreturn 0;\r\n}\r\nstatic int file_input_enum_frame_ival(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_interval_enum\r\n*fie)\r\n{\r\nreturn 0;\r\n}\r\nvoid\r\natomisp_file_input_unregister_entities(struct atomisp_file_device *file_dev)\r\n{\r\nmedia_entity_cleanup(&file_dev->sd.entity);\r\nv4l2_device_unregister_subdev(&file_dev->sd);\r\n}\r\nint atomisp_file_input_register_entities(struct atomisp_file_device *file_dev,\r\nstruct v4l2_device *vdev)\r\n{\r\nreturn v4l2_device_register_subdev(vdev, &file_dev->sd);\r\n}\r\nvoid atomisp_file_input_cleanup(struct atomisp_device *isp)\r\n{\r\nstruct atomisp_file_device *file_dev = &isp->file_dev;\r\nif (file_dev->work_queue) {\r\ndestroy_workqueue(file_dev->work_queue);\r\nfile_dev->work_queue = NULL;\r\n}\r\n}\r\nint atomisp_file_input_init(struct atomisp_device *isp)\r\n{\r\nstruct atomisp_file_device *file_dev = &isp->file_dev;\r\nstruct v4l2_subdev *sd = &file_dev->sd;\r\nstruct media_pad *pads = file_dev->pads;\r\nstruct media_entity *me = &sd->entity;\r\nfile_dev->isp = isp;\r\nfile_dev->work_queue = alloc_workqueue(isp->v4l2_dev.name, 0, 1);\r\nif (file_dev->work_queue == NULL) {\r\ndev_err(isp->dev, "Failed to initialize file inject workq\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_WORK(&file_dev->work, file_work);\r\nv4l2_subdev_init(sd, &file_input_ops);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nstrcpy(sd->name, "file_input_subdev");\r\nv4l2_set_subdevdata(sd, file_dev);\r\npads[0].flags = MEDIA_PAD_FL_SINK;\r\nme->function = MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN;\r\nreturn media_entity_pads_init(me, 1, pads);\r\n}
