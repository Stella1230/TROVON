bool __pure glob_match(char const *pat, char const *str)\r\n{\r\nchar const *back_pat = NULL, *back_str = back_str;\r\nfor (;;) {\r\nunsigned char c = *str++;\r\nunsigned char d = *pat++;\r\nswitch (d) {\r\ncase '?':\r\nif (c == '\0')\r\nreturn false;\r\nbreak;\r\ncase '*':\r\nif (*pat == '\0')\r\nreturn true;\r\nback_pat = pat;\r\nback_str = --str;\r\nbreak;\r\ncase '[': {\r\nbool match = false, inverted = (*pat == '!');\r\nchar const *class = pat + inverted;\r\nunsigned char a = *class++;\r\ndo {\r\nunsigned char b = a;\r\nif (a == '\0')\r\ngoto literal;\r\nif (class[0] == '-' && class[1] != ']') {\r\nb = class[1];\r\nif (b == '\0')\r\ngoto literal;\r\nclass += 2;\r\n}\r\nmatch |= (a <= c && c <= b);\r\n} while ((a = *class++) != ']');\r\nif (match == inverted)\r\ngoto backtrack;\r\npat = class;\r\n}\r\nbreak;\r\ncase '\\':\r\nd = *pat++;\r\ndefault:\r\nliteral:\r\nif (c == d) {\r\nif (d == '\0')\r\nreturn true;\r\nbreak;\r\n}\r\nbacktrack:\r\nif (c == '\0' || !back_pat)\r\nreturn false;\r\npat = back_pat;\r\nstr = ++back_str;\r\nbreak;\r\n}\r\n}\r\n}
