static int nd_region_probe(struct device *dev)\r\n{\r\nint err, rc;\r\nstatic unsigned long once;\r\nstruct nd_region_data *ndrd;\r\nstruct nd_region *nd_region = to_nd_region(dev);\r\nif (nd_region->num_lanes > num_online_cpus()\r\n&& nd_region->num_lanes < num_possible_cpus()\r\n&& !test_and_set_bit(0, &once)) {\r\ndev_info(dev, "online cpus (%d) < concurrent i/o lanes (%d) < possible cpus (%d)\n",\r\nnum_online_cpus(), nd_region->num_lanes,\r\nnum_possible_cpus());\r\ndev_info(dev, "setting nr_cpus=%d may yield better libnvdimm device performance\n",\r\nnd_region->num_lanes);\r\n}\r\nrc = nd_region_activate(nd_region);\r\nif (rc)\r\nreturn rc;\r\nrc = nd_blk_region_init(nd_region);\r\nif (rc)\r\nreturn rc;\r\nrc = nd_region_register_namespaces(nd_region, &err);\r\nif (rc < 0)\r\nreturn rc;\r\nndrd = dev_get_drvdata(dev);\r\nndrd->ns_active = rc;\r\nndrd->ns_count = rc + err;\r\nif (rc && err && rc == err)\r\nreturn -ENODEV;\r\nif (is_nd_pmem(&nd_region->dev)) {\r\nstruct resource ndr_res;\r\nif (devm_init_badblocks(dev, &nd_region->bb))\r\nreturn -ENODEV;\r\nnd_region->bb_state = sysfs_get_dirent(nd_region->dev.kobj.sd,\r\n"badblocks");\r\nif (!nd_region->bb_state)\r\ndev_warn(&nd_region->dev,\r\n"'badblocks' notification disabled\n");\r\nndr_res.start = nd_region->ndr_start;\r\nndr_res.end = nd_region->ndr_start + nd_region->ndr_size - 1;\r\nnvdimm_badblocks_populate(nd_region, &nd_region->bb, &ndr_res);\r\n}\r\nnd_region->btt_seed = nd_btt_create(nd_region);\r\nnd_region->pfn_seed = nd_pfn_create(nd_region);\r\nnd_region->dax_seed = nd_dax_create(nd_region);\r\nif (err == 0)\r\nreturn 0;\r\ndev_err(dev, "failed to register %d namespace%s, continuing...\n",\r\nerr, err == 1 ? "" : "s");\r\nreturn 0;\r\n}\r\nstatic int child_unregister(struct device *dev, void *data)\r\n{\r\nnd_device_unregister(dev, ND_SYNC);\r\nreturn 0;\r\n}\r\nstatic int nd_region_remove(struct device *dev)\r\n{\r\nstruct nd_region *nd_region = to_nd_region(dev);\r\ndevice_for_each_child(dev, NULL, child_unregister);\r\nnvdimm_bus_lock(dev);\r\nnd_region->ns_seed = NULL;\r\nnd_region->btt_seed = NULL;\r\nnd_region->pfn_seed = NULL;\r\nnd_region->dax_seed = NULL;\r\ndev_set_drvdata(dev, NULL);\r\nnvdimm_bus_unlock(dev);\r\nsysfs_put(nd_region->bb_state);\r\nnd_region->bb_state = NULL;\r\nreturn 0;\r\n}\r\nstatic int child_notify(struct device *dev, void *data)\r\n{\r\nnd_device_notify(dev, *(enum nvdimm_event *) data);\r\nreturn 0;\r\n}\r\nstatic void nd_region_notify(struct device *dev, enum nvdimm_event event)\r\n{\r\nif (event == NVDIMM_REVALIDATE_POISON) {\r\nstruct nd_region *nd_region = to_nd_region(dev);\r\nstruct resource res;\r\nif (is_nd_pmem(&nd_region->dev)) {\r\nres.start = nd_region->ndr_start;\r\nres.end = nd_region->ndr_start +\r\nnd_region->ndr_size - 1;\r\nnvdimm_badblocks_populate(nd_region,\r\n&nd_region->bb, &res);\r\nif (nd_region->bb_state)\r\nsysfs_notify_dirent(nd_region->bb_state);\r\n}\r\n}\r\ndevice_for_each_child(dev, &event, child_notify);\r\n}\r\nint __init nd_region_init(void)\r\n{\r\nreturn nd_driver_register(&nd_region_driver);\r\n}\r\nvoid nd_region_exit(void)\r\n{\r\ndriver_unregister(&nd_region_driver.drv);\r\n}
