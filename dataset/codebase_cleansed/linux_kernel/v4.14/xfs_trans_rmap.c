static void\r\nxfs_trans_set_rmap_flags(\r\nstruct xfs_map_extent *rmap,\r\nenum xfs_rmap_intent_type type,\r\nint whichfork,\r\nxfs_exntst_t state)\r\n{\r\nrmap->me_flags = 0;\r\nif (state == XFS_EXT_UNWRITTEN)\r\nrmap->me_flags |= XFS_RMAP_EXTENT_UNWRITTEN;\r\nif (whichfork == XFS_ATTR_FORK)\r\nrmap->me_flags |= XFS_RMAP_EXTENT_ATTR_FORK;\r\nswitch (type) {\r\ncase XFS_RMAP_MAP:\r\nrmap->me_flags |= XFS_RMAP_EXTENT_MAP;\r\nbreak;\r\ncase XFS_RMAP_MAP_SHARED:\r\nrmap->me_flags |= XFS_RMAP_EXTENT_MAP_SHARED;\r\nbreak;\r\ncase XFS_RMAP_UNMAP:\r\nrmap->me_flags |= XFS_RMAP_EXTENT_UNMAP;\r\nbreak;\r\ncase XFS_RMAP_UNMAP_SHARED:\r\nrmap->me_flags |= XFS_RMAP_EXTENT_UNMAP_SHARED;\r\nbreak;\r\ncase XFS_RMAP_CONVERT:\r\nrmap->me_flags |= XFS_RMAP_EXTENT_CONVERT;\r\nbreak;\r\ncase XFS_RMAP_CONVERT_SHARED:\r\nrmap->me_flags |= XFS_RMAP_EXTENT_CONVERT_SHARED;\r\nbreak;\r\ncase XFS_RMAP_ALLOC:\r\nrmap->me_flags |= XFS_RMAP_EXTENT_ALLOC;\r\nbreak;\r\ncase XFS_RMAP_FREE:\r\nrmap->me_flags |= XFS_RMAP_EXTENT_FREE;\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\n}\r\n}\r\nstruct xfs_rud_log_item *\r\nxfs_trans_get_rud(\r\nstruct xfs_trans *tp,\r\nstruct xfs_rui_log_item *ruip)\r\n{\r\nstruct xfs_rud_log_item *rudp;\r\nrudp = xfs_rud_init(tp->t_mountp, ruip);\r\nxfs_trans_add_item(tp, &rudp->rud_item);\r\nreturn rudp;\r\n}\r\nint\r\nxfs_trans_log_finish_rmap_update(\r\nstruct xfs_trans *tp,\r\nstruct xfs_rud_log_item *rudp,\r\nenum xfs_rmap_intent_type type,\r\nuint64_t owner,\r\nint whichfork,\r\nxfs_fileoff_t startoff,\r\nxfs_fsblock_t startblock,\r\nxfs_filblks_t blockcount,\r\nxfs_exntst_t state,\r\nstruct xfs_btree_cur **pcur)\r\n{\r\nint error;\r\nerror = xfs_rmap_finish_one(tp, type, owner, whichfork, startoff,\r\nstartblock, blockcount, state, pcur);\r\ntp->t_flags |= XFS_TRANS_DIRTY;\r\nrudp->rud_item.li_desc->lid_flags |= XFS_LID_DIRTY;\r\nreturn error;\r\n}\r\nstatic int\r\nxfs_rmap_update_diff_items(\r\nvoid *priv,\r\nstruct list_head *a,\r\nstruct list_head *b)\r\n{\r\nstruct xfs_mount *mp = priv;\r\nstruct xfs_rmap_intent *ra;\r\nstruct xfs_rmap_intent *rb;\r\nra = container_of(a, struct xfs_rmap_intent, ri_list);\r\nrb = container_of(b, struct xfs_rmap_intent, ri_list);\r\nreturn XFS_FSB_TO_AGNO(mp, ra->ri_bmap.br_startblock) -\r\nXFS_FSB_TO_AGNO(mp, rb->ri_bmap.br_startblock);\r\n}\r\nSTATIC void *\r\nxfs_rmap_update_create_intent(\r\nstruct xfs_trans *tp,\r\nunsigned int count)\r\n{\r\nstruct xfs_rui_log_item *ruip;\r\nASSERT(tp != NULL);\r\nASSERT(count > 0);\r\nruip = xfs_rui_init(tp->t_mountp, count);\r\nASSERT(ruip != NULL);\r\nxfs_trans_add_item(tp, &ruip->rui_item);\r\nreturn ruip;\r\n}\r\nSTATIC void\r\nxfs_rmap_update_log_item(\r\nstruct xfs_trans *tp,\r\nvoid *intent,\r\nstruct list_head *item)\r\n{\r\nstruct xfs_rui_log_item *ruip = intent;\r\nstruct xfs_rmap_intent *rmap;\r\nuint next_extent;\r\nstruct xfs_map_extent *map;\r\nrmap = container_of(item, struct xfs_rmap_intent, ri_list);\r\ntp->t_flags |= XFS_TRANS_DIRTY;\r\nruip->rui_item.li_desc->lid_flags |= XFS_LID_DIRTY;\r\nnext_extent = atomic_inc_return(&ruip->rui_next_extent) - 1;\r\nASSERT(next_extent < ruip->rui_format.rui_nextents);\r\nmap = &ruip->rui_format.rui_extents[next_extent];\r\nmap->me_owner = rmap->ri_owner;\r\nmap->me_startblock = rmap->ri_bmap.br_startblock;\r\nmap->me_startoff = rmap->ri_bmap.br_startoff;\r\nmap->me_len = rmap->ri_bmap.br_blockcount;\r\nxfs_trans_set_rmap_flags(map, rmap->ri_type, rmap->ri_whichfork,\r\nrmap->ri_bmap.br_state);\r\n}\r\nSTATIC void *\r\nxfs_rmap_update_create_done(\r\nstruct xfs_trans *tp,\r\nvoid *intent,\r\nunsigned int count)\r\n{\r\nreturn xfs_trans_get_rud(tp, intent);\r\n}\r\nSTATIC int\r\nxfs_rmap_update_finish_item(\r\nstruct xfs_trans *tp,\r\nstruct xfs_defer_ops *dop,\r\nstruct list_head *item,\r\nvoid *done_item,\r\nvoid **state)\r\n{\r\nstruct xfs_rmap_intent *rmap;\r\nint error;\r\nrmap = container_of(item, struct xfs_rmap_intent, ri_list);\r\nerror = xfs_trans_log_finish_rmap_update(tp, done_item,\r\nrmap->ri_type,\r\nrmap->ri_owner, rmap->ri_whichfork,\r\nrmap->ri_bmap.br_startoff,\r\nrmap->ri_bmap.br_startblock,\r\nrmap->ri_bmap.br_blockcount,\r\nrmap->ri_bmap.br_state,\r\n(struct xfs_btree_cur **)state);\r\nkmem_free(rmap);\r\nreturn error;\r\n}\r\nSTATIC void\r\nxfs_rmap_update_finish_cleanup(\r\nstruct xfs_trans *tp,\r\nvoid *state,\r\nint error)\r\n{\r\nstruct xfs_btree_cur *rcur = state;\r\nxfs_rmap_finish_one_cleanup(tp, rcur, error);\r\n}\r\nSTATIC void\r\nxfs_rmap_update_abort_intent(\r\nvoid *intent)\r\n{\r\nxfs_rui_release(intent);\r\n}\r\nSTATIC void\r\nxfs_rmap_update_cancel_item(\r\nstruct list_head *item)\r\n{\r\nstruct xfs_rmap_intent *rmap;\r\nrmap = container_of(item, struct xfs_rmap_intent, ri_list);\r\nkmem_free(rmap);\r\n}\r\nvoid\r\nxfs_rmap_update_init_defer_op(void)\r\n{\r\nxfs_defer_init_op_type(&xfs_rmap_update_defer_type);\r\n}
