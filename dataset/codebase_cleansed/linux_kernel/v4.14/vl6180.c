static int vl6180_read(struct i2c_client *client, u16 cmd, void *databuf,\r\nu8 len)\r\n{\r\n__be16 cmdbuf = cpu_to_be16(cmd);\r\nstruct i2c_msg msgs[2] = {\r\n{ .addr = client->addr, .len = sizeof(cmdbuf), .buf = (u8 *) &cmdbuf },\r\n{ .addr = client->addr, .len = len, .buf = databuf,\r\n.flags = I2C_M_RD } };\r\nint ret;\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret < 0)\r\ndev_err(&client->dev, "failed reading register 0x%04x\n", cmd);\r\nreturn ret;\r\n}\r\nstatic int vl6180_read_byte(struct i2c_client *client, u16 cmd)\r\n{\r\nu8 data;\r\nint ret;\r\nret = vl6180_read(client, cmd, &data, sizeof(data));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn data;\r\n}\r\nstatic int vl6180_read_word(struct i2c_client *client, u16 cmd)\r\n{\r\n__be16 data;\r\nint ret;\r\nret = vl6180_read(client, cmd, &data, sizeof(data));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn be16_to_cpu(data);\r\n}\r\nstatic int vl6180_write_byte(struct i2c_client *client, u16 cmd, u8 val)\r\n{\r\nu8 buf[3];\r\nstruct i2c_msg msgs[1] = {\r\n{ .addr = client->addr, .len = sizeof(buf), .buf = (u8 *) &buf } };\r\nint ret;\r\nbuf[0] = cmd >> 8;\r\nbuf[1] = cmd & 0xff;\r\nbuf[2] = val;\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed writing register 0x%04x\n", cmd);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vl6180_write_word(struct i2c_client *client, u16 cmd, u16 val)\r\n{\r\n__be16 buf[2];\r\nstruct i2c_msg msgs[1] = {\r\n{ .addr = client->addr, .len = sizeof(buf), .buf = (u8 *) &buf } };\r\nint ret;\r\nbuf[0] = cpu_to_be16(cmd);\r\nbuf[1] = cpu_to_be16(val);\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed writing register 0x%04x\n", cmd);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vl6180_measure(struct vl6180_data *data, int addr)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint tries = 20, ret;\r\nu16 value;\r\nmutex_lock(&data->lock);\r\nret = vl6180_write_byte(client,\r\nvl6180_chan_regs_table[addr].start_reg, VL6180_STARTSTOP);\r\nif (ret < 0)\r\ngoto fail;\r\nwhile (tries--) {\r\nret = vl6180_read_byte(client, VL6180_INTR_STATUS);\r\nif (ret < 0)\r\ngoto fail;\r\nif (ret & vl6180_chan_regs_table[addr].drdy_mask)\r\nbreak;\r\nmsleep(20);\r\n}\r\nif (tries < 0) {\r\nret = -EIO;\r\ngoto fail;\r\n}\r\nret = vl6180_chan_regs_table[addr].word ?\r\nvl6180_read_word(client, vl6180_chan_regs_table[addr].value_reg) :\r\nvl6180_read_byte(client, vl6180_chan_regs_table[addr].value_reg);\r\nif (ret < 0)\r\ngoto fail;\r\nvalue = ret;\r\nret = vl6180_write_byte(client, VL6180_INTR_CLEAR,\r\nVL6180_CLEAR_ERROR | VL6180_CLEAR_ALS | VL6180_CLEAR_RANGE);\r\nif (ret < 0)\r\ngoto fail;\r\nret = value;\r\nfail:\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int vl6180_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct vl6180_data *data = iio_priv(indio_dev);\r\nint ret, i;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = vl6180_measure(data, chan->address);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_INT_TIME:\r\nret = vl6180_read_word(data->client, VL6180_ALS_IT);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = 0;\r\n*val2 = (ret + 1) * 1000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_LIGHT:\r\n*val = 0;\r\n*val2 = 320000;\r\nbreak;\r\ncase IIO_DISTANCE:\r\n*val = 0;\r\n*val2 = 1000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_CHAN_INFO_HARDWAREGAIN:\r\nret = vl6180_read_byte(data->client, VL6180_ALS_GAIN);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(vl6180_als_gain); i++) {\r\nif (ret == vl6180_als_gain[i][2]) {\r\n*val = vl6180_als_gain[i][0];\r\n*val2 = vl6180_als_gain[i][1];\r\n}\r\n}\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int vl6180_hold(struct vl6180_data *data, bool hold)\r\n{\r\nreturn vl6180_write_byte(data->client, VL6180_HOLD,\r\nhold ? VL6180_HOLD_ON : 0);\r\n}\r\nstatic int vl6180_set_als_gain(struct vl6180_data *data, int val, int val2)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < ARRAY_SIZE(vl6180_als_gain); i++) {\r\nif (val == vl6180_als_gain[i][0] &&\r\nval2 == vl6180_als_gain[i][1]) {\r\nmutex_lock(&data->lock);\r\nret = vl6180_hold(data, true);\r\nif (ret < 0)\r\ngoto fail;\r\nret = vl6180_write_byte(data->client, VL6180_ALS_GAIN,\r\nvl6180_als_gain[i][3]);\r\nfail:\r\nvl6180_hold(data, false);\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vl6180_set_it(struct vl6180_data *data, int val2)\r\n{\r\nint ret;\r\nmutex_lock(&data->lock);\r\nret = vl6180_hold(data, true);\r\nif (ret < 0)\r\ngoto fail;\r\nret = vl6180_write_word(data->client, VL6180_ALS_IT,\r\n(val2 - 500) / 1000);\r\nfail:\r\nvl6180_hold(data, false);\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int vl6180_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct vl6180_data *data = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_INT_TIME:\r\nif (val != 0 || val2 < 500 || val2 >= 512500)\r\nreturn -EINVAL;\r\nreturn vl6180_set_it(data, val2);\r\ncase IIO_CHAN_INFO_HARDWAREGAIN:\r\nif (chan->type != IIO_LIGHT)\r\nreturn -EINVAL;\r\nreturn vl6180_set_als_gain(data, val, val2);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int vl6180_init(struct vl6180_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nret = vl6180_read_byte(client, VL6180_MODEL_ID);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != VL6180_MODEL_ID_VAL) {\r\ndev_err(&client->dev, "invalid model ID %02x\n", ret);\r\nreturn -ENODEV;\r\n}\r\nret = vl6180_hold(data, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = vl6180_read_byte(client, VL6180_OUT_OF_RESET);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != 0x01)\r\ndev_info(&client->dev, "device is not fresh out of reset\n");\r\nret = vl6180_write_byte(client, VL6180_INTR_CONFIG,\r\nVL6180_ALS_READY | VL6180_RANGE_READY);\r\nif (ret < 0)\r\nreturn ret;\r\nret = vl6180_write_word(client, VL6180_ALS_IT, VL6180_ALS_IT_100);\r\nif (ret < 0)\r\nreturn ret;\r\nret = vl6180_write_byte(client, VL6180_ALS_GAIN, VL6180_ALS_GAIN_1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = vl6180_write_byte(client, VL6180_OUT_OF_RESET, 0x00);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn vl6180_hold(data, false);\r\n}\r\nstatic int vl6180_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct vl6180_data *data;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\ndata->client = client;\r\nmutex_init(&data->lock);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->info = &vl6180_info;\r\nindio_dev->channels = vl6180_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(vl6180_channels);\r\nindio_dev->name = VL6180_DRV_NAME;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nret = vl6180_init(data);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn devm_iio_device_register(&client->dev, indio_dev);\r\n}
