static inline u32 b1prot(int l2, int l3)\r\n{\r\nswitch (l2) {\r\ncase ISDN_PROTO_L2_X75I:\r\ncase ISDN_PROTO_L2_X75UI:\r\ncase ISDN_PROTO_L2_X75BUI:\r\nreturn 0;\r\ncase ISDN_PROTO_L2_HDLC:\r\ndefault:\r\nreturn 0;\r\ncase ISDN_PROTO_L2_TRANS:\r\nreturn 1;\r\ncase ISDN_PROTO_L2_V11096:\r\ncase ISDN_PROTO_L2_V11019:\r\ncase ISDN_PROTO_L2_V11038:\r\nreturn 2;\r\ncase ISDN_PROTO_L2_FAX:\r\nreturn 4;\r\ncase ISDN_PROTO_L2_MODEM:\r\nreturn 8;\r\n}\r\n}\r\nstatic inline u32 b2prot(int l2, int l3)\r\n{\r\nswitch (l2) {\r\ncase ISDN_PROTO_L2_X75I:\r\ncase ISDN_PROTO_L2_X75UI:\r\ncase ISDN_PROTO_L2_X75BUI:\r\ndefault:\r\nreturn 0;\r\ncase ISDN_PROTO_L2_HDLC:\r\ncase ISDN_PROTO_L2_TRANS:\r\ncase ISDN_PROTO_L2_V11096:\r\ncase ISDN_PROTO_L2_V11019:\r\ncase ISDN_PROTO_L2_V11038:\r\ncase ISDN_PROTO_L2_MODEM:\r\nreturn 1;\r\ncase ISDN_PROTO_L2_FAX:\r\nreturn 4;\r\n}\r\n}\r\nstatic inline u32 b3prot(int l2, int l3)\r\n{\r\nswitch (l2) {\r\ncase ISDN_PROTO_L2_X75I:\r\ncase ISDN_PROTO_L2_X75UI:\r\ncase ISDN_PROTO_L2_X75BUI:\r\ncase ISDN_PROTO_L2_HDLC:\r\ncase ISDN_PROTO_L2_TRANS:\r\ncase ISDN_PROTO_L2_V11096:\r\ncase ISDN_PROTO_L2_V11019:\r\ncase ISDN_PROTO_L2_V11038:\r\ncase ISDN_PROTO_L2_MODEM:\r\ndefault:\r\nreturn 0;\r\ncase ISDN_PROTO_L2_FAX:\r\nreturn 4;\r\n}\r\n}\r\nstatic _cstruct b1config_async_v110(u16 rate)\r\n{\r\nstatic unsigned char buf[9];\r\nbuf[0] = 8;\r\nbuf[1] = rate & 0xff; buf[2] = (rate >> 8) & 0xff;\r\nbuf[3] = 8; buf[4] = 0;\r\nbuf[5] = 0; buf[6] = 0;\r\nbuf[7] = 0; buf[8] = 0;\r\nreturn buf;\r\n}\r\nstatic _cstruct b1config(int l2, int l3)\r\n{\r\nswitch (l2) {\r\ncase ISDN_PROTO_L2_X75I:\r\ncase ISDN_PROTO_L2_X75UI:\r\ncase ISDN_PROTO_L2_X75BUI:\r\ncase ISDN_PROTO_L2_HDLC:\r\ncase ISDN_PROTO_L2_TRANS:\r\ndefault:\r\nreturn NULL;\r\ncase ISDN_PROTO_L2_V11096:\r\nreturn b1config_async_v110(9600);\r\ncase ISDN_PROTO_L2_V11019:\r\nreturn b1config_async_v110(19200);\r\ncase ISDN_PROTO_L2_V11038:\r\nreturn b1config_async_v110(38400);\r\n}\r\n}\r\nstatic inline u16 si2cip(u8 si1, u8 si2)\r\n{\r\nstatic const u8 cip[17][5] =\r\n{\r\n{0, 0, 0, 0, 0},\r\n{16, 16, 4, 26, 16},\r\n{17, 17, 17, 4, 4},\r\n{2, 2, 2, 2, 2},\r\n{18, 18, 18, 18, 18},\r\n{2, 2, 2, 2, 2},\r\n{0, 0, 0, 0, 0},\r\n{2, 2, 2, 2, 2},\r\n{2, 2, 2, 2, 2},\r\n{21, 21, 21, 21, 21},\r\n{19, 19, 19, 19, 19},\r\n{0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0},\r\n{22, 22, 22, 22, 22},\r\n{27, 27, 27, 28, 27}\r\n};\r\nif (si1 > 16)\r\nsi1 = 0;\r\nif (si2 > 4)\r\nsi2 = 0;\r\nreturn (u16) cip[si1][si2];\r\n}\r\nstatic inline u8 cip2si1(u16 cipval)\r\n{\r\nstatic const u8 si[32] =\r\n{7, 1, 7, 7, 1, 1, 7, 7,\r\n7, 1, 0, 0, 0, 0, 0, 0,\r\n1, 2, 4, 10, 9, 9, 15, 7,\r\n7, 7, 1, 16, 16, 0, 0, 0};\r\nif (cipval > 31)\r\ncipval = 0;\r\nreturn si[cipval];\r\n}\r\nstatic inline u8 cip2si2(u16 cipval)\r\n{\r\nstatic const u8 si[32] =\r\n{0, 0, 0, 0, 2, 3, 0, 0,\r\n0, 3, 0, 0, 0, 0, 0, 0,\r\n1, 2, 0, 0, 9, 0, 0, 0,\r\n0, 0, 3, 2, 3, 0, 0, 0};\r\nif (cipval > 31)\r\ncipval = 0;\r\nreturn si[cipval];\r\n}\r\nstatic inline capidrv_contr *findcontrbydriverid(int driverid)\r\n{\r\nunsigned long flags;\r\ncapidrv_contr *p;\r\nspin_lock_irqsave(&global_lock, flags);\r\nfor (p = global.contr_list; p; p = p->next)\r\nif (p->myid == driverid)\r\nbreak;\r\nspin_unlock_irqrestore(&global_lock, flags);\r\nreturn p;\r\n}\r\nstatic capidrv_contr *findcontrbynumber(u32 contr)\r\n{\r\nunsigned long flags;\r\ncapidrv_contr *p = global.contr_list;\r\nspin_lock_irqsave(&global_lock, flags);\r\nfor (p = global.contr_list; p; p = p->next)\r\nif (p->contrnr == contr)\r\nbreak;\r\nspin_unlock_irqrestore(&global_lock, flags);\r\nreturn p;\r\n}\r\nstatic capidrv_plci *new_plci(capidrv_contr *card, int chan)\r\n{\r\ncapidrv_plci *plcip;\r\nplcip = kzalloc(sizeof(capidrv_plci), GFP_ATOMIC);\r\nif (plcip == NULL)\r\nreturn NULL;\r\nplcip->state = ST_PLCI_NONE;\r\nplcip->plci = 0;\r\nplcip->msgid = 0;\r\nplcip->chan = chan;\r\nplcip->next = card->plci_list;\r\ncard->plci_list = plcip;\r\ncard->bchans[chan].plcip = plcip;\r\nreturn plcip;\r\n}\r\nstatic capidrv_plci *find_plci_by_plci(capidrv_contr *card, u32 plci)\r\n{\r\ncapidrv_plci *p;\r\nfor (p = card->plci_list; p; p = p->next)\r\nif (p->plci == plci)\r\nreturn p;\r\nreturn NULL;\r\n}\r\nstatic capidrv_plci *find_plci_by_msgid(capidrv_contr *card, u16 msgid)\r\n{\r\ncapidrv_plci *p;\r\nfor (p = card->plci_list; p; p = p->next)\r\nif (p->msgid == msgid)\r\nreturn p;\r\nreturn NULL;\r\n}\r\nstatic capidrv_plci *find_plci_by_ncci(capidrv_contr *card, u32 ncci)\r\n{\r\ncapidrv_plci *p;\r\nfor (p = card->plci_list; p; p = p->next)\r\nif (p->plci == (ncci & 0xffff))\r\nreturn p;\r\nreturn NULL;\r\n}\r\nstatic void free_plci(capidrv_contr *card, capidrv_plci *plcip)\r\n{\r\ncapidrv_plci **pp;\r\nfor (pp = &card->plci_list; *pp; pp = &(*pp)->next) {\r\nif (*pp == plcip) {\r\n*pp = (*pp)->next;\r\ncard->bchans[plcip->chan].plcip = NULL;\r\ncard->bchans[plcip->chan].disconnecting = 0;\r\ncard->bchans[plcip->chan].incoming = 0;\r\nkfree(plcip);\r\nreturn;\r\n}\r\n}\r\nprintk(KERN_ERR "capidrv-%d: free_plci %p (0x%x) not found, Huh?\n",\r\ncard->contrnr, plcip, plcip->plci);\r\n}\r\nstatic inline capidrv_ncci *new_ncci(capidrv_contr *card,\r\ncapidrv_plci *plcip,\r\nu32 ncci)\r\n{\r\ncapidrv_ncci *nccip;\r\nnccip = kzalloc(sizeof(capidrv_ncci), GFP_ATOMIC);\r\nif (nccip == NULL)\r\nreturn NULL;\r\nnccip->ncci = ncci;\r\nnccip->state = ST_NCCI_NONE;\r\nnccip->plcip = plcip;\r\nnccip->chan = plcip->chan;\r\nnccip->datahandle = 0;\r\nnccip->next = plcip->ncci_list;\r\nplcip->ncci_list = nccip;\r\ncard->bchans[plcip->chan].nccip = nccip;\r\nreturn nccip;\r\n}\r\nstatic inline capidrv_ncci *find_ncci(capidrv_contr *card, u32 ncci)\r\n{\r\ncapidrv_plci *plcip;\r\ncapidrv_ncci *p;\r\nif ((plcip = find_plci_by_ncci(card, ncci)) == NULL)\r\nreturn NULL;\r\nfor (p = plcip->ncci_list; p; p = p->next)\r\nif (p->ncci == ncci)\r\nreturn p;\r\nreturn NULL;\r\n}\r\nstatic inline capidrv_ncci *find_ncci_by_msgid(capidrv_contr *card,\r\nu32 ncci, u16 msgid)\r\n{\r\ncapidrv_plci *plcip;\r\ncapidrv_ncci *p;\r\nif ((plcip = find_plci_by_ncci(card, ncci)) == NULL)\r\nreturn NULL;\r\nfor (p = plcip->ncci_list; p; p = p->next)\r\nif (p->msgid == msgid)\r\nreturn p;\r\nreturn NULL;\r\n}\r\nstatic void free_ncci(capidrv_contr *card, struct capidrv_ncci *nccip)\r\n{\r\nstruct capidrv_ncci **pp;\r\nfor (pp = &(nccip->plcip->ncci_list); *pp; pp = &(*pp)->next) {\r\nif (*pp == nccip) {\r\n*pp = (*pp)->next;\r\nbreak;\r\n}\r\n}\r\ncard->bchans[nccip->chan].nccip = NULL;\r\nkfree(nccip);\r\n}\r\nstatic int capidrv_add_ack(struct capidrv_ncci *nccip,\r\nu16 datahandle, int len)\r\n{\r\nstruct ncci_datahandle_queue *n, **pp;\r\nn = kmalloc(sizeof(struct ncci_datahandle_queue), GFP_ATOMIC);\r\nif (!n) {\r\nprintk(KERN_ERR "capidrv: kmalloc ncci_datahandle failed\n");\r\nreturn -1;\r\n}\r\nn->next = NULL;\r\nn->datahandle = datahandle;\r\nn->len = len;\r\nfor (pp = &nccip->ackqueue; *pp; pp = &(*pp)->next);\r\n*pp = n;\r\nreturn 0;\r\n}\r\nstatic int capidrv_del_ack(struct capidrv_ncci *nccip, u16 datahandle)\r\n{\r\nstruct ncci_datahandle_queue **pp, *p;\r\nint len;\r\nfor (pp = &nccip->ackqueue; *pp; pp = &(*pp)->next) {\r\nif ((*pp)->datahandle == datahandle) {\r\np = *pp;\r\nlen = p->len;\r\n*pp = (*pp)->next;\r\nkfree(p);\r\nreturn len;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic void send_message(capidrv_contr *card, _cmsg *cmsg)\r\n{\r\nstruct sk_buff *skb;\r\nsize_t len;\r\nif (capi_cmsg2message(cmsg, cmsg->buf)) {\r\nprintk(KERN_ERR "capidrv::send_message: parser failure\n");\r\nreturn;\r\n}\r\nlen = CAPIMSG_LEN(cmsg->buf);\r\nskb = alloc_skb(len, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_ERR "capidrv::send_message: can't allocate mem\n");\r\nreturn;\r\n}\r\nskb_put_data(skb, cmsg->buf, len);\r\nif (capi20_put_message(&global.ap, skb) != CAPI_NOERROR)\r\nkfree_skb(skb);\r\n}\r\nstatic void listen_change_state(capidrv_contr *card, int event)\r\n{\r\nstruct listenstatechange *p = listentable;\r\nwhile (p->event) {\r\nif (card->state == p->actstate && p->event == event) {\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: listen_change_state %d -> %d\n",\r\ncard->contrnr, card->state, p->nextstate);\r\ncard->state = p->nextstate;\r\nreturn;\r\n}\r\np++;\r\n}\r\nprintk(KERN_ERR "capidrv-%d: listen_change_state state=%d event=%d ????\n",\r\ncard->contrnr, card->state, event);\r\n}\r\nstatic void p0(capidrv_contr *card, capidrv_plci *plci)\r\n{\r\nisdn_ctrl cmd;\r\ncard->bchans[plci->chan].contr = NULL;\r\ncmd.command = ISDN_STAT_DHUP;\r\ncmd.driver = card->myid;\r\ncmd.arg = plci->chan;\r\ncard->interface.statcallb(&cmd);\r\nfree_plci(card, plci);\r\n}\r\nstatic void plci_change_state(capidrv_contr *card, capidrv_plci *plci, int event)\r\n{\r\nstruct plcistatechange *p = plcitable;\r\nwhile (p->event) {\r\nif (plci->state == p->actstate && p->event == event) {\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: plci_change_state:0x%x %d -> %d\n",\r\ncard->contrnr, plci->plci, plci->state, p->nextstate);\r\nplci->state = p->nextstate;\r\nif (p->changefunc)\r\np->changefunc(card, plci);\r\nreturn;\r\n}\r\np++;\r\n}\r\nprintk(KERN_ERR "capidrv-%d: plci_change_state:0x%x state=%d event=%d ????\n",\r\ncard->contrnr, plci->plci, plci->state, event);\r\n}\r\nstatic void n0(capidrv_contr *card, capidrv_ncci *ncci)\r\n{\r\nisdn_ctrl cmd;\r\ncapi_fill_DISCONNECT_REQ(&cmsg,\r\nglobal.ap.applid,\r\ncard->msgid++,\r\nncci->plcip->plci,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL\r\n);\r\nplci_change_state(card, ncci->plcip, EV_PLCI_DISCONNECT_REQ);\r\nsend_message(card, &cmsg);\r\ncmd.command = ISDN_STAT_BHUP;\r\ncmd.driver = card->myid;\r\ncmd.arg = ncci->chan;\r\ncard->interface.statcallb(&cmd);\r\nfree_ncci(card, ncci);\r\n}\r\nstatic void ncci_change_state(capidrv_contr *card, capidrv_ncci *ncci, int event)\r\n{\r\nstruct nccistatechange *p = nccitable;\r\nwhile (p->event) {\r\nif (ncci->state == p->actstate && p->event == event) {\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: ncci_change_state:0x%x %d -> %d\n",\r\ncard->contrnr, ncci->ncci, ncci->state, p->nextstate);\r\nif (p->nextstate == ST_NCCI_PREVIOUS) {\r\nncci->state = ncci->oldstate;\r\nncci->oldstate = p->actstate;\r\n} else {\r\nncci->oldstate = p->actstate;\r\nncci->state = p->nextstate;\r\n}\r\nif (p->changefunc)\r\np->changefunc(card, ncci);\r\nreturn;\r\n}\r\np++;\r\n}\r\nprintk(KERN_ERR "capidrv-%d: ncci_change_state:0x%x state=%d event=%d ????\n",\r\ncard->contrnr, ncci->ncci, ncci->state, event);\r\n}\r\nstatic inline int new_bchan(capidrv_contr *card)\r\n{\r\nint i;\r\nfor (i = 0; i < card->nbchan; i++) {\r\nif (card->bchans[i].plcip == NULL) {\r\ncard->bchans[i].disconnecting = 0;\r\nreturn i;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic char *capi_info2str(u16 reason)\r\n{\r\n#ifndef CONFIG_ISDN_CAPI_CAPIDRV_VERBOSE\r\nreturn "..";\r\n#else\r\nswitch (reason) {\r\ncase 0x0001:\r\nreturn "NCPI not supported by current protocol, NCPI ignored";\r\ncase 0x0002:\r\nreturn "Flags not supported by current protocol, flags ignored";\r\ncase 0x0003:\r\nreturn "Alert already sent by another application";\r\ncase 0x1001:\r\nreturn "Too many applications";\r\ncase 0x1002:\r\nreturn "Logical block size too small, must be at least 128 Bytes";\r\ncase 0x1003:\r\nreturn "Buffer exceeds 64 kByte";\r\ncase 0x1004:\r\nreturn "Message buffer size too small, must be at least 1024 Bytes";\r\ncase 0x1005:\r\nreturn "Max. number of logical connections not supported";\r\ncase 0x1006:\r\nreturn "Reserved";\r\ncase 0x1007:\r\nreturn "The message could not be accepted because of an internal busy condition";\r\ncase 0x1008:\r\nreturn "OS resource error (no memory ?)";\r\ncase 0x1009:\r\nreturn "CAPI not installed";\r\ncase 0x100A:\r\nreturn "Controller does not support external equipment";\r\ncase 0x100B:\r\nreturn "Controller does only support external equipment";\r\ncase 0x1101:\r\nreturn "Illegal application number";\r\ncase 0x1102:\r\nreturn "Illegal command or subcommand or message length less than 12 bytes";\r\ncase 0x1103:\r\nreturn "The message could not be accepted because of a queue full condition !! The error code does not imply that CAPI cannot receive messages directed to another controller, PLCI or NCCI";\r\ncase 0x1104:\r\nreturn "Queue is empty";\r\ncase 0x1105:\r\nreturn "Queue overflow, a message was lost !! This indicates a configuration error. The only recovery from this error is to perform a CAPI_RELEASE";\r\ncase 0x1106:\r\nreturn "Unknown notification parameter";\r\ncase 0x1107:\r\nreturn "The Message could not be accepted because of an internal busy condition";\r\ncase 0x1108:\r\nreturn "OS Resource error (no memory ?)";\r\ncase 0x1109:\r\nreturn "CAPI not installed";\r\ncase 0x110A:\r\nreturn "Controller does not support external equipment";\r\ncase 0x110B:\r\nreturn "Controller does only support external equipment";\r\ncase 0x2001:\r\nreturn "Message not supported in current state";\r\ncase 0x2002:\r\nreturn "Illegal Controller / PLCI / NCCI";\r\ncase 0x2003:\r\nreturn "Out of PLCI";\r\ncase 0x2004:\r\nreturn "Out of NCCI";\r\ncase 0x2005:\r\nreturn "Out of LISTEN";\r\ncase 0x2006:\r\nreturn "Out of FAX resources (protocol T.30)";\r\ncase 0x2007:\r\nreturn "Illegal message parameter coding";\r\ncase 0x3001:\r\nreturn "B1 protocol not supported";\r\ncase 0x3002:\r\nreturn "B2 protocol not supported";\r\ncase 0x3003:\r\nreturn "B3 protocol not supported";\r\ncase 0x3004:\r\nreturn "B1 protocol parameter not supported";\r\ncase 0x3005:\r\nreturn "B2 protocol parameter not supported";\r\ncase 0x3006:\r\nreturn "B3 protocol parameter not supported";\r\ncase 0x3007:\r\nreturn "B protocol combination not supported";\r\ncase 0x3008:\r\nreturn "NCPI not supported";\r\ncase 0x3009:\r\nreturn "CIP Value unknown";\r\ncase 0x300A:\r\nreturn "Flags not supported (reserved bits)";\r\ncase 0x300B:\r\nreturn "Facility not supported";\r\ncase 0x300C:\r\nreturn "Data length not supported by current protocol";\r\ncase 0x300D:\r\nreturn "Reset procedure not supported by current protocol";\r\ncase 0x3301:\r\nreturn "Protocol error layer 1 (broken line or B-channel removed by signalling protocol)";\r\ncase 0x3302:\r\nreturn "Protocol error layer 2";\r\ncase 0x3303:\r\nreturn "Protocol error layer 3";\r\ncase 0x3304:\r\nreturn "Another application got that call";\r\ncase 0x3311:\r\nreturn "Connecting not successful (remote station is no FAX G3 machine)";\r\ncase 0x3312:\r\nreturn "Connecting not successful (training error)";\r\ncase 0x3313:\r\nreturn "Disconnected before transfer (remote station does not support transfer mode, e.g. resolution)";\r\ncase 0x3314:\r\nreturn "Disconnected during transfer (remote abort)";\r\ncase 0x3315:\r\nreturn "Disconnected during transfer (remote procedure error, e.g. unsuccessful repetition of T.30 commands)";\r\ncase 0x3316:\r\nreturn "Disconnected during transfer (local tx data underrun)";\r\ncase 0x3317:\r\nreturn "Disconnected during transfer (local rx data overflow)";\r\ncase 0x3318:\r\nreturn "Disconnected during transfer (local abort)";\r\ncase 0x3319:\r\nreturn "Illegal parameter coding (e.g. SFF coding error)";\r\ncase 0x3481: return "Unallocated (unassigned) number";\r\ncase 0x3482: return "No route to specified transit network";\r\ncase 0x3483: return "No route to destination";\r\ncase 0x3486: return "Channel unacceptable";\r\ncase 0x3487:\r\nreturn "Call awarded and being delivered in an established channel";\r\ncase 0x3490: return "Normal call clearing";\r\ncase 0x3491: return "User busy";\r\ncase 0x3492: return "No user responding";\r\ncase 0x3493: return "No answer from user (user alerted)";\r\ncase 0x3495: return "Call rejected";\r\ncase 0x3496: return "Number changed";\r\ncase 0x349A: return "Non-selected user clearing";\r\ncase 0x349B: return "Destination out of order";\r\ncase 0x349C: return "Invalid number format";\r\ncase 0x349D: return "Facility rejected";\r\ncase 0x349E: return "Response to STATUS ENQUIRY";\r\ncase 0x349F: return "Normal, unspecified";\r\ncase 0x34A2: return "No circuit / channel available";\r\ncase 0x34A6: return "Network out of order";\r\ncase 0x34A9: return "Temporary failure";\r\ncase 0x34AA: return "Switching equipment congestion";\r\ncase 0x34AB: return "Access information discarded";\r\ncase 0x34AC: return "Requested circuit / channel not available";\r\ncase 0x34AF: return "Resources unavailable, unspecified";\r\ncase 0x34B1: return "Quality of service unavailable";\r\ncase 0x34B2: return "Requested facility not subscribed";\r\ncase 0x34B9: return "Bearer capability not authorized";\r\ncase 0x34BA: return "Bearer capability not presently available";\r\ncase 0x34BF: return "Service or option not available, unspecified";\r\ncase 0x34C1: return "Bearer capability not implemented";\r\ncase 0x34C2: return "Channel type not implemented";\r\ncase 0x34C5: return "Requested facility not implemented";\r\ncase 0x34C6: return "Only restricted digital information bearer capability is available";\r\ncase 0x34CF: return "Service or option not implemented, unspecified";\r\ncase 0x34D1: return "Invalid call reference value";\r\ncase 0x34D2: return "Identified channel does not exist";\r\ncase 0x34D3: return "A suspended call exists, but this call identity does not";\r\ncase 0x34D4: return "Call identity in use";\r\ncase 0x34D5: return "No call suspended";\r\ncase 0x34D6: return "Call having the requested call identity has been cleared";\r\ncase 0x34D8: return "Incompatible destination";\r\ncase 0x34DB: return "Invalid transit network selection";\r\ncase 0x34DF: return "Invalid message, unspecified";\r\ncase 0x34E0: return "Mandatory information element is missing";\r\ncase 0x34E1: return "Message type non-existent or not implemented";\r\ncase 0x34E2: return "Message not compatible with call state or message type non-existent or not implemented";\r\ncase 0x34E3: return "Information element non-existent or not implemented";\r\ncase 0x34E4: return "Invalid information element contents";\r\ncase 0x34E5: return "Message not compatible with call state";\r\ncase 0x34E6: return "Recovery on timer expiry";\r\ncase 0x34EF: return "Protocol error, unspecified";\r\ncase 0x34FF: return "Interworking, unspecified";\r\ndefault: return "No additional information";\r\n}\r\n#endif\r\n}\r\nstatic void handle_controller(_cmsg *cmsg)\r\n{\r\ncapidrv_contr *card = findcontrbynumber(cmsg->adr.adrController & 0x7f);\r\nif (!card) {\r\nprintk(KERN_ERR "capidrv: %s from unknown controller 0x%x\n",\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrController & 0x7f);\r\nreturn;\r\n}\r\nswitch (CAPICMD(cmsg->Command, cmsg->Subcommand)) {\r\ncase CAPI_LISTEN_CONF:\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: listenconf Info=0x%4x (%s) cipmask=0x%x\n",\r\ncard->contrnr, cmsg->Info, capi_info2str(cmsg->Info), card->cipmask);\r\nif (cmsg->Info) {\r\nlisten_change_state(card, EV_LISTEN_CONF_ERROR);\r\n} else if (card->cipmask == 0) {\r\nlisten_change_state(card, EV_LISTEN_CONF_EMPTY);\r\n} else {\r\nlisten_change_state(card, EV_LISTEN_CONF_OK);\r\n}\r\nbreak;\r\ncase CAPI_MANUFACTURER_IND:\r\nif (cmsg->ManuID == 0x214D5641\r\n&& cmsg->Class == 0\r\n&& cmsg->Function == 1) {\r\nu8 *data = cmsg->ManuData + 3;\r\nu16 len = cmsg->ManuData[0];\r\nu16 layer;\r\nint direction;\r\nif (len == 255) {\r\nlen = (cmsg->ManuData[1] | (cmsg->ManuData[2] << 8));\r\ndata += 2;\r\n}\r\nlen -= 2;\r\nlayer = ((*(data - 1)) << 8) | *(data - 2);\r\nif (layer & 0x300)\r\ndirection = (layer & 0x200) ? 0 : 1;\r\nelse direction = (layer & 0x800) ? 0 : 1;\r\nif (layer & 0x0C00) {\r\nif ((layer & 0xff) == 0x80) {\r\nhandle_dtrace_data(card, direction, 1, data, len);\r\nbreak;\r\n}\r\n} else if ((layer & 0xff) < 0x80) {\r\nhandle_dtrace_data(card, direction, 0, data, len);\r\nbreak;\r\n}\r\nprintk(KERN_INFO "capidrv-%d: %s from controller 0x%x layer 0x%x, ignored\n",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrController, layer);\r\nbreak;\r\n}\r\ngoto ignored;\r\ncase CAPI_MANUFACTURER_CONF:\r\nif (cmsg->ManuID == 0x214D5641) {\r\nchar *s = NULL;\r\nswitch (cmsg->Class) {\r\ncase 0: break;\r\ncase 1: s = "unknown class"; break;\r\ncase 2: s = "unknown function"; break;\r\ndefault: s = "unknown error"; break;\r\n}\r\nif (s)\r\nprintk(KERN_INFO "capidrv-%d: %s from controller 0x%x function %d: %s\n",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrController,\r\ncmsg->Function, s);\r\nbreak;\r\n}\r\ngoto ignored;\r\ncase CAPI_FACILITY_IND:\r\ngoto ignored;\r\ncase CAPI_FACILITY_CONF:\r\ngoto ignored;\r\ncase CAPI_INFO_IND:\r\ngoto ignored;\r\ncase CAPI_INFO_CONF:\r\ngoto ignored;\r\ndefault:\r\nprintk(KERN_ERR "capidrv-%d: got %s from controller 0x%x ???",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrController);\r\n}\r\nreturn;\r\nignored:\r\nprintk(KERN_INFO "capidrv-%d: %s from controller 0x%x ignored\n",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrController);\r\n}\r\nstatic void handle_incoming_call(capidrv_contr *card, _cmsg *cmsg)\r\n{\r\ncapidrv_plci *plcip;\r\ncapidrv_bchan *bchan;\r\nisdn_ctrl cmd;\r\nint chan;\r\nif ((chan = new_bchan(card)) == -1) {\r\nprintk(KERN_ERR "capidrv-%d: incoming call on not existing bchan ?\n", card->contrnr);\r\nreturn;\r\n}\r\nbchan = &card->bchans[chan];\r\nif ((plcip = new_plci(card, chan)) == NULL) {\r\nprintk(KERN_ERR "capidrv-%d: incoming call: no memory, sorry.\n", card->contrnr);\r\nreturn;\r\n}\r\nbchan->incoming = 1;\r\nplcip->plci = cmsg->adr.adrPLCI;\r\nplci_change_state(card, plcip, EV_PLCI_CONNECT_IND);\r\ncmd.command = ISDN_STAT_ICALL;\r\ncmd.driver = card->myid;\r\ncmd.arg = chan;\r\nmemset(&cmd.parm.setup, 0, sizeof(cmd.parm.setup));\r\nstrncpy(cmd.parm.setup.phone,\r\ncmsg->CallingPartyNumber + 3,\r\ncmsg->CallingPartyNumber[0] - 2);\r\nstrncpy(cmd.parm.setup.eazmsn,\r\ncmsg->CalledPartyNumber + 2,\r\ncmsg->CalledPartyNumber[0] - 1);\r\ncmd.parm.setup.si1 = cip2si1(cmsg->CIPValue);\r\ncmd.parm.setup.si2 = cip2si2(cmsg->CIPValue);\r\ncmd.parm.setup.plan = cmsg->CallingPartyNumber[1];\r\ncmd.parm.setup.screen = cmsg->CallingPartyNumber[2];\r\nprintk(KERN_INFO "capidrv-%d: incoming call %s,%d,%d,%s\n",\r\ncard->contrnr,\r\ncmd.parm.setup.phone,\r\ncmd.parm.setup.si1,\r\ncmd.parm.setup.si2,\r\ncmd.parm.setup.eazmsn);\r\nif (cmd.parm.setup.si1 == 1 && cmd.parm.setup.si2 != 0) {\r\nprintk(KERN_INFO "capidrv-%d: patching si2=%d to 0 for VBOX\n",\r\ncard->contrnr,\r\ncmd.parm.setup.si2);\r\ncmd.parm.setup.si2 = 0;\r\n}\r\nswitch (card->interface.statcallb(&cmd)) {\r\ncase 0:\r\ncase 3:\r\ncapi_cmsg_answer(cmsg);\r\ncmsg->Reject = 1;\r\nplci_change_state(card, plcip, EV_PLCI_CONNECT_REJECT);\r\nsend_message(card, cmsg);\r\nprintk(KERN_INFO "capidrv-%d: incoming call %s,%d,%d,%s ignored\n",\r\ncard->contrnr,\r\ncmd.parm.setup.phone,\r\ncmd.parm.setup.si1,\r\ncmd.parm.setup.si2,\r\ncmd.parm.setup.eazmsn);\r\nbreak;\r\ncase 1:\r\nif (plcip->state == ST_PLCI_INCOMING) {\r\nprintk(KERN_INFO "capidrv-%d: incoming call %s,%d,%d,%s tty alerting\n",\r\ncard->contrnr,\r\ncmd.parm.setup.phone,\r\ncmd.parm.setup.si1,\r\ncmd.parm.setup.si2,\r\ncmd.parm.setup.eazmsn);\r\ncapi_fill_ALERT_REQ(cmsg,\r\nglobal.ap.applid,\r\ncard->msgid++,\r\nplcip->plci,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL\r\n);\r\nplcip->msgid = cmsg->Messagenumber;\r\nsend_message(card, cmsg);\r\n} else {\r\nprintk(KERN_INFO "capidrv-%d: incoming call %s,%d,%d,%s on netdev\n",\r\ncard->contrnr,\r\ncmd.parm.setup.phone,\r\ncmd.parm.setup.si1,\r\ncmd.parm.setup.si2,\r\ncmd.parm.setup.eazmsn);\r\n}\r\nbreak;\r\ncase 2:\r\ncapi_cmsg_answer(cmsg);\r\ncmsg->Reject = 2;\r\nplci_change_state(card, plcip, EV_PLCI_CONNECT_REJECT);\r\nsend_message(card, cmsg);\r\nbreak;\r\ndefault:\r\ncapi_cmsg_answer(cmsg);\r\ncmsg->Reject = 8;\r\nplci_change_state(card, plcip, EV_PLCI_CONNECT_REJECT);\r\nsend_message(card, cmsg);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic void handle_plci(_cmsg *cmsg)\r\n{\r\ncapidrv_contr *card = findcontrbynumber(cmsg->adr.adrController & 0x7f);\r\ncapidrv_plci *plcip;\r\nisdn_ctrl cmd;\r\n_cdebbuf *cdb;\r\nif (!card) {\r\nprintk(KERN_ERR "capidrv: %s from unknown controller 0x%x\n",\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrController & 0x7f);\r\nreturn;\r\n}\r\nswitch (CAPICMD(cmsg->Command, cmsg->Subcommand)) {\r\ncase CAPI_DISCONNECT_IND:\r\nif (cmsg->Reason) {\r\nprintk(KERN_INFO "capidrv-%d: %s reason 0x%x (%s) for plci 0x%x\n",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->Reason, capi_info2str(cmsg->Reason), cmsg->adr.adrPLCI);\r\n}\r\nif (!(plcip = find_plci_by_plci(card, cmsg->adr.adrPLCI))) {\r\ncapi_cmsg_answer(cmsg);\r\nsend_message(card, cmsg);\r\ngoto notfound;\r\n}\r\ncard->bchans[plcip->chan].disconnecting = 1;\r\nplci_change_state(card, plcip, EV_PLCI_DISCONNECT_IND);\r\ncapi_cmsg_answer(cmsg);\r\nplci_change_state(card, plcip, EV_PLCI_DISCONNECT_RESP);\r\nsend_message(card, cmsg);\r\nbreak;\r\ncase CAPI_DISCONNECT_CONF:\r\nif (cmsg->Info) {\r\nprintk(KERN_INFO "capidrv-%d: %s info 0x%x (%s) for plci 0x%x\n",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->Info, capi_info2str(cmsg->Info),\r\ncmsg->adr.adrPLCI);\r\n}\r\nif (!(plcip = find_plci_by_plci(card, cmsg->adr.adrPLCI)))\r\ngoto notfound;\r\ncard->bchans[plcip->chan].disconnecting = 1;\r\nbreak;\r\ncase CAPI_ALERT_CONF:\r\nif (cmsg->Info) {\r\nprintk(KERN_INFO "capidrv-%d: %s info 0x%x (%s) for plci 0x%x\n",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->Info, capi_info2str(cmsg->Info),\r\ncmsg->adr.adrPLCI);\r\n}\r\nbreak;\r\ncase CAPI_CONNECT_IND:\r\nhandle_incoming_call(card, cmsg);\r\nbreak;\r\ncase CAPI_CONNECT_CONF:\r\nif (cmsg->Info) {\r\nprintk(KERN_INFO "capidrv-%d: %s info 0x%x (%s) for plci 0x%x\n",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->Info, capi_info2str(cmsg->Info),\r\ncmsg->adr.adrPLCI);\r\n}\r\nif (!(plcip = find_plci_by_msgid(card, cmsg->Messagenumber)))\r\ngoto notfound;\r\nplcip->plci = cmsg->adr.adrPLCI;\r\nif (cmsg->Info) {\r\nplci_change_state(card, plcip, EV_PLCI_CONNECT_CONF_ERROR);\r\n} else {\r\nplci_change_state(card, plcip, EV_PLCI_CONNECT_CONF_OK);\r\n}\r\nbreak;\r\ncase CAPI_CONNECT_ACTIVE_IND:\r\nif (!(plcip = find_plci_by_plci(card, cmsg->adr.adrPLCI)))\r\ngoto notfound;\r\nif (card->bchans[plcip->chan].incoming) {\r\ncapi_cmsg_answer(cmsg);\r\nplci_change_state(card, plcip, EV_PLCI_CONNECT_ACTIVE_IND);\r\nsend_message(card, cmsg);\r\n} else {\r\ncapidrv_ncci *nccip;\r\ncapi_cmsg_answer(cmsg);\r\nsend_message(card, cmsg);\r\nnccip = new_ncci(card, plcip, cmsg->adr.adrPLCI);\r\nif (!nccip) {\r\nprintk(KERN_ERR "capidrv-%d: no mem for ncci, sorry\n", card->contrnr);\r\nbreak;\r\n}\r\ncapi_fill_CONNECT_B3_REQ(cmsg,\r\nglobal.ap.applid,\r\ncard->msgid++,\r\nplcip->plci,\r\nNULL\r\n);\r\nnccip->msgid = cmsg->Messagenumber;\r\nplci_change_state(card, plcip,\r\nEV_PLCI_CONNECT_ACTIVE_IND);\r\nncci_change_state(card, nccip, EV_NCCI_CONNECT_B3_REQ);\r\nsend_message(card, cmsg);\r\ncmd.command = ISDN_STAT_DCONN;\r\ncmd.driver = card->myid;\r\ncmd.arg = plcip->chan;\r\ncard->interface.statcallb(&cmd);\r\n}\r\nbreak;\r\ncase CAPI_INFO_IND:\r\nif (!(plcip = find_plci_by_plci(card, cmsg->adr.adrPLCI)))\r\ngoto notfound;\r\nif (cmsg->InfoNumber == 0x4000) {\r\nif (cmsg->InfoElement[0] == 4) {\r\ncmd.command = ISDN_STAT_CINF;\r\ncmd.driver = card->myid;\r\ncmd.arg = plcip->chan;\r\nsprintf(cmd.parm.num, "%lu",\r\n(unsigned long)\r\n((u32) cmsg->InfoElement[1]\r\n| ((u32) (cmsg->InfoElement[2]) << 8)\r\n| ((u32) (cmsg->InfoElement[3]) << 16)\r\n| ((u32) (cmsg->InfoElement[4]) << 24)));\r\ncard->interface.statcallb(&cmd);\r\nbreak;\r\n}\r\n}\r\ncdb = capi_cmsg2str(cmsg);\r\nif (cdb) {\r\nprintk(KERN_WARNING "capidrv-%d: %s\n",\r\ncard->contrnr, cdb->buf);\r\ncdebbuf_free(cdb);\r\n} else\r\nprintk(KERN_WARNING "capidrv-%d: CAPI_INFO_IND InfoNumber %x not handled\n",\r\ncard->contrnr, cmsg->InfoNumber);\r\nbreak;\r\ncase CAPI_CONNECT_ACTIVE_CONF:\r\ngoto ignored;\r\ncase CAPI_SELECT_B_PROTOCOL_CONF:\r\ngoto ignored;\r\ncase CAPI_FACILITY_IND:\r\ngoto ignored;\r\ncase CAPI_FACILITY_CONF:\r\ngoto ignored;\r\ncase CAPI_INFO_CONF:\r\ngoto ignored;\r\ndefault:\r\nprintk(KERN_ERR "capidrv-%d: got %s for plci 0x%x ???",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrPLCI);\r\n}\r\nreturn;\r\nignored:\r\nprintk(KERN_INFO "capidrv-%d: %s for plci 0x%x ignored\n",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrPLCI);\r\nreturn;\r\nnotfound:\r\nprintk(KERN_ERR "capidrv-%d: %s: plci 0x%x not found\n",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrPLCI);\r\nreturn;\r\n}\r\nstatic void handle_ncci(_cmsg *cmsg)\r\n{\r\ncapidrv_contr *card = findcontrbynumber(cmsg->adr.adrController & 0x7f);\r\ncapidrv_plci *plcip;\r\ncapidrv_ncci *nccip;\r\nisdn_ctrl cmd;\r\nint len;\r\nif (!card) {\r\nprintk(KERN_ERR "capidrv: %s from unknown controller 0x%x\n",\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrController & 0x7f);\r\nreturn;\r\n}\r\nswitch (CAPICMD(cmsg->Command, cmsg->Subcommand)) {\r\ncase CAPI_CONNECT_B3_ACTIVE_IND:\r\nif (!(nccip = find_ncci(card, cmsg->adr.adrNCCI)))\r\ngoto notfound;\r\ncapi_cmsg_answer(cmsg);\r\nncci_change_state(card, nccip, EV_NCCI_CONNECT_B3_ACTIVE_IND);\r\nsend_message(card, cmsg);\r\ncmd.command = ISDN_STAT_BCONN;\r\ncmd.driver = card->myid;\r\ncmd.arg = nccip->chan;\r\ncard->interface.statcallb(&cmd);\r\nprintk(KERN_INFO "capidrv-%d: chan %d up with ncci 0x%x\n",\r\ncard->contrnr, nccip->chan, nccip->ncci);\r\nbreak;\r\ncase CAPI_CONNECT_B3_ACTIVE_CONF:\r\ngoto ignored;\r\ncase CAPI_CONNECT_B3_IND:\r\nplcip = find_plci_by_ncci(card, cmsg->adr.adrNCCI);\r\nif (plcip) {\r\nnccip = new_ncci(card, plcip, cmsg->adr.adrNCCI);\r\nif (nccip) {\r\nncci_change_state(card, nccip, EV_NCCI_CONNECT_B3_IND);\r\ncapi_fill_CONNECT_B3_RESP(cmsg,\r\nglobal.ap.applid,\r\ncard->msgid++,\r\nnccip->ncci,\r\n0,\r\nNULL\r\n);\r\nncci_change_state(card, nccip, EV_NCCI_CONNECT_B3_RESP);\r\nsend_message(card, cmsg);\r\nbreak;\r\n}\r\nprintk(KERN_ERR "capidrv-%d: no mem for ncci, sorry\n", card->contrnr);\r\n} else {\r\nprintk(KERN_ERR "capidrv-%d: %s: plci for ncci 0x%x not found\n",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrNCCI);\r\n}\r\ncapi_fill_CONNECT_B3_RESP(cmsg,\r\nglobal.ap.applid,\r\ncard->msgid++,\r\ncmsg->adr.adrNCCI,\r\n2,\r\nNULL\r\n);\r\nsend_message(card, cmsg);\r\nbreak;\r\ncase CAPI_CONNECT_B3_CONF:\r\nif (!(nccip = find_ncci_by_msgid(card,\r\ncmsg->adr.adrNCCI,\r\ncmsg->Messagenumber)))\r\ngoto notfound;\r\nnccip->ncci = cmsg->adr.adrNCCI;\r\nif (cmsg->Info) {\r\nprintk(KERN_INFO "capidrv-%d: %s info 0x%x (%s) for ncci 0x%x\n",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->Info, capi_info2str(cmsg->Info),\r\ncmsg->adr.adrNCCI);\r\n}\r\nif (cmsg->Info)\r\nncci_change_state(card, nccip, EV_NCCI_CONNECT_B3_CONF_ERROR);\r\nelse\r\nncci_change_state(card, nccip, EV_NCCI_CONNECT_B3_CONF_OK);\r\nbreak;\r\ncase CAPI_CONNECT_B3_T90_ACTIVE_IND:\r\ncapi_cmsg_answer(cmsg);\r\nsend_message(card, cmsg);\r\nbreak;\r\ncase CAPI_DATA_B3_IND:\r\ngoto ignored;\r\ncase CAPI_DATA_B3_CONF:\r\nif (cmsg->Info) {\r\nprintk(KERN_WARNING "CAPI_DATA_B3_CONF: Info %x - %s\n",\r\ncmsg->Info, capi_info2str(cmsg->Info));\r\n}\r\nif (!(nccip = find_ncci(card, cmsg->adr.adrNCCI)))\r\ngoto notfound;\r\nlen = capidrv_del_ack(nccip, cmsg->DataHandle);\r\nif (len < 0)\r\nbreak;\r\ncmd.command = ISDN_STAT_BSENT;\r\ncmd.driver = card->myid;\r\ncmd.arg = nccip->chan;\r\ncmd.parm.length = len;\r\ncard->interface.statcallb(&cmd);\r\nbreak;\r\ncase CAPI_DISCONNECT_B3_IND:\r\nif (!(nccip = find_ncci(card, cmsg->adr.adrNCCI)))\r\ngoto notfound;\r\ncard->bchans[nccip->chan].disconnecting = 1;\r\nncci_change_state(card, nccip, EV_NCCI_DISCONNECT_B3_IND);\r\ncapi_cmsg_answer(cmsg);\r\nncci_change_state(card, nccip, EV_NCCI_DISCONNECT_B3_RESP);\r\nsend_message(card, cmsg);\r\nbreak;\r\ncase CAPI_DISCONNECT_B3_CONF:\r\nif (!(nccip = find_ncci(card, cmsg->adr.adrNCCI)))\r\ngoto notfound;\r\nif (cmsg->Info) {\r\nprintk(KERN_INFO "capidrv-%d: %s info 0x%x (%s) for ncci 0x%x\n",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->Info, capi_info2str(cmsg->Info),\r\ncmsg->adr.adrNCCI);\r\nncci_change_state(card, nccip, EV_NCCI_DISCONNECT_B3_CONF_ERROR);\r\n}\r\nbreak;\r\ncase CAPI_RESET_B3_IND:\r\nif (!(nccip = find_ncci(card, cmsg->adr.adrNCCI)))\r\ngoto notfound;\r\nncci_change_state(card, nccip, EV_NCCI_RESET_B3_IND);\r\ncapi_cmsg_answer(cmsg);\r\nsend_message(card, cmsg);\r\nbreak;\r\ncase CAPI_RESET_B3_CONF:\r\ngoto ignored;\r\ncase CAPI_FACILITY_IND:\r\ngoto ignored;\r\ncase CAPI_FACILITY_CONF:\r\ngoto ignored;\r\ndefault:\r\nprintk(KERN_ERR "capidrv-%d: got %s for ncci 0x%x ???",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrNCCI);\r\n}\r\nreturn;\r\nignored:\r\nprintk(KERN_INFO "capidrv-%d: %s for ncci 0x%x ignored\n",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrNCCI);\r\nreturn;\r\nnotfound:\r\nprintk(KERN_ERR "capidrv-%d: %s: ncci 0x%x not found\n",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrNCCI);\r\n}\r\nstatic void handle_data(_cmsg *cmsg, struct sk_buff *skb)\r\n{\r\ncapidrv_contr *card = findcontrbynumber(cmsg->adr.adrController & 0x7f);\r\ncapidrv_ncci *nccip;\r\nif (!card) {\r\nprintk(KERN_ERR "capidrv: %s from unknown controller 0x%x\n",\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrController & 0x7f);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (!(nccip = find_ncci(card, cmsg->adr.adrNCCI))) {\r\nprintk(KERN_ERR "capidrv-%d: %s: ncci 0x%x not found\n",\r\ncard->contrnr,\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\ncmsg->adr.adrNCCI);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\n(void) skb_pull(skb, CAPIMSG_LEN(skb->data));\r\ncard->interface.rcvcallb_skb(card->myid, nccip->chan, skb);\r\ncapi_cmsg_answer(cmsg);\r\nsend_message(card, cmsg);\r\n}\r\nstatic void capidrv_recv_message(struct capi20_appl *ap, struct sk_buff *skb)\r\n{\r\nif (capi_message2cmsg(&s_cmsg, skb->data)) {\r\nprintk(KERN_ERR "capidrv: applid=%d: received invalid message\n",\r\nap->applid);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (debugmode > 3) {\r\n_cdebbuf *cdb = capi_cmsg2str(&s_cmsg);\r\nif (cdb) {\r\nprintk(KERN_DEBUG "%s: applid=%d %s\n", __func__,\r\nap->applid, cdb->buf);\r\ncdebbuf_free(cdb);\r\n} else\r\nprintk(KERN_DEBUG "%s: applid=%d %s not traced\n",\r\n__func__, ap->applid,\r\ncapi_cmd2str(s_cmsg.Command, s_cmsg.Subcommand));\r\n}\r\nif (s_cmsg.Command == CAPI_DATA_B3\r\n&& s_cmsg.Subcommand == CAPI_IND) {\r\nhandle_data(&s_cmsg, skb);\r\nreturn;\r\n}\r\nif ((s_cmsg.adr.adrController & 0xffffff00) == 0)\r\nhandle_controller(&s_cmsg);\r\nelse if ((s_cmsg.adr.adrPLCI & 0xffff0000) == 0)\r\nhandle_plci(&s_cmsg);\r\nelse\r\nhandle_ncci(&s_cmsg);\r\nkfree_skb(skb);\r\n}\r\nstatic void handle_dtrace_data(capidrv_contr *card,\r\nint send, int level2, u8 *data, u16 len)\r\n{\r\nu8 *p, *end;\r\nisdn_ctrl cmd;\r\nif (!len) {\r\nprintk(KERN_DEBUG "capidrv-%d: avmb1_q931_data: len == %d\n",\r\ncard->contrnr, len);\r\nreturn;\r\n}\r\nif (level2) {\r\nPUTBYTE_TO_STATUS(card, 'D');\r\nPUTBYTE_TO_STATUS(card, '2');\r\nPUTBYTE_TO_STATUS(card, send ? '>' : '<');\r\nPUTBYTE_TO_STATUS(card, ':');\r\n} else {\r\nPUTBYTE_TO_STATUS(card, 'D');\r\nPUTBYTE_TO_STATUS(card, '3');\r\nPUTBYTE_TO_STATUS(card, send ? '>' : '<');\r\nPUTBYTE_TO_STATUS(card, ':');\r\n}\r\nfor (p = data, end = data + len; p < end; p++) {\r\nPUTBYTE_TO_STATUS(card, ' ');\r\nPUTBYTE_TO_STATUS(card, hex_asc_hi(*p));\r\nPUTBYTE_TO_STATUS(card, hex_asc_lo(*p));\r\n}\r\nPUTBYTE_TO_STATUS(card, '\n');\r\ncmd.command = ISDN_STAT_STAVAIL;\r\ncmd.driver = card->myid;\r\ncmd.arg = len * 3 + 5;\r\ncard->interface.statcallb(&cmd);\r\n}\r\nstatic int capidrv_ioctl(isdn_ctrl *c, capidrv_contr *card)\r\n{\r\nswitch (c->arg) {\r\ncase 1:\r\ndebugmode = (int)(*((unsigned int *)c->parm.num));\r\nprintk(KERN_DEBUG "capidrv-%d: debugmode=%d\n",\r\ncard->contrnr, debugmode);\r\nreturn 0;\r\ndefault:\r\nprintk(KERN_DEBUG "capidrv-%d: capidrv_ioctl(%ld) called ??\n",\r\ncard->contrnr, c->arg);\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int decodeFVteln(char *teln, unsigned long *bmaskp, int *activep)\r\n{\r\nunsigned long bmask = 0;\r\nint active = !0;\r\nchar *s;\r\nint i;\r\nif (strncmp(teln, "FV:", 3) != 0)\r\nreturn 1;\r\ns = teln + 3;\r\nwhile (*s && *s == ' ') s++;\r\nif (!*s) return -2;\r\nif (*s == 'p' || *s == 'P') {\r\nactive = 0;\r\ns++;\r\n}\r\nif (*s == 'a' || *s == 'A') {\r\nactive = !0;\r\ns++;\r\n}\r\nwhile (*s) {\r\nint digit1 = 0;\r\nint digit2 = 0;\r\nchar *endp;\r\ndigit1 = simple_strtoul(s, &endp, 10);\r\nif (s == endp)\r\nreturn -3;\r\ns = endp;\r\nif (digit1 <= 0 || digit1 > 30) return -4;\r\nif (*s == 0 || *s == ',' || *s == ' ') {\r\nbmask |= (1 << digit1);\r\ndigit1 = 0;\r\nif (*s) s++;\r\ncontinue;\r\n}\r\nif (*s != '-') return -5;\r\ns++;\r\ndigit2 = simple_strtoul(s, &endp, 10);\r\nif (s == endp)\r\nreturn -3;\r\ns = endp;\r\nif (digit2 <= 0 || digit2 > 30) return -4;\r\nif (*s == 0 || *s == ',' || *s == ' ') {\r\nif (digit1 > digit2)\r\nfor (i = digit2; i <= digit1; i++)\r\nbmask |= (1 << i);\r\nelse\r\nfor (i = digit1; i <= digit2; i++)\r\nbmask |= (1 << i);\r\ndigit1 = digit2 = 0;\r\nif (*s) s++;\r\ncontinue;\r\n}\r\nreturn -6;\r\n}\r\nif (activep) *activep = active;\r\nif (bmaskp) *bmaskp = bmask;\r\nreturn 0;\r\n}\r\nstatic int FVteln2capi20(char *teln, u8 AdditionalInfo[1 + 2 + 2 + 31])\r\n{\r\nunsigned long bmask;\r\nint active;\r\nint rc, i;\r\nrc = decodeFVteln(teln, &bmask, &active);\r\nif (rc) return rc;\r\nAdditionalInfo[0] = 2 + 2 + 31;\r\nAdditionalInfo[1] = 3; AdditionalInfo[2] = 0;\r\nif (active) {\r\nAdditionalInfo[3] = 0; AdditionalInfo[4] = 0;\r\n} else {\r\nAdditionalInfo[3] = 1; AdditionalInfo[4] = 0;\r\n}\r\nAdditionalInfo[5] = 0;\r\nfor (i = 1; i <= 30; i++)\r\nAdditionalInfo[5 + i] = (bmask & (1 << i)) ? 0xff : 0;\r\nreturn 0;\r\n}\r\nstatic int capidrv_command(isdn_ctrl *c, capidrv_contr *card)\r\n{\r\nisdn_ctrl cmd;\r\nstruct capidrv_bchan *bchan;\r\nstruct capidrv_plci *plcip;\r\nu8 AdditionalInfo[1 + 2 + 2 + 31];\r\nint rc, isleasedline = 0;\r\nif (c->command == ISDN_CMD_IOCTL)\r\nreturn capidrv_ioctl(c, card);\r\nswitch (c->command) {\r\ncase ISDN_CMD_DIAL: {\r\nu8 calling[ISDN_MSNLEN + 3];\r\nu8 called[ISDN_MSNLEN + 2];\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: ISDN_CMD_DIAL(ch=%ld,\"%s,%d,%d,%s\")\n",\r\ncard->contrnr,\r\nc->arg,\r\nc->parm.setup.phone,\r\nc->parm.setup.si1,\r\nc->parm.setup.si2,\r\nc->parm.setup.eazmsn);\r\nbchan = &card->bchans[c->arg % card->nbchan];\r\nif (bchan->plcip) {\r\nprintk(KERN_ERR "capidrv-%d: dail ch=%ld,\"%s,%d,%d,%s\" in use (plci=0x%x)\n",\r\ncard->contrnr,\r\nc->arg,\r\nc->parm.setup.phone,\r\nc->parm.setup.si1,\r\nc->parm.setup.si2,\r\nc->parm.setup.eazmsn,\r\nbchan->plcip->plci);\r\nreturn 0;\r\n}\r\nbchan->si1 = c->parm.setup.si1;\r\nbchan->si2 = c->parm.setup.si2;\r\nstrncpy(bchan->num, c->parm.setup.phone, sizeof(bchan->num));\r\nstrncpy(bchan->mynum, c->parm.setup.eazmsn, sizeof(bchan->mynum));\r\nrc = FVteln2capi20(bchan->num, AdditionalInfo);\r\nisleasedline = (rc == 0);\r\nif (rc < 0)\r\nprintk(KERN_ERR "capidrv-%d: WARNING: invalid leased linedefinition \"%s\"\n", card->contrnr, bchan->num);\r\nif (isleasedline) {\r\ncalling[0] = 0;\r\ncalled[0] = 0;\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: connecting leased line\n", card->contrnr);\r\n} else {\r\ncalling[0] = strlen(bchan->mynum) + 2;\r\ncalling[1] = 0;\r\ncalling[2] = 0x80;\r\nstrncpy(calling + 3, bchan->mynum, ISDN_MSNLEN);\r\ncalled[0] = strlen(bchan->num) + 1;\r\ncalled[1] = 0x80;\r\nstrncpy(called + 2, bchan->num, ISDN_MSNLEN);\r\n}\r\ncapi_fill_CONNECT_REQ(&cmdcmsg,\r\nglobal.ap.applid,\r\ncard->msgid++,\r\ncard->contrnr,\r\nsi2cip(bchan->si1, bchan->si2),\r\ncalled,\r\ncalling,\r\nNULL,\r\nNULL,\r\nb1prot(bchan->l2, bchan->l3),\r\nb2prot(bchan->l2, bchan->l3),\r\nb3prot(bchan->l2, bchan->l3),\r\nb1config(bchan->l2, bchan->l3),\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nisleasedline ? AdditionalInfo : NULL,\r\nNULL,\r\nNULL,\r\nNULL\r\n);\r\nif ((plcip = new_plci(card, (c->arg % card->nbchan))) == NULL) {\r\ncmd.command = ISDN_STAT_DHUP;\r\ncmd.driver = card->myid;\r\ncmd.arg = (c->arg % card->nbchan);\r\ncard->interface.statcallb(&cmd);\r\nreturn -1;\r\n}\r\nplcip->msgid = cmdcmsg.Messagenumber;\r\nplcip->leasedline = isleasedline;\r\nplci_change_state(card, plcip, EV_PLCI_CONNECT_REQ);\r\nsend_message(card, &cmdcmsg);\r\nreturn 0;\r\n}\r\ncase ISDN_CMD_ACCEPTD:\r\nbchan = &card->bchans[c->arg % card->nbchan];\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: ISDN_CMD_ACCEPTD(ch=%ld) l2=%d l3=%d\n",\r\ncard->contrnr,\r\nc->arg, bchan->l2, bchan->l3);\r\ncapi_fill_CONNECT_RESP(&cmdcmsg,\r\nglobal.ap.applid,\r\ncard->msgid++,\r\nbchan->plcip->plci,\r\n0,\r\nb1prot(bchan->l2, bchan->l3),\r\nb2prot(bchan->l2, bchan->l3),\r\nb3prot(bchan->l2, bchan->l3),\r\nb1config(bchan->l2, bchan->l3),\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL\r\n);\r\nif (capi_cmsg2message(&cmdcmsg, cmdcmsg.buf)) {\r\nprintk(KERN_ERR "capidrv-%d: capidrv_command: parser failure\n",\r\ncard->contrnr);\r\nreturn -EINVAL;\r\n}\r\nplci_change_state(card, bchan->plcip, EV_PLCI_CONNECT_RESP);\r\nsend_message(card, &cmdcmsg);\r\nreturn 0;\r\ncase ISDN_CMD_ACCEPTB:\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: ISDN_CMD_ACCEPTB(ch=%ld)\n",\r\ncard->contrnr,\r\nc->arg);\r\nreturn -ENOSYS;\r\ncase ISDN_CMD_HANGUP:\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: ISDN_CMD_HANGUP(ch=%ld)\n",\r\ncard->contrnr,\r\nc->arg);\r\nbchan = &card->bchans[c->arg % card->nbchan];\r\nif (bchan->disconnecting) {\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: chan %ld already disconnecting ...\n",\r\ncard->contrnr,\r\nc->arg);\r\nreturn 0;\r\n}\r\nif (bchan->nccip) {\r\nbchan->disconnecting = 1;\r\ncapi_fill_DISCONNECT_B3_REQ(&cmdcmsg,\r\nglobal.ap.applid,\r\ncard->msgid++,\r\nbchan->nccip->ncci,\r\nNULL\r\n);\r\nncci_change_state(card, bchan->nccip, EV_NCCI_DISCONNECT_B3_REQ);\r\nsend_message(card, &cmdcmsg);\r\nreturn 0;\r\n} else if (bchan->plcip) {\r\nif (bchan->plcip->state == ST_PLCI_INCOMING) {\r\nbchan->disconnecting = 1;\r\nreturn 0;\r\n} else if (bchan->plcip->plci) {\r\nbchan->disconnecting = 1;\r\ncapi_fill_DISCONNECT_REQ(&cmdcmsg,\r\nglobal.ap.applid,\r\ncard->msgid++,\r\nbchan->plcip->plci,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL\r\n);\r\nplci_change_state(card, bchan->plcip, EV_PLCI_DISCONNECT_REQ);\r\nsend_message(card, &cmdcmsg);\r\nreturn 0;\r\n} else {\r\nprintk(KERN_ERR "capidrv-%d: chan %ld disconnect request while waiting for CONNECT_CONF\n",\r\ncard->contrnr,\r\nc->arg);\r\nreturn -EINVAL;\r\n}\r\n}\r\nprintk(KERN_ERR "capidrv-%d: chan %ld disconnect request on free channel\n",\r\ncard->contrnr,\r\nc->arg);\r\nreturn -EINVAL;\r\ncase ISDN_CMD_SETL2:\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: set L2 on chan %ld to %ld\n",\r\ncard->contrnr,\r\n(c->arg & 0xff), (c->arg >> 8));\r\nbchan = &card->bchans[(c->arg & 0xff) % card->nbchan];\r\nbchan->l2 = (c->arg >> 8);\r\nreturn 0;\r\ncase ISDN_CMD_SETL3:\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: set L3 on chan %ld to %ld\n",\r\ncard->contrnr,\r\n(c->arg & 0xff), (c->arg >> 8));\r\nbchan = &card->bchans[(c->arg & 0xff) % card->nbchan];\r\nbchan->l3 = (c->arg >> 8);\r\nreturn 0;\r\ncase ISDN_CMD_SETEAZ:\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: set EAZ \"%s\" on chan %ld\n",\r\ncard->contrnr,\r\nc->parm.num, c->arg);\r\nbchan = &card->bchans[c->arg % card->nbchan];\r\nstrncpy(bchan->msn, c->parm.num, ISDN_MSNLEN);\r\nreturn 0;\r\ncase ISDN_CMD_CLREAZ:\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: clearing EAZ on chan %ld\n",\r\ncard->contrnr, c->arg);\r\nbchan = &card->bchans[c->arg % card->nbchan];\r\nbchan->msn[0] = 0;\r\nreturn 0;\r\ndefault:\r\nprintk(KERN_ERR "capidrv-%d: ISDN_CMD_%d, Huh?\n",\r\ncard->contrnr, c->command);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int if_command(isdn_ctrl *c)\r\n{\r\ncapidrv_contr *card = findcontrbydriverid(c->driver);\r\nif (card)\r\nreturn capidrv_command(c, card);\r\nprintk(KERN_ERR\r\n"capidrv: if_command %d called with invalid driverId %d!\n",\r\nc->command, c->driver);\r\nreturn -ENODEV;\r\n}\r\nstatic int if_sendbuf(int id, int channel, int doack, struct sk_buff *skb)\r\n{\r\ncapidrv_contr *card = findcontrbydriverid(id);\r\ncapidrv_bchan *bchan;\r\ncapidrv_ncci *nccip;\r\nint len = skb->len;\r\nint msglen;\r\nu16 errcode;\r\nu16 datahandle;\r\nu32 data;\r\nif (!card) {\r\nprintk(KERN_ERR "capidrv: if_sendbuf called with invalid driverId %d!\n",\r\nid);\r\nreturn 0;\r\n}\r\nif (debugmode > 4)\r\nprintk(KERN_DEBUG "capidrv-%d: sendbuf len=%d skb=%p doack=%d\n",\r\ncard->contrnr, len, skb, doack);\r\nbchan = &card->bchans[channel % card->nbchan];\r\nnccip = bchan->nccip;\r\nif (!nccip || nccip->state != ST_NCCI_ACTIVE) {\r\nprintk(KERN_ERR "capidrv-%d: if_sendbuf: %s:%d: chan not up!\n",\r\ncard->contrnr, card->name, channel);\r\nreturn 0;\r\n}\r\ndatahandle = nccip->datahandle;\r\n#ifdef CONFIG_64BIT\r\ndata = 0;\r\n#else\r\ndata = (unsigned long) skb->data;\r\n#endif\r\ncapi_fill_DATA_B3_REQ(&sendcmsg, global.ap.applid, card->msgid++,\r\nnccip->ncci,\r\ndata,\r\nskb->len,\r\ndatahandle,\r\n0\r\n);\r\nif (capidrv_add_ack(nccip, datahandle, doack ? (int)skb->len : -1) < 0)\r\nreturn 0;\r\nif (capi_cmsg2message(&sendcmsg, sendcmsg.buf)) {\r\nprintk(KERN_ERR "capidrv-%d: if_sendbuf: parser failure\n",\r\ncard->contrnr);\r\nreturn -EINVAL;\r\n}\r\nmsglen = CAPIMSG_LEN(sendcmsg.buf);\r\nif (skb_headroom(skb) < msglen) {\r\nstruct sk_buff *nskb = skb_realloc_headroom(skb, msglen);\r\nif (!nskb) {\r\nprintk(KERN_ERR "capidrv-%d: if_sendbuf: no memory\n",\r\ncard->contrnr);\r\n(void)capidrv_del_ack(nccip, datahandle);\r\nreturn 0;\r\n}\r\nprintk(KERN_DEBUG "capidrv-%d: only %d bytes headroom, need %d\n",\r\ncard->contrnr, skb_headroom(skb), msglen);\r\nmemcpy(skb_push(nskb, msglen), sendcmsg.buf, msglen);\r\nerrcode = capi20_put_message(&global.ap, nskb);\r\nif (errcode == CAPI_NOERROR) {\r\ndev_kfree_skb(skb);\r\nnccip->datahandle++;\r\nreturn len;\r\n}\r\nif (debugmode > 3)\r\nprintk(KERN_DEBUG "capidrv-%d: sendbuf putmsg ret(%x) - %s\n",\r\ncard->contrnr, errcode, capi_info2str(errcode));\r\n(void)capidrv_del_ack(nccip, datahandle);\r\ndev_kfree_skb(nskb);\r\nreturn errcode == CAPI_SENDQUEUEFULL ? 0 : -1;\r\n} else {\r\nmemcpy(skb_push(skb, msglen), sendcmsg.buf, msglen);\r\nerrcode = capi20_put_message(&global.ap, skb);\r\nif (errcode == CAPI_NOERROR) {\r\nnccip->datahandle++;\r\nreturn len;\r\n}\r\nif (debugmode > 3)\r\nprintk(KERN_DEBUG "capidrv-%d: sendbuf putmsg ret(%x) - %s\n",\r\ncard->contrnr, errcode, capi_info2str(errcode));\r\nskb_pull(skb, msglen);\r\n(void)capidrv_del_ack(nccip, datahandle);\r\nreturn errcode == CAPI_SENDQUEUEFULL ? 0 : -1;\r\n}\r\n}\r\nstatic int if_readstat(u8 __user *buf, int len, int id, int channel)\r\n{\r\ncapidrv_contr *card = findcontrbydriverid(id);\r\nint count;\r\nu8 __user *p;\r\nif (!card) {\r\nprintk(KERN_ERR "capidrv: if_readstat called with invalid driverId %d!\n",\r\nid);\r\nreturn -ENODEV;\r\n}\r\nfor (p = buf, count = 0; count < len; p++, count++) {\r\nif (put_user(*card->q931_read++, p))\r\nreturn -EFAULT;\r\nif (card->q931_read > card->q931_end)\r\ncard->q931_read = card->q931_buf;\r\n}\r\nreturn count;\r\n}\r\nstatic void enable_dchannel_trace(capidrv_contr *card)\r\n{\r\nu8 manufacturer[CAPI_MANUFACTURER_LEN];\r\ncapi_version version;\r\nu16 contr = card->contrnr;\r\nu16 errcode;\r\nu16 avmversion[3];\r\nerrcode = capi20_get_manufacturer(contr, manufacturer);\r\nif (errcode != CAPI_NOERROR) {\r\nprintk(KERN_ERR "%s: can't get manufacturer (0x%x)\n",\r\ncard->name, errcode);\r\nreturn;\r\n}\r\nif (strstr(manufacturer, "AVM") == NULL) {\r\nprintk(KERN_ERR "%s: not from AVM, no d-channel trace possible (%s)\n",\r\ncard->name, manufacturer);\r\nreturn;\r\n}\r\nerrcode = capi20_get_version(contr, &version);\r\nif (errcode != CAPI_NOERROR) {\r\nprintk(KERN_ERR "%s: can't get version (0x%x)\n",\r\ncard->name, errcode);\r\nreturn;\r\n}\r\navmversion[0] = (version.majormanuversion >> 4) & 0x0f;\r\navmversion[1] = (version.majormanuversion << 4) & 0xf0;\r\navmversion[1] |= (version.minormanuversion >> 4) & 0x0f;\r\navmversion[2] |= version.minormanuversion & 0x0f;\r\nif (avmversion[0] > 3 || (avmversion[0] == 3 && avmversion[1] > 5)) {\r\nprintk(KERN_INFO "%s: D2 trace enabled\n", card->name);\r\ncapi_fill_MANUFACTURER_REQ(&cmdcmsg, global.ap.applid,\r\ncard->msgid++,\r\ncontr,\r\n0x214D5641,\r\n0,\r\n1,\r\n(_cstruct)"\004\200\014\000\000");\r\n} else {\r\nprintk(KERN_INFO "%s: D3 trace enabled\n", card->name);\r\ncapi_fill_MANUFACTURER_REQ(&cmdcmsg, global.ap.applid,\r\ncard->msgid++,\r\ncontr,\r\n0x214D5641,\r\n0,\r\n1,\r\n(_cstruct)"\004\002\003\000\000");\r\n}\r\nsend_message(card, &cmdcmsg);\r\n}\r\nstatic void send_listen(capidrv_contr *card)\r\n{\r\ncapi_fill_LISTEN_REQ(&cmdcmsg, global.ap.applid,\r\ncard->msgid++,\r\ncard->contrnr,\r\n1 << 6,\r\ncard->cipmask,\r\ncard->cipmask2,\r\nNULL, NULL);\r\nlisten_change_state(card, EV_LISTEN_REQ);\r\nsend_message(card, &cmdcmsg);\r\n}\r\nstatic void listentimerfunc(unsigned long x)\r\n{\r\ncapidrv_contr *card = (capidrv_contr *)x;\r\nif (card->state != ST_LISTEN_NONE && card->state != ST_LISTEN_ACTIVE)\r\nprintk(KERN_ERR "%s: controller dead ??\n", card->name);\r\nsend_listen(card);\r\nmod_timer(&card->listentimer, jiffies + 60 * HZ);\r\n}\r\nstatic int capidrv_addcontr(u16 contr, struct capi_profile *profp)\r\n{\r\ncapidrv_contr *card;\r\nunsigned long flags;\r\nisdn_ctrl cmd;\r\nchar id[20];\r\nint i;\r\nsprintf(id, "capidrv-%d", contr);\r\nif (!try_module_get(THIS_MODULE)) {\r\nprintk(KERN_WARNING "capidrv: (%s) Could not reserve module\n", id);\r\nreturn -1;\r\n}\r\nif (!(card = kzalloc(sizeof(capidrv_contr), GFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"capidrv: (%s) Could not allocate contr-struct.\n", id);\r\nreturn -1;\r\n}\r\ncard->owner = THIS_MODULE;\r\nsetup_timer(&card->listentimer, listentimerfunc, (unsigned long)card);\r\nstrcpy(card->name, id);\r\ncard->contrnr = contr;\r\ncard->nbchan = profp->nbchannel;\r\ncard->bchans = kmalloc(sizeof(capidrv_bchan) * card->nbchan, GFP_ATOMIC);\r\nif (!card->bchans) {\r\nprintk(KERN_WARNING\r\n"capidrv: (%s) Could not allocate bchan-structs.\n", id);\r\nmodule_put(card->owner);\r\nkfree(card);\r\nreturn -1;\r\n}\r\ncard->interface.channels = profp->nbchannel;\r\ncard->interface.maxbufsize = 2048;\r\ncard->interface.command = if_command;\r\ncard->interface.writebuf_skb = if_sendbuf;\r\ncard->interface.writecmd = NULL;\r\ncard->interface.readstat = if_readstat;\r\ncard->interface.features =\r\nISDN_FEATURE_L2_HDLC |\r\nISDN_FEATURE_L2_TRANS |\r\nISDN_FEATURE_L3_TRANS |\r\nISDN_FEATURE_P_UNKNOWN |\r\nISDN_FEATURE_L2_X75I |\r\nISDN_FEATURE_L2_X75UI |\r\nISDN_FEATURE_L2_X75BUI;\r\nif (profp->support1 & (1 << 2))\r\ncard->interface.features |=\r\nISDN_FEATURE_L2_V11096 |\r\nISDN_FEATURE_L2_V11019 |\r\nISDN_FEATURE_L2_V11038;\r\nif (profp->support1 & (1 << 8))\r\ncard->interface.features |= ISDN_FEATURE_L2_MODEM;\r\ncard->interface.hl_hdrlen = 22;\r\nstrncpy(card->interface.id, id, sizeof(card->interface.id) - 1);\r\ncard->q931_read = card->q931_buf;\r\ncard->q931_write = card->q931_buf;\r\ncard->q931_end = card->q931_buf + sizeof(card->q931_buf) - 1;\r\nif (!register_isdn(&card->interface)) {\r\nprintk(KERN_ERR "capidrv: Unable to register contr %s\n", id);\r\nkfree(card->bchans);\r\nmodule_put(card->owner);\r\nkfree(card);\r\nreturn -1;\r\n}\r\ncard->myid = card->interface.channels;\r\nmemset(card->bchans, 0, sizeof(capidrv_bchan) * card->nbchan);\r\nfor (i = 0; i < card->nbchan; i++) {\r\ncard->bchans[i].contr = card;\r\n}\r\nspin_lock_irqsave(&global_lock, flags);\r\ncard->next = global.contr_list;\r\nglobal.contr_list = card;\r\nglobal.ncontr++;\r\nspin_unlock_irqrestore(&global_lock, flags);\r\ncmd.command = ISDN_STAT_RUN;\r\ncmd.driver = card->myid;\r\ncard->interface.statcallb(&cmd);\r\ncard->cipmask = 0x1FFF03FF;\r\ncard->cipmask2 = 0;\r\nsend_listen(card);\r\nmod_timer(&card->listentimer, jiffies + 60 * HZ);\r\nprintk(KERN_INFO "%s: now up (%d B channels)\n",\r\ncard->name, card->nbchan);\r\nenable_dchannel_trace(card);\r\nreturn 0;\r\n}\r\nstatic int capidrv_delcontr(u16 contr)\r\n{\r\ncapidrv_contr **pp, *card;\r\nunsigned long flags;\r\nisdn_ctrl cmd;\r\nspin_lock_irqsave(&global_lock, flags);\r\nfor (card = global.contr_list; card; card = card->next) {\r\nif (card->contrnr == contr)\r\nbreak;\r\n}\r\nif (!card) {\r\nspin_unlock_irqrestore(&global_lock, flags);\r\nprintk(KERN_ERR "capidrv: delcontr: no contr %u\n", contr);\r\nreturn -1;\r\n}\r\nspin_unlock_irqrestore(&global_lock, flags);\r\ndel_timer(&card->listentimer);\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: id=%d unloading\n",\r\ncard->contrnr, card->myid);\r\ncmd.command = ISDN_STAT_STOP;\r\ncmd.driver = card->myid;\r\ncard->interface.statcallb(&cmd);\r\nwhile (card->nbchan) {\r\ncmd.command = ISDN_STAT_DISCH;\r\ncmd.driver = card->myid;\r\ncmd.arg = card->nbchan - 1;\r\ncmd.parm.num[0] = 0;\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: id=%d disable chan=%ld\n",\r\ncard->contrnr, card->myid, cmd.arg);\r\ncard->interface.statcallb(&cmd);\r\nif (card->bchans[card->nbchan - 1].nccip)\r\nfree_ncci(card, card->bchans[card->nbchan - 1].nccip);\r\nif (card->bchans[card->nbchan - 1].plcip)\r\nfree_plci(card, card->bchans[card->nbchan - 1].plcip);\r\nif (card->plci_list)\r\nprintk(KERN_ERR "capidrv: bug in free_plci()\n");\r\ncard->nbchan--;\r\n}\r\nkfree(card->bchans);\r\ncard->bchans = NULL;\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: id=%d isdn unload\n",\r\ncard->contrnr, card->myid);\r\ncmd.command = ISDN_STAT_UNLOAD;\r\ncmd.driver = card->myid;\r\ncard->interface.statcallb(&cmd);\r\nif (debugmode)\r\nprintk(KERN_DEBUG "capidrv-%d: id=%d remove contr from list\n",\r\ncard->contrnr, card->myid);\r\nspin_lock_irqsave(&global_lock, flags);\r\nfor (pp = &global.contr_list; *pp; pp = &(*pp)->next) {\r\nif (*pp == card) {\r\n*pp = (*pp)->next;\r\ncard->next = NULL;\r\nglobal.ncontr--;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&global_lock, flags);\r\nmodule_put(card->owner);\r\nprintk(KERN_INFO "%s: now down.\n", card->name);\r\nkfree(card);\r\nreturn 0;\r\n}\r\nstatic int\r\nlower_callback(struct notifier_block *nb, unsigned long val, void *v)\r\n{\r\ncapi_profile profile;\r\nu32 contr = (long)v;\r\nswitch (val) {\r\ncase CAPICTR_UP:\r\nprintk(KERN_INFO "capidrv: controller %hu up\n", contr);\r\nif (capi20_get_profile(contr, &profile) == CAPI_NOERROR)\r\n(void) capidrv_addcontr(contr, &profile);\r\nbreak;\r\ncase CAPICTR_DOWN:\r\nprintk(KERN_INFO "capidrv: controller %hu down\n", contr);\r\n(void) capidrv_delcontr(contr);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int capidrv_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "%lu %lu %lu %lu\n",\r\nglobal.ap.nrecvctlpkt,\r\nglobal.ap.nrecvdatapkt,\r\nglobal.ap.nsentctlpkt,\r\nglobal.ap.nsentdatapkt);\r\nreturn 0;\r\n}\r\nstatic int capidrv_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, capidrv_proc_show, NULL);\r\n}\r\nstatic void __init proc_init(void)\r\n{\r\nproc_create("capi/capidrv", 0, NULL, &capidrv_proc_fops);\r\n}\r\nstatic void __exit proc_exit(void)\r\n{\r\nremove_proc_entry("capi/capidrv", NULL);\r\n}\r\nstatic int __init capidrv_init(void)\r\n{\r\ncapi_profile profile;\r\nu32 ncontr, contr;\r\nu16 errcode;\r\nglobal.ap.rparam.level3cnt = -2;\r\nglobal.ap.rparam.datablkcnt = 16;\r\nglobal.ap.rparam.datablklen = 2048;\r\nglobal.ap.recv_message = capidrv_recv_message;\r\nerrcode = capi20_register(&global.ap);\r\nif (errcode) {\r\nreturn -EIO;\r\n}\r\nregister_capictr_notifier(&capictr_nb);\r\nerrcode = capi20_get_profile(0, &profile);\r\nif (errcode != CAPI_NOERROR) {\r\nunregister_capictr_notifier(&capictr_nb);\r\ncapi20_release(&global.ap);\r\nreturn -EIO;\r\n}\r\nncontr = profile.ncontroller;\r\nfor (contr = 1; contr <= ncontr; contr++) {\r\nerrcode = capi20_get_profile(contr, &profile);\r\nif (errcode != CAPI_NOERROR)\r\ncontinue;\r\n(void) capidrv_addcontr(contr, &profile);\r\n}\r\nproc_init();\r\nreturn 0;\r\n}\r\nstatic void __exit capidrv_exit(void)\r\n{\r\nunregister_capictr_notifier(&capictr_nb);\r\ncapi20_release(&global.ap);\r\nproc_exit();\r\n}
