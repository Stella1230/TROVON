static void wusb_key_dump(const void *buf, size_t len)\r\n{\r\nprint_hex_dump(KERN_ERR, " ", DUMP_PREFIX_OFFSET, 16, 1,\r\nbuf, len, 0);\r\n}\r\nstatic void bytewise_xor(void *_bo, const void *_bi1, const void *_bi2,\r\nsize_t size)\r\n{\r\nu8 *bo = _bo;\r\nconst u8 *bi1 = _bi1, *bi2 = _bi2;\r\nsize_t itr;\r\nfor (itr = 0; itr < size; itr++)\r\nbo[itr] = bi1[itr] ^ bi2[itr];\r\n}\r\nstatic int wusb_ccm_mac(struct crypto_skcipher *tfm_cbc,\r\nstruct crypto_cipher *tfm_aes,\r\nstruct wusb_mac_scratch *scratch,\r\nvoid *mic,\r\nconst struct aes_ccm_nonce *n,\r\nconst struct aes_ccm_label *a, const void *b,\r\nsize_t blen)\r\n{\r\nint result = 0;\r\nSKCIPHER_REQUEST_ON_STACK(req, tfm_cbc);\r\nstruct scatterlist sg[4], sg_dst;\r\nvoid *dst_buf;\r\nsize_t dst_size;\r\nu8 iv[crypto_skcipher_ivsize(tfm_cbc)];\r\nsize_t zero_padding;\r\nWARN_ON(sizeof(*a) != sizeof(scratch->b1) - sizeof(scratch->b1.la));\r\nWARN_ON(sizeof(scratch->b0) != sizeof(struct aes_ccm_block));\r\nWARN_ON(sizeof(scratch->b1) != sizeof(struct aes_ccm_block));\r\nWARN_ON(sizeof(scratch->ax) != sizeof(struct aes_ccm_block));\r\nresult = -ENOMEM;\r\nzero_padding = blen % sizeof(struct aes_ccm_block);\r\nif (zero_padding)\r\nzero_padding = sizeof(struct aes_ccm_block) - zero_padding;\r\ndst_size = blen + sizeof(scratch->b0) + sizeof(scratch->b1) +\r\nzero_padding;\r\ndst_buf = kzalloc(dst_size, GFP_KERNEL);\r\nif (!dst_buf)\r\ngoto error_dst_buf;\r\nmemset(iv, 0, sizeof(iv));\r\nscratch->b0.flags = 0x59;\r\nscratch->b0.ccm_nonce = *n;\r\nscratch->b0.lm = cpu_to_be16(0);\r\nscratch->b1.la = cpu_to_be16(blen + 14);\r\nmemcpy(&scratch->b1.mac_header, a, sizeof(*a));\r\nsg_init_table(sg, ARRAY_SIZE(sg));\r\nsg_set_buf(&sg[0], &scratch->b0, sizeof(scratch->b0));\r\nsg_set_buf(&sg[1], &scratch->b1, sizeof(scratch->b1));\r\nsg_set_buf(&sg[2], b, blen);\r\nsg_set_page(&sg[3], ZERO_PAGE(0), zero_padding, 0);\r\nsg_init_one(&sg_dst, dst_buf, dst_size);\r\nskcipher_request_set_tfm(req, tfm_cbc);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, sg, &sg_dst, dst_size, iv);\r\nresult = crypto_skcipher_encrypt(req);\r\nskcipher_request_zero(req);\r\nif (result < 0) {\r\nprintk(KERN_ERR "E: can't compute CBC-MAC tag (MIC): %d\n",\r\nresult);\r\ngoto error_cbc_crypt;\r\n}\r\nscratch->ax.flags = 0x01;\r\nscratch->ax.ccm_nonce = *n;\r\nscratch->ax.counter = 0;\r\ncrypto_cipher_encrypt_one(tfm_aes, (void *)&scratch->ax,\r\n(void *)&scratch->ax);\r\nbytewise_xor(mic, &scratch->ax, iv, 8);\r\nresult = 8;\r\nerror_cbc_crypt:\r\nkfree(dst_buf);\r\nerror_dst_buf:\r\nreturn result;\r\n}\r\nssize_t wusb_prf(void *out, size_t out_size,\r\nconst u8 key[16], const struct aes_ccm_nonce *_n,\r\nconst struct aes_ccm_label *a,\r\nconst void *b, size_t blen, size_t len)\r\n{\r\nssize_t result, bytes = 0, bitr;\r\nstruct aes_ccm_nonce n = *_n;\r\nstruct crypto_skcipher *tfm_cbc;\r\nstruct crypto_cipher *tfm_aes;\r\nstruct wusb_mac_scratch *scratch;\r\nu64 sfn = 0;\r\n__le64 sfn_le;\r\ntfm_cbc = crypto_alloc_skcipher("cbc(aes)", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm_cbc)) {\r\nresult = PTR_ERR(tfm_cbc);\r\nprintk(KERN_ERR "E: can't load CBC(AES): %d\n", (int)result);\r\ngoto error_alloc_cbc;\r\n}\r\nresult = crypto_skcipher_setkey(tfm_cbc, key, 16);\r\nif (result < 0) {\r\nprintk(KERN_ERR "E: can't set CBC key: %d\n", (int)result);\r\ngoto error_setkey_cbc;\r\n}\r\ntfm_aes = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm_aes)) {\r\nresult = PTR_ERR(tfm_aes);\r\nprintk(KERN_ERR "E: can't load AES: %d\n", (int)result);\r\ngoto error_alloc_aes;\r\n}\r\nresult = crypto_cipher_setkey(tfm_aes, key, 16);\r\nif (result < 0) {\r\nprintk(KERN_ERR "E: can't set AES key: %d\n", (int)result);\r\ngoto error_setkey_aes;\r\n}\r\nscratch = kmalloc(sizeof(*scratch), GFP_KERNEL);\r\nif (!scratch) {\r\nresult = -ENOMEM;\r\ngoto error_alloc_scratch;\r\n}\r\nfor (bitr = 0; bitr < (len + 63) / 64; bitr++) {\r\nsfn_le = cpu_to_le64(sfn++);\r\nmemcpy(&n.sfn, &sfn_le, sizeof(n.sfn));\r\nresult = wusb_ccm_mac(tfm_cbc, tfm_aes, scratch, out + bytes,\r\n&n, a, b, blen);\r\nif (result < 0)\r\ngoto error_ccm_mac;\r\nbytes += result;\r\n}\r\nresult = bytes;\r\nkfree(scratch);\r\nerror_alloc_scratch:\r\nerror_ccm_mac:\r\nerror_setkey_aes:\r\ncrypto_free_cipher(tfm_aes);\r\nerror_alloc_aes:\r\nerror_setkey_cbc:\r\ncrypto_free_skcipher(tfm_cbc);\r\nerror_alloc_cbc:\r\nreturn result;\r\n}\r\nstatic int wusb_oob_mic_verify(void)\r\n{\r\nint result;\r\nu8 mic[8];\r\nstruct usb_handshake stv_hsmic_hs = {\r\n.bMessageNumber = 2,\r\n.bStatus = 00,\r\n.tTKID = { 0x76, 0x98, 0x01 },\r\n.bReserved = 00,\r\n.CDID = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,\r\n0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\r\n0x3c, 0x3d, 0x3e, 0x3f },\r\n.nonce = { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,\r\n0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\r\n0x2c, 0x2d, 0x2e, 0x2f },\r\n.MIC = { 0x75, 0x6a, 0x97, 0x51, 0x0c, 0x8c,\r\n0x14, 0x7b },\r\n};\r\nsize_t hs_size;\r\nresult = wusb_oob_mic(mic, stv_hsmic_key, &stv_hsmic_n, &stv_hsmic_hs);\r\nif (result < 0)\r\nprintk(KERN_ERR "E: WUSB OOB MIC test: failed: %d\n", result);\r\nelse if (memcmp(stv_hsmic_hs.MIC, mic, sizeof(mic))) {\r\nprintk(KERN_ERR "E: OOB MIC test: "\r\n"mismatch between MIC result and WUSB1.0[A2]\n");\r\nhs_size = sizeof(stv_hsmic_hs) - sizeof(stv_hsmic_hs.MIC);\r\nprintk(KERN_ERR "E: Handshake2 in: (%zu bytes)\n", hs_size);\r\nwusb_key_dump(&stv_hsmic_hs, hs_size);\r\nprintk(KERN_ERR "E: CCM Nonce in: (%zu bytes)\n",\r\nsizeof(stv_hsmic_n));\r\nwusb_key_dump(&stv_hsmic_n, sizeof(stv_hsmic_n));\r\nprintk(KERN_ERR "E: MIC out:\n");\r\nwusb_key_dump(mic, sizeof(mic));\r\nprintk(KERN_ERR "E: MIC out (from WUSB1.0[A.2]):\n");\r\nwusb_key_dump(stv_hsmic_hs.MIC, sizeof(stv_hsmic_hs.MIC));\r\nresult = -EINVAL;\r\n} else\r\nresult = 0;\r\nreturn result;\r\n}\r\nstatic int wusb_key_derive_verify(void)\r\n{\r\nint result = 0;\r\nstruct wusb_keydvt_out keydvt_out;\r\nstruct wusb_keydvt_in stv_keydvt_in_a1 = {\r\n.hnonce = {\r\n0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\r\n0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f\r\n},\r\n.dnonce = {\r\n0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\r\n0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f\r\n}\r\n};\r\nresult = wusb_key_derive(&keydvt_out, stv_key_a1, &stv_keydvt_n_a1,\r\n&stv_keydvt_in_a1);\r\nif (result < 0)\r\nprintk(KERN_ERR "E: WUSB key derivation test: "\r\n"derivation failed: %d\n", result);\r\nif (memcmp(&stv_keydvt_out_a1, &keydvt_out, sizeof(keydvt_out))) {\r\nprintk(KERN_ERR "E: WUSB key derivation test: "\r\n"mismatch between key derivation result "\r\n"and WUSB1.0[A1] Errata 2006/12\n");\r\nprintk(KERN_ERR "E: keydvt in: key\n");\r\nwusb_key_dump(stv_key_a1, sizeof(stv_key_a1));\r\nprintk(KERN_ERR "E: keydvt in: nonce\n");\r\nwusb_key_dump(&stv_keydvt_n_a1, sizeof(stv_keydvt_n_a1));\r\nprintk(KERN_ERR "E: keydvt in: hnonce & dnonce\n");\r\nwusb_key_dump(&stv_keydvt_in_a1, sizeof(stv_keydvt_in_a1));\r\nprintk(KERN_ERR "E: keydvt out: KCK\n");\r\nwusb_key_dump(&keydvt_out.kck, sizeof(keydvt_out.kck));\r\nprintk(KERN_ERR "E: keydvt out: PTK\n");\r\nwusb_key_dump(&keydvt_out.ptk, sizeof(keydvt_out.ptk));\r\nresult = -EINVAL;\r\n} else\r\nresult = 0;\r\nreturn result;\r\n}\r\nint wusb_crypto_init(void)\r\n{\r\nint result;\r\nif (debug_crypto_verify) {\r\nresult = wusb_key_derive_verify();\r\nif (result < 0)\r\nreturn result;\r\nreturn wusb_oob_mic_verify();\r\n}\r\nreturn 0;\r\n}\r\nvoid wusb_crypto_exit(void)\r\n{\r\n}
