static int bq32k_read(struct device *dev, void *data, uint8_t off, uint8_t len)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &off,\r\n}, {\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = data,\r\n}\r\n};\r\nif (i2c_transfer(client->adapter, msgs, 2) == 2)\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nstatic int bq32k_write(struct device *dev, void *data, uint8_t off, uint8_t len)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nuint8_t buffer[len + 1];\r\nbuffer[0] = off;\r\nmemcpy(&buffer[1], data, len);\r\nif (i2c_master_send(client, buffer, len + 1) == len + 1)\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nstatic int bq32k_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct bq32k_regs regs;\r\nint error;\r\nerror = bq32k_read(dev, &regs, 0, sizeof(regs));\r\nif (error)\r\nreturn error;\r\nif (regs.minutes & BQ32K_OF)\r\nreturn -EINVAL;\r\ntm->tm_sec = bcd2bin(regs.seconds & BQ32K_SECONDS_MASK);\r\ntm->tm_min = bcd2bin(regs.minutes & BQ32K_MINUTES_MASK);\r\ntm->tm_hour = bcd2bin(regs.cent_hours & BQ32K_HOURS_MASK);\r\ntm->tm_mday = bcd2bin(regs.date);\r\ntm->tm_wday = bcd2bin(regs.day) - 1;\r\ntm->tm_mon = bcd2bin(regs.month) - 1;\r\ntm->tm_year = bcd2bin(regs.years) +\r\n((regs.cent_hours & BQ32K_CENT) ? 100 : 0);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int bq32k_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct bq32k_regs regs;\r\nregs.seconds = bin2bcd(tm->tm_sec);\r\nregs.minutes = bin2bcd(tm->tm_min);\r\nregs.cent_hours = bin2bcd(tm->tm_hour) | BQ32K_CENT_EN;\r\nregs.day = bin2bcd(tm->tm_wday + 1);\r\nregs.date = bin2bcd(tm->tm_mday);\r\nregs.month = bin2bcd(tm->tm_mon + 1);\r\nif (tm->tm_year >= 100) {\r\nregs.cent_hours |= BQ32K_CENT;\r\nregs.years = bin2bcd(tm->tm_year - 100);\r\n} else\r\nregs.years = bin2bcd(tm->tm_year);\r\nreturn bq32k_write(dev, &regs, 0, sizeof(regs));\r\n}\r\nstatic int trickle_charger_of_init(struct device *dev, struct device_node *node)\r\n{\r\nunsigned char reg;\r\nint error;\r\nu32 ohms = 0;\r\nif (of_property_read_u32(node, "trickle-resistor-ohms" , &ohms))\r\nreturn 0;\r\nswitch (ohms) {\r\ncase 180+940:\r\nif (of_property_read_bool(node, "trickle-diode-disable")) {\r\ndev_err(dev, "diode and resistor mismatch\n");\r\nreturn -EINVAL;\r\n}\r\nreg = 0x05;\r\nbreak;\r\ncase 180+20000:\r\nif (!of_property_read_bool(node, "trickle-diode-disable")) {\r\ndev_err(dev, "bq32k: diode and resistor mismatch\n");\r\nreturn -EINVAL;\r\n}\r\nreg = 0x45;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "invalid resistor value (%d)\n", ohms);\r\nreturn -EINVAL;\r\n}\r\nerror = bq32k_write(dev, &reg, BQ32K_CFG2, 1);\r\nif (error)\r\nreturn error;\r\nreg = 0x20;\r\nerror = bq32k_write(dev, &reg, BQ32K_TCH2, 1);\r\nif (error)\r\nreturn error;\r\ndev_info(dev, "Enabled trickle RTC battery charge.\n");\r\nreturn 0;\r\n}\r\nstatic ssize_t bq32k_sysfs_show_tricklecharge_bypass(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint reg, error;\r\nerror = bq32k_read(dev, &reg, BQ32K_CFG2, 1);\r\nif (error)\r\nreturn error;\r\nreturn sprintf(buf, "%d\n", (reg & BQ32K_TCFE) ? 1 : 0);\r\n}\r\nstatic ssize_t bq32k_sysfs_store_tricklecharge_bypass(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint reg, enable, error;\r\nif (kstrtoint(buf, 0, &enable))\r\nreturn -EINVAL;\r\nerror = bq32k_read(dev, &reg, BQ32K_CFG2, 1);\r\nif (error)\r\nreturn error;\r\nif (enable) {\r\nreg |= BQ32K_TCFE;\r\nerror = bq32k_write(dev, &reg, BQ32K_CFG2, 1);\r\nif (error)\r\nreturn error;\r\ndev_info(dev, "Enabled trickle charge FET bypass.\n");\r\n} else {\r\nreg &= ~BQ32K_TCFE;\r\nerror = bq32k_write(dev, &reg, BQ32K_CFG2, 1);\r\nif (error)\r\nreturn error;\r\ndev_info(dev, "Disabled trickle charge FET bypass.\n");\r\n}\r\nreturn count;\r\n}\r\nstatic int bq32k_sysfs_register(struct device *dev)\r\n{\r\nreturn device_create_file(dev, &dev_attr_trickle_charge_bypass);\r\n}\r\nstatic void bq32k_sysfs_unregister(struct device *dev)\r\n{\r\ndevice_remove_file(dev, &dev_attr_trickle_charge_bypass);\r\n}\r\nstatic int bq32k_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct rtc_device *rtc;\r\nuint8_t reg;\r\nint error;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nreturn -ENODEV;\r\nerror = bq32k_read(dev, &reg, BQ32K_SECONDS, 1);\r\nif (!error && (reg & BQ32K_STOP)) {\r\ndev_warn(dev, "Oscillator was halted. Restarting...\n");\r\nreg &= ~BQ32K_STOP;\r\nerror = bq32k_write(dev, &reg, BQ32K_SECONDS, 1);\r\n}\r\nif (error)\r\nreturn error;\r\nerror = bq32k_read(dev, &reg, BQ32K_MINUTES, 1);\r\nif (error)\r\nreturn error;\r\nif (reg & BQ32K_OF)\r\ndev_warn(dev, "Oscillator Failure. Check RTC battery.\n");\r\nif (client->dev.of_node)\r\ntrickle_charger_of_init(dev, client->dev.of_node);\r\nrtc = devm_rtc_device_register(&client->dev, bq32k_driver.driver.name,\r\n&bq32k_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc))\r\nreturn PTR_ERR(rtc);\r\nerror = bq32k_sysfs_register(&client->dev);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Unable to create sysfs entries for rtc bq32000\n");\r\nreturn error;\r\n}\r\ni2c_set_clientdata(client, rtc);\r\nreturn 0;\r\n}\r\nstatic int bq32k_remove(struct i2c_client *client)\r\n{\r\nbq32k_sysfs_unregister(&client->dev);\r\nreturn 0;\r\n}
