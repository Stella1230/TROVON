static void gpio_keys_button_event(struct input_polled_dev *dev,\r\nconst struct gpio_keys_button *button,\r\nint state)\r\n{\r\nstruct gpio_keys_polled_dev *bdev = dev->private;\r\nstruct input_dev *input = dev->input;\r\nunsigned int type = button->type ?: EV_KEY;\r\nif (type == EV_REL) {\r\nif (state) {\r\ninput_event(input, type, button->code, button->value);\r\n__set_bit(button->code, bdev->rel_axis_seen);\r\n}\r\n} else if (type == EV_ABS) {\r\nif (state) {\r\ninput_event(input, type, button->code, button->value);\r\n__set_bit(button->code, bdev->abs_axis_seen);\r\n}\r\n} else {\r\ninput_event(input, type, button->code, state);\r\ninput_sync(input);\r\n}\r\n}\r\nstatic void gpio_keys_polled_check_state(struct input_polled_dev *dev,\r\nconst struct gpio_keys_button *button,\r\nstruct gpio_keys_button_data *bdata)\r\n{\r\nint state;\r\nstate = gpiod_get_value_cansleep(bdata->gpiod);\r\nif (state < 0) {\r\ndev_err(dev->input->dev.parent,\r\n"failed to get gpio state: %d\n", state);\r\n} else {\r\ngpio_keys_button_event(dev, button, state);\r\nif (state != bdata->last_state) {\r\nbdata->count = 0;\r\nbdata->last_state = state;\r\n}\r\n}\r\n}\r\nstatic void gpio_keys_polled_poll(struct input_polled_dev *dev)\r\n{\r\nstruct gpio_keys_polled_dev *bdev = dev->private;\r\nconst struct gpio_keys_platform_data *pdata = bdev->pdata;\r\nstruct input_dev *input = dev->input;\r\nint i;\r\nmemset(bdev->rel_axis_seen, 0, sizeof(bdev->rel_axis_seen));\r\nmemset(bdev->abs_axis_seen, 0, sizeof(bdev->abs_axis_seen));\r\nfor (i = 0; i < pdata->nbuttons; i++) {\r\nstruct gpio_keys_button_data *bdata = &bdev->data[i];\r\nif (bdata->count < bdata->threshold) {\r\nbdata->count++;\r\ngpio_keys_button_event(dev, &pdata->buttons[i],\r\nbdata->last_state);\r\n} else {\r\ngpio_keys_polled_check_state(dev, &pdata->buttons[i],\r\nbdata);\r\n}\r\n}\r\nfor_each_set_bit(i, input->relbit, REL_CNT) {\r\nif (!test_bit(i, bdev->rel_axis_seen))\r\ninput_event(input, EV_REL, i, 0);\r\n}\r\nfor_each_set_bit(i, input->absbit, ABS_CNT) {\r\nif (!test_bit(i, bdev->abs_axis_seen))\r\ninput_event(input, EV_ABS, i, 0);\r\n}\r\ninput_sync(input);\r\n}\r\nstatic void gpio_keys_polled_open(struct input_polled_dev *dev)\r\n{\r\nstruct gpio_keys_polled_dev *bdev = dev->private;\r\nconst struct gpio_keys_platform_data *pdata = bdev->pdata;\r\nif (pdata->enable)\r\npdata->enable(bdev->dev);\r\n}\r\nstatic void gpio_keys_polled_close(struct input_polled_dev *dev)\r\n{\r\nstruct gpio_keys_polled_dev *bdev = dev->private;\r\nconst struct gpio_keys_platform_data *pdata = bdev->pdata;\r\nif (pdata->disable)\r\npdata->disable(bdev->dev);\r\n}\r\nstatic struct gpio_keys_platform_data *\r\ngpio_keys_polled_get_devtree_pdata(struct device *dev)\r\n{\r\nstruct gpio_keys_platform_data *pdata;\r\nstruct gpio_keys_button *button;\r\nstruct fwnode_handle *child;\r\nint nbuttons;\r\nnbuttons = device_get_child_node_count(dev);\r\nif (nbuttons == 0)\r\nreturn ERR_PTR(-EINVAL);\r\npdata = devm_kzalloc(dev, sizeof(*pdata) + nbuttons * sizeof(*button),\r\nGFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\nbutton = (struct gpio_keys_button *)(pdata + 1);\r\npdata->buttons = button;\r\npdata->nbuttons = nbuttons;\r\npdata->rep = device_property_present(dev, "autorepeat");\r\ndevice_property_read_u32(dev, "poll-interval", &pdata->poll_interval);\r\ndevice_for_each_child_node(dev, child) {\r\nif (fwnode_property_read_u32(child, "linux,code",\r\n&button->code)) {\r\ndev_err(dev, "button without keycode\n");\r\nfwnode_handle_put(child);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nfwnode_property_read_string(child, "label", &button->desc);\r\nif (fwnode_property_read_u32(child, "linux,input-type",\r\n&button->type))\r\nbutton->type = EV_KEY;\r\nif (fwnode_property_read_u32(child, "linux,input-value",\r\n(u32 *)&button->value))\r\nbutton->value = 1;\r\nbutton->wakeup =\r\nfwnode_property_read_bool(child, "wakeup-source") ||\r\nfwnode_property_read_bool(child, "gpio-key,wakeup");\r\nif (fwnode_property_read_u32(child, "debounce-interval",\r\n&button->debounce_interval))\r\nbutton->debounce_interval = 5;\r\nbutton++;\r\n}\r\nreturn pdata;\r\n}\r\nstatic void gpio_keys_polled_set_abs_params(struct input_dev *input,\r\nconst struct gpio_keys_platform_data *pdata, unsigned int code)\r\n{\r\nint i, min = 0, max = 0;\r\nfor (i = 0; i < pdata->nbuttons; i++) {\r\nconst struct gpio_keys_button *button = &pdata->buttons[i];\r\nif (button->type != EV_ABS || button->code != code)\r\ncontinue;\r\nif (button->value < min)\r\nmin = button->value;\r\nif (button->value > max)\r\nmax = button->value;\r\n}\r\ninput_set_abs_params(input, code, min, max, 0, 0);\r\n}\r\nstatic int gpio_keys_polled_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct fwnode_handle *child = NULL;\r\nconst struct gpio_keys_platform_data *pdata = dev_get_platdata(dev);\r\nstruct gpio_keys_polled_dev *bdev;\r\nstruct input_polled_dev *poll_dev;\r\nstruct input_dev *input;\r\nsize_t size;\r\nint error;\r\nint i;\r\nif (!pdata) {\r\npdata = gpio_keys_polled_get_devtree_pdata(dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n}\r\nif (!pdata->poll_interval) {\r\ndev_err(dev, "missing poll_interval value\n");\r\nreturn -EINVAL;\r\n}\r\nsize = sizeof(struct gpio_keys_polled_dev) +\r\npdata->nbuttons * sizeof(struct gpio_keys_button_data);\r\nbdev = devm_kzalloc(dev, size, GFP_KERNEL);\r\nif (!bdev) {\r\ndev_err(dev, "no memory for private data\n");\r\nreturn -ENOMEM;\r\n}\r\npoll_dev = devm_input_allocate_polled_device(dev);\r\nif (!poll_dev) {\r\ndev_err(dev, "no memory for polled device\n");\r\nreturn -ENOMEM;\r\n}\r\npoll_dev->private = bdev;\r\npoll_dev->poll = gpio_keys_polled_poll;\r\npoll_dev->poll_interval = pdata->poll_interval;\r\npoll_dev->open = gpio_keys_polled_open;\r\npoll_dev->close = gpio_keys_polled_close;\r\ninput = poll_dev->input;\r\ninput->name = pdev->name;\r\ninput->phys = DRV_NAME"/input0";\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0001;\r\ninput->id.version = 0x0100;\r\n__set_bit(EV_KEY, input->evbit);\r\nif (pdata->rep)\r\n__set_bit(EV_REP, input->evbit);\r\nfor (i = 0; i < pdata->nbuttons; i++) {\r\nconst struct gpio_keys_button *button = &pdata->buttons[i];\r\nstruct gpio_keys_button_data *bdata = &bdev->data[i];\r\nunsigned int type = button->type ?: EV_KEY;\r\nif (button->wakeup) {\r\ndev_err(dev, DRV_NAME " does not support wakeup\n");\r\nfwnode_handle_put(child);\r\nreturn -EINVAL;\r\n}\r\nif (!dev_get_platdata(dev)) {\r\nchild = device_get_next_child_node(dev, child);\r\nif (!child) {\r\ndev_err(dev, "missing child device node\n");\r\nreturn -EINVAL;\r\n}\r\nbdata->gpiod = devm_fwnode_get_gpiod_from_child(dev,\r\nNULL, child,\r\nGPIOD_IN,\r\nbutton->desc);\r\nif (IS_ERR(bdata->gpiod)) {\r\nerror = PTR_ERR(bdata->gpiod);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(dev,\r\n"failed to get gpio: %d\n",\r\nerror);\r\nfwnode_handle_put(child);\r\nreturn error;\r\n}\r\n} else if (gpio_is_valid(button->gpio)) {\r\nunsigned flags = GPIOF_IN;\r\nif (button->active_low)\r\nflags |= GPIOF_ACTIVE_LOW;\r\nerror = devm_gpio_request_one(dev, button->gpio,\r\nflags, button->desc ? : DRV_NAME);\r\nif (error) {\r\ndev_err(dev,\r\n"unable to claim gpio %u, err=%d\n",\r\nbutton->gpio, error);\r\nreturn error;\r\n}\r\nbdata->gpiod = gpio_to_desc(button->gpio);\r\nif (!bdata->gpiod) {\r\ndev_err(dev,\r\n"unable to convert gpio %u to descriptor\n",\r\nbutton->gpio);\r\nreturn -EINVAL;\r\n}\r\n}\r\nbdata->last_state = -1;\r\nbdata->threshold = DIV_ROUND_UP(button->debounce_interval,\r\npdata->poll_interval);\r\ninput_set_capability(input, type, button->code);\r\nif (type == EV_ABS)\r\ngpio_keys_polled_set_abs_params(input, pdata,\r\nbutton->code);\r\n}\r\nfwnode_handle_put(child);\r\nbdev->poll_dev = poll_dev;\r\nbdev->dev = dev;\r\nbdev->pdata = pdata;\r\nerror = input_register_polled_device(poll_dev);\r\nif (error) {\r\ndev_err(dev, "unable to register polled device, err=%d\n",\r\nerror);\r\nreturn error;\r\n}\r\nfor (i = 0; i < pdata->nbuttons; i++)\r\ngpio_keys_polled_check_state(poll_dev, &pdata->buttons[i],\r\n&bdev->data[i]);\r\ninput_sync(input);\r\nreturn 0;\r\n}
