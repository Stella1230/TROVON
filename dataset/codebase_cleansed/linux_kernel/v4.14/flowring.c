static bool\r\nbrcmf_flowring_is_tdls_mac(struct brcmf_flowring *flow, u8 mac[ETH_ALEN])\r\n{\r\nstruct brcmf_flowring_tdls_entry *search;\r\nsearch = flow->tdls_entry;\r\nwhile (search) {\r\nif (memcmp(search->mac, mac, ETH_ALEN) == 0)\r\nreturn true;\r\nsearch = search->next;\r\n}\r\nreturn false;\r\n}\r\nu32 brcmf_flowring_lookup(struct brcmf_flowring *flow, u8 da[ETH_ALEN],\r\nu8 prio, u8 ifidx)\r\n{\r\nstruct brcmf_flowring_hash *hash;\r\nu16 hash_idx;\r\nu32 i;\r\nbool found;\r\nbool sta;\r\nu8 fifo;\r\nu8 *mac;\r\nfifo = brcmf_flowring_prio2fifo[prio];\r\nsta = (flow->addr_mode[ifidx] == ADDR_INDIRECT);\r\nmac = da;\r\nif ((!sta) && (is_multicast_ether_addr(da))) {\r\nmac = (u8 *)ALLFFMAC;\r\nfifo = 0;\r\n}\r\nif ((sta) && (flow->tdls_active) &&\r\n(brcmf_flowring_is_tdls_mac(flow, da))) {\r\nsta = false;\r\n}\r\nhash_idx = sta ? BRCMF_FLOWRING_HASH_STA(fifo, ifidx) :\r\nBRCMF_FLOWRING_HASH_AP(mac, fifo, ifidx);\r\nhash_idx &= (BRCMF_FLOWRING_HASHSIZE - 1);\r\nfound = false;\r\nhash = flow->hash;\r\nfor (i = 0; i < BRCMF_FLOWRING_HASHSIZE; i++) {\r\nif ((sta || (memcmp(hash[hash_idx].mac, mac, ETH_ALEN) == 0)) &&\r\n(hash[hash_idx].fifo == fifo) &&\r\n(hash[hash_idx].ifidx == ifidx)) {\r\nfound = true;\r\nbreak;\r\n}\r\nhash_idx++;\r\nhash_idx &= (BRCMF_FLOWRING_HASHSIZE - 1);\r\n}\r\nif (found)\r\nreturn hash[hash_idx].flowid;\r\nreturn BRCMF_FLOWRING_INVALID_ID;\r\n}\r\nu32 brcmf_flowring_create(struct brcmf_flowring *flow, u8 da[ETH_ALEN],\r\nu8 prio, u8 ifidx)\r\n{\r\nstruct brcmf_flowring_ring *ring;\r\nstruct brcmf_flowring_hash *hash;\r\nu16 hash_idx;\r\nu32 i;\r\nbool found;\r\nu8 fifo;\r\nbool sta;\r\nu8 *mac;\r\nfifo = brcmf_flowring_prio2fifo[prio];\r\nsta = (flow->addr_mode[ifidx] == ADDR_INDIRECT);\r\nmac = da;\r\nif ((!sta) && (is_multicast_ether_addr(da))) {\r\nmac = (u8 *)ALLFFMAC;\r\nfifo = 0;\r\n}\r\nif ((sta) && (flow->tdls_active) &&\r\n(brcmf_flowring_is_tdls_mac(flow, da))) {\r\nsta = false;\r\n}\r\nhash_idx = sta ? BRCMF_FLOWRING_HASH_STA(fifo, ifidx) :\r\nBRCMF_FLOWRING_HASH_AP(mac, fifo, ifidx);\r\nhash_idx &= (BRCMF_FLOWRING_HASHSIZE - 1);\r\nfound = false;\r\nhash = flow->hash;\r\nfor (i = 0; i < BRCMF_FLOWRING_HASHSIZE; i++) {\r\nif ((hash[hash_idx].ifidx == BRCMF_FLOWRING_INVALID_IFIDX) &&\r\n(is_zero_ether_addr(hash[hash_idx].mac))) {\r\nfound = true;\r\nbreak;\r\n}\r\nhash_idx++;\r\nhash_idx &= (BRCMF_FLOWRING_HASHSIZE - 1);\r\n}\r\nif (found) {\r\nfor (i = 0; i < flow->nrofrings; i++) {\r\nif (flow->rings[i] == NULL)\r\nbreak;\r\n}\r\nif (i == flow->nrofrings)\r\nreturn -ENOMEM;\r\nring = kzalloc(sizeof(*ring), GFP_ATOMIC);\r\nif (!ring)\r\nreturn -ENOMEM;\r\nmemcpy(hash[hash_idx].mac, mac, ETH_ALEN);\r\nhash[hash_idx].fifo = fifo;\r\nhash[hash_idx].ifidx = ifidx;\r\nhash[hash_idx].flowid = i;\r\nring->hash_id = hash_idx;\r\nring->status = RING_CLOSED;\r\nskb_queue_head_init(&ring->skblist);\r\nflow->rings[i] = ring;\r\nreturn i;\r\n}\r\nreturn BRCMF_FLOWRING_INVALID_ID;\r\n}\r\nu8 brcmf_flowring_tid(struct brcmf_flowring *flow, u16 flowid)\r\n{\r\nstruct brcmf_flowring_ring *ring;\r\nring = flow->rings[flowid];\r\nreturn flow->hash[ring->hash_id].fifo;\r\n}\r\nstatic void brcmf_flowring_block(struct brcmf_flowring *flow, u16 flowid,\r\nbool blocked)\r\n{\r\nstruct brcmf_flowring_ring *ring;\r\nstruct brcmf_bus *bus_if;\r\nstruct brcmf_pub *drvr;\r\nstruct brcmf_if *ifp;\r\nbool currently_blocked;\r\nint i;\r\nu8 ifidx;\r\nunsigned long flags;\r\nspin_lock_irqsave(&flow->block_lock, flags);\r\nring = flow->rings[flowid];\r\nif (ring->blocked == blocked) {\r\nspin_unlock_irqrestore(&flow->block_lock, flags);\r\nreturn;\r\n}\r\nifidx = brcmf_flowring_ifidx_get(flow, flowid);\r\ncurrently_blocked = false;\r\nfor (i = 0; i < flow->nrofrings; i++) {\r\nif ((flow->rings[i]) && (i != flowid)) {\r\nring = flow->rings[i];\r\nif ((ring->status == RING_OPEN) &&\r\n(brcmf_flowring_ifidx_get(flow, i) == ifidx)) {\r\nif (ring->blocked) {\r\ncurrently_blocked = true;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nflow->rings[flowid]->blocked = blocked;\r\nif (currently_blocked) {\r\nspin_unlock_irqrestore(&flow->block_lock, flags);\r\nreturn;\r\n}\r\nbus_if = dev_get_drvdata(flow->dev);\r\ndrvr = bus_if->drvr;\r\nifp = brcmf_get_ifp(drvr, ifidx);\r\nbrcmf_txflowblock_if(ifp, BRCMF_NETIF_STOP_REASON_FLOW, blocked);\r\nspin_unlock_irqrestore(&flow->block_lock, flags);\r\n}\r\nvoid brcmf_flowring_delete(struct brcmf_flowring *flow, u16 flowid)\r\n{\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(flow->dev);\r\nstruct brcmf_flowring_ring *ring;\r\nstruct brcmf_if *ifp;\r\nu16 hash_idx;\r\nu8 ifidx;\r\nstruct sk_buff *skb;\r\nring = flow->rings[flowid];\r\nif (!ring)\r\nreturn;\r\nifidx = brcmf_flowring_ifidx_get(flow, flowid);\r\nifp = brcmf_get_ifp(bus_if->drvr, ifidx);\r\nbrcmf_flowring_block(flow, flowid, false);\r\nhash_idx = ring->hash_id;\r\nflow->hash[hash_idx].ifidx = BRCMF_FLOWRING_INVALID_IFIDX;\r\neth_zero_addr(flow->hash[hash_idx].mac);\r\nflow->rings[flowid] = NULL;\r\nskb = skb_dequeue(&ring->skblist);\r\nwhile (skb) {\r\nbrcmf_txfinalize(ifp, skb, false);\r\nskb = skb_dequeue(&ring->skblist);\r\n}\r\nkfree(ring);\r\n}\r\nu32 brcmf_flowring_enqueue(struct brcmf_flowring *flow, u16 flowid,\r\nstruct sk_buff *skb)\r\n{\r\nstruct brcmf_flowring_ring *ring;\r\nring = flow->rings[flowid];\r\nskb_queue_tail(&ring->skblist, skb);\r\nif (!ring->blocked &&\r\n(skb_queue_len(&ring->skblist) > BRCMF_FLOWRING_HIGH)) {\r\nbrcmf_flowring_block(flow, flowid, true);\r\nbrcmf_dbg(MSGBUF, "Flowcontrol: BLOCK for ring %d\n", flowid);\r\nif (skb_queue_len(&ring->skblist) < BRCMF_FLOWRING_LOW)\r\nbrcmf_flowring_block(flow, flowid, false);\r\n}\r\nreturn skb_queue_len(&ring->skblist);\r\n}\r\nstruct sk_buff *brcmf_flowring_dequeue(struct brcmf_flowring *flow, u16 flowid)\r\n{\r\nstruct brcmf_flowring_ring *ring;\r\nstruct sk_buff *skb;\r\nring = flow->rings[flowid];\r\nif (ring->status != RING_OPEN)\r\nreturn NULL;\r\nskb = skb_dequeue(&ring->skblist);\r\nif (ring->blocked &&\r\n(skb_queue_len(&ring->skblist) < BRCMF_FLOWRING_LOW)) {\r\nbrcmf_flowring_block(flow, flowid, false);\r\nbrcmf_dbg(MSGBUF, "Flowcontrol: OPEN for ring %d\n", flowid);\r\n}\r\nreturn skb;\r\n}\r\nvoid brcmf_flowring_reinsert(struct brcmf_flowring *flow, u16 flowid,\r\nstruct sk_buff *skb)\r\n{\r\nstruct brcmf_flowring_ring *ring;\r\nring = flow->rings[flowid];\r\nskb_queue_head(&ring->skblist, skb);\r\n}\r\nu32 brcmf_flowring_qlen(struct brcmf_flowring *flow, u16 flowid)\r\n{\r\nstruct brcmf_flowring_ring *ring;\r\nring = flow->rings[flowid];\r\nif (!ring)\r\nreturn 0;\r\nif (ring->status != RING_OPEN)\r\nreturn 0;\r\nreturn skb_queue_len(&ring->skblist);\r\n}\r\nvoid brcmf_flowring_open(struct brcmf_flowring *flow, u16 flowid)\r\n{\r\nstruct brcmf_flowring_ring *ring;\r\nring = flow->rings[flowid];\r\nif (!ring) {\r\nbrcmf_err("Ring NULL, for flowid %d\n", flowid);\r\nreturn;\r\n}\r\nring->status = RING_OPEN;\r\n}\r\nu8 brcmf_flowring_ifidx_get(struct brcmf_flowring *flow, u16 flowid)\r\n{\r\nstruct brcmf_flowring_ring *ring;\r\nu16 hash_idx;\r\nring = flow->rings[flowid];\r\nhash_idx = ring->hash_id;\r\nreturn flow->hash[hash_idx].ifidx;\r\n}\r\nstruct brcmf_flowring *brcmf_flowring_attach(struct device *dev, u16 nrofrings)\r\n{\r\nstruct brcmf_flowring *flow;\r\nu32 i;\r\nflow = kzalloc(sizeof(*flow), GFP_KERNEL);\r\nif (flow) {\r\nflow->dev = dev;\r\nflow->nrofrings = nrofrings;\r\nspin_lock_init(&flow->block_lock);\r\nfor (i = 0; i < ARRAY_SIZE(flow->addr_mode); i++)\r\nflow->addr_mode[i] = ADDR_INDIRECT;\r\nfor (i = 0; i < ARRAY_SIZE(flow->hash); i++)\r\nflow->hash[i].ifidx = BRCMF_FLOWRING_INVALID_IFIDX;\r\nflow->rings = kcalloc(nrofrings, sizeof(*flow->rings),\r\nGFP_KERNEL);\r\nif (!flow->rings) {\r\nkfree(flow);\r\nflow = NULL;\r\n}\r\n}\r\nreturn flow;\r\n}\r\nvoid brcmf_flowring_detach(struct brcmf_flowring *flow)\r\n{\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(flow->dev);\r\nstruct brcmf_pub *drvr = bus_if->drvr;\r\nstruct brcmf_flowring_tdls_entry *search;\r\nstruct brcmf_flowring_tdls_entry *remove;\r\nu16 flowid;\r\nfor (flowid = 0; flowid < flow->nrofrings; flowid++) {\r\nif (flow->rings[flowid])\r\nbrcmf_msgbuf_delete_flowring(drvr, flowid);\r\n}\r\nsearch = flow->tdls_entry;\r\nwhile (search) {\r\nremove = search;\r\nsearch = search->next;\r\nkfree(remove);\r\n}\r\nkfree(flow->rings);\r\nkfree(flow);\r\n}\r\nvoid brcmf_flowring_configure_addr_mode(struct brcmf_flowring *flow, int ifidx,\r\nenum proto_addr_mode addr_mode)\r\n{\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(flow->dev);\r\nstruct brcmf_pub *drvr = bus_if->drvr;\r\nu32 i;\r\nu16 flowid;\r\nif (flow->addr_mode[ifidx] != addr_mode) {\r\nfor (i = 0; i < ARRAY_SIZE(flow->hash); i++) {\r\nif (flow->hash[i].ifidx == ifidx) {\r\nflowid = flow->hash[i].flowid;\r\nif (flow->rings[flowid]->status != RING_OPEN)\r\ncontinue;\r\nflow->rings[flowid]->status = RING_CLOSING;\r\nbrcmf_msgbuf_delete_flowring(drvr, flowid);\r\n}\r\n}\r\nflow->addr_mode[ifidx] = addr_mode;\r\n}\r\n}\r\nvoid brcmf_flowring_delete_peer(struct brcmf_flowring *flow, int ifidx,\r\nu8 peer[ETH_ALEN])\r\n{\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(flow->dev);\r\nstruct brcmf_pub *drvr = bus_if->drvr;\r\nstruct brcmf_flowring_hash *hash;\r\nstruct brcmf_flowring_tdls_entry *prev;\r\nstruct brcmf_flowring_tdls_entry *search;\r\nu32 i;\r\nu16 flowid;\r\nbool sta;\r\nsta = (flow->addr_mode[ifidx] == ADDR_INDIRECT);\r\nsearch = flow->tdls_entry;\r\nprev = NULL;\r\nwhile (search) {\r\nif (memcmp(search->mac, peer, ETH_ALEN) == 0) {\r\nsta = false;\r\nbreak;\r\n}\r\nprev = search;\r\nsearch = search->next;\r\n}\r\nhash = flow->hash;\r\nfor (i = 0; i < BRCMF_FLOWRING_HASHSIZE; i++) {\r\nif ((sta || (memcmp(hash[i].mac, peer, ETH_ALEN) == 0)) &&\r\n(hash[i].ifidx == ifidx)) {\r\nflowid = flow->hash[i].flowid;\r\nif (flow->rings[flowid]->status == RING_OPEN) {\r\nflow->rings[flowid]->status = RING_CLOSING;\r\nbrcmf_msgbuf_delete_flowring(drvr, flowid);\r\n}\r\n}\r\n}\r\nif (search) {\r\nif (prev)\r\nprev->next = search->next;\r\nelse\r\nflow->tdls_entry = search->next;\r\nkfree(search);\r\nif (flow->tdls_entry == NULL)\r\nflow->tdls_active = false;\r\n}\r\n}\r\nvoid brcmf_flowring_add_tdls_peer(struct brcmf_flowring *flow, int ifidx,\r\nu8 peer[ETH_ALEN])\r\n{\r\nstruct brcmf_flowring_tdls_entry *tdls_entry;\r\nstruct brcmf_flowring_tdls_entry *search;\r\ntdls_entry = kzalloc(sizeof(*tdls_entry), GFP_ATOMIC);\r\nif (tdls_entry == NULL)\r\nreturn;\r\nmemcpy(tdls_entry->mac, peer, ETH_ALEN);\r\ntdls_entry->next = NULL;\r\nif (flow->tdls_entry == NULL) {\r\nflow->tdls_entry = tdls_entry;\r\n} else {\r\nsearch = flow->tdls_entry;\r\nif (memcmp(search->mac, peer, ETH_ALEN) == 0)\r\ngoto free_entry;\r\nwhile (search->next) {\r\nsearch = search->next;\r\nif (memcmp(search->mac, peer, ETH_ALEN) == 0)\r\ngoto free_entry;\r\n}\r\nsearch->next = tdls_entry;\r\n}\r\nflow->tdls_active = true;\r\nreturn;\r\nfree_entry:\r\nkfree(tdls_entry);\r\n}
