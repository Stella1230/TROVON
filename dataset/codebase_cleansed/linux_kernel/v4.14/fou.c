static inline struct fou *fou_from_sock(struct sock *sk)\r\n{\r\nreturn sk->sk_user_data;\r\n}\r\nstatic int fou_recv_pull(struct sk_buff *skb, struct fou *fou, size_t len)\r\n{\r\nif (fou->family == AF_INET)\r\nip_hdr(skb)->tot_len = htons(ntohs(ip_hdr(skb)->tot_len) - len);\r\nelse\r\nipv6_hdr(skb)->payload_len =\r\nhtons(ntohs(ipv6_hdr(skb)->payload_len) - len);\r\n__skb_pull(skb, len);\r\nskb_postpull_rcsum(skb, udp_hdr(skb), len);\r\nskb_reset_transport_header(skb);\r\nreturn iptunnel_pull_offloads(skb);\r\n}\r\nstatic int fou_udp_recv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct fou *fou = fou_from_sock(sk);\r\nif (!fou)\r\nreturn 1;\r\nif (fou_recv_pull(skb, fou, sizeof(struct udphdr)))\r\ngoto drop;\r\nreturn -fou->protocol;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic struct guehdr *gue_remcsum(struct sk_buff *skb, struct guehdr *guehdr,\r\nvoid *data, size_t hdrlen, u8 ipproto,\r\nbool nopartial)\r\n{\r\n__be16 *pd = data;\r\nsize_t start = ntohs(pd[0]);\r\nsize_t offset = ntohs(pd[1]);\r\nsize_t plen = sizeof(struct udphdr) + hdrlen +\r\nmax_t(size_t, offset + sizeof(u16), start);\r\nif (skb->remcsum_offload)\r\nreturn guehdr;\r\nif (!pskb_may_pull(skb, plen))\r\nreturn NULL;\r\nguehdr = (struct guehdr *)&udp_hdr(skb)[1];\r\nskb_remcsum_process(skb, (void *)guehdr + hdrlen,\r\nstart, offset, nopartial);\r\nreturn guehdr;\r\n}\r\nstatic int gue_control_message(struct sk_buff *skb, struct guehdr *guehdr)\r\n{\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int gue_udp_recv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct fou *fou = fou_from_sock(sk);\r\nsize_t len, optlen, hdrlen;\r\nstruct guehdr *guehdr;\r\nvoid *data;\r\nu16 doffset = 0;\r\nif (!fou)\r\nreturn 1;\r\nlen = sizeof(struct udphdr) + sizeof(struct guehdr);\r\nif (!pskb_may_pull(skb, len))\r\ngoto drop;\r\nguehdr = (struct guehdr *)&udp_hdr(skb)[1];\r\nswitch (guehdr->version) {\r\ncase 0:\r\nbreak;\r\ncase 1: {\r\nint prot;\r\nswitch (((struct iphdr *)guehdr)->version) {\r\ncase 4:\r\nprot = IPPROTO_IPIP;\r\nbreak;\r\ncase 6:\r\nprot = IPPROTO_IPV6;\r\nbreak;\r\ndefault:\r\ngoto drop;\r\n}\r\nif (fou_recv_pull(skb, fou, sizeof(struct udphdr)))\r\ngoto drop;\r\nreturn -prot;\r\n}\r\ndefault:\r\ngoto drop;\r\n}\r\noptlen = guehdr->hlen << 2;\r\nlen += optlen;\r\nif (!pskb_may_pull(skb, len))\r\ngoto drop;\r\nguehdr = (struct guehdr *)&udp_hdr(skb)[1];\r\nhdrlen = sizeof(struct guehdr) + optlen;\r\nif (guehdr->version != 0 || validate_gue_flags(guehdr, optlen))\r\ngoto drop;\r\nhdrlen = sizeof(struct guehdr) + optlen;\r\nif (fou->family == AF_INET)\r\nip_hdr(skb)->tot_len = htons(ntohs(ip_hdr(skb)->tot_len) - len);\r\nelse\r\nipv6_hdr(skb)->payload_len =\r\nhtons(ntohs(ipv6_hdr(skb)->payload_len) - len);\r\nskb_postpull_rcsum(skb, udp_hdr(skb), len);\r\ndata = &guehdr[1];\r\nif (guehdr->flags & GUE_FLAG_PRIV) {\r\n__be32 flags = *(__be32 *)(data + doffset);\r\ndoffset += GUE_LEN_PRIV;\r\nif (flags & GUE_PFLAG_REMCSUM) {\r\nguehdr = gue_remcsum(skb, guehdr, data + doffset,\r\nhdrlen, guehdr->proto_ctype,\r\n!!(fou->flags &\r\nFOU_F_REMCSUM_NOPARTIAL));\r\nif (!guehdr)\r\ngoto drop;\r\ndata = &guehdr[1];\r\ndoffset += GUE_PLEN_REMCSUM;\r\n}\r\n}\r\nif (unlikely(guehdr->control))\r\nreturn gue_control_message(skb, guehdr);\r\n__skb_pull(skb, sizeof(struct udphdr) + hdrlen);\r\nskb_reset_transport_header(skb);\r\nif (iptunnel_pull_offloads(skb))\r\ngoto drop;\r\nreturn -guehdr->proto_ctype;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff **fou_gro_receive(struct sock *sk,\r\nstruct sk_buff **head,\r\nstruct sk_buff *skb)\r\n{\r\nconst struct net_offload *ops;\r\nstruct sk_buff **pp = NULL;\r\nu8 proto = fou_from_sock(sk)->protocol;\r\nconst struct net_offload **offloads;\r\nNAPI_GRO_CB(skb)->encap_mark = 0;\r\nNAPI_GRO_CB(skb)->is_fou = 1;\r\nrcu_read_lock();\r\noffloads = NAPI_GRO_CB(skb)->is_ipv6 ? inet6_offloads : inet_offloads;\r\nops = rcu_dereference(offloads[proto]);\r\nif (!ops || !ops->callbacks.gro_receive)\r\ngoto out_unlock;\r\npp = call_gro_receive(ops->callbacks.gro_receive, head, skb);\r\nout_unlock:\r\nrcu_read_unlock();\r\nreturn pp;\r\n}\r\nstatic int fou_gro_complete(struct sock *sk, struct sk_buff *skb,\r\nint nhoff)\r\n{\r\nconst struct net_offload *ops;\r\nu8 proto = fou_from_sock(sk)->protocol;\r\nint err = -ENOSYS;\r\nconst struct net_offload **offloads;\r\nrcu_read_lock();\r\noffloads = NAPI_GRO_CB(skb)->is_ipv6 ? inet6_offloads : inet_offloads;\r\nops = rcu_dereference(offloads[proto]);\r\nif (WARN_ON(!ops || !ops->callbacks.gro_complete))\r\ngoto out_unlock;\r\nerr = ops->callbacks.gro_complete(skb, nhoff);\r\nskb_set_inner_mac_header(skb, nhoff);\r\nout_unlock:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic struct guehdr *gue_gro_remcsum(struct sk_buff *skb, unsigned int off,\r\nstruct guehdr *guehdr, void *data,\r\nsize_t hdrlen, struct gro_remcsum *grc,\r\nbool nopartial)\r\n{\r\n__be16 *pd = data;\r\nsize_t start = ntohs(pd[0]);\r\nsize_t offset = ntohs(pd[1]);\r\nif (skb->remcsum_offload)\r\nreturn guehdr;\r\nif (!NAPI_GRO_CB(skb)->csum_valid)\r\nreturn NULL;\r\nguehdr = skb_gro_remcsum_process(skb, (void *)guehdr, off, hdrlen,\r\nstart, offset, grc, nopartial);\r\nskb->remcsum_offload = 1;\r\nreturn guehdr;\r\n}\r\nstatic struct sk_buff **gue_gro_receive(struct sock *sk,\r\nstruct sk_buff **head,\r\nstruct sk_buff *skb)\r\n{\r\nconst struct net_offload **offloads;\r\nconst struct net_offload *ops;\r\nstruct sk_buff **pp = NULL;\r\nstruct sk_buff *p;\r\nstruct guehdr *guehdr;\r\nsize_t len, optlen, hdrlen, off;\r\nvoid *data;\r\nu16 doffset = 0;\r\nint flush = 1;\r\nstruct fou *fou = fou_from_sock(sk);\r\nstruct gro_remcsum grc;\r\nu8 proto;\r\nskb_gro_remcsum_init(&grc);\r\noff = skb_gro_offset(skb);\r\nlen = off + sizeof(*guehdr);\r\nguehdr = skb_gro_header_fast(skb, off);\r\nif (skb_gro_header_hard(skb, len)) {\r\nguehdr = skb_gro_header_slow(skb, len, off);\r\nif (unlikely(!guehdr))\r\ngoto out;\r\n}\r\nswitch (guehdr->version) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nswitch (((struct iphdr *)guehdr)->version) {\r\ncase 4:\r\nproto = IPPROTO_IPIP;\r\nbreak;\r\ncase 6:\r\nproto = IPPROTO_IPV6;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\ngoto next_proto;\r\ndefault:\r\ngoto out;\r\n}\r\noptlen = guehdr->hlen << 2;\r\nlen += optlen;\r\nif (skb_gro_header_hard(skb, len)) {\r\nguehdr = skb_gro_header_slow(skb, len, off);\r\nif (unlikely(!guehdr))\r\ngoto out;\r\n}\r\nif (unlikely(guehdr->control) || guehdr->version != 0 ||\r\nvalidate_gue_flags(guehdr, optlen))\r\ngoto out;\r\nhdrlen = sizeof(*guehdr) + optlen;\r\nskb_gro_postpull_rcsum(skb, guehdr, hdrlen);\r\ndata = &guehdr[1];\r\nif (guehdr->flags & GUE_FLAG_PRIV) {\r\n__be32 flags = *(__be32 *)(data + doffset);\r\ndoffset += GUE_LEN_PRIV;\r\nif (flags & GUE_PFLAG_REMCSUM) {\r\nguehdr = gue_gro_remcsum(skb, off, guehdr,\r\ndata + doffset, hdrlen, &grc,\r\n!!(fou->flags &\r\nFOU_F_REMCSUM_NOPARTIAL));\r\nif (!guehdr)\r\ngoto out;\r\ndata = &guehdr[1];\r\ndoffset += GUE_PLEN_REMCSUM;\r\n}\r\n}\r\nskb_gro_pull(skb, hdrlen);\r\nfor (p = *head; p; p = p->next) {\r\nconst struct guehdr *guehdr2;\r\nif (!NAPI_GRO_CB(p)->same_flow)\r\ncontinue;\r\nguehdr2 = (struct guehdr *)(p->data + off);\r\nif (guehdr->word != guehdr2->word) {\r\nNAPI_GRO_CB(p)->same_flow = 0;\r\ncontinue;\r\n}\r\nif (guehdr->hlen && memcmp(&guehdr[1], &guehdr2[1],\r\nguehdr->hlen << 2)) {\r\nNAPI_GRO_CB(p)->same_flow = 0;\r\ncontinue;\r\n}\r\n}\r\nproto = guehdr->proto_ctype;\r\nnext_proto:\r\nNAPI_GRO_CB(skb)->encap_mark = 0;\r\nNAPI_GRO_CB(skb)->is_fou = 1;\r\nrcu_read_lock();\r\noffloads = NAPI_GRO_CB(skb)->is_ipv6 ? inet6_offloads : inet_offloads;\r\nops = rcu_dereference(offloads[proto]);\r\nif (WARN_ON_ONCE(!ops || !ops->callbacks.gro_receive))\r\ngoto out_unlock;\r\npp = call_gro_receive(ops->callbacks.gro_receive, head, skb);\r\nflush = 0;\r\nout_unlock:\r\nrcu_read_unlock();\r\nout:\r\nNAPI_GRO_CB(skb)->flush |= flush;\r\nskb_gro_remcsum_cleanup(skb, &grc);\r\nskb->remcsum_offload = 0;\r\nreturn pp;\r\n}\r\nstatic int gue_gro_complete(struct sock *sk, struct sk_buff *skb, int nhoff)\r\n{\r\nconst struct net_offload **offloads;\r\nstruct guehdr *guehdr = (struct guehdr *)(skb->data + nhoff);\r\nconst struct net_offload *ops;\r\nunsigned int guehlen = 0;\r\nu8 proto;\r\nint err = -ENOENT;\r\nswitch (guehdr->version) {\r\ncase 0:\r\nproto = guehdr->proto_ctype;\r\nguehlen = sizeof(*guehdr) + (guehdr->hlen << 2);\r\nbreak;\r\ncase 1:\r\nswitch (((struct iphdr *)guehdr)->version) {\r\ncase 4:\r\nproto = IPPROTO_IPIP;\r\nbreak;\r\ncase 6:\r\nproto = IPPROTO_IPV6;\r\nbreak;\r\ndefault:\r\nreturn err;\r\n}\r\nbreak;\r\ndefault:\r\nreturn err;\r\n}\r\nrcu_read_lock();\r\noffloads = NAPI_GRO_CB(skb)->is_ipv6 ? inet6_offloads : inet_offloads;\r\nops = rcu_dereference(offloads[proto]);\r\nif (WARN_ON(!ops || !ops->callbacks.gro_complete))\r\ngoto out_unlock;\r\nerr = ops->callbacks.gro_complete(skb, nhoff + guehlen);\r\nskb_set_inner_mac_header(skb, nhoff + guehlen);\r\nout_unlock:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic int fou_add_to_port_list(struct net *net, struct fou *fou)\r\n{\r\nstruct fou_net *fn = net_generic(net, fou_net_id);\r\nstruct fou *fout;\r\nmutex_lock(&fn->fou_lock);\r\nlist_for_each_entry(fout, &fn->fou_list, list) {\r\nif (fou->port == fout->port &&\r\nfou->family == fout->family) {\r\nmutex_unlock(&fn->fou_lock);\r\nreturn -EALREADY;\r\n}\r\n}\r\nlist_add(&fou->list, &fn->fou_list);\r\nmutex_unlock(&fn->fou_lock);\r\nreturn 0;\r\n}\r\nstatic void fou_release(struct fou *fou)\r\n{\r\nstruct socket *sock = fou->sock;\r\nlist_del(&fou->list);\r\nudp_tunnel_sock_release(sock);\r\nkfree_rcu(fou, rcu);\r\n}\r\nstatic int fou_create(struct net *net, struct fou_cfg *cfg,\r\nstruct socket **sockp)\r\n{\r\nstruct socket *sock = NULL;\r\nstruct fou *fou = NULL;\r\nstruct sock *sk;\r\nstruct udp_tunnel_sock_cfg tunnel_cfg;\r\nint err;\r\nerr = udp_sock_create(net, &cfg->udp_config, &sock);\r\nif (err < 0)\r\ngoto error;\r\nfou = kzalloc(sizeof(*fou), GFP_KERNEL);\r\nif (!fou) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nsk = sock->sk;\r\nfou->port = cfg->udp_config.local_udp_port;\r\nfou->family = cfg->udp_config.family;\r\nfou->flags = cfg->flags;\r\nfou->type = cfg->type;\r\nfou->sock = sock;\r\nmemset(&tunnel_cfg, 0, sizeof(tunnel_cfg));\r\ntunnel_cfg.encap_type = 1;\r\ntunnel_cfg.sk_user_data = fou;\r\ntunnel_cfg.encap_destroy = NULL;\r\nswitch (cfg->type) {\r\ncase FOU_ENCAP_DIRECT:\r\ntunnel_cfg.encap_rcv = fou_udp_recv;\r\ntunnel_cfg.gro_receive = fou_gro_receive;\r\ntunnel_cfg.gro_complete = fou_gro_complete;\r\nfou->protocol = cfg->protocol;\r\nbreak;\r\ncase FOU_ENCAP_GUE:\r\ntunnel_cfg.encap_rcv = gue_udp_recv;\r\ntunnel_cfg.gro_receive = gue_gro_receive;\r\ntunnel_cfg.gro_complete = gue_gro_complete;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nsetup_udp_tunnel_sock(net, sock, &tunnel_cfg);\r\nsk->sk_allocation = GFP_ATOMIC;\r\nerr = fou_add_to_port_list(net, fou);\r\nif (err)\r\ngoto error;\r\nif (sockp)\r\n*sockp = sock;\r\nreturn 0;\r\nerror:\r\nkfree(fou);\r\nif (sock)\r\nudp_tunnel_sock_release(sock);\r\nreturn err;\r\n}\r\nstatic int fou_destroy(struct net *net, struct fou_cfg *cfg)\r\n{\r\nstruct fou_net *fn = net_generic(net, fou_net_id);\r\n__be16 port = cfg->udp_config.local_udp_port;\r\nu8 family = cfg->udp_config.family;\r\nint err = -EINVAL;\r\nstruct fou *fou;\r\nmutex_lock(&fn->fou_lock);\r\nlist_for_each_entry(fou, &fn->fou_list, list) {\r\nif (fou->port == port && fou->family == family) {\r\nfou_release(fou);\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&fn->fou_lock);\r\nreturn err;\r\n}\r\nstatic int parse_nl_config(struct genl_info *info,\r\nstruct fou_cfg *cfg)\r\n{\r\nmemset(cfg, 0, sizeof(*cfg));\r\ncfg->udp_config.family = AF_INET;\r\nif (info->attrs[FOU_ATTR_AF]) {\r\nu8 family = nla_get_u8(info->attrs[FOU_ATTR_AF]);\r\nswitch (family) {\r\ncase AF_INET:\r\nbreak;\r\ncase AF_INET6:\r\ncfg->udp_config.ipv6_v6only = 1;\r\nbreak;\r\ndefault:\r\nreturn -EAFNOSUPPORT;\r\n}\r\ncfg->udp_config.family = family;\r\n}\r\nif (info->attrs[FOU_ATTR_PORT]) {\r\n__be16 port = nla_get_be16(info->attrs[FOU_ATTR_PORT]);\r\ncfg->udp_config.local_udp_port = port;\r\n}\r\nif (info->attrs[FOU_ATTR_IPPROTO])\r\ncfg->protocol = nla_get_u8(info->attrs[FOU_ATTR_IPPROTO]);\r\nif (info->attrs[FOU_ATTR_TYPE])\r\ncfg->type = nla_get_u8(info->attrs[FOU_ATTR_TYPE]);\r\nif (info->attrs[FOU_ATTR_REMCSUM_NOPARTIAL])\r\ncfg->flags |= FOU_F_REMCSUM_NOPARTIAL;\r\nreturn 0;\r\n}\r\nstatic int fou_nl_cmd_add_port(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct net *net = genl_info_net(info);\r\nstruct fou_cfg cfg;\r\nint err;\r\nerr = parse_nl_config(info, &cfg);\r\nif (err)\r\nreturn err;\r\nreturn fou_create(net, &cfg, NULL);\r\n}\r\nstatic int fou_nl_cmd_rm_port(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct net *net = genl_info_net(info);\r\nstruct fou_cfg cfg;\r\nint err;\r\nerr = parse_nl_config(info, &cfg);\r\nif (err)\r\nreturn err;\r\nreturn fou_destroy(net, &cfg);\r\n}\r\nstatic int fou_fill_info(struct fou *fou, struct sk_buff *msg)\r\n{\r\nif (nla_put_u8(msg, FOU_ATTR_AF, fou->sock->sk->sk_family) ||\r\nnla_put_be16(msg, FOU_ATTR_PORT, fou->port) ||\r\nnla_put_u8(msg, FOU_ATTR_IPPROTO, fou->protocol) ||\r\nnla_put_u8(msg, FOU_ATTR_TYPE, fou->type))\r\nreturn -1;\r\nif (fou->flags & FOU_F_REMCSUM_NOPARTIAL)\r\nif (nla_put_flag(msg, FOU_ATTR_REMCSUM_NOPARTIAL))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int fou_dump_info(struct fou *fou, u32 portid, u32 seq,\r\nu32 flags, struct sk_buff *skb, u8 cmd)\r\n{\r\nvoid *hdr;\r\nhdr = genlmsg_put(skb, portid, seq, &fou_nl_family, flags, cmd);\r\nif (!hdr)\r\nreturn -ENOMEM;\r\nif (fou_fill_info(fou, skb) < 0)\r\ngoto nla_put_failure;\r\ngenlmsg_end(skb, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(skb, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int fou_nl_cmd_get_port(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct net *net = genl_info_net(info);\r\nstruct fou_net *fn = net_generic(net, fou_net_id);\r\nstruct sk_buff *msg;\r\nstruct fou_cfg cfg;\r\nstruct fou *fout;\r\n__be16 port;\r\nu8 family;\r\nint ret;\r\nret = parse_nl_config(info, &cfg);\r\nif (ret)\r\nreturn ret;\r\nport = cfg.udp_config.local_udp_port;\r\nif (port == 0)\r\nreturn -EINVAL;\r\nfamily = cfg.udp_config.family;\r\nif (family != AF_INET && family != AF_INET6)\r\nreturn -EINVAL;\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nret = -ESRCH;\r\nmutex_lock(&fn->fou_lock);\r\nlist_for_each_entry(fout, &fn->fou_list, list) {\r\nif (port == fout->port && family == fout->family) {\r\nret = fou_dump_info(fout, info->snd_portid,\r\ninfo->snd_seq, 0, msg,\r\ninfo->genlhdr->cmd);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&fn->fou_lock);\r\nif (ret < 0)\r\ngoto out_free;\r\nreturn genlmsg_reply(msg, info);\r\nout_free:\r\nnlmsg_free(msg);\r\nreturn ret;\r\n}\r\nstatic int fou_nl_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct fou_net *fn = net_generic(net, fou_net_id);\r\nstruct fou *fout;\r\nint idx = 0, ret;\r\nmutex_lock(&fn->fou_lock);\r\nlist_for_each_entry(fout, &fn->fou_list, list) {\r\nif (idx++ < cb->args[0])\r\ncontinue;\r\nret = fou_dump_info(fout, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI,\r\nskb, FOU_CMD_GET);\r\nif (ret)\r\nbreak;\r\n}\r\nmutex_unlock(&fn->fou_lock);\r\ncb->args[0] = idx;\r\nreturn skb->len;\r\n}\r\nsize_t fou_encap_hlen(struct ip_tunnel_encap *e)\r\n{\r\nreturn sizeof(struct udphdr);\r\n}\r\nsize_t gue_encap_hlen(struct ip_tunnel_encap *e)\r\n{\r\nsize_t len;\r\nbool need_priv = false;\r\nlen = sizeof(struct udphdr) + sizeof(struct guehdr);\r\nif (e->flags & TUNNEL_ENCAP_FLAG_REMCSUM) {\r\nlen += GUE_PLEN_REMCSUM;\r\nneed_priv = true;\r\n}\r\nlen += need_priv ? GUE_LEN_PRIV : 0;\r\nreturn len;\r\n}\r\nint __fou_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,\r\nu8 *protocol, __be16 *sport, int type)\r\n{\r\nint err;\r\nerr = iptunnel_handle_offloads(skb, type);\r\nif (err)\r\nreturn err;\r\n*sport = e->sport ? : udp_flow_src_port(dev_net(skb->dev),\r\nskb, 0, 0, false);\r\nreturn 0;\r\n}\r\nint __gue_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,\r\nu8 *protocol, __be16 *sport, int type)\r\n{\r\nstruct guehdr *guehdr;\r\nsize_t hdrlen, optlen = 0;\r\nvoid *data;\r\nbool need_priv = false;\r\nint err;\r\nif ((e->flags & TUNNEL_ENCAP_FLAG_REMCSUM) &&\r\nskb->ip_summed == CHECKSUM_PARTIAL) {\r\noptlen += GUE_PLEN_REMCSUM;\r\ntype |= SKB_GSO_TUNNEL_REMCSUM;\r\nneed_priv = true;\r\n}\r\noptlen += need_priv ? GUE_LEN_PRIV : 0;\r\nerr = iptunnel_handle_offloads(skb, type);\r\nif (err)\r\nreturn err;\r\n*sport = e->sport ? : udp_flow_src_port(dev_net(skb->dev),\r\nskb, 0, 0, false);\r\nhdrlen = sizeof(struct guehdr) + optlen;\r\nskb_push(skb, hdrlen);\r\nguehdr = (struct guehdr *)skb->data;\r\nguehdr->control = 0;\r\nguehdr->version = 0;\r\nguehdr->hlen = optlen >> 2;\r\nguehdr->flags = 0;\r\nguehdr->proto_ctype = *protocol;\r\ndata = &guehdr[1];\r\nif (need_priv) {\r\n__be32 *flags = data;\r\nguehdr->flags |= GUE_FLAG_PRIV;\r\n*flags = 0;\r\ndata += GUE_LEN_PRIV;\r\nif (type & SKB_GSO_TUNNEL_REMCSUM) {\r\nu16 csum_start = skb_checksum_start_offset(skb);\r\n__be16 *pd = data;\r\nif (csum_start < hdrlen)\r\nreturn -EINVAL;\r\ncsum_start -= hdrlen;\r\npd[0] = htons(csum_start);\r\npd[1] = htons(csum_start + skb->csum_offset);\r\nif (!skb_is_gso(skb)) {\r\nskb->ip_summed = CHECKSUM_NONE;\r\nskb->encapsulation = 0;\r\n}\r\n*flags |= GUE_PFLAG_REMCSUM;\r\ndata += GUE_PLEN_REMCSUM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void fou_build_udp(struct sk_buff *skb, struct ip_tunnel_encap *e,\r\nstruct flowi4 *fl4, u8 *protocol, __be16 sport)\r\n{\r\nstruct udphdr *uh;\r\nskb_push(skb, sizeof(struct udphdr));\r\nskb_reset_transport_header(skb);\r\nuh = udp_hdr(skb);\r\nuh->dest = e->dport;\r\nuh->source = sport;\r\nuh->len = htons(skb->len);\r\nudp_set_csum(!(e->flags & TUNNEL_ENCAP_FLAG_CSUM), skb,\r\nfl4->saddr, fl4->daddr, skb->len);\r\n*protocol = IPPROTO_UDP;\r\n}\r\nstatic int fou_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,\r\nu8 *protocol, struct flowi4 *fl4)\r\n{\r\nint type = e->flags & TUNNEL_ENCAP_FLAG_CSUM ? SKB_GSO_UDP_TUNNEL_CSUM :\r\nSKB_GSO_UDP_TUNNEL;\r\n__be16 sport;\r\nint err;\r\nerr = __fou_build_header(skb, e, protocol, &sport, type);\r\nif (err)\r\nreturn err;\r\nfou_build_udp(skb, e, fl4, protocol, sport);\r\nreturn 0;\r\n}\r\nstatic int gue_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,\r\nu8 *protocol, struct flowi4 *fl4)\r\n{\r\nint type = e->flags & TUNNEL_ENCAP_FLAG_CSUM ? SKB_GSO_UDP_TUNNEL_CSUM :\r\nSKB_GSO_UDP_TUNNEL;\r\n__be16 sport;\r\nint err;\r\nerr = __gue_build_header(skb, e, protocol, &sport, type);\r\nif (err)\r\nreturn err;\r\nfou_build_udp(skb, e, fl4, protocol, sport);\r\nreturn 0;\r\n}\r\nstatic int ip_tunnel_encap_add_fou_ops(void)\r\n{\r\nint ret;\r\nret = ip_tunnel_encap_add_ops(&fou_iptun_ops, TUNNEL_ENCAP_FOU);\r\nif (ret < 0) {\r\npr_err("can't add fou ops\n");\r\nreturn ret;\r\n}\r\nret = ip_tunnel_encap_add_ops(&gue_iptun_ops, TUNNEL_ENCAP_GUE);\r\nif (ret < 0) {\r\npr_err("can't add gue ops\n");\r\nip_tunnel_encap_del_ops(&fou_iptun_ops, TUNNEL_ENCAP_FOU);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ip_tunnel_encap_del_fou_ops(void)\r\n{\r\nip_tunnel_encap_del_ops(&fou_iptun_ops, TUNNEL_ENCAP_FOU);\r\nip_tunnel_encap_del_ops(&gue_iptun_ops, TUNNEL_ENCAP_GUE);\r\n}\r\nstatic int ip_tunnel_encap_add_fou_ops(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ip_tunnel_encap_del_fou_ops(void)\r\n{\r\n}\r\nstatic __net_init int fou_init_net(struct net *net)\r\n{\r\nstruct fou_net *fn = net_generic(net, fou_net_id);\r\nINIT_LIST_HEAD(&fn->fou_list);\r\nmutex_init(&fn->fou_lock);\r\nreturn 0;\r\n}\r\nstatic __net_exit void fou_exit_net(struct net *net)\r\n{\r\nstruct fou_net *fn = net_generic(net, fou_net_id);\r\nstruct fou *fou, *next;\r\nmutex_lock(&fn->fou_lock);\r\nlist_for_each_entry_safe(fou, next, &fn->fou_list, list)\r\nfou_release(fou);\r\nmutex_unlock(&fn->fou_lock);\r\n}\r\nstatic int __init fou_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_device(&fou_net_ops);\r\nif (ret)\r\ngoto exit;\r\nret = genl_register_family(&fou_nl_family);\r\nif (ret < 0)\r\ngoto unregister;\r\nret = ip_tunnel_encap_add_fou_ops();\r\nif (ret == 0)\r\nreturn 0;\r\ngenl_unregister_family(&fou_nl_family);\r\nunregister:\r\nunregister_pernet_device(&fou_net_ops);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic void __exit fou_fini(void)\r\n{\r\nip_tunnel_encap_del_fou_ops();\r\ngenl_unregister_family(&fou_nl_family);\r\nunregister_pernet_device(&fou_net_ops);\r\n}
