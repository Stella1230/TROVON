static int usbduxfast_send_cmd(struct comedi_device *dev, int cmd_type)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usbduxfast_private *devpriv = dev->private;\r\nint nsent;\r\nint ret;\r\ndevpriv->duxbuf[0] = cmd_type;\r\nret = usb_bulk_msg(usb, usb_sndbulkpipe(usb, CHANNELLISTEP),\r\ndevpriv->duxbuf, SIZEOFDUXBUF,\r\n&nsent, 10000);\r\nif (ret < 0)\r\ndev_err(dev->class_dev,\r\n"could not transmit command to the usb-device, err=%d\n",\r\nret);\r\nreturn ret;\r\n}\r\nstatic void usbduxfast_cmd_data(struct comedi_device *dev, int index,\r\nu8 len, u8 op, u8 out, u8 log)\r\n{\r\nstruct usbduxfast_private *devpriv = dev->private;\r\ndevpriv->duxbuf[1 + 0x00 + index] = len;\r\ndevpriv->duxbuf[1 + 0x08 + index] = op;\r\ndevpriv->duxbuf[1 + 0x10 + index] = out;\r\ndevpriv->duxbuf[1 + 0x18 + index] = log;\r\n}\r\nstatic int usbduxfast_ai_stop(struct comedi_device *dev, int do_unlink)\r\n{\r\nstruct usbduxfast_private *devpriv = dev->private;\r\ndevpriv->ai_cmd_running = 0;\r\nif (do_unlink && devpriv->urb) {\r\nusb_kill_urb(devpriv->urb);\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbduxfast_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbduxfast_private *devpriv = dev->private;\r\nint ret;\r\nmutex_lock(&devpriv->mut);\r\nret = usbduxfast_ai_stop(dev, 1);\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\nstatic void usbduxfast_ai_handle_urb(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct urb *urb)\r\n{\r\nstruct usbduxfast_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nint ret;\r\nif (devpriv->ignore) {\r\ndevpriv->ignore--;\r\n} else {\r\nunsigned int nsamples;\r\nnsamples = comedi_bytes_to_samples(s, urb->actual_length);\r\nnsamples = comedi_nsamples_left(s, nsamples);\r\ncomedi_buf_write_samples(s, urb->transfer_buffer, nsamples);\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg)\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\nif (!(async->events & COMEDI_CB_CANCEL_MASK)) {\r\nurb->dev = comedi_to_usb_dev(dev);\r\nurb->status = 0;\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev, "urb resubm failed: %d", ret);\r\nasync->events |= COMEDI_CB_ERROR;\r\n}\r\n}\r\n}\r\nstatic void usbduxfast_ai_interrupt(struct urb *urb)\r\n{\r\nstruct comedi_device *dev = urb->context;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct usbduxfast_private *devpriv = dev->private;\r\nif (!devpriv->ai_cmd_running)\r\nreturn;\r\nswitch (urb->status) {\r\ncase 0:\r\nusbduxfast_ai_handle_urb(dev, s, urb);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNABORTED:\r\nasync->events |= COMEDI_CB_ERROR;\r\nbreak;\r\ndefault:\r\ndev_err(dev->class_dev,\r\n"non-zero urb status received in ai intr context: %d\n",\r\nurb->status);\r\nasync->events |= COMEDI_CB_ERROR;\r\nbreak;\r\n}\r\nif (async->events & COMEDI_CB_CANCEL_MASK)\r\nusbduxfast_ai_stop(dev, 0);\r\ncomedi_event(dev, s);\r\n}\r\nstatic int usbduxfast_submit_urb(struct comedi_device *dev)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usbduxfast_private *devpriv = dev->private;\r\nint ret;\r\nusb_fill_bulk_urb(devpriv->urb, usb, usb_rcvbulkpipe(usb, BULKINEP),\r\ndevpriv->inbuf, SIZEINBUF,\r\nusbduxfast_ai_interrupt, dev);\r\nret = usb_submit_urb(devpriv->urb, GFP_ATOMIC);\r\nif (ret) {\r\ndev_err(dev->class_dev, "usb_submit_urb error %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbduxfast_ai_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int gain0 = CR_RANGE(cmd->chanlist[0]);\r\nint i;\r\nif (cmd->chanlist_len > 3 && cmd->chanlist_len != 16) {\r\ndev_err(dev->class_dev, "unsupported combination of channels\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < cmd->chanlist_len; ++i) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned int gain = CR_RANGE(cmd->chanlist[i]);\r\nif (chan != i) {\r\ndev_err(dev->class_dev,\r\n"channels are not consecutive\n");\r\nreturn -EINVAL;\r\n}\r\nif (gain != gain0 && cmd->chanlist_len > 3) {\r\ndev_err(dev->class_dev,\r\n"gain must be the same for all channels\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbduxfast_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nunsigned int steps;\r\nunsigned int arg;\r\nerr |= comedi_check_trigger_src(&cmd->start_src,\r\nTRIG_NOW | TRIG_EXT | TRIG_INT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (!cmd->chanlist_len)\r\nerr |= -EINVAL;\r\nif (cmd->start_src == TRIG_EXT &&\r\ncmd->chanlist_len != 1 && cmd->chanlist_len != 16)\r\nerr |= -EINVAL;\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nsteps = (cmd->convert_arg * 30) / 1000;\r\nif (cmd->chanlist_len != 1)\r\nerr |= comedi_check_trigger_arg_min(&steps,\r\nMIN_SAMPLING_PERIOD);\r\nerr |= comedi_check_trigger_arg_max(&steps, MAX_SAMPLING_PERIOD);\r\narg = (steps * 1000) / 30;\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= usbduxfast_ai_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int usbduxfast_ai_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct usbduxfast_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint ret;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\nmutex_lock(&devpriv->mut);\r\nif (!devpriv->ai_cmd_running) {\r\ndevpriv->ai_cmd_running = 1;\r\nret = usbduxfast_submit_urb(dev);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev, "urbSubmit: err=%d\n", ret);\r\ndevpriv->ai_cmd_running = 0;\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\ns->async->inttrig = NULL;\r\n} else {\r\ndev_err(dev->class_dev, "ai is already running\n");\r\n}\r\nmutex_unlock(&devpriv->mut);\r\nreturn 1;\r\n}\r\nstatic int usbduxfast_ai_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbduxfast_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int rngmask = 0xff;\r\nint j, ret;\r\nlong steps, steps_tmp;\r\nmutex_lock(&devpriv->mut);\r\nif (devpriv->ai_cmd_running) {\r\nret = -EBUSY;\r\ngoto cmd_exit;\r\n}\r\ndevpriv->ignore = PACKETS_TO_IGNORE;\r\nsteps = (cmd->convert_arg * 30) / 1000;\r\nswitch (cmd->chanlist_len) {\r\ncase 1:\r\nif (CR_RANGE(cmd->chanlist[0]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nif (cmd->start_src == TRIG_EXT) {\r\nusbduxfast_cmd_data(dev, 0, 0x01, 0x01, rngmask, 0x00);\r\n} else {\r\nusbduxfast_cmd_data(dev, 0, 0x01, 0x00, rngmask, 0x00);\r\n}\r\nif (steps < MIN_SAMPLING_PERIOD) {\r\nif (steps <= 1) {\r\nusbduxfast_cmd_data(dev, 1,\r\n0x89, 0x03, rngmask, 0xff);\r\n} else {\r\nusbduxfast_cmd_data(dev, 1, steps - 1,\r\n0x02, rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 2,\r\n0x09, 0x01, rngmask, 0xff);\r\n}\r\n} else {\r\nsteps = steps - 1;\r\nusbduxfast_cmd_data(dev, 1,\r\nsteps / 2, 0x00, rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 2, steps - steps / 2,\r\n0x00, rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 3,\r\n0x09, 0x03, rngmask, 0xff);\r\n}\r\nbreak;\r\ncase 2:\r\nif (CR_RANGE(cmd->chanlist[0]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nusbduxfast_cmd_data(dev, 0, 0x01, 0x02, rngmask, 0x00);\r\nsteps_tmp = steps - 1;\r\nif (CR_RANGE(cmd->chanlist[1]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nusbduxfast_cmd_data(dev, 1, steps_tmp / 2,\r\n0x00, 0xfe & rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 2, steps_tmp - steps_tmp / 2,\r\n0x00, rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 3, 0x01, 0x02, rngmask, 0x00);\r\nsteps_tmp = steps - 2;\r\nif (CR_RANGE(cmd->chanlist[0]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nusbduxfast_cmd_data(dev, 4, steps_tmp / 2,\r\n0x00, (0xff - 0x02) & rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 5, steps_tmp - steps_tmp / 2,\r\n0x00, rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 6, 0x01, 0x00, rngmask, 0x00);\r\nbreak;\r\ncase 3:\r\nfor (j = 0; j < 1; j++) {\r\nint index = j * 2;\r\nif (CR_RANGE(cmd->chanlist[j]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nusbduxfast_cmd_data(dev, index, steps / 2,\r\n0x02, rngmask, 0x00);\r\nif (CR_RANGE(cmd->chanlist[j + 1]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nusbduxfast_cmd_data(dev, index + 1, steps - steps / 2,\r\n0x00, 0xfe & rngmask, 0x00);\r\n}\r\nsteps_tmp = steps - 2;\r\nusbduxfast_cmd_data(dev, 4, steps_tmp / 2,\r\n0x02, rngmask, 0x00);\r\nif (CR_RANGE(cmd->chanlist[0]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nusbduxfast_cmd_data(dev, 5, steps_tmp - steps_tmp / 2,\r\n0x00, (0xff - 0x02) & rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 6, 0x01, 0x00, rngmask, 0x00);\r\nbreak;\r\ncase 16:\r\nif (CR_RANGE(cmd->chanlist[0]) > 0)\r\nrngmask = 0xff - 0x04;\r\nelse\r\nrngmask = 0xff;\r\nif (cmd->start_src == TRIG_EXT) {\r\nusbduxfast_cmd_data(dev, 0, 0x01, 0x01,\r\n(0xff - 0x02) & rngmask, 0x00);\r\n} else {\r\nusbduxfast_cmd_data(dev, 0, 0xff, 0x00,\r\n(0xff - 0x02) & rngmask, 0x00);\r\n}\r\nusbduxfast_cmd_data(dev, 1, 0x01, 0x02, rngmask, 0x00);\r\nsteps = steps - 2;\r\nusbduxfast_cmd_data(dev, 2, steps / 2,\r\n0x00, 0xfe & rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 3, steps - steps / 2,\r\n0x00, rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 4, 0x09, 0x01, rngmask, 0xff);\r\nbreak;\r\n}\r\nret = usbduxfast_send_cmd(dev, SENDADCOMMANDS);\r\nif (ret < 0)\r\ngoto cmd_exit;\r\nif ((cmd->start_src == TRIG_NOW) || (cmd->start_src == TRIG_EXT)) {\r\ndevpriv->ai_cmd_running = 1;\r\nret = usbduxfast_submit_urb(dev);\r\nif (ret < 0) {\r\ndevpriv->ai_cmd_running = 0;\r\ngoto cmd_exit;\r\n}\r\ns->async->inttrig = NULL;\r\n} else {\r\ns->async->inttrig = usbduxfast_ai_inttrig;\r\n}\r\ncmd_exit:\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\nstatic int usbduxfast_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usbduxfast_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nu8 rngmask = range ? (0xff - 0x04) : 0xff;\r\nint i, j, n, actual_length;\r\nint ret;\r\nmutex_lock(&devpriv->mut);\r\nif (devpriv->ai_cmd_running) {\r\ndev_err(dev->class_dev,\r\n"ai_insn_read not possible, async cmd is running\n");\r\nmutex_unlock(&devpriv->mut);\r\nreturn -EBUSY;\r\n}\r\nusbduxfast_cmd_data(dev, 0, 0x01, 0x02, rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 1, 0x0c, 0x00, 0xfe & rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 2, 0x01, 0x00, 0xfe & rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 3, 0x01, 0x00, 0xfe & rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 4, 0x01, 0x00, 0xfe & rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 5, 0x0c, 0x00, rngmask, 0x00);\r\nusbduxfast_cmd_data(dev, 6, 0x01, 0x00, rngmask, 0x00);\r\nret = usbduxfast_send_cmd(dev, SENDADCOMMANDS);\r\nif (ret < 0) {\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < PACKETS_TO_IGNORE; i++) {\r\nret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, BULKINEP),\r\ndevpriv->inbuf, SIZEINBUF,\r\n&actual_length, 10000);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev, "insn timeout, no data\n");\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\n}\r\nfor (i = 0; i < insn->n;) {\r\nret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, BULKINEP),\r\ndevpriv->inbuf, SIZEINBUF,\r\n&actual_length, 10000);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev, "insn data error: %d\n", ret);\r\nmutex_unlock(&devpriv->mut);\r\nreturn ret;\r\n}\r\nn = actual_length / sizeof(u16);\r\nif ((n % 16) != 0) {\r\ndev_err(dev->class_dev, "insn data packet corrupted\n");\r\nmutex_unlock(&devpriv->mut);\r\nreturn -EINVAL;\r\n}\r\nfor (j = chan; (j < n) && (i < insn->n); j = j + 16) {\r\ndata[i] = ((u16 *)(devpriv->inbuf))[j];\r\ni++;\r\n}\r\n}\r\nmutex_unlock(&devpriv->mut);\r\nreturn insn->n;\r\n}\r\nstatic int usbduxfast_upload_firmware(struct comedi_device *dev,\r\nconst u8 *data, size_t size,\r\nunsigned long context)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nu8 *buf;\r\nunsigned char *tmp;\r\nint ret;\r\nif (!data)\r\nreturn 0;\r\nif (size > FIRMWARE_MAX_LEN) {\r\ndev_err(dev->class_dev, "firmware binary too large for FX2\n");\r\nreturn -ENOMEM;\r\n}\r\nbuf = kmemdup(data, size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\ntmp = kmalloc(1, GFP_KERNEL);\r\nif (!tmp) {\r\nkfree(buf);\r\nreturn -ENOMEM;\r\n}\r\n*tmp = 1;\r\nret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\r\nUSBDUXFASTSUB_FIRMWARE,\r\nVENDOR_DIR_OUT,\r\nUSBDUXFASTSUB_CPUCS, 0x0000,\r\ntmp, 1,\r\nEZTIMEOUT);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev, "can not stop firmware\n");\r\ngoto done;\r\n}\r\nret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\r\nUSBDUXFASTSUB_FIRMWARE,\r\nVENDOR_DIR_OUT,\r\n0, 0x0000,\r\nbuf, size,\r\nEZTIMEOUT);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev, "firmware upload failed\n");\r\ngoto done;\r\n}\r\n*tmp = 0;\r\nret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\r\nUSBDUXFASTSUB_FIRMWARE,\r\nVENDOR_DIR_OUT,\r\nUSBDUXFASTSUB_CPUCS, 0x0000,\r\ntmp, 1,\r\nEZTIMEOUT);\r\nif (ret < 0)\r\ndev_err(dev->class_dev, "can not start firmware\n");\r\ndone:\r\nkfree(tmp);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int usbduxfast_auto_attach(struct comedi_device *dev,\r\nunsigned long context_unused)\r\n{\r\nstruct usb_interface *intf = comedi_to_usb_interface(dev);\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usbduxfast_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nif (usb->speed != USB_SPEED_HIGH) {\r\ndev_err(dev->class_dev,\r\n"This driver needs USB 2.0 to operate. Aborting...\n");\r\nreturn -ENODEV;\r\n}\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nmutex_init(&devpriv->mut);\r\nusb_set_intfdata(intf, devpriv);\r\ndevpriv->duxbuf = kmalloc(SIZEOFDUXBUF, GFP_KERNEL);\r\nif (!devpriv->duxbuf)\r\nreturn -ENOMEM;\r\nret = usb_set_interface(usb,\r\nintf->altsetting->desc.bInterfaceNumber, 1);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev,\r\n"could not switch to alternate setting 1\n");\r\nreturn -ENODEV;\r\n}\r\ndevpriv->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!devpriv->urb)\r\nreturn -ENOMEM;\r\ndevpriv->inbuf = kmalloc(SIZEINBUF, GFP_KERNEL);\r\nif (!devpriv->inbuf)\r\nreturn -ENOMEM;\r\nret = comedi_load_firmware(dev, &usb->dev, FIRMWARE,\r\nusbduxfast_upload_firmware, 0);\r\nif (ret)\r\nreturn ret;\r\nret = comedi_alloc_subdevices(dev, 1);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;\r\ns->n_chan = 16;\r\ns->maxdata = 0x1000;\r\ns->range_table = &range_usbduxfast_ai_range;\r\ns->insn_read = usbduxfast_ai_insn_read;\r\ns->len_chanlist = s->n_chan;\r\ns->do_cmdtest = usbduxfast_ai_cmdtest;\r\ns->do_cmd = usbduxfast_ai_cmd;\r\ns->cancel = usbduxfast_ai_cancel;\r\nreturn 0;\r\n}\r\nstatic void usbduxfast_detach(struct comedi_device *dev)\r\n{\r\nstruct usb_interface *intf = comedi_to_usb_interface(dev);\r\nstruct usbduxfast_private *devpriv = dev->private;\r\nif (!devpriv)\r\nreturn;\r\nmutex_lock(&devpriv->mut);\r\nusb_set_intfdata(intf, NULL);\r\nif (devpriv->urb) {\r\nusb_kill_urb(devpriv->urb);\r\nkfree(devpriv->inbuf);\r\nusb_free_urb(devpriv->urb);\r\n}\r\nkfree(devpriv->duxbuf);\r\nmutex_unlock(&devpriv->mut);\r\n}\r\nstatic int usbduxfast_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn comedi_usb_auto_config(intf, &usbduxfast_driver, 0);\r\n}
