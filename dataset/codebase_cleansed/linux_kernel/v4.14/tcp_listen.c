int rds_tcp_keepalive(struct socket *sock)\r\n{\r\nint keepidle = 5;\r\nint keepcnt = 5;\r\nint keepalive = 1;\r\nint ret = 0;\r\nret = kernel_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,\r\n(char *)&keepalive, sizeof(keepalive));\r\nif (ret < 0)\r\ngoto bail;\r\nret = kernel_setsockopt(sock, IPPROTO_TCP, TCP_KEEPCNT,\r\n(char *)&keepcnt, sizeof(keepcnt));\r\nif (ret < 0)\r\ngoto bail;\r\nret = kernel_setsockopt(sock, IPPROTO_TCP, TCP_KEEPIDLE,\r\n(char *)&keepidle, sizeof(keepidle));\r\nif (ret < 0)\r\ngoto bail;\r\nret = kernel_setsockopt(sock, IPPROTO_TCP, TCP_KEEPINTVL,\r\n(char *)&keepidle, sizeof(keepidle));\r\nbail:\r\nreturn ret;\r\n}\r\nstatic\r\nstruct rds_tcp_connection *rds_tcp_accept_one_path(struct rds_connection *conn)\r\n{\r\nint i;\r\nbool peer_is_smaller = IS_CANONICAL(conn->c_faddr, conn->c_laddr);\r\nint npaths = max_t(int, 1, conn->c_npaths);\r\nif (!peer_is_smaller) {\r\nif (npaths == 1)\r\nrds_conn_path_connect_if_down(&conn->c_path[0]);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < npaths; i++) {\r\nstruct rds_conn_path *cp = &conn->c_path[i];\r\nif (rds_conn_path_transition(cp, RDS_CONN_DOWN,\r\nRDS_CONN_CONNECTING) ||\r\nrds_conn_path_transition(cp, RDS_CONN_ERROR,\r\nRDS_CONN_CONNECTING)) {\r\nreturn cp->cp_transport_data;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid rds_tcp_set_linger(struct socket *sock)\r\n{\r\nstruct linger no_linger = {\r\n.l_onoff = 1,\r\n.l_linger = 0,\r\n};\r\nkernel_setsockopt(sock, SOL_SOCKET, SO_LINGER,\r\n(char *)&no_linger, sizeof(no_linger));\r\n}\r\nint rds_tcp_accept_one(struct socket *sock)\r\n{\r\nstruct socket *new_sock = NULL;\r\nstruct rds_connection *conn;\r\nint ret;\r\nstruct inet_sock *inet;\r\nstruct rds_tcp_connection *rs_tcp = NULL;\r\nint conn_state;\r\nstruct rds_conn_path *cp;\r\nif (!sock)\r\nreturn -ENETUNREACH;\r\nret = sock_create_lite(sock->sk->sk_family,\r\nsock->sk->sk_type, sock->sk->sk_protocol,\r\n&new_sock);\r\nif (ret)\r\ngoto out;\r\nnew_sock->type = sock->type;\r\nnew_sock->ops = sock->ops;\r\nret = sock->ops->accept(sock, new_sock, O_NONBLOCK, true);\r\nif (ret < 0)\r\ngoto out;\r\nret = rds_tcp_keepalive(new_sock);\r\nif (ret < 0)\r\ngoto out;\r\nrds_tcp_tune(new_sock);\r\ninet = inet_sk(new_sock->sk);\r\nrdsdebug("accepted tcp %pI4:%u -> %pI4:%u\n",\r\n&inet->inet_saddr, ntohs(inet->inet_sport),\r\n&inet->inet_daddr, ntohs(inet->inet_dport));\r\nconn = rds_conn_create(sock_net(sock->sk),\r\ninet->inet_saddr, inet->inet_daddr,\r\n&rds_tcp_transport, GFP_KERNEL);\r\nif (IS_ERR(conn)) {\r\nret = PTR_ERR(conn);\r\ngoto out;\r\n}\r\nrs_tcp = rds_tcp_accept_one_path(conn);\r\nif (!rs_tcp)\r\ngoto rst_nsk;\r\nmutex_lock(&rs_tcp->t_conn_path_lock);\r\ncp = rs_tcp->t_cpath;\r\nconn_state = rds_conn_path_state(cp);\r\nWARN_ON(conn_state == RDS_CONN_UP);\r\nif (conn_state != RDS_CONN_CONNECTING && conn_state != RDS_CONN_ERROR)\r\ngoto rst_nsk;\r\nif (rs_tcp->t_sock) {\r\nrds_tcp_reset_callbacks(new_sock, cp);\r\nrds_connect_path_complete(cp, RDS_CONN_RESETTING);\r\n} else {\r\nrds_tcp_set_callbacks(new_sock, cp);\r\nrds_connect_path_complete(cp, RDS_CONN_CONNECTING);\r\n}\r\nnew_sock = NULL;\r\nret = 0;\r\nif (conn->c_npaths == 0)\r\nrds_send_ping(cp->cp_conn, cp->cp_index);\r\ngoto out;\r\nrst_nsk:\r\nrds_tcp_set_linger(new_sock);\r\nkernel_sock_shutdown(new_sock, SHUT_RDWR);\r\nret = 0;\r\nout:\r\nif (rs_tcp)\r\nmutex_unlock(&rs_tcp->t_conn_path_lock);\r\nif (new_sock)\r\nsock_release(new_sock);\r\nreturn ret;\r\n}\r\nvoid rds_tcp_listen_data_ready(struct sock *sk)\r\n{\r\nvoid (*ready)(struct sock *sk);\r\nrdsdebug("listen data ready sk %p\n", sk);\r\nread_lock_bh(&sk->sk_callback_lock);\r\nready = sk->sk_user_data;\r\nif (!ready) {\r\nready = sk->sk_data_ready;\r\ngoto out;\r\n}\r\nif (sk->sk_state == TCP_LISTEN)\r\nrds_tcp_accept_work(sk);\r\nelse\r\nready = rds_tcp_listen_sock_def_readable(sock_net(sk));\r\nout:\r\nread_unlock_bh(&sk->sk_callback_lock);\r\nif (ready)\r\nready(sk);\r\n}\r\nstruct socket *rds_tcp_listen_init(struct net *net)\r\n{\r\nstruct sockaddr_in sin;\r\nstruct socket *sock = NULL;\r\nint ret;\r\nret = sock_create_kern(net, PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);\r\nif (ret < 0)\r\ngoto out;\r\nsock->sk->sk_reuse = SK_CAN_REUSE;\r\nrds_tcp_nonagle(sock);\r\nwrite_lock_bh(&sock->sk->sk_callback_lock);\r\nsock->sk->sk_user_data = sock->sk->sk_data_ready;\r\nsock->sk->sk_data_ready = rds_tcp_listen_data_ready;\r\nwrite_unlock_bh(&sock->sk->sk_callback_lock);\r\nsin.sin_family = PF_INET;\r\nsin.sin_addr.s_addr = (__force u32)htonl(INADDR_ANY);\r\nsin.sin_port = (__force u16)htons(RDS_TCP_PORT);\r\nret = sock->ops->bind(sock, (struct sockaddr *)&sin, sizeof(sin));\r\nif (ret < 0)\r\ngoto out;\r\nret = sock->ops->listen(sock, 64);\r\nif (ret < 0)\r\ngoto out;\r\nreturn sock;\r\nout:\r\nif (sock)\r\nsock_release(sock);\r\nreturn NULL;\r\n}\r\nvoid rds_tcp_listen_stop(struct socket *sock, struct work_struct *acceptor)\r\n{\r\nstruct sock *sk;\r\nif (!sock)\r\nreturn;\r\nsk = sock->sk;\r\nlock_sock(sk);\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nif (sk->sk_user_data) {\r\nsk->sk_data_ready = sk->sk_user_data;\r\nsk->sk_user_data = NULL;\r\n}\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\nrelease_sock(sk);\r\nflush_workqueue(rds_wq);\r\nflush_work(acceptor);\r\nsock_release(sock);\r\n}
