static void rx(struct net_device *dev, int bufnum,\r\nstruct archdr *pkthdr, int length)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nstruct archdr *pkt = pkthdr;\r\nchar *pktbuf, *pkthdrbuf;\r\nint ofs;\r\narc_printk(D_DURING, dev, "it's a raw(cap) packet (length=%d)\n",\r\nlength);\r\nif (length >= MinTU)\r\nofs = 512 - length;\r\nelse\r\nofs = 256 - length;\r\nskb = alloc_skb(length + ARC_HDR_SIZE + sizeof(int), GFP_ATOMIC);\r\nif (!skb) {\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb_put(skb, length + ARC_HDR_SIZE + sizeof(int));\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\npkt = (struct archdr *)skb_mac_header(skb);\r\nskb_pull(skb, ARC_HDR_SIZE);\r\npktbuf = (char *)pkt;\r\npkthdrbuf = (char *)pkthdr;\r\nmemcpy(pktbuf, pkthdrbuf, ARC_HDR_SIZE + sizeof(pkt->soft.cap.proto));\r\nmemcpy(pktbuf + ARC_HDR_SIZE + sizeof(pkt->soft.cap.proto) + sizeof(int),\r\npkthdrbuf + ARC_HDR_SIZE + sizeof(pkt->soft.cap.proto),\r\nsizeof(struct archdr) - ARC_HDR_SIZE - sizeof(pkt->soft.cap.proto));\r\nif (length > sizeof(pkt->soft))\r\nlp->hw.copy_from_card(dev, bufnum, ofs + sizeof(pkt->soft),\r\npkt->soft.raw + sizeof(pkt->soft)\r\n+ sizeof(int),\r\nlength - sizeof(pkt->soft));\r\nif (BUGLVL(D_SKB))\r\narcnet_dump_skb(dev, skb, "rx");\r\nskb->protocol = cpu_to_be16(ETH_P_ARCNET);\r\nnetif_rx(skb);\r\n}\r\nstatic int build_header(struct sk_buff *skb,\r\nstruct net_device *dev,\r\nunsigned short type,\r\nuint8_t daddr)\r\n{\r\nint hdr_size = ARC_HDR_SIZE;\r\nstruct archdr *pkt = skb_push(skb, hdr_size);\r\narc_printk(D_PROTO, dev, "Preparing header for cap packet %x.\n",\r\n*((int *)&pkt->soft.cap.cookie[0]));\r\npkt->hard.source = *dev->dev_addr;\r\nif (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {\r\npkt->hard.dest = 0;\r\nreturn hdr_size;\r\n}\r\npkt->hard.dest = daddr;\r\nreturn hdr_size;\r\n}\r\nstatic int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,\r\nint bufnum)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nstruct arc_hardware *hard = &pkt->hard;\r\nint ofs;\r\nlength -= ARC_HDR_SIZE;\r\nlength -= sizeof(int);\r\narc_printk(D_DURING, dev, "prepare_tx: txbufs=%d/%d/%d\n",\r\nlp->next_tx, lp->cur_tx, bufnum);\r\narc_printk(D_PROTO, dev, "Sending for cap packet %x.\n",\r\n*((int *)&pkt->soft.cap.cookie[0]));\r\nif (length > XMTU) {\r\narc_printk(D_NORMAL, dev, "Bug! prepare_tx with size %d (> %d)\n",\r\nlength, XMTU);\r\nlength = XMTU;\r\n}\r\nif (length > MinTU) {\r\nhard->offset[0] = 0;\r\nhard->offset[1] = ofs = 512 - length;\r\n} else if (length > MTU) {\r\nhard->offset[0] = 0;\r\nhard->offset[1] = ofs = 512 - length - 3;\r\n} else {\r\nhard->offset[0] = ofs = 256 - length;\r\n}\r\narc_printk(D_DURING, dev, "prepare_tx: length=%d ofs=%d\n",\r\nlength, ofs);\r\nlp->hw.copy_to_card(dev, bufnum, 0, hard, ARC_HDR_SIZE);\r\nlp->hw.copy_to_card(dev, bufnum, ofs, &pkt->soft.cap.proto,\r\nsizeof(pkt->soft.cap.proto));\r\nlp->hw.copy_to_card(dev, bufnum, ofs + 1,\r\n((unsigned char *)&pkt->soft.cap.mes), length - 1);\r\nlp->lastload_dest = hard->dest;\r\nreturn 1;\r\n}\r\nstatic int ack_tx(struct net_device *dev, int acked)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nstruct sk_buff *ackskb;\r\nstruct archdr *ackpkt;\r\nint length = sizeof(struct arc_cap);\r\narc_printk(D_DURING, dev, "capmode: ack_tx: protocol: %x: result: %d\n",\r\nlp->outgoing.skb->protocol, acked);\r\nif (BUGLVL(D_SKB))\r\narcnet_dump_skb(dev, lp->outgoing.skb, "ack_tx");\r\nackskb = alloc_skb(length + ARC_HDR_SIZE, GFP_ATOMIC);\r\nif (!ackskb)\r\ngoto free_outskb;\r\nskb_put(ackskb, length + ARC_HDR_SIZE);\r\nackskb->dev = dev;\r\nskb_reset_mac_header(ackskb);\r\nackpkt = (struct archdr *)skb_mac_header(ackskb);\r\nskb_copy_from_linear_data(lp->outgoing.skb, ackpkt,\r\nARC_HDR_SIZE + sizeof(struct arc_cap));\r\nackpkt->soft.cap.proto = 0;\r\nackpkt->soft.cap.mes.ack = acked;\r\narc_printk(D_PROTO, dev, "Acknowledge for cap packet %x.\n",\r\n*((int *)&ackpkt->soft.cap.cookie[0]));\r\nackskb->protocol = cpu_to_be16(ETH_P_ARCNET);\r\nif (BUGLVL(D_SKB))\r\narcnet_dump_skb(dev, ackskb, "ack_tx_recv");\r\nnetif_rx(ackskb);\r\nfree_outskb:\r\ndev_kfree_skb_irq(lp->outgoing.skb);\r\nlp->outgoing.proto = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init capmode_module_init(void)\r\n{\r\nint count;\r\npr_info("cap mode (`c') encapsulation support loaded\n");\r\nfor (count = 1; count <= 8; count++)\r\nif (arc_proto_map[count] == arc_proto_default)\r\narc_proto_map[count] = &capmode_proto;\r\nif (arc_bcast_proto == arc_proto_default)\r\narc_bcast_proto = &capmode_proto;\r\narc_proto_default = &capmode_proto;\r\narc_raw_proto = &capmode_proto;\r\nreturn 0;\r\n}\r\nstatic void __exit capmode_module_exit(void)\r\n{\r\narcnet_unregister_proto(&capmode_proto);\r\n}
