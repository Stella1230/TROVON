static void\r\nmove_subword (\r\nhive_uedge *target,\r\nunsigned target_bit,\r\nhive_uedge src,\r\nunsigned src_start,\r\nunsigned src_end)\r\n{\r\nunsigned int start_elem = target_bit / uedge_bits;\r\nunsigned int start_bit = target_bit % uedge_bits;\r\nunsigned subword_width = src_end - src_start;\r\nhive_uedge src_subword = SUBWORD(src, src_start, src_end);\r\nif (subword_width + start_bit > uedge_bits) {\r\nhive_uedge old_val1;\r\nhive_uedge old_val0 = INV_SUBWORD(target[start_elem], start_bit, uedge_bits);\r\ntarget[start_elem] = old_val0 | (src_subword << start_bit);\r\nold_val1 = INV_SUBWORD(target[start_elem+1], 0, subword_width + start_bit - uedge_bits);\r\ntarget[start_elem+1] = old_val1 | (src_subword >> ( uedge_bits - start_bit));\r\n} else {\r\nhive_uedge old_val = INV_SUBWORD(target[start_elem], start_bit, start_bit + subword_width);\r\ntarget[start_elem] = old_val | (src_subword << start_bit);\r\n}\r\n}\r\nstatic void\r\nhive_sim_wide_unpack(\r\nhive_wide vector,\r\nhive_wide elem,\r\nhive_uint elem_bits,\r\nhive_uint index)\r\n{\r\nunsigned int start_elem = (elem_bits * index) / uedge_bits;\r\nunsigned int start_bit = (elem_bits * index) % uedge_bits;\r\nunsigned int end_elem = (elem_bits * (index + 1) - 1) / uedge_bits;\r\nunsigned int end_bit = ((elem_bits * (index + 1) - 1) % uedge_bits) + 1;\r\nif (elem_bits == uedge_bits) {\r\nelem[0] = vector[index];\r\n} else if (start_elem == end_elem) {\r\nmove_subword(elem, 0, vector[start_elem], start_bit, end_bit);\r\n} else {\r\nunsigned int bits_written = 0;\r\nunsigned int i;\r\nmove_upper_bits(elem, bits_written, vector[start_elem], start_bit);\r\nbits_written += (64 - start_bit);\r\nfor(i = start_elem+1; i < end_elem; i++) {\r\nmove_word(elem, bits_written, vector[i]);\r\nbits_written += uedge_bits;\r\n}\r\nmove_lower_bits(elem, bits_written , vector[end_elem], end_bit);\r\n}\r\n}\r\nstatic void\r\nhive_sim_wide_pack(\r\nhive_wide vector,\r\nhive_wide elem,\r\nhive_uint elem_bits,\r\nhive_uint index)\r\n{\r\nunsigned int start_elem = (elem_bits * index) / uedge_bits;\r\nif (elem_bits == uedge_bits) {\r\nvector[start_elem] = elem[0];\r\n} else if (elem_bits > uedge_bits) {\r\nunsigned bits_to_write = elem_bits;\r\nunsigned start_bit = elem_bits * index;\r\nunsigned i = 0;\r\nfor(; bits_to_write > uedge_bits; bits_to_write -= uedge_bits, i++, start_bit += uedge_bits) {\r\nmove_word(vector, start_bit, elem[i]);\r\n}\r\nmove_lower_bits(vector, start_bit, elem[i], bits_to_write);\r\n} else {\r\nmove_lower_bits(vector, elem_bits * index, elem[0], elem_bits);\r\n}\r\n}\r\nstatic void load_vector (\r\nconst isp_ID_t ID,\r\nt_vmem_elem *to,\r\nconst t_vmem_elem *from)\r\n{\r\nunsigned i;\r\nhive_uedge *data;\r\nunsigned size = sizeof(short)*ISP_NWAY;\r\nVMEM_ARRAY(v, 2*ISP_NWAY);\r\nassert(ISP_BAMEM_BASE[ID] != (hrt_address)-1);\r\n#if !defined(HRT_MEMORY_ACCESS)\r\nia_css_device_load(ISP_BAMEM_BASE[ID] + (unsigned long)from, &v[0][0], size);\r\n#else\r\nhrt_master_port_load(ISP_BAMEM_BASE[ID] + (unsigned long)from, &v[0][0], size);\r\n#endif\r\ndata = (hive_uedge *)v;\r\nfor (i = 0; i < ISP_NWAY; i++) {\r\nhive_uedge elem = 0;\r\nhive_sim_wide_unpack(data, &elem, ISP_VEC_ELEMBITS, i);\r\nto[i] = elem;\r\n}\r\nhrt_sleep();\r\n}\r\nstatic void store_vector (\r\nconst isp_ID_t ID,\r\nt_vmem_elem *to,\r\nconst t_vmem_elem *from)\r\n{\r\nunsigned i;\r\nunsigned size = sizeof(short)*ISP_NWAY;\r\nVMEM_ARRAY(v, 2*ISP_NWAY);\r\nhive_uedge *data = (hive_uedge *)v;\r\nfor (i = 0; i < ISP_NWAY; i++) {\r\nhive_sim_wide_pack(data, (hive_wide)&from[i], ISP_VEC_ELEMBITS, i);\r\n}\r\nassert(ISP_BAMEM_BASE[ID] != (hrt_address)-1);\r\n#if !defined(HRT_MEMORY_ACCESS)\r\nia_css_device_store(ISP_BAMEM_BASE[ID] + (unsigned long)to, &v, size);\r\n#else\r\nhrt_master_port_store(ISP_BAMEM_BASE[ID] + (unsigned long)to, &v, size);\r\n#endif\r\nhrt_sleep();\r\n}\r\nvoid isp_vmem_load(\r\nconst isp_ID_t ID,\r\nconst t_vmem_elem *from,\r\nt_vmem_elem *to,\r\nunsigned elems)\r\n{\r\nunsigned c;\r\nconst t_vmem_elem *vp = from;\r\nassert(ID < N_ISP_ID);\r\nassert((unsigned long)from % ISP_VEC_ALIGN == 0);\r\nassert(elems % ISP_NWAY == 0);\r\nfor (c = 0; c < elems; c += ISP_NWAY) {\r\nload_vector(ID, &to[c], vp);\r\nvp = (t_vmem_elem *)((char*)vp + ISP_VEC_ALIGN);\r\n}\r\n}\r\nvoid isp_vmem_store(\r\nconst isp_ID_t ID,\r\nt_vmem_elem *to,\r\nconst t_vmem_elem *from,\r\nunsigned elems)\r\n{\r\nunsigned c;\r\nt_vmem_elem *vp = to;\r\nassert(ID < N_ISP_ID);\r\nassert((unsigned long)to % ISP_VEC_ALIGN == 0);\r\nassert(elems % ISP_NWAY == 0);\r\nfor (c = 0; c < elems; c += ISP_NWAY) {\r\nstore_vector (ID, vp, &from[c]);\r\nvp = (t_vmem_elem *)((char*)vp + ISP_VEC_ALIGN);\r\n}\r\n}\r\nvoid isp_vmem_2d_load (\r\nconst isp_ID_t ID,\r\nconst t_vmem_elem *from,\r\nt_vmem_elem *to,\r\nunsigned height,\r\nunsigned width,\r\nunsigned stride_to,\r\nunsigned stride_from )\r\n{\r\nunsigned h;\r\nassert(ID < N_ISP_ID);\r\nassert((unsigned long)from % ISP_VEC_ALIGN == 0);\r\nassert(width % ISP_NWAY == 0);\r\nassert(stride_from % ISP_NWAY == 0);\r\nfor (h = 0; h < height; h++) {\r\nunsigned c;\r\nconst t_vmem_elem *vp = from;\r\nfor (c = 0; c < width; c += ISP_NWAY) {\r\nload_vector(ID, &to[stride_to*h + c], vp);\r\nvp = (t_vmem_elem *)((char*)vp + ISP_VEC_ALIGN);\r\n}\r\nfrom = (const t_vmem_elem *)((const char *)from + stride_from/ISP_NWAY*ISP_VEC_ALIGN);\r\n}\r\n}\r\nvoid isp_vmem_2d_store (\r\nconst isp_ID_t ID,\r\nt_vmem_elem *to,\r\nconst t_vmem_elem *from,\r\nunsigned height,\r\nunsigned width,\r\nunsigned stride_to,\r\nunsigned stride_from )\r\n{\r\nunsigned h;\r\nassert(ID < N_ISP_ID);\r\nassert((unsigned long)to % ISP_VEC_ALIGN == 0);\r\nassert(width % ISP_NWAY == 0);\r\nassert(stride_to % ISP_NWAY == 0);\r\nfor (h = 0; h < height; h++) {\r\nunsigned c;\r\nt_vmem_elem *vp = to;\r\nfor (c = 0; c < width; c += ISP_NWAY) {\r\nstore_vector (ID, vp, &from[stride_from*h + c]);\r\nvp = (t_vmem_elem *)((char*)vp + ISP_VEC_ALIGN);\r\n}\r\nto = (t_vmem_elem *)((char *)to + stride_to/ISP_NWAY*ISP_VEC_ALIGN);\r\n}\r\n}
