static inline int is_imx25_esdhc(struct pltfm_imx_data *data)\r\n{\r\nreturn data->socdata == &esdhc_imx25_data;\r\n}\r\nstatic inline int is_imx53_esdhc(struct pltfm_imx_data *data)\r\n{\r\nreturn data->socdata == &esdhc_imx53_data;\r\n}\r\nstatic inline int is_imx6q_usdhc(struct pltfm_imx_data *data)\r\n{\r\nreturn data->socdata == &usdhc_imx6q_data;\r\n}\r\nstatic inline int esdhc_is_usdhc(struct pltfm_imx_data *data)\r\n{\r\nreturn !!(data->socdata->flags & ESDHC_FLAG_USDHC);\r\n}\r\nstatic inline void esdhc_clrset_le(struct sdhci_host *host, u32 mask, u32 val, int reg)\r\n{\r\nvoid __iomem *base = host->ioaddr + (reg & ~0x3);\r\nu32 shift = (reg & 0x3) * 8;\r\nwritel(((readl(base) & ~(mask << shift)) | (val << shift)), base);\r\n}\r\nstatic u32 esdhc_readl_le(struct sdhci_host *host, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nu32 val = readl(host->ioaddr + reg);\r\nif (unlikely(reg == SDHCI_PRESENT_STATE)) {\r\nu32 fsl_prss = val;\r\nval = fsl_prss & 0x000FFFFF;\r\nval |= (fsl_prss & 0x0F000000) >> 4;\r\nval |= (fsl_prss & 0x00800000) << 1;\r\n}\r\nif (unlikely(reg == SDHCI_CAPABILITIES)) {\r\nif (imx_data->socdata->flags & ESDHC_FLAG_HAVE_CAP1)\r\nval &= 0xffff0000;\r\nif (val & SDHCI_CAN_DO_ADMA1) {\r\nval &= ~SDHCI_CAN_DO_ADMA1;\r\nval |= SDHCI_CAN_DO_ADMA2;\r\n}\r\n}\r\nif (unlikely(reg == SDHCI_CAPABILITIES_1)) {\r\nif (esdhc_is_usdhc(imx_data)) {\r\nif (imx_data->socdata->flags & ESDHC_FLAG_HAVE_CAP1)\r\nval = readl(host->ioaddr + SDHCI_CAPABILITIES) & 0xFFFF;\r\nelse\r\nval = SDHCI_SUPPORT_DDR50 | SDHCI_SUPPORT_SDR104\r\n| SDHCI_SUPPORT_SDR50\r\n| SDHCI_USE_SDR50_TUNING\r\n| (SDHCI_TUNING_MODE_3 << SDHCI_RETUNING_MODE_SHIFT);\r\nif (imx_data->socdata->flags & ESDHC_FLAG_HS400)\r\nval |= SDHCI_SUPPORT_HS400;\r\n}\r\n}\r\nif (unlikely(reg == SDHCI_MAX_CURRENT) && esdhc_is_usdhc(imx_data)) {\r\nval = 0;\r\nval |= 0xFF << SDHCI_MAX_CURRENT_330_SHIFT;\r\nval |= 0xFF << SDHCI_MAX_CURRENT_300_SHIFT;\r\nval |= 0xFF << SDHCI_MAX_CURRENT_180_SHIFT;\r\n}\r\nif (unlikely(reg == SDHCI_INT_STATUS)) {\r\nif (val & ESDHC_INT_VENDOR_SPEC_DMA_ERR) {\r\nval &= ~ESDHC_INT_VENDOR_SPEC_DMA_ERR;\r\nval |= SDHCI_INT_ADMA_ERROR;\r\n}\r\nif ((imx_data->multiblock_status == WAIT_FOR_INT) &&\r\n((val & SDHCI_INT_RESPONSE) == SDHCI_INT_RESPONSE)) {\r\nval &= ~SDHCI_INT_RESPONSE;\r\nwritel(SDHCI_INT_RESPONSE, host->ioaddr +\r\nSDHCI_INT_STATUS);\r\nimx_data->multiblock_status = NO_CMD_PENDING;\r\n}\r\n}\r\nreturn val;\r\n}\r\nstatic void esdhc_writel_le(struct sdhci_host *host, u32 val, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nu32 data;\r\nif (unlikely(reg == SDHCI_INT_ENABLE || reg == SDHCI_SIGNAL_ENABLE ||\r\nreg == SDHCI_INT_STATUS)) {\r\nif ((val & SDHCI_INT_CARD_INT) && !esdhc_is_usdhc(imx_data)) {\r\ndata = readl(host->ioaddr + SDHCI_HOST_CONTROL);\r\ndata &= ~ESDHC_CTRL_D3CD;\r\nwritel(data, host->ioaddr + SDHCI_HOST_CONTROL);\r\ndata |= ESDHC_CTRL_D3CD;\r\nwritel(data, host->ioaddr + SDHCI_HOST_CONTROL);\r\n}\r\nif (val & SDHCI_INT_ADMA_ERROR) {\r\nval &= ~SDHCI_INT_ADMA_ERROR;\r\nval |= ESDHC_INT_VENDOR_SPEC_DMA_ERR;\r\n}\r\n}\r\nif (unlikely((imx_data->socdata->flags & ESDHC_FLAG_MULTIBLK_NO_INT)\r\n&& (reg == SDHCI_INT_STATUS)\r\n&& (val & SDHCI_INT_DATA_END))) {\r\nu32 v;\r\nv = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\r\nv &= ~ESDHC_VENDOR_SPEC_SDIO_QUIRK;\r\nwritel(v, host->ioaddr + ESDHC_VENDOR_SPEC);\r\nif (imx_data->multiblock_status == MULTIBLK_IN_PROCESS)\r\n{\r\ndata = MMC_STOP_TRANSMISSION << 24 |\r\nSDHCI_CMD_ABORTCMD << 16;\r\nwritel(data, host->ioaddr + SDHCI_TRANSFER_MODE);\r\nimx_data->multiblock_status = WAIT_FOR_INT;\r\n}\r\n}\r\nwritel(val, host->ioaddr + reg);\r\n}\r\nstatic u16 esdhc_readw_le(struct sdhci_host *host, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nu16 ret = 0;\r\nu32 val;\r\nif (unlikely(reg == SDHCI_HOST_VERSION)) {\r\nreg ^= 2;\r\nif (esdhc_is_usdhc(imx_data)) {\r\nreturn SDHCI_SPEC_300;\r\n}\r\n}\r\nif (unlikely(reg == SDHCI_HOST_CONTROL2)) {\r\nval = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\r\nif (val & ESDHC_VENDOR_SPEC_VSELECT)\r\nret |= SDHCI_CTRL_VDD_180;\r\nif (esdhc_is_usdhc(imx_data)) {\r\nif (imx_data->socdata->flags & ESDHC_FLAG_MAN_TUNING)\r\nval = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nelse if (imx_data->socdata->flags & ESDHC_FLAG_STD_TUNING)\r\nval = readl(host->ioaddr + SDHCI_ACMD12_ERR);\r\n}\r\nif (val & ESDHC_MIX_CTRL_EXE_TUNE)\r\nret |= SDHCI_CTRL_EXEC_TUNING;\r\nif (val & ESDHC_MIX_CTRL_SMPCLK_SEL)\r\nret |= SDHCI_CTRL_TUNED_CLK;\r\nret &= ~SDHCI_CTRL_PRESET_VAL_ENABLE;\r\nreturn ret;\r\n}\r\nif (unlikely(reg == SDHCI_TRANSFER_MODE)) {\r\nif (esdhc_is_usdhc(imx_data)) {\r\nu32 m = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nret = m & ESDHC_MIX_CTRL_SDHCI_MASK;\r\nif (m & ESDHC_MIX_CTRL_AC23EN) {\r\nret &= ~ESDHC_MIX_CTRL_AC23EN;\r\nret |= SDHCI_TRNS_AUTO_CMD23;\r\n}\r\n} else {\r\nret = readw(host->ioaddr + SDHCI_TRANSFER_MODE);\r\n}\r\nreturn ret;\r\n}\r\nreturn readw(host->ioaddr + reg);\r\n}\r\nstatic void esdhc_writew_le(struct sdhci_host *host, u16 val, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nu32 new_val = 0;\r\nswitch (reg) {\r\ncase SDHCI_CLOCK_CONTROL:\r\nnew_val = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\r\nif (val & SDHCI_CLOCK_CARD_EN)\r\nnew_val |= ESDHC_VENDOR_SPEC_FRC_SDCLK_ON;\r\nelse\r\nnew_val &= ~ESDHC_VENDOR_SPEC_FRC_SDCLK_ON;\r\nwritel(new_val, host->ioaddr + ESDHC_VENDOR_SPEC);\r\nreturn;\r\ncase SDHCI_HOST_CONTROL2:\r\nnew_val = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\r\nif (val & SDHCI_CTRL_VDD_180)\r\nnew_val |= ESDHC_VENDOR_SPEC_VSELECT;\r\nelse\r\nnew_val &= ~ESDHC_VENDOR_SPEC_VSELECT;\r\nwritel(new_val, host->ioaddr + ESDHC_VENDOR_SPEC);\r\nif (imx_data->socdata->flags & ESDHC_FLAG_MAN_TUNING) {\r\nnew_val = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nif (val & SDHCI_CTRL_TUNED_CLK) {\r\nnew_val |= ESDHC_MIX_CTRL_SMPCLK_SEL;\r\nnew_val |= ESDHC_MIX_CTRL_AUTO_TUNE_EN;\r\n} else {\r\nnew_val &= ~ESDHC_MIX_CTRL_SMPCLK_SEL;\r\nnew_val &= ~ESDHC_MIX_CTRL_AUTO_TUNE_EN;\r\n}\r\nwritel(new_val , host->ioaddr + ESDHC_MIX_CTRL);\r\n} else if (imx_data->socdata->flags & ESDHC_FLAG_STD_TUNING) {\r\nu32 v = readl(host->ioaddr + SDHCI_ACMD12_ERR);\r\nu32 m = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nif (val & SDHCI_CTRL_TUNED_CLK) {\r\nv |= ESDHC_MIX_CTRL_SMPCLK_SEL;\r\n} else {\r\nv &= ~ESDHC_MIX_CTRL_SMPCLK_SEL;\r\nm &= ~ESDHC_MIX_CTRL_FBCLK_SEL;\r\nm &= ~ESDHC_MIX_CTRL_AUTO_TUNE_EN;\r\n}\r\nif (val & SDHCI_CTRL_EXEC_TUNING) {\r\nv |= ESDHC_MIX_CTRL_EXE_TUNE;\r\nm |= ESDHC_MIX_CTRL_FBCLK_SEL;\r\nm |= ESDHC_MIX_CTRL_AUTO_TUNE_EN;\r\n} else {\r\nv &= ~ESDHC_MIX_CTRL_EXE_TUNE;\r\n}\r\nwritel(v, host->ioaddr + SDHCI_ACMD12_ERR);\r\nwritel(m, host->ioaddr + ESDHC_MIX_CTRL);\r\n}\r\nreturn;\r\ncase SDHCI_TRANSFER_MODE:\r\nif ((imx_data->socdata->flags & ESDHC_FLAG_MULTIBLK_NO_INT)\r\n&& (host->cmd->opcode == SD_IO_RW_EXTENDED)\r\n&& (host->cmd->data->blocks > 1)\r\n&& (host->cmd->data->flags & MMC_DATA_READ)) {\r\nu32 v;\r\nv = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\r\nv |= ESDHC_VENDOR_SPEC_SDIO_QUIRK;\r\nwritel(v, host->ioaddr + ESDHC_VENDOR_SPEC);\r\n}\r\nif (esdhc_is_usdhc(imx_data)) {\r\nu32 m = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nif (val & SDHCI_TRNS_AUTO_CMD23) {\r\nval &= ~SDHCI_TRNS_AUTO_CMD23;\r\nval |= ESDHC_MIX_CTRL_AC23EN;\r\n}\r\nm = val | (m & ~ESDHC_MIX_CTRL_SDHCI_MASK);\r\nwritel(m, host->ioaddr + ESDHC_MIX_CTRL);\r\n} else {\r\nimx_data->scratchpad = val;\r\n}\r\nreturn;\r\ncase SDHCI_COMMAND:\r\nif (host->cmd->opcode == MMC_STOP_TRANSMISSION)\r\nval |= SDHCI_CMD_ABORTCMD;\r\nif ((host->cmd->opcode == MMC_SET_BLOCK_COUNT) &&\r\n(imx_data->socdata->flags & ESDHC_FLAG_MULTIBLK_NO_INT))\r\nimx_data->multiblock_status = MULTIBLK_IN_PROCESS;\r\nif (esdhc_is_usdhc(imx_data))\r\nwritel(val << 16,\r\nhost->ioaddr + SDHCI_TRANSFER_MODE);\r\nelse\r\nwritel(val << 16 | imx_data->scratchpad,\r\nhost->ioaddr + SDHCI_TRANSFER_MODE);\r\nreturn;\r\ncase SDHCI_BLOCK_SIZE:\r\nval &= ~SDHCI_MAKE_BLKSZ(0x7, 0);\r\nbreak;\r\n}\r\nesdhc_clrset_le(host, 0xffff, val, reg);\r\n}\r\nstatic u8 esdhc_readb_le(struct sdhci_host *host, int reg)\r\n{\r\nu8 ret;\r\nu32 val;\r\nswitch (reg) {\r\ncase SDHCI_HOST_CONTROL:\r\nval = readl(host->ioaddr + reg);\r\nret = val & SDHCI_CTRL_LED;\r\nret |= (val >> 5) & SDHCI_CTRL_DMA_MASK;\r\nret |= (val & ESDHC_CTRL_4BITBUS);\r\nret |= (val & ESDHC_CTRL_8BITBUS) << 3;\r\nreturn ret;\r\n}\r\nreturn readb(host->ioaddr + reg);\r\n}\r\nstatic void esdhc_writeb_le(struct sdhci_host *host, u8 val, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nu32 new_val = 0;\r\nu32 mask;\r\nswitch (reg) {\r\ncase SDHCI_POWER_CONTROL:\r\nreturn;\r\ncase SDHCI_HOST_CONTROL:\r\nnew_val = val & SDHCI_CTRL_LED;\r\nnew_val |= ESDHC_HOST_CONTROL_LE;\r\nif (!is_imx25_esdhc(imx_data)) {\r\nnew_val |= (val & SDHCI_CTRL_DMA_MASK) << 5;\r\n}\r\nmask = 0xffff & ~(ESDHC_CTRL_BUSWIDTH_MASK | ESDHC_CTRL_D3CD);\r\nesdhc_clrset_le(host, mask, new_val, reg);\r\nreturn;\r\ncase SDHCI_SOFTWARE_RESET:\r\nif (val & SDHCI_RESET_DATA)\r\nnew_val = readl(host->ioaddr + SDHCI_HOST_CONTROL);\r\nbreak;\r\n}\r\nesdhc_clrset_le(host, 0xff, val, reg);\r\nif (reg == SDHCI_SOFTWARE_RESET) {\r\nif (val & SDHCI_RESET_ALL) {\r\nesdhc_clrset_le(host, 0x7, 0x7, ESDHC_SYSTEM_CONTROL);\r\nif (esdhc_is_usdhc(imx_data)) {\r\nnew_val = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nwritel(new_val & ESDHC_MIX_CTRL_TUNING_MASK,\r\nhost->ioaddr + ESDHC_MIX_CTRL);\r\nimx_data->is_ddr = 0;\r\n}\r\n} else if (val & SDHCI_RESET_DATA) {\r\nesdhc_clrset_le(host, 0xff, new_val,\r\nSDHCI_HOST_CONTROL);\r\n}\r\n}\r\n}\r\nstatic unsigned int esdhc_pltfm_get_max_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nreturn pltfm_host->clock;\r\n}\r\nstatic unsigned int esdhc_pltfm_get_min_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nreturn pltfm_host->clock / 256 / 16;\r\n}\r\nstatic inline void esdhc_pltfm_set_clock(struct sdhci_host *host,\r\nunsigned int clock)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nunsigned int host_clock = pltfm_host->clock;\r\nint ddr_pre_div = imx_data->is_ddr ? 2 : 1;\r\nint pre_div = 1;\r\nint div = 1;\r\nu32 temp, val;\r\nif (clock == 0) {\r\nhost->mmc->actual_clock = 0;\r\nif (esdhc_is_usdhc(imx_data)) {\r\nval = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\r\nwritel(val & ~ESDHC_VENDOR_SPEC_FRC_SDCLK_ON,\r\nhost->ioaddr + ESDHC_VENDOR_SPEC);\r\n}\r\nreturn;\r\n}\r\ntemp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);\r\ntemp &= ~(ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN\r\n| ESDHC_CLOCK_MASK);\r\nsdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);\r\nwhile (host_clock / (16 * pre_div * ddr_pre_div) > clock &&\r\npre_div < 256)\r\npre_div *= 2;\r\nwhile (host_clock / (div * pre_div * ddr_pre_div) > clock && div < 16)\r\ndiv++;\r\nhost->mmc->actual_clock = host_clock / (div * pre_div * ddr_pre_div);\r\ndev_dbg(mmc_dev(host->mmc), "desired SD clock: %d, actual: %d\n",\r\nclock, host->mmc->actual_clock);\r\npre_div >>= 1;\r\ndiv--;\r\ntemp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);\r\ntemp |= (ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN\r\n| (div << ESDHC_DIVIDER_SHIFT)\r\n| (pre_div << ESDHC_PREDIV_SHIFT));\r\nsdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);\r\nif (esdhc_is_usdhc(imx_data)) {\r\nval = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\r\nwritel(val | ESDHC_VENDOR_SPEC_FRC_SDCLK_ON,\r\nhost->ioaddr + ESDHC_VENDOR_SPEC);\r\n}\r\nmdelay(1);\r\n}\r\nstatic unsigned int esdhc_pltfm_get_ro(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nstruct esdhc_platform_data *boarddata = &imx_data->boarddata;\r\nswitch (boarddata->wp_type) {\r\ncase ESDHC_WP_GPIO:\r\nreturn mmc_gpio_get_ro(host->mmc);\r\ncase ESDHC_WP_CONTROLLER:\r\nreturn !(readl(host->ioaddr + SDHCI_PRESENT_STATE) &\r\nSDHCI_WRITE_PROTECT);\r\ncase ESDHC_WP_NONE:\r\nbreak;\r\n}\r\nreturn -ENOSYS;\r\n}\r\nstatic void esdhc_pltfm_set_bus_width(struct sdhci_host *host, int width)\r\n{\r\nu32 ctrl;\r\nswitch (width) {\r\ncase MMC_BUS_WIDTH_8:\r\nctrl = ESDHC_CTRL_8BITBUS;\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\nctrl = ESDHC_CTRL_4BITBUS;\r\nbreak;\r\ndefault:\r\nctrl = 0;\r\nbreak;\r\n}\r\nesdhc_clrset_le(host, ESDHC_CTRL_BUSWIDTH_MASK, ctrl,\r\nSDHCI_HOST_CONTROL);\r\n}\r\nstatic void esdhc_prepare_tuning(struct sdhci_host *host, u32 val)\r\n{\r\nu32 reg;\r\nmdelay(1);\r\nreg = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nreg |= ESDHC_MIX_CTRL_EXE_TUNE | ESDHC_MIX_CTRL_SMPCLK_SEL |\r\nESDHC_MIX_CTRL_FBCLK_SEL;\r\nwritel(reg, host->ioaddr + ESDHC_MIX_CTRL);\r\nwritel(val << 8, host->ioaddr + ESDHC_TUNE_CTRL_STATUS);\r\ndev_dbg(mmc_dev(host->mmc),\r\n"tuning with delay 0x%x ESDHC_TUNE_CTRL_STATUS 0x%x\n",\r\nval, readl(host->ioaddr + ESDHC_TUNE_CTRL_STATUS));\r\n}\r\nstatic void esdhc_post_tuning(struct sdhci_host *host)\r\n{\r\nu32 reg;\r\nreg = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nreg &= ~ESDHC_MIX_CTRL_EXE_TUNE;\r\nreg |= ESDHC_MIX_CTRL_AUTO_TUNE_EN;\r\nwritel(reg, host->ioaddr + ESDHC_MIX_CTRL);\r\n}\r\nstatic int esdhc_executing_tuning(struct sdhci_host *host, u32 opcode)\r\n{\r\nint min, max, avg, ret;\r\nmin = ESDHC_TUNE_CTRL_MIN;\r\nwhile (min < ESDHC_TUNE_CTRL_MAX) {\r\nesdhc_prepare_tuning(host, min);\r\nif (!mmc_send_tuning(host->mmc, opcode, NULL))\r\nbreak;\r\nmin += ESDHC_TUNE_CTRL_STEP;\r\n}\r\nmax = min + ESDHC_TUNE_CTRL_STEP;\r\nwhile (max < ESDHC_TUNE_CTRL_MAX) {\r\nesdhc_prepare_tuning(host, max);\r\nif (mmc_send_tuning(host->mmc, opcode, NULL)) {\r\nmax -= ESDHC_TUNE_CTRL_STEP;\r\nbreak;\r\n}\r\nmax += ESDHC_TUNE_CTRL_STEP;\r\n}\r\navg = (min + max) / 2;\r\nesdhc_prepare_tuning(host, avg);\r\nret = mmc_send_tuning(host->mmc, opcode, NULL);\r\nesdhc_post_tuning(host);\r\ndev_dbg(mmc_dev(host->mmc), "tuning %s at 0x%x ret %d\n",\r\nret ? "failed" : "passed", avg, ret);\r\nreturn ret;\r\n}\r\nstatic int esdhc_change_pinstate(struct sdhci_host *host,\r\nunsigned int uhs)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nstruct pinctrl_state *pinctrl;\r\ndev_dbg(mmc_dev(host->mmc), "change pinctrl state for uhs %d\n", uhs);\r\nif (IS_ERR(imx_data->pinctrl) ||\r\nIS_ERR(imx_data->pins_default) ||\r\nIS_ERR(imx_data->pins_100mhz) ||\r\nIS_ERR(imx_data->pins_200mhz))\r\nreturn -EINVAL;\r\nswitch (uhs) {\r\ncase MMC_TIMING_UHS_SDR50:\r\ncase MMC_TIMING_UHS_DDR50:\r\npinctrl = imx_data->pins_100mhz;\r\nbreak;\r\ncase MMC_TIMING_UHS_SDR104:\r\ncase MMC_TIMING_MMC_HS200:\r\ncase MMC_TIMING_MMC_HS400:\r\npinctrl = imx_data->pins_200mhz;\r\nbreak;\r\ndefault:\r\npinctrl = imx_data->pins_default;\r\n}\r\nreturn pinctrl_select_state(imx_data->pinctrl, pinctrl);\r\n}\r\nstatic void esdhc_set_strobe_dll(struct sdhci_host *host)\r\n{\r\nu32 v;\r\nif (host->mmc->actual_clock > ESDHC_STROBE_DLL_CLK_FREQ) {\r\nwritel(readl(host->ioaddr + ESDHC_VENDOR_SPEC) &\r\n~ESDHC_VENDOR_SPEC_FRC_SDCLK_ON,\r\nhost->ioaddr + ESDHC_VENDOR_SPEC);\r\nwritel(ESDHC_STROBE_DLL_CTRL_RESET,\r\nhost->ioaddr + ESDHC_STROBE_DLL_CTRL);\r\nv = ESDHC_STROBE_DLL_CTRL_ENABLE |\r\n(7 << ESDHC_STROBE_DLL_CTRL_SLV_DLY_TARGET_SHIFT);\r\nwritel(v, host->ioaddr + ESDHC_STROBE_DLL_CTRL);\r\nudelay(1);\r\nv = readl(host->ioaddr + ESDHC_STROBE_DLL_STATUS);\r\nif (!(v & ESDHC_STROBE_DLL_STS_REF_LOCK))\r\ndev_warn(mmc_dev(host->mmc),\r\n"warning! HS400 strobe DLL status REF not lock!\n");\r\nif (!(v & ESDHC_STROBE_DLL_STS_SLV_LOCK))\r\ndev_warn(mmc_dev(host->mmc),\r\n"warning! HS400 strobe DLL status SLV not lock!\n");\r\n}\r\n}\r\nstatic void esdhc_reset_tuning(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nu32 ctrl;\r\nif (esdhc_is_usdhc(imx_data)) {\r\nif (imx_data->socdata->flags & ESDHC_FLAG_MAN_TUNING) {\r\nctrl = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nctrl &= ~ESDHC_MIX_CTRL_SMPCLK_SEL;\r\nctrl &= ~ESDHC_MIX_CTRL_FBCLK_SEL;\r\nwritel(ctrl, host->ioaddr + ESDHC_MIX_CTRL);\r\nwritel(0, host->ioaddr + ESDHC_TUNE_CTRL_STATUS);\r\n} else if (imx_data->socdata->flags & ESDHC_FLAG_STD_TUNING) {\r\nctrl = readl(host->ioaddr + SDHCI_ACMD12_ERR);\r\nctrl &= ~ESDHC_MIX_CTRL_SMPCLK_SEL;\r\nwritel(ctrl, host->ioaddr + SDHCI_ACMD12_ERR);\r\n}\r\n}\r\n}\r\nstatic void esdhc_set_uhs_signaling(struct sdhci_host *host, unsigned timing)\r\n{\r\nu32 m;\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nstruct esdhc_platform_data *boarddata = &imx_data->boarddata;\r\nm = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nm &= ~(ESDHC_MIX_CTRL_DDREN | ESDHC_MIX_CTRL_HS400_EN);\r\nimx_data->is_ddr = 0;\r\nswitch (timing) {\r\ncase MMC_TIMING_UHS_SDR12:\r\ncase MMC_TIMING_UHS_SDR25:\r\ncase MMC_TIMING_UHS_SDR50:\r\ncase MMC_TIMING_UHS_SDR104:\r\ncase MMC_TIMING_MMC_HS200:\r\nwritel(m, host->ioaddr + ESDHC_MIX_CTRL);\r\nbreak;\r\ncase MMC_TIMING_UHS_DDR50:\r\ncase MMC_TIMING_MMC_DDR52:\r\nm |= ESDHC_MIX_CTRL_DDREN;\r\nwritel(m, host->ioaddr + ESDHC_MIX_CTRL);\r\nimx_data->is_ddr = 1;\r\nif (boarddata->delay_line) {\r\nu32 v;\r\nv = boarddata->delay_line <<\r\nESDHC_DLL_OVERRIDE_VAL_SHIFT |\r\n(1 << ESDHC_DLL_OVERRIDE_EN_SHIFT);\r\nif (is_imx53_esdhc(imx_data))\r\nv <<= 1;\r\nwritel(v, host->ioaddr + ESDHC_DLL_CTRL);\r\n}\r\nbreak;\r\ncase MMC_TIMING_MMC_HS400:\r\nm |= ESDHC_MIX_CTRL_DDREN | ESDHC_MIX_CTRL_HS400_EN;\r\nwritel(m, host->ioaddr + ESDHC_MIX_CTRL);\r\nimx_data->is_ddr = 1;\r\nhost->ops->set_clock(host, host->clock);\r\nesdhc_set_strobe_dll(host);\r\nbreak;\r\ncase MMC_TIMING_LEGACY:\r\ndefault:\r\nesdhc_reset_tuning(host);\r\nbreak;\r\n}\r\nesdhc_change_pinstate(host, timing);\r\n}\r\nstatic void esdhc_reset(struct sdhci_host *host, u8 mask)\r\n{\r\nsdhci_reset(host, mask);\r\nsdhci_writel(host, host->ier, SDHCI_INT_ENABLE);\r\nsdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);\r\n}\r\nstatic unsigned int esdhc_get_max_timeout_count(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nreturn esdhc_is_usdhc(imx_data) ? 1 << 29 : 1 << 27;\r\n}\r\nstatic void esdhc_set_timeout(struct sdhci_host *host, struct mmc_command *cmd)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nesdhc_clrset_le(host, ESDHC_SYS_CTRL_DTOCV_MASK,\r\nesdhc_is_usdhc(imx_data) ? 0xF : 0xE,\r\nSDHCI_TIMEOUT_CONTROL);\r\n}\r\nstatic void sdhci_esdhc_imx_hwinit(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nint tmp;\r\nif (esdhc_is_usdhc(imx_data)) {\r\nwritel(ESDHC_WTMK_DEFAULT_VAL, host->ioaddr + ESDHC_WTMK_LVL);\r\nwritel(readl(host->ioaddr + SDHCI_HOST_CONTROL)\r\n| ESDHC_BURST_LEN_EN_INCR,\r\nhost->ioaddr + SDHCI_HOST_CONTROL);\r\nwritel(readl(host->ioaddr + 0x6c) | BIT(7),\r\nhost->ioaddr + 0x6c);\r\nwritel(0x0, host->ioaddr + ESDHC_DLL_CTRL);\r\nif (imx_data->socdata->flags & ESDHC_FLAG_STD_TUNING) {\r\ntmp = readl(host->ioaddr + ESDHC_TUNING_CTRL);\r\ntmp |= ESDHC_STD_TUNING_EN |\r\nESDHC_TUNING_START_TAP_DEFAULT;\r\nif (imx_data->boarddata.tuning_start_tap) {\r\ntmp &= ~ESDHC_TUNING_START_TAP_MASK;\r\ntmp |= imx_data->boarddata.tuning_start_tap;\r\n}\r\nif (imx_data->boarddata.tuning_step) {\r\ntmp &= ~ESDHC_TUNING_STEP_MASK;\r\ntmp |= imx_data->boarddata.tuning_step\r\n<< ESDHC_TUNING_STEP_SHIFT;\r\n}\r\nwritel(tmp, host->ioaddr + ESDHC_TUNING_CTRL);\r\n}\r\n}\r\n}\r\nstatic int\r\nsdhci_esdhc_imx_probe_dt(struct platform_device *pdev,\r\nstruct sdhci_host *host,\r\nstruct pltfm_imx_data *imx_data)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct esdhc_platform_data *boarddata = &imx_data->boarddata;\r\nint ret;\r\nif (of_get_property(np, "fsl,wp-controller", NULL))\r\nboarddata->wp_type = ESDHC_WP_CONTROLLER;\r\nboarddata->wp_gpio = of_get_named_gpio(np, "wp-gpios", 0);\r\nif (gpio_is_valid(boarddata->wp_gpio))\r\nboarddata->wp_type = ESDHC_WP_GPIO;\r\nof_property_read_u32(np, "fsl,tuning-step", &boarddata->tuning_step);\r\nof_property_read_u32(np, "fsl,tuning-start-tap",\r\n&boarddata->tuning_start_tap);\r\nif (of_find_property(np, "no-1-8-v", NULL))\r\nboarddata->support_vsel = false;\r\nelse\r\nboarddata->support_vsel = true;\r\nif (of_property_read_u32(np, "fsl,delay-line", &boarddata->delay_line))\r\nboarddata->delay_line = 0;\r\nmmc_of_parse_voltage(np, &host->ocr_mask);\r\nif ((boarddata->support_vsel) && esdhc_is_usdhc(imx_data) &&\r\n!IS_ERR(imx_data->pins_default)) {\r\nimx_data->pins_100mhz = pinctrl_lookup_state(imx_data->pinctrl,\r\nESDHC_PINCTRL_STATE_100MHZ);\r\nimx_data->pins_200mhz = pinctrl_lookup_state(imx_data->pinctrl,\r\nESDHC_PINCTRL_STATE_200MHZ);\r\nif (IS_ERR(imx_data->pins_100mhz) ||\r\nIS_ERR(imx_data->pins_200mhz)) {\r\ndev_warn(mmc_dev(host->mmc),\r\n"could not get ultra high speed state, work on normal mode\n");\r\nhost->quirks2 |= SDHCI_QUIRK2_NO_1_8_V;\r\n}\r\n} else {\r\nhost->quirks2 |= SDHCI_QUIRK2_NO_1_8_V;\r\n}\r\nret = mmc_of_parse(host->mmc);\r\nif (ret)\r\nreturn ret;\r\nif (mmc_gpio_get_cd(host->mmc) >= 0)\r\nhost->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nsdhci_esdhc_imx_probe_dt(struct platform_device *pdev,\r\nstruct sdhci_host *host,\r\nstruct pltfm_imx_data *imx_data)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int sdhci_esdhc_imx_probe_nondt(struct platform_device *pdev,\r\nstruct sdhci_host *host,\r\nstruct pltfm_imx_data *imx_data)\r\n{\r\nstruct esdhc_platform_data *boarddata = &imx_data->boarddata;\r\nint err;\r\nif (!host->mmc->parent->platform_data) {\r\ndev_err(mmc_dev(host->mmc), "no board data!\n");\r\nreturn -EINVAL;\r\n}\r\nimx_data->boarddata = *((struct esdhc_platform_data *)\r\nhost->mmc->parent->platform_data);\r\nif (boarddata->wp_type == ESDHC_WP_GPIO) {\r\nerr = mmc_gpio_request_ro(host->mmc, boarddata->wp_gpio);\r\nif (err) {\r\ndev_err(mmc_dev(host->mmc),\r\n"failed to request write-protect gpio!\n");\r\nreturn err;\r\n}\r\nhost->mmc->caps2 |= MMC_CAP2_RO_ACTIVE_HIGH;\r\n}\r\nswitch (boarddata->cd_type) {\r\ncase ESDHC_CD_GPIO:\r\nerr = mmc_gpio_request_cd(host->mmc, boarddata->cd_gpio, 0);\r\nif (err) {\r\ndev_err(mmc_dev(host->mmc),\r\n"failed to request card-detect gpio!\n");\r\nreturn err;\r\n}\r\ncase ESDHC_CD_CONTROLLER:\r\nhost->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;\r\nbreak;\r\ncase ESDHC_CD_PERMANENT:\r\nhost->mmc->caps |= MMC_CAP_NONREMOVABLE;\r\nbreak;\r\ncase ESDHC_CD_NONE:\r\nbreak;\r\n}\r\nswitch (boarddata->max_bus_width) {\r\ncase 8:\r\nhost->mmc->caps |= MMC_CAP_8_BIT_DATA | MMC_CAP_4_BIT_DATA;\r\nbreak;\r\ncase 4:\r\nhost->mmc->caps |= MMC_CAP_4_BIT_DATA;\r\nbreak;\r\ncase 1:\r\ndefault:\r\nhost->quirks |= SDHCI_QUIRK_FORCE_1_BIT_DATA;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sdhci_esdhc_imx_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(imx_esdhc_dt_ids, &pdev->dev);\r\nstruct sdhci_pltfm_host *pltfm_host;\r\nstruct sdhci_host *host;\r\nint err;\r\nstruct pltfm_imx_data *imx_data;\r\nhost = sdhci_pltfm_init(pdev, &sdhci_esdhc_imx_pdata,\r\nsizeof(*imx_data));\r\nif (IS_ERR(host))\r\nreturn PTR_ERR(host);\r\npltfm_host = sdhci_priv(host);\r\nimx_data = sdhci_pltfm_priv(pltfm_host);\r\nimx_data->socdata = of_id ? of_id->data : (struct esdhc_soc_data *)\r\npdev->id_entry->driver_data;\r\nimx_data->clk_ipg = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(imx_data->clk_ipg)) {\r\nerr = PTR_ERR(imx_data->clk_ipg);\r\ngoto free_sdhci;\r\n}\r\nimx_data->clk_ahb = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(imx_data->clk_ahb)) {\r\nerr = PTR_ERR(imx_data->clk_ahb);\r\ngoto free_sdhci;\r\n}\r\nimx_data->clk_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(imx_data->clk_per)) {\r\nerr = PTR_ERR(imx_data->clk_per);\r\ngoto free_sdhci;\r\n}\r\npltfm_host->clk = imx_data->clk_per;\r\npltfm_host->clock = clk_get_rate(pltfm_host->clk);\r\nerr = clk_prepare_enable(imx_data->clk_per);\r\nif (err)\r\ngoto free_sdhci;\r\nerr = clk_prepare_enable(imx_data->clk_ipg);\r\nif (err)\r\ngoto disable_per_clk;\r\nerr = clk_prepare_enable(imx_data->clk_ahb);\r\nif (err)\r\ngoto disable_ipg_clk;\r\nimx_data->pinctrl = devm_pinctrl_get(&pdev->dev);\r\nif (IS_ERR(imx_data->pinctrl)) {\r\nerr = PTR_ERR(imx_data->pinctrl);\r\ngoto disable_ahb_clk;\r\n}\r\nimx_data->pins_default = pinctrl_lookup_state(imx_data->pinctrl,\r\nPINCTRL_STATE_DEFAULT);\r\nif (IS_ERR(imx_data->pins_default))\r\ndev_warn(mmc_dev(host->mmc), "could not get default state\n");\r\nif (esdhc_is_usdhc(imx_data)) {\r\nhost->quirks2 |= SDHCI_QUIRK2_PRESET_VALUE_BROKEN;\r\nhost->mmc->caps |= MMC_CAP_1_8V_DDR;\r\nif (!(imx_data->socdata->flags & ESDHC_FLAG_HS200))\r\nhost->quirks2 |= SDHCI_QUIRK2_BROKEN_HS200;\r\nwritel(0x0, host->ioaddr + ESDHC_MIX_CTRL);\r\nwritel(0x0, host->ioaddr + SDHCI_ACMD12_ERR);\r\nwritel(0x0, host->ioaddr + ESDHC_TUNE_CTRL_STATUS);\r\n}\r\nif (imx_data->socdata->flags & ESDHC_FLAG_MAN_TUNING)\r\nsdhci_esdhc_ops.platform_execute_tuning =\r\nesdhc_executing_tuning;\r\nif (imx_data->socdata->flags & ESDHC_FLAG_ERR004536)\r\nhost->quirks |= SDHCI_QUIRK_BROKEN_ADMA;\r\nif (imx_data->socdata->flags & ESDHC_FLAG_HS400)\r\nhost->quirks2 |= SDHCI_QUIRK2_CAPS_BIT63_FOR_HS400;\r\nif (of_id)\r\nerr = sdhci_esdhc_imx_probe_dt(pdev, host, imx_data);\r\nelse\r\nerr = sdhci_esdhc_imx_probe_nondt(pdev, host, imx_data);\r\nif (err)\r\ngoto disable_ahb_clk;\r\nsdhci_esdhc_imx_hwinit(host);\r\nerr = sdhci_add_host(host);\r\nif (err)\r\ngoto disable_ahb_clk;\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, 50);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_suspend_ignore_children(&pdev->dev, 1);\r\npm_runtime_enable(&pdev->dev);\r\nreturn 0;\r\ndisable_ahb_clk:\r\nclk_disable_unprepare(imx_data->clk_ahb);\r\ndisable_ipg_clk:\r\nclk_disable_unprepare(imx_data->clk_ipg);\r\ndisable_per_clk:\r\nclk_disable_unprepare(imx_data->clk_per);\r\nfree_sdhci:\r\nsdhci_pltfm_free(pdev);\r\nreturn err;\r\n}\r\nstatic int sdhci_esdhc_imx_remove(struct platform_device *pdev)\r\n{\r\nstruct sdhci_host *host = platform_get_drvdata(pdev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nint dead = (readl(host->ioaddr + SDHCI_INT_STATUS) == 0xffffffff);\r\npm_runtime_get_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_put_noidle(&pdev->dev);\r\nsdhci_remove_host(host, dead);\r\nclk_disable_unprepare(imx_data->clk_per);\r\nclk_disable_unprepare(imx_data->clk_ipg);\r\nclk_disable_unprepare(imx_data->clk_ahb);\r\nsdhci_pltfm_free(pdev);\r\nreturn 0;\r\n}\r\nstatic int sdhci_esdhc_suspend(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nif (host->tuning_mode != SDHCI_TUNING_MODE_3)\r\nmmc_retune_needed(host->mmc);\r\nreturn sdhci_suspend_host(host);\r\n}\r\nstatic int sdhci_esdhc_resume(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nsdhci_esdhc_imx_hwinit(host);\r\nreturn sdhci_resume_host(host);\r\n}\r\nstatic int sdhci_esdhc_runtime_suspend(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nint ret;\r\nret = sdhci_runtime_suspend_host(host);\r\nif (host->tuning_mode != SDHCI_TUNING_MODE_3)\r\nmmc_retune_needed(host->mmc);\r\nif (!sdhci_sdio_irq_enabled(host)) {\r\nclk_disable_unprepare(imx_data->clk_per);\r\nclk_disable_unprepare(imx_data->clk_ipg);\r\n}\r\nclk_disable_unprepare(imx_data->clk_ahb);\r\nreturn ret;\r\n}\r\nstatic int sdhci_esdhc_runtime_resume(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\r\nint err;\r\nif (!sdhci_sdio_irq_enabled(host)) {\r\nerr = clk_prepare_enable(imx_data->clk_per);\r\nif (err)\r\nreturn err;\r\nerr = clk_prepare_enable(imx_data->clk_ipg);\r\nif (err)\r\ngoto disable_per_clk;\r\n}\r\nerr = clk_prepare_enable(imx_data->clk_ahb);\r\nif (err)\r\ngoto disable_ipg_clk;\r\nerr = sdhci_runtime_resume_host(host);\r\nif (err)\r\ngoto disable_ahb_clk;\r\nreturn 0;\r\ndisable_ahb_clk:\r\nclk_disable_unprepare(imx_data->clk_ahb);\r\ndisable_ipg_clk:\r\nif (!sdhci_sdio_irq_enabled(host))\r\nclk_disable_unprepare(imx_data->clk_ipg);\r\ndisable_per_clk:\r\nif (!sdhci_sdio_irq_enabled(host))\r\nclk_disable_unprepare(imx_data->clk_per);\r\nreturn err;\r\n}
