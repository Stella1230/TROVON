struct snd_util_memhdr *\r\nsnd_util_memhdr_new(int memsize)\r\n{\r\nstruct snd_util_memhdr *hdr;\r\nhdr = kzalloc(sizeof(*hdr), GFP_KERNEL);\r\nif (hdr == NULL)\r\nreturn NULL;\r\nhdr->size = memsize;\r\nmutex_init(&hdr->block_mutex);\r\nINIT_LIST_HEAD(&hdr->block);\r\nreturn hdr;\r\n}\r\nvoid snd_util_memhdr_free(struct snd_util_memhdr *hdr)\r\n{\r\nstruct list_head *p;\r\nif (!hdr)\r\nreturn;\r\nwhile ((p = hdr->block.next) != &hdr->block) {\r\nlist_del(p);\r\nkfree(get_memblk(p));\r\n}\r\nkfree(hdr);\r\n}\r\nstruct snd_util_memblk *\r\n__snd_util_mem_alloc(struct snd_util_memhdr *hdr, int size)\r\n{\r\nstruct snd_util_memblk *blk;\r\nunsigned int units, prev_offset;\r\nstruct list_head *p;\r\nif (snd_BUG_ON(!hdr || size <= 0))\r\nreturn NULL;\r\nunits = size;\r\nif (units & 1)\r\nunits++;\r\nif (units > hdr->size)\r\nreturn NULL;\r\nprev_offset = 0;\r\nlist_for_each(p, &hdr->block) {\r\nblk = get_memblk(p);\r\nif (blk->offset - prev_offset >= units)\r\ngoto __found;\r\nprev_offset = blk->offset + blk->size;\r\n}\r\nif (hdr->size - prev_offset < units)\r\nreturn NULL;\r\n__found:\r\nreturn __snd_util_memblk_new(hdr, units, p->prev);\r\n}\r\nstruct snd_util_memblk *\r\n__snd_util_memblk_new(struct snd_util_memhdr *hdr, unsigned int units,\r\nstruct list_head *prev)\r\n{\r\nstruct snd_util_memblk *blk;\r\nblk = kmalloc(sizeof(struct snd_util_memblk) + hdr->block_extra_size,\r\nGFP_KERNEL);\r\nif (blk == NULL)\r\nreturn NULL;\r\nif (prev == &hdr->block)\r\nblk->offset = 0;\r\nelse {\r\nstruct snd_util_memblk *p = get_memblk(prev);\r\nblk->offset = p->offset + p->size;\r\n}\r\nblk->size = units;\r\nlist_add(&blk->list, prev);\r\nhdr->nblocks++;\r\nhdr->used += units;\r\nreturn blk;\r\n}\r\nstruct snd_util_memblk *\r\nsnd_util_mem_alloc(struct snd_util_memhdr *hdr, int size)\r\n{\r\nstruct snd_util_memblk *blk;\r\nmutex_lock(&hdr->block_mutex);\r\nblk = __snd_util_mem_alloc(hdr, size);\r\nmutex_unlock(&hdr->block_mutex);\r\nreturn blk;\r\n}\r\nvoid\r\n__snd_util_mem_free(struct snd_util_memhdr *hdr, struct snd_util_memblk *blk)\r\n{\r\nlist_del(&blk->list);\r\nhdr->nblocks--;\r\nhdr->used -= blk->size;\r\nkfree(blk);\r\n}\r\nint snd_util_mem_free(struct snd_util_memhdr *hdr, struct snd_util_memblk *blk)\r\n{\r\nif (snd_BUG_ON(!hdr || !blk))\r\nreturn -EINVAL;\r\nmutex_lock(&hdr->block_mutex);\r\n__snd_util_mem_free(hdr, blk);\r\nmutex_unlock(&hdr->block_mutex);\r\nreturn 0;\r\n}\r\nint snd_util_mem_avail(struct snd_util_memhdr *hdr)\r\n{\r\nunsigned int size;\r\nmutex_lock(&hdr->block_mutex);\r\nsize = hdr->size - hdr->used;\r\nmutex_unlock(&hdr->block_mutex);\r\nreturn size;\r\n}\r\nstatic int __init alsa_util_mem_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_util_mem_exit(void)\r\n{\r\n}
