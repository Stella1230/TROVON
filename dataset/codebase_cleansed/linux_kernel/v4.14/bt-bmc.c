static u8 bt_inb(struct bt_bmc *bt_bmc, int reg)\r\n{\r\nuint32_t val = 0;\r\nint rc;\r\nrc = regmap_read(bt_bmc->map, bt_bmc->offset + reg, &val);\r\nWARN(rc != 0, "regmap_read() failed: %d\n", rc);\r\nreturn rc == 0 ? (u8) val : 0;\r\n}\r\nstatic void bt_outb(struct bt_bmc *bt_bmc, u8 data, int reg)\r\n{\r\nint rc;\r\nrc = regmap_write(bt_bmc->map, bt_bmc->offset + reg, data);\r\nWARN(rc != 0, "regmap_write() failed: %d\n", rc);\r\n}\r\nstatic void clr_rd_ptr(struct bt_bmc *bt_bmc)\r\n{\r\nbt_outb(bt_bmc, BT_CTRL_CLR_RD_PTR, BT_CTRL);\r\n}\r\nstatic void clr_wr_ptr(struct bt_bmc *bt_bmc)\r\n{\r\nbt_outb(bt_bmc, BT_CTRL_CLR_WR_PTR, BT_CTRL);\r\n}\r\nstatic void clr_h2b_atn(struct bt_bmc *bt_bmc)\r\n{\r\nbt_outb(bt_bmc, BT_CTRL_H2B_ATN, BT_CTRL);\r\n}\r\nstatic void set_b_busy(struct bt_bmc *bt_bmc)\r\n{\r\nif (!(bt_inb(bt_bmc, BT_CTRL) & BT_CTRL_B_BUSY))\r\nbt_outb(bt_bmc, BT_CTRL_B_BUSY, BT_CTRL);\r\n}\r\nstatic void clr_b_busy(struct bt_bmc *bt_bmc)\r\n{\r\nif (bt_inb(bt_bmc, BT_CTRL) & BT_CTRL_B_BUSY)\r\nbt_outb(bt_bmc, BT_CTRL_B_BUSY, BT_CTRL);\r\n}\r\nstatic void set_b2h_atn(struct bt_bmc *bt_bmc)\r\n{\r\nbt_outb(bt_bmc, BT_CTRL_B2H_ATN, BT_CTRL);\r\n}\r\nstatic u8 bt_read(struct bt_bmc *bt_bmc)\r\n{\r\nreturn bt_inb(bt_bmc, BT_BMC2HOST);\r\n}\r\nstatic ssize_t bt_readn(struct bt_bmc *bt_bmc, u8 *buf, size_t n)\r\n{\r\nint i;\r\nfor (i = 0; i < n; i++)\r\nbuf[i] = bt_read(bt_bmc);\r\nreturn n;\r\n}\r\nstatic void bt_write(struct bt_bmc *bt_bmc, u8 c)\r\n{\r\nbt_outb(bt_bmc, c, BT_BMC2HOST);\r\n}\r\nstatic ssize_t bt_writen(struct bt_bmc *bt_bmc, u8 *buf, size_t n)\r\n{\r\nint i;\r\nfor (i = 0; i < n; i++)\r\nbt_write(bt_bmc, buf[i]);\r\nreturn n;\r\n}\r\nstatic void set_sms_atn(struct bt_bmc *bt_bmc)\r\n{\r\nbt_outb(bt_bmc, BT_CTRL_SMS_ATN, BT_CTRL);\r\n}\r\nstatic struct bt_bmc *file_bt_bmc(struct file *file)\r\n{\r\nreturn container_of(file->private_data, struct bt_bmc, miscdev);\r\n}\r\nstatic int bt_bmc_open(struct inode *inode, struct file *file)\r\n{\r\nstruct bt_bmc *bt_bmc = file_bt_bmc(file);\r\nif (atomic_inc_return(&open_count) == 1) {\r\nclr_b_busy(bt_bmc);\r\nreturn 0;\r\n}\r\natomic_dec(&open_count);\r\nreturn -EBUSY;\r\n}\r\nstatic ssize_t bt_bmc_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct bt_bmc *bt_bmc = file_bt_bmc(file);\r\nu8 len;\r\nint len_byte = 1;\r\nu8 kbuffer[BT_BMC_BUFFER_SIZE];\r\nssize_t ret = 0;\r\nssize_t nread;\r\nif (!access_ok(VERIFY_WRITE, buf, count))\r\nreturn -EFAULT;\r\nWARN_ON(*ppos);\r\nif (wait_event_interruptible(bt_bmc->queue,\r\nbt_inb(bt_bmc, BT_CTRL) & BT_CTRL_H2B_ATN))\r\nreturn -ERESTARTSYS;\r\nmutex_lock(&bt_bmc->mutex);\r\nif (unlikely(!(bt_inb(bt_bmc, BT_CTRL) & BT_CTRL_H2B_ATN))) {\r\nret = -EIO;\r\ngoto out_unlock;\r\n}\r\nset_b_busy(bt_bmc);\r\nclr_h2b_atn(bt_bmc);\r\nclr_rd_ptr(bt_bmc);\r\nkbuffer[0] = bt_read(bt_bmc);\r\nlen = kbuffer[0];\r\nif (len + 1 > count)\r\nlen = count - 1;\r\nwhile (len) {\r\nnread = min_t(ssize_t, len, sizeof(kbuffer) - len_byte);\r\nbt_readn(bt_bmc, kbuffer + len_byte, nread);\r\nif (copy_to_user(buf, kbuffer, nread + len_byte)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nlen -= nread;\r\nbuf += nread + len_byte;\r\nret += nread + len_byte;\r\nlen_byte = 0;\r\n}\r\nclr_b_busy(bt_bmc);\r\nout_unlock:\r\nmutex_unlock(&bt_bmc->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t bt_bmc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct bt_bmc *bt_bmc = file_bt_bmc(file);\r\nu8 kbuffer[BT_BMC_BUFFER_SIZE];\r\nssize_t ret = 0;\r\nssize_t nwritten;\r\nif (count < 5)\r\nreturn -EINVAL;\r\nif (!access_ok(VERIFY_READ, buf, count))\r\nreturn -EFAULT;\r\nWARN_ON(*ppos);\r\nif (wait_event_interruptible(bt_bmc->queue,\r\n!(bt_inb(bt_bmc, BT_CTRL) &\r\n(BT_CTRL_H_BUSY | BT_CTRL_B2H_ATN))))\r\nreturn -ERESTARTSYS;\r\nmutex_lock(&bt_bmc->mutex);\r\nif (unlikely(bt_inb(bt_bmc, BT_CTRL) &\r\n(BT_CTRL_H_BUSY | BT_CTRL_B2H_ATN))) {\r\nret = -EIO;\r\ngoto out_unlock;\r\n}\r\nclr_wr_ptr(bt_bmc);\r\nwhile (count) {\r\nnwritten = min_t(ssize_t, count, sizeof(kbuffer));\r\nif (copy_from_user(&kbuffer, buf, nwritten)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nbt_writen(bt_bmc, kbuffer, nwritten);\r\ncount -= nwritten;\r\nbuf += nwritten;\r\nret += nwritten;\r\n}\r\nset_b2h_atn(bt_bmc);\r\nout_unlock:\r\nmutex_unlock(&bt_bmc->mutex);\r\nreturn ret;\r\n}\r\nstatic long bt_bmc_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long param)\r\n{\r\nstruct bt_bmc *bt_bmc = file_bt_bmc(file);\r\nswitch (cmd) {\r\ncase BT_BMC_IOCTL_SMS_ATN:\r\nset_sms_atn(bt_bmc);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int bt_bmc_release(struct inode *inode, struct file *file)\r\n{\r\nstruct bt_bmc *bt_bmc = file_bt_bmc(file);\r\natomic_dec(&open_count);\r\nset_b_busy(bt_bmc);\r\nreturn 0;\r\n}\r\nstatic unsigned int bt_bmc_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct bt_bmc *bt_bmc = file_bt_bmc(file);\r\nunsigned int mask = 0;\r\nu8 ctrl;\r\npoll_wait(file, &bt_bmc->queue, wait);\r\nctrl = bt_inb(bt_bmc, BT_CTRL);\r\nif (ctrl & BT_CTRL_H2B_ATN)\r\nmask |= POLLIN;\r\nif (!(ctrl & (BT_CTRL_H_BUSY | BT_CTRL_B2H_ATN)))\r\nmask |= POLLOUT;\r\nreturn mask;\r\n}\r\nstatic void poll_timer(unsigned long data)\r\n{\r\nstruct bt_bmc *bt_bmc = (void *)data;\r\nbt_bmc->poll_timer.expires += msecs_to_jiffies(500);\r\nwake_up(&bt_bmc->queue);\r\nadd_timer(&bt_bmc->poll_timer);\r\n}\r\nstatic irqreturn_t bt_bmc_irq(int irq, void *arg)\r\n{\r\nstruct bt_bmc *bt_bmc = arg;\r\nu32 reg;\r\nint rc;\r\nrc = regmap_read(bt_bmc->map, bt_bmc->offset + BT_CR2, &reg);\r\nif (rc)\r\nreturn IRQ_NONE;\r\nreg &= BT_CR2_IRQ_H2B | BT_CR2_IRQ_HBUSY;\r\nif (!reg)\r\nreturn IRQ_NONE;\r\nregmap_write(bt_bmc->map, bt_bmc->offset + BT_CR2, reg);\r\nwake_up(&bt_bmc->queue);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bt_bmc_config_irq(struct bt_bmc *bt_bmc,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nint rc;\r\nbt_bmc->irq = platform_get_irq(pdev, 0);\r\nif (!bt_bmc->irq)\r\nreturn -ENODEV;\r\nrc = devm_request_irq(dev, bt_bmc->irq, bt_bmc_irq, IRQF_SHARED,\r\nDEVICE_NAME, bt_bmc);\r\nif (rc < 0) {\r\ndev_warn(dev, "Unable to request IRQ %d\n", bt_bmc->irq);\r\nbt_bmc->irq = 0;\r\nreturn rc;\r\n}\r\nrc = regmap_update_bits(bt_bmc->map, bt_bmc->offset + BT_CR1,\r\n(BT_CR1_IRQ_H2B | BT_CR1_IRQ_HBUSY),\r\n(BT_CR1_IRQ_H2B | BT_CR1_IRQ_HBUSY));\r\nreturn rc;\r\n}\r\nstatic int bt_bmc_probe(struct platform_device *pdev)\r\n{\r\nstruct bt_bmc *bt_bmc;\r\nstruct device *dev;\r\nint rc;\r\nif (!pdev || !pdev->dev.of_node)\r\nreturn -ENODEV;\r\ndev = &pdev->dev;\r\ndev_info(dev, "Found bt bmc device\n");\r\nbt_bmc = devm_kzalloc(dev, sizeof(*bt_bmc), GFP_KERNEL);\r\nif (!bt_bmc)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&pdev->dev, bt_bmc);\r\nbt_bmc->map = syscon_node_to_regmap(pdev->dev.parent->of_node);\r\nif (IS_ERR(bt_bmc->map)) {\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nbt_bmc->map = devm_regmap_init_mmio(dev, base, &bt_regmap_cfg);\r\nbt_bmc->offset = 0;\r\n} else {\r\nrc = of_property_read_u32(dev->of_node, "reg", &bt_bmc->offset);\r\nif (rc)\r\nreturn rc;\r\n}\r\nmutex_init(&bt_bmc->mutex);\r\ninit_waitqueue_head(&bt_bmc->queue);\r\nbt_bmc->miscdev.minor = MISC_DYNAMIC_MINOR,\r\nbt_bmc->miscdev.name = DEVICE_NAME,\r\nbt_bmc->miscdev.fops = &bt_bmc_fops,\r\nbt_bmc->miscdev.parent = dev;\r\nrc = misc_register(&bt_bmc->miscdev);\r\nif (rc) {\r\ndev_err(dev, "Unable to register misc device\n");\r\nreturn rc;\r\n}\r\nbt_bmc_config_irq(bt_bmc, pdev);\r\nif (bt_bmc->irq) {\r\ndev_info(dev, "Using IRQ %d\n", bt_bmc->irq);\r\n} else {\r\ndev_info(dev, "No IRQ; using timer\n");\r\nsetup_timer(&bt_bmc->poll_timer, poll_timer,\r\n(unsigned long)bt_bmc);\r\nbt_bmc->poll_timer.expires = jiffies + msecs_to_jiffies(10);\r\nadd_timer(&bt_bmc->poll_timer);\r\n}\r\nregmap_write(bt_bmc->map, bt_bmc->offset + BT_CR0,\r\n(BT_IO_BASE << BT_CR0_IO_BASE) |\r\n(BT_IRQ << BT_CR0_IRQ) |\r\nBT_CR0_EN_CLR_SLV_RDP |\r\nBT_CR0_EN_CLR_SLV_WRP |\r\nBT_CR0_ENABLE_IBT);\r\nclr_b_busy(bt_bmc);\r\nreturn 0;\r\n}\r\nstatic int bt_bmc_remove(struct platform_device *pdev)\r\n{\r\nstruct bt_bmc *bt_bmc = dev_get_drvdata(&pdev->dev);\r\nmisc_deregister(&bt_bmc->miscdev);\r\nif (!bt_bmc->irq)\r\ndel_timer_sync(&bt_bmc->poll_timer);\r\nreturn 0;\r\n}
