int v4l2_device_register(struct device *dev, struct v4l2_device *v4l2_dev)\r\n{\r\nif (v4l2_dev == NULL)\r\nreturn -EINVAL;\r\nINIT_LIST_HEAD(&v4l2_dev->subdevs);\r\nspin_lock_init(&v4l2_dev->lock);\r\nv4l2_prio_init(&v4l2_dev->prio);\r\nkref_init(&v4l2_dev->ref);\r\nget_device(dev);\r\nv4l2_dev->dev = dev;\r\nif (dev == NULL) {\r\nif (WARN_ON(!v4l2_dev->name[0]))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nif (!v4l2_dev->name[0])\r\nsnprintf(v4l2_dev->name, sizeof(v4l2_dev->name), "%s %s",\r\ndev->driver->name, dev_name(dev));\r\nif (!dev_get_drvdata(dev))\r\ndev_set_drvdata(dev, v4l2_dev);\r\nreturn 0;\r\n}\r\nstatic void v4l2_device_release(struct kref *ref)\r\n{\r\nstruct v4l2_device *v4l2_dev =\r\ncontainer_of(ref, struct v4l2_device, ref);\r\nif (v4l2_dev->release)\r\nv4l2_dev->release(v4l2_dev);\r\n}\r\nint v4l2_device_put(struct v4l2_device *v4l2_dev)\r\n{\r\nreturn kref_put(&v4l2_dev->ref, v4l2_device_release);\r\n}\r\nint v4l2_device_set_name(struct v4l2_device *v4l2_dev, const char *basename,\r\natomic_t *instance)\r\n{\r\nint num = atomic_inc_return(instance) - 1;\r\nint len = strlen(basename);\r\nif (basename[len - 1] >= '0' && basename[len - 1] <= '9')\r\nsnprintf(v4l2_dev->name, sizeof(v4l2_dev->name),\r\n"%s-%d", basename, num);\r\nelse\r\nsnprintf(v4l2_dev->name, sizeof(v4l2_dev->name),\r\n"%s%d", basename, num);\r\nreturn num;\r\n}\r\nvoid v4l2_device_disconnect(struct v4l2_device *v4l2_dev)\r\n{\r\nif (v4l2_dev->dev == NULL)\r\nreturn;\r\nif (dev_get_drvdata(v4l2_dev->dev) == v4l2_dev)\r\ndev_set_drvdata(v4l2_dev->dev, NULL);\r\nput_device(v4l2_dev->dev);\r\nv4l2_dev->dev = NULL;\r\n}\r\nvoid v4l2_device_unregister(struct v4l2_device *v4l2_dev)\r\n{\r\nstruct v4l2_subdev *sd, *next;\r\nif (v4l2_dev == NULL || !v4l2_dev->name[0])\r\nreturn;\r\nv4l2_device_disconnect(v4l2_dev);\r\nlist_for_each_entry_safe(sd, next, &v4l2_dev->subdevs, list) {\r\nv4l2_device_unregister_subdev(sd);\r\n#if IS_ENABLED(CONFIG_I2C)\r\nif (sd->flags & V4L2_SUBDEV_FL_IS_I2C) {\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (client &&\r\n!client->dev.of_node && !client->dev.fwnode)\r\ni2c_unregister_device(client);\r\ncontinue;\r\n}\r\n#endif\r\n#if defined(CONFIG_SPI)\r\nif (sd->flags & V4L2_SUBDEV_FL_IS_SPI) {\r\nstruct spi_device *spi = v4l2_get_subdevdata(sd);\r\nif (spi && !spi->dev.of_node && !spi->dev.fwnode)\r\nspi_unregister_device(spi);\r\ncontinue;\r\n}\r\n#endif\r\n}\r\nv4l2_dev->name[0] = '\0';\r\n}\r\nint v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,\r\nstruct v4l2_subdev *sd)\r\n{\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nstruct media_entity *entity = &sd->entity;\r\n#endif\r\nint err;\r\nif (!v4l2_dev || !sd || sd->v4l2_dev || !sd->name[0])\r\nreturn -EINVAL;\r\nsd->owner_v4l2_dev = v4l2_dev->dev && v4l2_dev->dev->driver &&\r\nsd->owner == v4l2_dev->dev->driver->owner;\r\nif (!sd->owner_v4l2_dev && !try_module_get(sd->owner))\r\nreturn -ENODEV;\r\nsd->v4l2_dev = v4l2_dev;\r\nerr = v4l2_ctrl_add_handler(v4l2_dev->ctrl_handler, sd->ctrl_handler, NULL);\r\nif (err)\r\ngoto error_module;\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nif (v4l2_dev->mdev) {\r\nerr = media_device_register_entity(v4l2_dev->mdev, entity);\r\nif (err < 0)\r\ngoto error_module;\r\n}\r\n#endif\r\nif (sd->internal_ops && sd->internal_ops->registered) {\r\nerr = sd->internal_ops->registered(sd);\r\nif (err)\r\ngoto error_unregister;\r\n}\r\nspin_lock(&v4l2_dev->lock);\r\nlist_add_tail(&sd->list, &v4l2_dev->subdevs);\r\nspin_unlock(&v4l2_dev->lock);\r\nreturn 0;\r\nerror_unregister:\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nmedia_device_unregister_entity(entity);\r\n#endif\r\nerror_module:\r\nif (!sd->owner_v4l2_dev)\r\nmodule_put(sd->owner);\r\nsd->v4l2_dev = NULL;\r\nreturn err;\r\n}\r\nstatic void v4l2_device_release_subdev_node(struct video_device *vdev)\r\n{\r\nstruct v4l2_subdev *sd = video_get_drvdata(vdev);\r\nsd->devnode = NULL;\r\nkfree(vdev);\r\n}\r\nint v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)\r\n{\r\nstruct video_device *vdev;\r\nstruct v4l2_subdev *sd;\r\nint err;\r\nlist_for_each_entry(sd, &v4l2_dev->subdevs, list) {\r\nif (!(sd->flags & V4L2_SUBDEV_FL_HAS_DEVNODE))\r\ncontinue;\r\nif (sd->devnode)\r\ncontinue;\r\nvdev = kzalloc(sizeof(*vdev), GFP_KERNEL);\r\nif (!vdev) {\r\nerr = -ENOMEM;\r\ngoto clean_up;\r\n}\r\nvideo_set_drvdata(vdev, sd);\r\nstrlcpy(vdev->name, sd->name, sizeof(vdev->name));\r\nvdev->v4l2_dev = v4l2_dev;\r\nvdev->fops = &v4l2_subdev_fops;\r\nvdev->release = v4l2_device_release_subdev_node;\r\nvdev->ctrl_handler = sd->ctrl_handler;\r\nerr = __video_register_device(vdev, VFL_TYPE_SUBDEV, -1, 1,\r\nsd->owner);\r\nif (err < 0) {\r\nkfree(vdev);\r\ngoto clean_up;\r\n}\r\nsd->devnode = vdev;\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nsd->entity.info.dev.major = VIDEO_MAJOR;\r\nsd->entity.info.dev.minor = vdev->minor;\r\nif (vdev->v4l2_dev->mdev) {\r\nstruct media_link *link;\r\nlink = media_create_intf_link(&sd->entity,\r\n&vdev->intf_devnode->intf,\r\nMEDIA_LNK_FL_ENABLED);\r\nif (!link) {\r\nerr = -ENOMEM;\r\ngoto clean_up;\r\n}\r\n}\r\n#endif\r\n}\r\nreturn 0;\r\nclean_up:\r\nlist_for_each_entry(sd, &v4l2_dev->subdevs, list) {\r\nif (!sd->devnode)\r\nbreak;\r\nvideo_unregister_device(sd->devnode);\r\n}\r\nreturn err;\r\n}\r\nvoid v4l2_device_unregister_subdev(struct v4l2_subdev *sd)\r\n{\r\nstruct v4l2_device *v4l2_dev;\r\nif (sd == NULL || sd->v4l2_dev == NULL)\r\nreturn;\r\nv4l2_dev = sd->v4l2_dev;\r\nspin_lock(&v4l2_dev->lock);\r\nlist_del(&sd->list);\r\nspin_unlock(&v4l2_dev->lock);\r\nif (sd->internal_ops && sd->internal_ops->unregistered)\r\nsd->internal_ops->unregistered(sd);\r\nsd->v4l2_dev = NULL;\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nif (v4l2_dev->mdev) {\r\nmedia_device_unregister_entity(&sd->entity);\r\n}\r\n#endif\r\nvideo_unregister_device(sd->devnode);\r\nif (!sd->owner_v4l2_dev)\r\nmodule_put(sd->owner);\r\n}
