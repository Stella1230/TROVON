static void c8sectpfe_timer_interrupt(unsigned long ac8sectpfei)\r\n{\r\nstruct c8sectpfei *fei = (struct c8sectpfei *)ac8sectpfei;\r\nstruct channel_info *channel;\r\nint chan_num;\r\nfor (chan_num = 0; chan_num < fei->tsin_count; chan_num++) {\r\nchannel = fei->channel_data[chan_num];\r\nif (channel->irec && readl(channel->irec + DMA_PRDS_TPENABLE))\r\ntasklet_schedule(&channel->tsklet);\r\n}\r\nfei->timer.expires = jiffies + msecs_to_jiffies(POLL_MSECS);\r\nadd_timer(&fei->timer);\r\n}\r\nstatic void channel_swdemux_tsklet(unsigned long data)\r\n{\r\nstruct channel_info *channel = (struct channel_info *)data;\r\nstruct c8sectpfei *fei = channel->fei;\r\nunsigned long wp, rp;\r\nint pos, num_packets, n, size;\r\nu8 *buf;\r\nif (unlikely(!channel || !channel->irec))\r\nreturn;\r\nwp = readl(channel->irec + DMA_PRDS_BUSWP_TP(0));\r\nrp = readl(channel->irec + DMA_PRDS_BUSRP_TP(0));\r\npos = rp - channel->back_buffer_busaddr;\r\nif (wp < rp)\r\nwp = channel->back_buffer_busaddr + FEI_BUFFER_SIZE;\r\nsize = wp - rp;\r\nnum_packets = size / PACKET_SIZE;\r\ndma_sync_single_for_cpu(fei->dev,\r\nrp,\r\nsize,\r\nDMA_FROM_DEVICE);\r\nbuf = (u8 *) channel->back_buffer_aligned;\r\ndev_dbg(fei->dev,\r\n"chan=%d channel=%p num_packets = %d, buf = %p, pos = 0x%x\n\trp=0x%lx, wp=0x%lx\n",\r\nchannel->tsin_id, channel, num_packets, buf, pos, rp, wp);\r\nfor (n = 0; n < num_packets; n++) {\r\ndvb_dmx_swfilter_packets(\r\n&fei->c8sectpfe[0]->\r\ndemux[channel->demux_mapping].dvb_demux,\r\n&buf[pos], 1);\r\npos += PACKET_SIZE;\r\n}\r\nif (wp == (channel->back_buffer_busaddr + FEI_BUFFER_SIZE))\r\nwritel(channel->back_buffer_busaddr, channel->irec +\r\nDMA_PRDS_BUSRP_TP(0));\r\nelse\r\nwritel(wp, channel->irec + DMA_PRDS_BUSRP_TP(0));\r\n}\r\nstatic int c8sectpfe_start_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux *demux = dvbdmxfeed->demux;\r\nstruct stdemux *stdemux = (struct stdemux *)demux->priv;\r\nstruct c8sectpfei *fei = stdemux->c8sectpfei;\r\nstruct channel_info *channel;\r\nu32 tmp;\r\nunsigned long *bitmap;\r\nint ret;\r\nswitch (dvbdmxfeed->type) {\r\ncase DMX_TYPE_TS:\r\nbreak;\r\ncase DMX_TYPE_SEC:\r\nbreak;\r\ndefault:\r\ndev_err(fei->dev, "%s:%d Error bailing\n"\r\n, __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nif (dvbdmxfeed->type == DMX_TYPE_TS) {\r\nswitch (dvbdmxfeed->pes_type) {\r\ncase DMX_PES_VIDEO:\r\ncase DMX_PES_AUDIO:\r\ncase DMX_PES_TELETEXT:\r\ncase DMX_PES_PCR:\r\ncase DMX_PES_OTHER:\r\nbreak;\r\ndefault:\r\ndev_err(fei->dev, "%s:%d Error bailing\n"\r\n, __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!atomic_read(&fei->fw_loaded)) {\r\nret = load_c8sectpfe_fw(fei);\r\nif (ret)\r\nreturn ret;\r\n}\r\nmutex_lock(&fei->lock);\r\nchannel = fei->channel_data[stdemux->tsin_index];\r\nbitmap = (unsigned long *) channel->pid_buffer_aligned;\r\nif (dvbdmxfeed->pid == 8192) {\r\ntmp = readl(fei->io + C8SECTPFE_IB_PID_SET(channel->tsin_id));\r\ntmp &= ~C8SECTPFE_PID_ENABLE;\r\nwritel(tmp, fei->io + C8SECTPFE_IB_PID_SET(channel->tsin_id));\r\n} else {\r\nbitmap_set(bitmap, dvbdmxfeed->pid, 1);\r\n}\r\ndma_sync_single_for_device(fei->dev,\r\nchannel->pid_buffer_busaddr,\r\nPID_TABLE_SIZE,\r\nDMA_TO_DEVICE);\r\nchannel->active = 1;\r\nif (fei->global_feed_count == 0) {\r\nfei->timer.expires = jiffies +\r\nmsecs_to_jiffies(msecs_to_jiffies(POLL_MSECS));\r\nadd_timer(&fei->timer);\r\n}\r\nif (stdemux->running_feed_count == 0) {\r\ndev_dbg(fei->dev, "Starting channel=%p\n", channel);\r\ntasklet_init(&channel->tsklet, channel_swdemux_tsklet,\r\n(unsigned long) channel);\r\nwritel(channel->fifo,\r\nfei->io + C8SECTPFE_IB_BUFF_STRT(channel->tsin_id));\r\nwritel(channel->fifo + FIFO_LEN - 1,\r\nfei->io + C8SECTPFE_IB_BUFF_END(channel->tsin_id));\r\nwritel(channel->fifo,\r\nfei->io + C8SECTPFE_IB_READ_PNT(channel->tsin_id));\r\nwritel(channel->fifo,\r\nfei->io + C8SECTPFE_IB_WRT_PNT(channel->tsin_id));\r\nwritel(channel->back_buffer_busaddr, channel->irec +\r\nDMA_PRDS_BUSBASE_TP(0));\r\ntmp = channel->back_buffer_busaddr + FEI_BUFFER_SIZE - 1;\r\nwritel(tmp, channel->irec + DMA_PRDS_BUSTOP_TP(0));\r\nwritel(channel->back_buffer_busaddr, channel->irec +\r\nDMA_PRDS_BUSWP_TP(0));\r\nwritel(C8SECTPFE_SYS_ENABLE | C8SECTPFE_SYS_RESET\r\n, fei->io + C8SECTPFE_IB_SYS(channel->tsin_id));\r\nwritel(0x1, channel->irec + DMA_PRDS_TPENABLE);\r\ndev_dbg(fei->dev, "%s:%d Starting DMA feed on stdemux=%p\n"\r\n, __func__, __LINE__, stdemux);\r\n}\r\nstdemux->running_feed_count++;\r\nfei->global_feed_count++;\r\nmutex_unlock(&fei->lock);\r\nreturn 0;\r\n}\r\nstatic int c8sectpfe_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux *demux = dvbdmxfeed->demux;\r\nstruct stdemux *stdemux = (struct stdemux *)demux->priv;\r\nstruct c8sectpfei *fei = stdemux->c8sectpfei;\r\nstruct channel_info *channel;\r\nint idlereq;\r\nu32 tmp;\r\nint ret;\r\nunsigned long *bitmap;\r\nif (!atomic_read(&fei->fw_loaded)) {\r\nret = load_c8sectpfe_fw(fei);\r\nif (ret)\r\nreturn ret;\r\n}\r\nmutex_lock(&fei->lock);\r\nchannel = fei->channel_data[stdemux->tsin_index];\r\nbitmap = (unsigned long *) channel->pid_buffer_aligned;\r\nif (dvbdmxfeed->pid == 8192) {\r\ntmp = readl(fei->io + C8SECTPFE_IB_PID_SET(channel->tsin_id));\r\ntmp |= C8SECTPFE_PID_ENABLE;\r\nwritel(tmp, fei->io + C8SECTPFE_IB_PID_SET(channel->tsin_id));\r\n} else {\r\nbitmap_clear(bitmap, dvbdmxfeed->pid, 1);\r\n}\r\ndma_sync_single_for_device(fei->dev,\r\nchannel->pid_buffer_busaddr,\r\nPID_TABLE_SIZE,\r\nDMA_TO_DEVICE);\r\nif (--stdemux->running_feed_count == 0) {\r\nchannel = fei->channel_data[stdemux->tsin_index];\r\nwritel(0, fei->io + C8SECTPFE_IB_SYS(channel->tsin_id));\r\nwritel(0, channel->irec + DMA_PRDS_TPENABLE);\r\ntasklet_disable(&channel->tsklet);\r\nidlereq = (1 << channel->tsin_id) | IDLEREQ;\r\nwritel(idlereq, fei->io + DMA_IDLE_REQ);\r\nret = wait_for_completion_timeout(&channel->idle_completion,\r\nmsecs_to_jiffies(100));\r\nif (ret == 0)\r\ndev_warn(fei->dev,\r\n"Timeout waiting for idle irq on tsin%d\n",\r\nchannel->tsin_id);\r\nreinit_completion(&channel->idle_completion);\r\nwritel(channel->back_buffer_busaddr,\r\nchannel->irec + DMA_PRDS_BUSBASE_TP(0));\r\ntmp = channel->back_buffer_busaddr + FEI_BUFFER_SIZE - 1;\r\nwritel(tmp, channel->irec + DMA_PRDS_BUSTOP_TP(0));\r\nwritel(channel->back_buffer_busaddr,\r\nchannel->irec + DMA_PRDS_BUSWP_TP(0));\r\ndev_dbg(fei->dev,\r\n"%s:%d stopping DMA feed on stdemux=%p channel=%d\n",\r\n__func__, __LINE__, stdemux, channel->tsin_id);\r\nmemset((void *)channel->pid_buffer_aligned\r\n, 0x00, PID_TABLE_SIZE);\r\ndma_sync_single_for_device(fei->dev,\r\nchannel->pid_buffer_busaddr,\r\nPID_TABLE_SIZE,\r\nDMA_TO_DEVICE);\r\nchannel->active = 0;\r\n}\r\nif (--fei->global_feed_count == 0) {\r\ndev_dbg(fei->dev, "%s:%d global_feed_count=%d\n"\r\n, __func__, __LINE__, fei->global_feed_count);\r\ndel_timer(&fei->timer);\r\n}\r\nmutex_unlock(&fei->lock);\r\nreturn 0;\r\n}\r\nstatic struct channel_info *find_channel(struct c8sectpfei *fei, int tsin_num)\r\n{\r\nint i;\r\nfor (i = 0; i < C8SECTPFE_MAX_TSIN_CHAN; i++) {\r\nif (!fei->channel_data[i])\r\ncontinue;\r\nif (fei->channel_data[i]->tsin_id == tsin_num)\r\nreturn fei->channel_data[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic void c8sectpfe_getconfig(struct c8sectpfei *fei)\r\n{\r\nstruct c8sectpfe_hw *hw = &fei->hw_stats;\r\nhw->num_ib = readl(fei->io + SYS_CFG_NUM_IB);\r\nhw->num_mib = readl(fei->io + SYS_CFG_NUM_MIB);\r\nhw->num_swts = readl(fei->io + SYS_CFG_NUM_SWTS);\r\nhw->num_tsout = readl(fei->io + SYS_CFG_NUM_TSOUT);\r\nhw->num_ccsc = readl(fei->io + SYS_CFG_NUM_CCSC);\r\nhw->num_ram = readl(fei->io + SYS_CFG_NUM_RAM);\r\nhw->num_tp = readl(fei->io + SYS_CFG_NUM_TP);\r\ndev_info(fei->dev, "C8SECTPFE hw supports the following:\n");\r\ndev_info(fei->dev, "Input Blocks: %d\n", hw->num_ib);\r\ndev_info(fei->dev, "Merged Input Blocks: %d\n", hw->num_mib);\r\ndev_info(fei->dev, "Software Transport Stream Inputs: %d\n"\r\n, hw->num_swts);\r\ndev_info(fei->dev, "Transport Stream Output: %d\n", hw->num_tsout);\r\ndev_info(fei->dev, "Cable Card Converter: %d\n", hw->num_ccsc);\r\ndev_info(fei->dev, "RAMs supported by C8SECTPFE: %d\n", hw->num_ram);\r\ndev_info(fei->dev, "Tango TPs supported by C8SECTPFE: %d\n"\r\n, hw->num_tp);\r\n}\r\nstatic irqreturn_t c8sectpfe_idle_irq_handler(int irq, void *priv)\r\n{\r\nstruct c8sectpfei *fei = priv;\r\nstruct channel_info *chan;\r\nint bit;\r\nunsigned long tmp = readl(fei->io + DMA_IDLE_REQ);\r\nfor_each_set_bit(bit, &tmp, fei->hw_stats.num_ib) {\r\nchan = find_channel(fei, bit);\r\nif (chan)\r\ncomplete(&chan->idle_completion);\r\n}\r\nwritel(0, fei->io + DMA_IDLE_REQ);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void free_input_block(struct c8sectpfei *fei, struct channel_info *tsin)\r\n{\r\nif (!fei || !tsin)\r\nreturn;\r\nif (tsin->back_buffer_busaddr)\r\nif (!dma_mapping_error(fei->dev, tsin->back_buffer_busaddr))\r\ndma_unmap_single(fei->dev, tsin->back_buffer_busaddr,\r\nFEI_BUFFER_SIZE, DMA_BIDIRECTIONAL);\r\nkfree(tsin->back_buffer_start);\r\nif (tsin->pid_buffer_busaddr)\r\nif (!dma_mapping_error(fei->dev, tsin->pid_buffer_busaddr))\r\ndma_unmap_single(fei->dev, tsin->pid_buffer_busaddr,\r\nPID_TABLE_SIZE, DMA_BIDIRECTIONAL);\r\nkfree(tsin->pid_buffer_start);\r\n}\r\nstatic int configure_memdma_and_inputblock(struct c8sectpfei *fei,\r\nstruct channel_info *tsin)\r\n{\r\nint ret;\r\nu32 tmp;\r\nchar tsin_pin_name[MAX_NAME];\r\nif (!fei || !tsin)\r\nreturn -EINVAL;\r\ndev_dbg(fei->dev, "%s:%d Configuring channel=%p tsin=%d\n"\r\n, __func__, __LINE__, tsin, tsin->tsin_id);\r\ninit_completion(&tsin->idle_completion);\r\ntsin->back_buffer_start = kzalloc(FEI_BUFFER_SIZE +\r\nFEI_ALIGNMENT, GFP_KERNEL);\r\nif (!tsin->back_buffer_start) {\r\nret = -ENOMEM;\r\ngoto err_unmap;\r\n}\r\ntsin->back_buffer_aligned = tsin->back_buffer_start\r\n+ FEI_ALIGNMENT;\r\ntsin->back_buffer_aligned = (void *)\r\n(((uintptr_t) tsin->back_buffer_aligned) & ~0x1F);\r\ntsin->back_buffer_busaddr = dma_map_single(fei->dev,\r\n(void *)tsin->back_buffer_aligned,\r\nFEI_BUFFER_SIZE,\r\nDMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(fei->dev, tsin->back_buffer_busaddr)) {\r\ndev_err(fei->dev, "failed to map back_buffer\n");\r\nret = -EFAULT;\r\ngoto err_unmap;\r\n}\r\ntsin->pid_buffer_start = kzalloc(2048, GFP_KERNEL);\r\nif (!tsin->pid_buffer_start) {\r\nret = -ENOMEM;\r\ngoto err_unmap;\r\n}\r\ntsin->pid_buffer_aligned = tsin->pid_buffer_start +\r\nPID_TABLE_SIZE;\r\ntsin->pid_buffer_aligned = (void *)\r\n(((uintptr_t) tsin->pid_buffer_aligned) & ~0x3ff);\r\ntsin->pid_buffer_busaddr = dma_map_single(fei->dev,\r\ntsin->pid_buffer_aligned,\r\nPID_TABLE_SIZE,\r\nDMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(fei->dev, tsin->pid_buffer_busaddr)) {\r\ndev_err(fei->dev, "failed to map pid_bitmap\n");\r\nret = -EFAULT;\r\ngoto err_unmap;\r\n}\r\ndma_sync_single_for_device(fei->dev,\r\ntsin->pid_buffer_busaddr,\r\nPID_TABLE_SIZE,\r\nDMA_TO_DEVICE);\r\nsnprintf(tsin_pin_name, MAX_NAME, "tsin%d-%s", tsin->tsin_id,\r\n(tsin->serial_not_parallel ? "serial" : "parallel"));\r\ntsin->pstate = pinctrl_lookup_state(fei->pinctrl, tsin_pin_name);\r\nif (IS_ERR(tsin->pstate)) {\r\ndev_err(fei->dev, "%s: pinctrl_lookup_state couldn't find %s state\n"\r\n, __func__, tsin_pin_name);\r\nret = PTR_ERR(tsin->pstate);\r\ngoto err_unmap;\r\n}\r\nret = pinctrl_select_state(fei->pinctrl, tsin->pstate);\r\nif (ret) {\r\ndev_err(fei->dev, "%s: pinctrl_select_state failed\n"\r\n, __func__);\r\ngoto err_unmap;\r\n}\r\ntmp = readl(fei->io + SYS_INPUT_CLKEN);\r\ntmp |= BIT(tsin->tsin_id);\r\nwritel(tmp, fei->io + SYS_INPUT_CLKEN);\r\nif (tsin->serial_not_parallel)\r\ntmp |= C8SECTPFE_SERIAL_NOT_PARALLEL;\r\nif (tsin->invert_ts_clk)\r\ntmp |= C8SECTPFE_INVERT_TSCLK;\r\nif (tsin->async_not_sync)\r\ntmp |= C8SECTPFE_ASYNC_NOT_SYNC;\r\ntmp |= C8SECTPFE_ALIGN_BYTE_SOP | C8SECTPFE_BYTE_ENDIANNESS_MSB;\r\nwritel(tmp, fei->io + C8SECTPFE_IB_IP_FMT_CFG(tsin->tsin_id));\r\nwritel(C8SECTPFE_SYNC(0x9) |\r\nC8SECTPFE_DROP(0x9) |\r\nC8SECTPFE_TOKEN(0x47),\r\nfei->io + C8SECTPFE_IB_SYNCLCKDRP_CFG(tsin->tsin_id));\r\nwritel(TS_PKT_SIZE, fei->io + C8SECTPFE_IB_PKT_LEN(tsin->tsin_id));\r\ntsin->fifo = (tsin->tsin_id * FIFO_LEN);\r\nwritel(tsin->fifo, fei->io + C8SECTPFE_IB_BUFF_STRT(tsin->tsin_id));\r\nwritel(tsin->fifo + FIFO_LEN - 1,\r\nfei->io + C8SECTPFE_IB_BUFF_END(tsin->tsin_id));\r\nwritel(tsin->fifo, fei->io + C8SECTPFE_IB_READ_PNT(tsin->tsin_id));\r\nwritel(tsin->fifo, fei->io + C8SECTPFE_IB_WRT_PNT(tsin->tsin_id));\r\nwritel(tsin->pid_buffer_busaddr,\r\nfei->io + PIDF_BASE(tsin->tsin_id));\r\ndev_dbg(fei->dev, "chan=%d PIDF_BASE=0x%x pid_bus_addr=%pad\n",\r\ntsin->tsin_id, readl(fei->io + PIDF_BASE(tsin->tsin_id)),\r\n&tsin->pid_buffer_busaddr);\r\ntmp = (C8SECTPFE_PID_ENABLE | C8SECTPFE_PID_NUMBITS(13)\r\n| C8SECTPFE_PID_OFFSET(40));\r\nwritel(tmp, fei->io + C8SECTPFE_IB_PID_SET(tsin->tsin_id));\r\ndev_dbg(fei->dev, "chan=%d setting wp: %d, rp: %d, buf: %d-%d\n",\r\ntsin->tsin_id,\r\nreadl(fei->io + C8SECTPFE_IB_WRT_PNT(tsin->tsin_id)),\r\nreadl(fei->io + C8SECTPFE_IB_READ_PNT(tsin->tsin_id)),\r\nreadl(fei->io + C8SECTPFE_IB_BUFF_STRT(tsin->tsin_id)),\r\nreadl(fei->io + C8SECTPFE_IB_BUFF_END(tsin->tsin_id)));\r\ntsin->irec = fei->io + DMA_MEMDMA_OFFSET + DMA_DMEM_OFFSET +\r\nreadl(fei->io + DMA_PTRREC_BASE);\r\ntsin->irec += (tsin->tsin_id * DMA_PRDS_SIZE);\r\nwritel(tsin->fifo, tsin->irec + DMA_PRDS_MEMBASE);\r\nwritel(tsin->fifo + FIFO_LEN - 1, tsin->irec + DMA_PRDS_MEMTOP);\r\nwritel((188 + 7)&~7, tsin->irec + DMA_PRDS_PKTSIZE);\r\nwritel(0x1, tsin->irec + DMA_PRDS_TPENABLE);\r\nwritel(tsin->back_buffer_busaddr, tsin->irec + DMA_PRDS_BUSBASE_TP(0));\r\ntmp = tsin->back_buffer_busaddr + FEI_BUFFER_SIZE - 1;\r\nwritel(tmp, tsin->irec + DMA_PRDS_BUSTOP_TP(0));\r\nwritel(tsin->back_buffer_busaddr, tsin->irec + DMA_PRDS_BUSWP_TP(0));\r\nwritel(tsin->back_buffer_busaddr, tsin->irec + DMA_PRDS_BUSRP_TP(0));\r\ntasklet_init(&tsin->tsklet, channel_swdemux_tsklet,\r\n(unsigned long) tsin);\r\nreturn 0;\r\nerr_unmap:\r\nfree_input_block(fei, tsin);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t c8sectpfe_error_irq_handler(int irq, void *priv)\r\n{\r\nstruct c8sectpfei *fei = priv;\r\ndev_err(fei->dev, "%s: error handling not yet implemented\n"\r\n, __func__);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int c8sectpfe_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *child, *np = dev->of_node;\r\nstruct c8sectpfei *fei;\r\nstruct resource *res;\r\nint ret, index = 0;\r\nstruct channel_info *tsin;\r\nfei = devm_kzalloc(dev, sizeof(struct c8sectpfei), GFP_KERNEL);\r\nif (!fei)\r\nreturn -ENOMEM;\r\nfei->dev = dev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "c8sectpfe");\r\nfei->io = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(fei->io))\r\nreturn PTR_ERR(fei->io);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"c8sectpfe-ram");\r\nfei->sram = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(fei->sram))\r\nreturn PTR_ERR(fei->sram);\r\nfei->sram_size = res->end - res->start;\r\nfei->idle_irq = platform_get_irq_byname(pdev, "c8sectpfe-idle-irq");\r\nif (fei->idle_irq < 0) {\r\ndev_err(dev, "Can't get c8sectpfe-idle-irq\n");\r\nreturn fei->idle_irq;\r\n}\r\nfei->error_irq = platform_get_irq_byname(pdev, "c8sectpfe-error-irq");\r\nif (fei->error_irq < 0) {\r\ndev_err(dev, "Can't get c8sectpfe-error-irq\n");\r\nreturn fei->error_irq;\r\n}\r\nplatform_set_drvdata(pdev, fei);\r\nfei->c8sectpfeclk = devm_clk_get(dev, "c8sectpfe");\r\nif (IS_ERR(fei->c8sectpfeclk)) {\r\ndev_err(dev, "c8sectpfe clk not found\n");\r\nreturn PTR_ERR(fei->c8sectpfeclk);\r\n}\r\nret = clk_prepare_enable(fei->c8sectpfeclk);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable c8sectpfe clock\n");\r\nreturn ret;\r\n}\r\nwritel(0, fei->io + SYS_INPUT_CLKEN);\r\nwritel(MEMDMAENABLE, fei->io + SYS_OTHER_CLKEN);\r\nmemset_io(fei->sram, 0x0, fei->sram_size);\r\nc8sectpfe_getconfig(fei);\r\nret = devm_request_irq(dev, fei->idle_irq, c8sectpfe_idle_irq_handler,\r\n0, "c8sectpfe-idle-irq", fei);\r\nif (ret) {\r\ndev_err(dev, "Can't register c8sectpfe-idle-irq IRQ.\n");\r\ngoto err_clk_disable;\r\n}\r\nret = devm_request_irq(dev, fei->error_irq,\r\nc8sectpfe_error_irq_handler, 0,\r\n"c8sectpfe-error-irq", fei);\r\nif (ret) {\r\ndev_err(dev, "Can't register c8sectpfe-error-irq IRQ.\n");\r\ngoto err_clk_disable;\r\n}\r\nfei->tsin_count = of_get_child_count(np);\r\nif (fei->tsin_count > C8SECTPFE_MAX_TSIN_CHAN ||\r\nfei->tsin_count > fei->hw_stats.num_ib) {\r\ndev_err(dev, "More tsin declared than exist on SoC!\n");\r\nret = -EINVAL;\r\ngoto err_clk_disable;\r\n}\r\nfei->pinctrl = devm_pinctrl_get(dev);\r\nif (IS_ERR(fei->pinctrl)) {\r\ndev_err(dev, "Error getting tsin pins\n");\r\nret = PTR_ERR(fei->pinctrl);\r\ngoto err_clk_disable;\r\n}\r\nfor_each_child_of_node(np, child) {\r\nstruct device_node *i2c_bus;\r\nfei->channel_data[index] = devm_kzalloc(dev,\r\nsizeof(struct channel_info),\r\nGFP_KERNEL);\r\nif (!fei->channel_data[index]) {\r\nret = -ENOMEM;\r\ngoto err_clk_disable;\r\n}\r\ntsin = fei->channel_data[index];\r\ntsin->fei = fei;\r\nret = of_property_read_u32(child, "tsin-num", &tsin->tsin_id);\r\nif (ret) {\r\ndev_err(&pdev->dev, "No tsin_num found\n");\r\ngoto err_clk_disable;\r\n}\r\nif (tsin->tsin_id > fei->hw_stats.num_ib) {\r\ndev_err(&pdev->dev,\r\n"tsin-num %d specified greater than number\n\tof input block hw in SoC! (%d)",\r\ntsin->tsin_id, fei->hw_stats.num_ib);\r\nret = -EINVAL;\r\ngoto err_clk_disable;\r\n}\r\ntsin->invert_ts_clk = of_property_read_bool(child,\r\n"invert-ts-clk");\r\ntsin->serial_not_parallel = of_property_read_bool(child,\r\n"serial-not-parallel");\r\ntsin->async_not_sync = of_property_read_bool(child,\r\n"async-not-sync");\r\nret = of_property_read_u32(child, "dvb-card",\r\n&tsin->dvb_card);\r\nif (ret) {\r\ndev_err(&pdev->dev, "No dvb-card found\n");\r\ngoto err_clk_disable;\r\n}\r\ni2c_bus = of_parse_phandle(child, "i2c-bus", 0);\r\nif (!i2c_bus) {\r\ndev_err(&pdev->dev, "No i2c-bus found\n");\r\nret = -ENODEV;\r\ngoto err_clk_disable;\r\n}\r\ntsin->i2c_adapter =\r\nof_find_i2c_adapter_by_node(i2c_bus);\r\nif (!tsin->i2c_adapter) {\r\ndev_err(&pdev->dev, "No i2c adapter found\n");\r\nof_node_put(i2c_bus);\r\nret = -ENODEV;\r\ngoto err_clk_disable;\r\n}\r\nof_node_put(i2c_bus);\r\ntsin->rst_gpio = of_get_named_gpio(child, "reset-gpios", 0);\r\nret = gpio_is_valid(tsin->rst_gpio);\r\nif (!ret) {\r\ndev_err(dev,\r\n"reset gpio for tsin%d not valid (gpio=%d)\n",\r\ntsin->tsin_id, tsin->rst_gpio);\r\ngoto err_clk_disable;\r\n}\r\nret = devm_gpio_request_one(dev, tsin->rst_gpio,\r\nGPIOF_OUT_INIT_LOW, "NIM reset");\r\nif (ret && ret != -EBUSY) {\r\ndev_err(dev, "Can't request tsin%d reset gpio\n"\r\n, fei->channel_data[index]->tsin_id);\r\ngoto err_clk_disable;\r\n}\r\nif (!ret) {\r\ngpio_direction_output(tsin->rst_gpio, 0);\r\nusleep_range(3500, 5000);\r\ngpio_direction_output(tsin->rst_gpio, 1);\r\nusleep_range(3000, 5000);\r\n}\r\ntsin->demux_mapping = index;\r\ndev_dbg(fei->dev,\r\n"channel=%p n=%d tsin_num=%d, invert-ts-clk=%d\n\tserial-not-parallel=%d pkt-clk-valid=%d dvb-card=%d\n",\r\nfei->channel_data[index], index,\r\ntsin->tsin_id, tsin->invert_ts_clk,\r\ntsin->serial_not_parallel, tsin->async_not_sync,\r\ntsin->dvb_card);\r\nindex++;\r\n}\r\nsetup_timer(&fei->timer, c8sectpfe_timer_interrupt,\r\n(unsigned long)fei);\r\nmutex_init(&fei->lock);\r\nret = c8sectpfe_tuner_register_frontend(&fei->c8sectpfe[0],\r\n(void *)fei,\r\nc8sectpfe_start_feed,\r\nc8sectpfe_stop_feed);\r\nif (ret) {\r\ndev_err(dev, "c8sectpfe_tuner_register_frontend failed (%d)\n",\r\nret);\r\ngoto err_clk_disable;\r\n}\r\nc8sectpfe_debugfs_init(fei);\r\nreturn 0;\r\nerr_clk_disable:\r\nclk_disable_unprepare(fei->c8sectpfeclk);\r\nreturn ret;\r\n}\r\nstatic int c8sectpfe_remove(struct platform_device *pdev)\r\n{\r\nstruct c8sectpfei *fei = platform_get_drvdata(pdev);\r\nstruct channel_info *channel;\r\nint i;\r\nwait_for_completion(&fei->fw_ack);\r\nc8sectpfe_tuner_unregister_frontend(fei->c8sectpfe[0], fei);\r\nfor (i = 0; i < fei->tsin_count; i++) {\r\nchannel = fei->channel_data[i];\r\nfree_input_block(fei, channel);\r\n}\r\nc8sectpfe_debugfs_exit(fei);\r\ndev_info(fei->dev, "Stopping memdma SLIM core\n");\r\nif (readl(fei->io + DMA_CPU_RUN))\r\nwritel(0x0, fei->io + DMA_CPU_RUN);\r\nif (readl(fei->io + SYS_INPUT_CLKEN))\r\nwritel(0, fei->io + SYS_INPUT_CLKEN);\r\nif (readl(fei->io + SYS_OTHER_CLKEN))\r\nwritel(0, fei->io + SYS_OTHER_CLKEN);\r\nif (fei->c8sectpfeclk)\r\nclk_disable_unprepare(fei->c8sectpfeclk);\r\nreturn 0;\r\n}\r\nstatic int configure_channels(struct c8sectpfei *fei)\r\n{\r\nint index = 0, ret;\r\nstruct channel_info *tsin;\r\nstruct device_node *child, *np = fei->dev->of_node;\r\nfor_each_child_of_node(np, child) {\r\ntsin = fei->channel_data[index];\r\nret = configure_memdma_and_inputblock(fei,\r\nfei->channel_data[index]);\r\nif (ret) {\r\ndev_err(fei->dev,\r\n"configure_memdma_and_inputblock failed\n");\r\ngoto err_unmap;\r\n}\r\nindex++;\r\n}\r\nreturn 0;\r\nerr_unmap:\r\nfor (index = 0; index < fei->tsin_count; index++) {\r\ntsin = fei->channel_data[index];\r\nfree_input_block(fei, tsin);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nc8sectpfe_elf_sanity_check(struct c8sectpfei *fei, const struct firmware *fw)\r\n{\r\nstruct elf32_hdr *ehdr;\r\nchar class;\r\nif (!fw) {\r\ndev_err(fei->dev, "failed to load %s\n", FIRMWARE_MEMDMA);\r\nreturn -EINVAL;\r\n}\r\nif (fw->size < sizeof(struct elf32_hdr)) {\r\ndev_err(fei->dev, "Image is too small\n");\r\nreturn -EINVAL;\r\n}\r\nehdr = (struct elf32_hdr *)fw->data;\r\nclass = ehdr->e_ident[EI_CLASS];\r\nif (class != ELFCLASS32) {\r\ndev_err(fei->dev, "Unsupported class: %d\n", class);\r\nreturn -EINVAL;\r\n}\r\nif (ehdr->e_ident[EI_DATA] != ELFDATA2LSB) {\r\ndev_err(fei->dev, "Unsupported firmware endianness\n");\r\nreturn -EINVAL;\r\n}\r\nif (fw->size < ehdr->e_shoff + sizeof(struct elf32_shdr)) {\r\ndev_err(fei->dev, "Image is too small\n");\r\nreturn -EINVAL;\r\n}\r\nif (memcmp(ehdr->e_ident, ELFMAG, SELFMAG)) {\r\ndev_err(fei->dev, "Image is corrupted (bad magic)\n");\r\nreturn -EINVAL;\r\n}\r\nehdr = (Elf32_Ehdr *)fw->data;\r\nif (ehdr->e_ident[EI_MAG0] != ELFMAG0 ||\r\nehdr->e_ident[EI_MAG1] != ELFMAG1 ||\r\nehdr->e_ident[EI_MAG2] != ELFMAG2 ||\r\nehdr->e_ident[EI_MAG3] != ELFMAG3) {\r\ndev_err(fei->dev, "Invalid ELF magic\n");\r\nreturn -EINVAL;\r\n}\r\nif (ehdr->e_type != ET_EXEC) {\r\ndev_err(fei->dev, "Unsupported ELF header type\n");\r\nreturn -EINVAL;\r\n}\r\nif (ehdr->e_phoff > fw->size) {\r\ndev_err(fei->dev, "Firmware size is too small\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void load_imem_segment(struct c8sectpfei *fei, Elf32_Phdr *phdr,\r\nconst struct firmware *fw, u8 __iomem *dest,\r\nint seg_num)\r\n{\r\nconst u8 *imem_src = fw->data + phdr->p_offset;\r\nint i;\r\ndev_dbg(fei->dev,\r\n"Loading IMEM segment %d 0x%08x\n\t (0x%x bytes) -> 0x%p (0x%x bytes)\n",\r\nseg_num,\r\nphdr->p_paddr, phdr->p_filesz,\r\ndest, phdr->p_memsz + phdr->p_memsz / 3);\r\nfor (i = 0; i < phdr->p_filesz; i++) {\r\nwriteb(readb((void __iomem *)imem_src), (void __iomem *)dest);\r\nif (i % 3 == 2) {\r\ndest++;\r\nwriteb(0x00, (void __iomem *)dest);\r\n}\r\ndest++;\r\nimem_src++;\r\n}\r\n}\r\nstatic void load_dmem_segment(struct c8sectpfei *fei, Elf32_Phdr *phdr,\r\nconst struct firmware *fw, u8 __iomem *dst, int seg_num)\r\n{\r\ndev_dbg(fei->dev,\r\n"Loading DMEM segment %d 0x%08x\n\t(0x%x bytes) -> 0x%p (0x%x bytes)\n",\r\nseg_num, phdr->p_paddr, phdr->p_filesz,\r\ndst, phdr->p_memsz);\r\nmemcpy((void __force *)dst, (void *)fw->data + phdr->p_offset,\r\nphdr->p_filesz);\r\nmemset((void __force *)dst + phdr->p_filesz, 0,\r\nphdr->p_memsz - phdr->p_filesz);\r\n}\r\nstatic int load_slim_core_fw(const struct firmware *fw, struct c8sectpfei *fei)\r\n{\r\nElf32_Ehdr *ehdr;\r\nElf32_Phdr *phdr;\r\nu8 __iomem *dst;\r\nint err = 0, i;\r\nif (!fw || !fei)\r\nreturn -EINVAL;\r\nehdr = (Elf32_Ehdr *)fw->data;\r\nphdr = (Elf32_Phdr *)(fw->data + ehdr->e_phoff);\r\nfor (i = 0; i < ehdr->e_phnum; i++, phdr++) {\r\nif (phdr->p_type != PT_LOAD)\r\ncontinue;\r\nif (phdr->p_offset + phdr->p_filesz > fw->size) {\r\ndev_err(fei->dev,\r\n"Segment %d is outside of firmware file\n", i);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (phdr->p_flags & PF_X) {\r\ndst = (u8 __iomem *) fei->io + DMA_MEMDMA_IMEM;\r\ndst += (phdr->p_paddr & 0xFFFFF) * sizeof(unsigned int);\r\nload_imem_segment(fei, phdr, fw, dst, i);\r\n} else {\r\ndst = (u8 __iomem *) fei->io + DMA_MEMDMA_DMEM;\r\ndst += (phdr->p_paddr & 0xFFFFF) * sizeof(unsigned int);\r\nload_dmem_segment(fei, phdr, fw, dst, i);\r\n}\r\n}\r\nrelease_firmware(fw);\r\nreturn err;\r\n}\r\nstatic int load_c8sectpfe_fw(struct c8sectpfei *fei)\r\n{\r\nconst struct firmware *fw;\r\nint err;\r\ndev_info(fei->dev, "Loading firmware: %s\n", FIRMWARE_MEMDMA);\r\nerr = request_firmware(&fw, FIRMWARE_MEMDMA, fei->dev);\r\nif (err)\r\nreturn err;\r\nerr = c8sectpfe_elf_sanity_check(fei, fw);\r\nif (err) {\r\ndev_err(fei->dev, "c8sectpfe_elf_sanity_check failed err=(%d)\n"\r\n, err);\r\nrelease_firmware(fw);\r\nreturn err;\r\n}\r\nerr = load_slim_core_fw(fw, fei);\r\nif (err) {\r\ndev_err(fei->dev, "load_slim_core_fw failed err=(%d)\n", err);\r\nreturn err;\r\n}\r\nerr = configure_channels(fei);\r\nif (err) {\r\ndev_err(fei->dev, "configure_channels failed err=(%d)\n", err);\r\nreturn err;\r\n}\r\nwritel(0x1, fei->io + DMA_PER_STBUS_SYNC);\r\ndev_info(fei->dev, "Boot the memdma SLIM core\n");\r\nwritel(0x1, fei->io + DMA_CPU_RUN);\r\natomic_set(&fei->fw_loaded, 1);\r\nreturn 0;\r\n}
