static u32 nfp_bar_maptype(struct nfp_bar *bar)\r\n{\r\nreturn NFP_PCIE_BAR_PCIE2CPP_MapType_of(bar->barcfg);\r\n}\r\nstatic resource_size_t nfp_bar_resource_len(struct nfp_bar *bar)\r\n{\r\nreturn pci_resource_len(bar->nfp->pdev, (bar->index / 8) * 2) / 8;\r\n}\r\nstatic resource_size_t nfp_bar_resource_start(struct nfp_bar *bar)\r\n{\r\nreturn pci_resource_start(bar->nfp->pdev, (bar->index / 8) * 2)\r\n+ nfp_bar_resource_len(bar) * (bar->index & 7);\r\n}\r\nstatic int\r\ncompute_bar(const struct nfp6000_pcie *nfp, const struct nfp_bar *bar,\r\nu32 *bar_config, u64 *bar_base,\r\nint tgt, int act, int tok, u64 offset, size_t size, int width)\r\n{\r\nint bitsize;\r\nu32 newcfg;\r\nif (tgt >= NFP_CPP_NUM_TARGETS)\r\nreturn -EINVAL;\r\nswitch (width) {\r\ncase 8:\r\nnewcfg = NFP_PCIE_BAR_PCIE2CPP_LengthSelect(\r\nNFP_PCIE_BAR_PCIE2CPP_LengthSelect_64BIT);\r\nbreak;\r\ncase 4:\r\nnewcfg = NFP_PCIE_BAR_PCIE2CPP_LengthSelect(\r\nNFP_PCIE_BAR_PCIE2CPP_LengthSelect_32BIT);\r\nbreak;\r\ncase 0:\r\nnewcfg = NFP_PCIE_BAR_PCIE2CPP_LengthSelect(\r\nNFP_PCIE_BAR_PCIE2CPP_LengthSelect_0BYTE);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (act != NFP_CPP_ACTION_RW && act != 0) {\r\nu64 mask = ~(NFP_PCIE_P2C_FIXED_SIZE(bar) - 1);\r\nnewcfg |= NFP_PCIE_BAR_PCIE2CPP_MapType(\r\nNFP_PCIE_BAR_PCIE2CPP_MapType_FIXED);\r\nnewcfg |= NFP_PCIE_BAR_PCIE2CPP_Target_BaseAddress(tgt);\r\nnewcfg |= NFP_PCIE_BAR_PCIE2CPP_Action_BaseAddress(act);\r\nnewcfg |= NFP_PCIE_BAR_PCIE2CPP_Token_BaseAddress(tok);\r\nif ((offset & mask) != ((offset + size - 1) & mask))\r\nreturn -EINVAL;\r\noffset &= mask;\r\nbitsize = 40 - 16;\r\n} else {\r\nu64 mask = ~(NFP_PCIE_P2C_BULK_SIZE(bar) - 1);\r\nnewcfg |= NFP_PCIE_BAR_PCIE2CPP_MapType(\r\nNFP_PCIE_BAR_PCIE2CPP_MapType_BULK);\r\nnewcfg |= NFP_PCIE_BAR_PCIE2CPP_Target_BaseAddress(tgt);\r\nnewcfg |= NFP_PCIE_BAR_PCIE2CPP_Token_BaseAddress(tok);\r\nif ((offset & mask) != ((offset + size - 1) & mask))\r\nreturn -EINVAL;\r\noffset &= mask;\r\nbitsize = 40 - 21;\r\n}\r\nif (bar->bitsize < bitsize)\r\nreturn -EINVAL;\r\nnewcfg |= offset >> bitsize;\r\nif (bar_base)\r\n*bar_base = offset;\r\nif (bar_config)\r\n*bar_config = newcfg;\r\nreturn 0;\r\n}\r\nstatic int\r\nnfp6000_bar_write(struct nfp6000_pcie *nfp, struct nfp_bar *bar, u32 newcfg)\r\n{\r\nint base, slot;\r\nint xbar;\r\nbase = bar->index >> 3;\r\nslot = bar->index & 7;\r\nif (nfp->iomem.csr) {\r\nxbar = NFP_PCIE_CPP_BAR_PCIETOCPPEXPANSIONBAR(base, slot);\r\nwritel(newcfg, nfp->iomem.csr + xbar);\r\nreadl(nfp->iomem.csr + xbar);\r\n} else {\r\nxbar = NFP_PCIE_CFG_BAR_PCIETOCPPEXPANSIONBAR(base, slot);\r\npci_write_config_dword(nfp->pdev, xbar, newcfg);\r\n}\r\nbar->barcfg = newcfg;\r\nreturn 0;\r\n}\r\nstatic int\r\nreconfigure_bar(struct nfp6000_pcie *nfp, struct nfp_bar *bar,\r\nint tgt, int act, int tok, u64 offset, size_t size, int width)\r\n{\r\nu64 newbase;\r\nu32 newcfg;\r\nint err;\r\nerr = compute_bar(nfp, bar, &newcfg, &newbase,\r\ntgt, act, tok, offset, size, width);\r\nif (err)\r\nreturn err;\r\nbar->base = newbase;\r\nreturn nfp6000_bar_write(nfp, bar, newcfg);\r\n}\r\nstatic int matching_bar(struct nfp_bar *bar, u32 tgt, u32 act, u32 tok,\r\nu64 offset, size_t size, int width)\r\n{\r\nint bartgt, baract, bartok;\r\nint barwidth;\r\nu32 maptype;\r\nmaptype = NFP_PCIE_BAR_PCIE2CPP_MapType_of(bar->barcfg);\r\nbartgt = NFP_PCIE_BAR_PCIE2CPP_Target_BaseAddress_of(bar->barcfg);\r\nbartok = NFP_PCIE_BAR_PCIE2CPP_Token_BaseAddress_of(bar->barcfg);\r\nbaract = NFP_PCIE_BAR_PCIE2CPP_Action_BaseAddress_of(bar->barcfg);\r\nbarwidth = NFP_PCIE_BAR_PCIE2CPP_LengthSelect_of(bar->barcfg);\r\nswitch (barwidth) {\r\ncase NFP_PCIE_BAR_PCIE2CPP_LengthSelect_32BIT:\r\nbarwidth = 4;\r\nbreak;\r\ncase NFP_PCIE_BAR_PCIE2CPP_LengthSelect_64BIT:\r\nbarwidth = 8;\r\nbreak;\r\ncase NFP_PCIE_BAR_PCIE2CPP_LengthSelect_0BYTE:\r\nbarwidth = 0;\r\nbreak;\r\ndefault:\r\nbarwidth = -1;\r\nbreak;\r\n}\r\nswitch (maptype) {\r\ncase NFP_PCIE_BAR_PCIE2CPP_MapType_TARGET:\r\nbartok = -1;\r\ncase NFP_PCIE_BAR_PCIE2CPP_MapType_BULK:\r\nbaract = NFP_CPP_ACTION_RW;\r\nif (act == 0)\r\nact = NFP_CPP_ACTION_RW;\r\ncase NFP_PCIE_BAR_PCIE2CPP_MapType_FIXED:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (barwidth != width)\r\nreturn 0;\r\nif ((bartgt < 0 || bartgt == tgt) &&\r\n(bartok < 0 || bartok == tok) &&\r\n(baract == act) &&\r\nbar->base <= offset &&\r\n(bar->base + (1 << bar->bitsize)) >= (offset + size))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nfind_matching_bar(struct nfp6000_pcie *nfp,\r\nu32 tgt, u32 act, u32 tok, u64 offset, size_t size, int width)\r\n{\r\nint n;\r\nfor (n = 0; n < nfp->bars; n++) {\r\nstruct nfp_bar *bar = &nfp->bar[n];\r\nif (matching_bar(bar, tgt, act, tok, offset, size, width))\r\nreturn n;\r\n}\r\nreturn -1;\r\n}\r\nstatic int\r\nfind_unused_bar_noblock(const struct nfp6000_pcie *nfp,\r\nint tgt, int act, int tok,\r\nu64 offset, size_t size, int width)\r\n{\r\nint n, busy = 0;\r\nfor (n = 0; n < nfp->bars; n++) {\r\nconst struct nfp_bar *bar = &nfp->bar[n];\r\nint err;\r\nif (!bar->bitsize)\r\ncontinue;\r\nerr = compute_bar(nfp, bar, NULL, NULL,\r\ntgt, act, tok, offset, size, width);\r\nif (err)\r\ncontinue;\r\nif (!atomic_read(&bar->refcnt))\r\nreturn n;\r\nbusy++;\r\n}\r\nif (WARN(!busy, "No suitable BAR found for request tgt:0x%x act:0x%x tok:0x%x off:0x%llx size:%zd width:%d\n",\r\ntgt, act, tok, offset, size, width))\r\nreturn -EINVAL;\r\nreturn -EAGAIN;\r\n}\r\nstatic int\r\nfind_unused_bar_and_lock(struct nfp6000_pcie *nfp,\r\nint tgt, int act, int tok,\r\nu64 offset, size_t size, int width)\r\n{\r\nunsigned long flags;\r\nint n;\r\nspin_lock_irqsave(&nfp->bar_lock, flags);\r\nn = find_unused_bar_noblock(nfp, tgt, act, tok, offset, size, width);\r\nif (n < 0)\r\nspin_unlock_irqrestore(&nfp->bar_lock, flags);\r\nelse\r\n__release(&nfp->bar_lock);\r\nreturn n;\r\n}\r\nstatic void nfp_bar_get(struct nfp6000_pcie *nfp, struct nfp_bar *bar)\r\n{\r\natomic_inc(&bar->refcnt);\r\n}\r\nstatic void nfp_bar_put(struct nfp6000_pcie *nfp, struct nfp_bar *bar)\r\n{\r\nif (atomic_dec_and_test(&bar->refcnt))\r\nwake_up_interruptible(&nfp->bar_waiters);\r\n}\r\nstatic int\r\nnfp_wait_for_bar(struct nfp6000_pcie *nfp, int *barnum,\r\nu32 tgt, u32 act, u32 tok, u64 offset, size_t size, int width)\r\n{\r\nreturn wait_event_interruptible(nfp->bar_waiters,\r\n(*barnum = find_unused_bar_and_lock(nfp, tgt, act, tok,\r\noffset, size, width))\r\n!= -EAGAIN);\r\n}\r\nstatic int\r\nnfp_alloc_bar(struct nfp6000_pcie *nfp,\r\nu32 tgt, u32 act, u32 tok,\r\nu64 offset, size_t size, int width, int nonblocking)\r\n{\r\nunsigned long irqflags;\r\nint barnum, retval;\r\nif (size > (1 << 24))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&nfp->bar_lock, irqflags);\r\nbarnum = find_matching_bar(nfp, tgt, act, tok, offset, size, width);\r\nif (barnum >= 0) {\r\nnfp_bar_get(nfp, &nfp->bar[barnum]);\r\nspin_unlock_irqrestore(&nfp->bar_lock, irqflags);\r\nreturn barnum;\r\n}\r\nbarnum = find_unused_bar_noblock(nfp, tgt, act, tok,\r\noffset, size, width);\r\nif (barnum < 0) {\r\nif (nonblocking)\r\ngoto err_nobar;\r\nspin_unlock_irqrestore(&nfp->bar_lock, irqflags);\r\nretval = nfp_wait_for_bar(nfp, &barnum, tgt, act, tok,\r\noffset, size, width);\r\nif (retval)\r\nreturn retval;\r\n__acquire(&nfp->bar_lock);\r\n}\r\nnfp_bar_get(nfp, &nfp->bar[barnum]);\r\nretval = reconfigure_bar(nfp, &nfp->bar[barnum],\r\ntgt, act, tok, offset, size, width);\r\nif (retval < 0) {\r\nnfp_bar_put(nfp, &nfp->bar[barnum]);\r\nbarnum = retval;\r\n}\r\nerr_nobar:\r\nspin_unlock_irqrestore(&nfp->bar_lock, irqflags);\r\nreturn barnum;\r\n}\r\nstatic int bar_cmp(const void *aptr, const void *bptr)\r\n{\r\nconst struct nfp_bar *a = aptr, *b = bptr;\r\nif (a->bitsize == b->bitsize)\r\nreturn a->index - b->index;\r\nelse\r\nreturn a->bitsize - b->bitsize;\r\n}\r\nstatic int enable_bars(struct nfp6000_pcie *nfp, u16 interface)\r\n{\r\nconst u32 barcfg_msix_general =\r\nNFP_PCIE_BAR_PCIE2CPP_MapType(\r\nNFP_PCIE_BAR_PCIE2CPP_MapType_GENERAL) |\r\nNFP_PCIE_BAR_PCIE2CPP_LengthSelect_32BIT;\r\nconst u32 barcfg_msix_xpb =\r\nNFP_PCIE_BAR_PCIE2CPP_MapType(\r\nNFP_PCIE_BAR_PCIE2CPP_MapType_BULK) |\r\nNFP_PCIE_BAR_PCIE2CPP_LengthSelect_32BIT |\r\nNFP_PCIE_BAR_PCIE2CPP_Target_BaseAddress(\r\nNFP_CPP_TARGET_ISLAND_XPB);\r\nconst u32 barcfg_explicit[4] = {\r\nNFP_PCIE_BAR_PCIE2CPP_MapType(\r\nNFP_PCIE_BAR_PCIE2CPP_MapType_EXPLICIT0),\r\nNFP_PCIE_BAR_PCIE2CPP_MapType(\r\nNFP_PCIE_BAR_PCIE2CPP_MapType_EXPLICIT1),\r\nNFP_PCIE_BAR_PCIE2CPP_MapType(\r\nNFP_PCIE_BAR_PCIE2CPP_MapType_EXPLICIT2),\r\nNFP_PCIE_BAR_PCIE2CPP_MapType(\r\nNFP_PCIE_BAR_PCIE2CPP_MapType_EXPLICIT3),\r\n};\r\nchar status_msg[196] = {};\r\nstruct nfp_bar *bar;\r\nint i, bars_free;\r\nint expl_groups;\r\nchar *msg, *end;\r\nmsg = status_msg +\r\nsnprintf(status_msg, sizeof(status_msg) - 1, "RESERVED BARs: ");\r\nend = status_msg + sizeof(status_msg) - 1;\r\nbar = &nfp->bar[0];\r\nfor (i = 0; i < ARRAY_SIZE(nfp->bar); i++, bar++) {\r\nstruct resource *res;\r\nres = &nfp->pdev->resource[(i >> 3) * 2];\r\nif (!(resource_type(res) & IORESOURCE_MEM)) {\r\nbar--;\r\ncontinue;\r\n}\r\nbar->resource = res;\r\nbar->barcfg = 0;\r\nbar->nfp = nfp;\r\nbar->index = i;\r\nbar->mask = nfp_bar_resource_len(bar) - 1;\r\nbar->bitsize = fls(bar->mask);\r\nbar->base = 0;\r\nbar->iomem = NULL;\r\n}\r\nnfp->bars = bar - &nfp->bar[0];\r\nif (nfp->bars < 8) {\r\ndev_err(nfp->dev, "No usable BARs found!\n");\r\nreturn -EINVAL;\r\n}\r\nbars_free = nfp->bars;\r\nmutex_init(&nfp->expl.mutex);\r\nnfp->expl.master_id = ((NFP_CPP_INTERFACE_UNIT_of(interface) & 3) + 4)\r\n<< 4;\r\nnfp->expl.signal_ref = 0x10;\r\nbar = &nfp->bar[0];\r\nif (nfp_bar_resource_len(bar) >= NFP_PCI_MIN_MAP_SIZE)\r\nbar->iomem = ioremap_nocache(nfp_bar_resource_start(bar),\r\nnfp_bar_resource_len(bar));\r\nif (bar->iomem) {\r\nmsg += snprintf(msg, end - msg, "0.0: General/MSI-X SRAM, ");\r\natomic_inc(&bar->refcnt);\r\nbars_free--;\r\nnfp6000_bar_write(nfp, bar, barcfg_msix_general);\r\nnfp->expl.data = bar->iomem + NFP_PCIE_SRAM + 0x1000;\r\nif (nfp->pdev->device == PCI_DEVICE_ID_NETRONOME_NFP4000 ||\r\nnfp->pdev->device == PCI_DEVICE_ID_NETRONOME_NFP6000) {\r\nnfp->iomem.csr = bar->iomem + NFP_PCIE_BAR(0);\r\n} else {\r\nint pf = nfp->pdev->devfn & 7;\r\nnfp->iomem.csr = bar->iomem + NFP_PCIE_BAR(pf);\r\n}\r\nnfp->iomem.em = bar->iomem + NFP_PCIE_EM;\r\n}\r\nif (nfp->pdev->device == PCI_DEVICE_ID_NETRONOME_NFP4000 ||\r\nnfp->pdev->device == PCI_DEVICE_ID_NETRONOME_NFP6000)\r\nexpl_groups = 4;\r\nelse\r\nexpl_groups = 1;\r\nbar = &nfp->bar[1];\r\nmsg += snprintf(msg, end - msg, "0.1: PCIe XPB/MSI-X PBA, ");\r\natomic_inc(&bar->refcnt);\r\nbars_free--;\r\nnfp6000_bar_write(nfp, bar, barcfg_msix_xpb);\r\nfor (i = 0; i < 4; i++) {\r\nint j;\r\nif (i >= NFP_PCIE_EXPLICIT_BARS || i >= expl_groups) {\r\nnfp->expl.group[i].bitsize = 0;\r\ncontinue;\r\n}\r\nbar = &nfp->bar[4 + i];\r\nbar->iomem = ioremap_nocache(nfp_bar_resource_start(bar),\r\nnfp_bar_resource_len(bar));\r\nif (bar->iomem) {\r\nmsg += snprintf(msg, end - msg,\r\n"0.%d: Explicit%d, ", 4 + i, i);\r\natomic_inc(&bar->refcnt);\r\nbars_free--;\r\nnfp->expl.group[i].bitsize = bar->bitsize;\r\nnfp->expl.group[i].addr = bar->iomem;\r\nnfp6000_bar_write(nfp, bar, barcfg_explicit[i]);\r\nfor (j = 0; j < 4; j++)\r\nnfp->expl.group[i].free[j] = true;\r\n}\r\nnfp->iomem.expl[i] = bar->iomem;\r\n}\r\nsort(&nfp->bar[0], nfp->bars, sizeof(nfp->bar[0]),\r\nbar_cmp, NULL);\r\ndev_info(nfp->dev, "%sfree: %d/%d\n", status_msg, bars_free, nfp->bars);\r\nreturn 0;\r\n}\r\nstatic void disable_bars(struct nfp6000_pcie *nfp)\r\n{\r\nstruct nfp_bar *bar = &nfp->bar[0];\r\nint n;\r\nfor (n = 0; n < nfp->bars; n++, bar++) {\r\nif (bar->iomem) {\r\niounmap(bar->iomem);\r\nbar->iomem = NULL;\r\n}\r\n}\r\n}\r\nstatic int nfp6000_area_init(struct nfp_cpp_area *area, u32 dest,\r\nunsigned long long address, unsigned long size)\r\n{\r\nstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\r\nu32 target = NFP_CPP_ID_TARGET_of(dest);\r\nu32 action = NFP_CPP_ID_ACTION_of(dest);\r\nu32 token = NFP_CPP_ID_TOKEN_of(dest);\r\nint pp;\r\npp = nfp_target_pushpull(NFP_CPP_ID(target, action, token), address);\r\nif (pp < 0)\r\nreturn pp;\r\npriv->width.read = PUSH_WIDTH(pp);\r\npriv->width.write = PULL_WIDTH(pp);\r\nif (priv->width.read > 0 &&\r\npriv->width.write > 0 &&\r\npriv->width.read != priv->width.write) {\r\nreturn -EINVAL;\r\n}\r\nif (priv->width.read > 0)\r\npriv->width.bar = priv->width.read;\r\nelse\r\npriv->width.bar = priv->width.write;\r\natomic_set(&priv->refcnt, 0);\r\npriv->bar = NULL;\r\npriv->target = target;\r\npriv->action = action;\r\npriv->token = token;\r\npriv->offset = address;\r\npriv->size = size;\r\nmemset(&priv->resource, 0, sizeof(priv->resource));\r\nreturn 0;\r\n}\r\nstatic void nfp6000_area_cleanup(struct nfp_cpp_area *area)\r\n{\r\n}\r\nstatic void priv_area_get(struct nfp_cpp_area *area)\r\n{\r\nstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\r\natomic_inc(&priv->refcnt);\r\n}\r\nstatic int priv_area_put(struct nfp_cpp_area *area)\r\n{\r\nstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\r\nif (WARN_ON(!atomic_read(&priv->refcnt)))\r\nreturn 0;\r\nreturn atomic_dec_and_test(&priv->refcnt);\r\n}\r\nstatic int nfp6000_area_acquire(struct nfp_cpp_area *area)\r\n{\r\nstruct nfp6000_pcie *nfp = nfp_cpp_priv(nfp_cpp_area_cpp(area));\r\nstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\r\nint barnum, err;\r\nif (priv->bar) {\r\npriv_area_get(area);\r\nreturn 0;\r\n}\r\nbarnum = nfp_alloc_bar(nfp, priv->target, priv->action, priv->token,\r\npriv->offset, priv->size, priv->width.bar, 1);\r\nif (barnum < 0) {\r\nerr = barnum;\r\ngoto err_alloc_bar;\r\n}\r\npriv->bar = &nfp->bar[barnum];\r\nif (nfp_bar_maptype(priv->bar) ==\r\nNFP_PCIE_BAR_PCIE2CPP_MapType_GENERAL) {\r\npriv->bar_offset = priv->offset &\r\n(NFP_PCIE_P2C_GENERAL_SIZE(priv->bar) - 1);\r\npriv->bar_offset += NFP_PCIE_P2C_GENERAL_TARGET_OFFSET(\r\npriv->bar, priv->target);\r\npriv->bar_offset += NFP_PCIE_P2C_GENERAL_TOKEN_OFFSET(\r\npriv->bar, priv->token);\r\n} else {\r\npriv->bar_offset = priv->offset & priv->bar->mask;\r\n}\r\npriv->phys = nfp_bar_resource_start(priv->bar) + priv->bar_offset;\r\npriv->resource.name = nfp_cpp_area_name(area);\r\npriv->resource.start = priv->phys;\r\npriv->resource.end = priv->resource.start + priv->size - 1;\r\npriv->resource.flags = IORESOURCE_MEM;\r\nif (priv->bar->iomem)\r\npriv->iomem = priv->bar->iomem + priv->bar_offset;\r\nelse\r\npriv->iomem = ioremap_nocache(priv->phys, priv->size);\r\nif (IS_ERR_OR_NULL(priv->iomem)) {\r\ndev_err(nfp->dev, "Can't ioremap() a %d byte region of BAR %d\n",\r\n(int)priv->size, priv->bar->index);\r\nerr = !priv->iomem ? -ENOMEM : PTR_ERR(priv->iomem);\r\npriv->iomem = NULL;\r\ngoto err_iomem_remap;\r\n}\r\npriv_area_get(area);\r\nreturn 0;\r\nerr_iomem_remap:\r\nnfp_bar_put(nfp, priv->bar);\r\npriv->bar = NULL;\r\nerr_alloc_bar:\r\nreturn err;\r\n}\r\nstatic void nfp6000_area_release(struct nfp_cpp_area *area)\r\n{\r\nstruct nfp6000_pcie *nfp = nfp_cpp_priv(nfp_cpp_area_cpp(area));\r\nstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\r\nif (!priv_area_put(area))\r\nreturn;\r\nif (!priv->bar->iomem)\r\niounmap(priv->iomem);\r\nnfp_bar_put(nfp, priv->bar);\r\npriv->bar = NULL;\r\npriv->iomem = NULL;\r\n}\r\nstatic phys_addr_t nfp6000_area_phys(struct nfp_cpp_area *area)\r\n{\r\nstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\r\nreturn priv->phys;\r\n}\r\nstatic void __iomem *nfp6000_area_iomem(struct nfp_cpp_area *area)\r\n{\r\nstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\r\nreturn priv->iomem;\r\n}\r\nstatic struct resource *nfp6000_area_resource(struct nfp_cpp_area *area)\r\n{\r\nstruct nfp6000_area_priv *priv = nfp_cpp_area_priv(area);\r\nreturn priv->bar->resource;\r\n}\r\nstatic int nfp6000_area_read(struct nfp_cpp_area *area, void *kernel_vaddr,\r\nunsigned long offset, unsigned int length)\r\n{\r\nu64 __maybe_unused *wrptr64 = kernel_vaddr;\r\nconst u64 __iomem __maybe_unused *rdptr64;\r\nstruct nfp6000_area_priv *priv;\r\nu32 *wrptr32 = kernel_vaddr;\r\nconst u32 __iomem *rdptr32;\r\nint n, width;\r\nbool is_64;\r\npriv = nfp_cpp_area_priv(area);\r\nrdptr64 = priv->iomem + offset;\r\nrdptr32 = priv->iomem + offset;\r\nif (offset + length > priv->size)\r\nreturn -EFAULT;\r\nwidth = priv->width.read;\r\nif (width <= 0)\r\nreturn -EINVAL;\r\nif ((priv->offset + offset) & (width - 1))\r\nreturn nfp_cpp_explicit_read(nfp_cpp_area_cpp(area),\r\nNFP_CPP_ID(priv->target,\r\npriv->action,\r\npriv->token),\r\npriv->offset + offset,\r\nkernel_vaddr, length, width);\r\nis_64 = width == TARGET_WIDTH_64;\r\nif (priv->target == (NFP_CPP_TARGET_ID_MASK & NFP_CPP_TARGET_MU) &&\r\npriv->action == NFP_CPP_ACTION_RW)\r\nis_64 = false;\r\nif (is_64) {\r\nif (offset % sizeof(u64) != 0 || length % sizeof(u64) != 0)\r\nreturn -EINVAL;\r\n} else {\r\nif (offset % sizeof(u32) != 0 || length % sizeof(u32) != 0)\r\nreturn -EINVAL;\r\n}\r\nif (WARN_ON(!priv->bar))\r\nreturn -EFAULT;\r\nif (is_64)\r\n#ifndef __raw_readq\r\nreturn -EINVAL;\r\n#else\r\nfor (n = 0; n < length; n += sizeof(u64))\r\n*wrptr64++ = __raw_readq(rdptr64++);\r\n#endif\r\nelse\r\nfor (n = 0; n < length; n += sizeof(u32))\r\n*wrptr32++ = __raw_readl(rdptr32++);\r\nreturn n;\r\n}\r\nstatic int\r\nnfp6000_area_write(struct nfp_cpp_area *area,\r\nconst void *kernel_vaddr,\r\nunsigned long offset, unsigned int length)\r\n{\r\nconst u64 __maybe_unused *rdptr64 = kernel_vaddr;\r\nu64 __iomem __maybe_unused *wrptr64;\r\nconst u32 *rdptr32 = kernel_vaddr;\r\nstruct nfp6000_area_priv *priv;\r\nu32 __iomem *wrptr32;\r\nint n, width;\r\nbool is_64;\r\npriv = nfp_cpp_area_priv(area);\r\nwrptr64 = priv->iomem + offset;\r\nwrptr32 = priv->iomem + offset;\r\nif (offset + length > priv->size)\r\nreturn -EFAULT;\r\nwidth = priv->width.write;\r\nif (width <= 0)\r\nreturn -EINVAL;\r\nif ((priv->offset + offset) & (width - 1))\r\nreturn nfp_cpp_explicit_write(nfp_cpp_area_cpp(area),\r\nNFP_CPP_ID(priv->target,\r\npriv->action,\r\npriv->token),\r\npriv->offset + offset,\r\nkernel_vaddr, length, width);\r\nis_64 = width == TARGET_WIDTH_64;\r\nif (priv->target == (NFP_CPP_TARGET_ID_MASK & NFP_CPP_TARGET_MU) &&\r\npriv->action == NFP_CPP_ACTION_RW)\r\nis_64 = false;\r\nif (is_64) {\r\nif (offset % sizeof(u64) != 0 || length % sizeof(u64) != 0)\r\nreturn -EINVAL;\r\n} else {\r\nif (offset % sizeof(u32) != 0 || length % sizeof(u32) != 0)\r\nreturn -EINVAL;\r\n}\r\nif (WARN_ON(!priv->bar))\r\nreturn -EFAULT;\r\nif (is_64)\r\n#ifndef __raw_writeq\r\nreturn -EINVAL;\r\n#else\r\nfor (n = 0; n < length; n += sizeof(u64)) {\r\n__raw_writeq(*rdptr64++, wrptr64++);\r\nwmb();\r\n}\r\n#endif\r\nelse\r\nfor (n = 0; n < length; n += sizeof(u32)) {\r\n__raw_writel(*rdptr32++, wrptr32++);\r\nwmb();\r\n}\r\nreturn n;\r\n}\r\nstatic int nfp6000_explicit_acquire(struct nfp_cpp_explicit *expl)\r\n{\r\nstruct nfp6000_pcie *nfp = nfp_cpp_priv(nfp_cpp_explicit_cpp(expl));\r\nstruct nfp6000_explicit_priv *priv = nfp_cpp_explicit_priv(expl);\r\nint i, j;\r\nmutex_lock(&nfp->expl.mutex);\r\nfor (i = 0; i < ARRAY_SIZE(nfp->expl.group); i++) {\r\nif (!nfp->expl.group[i].bitsize)\r\ncontinue;\r\nfor (j = 0; j < ARRAY_SIZE(nfp->expl.group[i].free); j++) {\r\nu16 data_offset;\r\nif (!nfp->expl.group[i].free[j])\r\ncontinue;\r\npriv->nfp = nfp;\r\npriv->bar.group = i;\r\npriv->bar.area = j;\r\npriv->bitsize = nfp->expl.group[i].bitsize - 2;\r\ndata_offset = (priv->bar.group << 9) +\r\n(priv->bar.area << 7);\r\npriv->data = nfp->expl.data + data_offset;\r\npriv->addr = nfp->expl.group[i].addr +\r\n(priv->bar.area << priv->bitsize);\r\nnfp->expl.group[i].free[j] = false;\r\nmutex_unlock(&nfp->expl.mutex);\r\nreturn 0;\r\n}\r\n}\r\nmutex_unlock(&nfp->expl.mutex);\r\nreturn -EAGAIN;\r\n}\r\nstatic void nfp6000_explicit_release(struct nfp_cpp_explicit *expl)\r\n{\r\nstruct nfp6000_explicit_priv *priv = nfp_cpp_explicit_priv(expl);\r\nstruct nfp6000_pcie *nfp = priv->nfp;\r\nmutex_lock(&nfp->expl.mutex);\r\nnfp->expl.group[priv->bar.group].free[priv->bar.area] = true;\r\nmutex_unlock(&nfp->expl.mutex);\r\n}\r\nstatic int nfp6000_explicit_put(struct nfp_cpp_explicit *expl,\r\nconst void *buff, size_t len)\r\n{\r\nstruct nfp6000_explicit_priv *priv = nfp_cpp_explicit_priv(expl);\r\nconst u32 *src = buff;\r\nsize_t i;\r\nfor (i = 0; i < len; i += sizeof(u32))\r\nwritel(*(src++), priv->data + i);\r\nreturn i;\r\n}\r\nstatic int\r\nnfp6000_explicit_do(struct nfp_cpp_explicit *expl,\r\nconst struct nfp_cpp_explicit_command *cmd, u64 address)\r\n{\r\nstruct nfp6000_explicit_priv *priv = nfp_cpp_explicit_priv(expl);\r\nu8 signal_master, signal_ref, data_master;\r\nstruct nfp6000_pcie *nfp = priv->nfp;\r\nint sigmask = 0;\r\nu16 data_ref;\r\nu32 csr[3];\r\nif (cmd->siga_mode)\r\nsigmask |= 1 << cmd->siga;\r\nif (cmd->sigb_mode)\r\nsigmask |= 1 << cmd->sigb;\r\nsignal_master = cmd->signal_master;\r\nif (!signal_master)\r\nsignal_master = nfp->expl.master_id;\r\nsignal_ref = cmd->signal_ref;\r\nif (signal_master == nfp->expl.master_id)\r\nsignal_ref = nfp->expl.signal_ref +\r\n((priv->bar.group * 4 + priv->bar.area) << 1);\r\ndata_master = cmd->data_master;\r\nif (!data_master)\r\ndata_master = nfp->expl.master_id;\r\ndata_ref = cmd->data_ref;\r\nif (data_master == nfp->expl.master_id)\r\ndata_ref = 0x1000 +\r\n(priv->bar.group << 9) + (priv->bar.area << 7);\r\ncsr[0] = NFP_PCIE_BAR_EXPLICIT_BAR0_SignalType(sigmask) |\r\nNFP_PCIE_BAR_EXPLICIT_BAR0_Token(\r\nNFP_CPP_ID_TOKEN_of(cmd->cpp_id)) |\r\nNFP_PCIE_BAR_EXPLICIT_BAR0_Address(address >> 16);\r\ncsr[1] = NFP_PCIE_BAR_EXPLICIT_BAR1_SignalRef(signal_ref) |\r\nNFP_PCIE_BAR_EXPLICIT_BAR1_DataMaster(data_master) |\r\nNFP_PCIE_BAR_EXPLICIT_BAR1_DataRef(data_ref);\r\ncsr[2] = NFP_PCIE_BAR_EXPLICIT_BAR2_Target(\r\nNFP_CPP_ID_TARGET_of(cmd->cpp_id)) |\r\nNFP_PCIE_BAR_EXPLICIT_BAR2_Action(\r\nNFP_CPP_ID_ACTION_of(cmd->cpp_id)) |\r\nNFP_PCIE_BAR_EXPLICIT_BAR2_Length(cmd->len) |\r\nNFP_PCIE_BAR_EXPLICIT_BAR2_ByteMask(cmd->byte_mask) |\r\nNFP_PCIE_BAR_EXPLICIT_BAR2_SignalMaster(signal_master);\r\nif (nfp->iomem.csr) {\r\nwritel(csr[0], nfp->iomem.csr +\r\nNFP_PCIE_BAR_EXPLICIT_BAR0(priv->bar.group,\r\npriv->bar.area));\r\nwritel(csr[1], nfp->iomem.csr +\r\nNFP_PCIE_BAR_EXPLICIT_BAR1(priv->bar.group,\r\npriv->bar.area));\r\nwritel(csr[2], nfp->iomem.csr +\r\nNFP_PCIE_BAR_EXPLICIT_BAR2(priv->bar.group,\r\npriv->bar.area));\r\nreadl(nfp->iomem.csr +\r\nNFP_PCIE_BAR_EXPLICIT_BAR0(priv->bar.group,\r\npriv->bar.area));\r\nreadl(nfp->iomem.csr +\r\nNFP_PCIE_BAR_EXPLICIT_BAR1(priv->bar.group,\r\npriv->bar.area));\r\nreadl(nfp->iomem.csr +\r\nNFP_PCIE_BAR_EXPLICIT_BAR2(priv->bar.group,\r\npriv->bar.area));\r\n} else {\r\npci_write_config_dword(nfp->pdev, 0x400 +\r\nNFP_PCIE_BAR_EXPLICIT_BAR0(\r\npriv->bar.group, priv->bar.area),\r\ncsr[0]);\r\npci_write_config_dword(nfp->pdev, 0x400 +\r\nNFP_PCIE_BAR_EXPLICIT_BAR1(\r\npriv->bar.group, priv->bar.area),\r\ncsr[1]);\r\npci_write_config_dword(nfp->pdev, 0x400 +\r\nNFP_PCIE_BAR_EXPLICIT_BAR2(\r\npriv->bar.group, priv->bar.area),\r\ncsr[2]);\r\n}\r\nreadb(priv->addr + (address & ((1 << priv->bitsize) - 1)));\r\nreturn sigmask;\r\n}\r\nstatic int nfp6000_explicit_get(struct nfp_cpp_explicit *expl,\r\nvoid *buff, size_t len)\r\n{\r\nstruct nfp6000_explicit_priv *priv = nfp_cpp_explicit_priv(expl);\r\nu32 *dst = buff;\r\nsize_t i;\r\nfor (i = 0; i < len; i += sizeof(u32))\r\n*(dst++) = readl(priv->data + i);\r\nreturn i;\r\n}\r\nstatic int nfp6000_init(struct nfp_cpp *cpp)\r\n{\r\nnfp_cpp_area_cache_add(cpp, SZ_64K);\r\nnfp_cpp_area_cache_add(cpp, SZ_64K);\r\nnfp_cpp_area_cache_add(cpp, SZ_256K);\r\nreturn 0;\r\n}\r\nstatic void nfp6000_free(struct nfp_cpp *cpp)\r\n{\r\nstruct nfp6000_pcie *nfp = nfp_cpp_priv(cpp);\r\ndisable_bars(nfp);\r\nkfree(nfp);\r\n}\r\nstatic void nfp6000_read_serial(struct device *dev, u8 *serial)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nint pos;\r\nu32 reg;\r\npos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_DSN);\r\nif (!pos) {\r\nmemset(serial, 0, NFP_SERIAL_LEN);\r\nreturn;\r\n}\r\npci_read_config_dword(pdev, pos + 4, &reg);\r\nput_unaligned_be16(reg >> 16, serial + 4);\r\npci_read_config_dword(pdev, pos + 8, &reg);\r\nput_unaligned_be32(reg, serial);\r\n}\r\nstatic u16 nfp6000_get_interface(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nint pos;\r\nu32 reg;\r\npos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_DSN);\r\nif (!pos)\r\nreturn NFP_CPP_INTERFACE(NFP_CPP_INTERFACE_TYPE_PCI, 0, 0xff);\r\npci_read_config_dword(pdev, pos + 4, &reg);\r\nreturn reg & 0xffff;\r\n}\r\nstruct nfp_cpp *nfp_cpp_from_nfp6000_pcie(struct pci_dev *pdev)\r\n{\r\nstruct nfp6000_pcie *nfp;\r\nu16 interface;\r\nint err;\r\ndev_info(&pdev->dev,\r\n"Netronome Flow Processor NFP4000/NFP6000 PCIe Card Probe\n");\r\nnfp = kzalloc(sizeof(*nfp), GFP_KERNEL);\r\nif (!nfp) {\r\nerr = -ENOMEM;\r\ngoto err_ret;\r\n}\r\nnfp->dev = &pdev->dev;\r\nnfp->pdev = pdev;\r\ninit_waitqueue_head(&nfp->bar_waiters);\r\nspin_lock_init(&nfp->bar_lock);\r\ninterface = nfp6000_get_interface(&pdev->dev);\r\nif (NFP_CPP_INTERFACE_TYPE_of(interface) !=\r\nNFP_CPP_INTERFACE_TYPE_PCI) {\r\ndev_err(&pdev->dev,\r\n"Interface type %d is not the expected %d\n",\r\nNFP_CPP_INTERFACE_TYPE_of(interface),\r\nNFP_CPP_INTERFACE_TYPE_PCI);\r\nerr = -ENODEV;\r\ngoto err_free_nfp;\r\n}\r\nif (NFP_CPP_INTERFACE_CHANNEL_of(interface) !=\r\nNFP_CPP_INTERFACE_CHANNEL_PEROPENER) {\r\ndev_err(&pdev->dev, "Interface channel %d is not the expected %d\n",\r\nNFP_CPP_INTERFACE_CHANNEL_of(interface),\r\nNFP_CPP_INTERFACE_CHANNEL_PEROPENER);\r\nerr = -ENODEV;\r\ngoto err_free_nfp;\r\n}\r\nerr = enable_bars(nfp, interface);\r\nif (err)\r\ngoto err_free_nfp;\r\nreturn nfp_cpp_from_operations(&nfp6000_pcie_ops, &pdev->dev, nfp);\r\nerr_free_nfp:\r\nkfree(nfp);\r\nerr_ret:\r\ndev_err(&pdev->dev, "NFP6000 PCI setup failed\n");\r\nreturn ERR_PTR(err);\r\n}
