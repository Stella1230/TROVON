static void bochs_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nstatic int bochs_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct bochs_device *bochs =\r\ncontainer_of(crtc, struct bochs_device, crtc);\r\nstruct bochs_framebuffer *bochs_fb;\r\nstruct bochs_bo *bo;\r\nu64 gpu_addr = 0;\r\nint ret;\r\nif (old_fb) {\r\nbochs_fb = to_bochs_framebuffer(old_fb);\r\nbo = gem_to_bochs_bo(bochs_fb->obj);\r\nret = ttm_bo_reserve(&bo->bo, true, false, NULL);\r\nif (ret) {\r\nDRM_ERROR("failed to reserve old_fb bo\n");\r\n} else {\r\nbochs_bo_unpin(bo);\r\nttm_bo_unreserve(&bo->bo);\r\n}\r\n}\r\nif (WARN_ON(crtc->primary->fb == NULL))\r\nreturn -EINVAL;\r\nbochs_fb = to_bochs_framebuffer(crtc->primary->fb);\r\nbo = gem_to_bochs_bo(bochs_fb->obj);\r\nret = ttm_bo_reserve(&bo->bo, true, false, NULL);\r\nif (ret)\r\nreturn ret;\r\nret = bochs_bo_pin(bo, TTM_PL_FLAG_VRAM, &gpu_addr);\r\nif (ret) {\r\nttm_bo_unreserve(&bo->bo);\r\nreturn ret;\r\n}\r\nttm_bo_unreserve(&bo->bo);\r\nbochs_hw_setbase(bochs, x, y, gpu_addr);\r\nreturn 0;\r\n}\r\nstatic int bochs_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y, struct drm_framebuffer *old_fb)\r\n{\r\nstruct bochs_device *bochs =\r\ncontainer_of(crtc, struct bochs_device, crtc);\r\nbochs_hw_setmode(bochs, mode);\r\nbochs_crtc_mode_set_base(crtc, x, y, old_fb);\r\nreturn 0;\r\n}\r\nstatic void bochs_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic void bochs_crtc_commit(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic int bochs_crtc_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event,\r\nuint32_t page_flip_flags,\r\nstruct drm_modeset_acquire_ctx *ctx)\r\n{\r\nstruct bochs_device *bochs =\r\ncontainer_of(crtc, struct bochs_device, crtc);\r\nstruct drm_framebuffer *old_fb = crtc->primary->fb;\r\nunsigned long irqflags;\r\ncrtc->primary->fb = fb;\r\nbochs_crtc_mode_set_base(crtc, 0, 0, old_fb);\r\nif (event) {\r\nspin_lock_irqsave(&bochs->dev->event_lock, irqflags);\r\ndrm_crtc_send_vblank_event(crtc, event);\r\nspin_unlock_irqrestore(&bochs->dev->event_lock, irqflags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void bochs_crtc_init(struct drm_device *dev)\r\n{\r\nstruct bochs_device *bochs = dev->dev_private;\r\nstruct drm_crtc *crtc = &bochs->crtc;\r\ndrm_crtc_init(dev, crtc, &bochs_crtc_funcs);\r\ndrm_crtc_helper_add(crtc, &bochs_helper_funcs);\r\n}\r\nstatic void bochs_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\n}\r\nstatic void bochs_encoder_dpms(struct drm_encoder *encoder, int state)\r\n{\r\n}\r\nstatic void bochs_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void bochs_encoder_commit(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void bochs_encoder_init(struct drm_device *dev)\r\n{\r\nstruct bochs_device *bochs = dev->dev_private;\r\nstruct drm_encoder *encoder = &bochs->encoder;\r\nencoder->possible_crtcs = 0x1;\r\ndrm_encoder_init(dev, encoder, &bochs_encoder_encoder_funcs,\r\nDRM_MODE_ENCODER_DAC, NULL);\r\ndrm_encoder_helper_add(encoder, &bochs_encoder_helper_funcs);\r\n}\r\nstatic int bochs_connector_get_modes(struct drm_connector *connector)\r\n{\r\nint count;\r\ncount = drm_add_modes_noedid(connector, 8192, 8192);\r\ndrm_set_preferred_mode(connector, defx, defy);\r\nreturn count;\r\n}\r\nstatic int bochs_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct bochs_device *bochs =\r\ncontainer_of(connector, struct bochs_device, connector);\r\nunsigned long size = mode->hdisplay * mode->vdisplay * 4;\r\nif (size * 2 > bochs->fb_size)\r\nreturn MODE_BAD;\r\nreturn MODE_OK;\r\n}\r\nstatic struct drm_encoder *\r\nbochs_connector_best_encoder(struct drm_connector *connector)\r\n{\r\nint enc_id = connector->encoder_ids[0];\r\nif (enc_id)\r\nreturn drm_encoder_find(connector->dev, enc_id);\r\nreturn NULL;\r\n}\r\nstatic void bochs_connector_init(struct drm_device *dev)\r\n{\r\nstruct bochs_device *bochs = dev->dev_private;\r\nstruct drm_connector *connector = &bochs->connector;\r\ndrm_connector_init(dev, connector, &bochs_connector_connector_funcs,\r\nDRM_MODE_CONNECTOR_VIRTUAL);\r\ndrm_connector_helper_add(connector,\r\n&bochs_connector_connector_helper_funcs);\r\ndrm_connector_register(connector);\r\n}\r\nint bochs_kms_init(struct bochs_device *bochs)\r\n{\r\ndrm_mode_config_init(bochs->dev);\r\nbochs->mode_config_initialized = true;\r\nbochs->dev->mode_config.max_width = 8192;\r\nbochs->dev->mode_config.max_height = 8192;\r\nbochs->dev->mode_config.fb_base = bochs->fb_base;\r\nbochs->dev->mode_config.preferred_depth = 24;\r\nbochs->dev->mode_config.prefer_shadow = 0;\r\nbochs->dev->mode_config.funcs = &bochs_mode_funcs;\r\nbochs_crtc_init(bochs->dev);\r\nbochs_encoder_init(bochs->dev);\r\nbochs_connector_init(bochs->dev);\r\ndrm_mode_connector_attach_encoder(&bochs->connector,\r\n&bochs->encoder);\r\nreturn 0;\r\n}\r\nvoid bochs_kms_fini(struct bochs_device *bochs)\r\n{\r\nif (bochs->mode_config_initialized) {\r\ndrm_mode_config_cleanup(bochs->dev);\r\nbochs->mode_config_initialized = false;\r\n}\r\n}
