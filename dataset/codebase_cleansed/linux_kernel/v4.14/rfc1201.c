static int __init arcnet_rfc1201_init(void)\r\n{\r\npr_info("%s\n", "RFC1201 \"standard\" (`a') encapsulation support loaded");\r\narc_proto_map[ARC_P_IP]\r\n= arc_proto_map[ARC_P_IPV6]\r\n= arc_proto_map[ARC_P_ARP]\r\n= arc_proto_map[ARC_P_RARP]\r\n= arc_proto_map[ARC_P_IPX]\r\n= arc_proto_map[ARC_P_NOVELL_EC]\r\n= &rfc1201_proto;\r\nif (arc_bcast_proto == arc_proto_default)\r\narc_bcast_proto = &rfc1201_proto;\r\nreturn 0;\r\n}\r\nstatic void __exit arcnet_rfc1201_exit(void)\r\n{\r\narcnet_unregister_proto(&rfc1201_proto);\r\n}\r\nstatic __be16 type_trans(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct archdr *pkt = (struct archdr *)skb->data;\r\nstruct arc_rfc1201 *soft = &pkt->soft.rfc1201;\r\nint hdr_size = ARC_HDR_SIZE + RFC1201_HDR_SIZE;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb, hdr_size);\r\nif (pkt->hard.dest == 0) {\r\nskb->pkt_type = PACKET_BROADCAST;\r\n} else if (dev->flags & IFF_PROMISC) {\r\nif (pkt->hard.dest != dev->dev_addr[0])\r\nskb->pkt_type = PACKET_OTHERHOST;\r\n}\r\nswitch (soft->proto) {\r\ncase ARC_P_IP:\r\nreturn htons(ETH_P_IP);\r\ncase ARC_P_IPV6:\r\nreturn htons(ETH_P_IPV6);\r\ncase ARC_P_ARP:\r\nreturn htons(ETH_P_ARP);\r\ncase ARC_P_RARP:\r\nreturn htons(ETH_P_RARP);\r\ncase ARC_P_IPX:\r\ncase ARC_P_NOVELL_EC:\r\nreturn htons(ETH_P_802_3);\r\ndefault:\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_crc_errors++;\r\nreturn 0;\r\n}\r\nreturn htons(ETH_P_IP);\r\n}\r\nstatic void rx(struct net_device *dev, int bufnum,\r\nstruct archdr *pkthdr, int length)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nstruct archdr *pkt = pkthdr;\r\nstruct arc_rfc1201 *soft = &pkthdr->soft.rfc1201;\r\nint saddr = pkt->hard.source, ofs;\r\nstruct Incoming *in = &lp->rfc1201.incoming[saddr];\r\narc_printk(D_DURING, dev, "it's an RFC1201 packet (length=%d)\n",\r\nlength);\r\nif (length >= MinTU)\r\nofs = 512 - length;\r\nelse\r\nofs = 256 - length;\r\nif (soft->split_flag == 0xFF) {\r\nif (length >= 4 + RFC1201_HDR_SIZE) {\r\narc_printk(D_DURING, dev, "compensating for exception packet\n");\r\n} else {\r\narc_printk(D_EXTRA, dev, "short RFC1201 exception packet from %02Xh",\r\nsaddr);\r\nreturn;\r\n}\r\nlength -= 4;\r\nofs += 4;\r\nlp->hw.copy_from_card(dev, bufnum, 512 - length,\r\nsoft, sizeof(pkt->soft));\r\n}\r\nif (!soft->split_flag) {\r\narc_printk(D_RX, dev, "incoming is not split (splitflag=%d)\n",\r\nsoft->split_flag);\r\nif (in->skb) {\r\narc_printk(D_EXTRA, dev, "aborting assembly (seq=%d) for unsplit packet (splitflag=%d, seq=%d)\n",\r\nin->sequence, soft->split_flag,\r\nsoft->sequence);\r\nlp->rfc1201.aborted_seq = soft->sequence;\r\ndev_kfree_skb_irq(in->skb);\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_missed_errors++;\r\nin->skb = NULL;\r\n}\r\nin->sequence = soft->sequence;\r\nskb = alloc_skb(length + ARC_HDR_SIZE, GFP_ATOMIC);\r\nif (!skb) {\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb_put(skb, length + ARC_HDR_SIZE);\r\nskb->dev = dev;\r\npkt = (struct archdr *)skb->data;\r\nsoft = &pkt->soft.rfc1201;\r\nmemcpy(pkt, pkthdr, sizeof(struct archdr));\r\nif (length > sizeof(pkt->soft))\r\nlp->hw.copy_from_card(dev, bufnum,\r\nofs + sizeof(pkt->soft),\r\npkt->soft.raw + sizeof(pkt->soft),\r\nlength - sizeof(pkt->soft));\r\nif (soft->proto == ARC_P_ARP) {\r\nstruct arphdr *arp = (struct arphdr *)soft->payload;\r\nif (arp->ar_hln == 1 && arp->ar_pln == 4) {\r\nuint8_t *cptr = (uint8_t *)arp + sizeof(struct arphdr);\r\nif (!*cptr) {\r\narc_printk(D_EXTRA, dev,\r\n"ARP source address was 00h, set to %02Xh\n",\r\nsaddr);\r\ndev->stats.rx_crc_errors++;\r\n*cptr = saddr;\r\n} else {\r\narc_printk(D_DURING, dev, "ARP source address (%Xh) is fine.\n",\r\n*cptr);\r\n}\r\n} else {\r\narc_printk(D_NORMAL, dev, "funny-shaped ARP packet. (%Xh, %Xh)\n",\r\narp->ar_hln, arp->ar_pln);\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_crc_errors++;\r\n}\r\n}\r\nif (BUGLVL(D_SKB))\r\narcnet_dump_skb(dev, skb, "rx");\r\nskb->protocol = type_trans(skb, dev);\r\nnetif_rx(skb);\r\n} else {\r\narc_printk(D_RX, dev, "packet is split (splitflag=%d, seq=%d)\n",\r\nsoft->split_flag, in->sequence);\r\nif (in->skb && in->sequence != soft->sequence) {\r\narc_printk(D_EXTRA, dev, "wrong seq number (saddr=%d, expected=%d, seq=%d, splitflag=%d)\n",\r\nsaddr, in->sequence, soft->sequence,\r\nsoft->split_flag);\r\ndev_kfree_skb_irq(in->skb);\r\nin->skb = NULL;\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_missed_errors++;\r\nin->lastpacket = in->numpackets = 0;\r\n}\r\nif (soft->split_flag & 1) {\r\narc_printk(D_RX, dev, "brand new splitpacket (splitflag=%d)\n",\r\nsoft->split_flag);\r\nif (in->skb) {\r\narc_printk(D_EXTRA, dev, "aborting previous (seq=%d) assembly (splitflag=%d, seq=%d)\n",\r\nin->sequence, soft->split_flag,\r\nsoft->sequence);\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_missed_errors++;\r\ndev_kfree_skb_irq(in->skb);\r\n}\r\nin->sequence = soft->sequence;\r\nin->numpackets = ((unsigned)soft->split_flag >> 1) + 2;\r\nin->lastpacket = 1;\r\nif (in->numpackets > 16) {\r\narc_printk(D_EXTRA, dev, "incoming packet more than 16 segments; dropping. (splitflag=%d)\n",\r\nsoft->split_flag);\r\nlp->rfc1201.aborted_seq = soft->sequence;\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_length_errors++;\r\nreturn;\r\n}\r\nin->skb = skb = alloc_skb(508 * in->numpackets + ARC_HDR_SIZE,\r\nGFP_ATOMIC);\r\nif (!skb) {\r\narc_printk(D_NORMAL, dev, "(split) memory squeeze, dropping packet.\n");\r\nlp->rfc1201.aborted_seq = soft->sequence;\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb->dev = dev;\r\npkt = (struct archdr *)skb->data;\r\nsoft = &pkt->soft.rfc1201;\r\nmemcpy(pkt, pkthdr, ARC_HDR_SIZE + RFC1201_HDR_SIZE);\r\nskb_put(skb, ARC_HDR_SIZE + RFC1201_HDR_SIZE);\r\nsoft->split_flag = 0;\r\n} else {\r\nint packetnum = ((unsigned)soft->split_flag >> 1) + 1;\r\nif (!in->skb) {\r\nif (lp->rfc1201.aborted_seq != soft->sequence) {\r\narc_printk(D_EXTRA, dev, "can't continue split without starting first! (splitflag=%d, seq=%d, aborted=%d)\n",\r\nsoft->split_flag,\r\nsoft->sequence,\r\nlp->rfc1201.aborted_seq);\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_missed_errors++;\r\n}\r\nreturn;\r\n}\r\nin->lastpacket++;\r\nif (packetnum != in->lastpacket) {\r\nif (packetnum <= in->lastpacket - 1) {\r\narc_printk(D_EXTRA, dev, "duplicate splitpacket ignored! (splitflag=%d)\n",\r\nsoft->split_flag);\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_frame_errors++;\r\nreturn;\r\n}\r\narc_printk(D_EXTRA, dev, "out-of-order splitpacket, reassembly (seq=%d) aborted (splitflag=%d, seq=%d)\n",\r\nin->sequence, soft->split_flag,\r\nsoft->sequence);\r\nlp->rfc1201.aborted_seq = soft->sequence;\r\ndev_kfree_skb_irq(in->skb);\r\nin->skb = NULL;\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_missed_errors++;\r\nin->lastpacket = in->numpackets = 0;\r\nreturn;\r\n}\r\npkt = (struct archdr *)in->skb->data;\r\nsoft = &pkt->soft.rfc1201;\r\n}\r\nskb = in->skb;\r\nlp->hw.copy_from_card(dev, bufnum, ofs + RFC1201_HDR_SIZE,\r\nskb->data + skb->len,\r\nlength - RFC1201_HDR_SIZE);\r\nskb_put(skb, length - RFC1201_HDR_SIZE);\r\nif (in->lastpacket == in->numpackets) {\r\nin->skb = NULL;\r\nin->lastpacket = in->numpackets = 0;\r\narc_printk(D_SKB_SIZE, dev, "skb: received %d bytes from %02X (unsplit)\n",\r\nskb->len, pkt->hard.source);\r\narc_printk(D_SKB_SIZE, dev, "skb: received %d bytes from %02X (split)\n",\r\nskb->len, pkt->hard.source);\r\nif (BUGLVL(D_SKB))\r\narcnet_dump_skb(dev, skb, "rx");\r\nskb->protocol = type_trans(skb, dev);\r\nnetif_rx(skb);\r\n}\r\n}\r\n}\r\nstatic int build_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type, uint8_t daddr)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nint hdr_size = ARC_HDR_SIZE + RFC1201_HDR_SIZE;\r\nstruct archdr *pkt = skb_push(skb, hdr_size);\r\nstruct arc_rfc1201 *soft = &pkt->soft.rfc1201;\r\nswitch (type) {\r\ncase ETH_P_IP:\r\nsoft->proto = ARC_P_IP;\r\nbreak;\r\ncase ETH_P_IPV6:\r\nsoft->proto = ARC_P_IPV6;\r\nbreak;\r\ncase ETH_P_ARP:\r\nsoft->proto = ARC_P_ARP;\r\nbreak;\r\ncase ETH_P_RARP:\r\nsoft->proto = ARC_P_RARP;\r\nbreak;\r\ncase ETH_P_IPX:\r\ncase ETH_P_802_3:\r\ncase ETH_P_802_2:\r\nsoft->proto = ARC_P_IPX;\r\nbreak;\r\ncase ETH_P_ATALK:\r\nsoft->proto = ARC_P_ATALK;\r\nbreak;\r\ndefault:\r\narc_printk(D_NORMAL, dev, "RFC1201: I don't understand protocol %d (%Xh)\n",\r\ntype, type);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_aborted_errors++;\r\nreturn 0;\r\n}\r\npkt->hard.source = *dev->dev_addr;\r\nsoft->sequence = htons(lp->rfc1201.sequence++);\r\nsoft->split_flag = 0;\r\nif (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {\r\npkt->hard.dest = 0;\r\nreturn hdr_size;\r\n}\r\npkt->hard.dest = daddr;\r\nreturn hdr_size;\r\n}\r\nstatic void load_pkt(struct net_device *dev, struct arc_hardware *hard,\r\nstruct arc_rfc1201 *soft, int softlen, int bufnum)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nint ofs;\r\nif (softlen > MinTU) {\r\nhard->offset[0] = 0;\r\nhard->offset[1] = ofs = 512 - softlen;\r\n} else if (softlen > MTU) {\r\nstruct arc_rfc1201 excsoft;\r\nexcsoft.proto = soft->proto;\r\nexcsoft.split_flag = 0xff;\r\nexcsoft.sequence = htons(0xffff);\r\nhard->offset[0] = 0;\r\nofs = 512 - softlen;\r\nhard->offset[1] = ofs - RFC1201_HDR_SIZE;\r\nlp->hw.copy_to_card(dev, bufnum, ofs - RFC1201_HDR_SIZE,\r\n&excsoft, RFC1201_HDR_SIZE);\r\n} else {\r\nhard->offset[0] = ofs = 256 - softlen;\r\n}\r\nlp->hw.copy_to_card(dev, bufnum, 0, hard, ARC_HDR_SIZE);\r\nlp->hw.copy_to_card(dev, bufnum, ofs, soft, softlen);\r\nlp->lastload_dest = hard->dest;\r\n}\r\nstatic int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,\r\nint bufnum)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nconst int maxsegsize = XMTU - RFC1201_HDR_SIZE;\r\nstruct Outgoing *out;\r\narc_printk(D_DURING, dev, "prepare_tx: txbufs=%d/%d/%d\n",\r\nlp->next_tx, lp->cur_tx, bufnum);\r\nlength -= ARC_HDR_SIZE;\r\npkt->soft.rfc1201.split_flag = 0;\r\nif (length > XMTU) {\r\nout = &lp->outgoing;\r\nout->length = length - RFC1201_HDR_SIZE;\r\nout->dataleft = lp->outgoing.length;\r\nout->numsegs = (out->dataleft + maxsegsize - 1) / maxsegsize;\r\nout->segnum = 0;\r\narc_printk(D_DURING, dev, "rfc1201 prep_tx: ready for %d-segment split (%d bytes, seq=%d)\n",\r\nout->numsegs, out->length,\r\npkt->soft.rfc1201.sequence);\r\nreturn 0;\r\n}\r\nload_pkt(dev, &pkt->hard, &pkt->soft.rfc1201, length, bufnum);\r\nreturn 1;\r\n}\r\nstatic int continue_tx(struct net_device *dev, int bufnum)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nstruct Outgoing *out = &lp->outgoing;\r\nstruct arc_hardware *hard = &out->pkt->hard;\r\nstruct arc_rfc1201 *soft = &out->pkt->soft.rfc1201, *newsoft;\r\nint maxsegsize = XMTU - RFC1201_HDR_SIZE;\r\nint seglen;\r\narc_printk(D_DURING, dev,\r\n"rfc1201 continue_tx: loading segment %d(+1) of %d (seq=%d)\n",\r\nout->segnum, out->numsegs, soft->sequence);\r\nnewsoft = (struct arc_rfc1201 *)\r\n(out->pkt->soft.raw + out->length - out->dataleft);\r\nif (!out->segnum)\r\nnewsoft->split_flag = ((out->numsegs - 2) << 1) | 1;\r\nelse {\r\nnewsoft->split_flag = out->segnum << 1;\r\nnewsoft->proto = soft->proto;\r\nnewsoft->sequence = soft->sequence;\r\n}\r\nseglen = maxsegsize;\r\nif (seglen > out->dataleft)\r\nseglen = out->dataleft;\r\nout->dataleft -= seglen;\r\nload_pkt(dev, hard, newsoft, seglen + RFC1201_HDR_SIZE, bufnum);\r\nout->segnum++;\r\nif (out->segnum >= out->numsegs)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}
