static int hw_rule_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nu8 **formats = rule->private;\r\nstruct snd_interval *r =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nconst struct snd_interval *c =\r\nhw_param_interval_c(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval t = {\r\n.min = UINT_MAX, .max = 0, .integer = 1\r\n};\r\nstruct snd_oxfw_stream_formation formation;\r\nint i, err;\r\nfor (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {\r\nif (formats[i] == NULL)\r\ncontinue;\r\nerr = snd_oxfw_stream_parse_format(formats[i], &formation);\r\nif (err < 0)\r\ncontinue;\r\nif (!snd_interval_test(c, formation.pcm))\r\ncontinue;\r\nt.min = min(t.min, formation.rate);\r\nt.max = max(t.max, formation.rate);\r\n}\r\nreturn snd_interval_refine(r, &t);\r\n}\r\nstatic int hw_rule_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nu8 **formats = rule->private;\r\nstruct snd_interval *c =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nconst struct snd_interval *r =\r\nhw_param_interval_c(params, SNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_oxfw_stream_formation formation;\r\nint i, j, err;\r\nunsigned int count, list[SND_OXFW_STREAM_FORMAT_ENTRIES] = {0};\r\ncount = 0;\r\nfor (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {\r\nif (formats[i] == NULL)\r\nbreak;\r\nerr = snd_oxfw_stream_parse_format(formats[i], &formation);\r\nif (err < 0)\r\ncontinue;\r\nif (!snd_interval_test(r, formation.rate))\r\ncontinue;\r\nif (list[count] == formation.pcm)\r\ncontinue;\r\nfor (j = 0; j < ARRAY_SIZE(list); j++) {\r\nif (list[j] == formation.pcm)\r\nbreak;\r\n}\r\nif (j == ARRAY_SIZE(list)) {\r\nlist[count] = formation.pcm;\r\nif (++count == ARRAY_SIZE(list))\r\nbreak;\r\n}\r\n}\r\nreturn snd_interval_list(c, count, list, 0);\r\n}\r\nstatic void limit_channels_and_rates(struct snd_pcm_hardware *hw, u8 **formats)\r\n{\r\nstruct snd_oxfw_stream_formation formation;\r\nint i, err;\r\nhw->channels_min = UINT_MAX;\r\nhw->channels_max = 0;\r\nhw->rate_min = UINT_MAX;\r\nhw->rate_max = 0;\r\nhw->rates = 0;\r\nfor (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {\r\nif (formats[i] == NULL)\r\nbreak;\r\nerr = snd_oxfw_stream_parse_format(formats[i], &formation);\r\nif (err < 0)\r\ncontinue;\r\nhw->channels_min = min(hw->channels_min, formation.pcm);\r\nhw->channels_max = max(hw->channels_max, formation.pcm);\r\nhw->rate_min = min(hw->rate_min, formation.rate);\r\nhw->rate_max = max(hw->rate_max, formation.rate);\r\nhw->rates |= snd_pcm_rate_to_rate_bit(formation.rate);\r\n}\r\n}\r\nstatic int init_hw_params(struct snd_oxfw *oxfw,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nu8 **formats;\r\nstruct amdtp_stream *stream;\r\nint err;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nruntime->hw.formats = AM824_IN_PCM_FORMAT_BITS;\r\nstream = &oxfw->tx_stream;\r\nformats = oxfw->tx_stream_formats;\r\n} else {\r\nruntime->hw.formats = AM824_OUT_PCM_FORMAT_BITS;\r\nstream = &oxfw->rx_stream;\r\nformats = oxfw->rx_stream_formats;\r\n}\r\nlimit_channels_and_rates(&runtime->hw, formats);\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nhw_rule_channels, formats,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\nhw_rule_rate, formats,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nif (err < 0)\r\ngoto end;\r\nerr = amdtp_am824_add_pcm_hw_constraints(stream, runtime);\r\nend:\r\nreturn err;\r\n}\r\nstatic int limit_to_current_params(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_oxfw *oxfw = substream->private_data;\r\nstruct snd_oxfw_stream_formation formation;\r\nenum avc_general_plug_dir dir;\r\nint err;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\ndir = AVC_GENERAL_PLUG_DIR_OUT;\r\nelse\r\ndir = AVC_GENERAL_PLUG_DIR_IN;\r\nerr = snd_oxfw_stream_get_current_formation(oxfw, dir, &formation);\r\nif (err < 0)\r\ngoto end;\r\nsubstream->runtime->hw.channels_min = formation.pcm;\r\nsubstream->runtime->hw.channels_max = formation.pcm;\r\nsubstream->runtime->hw.rate_min = formation.rate;\r\nsubstream->runtime->hw.rate_max = formation.rate;\r\nend:\r\nreturn err;\r\n}\r\nstatic int pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_oxfw *oxfw = substream->private_data;\r\nint err;\r\nerr = snd_oxfw_stream_lock_try(oxfw);\r\nif (err < 0)\r\ngoto end;\r\nerr = init_hw_params(oxfw, substream);\r\nif (err < 0)\r\ngoto err_locked;\r\nif (amdtp_stream_pcm_running(&oxfw->tx_stream) ||\r\namdtp_stream_pcm_running(&oxfw->rx_stream)) {\r\nerr = limit_to_current_params(substream);\r\nif (err < 0)\r\ngoto end;\r\n}\r\nsnd_pcm_set_sync(substream);\r\nend:\r\nreturn err;\r\nerr_locked:\r\nsnd_oxfw_stream_lock_release(oxfw);\r\nreturn err;\r\n}\r\nstatic int pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_oxfw *oxfw = substream->private_data;\r\nsnd_oxfw_stream_lock_release(oxfw);\r\nreturn 0;\r\n}\r\nstatic int pcm_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_oxfw *oxfw = substream->private_data;\r\nint err;\r\nerr = snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {\r\nmutex_lock(&oxfw->mutex);\r\noxfw->capture_substreams++;\r\nmutex_unlock(&oxfw->mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcm_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_oxfw *oxfw = substream->private_data;\r\nint err;\r\nerr = snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {\r\nmutex_lock(&oxfw->mutex);\r\noxfw->playback_substreams++;\r\nmutex_unlock(&oxfw->mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcm_capture_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_oxfw *oxfw = substream->private_data;\r\nmutex_lock(&oxfw->mutex);\r\nif (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)\r\noxfw->capture_substreams--;\r\nsnd_oxfw_stream_stop_simplex(oxfw, &oxfw->tx_stream);\r\nmutex_unlock(&oxfw->mutex);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int pcm_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_oxfw *oxfw = substream->private_data;\r\nmutex_lock(&oxfw->mutex);\r\nif (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)\r\noxfw->playback_substreams--;\r\nsnd_oxfw_stream_stop_simplex(oxfw, &oxfw->rx_stream);\r\nmutex_unlock(&oxfw->mutex);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int pcm_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_oxfw *oxfw = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nmutex_lock(&oxfw->mutex);\r\nerr = snd_oxfw_stream_start_simplex(oxfw, &oxfw->tx_stream,\r\nruntime->rate, runtime->channels);\r\nmutex_unlock(&oxfw->mutex);\r\nif (err < 0)\r\ngoto end;\r\namdtp_stream_pcm_prepare(&oxfw->tx_stream);\r\nend:\r\nreturn err;\r\n}\r\nstatic int pcm_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_oxfw *oxfw = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nmutex_lock(&oxfw->mutex);\r\nerr = snd_oxfw_stream_start_simplex(oxfw, &oxfw->rx_stream,\r\nruntime->rate, runtime->channels);\r\nmutex_unlock(&oxfw->mutex);\r\nif (err < 0)\r\ngoto end;\r\namdtp_stream_pcm_prepare(&oxfw->rx_stream);\r\nend:\r\nreturn err;\r\n}\r\nstatic int pcm_capture_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_oxfw *oxfw = substream->private_data;\r\nstruct snd_pcm_substream *pcm;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\npcm = substream;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\npcm = NULL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\namdtp_stream_pcm_trigger(&oxfw->tx_stream, pcm);\r\nreturn 0;\r\n}\r\nstatic int pcm_playback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_oxfw *oxfw = substream->private_data;\r\nstruct snd_pcm_substream *pcm;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\npcm = substream;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\npcm = NULL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\namdtp_stream_pcm_trigger(&oxfw->rx_stream, pcm);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t pcm_capture_pointer(struct snd_pcm_substream *sbstm)\r\n{\r\nstruct snd_oxfw *oxfw = sbstm->private_data;\r\nreturn amdtp_stream_pcm_pointer(&oxfw->tx_stream);\r\n}\r\nstatic snd_pcm_uframes_t pcm_playback_pointer(struct snd_pcm_substream *sbstm)\r\n{\r\nstruct snd_oxfw *oxfw = sbstm->private_data;\r\nreturn amdtp_stream_pcm_pointer(&oxfw->rx_stream);\r\n}\r\nstatic int pcm_capture_ack(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_oxfw *oxfw = substream->private_data;\r\nreturn amdtp_stream_pcm_ack(&oxfw->tx_stream);\r\n}\r\nstatic int pcm_playback_ack(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_oxfw *oxfw = substream->private_data;\r\nreturn amdtp_stream_pcm_ack(&oxfw->rx_stream);\r\n}\r\nint snd_oxfw_create_pcm(struct snd_oxfw *oxfw)\r\n{\r\nstatic const struct snd_pcm_ops capture_ops = {\r\n.open = pcm_open,\r\n.close = pcm_close,\r\n.ioctl = snd_pcm_lib_ioctl,\r\n.hw_params = pcm_capture_hw_params,\r\n.hw_free = pcm_capture_hw_free,\r\n.prepare = pcm_capture_prepare,\r\n.trigger = pcm_capture_trigger,\r\n.pointer = pcm_capture_pointer,\r\n.ack = pcm_capture_ack,\r\n.page = snd_pcm_lib_get_vmalloc_page,\r\n.mmap = snd_pcm_lib_mmap_vmalloc,\r\n};\r\nstatic const struct snd_pcm_ops playback_ops = {\r\n.open = pcm_open,\r\n.close = pcm_close,\r\n.ioctl = snd_pcm_lib_ioctl,\r\n.hw_params = pcm_playback_hw_params,\r\n.hw_free = pcm_playback_hw_free,\r\n.prepare = pcm_playback_prepare,\r\n.trigger = pcm_playback_trigger,\r\n.pointer = pcm_playback_pointer,\r\n.ack = pcm_playback_ack,\r\n.page = snd_pcm_lib_get_vmalloc_page,\r\n.mmap = snd_pcm_lib_mmap_vmalloc,\r\n};\r\nstruct snd_pcm *pcm;\r\nunsigned int cap = 0;\r\nint err;\r\nif (oxfw->has_output)\r\ncap = 1;\r\nerr = snd_pcm_new(oxfw->card, oxfw->card->driver, 0, 1, cap, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = oxfw;\r\nstrcpy(pcm->name, oxfw->card->shortname);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &playback_ops);\r\nif (cap > 0)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &capture_ops);\r\nreturn 0;\r\n}
