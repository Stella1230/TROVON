static void omap2_onenand_dma_cb(int lch, u16 ch_status, void *data)\r\n{\r\nstruct omap2_onenand *c = data;\r\ncomplete(&c->dma_done);\r\n}\r\nstatic irqreturn_t omap2_onenand_interrupt(int irq, void *dev_id)\r\n{\r\nstruct omap2_onenand *c = dev_id;\r\ncomplete(&c->irq_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline unsigned short read_reg(struct omap2_onenand *c, int reg)\r\n{\r\nreturn readw(c->onenand.base + reg);\r\n}\r\nstatic inline void write_reg(struct omap2_onenand *c, unsigned short value,\r\nint reg)\r\n{\r\nwritew(value, c->onenand.base + reg);\r\n}\r\nstatic void wait_err(char *msg, int state, unsigned int ctrl, unsigned int intr)\r\n{\r\nprintk(KERN_ERR "onenand_wait: %s! state %d ctrl 0x%04x intr 0x%04x\n",\r\nmsg, state, ctrl, intr);\r\n}\r\nstatic void wait_warn(char *msg, int state, unsigned int ctrl,\r\nunsigned int intr)\r\n{\r\nprintk(KERN_WARNING "onenand_wait: %s! state %d ctrl 0x%04x "\r\n"intr 0x%04x\n", msg, state, ctrl, intr);\r\n}\r\nstatic int omap2_onenand_wait(struct mtd_info *mtd, int state)\r\n{\r\nstruct omap2_onenand *c = container_of(mtd, struct omap2_onenand, mtd);\r\nstruct onenand_chip *this = mtd->priv;\r\nunsigned int intr = 0;\r\nunsigned int ctrl, ctrl_mask;\r\nunsigned long timeout;\r\nu32 syscfg;\r\nif (state == FL_RESETING || state == FL_PREPARING_ERASE ||\r\nstate == FL_VERIFYING_ERASE) {\r\nint i = 21;\r\nunsigned int intr_flags = ONENAND_INT_MASTER;\r\nswitch (state) {\r\ncase FL_RESETING:\r\nintr_flags |= ONENAND_INT_RESET;\r\nbreak;\r\ncase FL_PREPARING_ERASE:\r\nintr_flags |= ONENAND_INT_ERASE;\r\nbreak;\r\ncase FL_VERIFYING_ERASE:\r\ni = 101;\r\nbreak;\r\n}\r\nwhile (--i) {\r\nudelay(1);\r\nintr = read_reg(c, ONENAND_REG_INTERRUPT);\r\nif (intr & ONENAND_INT_MASTER)\r\nbreak;\r\n}\r\nctrl = read_reg(c, ONENAND_REG_CTRL_STATUS);\r\nif (ctrl & ONENAND_CTRL_ERROR) {\r\nwait_err("controller error", state, ctrl, intr);\r\nreturn -EIO;\r\n}\r\nif ((intr & intr_flags) == intr_flags)\r\nreturn 0;\r\n}\r\nif (state != FL_READING) {\r\nint result;\r\nsyscfg = read_reg(c, ONENAND_REG_SYS_CFG1);\r\nif (!(syscfg & ONENAND_SYS_CFG1_IOBE)) {\r\nsyscfg |= ONENAND_SYS_CFG1_IOBE;\r\nwrite_reg(c, syscfg, ONENAND_REG_SYS_CFG1);\r\nif (c->flags & ONENAND_IN_OMAP34XX)\r\nsyscfg = read_reg(c, ONENAND_REG_SYS_CFG1);\r\n}\r\nreinit_completion(&c->irq_done);\r\nif (c->gpio_irq) {\r\nresult = gpio_get_value(c->gpio_irq);\r\nif (result == -1) {\r\nctrl = read_reg(c, ONENAND_REG_CTRL_STATUS);\r\nintr = read_reg(c, ONENAND_REG_INTERRUPT);\r\nwait_err("gpio error", state, ctrl, intr);\r\nreturn -EIO;\r\n}\r\n} else\r\nresult = 0;\r\nif (result == 0) {\r\nint retry_cnt = 0;\r\nretry:\r\nresult = wait_for_completion_timeout(&c->irq_done,\r\nmsecs_to_jiffies(20));\r\nif (result == 0) {\r\nctrl = read_reg(c, ONENAND_REG_CTRL_STATUS);\r\nif (ctrl & ONENAND_CTRL_ONGO &&\r\n!this->ongoing) {\r\nretry_cnt += 1;\r\nif (retry_cnt < 3)\r\ngoto retry;\r\nintr = read_reg(c,\r\nONENAND_REG_INTERRUPT);\r\nwait_err("timeout", state, ctrl, intr);\r\nreturn -EIO;\r\n}\r\nintr = read_reg(c, ONENAND_REG_INTERRUPT);\r\nif ((intr & ONENAND_INT_MASTER) == 0)\r\nwait_warn("timeout", state, ctrl, intr);\r\n}\r\n}\r\n} else {\r\nint retry_cnt = 0;\r\nsyscfg = read_reg(c, ONENAND_REG_SYS_CFG1);\r\nsyscfg &= ~ONENAND_SYS_CFG1_IOBE;\r\nwrite_reg(c, syscfg, ONENAND_REG_SYS_CFG1);\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\nwhile (1) {\r\nif (time_before(jiffies, timeout)) {\r\nintr = read_reg(c, ONENAND_REG_INTERRUPT);\r\nif (intr & ONENAND_INT_MASTER)\r\nbreak;\r\n} else {\r\nctrl = read_reg(c, ONENAND_REG_CTRL_STATUS);\r\nif (ctrl & ONENAND_CTRL_ONGO) {\r\nretry_cnt += 1;\r\nif (retry_cnt < 3) {\r\ntimeout = jiffies +\r\nmsecs_to_jiffies(20);\r\ncontinue;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nintr = read_reg(c, ONENAND_REG_INTERRUPT);\r\nctrl = read_reg(c, ONENAND_REG_CTRL_STATUS);\r\nif (intr & ONENAND_INT_READ) {\r\nint ecc = read_reg(c, ONENAND_REG_ECC_STATUS);\r\nif (ecc) {\r\nunsigned int addr1, addr8;\r\naddr1 = read_reg(c, ONENAND_REG_START_ADDRESS1);\r\naddr8 = read_reg(c, ONENAND_REG_START_ADDRESS8);\r\nif (ecc & ONENAND_ECC_2BIT_ALL) {\r\nprintk(KERN_ERR "onenand_wait: ECC error = "\r\n"0x%04x, addr1 %#x, addr8 %#x\n",\r\necc, addr1, addr8);\r\nmtd->ecc_stats.failed++;\r\nreturn -EBADMSG;\r\n} else if (ecc & ONENAND_ECC_1BIT_ALL) {\r\nprintk(KERN_NOTICE "onenand_wait: correctable "\r\n"ECC error = 0x%04x, addr1 %#x, "\r\n"addr8 %#x\n", ecc, addr1, addr8);\r\nmtd->ecc_stats.corrected++;\r\n}\r\n}\r\n} else if (state == FL_READING) {\r\nwait_err("timeout", state, ctrl, intr);\r\nreturn -EIO;\r\n}\r\nif (ctrl & ONENAND_CTRL_ERROR) {\r\nwait_err("controller error", state, ctrl, intr);\r\nif (ctrl & ONENAND_CTRL_LOCK)\r\nprintk(KERN_ERR "onenand_wait: "\r\n"Device is write protected!!!\n");\r\nreturn -EIO;\r\n}\r\nctrl_mask = 0xFE9F;\r\nif (this->ongoing)\r\nctrl_mask &= ~0x8000;\r\nif (ctrl & ctrl_mask)\r\nwait_warn("unexpected controller status", state, ctrl, intr);\r\nreturn 0;\r\n}\r\nstatic inline int omap2_onenand_bufferram_offset(struct mtd_info *mtd, int area)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nif (ONENAND_CURRENT_BUFFERRAM(this)) {\r\nif (area == ONENAND_DATARAM)\r\nreturn this->writesize;\r\nif (area == ONENAND_SPARERAM)\r\nreturn mtd->oobsize;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap3_onenand_read_bufferram(struct mtd_info *mtd, int area,\r\nunsigned char *buffer, int offset,\r\nsize_t count)\r\n{\r\nstruct omap2_onenand *c = container_of(mtd, struct omap2_onenand, mtd);\r\nstruct onenand_chip *this = mtd->priv;\r\ndma_addr_t dma_src, dma_dst;\r\nint bram_offset;\r\nunsigned long timeout;\r\nvoid *buf = (void *)buffer;\r\nsize_t xtra;\r\nvolatile unsigned *done;\r\nbram_offset = omap2_onenand_bufferram_offset(mtd, area) + area + offset;\r\nif (bram_offset & 3 || (size_t)buf & 3 || count < 384)\r\ngoto out_copy;\r\nif (in_interrupt() || oops_in_progress)\r\ngoto out_copy;\r\nif (buf >= high_memory) {\r\nstruct page *p1;\r\nif (((size_t)buf & PAGE_MASK) !=\r\n((size_t)(buf + count - 1) & PAGE_MASK))\r\ngoto out_copy;\r\np1 = vmalloc_to_page(buf);\r\nif (!p1)\r\ngoto out_copy;\r\nbuf = page_address(p1) + ((size_t)buf & ~PAGE_MASK);\r\n}\r\nxtra = count & 3;\r\nif (xtra) {\r\ncount -= xtra;\r\nmemcpy(buf + count, this->base + bram_offset + count, xtra);\r\n}\r\ndma_src = c->phys_base + bram_offset;\r\ndma_dst = dma_map_single(&c->pdev->dev, buf, count, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(&c->pdev->dev, dma_dst)) {\r\ndev_err(&c->pdev->dev,\r\n"Couldn't DMA map a %d byte buffer\n",\r\ncount);\r\ngoto out_copy;\r\n}\r\nomap_set_dma_transfer_params(c->dma_channel, OMAP_DMA_DATA_TYPE_S32,\r\ncount >> 2, 1, 0, 0, 0);\r\nomap_set_dma_src_params(c->dma_channel, 0, OMAP_DMA_AMODE_POST_INC,\r\ndma_src, 0, 0);\r\nomap_set_dma_dest_params(c->dma_channel, 0, OMAP_DMA_AMODE_POST_INC,\r\ndma_dst, 0, 0);\r\nreinit_completion(&c->dma_done);\r\nomap_start_dma(c->dma_channel);\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\ndone = &c->dma_done.done;\r\nwhile (time_before(jiffies, timeout))\r\nif (*done)\r\nbreak;\r\ndma_unmap_single(&c->pdev->dev, dma_dst, count, DMA_FROM_DEVICE);\r\nif (!*done) {\r\ndev_err(&c->pdev->dev, "timeout waiting for DMA\n");\r\ngoto out_copy;\r\n}\r\nreturn 0;\r\nout_copy:\r\nmemcpy(buf, this->base + bram_offset, count);\r\nreturn 0;\r\n}\r\nstatic int omap3_onenand_write_bufferram(struct mtd_info *mtd, int area,\r\nconst unsigned char *buffer,\r\nint offset, size_t count)\r\n{\r\nstruct omap2_onenand *c = container_of(mtd, struct omap2_onenand, mtd);\r\nstruct onenand_chip *this = mtd->priv;\r\ndma_addr_t dma_src, dma_dst;\r\nint bram_offset;\r\nunsigned long timeout;\r\nvoid *buf = (void *)buffer;\r\nvolatile unsigned *done;\r\nbram_offset = omap2_onenand_bufferram_offset(mtd, area) + area + offset;\r\nif (bram_offset & 3 || (size_t)buf & 3 || count < 384)\r\ngoto out_copy;\r\nif (in_interrupt() || oops_in_progress)\r\ngoto out_copy;\r\nif (buf >= high_memory) {\r\nstruct page *p1;\r\nif (((size_t)buf & PAGE_MASK) !=\r\n((size_t)(buf + count - 1) & PAGE_MASK))\r\ngoto out_copy;\r\np1 = vmalloc_to_page(buf);\r\nif (!p1)\r\ngoto out_copy;\r\nbuf = page_address(p1) + ((size_t)buf & ~PAGE_MASK);\r\n}\r\ndma_src = dma_map_single(&c->pdev->dev, buf, count, DMA_TO_DEVICE);\r\ndma_dst = c->phys_base + bram_offset;\r\nif (dma_mapping_error(&c->pdev->dev, dma_src)) {\r\ndev_err(&c->pdev->dev,\r\n"Couldn't DMA map a %d byte buffer\n",\r\ncount);\r\nreturn -1;\r\n}\r\nomap_set_dma_transfer_params(c->dma_channel, OMAP_DMA_DATA_TYPE_S32,\r\ncount >> 2, 1, 0, 0, 0);\r\nomap_set_dma_src_params(c->dma_channel, 0, OMAP_DMA_AMODE_POST_INC,\r\ndma_src, 0, 0);\r\nomap_set_dma_dest_params(c->dma_channel, 0, OMAP_DMA_AMODE_POST_INC,\r\ndma_dst, 0, 0);\r\nreinit_completion(&c->dma_done);\r\nomap_start_dma(c->dma_channel);\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\ndone = &c->dma_done.done;\r\nwhile (time_before(jiffies, timeout))\r\nif (*done)\r\nbreak;\r\ndma_unmap_single(&c->pdev->dev, dma_src, count, DMA_TO_DEVICE);\r\nif (!*done) {\r\ndev_err(&c->pdev->dev, "timeout waiting for DMA\n");\r\ngoto out_copy;\r\n}\r\nreturn 0;\r\nout_copy:\r\nmemcpy(this->base + bram_offset, buf, count);\r\nreturn 0;\r\n}\r\nstatic int omap3_onenand_read_bufferram(struct mtd_info *mtd, int area,\r\nunsigned char *buffer, int offset,\r\nsize_t count)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int omap3_onenand_write_bufferram(struct mtd_info *mtd, int area,\r\nconst unsigned char *buffer,\r\nint offset, size_t count)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int omap2_onenand_read_bufferram(struct mtd_info *mtd, int area,\r\nunsigned char *buffer, int offset,\r\nsize_t count)\r\n{\r\nstruct omap2_onenand *c = container_of(mtd, struct omap2_onenand, mtd);\r\nstruct onenand_chip *this = mtd->priv;\r\ndma_addr_t dma_src, dma_dst;\r\nint bram_offset;\r\nbram_offset = omap2_onenand_bufferram_offset(mtd, area) + area + offset;\r\nif (1 || (c->dma_channel < 0) ||\r\n((void *) buffer >= (void *) high_memory) || (bram_offset & 3) ||\r\n(((unsigned int) buffer) & 3) || (count < 1024) || (count & 3)) {\r\nmemcpy(buffer, (__force void *)(this->base + bram_offset),\r\ncount);\r\nreturn 0;\r\n}\r\ndma_src = c->phys_base + bram_offset;\r\ndma_dst = dma_map_single(&c->pdev->dev, buffer, count,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(&c->pdev->dev, dma_dst)) {\r\ndev_err(&c->pdev->dev,\r\n"Couldn't DMA map a %d byte buffer\n",\r\ncount);\r\nreturn -1;\r\n}\r\nomap_set_dma_transfer_params(c->dma_channel, OMAP_DMA_DATA_TYPE_S32,\r\ncount / 4, 1, 0, 0, 0);\r\nomap_set_dma_src_params(c->dma_channel, 0, OMAP_DMA_AMODE_POST_INC,\r\ndma_src, 0, 0);\r\nomap_set_dma_dest_params(c->dma_channel, 0, OMAP_DMA_AMODE_POST_INC,\r\ndma_dst, 0, 0);\r\nreinit_completion(&c->dma_done);\r\nomap_start_dma(c->dma_channel);\r\nwait_for_completion(&c->dma_done);\r\ndma_unmap_single(&c->pdev->dev, dma_dst, count, DMA_FROM_DEVICE);\r\nreturn 0;\r\n}\r\nstatic int omap2_onenand_write_bufferram(struct mtd_info *mtd, int area,\r\nconst unsigned char *buffer,\r\nint offset, size_t count)\r\n{\r\nstruct omap2_onenand *c = container_of(mtd, struct omap2_onenand, mtd);\r\nstruct onenand_chip *this = mtd->priv;\r\ndma_addr_t dma_src, dma_dst;\r\nint bram_offset;\r\nbram_offset = omap2_onenand_bufferram_offset(mtd, area) + area + offset;\r\nif (1 || (c->dma_channel < 0) ||\r\n((void *) buffer >= (void *) high_memory) || (bram_offset & 3) ||\r\n(((unsigned int) buffer) & 3) || (count < 1024) || (count & 3)) {\r\nmemcpy((__force void *)(this->base + bram_offset), buffer,\r\ncount);\r\nreturn 0;\r\n}\r\ndma_src = dma_map_single(&c->pdev->dev, (void *) buffer, count,\r\nDMA_TO_DEVICE);\r\ndma_dst = c->phys_base + bram_offset;\r\nif (dma_mapping_error(&c->pdev->dev, dma_src)) {\r\ndev_err(&c->pdev->dev,\r\n"Couldn't DMA map a %d byte buffer\n",\r\ncount);\r\nreturn -1;\r\n}\r\nomap_set_dma_transfer_params(c->dma_channel, OMAP_DMA_DATA_TYPE_S16,\r\ncount / 2, 1, 0, 0, 0);\r\nomap_set_dma_src_params(c->dma_channel, 0, OMAP_DMA_AMODE_POST_INC,\r\ndma_src, 0, 0);\r\nomap_set_dma_dest_params(c->dma_channel, 0, OMAP_DMA_AMODE_POST_INC,\r\ndma_dst, 0, 0);\r\nreinit_completion(&c->dma_done);\r\nomap_start_dma(c->dma_channel);\r\nwait_for_completion(&c->dma_done);\r\ndma_unmap_single(&c->pdev->dev, dma_src, count, DMA_TO_DEVICE);\r\nreturn 0;\r\n}\r\nstatic int omap2_onenand_read_bufferram(struct mtd_info *mtd, int area,\r\nunsigned char *buffer, int offset,\r\nsize_t count)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int omap2_onenand_write_bufferram(struct mtd_info *mtd, int area,\r\nconst unsigned char *buffer,\r\nint offset, size_t count)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic void omap2_onenand_shutdown(struct platform_device *pdev)\r\n{\r\nstruct omap2_onenand *c = dev_get_drvdata(&pdev->dev);\r\nmemset((__force void *)c->onenand.base, 0, ONENAND_BUFRAM_SIZE);\r\n}\r\nstatic int omap2_onenand_enable(struct mtd_info *mtd)\r\n{\r\nint ret;\r\nstruct omap2_onenand *c = container_of(mtd, struct omap2_onenand, mtd);\r\nret = regulator_enable(c->regulator);\r\nif (ret != 0)\r\ndev_err(&c->pdev->dev, "can't enable regulator\n");\r\nreturn ret;\r\n}\r\nstatic int omap2_onenand_disable(struct mtd_info *mtd)\r\n{\r\nint ret;\r\nstruct omap2_onenand *c = container_of(mtd, struct omap2_onenand, mtd);\r\nret = regulator_disable(c->regulator);\r\nif (ret != 0)\r\ndev_err(&c->pdev->dev, "can't disable regulator\n");\r\nreturn ret;\r\n}\r\nstatic int omap2_onenand_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_onenand_platform_data *pdata;\r\nstruct omap2_onenand *c;\r\nstruct onenand_chip *this;\r\nint r;\r\nstruct resource *res;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "platform data missing\n");\r\nreturn -ENODEV;\r\n}\r\nc = kzalloc(sizeof(struct omap2_onenand), GFP_KERNEL);\r\nif (!c)\r\nreturn -ENOMEM;\r\ninit_completion(&c->irq_done);\r\ninit_completion(&c->dma_done);\r\nc->flags = pdata->flags;\r\nc->gpmc_cs = pdata->cs;\r\nc->gpio_irq = pdata->gpio_irq;\r\nc->dma_channel = pdata->dma_channel;\r\nif (c->dma_channel < 0) {\r\nc->gpio_irq = 0;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\nr = -EINVAL;\r\ndev_err(&pdev->dev, "error getting memory resource\n");\r\ngoto err_kfree;\r\n}\r\nc->phys_base = res->start;\r\nc->mem_size = resource_size(res);\r\nif (request_mem_region(c->phys_base, c->mem_size,\r\npdev->dev.driver->name) == NULL) {\r\ndev_err(&pdev->dev, "Cannot reserve memory region at 0x%08lx, size: 0x%x\n",\r\nc->phys_base, c->mem_size);\r\nr = -EBUSY;\r\ngoto err_kfree;\r\n}\r\nc->onenand.base = ioremap(c->phys_base, c->mem_size);\r\nif (c->onenand.base == NULL) {\r\nr = -ENOMEM;\r\ngoto err_release_mem_region;\r\n}\r\nif (pdata->onenand_setup != NULL) {\r\nr = pdata->onenand_setup(c->onenand.base, &c->freq);\r\nif (r < 0) {\r\ndev_err(&pdev->dev, "Onenand platform setup failed: "\r\n"%d\n", r);\r\ngoto err_iounmap;\r\n}\r\nc->setup = pdata->onenand_setup;\r\n}\r\nif (c->gpio_irq) {\r\nif ((r = gpio_request(c->gpio_irq, "OneNAND irq")) < 0) {\r\ndev_err(&pdev->dev, "Failed to request GPIO%d for "\r\n"OneNAND\n", c->gpio_irq);\r\ngoto err_iounmap;\r\n}\r\ngpio_direction_input(c->gpio_irq);\r\nif ((r = request_irq(gpio_to_irq(c->gpio_irq),\r\nomap2_onenand_interrupt, IRQF_TRIGGER_RISING,\r\npdev->dev.driver->name, c)) < 0)\r\ngoto err_release_gpio;\r\n}\r\nif (c->dma_channel >= 0) {\r\nr = omap_request_dma(0, pdev->dev.driver->name,\r\nomap2_onenand_dma_cb, (void *) c,\r\n&c->dma_channel);\r\nif (r == 0) {\r\nomap_set_dma_write_mode(c->dma_channel,\r\nOMAP_DMA_WRITE_NON_POSTED);\r\nomap_set_dma_src_data_pack(c->dma_channel, 1);\r\nomap_set_dma_src_burst_mode(c->dma_channel,\r\nOMAP_DMA_DATA_BURST_8);\r\nomap_set_dma_dest_data_pack(c->dma_channel, 1);\r\nomap_set_dma_dest_burst_mode(c->dma_channel,\r\nOMAP_DMA_DATA_BURST_8);\r\n} else {\r\ndev_info(&pdev->dev,\r\n"failed to allocate DMA for OneNAND, "\r\n"using PIO instead\n");\r\nc->dma_channel = -1;\r\n}\r\n}\r\ndev_info(&pdev->dev, "initializing on CS%d, phys base 0x%08lx, virtual "\r\n"base %p, freq %d MHz\n", c->gpmc_cs, c->phys_base,\r\nc->onenand.base, c->freq);\r\nc->pdev = pdev;\r\nc->mtd.priv = &c->onenand;\r\nc->mtd.dev.parent = &pdev->dev;\r\nmtd_set_of_node(&c->mtd, pdata->of_node);\r\nthis = &c->onenand;\r\nif (c->dma_channel >= 0) {\r\nthis->wait = omap2_onenand_wait;\r\nif (c->flags & ONENAND_IN_OMAP34XX) {\r\nthis->read_bufferram = omap3_onenand_read_bufferram;\r\nthis->write_bufferram = omap3_onenand_write_bufferram;\r\n} else {\r\nthis->read_bufferram = omap2_onenand_read_bufferram;\r\nthis->write_bufferram = omap2_onenand_write_bufferram;\r\n}\r\n}\r\nif (pdata->regulator_can_sleep) {\r\nc->regulator = regulator_get(&pdev->dev, "vonenand");\r\nif (IS_ERR(c->regulator)) {\r\ndev_err(&pdev->dev, "Failed to get regulator\n");\r\nr = PTR_ERR(c->regulator);\r\ngoto err_release_dma;\r\n}\r\nc->onenand.enable = omap2_onenand_enable;\r\nc->onenand.disable = omap2_onenand_disable;\r\n}\r\nif (pdata->skip_initial_unlocking)\r\nthis->options |= ONENAND_SKIP_INITIAL_UNLOCKING;\r\nif ((r = onenand_scan(&c->mtd, 1)) < 0)\r\ngoto err_release_regulator;\r\nr = mtd_device_register(&c->mtd, pdata ? pdata->parts : NULL,\r\npdata ? pdata->nr_parts : 0);\r\nif (r)\r\ngoto err_release_onenand;\r\nplatform_set_drvdata(pdev, c);\r\nreturn 0;\r\nerr_release_onenand:\r\nonenand_release(&c->mtd);\r\nerr_release_regulator:\r\nregulator_put(c->regulator);\r\nerr_release_dma:\r\nif (c->dma_channel != -1)\r\nomap_free_dma(c->dma_channel);\r\nif (c->gpio_irq)\r\nfree_irq(gpio_to_irq(c->gpio_irq), c);\r\nerr_release_gpio:\r\nif (c->gpio_irq)\r\ngpio_free(c->gpio_irq);\r\nerr_iounmap:\r\niounmap(c->onenand.base);\r\nerr_release_mem_region:\r\nrelease_mem_region(c->phys_base, c->mem_size);\r\nerr_kfree:\r\nkfree(c);\r\nreturn r;\r\n}\r\nstatic int omap2_onenand_remove(struct platform_device *pdev)\r\n{\r\nstruct omap2_onenand *c = dev_get_drvdata(&pdev->dev);\r\nonenand_release(&c->mtd);\r\nregulator_put(c->regulator);\r\nif (c->dma_channel != -1)\r\nomap_free_dma(c->dma_channel);\r\nomap2_onenand_shutdown(pdev);\r\nif (c->gpio_irq) {\r\nfree_irq(gpio_to_irq(c->gpio_irq), c);\r\ngpio_free(c->gpio_irq);\r\n}\r\niounmap(c->onenand.base);\r\nrelease_mem_region(c->phys_base, c->mem_size);\r\nkfree(c);\r\nreturn 0;\r\n}
