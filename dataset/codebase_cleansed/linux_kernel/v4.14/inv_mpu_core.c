int inv_mpu6050_switch_engine(struct inv_mpu6050_state *st, bool en, u32 mask)\r\n{\r\nunsigned int d, mgmt_1;\r\nint result;\r\nif (mask == INV_MPU6050_BIT_PWR_GYRO_STBY) {\r\nresult = regmap_read(st->map, st->reg->pwr_mgmt_1, &mgmt_1);\r\nif (result)\r\nreturn result;\r\nmgmt_1 &= ~INV_MPU6050_BIT_CLK_MASK;\r\n}\r\nif ((mask == INV_MPU6050_BIT_PWR_GYRO_STBY) && (!en)) {\r\nmgmt_1 |= INV_CLK_INTERNAL;\r\nresult = regmap_write(st->map, st->reg->pwr_mgmt_1, mgmt_1);\r\nif (result)\r\nreturn result;\r\n}\r\nresult = regmap_read(st->map, st->reg->pwr_mgmt_2, &d);\r\nif (result)\r\nreturn result;\r\nif (en)\r\nd &= ~mask;\r\nelse\r\nd |= mask;\r\nresult = regmap_write(st->map, st->reg->pwr_mgmt_2, d);\r\nif (result)\r\nreturn result;\r\nif (en) {\r\nmsleep(INV_MPU6050_TEMP_UP_TIME);\r\nif (mask == INV_MPU6050_BIT_PWR_GYRO_STBY) {\r\nmgmt_1 |= INV_CLK_PLL;\r\nresult = regmap_write(st->map,\r\nst->reg->pwr_mgmt_1, mgmt_1);\r\nif (result)\r\nreturn result;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint inv_mpu6050_set_power_itg(struct inv_mpu6050_state *st, bool power_on)\r\n{\r\nint result = 0;\r\nif (power_on) {\r\nif (!st->powerup_count)\r\nresult = regmap_write(st->map, st->reg->pwr_mgmt_1, 0);\r\nif (!result)\r\nst->powerup_count++;\r\n} else {\r\nst->powerup_count--;\r\nif (!st->powerup_count)\r\nresult = regmap_write(st->map, st->reg->pwr_mgmt_1,\r\nINV_MPU6050_BIT_SLEEP);\r\n}\r\nif (result)\r\nreturn result;\r\nif (power_on)\r\nusleep_range(INV_MPU6050_REG_UP_TIME_MIN,\r\nINV_MPU6050_REG_UP_TIME_MAX);\r\nreturn 0;\r\n}\r\nstatic int inv_mpu6050_set_lpf_regs(struct inv_mpu6050_state *st,\r\nenum inv_mpu6050_filter_e val)\r\n{\r\nint result;\r\nresult = regmap_write(st->map, st->reg->lpf, val);\r\nif (result)\r\nreturn result;\r\nswitch (st->chip_type) {\r\ncase INV_MPU6050:\r\ncase INV_MPU6000:\r\ncase INV_MPU9150:\r\nresult = 0;\r\nbreak;\r\ndefault:\r\nresult = regmap_write(st->map, st->reg->accel_lpf, val);\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int inv_mpu6050_init_config(struct iio_dev *indio_dev)\r\n{\r\nint result;\r\nu8 d;\r\nstruct inv_mpu6050_state *st = iio_priv(indio_dev);\r\nresult = inv_mpu6050_set_power_itg(st, true);\r\nif (result)\r\nreturn result;\r\nd = (INV_MPU6050_FSR_2000DPS << INV_MPU6050_GYRO_CONFIG_FSR_SHIFT);\r\nresult = regmap_write(st->map, st->reg->gyro_config, d);\r\nif (result)\r\nreturn result;\r\nresult = inv_mpu6050_set_lpf_regs(st, INV_MPU6050_FILTER_20HZ);\r\nif (result)\r\nreturn result;\r\nd = INV_MPU6050_ONE_K_HZ / INV_MPU6050_INIT_FIFO_RATE - 1;\r\nresult = regmap_write(st->map, st->reg->sample_rate_div, d);\r\nif (result)\r\nreturn result;\r\nd = (INV_MPU6050_FS_02G << INV_MPU6050_ACCL_CONFIG_FSR_SHIFT);\r\nresult = regmap_write(st->map, st->reg->accl_config, d);\r\nif (result)\r\nreturn result;\r\nmemcpy(&st->chip_config, hw_info[st->chip_type].config,\r\nsizeof(struct inv_mpu6050_chip_config));\r\nresult = inv_mpu6050_set_power_itg(st, false);\r\nreturn result;\r\n}\r\nstatic int inv_mpu6050_sensor_set(struct inv_mpu6050_state *st, int reg,\r\nint axis, int val)\r\n{\r\nint ind, result;\r\n__be16 d = cpu_to_be16(val);\r\nind = (axis - IIO_MOD_X) * 2;\r\nresult = regmap_bulk_write(st->map, reg + ind, (u8 *)&d, 2);\r\nif (result)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int inv_mpu6050_sensor_show(struct inv_mpu6050_state *st, int reg,\r\nint axis, int *val)\r\n{\r\nint ind, result;\r\n__be16 d;\r\nind = (axis - IIO_MOD_X) * 2;\r\nresult = regmap_bulk_read(st->map, reg + ind, (u8 *)&d, 2);\r\nif (result)\r\nreturn -EINVAL;\r\n*val = (short)be16_to_cpup(&d);\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int\r\ninv_mpu6050_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct inv_mpu6050_state *st = iio_priv(indio_dev);\r\nint ret = 0;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\n{\r\nint result;\r\nret = IIO_VAL_INT;\r\nmutex_lock(&st->lock);\r\nresult = iio_device_claim_direct_mode(indio_dev);\r\nif (result)\r\ngoto error_read_raw_unlock;\r\nresult = inv_mpu6050_set_power_itg(st, true);\r\nif (result)\r\ngoto error_read_raw_release;\r\nswitch (chan->type) {\r\ncase IIO_ANGL_VEL:\r\nresult = inv_mpu6050_switch_engine(st, true,\r\nINV_MPU6050_BIT_PWR_GYRO_STBY);\r\nif (result)\r\ngoto error_read_raw_power_off;\r\nret = inv_mpu6050_sensor_show(st, st->reg->raw_gyro,\r\nchan->channel2, val);\r\nresult = inv_mpu6050_switch_engine(st, false,\r\nINV_MPU6050_BIT_PWR_GYRO_STBY);\r\nif (result)\r\ngoto error_read_raw_power_off;\r\nbreak;\r\ncase IIO_ACCEL:\r\nresult = inv_mpu6050_switch_engine(st, true,\r\nINV_MPU6050_BIT_PWR_ACCL_STBY);\r\nif (result)\r\ngoto error_read_raw_power_off;\r\nret = inv_mpu6050_sensor_show(st, st->reg->raw_accl,\r\nchan->channel2, val);\r\nresult = inv_mpu6050_switch_engine(st, false,\r\nINV_MPU6050_BIT_PWR_ACCL_STBY);\r\nif (result)\r\ngoto error_read_raw_power_off;\r\nbreak;\r\ncase IIO_TEMP:\r\nmsleep(INV_MPU6050_SENSOR_UP_TIME);\r\nret = inv_mpu6050_sensor_show(st, st->reg->temperature,\r\nIIO_MOD_X, val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nerror_read_raw_power_off:\r\nresult |= inv_mpu6050_set_power_itg(st, false);\r\nerror_read_raw_release:\r\niio_device_release_direct_mode(indio_dev);\r\nerror_read_raw_unlock:\r\nmutex_unlock(&st->lock);\r\nif (result)\r\nreturn result;\r\nreturn ret;\r\n}\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_ANGL_VEL:\r\nmutex_lock(&st->lock);\r\n*val = 0;\r\n*val2 = gyro_scale_6050[st->chip_config.fsr];\r\nmutex_unlock(&st->lock);\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\ncase IIO_ACCEL:\r\nmutex_lock(&st->lock);\r\n*val = 0;\r\n*val2 = accel_scale[st->chip_config.accl_fs];\r\nmutex_unlock(&st->lock);\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_TEMP:\r\n*val = 0;\r\n*val2 = INV_MPU6050_TEMP_SCALE;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_OFFSET:\r\nswitch (chan->type) {\r\ncase IIO_TEMP:\r\n*val = INV_MPU6050_TEMP_OFFSET;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nswitch (chan->type) {\r\ncase IIO_ANGL_VEL:\r\nmutex_lock(&st->lock);\r\nret = inv_mpu6050_sensor_show(st, st->reg->gyro_offset,\r\nchan->channel2, val);\r\nmutex_unlock(&st->lock);\r\nreturn IIO_VAL_INT;\r\ncase IIO_ACCEL:\r\nmutex_lock(&st->lock);\r\nret = inv_mpu6050_sensor_show(st, st->reg->accl_offset,\r\nchan->channel2, val);\r\nmutex_unlock(&st->lock);\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int inv_mpu6050_write_gyro_scale(struct inv_mpu6050_state *st, int val)\r\n{\r\nint result, i;\r\nu8 d;\r\nfor (i = 0; i < ARRAY_SIZE(gyro_scale_6050); ++i) {\r\nif (gyro_scale_6050[i] == val) {\r\nd = (i << INV_MPU6050_GYRO_CONFIG_FSR_SHIFT);\r\nresult = regmap_write(st->map, st->reg->gyro_config, d);\r\nif (result)\r\nreturn result;\r\nst->chip_config.fsr = i;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int inv_write_raw_get_fmt(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, long mask)\r\n{\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_ANGL_VEL:\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\ndefault:\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\ndefault:\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int inv_mpu6050_write_accel_scale(struct inv_mpu6050_state *st, int val)\r\n{\r\nint result, i;\r\nu8 d;\r\nfor (i = 0; i < ARRAY_SIZE(accel_scale); ++i) {\r\nif (accel_scale[i] == val) {\r\nd = (i << INV_MPU6050_ACCL_CONFIG_FSR_SHIFT);\r\nresult = regmap_write(st->map, st->reg->accl_config, d);\r\nif (result)\r\nreturn result;\r\nst->chip_config.accl_fs = i;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int inv_mpu6050_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct inv_mpu6050_state *st = iio_priv(indio_dev);\r\nint result;\r\nmutex_lock(&st->lock);\r\nresult = iio_device_claim_direct_mode(indio_dev);\r\nif (result)\r\ngoto error_write_raw_unlock;\r\nresult = inv_mpu6050_set_power_itg(st, true);\r\nif (result)\r\ngoto error_write_raw_release;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_ANGL_VEL:\r\nresult = inv_mpu6050_write_gyro_scale(st, val2);\r\nbreak;\r\ncase IIO_ACCEL:\r\nresult = inv_mpu6050_write_accel_scale(st, val2);\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nswitch (chan->type) {\r\ncase IIO_ANGL_VEL:\r\nresult = inv_mpu6050_sensor_set(st,\r\nst->reg->gyro_offset,\r\nchan->channel2, val);\r\nbreak;\r\ncase IIO_ACCEL:\r\nresult = inv_mpu6050_sensor_set(st,\r\nst->reg->accl_offset,\r\nchan->channel2, val);\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\n}\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nresult |= inv_mpu6050_set_power_itg(st, false);\r\nerror_write_raw_release:\r\niio_device_release_direct_mode(indio_dev);\r\nerror_write_raw_unlock:\r\nmutex_unlock(&st->lock);\r\nreturn result;\r\n}\r\nstatic int inv_mpu6050_set_lpf(struct inv_mpu6050_state *st, int rate)\r\n{\r\nconst int hz[] = {188, 98, 42, 20, 10, 5};\r\nconst int d[] = {INV_MPU6050_FILTER_188HZ, INV_MPU6050_FILTER_98HZ,\r\nINV_MPU6050_FILTER_42HZ, INV_MPU6050_FILTER_20HZ,\r\nINV_MPU6050_FILTER_10HZ, INV_MPU6050_FILTER_5HZ};\r\nint i, h, result;\r\nu8 data;\r\nh = (rate >> 1);\r\ni = 0;\r\nwhile ((h < hz[i]) && (i < ARRAY_SIZE(d) - 1))\r\ni++;\r\ndata = d[i];\r\nresult = inv_mpu6050_set_lpf_regs(st, data);\r\nif (result)\r\nreturn result;\r\nst->chip_config.lpf = data;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\ninv_mpu6050_fifo_rate_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\ns32 fifo_rate;\r\nu8 d;\r\nint result;\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct inv_mpu6050_state *st = iio_priv(indio_dev);\r\nif (kstrtoint(buf, 10, &fifo_rate))\r\nreturn -EINVAL;\r\nif (fifo_rate < INV_MPU6050_MIN_FIFO_RATE ||\r\nfifo_rate > INV_MPU6050_MAX_FIFO_RATE)\r\nreturn -EINVAL;\r\nmutex_lock(&st->lock);\r\nif (fifo_rate == st->chip_config.fifo_rate) {\r\nresult = 0;\r\ngoto fifo_rate_fail_unlock;\r\n}\r\nresult = iio_device_claim_direct_mode(indio_dev);\r\nif (result)\r\ngoto fifo_rate_fail_unlock;\r\nresult = inv_mpu6050_set_power_itg(st, true);\r\nif (result)\r\ngoto fifo_rate_fail_release;\r\nd = INV_MPU6050_ONE_K_HZ / fifo_rate - 1;\r\nresult = regmap_write(st->map, st->reg->sample_rate_div, d);\r\nif (result)\r\ngoto fifo_rate_fail_power_off;\r\nst->chip_config.fifo_rate = fifo_rate;\r\nresult = inv_mpu6050_set_lpf(st, fifo_rate);\r\nif (result)\r\ngoto fifo_rate_fail_power_off;\r\nfifo_rate_fail_power_off:\r\nresult |= inv_mpu6050_set_power_itg(st, false);\r\nfifo_rate_fail_release:\r\niio_device_release_direct_mode(indio_dev);\r\nfifo_rate_fail_unlock:\r\nmutex_unlock(&st->lock);\r\nif (result)\r\nreturn result;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\ninv_fifo_rate_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct inv_mpu6050_state *st = iio_priv(dev_to_iio_dev(dev));\r\nunsigned fifo_rate;\r\nmutex_lock(&st->lock);\r\nfifo_rate = st->chip_config.fifo_rate;\r\nmutex_unlock(&st->lock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", fifo_rate);\r\n}\r\nstatic ssize_t inv_attr_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct inv_mpu6050_state *st = iio_priv(dev_to_iio_dev(dev));\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\ns8 *m;\r\nswitch (this_attr->address) {\r\ncase ATTR_GYRO_MATRIX:\r\ncase ATTR_ACCL_MATRIX:\r\nm = st->plat_data.orientation;\r\nreturn scnprintf(buf, PAGE_SIZE,\r\n"%d, %d, %d; %d, %d, %d; %d, %d, %d\n",\r\nm[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int inv_mpu6050_validate_trigger(struct iio_dev *indio_dev,\r\nstruct iio_trigger *trig)\r\n{\r\nstruct inv_mpu6050_state *st = iio_priv(indio_dev);\r\nif (st->trig != trig)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic const struct iio_mount_matrix *\r\ninv_get_mount_matrix(const struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan)\r\n{\r\nreturn &((struct inv_mpu6050_state *)iio_priv(indio_dev))->orientation;\r\n}\r\nstatic int inv_check_and_setup_chip(struct inv_mpu6050_state *st)\r\n{\r\nint result;\r\nunsigned int regval;\r\nint i;\r\nst->hw = &hw_info[st->chip_type];\r\nst->reg = hw_info[st->chip_type].reg;\r\nresult = regmap_read(st->map, INV_MPU6050_REG_WHOAMI, &regval);\r\nif (result)\r\nreturn result;\r\nif (regval != st->hw->whoami) {\r\nfor (i = 0; i < INV_NUM_PARTS; ++i) {\r\nif (regval == hw_info[i].whoami) {\r\ndev_warn(regmap_get_device(st->map),\r\n"whoami mismatch got %#02x (%s)"\r\n"expected %#02hhx (%s)\n",\r\nregval, hw_info[i].name,\r\nst->hw->whoami, st->hw->name);\r\nbreak;\r\n}\r\n}\r\nif (i >= INV_NUM_PARTS) {\r\ndev_err(regmap_get_device(st->map),\r\n"invalid whoami %#02x expected %#02hhx (%s)\n",\r\nregval, st->hw->whoami, st->hw->name);\r\nreturn -ENODEV;\r\n}\r\n}\r\nresult = regmap_write(st->map, st->reg->pwr_mgmt_1,\r\nINV_MPU6050_BIT_H_RESET);\r\nif (result)\r\nreturn result;\r\nmsleep(INV_MPU6050_POWER_UP_TIME);\r\nresult = inv_mpu6050_set_power_itg(st, false);\r\nif (result)\r\nreturn result;\r\nresult = inv_mpu6050_set_power_itg(st, true);\r\nif (result)\r\nreturn result;\r\nresult = inv_mpu6050_switch_engine(st, false,\r\nINV_MPU6050_BIT_PWR_ACCL_STBY);\r\nif (result)\r\nreturn result;\r\nresult = inv_mpu6050_switch_engine(st, false,\r\nINV_MPU6050_BIT_PWR_GYRO_STBY);\r\nif (result)\r\nreturn result;\r\nreturn 0;\r\n}\r\nint inv_mpu_core_probe(struct regmap *regmap, int irq, const char *name,\r\nint (*inv_mpu_bus_setup)(struct iio_dev *), int chip_type)\r\n{\r\nstruct inv_mpu6050_state *st;\r\nstruct iio_dev *indio_dev;\r\nstruct inv_mpu6050_platform_data *pdata;\r\nstruct device *dev = regmap_get_device(regmap);\r\nint result;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nBUILD_BUG_ON(ARRAY_SIZE(hw_info) != INV_NUM_PARTS);\r\nif (chip_type < 0 || chip_type >= INV_NUM_PARTS) {\r\ndev_err(dev, "Bad invensense chip_type=%d name=%s\n",\r\nchip_type, name);\r\nreturn -ENODEV;\r\n}\r\nst = iio_priv(indio_dev);\r\nmutex_init(&st->lock);\r\nst->chip_type = chip_type;\r\nst->powerup_count = 0;\r\nst->irq = irq;\r\nst->map = regmap;\r\npdata = dev_get_platdata(dev);\r\nif (!pdata) {\r\nresult = of_iio_read_mount_matrix(dev, "mount-matrix",\r\n&st->orientation);\r\nif (result) {\r\ndev_err(dev, "Failed to retrieve mounting matrix %d\n",\r\nresult);\r\nreturn result;\r\n}\r\n} else {\r\nst->plat_data = *pdata;\r\n}\r\nresult = inv_check_and_setup_chip(st);\r\nif (result)\r\nreturn result;\r\nif (inv_mpu_bus_setup)\r\ninv_mpu_bus_setup(indio_dev);\r\nresult = inv_mpu6050_init_config(indio_dev);\r\nif (result) {\r\ndev_err(dev, "Could not initialize device.\n");\r\nreturn result;\r\n}\r\ndev_set_drvdata(dev, indio_dev);\r\nindio_dev->dev.parent = dev;\r\nif (name)\r\nindio_dev->name = name;\r\nelse\r\nindio_dev->name = dev_name(dev);\r\nindio_dev->channels = inv_mpu_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(inv_mpu_channels);\r\nindio_dev->info = &mpu_info;\r\nindio_dev->modes = INDIO_BUFFER_TRIGGERED;\r\nresult = iio_triggered_buffer_setup(indio_dev,\r\ninv_mpu6050_irq_handler,\r\ninv_mpu6050_read_fifo,\r\nNULL);\r\nif (result) {\r\ndev_err(dev, "configure buffer fail %d\n", result);\r\nreturn result;\r\n}\r\nresult = inv_mpu6050_probe_trigger(indio_dev);\r\nif (result) {\r\ndev_err(dev, "trigger probe fail %d\n", result);\r\ngoto out_unreg_ring;\r\n}\r\nINIT_KFIFO(st->timestamps);\r\nspin_lock_init(&st->time_stamp_lock);\r\nresult = iio_device_register(indio_dev);\r\nif (result) {\r\ndev_err(dev, "IIO register fail %d\n", result);\r\ngoto out_remove_trigger;\r\n}\r\nreturn 0;\r\nout_remove_trigger:\r\ninv_mpu6050_remove_trigger(st);\r\nout_unreg_ring:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nreturn result;\r\n}\r\nint inv_mpu_core_remove(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\niio_device_unregister(indio_dev);\r\ninv_mpu6050_remove_trigger(iio_priv(indio_dev));\r\niio_triggered_buffer_cleanup(indio_dev);\r\nreturn 0;\r\n}\r\nstatic int inv_mpu_resume(struct device *dev)\r\n{\r\nstruct inv_mpu6050_state *st = iio_priv(dev_get_drvdata(dev));\r\nint result;\r\nmutex_lock(&st->lock);\r\nresult = inv_mpu6050_set_power_itg(st, true);\r\nmutex_unlock(&st->lock);\r\nreturn result;\r\n}\r\nstatic int inv_mpu_suspend(struct device *dev)\r\n{\r\nstruct inv_mpu6050_state *st = iio_priv(dev_get_drvdata(dev));\r\nint result;\r\nmutex_lock(&st->lock);\r\nresult = inv_mpu6050_set_power_itg(st, false);\r\nmutex_unlock(&st->lock);\r\nreturn result;\r\n}
