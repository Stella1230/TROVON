static u8 dp_link_status(const u8 link_status[DP_LINK_STATUS_SIZE], int r)\r\n{\r\nreturn link_status[r - DP_LANE0_1_STATUS];\r\n}\r\nstatic u8 dp_get_lane_status(const u8 link_status[DP_LINK_STATUS_SIZE],\r\nint lane)\r\n{\r\nint i = DP_LANE0_1_STATUS + (lane >> 1);\r\nint s = (lane & 1) * 4;\r\nu8 l = dp_link_status(link_status, i);\r\nreturn (l >> s) & 0xf;\r\n}\r\nbool drm_dp_channel_eq_ok(const u8 link_status[DP_LINK_STATUS_SIZE],\r\nint lane_count)\r\n{\r\nu8 lane_align;\r\nu8 lane_status;\r\nint lane;\r\nlane_align = dp_link_status(link_status,\r\nDP_LANE_ALIGN_STATUS_UPDATED);\r\nif ((lane_align & DP_INTERLANE_ALIGN_DONE) == 0)\r\nreturn false;\r\nfor (lane = 0; lane < lane_count; lane++) {\r\nlane_status = dp_get_lane_status(link_status, lane);\r\nif ((lane_status & DP_CHANNEL_EQ_BITS) != DP_CHANNEL_EQ_BITS)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nbool drm_dp_clock_recovery_ok(const u8 link_status[DP_LINK_STATUS_SIZE],\r\nint lane_count)\r\n{\r\nint lane;\r\nu8 lane_status;\r\nfor (lane = 0; lane < lane_count; lane++) {\r\nlane_status = dp_get_lane_status(link_status, lane);\r\nif ((lane_status & DP_LANE_CR_DONE) == 0)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nu8 drm_dp_get_adjust_request_voltage(const u8 link_status[DP_LINK_STATUS_SIZE],\r\nint lane)\r\n{\r\nint i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);\r\nint s = ((lane & 1) ?\r\nDP_ADJUST_VOLTAGE_SWING_LANE1_SHIFT :\r\nDP_ADJUST_VOLTAGE_SWING_LANE0_SHIFT);\r\nu8 l = dp_link_status(link_status, i);\r\nreturn ((l >> s) & 0x3) << DP_TRAIN_VOLTAGE_SWING_SHIFT;\r\n}\r\nu8 drm_dp_get_adjust_request_pre_emphasis(const u8 link_status[DP_LINK_STATUS_SIZE],\r\nint lane)\r\n{\r\nint i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);\r\nint s = ((lane & 1) ?\r\nDP_ADJUST_PRE_EMPHASIS_LANE1_SHIFT :\r\nDP_ADJUST_PRE_EMPHASIS_LANE0_SHIFT);\r\nu8 l = dp_link_status(link_status, i);\r\nreturn ((l >> s) & 0x3) << DP_TRAIN_PRE_EMPHASIS_SHIFT;\r\n}\r\nvoid drm_dp_link_train_clock_recovery_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE]) {\r\nif (dpcd[DP_TRAINING_AUX_RD_INTERVAL] == 0)\r\nudelay(100);\r\nelse\r\nmdelay(dpcd[DP_TRAINING_AUX_RD_INTERVAL] * 4);\r\n}\r\nvoid drm_dp_link_train_channel_eq_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE]) {\r\nif (dpcd[DP_TRAINING_AUX_RD_INTERVAL] == 0)\r\nudelay(400);\r\nelse\r\nmdelay(dpcd[DP_TRAINING_AUX_RD_INTERVAL] * 4);\r\n}\r\nu8 drm_dp_link_rate_to_bw_code(int link_rate)\r\n{\r\nswitch (link_rate) {\r\ncase 162000:\r\ndefault:\r\nreturn DP_LINK_BW_1_62;\r\ncase 270000:\r\nreturn DP_LINK_BW_2_7;\r\ncase 540000:\r\nreturn DP_LINK_BW_5_4;\r\n}\r\n}\r\nint drm_dp_bw_code_to_link_rate(u8 link_bw)\r\n{\r\nswitch (link_bw) {\r\ncase DP_LINK_BW_1_62:\r\ndefault:\r\nreturn 162000;\r\ncase DP_LINK_BW_2_7:\r\nreturn 270000;\r\ncase DP_LINK_BW_5_4:\r\nreturn 540000;\r\n}\r\n}\r\nstatic int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,\r\nunsigned int offset, void *buffer, size_t size)\r\n{\r\nstruct drm_dp_aux_msg msg;\r\nunsigned int retry, native_reply;\r\nint err = 0, ret = 0;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.address = offset;\r\nmsg.request = request;\r\nmsg.buffer = buffer;\r\nmsg.size = size;\r\nmutex_lock(&aux->hw_mutex);\r\nfor (retry = 0; retry < 32; retry++) {\r\nif (ret != 0 && ret != -ETIMEDOUT) {\r\nusleep_range(AUX_RETRY_INTERVAL,\r\nAUX_RETRY_INTERVAL + 100);\r\n}\r\nret = aux->transfer(aux, &msg);\r\nif (ret >= 0) {\r\nnative_reply = msg.reply & DP_AUX_NATIVE_REPLY_MASK;\r\nif (native_reply == DP_AUX_NATIVE_REPLY_ACK) {\r\nif (ret == size)\r\ngoto unlock;\r\nret = -EPROTO;\r\n} else\r\nret = -EIO;\r\n}\r\nif (!err)\r\nerr = ret;\r\n}\r\nDRM_DEBUG_KMS("Too many retries, giving up. First error: %d\n", err);\r\nret = err;\r\nunlock:\r\nmutex_unlock(&aux->hw_mutex);\r\nreturn ret;\r\n}\r\nssize_t drm_dp_dpcd_read(struct drm_dp_aux *aux, unsigned int offset,\r\nvoid *buffer, size_t size)\r\n{\r\nint ret;\r\nret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, DP_DPCD_REV, buffer,\r\n1);\r\nif (ret != 1)\r\nreturn ret;\r\nreturn drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, offset, buffer,\r\nsize);\r\n}\r\nssize_t drm_dp_dpcd_write(struct drm_dp_aux *aux, unsigned int offset,\r\nvoid *buffer, size_t size)\r\n{\r\nreturn drm_dp_dpcd_access(aux, DP_AUX_NATIVE_WRITE, offset, buffer,\r\nsize);\r\n}\r\nint drm_dp_dpcd_read_link_status(struct drm_dp_aux *aux,\r\nu8 status[DP_LINK_STATUS_SIZE])\r\n{\r\nreturn drm_dp_dpcd_read(aux, DP_LANE0_1_STATUS, status,\r\nDP_LINK_STATUS_SIZE);\r\n}\r\nint drm_dp_link_probe(struct drm_dp_aux *aux, struct drm_dp_link *link)\r\n{\r\nu8 values[3];\r\nint err;\r\nmemset(link, 0, sizeof(*link));\r\nerr = drm_dp_dpcd_read(aux, DP_DPCD_REV, values, sizeof(values));\r\nif (err < 0)\r\nreturn err;\r\nlink->revision = values[0];\r\nlink->rate = drm_dp_bw_code_to_link_rate(values[1]);\r\nlink->num_lanes = values[2] & DP_MAX_LANE_COUNT_MASK;\r\nif (values[2] & DP_ENHANCED_FRAME_CAP)\r\nlink->capabilities |= DP_LINK_CAP_ENHANCED_FRAMING;\r\nreturn 0;\r\n}\r\nint drm_dp_link_power_up(struct drm_dp_aux *aux, struct drm_dp_link *link)\r\n{\r\nu8 value;\r\nint err;\r\nif (link->revision < 0x11)\r\nreturn 0;\r\nerr = drm_dp_dpcd_readb(aux, DP_SET_POWER, &value);\r\nif (err < 0)\r\nreturn err;\r\nvalue &= ~DP_SET_POWER_MASK;\r\nvalue |= DP_SET_POWER_D0;\r\nerr = drm_dp_dpcd_writeb(aux, DP_SET_POWER, value);\r\nif (err < 0)\r\nreturn err;\r\nusleep_range(1000, 2000);\r\nreturn 0;\r\n}\r\nint drm_dp_link_power_down(struct drm_dp_aux *aux, struct drm_dp_link *link)\r\n{\r\nu8 value;\r\nint err;\r\nif (link->revision < 0x11)\r\nreturn 0;\r\nerr = drm_dp_dpcd_readb(aux, DP_SET_POWER, &value);\r\nif (err < 0)\r\nreturn err;\r\nvalue &= ~DP_SET_POWER_MASK;\r\nvalue |= DP_SET_POWER_D3;\r\nerr = drm_dp_dpcd_writeb(aux, DP_SET_POWER, value);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint drm_dp_link_configure(struct drm_dp_aux *aux, struct drm_dp_link *link)\r\n{\r\nu8 values[2];\r\nint err;\r\nvalues[0] = drm_dp_link_rate_to_bw_code(link->rate);\r\nvalues[1] = link->num_lanes;\r\nif (link->capabilities & DP_LINK_CAP_ENHANCED_FRAMING)\r\nvalues[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\r\nerr = drm_dp_dpcd_write(aux, DP_LINK_BW_SET, values, sizeof(values));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint drm_dp_downstream_max_clock(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\r\nconst u8 port_cap[4])\r\n{\r\nint type = port_cap[0] & DP_DS_PORT_TYPE_MASK;\r\nbool detailed_cap_info = dpcd[DP_DOWNSTREAMPORT_PRESENT] &\r\nDP_DETAILED_CAP_INFO_AVAILABLE;\r\nif (!detailed_cap_info)\r\nreturn 0;\r\nswitch (type) {\r\ncase DP_DS_PORT_TYPE_VGA:\r\nreturn port_cap[1] * 8 * 1000;\r\ncase DP_DS_PORT_TYPE_DVI:\r\ncase DP_DS_PORT_TYPE_HDMI:\r\ncase DP_DS_PORT_TYPE_DP_DUALMODE:\r\nreturn port_cap[1] * 2500;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint drm_dp_downstream_max_bpc(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\r\nconst u8 port_cap[4])\r\n{\r\nint type = port_cap[0] & DP_DS_PORT_TYPE_MASK;\r\nbool detailed_cap_info = dpcd[DP_DOWNSTREAMPORT_PRESENT] &\r\nDP_DETAILED_CAP_INFO_AVAILABLE;\r\nint bpc;\r\nif (!detailed_cap_info)\r\nreturn 0;\r\nswitch (type) {\r\ncase DP_DS_PORT_TYPE_VGA:\r\ncase DP_DS_PORT_TYPE_DVI:\r\ncase DP_DS_PORT_TYPE_HDMI:\r\ncase DP_DS_PORT_TYPE_DP_DUALMODE:\r\nbpc = port_cap[2] & DP_DS_MAX_BPC_MASK;\r\nswitch (bpc) {\r\ncase DP_DS_8BPC:\r\nreturn 8;\r\ncase DP_DS_10BPC:\r\nreturn 10;\r\ncase DP_DS_12BPC:\r\nreturn 12;\r\ncase DP_DS_16BPC:\r\nreturn 16;\r\n}\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint drm_dp_downstream_id(struct drm_dp_aux *aux, char id[6])\r\n{\r\nreturn drm_dp_dpcd_read(aux, DP_BRANCH_ID, id, 6);\r\n}\r\nvoid drm_dp_downstream_debug(struct seq_file *m,\r\nconst u8 dpcd[DP_RECEIVER_CAP_SIZE],\r\nconst u8 port_cap[4], struct drm_dp_aux *aux)\r\n{\r\nbool detailed_cap_info = dpcd[DP_DOWNSTREAMPORT_PRESENT] &\r\nDP_DETAILED_CAP_INFO_AVAILABLE;\r\nint clk;\r\nint bpc;\r\nchar id[7];\r\nint len;\r\nuint8_t rev[2];\r\nint type = port_cap[0] & DP_DS_PORT_TYPE_MASK;\r\nbool branch_device = dpcd[DP_DOWNSTREAMPORT_PRESENT] &\r\nDP_DWN_STRM_PORT_PRESENT;\r\nseq_printf(m, "\tDP branch device present: %s\n",\r\nbranch_device ? "yes" : "no");\r\nif (!branch_device)\r\nreturn;\r\nswitch (type) {\r\ncase DP_DS_PORT_TYPE_DP:\r\nseq_puts(m, "\t\tType: DisplayPort\n");\r\nbreak;\r\ncase DP_DS_PORT_TYPE_VGA:\r\nseq_puts(m, "\t\tType: VGA\n");\r\nbreak;\r\ncase DP_DS_PORT_TYPE_DVI:\r\nseq_puts(m, "\t\tType: DVI\n");\r\nbreak;\r\ncase DP_DS_PORT_TYPE_HDMI:\r\nseq_puts(m, "\t\tType: HDMI\n");\r\nbreak;\r\ncase DP_DS_PORT_TYPE_NON_EDID:\r\nseq_puts(m, "\t\tType: others without EDID support\n");\r\nbreak;\r\ncase DP_DS_PORT_TYPE_DP_DUALMODE:\r\nseq_puts(m, "\t\tType: DP++\n");\r\nbreak;\r\ncase DP_DS_PORT_TYPE_WIRELESS:\r\nseq_puts(m, "\t\tType: Wireless\n");\r\nbreak;\r\ndefault:\r\nseq_puts(m, "\t\tType: N/A\n");\r\n}\r\nmemset(id, 0, sizeof(id));\r\ndrm_dp_downstream_id(aux, id);\r\nseq_printf(m, "\t\tID: %s\n", id);\r\nlen = drm_dp_dpcd_read(aux, DP_BRANCH_HW_REV, &rev[0], 1);\r\nif (len > 0)\r\nseq_printf(m, "\t\tHW: %d.%d\n",\r\n(rev[0] & 0xf0) >> 4, rev[0] & 0xf);\r\nlen = drm_dp_dpcd_read(aux, DP_BRANCH_SW_REV, rev, 2);\r\nif (len > 0)\r\nseq_printf(m, "\t\tSW: %d.%d\n", rev[0], rev[1]);\r\nif (detailed_cap_info) {\r\nclk = drm_dp_downstream_max_clock(dpcd, port_cap);\r\nif (clk > 0) {\r\nif (type == DP_DS_PORT_TYPE_VGA)\r\nseq_printf(m, "\t\tMax dot clock: %d kHz\n", clk);\r\nelse\r\nseq_printf(m, "\t\tMax TMDS clock: %d kHz\n", clk);\r\n}\r\nbpc = drm_dp_downstream_max_bpc(dpcd, port_cap);\r\nif (bpc > 0)\r\nseq_printf(m, "\t\tMax bpc: %d\n", bpc);\r\n}\r\n}\r\nstatic u32 drm_dp_i2c_functionality(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\r\nI2C_FUNC_SMBUS_READ_BLOCK_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_PROC_CALL |\r\nI2C_FUNC_10BIT_ADDR;\r\n}\r\nstatic void drm_dp_i2c_msg_write_status_update(struct drm_dp_aux_msg *msg)\r\n{\r\nif ((msg->request & ~DP_AUX_I2C_MOT) == DP_AUX_I2C_WRITE) {\r\nmsg->request &= DP_AUX_I2C_MOT;\r\nmsg->request |= DP_AUX_I2C_WRITE_STATUS_UPDATE;\r\n}\r\n}\r\nstatic int drm_dp_aux_req_duration(const struct drm_dp_aux_msg *msg)\r\n{\r\nint len = AUX_PRECHARGE_LEN + AUX_SYNC_LEN + AUX_STOP_LEN +\r\nAUX_CMD_LEN + AUX_ADDRESS_LEN + AUX_LENGTH_LEN;\r\nif ((msg->request & DP_AUX_I2C_READ) == 0)\r\nlen += msg->size * 8;\r\nreturn len;\r\n}\r\nstatic int drm_dp_aux_reply_duration(const struct drm_dp_aux_msg *msg)\r\n{\r\nint len = AUX_PRECHARGE_LEN + AUX_SYNC_LEN + AUX_STOP_LEN +\r\nAUX_CMD_LEN + AUX_REPLY_PAD_LEN;\r\nif (msg->request & DP_AUX_I2C_READ)\r\nlen += msg->size * 8;\r\nreturn len;\r\n}\r\nstatic int drm_dp_i2c_msg_duration(const struct drm_dp_aux_msg *msg,\r\nint i2c_speed_khz)\r\n{\r\nreturn DIV_ROUND_UP((I2C_START_LEN + I2C_ADDR_LEN +\r\nmsg->size * I2C_DATA_LEN +\r\nI2C_STOP_LEN) * 1000, i2c_speed_khz);\r\n}\r\nstatic int drm_dp_i2c_retry_count(const struct drm_dp_aux_msg *msg,\r\nint i2c_speed_khz)\r\n{\r\nint aux_time_us = drm_dp_aux_req_duration(msg) +\r\ndrm_dp_aux_reply_duration(msg);\r\nint i2c_time_us = drm_dp_i2c_msg_duration(msg, i2c_speed_khz);\r\nreturn DIV_ROUND_UP(i2c_time_us, aux_time_us + AUX_RETRY_INTERVAL);\r\n}\r\nstatic int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)\r\n{\r\nunsigned int retry, defer_i2c;\r\nint ret;\r\nint max_retries = max(7, drm_dp_i2c_retry_count(msg, dp_aux_i2c_speed_khz));\r\nfor (retry = 0, defer_i2c = 0; retry < (max_retries + defer_i2c); retry++) {\r\nret = aux->transfer(aux, msg);\r\nif (ret < 0) {\r\nif (ret == -EBUSY)\r\ncontinue;\r\nif (ret == -ETIMEDOUT)\r\nDRM_DEBUG_KMS_RATELIMITED("transaction timed out\n");\r\nelse\r\nDRM_DEBUG_KMS("transaction failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nswitch (msg->reply & DP_AUX_NATIVE_REPLY_MASK) {\r\ncase DP_AUX_NATIVE_REPLY_ACK:\r\nbreak;\r\ncase DP_AUX_NATIVE_REPLY_NACK:\r\nDRM_DEBUG_KMS("native nack (result=%d, size=%zu)\n", ret, msg->size);\r\nreturn -EREMOTEIO;\r\ncase DP_AUX_NATIVE_REPLY_DEFER:\r\nDRM_DEBUG_KMS("native defer\n");\r\nusleep_range(AUX_RETRY_INTERVAL, AUX_RETRY_INTERVAL + 100);\r\ncontinue;\r\ndefault:\r\nDRM_ERROR("invalid native reply %#04x\n", msg->reply);\r\nreturn -EREMOTEIO;\r\n}\r\nswitch (msg->reply & DP_AUX_I2C_REPLY_MASK) {\r\ncase DP_AUX_I2C_REPLY_ACK:\r\nif (ret != msg->size)\r\ndrm_dp_i2c_msg_write_status_update(msg);\r\nreturn ret;\r\ncase DP_AUX_I2C_REPLY_NACK:\r\nDRM_DEBUG_KMS("I2C nack (result=%d, size=%zu\n", ret, msg->size);\r\naux->i2c_nack_count++;\r\nreturn -EREMOTEIO;\r\ncase DP_AUX_I2C_REPLY_DEFER:\r\nDRM_DEBUG_KMS("I2C defer\n");\r\naux->i2c_defer_count++;\r\nif (defer_i2c < 7)\r\ndefer_i2c++;\r\nusleep_range(AUX_RETRY_INTERVAL, AUX_RETRY_INTERVAL + 100);\r\ndrm_dp_i2c_msg_write_status_update(msg);\r\ncontinue;\r\ndefault:\r\nDRM_ERROR("invalid I2C reply %#04x\n", msg->reply);\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nDRM_DEBUG_KMS("too many retries, giving up\n");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic void drm_dp_i2c_msg_set_request(struct drm_dp_aux_msg *msg,\r\nconst struct i2c_msg *i2c_msg)\r\n{\r\nmsg->request = (i2c_msg->flags & I2C_M_RD) ?\r\nDP_AUX_I2C_READ : DP_AUX_I2C_WRITE;\r\nmsg->request |= DP_AUX_I2C_MOT;\r\n}\r\nstatic int drm_dp_i2c_drain_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *orig_msg)\r\n{\r\nint err, ret = orig_msg->size;\r\nstruct drm_dp_aux_msg msg = *orig_msg;\r\nwhile (msg.size > 0) {\r\nerr = drm_dp_i2c_do_msg(aux, &msg);\r\nif (err <= 0)\r\nreturn err == 0 ? -EPROTO : err;\r\nif (err < msg.size && err < ret) {\r\nDRM_DEBUG_KMS("Partial I2C reply: requested %zu bytes got %d bytes\n",\r\nmsg.size, err);\r\nret = err;\r\n}\r\nmsg.size -= err;\r\nmsg.buffer += err;\r\n}\r\nreturn ret;\r\n}\r\nstatic int drm_dp_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct drm_dp_aux *aux = adapter->algo_data;\r\nunsigned int i, j;\r\nunsigned transfer_size;\r\nstruct drm_dp_aux_msg msg;\r\nint err = 0;\r\ndp_aux_i2c_transfer_size = clamp(dp_aux_i2c_transfer_size, 1, DP_AUX_MAX_PAYLOAD_BYTES);\r\nmemset(&msg, 0, sizeof(msg));\r\nfor (i = 0; i < num; i++) {\r\nmsg.address = msgs[i].addr;\r\ndrm_dp_i2c_msg_set_request(&msg, &msgs[i]);\r\nmsg.buffer = NULL;\r\nmsg.size = 0;\r\nerr = drm_dp_i2c_do_msg(aux, &msg);\r\ndrm_dp_i2c_msg_set_request(&msg, &msgs[i]);\r\nif (err < 0)\r\nbreak;\r\ntransfer_size = dp_aux_i2c_transfer_size;\r\nfor (j = 0; j < msgs[i].len; j += msg.size) {\r\nmsg.buffer = msgs[i].buf + j;\r\nmsg.size = min(transfer_size, msgs[i].len - j);\r\nerr = drm_dp_i2c_drain_msg(aux, &msg);\r\ndrm_dp_i2c_msg_set_request(&msg, &msgs[i]);\r\nif (err < 0)\r\nbreak;\r\ntransfer_size = err;\r\n}\r\nif (err < 0)\r\nbreak;\r\n}\r\nif (err >= 0)\r\nerr = num;\r\nmsg.request &= ~DP_AUX_I2C_MOT;\r\nmsg.buffer = NULL;\r\nmsg.size = 0;\r\n(void)drm_dp_i2c_do_msg(aux, &msg);\r\nreturn err;\r\n}\r\nstatic struct drm_dp_aux *i2c_to_aux(struct i2c_adapter *i2c)\r\n{\r\nreturn container_of(i2c, struct drm_dp_aux, ddc);\r\n}\r\nstatic void lock_bus(struct i2c_adapter *i2c, unsigned int flags)\r\n{\r\nmutex_lock(&i2c_to_aux(i2c)->hw_mutex);\r\n}\r\nstatic int trylock_bus(struct i2c_adapter *i2c, unsigned int flags)\r\n{\r\nreturn mutex_trylock(&i2c_to_aux(i2c)->hw_mutex);\r\n}\r\nstatic void unlock_bus(struct i2c_adapter *i2c, unsigned int flags)\r\n{\r\nmutex_unlock(&i2c_to_aux(i2c)->hw_mutex);\r\n}\r\nstatic int drm_dp_aux_get_crc(struct drm_dp_aux *aux, u8 *crc)\r\n{\r\nu8 buf, count;\r\nint ret;\r\nret = drm_dp_dpcd_readb(aux, DP_TEST_SINK, &buf);\r\nif (ret < 0)\r\nreturn ret;\r\nWARN_ON(!(buf & DP_TEST_SINK_START));\r\nret = drm_dp_dpcd_readb(aux, DP_TEST_SINK_MISC, &buf);\r\nif (ret < 0)\r\nreturn ret;\r\ncount = buf & DP_TEST_COUNT_MASK;\r\nif (count == aux->crc_count)\r\nreturn -EAGAIN;\r\naux->crc_count = count;\r\nret = drm_dp_dpcd_read(aux, DP_TEST_CRC_R_CR, crc, 6);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void drm_dp_aux_crc_work(struct work_struct *work)\r\n{\r\nstruct drm_dp_aux *aux = container_of(work, struct drm_dp_aux,\r\ncrc_work);\r\nstruct drm_crtc *crtc;\r\nu8 crc_bytes[6];\r\nuint32_t crcs[3];\r\nint ret;\r\nif (WARN_ON(!aux->crtc))\r\nreturn;\r\ncrtc = aux->crtc;\r\nwhile (crtc->crc.opened) {\r\ndrm_crtc_wait_one_vblank(crtc);\r\nif (!crtc->crc.opened)\r\nbreak;\r\nret = drm_dp_aux_get_crc(aux, crc_bytes);\r\nif (ret == -EAGAIN) {\r\nusleep_range(1000, 2000);\r\nret = drm_dp_aux_get_crc(aux, crc_bytes);\r\n}\r\nif (ret == -EAGAIN) {\r\nDRM_DEBUG_KMS("Get CRC failed after retrying: %d\n",\r\nret);\r\ncontinue;\r\n} else if (ret) {\r\nDRM_DEBUG_KMS("Failed to get a CRC: %d\n", ret);\r\ncontinue;\r\n}\r\ncrcs[0] = crc_bytes[0] | crc_bytes[1] << 8;\r\ncrcs[1] = crc_bytes[2] | crc_bytes[3] << 8;\r\ncrcs[2] = crc_bytes[4] | crc_bytes[5] << 8;\r\ndrm_crtc_add_crc_entry(crtc, false, 0, crcs);\r\n}\r\n}\r\nvoid drm_dp_aux_init(struct drm_dp_aux *aux)\r\n{\r\nmutex_init(&aux->hw_mutex);\r\nINIT_WORK(&aux->crc_work, drm_dp_aux_crc_work);\r\naux->ddc.algo = &drm_dp_i2c_algo;\r\naux->ddc.algo_data = aux;\r\naux->ddc.retries = 3;\r\naux->ddc.lock_ops = &drm_dp_i2c_lock_ops;\r\n}\r\nint drm_dp_aux_register(struct drm_dp_aux *aux)\r\n{\r\nint ret;\r\nif (!aux->ddc.algo)\r\ndrm_dp_aux_init(aux);\r\naux->ddc.class = I2C_CLASS_DDC;\r\naux->ddc.owner = THIS_MODULE;\r\naux->ddc.dev.parent = aux->dev;\r\naux->ddc.dev.of_node = aux->dev->of_node;\r\nstrlcpy(aux->ddc.name, aux->name ? aux->name : dev_name(aux->dev),\r\nsizeof(aux->ddc.name));\r\nret = drm_dp_aux_register_devnode(aux);\r\nif (ret)\r\nreturn ret;\r\nret = i2c_add_adapter(&aux->ddc);\r\nif (ret) {\r\ndrm_dp_aux_unregister_devnode(aux);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid drm_dp_aux_unregister(struct drm_dp_aux *aux)\r\n{\r\ndrm_dp_aux_unregister_devnode(aux);\r\ni2c_del_adapter(&aux->ddc);\r\n}\r\nint drm_dp_psr_setup_time(const u8 psr_cap[EDP_PSR_RECEIVER_CAP_SIZE])\r\n{\r\nstatic const u16 psr_setup_time_us[] = {\r\nPSR_SETUP_TIME(330),\r\nPSR_SETUP_TIME(275),\r\nPSR_SETUP_TIME(165),\r\nPSR_SETUP_TIME(110),\r\nPSR_SETUP_TIME(55),\r\nPSR_SETUP_TIME(0),\r\n};\r\nint i;\r\ni = (psr_cap[1] & DP_PSR_SETUP_TIME_MASK) >> DP_PSR_SETUP_TIME_SHIFT;\r\nif (i >= ARRAY_SIZE(psr_setup_time_us))\r\nreturn -EINVAL;\r\nreturn psr_setup_time_us[i];\r\n}\r\nint drm_dp_start_crc(struct drm_dp_aux *aux, struct drm_crtc *crtc)\r\n{\r\nu8 buf;\r\nint ret;\r\nret = drm_dp_dpcd_readb(aux, DP_TEST_SINK, &buf);\r\nif (ret < 0)\r\nreturn ret;\r\nret = drm_dp_dpcd_writeb(aux, DP_TEST_SINK, buf | DP_TEST_SINK_START);\r\nif (ret < 0)\r\nreturn ret;\r\naux->crc_count = 0;\r\naux->crtc = crtc;\r\nschedule_work(&aux->crc_work);\r\nreturn 0;\r\n}\r\nint drm_dp_stop_crc(struct drm_dp_aux *aux)\r\n{\r\nu8 buf;\r\nint ret;\r\nret = drm_dp_dpcd_readb(aux, DP_TEST_SINK, &buf);\r\nif (ret < 0)\r\nreturn ret;\r\nret = drm_dp_dpcd_writeb(aux, DP_TEST_SINK, buf & ~DP_TEST_SINK_START);\r\nif (ret < 0)\r\nreturn ret;\r\nflush_work(&aux->crc_work);\r\naux->crtc = NULL;\r\nreturn 0;\r\n}\r\nstatic u32\r\ndrm_dp_get_quirks(const struct drm_dp_dpcd_ident *ident, bool is_branch)\r\n{\r\nconst struct dpcd_quirk *quirk;\r\nu32 quirks = 0;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dpcd_quirk_list); i++) {\r\nquirk = &dpcd_quirk_list[i];\r\nif (quirk->is_branch != is_branch)\r\ncontinue;\r\nif (memcmp(quirk->oui, ident->oui, sizeof(ident->oui)) != 0)\r\ncontinue;\r\nquirks |= quirk->quirks;\r\n}\r\nreturn quirks;\r\n}\r\nint drm_dp_read_desc(struct drm_dp_aux *aux, struct drm_dp_desc *desc,\r\nbool is_branch)\r\n{\r\nstruct drm_dp_dpcd_ident *ident = &desc->ident;\r\nunsigned int offset = is_branch ? DP_BRANCH_OUI : DP_SINK_OUI;\r\nint ret, dev_id_len;\r\nret = drm_dp_dpcd_read(aux, offset, ident, sizeof(*ident));\r\nif (ret < 0)\r\nreturn ret;\r\ndesc->quirks = drm_dp_get_quirks(ident, is_branch);\r\ndev_id_len = strnlen(ident->device_id, sizeof(ident->device_id));\r\nDRM_DEBUG_KMS("DP %s: OUI %*phD dev-ID %*pE HW-rev %d.%d SW-rev %d.%d quirks 0x%04x\n",\r\nis_branch ? "branch" : "sink",\r\n(int)sizeof(ident->oui), ident->oui,\r\ndev_id_len, ident->device_id,\r\nident->hw_rev >> 4, ident->hw_rev & 0xf,\r\nident->sw_major_rev, ident->sw_minor_rev,\r\ndesc->quirks);\r\nreturn 0;\r\n}
