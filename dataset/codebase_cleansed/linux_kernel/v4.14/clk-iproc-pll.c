static int pll_get_rate_index(struct iproc_pll *pll, unsigned int target_rate)\r\n{\r\nint i;\r\nfor (i = 0; i < pll->num_vco_entries; i++)\r\nif (target_rate == pll->vco_param[i].rate)\r\nbreak;\r\nif (i >= pll->num_vco_entries)\r\nreturn -EINVAL;\r\nreturn i;\r\n}\r\nstatic int get_kp(unsigned long ref_freq, enum kp_band kp_index)\r\n{\r\nint i;\r\nif (ref_freq < ref_freq_table[0][0])\r\nreturn -EINVAL;\r\nfor (i = 0; i < NUM_FREQ_BANDS; i++) {\r\nif (ref_freq >= ref_freq_table[i][0] &&\r\nref_freq < ref_freq_table[i][1])\r\nreturn kp_table[kp_index][i];\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int pll_wait_for_lock(struct iproc_pll *pll)\r\n{\r\nint i;\r\nconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\r\nfor (i = 0; i < LOCK_DELAY; i++) {\r\nu32 val = readl(pll->status_base + ctrl->status.offset);\r\nif (val & (1 << ctrl->status.shift))\r\nreturn 0;\r\nudelay(10);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void iproc_pll_write(const struct iproc_pll *pll, void __iomem *base,\r\nconst u32 offset, u32 val)\r\n{\r\nconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\r\nwritel(val, base + offset);\r\nif (unlikely(ctrl->flags & IPROC_CLK_NEEDS_READ_BACK &&\r\n(base == pll->status_base || base == pll->control_base)))\r\nval = readl(base + offset);\r\n}\r\nstatic void __pll_disable(struct iproc_pll *pll)\r\n{\r\nconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\r\nu32 val;\r\nif (ctrl->flags & IPROC_CLK_PLL_ASIU) {\r\nval = readl(pll->asiu_base + ctrl->asiu.offset);\r\nval &= ~(1 << ctrl->asiu.en_shift);\r\niproc_pll_write(pll, pll->asiu_base, ctrl->asiu.offset, val);\r\n}\r\nif (ctrl->flags & IPROC_CLK_EMBED_PWRCTRL) {\r\nval = readl(pll->control_base + ctrl->aon.offset);\r\nval |= bit_mask(ctrl->aon.pwr_width) << ctrl->aon.pwr_shift;\r\niproc_pll_write(pll, pll->control_base, ctrl->aon.offset, val);\r\n}\r\nif (pll->pwr_base) {\r\nval = readl(pll->pwr_base + ctrl->aon.offset);\r\nval |= 1 << ctrl->aon.iso_shift;\r\niproc_pll_write(pll, pll->pwr_base, ctrl->aon.offset, val);\r\nval &= ~(bit_mask(ctrl->aon.pwr_width) << ctrl->aon.pwr_shift);\r\niproc_pll_write(pll, pll->pwr_base, ctrl->aon.offset, val);\r\n}\r\n}\r\nstatic int __pll_enable(struct iproc_pll *pll)\r\n{\r\nconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\r\nu32 val;\r\nif (ctrl->flags & IPROC_CLK_EMBED_PWRCTRL) {\r\nval = readl(pll->control_base + ctrl->aon.offset);\r\nval &= ~(bit_mask(ctrl->aon.pwr_width) << ctrl->aon.pwr_shift);\r\niproc_pll_write(pll, pll->control_base, ctrl->aon.offset, val);\r\n}\r\nif (pll->pwr_base) {\r\nval = readl(pll->pwr_base + ctrl->aon.offset);\r\nval |= bit_mask(ctrl->aon.pwr_width) << ctrl->aon.pwr_shift;\r\nval &= ~(1 << ctrl->aon.iso_shift);\r\niproc_pll_write(pll, pll->pwr_base, ctrl->aon.offset, val);\r\n}\r\nif (ctrl->flags & IPROC_CLK_PLL_ASIU) {\r\nval = readl(pll->asiu_base + ctrl->asiu.offset);\r\nval |= (1 << ctrl->asiu.en_shift);\r\niproc_pll_write(pll, pll->asiu_base, ctrl->asiu.offset, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __pll_put_in_reset(struct iproc_pll *pll)\r\n{\r\nu32 val;\r\nconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\r\nconst struct iproc_pll_reset_ctrl *reset = &ctrl->reset;\r\nval = readl(pll->control_base + reset->offset);\r\nif (ctrl->flags & IPROC_CLK_PLL_RESET_ACTIVE_LOW)\r\nval |= BIT(reset->reset_shift) | BIT(reset->p_reset_shift);\r\nelse\r\nval &= ~(BIT(reset->reset_shift) | BIT(reset->p_reset_shift));\r\niproc_pll_write(pll, pll->control_base, reset->offset, val);\r\n}\r\nstatic void __pll_bring_out_reset(struct iproc_pll *pll, unsigned int kp,\r\nunsigned int ka, unsigned int ki)\r\n{\r\nu32 val;\r\nconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\r\nconst struct iproc_pll_reset_ctrl *reset = &ctrl->reset;\r\nconst struct iproc_pll_dig_filter_ctrl *dig_filter = &ctrl->dig_filter;\r\nval = readl(pll->control_base + dig_filter->offset);\r\nval &= ~(bit_mask(dig_filter->ki_width) << dig_filter->ki_shift |\r\nbit_mask(dig_filter->kp_width) << dig_filter->kp_shift |\r\nbit_mask(dig_filter->ka_width) << dig_filter->ka_shift);\r\nval |= ki << dig_filter->ki_shift | kp << dig_filter->kp_shift |\r\nka << dig_filter->ka_shift;\r\niproc_pll_write(pll, pll->control_base, dig_filter->offset, val);\r\nval = readl(pll->control_base + reset->offset);\r\nif (ctrl->flags & IPROC_CLK_PLL_RESET_ACTIVE_LOW)\r\nval &= ~(BIT(reset->reset_shift) | BIT(reset->p_reset_shift));\r\nelse\r\nval |= BIT(reset->reset_shift) | BIT(reset->p_reset_shift);\r\niproc_pll_write(pll, pll->control_base, reset->offset, val);\r\n}\r\nstatic int pll_set_rate(struct iproc_clk *clk, unsigned int rate_index,\r\nunsigned long parent_rate)\r\n{\r\nstruct iproc_pll *pll = clk->pll;\r\nconst struct iproc_pll_vco_param *vco = &pll->vco_param[rate_index];\r\nconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\r\nint ka = 0, ki, kp, ret;\r\nunsigned long rate = vco->rate;\r\nu32 val;\r\nenum kp_band kp_index;\r\nunsigned long ref_freq;\r\nif (vco->pdiv == 0)\r\nref_freq = parent_rate * 2;\r\nelse\r\nref_freq = parent_rate / vco->pdiv;\r\nif (rate >= VCO_LOW && rate < VCO_HIGH) {\r\nki = 4;\r\nkp_index = KP_BAND_MID;\r\n} else if (rate >= VCO_HIGH && rate < VCO_HIGH_HIGH) {\r\nki = 3;\r\nkp_index = KP_BAND_HIGH;\r\n} else if (rate >= VCO_HIGH_HIGH && rate < VCO_MAX) {\r\nki = 3;\r\nkp_index = KP_BAND_HIGH_HIGH;\r\n} else {\r\npr_err("%s: pll: %s has invalid rate: %lu\n", __func__,\r\nclk->name, rate);\r\nreturn -EINVAL;\r\n}\r\nkp = get_kp(ref_freq, kp_index);\r\nif (kp < 0) {\r\npr_err("%s: pll: %s has invalid kp\n", __func__, clk->name);\r\nreturn kp;\r\n}\r\nret = __pll_enable(pll);\r\nif (ret) {\r\npr_err("%s: pll: %s fails to enable\n", __func__, clk->name);\r\nreturn ret;\r\n}\r\n__pll_put_in_reset(pll);\r\nif (ctrl->flags & IPROC_CLK_PLL_USER_MODE_ON) {\r\nval = readl(pll->control_base + ctrl->macro_mode.offset);\r\nval &= ~(bit_mask(ctrl->macro_mode.width) <<\r\nctrl->macro_mode.shift);\r\nval |= PLL_USER_MODE << ctrl->macro_mode.shift;\r\niproc_pll_write(pll, pll->control_base,\r\nctrl->macro_mode.offset, val);\r\n}\r\niproc_pll_write(pll, pll->control_base, ctrl->vco_ctrl.u_offset, 0);\r\nval = readl(pll->control_base + ctrl->vco_ctrl.l_offset);\r\nif (rate >= VCO_LOW && rate < VCO_MID)\r\nval |= (1 << PLL_VCO_LOW_SHIFT);\r\nif (rate < VCO_HIGH)\r\nval &= ~(1 << PLL_VCO_HIGH_SHIFT);\r\nelse\r\nval |= (1 << PLL_VCO_HIGH_SHIFT);\r\niproc_pll_write(pll, pll->control_base, ctrl->vco_ctrl.l_offset, val);\r\nval = readl(pll->control_base + ctrl->ndiv_int.offset);\r\nval &= ~(bit_mask(ctrl->ndiv_int.width) << ctrl->ndiv_int.shift);\r\nval |= vco->ndiv_int << ctrl->ndiv_int.shift;\r\niproc_pll_write(pll, pll->control_base, ctrl->ndiv_int.offset, val);\r\nif (ctrl->flags & IPROC_CLK_PLL_HAS_NDIV_FRAC) {\r\nval = readl(pll->control_base + ctrl->ndiv_frac.offset);\r\nval &= ~(bit_mask(ctrl->ndiv_frac.width) <<\r\nctrl->ndiv_frac.shift);\r\nval |= vco->ndiv_frac << ctrl->ndiv_frac.shift;\r\niproc_pll_write(pll, pll->control_base, ctrl->ndiv_frac.offset,\r\nval);\r\n}\r\nval = readl(pll->control_base + ctrl->pdiv.offset);\r\nval &= ~(bit_mask(ctrl->pdiv.width) << ctrl->pdiv.shift);\r\nval |= vco->pdiv << ctrl->pdiv.shift;\r\niproc_pll_write(pll, pll->control_base, ctrl->pdiv.offset, val);\r\n__pll_bring_out_reset(pll, kp, ka, ki);\r\nret = pll_wait_for_lock(pll);\r\nif (ret < 0) {\r\npr_err("%s: pll: %s failed to lock\n", __func__, clk->name);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iproc_pll_enable(struct clk_hw *hw)\r\n{\r\nstruct iproc_clk *clk = to_iproc_clk(hw);\r\nstruct iproc_pll *pll = clk->pll;\r\nreturn __pll_enable(pll);\r\n}\r\nstatic void iproc_pll_disable(struct clk_hw *hw)\r\n{\r\nstruct iproc_clk *clk = to_iproc_clk(hw);\r\nstruct iproc_pll *pll = clk->pll;\r\nconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\r\nif (ctrl->flags & IPROC_CLK_AON)\r\nreturn;\r\n__pll_disable(pll);\r\n}\r\nstatic unsigned long iproc_pll_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct iproc_clk *clk = to_iproc_clk(hw);\r\nstruct iproc_pll *pll = clk->pll;\r\nconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\r\nu32 val;\r\nu64 ndiv, ndiv_int, ndiv_frac;\r\nunsigned int pdiv;\r\nif (parent_rate == 0)\r\nreturn 0;\r\nval = readl(pll->status_base + ctrl->status.offset);\r\nif ((val & (1 << ctrl->status.shift)) == 0) {\r\nclk->rate = 0;\r\nreturn 0;\r\n}\r\nval = readl(pll->control_base + ctrl->ndiv_int.offset);\r\nndiv_int = (val >> ctrl->ndiv_int.shift) &\r\nbit_mask(ctrl->ndiv_int.width);\r\nndiv = ndiv_int << 20;\r\nif (ctrl->flags & IPROC_CLK_PLL_HAS_NDIV_FRAC) {\r\nval = readl(pll->control_base + ctrl->ndiv_frac.offset);\r\nndiv_frac = (val >> ctrl->ndiv_frac.shift) &\r\nbit_mask(ctrl->ndiv_frac.width);\r\nndiv += ndiv_frac;\r\n}\r\nval = readl(pll->control_base + ctrl->pdiv.offset);\r\npdiv = (val >> ctrl->pdiv.shift) & bit_mask(ctrl->pdiv.width);\r\nclk->rate = (ndiv * parent_rate) >> 20;\r\nif (pdiv == 0)\r\nclk->rate *= 2;\r\nelse\r\nclk->rate /= pdiv;\r\nreturn clk->rate;\r\n}\r\nstatic long iproc_pll_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned i;\r\nstruct iproc_clk *clk = to_iproc_clk(hw);\r\nstruct iproc_pll *pll = clk->pll;\r\nif (rate == 0 || *parent_rate == 0 || !pll->vco_param)\r\nreturn -EINVAL;\r\nfor (i = 0; i < pll->num_vco_entries; i++) {\r\nif (rate <= pll->vco_param[i].rate)\r\nbreak;\r\n}\r\nif (i == pll->num_vco_entries)\r\ni--;\r\nreturn pll->vco_param[i].rate;\r\n}\r\nstatic int iproc_pll_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct iproc_clk *clk = to_iproc_clk(hw);\r\nstruct iproc_pll *pll = clk->pll;\r\nint rate_index, ret;\r\nrate_index = pll_get_rate_index(pll, rate);\r\nif (rate_index < 0)\r\nreturn rate_index;\r\nret = pll_set_rate(clk, rate_index, parent_rate);\r\nreturn ret;\r\n}\r\nstatic int iproc_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct iproc_clk *clk = to_iproc_clk(hw);\r\nconst struct iproc_clk_ctrl *ctrl = clk->ctrl;\r\nstruct iproc_pll *pll = clk->pll;\r\nu32 val;\r\nval = readl(pll->control_base + ctrl->enable.offset);\r\nval &= ~(1 << ctrl->enable.enable_shift);\r\niproc_pll_write(pll, pll->control_base, ctrl->enable.offset, val);\r\nval = readl(pll->control_base + ctrl->enable.offset);\r\nval &= ~(1 << ctrl->enable.hold_shift);\r\niproc_pll_write(pll, pll->control_base, ctrl->enable.offset, val);\r\nreturn 0;\r\n}\r\nstatic void iproc_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct iproc_clk *clk = to_iproc_clk(hw);\r\nconst struct iproc_clk_ctrl *ctrl = clk->ctrl;\r\nstruct iproc_pll *pll = clk->pll;\r\nu32 val;\r\nif (ctrl->flags & IPROC_CLK_AON)\r\nreturn;\r\nval = readl(pll->control_base + ctrl->enable.offset);\r\nval |= 1 << ctrl->enable.enable_shift;\r\niproc_pll_write(pll, pll->control_base, ctrl->enable.offset, val);\r\n}\r\nstatic unsigned long iproc_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct iproc_clk *clk = to_iproc_clk(hw);\r\nconst struct iproc_clk_ctrl *ctrl = clk->ctrl;\r\nstruct iproc_pll *pll = clk->pll;\r\nu32 val;\r\nunsigned int mdiv;\r\nif (parent_rate == 0)\r\nreturn 0;\r\nval = readl(pll->control_base + ctrl->mdiv.offset);\r\nmdiv = (val >> ctrl->mdiv.shift) & bit_mask(ctrl->mdiv.width);\r\nif (mdiv == 0)\r\nmdiv = 256;\r\nif (ctrl->flags & IPROC_CLK_MCLK_DIV_BY_2)\r\nclk->rate = parent_rate / (mdiv * 2);\r\nelse\r\nclk->rate = parent_rate / mdiv;\r\nreturn clk->rate;\r\n}\r\nstatic long iproc_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned int div;\r\nif (rate == 0 || *parent_rate == 0)\r\nreturn -EINVAL;\r\nif (rate == *parent_rate)\r\nreturn *parent_rate;\r\ndiv = DIV_ROUND_UP(*parent_rate, rate);\r\nif (div < 2)\r\nreturn *parent_rate;\r\nif (div > 256)\r\ndiv = 256;\r\nreturn *parent_rate / div;\r\n}\r\nstatic int iproc_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct iproc_clk *clk = to_iproc_clk(hw);\r\nconst struct iproc_clk_ctrl *ctrl = clk->ctrl;\r\nstruct iproc_pll *pll = clk->pll;\r\nu32 val;\r\nunsigned int div;\r\nif (rate == 0 || parent_rate == 0)\r\nreturn -EINVAL;\r\nif (ctrl->flags & IPROC_CLK_MCLK_DIV_BY_2)\r\ndiv = DIV_ROUND_UP(parent_rate, rate * 2);\r\nelse\r\ndiv = DIV_ROUND_UP(parent_rate, rate);\r\nif (div > 256)\r\nreturn -EINVAL;\r\nval = readl(pll->control_base + ctrl->mdiv.offset);\r\nif (div == 256) {\r\nval &= ~(bit_mask(ctrl->mdiv.width) << ctrl->mdiv.shift);\r\n} else {\r\nval &= ~(bit_mask(ctrl->mdiv.width) << ctrl->mdiv.shift);\r\nval |= div << ctrl->mdiv.shift;\r\n}\r\niproc_pll_write(pll, pll->control_base, ctrl->mdiv.offset, val);\r\nif (ctrl->flags & IPROC_CLK_MCLK_DIV_BY_2)\r\nclk->rate = parent_rate / (div * 2);\r\nelse\r\nclk->rate = parent_rate / div;\r\nreturn 0;\r\n}\r\nstatic void iproc_pll_sw_cfg(struct iproc_pll *pll)\r\n{\r\nconst struct iproc_pll_ctrl *ctrl = pll->ctrl;\r\nif (ctrl->flags & IPROC_CLK_PLL_NEEDS_SW_CFG) {\r\nu32 val;\r\nval = readl(pll->control_base + ctrl->sw_ctrl.offset);\r\nval |= BIT(ctrl->sw_ctrl.shift);\r\niproc_pll_write(pll, pll->control_base, ctrl->sw_ctrl.offset,\r\nval);\r\n}\r\n}\r\nvoid iproc_pll_clk_setup(struct device_node *node,\r\nconst struct iproc_pll_ctrl *pll_ctrl,\r\nconst struct iproc_pll_vco_param *vco,\r\nunsigned int num_vco_entries,\r\nconst struct iproc_clk_ctrl *clk_ctrl,\r\nunsigned int num_clks)\r\n{\r\nint i, ret;\r\nstruct iproc_pll *pll;\r\nstruct iproc_clk *iclk;\r\nstruct clk_init_data init;\r\nconst char *parent_name;\r\nif (WARN_ON(!pll_ctrl) || WARN_ON(!clk_ctrl))\r\nreturn;\r\npll = kzalloc(sizeof(*pll), GFP_KERNEL);\r\nif (WARN_ON(!pll))\r\nreturn;\r\npll->clk_data = kzalloc(sizeof(*pll->clk_data->hws) * num_clks +\r\nsizeof(*pll->clk_data), GFP_KERNEL);\r\nif (WARN_ON(!pll->clk_data))\r\ngoto err_clk_data;\r\npll->clk_data->num = num_clks;\r\npll->clks = kcalloc(num_clks, sizeof(*pll->clks), GFP_KERNEL);\r\nif (WARN_ON(!pll->clks))\r\ngoto err_clks;\r\npll->control_base = of_iomap(node, 0);\r\nif (WARN_ON(!pll->control_base))\r\ngoto err_pll_iomap;\r\npll->pwr_base = of_iomap(node, 1);\r\nif (pll_ctrl->flags & IPROC_CLK_PLL_ASIU) {\r\npll->asiu_base = of_iomap(node, 2);\r\nif (WARN_ON(!pll->asiu_base))\r\ngoto err_asiu_iomap;\r\n}\r\nif (pll_ctrl->flags & IPROC_CLK_PLL_SPLIT_STAT_CTRL) {\r\npll->status_base = of_iomap(node, 2);\r\nif (!pll->status_base)\r\ngoto err_status_iomap;\r\n} else\r\npll->status_base = pll->control_base;\r\npll->ctrl = pll_ctrl;\r\niclk = &pll->clks[0];\r\niclk->pll = pll;\r\niclk->name = node->name;\r\ninit.name = node->name;\r\ninit.ops = &iproc_pll_ops;\r\ninit.flags = 0;\r\nparent_name = of_clk_get_parent_name(node, 0);\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\niclk->hw.init = &init;\r\nif (vco) {\r\npll->num_vco_entries = num_vco_entries;\r\npll->vco_param = vco;\r\n}\r\niproc_pll_sw_cfg(pll);\r\nret = clk_hw_register(NULL, &iclk->hw);\r\nif (WARN_ON(ret))\r\ngoto err_pll_register;\r\npll->clk_data->hws[0] = &iclk->hw;\r\nfor (i = 1; i < num_clks; i++) {\r\nconst char *clk_name;\r\nmemset(&init, 0, sizeof(init));\r\nparent_name = node->name;\r\nret = of_property_read_string_index(node, "clock-output-names",\r\ni, &clk_name);\r\nif (WARN_ON(ret))\r\ngoto err_clk_register;\r\niclk = &pll->clks[i];\r\niclk->name = clk_name;\r\niclk->pll = pll;\r\niclk->ctrl = &clk_ctrl[i];\r\ninit.name = clk_name;\r\ninit.ops = &iproc_clk_ops;\r\ninit.flags = 0;\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\niclk->hw.init = &init;\r\nret = clk_hw_register(NULL, &iclk->hw);\r\nif (WARN_ON(ret))\r\ngoto err_clk_register;\r\npll->clk_data->hws[i] = &iclk->hw;\r\n}\r\nret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get,\r\npll->clk_data);\r\nif (WARN_ON(ret))\r\ngoto err_clk_register;\r\nreturn;\r\nerr_clk_register:\r\nwhile (--i >= 0)\r\nclk_hw_unregister(pll->clk_data->hws[i]);\r\nerr_pll_register:\r\nif (pll->status_base != pll->control_base)\r\niounmap(pll->status_base);\r\nerr_status_iomap:\r\nif (pll->asiu_base)\r\niounmap(pll->asiu_base);\r\nerr_asiu_iomap:\r\nif (pll->pwr_base)\r\niounmap(pll->pwr_base);\r\niounmap(pll->control_base);\r\nerr_pll_iomap:\r\nkfree(pll->clks);\r\nerr_clks:\r\nkfree(pll->clk_data);\r\nerr_clk_data:\r\nkfree(pll);\r\n}
