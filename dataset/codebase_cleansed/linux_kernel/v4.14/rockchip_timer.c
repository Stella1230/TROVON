static inline struct rk_timer *rk_timer(struct clock_event_device *ce)\r\n{\r\nreturn &container_of(ce, struct rk_clkevt, ce)->timer;\r\n}\r\nstatic inline void rk_timer_disable(struct rk_timer *timer)\r\n{\r\nwritel_relaxed(TIMER_DISABLE, timer->ctrl);\r\n}\r\nstatic inline void rk_timer_enable(struct rk_timer *timer, u32 flags)\r\n{\r\nwritel_relaxed(TIMER_ENABLE | flags, timer->ctrl);\r\n}\r\nstatic void rk_timer_update_counter(unsigned long cycles,\r\nstruct rk_timer *timer)\r\n{\r\nwritel_relaxed(cycles, timer->base + TIMER_LOAD_COUNT0);\r\nwritel_relaxed(0, timer->base + TIMER_LOAD_COUNT1);\r\n}\r\nstatic void rk_timer_interrupt_clear(struct rk_timer *timer)\r\n{\r\nwritel_relaxed(1, timer->base + TIMER_INT_STATUS);\r\n}\r\nstatic inline int rk_timer_set_next_event(unsigned long cycles,\r\nstruct clock_event_device *ce)\r\n{\r\nstruct rk_timer *timer = rk_timer(ce);\r\nrk_timer_disable(timer);\r\nrk_timer_update_counter(cycles, timer);\r\nrk_timer_enable(timer, TIMER_MODE_USER_DEFINED_COUNT |\r\nTIMER_INT_UNMASK);\r\nreturn 0;\r\n}\r\nstatic int rk_timer_shutdown(struct clock_event_device *ce)\r\n{\r\nstruct rk_timer *timer = rk_timer(ce);\r\nrk_timer_disable(timer);\r\nreturn 0;\r\n}\r\nstatic int rk_timer_set_periodic(struct clock_event_device *ce)\r\n{\r\nstruct rk_timer *timer = rk_timer(ce);\r\nrk_timer_disable(timer);\r\nrk_timer_update_counter(timer->freq / HZ - 1, timer);\r\nrk_timer_enable(timer, TIMER_MODE_FREE_RUNNING | TIMER_INT_UNMASK);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t rk_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *ce = dev_id;\r\nstruct rk_timer *timer = rk_timer(ce);\r\nrk_timer_interrupt_clear(timer);\r\nif (clockevent_state_oneshot(ce))\r\nrk_timer_disable(timer);\r\nce->event_handler(ce);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u64 notrace rk_timer_sched_read(void)\r\n{\r\nreturn ~readl_relaxed(rk_clksrc->base + TIMER_CURRENT_VALUE0);\r\n}\r\nstatic int __init\r\nrk_timer_probe(struct rk_timer *timer, struct device_node *np)\r\n{\r\nstruct clk *timer_clk;\r\nstruct clk *pclk;\r\nint ret = -EINVAL, irq;\r\nu32 ctrl_reg = TIMER_CONTROL_REG3288;\r\ntimer->base = of_iomap(np, 0);\r\nif (!timer->base) {\r\npr_err("Failed to get base address for '%s'\n", TIMER_NAME);\r\nreturn -ENXIO;\r\n}\r\nif (of_device_is_compatible(np, "rockchip,rk3399-timer"))\r\nctrl_reg = TIMER_CONTROL_REG3399;\r\ntimer->ctrl = timer->base + ctrl_reg;\r\npclk = of_clk_get_by_name(np, "pclk");\r\nif (IS_ERR(pclk)) {\r\nret = PTR_ERR(pclk);\r\npr_err("Failed to get pclk for '%s'\n", TIMER_NAME);\r\ngoto out_unmap;\r\n}\r\nret = clk_prepare_enable(pclk);\r\nif (ret) {\r\npr_err("Failed to enable pclk for '%s'\n", TIMER_NAME);\r\ngoto out_unmap;\r\n}\r\ntimer->pclk = pclk;\r\ntimer_clk = of_clk_get_by_name(np, "timer");\r\nif (IS_ERR(timer_clk)) {\r\nret = PTR_ERR(timer_clk);\r\npr_err("Failed to get timer clock for '%s'\n", TIMER_NAME);\r\ngoto out_timer_clk;\r\n}\r\nret = clk_prepare_enable(timer_clk);\r\nif (ret) {\r\npr_err("Failed to enable timer clock\n");\r\ngoto out_timer_clk;\r\n}\r\ntimer->clk = timer_clk;\r\ntimer->freq = clk_get_rate(timer_clk);\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq) {\r\nret = -EINVAL;\r\npr_err("Failed to map interrupts for '%s'\n", TIMER_NAME);\r\ngoto out_irq;\r\n}\r\ntimer->irq = irq;\r\nrk_timer_interrupt_clear(timer);\r\nrk_timer_disable(timer);\r\nreturn 0;\r\nout_irq:\r\nclk_disable_unprepare(timer_clk);\r\nout_timer_clk:\r\nclk_disable_unprepare(pclk);\r\nout_unmap:\r\niounmap(timer->base);\r\nreturn ret;\r\n}\r\nstatic void __init rk_timer_cleanup(struct rk_timer *timer)\r\n{\r\nclk_disable_unprepare(timer->clk);\r\nclk_disable_unprepare(timer->pclk);\r\niounmap(timer->base);\r\n}\r\nstatic int __init rk_clkevt_init(struct device_node *np)\r\n{\r\nstruct clock_event_device *ce;\r\nint ret = -EINVAL;\r\nrk_clkevt = kzalloc(sizeof(struct rk_clkevt), GFP_KERNEL);\r\nif (!rk_clkevt) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = rk_timer_probe(&rk_clkevt->timer, np);\r\nif (ret)\r\ngoto out_probe;\r\nce = &rk_clkevt->ce;\r\nce->name = TIMER_NAME;\r\nce->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT |\r\nCLOCK_EVT_FEAT_DYNIRQ;\r\nce->set_next_event = rk_timer_set_next_event;\r\nce->set_state_shutdown = rk_timer_shutdown;\r\nce->set_state_periodic = rk_timer_set_periodic;\r\nce->irq = rk_clkevt->timer.irq;\r\nce->cpumask = cpu_possible_mask;\r\nce->rating = 250;\r\nret = request_irq(rk_clkevt->timer.irq, rk_timer_interrupt, IRQF_TIMER,\r\nTIMER_NAME, ce);\r\nif (ret) {\r\npr_err("Failed to initialize '%s': %d\n",\r\nTIMER_NAME, ret);\r\ngoto out_irq;\r\n}\r\nclockevents_config_and_register(&rk_clkevt->ce,\r\nrk_clkevt->timer.freq, 1, UINT_MAX);\r\nreturn 0;\r\nout_irq:\r\nrk_timer_cleanup(&rk_clkevt->timer);\r\nout_probe:\r\nkfree(rk_clkevt);\r\nout:\r\nrk_clkevt = ERR_PTR(ret);\r\nreturn ret;\r\n}\r\nstatic int __init rk_clksrc_init(struct device_node *np)\r\n{\r\nint ret = -EINVAL;\r\nrk_clksrc = kzalloc(sizeof(struct rk_timer), GFP_KERNEL);\r\nif (!rk_clksrc) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = rk_timer_probe(rk_clksrc, np);\r\nif (ret)\r\ngoto out_probe;\r\nrk_timer_update_counter(UINT_MAX, rk_clksrc);\r\nrk_timer_enable(rk_clksrc, 0);\r\nret = clocksource_mmio_init(rk_clksrc->base + TIMER_CURRENT_VALUE0,\r\nTIMER_NAME, rk_clksrc->freq, 250, 32,\r\nclocksource_mmio_readl_down);\r\nif (ret) {\r\npr_err("Failed to register clocksource");\r\ngoto out_clocksource;\r\n}\r\nsched_clock_register(rk_timer_sched_read, 32, rk_clksrc->freq);\r\nreturn 0;\r\nout_clocksource:\r\nrk_timer_cleanup(rk_clksrc);\r\nout_probe:\r\nkfree(rk_clksrc);\r\nout:\r\nrk_clksrc = ERR_PTR(ret);\r\nreturn ret;\r\n}\r\nstatic int __init rk_timer_init(struct device_node *np)\r\n{\r\nif (!rk_clkevt)\r\nreturn rk_clkevt_init(np);\r\nif (!rk_clksrc)\r\nreturn rk_clksrc_init(np);\r\npr_err("Too many timer definitions for '%s'\n", TIMER_NAME);\r\nreturn -EINVAL;\r\n}
