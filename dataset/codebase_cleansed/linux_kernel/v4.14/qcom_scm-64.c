static int qcom_scm_call(struct device *dev, u32 svc_id, u32 cmd_id,\r\nconst struct qcom_scm_desc *desc,\r\nstruct arm_smccc_res *res)\r\n{\r\nint arglen = desc->arginfo & 0xf;\r\nint retry_count = 0, i;\r\nu32 fn_id = QCOM_SCM_FNID(svc_id, cmd_id);\r\nu64 cmd, x5 = desc->args[FIRST_EXT_ARG_IDX];\r\ndma_addr_t args_phys = 0;\r\nvoid *args_virt = NULL;\r\nsize_t alloc_len;\r\nstruct arm_smccc_quirk quirk = {.id = ARM_SMCCC_QUIRK_QCOM_A6};\r\nif (unlikely(arglen > N_REGISTER_ARGS)) {\r\nalloc_len = N_EXT_QCOM_SCM_ARGS * sizeof(u64);\r\nargs_virt = kzalloc(PAGE_ALIGN(alloc_len), GFP_KERNEL);\r\nif (!args_virt)\r\nreturn -ENOMEM;\r\nif (qcom_smccc_convention == ARM_SMCCC_SMC_32) {\r\n__le32 *args = args_virt;\r\nfor (i = 0; i < N_EXT_QCOM_SCM_ARGS; i++)\r\nargs[i] = cpu_to_le32(desc->args[i +\r\nFIRST_EXT_ARG_IDX]);\r\n} else {\r\n__le64 *args = args_virt;\r\nfor (i = 0; i < N_EXT_QCOM_SCM_ARGS; i++)\r\nargs[i] = cpu_to_le64(desc->args[i +\r\nFIRST_EXT_ARG_IDX]);\r\n}\r\nargs_phys = dma_map_single(dev, args_virt, alloc_len,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, args_phys)) {\r\nkfree(args_virt);\r\nreturn -ENOMEM;\r\n}\r\nx5 = args_phys;\r\n}\r\ndo {\r\nmutex_lock(&qcom_scm_lock);\r\ncmd = ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL,\r\nqcom_smccc_convention,\r\nARM_SMCCC_OWNER_SIP, fn_id);\r\nquirk.state.a6 = 0;\r\ndo {\r\narm_smccc_smc_quirk(cmd, desc->arginfo, desc->args[0],\r\ndesc->args[1], desc->args[2], x5,\r\nquirk.state.a6, 0, res, &quirk);\r\nif (res->a0 == QCOM_SCM_INTERRUPTED)\r\ncmd = res->a0;\r\n} while (res->a0 == QCOM_SCM_INTERRUPTED);\r\nmutex_unlock(&qcom_scm_lock);\r\nif (res->a0 == QCOM_SCM_V2_EBUSY) {\r\nif (retry_count++ > QCOM_SCM_EBUSY_MAX_RETRY)\r\nbreak;\r\nmsleep(QCOM_SCM_EBUSY_WAIT_MS);\r\n}\r\n} while (res->a0 == QCOM_SCM_V2_EBUSY);\r\nif (args_virt) {\r\ndma_unmap_single(dev, args_phys, alloc_len, DMA_TO_DEVICE);\r\nkfree(args_virt);\r\n}\r\nif (res->a0 < 0)\r\nreturn qcom_scm_remap_error(res->a0);\r\nreturn 0;\r\n}\r\nint __qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nint __qcom_scm_set_warm_boot_addr(struct device *dev, void *entry,\r\nconst cpumask_t *cpus)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nvoid __qcom_scm_cpu_power_down(u32 flags)\r\n{\r\n}\r\nint __qcom_scm_is_call_available(struct device *dev, u32 svc_id, u32 cmd_id)\r\n{\r\nint ret;\r\nstruct qcom_scm_desc desc = {0};\r\nstruct arm_smccc_res res;\r\ndesc.arginfo = QCOM_SCM_ARGS(1);\r\ndesc.args[0] = QCOM_SCM_FNID(svc_id, cmd_id) |\r\n(ARM_SMCCC_OWNER_SIP << ARM_SMCCC_OWNER_SHIFT);\r\nret = qcom_scm_call(dev, QCOM_SCM_SVC_INFO, QCOM_IS_CALL_AVAIL_CMD,\r\n&desc, &res);\r\nreturn ret ? : res.a1;\r\n}\r\nint __qcom_scm_hdcp_req(struct device *dev, struct qcom_scm_hdcp_req *req,\r\nu32 req_cnt, u32 *resp)\r\n{\r\nint ret;\r\nstruct qcom_scm_desc desc = {0};\r\nstruct arm_smccc_res res;\r\nif (req_cnt > QCOM_SCM_HDCP_MAX_REQ_CNT)\r\nreturn -ERANGE;\r\ndesc.args[0] = req[0].addr;\r\ndesc.args[1] = req[0].val;\r\ndesc.args[2] = req[1].addr;\r\ndesc.args[3] = req[1].val;\r\ndesc.args[4] = req[2].addr;\r\ndesc.args[5] = req[2].val;\r\ndesc.args[6] = req[3].addr;\r\ndesc.args[7] = req[3].val;\r\ndesc.args[8] = req[4].addr;\r\ndesc.args[9] = req[4].val;\r\ndesc.arginfo = QCOM_SCM_ARGS(10);\r\nret = qcom_scm_call(dev, QCOM_SCM_SVC_HDCP, QCOM_SCM_CMD_HDCP, &desc,\r\n&res);\r\n*resp = res.a1;\r\nreturn ret;\r\n}\r\nvoid __qcom_scm_init(void)\r\n{\r\nu64 cmd;\r\nstruct arm_smccc_res res;\r\nu32 function = QCOM_SCM_FNID(QCOM_SCM_SVC_INFO, QCOM_IS_CALL_AVAIL_CMD);\r\ncmd = ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL, ARM_SMCCC_SMC_64,\r\nARM_SMCCC_OWNER_SIP, function);\r\narm_smccc_smc(cmd, QCOM_SCM_ARGS(1), cmd & (~BIT(ARM_SMCCC_TYPE_SHIFT)),\r\n0, 0, 0, 0, 0, &res);\r\nif (!res.a0 && res.a1)\r\nqcom_smccc_convention = ARM_SMCCC_SMC_64;\r\nelse\r\nqcom_smccc_convention = ARM_SMCCC_SMC_32;\r\n}\r\nbool __qcom_scm_pas_supported(struct device *dev, u32 peripheral)\r\n{\r\nint ret;\r\nstruct qcom_scm_desc desc = {0};\r\nstruct arm_smccc_res res;\r\ndesc.args[0] = peripheral;\r\ndesc.arginfo = QCOM_SCM_ARGS(1);\r\nret = qcom_scm_call(dev, QCOM_SCM_SVC_PIL,\r\nQCOM_SCM_PAS_IS_SUPPORTED_CMD,\r\n&desc, &res);\r\nreturn ret ? false : !!res.a1;\r\n}\r\nint __qcom_scm_pas_init_image(struct device *dev, u32 peripheral,\r\ndma_addr_t metadata_phys)\r\n{\r\nint ret;\r\nstruct qcom_scm_desc desc = {0};\r\nstruct arm_smccc_res res;\r\ndesc.args[0] = peripheral;\r\ndesc.args[1] = metadata_phys;\r\ndesc.arginfo = QCOM_SCM_ARGS(2, QCOM_SCM_VAL, QCOM_SCM_RW);\r\nret = qcom_scm_call(dev, QCOM_SCM_SVC_PIL, QCOM_SCM_PAS_INIT_IMAGE_CMD,\r\n&desc, &res);\r\nreturn ret ? : res.a1;\r\n}\r\nint __qcom_scm_pas_mem_setup(struct device *dev, u32 peripheral,\r\nphys_addr_t addr, phys_addr_t size)\r\n{\r\nint ret;\r\nstruct qcom_scm_desc desc = {0};\r\nstruct arm_smccc_res res;\r\ndesc.args[0] = peripheral;\r\ndesc.args[1] = addr;\r\ndesc.args[2] = size;\r\ndesc.arginfo = QCOM_SCM_ARGS(3);\r\nret = qcom_scm_call(dev, QCOM_SCM_SVC_PIL, QCOM_SCM_PAS_MEM_SETUP_CMD,\r\n&desc, &res);\r\nreturn ret ? : res.a1;\r\n}\r\nint __qcom_scm_pas_auth_and_reset(struct device *dev, u32 peripheral)\r\n{\r\nint ret;\r\nstruct qcom_scm_desc desc = {0};\r\nstruct arm_smccc_res res;\r\ndesc.args[0] = peripheral;\r\ndesc.arginfo = QCOM_SCM_ARGS(1);\r\nret = qcom_scm_call(dev, QCOM_SCM_SVC_PIL,\r\nQCOM_SCM_PAS_AUTH_AND_RESET_CMD,\r\n&desc, &res);\r\nreturn ret ? : res.a1;\r\n}\r\nint __qcom_scm_pas_shutdown(struct device *dev, u32 peripheral)\r\n{\r\nint ret;\r\nstruct qcom_scm_desc desc = {0};\r\nstruct arm_smccc_res res;\r\ndesc.args[0] = peripheral;\r\ndesc.arginfo = QCOM_SCM_ARGS(1);\r\nret = qcom_scm_call(dev, QCOM_SCM_SVC_PIL, QCOM_SCM_PAS_SHUTDOWN_CMD,\r\n&desc, &res);\r\nreturn ret ? : res.a1;\r\n}\r\nint __qcom_scm_pas_mss_reset(struct device *dev, bool reset)\r\n{\r\nstruct qcom_scm_desc desc = {0};\r\nstruct arm_smccc_res res;\r\nint ret;\r\ndesc.args[0] = reset;\r\ndesc.args[1] = 0;\r\ndesc.arginfo = QCOM_SCM_ARGS(2);\r\nret = qcom_scm_call(dev, QCOM_SCM_SVC_PIL, QCOM_SCM_PAS_MSS_RESET, &desc,\r\n&res);\r\nreturn ret ? : res.a1;\r\n}\r\nint __qcom_scm_set_remote_state(struct device *dev, u32 state, u32 id)\r\n{\r\nstruct qcom_scm_desc desc = {0};\r\nstruct arm_smccc_res res;\r\nint ret;\r\ndesc.args[0] = state;\r\ndesc.args[1] = id;\r\ndesc.arginfo = QCOM_SCM_ARGS(2);\r\nret = qcom_scm_call(dev, QCOM_SCM_SVC_BOOT, QCOM_SCM_SET_REMOTE_STATE,\r\n&desc, &res);\r\nreturn ret ? : res.a1;\r\n}\r\nint __qcom_scm_restore_sec_cfg(struct device *dev, u32 device_id, u32 spare)\r\n{\r\nstruct qcom_scm_desc desc = {0};\r\nstruct arm_smccc_res res;\r\nint ret;\r\ndesc.args[0] = device_id;\r\ndesc.args[1] = spare;\r\ndesc.arginfo = QCOM_SCM_ARGS(2);\r\nret = qcom_scm_call(dev, QCOM_SCM_SVC_MP, QCOM_SCM_RESTORE_SEC_CFG,\r\n&desc, &res);\r\nreturn ret ? : res.a1;\r\n}\r\nint __qcom_scm_iommu_secure_ptbl_size(struct device *dev, u32 spare,\r\nsize_t *size)\r\n{\r\nstruct qcom_scm_desc desc = {0};\r\nstruct arm_smccc_res res;\r\nint ret;\r\ndesc.args[0] = spare;\r\ndesc.arginfo = QCOM_SCM_ARGS(1);\r\nret = qcom_scm_call(dev, QCOM_SCM_SVC_MP,\r\nQCOM_SCM_IOMMU_SECURE_PTBL_SIZE, &desc, &res);\r\nif (size)\r\n*size = res.a1;\r\nreturn ret ? : res.a2;\r\n}\r\nint __qcom_scm_iommu_secure_ptbl_init(struct device *dev, u64 addr, u32 size,\r\nu32 spare)\r\n{\r\nstruct qcom_scm_desc desc = {0};\r\nstruct arm_smccc_res res;\r\nint ret;\r\ndesc.args[0] = addr;\r\ndesc.args[1] = size;\r\ndesc.args[2] = spare;\r\ndesc.arginfo = QCOM_SCM_ARGS(3, QCOM_SCM_RW, QCOM_SCM_VAL,\r\nQCOM_SCM_VAL);\r\nret = qcom_scm_call(dev, QCOM_SCM_SVC_MP,\r\nQCOM_SCM_IOMMU_SECURE_PTBL_INIT, &desc, &res);\r\nif (ret == -EPERM)\r\nret = 0;\r\nreturn ret;\r\n}
