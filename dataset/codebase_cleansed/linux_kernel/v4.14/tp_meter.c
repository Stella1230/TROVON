static u32 batadv_tp_session_cookie(const u8 session[2], u8 icmp_uid)\r\n{\r\nu32 cookie;\r\ncookie = icmp_uid << 16;\r\ncookie |= session[0] << 8;\r\ncookie |= session[1];\r\nreturn cookie;\r\n}\r\nstatic u32 batadv_tp_cwnd(u32 base, u32 increment, u32 min)\r\n{\r\nu32 new_size = base + increment;\r\nif (new_size < base)\r\nnew_size = (u32)ULONG_MAX;\r\nnew_size = min_t(u32, new_size, BATADV_TP_AWND);\r\nreturn max_t(u32, new_size, min);\r\n}\r\nstatic void batadv_tp_update_cwnd(struct batadv_tp_vars *tp_vars, u32 mss)\r\n{\r\nspin_lock_bh(&tp_vars->cwnd_lock);\r\nif (tp_vars->cwnd <= tp_vars->ss_threshold) {\r\ntp_vars->dec_cwnd = 0;\r\ntp_vars->cwnd = batadv_tp_cwnd(tp_vars->cwnd, mss, mss);\r\nspin_unlock_bh(&tp_vars->cwnd_lock);\r\nreturn;\r\n}\r\ntp_vars->dec_cwnd += max_t(u32, 1U << 3,\r\n((mss * mss) << 6) / (tp_vars->cwnd << 3));\r\nif (tp_vars->dec_cwnd < (mss << 3)) {\r\nspin_unlock_bh(&tp_vars->cwnd_lock);\r\nreturn;\r\n}\r\ntp_vars->cwnd = batadv_tp_cwnd(tp_vars->cwnd, mss, mss);\r\ntp_vars->dec_cwnd = 0;\r\nspin_unlock_bh(&tp_vars->cwnd_lock);\r\n}\r\nstatic void batadv_tp_update_rto(struct batadv_tp_vars *tp_vars,\r\nu32 new_rtt)\r\n{\r\nlong m = new_rtt;\r\nif (tp_vars->srtt != 0) {\r\nm -= (tp_vars->srtt >> 3);\r\ntp_vars->srtt += m;\r\nif (m < 0)\r\nm = -m;\r\nm -= (tp_vars->rttvar >> 2);\r\ntp_vars->rttvar += m;\r\n} else {\r\ntp_vars->srtt = m << 3;\r\ntp_vars->rttvar = m << 1;\r\n}\r\ntp_vars->rto = (tp_vars->srtt >> 3) + tp_vars->rttvar;\r\n}\r\nstatic void batadv_tp_batctl_notify(enum batadv_tp_meter_reason reason,\r\nconst u8 *dst, struct batadv_priv *bat_priv,\r\nunsigned long start_time, u64 total_sent,\r\nu32 cookie)\r\n{\r\nu32 test_time;\r\nu8 result;\r\nu32 total_bytes;\r\nif (!batadv_tp_is_error(reason)) {\r\nresult = BATADV_TP_REASON_COMPLETE;\r\ntest_time = jiffies_to_msecs(jiffies - start_time);\r\ntotal_bytes = total_sent;\r\n} else {\r\nresult = reason;\r\ntest_time = 0;\r\ntotal_bytes = 0;\r\n}\r\nbatadv_netlink_tpmeter_notify(bat_priv, dst, result, test_time,\r\ntotal_bytes, cookie);\r\n}\r\nstatic void batadv_tp_batctl_error_notify(enum batadv_tp_meter_reason reason,\r\nconst u8 *dst,\r\nstruct batadv_priv *bat_priv,\r\nu32 cookie)\r\n{\r\nbatadv_tp_batctl_notify(reason, dst, bat_priv, 0, 0, cookie);\r\n}\r\nstatic struct batadv_tp_vars *batadv_tp_list_find(struct batadv_priv *bat_priv,\r\nconst u8 *dst)\r\n{\r\nstruct batadv_tp_vars *pos, *tp_vars = NULL;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(pos, &bat_priv->tp_list, list) {\r\nif (!batadv_compare_eth(pos->other_end, dst))\r\ncontinue;\r\nif (unlikely(!kref_get_unless_zero(&pos->refcount)))\r\ncontinue;\r\ntp_vars = pos;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn tp_vars;\r\n}\r\nstatic struct batadv_tp_vars *\r\nbatadv_tp_list_find_session(struct batadv_priv *bat_priv, const u8 *dst,\r\nconst u8 *session)\r\n{\r\nstruct batadv_tp_vars *pos, *tp_vars = NULL;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(pos, &bat_priv->tp_list, list) {\r\nif (!batadv_compare_eth(pos->other_end, dst))\r\ncontinue;\r\nif (memcmp(pos->session, session, sizeof(pos->session)) != 0)\r\ncontinue;\r\nif (unlikely(!kref_get_unless_zero(&pos->refcount)))\r\ncontinue;\r\ntp_vars = pos;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn tp_vars;\r\n}\r\nstatic void batadv_tp_vars_release(struct kref *ref)\r\n{\r\nstruct batadv_tp_vars *tp_vars;\r\nstruct batadv_tp_unacked *un, *safe;\r\ntp_vars = container_of(ref, struct batadv_tp_vars, refcount);\r\nspin_lock_bh(&tp_vars->unacked_lock);\r\nlist_for_each_entry_safe(un, safe, &tp_vars->unacked_list, list) {\r\nlist_del(&un->list);\r\nkfree(un);\r\n}\r\nspin_unlock_bh(&tp_vars->unacked_lock);\r\nkfree_rcu(tp_vars, rcu);\r\n}\r\nstatic void batadv_tp_vars_put(struct batadv_tp_vars *tp_vars)\r\n{\r\nkref_put(&tp_vars->refcount, batadv_tp_vars_release);\r\n}\r\nstatic void batadv_tp_sender_cleanup(struct batadv_priv *bat_priv,\r\nstruct batadv_tp_vars *tp_vars)\r\n{\r\ncancel_delayed_work(&tp_vars->finish_work);\r\nspin_lock_bh(&tp_vars->bat_priv->tp_list_lock);\r\nhlist_del_rcu(&tp_vars->list);\r\nspin_unlock_bh(&tp_vars->bat_priv->tp_list_lock);\r\nbatadv_tp_vars_put(tp_vars);\r\natomic_dec(&tp_vars->bat_priv->tp_num);\r\ndel_timer_sync(&tp_vars->timer);\r\ndel_timer(&tp_vars->timer);\r\nbatadv_tp_vars_put(tp_vars);\r\n}\r\nstatic void batadv_tp_sender_end(struct batadv_priv *bat_priv,\r\nstruct batadv_tp_vars *tp_vars)\r\n{\r\nu32 session_cookie;\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Test towards %pM finished..shutting down (reason=%d)\n",\r\ntp_vars->other_end, tp_vars->reason);\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Last timing stats: SRTT=%ums RTTVAR=%ums RTO=%ums\n",\r\ntp_vars->srtt >> 3, tp_vars->rttvar >> 2, tp_vars->rto);\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Final values: cwnd=%u ss_threshold=%u\n",\r\ntp_vars->cwnd, tp_vars->ss_threshold);\r\nsession_cookie = batadv_tp_session_cookie(tp_vars->session,\r\ntp_vars->icmp_uid);\r\nbatadv_tp_batctl_notify(tp_vars->reason,\r\ntp_vars->other_end,\r\nbat_priv,\r\ntp_vars->start_time,\r\natomic64_read(&tp_vars->tot_sent),\r\nsession_cookie);\r\n}\r\nstatic void batadv_tp_sender_shutdown(struct batadv_tp_vars *tp_vars,\r\nenum batadv_tp_meter_reason reason)\r\n{\r\nif (!atomic_dec_and_test(&tp_vars->sending))\r\nreturn;\r\ntp_vars->reason = reason;\r\n}\r\nstatic void batadv_tp_sender_finish(struct work_struct *work)\r\n{\r\nstruct delayed_work *delayed_work;\r\nstruct batadv_tp_vars *tp_vars;\r\ndelayed_work = to_delayed_work(work);\r\ntp_vars = container_of(delayed_work, struct batadv_tp_vars,\r\nfinish_work);\r\nbatadv_tp_sender_shutdown(tp_vars, BATADV_TP_REASON_COMPLETE);\r\n}\r\nstatic void batadv_tp_reset_sender_timer(struct batadv_tp_vars *tp_vars)\r\n{\r\nif (unlikely(atomic_read(&tp_vars->sending) == 0))\r\nreturn;\r\nmod_timer(&tp_vars->timer, jiffies + msecs_to_jiffies(tp_vars->rto));\r\n}\r\nstatic void batadv_tp_sender_timeout(unsigned long arg)\r\n{\r\nstruct batadv_tp_vars *tp_vars = (struct batadv_tp_vars *)arg;\r\nstruct batadv_priv *bat_priv = tp_vars->bat_priv;\r\nif (atomic_read(&tp_vars->sending) == 0)\r\nreturn;\r\nif (unlikely(tp_vars->rto >= BATADV_TP_MAX_RTO)) {\r\nbatadv_tp_sender_shutdown(tp_vars,\r\nBATADV_TP_REASON_DST_UNREACHABLE);\r\nreturn;\r\n}\r\ntp_vars->rto <<= 1;\r\nspin_lock_bh(&tp_vars->cwnd_lock);\r\ntp_vars->ss_threshold = tp_vars->cwnd >> 1;\r\nif (tp_vars->ss_threshold < BATADV_TP_PLEN * 2)\r\ntp_vars->ss_threshold = BATADV_TP_PLEN * 2;\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Meter: RTO fired during test towards %pM! cwnd=%u new ss_thr=%u, resetting last_sent to %u\n",\r\ntp_vars->other_end, tp_vars->cwnd, tp_vars->ss_threshold,\r\natomic_read(&tp_vars->last_acked));\r\ntp_vars->cwnd = BATADV_TP_PLEN * 3;\r\nspin_unlock_bh(&tp_vars->cwnd_lock);\r\ntp_vars->last_sent = atomic_read(&tp_vars->last_acked);\r\nwake_up(&tp_vars->more_bytes);\r\nbatadv_tp_reset_sender_timer(tp_vars);\r\n}\r\nstatic void batadv_tp_fill_prerandom(struct batadv_tp_vars *tp_vars,\r\nu8 *buf, size_t nbytes)\r\n{\r\nu32 local_offset;\r\nsize_t bytes_inbuf;\r\nsize_t to_copy;\r\nsize_t pos = 0;\r\nspin_lock_bh(&tp_vars->prerandom_lock);\r\nlocal_offset = tp_vars->prerandom_offset;\r\ntp_vars->prerandom_offset += nbytes;\r\ntp_vars->prerandom_offset %= sizeof(batadv_tp_prerandom);\r\nspin_unlock_bh(&tp_vars->prerandom_lock);\r\nwhile (nbytes) {\r\nlocal_offset %= sizeof(batadv_tp_prerandom);\r\nbytes_inbuf = sizeof(batadv_tp_prerandom) - local_offset;\r\nto_copy = min(nbytes, bytes_inbuf);\r\nmemcpy(&buf[pos], &batadv_tp_prerandom[local_offset], to_copy);\r\npos += to_copy;\r\nnbytes -= to_copy;\r\nlocal_offset = 0;\r\n}\r\n}\r\nstatic int batadv_tp_send_msg(struct batadv_tp_vars *tp_vars, const u8 *src,\r\nstruct batadv_orig_node *orig_node,\r\nu32 seqno, size_t len, const u8 *session,\r\nint uid, u32 timestamp)\r\n{\r\nstruct batadv_icmp_tp_packet *icmp;\r\nstruct sk_buff *skb;\r\nint r;\r\nu8 *data;\r\nsize_t data_len;\r\nskb = netdev_alloc_skb_ip_align(NULL, len + ETH_HLEN);\r\nif (unlikely(!skb))\r\nreturn BATADV_TP_REASON_MEMORY_ERROR;\r\nskb_reserve(skb, ETH_HLEN);\r\nicmp = skb_put(skb, sizeof(*icmp));\r\nether_addr_copy(icmp->dst, orig_node->orig);\r\nether_addr_copy(icmp->orig, src);\r\nicmp->version = BATADV_COMPAT_VERSION;\r\nicmp->packet_type = BATADV_ICMP;\r\nicmp->ttl = BATADV_TTL;\r\nicmp->msg_type = BATADV_TP;\r\nicmp->uid = uid;\r\nicmp->subtype = BATADV_TP_MSG;\r\nmemcpy(icmp->session, session, sizeof(icmp->session));\r\nicmp->seqno = htonl(seqno);\r\nicmp->timestamp = htonl(timestamp);\r\ndata_len = len - sizeof(*icmp);\r\ndata = skb_put(skb, data_len);\r\nbatadv_tp_fill_prerandom(tp_vars, data, data_len);\r\nr = batadv_send_skb_to_orig(skb, orig_node, NULL);\r\nif (r == NET_XMIT_SUCCESS)\r\nreturn 0;\r\nreturn BATADV_TP_REASON_CANT_SEND;\r\n}\r\nstatic void batadv_tp_recv_ack(struct batadv_priv *bat_priv,\r\nconst struct sk_buff *skb)\r\n{\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nstruct batadv_orig_node *orig_node = NULL;\r\nconst struct batadv_icmp_tp_packet *icmp;\r\nstruct batadv_tp_vars *tp_vars;\r\nsize_t packet_len, mss;\r\nu32 rtt, recv_ack, cwnd;\r\nunsigned char *dev_addr;\r\npacket_len = BATADV_TP_PLEN;\r\nmss = BATADV_TP_PLEN;\r\npacket_len += sizeof(struct batadv_unicast_packet);\r\nicmp = (struct batadv_icmp_tp_packet *)skb->data;\r\ntp_vars = batadv_tp_list_find_session(bat_priv, icmp->orig,\r\nicmp->session);\r\nif (unlikely(!tp_vars))\r\nreturn;\r\nif (unlikely(atomic_read(&tp_vars->sending) == 0))\r\ngoto out;\r\nif (batadv_seq_before(ntohl(icmp->seqno),\r\n(u32)atomic_read(&tp_vars->last_acked)))\r\ngoto out;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (unlikely(!primary_if))\r\ngoto out;\r\norig_node = batadv_orig_hash_find(bat_priv, icmp->orig);\r\nif (unlikely(!orig_node))\r\ngoto out;\r\nrtt = jiffies_to_msecs(jiffies) - ntohl(icmp->timestamp);\r\nif (icmp->timestamp && rtt)\r\nbatadv_tp_update_rto(tp_vars, rtt);\r\nbatadv_tp_reset_sender_timer(tp_vars);\r\nrecv_ack = ntohl(icmp->seqno);\r\nif (atomic_read(&tp_vars->last_acked) == recv_ack) {\r\natomic_inc(&tp_vars->dup_acks);\r\nif (atomic_read(&tp_vars->dup_acks) != 3)\r\ngoto out;\r\nif (recv_ack >= tp_vars->recover)\r\ngoto out;\r\nbatadv_tp_send_msg(tp_vars, primary_if->net_dev->dev_addr,\r\norig_node, recv_ack, packet_len,\r\nicmp->session, icmp->uid,\r\njiffies_to_msecs(jiffies));\r\nspin_lock_bh(&tp_vars->cwnd_lock);\r\ntp_vars->fast_recovery = true;\r\ntp_vars->recover = tp_vars->last_sent;\r\ntp_vars->ss_threshold = tp_vars->cwnd >> 1;\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Meter: Fast Recovery, (cur cwnd=%u) ss_thr=%u last_sent=%u recv_ack=%u\n",\r\ntp_vars->cwnd, tp_vars->ss_threshold,\r\ntp_vars->last_sent, recv_ack);\r\ntp_vars->cwnd = batadv_tp_cwnd(tp_vars->ss_threshold, 3 * mss,\r\nmss);\r\ntp_vars->dec_cwnd = 0;\r\ntp_vars->last_sent = recv_ack;\r\nspin_unlock_bh(&tp_vars->cwnd_lock);\r\n} else {\r\natomic64_add(recv_ack - atomic_read(&tp_vars->last_acked),\r\n&tp_vars->tot_sent);\r\natomic_set(&tp_vars->dup_acks, 0);\r\nif (tp_vars->fast_recovery) {\r\nif (batadv_seq_before(recv_ack, tp_vars->recover)) {\r\ndev_addr = primary_if->net_dev->dev_addr;\r\nbatadv_tp_send_msg(tp_vars, dev_addr,\r\norig_node, recv_ack,\r\npacket_len, icmp->session,\r\nicmp->uid,\r\njiffies_to_msecs(jiffies));\r\ntp_vars->cwnd = batadv_tp_cwnd(tp_vars->cwnd,\r\nmss, mss);\r\n} else {\r\ntp_vars->fast_recovery = false;\r\ncwnd = batadv_tp_cwnd(tp_vars->ss_threshold, 0,\r\nmss);\r\ntp_vars->cwnd = cwnd;\r\n}\r\ngoto move_twnd;\r\n}\r\nif (recv_ack - atomic_read(&tp_vars->last_acked) >= mss)\r\nbatadv_tp_update_cwnd(tp_vars, mss);\r\nmove_twnd:\r\natomic_set(&tp_vars->last_acked, recv_ack);\r\n}\r\nwake_up(&tp_vars->more_bytes);\r\nout:\r\nif (likely(primary_if))\r\nbatadv_hardif_put(primary_if);\r\nif (likely(orig_node))\r\nbatadv_orig_node_put(orig_node);\r\nif (likely(tp_vars))\r\nbatadv_tp_vars_put(tp_vars);\r\n}\r\nstatic bool batadv_tp_avail(struct batadv_tp_vars *tp_vars,\r\nsize_t payload_len)\r\n{\r\nu32 win_left, win_limit;\r\nwin_limit = atomic_read(&tp_vars->last_acked) + tp_vars->cwnd;\r\nwin_left = win_limit - tp_vars->last_sent;\r\nreturn win_left >= payload_len;\r\n}\r\nstatic int batadv_tp_wait_available(struct batadv_tp_vars *tp_vars, size_t plen)\r\n{\r\nint ret;\r\nret = wait_event_interruptible_timeout(tp_vars->more_bytes,\r\nbatadv_tp_avail(tp_vars, plen),\r\nHZ / 10);\r\nreturn ret;\r\n}\r\nstatic int batadv_tp_send(void *arg)\r\n{\r\nstruct batadv_tp_vars *tp_vars = arg;\r\nstruct batadv_priv *bat_priv = tp_vars->bat_priv;\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nstruct batadv_orig_node *orig_node = NULL;\r\nsize_t payload_len, packet_len;\r\nint err = 0;\r\nif (unlikely(tp_vars->role != BATADV_TP_SENDER)) {\r\nerr = BATADV_TP_REASON_DST_UNREACHABLE;\r\ntp_vars->reason = err;\r\ngoto out;\r\n}\r\norig_node = batadv_orig_hash_find(bat_priv, tp_vars->other_end);\r\nif (unlikely(!orig_node)) {\r\nerr = BATADV_TP_REASON_DST_UNREACHABLE;\r\ntp_vars->reason = err;\r\ngoto out;\r\n}\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (unlikely(!primary_if)) {\r\nerr = BATADV_TP_REASON_DST_UNREACHABLE;\r\ntp_vars->reason = err;\r\ngoto out;\r\n}\r\npayload_len = BATADV_TP_PLEN;\r\nBUILD_BUG_ON(sizeof(struct batadv_icmp_tp_packet) > BATADV_TP_PLEN);\r\nbatadv_tp_reset_sender_timer(tp_vars);\r\nqueue_delayed_work(batadv_event_workqueue, &tp_vars->finish_work,\r\nmsecs_to_jiffies(tp_vars->test_length));\r\nwhile (atomic_read(&tp_vars->sending) != 0) {\r\nif (unlikely(!batadv_tp_avail(tp_vars, payload_len))) {\r\nbatadv_tp_wait_available(tp_vars, payload_len);\r\ncontinue;\r\n}\r\npacket_len = payload_len + sizeof(struct batadv_unicast_packet);\r\nerr = batadv_tp_send_msg(tp_vars, primary_if->net_dev->dev_addr,\r\norig_node, tp_vars->last_sent,\r\npacket_len,\r\ntp_vars->session, tp_vars->icmp_uid,\r\njiffies_to_msecs(jiffies));\r\nif (unlikely(err && err != BATADV_TP_REASON_CANT_SEND)) {\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Meter: %s() cannot send packets (%d)\n",\r\n__func__, err);\r\nif (atomic_dec_and_test(&tp_vars->sending))\r\ntp_vars->reason = err;\r\nbreak;\r\n}\r\nif (!err)\r\ntp_vars->last_sent += payload_len;\r\ncond_resched();\r\n}\r\nout:\r\nif (likely(primary_if))\r\nbatadv_hardif_put(primary_if);\r\nif (likely(orig_node))\r\nbatadv_orig_node_put(orig_node);\r\nbatadv_tp_sender_end(bat_priv, tp_vars);\r\nbatadv_tp_sender_cleanup(bat_priv, tp_vars);\r\nbatadv_tp_vars_put(tp_vars);\r\ndo_exit(0);\r\n}\r\nstatic void batadv_tp_start_kthread(struct batadv_tp_vars *tp_vars)\r\n{\r\nstruct task_struct *kthread;\r\nstruct batadv_priv *bat_priv = tp_vars->bat_priv;\r\nu32 session_cookie;\r\nkref_get(&tp_vars->refcount);\r\nkthread = kthread_create(batadv_tp_send, tp_vars, "kbatadv_tp_meter");\r\nif (IS_ERR(kthread)) {\r\nsession_cookie = batadv_tp_session_cookie(tp_vars->session,\r\ntp_vars->icmp_uid);\r\npr_err("batadv: cannot create tp meter kthread\n");\r\nbatadv_tp_batctl_error_notify(BATADV_TP_REASON_MEMORY_ERROR,\r\ntp_vars->other_end,\r\nbat_priv, session_cookie);\r\nbatadv_tp_vars_put(tp_vars);\r\nbatadv_tp_sender_cleanup(bat_priv, tp_vars);\r\nreturn;\r\n}\r\nwake_up_process(kthread);\r\n}\r\nvoid batadv_tp_start(struct batadv_priv *bat_priv, const u8 *dst,\r\nu32 test_length, u32 *cookie)\r\n{\r\nstruct batadv_tp_vars *tp_vars;\r\nu8 session_id[2];\r\nu8 icmp_uid;\r\nu32 session_cookie;\r\nget_random_bytes(session_id, sizeof(session_id));\r\nget_random_bytes(&icmp_uid, 1);\r\nsession_cookie = batadv_tp_session_cookie(session_id, icmp_uid);\r\n*cookie = session_cookie;\r\nspin_lock_bh(&bat_priv->tp_list_lock);\r\ntp_vars = batadv_tp_list_find(bat_priv, dst);\r\nif (tp_vars) {\r\nspin_unlock_bh(&bat_priv->tp_list_lock);\r\nbatadv_tp_vars_put(tp_vars);\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Meter: test to or from the same node already ongoing, aborting\n");\r\nbatadv_tp_batctl_error_notify(BATADV_TP_REASON_ALREADY_ONGOING,\r\ndst, bat_priv, session_cookie);\r\nreturn;\r\n}\r\nif (!atomic_add_unless(&bat_priv->tp_num, 1, BATADV_TP_MAX_NUM)) {\r\nspin_unlock_bh(&bat_priv->tp_list_lock);\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Meter: too many ongoing sessions, aborting (SEND)\n");\r\nbatadv_tp_batctl_error_notify(BATADV_TP_REASON_TOO_MANY, dst,\r\nbat_priv, session_cookie);\r\nreturn;\r\n}\r\ntp_vars = kmalloc(sizeof(*tp_vars), GFP_ATOMIC);\r\nif (!tp_vars) {\r\nspin_unlock_bh(&bat_priv->tp_list_lock);\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Meter: %s cannot allocate list elements\n",\r\n__func__);\r\nbatadv_tp_batctl_error_notify(BATADV_TP_REASON_MEMORY_ERROR,\r\ndst, bat_priv, session_cookie);\r\nreturn;\r\n}\r\nether_addr_copy(tp_vars->other_end, dst);\r\nkref_init(&tp_vars->refcount);\r\ntp_vars->role = BATADV_TP_SENDER;\r\natomic_set(&tp_vars->sending, 1);\r\nmemcpy(tp_vars->session, session_id, sizeof(session_id));\r\ntp_vars->icmp_uid = icmp_uid;\r\ntp_vars->last_sent = BATADV_TP_FIRST_SEQ;\r\natomic_set(&tp_vars->last_acked, BATADV_TP_FIRST_SEQ);\r\ntp_vars->fast_recovery = false;\r\ntp_vars->recover = BATADV_TP_FIRST_SEQ;\r\ntp_vars->cwnd = BATADV_TP_PLEN * 3;\r\ntp_vars->ss_threshold = BATADV_TP_AWND;\r\ntp_vars->rto = 1000;\r\ntp_vars->srtt = 0;\r\ntp_vars->rttvar = 0;\r\natomic64_set(&tp_vars->tot_sent, 0);\r\nkref_get(&tp_vars->refcount);\r\nsetup_timer(&tp_vars->timer, batadv_tp_sender_timeout,\r\n(unsigned long)tp_vars);\r\ntp_vars->bat_priv = bat_priv;\r\ntp_vars->start_time = jiffies;\r\ninit_waitqueue_head(&tp_vars->more_bytes);\r\nspin_lock_init(&tp_vars->unacked_lock);\r\nINIT_LIST_HEAD(&tp_vars->unacked_list);\r\nspin_lock_init(&tp_vars->cwnd_lock);\r\ntp_vars->prerandom_offset = 0;\r\nspin_lock_init(&tp_vars->prerandom_lock);\r\nkref_get(&tp_vars->refcount);\r\nhlist_add_head_rcu(&tp_vars->list, &bat_priv->tp_list);\r\nspin_unlock_bh(&bat_priv->tp_list_lock);\r\ntp_vars->test_length = test_length;\r\nif (!tp_vars->test_length)\r\ntp_vars->test_length = BATADV_TP_DEF_TEST_LENGTH;\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Meter: starting throughput meter towards %pM (length=%ums)\n",\r\ndst, test_length);\r\nINIT_DELAYED_WORK(&tp_vars->finish_work, batadv_tp_sender_finish);\r\nbatadv_tp_start_kthread(tp_vars);\r\nbatadv_tp_vars_put(tp_vars);\r\n}\r\nvoid batadv_tp_stop(struct batadv_priv *bat_priv, const u8 *dst,\r\nu8 return_value)\r\n{\r\nstruct batadv_orig_node *orig_node;\r\nstruct batadv_tp_vars *tp_vars;\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Meter: stopping test towards %pM\n", dst);\r\norig_node = batadv_orig_hash_find(bat_priv, dst);\r\nif (!orig_node)\r\nreturn;\r\ntp_vars = batadv_tp_list_find(bat_priv, orig_node->orig);\r\nif (!tp_vars) {\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Meter: trying to interrupt an already over connection\n");\r\ngoto out;\r\n}\r\nbatadv_tp_sender_shutdown(tp_vars, return_value);\r\nbatadv_tp_vars_put(tp_vars);\r\nout:\r\nbatadv_orig_node_put(orig_node);\r\n}\r\nstatic void batadv_tp_reset_receiver_timer(struct batadv_tp_vars *tp_vars)\r\n{\r\nmod_timer(&tp_vars->timer,\r\njiffies + msecs_to_jiffies(BATADV_TP_RECV_TIMEOUT));\r\n}\r\nstatic void batadv_tp_receiver_shutdown(unsigned long arg)\r\n{\r\nstruct batadv_tp_vars *tp_vars = (struct batadv_tp_vars *)arg;\r\nstruct batadv_tp_unacked *un, *safe;\r\nstruct batadv_priv *bat_priv;\r\nbat_priv = tp_vars->bat_priv;\r\nif (!batadv_has_timed_out(tp_vars->last_recv_time,\r\nBATADV_TP_RECV_TIMEOUT)) {\r\nbatadv_tp_reset_receiver_timer(tp_vars);\r\nreturn;\r\n}\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Shutting down for inactivity (more than %dms) from %pM\n",\r\nBATADV_TP_RECV_TIMEOUT, tp_vars->other_end);\r\nspin_lock_bh(&tp_vars->bat_priv->tp_list_lock);\r\nhlist_del_rcu(&tp_vars->list);\r\nspin_unlock_bh(&tp_vars->bat_priv->tp_list_lock);\r\nbatadv_tp_vars_put(tp_vars);\r\natomic_dec(&bat_priv->tp_num);\r\nspin_lock_bh(&tp_vars->unacked_lock);\r\nlist_for_each_entry_safe(un, safe, &tp_vars->unacked_list, list) {\r\nlist_del(&un->list);\r\nkfree(un);\r\n}\r\nspin_unlock_bh(&tp_vars->unacked_lock);\r\nbatadv_tp_vars_put(tp_vars);\r\n}\r\nstatic int batadv_tp_send_ack(struct batadv_priv *bat_priv, const u8 *dst,\r\nu32 seq, __be32 timestamp, const u8 *session,\r\nint socket_index)\r\n{\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nstruct batadv_orig_node *orig_node;\r\nstruct batadv_icmp_tp_packet *icmp;\r\nstruct sk_buff *skb;\r\nint r, ret;\r\norig_node = batadv_orig_hash_find(bat_priv, dst);\r\nif (unlikely(!orig_node)) {\r\nret = BATADV_TP_REASON_DST_UNREACHABLE;\r\ngoto out;\r\n}\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (unlikely(!primary_if)) {\r\nret = BATADV_TP_REASON_DST_UNREACHABLE;\r\ngoto out;\r\n}\r\nskb = netdev_alloc_skb_ip_align(NULL, sizeof(*icmp) + ETH_HLEN);\r\nif (unlikely(!skb)) {\r\nret = BATADV_TP_REASON_MEMORY_ERROR;\r\ngoto out;\r\n}\r\nskb_reserve(skb, ETH_HLEN);\r\nicmp = skb_put(skb, sizeof(*icmp));\r\nicmp->packet_type = BATADV_ICMP;\r\nicmp->version = BATADV_COMPAT_VERSION;\r\nicmp->ttl = BATADV_TTL;\r\nicmp->msg_type = BATADV_TP;\r\nether_addr_copy(icmp->dst, orig_node->orig);\r\nether_addr_copy(icmp->orig, primary_if->net_dev->dev_addr);\r\nicmp->uid = socket_index;\r\nicmp->subtype = BATADV_TP_ACK;\r\nmemcpy(icmp->session, session, sizeof(icmp->session));\r\nicmp->seqno = htonl(seq);\r\nicmp->timestamp = timestamp;\r\nr = batadv_send_skb_to_orig(skb, orig_node, NULL);\r\nif (unlikely(r < 0) || (r == NET_XMIT_DROP)) {\r\nret = BATADV_TP_REASON_DST_UNREACHABLE;\r\ngoto out;\r\n}\r\nret = 0;\r\nout:\r\nif (likely(orig_node))\r\nbatadv_orig_node_put(orig_node);\r\nif (likely(primary_if))\r\nbatadv_hardif_put(primary_if);\r\nreturn ret;\r\n}\r\nstatic bool batadv_tp_handle_out_of_order(struct batadv_tp_vars *tp_vars,\r\nconst struct sk_buff *skb)\r\n{\r\nconst struct batadv_icmp_tp_packet *icmp;\r\nstruct batadv_tp_unacked *un, *new;\r\nu32 payload_len;\r\nbool added = false;\r\nnew = kmalloc(sizeof(*new), GFP_ATOMIC);\r\nif (unlikely(!new))\r\nreturn false;\r\nicmp = (struct batadv_icmp_tp_packet *)skb->data;\r\nnew->seqno = ntohl(icmp->seqno);\r\npayload_len = skb->len - sizeof(struct batadv_unicast_packet);\r\nnew->len = payload_len;\r\nspin_lock_bh(&tp_vars->unacked_lock);\r\nif (list_empty(&tp_vars->unacked_list)) {\r\nlist_add(&new->list, &tp_vars->unacked_list);\r\ngoto out;\r\n}\r\nlist_for_each_entry_reverse(un, &tp_vars->unacked_list, list) {\r\nif (new->seqno == un->seqno) {\r\nif (new->len > un->len)\r\nun->len = new->len;\r\nkfree(new);\r\nadded = true;\r\nbreak;\r\n}\r\nif (batadv_seq_before(new->seqno, un->seqno))\r\ncontinue;\r\nlist_add_tail(&new->list, &un->list);\r\nadded = true;\r\nbreak;\r\n}\r\nif (!added)\r\nlist_add(&new->list, &tp_vars->unacked_list);\r\nout:\r\nspin_unlock_bh(&tp_vars->unacked_lock);\r\nreturn true;\r\n}\r\nstatic void batadv_tp_ack_unordered(struct batadv_tp_vars *tp_vars)\r\n{\r\nstruct batadv_tp_unacked *un, *safe;\r\nu32 to_ack;\r\nspin_lock_bh(&tp_vars->unacked_lock);\r\nlist_for_each_entry_safe(un, safe, &tp_vars->unacked_list, list) {\r\nif (batadv_seq_before(tp_vars->last_recv, un->seqno))\r\nbreak;\r\nto_ack = un->seqno + un->len - tp_vars->last_recv;\r\nif (batadv_seq_before(tp_vars->last_recv, un->seqno + un->len))\r\ntp_vars->last_recv += to_ack;\r\nlist_del(&un->list);\r\nkfree(un);\r\n}\r\nspin_unlock_bh(&tp_vars->unacked_lock);\r\n}\r\nstatic struct batadv_tp_vars *\r\nbatadv_tp_init_recv(struct batadv_priv *bat_priv,\r\nconst struct batadv_icmp_tp_packet *icmp)\r\n{\r\nstruct batadv_tp_vars *tp_vars;\r\nspin_lock_bh(&bat_priv->tp_list_lock);\r\ntp_vars = batadv_tp_list_find_session(bat_priv, icmp->orig,\r\nicmp->session);\r\nif (tp_vars)\r\ngoto out_unlock;\r\nif (!atomic_add_unless(&bat_priv->tp_num, 1, BATADV_TP_MAX_NUM)) {\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Meter: too many ongoing sessions, aborting (RECV)\n");\r\ngoto out_unlock;\r\n}\r\ntp_vars = kmalloc(sizeof(*tp_vars), GFP_ATOMIC);\r\nif (!tp_vars)\r\ngoto out_unlock;\r\nether_addr_copy(tp_vars->other_end, icmp->orig);\r\ntp_vars->role = BATADV_TP_RECEIVER;\r\nmemcpy(tp_vars->session, icmp->session, sizeof(tp_vars->session));\r\ntp_vars->last_recv = BATADV_TP_FIRST_SEQ;\r\ntp_vars->bat_priv = bat_priv;\r\nkref_init(&tp_vars->refcount);\r\nspin_lock_init(&tp_vars->unacked_lock);\r\nINIT_LIST_HEAD(&tp_vars->unacked_list);\r\nkref_get(&tp_vars->refcount);\r\nhlist_add_head_rcu(&tp_vars->list, &bat_priv->tp_list);\r\nkref_get(&tp_vars->refcount);\r\nsetup_timer(&tp_vars->timer, batadv_tp_receiver_shutdown,\r\n(unsigned long)tp_vars);\r\nbatadv_tp_reset_receiver_timer(tp_vars);\r\nout_unlock:\r\nspin_unlock_bh(&bat_priv->tp_list_lock);\r\nreturn tp_vars;\r\n}\r\nstatic void batadv_tp_recv_msg(struct batadv_priv *bat_priv,\r\nconst struct sk_buff *skb)\r\n{\r\nconst struct batadv_icmp_tp_packet *icmp;\r\nstruct batadv_tp_vars *tp_vars;\r\nsize_t packet_size;\r\nu32 seqno;\r\nicmp = (struct batadv_icmp_tp_packet *)skb->data;\r\nseqno = ntohl(icmp->seqno);\r\nif (seqno == BATADV_TP_FIRST_SEQ) {\r\ntp_vars = batadv_tp_init_recv(bat_priv, icmp);\r\nif (!tp_vars) {\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Meter: seqno != BATADV_TP_FIRST_SEQ cannot initiate connection\n");\r\ngoto out;\r\n}\r\n} else {\r\ntp_vars = batadv_tp_list_find_session(bat_priv, icmp->orig,\r\nicmp->session);\r\nif (!tp_vars) {\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Unexpected packet from %pM!\n",\r\nicmp->orig);\r\ngoto out;\r\n}\r\n}\r\nif (unlikely(tp_vars->role != BATADV_TP_RECEIVER)) {\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Meter: dropping packet: not expected (role=%u)\n",\r\ntp_vars->role);\r\ngoto out;\r\n}\r\ntp_vars->last_recv_time = jiffies;\r\nif (batadv_seq_before(seqno, tp_vars->last_recv))\r\ngoto send_ack;\r\nif (ntohl(icmp->seqno) != tp_vars->last_recv) {\r\nif (!batadv_tp_handle_out_of_order(tp_vars, skb))\r\ngoto out;\r\ngoto send_ack;\r\n}\r\npacket_size = skb->len - sizeof(struct batadv_unicast_packet);\r\ntp_vars->last_recv += packet_size;\r\nbatadv_tp_ack_unordered(tp_vars);\r\nsend_ack:\r\nbatadv_tp_send_ack(bat_priv, icmp->orig, tp_vars->last_recv,\r\nicmp->timestamp, icmp->session, icmp->uid);\r\nout:\r\nif (likely(tp_vars))\r\nbatadv_tp_vars_put(tp_vars);\r\n}\r\nvoid batadv_tp_meter_recv(struct batadv_priv *bat_priv, struct sk_buff *skb)\r\n{\r\nstruct batadv_icmp_tp_packet *icmp;\r\nicmp = (struct batadv_icmp_tp_packet *)skb->data;\r\nswitch (icmp->subtype) {\r\ncase BATADV_TP_MSG:\r\nbatadv_tp_recv_msg(bat_priv, skb);\r\nbreak;\r\ncase BATADV_TP_ACK:\r\nbatadv_tp_recv_ack(bat_priv, skb);\r\nbreak;\r\ndefault:\r\nbatadv_dbg(BATADV_DBG_TP_METER, bat_priv,\r\n"Received unknown TP Metric packet type %u\n",\r\nicmp->subtype);\r\n}\r\nconsume_skb(skb);\r\n}\r\nvoid __init batadv_tp_meter_init(void)\r\n{\r\nget_random_bytes(batadv_tp_prerandom, sizeof(batadv_tp_prerandom));\r\n}
