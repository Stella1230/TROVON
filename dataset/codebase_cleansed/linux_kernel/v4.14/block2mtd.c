static struct page *page_read(struct address_space *mapping, int index)\r\n{\r\nreturn read_mapping_page(mapping, index, NULL);\r\n}\r\nstatic int _block2mtd_erase(struct block2mtd_dev *dev, loff_t to, size_t len)\r\n{\r\nstruct address_space *mapping = dev->blkdev->bd_inode->i_mapping;\r\nstruct page *page;\r\nint index = to >> PAGE_SHIFT;\r\nint pages = len >> PAGE_SHIFT;\r\nu_long *p;\r\nu_long *max;\r\nwhile (pages) {\r\npage = page_read(mapping, index);\r\nif (IS_ERR(page))\r\nreturn PTR_ERR(page);\r\nmax = page_address(page) + PAGE_SIZE;\r\nfor (p=page_address(page); p<max; p++)\r\nif (*p != -1UL) {\r\nlock_page(page);\r\nmemset(page_address(page), 0xff, PAGE_SIZE);\r\nset_page_dirty(page);\r\nunlock_page(page);\r\nbalance_dirty_pages_ratelimited(mapping);\r\nbreak;\r\n}\r\nput_page(page);\r\npages--;\r\nindex++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int block2mtd_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nstruct block2mtd_dev *dev = mtd->priv;\r\nsize_t from = instr->addr;\r\nsize_t len = instr->len;\r\nint err;\r\ninstr->state = MTD_ERASING;\r\nmutex_lock(&dev->write_mutex);\r\nerr = _block2mtd_erase(dev, from, len);\r\nmutex_unlock(&dev->write_mutex);\r\nif (err) {\r\npr_err("erase failed err = %d\n", err);\r\ninstr->state = MTD_ERASE_FAILED;\r\n} else\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn err;\r\n}\r\nstatic int block2mtd_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct block2mtd_dev *dev = mtd->priv;\r\nstruct page *page;\r\nint index = from >> PAGE_SHIFT;\r\nint offset = from & (PAGE_SIZE-1);\r\nint cpylen;\r\nwhile (len) {\r\nif ((offset + len) > PAGE_SIZE)\r\ncpylen = PAGE_SIZE - offset;\r\nelse\r\ncpylen = len;\r\nlen = len - cpylen;\r\npage = page_read(dev->blkdev->bd_inode->i_mapping, index);\r\nif (IS_ERR(page))\r\nreturn PTR_ERR(page);\r\nmemcpy(buf, page_address(page) + offset, cpylen);\r\nput_page(page);\r\nif (retlen)\r\n*retlen += cpylen;\r\nbuf += cpylen;\r\noffset = 0;\r\nindex++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int _block2mtd_write(struct block2mtd_dev *dev, const u_char *buf,\r\nloff_t to, size_t len, size_t *retlen)\r\n{\r\nstruct page *page;\r\nstruct address_space *mapping = dev->blkdev->bd_inode->i_mapping;\r\nint index = to >> PAGE_SHIFT;\r\nint offset = to & ~PAGE_MASK;\r\nint cpylen;\r\nwhile (len) {\r\nif ((offset+len) > PAGE_SIZE)\r\ncpylen = PAGE_SIZE - offset;\r\nelse\r\ncpylen = len;\r\nlen = len - cpylen;\r\npage = page_read(mapping, index);\r\nif (IS_ERR(page))\r\nreturn PTR_ERR(page);\r\nif (memcmp(page_address(page)+offset, buf, cpylen)) {\r\nlock_page(page);\r\nmemcpy(page_address(page) + offset, buf, cpylen);\r\nset_page_dirty(page);\r\nunlock_page(page);\r\nbalance_dirty_pages_ratelimited(mapping);\r\n}\r\nput_page(page);\r\nif (retlen)\r\n*retlen += cpylen;\r\nbuf += cpylen;\r\noffset = 0;\r\nindex++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int block2mtd_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct block2mtd_dev *dev = mtd->priv;\r\nint err;\r\nmutex_lock(&dev->write_mutex);\r\nerr = _block2mtd_write(dev, buf, to, len, retlen);\r\nmutex_unlock(&dev->write_mutex);\r\nif (err > 0)\r\nerr = 0;\r\nreturn err;\r\n}\r\nstatic void block2mtd_sync(struct mtd_info *mtd)\r\n{\r\nstruct block2mtd_dev *dev = mtd->priv;\r\nsync_blockdev(dev->blkdev);\r\nreturn;\r\n}\r\nstatic void block2mtd_free_device(struct block2mtd_dev *dev)\r\n{\r\nif (!dev)\r\nreturn;\r\nkfree(dev->mtd.name);\r\nif (dev->blkdev) {\r\ninvalidate_mapping_pages(dev->blkdev->bd_inode->i_mapping,\r\n0, -1);\r\nblkdev_put(dev->blkdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\r\n}\r\nkfree(dev);\r\n}\r\nstatic struct block2mtd_dev *add_device(char *devname, int erase_size,\r\nint timeout)\r\n{\r\n#ifndef MODULE\r\nint i;\r\n#endif\r\nconst fmode_t mode = FMODE_READ | FMODE_WRITE | FMODE_EXCL;\r\nstruct block_device *bdev = ERR_PTR(-ENODEV);\r\nstruct block2mtd_dev *dev;\r\nchar *name;\r\nif (!devname)\r\nreturn NULL;\r\ndev = kzalloc(sizeof(struct block2mtd_dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn NULL;\r\nbdev = blkdev_get_by_path(devname, mode, dev);\r\n#ifndef MODULE\r\nfor (i = 0; IS_ERR(bdev) && i <= timeout; i++) {\r\ndev_t devt;\r\nif (i)\r\nmsleep(1000);\r\nwait_for_device_probe();\r\ndevt = name_to_dev_t(devname);\r\nif (!devt)\r\ncontinue;\r\nbdev = blkdev_get_by_dev(devt, mode, dev);\r\n}\r\n#endif\r\nif (IS_ERR(bdev)) {\r\npr_err("error: cannot open device %s\n", devname);\r\ngoto err_free_block2mtd;\r\n}\r\ndev->blkdev = bdev;\r\nif (MAJOR(bdev->bd_dev) == MTD_BLOCK_MAJOR) {\r\npr_err("attempting to use an MTD device as a block device\n");\r\ngoto err_free_block2mtd;\r\n}\r\nif ((long)dev->blkdev->bd_inode->i_size % erase_size) {\r\npr_err("erasesize must be a divisor of device size\n");\r\ngoto err_free_block2mtd;\r\n}\r\nmutex_init(&dev->write_mutex);\r\nname = kasprintf(GFP_KERNEL, "block2mtd: %s", devname);\r\nif (!name)\r\ngoto err_destroy_mutex;\r\ndev->mtd.name = name;\r\ndev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK;\r\ndev->mtd.erasesize = erase_size;\r\ndev->mtd.writesize = 1;\r\ndev->mtd.writebufsize = PAGE_SIZE;\r\ndev->mtd.type = MTD_RAM;\r\ndev->mtd.flags = MTD_CAP_RAM;\r\ndev->mtd._erase = block2mtd_erase;\r\ndev->mtd._write = block2mtd_write;\r\ndev->mtd._sync = block2mtd_sync;\r\ndev->mtd._read = block2mtd_read;\r\ndev->mtd.priv = dev;\r\ndev->mtd.owner = THIS_MODULE;\r\nif (mtd_device_register(&dev->mtd, NULL, 0)) {\r\ngoto err_destroy_mutex;\r\n}\r\nlist_add(&dev->list, &blkmtd_device_list);\r\npr_info("mtd%d: [%s] erase_size = %dKiB [%d]\n",\r\ndev->mtd.index,\r\ndev->mtd.name + strlen("block2mtd: "),\r\ndev->mtd.erasesize >> 10, dev->mtd.erasesize);\r\nreturn dev;\r\nerr_destroy_mutex:\r\nmutex_destroy(&dev->write_mutex);\r\nerr_free_block2mtd:\r\nblock2mtd_free_device(dev);\r\nreturn NULL;\r\n}\r\nstatic int ustrtoul(const char *cp, char **endp, unsigned int base)\r\n{\r\nunsigned long result = simple_strtoul(cp, endp, base);\r\nswitch (**endp) {\r\ncase 'G' :\r\nresult *= 1024;\r\ncase 'M':\r\nresult *= 1024;\r\ncase 'K':\r\ncase 'k':\r\nresult *= 1024;\r\nif ((*endp)[1] == 'i') {\r\nif ((*endp)[2] == 'B')\r\n(*endp) += 3;\r\nelse\r\n(*endp) += 2;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int parse_num(size_t *num, const char *token)\r\n{\r\nchar *endp;\r\nsize_t n;\r\nn = (size_t) ustrtoul(token, &endp, 0);\r\nif (*endp)\r\nreturn -EINVAL;\r\n*num = n;\r\nreturn 0;\r\n}\r\nstatic inline void kill_final_newline(char *str)\r\n{\r\nchar *newline = strrchr(str, '\n');\r\nif (newline && !newline[1])\r\n*newline = 0;\r\n}\r\nstatic int block2mtd_setup2(const char *val)\r\n{\r\nchar buf[80 + 12 + 80 + 8];\r\nchar *str = buf;\r\nchar *token[2];\r\nchar *name;\r\nsize_t erase_size = PAGE_SIZE;\r\nunsigned long timeout = MTD_DEFAULT_TIMEOUT;\r\nint i, ret;\r\nif (strnlen(val, sizeof(buf)) >= sizeof(buf)) {\r\npr_err("parameter too long\n");\r\nreturn 0;\r\n}\r\nstrcpy(str, val);\r\nkill_final_newline(str);\r\nfor (i = 0; i < 2; i++)\r\ntoken[i] = strsep(&str, ",");\r\nif (str) {\r\npr_err("too many arguments\n");\r\nreturn 0;\r\n}\r\nif (!token[0]) {\r\npr_err("no argument\n");\r\nreturn 0;\r\n}\r\nname = token[0];\r\nif (strlen(name) + 1 > 80) {\r\npr_err("device name too long\n");\r\nreturn 0;\r\n}\r\nif (token[1]) {\r\nret = parse_num(&erase_size, token[1]);\r\nif (ret) {\r\npr_err("illegal erase size\n");\r\nreturn 0;\r\n}\r\n}\r\nadd_device(name, erase_size, timeout);\r\nreturn 0;\r\n}\r\nstatic int block2mtd_setup(const char *val, struct kernel_param *kp)\r\n{\r\n#ifdef MODULE\r\nreturn block2mtd_setup2(val);\r\n#else\r\nif (block2mtd_init_called)\r\nreturn block2mtd_setup2(val);\r\nstrlcpy(block2mtd_paramline, val, sizeof(block2mtd_paramline));\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int __init block2mtd_init(void)\r\n{\r\nint ret = 0;\r\n#ifndef MODULE\r\nif (strlen(block2mtd_paramline))\r\nret = block2mtd_setup2(block2mtd_paramline);\r\nblock2mtd_init_called = 1;\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void block2mtd_exit(void)\r\n{\r\nstruct list_head *pos, *next;\r\nlist_for_each_safe(pos, next, &blkmtd_device_list) {\r\nstruct block2mtd_dev *dev = list_entry(pos, typeof(*dev), list);\r\nblock2mtd_sync(&dev->mtd);\r\nmtd_device_unregister(&dev->mtd);\r\nmutex_destroy(&dev->write_mutex);\r\npr_info("mtd%d: [%s] removed\n",\r\ndev->mtd.index,\r\ndev->mtd.name + strlen("block2mtd: "));\r\nlist_del(&dev->list);\r\nblock2mtd_free_device(dev);\r\n}\r\n}
