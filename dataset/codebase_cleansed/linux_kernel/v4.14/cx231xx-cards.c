int cx231xx_tuner_callback(void *ptr, int component, int command, int arg)\r\n{\r\nint rc = 0;\r\nstruct cx231xx *dev = ptr;\r\nif (dev->tuner_type == TUNER_XC5000) {\r\nif (command == XC5000_TUNER_RESET) {\r\ndev_dbg(dev->dev,\r\n"Tuner CB: RESET: cmd %d : tuner type %d\n",\r\ncommand, dev->tuner_type);\r\ncx231xx_set_gpio_value(dev, dev->board.tuner_gpio->bit,\r\n1);\r\nmsleep(10);\r\ncx231xx_set_gpio_value(dev, dev->board.tuner_gpio->bit,\r\n0);\r\nmsleep(330);\r\ncx231xx_set_gpio_value(dev, dev->board.tuner_gpio->bit,\r\n1);\r\nmsleep(10);\r\n}\r\n} else if (dev->tuner_type == TUNER_NXP_TDA18271) {\r\nswitch (command) {\r\ncase TDA18271_CALLBACK_CMD_AGC_ENABLE:\r\nif (dev->model == CX231XX_BOARD_PV_PLAYTV_USB_HYBRID)\r\nrc = cx231xx_set_agc_analog_digital_mux_select(dev, arg);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic void cx231xx_reset_out(struct cx231xx *dev)\r\n{\r\ncx231xx_set_gpio_value(dev, CX23417_RESET, 1);\r\nmsleep(200);\r\ncx231xx_set_gpio_value(dev, CX23417_RESET, 0);\r\nmsleep(200);\r\ncx231xx_set_gpio_value(dev, CX23417_RESET, 1);\r\n}\r\nstatic void cx231xx_enable_OSC(struct cx231xx *dev)\r\n{\r\ncx231xx_set_gpio_value(dev, CX23417_OSC_EN, 1);\r\n}\r\nstatic void cx231xx_sleep_s5h1432(struct cx231xx *dev)\r\n{\r\ncx231xx_set_gpio_value(dev, SLEEP_S5H1432, 0);\r\n}\r\nstatic inline void cx231xx_set_model(struct cx231xx *dev)\r\n{\r\ndev->board = cx231xx_boards[dev->model];\r\n}\r\nvoid cx231xx_pre_card_setup(struct cx231xx *dev)\r\n{\r\ndev_info(dev->dev, "Identified as %s (card=%d)\n",\r\ndev->board.name, dev->model);\r\nif (CX231XX_BOARD_ASTROMETA_T2HYBRID == dev->model) {\r\ncx231xx_set_gpio_value(dev, 0x03, 0x01);\r\n}\r\nif (dev->board.tuner_gpio) {\r\ncx231xx_set_gpio_direction(dev, dev->board.tuner_gpio->bit, 1);\r\ncx231xx_set_gpio_value(dev, dev->board.tuner_gpio->bit, 1);\r\n}\r\nif (dev->board.tuner_sif_gpio >= 0)\r\ncx231xx_set_gpio_direction(dev, dev->board.tuner_sif_gpio, 1);\r\ncx231xx_set_mode(dev, CX231XX_ANALOG_MODE);\r\n}\r\nstatic void cx231xx_config_tuner(struct cx231xx *dev)\r\n{\r\nstruct tuner_setup tun_setup;\r\nstruct v4l2_frequency f;\r\nif (dev->tuner_type == TUNER_ABSENT)\r\nreturn;\r\ntun_setup.mode_mask = T_ANALOG_TV | T_RADIO;\r\ntun_setup.type = dev->tuner_type;\r\ntun_setup.addr = dev->tuner_addr;\r\ntun_setup.tuner_callback = cx231xx_tuner_callback;\r\ntuner_call(dev, tuner, s_type_addr, &tun_setup);\r\n#if 0\r\nif (tun_setup.type == TUNER_XC5000) {\r\nstatic struct xc2028_ctrl ctrl = {\r\n.fname = XC5000_DEFAULT_FIRMWARE,\r\n.max_len = 64,\r\n.demod = 0;\r\n};\r\nstruct v4l2_priv_tun_config cfg = {\r\n.tuner = dev->tuner_type,\r\n.priv = &ctrl,\r\n};\r\ntuner_call(dev, tuner, s_config, &cfg);\r\n}\r\n#endif\r\nf.tuner = 0;\r\nf.type = V4L2_TUNER_ANALOG_TV;\r\nf.frequency = 9076;\r\ndev->ctl_freq = f.frequency;\r\ncall_all(dev, tuner, s_frequency, &f);\r\n}\r\nstatic int read_eeprom(struct cx231xx *dev, struct i2c_client *client,\r\nu8 *eedata, int len)\r\n{\r\nint ret = 0;\r\nu8 start_offset = 0;\r\nint len_todo = len;\r\nu8 *eedata_cur = eedata;\r\nint i;\r\nstruct i2c_msg msg_write = { .addr = client->addr, .flags = 0,\r\n.buf = &start_offset, .len = 1 };\r\nstruct i2c_msg msg_read = { .addr = client->addr, .flags = I2C_M_RD };\r\nret = i2c_transfer(client->adapter, &msg_write, 1);\r\nif (ret < 0) {\r\ndev_err(dev->dev, "Can't read eeprom\n");\r\nreturn ret;\r\n}\r\nwhile (len_todo > 0) {\r\nmsg_read.len = (len_todo > 64) ? 64 : len_todo;\r\nmsg_read.buf = eedata_cur;\r\nret = i2c_transfer(client->adapter, &msg_read, 1);\r\nif (ret < 0) {\r\ndev_err(dev->dev, "Can't read eeprom\n");\r\nreturn ret;\r\n}\r\needata_cur += msg_read.len;\r\nlen_todo -= msg_read.len;\r\n}\r\nfor (i = 0; i + 15 < len; i += 16)\r\ndev_dbg(dev->dev, "i2c eeprom %02x: %*ph\n",\r\ni, 16, &eedata[i]);\r\nreturn 0;\r\n}\r\nvoid cx231xx_card_setup(struct cx231xx *dev)\r\n{\r\ncx231xx_set_model(dev);\r\ndev->tuner_type = cx231xx_boards[dev->model].tuner_type;\r\nif (cx231xx_boards[dev->model].tuner_addr)\r\ndev->tuner_addr = cx231xx_boards[dev->model].tuner_addr;\r\nif (dev->board.decoder == CX231XX_AVDECODER) {\r\ndev->sd_cx25840 = v4l2_i2c_new_subdev(&dev->v4l2_dev,\r\ncx231xx_get_i2c_adap(dev, I2C_0),\r\n"cx25840", 0x88 >> 1, NULL);\r\nif (dev->sd_cx25840 == NULL)\r\ndev_err(dev->dev,\r\n"cx25840 subdev registration failure\n");\r\ncx25840_call(dev, core, load_fw);\r\n}\r\nif (dev->board.tuner_type != TUNER_ABSENT) {\r\nstruct i2c_adapter *tuner_i2c = cx231xx_get_i2c_adap(dev,\r\ndev->board.tuner_i2c_master);\r\ndev->sd_tuner = v4l2_i2c_new_subdev(&dev->v4l2_dev,\r\ntuner_i2c,\r\n"tuner",\r\ndev->tuner_addr, NULL);\r\nif (dev->sd_tuner == NULL)\r\ndev_err(dev->dev,\r\n"tuner subdev registration failure\n");\r\nelse\r\ncx231xx_config_tuner(dev);\r\n}\r\nswitch (dev->model) {\r\ncase CX231XX_BOARD_HAUPPAUGE_930C_HD_1113xx:\r\ncase CX231XX_BOARD_HAUPPAUGE_930C_HD_1114xx:\r\ncase CX231XX_BOARD_HAUPPAUGE_955Q:\r\n{\r\nstruct eeprom {\r\nstruct tveeprom tvee;\r\nu8 eeprom[256];\r\nstruct i2c_client client;\r\n};\r\nstruct eeprom *e = kzalloc(sizeof(*e), GFP_KERNEL);\r\nif (e == NULL) {\r\ndev_err(dev->dev,\r\n"failed to allocate memory to read eeprom\n");\r\nbreak;\r\n}\r\ne->client.adapter = cx231xx_get_i2c_adap(dev, I2C_1_MUX_1);\r\ne->client.addr = 0xa0 >> 1;\r\nread_eeprom(dev, &e->client, e->eeprom, sizeof(e->eeprom));\r\ntveeprom_hauppauge_analog(&e->tvee, e->eeprom + 0xc0);\r\nkfree(e);\r\nbreak;\r\n}\r\n}\r\n}\r\nint cx231xx_config(struct cx231xx *dev)\r\n{\r\nreturn 0;\r\n}\r\nvoid cx231xx_config_i2c(struct cx231xx *dev)\r\n{\r\ncall_all(dev, video, s_stream, 1);\r\n}\r\nstatic void cx231xx_unregister_media_device(struct cx231xx *dev)\r\n{\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nif (dev->media_dev) {\r\nmedia_device_unregister(dev->media_dev);\r\nmedia_device_cleanup(dev->media_dev);\r\nkfree(dev->media_dev);\r\ndev->media_dev = NULL;\r\n}\r\n#endif\r\n}\r\nvoid cx231xx_release_resources(struct cx231xx *dev)\r\n{\r\ncx231xx_ir_exit(dev);\r\ncx231xx_release_analog_resources(dev);\r\ncx231xx_remove_from_devlist(dev);\r\ncx231xx_dev_uninit(dev);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\ncx231xx_unregister_media_device(dev);\r\nusb_put_dev(dev->udev);\r\nclear_bit(dev->devno, &cx231xx_devused);\r\n}\r\nstatic int cx231xx_media_device_init(struct cx231xx *dev,\r\nstruct usb_device *udev)\r\n{\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nstruct media_device *mdev;\r\nmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\r\nif (!mdev)\r\nreturn -ENOMEM;\r\nmedia_device_usb_init(mdev, udev, dev->board.name);\r\ndev->media_dev = mdev;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int cx231xx_init_dev(struct cx231xx *dev, struct usb_device *udev,\r\nint minor)\r\n{\r\nint retval = -ENOMEM;\r\nunsigned int maxh, maxw;\r\ndev->udev = udev;\r\nmutex_init(&dev->lock);\r\nmutex_init(&dev->ctrl_urb_lock);\r\nmutex_init(&dev->gpio_i2c_lock);\r\nmutex_init(&dev->i2c_lock);\r\nspin_lock_init(&dev->video_mode.slock);\r\nspin_lock_init(&dev->vbi_mode.slock);\r\nspin_lock_init(&dev->sliced_cc_mode.slock);\r\ninit_waitqueue_head(&dev->open);\r\ninit_waitqueue_head(&dev->wait_frame);\r\ninit_waitqueue_head(&dev->wait_stream);\r\ndev->cx231xx_read_ctrl_reg = cx231xx_read_ctrl_reg;\r\ndev->cx231xx_write_ctrl_reg = cx231xx_write_ctrl_reg;\r\ndev->cx231xx_send_usb_command = cx231xx_send_usb_command;\r\ndev->cx231xx_gpio_i2c_read = cx231xx_gpio_i2c_read;\r\ndev->cx231xx_gpio_i2c_write = cx231xx_gpio_i2c_write;\r\nretval = initialize_cx231xx(dev);\r\nif (retval < 0) {\r\ndev_err(dev->dev, "Failed to read PCB config\n");\r\nreturn retval;\r\n}\r\nif (dev->model == CX231XX_BOARD_CNXT_VIDEO_GRABBER ||\r\ndev->model == CX231XX_BOARD_HAUPPAUGE_USBLIVE2) {\r\ncx231xx_set_alt_setting(dev, INDEX_VIDEO, 3);\r\ncx231xx_set_alt_setting(dev, INDEX_VANC, 1);\r\n}\r\ncx231xx_pre_card_setup(dev);\r\nretval = cx231xx_config(dev);\r\nif (retval) {\r\ndev_err(dev->dev, "error configuring device\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->norm = dev->board.norm;\r\nretval = cx231xx_dev_init(dev);\r\nif (retval) {\r\ndev_err(dev->dev,\r\n"%s: cx231xx_i2c_register - errCode [%d]!\n",\r\n__func__, retval);\r\ngoto err_dev_init;\r\n}\r\ncx231xx_card_setup(dev);\r\ncx231xx_config_i2c(dev);\r\nmaxw = norm_maxw(dev);\r\nmaxh = norm_maxh(dev);\r\ndev->width = maxw;\r\ndev->height = maxh;\r\ndev->interlaced = 0;\r\ndev->video_input = 0;\r\nretval = cx231xx_config(dev);\r\nif (retval) {\r\ndev_err(dev->dev, "%s: cx231xx_config - errCode [%d]!\n",\r\n__func__, retval);\r\ngoto err_dev_init;\r\n}\r\nINIT_LIST_HEAD(&dev->video_mode.vidq.active);\r\nINIT_LIST_HEAD(&dev->video_mode.vidq.queued);\r\nINIT_LIST_HEAD(&dev->vbi_mode.vidq.active);\r\nINIT_LIST_HEAD(&dev->vbi_mode.vidq.queued);\r\ncx231xx_add_into_devlist(dev);\r\nif (dev->board.has_417) {\r\ndev_info(dev->dev, "attach 417 %d\n", dev->model);\r\nif (cx231xx_417_register(dev) < 0) {\r\ndev_err(dev->dev,\r\n"%s() Failed to register 417 on VID_B\n",\r\n__func__);\r\n}\r\n}\r\nretval = cx231xx_register_analog_devices(dev);\r\nif (retval)\r\ngoto err_analog;\r\ncx231xx_ir_init(dev);\r\ncx231xx_init_extension(dev);\r\nreturn 0;\r\nerr_analog:\r\ncx231xx_unregister_media_device(dev);\r\ncx231xx_release_analog_resources(dev);\r\ncx231xx_remove_from_devlist(dev);\r\nerr_dev_init:\r\ncx231xx_dev_uninit(dev);\r\nreturn retval;\r\n}\r\nstatic void request_module_async(struct work_struct *work)\r\n{\r\nstruct cx231xx *dev = container_of(work,\r\nstruct cx231xx, request_module_wk);\r\nif (dev->has_alsa_audio)\r\nrequest_module("cx231xx-alsa");\r\nif (dev->board.has_dvb)\r\nrequest_module("cx231xx-dvb");\r\n}\r\nstatic void request_modules(struct cx231xx *dev)\r\n{\r\nINIT_WORK(&dev->request_module_wk, request_module_async);\r\nschedule_work(&dev->request_module_wk);\r\n}\r\nstatic void flush_request_modules(struct cx231xx *dev)\r\n{\r\nflush_work(&dev->request_module_wk);\r\n}\r\nstatic int cx231xx_init_v4l2(struct cx231xx *dev,\r\nstruct usb_device *udev,\r\nstruct usb_interface *interface,\r\nint isoc_pipe)\r\n{\r\nstruct usb_interface *uif;\r\nint i, idx;\r\nidx = dev->current_pcb_config.hs_config_info[0].interface_info.video_index + 1;\r\nif (idx >= dev->max_iad_interface_count) {\r\ndev_err(dev->dev,\r\n"Video PCB interface #%d doesn't exist\n", idx);\r\nreturn -ENODEV;\r\n}\r\nuif = udev->actconfig->interface[idx];\r\nif (uif->altsetting[0].desc.bNumEndpoints < isoc_pipe + 1)\r\nreturn -ENODEV;\r\ndev->video_mode.end_point_addr = uif->altsetting[0].endpoint[isoc_pipe].desc.bEndpointAddress;\r\ndev->video_mode.num_alt = uif->num_altsetting;\r\ndev_info(dev->dev,\r\n"video EndPoint Addr 0x%x, Alternate settings: %i\n",\r\ndev->video_mode.end_point_addr,\r\ndev->video_mode.num_alt);\r\ndev->video_mode.alt_max_pkt_size = devm_kmalloc_array(&udev->dev, 32, dev->video_mode.num_alt, GFP_KERNEL);\r\nif (dev->video_mode.alt_max_pkt_size == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < dev->video_mode.num_alt; i++) {\r\nu16 tmp;\r\nif (uif->altsetting[i].desc.bNumEndpoints < isoc_pipe + 1)\r\nreturn -ENODEV;\r\ntmp = le16_to_cpu(uif->altsetting[i].endpoint[isoc_pipe].desc.wMaxPacketSize);\r\ndev->video_mode.alt_max_pkt_size[i] = (tmp & 0x07ff) * (((tmp & 0x1800) >> 11) + 1);\r\ndev_dbg(dev->dev,\r\n"Alternate setting %i, max size= %i\n", i,\r\ndev->video_mode.alt_max_pkt_size[i]);\r\n}\r\nidx = dev->current_pcb_config.hs_config_info[0].interface_info.vanc_index + 1;\r\nif (idx >= dev->max_iad_interface_count) {\r\ndev_err(dev->dev,\r\n"VBI PCB interface #%d doesn't exist\n", idx);\r\nreturn -ENODEV;\r\n}\r\nuif = udev->actconfig->interface[idx];\r\nif (uif->altsetting[0].desc.bNumEndpoints < isoc_pipe + 1)\r\nreturn -ENODEV;\r\ndev->vbi_mode.end_point_addr =\r\nuif->altsetting[0].endpoint[isoc_pipe].desc.\r\nbEndpointAddress;\r\ndev->vbi_mode.num_alt = uif->num_altsetting;\r\ndev_info(dev->dev,\r\n"VBI EndPoint Addr 0x%x, Alternate settings: %i\n",\r\ndev->vbi_mode.end_point_addr,\r\ndev->vbi_mode.num_alt);\r\ndev->vbi_mode.alt_max_pkt_size = devm_kmalloc_array(&udev->dev, 32, dev->vbi_mode.num_alt, GFP_KERNEL);\r\nif (dev->vbi_mode.alt_max_pkt_size == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < dev->vbi_mode.num_alt; i++) {\r\nu16 tmp;\r\nif (uif->altsetting[i].desc.bNumEndpoints < isoc_pipe + 1)\r\nreturn -ENODEV;\r\ntmp = le16_to_cpu(uif->altsetting[i].endpoint[isoc_pipe].\r\ndesc.wMaxPacketSize);\r\ndev->vbi_mode.alt_max_pkt_size[i] =\r\n(tmp & 0x07ff) * (((tmp & 0x1800) >> 11) + 1);\r\ndev_dbg(dev->dev,\r\n"Alternate setting %i, max size= %i\n", i,\r\ndev->vbi_mode.alt_max_pkt_size[i]);\r\n}\r\nidx = dev->current_pcb_config.hs_config_info[0].interface_info.hanc_index + 1;\r\nif (idx >= dev->max_iad_interface_count) {\r\ndev_err(dev->dev,\r\n"Sliced CC PCB interface #%d doesn't exist\n", idx);\r\nreturn -ENODEV;\r\n}\r\nuif = udev->actconfig->interface[idx];\r\nif (uif->altsetting[0].desc.bNumEndpoints < isoc_pipe + 1)\r\nreturn -ENODEV;\r\ndev->sliced_cc_mode.end_point_addr =\r\nuif->altsetting[0].endpoint[isoc_pipe].desc.\r\nbEndpointAddress;\r\ndev->sliced_cc_mode.num_alt = uif->num_altsetting;\r\ndev_info(dev->dev,\r\n"sliced CC EndPoint Addr 0x%x, Alternate settings: %i\n",\r\ndev->sliced_cc_mode.end_point_addr,\r\ndev->sliced_cc_mode.num_alt);\r\ndev->sliced_cc_mode.alt_max_pkt_size = devm_kmalloc_array(&udev->dev, 32, dev->sliced_cc_mode.num_alt, GFP_KERNEL);\r\nif (dev->sliced_cc_mode.alt_max_pkt_size == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < dev->sliced_cc_mode.num_alt; i++) {\r\nu16 tmp;\r\nif (uif->altsetting[i].desc.bNumEndpoints < isoc_pipe + 1)\r\nreturn -ENODEV;\r\ntmp = le16_to_cpu(uif->altsetting[i].endpoint[isoc_pipe].\r\ndesc.wMaxPacketSize);\r\ndev->sliced_cc_mode.alt_max_pkt_size[i] =\r\n(tmp & 0x07ff) * (((tmp & 0x1800) >> 11) + 1);\r\ndev_dbg(dev->dev,\r\n"Alternate setting %i, max size= %i\n", i,\r\ndev->sliced_cc_mode.alt_max_pkt_size[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx231xx_usb_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev;\r\nstruct device *d = &interface->dev;\r\nstruct usb_interface *uif;\r\nstruct cx231xx *dev = NULL;\r\nint retval = -ENODEV;\r\nint nr = 0, ifnum;\r\nint i, isoc_pipe = 0;\r\nchar *speed;\r\nu8 idx;\r\nstruct usb_interface_assoc_descriptor *assoc_desc;\r\nifnum = interface->altsetting[0].desc.bInterfaceNumber;\r\nif (ifnum != 1)\r\nreturn -ENODEV;\r\ndo {\r\nnr = find_first_zero_bit(&cx231xx_devused, CX231XX_MAXBOARDS);\r\nif (nr >= CX231XX_MAXBOARDS) {\r\ndev_err(d,\r\n"Supports only %i devices.\n",\r\nCX231XX_MAXBOARDS);\r\nreturn -ENOMEM;\r\n}\r\n} while (test_and_set_bit(nr, &cx231xx_devused));\r\nudev = usb_get_dev(interface_to_usbdev(interface));\r\ndev = devm_kzalloc(&udev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\nretval = -ENOMEM;\r\ngoto err_if;\r\n}\r\nsnprintf(dev->name, 29, "cx231xx #%d", nr);\r\ndev->devno = nr;\r\ndev->model = id->driver_info;\r\ndev->video_mode.alt = -1;\r\ndev->dev = d;\r\ncx231xx_set_model(dev);\r\ndev->interface_count++;\r\ndev->gpio_dir = 0;\r\ndev->gpio_val = 0;\r\ndev->xc_fw_load_done = 0;\r\ndev->has_alsa_audio = 1;\r\ndev->power_mode = -1;\r\natomic_set(&dev->devlist_count, 0);\r\ndev->vbi_or_sliced_cc_mode = 0;\r\ndev->max_iad_interface_count = udev->config->desc.bNumInterfaces;\r\ndev->mode_tv = 0;\r\ndev->USE_ISO = transfer_mode;\r\nswitch (udev->speed) {\r\ncase USB_SPEED_LOW:\r\nspeed = "1.5";\r\nbreak;\r\ncase USB_SPEED_UNKNOWN:\r\ncase USB_SPEED_FULL:\r\nspeed = "12";\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nspeed = "480";\r\nbreak;\r\ndefault:\r\nspeed = "unknown";\r\n}\r\ndev_info(d,\r\n"New device %s %s @ %s Mbps (%04x:%04x) with %d interfaces\n",\r\nudev->manufacturer ? udev->manufacturer : "",\r\nudev->product ? udev->product : "",\r\nspeed,\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct),\r\ndev->max_iad_interface_count);\r\ndev->interface_count++;\r\nnr = dev->devno;\r\nassoc_desc = udev->actconfig->intf_assoc[0];\r\nif (assoc_desc->bFirstInterface != ifnum) {\r\ndev_err(d, "Not found matching IAD interface\n");\r\nretval = -ENODEV;\r\ngoto err_if;\r\n}\r\ndev_dbg(d, "registering interface %d\n", ifnum);\r\nusb_set_intfdata(interface, dev);\r\nretval = cx231xx_media_device_init(dev, udev);\r\nif (retval) {\r\ndev_err(d, "cx231xx_media_device_init failed\n");\r\ngoto err_media_init;\r\n}\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\ndev->v4l2_dev.mdev = dev->media_dev;\r\n#endif\r\nretval = v4l2_device_register(&interface->dev, &dev->v4l2_dev);\r\nif (retval) {\r\ndev_err(d, "v4l2_device_register failed\n");\r\ngoto err_v4l2;\r\n}\r\nretval = cx231xx_init_dev(dev, udev, nr);\r\nif (retval)\r\ngoto err_init;\r\nretval = cx231xx_init_v4l2(dev, udev, interface, isoc_pipe);\r\nif (retval)\r\ngoto err_init;\r\nif (dev->current_pcb_config.ts1_source != 0xff) {\r\nidx = dev->current_pcb_config.hs_config_info[0].interface_info.ts1_index + 1;\r\nif (idx >= dev->max_iad_interface_count) {\r\ndev_err(d, "TS1 PCB interface #%d doesn't exist\n",\r\nidx);\r\nretval = -ENODEV;\r\ngoto err_video_alt;\r\n}\r\nuif = udev->actconfig->interface[idx];\r\nif (uif->altsetting[0].desc.bNumEndpoints < isoc_pipe + 1) {\r\nretval = -ENODEV;\r\ngoto err_video_alt;\r\n}\r\ndev->ts1_mode.end_point_addr =\r\nuif->altsetting[0].endpoint[isoc_pipe].\r\ndesc.bEndpointAddress;\r\ndev->ts1_mode.num_alt = uif->num_altsetting;\r\ndev_info(d,\r\n"TS EndPoint Addr 0x%x, Alternate settings: %i\n",\r\ndev->ts1_mode.end_point_addr,\r\ndev->ts1_mode.num_alt);\r\ndev->ts1_mode.alt_max_pkt_size = devm_kmalloc_array(&udev->dev, 32, dev->ts1_mode.num_alt, GFP_KERNEL);\r\nif (dev->ts1_mode.alt_max_pkt_size == NULL) {\r\nretval = -ENOMEM;\r\ngoto err_video_alt;\r\n}\r\nfor (i = 0; i < dev->ts1_mode.num_alt; i++) {\r\nu16 tmp;\r\nif (uif->altsetting[i].desc.bNumEndpoints < isoc_pipe + 1) {\r\nretval = -ENODEV;\r\ngoto err_video_alt;\r\n}\r\ntmp = le16_to_cpu(uif->altsetting[i].\r\nendpoint[isoc_pipe].desc.\r\nwMaxPacketSize);\r\ndev->ts1_mode.alt_max_pkt_size[i] =\r\n(tmp & 0x07ff) * (((tmp & 0x1800) >> 11) + 1);\r\ndev_dbg(d, "Alternate setting %i, max size= %i\n",\r\ni, dev->ts1_mode.alt_max_pkt_size[i]);\r\n}\r\n}\r\nif (dev->model == CX231XX_BOARD_CNXT_VIDEO_GRABBER) {\r\ncx231xx_enable_OSC(dev);\r\ncx231xx_reset_out(dev);\r\ncx231xx_set_alt_setting(dev, INDEX_VIDEO, 3);\r\n}\r\nif (dev->model == CX231XX_BOARD_CNXT_RDE_253S)\r\ncx231xx_sleep_s5h1432(dev);\r\nrequest_modules(dev);\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\ncx231xx_v4l2_create_entities(dev);\r\nretval = v4l2_mc_create_media_graph(dev->media_dev);\r\nif (!retval)\r\nretval = media_device_register(dev->media_dev);\r\n#endif\r\nif (retval < 0)\r\ncx231xx_release_resources(dev);\r\nreturn retval;\r\nerr_video_alt:\r\ncx231xx_close_extension(dev);\r\ncx231xx_ir_exit(dev);\r\ncx231xx_release_analog_resources(dev);\r\ncx231xx_417_unregister(dev);\r\ncx231xx_remove_from_devlist(dev);\r\ncx231xx_dev_uninit(dev);\r\nerr_init:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nerr_v4l2:\r\ncx231xx_unregister_media_device(dev);\r\nerr_media_init:\r\nusb_set_intfdata(interface, NULL);\r\nerr_if:\r\nusb_put_dev(udev);\r\nclear_bit(nr, &cx231xx_devused);\r\nreturn retval;\r\n}\r\nstatic void cx231xx_usb_disconnect(struct usb_interface *interface)\r\n{\r\nstruct cx231xx *dev;\r\ndev = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\nif (!dev)\r\nreturn;\r\nif (!dev->udev)\r\nreturn;\r\ndev->state |= DEV_DISCONNECTED;\r\nflush_request_modules(dev);\r\nmutex_lock(&dev->lock);\r\nwake_up_interruptible_all(&dev->open);\r\nif (dev->users) {\r\ndev_warn(dev->dev,\r\n"device %s is open! Deregistration and memory deallocation are deferred on close.\n",\r\nvideo_device_node_name(&dev->vdev));\r\ncx231xx_ir_exit(dev);\r\nif (dev->USE_ISO)\r\ncx231xx_uninit_isoc(dev);\r\nelse\r\ncx231xx_uninit_bulk(dev);\r\nwake_up_interruptible(&dev->wait_frame);\r\nwake_up_interruptible(&dev->wait_stream);\r\n} else {\r\n}\r\ncx231xx_close_extension(dev);\r\nmutex_unlock(&dev->lock);\r\nif (!dev->users)\r\ncx231xx_release_resources(dev);\r\n}
