static inline struct mmp_camera *mcam_to_cam(struct mcam_camera *mcam)\r\n{\r\nreturn container_of(mcam, struct mmp_camera, mcam);\r\n}\r\nstatic void mmpcam_add_device(struct mmp_camera *cam)\r\n{\r\nmutex_lock(&mmpcam_devices_lock);\r\nlist_add(&cam->devlist, &mmpcam_devices);\r\nmutex_unlock(&mmpcam_devices_lock);\r\n}\r\nstatic void mmpcam_remove_device(struct mmp_camera *cam)\r\n{\r\nmutex_lock(&mmpcam_devices_lock);\r\nlist_del(&cam->devlist);\r\nmutex_unlock(&mmpcam_devices_lock);\r\n}\r\nstatic struct mmp_camera *mmpcam_find_device(struct platform_device *pdev)\r\n{\r\nstruct mmp_camera *cam;\r\nmutex_lock(&mmpcam_devices_lock);\r\nlist_for_each_entry(cam, &mmpcam_devices, devlist) {\r\nif (cam->pdev == pdev) {\r\nmutex_unlock(&mmpcam_devices_lock);\r\nreturn cam;\r\n}\r\n}\r\nmutex_unlock(&mmpcam_devices_lock);\r\nreturn NULL;\r\n}\r\nstatic void mcam_clk_enable(struct mcam_camera *mcam)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < NR_MCAM_CLK; i++) {\r\nif (!IS_ERR(mcam->clk[i]))\r\nclk_prepare_enable(mcam->clk[i]);\r\n}\r\n}\r\nstatic void mcam_clk_disable(struct mcam_camera *mcam)\r\n{\r\nint i;\r\nfor (i = NR_MCAM_CLK - 1; i >= 0; i--) {\r\nif (!IS_ERR(mcam->clk[i]))\r\nclk_disable_unprepare(mcam->clk[i]);\r\n}\r\n}\r\nstatic void mmpcam_power_up_ctlr(struct mmp_camera *cam)\r\n{\r\niowrite32(0x3f, cam->power_regs + REG_CCIC_DCGCR);\r\niowrite32(0x3805b, cam->power_regs + REG_CCIC_CRCR);\r\nmdelay(1);\r\n}\r\nstatic int mmpcam_power_up(struct mcam_camera *mcam)\r\n{\r\nstruct mmp_camera *cam = mcam_to_cam(mcam);\r\nstruct mmp_camera_platform_data *pdata;\r\nmmpcam_power_up_ctlr(cam);\r\nmcam_reg_write(mcam, REG_CLKCTRL, 0x60000002);\r\npdata = cam->pdev->dev.platform_data;\r\ngpio_set_value(pdata->sensor_power_gpio, 1);\r\nmdelay(5);\r\nmcam_reg_clear_bit(mcam, REG_CTRL1, 0x10000000);\r\ngpio_set_value(pdata->sensor_reset_gpio, 0);\r\nmdelay(5);\r\ngpio_set_value(pdata->sensor_reset_gpio, 1);\r\nmdelay(5);\r\nmcam_clk_enable(mcam);\r\nreturn 0;\r\n}\r\nstatic void mmpcam_power_down(struct mcam_camera *mcam)\r\n{\r\nstruct mmp_camera *cam = mcam_to_cam(mcam);\r\nstruct mmp_camera_platform_data *pdata;\r\niowrite32(0, cam->power_regs + REG_CCIC_DCGCR);\r\niowrite32(0, cam->power_regs + REG_CCIC_CRCR);\r\npdata = cam->pdev->dev.platform_data;\r\ngpio_set_value(pdata->sensor_power_gpio, 0);\r\ngpio_set_value(pdata->sensor_reset_gpio, 0);\r\nmcam_clk_disable(mcam);\r\n}\r\nvoid mcam_ctlr_reset(struct mcam_camera *mcam)\r\n{\r\nunsigned long val;\r\nstruct mmp_camera *cam = mcam_to_cam(mcam);\r\nif (mcam->ccic_id) {\r\nval = ioread32(cam->power_regs + REG_CCIC2_CRCR);\r\niowrite32(val & ~0x2, cam->power_regs + REG_CCIC2_CRCR);\r\niowrite32(val | 0x2, cam->power_regs + REG_CCIC2_CRCR);\r\n} else {\r\nval = ioread32(cam->power_regs + REG_CCIC_CRCR);\r\niowrite32(val & ~0x2, cam->power_regs + REG_CCIC_CRCR);\r\niowrite32(val | 0x2, cam->power_regs + REG_CCIC_CRCR);\r\n}\r\n}\r\nvoid mmpcam_calc_dphy(struct mcam_camera *mcam)\r\n{\r\nstruct mmp_camera *cam = mcam_to_cam(mcam);\r\nstruct mmp_camera_platform_data *pdata = cam->pdev->dev.platform_data;\r\nstruct device *dev = &cam->pdev->dev;\r\nunsigned long tx_clk_esc;\r\nswitch (pdata->dphy3_algo) {\r\ncase DPHY3_ALGO_PXA910:\r\npdata->dphy[0] =\r\n(((1 + (pdata->lane_clk * 80) / 1000) & 0xff) << 8)\r\n| (1 + pdata->lane_clk * 35 / 1000);\r\nbreak;\r\ncase DPHY3_ALGO_PXA2128:\r\npdata->dphy[0] =\r\n(((2 + (pdata->lane_clk * 110) / 1000) & 0xff) << 8)\r\n| (1 + pdata->lane_clk * 35 / 1000);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "camera: use the default CSI2_DPHY3 value\n");\r\n}\r\nif (IS_ERR(cam->mipi_clk))\r\nreturn;\r\nclk_prepare_enable(cam->mipi_clk);\r\ntx_clk_esc = (clk_get_rate(cam->mipi_clk) / 1000000) / 12;\r\nclk_disable_unprepare(cam->mipi_clk);\r\npdata->dphy[2] =\r\n((((534 * tx_clk_esc) / 2000 - 1) & 0xff) << 8)\r\n| (((38 * tx_clk_esc) / 1000 - 1) & 0xff);\r\ndev_dbg(dev, "camera: DPHY sets: dphy3=0x%x, dphy5=0x%x, dphy6=0x%x\n",\r\npdata->dphy[0], pdata->dphy[1], pdata->dphy[2]);\r\n}\r\nstatic irqreturn_t mmpcam_irq(int irq, void *data)\r\n{\r\nstruct mcam_camera *mcam = data;\r\nunsigned int irqs, handled;\r\nspin_lock(&mcam->dev_lock);\r\nirqs = mcam_reg_read(mcam, REG_IRQSTAT);\r\nhandled = mccic_irq(mcam, irqs);\r\nspin_unlock(&mcam->dev_lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void mcam_init_clk(struct mcam_camera *mcam)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < NR_MCAM_CLK; i++) {\r\nif (mcam_clks[i] != NULL) {\r\nmcam->clk[i] = devm_clk_get(mcam->dev, mcam_clks[i]);\r\nif (IS_ERR(mcam->clk[i]))\r\ndev_warn(mcam->dev, "Could not get clk: %s\n",\r\nmcam_clks[i]);\r\n}\r\n}\r\n}\r\nstatic int mmpcam_probe(struct platform_device *pdev)\r\n{\r\nstruct mmp_camera *cam;\r\nstruct mcam_camera *mcam;\r\nstruct resource *res;\r\nstruct mmp_camera_platform_data *pdata;\r\nint ret;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata)\r\nreturn -ENODEV;\r\ncam = devm_kzalloc(&pdev->dev, sizeof(*cam), GFP_KERNEL);\r\nif (cam == NULL)\r\nreturn -ENOMEM;\r\ncam->pdev = pdev;\r\nINIT_LIST_HEAD(&cam->devlist);\r\nmcam = &cam->mcam;\r\nmcam->plat_power_up = mmpcam_power_up;\r\nmcam->plat_power_down = mmpcam_power_down;\r\nmcam->ctlr_reset = mcam_ctlr_reset;\r\nmcam->calc_dphy = mmpcam_calc_dphy;\r\nmcam->dev = &pdev->dev;\r\nmcam->use_smbus = 0;\r\nmcam->ccic_id = pdev->id;\r\nmcam->mclk_min = pdata->mclk_min;\r\nmcam->mclk_src = pdata->mclk_src;\r\nmcam->mclk_div = pdata->mclk_div;\r\nmcam->bus_type = pdata->bus_type;\r\nmcam->dphy = pdata->dphy;\r\nif (mcam->bus_type == V4L2_MBUS_CSI2) {\r\ncam->mipi_clk = devm_clk_get(mcam->dev, "mipi");\r\nif ((IS_ERR(cam->mipi_clk) && mcam->dphy[2] == 0))\r\nreturn PTR_ERR(cam->mipi_clk);\r\n}\r\nmcam->mipi_enabled = false;\r\nmcam->lane = pdata->lane;\r\nmcam->chip_id = MCAM_ARMADA610;\r\nmcam->buffer_mode = B_DMA_sg;\r\nstrlcpy(mcam->bus_info, "platform:mmp-camera", sizeof(mcam->bus_info));\r\nspin_lock_init(&mcam->dev_lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmcam->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mcam->regs))\r\nreturn PTR_ERR(mcam->regs);\r\nmcam->regs_size = resource_size(res);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\ncam->power_regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(cam->power_regs))\r\nreturn PTR_ERR(cam->power_regs);\r\nmcam->i2c_adapter = platform_get_drvdata(pdata->i2c_device);\r\nif (mcam->i2c_adapter == NULL) {\r\ndev_err(&pdev->dev, "No i2c adapter\n");\r\nreturn -ENODEV;\r\n}\r\nret = devm_gpio_request(&pdev->dev, pdata->sensor_power_gpio,\r\n"cam-power");\r\nif (ret) {\r\ndev_err(&pdev->dev, "Can't get sensor power gpio %d",\r\npdata->sensor_power_gpio);\r\nreturn ret;\r\n}\r\ngpio_direction_output(pdata->sensor_power_gpio, 0);\r\nret = devm_gpio_request(&pdev->dev, pdata->sensor_reset_gpio,\r\n"cam-reset");\r\nif (ret) {\r\ndev_err(&pdev->dev, "Can't get sensor reset gpio %d",\r\npdata->sensor_reset_gpio);\r\nreturn ret;\r\n}\r\ngpio_direction_output(pdata->sensor_reset_gpio, 0);\r\nmcam_init_clk(mcam);\r\nret = mmpcam_power_up(mcam);\r\nif (ret)\r\nreturn ret;\r\nret = mccic_register(mcam);\r\nif (ret)\r\ngoto out_power_down;\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res == NULL) {\r\nret = -ENODEV;\r\ngoto out_unregister;\r\n}\r\ncam->irq = res->start;\r\nret = devm_request_irq(&pdev->dev, cam->irq, mmpcam_irq, IRQF_SHARED,\r\n"mmp-camera", mcam);\r\nif (ret == 0) {\r\nmmpcam_add_device(cam);\r\nreturn 0;\r\n}\r\nout_unregister:\r\nmccic_shutdown(mcam);\r\nout_power_down:\r\nmmpcam_power_down(mcam);\r\nreturn ret;\r\n}\r\nstatic int mmpcam_remove(struct mmp_camera *cam)\r\n{\r\nstruct mcam_camera *mcam = &cam->mcam;\r\nmmpcam_remove_device(cam);\r\nmccic_shutdown(mcam);\r\nmmpcam_power_down(mcam);\r\nreturn 0;\r\n}\r\nstatic int mmpcam_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct mmp_camera *cam = mmpcam_find_device(pdev);\r\nif (cam == NULL)\r\nreturn -ENODEV;\r\nreturn mmpcam_remove(cam);\r\n}\r\nstatic int mmpcam_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct mmp_camera *cam = mmpcam_find_device(pdev);\r\nif (state.event != PM_EVENT_SUSPEND)\r\nreturn 0;\r\nmccic_suspend(&cam->mcam);\r\nreturn 0;\r\n}\r\nstatic int mmpcam_resume(struct platform_device *pdev)\r\n{\r\nstruct mmp_camera *cam = mmpcam_find_device(pdev);\r\nmmpcam_power_up_ctlr(cam);\r\nreturn mccic_resume(&cam->mcam);\r\n}\r\nstatic int __init mmpcam_init_module(void)\r\n{\r\nmutex_init(&mmpcam_devices_lock);\r\nreturn platform_driver_register(&mmpcam_driver);\r\n}\r\nstatic void __exit mmpcam_exit_module(void)\r\n{\r\nplatform_driver_unregister(&mmpcam_driver);\r\nif (!list_empty(&mmpcam_devices))\r\nprintk(KERN_ERR "mmp_camera leaving devices behind\n");\r\n}
