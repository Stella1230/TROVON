static u32\r\nnvbios_power_budget_table(struct nvkm_bios *bios, u8 *ver, u8 *hdr, u8 *cnt,\r\nu8 *len)\r\n{\r\nstruct bit_entry bit_P;\r\nu32 power_budget;\r\nif (bit_entry(bios, 'P', &bit_P) || bit_P.version != 2 ||\r\nbit_P.length < 0x30)\r\nreturn 0;\r\npower_budget = nvbios_rd32(bios, bit_P.offset + 0x2c);\r\nif (!power_budget)\r\nreturn 0;\r\n*ver = nvbios_rd08(bios, power_budget);\r\nswitch (*ver) {\r\ncase 0x20:\r\ncase 0x30:\r\n*hdr = nvbios_rd08(bios, power_budget + 0x1);\r\n*len = nvbios_rd08(bios, power_budget + 0x2);\r\n*cnt = nvbios_rd08(bios, power_budget + 0x3);\r\nreturn power_budget;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnvbios_power_budget_header(struct nvkm_bios *bios,\r\nstruct nvbios_power_budget *budget)\r\n{\r\nstruct nvkm_subdev *subdev = &bios->subdev;\r\nu8 ver, hdr, cnt, len, cap_entry;\r\nu32 header;\r\nif (!bios || !budget)\r\nreturn -EINVAL;\r\nheader = nvbios_power_budget_table(bios, &ver, &hdr, &cnt, &len);\r\nif (!header || !cnt)\r\nreturn -ENODEV;\r\nswitch (ver) {\r\ncase 0x20:\r\ncap_entry = nvbios_rd08(bios, header + 0x9);\r\nbreak;\r\ncase 0x30:\r\ncap_entry = nvbios_rd08(bios, header + 0xa);\r\nbreak;\r\ndefault:\r\ncap_entry = 0xff;\r\n}\r\nif (cap_entry >= cnt && cap_entry != 0xff) {\r\nnvkm_warn(subdev,\r\n"invalid cap_entry in power budget table found\n");\r\nbudget->cap_entry = 0xff;\r\nreturn -EINVAL;\r\n}\r\nbudget->offset = header;\r\nbudget->ver = ver;\r\nbudget->hlen = hdr;\r\nbudget->elen = len;\r\nbudget->ecount = cnt;\r\nbudget->cap_entry = cap_entry;\r\nreturn 0;\r\n}\r\nint\r\nnvbios_power_budget_entry(struct nvkm_bios *bios,\r\nstruct nvbios_power_budget *budget,\r\nu8 idx, struct nvbios_power_budget_entry *entry)\r\n{\r\nu32 entry_offset;\r\nif (!bios || !budget || !budget->offset || idx >= budget->ecount\r\n|| !entry)\r\nreturn -EINVAL;\r\nentry_offset = budget->offset + budget->hlen + idx * budget->elen;\r\nif (budget->ver >= 0x20) {\r\nentry->min_w = nvbios_rd32(bios, entry_offset + 0x2);\r\nentry->avg_w = nvbios_rd32(bios, entry_offset + 0x6);\r\nentry->max_w = nvbios_rd32(bios, entry_offset + 0xa);\r\n} else {\r\nentry->min_w = 0;\r\nentry->max_w = nvbios_rd32(bios, entry_offset + 0x2);\r\nentry->avg_w = entry->max_w;\r\n}\r\nreturn 0;\r\n}
