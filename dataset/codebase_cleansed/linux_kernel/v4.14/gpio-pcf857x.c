static int i2c_write_le8(struct i2c_client *client, unsigned data)\r\n{\r\nreturn i2c_smbus_write_byte(client, data);\r\n}\r\nstatic int i2c_read_le8(struct i2c_client *client)\r\n{\r\nreturn (int)i2c_smbus_read_byte(client);\r\n}\r\nstatic int i2c_write_le16(struct i2c_client *client, unsigned word)\r\n{\r\nu8 buf[2] = { word & 0xff, word >> 8, };\r\nint status;\r\nstatus = i2c_master_send(client, buf, 2);\r\nreturn (status < 0) ? status : 0;\r\n}\r\nstatic int i2c_read_le16(struct i2c_client *client)\r\n{\r\nu8 buf[2];\r\nint status;\r\nstatus = i2c_master_recv(client, buf, 2);\r\nif (status < 0)\r\nreturn status;\r\nreturn (buf[1] << 8) | buf[0];\r\n}\r\nstatic int pcf857x_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pcf857x *gpio = gpiochip_get_data(chip);\r\nint status;\r\nmutex_lock(&gpio->lock);\r\ngpio->out |= (1 << offset);\r\nstatus = gpio->write(gpio->client, gpio->out);\r\nmutex_unlock(&gpio->lock);\r\nreturn status;\r\n}\r\nstatic int pcf857x_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pcf857x *gpio = gpiochip_get_data(chip);\r\nint value;\r\nvalue = gpio->read(gpio->client);\r\nreturn (value < 0) ? value : !!(value & (1 << offset));\r\n}\r\nstatic int pcf857x_output(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct pcf857x *gpio = gpiochip_get_data(chip);\r\nunsigned bit = 1 << offset;\r\nint status;\r\nmutex_lock(&gpio->lock);\r\nif (value)\r\ngpio->out |= bit;\r\nelse\r\ngpio->out &= ~bit;\r\nstatus = gpio->write(gpio->client, gpio->out);\r\nmutex_unlock(&gpio->lock);\r\nreturn status;\r\n}\r\nstatic void pcf857x_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\npcf857x_output(chip, offset, value);\r\n}\r\nstatic irqreturn_t pcf857x_irq(int irq, void *data)\r\n{\r\nstruct pcf857x *gpio = data;\r\nunsigned long change, i, status;\r\nstatus = gpio->read(gpio->client);\r\nmutex_lock(&gpio->lock);\r\nchange = (gpio->status ^ status) & gpio->irq_enabled;\r\ngpio->status = status;\r\nmutex_unlock(&gpio->lock);\r\nfor_each_set_bit(i, &change, gpio->chip.ngpio)\r\nhandle_nested_irq(irq_find_mapping(gpio->chip.irqdomain, i));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void noop(struct irq_data *data) { }\r\nstatic int pcf857x_irq_set_wake(struct irq_data *data, unsigned int on)\r\n{\r\nstruct pcf857x *gpio = irq_data_get_irq_chip_data(data);\r\nint error = 0;\r\nif (gpio->irq_parent) {\r\nerror = irq_set_irq_wake(gpio->irq_parent, on);\r\nif (error) {\r\ndev_dbg(&gpio->client->dev,\r\n"irq %u doesn't support irq_set_wake\n",\r\ngpio->irq_parent);\r\ngpio->irq_parent = 0;\r\n}\r\n}\r\nreturn error;\r\n}\r\nstatic void pcf857x_irq_enable(struct irq_data *data)\r\n{\r\nstruct pcf857x *gpio = irq_data_get_irq_chip_data(data);\r\ngpio->irq_enabled |= (1 << data->hwirq);\r\n}\r\nstatic void pcf857x_irq_disable(struct irq_data *data)\r\n{\r\nstruct pcf857x *gpio = irq_data_get_irq_chip_data(data);\r\ngpio->irq_enabled &= ~(1 << data->hwirq);\r\n}\r\nstatic void pcf857x_irq_bus_lock(struct irq_data *data)\r\n{\r\nstruct pcf857x *gpio = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&gpio->lock);\r\n}\r\nstatic void pcf857x_irq_bus_sync_unlock(struct irq_data *data)\r\n{\r\nstruct pcf857x *gpio = irq_data_get_irq_chip_data(data);\r\nmutex_unlock(&gpio->lock);\r\n}\r\nstatic int pcf857x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pcf857x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct device_node *np = client->dev.of_node;\r\nstruct pcf857x *gpio;\r\nunsigned int n_latch = 0;\r\nint status;\r\nif (IS_ENABLED(CONFIG_OF) && np)\r\nof_property_read_u32(np, "lines-initial-states", &n_latch);\r\nelse if (pdata)\r\nn_latch = pdata->n_latch;\r\nelse\r\ndev_dbg(&client->dev, "no platform data\n");\r\ngpio = devm_kzalloc(&client->dev, sizeof(*gpio), GFP_KERNEL);\r\nif (!gpio)\r\nreturn -ENOMEM;\r\nmutex_init(&gpio->lock);\r\ngpio->chip.base = pdata ? pdata->gpio_base : -1;\r\ngpio->chip.can_sleep = true;\r\ngpio->chip.parent = &client->dev;\r\ngpio->chip.owner = THIS_MODULE;\r\ngpio->chip.get = pcf857x_get;\r\ngpio->chip.set = pcf857x_set;\r\ngpio->chip.direction_input = pcf857x_input;\r\ngpio->chip.direction_output = pcf857x_output;\r\ngpio->chip.ngpio = id->driver_data;\r\nif (gpio->chip.ngpio == 8) {\r\ngpio->write = i2c_write_le8;\r\ngpio->read = i2c_read_le8;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE))\r\nstatus = -EIO;\r\nelse\r\nstatus = i2c_smbus_read_byte(client);\r\n} else if (gpio->chip.ngpio == 16) {\r\ngpio->write = i2c_write_le16;\r\ngpio->read = i2c_read_le16;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nstatus = -EIO;\r\nelse\r\nstatus = i2c_read_le16(client);\r\n} else {\r\ndev_dbg(&client->dev, "unsupported number of gpios\n");\r\nstatus = -EINVAL;\r\n}\r\nif (status < 0)\r\ngoto fail;\r\ngpio->chip.label = client->name;\r\ngpio->client = client;\r\ni2c_set_clientdata(client, gpio);\r\ngpio->out = ~n_latch;\r\ngpio->status = gpio->out;\r\nstatus = devm_gpiochip_add_data(&client->dev, &gpio->chip, gpio);\r\nif (status < 0)\r\ngoto fail;\r\nif (client->irq) {\r\nstatus = gpiochip_irqchip_add_nested(&gpio->chip,\r\n&pcf857x_irq_chip,\r\n0, handle_level_irq,\r\nIRQ_TYPE_NONE);\r\nif (status) {\r\ndev_err(&client->dev, "cannot add irqchip\n");\r\ngoto fail;\r\n}\r\nstatus = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, pcf857x_irq, IRQF_ONESHOT |\r\nIRQF_TRIGGER_FALLING | IRQF_SHARED,\r\ndev_name(&client->dev), gpio);\r\nif (status)\r\ngoto fail;\r\ngpiochip_set_nested_irqchip(&gpio->chip, &pcf857x_irq_chip,\r\nclient->irq);\r\ngpio->irq_parent = client->irq;\r\n}\r\nif (pdata && pdata->setup) {\r\nstatus = pdata->setup(client,\r\ngpio->chip.base, gpio->chip.ngpio,\r\npdata->context);\r\nif (status < 0)\r\ndev_warn(&client->dev, "setup --> %d\n", status);\r\n}\r\ndev_info(&client->dev, "probed\n");\r\nreturn 0;\r\nfail:\r\ndev_dbg(&client->dev, "probe error %d for '%s'\n", status,\r\nclient->name);\r\nreturn status;\r\n}\r\nstatic int pcf857x_remove(struct i2c_client *client)\r\n{\r\nstruct pcf857x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct pcf857x *gpio = i2c_get_clientdata(client);\r\nint status = 0;\r\nif (pdata && pdata->teardown) {\r\nstatus = pdata->teardown(client,\r\ngpio->chip.base, gpio->chip.ngpio,\r\npdata->context);\r\nif (status < 0) {\r\ndev_err(&client->dev, "%s --> %d\n",\r\n"teardown", status);\r\nreturn status;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic void pcf857x_shutdown(struct i2c_client *client)\r\n{\r\nstruct pcf857x *gpio = i2c_get_clientdata(client);\r\ngpio->write(gpio->client, BIT(gpio->chip.ngpio) - 1);\r\n}\r\nstatic int __init pcf857x_init(void)\r\n{\r\nreturn i2c_add_driver(&pcf857x_driver);\r\n}\r\nstatic void __exit pcf857x_exit(void)\r\n{\r\ni2c_del_driver(&pcf857x_driver);\r\n}
