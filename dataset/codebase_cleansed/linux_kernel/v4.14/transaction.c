void btrfs_put_transaction(struct btrfs_transaction *transaction)\r\n{\r\nWARN_ON(refcount_read(&transaction->use_count) == 0);\r\nif (refcount_dec_and_test(&transaction->use_count)) {\r\nBUG_ON(!list_empty(&transaction->list));\r\nWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\r\nif (transaction->delayed_refs.pending_csums)\r\nbtrfs_err(transaction->fs_info,\r\n"pending csums is %llu",\r\ntransaction->delayed_refs.pending_csums);\r\nwhile (!list_empty(&transaction->pending_chunks)) {\r\nstruct extent_map *em;\r\nem = list_first_entry(&transaction->pending_chunks,\r\nstruct extent_map, list);\r\nlist_del_init(&em->list);\r\nfree_extent_map(em);\r\n}\r\nwhile (!list_empty(&transaction->deleted_bgs)) {\r\nstruct btrfs_block_group_cache *cache;\r\ncache = list_first_entry(&transaction->deleted_bgs,\r\nstruct btrfs_block_group_cache,\r\nbg_list);\r\nlist_del_init(&cache->bg_list);\r\nbtrfs_put_block_group_trimming(cache);\r\nbtrfs_put_block_group(cache);\r\n}\r\nkfree(transaction);\r\n}\r\n}\r\nstatic void clear_btree_io_tree(struct extent_io_tree *tree)\r\n{\r\nspin_lock(&tree->lock);\r\nsmp_mb();\r\nwhile (!RB_EMPTY_ROOT(&tree->state)) {\r\nstruct rb_node *node;\r\nstruct extent_state *state;\r\nnode = rb_first(&tree->state);\r\nstate = rb_entry(node, struct extent_state, rb_node);\r\nrb_erase(&state->rb_node, &tree->state);\r\nRB_CLEAR_NODE(&state->rb_node);\r\nASSERT(!waitqueue_active(&state->wq));\r\nfree_extent_state(state);\r\ncond_resched_lock(&tree->lock);\r\n}\r\nspin_unlock(&tree->lock);\r\n}\r\nstatic noinline void switch_commit_roots(struct btrfs_transaction *trans,\r\nstruct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_root *root, *tmp;\r\ndown_write(&fs_info->commit_root_sem);\r\nlist_for_each_entry_safe(root, tmp, &trans->switch_commits,\r\ndirty_list) {\r\nlist_del_init(&root->dirty_list);\r\nfree_extent_buffer(root->commit_root);\r\nroot->commit_root = btrfs_root_node(root);\r\nif (is_fstree(root->objectid))\r\nbtrfs_unpin_free_ino(root);\r\nclear_btree_io_tree(&root->dirty_log_pages);\r\n}\r\nspin_lock(&trans->dropped_roots_lock);\r\nwhile (!list_empty(&trans->dropped_roots)) {\r\nroot = list_first_entry(&trans->dropped_roots,\r\nstruct btrfs_root, root_list);\r\nlist_del_init(&root->root_list);\r\nspin_unlock(&trans->dropped_roots_lock);\r\nbtrfs_drop_and_free_fs_root(fs_info, root);\r\nspin_lock(&trans->dropped_roots_lock);\r\n}\r\nspin_unlock(&trans->dropped_roots_lock);\r\nup_write(&fs_info->commit_root_sem);\r\n}\r\nstatic inline void extwriter_counter_inc(struct btrfs_transaction *trans,\r\nunsigned int type)\r\n{\r\nif (type & TRANS_EXTWRITERS)\r\natomic_inc(&trans->num_extwriters);\r\n}\r\nstatic inline void extwriter_counter_dec(struct btrfs_transaction *trans,\r\nunsigned int type)\r\n{\r\nif (type & TRANS_EXTWRITERS)\r\natomic_dec(&trans->num_extwriters);\r\n}\r\nstatic inline void extwriter_counter_init(struct btrfs_transaction *trans,\r\nunsigned int type)\r\n{\r\natomic_set(&trans->num_extwriters, ((type & TRANS_EXTWRITERS) ? 1 : 0));\r\n}\r\nstatic inline int extwriter_counter_read(struct btrfs_transaction *trans)\r\n{\r\nreturn atomic_read(&trans->num_extwriters);\r\n}\r\nstatic noinline int join_transaction(struct btrfs_fs_info *fs_info,\r\nunsigned int type)\r\n{\r\nstruct btrfs_transaction *cur_trans;\r\nspin_lock(&fs_info->trans_lock);\r\nloop:\r\nif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\r\nspin_unlock(&fs_info->trans_lock);\r\nreturn -EROFS;\r\n}\r\ncur_trans = fs_info->running_transaction;\r\nif (cur_trans) {\r\nif (cur_trans->aborted) {\r\nspin_unlock(&fs_info->trans_lock);\r\nreturn cur_trans->aborted;\r\n}\r\nif (btrfs_blocked_trans_types[cur_trans->state] & type) {\r\nspin_unlock(&fs_info->trans_lock);\r\nreturn -EBUSY;\r\n}\r\nrefcount_inc(&cur_trans->use_count);\r\natomic_inc(&cur_trans->num_writers);\r\nextwriter_counter_inc(cur_trans, type);\r\nspin_unlock(&fs_info->trans_lock);\r\nreturn 0;\r\n}\r\nspin_unlock(&fs_info->trans_lock);\r\nif (type == TRANS_ATTACH)\r\nreturn -ENOENT;\r\nBUG_ON(type == TRANS_JOIN_NOLOCK);\r\ncur_trans = kmalloc(sizeof(*cur_trans), GFP_NOFS);\r\nif (!cur_trans)\r\nreturn -ENOMEM;\r\nspin_lock(&fs_info->trans_lock);\r\nif (fs_info->running_transaction) {\r\nkfree(cur_trans);\r\ngoto loop;\r\n} else if (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\r\nspin_unlock(&fs_info->trans_lock);\r\nkfree(cur_trans);\r\nreturn -EROFS;\r\n}\r\ncur_trans->fs_info = fs_info;\r\natomic_set(&cur_trans->num_writers, 1);\r\nextwriter_counter_init(cur_trans, type);\r\ninit_waitqueue_head(&cur_trans->writer_wait);\r\ninit_waitqueue_head(&cur_trans->commit_wait);\r\ninit_waitqueue_head(&cur_trans->pending_wait);\r\ncur_trans->state = TRANS_STATE_RUNNING;\r\nrefcount_set(&cur_trans->use_count, 2);\r\natomic_set(&cur_trans->pending_ordered, 0);\r\ncur_trans->flags = 0;\r\ncur_trans->start_time = get_seconds();\r\nmemset(&cur_trans->delayed_refs, 0, sizeof(cur_trans->delayed_refs));\r\ncur_trans->delayed_refs.href_root = RB_ROOT;\r\ncur_trans->delayed_refs.dirty_extent_root = RB_ROOT;\r\natomic_set(&cur_trans->delayed_refs.num_entries, 0);\r\nsmp_mb();\r\nif (!list_empty(&fs_info->tree_mod_seq_list))\r\nWARN(1, KERN_ERR "BTRFS: tree_mod_seq_list not empty when creating a fresh transaction\n");\r\nif (!RB_EMPTY_ROOT(&fs_info->tree_mod_log))\r\nWARN(1, KERN_ERR "BTRFS: tree_mod_log rb tree not empty when creating a fresh transaction\n");\r\natomic64_set(&fs_info->tree_mod_seq, 0);\r\nspin_lock_init(&cur_trans->delayed_refs.lock);\r\nINIT_LIST_HEAD(&cur_trans->pending_snapshots);\r\nINIT_LIST_HEAD(&cur_trans->pending_chunks);\r\nINIT_LIST_HEAD(&cur_trans->switch_commits);\r\nINIT_LIST_HEAD(&cur_trans->dirty_bgs);\r\nINIT_LIST_HEAD(&cur_trans->io_bgs);\r\nINIT_LIST_HEAD(&cur_trans->dropped_roots);\r\nmutex_init(&cur_trans->cache_write_mutex);\r\ncur_trans->num_dirty_bgs = 0;\r\nspin_lock_init(&cur_trans->dirty_bgs_lock);\r\nINIT_LIST_HEAD(&cur_trans->deleted_bgs);\r\nspin_lock_init(&cur_trans->dropped_roots_lock);\r\nlist_add_tail(&cur_trans->list, &fs_info->trans_list);\r\nextent_io_tree_init(&cur_trans->dirty_pages,\r\nfs_info->btree_inode);\r\nfs_info->generation++;\r\ncur_trans->transid = fs_info->generation;\r\nfs_info->running_transaction = cur_trans;\r\ncur_trans->aborted = 0;\r\nspin_unlock(&fs_info->trans_lock);\r\nreturn 0;\r\n}\r\nstatic int record_root_in_trans(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nint force)\r\n{\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nif ((test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\r\nroot->last_trans < trans->transid) || force) {\r\nWARN_ON(root == fs_info->extent_root);\r\nWARN_ON(root->commit_root != root->node);\r\nset_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state);\r\nsmp_wmb();\r\nspin_lock(&fs_info->fs_roots_radix_lock);\r\nif (root->last_trans == trans->transid && !force) {\r\nspin_unlock(&fs_info->fs_roots_radix_lock);\r\nreturn 0;\r\n}\r\nradix_tree_tag_set(&fs_info->fs_roots_radix,\r\n(unsigned long)root->root_key.objectid,\r\nBTRFS_ROOT_TRANS_TAG);\r\nspin_unlock(&fs_info->fs_roots_radix_lock);\r\nroot->last_trans = trans->transid;\r\nbtrfs_init_reloc_root(trans, root);\r\nsmp_mb__before_atomic();\r\nclear_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state);\r\n}\r\nreturn 0;\r\n}\r\nvoid btrfs_add_dropped_root(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root)\r\n{\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nstruct btrfs_transaction *cur_trans = trans->transaction;\r\nspin_lock(&cur_trans->dropped_roots_lock);\r\nlist_add_tail(&root->root_list, &cur_trans->dropped_roots);\r\nspin_unlock(&cur_trans->dropped_roots_lock);\r\nspin_lock(&fs_info->fs_roots_radix_lock);\r\nradix_tree_tag_clear(&fs_info->fs_roots_radix,\r\n(unsigned long)root->root_key.objectid,\r\nBTRFS_ROOT_TRANS_TAG);\r\nspin_unlock(&fs_info->fs_roots_radix_lock);\r\n}\r\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root)\r\n{\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\r\nreturn 0;\r\nsmp_rmb();\r\nif (root->last_trans == trans->transid &&\r\n!test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\r\nreturn 0;\r\nmutex_lock(&fs_info->reloc_mutex);\r\nrecord_root_in_trans(trans, root, 0);\r\nmutex_unlock(&fs_info->reloc_mutex);\r\nreturn 0;\r\n}\r\nstatic inline int is_transaction_blocked(struct btrfs_transaction *trans)\r\n{\r\nreturn (trans->state >= TRANS_STATE_BLOCKED &&\r\ntrans->state < TRANS_STATE_UNBLOCKED &&\r\n!trans->aborted);\r\n}\r\nstatic void wait_current_trans(struct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_transaction *cur_trans;\r\nspin_lock(&fs_info->trans_lock);\r\ncur_trans = fs_info->running_transaction;\r\nif (cur_trans && is_transaction_blocked(cur_trans)) {\r\nrefcount_inc(&cur_trans->use_count);\r\nspin_unlock(&fs_info->trans_lock);\r\nwait_event(fs_info->transaction_wait,\r\ncur_trans->state >= TRANS_STATE_UNBLOCKED ||\r\ncur_trans->aborted);\r\nbtrfs_put_transaction(cur_trans);\r\n} else {\r\nspin_unlock(&fs_info->trans_lock);\r\n}\r\n}\r\nstatic int may_wait_transaction(struct btrfs_fs_info *fs_info, int type)\r\n{\r\nif (test_bit(BTRFS_FS_LOG_RECOVERING, &fs_info->flags))\r\nreturn 0;\r\nif (type == TRANS_USERSPACE)\r\nreturn 1;\r\nif (type == TRANS_START &&\r\n!atomic_read(&fs_info->open_ioctl_trans))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline bool need_reserve_reloc_root(struct btrfs_root *root)\r\n{\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nif (!fs_info->reloc_ctl ||\r\n!test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\r\nroot->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\r\nroot->reloc_root)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic struct btrfs_trans_handle *\r\nstart_transaction(struct btrfs_root *root, unsigned int num_items,\r\nunsigned int type, enum btrfs_reserve_flush_enum flush,\r\nbool enforce_qgroups)\r\n{\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nstruct btrfs_trans_handle *h;\r\nstruct btrfs_transaction *cur_trans;\r\nu64 num_bytes = 0;\r\nu64 qgroup_reserved = 0;\r\nbool reloc_reserved = false;\r\nint ret;\r\nASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\r\nif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\r\nreturn ERR_PTR(-EROFS);\r\nif (current->journal_info) {\r\nWARN_ON(type & TRANS_EXTWRITERS);\r\nh = current->journal_info;\r\nh->use_count++;\r\nWARN_ON(h->use_count > 2);\r\nh->orig_rsv = h->block_rsv;\r\nh->block_rsv = NULL;\r\ngoto got_it;\r\n}\r\nif (num_items && root != fs_info->chunk_root) {\r\nqgroup_reserved = num_items * fs_info->nodesize;\r\nret = btrfs_qgroup_reserve_meta(root, qgroup_reserved,\r\nenforce_qgroups);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nnum_bytes = btrfs_calc_trans_metadata_size(fs_info, num_items);\r\nif (need_reserve_reloc_root(root)) {\r\nnum_bytes += fs_info->nodesize;\r\nreloc_reserved = true;\r\n}\r\nret = btrfs_block_rsv_add(root, &fs_info->trans_block_rsv,\r\nnum_bytes, flush);\r\nif (ret)\r\ngoto reserve_fail;\r\n}\r\nagain:\r\nh = kmem_cache_zalloc(btrfs_trans_handle_cachep, GFP_NOFS);\r\nif (!h) {\r\nret = -ENOMEM;\r\ngoto alloc_fail;\r\n}\r\nif (type & __TRANS_FREEZABLE)\r\nsb_start_intwrite(fs_info->sb);\r\nif (may_wait_transaction(fs_info, type))\r\nwait_current_trans(fs_info);\r\ndo {\r\nret = join_transaction(fs_info, type);\r\nif (ret == -EBUSY) {\r\nwait_current_trans(fs_info);\r\nif (unlikely(type == TRANS_ATTACH))\r\nret = -ENOENT;\r\n}\r\n} while (ret == -EBUSY);\r\nif (ret < 0)\r\ngoto join_fail;\r\ncur_trans = fs_info->running_transaction;\r\nh->transid = cur_trans->transid;\r\nh->transaction = cur_trans;\r\nh->root = root;\r\nh->use_count = 1;\r\nh->fs_info = root->fs_info;\r\nh->type = type;\r\nh->can_flush_pending_bgs = true;\r\nINIT_LIST_HEAD(&h->new_bgs);\r\nsmp_mb();\r\nif (cur_trans->state >= TRANS_STATE_BLOCKED &&\r\nmay_wait_transaction(fs_info, type)) {\r\ncurrent->journal_info = h;\r\nbtrfs_commit_transaction(h);\r\ngoto again;\r\n}\r\nif (num_bytes) {\r\ntrace_btrfs_space_reservation(fs_info, "transaction",\r\nh->transid, num_bytes, 1);\r\nh->block_rsv = &fs_info->trans_block_rsv;\r\nh->bytes_reserved = num_bytes;\r\nh->reloc_reserved = reloc_reserved;\r\n}\r\ngot_it:\r\nbtrfs_record_root_in_trans(h, root);\r\nif (!current->journal_info && type != TRANS_USERSPACE)\r\ncurrent->journal_info = h;\r\nreturn h;\r\njoin_fail:\r\nif (type & __TRANS_FREEZABLE)\r\nsb_end_intwrite(fs_info->sb);\r\nkmem_cache_free(btrfs_trans_handle_cachep, h);\r\nalloc_fail:\r\nif (num_bytes)\r\nbtrfs_block_rsv_release(fs_info, &fs_info->trans_block_rsv,\r\nnum_bytes);\r\nreserve_fail:\r\nbtrfs_qgroup_free_meta(root, qgroup_reserved);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct btrfs_trans_handle *btrfs_start_transaction(struct btrfs_root *root,\r\nunsigned int num_items)\r\n{\r\nreturn start_transaction(root, num_items, TRANS_START,\r\nBTRFS_RESERVE_FLUSH_ALL, true);\r\n}\r\nstruct btrfs_trans_handle *btrfs_start_transaction_fallback_global_rsv(\r\nstruct btrfs_root *root,\r\nunsigned int num_items,\r\nint min_factor)\r\n{\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nstruct btrfs_trans_handle *trans;\r\nu64 num_bytes;\r\nint ret;\r\ntrans = start_transaction(root, num_items, TRANS_START,\r\nBTRFS_RESERVE_FLUSH_ALL, false);\r\nif (!IS_ERR(trans) || PTR_ERR(trans) != -ENOSPC)\r\nreturn trans;\r\ntrans = btrfs_start_transaction(root, 0);\r\nif (IS_ERR(trans))\r\nreturn trans;\r\nnum_bytes = btrfs_calc_trans_metadata_size(fs_info, num_items);\r\nret = btrfs_cond_migrate_bytes(fs_info, &fs_info->trans_block_rsv,\r\nnum_bytes, min_factor);\r\nif (ret) {\r\nbtrfs_end_transaction(trans);\r\nreturn ERR_PTR(ret);\r\n}\r\ntrans->block_rsv = &fs_info->trans_block_rsv;\r\ntrans->bytes_reserved = num_bytes;\r\ntrace_btrfs_space_reservation(fs_info, "transaction",\r\ntrans->transid, num_bytes, 1);\r\nreturn trans;\r\n}\r\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\r\nstruct btrfs_root *root,\r\nunsigned int num_items)\r\n{\r\nreturn start_transaction(root, num_items, TRANS_START,\r\nBTRFS_RESERVE_FLUSH_LIMIT, true);\r\n}\r\nstruct btrfs_trans_handle *btrfs_join_transaction(struct btrfs_root *root)\r\n{\r\nreturn start_transaction(root, 0, TRANS_JOIN, BTRFS_RESERVE_NO_FLUSH,\r\ntrue);\r\n}\r\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\r\n{\r\nreturn start_transaction(root, 0, TRANS_JOIN_NOLOCK,\r\nBTRFS_RESERVE_NO_FLUSH, true);\r\n}\r\nstruct btrfs_trans_handle *btrfs_start_ioctl_transaction(struct btrfs_root *root)\r\n{\r\nreturn start_transaction(root, 0, TRANS_USERSPACE,\r\nBTRFS_RESERVE_NO_FLUSH, true);\r\n}\r\nstruct btrfs_trans_handle *btrfs_attach_transaction(struct btrfs_root *root)\r\n{\r\nreturn start_transaction(root, 0, TRANS_ATTACH,\r\nBTRFS_RESERVE_NO_FLUSH, true);\r\n}\r\nstruct btrfs_trans_handle *\r\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\r\n{\r\nstruct btrfs_trans_handle *trans;\r\ntrans = start_transaction(root, 0, TRANS_ATTACH,\r\nBTRFS_RESERVE_NO_FLUSH, true);\r\nif (IS_ERR(trans) && PTR_ERR(trans) == -ENOENT)\r\nbtrfs_wait_for_commit(root->fs_info, 0);\r\nreturn trans;\r\n}\r\nstatic noinline void wait_for_commit(struct btrfs_transaction *commit)\r\n{\r\nwait_event(commit->commit_wait, commit->state == TRANS_STATE_COMPLETED);\r\n}\r\nint btrfs_wait_for_commit(struct btrfs_fs_info *fs_info, u64 transid)\r\n{\r\nstruct btrfs_transaction *cur_trans = NULL, *t;\r\nint ret = 0;\r\nif (transid) {\r\nif (transid <= fs_info->last_trans_committed)\r\ngoto out;\r\nspin_lock(&fs_info->trans_lock);\r\nlist_for_each_entry(t, &fs_info->trans_list, list) {\r\nif (t->transid == transid) {\r\ncur_trans = t;\r\nrefcount_inc(&cur_trans->use_count);\r\nret = 0;\r\nbreak;\r\n}\r\nif (t->transid > transid) {\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&fs_info->trans_lock);\r\nif (!cur_trans) {\r\nif (transid > fs_info->last_trans_committed)\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n} else {\r\nspin_lock(&fs_info->trans_lock);\r\nlist_for_each_entry_reverse(t, &fs_info->trans_list,\r\nlist) {\r\nif (t->state >= TRANS_STATE_COMMIT_START) {\r\nif (t->state == TRANS_STATE_COMPLETED)\r\nbreak;\r\ncur_trans = t;\r\nrefcount_inc(&cur_trans->use_count);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&fs_info->trans_lock);\r\nif (!cur_trans)\r\ngoto out;\r\n}\r\nwait_for_commit(cur_trans);\r\nbtrfs_put_transaction(cur_trans);\r\nout:\r\nreturn ret;\r\n}\r\nvoid btrfs_throttle(struct btrfs_fs_info *fs_info)\r\n{\r\nif (!atomic_read(&fs_info->open_ioctl_trans))\r\nwait_current_trans(fs_info);\r\n}\r\nstatic int should_end_transaction(struct btrfs_trans_handle *trans)\r\n{\r\nstruct btrfs_fs_info *fs_info = trans->fs_info;\r\nif (fs_info->global_block_rsv.space_info->full &&\r\nbtrfs_check_space_for_delayed_refs(trans, fs_info))\r\nreturn 1;\r\nreturn !!btrfs_block_rsv_check(&fs_info->global_block_rsv, 5);\r\n}\r\nint btrfs_should_end_transaction(struct btrfs_trans_handle *trans)\r\n{\r\nstruct btrfs_transaction *cur_trans = trans->transaction;\r\nstruct btrfs_fs_info *fs_info = trans->fs_info;\r\nint updates;\r\nint err;\r\nsmp_mb();\r\nif (cur_trans->state >= TRANS_STATE_BLOCKED ||\r\ncur_trans->delayed_refs.flushing)\r\nreturn 1;\r\nupdates = trans->delayed_ref_updates;\r\ntrans->delayed_ref_updates = 0;\r\nif (updates) {\r\nerr = btrfs_run_delayed_refs(trans, fs_info, updates * 2);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn should_end_transaction(trans);\r\n}\r\nstatic int __btrfs_end_transaction(struct btrfs_trans_handle *trans,\r\nint throttle)\r\n{\r\nstruct btrfs_fs_info *info = trans->fs_info;\r\nstruct btrfs_transaction *cur_trans = trans->transaction;\r\nu64 transid = trans->transid;\r\nunsigned long cur = trans->delayed_ref_updates;\r\nint lock = (trans->type != TRANS_JOIN_NOLOCK);\r\nint err = 0;\r\nint must_run_delayed_refs = 0;\r\nif (trans->use_count > 1) {\r\ntrans->use_count--;\r\ntrans->block_rsv = trans->orig_rsv;\r\nreturn 0;\r\n}\r\nbtrfs_trans_release_metadata(trans, info);\r\ntrans->block_rsv = NULL;\r\nif (!list_empty(&trans->new_bgs))\r\nbtrfs_create_pending_block_groups(trans, info);\r\ntrans->delayed_ref_updates = 0;\r\nif (!trans->sync) {\r\nmust_run_delayed_refs =\r\nbtrfs_should_throttle_delayed_refs(trans, info);\r\ncur = max_t(unsigned long, cur, 32);\r\nif (must_run_delayed_refs == 1 &&\r\n(trans->type & (__TRANS_JOIN_NOLOCK | __TRANS_ATTACH)))\r\nmust_run_delayed_refs = 2;\r\n}\r\nbtrfs_trans_release_metadata(trans, info);\r\ntrans->block_rsv = NULL;\r\nif (!list_empty(&trans->new_bgs))\r\nbtrfs_create_pending_block_groups(trans, info);\r\nbtrfs_trans_release_chunk_metadata(trans);\r\nif (lock && !atomic_read(&info->open_ioctl_trans) &&\r\nshould_end_transaction(trans) &&\r\nREAD_ONCE(cur_trans->state) == TRANS_STATE_RUNNING) {\r\nspin_lock(&info->trans_lock);\r\nif (cur_trans->state == TRANS_STATE_RUNNING)\r\ncur_trans->state = TRANS_STATE_BLOCKED;\r\nspin_unlock(&info->trans_lock);\r\n}\r\nif (lock && READ_ONCE(cur_trans->state) == TRANS_STATE_BLOCKED) {\r\nif (throttle)\r\nreturn btrfs_commit_transaction(trans);\r\nelse\r\nwake_up_process(info->transaction_kthread);\r\n}\r\nif (trans->type & __TRANS_FREEZABLE)\r\nsb_end_intwrite(info->sb);\r\nWARN_ON(cur_trans != info->running_transaction);\r\nWARN_ON(atomic_read(&cur_trans->num_writers) < 1);\r\natomic_dec(&cur_trans->num_writers);\r\nextwriter_counter_dec(cur_trans, trans->type);\r\nsmp_mb();\r\nif (waitqueue_active(&cur_trans->writer_wait))\r\nwake_up(&cur_trans->writer_wait);\r\nbtrfs_put_transaction(cur_trans);\r\nif (current->journal_info == trans)\r\ncurrent->journal_info = NULL;\r\nif (throttle)\r\nbtrfs_run_delayed_iputs(info);\r\nif (trans->aborted ||\r\ntest_bit(BTRFS_FS_STATE_ERROR, &info->fs_state)) {\r\nwake_up_process(info->transaction_kthread);\r\nerr = -EIO;\r\n}\r\nkmem_cache_free(btrfs_trans_handle_cachep, trans);\r\nif (must_run_delayed_refs) {\r\nbtrfs_async_run_delayed_refs(info, cur, transid,\r\nmust_run_delayed_refs == 1);\r\n}\r\nreturn err;\r\n}\r\nint btrfs_end_transaction(struct btrfs_trans_handle *trans)\r\n{\r\nreturn __btrfs_end_transaction(trans, 0);\r\n}\r\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans)\r\n{\r\nreturn __btrfs_end_transaction(trans, 1);\r\n}\r\nint btrfs_write_marked_extents(struct btrfs_fs_info *fs_info,\r\nstruct extent_io_tree *dirty_pages, int mark)\r\n{\r\nint err = 0;\r\nint werr = 0;\r\nstruct address_space *mapping = fs_info->btree_inode->i_mapping;\r\nstruct extent_state *cached_state = NULL;\r\nu64 start = 0;\r\nu64 end;\r\nwhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\r\nmark, &cached_state)) {\r\nbool wait_writeback = false;\r\nerr = convert_extent_bit(dirty_pages, start, end,\r\nEXTENT_NEED_WAIT,\r\nmark, &cached_state);\r\nif (err == -ENOMEM) {\r\nerr = 0;\r\nwait_writeback = true;\r\n}\r\nif (!err)\r\nerr = filemap_fdatawrite_range(mapping, start, end);\r\nif (err)\r\nwerr = err;\r\nelse if (wait_writeback)\r\nwerr = filemap_fdatawait_range(mapping, start, end);\r\nfree_extent_state(cached_state);\r\ncached_state = NULL;\r\ncond_resched();\r\nstart = end + 1;\r\n}\r\nreturn werr;\r\n}\r\nstatic int __btrfs_wait_marked_extents(struct btrfs_fs_info *fs_info,\r\nstruct extent_io_tree *dirty_pages)\r\n{\r\nint err = 0;\r\nint werr = 0;\r\nstruct address_space *mapping = fs_info->btree_inode->i_mapping;\r\nstruct extent_state *cached_state = NULL;\r\nu64 start = 0;\r\nu64 end;\r\nwhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\r\nEXTENT_NEED_WAIT, &cached_state)) {\r\nerr = clear_extent_bit(dirty_pages, start, end,\r\nEXTENT_NEED_WAIT,\r\n0, 0, &cached_state, GFP_NOFS);\r\nif (err == -ENOMEM)\r\nerr = 0;\r\nif (!err)\r\nerr = filemap_fdatawait_range(mapping, start, end);\r\nif (err)\r\nwerr = err;\r\nfree_extent_state(cached_state);\r\ncached_state = NULL;\r\ncond_resched();\r\nstart = end + 1;\r\n}\r\nif (err)\r\nwerr = err;\r\nreturn werr;\r\n}\r\nint btrfs_wait_extents(struct btrfs_fs_info *fs_info,\r\nstruct extent_io_tree *dirty_pages)\r\n{\r\nbool errors = false;\r\nint err;\r\nerr = __btrfs_wait_marked_extents(fs_info, dirty_pages);\r\nif (test_and_clear_bit(BTRFS_FS_BTREE_ERR, &fs_info->flags))\r\nerrors = true;\r\nif (errors && !err)\r\nerr = -EIO;\r\nreturn err;\r\n}\r\nint btrfs_wait_tree_log_extents(struct btrfs_root *log_root, int mark)\r\n{\r\nstruct btrfs_fs_info *fs_info = log_root->fs_info;\r\nstruct extent_io_tree *dirty_pages = &log_root->dirty_log_pages;\r\nbool errors = false;\r\nint err;\r\nASSERT(log_root->root_key.objectid == BTRFS_TREE_LOG_OBJECTID);\r\nerr = __btrfs_wait_marked_extents(fs_info, dirty_pages);\r\nif ((mark & EXTENT_DIRTY) &&\r\ntest_and_clear_bit(BTRFS_FS_LOG1_ERR, &fs_info->flags))\r\nerrors = true;\r\nif ((mark & EXTENT_NEW) &&\r\ntest_and_clear_bit(BTRFS_FS_LOG2_ERR, &fs_info->flags))\r\nerrors = true;\r\nif (errors && !err)\r\nerr = -EIO;\r\nreturn err;\r\n}\r\nstatic int btrfs_write_and_wait_marked_extents(struct btrfs_fs_info *fs_info,\r\nstruct extent_io_tree *dirty_pages, int mark)\r\n{\r\nint ret;\r\nint ret2;\r\nstruct blk_plug plug;\r\nblk_start_plug(&plug);\r\nret = btrfs_write_marked_extents(fs_info, dirty_pages, mark);\r\nblk_finish_plug(&plug);\r\nret2 = btrfs_wait_extents(fs_info, dirty_pages);\r\nif (ret)\r\nreturn ret;\r\nif (ret2)\r\nreturn ret2;\r\nreturn 0;\r\n}\r\nstatic int btrfs_write_and_wait_transaction(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info)\r\n{\r\nint ret;\r\nret = btrfs_write_and_wait_marked_extents(fs_info,\r\n&trans->transaction->dirty_pages,\r\nEXTENT_DIRTY);\r\nclear_btree_io_tree(&trans->transaction->dirty_pages);\r\nreturn ret;\r\n}\r\nstatic int update_cowonly_root(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root)\r\n{\r\nint ret;\r\nu64 old_root_bytenr;\r\nu64 old_root_used;\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nstruct btrfs_root *tree_root = fs_info->tree_root;\r\nold_root_used = btrfs_root_used(&root->root_item);\r\nwhile (1) {\r\nold_root_bytenr = btrfs_root_bytenr(&root->root_item);\r\nif (old_root_bytenr == root->node->start &&\r\nold_root_used == btrfs_root_used(&root->root_item))\r\nbreak;\r\nbtrfs_set_root_node(&root->root_item, root->node);\r\nret = btrfs_update_root(trans, tree_root,\r\n&root->root_key,\r\n&root->root_item);\r\nif (ret)\r\nreturn ret;\r\nold_root_used = btrfs_root_used(&root->root_item);\r\n}\r\nreturn 0;\r\n}\r\nstatic noinline int commit_cowonly_roots(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info)\r\n{\r\nstruct list_head *dirty_bgs = &trans->transaction->dirty_bgs;\r\nstruct list_head *io_bgs = &trans->transaction->io_bgs;\r\nstruct list_head *next;\r\nstruct extent_buffer *eb;\r\nint ret;\r\neb = btrfs_lock_root_node(fs_info->tree_root);\r\nret = btrfs_cow_block(trans, fs_info->tree_root, eb, NULL,\r\n0, &eb);\r\nbtrfs_tree_unlock(eb);\r\nfree_extent_buffer(eb);\r\nif (ret)\r\nreturn ret;\r\nret = btrfs_run_delayed_refs(trans, fs_info, (unsigned long)-1);\r\nif (ret)\r\nreturn ret;\r\nret = btrfs_run_dev_stats(trans, fs_info);\r\nif (ret)\r\nreturn ret;\r\nret = btrfs_run_dev_replace(trans, fs_info);\r\nif (ret)\r\nreturn ret;\r\nret = btrfs_run_qgroups(trans, fs_info);\r\nif (ret)\r\nreturn ret;\r\nret = btrfs_setup_space_cache(trans, fs_info);\r\nif (ret)\r\nreturn ret;\r\nret = btrfs_run_delayed_refs(trans, fs_info, (unsigned long)-1);\r\nif (ret)\r\nreturn ret;\r\nagain:\r\nwhile (!list_empty(&fs_info->dirty_cowonly_roots)) {\r\nstruct btrfs_root *root;\r\nnext = fs_info->dirty_cowonly_roots.next;\r\nlist_del_init(next);\r\nroot = list_entry(next, struct btrfs_root, dirty_list);\r\nclear_bit(BTRFS_ROOT_DIRTY, &root->state);\r\nif (root != fs_info->extent_root)\r\nlist_add_tail(&root->dirty_list,\r\n&trans->transaction->switch_commits);\r\nret = update_cowonly_root(trans, root);\r\nif (ret)\r\nreturn ret;\r\nret = btrfs_run_delayed_refs(trans, fs_info, (unsigned long)-1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nwhile (!list_empty(dirty_bgs) || !list_empty(io_bgs)) {\r\nret = btrfs_write_dirty_block_groups(trans, fs_info);\r\nif (ret)\r\nreturn ret;\r\nret = btrfs_run_delayed_refs(trans, fs_info, (unsigned long)-1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!list_empty(&fs_info->dirty_cowonly_roots))\r\ngoto again;\r\nlist_add_tail(&fs_info->extent_root->dirty_list,\r\n&trans->transaction->switch_commits);\r\nbtrfs_after_dev_replace_commit(fs_info);\r\nreturn 0;\r\n}\r\nvoid btrfs_add_dead_root(struct btrfs_root *root)\r\n{\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nspin_lock(&fs_info->trans_lock);\r\nif (list_empty(&root->root_list))\r\nlist_add_tail(&root->root_list, &fs_info->dead_roots);\r\nspin_unlock(&fs_info->trans_lock);\r\n}\r\nstatic noinline int commit_fs_roots(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_root *gang[8];\r\nint i;\r\nint ret;\r\nint err = 0;\r\nspin_lock(&fs_info->fs_roots_radix_lock);\r\nwhile (1) {\r\nret = radix_tree_gang_lookup_tag(&fs_info->fs_roots_radix,\r\n(void **)gang, 0,\r\nARRAY_SIZE(gang),\r\nBTRFS_ROOT_TRANS_TAG);\r\nif (ret == 0)\r\nbreak;\r\nfor (i = 0; i < ret; i++) {\r\nstruct btrfs_root *root = gang[i];\r\nradix_tree_tag_clear(&fs_info->fs_roots_radix,\r\n(unsigned long)root->root_key.objectid,\r\nBTRFS_ROOT_TRANS_TAG);\r\nspin_unlock(&fs_info->fs_roots_radix_lock);\r\nbtrfs_free_log(trans, root);\r\nbtrfs_update_reloc_root(trans, root);\r\nbtrfs_orphan_commit_root(trans, root);\r\nbtrfs_save_ino_cache(root, trans);\r\nclear_bit(BTRFS_ROOT_FORCE_COW, &root->state);\r\nsmp_mb__after_atomic();\r\nif (root->commit_root != root->node) {\r\nlist_add_tail(&root->dirty_list,\r\n&trans->transaction->switch_commits);\r\nbtrfs_set_root_node(&root->root_item,\r\nroot->node);\r\n}\r\nerr = btrfs_update_root(trans, fs_info->tree_root,\r\n&root->root_key,\r\n&root->root_item);\r\nspin_lock(&fs_info->fs_roots_radix_lock);\r\nif (err)\r\nbreak;\r\nbtrfs_qgroup_free_meta_all(root);\r\n}\r\n}\r\nspin_unlock(&fs_info->fs_roots_radix_lock);\r\nreturn err;\r\n}\r\nint btrfs_defrag_root(struct btrfs_root *root)\r\n{\r\nstruct btrfs_fs_info *info = root->fs_info;\r\nstruct btrfs_trans_handle *trans;\r\nint ret;\r\nif (test_and_set_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state))\r\nreturn 0;\r\nwhile (1) {\r\ntrans = btrfs_start_transaction(root, 0);\r\nif (IS_ERR(trans))\r\nreturn PTR_ERR(trans);\r\nret = btrfs_defrag_leaves(trans, root);\r\nbtrfs_end_transaction(trans);\r\nbtrfs_btree_balance_dirty(info);\r\ncond_resched();\r\nif (btrfs_fs_closing(info) || ret != -EAGAIN)\r\nbreak;\r\nif (btrfs_defrag_cancelled(info)) {\r\nbtrfs_debug(info, "defrag_root cancelled");\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\n}\r\nclear_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state);\r\nreturn ret;\r\n}\r\nstatic int qgroup_account_snapshot(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *src,\r\nstruct btrfs_root *parent,\r\nstruct btrfs_qgroup_inherit *inherit,\r\nu64 dst_objectid)\r\n{\r\nstruct btrfs_fs_info *fs_info = src->fs_info;\r\nint ret;\r\nif (!test_bit(BTRFS_FS_QUOTA_ENABLED, &fs_info->flags))\r\nreturn 0;\r\nmutex_lock(&fs_info->tree_log_mutex);\r\nret = commit_fs_roots(trans, fs_info);\r\nif (ret)\r\ngoto out;\r\nret = btrfs_qgroup_account_extents(trans, fs_info);\r\nif (ret < 0)\r\ngoto out;\r\nret = btrfs_qgroup_inherit(trans, fs_info,\r\nsrc->root_key.objectid, dst_objectid,\r\ninherit);\r\nif (ret < 0)\r\ngoto out;\r\nret = commit_cowonly_roots(trans, fs_info);\r\nif (ret)\r\ngoto out;\r\nswitch_commit_roots(trans->transaction, fs_info);\r\nret = btrfs_write_and_wait_transaction(trans, fs_info);\r\nif (ret)\r\nbtrfs_handle_fs_error(fs_info, ret,\r\n"Error while writing out transaction for qgroup");\r\nout:\r\nmutex_unlock(&fs_info->tree_log_mutex);\r\nif (!ret)\r\nrecord_root_in_trans(trans, parent, 1);\r\nreturn ret;\r\n}\r\nstatic noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_pending_snapshot *pending)\r\n{\r\nstruct btrfs_key key;\r\nstruct btrfs_root_item *new_root_item;\r\nstruct btrfs_root *tree_root = fs_info->tree_root;\r\nstruct btrfs_root *root = pending->root;\r\nstruct btrfs_root *parent_root;\r\nstruct btrfs_block_rsv *rsv;\r\nstruct inode *parent_inode;\r\nstruct btrfs_path *path;\r\nstruct btrfs_dir_item *dir_item;\r\nstruct dentry *dentry;\r\nstruct extent_buffer *tmp;\r\nstruct extent_buffer *old;\r\nstruct timespec cur_time;\r\nint ret = 0;\r\nu64 to_reserve = 0;\r\nu64 index = 0;\r\nu64 objectid;\r\nu64 root_flags;\r\nuuid_le new_uuid;\r\nASSERT(pending->path);\r\npath = pending->path;\r\nASSERT(pending->root_item);\r\nnew_root_item = pending->root_item;\r\npending->error = btrfs_find_free_objectid(tree_root, &objectid);\r\nif (pending->error)\r\ngoto no_free_objectid;\r\nbtrfs_set_skip_qgroup(trans, objectid);\r\nbtrfs_reloc_pre_snapshot(pending, &to_reserve);\r\nif (to_reserve > 0) {\r\npending->error = btrfs_block_rsv_add(root,\r\n&pending->block_rsv,\r\nto_reserve,\r\nBTRFS_RESERVE_NO_FLUSH);\r\nif (pending->error)\r\ngoto clear_skip_qgroup;\r\n}\r\nkey.objectid = objectid;\r\nkey.offset = (u64)-1;\r\nkey.type = BTRFS_ROOT_ITEM_KEY;\r\nrsv = trans->block_rsv;\r\ntrans->block_rsv = &pending->block_rsv;\r\ntrans->bytes_reserved = trans->block_rsv->reserved;\r\ntrace_btrfs_space_reservation(fs_info, "transaction",\r\ntrans->transid,\r\ntrans->bytes_reserved, 1);\r\ndentry = pending->dentry;\r\nparent_inode = pending->dir;\r\nparent_root = BTRFS_I(parent_inode)->root;\r\nrecord_root_in_trans(trans, parent_root, 0);\r\ncur_time = current_time(parent_inode);\r\nret = btrfs_set_inode_index(BTRFS_I(parent_inode), &index);\r\nBUG_ON(ret);\r\ndir_item = btrfs_lookup_dir_item(NULL, parent_root, path,\r\nbtrfs_ino(BTRFS_I(parent_inode)),\r\ndentry->d_name.name,\r\ndentry->d_name.len, 0);\r\nif (dir_item != NULL && !IS_ERR(dir_item)) {\r\npending->error = -EEXIST;\r\ngoto dir_item_existed;\r\n} else if (IS_ERR(dir_item)) {\r\nret = PTR_ERR(dir_item);\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto fail;\r\n}\r\nbtrfs_release_path(path);\r\nret = btrfs_run_delayed_items(trans, fs_info);\r\nif (ret) {\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto fail;\r\n}\r\nrecord_root_in_trans(trans, root, 0);\r\nbtrfs_set_root_last_snapshot(&root->root_item, trans->transid);\r\nmemcpy(new_root_item, &root->root_item, sizeof(*new_root_item));\r\nbtrfs_check_and_init_root_item(new_root_item);\r\nroot_flags = btrfs_root_flags(new_root_item);\r\nif (pending->readonly)\r\nroot_flags |= BTRFS_ROOT_SUBVOL_RDONLY;\r\nelse\r\nroot_flags &= ~BTRFS_ROOT_SUBVOL_RDONLY;\r\nbtrfs_set_root_flags(new_root_item, root_flags);\r\nbtrfs_set_root_generation_v2(new_root_item,\r\ntrans->transid);\r\nuuid_le_gen(&new_uuid);\r\nmemcpy(new_root_item->uuid, new_uuid.b, BTRFS_UUID_SIZE);\r\nmemcpy(new_root_item->parent_uuid, root->root_item.uuid,\r\nBTRFS_UUID_SIZE);\r\nif (!(root_flags & BTRFS_ROOT_SUBVOL_RDONLY)) {\r\nmemset(new_root_item->received_uuid, 0,\r\nsizeof(new_root_item->received_uuid));\r\nmemset(&new_root_item->stime, 0, sizeof(new_root_item->stime));\r\nmemset(&new_root_item->rtime, 0, sizeof(new_root_item->rtime));\r\nbtrfs_set_root_stransid(new_root_item, 0);\r\nbtrfs_set_root_rtransid(new_root_item, 0);\r\n}\r\nbtrfs_set_stack_timespec_sec(&new_root_item->otime, cur_time.tv_sec);\r\nbtrfs_set_stack_timespec_nsec(&new_root_item->otime, cur_time.tv_nsec);\r\nbtrfs_set_root_otransid(new_root_item, trans->transid);\r\nold = btrfs_lock_root_node(root);\r\nret = btrfs_cow_block(trans, root, old, NULL, 0, &old);\r\nif (ret) {\r\nbtrfs_tree_unlock(old);\r\nfree_extent_buffer(old);\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto fail;\r\n}\r\nbtrfs_set_lock_blocking(old);\r\nret = btrfs_copy_root(trans, root, old, &tmp, objectid);\r\nbtrfs_tree_unlock(old);\r\nfree_extent_buffer(old);\r\nif (ret) {\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto fail;\r\n}\r\nset_bit(BTRFS_ROOT_FORCE_COW, &root->state);\r\nsmp_wmb();\r\nbtrfs_set_root_node(new_root_item, tmp);\r\nkey.offset = trans->transid;\r\nret = btrfs_insert_root(trans, tree_root, &key, new_root_item);\r\nbtrfs_tree_unlock(tmp);\r\nfree_extent_buffer(tmp);\r\nif (ret) {\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto fail;\r\n}\r\nret = btrfs_add_root_ref(trans, fs_info, objectid,\r\nparent_root->root_key.objectid,\r\nbtrfs_ino(BTRFS_I(parent_inode)), index,\r\ndentry->d_name.name, dentry->d_name.len);\r\nif (ret) {\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto fail;\r\n}\r\nkey.offset = (u64)-1;\r\npending->snap = btrfs_read_fs_root_no_name(fs_info, &key);\r\nif (IS_ERR(pending->snap)) {\r\nret = PTR_ERR(pending->snap);\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto fail;\r\n}\r\nret = btrfs_reloc_post_snapshot(trans, pending);\r\nif (ret) {\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto fail;\r\n}\r\nret = btrfs_run_delayed_refs(trans, fs_info, (unsigned long)-1);\r\nif (ret) {\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto fail;\r\n}\r\nret = qgroup_account_snapshot(trans, root, parent_root,\r\npending->inherit, objectid);\r\nif (ret < 0)\r\ngoto fail;\r\nret = btrfs_insert_dir_item(trans, parent_root,\r\ndentry->d_name.name, dentry->d_name.len,\r\nBTRFS_I(parent_inode), &key,\r\nBTRFS_FT_DIR, index);\r\nBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);\r\nif (ret) {\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto fail;\r\n}\r\nbtrfs_i_size_write(BTRFS_I(parent_inode), parent_inode->i_size +\r\ndentry->d_name.len * 2);\r\nparent_inode->i_mtime = parent_inode->i_ctime =\r\ncurrent_time(parent_inode);\r\nret = btrfs_update_inode_fallback(trans, parent_root, parent_inode);\r\nif (ret) {\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto fail;\r\n}\r\nret = btrfs_uuid_tree_add(trans, fs_info, new_uuid.b,\r\nBTRFS_UUID_KEY_SUBVOL, objectid);\r\nif (ret) {\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto fail;\r\n}\r\nif (!btrfs_is_empty_uuid(new_root_item->received_uuid)) {\r\nret = btrfs_uuid_tree_add(trans, fs_info,\r\nnew_root_item->received_uuid,\r\nBTRFS_UUID_KEY_RECEIVED_SUBVOL,\r\nobjectid);\r\nif (ret && ret != -EEXIST) {\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto fail;\r\n}\r\n}\r\nret = btrfs_run_delayed_refs(trans, fs_info, (unsigned long)-1);\r\nif (ret) {\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto fail;\r\n}\r\nfail:\r\npending->error = ret;\r\ndir_item_existed:\r\ntrans->block_rsv = rsv;\r\ntrans->bytes_reserved = 0;\r\nclear_skip_qgroup:\r\nbtrfs_clear_skip_qgroup(trans);\r\nno_free_objectid:\r\nkfree(new_root_item);\r\npending->root_item = NULL;\r\nbtrfs_free_path(path);\r\npending->path = NULL;\r\nreturn ret;\r\n}\r\nstatic noinline int create_pending_snapshots(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_pending_snapshot *pending, *next;\r\nstruct list_head *head = &trans->transaction->pending_snapshots;\r\nint ret = 0;\r\nlist_for_each_entry_safe(pending, next, head, list) {\r\nlist_del(&pending->list);\r\nret = create_pending_snapshot(trans, fs_info, pending);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void update_super_roots(struct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_root_item *root_item;\r\nstruct btrfs_super_block *super;\r\nsuper = fs_info->super_copy;\r\nroot_item = &fs_info->chunk_root->root_item;\r\nsuper->chunk_root = root_item->bytenr;\r\nsuper->chunk_root_generation = root_item->generation;\r\nsuper->chunk_root_level = root_item->level;\r\nroot_item = &fs_info->tree_root->root_item;\r\nsuper->root = root_item->bytenr;\r\nsuper->generation = root_item->generation;\r\nsuper->root_level = root_item->level;\r\nif (btrfs_test_opt(fs_info, SPACE_CACHE))\r\nsuper->cache_generation = root_item->generation;\r\nif (test_bit(BTRFS_FS_UPDATE_UUID_TREE_GEN, &fs_info->flags))\r\nsuper->uuid_tree_generation = root_item->generation;\r\n}\r\nint btrfs_transaction_in_commit(struct btrfs_fs_info *info)\r\n{\r\nstruct btrfs_transaction *trans;\r\nint ret = 0;\r\nspin_lock(&info->trans_lock);\r\ntrans = info->running_transaction;\r\nif (trans)\r\nret = (trans->state >= TRANS_STATE_COMMIT_START);\r\nspin_unlock(&info->trans_lock);\r\nreturn ret;\r\n}\r\nint btrfs_transaction_blocked(struct btrfs_fs_info *info)\r\n{\r\nstruct btrfs_transaction *trans;\r\nint ret = 0;\r\nspin_lock(&info->trans_lock);\r\ntrans = info->running_transaction;\r\nif (trans)\r\nret = is_transaction_blocked(trans);\r\nspin_unlock(&info->trans_lock);\r\nreturn ret;\r\n}\r\nstatic void wait_current_trans_commit_start(struct btrfs_fs_info *fs_info,\r\nstruct btrfs_transaction *trans)\r\n{\r\nwait_event(fs_info->transaction_blocked_wait,\r\ntrans->state >= TRANS_STATE_COMMIT_START || trans->aborted);\r\n}\r\nstatic void wait_current_trans_commit_start_and_unblock(\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_transaction *trans)\r\n{\r\nwait_event(fs_info->transaction_wait,\r\ntrans->state >= TRANS_STATE_UNBLOCKED || trans->aborted);\r\n}\r\nstatic void do_async_commit(struct work_struct *work)\r\n{\r\nstruct btrfs_async_commit *ac =\r\ncontainer_of(work, struct btrfs_async_commit, work);\r\nif (ac->newtrans->type & __TRANS_FREEZABLE)\r\n__sb_writers_acquired(ac->newtrans->fs_info->sb, SB_FREEZE_FS);\r\ncurrent->journal_info = ac->newtrans;\r\nbtrfs_commit_transaction(ac->newtrans);\r\nkfree(ac);\r\n}\r\nint btrfs_commit_transaction_async(struct btrfs_trans_handle *trans,\r\nint wait_for_unblock)\r\n{\r\nstruct btrfs_fs_info *fs_info = trans->fs_info;\r\nstruct btrfs_async_commit *ac;\r\nstruct btrfs_transaction *cur_trans;\r\nac = kmalloc(sizeof(*ac), GFP_NOFS);\r\nif (!ac)\r\nreturn -ENOMEM;\r\nINIT_WORK(&ac->work, do_async_commit);\r\nac->newtrans = btrfs_join_transaction(trans->root);\r\nif (IS_ERR(ac->newtrans)) {\r\nint err = PTR_ERR(ac->newtrans);\r\nkfree(ac);\r\nreturn err;\r\n}\r\ncur_trans = trans->transaction;\r\nrefcount_inc(&cur_trans->use_count);\r\nbtrfs_end_transaction(trans);\r\nif (ac->newtrans->type & __TRANS_FREEZABLE)\r\n__sb_writers_release(fs_info->sb, SB_FREEZE_FS);\r\nschedule_work(&ac->work);\r\nif (wait_for_unblock)\r\nwait_current_trans_commit_start_and_unblock(fs_info, cur_trans);\r\nelse\r\nwait_current_trans_commit_start(fs_info, cur_trans);\r\nif (current->journal_info == trans)\r\ncurrent->journal_info = NULL;\r\nbtrfs_put_transaction(cur_trans);\r\nreturn 0;\r\n}\r\nstatic void cleanup_transaction(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root, int err)\r\n{\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nstruct btrfs_transaction *cur_trans = trans->transaction;\r\nDEFINE_WAIT(wait);\r\nWARN_ON(trans->use_count > 1);\r\nbtrfs_abort_transaction(trans, err);\r\nspin_lock(&fs_info->trans_lock);\r\nBUG_ON(list_empty(&cur_trans->list));\r\nlist_del_init(&cur_trans->list);\r\nif (cur_trans == fs_info->running_transaction) {\r\ncur_trans->state = TRANS_STATE_COMMIT_DOING;\r\nspin_unlock(&fs_info->trans_lock);\r\nwait_event(cur_trans->writer_wait,\r\natomic_read(&cur_trans->num_writers) == 1);\r\nspin_lock(&fs_info->trans_lock);\r\n}\r\nspin_unlock(&fs_info->trans_lock);\r\nbtrfs_cleanup_one_transaction(trans->transaction, fs_info);\r\nspin_lock(&fs_info->trans_lock);\r\nif (cur_trans == fs_info->running_transaction)\r\nfs_info->running_transaction = NULL;\r\nspin_unlock(&fs_info->trans_lock);\r\nif (trans->type & __TRANS_FREEZABLE)\r\nsb_end_intwrite(fs_info->sb);\r\nbtrfs_put_transaction(cur_trans);\r\nbtrfs_put_transaction(cur_trans);\r\ntrace_btrfs_transaction_commit(root);\r\nif (current->journal_info == trans)\r\ncurrent->journal_info = NULL;\r\nbtrfs_scrub_cancel(fs_info);\r\nkmem_cache_free(btrfs_trans_handle_cachep, trans);\r\n}\r\nstatic inline int btrfs_start_delalloc_flush(struct btrfs_fs_info *fs_info)\r\n{\r\nif (btrfs_test_opt(fs_info, FLUSHONCOMMIT))\r\nreturn btrfs_start_delalloc_roots(fs_info, 1, -1);\r\nreturn 0;\r\n}\r\nstatic inline void btrfs_wait_delalloc_flush(struct btrfs_fs_info *fs_info)\r\n{\r\nif (btrfs_test_opt(fs_info, FLUSHONCOMMIT))\r\nbtrfs_wait_ordered_roots(fs_info, U64_MAX, 0, (u64)-1);\r\n}\r\nstatic inline void\r\nbtrfs_wait_pending_ordered(struct btrfs_transaction *cur_trans)\r\n{\r\nwait_event(cur_trans->pending_wait,\r\natomic_read(&cur_trans->pending_ordered) == 0);\r\n}\r\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans)\r\n{\r\nstruct btrfs_fs_info *fs_info = trans->fs_info;\r\nstruct btrfs_transaction *cur_trans = trans->transaction;\r\nstruct btrfs_transaction *prev_trans = NULL;\r\nint ret;\r\nif (unlikely(READ_ONCE(cur_trans->aborted))) {\r\nret = cur_trans->aborted;\r\nbtrfs_end_transaction(trans);\r\nreturn ret;\r\n}\r\nret = btrfs_run_delayed_refs(trans, fs_info, 0);\r\nif (ret) {\r\nbtrfs_end_transaction(trans);\r\nreturn ret;\r\n}\r\nbtrfs_trans_release_metadata(trans, fs_info);\r\ntrans->block_rsv = NULL;\r\ncur_trans = trans->transaction;\r\ncur_trans->delayed_refs.flushing = 1;\r\nsmp_wmb();\r\nif (!list_empty(&trans->new_bgs))\r\nbtrfs_create_pending_block_groups(trans, fs_info);\r\nret = btrfs_run_delayed_refs(trans, fs_info, 0);\r\nif (ret) {\r\nbtrfs_end_transaction(trans);\r\nreturn ret;\r\n}\r\nif (!test_bit(BTRFS_TRANS_DIRTY_BG_RUN, &cur_trans->flags)) {\r\nint run_it = 0;\r\nmutex_lock(&fs_info->ro_block_group_mutex);\r\nif (!test_and_set_bit(BTRFS_TRANS_DIRTY_BG_RUN,\r\n&cur_trans->flags))\r\nrun_it = 1;\r\nmutex_unlock(&fs_info->ro_block_group_mutex);\r\nif (run_it)\r\nret = btrfs_start_dirty_block_groups(trans, fs_info);\r\n}\r\nif (ret) {\r\nbtrfs_end_transaction(trans);\r\nreturn ret;\r\n}\r\nspin_lock(&fs_info->trans_lock);\r\nif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\r\nspin_unlock(&fs_info->trans_lock);\r\nrefcount_inc(&cur_trans->use_count);\r\nret = btrfs_end_transaction(trans);\r\nwait_for_commit(cur_trans);\r\nif (unlikely(cur_trans->aborted))\r\nret = cur_trans->aborted;\r\nbtrfs_put_transaction(cur_trans);\r\nreturn ret;\r\n}\r\ncur_trans->state = TRANS_STATE_COMMIT_START;\r\nwake_up(&fs_info->transaction_blocked_wait);\r\nif (cur_trans->list.prev != &fs_info->trans_list) {\r\nprev_trans = list_entry(cur_trans->list.prev,\r\nstruct btrfs_transaction, list);\r\nif (prev_trans->state != TRANS_STATE_COMPLETED) {\r\nrefcount_inc(&prev_trans->use_count);\r\nspin_unlock(&fs_info->trans_lock);\r\nwait_for_commit(prev_trans);\r\nret = prev_trans->aborted;\r\nbtrfs_put_transaction(prev_trans);\r\nif (ret)\r\ngoto cleanup_transaction;\r\n} else {\r\nspin_unlock(&fs_info->trans_lock);\r\n}\r\n} else {\r\nspin_unlock(&fs_info->trans_lock);\r\n}\r\nextwriter_counter_dec(cur_trans, trans->type);\r\nret = btrfs_start_delalloc_flush(fs_info);\r\nif (ret)\r\ngoto cleanup_transaction;\r\nret = btrfs_run_delayed_items(trans, fs_info);\r\nif (ret)\r\ngoto cleanup_transaction;\r\nwait_event(cur_trans->writer_wait,\r\nextwriter_counter_read(cur_trans) == 0);\r\nret = btrfs_run_delayed_items(trans, fs_info);\r\nif (ret)\r\ngoto cleanup_transaction;\r\nbtrfs_wait_delalloc_flush(fs_info);\r\nbtrfs_wait_pending_ordered(cur_trans);\r\nbtrfs_scrub_pause(fs_info);\r\nspin_lock(&fs_info->trans_lock);\r\ncur_trans->state = TRANS_STATE_COMMIT_DOING;\r\nspin_unlock(&fs_info->trans_lock);\r\nwait_event(cur_trans->writer_wait,\r\natomic_read(&cur_trans->num_writers) == 1);\r\nif (unlikely(READ_ONCE(cur_trans->aborted))) {\r\nret = cur_trans->aborted;\r\ngoto scrub_continue;\r\n}\r\nmutex_lock(&fs_info->reloc_mutex);\r\nret = create_pending_snapshots(trans, fs_info);\r\nif (ret) {\r\nmutex_unlock(&fs_info->reloc_mutex);\r\ngoto scrub_continue;\r\n}\r\nret = btrfs_run_delayed_items(trans, fs_info);\r\nif (ret) {\r\nmutex_unlock(&fs_info->reloc_mutex);\r\ngoto scrub_continue;\r\n}\r\nret = btrfs_run_delayed_refs(trans, fs_info, (unsigned long)-1);\r\nif (ret) {\r\nmutex_unlock(&fs_info->reloc_mutex);\r\ngoto scrub_continue;\r\n}\r\nbtrfs_assert_delayed_root_empty(fs_info);\r\nWARN_ON(cur_trans != trans->transaction);\r\nmutex_lock(&fs_info->tree_log_mutex);\r\nret = commit_fs_roots(trans, fs_info);\r\nif (ret) {\r\nmutex_unlock(&fs_info->tree_log_mutex);\r\nmutex_unlock(&fs_info->reloc_mutex);\r\ngoto scrub_continue;\r\n}\r\nbtrfs_apply_pending_changes(fs_info);\r\nbtrfs_free_log_root_tree(trans, fs_info);\r\nret = btrfs_run_delayed_refs(trans, fs_info, (unsigned long)-1);\r\nif (ret) {\r\nmutex_unlock(&fs_info->tree_log_mutex);\r\nmutex_unlock(&fs_info->reloc_mutex);\r\ngoto scrub_continue;\r\n}\r\nret = btrfs_qgroup_account_extents(trans, fs_info);\r\nif (ret < 0) {\r\nmutex_unlock(&fs_info->tree_log_mutex);\r\nmutex_unlock(&fs_info->reloc_mutex);\r\ngoto scrub_continue;\r\n}\r\nret = commit_cowonly_roots(trans, fs_info);\r\nif (ret) {\r\nmutex_unlock(&fs_info->tree_log_mutex);\r\nmutex_unlock(&fs_info->reloc_mutex);\r\ngoto scrub_continue;\r\n}\r\nif (unlikely(READ_ONCE(cur_trans->aborted))) {\r\nret = cur_trans->aborted;\r\nmutex_unlock(&fs_info->tree_log_mutex);\r\nmutex_unlock(&fs_info->reloc_mutex);\r\ngoto scrub_continue;\r\n}\r\nbtrfs_prepare_extent_commit(fs_info);\r\ncur_trans = fs_info->running_transaction;\r\nbtrfs_set_root_node(&fs_info->tree_root->root_item,\r\nfs_info->tree_root->node);\r\nlist_add_tail(&fs_info->tree_root->dirty_list,\r\n&cur_trans->switch_commits);\r\nbtrfs_set_root_node(&fs_info->chunk_root->root_item,\r\nfs_info->chunk_root->node);\r\nlist_add_tail(&fs_info->chunk_root->dirty_list,\r\n&cur_trans->switch_commits);\r\nswitch_commit_roots(cur_trans, fs_info);\r\nASSERT(list_empty(&cur_trans->dirty_bgs));\r\nASSERT(list_empty(&cur_trans->io_bgs));\r\nupdate_super_roots(fs_info);\r\nbtrfs_set_super_log_root(fs_info->super_copy, 0);\r\nbtrfs_set_super_log_root_level(fs_info->super_copy, 0);\r\nmemcpy(fs_info->super_for_commit, fs_info->super_copy,\r\nsizeof(*fs_info->super_copy));\r\nbtrfs_update_commit_device_size(fs_info);\r\nbtrfs_update_commit_device_bytes_used(fs_info, cur_trans);\r\nclear_bit(BTRFS_FS_LOG1_ERR, &fs_info->flags);\r\nclear_bit(BTRFS_FS_LOG2_ERR, &fs_info->flags);\r\nbtrfs_trans_release_chunk_metadata(trans);\r\nspin_lock(&fs_info->trans_lock);\r\ncur_trans->state = TRANS_STATE_UNBLOCKED;\r\nfs_info->running_transaction = NULL;\r\nspin_unlock(&fs_info->trans_lock);\r\nmutex_unlock(&fs_info->reloc_mutex);\r\nwake_up(&fs_info->transaction_wait);\r\nret = btrfs_write_and_wait_transaction(trans, fs_info);\r\nif (ret) {\r\nbtrfs_handle_fs_error(fs_info, ret,\r\n"Error while writing out transaction");\r\nmutex_unlock(&fs_info->tree_log_mutex);\r\ngoto scrub_continue;\r\n}\r\nret = write_all_supers(fs_info, 0);\r\nif (ret) {\r\nmutex_unlock(&fs_info->tree_log_mutex);\r\ngoto scrub_continue;\r\n}\r\nmutex_unlock(&fs_info->tree_log_mutex);\r\nbtrfs_finish_extent_commit(trans, fs_info);\r\nif (test_bit(BTRFS_TRANS_HAVE_FREE_BGS, &cur_trans->flags))\r\nbtrfs_clear_space_info_full(fs_info);\r\nfs_info->last_trans_committed = cur_trans->transid;\r\ncur_trans->state = TRANS_STATE_COMPLETED;\r\nwake_up(&cur_trans->commit_wait);\r\nspin_lock(&fs_info->trans_lock);\r\nlist_del_init(&cur_trans->list);\r\nspin_unlock(&fs_info->trans_lock);\r\nbtrfs_put_transaction(cur_trans);\r\nbtrfs_put_transaction(cur_trans);\r\nif (trans->type & __TRANS_FREEZABLE)\r\nsb_end_intwrite(fs_info->sb);\r\ntrace_btrfs_transaction_commit(trans->root);\r\nbtrfs_scrub_continue(fs_info);\r\nif (current->journal_info == trans)\r\ncurrent->journal_info = NULL;\r\nkmem_cache_free(btrfs_trans_handle_cachep, trans);\r\nif (current != fs_info->transaction_kthread &&\r\ncurrent != fs_info->cleaner_kthread &&\r\n!test_bit(BTRFS_FS_FROZEN, &fs_info->flags))\r\nbtrfs_run_delayed_iputs(fs_info);\r\nreturn ret;\r\nscrub_continue:\r\nbtrfs_scrub_continue(fs_info);\r\ncleanup_transaction:\r\nbtrfs_trans_release_metadata(trans, fs_info);\r\nbtrfs_trans_release_chunk_metadata(trans);\r\ntrans->block_rsv = NULL;\r\nbtrfs_warn(fs_info, "Skipping commit of aborted transaction.");\r\nif (current->journal_info == trans)\r\ncurrent->journal_info = NULL;\r\ncleanup_transaction(trans, trans->root, ret);\r\nreturn ret;\r\n}\r\nint btrfs_clean_one_deleted_snapshot(struct btrfs_root *root)\r\n{\r\nint ret;\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nspin_lock(&fs_info->trans_lock);\r\nif (list_empty(&fs_info->dead_roots)) {\r\nspin_unlock(&fs_info->trans_lock);\r\nreturn 0;\r\n}\r\nroot = list_first_entry(&fs_info->dead_roots,\r\nstruct btrfs_root, root_list);\r\nlist_del_init(&root->root_list);\r\nspin_unlock(&fs_info->trans_lock);\r\nbtrfs_debug(fs_info, "cleaner removing %llu", root->objectid);\r\nbtrfs_kill_all_delayed_nodes(root);\r\nif (btrfs_header_backref_rev(root->node) <\r\nBTRFS_MIXED_BACKREF_REV)\r\nret = btrfs_drop_snapshot(root, NULL, 0, 0);\r\nelse\r\nret = btrfs_drop_snapshot(root, NULL, 1, 0);\r\nreturn (ret < 0) ? 0 : 1;\r\n}\r\nvoid btrfs_apply_pending_changes(struct btrfs_fs_info *fs_info)\r\n{\r\nunsigned long prev;\r\nunsigned long bit;\r\nprev = xchg(&fs_info->pending_changes, 0);\r\nif (!prev)\r\nreturn;\r\nbit = 1 << BTRFS_PENDING_SET_INODE_MAP_CACHE;\r\nif (prev & bit)\r\nbtrfs_set_opt(fs_info->mount_opt, INODE_MAP_CACHE);\r\nprev &= ~bit;\r\nbit = 1 << BTRFS_PENDING_CLEAR_INODE_MAP_CACHE;\r\nif (prev & bit)\r\nbtrfs_clear_opt(fs_info->mount_opt, INODE_MAP_CACHE);\r\nprev &= ~bit;\r\nbit = 1 << BTRFS_PENDING_COMMIT;\r\nif (prev & bit)\r\nbtrfs_debug(fs_info, "pending commit done");\r\nprev &= ~bit;\r\nif (prev)\r\nbtrfs_warn(fs_info,\r\n"unknown pending changes left 0x%lx, ignoring", prev);\r\n}
