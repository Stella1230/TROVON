static void mvebu_gpioreg_edge_cause(struct mvebu_gpio_chip *mvchip,\r\nstruct regmap **map, unsigned int *offset)\r\n{\r\nint cpu;\r\nswitch (mvchip->soc_variant) {\r\ncase MVEBU_GPIO_SOC_VARIANT_ORION:\r\ncase MVEBU_GPIO_SOC_VARIANT_MV78200:\r\ncase MVEBU_GPIO_SOC_VARIANT_A8K:\r\n*map = mvchip->regs;\r\n*offset = GPIO_EDGE_CAUSE_OFF + mvchip->offset;\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\r\ncpu = smp_processor_id();\r\n*map = mvchip->percpu_regs;\r\n*offset = GPIO_EDGE_CAUSE_ARMADAXP_OFF(cpu);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic u32\r\nmvebu_gpio_read_edge_cause(struct mvebu_gpio_chip *mvchip)\r\n{\r\nstruct regmap *map;\r\nunsigned int offset;\r\nu32 val;\r\nmvebu_gpioreg_edge_cause(mvchip, &map, &offset);\r\nregmap_read(map, offset, &val);\r\nreturn val;\r\n}\r\nstatic void\r\nmvebu_gpio_write_edge_cause(struct mvebu_gpio_chip *mvchip, u32 val)\r\n{\r\nstruct regmap *map;\r\nunsigned int offset;\r\nmvebu_gpioreg_edge_cause(mvchip, &map, &offset);\r\nregmap_write(map, offset, val);\r\n}\r\nstatic inline void\r\nmvebu_gpioreg_edge_mask(struct mvebu_gpio_chip *mvchip,\r\nstruct regmap **map, unsigned int *offset)\r\n{\r\nint cpu;\r\nswitch (mvchip->soc_variant) {\r\ncase MVEBU_GPIO_SOC_VARIANT_ORION:\r\ncase MVEBU_GPIO_SOC_VARIANT_A8K:\r\n*map = mvchip->regs;\r\n*offset = GPIO_EDGE_MASK_OFF + mvchip->offset;\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_MV78200:\r\ncpu = smp_processor_id();\r\n*map = mvchip->regs;\r\n*offset = GPIO_EDGE_MASK_MV78200_OFF(cpu);\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\r\ncpu = smp_processor_id();\r\n*map = mvchip->percpu_regs;\r\n*offset = GPIO_EDGE_MASK_ARMADAXP_OFF(cpu);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic u32\r\nmvebu_gpio_read_edge_mask(struct mvebu_gpio_chip *mvchip)\r\n{\r\nstruct regmap *map;\r\nunsigned int offset;\r\nu32 val;\r\nmvebu_gpioreg_edge_mask(mvchip, &map, &offset);\r\nregmap_read(map, offset, &val);\r\nreturn val;\r\n}\r\nstatic void\r\nmvebu_gpio_write_edge_mask(struct mvebu_gpio_chip *mvchip, u32 val)\r\n{\r\nstruct regmap *map;\r\nunsigned int offset;\r\nmvebu_gpioreg_edge_mask(mvchip, &map, &offset);\r\nregmap_write(map, offset, val);\r\n}\r\nstatic void\r\nmvebu_gpioreg_level_mask(struct mvebu_gpio_chip *mvchip,\r\nstruct regmap **map, unsigned int *offset)\r\n{\r\nint cpu;\r\nswitch (mvchip->soc_variant) {\r\ncase MVEBU_GPIO_SOC_VARIANT_ORION:\r\ncase MVEBU_GPIO_SOC_VARIANT_A8K:\r\n*map = mvchip->regs;\r\n*offset = GPIO_LEVEL_MASK_OFF + mvchip->offset;\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_MV78200:\r\ncpu = smp_processor_id();\r\n*map = mvchip->regs;\r\n*offset = GPIO_LEVEL_MASK_MV78200_OFF(cpu);\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\r\ncpu = smp_processor_id();\r\n*map = mvchip->percpu_regs;\r\n*offset = GPIO_LEVEL_MASK_ARMADAXP_OFF(cpu);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic u32\r\nmvebu_gpio_read_level_mask(struct mvebu_gpio_chip *mvchip)\r\n{\r\nstruct regmap *map;\r\nunsigned int offset;\r\nu32 val;\r\nmvebu_gpioreg_level_mask(mvchip, &map, &offset);\r\nregmap_read(map, offset, &val);\r\nreturn val;\r\n}\r\nstatic void\r\nmvebu_gpio_write_level_mask(struct mvebu_gpio_chip *mvchip, u32 val)\r\n{\r\nstruct regmap *map;\r\nunsigned int offset;\r\nmvebu_gpioreg_level_mask(mvchip, &map, &offset);\r\nregmap_write(map, offset, val);\r\n}\r\nstatic void __iomem *mvebu_pwmreg_blink_on_duration(struct mvebu_pwm *mvpwm)\r\n{\r\nreturn mvpwm->membase + PWM_BLINK_ON_DURATION_OFF;\r\n}\r\nstatic void __iomem *mvebu_pwmreg_blink_off_duration(struct mvebu_pwm *mvpwm)\r\n{\r\nreturn mvpwm->membase + PWM_BLINK_OFF_DURATION_OFF;\r\n}\r\nstatic void mvebu_gpio_set(struct gpio_chip *chip, unsigned int pin, int value)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\r\nregmap_update_bits(mvchip->regs, GPIO_OUT_OFF + mvchip->offset,\r\nBIT(pin), value ? BIT(pin) : 0);\r\n}\r\nstatic int mvebu_gpio_get(struct gpio_chip *chip, unsigned int pin)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\r\nu32 u;\r\nregmap_read(mvchip->regs, GPIO_IO_CONF_OFF + mvchip->offset, &u);\r\nif (u & BIT(pin)) {\r\nu32 data_in, in_pol;\r\nregmap_read(mvchip->regs, GPIO_DATA_IN_OFF + mvchip->offset,\r\n&data_in);\r\nregmap_read(mvchip->regs, GPIO_IN_POL_OFF + mvchip->offset,\r\n&in_pol);\r\nu = data_in ^ in_pol;\r\n} else {\r\nregmap_read(mvchip->regs, GPIO_OUT_OFF + mvchip->offset, &u);\r\n}\r\nreturn (u >> pin) & 1;\r\n}\r\nstatic void mvebu_gpio_blink(struct gpio_chip *chip, unsigned int pin,\r\nint value)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\r\nregmap_update_bits(mvchip->regs, GPIO_BLINK_EN_OFF + mvchip->offset,\r\nBIT(pin), value ? BIT(pin) : 0);\r\n}\r\nstatic int mvebu_gpio_direction_input(struct gpio_chip *chip, unsigned int pin)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\r\nint ret;\r\nret = pinctrl_gpio_direction_input(chip->base + pin);\r\nif (ret)\r\nreturn ret;\r\nregmap_update_bits(mvchip->regs, GPIO_IO_CONF_OFF + mvchip->offset,\r\nBIT(pin), BIT(pin));\r\nreturn 0;\r\n}\r\nstatic int mvebu_gpio_direction_output(struct gpio_chip *chip, unsigned int pin,\r\nint value)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\r\nint ret;\r\nret = pinctrl_gpio_direction_output(chip->base + pin);\r\nif (ret)\r\nreturn ret;\r\nmvebu_gpio_blink(chip, pin, 0);\r\nmvebu_gpio_set(chip, pin, value);\r\nregmap_update_bits(mvchip->regs, GPIO_IO_CONF_OFF + mvchip->offset,\r\nBIT(pin), 0);\r\nreturn 0;\r\n}\r\nstatic int mvebu_gpio_to_irq(struct gpio_chip *chip, unsigned int pin)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\r\nreturn irq_create_mapping(mvchip->domain, pin);\r\n}\r\nstatic void mvebu_gpio_irq_ack(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mvebu_gpio_chip *mvchip = gc->private;\r\nu32 mask = d->mask;\r\nirq_gc_lock(gc);\r\nmvebu_gpio_write_edge_cause(mvchip, ~mask);\r\nirq_gc_unlock(gc);\r\n}\r\nstatic void mvebu_gpio_edge_irq_mask(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mvebu_gpio_chip *mvchip = gc->private;\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = d->mask;\r\nirq_gc_lock(gc);\r\nct->mask_cache_priv &= ~mask;\r\nmvebu_gpio_write_edge_mask(mvchip, ct->mask_cache_priv);\r\nirq_gc_unlock(gc);\r\n}\r\nstatic void mvebu_gpio_edge_irq_unmask(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mvebu_gpio_chip *mvchip = gc->private;\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = d->mask;\r\nirq_gc_lock(gc);\r\nct->mask_cache_priv |= mask;\r\nmvebu_gpio_write_edge_mask(mvchip, ct->mask_cache_priv);\r\nirq_gc_unlock(gc);\r\n}\r\nstatic void mvebu_gpio_level_irq_mask(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mvebu_gpio_chip *mvchip = gc->private;\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = d->mask;\r\nirq_gc_lock(gc);\r\nct->mask_cache_priv &= ~mask;\r\nmvebu_gpio_write_level_mask(mvchip, ct->mask_cache_priv);\r\nirq_gc_unlock(gc);\r\n}\r\nstatic void mvebu_gpio_level_irq_unmask(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mvebu_gpio_chip *mvchip = gc->private;\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = d->mask;\r\nirq_gc_lock(gc);\r\nct->mask_cache_priv |= mask;\r\nmvebu_gpio_write_level_mask(mvchip, ct->mask_cache_priv);\r\nirq_gc_unlock(gc);\r\n}\r\nstatic int mvebu_gpio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nstruct mvebu_gpio_chip *mvchip = gc->private;\r\nint pin;\r\nu32 u;\r\npin = d->hwirq;\r\nregmap_read(mvchip->regs, GPIO_IO_CONF_OFF + mvchip->offset, &u);\r\nif ((u & BIT(pin)) == 0)\r\nreturn -EINVAL;\r\ntype &= IRQ_TYPE_SENSE_MASK;\r\nif (type == IRQ_TYPE_NONE)\r\nreturn -EINVAL;\r\nif (!(ct->type & type))\r\nif (irq_setup_alt_chip(d, type))\r\nreturn -EINVAL;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nregmap_update_bits(mvchip->regs,\r\nGPIO_IN_POL_OFF + mvchip->offset,\r\nBIT(pin), 0);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nregmap_update_bits(mvchip->regs,\r\nGPIO_IN_POL_OFF + mvchip->offset,\r\nBIT(pin), BIT(pin));\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH: {\r\nu32 data_in, in_pol, val;\r\nregmap_read(mvchip->regs,\r\nGPIO_IN_POL_OFF + mvchip->offset, &in_pol);\r\nregmap_read(mvchip->regs,\r\nGPIO_DATA_IN_OFF + mvchip->offset, &data_in);\r\nif ((data_in ^ in_pol) & BIT(pin))\r\nval = BIT(pin);\r\nelse\r\nval = 0;\r\nregmap_update_bits(mvchip->regs,\r\nGPIO_IN_POL_OFF + mvchip->offset,\r\nBIT(pin), val);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mvebu_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nu32 cause, type, data_in, level_mask, edge_cause, edge_mask;\r\nint i;\r\nif (mvchip == NULL)\r\nreturn;\r\nchained_irq_enter(chip, desc);\r\nregmap_read(mvchip->regs, GPIO_DATA_IN_OFF + mvchip->offset, &data_in);\r\nlevel_mask = mvebu_gpio_read_level_mask(mvchip);\r\nedge_cause = mvebu_gpio_read_edge_cause(mvchip);\r\nedge_mask = mvebu_gpio_read_edge_mask(mvchip);\r\ncause = (data_in & level_mask) | (edge_cause & edge_mask);\r\nfor (i = 0; i < mvchip->chip.ngpio; i++) {\r\nint irq;\r\nirq = irq_find_mapping(mvchip->domain, i);\r\nif (!(cause & BIT(i)))\r\ncontinue;\r\ntype = irq_get_trigger_type(irq);\r\nif ((type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {\r\nu32 polarity;\r\nregmap_read(mvchip->regs,\r\nGPIO_IN_POL_OFF + mvchip->offset,\r\n&polarity);\r\npolarity ^= BIT(i);\r\nregmap_write(mvchip->regs,\r\nGPIO_IN_POL_OFF + mvchip->offset,\r\npolarity);\r\n}\r\ngeneric_handle_irq(irq);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic struct mvebu_pwm *to_mvebu_pwm(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct mvebu_pwm, chip);\r\n}\r\nstatic int mvebu_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct mvebu_pwm *mvpwm = to_mvebu_pwm(chip);\r\nstruct mvebu_gpio_chip *mvchip = mvpwm->mvchip;\r\nstruct gpio_desc *desc;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&mvpwm->lock, flags);\r\nif (mvpwm->gpiod) {\r\nret = -EBUSY;\r\n} else {\r\ndesc = gpio_to_desc(mvchip->chip.base + pwm->hwpwm);\r\nif (!desc) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nret = gpiod_request(desc, "mvebu-pwm");\r\nif (ret)\r\ngoto out;\r\nret = gpiod_direction_output(desc, 0);\r\nif (ret) {\r\ngpiod_free(desc);\r\ngoto out;\r\n}\r\nmvpwm->gpiod = desc;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&mvpwm->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void mvebu_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct mvebu_pwm *mvpwm = to_mvebu_pwm(chip);\r\nunsigned long flags;\r\nspin_lock_irqsave(&mvpwm->lock, flags);\r\ngpiod_free(mvpwm->gpiod);\r\nmvpwm->gpiod = NULL;\r\nspin_unlock_irqrestore(&mvpwm->lock, flags);\r\n}\r\nstatic void mvebu_pwm_get_state(struct pwm_chip *chip,\r\nstruct pwm_device *pwm,\r\nstruct pwm_state *state) {\r\nstruct mvebu_pwm *mvpwm = to_mvebu_pwm(chip);\r\nstruct mvebu_gpio_chip *mvchip = mvpwm->mvchip;\r\nunsigned long long val;\r\nunsigned long flags;\r\nu32 u;\r\nspin_lock_irqsave(&mvpwm->lock, flags);\r\nval = (unsigned long long)\r\nreadl_relaxed(mvebu_pwmreg_blink_on_duration(mvpwm));\r\nval *= NSEC_PER_SEC;\r\ndo_div(val, mvpwm->clk_rate);\r\nif (val > UINT_MAX)\r\nstate->duty_cycle = UINT_MAX;\r\nelse if (val)\r\nstate->duty_cycle = val;\r\nelse\r\nstate->duty_cycle = 1;\r\nval = (unsigned long long)\r\nreadl_relaxed(mvebu_pwmreg_blink_off_duration(mvpwm));\r\nval *= NSEC_PER_SEC;\r\ndo_div(val, mvpwm->clk_rate);\r\nif (val < state->duty_cycle) {\r\nstate->period = 1;\r\n} else {\r\nval -= state->duty_cycle;\r\nif (val > UINT_MAX)\r\nstate->period = UINT_MAX;\r\nelse if (val)\r\nstate->period = val;\r\nelse\r\nstate->period = 1;\r\n}\r\nregmap_read(mvchip->regs, GPIO_BLINK_EN_OFF + mvchip->offset, &u);\r\nif (u)\r\nstate->enabled = true;\r\nelse\r\nstate->enabled = false;\r\nspin_unlock_irqrestore(&mvpwm->lock, flags);\r\n}\r\nstatic int mvebu_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct mvebu_pwm *mvpwm = to_mvebu_pwm(chip);\r\nstruct mvebu_gpio_chip *mvchip = mvpwm->mvchip;\r\nunsigned long long val;\r\nunsigned long flags;\r\nunsigned int on, off;\r\nval = (unsigned long long) mvpwm->clk_rate * state->duty_cycle;\r\ndo_div(val, NSEC_PER_SEC);\r\nif (val > UINT_MAX)\r\nreturn -EINVAL;\r\nif (val)\r\non = val;\r\nelse\r\non = 1;\r\nval = (unsigned long long) mvpwm->clk_rate *\r\n(state->period - state->duty_cycle);\r\ndo_div(val, NSEC_PER_SEC);\r\nif (val > UINT_MAX)\r\nreturn -EINVAL;\r\nif (val)\r\noff = val;\r\nelse\r\noff = 1;\r\nspin_lock_irqsave(&mvpwm->lock, flags);\r\nwritel_relaxed(on, mvebu_pwmreg_blink_on_duration(mvpwm));\r\nwritel_relaxed(off, mvebu_pwmreg_blink_off_duration(mvpwm));\r\nif (state->enabled)\r\nmvebu_gpio_blink(&mvchip->chip, pwm->hwpwm, 1);\r\nelse\r\nmvebu_gpio_blink(&mvchip->chip, pwm->hwpwm, 0);\r\nspin_unlock_irqrestore(&mvpwm->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void __maybe_unused mvebu_pwm_suspend(struct mvebu_gpio_chip *mvchip)\r\n{\r\nstruct mvebu_pwm *mvpwm = mvchip->mvpwm;\r\nregmap_read(mvchip->regs, GPIO_BLINK_CNT_SELECT_OFF + mvchip->offset,\r\n&mvpwm->blink_select);\r\nmvpwm->blink_on_duration =\r\nreadl_relaxed(mvebu_pwmreg_blink_on_duration(mvpwm));\r\nmvpwm->blink_off_duration =\r\nreadl_relaxed(mvebu_pwmreg_blink_off_duration(mvpwm));\r\n}\r\nstatic void __maybe_unused mvebu_pwm_resume(struct mvebu_gpio_chip *mvchip)\r\n{\r\nstruct mvebu_pwm *mvpwm = mvchip->mvpwm;\r\nregmap_write(mvchip->regs, GPIO_BLINK_CNT_SELECT_OFF + mvchip->offset,\r\nmvpwm->blink_select);\r\nwritel_relaxed(mvpwm->blink_on_duration,\r\nmvebu_pwmreg_blink_on_duration(mvpwm));\r\nwritel_relaxed(mvpwm->blink_off_duration,\r\nmvebu_pwmreg_blink_off_duration(mvpwm));\r\n}\r\nstatic int mvebu_pwm_probe(struct platform_device *pdev,\r\nstruct mvebu_gpio_chip *mvchip,\r\nint id)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mvebu_pwm *mvpwm;\r\nstruct resource *res;\r\nu32 set;\r\nif (!of_device_is_compatible(mvchip->chip.of_node,\r\n"marvell,armada-370-gpio"))\r\nreturn 0;\r\nif (IS_ERR(mvchip->clk))\r\nreturn PTR_ERR(mvchip->clk);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pwm");\r\nif (!res)\r\nreturn 0;\r\nif (id == 0)\r\nset = 0;\r\nelse if (id == 1)\r\nset = U32_MAX;\r\nelse\r\nreturn -EINVAL;\r\nregmap_write(mvchip->regs,\r\nGPIO_BLINK_CNT_SELECT_OFF + mvchip->offset, set);\r\nmvpwm = devm_kzalloc(dev, sizeof(struct mvebu_pwm), GFP_KERNEL);\r\nif (!mvpwm)\r\nreturn -ENOMEM;\r\nmvchip->mvpwm = mvpwm;\r\nmvpwm->mvchip = mvchip;\r\nmvpwm->membase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(mvpwm->membase))\r\nreturn PTR_ERR(mvpwm->membase);\r\nmvpwm->clk_rate = clk_get_rate(mvchip->clk);\r\nif (!mvpwm->clk_rate) {\r\ndev_err(dev, "failed to get clock rate\n");\r\nreturn -EINVAL;\r\n}\r\nmvpwm->chip.dev = dev;\r\nmvpwm->chip.ops = &mvebu_pwm_ops;\r\nmvpwm->chip.npwm = mvchip->chip.ngpio;\r\nmvpwm->chip.base = -1;\r\nspin_lock_init(&mvpwm->lock);\r\nreturn pwmchip_add(&mvpwm->chip);\r\n}\r\nstatic void mvebu_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);\r\nu32 out, io_conf, blink, in_pol, data_in, cause, edg_msk, lvl_msk;\r\nint i;\r\nregmap_read(mvchip->regs, GPIO_OUT_OFF + mvchip->offset, &out);\r\nregmap_read(mvchip->regs, GPIO_IO_CONF_OFF + mvchip->offset, &io_conf);\r\nregmap_read(mvchip->regs, GPIO_BLINK_EN_OFF + mvchip->offset, &blink);\r\nregmap_read(mvchip->regs, GPIO_IN_POL_OFF + mvchip->offset, &in_pol);\r\nregmap_read(mvchip->regs, GPIO_DATA_IN_OFF + mvchip->offset, &data_in);\r\ncause = mvebu_gpio_read_edge_cause(mvchip);\r\nedg_msk = mvebu_gpio_read_edge_mask(mvchip);\r\nlvl_msk = mvebu_gpio_read_level_mask(mvchip);\r\nfor (i = 0; i < chip->ngpio; i++) {\r\nconst char *label;\r\nu32 msk;\r\nbool is_out;\r\nlabel = gpiochip_is_requested(chip, i);\r\nif (!label)\r\ncontinue;\r\nmsk = BIT(i);\r\nis_out = !(io_conf & msk);\r\nseq_printf(s, " gpio-%-3d (%-20.20s)", chip->base + i, label);\r\nif (is_out) {\r\nseq_printf(s, " out %s %s\n",\r\nout & msk ? "hi" : "lo",\r\nblink & msk ? "(blink )" : "");\r\ncontinue;\r\n}\r\nseq_printf(s, " in %s (act %s) - IRQ",\r\n(data_in ^ in_pol) & msk ? "hi" : "lo",\r\nin_pol & msk ? "lo" : "hi");\r\nif (!((edg_msk | lvl_msk) & msk)) {\r\nseq_puts(s, " disabled\n");\r\ncontinue;\r\n}\r\nif (edg_msk & msk)\r\nseq_puts(s, " edge ");\r\nif (lvl_msk & msk)\r\nseq_puts(s, " level");\r\nseq_printf(s, " (%s)\n", cause & msk ? "pending" : "clear ");\r\n}\r\n}\r\nstatic int mvebu_gpio_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = platform_get_drvdata(pdev);\r\nint i;\r\nregmap_read(mvchip->regs, GPIO_OUT_OFF + mvchip->offset,\r\n&mvchip->out_reg);\r\nregmap_read(mvchip->regs, GPIO_IO_CONF_OFF + mvchip->offset,\r\n&mvchip->io_conf_reg);\r\nregmap_read(mvchip->regs, GPIO_BLINK_EN_OFF + mvchip->offset,\r\n&mvchip->blink_en_reg);\r\nregmap_read(mvchip->regs, GPIO_IN_POL_OFF + mvchip->offset,\r\n&mvchip->in_pol_reg);\r\nswitch (mvchip->soc_variant) {\r\ncase MVEBU_GPIO_SOC_VARIANT_ORION:\r\ncase MVEBU_GPIO_SOC_VARIANT_A8K:\r\nregmap_read(mvchip->regs, GPIO_EDGE_MASK_OFF + mvchip->offset,\r\n&mvchip->edge_mask_regs[0]);\r\nregmap_read(mvchip->regs, GPIO_LEVEL_MASK_OFF + mvchip->offset,\r\n&mvchip->level_mask_regs[0]);\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_MV78200:\r\nfor (i = 0; i < 2; i++) {\r\nregmap_read(mvchip->regs,\r\nGPIO_EDGE_MASK_MV78200_OFF(i),\r\n&mvchip->edge_mask_regs[i]);\r\nregmap_read(mvchip->regs,\r\nGPIO_LEVEL_MASK_MV78200_OFF(i),\r\n&mvchip->level_mask_regs[i]);\r\n}\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\r\nfor (i = 0; i < 4; i++) {\r\nregmap_read(mvchip->regs,\r\nGPIO_EDGE_MASK_ARMADAXP_OFF(i),\r\n&mvchip->edge_mask_regs[i]);\r\nregmap_read(mvchip->regs,\r\nGPIO_LEVEL_MASK_ARMADAXP_OFF(i),\r\n&mvchip->level_mask_regs[i]);\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (IS_ENABLED(CONFIG_PWM))\r\nmvebu_pwm_suspend(mvchip);\r\nreturn 0;\r\n}\r\nstatic int mvebu_gpio_resume(struct platform_device *pdev)\r\n{\r\nstruct mvebu_gpio_chip *mvchip = platform_get_drvdata(pdev);\r\nint i;\r\nregmap_write(mvchip->regs, GPIO_OUT_OFF + mvchip->offset,\r\nmvchip->out_reg);\r\nregmap_write(mvchip->regs, GPIO_IO_CONF_OFF + mvchip->offset,\r\nmvchip->io_conf_reg);\r\nregmap_write(mvchip->regs, GPIO_BLINK_EN_OFF + mvchip->offset,\r\nmvchip->blink_en_reg);\r\nregmap_write(mvchip->regs, GPIO_IN_POL_OFF + mvchip->offset,\r\nmvchip->in_pol_reg);\r\nswitch (mvchip->soc_variant) {\r\ncase MVEBU_GPIO_SOC_VARIANT_ORION:\r\ncase MVEBU_GPIO_SOC_VARIANT_A8K:\r\nregmap_write(mvchip->regs, GPIO_EDGE_MASK_OFF + mvchip->offset,\r\nmvchip->edge_mask_regs[0]);\r\nregmap_write(mvchip->regs, GPIO_LEVEL_MASK_OFF + mvchip->offset,\r\nmvchip->level_mask_regs[0]);\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_MV78200:\r\nfor (i = 0; i < 2; i++) {\r\nregmap_write(mvchip->regs,\r\nGPIO_EDGE_MASK_MV78200_OFF(i),\r\nmvchip->edge_mask_regs[i]);\r\nregmap_write(mvchip->regs,\r\nGPIO_LEVEL_MASK_MV78200_OFF(i),\r\nmvchip->level_mask_regs[i]);\r\n}\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\r\nfor (i = 0; i < 4; i++) {\r\nregmap_write(mvchip->regs,\r\nGPIO_EDGE_MASK_ARMADAXP_OFF(i),\r\nmvchip->edge_mask_regs[i]);\r\nregmap_write(mvchip->regs,\r\nGPIO_LEVEL_MASK_ARMADAXP_OFF(i),\r\nmvchip->level_mask_regs[i]);\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (IS_ENABLED(CONFIG_PWM))\r\nmvebu_pwm_resume(mvchip);\r\nreturn 0;\r\n}\r\nstatic int mvebu_gpio_probe_raw(struct platform_device *pdev,\r\nstruct mvebu_gpio_chip *mvchip)\r\n{\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nmvchip->regs = devm_regmap_init_mmio(&pdev->dev, base,\r\n&mvebu_gpio_regmap_config);\r\nif (IS_ERR(mvchip->regs))\r\nreturn PTR_ERR(mvchip->regs);\r\nmvchip->offset = 0;\r\nif (mvchip->soc_variant == MVEBU_GPIO_SOC_VARIANT_ARMADAXP) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nmvchip->percpu_regs =\r\ndevm_regmap_init_mmio(&pdev->dev, base,\r\n&mvebu_gpio_regmap_config);\r\nif (IS_ERR(mvchip->percpu_regs))\r\nreturn PTR_ERR(mvchip->percpu_regs);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvebu_gpio_probe_syscon(struct platform_device *pdev,\r\nstruct mvebu_gpio_chip *mvchip)\r\n{\r\nmvchip->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\r\nif (IS_ERR(mvchip->regs))\r\nreturn PTR_ERR(mvchip->regs);\r\nif (of_property_read_u32(pdev->dev.of_node, "offset", &mvchip->offset))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int mvebu_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct mvebu_gpio_chip *mvchip;\r\nconst struct of_device_id *match;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\nunsigned int ngpios;\r\nbool have_irqs;\r\nint soc_variant;\r\nint i, cpu, id;\r\nint err;\r\nmatch = of_match_device(mvebu_gpio_of_match, &pdev->dev);\r\nif (match)\r\nsoc_variant = (unsigned long) match->data;\r\nelse\r\nsoc_variant = MVEBU_GPIO_SOC_VARIANT_ORION;\r\nhave_irqs = of_irq_count(np) != 0;\r\nmvchip = devm_kzalloc(&pdev->dev, sizeof(struct mvebu_gpio_chip),\r\nGFP_KERNEL);\r\nif (!mvchip)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, mvchip);\r\nif (of_property_read_u32(pdev->dev.of_node, "ngpios", &ngpios)) {\r\ndev_err(&pdev->dev, "Missing ngpios OF property\n");\r\nreturn -ENODEV;\r\n}\r\nid = of_alias_get_id(pdev->dev.of_node, "gpio");\r\nif (id < 0) {\r\ndev_err(&pdev->dev, "Couldn't get OF id\n");\r\nreturn id;\r\n}\r\nmvchip->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (!IS_ERR(mvchip->clk))\r\nclk_prepare_enable(mvchip->clk);\r\nmvchip->soc_variant = soc_variant;\r\nmvchip->chip.label = dev_name(&pdev->dev);\r\nmvchip->chip.parent = &pdev->dev;\r\nmvchip->chip.request = gpiochip_generic_request;\r\nmvchip->chip.free = gpiochip_generic_free;\r\nmvchip->chip.direction_input = mvebu_gpio_direction_input;\r\nmvchip->chip.get = mvebu_gpio_get;\r\nmvchip->chip.direction_output = mvebu_gpio_direction_output;\r\nmvchip->chip.set = mvebu_gpio_set;\r\nif (have_irqs)\r\nmvchip->chip.to_irq = mvebu_gpio_to_irq;\r\nmvchip->chip.base = id * MVEBU_MAX_GPIO_PER_BANK;\r\nmvchip->chip.ngpio = ngpios;\r\nmvchip->chip.can_sleep = false;\r\nmvchip->chip.of_node = np;\r\nmvchip->chip.dbg_show = mvebu_gpio_dbg_show;\r\nif (soc_variant == MVEBU_GPIO_SOC_VARIANT_A8K)\r\nerr = mvebu_gpio_probe_syscon(pdev, mvchip);\r\nelse\r\nerr = mvebu_gpio_probe_raw(pdev, mvchip);\r\nif (err)\r\nreturn err;\r\nswitch (soc_variant) {\r\ncase MVEBU_GPIO_SOC_VARIANT_ORION:\r\ncase MVEBU_GPIO_SOC_VARIANT_A8K:\r\nregmap_write(mvchip->regs,\r\nGPIO_EDGE_CAUSE_OFF + mvchip->offset, 0);\r\nregmap_write(mvchip->regs,\r\nGPIO_EDGE_MASK_OFF + mvchip->offset, 0);\r\nregmap_write(mvchip->regs,\r\nGPIO_LEVEL_MASK_OFF + mvchip->offset, 0);\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_MV78200:\r\nregmap_write(mvchip->regs, GPIO_EDGE_CAUSE_OFF, 0);\r\nfor (cpu = 0; cpu < 2; cpu++) {\r\nregmap_write(mvchip->regs,\r\nGPIO_EDGE_MASK_MV78200_OFF(cpu), 0);\r\nregmap_write(mvchip->regs,\r\nGPIO_LEVEL_MASK_MV78200_OFF(cpu), 0);\r\n}\r\nbreak;\r\ncase MVEBU_GPIO_SOC_VARIANT_ARMADAXP:\r\nregmap_write(mvchip->regs, GPIO_EDGE_CAUSE_OFF, 0);\r\nregmap_write(mvchip->regs, GPIO_EDGE_MASK_OFF, 0);\r\nregmap_write(mvchip->regs, GPIO_LEVEL_MASK_OFF, 0);\r\nfor (cpu = 0; cpu < 4; cpu++) {\r\nregmap_write(mvchip->percpu_regs,\r\nGPIO_EDGE_CAUSE_ARMADAXP_OFF(cpu), 0);\r\nregmap_write(mvchip->percpu_regs,\r\nGPIO_EDGE_MASK_ARMADAXP_OFF(cpu), 0);\r\nregmap_write(mvchip->percpu_regs,\r\nGPIO_LEVEL_MASK_ARMADAXP_OFF(cpu), 0);\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ndevm_gpiochip_add_data(&pdev->dev, &mvchip->chip, mvchip);\r\nif (!have_irqs)\r\nreturn 0;\r\nmvchip->domain =\r\nirq_domain_add_linear(np, ngpios, &irq_generic_chip_ops, NULL);\r\nif (!mvchip->domain) {\r\ndev_err(&pdev->dev, "couldn't allocate irq domain %s (DT).\n",\r\nmvchip->chip.label);\r\nreturn -ENODEV;\r\n}\r\nerr = irq_alloc_domain_generic_chips(\r\nmvchip->domain, ngpios, 2, np->name, handle_level_irq,\r\nIRQ_NOREQUEST | IRQ_NOPROBE | IRQ_LEVEL, 0, 0);\r\nif (err) {\r\ndev_err(&pdev->dev, "couldn't allocate irq chips %s (DT).\n",\r\nmvchip->chip.label);\r\ngoto err_domain;\r\n}\r\ngc = irq_get_domain_generic_chip(mvchip->domain, 0);\r\ngc->private = mvchip;\r\nct = &gc->chip_types[0];\r\nct->type = IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW;\r\nct->chip.irq_mask = mvebu_gpio_level_irq_mask;\r\nct->chip.irq_unmask = mvebu_gpio_level_irq_unmask;\r\nct->chip.irq_set_type = mvebu_gpio_irq_set_type;\r\nct->chip.name = mvchip->chip.label;\r\nct = &gc->chip_types[1];\r\nct->type = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;\r\nct->chip.irq_ack = mvebu_gpio_irq_ack;\r\nct->chip.irq_mask = mvebu_gpio_edge_irq_mask;\r\nct->chip.irq_unmask = mvebu_gpio_edge_irq_unmask;\r\nct->chip.irq_set_type = mvebu_gpio_irq_set_type;\r\nct->handler = handle_edge_irq;\r\nct->chip.name = mvchip->chip.label;\r\nfor (i = 0; i < 4; i++) {\r\nint irq = platform_get_irq(pdev, i);\r\nif (irq < 0)\r\ncontinue;\r\nirq_set_chained_handler_and_data(irq, mvebu_gpio_irq_handler,\r\nmvchip);\r\n}\r\nif (IS_ENABLED(CONFIG_PWM))\r\nreturn mvebu_pwm_probe(pdev, mvchip, id);\r\nreturn 0;\r\nerr_domain:\r\nirq_domain_remove(mvchip->domain);\r\nreturn err;\r\n}
