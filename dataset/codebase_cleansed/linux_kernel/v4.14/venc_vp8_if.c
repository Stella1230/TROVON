static inline u32 vp8_enc_read_reg(struct venc_vp8_inst *inst, u32 addr)\r\n{\r\nreturn readl(inst->hw_base + addr);\r\n}\r\nstatic void vp8_enc_free_work_buf(struct venc_vp8_inst *inst)\r\n{\r\nint i;\r\nmtk_vcodec_debug_enter(inst);\r\nfor (i = 0; i < VENC_VP8_VPU_WORK_BUF_MAX; i++) {\r\nif (inst->work_bufs[i].size == 0)\r\ncontinue;\r\nmtk_vcodec_mem_free(inst->ctx, &inst->work_bufs[i]);\r\n}\r\nmtk_vcodec_debug_leave(inst);\r\n}\r\nstatic int vp8_enc_alloc_work_buf(struct venc_vp8_inst *inst)\r\n{\r\nint i;\r\nint ret = 0;\r\nstruct venc_vp8_vpu_buf *wb = inst->vsi->work_bufs;\r\nmtk_vcodec_debug_enter(inst);\r\nfor (i = 0; i < VENC_VP8_VPU_WORK_BUF_MAX; i++) {\r\nif (wb[i].size == 0)\r\ncontinue;\r\ninst->work_bufs[i].size = wb[i].size;\r\nret = mtk_vcodec_mem_alloc(inst->ctx, &inst->work_bufs[i]);\r\nif (ret) {\r\nmtk_vcodec_err(inst,\r\n"cannot alloc work_bufs[%d]", i);\r\ngoto err_alloc;\r\n}\r\nif (i == VENC_VP8_VPU_WORK_BUF_RC_CODE ||\r\ni == VENC_VP8_VPU_WORK_BUF_RC_CODE2 ||\r\ni == VENC_VP8_VPU_WORK_BUF_RC_CODE3) {\r\nvoid *tmp_va;\r\ntmp_va = vpu_mapping_dm_addr(inst->vpu_inst.dev,\r\nwb[i].vpua);\r\nmemcpy(inst->work_bufs[i].va, tmp_va, wb[i].size);\r\n}\r\nwb[i].iova = inst->work_bufs[i].dma_addr;\r\nmtk_vcodec_debug(inst,\r\n"work_bufs[%d] va=0x%p,iova=%pad,size=%zu",\r\ni, inst->work_bufs[i].va,\r\n&inst->work_bufs[i].dma_addr,\r\ninst->work_bufs[i].size);\r\n}\r\nmtk_vcodec_debug_leave(inst);\r\nreturn ret;\r\nerr_alloc:\r\nvp8_enc_free_work_buf(inst);\r\nreturn ret;\r\n}\r\nstatic unsigned int vp8_enc_wait_venc_done(struct venc_vp8_inst *inst)\r\n{\r\nunsigned int irq_status = 0;\r\nstruct mtk_vcodec_ctx *ctx = (struct mtk_vcodec_ctx *)inst->ctx;\r\nif (!mtk_vcodec_wait_for_done_ctx(ctx, MTK_INST_IRQ_RECEIVED,\r\nWAIT_INTR_TIMEOUT_MS)) {\r\nirq_status = ctx->irq_status;\r\nmtk_vcodec_debug(inst, "isr return %x", irq_status);\r\n}\r\nreturn irq_status;\r\n}\r\nstatic int vp8_enc_compose_one_frame(struct venc_vp8_inst *inst,\r\nstruct mtk_vcodec_mem *bs_buf,\r\nunsigned int *bs_size)\r\n{\r\nunsigned int not_key;\r\nu32 bs_frm_size;\r\nu32 bs_hdr_len;\r\nunsigned int ac_tag_size;\r\nu8 ac_tag[MAX_AC_TAG_SIZE];\r\nu32 tag;\r\nbs_frm_size = vp8_enc_read_reg(inst, VENC_BITSTREAM_FRAME_SIZE);\r\nbs_hdr_len = vp8_enc_read_reg(inst, VENC_BITSTREAM_HEADER_LEN);\r\nnot_key = !inst->vpu_inst.is_key_frm;\r\ntag = (bs_hdr_len << 5) | 0x10 | not_key;\r\nac_tag[0] = tag & 0xff;\r\nac_tag[1] = (tag >> 8) & 0xff;\r\nac_tag[2] = (tag >> 16) & 0xff;\r\nif (not_key == 0) {\r\nac_tag_size = MAX_AC_TAG_SIZE;\r\nac_tag[3] = 0x9d;\r\nac_tag[4] = 0x01;\r\nac_tag[5] = 0x2a;\r\nac_tag[6] = inst->vsi->config.pic_w;\r\nac_tag[7] = inst->vsi->config.pic_w >> 8;\r\nac_tag[8] = inst->vsi->config.pic_h;\r\nac_tag[9] = inst->vsi->config.pic_h >> 8;\r\n} else {\r\nac_tag_size = 3;\r\n}\r\nif (bs_buf->size < bs_hdr_len + bs_frm_size + ac_tag_size) {\r\nmtk_vcodec_err(inst, "bitstream buf size is too small(%zu)",\r\nbs_buf->size);\r\nreturn -EINVAL;\r\n}\r\nmemmove(bs_buf->va + bs_hdr_len + ac_tag_size,\r\nbs_buf->va, bs_frm_size);\r\nmemcpy(bs_buf->va + ac_tag_size,\r\ninst->work_bufs[VENC_VP8_VPU_WORK_BUF_BS_HEADER].va,\r\nbs_hdr_len);\r\nmemcpy(bs_buf->va, ac_tag, ac_tag_size);\r\n*bs_size = bs_frm_size + bs_hdr_len + ac_tag_size;\r\nreturn 0;\r\n}\r\nstatic int vp8_enc_encode_frame(struct venc_vp8_inst *inst,\r\nstruct venc_frm_buf *frm_buf,\r\nstruct mtk_vcodec_mem *bs_buf,\r\nunsigned int *bs_size)\r\n{\r\nint ret = 0;\r\nunsigned int irq_status;\r\nmtk_vcodec_debug(inst, "->frm_cnt=%d", inst->frm_cnt);\r\nret = vpu_enc_encode(&inst->vpu_inst, 0, frm_buf, bs_buf, bs_size);\r\nif (ret)\r\nreturn ret;\r\nirq_status = vp8_enc_wait_venc_done(inst);\r\nif (irq_status != MTK_VENC_IRQ_STATUS_FRM) {\r\nmtk_vcodec_err(inst, "irq_status=%d failed", irq_status);\r\nreturn -EIO;\r\n}\r\nif (vp8_enc_compose_one_frame(inst, bs_buf, bs_size)) {\r\nmtk_vcodec_err(inst, "vp8_enc_compose_one_frame failed");\r\nreturn -EINVAL;\r\n}\r\ninst->frm_cnt++;\r\nmtk_vcodec_debug(inst, "<-size=%d key_frm=%d", *bs_size,\r\ninst->vpu_inst.is_key_frm);\r\nreturn ret;\r\n}\r\nstatic int vp8_enc_init(struct mtk_vcodec_ctx *ctx, unsigned long *handle)\r\n{\r\nint ret = 0;\r\nstruct venc_vp8_inst *inst;\r\ninst = kzalloc(sizeof(*inst), GFP_KERNEL);\r\nif (!inst)\r\nreturn -ENOMEM;\r\ninst->ctx = ctx;\r\ninst->vpu_inst.ctx = ctx;\r\ninst->vpu_inst.dev = ctx->dev->vpu_plat_dev;\r\ninst->vpu_inst.id = IPI_VENC_VP8;\r\ninst->hw_base = mtk_vcodec_get_reg_addr(inst->ctx, VENC_LT_SYS);\r\nmtk_vcodec_debug_enter(inst);\r\nret = vpu_enc_init(&inst->vpu_inst);\r\ninst->vsi = (struct venc_vp8_vsi *)inst->vpu_inst.vsi;\r\nmtk_vcodec_debug_leave(inst);\r\nif (ret)\r\nkfree(inst);\r\nelse\r\n(*handle) = (unsigned long)inst;\r\nreturn ret;\r\n}\r\nstatic int vp8_enc_encode(unsigned long handle,\r\nenum venc_start_opt opt,\r\nstruct venc_frm_buf *frm_buf,\r\nstruct mtk_vcodec_mem *bs_buf,\r\nstruct venc_done_result *result)\r\n{\r\nint ret = 0;\r\nstruct venc_vp8_inst *inst = (struct venc_vp8_inst *)handle;\r\nstruct mtk_vcodec_ctx *ctx = inst->ctx;\r\nmtk_vcodec_debug_enter(inst);\r\nenable_irq(ctx->dev->enc_lt_irq);\r\nswitch (opt) {\r\ncase VENC_START_OPT_ENCODE_FRAME:\r\nret = vp8_enc_encode_frame(inst, frm_buf, bs_buf,\r\n&result->bs_size);\r\nif (ret)\r\ngoto encode_err;\r\nresult->is_key_frm = inst->vpu_inst.is_key_frm;\r\nbreak;\r\ndefault:\r\nmtk_vcodec_err(inst, "opt not support:%d", opt);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nencode_err:\r\ndisable_irq(ctx->dev->enc_lt_irq);\r\nmtk_vcodec_debug_leave(inst);\r\nreturn ret;\r\n}\r\nstatic int vp8_enc_set_param(unsigned long handle,\r\nenum venc_set_param_type type,\r\nstruct venc_enc_param *enc_prm)\r\n{\r\nint ret = 0;\r\nstruct venc_vp8_inst *inst = (struct venc_vp8_inst *)handle;\r\nmtk_vcodec_debug(inst, "->type=%d", type);\r\nswitch (type) {\r\ncase VENC_SET_PARAM_ENC:\r\ninst->vsi->config.input_fourcc = enc_prm->input_yuv_fmt;\r\ninst->vsi->config.bitrate = enc_prm->bitrate;\r\ninst->vsi->config.pic_w = enc_prm->width;\r\ninst->vsi->config.pic_h = enc_prm->height;\r\ninst->vsi->config.buf_w = enc_prm->buf_width;\r\ninst->vsi->config.buf_h = enc_prm->buf_height;\r\ninst->vsi->config.gop_size = enc_prm->gop_size;\r\ninst->vsi->config.framerate = enc_prm->frm_rate;\r\ninst->vsi->config.ts_mode = inst->ts_mode;\r\nret = vpu_enc_set_param(&inst->vpu_inst, type, enc_prm);\r\nif (ret)\r\nbreak;\r\nif (inst->work_buf_allocated) {\r\nvp8_enc_free_work_buf(inst);\r\ninst->work_buf_allocated = false;\r\n}\r\nret = vp8_enc_alloc_work_buf(inst);\r\nif (ret)\r\nbreak;\r\ninst->work_buf_allocated = true;\r\nbreak;\r\ncase VENC_SET_PARAM_TS_MODE:\r\ninst->ts_mode = 1;\r\nmtk_vcodec_debug(inst, "set ts_mode");\r\nbreak;\r\ndefault:\r\nret = vpu_enc_set_param(&inst->vpu_inst, type, enc_prm);\r\nbreak;\r\n}\r\nmtk_vcodec_debug_leave(inst);\r\nreturn ret;\r\n}\r\nstatic int vp8_enc_deinit(unsigned long handle)\r\n{\r\nint ret = 0;\r\nstruct venc_vp8_inst *inst = (struct venc_vp8_inst *)handle;\r\nmtk_vcodec_debug_enter(inst);\r\nret = vpu_enc_deinit(&inst->vpu_inst);\r\nif (inst->work_buf_allocated)\r\nvp8_enc_free_work_buf(inst);\r\nmtk_vcodec_debug_leave(inst);\r\nkfree(inst);\r\nreturn ret;\r\n}\r\nconst struct venc_common_if *get_vp8_enc_comm_if(void)\r\n{\r\nreturn &venc_vp8_if;\r\n}
