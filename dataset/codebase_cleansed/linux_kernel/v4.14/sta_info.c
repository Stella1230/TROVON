static int sta_info_hash_del(struct ieee80211_local *local,\r\nstruct sta_info *sta)\r\n{\r\nreturn rhltable_remove(&local->sta_hash, &sta->hash_node,\r\nsta_rht_params);\r\n}\r\nstatic void __cleanup_single_sta(struct sta_info *sta)\r\n{\r\nint ac, i;\r\nstruct tid_ampdu_tx *tid_tx;\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct fq *fq = &local->fq;\r\nstruct ps_data *ps;\r\nif (test_sta_flag(sta, WLAN_STA_PS_STA) ||\r\ntest_sta_flag(sta, WLAN_STA_PS_DRIVER) ||\r\ntest_sta_flag(sta, WLAN_STA_PS_DELIVER)) {\r\nif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\r\nsta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\r\nps = &sdata->bss->ps;\r\nelse if (ieee80211_vif_is_mesh(&sdata->vif))\r\nps = &sdata->u.mesh.ps;\r\nelse\r\nreturn;\r\nclear_sta_flag(sta, WLAN_STA_PS_STA);\r\nclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\r\nclear_sta_flag(sta, WLAN_STA_PS_DELIVER);\r\natomic_dec(&ps->num_sta_ps);\r\n}\r\nif (sta->sta.txq[0]) {\r\nfor (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {\r\nstruct txq_info *txqi = to_txq_info(sta->sta.txq[i]);\r\nspin_lock_bh(&fq->lock);\r\nieee80211_txq_purge(local, txqi);\r\nspin_unlock_bh(&fq->lock);\r\n}\r\n}\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\r\nlocal->total_ps_buffered -= skb_queue_len(&sta->ps_tx_buf[ac]);\r\nieee80211_purge_tx_queue(&local->hw, &sta->ps_tx_buf[ac]);\r\nieee80211_purge_tx_queue(&local->hw, &sta->tx_filtered[ac]);\r\n}\r\nif (ieee80211_vif_is_mesh(&sdata->vif))\r\nmesh_sta_cleanup(sta);\r\ncancel_work_sync(&sta->drv_deliver_wk);\r\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\r\nkfree(sta->ampdu_mlme.tid_start_tx[i]);\r\ntid_tx = rcu_dereference_raw(sta->ampdu_mlme.tid_tx[i]);\r\nif (!tid_tx)\r\ncontinue;\r\nieee80211_purge_tx_queue(&local->hw, &tid_tx->pending);\r\nkfree(tid_tx);\r\n}\r\n}\r\nstatic void cleanup_single_sta(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct ieee80211_local *local = sdata->local;\r\n__cleanup_single_sta(sta);\r\nsta_info_free(local, sta);\r\n}\r\nstruct rhlist_head *sta_info_hash_lookup(struct ieee80211_local *local,\r\nconst u8 *addr)\r\n{\r\nreturn rhltable_lookup(&local->sta_hash, addr, sta_rht_params);\r\n}\r\nstruct sta_info *sta_info_get(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *addr)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct rhlist_head *tmp;\r\nstruct sta_info *sta;\r\nrcu_read_lock();\r\nfor_each_sta_info(local, addr, sta, tmp) {\r\nif (sta->sdata == sdata) {\r\nrcu_read_unlock();\r\nreturn sta;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstruct sta_info *sta_info_get_bss(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *addr)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct rhlist_head *tmp;\r\nstruct sta_info *sta;\r\nrcu_read_lock();\r\nfor_each_sta_info(local, addr, sta, tmp) {\r\nif (sta->sdata == sdata ||\r\n(sta->sdata->bss && sta->sdata->bss == sdata->bss)) {\r\nrcu_read_unlock();\r\nreturn sta;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstruct sta_info *sta_info_get_by_idx(struct ieee80211_sub_if_data *sdata,\r\nint idx)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta;\r\nint i = 0;\r\nlist_for_each_entry_rcu(sta, &local->sta_list, list) {\r\nif (sdata != sta->sdata)\r\ncontinue;\r\nif (i < idx) {\r\n++i;\r\ncontinue;\r\n}\r\nreturn sta;\r\n}\r\nreturn NULL;\r\n}\r\nvoid sta_info_free(struct ieee80211_local *local, struct sta_info *sta)\r\n{\r\nif (sta->rate_ctrl)\r\nrate_control_free_sta(sta);\r\nsta_dbg(sta->sdata, "Destroyed STA %pM\n", sta->sta.addr);\r\nif (sta->sta.txq[0])\r\nkfree(to_txq_info(sta->sta.txq[0]));\r\nkfree(rcu_dereference_raw(sta->sta.rates));\r\n#ifdef CONFIG_MAC80211_MESH\r\nkfree(sta->mesh);\r\n#endif\r\nfree_percpu(sta->pcpu_rx_stats);\r\nkfree(sta);\r\n}\r\nstatic int sta_info_hash_add(struct ieee80211_local *local,\r\nstruct sta_info *sta)\r\n{\r\nreturn rhltable_insert(&local->sta_hash, &sta->hash_node,\r\nsta_rht_params);\r\n}\r\nstatic void sta_deliver_ps_frames(struct work_struct *wk)\r\n{\r\nstruct sta_info *sta;\r\nsta = container_of(wk, struct sta_info, drv_deliver_wk);\r\nif (sta->dead)\r\nreturn;\r\nlocal_bh_disable();\r\nif (!test_sta_flag(sta, WLAN_STA_PS_STA))\r\nieee80211_sta_ps_deliver_wakeup(sta);\r\nelse if (test_and_clear_sta_flag(sta, WLAN_STA_PSPOLL))\r\nieee80211_sta_ps_deliver_poll_response(sta);\r\nelse if (test_and_clear_sta_flag(sta, WLAN_STA_UAPSD))\r\nieee80211_sta_ps_deliver_uapsd(sta);\r\nlocal_bh_enable();\r\n}\r\nstatic int sta_prepare_rate_control(struct ieee80211_local *local,\r\nstruct sta_info *sta, gfp_t gfp)\r\n{\r\nif (ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL))\r\nreturn 0;\r\nsta->rate_ctrl = local->rate_ctrl;\r\nsta->rate_ctrl_priv = rate_control_alloc_sta(sta->rate_ctrl,\r\nsta, gfp);\r\nif (!sta->rate_ctrl_priv)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstruct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *addr, gfp_t gfp)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_hw *hw = &local->hw;\r\nstruct sta_info *sta;\r\nint i;\r\nsta = kzalloc(sizeof(*sta) + hw->sta_data_size, gfp);\r\nif (!sta)\r\nreturn NULL;\r\nif (ieee80211_hw_check(hw, USES_RSS)) {\r\nsta->pcpu_rx_stats =\r\nalloc_percpu(struct ieee80211_sta_rx_stats);\r\nif (!sta->pcpu_rx_stats)\r\ngoto free;\r\n}\r\nspin_lock_init(&sta->lock);\r\nspin_lock_init(&sta->ps_lock);\r\nINIT_WORK(&sta->drv_deliver_wk, sta_deliver_ps_frames);\r\nINIT_WORK(&sta->ampdu_mlme.work, ieee80211_ba_session_work);\r\nmutex_init(&sta->ampdu_mlme.mtx);\r\n#ifdef CONFIG_MAC80211_MESH\r\nif (ieee80211_vif_is_mesh(&sdata->vif)) {\r\nsta->mesh = kzalloc(sizeof(*sta->mesh), gfp);\r\nif (!sta->mesh)\r\ngoto free;\r\nspin_lock_init(&sta->mesh->plink_lock);\r\nif (ieee80211_vif_is_mesh(&sdata->vif) &&\r\n!sdata->u.mesh.user_mpm)\r\ninit_timer(&sta->mesh->plink_timer);\r\nsta->mesh->nonpeer_pm = NL80211_MESH_POWER_ACTIVE;\r\n}\r\n#endif\r\nmemcpy(sta->addr, addr, ETH_ALEN);\r\nmemcpy(sta->sta.addr, addr, ETH_ALEN);\r\nsta->sta.max_rx_aggregation_subframes =\r\nlocal->hw.max_rx_aggregation_subframes;\r\nsta->local = local;\r\nsta->sdata = sdata;\r\nsta->rx_stats.last_rx = jiffies;\r\nu64_stats_init(&sta->rx_stats.syncp);\r\nsta->sta_state = IEEE80211_STA_NONE;\r\nsta->reserved_tid = IEEE80211_TID_UNRESERVED;\r\nsta->last_connected = ktime_get_seconds();\r\newma_signal_init(&sta->rx_stats_avg.signal);\r\nfor (i = 0; i < ARRAY_SIZE(sta->rx_stats_avg.chain_signal); i++)\r\newma_signal_init(&sta->rx_stats_avg.chain_signal[i]);\r\nif (local->ops->wake_tx_queue) {\r\nvoid *txq_data;\r\nint size = sizeof(struct txq_info) +\r\nALIGN(hw->txq_data_size, sizeof(void *));\r\ntxq_data = kcalloc(ARRAY_SIZE(sta->sta.txq), size, gfp);\r\nif (!txq_data)\r\ngoto free;\r\nfor (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {\r\nstruct txq_info *txq = txq_data + i * size;\r\nieee80211_txq_init(sdata, sta, txq, i);\r\n}\r\n}\r\nif (sta_prepare_rate_control(local, sta, gfp))\r\ngoto free_txq;\r\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\r\nsta->timer_to_tid[i] = i;\r\n}\r\nfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\r\nskb_queue_head_init(&sta->ps_tx_buf[i]);\r\nskb_queue_head_init(&sta->tx_filtered[i]);\r\n}\r\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\r\nsta->last_seq_ctrl[i] = cpu_to_le16(USHRT_MAX);\r\nsta->sta.smps_mode = IEEE80211_SMPS_OFF;\r\nif (sdata->vif.type == NL80211_IFTYPE_AP ||\r\nsdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\r\nstruct ieee80211_supported_band *sband;\r\nu8 smps;\r\nsband = ieee80211_get_sband(sdata);\r\nif (!sband)\r\ngoto free_txq;\r\nsmps = (sband->ht_cap.cap & IEEE80211_HT_CAP_SM_PS) >>\r\nIEEE80211_HT_CAP_SM_PS_SHIFT;\r\nswitch (smps) {\r\ncase WLAN_HT_SMPS_CONTROL_DISABLED:\r\nsta->known_smps_mode = IEEE80211_SMPS_OFF;\r\nbreak;\r\ncase WLAN_HT_SMPS_CONTROL_STATIC:\r\nsta->known_smps_mode = IEEE80211_SMPS_STATIC;\r\nbreak;\r\ncase WLAN_HT_SMPS_CONTROL_DYNAMIC:\r\nsta->known_smps_mode = IEEE80211_SMPS_DYNAMIC;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nsta->sta.max_rc_amsdu_len = IEEE80211_MAX_MPDU_LEN_HT_BA;\r\nsta->cparams.ce_threshold = CODEL_DISABLED_THRESHOLD;\r\nsta->cparams.target = MS2TIME(20);\r\nsta->cparams.interval = MS2TIME(100);\r\nsta->cparams.ecn = true;\r\nsta_dbg(sdata, "Allocated STA %pM\n", sta->sta.addr);\r\nreturn sta;\r\nfree_txq:\r\nif (sta->sta.txq[0])\r\nkfree(to_txq_info(sta->sta.txq[0]));\r\nfree:\r\n#ifdef CONFIG_MAC80211_MESH\r\nkfree(sta->mesh);\r\n#endif\r\nkfree(sta);\r\nreturn NULL;\r\n}\r\nstatic int sta_info_insert_check(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nif (unlikely(!ieee80211_sdata_running(sdata)))\r\nreturn -ENETDOWN;\r\nif (WARN_ON(ether_addr_equal(sta->sta.addr, sdata->vif.addr) ||\r\nis_multicast_ether_addr(sta->sta.addr)))\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\nlockdep_assert_held(&sdata->local->sta_mtx);\r\nif (ieee80211_hw_check(&sdata->local->hw, NEEDS_UNIQUE_STA_ADDR) &&\r\nieee80211_find_sta_by_ifaddr(&sdata->local->hw, sta->addr, NULL)) {\r\nrcu_read_unlock();\r\nreturn -ENOTUNIQ;\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int sta_info_insert_drv_state(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta)\r\n{\r\nenum ieee80211_sta_state state;\r\nint err = 0;\r\nfor (state = IEEE80211_STA_NOTEXIST; state < sta->sta_state; state++) {\r\nerr = drv_sta_state(local, sdata, sta, state, state + 1);\r\nif (err)\r\nbreak;\r\n}\r\nif (!err) {\r\nif (!local->ops->sta_add)\r\nsta->uploaded = true;\r\nreturn 0;\r\n}\r\nif (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\r\nsdata_info(sdata,\r\n"failed to move IBSS STA %pM to state %d (%d) - keeping it anyway\n",\r\nsta->sta.addr, state + 1, err);\r\nerr = 0;\r\n}\r\nfor (; state > IEEE80211_STA_NOTEXIST; state--)\r\nWARN_ON(drv_sta_state(local, sdata, sta, state, state - 1));\r\nreturn err;\r\n}\r\nstatic int sta_info_insert_finish(struct sta_info *sta) __acquires(RCU)\r\n{\r\nstruct ieee80211_local *local = sta->local;\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct station_info *sinfo = NULL;\r\nint err = 0;\r\nlockdep_assert_held(&local->sta_mtx);\r\nif (sta_info_get_bss(sdata, sta->sta.addr)) {\r\nerr = -EEXIST;\r\ngoto out_err;\r\n}\r\nsinfo = kzalloc(sizeof(struct station_info), GFP_KERNEL);\r\nif (!sinfo) {\r\nerr = -ENOMEM;\r\ngoto out_err;\r\n}\r\nlocal->num_sta++;\r\nlocal->sta_generation++;\r\nsmp_mb();\r\nset_sta_flag(sta, WLAN_STA_BLOCK_BA);\r\nerr = sta_info_hash_add(local, sta);\r\nif (err)\r\ngoto out_drop_sta;\r\nlist_add_tail_rcu(&sta->list, &local->sta_list);\r\nerr = sta_info_insert_drv_state(local, sdata, sta);\r\nif (err)\r\ngoto out_remove;\r\nset_sta_flag(sta, WLAN_STA_INSERTED);\r\nclear_sta_flag(sta, WLAN_STA_BLOCK_BA);\r\nieee80211_sta_debugfs_add(sta);\r\nrate_control_add_sta_debugfs(sta);\r\nsinfo->generation = local->sta_generation;\r\ncfg80211_new_sta(sdata->dev, sta->sta.addr, sinfo, GFP_KERNEL);\r\nkfree(sinfo);\r\nsta_dbg(sdata, "Inserted STA %pM\n", sta->sta.addr);\r\nrcu_read_lock();\r\nmutex_unlock(&local->sta_mtx);\r\nif (ieee80211_vif_is_mesh(&sdata->vif))\r\nmesh_accept_plinks_update(sdata);\r\nreturn 0;\r\nout_remove:\r\nsta_info_hash_del(local, sta);\r\nlist_del_rcu(&sta->list);\r\nout_drop_sta:\r\nlocal->num_sta--;\r\nsynchronize_net();\r\n__cleanup_single_sta(sta);\r\nout_err:\r\nmutex_unlock(&local->sta_mtx);\r\nkfree(sinfo);\r\nrcu_read_lock();\r\nreturn err;\r\n}\r\nint sta_info_insert_rcu(struct sta_info *sta) __acquires(RCU)\r\n{\r\nstruct ieee80211_local *local = sta->local;\r\nint err;\r\nmight_sleep();\r\nmutex_lock(&local->sta_mtx);\r\nerr = sta_info_insert_check(sta);\r\nif (err) {\r\nmutex_unlock(&local->sta_mtx);\r\nrcu_read_lock();\r\ngoto out_free;\r\n}\r\nerr = sta_info_insert_finish(sta);\r\nif (err)\r\ngoto out_free;\r\nreturn 0;\r\nout_free:\r\nsta_info_free(local, sta);\r\nreturn err;\r\n}\r\nint sta_info_insert(struct sta_info *sta)\r\n{\r\nint err = sta_info_insert_rcu(sta);\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic inline void __bss_tim_set(u8 *tim, u16 id)\r\n{\r\ntim[id / 8] |= (1 << (id % 8));\r\n}\r\nstatic inline void __bss_tim_clear(u8 *tim, u16 id)\r\n{\r\ntim[id / 8] &= ~(1 << (id % 8));\r\n}\r\nstatic inline bool __bss_tim_get(u8 *tim, u16 id)\r\n{\r\nreturn tim[id / 8] & (1 << (id % 8));\r\n}\r\nstatic unsigned long ieee80211_tids_for_ac(int ac)\r\n{\r\nswitch (ac) {\r\ncase IEEE80211_AC_VO:\r\nreturn BIT(6) | BIT(7);\r\ncase IEEE80211_AC_VI:\r\nreturn BIT(4) | BIT(5);\r\ncase IEEE80211_AC_BE:\r\nreturn BIT(0) | BIT(3);\r\ncase IEEE80211_AC_BK:\r\nreturn BIT(1) | BIT(2);\r\ndefault:\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\n}\r\nstatic void __sta_info_recalc_tim(struct sta_info *sta, bool ignore_pending)\r\n{\r\nstruct ieee80211_local *local = sta->local;\r\nstruct ps_data *ps;\r\nbool indicate_tim = false;\r\nu8 ignore_for_tim = sta->sta.uapsd_queues;\r\nint ac;\r\nu16 id = sta->sta.aid;\r\nif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\r\nsta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\r\nif (WARN_ON_ONCE(!sta->sdata->bss))\r\nreturn;\r\nps = &sta->sdata->bss->ps;\r\n#ifdef CONFIG_MAC80211_MESH\r\n} else if (ieee80211_vif_is_mesh(&sta->sdata->vif)) {\r\nps = &sta->sdata->u.mesh.ps;\r\n#endif\r\n} else {\r\nreturn;\r\n}\r\nif (ieee80211_hw_check(&local->hw, AP_LINK_PS) && !local->ops->set_tim)\r\nreturn;\r\nif (sta->dead)\r\ngoto done;\r\nif (ignore_for_tim == BIT(IEEE80211_NUM_ACS) - 1)\r\nignore_for_tim = 0;\r\nif (ignore_pending)\r\nignore_for_tim = BIT(IEEE80211_NUM_ACS) - 1;\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\r\nunsigned long tids;\r\nif (ignore_for_tim & ieee80211_ac_to_qos_mask[ac])\r\ncontinue;\r\nindicate_tim |= !skb_queue_empty(&sta->tx_filtered[ac]) ||\r\n!skb_queue_empty(&sta->ps_tx_buf[ac]);\r\nif (indicate_tim)\r\nbreak;\r\ntids = ieee80211_tids_for_ac(ac);\r\nindicate_tim |=\r\nsta->driver_buffered_tids & tids;\r\nindicate_tim |=\r\nsta->txq_buffered_tids & tids;\r\n}\r\ndone:\r\nspin_lock_bh(&local->tim_lock);\r\nif (indicate_tim == __bss_tim_get(ps->tim, id))\r\ngoto out_unlock;\r\nif (indicate_tim)\r\n__bss_tim_set(ps->tim, id);\r\nelse\r\n__bss_tim_clear(ps->tim, id);\r\nif (local->ops->set_tim && !WARN_ON(sta->dead)) {\r\nlocal->tim_in_locked_section = true;\r\ndrv_set_tim(local, &sta->sta, indicate_tim);\r\nlocal->tim_in_locked_section = false;\r\n}\r\nout_unlock:\r\nspin_unlock_bh(&local->tim_lock);\r\n}\r\nvoid sta_info_recalc_tim(struct sta_info *sta)\r\n{\r\n__sta_info_recalc_tim(sta, false);\r\n}\r\nstatic bool sta_info_buffer_expired(struct sta_info *sta, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_tx_info *info;\r\nint timeout;\r\nif (!skb)\r\nreturn false;\r\ninfo = IEEE80211_SKB_CB(skb);\r\ntimeout = (sta->listen_interval *\r\nsta->sdata->vif.bss_conf.beacon_int *\r\n32 / 15625) * HZ;\r\nif (timeout < STA_TX_BUFFER_EXPIRE)\r\ntimeout = STA_TX_BUFFER_EXPIRE;\r\nreturn time_after(jiffies, info->control.jiffies + timeout);\r\n}\r\nstatic bool sta_info_cleanup_expire_buffered_ac(struct ieee80211_local *local,\r\nstruct sta_info *sta, int ac)\r\n{\r\nunsigned long flags;\r\nstruct sk_buff *skb;\r\nfor (;;) {\r\nspin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);\r\nskb = skb_peek(&sta->tx_filtered[ac]);\r\nif (sta_info_buffer_expired(sta, skb))\r\nskb = __skb_dequeue(&sta->tx_filtered[ac]);\r\nelse\r\nskb = NULL;\r\nspin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);\r\nif (!skb)\r\nbreak;\r\nieee80211_free_txskb(&local->hw, skb);\r\n}\r\nfor (;;) {\r\nspin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);\r\nskb = skb_peek(&sta->ps_tx_buf[ac]);\r\nif (sta_info_buffer_expired(sta, skb))\r\nskb = __skb_dequeue(&sta->ps_tx_buf[ac]);\r\nelse\r\nskb = NULL;\r\nspin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);\r\nif (!skb)\r\nbreak;\r\nlocal->total_ps_buffered--;\r\nps_dbg(sta->sdata, "Buffered frame expired (STA %pM)\n",\r\nsta->sta.addr);\r\nieee80211_free_txskb(&local->hw, skb);\r\n}\r\nsta_info_recalc_tim(sta);\r\nreturn !(skb_queue_empty(&sta->ps_tx_buf[ac]) &&\r\nskb_queue_empty(&sta->tx_filtered[ac]));\r\n}\r\nstatic bool sta_info_cleanup_expire_buffered(struct ieee80211_local *local,\r\nstruct sta_info *sta)\r\n{\r\nbool have_buffered = false;\r\nint ac;\r\nif (!sta->sdata->bss &&\r\n!ieee80211_vif_is_mesh(&sta->sdata->vif))\r\nreturn false;\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\r\nhave_buffered |=\r\nsta_info_cleanup_expire_buffered_ac(local, sta, ac);\r\nreturn have_buffered;\r\n}\r\nstatic int __must_check __sta_info_destroy_part1(struct sta_info *sta)\r\n{\r\nstruct ieee80211_local *local;\r\nstruct ieee80211_sub_if_data *sdata;\r\nint ret;\r\nmight_sleep();\r\nif (!sta)\r\nreturn -ENOENT;\r\nlocal = sta->local;\r\nsdata = sta->sdata;\r\nlockdep_assert_held(&local->sta_mtx);\r\nset_sta_flag(sta, WLAN_STA_BLOCK_BA);\r\nieee80211_sta_tear_down_BA_sessions(sta, AGG_STOP_DESTROY_STA);\r\ndrv_sync_rx_queues(local, sta);\r\nret = sta_info_hash_del(local, sta);\r\nif (WARN_ON(ret))\r\nreturn ret;\r\nif (test_sta_flag(sta, WLAN_STA_TDLS_OFF_CHANNEL)) {\r\ndrv_tdls_cancel_channel_switch(local, sdata, &sta->sta);\r\nclear_sta_flag(sta, WLAN_STA_TDLS_OFF_CHANNEL);\r\n}\r\nlist_del_rcu(&sta->list);\r\nsta->removed = true;\r\ndrv_sta_pre_rcu_remove(local, sta->sdata, sta);\r\nif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\r\nrcu_access_pointer(sdata->u.vlan.sta) == sta)\r\nRCU_INIT_POINTER(sdata->u.vlan.sta, NULL);\r\nreturn 0;\r\n}\r\nstatic void __sta_info_destroy_part2(struct sta_info *sta)\r\n{\r\nstruct ieee80211_local *local = sta->local;\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct station_info *sinfo;\r\nint ret;\r\nmight_sleep();\r\nlockdep_assert_held(&local->sta_mtx);\r\nieee80211_free_sta_keys(local, sta);\r\n__sta_info_recalc_tim(sta, true);\r\nsta->dead = true;\r\nlocal->num_sta--;\r\nlocal->sta_generation++;\r\nwhile (sta->sta_state > IEEE80211_STA_NONE) {\r\nret = sta_info_move_state(sta, sta->sta_state - 1);\r\nif (ret) {\r\nWARN_ON_ONCE(1);\r\nbreak;\r\n}\r\n}\r\nif (sta->uploaded) {\r\nret = drv_sta_state(local, sdata, sta, IEEE80211_STA_NONE,\r\nIEEE80211_STA_NOTEXIST);\r\nWARN_ON_ONCE(ret != 0);\r\n}\r\nsta_dbg(sdata, "Removed STA %pM\n", sta->sta.addr);\r\nsinfo = kzalloc(sizeof(*sinfo), GFP_KERNEL);\r\nif (sinfo)\r\nsta_set_sinfo(sta, sinfo);\r\ncfg80211_del_sta_sinfo(sdata->dev, sta->sta.addr, sinfo, GFP_KERNEL);\r\nkfree(sinfo);\r\nrate_control_remove_sta_debugfs(sta);\r\nieee80211_sta_debugfs_remove(sta);\r\ncleanup_single_sta(sta);\r\n}\r\nint __must_check __sta_info_destroy(struct sta_info *sta)\r\n{\r\nint err = __sta_info_destroy_part1(sta);\r\nif (err)\r\nreturn err;\r\nsynchronize_net();\r\n__sta_info_destroy_part2(sta);\r\nreturn 0;\r\n}\r\nint sta_info_destroy_addr(struct ieee80211_sub_if_data *sdata, const u8 *addr)\r\n{\r\nstruct sta_info *sta;\r\nint ret;\r\nmutex_lock(&sdata->local->sta_mtx);\r\nsta = sta_info_get(sdata, addr);\r\nret = __sta_info_destroy(sta);\r\nmutex_unlock(&sdata->local->sta_mtx);\r\nreturn ret;\r\n}\r\nint sta_info_destroy_addr_bss(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *addr)\r\n{\r\nstruct sta_info *sta;\r\nint ret;\r\nmutex_lock(&sdata->local->sta_mtx);\r\nsta = sta_info_get_bss(sdata, addr);\r\nret = __sta_info_destroy(sta);\r\nmutex_unlock(&sdata->local->sta_mtx);\r\nreturn ret;\r\n}\r\nstatic void sta_info_cleanup(unsigned long data)\r\n{\r\nstruct ieee80211_local *local = (struct ieee80211_local *) data;\r\nstruct sta_info *sta;\r\nbool timer_needed = false;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(sta, &local->sta_list, list)\r\nif (sta_info_cleanup_expire_buffered(local, sta))\r\ntimer_needed = true;\r\nrcu_read_unlock();\r\nif (local->quiescing)\r\nreturn;\r\nif (!timer_needed)\r\nreturn;\r\nmod_timer(&local->sta_cleanup,\r\nround_jiffies(jiffies + STA_INFO_CLEANUP_INTERVAL));\r\n}\r\nint sta_info_init(struct ieee80211_local *local)\r\n{\r\nint err;\r\nerr = rhltable_init(&local->sta_hash, &sta_rht_params);\r\nif (err)\r\nreturn err;\r\nspin_lock_init(&local->tim_lock);\r\nmutex_init(&local->sta_mtx);\r\nINIT_LIST_HEAD(&local->sta_list);\r\nsetup_timer(&local->sta_cleanup, sta_info_cleanup,\r\n(unsigned long)local);\r\nreturn 0;\r\n}\r\nvoid sta_info_stop(struct ieee80211_local *local)\r\n{\r\ndel_timer_sync(&local->sta_cleanup);\r\nrhltable_destroy(&local->sta_hash);\r\n}\r\nint __sta_info_flush(struct ieee80211_sub_if_data *sdata, bool vlans)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta, *tmp;\r\nLIST_HEAD(free_list);\r\nint ret = 0;\r\nmight_sleep();\r\nWARN_ON(vlans && sdata->vif.type != NL80211_IFTYPE_AP);\r\nWARN_ON(vlans && !sdata->bss);\r\nmutex_lock(&local->sta_mtx);\r\nlist_for_each_entry_safe(sta, tmp, &local->sta_list, list) {\r\nif (sdata == sta->sdata ||\r\n(vlans && sdata->bss == sta->sdata->bss)) {\r\nif (!WARN_ON(__sta_info_destroy_part1(sta)))\r\nlist_add(&sta->free_list, &free_list);\r\nret++;\r\n}\r\n}\r\nif (!list_empty(&free_list)) {\r\nsynchronize_net();\r\nlist_for_each_entry_safe(sta, tmp, &free_list, free_list)\r\n__sta_info_destroy_part2(sta);\r\n}\r\nmutex_unlock(&local->sta_mtx);\r\nreturn ret;\r\n}\r\nvoid ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,\r\nunsigned long exp_time)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta, *tmp;\r\nmutex_lock(&local->sta_mtx);\r\nlist_for_each_entry_safe(sta, tmp, &local->sta_list, list) {\r\nunsigned long last_active = ieee80211_sta_last_active(sta);\r\nif (sdata != sta->sdata)\r\ncontinue;\r\nif (time_is_before_jiffies(last_active + exp_time)) {\r\nsta_dbg(sta->sdata, "expiring inactive STA %pM\n",\r\nsta->sta.addr);\r\nif (ieee80211_vif_is_mesh(&sdata->vif) &&\r\ntest_sta_flag(sta, WLAN_STA_PS_STA))\r\natomic_dec(&sdata->u.mesh.ps.num_sta_ps);\r\nWARN_ON(__sta_info_destroy(sta));\r\n}\r\n}\r\nmutex_unlock(&local->sta_mtx);\r\n}\r\nstruct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,\r\nconst u8 *addr,\r\nconst u8 *localaddr)\r\n{\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\nstruct rhlist_head *tmp;\r\nstruct sta_info *sta;\r\nfor_each_sta_info(local, addr, sta, tmp) {\r\nif (localaddr &&\r\n!ether_addr_equal(sta->sdata->vif.addr, localaddr))\r\ncontinue;\r\nif (!sta->uploaded)\r\nreturn NULL;\r\nreturn &sta->sta;\r\n}\r\nreturn NULL;\r\n}\r\nstruct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,\r\nconst u8 *addr)\r\n{\r\nstruct sta_info *sta;\r\nif (!vif)\r\nreturn NULL;\r\nsta = sta_info_get_bss(vif_to_sdata(vif), addr);\r\nif (!sta)\r\nreturn NULL;\r\nif (!sta->uploaded)\r\nreturn NULL;\r\nreturn &sta->sta;\r\n}\r\nvoid ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sk_buff_head pending;\r\nint filtered = 0, buffered = 0, ac, i;\r\nunsigned long flags;\r\nstruct ps_data *ps;\r\nif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\r\nsdata = container_of(sdata->bss, struct ieee80211_sub_if_data,\r\nu.ap);\r\nif (sdata->vif.type == NL80211_IFTYPE_AP)\r\nps = &sdata->bss->ps;\r\nelse if (ieee80211_vif_is_mesh(&sdata->vif))\r\nps = &sdata->u.mesh.ps;\r\nelse\r\nreturn;\r\nclear_sta_flag(sta, WLAN_STA_SP);\r\nBUILD_BUG_ON(BITS_TO_LONGS(IEEE80211_NUM_TIDS) > 1);\r\nsta->driver_buffered_tids = 0;\r\nsta->txq_buffered_tids = 0;\r\nif (!ieee80211_hw_check(&local->hw, AP_LINK_PS))\r\ndrv_sta_notify(local, sdata, STA_NOTIFY_AWAKE, &sta->sta);\r\nif (sta->sta.txq[0]) {\r\nfor (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {\r\nif (!txq_has_queue(sta->sta.txq[i]))\r\ncontinue;\r\ndrv_wake_tx_queue(local, to_txq_info(sta->sta.txq[i]));\r\n}\r\n}\r\nskb_queue_head_init(&pending);\r\nspin_lock(&sta->ps_lock);\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\r\nint count = skb_queue_len(&pending), tmp;\r\nspin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);\r\nskb_queue_splice_tail_init(&sta->tx_filtered[ac], &pending);\r\nspin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);\r\ntmp = skb_queue_len(&pending);\r\nfiltered += tmp - count;\r\ncount = tmp;\r\nspin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);\r\nskb_queue_splice_tail_init(&sta->ps_tx_buf[ac], &pending);\r\nspin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);\r\ntmp = skb_queue_len(&pending);\r\nbuffered += tmp - count;\r\n}\r\nieee80211_add_pending_skbs(local, &pending);\r\nclear_sta_flag(sta, WLAN_STA_PS_DELIVER);\r\nclear_sta_flag(sta, WLAN_STA_PSPOLL);\r\nclear_sta_flag(sta, WLAN_STA_UAPSD);\r\nspin_unlock(&sta->ps_lock);\r\natomic_dec(&ps->num_sta_ps);\r\nif (!ieee80211_vif_is_mesh(&sdata->vif) &&\r\n!ieee80211_smps_is_restrictive(sta->known_smps_mode,\r\nsdata->smps_mode) &&\r\nsta->known_smps_mode != sdata->bss->req_smps &&\r\nsta_info_tx_streams(sta) != 1) {\r\nht_dbg(sdata,\r\n"%pM just woke up and MIMO capable - update SMPS\n",\r\nsta->sta.addr);\r\nieee80211_send_smps_action(sdata, sdata->bss->req_smps,\r\nsta->sta.addr,\r\nsdata->vif.bss_conf.bssid);\r\n}\r\nlocal->total_ps_buffered -= buffered;\r\nsta_info_recalc_tim(sta);\r\nps_dbg(sdata,\r\n"STA %pM aid %d sending %d filtered/%d PS frames since STA woke up\n",\r\nsta->sta.addr, sta->sta.aid, filtered, buffered);\r\nieee80211_check_fast_xmit(sta);\r\n}\r\nstatic void ieee80211_send_null_response(struct sta_info *sta, int tid,\r\nenum ieee80211_frame_release_type reason,\r\nbool call_driver, bool more_data)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_qos_hdr *nullfunc;\r\nstruct sk_buff *skb;\r\nint size = sizeof(*nullfunc);\r\n__le16 fc;\r\nbool qos = sta->sta.wme;\r\nstruct ieee80211_tx_info *info;\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nif (qos) {\r\nfc = cpu_to_le16(IEEE80211_FTYPE_DATA |\r\nIEEE80211_STYPE_QOS_NULLFUNC |\r\nIEEE80211_FCTL_FROMDS);\r\n} else {\r\nsize -= 2;\r\nfc = cpu_to_le16(IEEE80211_FTYPE_DATA |\r\nIEEE80211_STYPE_NULLFUNC |\r\nIEEE80211_FCTL_FROMDS);\r\n}\r\nskb = dev_alloc_skb(local->hw.extra_tx_headroom + size);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, local->hw.extra_tx_headroom);\r\nnullfunc = skb_put(skb, size);\r\nnullfunc->frame_control = fc;\r\nnullfunc->duration_id = 0;\r\nmemcpy(nullfunc->addr1, sta->sta.addr, ETH_ALEN);\r\nmemcpy(nullfunc->addr2, sdata->vif.addr, ETH_ALEN);\r\nmemcpy(nullfunc->addr3, sdata->vif.addr, ETH_ALEN);\r\nnullfunc->seq_ctrl = 0;\r\nskb->priority = tid;\r\nskb_set_queue_mapping(skb, ieee802_1d_to_ac[tid]);\r\nif (qos) {\r\nnullfunc->qos_ctrl = cpu_to_le16(tid);\r\nif (reason == IEEE80211_FRAME_RELEASE_UAPSD) {\r\nnullfunc->qos_ctrl |=\r\ncpu_to_le16(IEEE80211_QOS_CTL_EOSP);\r\nif (more_data)\r\nnullfunc->frame_control |=\r\ncpu_to_le16(IEEE80211_FCTL_MOREDATA);\r\n}\r\n}\r\ninfo = IEEE80211_SKB_CB(skb);\r\ninfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER |\r\nIEEE80211_TX_STATUS_EOSP |\r\nIEEE80211_TX_CTL_REQ_TX_STATUS;\r\ninfo->control.flags |= IEEE80211_TX_CTRL_PS_RESPONSE;\r\nif (call_driver)\r\ndrv_allow_buffered_frames(local, sta, BIT(tid), 1,\r\nreason, false);\r\nskb->dev = sdata->dev;\r\nrcu_read_lock();\r\nchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\r\nif (WARN_ON(!chanctx_conf)) {\r\nrcu_read_unlock();\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\ninfo->band = chanctx_conf->def.chan->band;\r\nieee80211_xmit(sdata, sta, skb);\r\nrcu_read_unlock();\r\n}\r\nstatic int find_highest_prio_tid(unsigned long tids)\r\n{\r\nif (tids & 0xF8)\r\nreturn fls(tids) - 1;\r\nif (tids & BIT(0))\r\nreturn 0;\r\nreturn fls(tids) - 1;\r\n}\r\nstatic bool\r\nieee80211_sta_ps_more_data(struct sta_info *sta, u8 ignored_acs,\r\nenum ieee80211_frame_release_type reason,\r\nunsigned long driver_release_tids)\r\n{\r\nint ac;\r\nif (reason == IEEE80211_FRAME_RELEASE_PSPOLL &&\r\nhweight16(driver_release_tids) > 1)\r\nreturn true;\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\r\nif (ignored_acs & ieee80211_ac_to_qos_mask[ac])\r\ncontinue;\r\nif (!skb_queue_empty(&sta->tx_filtered[ac]) ||\r\n!skb_queue_empty(&sta->ps_tx_buf[ac]))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void\r\nieee80211_sta_ps_get_frames(struct sta_info *sta, int n_frames, u8 ignored_acs,\r\nenum ieee80211_frame_release_type reason,\r\nstruct sk_buff_head *frames,\r\nunsigned long *driver_release_tids)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct ieee80211_local *local = sdata->local;\r\nint ac;\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\r\nunsigned long tids;\r\nif (ignored_acs & ieee80211_ac_to_qos_mask[ac])\r\ncontinue;\r\ntids = ieee80211_tids_for_ac(ac);\r\nif (skb_queue_empty(frames)) {\r\n*driver_release_tids |=\r\nsta->driver_buffered_tids & tids;\r\n*driver_release_tids |= sta->txq_buffered_tids & tids;\r\n}\r\nif (!*driver_release_tids) {\r\nstruct sk_buff *skb;\r\nwhile (n_frames > 0) {\r\nskb = skb_dequeue(&sta->tx_filtered[ac]);\r\nif (!skb) {\r\nskb = skb_dequeue(\r\n&sta->ps_tx_buf[ac]);\r\nif (skb)\r\nlocal->total_ps_buffered--;\r\n}\r\nif (!skb)\r\nbreak;\r\nn_frames--;\r\n__skb_queue_tail(frames, skb);\r\n}\r\n}\r\nif (!skb_queue_empty(&sta->tx_filtered[ac]) ||\r\n!skb_queue_empty(&sta->ps_tx_buf[ac]))\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nieee80211_sta_ps_deliver_response(struct sta_info *sta,\r\nint n_frames, u8 ignored_acs,\r\nenum ieee80211_frame_release_type reason)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct ieee80211_local *local = sdata->local;\r\nunsigned long driver_release_tids = 0;\r\nstruct sk_buff_head frames;\r\nbool more_data;\r\nset_sta_flag(sta, WLAN_STA_SP);\r\n__skb_queue_head_init(&frames);\r\nieee80211_sta_ps_get_frames(sta, n_frames, ignored_acs, reason,\r\n&frames, &driver_release_tids);\r\nmore_data = ieee80211_sta_ps_more_data(sta, ignored_acs, reason, driver_release_tids);\r\nif (driver_release_tids && reason == IEEE80211_FRAME_RELEASE_PSPOLL)\r\ndriver_release_tids =\r\nBIT(find_highest_prio_tid(driver_release_tids));\r\nif (skb_queue_empty(&frames) && !driver_release_tids) {\r\nint tid, ac;\r\nfor (ac = IEEE80211_AC_VO; ac < IEEE80211_NUM_ACS; ac++)\r\nif (!(ignored_acs & ieee80211_ac_to_qos_mask[ac]))\r\nbreak;\r\ntid = 7 - 2 * ac;\r\nieee80211_send_null_response(sta, tid, reason, true, false);\r\n} else if (!driver_release_tids) {\r\nstruct sk_buff_head pending;\r\nstruct sk_buff *skb;\r\nint num = 0;\r\nu16 tids = 0;\r\nbool need_null = false;\r\nskb_queue_head_init(&pending);\r\nwhile ((skb = __skb_dequeue(&frames))) {\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr = (void *) skb->data;\r\nu8 *qoshdr = NULL;\r\nnum++;\r\ninfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER;\r\ninfo->control.flags |= IEEE80211_TX_CTRL_PS_RESPONSE;\r\nif (more_data || !skb_queue_empty(&frames))\r\nhdr->frame_control |=\r\ncpu_to_le16(IEEE80211_FCTL_MOREDATA);\r\nelse\r\nhdr->frame_control &=\r\ncpu_to_le16(~IEEE80211_FCTL_MOREDATA);\r\nif (ieee80211_is_data_qos(hdr->frame_control) ||\r\nieee80211_is_qos_nullfunc(hdr->frame_control))\r\nqoshdr = ieee80211_get_qos_ctl(hdr);\r\ntids |= BIT(skb->priority);\r\n__skb_queue_tail(&pending, skb);\r\nif (!skb_queue_empty(&frames))\r\ncontinue;\r\nif (reason != IEEE80211_FRAME_RELEASE_UAPSD) {\r\ninfo->flags |= IEEE80211_TX_STATUS_EOSP |\r\nIEEE80211_TX_CTL_REQ_TX_STATUS;\r\nbreak;\r\n}\r\nif (qoshdr) {\r\n*qoshdr |= IEEE80211_QOS_CTL_EOSP;\r\ninfo->flags |= IEEE80211_TX_STATUS_EOSP |\r\nIEEE80211_TX_CTL_REQ_TX_STATUS;\r\n} else {\r\nhdr->frame_control |=\r\ncpu_to_le16(IEEE80211_FCTL_MOREDATA);\r\nneed_null = true;\r\nnum++;\r\n}\r\nbreak;\r\n}\r\ndrv_allow_buffered_frames(local, sta, tids, num,\r\nreason, more_data);\r\nieee80211_add_pending_skbs(local, &pending);\r\nif (need_null)\r\nieee80211_send_null_response(\r\nsta, find_highest_prio_tid(tids),\r\nreason, false, false);\r\nsta_info_recalc_tim(sta);\r\n} else {\r\nint tid;\r\ndrv_release_buffered_frames(local, sta, driver_release_tids,\r\nn_frames, reason, more_data);\r\nif (!sta->sta.txq[0])\r\nreturn;\r\nfor (tid = 0; tid < ARRAY_SIZE(sta->sta.txq); tid++) {\r\nif (!(driver_release_tids & BIT(tid)) ||\r\ntxq_has_queue(sta->sta.txq[tid]))\r\ncontinue;\r\nsta_info_recalc_tim(sta);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid ieee80211_sta_ps_deliver_poll_response(struct sta_info *sta)\r\n{\r\nu8 ignore_for_response = sta->sta.uapsd_queues;\r\nif (ignore_for_response == BIT(IEEE80211_NUM_ACS) - 1)\r\nignore_for_response = 0;\r\nieee80211_sta_ps_deliver_response(sta, 1, ignore_for_response,\r\nIEEE80211_FRAME_RELEASE_PSPOLL);\r\n}\r\nvoid ieee80211_sta_ps_deliver_uapsd(struct sta_info *sta)\r\n{\r\nint n_frames = sta->sta.max_sp;\r\nu8 delivery_enabled = sta->sta.uapsd_queues;\r\nif (!delivery_enabled)\r\nreturn;\r\nswitch (sta->sta.max_sp) {\r\ncase 1:\r\nn_frames = 2;\r\nbreak;\r\ncase 2:\r\nn_frames = 4;\r\nbreak;\r\ncase 3:\r\nn_frames = 6;\r\nbreak;\r\ncase 0:\r\nn_frames = 128;\r\nbreak;\r\n}\r\nieee80211_sta_ps_deliver_response(sta, n_frames, ~delivery_enabled,\r\nIEEE80211_FRAME_RELEASE_UAPSD);\r\n}\r\nvoid ieee80211_sta_block_awake(struct ieee80211_hw *hw,\r\nstruct ieee80211_sta *pubsta, bool block)\r\n{\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\ntrace_api_sta_block_awake(sta->local, pubsta, block);\r\nif (block) {\r\nset_sta_flag(sta, WLAN_STA_PS_DRIVER);\r\nieee80211_clear_fast_xmit(sta);\r\nreturn;\r\n}\r\nif (!test_sta_flag(sta, WLAN_STA_PS_DRIVER))\r\nreturn;\r\nif (!test_sta_flag(sta, WLAN_STA_PS_STA)) {\r\nset_sta_flag(sta, WLAN_STA_PS_DELIVER);\r\nclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\r\nieee80211_queue_work(hw, &sta->drv_deliver_wk);\r\n} else if (test_sta_flag(sta, WLAN_STA_PSPOLL) ||\r\ntest_sta_flag(sta, WLAN_STA_UAPSD)) {\r\nclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\r\nieee80211_queue_work(hw, &sta->drv_deliver_wk);\r\n} else {\r\nclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\r\nieee80211_check_fast_xmit(sta);\r\n}\r\n}\r\nvoid ieee80211_sta_eosp(struct ieee80211_sta *pubsta)\r\n{\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\nstruct ieee80211_local *local = sta->local;\r\ntrace_api_eosp(local, pubsta);\r\nclear_sta_flag(sta, WLAN_STA_SP);\r\n}\r\nvoid ieee80211_send_eosp_nullfunc(struct ieee80211_sta *pubsta, int tid)\r\n{\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\nenum ieee80211_frame_release_type reason;\r\nbool more_data;\r\ntrace_api_send_eosp_nullfunc(sta->local, pubsta, tid);\r\nreason = IEEE80211_FRAME_RELEASE_UAPSD;\r\nmore_data = ieee80211_sta_ps_more_data(sta, ~sta->sta.uapsd_queues,\r\nreason, 0);\r\nieee80211_send_null_response(sta, tid, reason, false, more_data);\r\n}\r\nvoid ieee80211_sta_set_buffered(struct ieee80211_sta *pubsta,\r\nu8 tid, bool buffered)\r\n{\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\nif (WARN_ON(tid >= IEEE80211_NUM_TIDS))\r\nreturn;\r\ntrace_api_sta_set_buffered(sta->local, pubsta, tid, buffered);\r\nif (buffered)\r\nset_bit(tid, &sta->driver_buffered_tids);\r\nelse\r\nclear_bit(tid, &sta->driver_buffered_tids);\r\nsta_info_recalc_tim(sta);\r\n}\r\nstatic void\r\nieee80211_recalc_p2p_go_ps_allowed(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nbool allow_p2p_go_ps = sdata->vif.p2p;\r\nstruct sta_info *sta;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(sta, &local->sta_list, list) {\r\nif (sdata != sta->sdata ||\r\n!test_sta_flag(sta, WLAN_STA_ASSOC))\r\ncontinue;\r\nif (!sta->sta.support_p2p_ps) {\r\nallow_p2p_go_ps = false;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (allow_p2p_go_ps != sdata->vif.bss_conf.allow_p2p_go_ps) {\r\nsdata->vif.bss_conf.allow_p2p_go_ps = allow_p2p_go_ps;\r\nieee80211_bss_info_change_notify(sdata, BSS_CHANGED_P2P_PS);\r\n}\r\n}\r\nint sta_info_move_state(struct sta_info *sta,\r\nenum ieee80211_sta_state new_state)\r\n{\r\nmight_sleep();\r\nif (sta->sta_state == new_state)\r\nreturn 0;\r\nswitch (new_state) {\r\ncase IEEE80211_STA_NONE:\r\nif (sta->sta_state != IEEE80211_STA_AUTH)\r\nreturn -EINVAL;\r\nbreak;\r\ncase IEEE80211_STA_AUTH:\r\nif (sta->sta_state != IEEE80211_STA_NONE &&\r\nsta->sta_state != IEEE80211_STA_ASSOC)\r\nreturn -EINVAL;\r\nbreak;\r\ncase IEEE80211_STA_ASSOC:\r\nif (sta->sta_state != IEEE80211_STA_AUTH &&\r\nsta->sta_state != IEEE80211_STA_AUTHORIZED)\r\nreturn -EINVAL;\r\nbreak;\r\ncase IEEE80211_STA_AUTHORIZED:\r\nif (sta->sta_state != IEEE80211_STA_ASSOC)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nWARN(1, "invalid state %d", new_state);\r\nreturn -EINVAL;\r\n}\r\nsta_dbg(sta->sdata, "moving STA %pM to state %d\n",\r\nsta->sta.addr, new_state);\r\nif (test_sta_flag(sta, WLAN_STA_INSERTED)) {\r\nint err = drv_sta_state(sta->local, sta->sdata, sta,\r\nsta->sta_state, new_state);\r\nif (err)\r\nreturn err;\r\n}\r\nswitch (new_state) {\r\ncase IEEE80211_STA_NONE:\r\nif (sta->sta_state == IEEE80211_STA_AUTH)\r\nclear_bit(WLAN_STA_AUTH, &sta->_flags);\r\nbreak;\r\ncase IEEE80211_STA_AUTH:\r\nif (sta->sta_state == IEEE80211_STA_NONE) {\r\nset_bit(WLAN_STA_AUTH, &sta->_flags);\r\n} else if (sta->sta_state == IEEE80211_STA_ASSOC) {\r\nclear_bit(WLAN_STA_ASSOC, &sta->_flags);\r\nieee80211_recalc_min_chandef(sta->sdata);\r\nif (!sta->sta.support_p2p_ps)\r\nieee80211_recalc_p2p_go_ps_allowed(sta->sdata);\r\n}\r\nbreak;\r\ncase IEEE80211_STA_ASSOC:\r\nif (sta->sta_state == IEEE80211_STA_AUTH) {\r\nset_bit(WLAN_STA_ASSOC, &sta->_flags);\r\nieee80211_recalc_min_chandef(sta->sdata);\r\nif (!sta->sta.support_p2p_ps)\r\nieee80211_recalc_p2p_go_ps_allowed(sta->sdata);\r\n} else if (sta->sta_state == IEEE80211_STA_AUTHORIZED) {\r\nieee80211_vif_dec_num_mcast(sta->sdata);\r\nclear_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\r\nieee80211_clear_fast_xmit(sta);\r\nieee80211_clear_fast_rx(sta);\r\n}\r\nbreak;\r\ncase IEEE80211_STA_AUTHORIZED:\r\nif (sta->sta_state == IEEE80211_STA_ASSOC) {\r\nieee80211_vif_inc_num_mcast(sta->sdata);\r\nset_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\r\nieee80211_check_fast_xmit(sta);\r\nieee80211_check_fast_rx(sta);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsta->sta_state = new_state;\r\nreturn 0;\r\n}\r\nu8 sta_info_tx_streams(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sta_ht_cap *ht_cap = &sta->sta.ht_cap;\r\nu8 rx_streams;\r\nif (!sta->sta.ht_cap.ht_supported)\r\nreturn 1;\r\nif (sta->sta.vht_cap.vht_supported) {\r\nint i;\r\nu16 tx_mcs_map =\r\nle16_to_cpu(sta->sta.vht_cap.vht_mcs.tx_mcs_map);\r\nfor (i = 7; i >= 0; i--)\r\nif ((tx_mcs_map & (0x3 << (i * 2))) !=\r\nIEEE80211_VHT_MCS_NOT_SUPPORTED)\r\nreturn i + 1;\r\n}\r\nif (ht_cap->mcs.rx_mask[3])\r\nrx_streams = 4;\r\nelse if (ht_cap->mcs.rx_mask[2])\r\nrx_streams = 3;\r\nelse if (ht_cap->mcs.rx_mask[1])\r\nrx_streams = 2;\r\nelse\r\nrx_streams = 1;\r\nif (!(ht_cap->mcs.tx_params & IEEE80211_HT_MCS_TX_RX_DIFF))\r\nreturn rx_streams;\r\nreturn ((ht_cap->mcs.tx_params & IEEE80211_HT_MCS_TX_MAX_STREAMS_MASK)\r\n>> IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT) + 1;\r\n}\r\nstatic struct ieee80211_sta_rx_stats *\r\nsta_get_last_rx_stats(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sta_rx_stats *stats = &sta->rx_stats;\r\nstruct ieee80211_local *local = sta->local;\r\nint cpu;\r\nif (!ieee80211_hw_check(&local->hw, USES_RSS))\r\nreturn stats;\r\nfor_each_possible_cpu(cpu) {\r\nstruct ieee80211_sta_rx_stats *cpustats;\r\ncpustats = per_cpu_ptr(sta->pcpu_rx_stats, cpu);\r\nif (time_after(cpustats->last_rx, stats->last_rx))\r\nstats = cpustats;\r\n}\r\nreturn stats;\r\n}\r\nstatic void sta_stats_decode_rate(struct ieee80211_local *local, u16 rate,\r\nstruct rate_info *rinfo)\r\n{\r\nrinfo->bw = STA_STATS_GET(BW, rate);\r\nswitch (STA_STATS_GET(TYPE, rate)) {\r\ncase STA_STATS_RATE_TYPE_VHT:\r\nrinfo->flags = RATE_INFO_FLAGS_VHT_MCS;\r\nrinfo->mcs = STA_STATS_GET(VHT_MCS, rate);\r\nrinfo->nss = STA_STATS_GET(VHT_NSS, rate);\r\nif (STA_STATS_GET(SGI, rate))\r\nrinfo->flags |= RATE_INFO_FLAGS_SHORT_GI;\r\nbreak;\r\ncase STA_STATS_RATE_TYPE_HT:\r\nrinfo->flags = RATE_INFO_FLAGS_MCS;\r\nrinfo->mcs = STA_STATS_GET(HT_MCS, rate);\r\nif (STA_STATS_GET(SGI, rate))\r\nrinfo->flags |= RATE_INFO_FLAGS_SHORT_GI;\r\nbreak;\r\ncase STA_STATS_RATE_TYPE_LEGACY: {\r\nstruct ieee80211_supported_band *sband;\r\nu16 brate;\r\nunsigned int shift;\r\nint band = STA_STATS_GET(LEGACY_BAND, rate);\r\nint rate_idx = STA_STATS_GET(LEGACY_IDX, rate);\r\nrinfo->flags = 0;\r\nsband = local->hw.wiphy->bands[band];\r\nbrate = sband->bitrates[rate_idx].bitrate;\r\nif (rinfo->bw == RATE_INFO_BW_5)\r\nshift = 2;\r\nelse if (rinfo->bw == RATE_INFO_BW_10)\r\nshift = 1;\r\nelse\r\nshift = 0;\r\nrinfo->legacy = DIV_ROUND_UP(brate, 1 << shift);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int sta_set_rate_info_rx(struct sta_info *sta, struct rate_info *rinfo)\r\n{\r\nu16 rate = ACCESS_ONCE(sta_get_last_rx_stats(sta)->last_rate);\r\nif (rate == STA_STATS_RATE_INVALID)\r\nreturn -EINVAL;\r\nsta_stats_decode_rate(sta->local, rate, rinfo);\r\nreturn 0;\r\n}\r\nstatic void sta_set_tidstats(struct sta_info *sta,\r\nstruct cfg80211_tid_stats *tidstats,\r\nint tid)\r\n{\r\nstruct ieee80211_local *local = sta->local;\r\nif (!(tidstats->filled & BIT(NL80211_TID_STATS_RX_MSDU))) {\r\nunsigned int start;\r\ndo {\r\nstart = u64_stats_fetch_begin(&sta->rx_stats.syncp);\r\ntidstats->rx_msdu = sta->rx_stats.msdu[tid];\r\n} while (u64_stats_fetch_retry(&sta->rx_stats.syncp, start));\r\ntidstats->filled |= BIT(NL80211_TID_STATS_RX_MSDU);\r\n}\r\nif (!(tidstats->filled & BIT(NL80211_TID_STATS_TX_MSDU))) {\r\ntidstats->filled |= BIT(NL80211_TID_STATS_TX_MSDU);\r\ntidstats->tx_msdu = sta->tx_stats.msdu[tid];\r\n}\r\nif (!(tidstats->filled & BIT(NL80211_TID_STATS_TX_MSDU_RETRIES)) &&\r\nieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {\r\ntidstats->filled |= BIT(NL80211_TID_STATS_TX_MSDU_RETRIES);\r\ntidstats->tx_msdu_retries = sta->status_stats.msdu_retries[tid];\r\n}\r\nif (!(tidstats->filled & BIT(NL80211_TID_STATS_TX_MSDU_FAILED)) &&\r\nieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {\r\ntidstats->filled |= BIT(NL80211_TID_STATS_TX_MSDU_FAILED);\r\ntidstats->tx_msdu_failed = sta->status_stats.msdu_failed[tid];\r\n}\r\n}\r\nstatic inline u64 sta_get_stats_bytes(struct ieee80211_sta_rx_stats *rxstats)\r\n{\r\nunsigned int start;\r\nu64 value;\r\ndo {\r\nstart = u64_stats_fetch_begin(&rxstats->syncp);\r\nvalue = rxstats->bytes;\r\n} while (u64_stats_fetch_retry(&rxstats->syncp, start));\r\nreturn value;\r\n}\r\nvoid sta_set_sinfo(struct sta_info *sta, struct station_info *sinfo)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct ieee80211_local *local = sdata->local;\r\nu32 thr = 0;\r\nint i, ac, cpu;\r\nstruct ieee80211_sta_rx_stats *last_rxstats;\r\nlast_rxstats = sta_get_last_rx_stats(sta);\r\nsinfo->generation = sdata->local->sta_generation;\r\nif (sdata->vif.type == NL80211_IFTYPE_STATION)\r\nsinfo->rx_beacon = sdata->u.mgd.count_beacon_signal;\r\ndrv_sta_statistics(local, sdata, &sta->sta, sinfo);\r\nsinfo->filled |= BIT(NL80211_STA_INFO_INACTIVE_TIME) |\r\nBIT(NL80211_STA_INFO_STA_FLAGS) |\r\nBIT(NL80211_STA_INFO_BSS_PARAM) |\r\nBIT(NL80211_STA_INFO_CONNECTED_TIME) |\r\nBIT(NL80211_STA_INFO_RX_DROP_MISC);\r\nif (sdata->vif.type == NL80211_IFTYPE_STATION) {\r\nsinfo->beacon_loss_count = sdata->u.mgd.beacon_loss_count;\r\nsinfo->filled |= BIT(NL80211_STA_INFO_BEACON_LOSS);\r\n}\r\nsinfo->connected_time = ktime_get_seconds() - sta->last_connected;\r\nsinfo->inactive_time =\r\njiffies_to_msecs(jiffies - ieee80211_sta_last_active(sta));\r\nif (!(sinfo->filled & (BIT(NL80211_STA_INFO_TX_BYTES64) |\r\nBIT(NL80211_STA_INFO_TX_BYTES)))) {\r\nsinfo->tx_bytes = 0;\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\r\nsinfo->tx_bytes += sta->tx_stats.bytes[ac];\r\nsinfo->filled |= BIT(NL80211_STA_INFO_TX_BYTES64);\r\n}\r\nif (!(sinfo->filled & BIT(NL80211_STA_INFO_TX_PACKETS))) {\r\nsinfo->tx_packets = 0;\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\r\nsinfo->tx_packets += sta->tx_stats.packets[ac];\r\nsinfo->filled |= BIT(NL80211_STA_INFO_TX_PACKETS);\r\n}\r\nif (!(sinfo->filled & (BIT(NL80211_STA_INFO_RX_BYTES64) |\r\nBIT(NL80211_STA_INFO_RX_BYTES)))) {\r\nsinfo->rx_bytes += sta_get_stats_bytes(&sta->rx_stats);\r\nif (sta->pcpu_rx_stats) {\r\nfor_each_possible_cpu(cpu) {\r\nstruct ieee80211_sta_rx_stats *cpurxs;\r\ncpurxs = per_cpu_ptr(sta->pcpu_rx_stats, cpu);\r\nsinfo->rx_bytes += sta_get_stats_bytes(cpurxs);\r\n}\r\n}\r\nsinfo->filled |= BIT(NL80211_STA_INFO_RX_BYTES64);\r\n}\r\nif (!(sinfo->filled & BIT(NL80211_STA_INFO_RX_PACKETS))) {\r\nsinfo->rx_packets = sta->rx_stats.packets;\r\nif (sta->pcpu_rx_stats) {\r\nfor_each_possible_cpu(cpu) {\r\nstruct ieee80211_sta_rx_stats *cpurxs;\r\ncpurxs = per_cpu_ptr(sta->pcpu_rx_stats, cpu);\r\nsinfo->rx_packets += cpurxs->packets;\r\n}\r\n}\r\nsinfo->filled |= BIT(NL80211_STA_INFO_RX_PACKETS);\r\n}\r\nif (!(sinfo->filled & BIT(NL80211_STA_INFO_TX_RETRIES))) {\r\nsinfo->tx_retries = sta->status_stats.retry_count;\r\nsinfo->filled |= BIT(NL80211_STA_INFO_TX_RETRIES);\r\n}\r\nif (!(sinfo->filled & BIT(NL80211_STA_INFO_TX_FAILED))) {\r\nsinfo->tx_failed = sta->status_stats.retry_failed;\r\nsinfo->filled |= BIT(NL80211_STA_INFO_TX_FAILED);\r\n}\r\nsinfo->rx_dropped_misc = sta->rx_stats.dropped;\r\nif (sta->pcpu_rx_stats) {\r\nfor_each_possible_cpu(cpu) {\r\nstruct ieee80211_sta_rx_stats *cpurxs;\r\ncpurxs = per_cpu_ptr(sta->pcpu_rx_stats, cpu);\r\nsinfo->rx_dropped_misc += cpurxs->dropped;\r\n}\r\n}\r\nif (sdata->vif.type == NL80211_IFTYPE_STATION &&\r\n!(sdata->vif.driver_flags & IEEE80211_VIF_BEACON_FILTER)) {\r\nsinfo->filled |= BIT(NL80211_STA_INFO_BEACON_RX) |\r\nBIT(NL80211_STA_INFO_BEACON_SIGNAL_AVG);\r\nsinfo->rx_beacon_signal_avg = ieee80211_ave_rssi(&sdata->vif);\r\n}\r\nif (ieee80211_hw_check(&sta->local->hw, SIGNAL_DBM) ||\r\nieee80211_hw_check(&sta->local->hw, SIGNAL_UNSPEC)) {\r\nif (!(sinfo->filled & BIT(NL80211_STA_INFO_SIGNAL))) {\r\nsinfo->signal = (s8)last_rxstats->last_signal;\r\nsinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);\r\n}\r\nif (!sta->pcpu_rx_stats &&\r\n!(sinfo->filled & BIT(NL80211_STA_INFO_SIGNAL_AVG))) {\r\nsinfo->signal_avg =\r\n-ewma_signal_read(&sta->rx_stats_avg.signal);\r\nsinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL_AVG);\r\n}\r\n}\r\nif (last_rxstats->chains &&\r\n!(sinfo->filled & (BIT(NL80211_STA_INFO_CHAIN_SIGNAL) |\r\nBIT(NL80211_STA_INFO_CHAIN_SIGNAL_AVG)))) {\r\nsinfo->filled |= BIT(NL80211_STA_INFO_CHAIN_SIGNAL);\r\nif (!sta->pcpu_rx_stats)\r\nsinfo->filled |= BIT(NL80211_STA_INFO_CHAIN_SIGNAL_AVG);\r\nsinfo->chains = last_rxstats->chains;\r\nfor (i = 0; i < ARRAY_SIZE(sinfo->chain_signal); i++) {\r\nsinfo->chain_signal[i] =\r\nlast_rxstats->chain_signal_last[i];\r\nsinfo->chain_signal_avg[i] =\r\n-ewma_signal_read(&sta->rx_stats_avg.chain_signal[i]);\r\n}\r\n}\r\nif (!(sinfo->filled & BIT(NL80211_STA_INFO_TX_BITRATE))) {\r\nsta_set_rate_info_tx(sta, &sta->tx_stats.last_rate,\r\n&sinfo->txrate);\r\nsinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);\r\n}\r\nif (!(sinfo->filled & BIT(NL80211_STA_INFO_RX_BITRATE))) {\r\nif (sta_set_rate_info_rx(sta, &sinfo->rxrate) == 0)\r\nsinfo->filled |= BIT(NL80211_STA_INFO_RX_BITRATE);\r\n}\r\nsinfo->filled |= BIT(NL80211_STA_INFO_TID_STATS);\r\nfor (i = 0; i < IEEE80211_NUM_TIDS + 1; i++) {\r\nstruct cfg80211_tid_stats *tidstats = &sinfo->pertid[i];\r\nsta_set_tidstats(sta, tidstats, i);\r\n}\r\nif (ieee80211_vif_is_mesh(&sdata->vif)) {\r\n#ifdef CONFIG_MAC80211_MESH\r\nsinfo->filled |= BIT(NL80211_STA_INFO_LLID) |\r\nBIT(NL80211_STA_INFO_PLID) |\r\nBIT(NL80211_STA_INFO_PLINK_STATE) |\r\nBIT(NL80211_STA_INFO_LOCAL_PM) |\r\nBIT(NL80211_STA_INFO_PEER_PM) |\r\nBIT(NL80211_STA_INFO_NONPEER_PM);\r\nsinfo->llid = sta->mesh->llid;\r\nsinfo->plid = sta->mesh->plid;\r\nsinfo->plink_state = sta->mesh->plink_state;\r\nif (test_sta_flag(sta, WLAN_STA_TOFFSET_KNOWN)) {\r\nsinfo->filled |= BIT(NL80211_STA_INFO_T_OFFSET);\r\nsinfo->t_offset = sta->mesh->t_offset;\r\n}\r\nsinfo->local_pm = sta->mesh->local_pm;\r\nsinfo->peer_pm = sta->mesh->peer_pm;\r\nsinfo->nonpeer_pm = sta->mesh->nonpeer_pm;\r\n#endif\r\n}\r\nsinfo->bss_param.flags = 0;\r\nif (sdata->vif.bss_conf.use_cts_prot)\r\nsinfo->bss_param.flags |= BSS_PARAM_FLAGS_CTS_PROT;\r\nif (sdata->vif.bss_conf.use_short_preamble)\r\nsinfo->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_PREAMBLE;\r\nif (sdata->vif.bss_conf.use_short_slot)\r\nsinfo->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_SLOT_TIME;\r\nsinfo->bss_param.dtim_period = sdata->vif.bss_conf.dtim_period;\r\nsinfo->bss_param.beacon_interval = sdata->vif.bss_conf.beacon_int;\r\nsinfo->sta_flags.set = 0;\r\nsinfo->sta_flags.mask = BIT(NL80211_STA_FLAG_AUTHORIZED) |\r\nBIT(NL80211_STA_FLAG_SHORT_PREAMBLE) |\r\nBIT(NL80211_STA_FLAG_WME) |\r\nBIT(NL80211_STA_FLAG_MFP) |\r\nBIT(NL80211_STA_FLAG_AUTHENTICATED) |\r\nBIT(NL80211_STA_FLAG_ASSOCIATED) |\r\nBIT(NL80211_STA_FLAG_TDLS_PEER);\r\nif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\r\nsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_AUTHORIZED);\r\nif (test_sta_flag(sta, WLAN_STA_SHORT_PREAMBLE))\r\nsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_SHORT_PREAMBLE);\r\nif (sta->sta.wme)\r\nsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_WME);\r\nif (test_sta_flag(sta, WLAN_STA_MFP))\r\nsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_MFP);\r\nif (test_sta_flag(sta, WLAN_STA_AUTH))\r\nsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_AUTHENTICATED);\r\nif (test_sta_flag(sta, WLAN_STA_ASSOC))\r\nsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_ASSOCIATED);\r\nif (test_sta_flag(sta, WLAN_STA_TDLS_PEER))\r\nsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_TDLS_PEER);\r\nthr = sta_get_expected_throughput(sta);\r\nif (thr != 0) {\r\nsinfo->filled |= BIT(NL80211_STA_INFO_EXPECTED_THROUGHPUT);\r\nsinfo->expected_throughput = thr;\r\n}\r\n}\r\nu32 sta_get_expected_throughput(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct rate_control_ref *ref = NULL;\r\nu32 thr = 0;\r\nif (test_sta_flag(sta, WLAN_STA_RATE_CONTROL))\r\nref = local->rate_ctrl;\r\nif (ref && ref->ops->get_expected_throughput)\r\nthr = ref->ops->get_expected_throughput(sta->rate_ctrl_priv);\r\nelse\r\nthr = drv_get_expected_throughput(local, sta);\r\nreturn thr;\r\n}\r\nunsigned long ieee80211_sta_last_active(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sta_rx_stats *stats = sta_get_last_rx_stats(sta);\r\nif (time_after(stats->last_rx, sta->status_stats.last_ack))\r\nreturn stats->last_rx;\r\nreturn sta->status_stats.last_ack;\r\n}\r\nstatic void sta_update_codel_params(struct sta_info *sta, u32 thr)\r\n{\r\nif (!sta->sdata->local->ops->wake_tx_queue)\r\nreturn;\r\nif (thr && thr < STA_SLOW_THRESHOLD * sta->local->num_sta) {\r\nsta->cparams.target = MS2TIME(50);\r\nsta->cparams.interval = MS2TIME(300);\r\nsta->cparams.ecn = false;\r\n} else {\r\nsta->cparams.target = MS2TIME(20);\r\nsta->cparams.interval = MS2TIME(100);\r\nsta->cparams.ecn = true;\r\n}\r\n}\r\nvoid ieee80211_sta_set_expected_throughput(struct ieee80211_sta *pubsta,\r\nu32 thr)\r\n{\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\nsta_update_codel_params(sta, thr);\r\n}
