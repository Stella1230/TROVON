static int rt5033_battery_get_capacity(struct i2c_client *client)\r\n{\r\nstruct rt5033_battery *battery = i2c_get_clientdata(client);\r\nu32 msb;\r\nregmap_read(battery->regmap, RT5033_FUEL_REG_SOC_H, &msb);\r\nreturn msb;\r\n}\r\nstatic int rt5033_battery_get_present(struct i2c_client *client)\r\n{\r\nstruct rt5033_battery *battery = i2c_get_clientdata(client);\r\nu32 val;\r\nregmap_read(battery->regmap, RT5033_FUEL_REG_CONFIG_L, &val);\r\nreturn (val & RT5033_FUEL_BAT_PRESENT) ? true : false;\r\n}\r\nstatic int rt5033_battery_get_watt_prop(struct i2c_client *client,\r\nenum power_supply_property psp)\r\n{\r\nstruct rt5033_battery *battery = i2c_get_clientdata(client);\r\nunsigned int regh, regl;\r\nint ret;\r\nu32 msb, lsb;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nregh = RT5033_FUEL_REG_VBAT_H;\r\nregl = RT5033_FUEL_REG_VBAT_L;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_AVG:\r\nregh = RT5033_FUEL_REG_AVG_VOLT_H;\r\nregl = RT5033_FUEL_REG_AVG_VOLT_L;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_OCV:\r\nregh = RT5033_FUEL_REG_OCV_H;\r\nregl = RT5033_FUEL_REG_OCV_L;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_read(battery->regmap, regh, &msb);\r\nregmap_read(battery->regmap, regl, &lsb);\r\nret = ((msb << 4) + (lsb >> 4)) * 1250 / 1000;\r\nreturn ret;\r\n}\r\nstatic int rt5033_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct rt5033_battery *battery = power_supply_get_drvdata(psy);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\ncase POWER_SUPPLY_PROP_VOLTAGE_AVG:\r\ncase POWER_SUPPLY_PROP_VOLTAGE_OCV:\r\nval->intval = rt5033_battery_get_watt_prop(battery->client,\r\npsp);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = rt5033_battery_get_present(battery->client);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nval->intval = rt5033_battery_get_capacity(battery->client);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5033_battery_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct power_supply_config psy_cfg = {};\r\nstruct rt5033_battery *battery;\r\nu32 ret;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))\r\nreturn -EIO;\r\nbattery = devm_kzalloc(&client->dev, sizeof(*battery), GFP_KERNEL);\r\nif (!battery)\r\nreturn -EINVAL;\r\nbattery->client = client;\r\nbattery->regmap = devm_regmap_init_i2c(client,\r\n&rt5033_battery_regmap_config);\r\nif (IS_ERR(battery->regmap)) {\r\ndev_err(&client->dev, "Failed to initialize regmap\n");\r\nreturn -EINVAL;\r\n}\r\ni2c_set_clientdata(client, battery);\r\npsy_cfg.drv_data = battery;\r\nbattery->psy = power_supply_register(&client->dev,\r\n&rt5033_battery_desc, &psy_cfg);\r\nif (IS_ERR(battery->psy)) {\r\ndev_err(&client->dev, "Failed to register power supply\n");\r\nret = PTR_ERR(battery->psy);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5033_battery_remove(struct i2c_client *client)\r\n{\r\nstruct rt5033_battery *battery = i2c_get_clientdata(client);\r\npower_supply_unregister(battery->psy);\r\nreturn 0;\r\n}
