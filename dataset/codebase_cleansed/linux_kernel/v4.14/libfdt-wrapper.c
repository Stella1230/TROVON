static void expand_buf(int minexpand)\r\n{\r\nint size = fdt_totalsize(fdt);\r\nint rc;\r\nsize = _ALIGN(size + minexpand, EXPAND_GRANULARITY);\r\nbuf = platform_ops.realloc(buf, size);\r\nif (!buf)\r\nfatal("Couldn't find %d bytes to expand device tree\n\r", size);\r\nrc = fdt_open_into(fdt, buf, size);\r\nif (rc != 0)\r\nfatal("Couldn't expand fdt into new buffer: %s\n\r",\r\nfdt_strerror(rc));\r\nfdt = buf;\r\n}\r\nstatic void *fdt_wrapper_finddevice(const char *path)\r\n{\r\nreturn offset_devp(fdt_path_offset(fdt, path));\r\n}\r\nstatic int fdt_wrapper_getprop(const void *devp, const char *name,\r\nvoid *buf, const int buflen)\r\n{\r\nconst void *p;\r\nint len;\r\np = fdt_getprop(fdt, devp_offset(devp), name, &len);\r\nif (!p)\r\nreturn check_err(len);\r\nmemcpy(buf, p, min(len, buflen));\r\nreturn len;\r\n}\r\nstatic int fdt_wrapper_setprop(const void *devp, const char *name,\r\nconst void *buf, const int len)\r\n{\r\nint rc;\r\nrc = fdt_setprop(fdt, devp_offset(devp), name, buf, len);\r\nif (rc == -FDT_ERR_NOSPACE) {\r\nexpand_buf(len + 16);\r\nrc = fdt_setprop(fdt, devp_offset(devp), name, buf, len);\r\n}\r\nreturn check_err(rc);\r\n}\r\nstatic int fdt_wrapper_del_node(const void *devp)\r\n{\r\nreturn fdt_del_node(fdt, devp_offset(devp));\r\n}\r\nstatic void *fdt_wrapper_get_parent(const void *devp)\r\n{\r\nreturn offset_devp(fdt_parent_offset(fdt, devp_offset(devp)));\r\n}\r\nstatic void *fdt_wrapper_create_node(const void *devp, const char *name)\r\n{\r\nint offset;\r\noffset = fdt_add_subnode(fdt, devp_offset(devp), name);\r\nif (offset == -FDT_ERR_NOSPACE) {\r\nexpand_buf(strlen(name) + 16);\r\noffset = fdt_add_subnode(fdt, devp_offset(devp), name);\r\n}\r\nreturn offset_devp(offset);\r\n}\r\nstatic void *fdt_wrapper_find_node_by_prop_value(const void *prev,\r\nconst char *name,\r\nconst char *val,\r\nint len)\r\n{\r\nint offset = fdt_node_offset_by_prop_value(fdt, devp_offset_find(prev),\r\nname, val, len);\r\nreturn offset_devp(offset);\r\n}\r\nstatic void *fdt_wrapper_find_node_by_compatible(const void *prev,\r\nconst char *val)\r\n{\r\nint offset = fdt_node_offset_by_compatible(fdt, devp_offset_find(prev),\r\nval);\r\nreturn offset_devp(offset);\r\n}\r\nstatic char *fdt_wrapper_get_path(const void *devp, char *buf, int len)\r\n{\r\nint rc;\r\nrc = fdt_get_path(fdt, devp_offset(devp), buf, len);\r\nif (check_err(rc))\r\nreturn NULL;\r\nreturn buf;\r\n}\r\nstatic unsigned long fdt_wrapper_finalize(void)\r\n{\r\nint rc;\r\nrc = fdt_pack(fdt);\r\nif (rc != 0)\r\nfatal("Couldn't pack flat tree: %s\n\r",\r\nfdt_strerror(rc));\r\nreturn (unsigned long)fdt;\r\n}\r\nvoid fdt_init(void *blob)\r\n{\r\nint err;\r\nint bufsize;\r\ndt_ops.finddevice = fdt_wrapper_finddevice;\r\ndt_ops.getprop = fdt_wrapper_getprop;\r\ndt_ops.setprop = fdt_wrapper_setprop;\r\ndt_ops.get_parent = fdt_wrapper_get_parent;\r\ndt_ops.create_node = fdt_wrapper_create_node;\r\ndt_ops.find_node_by_prop_value = fdt_wrapper_find_node_by_prop_value;\r\ndt_ops.find_node_by_compatible = fdt_wrapper_find_node_by_compatible;\r\ndt_ops.del_node = fdt_wrapper_del_node;\r\ndt_ops.get_path = fdt_wrapper_get_path;\r\ndt_ops.finalize = fdt_wrapper_finalize;\r\nfdt = blob;\r\nbufsize = fdt_totalsize(fdt) + EXPAND_GRANULARITY;\r\nbuf = malloc(bufsize);\r\nif(!buf)\r\nfatal("malloc failed. can't relocate the device tree\n\r");\r\nerr = fdt_open_into(fdt, buf, bufsize);\r\nif (err != 0)\r\nfatal("fdt_init(): %s\n\r", fdt_strerror(err));\r\nfdt = buf;\r\n}
