static void mangle_contents(struct sk_buff *skb,\r\nunsigned int dataoff,\r\nunsigned int match_offset,\r\nunsigned int match_len,\r\nconst char *rep_buffer,\r\nunsigned int rep_len)\r\n{\r\nunsigned char *data;\r\nBUG_ON(skb_is_nonlinear(skb));\r\ndata = skb_network_header(skb) + dataoff;\r\nmemmove(data + match_offset + rep_len,\r\ndata + match_offset + match_len,\r\nskb_tail_pointer(skb) - (skb_network_header(skb) + dataoff +\r\nmatch_offset + match_len));\r\nmemcpy(data + match_offset, rep_buffer, rep_len);\r\nif (rep_len > match_len) {\r\npr_debug("nf_nat_mangle_packet: Extending packet by "\r\n"%u from %u bytes\n", rep_len - match_len, skb->len);\r\nskb_put(skb, rep_len - match_len);\r\n} else {\r\npr_debug("nf_nat_mangle_packet: Shrinking packet from "\r\n"%u from %u bytes\n", match_len - rep_len, skb->len);\r\n__skb_trim(skb, skb->len + rep_len - match_len);\r\n}\r\nif (nf_ct_l3num((struct nf_conn *)skb_nfct(skb)) == NFPROTO_IPV4) {\r\nip_hdr(skb)->tot_len = htons(skb->len);\r\nip_send_check(ip_hdr(skb));\r\n} else\r\nipv6_hdr(skb)->payload_len =\r\nhtons(skb->len - sizeof(struct ipv6hdr));\r\n}\r\nstatic bool enlarge_skb(struct sk_buff *skb, unsigned int extra)\r\n{\r\nif (skb->len + extra > 65535)\r\nreturn false;\r\nif (pskb_expand_head(skb, 0, extra - skb_tailroom(skb), GFP_ATOMIC))\r\nreturn false;\r\nreturn true;\r\n}\r\nbool __nf_nat_mangle_tcp_packet(struct sk_buff *skb,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned int match_offset,\r\nunsigned int match_len,\r\nconst char *rep_buffer,\r\nunsigned int rep_len, bool adjust)\r\n{\r\nconst struct nf_nat_l3proto *l3proto;\r\nstruct tcphdr *tcph;\r\nint oldlen, datalen;\r\nif (!skb_make_writable(skb, skb->len))\r\nreturn false;\r\nif (rep_len > match_len &&\r\nrep_len - match_len > skb_tailroom(skb) &&\r\n!enlarge_skb(skb, rep_len - match_len))\r\nreturn false;\r\nSKB_LINEAR_ASSERT(skb);\r\ntcph = (void *)skb->data + protoff;\r\noldlen = skb->len - protoff;\r\nmangle_contents(skb, protoff + tcph->doff*4,\r\nmatch_offset, match_len, rep_buffer, rep_len);\r\ndatalen = skb->len - protoff;\r\nl3proto = __nf_nat_l3proto_find(nf_ct_l3num(ct));\r\nl3proto->csum_recalc(skb, IPPROTO_TCP, tcph, &tcph->check,\r\ndatalen, oldlen);\r\nif (adjust && rep_len != match_len)\r\nnf_ct_seqadj_set(ct, ctinfo, tcph->seq,\r\n(int)rep_len - (int)match_len);\r\nreturn true;\r\n}\r\nbool\r\nnf_nat_mangle_udp_packet(struct sk_buff *skb,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned int match_offset,\r\nunsigned int match_len,\r\nconst char *rep_buffer,\r\nunsigned int rep_len)\r\n{\r\nconst struct nf_nat_l3proto *l3proto;\r\nstruct udphdr *udph;\r\nint datalen, oldlen;\r\nif (!skb_make_writable(skb, skb->len))\r\nreturn false;\r\nif (rep_len > match_len &&\r\nrep_len - match_len > skb_tailroom(skb) &&\r\n!enlarge_skb(skb, rep_len - match_len))\r\nreturn false;\r\nudph = (void *)skb->data + protoff;\r\noldlen = skb->len - protoff;\r\nmangle_contents(skb, protoff + sizeof(*udph),\r\nmatch_offset, match_len, rep_buffer, rep_len);\r\ndatalen = skb->len - protoff;\r\nudph->len = htons(datalen);\r\nif (!udph->check && skb->ip_summed != CHECKSUM_PARTIAL)\r\nreturn true;\r\nl3proto = __nf_nat_l3proto_find(nf_ct_l3num(ct));\r\nl3proto->csum_recalc(skb, IPPROTO_UDP, udph, &udph->check,\r\ndatalen, oldlen);\r\nreturn true;\r\n}\r\nvoid nf_nat_follow_master(struct nf_conn *ct,\r\nstruct nf_conntrack_expect *exp)\r\n{\r\nstruct nf_nat_range range;\r\nBUG_ON(ct->status & IPS_NAT_DONE_MASK);\r\nrange.flags = NF_NAT_RANGE_MAP_IPS;\r\nrange.min_addr = range.max_addr\r\n= ct->master->tuplehash[!exp->dir].tuple.dst.u3;\r\nnf_nat_setup_info(ct, &range, NF_NAT_MANIP_SRC);\r\nrange.flags = (NF_NAT_RANGE_MAP_IPS | NF_NAT_RANGE_PROTO_SPECIFIED);\r\nrange.min_proto = range.max_proto = exp->saved_proto;\r\nrange.min_addr = range.max_addr\r\n= ct->master->tuplehash[!exp->dir].tuple.src.u3;\r\nnf_nat_setup_info(ct, &range, NF_NAT_MANIP_DST);\r\n}
