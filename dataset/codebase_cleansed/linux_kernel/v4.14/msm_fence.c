struct msm_fence_context *\r\nmsm_fence_context_alloc(struct drm_device *dev, const char *name)\r\n{\r\nstruct msm_fence_context *fctx;\r\nfctx = kzalloc(sizeof(*fctx), GFP_KERNEL);\r\nif (!fctx)\r\nreturn ERR_PTR(-ENOMEM);\r\nfctx->dev = dev;\r\nfctx->name = name;\r\nfctx->context = dma_fence_context_alloc(1);\r\ninit_waitqueue_head(&fctx->event);\r\nspin_lock_init(&fctx->spinlock);\r\nreturn fctx;\r\n}\r\nvoid msm_fence_context_free(struct msm_fence_context *fctx)\r\n{\r\nkfree(fctx);\r\n}\r\nstatic inline bool fence_completed(struct msm_fence_context *fctx, uint32_t fence)\r\n{\r\nreturn (int32_t)(fctx->completed_fence - fence) >= 0;\r\n}\r\nint msm_wait_fence(struct msm_fence_context *fctx, uint32_t fence,\r\nktime_t *timeout, bool interruptible)\r\n{\r\nint ret;\r\nif (fence > fctx->last_fence) {\r\nDRM_ERROR("%s: waiting on invalid fence: %u (of %u)\n",\r\nfctx->name, fence, fctx->last_fence);\r\nreturn -EINVAL;\r\n}\r\nif (!timeout) {\r\nret = fence_completed(fctx, fence) ? 0 : -EBUSY;\r\n} else {\r\nunsigned long remaining_jiffies = timeout_to_jiffies(timeout);\r\nif (interruptible)\r\nret = wait_event_interruptible_timeout(fctx->event,\r\nfence_completed(fctx, fence),\r\nremaining_jiffies);\r\nelse\r\nret = wait_event_timeout(fctx->event,\r\nfence_completed(fctx, fence),\r\nremaining_jiffies);\r\nif (ret == 0) {\r\nDBG("timeout waiting for fence: %u (completed: %u)",\r\nfence, fctx->completed_fence);\r\nret = -ETIMEDOUT;\r\n} else if (ret != -ERESTARTSYS) {\r\nret = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid msm_update_fence(struct msm_fence_context *fctx, uint32_t fence)\r\n{\r\nspin_lock(&fctx->spinlock);\r\nfctx->completed_fence = max(fence, fctx->completed_fence);\r\nspin_unlock(&fctx->spinlock);\r\nwake_up_all(&fctx->event);\r\n}\r\nstatic inline struct msm_fence *to_msm_fence(struct dma_fence *fence)\r\n{\r\nreturn container_of(fence, struct msm_fence, base);\r\n}\r\nstatic const char *msm_fence_get_driver_name(struct dma_fence *fence)\r\n{\r\nreturn "msm";\r\n}\r\nstatic const char *msm_fence_get_timeline_name(struct dma_fence *fence)\r\n{\r\nstruct msm_fence *f = to_msm_fence(fence);\r\nreturn f->fctx->name;\r\n}\r\nstatic bool msm_fence_enable_signaling(struct dma_fence *fence)\r\n{\r\nreturn true;\r\n}\r\nstatic bool msm_fence_signaled(struct dma_fence *fence)\r\n{\r\nstruct msm_fence *f = to_msm_fence(fence);\r\nreturn fence_completed(f->fctx, f->base.seqno);\r\n}\r\nstruct dma_fence *\r\nmsm_fence_alloc(struct msm_fence_context *fctx)\r\n{\r\nstruct msm_fence *f;\r\nf = kzalloc(sizeof(*f), GFP_KERNEL);\r\nif (!f)\r\nreturn ERR_PTR(-ENOMEM);\r\nf->fctx = fctx;\r\ndma_fence_init(&f->base, &msm_fence_ops, &fctx->spinlock,\r\nfctx->context, ++fctx->last_fence);\r\nreturn &f->base;\r\n}
