void ISACVersion(struct IsdnCardState *cs, char *s)\r\n{\r\nint val;\r\nval = cs->readisac(cs, ISAC_RBCH);\r\nprintk(KERN_INFO "%s ISAC version (%x): %s\n", s, val, ISACVer[(val >> 5) & 3]);\r\n}\r\nstatic void\r\nph_command(struct IsdnCardState *cs, unsigned int command)\r\n{\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ph_command %x", command);\r\ncs->writeisac(cs, ISAC_CIX0, (command << 2) | 3);\r\n}\r\nstatic void\r\nisac_new_ph(struct IsdnCardState *cs)\r\n{\r\nswitch (cs->dc.isac.ph_state) {\r\ncase (ISAC_IND_RS):\r\ncase (ISAC_IND_EI):\r\nph_command(cs, ISAC_CMD_DUI);\r\nl1_msg(cs, HW_RESET | INDICATION, NULL);\r\nbreak;\r\ncase (ISAC_IND_DID):\r\nl1_msg(cs, HW_DEACTIVATE | CONFIRM, NULL);\r\nbreak;\r\ncase (ISAC_IND_DR):\r\nl1_msg(cs, HW_DEACTIVATE | INDICATION, NULL);\r\nbreak;\r\ncase (ISAC_IND_PU):\r\nl1_msg(cs, HW_POWERUP | CONFIRM, NULL);\r\nbreak;\r\ncase (ISAC_IND_RSY):\r\nl1_msg(cs, HW_RSYNC | INDICATION, NULL);\r\nbreak;\r\ncase (ISAC_IND_ARD):\r\nl1_msg(cs, HW_INFO2 | INDICATION, NULL);\r\nbreak;\r\ncase (ISAC_IND_AI8):\r\nl1_msg(cs, HW_INFO4_P8 | INDICATION, NULL);\r\nbreak;\r\ncase (ISAC_IND_AI10):\r\nl1_msg(cs, HW_INFO4_P10 | INDICATION, NULL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nisac_bh(struct work_struct *work)\r\n{\r\nstruct IsdnCardState *cs =\r\ncontainer_of(work, struct IsdnCardState, tqueue);\r\nstruct PStack *stptr;\r\nif (test_and_clear_bit(D_CLEARBUSY, &cs->event)) {\r\nif (cs->debug)\r\ndebugl1(cs, "D-Channel Busy cleared");\r\nstptr = cs->stlist;\r\nwhile (stptr != NULL) {\r\nstptr->l1.l1l2(stptr, PH_PAUSE | CONFIRM, NULL);\r\nstptr = stptr->next;\r\n}\r\n}\r\nif (test_and_clear_bit(D_L1STATECHANGE, &cs->event))\r\nisac_new_ph(cs);\r\nif (test_and_clear_bit(D_RCVBUFREADY, &cs->event))\r\nDChannel_proc_rcv(cs);\r\nif (test_and_clear_bit(D_XMTBUFREADY, &cs->event))\r\nDChannel_proc_xmt(cs);\r\n#if ARCOFI_USE\r\nif (!test_bit(HW_ARCOFI, &cs->HW_Flags))\r\nreturn;\r\nif (test_and_clear_bit(D_RX_MON1, &cs->event))\r\narcofi_fsm(cs, ARCOFI_RX_END, NULL);\r\nif (test_and_clear_bit(D_TX_MON1, &cs->event))\r\narcofi_fsm(cs, ARCOFI_TX_END, NULL);\r\n#endif\r\n}\r\nstatic void\r\nisac_empty_fifo(struct IsdnCardState *cs, int count)\r\n{\r\nu_char *ptr;\r\nif ((cs->debug & L1_DEB_ISAC) && !(cs->debug & L1_DEB_ISAC_FIFO))\r\ndebugl1(cs, "isac_empty_fifo");\r\nif ((cs->rcvidx + count) >= MAX_DFRAME_LEN_L1) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "isac_empty_fifo overrun %d",\r\ncs->rcvidx + count);\r\ncs->writeisac(cs, ISAC_CMDR, 0x80);\r\ncs->rcvidx = 0;\r\nreturn;\r\n}\r\nptr = cs->rcvbuf + cs->rcvidx;\r\ncs->rcvidx += count;\r\ncs->readisacfifo(cs, ptr, count);\r\ncs->writeisac(cs, ISAC_CMDR, 0x80);\r\nif (cs->debug & L1_DEB_ISAC_FIFO) {\r\nchar *t = cs->dlog;\r\nt += sprintf(t, "isac_empty_fifo cnt %d", count);\r\nQuickHex(t, ptr, count);\r\ndebugl1(cs, "%s", cs->dlog);\r\n}\r\n}\r\nstatic void\r\nisac_fill_fifo(struct IsdnCardState *cs)\r\n{\r\nint count, more;\r\nu_char *ptr;\r\nif ((cs->debug & L1_DEB_ISAC) && !(cs->debug & L1_DEB_ISAC_FIFO))\r\ndebugl1(cs, "isac_fill_fifo");\r\nif (!cs->tx_skb)\r\nreturn;\r\ncount = cs->tx_skb->len;\r\nif (count <= 0)\r\nreturn;\r\nmore = 0;\r\nif (count > 32) {\r\nmore = !0;\r\ncount = 32;\r\n}\r\nptr = cs->tx_skb->data;\r\nskb_pull(cs->tx_skb, count);\r\ncs->tx_cnt += count;\r\ncs->writeisacfifo(cs, ptr, count);\r\ncs->writeisac(cs, ISAC_CMDR, more ? 0x8 : 0xa);\r\nif (test_and_set_bit(FLG_DBUSY_TIMER, &cs->HW_Flags)) {\r\ndebugl1(cs, "isac_fill_fifo dbusytimer running");\r\ndel_timer(&cs->dbusytimer);\r\n}\r\ninit_timer(&cs->dbusytimer);\r\ncs->dbusytimer.expires = jiffies + ((DBUSY_TIMER_VALUE * HZ)/1000);\r\nadd_timer(&cs->dbusytimer);\r\nif (cs->debug & L1_DEB_ISAC_FIFO) {\r\nchar *t = cs->dlog;\r\nt += sprintf(t, "isac_fill_fifo cnt %d", count);\r\nQuickHex(t, ptr, count);\r\ndebugl1(cs, "%s", cs->dlog);\r\n}\r\n}\r\nvoid\r\nisac_interrupt(struct IsdnCardState *cs, u_char val)\r\n{\r\nu_char exval, v1;\r\nstruct sk_buff *skb;\r\nunsigned int count;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ISAC interrupt %x", val);\r\nif (val & 0x80) {\r\nexval = cs->readisac(cs, ISAC_RSTA);\r\nif ((exval & 0x70) != 0x20) {\r\nif (exval & 0x40) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ISAC RDO");\r\n#ifdef ERROR_STATISTIC\r\ncs->err_rx++;\r\n#endif\r\n}\r\nif (!(exval & 0x20)) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ISAC CRC error");\r\n#ifdef ERROR_STATISTIC\r\ncs->err_crc++;\r\n#endif\r\n}\r\ncs->writeisac(cs, ISAC_CMDR, 0x80);\r\n} else {\r\ncount = cs->readisac(cs, ISAC_RBCL) & 0x1f;\r\nif (count == 0)\r\ncount = 32;\r\nisac_empty_fifo(cs, count);\r\ncount = cs->rcvidx;\r\nif (count > 0) {\r\ncs->rcvidx = 0;\r\nskb = alloc_skb(count, GFP_ATOMIC);\r\nif (!skb)\r\nprintk(KERN_WARNING "HiSax: D receive out of memory\n");\r\nelse {\r\nskb_put_data(skb, cs->rcvbuf, count);\r\nskb_queue_tail(&cs->rq, skb);\r\n}\r\n}\r\n}\r\ncs->rcvidx = 0;\r\nschedule_event(cs, D_RCVBUFREADY);\r\n}\r\nif (val & 0x40) {\r\nisac_empty_fifo(cs, 32);\r\n}\r\nif (val & 0x20) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ISAC RSC interrupt");\r\n}\r\nif (val & 0x10) {\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nif (test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nschedule_event(cs, D_CLEARBUSY);\r\nif (cs->tx_skb) {\r\nif (cs->tx_skb->len) {\r\nisac_fill_fifo(cs);\r\ngoto afterXPR;\r\n} else {\r\ndev_kfree_skb_irq(cs->tx_skb);\r\ncs->tx_cnt = 0;\r\ncs->tx_skb = NULL;\r\n}\r\n}\r\ncs->tx_skb = skb_dequeue(&cs->sq);\r\nif (cs->tx_skb) {\r\ncs->tx_cnt = 0;\r\nisac_fill_fifo(cs);\r\n} else\r\nschedule_event(cs, D_XMTBUFREADY);\r\n}\r\nafterXPR:\r\nif (val & 0x04) {\r\nexval = cs->readisac(cs, ISAC_CIR0);\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ISAC CIR0 %02X", exval);\r\nif (exval & 2) {\r\ncs->dc.isac.ph_state = (exval >> 2) & 0xf;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ph_state change %x", cs->dc.isac.ph_state);\r\nschedule_event(cs, D_L1STATECHANGE);\r\n}\r\nif (exval & 1) {\r\nexval = cs->readisac(cs, ISAC_CIR1);\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ISAC CIR1 %02X", exval);\r\n}\r\n}\r\nif (val & 0x02) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ISAC SIN interrupt");\r\n}\r\nif (val & 0x01) {\r\nexval = cs->readisac(cs, ISAC_EXIR);\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ISAC EXIR %02x", exval);\r\nif (exval & 0x80) {\r\ndebugl1(cs, "ISAC XMR");\r\nprintk(KERN_WARNING "HiSax: ISAC XMR\n");\r\n}\r\nif (exval & 0x40) {\r\ndebugl1(cs, "ISAC XDU");\r\nprintk(KERN_WARNING "HiSax: ISAC XDU\n");\r\n#ifdef ERROR_STATISTIC\r\ncs->err_tx++;\r\n#endif\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nif (test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nschedule_event(cs, D_CLEARBUSY);\r\nif (cs->tx_skb) {\r\nskb_push(cs->tx_skb, cs->tx_cnt);\r\ncs->tx_cnt = 0;\r\nisac_fill_fifo(cs);\r\n} else {\r\nprintk(KERN_WARNING "HiSax: ISAC XDU no skb\n");\r\ndebugl1(cs, "ISAC XDU no skb");\r\n}\r\n}\r\nif (exval & 0x04) {\r\nv1 = cs->readisac(cs, ISAC_MOSR);\r\nif (cs->debug & L1_DEB_MONITOR)\r\ndebugl1(cs, "ISAC MOSR %02x", v1);\r\n#if ARCOFI_USE\r\nif (v1 & 0x08) {\r\nif (!cs->dc.isac.mon_rx) {\r\ncs->dc.isac.mon_rx = kmalloc(MAX_MON_FRAME, GFP_ATOMIC);\r\nif (!cs->dc.isac.mon_rx) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ISAC MON RX out of memory!");\r\ncs->dc.isac.mocr &= 0xf0;\r\ncs->dc.isac.mocr |= 0x0a;\r\ncs->writeisac(cs, ISAC_MOCR, cs->dc.isac.mocr);\r\ngoto afterMONR0;\r\n} else\r\ncs->dc.isac.mon_rxp = 0;\r\n}\r\nif (cs->dc.isac.mon_rxp >= MAX_MON_FRAME) {\r\ncs->dc.isac.mocr &= 0xf0;\r\ncs->dc.isac.mocr |= 0x0a;\r\ncs->writeisac(cs, ISAC_MOCR, cs->dc.isac.mocr);\r\ncs->dc.isac.mon_rxp = 0;\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ISAC MON RX overflow!");\r\ngoto afterMONR0;\r\n}\r\ncs->dc.isac.mon_rx[cs->dc.isac.mon_rxp++] = cs->readisac(cs, ISAC_MOR0);\r\nif (cs->debug & L1_DEB_MONITOR)\r\ndebugl1(cs, "ISAC MOR0 %02x", cs->dc.isac.mon_rx[cs->dc.isac.mon_rxp - 1]);\r\nif (cs->dc.isac.mon_rxp == 1) {\r\ncs->dc.isac.mocr |= 0x04;\r\ncs->writeisac(cs, ISAC_MOCR, cs->dc.isac.mocr);\r\n}\r\n}\r\nafterMONR0:\r\nif (v1 & 0x80) {\r\nif (!cs->dc.isac.mon_rx) {\r\ncs->dc.isac.mon_rx = kmalloc(MAX_MON_FRAME, GFP_ATOMIC);\r\nif (!cs->dc.isac.mon_rx) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ISAC MON RX out of memory!");\r\ncs->dc.isac.mocr &= 0x0f;\r\ncs->dc.isac.mocr |= 0xa0;\r\ncs->writeisac(cs, ISAC_MOCR, cs->dc.isac.mocr);\r\ngoto afterMONR1;\r\n} else\r\ncs->dc.isac.mon_rxp = 0;\r\n}\r\nif (cs->dc.isac.mon_rxp >= MAX_MON_FRAME) {\r\ncs->dc.isac.mocr &= 0x0f;\r\ncs->dc.isac.mocr |= 0xa0;\r\ncs->writeisac(cs, ISAC_MOCR, cs->dc.isac.mocr);\r\ncs->dc.isac.mon_rxp = 0;\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ISAC MON RX overflow!");\r\ngoto afterMONR1;\r\n}\r\ncs->dc.isac.mon_rx[cs->dc.isac.mon_rxp++] = cs->readisac(cs, ISAC_MOR1);\r\nif (cs->debug & L1_DEB_MONITOR)\r\ndebugl1(cs, "ISAC MOR1 %02x", cs->dc.isac.mon_rx[cs->dc.isac.mon_rxp - 1]);\r\ncs->dc.isac.mocr |= 0x40;\r\ncs->writeisac(cs, ISAC_MOCR, cs->dc.isac.mocr);\r\n}\r\nafterMONR1:\r\nif (v1 & 0x04) {\r\ncs->dc.isac.mocr &= 0xf0;\r\ncs->writeisac(cs, ISAC_MOCR, cs->dc.isac.mocr);\r\ncs->dc.isac.mocr |= 0x0a;\r\ncs->writeisac(cs, ISAC_MOCR, cs->dc.isac.mocr);\r\nschedule_event(cs, D_RX_MON0);\r\n}\r\nif (v1 & 0x40) {\r\ncs->dc.isac.mocr &= 0x0f;\r\ncs->writeisac(cs, ISAC_MOCR, cs->dc.isac.mocr);\r\ncs->dc.isac.mocr |= 0xa0;\r\ncs->writeisac(cs, ISAC_MOCR, cs->dc.isac.mocr);\r\nschedule_event(cs, D_RX_MON1);\r\n}\r\nif (v1 & 0x02) {\r\nif ((!cs->dc.isac.mon_tx) || (cs->dc.isac.mon_txc &&\r\n(cs->dc.isac.mon_txp >= cs->dc.isac.mon_txc) &&\r\n!(v1 & 0x08))) {\r\ncs->dc.isac.mocr &= 0xf0;\r\ncs->writeisac(cs, ISAC_MOCR, cs->dc.isac.mocr);\r\ncs->dc.isac.mocr |= 0x0a;\r\ncs->writeisac(cs, ISAC_MOCR, cs->dc.isac.mocr);\r\nif (cs->dc.isac.mon_txc &&\r\n(cs->dc.isac.mon_txp >= cs->dc.isac.mon_txc))\r\nschedule_event(cs, D_TX_MON0);\r\ngoto AfterMOX0;\r\n}\r\nif (cs->dc.isac.mon_txc && (cs->dc.isac.mon_txp >= cs->dc.isac.mon_txc)) {\r\nschedule_event(cs, D_TX_MON0);\r\ngoto AfterMOX0;\r\n}\r\ncs->writeisac(cs, ISAC_MOX0,\r\ncs->dc.isac.mon_tx[cs->dc.isac.mon_txp++]);\r\nif (cs->debug & L1_DEB_MONITOR)\r\ndebugl1(cs, "ISAC %02x -> MOX0", cs->dc.isac.mon_tx[cs->dc.isac.mon_txp - 1]);\r\n}\r\nAfterMOX0:\r\nif (v1 & 0x20) {\r\nif ((!cs->dc.isac.mon_tx) || (cs->dc.isac.mon_txc &&\r\n(cs->dc.isac.mon_txp >= cs->dc.isac.mon_txc) &&\r\n!(v1 & 0x80))) {\r\ncs->dc.isac.mocr &= 0x0f;\r\ncs->writeisac(cs, ISAC_MOCR, cs->dc.isac.mocr);\r\ncs->dc.isac.mocr |= 0xa0;\r\ncs->writeisac(cs, ISAC_MOCR, cs->dc.isac.mocr);\r\nif (cs->dc.isac.mon_txc &&\r\n(cs->dc.isac.mon_txp >= cs->dc.isac.mon_txc))\r\nschedule_event(cs, D_TX_MON1);\r\ngoto AfterMOX1;\r\n}\r\nif (cs->dc.isac.mon_txc && (cs->dc.isac.mon_txp >= cs->dc.isac.mon_txc)) {\r\nschedule_event(cs, D_TX_MON1);\r\ngoto AfterMOX1;\r\n}\r\ncs->writeisac(cs, ISAC_MOX1,\r\ncs->dc.isac.mon_tx[cs->dc.isac.mon_txp++]);\r\nif (cs->debug & L1_DEB_MONITOR)\r\ndebugl1(cs, "ISAC %02x -> MOX1", cs->dc.isac.mon_tx[cs->dc.isac.mon_txp - 1]);\r\n}\r\nAfterMOX1:;\r\n#endif\r\n}\r\n}\r\n}\r\nstatic void\r\nISAC_l1hw(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct IsdnCardState *cs = (struct IsdnCardState *) st->l1.hardware;\r\nstruct sk_buff *skb = arg;\r\nu_long flags;\r\nint val;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nif (cs->debug & DEB_DLOG_HEX)\r\nLogFrame(cs, skb->data, skb->len);\r\nif (cs->debug & DEB_DLOG_VERBOSE)\r\ndlogframe(cs, skb, 0);\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->tx_skb) {\r\nskb_queue_tail(&cs->sq, skb);\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA Queued", 0);\r\n#endif\r\n} else {\r\ncs->tx_skb = skb;\r\ncs->tx_cnt = 0;\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA", 0);\r\n#endif\r\nisac_fill_fifo(cs);\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->tx_skb) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, " l2l1 tx_skb exist this shouldn't happen");\r\nskb_queue_tail(&cs->sq, skb);\r\n} else {\r\nif (cs->debug & DEB_DLOG_HEX)\r\nLogFrame(cs, skb->data, skb->len);\r\nif (cs->debug & DEB_DLOG_VERBOSE)\r\ndlogframe(cs, skb, 0);\r\ncs->tx_skb = skb;\r\ncs->tx_cnt = 0;\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA_PULLED", 0);\r\n#endif\r\nisac_fill_fifo(cs);\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\ndebugl1(cs, "-> PH_REQUEST_PULL");\r\n#endif\r\nif (!cs->tx_skb) {\r\ntest_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\ntest_and_set_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (HW_RESET | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif ((cs->dc.isac.ph_state == ISAC_IND_EI) ||\r\n(cs->dc.isac.ph_state == ISAC_IND_DR) ||\r\n(cs->dc.isac.ph_state == ISAC_IND_RS))\r\nph_command(cs, ISAC_CMD_TIM);\r\nelse\r\nph_command(cs, ISAC_CMD_RS);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_ENABLE | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nph_command(cs, ISAC_CMD_TIM);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_INFO3 | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nph_command(cs, ISAC_CMD_AR8);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_TESTLOOP | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nval = 0;\r\nif (1 & (long) arg)\r\nval |= 0x0c;\r\nif (2 & (long) arg)\r\nval |= 0x3;\r\nif (test_bit(HW_IOM1, &cs->HW_Flags)) {\r\nif (!val) {\r\ncs->writeisac(cs, ISAC_SPCR, 0xa);\r\ncs->writeisac(cs, ISAC_ADF1, 0x2);\r\n} else {\r\ncs->writeisac(cs, ISAC_SPCR, val);\r\ncs->writeisac(cs, ISAC_ADF1, 0xa);\r\n}\r\n} else {\r\ncs->writeisac(cs, ISAC_SPCR, val);\r\nif (val)\r\ncs->writeisac(cs, ISAC_ADF1, 0x8);\r\nelse\r\ncs->writeisac(cs, ISAC_ADF1, 0x0);\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_DEACTIVATE | RESPONSE):\r\nskb_queue_purge(&cs->rq);\r\nskb_queue_purge(&cs->sq);\r\nif (cs->tx_skb) {\r\ndev_kfree_skb_any(cs->tx_skb);\r\ncs->tx_skb = NULL;\r\n}\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nif (test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nschedule_event(cs, D_CLEARBUSY);\r\nbreak;\r\ndefault:\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "isac_l1hw unknown %04x", pr);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nsetstack_isac(struct PStack *st, struct IsdnCardState *cs)\r\n{\r\nst->l1.l1hw = ISAC_l1hw;\r\n}\r\nstatic void\r\nDC_Close_isac(struct IsdnCardState *cs)\r\n{\r\nkfree(cs->dc.isac.mon_rx);\r\ncs->dc.isac.mon_rx = NULL;\r\nkfree(cs->dc.isac.mon_tx);\r\ncs->dc.isac.mon_tx = NULL;\r\n}\r\nstatic void\r\ndbusy_timer_handler(struct IsdnCardState *cs)\r\n{\r\nstruct PStack *stptr;\r\nint rbch, star;\r\nif (test_bit(FLG_DBUSY_TIMER, &cs->HW_Flags)) {\r\nrbch = cs->readisac(cs, ISAC_RBCH);\r\nstar = cs->readisac(cs, ISAC_STAR);\r\nif (cs->debug)\r\ndebugl1(cs, "D-Channel Busy RBCH %02x STAR %02x",\r\nrbch, star);\r\nif (rbch & ISAC_RBCH_XAC) {\r\ntest_and_set_bit(FLG_L1_DBUSY, &cs->HW_Flags);\r\nstptr = cs->stlist;\r\nwhile (stptr != NULL) {\r\nstptr->l1.l1l2(stptr, PH_PAUSE | INDICATION, NULL);\r\nstptr = stptr->next;\r\n}\r\n} else {\r\ntest_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags);\r\nif (cs->tx_skb) {\r\ndev_kfree_skb_any(cs->tx_skb);\r\ncs->tx_cnt = 0;\r\ncs->tx_skb = NULL;\r\n} else {\r\nprintk(KERN_WARNING "HiSax: ISAC D-Channel Busy no skb\n");\r\ndebugl1(cs, "D-Channel Busy no skb");\r\n}\r\ncs->writeisac(cs, ISAC_CMDR, 0x01);\r\ncs->irq_func(cs->irq, cs);\r\n}\r\n}\r\n}\r\nvoid initisac(struct IsdnCardState *cs)\r\n{\r\ncs->setstack_d = setstack_isac;\r\ncs->DC_Close = DC_Close_isac;\r\ncs->dc.isac.mon_tx = NULL;\r\ncs->dc.isac.mon_rx = NULL;\r\ncs->writeisac(cs, ISAC_MASK, 0xff);\r\ncs->dc.isac.mocr = 0xaa;\r\nif (test_bit(HW_IOM1, &cs->HW_Flags)) {\r\ncs->writeisac(cs, ISAC_ADF2, 0x0);\r\ncs->writeisac(cs, ISAC_SPCR, 0xa);\r\ncs->writeisac(cs, ISAC_ADF1, 0x2);\r\ncs->writeisac(cs, ISAC_STCR, 0x70);\r\ncs->writeisac(cs, ISAC_MODE, 0xc9);\r\n} else {\r\nif (!cs->dc.isac.adf2)\r\ncs->dc.isac.adf2 = 0x80;\r\ncs->writeisac(cs, ISAC_ADF2, cs->dc.isac.adf2);\r\ncs->writeisac(cs, ISAC_SQXR, 0x2f);\r\ncs->writeisac(cs, ISAC_SPCR, 0x00);\r\ncs->writeisac(cs, ISAC_STCR, 0x70);\r\ncs->writeisac(cs, ISAC_MODE, 0xc9);\r\ncs->writeisac(cs, ISAC_TIMR, 0x00);\r\ncs->writeisac(cs, ISAC_ADF1, 0x00);\r\n}\r\nph_command(cs, ISAC_CMD_RS);\r\ncs->writeisac(cs, ISAC_MASK, 0x0);\r\n}\r\nvoid clear_pending_isac_ints(struct IsdnCardState *cs)\r\n{\r\nint val, eval;\r\nval = cs->readisac(cs, ISAC_STAR);\r\ndebugl1(cs, "ISAC STAR %x", val);\r\nval = cs->readisac(cs, ISAC_MODE);\r\ndebugl1(cs, "ISAC MODE %x", val);\r\nval = cs->readisac(cs, ISAC_ADF2);\r\ndebugl1(cs, "ISAC ADF2 %x", val);\r\nval = cs->readisac(cs, ISAC_ISTA);\r\ndebugl1(cs, "ISAC ISTA %x", val);\r\nif (val & 0x01) {\r\neval = cs->readisac(cs, ISAC_EXIR);\r\ndebugl1(cs, "ISAC EXIR %x", eval);\r\n}\r\nval = cs->readisac(cs, ISAC_CIR0);\r\ndebugl1(cs, "ISAC CIR0 %x", val);\r\ncs->dc.isac.ph_state = (val >> 2) & 0xf;\r\nschedule_event(cs, D_L1STATECHANGE);\r\ncs->writeisac(cs, ISAC_MASK, 0xFF);\r\n}\r\nvoid setup_isac(struct IsdnCardState *cs)\r\n{\r\nINIT_WORK(&cs->tqueue, isac_bh);\r\nsetup_timer(&cs->dbusytimer, (void *)dbusy_timer_handler, (long)cs);\r\n}
