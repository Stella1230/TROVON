static inline u_int16_t get_16(const unsigned char *x)\r\n{\r\nreturn (x[1] << 8) | x[0];\r\n}\r\nstatic inline u_int32_t get_32(const unsigned char *x)\r\n{\r\nreturn (x[3] << 24) | (x[2] << 16) | (x[1] << 8) | x[0];\r\n}\r\nstatic inline u_int32_t get_24(const unsigned char *x)\r\n{\r\nreturn (x[2] << 24) | (x[1] << 16) | (x[0] << 8);\r\n}\r\nstatic void print_eisa_id(char *s, u_int32_t id)\r\n{\r\nchar vendor[4];\r\nint rev;\r\nint device;\r\nrev = id & 0xff;\r\nid >>= 8;\r\ndevice = id & 0xff;\r\nid >>= 8;\r\nvendor[3] = '\0';\r\nvendor[2] = '@' + (id & 0x1f);\r\nid >>= 5;\r\nvendor[1] = '@' + (id & 0x1f);\r\nid >>= 5;\r\nvendor[0] = '@' + (id & 0x1f);\r\nid >>= 5;\r\nsprintf(s, "%s%02X%02X", vendor, device, rev);\r\n}\r\nstatic int configure_memory(const unsigned char *buf,\r\nstruct resource *mem_parent,\r\nchar *name)\r\n{\r\nint len;\r\nu_int8_t c;\r\nint i;\r\nstruct resource *res;\r\nlen=0;\r\nfor (i=0;i<HPEE_MEMORY_MAX_ENT;i++) {\r\nc = get_8(buf+len);\r\nif (NULL != (res = kzalloc(sizeof(struct resource), GFP_KERNEL))) {\r\nint result;\r\nres->name = name;\r\nres->start = mem_parent->start + get_24(buf+len+2);\r\nres->end = res->start + get_16(buf+len+5)*1024;\r\nres->flags = IORESOURCE_MEM;\r\nprintk("memory %lx-%lx ", (unsigned long)res->start, (unsigned long)res->end);\r\nresult = request_resource(mem_parent, res);\r\nif (result < 0) {\r\nprintk(KERN_ERR "EISA Enumerator: failed to claim EISA Bus address space!\n");\r\nreturn result;\r\n}\r\n}\r\nlen+=7;\r\nif (!(c & HPEE_MEMORY_MORE)) {\r\nbreak;\r\n}\r\n}\r\nreturn len;\r\n}\r\nstatic int configure_irq(const unsigned char *buf)\r\n{\r\nint len;\r\nu_int8_t c;\r\nint i;\r\nlen=0;\r\nfor (i=0;i<HPEE_IRQ_MAX_ENT;i++) {\r\nc = get_8(buf+len);\r\nprintk("IRQ %d ", c & HPEE_IRQ_CHANNEL_MASK);\r\nif (c & HPEE_IRQ_TRIG_LEVEL) {\r\neisa_make_irq_level(c & HPEE_IRQ_CHANNEL_MASK);\r\n} else {\r\neisa_make_irq_edge(c & HPEE_IRQ_CHANNEL_MASK);\r\n}\r\nlen+=2;\r\nif (!(c & HPEE_IRQ_MORE)) {\r\nbreak;\r\n}\r\n}\r\nreturn len;\r\n}\r\nstatic int configure_dma(const unsigned char *buf)\r\n{\r\nint len;\r\nu_int8_t c;\r\nint i;\r\nlen=0;\r\nfor (i=0;i<HPEE_DMA_MAX_ENT;i++) {\r\nc = get_8(buf+len);\r\nprintk("DMA %d ", c&HPEE_DMA_CHANNEL_MASK);\r\nlen+=2;\r\nif (!(c & HPEE_DMA_MORE)) {\r\nbreak;\r\n}\r\n}\r\nreturn len;\r\n}\r\nstatic int configure_port(const unsigned char *buf, struct resource *io_parent,\r\nchar *board)\r\n{\r\nint len;\r\nu_int8_t c;\r\nint i;\r\nstruct resource *res;\r\nint result;\r\nlen=0;\r\nfor (i=0;i<HPEE_PORT_MAX_ENT;i++) {\r\nc = get_8(buf+len);\r\nif (NULL != (res = kzalloc(sizeof(struct resource), GFP_KERNEL))) {\r\nres->name = board;\r\nres->start = get_16(buf+len+1);\r\nres->end = get_16(buf+len+1)+(c&HPEE_PORT_SIZE_MASK)+1;\r\nres->flags = IORESOURCE_IO;\r\nprintk("ioports %lx-%lx ", (unsigned long)res->start, (unsigned long)res->end);\r\nresult = request_resource(io_parent, res);\r\nif (result < 0) {\r\nprintk(KERN_ERR "EISA Enumerator: failed to claim EISA Bus address space!\n");\r\nreturn result;\r\n}\r\n}\r\nlen+=3;\r\nif (!(c & HPEE_PORT_MORE)) {\r\nbreak;\r\n}\r\n}\r\nreturn len;\r\n}\r\nstatic int configure_port_init(const unsigned char *buf)\r\n{\r\nint len=0;\r\nu_int8_t c;\r\nwhile (len<HPEE_PORT_INIT_MAX_LEN) {\r\nint s=0;\r\nc = get_8(buf+len);\r\nswitch (c & HPEE_PORT_INIT_WIDTH_MASK) {\r\ncase HPEE_PORT_INIT_WIDTH_BYTE:\r\ns=1;\r\nif (c & HPEE_PORT_INIT_MASK) {\r\nprintk(KERN_WARNING "port_init: unverified mask attribute\n");\r\noutb((inb(get_16(buf+len+1) &\r\nget_8(buf+len+3)) |\r\nget_8(buf+len+4)), get_16(buf+len+1));\r\n} else {\r\noutb(get_8(buf+len+3), get_16(buf+len+1));\r\n}\r\nbreak;\r\ncase HPEE_PORT_INIT_WIDTH_WORD:\r\ns=2;\r\nif (c & HPEE_PORT_INIT_MASK) {\r\nprintk(KERN_WARNING "port_init: unverified mask attribute\n");\r\noutw((inw(get_16(buf+len+1)) &\r\nget_16(buf+len+3)) |\r\nget_16(buf+len+5),\r\nget_16(buf+len+1));\r\n} else {\r\noutw(cpu_to_le16(get_16(buf+len+3)), get_16(buf+len+1));\r\n}\r\nbreak;\r\ncase HPEE_PORT_INIT_WIDTH_DWORD:\r\ns=4;\r\nif (c & HPEE_PORT_INIT_MASK) {\r\nprintk(KERN_WARNING "port_init: unverified mask attribute\n");\r\noutl((inl(get_16(buf+len+1) &\r\nget_32(buf+len+3)) |\r\nget_32(buf+len+7)), get_16(buf+len+1));\r\n} else {\r\noutl(cpu_to_le32(get_32(buf+len+3)), get_16(buf+len+1));\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Invalid port init word %02x\n", c);\r\nreturn 0;\r\n}\r\nif (c & HPEE_PORT_INIT_MASK) {\r\ns*=2;\r\n}\r\nlen+=s+3;\r\nif (!(c & HPEE_PORT_INIT_MORE)) {\r\nbreak;\r\n}\r\n}\r\nreturn len;\r\n}\r\nstatic int configure_choise(const unsigned char *buf, u_int8_t *info)\r\n{\r\nint len;\r\nlen = get_8(buf);\r\n*info=get_8(buf+len+1);\r\nreturn len+2;\r\n}\r\nstatic int configure_type_string(const unsigned char *buf)\r\n{\r\nint len;\r\nlen = get_8(buf);\r\nif (len > 80) {\r\nprintk(KERN_ERR "eisa_enumerator: type info field too long (%d, max is 80)\n", len);\r\n}\r\nreturn 1+len;\r\n}\r\nstatic int configure_function(const unsigned char *buf, int *more)\r\n{\r\n*more = get_16(buf);\r\nreturn 2;\r\n}\r\nstatic int parse_slot_config(int slot,\r\nconst unsigned char *buf,\r\nstruct eeprom_eisa_slot_info *es,\r\nstruct resource *io_parent,\r\nstruct resource *mem_parent)\r\n{\r\nint res=0;\r\nint function_len;\r\nunsigned int pos=0;\r\nunsigned int maxlen;\r\nint num_func=0;\r\nu_int8_t flags;\r\nint p0;\r\nchar *board;\r\nint id_string_used=0;\r\nif (NULL == (board = kmalloc(8, GFP_KERNEL))) {\r\nreturn -1;\r\n}\r\nprint_eisa_id(board, es->eisa_slot_id);\r\nprintk(KERN_INFO "EISA slot %d: %s %s ",\r\nslot, board, es->flags&HPEE_FLAG_BOARD_IS_ISA ? "ISA" : "EISA");\r\nmaxlen = es->config_data_length < HPEE_MAX_LENGTH ?\r\nes->config_data_length : HPEE_MAX_LENGTH;\r\nwhile ((pos < maxlen) && (num_func <= es->num_functions)) {\r\npos+=configure_function(buf+pos, &function_len);\r\nif (!function_len) {\r\nbreak;\r\n}\r\nnum_func++;\r\np0 = pos;\r\npos += configure_choise(buf+pos, &flags);\r\nif (flags & HPEE_FUNCTION_INFO_F_DISABLED) {\r\npos = p0 + function_len;\r\ncontinue;\r\n}\r\nif (flags & HPEE_FUNCTION_INFO_CFG_FREE_FORM) {\r\nprintk("function %d have free-form configuration, skipping ",\r\nnum_func);\r\npos = p0 + function_len;\r\ncontinue;\r\n}\r\nif (flags & HPEE_FUNCTION_INFO_HAVE_TYPE) {\r\npos += configure_type_string(buf+pos);\r\n}\r\nif (flags & HPEE_FUNCTION_INFO_HAVE_MEMORY) {\r\nid_string_used=1;\r\npos += configure_memory(buf+pos, mem_parent, board);\r\n}\r\nif (flags & HPEE_FUNCTION_INFO_HAVE_IRQ) {\r\npos += configure_irq(buf+pos);\r\n}\r\nif (flags & HPEE_FUNCTION_INFO_HAVE_DMA) {\r\npos += configure_dma(buf+pos);\r\n}\r\nif (flags & HPEE_FUNCTION_INFO_HAVE_PORT) {\r\nid_string_used=1;\r\npos += configure_port(buf+pos, io_parent, board);\r\n}\r\nif (flags & HPEE_FUNCTION_INFO_HAVE_PORT_INIT) {\r\npos += configure_port_init(buf+pos);\r\n}\r\nif (p0 + function_len < pos) {\r\nprintk(KERN_ERR "eisa_enumerator: function %d length mis-match "\r\n"got %d, expected %d\n",\r\nnum_func, pos-p0, function_len);\r\nres=-1;\r\nbreak;\r\n}\r\npos = p0 + function_len;\r\n}\r\nprintk("\n");\r\nif (!id_string_used) {\r\nkfree(board);\r\n}\r\nif (pos != es->config_data_length) {\r\nprintk(KERN_ERR "eisa_enumerator: config data length mis-match got %d, expected %d\n",\r\npos, es->config_data_length);\r\nres=-1;\r\n}\r\nif (num_func != es->num_functions) {\r\nprintk(KERN_ERR "eisa_enumerator: number of functions mis-match got %d, expected %d\n",\r\nnum_func, es->num_functions);\r\nres=-2;\r\n}\r\nreturn res;\r\n}\r\nstatic int init_slot(int slot, struct eeprom_eisa_slot_info *es)\r\n{\r\nunsigned int id;\r\nchar id_string[8];\r\nif (!(es->slot_info&HPEE_SLOT_INFO_NO_READID)) {\r\nid = le32_to_cpu(inl(SLOT2PORT(slot)+EPI));\r\nif (0xffffffff == id) {\r\nif (es->eisa_slot_id == 0xffffffff)\r\nreturn -1;\r\nprintk(KERN_ERR "EISA slot %d a configured board was not detected (",\r\nslot);\r\nprint_eisa_id(id_string, es->eisa_slot_id);\r\nprintk(" expected %s)\n", id_string);\r\nreturn -1;\r\n}\r\nif (es->eisa_slot_id != id) {\r\nprint_eisa_id(id_string, id);\r\nprintk(KERN_ERR "EISA slot %d id mis-match: got %s",\r\nslot, id_string);\r\nprint_eisa_id(id_string, es->eisa_slot_id);\r\nprintk(" expected %s\n", id_string);\r\nreturn -1;\r\n}\r\n}\r\nif (es->slot_features & HPEE_SLOT_FEATURES_ENABLE) {\r\noutb(0x01| inb(SLOT2PORT(slot)+EPI+4),\r\nSLOT2PORT(slot)+EPI+4);\r\n}\r\nreturn 0;\r\n}\r\nint eisa_enumerator(unsigned long eeprom_addr,\r\nstruct resource *io_parent, struct resource *mem_parent)\r\n{\r\nint i;\r\nstruct eeprom_header *eh;\r\nstatic char eeprom_buf[HPEE_MAX_LENGTH];\r\nfor (i=0; i < HPEE_MAX_LENGTH; i++) {\r\neeprom_buf[i] = gsc_readb(eeprom_addr+i);\r\n}\r\nprintk(KERN_INFO "Enumerating EISA bus\n");\r\neh = (struct eeprom_header*)(eeprom_buf);\r\nfor (i=0;i<eh->num_slots;i++) {\r\nstruct eeprom_eisa_slot_info *es;\r\nes = (struct eeprom_eisa_slot_info*)\r\n(&eeprom_buf[HPEE_SLOT_INFO(i)]);\r\nif (-1==init_slot(i+1, es)) {\r\ncontinue;\r\n}\r\nif (es->config_data_offset < HPEE_MAX_LENGTH) {\r\nif (parse_slot_config(i+1, &eeprom_buf[es->config_data_offset],\r\nes, io_parent, mem_parent)) {\r\nreturn -1;\r\n}\r\n} else {\r\nprintk (KERN_WARNING "EISA EEPROM offset 0x%x out of range\n",es->config_data_offset);\r\nreturn -1;\r\n}\r\n}\r\nreturn eh->num_slots;\r\n}
