static void oaktrail_lvds_set_power(struct drm_device *dev,\r\nstruct gma_encoder *gma_encoder,\r\nbool on)\r\n{\r\nu32 pp_status;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (!gma_power_begin(dev, true))\r\nreturn;\r\nif (on) {\r\nREG_WRITE(PP_CONTROL, REG_READ(PP_CONTROL) |\r\nPOWER_TARGET_ON);\r\ndo {\r\npp_status = REG_READ(PP_STATUS);\r\n} while ((pp_status & (PP_ON | PP_READY)) == PP_READY);\r\ndev_priv->is_lvds_on = true;\r\nif (dev_priv->ops->lvds_bl_power)\r\ndev_priv->ops->lvds_bl_power(dev, true);\r\n} else {\r\nif (dev_priv->ops->lvds_bl_power)\r\ndev_priv->ops->lvds_bl_power(dev, false);\r\nREG_WRITE(PP_CONTROL, REG_READ(PP_CONTROL) &\r\n~POWER_TARGET_ON);\r\ndo {\r\npp_status = REG_READ(PP_STATUS);\r\n} while (pp_status & PP_ON);\r\ndev_priv->is_lvds_on = false;\r\npm_request_idle(&dev->pdev->dev);\r\n}\r\ngma_power_end(dev);\r\n}\r\nstatic void oaktrail_lvds_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct gma_encoder *gma_encoder = to_gma_encoder(encoder);\r\nif (mode == DRM_MODE_DPMS_ON)\r\noaktrail_lvds_set_power(dev, gma_encoder, true);\r\nelse\r\noaktrail_lvds_set_power(dev, gma_encoder, false);\r\n}\r\nstatic void oaktrail_lvds_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct drm_connector *connector = NULL;\r\nstruct drm_crtc *crtc = encoder->crtc;\r\nu32 lvds_port;\r\nuint64_t v = DRM_MODE_SCALE_FULLSCREEN;\r\nif (!gma_power_begin(dev, true))\r\nreturn;\r\nlvds_port = (REG_READ(LVDS) &\r\n(~LVDS_PIPEB_SELECT)) |\r\nLVDS_PORT_EN |\r\nLVDS_BORDER_EN;\r\nif (mode_dev->panel_wants_dither || dev_priv->lvds_dither)\r\nlvds_port |= MRST_PANEL_8TO6_DITHER_ENABLE;\r\nREG_WRITE(LVDS, lvds_port);\r\nlist_for_each_entry(connector, &mode_config->connector_list, head) {\r\nif (!connector->encoder || connector->encoder->crtc != crtc)\r\ncontinue;\r\n}\r\nif (!connector) {\r\nDRM_ERROR("Couldn't find connector when setting mode");\r\nreturn;\r\n}\r\ndrm_object_property_get_value(\r\n&connector->base,\r\ndev->mode_config.scaling_mode_property,\r\n&v);\r\nif (v == DRM_MODE_SCALE_NO_SCALE)\r\nREG_WRITE(PFIT_CONTROL, 0);\r\nelse if (v == DRM_MODE_SCALE_ASPECT) {\r\nif ((mode->vdisplay != adjusted_mode->crtc_vdisplay) ||\r\n(mode->hdisplay != adjusted_mode->crtc_hdisplay)) {\r\nif ((adjusted_mode->crtc_hdisplay * mode->vdisplay) ==\r\n(mode->hdisplay * adjusted_mode->crtc_vdisplay))\r\nREG_WRITE(PFIT_CONTROL, PFIT_ENABLE);\r\nelse if ((adjusted_mode->crtc_hdisplay *\r\nmode->vdisplay) > (mode->hdisplay *\r\nadjusted_mode->crtc_vdisplay))\r\nREG_WRITE(PFIT_CONTROL, PFIT_ENABLE |\r\nPFIT_SCALING_MODE_PILLARBOX);\r\nelse\r\nREG_WRITE(PFIT_CONTROL, PFIT_ENABLE |\r\nPFIT_SCALING_MODE_LETTERBOX);\r\n} else\r\nREG_WRITE(PFIT_CONTROL, PFIT_ENABLE);\r\n} else\r\nREG_WRITE(PFIT_CONTROL, PFIT_ENABLE);\r\ngma_power_end(dev);\r\n}\r\nstatic void oaktrail_lvds_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_encoder *gma_encoder = to_gma_encoder(encoder);\r\nstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\r\nif (!gma_power_begin(dev, true))\r\nreturn;\r\nmode_dev->saveBLC_PWM_CTL = REG_READ(BLC_PWM_CTL);\r\nmode_dev->backlight_duty_cycle = (mode_dev->saveBLC_PWM_CTL &\r\nBACKLIGHT_DUTY_CYCLE_MASK);\r\noaktrail_lvds_set_power(dev, gma_encoder, false);\r\ngma_power_end(dev);\r\n}\r\nstatic u32 oaktrail_lvds_get_max_backlight(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 ret;\r\nif (gma_power_begin(dev, false)) {\r\nret = ((REG_READ(BLC_PWM_CTL) &\r\nBACKLIGHT_MODULATION_FREQ_MASK) >>\r\nBACKLIGHT_MODULATION_FREQ_SHIFT) * 2;\r\ngma_power_end(dev);\r\n} else\r\nret = ((dev_priv->regs.saveBLC_PWM_CTL &\r\nBACKLIGHT_MODULATION_FREQ_MASK) >>\r\nBACKLIGHT_MODULATION_FREQ_SHIFT) * 2;\r\nreturn ret;\r\n}\r\nstatic void oaktrail_lvds_commit(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_encoder *gma_encoder = to_gma_encoder(encoder);\r\nstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\r\nif (mode_dev->backlight_duty_cycle == 0)\r\nmode_dev->backlight_duty_cycle =\r\noaktrail_lvds_get_max_backlight(dev);\r\noaktrail_lvds_set_power(dev, gma_encoder, true);\r\n}\r\nstatic void oaktrail_lvds_get_configuration_mode(struct drm_device *dev,\r\nstruct psb_intel_mode_device *mode_dev)\r\n{\r\nstruct drm_display_mode *mode = NULL;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct oaktrail_timing_info *ti = &dev_priv->gct_data.DTD;\r\nmode_dev->panel_fixed_mode = NULL;\r\nif (dev_priv->has_gct) {\r\nmode = kzalloc(sizeof(*mode), GFP_KERNEL);\r\nif (!mode)\r\nreturn;\r\nmode->hdisplay = (ti->hactive_hi << 8) | ti->hactive_lo;\r\nmode->vdisplay = (ti->vactive_hi << 8) | ti->vactive_lo;\r\nmode->hsync_start = mode->hdisplay + \\r\n((ti->hsync_offset_hi << 8) | \\r\nti->hsync_offset_lo);\r\nmode->hsync_end = mode->hsync_start + \\r\n((ti->hsync_pulse_width_hi << 8) | \\r\nti->hsync_pulse_width_lo);\r\nmode->htotal = mode->hdisplay + ((ti->hblank_hi << 8) | \\r\nti->hblank_lo);\r\nmode->vsync_start = \\r\nmode->vdisplay + ((ti->vsync_offset_hi << 4) | \\r\nti->vsync_offset_lo);\r\nmode->vsync_end = \\r\nmode->vsync_start + ((ti->vsync_pulse_width_hi << 4) | \\r\nti->vsync_pulse_width_lo);\r\nmode->vtotal = mode->vdisplay + \\r\n((ti->vblank_hi << 8) | ti->vblank_lo);\r\nmode->clock = ti->pixel_clock * 10;\r\n#if 0\r\npr_info("hdisplay is %d\n", mode->hdisplay);\r\npr_info("vdisplay is %d\n", mode->vdisplay);\r\npr_info("HSS is %d\n", mode->hsync_start);\r\npr_info("HSE is %d\n", mode->hsync_end);\r\npr_info("htotal is %d\n", mode->htotal);\r\npr_info("VSS is %d\n", mode->vsync_start);\r\npr_info("VSE is %d\n", mode->vsync_end);\r\npr_info("vtotal is %d\n", mode->vtotal);\r\npr_info("clock is %d\n", mode->clock);\r\n#endif\r\nmode_dev->panel_fixed_mode = mode;\r\n}\r\nif (mode_dev->panel_fixed_mode == NULL && mode_dev->vbt_mode)\r\nmode_dev->panel_fixed_mode = drm_mode_duplicate(dev,\r\nmode_dev->vbt_mode);\r\nif (mode_dev->panel_fixed_mode == NULL)\r\nif (dev_priv->lfp_lvds_vbt_mode)\r\nmode_dev->panel_fixed_mode =\r\ndrm_mode_duplicate(dev,\r\ndev_priv->lfp_lvds_vbt_mode);\r\nif (mode_dev->panel_fixed_mode == NULL)\r\nreturn;\r\ndrm_mode_set_name(mode_dev->panel_fixed_mode);\r\ndrm_mode_set_crtcinfo(mode_dev->panel_fixed_mode, 0);\r\n}\r\nvoid oaktrail_lvds_init(struct drm_device *dev,\r\nstruct psb_intel_mode_device *mode_dev)\r\n{\r\nstruct gma_encoder *gma_encoder;\r\nstruct gma_connector *gma_connector;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct edid *edid;\r\nstruct i2c_adapter *i2c_adap;\r\nstruct drm_display_mode *scan;\r\ngma_encoder = kzalloc(sizeof(struct gma_encoder), GFP_KERNEL);\r\nif (!gma_encoder)\r\nreturn;\r\ngma_connector = kzalloc(sizeof(struct gma_connector), GFP_KERNEL);\r\nif (!gma_connector)\r\ngoto failed_connector;\r\nconnector = &gma_connector->base;\r\nencoder = &gma_encoder->base;\r\ndev_priv->is_lvds_on = true;\r\ndrm_connector_init(dev, connector,\r\n&psb_intel_lvds_connector_funcs,\r\nDRM_MODE_CONNECTOR_LVDS);\r\ndrm_encoder_init(dev, encoder, &psb_intel_lvds_enc_funcs,\r\nDRM_MODE_ENCODER_LVDS, NULL);\r\ngma_connector_attach_encoder(gma_connector, gma_encoder);\r\ngma_encoder->type = INTEL_OUTPUT_LVDS;\r\ndrm_encoder_helper_add(encoder, &oaktrail_lvds_helper_funcs);\r\ndrm_connector_helper_add(connector,\r\n&psb_intel_lvds_connector_helper_funcs);\r\nconnector->display_info.subpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_FULLSCREEN);\r\ndrm_object_attach_property(&connector->base,\r\ndev_priv->backlight_property,\r\nBRIGHTNESS_MAX_LEVEL);\r\nmode_dev->panel_wants_dither = false;\r\nif (dev_priv->has_gct)\r\nmode_dev->panel_wants_dither = (dev_priv->gct_data.\r\nPanel_Port_Control & MRST_PANEL_8TO6_DITHER_ENABLE);\r\nif (dev_priv->lvds_dither)\r\nmode_dev->panel_wants_dither = 1;\r\nedid = NULL;\r\nmutex_lock(&dev->mode_config.mutex);\r\ni2c_adap = i2c_get_adapter(dev_priv->ops->i2c_bus);\r\nif (i2c_adap)\r\nedid = drm_get_edid(connector, i2c_adap);\r\nif (edid == NULL && dev_priv->lpc_gpio_base) {\r\noaktrail_lvds_i2c_init(encoder);\r\nif (gma_encoder->ddc_bus != NULL) {\r\ni2c_adap = &gma_encoder->ddc_bus->adapter;\r\nedid = drm_get_edid(connector, i2c_adap);\r\n}\r\n}\r\nif (edid) {\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\ndrm_add_edid_modes(connector, edid);\r\nkfree(edid);\r\nlist_for_each_entry(scan, &connector->probed_modes, head) {\r\nif (scan->type & DRM_MODE_TYPE_PREFERRED) {\r\nmode_dev->panel_fixed_mode =\r\ndrm_mode_duplicate(dev, scan);\r\ngoto out;\r\n}\r\n}\r\n} else\r\ndev_err(dev->dev, "No ddc adapter available!\n");\r\noaktrail_lvds_get_configuration_mode(dev, mode_dev);\r\nif (mode_dev->panel_fixed_mode) {\r\nmode_dev->panel_fixed_mode->type |= DRM_MODE_TYPE_PREFERRED;\r\ngoto out;\r\n}\r\nif (!mode_dev->panel_fixed_mode) {\r\ndev_err(dev->dev, "Found no modes on the lvds, ignoring the LVDS\n");\r\ngoto failed_find;\r\n}\r\nout:\r\nmutex_unlock(&dev->mode_config.mutex);\r\ndrm_connector_register(connector);\r\nreturn;\r\nfailed_find:\r\nmutex_unlock(&dev->mode_config.mutex);\r\ndev_dbg(dev->dev, "No LVDS modes found, disabling.\n");\r\nif (gma_encoder->ddc_bus) {\r\npsb_intel_i2c_destroy(gma_encoder->ddc_bus);\r\ngma_encoder->ddc_bus = NULL;\r\n}\r\ndrm_encoder_cleanup(encoder);\r\ndrm_connector_cleanup(connector);\r\nkfree(gma_connector);\r\nfailed_connector:\r\nkfree(gma_encoder);\r\n}
