static int ad5820_write(struct ad5820_device *coil, u16 data)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&coil->subdev);\r\nstruct i2c_msg msg;\r\n__be16 be_data;\r\nint r;\r\nif (!client->adapter)\r\nreturn -ENODEV;\r\nbe_data = cpu_to_be16(data);\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = 2;\r\nmsg.buf = (u8 *)&be_data;\r\nr = i2c_transfer(client->adapter, &msg, 1);\r\nif (r < 0) {\r\ndev_err(&client->dev, "write failed, error %d\n", r);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ad5820_update_hw(struct ad5820_device *coil)\r\n{\r\nu16 status;\r\nstatus = RAMP_US_TO_CODE(coil->focus_ramp_time);\r\nstatus |= coil->focus_ramp_mode\r\n? AD5820_RAMP_MODE_64_16 : AD5820_RAMP_MODE_LINEAR;\r\nstatus |= coil->focus_absolute << AD5820_DAC_SHIFT;\r\nif (coil->standby)\r\nstatus |= AD5820_POWER_DOWN;\r\nreturn ad5820_write(coil, status);\r\n}\r\nstatic int ad5820_power_off(struct ad5820_device *coil, bool standby)\r\n{\r\nint ret = 0, ret2;\r\nif (standby) {\r\ncoil->standby = true;\r\nret = ad5820_update_hw(coil);\r\n}\r\nret2 = regulator_disable(coil->vana);\r\nif (ret)\r\nreturn ret;\r\nreturn ret2;\r\n}\r\nstatic int ad5820_power_on(struct ad5820_device *coil, bool restore)\r\n{\r\nint ret;\r\nret = regulator_enable(coil->vana);\r\nif (ret < 0)\r\nreturn ret;\r\nif (restore) {\r\ncoil->standby = false;\r\nret = ad5820_update_hw(coil);\r\nif (ret)\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\ncoil->standby = true;\r\nregulator_disable(coil->vana);\r\nreturn ret;\r\n}\r\nstatic int ad5820_set_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct ad5820_device *coil =\r\ncontainer_of(ctrl->handler, struct ad5820_device, ctrls);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_FOCUS_ABSOLUTE:\r\ncoil->focus_absolute = ctrl->val;\r\nreturn ad5820_update_hw(coil);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ad5820_init_controls(struct ad5820_device *coil)\r\n{\r\nv4l2_ctrl_handler_init(&coil->ctrls, 1);\r\nv4l2_ctrl_new_std(&coil->ctrls, &ad5820_ctrl_ops,\r\nV4L2_CID_FOCUS_ABSOLUTE, 0, 1023, 1, 0);\r\nif (coil->ctrls.error)\r\nreturn coil->ctrls.error;\r\ncoil->focus_absolute = 0;\r\ncoil->focus_ramp_time = 0;\r\ncoil->focus_ramp_mode = 0;\r\ncoil->subdev.ctrl_handler = &coil->ctrls;\r\nreturn 0;\r\n}\r\nstatic int ad5820_registered(struct v4l2_subdev *subdev)\r\n{\r\nstruct ad5820_device *coil = to_ad5820_device(subdev);\r\nreturn ad5820_init_controls(coil);\r\n}\r\nstatic int\r\nad5820_set_power(struct v4l2_subdev *subdev, int on)\r\n{\r\nstruct ad5820_device *coil = to_ad5820_device(subdev);\r\nint ret = 0;\r\nmutex_lock(&coil->power_lock);\r\nif (coil->power_count == !on) {\r\nret = on ? ad5820_power_on(coil, true) :\r\nad5820_power_off(coil, true);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\ncoil->power_count += on ? 1 : -1;\r\nWARN_ON(coil->power_count < 0);\r\ndone:\r\nmutex_unlock(&coil->power_lock);\r\nreturn ret;\r\n}\r\nstatic int ad5820_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nreturn ad5820_set_power(sd, 1);\r\n}\r\nstatic int ad5820_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nreturn ad5820_set_power(sd, 0);\r\n}\r\nstatic int __maybe_unused ad5820_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct ad5820_device *coil = to_ad5820_device(subdev);\r\nif (!coil->power_count)\r\nreturn 0;\r\nreturn ad5820_power_off(coil, false);\r\n}\r\nstatic int __maybe_unused ad5820_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct ad5820_device *coil = to_ad5820_device(subdev);\r\nif (!coil->power_count)\r\nreturn 0;\r\nreturn ad5820_power_on(coil, true);\r\n}\r\nstatic int ad5820_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *devid)\r\n{\r\nstruct ad5820_device *coil;\r\nint ret;\r\ncoil = devm_kzalloc(&client->dev, sizeof(*coil), GFP_KERNEL);\r\nif (!coil)\r\nreturn -ENOMEM;\r\ncoil->vana = devm_regulator_get(&client->dev, "VANA");\r\nif (IS_ERR(coil->vana)) {\r\nret = PTR_ERR(coil->vana);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(&client->dev, "could not get regulator for vana\n");\r\nreturn ret;\r\n}\r\nmutex_init(&coil->power_lock);\r\nv4l2_i2c_subdev_init(&coil->subdev, client, &ad5820_ops);\r\ncoil->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\ncoil->subdev.internal_ops = &ad5820_internal_ops;\r\nstrcpy(coil->subdev.name, "ad5820 focus");\r\nret = media_entity_pads_init(&coil->subdev.entity, 0, NULL);\r\nif (ret < 0)\r\ngoto cleanup2;\r\nret = v4l2_async_register_subdev(&coil->subdev);\r\nif (ret < 0)\r\ngoto cleanup;\r\nreturn ret;\r\ncleanup2:\r\nmutex_destroy(&coil->power_lock);\r\ncleanup:\r\nmedia_entity_cleanup(&coil->subdev.entity);\r\nreturn ret;\r\n}\r\nstatic int ad5820_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct ad5820_device *coil = to_ad5820_device(subdev);\r\nv4l2_async_unregister_subdev(&coil->subdev);\r\nv4l2_ctrl_handler_free(&coil->ctrls);\r\nmedia_entity_cleanup(&coil->subdev.entity);\r\nmutex_destroy(&coil->power_lock);\r\nreturn 0;\r\n}
