static inline void *next_platform_timer(void *platform_timer)\r\n{\r\nstruct acpi_gtdt_header *gh = platform_timer;\r\nplatform_timer += gh->length;\r\nif (platform_timer < acpi_gtdt_desc.gtdt_end)\r\nreturn platform_timer;\r\nreturn NULL;\r\n}\r\nstatic inline bool is_timer_block(void *platform_timer)\r\n{\r\nstruct acpi_gtdt_header *gh = platform_timer;\r\nreturn gh->type == ACPI_GTDT_TYPE_TIMER_BLOCK;\r\n}\r\nstatic inline bool is_non_secure_watchdog(void *platform_timer)\r\n{\r\nstruct acpi_gtdt_header *gh = platform_timer;\r\nstruct acpi_gtdt_watchdog *wd = platform_timer;\r\nif (gh->type != ACPI_GTDT_TYPE_WATCHDOG)\r\nreturn false;\r\nreturn !(wd->timer_flags & ACPI_GTDT_WATCHDOG_SECURE);\r\n}\r\nstatic int __init map_gt_gsi(u32 interrupt, u32 flags)\r\n{\r\nint trigger, polarity;\r\ntrigger = (flags & ACPI_GTDT_INTERRUPT_MODE) ? ACPI_EDGE_SENSITIVE\r\n: ACPI_LEVEL_SENSITIVE;\r\npolarity = (flags & ACPI_GTDT_INTERRUPT_POLARITY) ? ACPI_ACTIVE_LOW\r\n: ACPI_ACTIVE_HIGH;\r\nreturn acpi_register_gsi(NULL, interrupt, trigger, polarity);\r\n}\r\nint __init acpi_gtdt_map_ppi(int type)\r\n{\r\nstruct acpi_table_gtdt *gtdt = acpi_gtdt_desc.gtdt;\r\nswitch (type) {\r\ncase ARCH_TIMER_PHYS_NONSECURE_PPI:\r\nreturn map_gt_gsi(gtdt->non_secure_el1_interrupt,\r\ngtdt->non_secure_el1_flags);\r\ncase ARCH_TIMER_VIRT_PPI:\r\nreturn map_gt_gsi(gtdt->virtual_timer_interrupt,\r\ngtdt->virtual_timer_flags);\r\ncase ARCH_TIMER_HYP_PPI:\r\nreturn map_gt_gsi(gtdt->non_secure_el2_interrupt,\r\ngtdt->non_secure_el2_flags);\r\ndefault:\r\npr_err("Failed to map timer interrupt: invalid type.\n");\r\n}\r\nreturn 0;\r\n}\r\nbool __init acpi_gtdt_c3stop(int type)\r\n{\r\nstruct acpi_table_gtdt *gtdt = acpi_gtdt_desc.gtdt;\r\nswitch (type) {\r\ncase ARCH_TIMER_PHYS_NONSECURE_PPI:\r\nreturn !(gtdt->non_secure_el1_flags & ACPI_GTDT_ALWAYS_ON);\r\ncase ARCH_TIMER_VIRT_PPI:\r\nreturn !(gtdt->virtual_timer_flags & ACPI_GTDT_ALWAYS_ON);\r\ncase ARCH_TIMER_HYP_PPI:\r\nreturn !(gtdt->non_secure_el2_flags & ACPI_GTDT_ALWAYS_ON);\r\ndefault:\r\npr_err("Failed to get c3stop info: invalid type.\n");\r\n}\r\nreturn false;\r\n}\r\nint __init acpi_gtdt_init(struct acpi_table_header *table,\r\nint *platform_timer_count)\r\n{\r\nvoid *platform_timer;\r\nstruct acpi_table_gtdt *gtdt;\r\ngtdt = container_of(table, struct acpi_table_gtdt, header);\r\nacpi_gtdt_desc.gtdt = gtdt;\r\nacpi_gtdt_desc.gtdt_end = (void *)table + table->length;\r\nacpi_gtdt_desc.platform_timer = NULL;\r\nif (platform_timer_count)\r\n*platform_timer_count = 0;\r\nif (table->revision < 2) {\r\npr_warn("Revision:%d doesn't support Platform Timers.\n",\r\ntable->revision);\r\nreturn 0;\r\n}\r\nif (!gtdt->platform_timer_count) {\r\npr_debug("No Platform Timer.\n");\r\nreturn 0;\r\n}\r\nplatform_timer = (void *)gtdt + gtdt->platform_timer_offset;\r\nif (platform_timer < (void *)table + sizeof(struct acpi_table_gtdt)) {\r\npr_err(FW_BUG "invalid timer data.\n");\r\nreturn -EINVAL;\r\n}\r\nacpi_gtdt_desc.platform_timer = platform_timer;\r\nif (platform_timer_count)\r\n*platform_timer_count = gtdt->platform_timer_count;\r\nreturn 0;\r\n}\r\nstatic int __init gtdt_parse_timer_block(struct acpi_gtdt_timer_block *block,\r\nstruct arch_timer_mem *timer_mem)\r\n{\r\nint i;\r\nstruct arch_timer_mem_frame *frame;\r\nstruct acpi_gtdt_timer_entry *gtdt_frame;\r\nif (!block->timer_count) {\r\npr_err(FW_BUG "GT block present, but frame count is zero.");\r\nreturn -ENODEV;\r\n}\r\nif (block->timer_count > ARCH_TIMER_MEM_MAX_FRAMES) {\r\npr_err(FW_BUG "GT block lists %d frames, ACPI spec only allows 8\n",\r\nblock->timer_count);\r\nreturn -EINVAL;\r\n}\r\ntimer_mem->cntctlbase = (phys_addr_t)block->block_address;\r\ntimer_mem->size = SZ_4K;\r\ngtdt_frame = (void *)block + block->timer_offset;\r\nif (gtdt_frame + block->timer_count != (void *)block + block->header.length)\r\nreturn -EINVAL;\r\nfor (i = 0; i < block->timer_count; i++, gtdt_frame++) {\r\nif (gtdt_frame->common_flags & ACPI_GTDT_GT_IS_SECURE_TIMER)\r\ncontinue;\r\nif (gtdt_frame->frame_number >= ARCH_TIMER_MEM_MAX_FRAMES ||\r\n!gtdt_frame->base_address || !gtdt_frame->timer_interrupt)\r\ngoto error;\r\nframe = &timer_mem->frame[gtdt_frame->frame_number];\r\nif (frame->valid)\r\ngoto error;\r\nframe->phys_irq = map_gt_gsi(gtdt_frame->timer_interrupt,\r\ngtdt_frame->timer_flags);\r\nif (frame->phys_irq <= 0) {\r\npr_warn("failed to map physical timer irq in frame %d.\n",\r\ngtdt_frame->frame_number);\r\ngoto error;\r\n}\r\nif (gtdt_frame->virtual_timer_interrupt) {\r\nframe->virt_irq =\r\nmap_gt_gsi(gtdt_frame->virtual_timer_interrupt,\r\ngtdt_frame->virtual_timer_flags);\r\nif (frame->virt_irq <= 0) {\r\npr_warn("failed to map virtual timer irq in frame %d.\n",\r\ngtdt_frame->frame_number);\r\ngoto error;\r\n}\r\n} else {\r\npr_debug("virtual timer in frame %d not implemented.\n",\r\ngtdt_frame->frame_number);\r\n}\r\nframe->cntbase = gtdt_frame->base_address;\r\nframe->size = SZ_4K;\r\nframe->valid = true;\r\n}\r\nreturn 0;\r\nerror:\r\ndo {\r\nif (gtdt_frame->common_flags & ACPI_GTDT_GT_IS_SECURE_TIMER ||\r\ngtdt_frame->frame_number >= ARCH_TIMER_MEM_MAX_FRAMES)\r\ncontinue;\r\nframe = &timer_mem->frame[gtdt_frame->frame_number];\r\nif (frame->phys_irq > 0)\r\nacpi_unregister_gsi(gtdt_frame->timer_interrupt);\r\nframe->phys_irq = 0;\r\nif (frame->virt_irq > 0)\r\nacpi_unregister_gsi(gtdt_frame->virtual_timer_interrupt);\r\nframe->virt_irq = 0;\r\n} while (i-- >= 0 && gtdt_frame--);\r\nreturn -EINVAL;\r\n}\r\nint __init acpi_arch_timer_mem_init(struct arch_timer_mem *timer_mem,\r\nint *timer_count)\r\n{\r\nint ret;\r\nvoid *platform_timer;\r\n*timer_count = 0;\r\nfor_each_platform_timer(platform_timer) {\r\nif (is_timer_block(platform_timer)) {\r\nret = gtdt_parse_timer_block(platform_timer, timer_mem);\r\nif (ret)\r\nreturn ret;\r\ntimer_mem++;\r\n(*timer_count)++;\r\n}\r\n}\r\nif (*timer_count)\r\npr_info("found %d memory-mapped timer block(s).\n",\r\n*timer_count);\r\nreturn 0;\r\n}\r\nstatic int __init gtdt_import_sbsa_gwdt(struct acpi_gtdt_watchdog *wd,\r\nint index)\r\n{\r\nstruct platform_device *pdev;\r\nint irq = map_gt_gsi(wd->timer_interrupt, wd->timer_flags);\r\nstruct resource res[] = {\r\nDEFINE_RES_MEM(wd->control_frame_address, SZ_4K),\r\nDEFINE_RES_MEM(wd->refresh_frame_address, SZ_4K),\r\nDEFINE_RES_IRQ(irq),\r\n};\r\nint nr_res = ARRAY_SIZE(res);\r\npr_debug("found a Watchdog (0x%llx/0x%llx gsi:%u flags:0x%x).\n",\r\nwd->refresh_frame_address, wd->control_frame_address,\r\nwd->timer_interrupt, wd->timer_flags);\r\nif (!(wd->refresh_frame_address && wd->control_frame_address)) {\r\npr_err(FW_BUG "failed to get the Watchdog base address.\n");\r\nacpi_unregister_gsi(wd->timer_interrupt);\r\nreturn -EINVAL;\r\n}\r\nif (irq <= 0) {\r\npr_warn("failed to map the Watchdog interrupt.\n");\r\nnr_res--;\r\n}\r\npdev = platform_device_register_simple("sbsa-gwdt", index, res, nr_res);\r\nif (IS_ERR(pdev)) {\r\nacpi_unregister_gsi(wd->timer_interrupt);\r\nreturn PTR_ERR(pdev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init gtdt_sbsa_gwdt_init(void)\r\n{\r\nvoid *platform_timer;\r\nstruct acpi_table_header *table;\r\nint ret, timer_count, gwdt_count = 0;\r\nif (acpi_disabled)\r\nreturn 0;\r\nif (ACPI_FAILURE(acpi_get_table(ACPI_SIG_GTDT, 0, &table)))\r\nreturn -EINVAL;\r\nret = acpi_gtdt_init(table, &timer_count);\r\nif (ret || !timer_count)\r\nreturn ret;\r\nfor_each_platform_timer(platform_timer) {\r\nif (is_non_secure_watchdog(platform_timer)) {\r\nret = gtdt_import_sbsa_gwdt(platform_timer, gwdt_count);\r\nif (ret)\r\nbreak;\r\ngwdt_count++;\r\n}\r\n}\r\nif (gwdt_count)\r\npr_info("found %d SBSA generic Watchdog(s).\n", gwdt_count);\r\nreturn ret;\r\n}
