static u32 set_hsync_pulse_width(struct mxsfb_drm_private *mxsfb, u32 val)\r\n{\r\nreturn (val & mxsfb->devdata->hs_wdth_mask) <<\r\nmxsfb->devdata->hs_wdth_shift;\r\n}\r\nstatic int mxsfb_set_pixel_fmt(struct mxsfb_drm_private *mxsfb)\r\n{\r\nstruct drm_crtc *crtc = &mxsfb->pipe.crtc;\r\nstruct drm_device *drm = crtc->dev;\r\nconst u32 format = crtc->primary->state->fb->format->format;\r\nu32 ctrl, ctrl1;\r\nctrl = CTRL_BYPASS_COUNT | CTRL_MASTER;\r\nctrl1 = readl(mxsfb->base + LCDC_CTRL1);\r\nctrl1 &= CTRL1_CUR_FRAME_DONE_IRQ_EN | CTRL1_CUR_FRAME_DONE_IRQ;\r\nswitch (format) {\r\ncase DRM_FORMAT_RGB565:\r\ndev_dbg(drm->dev, "Setting up RGB565 mode\n");\r\nctrl |= CTRL_SET_WORD_LENGTH(0);\r\nctrl1 |= CTRL1_SET_BYTE_PACKAGING(0xf);\r\nbreak;\r\ncase DRM_FORMAT_XRGB8888:\r\ndev_dbg(drm->dev, "Setting up XRGB8888 mode\n");\r\nctrl |= CTRL_SET_WORD_LENGTH(3);\r\nctrl1 |= CTRL1_SET_BYTE_PACKAGING(0x7);\r\nbreak;\r\ndefault:\r\ndev_err(drm->dev, "Unhandled pixel format %08x\n", format);\r\nreturn -EINVAL;\r\n}\r\nwritel(ctrl1, mxsfb->base + LCDC_CTRL1);\r\nwritel(ctrl, mxsfb->base + LCDC_CTRL);\r\nreturn 0;\r\n}\r\nstatic void mxsfb_set_bus_fmt(struct mxsfb_drm_private *mxsfb)\r\n{\r\nstruct drm_crtc *crtc = &mxsfb->pipe.crtc;\r\nstruct drm_device *drm = crtc->dev;\r\nu32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;\r\nu32 reg;\r\nreg = readl(mxsfb->base + LCDC_CTRL);\r\nif (mxsfb->connector.display_info.num_bus_formats)\r\nbus_format = mxsfb->connector.display_info.bus_formats[0];\r\nreg &= ~CTRL_BUS_WIDTH_MASK;\r\nswitch (bus_format) {\r\ncase MEDIA_BUS_FMT_RGB565_1X16:\r\nreg |= CTRL_SET_BUS_WIDTH(STMLCDIF_16BIT);\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB666_1X18:\r\nreg |= CTRL_SET_BUS_WIDTH(STMLCDIF_18BIT);\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB888_1X24:\r\nreg |= CTRL_SET_BUS_WIDTH(STMLCDIF_24BIT);\r\nbreak;\r\ndefault:\r\ndev_err(drm->dev, "Unknown media bus format %d\n", bus_format);\r\nbreak;\r\n}\r\nwritel(reg, mxsfb->base + LCDC_CTRL);\r\n}\r\nstatic void mxsfb_enable_controller(struct mxsfb_drm_private *mxsfb)\r\n{\r\nu32 reg;\r\nif (mxsfb->clk_disp_axi)\r\nclk_prepare_enable(mxsfb->clk_disp_axi);\r\nclk_prepare_enable(mxsfb->clk);\r\nmxsfb_enable_axi_clk(mxsfb);\r\nwritel(CTRL_DOTCLK_MODE, mxsfb->base + LCDC_CTRL + REG_SET);\r\nreg = readl(mxsfb->base + LCDC_VDCTRL4);\r\nreg |= VDCTRL4_SYNC_SIGNALS_ON;\r\nwritel(reg, mxsfb->base + LCDC_VDCTRL4);\r\nwritel(CTRL_RUN, mxsfb->base + LCDC_CTRL + REG_SET);\r\n}\r\nstatic void mxsfb_disable_controller(struct mxsfb_drm_private *mxsfb)\r\n{\r\nu32 reg;\r\nwritel(CTRL_DOTCLK_MODE, mxsfb->base + LCDC_CTRL + REG_CLR);\r\nreadl_poll_timeout(mxsfb->base + LCDC_CTRL, reg, !(reg & CTRL_RUN),\r\n0, 1000);\r\nreg = readl(mxsfb->base + LCDC_VDCTRL4);\r\nreg &= ~VDCTRL4_SYNC_SIGNALS_ON;\r\nwritel(reg, mxsfb->base + LCDC_VDCTRL4);\r\nmxsfb_disable_axi_clk(mxsfb);\r\nclk_disable_unprepare(mxsfb->clk);\r\nif (mxsfb->clk_disp_axi)\r\nclk_disable_unprepare(mxsfb->clk_disp_axi);\r\n}\r\nstatic int clear_poll_bit(void __iomem *addr, u32 mask)\r\n{\r\nu32 reg;\r\nwritel(mask, addr + MXS_CLR_ADDR);\r\nreturn readl_poll_timeout(addr, reg, !(reg & mask), 0, RESET_TIMEOUT);\r\n}\r\nstatic int mxsfb_reset_block(void __iomem *reset_addr)\r\n{\r\nint ret;\r\nret = clear_poll_bit(reset_addr, MODULE_SFTRST);\r\nif (ret)\r\nreturn ret;\r\nwritel(MODULE_CLKGATE, reset_addr + MXS_CLR_ADDR);\r\nret = clear_poll_bit(reset_addr, MODULE_SFTRST);\r\nif (ret)\r\nreturn ret;\r\nreturn clear_poll_bit(reset_addr, MODULE_CLKGATE);\r\n}\r\nstatic void mxsfb_crtc_mode_set_nofb(struct mxsfb_drm_private *mxsfb)\r\n{\r\nstruct drm_display_mode *m = &mxsfb->pipe.crtc.state->adjusted_mode;\r\nconst u32 bus_flags = mxsfb->connector.display_info.bus_flags;\r\nu32 vdctrl0, vsync_pulse_len, hsync_pulse_len;\r\nint err;\r\nmxsfb_enable_axi_clk(mxsfb);\r\nerr = mxsfb_reset_block(mxsfb->base);\r\nif (err)\r\nreturn;\r\nwritel(CTRL1_FIFO_CLEAR, mxsfb->base + LCDC_CTRL1 + REG_SET);\r\nerr = mxsfb_set_pixel_fmt(mxsfb);\r\nif (err)\r\nreturn;\r\nclk_set_rate(mxsfb->clk, m->crtc_clock * 1000);\r\nwritel(TRANSFER_COUNT_SET_VCOUNT(m->crtc_vdisplay) |\r\nTRANSFER_COUNT_SET_HCOUNT(m->crtc_hdisplay),\r\nmxsfb->base + mxsfb->devdata->transfer_count);\r\nvsync_pulse_len = m->crtc_vsync_end - m->crtc_vsync_start;\r\nvdctrl0 = VDCTRL0_ENABLE_PRESENT |\r\nVDCTRL0_VSYNC_PERIOD_UNIT |\r\nVDCTRL0_VSYNC_PULSE_WIDTH_UNIT |\r\nVDCTRL0_SET_VSYNC_PULSE_WIDTH(vsync_pulse_len);\r\nif (m->flags & DRM_MODE_FLAG_PHSYNC)\r\nvdctrl0 |= VDCTRL0_HSYNC_ACT_HIGH;\r\nif (m->flags & DRM_MODE_FLAG_PVSYNC)\r\nvdctrl0 |= VDCTRL0_VSYNC_ACT_HIGH;\r\nif (!(bus_flags & DRM_BUS_FLAG_DE_LOW))\r\nvdctrl0 |= VDCTRL0_ENABLE_ACT_HIGH;\r\nif (bus_flags & DRM_BUS_FLAG_PIXDATA_POSEDGE)\r\nvdctrl0 |= VDCTRL0_DOTCLK_ACT_FALLING;\r\nwritel(vdctrl0, mxsfb->base + LCDC_VDCTRL0);\r\nmxsfb_set_bus_fmt(mxsfb);\r\nwritel(m->crtc_vtotal, mxsfb->base + LCDC_VDCTRL1);\r\nhsync_pulse_len = m->crtc_hsync_end - m->crtc_hsync_start;\r\nwritel(set_hsync_pulse_width(mxsfb, hsync_pulse_len) |\r\nVDCTRL2_SET_HSYNC_PERIOD(m->crtc_htotal),\r\nmxsfb->base + LCDC_VDCTRL2);\r\nwritel(SET_HOR_WAIT_CNT(m->crtc_htotal - m->crtc_hsync_start) |\r\nSET_VERT_WAIT_CNT(m->crtc_vtotal - m->crtc_vsync_start),\r\nmxsfb->base + LCDC_VDCTRL3);\r\nwritel(SET_DOTCLK_H_VALID_DATA_CNT(m->hdisplay),\r\nmxsfb->base + LCDC_VDCTRL4);\r\nmxsfb_disable_axi_clk(mxsfb);\r\n}\r\nvoid mxsfb_crtc_enable(struct mxsfb_drm_private *mxsfb)\r\n{\r\nmxsfb_crtc_mode_set_nofb(mxsfb);\r\nmxsfb_enable_controller(mxsfb);\r\n}\r\nvoid mxsfb_crtc_disable(struct mxsfb_drm_private *mxsfb)\r\n{\r\nmxsfb_disable_controller(mxsfb);\r\n}\r\nvoid mxsfb_plane_atomic_update(struct mxsfb_drm_private *mxsfb,\r\nstruct drm_plane_state *state)\r\n{\r\nstruct drm_simple_display_pipe *pipe = &mxsfb->pipe;\r\nstruct drm_crtc *crtc = &pipe->crtc;\r\nstruct drm_framebuffer *fb = pipe->plane.state->fb;\r\nstruct drm_pending_vblank_event *event;\r\nstruct drm_gem_cma_object *gem;\r\nif (!crtc)\r\nreturn;\r\nspin_lock_irq(&crtc->dev->event_lock);\r\nevent = crtc->state->event;\r\nif (event) {\r\ncrtc->state->event = NULL;\r\nif (drm_crtc_vblank_get(crtc) == 0) {\r\ndrm_crtc_arm_vblank_event(crtc, event);\r\n} else {\r\ndrm_crtc_send_vblank_event(crtc, event);\r\n}\r\n}\r\nspin_unlock_irq(&crtc->dev->event_lock);\r\nif (!fb)\r\nreturn;\r\ngem = drm_fb_cma_get_gem_obj(fb, 0);\r\nmxsfb_enable_axi_clk(mxsfb);\r\nwritel(gem->paddr, mxsfb->base + mxsfb->devdata->next_buf);\r\nmxsfb_disable_axi_clk(mxsfb);\r\n}
