int sti_uniperiph_reset(struct uniperif *uni)\r\n{\r\nint count = 10;\r\nSET_UNIPERIF_SOFT_RST_SOFT_RST(uni);\r\nif (uni->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0) {\r\nwhile (GET_UNIPERIF_SOFT_RST_SOFT_RST(uni) && count) {\r\nudelay(5);\r\ncount--;\r\n}\r\n}\r\nif (!count) {\r\ndev_err(uni->dev, "Failed to reset uniperif\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint sti_uniperiph_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\r\nunsigned int rx_mask, int slots,\r\nint slot_width)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *uni = priv->dai_data.uni;\r\nint i, frame_size, avail_slots;\r\nif (!UNIPERIF_TYPE_IS_TDM(uni)) {\r\ndev_err(uni->dev, "cpu dai not in tdm mode\n");\r\nreturn -EINVAL;\r\n}\r\nuni->tdm_slot.slots = slots;\r\nuni->tdm_slot.slot_width = slot_width;\r\nuni->tdm_slot.mask = (tx_mask != 0) ? tx_mask : rx_mask;\r\nfor (i = 0, avail_slots = 0; i < uni->tdm_slot.slots; i++) {\r\nif ((uni->tdm_slot.mask >> i) & 0x01)\r\navail_slots++;\r\n}\r\nuni->tdm_slot.avail_slots = avail_slots;\r\nframe_size = uni->tdm_slot.avail_slots * uni->tdm_slot.slot_width / 8;\r\nif ((frame_size > UNIPERIF_MAX_FRAME_SZ) ||\r\n(frame_size & ~(int)UNIPERIF_ALLOWED_FRAME_SZ)) {\r\ndev_err(uni->dev, "frame size not allowed: %d bytes\n",\r\nframe_size);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint sti_uniperiph_fix_tdm_chan(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct uniperif *uni = rule->private;\r\nstruct snd_interval t;\r\nt.min = uni->tdm_slot.avail_slots;\r\nt.max = uni->tdm_slot.avail_slots;\r\nt.openmin = 0;\r\nt.openmax = 0;\r\nt.integer = 0;\r\nreturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\r\n}\r\nint sti_uniperiph_fix_tdm_format(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct uniperif *uni = rule->private;\r\nstruct snd_mask *maskp = hw_param_mask(params, rule->var);\r\nu64 format;\r\nswitch (uni->tdm_slot.slot_width) {\r\ncase 16:\r\nformat = SNDRV_PCM_FMTBIT_S16_LE;\r\nbreak;\r\ncase 32:\r\nformat = SNDRV_PCM_FMTBIT_S32_LE;\r\nbreak;\r\ndefault:\r\ndev_err(uni->dev, "format not supported: %d bits\n",\r\nuni->tdm_slot.slot_width);\r\nreturn -EINVAL;\r\n}\r\nmaskp->bits[0] &= (u_int32_t)format;\r\nmaskp->bits[1] &= (u_int32_t)(format >> 32);\r\nmemset(maskp->bits + 2, 0, (SNDRV_MASK_MAX - 64) / 8);\r\nif (!maskp->bits[0] && !maskp->bits[1])\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint sti_uniperiph_get_tdm_word_pos(struct uniperif *uni,\r\nunsigned int *word_pos)\r\n{\r\nint slot_width = uni->tdm_slot.slot_width / 8;\r\nint slots_num = uni->tdm_slot.slots;\r\nunsigned int slots_mask = uni->tdm_slot.mask;\r\nint i, j, k;\r\nunsigned int word16_pos[4];\r\nfor (i = 0, j = 0, k = 0; (i < slots_num) && (k < WORD_MAX); i++) {\r\nif ((slots_mask >> i) & 0x01) {\r\nword16_pos[j] = i * slot_width;\r\nif (slot_width == 4) {\r\nword16_pos[j + 1] = word16_pos[j] + 2;\r\nj++;\r\n}\r\nj++;\r\nif (j > 3) {\r\nword_pos[k] = word16_pos[1] |\r\n(word16_pos[0] << 8) |\r\n(word16_pos[3] << 16) |\r\n(word16_pos[2] << 24);\r\nj = 0;\r\nk++;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sti_uniperiph_dai_create_ctrl(struct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *uni = priv->dai_data.uni;\r\nstruct snd_kcontrol_new *ctrl;\r\nint i;\r\nif (!uni->num_ctrls)\r\nreturn 0;\r\nfor (i = 0; i < uni->num_ctrls; i++) {\r\nctrl = &uni->snd_ctrls[i];\r\nctrl->index = uni->id;\r\nctrl->device = uni->id;\r\n}\r\nreturn snd_soc_add_dai_controls(dai, uni->snd_ctrls, uni->num_ctrls);\r\n}\r\nint sti_uniperiph_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *uni = priv->dai_data.uni;\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\nint transfer_size;\r\nif (uni->type == SND_ST_UNIPERIF_TYPE_TDM)\r\ntransfer_size = snd_soc_params_to_frame_size(params) / 32;\r\nelse\r\ntransfer_size = params_channels(params) * UNIPERIF_FIFO_FRAMES;\r\ndma_data = snd_soc_dai_get_dma_data(dai, substream);\r\ndma_data->maxburst = transfer_size;\r\nreturn 0;\r\n}\r\nint sti_uniperiph_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\npriv->dai_data.uni->daifmt = fmt;\r\nreturn 0;\r\n}\r\nstatic int sti_uniperiph_dai_suspend(struct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *uni = priv->dai_data.uni;\r\nint ret;\r\nif (uni->state != UNIPERIF_STATE_STOPPED) {\r\ndev_err(uni->dev, "%s: invalid uni state( %d)\n",\r\n__func__, (int)uni->state);\r\nreturn -EBUSY;\r\n}\r\nret = pinctrl_pm_select_sleep_state(uni->dev);\r\nif (ret)\r\ndev_err(uni->dev, "%s: failed to select pinctrl state\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nstatic int sti_uniperiph_dai_resume(struct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *uni = priv->dai_data.uni;\r\nint ret;\r\nif (priv->dai_data.stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nret = uni_player_resume(uni);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = pinctrl_pm_select_default_state(uni->dev);\r\nif (ret)\r\ndev_err(uni->dev, "%s: failed to select pinctrl state\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nstatic int sti_uniperiph_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct sti_uniperiph_dai *dai_data = &priv->dai_data;\r\nif (priv->dai_data.stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsnd_soc_dai_init_dma_data(dai, &dai_data->dma_data, NULL);\r\nelse\r\nsnd_soc_dai_init_dma_data(dai, NULL, &dai_data->dma_data);\r\ndai_data->dma_data.addr = dai_data->uni->fifo_phys_address;\r\ndai_data->dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nreturn sti_uniperiph_dai_create_ctrl(dai);\r\n}\r\nstatic int sti_uniperiph_cpu_dai_of(struct device_node *node,\r\nstruct sti_uniperiph_data *priv)\r\n{\r\nstruct device *dev = &priv->pdev->dev;\r\nstruct sti_uniperiph_dai *dai_data = &priv->dai_data;\r\nstruct snd_soc_dai_driver *dai = priv->dai;\r\nstruct snd_soc_pcm_stream *stream;\r\nstruct uniperif *uni;\r\nconst struct of_device_id *of_id;\r\nconst struct sti_uniperiph_dev_data *dev_data;\r\nconst char *mode;\r\nint ret;\r\nof_id = of_match_node(snd_soc_sti_match, node);\r\nif (!of_id->data) {\r\ndev_err(dev, "data associated to device is missing\n");\r\nreturn -EINVAL;\r\n}\r\ndev_data = (struct sti_uniperiph_dev_data *)of_id->data;\r\nuni = devm_kzalloc(dev, sizeof(*uni), GFP_KERNEL);\r\nif (!uni)\r\nreturn -ENOMEM;\r\nuni->id = dev_data->id;\r\nuni->ver = dev_data->version;\r\n*dai = sti_uniperiph_dai_template;\r\ndai->name = dev_data->dai_names;\r\nuni->mem_region = platform_get_resource(priv->pdev, IORESOURCE_MEM, 0);\r\nif (!uni->mem_region) {\r\ndev_err(dev, "Failed to get memory resource\n");\r\nreturn -ENODEV;\r\n}\r\nuni->base = devm_ioremap_resource(dev, uni->mem_region);\r\nif (IS_ERR(uni->base))\r\nreturn PTR_ERR(uni->base);\r\nuni->fifo_phys_address = uni->mem_region->start +\r\nUNIPERIF_FIFO_DATA_OFFSET(uni);\r\nuni->irq = platform_get_irq(priv->pdev, 0);\r\nif (uni->irq < 0) {\r\ndev_err(dev, "Failed to get IRQ resource\n");\r\nreturn -ENXIO;\r\n}\r\nuni->type = dev_data->type;\r\nif (dev_data->type & SND_ST_UNIPERIF_TYPE_TDM) {\r\nif (!of_property_read_string(node, "st,tdm-mode", &mode))\r\nuni->type = SND_ST_UNIPERIF_TYPE_TDM;\r\nelse\r\nuni->type = SND_ST_UNIPERIF_TYPE_PCM;\r\n}\r\ndai_data->uni = uni;\r\ndai_data->stream = dev_data->stream;\r\nif (priv->dai_data.stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nret = uni_player_init(priv->pdev, uni);\r\nstream = &dai->playback;\r\n} else {\r\nret = uni_reader_init(priv->pdev, uni);\r\nstream = &dai->capture;\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\ndai->ops = uni->dai_ops;\r\nstream->stream_name = dai->name;\r\nstream->channels_min = uni->hw->channels_min;\r\nstream->channels_max = uni->hw->channels_max;\r\nstream->rates = uni->hw->rates;\r\nstream->formats = uni->hw->formats;\r\nreturn 0;\r\n}\r\nstatic int sti_uniperiph_probe(struct platform_device *pdev)\r\n{\r\nstruct sti_uniperiph_data *priv;\r\nstruct device_node *node = pdev->dev.of_node;\r\nint ret;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->dai = devm_kzalloc(&pdev->dev, sizeof(*priv->dai), GFP_KERNEL);\r\nif (!priv->dai)\r\nreturn -ENOMEM;\r\npriv->pdev = pdev;\r\nret = sti_uniperiph_cpu_dai_of(node, priv);\r\ndev_set_drvdata(&pdev->dev, priv);\r\nret = devm_snd_soc_register_component(&pdev->dev,\r\n&sti_uniperiph_dai_component,\r\npriv->dai, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn devm_snd_dmaengine_pcm_register(&pdev->dev,\r\n&dmaengine_pcm_config, 0);\r\n}
