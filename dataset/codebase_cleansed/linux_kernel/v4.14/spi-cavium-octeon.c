static int octeon_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res_mem;\r\nvoid __iomem *reg_base;\r\nstruct spi_master *master;\r\nstruct octeon_spi *p;\r\nint err = -ENOENT;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct octeon_spi));\r\nif (!master)\r\nreturn -ENOMEM;\r\np = spi_master_get_devdata(master);\r\nplatform_set_drvdata(pdev, master);\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nreg_base = devm_ioremap_resource(&pdev->dev, res_mem);\r\nif (IS_ERR(reg_base)) {\r\nerr = PTR_ERR(reg_base);\r\ngoto fail;\r\n}\r\np->register_base = reg_base;\r\np->sys_freq = octeon_get_io_clock_rate();\r\np->regs.config = 0;\r\np->regs.status = 0x08;\r\np->regs.tx = 0x10;\r\np->regs.data = 0x80;\r\nmaster->num_chipselect = 4;\r\nmaster->mode_bits = SPI_CPHA |\r\nSPI_CPOL |\r\nSPI_CS_HIGH |\r\nSPI_LSB_FIRST |\r\nSPI_3WIRE;\r\nmaster->transfer_one_message = octeon_spi_transfer_one_message;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\nmaster->max_speed_hz = OCTEON_SPI_MAX_CLOCK_HZ;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nerr = devm_spi_register_master(&pdev->dev, master);\r\nif (err) {\r\ndev_err(&pdev->dev, "register master failed: %d\n", err);\r\ngoto fail;\r\n}\r\ndev_info(&pdev->dev, "OCTEON SPI bus driver\n");\r\nreturn 0;\r\nfail:\r\nspi_master_put(master);\r\nreturn err;\r\n}\r\nstatic int octeon_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct octeon_spi *p = spi_master_get_devdata(master);\r\nwriteq(0, p->register_base + OCTEON_SPI_CFG(p));\r\nreturn 0;\r\n}
