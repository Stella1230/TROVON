static int\r\nfcmp_gt(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)\r\n{\r\nif (CMP(CMP) > 0)\r\nregs->sr |= 1;\r\nelse\r\nregs->sr &= ~1;\r\nreturn 0;\r\n}\r\nstatic int\r\nfcmp_eq(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)\r\n{\r\nif (CMP(CMP ) == 0)\r\nregs->sr |= 1;\r\nelse\r\nregs->sr &= ~1;\r\nreturn 0;\r\n}\r\nstatic int\r\nfadd(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)\r\n{\r\nBOTH_PRmn(ARITH_X, ADD);\r\nreturn 0;\r\n}\r\nstatic int\r\nfsub(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)\r\n{\r\nBOTH_PRmn(ARITH_X, SUB);\r\nreturn 0;\r\n}\r\nstatic int\r\nfmul(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)\r\n{\r\nBOTH_PRmn(ARITH_X, MUL);\r\nreturn 0;\r\n}\r\nstatic int\r\nfdiv(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)\r\n{\r\nBOTH_PRmn(ARITH_X, DIV);\r\nreturn 0;\r\n}\r\nstatic int\r\nfmac(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)\r\n{\r\nFP_DECL_EX;\r\nFP_DECL_S(Fr);\r\nFP_DECL_S(Ft);\r\nFP_DECL_S(F0);\r\nFP_DECL_S(Fm);\r\nFP_DECL_S(Fn);\r\nUNPACK_S(F0, FR0);\r\nUNPACK_S(Fm, FRm);\r\nUNPACK_S(Fn, FRn);\r\nFP_MUL_S(Ft, Fm, F0);\r\nFP_ADD_S(Fr, Fn, Ft);\r\nPACK_S(FRn, Fr);\r\nreturn 0;\r\n}\r\nstatic int\r\nfmov_idx_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,\r\nint n)\r\n{\r\nif (FPSCR_SZ) {\r\nFMOV_EXT(n);\r\nREAD(FRn, Rm + R0 + 4);\r\nn++;\r\nREAD(FRn, Rm + R0);\r\n} else {\r\nREAD(FRn, Rm + R0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nfmov_mem_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,\r\nint n)\r\n{\r\nif (FPSCR_SZ) {\r\nFMOV_EXT(n);\r\nREAD(FRn, Rm + 4);\r\nn++;\r\nREAD(FRn, Rm);\r\n} else {\r\nREAD(FRn, Rm);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nfmov_inc_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,\r\nint n)\r\n{\r\nif (FPSCR_SZ) {\r\nFMOV_EXT(n);\r\nREAD(FRn, Rm + 4);\r\nn++;\r\nREAD(FRn, Rm);\r\nRm += 8;\r\n} else {\r\nREAD(FRn, Rm);\r\nRm += 4;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nfmov_reg_idx(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,\r\nint n)\r\n{\r\nif (FPSCR_SZ) {\r\nFMOV_EXT(m);\r\nWRITE(FRm, Rn + R0 + 4);\r\nm++;\r\nWRITE(FRm, Rn + R0);\r\n} else {\r\nWRITE(FRm, Rn + R0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nfmov_reg_mem(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,\r\nint n)\r\n{\r\nif (FPSCR_SZ) {\r\nFMOV_EXT(m);\r\nWRITE(FRm, Rn + 4);\r\nm++;\r\nWRITE(FRm, Rn);\r\n} else {\r\nWRITE(FRm, Rn);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nfmov_reg_dec(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,\r\nint n)\r\n{\r\nif (FPSCR_SZ) {\r\nFMOV_EXT(m);\r\nRn -= 8;\r\nWRITE(FRm, Rn + 4);\r\nm++;\r\nWRITE(FRm, Rn);\r\n} else {\r\nRn -= 4;\r\nWRITE(FRm, Rn);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nfmov_reg_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,\r\nint n)\r\n{\r\nif (FPSCR_SZ) {\r\nFMOV_EXT(m);\r\nFMOV_EXT(n);\r\nDRn = DRm;\r\n} else {\r\nFRn = FRm;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nfnop_mn(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int ffloat(struct sh_fpu_soft_struct *fregs, int n)\r\n{\r\nFP_DECL_EX;\r\nif (FPSCR_PR)\r\nEMU_FLOAT_X(D, DRn);\r\nelse\r\nEMU_FLOAT_X(S, FRn);\r\nreturn 0;\r\n}\r\nstatic int ftrc(struct sh_fpu_soft_struct *fregs, int n)\r\n{\r\nFP_DECL_EX;\r\nif (FPSCR_PR)\r\nEMU_FTRC_X(D, DRn);\r\nelse\r\nEMU_FTRC_X(S, FRn);\r\nreturn 0;\r\n}\r\nstatic int fcnvsd(struct sh_fpu_soft_struct *fregs, int n)\r\n{\r\nFP_DECL_EX;\r\nFP_DECL_S(Fn);\r\nFP_DECL_D(Fr);\r\nUNPACK_S(Fn, FPUL);\r\nFP_CONV(D, S, 2, 1, Fr, Fn);\r\nPACK_D(DRn, Fr);\r\nreturn 0;\r\n}\r\nstatic int fcnvds(struct sh_fpu_soft_struct *fregs, int n)\r\n{\r\nFP_DECL_EX;\r\nFP_DECL_D(Fn);\r\nFP_DECL_S(Fr);\r\nUNPACK_D(Fn, DRn);\r\nFP_CONV(S, D, 1, 2, Fr, Fn);\r\nPACK_S(FPUL, Fr);\r\nreturn 0;\r\n}\r\nstatic int fxchg(struct sh_fpu_soft_struct *fregs, int flag)\r\n{\r\nFPSCR ^= flag;\r\nreturn 0;\r\n}\r\nstatic int fsts(struct sh_fpu_soft_struct *fregs, int n)\r\n{\r\nFRn = FPUL;\r\nreturn 0;\r\n}\r\nstatic int flds(struct sh_fpu_soft_struct *fregs, int n)\r\n{\r\nFPUL = FRn;\r\nreturn 0;\r\n}\r\nstatic int fneg(struct sh_fpu_soft_struct *fregs, int n)\r\n{\r\nFRn ^= (1 << (_FP_W_TYPE_SIZE - 1));\r\nreturn 0;\r\n}\r\nstatic int fabs(struct sh_fpu_soft_struct *fregs, int n)\r\n{\r\nFRn &= ~(1 << (_FP_W_TYPE_SIZE - 1));\r\nreturn 0;\r\n}\r\nstatic int fld0(struct sh_fpu_soft_struct *fregs, int n)\r\n{\r\nFRn = 0;\r\nreturn 0;\r\n}\r\nstatic int fld1(struct sh_fpu_soft_struct *fregs, int n)\r\n{\r\nFRn = (_FP_EXPBIAS_S << (_FP_FRACBITS_S - 1));\r\nreturn 0;\r\n}\r\nstatic int fnop_n(struct sh_fpu_soft_struct *fregs, int n)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int id_fxfd(struct sh_fpu_soft_struct *fregs, int x)\r\n{\r\nconst int flag[] = { FPSCR_SZ, FPSCR_PR, FPSCR_FR, 0 };\r\nswitch (x & 3) {\r\ncase 3:\r\nfxchg(fregs, flag[x >> 2]);\r\nbreak;\r\ncase 1:\r\nftrv(fregs, x - 1);\r\nbreak;\r\ndefault:\r\nfsca(fregs, x);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nid_fnxd(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int x, int n)\r\n{\r\nreturn (fnxd[x])(fregs, n);\r\n}\r\nstatic int\r\nid_fnmx(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, u16 code)\r\n{\r\nint n = (code >> 8) & 0xf, m = (code >> 4) & 0xf, x = code & 0xf;\r\nreturn (fnmx[x])(fregs, regs, m, n);\r\n}\r\nstatic int\r\nid_sys(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, u16 code)\r\n{\r\nint n = ((code >> 8) & 0xf);\r\nunsigned long *reg = (code & 0x0010) ? &FPUL : &FPSCR;\r\nswitch (code & 0xf0ff) {\r\ncase 0x005a:\r\ncase 0x006a:\r\nRn = *reg;\r\nbreak;\r\ncase 0x405a:\r\ncase 0x406a:\r\n*reg = Rn;\r\nbreak;\r\ncase 0x4052:\r\ncase 0x4062:\r\nRn -= 4;\r\nWRITE(*reg, Rn);\r\nbreak;\r\ncase 0x4056:\r\ncase 0x4066:\r\nREAD(*reg, Rn);\r\nRn += 4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fpu_emulate(u16 code, struct sh_fpu_soft_struct *fregs, struct pt_regs *regs)\r\n{\r\nif ((code & 0xf000) == 0xf000)\r\nreturn id_fnmx(fregs, regs, code);\r\nelse\r\nreturn id_sys(fregs, regs, code);\r\n}\r\nstatic void denormal_to_double(struct sh_fpu_soft_struct *fpu, int n)\r\n{\r\nunsigned long du, dl;\r\nunsigned long x = fpu->fpul;\r\nint exp = 1023 - 126;\r\nif (x != 0 && (x & 0x7f800000) == 0) {\r\ndu = (x & 0x80000000);\r\nwhile ((x & 0x00800000) == 0) {\r\nx <<= 1;\r\nexp--;\r\n}\r\nx &= 0x007fffff;\r\ndu |= (exp << 20) | (x >> 3);\r\ndl = x << 29;\r\nfpu->fp_regs[n] = du;\r\nfpu->fp_regs[n+1] = dl;\r\n}\r\n}\r\nstatic int ieee_fpe_handler(struct pt_regs *regs)\r\n{\r\nunsigned short insn = *(unsigned short *)regs->pc;\r\nunsigned short finsn;\r\nunsigned long nextpc;\r\nsiginfo_t info;\r\nint nib[4] = {\r\n(insn >> 12) & 0xf,\r\n(insn >> 8) & 0xf,\r\n(insn >> 4) & 0xf,\r\ninsn & 0xf};\r\nif (nib[0] == 0xb ||\r\n(nib[0] == 0x4 && nib[2] == 0x0 && nib[3] == 0xb))\r\nregs->pr = regs->pc + 4;\r\nif (nib[0] == 0xa || nib[0] == 0xb) {\r\nnextpc = regs->pc + 4 + ((short) ((insn & 0xfff) << 4) >> 3);\r\nfinsn = *(unsigned short *) (regs->pc + 2);\r\n} else if (nib[0] == 0x8 && nib[1] == 0xd) {\r\nif (regs->sr & 1)\r\nnextpc = regs->pc + 4 + ((char) (insn & 0xff) << 1);\r\nelse\r\nnextpc = regs->pc + 4;\r\nfinsn = *(unsigned short *) (regs->pc + 2);\r\n} else if (nib[0] == 0x8 && nib[1] == 0xf) {\r\nif (regs->sr & 1)\r\nnextpc = regs->pc + 4;\r\nelse\r\nnextpc = regs->pc + 4 + ((char) (insn & 0xff) << 1);\r\nfinsn = *(unsigned short *) (regs->pc + 2);\r\n} else if (nib[0] == 0x4 && nib[3] == 0xb &&\r\n(nib[2] == 0x0 || nib[2] == 0x2)) {\r\nnextpc = regs->regs[nib[1]];\r\nfinsn = *(unsigned short *) (regs->pc + 2);\r\n} else if (nib[0] == 0x0 && nib[3] == 0x3 &&\r\n(nib[2] == 0x0 || nib[2] == 0x2)) {\r\nnextpc = regs->pc + 4 + regs->regs[nib[1]];\r\nfinsn = *(unsigned short *) (regs->pc + 2);\r\n} else if (insn == 0x000b) {\r\nnextpc = regs->pr;\r\nfinsn = *(unsigned short *) (regs->pc + 2);\r\n} else {\r\nnextpc = regs->pc + 2;\r\nfinsn = insn;\r\n}\r\nif ((finsn & 0xf1ff) == 0xf0ad) {\r\nstruct task_struct *tsk = current;\r\nif ((tsk->thread.xstate->softfpu.fpscr & (1 << 17))) {\r\ndenormal_to_double (&tsk->thread.xstate->softfpu,\r\n(finsn >> 8) & 0xf);\r\ntsk->thread.xstate->softfpu.fpscr &=\r\n~(FPSCR_CAUSE_MASK | FPSCR_FLAG_MASK);\r\ntask_thread_info(tsk)->status |= TS_USEDFPU;\r\n} else {\r\ninfo.si_signo = SIGFPE;\r\ninfo.si_errno = 0;\r\ninfo.si_code = FPE_FLTINV;\r\ninfo.si_addr = (void __user *)regs->pc;\r\nforce_sig_info(SIGFPE, &info, tsk);\r\n}\r\nregs->pc = nextpc;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fpu_init(struct sh_fpu_soft_struct *fpu)\r\n{\r\nint i;\r\nfpu->fpscr = FPSCR_INIT;\r\nfpu->fpul = 0;\r\nfor (i = 0; i < 16; i++) {\r\nfpu->fp_regs[i] = 0;\r\nfpu->xfp_regs[i]= 0;\r\n}\r\n}\r\nint do_fpu_inst(unsigned short inst, struct pt_regs *regs)\r\n{\r\nstruct task_struct *tsk = current;\r\nstruct sh_fpu_soft_struct *fpu = &(tsk->thread.xstate->softfpu);\r\nperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\r\nif (!(task_thread_info(tsk)->status & TS_USEDFPU)) {\r\nfpu_init(fpu);\r\ntask_thread_info(tsk)->status |= TS_USEDFPU;\r\n}\r\nreturn fpu_emulate(inst, fpu, regs);\r\n}
