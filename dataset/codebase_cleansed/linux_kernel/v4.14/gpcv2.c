static int imx7_gpc_pu_pgc_sw_pxx_req(struct generic_pm_domain *genpd,\r\nbool on)\r\n{\r\nstruct imx7_pgc_domain *domain = container_of(genpd,\r\nstruct imx7_pgc_domain,\r\ngenpd);\r\nunsigned int offset = on ?\r\nGPC_PU_PGC_SW_PUP_REQ : GPC_PU_PGC_SW_PDN_REQ;\r\nconst bool enable_power_control = !on;\r\nconst bool has_regulator = !IS_ERR(domain->regulator);\r\nunsigned long deadline;\r\nint ret = 0;\r\nregmap_update_bits(domain->regmap, GPC_PGC_CPU_MAPPING,\r\ndomain->bits.map, domain->bits.map);\r\nif (has_regulator && on) {\r\nret = regulator_enable(domain->regulator);\r\nif (ret) {\r\ndev_err(domain->dev, "failed to enable regulator\n");\r\ngoto unmap;\r\n}\r\n}\r\nif (enable_power_control)\r\nregmap_update_bits(domain->regmap, GPC_PGC_CTRL(domain->pgc),\r\nGPC_PGC_CTRL_PCR, GPC_PGC_CTRL_PCR);\r\nregmap_update_bits(domain->regmap, offset,\r\ndomain->bits.pxx, domain->bits.pxx);\r\ndeadline = jiffies + msecs_to_jiffies(1);\r\nwhile (true) {\r\nu32 pxx_req;\r\nregmap_read(domain->regmap, offset, &pxx_req);\r\nif (!(pxx_req & domain->bits.pxx))\r\nbreak;\r\nif (time_after(jiffies, deadline)) {\r\ndev_err(domain->dev, "falied to command PGC\n");\r\nret = -ETIMEDOUT;\r\non = !on;\r\nbreak;\r\n}\r\ncpu_relax();\r\n}\r\nif (enable_power_control)\r\nregmap_update_bits(domain->regmap, GPC_PGC_CTRL(domain->pgc),\r\nGPC_PGC_CTRL_PCR, 0);\r\nif (has_regulator && !on) {\r\nint err;\r\nerr = regulator_disable(domain->regulator);\r\nif (err)\r\ndev_err(domain->dev,\r\n"failed to disable regulator: %d\n", ret);\r\nret = ret ?: err;\r\n}\r\nunmap:\r\nregmap_update_bits(domain->regmap, GPC_PGC_CPU_MAPPING,\r\ndomain->bits.map, 0);\r\nreturn ret;\r\n}\r\nstatic int imx7_gpc_pu_pgc_sw_pup_req(struct generic_pm_domain *genpd)\r\n{\r\nreturn imx7_gpc_pu_pgc_sw_pxx_req(genpd, true);\r\n}\r\nstatic int imx7_gpc_pu_pgc_sw_pdn_req(struct generic_pm_domain *genpd)\r\n{\r\nreturn imx7_gpc_pu_pgc_sw_pxx_req(genpd, false);\r\n}\r\nstatic int imx7_pgc_domain_probe(struct platform_device *pdev)\r\n{\r\nstruct imx7_pgc_domain *domain = pdev->dev.platform_data;\r\nint ret;\r\ndomain->dev = &pdev->dev;\r\ndomain->regulator = devm_regulator_get_optional(domain->dev, "power");\r\nif (IS_ERR(domain->regulator)) {\r\nif (PTR_ERR(domain->regulator) != -ENODEV) {\r\nif (PTR_ERR(domain->regulator) != -EPROBE_DEFER)\r\ndev_err(domain->dev, "Failed to get domain's regulator\n");\r\nreturn PTR_ERR(domain->regulator);\r\n}\r\n} else {\r\nregulator_set_voltage(domain->regulator,\r\ndomain->voltage, domain->voltage);\r\n}\r\nret = pm_genpd_init(&domain->genpd, NULL, true);\r\nif (ret) {\r\ndev_err(domain->dev, "Failed to init power domain\n");\r\nreturn ret;\r\n}\r\nret = of_genpd_add_provider_simple(domain->dev->of_node,\r\n&domain->genpd);\r\nif (ret) {\r\ndev_err(domain->dev, "Failed to add genpd provider\n");\r\npm_genpd_remove(&domain->genpd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int imx7_pgc_domain_remove(struct platform_device *pdev)\r\n{\r\nstruct imx7_pgc_domain *domain = pdev->dev.platform_data;\r\nof_genpd_del_provider(domain->dev->of_node);\r\npm_genpd_remove(&domain->genpd);\r\nreturn 0;\r\n}\r\nstatic int imx_gpcv2_probe(struct platform_device *pdev)\r\n{\r\nstatic const struct regmap_range yes_ranges[] = {\r\nregmap_reg_range(GPC_LPCR_A7_BSC,\r\nGPC_M4_PU_PDN_FLG),\r\nregmap_reg_range(GPC_PGC_CTRL(PGC_MIPI),\r\nGPC_PGC_SR(PGC_MIPI)),\r\nregmap_reg_range(GPC_PGC_CTRL(PGC_PCIE),\r\nGPC_PGC_SR(PGC_PCIE)),\r\nregmap_reg_range(GPC_PGC_CTRL(PGC_USB_HSIC),\r\nGPC_PGC_SR(PGC_USB_HSIC)),\r\n};\r\nstatic const struct regmap_access_table access_table = {\r\n.yes_ranges = yes_ranges,\r\n.n_yes_ranges = ARRAY_SIZE(yes_ranges),\r\n};\r\nstatic const struct regmap_config regmap_config = {\r\n.reg_bits = 32,\r\n.val_bits = 32,\r\n.reg_stride = 4,\r\n.rd_table = &access_table,\r\n.wr_table = &access_table,\r\n.max_register = SZ_4K,\r\n};\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *pgc_np, *np;\r\nstruct regmap *regmap;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint ret;\r\npgc_np = of_get_child_by_name(dev->of_node, "pgc");\r\nif (!pgc_np) {\r\ndev_err(dev, "No power domains specified in DT\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nregmap = devm_regmap_init_mmio(dev, base, &regmap_config);\r\nif (IS_ERR(regmap)) {\r\nret = PTR_ERR(regmap);\r\ndev_err(dev, "failed to init regmap (%d)\n", ret);\r\nreturn ret;\r\n}\r\nfor_each_child_of_node(pgc_np, np) {\r\nstruct platform_device *pd_pdev;\r\nstruct imx7_pgc_domain *domain;\r\nu32 domain_index;\r\nret = of_property_read_u32(np, "reg", &domain_index);\r\nif (ret) {\r\ndev_err(dev, "Failed to read 'reg' property\n");\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\nif (domain_index >= ARRAY_SIZE(imx7_pgc_domains)) {\r\ndev_warn(dev,\r\n"Domain index %d is out of bounds\n",\r\ndomain_index);\r\ncontinue;\r\n}\r\ndomain = &imx7_pgc_domains[domain_index];\r\ndomain->regmap = regmap;\r\ndomain->genpd.power_on = imx7_gpc_pu_pgc_sw_pup_req;\r\ndomain->genpd.power_off = imx7_gpc_pu_pgc_sw_pdn_req;\r\npd_pdev = platform_device_alloc("imx7-pgc-domain",\r\ndomain_index);\r\nif (!pd_pdev) {\r\ndev_err(dev, "Failed to allocate platform device\n");\r\nof_node_put(np);\r\nreturn -ENOMEM;\r\n}\r\npd_pdev->dev.platform_data = domain;\r\npd_pdev->dev.parent = dev;\r\npd_pdev->dev.of_node = np;\r\nret = platform_device_add(pd_pdev);\r\nif (ret) {\r\nplatform_device_put(pd_pdev);\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}
