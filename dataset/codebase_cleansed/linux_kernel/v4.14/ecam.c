struct pci_config_window *pci_ecam_create(struct device *dev,\r\nstruct resource *cfgres, struct resource *busr,\r\nstruct pci_ecam_ops *ops)\r\n{\r\nstruct pci_config_window *cfg;\r\nunsigned int bus_range, bus_range_max, bsz;\r\nstruct resource *conflict;\r\nint i, err;\r\nif (busr->start > busr->end)\r\nreturn ERR_PTR(-EINVAL);\r\ncfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\r\nif (!cfg)\r\nreturn ERR_PTR(-ENOMEM);\r\ncfg->parent = dev;\r\ncfg->ops = ops;\r\ncfg->busr.start = busr->start;\r\ncfg->busr.end = busr->end;\r\ncfg->busr.flags = IORESOURCE_BUS;\r\nbus_range = resource_size(&cfg->busr);\r\nbus_range_max = resource_size(cfgres) >> ops->bus_shift;\r\nif (bus_range > bus_range_max) {\r\nbus_range = bus_range_max;\r\ncfg->busr.end = busr->start + bus_range - 1;\r\ndev_warn(dev, "ECAM area %pR can only accommodate %pR (reduced from %pR desired)\n",\r\ncfgres, &cfg->busr, busr);\r\n}\r\nbsz = 1 << ops->bus_shift;\r\ncfg->res.start = cfgres->start;\r\ncfg->res.end = cfgres->end;\r\ncfg->res.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\r\ncfg->res.name = "PCI ECAM";\r\nconflict = request_resource_conflict(&iomem_resource, &cfg->res);\r\nif (conflict) {\r\nerr = -EBUSY;\r\ndev_err(dev, "can't claim ECAM area %pR: address conflict with %s %pR\n",\r\n&cfg->res, conflict->name, conflict);\r\ngoto err_exit;\r\n}\r\nif (per_bus_mapping) {\r\ncfg->winp = kcalloc(bus_range, sizeof(*cfg->winp), GFP_KERNEL);\r\nif (!cfg->winp)\r\ngoto err_exit_malloc;\r\nfor (i = 0; i < bus_range; i++) {\r\ncfg->winp[i] =\r\npci_remap_cfgspace(cfgres->start + i * bsz,\r\nbsz);\r\nif (!cfg->winp[i])\r\ngoto err_exit_iomap;\r\n}\r\n} else {\r\ncfg->win = pci_remap_cfgspace(cfgres->start, bus_range * bsz);\r\nif (!cfg->win)\r\ngoto err_exit_iomap;\r\n}\r\nif (ops->init) {\r\nerr = ops->init(cfg);\r\nif (err)\r\ngoto err_exit;\r\n}\r\ndev_info(dev, "ECAM at %pR for %pR\n", &cfg->res, &cfg->busr);\r\nreturn cfg;\r\nerr_exit_iomap:\r\ndev_err(dev, "ECAM ioremap failed\n");\r\nerr_exit_malloc:\r\nerr = -ENOMEM;\r\nerr_exit:\r\npci_ecam_free(cfg);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid pci_ecam_free(struct pci_config_window *cfg)\r\n{\r\nint i;\r\nif (per_bus_mapping) {\r\nif (cfg->winp) {\r\nfor (i = 0; i < resource_size(&cfg->busr); i++)\r\nif (cfg->winp[i])\r\niounmap(cfg->winp[i]);\r\nkfree(cfg->winp);\r\n}\r\n} else {\r\nif (cfg->win)\r\niounmap(cfg->win);\r\n}\r\nif (cfg->res.parent)\r\nrelease_resource(&cfg->res);\r\nkfree(cfg);\r\n}\r\nvoid __iomem *pci_ecam_map_bus(struct pci_bus *bus, unsigned int devfn,\r\nint where)\r\n{\r\nstruct pci_config_window *cfg = bus->sysdata;\r\nunsigned int devfn_shift = cfg->ops->bus_shift - 8;\r\nunsigned int busn = bus->number;\r\nvoid __iomem *base;\r\nif (busn < cfg->busr.start || busn > cfg->busr.end)\r\nreturn NULL;\r\nbusn -= cfg->busr.start;\r\nif (per_bus_mapping)\r\nbase = cfg->winp[busn];\r\nelse\r\nbase = cfg->win + (busn << cfg->ops->bus_shift);\r\nreturn base + (devfn << devfn_shift) + where;\r\n}
