static int ip_vs_rr_init_svc(struct ip_vs_service *svc)\r\n{\r\nsvc->sched_data = &svc->destinations;\r\nreturn 0;\r\n}\r\nstatic int ip_vs_rr_del_dest(struct ip_vs_service *svc, struct ip_vs_dest *dest)\r\n{\r\nstruct list_head *p;\r\nspin_lock_bh(&svc->sched_lock);\r\np = (struct list_head *) svc->sched_data;\r\nif (p == &dest->n_list)\r\nsvc->sched_data = p->next->prev;\r\nspin_unlock_bh(&svc->sched_lock);\r\nreturn 0;\r\n}\r\nstatic struct ip_vs_dest *\r\nip_vs_rr_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\r\nstruct ip_vs_iphdr *iph)\r\n{\r\nstruct list_head *p;\r\nstruct ip_vs_dest *dest, *last;\r\nint pass = 0;\r\nIP_VS_DBG(6, "%s(): Scheduling...\n", __func__);\r\nspin_lock_bh(&svc->sched_lock);\r\np = (struct list_head *) svc->sched_data;\r\nlast = dest = list_entry(p, struct ip_vs_dest, n_list);\r\ndo {\r\nlist_for_each_entry_continue_rcu(dest,\r\n&svc->destinations,\r\nn_list) {\r\nif (!(dest->flags & IP_VS_DEST_F_OVERLOAD) &&\r\natomic_read(&dest->weight) > 0)\r\ngoto out;\r\nif (dest == last)\r\ngoto stop;\r\n}\r\npass++;\r\n} while (pass < 2 && p != &svc->destinations);\r\nstop:\r\nspin_unlock_bh(&svc->sched_lock);\r\nip_vs_scheduler_err(svc, "no destination available");\r\nreturn NULL;\r\nout:\r\nsvc->sched_data = &dest->n_list;\r\nspin_unlock_bh(&svc->sched_lock);\r\nIP_VS_DBG_BUF(6, "RR: server %s:%u "\r\n"activeconns %d refcnt %d weight %d\n",\r\nIP_VS_DBG_ADDR(dest->af, &dest->addr), ntohs(dest->port),\r\natomic_read(&dest->activeconns),\r\nrefcount_read(&dest->refcnt), atomic_read(&dest->weight));\r\nreturn dest;\r\n}\r\nstatic int __init ip_vs_rr_init(void)\r\n{\r\nreturn register_ip_vs_scheduler(&ip_vs_rr_scheduler);\r\n}\r\nstatic void __exit ip_vs_rr_cleanup(void)\r\n{\r\nunregister_ip_vs_scheduler(&ip_vs_rr_scheduler);\r\nsynchronize_rcu();\r\n}
