static int\r\nqca_tty_receive(struct serdev_device *serdev, const unsigned char *data,\r\nsize_t count)\r\n{\r\nstruct qcauart *qca = serdev_device_get_drvdata(serdev);\r\nstruct net_device *netdev = qca->net_dev;\r\nstruct net_device_stats *n_stats = &netdev->stats;\r\nsize_t i;\r\nif (!qca->rx_skb) {\r\nqca->rx_skb = netdev_alloc_skb_ip_align(netdev,\r\nnetdev->mtu +\r\nVLAN_ETH_HLEN);\r\nif (!qca->rx_skb) {\r\nn_stats->rx_errors++;\r\nn_stats->rx_dropped++;\r\nreturn 0;\r\n}\r\n}\r\nfor (i = 0; i < count; i++) {\r\ns32 retcode;\r\nretcode = qcafrm_fsm_decode(&qca->frm_handle,\r\nqca->rx_skb->data,\r\nskb_tailroom(qca->rx_skb),\r\ndata[i]);\r\nswitch (retcode) {\r\ncase QCAFRM_GATHER:\r\ncase QCAFRM_NOHEAD:\r\nbreak;\r\ncase QCAFRM_NOTAIL:\r\nnetdev_dbg(netdev, "recv: no RX tail\n");\r\nn_stats->rx_errors++;\r\nn_stats->rx_dropped++;\r\nbreak;\r\ncase QCAFRM_INVLEN:\r\nnetdev_dbg(netdev, "recv: invalid RX length\n");\r\nn_stats->rx_errors++;\r\nn_stats->rx_dropped++;\r\nbreak;\r\ndefault:\r\nn_stats->rx_packets++;\r\nn_stats->rx_bytes += retcode;\r\nskb_put(qca->rx_skb, retcode);\r\nqca->rx_skb->protocol = eth_type_trans(\r\nqca->rx_skb, qca->rx_skb->dev);\r\nqca->rx_skb->ip_summed = CHECKSUM_UNNECESSARY;\r\nnetif_rx_ni(qca->rx_skb);\r\nqca->rx_skb = netdev_alloc_skb_ip_align(netdev,\r\nnetdev->mtu +\r\nVLAN_ETH_HLEN);\r\nif (!qca->rx_skb) {\r\nnetdev_dbg(netdev, "recv: out of RX resources\n");\r\nn_stats->rx_errors++;\r\nreturn i;\r\n}\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic void qcauart_transmit(struct work_struct *work)\r\n{\r\nstruct qcauart *qca = container_of(work, struct qcauart, tx_work);\r\nstruct net_device_stats *n_stats = &qca->net_dev->stats;\r\nint written;\r\nspin_lock_bh(&qca->lock);\r\nif (!netif_running(qca->net_dev)) {\r\nspin_unlock_bh(&qca->lock);\r\nreturn;\r\n}\r\nif (qca->tx_left <= 0) {\r\nn_stats->tx_packets++;\r\nspin_unlock_bh(&qca->lock);\r\nnetif_wake_queue(qca->net_dev);\r\nreturn;\r\n}\r\nwritten = serdev_device_write_buf(qca->serdev, qca->tx_head,\r\nqca->tx_left);\r\nif (written > 0) {\r\nqca->tx_left -= written;\r\nqca->tx_head += written;\r\n}\r\nspin_unlock_bh(&qca->lock);\r\n}\r\nstatic void qca_tty_wakeup(struct serdev_device *serdev)\r\n{\r\nstruct qcauart *qca = serdev_device_get_drvdata(serdev);\r\nschedule_work(&qca->tx_work);\r\n}\r\nstatic int qcauart_netdev_open(struct net_device *dev)\r\n{\r\nstruct qcauart *qca = netdev_priv(dev);\r\nnetif_start_queue(qca->net_dev);\r\nreturn 0;\r\n}\r\nstatic int qcauart_netdev_close(struct net_device *dev)\r\n{\r\nstruct qcauart *qca = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nflush_work(&qca->tx_work);\r\nspin_lock_bh(&qca->lock);\r\nqca->tx_left = 0;\r\nspin_unlock_bh(&qca->lock);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t\r\nqcauart_netdev_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct net_device_stats *n_stats = &dev->stats;\r\nstruct qcauart *qca = netdev_priv(dev);\r\nu8 pad_len = 0;\r\nint written;\r\nu8 *pos;\r\nspin_lock(&qca->lock);\r\nWARN_ON(qca->tx_left);\r\nif (!netif_running(dev)) {\r\nspin_unlock(&qca->lock);\r\nnetdev_warn(qca->net_dev, "xmit: iface is down\n");\r\ngoto out;\r\n}\r\npos = qca->tx_buffer;\r\nif (skb->len < QCAFRM_MIN_LEN)\r\npad_len = QCAFRM_MIN_LEN - skb->len;\r\npos += qcafrm_create_header(pos, skb->len + pad_len);\r\nmemcpy(pos, skb->data, skb->len);\r\npos += skb->len;\r\nif (pad_len) {\r\nmemset(pos, 0, pad_len);\r\npos += pad_len;\r\n}\r\npos += qcafrm_create_footer(pos);\r\nnetif_stop_queue(qca->net_dev);\r\nwritten = serdev_device_write_buf(qca->serdev, qca->tx_buffer,\r\npos - qca->tx_buffer);\r\nif (written > 0) {\r\nqca->tx_left = (pos - qca->tx_buffer) - written;\r\nqca->tx_head = qca->tx_buffer + written;\r\nn_stats->tx_bytes += written;\r\n}\r\nspin_unlock(&qca->lock);\r\nnetif_trans_update(dev);\r\nout:\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void qcauart_netdev_tx_timeout(struct net_device *dev)\r\n{\r\nstruct qcauart *qca = netdev_priv(dev);\r\nnetdev_info(qca->net_dev, "Transmit timeout at %ld, latency %ld\n",\r\njiffies, dev_trans_start(dev));\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_dropped++;\r\n}\r\nstatic int qcauart_netdev_init(struct net_device *dev)\r\n{\r\nstruct qcauart *qca = netdev_priv(dev);\r\nsize_t len;\r\ndev->mtu = QCAFRM_MAX_MTU;\r\ndev->type = ARPHRD_ETHER;\r\nlen = QCAFRM_HEADER_LEN + QCAFRM_MAX_LEN + QCAFRM_FOOTER_LEN;\r\nqca->tx_buffer = devm_kmalloc(&qca->serdev->dev, len, GFP_KERNEL);\r\nif (!qca->tx_buffer)\r\nreturn -ENOMEM;\r\nqca->rx_skb = netdev_alloc_skb_ip_align(qca->net_dev,\r\nqca->net_dev->mtu +\r\nVLAN_ETH_HLEN);\r\nif (!qca->rx_skb)\r\nreturn -ENOBUFS;\r\nreturn 0;\r\n}\r\nstatic void qcauart_netdev_uninit(struct net_device *dev)\r\n{\r\nstruct qcauart *qca = netdev_priv(dev);\r\nif (qca->rx_skb)\r\ndev_kfree_skb(qca->rx_skb);\r\n}\r\nstatic void qcauart_netdev_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &qcauart_netdev_ops;\r\ndev->watchdog_timeo = QCAUART_TX_TIMEOUT;\r\ndev->priv_flags &= ~IFF_TX_SKB_SHARING;\r\ndev->tx_queue_len = 100;\r\ndev->min_mtu = QCAFRM_MIN_MTU;\r\ndev->max_mtu = QCAFRM_MAX_MTU;\r\n}\r\nstatic int qca_uart_probe(struct serdev_device *serdev)\r\n{\r\nstruct net_device *qcauart_dev = alloc_etherdev(sizeof(struct qcauart));\r\nstruct qcauart *qca;\r\nconst char *mac;\r\nu32 speed = 115200;\r\nint ret;\r\nif (!qcauart_dev)\r\nreturn -ENOMEM;\r\nqcauart_netdev_setup(qcauart_dev);\r\nSET_NETDEV_DEV(qcauart_dev, &serdev->dev);\r\nqca = netdev_priv(qcauart_dev);\r\nif (!qca) {\r\npr_err("qca_uart: Fail to retrieve private structure\n");\r\nret = -ENOMEM;\r\ngoto free;\r\n}\r\nqca->net_dev = qcauart_dev;\r\nqca->serdev = serdev;\r\nqcafrm_fsm_init_uart(&qca->frm_handle);\r\nspin_lock_init(&qca->lock);\r\nINIT_WORK(&qca->tx_work, qcauart_transmit);\r\nof_property_read_u32(serdev->dev.of_node, "current-speed", &speed);\r\nmac = of_get_mac_address(serdev->dev.of_node);\r\nif (mac)\r\nether_addr_copy(qca->net_dev->dev_addr, mac);\r\nif (!is_valid_ether_addr(qca->net_dev->dev_addr)) {\r\neth_hw_addr_random(qca->net_dev);\r\ndev_info(&serdev->dev, "Using random MAC address: %pM\n",\r\nqca->net_dev->dev_addr);\r\n}\r\nnetif_carrier_on(qca->net_dev);\r\nserdev_device_set_drvdata(serdev, qca);\r\nserdev_device_set_client_ops(serdev, &qca_serdev_ops);\r\nret = serdev_device_open(serdev);\r\nif (ret) {\r\ndev_err(&serdev->dev, "Unable to open device %s\n",\r\nqcauart_dev->name);\r\ngoto free;\r\n}\r\nspeed = serdev_device_set_baudrate(serdev, speed);\r\ndev_info(&serdev->dev, "Using baudrate: %u\n", speed);\r\nserdev_device_set_flow_control(serdev, false);\r\nret = register_netdev(qcauart_dev);\r\nif (ret) {\r\ndev_err(&serdev->dev, "Unable to register net device %s\n",\r\nqcauart_dev->name);\r\nserdev_device_close(serdev);\r\ncancel_work_sync(&qca->tx_work);\r\ngoto free;\r\n}\r\nreturn 0;\r\nfree:\r\nfree_netdev(qcauart_dev);\r\nreturn ret;\r\n}\r\nstatic void qca_uart_remove(struct serdev_device *serdev)\r\n{\r\nstruct qcauart *qca = serdev_device_get_drvdata(serdev);\r\nunregister_netdev(qca->net_dev);\r\nserdev_device_close(serdev);\r\ncancel_work_sync(&qca->tx_work);\r\nfree_netdev(qca->net_dev);\r\n}
