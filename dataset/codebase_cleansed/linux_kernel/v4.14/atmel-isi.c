static void set_dma_ctrl(struct fbd *fb_desc, u32 ctrl)\r\n{\r\nfb_desc->dma_ctrl = ctrl;\r\n}\r\nstatic void isi_writel(struct atmel_isi *isi, u32 reg, u32 val)\r\n{\r\nwritel(val, isi->regs + reg);\r\n}\r\nstatic u32 isi_readl(struct atmel_isi *isi, u32 reg)\r\n{\r\nreturn readl(isi->regs + reg);\r\n}\r\nstatic void configure_geometry(struct atmel_isi *isi)\r\n{\r\nu32 cfg2, psize;\r\nu32 fourcc = isi->current_fmt->fourcc;\r\nisi->enable_preview_path = fourcc == V4L2_PIX_FMT_RGB565 ||\r\nfourcc == V4L2_PIX_FMT_RGB32;\r\ncfg2 = isi->current_fmt->swap;\r\nisi_writel(isi, ISI_CTRL, ISI_CTRL_DIS);\r\ncfg2 |= ((isi->fmt.fmt.pix.width - 1) << ISI_CFG2_IM_HSIZE_OFFSET) &\r\nISI_CFG2_IM_HSIZE_MASK;\r\ncfg2 |= ((isi->fmt.fmt.pix.height - 1) << ISI_CFG2_IM_VSIZE_OFFSET)\r\n& ISI_CFG2_IM_VSIZE_MASK;\r\nisi_writel(isi, ISI_CFG2, cfg2);\r\npsize = ((isi->fmt.fmt.pix.width - 1) << ISI_PSIZE_PREV_HSIZE_OFFSET) &\r\nISI_PSIZE_PREV_HSIZE_MASK;\r\npsize |= ((isi->fmt.fmt.pix.height - 1) << ISI_PSIZE_PREV_VSIZE_OFFSET) &\r\nISI_PSIZE_PREV_VSIZE_MASK;\r\nisi_writel(isi, ISI_PSIZE, psize);\r\nisi_writel(isi, ISI_PDECF, ISI_PDECF_NO_SAMPLING);\r\n}\r\nstatic irqreturn_t atmel_isi_handle_streaming(struct atmel_isi *isi)\r\n{\r\nif (isi->active) {\r\nstruct vb2_v4l2_buffer *vbuf = &isi->active->vb;\r\nstruct frame_buffer *buf = isi->active;\r\nlist_del_init(&buf->list);\r\nvbuf->vb2_buf.timestamp = ktime_get_ns();\r\nvbuf->sequence = isi->sequence++;\r\nvbuf->field = V4L2_FIELD_NONE;\r\nvb2_buffer_done(&vbuf->vb2_buf, VB2_BUF_STATE_DONE);\r\n}\r\nif (list_empty(&isi->video_buffer_list)) {\r\nisi->active = NULL;\r\n} else {\r\nisi->active = list_entry(isi->video_buffer_list.next,\r\nstruct frame_buffer, list);\r\nif (!isi->enable_preview_path) {\r\nisi_writel(isi, ISI_DMA_C_DSCR,\r\n(u32)isi->active->p_dma_desc->fbd_phys);\r\nisi_writel(isi, ISI_DMA_C_CTRL,\r\nISI_DMA_CTRL_FETCH | ISI_DMA_CTRL_DONE);\r\nisi_writel(isi, ISI_DMA_CHER, ISI_DMA_CHSR_C_CH);\r\n} else {\r\nisi_writel(isi, ISI_DMA_P_DSCR,\r\n(u32)isi->active->p_dma_desc->fbd_phys);\r\nisi_writel(isi, ISI_DMA_P_CTRL,\r\nISI_DMA_CTRL_FETCH | ISI_DMA_CTRL_DONE);\r\nisi_writel(isi, ISI_DMA_CHER, ISI_DMA_CHSR_P_CH);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t isi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct atmel_isi *isi = dev_id;\r\nu32 status, mask, pending;\r\nirqreturn_t ret = IRQ_NONE;\r\nspin_lock(&isi->irqlock);\r\nstatus = isi_readl(isi, ISI_STATUS);\r\nmask = isi_readl(isi, ISI_INTMASK);\r\npending = status & mask;\r\nif (pending & ISI_CTRL_SRST) {\r\ncomplete(&isi->complete);\r\nisi_writel(isi, ISI_INTDIS, ISI_CTRL_SRST);\r\nret = IRQ_HANDLED;\r\n} else if (pending & ISI_CTRL_DIS) {\r\ncomplete(&isi->complete);\r\nisi_writel(isi, ISI_INTDIS, ISI_CTRL_DIS);\r\nret = IRQ_HANDLED;\r\n} else {\r\nif (likely(pending & ISI_SR_CXFR_DONE) ||\r\nlikely(pending & ISI_SR_PXFR_DONE))\r\nret = atmel_isi_handle_streaming(isi);\r\n}\r\nspin_unlock(&isi->irqlock);\r\nreturn ret;\r\n}\r\nstatic int atmel_isi_wait_status(struct atmel_isi *isi, int wait_reset)\r\n{\r\nunsigned long timeout;\r\ninit_completion(&isi->complete);\r\nif (wait_reset) {\r\nisi_writel(isi, ISI_INTEN, ISI_CTRL_SRST);\r\nisi_writel(isi, ISI_CTRL, ISI_CTRL_SRST);\r\n} else {\r\nisi_writel(isi, ISI_INTEN, ISI_CTRL_DIS);\r\nisi_writel(isi, ISI_CTRL, ISI_CTRL_DIS);\r\n}\r\ntimeout = wait_for_completion_timeout(&isi->complete,\r\nmsecs_to_jiffies(500));\r\nif (timeout == 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct atmel_isi *isi = vb2_get_drv_priv(vq);\r\nunsigned long size;\r\nsize = isi->fmt.fmt.pix.sizeimage;\r\nif (*nplanes)\r\nreturn sizes[0] < size ? -EINVAL : 0;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nisi->active = NULL;\r\ndev_dbg(isi->dev, "%s, count=%d, size=%ld\n", __func__,\r\n*nbuffers, size);\r\nreturn 0;\r\n}\r\nstatic int buffer_init(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct frame_buffer *buf = container_of(vbuf, struct frame_buffer, vb);\r\nbuf->p_dma_desc = NULL;\r\nINIT_LIST_HEAD(&buf->list);\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct frame_buffer *buf = container_of(vbuf, struct frame_buffer, vb);\r\nstruct atmel_isi *isi = vb2_get_drv_priv(vb->vb2_queue);\r\nunsigned long size;\r\nstruct isi_dma_desc *desc;\r\nsize = isi->fmt.fmt.pix.sizeimage;\r\nif (vb2_plane_size(vb, 0) < size) {\r\ndev_err(isi->dev, "%s data will not fit into plane (%lu < %lu)\n",\r\n__func__, vb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, size);\r\nif (!buf->p_dma_desc) {\r\nif (list_empty(&isi->dma_desc_head)) {\r\ndev_err(isi->dev, "Not enough dma descriptors.\n");\r\nreturn -EINVAL;\r\n} else {\r\ndesc = list_entry(isi->dma_desc_head.next,\r\nstruct isi_dma_desc, list);\r\nlist_del_init(&desc->list);\r\ndesc->p_fbd->fb_address =\r\nvb2_dma_contig_plane_dma_addr(vb, 0);\r\ndesc->p_fbd->next_fbd_address = 0;\r\nset_dma_ctrl(desc->p_fbd, ISI_DMA_CTRL_WB);\r\nbuf->p_dma_desc = desc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void buffer_cleanup(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct atmel_isi *isi = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct frame_buffer *buf = container_of(vbuf, struct frame_buffer, vb);\r\nif (buf->p_dma_desc)\r\nlist_add(&buf->p_dma_desc->list, &isi->dma_desc_head);\r\n}\r\nstatic void start_dma(struct atmel_isi *isi, struct frame_buffer *buffer)\r\n{\r\nu32 ctrl, cfg1;\r\ncfg1 = isi_readl(isi, ISI_CFG1);\r\nisi_writel(isi, ISI_INTEN,\r\nISI_SR_CXFR_DONE | ISI_SR_PXFR_DONE);\r\nif (!isi->enable_preview_path) {\r\nif (isi_readl(isi, ISI_STATUS) & ISI_CTRL_CDC) {\r\ndev_err(isi->dev, "Already in frame handling.\n");\r\nreturn;\r\n}\r\nisi_writel(isi, ISI_DMA_C_DSCR,\r\n(u32)buffer->p_dma_desc->fbd_phys);\r\nisi_writel(isi, ISI_DMA_C_CTRL,\r\nISI_DMA_CTRL_FETCH | ISI_DMA_CTRL_DONE);\r\nisi_writel(isi, ISI_DMA_CHER, ISI_DMA_CHSR_C_CH);\r\n} else {\r\nisi_writel(isi, ISI_DMA_P_DSCR,\r\n(u32)buffer->p_dma_desc->fbd_phys);\r\nisi_writel(isi, ISI_DMA_P_CTRL,\r\nISI_DMA_CTRL_FETCH | ISI_DMA_CTRL_DONE);\r\nisi_writel(isi, ISI_DMA_CHER, ISI_DMA_CHSR_P_CH);\r\n}\r\ncfg1 &= ~ISI_CFG1_FRATE_DIV_MASK;\r\ncfg1 |= isi->pdata.frate | ISI_CFG1_DISCR;\r\nctrl = ISI_CTRL_EN;\r\nif (!isi->enable_preview_path)\r\nctrl |= ISI_CTRL_CDC;\r\nisi_writel(isi, ISI_CTRL, ctrl);\r\nisi_writel(isi, ISI_CFG1, cfg1);\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct atmel_isi *isi = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct frame_buffer *buf = container_of(vbuf, struct frame_buffer, vb);\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&isi->irqlock, flags);\r\nlist_add_tail(&buf->list, &isi->video_buffer_list);\r\nif (isi->active == NULL) {\r\nisi->active = buf;\r\nif (vb2_is_streaming(vb->vb2_queue))\r\nstart_dma(isi, buf);\r\n}\r\nspin_unlock_irqrestore(&isi->irqlock, flags);\r\n}\r\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct atmel_isi *isi = vb2_get_drv_priv(vq);\r\nstruct frame_buffer *buf, *node;\r\nint ret;\r\npm_runtime_get_sync(isi->dev);\r\nret = v4l2_subdev_call(isi->entity.subdev, video, s_stream, 1);\r\nif (ret && ret != -ENOIOCTLCMD) {\r\ndev_err(isi->dev, "stream on failed in subdev\n");\r\ngoto err_start_stream;\r\n}\r\nret = atmel_isi_wait_status(isi, WAIT_ISI_RESET);\r\nif (ret < 0) {\r\ndev_err(isi->dev, "Reset ISI timed out\n");\r\ngoto err_reset;\r\n}\r\nisi_writel(isi, ISI_INTDIS, (u32)~0UL);\r\nisi->sequence = 0;\r\nconfigure_geometry(isi);\r\nspin_lock_irq(&isi->irqlock);\r\nisi_readl(isi, ISI_STATUS);\r\nstart_dma(isi, isi->active);\r\nspin_unlock_irq(&isi->irqlock);\r\nreturn 0;\r\nerr_reset:\r\nv4l2_subdev_call(isi->entity.subdev, video, s_stream, 0);\r\nerr_start_stream:\r\npm_runtime_put(isi->dev);\r\nspin_lock_irq(&isi->irqlock);\r\nisi->active = NULL;\r\nlist_for_each_entry_safe(buf, node, &isi->video_buffer_list, list) {\r\nlist_del_init(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\r\n}\r\nspin_unlock_irq(&isi->irqlock);\r\nreturn ret;\r\n}\r\nstatic void stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct atmel_isi *isi = vb2_get_drv_priv(vq);\r\nstruct frame_buffer *buf, *node;\r\nint ret = 0;\r\nunsigned long timeout;\r\nret = v4l2_subdev_call(isi->entity.subdev, video, s_stream, 0);\r\nif (ret && ret != -ENOIOCTLCMD)\r\ndev_err(isi->dev, "stream off failed in subdev\n");\r\nspin_lock_irq(&isi->irqlock);\r\nisi->active = NULL;\r\nlist_for_each_entry_safe(buf, node, &isi->video_buffer_list, list) {\r\nlist_del_init(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irq(&isi->irqlock);\r\nif (!isi->enable_preview_path) {\r\ntimeout = jiffies + FRAME_INTERVAL_MILLI_SEC * HZ;\r\nwhile ((isi_readl(isi, ISI_STATUS) & ISI_CTRL_CDC) &&\r\ntime_before(jiffies, timeout))\r\nmsleep(1);\r\nif (time_after(jiffies, timeout))\r\ndev_err(isi->dev,\r\n"Timeout waiting for finishing codec request\n");\r\n}\r\nisi_writel(isi, ISI_INTDIS,\r\nISI_SR_CXFR_DONE | ISI_SR_PXFR_DONE);\r\nret = atmel_isi_wait_status(isi, WAIT_ISI_DISABLE);\r\nif (ret < 0)\r\ndev_err(isi->dev, "Disable ISI timed out\n");\r\npm_runtime_put(isi->dev);\r\n}\r\nstatic int isi_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct atmel_isi *isi = video_drvdata(file);\r\n*fmt = isi->fmt;\r\nreturn 0;\r\n}\r\nstatic const struct isi_format *find_format_by_fourcc(struct atmel_isi *isi,\r\nunsigned int fourcc)\r\n{\r\nunsigned int num_formats = isi->num_user_formats;\r\nconst struct isi_format *fmt;\r\nunsigned int i;\r\nfor (i = 0; i < num_formats; i++) {\r\nfmt = isi->user_formats[i];\r\nif (fmt->fourcc == fourcc)\r\nreturn fmt;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int isi_try_fmt(struct atmel_isi *isi, struct v4l2_format *f,\r\nconst struct isi_format **current_fmt)\r\n{\r\nconst struct isi_format *isi_fmt;\r\nstruct v4l2_pix_format *pixfmt = &f->fmt.pix;\r\nstruct v4l2_subdev_pad_config pad_cfg;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_TRY,\r\n};\r\nint ret;\r\nisi_fmt = find_format_by_fourcc(isi, pixfmt->pixelformat);\r\nif (!isi_fmt) {\r\nisi_fmt = isi->user_formats[isi->num_user_formats - 1];\r\npixfmt->pixelformat = isi_fmt->fourcc;\r\n}\r\npixfmt->width = clamp(pixfmt->width, 0U, MAX_SUPPORT_WIDTH);\r\npixfmt->height = clamp(pixfmt->height, 0U, MAX_SUPPORT_HEIGHT);\r\nv4l2_fill_mbus_format(&format.format, pixfmt, isi_fmt->mbus_code);\r\nret = v4l2_subdev_call(isi->entity.subdev, pad, set_fmt,\r\n&pad_cfg, &format);\r\nif (ret < 0)\r\nreturn ret;\r\nv4l2_fill_pix_format(pixfmt, &format.format);\r\npixfmt->field = V4L2_FIELD_NONE;\r\npixfmt->bytesperline = pixfmt->width * isi_fmt->bpp;\r\npixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height;\r\nif (current_fmt)\r\n*current_fmt = isi_fmt;\r\nreturn 0;\r\n}\r\nstatic int isi_set_fmt(struct atmel_isi *isi, struct v4l2_format *f)\r\n{\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nconst struct isi_format *current_fmt;\r\nint ret;\r\nret = isi_try_fmt(isi, f, &current_fmt);\r\nif (ret)\r\nreturn ret;\r\nv4l2_fill_mbus_format(&format.format, &f->fmt.pix,\r\ncurrent_fmt->mbus_code);\r\nret = v4l2_subdev_call(isi->entity.subdev, pad,\r\nset_fmt, NULL, &format);\r\nif (ret < 0)\r\nreturn ret;\r\nisi->fmt = *f;\r\nisi->current_fmt = current_fmt;\r\nreturn 0;\r\n}\r\nstatic int isi_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct atmel_isi *isi = video_drvdata(file);\r\nif (vb2_is_streaming(&isi->queue))\r\nreturn -EBUSY;\r\nreturn isi_set_fmt(isi, f);\r\n}\r\nstatic int isi_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct atmel_isi *isi = video_drvdata(file);\r\nreturn isi_try_fmt(isi, f, NULL);\r\n}\r\nstatic int isi_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct atmel_isi *isi = video_drvdata(file);\r\nif (f->index >= isi->num_user_formats)\r\nreturn -EINVAL;\r\nf->pixelformat = isi->user_formats[f->index]->fourcc;\r\nreturn 0;\r\n}\r\nstatic int isi_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrlcpy(cap->driver, "atmel-isi", sizeof(cap->driver));\r\nstrlcpy(cap->card, "Atmel Image Sensor Interface", sizeof(cap->card));\r\nstrlcpy(cap->bus_info, "platform:isi", sizeof(cap->bus_info));\r\nreturn 0;\r\n}\r\nstatic int isi_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nif (i->index != 0)\r\nreturn -EINVAL;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrlcpy(i->name, "Camera", sizeof(i->name));\r\nreturn 0;\r\n}\r\nstatic int isi_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int isi_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nif (i > 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int isi_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\r\n{\r\nstruct atmel_isi *isi = video_drvdata(file);\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\na->parm.capture.readbuffers = 2;\r\nreturn v4l2_subdev_call(isi->entity.subdev, video, g_parm, a);\r\n}\r\nstatic int isi_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\r\n{\r\nstruct atmel_isi *isi = video_drvdata(file);\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\na->parm.capture.readbuffers = 2;\r\nreturn v4l2_subdev_call(isi->entity.subdev, video, s_parm, a);\r\n}\r\nstatic int isi_enum_framesizes(struct file *file, void *fh,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct atmel_isi *isi = video_drvdata(file);\r\nconst struct isi_format *isi_fmt;\r\nstruct v4l2_subdev_frame_size_enum fse = {\r\n.index = fsize->index,\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nint ret;\r\nisi_fmt = find_format_by_fourcc(isi, fsize->pixel_format);\r\nif (!isi_fmt)\r\nreturn -EINVAL;\r\nfse.code = isi_fmt->mbus_code;\r\nret = v4l2_subdev_call(isi->entity.subdev, pad, enum_frame_size,\r\nNULL, &fse);\r\nif (ret)\r\nreturn ret;\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfsize->discrete.width = fse.max_width;\r\nfsize->discrete.height = fse.max_height;\r\nreturn 0;\r\n}\r\nstatic int isi_enum_frameintervals(struct file *file, void *fh,\r\nstruct v4l2_frmivalenum *fival)\r\n{\r\nstruct atmel_isi *isi = video_drvdata(file);\r\nconst struct isi_format *isi_fmt;\r\nstruct v4l2_subdev_frame_interval_enum fie = {\r\n.index = fival->index,\r\n.width = fival->width,\r\n.height = fival->height,\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nint ret;\r\nisi_fmt = find_format_by_fourcc(isi, fival->pixel_format);\r\nif (!isi_fmt)\r\nreturn -EINVAL;\r\nfie.code = isi_fmt->mbus_code;\r\nret = v4l2_subdev_call(isi->entity.subdev, pad,\r\nenum_frame_interval, NULL, &fie);\r\nif (ret)\r\nreturn ret;\r\nfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\r\nfival->discrete = fie.interval;\r\nreturn 0;\r\n}\r\nstatic void isi_camera_set_bus_param(struct atmel_isi *isi)\r\n{\r\nu32 cfg1 = 0;\r\nif (isi->pdata.hsync_act_low)\r\ncfg1 |= ISI_CFG1_HSYNC_POL_ACTIVE_LOW;\r\nif (isi->pdata.vsync_act_low)\r\ncfg1 |= ISI_CFG1_VSYNC_POL_ACTIVE_LOW;\r\nif (isi->pdata.pclk_act_falling)\r\ncfg1 |= ISI_CFG1_PIXCLK_POL_ACTIVE_FALLING;\r\nif (isi->pdata.has_emb_sync)\r\ncfg1 |= ISI_CFG1_EMB_SYNC;\r\nif (isi->pdata.full_mode)\r\ncfg1 |= ISI_CFG1_FULL_MODE;\r\ncfg1 |= ISI_CFG1_THMASK_BEATS_16;\r\npm_runtime_get_sync(isi->dev);\r\nisi_writel(isi, ISI_CTRL, ISI_CTRL_DIS);\r\nisi_writel(isi, ISI_CFG1, cfg1);\r\npm_runtime_put(isi->dev);\r\n}\r\nstatic int atmel_isi_parse_dt(struct atmel_isi *isi,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct v4l2_fwnode_endpoint ep;\r\nint err;\r\nisi->pdata.full_mode = 1;\r\nisi->pdata.frate = ISI_CFG1_FRATE_CAPTURE_ALL;\r\nnp = of_graph_get_next_endpoint(np, NULL);\r\nif (!np) {\r\ndev_err(&pdev->dev, "Could not find the endpoint\n");\r\nreturn -EINVAL;\r\n}\r\nerr = v4l2_fwnode_endpoint_parse(of_fwnode_handle(np), &ep);\r\nof_node_put(np);\r\nif (err) {\r\ndev_err(&pdev->dev, "Could not parse the endpoint\n");\r\nreturn err;\r\n}\r\nswitch (ep.bus.parallel.bus_width) {\r\ncase 8:\r\nisi->pdata.data_width_flags = ISI_DATAWIDTH_8;\r\nbreak;\r\ncase 10:\r\nisi->pdata.data_width_flags =\r\nISI_DATAWIDTH_8 | ISI_DATAWIDTH_10;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unsupported bus width: %d\n",\r\nep.bus.parallel.bus_width);\r\nreturn -EINVAL;\r\n}\r\nif (ep.bus.parallel.flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\r\nisi->pdata.hsync_act_low = true;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\r\nisi->pdata.vsync_act_low = true;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\nisi->pdata.pclk_act_falling = true;\r\nif (ep.bus_type == V4L2_MBUS_BT656)\r\nisi->pdata.has_emb_sync = true;\r\nreturn 0;\r\n}\r\nstatic int isi_open(struct file *file)\r\n{\r\nstruct atmel_isi *isi = video_drvdata(file);\r\nstruct v4l2_subdev *sd = isi->entity.subdev;\r\nint ret;\r\nif (mutex_lock_interruptible(&isi->lock))\r\nreturn -ERESTARTSYS;\r\nret = v4l2_fh_open(file);\r\nif (ret < 0)\r\ngoto unlock;\r\nif (!v4l2_fh_is_singular_file(file))\r\ngoto fh_rel;\r\nret = v4l2_subdev_call(sd, core, s_power, 1);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\ngoto fh_rel;\r\nret = isi_set_fmt(isi, &isi->fmt);\r\nif (ret)\r\nv4l2_subdev_call(sd, core, s_power, 0);\r\nfh_rel:\r\nif (ret)\r\nv4l2_fh_release(file);\r\nunlock:\r\nmutex_unlock(&isi->lock);\r\nreturn ret;\r\n}\r\nstatic int isi_release(struct file *file)\r\n{\r\nstruct atmel_isi *isi = video_drvdata(file);\r\nstruct v4l2_subdev *sd = isi->entity.subdev;\r\nbool fh_singular;\r\nint ret;\r\nmutex_lock(&isi->lock);\r\nfh_singular = v4l2_fh_is_singular_file(file);\r\nret = _vb2_fop_release(file, NULL);\r\nif (fh_singular)\r\nv4l2_subdev_call(sd, core, s_power, 0);\r\nmutex_unlock(&isi->lock);\r\nreturn ret;\r\n}\r\nstatic int isi_set_default_fmt(struct atmel_isi *isi)\r\n{\r\nstruct v4l2_format f = {\r\n.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\r\n.fmt.pix = {\r\n.width = VGA_WIDTH,\r\n.height = VGA_HEIGHT,\r\n.field = V4L2_FIELD_NONE,\r\n.pixelformat = isi->user_formats[0]->fourcc,\r\n},\r\n};\r\nint ret;\r\nret = isi_try_fmt(isi, &f, NULL);\r\nif (ret)\r\nreturn ret;\r\nisi->current_fmt = isi->user_formats[0];\r\nisi->fmt = f;\r\nreturn 0;\r\n}\r\nstatic int isi_formats_init(struct atmel_isi *isi)\r\n{\r\nconst struct isi_format *isi_fmts[ARRAY_SIZE(isi_formats)];\r\nunsigned int num_fmts = 0, i, j;\r\nstruct v4l2_subdev *subdev = isi->entity.subdev;\r\nstruct v4l2_subdev_mbus_code_enum mbus_code = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nwhile (!v4l2_subdev_call(subdev, pad, enum_mbus_code,\r\nNULL, &mbus_code)) {\r\nfor (i = 0; i < ARRAY_SIZE(isi_formats); i++) {\r\nif (isi_formats[i].mbus_code != mbus_code.code)\r\ncontinue;\r\nfor (j = 0; j < num_fmts; j++)\r\nif (isi_fmts[j]->fourcc == isi_formats[i].fourcc)\r\nbreak;\r\nif (j == num_fmts)\r\nisi_fmts[num_fmts++] = isi_formats + i;\r\n}\r\nmbus_code.index++;\r\n}\r\nif (!num_fmts)\r\nreturn -ENXIO;\r\nisi->num_user_formats = num_fmts;\r\nisi->user_formats = devm_kcalloc(isi->dev,\r\nnum_fmts, sizeof(struct isi_format *),\r\nGFP_KERNEL);\r\nif (!isi->user_formats) {\r\ndev_err(isi->dev, "could not allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(isi->user_formats, isi_fmts,\r\nnum_fmts * sizeof(struct isi_format *));\r\nisi->current_fmt = isi->user_formats[0];\r\nreturn 0;\r\n}\r\nstatic int isi_graph_notify_complete(struct v4l2_async_notifier *notifier)\r\n{\r\nstruct atmel_isi *isi = notifier_to_isi(notifier);\r\nint ret;\r\nisi->vdev->ctrl_handler = isi->entity.subdev->ctrl_handler;\r\nret = isi_formats_init(isi);\r\nif (ret) {\r\ndev_err(isi->dev, "No supported mediabus format found\n");\r\nreturn ret;\r\n}\r\nisi_camera_set_bus_param(isi);\r\nret = isi_set_default_fmt(isi);\r\nif (ret) {\r\ndev_err(isi->dev, "Could not set default format\n");\r\nreturn ret;\r\n}\r\nret = video_register_device(isi->vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret) {\r\ndev_err(isi->dev, "Failed to register video device\n");\r\nreturn ret;\r\n}\r\ndev_dbg(isi->dev, "Device registered as %s\n",\r\nvideo_device_node_name(isi->vdev));\r\nreturn 0;\r\n}\r\nstatic void isi_graph_notify_unbind(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *sd,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nstruct atmel_isi *isi = notifier_to_isi(notifier);\r\ndev_dbg(isi->dev, "Removing %s\n", video_device_node_name(isi->vdev));\r\nvideo_unregister_device(isi->vdev);\r\n}\r\nstatic int isi_graph_notify_bound(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nstruct atmel_isi *isi = notifier_to_isi(notifier);\r\ndev_dbg(isi->dev, "subdev %s bound\n", subdev->name);\r\nisi->entity.subdev = subdev;\r\nreturn 0;\r\n}\r\nstatic int isi_graph_parse(struct atmel_isi *isi, struct device_node *node)\r\n{\r\nstruct device_node *ep = NULL;\r\nstruct device_node *remote;\r\nwhile (1) {\r\nep = of_graph_get_next_endpoint(node, ep);\r\nif (!ep)\r\nreturn -EINVAL;\r\nremote = of_graph_get_remote_port_parent(ep);\r\nif (!remote) {\r\nof_node_put(ep);\r\nreturn -EINVAL;\r\n}\r\nisi->entity.node = remote;\r\nisi->entity.asd.match_type = V4L2_ASYNC_MATCH_FWNODE;\r\nisi->entity.asd.match.fwnode.fwnode = of_fwnode_handle(remote);\r\nreturn 0;\r\n}\r\n}\r\nstatic int isi_graph_init(struct atmel_isi *isi)\r\n{\r\nstruct v4l2_async_subdev **subdevs = NULL;\r\nint ret;\r\nret = isi_graph_parse(isi, isi->dev->of_node);\r\nif (ret < 0) {\r\ndev_err(isi->dev, "Graph parsing failed\n");\r\nreturn ret;\r\n}\r\nsubdevs = devm_kzalloc(isi->dev, sizeof(*subdevs), GFP_KERNEL);\r\nif (subdevs == NULL) {\r\nof_node_put(isi->entity.node);\r\nreturn -ENOMEM;\r\n}\r\nsubdevs[0] = &isi->entity.asd;\r\nisi->notifier.subdevs = subdevs;\r\nisi->notifier.num_subdevs = 1;\r\nisi->notifier.bound = isi_graph_notify_bound;\r\nisi->notifier.unbind = isi_graph_notify_unbind;\r\nisi->notifier.complete = isi_graph_notify_complete;\r\nret = v4l2_async_notifier_register(&isi->v4l2_dev, &isi->notifier);\r\nif (ret < 0) {\r\ndev_err(isi->dev, "Notifier registration failed\n");\r\nof_node_put(isi->entity.node);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_isi_probe(struct platform_device *pdev)\r\n{\r\nint irq;\r\nstruct atmel_isi *isi;\r\nstruct vb2_queue *q;\r\nstruct resource *regs;\r\nint ret, i;\r\nisi = devm_kzalloc(&pdev->dev, sizeof(struct atmel_isi), GFP_KERNEL);\r\nif (!isi) {\r\ndev_err(&pdev->dev, "Can't allocate interface!\n");\r\nreturn -ENOMEM;\r\n}\r\nisi->pclk = devm_clk_get(&pdev->dev, "isi_clk");\r\nif (IS_ERR(isi->pclk))\r\nreturn PTR_ERR(isi->pclk);\r\nret = atmel_isi_parse_dt(isi, pdev);\r\nif (ret)\r\nreturn ret;\r\nisi->active = NULL;\r\nisi->dev = &pdev->dev;\r\nmutex_init(&isi->lock);\r\nspin_lock_init(&isi->irqlock);\r\nINIT_LIST_HEAD(&isi->video_buffer_list);\r\nINIT_LIST_HEAD(&isi->dma_desc_head);\r\nq = &isi->queue;\r\nret = v4l2_device_register(&pdev->dev, &isi->v4l2_dev);\r\nif (ret)\r\nreturn ret;\r\nisi->vdev = video_device_alloc();\r\nif (isi->vdev == NULL) {\r\nret = -ENOMEM;\r\ngoto err_vdev_alloc;\r\n}\r\nisi->vdev->fops = &isi_fops;\r\nisi->vdev->v4l2_dev = &isi->v4l2_dev;\r\nisi->vdev->queue = &isi->queue;\r\nstrlcpy(isi->vdev->name, KBUILD_MODNAME, sizeof(isi->vdev->name));\r\nisi->vdev->release = video_device_release;\r\nisi->vdev->ioctl_ops = &isi_ioctl_ops;\r\nisi->vdev->lock = &isi->lock;\r\nisi->vdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\r\nV4L2_CAP_READWRITE;\r\nvideo_set_drvdata(isi->vdev, isi);\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;\r\nq->lock = &isi->lock;\r\nq->drv_priv = isi;\r\nq->buf_struct_size = sizeof(struct frame_buffer);\r\nq->ops = &isi_video_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->min_buffers_needed = 2;\r\nq->dev = &pdev->dev;\r\nret = vb2_queue_init(q);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to initialize VB2 queue\n");\r\ngoto err_vb2_queue;\r\n}\r\nisi->p_fb_descriptors = dma_alloc_coherent(&pdev->dev,\r\nsizeof(struct fbd) * VIDEO_MAX_FRAME,\r\n&isi->fb_descriptors_phys,\r\nGFP_KERNEL);\r\nif (!isi->p_fb_descriptors) {\r\ndev_err(&pdev->dev, "Can't allocate descriptors!\n");\r\nret = -ENOMEM;\r\ngoto err_dma_alloc;\r\n}\r\nfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\r\nisi->dma_desc[i].p_fbd = isi->p_fb_descriptors + i;\r\nisi->dma_desc[i].fbd_phys = isi->fb_descriptors_phys +\r\ni * sizeof(struct fbd);\r\nlist_add(&isi->dma_desc[i].list, &isi->dma_desc_head);\r\n}\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nisi->regs = devm_ioremap_resource(&pdev->dev, regs);\r\nif (IS_ERR(isi->regs)) {\r\nret = PTR_ERR(isi->regs);\r\ngoto err_ioremap;\r\n}\r\nif (isi->pdata.data_width_flags & ISI_DATAWIDTH_8)\r\nisi->width_flags = 1 << 7;\r\nif (isi->pdata.data_width_flags & ISI_DATAWIDTH_10)\r\nisi->width_flags |= 1 << 9;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nret = irq;\r\ngoto err_req_irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, isi_interrupt, 0, "isi", isi);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to request irq %d\n", irq);\r\ngoto err_req_irq;\r\n}\r\nisi->irq = irq;\r\nret = isi_graph_init(isi);\r\nif (ret < 0)\r\ngoto err_req_irq;\r\npm_suspend_ignore_children(&pdev->dev, true);\r\npm_runtime_enable(&pdev->dev);\r\nplatform_set_drvdata(pdev, isi);\r\nreturn 0;\r\nerr_req_irq:\r\nerr_ioremap:\r\ndma_free_coherent(&pdev->dev,\r\nsizeof(struct fbd) * VIDEO_MAX_FRAME,\r\nisi->p_fb_descriptors,\r\nisi->fb_descriptors_phys);\r\nerr_dma_alloc:\r\nerr_vb2_queue:\r\nvideo_device_release(isi->vdev);\r\nerr_vdev_alloc:\r\nv4l2_device_unregister(&isi->v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic int atmel_isi_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_isi *isi = platform_get_drvdata(pdev);\r\ndma_free_coherent(&pdev->dev,\r\nsizeof(struct fbd) * VIDEO_MAX_FRAME,\r\nisi->p_fb_descriptors,\r\nisi->fb_descriptors_phys);\r\npm_runtime_disable(&pdev->dev);\r\nv4l2_async_notifier_unregister(&isi->notifier);\r\nv4l2_device_unregister(&isi->v4l2_dev);\r\nreturn 0;\r\n}\r\nstatic int atmel_isi_runtime_suspend(struct device *dev)\r\n{\r\nstruct atmel_isi *isi = dev_get_drvdata(dev);\r\nclk_disable_unprepare(isi->pclk);\r\nreturn 0;\r\n}\r\nstatic int atmel_isi_runtime_resume(struct device *dev)\r\n{\r\nstruct atmel_isi *isi = dev_get_drvdata(dev);\r\nreturn clk_prepare_enable(isi->pclk);\r\n}
