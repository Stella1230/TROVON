static int __init option_setup(char *opt)\r\n{\r\nstrlcpy(config, opt, MAX_PARAM_LENGTH);\r\nreturn 1;\r\n}\r\nstatic int __init dynamic_netconsole_init(void)\r\n{\r\nconfig_group_init(&netconsole_subsys.su_group);\r\nmutex_init(&netconsole_subsys.su_mutex);\r\nreturn configfs_register_subsystem(&netconsole_subsys);\r\n}\r\nstatic void __exit dynamic_netconsole_exit(void)\r\n{\r\nconfigfs_unregister_subsystem(&netconsole_subsys);\r\n}\r\nstatic void netconsole_target_get(struct netconsole_target *nt)\r\n{\r\nif (config_item_name(&nt->item))\r\nconfig_item_get(&nt->item);\r\n}\r\nstatic void netconsole_target_put(struct netconsole_target *nt)\r\n{\r\nif (config_item_name(&nt->item))\r\nconfig_item_put(&nt->item);\r\n}\r\nstatic int __init dynamic_netconsole_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit dynamic_netconsole_exit(void)\r\n{\r\n}\r\nstatic void netconsole_target_get(struct netconsole_target *nt)\r\n{\r\n}\r\nstatic void netconsole_target_put(struct netconsole_target *nt)\r\n{\r\n}\r\nstatic struct netconsole_target *alloc_param_target(char *target_config)\r\n{\r\nint err = -ENOMEM;\r\nstruct netconsole_target *nt;\r\nnt = kzalloc(sizeof(*nt), GFP_KERNEL);\r\nif (!nt)\r\ngoto fail;\r\nnt->np.name = "netconsole";\r\nstrlcpy(nt->np.dev_name, "eth0", IFNAMSIZ);\r\nnt->np.local_port = 6665;\r\nnt->np.remote_port = 6666;\r\neth_broadcast_addr(nt->np.remote_mac);\r\nif (*target_config == '+') {\r\nnt->extended = true;\r\ntarget_config++;\r\n}\r\nerr = netpoll_parse_options(&nt->np, target_config);\r\nif (err)\r\ngoto fail;\r\nerr = netpoll_setup(&nt->np);\r\nif (err)\r\ngoto fail;\r\nnt->enabled = true;\r\nreturn nt;\r\nfail:\r\nkfree(nt);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void free_param_target(struct netconsole_target *nt)\r\n{\r\nnetpoll_cleanup(&nt->np);\r\nkfree(nt);\r\n}\r\nstatic struct netconsole_target *to_target(struct config_item *item)\r\n{\r\nreturn item ?\r\ncontainer_of(item, struct netconsole_target, item) :\r\nNULL;\r\n}\r\nstatic ssize_t enabled_show(struct config_item *item, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", to_target(item)->enabled);\r\n}\r\nstatic ssize_t extended_show(struct config_item *item, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", to_target(item)->extended);\r\n}\r\nstatic ssize_t dev_name_show(struct config_item *item, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", to_target(item)->np.dev_name);\r\n}\r\nstatic ssize_t local_port_show(struct config_item *item, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", to_target(item)->np.local_port);\r\n}\r\nstatic ssize_t remote_port_show(struct config_item *item, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", to_target(item)->np.remote_port);\r\n}\r\nstatic ssize_t local_ip_show(struct config_item *item, char *buf)\r\n{\r\nstruct netconsole_target *nt = to_target(item);\r\nif (nt->np.ipv6)\r\nreturn snprintf(buf, PAGE_SIZE, "%pI6c\n", &nt->np.local_ip.in6);\r\nelse\r\nreturn snprintf(buf, PAGE_SIZE, "%pI4\n", &nt->np.local_ip);\r\n}\r\nstatic ssize_t remote_ip_show(struct config_item *item, char *buf)\r\n{\r\nstruct netconsole_target *nt = to_target(item);\r\nif (nt->np.ipv6)\r\nreturn snprintf(buf, PAGE_SIZE, "%pI6c\n", &nt->np.remote_ip.in6);\r\nelse\r\nreturn snprintf(buf, PAGE_SIZE, "%pI4\n", &nt->np.remote_ip);\r\n}\r\nstatic ssize_t local_mac_show(struct config_item *item, char *buf)\r\n{\r\nstruct net_device *dev = to_target(item)->np.dev;\r\nstatic const u8 bcast[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\r\nreturn snprintf(buf, PAGE_SIZE, "%pM\n", dev ? dev->dev_addr : bcast);\r\n}\r\nstatic ssize_t remote_mac_show(struct config_item *item, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%pM\n", to_target(item)->np.remote_mac);\r\n}\r\nstatic ssize_t enabled_store(struct config_item *item,\r\nconst char *buf, size_t count)\r\n{\r\nstruct netconsole_target *nt = to_target(item);\r\nunsigned long flags;\r\nint enabled;\r\nint err;\r\nmutex_lock(&dynamic_netconsole_mutex);\r\nerr = kstrtoint(buf, 10, &enabled);\r\nif (err < 0)\r\ngoto out_unlock;\r\nerr = -EINVAL;\r\nif (enabled < 0 || enabled > 1)\r\ngoto out_unlock;\r\nif ((bool)enabled == nt->enabled) {\r\npr_info("network logging has already %s\n",\r\nnt->enabled ? "started" : "stopped");\r\ngoto out_unlock;\r\n}\r\nif (enabled) {\r\nif (nt->extended && !(netconsole_ext.flags & CON_ENABLED)) {\r\nnetconsole_ext.flags |= CON_ENABLED;\r\nregister_console(&netconsole_ext);\r\n}\r\nnetpoll_print_options(&nt->np);\r\nerr = netpoll_setup(&nt->np);\r\nif (err)\r\ngoto out_unlock;\r\npr_info("network logging started\n");\r\n} else {\r\nspin_lock_irqsave(&target_list_lock, flags);\r\nnt->enabled = false;\r\nspin_unlock_irqrestore(&target_list_lock, flags);\r\nnetpoll_cleanup(&nt->np);\r\n}\r\nnt->enabled = enabled;\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn strnlen(buf, count);\r\nout_unlock:\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn err;\r\n}\r\nstatic ssize_t extended_store(struct config_item *item, const char *buf,\r\nsize_t count)\r\n{\r\nstruct netconsole_target *nt = to_target(item);\r\nint extended;\r\nint err;\r\nmutex_lock(&dynamic_netconsole_mutex);\r\nif (nt->enabled) {\r\npr_err("target (%s) is enabled, disable to update parameters\n",\r\nconfig_item_name(&nt->item));\r\nerr = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nerr = kstrtoint(buf, 10, &extended);\r\nif (err < 0)\r\ngoto out_unlock;\r\nif (extended < 0 || extended > 1) {\r\nerr = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nnt->extended = extended;\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn strnlen(buf, count);\r\nout_unlock:\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn err;\r\n}\r\nstatic ssize_t dev_name_store(struct config_item *item, const char *buf,\r\nsize_t count)\r\n{\r\nstruct netconsole_target *nt = to_target(item);\r\nsize_t len;\r\nmutex_lock(&dynamic_netconsole_mutex);\r\nif (nt->enabled) {\r\npr_err("target (%s) is enabled, disable to update parameters\n",\r\nconfig_item_name(&nt->item));\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn -EINVAL;\r\n}\r\nstrlcpy(nt->np.dev_name, buf, IFNAMSIZ);\r\nlen = strnlen(nt->np.dev_name, IFNAMSIZ);\r\nif (nt->np.dev_name[len - 1] == '\n')\r\nnt->np.dev_name[len - 1] = '\0';\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t local_port_store(struct config_item *item, const char *buf,\r\nsize_t count)\r\n{\r\nstruct netconsole_target *nt = to_target(item);\r\nint rv = -EINVAL;\r\nmutex_lock(&dynamic_netconsole_mutex);\r\nif (nt->enabled) {\r\npr_err("target (%s) is enabled, disable to update parameters\n",\r\nconfig_item_name(&nt->item));\r\ngoto out_unlock;\r\n}\r\nrv = kstrtou16(buf, 10, &nt->np.local_port);\r\nif (rv < 0)\r\ngoto out_unlock;\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn strnlen(buf, count);\r\nout_unlock:\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn rv;\r\n}\r\nstatic ssize_t remote_port_store(struct config_item *item,\r\nconst char *buf, size_t count)\r\n{\r\nstruct netconsole_target *nt = to_target(item);\r\nint rv = -EINVAL;\r\nmutex_lock(&dynamic_netconsole_mutex);\r\nif (nt->enabled) {\r\npr_err("target (%s) is enabled, disable to update parameters\n",\r\nconfig_item_name(&nt->item));\r\ngoto out_unlock;\r\n}\r\nrv = kstrtou16(buf, 10, &nt->np.remote_port);\r\nif (rv < 0)\r\ngoto out_unlock;\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn strnlen(buf, count);\r\nout_unlock:\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn rv;\r\n}\r\nstatic ssize_t local_ip_store(struct config_item *item, const char *buf,\r\nsize_t count)\r\n{\r\nstruct netconsole_target *nt = to_target(item);\r\nmutex_lock(&dynamic_netconsole_mutex);\r\nif (nt->enabled) {\r\npr_err("target (%s) is enabled, disable to update parameters\n",\r\nconfig_item_name(&nt->item));\r\ngoto out_unlock;\r\n}\r\nif (strnchr(buf, count, ':')) {\r\nconst char *end;\r\nif (in6_pton(buf, count, nt->np.local_ip.in6.s6_addr, -1, &end) > 0) {\r\nif (*end && *end != '\n') {\r\npr_err("invalid IPv6 address at: <%c>\n", *end);\r\ngoto out_unlock;\r\n}\r\nnt->np.ipv6 = true;\r\n} else\r\ngoto out_unlock;\r\n} else {\r\nif (!nt->np.ipv6) {\r\nnt->np.local_ip.ip = in_aton(buf);\r\n} else\r\ngoto out_unlock;\r\n}\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn strnlen(buf, count);\r\nout_unlock:\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t remote_ip_store(struct config_item *item, const char *buf,\r\nsize_t count)\r\n{\r\nstruct netconsole_target *nt = to_target(item);\r\nmutex_lock(&dynamic_netconsole_mutex);\r\nif (nt->enabled) {\r\npr_err("target (%s) is enabled, disable to update parameters\n",\r\nconfig_item_name(&nt->item));\r\ngoto out_unlock;\r\n}\r\nif (strnchr(buf, count, ':')) {\r\nconst char *end;\r\nif (in6_pton(buf, count, nt->np.remote_ip.in6.s6_addr, -1, &end) > 0) {\r\nif (*end && *end != '\n') {\r\npr_err("invalid IPv6 address at: <%c>\n", *end);\r\ngoto out_unlock;\r\n}\r\nnt->np.ipv6 = true;\r\n} else\r\ngoto out_unlock;\r\n} else {\r\nif (!nt->np.ipv6) {\r\nnt->np.remote_ip.ip = in_aton(buf);\r\n} else\r\ngoto out_unlock;\r\n}\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn strnlen(buf, count);\r\nout_unlock:\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t remote_mac_store(struct config_item *item, const char *buf,\r\nsize_t count)\r\n{\r\nstruct netconsole_target *nt = to_target(item);\r\nu8 remote_mac[ETH_ALEN];\r\nmutex_lock(&dynamic_netconsole_mutex);\r\nif (nt->enabled) {\r\npr_err("target (%s) is enabled, disable to update parameters\n",\r\nconfig_item_name(&nt->item));\r\ngoto out_unlock;\r\n}\r\nif (!mac_pton(buf, remote_mac))\r\ngoto out_unlock;\r\nif (buf[3 * ETH_ALEN - 1] && buf[3 * ETH_ALEN - 1] != '\n')\r\ngoto out_unlock;\r\nmemcpy(nt->np.remote_mac, remote_mac, ETH_ALEN);\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn strnlen(buf, count);\r\nout_unlock:\r\nmutex_unlock(&dynamic_netconsole_mutex);\r\nreturn -EINVAL;\r\n}\r\nstatic void netconsole_target_release(struct config_item *item)\r\n{\r\nkfree(to_target(item));\r\n}\r\nstatic struct config_item *make_netconsole_target(struct config_group *group,\r\nconst char *name)\r\n{\r\nunsigned long flags;\r\nstruct netconsole_target *nt;\r\nnt = kzalloc(sizeof(*nt), GFP_KERNEL);\r\nif (!nt)\r\nreturn ERR_PTR(-ENOMEM);\r\nnt->np.name = "netconsole";\r\nstrlcpy(nt->np.dev_name, "eth0", IFNAMSIZ);\r\nnt->np.local_port = 6665;\r\nnt->np.remote_port = 6666;\r\neth_broadcast_addr(nt->np.remote_mac);\r\nconfig_item_init_type_name(&nt->item, name, &netconsole_target_type);\r\nspin_lock_irqsave(&target_list_lock, flags);\r\nlist_add(&nt->list, &target_list);\r\nspin_unlock_irqrestore(&target_list_lock, flags);\r\nreturn &nt->item;\r\n}\r\nstatic void drop_netconsole_target(struct config_group *group,\r\nstruct config_item *item)\r\n{\r\nunsigned long flags;\r\nstruct netconsole_target *nt = to_target(item);\r\nspin_lock_irqsave(&target_list_lock, flags);\r\nlist_del(&nt->list);\r\nspin_unlock_irqrestore(&target_list_lock, flags);\r\nif (nt->enabled)\r\nnetpoll_cleanup(&nt->np);\r\nconfig_item_put(&nt->item);\r\n}\r\nstatic int netconsole_netdev_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nunsigned long flags;\r\nstruct netconsole_target *nt;\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nbool stopped = false;\r\nif (!(event == NETDEV_CHANGENAME || event == NETDEV_UNREGISTER ||\r\nevent == NETDEV_RELEASE || event == NETDEV_JOIN))\r\ngoto done;\r\nspin_lock_irqsave(&target_list_lock, flags);\r\nrestart:\r\nlist_for_each_entry(nt, &target_list, list) {\r\nnetconsole_target_get(nt);\r\nif (nt->np.dev == dev) {\r\nswitch (event) {\r\ncase NETDEV_CHANGENAME:\r\nstrlcpy(nt->np.dev_name, dev->name, IFNAMSIZ);\r\nbreak;\r\ncase NETDEV_RELEASE:\r\ncase NETDEV_JOIN:\r\ncase NETDEV_UNREGISTER:\r\nspin_unlock_irqrestore(&target_list_lock, flags);\r\n__netpoll_cleanup(&nt->np);\r\nspin_lock_irqsave(&target_list_lock, flags);\r\ndev_put(nt->np.dev);\r\nnt->np.dev = NULL;\r\nnt->enabled = false;\r\nstopped = true;\r\nnetconsole_target_put(nt);\r\ngoto restart;\r\n}\r\n}\r\nnetconsole_target_put(nt);\r\n}\r\nspin_unlock_irqrestore(&target_list_lock, flags);\r\nif (stopped) {\r\nconst char *msg = "had an event";\r\nswitch (event) {\r\ncase NETDEV_UNREGISTER:\r\nmsg = "unregistered";\r\nbreak;\r\ncase NETDEV_RELEASE:\r\nmsg = "released slaves";\r\nbreak;\r\ncase NETDEV_JOIN:\r\nmsg = "is joining a master device";\r\nbreak;\r\n}\r\npr_info("network logging stopped on interface %s as it %s\n",\r\ndev->name, msg);\r\n}\r\ndone:\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void send_ext_msg_udp(struct netconsole_target *nt, const char *msg,\r\nint msg_len)\r\n{\r\nstatic char buf[MAX_PRINT_CHUNK];\r\nconst char *header, *body;\r\nint offset = 0;\r\nint header_len, body_len;\r\nif (msg_len <= MAX_PRINT_CHUNK) {\r\nnetpoll_send_udp(&nt->np, msg, msg_len);\r\nreturn;\r\n}\r\nheader = msg;\r\nbody = memchr(msg, ';', msg_len);\r\nif (WARN_ON_ONCE(!body))\r\nreturn;\r\nheader_len = body - header;\r\nbody_len = msg_len - header_len - 1;\r\nbody++;\r\nmemcpy(buf, header, header_len);\r\nwhile (offset < body_len) {\r\nint this_header = header_len;\r\nint this_chunk;\r\nthis_header += scnprintf(buf + this_header,\r\nsizeof(buf) - this_header,\r\n",ncfrag=%d/%d;", offset, body_len);\r\nthis_chunk = min(body_len - offset,\r\nMAX_PRINT_CHUNK - this_header);\r\nif (WARN_ON_ONCE(this_chunk <= 0))\r\nreturn;\r\nmemcpy(buf + this_header, body + offset, this_chunk);\r\nnetpoll_send_udp(&nt->np, buf, this_header + this_chunk);\r\noffset += this_chunk;\r\n}\r\n}\r\nstatic void write_ext_msg(struct console *con, const char *msg,\r\nunsigned int len)\r\n{\r\nstruct netconsole_target *nt;\r\nunsigned long flags;\r\nif ((oops_only && !oops_in_progress) || list_empty(&target_list))\r\nreturn;\r\nspin_lock_irqsave(&target_list_lock, flags);\r\nlist_for_each_entry(nt, &target_list, list)\r\nif (nt->extended && nt->enabled && netif_running(nt->np.dev))\r\nsend_ext_msg_udp(nt, msg, len);\r\nspin_unlock_irqrestore(&target_list_lock, flags);\r\n}\r\nstatic void write_msg(struct console *con, const char *msg, unsigned int len)\r\n{\r\nint frag, left;\r\nunsigned long flags;\r\nstruct netconsole_target *nt;\r\nconst char *tmp;\r\nif (oops_only && !oops_in_progress)\r\nreturn;\r\nif (list_empty(&target_list))\r\nreturn;\r\nspin_lock_irqsave(&target_list_lock, flags);\r\nlist_for_each_entry(nt, &target_list, list) {\r\nif (!nt->extended && nt->enabled && netif_running(nt->np.dev)) {\r\ntmp = msg;\r\nfor (left = len; left;) {\r\nfrag = min(left, MAX_PRINT_CHUNK);\r\nnetpoll_send_udp(&nt->np, tmp, frag);\r\ntmp += frag;\r\nleft -= frag;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&target_list_lock, flags);\r\n}\r\nstatic int __init init_netconsole(void)\r\n{\r\nint err;\r\nstruct netconsole_target *nt, *tmp;\r\nunsigned long flags;\r\nchar *target_config;\r\nchar *input = config;\r\nif (strnlen(input, MAX_PARAM_LENGTH)) {\r\nwhile ((target_config = strsep(&input, ";"))) {\r\nnt = alloc_param_target(target_config);\r\nif (IS_ERR(nt)) {\r\nerr = PTR_ERR(nt);\r\ngoto fail;\r\n}\r\nif (nt->extended)\r\nnetconsole_ext.flags |= CON_PRINTBUFFER |\r\nCON_ENABLED;\r\nelse\r\nnetconsole.flags |= CON_PRINTBUFFER;\r\nspin_lock_irqsave(&target_list_lock, flags);\r\nlist_add(&nt->list, &target_list);\r\nspin_unlock_irqrestore(&target_list_lock, flags);\r\n}\r\n}\r\nerr = register_netdevice_notifier(&netconsole_netdev_notifier);\r\nif (err)\r\ngoto fail;\r\nerr = dynamic_netconsole_init();\r\nif (err)\r\ngoto undonotifier;\r\nif (netconsole_ext.flags & CON_ENABLED)\r\nregister_console(&netconsole_ext);\r\nregister_console(&netconsole);\r\npr_info("network logging started\n");\r\nreturn err;\r\nundonotifier:\r\nunregister_netdevice_notifier(&netconsole_netdev_notifier);\r\nfail:\r\npr_err("cleaning up\n");\r\nlist_for_each_entry_safe(nt, tmp, &target_list, list) {\r\nlist_del(&nt->list);\r\nfree_param_target(nt);\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit cleanup_netconsole(void)\r\n{\r\nstruct netconsole_target *nt, *tmp;\r\nunregister_console(&netconsole_ext);\r\nunregister_console(&netconsole);\r\ndynamic_netconsole_exit();\r\nunregister_netdevice_notifier(&netconsole_netdev_notifier);\r\nlist_for_each_entry_safe(nt, tmp, &target_list, list) {\r\nlist_del(&nt->list);\r\nfree_param_target(nt);\r\n}\r\n}
