static int bnx2x_get_port_type(struct bnx2x *bp)\r\n{\r\nint port_type;\r\nu32 phy_idx = bnx2x_get_cur_phy_idx(bp);\r\nswitch (bp->link_params.phy[phy_idx].media_type) {\r\ncase ETH_PHY_SFPP_10G_FIBER:\r\ncase ETH_PHY_SFP_1G_FIBER:\r\ncase ETH_PHY_XFP_FIBER:\r\ncase ETH_PHY_KR:\r\ncase ETH_PHY_CX4:\r\nport_type = PORT_FIBRE;\r\nbreak;\r\ncase ETH_PHY_DA_TWINAX:\r\nport_type = PORT_DA;\r\nbreak;\r\ncase ETH_PHY_BASE_T:\r\nport_type = PORT_TP;\r\nbreak;\r\ncase ETH_PHY_NOT_PRESENT:\r\nport_type = PORT_NONE;\r\nbreak;\r\ncase ETH_PHY_UNSPECIFIED:\r\ndefault:\r\nport_type = PORT_OTHER;\r\nbreak;\r\n}\r\nreturn port_type;\r\n}\r\nstatic int bnx2x_get_vf_link_ksettings(struct net_device *dev,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nu32 supported, advertising;\r\nethtool_convert_link_mode_to_legacy_u32(&supported,\r\ncmd->link_modes.supported);\r\nethtool_convert_link_mode_to_legacy_u32(&advertising,\r\ncmd->link_modes.advertising);\r\nif (bp->state == BNX2X_STATE_OPEN) {\r\nif (test_bit(BNX2X_LINK_REPORT_FD,\r\n&bp->vf_link_vars.link_report_flags))\r\ncmd->base.duplex = DUPLEX_FULL;\r\nelse\r\ncmd->base.duplex = DUPLEX_HALF;\r\ncmd->base.speed = bp->vf_link_vars.line_speed;\r\n} else {\r\ncmd->base.duplex = DUPLEX_UNKNOWN;\r\ncmd->base.speed = SPEED_UNKNOWN;\r\n}\r\ncmd->base.port = PORT_OTHER;\r\ncmd->base.phy_address = 0;\r\ncmd->base.autoneg = AUTONEG_DISABLE;\r\nDP(BNX2X_MSG_ETHTOOL, "ethtool_cmd: cmd %d\n"\r\n" supported 0x%x advertising 0x%x speed %u\n"\r\n" duplex %d port %d phy_address %d\n"\r\n" autoneg %d\n",\r\ncmd->base.cmd, supported, advertising,\r\ncmd->base.speed,\r\ncmd->base.duplex, cmd->base.port, cmd->base.phy_address,\r\ncmd->base.autoneg);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_get_link_ksettings(struct net_device *dev,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nint cfg_idx = bnx2x_get_link_cfg_idx(bp);\r\nu32 media_type;\r\nu32 supported, advertising, lp_advertising;\r\nethtool_convert_link_mode_to_legacy_u32(&lp_advertising,\r\ncmd->link_modes.lp_advertising);\r\nsupported = bp->port.supported[cfg_idx] |\r\n(bp->port.supported[cfg_idx ^ 1] &\r\n(SUPPORTED_TP | SUPPORTED_FIBRE));\r\nadvertising = bp->port.advertising[cfg_idx];\r\nmedia_type = bp->link_params.phy[bnx2x_get_cur_phy_idx(bp)].media_type;\r\nif (media_type == ETH_PHY_SFP_1G_FIBER) {\r\nsupported &= ~(SUPPORTED_10000baseT_Full);\r\nadvertising &= ~(ADVERTISED_10000baseT_Full);\r\n}\r\nif ((bp->state == BNX2X_STATE_OPEN) && bp->link_vars.link_up &&\r\n!(bp->flags & MF_FUNC_DIS)) {\r\ncmd->base.duplex = bp->link_vars.duplex;\r\nif (IS_MF(bp) && !BP_NOMCP(bp))\r\ncmd->base.speed = bnx2x_get_mf_speed(bp);\r\nelse\r\ncmd->base.speed = bp->link_vars.line_speed;\r\n} else {\r\ncmd->base.duplex = DUPLEX_UNKNOWN;\r\ncmd->base.speed = SPEED_UNKNOWN;\r\n}\r\ncmd->base.port = bnx2x_get_port_type(bp);\r\ncmd->base.phy_address = bp->mdio.prtad;\r\nif (bp->link_params.req_line_speed[cfg_idx] == SPEED_AUTO_NEG)\r\ncmd->base.autoneg = AUTONEG_ENABLE;\r\nelse\r\ncmd->base.autoneg = AUTONEG_DISABLE;\r\nif (bp->link_vars.link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) {\r\nu32 status = bp->link_vars.link_status;\r\nlp_advertising |= ADVERTISED_Autoneg;\r\nif (status & LINK_STATUS_LINK_PARTNER_SYMMETRIC_PAUSE)\r\nlp_advertising |= ADVERTISED_Pause;\r\nif (status & LINK_STATUS_LINK_PARTNER_ASYMMETRIC_PAUSE)\r\nlp_advertising |= ADVERTISED_Asym_Pause;\r\nif (status & LINK_STATUS_LINK_PARTNER_10THD_CAPABLE)\r\nlp_advertising |= ADVERTISED_10baseT_Half;\r\nif (status & LINK_STATUS_LINK_PARTNER_10TFD_CAPABLE)\r\nlp_advertising |= ADVERTISED_10baseT_Full;\r\nif (status & LINK_STATUS_LINK_PARTNER_100TXHD_CAPABLE)\r\nlp_advertising |= ADVERTISED_100baseT_Half;\r\nif (status & LINK_STATUS_LINK_PARTNER_100TXFD_CAPABLE)\r\nlp_advertising |= ADVERTISED_100baseT_Full;\r\nif (status & LINK_STATUS_LINK_PARTNER_1000THD_CAPABLE)\r\nlp_advertising |= ADVERTISED_1000baseT_Half;\r\nif (status & LINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE) {\r\nif (media_type == ETH_PHY_KR) {\r\nlp_advertising |=\r\nADVERTISED_1000baseKX_Full;\r\n} else {\r\nlp_advertising |=\r\nADVERTISED_1000baseT_Full;\r\n}\r\n}\r\nif (status & LINK_STATUS_LINK_PARTNER_2500XFD_CAPABLE)\r\nlp_advertising |= ADVERTISED_2500baseX_Full;\r\nif (status & LINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE) {\r\nif (media_type == ETH_PHY_KR) {\r\nlp_advertising |=\r\nADVERTISED_10000baseKR_Full;\r\n} else {\r\nlp_advertising |=\r\nADVERTISED_10000baseT_Full;\r\n}\r\n}\r\nif (status & LINK_STATUS_LINK_PARTNER_20GXFD_CAPABLE)\r\nlp_advertising |= ADVERTISED_20000baseKR2_Full;\r\n}\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\r\nsupported);\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\r\nadvertising);\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.lp_advertising,\r\nlp_advertising);\r\nDP(BNX2X_MSG_ETHTOOL, "ethtool_cmd: cmd %d\n"\r\n" supported 0x%x advertising 0x%x speed %u\n"\r\n" duplex %d port %d phy_address %d\n"\r\n" autoneg %d\n",\r\ncmd->base.cmd, supported, advertising,\r\ncmd->base.speed,\r\ncmd->base.duplex, cmd->base.port, cmd->base.phy_address,\r\ncmd->base.autoneg);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_set_link_ksettings(struct net_device *dev,\r\nconst struct ethtool_link_ksettings *cmd)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nu32 advertising, cfg_idx, old_multi_phy_config, new_multi_phy_config;\r\nu32 speed, phy_idx;\r\nu32 supported;\r\nu8 duplex = cmd->base.duplex;\r\nethtool_convert_link_mode_to_legacy_u32(&supported,\r\ncmd->link_modes.supported);\r\nethtool_convert_link_mode_to_legacy_u32(&advertising,\r\ncmd->link_modes.advertising);\r\nif (IS_MF_SD(bp))\r\nreturn 0;\r\nDP(BNX2X_MSG_ETHTOOL, "ethtool_cmd: cmd %d\n"\r\n" supported 0x%x advertising 0x%x speed %u\n"\r\n" duplex %d port %d phy_address %d\n"\r\n" autoneg %d\n",\r\ncmd->base.cmd, supported, advertising,\r\ncmd->base.speed,\r\ncmd->base.duplex, cmd->base.port, cmd->base.phy_address,\r\ncmd->base.autoneg);\r\nspeed = cmd->base.speed;\r\nif (duplex == DUPLEX_UNKNOWN)\r\nduplex = DUPLEX_FULL;\r\nif (IS_MF_SI(bp)) {\r\nu32 part;\r\nu32 line_speed = bp->link_vars.line_speed;\r\nif (!line_speed)\r\nline_speed = 10000;\r\nif (bp->common.bc_ver < REQ_BC_VER_4_SET_MF_BW) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"To set speed BC %X or higher is required, please upgrade BC\n",\r\nREQ_BC_VER_4_SET_MF_BW);\r\nreturn -EINVAL;\r\n}\r\npart = (speed * 100) / line_speed;\r\nif (line_speed < speed || !part) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Speed setting should be in a range from 1%% to 100%% of actual line speed\n");\r\nreturn -EINVAL;\r\n}\r\nif (bp->state != BNX2X_STATE_OPEN)\r\nbp->pending_max = part;\r\nelse\r\nbnx2x_update_max_mf_config(bp, part);\r\nreturn 0;\r\n}\r\ncfg_idx = bnx2x_get_link_cfg_idx(bp);\r\nold_multi_phy_config = bp->link_params.multi_phy_config;\r\nif (cmd->base.port != bnx2x_get_port_type(bp)) {\r\nswitch (cmd->base.port) {\r\ncase PORT_TP:\r\nif (!(bp->port.supported[0] & SUPPORTED_TP ||\r\nbp->port.supported[1] & SUPPORTED_TP)) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Unsupported port type\n");\r\nreturn -EINVAL;\r\n}\r\nbp->link_params.multi_phy_config &=\r\n~PORT_HW_CFG_PHY_SELECTION_MASK;\r\nif (bp->link_params.multi_phy_config &\r\nPORT_HW_CFG_PHY_SWAPPED_ENABLED)\r\nbp->link_params.multi_phy_config |=\r\nPORT_HW_CFG_PHY_SELECTION_SECOND_PHY;\r\nelse\r\nbp->link_params.multi_phy_config |=\r\nPORT_HW_CFG_PHY_SELECTION_FIRST_PHY;\r\nbreak;\r\ncase PORT_FIBRE:\r\ncase PORT_DA:\r\ncase PORT_NONE:\r\nif (!(bp->port.supported[0] & SUPPORTED_FIBRE ||\r\nbp->port.supported[1] & SUPPORTED_FIBRE)) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Unsupported port type\n");\r\nreturn -EINVAL;\r\n}\r\nbp->link_params.multi_phy_config &=\r\n~PORT_HW_CFG_PHY_SELECTION_MASK;\r\nif (bp->link_params.multi_phy_config &\r\nPORT_HW_CFG_PHY_SWAPPED_ENABLED)\r\nbp->link_params.multi_phy_config |=\r\nPORT_HW_CFG_PHY_SELECTION_FIRST_PHY;\r\nelse\r\nbp->link_params.multi_phy_config |=\r\nPORT_HW_CFG_PHY_SELECTION_SECOND_PHY;\r\nbreak;\r\ndefault:\r\nDP(BNX2X_MSG_ETHTOOL, "Unsupported port type\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nnew_multi_phy_config = bp->link_params.multi_phy_config;\r\ncfg_idx = bnx2x_get_link_cfg_idx(bp);\r\nbp->link_params.multi_phy_config = old_multi_phy_config;\r\nDP(BNX2X_MSG_ETHTOOL, "cfg_idx = %x\n", cfg_idx);\r\nif (cmd->base.autoneg == AUTONEG_ENABLE) {\r\nu32 an_supported_speed = bp->port.supported[cfg_idx];\r\nif (bp->link_params.phy[EXT_PHY1].type ==\r\nPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833)\r\nan_supported_speed |= (SUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full);\r\nif (!(bp->port.supported[cfg_idx] & SUPPORTED_Autoneg)) {\r\nDP(BNX2X_MSG_ETHTOOL, "Autoneg not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (advertising & ~an_supported_speed) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Advertisement parameters are not supported\n");\r\nreturn -EINVAL;\r\n}\r\nbp->link_params.req_line_speed[cfg_idx] = SPEED_AUTO_NEG;\r\nbp->link_params.req_duplex[cfg_idx] = duplex;\r\nbp->port.advertising[cfg_idx] = (ADVERTISED_Autoneg |\r\nadvertising);\r\nif (advertising) {\r\nbp->link_params.speed_cap_mask[cfg_idx] = 0;\r\nif (advertising & ADVERTISED_10baseT_Half) {\r\nbp->link_params.speed_cap_mask[cfg_idx] |=\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF;\r\n}\r\nif (advertising & ADVERTISED_10baseT_Full)\r\nbp->link_params.speed_cap_mask[cfg_idx] |=\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL;\r\nif (advertising & ADVERTISED_100baseT_Full)\r\nbp->link_params.speed_cap_mask[cfg_idx] |=\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL;\r\nif (advertising & ADVERTISED_100baseT_Half) {\r\nbp->link_params.speed_cap_mask[cfg_idx] |=\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF;\r\n}\r\nif (advertising & ADVERTISED_1000baseT_Half) {\r\nbp->link_params.speed_cap_mask[cfg_idx] |=\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_1G;\r\n}\r\nif (advertising & (ADVERTISED_1000baseT_Full |\r\nADVERTISED_1000baseKX_Full))\r\nbp->link_params.speed_cap_mask[cfg_idx] |=\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_1G;\r\nif (advertising & (ADVERTISED_10000baseT_Full |\r\nADVERTISED_10000baseKX4_Full |\r\nADVERTISED_10000baseKR_Full))\r\nbp->link_params.speed_cap_mask[cfg_idx] |=\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10G;\r\nif (advertising & ADVERTISED_20000baseKR2_Full)\r\nbp->link_params.speed_cap_mask[cfg_idx] |=\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_20G;\r\n}\r\n} else {\r\nswitch (speed) {\r\ncase SPEED_10:\r\nif (duplex == DUPLEX_FULL) {\r\nif (!(bp->port.supported[cfg_idx] &\r\nSUPPORTED_10baseT_Full)) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"10M full not supported\n");\r\nreturn -EINVAL;\r\n}\r\nadvertising = (ADVERTISED_10baseT_Full |\r\nADVERTISED_TP);\r\n} else {\r\nif (!(bp->port.supported[cfg_idx] &\r\nSUPPORTED_10baseT_Half)) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"10M half not supported\n");\r\nreturn -EINVAL;\r\n}\r\nadvertising = (ADVERTISED_10baseT_Half |\r\nADVERTISED_TP);\r\n}\r\nbreak;\r\ncase SPEED_100:\r\nif (duplex == DUPLEX_FULL) {\r\nif (!(bp->port.supported[cfg_idx] &\r\nSUPPORTED_100baseT_Full)) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"100M full not supported\n");\r\nreturn -EINVAL;\r\n}\r\nadvertising = (ADVERTISED_100baseT_Full |\r\nADVERTISED_TP);\r\n} else {\r\nif (!(bp->port.supported[cfg_idx] &\r\nSUPPORTED_100baseT_Half)) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"100M half not supported\n");\r\nreturn -EINVAL;\r\n}\r\nadvertising = (ADVERTISED_100baseT_Half |\r\nADVERTISED_TP);\r\n}\r\nbreak;\r\ncase SPEED_1000:\r\nif (duplex != DUPLEX_FULL) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"1G half not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (bp->port.supported[cfg_idx] &\r\nSUPPORTED_1000baseT_Full) {\r\nadvertising = (ADVERTISED_1000baseT_Full |\r\nADVERTISED_TP);\r\n} else if (bp->port.supported[cfg_idx] &\r\nSUPPORTED_1000baseKX_Full) {\r\nadvertising = ADVERTISED_1000baseKX_Full;\r\n} else {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"1G full not supported\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SPEED_2500:\r\nif (duplex != DUPLEX_FULL) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"2.5G half not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(bp->port.supported[cfg_idx]\r\n& SUPPORTED_2500baseX_Full)) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"2.5G full not supported\n");\r\nreturn -EINVAL;\r\n}\r\nadvertising = (ADVERTISED_2500baseX_Full |\r\nADVERTISED_TP);\r\nbreak;\r\ncase SPEED_10000:\r\nif (duplex != DUPLEX_FULL) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"10G half not supported\n");\r\nreturn -EINVAL;\r\n}\r\nphy_idx = bnx2x_get_cur_phy_idx(bp);\r\nif ((bp->port.supported[cfg_idx] &\r\nSUPPORTED_10000baseT_Full) &&\r\n(bp->link_params.phy[phy_idx].media_type !=\r\nETH_PHY_SFP_1G_FIBER)) {\r\nadvertising = (ADVERTISED_10000baseT_Full |\r\nADVERTISED_FIBRE);\r\n} else if (bp->port.supported[cfg_idx] &\r\nSUPPORTED_10000baseKR_Full) {\r\nadvertising = (ADVERTISED_10000baseKR_Full |\r\nADVERTISED_FIBRE);\r\n} else {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"10G full not supported\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nDP(BNX2X_MSG_ETHTOOL, "Unsupported speed %u\n", speed);\r\nreturn -EINVAL;\r\n}\r\nbp->link_params.req_line_speed[cfg_idx] = speed;\r\nbp->link_params.req_duplex[cfg_idx] = duplex;\r\nbp->port.advertising[cfg_idx] = advertising;\r\n}\r\nDP(BNX2X_MSG_ETHTOOL, "req_line_speed %d\n"\r\n" req_duplex %d advertising 0x%x\n",\r\nbp->link_params.req_line_speed[cfg_idx],\r\nbp->link_params.req_duplex[cfg_idx],\r\nbp->port.advertising[cfg_idx]);\r\nbp->link_params.multi_phy_config = new_multi_phy_config;\r\nif (netif_running(dev)) {\r\nbnx2x_stats_handle(bp, STATS_EVENT_STOP);\r\nbnx2x_force_link_reset(bp);\r\nbnx2x_link_set(bp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __bnx2x_get_preset_regs_len(struct bnx2x *bp, u32 preset)\r\n{\r\nif (CHIP_IS_E1(bp))\r\nreturn dump_num_registers[0][preset-1];\r\nelse if (CHIP_IS_E1H(bp))\r\nreturn dump_num_registers[1][preset-1];\r\nelse if (CHIP_IS_E2(bp))\r\nreturn dump_num_registers[2][preset-1];\r\nelse if (CHIP_IS_E3A0(bp))\r\nreturn dump_num_registers[3][preset-1];\r\nelse if (CHIP_IS_E3B0(bp))\r\nreturn dump_num_registers[4][preset-1];\r\nelse\r\nreturn 0;\r\n}\r\nstatic int __bnx2x_get_regs_len(struct bnx2x *bp)\r\n{\r\nu32 preset_idx;\r\nint regdump_len = 0;\r\nfor (preset_idx = 1; preset_idx <= DUMP_MAX_PRESETS; preset_idx++)\r\nregdump_len += __bnx2x_get_preset_regs_len(bp, preset_idx);\r\nreturn regdump_len;\r\n}\r\nstatic int bnx2x_get_regs_len(struct net_device *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nint regdump_len = 0;\r\nif (IS_VF(bp))\r\nreturn 0;\r\nregdump_len = __bnx2x_get_regs_len(bp);\r\nregdump_len *= 4;\r\nregdump_len += sizeof(struct dump_header);\r\nreturn regdump_len;\r\n}\r\nstatic const u32 *__bnx2x_get_page_addr_ar(struct bnx2x *bp)\r\n{\r\nif (CHIP_IS_E2(bp))\r\nreturn page_vals_e2;\r\nelse if (CHIP_IS_E3(bp))\r\nreturn page_vals_e3;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic u32 __bnx2x_get_page_reg_num(struct bnx2x *bp)\r\n{\r\nif (CHIP_IS_E2(bp))\r\nreturn PAGE_MODE_VALUES_E2;\r\nelse if (CHIP_IS_E3(bp))\r\nreturn PAGE_MODE_VALUES_E3;\r\nelse\r\nreturn 0;\r\n}\r\nstatic const u32 *__bnx2x_get_page_write_ar(struct bnx2x *bp)\r\n{\r\nif (CHIP_IS_E2(bp))\r\nreturn page_write_regs_e2;\r\nelse if (CHIP_IS_E3(bp))\r\nreturn page_write_regs_e3;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic u32 __bnx2x_get_page_write_num(struct bnx2x *bp)\r\n{\r\nif (CHIP_IS_E2(bp))\r\nreturn PAGE_WRITE_REGS_E2;\r\nelse if (CHIP_IS_E3(bp))\r\nreturn PAGE_WRITE_REGS_E3;\r\nelse\r\nreturn 0;\r\n}\r\nstatic const struct reg_addr *__bnx2x_get_page_read_ar(struct bnx2x *bp)\r\n{\r\nif (CHIP_IS_E2(bp))\r\nreturn page_read_regs_e2;\r\nelse if (CHIP_IS_E3(bp))\r\nreturn page_read_regs_e3;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic u32 __bnx2x_get_page_read_num(struct bnx2x *bp)\r\n{\r\nif (CHIP_IS_E2(bp))\r\nreturn PAGE_READ_REGS_E2;\r\nelse if (CHIP_IS_E3(bp))\r\nreturn PAGE_READ_REGS_E3;\r\nelse\r\nreturn 0;\r\n}\r\nstatic bool bnx2x_is_reg_in_chip(struct bnx2x *bp,\r\nconst struct reg_addr *reg_info)\r\n{\r\nif (CHIP_IS_E1(bp))\r\nreturn IS_E1_REG(reg_info->chips);\r\nelse if (CHIP_IS_E1H(bp))\r\nreturn IS_E1H_REG(reg_info->chips);\r\nelse if (CHIP_IS_E2(bp))\r\nreturn IS_E2_REG(reg_info->chips);\r\nelse if (CHIP_IS_E3A0(bp))\r\nreturn IS_E3A0_REG(reg_info->chips);\r\nelse if (CHIP_IS_E3B0(bp))\r\nreturn IS_E3B0_REG(reg_info->chips);\r\nelse\r\nreturn false;\r\n}\r\nstatic bool bnx2x_is_wreg_in_chip(struct bnx2x *bp,\r\nconst struct wreg_addr *wreg_info)\r\n{\r\nif (CHIP_IS_E1(bp))\r\nreturn IS_E1_REG(wreg_info->chips);\r\nelse if (CHIP_IS_E1H(bp))\r\nreturn IS_E1H_REG(wreg_info->chips);\r\nelse if (CHIP_IS_E2(bp))\r\nreturn IS_E2_REG(wreg_info->chips);\r\nelse if (CHIP_IS_E3A0(bp))\r\nreturn IS_E3A0_REG(wreg_info->chips);\r\nelse if (CHIP_IS_E3B0(bp))\r\nreturn IS_E3B0_REG(wreg_info->chips);\r\nelse\r\nreturn false;\r\n}\r\nstatic void bnx2x_read_pages_regs(struct bnx2x *bp, u32 *p, u32 preset)\r\n{\r\nu32 i, j, k, n;\r\nconst u32 *page_addr = __bnx2x_get_page_addr_ar(bp);\r\nint num_pages = __bnx2x_get_page_reg_num(bp);\r\nconst u32 *write_addr = __bnx2x_get_page_write_ar(bp);\r\nint write_num = __bnx2x_get_page_write_num(bp);\r\nconst struct reg_addr *read_addr = __bnx2x_get_page_read_ar(bp);\r\nint read_num = __bnx2x_get_page_read_num(bp);\r\nu32 addr, size;\r\nfor (i = 0; i < num_pages; i++) {\r\nfor (j = 0; j < write_num; j++) {\r\nREG_WR(bp, write_addr[j], page_addr[i]);\r\nfor (k = 0; k < read_num; k++) {\r\nif (IS_REG_IN_PRESET(read_addr[k].presets,\r\npreset)) {\r\nsize = read_addr[k].size;\r\nfor (n = 0; n < size; n++) {\r\naddr = read_addr[k].addr + n*4;\r\n*p++ = REG_RD(bp, addr);\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic int __bnx2x_get_preset_regs(struct bnx2x *bp, u32 *p, u32 preset)\r\n{\r\nu32 i, j, addr;\r\nconst struct wreg_addr *wreg_addr_p = NULL;\r\nif (CHIP_IS_E1(bp))\r\nwreg_addr_p = &wreg_addr_e1;\r\nelse if (CHIP_IS_E1H(bp))\r\nwreg_addr_p = &wreg_addr_e1h;\r\nelse if (CHIP_IS_E2(bp))\r\nwreg_addr_p = &wreg_addr_e2;\r\nelse if (CHIP_IS_E3A0(bp))\r\nwreg_addr_p = &wreg_addr_e3;\r\nelse if (CHIP_IS_E3B0(bp))\r\nwreg_addr_p = &wreg_addr_e3b0;\r\nfor (i = 0; i < IDLE_REGS_COUNT; i++) {\r\nif (bnx2x_is_reg_in_chip(bp, &idle_reg_addrs[i]) &&\r\nIS_REG_IN_PRESET(idle_reg_addrs[i].presets, preset)) {\r\nfor (j = 0; j < idle_reg_addrs[i].size; j++)\r\n*p++ = REG_RD(bp, idle_reg_addrs[i].addr + j*4);\r\n}\r\n}\r\nfor (i = 0; i < REGS_COUNT; i++) {\r\nif (bnx2x_is_reg_in_chip(bp, &reg_addrs[i]) &&\r\nIS_REG_IN_PRESET(reg_addrs[i].presets, preset)) {\r\nfor (j = 0; j < reg_addrs[i].size; j++)\r\n*p++ = REG_RD(bp, reg_addrs[i].addr + j*4);\r\n}\r\n}\r\nif (bnx2x_is_wreg_in_chip(bp, wreg_addr_p) &&\r\nIS_REG_IN_PRESET(wreg_addr_p->presets, preset)) {\r\nfor (i = 0; i < wreg_addr_p->size; i++) {\r\n*p++ = REG_RD(bp, wreg_addr_p->addr + i*4);\r\nfor (j = 0; j < wreg_addr_p->read_regs_count; j++) {\r\naddr = *(wreg_addr_p->read_regs);\r\n*p++ = REG_RD(bp, addr + j*4);\r\n}\r\n}\r\n}\r\nif (CHIP_IS_E2(bp) || CHIP_IS_E3(bp)) {\r\nbnx2x_read_pages_regs(bp, p, preset);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __bnx2x_get_regs(struct bnx2x *bp, u32 *p)\r\n{\r\nu32 preset_idx;\r\nfor (preset_idx = 1; preset_idx <= DUMP_MAX_PRESETS; preset_idx++) {\r\nif ((preset_idx == 2) ||\r\n(preset_idx == 5) ||\r\n(preset_idx == 8) ||\r\n(preset_idx == 11))\r\ncontinue;\r\n__bnx2x_get_preset_regs(bp, p, preset_idx);\r\np += __bnx2x_get_preset_regs_len(bp, preset_idx);\r\n}\r\n}\r\nstatic void bnx2x_get_regs(struct net_device *dev,\r\nstruct ethtool_regs *regs, void *_p)\r\n{\r\nu32 *p = _p;\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nstruct dump_header dump_hdr = {0};\r\nregs->version = 2;\r\nmemset(p, 0, regs->len);\r\nif (!netif_running(bp->dev))\r\nreturn;\r\nbnx2x_disable_blocks_parity(bp);\r\ndump_hdr.header_size = (sizeof(struct dump_header) / 4) - 1;\r\ndump_hdr.preset = DUMP_ALL_PRESETS;\r\ndump_hdr.version = BNX2X_DUMP_VERSION;\r\nif (CHIP_IS_E1(bp)) {\r\ndump_hdr.dump_meta_data = DUMP_CHIP_E1;\r\n} else if (CHIP_IS_E1H(bp)) {\r\ndump_hdr.dump_meta_data = DUMP_CHIP_E1H;\r\n} else if (CHIP_IS_E2(bp)) {\r\ndump_hdr.dump_meta_data = DUMP_CHIP_E2 |\r\n(BP_PATH(bp) ? DUMP_PATH_1 : DUMP_PATH_0);\r\n} else if (CHIP_IS_E3A0(bp)) {\r\ndump_hdr.dump_meta_data = DUMP_CHIP_E3A0 |\r\n(BP_PATH(bp) ? DUMP_PATH_1 : DUMP_PATH_0);\r\n} else if (CHIP_IS_E3B0(bp)) {\r\ndump_hdr.dump_meta_data = DUMP_CHIP_E3B0 |\r\n(BP_PATH(bp) ? DUMP_PATH_1 : DUMP_PATH_0);\r\n}\r\nmemcpy(p, &dump_hdr, sizeof(struct dump_header));\r\np += dump_hdr.header_size + 1;\r\nBNX2X_ERR("Generating register dump. Might trigger harmless GRC timeouts\n");\r\n__bnx2x_get_regs(bp, p);\r\nbnx2x_clear_blocks_parity(bp);\r\nbnx2x_enable_blocks_parity(bp);\r\n}\r\nstatic int bnx2x_get_preset_regs_len(struct net_device *dev, u32 preset)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nint regdump_len = 0;\r\nregdump_len = __bnx2x_get_preset_regs_len(bp, preset);\r\nregdump_len *= 4;\r\nregdump_len += sizeof(struct dump_header);\r\nreturn regdump_len;\r\n}\r\nstatic int bnx2x_set_dump(struct net_device *dev, struct ethtool_dump *val)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nif (val->flag < 1 || val->flag > DUMP_MAX_PRESETS)\r\nreturn -EINVAL;\r\nbp->dump_preset_idx = val->flag;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_get_dump_flag(struct net_device *dev,\r\nstruct ethtool_dump *dump)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\ndump->version = BNX2X_DUMP_VERSION;\r\ndump->flag = bp->dump_preset_idx;\r\ndump->len = bnx2x_get_preset_regs_len(dev, bp->dump_preset_idx);\r\nDP(BNX2X_MSG_ETHTOOL, "Get dump preset %d length=%d\n",\r\nbp->dump_preset_idx, dump->len);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_get_dump_data(struct net_device *dev,\r\nstruct ethtool_dump *dump,\r\nvoid *buffer)\r\n{\r\nu32 *p = buffer;\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nstruct dump_header dump_hdr = {0};\r\nbnx2x_disable_blocks_parity(bp);\r\ndump_hdr.header_size = (sizeof(struct dump_header) / 4) - 1;\r\ndump_hdr.preset = bp->dump_preset_idx;\r\ndump_hdr.version = BNX2X_DUMP_VERSION;\r\nDP(BNX2X_MSG_ETHTOOL, "Get dump data of preset %d\n", dump_hdr.preset);\r\nif (CHIP_IS_E1(bp)) {\r\ndump_hdr.dump_meta_data = DUMP_CHIP_E1;\r\n} else if (CHIP_IS_E1H(bp)) {\r\ndump_hdr.dump_meta_data = DUMP_CHIP_E1H;\r\n} else if (CHIP_IS_E2(bp)) {\r\ndump_hdr.dump_meta_data = DUMP_CHIP_E2 |\r\n(BP_PATH(bp) ? DUMP_PATH_1 : DUMP_PATH_0);\r\n} else if (CHIP_IS_E3A0(bp)) {\r\ndump_hdr.dump_meta_data = DUMP_CHIP_E3A0 |\r\n(BP_PATH(bp) ? DUMP_PATH_1 : DUMP_PATH_0);\r\n} else if (CHIP_IS_E3B0(bp)) {\r\ndump_hdr.dump_meta_data = DUMP_CHIP_E3B0 |\r\n(BP_PATH(bp) ? DUMP_PATH_1 : DUMP_PATH_0);\r\n}\r\nmemcpy(p, &dump_hdr, sizeof(struct dump_header));\r\np += dump_hdr.header_size + 1;\r\n__bnx2x_get_preset_regs(bp, p, dump_hdr.preset);\r\nbnx2x_clear_blocks_parity(bp);\r\nbnx2x_enable_blocks_parity(bp);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\r\nbnx2x_fill_fw_str(bp, info->fw_version, sizeof(info->fw_version));\r\nstrlcpy(info->bus_info, pci_name(bp->pdev), sizeof(info->bus_info));\r\n}\r\nstatic void bnx2x_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nif (bp->flags & NO_WOL_FLAG) {\r\nwol->supported = 0;\r\nwol->wolopts = 0;\r\n} else {\r\nwol->supported = WAKE_MAGIC;\r\nif (bp->wol)\r\nwol->wolopts = WAKE_MAGIC;\r\nelse\r\nwol->wolopts = 0;\r\n}\r\nmemset(&wol->sopass, 0, sizeof(wol->sopass));\r\n}\r\nstatic int bnx2x_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nif (wol->wolopts & ~WAKE_MAGIC) {\r\nDP(BNX2X_MSG_ETHTOOL, "WOL not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (wol->wolopts & WAKE_MAGIC) {\r\nif (bp->flags & NO_WOL_FLAG) {\r\nDP(BNX2X_MSG_ETHTOOL, "WOL not supported\n");\r\nreturn -EINVAL;\r\n}\r\nbp->wol = 1;\r\n} else\r\nbp->wol = 0;\r\nif (SHMEM2_HAS(bp, curr_cfg))\r\nSHMEM2_WR(bp, curr_cfg, CURR_CFG_MET_OS);\r\nreturn 0;\r\n}\r\nstatic u32 bnx2x_get_msglevel(struct net_device *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nreturn bp->msg_enable;\r\n}\r\nstatic void bnx2x_set_msglevel(struct net_device *dev, u32 level)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nif (capable(CAP_NET_ADMIN)) {\r\nif (IS_PF(bp) && (level & BNX2X_MSG_MCP))\r\nbnx2x_fw_dump_lvl(bp, KERN_INFO);\r\nbp->msg_enable = level;\r\n}\r\n}\r\nstatic int bnx2x_nway_reset(struct net_device *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nif (!bp->port.pmf)\r\nreturn 0;\r\nif (netif_running(dev)) {\r\nbnx2x_stats_handle(bp, STATS_EVENT_STOP);\r\nbnx2x_force_link_reset(bp);\r\nbnx2x_link_set(bp);\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 bnx2x_get_link(struct net_device *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nif (bp->flags & MF_FUNC_DIS || (bp->state != BNX2X_STATE_OPEN))\r\nreturn 0;\r\nif (IS_VF(bp))\r\nreturn !test_bit(BNX2X_LINK_REPORT_LINK_DOWN,\r\n&bp->vf_link_vars.link_report_flags);\r\nreturn bp->link_vars.link_up;\r\n}\r\nstatic int bnx2x_get_eeprom_len(struct net_device *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nreturn bp->common.flash_size;\r\n}\r\nstatic int bnx2x_acquire_nvram_lock(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nint count, i;\r\nu32 val;\r\nbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_NVRAM);\r\ncount = BNX2X_NVRAM_TIMEOUT_COUNT;\r\nif (CHIP_REV_IS_SLOW(bp))\r\ncount *= 100;\r\nREG_WR(bp, MCP_REG_MCPR_NVM_SW_ARB,\r\n(MCPR_NVM_SW_ARB_ARB_REQ_SET1 << port));\r\nfor (i = 0; i < count*10; i++) {\r\nval = REG_RD(bp, MCP_REG_MCPR_NVM_SW_ARB);\r\nif (val & (MCPR_NVM_SW_ARB_ARB_ARB1 << port))\r\nbreak;\r\nudelay(5);\r\n}\r\nif (!(val & (MCPR_NVM_SW_ARB_ARB_ARB1 << port))) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"cannot get access to nvram interface\n");\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_NVRAM);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_release_nvram_lock(struct bnx2x *bp)\r\n{\r\nint port = BP_PORT(bp);\r\nint count, i;\r\nu32 val;\r\ncount = BNX2X_NVRAM_TIMEOUT_COUNT;\r\nif (CHIP_REV_IS_SLOW(bp))\r\ncount *= 100;\r\nREG_WR(bp, MCP_REG_MCPR_NVM_SW_ARB,\r\n(MCPR_NVM_SW_ARB_ARB_REQ_CLR1 << port));\r\nfor (i = 0; i < count*10; i++) {\r\nval = REG_RD(bp, MCP_REG_MCPR_NVM_SW_ARB);\r\nif (!(val & (MCPR_NVM_SW_ARB_ARB_ARB1 << port)))\r\nbreak;\r\nudelay(5);\r\n}\r\nif (val & (MCPR_NVM_SW_ARB_ARB_ARB1 << port)) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"cannot free access to nvram interface\n");\r\nreturn -EBUSY;\r\n}\r\nbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_NVRAM);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_enable_nvram_access(struct bnx2x *bp)\r\n{\r\nu32 val;\r\nval = REG_RD(bp, MCP_REG_MCPR_NVM_ACCESS_ENABLE);\r\nREG_WR(bp, MCP_REG_MCPR_NVM_ACCESS_ENABLE,\r\n(val | MCPR_NVM_ACCESS_ENABLE_EN |\r\nMCPR_NVM_ACCESS_ENABLE_WR_EN));\r\n}\r\nstatic void bnx2x_disable_nvram_access(struct bnx2x *bp)\r\n{\r\nu32 val;\r\nval = REG_RD(bp, MCP_REG_MCPR_NVM_ACCESS_ENABLE);\r\nREG_WR(bp, MCP_REG_MCPR_NVM_ACCESS_ENABLE,\r\n(val & ~(MCPR_NVM_ACCESS_ENABLE_EN |\r\nMCPR_NVM_ACCESS_ENABLE_WR_EN)));\r\n}\r\nstatic int bnx2x_nvram_read_dword(struct bnx2x *bp, u32 offset, __be32 *ret_val,\r\nu32 cmd_flags)\r\n{\r\nint count, i, rc;\r\nu32 val;\r\ncmd_flags |= MCPR_NVM_COMMAND_DOIT;\r\nREG_WR(bp, MCP_REG_MCPR_NVM_COMMAND, MCPR_NVM_COMMAND_DONE);\r\nREG_WR(bp, MCP_REG_MCPR_NVM_ADDR,\r\n(offset & MCPR_NVM_ADDR_NVM_ADDR_VALUE));\r\nREG_WR(bp, MCP_REG_MCPR_NVM_COMMAND, cmd_flags);\r\ncount = BNX2X_NVRAM_TIMEOUT_COUNT;\r\nif (CHIP_REV_IS_SLOW(bp))\r\ncount *= 100;\r\n*ret_val = 0;\r\nrc = -EBUSY;\r\nfor (i = 0; i < count; i++) {\r\nudelay(5);\r\nval = REG_RD(bp, MCP_REG_MCPR_NVM_COMMAND);\r\nif (val & MCPR_NVM_COMMAND_DONE) {\r\nval = REG_RD(bp, MCP_REG_MCPR_NVM_READ);\r\n*ret_val = cpu_to_be32(val);\r\nrc = 0;\r\nbreak;\r\n}\r\n}\r\nif (rc == -EBUSY)\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"nvram read timeout expired\n");\r\nreturn rc;\r\n}\r\nint bnx2x_nvram_read(struct bnx2x *bp, u32 offset, u8 *ret_buf,\r\nint buf_size)\r\n{\r\nint rc;\r\nu32 cmd_flags;\r\n__be32 val;\r\nif ((offset & 0x03) || (buf_size & 0x03) || (buf_size == 0)) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"Invalid parameter: offset 0x%x buf_size 0x%x\n",\r\noffset, buf_size);\r\nreturn -EINVAL;\r\n}\r\nif (offset + buf_size > bp->common.flash_size) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"Invalid parameter: offset (0x%x) + buf_size (0x%x) > flash_size (0x%x)\n",\r\noffset, buf_size, bp->common.flash_size);\r\nreturn -EINVAL;\r\n}\r\nrc = bnx2x_acquire_nvram_lock(bp);\r\nif (rc)\r\nreturn rc;\r\nbnx2x_enable_nvram_access(bp);\r\ncmd_flags = MCPR_NVM_COMMAND_FIRST;\r\nwhile ((buf_size > sizeof(u32)) && (rc == 0)) {\r\nrc = bnx2x_nvram_read_dword(bp, offset, &val, cmd_flags);\r\nmemcpy(ret_buf, &val, 4);\r\noffset += sizeof(u32);\r\nret_buf += sizeof(u32);\r\nbuf_size -= sizeof(u32);\r\ncmd_flags = 0;\r\n}\r\nif (rc == 0) {\r\ncmd_flags |= MCPR_NVM_COMMAND_LAST;\r\nrc = bnx2x_nvram_read_dword(bp, offset, &val, cmd_flags);\r\nmemcpy(ret_buf, &val, 4);\r\n}\r\nbnx2x_disable_nvram_access(bp);\r\nbnx2x_release_nvram_lock(bp);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_nvram_read32(struct bnx2x *bp, u32 offset, u32 *buf,\r\nint buf_size)\r\n{\r\nint rc;\r\nrc = bnx2x_nvram_read(bp, offset, (u8 *)buf, buf_size);\r\nif (!rc) {\r\n__be32 *be = (__be32 *)buf;\r\nwhile ((buf_size -= 4) >= 0)\r\n*buf++ = be32_to_cpu(*be++);\r\n}\r\nreturn rc;\r\n}\r\nstatic bool bnx2x_is_nvm_accessible(struct bnx2x *bp)\r\n{\r\nint rc = 1;\r\nu16 pm = 0;\r\nstruct net_device *dev = pci_get_drvdata(bp->pdev);\r\nif (bp->pdev->pm_cap)\r\nrc = pci_read_config_word(bp->pdev,\r\nbp->pdev->pm_cap + PCI_PM_CTRL, &pm);\r\nif ((rc && !netif_running(dev)) ||\r\n(!rc && ((pm & PCI_PM_CTRL_STATE_MASK) != (__force u16)PCI_D0)))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int bnx2x_get_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 *eebuf)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nif (!bnx2x_is_nvm_accessible(bp)) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"cannot access eeprom when the interface is down\n");\r\nreturn -EAGAIN;\r\n}\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM, "ethtool_eeprom: cmd %d\n"\r\n" magic 0x%x offset 0x%x (%d) len 0x%x (%d)\n",\r\neeprom->cmd, eeprom->magic, eeprom->offset, eeprom->offset,\r\neeprom->len, eeprom->len);\r\nreturn bnx2x_nvram_read(bp, eeprom->offset, eebuf, eeprom->len);\r\n}\r\nstatic int bnx2x_get_module_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *ee,\r\nu8 *data)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nint rc = -EINVAL, phy_idx;\r\nu8 *user_data = data;\r\nunsigned int start_addr = ee->offset, xfer_size = 0;\r\nif (!bnx2x_is_nvm_accessible(bp)) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"cannot access eeprom when the interface is down\n");\r\nreturn -EAGAIN;\r\n}\r\nphy_idx = bnx2x_get_cur_phy_idx(bp);\r\nif (start_addr < ETH_MODULE_SFF_8079_LEN) {\r\nif (start_addr + ee->len > ETH_MODULE_SFF_8079_LEN)\r\nxfer_size = ETH_MODULE_SFF_8079_LEN - start_addr;\r\nelse\r\nxfer_size = ee->len;\r\nbnx2x_acquire_phy_lock(bp);\r\nrc = bnx2x_read_sfp_module_eeprom(&bp->link_params.phy[phy_idx],\r\n&bp->link_params,\r\nI2C_DEV_ADDR_A0,\r\nstart_addr,\r\nxfer_size,\r\nuser_data);\r\nbnx2x_release_phy_lock(bp);\r\nif (rc) {\r\nDP(BNX2X_MSG_ETHTOOL, "Failed reading A0 section\n");\r\nreturn -EINVAL;\r\n}\r\nuser_data += xfer_size;\r\nstart_addr += xfer_size;\r\n}\r\nif ((start_addr >= ETH_MODULE_SFF_8079_LEN) &&\r\n(start_addr < ETH_MODULE_SFF_8472_LEN)) {\r\nxfer_size = ee->len - xfer_size;\r\nif (start_addr + xfer_size > ETH_MODULE_SFF_8472_LEN)\r\nxfer_size = ETH_MODULE_SFF_8472_LEN - start_addr;\r\nstart_addr -= ETH_MODULE_SFF_8079_LEN;\r\nbnx2x_acquire_phy_lock(bp);\r\nrc = bnx2x_read_sfp_module_eeprom(&bp->link_params.phy[phy_idx],\r\n&bp->link_params,\r\nI2C_DEV_ADDR_A2,\r\nstart_addr,\r\nxfer_size,\r\nuser_data);\r\nbnx2x_release_phy_lock(bp);\r\nif (rc) {\r\nDP(BNX2X_MSG_ETHTOOL, "Failed reading A2 section\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int bnx2x_get_module_info(struct net_device *dev,\r\nstruct ethtool_modinfo *modinfo)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nint phy_idx, rc;\r\nu8 sff8472_comp, diag_type;\r\nif (!bnx2x_is_nvm_accessible(bp)) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"cannot access eeprom when the interface is down\n");\r\nreturn -EAGAIN;\r\n}\r\nphy_idx = bnx2x_get_cur_phy_idx(bp);\r\nbnx2x_acquire_phy_lock(bp);\r\nrc = bnx2x_read_sfp_module_eeprom(&bp->link_params.phy[phy_idx],\r\n&bp->link_params,\r\nI2C_DEV_ADDR_A0,\r\nSFP_EEPROM_SFF_8472_COMP_ADDR,\r\nSFP_EEPROM_SFF_8472_COMP_SIZE,\r\n&sff8472_comp);\r\nbnx2x_release_phy_lock(bp);\r\nif (rc) {\r\nDP(BNX2X_MSG_ETHTOOL, "Failed reading SFF-8472 comp field\n");\r\nreturn -EINVAL;\r\n}\r\nbnx2x_acquire_phy_lock(bp);\r\nrc = bnx2x_read_sfp_module_eeprom(&bp->link_params.phy[phy_idx],\r\n&bp->link_params,\r\nI2C_DEV_ADDR_A0,\r\nSFP_EEPROM_DIAG_TYPE_ADDR,\r\nSFP_EEPROM_DIAG_TYPE_SIZE,\r\n&diag_type);\r\nbnx2x_release_phy_lock(bp);\r\nif (rc) {\r\nDP(BNX2X_MSG_ETHTOOL, "Failed reading Diag Type field\n");\r\nreturn -EINVAL;\r\n}\r\nif (!sff8472_comp ||\r\n(diag_type & SFP_EEPROM_DIAG_ADDR_CHANGE_REQ)) {\r\nmodinfo->type = ETH_MODULE_SFF_8079;\r\nmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\r\n} else {\r\nmodinfo->type = ETH_MODULE_SFF_8472;\r\nmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_nvram_write_dword(struct bnx2x *bp, u32 offset, u32 val,\r\nu32 cmd_flags)\r\n{\r\nint count, i, rc;\r\ncmd_flags |= MCPR_NVM_COMMAND_DOIT | MCPR_NVM_COMMAND_WR;\r\nREG_WR(bp, MCP_REG_MCPR_NVM_COMMAND, MCPR_NVM_COMMAND_DONE);\r\nREG_WR(bp, MCP_REG_MCPR_NVM_WRITE, val);\r\nREG_WR(bp, MCP_REG_MCPR_NVM_ADDR,\r\n(offset & MCPR_NVM_ADDR_NVM_ADDR_VALUE));\r\nREG_WR(bp, MCP_REG_MCPR_NVM_COMMAND, cmd_flags);\r\ncount = BNX2X_NVRAM_TIMEOUT_COUNT;\r\nif (CHIP_REV_IS_SLOW(bp))\r\ncount *= 100;\r\nrc = -EBUSY;\r\nfor (i = 0; i < count; i++) {\r\nudelay(5);\r\nval = REG_RD(bp, MCP_REG_MCPR_NVM_COMMAND);\r\nif (val & MCPR_NVM_COMMAND_DONE) {\r\nrc = 0;\r\nbreak;\r\n}\r\n}\r\nif (rc == -EBUSY)\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"nvram write timeout expired\n");\r\nreturn rc;\r\n}\r\nstatic int bnx2x_nvram_write1(struct bnx2x *bp, u32 offset, u8 *data_buf,\r\nint buf_size)\r\n{\r\nint rc;\r\nu32 cmd_flags, align_offset, val;\r\n__be32 val_be;\r\nif (offset + buf_size > bp->common.flash_size) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"Invalid parameter: offset (0x%x) + buf_size (0x%x) > flash_size (0x%x)\n",\r\noffset, buf_size, bp->common.flash_size);\r\nreturn -EINVAL;\r\n}\r\nrc = bnx2x_acquire_nvram_lock(bp);\r\nif (rc)\r\nreturn rc;\r\nbnx2x_enable_nvram_access(bp);\r\ncmd_flags = (MCPR_NVM_COMMAND_FIRST | MCPR_NVM_COMMAND_LAST);\r\nalign_offset = (offset & ~0x03);\r\nrc = bnx2x_nvram_read_dword(bp, align_offset, &val_be, cmd_flags);\r\nif (rc == 0) {\r\nval = be32_to_cpu(val_be);\r\nval &= ~le32_to_cpu((__force __le32)\r\n(0xff << BYTE_OFFSET(offset)));\r\nval |= le32_to_cpu((__force __le32)\r\n(*data_buf << BYTE_OFFSET(offset)));\r\nrc = bnx2x_nvram_write_dword(bp, align_offset, val,\r\ncmd_flags);\r\n}\r\nbnx2x_disable_nvram_access(bp);\r\nbnx2x_release_nvram_lock(bp);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_nvram_write(struct bnx2x *bp, u32 offset, u8 *data_buf,\r\nint buf_size)\r\n{\r\nint rc;\r\nu32 cmd_flags;\r\nu32 val;\r\nu32 written_so_far;\r\nif (buf_size == 1)\r\nreturn bnx2x_nvram_write1(bp, offset, data_buf, buf_size);\r\nif ((offset & 0x03) || (buf_size & 0x03) || (buf_size == 0)) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"Invalid parameter: offset 0x%x buf_size 0x%x\n",\r\noffset, buf_size);\r\nreturn -EINVAL;\r\n}\r\nif (offset + buf_size > bp->common.flash_size) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"Invalid parameter: offset (0x%x) + buf_size (0x%x) > flash_size (0x%x)\n",\r\noffset, buf_size, bp->common.flash_size);\r\nreturn -EINVAL;\r\n}\r\nrc = bnx2x_acquire_nvram_lock(bp);\r\nif (rc)\r\nreturn rc;\r\nbnx2x_enable_nvram_access(bp);\r\nwritten_so_far = 0;\r\ncmd_flags = MCPR_NVM_COMMAND_FIRST;\r\nwhile ((written_so_far < buf_size) && (rc == 0)) {\r\nif (written_so_far == (buf_size - sizeof(u32)))\r\ncmd_flags |= MCPR_NVM_COMMAND_LAST;\r\nelse if (((offset + 4) % BNX2X_NVRAM_PAGE_SIZE) == 0)\r\ncmd_flags |= MCPR_NVM_COMMAND_LAST;\r\nelse if ((offset % BNX2X_NVRAM_PAGE_SIZE) == 0)\r\ncmd_flags |= MCPR_NVM_COMMAND_FIRST;\r\nmemcpy(&val, data_buf, 4);\r\nrc = bnx2x_nvram_write_dword(bp, offset, val, cmd_flags);\r\noffset += sizeof(u32);\r\ndata_buf += sizeof(u32);\r\nwritten_so_far += sizeof(u32);\r\nif ((cmd_flags & MCPR_NVM_COMMAND_LAST) &&\r\n(written_so_far < buf_size)) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"Releasing NVM lock after offset 0x%x\n",\r\n(u32)(offset - sizeof(u32)));\r\nbnx2x_release_nvram_lock(bp);\r\nusleep_range(1000, 2000);\r\nrc = bnx2x_acquire_nvram_lock(bp);\r\nif (rc)\r\nreturn rc;\r\n}\r\ncmd_flags = 0;\r\n}\r\nbnx2x_disable_nvram_access(bp);\r\nbnx2x_release_nvram_lock(bp);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_set_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 *eebuf)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nint port = BP_PORT(bp);\r\nint rc = 0;\r\nu32 ext_phy_config;\r\nif (!bnx2x_is_nvm_accessible(bp)) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"cannot access eeprom when the interface is down\n");\r\nreturn -EAGAIN;\r\n}\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM, "ethtool_eeprom: cmd %d\n"\r\n" magic 0x%x offset 0x%x (%d) len 0x%x (%d)\n",\r\neeprom->cmd, eeprom->magic, eeprom->offset, eeprom->offset,\r\neeprom->len, eeprom->len);\r\nif ((eeprom->magic >= 0x50485900) && (eeprom->magic <= 0x504859FF) &&\r\n!bp->port.pmf) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"wrong magic or interface is not pmf\n");\r\nreturn -EINVAL;\r\n}\r\next_phy_config =\r\nSHMEM_RD(bp,\r\ndev_info.port_hw_config[port].external_phy_config);\r\nif (eeprom->magic == 0x50485950) {\r\nbnx2x_stats_handle(bp, STATS_EVENT_STOP);\r\nbnx2x_acquire_phy_lock(bp);\r\nrc |= bnx2x_link_reset(&bp->link_params,\r\n&bp->link_vars, 0);\r\nif (XGXS_EXT_PHY_TYPE(ext_phy_config) ==\r\nPORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101)\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_0,\r\nMISC_REGISTERS_GPIO_HIGH, port);\r\nbnx2x_release_phy_lock(bp);\r\nbnx2x_link_report(bp);\r\n} else if (eeprom->magic == 0x50485952) {\r\nif (bp->state == BNX2X_STATE_OPEN) {\r\nbnx2x_acquire_phy_lock(bp);\r\nrc |= bnx2x_link_reset(&bp->link_params,\r\n&bp->link_vars, 1);\r\nrc |= bnx2x_phy_init(&bp->link_params,\r\n&bp->link_vars);\r\nbnx2x_release_phy_lock(bp);\r\nbnx2x_calc_fc_adv(bp);\r\n}\r\n} else if (eeprom->magic == 0x53985943) {\r\nif (XGXS_EXT_PHY_TYPE(ext_phy_config) ==\r\nPORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101) {\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_0,\r\nMISC_REGISTERS_GPIO_LOW, port);\r\nbnx2x_acquire_phy_lock(bp);\r\nbnx2x_sfx7101_sp_sw_reset(bp,\r\n&bp->link_params.phy[EXT_PHY1]);\r\nmsleep(500);\r\nbnx2x_ext_phy_hw_reset(bp, port);\r\nmsleep(500);\r\nbnx2x_release_phy_lock(bp);\r\n}\r\n} else\r\nrc = bnx2x_nvram_write(bp, eeprom->offset, eebuf, eeprom->len);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_get_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *coal)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nmemset(coal, 0, sizeof(struct ethtool_coalesce));\r\ncoal->rx_coalesce_usecs = bp->rx_ticks;\r\ncoal->tx_coalesce_usecs = bp->tx_ticks;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_set_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *coal)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nbp->rx_ticks = (u16)coal->rx_coalesce_usecs;\r\nif (bp->rx_ticks > BNX2X_MAX_COALESCE_TOUT)\r\nbp->rx_ticks = BNX2X_MAX_COALESCE_TOUT;\r\nbp->tx_ticks = (u16)coal->tx_coalesce_usecs;\r\nif (bp->tx_ticks > BNX2X_MAX_COALESCE_TOUT)\r\nbp->tx_ticks = BNX2X_MAX_COALESCE_TOUT;\r\nif (netif_running(dev))\r\nbnx2x_update_coalesce(bp);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_get_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *ering)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nering->rx_max_pending = MAX_RX_AVAIL;\r\nif (bp->rx_ring_size)\r\nering->rx_pending = bp->rx_ring_size;\r\nelse if (BNX2X_NUM_RX_QUEUES(bp))\r\nering->rx_pending = MAX_RX_AVAIL / BNX2X_NUM_RX_QUEUES(bp);\r\nelse\r\nering->rx_pending = MAX_RX_AVAIL;\r\nering->tx_max_pending = IS_MF_FCOE_AFEX(bp) ? 0 : MAX_TX_AVAIL;\r\nering->tx_pending = bp->tx_ring_size;\r\n}\r\nstatic int bnx2x_set_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *ering)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"set ring params command parameters: rx_pending = %d, tx_pending = %d\n",\r\nering->rx_pending, ering->tx_pending);\r\nif (pci_num_vf(bp->pdev)) {\r\nDP(BNX2X_MSG_IOV,\r\n"VFs are enabled, can not change ring parameters\n");\r\nreturn -EPERM;\r\n}\r\nif (bp->recovery_state != BNX2X_RECOVERY_DONE) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Handling parity error recovery. Try again later\n");\r\nreturn -EAGAIN;\r\n}\r\nif ((ering->rx_pending > MAX_RX_AVAIL) ||\r\n(ering->rx_pending < (bp->disable_tpa ? MIN_RX_SIZE_NONTPA :\r\nMIN_RX_SIZE_TPA)) ||\r\n(ering->tx_pending > (IS_MF_STORAGE_ONLY(bp) ? 0 : MAX_TX_AVAIL)) ||\r\n(ering->tx_pending <= MAX_SKB_FRAGS + 4)) {\r\nDP(BNX2X_MSG_ETHTOOL, "Command parameters not supported\n");\r\nreturn -EINVAL;\r\n}\r\nbp->rx_ring_size = ering->rx_pending;\r\nbp->tx_ring_size = ering->tx_pending;\r\nreturn bnx2x_reload_if_running(dev);\r\n}\r\nstatic void bnx2x_get_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *epause)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nint cfg_idx = bnx2x_get_link_cfg_idx(bp);\r\nint cfg_reg;\r\nepause->autoneg = (bp->link_params.req_flow_ctrl[cfg_idx] ==\r\nBNX2X_FLOW_CTRL_AUTO);\r\nif (!epause->autoneg)\r\ncfg_reg = bp->link_params.req_flow_ctrl[cfg_idx];\r\nelse\r\ncfg_reg = bp->link_params.req_fc_auto_adv;\r\nepause->rx_pause = ((cfg_reg & BNX2X_FLOW_CTRL_RX) ==\r\nBNX2X_FLOW_CTRL_RX);\r\nepause->tx_pause = ((cfg_reg & BNX2X_FLOW_CTRL_TX) ==\r\nBNX2X_FLOW_CTRL_TX);\r\nDP(BNX2X_MSG_ETHTOOL, "ethtool_pauseparam: cmd %d\n"\r\n" autoneg %d rx_pause %d tx_pause %d\n",\r\nepause->cmd, epause->autoneg, epause->rx_pause, epause->tx_pause);\r\n}\r\nstatic int bnx2x_set_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *epause)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nu32 cfg_idx = bnx2x_get_link_cfg_idx(bp);\r\nif (IS_MF(bp))\r\nreturn 0;\r\nDP(BNX2X_MSG_ETHTOOL, "ethtool_pauseparam: cmd %d\n"\r\n" autoneg %d rx_pause %d tx_pause %d\n",\r\nepause->cmd, epause->autoneg, epause->rx_pause, epause->tx_pause);\r\nbp->link_params.req_flow_ctrl[cfg_idx] = BNX2X_FLOW_CTRL_AUTO;\r\nif (epause->rx_pause)\r\nbp->link_params.req_flow_ctrl[cfg_idx] |= BNX2X_FLOW_CTRL_RX;\r\nif (epause->tx_pause)\r\nbp->link_params.req_flow_ctrl[cfg_idx] |= BNX2X_FLOW_CTRL_TX;\r\nif (bp->link_params.req_flow_ctrl[cfg_idx] == BNX2X_FLOW_CTRL_AUTO)\r\nbp->link_params.req_flow_ctrl[cfg_idx] = BNX2X_FLOW_CTRL_NONE;\r\nif (epause->autoneg) {\r\nif (!(bp->port.supported[cfg_idx] & SUPPORTED_Autoneg)) {\r\nDP(BNX2X_MSG_ETHTOOL, "autoneg not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (bp->link_params.req_line_speed[cfg_idx] == SPEED_AUTO_NEG) {\r\nbp->link_params.req_flow_ctrl[cfg_idx] =\r\nBNX2X_FLOW_CTRL_AUTO;\r\n}\r\nbp->link_params.req_fc_auto_adv = 0;\r\nif (epause->rx_pause)\r\nbp->link_params.req_fc_auto_adv |= BNX2X_FLOW_CTRL_RX;\r\nif (epause->tx_pause)\r\nbp->link_params.req_fc_auto_adv |= BNX2X_FLOW_CTRL_TX;\r\nif (!bp->link_params.req_fc_auto_adv)\r\nbp->link_params.req_fc_auto_adv |= BNX2X_FLOW_CTRL_NONE;\r\n}\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"req_flow_ctrl 0x%x\n", bp->link_params.req_flow_ctrl[cfg_idx]);\r\nif (netif_running(dev)) {\r\nbnx2x_stats_handle(bp, STATS_EVENT_STOP);\r\nbnx2x_force_link_reset(bp);\r\nbnx2x_link_set(bp);\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 bnx2x_eee_to_adv(u32 eee_adv)\r\n{\r\nu32 modes = 0;\r\nif (eee_adv & SHMEM_EEE_100M_ADV)\r\nmodes |= ADVERTISED_100baseT_Full;\r\nif (eee_adv & SHMEM_EEE_1G_ADV)\r\nmodes |= ADVERTISED_1000baseT_Full;\r\nif (eee_adv & SHMEM_EEE_10G_ADV)\r\nmodes |= ADVERTISED_10000baseT_Full;\r\nreturn modes;\r\n}\r\nstatic u32 bnx2x_adv_to_eee(u32 modes, u32 shift)\r\n{\r\nu32 eee_adv = 0;\r\nif (modes & ADVERTISED_100baseT_Full)\r\neee_adv |= SHMEM_EEE_100M_ADV;\r\nif (modes & ADVERTISED_1000baseT_Full)\r\neee_adv |= SHMEM_EEE_1G_ADV;\r\nif (modes & ADVERTISED_10000baseT_Full)\r\neee_adv |= SHMEM_EEE_10G_ADV;\r\nreturn eee_adv << shift;\r\n}\r\nstatic int bnx2x_get_eee(struct net_device *dev, struct ethtool_eee *edata)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nu32 eee_cfg;\r\nif (!SHMEM2_HAS(bp, eee_status[BP_PORT(bp)])) {\r\nDP(BNX2X_MSG_ETHTOOL, "BC Version does not support EEE\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\neee_cfg = bp->link_vars.eee_status;\r\nedata->supported =\r\nbnx2x_eee_to_adv((eee_cfg & SHMEM_EEE_SUPPORTED_MASK) >>\r\nSHMEM_EEE_SUPPORTED_SHIFT);\r\nedata->advertised =\r\nbnx2x_eee_to_adv((eee_cfg & SHMEM_EEE_ADV_STATUS_MASK) >>\r\nSHMEM_EEE_ADV_STATUS_SHIFT);\r\nedata->lp_advertised =\r\nbnx2x_eee_to_adv((eee_cfg & SHMEM_EEE_LP_ADV_STATUS_MASK) >>\r\nSHMEM_EEE_LP_ADV_STATUS_SHIFT);\r\nedata->tx_lpi_timer = (eee_cfg & SHMEM_EEE_TIMER_MASK) << 4;\r\nedata->eee_enabled = (eee_cfg & SHMEM_EEE_REQUESTED_BIT) ? 1 : 0;\r\nedata->eee_active = (eee_cfg & SHMEM_EEE_ACTIVE_BIT) ? 1 : 0;\r\nedata->tx_lpi_enabled = (eee_cfg & SHMEM_EEE_LPI_REQUESTED_BIT) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_set_eee(struct net_device *dev, struct ethtool_eee *edata)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nu32 eee_cfg;\r\nu32 advertised;\r\nif (IS_MF(bp))\r\nreturn 0;\r\nif (!SHMEM2_HAS(bp, eee_status[BP_PORT(bp)])) {\r\nDP(BNX2X_MSG_ETHTOOL, "BC Version does not support EEE\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\neee_cfg = bp->link_vars.eee_status;\r\nif (!(eee_cfg & SHMEM_EEE_SUPPORTED_MASK)) {\r\nDP(BNX2X_MSG_ETHTOOL, "Board does not support EEE!\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nadvertised = bnx2x_adv_to_eee(edata->advertised,\r\nSHMEM_EEE_ADV_STATUS_SHIFT);\r\nif ((advertised != (eee_cfg & SHMEM_EEE_ADV_STATUS_MASK))) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Direct manipulation of EEE advertisement is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (edata->tx_lpi_timer > EEE_MODE_TIMER_MASK) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Maximal Tx Lpi timer supported is %x(u)\n",\r\nEEE_MODE_TIMER_MASK);\r\nreturn -EINVAL;\r\n}\r\nif (edata->tx_lpi_enabled &&\r\n(edata->tx_lpi_timer < EEE_MODE_NVRAM_AGGRESSIVE_TIME)) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Minimal Tx Lpi timer supported is %d(u)\n",\r\nEEE_MODE_NVRAM_AGGRESSIVE_TIME);\r\nreturn -EINVAL;\r\n}\r\nif (edata->eee_enabled)\r\nbp->link_params.eee_mode |= EEE_MODE_ADV_LPI;\r\nelse\r\nbp->link_params.eee_mode &= ~EEE_MODE_ADV_LPI;\r\nif (edata->tx_lpi_enabled)\r\nbp->link_params.eee_mode |= EEE_MODE_ENABLE_LPI;\r\nelse\r\nbp->link_params.eee_mode &= ~EEE_MODE_ENABLE_LPI;\r\nbp->link_params.eee_mode &= ~EEE_MODE_TIMER_MASK;\r\nbp->link_params.eee_mode |= (edata->tx_lpi_timer &\r\nEEE_MODE_TIMER_MASK) |\r\nEEE_MODE_OVERRIDE_NVRAM |\r\nEEE_MODE_OUTPUT_TIME;\r\nif (netif_running(dev)) {\r\nbnx2x_stats_handle(bp, STATS_EVENT_STOP);\r\nbnx2x_force_link_reset(bp);\r\nbnx2x_link_set(bp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_test_registers(struct bnx2x *bp)\r\n{\r\nint idx, i, rc = -ENODEV;\r\nu32 wr_val = 0, hw;\r\nint port = BP_PORT(bp);\r\nstatic const struct {\r\nu32 hw;\r\nu32 offset0;\r\nu32 offset1;\r\nu32 mask;\r\n} reg_tbl[] = {\r\n{ BNX2X_CHIP_MASK_ALL,\r\nBRB1_REG_PAUSE_LOW_THRESHOLD_0, 4, 0x000003ff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nDORQ_REG_DB_ADDR0, 4, 0xffffffff },\r\n{ BNX2X_CHIP_MASK_E1X,\r\nHC_REG_AGG_INT_0, 4, 0x000003ff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nPBF_REG_MAC_IF0_ENABLE, 4, 0x00000001 },\r\n{ BNX2X_CHIP_MASK_E1X | BNX2X_CHIP_MASK_E2 | BNX2X_CHIP_MASK_E3,\r\nPBF_REG_P0_INIT_CRD, 4, 0x000007ff },\r\n{ BNX2X_CHIP_MASK_E3B0,\r\nPBF_REG_INIT_CRD_Q0, 4, 0x000007ff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nPRS_REG_CID_PORT_0, 4, 0x00ffffff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nPXP2_REG_PSWRQ_CDU0_L2P, 4, 0x000fffff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nPXP2_REG_RQ_CDU0_EFIRST_MEM_ADDR, 8, 0x0003ffff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nPXP2_REG_PSWRQ_TM0_L2P, 4, 0x000fffff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nPXP2_REG_RQ_USDM0_EFIRST_MEM_ADDR, 8, 0x0003ffff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nPXP2_REG_PSWRQ_TSDM0_L2P, 4, 0x000fffff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nQM_REG_CONNNUM_0, 4, 0x000fffff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nTM_REG_LIN0_MAX_ACTIVE_CID, 4, 0x0003ffff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nSRC_REG_KEYRSS0_0, 40, 0xffffffff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nSRC_REG_KEYRSS0_7, 40, 0xffffffff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nXCM_REG_WU_DA_SET_TMR_CNT_FLG_CMD00, 4, 0x00000001 },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nXCM_REG_WU_DA_CNT_CMD00, 4, 0x00000003 },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nXCM_REG_GLB_DEL_ACK_MAX_CNT_0, 4, 0x000000ff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nNIG_REG_LLH0_T_BIT, 4, 0x00000001 },\r\n{ BNX2X_CHIP_MASK_E1X | BNX2X_CHIP_MASK_E2,\r\nNIG_REG_EMAC0_IN_EN, 4, 0x00000001 },\r\n{ BNX2X_CHIP_MASK_E1X | BNX2X_CHIP_MASK_E2,\r\nNIG_REG_BMAC0_IN_EN, 4, 0x00000001 },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nNIG_REG_XCM0_OUT_EN, 4, 0x00000001 },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nNIG_REG_BRB0_OUT_EN, 4, 0x00000001 },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nNIG_REG_LLH0_XCM_MASK, 4, 0x00000007 },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nNIG_REG_LLH0_ACPI_PAT_6_LEN, 68, 0x000000ff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nNIG_REG_LLH0_ACPI_PAT_0_CRC, 68, 0xffffffff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nNIG_REG_LLH0_DEST_MAC_0_0, 160, 0xffffffff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nNIG_REG_LLH0_DEST_IP_0_1, 160, 0xffffffff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nNIG_REG_LLH0_IPV4_IPV6_0, 160, 0x00000001 },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nNIG_REG_LLH0_DEST_UDP_0, 160, 0x0000ffff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nNIG_REG_LLH0_DEST_TCP_0, 160, 0x0000ffff },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nNIG_REG_LLH0_VLAN_ID_0, 160, 0x00000fff },\r\n{ BNX2X_CHIP_MASK_E1X | BNX2X_CHIP_MASK_E2,\r\nNIG_REG_XGXS_SERDES0_MODE_SEL, 4, 0x00000001 },\r\n{ BNX2X_CHIP_MASK_ALL,\r\nNIG_REG_LED_CONTROL_OVERRIDE_TRAFFIC_P0, 4, 0x00000001},\r\n{ BNX2X_CHIP_MASK_ALL,\r\nNIG_REG_STATUS_INTERRUPT_PORT0, 4, 0x07ffffff },\r\n{ BNX2X_CHIP_MASK_E1X | BNX2X_CHIP_MASK_E2,\r\nNIG_REG_XGXS0_CTRL_EXTREMOTEMDIOST, 24, 0x00000001 },\r\n{ BNX2X_CHIP_MASK_E1X | BNX2X_CHIP_MASK_E2,\r\nNIG_REG_SERDES0_CTRL_PHY_ADDR, 16, 0x0000001f },\r\n{ BNX2X_CHIP_MASK_ALL, 0xffffffff, 0, 0x00000000 }\r\n};\r\nif (!bnx2x_is_nvm_accessible(bp)) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"cannot access eeprom when the interface is down\n");\r\nreturn rc;\r\n}\r\nif (CHIP_IS_E1(bp))\r\nhw = BNX2X_CHIP_MASK_E1;\r\nelse if (CHIP_IS_E1H(bp))\r\nhw = BNX2X_CHIP_MASK_E1H;\r\nelse if (CHIP_IS_E2(bp))\r\nhw = BNX2X_CHIP_MASK_E2;\r\nelse if (CHIP_IS_E3B0(bp))\r\nhw = BNX2X_CHIP_MASK_E3B0;\r\nelse\r\nhw = BNX2X_CHIP_MASK_E3;\r\nfor (idx = 0; idx < 2; idx++) {\r\nswitch (idx) {\r\ncase 0:\r\nwr_val = 0;\r\nbreak;\r\ncase 1:\r\nwr_val = 0xffffffff;\r\nbreak;\r\n}\r\nfor (i = 0; reg_tbl[i].offset0 != 0xffffffff; i++) {\r\nu32 offset, mask, save_val, val;\r\nif (!(hw & reg_tbl[i].hw))\r\ncontinue;\r\noffset = reg_tbl[i].offset0 + port*reg_tbl[i].offset1;\r\nmask = reg_tbl[i].mask;\r\nsave_val = REG_RD(bp, offset);\r\nREG_WR(bp, offset, wr_val & mask);\r\nval = REG_RD(bp, offset);\r\nREG_WR(bp, offset, save_val);\r\nif ((val & mask) != (wr_val & mask)) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"offset 0x%x: val 0x%x != 0x%x mask 0x%x\n",\r\noffset, val, wr_val, mask);\r\ngoto test_reg_exit;\r\n}\r\n}\r\n}\r\nrc = 0;\r\ntest_reg_exit:\r\nreturn rc;\r\n}\r\nstatic int bnx2x_test_memory(struct bnx2x *bp)\r\n{\r\nint i, j, rc = -ENODEV;\r\nu32 val, index;\r\nstatic const struct {\r\nu32 offset;\r\nint size;\r\n} mem_tbl[] = {\r\n{ CCM_REG_XX_DESCR_TABLE, CCM_REG_XX_DESCR_TABLE_SIZE },\r\n{ CFC_REG_ACTIVITY_COUNTER, CFC_REG_ACTIVITY_COUNTER_SIZE },\r\n{ CFC_REG_LINK_LIST, CFC_REG_LINK_LIST_SIZE },\r\n{ DMAE_REG_CMD_MEM, DMAE_REG_CMD_MEM_SIZE },\r\n{ TCM_REG_XX_DESCR_TABLE, TCM_REG_XX_DESCR_TABLE_SIZE },\r\n{ UCM_REG_XX_DESCR_TABLE, UCM_REG_XX_DESCR_TABLE_SIZE },\r\n{ XCM_REG_XX_DESCR_TABLE, XCM_REG_XX_DESCR_TABLE_SIZE },\r\n{ 0xffffffff, 0 }\r\n};\r\nstatic const struct {\r\nchar *name;\r\nu32 offset;\r\nu32 hw_mask[BNX2X_CHIP_MAX_OFST];\r\n} prty_tbl[] = {\r\n{ "CCM_PRTY_STS", CCM_REG_CCM_PRTY_STS,\r\n{0x3ffc0, 0, 0, 0} },\r\n{ "CFC_PRTY_STS", CFC_REG_CFC_PRTY_STS,\r\n{0x2, 0x2, 0, 0} },\r\n{ "DMAE_PRTY_STS", DMAE_REG_DMAE_PRTY_STS,\r\n{0, 0, 0, 0} },\r\n{ "TCM_PRTY_STS", TCM_REG_TCM_PRTY_STS,\r\n{0x3ffc0, 0, 0, 0} },\r\n{ "UCM_PRTY_STS", UCM_REG_UCM_PRTY_STS,\r\n{0x3ffc0, 0, 0, 0} },\r\n{ "XCM_PRTY_STS", XCM_REG_XCM_PRTY_STS,\r\n{0x3ffc1, 0, 0, 0} },\r\n{ NULL, 0xffffffff, {0, 0, 0, 0} }\r\n};\r\nif (!bnx2x_is_nvm_accessible(bp)) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"cannot access eeprom when the interface is down\n");\r\nreturn rc;\r\n}\r\nif (CHIP_IS_E1(bp))\r\nindex = BNX2X_CHIP_E1_OFST;\r\nelse if (CHIP_IS_E1H(bp))\r\nindex = BNX2X_CHIP_E1H_OFST;\r\nelse if (CHIP_IS_E2(bp))\r\nindex = BNX2X_CHIP_E2_OFST;\r\nelse\r\nindex = BNX2X_CHIP_E3_OFST;\r\nfor (i = 0; prty_tbl[i].offset != 0xffffffff; i++) {\r\nval = REG_RD(bp, prty_tbl[i].offset);\r\nif (val & ~(prty_tbl[i].hw_mask[index])) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"%s is 0x%x\n", prty_tbl[i].name, val);\r\ngoto test_mem_exit;\r\n}\r\n}\r\nfor (i = 0; mem_tbl[i].offset != 0xffffffff; i++)\r\nfor (j = 0; j < mem_tbl[i].size; j++)\r\nREG_RD(bp, mem_tbl[i].offset + j*4);\r\nfor (i = 0; prty_tbl[i].offset != 0xffffffff; i++) {\r\nval = REG_RD(bp, prty_tbl[i].offset);\r\nif (val & ~(prty_tbl[i].hw_mask[index])) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"%s is 0x%x\n", prty_tbl[i].name, val);\r\ngoto test_mem_exit;\r\n}\r\n}\r\nrc = 0;\r\ntest_mem_exit:\r\nreturn rc;\r\n}\r\nstatic void bnx2x_wait_for_link(struct bnx2x *bp, u8 link_up, u8 is_serdes)\r\n{\r\nint cnt = 1400;\r\nif (link_up) {\r\nwhile (bnx2x_link_test(bp, is_serdes) && cnt--)\r\nmsleep(20);\r\nif (cnt <= 0 && bnx2x_link_test(bp, is_serdes))\r\nDP(BNX2X_MSG_ETHTOOL, "Timeout waiting for link up\n");\r\ncnt = 1400;\r\nwhile (!bp->link_vars.link_up && cnt--)\r\nmsleep(20);\r\nif (cnt <= 0 && !bp->link_vars.link_up)\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Timeout waiting for link init\n");\r\n}\r\n}\r\nstatic int bnx2x_run_loopback(struct bnx2x *bp, int loopback_mode)\r\n{\r\nunsigned int pkt_size, num_pkts, i;\r\nstruct sk_buff *skb;\r\nunsigned char *packet;\r\nstruct bnx2x_fastpath *fp_rx = &bp->fp[0];\r\nstruct bnx2x_fastpath *fp_tx = &bp->fp[0];\r\nstruct bnx2x_fp_txdata *txdata = fp_tx->txdata_ptr[0];\r\nu16 tx_start_idx, tx_idx;\r\nu16 rx_start_idx, rx_idx;\r\nu16 pkt_prod, bd_prod;\r\nstruct sw_tx_bd *tx_buf;\r\nstruct eth_tx_start_bd *tx_start_bd;\r\ndma_addr_t mapping;\r\nunion eth_rx_cqe *cqe;\r\nu8 cqe_fp_flags, cqe_fp_type;\r\nstruct sw_rx_bd *rx_buf;\r\nu16 len;\r\nint rc = -ENODEV;\r\nu8 *data;\r\nstruct netdev_queue *txq = netdev_get_tx_queue(bp->dev,\r\ntxdata->txq_index);\r\nswitch (loopback_mode) {\r\ncase BNX2X_PHY_LOOPBACK:\r\nif (bp->link_params.loopback_mode != LOOPBACK_XGXS) {\r\nDP(BNX2X_MSG_ETHTOOL, "PHY loopback not supported\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase BNX2X_MAC_LOOPBACK:\r\nif (CHIP_IS_E3(bp)) {\r\nint cfg_idx = bnx2x_get_link_cfg_idx(bp);\r\nif (bp->port.supported[cfg_idx] &\r\n(SUPPORTED_10000baseT_Full |\r\nSUPPORTED_20000baseMLD2_Full |\r\nSUPPORTED_20000baseKR2_Full))\r\nbp->link_params.loopback_mode = LOOPBACK_XMAC;\r\nelse\r\nbp->link_params.loopback_mode = LOOPBACK_UMAC;\r\n} else\r\nbp->link_params.loopback_mode = LOOPBACK_BMAC;\r\nbnx2x_phy_init(&bp->link_params, &bp->link_vars);\r\nbreak;\r\ncase BNX2X_EXT_LOOPBACK:\r\nif (bp->link_params.loopback_mode != LOOPBACK_EXT) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Can't configure external loopback\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nDP(BNX2X_MSG_ETHTOOL, "Command parameters not supported\n");\r\nreturn -EINVAL;\r\n}\r\npkt_size = (((bp->dev->mtu < ETH_MAX_PACKET_SIZE) ?\r\nbp->dev->mtu : ETH_MAX_PACKET_SIZE) + ETH_HLEN);\r\nskb = netdev_alloc_skb(bp->dev, fp_rx->rx_buf_size);\r\nif (!skb) {\r\nDP(BNX2X_MSG_ETHTOOL, "Can't allocate skb\n");\r\nrc = -ENOMEM;\r\ngoto test_loopback_exit;\r\n}\r\npacket = skb_put(skb, pkt_size);\r\nmemcpy(packet, bp->dev->dev_addr, ETH_ALEN);\r\neth_zero_addr(packet + ETH_ALEN);\r\nmemset(packet + 2*ETH_ALEN, 0x77, (ETH_HLEN - 2*ETH_ALEN));\r\nfor (i = ETH_HLEN; i < pkt_size; i++)\r\npacket[i] = (unsigned char) (i & 0xff);\r\nmapping = dma_map_single(&bp->pdev->dev, skb->data,\r\nskb_headlen(skb), DMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(&bp->pdev->dev, mapping))) {\r\nrc = -ENOMEM;\r\ndev_kfree_skb(skb);\r\nDP(BNX2X_MSG_ETHTOOL, "Unable to map SKB\n");\r\ngoto test_loopback_exit;\r\n}\r\nnum_pkts = 0;\r\ntx_start_idx = le16_to_cpu(*txdata->tx_cons_sb);\r\nrx_start_idx = le16_to_cpu(*fp_rx->rx_cons_sb);\r\nnetdev_tx_sent_queue(txq, skb->len);\r\npkt_prod = txdata->tx_pkt_prod++;\r\ntx_buf = &txdata->tx_buf_ring[TX_BD(pkt_prod)];\r\ntx_buf->first_bd = txdata->tx_bd_prod;\r\ntx_buf->skb = skb;\r\ntx_buf->flags = 0;\r\nbd_prod = TX_BD(txdata->tx_bd_prod);\r\ntx_start_bd = &txdata->tx_desc_ring[bd_prod].start_bd;\r\ntx_start_bd->addr_hi = cpu_to_le32(U64_HI(mapping));\r\ntx_start_bd->addr_lo = cpu_to_le32(U64_LO(mapping));\r\ntx_start_bd->nbd = cpu_to_le16(2);\r\ntx_start_bd->nbytes = cpu_to_le16(skb_headlen(skb));\r\ntx_start_bd->vlan_or_ethertype = cpu_to_le16(pkt_prod);\r\ntx_start_bd->bd_flags.as_bitfield = ETH_TX_BD_FLAGS_START_BD;\r\nSET_FLAG(tx_start_bd->general_data,\r\nETH_TX_START_BD_HDR_NBDS,\r\n1);\r\nSET_FLAG(tx_start_bd->general_data,\r\nETH_TX_START_BD_PARSE_NBDS,\r\n0);\r\nbd_prod = TX_BD(NEXT_TX_IDX(bd_prod));\r\nif (CHIP_IS_E1x(bp)) {\r\nu16 global_data = 0;\r\nstruct eth_tx_parse_bd_e1x *pbd_e1x =\r\n&txdata->tx_desc_ring[bd_prod].parse_bd_e1x;\r\nmemset(pbd_e1x, 0, sizeof(struct eth_tx_parse_bd_e1x));\r\nSET_FLAG(global_data,\r\nETH_TX_PARSE_BD_E1X_ETH_ADDR_TYPE, UNICAST_ADDRESS);\r\npbd_e1x->global_data = cpu_to_le16(global_data);\r\n} else {\r\nu32 parsing_data = 0;\r\nstruct eth_tx_parse_bd_e2 *pbd_e2 =\r\n&txdata->tx_desc_ring[bd_prod].parse_bd_e2;\r\nmemset(pbd_e2, 0, sizeof(struct eth_tx_parse_bd_e2));\r\nSET_FLAG(parsing_data,\r\nETH_TX_PARSE_BD_E2_ETH_ADDR_TYPE, UNICAST_ADDRESS);\r\npbd_e2->parsing_data = cpu_to_le32(parsing_data);\r\n}\r\nwmb();\r\ntxdata->tx_db.data.prod += 2;\r\nbarrier();\r\nDOORBELL(bp, txdata->cid, txdata->tx_db.raw);\r\nmmiowb();\r\nbarrier();\r\nnum_pkts++;\r\ntxdata->tx_bd_prod += 2;\r\nudelay(100);\r\ntx_idx = le16_to_cpu(*txdata->tx_cons_sb);\r\nif (tx_idx != tx_start_idx + num_pkts)\r\ngoto test_loopback_exit;\r\nif (bp->common.int_block == INT_BLOCK_IGU) {\r\nlocal_bh_disable();\r\nbnx2x_tx_int(bp, txdata);\r\nlocal_bh_enable();\r\n}\r\nrx_idx = le16_to_cpu(*fp_rx->rx_cons_sb);\r\nif (rx_idx != rx_start_idx + num_pkts)\r\ngoto test_loopback_exit;\r\ncqe = &fp_rx->rx_comp_ring[RCQ_BD(fp_rx->rx_comp_cons)];\r\ncqe_fp_flags = cqe->fast_path_cqe.type_error_flags;\r\ncqe_fp_type = cqe_fp_flags & ETH_FAST_PATH_RX_CQE_TYPE;\r\nif (!CQE_TYPE_FAST(cqe_fp_type) || (cqe_fp_flags & ETH_RX_ERROR_FALGS))\r\ngoto test_loopback_rx_exit;\r\nlen = le16_to_cpu(cqe->fast_path_cqe.pkt_len_or_gro_seg_len);\r\nif (len != pkt_size)\r\ngoto test_loopback_rx_exit;\r\nrx_buf = &fp_rx->rx_buf_ring[RX_BD(fp_rx->rx_bd_cons)];\r\ndma_sync_single_for_cpu(&bp->pdev->dev,\r\ndma_unmap_addr(rx_buf, mapping),\r\nfp_rx->rx_buf_size, DMA_FROM_DEVICE);\r\ndata = rx_buf->data + NET_SKB_PAD + cqe->fast_path_cqe.placement_offset;\r\nfor (i = ETH_HLEN; i < pkt_size; i++)\r\nif (*(data + i) != (unsigned char) (i & 0xff))\r\ngoto test_loopback_rx_exit;\r\nrc = 0;\r\ntest_loopback_rx_exit:\r\nfp_rx->rx_bd_cons = NEXT_RX_IDX(fp_rx->rx_bd_cons);\r\nfp_rx->rx_bd_prod = NEXT_RX_IDX(fp_rx->rx_bd_prod);\r\nfp_rx->rx_comp_cons = NEXT_RCQ_IDX(fp_rx->rx_comp_cons);\r\nfp_rx->rx_comp_prod = NEXT_RCQ_IDX(fp_rx->rx_comp_prod);\r\nbnx2x_update_rx_prod(bp, fp_rx, fp_rx->rx_bd_prod, fp_rx->rx_comp_prod,\r\nfp_rx->rx_sge_prod);\r\ntest_loopback_exit:\r\nbp->link_params.loopback_mode = LOOPBACK_NONE;\r\nreturn rc;\r\n}\r\nstatic int bnx2x_test_loopback(struct bnx2x *bp)\r\n{\r\nint rc = 0, res;\r\nif (BP_NOMCP(bp))\r\nreturn rc;\r\nif (!netif_running(bp->dev))\r\nreturn BNX2X_LOOPBACK_FAILED;\r\nbnx2x_netif_stop(bp, 1);\r\nbnx2x_acquire_phy_lock(bp);\r\nres = bnx2x_run_loopback(bp, BNX2X_PHY_LOOPBACK);\r\nif (res) {\r\nDP(BNX2X_MSG_ETHTOOL, " PHY loopback failed (res %d)\n", res);\r\nrc |= BNX2X_PHY_LOOPBACK_FAILED;\r\n}\r\nres = bnx2x_run_loopback(bp, BNX2X_MAC_LOOPBACK);\r\nif (res) {\r\nDP(BNX2X_MSG_ETHTOOL, " MAC loopback failed (res %d)\n", res);\r\nrc |= BNX2X_MAC_LOOPBACK_FAILED;\r\n}\r\nbnx2x_release_phy_lock(bp);\r\nbnx2x_netif_start(bp);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_test_ext_loopback(struct bnx2x *bp)\r\n{\r\nint rc;\r\nu8 is_serdes =\r\n(bp->link_vars.link_status & LINK_STATUS_SERDES_LINK) > 0;\r\nif (BP_NOMCP(bp))\r\nreturn -ENODEV;\r\nif (!netif_running(bp->dev))\r\nreturn BNX2X_EXT_LOOPBACK_FAILED;\r\nbnx2x_nic_unload(bp, UNLOAD_NORMAL, false);\r\nrc = bnx2x_nic_load(bp, LOAD_LOOPBACK_EXT);\r\nif (rc) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Can't perform self-test, nic_load (for external lb) failed\n");\r\nreturn -ENODEV;\r\n}\r\nbnx2x_wait_for_link(bp, 1, is_serdes);\r\nbnx2x_netif_stop(bp, 1);\r\nrc = bnx2x_run_loopback(bp, BNX2X_EXT_LOOPBACK);\r\nif (rc)\r\nDP(BNX2X_MSG_ETHTOOL, "EXT loopback failed (res %d)\n", rc);\r\nbnx2x_netif_start(bp);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_nvram_crc(struct bnx2x *bp,\r\nint offset,\r\nint size,\r\nu8 *buff)\r\n{\r\nu32 crc = ~0;\r\nint rc = 0, done = 0;\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"NVRAM CRC from 0x%08x to 0x%08x\n", offset, offset + size);\r\nwhile (done < size) {\r\nint count = min_t(int, size - done, CRC_BUFF_SIZE);\r\nrc = bnx2x_nvram_read(bp, offset + done, buff, count);\r\nif (rc)\r\nreturn rc;\r\ncrc = crc32_le(crc, buff, count);\r\ndone += count;\r\n}\r\nif (crc != CRC32_RESIDUAL)\r\nrc = -EINVAL;\r\nreturn rc;\r\n}\r\nstatic int bnx2x_test_nvram_dir(struct bnx2x *bp,\r\nstruct code_entry *entry,\r\nu8 *buff)\r\n{\r\nsize_t size = entry->code_attribute & CODE_IMAGE_LENGTH_MASK;\r\nu32 type = entry->code_attribute & CODE_IMAGE_TYPE_MASK;\r\nint rc;\r\nif (size == 0 || type == CODE_IMAGE_VNTAG_PROFILES_DATA)\r\nreturn 0;\r\nrc = bnx2x_nvram_crc(bp, entry->nvm_start_addr, size, buff);\r\nif (rc)\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"image %x has failed crc test (rc %d)\n", type, rc);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_test_dir_entry(struct bnx2x *bp, u32 addr, u8 *buff)\r\n{\r\nint rc;\r\nstruct code_entry entry;\r\nrc = bnx2x_nvram_read32(bp, addr, (u32 *)&entry, sizeof(entry));\r\nif (rc)\r\nreturn rc;\r\nreturn bnx2x_test_nvram_dir(bp, &entry, buff);\r\n}\r\nstatic int bnx2x_test_nvram_ext_dirs(struct bnx2x *bp, u8 *buff)\r\n{\r\nu32 rc, cnt, dir_offset = NVRAM_DIR_OFFSET;\r\nstruct code_entry entry;\r\nint i;\r\nrc = bnx2x_nvram_read32(bp,\r\ndir_offset +\r\nsizeof(entry) * CODE_ENTRY_EXTENDED_DIR_IDX,\r\n(u32 *)&entry, sizeof(entry));\r\nif (rc)\r\nreturn rc;\r\nif (!EXTENDED_DIR_EXISTS(entry.code_attribute))\r\nreturn 0;\r\nrc = bnx2x_nvram_read32(bp, entry.nvm_start_addr,\r\n&cnt, sizeof(u32));\r\nif (rc)\r\nreturn rc;\r\ndir_offset = entry.nvm_start_addr + 8;\r\nfor (i = 0; i < cnt && i < MAX_IMAGES_IN_EXTENDED_DIR; i++) {\r\nrc = bnx2x_test_dir_entry(bp, dir_offset +\r\nsizeof(struct code_entry) * i,\r\nbuff);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_test_nvram_dirs(struct bnx2x *bp, u8 *buff)\r\n{\r\nu32 rc, dir_offset = NVRAM_DIR_OFFSET;\r\nint i;\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM, "NVRAM DIRS CRC test-set\n");\r\nfor (i = 0; i < CODE_ENTRY_EXTENDED_DIR_IDX; i++) {\r\nrc = bnx2x_test_dir_entry(bp, dir_offset +\r\nsizeof(struct code_entry) * i,\r\nbuff);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn bnx2x_test_nvram_ext_dirs(bp, buff);\r\n}\r\nstatic int bnx2x_test_nvram_tbl(struct bnx2x *bp,\r\nconst struct crc_pair *nvram_tbl, u8 *buf)\r\n{\r\nint i;\r\nfor (i = 0; nvram_tbl[i].size; i++) {\r\nint rc = bnx2x_nvram_crc(bp, nvram_tbl[i].offset,\r\nnvram_tbl[i].size, buf);\r\nif (rc) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"nvram_tbl[%d] has failed crc test (rc %d)\n",\r\ni, rc);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_test_nvram(struct bnx2x *bp)\r\n{\r\nstatic const struct crc_pair nvram_tbl[] = {\r\n{ 0, 0x14 },\r\n{ 0x14, 0xec },\r\n{ 0x100, 0x350 },\r\n{ 0x450, 0xf0 },\r\n{ 0x640, 0x64 },\r\n{ 0x708, 0x70 },\r\n{ 0, 0 }\r\n};\r\nstatic const struct crc_pair nvram_tbl2[] = {\r\n{ 0x7e8, 0x350 },\r\n{ 0xb38, 0xf0 },\r\n{ 0, 0 }\r\n};\r\nu8 *buf;\r\nint rc;\r\nu32 magic;\r\nif (BP_NOMCP(bp))\r\nreturn 0;\r\nbuf = kmalloc(CRC_BUFF_SIZE, GFP_KERNEL);\r\nif (!buf) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM, "kmalloc failed\n");\r\nrc = -ENOMEM;\r\ngoto test_nvram_exit;\r\n}\r\nrc = bnx2x_nvram_read32(bp, 0, &magic, sizeof(magic));\r\nif (rc) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"magic value read (rc %d)\n", rc);\r\ngoto test_nvram_exit;\r\n}\r\nif (magic != 0x669955aa) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"wrong magic value (0x%08x)\n", magic);\r\nrc = -ENODEV;\r\ngoto test_nvram_exit;\r\n}\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM, "Port 0 CRC test-set\n");\r\nrc = bnx2x_test_nvram_tbl(bp, nvram_tbl, buf);\r\nif (rc)\r\ngoto test_nvram_exit;\r\nif (!CHIP_IS_E1x(bp) && !CHIP_IS_57811xx(bp)) {\r\nu32 hide = SHMEM_RD(bp, dev_info.shared_hw_config.config2) &\r\nSHARED_HW_CFG_HIDE_PORT1;\r\nif (!hide) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"Port 1 CRC test-set\n");\r\nrc = bnx2x_test_nvram_tbl(bp, nvram_tbl2, buf);\r\nif (rc)\r\ngoto test_nvram_exit;\r\n}\r\n}\r\nrc = bnx2x_test_nvram_dirs(bp, buf);\r\ntest_nvram_exit:\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_test_intr(struct bnx2x *bp)\r\n{\r\nstruct bnx2x_queue_state_params params = {NULL};\r\nif (!netif_running(bp->dev)) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"cannot access eeprom when the interface is down\n");\r\nreturn -ENODEV;\r\n}\r\nparams.q_obj = &bp->sp_objs->q_obj;\r\nparams.cmd = BNX2X_Q_CMD_EMPTY;\r\n__set_bit(RAMROD_COMP_WAIT, &params.ramrod_flags);\r\nreturn bnx2x_queue_state_change(bp, &params);\r\n}\r\nstatic void bnx2x_self_test(struct net_device *dev,\r\nstruct ethtool_test *etest, u64 *buf)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nu8 is_serdes, link_up;\r\nint rc, cnt = 0;\r\nif (pci_num_vf(bp->pdev)) {\r\nDP(BNX2X_MSG_IOV,\r\n"VFs are enabled, can not perform self test\n");\r\nreturn;\r\n}\r\nif (bp->recovery_state != BNX2X_RECOVERY_DONE) {\r\nnetdev_err(bp->dev,\r\n"Handling parity error recovery. Try again later\n");\r\netest->flags |= ETH_TEST_FL_FAILED;\r\nreturn;\r\n}\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Self-test command parameters: offline = %d, external_lb = %d\n",\r\n(etest->flags & ETH_TEST_FL_OFFLINE),\r\n(etest->flags & ETH_TEST_FL_EXTERNAL_LB)>>2);\r\nmemset(buf, 0, sizeof(u64) * BNX2X_NUM_TESTS(bp));\r\nif (bnx2x_test_nvram(bp) != 0) {\r\nif (!IS_MF(bp))\r\nbuf[4] = 1;\r\nelse\r\nbuf[0] = 1;\r\netest->flags |= ETH_TEST_FL_FAILED;\r\n}\r\nif (!netif_running(dev)) {\r\nDP(BNX2X_MSG_ETHTOOL, "Interface is down\n");\r\nreturn;\r\n}\r\nis_serdes = (bp->link_vars.link_status & LINK_STATUS_SERDES_LINK) > 0;\r\nlink_up = bp->link_vars.link_up;\r\nif ((etest->flags & ETH_TEST_FL_OFFLINE) && !IS_MF(bp)) {\r\nint port = BP_PORT(bp);\r\nu32 val;\r\nval = REG_RD(bp, NIG_REG_EGRESS_UMP0_IN_EN + port*4);\r\nREG_WR(bp, NIG_REG_EGRESS_UMP0_IN_EN + port*4, 0);\r\nbnx2x_nic_unload(bp, UNLOAD_NORMAL, false);\r\nrc = bnx2x_nic_load(bp, LOAD_DIAG);\r\nif (rc) {\r\netest->flags |= ETH_TEST_FL_FAILED;\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Can't perform self-test, nic_load (for offline) failed\n");\r\nreturn;\r\n}\r\nbnx2x_wait_for_link(bp, 1, is_serdes);\r\nif (bnx2x_test_registers(bp) != 0) {\r\nbuf[0] = 1;\r\netest->flags |= ETH_TEST_FL_FAILED;\r\n}\r\nif (bnx2x_test_memory(bp) != 0) {\r\nbuf[1] = 1;\r\netest->flags |= ETH_TEST_FL_FAILED;\r\n}\r\nbuf[2] = bnx2x_test_loopback(bp);\r\nif (buf[2] != 0)\r\netest->flags |= ETH_TEST_FL_FAILED;\r\nif (etest->flags & ETH_TEST_FL_EXTERNAL_LB) {\r\nbuf[3] = bnx2x_test_ext_loopback(bp);\r\nif (buf[3] != 0)\r\netest->flags |= ETH_TEST_FL_FAILED;\r\netest->flags |= ETH_TEST_FL_EXTERNAL_LB_DONE;\r\n}\r\nbnx2x_nic_unload(bp, UNLOAD_NORMAL, false);\r\nREG_WR(bp, NIG_REG_EGRESS_UMP0_IN_EN + port*4, val);\r\nrc = bnx2x_nic_load(bp, LOAD_NORMAL);\r\nif (rc) {\r\netest->flags |= ETH_TEST_FL_FAILED;\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Can't perform self-test, nic_load (for online) failed\n");\r\nreturn;\r\n}\r\nbnx2x_wait_for_link(bp, link_up, is_serdes);\r\n}\r\nif (bnx2x_test_intr(bp) != 0) {\r\nif (!IS_MF(bp))\r\nbuf[5] = 1;\r\nelse\r\nbuf[1] = 1;\r\netest->flags |= ETH_TEST_FL_FAILED;\r\n}\r\nif (link_up) {\r\ncnt = 100;\r\nwhile (bnx2x_link_test(bp, is_serdes) && --cnt)\r\nmsleep(20);\r\n}\r\nif (!cnt) {\r\nif (!IS_MF(bp))\r\nbuf[6] = 1;\r\nelse\r\nbuf[2] = 1;\r\netest->flags |= ETH_TEST_FL_FAILED;\r\n}\r\n}\r\nstatic int bnx2x_num_stat_queues(struct bnx2x *bp)\r\n{\r\nreturn BNX2X_NUM_ETH_QUEUES(bp);\r\n}\r\nstatic int bnx2x_get_sset_count(struct net_device *dev, int stringset)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nint i, num_strings = 0;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nif (is_multi(bp)) {\r\nnum_strings = bnx2x_num_stat_queues(bp) *\r\nBNX2X_NUM_Q_STATS;\r\n} else\r\nnum_strings = 0;\r\nif (HIDE_PORT_STAT(bp)) {\r\nfor (i = 0; i < BNX2X_NUM_STATS; i++)\r\nif (!IS_PORT_STAT(i))\r\nnum_strings++;\r\n} else\r\nnum_strings += BNX2X_NUM_STATS;\r\nreturn num_strings;\r\ncase ETH_SS_TEST:\r\nreturn BNX2X_NUM_TESTS(bp);\r\ncase ETH_SS_PRIV_FLAGS:\r\nreturn BNX2X_PRI_FLAG_LEN;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic u32 bnx2x_get_private_flags(struct net_device *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nu32 flags = 0;\r\nflags |= (!(bp->flags & NO_ISCSI_FLAG) ? 1 : 0) << BNX2X_PRI_FLAG_ISCSI;\r\nflags |= (!(bp->flags & NO_FCOE_FLAG) ? 1 : 0) << BNX2X_PRI_FLAG_FCOE;\r\nflags |= (!!IS_MF_STORAGE_ONLY(bp)) << BNX2X_PRI_FLAG_STORAGE;\r\nreturn flags;\r\n}\r\nstatic void bnx2x_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nint i, j, k, start;\r\nchar queue_name[MAX_QUEUE_NAME_LEN+1];\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nk = 0;\r\nif (is_multi(bp)) {\r\nfor_each_eth_queue(bp, i) {\r\nmemset(queue_name, 0, sizeof(queue_name));\r\nsnprintf(queue_name, sizeof(queue_name),\r\n"%d", i);\r\nfor (j = 0; j < BNX2X_NUM_Q_STATS; j++)\r\nsnprintf(buf + (k + j)*ETH_GSTRING_LEN,\r\nETH_GSTRING_LEN,\r\nbnx2x_q_stats_arr[j].string,\r\nqueue_name);\r\nk += BNX2X_NUM_Q_STATS;\r\n}\r\n}\r\nfor (i = 0, j = 0; i < BNX2X_NUM_STATS; i++) {\r\nif (HIDE_PORT_STAT(bp) && IS_PORT_STAT(i))\r\ncontinue;\r\nstrcpy(buf + (k + j)*ETH_GSTRING_LEN,\r\nbnx2x_stats_arr[i].string);\r\nj++;\r\n}\r\nbreak;\r\ncase ETH_SS_TEST:\r\nif (!IS_MF(bp))\r\nstart = 0;\r\nelse\r\nstart = 4;\r\nmemcpy(buf, bnx2x_tests_str_arr + start,\r\nETH_GSTRING_LEN * BNX2X_NUM_TESTS(bp));\r\nbreak;\r\ncase ETH_SS_PRIV_FLAGS:\r\nmemcpy(buf, bnx2x_private_arr,\r\nETH_GSTRING_LEN * BNX2X_PRI_FLAG_LEN);\r\nbreak;\r\n}\r\n}\r\nstatic void bnx2x_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 *buf)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nu32 *hw_stats, *offset;\r\nint i, j, k = 0;\r\nif (is_multi(bp)) {\r\nfor_each_eth_queue(bp, i) {\r\nhw_stats = (u32 *)&bp->fp_stats[i].eth_q_stats;\r\nfor (j = 0; j < BNX2X_NUM_Q_STATS; j++) {\r\nif (bnx2x_q_stats_arr[j].size == 0) {\r\nbuf[k + j] = 0;\r\ncontinue;\r\n}\r\noffset = (hw_stats +\r\nbnx2x_q_stats_arr[j].offset);\r\nif (bnx2x_q_stats_arr[j].size == 4) {\r\nbuf[k + j] = (u64) *offset;\r\ncontinue;\r\n}\r\nbuf[k + j] = HILO_U64(*offset, *(offset + 1));\r\n}\r\nk += BNX2X_NUM_Q_STATS;\r\n}\r\n}\r\nhw_stats = (u32 *)&bp->eth_stats;\r\nfor (i = 0, j = 0; i < BNX2X_NUM_STATS; i++) {\r\nif (HIDE_PORT_STAT(bp) && IS_PORT_STAT(i))\r\ncontinue;\r\nif (bnx2x_stats_arr[i].size == 0) {\r\nbuf[k + j] = 0;\r\nj++;\r\ncontinue;\r\n}\r\noffset = (hw_stats + bnx2x_stats_arr[i].offset);\r\nif (bnx2x_stats_arr[i].size == 4) {\r\nbuf[k + j] = (u64) *offset;\r\nj++;\r\ncontinue;\r\n}\r\nbuf[k + j] = HILO_U64(*offset, *(offset + 1));\r\nj++;\r\n}\r\n}\r\nstatic int bnx2x_set_phys_id(struct net_device *dev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nif (!bnx2x_is_nvm_accessible(bp)) {\r\nDP(BNX2X_MSG_ETHTOOL | BNX2X_MSG_NVM,\r\n"cannot access eeprom when the interface is down\n");\r\nreturn -EAGAIN;\r\n}\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nreturn 1;\r\ncase ETHTOOL_ID_ON:\r\nbnx2x_acquire_phy_lock(bp);\r\nbnx2x_set_led(&bp->link_params, &bp->link_vars,\r\nLED_MODE_ON, SPEED_1000);\r\nbnx2x_release_phy_lock(bp);\r\nbreak;\r\ncase ETHTOOL_ID_OFF:\r\nbnx2x_acquire_phy_lock(bp);\r\nbnx2x_set_led(&bp->link_params, &bp->link_vars,\r\nLED_MODE_FRONT_PANEL_OFF, 0);\r\nbnx2x_release_phy_lock(bp);\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\nbnx2x_acquire_phy_lock(bp);\r\nbnx2x_set_led(&bp->link_params, &bp->link_vars,\r\nLED_MODE_OPER,\r\nbp->link_vars.line_speed);\r\nbnx2x_release_phy_lock(bp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_get_rss_flags(struct bnx2x *bp, struct ethtool_rxnfc *info)\r\n{\r\nswitch (info->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncase TCP_V6_FLOW:\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST |\r\nRXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nbreak;\r\ncase UDP_V4_FLOW:\r\nif (bp->rss_conf_obj.udp_rss_v4)\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST |\r\nRXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nelse\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ncase UDP_V6_FLOW:\r\nif (bp->rss_conf_obj.udp_rss_v6)\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST |\r\nRXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nelse\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ncase IPV4_FLOW:\r\ncase IPV6_FLOW:\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ndefault:\r\ninfo->data = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,\r\nu32 *rules __always_unused)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nswitch (info->cmd) {\r\ncase ETHTOOL_GRXRINGS:\r\ninfo->data = BNX2X_NUM_ETH_QUEUES(bp);\r\nreturn 0;\r\ncase ETHTOOL_GRXFH:\r\nreturn bnx2x_get_rss_flags(bp, info);\r\ndefault:\r\nDP(BNX2X_MSG_ETHTOOL, "Command parameters not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int bnx2x_set_rss_flags(struct bnx2x *bp, struct ethtool_rxnfc *info)\r\n{\r\nint udp_rss_requested;\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Set rss flags command parameters: flow type = %d, data = %llu\n",\r\ninfo->flow_type, info->data);\r\nswitch (info->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncase TCP_V6_FLOW:\r\nif (info->data ^ (RXH_IP_SRC | RXH_IP_DST |\r\nRXH_L4_B_0_1 | RXH_L4_B_2_3)) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Command parameters not supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ncase UDP_V4_FLOW:\r\ncase UDP_V6_FLOW:\r\nif (info->data == (RXH_IP_SRC | RXH_IP_DST |\r\nRXH_L4_B_0_1 | RXH_L4_B_2_3))\r\nudp_rss_requested = 1;\r\nelse if (info->data == (RXH_IP_SRC | RXH_IP_DST))\r\nudp_rss_requested = 0;\r\nelse\r\nreturn -EINVAL;\r\nif (CHIP_IS_E1x(bp) && udp_rss_requested) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"57710, 57711 boards don't support RSS according to UDP 4-tuple\n");\r\nreturn -EINVAL;\r\n}\r\nif ((info->flow_type == UDP_V4_FLOW) &&\r\n(bp->rss_conf_obj.udp_rss_v4 != udp_rss_requested)) {\r\nbp->rss_conf_obj.udp_rss_v4 = udp_rss_requested;\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"rss re-configured, UDP 4-tupple %s\n",\r\nudp_rss_requested ? "enabled" : "disabled");\r\nreturn bnx2x_rss(bp, &bp->rss_conf_obj, false, true);\r\n} else if ((info->flow_type == UDP_V6_FLOW) &&\r\n(bp->rss_conf_obj.udp_rss_v6 != udp_rss_requested)) {\r\nbp->rss_conf_obj.udp_rss_v6 = udp_rss_requested;\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"rss re-configured, UDP 4-tupple %s\n",\r\nudp_rss_requested ? "enabled" : "disabled");\r\nreturn bnx2x_rss(bp, &bp->rss_conf_obj, false, true);\r\n}\r\nreturn 0;\r\ncase IPV4_FLOW:\r\ncase IPV6_FLOW:\r\nif (info->data ^ (RXH_IP_SRC | RXH_IP_DST)) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Command parameters not supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ncase SCTP_V4_FLOW:\r\ncase AH_ESP_V4_FLOW:\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\ncase SCTP_V6_FLOW:\r\ncase AH_ESP_V6_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V6_FLOW:\r\ncase IP_USER_FLOW:\r\ncase ETHER_FLOW:\r\nif (info->data) {\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"Command parameters not supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int bnx2x_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nswitch (info->cmd) {\r\ncase ETHTOOL_SRXFH:\r\nreturn bnx2x_set_rss_flags(bp, info);\r\ndefault:\r\nDP(BNX2X_MSG_ETHTOOL, "Command parameters not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic u32 bnx2x_get_rxfh_indir_size(struct net_device *dev)\r\n{\r\nreturn T_ETH_INDIRECTION_TABLE_SIZE;\r\n}\r\nstatic int bnx2x_get_rxfh(struct net_device *dev, u32 *indir, u8 *key,\r\nu8 *hfunc)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nu8 ind_table[T_ETH_INDIRECTION_TABLE_SIZE] = {0};\r\nsize_t i;\r\nif (hfunc)\r\n*hfunc = ETH_RSS_HASH_TOP;\r\nif (!indir)\r\nreturn 0;\r\nbnx2x_get_rss_ind_table(&bp->rss_conf_obj, ind_table);\r\nfor (i = 0; i < T_ETH_INDIRECTION_TABLE_SIZE; i++)\r\nindir[i] = ind_table[i] - bp->fp->cl_id;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_set_rxfh(struct net_device *dev, const u32 *indir,\r\nconst u8 *key, const u8 hfunc)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nsize_t i;\r\nif (key ||\r\n(hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))\r\nreturn -EOPNOTSUPP;\r\nif (!indir)\r\nreturn 0;\r\nfor (i = 0; i < T_ETH_INDIRECTION_TABLE_SIZE; i++) {\r\nbp->rss_conf_obj.ind_table[i] = indir[i] + bp->fp->cl_id;\r\n}\r\nreturn bnx2x_config_rss_eth(bp, false);\r\n}\r\nstatic void bnx2x_get_channels(struct net_device *dev,\r\nstruct ethtool_channels *channels)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nchannels->max_combined = BNX2X_MAX_RSS_COUNT(bp);\r\nchannels->combined_count = BNX2X_NUM_ETH_QUEUES(bp);\r\n}\r\nstatic void bnx2x_change_num_queues(struct bnx2x *bp, int num_rss)\r\n{\r\nbnx2x_disable_msi(bp);\r\nbp->num_ethernet_queues = num_rss;\r\nbp->num_queues = bp->num_ethernet_queues + bp->num_cnic_queues;\r\nBNX2X_DEV_INFO("set number of queues to %d\n", bp->num_queues);\r\nbnx2x_set_int_mode(bp);\r\n}\r\nstatic int bnx2x_set_channels(struct net_device *dev,\r\nstruct ethtool_channels *channels)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nDP(BNX2X_MSG_ETHTOOL,\r\n"set-channels command parameters: rx = %d, tx = %d, other = %d, combined = %d\n",\r\nchannels->rx_count, channels->tx_count, channels->other_count,\r\nchannels->combined_count);\r\nif (pci_num_vf(bp->pdev)) {\r\nDP(BNX2X_MSG_IOV, "VFs are enabled, can not set channels\n");\r\nreturn -EPERM;\r\n}\r\nif (channels->rx_count || channels->tx_count || channels->other_count\r\n|| (channels->combined_count == 0) ||\r\n(channels->combined_count > BNX2X_MAX_RSS_COUNT(bp))) {\r\nDP(BNX2X_MSG_ETHTOOL, "command parameters not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (channels->combined_count == BNX2X_NUM_ETH_QUEUES(bp)) {\r\nDP(BNX2X_MSG_ETHTOOL, "No change in active parameters\n");\r\nreturn 0;\r\n}\r\nif (unlikely(!netif_running(dev))) {\r\nbnx2x_change_num_queues(bp, channels->combined_count);\r\nreturn 0;\r\n}\r\nbnx2x_nic_unload(bp, UNLOAD_NORMAL, true);\r\nbnx2x_change_num_queues(bp, channels->combined_count);\r\nreturn bnx2x_nic_load(bp, LOAD_NORMAL);\r\n}\r\nstatic int bnx2x_get_ts_info(struct net_device *dev,\r\nstruct ethtool_ts_info *info)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nif (bp->flags & PTP_SUPPORTED) {\r\ninfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\r\nSOF_TIMESTAMPING_RX_SOFTWARE |\r\nSOF_TIMESTAMPING_SOFTWARE |\r\nSOF_TIMESTAMPING_TX_HARDWARE |\r\nSOF_TIMESTAMPING_RX_HARDWARE |\r\nSOF_TIMESTAMPING_RAW_HARDWARE;\r\nif (bp->ptp_clock)\r\ninfo->phc_index = ptp_clock_index(bp->ptp_clock);\r\nelse\r\ninfo->phc_index = -1;\r\ninfo->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_EVENT);\r\ninfo->tx_types = (1 << HWTSTAMP_TX_OFF)|(1 << HWTSTAMP_TX_ON);\r\nreturn 0;\r\n}\r\nreturn ethtool_op_get_ts_info(dev, info);\r\n}\r\nvoid bnx2x_set_ethtool_ops(struct bnx2x *bp, struct net_device *netdev)\r\n{\r\nnetdev->ethtool_ops = (IS_PF(bp)) ?\r\n&bnx2x_ethtool_ops : &bnx2x_vf_ethtool_ops;\r\n}
