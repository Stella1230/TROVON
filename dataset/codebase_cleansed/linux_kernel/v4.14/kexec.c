static int copy_user_segment_list(struct kimage *image,\r\nunsigned long nr_segments,\r\nstruct kexec_segment __user *segments)\r\n{\r\nint ret;\r\nsize_t segment_bytes;\r\nimage->nr_segments = nr_segments;\r\nsegment_bytes = nr_segments * sizeof(*segments);\r\nret = copy_from_user(image->segment, segments, segment_bytes);\r\nif (ret)\r\nret = -EFAULT;\r\nreturn ret;\r\n}\r\nstatic int kimage_alloc_init(struct kimage **rimage, unsigned long entry,\r\nunsigned long nr_segments,\r\nstruct kexec_segment __user *segments,\r\nunsigned long flags)\r\n{\r\nint ret;\r\nstruct kimage *image;\r\nbool kexec_on_panic = flags & KEXEC_ON_CRASH;\r\nif (kexec_on_panic) {\r\nif ((entry < phys_to_boot_phys(crashk_res.start)) ||\r\n(entry > phys_to_boot_phys(crashk_res.end)))\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nimage = do_kimage_alloc_init();\r\nif (!image)\r\nreturn -ENOMEM;\r\nimage->start = entry;\r\nret = copy_user_segment_list(image, nr_segments, segments);\r\nif (ret)\r\ngoto out_free_image;\r\nif (kexec_on_panic) {\r\nimage->control_page = crashk_res.start;\r\nimage->type = KEXEC_TYPE_CRASH;\r\n}\r\nret = sanity_check_segment_list(image);\r\nif (ret)\r\ngoto out_free_image;\r\nret = -ENOMEM;\r\nimage->control_code_page = kimage_alloc_control_pages(image,\r\nget_order(KEXEC_CONTROL_PAGE_SIZE));\r\nif (!image->control_code_page) {\r\npr_err("Could not allocate control_code_buffer\n");\r\ngoto out_free_image;\r\n}\r\nif (!kexec_on_panic) {\r\nimage->swap_page = kimage_alloc_control_pages(image, 0);\r\nif (!image->swap_page) {\r\npr_err("Could not allocate swap buffer\n");\r\ngoto out_free_control_pages;\r\n}\r\n}\r\n*rimage = image;\r\nreturn 0;\r\nout_free_control_pages:\r\nkimage_free_page_list(&image->control_pages);\r\nout_free_image:\r\nkfree(image);\r\nreturn ret;\r\n}\r\nstatic int do_kexec_load(unsigned long entry, unsigned long nr_segments,\r\nstruct kexec_segment __user *segments, unsigned long flags)\r\n{\r\nstruct kimage **dest_image, *image;\r\nunsigned long i;\r\nint ret;\r\nif (flags & KEXEC_ON_CRASH) {\r\ndest_image = &kexec_crash_image;\r\nif (kexec_crash_image)\r\narch_kexec_unprotect_crashkres();\r\n} else {\r\ndest_image = &kexec_image;\r\n}\r\nif (nr_segments == 0) {\r\nkimage_free(xchg(dest_image, NULL));\r\nreturn 0;\r\n}\r\nif (flags & KEXEC_ON_CRASH) {\r\nkimage_free(xchg(&kexec_crash_image, NULL));\r\n}\r\nret = kimage_alloc_init(&image, entry, nr_segments, segments, flags);\r\nif (ret)\r\nreturn ret;\r\nif (flags & KEXEC_PRESERVE_CONTEXT)\r\nimage->preserve_context = 1;\r\nret = machine_kexec_prepare(image);\r\nif (ret)\r\ngoto out;\r\nret = kimage_crash_copy_vmcoreinfo(image);\r\nif (ret)\r\ngoto out;\r\nfor (i = 0; i < nr_segments; i++) {\r\nret = kimage_load_segment(image, &image->segment[i]);\r\nif (ret)\r\ngoto out;\r\n}\r\nkimage_terminate(image);\r\nimage = xchg(dest_image, image);\r\nout:\r\nif ((flags & KEXEC_ON_CRASH) && kexec_crash_image)\r\narch_kexec_protect_crashkres();\r\nkimage_free(image);\r\nreturn ret;\r\n}
