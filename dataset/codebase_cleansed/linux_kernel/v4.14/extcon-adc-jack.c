static void adc_jack_handler(struct work_struct *work)\r\n{\r\nstruct adc_jack_data *data = container_of(to_delayed_work(work),\r\nstruct adc_jack_data,\r\nhandler);\r\nstruct adc_jack_cond *def;\r\nint ret, adc_val;\r\nint i;\r\nret = iio_read_channel_raw(data->chan, &adc_val);\r\nif (ret < 0) {\r\ndev_err(data->dev, "read channel() error: %d\n", ret);\r\nreturn;\r\n}\r\nfor (i = 0; i < data->num_conditions; i++) {\r\ndef = &data->adc_conditions[i];\r\nif (def->min_adc <= adc_val && def->max_adc >= adc_val) {\r\nextcon_set_state_sync(data->edev, def->id, true);\r\nreturn;\r\n}\r\n}\r\nfor (i = 0; i < data->num_conditions; i++) {\r\ndef = &data->adc_conditions[i];\r\nextcon_set_state_sync(data->edev, def->id, false);\r\n}\r\n}\r\nstatic irqreturn_t adc_jack_irq_thread(int irq, void *_data)\r\n{\r\nstruct adc_jack_data *data = _data;\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&data->handler, data->handling_delay);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int adc_jack_probe(struct platform_device *pdev)\r\n{\r\nstruct adc_jack_data *data;\r\nstruct adc_jack_pdata *pdata = dev_get_platdata(&pdev->dev);\r\nint i, err = 0;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nif (!pdata->cable_names) {\r\ndev_err(&pdev->dev, "error: cable_names not defined.\n");\r\nreturn -EINVAL;\r\n}\r\ndata->dev = &pdev->dev;\r\ndata->edev = devm_extcon_dev_allocate(&pdev->dev, pdata->cable_names);\r\nif (IS_ERR(data->edev)) {\r\ndev_err(&pdev->dev, "failed to allocate extcon device\n");\r\nreturn -ENOMEM;\r\n}\r\nif (!pdata->adc_conditions) {\r\ndev_err(&pdev->dev, "error: adc_conditions not defined.\n");\r\nreturn -EINVAL;\r\n}\r\ndata->adc_conditions = pdata->adc_conditions;\r\nfor (i = 0; data->adc_conditions[i].id != EXTCON_NONE; i++);\r\ndata->num_conditions = i;\r\ndata->chan = iio_channel_get(&pdev->dev, pdata->consumer_channel);\r\nif (IS_ERR(data->chan))\r\nreturn PTR_ERR(data->chan);\r\ndata->handling_delay = msecs_to_jiffies(pdata->handling_delay_ms);\r\ndata->wakeup_source = pdata->wakeup_source;\r\nINIT_DEFERRABLE_WORK(&data->handler, adc_jack_handler);\r\nplatform_set_drvdata(pdev, data);\r\nerr = devm_extcon_dev_register(&pdev->dev, data->edev);\r\nif (err)\r\nreturn err;\r\ndata->irq = platform_get_irq(pdev, 0);\r\nif (!data->irq) {\r\ndev_err(&pdev->dev, "platform_get_irq failed\n");\r\nreturn -ENODEV;\r\n}\r\nerr = request_any_context_irq(data->irq, adc_jack_irq_thread,\r\npdata->irq_flags, pdata->name, data);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "error: irq %d\n", data->irq);\r\nreturn err;\r\n}\r\nif (data->wakeup_source)\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nadc_jack_handler(&data->handler.work);\r\nreturn 0;\r\n}\r\nstatic int adc_jack_remove(struct platform_device *pdev)\r\n{\r\nstruct adc_jack_data *data = platform_get_drvdata(pdev);\r\nfree_irq(data->irq, data);\r\ncancel_work_sync(&data->handler.work);\r\niio_channel_release(data->chan);\r\nreturn 0;\r\n}\r\nstatic int adc_jack_suspend(struct device *dev)\r\n{\r\nstruct adc_jack_data *data = dev_get_drvdata(dev);\r\ncancel_delayed_work_sync(&data->handler);\r\nif (device_may_wakeup(data->dev))\r\nenable_irq_wake(data->irq);\r\nreturn 0;\r\n}\r\nstatic int adc_jack_resume(struct device *dev)\r\n{\r\nstruct adc_jack_data *data = dev_get_drvdata(dev);\r\nif (device_may_wakeup(data->dev))\r\ndisable_irq_wake(data->irq);\r\nreturn 0;\r\n}
