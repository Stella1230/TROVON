int efx_mcdi_init(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_iface *mcdi;\r\nbool already_attached;\r\nint rc = -ENOMEM;\r\nefx->mcdi = kzalloc(sizeof(*efx->mcdi), GFP_KERNEL);\r\nif (!efx->mcdi)\r\ngoto fail;\r\nmcdi = efx_mcdi(efx);\r\nmcdi->efx = efx;\r\n#ifdef CONFIG_SFC_MCDI_LOGGING\r\nmcdi->logging_buffer = (char *)__get_free_page(GFP_KERNEL);\r\nif (!mcdi->logging_buffer)\r\ngoto fail1;\r\nmcdi->logging_enabled = mcdi_logging_default;\r\n#endif\r\ninit_waitqueue_head(&mcdi->wq);\r\ninit_waitqueue_head(&mcdi->proxy_rx_wq);\r\nspin_lock_init(&mcdi->iface_lock);\r\nmcdi->state = MCDI_STATE_QUIESCENT;\r\nmcdi->mode = MCDI_MODE_POLL;\r\nspin_lock_init(&mcdi->async_lock);\r\nINIT_LIST_HEAD(&mcdi->async_list);\r\nsetup_timer(&mcdi->async_timer, efx_mcdi_timeout_async,\r\n(unsigned long)mcdi);\r\n(void) efx_mcdi_poll_reboot(efx);\r\nmcdi->new_epoch = true;\r\nrc = efx_mcdi_handle_assertion(efx);\r\nif (rc)\r\ngoto fail2;\r\nrc = efx_mcdi_drv_attach(efx, true, &already_attached);\r\nif (rc) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Unable to register driver with MCPU\n");\r\ngoto fail2;\r\n}\r\nif (already_attached)\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Host already registered with MCPU\n");\r\nif (efx->mcdi->fn_flags &\r\n(1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_PRIMARY))\r\nefx->primary = efx;\r\nreturn 0;\r\nfail2:\r\n#ifdef CONFIG_SFC_MCDI_LOGGING\r\nfree_page((unsigned long)mcdi->logging_buffer);\r\nfail1:\r\n#endif\r\nkfree(efx->mcdi);\r\nefx->mcdi = NULL;\r\nfail:\r\nreturn rc;\r\n}\r\nvoid efx_mcdi_detach(struct efx_nic *efx)\r\n{\r\nif (!efx->mcdi)\r\nreturn;\r\nBUG_ON(efx->mcdi->iface.state != MCDI_STATE_QUIESCENT);\r\nefx_mcdi_drv_attach(efx, false, NULL);\r\n}\r\nvoid efx_mcdi_fini(struct efx_nic *efx)\r\n{\r\nif (!efx->mcdi)\r\nreturn;\r\n#ifdef CONFIG_SFC_MCDI_LOGGING\r\nfree_page((unsigned long)efx->mcdi->iface.logging_buffer);\r\n#endif\r\nkfree(efx->mcdi);\r\n}\r\nstatic void efx_mcdi_send_request(struct efx_nic *efx, unsigned cmd,\r\nconst efx_dword_t *inbuf, size_t inlen)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\n#ifdef CONFIG_SFC_MCDI_LOGGING\r\nchar *buf = mcdi->logging_buffer;\r\n#endif\r\nefx_dword_t hdr[2];\r\nsize_t hdr_len;\r\nu32 xflags, seqno;\r\nBUG_ON(mcdi->state == MCDI_STATE_QUIESCENT);\r\nspin_lock_bh(&mcdi->iface_lock);\r\n++mcdi->seqno;\r\nspin_unlock_bh(&mcdi->iface_lock);\r\nseqno = mcdi->seqno & SEQ_MASK;\r\nxflags = 0;\r\nif (mcdi->mode == MCDI_MODE_EVENTS)\r\nxflags |= MCDI_HEADER_XFLAGS_EVREQ;\r\nif (efx->type->mcdi_max_ver == 1) {\r\nEFX_POPULATE_DWORD_7(hdr[0],\r\nMCDI_HEADER_RESPONSE, 0,\r\nMCDI_HEADER_RESYNC, 1,\r\nMCDI_HEADER_CODE, cmd,\r\nMCDI_HEADER_DATALEN, inlen,\r\nMCDI_HEADER_SEQ, seqno,\r\nMCDI_HEADER_XFLAGS, xflags,\r\nMCDI_HEADER_NOT_EPOCH, !mcdi->new_epoch);\r\nhdr_len = 4;\r\n} else {\r\nBUG_ON(inlen > MCDI_CTL_SDU_LEN_MAX_V2);\r\nEFX_POPULATE_DWORD_7(hdr[0],\r\nMCDI_HEADER_RESPONSE, 0,\r\nMCDI_HEADER_RESYNC, 1,\r\nMCDI_HEADER_CODE, MC_CMD_V2_EXTN,\r\nMCDI_HEADER_DATALEN, 0,\r\nMCDI_HEADER_SEQ, seqno,\r\nMCDI_HEADER_XFLAGS, xflags,\r\nMCDI_HEADER_NOT_EPOCH, !mcdi->new_epoch);\r\nEFX_POPULATE_DWORD_2(hdr[1],\r\nMC_CMD_V2_EXTN_IN_EXTENDED_CMD, cmd,\r\nMC_CMD_V2_EXTN_IN_ACTUAL_LEN, inlen);\r\nhdr_len = 8;\r\n}\r\n#ifdef CONFIG_SFC_MCDI_LOGGING\r\nif (mcdi->logging_enabled && !WARN_ON_ONCE(!buf)) {\r\nint bytes = 0;\r\nint i;\r\nWARN_ON_ONCE(hdr_len % 4);\r\nWARN_ON_ONCE(inlen % 4);\r\nfor (i = 0; i < hdr_len / 4 && bytes < PAGE_SIZE; i++)\r\nbytes += snprintf(buf + bytes, PAGE_SIZE - bytes,\r\n" %08x", le32_to_cpu(hdr[i].u32[0]));\r\nfor (i = 0; i < inlen / 4 && bytes < PAGE_SIZE; i++)\r\nbytes += snprintf(buf + bytes, PAGE_SIZE - bytes,\r\n" %08x", le32_to_cpu(inbuf[i].u32[0]));\r\nnetif_info(efx, hw, efx->net_dev, "MCDI RPC REQ:%s\n", buf);\r\n}\r\n#endif\r\nefx->type->mcdi_request(efx, hdr, hdr_len, inbuf, inlen);\r\nmcdi->new_epoch = false;\r\n}\r\nstatic int efx_mcdi_errno(unsigned int mcdi_err)\r\n{\r\nswitch (mcdi_err) {\r\ncase 0:\r\nreturn 0;\r\n#define TRANSLATE_ERROR(name) \\r\ncase MC_CMD_ERR_ ## name: \\r\nreturn -name;\r\nTRANSLATE_ERROR(EPERM);\r\nTRANSLATE_ERROR(ENOENT);\r\nTRANSLATE_ERROR(EINTR);\r\nTRANSLATE_ERROR(EAGAIN);\r\nTRANSLATE_ERROR(EACCES);\r\nTRANSLATE_ERROR(EBUSY);\r\nTRANSLATE_ERROR(EINVAL);\r\nTRANSLATE_ERROR(EDEADLK);\r\nTRANSLATE_ERROR(ENOSYS);\r\nTRANSLATE_ERROR(ETIME);\r\nTRANSLATE_ERROR(EALREADY);\r\nTRANSLATE_ERROR(ENOSPC);\r\n#undef TRANSLATE_ERROR\r\ncase MC_CMD_ERR_ENOTSUP:\r\nreturn -EOPNOTSUPP;\r\ncase MC_CMD_ERR_ALLOC_FAIL:\r\nreturn -ENOBUFS;\r\ncase MC_CMD_ERR_MAC_EXIST:\r\nreturn -EADDRINUSE;\r\ndefault:\r\nreturn -EPROTO;\r\n}\r\n}\r\nstatic void efx_mcdi_read_response_header(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nunsigned int respseq, respcmd, error;\r\n#ifdef CONFIG_SFC_MCDI_LOGGING\r\nchar *buf = mcdi->logging_buffer;\r\n#endif\r\nefx_dword_t hdr;\r\nefx->type->mcdi_read_response(efx, &hdr, 0, 4);\r\nrespseq = EFX_DWORD_FIELD(hdr, MCDI_HEADER_SEQ);\r\nrespcmd = EFX_DWORD_FIELD(hdr, MCDI_HEADER_CODE);\r\nerror = EFX_DWORD_FIELD(hdr, MCDI_HEADER_ERROR);\r\nif (respcmd != MC_CMD_V2_EXTN) {\r\nmcdi->resp_hdr_len = 4;\r\nmcdi->resp_data_len = EFX_DWORD_FIELD(hdr, MCDI_HEADER_DATALEN);\r\n} else {\r\nefx->type->mcdi_read_response(efx, &hdr, 4, 4);\r\nmcdi->resp_hdr_len = 8;\r\nmcdi->resp_data_len =\r\nEFX_DWORD_FIELD(hdr, MC_CMD_V2_EXTN_IN_ACTUAL_LEN);\r\n}\r\n#ifdef CONFIG_SFC_MCDI_LOGGING\r\nif (mcdi->logging_enabled && !WARN_ON_ONCE(!buf)) {\r\nsize_t hdr_len, data_len;\r\nint bytes = 0;\r\nint i;\r\nWARN_ON_ONCE(mcdi->resp_hdr_len % 4);\r\nhdr_len = mcdi->resp_hdr_len / 4;\r\ndata_len = DIV_ROUND_UP(mcdi->resp_data_len, 4);\r\nfor (i = 0; i < hdr_len && bytes < PAGE_SIZE; i++) {\r\nefx->type->mcdi_read_response(efx, &hdr, (i * 4), 4);\r\nbytes += snprintf(buf + bytes, PAGE_SIZE - bytes,\r\n" %08x", le32_to_cpu(hdr.u32[0]));\r\n}\r\nfor (i = 0; i < data_len && bytes < PAGE_SIZE; i++) {\r\nefx->type->mcdi_read_response(efx, &hdr,\r\nmcdi->resp_hdr_len + (i * 4), 4);\r\nbytes += snprintf(buf + bytes, PAGE_SIZE - bytes,\r\n" %08x", le32_to_cpu(hdr.u32[0]));\r\n}\r\nnetif_info(efx, hw, efx->net_dev, "MCDI RPC RESP:%s\n", buf);\r\n}\r\n#endif\r\nmcdi->resprc_raw = 0;\r\nif (error && mcdi->resp_data_len == 0) {\r\nnetif_err(efx, hw, efx->net_dev, "MC rebooted\n");\r\nmcdi->resprc = -EIO;\r\n} else if ((respseq ^ mcdi->seqno) & SEQ_MASK) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"MC response mismatch tx seq 0x%x rx seq 0x%x\n",\r\nrespseq, mcdi->seqno);\r\nmcdi->resprc = -EIO;\r\n} else if (error) {\r\nefx->type->mcdi_read_response(efx, &hdr, mcdi->resp_hdr_len, 4);\r\nmcdi->resprc_raw = EFX_DWORD_FIELD(hdr, EFX_DWORD_0);\r\nmcdi->resprc = efx_mcdi_errno(mcdi->resprc_raw);\r\n} else {\r\nmcdi->resprc = 0;\r\n}\r\n}\r\nstatic bool efx_mcdi_poll_once(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nrmb();\r\nif (!efx->type->mcdi_poll_response(efx))\r\nreturn false;\r\nspin_lock_bh(&mcdi->iface_lock);\r\nefx_mcdi_read_response_header(efx);\r\nspin_unlock_bh(&mcdi->iface_lock);\r\nreturn true;\r\n}\r\nstatic int efx_mcdi_poll(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nunsigned long time, finish;\r\nunsigned int spins;\r\nint rc;\r\nrc = efx_mcdi_poll_reboot(efx);\r\nif (rc) {\r\nspin_lock_bh(&mcdi->iface_lock);\r\nmcdi->resprc = rc;\r\nmcdi->resp_hdr_len = 0;\r\nmcdi->resp_data_len = 0;\r\nspin_unlock_bh(&mcdi->iface_lock);\r\nreturn 0;\r\n}\r\nspins = TICK_USEC;\r\nfinish = jiffies + MCDI_RPC_TIMEOUT;\r\nwhile (1) {\r\nif (spins != 0) {\r\n--spins;\r\nudelay(1);\r\n} else {\r\nschedule_timeout_uninterruptible(1);\r\n}\r\ntime = jiffies;\r\nif (efx_mcdi_poll_once(efx))\r\nbreak;\r\nif (time_after(time, finish))\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nint efx_mcdi_poll_reboot(struct efx_nic *efx)\r\n{\r\nif (!efx->mcdi)\r\nreturn 0;\r\nreturn efx->type->mcdi_poll_reboot(efx);\r\n}\r\nstatic bool efx_mcdi_acquire_async(struct efx_mcdi_iface *mcdi)\r\n{\r\nreturn cmpxchg(&mcdi->state,\r\nMCDI_STATE_QUIESCENT, MCDI_STATE_RUNNING_ASYNC) ==\r\nMCDI_STATE_QUIESCENT;\r\n}\r\nstatic void efx_mcdi_acquire_sync(struct efx_mcdi_iface *mcdi)\r\n{\r\nwait_event(mcdi->wq,\r\ncmpxchg(&mcdi->state,\r\nMCDI_STATE_QUIESCENT, MCDI_STATE_RUNNING_SYNC) ==\r\nMCDI_STATE_QUIESCENT);\r\n}\r\nstatic int efx_mcdi_await_completion(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nif (wait_event_timeout(mcdi->wq, mcdi->state == MCDI_STATE_COMPLETED,\r\nMCDI_RPC_TIMEOUT) == 0)\r\nreturn -ETIMEDOUT;\r\nif (mcdi->mode == MCDI_MODE_POLL)\r\nreturn efx_mcdi_poll(efx);\r\nreturn 0;\r\n}\r\nstatic bool efx_mcdi_complete_sync(struct efx_mcdi_iface *mcdi)\r\n{\r\nif (cmpxchg(&mcdi->state,\r\nMCDI_STATE_RUNNING_SYNC, MCDI_STATE_COMPLETED) ==\r\nMCDI_STATE_RUNNING_SYNC) {\r\nwake_up(&mcdi->wq);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void efx_mcdi_release(struct efx_mcdi_iface *mcdi)\r\n{\r\nif (mcdi->mode == MCDI_MODE_EVENTS) {\r\nstruct efx_mcdi_async_param *async;\r\nstruct efx_nic *efx = mcdi->efx;\r\nspin_lock_bh(&mcdi->async_lock);\r\nasync = list_first_entry_or_null(\r\n&mcdi->async_list, struct efx_mcdi_async_param, list);\r\nif (async) {\r\nmcdi->state = MCDI_STATE_RUNNING_ASYNC;\r\nefx_mcdi_send_request(efx, async->cmd,\r\n(const efx_dword_t *)(async + 1),\r\nasync->inlen);\r\nmod_timer(&mcdi->async_timer,\r\njiffies + MCDI_RPC_TIMEOUT);\r\n}\r\nspin_unlock_bh(&mcdi->async_lock);\r\nif (async)\r\nreturn;\r\n}\r\nmcdi->state = MCDI_STATE_QUIESCENT;\r\nwake_up(&mcdi->wq);\r\n}\r\nstatic bool efx_mcdi_complete_async(struct efx_mcdi_iface *mcdi, bool timeout)\r\n{\r\nstruct efx_nic *efx = mcdi->efx;\r\nstruct efx_mcdi_async_param *async;\r\nsize_t hdr_len, data_len, err_len;\r\nefx_dword_t *outbuf;\r\nMCDI_DECLARE_BUF_ERR(errbuf);\r\nint rc;\r\nif (cmpxchg(&mcdi->state,\r\nMCDI_STATE_RUNNING_ASYNC, MCDI_STATE_COMPLETED) !=\r\nMCDI_STATE_RUNNING_ASYNC)\r\nreturn false;\r\nspin_lock(&mcdi->iface_lock);\r\nif (timeout) {\r\n++mcdi->seqno;\r\n++mcdi->credits;\r\nrc = -ETIMEDOUT;\r\nhdr_len = 0;\r\ndata_len = 0;\r\n} else {\r\nrc = mcdi->resprc;\r\nhdr_len = mcdi->resp_hdr_len;\r\ndata_len = mcdi->resp_data_len;\r\n}\r\nspin_unlock(&mcdi->iface_lock);\r\nif (!timeout)\r\ndel_timer_sync(&mcdi->async_timer);\r\nspin_lock(&mcdi->async_lock);\r\nasync = list_first_entry(&mcdi->async_list,\r\nstruct efx_mcdi_async_param, list);\r\nlist_del(&async->list);\r\nspin_unlock(&mcdi->async_lock);\r\noutbuf = (efx_dword_t *)(async + 1);\r\nefx->type->mcdi_read_response(efx, outbuf, hdr_len,\r\nmin(async->outlen, data_len));\r\nif (!timeout && rc && !async->quiet) {\r\nerr_len = min(sizeof(errbuf), data_len);\r\nefx->type->mcdi_read_response(efx, errbuf, hdr_len,\r\nsizeof(errbuf));\r\nefx_mcdi_display_error(efx, async->cmd, async->inlen, errbuf,\r\nerr_len, rc);\r\n}\r\nif (async->complete)\r\nasync->complete(efx, async->cookie, rc, outbuf,\r\nmin(async->outlen, data_len));\r\nkfree(async);\r\nefx_mcdi_release(mcdi);\r\nreturn true;\r\n}\r\nstatic void efx_mcdi_ev_cpl(struct efx_nic *efx, unsigned int seqno,\r\nunsigned int datalen, unsigned int mcdi_err)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nbool wake = false;\r\nspin_lock(&mcdi->iface_lock);\r\nif ((seqno ^ mcdi->seqno) & SEQ_MASK) {\r\nif (mcdi->credits)\r\n--mcdi->credits;\r\nelse\r\nnetif_err(efx, hw, efx->net_dev,\r\n"MC response mismatch tx seq 0x%x rx "\r\n"seq 0x%x\n", seqno, mcdi->seqno);\r\n} else {\r\nif (efx->type->mcdi_max_ver >= 2) {\r\nefx_mcdi_read_response_header(efx);\r\n} else {\r\nmcdi->resprc = efx_mcdi_errno(mcdi_err);\r\nmcdi->resp_hdr_len = 4;\r\nmcdi->resp_data_len = datalen;\r\n}\r\nwake = true;\r\n}\r\nspin_unlock(&mcdi->iface_lock);\r\nif (wake) {\r\nif (!efx_mcdi_complete_async(mcdi, false))\r\n(void) efx_mcdi_complete_sync(mcdi);\r\n}\r\n}\r\nstatic void efx_mcdi_timeout_async(unsigned long context)\r\n{\r\nstruct efx_mcdi_iface *mcdi = (struct efx_mcdi_iface *)context;\r\nefx_mcdi_complete_async(mcdi, true);\r\n}\r\nstatic int\r\nefx_mcdi_check_supported(struct efx_nic *efx, unsigned int cmd, size_t inlen)\r\n{\r\nif (efx->type->mcdi_max_ver < 0 ||\r\n(efx->type->mcdi_max_ver < 2 &&\r\ncmd > MC_CMD_CMD_SPACE_ESCAPE_7))\r\nreturn -EINVAL;\r\nif (inlen > MCDI_CTL_SDU_LEN_MAX_V2 ||\r\n(efx->type->mcdi_max_ver < 2 &&\r\ninlen > MCDI_CTL_SDU_LEN_MAX_V1))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic bool efx_mcdi_get_proxy_handle(struct efx_nic *efx,\r\nsize_t hdr_len, size_t data_len,\r\nu32 *proxy_handle)\r\n{\r\nMCDI_DECLARE_BUF_ERR(testbuf);\r\nconst size_t buflen = sizeof(testbuf);\r\nif (!proxy_handle || data_len < buflen)\r\nreturn false;\r\nefx->type->mcdi_read_response(efx, testbuf, hdr_len, buflen);\r\nif (MCDI_DWORD(testbuf, ERR_CODE) == MC_CMD_ERR_PROXY_PENDING) {\r\n*proxy_handle = MCDI_DWORD(testbuf, ERR_PROXY_PENDING_HANDLE);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int _efx_mcdi_rpc_finish(struct efx_nic *efx, unsigned int cmd,\r\nsize_t inlen,\r\nefx_dword_t *outbuf, size_t outlen,\r\nsize_t *outlen_actual, bool quiet,\r\nu32 *proxy_handle, int *raw_rc)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nMCDI_DECLARE_BUF_ERR(errbuf);\r\nint rc;\r\nif (mcdi->mode == MCDI_MODE_POLL)\r\nrc = efx_mcdi_poll(efx);\r\nelse\r\nrc = efx_mcdi_await_completion(efx);\r\nif (rc != 0) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"MC command 0x%x inlen %d mode %d timed out\n",\r\ncmd, (int)inlen, mcdi->mode);\r\nif (mcdi->mode == MCDI_MODE_EVENTS && efx_mcdi_poll_once(efx)) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"MCDI request was completed without an event\n");\r\nrc = 0;\r\n}\r\nefx_mcdi_abandon(efx);\r\nspin_lock_bh(&mcdi->iface_lock);\r\n++mcdi->seqno;\r\n++mcdi->credits;\r\nspin_unlock_bh(&mcdi->iface_lock);\r\n}\r\nif (proxy_handle)\r\n*proxy_handle = 0;\r\nif (rc != 0) {\r\nif (outlen_actual)\r\n*outlen_actual = 0;\r\n} else {\r\nsize_t hdr_len, data_len, err_len;\r\nspin_lock_bh(&mcdi->iface_lock);\r\nrc = mcdi->resprc;\r\nif (raw_rc)\r\n*raw_rc = mcdi->resprc_raw;\r\nhdr_len = mcdi->resp_hdr_len;\r\ndata_len = mcdi->resp_data_len;\r\nerr_len = min(sizeof(errbuf), data_len);\r\nspin_unlock_bh(&mcdi->iface_lock);\r\nBUG_ON(rc > 0);\r\nefx->type->mcdi_read_response(efx, outbuf, hdr_len,\r\nmin(outlen, data_len));\r\nif (outlen_actual)\r\n*outlen_actual = data_len;\r\nefx->type->mcdi_read_response(efx, errbuf, hdr_len, err_len);\r\nif (cmd == MC_CMD_REBOOT && rc == -EIO) {\r\n} else if (rc == -EIO || rc == -EINTR) {\r\nnetif_err(efx, hw, efx->net_dev, "MC reboot detected\n");\r\nnetif_dbg(efx, hw, efx->net_dev, "MC rebooted during command %d rc %d\n",\r\ncmd, -rc);\r\nif (efx->type->mcdi_reboot_detected)\r\nefx->type->mcdi_reboot_detected(efx);\r\nefx_schedule_reset(efx, RESET_TYPE_MC_FAILURE);\r\n} else if (proxy_handle && (rc == -EPROTO) &&\r\nefx_mcdi_get_proxy_handle(efx, hdr_len, data_len,\r\nproxy_handle)) {\r\nmcdi->proxy_rx_status = 0;\r\nmcdi->proxy_rx_handle = 0;\r\nmcdi->state = MCDI_STATE_PROXY_WAIT;\r\n} else if (rc && !quiet) {\r\nefx_mcdi_display_error(efx, cmd, inlen, errbuf, err_len,\r\nrc);\r\n}\r\nif (rc == -EIO || rc == -EINTR) {\r\nmsleep(MCDI_STATUS_SLEEP_MS);\r\nefx_mcdi_poll_reboot(efx);\r\nmcdi->new_epoch = true;\r\n}\r\n}\r\nif (!proxy_handle || !*proxy_handle)\r\nefx_mcdi_release(mcdi);\r\nreturn rc;\r\n}\r\nstatic void efx_mcdi_proxy_abort(struct efx_mcdi_iface *mcdi)\r\n{\r\nif (mcdi->state == MCDI_STATE_PROXY_WAIT) {\r\nmcdi->proxy_rx_status = -EINTR;\r\nwake_up(&mcdi->proxy_rx_wq);\r\n}\r\n}\r\nstatic void efx_mcdi_ev_proxy_response(struct efx_nic *efx,\r\nu32 handle, int status)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nWARN_ON(mcdi->state != MCDI_STATE_PROXY_WAIT);\r\nmcdi->proxy_rx_status = efx_mcdi_errno(status);\r\nwmb();\r\nmcdi->proxy_rx_handle = handle;\r\nwake_up(&mcdi->proxy_rx_wq);\r\n}\r\nstatic int efx_mcdi_proxy_wait(struct efx_nic *efx, u32 handle, bool quiet)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nint rc;\r\nrc = wait_event_timeout(mcdi->proxy_rx_wq,\r\nmcdi->proxy_rx_handle != 0 ||\r\nmcdi->proxy_rx_status == -EINTR,\r\nMCDI_RPC_TIMEOUT);\r\nif (rc <= 0) {\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"MCDI proxy timeout %d\n", handle);\r\nreturn -ETIMEDOUT;\r\n} else if (mcdi->proxy_rx_handle != handle) {\r\nnetif_warn(efx, hw, efx->net_dev,\r\n"MCDI proxy unexpected handle %d (expected %d)\n",\r\nmcdi->proxy_rx_handle, handle);\r\nreturn -EINVAL;\r\n}\r\nreturn mcdi->proxy_rx_status;\r\n}\r\nstatic int _efx_mcdi_rpc(struct efx_nic *efx, unsigned int cmd,\r\nconst efx_dword_t *inbuf, size_t inlen,\r\nefx_dword_t *outbuf, size_t outlen,\r\nsize_t *outlen_actual, bool quiet, int *raw_rc)\r\n{\r\nu32 proxy_handle = 0;\r\nint rc;\r\nif (inbuf && inlen && (inbuf == outbuf)) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nrc = efx_mcdi_rpc_start(efx, cmd, inbuf, inlen);\r\nif (rc)\r\nreturn rc;\r\nrc = _efx_mcdi_rpc_finish(efx, cmd, inlen, outbuf, outlen,\r\noutlen_actual, quiet, &proxy_handle, raw_rc);\r\nif (proxy_handle) {\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"MCDI waiting for proxy auth %d\n",\r\nproxy_handle);\r\nrc = efx_mcdi_proxy_wait(efx, proxy_handle, quiet);\r\nif (rc == 0) {\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"MCDI proxy retry %d\n", proxy_handle);\r\nmcdi->state = MCDI_STATE_RUNNING_SYNC;\r\nefx_mcdi_send_request(efx, cmd, inbuf, inlen);\r\nrc = _efx_mcdi_rpc_finish(efx, cmd, inlen,\r\noutbuf, outlen, outlen_actual,\r\nquiet, NULL, raw_rc);\r\n} else {\r\nnetif_cond_dbg(efx, hw, efx->net_dev, rc == -EPERM, err,\r\n"MC command 0x%x failed after proxy auth rc=%d\n",\r\ncmd, rc);\r\nif (rc == -EINTR || rc == -EIO)\r\nefx_schedule_reset(efx, RESET_TYPE_MC_FAILURE);\r\nefx_mcdi_release(mcdi);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int _efx_mcdi_rpc_evb_retry(struct efx_nic *efx, unsigned cmd,\r\nconst efx_dword_t *inbuf, size_t inlen,\r\nefx_dword_t *outbuf, size_t outlen,\r\nsize_t *outlen_actual, bool quiet)\r\n{\r\nint raw_rc = 0;\r\nint rc;\r\nrc = _efx_mcdi_rpc(efx, cmd, inbuf, inlen,\r\noutbuf, outlen, outlen_actual, true, &raw_rc);\r\nif ((rc == -EPROTO) && (raw_rc == MC_CMD_ERR_NO_EVB_PORT) &&\r\nefx->type->is_vf) {\r\nunsigned long abort_time = jiffies + MCDI_RPC_TIMEOUT;\r\nunsigned int delay_us = 10000;\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"%s: NO_EVB_PORT; will retry request\n",\r\n__func__);\r\ndo {\r\nusleep_range(delay_us, delay_us + 10000);\r\nrc = _efx_mcdi_rpc(efx, cmd, inbuf, inlen,\r\noutbuf, outlen, outlen_actual,\r\ntrue, &raw_rc);\r\nif (delay_us < 100000)\r\ndelay_us <<= 1;\r\n} while ((rc == -EPROTO) &&\r\n(raw_rc == MC_CMD_ERR_NO_EVB_PORT) &&\r\ntime_before(jiffies, abort_time));\r\n}\r\nif (rc && !quiet && !(cmd == MC_CMD_REBOOT && rc == -EIO))\r\nefx_mcdi_display_error(efx, cmd, inlen,\r\noutbuf, outlen, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_rpc(struct efx_nic *efx, unsigned cmd,\r\nconst efx_dword_t *inbuf, size_t inlen,\r\nefx_dword_t *outbuf, size_t outlen,\r\nsize_t *outlen_actual)\r\n{\r\nreturn _efx_mcdi_rpc_evb_retry(efx, cmd, inbuf, inlen, outbuf, outlen,\r\noutlen_actual, false);\r\n}\r\nint efx_mcdi_rpc_quiet(struct efx_nic *efx, unsigned cmd,\r\nconst efx_dword_t *inbuf, size_t inlen,\r\nefx_dword_t *outbuf, size_t outlen,\r\nsize_t *outlen_actual)\r\n{\r\nreturn _efx_mcdi_rpc_evb_retry(efx, cmd, inbuf, inlen, outbuf, outlen,\r\noutlen_actual, true);\r\n}\r\nint efx_mcdi_rpc_start(struct efx_nic *efx, unsigned cmd,\r\nconst efx_dword_t *inbuf, size_t inlen)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nint rc;\r\nrc = efx_mcdi_check_supported(efx, cmd, inlen);\r\nif (rc)\r\nreturn rc;\r\nif (efx->mc_bist_for_other_fn)\r\nreturn -ENETDOWN;\r\nif (mcdi->mode == MCDI_MODE_FAIL)\r\nreturn -ENETDOWN;\r\nefx_mcdi_acquire_sync(mcdi);\r\nefx_mcdi_send_request(efx, cmd, inbuf, inlen);\r\nreturn 0;\r\n}\r\nstatic int _efx_mcdi_rpc_async(struct efx_nic *efx, unsigned int cmd,\r\nconst efx_dword_t *inbuf, size_t inlen,\r\nsize_t outlen,\r\nefx_mcdi_async_completer *complete,\r\nunsigned long cookie, bool quiet)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nstruct efx_mcdi_async_param *async;\r\nint rc;\r\nrc = efx_mcdi_check_supported(efx, cmd, inlen);\r\nif (rc)\r\nreturn rc;\r\nif (efx->mc_bist_for_other_fn)\r\nreturn -ENETDOWN;\r\nasync = kmalloc(sizeof(*async) + ALIGN(max(inlen, outlen), 4),\r\nGFP_ATOMIC);\r\nif (!async)\r\nreturn -ENOMEM;\r\nasync->cmd = cmd;\r\nasync->inlen = inlen;\r\nasync->outlen = outlen;\r\nasync->quiet = quiet;\r\nasync->complete = complete;\r\nasync->cookie = cookie;\r\nmemcpy(async + 1, inbuf, inlen);\r\nspin_lock_bh(&mcdi->async_lock);\r\nif (mcdi->mode == MCDI_MODE_EVENTS) {\r\nlist_add_tail(&async->list, &mcdi->async_list);\r\nif (mcdi->async_list.next == &async->list &&\r\nefx_mcdi_acquire_async(mcdi)) {\r\nefx_mcdi_send_request(efx, cmd, inbuf, inlen);\r\nmod_timer(&mcdi->async_timer,\r\njiffies + MCDI_RPC_TIMEOUT);\r\n}\r\n} else {\r\nkfree(async);\r\nrc = -ENETDOWN;\r\n}\r\nspin_unlock_bh(&mcdi->async_lock);\r\nreturn rc;\r\n}\r\nint\r\nefx_mcdi_rpc_async(struct efx_nic *efx, unsigned int cmd,\r\nconst efx_dword_t *inbuf, size_t inlen, size_t outlen,\r\nefx_mcdi_async_completer *complete, unsigned long cookie)\r\n{\r\nreturn _efx_mcdi_rpc_async(efx, cmd, inbuf, inlen, outlen, complete,\r\ncookie, false);\r\n}\r\nint efx_mcdi_rpc_async_quiet(struct efx_nic *efx, unsigned int cmd,\r\nconst efx_dword_t *inbuf, size_t inlen,\r\nsize_t outlen, efx_mcdi_async_completer *complete,\r\nunsigned long cookie)\r\n{\r\nreturn _efx_mcdi_rpc_async(efx, cmd, inbuf, inlen, outlen, complete,\r\ncookie, true);\r\n}\r\nint efx_mcdi_rpc_finish(struct efx_nic *efx, unsigned cmd, size_t inlen,\r\nefx_dword_t *outbuf, size_t outlen,\r\nsize_t *outlen_actual)\r\n{\r\nreturn _efx_mcdi_rpc_finish(efx, cmd, inlen, outbuf, outlen,\r\noutlen_actual, false, NULL, NULL);\r\n}\r\nint efx_mcdi_rpc_finish_quiet(struct efx_nic *efx, unsigned cmd, size_t inlen,\r\nefx_dword_t *outbuf, size_t outlen,\r\nsize_t *outlen_actual)\r\n{\r\nreturn _efx_mcdi_rpc_finish(efx, cmd, inlen, outbuf, outlen,\r\noutlen_actual, true, NULL, NULL);\r\n}\r\nvoid efx_mcdi_display_error(struct efx_nic *efx, unsigned cmd,\r\nsize_t inlen, efx_dword_t *outbuf,\r\nsize_t outlen, int rc)\r\n{\r\nint code = 0, err_arg = 0;\r\nif (outlen >= MC_CMD_ERR_CODE_OFST + 4)\r\ncode = MCDI_DWORD(outbuf, ERR_CODE);\r\nif (outlen >= MC_CMD_ERR_ARG_OFST + 4)\r\nerr_arg = MCDI_DWORD(outbuf, ERR_ARG);\r\nnetif_cond_dbg(efx, hw, efx->net_dev, rc == -EPERM, err,\r\n"MC command 0x%x inlen %zu failed rc=%d (raw=%d) arg=%d\n",\r\ncmd, inlen, rc, code, err_arg);\r\n}\r\nvoid efx_mcdi_mode_poll(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_iface *mcdi;\r\nif (!efx->mcdi)\r\nreturn;\r\nmcdi = efx_mcdi(efx);\r\nif (mcdi->mode == MCDI_MODE_POLL || mcdi->mode == MCDI_MODE_FAIL)\r\nreturn;\r\nmcdi->mode = MCDI_MODE_POLL;\r\nefx_mcdi_complete_sync(mcdi);\r\n}\r\nvoid efx_mcdi_flush_async(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_async_param *async, *next;\r\nstruct efx_mcdi_iface *mcdi;\r\nif (!efx->mcdi)\r\nreturn;\r\nmcdi = efx_mcdi(efx);\r\nBUG_ON(mcdi->mode == MCDI_MODE_EVENTS);\r\ndel_timer_sync(&mcdi->async_timer);\r\nif (mcdi->state == MCDI_STATE_RUNNING_ASYNC) {\r\nefx_mcdi_poll(efx);\r\nmcdi->state = MCDI_STATE_QUIESCENT;\r\n}\r\nlist_for_each_entry_safe(async, next, &mcdi->async_list, list) {\r\nif (async->complete)\r\nasync->complete(efx, async->cookie, -ENETDOWN, NULL, 0);\r\nlist_del(&async->list);\r\nkfree(async);\r\n}\r\n}\r\nvoid efx_mcdi_mode_event(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_iface *mcdi;\r\nif (!efx->mcdi)\r\nreturn;\r\nmcdi = efx_mcdi(efx);\r\nif (mcdi->mode == MCDI_MODE_EVENTS || mcdi->mode == MCDI_MODE_FAIL)\r\nreturn;\r\nefx_mcdi_acquire_sync(mcdi);\r\nmcdi->mode = MCDI_MODE_EVENTS;\r\nefx_mcdi_release(mcdi);\r\n}\r\nstatic void efx_mcdi_ev_death(struct efx_nic *efx, int rc)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nspin_lock(&mcdi->iface_lock);\r\nefx_mcdi_proxy_abort(mcdi);\r\nif (efx_mcdi_complete_sync(mcdi)) {\r\nif (mcdi->mode == MCDI_MODE_EVENTS) {\r\nmcdi->resprc = rc;\r\nmcdi->resp_hdr_len = 0;\r\nmcdi->resp_data_len = 0;\r\n++mcdi->credits;\r\n}\r\n} else {\r\nint count;\r\nfor (count = 0; count < MCDI_STATUS_DELAY_COUNT; ++count) {\r\nrc = efx_mcdi_poll_reboot(efx);\r\nif (rc)\r\nbreak;\r\nudelay(MCDI_STATUS_DELAY_US);\r\n}\r\nif (!rc && efx->type->mcdi_reboot_detected)\r\nefx->type->mcdi_reboot_detected(efx);\r\nmcdi->new_epoch = true;\r\nefx_schedule_reset(efx, RESET_TYPE_MC_FAILURE);\r\n}\r\nspin_unlock(&mcdi->iface_lock);\r\n}\r\nstatic void efx_mcdi_ev_bist(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nspin_lock(&mcdi->iface_lock);\r\nefx->mc_bist_for_other_fn = true;\r\nefx_mcdi_proxy_abort(mcdi);\r\nif (efx_mcdi_complete_sync(mcdi)) {\r\nif (mcdi->mode == MCDI_MODE_EVENTS) {\r\nmcdi->resprc = -EIO;\r\nmcdi->resp_hdr_len = 0;\r\nmcdi->resp_data_len = 0;\r\n++mcdi->credits;\r\n}\r\n}\r\nmcdi->new_epoch = true;\r\nefx_schedule_reset(efx, RESET_TYPE_MC_BIST);\r\nspin_unlock(&mcdi->iface_lock);\r\n}\r\nstatic void efx_mcdi_abandon(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nif (xchg(&mcdi->mode, MCDI_MODE_FAIL) == MCDI_MODE_FAIL)\r\nreturn;\r\nnetif_dbg(efx, hw, efx->net_dev, "MCDI is timing out; trying to recover\n");\r\nefx_schedule_reset(efx, RESET_TYPE_MCDI_TIMEOUT);\r\n}\r\nvoid efx_mcdi_process_event(struct efx_channel *channel,\r\nefx_qword_t *event)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nint code = EFX_QWORD_FIELD(*event, MCDI_EVENT_CODE);\r\nu32 data = EFX_QWORD_FIELD(*event, MCDI_EVENT_DATA);\r\nswitch (code) {\r\ncase MCDI_EVENT_CODE_BADSSERT:\r\nnetif_err(efx, hw, efx->net_dev,\r\n"MC watchdog or assertion failure at 0x%x\n", data);\r\nefx_mcdi_ev_death(efx, -EINTR);\r\nbreak;\r\ncase MCDI_EVENT_CODE_PMNOTICE:\r\nnetif_info(efx, wol, efx->net_dev, "MCDI PM event.\n");\r\nbreak;\r\ncase MCDI_EVENT_CODE_CMDDONE:\r\nefx_mcdi_ev_cpl(efx,\r\nMCDI_EVENT_FIELD(*event, CMDDONE_SEQ),\r\nMCDI_EVENT_FIELD(*event, CMDDONE_DATALEN),\r\nMCDI_EVENT_FIELD(*event, CMDDONE_ERRNO));\r\nbreak;\r\ncase MCDI_EVENT_CODE_LINKCHANGE:\r\nefx_mcdi_process_link_change(efx, event);\r\nbreak;\r\ncase MCDI_EVENT_CODE_SENSOREVT:\r\nefx_mcdi_sensor_event(efx, event);\r\nbreak;\r\ncase MCDI_EVENT_CODE_SCHEDERR:\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"MC Scheduler alert (0x%x)\n", data);\r\nbreak;\r\ncase MCDI_EVENT_CODE_REBOOT:\r\ncase MCDI_EVENT_CODE_MC_REBOOT:\r\nnetif_info(efx, hw, efx->net_dev, "MC Reboot\n");\r\nefx_mcdi_ev_death(efx, -EIO);\r\nbreak;\r\ncase MCDI_EVENT_CODE_MC_BIST:\r\nnetif_info(efx, hw, efx->net_dev, "MC entered BIST mode\n");\r\nefx_mcdi_ev_bist(efx);\r\nbreak;\r\ncase MCDI_EVENT_CODE_MAC_STATS_DMA:\r\nbreak;\r\ncase MCDI_EVENT_CODE_FLR:\r\nif (efx->type->sriov_flr)\r\nefx->type->sriov_flr(efx,\r\nMCDI_EVENT_FIELD(*event, FLR_VF));\r\nbreak;\r\ncase MCDI_EVENT_CODE_PTP_RX:\r\ncase MCDI_EVENT_CODE_PTP_FAULT:\r\ncase MCDI_EVENT_CODE_PTP_PPS:\r\nefx_ptp_event(efx, event);\r\nbreak;\r\ncase MCDI_EVENT_CODE_PTP_TIME:\r\nefx_time_sync_event(channel, event);\r\nbreak;\r\ncase MCDI_EVENT_CODE_TX_FLUSH:\r\ncase MCDI_EVENT_CODE_RX_FLUSH:\r\nBUILD_BUG_ON(MCDI_EVENT_TX_FLUSH_TO_DRIVER_LBN !=\r\nMCDI_EVENT_RX_FLUSH_TO_DRIVER_LBN);\r\nif (!MCDI_EVENT_FIELD(*event, TX_FLUSH_TO_DRIVER))\r\nefx_ef10_handle_drain_event(efx);\r\nbreak;\r\ncase MCDI_EVENT_CODE_TX_ERR:\r\ncase MCDI_EVENT_CODE_RX_ERR:\r\nnetif_err(efx, hw, efx->net_dev,\r\n"%s DMA error (event: "EFX_QWORD_FMT")\n",\r\ncode == MCDI_EVENT_CODE_TX_ERR ? "TX" : "RX",\r\nEFX_QWORD_VAL(*event));\r\nefx_schedule_reset(efx, RESET_TYPE_DMA_ERROR);\r\nbreak;\r\ncase MCDI_EVENT_CODE_PROXY_RESPONSE:\r\nefx_mcdi_ev_proxy_response(efx,\r\nMCDI_EVENT_FIELD(*event, PROXY_RESPONSE_HANDLE),\r\nMCDI_EVENT_FIELD(*event, PROXY_RESPONSE_RC));\r\nbreak;\r\ndefault:\r\nnetif_err(efx, hw, efx->net_dev,\r\n"Unknown MCDI event " EFX_QWORD_FMT "\n",\r\nEFX_QWORD_VAL(*event));\r\n}\r\n}\r\nvoid efx_mcdi_print_fwver(struct efx_nic *efx, char *buf, size_t len)\r\n{\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_VERSION_OUT_LEN);\r\nsize_t outlength;\r\nconst __le16 *ver_words;\r\nsize_t offset;\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_GET_VERSION_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_VERSION, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlength);\r\nif (rc)\r\ngoto fail;\r\nif (outlength < MC_CMD_GET_VERSION_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\nver_words = (__le16 *)MCDI_PTR(outbuf, GET_VERSION_OUT_VERSION);\r\noffset = snprintf(buf, len, "%u.%u.%u.%u",\r\nle16_to_cpu(ver_words[0]), le16_to_cpu(ver_words[1]),\r\nle16_to_cpu(ver_words[2]), le16_to_cpu(ver_words[3]));\r\nif (efx_nic_rev(efx) >= EFX_REV_HUNT_A0) {\r\nstruct efx_ef10_nic_data *nic_data = efx->nic_data;\r\noffset += snprintf(buf + offset, len - offset, " rx%x tx%x",\r\nnic_data->rx_dpcpu_fw_id,\r\nnic_data->tx_dpcpu_fw_id);\r\nif (WARN_ON(offset >= len))\r\nbuf[0] = 0;\r\n}\r\nreturn;\r\nfail:\r\nnetif_err(efx, probe, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nbuf[0] = 0;\r\n}\r\nstatic int efx_mcdi_drv_attach(struct efx_nic *efx, bool driver_operating,\r\nbool *was_attached)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_DRV_ATTACH_IN_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_DRV_ATTACH_EXT_OUT_LEN);\r\nsize_t outlen;\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, DRV_ATTACH_IN_NEW_STATE,\r\ndriver_operating ? 1 : 0);\r\nMCDI_SET_DWORD(inbuf, DRV_ATTACH_IN_UPDATE, 1);\r\nMCDI_SET_DWORD(inbuf, DRV_ATTACH_IN_FIRMWARE_ID, MC_CMD_FW_LOW_LATENCY);\r\nrc = efx_mcdi_rpc_quiet(efx, MC_CMD_DRV_ATTACH, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc == -EPERM) {\r\nnetif_dbg(efx, probe, efx->net_dev,\r\n"efx_mcdi_drv_attach with fw-variant setting failed EPERM, trying without it\n");\r\nMCDI_SET_DWORD(inbuf, DRV_ATTACH_IN_FIRMWARE_ID,\r\nMC_CMD_FW_DONT_CARE);\r\nrc = efx_mcdi_rpc_quiet(efx, MC_CMD_DRV_ATTACH, inbuf,\r\nsizeof(inbuf), outbuf, sizeof(outbuf),\r\n&outlen);\r\n}\r\nif (rc) {\r\nefx_mcdi_display_error(efx, MC_CMD_DRV_ATTACH, sizeof(inbuf),\r\noutbuf, outlen, rc);\r\ngoto fail;\r\n}\r\nif (outlen < MC_CMD_DRV_ATTACH_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\nif (driver_operating) {\r\nif (outlen >= MC_CMD_DRV_ATTACH_EXT_OUT_LEN) {\r\nefx->mcdi->fn_flags =\r\nMCDI_DWORD(outbuf,\r\nDRV_ATTACH_EXT_OUT_FUNC_FLAGS);\r\n} else {\r\nefx->mcdi->fn_flags =\r\n1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_LINKCTRL |\r\n1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_TRUSTED |\r\n(efx_port_num(efx) == 0) <<\r\nMC_CMD_DRV_ATTACH_EXT_OUT_FLAG_PRIMARY;\r\n}\r\n}\r\nif (was_attached != NULL)\r\n*was_attached = MCDI_DWORD(outbuf, DRV_ATTACH_OUT_OLD_STATE);\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, probe, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_get_board_cfg(struct efx_nic *efx, u8 *mac_address,\r\nu16 *fw_subtype_list, u32 *capabilities)\r\n{\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_BOARD_CFG_OUT_LENMAX);\r\nsize_t outlen, i;\r\nint port_num = efx_port_num(efx);\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_GET_BOARD_CFG_IN_LEN != 0);\r\nBUILD_BUG_ON(MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0_OFST & 1);\r\nBUILD_BUG_ON(MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1_OFST & 1);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_BOARD_CFG, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_GET_BOARD_CFG_OUT_LENMIN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\nif (mac_address)\r\nether_addr_copy(mac_address,\r\nport_num ?\r\nMCDI_PTR(outbuf, GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1) :\r\nMCDI_PTR(outbuf, GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0));\r\nif (fw_subtype_list) {\r\nfor (i = 0;\r\ni < MCDI_VAR_ARRAY_LEN(outlen,\r\nGET_BOARD_CFG_OUT_FW_SUBTYPE_LIST);\r\ni++)\r\nfw_subtype_list[i] = MCDI_ARRAY_WORD(\r\noutbuf, GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST, i);\r\nfor (; i < MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_MAXNUM; i++)\r\nfw_subtype_list[i] = 0;\r\n}\r\nif (capabilities) {\r\nif (port_num)\r\n*capabilities = MCDI_DWORD(outbuf,\r\nGET_BOARD_CFG_OUT_CAPABILITIES_PORT1);\r\nelse\r\n*capabilities = MCDI_DWORD(outbuf,\r\nGET_BOARD_CFG_OUT_CAPABILITIES_PORT0);\r\n}\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d len=%d\n",\r\n__func__, rc, (int)outlen);\r\nreturn rc;\r\n}\r\nint efx_mcdi_log_ctrl(struct efx_nic *efx, bool evq, bool uart, u32 dest_evq)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_LOG_CTRL_IN_LEN);\r\nu32 dest = 0;\r\nint rc;\r\nif (uart)\r\ndest |= MC_CMD_LOG_CTRL_IN_LOG_DEST_UART;\r\nif (evq)\r\ndest |= MC_CMD_LOG_CTRL_IN_LOG_DEST_EVQ;\r\nMCDI_SET_DWORD(inbuf, LOG_CTRL_IN_LOG_DEST, dest);\r\nMCDI_SET_DWORD(inbuf, LOG_CTRL_IN_LOG_DEST_EVQ, dest_evq);\r\nBUILD_BUG_ON(MC_CMD_LOG_CTRL_OUT_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_LOG_CTRL, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nreturn rc;\r\n}\r\nint efx_mcdi_nvram_types(struct efx_nic *efx, u32 *nvram_types_out)\r\n{\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_NVRAM_TYPES_OUT_LEN);\r\nsize_t outlen;\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_NVRAM_TYPES_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_TYPES, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_NVRAM_TYPES_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\n*nvram_types_out = MCDI_DWORD(outbuf, NVRAM_TYPES_OUT_TYPES);\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_nvram_info(struct efx_nic *efx, unsigned int type,\r\nsize_t *size_out, size_t *erase_size_out,\r\nbool *protected_out)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_NVRAM_INFO_IN_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_NVRAM_INFO_OUT_LEN);\r\nsize_t outlen;\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, NVRAM_INFO_IN_TYPE, type);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_INFO, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_NVRAM_INFO_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\n*size_out = MCDI_DWORD(outbuf, NVRAM_INFO_OUT_SIZE);\r\n*erase_size_out = MCDI_DWORD(outbuf, NVRAM_INFO_OUT_ERASESIZE);\r\n*protected_out = !!(MCDI_DWORD(outbuf, NVRAM_INFO_OUT_FLAGS) &\r\n(1 << MC_CMD_NVRAM_INFO_OUT_PROTECTED_LBN));\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_nvram_test(struct efx_nic *efx, unsigned int type)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_NVRAM_TEST_IN_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_NVRAM_TEST_OUT_LEN);\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, NVRAM_TEST_IN_TYPE, type);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_TEST, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), NULL);\r\nif (rc)\r\nreturn rc;\r\nswitch (MCDI_DWORD(outbuf, NVRAM_TEST_OUT_RESULT)) {\r\ncase MC_CMD_NVRAM_TEST_PASS:\r\ncase MC_CMD_NVRAM_TEST_NOTSUPP:\r\nreturn 0;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nint efx_mcdi_nvram_test_all(struct efx_nic *efx)\r\n{\r\nu32 nvram_types;\r\nunsigned int type;\r\nint rc;\r\nrc = efx_mcdi_nvram_types(efx, &nvram_types);\r\nif (rc)\r\ngoto fail1;\r\ntype = 0;\r\nwhile (nvram_types != 0) {\r\nif (nvram_types & 1) {\r\nrc = efx_mcdi_nvram_test(efx, type);\r\nif (rc)\r\ngoto fail2;\r\n}\r\ntype++;\r\nnvram_types >>= 1;\r\n}\r\nreturn 0;\r\nfail2:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed type=%u\n",\r\n__func__, type);\r\nfail1:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_read_assertion(struct efx_nic *efx)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_GET_ASSERTS_IN_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_ASSERTS_OUT_LEN);\r\nunsigned int flags, index;\r\nconst char *reason;\r\nsize_t outlen;\r\nint retry;\r\nint rc;\r\nretry = 2;\r\ndo {\r\nMCDI_SET_DWORD(inbuf, GET_ASSERTS_IN_CLEAR, 1);\r\nrc = efx_mcdi_rpc_quiet(efx, MC_CMD_GET_ASSERTS,\r\ninbuf, MC_CMD_GET_ASSERTS_IN_LEN,\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc == -EPERM)\r\nreturn 0;\r\n} while ((rc == -EINTR || rc == -EIO) && retry-- > 0);\r\nif (rc) {\r\nefx_mcdi_display_error(efx, MC_CMD_GET_ASSERTS,\r\nMC_CMD_GET_ASSERTS_IN_LEN, outbuf,\r\noutlen, rc);\r\nreturn rc;\r\n}\r\nif (outlen < MC_CMD_GET_ASSERTS_OUT_LEN)\r\nreturn -EIO;\r\nflags = MCDI_DWORD(outbuf, GET_ASSERTS_OUT_GLOBAL_FLAGS);\r\nif (flags == MC_CMD_GET_ASSERTS_FLAGS_NO_FAILS)\r\nreturn 0;\r\nreason = (flags == MC_CMD_GET_ASSERTS_FLAGS_SYS_FAIL)\r\n? "system-level assertion"\r\n: (flags == MC_CMD_GET_ASSERTS_FLAGS_THR_FAIL)\r\n? "thread-level assertion"\r\n: (flags == MC_CMD_GET_ASSERTS_FLAGS_WDOG_FIRED)\r\n? "watchdog reset"\r\n: "unknown assertion";\r\nnetif_err(efx, hw, efx->net_dev,\r\n"MCPU %s at PC = 0x%.8x in thread 0x%.8x\n", reason,\r\nMCDI_DWORD(outbuf, GET_ASSERTS_OUT_SAVED_PC_OFFS),\r\nMCDI_DWORD(outbuf, GET_ASSERTS_OUT_THREAD_OFFS));\r\nfor (index = 0;\r\nindex < MC_CMD_GET_ASSERTS_OUT_GP_REGS_OFFS_NUM;\r\nindex++)\r\nnetif_err(efx, hw, efx->net_dev, "R%.2d (?): 0x%.8x\n",\r\n1 + index,\r\nMCDI_ARRAY_DWORD(outbuf, GET_ASSERTS_OUT_GP_REGS_OFFS,\r\nindex));\r\nreturn 1;\r\n}\r\nstatic int efx_mcdi_exit_assertion(struct efx_nic *efx)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_REBOOT_IN_LEN);\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_REBOOT_OUT_LEN != 0);\r\nMCDI_SET_DWORD(inbuf, REBOOT_IN_FLAGS,\r\nMC_CMD_REBOOT_FLAGS_AFTER_ASSERTION);\r\nrc = efx_mcdi_rpc_quiet(efx, MC_CMD_REBOOT, inbuf, MC_CMD_REBOOT_IN_LEN,\r\nNULL, 0, NULL);\r\nif (rc == -EIO)\r\nrc = 0;\r\nif (rc)\r\nefx_mcdi_display_error(efx, MC_CMD_REBOOT, MC_CMD_REBOOT_IN_LEN,\r\nNULL, 0, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_handle_assertion(struct efx_nic *efx)\r\n{\r\nint rc;\r\nrc = efx_mcdi_read_assertion(efx);\r\nif (rc <= 0)\r\nreturn rc;\r\nreturn efx_mcdi_exit_assertion(efx);\r\n}\r\nvoid efx_mcdi_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_SET_ID_LED_IN_LEN);\r\nint rc;\r\nBUILD_BUG_ON(EFX_LED_OFF != MC_CMD_LED_OFF);\r\nBUILD_BUG_ON(EFX_LED_ON != MC_CMD_LED_ON);\r\nBUILD_BUG_ON(EFX_LED_DEFAULT != MC_CMD_LED_DEFAULT);\r\nBUILD_BUG_ON(MC_CMD_SET_ID_LED_OUT_LEN != 0);\r\nMCDI_SET_DWORD(inbuf, SET_ID_LED_IN_STATE, mode);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_SET_ID_LED, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\n}\r\nstatic int efx_mcdi_reset_func(struct efx_nic *efx)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_ENTITY_RESET_IN_LEN);\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_ENTITY_RESET_OUT_LEN != 0);\r\nMCDI_POPULATE_DWORD_1(inbuf, ENTITY_RESET_IN_FLAG,\r\nENTITY_RESET_IN_FUNCTION_RESOURCE_RESET, 1);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_ENTITY_RESET, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_reset_mc(struct efx_nic *efx)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_REBOOT_IN_LEN);\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_REBOOT_OUT_LEN != 0);\r\nMCDI_SET_DWORD(inbuf, REBOOT_IN_FLAGS, 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_REBOOT, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nif (rc == -EIO)\r\nreturn 0;\r\nif (rc == 0)\r\nrc = -EIO;\r\nreturn rc;\r\n}\r\nenum reset_type efx_mcdi_map_reset_reason(enum reset_type reason)\r\n{\r\nreturn RESET_TYPE_RECOVER_OR_ALL;\r\n}\r\nint efx_mcdi_reset(struct efx_nic *efx, enum reset_type method)\r\n{\r\nint rc;\r\nif (method == RESET_TYPE_MCDI_TIMEOUT) {\r\nrc = pci_reset_function(efx->pci_dev);\r\nif (rc)\r\nreturn rc;\r\nif (efx->mcdi) {\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nmcdi->mode = MCDI_MODE_POLL;\r\n}\r\nreturn 0;\r\n}\r\nrc = efx_mcdi_handle_assertion(efx);\r\nif (rc)\r\nreturn rc;\r\nif (method == RESET_TYPE_DATAPATH)\r\nreturn 0;\r\nelse if (method == RESET_TYPE_WORLD)\r\nreturn efx_mcdi_reset_mc(efx);\r\nelse\r\nreturn efx_mcdi_reset_func(efx);\r\n}\r\nstatic int efx_mcdi_wol_filter_set(struct efx_nic *efx, u32 type,\r\nconst u8 *mac, int *id_out)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_WOL_FILTER_SET_IN_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_WOL_FILTER_SET_OUT_LEN);\r\nsize_t outlen;\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, WOL_FILTER_SET_IN_WOL_TYPE, type);\r\nMCDI_SET_DWORD(inbuf, WOL_FILTER_SET_IN_FILTER_MODE,\r\nMC_CMD_FILTER_MODE_SIMPLE);\r\nether_addr_copy(MCDI_PTR(inbuf, WOL_FILTER_SET_IN_MAGIC_MAC), mac);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_SET, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_WOL_FILTER_SET_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\n*id_out = (int)MCDI_DWORD(outbuf, WOL_FILTER_SET_OUT_FILTER_ID);\r\nreturn 0;\r\nfail:\r\n*id_out = -1;\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint\r\nefx_mcdi_wol_filter_set_magic(struct efx_nic *efx, const u8 *mac, int *id_out)\r\n{\r\nreturn efx_mcdi_wol_filter_set(efx, MC_CMD_WOL_TYPE_MAGIC, mac, id_out);\r\n}\r\nint efx_mcdi_wol_filter_get_magic(struct efx_nic *efx, int *id_out)\r\n{\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_WOL_FILTER_GET_OUT_LEN);\r\nsize_t outlen;\r\nint rc;\r\nrc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_GET, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_WOL_FILTER_GET_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\n*id_out = (int)MCDI_DWORD(outbuf, WOL_FILTER_GET_OUT_FILTER_ID);\r\nreturn 0;\r\nfail:\r\n*id_out = -1;\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_wol_filter_remove(struct efx_nic *efx, int id)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_WOL_FILTER_REMOVE_IN_LEN);\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, WOL_FILTER_REMOVE_IN_FILTER_ID, (u32)id);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_REMOVE, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nreturn rc;\r\n}\r\nint efx_mcdi_flush_rxqs(struct efx_nic *efx)\r\n{\r\nstruct efx_channel *channel;\r\nstruct efx_rx_queue *rx_queue;\r\nMCDI_DECLARE_BUF(inbuf,\r\nMC_CMD_FLUSH_RX_QUEUES_IN_LEN(EFX_MAX_CHANNELS));\r\nint rc, count;\r\nBUILD_BUG_ON(EFX_MAX_CHANNELS >\r\nMC_CMD_FLUSH_RX_QUEUES_IN_QID_OFST_MAXNUM);\r\ncount = 0;\r\nefx_for_each_channel(channel, efx) {\r\nefx_for_each_channel_rx_queue(rx_queue, channel) {\r\nif (rx_queue->flush_pending) {\r\nrx_queue->flush_pending = false;\r\natomic_dec(&efx->rxq_flush_pending);\r\nMCDI_SET_ARRAY_DWORD(\r\ninbuf, FLUSH_RX_QUEUES_IN_QID_OFST,\r\ncount, efx_rx_queue_index(rx_queue));\r\ncount++;\r\n}\r\n}\r\n}\r\nrc = efx_mcdi_rpc(efx, MC_CMD_FLUSH_RX_QUEUES, inbuf,\r\nMC_CMD_FLUSH_RX_QUEUES_IN_LEN(count), NULL, 0, NULL);\r\nWARN_ON(rc < 0);\r\nreturn rc;\r\n}\r\nint efx_mcdi_wol_filter_reset(struct efx_nic *efx)\r\n{\r\nint rc;\r\nrc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_RESET, NULL, 0, NULL, 0, NULL);\r\nreturn rc;\r\n}\r\nint efx_mcdi_set_workaround(struct efx_nic *efx, u32 type, bool enabled,\r\nunsigned int *flags)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_WORKAROUND_IN_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_WORKAROUND_EXT_OUT_LEN);\r\nsize_t outlen;\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_WORKAROUND_OUT_LEN != 0);\r\nMCDI_SET_DWORD(inbuf, WORKAROUND_IN_TYPE, type);\r\nMCDI_SET_DWORD(inbuf, WORKAROUND_IN_ENABLED, enabled);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_WORKAROUND, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\nreturn rc;\r\nif (!flags)\r\nreturn 0;\r\nif (outlen >= MC_CMD_WORKAROUND_EXT_OUT_LEN)\r\n*flags = MCDI_DWORD(outbuf, WORKAROUND_EXT_OUT_FLAGS);\r\nelse\r\n*flags = 0;\r\nreturn 0;\r\n}\r\nint efx_mcdi_get_workarounds(struct efx_nic *efx, unsigned int *impl_out,\r\nunsigned int *enabled_out)\r\n{\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_WORKAROUNDS_OUT_LEN);\r\nsize_t outlen;\r\nint rc;\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_WORKAROUNDS, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_GET_WORKAROUNDS_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\nif (impl_out)\r\n*impl_out = MCDI_DWORD(outbuf, GET_WORKAROUNDS_OUT_IMPLEMENTED);\r\nif (enabled_out)\r\n*enabled_out = MCDI_DWORD(outbuf, GET_WORKAROUNDS_OUT_ENABLED);\r\nreturn 0;\r\nfail:\r\nnetif_cond_dbg(efx, hw, efx->net_dev, rc == -ENOSYS, err,\r\n"%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_nvram_update_start(struct efx_nic *efx, unsigned int type)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_NVRAM_UPDATE_START_IN_LEN);\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, NVRAM_UPDATE_START_IN_TYPE, type);\r\nBUILD_BUG_ON(MC_CMD_NVRAM_UPDATE_START_OUT_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_UPDATE_START, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_nvram_read(struct efx_nic *efx, unsigned int type,\r\nloff_t offset, u8 *buffer, size_t length)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_NVRAM_READ_IN_LEN);\r\nMCDI_DECLARE_BUF(outbuf,\r\nMC_CMD_NVRAM_READ_OUT_LEN(EFX_MCDI_NVRAM_LEN_MAX));\r\nsize_t outlen;\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, NVRAM_READ_IN_TYPE, type);\r\nMCDI_SET_DWORD(inbuf, NVRAM_READ_IN_OFFSET, offset);\r\nMCDI_SET_DWORD(inbuf, NVRAM_READ_IN_LENGTH, length);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_READ, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\nreturn rc;\r\nmemcpy(buffer, MCDI_PTR(outbuf, NVRAM_READ_OUT_READ_BUFFER), length);\r\nreturn 0;\r\n}\r\nstatic int efx_mcdi_nvram_write(struct efx_nic *efx, unsigned int type,\r\nloff_t offset, const u8 *buffer, size_t length)\r\n{\r\nMCDI_DECLARE_BUF(inbuf,\r\nMC_CMD_NVRAM_WRITE_IN_LEN(EFX_MCDI_NVRAM_LEN_MAX));\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, NVRAM_WRITE_IN_TYPE, type);\r\nMCDI_SET_DWORD(inbuf, NVRAM_WRITE_IN_OFFSET, offset);\r\nMCDI_SET_DWORD(inbuf, NVRAM_WRITE_IN_LENGTH, length);\r\nmemcpy(MCDI_PTR(inbuf, NVRAM_WRITE_IN_WRITE_BUFFER), buffer, length);\r\nBUILD_BUG_ON(MC_CMD_NVRAM_WRITE_OUT_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_WRITE, inbuf,\r\nALIGN(MC_CMD_NVRAM_WRITE_IN_LEN(length), 4),\r\nNULL, 0, NULL);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_nvram_erase(struct efx_nic *efx, unsigned int type,\r\nloff_t offset, size_t length)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_NVRAM_ERASE_IN_LEN);\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, NVRAM_ERASE_IN_TYPE, type);\r\nMCDI_SET_DWORD(inbuf, NVRAM_ERASE_IN_OFFSET, offset);\r\nMCDI_SET_DWORD(inbuf, NVRAM_ERASE_IN_LENGTH, length);\r\nBUILD_BUG_ON(MC_CMD_NVRAM_ERASE_OUT_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_ERASE, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_nvram_update_finish(struct efx_nic *efx, unsigned int type)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_NVRAM_UPDATE_FINISH_IN_LEN);\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, NVRAM_UPDATE_FINISH_IN_TYPE, type);\r\nBUILD_BUG_ON(MC_CMD_NVRAM_UPDATE_FINISH_OUT_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_UPDATE_FINISH, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nreturn rc;\r\n}\r\nint efx_mcdi_mtd_read(struct mtd_info *mtd, loff_t start,\r\nsize_t len, size_t *retlen, u8 *buffer)\r\n{\r\nstruct efx_mcdi_mtd_partition *part = to_efx_mcdi_mtd_partition(mtd);\r\nstruct efx_nic *efx = mtd->priv;\r\nloff_t offset = start;\r\nloff_t end = min_t(loff_t, start + len, mtd->size);\r\nsize_t chunk;\r\nint rc = 0;\r\nwhile (offset < end) {\r\nchunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);\r\nrc = efx_mcdi_nvram_read(efx, part->nvram_type, offset,\r\nbuffer, chunk);\r\nif (rc)\r\ngoto out;\r\noffset += chunk;\r\nbuffer += chunk;\r\n}\r\nout:\r\n*retlen = offset - start;\r\nreturn rc;\r\n}\r\nint efx_mcdi_mtd_erase(struct mtd_info *mtd, loff_t start, size_t len)\r\n{\r\nstruct efx_mcdi_mtd_partition *part = to_efx_mcdi_mtd_partition(mtd);\r\nstruct efx_nic *efx = mtd->priv;\r\nloff_t offset = start & ~((loff_t)(mtd->erasesize - 1));\r\nloff_t end = min_t(loff_t, start + len, mtd->size);\r\nsize_t chunk = part->common.mtd.erasesize;\r\nint rc = 0;\r\nif (!part->updating) {\r\nrc = efx_mcdi_nvram_update_start(efx, part->nvram_type);\r\nif (rc)\r\ngoto out;\r\npart->updating = true;\r\n}\r\nwhile (offset < end) {\r\nrc = efx_mcdi_nvram_erase(efx, part->nvram_type, offset,\r\nchunk);\r\nif (rc)\r\ngoto out;\r\noffset += chunk;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nint efx_mcdi_mtd_write(struct mtd_info *mtd, loff_t start,\r\nsize_t len, size_t *retlen, const u8 *buffer)\r\n{\r\nstruct efx_mcdi_mtd_partition *part = to_efx_mcdi_mtd_partition(mtd);\r\nstruct efx_nic *efx = mtd->priv;\r\nloff_t offset = start;\r\nloff_t end = min_t(loff_t, start + len, mtd->size);\r\nsize_t chunk;\r\nint rc = 0;\r\nif (!part->updating) {\r\nrc = efx_mcdi_nvram_update_start(efx, part->nvram_type);\r\nif (rc)\r\ngoto out;\r\npart->updating = true;\r\n}\r\nwhile (offset < end) {\r\nchunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);\r\nrc = efx_mcdi_nvram_write(efx, part->nvram_type, offset,\r\nbuffer, chunk);\r\nif (rc)\r\ngoto out;\r\noffset += chunk;\r\nbuffer += chunk;\r\n}\r\nout:\r\n*retlen = offset - start;\r\nreturn rc;\r\n}\r\nint efx_mcdi_mtd_sync(struct mtd_info *mtd)\r\n{\r\nstruct efx_mcdi_mtd_partition *part = to_efx_mcdi_mtd_partition(mtd);\r\nstruct efx_nic *efx = mtd->priv;\r\nint rc = 0;\r\nif (part->updating) {\r\npart->updating = false;\r\nrc = efx_mcdi_nvram_update_finish(efx, part->nvram_type);\r\n}\r\nreturn rc;\r\n}\r\nvoid efx_mcdi_mtd_rename(struct efx_mtd_partition *part)\r\n{\r\nstruct efx_mcdi_mtd_partition *mcdi_part =\r\ncontainer_of(part, struct efx_mcdi_mtd_partition, common);\r\nstruct efx_nic *efx = part->mtd.priv;\r\nsnprintf(part->name, sizeof(part->name), "%s %s:%02x",\r\nefx->name, part->type_name, mcdi_part->fw_subtype);\r\n}
