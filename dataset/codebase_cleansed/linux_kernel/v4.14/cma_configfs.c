static struct cma_dev_port_group *to_dev_port_group(struct config_item *item)\r\n{\r\nstruct config_group *group;\r\nif (!item)\r\nreturn NULL;\r\ngroup = container_of(item, struct config_group, cg_item);\r\nreturn container_of(group, struct cma_dev_port_group, group);\r\n}\r\nstatic bool filter_by_name(struct ib_device *ib_dev, void *cookie)\r\n{\r\nreturn !strcmp(ib_dev->name, cookie);\r\n}\r\nstatic int cma_configfs_params_get(struct config_item *item,\r\nstruct cma_device **pcma_dev,\r\nstruct cma_dev_port_group **pgroup)\r\n{\r\nstruct cma_dev_port_group *group = to_dev_port_group(item);\r\nstruct cma_device *cma_dev;\r\nif (!group)\r\nreturn -ENODEV;\r\ncma_dev = cma_enum_devices_by_ibdev(filter_by_name,\r\ngroup->cma_dev_group->name);\r\nif (!cma_dev)\r\nreturn -ENODEV;\r\n*pcma_dev = cma_dev;\r\n*pgroup = group;\r\nreturn 0;\r\n}\r\nstatic void cma_configfs_params_put(struct cma_device *cma_dev)\r\n{\r\ncma_deref_dev(cma_dev);\r\n}\r\nstatic ssize_t default_roce_mode_show(struct config_item *item,\r\nchar *buf)\r\n{\r\nstruct cma_device *cma_dev;\r\nstruct cma_dev_port_group *group;\r\nint gid_type;\r\nssize_t ret;\r\nret = cma_configfs_params_get(item, &cma_dev, &group);\r\nif (ret)\r\nreturn ret;\r\ngid_type = cma_get_default_gid_type(cma_dev, group->port_num);\r\ncma_configfs_params_put(cma_dev);\r\nif (gid_type < 0)\r\nreturn gid_type;\r\nreturn sprintf(buf, "%s\n", ib_cache_gid_type_str(gid_type));\r\n}\r\nstatic ssize_t default_roce_mode_store(struct config_item *item,\r\nconst char *buf, size_t count)\r\n{\r\nstruct cma_device *cma_dev;\r\nstruct cma_dev_port_group *group;\r\nint gid_type = ib_cache_gid_parse_type_str(buf);\r\nssize_t ret;\r\nif (gid_type < 0)\r\nreturn -EINVAL;\r\nret = cma_configfs_params_get(item, &cma_dev, &group);\r\nif (ret)\r\nreturn ret;\r\nret = cma_set_default_gid_type(cma_dev, group->port_num, gid_type);\r\ncma_configfs_params_put(cma_dev);\r\nreturn !ret ? strnlen(buf, count) : ret;\r\n}\r\nstatic ssize_t default_roce_tos_show(struct config_item *item, char *buf)\r\n{\r\nstruct cma_device *cma_dev;\r\nstruct cma_dev_port_group *group;\r\nssize_t ret;\r\nu8 tos;\r\nret = cma_configfs_params_get(item, &cma_dev, &group);\r\nif (ret)\r\nreturn ret;\r\ntos = cma_get_default_roce_tos(cma_dev, group->port_num);\r\ncma_configfs_params_put(cma_dev);\r\nreturn sprintf(buf, "%u\n", tos);\r\n}\r\nstatic ssize_t default_roce_tos_store(struct config_item *item,\r\nconst char *buf, size_t count)\r\n{\r\nstruct cma_device *cma_dev;\r\nstruct cma_dev_port_group *group;\r\nssize_t ret;\r\nu8 tos;\r\nret = kstrtou8(buf, 0, &tos);\r\nif (ret)\r\nreturn ret;\r\nret = cma_configfs_params_get(item, &cma_dev, &group);\r\nif (ret)\r\nreturn ret;\r\nret = cma_set_default_roce_tos(cma_dev, group->port_num, tos);\r\ncma_configfs_params_put(cma_dev);\r\nreturn ret ? ret : strnlen(buf, count);\r\n}\r\nstatic int make_cma_ports(struct cma_dev_group *cma_dev_group,\r\nstruct cma_device *cma_dev)\r\n{\r\nstruct ib_device *ibdev;\r\nunsigned int i;\r\nunsigned int ports_num;\r\nstruct cma_dev_port_group *ports;\r\nint err;\r\nibdev = cma_get_ib_dev(cma_dev);\r\nif (!ibdev)\r\nreturn -ENODEV;\r\nports_num = ibdev->phys_port_cnt;\r\nports = kcalloc(ports_num, sizeof(*cma_dev_group->ports),\r\nGFP_KERNEL);\r\nif (!ports) {\r\nerr = -ENOMEM;\r\ngoto free;\r\n}\r\nfor (i = 0; i < ports_num; i++) {\r\nchar port_str[10];\r\nports[i].port_num = i + 1;\r\nsnprintf(port_str, sizeof(port_str), "%u", i + 1);\r\nports[i].cma_dev_group = cma_dev_group;\r\nconfig_group_init_type_name(&ports[i].group,\r\nport_str,\r\n&cma_port_group_type);\r\nconfigfs_add_default_group(&ports[i].group,\r\n&cma_dev_group->ports_group);\r\n}\r\ncma_dev_group->ports = ports;\r\nreturn 0;\r\nfree:\r\nkfree(ports);\r\ncma_dev_group->ports = NULL;\r\nreturn err;\r\n}\r\nstatic void release_cma_dev(struct config_item *item)\r\n{\r\nstruct config_group *group = container_of(item, struct config_group,\r\ncg_item);\r\nstruct cma_dev_group *cma_dev_group = container_of(group,\r\nstruct cma_dev_group,\r\ndevice_group);\r\nkfree(cma_dev_group);\r\n}\r\nstatic void release_cma_ports_group(struct config_item *item)\r\n{\r\nstruct config_group *group = container_of(item, struct config_group,\r\ncg_item);\r\nstruct cma_dev_group *cma_dev_group = container_of(group,\r\nstruct cma_dev_group,\r\nports_group);\r\nkfree(cma_dev_group->ports);\r\ncma_dev_group->ports = NULL;\r\n}\r\nstatic struct config_group *make_cma_dev(struct config_group *group,\r\nconst char *name)\r\n{\r\nint err = -ENODEV;\r\nstruct cma_device *cma_dev = cma_enum_devices_by_ibdev(filter_by_name,\r\n(void *)name);\r\nstruct cma_dev_group *cma_dev_group = NULL;\r\nif (!cma_dev)\r\ngoto fail;\r\ncma_dev_group = kzalloc(sizeof(*cma_dev_group), GFP_KERNEL);\r\nif (!cma_dev_group) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nstrncpy(cma_dev_group->name, name, sizeof(cma_dev_group->name));\r\nconfig_group_init_type_name(&cma_dev_group->ports_group, "ports",\r\n&cma_ports_group_type);\r\nerr = make_cma_ports(cma_dev_group, cma_dev);\r\nif (err)\r\ngoto fail;\r\nconfig_group_init_type_name(&cma_dev_group->device_group, name,\r\n&cma_device_group_type);\r\nconfigfs_add_default_group(&cma_dev_group->ports_group,\r\n&cma_dev_group->device_group);\r\ncma_deref_dev(cma_dev);\r\nreturn &cma_dev_group->device_group;\r\nfail:\r\nif (cma_dev)\r\ncma_deref_dev(cma_dev);\r\nkfree(cma_dev_group);\r\nreturn ERR_PTR(err);\r\n}\r\nint __init cma_configfs_init(void)\r\n{\r\nconfig_group_init(&cma_subsys.su_group);\r\nmutex_init(&cma_subsys.su_mutex);\r\nreturn configfs_register_subsystem(&cma_subsys);\r\n}\r\nvoid __exit cma_configfs_exit(void)\r\n{\r\nconfigfs_unregister_subsystem(&cma_subsys);\r\n}
