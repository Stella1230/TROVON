static struct tcp_ulp_ops *tcp_ulp_find(const char *name)\r\n{\r\nstruct tcp_ulp_ops *e;\r\nlist_for_each_entry_rcu(e, &tcp_ulp_list, list) {\r\nif (strcmp(e->name, name) == 0)\r\nreturn e;\r\n}\r\nreturn NULL;\r\n}\r\nstatic const struct tcp_ulp_ops *__tcp_ulp_find_autoload(const char *name)\r\n{\r\nconst struct tcp_ulp_ops *ulp = NULL;\r\nrcu_read_lock();\r\nulp = tcp_ulp_find(name);\r\n#ifdef CONFIG_MODULES\r\nif (!ulp && capable(CAP_NET_ADMIN)) {\r\nrcu_read_unlock();\r\nrequest_module("%s", name);\r\nrcu_read_lock();\r\nulp = tcp_ulp_find(name);\r\n}\r\n#endif\r\nif (!ulp || !try_module_get(ulp->owner))\r\nulp = NULL;\r\nrcu_read_unlock();\r\nreturn ulp;\r\n}\r\nint tcp_register_ulp(struct tcp_ulp_ops *ulp)\r\n{\r\nint ret = 0;\r\nspin_lock(&tcp_ulp_list_lock);\r\nif (tcp_ulp_find(ulp->name)) {\r\npr_notice("%s already registered or non-unique name\n",\r\nulp->name);\r\nret = -EEXIST;\r\n} else {\r\nlist_add_tail_rcu(&ulp->list, &tcp_ulp_list);\r\n}\r\nspin_unlock(&tcp_ulp_list_lock);\r\nreturn ret;\r\n}\r\nvoid tcp_unregister_ulp(struct tcp_ulp_ops *ulp)\r\n{\r\nspin_lock(&tcp_ulp_list_lock);\r\nlist_del_rcu(&ulp->list);\r\nspin_unlock(&tcp_ulp_list_lock);\r\nsynchronize_rcu();\r\n}\r\nvoid tcp_get_available_ulp(char *buf, size_t maxlen)\r\n{\r\nstruct tcp_ulp_ops *ulp_ops;\r\nsize_t offs = 0;\r\n*buf = '\0';\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(ulp_ops, &tcp_ulp_list, list) {\r\noffs += snprintf(buf + offs, maxlen - offs,\r\n"%s%s",\r\noffs == 0 ? "" : " ", ulp_ops->name);\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid tcp_cleanup_ulp(struct sock *sk)\r\n{\r\nstruct inet_connection_sock *icsk = inet_csk(sk);\r\nif (!icsk->icsk_ulp_ops)\r\nreturn;\r\nif (icsk->icsk_ulp_ops->release)\r\nicsk->icsk_ulp_ops->release(sk);\r\nmodule_put(icsk->icsk_ulp_ops->owner);\r\n}\r\nint tcp_set_ulp(struct sock *sk, const char *name)\r\n{\r\nstruct inet_connection_sock *icsk = inet_csk(sk);\r\nconst struct tcp_ulp_ops *ulp_ops;\r\nint err = 0;\r\nif (icsk->icsk_ulp_ops)\r\nreturn -EEXIST;\r\nulp_ops = __tcp_ulp_find_autoload(name);\r\nif (!ulp_ops)\r\nreturn -ENOENT;\r\nerr = ulp_ops->init(sk);\r\nif (err) {\r\nmodule_put(ulp_ops->owner);\r\nreturn err;\r\n}\r\nicsk->icsk_ulp_ops = ulp_ops;\r\nreturn 0;\r\n}
