static void set_hw_cap(struct pp_hwmgr *hwmgr, bool setIt, enum phm_platform_caps cap)\r\n{\r\nif (setIt)\r\nphm_cap_set(hwmgr->platform_descriptor.platformCaps, cap);\r\nelse\r\nphm_cap_unset(hwmgr->platform_descriptor.platformCaps, cap);\r\n}\r\nstatic int set_platform_caps(struct pp_hwmgr *hwmgr, uint32_t powerplay_caps)\r\n{\r\nPP_ASSERT_WITH_CODE((~powerplay_caps & ____RETIRE16____),\r\n"ATOM_PP_PLATFORM_CAP_ASPM_L1 is not supported!", continue);\r\nPP_ASSERT_WITH_CODE((~powerplay_caps & ____RETIRE64____),\r\n"ATOM_PP_PLATFORM_CAP_GEMINIPRIMARY is not supported!", continue);\r\nPP_ASSERT_WITH_CODE((~powerplay_caps & ____RETIRE512____),\r\n"ATOM_PP_PLATFORM_CAP_SIDEPORTCONTROL is not supported!", continue);\r\nPP_ASSERT_WITH_CODE((~powerplay_caps & ____RETIRE1024____),\r\n"ATOM_PP_PLATFORM_CAP_TURNOFFPLL_ASPML1 is not supported!", continue);\r\nPP_ASSERT_WITH_CODE((~powerplay_caps & ____RETIRE2048____),\r\n"ATOM_PP_PLATFORM_CAP_HTLINKCONTROL is not supported!", continue);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_POWERPLAY),\r\nPHM_PlatformCaps_PowerPlaySupport\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_SBIOSPOWERSOURCE),\r\nPHM_PlatformCaps_BiosPowerSourceControl\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_HARDWAREDC),\r\nPHM_PlatformCaps_AutomaticDCTransition\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_MVDD_CONTROL),\r\nPHM_PlatformCaps_EnableMVDDControl\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_VDDCI_CONTROL),\r\nPHM_PlatformCaps_ControlVDDCI\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_VDDGFX_CONTROL),\r\nPHM_PlatformCaps_ControlVDDGFX\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_BACO),\r\nPHM_PlatformCaps_BACO\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_CAP_DISABLE_VOLTAGE_ISLAND),\r\nPHM_PlatformCaps_DisableVoltageIsland\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_TONGA_PP_PLATFORM_COMBINE_PCC_WITH_THERMAL_SIGNAL),\r\nPHM_PlatformCaps_CombinePCCWithThermalSignal\r\n);\r\nset_hw_cap(\r\nhwmgr,\r\n0 != (powerplay_caps & ATOM_TONGA_PLATFORM_LOAD_POST_PRODUCTION_FIRMWARE),\r\nPHM_PlatformCaps_LoadPostProductionFirmware\r\n);\r\nreturn 0;\r\n}\r\nstatic const void *get_powerplay_table(struct pp_hwmgr *hwmgr)\r\n{\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 size;\r\nu8 frev, crev;\r\nvoid *table_address = (void *)hwmgr->soft_pp_table;\r\nif (!table_address) {\r\ntable_address = (ATOM_Tonga_POWERPLAYTABLE *)\r\ncgs_atom_get_data_table(hwmgr->device,\r\nindex, &size, &frev, &crev);\r\nhwmgr->soft_pp_table = table_address;\r\nhwmgr->soft_pp_table_size = size;\r\n}\r\nreturn table_address;\r\n}\r\nstatic int get_vddc_lookup_table(\r\nstruct pp_hwmgr *hwmgr,\r\nphm_ppt_v1_voltage_lookup_table **lookup_table,\r\nconst ATOM_Tonga_Voltage_Lookup_Table *vddc_lookup_pp_tables,\r\nuint32_t max_levels\r\n)\r\n{\r\nuint32_t table_size, i;\r\nphm_ppt_v1_voltage_lookup_table *table;\r\nphm_ppt_v1_voltage_lookup_record *record;\r\nATOM_Tonga_Voltage_Lookup_Record *atom_record;\r\nPP_ASSERT_WITH_CODE((0 != vddc_lookup_pp_tables->ucNumEntries),\r\n"Invalid CAC Leakage PowerPlay Table!", return 1);\r\ntable_size = sizeof(uint32_t) +\r\nsizeof(phm_ppt_v1_voltage_lookup_record) * max_levels;\r\ntable = kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == table)\r\nreturn -ENOMEM;\r\nmemset(table, 0x00, table_size);\r\ntable->count = vddc_lookup_pp_tables->ucNumEntries;\r\nfor (i = 0; i < vddc_lookup_pp_tables->ucNumEntries; i++) {\r\nrecord = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nphm_ppt_v1_voltage_lookup_record,\r\nentries, table, i);\r\natom_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nATOM_Tonga_Voltage_Lookup_Record,\r\nentries, vddc_lookup_pp_tables, i);\r\nrecord->us_calculated = 0;\r\nrecord->us_vdd = atom_record->usVdd;\r\nrecord->us_cac_low = atom_record->usCACLow;\r\nrecord->us_cac_mid = atom_record->usCACMid;\r\nrecord->us_cac_high = atom_record->usCACHigh;\r\n}\r\n*lookup_table = table;\r\nreturn 0;\r\n}\r\nstatic int get_platform_power_management_table(\r\nstruct pp_hwmgr *hwmgr,\r\nATOM_Tonga_PPM_Table *atom_ppm_table)\r\n{\r\nstruct phm_ppm_table *ptr = kzalloc(sizeof(ATOM_Tonga_PPM_Table), GFP_KERNEL);\r\nstruct phm_ppt_v1_information *pp_table_information =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nif (NULL == ptr)\r\nreturn -ENOMEM;\r\nptr->ppm_design\r\n= atom_ppm_table->ucPpmDesign;\r\nptr->cpu_core_number\r\n= atom_ppm_table->usCpuCoreNumber;\r\nptr->platform_tdp\r\n= atom_ppm_table->ulPlatformTDP;\r\nptr->small_ac_platform_tdp\r\n= atom_ppm_table->ulSmallACPlatformTDP;\r\nptr->platform_tdc\r\n= atom_ppm_table->ulPlatformTDC;\r\nptr->small_ac_platform_tdc\r\n= atom_ppm_table->ulSmallACPlatformTDC;\r\nptr->apu_tdp\r\n= atom_ppm_table->ulApuTDP;\r\nptr->dgpu_tdp\r\n= atom_ppm_table->ulDGpuTDP;\r\nptr->dgpu_ulv_power\r\n= atom_ppm_table->ulDGpuUlvPower;\r\nptr->tj_max\r\n= atom_ppm_table->ulTjmax;\r\npp_table_information->ppm_parameter_table = ptr;\r\nreturn 0;\r\n}\r\nstatic int init_dpm_2_parameters(\r\nstruct pp_hwmgr *hwmgr,\r\nconst ATOM_Tonga_POWERPLAYTABLE *powerplay_table\r\n)\r\n{\r\nint result = 0;\r\nstruct phm_ppt_v1_information *pp_table_information = (struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nATOM_Tonga_PPM_Table *atom_ppm_table;\r\nuint32_t disable_ppm = 0;\r\nuint32_t disable_power_control = 0;\r\npp_table_information->us_ulv_voltage_offset =\r\nle16_to_cpu(powerplay_table->usUlvVoltageOffset);\r\npp_table_information->ppm_parameter_table = NULL;\r\npp_table_information->vddc_lookup_table = NULL;\r\npp_table_information->vddgfx_lookup_table = NULL;\r\nhwmgr->platform_descriptor.TDPODLimit =\r\nle16_to_cpu(powerplay_table->usPowerControlLimit);\r\nhwmgr->platform_descriptor.TDPAdjustment = 0;\r\nhwmgr->platform_descriptor.VidAdjustment = 0;\r\nhwmgr->platform_descriptor.VidAdjustmentPolarity = 0;\r\nhwmgr->platform_descriptor.VidMinLimit = 0;\r\nhwmgr->platform_descriptor.VidMaxLimit = 1500000;\r\nhwmgr->platform_descriptor.VidStep = 6250;\r\ndisable_power_control = 0;\r\nif (0 == disable_power_control) {\r\nif (hwmgr->platform_descriptor.TDPODLimit != 0)\r\nphm_cap_set(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_PowerControl);\r\n}\r\nif (0 != powerplay_table->usVddcLookupTableOffset) {\r\nconst ATOM_Tonga_Voltage_Lookup_Table *pVddcCACTable =\r\n(ATOM_Tonga_Voltage_Lookup_Table *)(((unsigned long)powerplay_table) +\r\nle16_to_cpu(powerplay_table->usVddcLookupTableOffset));\r\nresult = get_vddc_lookup_table(hwmgr,\r\n&pp_table_information->vddc_lookup_table, pVddcCACTable, 16);\r\n}\r\nif (0 != powerplay_table->usVddgfxLookupTableOffset) {\r\nconst ATOM_Tonga_Voltage_Lookup_Table *pVddgfxCACTable =\r\n(ATOM_Tonga_Voltage_Lookup_Table *)(((unsigned long)powerplay_table) +\r\nle16_to_cpu(powerplay_table->usVddgfxLookupTableOffset));\r\nresult = get_vddc_lookup_table(hwmgr,\r\n&pp_table_information->vddgfx_lookup_table, pVddgfxCACTable, 16);\r\n}\r\ndisable_ppm = 0;\r\nif (0 == disable_ppm) {\r\natom_ppm_table = (ATOM_Tonga_PPM_Table *)\r\n(((unsigned long)powerplay_table) + le16_to_cpu(powerplay_table->usPPMTableOffset));\r\nif (0 != powerplay_table->usPPMTableOffset) {\r\nif (get_platform_power_management_table(hwmgr, atom_ppm_table) == 0) {\r\nphm_cap_set(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_EnablePlatformPowerManagement);\r\n}\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int get_valid_clk(\r\nstruct pp_hwmgr *hwmgr,\r\nstruct phm_clock_array **clk_table,\r\nphm_ppt_v1_clock_voltage_dependency_table const *clk_volt_pp_table\r\n)\r\n{\r\nuint32_t table_size, i;\r\nstruct phm_clock_array *table;\r\nphm_ppt_v1_clock_voltage_dependency_record *dep_record;\r\nPP_ASSERT_WITH_CODE((0 != clk_volt_pp_table->count),\r\n"Invalid PowerPlay Table!", return -1);\r\ntable_size = sizeof(uint32_t) +\r\nsizeof(uint32_t) * clk_volt_pp_table->count;\r\ntable = kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == table)\r\nreturn -ENOMEM;\r\nmemset(table, 0x00, table_size);\r\ntable->count = (uint32_t)clk_volt_pp_table->count;\r\nfor (i = 0; i < table->count; i++) {\r\ndep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nphm_ppt_v1_clock_voltage_dependency_record,\r\nentries, clk_volt_pp_table, i);\r\ntable->values[i] = (uint32_t)dep_record->clk;\r\n}\r\n*clk_table = table;\r\nreturn 0;\r\n}\r\nstatic int get_hard_limits(\r\nstruct pp_hwmgr *hwmgr,\r\nstruct phm_clock_and_voltage_limits *limits,\r\nATOM_Tonga_Hard_Limit_Table const *limitable\r\n)\r\n{\r\nPP_ASSERT_WITH_CODE((0 != limitable->ucNumEntries), "Invalid PowerPlay Table!", return -1);\r\nlimits->sclk = (uint32_t)limitable->entries[0].ulSCLKLimit;\r\nlimits->mclk = (uint32_t)limitable->entries[0].ulMCLKLimit;\r\nlimits->vddc = (uint16_t)limitable->entries[0].usVddcLimit;\r\nlimits->vddci = (uint16_t)limitable->entries[0].usVddciLimit;\r\nlimits->vddgfx = (uint16_t)limitable->entries[0].usVddgfxLimit;\r\nreturn 0;\r\n}\r\nstatic int get_mclk_voltage_dependency_table(\r\nstruct pp_hwmgr *hwmgr,\r\nphm_ppt_v1_clock_voltage_dependency_table **pp_tonga_mclk_dep_table,\r\nATOM_Tonga_MCLK_Dependency_Table const *mclk_dep_table\r\n)\r\n{\r\nuint32_t table_size, i;\r\nphm_ppt_v1_clock_voltage_dependency_table *mclk_table;\r\nphm_ppt_v1_clock_voltage_dependency_record *mclk_table_record;\r\nATOM_Tonga_MCLK_Dependency_Record *mclk_dep_record;\r\nPP_ASSERT_WITH_CODE((0 != mclk_dep_table->ucNumEntries),\r\n"Invalid PowerPlay Table!", return -1);\r\ntable_size = sizeof(uint32_t) + sizeof(phm_ppt_v1_clock_voltage_dependency_record)\r\n* mclk_dep_table->ucNumEntries;\r\nmclk_table = kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == mclk_table)\r\nreturn -ENOMEM;\r\nmemset(mclk_table, 0x00, table_size);\r\nmclk_table->count = (uint32_t)mclk_dep_table->ucNumEntries;\r\nfor (i = 0; i < mclk_dep_table->ucNumEntries; i++) {\r\nmclk_table_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nphm_ppt_v1_clock_voltage_dependency_record,\r\nentries, mclk_table, i);\r\nmclk_dep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nATOM_Tonga_MCLK_Dependency_Record,\r\nentries, mclk_dep_table, i);\r\nmclk_table_record->vddInd = mclk_dep_record->ucVddcInd;\r\nmclk_table_record->vdd_offset = mclk_dep_record->usVddgfxOffset;\r\nmclk_table_record->vddci = mclk_dep_record->usVddci;\r\nmclk_table_record->mvdd = mclk_dep_record->usMvdd;\r\nmclk_table_record->clk = mclk_dep_record->ulMclk;\r\n}\r\n*pp_tonga_mclk_dep_table = mclk_table;\r\nreturn 0;\r\n}\r\nstatic int get_sclk_voltage_dependency_table(\r\nstruct pp_hwmgr *hwmgr,\r\nphm_ppt_v1_clock_voltage_dependency_table **pp_tonga_sclk_dep_table,\r\nPPTable_Generic_SubTable_Header const *sclk_dep_table\r\n)\r\n{\r\nuint32_t table_size, i;\r\nphm_ppt_v1_clock_voltage_dependency_table *sclk_table;\r\nphm_ppt_v1_clock_voltage_dependency_record *sclk_table_record;\r\nif (sclk_dep_table->ucRevId < 1) {\r\nconst ATOM_Tonga_SCLK_Dependency_Table *tonga_table =\r\n(ATOM_Tonga_SCLK_Dependency_Table *)sclk_dep_table;\r\nATOM_Tonga_SCLK_Dependency_Record *sclk_dep_record;\r\nPP_ASSERT_WITH_CODE((0 != tonga_table->ucNumEntries),\r\n"Invalid PowerPlay Table!", return -1);\r\ntable_size = sizeof(uint32_t) + sizeof(phm_ppt_v1_clock_voltage_dependency_record)\r\n* tonga_table->ucNumEntries;\r\nsclk_table = kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == sclk_table)\r\nreturn -ENOMEM;\r\nmemset(sclk_table, 0x00, table_size);\r\nsclk_table->count = (uint32_t)tonga_table->ucNumEntries;\r\nfor (i = 0; i < tonga_table->ucNumEntries; i++) {\r\nsclk_dep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nATOM_Tonga_SCLK_Dependency_Record,\r\nentries, tonga_table, i);\r\nsclk_table_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nphm_ppt_v1_clock_voltage_dependency_record,\r\nentries, sclk_table, i);\r\nsclk_table_record->vddInd = sclk_dep_record->ucVddInd;\r\nsclk_table_record->vdd_offset = sclk_dep_record->usVddcOffset;\r\nsclk_table_record->clk = sclk_dep_record->ulSclk;\r\nsclk_table_record->cks_enable =\r\n(((sclk_dep_record->ucCKSVOffsetandDisable & 0x80) >> 7) == 0) ? 1 : 0;\r\nsclk_table_record->cks_voffset = (sclk_dep_record->ucCKSVOffsetandDisable & 0x7F);\r\n}\r\n} else {\r\nconst ATOM_Polaris_SCLK_Dependency_Table *polaris_table =\r\n(ATOM_Polaris_SCLK_Dependency_Table *)sclk_dep_table;\r\nATOM_Polaris_SCLK_Dependency_Record *sclk_dep_record;\r\nPP_ASSERT_WITH_CODE((0 != polaris_table->ucNumEntries),\r\n"Invalid PowerPlay Table!", return -1);\r\ntable_size = sizeof(uint32_t) + sizeof(phm_ppt_v1_clock_voltage_dependency_record)\r\n* polaris_table->ucNumEntries;\r\nsclk_table = kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == sclk_table)\r\nreturn -ENOMEM;\r\nmemset(sclk_table, 0x00, table_size);\r\nsclk_table->count = (uint32_t)polaris_table->ucNumEntries;\r\nfor (i = 0; i < polaris_table->ucNumEntries; i++) {\r\nsclk_dep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nATOM_Polaris_SCLK_Dependency_Record,\r\nentries, polaris_table, i);\r\nsclk_table_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nphm_ppt_v1_clock_voltage_dependency_record,\r\nentries, sclk_table, i);\r\nsclk_table_record->vddInd = sclk_dep_record->ucVddInd;\r\nsclk_table_record->vdd_offset = sclk_dep_record->usVddcOffset;\r\nsclk_table_record->clk = sclk_dep_record->ulSclk;\r\nsclk_table_record->cks_enable =\r\n(((sclk_dep_record->ucCKSVOffsetandDisable & 0x80) >> 7) == 0) ? 1 : 0;\r\nsclk_table_record->cks_voffset = (sclk_dep_record->ucCKSVOffsetandDisable & 0x7F);\r\nsclk_table_record->sclk_offset = sclk_dep_record->ulSclkOffset;\r\n}\r\n}\r\n*pp_tonga_sclk_dep_table = sclk_table;\r\nreturn 0;\r\n}\r\nstatic int get_pcie_table(\r\nstruct pp_hwmgr *hwmgr,\r\nphm_ppt_v1_pcie_table **pp_tonga_pcie_table,\r\nPPTable_Generic_SubTable_Header const *ptable\r\n)\r\n{\r\nuint32_t table_size, i, pcie_count;\r\nphm_ppt_v1_pcie_table *pcie_table;\r\nstruct phm_ppt_v1_information *pp_table_information =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nphm_ppt_v1_pcie_record *pcie_record;\r\nif (ptable->ucRevId < 1) {\r\nconst ATOM_Tonga_PCIE_Table *atom_pcie_table = (ATOM_Tonga_PCIE_Table *)ptable;\r\nATOM_Tonga_PCIE_Record *atom_pcie_record;\r\nPP_ASSERT_WITH_CODE((atom_pcie_table->ucNumEntries != 0),\r\n"Invalid PowerPlay Table!", return -1);\r\ntable_size = sizeof(uint32_t) +\r\nsizeof(phm_ppt_v1_pcie_record) * atom_pcie_table->ucNumEntries;\r\npcie_table = kzalloc(table_size, GFP_KERNEL);\r\nif (pcie_table == NULL)\r\nreturn -ENOMEM;\r\nmemset(pcie_table, 0x00, table_size);\r\npcie_count = (pp_table_information->vdd_dep_on_sclk->count) + 1;\r\nif ((uint32_t)atom_pcie_table->ucNumEntries <= pcie_count)\r\npcie_count = (uint32_t)atom_pcie_table->ucNumEntries;\r\nelse\r\npr_err("Number of Pcie Entries exceed the number of SCLK Dpm Levels! \\r\nDisregarding the excess entries... \n");\r\npcie_table->count = pcie_count;\r\nfor (i = 0; i < pcie_count; i++) {\r\npcie_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nphm_ppt_v1_pcie_record,\r\nentries, pcie_table, i);\r\natom_pcie_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nATOM_Tonga_PCIE_Record,\r\nentries, atom_pcie_table, i);\r\npcie_record->gen_speed = atom_pcie_record->ucPCIEGenSpeed;\r\npcie_record->lane_width = atom_pcie_record->usPCIELaneWidth;\r\n}\r\n*pp_tonga_pcie_table = pcie_table;\r\n} else {\r\nconst ATOM_Polaris10_PCIE_Table *atom_pcie_table = (ATOM_Polaris10_PCIE_Table *)ptable;\r\nATOM_Polaris10_PCIE_Record *atom_pcie_record;\r\nPP_ASSERT_WITH_CODE((atom_pcie_table->ucNumEntries != 0),\r\n"Invalid PowerPlay Table!", return -1);\r\ntable_size = sizeof(uint32_t) +\r\nsizeof(phm_ppt_v1_pcie_record) * atom_pcie_table->ucNumEntries;\r\npcie_table = kzalloc(table_size, GFP_KERNEL);\r\nif (pcie_table == NULL)\r\nreturn -ENOMEM;\r\nmemset(pcie_table, 0x00, table_size);\r\npcie_count = (pp_table_information->vdd_dep_on_sclk->count) + 1;\r\nif ((uint32_t)atom_pcie_table->ucNumEntries <= pcie_count)\r\npcie_count = (uint32_t)atom_pcie_table->ucNumEntries;\r\nelse\r\npr_err("Number of Pcie Entries exceed the number of SCLK Dpm Levels! \\r\nDisregarding the excess entries... \n");\r\npcie_table->count = pcie_count;\r\nfor (i = 0; i < pcie_count; i++) {\r\npcie_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nphm_ppt_v1_pcie_record,\r\nentries, pcie_table, i);\r\natom_pcie_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nATOM_Polaris10_PCIE_Record,\r\nentries, atom_pcie_table, i);\r\npcie_record->gen_speed = atom_pcie_record->ucPCIEGenSpeed;\r\npcie_record->lane_width = atom_pcie_record->usPCIELaneWidth;\r\npcie_record->pcie_sclk = atom_pcie_record->ulPCIE_Sclk;\r\n}\r\n*pp_tonga_pcie_table = pcie_table;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_cac_tdp_table(\r\nstruct pp_hwmgr *hwmgr,\r\nstruct phm_cac_tdp_table **cac_tdp_table,\r\nconst PPTable_Generic_SubTable_Header * table\r\n)\r\n{\r\nuint32_t table_size;\r\nstruct phm_cac_tdp_table *tdp_table;\r\ntable_size = sizeof(uint32_t) + sizeof(struct phm_cac_tdp_table);\r\ntdp_table = kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == tdp_table)\r\nreturn -ENOMEM;\r\nmemset(tdp_table, 0x00, table_size);\r\nhwmgr->dyn_state.cac_dtp_table = kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == hwmgr->dyn_state.cac_dtp_table) {\r\nkfree(tdp_table);\r\nreturn -ENOMEM;\r\n}\r\nmemset(hwmgr->dyn_state.cac_dtp_table, 0x00, table_size);\r\nif (table->ucRevId < 3) {\r\nconst ATOM_Tonga_PowerTune_Table *tonga_table =\r\n(ATOM_Tonga_PowerTune_Table *)table;\r\ntdp_table->usTDP = tonga_table->usTDP;\r\ntdp_table->usConfigurableTDP =\r\ntonga_table->usConfigurableTDP;\r\ntdp_table->usTDC = tonga_table->usTDC;\r\ntdp_table->usBatteryPowerLimit =\r\ntonga_table->usBatteryPowerLimit;\r\ntdp_table->usSmallPowerLimit =\r\ntonga_table->usSmallPowerLimit;\r\ntdp_table->usLowCACLeakage =\r\ntonga_table->usLowCACLeakage;\r\ntdp_table->usHighCACLeakage =\r\ntonga_table->usHighCACLeakage;\r\ntdp_table->usMaximumPowerDeliveryLimit =\r\ntonga_table->usMaximumPowerDeliveryLimit;\r\ntdp_table->usDefaultTargetOperatingTemp =\r\ntonga_table->usTjMax;\r\ntdp_table->usTargetOperatingTemp =\r\ntonga_table->usTjMax;\r\ntdp_table->usPowerTuneDataSetID =\r\ntonga_table->usPowerTuneDataSetID;\r\ntdp_table->usSoftwareShutdownTemp =\r\ntonga_table->usSoftwareShutdownTemp;\r\ntdp_table->usClockStretchAmount =\r\ntonga_table->usClockStretchAmount;\r\n} else {\r\nconst ATOM_Fiji_PowerTune_Table *fijitable =\r\n(ATOM_Fiji_PowerTune_Table *)table;\r\ntdp_table->usTDP = fijitable->usTDP;\r\ntdp_table->usConfigurableTDP = fijitable->usConfigurableTDP;\r\ntdp_table->usTDC = fijitable->usTDC;\r\ntdp_table->usBatteryPowerLimit = fijitable->usBatteryPowerLimit;\r\ntdp_table->usSmallPowerLimit = fijitable->usSmallPowerLimit;\r\ntdp_table->usLowCACLeakage = fijitable->usLowCACLeakage;\r\ntdp_table->usHighCACLeakage = fijitable->usHighCACLeakage;\r\ntdp_table->usMaximumPowerDeliveryLimit =\r\nfijitable->usMaximumPowerDeliveryLimit;\r\ntdp_table->usDefaultTargetOperatingTemp =\r\nfijitable->usTjMax;\r\ntdp_table->usTargetOperatingTemp =\r\nfijitable->usTjMax;\r\ntdp_table->usPowerTuneDataSetID =\r\nfijitable->usPowerTuneDataSetID;\r\ntdp_table->usSoftwareShutdownTemp =\r\nfijitable->usSoftwareShutdownTemp;\r\ntdp_table->usClockStretchAmount =\r\nfijitable->usClockStretchAmount;\r\ntdp_table->usTemperatureLimitHotspot =\r\nfijitable->usTemperatureLimitHotspot;\r\ntdp_table->usTemperatureLimitLiquid1 =\r\nfijitable->usTemperatureLimitLiquid1;\r\ntdp_table->usTemperatureLimitLiquid2 =\r\nfijitable->usTemperatureLimitLiquid2;\r\ntdp_table->usTemperatureLimitVrVddc =\r\nfijitable->usTemperatureLimitVrVddc;\r\ntdp_table->usTemperatureLimitVrMvdd =\r\nfijitable->usTemperatureLimitVrMvdd;\r\ntdp_table->usTemperatureLimitPlx =\r\nfijitable->usTemperatureLimitPlx;\r\ntdp_table->ucLiquid1_I2C_address =\r\nfijitable->ucLiquid1_I2C_address;\r\ntdp_table->ucLiquid2_I2C_address =\r\nfijitable->ucLiquid2_I2C_address;\r\ntdp_table->ucLiquid_I2C_Line =\r\nfijitable->ucLiquid_I2C_Line;\r\ntdp_table->ucVr_I2C_address = fijitable->ucVr_I2C_address;\r\ntdp_table->ucVr_I2C_Line = fijitable->ucVr_I2C_Line;\r\ntdp_table->ucPlx_I2C_address = fijitable->ucPlx_I2C_address;\r\ntdp_table->ucPlx_I2C_Line = fijitable->ucPlx_I2C_Line;\r\n}\r\n*cac_tdp_table = tdp_table;\r\nreturn 0;\r\n}\r\nstatic int get_mm_clock_voltage_table(\r\nstruct pp_hwmgr *hwmgr,\r\nphm_ppt_v1_mm_clock_voltage_dependency_table **tonga_mm_table,\r\nconst ATOM_Tonga_MM_Dependency_Table * mm_dependency_table\r\n)\r\n{\r\nuint32_t table_size, i;\r\nconst ATOM_Tonga_MM_Dependency_Record *mm_dependency_record;\r\nphm_ppt_v1_mm_clock_voltage_dependency_table *mm_table;\r\nphm_ppt_v1_mm_clock_voltage_dependency_record *mm_table_record;\r\nPP_ASSERT_WITH_CODE((0 != mm_dependency_table->ucNumEntries),\r\n"Invalid PowerPlay Table!", return -1);\r\ntable_size = sizeof(uint32_t) +\r\nsizeof(phm_ppt_v1_mm_clock_voltage_dependency_record)\r\n* mm_dependency_table->ucNumEntries;\r\nmm_table = kzalloc(table_size, GFP_KERNEL);\r\nif (NULL == mm_table)\r\nreturn -ENOMEM;\r\nmemset(mm_table, 0x00, table_size);\r\nmm_table->count = mm_dependency_table->ucNumEntries;\r\nfor (i = 0; i < mm_dependency_table->ucNumEntries; i++) {\r\nmm_dependency_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nATOM_Tonga_MM_Dependency_Record,\r\nentries, mm_dependency_table, i);\r\nmm_table_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nphm_ppt_v1_mm_clock_voltage_dependency_record,\r\nentries, mm_table, i);\r\nmm_table_record->vddcInd = mm_dependency_record->ucVddcInd;\r\nmm_table_record->vddgfx_offset = mm_dependency_record->usVddgfxOffset;\r\nmm_table_record->aclk = mm_dependency_record->ulAClk;\r\nmm_table_record->samclock = mm_dependency_record->ulSAMUClk;\r\nmm_table_record->eclk = mm_dependency_record->ulEClk;\r\nmm_table_record->vclk = mm_dependency_record->ulVClk;\r\nmm_table_record->dclk = mm_dependency_record->ulDClk;\r\n}\r\n*tonga_mm_table = mm_table;\r\nreturn 0;\r\n}\r\nstatic int init_clock_voltage_dependency(\r\nstruct pp_hwmgr *hwmgr,\r\nconst ATOM_Tonga_POWERPLAYTABLE *powerplay_table\r\n)\r\n{\r\nint result = 0;\r\nstruct phm_ppt_v1_information *pp_table_information =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nconst ATOM_Tonga_MM_Dependency_Table *mm_dependency_table =\r\n(const ATOM_Tonga_MM_Dependency_Table *)(((unsigned long) powerplay_table) +\r\nle16_to_cpu(powerplay_table->usMMDependencyTableOffset));\r\nconst PPTable_Generic_SubTable_Header *pPowerTuneTable =\r\n(const PPTable_Generic_SubTable_Header *)(((unsigned long) powerplay_table) +\r\nle16_to_cpu(powerplay_table->usPowerTuneTableOffset));\r\nconst ATOM_Tonga_MCLK_Dependency_Table *mclk_dep_table =\r\n(const ATOM_Tonga_MCLK_Dependency_Table *)(((unsigned long) powerplay_table) +\r\nle16_to_cpu(powerplay_table->usMclkDependencyTableOffset));\r\nconst PPTable_Generic_SubTable_Header *sclk_dep_table =\r\n(const PPTable_Generic_SubTable_Header *)(((unsigned long) powerplay_table) +\r\nle16_to_cpu(powerplay_table->usSclkDependencyTableOffset));\r\nconst ATOM_Tonga_Hard_Limit_Table *pHardLimits =\r\n(const ATOM_Tonga_Hard_Limit_Table *)(((unsigned long) powerplay_table) +\r\nle16_to_cpu(powerplay_table->usHardLimitTableOffset));\r\nconst PPTable_Generic_SubTable_Header *pcie_table =\r\n(const PPTable_Generic_SubTable_Header *)(((unsigned long) powerplay_table) +\r\nle16_to_cpu(powerplay_table->usPCIETableOffset));\r\npp_table_information->vdd_dep_on_sclk = NULL;\r\npp_table_information->vdd_dep_on_mclk = NULL;\r\npp_table_information->mm_dep_table = NULL;\r\npp_table_information->pcie_table = NULL;\r\nif (powerplay_table->usMMDependencyTableOffset != 0)\r\nresult = get_mm_clock_voltage_table(hwmgr,\r\n&pp_table_information->mm_dep_table, mm_dependency_table);\r\nif (result == 0 && powerplay_table->usPowerTuneTableOffset != 0)\r\nresult = get_cac_tdp_table(hwmgr,\r\n&pp_table_information->cac_dtp_table, pPowerTuneTable);\r\nif (result == 0 && powerplay_table->usSclkDependencyTableOffset != 0)\r\nresult = get_sclk_voltage_dependency_table(hwmgr,\r\n&pp_table_information->vdd_dep_on_sclk, sclk_dep_table);\r\nif (result == 0 && powerplay_table->usMclkDependencyTableOffset != 0)\r\nresult = get_mclk_voltage_dependency_table(hwmgr,\r\n&pp_table_information->vdd_dep_on_mclk, mclk_dep_table);\r\nif (result == 0 && powerplay_table->usPCIETableOffset != 0)\r\nresult = get_pcie_table(hwmgr,\r\n&pp_table_information->pcie_table, pcie_table);\r\nif (result == 0 && powerplay_table->usHardLimitTableOffset != 0)\r\nresult = get_hard_limits(hwmgr,\r\n&pp_table_information->max_clock_voltage_on_dc, pHardLimits);\r\nhwmgr->dyn_state.max_clock_voltage_on_dc.sclk =\r\npp_table_information->max_clock_voltage_on_dc.sclk;\r\nhwmgr->dyn_state.max_clock_voltage_on_dc.mclk =\r\npp_table_information->max_clock_voltage_on_dc.mclk;\r\nhwmgr->dyn_state.max_clock_voltage_on_dc.vddc =\r\npp_table_information->max_clock_voltage_on_dc.vddc;\r\nhwmgr->dyn_state.max_clock_voltage_on_dc.vddci =\r\npp_table_information->max_clock_voltage_on_dc.vddci;\r\nif (result == 0 && (NULL != pp_table_information->vdd_dep_on_mclk)\r\n&& (0 != pp_table_information->vdd_dep_on_mclk->count))\r\nresult = get_valid_clk(hwmgr, &pp_table_information->valid_mclk_values,\r\npp_table_information->vdd_dep_on_mclk);\r\nif (result == 0 && (NULL != pp_table_information->vdd_dep_on_sclk)\r\n&& (0 != pp_table_information->vdd_dep_on_sclk->count))\r\nresult = get_valid_clk(hwmgr, &pp_table_information->valid_sclk_values,\r\npp_table_information->vdd_dep_on_sclk);\r\nreturn result;\r\n}\r\nstatic int init_over_drive_limits(\r\nstruct pp_hwmgr *hwmgr,\r\nconst ATOM_Tonga_POWERPLAYTABLE *powerplay_table)\r\n{\r\nhwmgr->platform_descriptor.overdriveLimit.engineClock =\r\nle16_to_cpu(powerplay_table->ulMaxODEngineClock);\r\nhwmgr->platform_descriptor.overdriveLimit.memoryClock =\r\nle16_to_cpu(powerplay_table->ulMaxODMemoryClock);\r\nhwmgr->platform_descriptor.minOverdriveVDDC = 0;\r\nhwmgr->platform_descriptor.maxOverdriveVDDC = 0;\r\nhwmgr->platform_descriptor.overdriveVDDCStep = 0;\r\nif (hwmgr->platform_descriptor.overdriveLimit.engineClock > 0 \\r\n&& hwmgr->platform_descriptor.overdriveLimit.memoryClock > 0) {\r\nphm_cap_set(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_ACOverdriveSupport);\r\n}\r\nreturn 0;\r\n}\r\nstatic int init_thermal_controller(\r\nstruct pp_hwmgr *hwmgr,\r\nconst ATOM_Tonga_POWERPLAYTABLE *powerplay_table\r\n)\r\n{\r\nconst PPTable_Generic_SubTable_Header *fan_table;\r\nATOM_Tonga_Thermal_Controller *thermal_controller;\r\nthermal_controller = (ATOM_Tonga_Thermal_Controller *)\r\n(((unsigned long)powerplay_table) +\r\nle16_to_cpu(powerplay_table->usThermalControllerOffset));\r\nPP_ASSERT_WITH_CODE((0 != powerplay_table->usThermalControllerOffset),\r\n"Thermal controller table not set!", return -1);\r\nhwmgr->thermal_controller.ucType = thermal_controller->ucType;\r\nhwmgr->thermal_controller.ucI2cLine = thermal_controller->ucI2cLine;\r\nhwmgr->thermal_controller.ucI2cAddress = thermal_controller->ucI2cAddress;\r\nhwmgr->thermal_controller.fanInfo.bNoFan =\r\n(0 != (thermal_controller->ucFanParameters & ATOM_TONGA_PP_FANPARAMETERS_NOFAN));\r\nhwmgr->thermal_controller.fanInfo.ucTachometerPulsesPerRevolution =\r\nthermal_controller->ucFanParameters &\r\nATOM_TONGA_PP_FANPARAMETERS_TACHOMETER_PULSES_PER_REVOLUTION_MASK;\r\nhwmgr->thermal_controller.fanInfo.ulMinRPM\r\n= thermal_controller->ucFanMinRPM * 100UL;\r\nhwmgr->thermal_controller.fanInfo.ulMaxRPM\r\n= thermal_controller->ucFanMaxRPM * 100UL;\r\nset_hw_cap(\r\nhwmgr,\r\nATOM_TONGA_PP_THERMALCONTROLLER_NONE != hwmgr->thermal_controller.ucType,\r\nPHM_PlatformCaps_ThermalController\r\n);\r\nif (0 == powerplay_table->usFanTableOffset)\r\nreturn 0;\r\nfan_table = (const PPTable_Generic_SubTable_Header *)\r\n(((unsigned long)powerplay_table) +\r\nle16_to_cpu(powerplay_table->usFanTableOffset));\r\nPP_ASSERT_WITH_CODE((0 != powerplay_table->usFanTableOffset),\r\n"Fan table not set!", return -1);\r\nPP_ASSERT_WITH_CODE((0 < fan_table->ucRevId),\r\n"Unsupported fan table format!", return -1);\r\nhwmgr->thermal_controller.advanceFanControlParameters.ulCycleDelay\r\n= 100000;\r\nphm_cap_set(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_MicrocodeFanControl);\r\nif (fan_table->ucRevId < 8) {\r\nconst ATOM_Tonga_Fan_Table *tonga_fan_table =\r\n(ATOM_Tonga_Fan_Table *)fan_table;\r\nhwmgr->thermal_controller.advanceFanControlParameters.ucTHyst\r\n= tonga_fan_table->ucTHyst;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usTMin\r\n= tonga_fan_table->usTMin;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usTMed\r\n= tonga_fan_table->usTMed;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usTHigh\r\n= tonga_fan_table->usTHigh;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usPWMMin\r\n= tonga_fan_table->usPWMMin;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usPWMMed\r\n= tonga_fan_table->usPWMMed;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usPWMHigh\r\n= tonga_fan_table->usPWMHigh;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usTMax\r\n= 10900;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usTMax\r\n= tonga_fan_table->usTMax;\r\nhwmgr->thermal_controller.advanceFanControlParameters.ucFanControlMode\r\n= tonga_fan_table->ucFanControlMode;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usDefaultMaxFanPWM\r\n= tonga_fan_table->usFanPWMMax;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usDefaultFanOutputSensitivity\r\n= 4836;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity\r\n= tonga_fan_table->usFanOutputSensitivity;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usDefaultMaxFanRPM\r\n= tonga_fan_table->usFanRPMMax;\r\nhwmgr->thermal_controller.advanceFanControlParameters.ulMinFanSCLKAcousticLimit\r\n= (tonga_fan_table->ulMinFanSCLKAcousticLimit / 100);\r\nhwmgr->thermal_controller.advanceFanControlParameters.ucTargetTemperature\r\n= tonga_fan_table->ucTargetTemperature;\r\nhwmgr->thermal_controller.advanceFanControlParameters.ucMinimumPWMLimit\r\n= tonga_fan_table->ucMinimumPWMLimit;\r\n} else {\r\nconst ATOM_Fiji_Fan_Table *fiji_fan_table =\r\n(ATOM_Fiji_Fan_Table *)fan_table;\r\nhwmgr->thermal_controller.advanceFanControlParameters.ucTHyst\r\n= fiji_fan_table->ucTHyst;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usTMin\r\n= fiji_fan_table->usTMin;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usTMed\r\n= fiji_fan_table->usTMed;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usTHigh\r\n= fiji_fan_table->usTHigh;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usPWMMin\r\n= fiji_fan_table->usPWMMin;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usPWMMed\r\n= fiji_fan_table->usPWMMed;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usPWMHigh\r\n= fiji_fan_table->usPWMHigh;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usTMax\r\n= fiji_fan_table->usTMax;\r\nhwmgr->thermal_controller.advanceFanControlParameters.ucFanControlMode\r\n= fiji_fan_table->ucFanControlMode;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usDefaultMaxFanPWM\r\n= fiji_fan_table->usFanPWMMax;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usDefaultFanOutputSensitivity\r\n= 4836;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity\r\n= fiji_fan_table->usFanOutputSensitivity;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usDefaultMaxFanRPM\r\n= fiji_fan_table->usFanRPMMax;\r\nhwmgr->thermal_controller.advanceFanControlParameters.ulMinFanSCLKAcousticLimit\r\n= (fiji_fan_table->ulMinFanSCLKAcousticLimit / 100);\r\nhwmgr->thermal_controller.advanceFanControlParameters.ucTargetTemperature\r\n= fiji_fan_table->ucTargetTemperature;\r\nhwmgr->thermal_controller.advanceFanControlParameters.ucMinimumPWMLimit\r\n= fiji_fan_table->ucMinimumPWMLimit;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usFanGainEdge\r\n= fiji_fan_table->usFanGainEdge;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usFanGainHotspot\r\n= fiji_fan_table->usFanGainHotspot;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usFanGainLiquid\r\n= fiji_fan_table->usFanGainLiquid;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usFanGainVrVddc\r\n= fiji_fan_table->usFanGainVrVddc;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usFanGainVrMvdd\r\n= fiji_fan_table->usFanGainVrMvdd;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usFanGainPlx\r\n= fiji_fan_table->usFanGainPlx;\r\nhwmgr->thermal_controller.advanceFanControlParameters.usFanGainHbm\r\n= fiji_fan_table->usFanGainHbm;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_powerplay_tables(\r\nstruct pp_hwmgr *hwmgr,\r\nconst ATOM_Tonga_POWERPLAYTABLE *powerplay_table\r\n)\r\n{\r\nconst ATOM_Tonga_State_Array *state_arrays;\r\nstate_arrays = (ATOM_Tonga_State_Array *)(((unsigned long)powerplay_table) +\r\nle16_to_cpu(powerplay_table->usStateArrayOffset));\r\nPP_ASSERT_WITH_CODE((ATOM_Tonga_TABLE_REVISION_TONGA <=\r\npowerplay_table->sHeader.ucTableFormatRevision),\r\n"Unsupported PPTable format!", return -1);\r\nPP_ASSERT_WITH_CODE((0 != powerplay_table->usStateArrayOffset),\r\n"State table is not set!", return -1);\r\nPP_ASSERT_WITH_CODE((0 < powerplay_table->sHeader.usStructureSize),\r\n"Invalid PowerPlay Table!", return -1);\r\nPP_ASSERT_WITH_CODE((0 < state_arrays->ucNumEntries),\r\n"Invalid PowerPlay Table!", return -1);\r\nreturn 0;\r\n}\r\nstatic int pp_tables_v1_0_initialize(struct pp_hwmgr *hwmgr)\r\n{\r\nint result = 0;\r\nconst ATOM_Tonga_POWERPLAYTABLE *powerplay_table;\r\nhwmgr->pptable = kzalloc(sizeof(struct phm_ppt_v1_information), GFP_KERNEL);\r\nPP_ASSERT_WITH_CODE((NULL != hwmgr->pptable),\r\n"Failed to allocate hwmgr->pptable!", return -ENOMEM);\r\nmemset(hwmgr->pptable, 0x00, sizeof(struct phm_ppt_v1_information));\r\npowerplay_table = get_powerplay_table(hwmgr);\r\nPP_ASSERT_WITH_CODE((NULL != powerplay_table),\r\n"Missing PowerPlay Table!", return -1);\r\nresult = check_powerplay_tables(hwmgr, powerplay_table);\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"check_powerplay_tables failed", return result);\r\nresult = set_platform_caps(hwmgr,\r\nle32_to_cpu(powerplay_table->ulPlatformCaps));\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"set_platform_caps failed", return result);\r\nresult = init_thermal_controller(hwmgr, powerplay_table);\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"init_thermal_controller failed", return result);\r\nresult = init_over_drive_limits(hwmgr, powerplay_table);\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"init_over_drive_limits failed", return result);\r\nresult = init_clock_voltage_dependency(hwmgr, powerplay_table);\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"init_clock_voltage_dependency failed", return result);\r\nresult = init_dpm_2_parameters(hwmgr, powerplay_table);\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"init_dpm_2_parameters failed", return result);\r\nreturn result;\r\n}\r\nstatic int pp_tables_v1_0_uninitialize(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct phm_ppt_v1_information *pp_table_information =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nkfree(pp_table_information->vdd_dep_on_sclk);\r\npp_table_information->vdd_dep_on_sclk = NULL;\r\nkfree(pp_table_information->vdd_dep_on_mclk);\r\npp_table_information->vdd_dep_on_mclk = NULL;\r\nkfree(pp_table_information->valid_mclk_values);\r\npp_table_information->valid_mclk_values = NULL;\r\nkfree(pp_table_information->valid_sclk_values);\r\npp_table_information->valid_sclk_values = NULL;\r\nkfree(pp_table_information->vddc_lookup_table);\r\npp_table_information->vddc_lookup_table = NULL;\r\nkfree(pp_table_information->vddgfx_lookup_table);\r\npp_table_information->vddgfx_lookup_table = NULL;\r\nkfree(pp_table_information->mm_dep_table);\r\npp_table_information->mm_dep_table = NULL;\r\nkfree(pp_table_information->cac_dtp_table);\r\npp_table_information->cac_dtp_table = NULL;\r\nkfree(hwmgr->dyn_state.cac_dtp_table);\r\nhwmgr->dyn_state.cac_dtp_table = NULL;\r\nkfree(pp_table_information->ppm_parameter_table);\r\npp_table_information->ppm_parameter_table = NULL;\r\nkfree(pp_table_information->pcie_table);\r\npp_table_information->pcie_table = NULL;\r\nkfree(hwmgr->pptable);\r\nhwmgr->pptable = NULL;\r\nreturn 0;\r\n}\r\nint get_number_of_powerplay_table_entries_v1_0(struct pp_hwmgr *hwmgr)\r\n{\r\nATOM_Tonga_State_Array const *state_arrays;\r\nconst ATOM_Tonga_POWERPLAYTABLE *pp_table = get_powerplay_table(hwmgr);\r\nPP_ASSERT_WITH_CODE((NULL != pp_table),\r\n"Missing PowerPlay Table!", return -1);\r\nPP_ASSERT_WITH_CODE((pp_table->sHeader.ucTableFormatRevision >=\r\nATOM_Tonga_TABLE_REVISION_TONGA),\r\n"Incorrect PowerPlay table revision!", return -1);\r\nstate_arrays = (ATOM_Tonga_State_Array *)(((unsigned long)pp_table) +\r\nle16_to_cpu(pp_table->usStateArrayOffset));\r\nreturn (uint32_t)(state_arrays->ucNumEntries);\r\n}\r\nstatic uint32_t make_classification_flags(struct pp_hwmgr *hwmgr,\r\nuint16_t classification, uint16_t classification2)\r\n{\r\nuint32_t result = 0;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_BOOT)\r\nresult |= PP_StateClassificationFlag_Boot;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_THERMAL)\r\nresult |= PP_StateClassificationFlag_Thermal;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_LIMITEDPOWERSOURCE)\r\nresult |= PP_StateClassificationFlag_LimitedPowerSource;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_REST)\r\nresult |= PP_StateClassificationFlag_Rest;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_FORCED)\r\nresult |= PP_StateClassificationFlag_Forced;\r\nif (classification & ATOM_PPLIB_CLASSIFICATION_ACPI)\r\nresult |= PP_StateClassificationFlag_ACPI;\r\nif (classification2 & ATOM_PPLIB_CLASSIFICATION2_LIMITEDPOWERSOURCE_2)\r\nresult |= PP_StateClassificationFlag_LimitedPowerSource_2;\r\nreturn result;\r\n}\r\nstatic int ppt_get_num_of_vce_state_table_entries_v1_0(struct pp_hwmgr *hwmgr)\r\n{\r\nconst ATOM_Tonga_POWERPLAYTABLE *pp_table = get_powerplay_table(hwmgr);\r\nconst ATOM_Tonga_VCE_State_Table *vce_state_table;\r\nif (pp_table == NULL)\r\nreturn 0;\r\nvce_state_table = (void *)pp_table +\r\nle16_to_cpu(pp_table->usVCEStateTableOffset);\r\nreturn vce_state_table->ucNumEntries;\r\n}\r\nstatic int ppt_get_vce_state_table_entry_v1_0(struct pp_hwmgr *hwmgr, uint32_t i,\r\nstruct amd_vce_state *vce_state, void **clock_info, uint32_t *flag)\r\n{\r\nconst ATOM_Tonga_VCE_State_Record *vce_state_record;\r\nATOM_Tonga_SCLK_Dependency_Record *sclk_dep_record;\r\nATOM_Tonga_MCLK_Dependency_Record *mclk_dep_record;\r\nATOM_Tonga_MM_Dependency_Record *mm_dep_record;\r\nconst ATOM_Tonga_POWERPLAYTABLE *pptable = get_powerplay_table(hwmgr);\r\nconst ATOM_Tonga_VCE_State_Table *vce_state_table = (ATOM_Tonga_VCE_State_Table *)(((unsigned long)pptable)\r\n+ le16_to_cpu(pptable->usVCEStateTableOffset));\r\nconst ATOM_Tonga_SCLK_Dependency_Table *sclk_dep_table = (ATOM_Tonga_SCLK_Dependency_Table *)(((unsigned long)pptable)\r\n+ le16_to_cpu(pptable->usSclkDependencyTableOffset));\r\nconst ATOM_Tonga_MCLK_Dependency_Table *mclk_dep_table = (ATOM_Tonga_MCLK_Dependency_Table *)(((unsigned long)pptable)\r\n+ le16_to_cpu(pptable->usMclkDependencyTableOffset));\r\nconst ATOM_Tonga_MM_Dependency_Table *mm_dep_table = (ATOM_Tonga_MM_Dependency_Table *)(((unsigned long)pptable)\r\n+ le16_to_cpu(pptable->usMMDependencyTableOffset));\r\nPP_ASSERT_WITH_CODE((i < vce_state_table->ucNumEntries),\r\n"Requested state entry ID is out of range!",\r\nreturn -EINVAL);\r\nvce_state_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nATOM_Tonga_VCE_State_Record,\r\nentries, vce_state_table, i);\r\nsclk_dep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nATOM_Tonga_SCLK_Dependency_Record,\r\nentries, sclk_dep_table,\r\nvce_state_record->ucSCLKIndex);\r\nmm_dep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nATOM_Tonga_MM_Dependency_Record,\r\nentries, mm_dep_table,\r\nvce_state_record->ucVCEClockIndex);\r\n*flag = vce_state_record->ucFlag;\r\nvce_state->evclk = mm_dep_record->ulEClk;\r\nvce_state->ecclk = mm_dep_record->ulEClk;\r\nvce_state->sclk = sclk_dep_record->ulSclk;\r\nif (vce_state_record->ucMCLKIndex >= mclk_dep_table->ucNumEntries)\r\nmclk_dep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nATOM_Tonga_MCLK_Dependency_Record,\r\nentries, mclk_dep_table,\r\nmclk_dep_table->ucNumEntries - 1);\r\nelse\r\nmclk_dep_record = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nATOM_Tonga_MCLK_Dependency_Record,\r\nentries, mclk_dep_table,\r\nvce_state_record->ucMCLKIndex);\r\nvce_state->mclk = mclk_dep_record->ulMclk;\r\nreturn 0;\r\n}\r\nint get_powerplay_table_entry_v1_0(struct pp_hwmgr *hwmgr,\r\nuint32_t entry_index, struct pp_power_state *power_state,\r\nint (*call_back_func)(struct pp_hwmgr *, void *,\r\nstruct pp_power_state *, void *, uint32_t))\r\n{\r\nint result = 0;\r\nconst ATOM_Tonga_State_Array *state_arrays;\r\nconst ATOM_Tonga_State *state_entry;\r\nconst ATOM_Tonga_POWERPLAYTABLE *pp_table = get_powerplay_table(hwmgr);\r\nint i, j;\r\nuint32_t flags = 0;\r\nPP_ASSERT_WITH_CODE((NULL != pp_table), "Missing PowerPlay Table!", return -1;);\r\npower_state->classification.bios_index = entry_index;\r\nif (pp_table->sHeader.ucTableFormatRevision >=\r\nATOM_Tonga_TABLE_REVISION_TONGA) {\r\nstate_arrays = (ATOM_Tonga_State_Array *)(((unsigned long)pp_table) +\r\nle16_to_cpu(pp_table->usStateArrayOffset));\r\nPP_ASSERT_WITH_CODE((0 < pp_table->usStateArrayOffset),\r\n"Invalid PowerPlay Table State Array Offset.", return -1);\r\nPP_ASSERT_WITH_CODE((0 < state_arrays->ucNumEntries),\r\n"Invalid PowerPlay Table State Array.", return -1);\r\nPP_ASSERT_WITH_CODE((entry_index <= state_arrays->ucNumEntries),\r\n"Invalid PowerPlay Table State Array Entry.", return -1);\r\nstate_entry = GET_FLEXIBLE_ARRAY_MEMBER_ADDR(\r\nATOM_Tonga_State, entries,\r\nstate_arrays, entry_index);\r\nresult = call_back_func(hwmgr, (void *)state_entry, power_state,\r\n(void *)pp_table,\r\nmake_classification_flags(hwmgr,\r\nle16_to_cpu(state_entry->usClassification),\r\nle16_to_cpu(state_entry->usClassification2)));\r\n}\r\nif (!result && (power_state->classification.flags &\r\nPP_StateClassificationFlag_Boot))\r\nresult = hwmgr->hwmgr_func->patch_boot_state(hwmgr, &(power_state->hardware));\r\nhwmgr->num_vce_state_tables = i = ppt_get_num_of_vce_state_table_entries_v1_0(hwmgr);\r\nif ((i != 0) && (i <= AMD_MAX_VCE_LEVELS)) {\r\nfor (j = 0; j < i; j++)\r\nppt_get_vce_state_table_entry_v1_0(hwmgr, j, &(hwmgr->vce_states[j]), NULL, &flags);\r\n}\r\nreturn result;\r\n}
