VCHIQ_STATUS_T vchiq_initialise(VCHIQ_INSTANCE_T *instance_out)\r\n{\r\nVCHIQ_STATUS_T status = VCHIQ_ERROR;\r\nVCHIQ_STATE_T *state;\r\nVCHIQ_INSTANCE_T instance = NULL;\r\nint i;\r\nvchiq_log_trace(vchiq_core_log_level, "%s called", __func__);\r\nfor (i = 0; i < VCHIQ_INIT_RETRIES; i++) {\r\nstate = vchiq_get_state();\r\nif (state)\r\nbreak;\r\nudelay(500);\r\n}\r\nif (i == VCHIQ_INIT_RETRIES) {\r\nvchiq_log_error(vchiq_core_log_level,\r\n"%s: videocore not initialized\n", __func__);\r\ngoto failed;\r\n} else if (i > 0) {\r\nvchiq_log_warning(vchiq_core_log_level,\r\n"%s: videocore initialized after %d retries\n", __func__, i);\r\n}\r\ninstance = kzalloc(sizeof(*instance), GFP_KERNEL);\r\nif (!instance) {\r\nvchiq_log_error(vchiq_core_log_level,\r\n"%s: error allocating vchiq instance\n", __func__);\r\ngoto failed;\r\n}\r\ninstance->connected = 0;\r\ninstance->state = state;\r\nmutex_init(&instance->bulk_waiter_list_mutex);\r\nINIT_LIST_HEAD(&instance->bulk_waiter_list);\r\n*instance_out = instance;\r\nstatus = VCHIQ_SUCCESS;\r\nfailed:\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%s(%p): returning %d", __func__, instance, status);\r\nreturn status;\r\n}\r\nVCHIQ_STATUS_T vchiq_shutdown(VCHIQ_INSTANCE_T instance)\r\n{\r\nVCHIQ_STATUS_T status;\r\nVCHIQ_STATE_T *state = instance->state;\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%s(%p) called", __func__, instance);\r\nif (mutex_lock_killable(&state->mutex) != 0)\r\nreturn VCHIQ_RETRY;\r\nstatus = vchiq_shutdown_internal(state, instance);\r\nmutex_unlock(&state->mutex);\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%s(%p): returning %d", __func__, instance, status);\r\nif (status == VCHIQ_SUCCESS) {\r\nstruct list_head *pos, *next;\r\nlist_for_each_safe(pos, next,\r\n&instance->bulk_waiter_list) {\r\nstruct bulk_waiter_node *waiter;\r\nwaiter = list_entry(pos,\r\nstruct bulk_waiter_node,\r\nlist);\r\nlist_del(pos);\r\nvchiq_log_info(vchiq_arm_log_level,\r\n"bulk_waiter - cleaned up %pK for pid %d",\r\nwaiter, waiter->pid);\r\nkfree(waiter);\r\n}\r\nkfree(instance);\r\n}\r\nreturn status;\r\n}\r\nstatic int vchiq_is_connected(VCHIQ_INSTANCE_T instance)\r\n{\r\nreturn instance->connected;\r\n}\r\nVCHIQ_STATUS_T vchiq_connect(VCHIQ_INSTANCE_T instance)\r\n{\r\nVCHIQ_STATUS_T status;\r\nVCHIQ_STATE_T *state = instance->state;\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%s(%p) called", __func__, instance);\r\nif (mutex_lock_killable(&state->mutex) != 0) {\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%s: call to mutex_lock failed", __func__);\r\nstatus = VCHIQ_RETRY;\r\ngoto failed;\r\n}\r\nstatus = vchiq_connect_internal(state, instance);\r\nif (status == VCHIQ_SUCCESS)\r\ninstance->connected = 1;\r\nmutex_unlock(&state->mutex);\r\nfailed:\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%s(%p): returning %d", __func__, instance, status);\r\nreturn status;\r\n}\r\nVCHIQ_STATUS_T vchiq_add_service(\r\nVCHIQ_INSTANCE_T instance,\r\nconst VCHIQ_SERVICE_PARAMS_T *params,\r\nVCHIQ_SERVICE_HANDLE_T *phandle)\r\n{\r\nVCHIQ_STATUS_T status;\r\nVCHIQ_STATE_T *state = instance->state;\r\nVCHIQ_SERVICE_T *service = NULL;\r\nint srvstate;\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%s(%p) called", __func__, instance);\r\n*phandle = VCHIQ_SERVICE_HANDLE_INVALID;\r\nsrvstate = vchiq_is_connected(instance)\r\n? VCHIQ_SRVSTATE_LISTENING\r\n: VCHIQ_SRVSTATE_HIDDEN;\r\nservice = vchiq_add_service_internal(\r\nstate,\r\nparams,\r\nsrvstate,\r\ninstance,\r\nNULL);\r\nif (service) {\r\n*phandle = service->handle;\r\nstatus = VCHIQ_SUCCESS;\r\n} else\r\nstatus = VCHIQ_ERROR;\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%s(%p): returning %d", __func__, instance, status);\r\nreturn status;\r\n}\r\nVCHIQ_STATUS_T vchiq_open_service(\r\nVCHIQ_INSTANCE_T instance,\r\nconst VCHIQ_SERVICE_PARAMS_T *params,\r\nVCHIQ_SERVICE_HANDLE_T *phandle)\r\n{\r\nVCHIQ_STATUS_T status = VCHIQ_ERROR;\r\nVCHIQ_STATE_T *state = instance->state;\r\nVCHIQ_SERVICE_T *service = NULL;\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%s(%p) called", __func__, instance);\r\n*phandle = VCHIQ_SERVICE_HANDLE_INVALID;\r\nif (!vchiq_is_connected(instance))\r\ngoto failed;\r\nservice = vchiq_add_service_internal(state,\r\nparams,\r\nVCHIQ_SRVSTATE_OPENING,\r\ninstance,\r\nNULL);\r\nif (service) {\r\n*phandle = service->handle;\r\nstatus = vchiq_open_service_internal(service, current->pid);\r\nif (status != VCHIQ_SUCCESS) {\r\nvchiq_remove_service(service->handle);\r\n*phandle = VCHIQ_SERVICE_HANDLE_INVALID;\r\n}\r\n}\r\nfailed:\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%s(%p): returning %d", __func__, instance, status);\r\nreturn status;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_queue_bulk_transmit(VCHIQ_SERVICE_HANDLE_T handle,\r\nconst void *data, unsigned int size, void *userdata)\r\n{\r\nreturn vchiq_bulk_transfer(handle,\r\nVCHI_MEM_HANDLE_INVALID, (void *)data, size, userdata,\r\nVCHIQ_BULK_MODE_CALLBACK, VCHIQ_BULK_TRANSMIT);\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_queue_bulk_receive(VCHIQ_SERVICE_HANDLE_T handle, void *data,\r\nunsigned int size, void *userdata)\r\n{\r\nreturn vchiq_bulk_transfer(handle,\r\nVCHI_MEM_HANDLE_INVALID, data, size, userdata,\r\nVCHIQ_BULK_MODE_CALLBACK, VCHIQ_BULK_RECEIVE);\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_bulk_transmit(VCHIQ_SERVICE_HANDLE_T handle, const void *data,\r\nunsigned int size, void *userdata, VCHIQ_BULK_MODE_T mode)\r\n{\r\nVCHIQ_STATUS_T status;\r\nswitch (mode) {\r\ncase VCHIQ_BULK_MODE_NOCALLBACK:\r\ncase VCHIQ_BULK_MODE_CALLBACK:\r\nstatus = vchiq_bulk_transfer(handle,\r\nVCHI_MEM_HANDLE_INVALID, (void *)data, size, userdata,\r\nmode, VCHIQ_BULK_TRANSMIT);\r\nbreak;\r\ncase VCHIQ_BULK_MODE_BLOCKING:\r\nstatus = vchiq_blocking_bulk_transfer(handle,\r\n(void *)data, size, VCHIQ_BULK_TRANSMIT);\r\nbreak;\r\ndefault:\r\nreturn VCHIQ_ERROR;\r\n}\r\nreturn status;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_bulk_receive(VCHIQ_SERVICE_HANDLE_T handle, void *data,\r\nunsigned int size, void *userdata, VCHIQ_BULK_MODE_T mode)\r\n{\r\nVCHIQ_STATUS_T status;\r\nswitch (mode) {\r\ncase VCHIQ_BULK_MODE_NOCALLBACK:\r\ncase VCHIQ_BULK_MODE_CALLBACK:\r\nstatus = vchiq_bulk_transfer(handle,\r\nVCHI_MEM_HANDLE_INVALID, data, size, userdata,\r\nmode, VCHIQ_BULK_RECEIVE);\r\nbreak;\r\ncase VCHIQ_BULK_MODE_BLOCKING:\r\nstatus = vchiq_blocking_bulk_transfer(handle,\r\n(void *)data, size, VCHIQ_BULK_RECEIVE);\r\nbreak;\r\ndefault:\r\nreturn VCHIQ_ERROR;\r\n}\r\nreturn status;\r\n}\r\nstatic VCHIQ_STATUS_T\r\nvchiq_blocking_bulk_transfer(VCHIQ_SERVICE_HANDLE_T handle, void *data,\r\nunsigned int size, VCHIQ_BULK_DIR_T dir)\r\n{\r\nVCHIQ_INSTANCE_T instance;\r\nVCHIQ_SERVICE_T *service;\r\nVCHIQ_STATUS_T status;\r\nstruct bulk_waiter_node *waiter = NULL;\r\nstruct list_head *pos;\r\nservice = find_service_by_handle(handle);\r\nif (!service)\r\nreturn VCHIQ_ERROR;\r\ninstance = service->instance;\r\nunlock_service(service);\r\nmutex_lock(&instance->bulk_waiter_list_mutex);\r\nlist_for_each(pos, &instance->bulk_waiter_list) {\r\nif (list_entry(pos, struct bulk_waiter_node,\r\nlist)->pid == current->pid) {\r\nwaiter = list_entry(pos,\r\nstruct bulk_waiter_node,\r\nlist);\r\nlist_del(pos);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&instance->bulk_waiter_list_mutex);\r\nif (waiter) {\r\nVCHIQ_BULK_T *bulk = waiter->bulk_waiter.bulk;\r\nif (bulk) {\r\nif ((bulk->data != data) ||\r\n(bulk->size != size)) {\r\nspin_lock(&bulk_waiter_spinlock);\r\nbulk->userdata = NULL;\r\nspin_unlock(&bulk_waiter_spinlock);\r\n}\r\n}\r\n}\r\nif (!waiter) {\r\nwaiter = kzalloc(sizeof(struct bulk_waiter_node), GFP_KERNEL);\r\nif (!waiter) {\r\nvchiq_log_error(vchiq_core_log_level,\r\n"%s - out of memory", __func__);\r\nreturn VCHIQ_ERROR;\r\n}\r\n}\r\nstatus = vchiq_bulk_transfer(handle, VCHI_MEM_HANDLE_INVALID,\r\ndata, size, &waiter->bulk_waiter, VCHIQ_BULK_MODE_BLOCKING,\r\ndir);\r\nif ((status != VCHIQ_RETRY) || fatal_signal_pending(current) ||\r\n!waiter->bulk_waiter.bulk) {\r\nVCHIQ_BULK_T *bulk = waiter->bulk_waiter.bulk;\r\nif (bulk) {\r\nspin_lock(&bulk_waiter_spinlock);\r\nbulk->userdata = NULL;\r\nspin_unlock(&bulk_waiter_spinlock);\r\n}\r\nkfree(waiter);\r\n} else {\r\nwaiter->pid = current->pid;\r\nmutex_lock(&instance->bulk_waiter_list_mutex);\r\nlist_add(&waiter->list, &instance->bulk_waiter_list);\r\nmutex_unlock(&instance->bulk_waiter_list_mutex);\r\nvchiq_log_info(vchiq_arm_log_level,\r\n"saved bulk_waiter %pK for pid %d",\r\nwaiter, current->pid);\r\n}\r\nreturn status;\r\n}
