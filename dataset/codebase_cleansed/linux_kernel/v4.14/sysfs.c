static ssize_t get_hv_confstr(char *page, int query)\r\n{\r\nssize_t n = hv_confstr(query, (unsigned long)page, PAGE_SIZE - 1);\r\nn = n < 0 ? 0 : min(n, (ssize_t)PAGE_SIZE - 1) - 1;\r\nif (n)\r\npage[n++] = '\n';\r\npage[n] = '\0';\r\nreturn n;\r\n}\r\nstatic ssize_t chip_width_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%u\n", smp_width);\r\n}\r\nstatic ssize_t chip_height_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%u\n", smp_height);\r\n}\r\nstatic ssize_t chip_serial_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *page)\r\n{\r\nreturn get_hv_confstr(page, HV_CONFSTR_CHIP_SERIAL_NUM);\r\n}\r\nstatic ssize_t chip_revision_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *page)\r\n{\r\nreturn get_hv_confstr(page, HV_CONFSTR_CHIP_REV);\r\n}\r\nstatic ssize_t type_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "tilera\n");\r\n}\r\nstatic ssize_t\r\nhvconfig_bin_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstatic size_t size;\r\nif (size == 0)\r\nsize = hv_confstr(HV_CONFSTR_HV_CONFIG, 0, 0) - 1;\r\nif (off > size)\r\nreturn -EINVAL;\r\nif (count > size - off)\r\ncount = size - off;\r\nif (count) {\r\nchar *hvc;\r\nsize = off + count;\r\nhvc = kmalloc(size, GFP_KERNEL);\r\nif (hvc == NULL)\r\nreturn -ENOMEM;\r\nhv_confstr(HV_CONFSTR_HV_CONFIG, (unsigned long)hvc, size);\r\nmemcpy(buf, hvc + off, count);\r\nkfree(hvc);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t hv_stats_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *page)\r\n{\r\nint cpu = dev->id;\r\nlong lotar = HV_XY_TO_LOTAR(cpu_x(cpu), cpu_y(cpu));\r\nssize_t n = hv_confstr(HV_CONFSTR_HV_STATS,\r\n(unsigned long)page, PAGE_SIZE - 1,\r\nlotar, 0);\r\nn = n < 0 ? 0 : min(n, (ssize_t)PAGE_SIZE - 1);\r\npage[n] = '\0';\r\nreturn n;\r\n}\r\nstatic ssize_t hv_stats_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nint cpu = dev->id;\r\nlong lotar = HV_XY_TO_LOTAR(cpu_x(cpu), cpu_y(cpu));\r\nssize_t n = hv_confstr(HV_CONFSTR_HV_STATS, 0, 0, lotar, 1);\r\nreturn n < 0 ? n : count;\r\n}\r\nstatic int hv_stats_device_add(struct device *dev, struct subsys_interface *sif)\r\n{\r\nint err, cpu = dev->id;\r\nif (!cpu_online(cpu))\r\nreturn 0;\r\nerr = sysfs_create_file(&dev->kobj, &dev_attr_hv_stats.attr);\r\nreturn err;\r\n}\r\nstatic void hv_stats_device_remove(struct device *dev,\r\nstruct subsys_interface *sif)\r\n{\r\nint cpu = dev->id;\r\nif (cpu_online(cpu))\r\nsysfs_remove_file(&dev->kobj, &dev_attr_hv_stats.attr);\r\n}\r\nstatic int __init create_sysfs_entries(void)\r\n{\r\nint err = 0;\r\n#define create_cpu_attr(name) \\r\nif (!err) \\r\nerr = device_create_file(cpu_subsys.dev_root, &dev_attr_##name);\r\ncreate_cpu_attr(chip_width);\r\ncreate_cpu_attr(chip_height);\r\ncreate_cpu_attr(chip_serial);\r\ncreate_cpu_attr(chip_revision);\r\n#define create_hv_attr(name) \\r\nif (!err) \\r\nerr = sysfs_create_file(hypervisor_kobj, &dev_attr_##name.attr);\r\ncreate_hv_attr(type);\r\ncreate_hv_attr(version);\r\ncreate_hv_attr(config_version);\r\nif (!err)\r\nerr = sysfs_create_group(hypervisor_kobj, &board_attr_group);\r\nif (!err) {\r\nsysfs_bin_attr_init(&hvconfig_bin);\r\nhvconfig_bin.attr.name = "hvconfig";\r\nhvconfig_bin.attr.mode = S_IRUGO;\r\nhvconfig_bin.read = hvconfig_bin_read;\r\nhvconfig_bin.size = PAGE_SIZE;\r\nerr = sysfs_create_bin_file(hypervisor_kobj, &hvconfig_bin);\r\n}\r\nif (!err) {\r\nint cpu = raw_smp_processor_id();\r\nlong lotar = HV_XY_TO_LOTAR(cpu_x(cpu), cpu_y(cpu));\r\nchar dummy;\r\nssize_t n = hv_confstr(HV_CONFSTR_HV_STATS,\r\n(unsigned long) &dummy, 1,\r\nlotar, 0);\r\nif (n >= 0)\r\nerr = subsys_interface_register(&hv_stats_interface);\r\n}\r\nreturn err;\r\n}
