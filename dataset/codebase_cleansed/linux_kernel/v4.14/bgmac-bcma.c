static inline bool bgmac_is_bcm4707_family(struct bcma_device *core)\r\n{\r\nswitch (core->bus->chipinfo.id) {\r\ncase BCMA_CHIP_ID_BCM4707:\r\ncase BCMA_CHIP_ID_BCM47094:\r\ncase BCMA_CHIP_ID_BCM53018:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic u32 bcma_bgmac_read(struct bgmac *bgmac, u16 offset)\r\n{\r\nreturn bcma_read32(bgmac->bcma.core, offset);\r\n}\r\nstatic void bcma_bgmac_write(struct bgmac *bgmac, u16 offset, u32 value)\r\n{\r\nbcma_write32(bgmac->bcma.core, offset, value);\r\n}\r\nstatic u32 bcma_bgmac_idm_read(struct bgmac *bgmac, u16 offset)\r\n{\r\nreturn bcma_aread32(bgmac->bcma.core, offset);\r\n}\r\nstatic void bcma_bgmac_idm_write(struct bgmac *bgmac, u16 offset, u32 value)\r\n{\r\nreturn bcma_awrite32(bgmac->bcma.core, offset, value);\r\n}\r\nstatic bool bcma_bgmac_clk_enabled(struct bgmac *bgmac)\r\n{\r\nreturn bcma_core_is_enabled(bgmac->bcma.core);\r\n}\r\nstatic void bcma_bgmac_clk_enable(struct bgmac *bgmac, u32 flags)\r\n{\r\nbcma_core_enable(bgmac->bcma.core, flags);\r\n}\r\nstatic void bcma_bgmac_cco_ctl_maskset(struct bgmac *bgmac, u32 offset,\r\nu32 mask, u32 set)\r\n{\r\nstruct bcma_drv_cc *cc = &bgmac->bcma.core->bus->drv_cc;\r\nbcma_chipco_chipctl_maskset(cc, offset, mask, set);\r\n}\r\nstatic u32 bcma_bgmac_get_bus_clock(struct bgmac *bgmac)\r\n{\r\nstruct bcma_drv_cc *cc = &bgmac->bcma.core->bus->drv_cc;\r\nreturn bcma_pmu_get_bus_clock(cc);\r\n}\r\nstatic void bcma_bgmac_cmn_maskset32(struct bgmac *bgmac, u16 offset, u32 mask,\r\nu32 set)\r\n{\r\nbcma_maskset32(bgmac->bcma.cmn, offset, mask, set);\r\n}\r\nstatic int bcma_phy_connect(struct bgmac *bgmac)\r\n{\r\nstruct phy_device *phy_dev;\r\nchar bus_id[MII_BUS_ID_SIZE + 3];\r\nsnprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, bgmac->mii_bus->id,\r\nbgmac->phyaddr);\r\nphy_dev = phy_connect(bgmac->net_dev, bus_id, bgmac_adjust_link,\r\nPHY_INTERFACE_MODE_MII);\r\nif (IS_ERR(phy_dev)) {\r\ndev_err(bgmac->dev, "PHY connection failed\n");\r\nreturn PTR_ERR(phy_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bgmac_probe(struct bcma_device *core)\r\n{\r\nstruct bcma_chipinfo *ci = &core->bus->chipinfo;\r\nstruct ssb_sprom *sprom = &core->bus->sprom;\r\nstruct mii_bus *mii_bus;\r\nstruct bgmac *bgmac;\r\nconst u8 *mac = NULL;\r\nint err;\r\nbgmac = bgmac_alloc(&core->dev);\r\nif (!bgmac)\r\nreturn -ENOMEM;\r\nbgmac->bcma.core = core;\r\nbgmac->dma_dev = core->dma_dev;\r\nbgmac->irq = core->irq;\r\nbcma_set_drvdata(core, bgmac);\r\nif (bgmac->dev->of_node)\r\nmac = of_get_mac_address(bgmac->dev->of_node);\r\nif (!mac) {\r\nswitch (core->core_unit) {\r\ncase 0:\r\nmac = sprom->et0mac;\r\nbreak;\r\ncase 1:\r\nmac = sprom->et1mac;\r\nbreak;\r\ncase 2:\r\nmac = sprom->et2mac;\r\nbreak;\r\ndefault:\r\ndev_err(bgmac->dev, "Unsupported core_unit %d\n",\r\ncore->core_unit);\r\nerr = -ENOTSUPP;\r\ngoto err;\r\n}\r\n}\r\nether_addr_copy(bgmac->net_dev->dev_addr, mac);\r\nif (core->id.id == BCMA_CORE_4706_MAC_GBIT &&\r\n!core->bus->drv_gmac_cmn.core) {\r\ndev_err(bgmac->dev, "GMAC CMN core not found (required for BCM4706)\n");\r\nerr = -ENODEV;\r\ngoto err;\r\n}\r\nbgmac->bcma.cmn = core->bus->drv_gmac_cmn.core;\r\nswitch (core->core_unit) {\r\ncase 0:\r\nbgmac->phyaddr = sprom->et0phyaddr;\r\nbreak;\r\ncase 1:\r\nbgmac->phyaddr = sprom->et1phyaddr;\r\nbreak;\r\ncase 2:\r\nbgmac->phyaddr = sprom->et2phyaddr;\r\nbreak;\r\n}\r\nbgmac->phyaddr &= BGMAC_PHY_MASK;\r\nif (bgmac->phyaddr == BGMAC_PHY_MASK) {\r\ndev_err(bgmac->dev, "No PHY found\n");\r\nerr = -ENODEV;\r\ngoto err;\r\n}\r\ndev_info(bgmac->dev, "Found PHY addr: %d%s\n", bgmac->phyaddr,\r\nbgmac->phyaddr == BGMAC_PHY_NOREGS ? " (NOREGS)" : "");\r\nif (!bgmac_is_bcm4707_family(core) &&\r\n!(ci->id == BCMA_CHIP_ID_BCM53573 && core->core_unit == 1)) {\r\nmii_bus = bcma_mdio_mii_register(bgmac);\r\nif (IS_ERR(mii_bus)) {\r\nerr = PTR_ERR(mii_bus);\r\ngoto err;\r\n}\r\nbgmac->mii_bus = mii_bus;\r\n}\r\nif (core->bus->hosttype == BCMA_HOSTTYPE_PCI) {\r\ndev_err(bgmac->dev, "PCI setup not implemented\n");\r\nerr = -ENOTSUPP;\r\ngoto err1;\r\n}\r\nbgmac->has_robosw = !!(sprom->boardflags_lo & BGMAC_BFL_ENETROBO);\r\nif (bgmac->has_robosw)\r\ndev_warn(bgmac->dev, "Support for Roboswitch not implemented\n");\r\nif (sprom->boardflags_lo & BGMAC_BFL_ENETADM)\r\ndev_warn(bgmac->dev, "Support for ADMtek ethernet switch not implemented\n");\r\nswitch (ci->id) {\r\ncase BCMA_CHIP_ID_BCM4716:\r\nbgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;\r\ncase BCMA_CHIP_ID_BCM47162:\r\nbgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL2;\r\nbgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;\r\nbreak;\r\ncase BCMA_CHIP_ID_BCM5357:\r\ncase BCMA_CHIP_ID_BCM53572:\r\nbgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;\r\nbgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;\r\nbgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL1;\r\nbgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_PHY;\r\nif (ci->pkg == BCMA_PKG_ID_BCM47188 ||\r\nci->pkg == BCMA_PKG_ID_BCM47186) {\r\nbgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_RGMII;\r\nbgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;\r\n}\r\nif (ci->pkg == BCMA_PKG_ID_BCM5358)\r\nbgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_EPHYRMII;\r\nbreak;\r\ncase BCMA_CHIP_ID_BCM53573:\r\nbgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;\r\nbgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;\r\nif (ci->pkg == BCMA_PKG_ID_BCM47189)\r\nbgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;\r\nif (core->core_unit == 0) {\r\nbgmac->feature_flags |= BGMAC_FEAT_CC4_IF_SW_TYPE;\r\nif (ci->pkg == BCMA_PKG_ID_BCM47189)\r\nbgmac->feature_flags |=\r\nBGMAC_FEAT_CC4_IF_SW_TYPE_RGMII;\r\n} else if (core->core_unit == 1) {\r\nbgmac->feature_flags |= BGMAC_FEAT_IRQ_ID_OOB_6;\r\nbgmac->feature_flags |= BGMAC_FEAT_CC7_IF_TYPE_RGMII;\r\n}\r\nbreak;\r\ncase BCMA_CHIP_ID_BCM4749:\r\nbgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;\r\nbgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;\r\nbgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL1;\r\nbgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_PHY;\r\nif (ci->pkg == 10) {\r\nbgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_RGMII;\r\nbgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;\r\n}\r\nbreak;\r\ncase BCMA_CHIP_ID_BCM4707:\r\ncase BCMA_CHIP_ID_BCM47094:\r\ncase BCMA_CHIP_ID_BCM53018:\r\nbgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;\r\nbgmac->feature_flags |= BGMAC_FEAT_NO_RESET;\r\nbgmac->feature_flags |= BGMAC_FEAT_FORCE_SPEED_2500;\r\nbreak;\r\ndefault:\r\nbgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;\r\nbgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;\r\n}\r\nif (!bgmac_is_bcm4707_family(core) && core->id.rev > 2)\r\nbgmac->feature_flags |= BGMAC_FEAT_MISC_PLL_REQ;\r\nif (core->id.id == BCMA_CORE_4706_MAC_GBIT) {\r\nbgmac->feature_flags |= BGMAC_FEAT_CMN_PHY_CTL;\r\nbgmac->feature_flags |= BGMAC_FEAT_NO_CLR_MIB;\r\n}\r\nif (core->id.rev >= 4) {\r\nbgmac->feature_flags |= BGMAC_FEAT_CMDCFG_SR_REV4;\r\nbgmac->feature_flags |= BGMAC_FEAT_TX_MASK_SETUP;\r\nbgmac->feature_flags |= BGMAC_FEAT_RX_MASK_SETUP;\r\n}\r\nbgmac->read = bcma_bgmac_read;\r\nbgmac->write = bcma_bgmac_write;\r\nbgmac->idm_read = bcma_bgmac_idm_read;\r\nbgmac->idm_write = bcma_bgmac_idm_write;\r\nbgmac->clk_enabled = bcma_bgmac_clk_enabled;\r\nbgmac->clk_enable = bcma_bgmac_clk_enable;\r\nbgmac->cco_ctl_maskset = bcma_bgmac_cco_ctl_maskset;\r\nbgmac->get_bus_clock = bcma_bgmac_get_bus_clock;\r\nbgmac->cmn_maskset32 = bcma_bgmac_cmn_maskset32;\r\nif (bgmac->mii_bus)\r\nbgmac->phy_connect = bcma_phy_connect;\r\nelse\r\nbgmac->phy_connect = bgmac_phy_connect_direct;\r\nerr = bgmac_enet_probe(bgmac);\r\nif (err)\r\ngoto err1;\r\nreturn 0;\r\nerr1:\r\nbcma_mdio_mii_unregister(bgmac->mii_bus);\r\nerr:\r\nbcma_set_drvdata(core, NULL);\r\nreturn err;\r\n}\r\nstatic void bgmac_remove(struct bcma_device *core)\r\n{\r\nstruct bgmac *bgmac = bcma_get_drvdata(core);\r\nbcma_mdio_mii_unregister(bgmac->mii_bus);\r\nbgmac_enet_remove(bgmac);\r\nbcma_set_drvdata(core, NULL);\r\nkfree(bgmac);\r\n}\r\nstatic int __init bgmac_init(void)\r\n{\r\nint err;\r\nerr = bcma_driver_register(&bgmac_bcma_driver);\r\nif (err)\r\nreturn err;\r\npr_info("Broadcom 47xx GBit MAC driver loaded\n");\r\nreturn 0;\r\n}\r\nstatic void __exit bgmac_exit(void)\r\n{\r\nbcma_driver_unregister(&bgmac_bcma_driver);\r\n}
