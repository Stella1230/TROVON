static void tbi_boing_init(void)\r\n{\r\nunsigned long size;\r\nunsigned long offset;\r\nchar modname[MODULE_NAME_LEN];\r\nchar name[KSYM_NAME_LEN];\r\ntbi_boing_addr = kallsyms_lookup_name("___TBIBoingVec");\r\nif (!tbi_boing_addr)\r\ntbi_boing_addr = 1;\r\nelse if (!lookup_symbol_attrs(tbi_boing_addr, &size,\r\n&offset, modname, name))\r\ntbi_boing_size = size;\r\n}\r\nint notrace unwind_frame(struct stackframe *frame)\r\n{\r\nstruct metag_frame *fp = (struct metag_frame *)frame->fp;\r\nunsigned long lr;\r\nunsigned long fpnew;\r\nif (frame->fp & 0x7)\r\nreturn -EINVAL;\r\nfpnew = fp->fp;\r\nlr = fp->lr - 4;\r\n#ifdef CONFIG_KALLSYMS\r\nif (!tbi_boing_addr)\r\ntbi_boing_init();\r\nif (tbi_boing_size && lr >= tbi_boing_addr &&\r\nlr < tbi_boing_addr + tbi_boing_size) {\r\nstruct pt_regs *regs = (struct pt_regs *)fpnew;\r\nif (user_mode(regs))\r\nreturn -EINVAL;\r\nfpnew = regs->ctx.AX[1].U0;\r\nlr = regs->ctx.DX[4].U1;\r\n}\r\n#endif\r\nif (fpnew < (ALIGN_DOWN((unsigned long)fp, THREAD_SIZE) +\r\nsizeof(struct thread_info)) || fpnew >= (unsigned long)fp)\r\nreturn -EINVAL;\r\nframe->fp = fpnew;\r\nframe->pc = lr;\r\nreturn 0;\r\n}\r\nint notrace unwind_frame(struct stackframe *frame)\r\n{\r\nstruct metag_frame *sp = (struct metag_frame *)frame->sp;\r\nif (frame->sp & 0x7)\r\nreturn -EINVAL;\r\nwhile (!kstack_end(sp)) {\r\nunsigned long addr = sp->lr - 4;\r\nsp--;\r\nif (__kernel_text_address(addr)) {\r\nframe->sp = (unsigned long)sp;\r\nframe->pc = addr;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid notrace walk_stackframe(struct stackframe *frame,\r\nint (*fn)(struct stackframe *, void *), void *data)\r\n{\r\nwhile (1) {\r\nint ret;\r\nif (fn(frame, data))\r\nbreak;\r\nret = unwind_frame(frame);\r\nif (ret < 0)\r\nbreak;\r\n}\r\n}\r\nstatic int save_trace(struct stackframe *frame, void *d)\r\n{\r\nstruct stack_trace_data *data = d;\r\nstruct stack_trace *trace = data->trace;\r\nunsigned long addr = frame->pc;\r\nif (data->no_sched_functions && in_sched_functions(addr))\r\nreturn 0;\r\nif (data->skip) {\r\ndata->skip--;\r\nreturn 0;\r\n}\r\ntrace->entries[trace->nr_entries++] = addr;\r\nreturn trace->nr_entries >= trace->max_entries;\r\n}\r\nvoid save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)\r\n{\r\nstruct stack_trace_data data;\r\nstruct stackframe frame;\r\ndata.trace = trace;\r\ndata.skip = trace->skip;\r\nif (tsk != current) {\r\n#ifdef CONFIG_SMP\r\nif (trace->nr_entries < trace->max_entries)\r\ntrace->entries[trace->nr_entries++] = ULONG_MAX;\r\nreturn;\r\n#else\r\ndata.no_sched_functions = 1;\r\nframe.fp = thread_saved_fp(tsk);\r\nframe.sp = thread_saved_sp(tsk);\r\nframe.lr = 0;\r\nframe.pc = thread_saved_pc(tsk);\r\n#endif\r\n} else {\r\nregister unsigned long current_sp asm ("A0StP");\r\ndata.no_sched_functions = 0;\r\nframe.fp = (unsigned long)__builtin_frame_address(0);\r\nframe.sp = current_sp;\r\nframe.lr = (unsigned long)__builtin_return_address(0);\r\nframe.pc = (unsigned long)save_stack_trace_tsk;\r\n}\r\nwalk_stackframe(&frame, save_trace, &data);\r\nif (trace->nr_entries < trace->max_entries)\r\ntrace->entries[trace->nr_entries++] = ULONG_MAX;\r\n}\r\nvoid save_stack_trace(struct stack_trace *trace)\r\n{\r\nsave_stack_trace_tsk(current, trace);\r\n}
