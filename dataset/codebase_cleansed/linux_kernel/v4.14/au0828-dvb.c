static void au0828_bulk_timeout(unsigned long data)\r\n{\r\nstruct au0828_dev *dev = (struct au0828_dev *) data;\r\ndprintk(1, "%s called\n", __func__);\r\ndev->bulk_timeout_running = 0;\r\nschedule_work(&dev->restart_streaming);\r\n}\r\nstatic void urb_completion(struct urb *purb)\r\n{\r\nstruct au0828_dev *dev = purb->context;\r\nint ptype = usb_pipetype(purb->pipe);\r\nunsigned char *ptr;\r\ndprintk(2, "%s: %d\n", __func__, purb->actual_length);\r\nif (!dev) {\r\ndprintk(2, "%s: no dev!\n", __func__);\r\nreturn;\r\n}\r\nif (!dev->urb_streaming) {\r\ndprintk(2, "%s: not streaming!\n", __func__);\r\nreturn;\r\n}\r\nif (ptype != PIPE_BULK) {\r\npr_err("%s: Unsupported URB type %d\n",\r\n__func__, ptype);\r\nreturn;\r\n}\r\nptr = purb->transfer_buffer;\r\nif (purb->actual_length > 0 && ptr[0] != 0x47) {\r\ndprintk(1, "Need to restart streaming %02x len=%d!\n",\r\nptr[0], purb->actual_length);\r\nschedule_work(&dev->restart_streaming);\r\nreturn;\r\n} else if (dev->bulk_timeout_running == 1) {\r\ndprintk(1, "%s cancelling bulk timeout\n", __func__);\r\ndev->bulk_timeout_running = 0;\r\ndel_timer(&dev->bulk_timeout);\r\n}\r\ndvb_dmx_swfilter_packets(&dev->dvb.demux,\r\npurb->transfer_buffer, purb->actual_length / 188);\r\nmemset(purb->transfer_buffer, 0, URB_BUFSIZE);\r\nusb_submit_urb(purb, GFP_ATOMIC);\r\n}\r\nstatic int stop_urb_transfer(struct au0828_dev *dev)\r\n{\r\nint i;\r\ndprintk(2, "%s()\n", __func__);\r\nif (!dev->urb_streaming)\r\nreturn 0;\r\nif (dev->bulk_timeout_running == 1) {\r\ndev->bulk_timeout_running = 0;\r\ndel_timer(&dev->bulk_timeout);\r\n}\r\ndev->urb_streaming = false;\r\nfor (i = 0; i < URB_COUNT; i++) {\r\nif (dev->urbs[i]) {\r\nusb_kill_urb(dev->urbs[i]);\r\nif (!preallocate_big_buffers)\r\nkfree(dev->urbs[i]->transfer_buffer);\r\nusb_free_urb(dev->urbs[i]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int start_urb_transfer(struct au0828_dev *dev)\r\n{\r\nstruct urb *purb;\r\nint i, ret;\r\ndprintk(2, "%s()\n", __func__);\r\nif (dev->urb_streaming) {\r\ndprintk(2, "%s: bulk xfer already running!\n", __func__);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < URB_COUNT; i++) {\r\ndev->urbs[i] = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->urbs[i])\r\nreturn -ENOMEM;\r\npurb = dev->urbs[i];\r\nif (preallocate_big_buffers)\r\npurb->transfer_buffer = dev->dig_transfer_buffer[i];\r\nelse\r\npurb->transfer_buffer = kzalloc(URB_BUFSIZE,\r\nGFP_KERNEL);\r\nif (!purb->transfer_buffer) {\r\nusb_free_urb(purb);\r\ndev->urbs[i] = NULL;\r\nret = -ENOMEM;\r\npr_err("%s: failed big buffer allocation, err = %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\npurb->status = -EINPROGRESS;\r\nusb_fill_bulk_urb(purb,\r\ndev->usbdev,\r\nusb_rcvbulkpipe(dev->usbdev,\r\n_AU0828_BULKPIPE),\r\npurb->transfer_buffer,\r\nURB_BUFSIZE,\r\nurb_completion,\r\ndev);\r\n}\r\nfor (i = 0; i < URB_COUNT; i++) {\r\nret = usb_submit_urb(dev->urbs[i], GFP_ATOMIC);\r\nif (ret != 0) {\r\nstop_urb_transfer(dev);\r\npr_err("%s: failed urb submission, err = %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\n}\r\ndev->urb_streaming = true;\r\nmod_timer(&dev->bulk_timeout, jiffies + (HZ));\r\ndev->bulk_timeout_running = 1;\r\nreturn 0;\r\n}\r\nstatic void au0828_start_transport(struct au0828_dev *dev)\r\n{\r\nau0828_write(dev, 0x608, 0x90);\r\nau0828_write(dev, 0x609, 0x72);\r\nau0828_write(dev, 0x60a, 0x71);\r\nau0828_write(dev, 0x60b, 0x01);\r\n}\r\nstatic void au0828_stop_transport(struct au0828_dev *dev, int full_stop)\r\n{\r\nif (full_stop) {\r\nau0828_write(dev, 0x608, 0x00);\r\nau0828_write(dev, 0x609, 0x00);\r\nau0828_write(dev, 0x60a, 0x00);\r\n}\r\nau0828_write(dev, 0x60b, 0x00);\r\n}\r\nstatic int au0828_dvb_start_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct au0828_dev *dev = (struct au0828_dev *) demux->priv;\r\nstruct au0828_dvb *dvb = &dev->dvb;\r\nint ret = 0;\r\ndprintk(1, "%s()\n", __func__);\r\nif (!demux->dmx.frontend)\r\nreturn -EINVAL;\r\nif (dvb->frontend) {\r\nmutex_lock(&dvb->lock);\r\ndvb->start_count++;\r\ndprintk(1, "%s(), start_count: %d, stop_count: %d\n", __func__,\r\ndvb->start_count, dvb->stop_count);\r\nif (dvb->feeding++ == 0) {\r\nau0828_start_transport(dev);\r\nret = start_urb_transfer(dev);\r\nif (ret < 0) {\r\nau0828_stop_transport(dev, 0);\r\ndvb->feeding--;\r\n}\r\n}\r\nmutex_unlock(&dvb->lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic int au0828_dvb_stop_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct au0828_dev *dev = (struct au0828_dev *) demux->priv;\r\nstruct au0828_dvb *dvb = &dev->dvb;\r\nint ret = 0;\r\ndprintk(1, "%s()\n", __func__);\r\nif (dvb->frontend) {\r\ncancel_work_sync(&dev->restart_streaming);\r\nmutex_lock(&dvb->lock);\r\ndvb->stop_count++;\r\ndprintk(1, "%s(), start_count: %d, stop_count: %d\n", __func__,\r\ndvb->start_count, dvb->stop_count);\r\nif (dvb->feeding > 0) {\r\ndvb->feeding--;\r\nif (dvb->feeding == 0) {\r\nret = stop_urb_transfer(dev);\r\nau0828_stop_transport(dev, 0);\r\n}\r\n}\r\nmutex_unlock(&dvb->lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic void au0828_restart_dvb_streaming(struct work_struct *work)\r\n{\r\nstruct au0828_dev *dev = container_of(work, struct au0828_dev,\r\nrestart_streaming);\r\nstruct au0828_dvb *dvb = &dev->dvb;\r\nif (!dev->urb_streaming)\r\nreturn;\r\ndprintk(1, "Restarting streaming...!\n");\r\nmutex_lock(&dvb->lock);\r\nstop_urb_transfer(dev);\r\nau0828_stop_transport(dev, 1);\r\nau0828_start_transport(dev);\r\nstart_urb_transfer(dev);\r\nmutex_unlock(&dvb->lock);\r\n}\r\nstatic int au0828_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct au0828_dev *dev = fe->dvb->priv;\r\nstruct au0828_dvb *dvb = &dev->dvb;\r\nint ret, was_streaming;\r\nmutex_lock(&dvb->lock);\r\nwas_streaming = dev->urb_streaming;\r\nif (was_streaming) {\r\nau0828_stop_transport(dev, 1);\r\nmutex_unlock(&dvb->lock);\r\ncancel_work_sync(&dev->restart_streaming);\r\nmutex_lock(&dvb->lock);\r\nstop_urb_transfer(dev);\r\n}\r\nmutex_unlock(&dvb->lock);\r\nret = dvb->set_frontend(fe);\r\nif (was_streaming) {\r\nmutex_lock(&dvb->lock);\r\nau0828_start_transport(dev);\r\nstart_urb_transfer(dev);\r\nmutex_unlock(&dvb->lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic int dvb_register(struct au0828_dev *dev)\r\n{\r\nstruct au0828_dvb *dvb = &dev->dvb;\r\nint result;\r\ndprintk(1, "%s()\n", __func__);\r\nif (preallocate_big_buffers) {\r\nint i;\r\nfor (i = 0; i < URB_COUNT; i++) {\r\ndev->dig_transfer_buffer[i] = kzalloc(URB_BUFSIZE,\r\nGFP_KERNEL);\r\nif (!dev->dig_transfer_buffer[i]) {\r\nresult = -ENOMEM;\r\npr_err("failed buffer allocation (errno = %d)\n",\r\nresult);\r\ngoto fail_adapter;\r\n}\r\n}\r\n}\r\nINIT_WORK(&dev->restart_streaming, au0828_restart_dvb_streaming);\r\nresult = dvb_register_adapter(&dvb->adapter,\r\nKBUILD_MODNAME, THIS_MODULE,\r\n&dev->usbdev->dev, adapter_nr);\r\nif (result < 0) {\r\npr_err("dvb_register_adapter failed (errno = %d)\n",\r\nresult);\r\ngoto fail_adapter;\r\n}\r\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\r\ndvb->adapter.mdev = dev->media_dev;\r\n#endif\r\ndvb->adapter.priv = dev;\r\nresult = dvb_register_frontend(&dvb->adapter, dvb->frontend);\r\nif (result < 0) {\r\npr_err("dvb_register_frontend failed (errno = %d)\n",\r\nresult);\r\ngoto fail_frontend;\r\n}\r\ndvb->set_frontend = dvb->frontend->ops.set_frontend;\r\ndvb->frontend->ops.set_frontend = au0828_set_frontend;\r\ndvb->demux.dmx.capabilities =\r\nDMX_TS_FILTERING | DMX_SECTION_FILTERING |\r\nDMX_MEMORY_BASED_FILTERING;\r\ndvb->demux.priv = dev;\r\ndvb->demux.filternum = 256;\r\ndvb->demux.feednum = 256;\r\ndvb->demux.start_feed = au0828_dvb_start_feed;\r\ndvb->demux.stop_feed = au0828_dvb_stop_feed;\r\nresult = dvb_dmx_init(&dvb->demux);\r\nif (result < 0) {\r\npr_err("dvb_dmx_init failed (errno = %d)\n", result);\r\ngoto fail_dmx;\r\n}\r\ndvb->dmxdev.filternum = 256;\r\ndvb->dmxdev.demux = &dvb->demux.dmx;\r\ndvb->dmxdev.capabilities = 0;\r\nresult = dvb_dmxdev_init(&dvb->dmxdev, &dvb->adapter);\r\nif (result < 0) {\r\npr_err("dvb_dmxdev_init failed (errno = %d)\n", result);\r\ngoto fail_dmxdev;\r\n}\r\ndvb->fe_hw.source = DMX_FRONTEND_0;\r\nresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\nif (result < 0) {\r\npr_err("add_frontend failed (DMX_FRONTEND_0, errno = %d)\n",\r\nresult);\r\ngoto fail_fe_hw;\r\n}\r\ndvb->fe_mem.source = DMX_MEMORY_FE;\r\nresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_mem);\r\nif (result < 0) {\r\npr_err("add_frontend failed (DMX_MEMORY_FE, errno = %d)\n",\r\nresult);\r\ngoto fail_fe_mem;\r\n}\r\nresult = dvb->demux.dmx.connect_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\nif (result < 0) {\r\npr_err("connect_frontend failed (errno = %d)\n", result);\r\ngoto fail_fe_conn;\r\n}\r\ndvb_net_init(&dvb->adapter, &dvb->net, &dvb->demux.dmx);\r\ndvb->start_count = 0;\r\ndvb->stop_count = 0;\r\nresult = dvb_create_media_graph(&dvb->adapter, false);\r\nif (result < 0)\r\ngoto fail_create_graph;\r\nreturn 0;\r\nfail_create_graph:\r\ndvb_net_release(&dvb->net);\r\nfail_fe_conn:\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\r\nfail_fe_mem:\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\nfail_fe_hw:\r\ndvb_dmxdev_release(&dvb->dmxdev);\r\nfail_dmxdev:\r\ndvb_dmx_release(&dvb->demux);\r\nfail_dmx:\r\ndvb_unregister_frontend(dvb->frontend);\r\nfail_frontend:\r\ndvb_frontend_detach(dvb->frontend);\r\ndvb_unregister_adapter(&dvb->adapter);\r\nfail_adapter:\r\nif (preallocate_big_buffers) {\r\nint i;\r\nfor (i = 0; i < URB_COUNT; i++)\r\nkfree(dev->dig_transfer_buffer[i]);\r\n}\r\nreturn result;\r\n}\r\nvoid au0828_dvb_unregister(struct au0828_dev *dev)\r\n{\r\nstruct au0828_dvb *dvb = &dev->dvb;\r\ndprintk(1, "%s()\n", __func__);\r\nif (dvb->frontend == NULL)\r\nreturn;\r\ncancel_work_sync(&dev->restart_streaming);\r\ndvb_net_release(&dvb->net);\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\ndvb_dmxdev_release(&dvb->dmxdev);\r\ndvb_dmx_release(&dvb->demux);\r\ndvb_unregister_frontend(dvb->frontend);\r\ndvb_frontend_detach(dvb->frontend);\r\ndvb_unregister_adapter(&dvb->adapter);\r\nif (preallocate_big_buffers) {\r\nint i;\r\nfor (i = 0; i < URB_COUNT; i++)\r\nkfree(dev->dig_transfer_buffer[i]);\r\n}\r\ndvb->frontend = NULL;\r\n}\r\nint au0828_dvb_register(struct au0828_dev *dev)\r\n{\r\nstruct au0828_dvb *dvb = &dev->dvb;\r\nint ret;\r\ndprintk(1, "%s()\n", __func__);\r\nswitch (dev->boardnr) {\r\ncase AU0828_BOARD_HAUPPAUGE_HVR850:\r\ncase AU0828_BOARD_HAUPPAUGE_HVR950Q:\r\ndvb->frontend = dvb_attach(au8522_attach,\r\n&hauppauge_hvr950q_config,\r\n&dev->i2c_adap);\r\nif (dvb->frontend != NULL)\r\nswitch (dev->board.tuner_type) {\r\ndefault:\r\ncase TUNER_XC5000:\r\ndvb_attach(xc5000_attach, dvb->frontend,\r\n&dev->i2c_adap,\r\n&hauppauge_xc5000a_config);\r\nbreak;\r\ncase TUNER_XC5000C:\r\ndvb_attach(xc5000_attach, dvb->frontend,\r\n&dev->i2c_adap,\r\n&hauppauge_xc5000c_config);\r\nbreak;\r\n}\r\nbreak;\r\ncase AU0828_BOARD_HAUPPAUGE_HVR950Q_MXL:\r\ndvb->frontend = dvb_attach(au8522_attach,\r\n&hauppauge_hvr950q_config,\r\n&dev->i2c_adap);\r\nif (dvb->frontend != NULL)\r\ndvb_attach(mxl5007t_attach, dvb->frontend,\r\n&dev->i2c_adap, 0x60,\r\n&mxl5007t_hvr950q_config);\r\nbreak;\r\ncase AU0828_BOARD_HAUPPAUGE_WOODBURY:\r\ndvb->frontend = dvb_attach(au8522_attach,\r\n&hauppauge_woodbury_config,\r\n&dev->i2c_adap);\r\nif (dvb->frontend != NULL)\r\ndvb_attach(tda18271_attach, dvb->frontend,\r\n0x60, &dev->i2c_adap,\r\n&hauppauge_woodbury_tunerconfig);\r\nbreak;\r\ncase AU0828_BOARD_DVICO_FUSIONHDTV7:\r\ndvb->frontend = dvb_attach(au8522_attach,\r\n&fusionhdtv7usb_config,\r\n&dev->i2c_adap);\r\nif (dvb->frontend != NULL) {\r\ndvb_attach(xc5000_attach, dvb->frontend,\r\n&dev->i2c_adap,\r\n&hauppauge_xc5000a_config);\r\n}\r\nbreak;\r\ndefault:\r\npr_warn("The frontend of your DVB/ATSC card isn't supported yet\n");\r\nbreak;\r\n}\r\nif (NULL == dvb->frontend) {\r\npr_err("%s() Frontend initialization failed\n",\r\n__func__);\r\nreturn -1;\r\n}\r\ndvb->frontend->callback = au0828_tuner_callback;\r\nret = dvb_register(dev);\r\nif (ret < 0) {\r\nif (dvb->frontend->ops.release)\r\ndvb->frontend->ops.release(dvb->frontend);\r\ndvb->frontend = NULL;\r\nreturn ret;\r\n}\r\ndev->bulk_timeout.function = au0828_bulk_timeout;\r\ndev->bulk_timeout.data = (unsigned long) dev;\r\ninit_timer(&dev->bulk_timeout);\r\nreturn 0;\r\n}\r\nvoid au0828_dvb_suspend(struct au0828_dev *dev)\r\n{\r\nstruct au0828_dvb *dvb = &dev->dvb;\r\nint rc;\r\nif (dvb->frontend) {\r\nif (dev->urb_streaming) {\r\ncancel_work_sync(&dev->restart_streaming);\r\nmutex_lock(&dvb->lock);\r\nstop_urb_transfer(dev);\r\nau0828_stop_transport(dev, 1);\r\nmutex_unlock(&dvb->lock);\r\ndev->need_urb_start = true;\r\n}\r\nrc = dvb_frontend_suspend(dvb->frontend);\r\npr_info("au0828_dvb_suspend(): Suspending DVB fe %d\n", rc);\r\n}\r\n}\r\nvoid au0828_dvb_resume(struct au0828_dev *dev)\r\n{\r\nstruct au0828_dvb *dvb = &dev->dvb;\r\nint rc;\r\nif (dvb->frontend) {\r\nrc = dvb_frontend_resume(dvb->frontend);\r\npr_info("au0828_dvb_resume(): Resuming DVB fe %d\n", rc);\r\nif (dev->need_urb_start) {\r\nmutex_lock(&dvb->lock);\r\nau0828_start_transport(dev);\r\nstart_urb_transfer(dev);\r\nmutex_unlock(&dvb->lock);\r\n}\r\n}\r\n}
