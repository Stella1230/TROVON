struct sst_block *sst_create_block(struct intel_sst_drv *ctx,\r\nu32 msg_id, u32 drv_id)\r\n{\r\nstruct sst_block *msg = NULL;\r\ndev_dbg(ctx->dev, "Enter\n");\r\nmsg = kzalloc(sizeof(*msg), GFP_KERNEL);\r\nif (!msg)\r\nreturn NULL;\r\nmsg->condition = false;\r\nmsg->on = true;\r\nmsg->msg_id = msg_id;\r\nmsg->drv_id = drv_id;\r\nspin_lock_bh(&ctx->block_lock);\r\nlist_add_tail(&msg->node, &ctx->block_list);\r\nspin_unlock_bh(&ctx->block_lock);\r\nreturn msg;\r\n}\r\nint sst_wake_up_block(struct intel_sst_drv *ctx, int result,\r\nu32 drv_id, u32 ipc, void *data, u32 size)\r\n{\r\nstruct sst_block *block = NULL;\r\ndev_dbg(ctx->dev, "Enter\n");\r\nspin_lock_bh(&ctx->block_lock);\r\nlist_for_each_entry(block, &ctx->block_list, node) {\r\ndev_dbg(ctx->dev, "Block ipc %d, drv_id %d\n", block->msg_id,\r\nblock->drv_id);\r\nif (block->msg_id == ipc && block->drv_id == drv_id) {\r\ndev_dbg(ctx->dev, "free up the block\n");\r\nblock->ret_code = result;\r\nblock->data = data;\r\nblock->size = size;\r\nblock->condition = true;\r\nspin_unlock_bh(&ctx->block_lock);\r\nwake_up(&ctx->wait_queue);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock_bh(&ctx->block_lock);\r\ndev_dbg(ctx->dev,\r\n"Block not found or a response received for a short msg for ipc %d, drv_id %d\n",\r\nipc, drv_id);\r\nreturn -EINVAL;\r\n}\r\nint sst_free_block(struct intel_sst_drv *ctx, struct sst_block *freed)\r\n{\r\nstruct sst_block *block = NULL, *__block;\r\ndev_dbg(ctx->dev, "Enter\n");\r\nspin_lock_bh(&ctx->block_lock);\r\nlist_for_each_entry_safe(block, __block, &ctx->block_list, node) {\r\nif (block == freed) {\r\npr_debug("pvt_id freed --> %d\n", freed->drv_id);\r\nlist_del(&freed->node);\r\nspin_unlock_bh(&ctx->block_lock);\r\nkfree(freed->data);\r\nfreed->data = NULL;\r\nkfree(freed);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock_bh(&ctx->block_lock);\r\ndev_err(ctx->dev, "block is already freed!!!\n");\r\nreturn -EINVAL;\r\n}\r\nint sst_post_message_mrfld(struct intel_sst_drv *sst_drv_ctx,\r\nstruct ipc_post *ipc_msg, bool sync)\r\n{\r\nstruct ipc_post *msg = ipc_msg;\r\nunion ipc_header_mrfld header;\r\nunsigned int loop_count = 0;\r\nint retval = 0;\r\nunsigned long irq_flags;\r\ndev_dbg(sst_drv_ctx->dev, "Enter: sync: %d\n", sync);\r\nspin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);\r\nheader.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCX);\r\nif (sync) {\r\nwhile (header.p.header_high.part.busy) {\r\nif (loop_count > 25) {\r\ndev_err(sst_drv_ctx->dev,\r\n"sst: Busy wait failed, cant send this msg\n");\r\nretval = -EBUSY;\r\ngoto out;\r\n}\r\ncpu_relax();\r\nloop_count++;\r\nheader.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCX);\r\n}\r\n} else {\r\nif (list_empty(&sst_drv_ctx->ipc_dispatch_list)) {\r\nspin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);\r\ndev_dbg(sst_drv_ctx->dev,\r\n"Empty msg queue... NO Action\n");\r\nreturn 0;\r\n}\r\nif (header.p.header_high.part.busy) {\r\nspin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);\r\ndev_dbg(sst_drv_ctx->dev, "Busy not free... post later\n");\r\nreturn 0;\r\n}\r\nmsg = list_entry(sst_drv_ctx->ipc_dispatch_list.next,\r\nstruct ipc_post, node);\r\nlist_del(&msg->node);\r\n}\r\ndev_dbg(sst_drv_ctx->dev, "sst: Post message: header = %x\n",\r\nmsg->mrfld_header.p.header_high.full);\r\ndev_dbg(sst_drv_ctx->dev, "sst: size = 0x%x\n",\r\nmsg->mrfld_header.p.header_low_payload);\r\nif (msg->mrfld_header.p.header_high.part.large)\r\nmemcpy_toio(sst_drv_ctx->mailbox + SST_MAILBOX_SEND,\r\nmsg->mailbox_data,\r\nmsg->mrfld_header.p.header_low_payload);\r\nsst_shim_write64(sst_drv_ctx->shim, SST_IPCX, msg->mrfld_header.full);\r\nout:\r\nspin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);\r\nkfree(msg->mailbox_data);\r\nkfree(msg);\r\nreturn retval;\r\n}\r\nvoid intel_sst_clear_intr_mrfld(struct intel_sst_drv *sst_drv_ctx)\r\n{\r\nunion interrupt_reg_mrfld isr;\r\nunion interrupt_reg_mrfld imr;\r\nunion ipc_header_mrfld clear_ipc;\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);\r\nimr.full = sst_shim_read64(sst_drv_ctx->shim, SST_IMRX);\r\nisr.full = sst_shim_read64(sst_drv_ctx->shim, SST_ISRX);\r\nisr.part.busy_interrupt = 1;\r\nsst_shim_write64(sst_drv_ctx->shim, SST_ISRX, isr.full);\r\nclear_ipc.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCD);\r\nclear_ipc.p.header_high.part.busy = 0;\r\nclear_ipc.p.header_high.part.done = 1;\r\nclear_ipc.p.header_low_payload = IPC_ACK_SUCCESS;\r\nsst_shim_write64(sst_drv_ctx->shim, SST_IPCD, clear_ipc.full);\r\nimr.part.busy_interrupt = 0;\r\nsst_shim_write64(sst_drv_ctx->shim, SST_IMRX, imr.full);\r\nspin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);\r\n}\r\nstatic void process_fw_init(struct intel_sst_drv *sst_drv_ctx,\r\nvoid *msg)\r\n{\r\nstruct ipc_header_fw_init *init =\r\n(struct ipc_header_fw_init *)msg;\r\nint retval = 0;\r\ndev_dbg(sst_drv_ctx->dev, "*** FW Init msg came***\n");\r\nif (init->result) {\r\nsst_set_fw_state_locked(sst_drv_ctx, SST_RESET);\r\ndev_err(sst_drv_ctx->dev, "FW Init failed, Error %x\n",\r\ninit->result);\r\nretval = init->result;\r\ngoto ret;\r\n}\r\nif (memcmp(&sst_drv_ctx->fw_version, &init->fw_version,\r\nsizeof(init->fw_version)))\r\ndev_info(sst_drv_ctx->dev, "FW Version %02x.%02x.%02x.%02x\n",\r\ninit->fw_version.type, init->fw_version.major,\r\ninit->fw_version.minor, init->fw_version.build);\r\ndev_dbg(sst_drv_ctx->dev, "Build date %s Time %s\n",\r\ninit->build_info.date, init->build_info.time);\r\nsst_drv_ctx->fw_version.type = init->fw_version.type;\r\nsst_drv_ctx->fw_version.major = init->fw_version.major;\r\nsst_drv_ctx->fw_version.minor = init->fw_version.minor;\r\nsst_drv_ctx->fw_version.build = init->fw_version.build;\r\nret:\r\nsst_wake_up_block(sst_drv_ctx, retval, FW_DWNL_ID, 0 , NULL, 0);\r\n}\r\nstatic void process_fw_async_msg(struct intel_sst_drv *sst_drv_ctx,\r\nstruct ipc_post *msg)\r\n{\r\nu32 msg_id;\r\nint str_id;\r\nu32 data_size, i;\r\nvoid *data_offset;\r\nstruct stream_info *stream;\r\nu32 msg_low, pipe_id;\r\nmsg_low = msg->mrfld_header.p.header_low_payload;\r\nmsg_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->cmd_id;\r\ndata_offset = (msg->mailbox_data + sizeof(struct ipc_dsp_hdr));\r\ndata_size = msg_low - (sizeof(struct ipc_dsp_hdr));\r\nswitch (msg_id) {\r\ncase IPC_SST_PERIOD_ELAPSED_MRFLD:\r\npipe_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->pipe_id;\r\nstr_id = get_stream_id_mrfld(sst_drv_ctx, pipe_id);\r\nif (str_id > 0) {\r\ndev_dbg(sst_drv_ctx->dev,\r\n"Period elapsed rcvd for pipe id 0x%x\n",\r\npipe_id);\r\nstream = &sst_drv_ctx->streams[str_id];\r\nif (stream->status == STREAM_INIT)\r\nbreak;\r\nif (stream->period_elapsed)\r\nstream->period_elapsed(stream->pcm_substream);\r\nif (stream->compr_cb)\r\nstream->compr_cb(stream->compr_cb_param);\r\n}\r\nbreak;\r\ncase IPC_IA_DRAIN_STREAM_MRFLD:\r\npipe_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->pipe_id;\r\nstr_id = get_stream_id_mrfld(sst_drv_ctx, pipe_id);\r\nif (str_id > 0) {\r\nstream = &sst_drv_ctx->streams[str_id];\r\nif (stream->drain_notify)\r\nstream->drain_notify(stream->drain_cb_param);\r\n}\r\nbreak;\r\ncase IPC_IA_FW_ASYNC_ERR_MRFLD:\r\ndev_err(sst_drv_ctx->dev, "FW sent async error msg:\n");\r\nfor (i = 0; i < (data_size/4); i++)\r\nprint_hex_dump(KERN_DEBUG, NULL, DUMP_PREFIX_NONE,\r\n16, 4, data_offset, data_size, false);\r\nbreak;\r\ncase IPC_IA_FW_INIT_CMPLT_MRFLD:\r\nprocess_fw_init(sst_drv_ctx, data_offset);\r\nbreak;\r\ncase IPC_IA_BUF_UNDER_RUN_MRFLD:\r\npipe_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->pipe_id;\r\nstr_id = get_stream_id_mrfld(sst_drv_ctx, pipe_id);\r\nif (str_id > 0)\r\ndev_err(sst_drv_ctx->dev,\r\n"Buffer under-run for pipe:%#x str_id:%d\n",\r\npipe_id, str_id);\r\nbreak;\r\ndefault:\r\ndev_err(sst_drv_ctx->dev,\r\n"Unrecognized async msg from FW msg_id %#x\n", msg_id);\r\n}\r\n}\r\nvoid sst_process_reply_mrfld(struct intel_sst_drv *sst_drv_ctx,\r\nstruct ipc_post *msg)\r\n{\r\nunsigned int drv_id;\r\nvoid *data;\r\nunion ipc_header_high msg_high;\r\nu32 msg_low;\r\nstruct ipc_dsp_hdr *dsp_hdr;\r\nmsg_high = msg->mrfld_header.p.header_high;\r\nmsg_low = msg->mrfld_header.p.header_low_payload;\r\ndev_dbg(sst_drv_ctx->dev, "IPC process message header %x payload %x\n",\r\nmsg->mrfld_header.p.header_high.full,\r\nmsg->mrfld_header.p.header_low_payload);\r\ndrv_id = msg_high.part.drv_id;\r\nif (drv_id == SST_ASYNC_DRV_ID) {\r\nprocess_fw_async_msg(sst_drv_ctx, msg);\r\nreturn;\r\n}\r\nif (msg_high.part.result && drv_id && !msg_high.part.large) {\r\ndev_err(sst_drv_ctx->dev, "FW sent error response 0x%x", msg_low);\r\nsst_wake_up_block(sst_drv_ctx, msg_high.part.result,\r\nmsg_high.part.drv_id,\r\nmsg_high.part.msg_id, NULL, 0);\r\nreturn;\r\n}\r\nif (msg_high.part.large) {\r\ndata = kmemdup((void *)msg->mailbox_data, msg_low, GFP_KERNEL);\r\nif (!data)\r\nreturn;\r\ndsp_hdr = (struct ipc_dsp_hdr *)data;\r\ndev_dbg(sst_drv_ctx->dev, "cmd_id %d\n", dsp_hdr->cmd_id);\r\nif (sst_wake_up_block(sst_drv_ctx, msg_high.part.result,\r\nmsg_high.part.drv_id,\r\nmsg_high.part.msg_id, data, msg_low))\r\nkfree(data);\r\n} else {\r\nsst_wake_up_block(sst_drv_ctx, msg_high.part.result,\r\nmsg_high.part.drv_id,\r\nmsg_high.part.msg_id, NULL, 0);\r\n}\r\n}
