static void ufs_qcom_dump_regs(struct ufs_hba *hba, int offset, int len,\r\nchar *prefix)\r\n{\r\nprint_hex_dump(KERN_ERR, prefix,\r\nlen > 4 ? DUMP_PREFIX_OFFSET : DUMP_PREFIX_NONE,\r\n16, 4, (void __force *)hba->mmio_base + offset,\r\nlen * 4, false);\r\n}\r\nstatic void ufs_qcom_dump_regs_wrapper(struct ufs_hba *hba, int offset, int len,\r\nchar *prefix, void *priv)\r\n{\r\nufs_qcom_dump_regs(hba, offset, len, prefix);\r\n}\r\nstatic int ufs_qcom_get_connected_tx_lanes(struct ufs_hba *hba, u32 *tx_lanes)\r\n{\r\nint err = 0;\r\nerr = ufshcd_dme_get(hba,\r\nUIC_ARG_MIB(PA_CONNECTEDTXDATALANES), tx_lanes);\r\nif (err)\r\ndev_err(hba->dev, "%s: couldn't read PA_CONNECTEDTXDATALANES %d\n",\r\n__func__, err);\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_host_clk_get(struct device *dev,\r\nconst char *name, struct clk **clk_out)\r\n{\r\nstruct clk *clk;\r\nint err = 0;\r\nclk = devm_clk_get(dev, name);\r\nif (IS_ERR(clk)) {\r\nerr = PTR_ERR(clk);\r\ndev_err(dev, "%s: failed to get %s err %d",\r\n__func__, name, err);\r\n} else {\r\n*clk_out = clk;\r\n}\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_host_clk_enable(struct device *dev,\r\nconst char *name, struct clk *clk)\r\n{\r\nint err = 0;\r\nerr = clk_prepare_enable(clk);\r\nif (err)\r\ndev_err(dev, "%s: %s enable failed %d\n", __func__, name, err);\r\nreturn err;\r\n}\r\nstatic void ufs_qcom_disable_lane_clks(struct ufs_qcom_host *host)\r\n{\r\nif (!host->is_lane_clks_enabled)\r\nreturn;\r\nif (host->hba->lanes_per_direction > 1)\r\nclk_disable_unprepare(host->tx_l1_sync_clk);\r\nclk_disable_unprepare(host->tx_l0_sync_clk);\r\nif (host->hba->lanes_per_direction > 1)\r\nclk_disable_unprepare(host->rx_l1_sync_clk);\r\nclk_disable_unprepare(host->rx_l0_sync_clk);\r\nhost->is_lane_clks_enabled = false;\r\n}\r\nstatic int ufs_qcom_enable_lane_clks(struct ufs_qcom_host *host)\r\n{\r\nint err = 0;\r\nstruct device *dev = host->hba->dev;\r\nif (host->is_lane_clks_enabled)\r\nreturn 0;\r\nerr = ufs_qcom_host_clk_enable(dev, "rx_lane0_sync_clk",\r\nhost->rx_l0_sync_clk);\r\nif (err)\r\ngoto out;\r\nerr = ufs_qcom_host_clk_enable(dev, "tx_lane0_sync_clk",\r\nhost->tx_l0_sync_clk);\r\nif (err)\r\ngoto disable_rx_l0;\r\nif (host->hba->lanes_per_direction > 1) {\r\nerr = ufs_qcom_host_clk_enable(dev, "rx_lane1_sync_clk",\r\nhost->rx_l1_sync_clk);\r\nif (err)\r\ngoto disable_tx_l0;\r\nerr = ufs_qcom_host_clk_enable(dev, "tx_lane1_sync_clk",\r\nhost->tx_l1_sync_clk);\r\nif (err)\r\ngoto disable_rx_l1;\r\n}\r\nhost->is_lane_clks_enabled = true;\r\ngoto out;\r\ndisable_rx_l1:\r\nif (host->hba->lanes_per_direction > 1)\r\nclk_disable_unprepare(host->rx_l1_sync_clk);\r\ndisable_tx_l0:\r\nclk_disable_unprepare(host->tx_l0_sync_clk);\r\ndisable_rx_l0:\r\nclk_disable_unprepare(host->rx_l0_sync_clk);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_init_lane_clks(struct ufs_qcom_host *host)\r\n{\r\nint err = 0;\r\nstruct device *dev = host->hba->dev;\r\nerr = ufs_qcom_host_clk_get(dev,\r\n"rx_lane0_sync_clk", &host->rx_l0_sync_clk);\r\nif (err)\r\ngoto out;\r\nerr = ufs_qcom_host_clk_get(dev,\r\n"tx_lane0_sync_clk", &host->tx_l0_sync_clk);\r\nif (err)\r\ngoto out;\r\nif (host->hba->lanes_per_direction > 1) {\r\nerr = ufs_qcom_host_clk_get(dev, "rx_lane1_sync_clk",\r\n&host->rx_l1_sync_clk);\r\nif (err)\r\ngoto out;\r\nerr = ufs_qcom_host_clk_get(dev, "tx_lane1_sync_clk",\r\n&host->tx_l1_sync_clk);\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_link_startup_post_change(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nstruct phy *phy = host->generic_phy;\r\nu32 tx_lanes;\r\nint err = 0;\r\nerr = ufs_qcom_get_connected_tx_lanes(hba, &tx_lanes);\r\nif (err)\r\ngoto out;\r\nerr = ufs_qcom_phy_set_tx_lane_enable(phy, tx_lanes);\r\nif (err)\r\ndev_err(hba->dev, "%s: ufs_qcom_phy_set_tx_lane_enable failed\n",\r\n__func__);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_check_hibern8(struct ufs_hba *hba)\r\n{\r\nint err;\r\nu32 tx_fsm_val = 0;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(HBRN8_POLL_TOUT_MS);\r\ndo {\r\nerr = ufshcd_dme_get(hba,\r\nUIC_ARG_MIB_SEL(MPHY_TX_FSM_STATE,\r\nUIC_ARG_MPHY_TX_GEN_SEL_INDEX(0)),\r\n&tx_fsm_val);\r\nif (err || tx_fsm_val == TX_FSM_HIBERN8)\r\nbreak;\r\nusleep_range(100, 200);\r\n} while (time_before(jiffies, timeout));\r\nif (time_after(jiffies, timeout))\r\nerr = ufshcd_dme_get(hba,\r\nUIC_ARG_MIB_SEL(MPHY_TX_FSM_STATE,\r\nUIC_ARG_MPHY_TX_GEN_SEL_INDEX(0)),\r\n&tx_fsm_val);\r\nif (err) {\r\ndev_err(hba->dev, "%s: unable to get TX_FSM_STATE, err %d\n",\r\n__func__, err);\r\n} else if (tx_fsm_val != TX_FSM_HIBERN8) {\r\nerr = tx_fsm_val;\r\ndev_err(hba->dev, "%s: invalid TX_FSM_STATE = %d\n",\r\n__func__, err);\r\n}\r\nreturn err;\r\n}\r\nstatic void ufs_qcom_select_unipro_mode(struct ufs_qcom_host *host)\r\n{\r\nufshcd_rmwl(host->hba, QUNIPRO_SEL,\r\nufs_qcom_cap_qunipro(host) ? QUNIPRO_SEL : 0,\r\nREG_UFS_CFG1);\r\nmb();\r\n}\r\nstatic int ufs_qcom_power_up_sequence(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nstruct phy *phy = host->generic_phy;\r\nint ret = 0;\r\nbool is_rate_B = (UFS_QCOM_LIMIT_HS_RATE == PA_HS_MODE_B)\r\n? true : false;\r\nufs_qcom_assert_reset(hba);\r\nusleep_range(1000, 1100);\r\nret = ufs_qcom_phy_calibrate_phy(phy, is_rate_B);\r\nif (ret) {\r\ndev_err(hba->dev, "%s: ufs_qcom_phy_calibrate_phy() failed, ret = %d\n",\r\n__func__, ret);\r\ngoto out;\r\n}\r\nufs_qcom_deassert_reset(hba);\r\nusleep_range(1000, 1100);\r\nret = ufs_qcom_phy_start_serdes(phy);\r\nif (ret) {\r\ndev_err(hba->dev, "%s: ufs_qcom_phy_start_serdes() failed, ret = %d\n",\r\n__func__, ret);\r\ngoto out;\r\n}\r\nret = ufs_qcom_phy_is_pcs_ready(phy);\r\nif (ret)\r\ndev_err(hba->dev,\r\n"%s: is_physical_coding_sublayer_ready() failed, ret = %d\n",\r\n__func__, ret);\r\nufs_qcom_select_unipro_mode(host);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ufs_qcom_enable_hw_clk_gating(struct ufs_hba *hba)\r\n{\r\nufshcd_writel(hba,\r\nufshcd_readl(hba, REG_UFS_CFG2) | REG_UFS_CFG2_CGC_EN_ALL,\r\nREG_UFS_CFG2);\r\nmb();\r\n}\r\nstatic int ufs_qcom_hce_enable_notify(struct ufs_hba *hba,\r\nenum ufs_notify_change_status status)\r\n{\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nint err = 0;\r\nswitch (status) {\r\ncase PRE_CHANGE:\r\nufs_qcom_power_up_sequence(hba);\r\nerr = ufs_qcom_enable_lane_clks(host);\r\nbreak;\r\ncase POST_CHANGE:\r\nerr = ufs_qcom_check_hibern8(hba);\r\nufs_qcom_enable_hw_clk_gating(hba);\r\nbreak;\r\ndefault:\r\ndev_err(hba->dev, "%s: invalid status %d\n", __func__, status);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_cfg_timers(struct ufs_hba *hba, u32 gear,\r\nu32 hs, u32 rate, bool update_link_startup_timer)\r\n{\r\nint ret = 0;\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nstruct ufs_clk_info *clki;\r\nu32 core_clk_period_in_ns;\r\nu32 tx_clk_cycles_per_us = 0;\r\nunsigned long core_clk_rate = 0;\r\nu32 core_clk_cycles_per_us = 0;\r\nstatic u32 pwm_fr_table[][2] = {\r\n{UFS_PWM_G1, 0x1},\r\n{UFS_PWM_G2, 0x1},\r\n{UFS_PWM_G3, 0x1},\r\n{UFS_PWM_G4, 0x1},\r\n};\r\nstatic u32 hs_fr_table_rA[][2] = {\r\n{UFS_HS_G1, 0x1F},\r\n{UFS_HS_G2, 0x3e},\r\n{UFS_HS_G3, 0x7D},\r\n};\r\nstatic u32 hs_fr_table_rB[][2] = {\r\n{UFS_HS_G1, 0x24},\r\n{UFS_HS_G2, 0x49},\r\n{UFS_HS_G3, 0x92},\r\n};\r\nif (ufs_qcom_cap_qunipro(host) && !ufshcd_is_intr_aggr_allowed(hba))\r\ngoto out;\r\nif (gear == 0) {\r\ndev_err(hba->dev, "%s: invalid gear = %d\n", __func__, gear);\r\ngoto out_error;\r\n}\r\nlist_for_each_entry(clki, &hba->clk_list_head, list) {\r\nif (!strcmp(clki->name, "core_clk"))\r\ncore_clk_rate = clk_get_rate(clki->clk);\r\n}\r\nif (core_clk_rate < DEFAULT_CLK_RATE_HZ)\r\ncore_clk_rate = DEFAULT_CLK_RATE_HZ;\r\ncore_clk_cycles_per_us = core_clk_rate / USEC_PER_SEC;\r\nif (ufshcd_readl(hba, REG_UFS_SYS1CLK_1US) != core_clk_cycles_per_us) {\r\nufshcd_writel(hba, core_clk_cycles_per_us, REG_UFS_SYS1CLK_1US);\r\nmb();\r\n}\r\nif (ufs_qcom_cap_qunipro(host))\r\ngoto out;\r\ncore_clk_period_in_ns = NSEC_PER_SEC / core_clk_rate;\r\ncore_clk_period_in_ns <<= OFFSET_CLK_NS_REG;\r\ncore_clk_period_in_ns &= MASK_CLK_NS_REG;\r\nswitch (hs) {\r\ncase FASTAUTO_MODE:\r\ncase FAST_MODE:\r\nif (rate == PA_HS_MODE_A) {\r\nif (gear > ARRAY_SIZE(hs_fr_table_rA)) {\r\ndev_err(hba->dev,\r\n"%s: index %d exceeds table size %zu\n",\r\n__func__, gear,\r\nARRAY_SIZE(hs_fr_table_rA));\r\ngoto out_error;\r\n}\r\ntx_clk_cycles_per_us = hs_fr_table_rA[gear-1][1];\r\n} else if (rate == PA_HS_MODE_B) {\r\nif (gear > ARRAY_SIZE(hs_fr_table_rB)) {\r\ndev_err(hba->dev,\r\n"%s: index %d exceeds table size %zu\n",\r\n__func__, gear,\r\nARRAY_SIZE(hs_fr_table_rB));\r\ngoto out_error;\r\n}\r\ntx_clk_cycles_per_us = hs_fr_table_rB[gear-1][1];\r\n} else {\r\ndev_err(hba->dev, "%s: invalid rate = %d\n",\r\n__func__, rate);\r\ngoto out_error;\r\n}\r\nbreak;\r\ncase SLOWAUTO_MODE:\r\ncase SLOW_MODE:\r\nif (gear > ARRAY_SIZE(pwm_fr_table)) {\r\ndev_err(hba->dev,\r\n"%s: index %d exceeds table size %zu\n",\r\n__func__, gear,\r\nARRAY_SIZE(pwm_fr_table));\r\ngoto out_error;\r\n}\r\ntx_clk_cycles_per_us = pwm_fr_table[gear-1][1];\r\nbreak;\r\ncase UNCHANGED:\r\ndefault:\r\ndev_err(hba->dev, "%s: invalid mode = %d\n", __func__, hs);\r\ngoto out_error;\r\n}\r\nif (ufshcd_readl(hba, REG_UFS_TX_SYMBOL_CLK_NS_US) !=\r\n(core_clk_period_in_ns | tx_clk_cycles_per_us)) {\r\nufshcd_writel(hba, core_clk_period_in_ns | tx_clk_cycles_per_us,\r\nREG_UFS_TX_SYMBOL_CLK_NS_US);\r\nmb();\r\n}\r\nif (update_link_startup_timer) {\r\nufshcd_writel(hba, ((core_clk_rate / MSEC_PER_SEC) * 100),\r\nREG_UFS_PA_LINK_STARTUP_TIMER);\r\nmb();\r\n}\r\ngoto out;\r\nout_error:\r\nret = -EINVAL;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ufs_qcom_link_startup_notify(struct ufs_hba *hba,\r\nenum ufs_notify_change_status status)\r\n{\r\nint err = 0;\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nswitch (status) {\r\ncase PRE_CHANGE:\r\nif (ufs_qcom_cfg_timers(hba, UFS_PWM_G1, SLOWAUTO_MODE,\r\n0, true)) {\r\ndev_err(hba->dev, "%s: ufs_qcom_cfg_timers() failed\n",\r\n__func__);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (ufs_qcom_cap_qunipro(host))\r\nerr = ufs_qcom_set_dme_vs_core_clk_ctrl_clear_div(hba,\r\n150);\r\nif (ufshcd_get_local_unipro_ver(hba) != UFS_UNIPRO_VER_1_41)\r\nerr = ufshcd_dme_set(hba,\r\nUIC_ARG_MIB(PA_LOCAL_TX_LCC_ENABLE),\r\n0);\r\nbreak;\r\ncase POST_CHANGE:\r\nufs_qcom_link_startup_post_change(hba);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_suspend(struct ufs_hba *hba, enum ufs_pm_op pm_op)\r\n{\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nstruct phy *phy = host->generic_phy;\r\nint ret = 0;\r\nif (ufs_qcom_is_link_off(hba)) {\r\nufs_qcom_disable_lane_clks(host);\r\nphy_power_off(phy);\r\nufs_qcom_assert_reset(hba);\r\ngoto out;\r\n}\r\nif (!ufs_qcom_is_link_active(hba)) {\r\nufs_qcom_disable_lane_clks(host);\r\nphy_power_off(phy);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ufs_qcom_resume(struct ufs_hba *hba, enum ufs_pm_op pm_op)\r\n{\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nstruct phy *phy = host->generic_phy;\r\nint err;\r\nerr = phy_power_on(phy);\r\nif (err) {\r\ndev_err(hba->dev, "%s: failed enabling regs, err = %d\n",\r\n__func__, err);\r\ngoto out;\r\n}\r\nerr = ufs_qcom_enable_lane_clks(host);\r\nif (err)\r\ngoto out;\r\nhba->is_sys_suspended = false;\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_get_pwr_dev_param(struct ufs_qcom_dev_params *qcom_param,\r\nstruct ufs_pa_layer_attr *dev_max,\r\nstruct ufs_pa_layer_attr *agreed_pwr)\r\n{\r\nint min_qcom_gear;\r\nint min_dev_gear;\r\nbool is_dev_sup_hs = false;\r\nbool is_qcom_max_hs = false;\r\nif (dev_max->pwr_rx == FAST_MODE)\r\nis_dev_sup_hs = true;\r\nif (qcom_param->desired_working_mode == FAST) {\r\nis_qcom_max_hs = true;\r\nmin_qcom_gear = min_t(u32, qcom_param->hs_rx_gear,\r\nqcom_param->hs_tx_gear);\r\n} else {\r\nmin_qcom_gear = min_t(u32, qcom_param->pwm_rx_gear,\r\nqcom_param->pwm_tx_gear);\r\n}\r\nif (!is_dev_sup_hs && is_qcom_max_hs) {\r\npr_err("%s: failed to agree on power mode (device doesn't support HS but requested power is HS)\n",\r\n__func__);\r\nreturn -ENOTSUPP;\r\n} else if (is_dev_sup_hs && is_qcom_max_hs) {\r\nagreed_pwr->pwr_rx = agreed_pwr->pwr_tx =\r\nqcom_param->rx_pwr_hs;\r\n} else {\r\nagreed_pwr->pwr_rx = agreed_pwr->pwr_tx =\r\nqcom_param->rx_pwr_pwm;\r\n}\r\nagreed_pwr->lane_tx = min_t(u32, dev_max->lane_tx,\r\nqcom_param->tx_lanes);\r\nagreed_pwr->lane_rx = min_t(u32, dev_max->lane_rx,\r\nqcom_param->rx_lanes);\r\nmin_dev_gear = min_t(u32, dev_max->gear_rx, dev_max->gear_tx);\r\nif ((is_dev_sup_hs && is_qcom_max_hs) ||\r\n(!is_dev_sup_hs && !is_qcom_max_hs))\r\nagreed_pwr->gear_rx = agreed_pwr->gear_tx =\r\nmin_t(u32, min_dev_gear, min_qcom_gear);\r\nelse if (!is_dev_sup_hs)\r\nagreed_pwr->gear_rx = agreed_pwr->gear_tx = min_dev_gear;\r\nelse\r\nagreed_pwr->gear_rx = agreed_pwr->gear_tx = min_qcom_gear;\r\nagreed_pwr->hs_rate = qcom_param->hs_rate;\r\nreturn 0;\r\n}\r\nstatic int ufs_qcom_get_bus_vote(struct ufs_qcom_host *host,\r\nconst char *speed_mode)\r\n{\r\nstruct device *dev = host->hba->dev;\r\nstruct device_node *np = dev->of_node;\r\nint err;\r\nconst char *key = "qcom,bus-vector-names";\r\nif (!speed_mode) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (host->bus_vote.is_max_bw_needed && !!strcmp(speed_mode, "MIN"))\r\nerr = of_property_match_string(np, key, "MAX");\r\nelse\r\nerr = of_property_match_string(np, key, speed_mode);\r\nout:\r\nif (err < 0)\r\ndev_err(dev, "%s: Invalid %s mode %d\n",\r\n__func__, speed_mode, err);\r\nreturn err;\r\n}\r\nstatic void ufs_qcom_get_speed_mode(struct ufs_pa_layer_attr *p, char *result)\r\n{\r\nint gear = max_t(u32, p->gear_rx, p->gear_tx);\r\nint lanes = max_t(u32, p->lane_rx, p->lane_tx);\r\nint pwr;\r\nif (!gear)\r\ngear = 1;\r\nif (!lanes)\r\nlanes = 1;\r\nif (!p->pwr_rx && !p->pwr_tx) {\r\npwr = SLOWAUTO_MODE;\r\nsnprintf(result, BUS_VECTOR_NAME_LEN, "MIN");\r\n} else if (p->pwr_rx == FAST_MODE || p->pwr_rx == FASTAUTO_MODE ||\r\np->pwr_tx == FAST_MODE || p->pwr_tx == FASTAUTO_MODE) {\r\npwr = FAST_MODE;\r\nsnprintf(result, BUS_VECTOR_NAME_LEN, "%s_R%s_G%d_L%d", "HS",\r\np->hs_rate == PA_HS_MODE_B ? "B" : "A", gear, lanes);\r\n} else {\r\npwr = SLOW_MODE;\r\nsnprintf(result, BUS_VECTOR_NAME_LEN, "%s_G%d_L%d",\r\n"PWM", gear, lanes);\r\n}\r\n}\r\nstatic int ufs_qcom_set_bus_vote(struct ufs_qcom_host *host, int vote)\r\n{\r\nint err = 0;\r\nif (vote != host->bus_vote.curr_vote) {\r\nerr = msm_bus_scale_client_update_request(\r\nhost->bus_vote.client_handle, vote);\r\nif (err) {\r\ndev_err(host->hba->dev,\r\n"%s: msm_bus_scale_client_update_request() failed: bus_client_handle=0x%x, vote=%d, err=%d\n",\r\n__func__, host->bus_vote.client_handle,\r\nvote, err);\r\ngoto out;\r\n}\r\nhost->bus_vote.curr_vote = vote;\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_update_bus_bw_vote(struct ufs_qcom_host *host)\r\n{\r\nint vote;\r\nint err = 0;\r\nchar mode[BUS_VECTOR_NAME_LEN];\r\nufs_qcom_get_speed_mode(&host->dev_req_params, mode);\r\nvote = ufs_qcom_get_bus_vote(host, mode);\r\nif (vote >= 0)\r\nerr = ufs_qcom_set_bus_vote(host, vote);\r\nelse\r\nerr = vote;\r\nif (err)\r\ndev_err(host->hba->dev, "%s: failed %d\n", __func__, err);\r\nelse\r\nhost->bus_vote.saved_vote = vote;\r\nreturn err;\r\n}\r\nstatic ssize_t\r\nshow_ufs_to_mem_max_bus_bw(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ufs_hba *hba = dev_get_drvdata(dev);\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n",\r\nhost->bus_vote.is_max_bw_needed);\r\n}\r\nstatic ssize_t\r\nstore_ufs_to_mem_max_bus_bw(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ufs_hba *hba = dev_get_drvdata(dev);\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nuint32_t value;\r\nif (!kstrtou32(buf, 0, &value)) {\r\nhost->bus_vote.is_max_bw_needed = !!value;\r\nufs_qcom_update_bus_bw_vote(host);\r\n}\r\nreturn count;\r\n}\r\nstatic int ufs_qcom_bus_register(struct ufs_qcom_host *host)\r\n{\r\nint err;\r\nstruct msm_bus_scale_pdata *bus_pdata;\r\nstruct device *dev = host->hba->dev;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct device_node *np = dev->of_node;\r\nbus_pdata = msm_bus_cl_get_pdata(pdev);\r\nif (!bus_pdata) {\r\ndev_err(dev, "%s: failed to get bus vectors\n", __func__);\r\nerr = -ENODATA;\r\ngoto out;\r\n}\r\nerr = of_property_count_strings(np, "qcom,bus-vector-names");\r\nif (err < 0 || err != bus_pdata->num_usecases) {\r\ndev_err(dev, "%s: qcom,bus-vector-names not specified correctly %d\n",\r\n__func__, err);\r\ngoto out;\r\n}\r\nhost->bus_vote.client_handle = msm_bus_scale_register_client(bus_pdata);\r\nif (!host->bus_vote.client_handle) {\r\ndev_err(dev, "%s: msm_bus_scale_register_client failed\n",\r\n__func__);\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nhost->bus_vote.min_bw_vote = ufs_qcom_get_bus_vote(host, "MIN");\r\nhost->bus_vote.max_bw_vote = ufs_qcom_get_bus_vote(host, "MAX");\r\nhost->bus_vote.max_bus_bw.show = show_ufs_to_mem_max_bus_bw;\r\nhost->bus_vote.max_bus_bw.store = store_ufs_to_mem_max_bus_bw;\r\nsysfs_attr_init(&host->bus_vote.max_bus_bw.attr);\r\nhost->bus_vote.max_bus_bw.attr.name = "max_bus_bw";\r\nhost->bus_vote.max_bus_bw.attr.mode = S_IRUGO | S_IWUSR;\r\nerr = device_create_file(dev, &host->bus_vote.max_bus_bw);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_update_bus_bw_vote(struct ufs_qcom_host *host)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ufs_qcom_set_bus_vote(struct ufs_qcom_host *host, int vote)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ufs_qcom_bus_register(struct ufs_qcom_host *host)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ufs_qcom_dev_ref_clk_ctrl(struct ufs_qcom_host *host, bool enable)\r\n{\r\nif (host->dev_ref_clk_ctrl_mmio &&\r\n(enable ^ host->is_dev_ref_clk_enabled)) {\r\nu32 temp = readl_relaxed(host->dev_ref_clk_ctrl_mmio);\r\nif (enable)\r\ntemp |= host->dev_ref_clk_en_mask;\r\nelse\r\ntemp &= ~host->dev_ref_clk_en_mask;\r\nif (!enable)\r\nudelay(1);\r\nwritel_relaxed(temp, host->dev_ref_clk_ctrl_mmio);\r\nwmb();\r\nif (enable)\r\nudelay(1);\r\nhost->is_dev_ref_clk_enabled = enable;\r\n}\r\n}\r\nstatic int ufs_qcom_pwr_change_notify(struct ufs_hba *hba,\r\nenum ufs_notify_change_status status,\r\nstruct ufs_pa_layer_attr *dev_max_params,\r\nstruct ufs_pa_layer_attr *dev_req_params)\r\n{\r\nu32 val;\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nstruct phy *phy = host->generic_phy;\r\nstruct ufs_qcom_dev_params ufs_qcom_cap;\r\nint ret = 0;\r\nint res = 0;\r\nif (!dev_req_params) {\r\npr_err("%s: incoming dev_req_params is NULL\n", __func__);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (status) {\r\ncase PRE_CHANGE:\r\nufs_qcom_cap.tx_lanes = UFS_QCOM_LIMIT_NUM_LANES_TX;\r\nufs_qcom_cap.rx_lanes = UFS_QCOM_LIMIT_NUM_LANES_RX;\r\nufs_qcom_cap.hs_rx_gear = UFS_QCOM_LIMIT_HSGEAR_RX;\r\nufs_qcom_cap.hs_tx_gear = UFS_QCOM_LIMIT_HSGEAR_TX;\r\nufs_qcom_cap.pwm_rx_gear = UFS_QCOM_LIMIT_PWMGEAR_RX;\r\nufs_qcom_cap.pwm_tx_gear = UFS_QCOM_LIMIT_PWMGEAR_TX;\r\nufs_qcom_cap.rx_pwr_pwm = UFS_QCOM_LIMIT_RX_PWR_PWM;\r\nufs_qcom_cap.tx_pwr_pwm = UFS_QCOM_LIMIT_TX_PWR_PWM;\r\nufs_qcom_cap.rx_pwr_hs = UFS_QCOM_LIMIT_RX_PWR_HS;\r\nufs_qcom_cap.tx_pwr_hs = UFS_QCOM_LIMIT_TX_PWR_HS;\r\nufs_qcom_cap.hs_rate = UFS_QCOM_LIMIT_HS_RATE;\r\nufs_qcom_cap.desired_working_mode =\r\nUFS_QCOM_LIMIT_DESIRED_MODE;\r\nif (host->hw_ver.major == 0x1) {\r\nif (ufs_qcom_cap.hs_tx_gear > UFS_HS_G2)\r\nufs_qcom_cap.hs_tx_gear = UFS_HS_G2;\r\nif (ufs_qcom_cap.hs_rx_gear > UFS_HS_G2)\r\nufs_qcom_cap.hs_rx_gear = UFS_HS_G2;\r\n}\r\nret = ufs_qcom_get_pwr_dev_param(&ufs_qcom_cap,\r\ndev_max_params,\r\ndev_req_params);\r\nif (ret) {\r\npr_err("%s: failed to determine capabilities\n",\r\n__func__);\r\ngoto out;\r\n}\r\nif (!ufshcd_is_hs_mode(&hba->pwr_info) &&\r\nufshcd_is_hs_mode(dev_req_params))\r\nufs_qcom_dev_ref_clk_ctrl(host, true);\r\nbreak;\r\ncase POST_CHANGE:\r\nif (ufs_qcom_cfg_timers(hba, dev_req_params->gear_rx,\r\ndev_req_params->pwr_rx,\r\ndev_req_params->hs_rate, false)) {\r\ndev_err(hba->dev, "%s: ufs_qcom_cfg_timers() failed\n",\r\n__func__);\r\nret = -EINVAL;\r\n}\r\nval = ~(MAX_U32 << dev_req_params->lane_tx);\r\nres = ufs_qcom_phy_set_tx_lane_enable(phy, val);\r\nif (res) {\r\ndev_err(hba->dev, "%s: ufs_qcom_phy_set_tx_lane_enable() failed res = %d\n",\r\n__func__, res);\r\nret = res;\r\n}\r\nmemcpy(&host->dev_req_params,\r\ndev_req_params, sizeof(*dev_req_params));\r\nufs_qcom_update_bus_bw_vote(host);\r\nif (ufshcd_is_hs_mode(&hba->pwr_info) &&\r\n!ufshcd_is_hs_mode(dev_req_params))\r\nufs_qcom_dev_ref_clk_ctrl(host, false);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ufs_qcom_quirk_host_pa_saveconfigtime(struct ufs_hba *hba)\r\n{\r\nint err;\r\nu32 pa_vs_config_reg1;\r\nerr = ufshcd_dme_get(hba, UIC_ARG_MIB(PA_VS_CONFIG_REG1),\r\n&pa_vs_config_reg1);\r\nif (err)\r\ngoto out;\r\nerr = ufshcd_dme_set(hba, UIC_ARG_MIB(PA_VS_CONFIG_REG1),\r\n(pa_vs_config_reg1 | (1 << 12)));\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_apply_dev_quirks(struct ufs_hba *hba)\r\n{\r\nint err = 0;\r\nif (hba->dev_quirks & UFS_DEVICE_QUIRK_HOST_PA_SAVECONFIGTIME)\r\nerr = ufs_qcom_quirk_host_pa_saveconfigtime(hba);\r\nreturn err;\r\n}\r\nstatic u32 ufs_qcom_get_ufs_hci_version(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nif (host->hw_ver.major == 0x1)\r\nreturn UFSHCI_VERSION_11;\r\nelse\r\nreturn UFSHCI_VERSION_20;\r\n}\r\nstatic void ufs_qcom_advertise_quirks(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nif (host->hw_ver.major == 0x01) {\r\nhba->quirks |= UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS\r\n| UFSHCD_QUIRK_BROKEN_PA_RXHSUNTERMCAP\r\n| UFSHCD_QUIRK_DME_PEER_ACCESS_AUTO_MODE;\r\nif (host->hw_ver.minor == 0x0001 && host->hw_ver.step == 0x0001)\r\nhba->quirks |= UFSHCD_QUIRK_BROKEN_INTR_AGGR;\r\nhba->quirks |= UFSHCD_QUIRK_BROKEN_LCC;\r\n}\r\nif (host->hw_ver.major >= 0x2) {\r\nhba->quirks |= UFSHCD_QUIRK_BROKEN_UFS_HCI_VERSION;\r\nif (!ufs_qcom_cap_qunipro(host))\r\nhba->quirks |= (UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS\r\n| UFSHCD_QUIRK_DME_PEER_ACCESS_AUTO_MODE\r\n| UFSHCD_QUIRK_BROKEN_PA_RXHSUNTERMCAP);\r\n}\r\n}\r\nstatic void ufs_qcom_set_caps(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nhba->caps |= UFSHCD_CAP_CLK_GATING | UFSHCD_CAP_HIBERN8_WITH_CLK_GATING;\r\nhba->caps |= UFSHCD_CAP_CLK_SCALING;\r\nhba->caps |= UFSHCD_CAP_AUTO_BKOPS_SUSPEND;\r\nif (host->hw_ver.major >= 0x2) {\r\nhost->caps = UFS_QCOM_CAP_QUNIPRO |\r\nUFS_QCOM_CAP_RETAIN_SEC_CFG_AFTER_PWR_COLLAPSE;\r\n}\r\n}\r\nstatic int ufs_qcom_setup_clocks(struct ufs_hba *hba, bool on,\r\nenum ufs_notify_change_status status)\r\n{\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nint err;\r\nint vote = 0;\r\nif (!host)\r\nreturn 0;\r\nif (on && (status == POST_CHANGE)) {\r\nphy_power_on(host->generic_phy);\r\nif (ufshcd_is_hs_mode(&hba->pwr_info))\r\nufs_qcom_dev_ref_clk_ctrl(host, true);\r\nvote = host->bus_vote.saved_vote;\r\nif (vote == host->bus_vote.min_bw_vote)\r\nufs_qcom_update_bus_bw_vote(host);\r\n} else if (!on && (status == PRE_CHANGE)) {\r\nif (!ufs_qcom_is_link_active(hba)) {\r\nufs_qcom_dev_ref_clk_ctrl(host, false);\r\nphy_power_off(host->generic_phy);\r\n}\r\nvote = host->bus_vote.min_bw_vote;\r\n}\r\nerr = ufs_qcom_set_bus_vote(host, vote);\r\nif (err)\r\ndev_err(hba->dev, "%s: set bus vote failed %d\n",\r\n__func__, err);\r\nreturn err;\r\n}\r\nstatic int __init get_android_boot_dev(char *str)\r\n{\r\nstrlcpy(android_boot_dev, str, ANDROID_BOOT_DEV_MAX);\r\nreturn 1;\r\n}\r\nstatic int ufs_qcom_init(struct ufs_hba *hba)\r\n{\r\nint err;\r\nstruct device *dev = hba->dev;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ufs_qcom_host *host;\r\nstruct resource *res;\r\nif (strlen(android_boot_dev) && strcmp(android_boot_dev, dev_name(dev)))\r\nreturn -ENODEV;\r\nhost = devm_kzalloc(dev, sizeof(*host), GFP_KERNEL);\r\nif (!host) {\r\nerr = -ENOMEM;\r\ndev_err(dev, "%s: no memory for qcom ufs host\n", __func__);\r\ngoto out;\r\n}\r\nhost->hba = hba;\r\nufshcd_set_variant(hba, host);\r\nhost->generic_phy = devm_phy_get(dev, "ufsphy");\r\nif (host->generic_phy == ERR_PTR(-EPROBE_DEFER)) {\r\nerr = -EPROBE_DEFER;\r\ndev_warn(dev, "%s: required phy device. hasn't probed yet. err = %d\n",\r\n__func__, err);\r\ngoto out_variant_clear;\r\n} else if (IS_ERR(host->generic_phy)) {\r\nerr = PTR_ERR(host->generic_phy);\r\ndev_err(dev, "%s: PHY get failed %d\n", __func__, err);\r\ngoto out_variant_clear;\r\n}\r\nerr = ufs_qcom_bus_register(host);\r\nif (err)\r\ngoto out_variant_clear;\r\nufs_qcom_get_controller_revision(hba, &host->hw_ver.major,\r\n&host->hw_ver.minor, &host->hw_ver.step);\r\nif (host->hw_ver.major >= 0x02) {\r\nhost->dev_ref_clk_ctrl_mmio = hba->mmio_base + REG_UFS_CFG1;\r\nhost->dev_ref_clk_en_mask = BIT(26);\r\n} else {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (res) {\r\nhost->dev_ref_clk_ctrl_mmio =\r\ndevm_ioremap_resource(dev, res);\r\nif (IS_ERR(host->dev_ref_clk_ctrl_mmio)) {\r\ndev_warn(dev,\r\n"%s: could not map dev_ref_clk_ctrl_mmio, err %ld\n",\r\n__func__,\r\nPTR_ERR(host->dev_ref_clk_ctrl_mmio));\r\nhost->dev_ref_clk_ctrl_mmio = NULL;\r\n}\r\nhost->dev_ref_clk_en_mask = BIT(5);\r\n}\r\n}\r\nufs_qcom_phy_save_controller_version(host->generic_phy,\r\nhost->hw_ver.major, host->hw_ver.minor, host->hw_ver.step);\r\nphy_init(host->generic_phy);\r\nerr = phy_power_on(host->generic_phy);\r\nif (err)\r\ngoto out_unregister_bus;\r\nerr = ufs_qcom_init_lane_clks(host);\r\nif (err)\r\ngoto out_disable_phy;\r\nufs_qcom_set_caps(hba);\r\nufs_qcom_advertise_quirks(hba);\r\nufs_qcom_setup_clocks(hba, true, POST_CHANGE);\r\nif (hba->dev->id < MAX_UFS_QCOM_HOSTS)\r\nufs_qcom_hosts[hba->dev->id] = host;\r\nhost->dbg_print_en |= UFS_QCOM_DEFAULT_DBG_PRINT_EN;\r\nufs_qcom_get_default_testbus_cfg(host);\r\nerr = ufs_qcom_testbus_config(host);\r\nif (err) {\r\ndev_warn(dev, "%s: failed to configure the testbus %d\n",\r\n__func__, err);\r\nerr = 0;\r\n}\r\ngoto out;\r\nout_disable_phy:\r\nphy_power_off(host->generic_phy);\r\nout_unregister_bus:\r\nphy_exit(host->generic_phy);\r\nout_variant_clear:\r\nufshcd_set_variant(hba, NULL);\r\nout:\r\nreturn err;\r\n}\r\nstatic void ufs_qcom_exit(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nufs_qcom_disable_lane_clks(host);\r\nphy_power_off(host->generic_phy);\r\nphy_exit(host->generic_phy);\r\n}\r\nstatic int ufs_qcom_set_dme_vs_core_clk_ctrl_clear_div(struct ufs_hba *hba,\r\nu32 clk_cycles)\r\n{\r\nint err;\r\nu32 core_clk_ctrl_reg;\r\nif (clk_cycles > DME_VS_CORE_CLK_CTRL_MAX_CORE_CLK_1US_CYCLES_MASK)\r\nreturn -EINVAL;\r\nerr = ufshcd_dme_get(hba,\r\nUIC_ARG_MIB(DME_VS_CORE_CLK_CTRL),\r\n&core_clk_ctrl_reg);\r\nif (err)\r\ngoto out;\r\ncore_clk_ctrl_reg &= ~DME_VS_CORE_CLK_CTRL_MAX_CORE_CLK_1US_CYCLES_MASK;\r\ncore_clk_ctrl_reg |= clk_cycles;\r\ncore_clk_ctrl_reg &= ~DME_VS_CORE_CLK_CTRL_CORE_CLK_DIV_EN_BIT;\r\nerr = ufshcd_dme_set(hba,\r\nUIC_ARG_MIB(DME_VS_CORE_CLK_CTRL),\r\ncore_clk_ctrl_reg);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_clk_scale_up_pre_change(struct ufs_hba *hba)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ufs_qcom_clk_scale_up_post_change(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nif (!ufs_qcom_cap_qunipro(host))\r\nreturn 0;\r\nreturn ufs_qcom_set_dme_vs_core_clk_ctrl_clear_div(hba, 150);\r\n}\r\nstatic int ufs_qcom_clk_scale_down_pre_change(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nint err;\r\nu32 core_clk_ctrl_reg;\r\nif (!ufs_qcom_cap_qunipro(host))\r\nreturn 0;\r\nerr = ufshcd_dme_get(hba,\r\nUIC_ARG_MIB(DME_VS_CORE_CLK_CTRL),\r\n&core_clk_ctrl_reg);\r\nif (!err &&\r\n(core_clk_ctrl_reg & DME_VS_CORE_CLK_CTRL_CORE_CLK_DIV_EN_BIT)) {\r\ncore_clk_ctrl_reg &= ~DME_VS_CORE_CLK_CTRL_CORE_CLK_DIV_EN_BIT;\r\nerr = ufshcd_dme_set(hba,\r\nUIC_ARG_MIB(DME_VS_CORE_CLK_CTRL),\r\ncore_clk_ctrl_reg);\r\n}\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_clk_scale_down_post_change(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nif (!ufs_qcom_cap_qunipro(host))\r\nreturn 0;\r\nreturn ufs_qcom_set_dme_vs_core_clk_ctrl_clear_div(hba, 75);\r\n}\r\nstatic int ufs_qcom_clk_scale_notify(struct ufs_hba *hba,\r\nbool scale_up, enum ufs_notify_change_status status)\r\n{\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nstruct ufs_pa_layer_attr *dev_req_params = &host->dev_req_params;\r\nint err = 0;\r\nif (status == PRE_CHANGE) {\r\nif (scale_up)\r\nerr = ufs_qcom_clk_scale_up_pre_change(hba);\r\nelse\r\nerr = ufs_qcom_clk_scale_down_pre_change(hba);\r\n} else {\r\nif (scale_up)\r\nerr = ufs_qcom_clk_scale_up_post_change(hba);\r\nelse\r\nerr = ufs_qcom_clk_scale_down_post_change(hba);\r\nif (err || !dev_req_params)\r\ngoto out;\r\nufs_qcom_cfg_timers(hba,\r\ndev_req_params->gear_rx,\r\ndev_req_params->pwr_rx,\r\ndev_req_params->hs_rate,\r\nfalse);\r\nufs_qcom_update_bus_bw_vote(host);\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic void ufs_qcom_print_hw_debug_reg_all(struct ufs_hba *hba,\r\nvoid *priv, void (*print_fn)(struct ufs_hba *hba,\r\nint offset, int num_regs, char *str, void *priv))\r\n{\r\nu32 reg;\r\nstruct ufs_qcom_host *host;\r\nif (unlikely(!hba)) {\r\npr_err("%s: hba is NULL\n", __func__);\r\nreturn;\r\n}\r\nif (unlikely(!print_fn)) {\r\ndev_err(hba->dev, "%s: print_fn is NULL\n", __func__);\r\nreturn;\r\n}\r\nhost = ufshcd_get_variant(hba);\r\nif (!(host->dbg_print_en & UFS_QCOM_DBG_PRINT_REGS_EN))\r\nreturn;\r\nreg = ufs_qcom_get_debug_reg_offset(host, UFS_UFS_DBG_RD_REG_OCSC);\r\nprint_fn(hba, reg, 44, "UFS_UFS_DBG_RD_REG_OCSC ", priv);\r\nreg = ufshcd_readl(hba, REG_UFS_CFG1);\r\nreg |= UFS_BIT(17);\r\nufshcd_writel(hba, reg, REG_UFS_CFG1);\r\nreg = ufs_qcom_get_debug_reg_offset(host, UFS_UFS_DBG_RD_EDTL_RAM);\r\nprint_fn(hba, reg, 32, "UFS_UFS_DBG_RD_EDTL_RAM ", priv);\r\nreg = ufs_qcom_get_debug_reg_offset(host, UFS_UFS_DBG_RD_DESC_RAM);\r\nprint_fn(hba, reg, 128, "UFS_UFS_DBG_RD_DESC_RAM ", priv);\r\nreg = ufs_qcom_get_debug_reg_offset(host, UFS_UFS_DBG_RD_PRDT_RAM);\r\nprint_fn(hba, reg, 64, "UFS_UFS_DBG_RD_PRDT_RAM ", priv);\r\nufshcd_rmwl(hba, UFS_BIT(17), 0, REG_UFS_CFG1);\r\nreg = ufs_qcom_get_debug_reg_offset(host, UFS_DBG_RD_REG_UAWM);\r\nprint_fn(hba, reg, 4, "UFS_DBG_RD_REG_UAWM ", priv);\r\nreg = ufs_qcom_get_debug_reg_offset(host, UFS_DBG_RD_REG_UARM);\r\nprint_fn(hba, reg, 4, "UFS_DBG_RD_REG_UARM ", priv);\r\nreg = ufs_qcom_get_debug_reg_offset(host, UFS_DBG_RD_REG_TXUC);\r\nprint_fn(hba, reg, 48, "UFS_DBG_RD_REG_TXUC ", priv);\r\nreg = ufs_qcom_get_debug_reg_offset(host, UFS_DBG_RD_REG_RXUC);\r\nprint_fn(hba, reg, 27, "UFS_DBG_RD_REG_RXUC ", priv);\r\nreg = ufs_qcom_get_debug_reg_offset(host, UFS_DBG_RD_REG_DFC);\r\nprint_fn(hba, reg, 19, "UFS_DBG_RD_REG_DFC ", priv);\r\nreg = ufs_qcom_get_debug_reg_offset(host, UFS_DBG_RD_REG_TRLUT);\r\nprint_fn(hba, reg, 34, "UFS_DBG_RD_REG_TRLUT ", priv);\r\nreg = ufs_qcom_get_debug_reg_offset(host, UFS_DBG_RD_REG_TMRLUT);\r\nprint_fn(hba, reg, 9, "UFS_DBG_RD_REG_TMRLUT ", priv);\r\n}\r\nstatic void ufs_qcom_enable_test_bus(struct ufs_qcom_host *host)\r\n{\r\nif (host->dbg_print_en & UFS_QCOM_DBG_PRINT_TEST_BUS_EN) {\r\nufshcd_rmwl(host->hba, UFS_REG_TEST_BUS_EN,\r\nUFS_REG_TEST_BUS_EN, REG_UFS_CFG1);\r\nufshcd_rmwl(host->hba, TEST_BUS_EN, TEST_BUS_EN, REG_UFS_CFG1);\r\n} else {\r\nufshcd_rmwl(host->hba, UFS_REG_TEST_BUS_EN, 0, REG_UFS_CFG1);\r\nufshcd_rmwl(host->hba, TEST_BUS_EN, 0, REG_UFS_CFG1);\r\n}\r\n}\r\nstatic void ufs_qcom_get_default_testbus_cfg(struct ufs_qcom_host *host)\r\n{\r\nhost->testbus.select_major = TSTBUS_UNIPRO;\r\nhost->testbus.select_minor = 37;\r\n}\r\nstatic bool ufs_qcom_testbus_cfg_is_ok(struct ufs_qcom_host *host)\r\n{\r\nif (host->testbus.select_major >= TSTBUS_MAX) {\r\ndev_err(host->hba->dev,\r\n"%s: UFS_CFG1[TEST_BUS_SEL} may not equal 0x%05X\n",\r\n__func__, host->testbus.select_major);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nint ufs_qcom_testbus_config(struct ufs_qcom_host *host)\r\n{\r\nint reg;\r\nint offset;\r\nu32 mask = TEST_BUS_SUB_SEL_MASK;\r\nif (!host)\r\nreturn -EINVAL;\r\nif (!ufs_qcom_testbus_cfg_is_ok(host))\r\nreturn -EPERM;\r\nswitch (host->testbus.select_major) {\r\ncase TSTBUS_UAWM:\r\nreg = UFS_TEST_BUS_CTRL_0;\r\noffset = 24;\r\nbreak;\r\ncase TSTBUS_UARM:\r\nreg = UFS_TEST_BUS_CTRL_0;\r\noffset = 16;\r\nbreak;\r\ncase TSTBUS_TXUC:\r\nreg = UFS_TEST_BUS_CTRL_0;\r\noffset = 8;\r\nbreak;\r\ncase TSTBUS_RXUC:\r\nreg = UFS_TEST_BUS_CTRL_0;\r\noffset = 0;\r\nbreak;\r\ncase TSTBUS_DFC:\r\nreg = UFS_TEST_BUS_CTRL_1;\r\noffset = 24;\r\nbreak;\r\ncase TSTBUS_TRLUT:\r\nreg = UFS_TEST_BUS_CTRL_1;\r\noffset = 16;\r\nbreak;\r\ncase TSTBUS_TMRLUT:\r\nreg = UFS_TEST_BUS_CTRL_1;\r\noffset = 8;\r\nbreak;\r\ncase TSTBUS_OCSC:\r\nreg = UFS_TEST_BUS_CTRL_1;\r\noffset = 0;\r\nbreak;\r\ncase TSTBUS_WRAPPER:\r\nreg = UFS_TEST_BUS_CTRL_2;\r\noffset = 16;\r\nbreak;\r\ncase TSTBUS_COMBINED:\r\nreg = UFS_TEST_BUS_CTRL_2;\r\noffset = 8;\r\nbreak;\r\ncase TSTBUS_UTP_HCI:\r\nreg = UFS_TEST_BUS_CTRL_2;\r\noffset = 0;\r\nbreak;\r\ncase TSTBUS_UNIPRO:\r\nreg = UFS_UNIPRO_CFG;\r\noffset = 20;\r\nmask = 0xFFF;\r\nbreak;\r\n}\r\nmask <<= offset;\r\npm_runtime_get_sync(host->hba->dev);\r\nufshcd_hold(host->hba, false);\r\nufshcd_rmwl(host->hba, TEST_BUS_SEL,\r\n(u32)host->testbus.select_major << 19,\r\nREG_UFS_CFG1);\r\nufshcd_rmwl(host->hba, mask,\r\n(u32)host->testbus.select_minor << offset,\r\nreg);\r\nufs_qcom_enable_test_bus(host);\r\nmb();\r\nufshcd_release(host->hba);\r\npm_runtime_put_sync(host->hba->dev);\r\nreturn 0;\r\n}\r\nstatic void ufs_qcom_testbus_read(struct ufs_hba *hba)\r\n{\r\nufs_qcom_dump_regs(hba, UFS_TEST_BUS, 1, "UFS_TEST_BUS ");\r\n}\r\nstatic void ufs_qcom_print_unipro_testbus(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = ufshcd_get_variant(hba);\r\nu32 *testbus = NULL;\r\nint i, nminor = 256, testbus_len = nminor * sizeof(u32);\r\ntestbus = kmalloc(testbus_len, GFP_KERNEL);\r\nif (!testbus)\r\nreturn;\r\nhost->testbus.select_major = TSTBUS_UNIPRO;\r\nfor (i = 0; i < nminor; i++) {\r\nhost->testbus.select_minor = i;\r\nufs_qcom_testbus_config(host);\r\ntestbus[i] = ufshcd_readl(hba, UFS_TEST_BUS);\r\n}\r\nprint_hex_dump(KERN_ERR, "UNIPRO_TEST_BUS ", DUMP_PREFIX_OFFSET,\r\n16, 4, testbus, testbus_len, false);\r\nkfree(testbus);\r\n}\r\nstatic void ufs_qcom_dump_dbg_regs(struct ufs_hba *hba)\r\n{\r\nufs_qcom_dump_regs(hba, REG_UFS_SYS1CLK_1US, 16,\r\n"HCI Vendor Specific Registers ");\r\nufs_qcom_print_hw_debug_reg_all(hba, NULL, ufs_qcom_dump_regs_wrapper);\r\nusleep_range(1000, 1100);\r\nufs_qcom_testbus_read(hba);\r\nusleep_range(1000, 1100);\r\nufs_qcom_print_unipro_testbus(hba);\r\nusleep_range(1000, 1100);\r\n}\r\nstatic int ufs_qcom_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nstruct device *dev = &pdev->dev;\r\nerr = ufshcd_pltfrm_init(pdev, &ufs_hba_qcom_vops);\r\nif (err)\r\ndev_err(dev, "ufshcd_pltfrm_init() failed %d\n", err);\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_remove(struct platform_device *pdev)\r\n{\r\nstruct ufs_hba *hba = platform_get_drvdata(pdev);\r\npm_runtime_get_sync(&(pdev)->dev);\r\nufshcd_remove(hba);\r\nreturn 0;\r\n}
