static void stmmac_ethtool_getdrvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nif (priv->plat->has_gmac || priv->plat->has_gmac4)\r\nstrlcpy(info->driver, GMAC_ETHTOOL_NAME, sizeof(info->driver));\r\nelse\r\nstrlcpy(info->driver, MAC100_ETHTOOL_NAME,\r\nsizeof(info->driver));\r\nstrlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\r\n}\r\nstatic int stmmac_ethtool_get_link_ksettings(struct net_device *dev,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nstruct phy_device *phy = dev->phydev;\r\nif (priv->hw->pcs & STMMAC_PCS_RGMII ||\r\npriv->hw->pcs & STMMAC_PCS_SGMII) {\r\nstruct rgmii_adv adv;\r\nu32 supported, advertising, lp_advertising;\r\nif (!priv->xstats.pcs_link) {\r\ncmd->base.speed = SPEED_UNKNOWN;\r\ncmd->base.duplex = DUPLEX_UNKNOWN;\r\nreturn 0;\r\n}\r\ncmd->base.duplex = priv->xstats.pcs_duplex;\r\ncmd->base.speed = priv->xstats.pcs_speed;\r\nif (!priv->hw->mac->pcs_get_adv_lp)\r\nreturn -EOPNOTSUPP;\r\npriv->hw->mac->pcs_get_adv_lp(priv->ioaddr, &adv);\r\nethtool_convert_link_mode_to_legacy_u32(\r\n&supported, cmd->link_modes.supported);\r\nethtool_convert_link_mode_to_legacy_u32(\r\n&advertising, cmd->link_modes.advertising);\r\nethtool_convert_link_mode_to_legacy_u32(\r\n&lp_advertising, cmd->link_modes.lp_advertising);\r\nif (adv.pause & STMMAC_PCS_PAUSE)\r\nadvertising |= ADVERTISED_Pause;\r\nif (adv.pause & STMMAC_PCS_ASYM_PAUSE)\r\nadvertising |= ADVERTISED_Asym_Pause;\r\nif (adv.lp_pause & STMMAC_PCS_PAUSE)\r\nlp_advertising |= ADVERTISED_Pause;\r\nif (adv.lp_pause & STMMAC_PCS_ASYM_PAUSE)\r\nlp_advertising |= ADVERTISED_Asym_Pause;\r\ncmd->base.autoneg = ADVERTISED_Autoneg;\r\nsupported |= SUPPORTED_Autoneg;\r\nadvertising |= ADVERTISED_Autoneg;\r\nlp_advertising |= ADVERTISED_Autoneg;\r\nif (adv.duplex) {\r\nsupported |= (SUPPORTED_1000baseT_Full |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_10baseT_Full);\r\nadvertising |= (ADVERTISED_1000baseT_Full |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_10baseT_Full);\r\n} else {\r\nsupported |= (SUPPORTED_1000baseT_Half |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_10baseT_Half);\r\nadvertising |= (ADVERTISED_1000baseT_Half |\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_10baseT_Half);\r\n}\r\nif (adv.lp_duplex)\r\nlp_advertising |= (ADVERTISED_1000baseT_Full |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_10baseT_Full);\r\nelse\r\nlp_advertising |= (ADVERTISED_1000baseT_Half |\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_10baseT_Half);\r\ncmd->base.port = PORT_OTHER;\r\nethtool_convert_legacy_u32_to_link_mode(\r\ncmd->link_modes.supported, supported);\r\nethtool_convert_legacy_u32_to_link_mode(\r\ncmd->link_modes.advertising, advertising);\r\nethtool_convert_legacy_u32_to_link_mode(\r\ncmd->link_modes.lp_advertising, lp_advertising);\r\nreturn 0;\r\n}\r\nif (phy == NULL) {\r\npr_err("%s: %s: PHY is not registered\n",\r\n__func__, dev->name);\r\nreturn -ENODEV;\r\n}\r\nif (!netif_running(dev)) {\r\npr_err("%s: interface is disabled: we cannot track "\r\n"link speed / duplex setting\n", dev->name);\r\nreturn -EBUSY;\r\n}\r\nphy_ethtool_ksettings_get(phy, cmd);\r\nreturn 0;\r\n}\r\nstatic int\r\nstmmac_ethtool_set_link_ksettings(struct net_device *dev,\r\nconst struct ethtool_link_ksettings *cmd)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nstruct phy_device *phy = dev->phydev;\r\nint rc;\r\nif (priv->hw->pcs & STMMAC_PCS_RGMII ||\r\npriv->hw->pcs & STMMAC_PCS_SGMII) {\r\nu32 mask = ADVERTISED_Autoneg | ADVERTISED_Pause;\r\nif (cmd->base.autoneg != AUTONEG_ENABLE)\r\nreturn -EINVAL;\r\nmask &= (ADVERTISED_1000baseT_Half |\r\nADVERTISED_1000baseT_Full |\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_10baseT_Half |\r\nADVERTISED_10baseT_Full);\r\nspin_lock(&priv->lock);\r\nif (priv->hw->mac->pcs_ctrl_ane)\r\npriv->hw->mac->pcs_ctrl_ane(priv->ioaddr, 1,\r\npriv->hw->ps, 0);\r\nspin_unlock(&priv->lock);\r\nreturn 0;\r\n}\r\nrc = phy_ethtool_ksettings_set(phy, cmd);\r\nreturn rc;\r\n}\r\nstatic u32 stmmac_ethtool_getmsglevel(struct net_device *dev)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nreturn priv->msg_enable;\r\n}\r\nstatic void stmmac_ethtool_setmsglevel(struct net_device *dev, u32 level)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\npriv->msg_enable = level;\r\n}\r\nstatic int stmmac_check_if_running(struct net_device *dev)\r\n{\r\nif (!netif_running(dev))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int stmmac_ethtool_get_regs_len(struct net_device *dev)\r\n{\r\nreturn REG_SPACE_SIZE;\r\n}\r\nstatic void stmmac_ethtool_gregs(struct net_device *dev,\r\nstruct ethtool_regs *regs, void *space)\r\n{\r\nu32 *reg_space = (u32 *) space;\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nmemset(reg_space, 0x0, REG_SPACE_SIZE);\r\npriv->hw->mac->dump_regs(priv->hw, reg_space);\r\npriv->hw->dma->dump_regs(priv->ioaddr, reg_space);\r\nmemcpy(&reg_space[ETHTOOL_DMA_OFFSET], &reg_space[DMA_BUS_MODE / 4],\r\nNUM_DWMAC1000_DMA_REGS * 4);\r\n}\r\nstatic void\r\nstmmac_get_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(netdev);\r\npause->rx_pause = 0;\r\npause->tx_pause = 0;\r\nif (priv->hw->pcs && priv->hw->mac->pcs_get_adv_lp) {\r\nstruct rgmii_adv adv_lp;\r\npause->autoneg = 1;\r\npriv->hw->mac->pcs_get_adv_lp(priv->ioaddr, &adv_lp);\r\nif (!adv_lp.pause)\r\nreturn;\r\n} else {\r\nif (!(netdev->phydev->supported & SUPPORTED_Pause) ||\r\n!(netdev->phydev->supported & SUPPORTED_Asym_Pause))\r\nreturn;\r\n}\r\npause->autoneg = netdev->phydev->autoneg;\r\nif (priv->flow_ctrl & FLOW_RX)\r\npause->rx_pause = 1;\r\nif (priv->flow_ctrl & FLOW_TX)\r\npause->tx_pause = 1;\r\n}\r\nstatic int\r\nstmmac_set_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(netdev);\r\nu32 tx_cnt = priv->plat->tx_queues_to_use;\r\nstruct phy_device *phy = netdev->phydev;\r\nint new_pause = FLOW_OFF;\r\nif (priv->hw->pcs && priv->hw->mac->pcs_get_adv_lp) {\r\nstruct rgmii_adv adv_lp;\r\npause->autoneg = 1;\r\npriv->hw->mac->pcs_get_adv_lp(priv->ioaddr, &adv_lp);\r\nif (!adv_lp.pause)\r\nreturn -EOPNOTSUPP;\r\n} else {\r\nif (!(phy->supported & SUPPORTED_Pause) ||\r\n!(phy->supported & SUPPORTED_Asym_Pause))\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (pause->rx_pause)\r\nnew_pause |= FLOW_RX;\r\nif (pause->tx_pause)\r\nnew_pause |= FLOW_TX;\r\npriv->flow_ctrl = new_pause;\r\nphy->autoneg = pause->autoneg;\r\nif (phy->autoneg) {\r\nif (netif_running(netdev))\r\nreturn phy_start_aneg(phy);\r\n}\r\npriv->hw->mac->flow_ctrl(priv->hw, phy->duplex, priv->flow_ctrl,\r\npriv->pause, tx_cnt);\r\nreturn 0;\r\n}\r\nstatic void stmmac_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *dummy, u64 *data)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nu32 rx_queues_count = priv->plat->rx_queues_to_use;\r\nu32 tx_queues_count = priv->plat->tx_queues_to_use;\r\nint i, j = 0;\r\nif (priv->hw->dma->dma_diagnostic_fr)\r\npriv->hw->dma->dma_diagnostic_fr(&dev->stats,\r\n(void *) &priv->xstats,\r\npriv->ioaddr);\r\nelse {\r\nif (priv->dma_cap.rmon) {\r\ndwmac_mmc_read(priv->mmcaddr, &priv->mmc);\r\nfor (i = 0; i < STMMAC_MMC_STATS_LEN; i++) {\r\nchar *p;\r\np = (char *)priv + stmmac_mmc[i].stat_offset;\r\ndata[j++] = (stmmac_mmc[i].sizeof_stat ==\r\nsizeof(u64)) ? (*(u64 *)p) :\r\n(*(u32 *)p);\r\n}\r\n}\r\nif (priv->eee_enabled) {\r\nint val = phy_get_eee_err(dev->phydev);\r\nif (val)\r\npriv->xstats.phy_eee_wakeup_error_n = val;\r\n}\r\nif ((priv->hw->mac->debug) &&\r\n(priv->synopsys_id >= DWMAC_CORE_3_50))\r\npriv->hw->mac->debug(priv->ioaddr,\r\n(void *)&priv->xstats,\r\nrx_queues_count, tx_queues_count);\r\n}\r\nfor (i = 0; i < STMMAC_STATS_LEN; i++) {\r\nchar *p = (char *)priv + stmmac_gstrings_stats[i].stat_offset;\r\ndata[j++] = (stmmac_gstrings_stats[i].sizeof_stat ==\r\nsizeof(u64)) ? (*(u64 *)p) : (*(u32 *)p);\r\n}\r\n}\r\nstatic int stmmac_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(netdev);\r\nint len;\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nlen = STMMAC_STATS_LEN;\r\nif (priv->dma_cap.rmon)\r\nlen += STMMAC_MMC_STATS_LEN;\r\nreturn len;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void stmmac_get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nint i;\r\nu8 *p = data;\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nif (priv->dma_cap.rmon)\r\nfor (i = 0; i < STMMAC_MMC_STATS_LEN; i++) {\r\nmemcpy(p, stmmac_mmc[i].stat_string,\r\nETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\nfor (i = 0; i < STMMAC_STATS_LEN; i++) {\r\nmemcpy(p, stmmac_gstrings_stats[i].stat_string,\r\nETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\nstatic void stmmac_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nspin_lock_irq(&priv->lock);\r\nif (device_can_wakeup(priv->device)) {\r\nwol->supported = WAKE_MAGIC | WAKE_UCAST;\r\nwol->wolopts = priv->wolopts;\r\n}\r\nspin_unlock_irq(&priv->lock);\r\n}\r\nstatic int stmmac_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nu32 support = WAKE_MAGIC | WAKE_UCAST;\r\nif ((priv->hw_cap_support) && (!priv->dma_cap.pmt_magic_frame))\r\nwol->wolopts &= ~WAKE_MAGIC;\r\nif (!device_can_wakeup(priv->device))\r\nreturn -EINVAL;\r\nif (wol->wolopts & ~support)\r\nreturn -EINVAL;\r\nif (wol->wolopts) {\r\npr_info("stmmac: wakeup enable\n");\r\ndevice_set_wakeup_enable(priv->device, 1);\r\nenable_irq_wake(priv->wol_irq);\r\n} else {\r\ndevice_set_wakeup_enable(priv->device, 0);\r\ndisable_irq_wake(priv->wol_irq);\r\n}\r\nspin_lock_irq(&priv->lock);\r\npriv->wolopts = wol->wolopts;\r\nspin_unlock_irq(&priv->lock);\r\nreturn 0;\r\n}\r\nstatic int stmmac_ethtool_op_get_eee(struct net_device *dev,\r\nstruct ethtool_eee *edata)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nif (!priv->dma_cap.eee)\r\nreturn -EOPNOTSUPP;\r\nedata->eee_enabled = priv->eee_enabled;\r\nedata->eee_active = priv->eee_active;\r\nedata->tx_lpi_timer = priv->tx_lpi_timer;\r\nreturn phy_ethtool_get_eee(dev->phydev, edata);\r\n}\r\nstatic int stmmac_ethtool_op_set_eee(struct net_device *dev,\r\nstruct ethtool_eee *edata)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\npriv->eee_enabled = edata->eee_enabled;\r\nif (!priv->eee_enabled)\r\nstmmac_disable_eee_mode(priv);\r\nelse {\r\npriv->eee_enabled = stmmac_eee_init(priv);\r\nif (!priv->eee_enabled)\r\nreturn -EOPNOTSUPP;\r\npriv->tx_lpi_timer = edata->tx_lpi_timer;\r\n}\r\nreturn phy_ethtool_set_eee(dev->phydev, edata);\r\n}\r\nstatic u32 stmmac_usec2riwt(u32 usec, struct stmmac_priv *priv)\r\n{\r\nunsigned long clk = clk_get_rate(priv->plat->stmmac_clk);\r\nif (!clk)\r\nreturn 0;\r\nreturn (usec * (clk / 1000000)) / 256;\r\n}\r\nstatic u32 stmmac_riwt2usec(u32 riwt, struct stmmac_priv *priv)\r\n{\r\nunsigned long clk = clk_get_rate(priv->plat->stmmac_clk);\r\nif (!clk)\r\nreturn 0;\r\nreturn (riwt * 256) / (clk / 1000000);\r\n}\r\nstatic int stmmac_get_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nec->tx_coalesce_usecs = priv->tx_coal_timer;\r\nec->tx_max_coalesced_frames = priv->tx_coal_frames;\r\nif (priv->use_riwt)\r\nec->rx_coalesce_usecs = stmmac_riwt2usec(priv->rx_riwt, priv);\r\nreturn 0;\r\n}\r\nstatic int stmmac_set_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nu32 rx_cnt = priv->plat->rx_queues_to_use;\r\nunsigned int rx_riwt;\r\nif ((ec->rx_max_coalesced_frames) || (ec->rx_coalesce_usecs_irq) ||\r\n(ec->rx_max_coalesced_frames_irq) || (ec->tx_coalesce_usecs_irq) ||\r\n(ec->use_adaptive_rx_coalesce) || (ec->use_adaptive_tx_coalesce) ||\r\n(ec->pkt_rate_low) || (ec->rx_coalesce_usecs_low) ||\r\n(ec->rx_max_coalesced_frames_low) || (ec->tx_coalesce_usecs_high) ||\r\n(ec->tx_max_coalesced_frames_low) || (ec->pkt_rate_high) ||\r\n(ec->tx_coalesce_usecs_low) || (ec->rx_coalesce_usecs_high) ||\r\n(ec->rx_max_coalesced_frames_high) ||\r\n(ec->tx_max_coalesced_frames_irq) ||\r\n(ec->stats_block_coalesce_usecs) ||\r\n(ec->tx_max_coalesced_frames_high) || (ec->rate_sample_interval))\r\nreturn -EOPNOTSUPP;\r\nif (ec->rx_coalesce_usecs == 0)\r\nreturn -EINVAL;\r\nif ((ec->tx_coalesce_usecs == 0) &&\r\n(ec->tx_max_coalesced_frames == 0))\r\nreturn -EINVAL;\r\nif ((ec->tx_coalesce_usecs > STMMAC_MAX_COAL_TX_TICK) ||\r\n(ec->tx_max_coalesced_frames > STMMAC_TX_MAX_FRAMES))\r\nreturn -EINVAL;\r\nrx_riwt = stmmac_usec2riwt(ec->rx_coalesce_usecs, priv);\r\nif ((rx_riwt > MAX_DMA_RIWT) || (rx_riwt < MIN_DMA_RIWT))\r\nreturn -EINVAL;\r\nelse if (!priv->use_riwt)\r\nreturn -EOPNOTSUPP;\r\npriv->tx_coal_frames = ec->tx_max_coalesced_frames;\r\npriv->tx_coal_timer = ec->tx_coalesce_usecs;\r\npriv->rx_riwt = rx_riwt;\r\npriv->hw->dma->rx_watchdog(priv->ioaddr, priv->rx_riwt, rx_cnt);\r\nreturn 0;\r\n}\r\nstatic int stmmac_get_ts_info(struct net_device *dev,\r\nstruct ethtool_ts_info *info)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nif ((priv->dma_cap.time_stamp || priv->dma_cap.atime_stamp)) {\r\ninfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\r\nSOF_TIMESTAMPING_TX_HARDWARE |\r\nSOF_TIMESTAMPING_RX_SOFTWARE |\r\nSOF_TIMESTAMPING_RX_HARDWARE |\r\nSOF_TIMESTAMPING_SOFTWARE |\r\nSOF_TIMESTAMPING_RAW_HARDWARE;\r\nif (priv->ptp_clock)\r\ninfo->phc_index = ptp_clock_index(priv->ptp_clock);\r\ninfo->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);\r\ninfo->rx_filters = ((1 << HWTSTAMP_FILTER_NONE) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_ALL));\r\nreturn 0;\r\n} else\r\nreturn ethtool_op_get_ts_info(dev, info);\r\n}\r\nstatic int stmmac_get_tunable(struct net_device *dev,\r\nconst struct ethtool_tunable *tuna, void *data)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nint ret = 0;\r\nswitch (tuna->id) {\r\ncase ETHTOOL_RX_COPYBREAK:\r\n*(u32 *)data = priv->rx_copybreak;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int stmmac_set_tunable(struct net_device *dev,\r\nconst struct ethtool_tunable *tuna,\r\nconst void *data)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nint ret = 0;\r\nswitch (tuna->id) {\r\ncase ETHTOOL_RX_COPYBREAK:\r\npriv->rx_copybreak = *(u32 *)data;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid stmmac_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nnetdev->ethtool_ops = &stmmac_ethtool_ops;\r\n}
