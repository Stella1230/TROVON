static inline u32 i2c_in_csr(u32 bus_num)\r\n{\r\nreturn bus_num ? ASIC_QSFP2_IN : ASIC_QSFP1_IN;\r\n}\r\nstatic inline u32 i2c_oe_csr(u32 bus_num)\r\n{\r\nreturn bus_num ? ASIC_QSFP2_OE : ASIC_QSFP1_OE;\r\n}\r\nstatic void hfi1_setsda(void *data, int state)\r\n{\r\nstruct hfi1_i2c_bus *bus = (struct hfi1_i2c_bus *)data;\r\nstruct hfi1_devdata *dd = bus->controlling_dd;\r\nu64 reg;\r\nu32 target_oe;\r\ntarget_oe = i2c_oe_csr(bus->num);\r\nreg = read_csr(dd, target_oe);\r\nif (state)\r\nreg &= ~QSFP_HFI0_I2CDAT;\r\nelse\r\nreg |= QSFP_HFI0_I2CDAT;\r\nwrite_csr(dd, target_oe, reg);\r\n(void)read_csr(dd, target_oe);\r\n}\r\nstatic void hfi1_setscl(void *data, int state)\r\n{\r\nstruct hfi1_i2c_bus *bus = (struct hfi1_i2c_bus *)data;\r\nstruct hfi1_devdata *dd = bus->controlling_dd;\r\nu64 reg;\r\nu32 target_oe;\r\ntarget_oe = i2c_oe_csr(bus->num);\r\nreg = read_csr(dd, target_oe);\r\nif (state)\r\nreg &= ~QSFP_HFI0_I2CCLK;\r\nelse\r\nreg |= QSFP_HFI0_I2CCLK;\r\nwrite_csr(dd, target_oe, reg);\r\n(void)read_csr(dd, target_oe);\r\n}\r\nstatic int hfi1_getsda(void *data)\r\n{\r\nstruct hfi1_i2c_bus *bus = (struct hfi1_i2c_bus *)data;\r\nu64 reg;\r\nu32 target_in;\r\nhfi1_setsda(data, 1);\r\nudelay(2);\r\ntarget_in = i2c_in_csr(bus->num);\r\nreg = read_csr(bus->controlling_dd, target_in);\r\nreturn !!(reg & QSFP_HFI0_I2CDAT);\r\n}\r\nstatic int hfi1_getscl(void *data)\r\n{\r\nstruct hfi1_i2c_bus *bus = (struct hfi1_i2c_bus *)data;\r\nu64 reg;\r\nu32 target_in;\r\nhfi1_setscl(data, 1);\r\nudelay(2);\r\ntarget_in = i2c_in_csr(bus->num);\r\nreg = read_csr(bus->controlling_dd, target_in);\r\nreturn !!(reg & QSFP_HFI0_I2CCLK);\r\n}\r\nstatic struct hfi1_i2c_bus *init_i2c_bus(struct hfi1_devdata *dd,\r\nstruct hfi1_asic_data *ad, int num)\r\n{\r\nstruct hfi1_i2c_bus *bus;\r\nint ret;\r\nbus = kzalloc(sizeof(*bus), GFP_KERNEL);\r\nif (!bus)\r\nreturn NULL;\r\nbus->controlling_dd = dd;\r\nbus->num = num;\r\nbus->algo.setsda = hfi1_setsda;\r\nbus->algo.setscl = hfi1_setscl;\r\nbus->algo.getsda = hfi1_getsda;\r\nbus->algo.getscl = hfi1_getscl;\r\nbus->algo.udelay = 5;\r\nbus->algo.timeout = usecs_to_jiffies(100000);\r\nbus->algo.data = bus;\r\nbus->adapter.owner = THIS_MODULE;\r\nbus->adapter.algo_data = &bus->algo;\r\nbus->adapter.dev.parent = &dd->pcidev->dev;\r\nsnprintf(bus->adapter.name, sizeof(bus->adapter.name),\r\n"hfi1_i2c%d", num);\r\nret = i2c_bit_add_bus(&bus->adapter);\r\nif (ret) {\r\ndd_dev_info(dd, "%s: unable to add i2c bus %d, err %d\n",\r\n__func__, num, ret);\r\nkfree(bus);\r\nreturn NULL;\r\n}\r\nreturn bus;\r\n}\r\nint set_up_i2c(struct hfi1_devdata *dd, struct hfi1_asic_data *ad)\r\n{\r\nad->i2c_bus0 = init_i2c_bus(dd, ad, 0);\r\nad->i2c_bus1 = init_i2c_bus(dd, ad, 1);\r\nif (!ad->i2c_bus0 || !ad->i2c_bus1)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void clean_i2c_bus(struct hfi1_i2c_bus *bus)\r\n{\r\nif (bus) {\r\ni2c_del_adapter(&bus->adapter);\r\nkfree(bus);\r\n}\r\n}\r\nvoid clean_up_i2c(struct hfi1_devdata *dd, struct hfi1_asic_data *ad)\r\n{\r\nclean_i2c_bus(ad->i2c_bus0);\r\nad->i2c_bus0 = NULL;\r\nclean_i2c_bus(ad->i2c_bus1);\r\nad->i2c_bus1 = NULL;\r\n}\r\nstatic int i2c_bus_write(struct hfi1_devdata *dd, struct hfi1_i2c_bus *i2c,\r\nu8 slave_addr, int offset, int offset_size,\r\nu8 *data, u16 len)\r\n{\r\nint ret;\r\nint num_msgs;\r\nu8 offset_bytes[2];\r\nstruct i2c_msg msgs[2];\r\nswitch (offset_size) {\r\ncase 0:\r\nnum_msgs = 1;\r\nmsgs[0].addr = slave_addr;\r\nmsgs[0].flags = 0;\r\nmsgs[0].len = len;\r\nmsgs[0].buf = data;\r\nbreak;\r\ncase 2:\r\noffset_bytes[1] = (offset >> 8) & 0xff;\r\ncase 1:\r\nnum_msgs = 2;\r\noffset_bytes[0] = offset & 0xff;\r\nmsgs[0].addr = slave_addr;\r\nmsgs[0].flags = 0;\r\nmsgs[0].len = offset_size;\r\nmsgs[0].buf = offset_bytes;\r\nmsgs[1].addr = slave_addr;\r\nmsgs[1].flags = I2C_M_NOSTART,\r\nmsgs[1].len = len;\r\nmsgs[1].buf = data;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ni2c->controlling_dd = dd;\r\nret = i2c_transfer(&i2c->adapter, msgs, num_msgs);\r\nif (ret != num_msgs) {\r\ndd_dev_err(dd, "%s: bus %d, i2c slave 0x%x, offset 0x%x, len 0x%x; write failed, ret %d\n",\r\n__func__, i2c->num, slave_addr, offset, len, ret);\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_bus_read(struct hfi1_devdata *dd, struct hfi1_i2c_bus *bus,\r\nu8 slave_addr, int offset, int offset_size,\r\nu8 *data, u16 len)\r\n{\r\nint ret;\r\nint num_msgs;\r\nu8 offset_bytes[2];\r\nstruct i2c_msg msgs[2];\r\nswitch (offset_size) {\r\ncase 0:\r\nnum_msgs = 1;\r\nmsgs[0].addr = slave_addr;\r\nmsgs[0].flags = I2C_M_RD;\r\nmsgs[0].len = len;\r\nmsgs[0].buf = data;\r\nbreak;\r\ncase 2:\r\noffset_bytes[1] = (offset >> 8) & 0xff;\r\ncase 1:\r\nnum_msgs = 2;\r\noffset_bytes[0] = offset & 0xff;\r\nmsgs[0].addr = slave_addr;\r\nmsgs[0].flags = 0;\r\nmsgs[0].len = offset_size;\r\nmsgs[0].buf = offset_bytes;\r\nmsgs[1].addr = slave_addr;\r\nmsgs[1].flags = I2C_M_RD,\r\nmsgs[1].len = len;\r\nmsgs[1].buf = data;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbus->controlling_dd = dd;\r\nret = i2c_transfer(&bus->adapter, msgs, num_msgs);\r\nif (ret != num_msgs) {\r\ndd_dev_err(dd, "%s: bus %d, i2c slave 0x%x, offset 0x%x, len 0x%x; read failed, ret %d\n",\r\n__func__, bus->num, slave_addr, offset, len, ret);\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __i2c_write(struct hfi1_pportdata *ppd, u32 target, int i2c_addr,\r\nint offset, void *bp, int len)\r\n{\r\nstruct hfi1_devdata *dd = ppd->dd;\r\nstruct hfi1_i2c_bus *bus;\r\nu8 slave_addr;\r\nint offset_size;\r\nbus = target ? dd->asic_data->i2c_bus1 : dd->asic_data->i2c_bus0;\r\nslave_addr = (i2c_addr & 0xff) >> 1;\r\noffset_size = (i2c_addr >> 8) & 0x3;\r\nreturn i2c_bus_write(dd, bus, slave_addr, offset, offset_size, bp, len);\r\n}\r\nint i2c_write(struct hfi1_pportdata *ppd, u32 target, int i2c_addr, int offset,\r\nvoid *bp, int len)\r\n{\r\nint ret;\r\nif (!check_chip_resource(ppd->dd, i2c_target(target), __func__))\r\nreturn -EACCES;\r\nret = __i2c_write(ppd, target, i2c_addr, offset, bp, len);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic int __i2c_read(struct hfi1_pportdata *ppd, u32 target, int i2c_addr,\r\nint offset, void *bp, int len)\r\n{\r\nstruct hfi1_devdata *dd = ppd->dd;\r\nstruct hfi1_i2c_bus *bus;\r\nu8 slave_addr;\r\nint offset_size;\r\nbus = target ? dd->asic_data->i2c_bus1 : dd->asic_data->i2c_bus0;\r\nslave_addr = (i2c_addr & 0xff) >> 1;\r\noffset_size = (i2c_addr >> 8) & 0x3;\r\nreturn i2c_bus_read(dd, bus, slave_addr, offset, offset_size, bp, len);\r\n}\r\nint i2c_read(struct hfi1_pportdata *ppd, u32 target, int i2c_addr, int offset,\r\nvoid *bp, int len)\r\n{\r\nint ret;\r\nif (!check_chip_resource(ppd->dd, i2c_target(target), __func__))\r\nreturn -EACCES;\r\nret = __i2c_read(ppd, target, i2c_addr, offset, bp, len);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nint qsfp_write(struct hfi1_pportdata *ppd, u32 target, int addr, void *bp,\r\nint len)\r\n{\r\nint count = 0;\r\nint offset;\r\nint nwrite;\r\nint ret = 0;\r\nu8 page;\r\nif (!check_chip_resource(ppd->dd, i2c_target(target), __func__))\r\nreturn -EACCES;\r\nwhile (count < len) {\r\npage = (u8)(addr / QSFP_PAGESIZE);\r\nret = __i2c_write(ppd, target, QSFP_DEV | QSFP_OFFSET_SIZE,\r\nQSFP_PAGE_SELECT_BYTE_OFFS, &page, 1);\r\nmdelay(5);\r\nif (ret) {\r\nhfi1_dev_porterr(ppd->dd, ppd->port,\r\n"QSFP chain %d can't write QSFP_PAGE_SELECT_BYTE: %d\n",\r\ntarget, ret);\r\nbreak;\r\n}\r\noffset = addr % QSFP_PAGESIZE;\r\nnwrite = len - count;\r\nif (((addr % QSFP_RW_BOUNDARY) + nwrite) > QSFP_RW_BOUNDARY)\r\nnwrite = QSFP_RW_BOUNDARY - (addr % QSFP_RW_BOUNDARY);\r\nret = __i2c_write(ppd, target, QSFP_DEV | QSFP_OFFSET_SIZE,\r\noffset, bp + count, nwrite);\r\nmdelay(5);\r\nif (ret)\r\nbreak;\r\ncount += nwrite;\r\naddr += nwrite;\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nint one_qsfp_write(struct hfi1_pportdata *ppd, u32 target, int addr, void *bp,\r\nint len)\r\n{\r\nstruct hfi1_devdata *dd = ppd->dd;\r\nu32 resource = qsfp_resource(dd);\r\nint ret;\r\nret = acquire_chip_resource(dd, resource, QSFP_WAIT);\r\nif (ret)\r\nreturn ret;\r\nret = qsfp_write(ppd, target, addr, bp, len);\r\nrelease_chip_resource(dd, resource);\r\nreturn ret;\r\n}\r\nint qsfp_read(struct hfi1_pportdata *ppd, u32 target, int addr, void *bp,\r\nint len)\r\n{\r\nint count = 0;\r\nint offset;\r\nint nread;\r\nint ret = 0;\r\nu8 page;\r\nif (!check_chip_resource(ppd->dd, i2c_target(target), __func__))\r\nreturn -EACCES;\r\nwhile (count < len) {\r\npage = (u8)(addr / QSFP_PAGESIZE);\r\nret = __i2c_write(ppd, target, QSFP_DEV | QSFP_OFFSET_SIZE,\r\nQSFP_PAGE_SELECT_BYTE_OFFS, &page, 1);\r\nmdelay(5);\r\nif (ret) {\r\nhfi1_dev_porterr(ppd->dd, ppd->port,\r\n"QSFP chain %d can't write QSFP_PAGE_SELECT_BYTE: %d\n",\r\ntarget, ret);\r\nbreak;\r\n}\r\noffset = addr % QSFP_PAGESIZE;\r\nnread = len - count;\r\nif (((addr % QSFP_RW_BOUNDARY) + nread) > QSFP_RW_BOUNDARY)\r\nnread = QSFP_RW_BOUNDARY - (addr % QSFP_RW_BOUNDARY);\r\nret = __i2c_read(ppd, target, QSFP_DEV | QSFP_OFFSET_SIZE,\r\noffset, bp + count, nread);\r\nif (ret)\r\nbreak;\r\ncount += nread;\r\naddr += nread;\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nint one_qsfp_read(struct hfi1_pportdata *ppd, u32 target, int addr, void *bp,\r\nint len)\r\n{\r\nstruct hfi1_devdata *dd = ppd->dd;\r\nu32 resource = qsfp_resource(dd);\r\nint ret;\r\nret = acquire_chip_resource(dd, resource, QSFP_WAIT);\r\nif (ret)\r\nreturn ret;\r\nret = qsfp_read(ppd, target, addr, bp, len);\r\nrelease_chip_resource(dd, resource);\r\nreturn ret;\r\n}\r\nint refresh_qsfp_cache(struct hfi1_pportdata *ppd, struct qsfp_data *cp)\r\n{\r\nu32 target = ppd->dd->hfi1_id;\r\nint ret;\r\nunsigned long flags;\r\nu8 *cache = &cp->cache[0];\r\nmemset(cache, 0, (QSFP_MAX_NUM_PAGES * 128));\r\nspin_lock_irqsave(&ppd->qsfp_info.qsfp_lock, flags);\r\nppd->qsfp_info.cache_valid = 0;\r\nspin_unlock_irqrestore(&ppd->qsfp_info.qsfp_lock, flags);\r\nif (!qsfp_mod_present(ppd)) {\r\nret = -ENODEV;\r\ngoto bail;\r\n}\r\nret = qsfp_read(ppd, target, 0, cache, QSFP_PAGESIZE);\r\nif (ret != QSFP_PAGESIZE) {\r\ndd_dev_info(ppd->dd,\r\n"%s: Page 0 read failed, expected %d, got %d\n",\r\n__func__, QSFP_PAGESIZE, ret);\r\ngoto bail;\r\n}\r\nif (!(cache[2] & 4)) {\r\nif ((cache[195] & 0xC0) == 0xC0) {\r\nret = qsfp_read(ppd, target, 384, cache + 256, 128);\r\nif (ret <= 0 || ret != 128) {\r\ndd_dev_info(ppd->dd, "%s failed\n", __func__);\r\ngoto bail;\r\n}\r\nret = qsfp_read(ppd, target, 640, cache + 384, 128);\r\nif (ret <= 0 || ret != 128) {\r\ndd_dev_info(ppd->dd, "%s failed\n", __func__);\r\ngoto bail;\r\n}\r\nret = qsfp_read(ppd, target, 896, cache + 512, 128);\r\nif (ret <= 0 || ret != 128) {\r\ndd_dev_info(ppd->dd, "%s failed\n", __func__);\r\ngoto bail;\r\n}\r\n} else if ((cache[195] & 0x80) == 0x80) {\r\nret = qsfp_read(ppd, target, 640, cache + 384, 128);\r\nif (ret <= 0 || ret != 128) {\r\ndd_dev_info(ppd->dd, "%s failed\n", __func__);\r\ngoto bail;\r\n}\r\nret = qsfp_read(ppd, target, 896, cache + 512, 128);\r\nif (ret <= 0 || ret != 128) {\r\ndd_dev_info(ppd->dd, "%s failed\n", __func__);\r\ngoto bail;\r\n}\r\n} else if ((cache[195] & 0x40) == 0x40) {\r\nret = qsfp_read(ppd, target, 384, cache + 256, 128);\r\nif (ret <= 0 || ret != 128) {\r\ndd_dev_info(ppd->dd, "%s failed\n", __func__);\r\ngoto bail;\r\n}\r\nret = qsfp_read(ppd, target, 896, cache + 512, 128);\r\nif (ret <= 0 || ret != 128) {\r\ndd_dev_info(ppd->dd, "%s failed\n", __func__);\r\ngoto bail;\r\n}\r\n} else {\r\nret = qsfp_read(ppd, target, 896, cache + 512, 128);\r\nif (ret <= 0 || ret != 128) {\r\ndd_dev_info(ppd->dd, "%s failed\n", __func__);\r\ngoto bail;\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&ppd->qsfp_info.qsfp_lock, flags);\r\nppd->qsfp_info.cache_valid = 1;\r\nppd->qsfp_info.cache_refresh_required = 0;\r\nspin_unlock_irqrestore(&ppd->qsfp_info.qsfp_lock, flags);\r\nreturn 0;\r\nbail:\r\nmemset(cache, 0, (QSFP_MAX_NUM_PAGES * 128));\r\nreturn ret;\r\n}\r\nint get_qsfp_power_class(u8 power_byte)\r\n{\r\nif (QSFP_HIGH_PWR(power_byte) == QSFP_HIGH_PWR_UNUSED)\r\nreturn (QSFP_PWR(power_byte) + 1);\r\nreturn (QSFP_HIGH_PWR(power_byte) + 4);\r\n}\r\nint qsfp_mod_present(struct hfi1_pportdata *ppd)\r\n{\r\nstruct hfi1_devdata *dd = ppd->dd;\r\nu64 reg;\r\nreg = read_csr(dd, dd->hfi1_id ? ASIC_QSFP2_IN : ASIC_QSFP1_IN);\r\nreturn !(reg & QSFP_HFI0_MODPRST_N);\r\n}\r\nint get_cable_info(struct hfi1_devdata *dd, u32 port_num, u32 addr, u32 len,\r\nu8 *data)\r\n{\r\nstruct hfi1_pportdata *ppd;\r\nu32 excess_len = len;\r\nint ret = 0, offset = 0;\r\nif (port_num > dd->num_pports || port_num < 1) {\r\ndd_dev_info(dd, "%s: Invalid port number %d\n",\r\n__func__, port_num);\r\nret = -EINVAL;\r\ngoto set_zeroes;\r\n}\r\nppd = dd->pport + (port_num - 1);\r\nif (!qsfp_mod_present(ppd)) {\r\nret = -ENODEV;\r\ngoto set_zeroes;\r\n}\r\nif (!ppd->qsfp_info.cache_valid) {\r\nret = -EINVAL;\r\ngoto set_zeroes;\r\n}\r\nif (addr >= (QSFP_MAX_NUM_PAGES * 128)) {\r\nret = -ERANGE;\r\ngoto set_zeroes;\r\n}\r\nif ((addr + len) > (QSFP_MAX_NUM_PAGES * 128)) {\r\nexcess_len = (addr + len) - (QSFP_MAX_NUM_PAGES * 128);\r\nmemcpy(data, &ppd->qsfp_info.cache[addr], (len - excess_len));\r\ndata += (len - excess_len);\r\ngoto set_zeroes;\r\n}\r\nmemcpy(data, &ppd->qsfp_info.cache[addr], len);\r\nif (addr <= QSFP_MONITOR_VAL_END &&\r\n(addr + len) >= QSFP_MONITOR_VAL_START) {\r\nif (addr < QSFP_MONITOR_VAL_START) {\r\nif (addr + len <= QSFP_MONITOR_VAL_END)\r\nlen = addr + len - QSFP_MONITOR_VAL_START;\r\nelse\r\nlen = QSFP_MONITOR_RANGE;\r\noffset = QSFP_MONITOR_VAL_START - addr;\r\naddr = QSFP_MONITOR_VAL_START;\r\n} else if (addr == QSFP_MONITOR_VAL_START) {\r\noffset = 0;\r\nif (addr + len > QSFP_MONITOR_VAL_END)\r\nlen = QSFP_MONITOR_RANGE;\r\n} else {\r\noffset = 0;\r\nif (addr + len > QSFP_MONITOR_VAL_END)\r\nlen = QSFP_MONITOR_VAL_END - addr + 1;\r\n}\r\nret = one_qsfp_read(ppd, dd->hfi1_id, addr, data + offset, len);\r\nif (ret != len) {\r\nret = -EAGAIN;\r\ngoto set_zeroes;\r\n}\r\n}\r\nreturn 0;\r\nset_zeroes:\r\nmemset(data, 0, excess_len);\r\nreturn ret;\r\n}\r\nint qsfp_dump(struct hfi1_pportdata *ppd, char *buf, int len)\r\n{\r\nu8 *cache = &ppd->qsfp_info.cache[0];\r\nu8 bin_buff[QSFP_DUMP_CHUNK];\r\nchar lenstr[6];\r\nint sofar;\r\nint bidx = 0;\r\nu8 *atten = &cache[QSFP_ATTEN_OFFS];\r\nu8 *vendor_oui = &cache[QSFP_VOUI_OFFS];\r\nu8 power_byte = 0;\r\nsofar = 0;\r\nlenstr[0] = ' ';\r\nlenstr[1] = '\0';\r\nif (ppd->qsfp_info.cache_valid) {\r\nif (QSFP_IS_CU(cache[QSFP_MOD_TECH_OFFS]))\r\nsnprintf(lenstr, sizeof(lenstr), "%dM ",\r\ncache[QSFP_MOD_LEN_OFFS]);\r\npower_byte = cache[QSFP_MOD_PWR_OFFS];\r\nsofar += scnprintf(buf + sofar, len - sofar, "PWR:%.3sW\n",\r\npwr_codes[get_qsfp_power_class(power_byte)]);\r\nsofar += scnprintf(buf + sofar, len - sofar, "TECH:%s%s\n",\r\nlenstr,\r\nhfi1_qsfp_devtech[(cache[QSFP_MOD_TECH_OFFS]) >> 4]);\r\nsofar += scnprintf(buf + sofar, len - sofar, "Vendor:%.*s\n",\r\nQSFP_VEND_LEN, &cache[QSFP_VEND_OFFS]);\r\nsofar += scnprintf(buf + sofar, len - sofar, "OUI:%06X\n",\r\nQSFP_OUI(vendor_oui));\r\nsofar += scnprintf(buf + sofar, len - sofar, "Part#:%.*s\n",\r\nQSFP_PN_LEN, &cache[QSFP_PN_OFFS]);\r\nsofar += scnprintf(buf + sofar, len - sofar, "Rev:%.*s\n",\r\nQSFP_REV_LEN, &cache[QSFP_REV_OFFS]);\r\nif (QSFP_IS_CU(cache[QSFP_MOD_TECH_OFFS]))\r\nsofar += scnprintf(buf + sofar, len - sofar,\r\n"Atten:%d, %d\n",\r\nQSFP_ATTEN_SDR(atten),\r\nQSFP_ATTEN_DDR(atten));\r\nsofar += scnprintf(buf + sofar, len - sofar, "Serial:%.*s\n",\r\nQSFP_SN_LEN, &cache[QSFP_SN_OFFS]);\r\nsofar += scnprintf(buf + sofar, len - sofar, "Date:%.*s\n",\r\nQSFP_DATE_LEN, &cache[QSFP_DATE_OFFS]);\r\nsofar += scnprintf(buf + sofar, len - sofar, "Lot:%.*s\n",\r\nQSFP_LOT_LEN, &cache[QSFP_LOT_OFFS]);\r\nwhile (bidx < QSFP_DEFAULT_HDR_CNT) {\r\nint iidx;\r\nmemcpy(bin_buff, &cache[bidx], QSFP_DUMP_CHUNK);\r\nfor (iidx = 0; iidx < QSFP_DUMP_CHUNK; ++iidx) {\r\nsofar += scnprintf(buf + sofar, len - sofar,\r\n" %02X", bin_buff[iidx]);\r\n}\r\nsofar += scnprintf(buf + sofar, len - sofar, "\n");\r\nbidx += QSFP_DUMP_CHUNK;\r\n}\r\n}\r\nreturn sofar;\r\n}
