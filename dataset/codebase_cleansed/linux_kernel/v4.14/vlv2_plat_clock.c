int vlv2_plat_set_clock_freq(int clk_num, int freq_type)\r\n{\r\nvoid __iomem *addr;\r\nif (clk_num < 0 || clk_num >= MAX_CLK_COUNT) {\r\npr_err("Clock number out of range (%d)\n", clk_num);\r\nreturn -EINVAL;\r\n}\r\nif (freq_type != CLK_FREQ_TYPE_XTAL &&\r\nfreq_type != CLK_FREQ_TYPE_PLL) {\r\npr_err("wrong clock type\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pmc_base) {\r\npr_err("memio map is not set\n");\r\nreturn -EINVAL;\r\n}\r\naddr = pmc_base + PLT_CLK_CTL_OFFSET(clk_num);\r\nmutex_lock(&clk_mutex);\r\nwritel(REG_SET_FIELD(readl(addr), CLK_FREQ_TYPE, freq_type), addr);\r\nmutex_unlock(&clk_mutex);\r\nreturn 0;\r\n}\r\nint vlv2_plat_get_clock_freq(int clk_num)\r\n{\r\nu32 ret;\r\nif (clk_num < 0 || clk_num >= MAX_CLK_COUNT) {\r\npr_err("Clock number out of range (%d)\n", clk_num);\r\nreturn -EINVAL;\r\n}\r\nif (!pmc_base) {\r\npr_err("memio map is not set\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&clk_mutex);\r\nret = REG_GET_FIELD(readl(pmc_base + PLT_CLK_CTL_OFFSET(clk_num)),\r\nCLK_FREQ_TYPE);\r\nmutex_unlock(&clk_mutex);\r\nreturn ret;\r\n}\r\nint vlv2_plat_configure_clock(int clk_num, u32 conf)\r\n{\r\nvoid __iomem *addr;\r\nif (clk_num < 0 || clk_num >= MAX_CLK_COUNT) {\r\npr_err("Clock number out of range (%d)\n", clk_num);\r\nreturn -EINVAL;\r\n}\r\nif (conf != CLK_CONFG_D3_GATED &&\r\nconf != CLK_CONFG_FORCE_ON &&\r\nconf != CLK_CONFG_FORCE_OFF) {\r\npr_err("Invalid clock configuration requested\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pmc_base) {\r\npr_err("memio map is not set\n");\r\nreturn -EINVAL;\r\n}\r\naddr = pmc_base + PLT_CLK_CTL_OFFSET(clk_num);\r\nmutex_lock(&clk_mutex);\r\nwritel(REG_SET_FIELD(readl(addr), CLK_CONFG, conf), addr);\r\nmutex_unlock(&clk_mutex);\r\nreturn 0;\r\n}\r\nint vlv2_plat_get_clock_status(int clk_num)\r\n{\r\nint ret;\r\nif (clk_num < 0 || clk_num >= MAX_CLK_COUNT) {\r\npr_err("Clock number out of range (%d)\n", clk_num);\r\nreturn -EINVAL;\r\n}\r\nif (!pmc_base) {\r\npr_err("memio map is not set\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&clk_mutex);\r\nret = (int)REG_GET_FIELD(readl(pmc_base + PLT_CLK_CTL_OFFSET(clk_num)),\r\nCLK_CONFG);\r\nmutex_unlock(&clk_mutex);\r\nreturn ret;\r\n}\r\nstatic int vlv2_plat_clk_probe(struct platform_device *pdev)\r\n{\r\nint i = 0;\r\npmc_base = ioremap_nocache(VLV2_PMC_CLK_BASE_ADDRESS, PMC_MAP_SIZE);\r\nif (!pmc_base) {\r\ndev_err(&pdev->dev, "I/O memory remapping failed\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < MAX_CLK_COUNT; i++)\r\nvlv2_plat_configure_clock(i, CLK_CONFG_FORCE_OFF);\r\ndev_info(&pdev->dev, "vlv2_plat_clk initialized\n");\r\nreturn 0;\r\n}\r\nstatic int vlv2_resume(struct device *device)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_CLK_COUNT; i++)\r\nvlv2_plat_configure_clock(i, CLK_CONFG_FORCE_OFF);\r\nreturn 0;\r\n}\r\nstatic int vlv2_suspend(struct device *device)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init vlv2_plat_clk_init(void)\r\n{\r\nreturn platform_driver_register(&vlv2_plat_clk_driver);\r\n}
