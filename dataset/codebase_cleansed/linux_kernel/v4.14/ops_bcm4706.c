static inline u8 bcm47xxnflash_ops_bcm4706_ns_to_cycle(u16 ns, u16 clock)\r\n{\r\nreturn ((ns * 1000 * clock) / 1000000) + 1;\r\n}\r\nstatic int bcm47xxnflash_ops_bcm4706_ctl_cmd(struct bcma_drv_cc *cc, u32 code)\r\n{\r\nint i = 0;\r\nbcma_cc_write32(cc, BCMA_CC_NFLASH_CTL, NCTL_START | code);\r\nfor (i = 0; i < NFLASH_READY_RETRIES; i++) {\r\nif (!(bcma_cc_read32(cc, BCMA_CC_NFLASH_CTL) & NCTL_START)) {\r\ni = 0;\r\nbreak;\r\n}\r\n}\r\nif (i) {\r\npr_err("NFLASH control command not ready!\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm47xxnflash_ops_bcm4706_poll(struct bcma_drv_cc *cc)\r\n{\r\nint i;\r\nfor (i = 0; i < NFLASH_READY_RETRIES; i++) {\r\nif (bcma_cc_read32(cc, BCMA_CC_NFLASH_CTL) & NCTL_READY) {\r\nif (bcma_cc_read32(cc, BCMA_CC_NFLASH_CTL) &\r\nBCMA_CC_NFLASH_CTL_ERR) {\r\npr_err("Error on polling\n");\r\nreturn -EBUSY;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\n}\r\npr_err("Polling timeout!\n");\r\nreturn -EBUSY;\r\n}\r\nstatic void bcm47xxnflash_ops_bcm4706_read(struct mtd_info *mtd, uint8_t *buf,\r\nint len)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\r\nu32 ctlcode;\r\nu32 *dest = (u32 *)buf;\r\nint i;\r\nint toread;\r\nBUG_ON(b47n->curr_page_addr & ~nand_chip->pagemask);\r\nwhile (len) {\r\ntoread = min(len, 0x200);\r\nbcma_cc_write32(b47n->cc, BCMA_CC_NFLASH_COL_ADDR,\r\nb47n->curr_column);\r\nbcma_cc_write32(b47n->cc, BCMA_CC_NFLASH_ROW_ADDR,\r\nb47n->curr_page_addr);\r\nctlcode = NCTL_CSA | NCTL_CMD1W | NCTL_ROW | NCTL_COL |\r\nNCTL_CMD0;\r\nctlcode |= NAND_CMD_READSTART << 8;\r\nif (bcm47xxnflash_ops_bcm4706_ctl_cmd(b47n->cc, ctlcode))\r\nreturn;\r\nif (bcm47xxnflash_ops_bcm4706_poll(b47n->cc))\r\nreturn;\r\nfor (i = 0; i < toread; i += 4, dest++) {\r\nctlcode = NCTL_CSA | 0x30000000 | NCTL_READ;\r\nif (i == toread - 4)\r\nctlcode &= ~NCTL_CSA;\r\nif (bcm47xxnflash_ops_bcm4706_ctl_cmd(b47n->cc,\r\nctlcode))\r\nreturn;\r\n*dest = bcma_cc_read32(b47n->cc, BCMA_CC_NFLASH_DATA);\r\n}\r\nb47n->curr_column += toread;\r\nlen -= toread;\r\n}\r\n}\r\nstatic void bcm47xxnflash_ops_bcm4706_write(struct mtd_info *mtd,\r\nconst uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\r\nstruct bcma_drv_cc *cc = b47n->cc;\r\nu32 ctlcode;\r\nconst u32 *data = (u32 *)buf;\r\nint i;\r\nBUG_ON(b47n->curr_page_addr & ~nand_chip->pagemask);\r\nfor (i = 0; i < len; i += 4, data++) {\r\nbcma_cc_write32(cc, BCMA_CC_NFLASH_DATA, *data);\r\nctlcode = NCTL_CSA | 0x30000000 | NCTL_WRITE;\r\nif (i == len - 4)\r\nctlcode &= ~NCTL_CSA;\r\nif (bcm47xxnflash_ops_bcm4706_ctl_cmd(cc, ctlcode)) {\r\npr_err("%s ctl_cmd didn't work!\n", __func__);\r\nreturn;\r\n}\r\n}\r\nb47n->curr_column += len;\r\n}\r\nstatic void bcm47xxnflash_ops_bcm4706_cmd_ctrl(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\r\nu32 code = 0;\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (cmd & NAND_CTRL_CLE)\r\ncode = cmd | NCTL_CMD0;\r\nif (cmd != NAND_CMD_RESET)\r\ncode |= NCTL_CSA;\r\nbcm47xxnflash_ops_bcm4706_ctl_cmd(b47n->cc, code);\r\n}\r\nstatic void bcm47xxnflash_ops_bcm4706_select_chip(struct mtd_info *mtd,\r\nint chip)\r\n{\r\nreturn;\r\n}\r\nstatic int bcm47xxnflash_ops_bcm4706_dev_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\r\nreturn !!(bcma_cc_read32(b47n->cc, BCMA_CC_NFLASH_CTL) & NCTL_READY);\r\n}\r\nstatic void bcm47xxnflash_ops_bcm4706_cmdfunc(struct mtd_info *mtd,\r\nunsigned command, int column,\r\nint page_addr)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\r\nstruct bcma_drv_cc *cc = b47n->cc;\r\nu32 ctlcode;\r\nint i;\r\nif (column != -1)\r\nb47n->curr_column = column;\r\nif (page_addr != -1)\r\nb47n->curr_page_addr = page_addr;\r\nswitch (command) {\r\ncase NAND_CMD_RESET:\r\nnand_chip->cmd_ctrl(mtd, command, NAND_CTRL_CLE);\r\nndelay(100);\r\nnand_wait_ready(mtd);\r\nbreak;\r\ncase NAND_CMD_READID:\r\nctlcode = NCTL_CSA | 0x01000000 | NCTL_CMD1W | NCTL_CMD0;\r\nctlcode |= NAND_CMD_READID;\r\nif (bcm47xxnflash_ops_bcm4706_ctl_cmd(b47n->cc, ctlcode)) {\r\npr_err("READID error\n");\r\nbreak;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(b47n->id_data); i++) {\r\nctlcode = NCTL_CSA | NCTL_READ;\r\nif (i == ARRAY_SIZE(b47n->id_data) - 1)\r\nctlcode &= ~NCTL_CSA;\r\nif (bcm47xxnflash_ops_bcm4706_ctl_cmd(b47n->cc,\r\nctlcode)) {\r\npr_err("READID error\n");\r\nbreak;\r\n}\r\nb47n->id_data[i] =\r\nbcma_cc_read32(b47n->cc, BCMA_CC_NFLASH_DATA)\r\n& 0xFF;\r\n}\r\nbreak;\r\ncase NAND_CMD_STATUS:\r\nctlcode = NCTL_CSA | NCTL_CMD0 | NAND_CMD_STATUS;\r\nif (bcm47xxnflash_ops_bcm4706_ctl_cmd(cc, ctlcode))\r\npr_err("STATUS command error\n");\r\nbreak;\r\ncase NAND_CMD_READ0:\r\nbreak;\r\ncase NAND_CMD_READOOB:\r\nif (page_addr != -1)\r\nb47n->curr_column += mtd->writesize;\r\nbreak;\r\ncase NAND_CMD_ERASE1:\r\nbcma_cc_write32(cc, BCMA_CC_NFLASH_ROW_ADDR,\r\nb47n->curr_page_addr);\r\nctlcode = NCTL_ROW | NCTL_CMD1W | NCTL_CMD0 |\r\nNAND_CMD_ERASE1 | (NAND_CMD_ERASE2 << 8);\r\nif (bcm47xxnflash_ops_bcm4706_ctl_cmd(cc, ctlcode))\r\npr_err("ERASE1 failed\n");\r\nbreak;\r\ncase NAND_CMD_ERASE2:\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\nbcma_cc_write32(cc, BCMA_CC_NFLASH_COL_ADDR,\r\nb47n->curr_column);\r\nbcma_cc_write32(cc, BCMA_CC_NFLASH_ROW_ADDR,\r\nb47n->curr_page_addr);\r\nctlcode = 0x40000000 | NCTL_ROW | NCTL_COL | NCTL_CMD0;\r\nctlcode |= NAND_CMD_SEQIN;\r\nif (bcm47xxnflash_ops_bcm4706_ctl_cmd(cc, ctlcode))\r\npr_err("SEQIN failed\n");\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\nif (bcm47xxnflash_ops_bcm4706_ctl_cmd(cc, NCTL_CMD0 |\r\nNAND_CMD_PAGEPROG))\r\npr_err("PAGEPROG failed\n");\r\nif (bcm47xxnflash_ops_bcm4706_poll(cc))\r\npr_err("PAGEPROG not ready\n");\r\nbreak;\r\ndefault:\r\npr_err("Command 0x%X unsupported\n", command);\r\nbreak;\r\n}\r\nb47n->curr_command = command;\r\n}\r\nstatic u8 bcm47xxnflash_ops_bcm4706_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\r\nstruct bcma_drv_cc *cc = b47n->cc;\r\nu32 tmp = 0;\r\nswitch (b47n->curr_command) {\r\ncase NAND_CMD_READID:\r\nif (b47n->curr_column >= ARRAY_SIZE(b47n->id_data)) {\r\npr_err("Requested invalid id_data: %d\n",\r\nb47n->curr_column);\r\nreturn 0;\r\n}\r\nreturn b47n->id_data[b47n->curr_column++];\r\ncase NAND_CMD_STATUS:\r\nif (bcm47xxnflash_ops_bcm4706_ctl_cmd(cc, NCTL_READ))\r\nreturn 0;\r\nreturn bcma_cc_read32(cc, BCMA_CC_NFLASH_DATA) & 0xff;\r\ncase NAND_CMD_READOOB:\r\nbcm47xxnflash_ops_bcm4706_read(mtd, (u8 *)&tmp, 4);\r\nreturn tmp & 0xFF;\r\n}\r\npr_err("Invalid command for byte read: 0x%X\n", b47n->curr_command);\r\nreturn 0;\r\n}\r\nstatic void bcm47xxnflash_ops_bcm4706_read_buf(struct mtd_info *mtd,\r\nuint8_t *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\r\nswitch (b47n->curr_command) {\r\ncase NAND_CMD_READ0:\r\ncase NAND_CMD_READOOB:\r\nbcm47xxnflash_ops_bcm4706_read(mtd, buf, len);\r\nreturn;\r\n}\r\npr_err("Invalid command for buf read: 0x%X\n", b47n->curr_command);\r\n}\r\nstatic void bcm47xxnflash_ops_bcm4706_write_buf(struct mtd_info *mtd,\r\nconst uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\r\nswitch (b47n->curr_command) {\r\ncase NAND_CMD_SEQIN:\r\nbcm47xxnflash_ops_bcm4706_write(mtd, buf, len);\r\nreturn;\r\n}\r\npr_err("Invalid command for buf write: 0x%X\n", b47n->curr_command);\r\n}\r\nint bcm47xxnflash_ops_bcm4706_init(struct bcm47xxnflash *b47n)\r\n{\r\nstruct nand_chip *nand_chip = (struct nand_chip *)&b47n->nand_chip;\r\nint err;\r\nu32 freq;\r\nu16 clock;\r\nu8 w0, w1, w2, w3, w4;\r\nunsigned long chipsize;\r\nu8 tbits, col_bits, col_size, row_bits, row_bsize;\r\nu32 val;\r\nb47n->nand_chip.select_chip = bcm47xxnflash_ops_bcm4706_select_chip;\r\nnand_chip->cmd_ctrl = bcm47xxnflash_ops_bcm4706_cmd_ctrl;\r\nnand_chip->dev_ready = bcm47xxnflash_ops_bcm4706_dev_ready;\r\nb47n->nand_chip.cmdfunc = bcm47xxnflash_ops_bcm4706_cmdfunc;\r\nb47n->nand_chip.read_byte = bcm47xxnflash_ops_bcm4706_read_byte;\r\nb47n->nand_chip.read_buf = bcm47xxnflash_ops_bcm4706_read_buf;\r\nb47n->nand_chip.write_buf = bcm47xxnflash_ops_bcm4706_write_buf;\r\nb47n->nand_chip.onfi_set_features = nand_onfi_get_set_features_notsupp;\r\nb47n->nand_chip.onfi_get_features = nand_onfi_get_set_features_notsupp;\r\nnand_chip->chip_delay = 50;\r\nb47n->nand_chip.bbt_options = NAND_BBT_USE_FLASH;\r\nb47n->nand_chip.ecc.mode = NAND_ECC_NONE;\r\nbcma_cc_set32(b47n->cc, BCMA_CC_4706_FLASHSCFG,\r\nBCMA_CC_4706_FLASHSCFG_NF1);\r\nif (b47n->cc->status & BCMA_CC_CHIPST_4706_PKG_OPTION) {\r\nfreq = 400000000 / 4;\r\n} else {\r\nfreq = bcma_chipco_pll_read(b47n->cc, 4);\r\nfreq = (freq & 0xFFF) >> 3;\r\nfreq = (freq * 25000000 / 2) / 4;\r\n}\r\nclock = freq / 1000000;\r\nw0 = bcm47xxnflash_ops_bcm4706_ns_to_cycle(15, clock);\r\nw1 = bcm47xxnflash_ops_bcm4706_ns_to_cycle(20, clock);\r\nw2 = bcm47xxnflash_ops_bcm4706_ns_to_cycle(10, clock);\r\nw3 = bcm47xxnflash_ops_bcm4706_ns_to_cycle(10, clock);\r\nw4 = bcm47xxnflash_ops_bcm4706_ns_to_cycle(100, clock);\r\nbcma_cc_write32(b47n->cc, BCMA_CC_NFLASH_WAITCNT0,\r\n(w4 << 24 | w3 << 18 | w2 << 12 | w1 << 6 | w0));\r\nerr = nand_scan(nand_to_mtd(&b47n->nand_chip), 1);\r\nif (err) {\r\npr_err("Could not scan NAND flash: %d\n", err);\r\ngoto exit;\r\n}\r\nchipsize = b47n->nand_chip.chipsize >> 20;\r\ntbits = ffs(chipsize);\r\nif (!tbits || tbits != fls(chipsize)) {\r\npr_err("Invalid flash size: 0x%lX\n", chipsize);\r\nerr = -ENOTSUPP;\r\ngoto exit;\r\n}\r\ntbits += 19;\r\ncol_bits = b47n->nand_chip.page_shift + 1;\r\ncol_size = (col_bits + 7) / 8;\r\nrow_bits = tbits - col_bits + 1;\r\nrow_bsize = (row_bits + 7) / 8;\r\nval = ((row_bsize - 1) << 6) | ((col_size - 1) << 4) | 2;\r\nbcma_cc_write32(b47n->cc, BCMA_CC_NFLASH_CONF, val);\r\nexit:\r\nif (err)\r\nbcma_cc_mask32(b47n->cc, BCMA_CC_4706_FLASHSCFG,\r\n~BCMA_CC_4706_FLASHSCFG_NF1);\r\nreturn err;\r\n}
