static int cinergyt2_streaming_ctrl(struct dvb_usb_adapter *adap, int enable)\r\n{\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct cinergyt2_state *st = d->priv;\r\nint ret;\r\nmutex_lock(&d->data_mutex);\r\nst->data[0] = CINERGYT2_EP1_CONTROL_STREAM_TRANSFER;\r\nst->data[1] = enable ? 1 : 0;\r\nret = dvb_usb_generic_rw(d, st->data, 2, st->data, 64, 0);\r\nmutex_unlock(&d->data_mutex);\r\nreturn ret;\r\n}\r\nstatic int cinergyt2_power_ctrl(struct dvb_usb_device *d, int enable)\r\n{\r\nstruct cinergyt2_state *st = d->priv;\r\nint ret;\r\nmutex_lock(&d->data_mutex);\r\nst->data[0] = CINERGYT2_EP1_SLEEP_MODE;\r\nst->data[1] = enable ? 0 : 1;\r\nret = dvb_usb_generic_rw(d, st->data, 2, st->data, 3, 0);\r\nmutex_unlock(&d->data_mutex);\r\nreturn ret;\r\n}\r\nstatic int cinergyt2_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct cinergyt2_state *st = d->priv;\r\nint ret;\r\nadap->fe_adap[0].fe = cinergyt2_fe_attach(adap->dev);\r\nmutex_lock(&d->data_mutex);\r\nst->data[0] = CINERGYT2_EP1_GET_FIRMWARE_VERSION;\r\nret = dvb_usb_generic_rw(d, st->data, 1, st->data, 3, 0);\r\nif (ret < 0) {\r\ndeb_rc("cinergyt2_power_ctrl() Failed to retrieve sleep state info\n");\r\n}\r\nmutex_unlock(&d->data_mutex);\r\ncinergyt2_usb_device = adap->dev;\r\nreturn ret;\r\n}\r\nstatic int cinergyt2_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\r\n{\r\nstruct cinergyt2_state *st = d->priv;\r\nint i, ret;\r\n*state = REMOTE_NO_KEY_PRESSED;\r\nmutex_lock(&d->data_mutex);\r\nst->data[0] = CINERGYT2_EP1_GET_RC_EVENTS;\r\nret = dvb_usb_generic_rw(d, st->data, 1, st->data, 5, 0);\r\nif (ret < 0)\r\ngoto ret;\r\nif (st->data[4] == 0xff) {\r\nst->rc_counter++;\r\nif (st->rc_counter > RC_REPEAT_DELAY) {\r\nfor (i = 0; i < ARRAY_SIZE(repeatable_keys); i++) {\r\nif (d->last_event == repeatable_keys[i]) {\r\n*state = REMOTE_KEY_REPEAT;\r\n*event = d->last_event;\r\ndeb_rc("repeat key, event %x\n",\r\n*event);\r\ngoto ret;\r\n}\r\n}\r\ndeb_rc("repeated key (non repeatable)\n");\r\n}\r\ngoto ret;\r\n}\r\nst->data[2] = ~st->data[1];\r\ndvb_usb_nec_rc_key_to_event(d, st->data, event, state);\r\nif (st->data[0] != 0) {\r\nif (*event != d->last_event)\r\nst->rc_counter = 0;\r\ndeb_rc("key: %*ph\n", 5, st->data);\r\n}\r\nret:\r\nmutex_unlock(&d->data_mutex);\r\nreturn ret;\r\n}\r\nstatic int cinergyt2_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn dvb_usb_device_init(intf, &cinergyt2_properties,\r\nTHIS_MODULE, NULL, adapter_nr);\r\n}
