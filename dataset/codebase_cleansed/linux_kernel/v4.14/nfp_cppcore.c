static void __resource_add(struct list_head *head, struct nfp_cpp_resource *res)\r\n{\r\nstruct nfp_cpp_resource *tmp;\r\nstruct list_head *pos;\r\nlist_for_each(pos, head) {\r\ntmp = container_of(pos, struct nfp_cpp_resource, list);\r\nif (tmp->cpp_id > res->cpp_id)\r\nbreak;\r\nif (tmp->cpp_id == res->cpp_id && tmp->start > res->start)\r\nbreak;\r\n}\r\nlist_add_tail(&res->list, pos);\r\n}\r\nstatic void __resource_del(struct nfp_cpp_resource *res)\r\n{\r\nlist_del_init(&res->list);\r\n}\r\nstatic void __release_cpp_area(struct kref *kref)\r\n{\r\nstruct nfp_cpp_area *area =\r\ncontainer_of(kref, struct nfp_cpp_area, kref);\r\nstruct nfp_cpp *cpp = nfp_cpp_area_cpp(area);\r\nif (area->cpp->op->area_cleanup)\r\narea->cpp->op->area_cleanup(area);\r\nwrite_lock(&cpp->resource_lock);\r\n__resource_del(&area->resource);\r\nwrite_unlock(&cpp->resource_lock);\r\nkfree(area);\r\n}\r\nstatic void nfp_cpp_area_put(struct nfp_cpp_area *area)\r\n{\r\nkref_put(&area->kref, __release_cpp_area);\r\n}\r\nstatic struct nfp_cpp_area *nfp_cpp_area_get(struct nfp_cpp_area *area)\r\n{\r\nkref_get(&area->kref);\r\nreturn area;\r\n}\r\nvoid nfp_cpp_free(struct nfp_cpp *cpp)\r\n{\r\nstruct nfp_cpp_area_cache *cache, *ctmp;\r\nstruct nfp_cpp_resource *res, *rtmp;\r\nlist_for_each_entry_safe(cache, ctmp, &cpp->area_cache_list, entry) {\r\nlist_del(&cache->entry);\r\nif (cache->id)\r\nnfp_cpp_area_release(cache->area);\r\nnfp_cpp_area_free(cache->area);\r\nkfree(cache);\r\n}\r\nWARN_ON(!list_empty(&cpp->resource_list));\r\nlist_for_each_entry_safe(res, rtmp, &cpp->resource_list, list) {\r\nstruct nfp_cpp_area *area = container_of(res,\r\nstruct nfp_cpp_area,\r\nresource);\r\ndev_err(cpp->dev.parent, "Dangling area: %d:%d:%d:0x%0llx-0x%0llx%s%s\n",\r\nNFP_CPP_ID_TARGET_of(res->cpp_id),\r\nNFP_CPP_ID_ACTION_of(res->cpp_id),\r\nNFP_CPP_ID_TOKEN_of(res->cpp_id),\r\nres->start, res->end,\r\nres->name ? " " : "",\r\nres->name ? res->name : "");\r\nif (area->cpp->op->area_release)\r\narea->cpp->op->area_release(area);\r\n__release_cpp_area(&area->kref);\r\n}\r\nif (cpp->op->free)\r\ncpp->op->free(cpp);\r\ndevice_unregister(&cpp->dev);\r\nkfree(cpp);\r\n}\r\nu32 nfp_cpp_model(struct nfp_cpp *cpp)\r\n{\r\nreturn cpp->model;\r\n}\r\nu16 nfp_cpp_interface(struct nfp_cpp *cpp)\r\n{\r\nreturn cpp->interface;\r\n}\r\nint nfp_cpp_serial(struct nfp_cpp *cpp, const u8 **serial)\r\n{\r\n*serial = &cpp->serial[0];\r\nreturn sizeof(cpp->serial);\r\n}\r\nstruct nfp_cpp_area *\r\nnfp_cpp_area_alloc_with_name(struct nfp_cpp *cpp, u32 dest, const char *name,\r\nunsigned long long address, unsigned long size)\r\n{\r\nstruct nfp_cpp_area *area;\r\nu64 tmp64 = address;\r\nint err, name_len;\r\nerr = nfp_target_cpp(dest, tmp64, &dest, &tmp64, cpp->imb_cat_table);\r\nif (err < 0)\r\nreturn NULL;\r\naddress = tmp64;\r\nif (!name)\r\nname = "(reserved)";\r\nname_len = strlen(name) + 1;\r\narea = kzalloc(sizeof(*area) + cpp->op->area_priv_size + name_len,\r\nGFP_KERNEL);\r\nif (!area)\r\nreturn NULL;\r\narea->cpp = cpp;\r\narea->resource.name = (void *)area + sizeof(*area) +\r\ncpp->op->area_priv_size;\r\nmemcpy((char *)area->resource.name, name, name_len);\r\narea->resource.cpp_id = dest;\r\narea->resource.start = address;\r\narea->resource.end = area->resource.start + size - 1;\r\nINIT_LIST_HEAD(&area->resource.list);\r\natomic_set(&area->refcount, 0);\r\nkref_init(&area->kref);\r\nmutex_init(&area->mutex);\r\nif (cpp->op->area_init) {\r\nint err;\r\nerr = cpp->op->area_init(area, dest, address, size);\r\nif (err < 0) {\r\nkfree(area);\r\nreturn NULL;\r\n}\r\n}\r\nwrite_lock(&cpp->resource_lock);\r\n__resource_add(&cpp->resource_list, &area->resource);\r\nwrite_unlock(&cpp->resource_lock);\r\narea->offset = address;\r\narea->size = size;\r\nreturn area;\r\n}\r\nstruct nfp_cpp_area *\r\nnfp_cpp_area_alloc(struct nfp_cpp *cpp, u32 dest,\r\nunsigned long long address, unsigned long size)\r\n{\r\nreturn nfp_cpp_area_alloc_with_name(cpp, dest, NULL, address, size);\r\n}\r\nstruct nfp_cpp_area *\r\nnfp_cpp_area_alloc_acquire(struct nfp_cpp *cpp, const char *name, u32 dest,\r\nunsigned long long address, unsigned long size)\r\n{\r\nstruct nfp_cpp_area *area;\r\narea = nfp_cpp_area_alloc_with_name(cpp, dest, name, address, size);\r\nif (!area)\r\nreturn NULL;\r\nif (nfp_cpp_area_acquire(area)) {\r\nnfp_cpp_area_free(area);\r\nreturn NULL;\r\n}\r\nreturn area;\r\n}\r\nvoid nfp_cpp_area_free(struct nfp_cpp_area *area)\r\n{\r\nif (atomic_read(&area->refcount))\r\nnfp_warn(area->cpp, "Warning: freeing busy area\n");\r\nnfp_cpp_area_put(area);\r\n}\r\nstatic bool nfp_cpp_area_acquire_try(struct nfp_cpp_area *area, int *status)\r\n{\r\n*status = area->cpp->op->area_acquire(area);\r\nreturn *status != -EAGAIN;\r\n}\r\nstatic int __nfp_cpp_area_acquire(struct nfp_cpp_area *area)\r\n{\r\nint err, status;\r\nif (atomic_inc_return(&area->refcount) > 1)\r\nreturn 0;\r\nif (!area->cpp->op->area_acquire)\r\nreturn 0;\r\nerr = wait_event_interruptible(area->cpp->waitq,\r\nnfp_cpp_area_acquire_try(area, &status));\r\nif (!err)\r\nerr = status;\r\nif (err) {\r\nnfp_warn(area->cpp, "Warning: area wait failed: %d\n", err);\r\natomic_dec(&area->refcount);\r\nreturn err;\r\n}\r\nnfp_cpp_area_get(area);\r\nreturn 0;\r\n}\r\nint nfp_cpp_area_acquire(struct nfp_cpp_area *area)\r\n{\r\nint ret;\r\nmutex_lock(&area->mutex);\r\nret = __nfp_cpp_area_acquire(area);\r\nmutex_unlock(&area->mutex);\r\nreturn ret;\r\n}\r\nint nfp_cpp_area_acquire_nonblocking(struct nfp_cpp_area *area)\r\n{\r\nmutex_lock(&area->mutex);\r\nif (atomic_inc_return(&area->refcount) == 1) {\r\nif (area->cpp->op->area_acquire) {\r\nint err;\r\nerr = area->cpp->op->area_acquire(area);\r\nif (err < 0) {\r\natomic_dec(&area->refcount);\r\nmutex_unlock(&area->mutex);\r\nreturn err;\r\n}\r\n}\r\n}\r\nmutex_unlock(&area->mutex);\r\nnfp_cpp_area_get(area);\r\nreturn 0;\r\n}\r\nvoid nfp_cpp_area_release(struct nfp_cpp_area *area)\r\n{\r\nmutex_lock(&area->mutex);\r\nif (atomic_dec_and_test(&area->refcount)) {\r\nif (area->cpp->op->area_release) {\r\narea->cpp->op->area_release(area);\r\nwake_up_interruptible_all(&area->cpp->waitq);\r\n}\r\n}\r\nmutex_unlock(&area->mutex);\r\nnfp_cpp_area_put(area);\r\n}\r\nvoid nfp_cpp_area_release_free(struct nfp_cpp_area *area)\r\n{\r\nnfp_cpp_area_release(area);\r\nnfp_cpp_area_free(area);\r\n}\r\nint nfp_cpp_area_read(struct nfp_cpp_area *area,\r\nunsigned long offset, void *kernel_vaddr,\r\nsize_t length)\r\n{\r\nreturn area->cpp->op->area_read(area, kernel_vaddr, offset, length);\r\n}\r\nint nfp_cpp_area_write(struct nfp_cpp_area *area,\r\nunsigned long offset, const void *kernel_vaddr,\r\nsize_t length)\r\n{\r\nreturn area->cpp->op->area_write(area, kernel_vaddr, offset, length);\r\n}\r\nconst char *nfp_cpp_area_name(struct nfp_cpp_area *cpp_area)\r\n{\r\nreturn cpp_area->resource.name;\r\n}\r\nvoid *nfp_cpp_area_priv(struct nfp_cpp_area *cpp_area)\r\n{\r\nreturn &cpp_area[1];\r\n}\r\nstruct nfp_cpp *nfp_cpp_area_cpp(struct nfp_cpp_area *cpp_area)\r\n{\r\nreturn cpp_area->cpp;\r\n}\r\nstruct resource *nfp_cpp_area_resource(struct nfp_cpp_area *area)\r\n{\r\nstruct resource *res = NULL;\r\nif (area->cpp->op->area_resource)\r\nres = area->cpp->op->area_resource(area);\r\nreturn res;\r\n}\r\nphys_addr_t nfp_cpp_area_phys(struct nfp_cpp_area *area)\r\n{\r\nphys_addr_t addr = ~0;\r\nif (area->cpp->op->area_phys)\r\naddr = area->cpp->op->area_phys(area);\r\nreturn addr;\r\n}\r\nvoid __iomem *nfp_cpp_area_iomem(struct nfp_cpp_area *area)\r\n{\r\nvoid __iomem *iomem = NULL;\r\nif (area->cpp->op->area_iomem)\r\niomem = area->cpp->op->area_iomem(area);\r\nreturn iomem;\r\n}\r\nint nfp_cpp_area_readl(struct nfp_cpp_area *area,\r\nunsigned long offset, u32 *value)\r\n{\r\nu8 tmp[4];\r\nint err;\r\nerr = nfp_cpp_area_read(area, offset, &tmp, sizeof(tmp));\r\n*value = get_unaligned_le32(tmp);\r\nreturn err;\r\n}\r\nint nfp_cpp_area_writel(struct nfp_cpp_area *area,\r\nunsigned long offset, u32 value)\r\n{\r\nu8 tmp[4];\r\nput_unaligned_le32(value, tmp);\r\nreturn nfp_cpp_area_write(area, offset, &tmp, sizeof(tmp));\r\n}\r\nint nfp_cpp_area_readq(struct nfp_cpp_area *area,\r\nunsigned long offset, u64 *value)\r\n{\r\nu8 tmp[8];\r\nint err;\r\nerr = nfp_cpp_area_read(area, offset, &tmp, sizeof(tmp));\r\n*value = get_unaligned_le64(tmp);\r\nreturn err;\r\n}\r\nint nfp_cpp_area_writeq(struct nfp_cpp_area *area,\r\nunsigned long offset, u64 value)\r\n{\r\nu8 tmp[8];\r\nput_unaligned_le64(value, tmp);\r\nreturn nfp_cpp_area_write(area, offset, &tmp, sizeof(tmp));\r\n}\r\nint nfp_cpp_area_fill(struct nfp_cpp_area *area,\r\nunsigned long offset, u32 value, size_t length)\r\n{\r\nu8 tmp[4];\r\nsize_t i;\r\nint k;\r\nput_unaligned_le32(value, tmp);\r\nif (offset % sizeof(tmp) || length % sizeof(tmp))\r\nreturn -EINVAL;\r\nfor (i = 0; i < length; i += sizeof(tmp)) {\r\nk = nfp_cpp_area_write(area, offset + i, &tmp, sizeof(tmp));\r\nif (k < 0)\r\nreturn k;\r\n}\r\nreturn i;\r\n}\r\nint nfp_cpp_area_cache_add(struct nfp_cpp *cpp, size_t size)\r\n{\r\nstruct nfp_cpp_area_cache *cache;\r\nstruct nfp_cpp_area *area;\r\narea = nfp_cpp_area_alloc(cpp, NFP_CPP_ID(7, NFP_CPP_ACTION_RW, 0),\r\n0, size);\r\nif (!area)\r\nreturn -ENOMEM;\r\ncache = kzalloc(sizeof(*cache), GFP_KERNEL);\r\nif (!cache)\r\nreturn -ENOMEM;\r\ncache->id = 0;\r\ncache->addr = 0;\r\ncache->size = size;\r\ncache->area = area;\r\nmutex_lock(&cpp->area_cache_mutex);\r\nlist_add_tail(&cache->entry, &cpp->area_cache_list);\r\nmutex_unlock(&cpp->area_cache_mutex);\r\nreturn 0;\r\n}\r\nstatic struct nfp_cpp_area_cache *\r\narea_cache_get(struct nfp_cpp *cpp, u32 id,\r\nu64 addr, unsigned long *offset, size_t length)\r\n{\r\nstruct nfp_cpp_area_cache *cache;\r\nint err;\r\nif (length == 0 || id == 0)\r\nreturn NULL;\r\nerr = nfp_target_cpp(id, addr, &id, &addr, cpp->imb_cat_table);\r\nif (err < 0)\r\nreturn NULL;\r\nmutex_lock(&cpp->area_cache_mutex);\r\nif (list_empty(&cpp->area_cache_list)) {\r\nmutex_unlock(&cpp->area_cache_mutex);\r\nreturn NULL;\r\n}\r\naddr += *offset;\r\nlist_for_each_entry(cache, &cpp->area_cache_list, entry) {\r\nif (id == cache->id &&\r\naddr >= cache->addr &&\r\naddr + length <= cache->addr + cache->size)\r\ngoto exit;\r\n}\r\ncache = list_entry(cpp->area_cache_list.prev,\r\nstruct nfp_cpp_area_cache, entry);\r\nif (round_down(addr + length - 1, cache->size) !=\r\nround_down(addr, cache->size)) {\r\nmutex_unlock(&cpp->area_cache_mutex);\r\nreturn NULL;\r\n}\r\nif (cache->id) {\r\nnfp_cpp_area_release(cache->area);\r\ncache->id = 0;\r\ncache->addr = 0;\r\n}\r\ncache->id = id;\r\ncache->addr = addr & ~(u64)(cache->size - 1);\r\nif (cpp->op->area_init) {\r\nerr = cpp->op->area_init(cache->area,\r\nid, cache->addr, cache->size);\r\nif (err < 0) {\r\nmutex_unlock(&cpp->area_cache_mutex);\r\nreturn NULL;\r\n}\r\n}\r\nerr = nfp_cpp_area_acquire(cache->area);\r\nif (err < 0) {\r\nmutex_unlock(&cpp->area_cache_mutex);\r\nreturn NULL;\r\n}\r\nexit:\r\n*offset = addr - cache->addr;\r\nreturn cache;\r\n}\r\nstatic void\r\narea_cache_put(struct nfp_cpp *cpp, struct nfp_cpp_area_cache *cache)\r\n{\r\nif (!cache)\r\nreturn;\r\nlist_del(&cache->entry);\r\nlist_add(&cache->entry, &cpp->area_cache_list);\r\nmutex_unlock(&cpp->area_cache_mutex);\r\n}\r\nstatic int __nfp_cpp_read(struct nfp_cpp *cpp, u32 destination,\r\nunsigned long long address, void *kernel_vaddr,\r\nsize_t length)\r\n{\r\nstruct nfp_cpp_area_cache *cache;\r\nstruct nfp_cpp_area *area;\r\nunsigned long offset = 0;\r\nint err;\r\ncache = area_cache_get(cpp, destination, address, &offset, length);\r\nif (cache) {\r\narea = cache->area;\r\n} else {\r\narea = nfp_cpp_area_alloc(cpp, destination, address, length);\r\nif (!area)\r\nreturn -ENOMEM;\r\nerr = nfp_cpp_area_acquire(area);\r\nif (err) {\r\nnfp_cpp_area_free(area);\r\nreturn err;\r\n}\r\n}\r\nerr = nfp_cpp_area_read(area, offset, kernel_vaddr, length);\r\nif (cache)\r\narea_cache_put(cpp, cache);\r\nelse\r\nnfp_cpp_area_release_free(area);\r\nreturn err;\r\n}\r\nint nfp_cpp_read(struct nfp_cpp *cpp, u32 destination,\r\nunsigned long long address, void *kernel_vaddr,\r\nsize_t length)\r\n{\r\nsize_t n, offset;\r\nint ret;\r\nfor (offset = 0; offset < length; offset += n) {\r\nunsigned long long r_addr = address + offset;\r\nn = min_t(size_t, length - offset,\r\nALIGN(r_addr + 1, NFP_CPP_SAFE_AREA_SIZE) - r_addr);\r\nret = __nfp_cpp_read(cpp, destination, address + offset,\r\nkernel_vaddr + offset, n);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != n)\r\nreturn offset + n;\r\n}\r\nreturn length;\r\n}\r\nstatic int __nfp_cpp_write(struct nfp_cpp *cpp, u32 destination,\r\nunsigned long long address,\r\nconst void *kernel_vaddr, size_t length)\r\n{\r\nstruct nfp_cpp_area_cache *cache;\r\nstruct nfp_cpp_area *area;\r\nunsigned long offset = 0;\r\nint err;\r\ncache = area_cache_get(cpp, destination, address, &offset, length);\r\nif (cache) {\r\narea = cache->area;\r\n} else {\r\narea = nfp_cpp_area_alloc(cpp, destination, address, length);\r\nif (!area)\r\nreturn -ENOMEM;\r\nerr = nfp_cpp_area_acquire(area);\r\nif (err) {\r\nnfp_cpp_area_free(area);\r\nreturn err;\r\n}\r\n}\r\nerr = nfp_cpp_area_write(area, offset, kernel_vaddr, length);\r\nif (cache)\r\narea_cache_put(cpp, cache);\r\nelse\r\nnfp_cpp_area_release_free(area);\r\nreturn err;\r\n}\r\nint nfp_cpp_write(struct nfp_cpp *cpp, u32 destination,\r\nunsigned long long address,\r\nconst void *kernel_vaddr, size_t length)\r\n{\r\nsize_t n, offset;\r\nint ret;\r\nfor (offset = 0; offset < length; offset += n) {\r\nunsigned long long w_addr = address + offset;\r\nn = min_t(size_t, length - offset,\r\nALIGN(w_addr + 1, NFP_CPP_SAFE_AREA_SIZE) - w_addr);\r\nret = __nfp_cpp_write(cpp, destination, address + offset,\r\nkernel_vaddr + offset, n);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != n)\r\nreturn offset + n;\r\n}\r\nreturn length;\r\n}\r\nstatic u32 nfp_xpb_to_cpp(struct nfp_cpp *cpp, u32 *xpb_addr)\r\n{\r\nint island;\r\nu32 xpb;\r\nxpb = NFP_CPP_ID(14, NFP_CPP_ACTION_RW, 0);\r\nisland = (*xpb_addr >> 24) & 0x3f;\r\nif (!island)\r\nreturn xpb;\r\nif (island != 1) {\r\n*xpb_addr |= 1 << 30;\r\nreturn xpb;\r\n}\r\n*xpb_addr &= ~0x7f000000;\r\nif (*xpb_addr < 0x60000) {\r\n*xpb_addr |= 1 << 30;\r\n} else {\r\nif (NFP_CPP_INTERFACE_TYPE_of(nfp_cpp_interface(cpp))\r\n!= NFP_CPP_INTERFACE_TYPE_ARM)\r\n*xpb_addr |= 1 << 24;\r\n}\r\nreturn xpb;\r\n}\r\nint nfp_xpb_readl(struct nfp_cpp *cpp, u32 xpb_addr, u32 *value)\r\n{\r\nu32 cpp_dest = nfp_xpb_to_cpp(cpp, &xpb_addr);\r\nreturn nfp_cpp_readl(cpp, cpp_dest, xpb_addr, value);\r\n}\r\nint nfp_xpb_writel(struct nfp_cpp *cpp, u32 xpb_addr, u32 value)\r\n{\r\nu32 cpp_dest = nfp_xpb_to_cpp(cpp, &xpb_addr);\r\nreturn nfp_cpp_writel(cpp, cpp_dest, xpb_addr, value);\r\n}\r\nint nfp_xpb_writelm(struct nfp_cpp *cpp, u32 xpb_tgt,\r\nu32 mask, u32 value)\r\n{\r\nint err;\r\nu32 tmp;\r\nerr = nfp_xpb_readl(cpp, xpb_tgt, &tmp);\r\nif (err < 0)\r\nreturn err;\r\ntmp &= ~mask;\r\ntmp |= mask & value;\r\nreturn nfp_xpb_writel(cpp, xpb_tgt, tmp);\r\n}\r\nstatic void nfp_cpp_dev_release(struct device *dev)\r\n{\r\n}\r\nstruct nfp_cpp *\r\nnfp_cpp_from_operations(const struct nfp_cpp_operations *ops,\r\nstruct device *parent, void *priv)\r\n{\r\nconst u32 arm = NFP_CPP_ID(NFP_CPP_TARGET_ARM, NFP_CPP_ACTION_RW, 0);\r\nstruct nfp_cpp *cpp;\r\nu32 mask[2];\r\nu32 xpbaddr;\r\nsize_t tgt;\r\nint err;\r\ncpp = kzalloc(sizeof(*cpp), GFP_KERNEL);\r\nif (!cpp) {\r\nerr = -ENOMEM;\r\ngoto err_malloc;\r\n}\r\ncpp->op = ops;\r\ncpp->priv = priv;\r\ncpp->interface = ops->get_interface(parent);\r\nif (ops->read_serial)\r\nops->read_serial(parent, cpp->serial);\r\nrwlock_init(&cpp->resource_lock);\r\ninit_waitqueue_head(&cpp->waitq);\r\nlockdep_set_class(&cpp->resource_lock, &nfp_cpp_resource_lock_key);\r\nINIT_LIST_HEAD(&cpp->resource_list);\r\nINIT_LIST_HEAD(&cpp->area_cache_list);\r\nmutex_init(&cpp->area_cache_mutex);\r\ncpp->dev.init_name = "cpp";\r\ncpp->dev.parent = parent;\r\ncpp->dev.release = nfp_cpp_dev_release;\r\nerr = device_register(&cpp->dev);\r\nif (err < 0) {\r\nput_device(&cpp->dev);\r\ngoto err_dev;\r\n}\r\ndev_set_drvdata(&cpp->dev, cpp);\r\nif (cpp->op->init) {\r\nerr = cpp->op->init(cpp);\r\nif (err < 0) {\r\ndev_err(parent,\r\n"NFP interface initialization failed\n");\r\ngoto err_out;\r\n}\r\n}\r\nerr = nfp_cpp_model_autodetect(cpp, &cpp->model);\r\nif (err < 0) {\r\ndev_err(parent, "NFP model detection failed\n");\r\ngoto err_out;\r\n}\r\nfor (tgt = 0; tgt < ARRAY_SIZE(cpp->imb_cat_table); tgt++) {\r\nxpbaddr = 0x000a0000 + (tgt * 4);\r\nerr = nfp_xpb_readl(cpp, xpbaddr,\r\n&cpp->imb_cat_table[tgt]);\r\nif (err < 0) {\r\ndev_err(parent,\r\n"Can't read CPP mapping from device\n");\r\ngoto err_out;\r\n}\r\n}\r\nnfp_cpp_readl(cpp, arm, NFP_ARM_GCSR + NFP_ARM_GCSR_SOFTMODEL2,\r\n&mask[0]);\r\nnfp_cpp_readl(cpp, arm, NFP_ARM_GCSR + NFP_ARM_GCSR_SOFTMODEL3,\r\n&mask[1]);\r\ndev_info(cpp->dev.parent, "Model: 0x%08x, SN: %pM, Ifc: 0x%04x\n",\r\nnfp_cpp_model(cpp), cpp->serial, nfp_cpp_interface(cpp));\r\nreturn cpp;\r\nerr_out:\r\ndevice_unregister(&cpp->dev);\r\nerr_dev:\r\nkfree(cpp);\r\nerr_malloc:\r\nreturn ERR_PTR(err);\r\n}\r\nvoid *nfp_cpp_priv(struct nfp_cpp *cpp)\r\n{\r\nreturn cpp->priv;\r\n}\r\nstruct device *nfp_cpp_device(struct nfp_cpp *cpp)\r\n{\r\nreturn &cpp->dev;\r\n}\r\nstruct nfp_cpp_explicit *nfp_cpp_explicit_acquire(struct nfp_cpp *cpp)\r\n{\r\nstruct nfp_cpp_explicit *expl;\r\nint err;\r\nexpl = kzalloc(sizeof(*expl) + cpp->op->explicit_priv_size, GFP_KERNEL);\r\nif (!expl)\r\nreturn NULL;\r\nexpl->cpp = cpp;\r\nerr = NFP_EXPL_OP(explicit_acquire, expl);\r\nif (err < 0) {\r\nkfree(expl);\r\nreturn NULL;\r\n}\r\nreturn expl;\r\n}\r\nint nfp_cpp_explicit_set_target(struct nfp_cpp_explicit *expl,\r\nu32 cpp_id, u8 len, u8 mask)\r\n{\r\nexpl->cmd.cpp_id = cpp_id;\r\nexpl->cmd.len = len;\r\nexpl->cmd.byte_mask = mask;\r\nreturn 0;\r\n}\r\nint nfp_cpp_explicit_set_data(struct nfp_cpp_explicit *expl,\r\nu8 data_master, u16 data_ref)\r\n{\r\nexpl->cmd.data_master = data_master;\r\nexpl->cmd.data_ref = data_ref;\r\nreturn 0;\r\n}\r\nint nfp_cpp_explicit_set_signal(struct nfp_cpp_explicit *expl,\r\nu8 signal_master, u8 signal_ref)\r\n{\r\nexpl->cmd.signal_master = signal_master;\r\nexpl->cmd.signal_ref = signal_ref;\r\nreturn 0;\r\n}\r\nint nfp_cpp_explicit_set_posted(struct nfp_cpp_explicit *expl, int posted,\r\nu8 siga,\r\nenum nfp_cpp_explicit_signal_mode siga_mode,\r\nu8 sigb,\r\nenum nfp_cpp_explicit_signal_mode sigb_mode)\r\n{\r\nexpl->cmd.posted = posted;\r\nexpl->cmd.siga = siga;\r\nexpl->cmd.sigb = sigb;\r\nexpl->cmd.siga_mode = siga_mode;\r\nexpl->cmd.sigb_mode = sigb_mode;\r\nreturn 0;\r\n}\r\nint nfp_cpp_explicit_put(struct nfp_cpp_explicit *expl,\r\nconst void *buff, size_t len)\r\n{\r\nreturn NFP_EXPL_OP(explicit_put, expl, buff, len);\r\n}\r\nint nfp_cpp_explicit_do(struct nfp_cpp_explicit *expl, u64 address)\r\n{\r\nreturn NFP_EXPL_OP(explicit_do, expl, &expl->cmd, address);\r\n}\r\nint nfp_cpp_explicit_get(struct nfp_cpp_explicit *expl, void *buff, size_t len)\r\n{\r\nreturn NFP_EXPL_OP(explicit_get, expl, buff, len);\r\n}\r\nvoid nfp_cpp_explicit_release(struct nfp_cpp_explicit *expl)\r\n{\r\nNFP_EXPL_OP_NR(explicit_release, expl);\r\nkfree(expl);\r\n}\r\nstruct nfp_cpp *nfp_cpp_explicit_cpp(struct nfp_cpp_explicit *cpp_explicit)\r\n{\r\nreturn cpp_explicit->cpp;\r\n}\r\nvoid *nfp_cpp_explicit_priv(struct nfp_cpp_explicit *cpp_explicit)\r\n{\r\nreturn &cpp_explicit[1];\r\n}
