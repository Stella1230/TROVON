static int orion_mdio_wait_ready(const struct orion_mdio_ops *ops,\r\nstruct mii_bus *bus)\r\n{\r\nstruct orion_mdio_dev *dev = bus->priv;\r\nunsigned long timeout = usecs_to_jiffies(MVMDIO_SMI_TIMEOUT);\r\nunsigned long end = jiffies + timeout;\r\nint timedout = 0;\r\nwhile (1) {\r\nif (ops->is_done(dev))\r\nreturn 0;\r\nelse if (timedout)\r\nbreak;\r\nif (dev->err_interrupt <= 0) {\r\nusleep_range(ops->poll_interval_min,\r\nops->poll_interval_max);\r\nif (time_is_before_jiffies(end))\r\n++timedout;\r\n} else {\r\nif (timeout < 2)\r\ntimeout = 2;\r\nwait_event_timeout(dev->smi_busy_wait,\r\nops->is_done(dev), timeout);\r\n++timedout;\r\n}\r\n}\r\ndev_err(bus->parent, "Timeout: SMI busy for too long\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int orion_mdio_smi_is_done(struct orion_mdio_dev *dev)\r\n{\r\nreturn !(readl(dev->regs) & MVMDIO_SMI_BUSY);\r\n}\r\nstatic int orion_mdio_smi_read(struct mii_bus *bus, int mii_id,\r\nint regnum)\r\n{\r\nstruct orion_mdio_dev *dev = bus->priv;\r\nu32 val;\r\nint ret;\r\nif (regnum & MII_ADDR_C45)\r\nreturn -EOPNOTSUPP;\r\nret = orion_mdio_wait_ready(&orion_mdio_smi_ops, bus);\r\nif (ret < 0)\r\nreturn ret;\r\nwritel(((mii_id << MVMDIO_SMI_PHY_ADDR_SHIFT) |\r\n(regnum << MVMDIO_SMI_PHY_REG_SHIFT) |\r\nMVMDIO_SMI_READ_OPERATION),\r\ndev->regs);\r\nret = orion_mdio_wait_ready(&orion_mdio_smi_ops, bus);\r\nif (ret < 0)\r\nreturn ret;\r\nval = readl(dev->regs);\r\nif (!(val & MVMDIO_SMI_READ_VALID)) {\r\ndev_err(bus->parent, "SMI bus read not valid\n");\r\nreturn -ENODEV;\r\n}\r\nreturn val & GENMASK(15, 0);\r\n}\r\nstatic int orion_mdio_smi_write(struct mii_bus *bus, int mii_id,\r\nint regnum, u16 value)\r\n{\r\nstruct orion_mdio_dev *dev = bus->priv;\r\nint ret;\r\nif (regnum & MII_ADDR_C45)\r\nreturn -EOPNOTSUPP;\r\nret = orion_mdio_wait_ready(&orion_mdio_smi_ops, bus);\r\nif (ret < 0)\r\nreturn ret;\r\nwritel(((mii_id << MVMDIO_SMI_PHY_ADDR_SHIFT) |\r\n(regnum << MVMDIO_SMI_PHY_REG_SHIFT) |\r\nMVMDIO_SMI_WRITE_OPERATION |\r\n(value << MVMDIO_SMI_DATA_SHIFT)),\r\ndev->regs);\r\nreturn 0;\r\n}\r\nstatic int orion_mdio_xsmi_is_done(struct orion_mdio_dev *dev)\r\n{\r\nreturn !(readl(dev->regs + MVMDIO_XSMI_MGNT_REG) & MVMDIO_XSMI_BUSY);\r\n}\r\nstatic int orion_mdio_xsmi_read(struct mii_bus *bus, int mii_id,\r\nint regnum)\r\n{\r\nstruct orion_mdio_dev *dev = bus->priv;\r\nu16 dev_addr = (regnum >> 16) & GENMASK(4, 0);\r\nint ret;\r\nif (!(regnum & MII_ADDR_C45))\r\nreturn -EOPNOTSUPP;\r\nret = orion_mdio_wait_ready(&orion_mdio_xsmi_ops, bus);\r\nif (ret < 0)\r\nreturn ret;\r\nwritel(regnum & GENMASK(15, 0), dev->regs + MVMDIO_XSMI_ADDR_REG);\r\nwritel((mii_id << MVMDIO_XSMI_PHYADDR_SHIFT) |\r\n(dev_addr << MVMDIO_XSMI_DEVADDR_SHIFT) |\r\nMVMDIO_XSMI_READ_OPERATION,\r\ndev->regs + MVMDIO_XSMI_MGNT_REG);\r\nret = orion_mdio_wait_ready(&orion_mdio_xsmi_ops, bus);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(readl(dev->regs + MVMDIO_XSMI_MGNT_REG) &\r\nMVMDIO_XSMI_READ_VALID)) {\r\ndev_err(bus->parent, "XSMI bus read not valid\n");\r\nreturn -ENODEV;\r\n}\r\nreturn readl(dev->regs + MVMDIO_XSMI_MGNT_REG) & GENMASK(15, 0);\r\n}\r\nstatic int orion_mdio_xsmi_write(struct mii_bus *bus, int mii_id,\r\nint regnum, u16 value)\r\n{\r\nstruct orion_mdio_dev *dev = bus->priv;\r\nu16 dev_addr = (regnum >> 16) & GENMASK(4, 0);\r\nint ret;\r\nif (!(regnum & MII_ADDR_C45))\r\nreturn -EOPNOTSUPP;\r\nret = orion_mdio_wait_ready(&orion_mdio_xsmi_ops, bus);\r\nif (ret < 0)\r\nreturn ret;\r\nwritel(regnum & GENMASK(15, 0), dev->regs + MVMDIO_XSMI_ADDR_REG);\r\nwritel((mii_id << MVMDIO_XSMI_PHYADDR_SHIFT) |\r\n(dev_addr << MVMDIO_XSMI_DEVADDR_SHIFT) |\r\nMVMDIO_XSMI_WRITE_OPERATION | value,\r\ndev->regs + MVMDIO_XSMI_MGNT_REG);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t orion_mdio_err_irq(int irq, void *dev_id)\r\n{\r\nstruct orion_mdio_dev *dev = dev_id;\r\nif (readl(dev->regs + MVMDIO_ERR_INT_CAUSE) &\r\nMVMDIO_ERR_INT_SMI_DONE) {\r\nwritel(~MVMDIO_ERR_INT_SMI_DONE,\r\ndev->regs + MVMDIO_ERR_INT_CAUSE);\r\nwake_up(&dev->smi_busy_wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int orion_mdio_probe(struct platform_device *pdev)\r\n{\r\nenum orion_mdio_bus_type type;\r\nstruct resource *r;\r\nstruct mii_bus *bus;\r\nstruct orion_mdio_dev *dev;\r\nint i, ret;\r\ntype = (enum orion_mdio_bus_type)of_device_get_match_data(&pdev->dev);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "No SMI register address given\n");\r\nreturn -ENODEV;\r\n}\r\nbus = devm_mdiobus_alloc_size(&pdev->dev,\r\nsizeof(struct orion_mdio_dev));\r\nif (!bus)\r\nreturn -ENOMEM;\r\nswitch (type) {\r\ncase BUS_TYPE_SMI:\r\nbus->read = orion_mdio_smi_read;\r\nbus->write = orion_mdio_smi_write;\r\nbreak;\r\ncase BUS_TYPE_XSMI:\r\nbus->read = orion_mdio_xsmi_read;\r\nbus->write = orion_mdio_xsmi_write;\r\nbreak;\r\n}\r\nbus->name = "orion_mdio_bus";\r\nsnprintf(bus->id, MII_BUS_ID_SIZE, "%s-mii",\r\ndev_name(&pdev->dev));\r\nbus->parent = &pdev->dev;\r\ndev = bus->priv;\r\ndev->regs = devm_ioremap(&pdev->dev, r->start, resource_size(r));\r\nif (!dev->regs) {\r\ndev_err(&pdev->dev, "Unable to remap SMI register\n");\r\nreturn -ENODEV;\r\n}\r\ninit_waitqueue_head(&dev->smi_busy_wait);\r\nfor (i = 0; i < ARRAY_SIZE(dev->clk); i++) {\r\ndev->clk[i] = of_clk_get(pdev->dev.of_node, i);\r\nif (IS_ERR(dev->clk[i]))\r\nbreak;\r\nclk_prepare_enable(dev->clk[i]);\r\n}\r\ndev->err_interrupt = platform_get_irq(pdev, 0);\r\nif (dev->err_interrupt > 0 &&\r\nresource_size(r) < MVMDIO_ERR_INT_MASK + 4) {\r\ndev_err(&pdev->dev,\r\n"disabling interrupt, resource size is too small\n");\r\ndev->err_interrupt = 0;\r\n}\r\nif (dev->err_interrupt > 0) {\r\nret = devm_request_irq(&pdev->dev, dev->err_interrupt,\r\norion_mdio_err_irq,\r\nIRQF_SHARED, pdev->name, dev);\r\nif (ret)\r\ngoto out_mdio;\r\nwritel(MVMDIO_ERR_INT_SMI_DONE,\r\ndev->regs + MVMDIO_ERR_INT_MASK);\r\n} else if (dev->err_interrupt == -EPROBE_DEFER) {\r\nreturn -EPROBE_DEFER;\r\n}\r\nif (pdev->dev.of_node)\r\nret = of_mdiobus_register(bus, pdev->dev.of_node);\r\nelse\r\nret = mdiobus_register(bus);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Cannot register MDIO bus (%d)\n", ret);\r\ngoto out_mdio;\r\n}\r\nplatform_set_drvdata(pdev, bus);\r\nreturn 0;\r\nout_mdio:\r\nif (dev->err_interrupt > 0)\r\nwritel(0, dev->regs + MVMDIO_ERR_INT_MASK);\r\nfor (i = 0; i < ARRAY_SIZE(dev->clk); i++) {\r\nif (IS_ERR(dev->clk[i]))\r\nbreak;\r\nclk_disable_unprepare(dev->clk[i]);\r\nclk_put(dev->clk[i]);\r\n}\r\nreturn ret;\r\n}\r\nstatic int orion_mdio_remove(struct platform_device *pdev)\r\n{\r\nstruct mii_bus *bus = platform_get_drvdata(pdev);\r\nstruct orion_mdio_dev *dev = bus->priv;\r\nint i;\r\nif (dev->err_interrupt > 0)\r\nwritel(0, dev->regs + MVMDIO_ERR_INT_MASK);\r\nmdiobus_unregister(bus);\r\nfor (i = 0; i < ARRAY_SIZE(dev->clk); i++) {\r\nif (IS_ERR(dev->clk[i]))\r\nbreak;\r\nclk_disable_unprepare(dev->clk[i]);\r\nclk_put(dev->clk[i]);\r\n}\r\nreturn 0;\r\n}
