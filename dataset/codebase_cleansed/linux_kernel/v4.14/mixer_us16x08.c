static int snd_us16x08_recv_urb(struct snd_usb_audio *chip,\r\nunsigned char *buf, int size)\r\n{\r\nmutex_lock(&chip->mutex);\r\nsnd_usb_ctl_msg(chip->dev,\r\nusb_rcvctrlpipe(chip->dev, 0),\r\nSND_US16X08_URB_METER_REQUEST,\r\nSND_US16X08_URB_METER_REQUESTTYPE, 0, 0, buf, size);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int snd_us16x08_send_urb(struct snd_usb_audio *chip, char *buf, int size)\r\n{\r\nreturn snd_usb_ctl_msg(chip->dev, usb_sndctrlpipe(chip->dev, 0),\r\nSND_US16X08_URB_REQUEST, SND_US16X08_URB_REQUESTTYPE,\r\n0, 0, buf, size);\r\n}\r\nstatic int snd_us16x08_route_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nreturn snd_ctl_enum_info(uinfo, 1, 10, route_names);\r\n}\r\nstatic int snd_us16x08_route_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nint index = ucontrol->id.index;\r\nucontrol->value.enumerated.item[0] = elem->cache_val[index];\r\nreturn 0;\r\n}\r\nstatic int snd_us16x08_route_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nstruct snd_usb_audio *chip = elem->head.mixer->chip;\r\nint index = ucontrol->id.index;\r\nchar buf[sizeof(route_msg)];\r\nint val, val_org, err;\r\nval = ucontrol->value.enumerated.item[0];\r\nif (val < 0 || val > 9)\r\nreturn -EINVAL;\r\nmemcpy(buf, route_msg, sizeof(route_msg));\r\nif (val < 2) {\r\nval_org = val;\r\nbuf[2] = 0x02;\r\n} else {\r\nbuf[2] = 0x03;\r\nval_org = val - 2;\r\n}\r\nbuf[5] = (unsigned char) (val_org & 0x0f) + 1;\r\nbuf[13] = index + 1;\r\nerr = snd_us16x08_send_urb(chip, buf, sizeof(route_msg));\r\nif (err > 0) {\r\nelem->cached |= 1 << index;\r\nelem->cache_val[index] = val;\r\n} else {\r\nusb_audio_dbg(chip, "Failed to set routing, err:%d\n", err);\r\n}\r\nreturn err > 0 ? 1 : 0;\r\n}\r\nstatic int snd_us16x08_master_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->count = 1;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->value.integer.max = SND_US16X08_KCMAX(kcontrol);\r\nuinfo->value.integer.min = SND_US16X08_KCMIN(kcontrol);\r\nuinfo->value.integer.step = SND_US16X08_KCSTEP(kcontrol);\r\nreturn 0;\r\n}\r\nstatic int snd_us16x08_master_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nint index = ucontrol->id.index;\r\nucontrol->value.integer.value[0] = elem->cache_val[index];\r\nreturn 0;\r\n}\r\nstatic int snd_us16x08_master_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nstruct snd_usb_audio *chip = elem->head.mixer->chip;\r\nchar buf[sizeof(mix_msg_out)];\r\nint val, err;\r\nint index = ucontrol->id.index;\r\nval = ucontrol->value.integer.value[0];\r\nif (val < SND_US16X08_KCMIN(kcontrol)\r\n|| val > SND_US16X08_KCMAX(kcontrol))\r\nreturn -EINVAL;\r\nmemcpy(buf, mix_msg_out, sizeof(mix_msg_out));\r\nbuf[8] = val - SND_US16X08_KCBIAS(kcontrol);\r\nbuf[6] = elem->head.id;\r\nbuf[5] = index + 1;\r\nerr = snd_us16x08_send_urb(chip, buf, sizeof(mix_msg_out));\r\nif (err > 0) {\r\nelem->cached |= 1 << index;\r\nelem->cache_val[index] = val;\r\n} else {\r\nusb_audio_dbg(chip, "Failed to set master, err:%d\n", err);\r\n}\r\nreturn err > 0 ? 1 : 0;\r\n}\r\nstatic int snd_us16x08_bus_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nstruct snd_usb_audio *chip = elem->head.mixer->chip;\r\nchar buf[sizeof(mix_msg_out)];\r\nint val, err = 0;\r\nval = ucontrol->value.integer.value[0];\r\nswitch (elem->head.id) {\r\ncase SND_US16X08_ID_BYPASS:\r\nmemcpy(buf, bypass_msg_out, sizeof(bypass_msg_out));\r\nbuf[2] = val;\r\nerr = snd_us16x08_send_urb(chip, buf, sizeof(bypass_msg_out));\r\nbreak;\r\ncase SND_US16X08_ID_BUSS_OUT:\r\nmemcpy(buf, bus_msg_out, sizeof(bus_msg_out));\r\nbuf[2] = val;\r\nerr = snd_us16x08_send_urb(chip, buf, sizeof(bus_msg_out));\r\nbreak;\r\ncase SND_US16X08_ID_MUTE:\r\nmemcpy(buf, mix_msg_out, sizeof(mix_msg_out));\r\nbuf[8] = val;\r\nbuf[6] = elem->head.id;\r\nbuf[5] = 1;\r\nerr = snd_us16x08_send_urb(chip, buf, sizeof(mix_msg_out));\r\nbreak;\r\n}\r\nif (err > 0) {\r\nelem->cached |= 1;\r\nelem->cache_val[0] = val;\r\n} else {\r\nusb_audio_dbg(chip, "Failed to set buss param, err:%d\n", err);\r\n}\r\nreturn err > 0 ? 1 : 0;\r\n}\r\nstatic int snd_us16x08_bus_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nswitch (elem->head.id) {\r\ncase SND_US16X08_ID_BUSS_OUT:\r\nucontrol->value.integer.value[0] = elem->cache_val[0];\r\nbreak;\r\ncase SND_US16X08_ID_BYPASS:\r\nucontrol->value.integer.value[0] = elem->cache_val[0];\r\nbreak;\r\ncase SND_US16X08_ID_MUTE:\r\nucontrol->value.integer.value[0] = elem->cache_val[0];\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_us16x08_channel_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nint index = ucontrol->id.index;\r\nucontrol->value.integer.value[0] = elem->cache_val[index];\r\nreturn 0;\r\n}\r\nstatic int snd_us16x08_channel_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nstruct snd_usb_audio *chip = elem->head.mixer->chip;\r\nchar buf[sizeof(mix_msg_in)];\r\nint val, err;\r\nint index = ucontrol->id.index;\r\nval = ucontrol->value.integer.value[0];\r\nif (val < SND_US16X08_KCMIN(kcontrol)\r\n|| val > SND_US16X08_KCMAX(kcontrol))\r\nreturn -EINVAL;\r\nmemcpy(buf, mix_msg_in, sizeof(mix_msg_in));\r\nbuf[8] = val - SND_US16X08_KCBIAS(kcontrol);\r\nbuf[6] = elem->head.id;\r\nbuf[5] = index + 1;\r\nerr = snd_us16x08_send_urb(chip, buf, sizeof(mix_msg_in));\r\nif (err > 0) {\r\nelem->cached |= 1 << index;\r\nelem->cache_val[index] = val;\r\n} else {\r\nusb_audio_dbg(chip, "Failed to set channel, err:%d\n", err);\r\n}\r\nreturn err > 0 ? 1 : 0;\r\n}\r\nstatic int snd_us16x08_mix_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->count = 1;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->value.integer.max = SND_US16X08_KCMAX(kcontrol);\r\nuinfo->value.integer.min = SND_US16X08_KCMIN(kcontrol);\r\nuinfo->value.integer.step = SND_US16X08_KCSTEP(kcontrol);\r\nreturn 0;\r\n}\r\nstatic int snd_us16x08_comp_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nstruct snd_us16x08_comp_store *store = elem->private_data;\r\nint index = ucontrol->id.index;\r\nint val_idx = COMP_STORE_IDX(elem->head.id);\r\nucontrol->value.integer.value[0] = store->val[val_idx][index];\r\nreturn 0;\r\n}\r\nstatic int snd_us16x08_comp_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nstruct snd_usb_audio *chip = elem->head.mixer->chip;\r\nstruct snd_us16x08_comp_store *store = elem->private_data;\r\nint index = ucontrol->id.index;\r\nchar buf[sizeof(comp_msg)];\r\nint val_idx, val;\r\nint err;\r\nval = ucontrol->value.integer.value[0];\r\nif (val < SND_US16X08_KCMIN(kcontrol)\r\n|| val > SND_US16X08_KCMAX(kcontrol))\r\nreturn -EINVAL;\r\nval_idx = elem->head.id - SND_US16X08_ID_COMP_BASE;\r\nstore->val[val_idx][index] = ucontrol->value.integer.value[0];\r\nmemcpy(buf, comp_msg, sizeof(comp_msg));\r\nbuf[8] = store->val[\r\nCOMP_STORE_IDX(SND_US16X08_ID_COMP_THRESHOLD)][index]\r\n- SND_US16X08_COMP_THRESHOLD_BIAS;\r\nbuf[11] = ratio_map[store->val[\r\nCOMP_STORE_IDX(SND_US16X08_ID_COMP_RATIO)][index]];\r\nbuf[14] = store->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_ATTACK)][index]\r\n+ SND_US16X08_COMP_ATTACK_BIAS;\r\nbuf[17] = store->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_RELEASE)][index]\r\n+ SND_US16X08_COMP_RELEASE_BIAS;\r\nbuf[20] = store->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_GAIN)][index];\r\nbuf[26] = store->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_SWITCH)][index];\r\nbuf[5] = index + 1;\r\nerr = snd_us16x08_send_urb(chip, buf, sizeof(comp_msg));\r\nif (err > 0) {\r\nelem->cached |= 1 << index;\r\nelem->cache_val[index] = val;\r\n} else {\r\nusb_audio_dbg(chip, "Failed to set compressor, err:%d\n", err);\r\n}\r\nreturn 1;\r\n}\r\nstatic int snd_us16x08_eqswitch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint val;\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nstruct snd_us16x08_eq_store *store = elem->private_data;\r\nint index = ucontrol->id.index;\r\nval = store->val[EQ_STORE_BAND_IDX(elem->head.id)]\r\n[EQ_STORE_PARAM_IDX(elem->head.id)][index];\r\nucontrol->value.integer.value[0] = val;\r\nreturn 0;\r\n}\r\nstatic int snd_us16x08_eqswitch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nstruct snd_usb_audio *chip = elem->head.mixer->chip;\r\nstruct snd_us16x08_eq_store *store = elem->private_data;\r\nint index = ucontrol->id.index;\r\nchar buf[sizeof(eqs_msq)];\r\nint val, err = 0;\r\nint b_idx;\r\nval = ucontrol->value.integer.value[0] + SND_US16X08_KCBIAS(kcontrol);\r\nmemcpy(buf, eqs_msq, sizeof(eqs_msq));\r\nbuf[5] = index + 1;\r\nfor (b_idx = 0; b_idx < SND_US16X08_ID_EQ_BAND_COUNT; b_idx++) {\r\nbuf[20] = val;\r\nbuf[17] = store->val[b_idx][2][index];\r\nbuf[14] = store->val[b_idx][1][index];\r\nbuf[11] = store->val[b_idx][0][index];\r\nbuf[8] = b_idx + 1;\r\nerr = snd_us16x08_send_urb(chip, buf, sizeof(eqs_msq));\r\nif (err < 0)\r\nbreak;\r\nstore->val[b_idx][3][index] = val;\r\nmsleep(15);\r\n}\r\nif (err > 0) {\r\nelem->cached |= 1 << index;\r\nelem->cache_val[index] = val;\r\n} else {\r\nusb_audio_dbg(chip, "Failed to set eq switch, err:%d\n", err);\r\n}\r\nreturn 1;\r\n}\r\nstatic int snd_us16x08_eq_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint val;\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nstruct snd_us16x08_eq_store *store = elem->private_data;\r\nint index = ucontrol->id.index;\r\nint b_idx = EQ_STORE_BAND_IDX(elem->head.id) - 1;\r\nint p_idx = EQ_STORE_PARAM_IDX(elem->head.id);\r\nval = store->val[b_idx][p_idx][index];\r\nucontrol->value.integer.value[0] = val;\r\nreturn 0;\r\n}\r\nstatic int snd_us16x08_eq_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nstruct snd_usb_audio *chip = elem->head.mixer->chip;\r\nstruct snd_us16x08_eq_store *store = elem->private_data;\r\nint index = ucontrol->id.index;\r\nchar buf[sizeof(eqs_msq)];\r\nint val, err;\r\nint b_idx = EQ_STORE_BAND_IDX(elem->head.id) - 1;\r\nint p_idx = EQ_STORE_PARAM_IDX(elem->head.id);\r\nval = ucontrol->value.integer.value[0];\r\nif (val < SND_US16X08_KCMIN(kcontrol)\r\n|| val > SND_US16X08_KCMAX(kcontrol))\r\nreturn -EINVAL;\r\nmemcpy(buf, eqs_msq, sizeof(eqs_msq));\r\nstore->val[b_idx][p_idx][index] = val;\r\nbuf[20] = store->val[b_idx][3][index];\r\nbuf[17] = store->val[b_idx][2][index];\r\nbuf[14] = store->val[b_idx][1][index];\r\nbuf[11] = store->val[b_idx][0][index];\r\nbuf[5] = index + 1;\r\nbuf[8] = b_idx + 1;\r\nerr = snd_us16x08_send_urb(chip, buf, sizeof(eqs_msq));\r\nif (err > 0) {\r\nelem->cached |= 1 << index;\r\nelem->cache_val[index] = val;\r\n} else {\r\nusb_audio_dbg(chip, "Failed to set eq param, err:%d\n", err);\r\n}\r\nreturn 1;\r\n}\r\nstatic int snd_us16x08_meter_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->count = 1;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->value.integer.max = 0x7FFF;\r\nuinfo->value.integer.min = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_get_meter_comp_index(struct snd_us16x08_meter_store *store)\r\n{\r\nint ret;\r\nif (store->comp_active_index) {\r\nif (store->comp_active_index & 0x20) {\r\nif (store->comp_index -\r\nstore->comp_active_index > 1)\r\nstore->comp_index =\r\nstore->comp_active_index;\r\nret = store->comp_index++ & 0x1F;\r\n} else {\r\nret = store->comp_active_index;\r\n}\r\n} else {\r\nwhile (!store->comp_store->val[\r\nCOMP_STORE_IDX(SND_US16X08_ID_COMP_SWITCH)]\r\n[store->comp_index - 1]\r\n&& store->comp_index <= SND_US16X08_MAX_CHANNELS) {\r\nstore->comp_index++;\r\n}\r\nret = store->comp_index++;\r\nif (store->comp_index > SND_US16X08_MAX_CHANNELS)\r\nstore->comp_index = 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic void get_meter_levels_from_urb(int s,\r\nstruct snd_us16x08_meter_store *store,\r\nu8 *meter_urb)\r\n{\r\nint val = MUC2(meter_urb, s) + (MUC3(meter_urb, s) << 8);\r\nif (MUA0(meter_urb, s) == 0x61 && MUA1(meter_urb, s) == 0x02 &&\r\nMUA2(meter_urb, s) == 0x04 && MUB0(meter_urb, s) == 0x62) {\r\nif (MUC0(meter_urb, s) == 0x72)\r\nstore->meter_level[MUB2(meter_urb, s) - 1] = val;\r\nif (MUC0(meter_urb, s) == 0xb2)\r\nstore->comp_level[MUB2(meter_urb, s) - 1] = val;\r\n}\r\nif (MUA0(meter_urb, s) == 0x61 && MUA1(meter_urb, s) == 0x02 &&\r\nMUA2(meter_urb, s) == 0x02 && MUB0(meter_urb, s) == 0x62)\r\nstore->master_level[MUB2(meter_urb, s) - 1] = val;\r\n}\r\nstatic int snd_us16x08_meter_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint i, set;\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nstruct snd_usb_audio *chip = elem->head.mixer->chip;\r\nstruct snd_us16x08_meter_store *store = elem->private_data;\r\nu8 meter_urb[64];\r\nswitch (kcontrol->private_value) {\r\ncase 0: {\r\nchar tmp[sizeof(mix_init_msg1)];\r\nmemcpy(tmp, mix_init_msg1, sizeof(mix_init_msg1));\r\nsnd_us16x08_send_urb(chip, tmp, 4);\r\nsnd_us16x08_recv_urb(chip, meter_urb,\r\nsizeof(meter_urb));\r\nkcontrol->private_value++;\r\nbreak;\r\n}\r\ncase 1:\r\nsnd_us16x08_recv_urb(chip, meter_urb,\r\nsizeof(meter_urb));\r\nkcontrol->private_value++;\r\nbreak;\r\ncase 2:\r\nsnd_us16x08_recv_urb(chip, meter_urb,\r\nsizeof(meter_urb));\r\nkcontrol->private_value++;\r\nbreak;\r\ncase 3: {\r\nchar tmp[sizeof(mix_init_msg2)];\r\nmemcpy(tmp, mix_init_msg2, sizeof(mix_init_msg2));\r\ntmp[2] = snd_get_meter_comp_index(store);\r\nsnd_us16x08_send_urb(chip, tmp, 10);\r\nsnd_us16x08_recv_urb(chip, meter_urb,\r\nsizeof(meter_urb));\r\nkcontrol->private_value = 0;\r\nbreak;\r\n}\r\n}\r\nfor (set = 0; set < 6; set++)\r\nget_meter_levels_from_urb(set, store, meter_urb);\r\nfor (i = 0; i < SND_US16X08_MAX_CHANNELS; i++) {\r\nucontrol->value.integer.value[i] =\r\nstore ? store->meter_level[i] : 0;\r\n}\r\nucontrol->value.integer.value[i++] = store ? store->master_level[0] : 0;\r\nucontrol->value.integer.value[i++] = store ? store->master_level[1] : 0;\r\nfor (i = 2; i < SND_US16X08_MAX_CHANNELS + 2; i++)\r\nucontrol->value.integer.value[i + SND_US16X08_MAX_CHANNELS] =\r\nstore ? store->comp_level[i - 2] : 0;\r\nreturn 1;\r\n}\r\nstatic int snd_us16x08_meter_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kcontrol->private_data;\r\nstruct snd_us16x08_meter_store *store = elem->private_data;\r\nint val;\r\nval = ucontrol->value.integer.value[0];\r\nif (val < 0 || val >= SND_US16X08_MAX_CHANNELS)\r\nreturn -EINVAL;\r\nstore->comp_active_index = val;\r\nstore->comp_index = val;\r\nreturn 1;\r\n}\r\nstatic struct snd_us16x08_comp_store *snd_us16x08_create_comp_store(void)\r\n{\r\nint i;\r\nstruct snd_us16x08_comp_store *tmp;\r\ntmp = kmalloc(sizeof(*tmp), GFP_KERNEL);\r\nif (!tmp)\r\nreturn NULL;\r\nfor (i = 0; i < SND_US16X08_MAX_CHANNELS; i++) {\r\ntmp->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_THRESHOLD)][i]\r\n= 0x20;\r\ntmp->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_RATIO)][i] = 0x00;\r\ntmp->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_GAIN)][i] = 0x00;\r\ntmp->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_SWITCH)][i] = 0x00;\r\ntmp->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_ATTACK)][i] = 0x00;\r\ntmp->val[COMP_STORE_IDX(SND_US16X08_ID_COMP_RELEASE)][i] = 0x00;\r\n}\r\nreturn tmp;\r\n}\r\nstatic struct snd_us16x08_eq_store *snd_us16x08_create_eq_store(void)\r\n{\r\nint i, b_idx;\r\nstruct snd_us16x08_eq_store *tmp;\r\ntmp = kmalloc(sizeof(*tmp), GFP_KERNEL);\r\nif (!tmp)\r\nreturn NULL;\r\nfor (i = 0; i < SND_US16X08_MAX_CHANNELS; i++) {\r\nfor (b_idx = 0; b_idx < SND_US16X08_ID_EQ_BAND_COUNT; b_idx++) {\r\ntmp->val[b_idx][0][i] = 0x0c;\r\ntmp->val[b_idx][3][i] = 0x00;\r\nswitch (b_idx) {\r\ncase 0:\r\ntmp->val[b_idx][1][i] = 0x05;\r\ntmp->val[b_idx][2][i] = 0xff;\r\nbreak;\r\ncase 1:\r\ntmp->val[b_idx][1][i] = 0x0e;\r\ntmp->val[b_idx][2][i] = 0x02;\r\nbreak;\r\ncase 2:\r\ntmp->val[b_idx][1][i] = 0x1b;\r\ntmp->val[b_idx][2][i] = 0x02;\r\nbreak;\r\ncase 3:\r\ntmp->val[b_idx][1][i] = 0x2f\r\n- SND_US16X08_EQ_HIGHFREQ_BIAS;\r\ntmp->val[b_idx][2][i] = 0xff;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn tmp;\r\n}\r\nstatic struct snd_us16x08_meter_store *snd_us16x08_create_meter_store(void)\r\n{\r\nstruct snd_us16x08_meter_store *tmp;\r\ntmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\r\nif (!tmp)\r\nreturn NULL;\r\ntmp->comp_index = 1;\r\ntmp->comp_active_index = 0;\r\nreturn tmp;\r\n}\r\nstatic void elem_private_free(struct snd_kcontrol *kctl)\r\n{\r\nstruct usb_mixer_elem_info *elem = kctl->private_data;\r\nif (elem)\r\nkfree(elem->private_data);\r\nkfree(elem);\r\nkctl->private_data = NULL;\r\n}\r\nstatic int add_new_ctl(struct usb_mixer_interface *mixer,\r\nconst struct snd_kcontrol_new *ncontrol,\r\nint index, int val_type, int channels,\r\nconst char *name, void *opt,\r\nbool do_private_free,\r\nstruct usb_mixer_elem_info **elem_ret)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nstruct usb_mixer_elem_info *elem;\r\nint err;\r\nusb_audio_dbg(mixer->chip, "us16x08 add mixer %s\n", name);\r\nelem = kzalloc(sizeof(*elem), GFP_KERNEL);\r\nif (!elem)\r\nreturn -ENOMEM;\r\nelem->head.mixer = mixer;\r\nelem->head.resume = NULL;\r\nelem->control = 0;\r\nelem->idx_off = 0;\r\nelem->head.id = index;\r\nelem->val_type = val_type;\r\nelem->channels = channels;\r\nelem->private_data = opt;\r\nkctl = snd_ctl_new1(ncontrol, elem);\r\nif (!kctl) {\r\nkfree(elem);\r\nreturn -ENOMEM;\r\n}\r\nif (do_private_free)\r\nkctl->private_free = elem_private_free;\r\nelse\r\nkctl->private_free = snd_usb_mixer_elem_free;\r\nstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\r\nerr = snd_usb_mixer_add_control(&elem->head, kctl);\r\nif (err < 0)\r\nreturn err;\r\nif (elem_ret)\r\n*elem_ret = elem;\r\nreturn 0;\r\n}\r\nint snd_us16x08_controls_create(struct usb_mixer_interface *mixer)\r\n{\r\nint i, j;\r\nint err;\r\nstruct usb_mixer_elem_info *elem;\r\nstruct snd_us16x08_comp_store *comp_store;\r\nstruct snd_us16x08_meter_store *meter_store;\r\nstruct snd_us16x08_eq_store *eq_store;\r\nif (mixer->hostif->desc.bInterfaceNumber == 3) {\r\nerr = add_new_ctl(mixer, &snd_us16x08_route_ctl,\r\nSND_US16X08_ID_ROUTE, USB_MIXER_U8, 8, "Line Out Route",\r\nNULL, false, &elem);\r\nif (err < 0) {\r\nusb_audio_dbg(mixer->chip,\r\n"Failed to create route control, err:%d\n",\r\nerr);\r\nreturn err;\r\n}\r\nfor (i = 0; i < 8; i++)\r\nelem->cache_val[i] = i < 2 ? i : i + 2;\r\nelem->cached = 0xff;\r\ncomp_store = snd_us16x08_create_comp_store();\r\nif (!comp_store)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(master_controls); i++) {\r\nerr = add_new_ctl(mixer,\r\nmaster_controls[i].kcontrol_new,\r\nmaster_controls[i].control_id,\r\nmaster_controls[i].type,\r\nmaster_controls[i].num_channels,\r\nmaster_controls[i].name,\r\ncomp_store,\r\ni == 0,\r\n&elem);\r\nif (err < 0)\r\nreturn err;\r\nelem->cache_val[0] = master_controls[i].default_val;\r\nelem->cached = 1;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(channel_controls); i++) {\r\nerr = add_new_ctl(mixer,\r\nchannel_controls[i].kcontrol_new,\r\nchannel_controls[i].control_id,\r\nchannel_controls[i].type,\r\nchannel_controls[i].num_channels,\r\nchannel_controls[i].name,\r\ncomp_store,\r\nfalse, &elem);\r\nif (err < 0)\r\nreturn err;\r\nfor (j = 0; j < SND_US16X08_MAX_CHANNELS; j++) {\r\nelem->cache_val[j] =\r\nchannel_controls[i].default_val;\r\n}\r\nelem->cached = 0xffff;\r\n}\r\neq_store = snd_us16x08_create_eq_store();\r\nif (!eq_store)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(eq_controls); i++) {\r\nerr = add_new_ctl(mixer,\r\neq_controls[i].kcontrol_new,\r\neq_controls[i].control_id,\r\neq_controls[i].type,\r\neq_controls[i].num_channels,\r\neq_controls[i].name,\r\neq_store,\r\ni == 0,\r\nNULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(comp_controls); i++) {\r\nerr = add_new_ctl(mixer,\r\ncomp_controls[i].kcontrol_new,\r\ncomp_controls[i].control_id,\r\ncomp_controls[i].type,\r\ncomp_controls[i].num_channels,\r\ncomp_controls[i].name,\r\ncomp_store,\r\nfalse, NULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nmeter_store = snd_us16x08_create_meter_store();\r\nif (!meter_store)\r\nreturn -ENOMEM;\r\nmeter_store->comp_store = comp_store;\r\nerr = add_new_ctl(mixer, &snd_us16x08_meter_ctl,\r\nSND_US16X08_ID_METER, USB_MIXER_U16, 0, "Level Meter",\r\nmeter_store, true, NULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
