bool verity_fec_is_enabled(struct dm_verity *v)\r\n{\r\nreturn v->fec && v->fec->dev;\r\n}\r\nstatic inline struct dm_verity_fec_io *fec_io(struct dm_verity_io *io)\r\n{\r\nreturn (struct dm_verity_fec_io *) verity_io_digest_end(io->v, io);\r\n}\r\nstatic inline u64 fec_interleave(struct dm_verity *v, u64 offset)\r\n{\r\nu32 mod;\r\nmod = do_div(offset, v->fec->rsn);\r\nreturn offset + mod * (v->fec->rounds << v->data_dev_block_bits);\r\n}\r\nstatic int fec_decode_rs8(struct dm_verity *v, struct dm_verity_fec_io *fio,\r\nu8 *data, u8 *fec, int neras)\r\n{\r\nint i;\r\nuint16_t par[DM_VERITY_FEC_RSM - DM_VERITY_FEC_MIN_RSN];\r\nfor (i = 0; i < v->fec->roots; i++)\r\npar[i] = fec[i];\r\nreturn decode_rs8(fio->rs, data, par, v->fec->rsn, NULL, neras,\r\nfio->erasures, 0, NULL);\r\n}\r\nstatic u8 *fec_read_parity(struct dm_verity *v, u64 rsb, int index,\r\nunsigned *offset, struct dm_buffer **buf)\r\n{\r\nu64 position, block;\r\nu8 *res;\r\nposition = (index + rsb) * v->fec->roots;\r\nblock = position >> v->data_dev_block_bits;\r\n*offset = (unsigned)(position - (block << v->data_dev_block_bits));\r\nres = dm_bufio_read(v->fec->bufio, v->fec->start + block, buf);\r\nif (unlikely(IS_ERR(res))) {\r\nDMERR("%s: FEC %llu: parity read failed (block %llu): %ld",\r\nv->data_dev->name, (unsigned long long)rsb,\r\n(unsigned long long)(v->fec->start + block),\r\nPTR_ERR(res));\r\n*buf = NULL;\r\n}\r\nreturn res;\r\n}\r\nstatic inline u8 *fec_buffer_rs_block(struct dm_verity *v,\r\nstruct dm_verity_fec_io *fio,\r\nunsigned i, unsigned j)\r\n{\r\nreturn &fio->bufs[i][j * v->fec->rsn];\r\n}\r\nstatic inline unsigned fec_buffer_rs_index(unsigned i, unsigned j)\r\n{\r\nreturn (i << DM_VERITY_FEC_BUF_RS_BITS) + j;\r\n}\r\nstatic int fec_decode_bufs(struct dm_verity *v, struct dm_verity_fec_io *fio,\r\nu64 rsb, int byte_index, unsigned block_offset,\r\nint neras)\r\n{\r\nint r, corrected = 0, res;\r\nstruct dm_buffer *buf;\r\nunsigned n, i, offset;\r\nu8 *par, *block;\r\npar = fec_read_parity(v, rsb, block_offset, &offset, &buf);\r\nif (IS_ERR(par))\r\nreturn PTR_ERR(par);\r\nfec_for_each_buffer_rs_block(fio, n, i) {\r\nblock = fec_buffer_rs_block(v, fio, n, i);\r\nres = fec_decode_rs8(v, fio, block, &par[offset], neras);\r\nif (res < 0) {\r\nr = res;\r\ngoto error;\r\n}\r\ncorrected += res;\r\nfio->output[block_offset] = block[byte_index];\r\nblock_offset++;\r\nif (block_offset >= 1 << v->data_dev_block_bits)\r\ngoto done;\r\noffset += v->fec->roots;\r\nif (offset >= 1 << v->data_dev_block_bits) {\r\ndm_bufio_release(buf);\r\npar = fec_read_parity(v, rsb, block_offset, &offset, &buf);\r\nif (unlikely(IS_ERR(par)))\r\nreturn PTR_ERR(par);\r\n}\r\n}\r\ndone:\r\nr = corrected;\r\nerror:\r\ndm_bufio_release(buf);\r\nif (r < 0 && neras)\r\nDMERR_LIMIT("%s: FEC %llu: failed to correct: %d",\r\nv->data_dev->name, (unsigned long long)rsb, r);\r\nelse if (r > 0)\r\nDMWARN_LIMIT("%s: FEC %llu: corrected %d errors",\r\nv->data_dev->name, (unsigned long long)rsb, r);\r\nreturn r;\r\n}\r\nstatic int fec_is_erasure(struct dm_verity *v, struct dm_verity_io *io,\r\nu8 *want_digest, u8 *data)\r\n{\r\nif (unlikely(verity_hash(v, verity_io_hash_req(v, io),\r\ndata, 1 << v->data_dev_block_bits,\r\nverity_io_real_digest(v, io))))\r\nreturn 0;\r\nreturn memcmp(verity_io_real_digest(v, io), want_digest,\r\nv->digest_size) != 0;\r\n}\r\nstatic int fec_read_bufs(struct dm_verity *v, struct dm_verity_io *io,\r\nu64 rsb, u64 target, unsigned block_offset,\r\nint *neras)\r\n{\r\nbool is_zero;\r\nint i, j, target_index = -1;\r\nstruct dm_buffer *buf;\r\nstruct dm_bufio_client *bufio;\r\nstruct dm_verity_fec_io *fio = fec_io(io);\r\nu64 block, ileaved;\r\nu8 *bbuf, *rs_block;\r\nu8 want_digest[v->digest_size];\r\nunsigned n, k;\r\nif (neras)\r\n*neras = 0;\r\nfor (i = 0; i < v->fec->rsn; i++) {\r\nileaved = fec_interleave(v, rsb * v->fec->rsn + i);\r\nif (ileaved == target)\r\ntarget_index = i;\r\nblock = ileaved >> v->data_dev_block_bits;\r\nbufio = v->fec->data_bufio;\r\nif (block >= v->data_blocks) {\r\nblock -= v->data_blocks;\r\nif (unlikely(block >= v->fec->hash_blocks))\r\ncontinue;\r\nblock += v->hash_start;\r\nbufio = v->bufio;\r\n}\r\nbbuf = dm_bufio_read(bufio, block, &buf);\r\nif (unlikely(IS_ERR(bbuf))) {\r\nDMWARN_LIMIT("%s: FEC %llu: read failed (%llu): %ld",\r\nv->data_dev->name,\r\n(unsigned long long)rsb,\r\n(unsigned long long)block, PTR_ERR(bbuf));\r\nif (neras && *neras <= v->fec->roots)\r\nfio->erasures[(*neras)++] = i;\r\ncontinue;\r\n}\r\nif (bufio == v->fec->data_bufio &&\r\nverity_hash_for_block(v, io, block, want_digest,\r\n&is_zero) == 0) {\r\nif (is_zero)\r\ngoto done;\r\nif (neras && *neras <= v->fec->roots &&\r\nfec_is_erasure(v, io, want_digest, bbuf))\r\nfio->erasures[(*neras)++] = i;\r\n}\r\nfec_for_each_buffer_rs_block(fio, n, j) {\r\nk = fec_buffer_rs_index(n, j) + block_offset;\r\nif (k >= 1 << v->data_dev_block_bits)\r\ngoto done;\r\nrs_block = fec_buffer_rs_block(v, fio, n, j);\r\nrs_block[i] = bbuf[k];\r\n}\r\ndone:\r\ndm_bufio_release(buf);\r\n}\r\nreturn target_index;\r\n}\r\nstatic int fec_alloc_bufs(struct dm_verity *v, struct dm_verity_fec_io *fio)\r\n{\r\nunsigned n;\r\nif (!fio->rs)\r\nfio->rs = mempool_alloc(v->fec->rs_pool, GFP_NOIO);\r\nfec_for_each_prealloc_buffer(n) {\r\nif (fio->bufs[n])\r\ncontinue;\r\nfio->bufs[n] = mempool_alloc(v->fec->prealloc_pool, GFP_NOWAIT);\r\nif (unlikely(!fio->bufs[n])) {\r\nDMERR("failed to allocate FEC buffer");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfec_for_each_extra_buffer(fio, n) {\r\nif (fio->bufs[n])\r\ncontinue;\r\nfio->bufs[n] = mempool_alloc(v->fec->extra_pool, GFP_NOWAIT);\r\nif (unlikely(!fio->bufs[n]))\r\nbreak;\r\n}\r\nfio->nbufs = n;\r\nif (!fio->output)\r\nfio->output = mempool_alloc(v->fec->output_pool, GFP_NOIO);\r\nreturn 0;\r\n}\r\nstatic void fec_init_bufs(struct dm_verity *v, struct dm_verity_fec_io *fio)\r\n{\r\nunsigned n;\r\nfec_for_each_buffer(fio, n)\r\nmemset(fio->bufs[n], 0, v->fec->rsn << DM_VERITY_FEC_BUF_RS_BITS);\r\nmemset(fio->erasures, 0, sizeof(fio->erasures));\r\n}\r\nstatic int fec_decode_rsb(struct dm_verity *v, struct dm_verity_io *io,\r\nstruct dm_verity_fec_io *fio, u64 rsb, u64 offset,\r\nbool use_erasures)\r\n{\r\nint r, neras = 0;\r\nunsigned pos;\r\nr = fec_alloc_bufs(v, fio);\r\nif (unlikely(r < 0))\r\nreturn r;\r\nfor (pos = 0; pos < 1 << v->data_dev_block_bits; ) {\r\nfec_init_bufs(v, fio);\r\nr = fec_read_bufs(v, io, rsb, offset, pos,\r\nuse_erasures ? &neras : NULL);\r\nif (unlikely(r < 0))\r\nreturn r;\r\nr = fec_decode_bufs(v, fio, rsb, r, pos, neras);\r\nif (r < 0)\r\nreturn r;\r\npos += fio->nbufs << DM_VERITY_FEC_BUF_RS_BITS;\r\n}\r\nr = verity_hash(v, verity_io_hash_req(v, io), fio->output,\r\n1 << v->data_dev_block_bits,\r\nverity_io_real_digest(v, io));\r\nif (unlikely(r < 0))\r\nreturn r;\r\nif (memcmp(verity_io_real_digest(v, io), verity_io_want_digest(v, io),\r\nv->digest_size)) {\r\nDMERR_LIMIT("%s: FEC %llu: failed to correct (%d erasures)",\r\nv->data_dev->name, (unsigned long long)rsb, neras);\r\nreturn -EILSEQ;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fec_bv_copy(struct dm_verity *v, struct dm_verity_io *io, u8 *data,\r\nsize_t len)\r\n{\r\nstruct dm_verity_fec_io *fio = fec_io(io);\r\nmemcpy(data, &fio->output[fio->output_pos], len);\r\nfio->output_pos += len;\r\nreturn 0;\r\n}\r\nint verity_fec_decode(struct dm_verity *v, struct dm_verity_io *io,\r\nenum verity_block_type type, sector_t block, u8 *dest,\r\nstruct bvec_iter *iter)\r\n{\r\nint r;\r\nstruct dm_verity_fec_io *fio = fec_io(io);\r\nu64 offset, res, rsb;\r\nif (!verity_fec_is_enabled(v))\r\nreturn -EOPNOTSUPP;\r\nif (fio->level >= DM_VERITY_FEC_MAX_RECURSION) {\r\nDMWARN_LIMIT("%s: FEC: recursion too deep", v->data_dev->name);\r\nreturn -EIO;\r\n}\r\nfio->level++;\r\nif (type == DM_VERITY_BLOCK_TYPE_METADATA)\r\nblock += v->data_blocks;\r\noffset = block << v->data_dev_block_bits;\r\nres = div64_u64(offset, v->fec->rounds << v->data_dev_block_bits);\r\nrsb = offset - res * (v->fec->rounds << v->data_dev_block_bits);\r\nr = fec_decode_rsb(v, io, fio, rsb, offset, false);\r\nif (r < 0) {\r\nr = fec_decode_rsb(v, io, fio, rsb, offset, true);\r\nif (r < 0)\r\ngoto done;\r\n}\r\nif (dest)\r\nmemcpy(dest, fio->output, 1 << v->data_dev_block_bits);\r\nelse if (iter) {\r\nfio->output_pos = 0;\r\nr = verity_for_bv_block(v, io, iter, fec_bv_copy);\r\n}\r\ndone:\r\nfio->level--;\r\nreturn r;\r\n}\r\nvoid verity_fec_finish_io(struct dm_verity_io *io)\r\n{\r\nunsigned n;\r\nstruct dm_verity_fec *f = io->v->fec;\r\nstruct dm_verity_fec_io *fio = fec_io(io);\r\nif (!verity_fec_is_enabled(io->v))\r\nreturn;\r\nmempool_free(fio->rs, f->rs_pool);\r\nfec_for_each_prealloc_buffer(n)\r\nmempool_free(fio->bufs[n], f->prealloc_pool);\r\nfec_for_each_extra_buffer(fio, n)\r\nmempool_free(fio->bufs[n], f->extra_pool);\r\nmempool_free(fio->output, f->output_pool);\r\n}\r\nvoid verity_fec_init_io(struct dm_verity_io *io)\r\n{\r\nstruct dm_verity_fec_io *fio = fec_io(io);\r\nif (!verity_fec_is_enabled(io->v))\r\nreturn;\r\nfio->rs = NULL;\r\nmemset(fio->bufs, 0, sizeof(fio->bufs));\r\nfio->nbufs = 0;\r\nfio->output = NULL;\r\nfio->level = 0;\r\n}\r\nunsigned verity_fec_status_table(struct dm_verity *v, unsigned sz,\r\nchar *result, unsigned maxlen)\r\n{\r\nif (!verity_fec_is_enabled(v))\r\nreturn sz;\r\nDMEMIT(" " DM_VERITY_OPT_FEC_DEV " %s "\r\nDM_VERITY_OPT_FEC_BLOCKS " %llu "\r\nDM_VERITY_OPT_FEC_START " %llu "\r\nDM_VERITY_OPT_FEC_ROOTS " %d",\r\nv->fec->dev->name,\r\n(unsigned long long)v->fec->blocks,\r\n(unsigned long long)v->fec->start,\r\nv->fec->roots);\r\nreturn sz;\r\n}\r\nvoid verity_fec_dtr(struct dm_verity *v)\r\n{\r\nstruct dm_verity_fec *f = v->fec;\r\nif (!verity_fec_is_enabled(v))\r\ngoto out;\r\nmempool_destroy(f->rs_pool);\r\nmempool_destroy(f->prealloc_pool);\r\nmempool_destroy(f->extra_pool);\r\nkmem_cache_destroy(f->cache);\r\nif (f->data_bufio)\r\ndm_bufio_client_destroy(f->data_bufio);\r\nif (f->bufio)\r\ndm_bufio_client_destroy(f->bufio);\r\nif (f->dev)\r\ndm_put_device(v->ti, f->dev);\r\nout:\r\nkfree(f);\r\nv->fec = NULL;\r\n}\r\nstatic void *fec_rs_alloc(gfp_t gfp_mask, void *pool_data)\r\n{\r\nstruct dm_verity *v = (struct dm_verity *)pool_data;\r\nreturn init_rs(8, 0x11d, 0, 1, v->fec->roots);\r\n}\r\nstatic void fec_rs_free(void *element, void *pool_data)\r\n{\r\nstruct rs_control *rs = (struct rs_control *)element;\r\nif (rs)\r\nfree_rs(rs);\r\n}\r\nbool verity_is_fec_opt_arg(const char *arg_name)\r\n{\r\nreturn (!strcasecmp(arg_name, DM_VERITY_OPT_FEC_DEV) ||\r\n!strcasecmp(arg_name, DM_VERITY_OPT_FEC_BLOCKS) ||\r\n!strcasecmp(arg_name, DM_VERITY_OPT_FEC_START) ||\r\n!strcasecmp(arg_name, DM_VERITY_OPT_FEC_ROOTS));\r\n}\r\nint verity_fec_parse_opt_args(struct dm_arg_set *as, struct dm_verity *v,\r\nunsigned *argc, const char *arg_name)\r\n{\r\nint r;\r\nstruct dm_target *ti = v->ti;\r\nconst char *arg_value;\r\nunsigned long long num_ll;\r\nunsigned char num_c;\r\nchar dummy;\r\nif (!*argc) {\r\nti->error = "FEC feature arguments require a value";\r\nreturn -EINVAL;\r\n}\r\narg_value = dm_shift_arg(as);\r\n(*argc)--;\r\nif (!strcasecmp(arg_name, DM_VERITY_OPT_FEC_DEV)) {\r\nr = dm_get_device(ti, arg_value, FMODE_READ, &v->fec->dev);\r\nif (r) {\r\nti->error = "FEC device lookup failed";\r\nreturn r;\r\n}\r\n} else if (!strcasecmp(arg_name, DM_VERITY_OPT_FEC_BLOCKS)) {\r\nif (sscanf(arg_value, "%llu%c", &num_ll, &dummy) != 1 ||\r\n((sector_t)(num_ll << (v->data_dev_block_bits - SECTOR_SHIFT))\r\n>> (v->data_dev_block_bits - SECTOR_SHIFT) != num_ll)) {\r\nti->error = "Invalid " DM_VERITY_OPT_FEC_BLOCKS;\r\nreturn -EINVAL;\r\n}\r\nv->fec->blocks = num_ll;\r\n} else if (!strcasecmp(arg_name, DM_VERITY_OPT_FEC_START)) {\r\nif (sscanf(arg_value, "%llu%c", &num_ll, &dummy) != 1 ||\r\n((sector_t)(num_ll << (v->data_dev_block_bits - SECTOR_SHIFT)) >>\r\n(v->data_dev_block_bits - SECTOR_SHIFT) != num_ll)) {\r\nti->error = "Invalid " DM_VERITY_OPT_FEC_START;\r\nreturn -EINVAL;\r\n}\r\nv->fec->start = num_ll;\r\n} else if (!strcasecmp(arg_name, DM_VERITY_OPT_FEC_ROOTS)) {\r\nif (sscanf(arg_value, "%hhu%c", &num_c, &dummy) != 1 || !num_c ||\r\nnum_c < (DM_VERITY_FEC_RSM - DM_VERITY_FEC_MAX_RSN) ||\r\nnum_c > (DM_VERITY_FEC_RSM - DM_VERITY_FEC_MIN_RSN)) {\r\nti->error = "Invalid " DM_VERITY_OPT_FEC_ROOTS;\r\nreturn -EINVAL;\r\n}\r\nv->fec->roots = num_c;\r\n} else {\r\nti->error = "Unrecognized verity FEC feature request";\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint verity_fec_ctr_alloc(struct dm_verity *v)\r\n{\r\nstruct dm_verity_fec *f;\r\nf = kzalloc(sizeof(struct dm_verity_fec), GFP_KERNEL);\r\nif (!f) {\r\nv->ti->error = "Cannot allocate FEC structure";\r\nreturn -ENOMEM;\r\n}\r\nv->fec = f;\r\nreturn 0;\r\n}\r\nint verity_fec_ctr(struct dm_verity *v)\r\n{\r\nstruct dm_verity_fec *f = v->fec;\r\nstruct dm_target *ti = v->ti;\r\nu64 hash_blocks;\r\nif (!verity_fec_is_enabled(v)) {\r\nverity_fec_dtr(v);\r\nreturn 0;\r\n}\r\nhash_blocks = v->hash_blocks - v->hash_start;\r\nif (v->data_dev_block_bits != v->hash_dev_block_bits) {\r\nti->error = "Block sizes must match to use FEC";\r\nreturn -EINVAL;\r\n}\r\nif (!f->roots) {\r\nti->error = "Missing " DM_VERITY_OPT_FEC_ROOTS;\r\nreturn -EINVAL;\r\n}\r\nf->rsn = DM_VERITY_FEC_RSM - f->roots;\r\nif (!f->blocks) {\r\nti->error = "Missing " DM_VERITY_OPT_FEC_BLOCKS;\r\nreturn -EINVAL;\r\n}\r\nf->rounds = f->blocks;\r\nif (sector_div(f->rounds, f->rsn))\r\nf->rounds++;\r\nif (f->blocks < v->data_blocks + hash_blocks || !f->rounds) {\r\nti->error = "Invalid " DM_VERITY_OPT_FEC_BLOCKS;\r\nreturn -EINVAL;\r\n}\r\nf->hash_blocks = f->blocks - v->data_blocks;\r\nif (dm_bufio_get_device_size(v->bufio) < f->hash_blocks) {\r\nti->error = "Hash device is too small for "\r\nDM_VERITY_OPT_FEC_BLOCKS;\r\nreturn -E2BIG;\r\n}\r\nf->bufio = dm_bufio_client_create(f->dev->bdev,\r\n1 << v->data_dev_block_bits,\r\n1, 0, NULL, NULL);\r\nif (IS_ERR(f->bufio)) {\r\nti->error = "Cannot initialize FEC bufio client";\r\nreturn PTR_ERR(f->bufio);\r\n}\r\nif (dm_bufio_get_device_size(f->bufio) <\r\n((f->start + f->rounds * f->roots) >> v->data_dev_block_bits)) {\r\nti->error = "FEC device is too small";\r\nreturn -E2BIG;\r\n}\r\nf->data_bufio = dm_bufio_client_create(v->data_dev->bdev,\r\n1 << v->data_dev_block_bits,\r\n1, 0, NULL, NULL);\r\nif (IS_ERR(f->data_bufio)) {\r\nti->error = "Cannot initialize FEC data bufio client";\r\nreturn PTR_ERR(f->data_bufio);\r\n}\r\nif (dm_bufio_get_device_size(f->data_bufio) < v->data_blocks) {\r\nti->error = "Data device is too small";\r\nreturn -E2BIG;\r\n}\r\nf->rs_pool = mempool_create(num_online_cpus(), fec_rs_alloc,\r\nfec_rs_free, (void *) v);\r\nif (!f->rs_pool) {\r\nti->error = "Cannot allocate RS pool";\r\nreturn -ENOMEM;\r\n}\r\nf->cache = kmem_cache_create("dm_verity_fec_buffers",\r\nf->rsn << DM_VERITY_FEC_BUF_RS_BITS,\r\n0, 0, NULL);\r\nif (!f->cache) {\r\nti->error = "Cannot create FEC buffer cache";\r\nreturn -ENOMEM;\r\n}\r\nf->prealloc_pool = mempool_create_slab_pool(num_online_cpus() *\r\nDM_VERITY_FEC_BUF_PREALLOC,\r\nf->cache);\r\nif (!f->prealloc_pool) {\r\nti->error = "Cannot allocate FEC buffer prealloc pool";\r\nreturn -ENOMEM;\r\n}\r\nf->extra_pool = mempool_create_slab_pool(0, f->cache);\r\nif (!f->extra_pool) {\r\nti->error = "Cannot allocate FEC buffer extra pool";\r\nreturn -ENOMEM;\r\n}\r\nf->output_pool = mempool_create_kmalloc_pool(num_online_cpus(),\r\n1 << v->data_dev_block_bits);\r\nif (!f->output_pool) {\r\nti->error = "Cannot allocate FEC output pool";\r\nreturn -ENOMEM;\r\n}\r\nti->per_io_data_size += sizeof(struct dm_verity_fec_io);\r\nreturn 0;\r\n}
