static int get_atomisp_histogram32(struct atomisp_histogram *kp,\r\nstruct atomisp_histogram32 __user *up)\r\n{\r\ncompat_uptr_t tmp;\r\nif (!access_ok(VERIFY_READ, up, sizeof(struct atomisp_histogram32)) ||\r\nget_user(kp->num_elements, &up->num_elements) ||\r\nget_user(tmp, &up->data))\r\nreturn -EFAULT;\r\nkp->data = compat_ptr(tmp);\r\nreturn 0;\r\n}\r\nstatic int put_atomisp_histogram32(struct atomisp_histogram *kp,\r\nstruct atomisp_histogram32 __user *up)\r\n{\r\ncompat_uptr_t tmp = (compat_uptr_t)((uintptr_t)kp->data);\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(struct atomisp_histogram32)) ||\r\nput_user(kp->num_elements, &up->num_elements) ||\r\nput_user(tmp, &up->data))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic inline int get_v4l2_pix_format(struct v4l2_pix_format *kp,\r\nstruct v4l2_pix_format __user *up)\r\n{\r\nif (copy_from_user(kp, up, sizeof(struct v4l2_pix_format)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic inline int put_v4l2_pix_format(struct v4l2_pix_format *kp,\r\nstruct v4l2_pix_format __user *up)\r\n{\r\nif (copy_to_user(up, kp, sizeof(struct v4l2_pix_format)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_v4l2_framebuffer32(struct v4l2_framebuffer *kp,\r\nstruct v4l2_framebuffer32 __user *up)\r\n{\r\ncompat_uptr_t tmp;\r\nif (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_framebuffer32)) ||\r\nget_user(tmp, &up->base) ||\r\nget_user(kp->capability, &up->capability) ||\r\nget_user(kp->flags, &up->flags))\r\nreturn -EFAULT;\r\nkp->base = compat_ptr(tmp);\r\nget_v4l2_pix_format((struct v4l2_pix_format *)&kp->fmt, &up->fmt);\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_dis_statistics32(struct atomisp_dis_statistics *kp,\r\nstruct atomisp_dis_statistics32 __user *up)\r\n{\r\ncompat_uptr_t hor_prod_odd_real;\r\ncompat_uptr_t hor_prod_odd_imag;\r\ncompat_uptr_t hor_prod_even_real;\r\ncompat_uptr_t hor_prod_even_imag;\r\ncompat_uptr_t ver_prod_odd_real;\r\ncompat_uptr_t ver_prod_odd_imag;\r\ncompat_uptr_t ver_prod_even_real;\r\ncompat_uptr_t ver_prod_even_imag;\r\nif (!access_ok(VERIFY_READ, up,\r\nsizeof(struct atomisp_dis_statistics32)) ||\r\ncopy_from_user(kp, up, sizeof(struct atomisp_dvs_grid_info)) ||\r\nget_user(hor_prod_odd_real,\r\n&up->dvs2_stat.hor_prod.odd_real) ||\r\nget_user(hor_prod_odd_imag,\r\n&up->dvs2_stat.hor_prod.odd_imag) ||\r\nget_user(hor_prod_even_real,\r\n&up->dvs2_stat.hor_prod.even_real) ||\r\nget_user(hor_prod_even_imag,\r\n&up->dvs2_stat.hor_prod.even_imag) ||\r\nget_user(ver_prod_odd_real,\r\n&up->dvs2_stat.ver_prod.odd_real) ||\r\nget_user(ver_prod_odd_imag,\r\n&up->dvs2_stat.ver_prod.odd_imag) ||\r\nget_user(ver_prod_even_real,\r\n&up->dvs2_stat.ver_prod.even_real) ||\r\nget_user(ver_prod_even_imag,\r\n&up->dvs2_stat.ver_prod.even_imag) ||\r\nget_user(kp->exp_id, &up->exp_id))\r\nreturn -EFAULT;\r\nkp->dvs2_stat.hor_prod.odd_real = compat_ptr(hor_prod_odd_real);\r\nkp->dvs2_stat.hor_prod.odd_imag = compat_ptr(hor_prod_odd_imag);\r\nkp->dvs2_stat.hor_prod.even_real = compat_ptr(hor_prod_even_real);\r\nkp->dvs2_stat.hor_prod.even_imag = compat_ptr(hor_prod_even_imag);\r\nkp->dvs2_stat.ver_prod.odd_real = compat_ptr(ver_prod_odd_real);\r\nkp->dvs2_stat.ver_prod.odd_imag = compat_ptr(ver_prod_odd_imag);\r\nkp->dvs2_stat.ver_prod.even_real = compat_ptr(ver_prod_even_real);\r\nkp->dvs2_stat.ver_prod.even_imag = compat_ptr(ver_prod_even_imag);\r\nreturn 0;\r\n}\r\nstatic int put_atomisp_dis_statistics32(struct atomisp_dis_statistics *kp,\r\nstruct atomisp_dis_statistics32 __user *up)\r\n{\r\ncompat_uptr_t hor_prod_odd_real =\r\n(compat_uptr_t)((uintptr_t)kp->dvs2_stat.hor_prod.odd_real);\r\ncompat_uptr_t hor_prod_odd_imag =\r\n(compat_uptr_t)((uintptr_t)kp->dvs2_stat.hor_prod.odd_imag);\r\ncompat_uptr_t hor_prod_even_real =\r\n(compat_uptr_t)((uintptr_t)kp->dvs2_stat.hor_prod.even_real);\r\ncompat_uptr_t hor_prod_even_imag =\r\n(compat_uptr_t)((uintptr_t)kp->dvs2_stat.hor_prod.even_imag);\r\ncompat_uptr_t ver_prod_odd_real =\r\n(compat_uptr_t)((uintptr_t)kp->dvs2_stat.ver_prod.odd_real);\r\ncompat_uptr_t ver_prod_odd_imag =\r\n(compat_uptr_t)((uintptr_t)kp->dvs2_stat.ver_prod.odd_imag);\r\ncompat_uptr_t ver_prod_even_real =\r\n(compat_uptr_t)((uintptr_t)kp->dvs2_stat.ver_prod.even_real);\r\ncompat_uptr_t ver_prod_even_imag =\r\n(compat_uptr_t)((uintptr_t)kp->dvs2_stat.ver_prod.even_imag);\r\nif (!access_ok(VERIFY_WRITE, up,\r\nsizeof(struct atomisp_dis_statistics32)) ||\r\ncopy_to_user(up, kp, sizeof(struct atomisp_dvs_grid_info)) ||\r\nput_user(hor_prod_odd_real,\r\n&up->dvs2_stat.hor_prod.odd_real) ||\r\nput_user(hor_prod_odd_imag,\r\n&up->dvs2_stat.hor_prod.odd_imag) ||\r\nput_user(hor_prod_even_real,\r\n&up->dvs2_stat.hor_prod.even_real) ||\r\nput_user(hor_prod_even_imag,\r\n&up->dvs2_stat.hor_prod.even_imag) ||\r\nput_user(ver_prod_odd_real,\r\n&up->dvs2_stat.ver_prod.odd_real) ||\r\nput_user(ver_prod_odd_imag,\r\n&up->dvs2_stat.ver_prod.odd_imag) ||\r\nput_user(ver_prod_even_real,\r\n&up->dvs2_stat.ver_prod.even_real) ||\r\nput_user(ver_prod_even_imag,\r\n&up->dvs2_stat.ver_prod.even_imag) ||\r\nput_user(kp->exp_id, &up->exp_id))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_dis_coefficients32(struct atomisp_dis_coefficients *kp,\r\nstruct atomisp_dis_coefficients32 __user *up)\r\n{\r\ncompat_uptr_t hor_coefs_odd_real;\r\ncompat_uptr_t hor_coefs_odd_imag;\r\ncompat_uptr_t hor_coefs_even_real;\r\ncompat_uptr_t hor_coefs_even_imag;\r\ncompat_uptr_t ver_coefs_odd_real;\r\ncompat_uptr_t ver_coefs_odd_imag;\r\ncompat_uptr_t ver_coefs_even_real;\r\ncompat_uptr_t ver_coefs_even_imag;\r\nif (!access_ok(VERIFY_READ, up,\r\nsizeof(struct atomisp_dis_coefficients32)) ||\r\ncopy_from_user(kp, up, sizeof(struct atomisp_dvs_grid_info)) ||\r\nget_user(hor_coefs_odd_real, &up->hor_coefs.odd_real) ||\r\nget_user(hor_coefs_odd_imag, &up->hor_coefs.odd_imag) ||\r\nget_user(hor_coefs_even_real, &up->hor_coefs.even_real) ||\r\nget_user(hor_coefs_even_imag, &up->hor_coefs.even_imag) ||\r\nget_user(ver_coefs_odd_real, &up->ver_coefs.odd_real) ||\r\nget_user(ver_coefs_odd_imag, &up->ver_coefs.odd_imag) ||\r\nget_user(ver_coefs_even_real, &up->ver_coefs.even_real) ||\r\nget_user(ver_coefs_even_imag, &up->ver_coefs.even_imag))\r\nreturn -EFAULT;\r\nkp->hor_coefs.odd_real = compat_ptr(hor_coefs_odd_real);\r\nkp->hor_coefs.odd_imag = compat_ptr(hor_coefs_odd_imag);\r\nkp->hor_coefs.even_real = compat_ptr(hor_coefs_even_real);\r\nkp->hor_coefs.even_imag = compat_ptr(hor_coefs_even_imag);\r\nkp->ver_coefs.odd_real = compat_ptr(ver_coefs_odd_real);\r\nkp->ver_coefs.odd_imag = compat_ptr(ver_coefs_odd_imag);\r\nkp->ver_coefs.even_real = compat_ptr(ver_coefs_even_real);\r\nkp->ver_coefs.even_imag = compat_ptr(ver_coefs_even_imag);\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_dvs_6axis_config32(struct atomisp_dvs_6axis_config *kp,\r\nstruct atomisp_dvs_6axis_config32 __user *up)\r\n{ compat_uptr_t xcoords_y;\r\ncompat_uptr_t ycoords_y;\r\ncompat_uptr_t xcoords_uv;\r\ncompat_uptr_t ycoords_uv;\r\nif (!access_ok(VERIFY_READ, up,\r\nsizeof(struct atomisp_dvs_6axis_config32)) ||\r\nget_user(kp->exp_id, &up->exp_id) ||\r\nget_user(kp->width_y, &up->width_y) ||\r\nget_user(kp->height_y, &up->height_y) ||\r\nget_user(kp->width_uv, &up->width_uv) ||\r\nget_user(kp->height_uv, &up->height_uv) ||\r\nget_user(xcoords_y, &up->xcoords_y) ||\r\nget_user(ycoords_y, &up->ycoords_y) ||\r\nget_user(xcoords_uv, &up->xcoords_uv) ||\r\nget_user(ycoords_uv, &up->ycoords_uv))\r\nreturn -EFAULT;\r\nkp->xcoords_y = compat_ptr(xcoords_y);\r\nkp->ycoords_y = compat_ptr(ycoords_y);\r\nkp->xcoords_uv = compat_ptr(xcoords_uv);\r\nkp->ycoords_uv = compat_ptr(ycoords_uv);\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_3a_statistics32(struct atomisp_3a_statistics *kp,\r\nstruct atomisp_3a_statistics32 __user *up)\r\n{\r\ncompat_uptr_t data;\r\ncompat_uptr_t rgby_data;\r\nif (!access_ok(VERIFY_READ, up,\r\nsizeof(struct atomisp_3a_statistics32)) ||\r\ncopy_from_user(kp, up, sizeof(struct atomisp_grid_info)) ||\r\nget_user(rgby_data, &up->rgby_data) ||\r\nget_user(data, &up->data) ||\r\nget_user(kp->exp_id, &up->exp_id) ||\r\nget_user(kp->isp_config_id, &up->isp_config_id))\r\nreturn -EFAULT;\r\nkp->data = compat_ptr(data);\r\nkp->rgby_data = compat_ptr(rgby_data);\r\nreturn 0;\r\n}\r\nstatic int put_atomisp_3a_statistics32(struct atomisp_3a_statistics *kp,\r\nstruct atomisp_3a_statistics32 __user *up)\r\n{\r\ncompat_uptr_t data = (compat_uptr_t)((uintptr_t)kp->data);\r\ncompat_uptr_t rgby_data = (compat_uptr_t)((uintptr_t)kp->rgby_data);\r\nif (!access_ok(VERIFY_WRITE, up,\r\nsizeof(struct atomisp_3a_statistics32)) ||\r\ncopy_to_user(up, kp, sizeof(struct atomisp_grid_info)) ||\r\nput_user(rgby_data, &up->rgby_data) ||\r\nput_user(data, &up->data) ||\r\nput_user(kp->exp_id, &up->exp_id) ||\r\nput_user(kp->isp_config_id, &up->isp_config_id))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_metadata_stat32(struct atomisp_metadata *kp,\r\nstruct atomisp_metadata32 __user *up)\r\n{\r\ncompat_uptr_t data;\r\ncompat_uptr_t effective_width;\r\nif (!access_ok(VERIFY_READ, up,\r\nsizeof(struct atomisp_metadata32)) ||\r\nget_user(data, &up->data) ||\r\nget_user(kp->width, &up->width) ||\r\nget_user(kp->height, &up->height) ||\r\nget_user(kp->stride, &up->stride) ||\r\nget_user(kp->exp_id, &up->exp_id) ||\r\nget_user(effective_width, &up->effective_width))\r\nreturn -EFAULT;\r\nkp->data = compat_ptr(data);\r\nkp->effective_width = compat_ptr(effective_width);\r\nreturn 0;\r\n}\r\nstatic int put_atomisp_metadata_stat32(struct atomisp_metadata *kp,\r\nstruct atomisp_metadata32 __user *up)\r\n{\r\ncompat_uptr_t data = (compat_uptr_t)((uintptr_t)kp->data);\r\ncompat_uptr_t effective_width =\r\n(compat_uptr_t)((uintptr_t)kp->effective_width);\r\nif (!access_ok(VERIFY_WRITE, up,\r\nsizeof(struct atomisp_metadata32)) ||\r\nput_user(data, &up->data) ||\r\nput_user(kp->width, &up->width) ||\r\nput_user(kp->height, &up->height) ||\r\nput_user(kp->stride, &up->stride) ||\r\nput_user(kp->exp_id, &up->exp_id) ||\r\nput_user(effective_width, &up->effective_width))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int put_atomisp_metadata_by_type_stat32(\r\nstruct atomisp_metadata_with_type *kp,\r\nstruct atomisp_metadata_with_type32 __user *up)\r\n{\r\ncompat_uptr_t data = (compat_uptr_t)((uintptr_t)kp->data);\r\ncompat_uptr_t effective_width =\r\n(compat_uptr_t)((uintptr_t)kp->effective_width);\r\nif (!access_ok(VERIFY_WRITE, up,\r\nsizeof(struct atomisp_metadata_with_type32)) ||\r\nput_user(data, &up->data) ||\r\nput_user(kp->width, &up->width) ||\r\nput_user(kp->height, &up->height) ||\r\nput_user(kp->stride, &up->stride) ||\r\nput_user(kp->exp_id, &up->exp_id) ||\r\nput_user(effective_width, &up->effective_width) ||\r\nput_user(kp->type, &up->type))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_metadata_by_type_stat32(\r\nstruct atomisp_metadata_with_type *kp,\r\nstruct atomisp_metadata_with_type32 __user *up)\r\n{\r\ncompat_uptr_t data;\r\ncompat_uptr_t effective_width;\r\nif (!access_ok(VERIFY_READ, up,\r\nsizeof(struct atomisp_metadata_with_type32)) ||\r\nget_user(data, &up->data) ||\r\nget_user(kp->width, &up->width) ||\r\nget_user(kp->height, &up->height) ||\r\nget_user(kp->stride, &up->stride) ||\r\nget_user(kp->exp_id, &up->exp_id) ||\r\nget_user(effective_width, &up->effective_width) ||\r\nget_user(kp->type, &up->type))\r\nreturn -EFAULT;\r\nkp->data = compat_ptr(data);\r\nkp->effective_width = compat_ptr(effective_width);\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_morph_table32(struct atomisp_morph_table *kp,\r\nstruct atomisp_morph_table32 __user *up)\r\n{\r\nunsigned int n = ATOMISP_MORPH_TABLE_NUM_PLANES;\r\nif (!access_ok(VERIFY_READ, up,\r\nsizeof(struct atomisp_morph_table32)) ||\r\nget_user(kp->enabled, &up->enabled) ||\r\nget_user(kp->width, &up->width) ||\r\nget_user(kp->height, &up->height))\r\nreturn -EFAULT;\r\nwhile (n-- > 0) {\r\nuintptr_t *coord_kp = (uintptr_t *)&kp->coordinates_x[n];\r\nif (get_user((*coord_kp), &up->coordinates_x[n]))\r\nreturn -EFAULT;\r\ncoord_kp = (uintptr_t *)&kp->coordinates_y[n];\r\nif (get_user((*coord_kp), &up->coordinates_y[n]))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int put_atomisp_morph_table32(struct atomisp_morph_table *kp,\r\nstruct atomisp_morph_table32 __user *up)\r\n{\r\nunsigned int n = ATOMISP_MORPH_TABLE_NUM_PLANES;\r\nif (!access_ok(VERIFY_WRITE, up,\r\nsizeof(struct atomisp_morph_table32)) ||\r\nput_user(kp->enabled, &up->enabled) ||\r\nput_user(kp->width, &up->width) ||\r\nput_user(kp->height, &up->height))\r\nreturn -EFAULT;\r\nwhile (n-- > 0) {\r\nuintptr_t *coord_kp = (uintptr_t *)&kp->coordinates_x[n];\r\nif (put_user((*coord_kp), &up->coordinates_x[n]))\r\nreturn -EFAULT;\r\ncoord_kp = (uintptr_t *)&kp->coordinates_y[n];\r\nif (put_user((*coord_kp), &up->coordinates_y[n]))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_overlay32(struct atomisp_overlay *kp,\r\nstruct atomisp_overlay32 __user *up)\r\n{\r\ncompat_uptr_t frame;\r\nif (!access_ok(VERIFY_READ, up, sizeof(struct atomisp_overlay32)) ||\r\nget_user(frame, &up->frame) ||\r\nget_user(kp->bg_y, &up->bg_y) ||\r\nget_user(kp->bg_u, &up->bg_u) ||\r\nget_user(kp->bg_v, &up->bg_v) ||\r\nget_user(kp->blend_input_perc_y, &up->blend_input_perc_y) ||\r\nget_user(kp->blend_input_perc_u, &up->blend_input_perc_u) ||\r\nget_user(kp->blend_input_perc_v, &up->blend_input_perc_v) ||\r\nget_user(kp->blend_overlay_perc_y,\r\n&up->blend_overlay_perc_y) ||\r\nget_user(kp->blend_overlay_perc_u,\r\n&up->blend_overlay_perc_u) ||\r\nget_user(kp->blend_overlay_perc_v,\r\n&up->blend_overlay_perc_v) ||\r\nget_user(kp->blend_overlay_perc_u,\r\n&up->blend_overlay_perc_u) ||\r\nget_user(kp->overlay_start_x, &up->overlay_start_y))\r\nreturn -EFAULT;\r\nkp->frame = compat_ptr(frame);\r\nreturn 0;\r\n}\r\nstatic int put_atomisp_overlay32(struct atomisp_overlay *kp,\r\nstruct atomisp_overlay32 __user *up)\r\n{\r\ncompat_uptr_t frame = (compat_uptr_t)((uintptr_t)kp->frame);\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(struct atomisp_overlay32)) ||\r\nput_user(frame, &up->frame) ||\r\nput_user(kp->bg_y, &up->bg_y) ||\r\nput_user(kp->bg_u, &up->bg_u) ||\r\nput_user(kp->bg_v, &up->bg_v) ||\r\nput_user(kp->blend_input_perc_y, &up->blend_input_perc_y) ||\r\nput_user(kp->blend_input_perc_u, &up->blend_input_perc_u) ||\r\nput_user(kp->blend_input_perc_v, &up->blend_input_perc_v) ||\r\nput_user(kp->blend_overlay_perc_y,\r\n&up->blend_overlay_perc_y) ||\r\nput_user(kp->blend_overlay_perc_u,\r\n&up->blend_overlay_perc_u) ||\r\nput_user(kp->blend_overlay_perc_v,\r\n&up->blend_overlay_perc_v) ||\r\nput_user(kp->blend_overlay_perc_u,\r\n&up->blend_overlay_perc_u) ||\r\nput_user(kp->overlay_start_x, &up->overlay_start_y))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_calibration_group32(\r\nstruct atomisp_calibration_group *kp,\r\nstruct atomisp_calibration_group32 __user *up)\r\n{\r\ncompat_uptr_t calb_grp_values;\r\nif (!access_ok(VERIFY_READ, up,\r\nsizeof(struct atomisp_calibration_group32)) ||\r\nget_user(kp->size, &up->size) ||\r\nget_user(kp->type, &up->type) ||\r\nget_user(calb_grp_values, &up->calb_grp_values))\r\nreturn -EFAULT;\r\nkp->calb_grp_values = compat_ptr(calb_grp_values);\r\nreturn 0;\r\n}\r\nstatic int put_atomisp_calibration_group32(\r\nstruct atomisp_calibration_group *kp,\r\nstruct atomisp_calibration_group32 __user *up)\r\n{\r\ncompat_uptr_t calb_grp_values =\r\n(compat_uptr_t)((uintptr_t)kp->calb_grp_values);\r\nif (!access_ok(VERIFY_WRITE, up,\r\nsizeof(struct atomisp_calibration_group32)) ||\r\nput_user(kp->size, &up->size) ||\r\nput_user(kp->type, &up->type) ||\r\nput_user(calb_grp_values, &up->calb_grp_values))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_acc_fw_load32(struct atomisp_acc_fw_load *kp,\r\nstruct atomisp_acc_fw_load32 __user *up)\r\n{\r\ncompat_uptr_t data;\r\nif (!access_ok(VERIFY_READ, up,\r\nsizeof(struct atomisp_acc_fw_load32)) ||\r\nget_user(kp->size, &up->size) ||\r\nget_user(kp->fw_handle, &up->fw_handle) ||\r\nget_user(data, &up->data))\r\nreturn -EFAULT;\r\nkp->data = compat_ptr(data);\r\nreturn 0;\r\n}\r\nstatic int put_atomisp_acc_fw_load32(struct atomisp_acc_fw_load *kp,\r\nstruct atomisp_acc_fw_load32 __user *up)\r\n{\r\ncompat_uptr_t data = (compat_uptr_t)((uintptr_t)kp->data);\r\nif (!access_ok(VERIFY_WRITE, up,\r\nsizeof(struct atomisp_acc_fw_load32)) ||\r\nput_user(kp->size, &up->size) ||\r\nput_user(kp->fw_handle, &up->fw_handle) ||\r\nput_user(data, &up->data))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_acc_fw_arg32(struct atomisp_acc_fw_arg *kp,\r\nstruct atomisp_acc_fw_arg32 __user *up)\r\n{\r\ncompat_uptr_t value;\r\nif (!access_ok(VERIFY_READ, up, sizeof(struct atomisp_acc_fw_arg32)) ||\r\nget_user(kp->fw_handle, &up->fw_handle) ||\r\nget_user(kp->index, &up->index) ||\r\nget_user(value, &up->value) ||\r\nget_user(kp->size, &up->size))\r\nreturn -EFAULT;\r\nkp->value = compat_ptr(value);\r\nreturn 0;\r\n}\r\nstatic int put_atomisp_acc_fw_arg32(struct atomisp_acc_fw_arg *kp,\r\nstruct atomisp_acc_fw_arg32 __user *up)\r\n{\r\ncompat_uptr_t value = (compat_uptr_t)((uintptr_t)kp->value);\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(struct atomisp_acc_fw_arg32)) ||\r\nput_user(kp->fw_handle, &up->fw_handle) ||\r\nput_user(kp->index, &up->index) ||\r\nput_user(value, &up->value) ||\r\nput_user(kp->size, &up->size))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_v4l2_private_int_data32(struct v4l2_private_int_data *kp,\r\nstruct v4l2_private_int_data32 __user *up)\r\n{\r\ncompat_uptr_t data;\r\nif (!access_ok(VERIFY_READ, up,\r\nsizeof(struct v4l2_private_int_data32)) ||\r\nget_user(kp->size, &up->size) ||\r\nget_user(data, &up->data) ||\r\nget_user(kp->reserved[0], &up->reserved[0]) ||\r\nget_user(kp->reserved[1], &up->reserved[1]))\r\nreturn -EFAULT;\r\nkp->data = compat_ptr(data);\r\nreturn 0;\r\n}\r\nstatic int put_v4l2_private_int_data32(struct v4l2_private_int_data *kp,\r\nstruct v4l2_private_int_data32 __user *up)\r\n{\r\ncompat_uptr_t data = (compat_uptr_t)((uintptr_t)kp->data);\r\nif (!access_ok(VERIFY_WRITE, up,\r\nsizeof(struct v4l2_private_int_data32)) ||\r\nput_user(kp->size, &up->size) ||\r\nput_user(data, &up->data) ||\r\nput_user(kp->reserved[0], &up->reserved[0]) ||\r\nput_user(kp->reserved[1], &up->reserved[1]))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_shading_table32(struct atomisp_shading_table *kp,\r\nstruct atomisp_shading_table32 __user *up)\r\n{\r\nunsigned int n = ATOMISP_NUM_SC_COLORS;\r\nif (!access_ok(VERIFY_READ, up,\r\nsizeof(struct atomisp_shading_table32)) ||\r\nget_user(kp->enable, &up->enable) ||\r\nget_user(kp->sensor_width, &up->sensor_width) ||\r\nget_user(kp->sensor_height, &up->sensor_height) ||\r\nget_user(kp->width, &up->width) ||\r\nget_user(kp->height, &up->height) ||\r\nget_user(kp->fraction_bits, &up->fraction_bits))\r\nreturn -EFAULT;\r\nwhile (n-- > 0) {\r\nuintptr_t *data_p = (uintptr_t *)&kp->data[n];\r\nif (get_user((*data_p), &up->data[n]))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_acc_map32(struct atomisp_acc_map *kp,\r\nstruct atomisp_acc_map32 __user *up)\r\n{\r\ncompat_uptr_t user_ptr;\r\nif (!access_ok(VERIFY_READ, up, sizeof(struct atomisp_acc_map32)) ||\r\nget_user(kp->flags, &up->flags) ||\r\nget_user(kp->length, &up->length) ||\r\nget_user(user_ptr, &up->user_ptr) ||\r\nget_user(kp->css_ptr, &up->css_ptr) ||\r\nget_user(kp->reserved[0], &up->reserved[0]) ||\r\nget_user(kp->reserved[1], &up->reserved[1]) ||\r\nget_user(kp->reserved[2], &up->reserved[2]) ||\r\nget_user(kp->reserved[3], &up->reserved[3]))\r\nreturn -EFAULT;\r\nkp->user_ptr = compat_ptr(user_ptr);\r\nreturn 0;\r\n}\r\nstatic int put_atomisp_acc_map32(struct atomisp_acc_map *kp,\r\nstruct atomisp_acc_map32 __user *up)\r\n{\r\ncompat_uptr_t user_ptr = (compat_uptr_t)((uintptr_t)kp->user_ptr);\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(struct atomisp_acc_map32)) ||\r\nput_user(kp->flags, &up->flags) ||\r\nput_user(kp->length, &up->length) ||\r\nput_user(user_ptr, &up->user_ptr) ||\r\nput_user(kp->css_ptr, &up->css_ptr) ||\r\nput_user(kp->reserved[0], &up->reserved[0]) ||\r\nput_user(kp->reserved[1], &up->reserved[1]) ||\r\nput_user(kp->reserved[2], &up->reserved[2]) ||\r\nput_user(kp->reserved[3], &up->reserved[3]))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_acc_s_mapped_arg32(struct atomisp_acc_s_mapped_arg *kp,\r\nstruct atomisp_acc_s_mapped_arg32 __user *up)\r\n{\r\nif (!access_ok(VERIFY_READ, up,\r\nsizeof(struct atomisp_acc_s_mapped_arg32)) ||\r\nget_user(kp->fw_handle, &up->fw_handle) ||\r\nget_user(kp->memory, &up->memory) ||\r\nget_user(kp->length, &up->length) ||\r\nget_user(kp->css_ptr, &up->css_ptr))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int put_atomisp_acc_s_mapped_arg32(struct atomisp_acc_s_mapped_arg *kp,\r\nstruct atomisp_acc_s_mapped_arg32 __user *up)\r\n{\r\nif (!access_ok(VERIFY_WRITE, up,\r\nsizeof(struct atomisp_acc_s_mapped_arg32)) ||\r\nput_user(kp->fw_handle, &up->fw_handle) ||\r\nput_user(kp->memory, &up->memory) ||\r\nput_user(kp->length, &up->length) ||\r\nput_user(kp->css_ptr, &up->css_ptr))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_parameters32(struct atomisp_parameters *kp,\r\nstruct atomisp_parameters32 __user *up)\r\n{\r\nint n = offsetof(struct atomisp_parameters32, output_frame) /\r\nsizeof(compat_uptr_t);\r\nunsigned int size, offset = 0;\r\nvoid __user *user_ptr;\r\n#ifdef ISP2401\r\nunsigned int stp, mtp, dcp, dscp = 0;\r\n#endif\r\nif (!access_ok(VERIFY_READ, up, sizeof(struct atomisp_parameters32)))\r\nreturn -EFAULT;\r\nwhile (n >= 0) {\r\ncompat_uptr_t *src = (compat_uptr_t *)up + n;\r\nuintptr_t *dst = (uintptr_t *)kp + n;\r\nif (get_user((*dst), src))\r\nreturn -EFAULT;\r\nn--;\r\n}\r\nif (get_user(kp->isp_config_id, &up->isp_config_id) ||\r\n#ifndef ISP2401\r\nget_user(kp->per_frame_setting, &up->per_frame_setting))\r\n#else\r\nget_user(kp->per_frame_setting, &up->per_frame_setting) ||\r\nget_user(stp, &up->shading_table) ||\r\nget_user(mtp, &up->morph_table) ||\r\nget_user(dcp, &up->dvs2_coefs) ||\r\nget_user(dscp, &up->dvs_6axis_config))\r\n#endif\r\nreturn -EFAULT;\r\nint get_atomisp_acc_fw_load_to_pipe32(\r\nstruct atomisp_acc_fw_load_to_pipe *kp,\r\nstruct atomisp_acc_fw_load_to_pipe32 __user *up)\r\n{\r\ncompat_uptr_t data;\r\nif (!access_ok(VERIFY_READ, up,\r\nsizeof(struct atomisp_acc_fw_load_to_pipe32)) ||\r\nget_user(kp->flags, &up->flags) ||\r\nget_user(kp->fw_handle, &up->fw_handle) ||\r\nget_user(kp->size, &up->size) ||\r\nget_user(kp->type, &up->type) ||\r\nget_user(kp->reserved[0], &up->reserved[0]) ||\r\nget_user(kp->reserved[1], &up->reserved[1]) ||\r\nget_user(kp->reserved[2], &up->reserved[2]) ||\r\nget_user(data, &up->data))\r\nreturn -EFAULT;\r\nkp->data = compat_ptr(data);\r\nreturn 0;\r\n}\r\nstatic int put_atomisp_acc_fw_load_to_pipe32(\r\nstruct atomisp_acc_fw_load_to_pipe *kp,\r\nstruct atomisp_acc_fw_load_to_pipe32 __user *up)\r\n{\r\ncompat_uptr_t data = (compat_uptr_t)((uintptr_t)kp->data);\r\nif (!access_ok(VERIFY_WRITE, up,\r\nsizeof(struct atomisp_acc_fw_load_to_pipe32)) ||\r\nput_user(kp->flags, &up->flags) ||\r\nput_user(kp->fw_handle, &up->fw_handle) ||\r\nput_user(kp->size, &up->size) ||\r\nput_user(kp->type, &up->type) ||\r\nput_user(kp->reserved[0], &up->reserved[0]) ||\r\nput_user(kp->reserved[1], &up->reserved[1]) ||\r\nput_user(kp->reserved[2], &up->reserved[2]) ||\r\nput_user(data, &up->data))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_atomisp_sensor_ae_bracketing_lut(\r\nstruct atomisp_sensor_ae_bracketing_lut *kp,\r\nstruct atomisp_sensor_ae_bracketing_lut32 __user *up)\r\n{\r\ncompat_uptr_t lut;\r\nif (!access_ok(VERIFY_READ, up,\r\nsizeof(struct atomisp_sensor_ae_bracketing_lut32)) ||\r\nget_user(kp->lut_size, &up->lut_size) ||\r\nget_user(lut, &up->lut))\r\nreturn -EFAULT;\r\nkp->lut = compat_ptr(lut);\r\nreturn 0;\r\n}\r\nstatic long native_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nlong ret = -ENOIOCTLCMD;\r\nif (file->f_op->unlocked_ioctl)\r\nret = file->f_op->unlocked_ioctl(file, cmd, arg);\r\nreturn ret;\r\n}\r\nlong atomisp_do_compat_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nunion {\r\nstruct atomisp_histogram his;\r\nstruct atomisp_dis_statistics dis_s;\r\nstruct atomisp_dis_coefficients dis_c;\r\nstruct atomisp_dvs_6axis_config dvs_c;\r\nstruct atomisp_3a_statistics s3a_s;\r\nstruct atomisp_morph_table mor_t;\r\nstruct v4l2_framebuffer v4l2_buf;\r\nstruct atomisp_overlay overlay;\r\nstruct atomisp_calibration_group cal_grp;\r\nstruct atomisp_acc_fw_load acc_fw_load;\r\nstruct atomisp_acc_fw_arg acc_fw_arg;\r\nstruct v4l2_private_int_data v4l2_pri_data;\r\nstruct atomisp_shading_table shd_tbl;\r\nstruct atomisp_acc_map acc_map;\r\nstruct atomisp_acc_s_mapped_arg acc_map_arg;\r\nstruct atomisp_parameters param;\r\nstruct atomisp_acc_fw_load_to_pipe acc_fw_to_pipe;\r\nstruct atomisp_metadata md;\r\nstruct atomisp_metadata_with_type md_with_type;\r\nstruct atomisp_sensor_ae_bracketing_lut lut;\r\n} karg;\r\nmm_segment_t old_fs;\r\nvoid __user *up = compat_ptr(arg);\r\nlong err = -ENOIOCTLCMD;\r\nswitch (cmd) {\r\ncase ATOMISP_IOC_G_HISTOGRAM32:\r\ncmd = ATOMISP_IOC_G_HISTOGRAM;\r\nbreak;\r\ncase ATOMISP_IOC_S_HISTOGRAM32:\r\ncmd = ATOMISP_IOC_S_HISTOGRAM;\r\nbreak;\r\ncase ATOMISP_IOC_G_DIS_STAT32:\r\ncmd = ATOMISP_IOC_G_DIS_STAT;\r\nbreak;\r\ncase ATOMISP_IOC_S_DIS_COEFS32:\r\ncmd = ATOMISP_IOC_S_DIS_COEFS;\r\nbreak;\r\ncase ATOMISP_IOC_S_DIS_VECTOR32:\r\ncmd = ATOMISP_IOC_S_DIS_VECTOR;\r\nbreak;\r\ncase ATOMISP_IOC_G_3A_STAT32:\r\ncmd = ATOMISP_IOC_G_3A_STAT;\r\nbreak;\r\ncase ATOMISP_IOC_G_ISP_GDC_TAB32:\r\ncmd = ATOMISP_IOC_G_ISP_GDC_TAB;\r\nbreak;\r\ncase ATOMISP_IOC_S_ISP_GDC_TAB32:\r\ncmd = ATOMISP_IOC_S_ISP_GDC_TAB;\r\nbreak;\r\ncase ATOMISP_IOC_S_ISP_FPN_TABLE32:\r\ncmd = ATOMISP_IOC_S_ISP_FPN_TABLE;\r\nbreak;\r\ncase ATOMISP_IOC_G_ISP_OVERLAY32:\r\ncmd = ATOMISP_IOC_G_ISP_OVERLAY;\r\nbreak;\r\ncase ATOMISP_IOC_S_ISP_OVERLAY32:\r\ncmd = ATOMISP_IOC_S_ISP_OVERLAY;\r\nbreak;\r\ncase ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP32:\r\ncmd = ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP;\r\nbreak;\r\ncase ATOMISP_IOC_ACC_LOAD32:\r\ncmd = ATOMISP_IOC_ACC_LOAD;\r\nbreak;\r\ncase ATOMISP_IOC_ACC_S_ARG32:\r\ncmd = ATOMISP_IOC_ACC_S_ARG;\r\nbreak;\r\ncase ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA32:\r\ncmd = ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA;\r\nbreak;\r\ncase ATOMISP_IOC_S_ISP_SHD_TAB32:\r\ncmd = ATOMISP_IOC_S_ISP_SHD_TAB;\r\nbreak;\r\ncase ATOMISP_IOC_ACC_DESTAB32:\r\ncmd = ATOMISP_IOC_ACC_DESTAB;\r\nbreak;\r\ncase ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA32:\r\ncmd = ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA;\r\nbreak;\r\ncase ATOMISP_IOC_ACC_MAP32:\r\ncmd = ATOMISP_IOC_ACC_MAP;\r\nbreak;\r\ncase ATOMISP_IOC_ACC_UNMAP32:\r\ncmd = ATOMISP_IOC_ACC_UNMAP;\r\nbreak;\r\ncase ATOMISP_IOC_ACC_S_MAPPED_ARG32:\r\ncmd = ATOMISP_IOC_ACC_S_MAPPED_ARG;\r\nbreak;\r\ncase ATOMISP_IOC_S_PARAMETERS32:\r\ncmd = ATOMISP_IOC_S_PARAMETERS;\r\nbreak;\r\ncase ATOMISP_IOC_ACC_LOAD_TO_PIPE32:\r\ncmd = ATOMISP_IOC_ACC_LOAD_TO_PIPE;\r\nbreak;\r\ncase ATOMISP_IOC_G_METADATA32:\r\ncmd = ATOMISP_IOC_G_METADATA;\r\nbreak;\r\ncase ATOMISP_IOC_G_METADATA_BY_TYPE32:\r\ncmd = ATOMISP_IOC_G_METADATA_BY_TYPE;\r\nbreak;\r\ncase ATOMISP_IOC_S_SENSOR_AE_BRACKETING_LUT32:\r\ncmd = ATOMISP_IOC_S_SENSOR_AE_BRACKETING_LUT;\r\nbreak;\r\n}\r\nswitch (cmd) {\r\ncase ATOMISP_IOC_G_HISTOGRAM:\r\ncase ATOMISP_IOC_S_HISTOGRAM:\r\nerr = get_atomisp_histogram32(&karg.his, up);\r\nbreak;\r\ncase ATOMISP_IOC_G_DIS_STAT:\r\nerr = get_atomisp_dis_statistics32(&karg.dis_s, up);\r\nbreak;\r\ncase ATOMISP_IOC_S_DIS_COEFS:\r\nerr = get_atomisp_dis_coefficients32(&karg.dis_c, up);\r\nbreak;\r\ncase ATOMISP_IOC_S_DIS_VECTOR:\r\nerr = get_atomisp_dvs_6axis_config32(&karg.dvs_c, up);\r\nbreak;\r\ncase ATOMISP_IOC_G_3A_STAT:\r\nerr = get_atomisp_3a_statistics32(&karg.s3a_s, up);\r\nbreak;\r\ncase ATOMISP_IOC_G_ISP_GDC_TAB:\r\ncase ATOMISP_IOC_S_ISP_GDC_TAB:\r\nerr = get_atomisp_morph_table32(&karg.mor_t, up);\r\nbreak;\r\ncase ATOMISP_IOC_S_ISP_FPN_TABLE:\r\nerr = get_v4l2_framebuffer32(&karg.v4l2_buf, up);\r\nbreak;\r\ncase ATOMISP_IOC_G_ISP_OVERLAY:\r\ncase ATOMISP_IOC_S_ISP_OVERLAY:\r\nerr = get_atomisp_overlay32(&karg.overlay, up);\r\nbreak;\r\ncase ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP:\r\nerr = get_atomisp_calibration_group32(&karg.cal_grp, up);\r\nbreak;\r\ncase ATOMISP_IOC_ACC_LOAD:\r\nerr = get_atomisp_acc_fw_load32(&karg.acc_fw_load, up);\r\nbreak;\r\ncase ATOMISP_IOC_ACC_S_ARG:\r\ncase ATOMISP_IOC_ACC_DESTAB:\r\nerr = get_atomisp_acc_fw_arg32(&karg.acc_fw_arg, up);\r\nbreak;\r\ncase ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:\r\ncase ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA:\r\nerr = get_v4l2_private_int_data32(&karg.v4l2_pri_data, up);\r\nbreak;\r\ncase ATOMISP_IOC_S_ISP_SHD_TAB:\r\nerr = get_atomisp_shading_table32(&karg.shd_tbl, up);\r\nbreak;\r\ncase ATOMISP_IOC_ACC_MAP:\r\ncase ATOMISP_IOC_ACC_UNMAP:\r\nerr = get_atomisp_acc_map32(&karg.acc_map, up);\r\nbreak;\r\ncase ATOMISP_IOC_ACC_S_MAPPED_ARG:\r\nerr = get_atomisp_acc_s_mapped_arg32(&karg.acc_map_arg, up);\r\nbreak;\r\ncase ATOMISP_IOC_S_PARAMETERS:\r\nerr = get_atomisp_parameters32(&karg.param, up);\r\nbreak;\r\ncase ATOMISP_IOC_ACC_LOAD_TO_PIPE:\r\nerr = get_atomisp_acc_fw_load_to_pipe32(&karg.acc_fw_to_pipe,\r\nup);\r\nbreak;\r\ncase ATOMISP_IOC_G_METADATA:\r\nerr = get_atomisp_metadata_stat32(&karg.md, up);\r\nbreak;\r\ncase ATOMISP_IOC_G_METADATA_BY_TYPE:\r\nerr = get_atomisp_metadata_by_type_stat32(&karg.md_with_type,\r\nup);\r\nbreak;\r\ncase ATOMISP_IOC_S_SENSOR_AE_BRACKETING_LUT:\r\nerr = get_atomisp_sensor_ae_bracketing_lut(&karg.lut, up);\r\nbreak;\r\n}\r\nif (err)\r\nreturn err;\r\nold_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nerr = native_ioctl(file, cmd, (unsigned long)&karg);\r\nset_fs(old_fs);\r\nif (err)\r\nreturn err;\r\nswitch (cmd) {\r\ncase ATOMISP_IOC_G_HISTOGRAM:\r\nerr = put_atomisp_histogram32(&karg.his, up);\r\nbreak;\r\ncase ATOMISP_IOC_G_DIS_STAT:\r\nerr = put_atomisp_dis_statistics32(&karg.dis_s, up);\r\nbreak;\r\ncase ATOMISP_IOC_G_3A_STAT:\r\nerr = put_atomisp_3a_statistics32(&karg.s3a_s, up);\r\nbreak;\r\ncase ATOMISP_IOC_G_ISP_GDC_TAB:\r\nerr = put_atomisp_morph_table32(&karg.mor_t, up);\r\nbreak;\r\ncase ATOMISP_IOC_G_ISP_OVERLAY:\r\nerr = put_atomisp_overlay32(&karg.overlay, up);\r\nbreak;\r\ncase ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP:\r\nerr = put_atomisp_calibration_group32(&karg.cal_grp, up);\r\nbreak;\r\ncase ATOMISP_IOC_ACC_LOAD:\r\nerr = put_atomisp_acc_fw_load32(&karg.acc_fw_load, up);\r\nbreak;\r\ncase ATOMISP_IOC_ACC_S_ARG:\r\ncase ATOMISP_IOC_ACC_DESTAB:\r\nerr = put_atomisp_acc_fw_arg32(&karg.acc_fw_arg, up);\r\nbreak;\r\ncase ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:\r\ncase ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA:\r\nerr = put_v4l2_private_int_data32(&karg.v4l2_pri_data, up);\r\nbreak;\r\ncase ATOMISP_IOC_ACC_MAP:\r\ncase ATOMISP_IOC_ACC_UNMAP:\r\nerr = put_atomisp_acc_map32(&karg.acc_map, up);\r\nbreak;\r\ncase ATOMISP_IOC_ACC_S_MAPPED_ARG:\r\nerr = put_atomisp_acc_s_mapped_arg32(&karg.acc_map_arg, up);\r\nbreak;\r\ncase ATOMISP_IOC_ACC_LOAD_TO_PIPE:\r\nerr = put_atomisp_acc_fw_load_to_pipe32(&karg.acc_fw_to_pipe,\r\nup);\r\nbreak;\r\ncase ATOMISP_IOC_G_METADATA:\r\nerr = put_atomisp_metadata_stat32(&karg.md, up);\r\nbreak;\r\ncase ATOMISP_IOC_G_METADATA_BY_TYPE:\r\nerr = put_atomisp_metadata_by_type_stat32(&karg.md_with_type,\r\nup);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nlong atomisp_compat_ioctl32(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct atomisp_device *isp = video_get_drvdata(vdev);\r\nlong ret = -ENOIOCTLCMD;\r\nif (!file->f_op->unlocked_ioctl)\r\nreturn ret;\r\nswitch (cmd) {\r\ncase ATOMISP_IOC_G_XNR:\r\ncase ATOMISP_IOC_S_XNR:\r\ncase ATOMISP_IOC_G_NR:\r\ncase ATOMISP_IOC_S_NR:\r\ncase ATOMISP_IOC_G_TNR:\r\ncase ATOMISP_IOC_S_TNR:\r\ncase ATOMISP_IOC_G_BLACK_LEVEL_COMP:\r\ncase ATOMISP_IOC_S_BLACK_LEVEL_COMP:\r\ncase ATOMISP_IOC_G_EE:\r\ncase ATOMISP_IOC_S_EE:\r\ncase ATOMISP_IOC_S_DIS_VECTOR:\r\ncase ATOMISP_IOC_G_ISP_PARM:\r\ncase ATOMISP_IOC_S_ISP_PARM:\r\ncase ATOMISP_IOC_G_ISP_GAMMA:\r\ncase ATOMISP_IOC_S_ISP_GAMMA:\r\ncase ATOMISP_IOC_ISP_MAKERNOTE:\r\ncase ATOMISP_IOC_G_ISP_MACC:\r\ncase ATOMISP_IOC_S_ISP_MACC:\r\ncase ATOMISP_IOC_G_ISP_BAD_PIXEL_DETECTION:\r\ncase ATOMISP_IOC_S_ISP_BAD_PIXEL_DETECTION:\r\ncase ATOMISP_IOC_G_ISP_FALSE_COLOR_CORRECTION:\r\ncase ATOMISP_IOC_S_ISP_FALSE_COLOR_CORRECTION:\r\ncase ATOMISP_IOC_G_ISP_CTC:\r\ncase ATOMISP_IOC_S_ISP_CTC:\r\ncase ATOMISP_IOC_G_ISP_WHITE_BALANCE:\r\ncase ATOMISP_IOC_S_ISP_WHITE_BALANCE:\r\ncase ATOMISP_IOC_CAMERA_BRIDGE:\r\ncase ATOMISP_IOC_G_SENSOR_MODE_DATA:\r\ncase ATOMISP_IOC_S_EXPOSURE:\r\ncase ATOMISP_IOC_G_3A_CONFIG:\r\ncase ATOMISP_IOC_S_3A_CONFIG:\r\ncase ATOMISP_IOC_ACC_UNLOAD:\r\ncase ATOMISP_IOC_ACC_START:\r\ncase ATOMISP_IOC_ACC_WAIT:\r\ncase ATOMISP_IOC_ACC_ABORT:\r\ncase ATOMISP_IOC_G_ISP_GAMMA_CORRECTION:\r\ncase ATOMISP_IOC_S_ISP_GAMMA_CORRECTION:\r\ncase ATOMISP_IOC_S_CONT_CAPTURE_CONFIG:\r\ncase ATOMISP_IOC_G_DVS2_BQ_RESOLUTIONS:\r\ncase ATOMISP_IOC_EXT_ISP_CTRL:\r\ncase ATOMISP_IOC_EXP_ID_UNLOCK:\r\ncase ATOMISP_IOC_EXP_ID_CAPTURE:\r\ncase ATOMISP_IOC_S_ENABLE_DZ_CAPT_PIPE:\r\ncase ATOMISP_IOC_G_FORMATS_CONFIG:\r\ncase ATOMISP_IOC_S_FORMATS_CONFIG:\r\ncase ATOMISP_IOC_S_EXPOSURE_WINDOW:\r\ncase ATOMISP_IOC_S_ACC_STATE:\r\ncase ATOMISP_IOC_G_ACC_STATE:\r\ncase ATOMISP_IOC_INJECT_A_FAKE_EVENT:\r\ncase ATOMISP_IOC_G_SENSOR_AE_BRACKETING_INFO:\r\ncase ATOMISP_IOC_S_SENSOR_AE_BRACKETING_MODE:\r\ncase ATOMISP_IOC_G_SENSOR_AE_BRACKETING_MODE:\r\ncase ATOMISP_IOC_G_INVALID_FRAME_NUM:\r\ncase ATOMISP_IOC_S_ARRAY_RESOLUTION:\r\n#ifdef ISP2401\r\ncase ATOMISP_IOC_S_SENSOR_RUNMODE:\r\ncase ATOMISP_IOC_G_UPDATE_EXPOSURE:\r\n#endif\r\nret = native_ioctl(file, cmd, arg);\r\nbreak;\r\ncase ATOMISP_IOC_G_HISTOGRAM32:\r\ncase ATOMISP_IOC_S_HISTOGRAM32:\r\ncase ATOMISP_IOC_G_DIS_STAT32:\r\ncase ATOMISP_IOC_S_DIS_COEFS32:\r\ncase ATOMISP_IOC_S_DIS_VECTOR32:\r\ncase ATOMISP_IOC_G_3A_STAT32:\r\ncase ATOMISP_IOC_G_ISP_GDC_TAB32:\r\ncase ATOMISP_IOC_S_ISP_GDC_TAB32:\r\ncase ATOMISP_IOC_S_ISP_FPN_TABLE32:\r\ncase ATOMISP_IOC_G_ISP_OVERLAY32:\r\ncase ATOMISP_IOC_S_ISP_OVERLAY32:\r\ncase ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP32:\r\ncase ATOMISP_IOC_ACC_LOAD32:\r\ncase ATOMISP_IOC_ACC_S_ARG32:\r\ncase ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA32:\r\ncase ATOMISP_IOC_S_ISP_SHD_TAB32:\r\ncase ATOMISP_IOC_ACC_DESTAB32:\r\ncase ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA32:\r\ncase ATOMISP_IOC_ACC_MAP32:\r\ncase ATOMISP_IOC_ACC_UNMAP32:\r\ncase ATOMISP_IOC_ACC_S_MAPPED_ARG32:\r\ncase ATOMISP_IOC_S_PARAMETERS32:\r\ncase ATOMISP_IOC_ACC_LOAD_TO_PIPE32:\r\ncase ATOMISP_IOC_G_METADATA32:\r\ncase ATOMISP_IOC_G_METADATA_BY_TYPE32:\r\ncase ATOMISP_IOC_S_SENSOR_AE_BRACKETING_LUT32:\r\nret = atomisp_do_compat_ioctl(file, cmd, arg);\r\nbreak;\r\ndefault:\r\ndev_warn(isp->dev,\r\n"%s: unknown ioctl '%c', dir=%d, #%d (0x%08x)\n",\r\n__func__, _IOC_TYPE(cmd), _IOC_DIR(cmd), _IOC_NR(cmd),\r\ncmd);\r\nbreak;\r\n}\r\nreturn ret;\r\n}
