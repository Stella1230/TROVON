static int is_in_nid_list(hda_nid_t nid, const hda_nid_t *list)\r\n{\r\nfor (; *list; list++)\r\nif (*list == nid)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int compare_seq(const void *ap, const void *bp)\r\n{\r\nconst struct auto_out_pin *a = ap;\r\nconst struct auto_out_pin *b = bp;\r\nreturn (int)(a->seq - b->seq);\r\n}\r\nstatic void sort_pins_by_sequence(hda_nid_t *pins, struct auto_out_pin *list,\r\nint num_pins)\r\n{\r\nint i;\r\nsort(list, num_pins, sizeof(list[0]), compare_seq, NULL);\r\nfor (i = 0; i < num_pins; i++)\r\npins[i] = list[i].pin;\r\n}\r\nstatic void add_auto_cfg_input_pin(struct hda_codec *codec, struct auto_pin_cfg *cfg,\r\nhda_nid_t nid, int type)\r\n{\r\nif (cfg->num_inputs < AUTO_CFG_MAX_INS) {\r\ncfg->inputs[cfg->num_inputs].pin = nid;\r\ncfg->inputs[cfg->num_inputs].type = type;\r\ncfg->inputs[cfg->num_inputs].has_boost_on_pin =\r\nnid_has_volume(codec, nid, HDA_INPUT);\r\ncfg->num_inputs++;\r\n}\r\n}\r\nstatic int compare_input_type(const void *ap, const void *bp)\r\n{\r\nconst struct auto_pin_cfg_item *a = ap;\r\nconst struct auto_pin_cfg_item *b = bp;\r\nif (a->type != b->type)\r\nreturn (int)(a->type - b->type);\r\nreturn (int)(b->has_boost_on_pin - a->has_boost_on_pin);\r\n}\r\nstatic void reorder_outputs(unsigned int nums, hda_nid_t *pins)\r\n{\r\nhda_nid_t nid;\r\nswitch (nums) {\r\ncase 3:\r\ncase 4:\r\nnid = pins[1];\r\npins[1] = pins[2];\r\npins[2] = nid;\r\nbreak;\r\n}\r\n}\r\nstatic bool check_pincap_validity(struct hda_codec *codec, hda_nid_t pin,\r\nunsigned int dev)\r\n{\r\nunsigned int pincap = snd_hda_query_pin_caps(codec, pin);\r\nif (!pincap)\r\nreturn true;\r\nswitch (dev) {\r\ncase AC_JACK_LINE_OUT:\r\ncase AC_JACK_SPEAKER:\r\ncase AC_JACK_HP_OUT:\r\ncase AC_JACK_SPDIF_OUT:\r\ncase AC_JACK_DIG_OTHER_OUT:\r\nreturn !!(pincap & AC_PINCAP_OUT);\r\ndefault:\r\nreturn !!(pincap & AC_PINCAP_IN);\r\n}\r\n}\r\nstatic bool can_be_headset_mic(struct hda_codec *codec,\r\nstruct auto_pin_cfg_item *item,\r\nint seq_number)\r\n{\r\nint attr;\r\nunsigned int def_conf;\r\nif (item->type != AUTO_PIN_MIC)\r\nreturn false;\r\nif (item->is_headset_mic || item->is_headphone_mic)\r\nreturn false;\r\ndef_conf = snd_hda_codec_get_pincfg(codec, item->pin);\r\nattr = snd_hda_get_input_pin_attr(def_conf);\r\nif (attr <= INPUT_PIN_ATTR_DOCK)\r\nreturn false;\r\nif (seq_number >= 0) {\r\nint seq = get_defcfg_sequence(def_conf);\r\nif (seq != seq_number)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nint snd_hda_parse_pin_defcfg(struct hda_codec *codec,\r\nstruct auto_pin_cfg *cfg,\r\nconst hda_nid_t *ignore_nids,\r\nunsigned int cond_flags)\r\n{\r\nhda_nid_t nid;\r\nshort seq, assoc_line_out;\r\nstruct auto_out_pin line_out[ARRAY_SIZE(cfg->line_out_pins)];\r\nstruct auto_out_pin speaker_out[ARRAY_SIZE(cfg->speaker_pins)];\r\nstruct auto_out_pin hp_out[ARRAY_SIZE(cfg->hp_pins)];\r\nint i;\r\nif (!snd_hda_get_int_hint(codec, "parser_flags", &i))\r\ncond_flags = i;\r\nmemset(cfg, 0, sizeof(*cfg));\r\nmemset(line_out, 0, sizeof(line_out));\r\nmemset(speaker_out, 0, sizeof(speaker_out));\r\nmemset(hp_out, 0, sizeof(hp_out));\r\nassoc_line_out = 0;\r\nfor_each_hda_codec_node(nid, codec) {\r\nunsigned int wid_caps = get_wcaps(codec, nid);\r\nunsigned int wid_type = get_wcaps_type(wid_caps);\r\nunsigned int def_conf;\r\nshort assoc, loc, conn, dev;\r\nif (wid_type != AC_WID_PIN)\r\ncontinue;\r\nif (ignore_nids && is_in_nid_list(nid, ignore_nids))\r\ncontinue;\r\ndef_conf = snd_hda_codec_get_pincfg(codec, nid);\r\nconn = get_defcfg_connect(def_conf);\r\nif (conn == AC_JACK_PORT_NONE)\r\ncontinue;\r\nloc = get_defcfg_location(def_conf);\r\ndev = get_defcfg_device(def_conf);\r\nif (dev == AC_JACK_LINE_OUT) {\r\nif (conn == AC_JACK_PORT_FIXED ||\r\nconn == AC_JACK_PORT_BOTH)\r\ndev = AC_JACK_SPEAKER;\r\n}\r\nif (!check_pincap_validity(codec, nid, dev))\r\ncontinue;\r\nswitch (dev) {\r\ncase AC_JACK_LINE_OUT:\r\nseq = get_defcfg_sequence(def_conf);\r\nassoc = get_defcfg_association(def_conf);\r\nif (!(wid_caps & AC_WCAP_STEREO))\r\nif (!cfg->mono_out_pin)\r\ncfg->mono_out_pin = nid;\r\nif (!assoc)\r\ncontinue;\r\nif (!assoc_line_out)\r\nassoc_line_out = assoc;\r\nelse if (assoc_line_out != assoc) {\r\ncodec_info(codec,\r\n"ignore pin 0x%x with mismatching assoc# 0x%x vs 0x%x\n",\r\nnid, assoc, assoc_line_out);\r\ncontinue;\r\n}\r\nif (cfg->line_outs >= ARRAY_SIZE(cfg->line_out_pins)) {\r\ncodec_info(codec,\r\n"ignore pin 0x%x, too many assigned pins\n",\r\nnid);\r\ncontinue;\r\n}\r\nline_out[cfg->line_outs].pin = nid;\r\nline_out[cfg->line_outs].seq = seq;\r\ncfg->line_outs++;\r\nbreak;\r\ncase AC_JACK_SPEAKER:\r\nseq = get_defcfg_sequence(def_conf);\r\nassoc = get_defcfg_association(def_conf);\r\nif (cfg->speaker_outs >= ARRAY_SIZE(cfg->speaker_pins)) {\r\ncodec_info(codec,\r\n"ignore pin 0x%x, too many assigned pins\n",\r\nnid);\r\ncontinue;\r\n}\r\nspeaker_out[cfg->speaker_outs].pin = nid;\r\nspeaker_out[cfg->speaker_outs].seq = (assoc << 4) | seq;\r\ncfg->speaker_outs++;\r\nbreak;\r\ncase AC_JACK_HP_OUT:\r\nseq = get_defcfg_sequence(def_conf);\r\nassoc = get_defcfg_association(def_conf);\r\nif (cfg->hp_outs >= ARRAY_SIZE(cfg->hp_pins)) {\r\ncodec_info(codec,\r\n"ignore pin 0x%x, too many assigned pins\n",\r\nnid);\r\ncontinue;\r\n}\r\nhp_out[cfg->hp_outs].pin = nid;\r\nhp_out[cfg->hp_outs].seq = (assoc << 4) | seq;\r\ncfg->hp_outs++;\r\nbreak;\r\ncase AC_JACK_MIC_IN:\r\nadd_auto_cfg_input_pin(codec, cfg, nid, AUTO_PIN_MIC);\r\nbreak;\r\ncase AC_JACK_LINE_IN:\r\nadd_auto_cfg_input_pin(codec, cfg, nid, AUTO_PIN_LINE_IN);\r\nbreak;\r\ncase AC_JACK_CD:\r\nadd_auto_cfg_input_pin(codec, cfg, nid, AUTO_PIN_CD);\r\nbreak;\r\ncase AC_JACK_AUX:\r\nadd_auto_cfg_input_pin(codec, cfg, nid, AUTO_PIN_AUX);\r\nbreak;\r\ncase AC_JACK_SPDIF_OUT:\r\ncase AC_JACK_DIG_OTHER_OUT:\r\nif (cfg->dig_outs >= ARRAY_SIZE(cfg->dig_out_pins)) {\r\ncodec_info(codec,\r\n"ignore pin 0x%x, too many assigned pins\n",\r\nnid);\r\ncontinue;\r\n}\r\ncfg->dig_out_pins[cfg->dig_outs] = nid;\r\ncfg->dig_out_type[cfg->dig_outs] =\r\n(loc == AC_JACK_LOC_HDMI) ?\r\nHDA_PCM_TYPE_HDMI : HDA_PCM_TYPE_SPDIF;\r\ncfg->dig_outs++;\r\nbreak;\r\ncase AC_JACK_SPDIF_IN:\r\ncase AC_JACK_DIG_OTHER_IN:\r\ncfg->dig_in_pin = nid;\r\nif (loc == AC_JACK_LOC_HDMI)\r\ncfg->dig_in_type = HDA_PCM_TYPE_HDMI;\r\nelse\r\ncfg->dig_in_type = HDA_PCM_TYPE_SPDIF;\r\nbreak;\r\n}\r\n}\r\nif (cond_flags & HDA_PINCFG_HEADSET_MIC || cond_flags & HDA_PINCFG_HEADPHONE_MIC) {\r\nbool hsmic = !!(cond_flags & HDA_PINCFG_HEADSET_MIC);\r\nbool hpmic = !!(cond_flags & HDA_PINCFG_HEADPHONE_MIC);\r\nfor (i = 0; (hsmic || hpmic) && (i < cfg->num_inputs); i++)\r\nif (hsmic && can_be_headset_mic(codec, &cfg->inputs[i], 0xc)) {\r\ncfg->inputs[i].is_headset_mic = 1;\r\nhsmic = false;\r\n} else if (hpmic && can_be_headset_mic(codec, &cfg->inputs[i], 0xd)) {\r\ncfg->inputs[i].is_headphone_mic = 1;\r\nhpmic = false;\r\n}\r\nfor (i = 0; (hsmic || hpmic) && (i < cfg->num_inputs); i++) {\r\nif (!can_be_headset_mic(codec, &cfg->inputs[i], -1))\r\ncontinue;\r\nif (hsmic) {\r\ncfg->inputs[i].is_headset_mic = 1;\r\nhsmic = false;\r\n} else if (hpmic) {\r\ncfg->inputs[i].is_headphone_mic = 1;\r\nhpmic = false;\r\n}\r\n}\r\nif (hsmic)\r\ncodec_dbg(codec, "Told to look for a headset mic, but didn't find any.\n");\r\nif (hpmic)\r\ncodec_dbg(codec, "Told to look for a headphone mic, but didn't find any.\n");\r\n}\r\nif (!cfg->line_outs && cfg->hp_outs > 1 &&\r\n!(cond_flags & HDA_PINCFG_NO_HP_FIXUP)) {\r\nint i = 0;\r\nwhile (i < cfg->hp_outs) {\r\nif ((hp_out[i].seq & 0x0f) == 0x0f) {\r\ni++;\r\ncontinue;\r\n}\r\nline_out[cfg->line_outs++] = hp_out[i];\r\ncfg->hp_outs--;\r\nmemmove(hp_out + i, hp_out + i + 1,\r\nsizeof(hp_out[0]) * (cfg->hp_outs - i));\r\n}\r\nmemset(hp_out + cfg->hp_outs, 0,\r\nsizeof(hp_out[0]) * (AUTO_CFG_MAX_OUTS - cfg->hp_outs));\r\nif (!cfg->hp_outs)\r\ncfg->line_out_type = AUTO_PIN_HP_OUT;\r\n}\r\nsort_pins_by_sequence(cfg->line_out_pins, line_out, cfg->line_outs);\r\nsort_pins_by_sequence(cfg->speaker_pins, speaker_out,\r\ncfg->speaker_outs);\r\nsort_pins_by_sequence(cfg->hp_pins, hp_out, cfg->hp_outs);\r\nif (!cfg->line_outs &&\r\n!(cond_flags & HDA_PINCFG_NO_LO_FIXUP)) {\r\nif (cfg->speaker_outs) {\r\ncfg->line_outs = cfg->speaker_outs;\r\nmemcpy(cfg->line_out_pins, cfg->speaker_pins,\r\nsizeof(cfg->speaker_pins));\r\ncfg->speaker_outs = 0;\r\nmemset(cfg->speaker_pins, 0, sizeof(cfg->speaker_pins));\r\ncfg->line_out_type = AUTO_PIN_SPEAKER_OUT;\r\n} else if (cfg->hp_outs) {\r\ncfg->line_outs = cfg->hp_outs;\r\nmemcpy(cfg->line_out_pins, cfg->hp_pins,\r\nsizeof(cfg->hp_pins));\r\ncfg->hp_outs = 0;\r\nmemset(cfg->hp_pins, 0, sizeof(cfg->hp_pins));\r\ncfg->line_out_type = AUTO_PIN_HP_OUT;\r\n}\r\n}\r\nreorder_outputs(cfg->line_outs, cfg->line_out_pins);\r\nreorder_outputs(cfg->hp_outs, cfg->hp_pins);\r\nreorder_outputs(cfg->speaker_outs, cfg->speaker_pins);\r\nsort(cfg->inputs, cfg->num_inputs, sizeof(cfg->inputs[0]),\r\ncompare_input_type, NULL);\r\ncodec_info(codec, "autoconfig for %s: line_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x) type:%s\n",\r\ncodec->core.chip_name, cfg->line_outs, cfg->line_out_pins[0],\r\ncfg->line_out_pins[1], cfg->line_out_pins[2],\r\ncfg->line_out_pins[3], cfg->line_out_pins[4],\r\ncfg->line_out_type == AUTO_PIN_HP_OUT ? "hp" :\r\n(cfg->line_out_type == AUTO_PIN_SPEAKER_OUT ?\r\n"speaker" : "line"));\r\ncodec_info(codec, " speaker_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x)\n",\r\ncfg->speaker_outs, cfg->speaker_pins[0],\r\ncfg->speaker_pins[1], cfg->speaker_pins[2],\r\ncfg->speaker_pins[3], cfg->speaker_pins[4]);\r\ncodec_info(codec, " hp_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x)\n",\r\ncfg->hp_outs, cfg->hp_pins[0],\r\ncfg->hp_pins[1], cfg->hp_pins[2],\r\ncfg->hp_pins[3], cfg->hp_pins[4]);\r\ncodec_info(codec, " mono: mono_out=0x%x\n", cfg->mono_out_pin);\r\nif (cfg->dig_outs)\r\ncodec_info(codec, " dig-out=0x%x/0x%x\n",\r\ncfg->dig_out_pins[0], cfg->dig_out_pins[1]);\r\ncodec_info(codec, " inputs:\n");\r\nfor (i = 0; i < cfg->num_inputs; i++) {\r\ncodec_info(codec, " %s=0x%x\n",\r\nhda_get_autocfg_input_label(codec, cfg, i),\r\ncfg->inputs[i].pin);\r\n}\r\nif (cfg->dig_in_pin)\r\ncodec_info(codec, " dig-in=0x%x\n", cfg->dig_in_pin);\r\nreturn 0;\r\n}\r\nint snd_hda_get_input_pin_attr(unsigned int def_conf)\r\n{\r\nunsigned int loc = get_defcfg_location(def_conf);\r\nunsigned int conn = get_defcfg_connect(def_conf);\r\nif (conn == AC_JACK_PORT_NONE)\r\nreturn INPUT_PIN_ATTR_UNUSED;\r\nif (conn == AC_JACK_PORT_FIXED || conn == AC_JACK_PORT_BOTH)\r\nreturn INPUT_PIN_ATTR_INT;\r\nif ((loc & 0x30) == AC_JACK_LOC_INTERNAL)\r\nreturn INPUT_PIN_ATTR_INT;\r\nif ((loc & 0x30) == AC_JACK_LOC_SEPARATE)\r\nreturn INPUT_PIN_ATTR_DOCK;\r\nif (loc == AC_JACK_LOC_REAR)\r\nreturn INPUT_PIN_ATTR_REAR;\r\nif (loc == AC_JACK_LOC_FRONT)\r\nreturn INPUT_PIN_ATTR_FRONT;\r\nreturn INPUT_PIN_ATTR_NORMAL;\r\n}\r\nstatic const char *hda_get_input_pin_label(struct hda_codec *codec,\r\nconst struct auto_pin_cfg_item *item,\r\nhda_nid_t pin, bool check_location)\r\n{\r\nunsigned int def_conf;\r\nstatic const char * const mic_names[] = {\r\n"Internal Mic", "Dock Mic", "Mic", "Rear Mic", "Front Mic"\r\n};\r\nint attr;\r\ndef_conf = snd_hda_codec_get_pincfg(codec, pin);\r\nswitch (get_defcfg_device(def_conf)) {\r\ncase AC_JACK_MIC_IN:\r\nif (item && item->is_headset_mic)\r\nreturn "Headset Mic";\r\nif (item && item->is_headphone_mic)\r\nreturn "Headphone Mic";\r\nif (!check_location)\r\nreturn "Mic";\r\nattr = snd_hda_get_input_pin_attr(def_conf);\r\nif (!attr)\r\nreturn "None";\r\nreturn mic_names[attr - 1];\r\ncase AC_JACK_LINE_IN:\r\nif (!check_location)\r\nreturn "Line";\r\nattr = snd_hda_get_input_pin_attr(def_conf);\r\nif (!attr)\r\nreturn "None";\r\nif (attr == INPUT_PIN_ATTR_DOCK)\r\nreturn "Dock Line";\r\nreturn "Line";\r\ncase AC_JACK_AUX:\r\nreturn "Aux";\r\ncase AC_JACK_CD:\r\nreturn "CD";\r\ncase AC_JACK_SPDIF_IN:\r\nreturn "SPDIF In";\r\ncase AC_JACK_DIG_OTHER_IN:\r\nreturn "Digital In";\r\ncase AC_JACK_HP_OUT:\r\nreturn "Headphone Mic";\r\ndefault:\r\nreturn "Misc";\r\n}\r\n}\r\nstatic int check_mic_location_need(struct hda_codec *codec,\r\nconst struct auto_pin_cfg *cfg,\r\nint input)\r\n{\r\nunsigned int defc;\r\nint i, attr, attr2;\r\ndefc = snd_hda_codec_get_pincfg(codec, cfg->inputs[input].pin);\r\nattr = snd_hda_get_input_pin_attr(defc);\r\nif (attr <= INPUT_PIN_ATTR_NORMAL)\r\nreturn 1;\r\nattr = 0;\r\nfor (i = 0; i < cfg->num_inputs; i++) {\r\ndefc = snd_hda_codec_get_pincfg(codec, cfg->inputs[i].pin);\r\nattr2 = snd_hda_get_input_pin_attr(defc);\r\nif (attr2 >= INPUT_PIN_ATTR_NORMAL) {\r\nif (attr && attr != attr2)\r\nreturn 1;\r\nattr = attr2;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nconst char *hda_get_autocfg_input_label(struct hda_codec *codec,\r\nconst struct auto_pin_cfg *cfg,\r\nint input)\r\n{\r\nint type = cfg->inputs[input].type;\r\nint has_multiple_pins = 0;\r\nif ((input > 0 && cfg->inputs[input - 1].type == type) ||\r\n(input < cfg->num_inputs - 1 && cfg->inputs[input + 1].type == type))\r\nhas_multiple_pins = 1;\r\nif (has_multiple_pins && type == AUTO_PIN_MIC)\r\nhas_multiple_pins &= check_mic_location_need(codec, cfg, input);\r\nhas_multiple_pins |= codec->force_pin_prefix;\r\nreturn hda_get_input_pin_label(codec, &cfg->inputs[input],\r\ncfg->inputs[input].pin,\r\nhas_multiple_pins);\r\n}\r\nstatic int find_idx_in_nid_list(hda_nid_t nid, const hda_nid_t *list, int nums)\r\n{\r\nint i;\r\nfor (i = 0; i < nums; i++)\r\nif (list[i] == nid)\r\nreturn i;\r\nreturn -1;\r\n}\r\nstatic const char *check_output_sfx(hda_nid_t nid, const hda_nid_t *pins,\r\nint num_pins, int *indexp)\r\n{\r\nstatic const char * const channel_sfx[] = {\r\n" Front", " Surround", " CLFE", " Side"\r\n};\r\nint i;\r\ni = find_idx_in_nid_list(nid, pins, num_pins);\r\nif (i < 0)\r\nreturn NULL;\r\nif (num_pins == 1)\r\nreturn "";\r\nif (num_pins > ARRAY_SIZE(channel_sfx)) {\r\nif (indexp)\r\n*indexp = i;\r\nreturn "";\r\n}\r\nreturn channel_sfx[i];\r\n}\r\nstatic const char *check_output_pfx(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nunsigned int def_conf = snd_hda_codec_get_pincfg(codec, nid);\r\nint attr = snd_hda_get_input_pin_attr(def_conf);\r\nswitch (attr) {\r\ncase INPUT_PIN_ATTR_DOCK:\r\nreturn "Dock ";\r\ncase INPUT_PIN_ATTR_FRONT:\r\nreturn "Front ";\r\n}\r\nreturn "";\r\n}\r\nstatic int get_hp_label_index(struct hda_codec *codec, hda_nid_t nid,\r\nconst hda_nid_t *pins, int num_pins)\r\n{\r\nint i, j, idx = 0;\r\nconst char *pfx = check_output_pfx(codec, nid);\r\ni = find_idx_in_nid_list(nid, pins, num_pins);\r\nif (i < 0)\r\nreturn -1;\r\nfor (j = 0; j < i; j++)\r\nif (pfx == check_output_pfx(codec, pins[j]))\r\nidx++;\r\nreturn idx;\r\n}\r\nstatic int fill_audio_out_name(struct hda_codec *codec, hda_nid_t nid,\r\nconst struct auto_pin_cfg *cfg,\r\nconst char *name, char *label, int maxlen,\r\nint *indexp)\r\n{\r\nunsigned int def_conf = snd_hda_codec_get_pincfg(codec, nid);\r\nint attr = snd_hda_get_input_pin_attr(def_conf);\r\nconst char *pfx, *sfx = "";\r\nif (!strcmp(name, "Line Out") && attr == INPUT_PIN_ATTR_INT)\r\nname = "Speaker";\r\npfx = check_output_pfx(codec, nid);\r\nif (cfg) {\r\nsfx = check_output_sfx(nid, cfg->line_out_pins, cfg->line_outs,\r\nindexp);\r\nif (!sfx)\r\nsfx = check_output_sfx(nid, cfg->speaker_pins, cfg->speaker_outs,\r\nindexp);\r\nif (!sfx) {\r\nint idx = get_hp_label_index(codec, nid, cfg->hp_pins,\r\ncfg->hp_outs);\r\nif (idx >= 0 && indexp)\r\n*indexp = idx;\r\nsfx = "";\r\n}\r\n}\r\nsnprintf(label, maxlen, "%s%s%s", pfx, name, sfx);\r\nreturn 1;\r\n}\r\nint snd_hda_get_pin_label(struct hda_codec *codec, hda_nid_t nid,\r\nconst struct auto_pin_cfg *cfg,\r\nchar *label, int maxlen, int *indexp)\r\n{\r\nunsigned int def_conf = snd_hda_codec_get_pincfg(codec, nid);\r\nconst char *name = NULL;\r\nint i;\r\nbool hdmi;\r\nif (indexp)\r\n*indexp = 0;\r\nif (get_defcfg_connect(def_conf) == AC_JACK_PORT_NONE)\r\nreturn 0;\r\nswitch (get_defcfg_device(def_conf)) {\r\ncase AC_JACK_LINE_OUT:\r\nreturn fill_audio_out_name(codec, nid, cfg, "Line Out",\r\nlabel, maxlen, indexp);\r\ncase AC_JACK_SPEAKER:\r\nreturn fill_audio_out_name(codec, nid, cfg, "Speaker",\r\nlabel, maxlen, indexp);\r\ncase AC_JACK_HP_OUT:\r\nreturn fill_audio_out_name(codec, nid, cfg, "Headphone",\r\nlabel, maxlen, indexp);\r\ncase AC_JACK_SPDIF_OUT:\r\ncase AC_JACK_DIG_OTHER_OUT:\r\nhdmi = is_hdmi_cfg(def_conf);\r\nname = hdmi ? "HDMI" : "SPDIF";\r\nif (cfg && indexp)\r\nfor (i = 0; i < cfg->dig_outs; i++) {\r\nhda_nid_t pin = cfg->dig_out_pins[i];\r\nunsigned int c;\r\nif (pin == nid)\r\nbreak;\r\nc = snd_hda_codec_get_pincfg(codec, pin);\r\nif (hdmi == is_hdmi_cfg(c))\r\n(*indexp)++;\r\n}\r\nbreak;\r\ndefault:\r\nif (cfg) {\r\nfor (i = 0; i < cfg->num_inputs; i++) {\r\nif (cfg->inputs[i].pin != nid)\r\ncontinue;\r\nname = hda_get_autocfg_input_label(codec, cfg, i);\r\nif (name)\r\nbreak;\r\n}\r\n}\r\nif (!name)\r\nname = hda_get_input_pin_label(codec, NULL, nid, true);\r\nbreak;\r\n}\r\nif (!name)\r\nreturn 0;\r\nstrlcpy(label, name, maxlen);\r\nreturn 1;\r\n}\r\nint snd_hda_add_verbs(struct hda_codec *codec,\r\nconst struct hda_verb *list)\r\n{\r\nconst struct hda_verb **v;\r\nv = snd_array_new(&codec->verbs);\r\nif (!v)\r\nreturn -ENOMEM;\r\n*v = list;\r\nreturn 0;\r\n}\r\nvoid snd_hda_apply_verbs(struct hda_codec *codec)\r\n{\r\nint i;\r\nfor (i = 0; i < codec->verbs.used; i++) {\r\nstruct hda_verb **v = snd_array_elem(&codec->verbs, i);\r\nsnd_hda_sequence_write(codec, *v);\r\n}\r\n}\r\nvoid snd_hda_apply_pincfgs(struct hda_codec *codec,\r\nconst struct hda_pintbl *cfg)\r\n{\r\nfor (; cfg->nid; cfg++)\r\nsnd_hda_codec_set_pincfg(codec, cfg->nid, cfg->val);\r\n}\r\nstatic void set_pin_targets(struct hda_codec *codec,\r\nconst struct hda_pintbl *cfg)\r\n{\r\nfor (; cfg->nid; cfg++)\r\nsnd_hda_set_pin_ctl_cache(codec, cfg->nid, cfg->val);\r\n}\r\nstatic void apply_fixup(struct hda_codec *codec, int id, int action, int depth)\r\n{\r\nconst char *modelname = codec->fixup_name;\r\nwhile (id >= 0) {\r\nconst struct hda_fixup *fix = codec->fixup_list + id;\r\nif (fix->chained_before)\r\napply_fixup(codec, fix->chain_id, action, depth + 1);\r\nswitch (fix->type) {\r\ncase HDA_FIXUP_PINS:\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE || !fix->v.pins)\r\nbreak;\r\ncodec_dbg(codec, "%s: Apply pincfg for %s\n",\r\ncodec->core.chip_name, modelname);\r\nsnd_hda_apply_pincfgs(codec, fix->v.pins);\r\nbreak;\r\ncase HDA_FIXUP_VERBS:\r\nif (action != HDA_FIXUP_ACT_PROBE || !fix->v.verbs)\r\nbreak;\r\ncodec_dbg(codec, "%s: Apply fix-verbs for %s\n",\r\ncodec->core.chip_name, modelname);\r\nsnd_hda_add_verbs(codec, fix->v.verbs);\r\nbreak;\r\ncase HDA_FIXUP_FUNC:\r\nif (!fix->v.func)\r\nbreak;\r\ncodec_dbg(codec, "%s: Apply fix-func for %s\n",\r\ncodec->core.chip_name, modelname);\r\nfix->v.func(codec, fix, action);\r\nbreak;\r\ncase HDA_FIXUP_PINCTLS:\r\nif (action != HDA_FIXUP_ACT_PROBE || !fix->v.pins)\r\nbreak;\r\ncodec_dbg(codec, "%s: Apply pinctl for %s\n",\r\ncodec->core.chip_name, modelname);\r\nset_pin_targets(codec, fix->v.pins);\r\nbreak;\r\ndefault:\r\ncodec_err(codec, "%s: Invalid fixup type %d\n",\r\ncodec->core.chip_name, fix->type);\r\nbreak;\r\n}\r\nif (!fix->chained || fix->chained_before)\r\nbreak;\r\nif (++depth > 10)\r\nbreak;\r\nid = fix->chain_id;\r\n}\r\n}\r\nvoid snd_hda_apply_fixup(struct hda_codec *codec, int action)\r\n{\r\nif (codec->fixup_list)\r\napply_fixup(codec, codec->fixup_id, action, 0);\r\n}\r\nstatic bool pin_config_match(struct hda_codec *codec,\r\nconst struct hda_pintbl *pins)\r\n{\r\nint i;\r\nfor (i = 0; i < codec->init_pins.used; i++) {\r\nstruct hda_pincfg *pin = snd_array_elem(&codec->init_pins, i);\r\nhda_nid_t nid = pin->nid;\r\nu32 cfg = pin->cfg;\r\nconst struct hda_pintbl *t_pins;\r\nint found;\r\nt_pins = pins;\r\nfound = 0;\r\nfor (; t_pins->nid; t_pins++) {\r\nif (t_pins->nid == nid) {\r\nfound = 1;\r\nif ((t_pins->val & IGNORE_SEQ_ASSOC) == (cfg & IGNORE_SEQ_ASSOC))\r\nbreak;\r\nelse if ((cfg & 0xf0000000) == 0x40000000 && (t_pins->val & 0xf0000000) == 0x40000000)\r\nbreak;\r\nelse\r\nreturn false;\r\n}\r\n}\r\nif (!found && (cfg & 0xf0000000) != 0x40000000)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nvoid snd_hda_pick_pin_fixup(struct hda_codec *codec,\r\nconst struct snd_hda_pin_quirk *pin_quirk,\r\nconst struct hda_fixup *fixlist)\r\n{\r\nconst struct snd_hda_pin_quirk *pq;\r\nif (codec->fixup_id != HDA_FIXUP_ID_NOT_SET)\r\nreturn;\r\nfor (pq = pin_quirk; pq->subvendor; pq++) {\r\nif ((codec->core.subsystem_id & 0xffff0000) != (pq->subvendor << 16))\r\ncontinue;\r\nif (codec->core.vendor_id != pq->codec)\r\ncontinue;\r\nif (pin_config_match(codec, pq->pins)) {\r\ncodec->fixup_id = pq->value;\r\n#ifdef CONFIG_SND_DEBUG_VERBOSE\r\ncodec->fixup_name = pq->name;\r\ncodec_dbg(codec, "%s: picked fixup %s (pin match)\n",\r\ncodec->core.chip_name, codec->fixup_name);\r\n#endif\r\ncodec->fixup_list = fixlist;\r\nreturn;\r\n}\r\n}\r\n}\r\nvoid snd_hda_pick_fixup(struct hda_codec *codec,\r\nconst struct hda_model_fixup *models,\r\nconst struct snd_pci_quirk *quirk,\r\nconst struct hda_fixup *fixlist)\r\n{\r\nconst struct snd_pci_quirk *q;\r\nint id = HDA_FIXUP_ID_NOT_SET;\r\nconst char *name = NULL;\r\nif (codec->fixup_id != HDA_FIXUP_ID_NOT_SET)\r\nreturn;\r\nif (codec->modelname && !strcmp(codec->modelname, "nofixup")) {\r\ncodec->fixup_list = NULL;\r\ncodec->fixup_name = NULL;\r\ncodec->fixup_id = HDA_FIXUP_ID_NO_FIXUP;\r\ncodec_dbg(codec, "%s: picked no fixup (nofixup specified)\n",\r\ncodec->core.chip_name);\r\nreturn;\r\n}\r\nif (codec->modelname && models) {\r\nwhile (models->name) {\r\nif (!strcmp(codec->modelname, models->name)) {\r\ncodec->fixup_id = models->id;\r\ncodec->fixup_name = models->name;\r\ncodec->fixup_list = fixlist;\r\ncodec_dbg(codec, "%s: picked fixup %s (model specified)\n",\r\ncodec->core.chip_name, codec->fixup_name);\r\nreturn;\r\n}\r\nmodels++;\r\n}\r\n}\r\nif (quirk) {\r\nq = snd_pci_quirk_lookup(codec->bus->pci, quirk);\r\nif (q) {\r\nid = q->value;\r\n#ifdef CONFIG_SND_DEBUG_VERBOSE\r\nname = q->name;\r\ncodec_dbg(codec, "%s: picked fixup %s (PCI SSID%s)\n",\r\ncodec->core.chip_name, name, q->subdevice_mask ? "" : " - vendor generic");\r\n#endif\r\n}\r\n}\r\nif (id < 0 && quirk) {\r\nfor (q = quirk; q->subvendor || q->subdevice; q++) {\r\nunsigned int vendorid =\r\nq->subdevice | (q->subvendor << 16);\r\nunsigned int mask = 0xffff0000 | q->subdevice_mask;\r\nif ((codec->core.subsystem_id & mask) == (vendorid & mask)) {\r\nid = q->value;\r\n#ifdef CONFIG_SND_DEBUG_VERBOSE\r\nname = q->name;\r\ncodec_dbg(codec, "%s: picked fixup %s (codec SSID)\n",\r\ncodec->core.chip_name, name);\r\n#endif\r\nbreak;\r\n}\r\n}\r\n}\r\ncodec->fixup_id = id;\r\nif (id >= 0) {\r\ncodec->fixup_list = fixlist;\r\ncodec->fixup_name = name;\r\n}\r\n}
