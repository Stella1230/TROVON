int\r\nsnd_emu10k1_sample_new(struct snd_emux *rec, struct snd_sf_sample *sp,\r\nstruct snd_util_memhdr *hdr,\r\nconst void __user *data, long count)\r\n{\r\nint offset;\r\nint truesize, size, loopsize, blocksize;\r\nint loopend, sampleend;\r\nunsigned int start_addr;\r\nstruct snd_emu10k1 *emu;\r\nemu = rec->hw;\r\nif (snd_BUG_ON(!sp || !hdr))\r\nreturn -EINVAL;\r\nif (sp->v.size == 0) {\r\ndev_dbg(emu->card->dev,\r\n"emu: rom font for sample %d\n", sp->v.sample);\r\nreturn 0;\r\n}\r\nsp->v.end -= sp->v.start;\r\nsp->v.loopstart -= sp->v.start;\r\nsp->v.loopend -= sp->v.start;\r\nsp->v.start = 0;\r\nsampleend = sp->v.end;\r\nif (sampleend > sp->v.size)\r\nsampleend = sp->v.size;\r\nloopend = sp->v.loopend;\r\nif (loopend > sampleend)\r\nloopend = sampleend;\r\nif (sp->v.loopstart >= sp->v.loopend) {\r\nint tmp = sp->v.loopstart;\r\nsp->v.loopstart = sp->v.loopend;\r\nsp->v.loopend = tmp;\r\n}\r\ntruesize = sp->v.size + BLANK_HEAD_SIZE;\r\nloopsize = 0;\r\n#if 0\r\nif (sp->v.mode_flags & (SNDRV_SFNT_SAMPLE_BIDIR_LOOP|SNDRV_SFNT_SAMPLE_REVERSE_LOOP))\r\nloopsize = sp->v.loopend - sp->v.loopstart;\r\ntruesize += loopsize;\r\n#endif\r\nif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_NO_BLANK)\r\ntruesize += BLANK_LOOP_SIZE;\r\nblocksize = truesize;\r\nif (! (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS))\r\nblocksize *= 2;\r\nsp->block = snd_emu10k1_synth_alloc(emu, blocksize);\r\nif (sp->block == NULL) {\r\ndev_dbg(emu->card->dev,\r\n"synth malloc failed (size=%d)\n", blocksize);\r\nreturn -ENOSPC;\r\n}\r\nsp->v.truesize = blocksize;\r\noffset = 0;\r\nsize = BLANK_HEAD_SIZE;\r\nif (! (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS))\r\nsize *= 2;\r\nif (offset + size > blocksize)\r\nreturn -EINVAL;\r\nsnd_emu10k1_synth_bzero(emu, sp->block, offset, size);\r\noffset += size;\r\nsize = loopend;\r\nif (! (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS))\r\nsize *= 2;\r\nif (offset + size > blocksize)\r\nreturn -EINVAL;\r\nif (snd_emu10k1_synth_copy_from_user(emu, sp->block, offset, data, size)) {\r\nsnd_emu10k1_synth_free(emu, sp->block);\r\nsp->block = NULL;\r\nreturn -EFAULT;\r\n}\r\noffset += size;\r\ndata += size;\r\n#if 0\r\nif (sp->v.mode_flags & (SNDRV_SFNT_SAMPLE_BIDIR_LOOP|SNDRV_SFNT_SAMPLE_REVERSE_LOOP)) {\r\nif (! (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS)) {\r\nint woffset;\r\nunsigned short *wblock = (unsigned short*)block;\r\nwoffset = offset / 2;\r\nif (offset + loopsize * 2 > blocksize)\r\nreturn -EINVAL;\r\nfor (i = 0; i < loopsize; i++)\r\nwblock[woffset + i] = wblock[woffset - i -1];\r\noffset += loopsize * 2;\r\n} else {\r\nif (offset + loopsize > blocksize)\r\nreturn -EINVAL;\r\nfor (i = 0; i < loopsize; i++)\r\nblock[offset + i] = block[offset - i -1];\r\noffset += loopsize;\r\n}\r\nif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_BIDIR_LOOP) {\r\nsp->v.loopend += loopsize;\r\n} else {\r\nsp->v.loopstart += loopsize;\r\nsp->v.loopend += loopsize;\r\n}\r\nsp->v.end += loopsize;\r\n}\r\n#endif\r\nsize = sp->v.size - loopend;\r\nif (size < 0)\r\nreturn -EINVAL;\r\nif (! (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS))\r\nsize *= 2;\r\nif (snd_emu10k1_synth_copy_from_user(emu, sp->block, offset, data, size)) {\r\nsnd_emu10k1_synth_free(emu, sp->block);\r\nsp->block = NULL;\r\nreturn -EFAULT;\r\n}\r\noffset += size;\r\nif (offset < blocksize)\r\nsnd_emu10k1_synth_bzero(emu, sp->block, offset, blocksize - offset);\r\nif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_NO_BLANK) {\r\nif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_SINGLESHOT) {\r\nsp->v.loopstart = sp->v.end + BLANK_LOOP_START;\r\nsp->v.loopend = sp->v.end + BLANK_LOOP_END;\r\n}\r\n}\r\n#if 0\r\nif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_UNSIGNED) {\r\nif (! (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS)) {\r\nunsigned short *wblock = (unsigned short*)block;\r\nfor (i = 0; i < truesize; i++)\r\nwblock[i] ^= 0x8000;\r\n} else {\r\nfor (i = 0; i < truesize; i++)\r\nblock[i] ^= 0x80;\r\n}\r\n}\r\n#endif\r\nstart_addr = BLANK_HEAD_SIZE * 2;\r\nif (! (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS))\r\nstart_addr >>= 1;\r\nsp->v.start += start_addr;\r\nsp->v.end += start_addr;\r\nsp->v.loopstart += start_addr;\r\nsp->v.loopend += start_addr;\r\nreturn 0;\r\n}\r\nint\r\nsnd_emu10k1_sample_free(struct snd_emux *rec, struct snd_sf_sample *sp,\r\nstruct snd_util_memhdr *hdr)\r\n{\r\nstruct snd_emu10k1 *emu;\r\nemu = rec->hw;\r\nif (snd_BUG_ON(!sp || !hdr))\r\nreturn -EINVAL;\r\nif (sp->block) {\r\nsnd_emu10k1_synth_free(emu, sp->block);\r\nsp->block = NULL;\r\n}\r\nreturn 0;\r\n}
