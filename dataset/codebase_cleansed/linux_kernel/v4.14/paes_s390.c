static inline int __paes_convert_key(struct pkey_seckey *sk,\r\nstruct pkey_protkey *pk)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < 3; i++) {\r\nret = pkey_skey2pkey(sk, pk);\r\nif (ret == 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __paes_set_key(struct s390_paes_ctx *ctx)\r\n{\r\nunsigned long fc;\r\nif (__paes_convert_key(&ctx->sk, &ctx->pk))\r\nreturn -EINVAL;\r\nfc = (ctx->pk.type == PKEY_KEYTYPE_AES_128) ? CPACF_KM_PAES_128 :\r\n(ctx->pk.type == PKEY_KEYTYPE_AES_192) ? CPACF_KM_PAES_192 :\r\n(ctx->pk.type == PKEY_KEYTYPE_AES_256) ? CPACF_KM_PAES_256 : 0;\r\nctx->fc = (fc && cpacf_test_func(&km_functions, fc)) ? fc : 0;\r\nreturn ctx->fc ? 0 : -EINVAL;\r\n}\r\nstatic int ecb_paes_set_key(struct crypto_tfm *tfm, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct s390_paes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nif (key_len != SECKEYBLOBSIZE)\r\nreturn -EINVAL;\r\nmemcpy(ctx->sk.seckey, in_key, SECKEYBLOBSIZE);\r\nif (__paes_set_key(ctx)) {\r\ntfm->crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ecb_paes_crypt(struct blkcipher_desc *desc,\r\nunsigned long modifier,\r\nstruct blkcipher_walk *walk)\r\n{\r\nstruct s390_paes_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nunsigned int nbytes, n, k;\r\nint ret;\r\nret = blkcipher_walk_virt(desc, walk);\r\nwhile ((nbytes = walk->nbytes) >= AES_BLOCK_SIZE) {\r\nn = nbytes & ~(AES_BLOCK_SIZE - 1);\r\nk = cpacf_km(ctx->fc | modifier, ctx->pk.protkey,\r\nwalk->dst.virt.addr, walk->src.virt.addr, n);\r\nif (k)\r\nret = blkcipher_walk_done(desc, walk, nbytes - k);\r\nif (k < n) {\r\nif (__paes_set_key(ctx) != 0)\r\nreturn blkcipher_walk_done(desc, walk, -EIO);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ecb_paes_encrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nreturn ecb_paes_crypt(desc, CPACF_ENCRYPT, &walk);\r\n}\r\nstatic int ecb_paes_decrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nreturn ecb_paes_crypt(desc, CPACF_DECRYPT, &walk);\r\n}\r\nstatic int __cbc_paes_set_key(struct s390_paes_ctx *ctx)\r\n{\r\nunsigned long fc;\r\nif (__paes_convert_key(&ctx->sk, &ctx->pk))\r\nreturn -EINVAL;\r\nfc = (ctx->pk.type == PKEY_KEYTYPE_AES_128) ? CPACF_KMC_PAES_128 :\r\n(ctx->pk.type == PKEY_KEYTYPE_AES_192) ? CPACF_KMC_PAES_192 :\r\n(ctx->pk.type == PKEY_KEYTYPE_AES_256) ? CPACF_KMC_PAES_256 : 0;\r\nctx->fc = (fc && cpacf_test_func(&kmc_functions, fc)) ? fc : 0;\r\nreturn ctx->fc ? 0 : -EINVAL;\r\n}\r\nstatic int cbc_paes_set_key(struct crypto_tfm *tfm, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct s390_paes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nmemcpy(ctx->sk.seckey, in_key, SECKEYBLOBSIZE);\r\nif (__cbc_paes_set_key(ctx)) {\r\ntfm->crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cbc_paes_crypt(struct blkcipher_desc *desc, unsigned long modifier,\r\nstruct blkcipher_walk *walk)\r\n{\r\nstruct s390_paes_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nunsigned int nbytes, n, k;\r\nint ret;\r\nstruct {\r\nu8 iv[AES_BLOCK_SIZE];\r\nu8 key[MAXPROTKEYSIZE];\r\n} param;\r\nret = blkcipher_walk_virt(desc, walk);\r\nmemcpy(param.iv, walk->iv, AES_BLOCK_SIZE);\r\nmemcpy(param.key, ctx->pk.protkey, MAXPROTKEYSIZE);\r\nwhile ((nbytes = walk->nbytes) >= AES_BLOCK_SIZE) {\r\nn = nbytes & ~(AES_BLOCK_SIZE - 1);\r\nk = cpacf_kmc(ctx->fc | modifier, &param,\r\nwalk->dst.virt.addr, walk->src.virt.addr, n);\r\nif (k)\r\nret = blkcipher_walk_done(desc, walk, nbytes - k);\r\nif (n < k) {\r\nif (__cbc_paes_set_key(ctx) != 0)\r\nreturn blkcipher_walk_done(desc, walk, -EIO);\r\nmemcpy(param.key, ctx->pk.protkey, MAXPROTKEYSIZE);\r\n}\r\n}\r\nmemcpy(walk->iv, param.iv, AES_BLOCK_SIZE);\r\nreturn ret;\r\n}\r\nstatic int cbc_paes_encrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nreturn cbc_paes_crypt(desc, 0, &walk);\r\n}\r\nstatic int cbc_paes_decrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nreturn cbc_paes_crypt(desc, CPACF_DECRYPT, &walk);\r\n}\r\nstatic int __xts_paes_set_key(struct s390_pxts_ctx *ctx)\r\n{\r\nunsigned long fc;\r\nif (__paes_convert_key(&ctx->sk[0], &ctx->pk[0]) ||\r\n__paes_convert_key(&ctx->sk[1], &ctx->pk[1]))\r\nreturn -EINVAL;\r\nif (ctx->pk[0].type != ctx->pk[1].type)\r\nreturn -EINVAL;\r\nfc = (ctx->pk[0].type == PKEY_KEYTYPE_AES_128) ? CPACF_KM_PXTS_128 :\r\n(ctx->pk[0].type == PKEY_KEYTYPE_AES_256) ?\r\nCPACF_KM_PXTS_256 : 0;\r\nctx->fc = (fc && cpacf_test_func(&km_functions, fc)) ? fc : 0;\r\nreturn ctx->fc ? 0 : -EINVAL;\r\n}\r\nstatic int xts_paes_set_key(struct crypto_tfm *tfm, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct s390_pxts_ctx *ctx = crypto_tfm_ctx(tfm);\r\nu8 ckey[2 * AES_MAX_KEY_SIZE];\r\nunsigned int ckey_len;\r\nmemcpy(ctx->sk[0].seckey, in_key, SECKEYBLOBSIZE);\r\nmemcpy(ctx->sk[1].seckey, in_key + SECKEYBLOBSIZE, SECKEYBLOBSIZE);\r\nif (__xts_paes_set_key(ctx)) {\r\ntfm->crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;\r\nreturn -EINVAL;\r\n}\r\nckey_len = (ctx->pk[0].type == PKEY_KEYTYPE_AES_128) ?\r\nAES_KEYSIZE_128 : AES_KEYSIZE_256;\r\nmemcpy(ckey, ctx->pk[0].protkey, ckey_len);\r\nmemcpy(ckey + ckey_len, ctx->pk[1].protkey, ckey_len);\r\nreturn xts_check_key(tfm, ckey, 2*ckey_len);\r\n}\r\nstatic int xts_paes_crypt(struct blkcipher_desc *desc, unsigned long modifier,\r\nstruct blkcipher_walk *walk)\r\n{\r\nstruct s390_pxts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nunsigned int keylen, offset, nbytes, n, k;\r\nint ret;\r\nstruct {\r\nu8 key[MAXPROTKEYSIZE];\r\nu8 tweak[16];\r\nu8 block[16];\r\nu8 bit[16];\r\nu8 xts[16];\r\n} pcc_param;\r\nstruct {\r\nu8 key[MAXPROTKEYSIZE];\r\nu8 init[16];\r\n} xts_param;\r\nret = blkcipher_walk_virt(desc, walk);\r\nkeylen = (ctx->pk[0].type == PKEY_KEYTYPE_AES_128) ? 48 : 64;\r\noffset = (ctx->pk[0].type == PKEY_KEYTYPE_AES_128) ? 16 : 0;\r\nretry:\r\nmemset(&pcc_param, 0, sizeof(pcc_param));\r\nmemcpy(pcc_param.tweak, walk->iv, sizeof(pcc_param.tweak));\r\nmemcpy(pcc_param.key + offset, ctx->pk[1].protkey, keylen);\r\ncpacf_pcc(ctx->fc, pcc_param.key + offset);\r\nmemcpy(xts_param.key + offset, ctx->pk[0].protkey, keylen);\r\nmemcpy(xts_param.init, pcc_param.xts, 16);\r\nwhile ((nbytes = walk->nbytes) >= AES_BLOCK_SIZE) {\r\nn = nbytes & ~(AES_BLOCK_SIZE - 1);\r\nk = cpacf_km(ctx->fc | modifier, xts_param.key + offset,\r\nwalk->dst.virt.addr, walk->src.virt.addr, n);\r\nif (k)\r\nret = blkcipher_walk_done(desc, walk, nbytes - k);\r\nif (k < n) {\r\nif (__xts_paes_set_key(ctx) != 0)\r\nreturn blkcipher_walk_done(desc, walk, -EIO);\r\ngoto retry;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int xts_paes_encrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nreturn xts_paes_crypt(desc, 0, &walk);\r\n}\r\nstatic int xts_paes_decrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nreturn xts_paes_crypt(desc, CPACF_DECRYPT, &walk);\r\n}\r\nstatic int __ctr_paes_set_key(struct s390_paes_ctx *ctx)\r\n{\r\nunsigned long fc;\r\nif (__paes_convert_key(&ctx->sk, &ctx->pk))\r\nreturn -EINVAL;\r\nfc = (ctx->pk.type == PKEY_KEYTYPE_AES_128) ? CPACF_KMCTR_PAES_128 :\r\n(ctx->pk.type == PKEY_KEYTYPE_AES_192) ? CPACF_KMCTR_PAES_192 :\r\n(ctx->pk.type == PKEY_KEYTYPE_AES_256) ?\r\nCPACF_KMCTR_PAES_256 : 0;\r\nctx->fc = (fc && cpacf_test_func(&kmctr_functions, fc)) ? fc : 0;\r\nreturn ctx->fc ? 0 : -EINVAL;\r\n}\r\nstatic int ctr_paes_set_key(struct crypto_tfm *tfm, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct s390_paes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nmemcpy(ctx->sk.seckey, in_key, key_len);\r\nif (__ctr_paes_set_key(ctx)) {\r\ntfm->crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int __ctrblk_init(u8 *ctrptr, u8 *iv, unsigned int nbytes)\r\n{\r\nunsigned int i, n;\r\nmemcpy(ctrptr, iv, AES_BLOCK_SIZE);\r\nn = (nbytes > PAGE_SIZE) ? PAGE_SIZE : nbytes & ~(AES_BLOCK_SIZE - 1);\r\nfor (i = (n / AES_BLOCK_SIZE) - 1; i > 0; i--) {\r\nmemcpy(ctrptr + AES_BLOCK_SIZE, ctrptr, AES_BLOCK_SIZE);\r\ncrypto_inc(ctrptr + AES_BLOCK_SIZE, AES_BLOCK_SIZE);\r\nctrptr += AES_BLOCK_SIZE;\r\n}\r\nreturn n;\r\n}\r\nstatic int ctr_paes_crypt(struct blkcipher_desc *desc, unsigned long modifier,\r\nstruct blkcipher_walk *walk)\r\n{\r\nstruct s390_paes_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nu8 buf[AES_BLOCK_SIZE], *ctrptr;\r\nunsigned int nbytes, n, k;\r\nint ret, locked;\r\nlocked = spin_trylock(&ctrblk_lock);\r\nret = blkcipher_walk_virt_block(desc, walk, AES_BLOCK_SIZE);\r\nwhile ((nbytes = walk->nbytes) >= AES_BLOCK_SIZE) {\r\nn = AES_BLOCK_SIZE;\r\nif (nbytes >= 2*AES_BLOCK_SIZE && locked)\r\nn = __ctrblk_init(ctrblk, walk->iv, nbytes);\r\nctrptr = (n > AES_BLOCK_SIZE) ? ctrblk : walk->iv;\r\nk = cpacf_kmctr(ctx->fc | modifier, ctx->pk.protkey,\r\nwalk->dst.virt.addr, walk->src.virt.addr,\r\nn, ctrptr);\r\nif (k) {\r\nif (ctrptr == ctrblk)\r\nmemcpy(walk->iv, ctrptr + k - AES_BLOCK_SIZE,\r\nAES_BLOCK_SIZE);\r\ncrypto_inc(walk->iv, AES_BLOCK_SIZE);\r\nret = blkcipher_walk_done(desc, walk, nbytes - n);\r\n}\r\nif (k < n) {\r\nif (__ctr_paes_set_key(ctx) != 0) {\r\nif (locked)\r\nspin_unlock(&ctrblk_lock);\r\nreturn blkcipher_walk_done(desc, walk, -EIO);\r\n}\r\n}\r\n}\r\nif (locked)\r\nspin_unlock(&ctrblk_lock);\r\nif (nbytes) {\r\nwhile (1) {\r\nif (cpacf_kmctr(ctx->fc | modifier,\r\nctx->pk.protkey, buf,\r\nwalk->src.virt.addr, AES_BLOCK_SIZE,\r\nwalk->iv) == AES_BLOCK_SIZE)\r\nbreak;\r\nif (__ctr_paes_set_key(ctx) != 0)\r\nreturn blkcipher_walk_done(desc, walk, -EIO);\r\n}\r\nmemcpy(walk->dst.virt.addr, buf, nbytes);\r\ncrypto_inc(walk->iv, AES_BLOCK_SIZE);\r\nret = blkcipher_walk_done(desc, walk, 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ctr_paes_encrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nreturn ctr_paes_crypt(desc, 0, &walk);\r\n}\r\nstatic int ctr_paes_decrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nreturn ctr_paes_crypt(desc, CPACF_DECRYPT, &walk);\r\n}\r\nstatic inline void __crypto_unregister_alg(struct crypto_alg *alg)\r\n{\r\nif (!list_empty(&alg->cra_list))\r\ncrypto_unregister_alg(alg);\r\n}\r\nstatic void paes_s390_fini(void)\r\n{\r\nif (ctrblk)\r\nfree_page((unsigned long) ctrblk);\r\n__crypto_unregister_alg(&ctr_paes_alg);\r\n__crypto_unregister_alg(&xts_paes_alg);\r\n__crypto_unregister_alg(&cbc_paes_alg);\r\n__crypto_unregister_alg(&ecb_paes_alg);\r\n}\r\nstatic int __init paes_s390_init(void)\r\n{\r\nint ret;\r\ncpacf_query(CPACF_KM, &km_functions);\r\ncpacf_query(CPACF_KMC, &kmc_functions);\r\ncpacf_query(CPACF_KMCTR, &kmctr_functions);\r\nif (cpacf_test_func(&km_functions, CPACF_KM_PAES_128) ||\r\ncpacf_test_func(&km_functions, CPACF_KM_PAES_192) ||\r\ncpacf_test_func(&km_functions, CPACF_KM_PAES_256)) {\r\nret = crypto_register_alg(&ecb_paes_alg);\r\nif (ret)\r\ngoto out_err;\r\n}\r\nif (cpacf_test_func(&kmc_functions, CPACF_KMC_PAES_128) ||\r\ncpacf_test_func(&kmc_functions, CPACF_KMC_PAES_192) ||\r\ncpacf_test_func(&kmc_functions, CPACF_KMC_PAES_256)) {\r\nret = crypto_register_alg(&cbc_paes_alg);\r\nif (ret)\r\ngoto out_err;\r\n}\r\nif (cpacf_test_func(&km_functions, CPACF_KM_PXTS_128) ||\r\ncpacf_test_func(&km_functions, CPACF_KM_PXTS_256)) {\r\nret = crypto_register_alg(&xts_paes_alg);\r\nif (ret)\r\ngoto out_err;\r\n}\r\nif (cpacf_test_func(&kmctr_functions, CPACF_KMCTR_PAES_128) ||\r\ncpacf_test_func(&kmctr_functions, CPACF_KMCTR_PAES_192) ||\r\ncpacf_test_func(&kmctr_functions, CPACF_KMCTR_PAES_256)) {\r\nret = crypto_register_alg(&ctr_paes_alg);\r\nif (ret)\r\ngoto out_err;\r\nctrblk = (u8 *) __get_free_page(GFP_KERNEL);\r\nif (!ctrblk) {\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\n}\r\nreturn 0;\r\nout_err:\r\npaes_s390_fini();\r\nreturn ret;\r\n}
