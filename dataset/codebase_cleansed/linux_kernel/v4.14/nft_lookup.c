static void nft_lookup_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_lookup *priv = nft_expr_priv(expr);\r\nconst struct nft_set *set = priv->set;\r\nconst struct nft_set_ext *ext;\r\nbool found;\r\nfound = set->ops->lookup(nft_net(pkt), set, &regs->data[priv->sreg],\r\n&ext) ^ priv->invert;\r\nif (!found) {\r\nregs->verdict.code = NFT_BREAK;\r\nreturn;\r\n}\r\nif (set->flags & NFT_SET_MAP)\r\nnft_data_copy(&regs->data[priv->dreg],\r\nnft_set_ext_data(ext), set->dlen);\r\n}\r\nstatic int nft_lookup_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_lookup *priv = nft_expr_priv(expr);\r\nu8 genmask = nft_genmask_next(ctx->net);\r\nstruct nft_set *set;\r\nu32 flags;\r\nint err;\r\nif (tb[NFTA_LOOKUP_SET] == NULL ||\r\ntb[NFTA_LOOKUP_SREG] == NULL)\r\nreturn -EINVAL;\r\nset = nft_set_lookup(ctx->net, ctx->table, tb[NFTA_LOOKUP_SET],\r\ntb[NFTA_LOOKUP_SET_ID], genmask);\r\nif (IS_ERR(set))\r\nreturn PTR_ERR(set);\r\nif (set->flags & NFT_SET_EVAL)\r\nreturn -EOPNOTSUPP;\r\npriv->sreg = nft_parse_register(tb[NFTA_LOOKUP_SREG]);\r\nerr = nft_validate_register_load(priv->sreg, set->klen);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[NFTA_LOOKUP_FLAGS]) {\r\nflags = ntohl(nla_get_be32(tb[NFTA_LOOKUP_FLAGS]));\r\nif (flags & ~NFT_LOOKUP_F_INV)\r\nreturn -EINVAL;\r\nif (flags & NFT_LOOKUP_F_INV) {\r\nif (set->flags & NFT_SET_MAP)\r\nreturn -EINVAL;\r\npriv->invert = true;\r\n}\r\n}\r\nif (tb[NFTA_LOOKUP_DREG] != NULL) {\r\nif (priv->invert)\r\nreturn -EINVAL;\r\nif (!(set->flags & NFT_SET_MAP))\r\nreturn -EINVAL;\r\npriv->dreg = nft_parse_register(tb[NFTA_LOOKUP_DREG]);\r\nerr = nft_validate_register_store(ctx, priv->dreg, NULL,\r\nset->dtype, set->dlen);\r\nif (err < 0)\r\nreturn err;\r\n} else if (set->flags & NFT_SET_MAP)\r\nreturn -EINVAL;\r\npriv->binding.flags = set->flags & NFT_SET_MAP;\r\nerr = nf_tables_bind_set(ctx, set, &priv->binding);\r\nif (err < 0)\r\nreturn err;\r\npriv->set = set;\r\nreturn 0;\r\n}\r\nstatic void nft_lookup_destroy(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr)\r\n{\r\nstruct nft_lookup *priv = nft_expr_priv(expr);\r\nnf_tables_unbind_set(ctx, priv->set, &priv->binding);\r\n}\r\nstatic int nft_lookup_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_lookup *priv = nft_expr_priv(expr);\r\nu32 flags = priv->invert ? NFT_LOOKUP_F_INV : 0;\r\nif (nla_put_string(skb, NFTA_LOOKUP_SET, priv->set->name))\r\ngoto nla_put_failure;\r\nif (nft_dump_register(skb, NFTA_LOOKUP_SREG, priv->sreg))\r\ngoto nla_put_failure;\r\nif (priv->set->flags & NFT_SET_MAP)\r\nif (nft_dump_register(skb, NFTA_LOOKUP_DREG, priv->dreg))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_LOOKUP_FLAGS, htonl(flags)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}
