static void print_regs(struct udc *dev)\r\n{\r\nDBG(dev, "------- Device registers -------\n");\r\nDBG(dev, "dev config = %08x\n", readl(&dev->regs->cfg));\r\nDBG(dev, "dev control = %08x\n", readl(&dev->regs->ctl));\r\nDBG(dev, "dev status = %08x\n", readl(&dev->regs->sts));\r\nDBG(dev, "\n");\r\nDBG(dev, "dev int's = %08x\n", readl(&dev->regs->irqsts));\r\nDBG(dev, "dev intmask = %08x\n", readl(&dev->regs->irqmsk));\r\nDBG(dev, "\n");\r\nDBG(dev, "dev ep int's = %08x\n", readl(&dev->regs->ep_irqsts));\r\nDBG(dev, "dev ep intmask = %08x\n", readl(&dev->regs->ep_irqmsk));\r\nDBG(dev, "\n");\r\nDBG(dev, "USE DMA = %d\n", use_dma);\r\nif (use_dma && use_dma_ppb && !use_dma_ppb_du) {\r\nDBG(dev, "DMA mode = PPBNDU (packet per buffer "\r\n"WITHOUT desc. update)\n");\r\ndev_info(dev->dev, "DMA mode (%s)\n", "PPBNDU");\r\n} else if (use_dma && use_dma_ppb && use_dma_ppb_du) {\r\nDBG(dev, "DMA mode = PPBDU (packet per buffer "\r\n"WITH desc. update)\n");\r\ndev_info(dev->dev, "DMA mode (%s)\n", "PPBDU");\r\n}\r\nif (use_dma && use_dma_bufferfill_mode) {\r\nDBG(dev, "DMA mode = BF (buffer fill mode)\n");\r\ndev_info(dev->dev, "DMA mode (%s)\n", "BF");\r\n}\r\nif (!use_dma)\r\ndev_info(dev->dev, "FIFO mode\n");\r\nDBG(dev, "-------------------------------------------------------\n");\r\n}\r\nint udc_mask_unused_interrupts(struct udc *dev)\r\n{\r\nu32 tmp;\r\ntmp = AMD_BIT(UDC_DEVINT_SVC) |\r\nAMD_BIT(UDC_DEVINT_ENUM) |\r\nAMD_BIT(UDC_DEVINT_US) |\r\nAMD_BIT(UDC_DEVINT_UR) |\r\nAMD_BIT(UDC_DEVINT_ES) |\r\nAMD_BIT(UDC_DEVINT_SI) |\r\nAMD_BIT(UDC_DEVINT_SOF)|\r\nAMD_BIT(UDC_DEVINT_SC);\r\nwritel(tmp, &dev->regs->irqmsk);\r\nwritel(UDC_EPINT_MSK_DISABLE_ALL, &dev->regs->ep_irqmsk);\r\nreturn 0;\r\n}\r\nstatic int udc_enable_ep0_interrupts(struct udc *dev)\r\n{\r\nu32 tmp;\r\nDBG(dev, "udc_enable_ep0_interrupts()\n");\r\ntmp = readl(&dev->regs->ep_irqmsk);\r\ntmp &= AMD_UNMASK_BIT(UDC_EPINT_IN_EP0)\r\n& AMD_UNMASK_BIT(UDC_EPINT_OUT_EP0);\r\nwritel(tmp, &dev->regs->ep_irqmsk);\r\nreturn 0;\r\n}\r\nint udc_enable_dev_setup_interrupts(struct udc *dev)\r\n{\r\nu32 tmp;\r\nDBG(dev, "enable device interrupts for setup data\n");\r\ntmp = readl(&dev->regs->irqmsk);\r\ntmp &= AMD_UNMASK_BIT(UDC_DEVINT_SI)\r\n& AMD_UNMASK_BIT(UDC_DEVINT_SC)\r\n& AMD_UNMASK_BIT(UDC_DEVINT_UR)\r\n& AMD_UNMASK_BIT(UDC_DEVINT_SVC)\r\n& AMD_UNMASK_BIT(UDC_DEVINT_ENUM);\r\nwritel(tmp, &dev->regs->irqmsk);\r\nreturn 0;\r\n}\r\nstatic int udc_set_txfifo_addr(struct udc_ep *ep)\r\n{\r\nstruct udc *dev;\r\nu32 tmp;\r\nint i;\r\nif (!ep || !(ep->in))\r\nreturn -EINVAL;\r\ndev = ep->dev;\r\nep->txfifo = dev->txfifo;\r\nfor (i = 0; i < ep->num; i++) {\r\nif (dev->ep[i].regs) {\r\ntmp = readl(&dev->ep[i].regs->bufin_framenum);\r\ntmp = AMD_GETBITS(tmp, UDC_EPIN_BUFF_SIZE);\r\nep->txfifo += tmp;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void UDC_QUEUE_CNAK(struct udc_ep *ep, unsigned num)\r\n{\r\nif (readl(&ep->regs->ctl) & AMD_BIT(UDC_EPCTL_NAK)) {\r\nDBG(ep->dev, "NAK could not be cleared for ep%d\n", num);\r\ncnak_pending |= 1 << (num);\r\nep->naking = 1;\r\n} else\r\ncnak_pending = cnak_pending & (~(1 << (num)));\r\n}\r\nstatic int\r\nudc_ep_enable(struct usb_ep *usbep, const struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct udc_ep *ep;\r\nstruct udc *dev;\r\nu32 tmp;\r\nunsigned long iflags;\r\nu8 udc_csr_epix;\r\nunsigned maxpacket;\r\nif (!usbep\r\n|| usbep->name == ep0_string\r\n|| !desc\r\n|| desc->bDescriptorType != USB_DT_ENDPOINT)\r\nreturn -EINVAL;\r\nep = container_of(usbep, struct udc_ep, ep);\r\ndev = ep->dev;\r\nDBG(dev, "udc_ep_enable() ep %d\n", ep->num);\r\nif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&dev->lock, iflags);\r\nep->ep.desc = desc;\r\nep->halted = 0;\r\ntmp = readl(&dev->ep[ep->num].regs->ctl);\r\ntmp = AMD_ADDBITS(tmp, desc->bmAttributes, UDC_EPCTL_ET);\r\nwritel(tmp, &dev->ep[ep->num].regs->ctl);\r\nmaxpacket = usb_endpoint_maxp(desc);\r\ntmp = readl(&dev->ep[ep->num].regs->bufout_maxpkt);\r\ntmp = AMD_ADDBITS(tmp, maxpacket, UDC_EP_MAX_PKT_SIZE);\r\nep->ep.maxpacket = maxpacket;\r\nwritel(tmp, &dev->ep[ep->num].regs->bufout_maxpkt);\r\nif (ep->in) {\r\nudc_csr_epix = ep->num;\r\ntmp = readl(&dev->ep[ep->num].regs->bufin_framenum);\r\ntmp = AMD_ADDBITS(\r\ntmp,\r\nmaxpacket * UDC_EPIN_BUFF_SIZE_MULT\r\n/ UDC_DWORD_BYTES,\r\nUDC_EPIN_BUFF_SIZE);\r\nwritel(tmp, &dev->ep[ep->num].regs->bufin_framenum);\r\nudc_set_txfifo_addr(ep);\r\ntmp = readl(&ep->regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_F);\r\nwritel(tmp, &ep->regs->ctl);\r\n} else {\r\nudc_csr_epix = ep->num - UDC_CSR_EP_OUT_IX_OFS;\r\ntmp = readl(&dev->csr->ne[ep->num - UDC_CSR_EP_OUT_IX_OFS]);\r\ntmp = AMD_ADDBITS(tmp, maxpacket,\r\nUDC_CSR_NE_MAX_PKT);\r\nwritel(tmp, &dev->csr->ne[ep->num - UDC_CSR_EP_OUT_IX_OFS]);\r\nif (use_dma && !ep->in) {\r\nep->bna_dummy_req = udc_alloc_bna_dummy(ep);\r\nep->bna_occurred = 0;\r\n}\r\nif (ep->num != UDC_EP0OUT_IX)\r\ndev->data_ep_enabled = 1;\r\n}\r\ntmp = readl(&dev->csr->ne[udc_csr_epix]);\r\ntmp = AMD_ADDBITS(tmp, maxpacket, UDC_CSR_NE_MAX_PKT);\r\ntmp = AMD_ADDBITS(tmp, desc->bEndpointAddress, UDC_CSR_NE_NUM);\r\ntmp = AMD_ADDBITS(tmp, ep->in, UDC_CSR_NE_DIR);\r\ntmp = AMD_ADDBITS(tmp, desc->bmAttributes, UDC_CSR_NE_TYPE);\r\ntmp = AMD_ADDBITS(tmp, ep->dev->cur_config, UDC_CSR_NE_CFG);\r\ntmp = AMD_ADDBITS(tmp, ep->dev->cur_intf, UDC_CSR_NE_INTF);\r\ntmp = AMD_ADDBITS(tmp, ep->dev->cur_alt, UDC_CSR_NE_ALT);\r\nwritel(tmp, &dev->csr->ne[udc_csr_epix]);\r\ntmp = readl(&dev->regs->ep_irqmsk);\r\ntmp &= AMD_UNMASK_BIT(ep->num);\r\nwritel(tmp, &dev->regs->ep_irqmsk);\r\nif (!use_dma || ep->in) {\r\ntmp = readl(&ep->regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_CNAK);\r\nwritel(tmp, &ep->regs->ctl);\r\nep->naking = 0;\r\nUDC_QUEUE_CNAK(ep, ep->num);\r\n}\r\ntmp = desc->bEndpointAddress;\r\nDBG(dev, "%s enabled\n", usbep->name);\r\nspin_unlock_irqrestore(&dev->lock, iflags);\r\nreturn 0;\r\n}\r\nstatic void ep_init(struct udc_regs __iomem *regs, struct udc_ep *ep)\r\n{\r\nu32 tmp;\r\nVDBG(ep->dev, "ep-%d reset\n", ep->num);\r\nep->ep.desc = NULL;\r\nep->ep.ops = &udc_ep_ops;\r\nINIT_LIST_HEAD(&ep->queue);\r\nusb_ep_set_maxpacket_limit(&ep->ep,(u16) ~0);\r\ntmp = readl(&ep->regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_SNAK);\r\nwritel(tmp, &ep->regs->ctl);\r\nep->naking = 1;\r\ntmp = readl(&regs->ep_irqmsk);\r\ntmp |= AMD_BIT(ep->num);\r\nwritel(tmp, &regs->ep_irqmsk);\r\nif (ep->in) {\r\ntmp = readl(&ep->regs->ctl);\r\ntmp &= AMD_UNMASK_BIT(UDC_EPCTL_P);\r\nwritel(tmp, &ep->regs->ctl);\r\ntmp = readl(&ep->regs->sts);\r\ntmp |= AMD_BIT(UDC_EPSTS_IN);\r\nwritel(tmp, &ep->regs->sts);\r\ntmp = readl(&ep->regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_F);\r\nwritel(tmp, &ep->regs->ctl);\r\n}\r\nwritel(0, &ep->regs->desptr);\r\n}\r\nstatic int udc_ep_disable(struct usb_ep *usbep)\r\n{\r\nstruct udc_ep *ep = NULL;\r\nunsigned long iflags;\r\nif (!usbep)\r\nreturn -EINVAL;\r\nep = container_of(usbep, struct udc_ep, ep);\r\nif (usbep->name == ep0_string || !ep->ep.desc)\r\nreturn -EINVAL;\r\nDBG(ep->dev, "Disable ep-%d\n", ep->num);\r\nspin_lock_irqsave(&ep->dev->lock, iflags);\r\nudc_free_request(&ep->ep, &ep->bna_dummy_req->req);\r\nempty_req_queue(ep);\r\nep_init(ep->dev->regs, ep);\r\nspin_unlock_irqrestore(&ep->dev->lock, iflags);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *\r\nudc_alloc_request(struct usb_ep *usbep, gfp_t gfp)\r\n{\r\nstruct udc_request *req;\r\nstruct udc_data_dma *dma_desc;\r\nstruct udc_ep *ep;\r\nif (!usbep)\r\nreturn NULL;\r\nep = container_of(usbep, struct udc_ep, ep);\r\nVDBG(ep->dev, "udc_alloc_req(): ep%d\n", ep->num);\r\nreq = kzalloc(sizeof(struct udc_request), gfp);\r\nif (!req)\r\nreturn NULL;\r\nreq->req.dma = DMA_DONT_USE;\r\nINIT_LIST_HEAD(&req->queue);\r\nif (ep->dma) {\r\ndma_desc = dma_pool_alloc(ep->dev->data_requests, gfp,\r\n&req->td_phys);\r\nif (!dma_desc) {\r\nkfree(req);\r\nreturn NULL;\r\n}\r\nVDBG(ep->dev, "udc_alloc_req: req = %p dma_desc = %p, "\r\n"td_phys = %lx\n",\r\nreq, dma_desc,\r\n(unsigned long)req->td_phys);\r\ndma_desc->status = AMD_ADDBITS(dma_desc->status,\r\nUDC_DMA_STP_STS_BS_HOST_BUSY,\r\nUDC_DMA_STP_STS_BS);\r\ndma_desc->bufptr = cpu_to_le32(DMA_DONT_USE);\r\nreq->td_data = dma_desc;\r\nreq->td_data_last = NULL;\r\nreq->chain_len = 1;\r\n}\r\nreturn &req->req;\r\n}\r\nstatic void udc_free_dma_chain(struct udc *dev, struct udc_request *req)\r\n{\r\nstruct udc_data_dma *td = req->td_data;\r\nunsigned int i;\r\ndma_addr_t addr_next = 0x00;\r\ndma_addr_t addr = (dma_addr_t)td->next;\r\nDBG(dev, "free chain req = %p\n", req);\r\nfor (i = 1; i < req->chain_len; i++) {\r\ntd = phys_to_virt(addr);\r\naddr_next = (dma_addr_t)td->next;\r\ndma_pool_free(dev->data_requests, td, addr);\r\naddr = addr_next;\r\n}\r\n}\r\nstatic void\r\nudc_free_request(struct usb_ep *usbep, struct usb_request *usbreq)\r\n{\r\nstruct udc_ep *ep;\r\nstruct udc_request *req;\r\nif (!usbep || !usbreq)\r\nreturn;\r\nep = container_of(usbep, struct udc_ep, ep);\r\nreq = container_of(usbreq, struct udc_request, req);\r\nVDBG(ep->dev, "free_req req=%p\n", req);\r\nBUG_ON(!list_empty(&req->queue));\r\nif (req->td_data) {\r\nVDBG(ep->dev, "req->td_data=%p\n", req->td_data);\r\nif (req->chain_len > 1)\r\nudc_free_dma_chain(ep->dev, req);\r\ndma_pool_free(ep->dev->data_requests, req->td_data,\r\nreq->td_phys);\r\n}\r\nkfree(req);\r\n}\r\nstatic void udc_init_bna_dummy(struct udc_request *req)\r\n{\r\nif (req) {\r\nreq->td_data->status |= AMD_BIT(UDC_DMA_IN_STS_L);\r\nreq->td_data->next = req->td_phys;\r\nreq->td_data->status\r\n= AMD_ADDBITS(req->td_data->status,\r\nUDC_DMA_STP_STS_BS_DMA_DONE,\r\nUDC_DMA_STP_STS_BS);\r\n#ifdef UDC_VERBOSE\r\npr_debug("bna desc = %p, sts = %08x\n",\r\nreq->td_data, req->td_data->status);\r\n#endif\r\n}\r\n}\r\nstatic struct udc_request *udc_alloc_bna_dummy(struct udc_ep *ep)\r\n{\r\nstruct udc_request *req = NULL;\r\nstruct usb_request *_req = NULL;\r\n_req = udc_alloc_request(&ep->ep, GFP_ATOMIC);\r\nif (_req) {\r\nreq = container_of(_req, struct udc_request, req);\r\nep->bna_dummy_req = req;\r\nudc_init_bna_dummy(req);\r\n}\r\nreturn req;\r\n}\r\nstatic void\r\nudc_txfifo_write(struct udc_ep *ep, struct usb_request *req)\r\n{\r\nu8 *req_buf;\r\nu32 *buf;\r\nint i, j;\r\nunsigned bytes = 0;\r\nunsigned remaining = 0;\r\nif (!req || !ep)\r\nreturn;\r\nreq_buf = req->buf + req->actual;\r\nprefetch(req_buf);\r\nremaining = req->length - req->actual;\r\nbuf = (u32 *) req_buf;\r\nbytes = ep->ep.maxpacket;\r\nif (bytes > remaining)\r\nbytes = remaining;\r\nfor (i = 0; i < bytes / UDC_DWORD_BYTES; i++)\r\nwritel(*(buf + i), ep->txfifo);\r\nfor (j = 0; j < bytes % UDC_DWORD_BYTES; j++) {\r\nwriteb((u8)(*(buf + i) >> (j << UDC_BITS_PER_BYTE_SHIFT)),\r\nep->txfifo);\r\n}\r\nwritel(0, &ep->regs->confirm);\r\n}\r\nstatic int udc_rxfifo_read_dwords(struct udc *dev, u32 *buf, int dwords)\r\n{\r\nint i;\r\nVDBG(dev, "udc_read_dwords(): %d dwords\n", dwords);\r\nfor (i = 0; i < dwords; i++)\r\n*(buf + i) = readl(dev->rxfifo);\r\nreturn 0;\r\n}\r\nstatic int udc_rxfifo_read_bytes(struct udc *dev, u8 *buf, int bytes)\r\n{\r\nint i, j;\r\nu32 tmp;\r\nVDBG(dev, "udc_read_bytes(): %d bytes\n", bytes);\r\nfor (i = 0; i < bytes / UDC_DWORD_BYTES; i++)\r\n*((u32 *)(buf + (i<<2))) = readl(dev->rxfifo);\r\nif (bytes % UDC_DWORD_BYTES) {\r\ntmp = readl(dev->rxfifo);\r\nfor (j = 0; j < bytes % UDC_DWORD_BYTES; j++) {\r\n*(buf + (i<<2) + j) = (u8)(tmp & UDC_BYTE_MASK);\r\ntmp = tmp >> UDC_BITS_PER_BYTE;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nudc_rxfifo_read(struct udc_ep *ep, struct udc_request *req)\r\n{\r\nu8 *buf;\r\nunsigned buf_space;\r\nunsigned bytes = 0;\r\nunsigned finished = 0;\r\nbytes = readl(&ep->regs->sts);\r\nbytes = AMD_GETBITS(bytes, UDC_EPSTS_RX_PKT_SIZE);\r\nbuf_space = req->req.length - req->req.actual;\r\nbuf = req->req.buf + req->req.actual;\r\nif (bytes > buf_space) {\r\nif ((buf_space % ep->ep.maxpacket) != 0) {\r\nDBG(ep->dev,\r\n"%s: rx %d bytes, rx-buf space = %d bytesn\n",\r\nep->ep.name, bytes, buf_space);\r\nreq->req.status = -EOVERFLOW;\r\n}\r\nbytes = buf_space;\r\n}\r\nreq->req.actual += bytes;\r\nif (((bytes % ep->ep.maxpacket) != 0) || (!bytes)\r\n|| ((req->req.actual == req->req.length) && !req->req.zero))\r\nfinished = 1;\r\nVDBG(ep->dev, "ep %s: rxfifo read %d bytes\n", ep->ep.name, bytes);\r\nudc_rxfifo_read_bytes(ep->dev, buf, bytes);\r\nreturn finished;\r\n}\r\nstatic int udc_create_dma_chain(\r\nstruct udc_ep *ep,\r\nstruct udc_request *req,\r\nunsigned long buf_len, gfp_t gfp_flags\r\n)\r\n{\r\nunsigned long bytes = req->req.length;\r\nunsigned int i;\r\ndma_addr_t dma_addr;\r\nstruct udc_data_dma *td = NULL;\r\nstruct udc_data_dma *last = NULL;\r\nunsigned long txbytes;\r\nunsigned create_new_chain = 0;\r\nunsigned len;\r\nVDBG(ep->dev, "udc_create_dma_chain: bytes=%ld buf_len=%ld\n",\r\nbytes, buf_len);\r\ndma_addr = DMA_DONT_USE;\r\nif (!ep->in)\r\nreq->td_data->status &= AMD_CLEAR_BIT(UDC_DMA_IN_STS_L);\r\nlen = req->req.length / ep->ep.maxpacket;\r\nif (req->req.length % ep->ep.maxpacket)\r\nlen++;\r\nif (len > req->chain_len) {\r\nif (req->chain_len > 1)\r\nudc_free_dma_chain(ep->dev, req);\r\nreq->chain_len = len;\r\ncreate_new_chain = 1;\r\n}\r\ntd = req->td_data;\r\nfor (i = buf_len; i < bytes; i += buf_len) {\r\nif (create_new_chain) {\r\ntd = dma_pool_alloc(ep->dev->data_requests,\r\ngfp_flags, &dma_addr);\r\nif (!td)\r\nreturn -ENOMEM;\r\ntd->status = 0;\r\n} else if (i == buf_len) {\r\ntd = (struct udc_data_dma *)phys_to_virt(\r\nreq->td_data->next);\r\ntd->status = 0;\r\n} else {\r\ntd = (struct udc_data_dma *)phys_to_virt(last->next);\r\ntd->status = 0;\r\n}\r\nif (td)\r\ntd->bufptr = req->req.dma + i;\r\nelse\r\nbreak;\r\nif ((bytes - i) >= buf_len) {\r\ntxbytes = buf_len;\r\n} else {\r\ntxbytes = bytes - i;\r\n}\r\nif (i == buf_len) {\r\nif (create_new_chain)\r\nreq->td_data->next = dma_addr;\r\nif (ep->in) {\r\nreq->td_data->status =\r\nAMD_ADDBITS(req->td_data->status,\r\nep->ep.maxpacket,\r\nUDC_DMA_IN_STS_TXBYTES);\r\ntd->status = AMD_ADDBITS(td->status,\r\ntxbytes,\r\nUDC_DMA_IN_STS_TXBYTES);\r\n}\r\n} else {\r\nif (create_new_chain)\r\nlast->next = dma_addr;\r\nif (ep->in) {\r\ntd->status = AMD_ADDBITS(td->status,\r\ntxbytes,\r\nUDC_DMA_IN_STS_TXBYTES);\r\n}\r\n}\r\nlast = td;\r\n}\r\nif (td) {\r\ntd->status |= AMD_BIT(UDC_DMA_IN_STS_L);\r\nreq->td_data_last = td;\r\n}\r\nreturn 0;\r\n}\r\nstatic int prep_dma(struct udc_ep *ep, struct udc_request *req, gfp_t gfp)\r\n{\r\nint retval = 0;\r\nu32 tmp;\r\nVDBG(ep->dev, "prep_dma\n");\r\nVDBG(ep->dev, "prep_dma ep%d req->td_data=%p\n",\r\nep->num, req->td_data);\r\nreq->td_data->bufptr = req->req.dma;\r\nreq->td_data->status |= AMD_BIT(UDC_DMA_IN_STS_L);\r\nif (use_dma_ppb) {\r\nretval = udc_create_dma_chain(ep, req, ep->ep.maxpacket, gfp);\r\nif (retval != 0) {\r\nif (retval == -ENOMEM)\r\nDBG(ep->dev, "Out of DMA memory\n");\r\nreturn retval;\r\n}\r\nif (ep->in) {\r\nif (req->req.length == ep->ep.maxpacket) {\r\nreq->td_data->status =\r\nAMD_ADDBITS(req->td_data->status,\r\nep->ep.maxpacket,\r\nUDC_DMA_IN_STS_TXBYTES);\r\n}\r\n}\r\n}\r\nif (ep->in) {\r\nVDBG(ep->dev, "IN: use_dma_ppb=%d req->req.len=%d "\r\n"maxpacket=%d ep%d\n",\r\nuse_dma_ppb, req->req.length,\r\nep->ep.maxpacket, ep->num);\r\nif (!use_dma_ppb || req->req.length < ep->ep.maxpacket\r\n|| ep->num == UDC_EP0OUT_IX\r\n|| ep->num == UDC_EP0IN_IX) {\r\nreq->td_data->status =\r\nAMD_ADDBITS(req->td_data->status,\r\nreq->req.length,\r\nUDC_DMA_IN_STS_TXBYTES);\r\nreq->td_data->status =\r\nAMD_ADDBITS(req->td_data->status,\r\n0,\r\nUDC_DMA_IN_STS_FRAMENUM);\r\n}\r\nreq->td_data->status =\r\nAMD_ADDBITS(req->td_data->status,\r\nUDC_DMA_STP_STS_BS_HOST_BUSY,\r\nUDC_DMA_STP_STS_BS);\r\n} else {\r\nVDBG(ep->dev, "OUT set host ready\n");\r\nreq->td_data->status =\r\nAMD_ADDBITS(req->td_data->status,\r\nUDC_DMA_STP_STS_BS_HOST_READY,\r\nUDC_DMA_STP_STS_BS);\r\nif (ep->naking) {\r\ntmp = readl(&ep->regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_CNAK);\r\nwritel(tmp, &ep->regs->ctl);\r\nep->naking = 0;\r\nUDC_QUEUE_CNAK(ep, ep->num);\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic void\r\ncomplete_req(struct udc_ep *ep, struct udc_request *req, int sts)\r\n__releases(ep->dev->lock)\r\n__acquires(ep->dev->lock)\r\n{\r\nstruct udc *dev;\r\nunsigned halted;\r\nVDBG(ep->dev, "complete_req(): ep%d\n", ep->num);\r\ndev = ep->dev;\r\nif (ep->dma)\r\nusb_gadget_unmap_request(&dev->gadget, &req->req, ep->in);\r\nhalted = ep->halted;\r\nep->halted = 1;\r\nif (req->req.status == -EINPROGRESS)\r\nreq->req.status = sts;\r\nlist_del_init(&req->queue);\r\nVDBG(ep->dev, "req %p => complete %d bytes at %s with sts %d\n",\r\n&req->req, req->req.length, ep->ep.name, sts);\r\nspin_unlock(&dev->lock);\r\nusb_gadget_giveback_request(&ep->ep, &req->req);\r\nspin_lock(&dev->lock);\r\nep->halted = halted;\r\n}\r\nstatic struct udc_data_dma *udc_get_last_dma_desc(struct udc_request *req)\r\n{\r\nstruct udc_data_dma *td;\r\ntd = req->td_data;\r\nwhile (td && !(td->status & AMD_BIT(UDC_DMA_IN_STS_L)))\r\ntd = phys_to_virt(td->next);\r\nreturn td;\r\n}\r\nstatic u32 udc_get_ppbdu_rxbytes(struct udc_request *req)\r\n{\r\nstruct udc_data_dma *td;\r\nu32 count;\r\ntd = req->td_data;\r\ncount = AMD_GETBITS(td->status, UDC_DMA_OUT_STS_RXBYTES);\r\nwhile (td && !(td->status & AMD_BIT(UDC_DMA_IN_STS_L))) {\r\ntd = phys_to_virt(td->next);\r\nif (td) {\r\ncount += AMD_GETBITS(td->status,\r\nUDC_DMA_OUT_STS_RXBYTES);\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic void udc_set_rde(struct udc *dev)\r\n{\r\nu32 tmp;\r\nVDBG(dev, "udc_set_rde()\n");\r\nif (timer_pending(&udc_timer)) {\r\nset_rde = 0;\r\nmod_timer(&udc_timer, jiffies - 1);\r\n}\r\ntmp = readl(&dev->regs->ctl);\r\ntmp |= AMD_BIT(UDC_DEVCTL_RDE);\r\nwritel(tmp, &dev->regs->ctl);\r\n}\r\nstatic int\r\nudc_queue(struct usb_ep *usbep, struct usb_request *usbreq, gfp_t gfp)\r\n{\r\nint retval = 0;\r\nu8 open_rxfifo = 0;\r\nunsigned long iflags;\r\nstruct udc_ep *ep;\r\nstruct udc_request *req;\r\nstruct udc *dev;\r\nu32 tmp;\r\nreq = container_of(usbreq, struct udc_request, req);\r\nif (!usbep || !usbreq || !usbreq->complete || !usbreq->buf\r\n|| !list_empty(&req->queue))\r\nreturn -EINVAL;\r\nep = container_of(usbep, struct udc_ep, ep);\r\nif (!ep->ep.desc && (ep->num != 0 && ep->num != UDC_EP0OUT_IX))\r\nreturn -EINVAL;\r\nVDBG(ep->dev, "udc_queue(): ep%d-in=%d\n", ep->num, ep->in);\r\ndev = ep->dev;\r\nif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nif (ep->dma) {\r\nVDBG(dev, "DMA map req %p\n", req);\r\nretval = usb_gadget_map_request(&udc->gadget, usbreq, ep->in);\r\nif (retval)\r\nreturn retval;\r\n}\r\nVDBG(dev, "%s queue req %p, len %d req->td_data=%p buf %p\n",\r\nusbep->name, usbreq, usbreq->length,\r\nreq->td_data, usbreq->buf);\r\nspin_lock_irqsave(&dev->lock, iflags);\r\nusbreq->actual = 0;\r\nusbreq->status = -EINPROGRESS;\r\nreq->dma_done = 0;\r\nif (list_empty(&ep->queue)) {\r\nif (usbreq->length == 0) {\r\ncomplete_req(ep, req, 0);\r\nVDBG(dev, "%s: zlp\n", ep->ep.name);\r\nif (dev->set_cfg_not_acked) {\r\ntmp = readl(&dev->regs->ctl);\r\ntmp |= AMD_BIT(UDC_DEVCTL_CSR_DONE);\r\nwritel(tmp, &dev->regs->ctl);\r\ndev->set_cfg_not_acked = 0;\r\n}\r\nif (dev->waiting_zlp_ack_ep0in) {\r\ntmp = readl(&dev->ep[UDC_EP0IN_IX].regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_CNAK);\r\nwritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->ctl);\r\ndev->ep[UDC_EP0IN_IX].naking = 0;\r\nUDC_QUEUE_CNAK(&dev->ep[UDC_EP0IN_IX],\r\nUDC_EP0IN_IX);\r\ndev->waiting_zlp_ack_ep0in = 0;\r\n}\r\ngoto finished;\r\n}\r\nif (ep->dma) {\r\nretval = prep_dma(ep, req, GFP_ATOMIC);\r\nif (retval != 0)\r\ngoto finished;\r\nif (ep->in) {\r\nreq->td_data->status =\r\nAMD_ADDBITS(req->td_data->status,\r\nUDC_DMA_IN_STS_BS_HOST_READY,\r\nUDC_DMA_IN_STS_BS);\r\n}\r\nif (!ep->in) {\r\nif (timer_pending(&udc_timer)) {\r\nset_rde = 0;\r\nmod_timer(&udc_timer, jiffies - 1);\r\n}\r\ntmp = readl(&dev->regs->ctl);\r\ntmp &= AMD_UNMASK_BIT(UDC_DEVCTL_RDE);\r\nwritel(tmp, &dev->regs->ctl);\r\nopen_rxfifo = 1;\r\nif (ep->bna_occurred) {\r\nVDBG(dev, "copy to BNA dummy desc.\n");\r\nmemcpy(ep->bna_dummy_req->td_data,\r\nreq->td_data,\r\nsizeof(struct udc_data_dma));\r\n}\r\n}\r\nwritel(req->td_phys, &ep->regs->desptr);\r\nif (ep->naking) {\r\ntmp = readl(&ep->regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_CNAK);\r\nwritel(tmp, &ep->regs->ctl);\r\nep->naking = 0;\r\nUDC_QUEUE_CNAK(ep, ep->num);\r\n}\r\nif (ep->in) {\r\ntmp = readl(&dev->regs->ep_irqmsk);\r\ntmp &= AMD_UNMASK_BIT(ep->num);\r\nwritel(tmp, &dev->regs->ep_irqmsk);\r\n}\r\n} else if (ep->in) {\r\ntmp = readl(&dev->regs->ep_irqmsk);\r\ntmp &= AMD_UNMASK_BIT(ep->num);\r\nwritel(tmp, &dev->regs->ep_irqmsk);\r\n}\r\n} else if (ep->dma) {\r\nif (ep->in) {\r\nretval = prep_dma(ep, req, GFP_ATOMIC);\r\nif (retval != 0)\r\ngoto finished;\r\n}\r\n}\r\nVDBG(dev, "list_add\n");\r\nif (req) {\r\nlist_add_tail(&req->queue, &ep->queue);\r\nif (open_rxfifo) {\r\nreq->dma_going = 1;\r\nudc_set_rde(dev);\r\nif (ep->num != UDC_EP0OUT_IX)\r\ndev->data_ep_queued = 1;\r\n}\r\nif (!ep->in) {\r\nif (!use_dma && udc_rxfifo_pending) {\r\nDBG(dev, "udc_queue(): pending bytes in "\r\n"rxfifo after nyet\n");\r\nif (udc_rxfifo_read(ep, req)) {\r\ncomplete_req(ep, req, 0);\r\n}\r\nudc_rxfifo_pending = 0;\r\n}\r\n}\r\n}\r\nfinished:\r\nspin_unlock_irqrestore(&dev->lock, iflags);\r\nreturn retval;\r\n}\r\nvoid empty_req_queue(struct udc_ep *ep)\r\n{\r\nstruct udc_request *req;\r\nep->halted = 1;\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct udc_request,\r\nqueue);\r\ncomplete_req(ep, req, -ESHUTDOWN);\r\n}\r\n}\r\nstatic int udc_dequeue(struct usb_ep *usbep, struct usb_request *usbreq)\r\n{\r\nstruct udc_ep *ep;\r\nstruct udc_request *req;\r\nunsigned halted;\r\nunsigned long iflags;\r\nep = container_of(usbep, struct udc_ep, ep);\r\nif (!usbep || !usbreq || (!ep->ep.desc && (ep->num != 0\r\n&& ep->num != UDC_EP0OUT_IX)))\r\nreturn -EINVAL;\r\nreq = container_of(usbreq, struct udc_request, req);\r\nspin_lock_irqsave(&ep->dev->lock, iflags);\r\nhalted = ep->halted;\r\nep->halted = 1;\r\nif (ep->queue.next == &req->queue) {\r\nif (ep->dma && req->dma_going) {\r\nif (ep->in)\r\nep->cancel_transfer = 1;\r\nelse {\r\nu32 tmp;\r\nu32 dma_sts;\r\ntmp = readl(&udc->regs->ctl);\r\nwritel(tmp & AMD_UNMASK_BIT(UDC_DEVCTL_RDE),\r\n&udc->regs->ctl);\r\ndma_sts = AMD_GETBITS(req->td_data->status,\r\nUDC_DMA_OUT_STS_BS);\r\nif (dma_sts != UDC_DMA_OUT_STS_BS_HOST_READY)\r\nep->cancel_transfer = 1;\r\nelse {\r\nudc_init_bna_dummy(ep->req);\r\nwritel(ep->bna_dummy_req->td_phys,\r\n&ep->regs->desptr);\r\n}\r\nwritel(tmp, &udc->regs->ctl);\r\n}\r\n}\r\n}\r\ncomplete_req(ep, req, -ECONNRESET);\r\nep->halted = halted;\r\nspin_unlock_irqrestore(&ep->dev->lock, iflags);\r\nreturn 0;\r\n}\r\nstatic int\r\nudc_set_halt(struct usb_ep *usbep, int halt)\r\n{\r\nstruct udc_ep *ep;\r\nu32 tmp;\r\nunsigned long iflags;\r\nint retval = 0;\r\nif (!usbep)\r\nreturn -EINVAL;\r\npr_debug("set_halt %s: halt=%d\n", usbep->name, halt);\r\nep = container_of(usbep, struct udc_ep, ep);\r\nif (!ep->ep.desc && (ep->num != 0 && ep->num != UDC_EP0OUT_IX))\r\nreturn -EINVAL;\r\nif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&udc_stall_spinlock, iflags);\r\nif (halt) {\r\nif (ep->num == 0)\r\nep->dev->stall_ep0in = 1;\r\nelse {\r\ntmp = readl(&ep->regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_S);\r\nwritel(tmp, &ep->regs->ctl);\r\nep->halted = 1;\r\nif (!timer_pending(&udc_pollstall_timer)) {\r\nudc_pollstall_timer.expires = jiffies +\r\nHZ * UDC_POLLSTALL_TIMER_USECONDS\r\n/ (1000 * 1000);\r\nif (!stop_pollstall_timer) {\r\nDBG(ep->dev, "start polltimer\n");\r\nadd_timer(&udc_pollstall_timer);\r\n}\r\n}\r\n}\r\n} else {\r\nif (ep->halted) {\r\ntmp = readl(&ep->regs->ctl);\r\ntmp = tmp & AMD_CLEAR_BIT(UDC_EPCTL_S);\r\ntmp |= AMD_BIT(UDC_EPCTL_CNAK);\r\nwritel(tmp, &ep->regs->ctl);\r\nep->halted = 0;\r\nUDC_QUEUE_CNAK(ep, ep->num);\r\n}\r\n}\r\nspin_unlock_irqrestore(&udc_stall_spinlock, iflags);\r\nreturn retval;\r\n}\r\nstatic int udc_get_frame(struct usb_gadget *gadget)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int udc_remote_wakeup(struct udc *dev)\r\n{\r\nunsigned long flags;\r\nu32 tmp;\r\nDBG(dev, "UDC initiates remote wakeup\n");\r\nspin_lock_irqsave(&dev->lock, flags);\r\ntmp = readl(&dev->regs->ctl);\r\ntmp |= AMD_BIT(UDC_DEVCTL_RES);\r\nwritel(tmp, &dev->regs->ctl);\r\ntmp &= AMD_CLEAR_BIT(UDC_DEVCTL_RES);\r\nwritel(tmp, &dev->regs->ctl);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int udc_wakeup(struct usb_gadget *gadget)\r\n{\r\nstruct udc *dev;\r\nif (!gadget)\r\nreturn -EINVAL;\r\ndev = container_of(gadget, struct udc, gadget);\r\nudc_remote_wakeup(dev);\r\nreturn 0;\r\n}\r\nstatic void make_ep_lists(struct udc *dev)\r\n{\r\nINIT_LIST_HEAD(&dev->gadget.ep_list);\r\nlist_add_tail(&dev->ep[UDC_EPIN_STATUS_IX].ep.ep_list,\r\n&dev->gadget.ep_list);\r\nlist_add_tail(&dev->ep[UDC_EPIN_IX].ep.ep_list,\r\n&dev->gadget.ep_list);\r\nlist_add_tail(&dev->ep[UDC_EPOUT_IX].ep.ep_list,\r\n&dev->gadget.ep_list);\r\ndev->ep[UDC_EPIN_STATUS_IX].fifo_depth = UDC_EPIN_SMALLINT_BUFF_SIZE;\r\nif (dev->gadget.speed == USB_SPEED_FULL)\r\ndev->ep[UDC_EPIN_IX].fifo_depth = UDC_FS_EPIN_BUFF_SIZE;\r\nelse if (dev->gadget.speed == USB_SPEED_HIGH)\r\ndev->ep[UDC_EPIN_IX].fifo_depth = hs_tx_buf;\r\ndev->ep[UDC_EPOUT_IX].fifo_depth = UDC_RXFIFO_SIZE;\r\n}\r\nvoid udc_basic_init(struct udc *dev)\r\n{\r\nu32 tmp;\r\nDBG(dev, "udc_basic_init()\n");\r\ndev->gadget.speed = USB_SPEED_UNKNOWN;\r\nif (timer_pending(&udc_timer)) {\r\nset_rde = 0;\r\nmod_timer(&udc_timer, jiffies - 1);\r\n}\r\nif (timer_pending(&udc_pollstall_timer))\r\nmod_timer(&udc_pollstall_timer, jiffies - 1);\r\ntmp = readl(&dev->regs->ctl);\r\ntmp &= AMD_UNMASK_BIT(UDC_DEVCTL_RDE);\r\ntmp &= AMD_UNMASK_BIT(UDC_DEVCTL_TDE);\r\nwritel(tmp, &dev->regs->ctl);\r\ntmp = readl(&dev->regs->cfg);\r\ntmp |= AMD_BIT(UDC_DEVCFG_CSR_PRG);\r\ntmp |= AMD_BIT(UDC_DEVCFG_SP);\r\ntmp |= AMD_BIT(UDC_DEVCFG_RWKP);\r\nwritel(tmp, &dev->regs->cfg);\r\nmake_ep_lists(dev);\r\ndev->data_ep_enabled = 0;\r\ndev->data_ep_queued = 0;\r\n}\r\nstatic int startup_registers(struct udc *dev)\r\n{\r\nu32 tmp;\r\nudc_soft_reset(dev);\r\nudc_mask_unused_interrupts(dev);\r\nudc_basic_init(dev);\r\nudc_setup_endpoints(dev);\r\ntmp = readl(&dev->regs->cfg);\r\nif (use_fullspeed)\r\ntmp = AMD_ADDBITS(tmp, UDC_DEVCFG_SPD_FS, UDC_DEVCFG_SPD);\r\nelse\r\ntmp = AMD_ADDBITS(tmp, UDC_DEVCFG_SPD_HS, UDC_DEVCFG_SPD);\r\nwritel(tmp, &dev->regs->cfg);\r\nreturn 0;\r\n}\r\nstatic void udc_setup_endpoints(struct udc *dev)\r\n{\r\nstruct udc_ep *ep;\r\nu32 tmp;\r\nu32 reg;\r\nDBG(dev, "udc_setup_endpoints()\n");\r\ntmp = readl(&dev->regs->sts);\r\ntmp = AMD_GETBITS(tmp, UDC_DEVSTS_ENUM_SPEED);\r\nif (tmp == UDC_DEVSTS_ENUM_SPEED_HIGH)\r\ndev->gadget.speed = USB_SPEED_HIGH;\r\nelse if (tmp == UDC_DEVSTS_ENUM_SPEED_FULL)\r\ndev->gadget.speed = USB_SPEED_FULL;\r\nfor (tmp = 0; tmp < UDC_EP_NUM; tmp++) {\r\nep = &dev->ep[tmp];\r\nep->dev = dev;\r\nep->ep.name = ep_info[tmp].name;\r\nep->ep.caps = ep_info[tmp].caps;\r\nep->num = tmp;\r\nep->txfifo = dev->txfifo;\r\nif (tmp < UDC_EPIN_NUM) {\r\nep->fifo_depth = UDC_TXFIFO_SIZE;\r\nep->in = 1;\r\n} else {\r\nep->fifo_depth = UDC_RXFIFO_SIZE;\r\nep->in = 0;\r\n}\r\nep->regs = &dev->ep_regs[tmp];\r\nif (!ep->ep.desc)\r\nep_init(dev->regs, ep);\r\nif (use_dma) {\r\nep->dma = &dev->regs->ctl;\r\nif (tmp != UDC_EP0IN_IX && tmp != UDC_EP0OUT_IX\r\n&& tmp > UDC_EPIN_NUM) {\r\nreg = readl(&dev->ep[tmp].regs->ctl);\r\nreg |= AMD_BIT(UDC_EPCTL_SNAK);\r\nwritel(reg, &dev->ep[tmp].regs->ctl);\r\ndev->ep[tmp].naking = 1;\r\n}\r\n}\r\n}\r\nif (dev->gadget.speed == USB_SPEED_FULL) {\r\nusb_ep_set_maxpacket_limit(&dev->ep[UDC_EP0IN_IX].ep,\r\nUDC_FS_EP0IN_MAX_PKT_SIZE);\r\nusb_ep_set_maxpacket_limit(&dev->ep[UDC_EP0OUT_IX].ep,\r\nUDC_FS_EP0OUT_MAX_PKT_SIZE);\r\n} else if (dev->gadget.speed == USB_SPEED_HIGH) {\r\nusb_ep_set_maxpacket_limit(&dev->ep[UDC_EP0IN_IX].ep,\r\nUDC_EP0IN_MAX_PKT_SIZE);\r\nusb_ep_set_maxpacket_limit(&dev->ep[UDC_EP0OUT_IX].ep,\r\nUDC_EP0OUT_MAX_PKT_SIZE);\r\n}\r\ndev->gadget.ep0 = &dev->ep[UDC_EP0IN_IX].ep;\r\ndev->ep[UDC_EP0IN_IX].halted = 0;\r\nINIT_LIST_HEAD(&dev->gadget.ep0->ep_list);\r\ndev->cur_config = 0;\r\ndev->cur_intf = 0;\r\ndev->cur_alt = 0;\r\n}\r\nstatic void usb_connect(struct udc *dev)\r\n{\r\nif (dev->connected)\r\nreturn;\r\ndev_info(dev->dev, "USB Connect\n");\r\ndev->connected = 1;\r\nudc_basic_init(dev);\r\nudc_enable_dev_setup_interrupts(dev);\r\n}\r\nstatic void usb_disconnect(struct udc *dev)\r\n{\r\nif (!dev->connected)\r\nreturn;\r\ndev_info(dev->dev, "USB Disconnect\n");\r\ndev->connected = 0;\r\nudc_mask_unused_interrupts(dev);\r\ntasklet_schedule(&disconnect_tasklet);\r\n}\r\nstatic void udc_tasklet_disconnect(unsigned long par)\r\n{\r\nstruct udc *dev = (struct udc *)(*((struct udc **) par));\r\nu32 tmp;\r\nDBG(dev, "Tasklet disconnect\n");\r\nspin_lock_irq(&dev->lock);\r\nif (dev->driver) {\r\nspin_unlock(&dev->lock);\r\ndev->driver->disconnect(&dev->gadget);\r\nspin_lock(&dev->lock);\r\nfor (tmp = 0; tmp < UDC_EP_NUM; tmp++)\r\nempty_req_queue(&dev->ep[tmp]);\r\n}\r\nep_init(dev->regs,\r\n&dev->ep[UDC_EP0IN_IX]);\r\nif (!soft_reset_occured) {\r\nudc_soft_reset(dev);\r\nsoft_reset_occured++;\r\n}\r\nudc_enable_dev_setup_interrupts(dev);\r\nif (use_fullspeed) {\r\ntmp = readl(&dev->regs->cfg);\r\ntmp = AMD_ADDBITS(tmp, UDC_DEVCFG_SPD_FS, UDC_DEVCFG_SPD);\r\nwritel(tmp, &dev->regs->cfg);\r\n}\r\nspin_unlock_irq(&dev->lock);\r\n}\r\nstatic void udc_soft_reset(struct udc *dev)\r\n{\r\nunsigned long flags;\r\nDBG(dev, "Soft reset\n");\r\nwritel(UDC_EPINT_MSK_DISABLE_ALL, &dev->regs->ep_irqsts);\r\nwritel(UDC_DEV_MSK_DISABLE, &dev->regs->irqsts);\r\nif (dev->chiprev != UDC_BCM_REV) {\r\nspin_lock_irqsave(&udc_irq_spinlock, flags);\r\nwritel(AMD_BIT(UDC_DEVCFG_SOFTRESET), &dev->regs->cfg);\r\nreadl(&dev->regs->cfg);\r\nspin_unlock_irqrestore(&udc_irq_spinlock, flags);\r\n}\r\n}\r\nstatic void udc_timer_function(unsigned long v)\r\n{\r\nu32 tmp;\r\nspin_lock_irq(&udc_irq_spinlock);\r\nif (set_rde > 0) {\r\nif (set_rde > 1) {\r\ntmp = readl(&udc->regs->ctl);\r\ntmp |= AMD_BIT(UDC_DEVCTL_RDE);\r\nwritel(tmp, &udc->regs->ctl);\r\nset_rde = -1;\r\n} else if (readl(&udc->regs->sts)\r\n& AMD_BIT(UDC_DEVSTS_RXFIFO_EMPTY)) {\r\nudc_timer.expires = jiffies + HZ/UDC_RDE_TIMER_DIV;\r\nif (!stop_timer)\r\nadd_timer(&udc_timer);\r\n} else {\r\nset_rde++;\r\nudc_timer.expires = jiffies + HZ*UDC_RDE_TIMER_SECONDS;\r\nif (!stop_timer)\r\nadd_timer(&udc_timer);\r\n}\r\n} else\r\nset_rde = -1;\r\nspin_unlock_irq(&udc_irq_spinlock);\r\nif (stop_timer)\r\ncomplete(&on_exit);\r\n}\r\nstatic void udc_handle_halt_state(struct udc_ep *ep)\r\n{\r\nu32 tmp;\r\nif (ep->halted == 1) {\r\ntmp = readl(&ep->regs->ctl);\r\nif (!(tmp & AMD_BIT(UDC_EPCTL_S))) {\r\ntmp |= AMD_BIT(UDC_EPCTL_CNAK);\r\nwritel(tmp, &ep->regs->ctl);\r\nep->halted = 0;\r\nUDC_QUEUE_CNAK(ep, ep->num);\r\n}\r\n}\r\n}\r\nstatic void udc_pollstall_timer_function(unsigned long v)\r\n{\r\nstruct udc_ep *ep;\r\nint halted = 0;\r\nspin_lock_irq(&udc_stall_spinlock);\r\nep = &udc->ep[UDC_EPIN_IX];\r\nudc_handle_halt_state(ep);\r\nif (ep->halted)\r\nhalted = 1;\r\nep = &udc->ep[UDC_EPOUT_IX];\r\nudc_handle_halt_state(ep);\r\nif (ep->halted)\r\nhalted = 1;\r\nif (!stop_pollstall_timer && halted) {\r\nudc_pollstall_timer.expires = jiffies +\r\nHZ * UDC_POLLSTALL_TIMER_USECONDS\r\n/ (1000 * 1000);\r\nadd_timer(&udc_pollstall_timer);\r\n}\r\nspin_unlock_irq(&udc_stall_spinlock);\r\nif (stop_pollstall_timer)\r\ncomplete(&on_pollstall_exit);\r\n}\r\nstatic void activate_control_endpoints(struct udc *dev)\r\n{\r\nu32 tmp;\r\nDBG(dev, "activate_control_endpoints\n");\r\ntmp = readl(&dev->ep[UDC_EP0IN_IX].regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_F);\r\nwritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->ctl);\r\ndev->ep[UDC_EP0IN_IX].in = 1;\r\ndev->ep[UDC_EP0OUT_IX].in = 0;\r\ntmp = readl(&dev->ep[UDC_EP0IN_IX].regs->bufin_framenum);\r\nif (dev->gadget.speed == USB_SPEED_FULL)\r\ntmp = AMD_ADDBITS(tmp, UDC_FS_EPIN0_BUFF_SIZE,\r\nUDC_EPIN_BUFF_SIZE);\r\nelse if (dev->gadget.speed == USB_SPEED_HIGH)\r\ntmp = AMD_ADDBITS(tmp, UDC_EPIN0_BUFF_SIZE,\r\nUDC_EPIN_BUFF_SIZE);\r\nwritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->bufin_framenum);\r\ntmp = readl(&dev->ep[UDC_EP0IN_IX].regs->bufout_maxpkt);\r\nif (dev->gadget.speed == USB_SPEED_FULL)\r\ntmp = AMD_ADDBITS(tmp, UDC_FS_EP0IN_MAX_PKT_SIZE,\r\nUDC_EP_MAX_PKT_SIZE);\r\nelse if (dev->gadget.speed == USB_SPEED_HIGH)\r\ntmp = AMD_ADDBITS(tmp, UDC_EP0IN_MAX_PKT_SIZE,\r\nUDC_EP_MAX_PKT_SIZE);\r\nwritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->bufout_maxpkt);\r\ntmp = readl(&dev->ep[UDC_EP0OUT_IX].regs->bufout_maxpkt);\r\nif (dev->gadget.speed == USB_SPEED_FULL)\r\ntmp = AMD_ADDBITS(tmp, UDC_FS_EP0OUT_MAX_PKT_SIZE,\r\nUDC_EP_MAX_PKT_SIZE);\r\nelse if (dev->gadget.speed == USB_SPEED_HIGH)\r\ntmp = AMD_ADDBITS(tmp, UDC_EP0OUT_MAX_PKT_SIZE,\r\nUDC_EP_MAX_PKT_SIZE);\r\nwritel(tmp, &dev->ep[UDC_EP0OUT_IX].regs->bufout_maxpkt);\r\ntmp = readl(&dev->csr->ne[0]);\r\nif (dev->gadget.speed == USB_SPEED_FULL)\r\ntmp = AMD_ADDBITS(tmp, UDC_FS_EP0OUT_MAX_PKT_SIZE,\r\nUDC_CSR_NE_MAX_PKT);\r\nelse if (dev->gadget.speed == USB_SPEED_HIGH)\r\ntmp = AMD_ADDBITS(tmp, UDC_EP0OUT_MAX_PKT_SIZE,\r\nUDC_CSR_NE_MAX_PKT);\r\nwritel(tmp, &dev->csr->ne[0]);\r\nif (use_dma) {\r\ndev->ep[UDC_EP0OUT_IX].td->status |=\r\nAMD_BIT(UDC_DMA_OUT_STS_L);\r\nwritel(dev->ep[UDC_EP0OUT_IX].td_stp_dma,\r\n&dev->ep[UDC_EP0OUT_IX].regs->subptr);\r\nwritel(dev->ep[UDC_EP0OUT_IX].td_phys,\r\n&dev->ep[UDC_EP0OUT_IX].regs->desptr);\r\nif (timer_pending(&udc_timer)) {\r\nset_rde = 0;\r\nmod_timer(&udc_timer, jiffies - 1);\r\n}\r\nif (timer_pending(&udc_pollstall_timer))\r\nmod_timer(&udc_pollstall_timer, jiffies - 1);\r\ntmp = readl(&dev->regs->ctl);\r\ntmp |= AMD_BIT(UDC_DEVCTL_MODE)\r\n| AMD_BIT(UDC_DEVCTL_RDE)\r\n| AMD_BIT(UDC_DEVCTL_TDE);\r\nif (use_dma_bufferfill_mode)\r\ntmp |= AMD_BIT(UDC_DEVCTL_BF);\r\nelse if (use_dma_ppb_du)\r\ntmp |= AMD_BIT(UDC_DEVCTL_DU);\r\nwritel(tmp, &dev->regs->ctl);\r\n}\r\ntmp = readl(&dev->ep[UDC_EP0IN_IX].regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_CNAK);\r\nwritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->ctl);\r\ndev->ep[UDC_EP0IN_IX].naking = 0;\r\nUDC_QUEUE_CNAK(&dev->ep[UDC_EP0IN_IX], UDC_EP0IN_IX);\r\ntmp = readl(&dev->ep[UDC_EP0OUT_IX].regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_CNAK);\r\nwritel(tmp, &dev->ep[UDC_EP0OUT_IX].regs->ctl);\r\ndev->ep[UDC_EP0OUT_IX].naking = 0;\r\nUDC_QUEUE_CNAK(&dev->ep[UDC_EP0OUT_IX], UDC_EP0OUT_IX);\r\n}\r\nstatic int setup_ep0(struct udc *dev)\r\n{\r\nactivate_control_endpoints(dev);\r\nudc_enable_ep0_interrupts(dev);\r\nudc_enable_dev_setup_interrupts(dev);\r\nreturn 0;\r\n}\r\nstatic int amd5536_udc_start(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct udc *dev = to_amd5536_udc(g);\r\nu32 tmp;\r\ndriver->driver.bus = NULL;\r\ndev->driver = driver;\r\ndev->ep[UDC_EP0OUT_IX].ep.driver_data =\r\ndev->ep[UDC_EP0IN_IX].ep.driver_data;\r\nsetup_ep0(dev);\r\ntmp = readl(&dev->regs->ctl);\r\ntmp = tmp & AMD_CLEAR_BIT(UDC_DEVCTL_SD);\r\nwritel(tmp, &dev->regs->ctl);\r\nusb_connect(dev);\r\nreturn 0;\r\n}\r\nstatic void\r\nshutdown(struct udc *dev, struct usb_gadget_driver *driver)\r\n__releases(dev->lock)\r\n__acquires(dev->lock)\r\n{\r\nint tmp;\r\nudc_basic_init(dev);\r\nfor (tmp = 0; tmp < UDC_EP_NUM; tmp++)\r\nempty_req_queue(&dev->ep[tmp]);\r\nudc_setup_endpoints(dev);\r\n}\r\nstatic int amd5536_udc_stop(struct usb_gadget *g)\r\n{\r\nstruct udc *dev = to_amd5536_udc(g);\r\nunsigned long flags;\r\nu32 tmp;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nudc_mask_unused_interrupts(dev);\r\nshutdown(dev, NULL);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\ndev->driver = NULL;\r\ntmp = readl(&dev->regs->ctl);\r\ntmp |= AMD_BIT(UDC_DEVCTL_SD);\r\nwritel(tmp, &dev->regs->ctl);\r\nreturn 0;\r\n}\r\nstatic void udc_process_cnak_queue(struct udc *dev)\r\n{\r\nu32 tmp;\r\nu32 reg;\r\nDBG(dev, "CNAK pending queue processing\n");\r\nfor (tmp = 0; tmp < UDC_EPIN_NUM_USED; tmp++) {\r\nif (cnak_pending & (1 << tmp)) {\r\nDBG(dev, "CNAK pending for ep%d\n", tmp);\r\nreg = readl(&dev->ep[tmp].regs->ctl);\r\nreg |= AMD_BIT(UDC_EPCTL_CNAK);\r\nwritel(reg, &dev->ep[tmp].regs->ctl);\r\ndev->ep[tmp].naking = 0;\r\nUDC_QUEUE_CNAK(&dev->ep[tmp], dev->ep[tmp].num);\r\n}\r\n}\r\nif (cnak_pending & (1 << UDC_EP0OUT_IX)) {\r\nDBG(dev, "CNAK pending for ep%d\n", UDC_EP0OUT_IX);\r\nreg = readl(&dev->ep[UDC_EP0OUT_IX].regs->ctl);\r\nreg |= AMD_BIT(UDC_EPCTL_CNAK);\r\nwritel(reg, &dev->ep[UDC_EP0OUT_IX].regs->ctl);\r\ndev->ep[UDC_EP0OUT_IX].naking = 0;\r\nUDC_QUEUE_CNAK(&dev->ep[UDC_EP0OUT_IX],\r\ndev->ep[UDC_EP0OUT_IX].num);\r\n}\r\n}\r\nstatic void udc_ep0_set_rde(struct udc *dev)\r\n{\r\nif (use_dma) {\r\nif (!dev->data_ep_enabled || dev->data_ep_queued) {\r\nudc_set_rde(dev);\r\n} else {\r\nif (set_rde != 0 && !timer_pending(&udc_timer)) {\r\nudc_timer.expires =\r\njiffies + HZ/UDC_RDE_TIMER_DIV;\r\nset_rde = 1;\r\nif (!stop_timer)\r\nadd_timer(&udc_timer);\r\n}\r\n}\r\n}\r\n}\r\nstatic irqreturn_t udc_data_out_isr(struct udc *dev, int ep_ix)\r\n{\r\nirqreturn_t ret_val = IRQ_NONE;\r\nu32 tmp;\r\nstruct udc_ep *ep;\r\nstruct udc_request *req;\r\nunsigned int count;\r\nstruct udc_data_dma *td = NULL;\r\nunsigned dma_done;\r\nVDBG(dev, "ep%d irq\n", ep_ix);\r\nep = &dev->ep[ep_ix];\r\ntmp = readl(&ep->regs->sts);\r\nif (use_dma) {\r\nif (tmp & AMD_BIT(UDC_EPSTS_BNA)) {\r\nDBG(dev, "BNA ep%dout occurred - DESPTR = %x\n",\r\nep->num, readl(&ep->regs->desptr));\r\nwritel(tmp | AMD_BIT(UDC_EPSTS_BNA), &ep->regs->sts);\r\nif (!ep->cancel_transfer)\r\nep->bna_occurred = 1;\r\nelse\r\nep->cancel_transfer = 0;\r\nret_val = IRQ_HANDLED;\r\ngoto finished;\r\n}\r\n}\r\nif (tmp & AMD_BIT(UDC_EPSTS_HE)) {\r\ndev_err(dev->dev, "HE ep%dout occurred\n", ep->num);\r\nwritel(tmp | AMD_BIT(UDC_EPSTS_HE), &ep->regs->sts);\r\nret_val = IRQ_HANDLED;\r\ngoto finished;\r\n}\r\nif (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct udc_request, queue);\r\n} else {\r\nreq = NULL;\r\nudc_rxfifo_pending = 1;\r\n}\r\nVDBG(dev, "req = %p\n", req);\r\nif (!use_dma) {\r\nif (req && udc_rxfifo_read(ep, req)) {\r\nret_val = IRQ_HANDLED;\r\ncomplete_req(ep, req, 0);\r\nif (!list_empty(&ep->queue) && !ep->halted) {\r\nreq = list_entry(ep->queue.next,\r\nstruct udc_request, queue);\r\n} else\r\nreq = NULL;\r\n}\r\n} else if (!ep->cancel_transfer && req) {\r\nret_val = IRQ_HANDLED;\r\nif (!use_dma_ppb) {\r\ndma_done = AMD_GETBITS(req->td_data->status,\r\nUDC_DMA_OUT_STS_BS);\r\n} else {\r\nif (ep->bna_occurred) {\r\nVDBG(dev, "Recover desc. from BNA dummy\n");\r\nmemcpy(req->td_data, ep->bna_dummy_req->td_data,\r\nsizeof(struct udc_data_dma));\r\nep->bna_occurred = 0;\r\nudc_init_bna_dummy(ep->req);\r\n}\r\ntd = udc_get_last_dma_desc(req);\r\ndma_done = AMD_GETBITS(td->status, UDC_DMA_OUT_STS_BS);\r\n}\r\nif (dma_done == UDC_DMA_OUT_STS_BS_DMA_DONE) {\r\nif (!use_dma_ppb) {\r\ncount = AMD_GETBITS(req->td_data->status,\r\nUDC_DMA_OUT_STS_RXBYTES);\r\nVDBG(dev, "rx bytes=%u\n", count);\r\n} else {\r\nVDBG(dev, "req->td_data=%p\n", req->td_data);\r\nVDBG(dev, "last desc = %p\n", td);\r\nif (use_dma_ppb_du) {\r\ncount = udc_get_ppbdu_rxbytes(req);\r\n} else {\r\ncount = AMD_GETBITS(td->status,\r\nUDC_DMA_OUT_STS_RXBYTES);\r\nif (!count && req->req.length\r\n== UDC_DMA_MAXPACKET) {\r\ncount = UDC_DMA_MAXPACKET;\r\n}\r\n}\r\nVDBG(dev, "last desc rx bytes=%u\n", count);\r\n}\r\ntmp = req->req.length - req->req.actual;\r\nif (count > tmp) {\r\nif ((tmp % ep->ep.maxpacket) != 0) {\r\nDBG(dev, "%s: rx %db, space=%db\n",\r\nep->ep.name, count, tmp);\r\nreq->req.status = -EOVERFLOW;\r\n}\r\ncount = tmp;\r\n}\r\nreq->req.actual += count;\r\nreq->dma_going = 0;\r\ncomplete_req(ep, req, 0);\r\nif (!list_empty(&ep->queue) && !ep->halted) {\r\nreq = list_entry(ep->queue.next,\r\nstruct udc_request,\r\nqueue);\r\nif (req->dma_going == 0) {\r\nif (prep_dma(ep, req, GFP_ATOMIC) != 0)\r\ngoto finished;\r\nwritel(req->td_phys,\r\n&ep->regs->desptr);\r\nreq->dma_going = 1;\r\nudc_set_rde(dev);\r\n}\r\n} else {\r\nif (ep->bna_dummy_req) {\r\nwritel(ep->bna_dummy_req->td_phys,\r\n&ep->regs->desptr);\r\nep->bna_occurred = 0;\r\n}\r\nif (set_rde != 0\r\n&& !timer_pending(&udc_timer)) {\r\nudc_timer.expires =\r\njiffies\r\n+ HZ*UDC_RDE_TIMER_SECONDS;\r\nset_rde = 1;\r\nif (!stop_timer)\r\nadd_timer(&udc_timer);\r\n}\r\nif (ep->num != UDC_EP0OUT_IX)\r\ndev->data_ep_queued = 0;\r\n}\r\n} else {\r\nudc_set_rde(dev);\r\n}\r\n} else if (ep->cancel_transfer) {\r\nret_val = IRQ_HANDLED;\r\nep->cancel_transfer = 0;\r\n}\r\nif (cnak_pending) {\r\nif (readl(&dev->regs->sts) & AMD_BIT(UDC_DEVSTS_RXFIFO_EMPTY))\r\nudc_process_cnak_queue(dev);\r\n}\r\nwritel(UDC_EPSTS_OUT_CLEAR, &ep->regs->sts);\r\nfinished:\r\nreturn ret_val;\r\n}\r\nstatic irqreturn_t udc_data_in_isr(struct udc *dev, int ep_ix)\r\n{\r\nirqreturn_t ret_val = IRQ_NONE;\r\nu32 tmp;\r\nu32 epsts;\r\nstruct udc_ep *ep;\r\nstruct udc_request *req;\r\nstruct udc_data_dma *td;\r\nunsigned len;\r\nep = &dev->ep[ep_ix];\r\nepsts = readl(&ep->regs->sts);\r\nif (use_dma) {\r\nif (epsts & AMD_BIT(UDC_EPSTS_BNA)) {\r\ndev_err(dev->dev,\r\n"BNA ep%din occurred - DESPTR = %08lx\n",\r\nep->num,\r\n(unsigned long) readl(&ep->regs->desptr));\r\nwritel(epsts, &ep->regs->sts);\r\nret_val = IRQ_HANDLED;\r\ngoto finished;\r\n}\r\n}\r\nif (epsts & AMD_BIT(UDC_EPSTS_HE)) {\r\ndev_err(dev->dev,\r\n"HE ep%dn occurred - DESPTR = %08lx\n",\r\nep->num, (unsigned long) readl(&ep->regs->desptr));\r\nwritel(epsts | AMD_BIT(UDC_EPSTS_HE), &ep->regs->sts);\r\nret_val = IRQ_HANDLED;\r\ngoto finished;\r\n}\r\nif (epsts & AMD_BIT(UDC_EPSTS_TDC)) {\r\nVDBG(dev, "TDC set- completion\n");\r\nret_val = IRQ_HANDLED;\r\nif (!ep->cancel_transfer && !list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct udc_request, queue);\r\nif (use_dma_ppb_du) {\r\ntd = udc_get_last_dma_desc(req);\r\nif (td)\r\nreq->req.actual = req->req.length;\r\n} else {\r\nreq->req.actual = req->req.length;\r\n}\r\nif (req->req.actual == req->req.length) {\r\ncomplete_req(ep, req, 0);\r\nreq->dma_going = 0;\r\nif (list_empty(&ep->queue)) {\r\ntmp = readl(&dev->regs->ep_irqmsk);\r\ntmp |= AMD_BIT(ep->num);\r\nwritel(tmp, &dev->regs->ep_irqmsk);\r\n}\r\n}\r\n}\r\nep->cancel_transfer = 0;\r\n}\r\nif ((epsts & AMD_BIT(UDC_EPSTS_IN))\r\n&& !(epsts & AMD_BIT(UDC_EPSTS_TDC))) {\r\nret_val = IRQ_HANDLED;\r\nif (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct udc_request, queue);\r\nif (!use_dma) {\r\nudc_txfifo_write(ep, &req->req);\r\nlen = req->req.length - req->req.actual;\r\nif (len > ep->ep.maxpacket)\r\nlen = ep->ep.maxpacket;\r\nreq->req.actual += len;\r\nif (req->req.actual == req->req.length\r\n|| (len != ep->ep.maxpacket)) {\r\ncomplete_req(ep, req, 0);\r\n}\r\n} else if (req && !req->dma_going) {\r\nVDBG(dev, "IN DMA : req=%p req->td_data=%p\n",\r\nreq, req->td_data);\r\nif (req->td_data) {\r\nreq->dma_going = 1;\r\nif (use_dma_ppb && req->req.length >\r\nep->ep.maxpacket) {\r\nreq->td_data->status &=\r\nAMD_CLEAR_BIT(\r\nUDC_DMA_IN_STS_L);\r\n}\r\nwritel(req->td_phys, &ep->regs->desptr);\r\nreq->td_data->status =\r\nAMD_ADDBITS(\r\nreq->td_data->status,\r\nUDC_DMA_IN_STS_BS_HOST_READY,\r\nUDC_DMA_IN_STS_BS);\r\ntmp = readl(&ep->regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_P);\r\nwritel(tmp, &ep->regs->ctl);\r\n}\r\n}\r\n} else if (!use_dma && ep->in) {\r\ntmp = readl(\r\n&dev->regs->ep_irqmsk);\r\ntmp |= AMD_BIT(ep->num);\r\nwritel(tmp,\r\n&dev->regs->ep_irqmsk);\r\n}\r\n}\r\nwritel(epsts, &ep->regs->sts);\r\nfinished:\r\nreturn ret_val;\r\n}\r\nstatic irqreturn_t udc_control_out_isr(struct udc *dev)\r\n__releases(dev->lock)\r\n__acquires(dev->lock)\r\n{\r\nirqreturn_t ret_val = IRQ_NONE;\r\nu32 tmp;\r\nint setup_supported;\r\nu32 count;\r\nint set = 0;\r\nstruct udc_ep *ep;\r\nstruct udc_ep *ep_tmp;\r\nep = &dev->ep[UDC_EP0OUT_IX];\r\nwritel(AMD_BIT(UDC_EPINT_OUT_EP0), &dev->regs->ep_irqsts);\r\ntmp = readl(&dev->ep[UDC_EP0OUT_IX].regs->sts);\r\nif (tmp & AMD_BIT(UDC_EPSTS_BNA)) {\r\nVDBG(dev, "ep0: BNA set\n");\r\nwritel(AMD_BIT(UDC_EPSTS_BNA),\r\n&dev->ep[UDC_EP0OUT_IX].regs->sts);\r\nep->bna_occurred = 1;\r\nret_val = IRQ_HANDLED;\r\ngoto finished;\r\n}\r\ntmp = AMD_GETBITS(tmp, UDC_EPSTS_OUT);\r\nVDBG(dev, "data_typ = %x\n", tmp);\r\nif (tmp == UDC_EPSTS_OUT_SETUP) {\r\nret_val = IRQ_HANDLED;\r\nep->dev->stall_ep0in = 0;\r\ndev->waiting_zlp_ack_ep0in = 0;\r\ntmp = readl(&dev->ep[UDC_EP0IN_IX].regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_SNAK);\r\nwritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->ctl);\r\ndev->ep[UDC_EP0IN_IX].naking = 1;\r\nif (use_dma) {\r\nwritel(UDC_EPSTS_OUT_CLEAR,\r\n&dev->ep[UDC_EP0OUT_IX].regs->sts);\r\nsetup_data.data[0] =\r\ndev->ep[UDC_EP0OUT_IX].td_stp->data12;\r\nsetup_data.data[1] =\r\ndev->ep[UDC_EP0OUT_IX].td_stp->data34;\r\ndev->ep[UDC_EP0OUT_IX].td_stp->status =\r\nUDC_DMA_STP_STS_BS_HOST_READY;\r\n} else {\r\nudc_rxfifo_read_dwords(dev, setup_data.data, 2);\r\n}\r\nif ((setup_data.request.bRequestType & USB_DIR_IN) != 0) {\r\ndev->gadget.ep0 = &dev->ep[UDC_EP0IN_IX].ep;\r\nudc_ep0_set_rde(dev);\r\nset = 0;\r\n} else {\r\ndev->gadget.ep0 = &dev->ep[UDC_EP0OUT_IX].ep;\r\nif (ep->bna_dummy_req) {\r\nwritel(ep->bna_dummy_req->td_phys,\r\n&dev->ep[UDC_EP0OUT_IX].regs->desptr);\r\nep->bna_occurred = 0;\r\n}\r\nset = 1;\r\ndev->ep[UDC_EP0OUT_IX].naking = 1;\r\nset_rde = 1;\r\nif (!timer_pending(&udc_timer)) {\r\nudc_timer.expires = jiffies +\r\nHZ/UDC_RDE_TIMER_DIV;\r\nif (!stop_timer)\r\nadd_timer(&udc_timer);\r\n}\r\n}\r\nif (setup_data.data[0] == UDC_MSCRES_DWORD0\r\n&& setup_data.data[1] == UDC_MSCRES_DWORD1) {\r\nDBG(dev, "MSC Reset\n");\r\nep_tmp = &udc->ep[UDC_EPIN_IX];\r\nudc_set_halt(&ep_tmp->ep, 0);\r\nep_tmp = &udc->ep[UDC_EPOUT_IX];\r\nudc_set_halt(&ep_tmp->ep, 0);\r\n}\r\nspin_unlock(&dev->lock);\r\nsetup_supported = dev->driver->setup(&dev->gadget,\r\n&setup_data.request);\r\nspin_lock(&dev->lock);\r\ntmp = readl(&dev->ep[UDC_EP0IN_IX].regs->ctl);\r\nif (setup_supported >= 0 && setup_supported <\r\nUDC_EP0IN_MAXPACKET) {\r\ntmp |= AMD_BIT(UDC_EPCTL_CNAK);\r\nwritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->ctl);\r\ndev->ep[UDC_EP0IN_IX].naking = 0;\r\nUDC_QUEUE_CNAK(&dev->ep[UDC_EP0IN_IX], UDC_EP0IN_IX);\r\n} else if (setup_supported < 0) {\r\ntmp |= AMD_BIT(UDC_EPCTL_S);\r\nwritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->ctl);\r\n} else\r\ndev->waiting_zlp_ack_ep0in = 1;\r\nif (!set) {\r\ntmp = readl(&dev->ep[UDC_EP0OUT_IX].regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_CNAK);\r\nwritel(tmp, &dev->ep[UDC_EP0OUT_IX].regs->ctl);\r\ndev->ep[UDC_EP0OUT_IX].naking = 0;\r\nUDC_QUEUE_CNAK(&dev->ep[UDC_EP0OUT_IX], UDC_EP0OUT_IX);\r\n}\r\nif (!use_dma) {\r\nwritel(UDC_EPSTS_OUT_CLEAR,\r\n&dev->ep[UDC_EP0OUT_IX].regs->sts);\r\n}\r\n} else if (tmp == UDC_EPSTS_OUT_DATA) {\r\nwritel(UDC_EPSTS_OUT_CLEAR, &dev->ep[UDC_EP0OUT_IX].regs->sts);\r\nif (use_dma) {\r\nif (list_empty(&dev->ep[UDC_EP0OUT_IX].queue)) {\r\nVDBG(dev, "ZLP\n");\r\ndev->ep[UDC_EP0OUT_IX].td->status =\r\nAMD_ADDBITS(\r\ndev->ep[UDC_EP0OUT_IX].td->status,\r\nUDC_DMA_OUT_STS_BS_HOST_READY,\r\nUDC_DMA_OUT_STS_BS);\r\nudc_ep0_set_rde(dev);\r\nret_val = IRQ_HANDLED;\r\n} else {\r\nret_val |= udc_data_out_isr(dev, UDC_EP0OUT_IX);\r\nwritel(dev->ep[UDC_EP0OUT_IX].td_phys,\r\n&dev->ep[UDC_EP0OUT_IX].regs->desptr);\r\nudc_ep0_set_rde(dev);\r\n}\r\n} else {\r\ncount = readl(&dev->ep[UDC_EP0OUT_IX].regs->sts);\r\ncount = AMD_GETBITS(count, UDC_EPSTS_RX_PKT_SIZE);\r\ncount = 0;\r\nif (count != 0) {\r\nret_val |= udc_data_out_isr(dev, UDC_EP0OUT_IX);\r\n} else {\r\nreadl(&dev->ep[UDC_EP0OUT_IX].regs->confirm);\r\nret_val = IRQ_HANDLED;\r\n}\r\n}\r\n}\r\nif (cnak_pending) {\r\nif (readl(&dev->regs->sts) & AMD_BIT(UDC_DEVSTS_RXFIFO_EMPTY))\r\nudc_process_cnak_queue(dev);\r\n}\r\nfinished:\r\nreturn ret_val;\r\n}\r\nstatic irqreturn_t udc_control_in_isr(struct udc *dev)\r\n{\r\nirqreturn_t ret_val = IRQ_NONE;\r\nu32 tmp;\r\nstruct udc_ep *ep;\r\nstruct udc_request *req;\r\nunsigned len;\r\nep = &dev->ep[UDC_EP0IN_IX];\r\nwritel(AMD_BIT(UDC_EPINT_IN_EP0), &dev->regs->ep_irqsts);\r\ntmp = readl(&dev->ep[UDC_EP0IN_IX].regs->sts);\r\nif (tmp & AMD_BIT(UDC_EPSTS_TDC)) {\r\nVDBG(dev, "isr: TDC clear\n");\r\nret_val = IRQ_HANDLED;\r\nwritel(AMD_BIT(UDC_EPSTS_TDC),\r\n&dev->ep[UDC_EP0IN_IX].regs->sts);\r\n} else if (tmp & AMD_BIT(UDC_EPSTS_IN)) {\r\nret_val = IRQ_HANDLED;\r\nif (ep->dma) {\r\nwritel(AMD_BIT(UDC_EPSTS_IN),\r\n&dev->ep[UDC_EP0IN_IX].regs->sts);\r\n}\r\nif (dev->stall_ep0in) {\r\nDBG(dev, "stall ep0in\n");\r\ntmp = readl(&ep->regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_S);\r\nwritel(tmp, &ep->regs->ctl);\r\n} else {\r\nif (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct udc_request, queue);\r\nif (ep->dma) {\r\nwritel(req->td_phys, &ep->regs->desptr);\r\nreq->td_data->status =\r\nAMD_ADDBITS(\r\nreq->td_data->status,\r\nUDC_DMA_STP_STS_BS_HOST_READY,\r\nUDC_DMA_STP_STS_BS);\r\ntmp =\r\nreadl(&dev->ep[UDC_EP0IN_IX].regs->ctl);\r\ntmp |= AMD_BIT(UDC_EPCTL_P);\r\nwritel(tmp,\r\n&dev->ep[UDC_EP0IN_IX].regs->ctl);\r\nreq->req.actual = req->req.length;\r\ncomplete_req(ep, req, 0);\r\n} else {\r\nudc_txfifo_write(ep, &req->req);\r\nlen = req->req.length - req->req.actual;\r\nif (len > ep->ep.maxpacket)\r\nlen = ep->ep.maxpacket;\r\nreq->req.actual += len;\r\nif (req->req.actual == req->req.length\r\n|| (len != ep->ep.maxpacket)) {\r\ncomplete_req(ep, req, 0);\r\n}\r\n}\r\n}\r\n}\r\nep->halted = 0;\r\ndev->stall_ep0in = 0;\r\nif (!ep->dma) {\r\nwritel(AMD_BIT(UDC_EPSTS_IN),\r\n&dev->ep[UDC_EP0IN_IX].regs->sts);\r\n}\r\n}\r\nreturn ret_val;\r\n}\r\nstatic irqreturn_t udc_dev_isr(struct udc *dev, u32 dev_irq)\r\n__releases(dev->lock)\r\n__acquires(dev->lock)\r\n{\r\nirqreturn_t ret_val = IRQ_NONE;\r\nu32 tmp;\r\nu32 cfg;\r\nstruct udc_ep *ep;\r\nu16 i;\r\nu8 udc_csr_epix;\r\nif (dev_irq & AMD_BIT(UDC_DEVINT_SC)) {\r\nret_val = IRQ_HANDLED;\r\ntmp = readl(&dev->regs->sts);\r\ncfg = AMD_GETBITS(tmp, UDC_DEVSTS_CFG);\r\nDBG(dev, "SET_CONFIG interrupt: config=%d\n", cfg);\r\ndev->cur_config = cfg;\r\ndev->set_cfg_not_acked = 1;\r\nmemset(&setup_data, 0 , sizeof(union udc_setup_data));\r\nsetup_data.request.bRequest = USB_REQ_SET_CONFIGURATION;\r\nsetup_data.request.wValue = cpu_to_le16(dev->cur_config);\r\nfor (i = 0; i < UDC_EP_NUM; i++) {\r\nep = &dev->ep[i];\r\nif (ep->in) {\r\nudc_csr_epix = ep->num;\r\n} else {\r\nudc_csr_epix = ep->num - UDC_CSR_EP_OUT_IX_OFS;\r\n}\r\ntmp = readl(&dev->csr->ne[udc_csr_epix]);\r\ntmp = AMD_ADDBITS(tmp, ep->dev->cur_config,\r\nUDC_CSR_NE_CFG);\r\nwritel(tmp, &dev->csr->ne[udc_csr_epix]);\r\nep->halted = 0;\r\ntmp = readl(&ep->regs->ctl);\r\ntmp = tmp & AMD_CLEAR_BIT(UDC_EPCTL_S);\r\nwritel(tmp, &ep->regs->ctl);\r\n}\r\nspin_unlock(&dev->lock);\r\ntmp = dev->driver->setup(&dev->gadget, &setup_data.request);\r\nspin_lock(&dev->lock);\r\n}\r\nif (dev_irq & AMD_BIT(UDC_DEVINT_SI)) {\r\nret_val = IRQ_HANDLED;\r\ndev->set_cfg_not_acked = 1;\r\ntmp = readl(&dev->regs->sts);\r\ndev->cur_alt = AMD_GETBITS(tmp, UDC_DEVSTS_ALT);\r\ndev->cur_intf = AMD_GETBITS(tmp, UDC_DEVSTS_INTF);\r\nmemset(&setup_data, 0 , sizeof(union udc_setup_data));\r\nsetup_data.request.bRequest = USB_REQ_SET_INTERFACE;\r\nsetup_data.request.bRequestType = USB_RECIP_INTERFACE;\r\nsetup_data.request.wValue = cpu_to_le16(dev->cur_alt);\r\nsetup_data.request.wIndex = cpu_to_le16(dev->cur_intf);\r\nDBG(dev, "SET_INTERFACE interrupt: alt=%d intf=%d\n",\r\ndev->cur_alt, dev->cur_intf);\r\nfor (i = 0; i < UDC_EP_NUM; i++) {\r\nep = &dev->ep[i];\r\nif (ep->in) {\r\nudc_csr_epix = ep->num;\r\n} else {\r\nudc_csr_epix = ep->num - UDC_CSR_EP_OUT_IX_OFS;\r\n}\r\ntmp = readl(&dev->csr->ne[udc_csr_epix]);\r\ntmp = AMD_ADDBITS(tmp, ep->dev->cur_intf,\r\nUDC_CSR_NE_INTF);\r\ntmp = AMD_ADDBITS(tmp, ep->dev->cur_alt,\r\nUDC_CSR_NE_ALT);\r\nwritel(tmp, &dev->csr->ne[udc_csr_epix]);\r\nep->halted = 0;\r\ntmp = readl(&ep->regs->ctl);\r\ntmp = tmp & AMD_CLEAR_BIT(UDC_EPCTL_S);\r\nwritel(tmp, &ep->regs->ctl);\r\n}\r\nspin_unlock(&dev->lock);\r\ntmp = dev->driver->setup(&dev->gadget, &setup_data.request);\r\nspin_lock(&dev->lock);\r\n}\r\nif (dev_irq & AMD_BIT(UDC_DEVINT_UR)) {\r\nDBG(dev, "USB Reset interrupt\n");\r\nret_val = IRQ_HANDLED;\r\nsoft_reset_occured = 0;\r\ndev->waiting_zlp_ack_ep0in = 0;\r\ndev->set_cfg_not_acked = 0;\r\nudc_mask_unused_interrupts(dev);\r\nspin_unlock(&dev->lock);\r\nif (dev->sys_suspended && dev->driver->resume) {\r\ndev->driver->resume(&dev->gadget);\r\ndev->sys_suspended = 0;\r\n}\r\nusb_gadget_udc_reset(&dev->gadget, dev->driver);\r\nspin_lock(&dev->lock);\r\nempty_req_queue(&dev->ep[UDC_EP0IN_IX]);\r\nep_init(dev->regs, &dev->ep[UDC_EP0IN_IX]);\r\ntmp = readl(&dev->regs->sts);\r\nif (!(tmp & AMD_BIT(UDC_DEVSTS_RXFIFO_EMPTY))\r\n&& !soft_reset_after_usbreset_occured) {\r\nudc_soft_reset(dev);\r\nsoft_reset_after_usbreset_occured++;\r\n}\r\nDBG(dev, "DMA machine reset\n");\r\ntmp = readl(&dev->regs->cfg);\r\nwritel(tmp | AMD_BIT(UDC_DEVCFG_DMARST), &dev->regs->cfg);\r\nwritel(tmp, &dev->regs->cfg);\r\nudc_basic_init(dev);\r\nudc_enable_dev_setup_interrupts(dev);\r\ntmp = readl(&dev->regs->irqmsk);\r\ntmp &= AMD_UNMASK_BIT(UDC_DEVINT_US);\r\nwritel(tmp, &dev->regs->irqmsk);\r\n}\r\nif (dev_irq & AMD_BIT(UDC_DEVINT_US)) {\r\nDBG(dev, "USB Suspend interrupt\n");\r\nret_val = IRQ_HANDLED;\r\nif (dev->driver->suspend) {\r\nspin_unlock(&dev->lock);\r\ndev->sys_suspended = 1;\r\ndev->driver->suspend(&dev->gadget);\r\nspin_lock(&dev->lock);\r\n}\r\n}\r\nif (dev_irq & AMD_BIT(UDC_DEVINT_ENUM)) {\r\nDBG(dev, "ENUM interrupt\n");\r\nret_val = IRQ_HANDLED;\r\nsoft_reset_after_usbreset_occured = 0;\r\nempty_req_queue(&dev->ep[UDC_EP0IN_IX]);\r\nep_init(dev->regs, &dev->ep[UDC_EP0IN_IX]);\r\nudc_setup_endpoints(dev);\r\ndev_info(dev->dev, "Connect: %s\n",\r\nusb_speed_string(dev->gadget.speed));\r\nactivate_control_endpoints(dev);\r\nudc_enable_ep0_interrupts(dev);\r\n}\r\nif (dev_irq & AMD_BIT(UDC_DEVINT_SVC)) {\r\nDBG(dev, "USB SVC interrupt\n");\r\nret_val = IRQ_HANDLED;\r\ntmp = readl(&dev->regs->sts);\r\nif (!(tmp & AMD_BIT(UDC_DEVSTS_SESSVLD))) {\r\ntmp = readl(&dev->regs->irqmsk);\r\ntmp |= AMD_BIT(UDC_DEVINT_US);\r\nwritel(tmp, &dev->regs->irqmsk);\r\nDBG(dev, "USB Disconnect (session valid low)\n");\r\nusb_disconnect(udc);\r\n}\r\n}\r\nreturn ret_val;\r\n}\r\nirqreturn_t udc_irq(int irq, void *pdev)\r\n{\r\nstruct udc *dev = pdev;\r\nu32 reg;\r\nu16 i;\r\nu32 ep_irq;\r\nirqreturn_t ret_val = IRQ_NONE;\r\nspin_lock(&dev->lock);\r\nreg = readl(&dev->regs->ep_irqsts);\r\nif (reg) {\r\nif (reg & AMD_BIT(UDC_EPINT_OUT_EP0))\r\nret_val |= udc_control_out_isr(dev);\r\nif (reg & AMD_BIT(UDC_EPINT_IN_EP0))\r\nret_val |= udc_control_in_isr(dev);\r\nfor (i = 1; i < UDC_EP_NUM; i++) {\r\nep_irq = 1 << i;\r\nif (!(reg & ep_irq) || i == UDC_EPINT_OUT_EP0)\r\ncontinue;\r\nwritel(ep_irq, &dev->regs->ep_irqsts);\r\nif (i > UDC_EPIN_NUM)\r\nret_val |= udc_data_out_isr(dev, i);\r\nelse\r\nret_val |= udc_data_in_isr(dev, i);\r\n}\r\n}\r\nreg = readl(&dev->regs->irqsts);\r\nif (reg) {\r\nwritel(reg, &dev->regs->irqsts);\r\nret_val |= udc_dev_isr(dev, reg);\r\n}\r\nspin_unlock(&dev->lock);\r\nreturn ret_val;\r\n}\r\nvoid gadget_release(struct device *pdev)\r\n{\r\nstruct amd5536udc *dev = dev_get_drvdata(pdev);\r\nkfree(dev);\r\n}\r\nvoid udc_remove(struct udc *dev)\r\n{\r\nstop_timer++;\r\nif (timer_pending(&udc_timer))\r\nwait_for_completion(&on_exit);\r\nif (udc_timer.data)\r\ndel_timer_sync(&udc_timer);\r\nstop_pollstall_timer++;\r\nif (timer_pending(&udc_pollstall_timer))\r\nwait_for_completion(&on_pollstall_exit);\r\nif (udc_pollstall_timer.data)\r\ndel_timer_sync(&udc_pollstall_timer);\r\nudc = NULL;\r\n}\r\nvoid free_dma_pools(struct udc *dev)\r\n{\r\ndma_pool_free(dev->stp_requests, dev->ep[UDC_EP0OUT_IX].td,\r\ndev->ep[UDC_EP0OUT_IX].td_phys);\r\ndma_pool_free(dev->stp_requests, dev->ep[UDC_EP0OUT_IX].td_stp,\r\ndev->ep[UDC_EP0OUT_IX].td_stp_dma);\r\ndma_pool_destroy(dev->stp_requests);\r\ndma_pool_destroy(dev->data_requests);\r\n}\r\nint init_dma_pools(struct udc *dev)\r\n{\r\nstruct udc_stp_dma *td_stp;\r\nstruct udc_data_dma *td_data;\r\nint retval;\r\nif (use_dma_ppb) {\r\nuse_dma_bufferfill_mode = 0;\r\n} else {\r\nuse_dma_ppb_du = 0;\r\nuse_dma_bufferfill_mode = 1;\r\n}\r\ndev->data_requests = dma_pool_create("data_requests", dev->dev,\r\nsizeof(struct udc_data_dma), 0, 0);\r\nif (!dev->data_requests) {\r\nDBG(dev, "can't get request data pool\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->ep[UDC_EP0IN_IX].dma = &dev->regs->ctl;\r\ndev->stp_requests = dma_pool_create("setup requests", dev->dev,\r\nsizeof(struct udc_stp_dma), 0, 0);\r\nif (!dev->stp_requests) {\r\nDBG(dev, "can't get stp request pool\n");\r\nretval = -ENOMEM;\r\ngoto err_create_dma_pool;\r\n}\r\ntd_stp = dma_pool_alloc(dev->stp_requests, GFP_KERNEL,\r\n&dev->ep[UDC_EP0OUT_IX].td_stp_dma);\r\nif (!td_stp) {\r\nretval = -ENOMEM;\r\ngoto err_alloc_dma;\r\n}\r\ndev->ep[UDC_EP0OUT_IX].td_stp = td_stp;\r\ntd_data = dma_pool_alloc(dev->stp_requests, GFP_KERNEL,\r\n&dev->ep[UDC_EP0OUT_IX].td_phys);\r\nif (!td_data) {\r\nretval = -ENOMEM;\r\ngoto err_alloc_phys;\r\n}\r\ndev->ep[UDC_EP0OUT_IX].td = td_data;\r\nreturn 0;\r\nerr_alloc_phys:\r\ndma_pool_free(dev->stp_requests, dev->ep[UDC_EP0OUT_IX].td_stp,\r\ndev->ep[UDC_EP0OUT_IX].td_stp_dma);\r\nerr_alloc_dma:\r\ndma_pool_destroy(dev->stp_requests);\r\ndev->stp_requests = NULL;\r\nerr_create_dma_pool:\r\ndma_pool_destroy(dev->data_requests);\r\ndev->data_requests = NULL;\r\nreturn retval;\r\n}\r\nint udc_probe(struct udc *dev)\r\n{\r\nchar tmp[128];\r\nu32 reg;\r\nint retval;\r\nudc_timer.data = 0;\r\nudc_pollstall_timer.data = 0;\r\ndev->gadget.ops = &udc_ops;\r\ndev_set_name(&dev->gadget.dev, "gadget");\r\ndev->gadget.name = name;\r\ndev->gadget.max_speed = USB_SPEED_HIGH;\r\nstartup_registers(dev);\r\ndev_info(dev->dev, "%s\n", mod_desc);\r\nsnprintf(tmp, sizeof(tmp), "%d", dev->irq);\r\nif (dev->chiprev == UDC_HSA0_REV ||\r\ndev->chiprev == UDC_HSB1_REV) {\r\ndev_info(dev->dev, "irq %s, pci mem %08lx, chip rev %02x(Geode5536 %s)\n",\r\ntmp, dev->phys_addr, dev->chiprev,\r\n(dev->chiprev == UDC_HSA0_REV) ?\r\n"A0" : "B1");\r\nstrcpy(tmp, UDC_DRIVER_VERSION_STRING);\r\nif (dev->chiprev == UDC_HSA0_REV) {\r\ndev_err(dev->dev, "chip revision is A0; too old\n");\r\nretval = -ENODEV;\r\ngoto finished;\r\n}\r\ndev_info(dev->dev,\r\n"driver version: %s(for Geode5536 B1)\n", tmp);\r\n}\r\nudc = dev;\r\nretval = usb_add_gadget_udc_release(udc->dev, &dev->gadget,\r\ngadget_release);\r\nif (retval)\r\ngoto finished;\r\ninit_timer(&udc_timer);\r\nudc_timer.function = udc_timer_function;\r\nudc_timer.data = 1;\r\ninit_timer(&udc_pollstall_timer);\r\nudc_pollstall_timer.function = udc_pollstall_timer_function;\r\nudc_pollstall_timer.data = 1;\r\nreg = readl(&dev->regs->ctl);\r\nreg |= AMD_BIT(UDC_DEVCTL_SD);\r\nwritel(reg, &dev->regs->ctl);\r\nprint_regs(dev);\r\nreturn 0;\r\nfinished:\r\nreturn retval;\r\n}
