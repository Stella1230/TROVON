static int cx24113_writereg(struct cx24113_state *state, int reg, int data)\r\n{\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = { .addr = state->config->i2c_addr,\r\n.flags = 0, .buf = buf, .len = 2 };\r\nint err = i2c_transfer(state->i2c, &msg, 1);\r\nif (err != 1) {\r\nprintk(KERN_DEBUG "%s: writereg error(err == %i, reg == 0x%02x, data == 0x%02x)\n",\r\n__func__, err, reg, data);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24113_readreg(struct cx24113_state *state, u8 reg)\r\n{\r\nint ret;\r\nu8 b;\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->config->i2c_addr,\r\n.flags = 0, .buf = &reg, .len = 1 },\r\n{ .addr = state->config->i2c_addr,\r\n.flags = I2C_M_RD, .buf = &b, .len = 1 }\r\n};\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2) {\r\nprintk(KERN_DEBUG "%s: reg=0x%x (error=%d)\n",\r\n__func__, reg, ret);\r\nreturn ret;\r\n}\r\nreturn b;\r\n}\r\nstatic void cx24113_set_parameters(struct cx24113_state *state)\r\n{\r\nu8 r;\r\nr = cx24113_readreg(state, 0x10) & 0x82;\r\nr |= state->icp_mode;\r\nr |= state->icp_man << 4;\r\nr |= state->icp_dig << 2;\r\nr |= state->prescaler_mode << 5;\r\ncx24113_writereg(state, 0x10, r);\r\nr = (state->icp_auto_low << 0) | (state->icp_auto_mlow << 2)\r\n| (state->icp_auto_mhi << 4) | (state->icp_auto_hi << 6);\r\ncx24113_writereg(state, 0x11, r);\r\nif (state->rev == REV_CX24113) {\r\nr = cx24113_readreg(state, 0x20) & 0xec;\r\nr |= state->lna_gain;\r\nr |= state->rfvga_bias_ctrl << 4;\r\ncx24113_writereg(state, 0x20, r);\r\n}\r\nr = cx24113_readreg(state, 0x12) & 0x03;\r\nr |= state->acp_on << 2;\r\nr |= state->bs_delay << 4;\r\ncx24113_writereg(state, 0x12, r);\r\nr = cx24113_readreg(state, 0x18) & 0x40;\r\nr |= state->vco_shift;\r\nif (state->vco_band == VCOBANDSEL_6)\r\nr |= (1 << 7);\r\nelse\r\nr |= (state->vco_band << 1);\r\ncx24113_writereg(state, 0x18, r);\r\nr = cx24113_readreg(state, 0x14) & 0x20;\r\nr |= (state->vco_mode << 6) | ((state->bs_freqcnt >> 8) & 0x1f);\r\ncx24113_writereg(state, 0x14, r);\r\ncx24113_writereg(state, 0x15, (state->bs_freqcnt & 0xff));\r\ncx24113_writereg(state, 0x16, (state->bs_rdiv >> 4) & 0xff);\r\nr = (cx24113_readreg(state, 0x17) & 0x0f) |\r\n((state->bs_rdiv & 0x0f) << 4);\r\ncx24113_writereg(state, 0x17, r);\r\n}\r\nstatic int cx24113_set_gain_settings(struct cx24113_state *state,\r\ns16 power_estimation)\r\n{\r\nu8 ampout = cx24113_readreg(state, 0x1d) & 0xf0,\r\nvga = cx24113_readreg(state, 0x1f) & 0x3f,\r\nrfvga = cx24113_readreg(state, 0x20) & 0xf3;\r\nu8 gain_level = power_estimation >= state->tuner_gain_thres;\r\ndprintk("power estimation: %d, thres: %d, gain_level: %d/%d\n",\r\npower_estimation, state->tuner_gain_thres,\r\nstate->gain_level, gain_level);\r\nif (gain_level == state->gain_level)\r\nreturn 0;\r\nampout |= 0xf;\r\nif (gain_level) {\r\nrfvga |= RFVGA_0 << 2;\r\nvga |= (VGA_7 << 3) | VGA_7;\r\n} else {\r\nrfvga |= RFVGA_2 << 2;\r\nvga |= (VGA_6 << 3) | VGA_2;\r\n}\r\nstate->gain_level = gain_level;\r\ncx24113_writereg(state, 0x1d, ampout);\r\ncx24113_writereg(state, 0x1f, vga);\r\ncx24113_writereg(state, 0x20, rfvga);\r\nreturn 1;\r\n}\r\nstatic int cx24113_set_Fref(struct cx24113_state *state, u8 high)\r\n{\r\nu8 xtal = cx24113_readreg(state, 0x02);\r\nif (state->rev == 0x43 && state->vcodiv == VCODIV4)\r\nhigh = 1;\r\nxtal &= ~0x2;\r\nif (high)\r\nxtal |= high << 1;\r\nreturn cx24113_writereg(state, 0x02, xtal);\r\n}\r\nstatic int cx24113_enable(struct cx24113_state *state, u8 enable)\r\n{\r\nu8 r21 = (cx24113_readreg(state, 0x21) & 0xc0) | enable;\r\nif (state->rev == REV_CX24113)\r\nr21 |= (1 << 1);\r\nreturn cx24113_writereg(state, 0x21, r21);\r\n}\r\nstatic int cx24113_set_bandwidth(struct cx24113_state *state, u32 bandwidth_khz)\r\n{\r\nu8 r;\r\nif (bandwidth_khz <= 19000)\r\nr = 0x03 << 6;\r\nelse if (bandwidth_khz <= 25000)\r\nr = 0x02 << 6;\r\nelse\r\nr = 0x01 << 6;\r\ndprintk("bandwidth to be set: %d\n", bandwidth_khz);\r\nbandwidth_khz *= 10;\r\nbandwidth_khz -= 10000;\r\nbandwidth_khz /= 1000;\r\nbandwidth_khz += 5;\r\nbandwidth_khz /= 10;\r\ndprintk("bandwidth: %d %d\n", r >> 6, bandwidth_khz);\r\nr |= bandwidth_khz & 0x3f;\r\nreturn cx24113_writereg(state, 0x1e, r);\r\n}\r\nstatic int cx24113_set_clk_inversion(struct cx24113_state *state, u8 on)\r\n{\r\nu8 r = (cx24113_readreg(state, 0x10) & 0x7f) | ((on & 0x1) << 7);\r\nreturn cx24113_writereg(state, 0x10, r);\r\n}\r\nstatic int cx24113_get_status(struct dvb_frontend *fe, u32 *status)\r\n{\r\nstruct cx24113_state *state = fe->tuner_priv;\r\nu8 r = (cx24113_readreg(state, 0x10) & 0x02) >> 1;\r\nif (r)\r\n*status |= TUNER_STATUS_LOCKED;\r\ndprintk("PLL locked: %d\n", r);\r\nreturn 0;\r\n}\r\nstatic u8 cx24113_set_ref_div(struct cx24113_state *state, u8 refdiv)\r\n{\r\nif (state->rev == 0x43 && state->vcodiv == VCODIV4)\r\nrefdiv = 2;\r\nreturn state->refdiv = refdiv;\r\n}\r\nstatic void cx24113_calc_pll_nf(struct cx24113_state *state, u16 *n, s32 *f)\r\n{\r\ns32 N;\r\ns64 F;\r\nu64 dividend;\r\nu8 R, r;\r\nu8 vcodiv;\r\nu8 factor;\r\ns32 freq_hz = state->frequency * 1000;\r\nif (state->config->xtal_khz < 20000)\r\nfactor = 1;\r\nelse\r\nfactor = 2;\r\nif (state->rev == REV_CX24113) {\r\nif (state->frequency >= 1100000)\r\nvcodiv = VCODIV2;\r\nelse\r\nvcodiv = VCODIV4;\r\n} else {\r\nif (state->frequency >= 1165000)\r\nvcodiv = VCODIV2;\r\nelse\r\nvcodiv = VCODIV4;\r\n}\r\nstate->vcodiv = vcodiv;\r\ndprintk("calculating N/F for %dHz with vcodiv %d\n", freq_hz, vcodiv);\r\nR = 0;\r\ndo {\r\nR = cx24113_set_ref_div(state, R + 1);\r\nN = (freq_hz / 100 * vcodiv) * R;\r\nN /= (state->config->xtal_khz) * factor * 2;\r\nN += 5;\r\nN /= 10;\r\nN -= 32;\r\n} while (N < 6 && R < 3);\r\nif (N < 6) {\r\ncx_err("strange frequency: N < 6\n");\r\nreturn;\r\n}\r\nF = freq_hz;\r\nF *= (u64) (R * vcodiv * 262144);\r\ndprintk("1 N: %d, F: %lld, R: %d\n", N, (long long)F, R);\r\ndividend = F;\r\ndo_div(dividend, state->config->xtal_khz * 1000 * factor * 2);\r\nF = dividend;\r\ndprintk("2 N: %d, F: %lld, R: %d\n", N, (long long)F, R);\r\nF -= (N + 32) * 262144;\r\ndprintk("3 N: %d, F: %lld, R: %d\n", N, (long long)F, R);\r\nif (state->Fwindow_enabled) {\r\nif (F > (262144 / 2 - 1638))\r\nF = 262144 / 2 - 1638;\r\nif (F < (-262144 / 2 + 1638))\r\nF = -262144 / 2 + 1638;\r\nif ((F < 3277 && F > 0) || (F > -3277 && F < 0)) {\r\nF = 0;\r\nr = cx24113_readreg(state, 0x10);\r\ncx24113_writereg(state, 0x10, r | (1 << 6));\r\n}\r\n}\r\ndprintk("4 N: %d, F: %lld, R: %d\n", N, (long long)F, R);\r\n*n = (u16) N;\r\n*f = (s32) F;\r\n}\r\nstatic void cx24113_set_nfr(struct cx24113_state *state, u16 n, s32 f, u8 r)\r\n{\r\nu8 reg;\r\ncx24113_writereg(state, 0x19, (n >> 1) & 0xff);\r\nreg = ((n & 0x1) << 7) | ((f >> 11) & 0x7f);\r\ncx24113_writereg(state, 0x1a, reg);\r\ncx24113_writereg(state, 0x1b, (f >> 3) & 0xff);\r\nreg = cx24113_readreg(state, 0x1c) & 0x1f;\r\ncx24113_writereg(state, 0x1c, reg | ((f & 0x7) << 5));\r\ncx24113_set_Fref(state, r - 1);\r\n}\r\nstatic int cx24113_set_frequency(struct cx24113_state *state, u32 frequency)\r\n{\r\nu8 r = 1;\r\nu16 n = 6;\r\ns32 f = 0;\r\nr = cx24113_readreg(state, 0x14);\r\ncx24113_writereg(state, 0x14, r & 0x3f);\r\nr = cx24113_readreg(state, 0x10);\r\ncx24113_writereg(state, 0x10, r & 0xbf);\r\nstate->frequency = frequency;\r\ndprintk("tuning to frequency: %d\n", frequency);\r\ncx24113_calc_pll_nf(state, &n, &f);\r\ncx24113_set_nfr(state, n, f, state->refdiv);\r\nr = cx24113_readreg(state, 0x18) & 0xbf;\r\nif (state->vcodiv != VCODIV2)\r\nr |= 1 << 6;\r\ncx24113_writereg(state, 0x18, r);\r\nmsleep(5);\r\nr = cx24113_readreg(state, 0x1c) & 0xef;\r\ncx24113_writereg(state, 0x1c, r | (1 << 4));\r\nreturn 0;\r\n}\r\nstatic int cx24113_init(struct dvb_frontend *fe)\r\n{\r\nstruct cx24113_state *state = fe->tuner_priv;\r\nint ret;\r\nstate->tuner_gain_thres = -50;\r\nstate->gain_level = 255;\r\nstate->icp_mode = 0;\r\nif (state->config->xtal_khz < 11000) {\r\nstate->icp_auto_hi = ICP_LEVEL4;\r\nstate->icp_auto_mhi = ICP_LEVEL4;\r\nstate->icp_auto_mlow = ICP_LEVEL3;\r\nstate->icp_auto_low = ICP_LEVEL3;\r\n} else {\r\nstate->icp_auto_hi = ICP_LEVEL4;\r\nstate->icp_auto_mhi = ICP_LEVEL4;\r\nstate->icp_auto_mlow = ICP_LEVEL3;\r\nstate->icp_auto_low = ICP_LEVEL2;\r\n}\r\nstate->icp_dig = ICP_LEVEL3;\r\nstate->icp_man = ICP_LEVEL1;\r\nstate->acp_on = 1;\r\nstate->vco_mode = 0;\r\nstate->vco_shift = 0;\r\nstate->vco_band = VCOBANDSEL_1;\r\nstate->bs_delay = 8;\r\nstate->bs_freqcnt = 0x0fff;\r\nstate->bs_rdiv = 0x0fff;\r\nstate->prescaler_mode = 0;\r\nstate->lna_gain = LNA_MAX_GAIN;\r\nstate->rfvga_bias_ctrl = 1;\r\nstate->Fwindow_enabled = 1;\r\ncx24113_set_Fref(state, 0);\r\ncx24113_enable(state, 0x3d);\r\ncx24113_set_parameters(state);\r\ncx24113_set_gain_settings(state, -30);\r\ncx24113_set_bandwidth(state, 18025);\r\ncx24113_set_clk_inversion(state, 1);\r\nif (state->config->xtal_khz >= 40000)\r\nret = cx24113_writereg(state, 0x02,\r\n(cx24113_readreg(state, 0x02) & 0xfb) | (1 << 2));\r\nelse\r\nret = cx24113_writereg(state, 0x02,\r\n(cx24113_readreg(state, 0x02) & 0xfb) | (0 << 2));\r\nreturn ret;\r\n}\r\nstatic int cx24113_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct cx24113_state *state = fe->tuner_priv;\r\nu32 roll_off = 675;\r\nu32 bw;\r\nbw = ((c->symbol_rate/100) * roll_off) / 1000;\r\nbw += (10000000/100) + 5;\r\nbw /= 10;\r\nbw += 1000;\r\ncx24113_set_bandwidth(state, bw);\r\ncx24113_set_frequency(state, c->frequency);\r\nmsleep(5);\r\nreturn cx24113_get_status(fe, &bw);\r\n}\r\nvoid cx24113_agc_callback(struct dvb_frontend *fe)\r\n{\r\nstruct cx24113_state *state = fe->tuner_priv;\r\ns16 s, i;\r\nif (!fe->ops.read_signal_strength)\r\nreturn;\r\ndo {\r\nfe->ops.read_signal_strength(fe, (u16 *) &s);\r\ns >>= 8;\r\ndprintk("signal strength: %d\n", s);\r\nfor (i = 0; i < sizeof(cx24113_agc_table[0]); i++)\r\nif (cx24113_agc_table[state->gain_level][i] > s)\r\nbreak;\r\ns = -25 - i*5;\r\n} while (cx24113_set_gain_settings(state, s));\r\n}\r\nstatic int cx24113_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct cx24113_state *state = fe->tuner_priv;\r\n*frequency = state->frequency;\r\nreturn 0;\r\n}\r\nstatic void cx24113_release(struct dvb_frontend *fe)\r\n{\r\nstruct cx24113_state *state = fe->tuner_priv;\r\ndprintk("\n");\r\nfe->tuner_priv = NULL;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *cx24113_attach(struct dvb_frontend *fe,\r\nconst struct cx24113_config *config, struct i2c_adapter *i2c)\r\n{\r\nstruct cx24113_state *state =\r\nkzalloc(sizeof(struct cx24113_state), GFP_KERNEL);\r\nint rc;\r\nif (state == NULL) {\r\ncx_err("Unable to kzalloc\n");\r\ngoto error;\r\n}\r\nstate->config = config;\r\nstate->i2c = i2c;\r\ncx_info("trying to detect myself\n");\r\ncx24113_readreg(state, 0x00);\r\nrc = cx24113_readreg(state, 0x00);\r\nif (rc < 0) {\r\ncx_info("CX24113 not found.\n");\r\ngoto error;\r\n}\r\nstate->rev = rc;\r\nswitch (rc) {\r\ncase 0x43:\r\ncx_info("detected CX24113 variant\n");\r\nbreak;\r\ncase REV_CX24113:\r\ncx_info("successfully detected\n");\r\nbreak;\r\ndefault:\r\ncx_err("unsupported device id: %x\n", state->rev);\r\ngoto error;\r\n}\r\nstate->ver = cx24113_readreg(state, 0x01);\r\ncx_info("version: %x\n", state->ver);\r\nmemcpy(&fe->ops.tuner_ops, &cx24113_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = state;\r\nreturn fe;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
