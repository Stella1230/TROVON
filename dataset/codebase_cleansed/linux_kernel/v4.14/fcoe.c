static int fcoe_interface_setup(struct fcoe_interface *fcoe,\r\nstruct net_device *netdev)\r\n{\r\nstruct fcoe_ctlr *fip = fcoe_to_ctlr(fcoe);\r\nstruct netdev_hw_addr *ha;\r\nstruct net_device *real_dev;\r\nu8 flogi_maddr[ETH_ALEN];\r\nconst struct net_device_ops *ops;\r\nfcoe->netdev = netdev;\r\nops = netdev->netdev_ops;\r\nif (ops->ndo_fcoe_enable) {\r\nif (ops->ndo_fcoe_enable(netdev))\r\nFCOE_NETDEV_DBG(netdev, "Failed to enable FCoE"\r\n" specific feature for LLD.\n");\r\n}\r\nif (netdev->priv_flags & IFF_BONDING && netdev->flags & IFF_MASTER) {\r\nFCOE_NETDEV_DBG(netdev, "Bonded interfaces not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nreal_dev = is_vlan_dev(netdev) ? vlan_dev_real_dev(netdev) : netdev;\r\nfcoe->realdev = real_dev;\r\nrcu_read_lock();\r\nfor_each_dev_addr(real_dev, ha) {\r\nif ((ha->type == NETDEV_HW_ADDR_T_SAN) &&\r\n(is_valid_ether_addr(ha->addr))) {\r\nmemcpy(fip->ctl_src_addr, ha->addr, ETH_ALEN);\r\nfip->spma = 1;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (!fip->spma)\r\nmemcpy(fip->ctl_src_addr, netdev->dev_addr, netdev->addr_len);\r\nmemcpy(flogi_maddr, (u8[6]) FC_FCOE_FLOGI_MAC, ETH_ALEN);\r\ndev_uc_add(netdev, flogi_maddr);\r\nif (fip->spma)\r\ndev_uc_add(netdev, fip->ctl_src_addr);\r\nif (fip->mode == FIP_MODE_VN2VN) {\r\ndev_mc_add(netdev, FIP_ALL_VN2VN_MACS);\r\ndev_mc_add(netdev, FIP_ALL_P2P_MACS);\r\n} else\r\ndev_mc_add(netdev, FIP_ALL_ENODE_MACS);\r\nfcoe->fcoe_packet_type.func = fcoe_rcv;\r\nfcoe->fcoe_packet_type.type = htons(ETH_P_FCOE);\r\nfcoe->fcoe_packet_type.dev = netdev;\r\ndev_add_pack(&fcoe->fcoe_packet_type);\r\nfcoe->fip_packet_type.func = fcoe_fip_recv;\r\nfcoe->fip_packet_type.type = htons(ETH_P_FIP);\r\nfcoe->fip_packet_type.dev = netdev;\r\ndev_add_pack(&fcoe->fip_packet_type);\r\nif (netdev != real_dev) {\r\nfcoe->fip_vlan_packet_type.func = fcoe_fip_vlan_recv;\r\nfcoe->fip_vlan_packet_type.type = htons(ETH_P_FIP);\r\nfcoe->fip_vlan_packet_type.dev = real_dev;\r\ndev_add_pack(&fcoe->fip_vlan_packet_type);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct fcoe_interface *fcoe_interface_create(struct net_device *netdev,\r\nenum fip_state fip_mode)\r\n{\r\nstruct fcoe_ctlr_device *ctlr_dev;\r\nstruct fcoe_ctlr *ctlr;\r\nstruct fcoe_interface *fcoe;\r\nint size;\r\nint err;\r\nif (!try_module_get(THIS_MODULE)) {\r\nFCOE_NETDEV_DBG(netdev,\r\n"Could not get a reference to the module\n");\r\nfcoe = ERR_PTR(-EBUSY);\r\ngoto out;\r\n}\r\nsize = sizeof(struct fcoe_ctlr) + sizeof(struct fcoe_interface);\r\nctlr_dev = fcoe_ctlr_device_add(&netdev->dev, &fcoe_sysfs_templ,\r\nsize);\r\nif (!ctlr_dev) {\r\nFCOE_DBG("Failed to add fcoe_ctlr_device\n");\r\nfcoe = ERR_PTR(-ENOMEM);\r\ngoto out_putmod;\r\n}\r\nctlr = fcoe_ctlr_device_priv(ctlr_dev);\r\nctlr->cdev = ctlr_dev;\r\nfcoe = fcoe_ctlr_priv(ctlr);\r\ndev_hold(netdev);\r\nfcoe_ctlr_init(ctlr, fip_mode);\r\nctlr->send = fcoe_fip_send;\r\nctlr->update_mac = fcoe_update_src_mac;\r\nctlr->get_src_addr = fcoe_get_src_mac;\r\nerr = fcoe_interface_setup(fcoe, netdev);\r\nif (err) {\r\nfcoe_ctlr_destroy(ctlr);\r\nfcoe_ctlr_device_delete(ctlr_dev);\r\ndev_put(netdev);\r\nfcoe = ERR_PTR(err);\r\ngoto out_putmod;\r\n}\r\ngoto out;\r\nout_putmod:\r\nmodule_put(THIS_MODULE);\r\nout:\r\nreturn fcoe;\r\n}\r\nstatic void fcoe_interface_remove(struct fcoe_interface *fcoe)\r\n{\r\nstruct net_device *netdev = fcoe->netdev;\r\nstruct fcoe_ctlr *fip = fcoe_to_ctlr(fcoe);\r\nu8 flogi_maddr[ETH_ALEN];\r\nconst struct net_device_ops *ops;\r\n__dev_remove_pack(&fcoe->fcoe_packet_type);\r\n__dev_remove_pack(&fcoe->fip_packet_type);\r\nif (netdev != fcoe->realdev)\r\n__dev_remove_pack(&fcoe->fip_vlan_packet_type);\r\nsynchronize_net();\r\nmemcpy(flogi_maddr, (u8[6]) FC_FCOE_FLOGI_MAC, ETH_ALEN);\r\ndev_uc_del(netdev, flogi_maddr);\r\nif (fip->spma)\r\ndev_uc_del(netdev, fip->ctl_src_addr);\r\nif (fip->mode == FIP_MODE_VN2VN) {\r\ndev_mc_del(netdev, FIP_ALL_VN2VN_MACS);\r\ndev_mc_del(netdev, FIP_ALL_P2P_MACS);\r\n} else\r\ndev_mc_del(netdev, FIP_ALL_ENODE_MACS);\r\nops = netdev->netdev_ops;\r\nif (ops->ndo_fcoe_disable) {\r\nif (ops->ndo_fcoe_disable(netdev))\r\nFCOE_NETDEV_DBG(netdev, "Failed to disable FCoE"\r\n" specific feature for LLD.\n");\r\n}\r\nfcoe->removed = 1;\r\n}\r\nstatic void fcoe_interface_cleanup(struct fcoe_interface *fcoe)\r\n{\r\nstruct net_device *netdev = fcoe->netdev;\r\nstruct fcoe_ctlr *fip = fcoe_to_ctlr(fcoe);\r\nrtnl_lock();\r\nif (!fcoe->removed)\r\nfcoe_interface_remove(fcoe);\r\nrtnl_unlock();\r\nfcoe_ctlr_destroy(fip);\r\nscsi_host_put(fip->lp->host);\r\ndev_put(netdev);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int fcoe_fip_recv(struct sk_buff *skb, struct net_device *netdev,\r\nstruct packet_type *ptype,\r\nstruct net_device *orig_dev)\r\n{\r\nstruct fcoe_interface *fcoe;\r\nstruct fcoe_ctlr *ctlr;\r\nfcoe = container_of(ptype, struct fcoe_interface, fip_packet_type);\r\nctlr = fcoe_to_ctlr(fcoe);\r\nfcoe_ctlr_recv(ctlr, skb);\r\nreturn 0;\r\n}\r\nstatic int fcoe_fip_vlan_recv(struct sk_buff *skb, struct net_device *netdev,\r\nstruct packet_type *ptype,\r\nstruct net_device *orig_dev)\r\n{\r\nstruct fcoe_interface *fcoe;\r\nstruct fcoe_ctlr *ctlr;\r\nfcoe = container_of(ptype, struct fcoe_interface, fip_vlan_packet_type);\r\nctlr = fcoe_to_ctlr(fcoe);\r\nfcoe_ctlr_recv(ctlr, skb);\r\nreturn 0;\r\n}\r\nstatic void fcoe_port_send(struct fcoe_port *port, struct sk_buff *skb)\r\n{\r\nif (port->fcoe_pending_queue.qlen)\r\nfcoe_check_wait_queue(port->lport, skb);\r\nelse if (fcoe_start_io(skb))\r\nfcoe_check_wait_queue(port->lport, skb);\r\n}\r\nstatic void fcoe_fip_send(struct fcoe_ctlr *fip, struct sk_buff *skb)\r\n{\r\nstruct fcoe_interface *fcoe = fcoe_from_ctlr(fip);\r\nstruct fip_frame {\r\nstruct ethhdr eth;\r\nstruct fip_header fip;\r\n} __packed *frame;\r\nframe = (struct fip_frame *)skb->data;\r\nif (ntohs(frame->eth.h_proto) == ETH_P_FIP &&\r\nntohs(frame->fip.fip_op) == FIP_OP_VLAN &&\r\nfcoe->realdev != fcoe->netdev)\r\nskb->dev = fcoe->realdev;\r\nelse\r\nskb->dev = fcoe->netdev;\r\nfcoe_port_send(lport_priv(fip->lp), skb);\r\n}\r\nstatic void fcoe_update_src_mac(struct fc_lport *lport, u8 *addr)\r\n{\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct fcoe_interface *fcoe = port->priv;\r\nif (!is_zero_ether_addr(port->data_src_addr))\r\ndev_uc_del(fcoe->netdev, port->data_src_addr);\r\nif (!is_zero_ether_addr(addr))\r\ndev_uc_add(fcoe->netdev, addr);\r\nmemcpy(port->data_src_addr, addr, ETH_ALEN);\r\n}\r\nstatic u8 *fcoe_get_src_mac(struct fc_lport *lport)\r\n{\r\nstruct fcoe_port *port = lport_priv(lport);\r\nreturn port->data_src_addr;\r\n}\r\nstatic int fcoe_lport_config(struct fc_lport *lport)\r\n{\r\nlport->link_up = 0;\r\nlport->qfull = 0;\r\nlport->max_retry_count = 3;\r\nlport->max_rport_retry_count = 3;\r\nlport->e_d_tov = fcoe_e_d_tov;\r\nlport->r_a_tov = fcoe_r_a_tov;\r\nlport->service_params = (FCP_SPPF_INIT_FCN | FCP_SPPF_RD_XRDY_DIS |\r\nFCP_SPPF_RETRY | FCP_SPPF_CONF_COMPL);\r\nlport->does_npiv = 1;\r\nfc_lport_init_stats(lport);\r\nfc_lport_config(lport);\r\nlport->crc_offload = 0;\r\nlport->seq_offload = 0;\r\nlport->lro_enabled = 0;\r\nlport->lro_xid = 0;\r\nlport->lso_max = 0;\r\nreturn 0;\r\n}\r\nstatic void fcoe_netdev_features_change(struct fc_lport *lport,\r\nstruct net_device *netdev)\r\n{\r\nmutex_lock(&lport->lp_mutex);\r\nif (netdev->features & NETIF_F_SG)\r\nlport->sg_supp = 1;\r\nelse\r\nlport->sg_supp = 0;\r\nif (netdev->features & NETIF_F_FCOE_CRC) {\r\nlport->crc_offload = 1;\r\nFCOE_NETDEV_DBG(netdev, "Supports FCCRC offload\n");\r\n} else {\r\nlport->crc_offload = 0;\r\n}\r\nif (netdev->features & NETIF_F_FSO) {\r\nlport->seq_offload = 1;\r\nlport->lso_max = netdev->gso_max_size;\r\nFCOE_NETDEV_DBG(netdev, "Supports LSO for max len 0x%x\n",\r\nlport->lso_max);\r\n} else {\r\nlport->seq_offload = 0;\r\nlport->lso_max = 0;\r\n}\r\nif (netdev->fcoe_ddp_xid) {\r\nlport->lro_enabled = 1;\r\nlport->lro_xid = netdev->fcoe_ddp_xid;\r\nFCOE_NETDEV_DBG(netdev, "Supports LRO for max xid 0x%x\n",\r\nlport->lro_xid);\r\n} else {\r\nlport->lro_enabled = 0;\r\nlport->lro_xid = 0;\r\n}\r\nmutex_unlock(&lport->lp_mutex);\r\n}\r\nstatic int fcoe_netdev_config(struct fc_lport *lport, struct net_device *netdev)\r\n{\r\nu32 mfs;\r\nu64 wwnn, wwpn;\r\nstruct fcoe_interface *fcoe;\r\nstruct fcoe_ctlr *ctlr;\r\nstruct fcoe_port *port;\r\nport = lport_priv(lport);\r\nfcoe = port->priv;\r\nctlr = fcoe_to_ctlr(fcoe);\r\nif (is_vlan_dev(netdev))\r\nlport->vlan = vlan_dev_vlan_id(netdev);\r\nelse\r\nlport->vlan = 0;\r\nmfs = netdev->mtu;\r\nif (netdev->features & NETIF_F_FCOE_MTU) {\r\nmfs = FCOE_MTU;\r\nFCOE_NETDEV_DBG(netdev, "Supports FCOE_MTU of %d bytes\n", mfs);\r\n}\r\nmfs -= (sizeof(struct fcoe_hdr) + sizeof(struct fcoe_crc_eof));\r\nif (fc_set_mfs(lport, mfs))\r\nreturn -EINVAL;\r\nfcoe_netdev_features_change(lport, netdev);\r\nskb_queue_head_init(&port->fcoe_pending_queue);\r\nport->fcoe_pending_queue_active = 0;\r\nsetup_timer(&port->timer, fcoe_queue_timer, (unsigned long)lport);\r\nfcoe_link_speed_update(lport);\r\nif (!lport->vport) {\r\nif (fcoe_get_wwn(netdev, &wwnn, NETDEV_FCOE_WWNN))\r\nwwnn = fcoe_wwn_from_mac(ctlr->ctl_src_addr, 1, 0);\r\nfc_set_wwnn(lport, wwnn);\r\nif (fcoe_get_wwn(netdev, &wwpn, NETDEV_FCOE_WWPN))\r\nwwpn = fcoe_wwn_from_mac(ctlr->ctl_src_addr,\r\n2, 0);\r\nfc_set_wwpn(lport, wwpn);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fcoe_shost_config(struct fc_lport *lport, struct device *dev)\r\n{\r\nint rc = 0;\r\nlport->host->max_lun = FCOE_MAX_LUN;\r\nlport->host->max_id = FCOE_MAX_FCP_TARGET;\r\nlport->host->max_channel = 0;\r\nlport->host->max_cmd_len = FCOE_MAX_CMD_LEN;\r\nif (lport->vport)\r\nlport->host->transportt = fcoe_vport_scsi_transport;\r\nelse\r\nlport->host->transportt = fcoe_nport_scsi_transport;\r\nrc = scsi_add_host(lport->host, dev);\r\nif (rc) {\r\nFCOE_NETDEV_DBG(fcoe_netdev(lport), "fcoe_shost_config: "\r\n"error on scsi_add_host\n");\r\nreturn rc;\r\n}\r\nif (!lport->vport)\r\nfc_host_max_npiv_vports(lport->host) = USHRT_MAX;\r\nsnprintf(fc_host_symbolic_name(lport->host), FC_SYMBOLIC_NAME_SIZE,\r\n"%s v%s over %s", FCOE_NAME, FCOE_VERSION,\r\nfcoe_netdev(lport)->name);\r\nreturn 0;\r\n}\r\nstatic void fcoe_fdmi_info(struct fc_lport *lport, struct net_device *netdev)\r\n{\r\nstruct fcoe_interface *fcoe;\r\nstruct fcoe_port *port;\r\nstruct net_device *realdev;\r\nint rc;\r\nport = lport_priv(lport);\r\nfcoe = port->priv;\r\nrealdev = fcoe->realdev;\r\nif (lport->vport)\r\nreturn;\r\nif (realdev->netdev_ops->ndo_fcoe_get_hbainfo) {\r\nstruct netdev_fcoe_hbainfo *fdmi;\r\nfdmi = kzalloc(sizeof(*fdmi), GFP_KERNEL);\r\nif (!fdmi)\r\nreturn;\r\nrc = realdev->netdev_ops->ndo_fcoe_get_hbainfo(realdev,\r\nfdmi);\r\nif (rc) {\r\nprintk(KERN_INFO "fcoe: Failed to retrieve FDMI "\r\n"information from netdev.\n");\r\nreturn;\r\n}\r\nsnprintf(fc_host_serial_number(lport->host),\r\nFC_SERIAL_NUMBER_SIZE,\r\n"%s",\r\nfdmi->serial_number);\r\nsnprintf(fc_host_manufacturer(lport->host),\r\nFC_SERIAL_NUMBER_SIZE,\r\n"%s",\r\nfdmi->manufacturer);\r\nsnprintf(fc_host_model(lport->host),\r\nFC_SYMBOLIC_NAME_SIZE,\r\n"%s",\r\nfdmi->model);\r\nsnprintf(fc_host_model_description(lport->host),\r\nFC_SYMBOLIC_NAME_SIZE,\r\n"%s",\r\nfdmi->model_description);\r\nsnprintf(fc_host_hardware_version(lport->host),\r\nFC_VERSION_STRING_SIZE,\r\n"%s",\r\nfdmi->hardware_version);\r\nsnprintf(fc_host_driver_version(lport->host),\r\nFC_VERSION_STRING_SIZE,\r\n"%s",\r\nfdmi->driver_version);\r\nsnprintf(fc_host_optionrom_version(lport->host),\r\nFC_VERSION_STRING_SIZE,\r\n"%s",\r\nfdmi->optionrom_version);\r\nsnprintf(fc_host_firmware_version(lport->host),\r\nFC_VERSION_STRING_SIZE,\r\n"%s",\r\nfdmi->firmware_version);\r\nlport->fdmi_enabled = 1;\r\nkfree(fdmi);\r\n} else {\r\nlport->fdmi_enabled = 0;\r\nprintk(KERN_INFO "fcoe: No FDMI support.\n");\r\n}\r\n}\r\nstatic bool fcoe_oem_match(struct fc_frame *fp)\r\n{\r\nstruct fc_frame_header *fh = fc_frame_header_get(fp);\r\nstruct fcp_cmnd *fcp;\r\nif (fc_fcp_is_read(fr_fsp(fp)) &&\r\n(fr_fsp(fp)->data_len > fcoe_ddp_min))\r\nreturn true;\r\nelse if ((fr_fsp(fp) == NULL) &&\r\n(fh->fh_r_ctl == FC_RCTL_DD_UNSOL_CMD) &&\r\n(ntohs(fh->fh_rx_id) == FC_XID_UNKNOWN)) {\r\nfcp = fc_frame_payload_get(fp, sizeof(*fcp));\r\nif ((fcp->fc_flags & FCP_CFL_WRDATA) &&\r\n(ntohl(fcp->fc_dl) > fcoe_ddp_min))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic inline int fcoe_em_config(struct fc_lport *lport)\r\n{\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct fcoe_interface *fcoe = port->priv;\r\nstruct fcoe_interface *oldfcoe = NULL;\r\nstruct net_device *old_real_dev, *cur_real_dev;\r\nu16 min_xid = FCOE_MIN_XID;\r\nu16 max_xid = FCOE_MAX_XID;\r\nif (!lport->lro_enabled || !lport->lro_xid ||\r\n(lport->lro_xid >= max_xid)) {\r\nlport->lro_xid = 0;\r\ngoto skip_oem;\r\n}\r\nif (is_vlan_dev(fcoe->netdev))\r\ncur_real_dev = vlan_dev_real_dev(fcoe->netdev);\r\nelse\r\ncur_real_dev = fcoe->netdev;\r\nlist_for_each_entry(oldfcoe, &fcoe_hostlist, list) {\r\nif (is_vlan_dev(oldfcoe->netdev))\r\nold_real_dev = vlan_dev_real_dev(oldfcoe->netdev);\r\nelse\r\nold_real_dev = oldfcoe->netdev;\r\nif (cur_real_dev == old_real_dev) {\r\nfcoe->oem = oldfcoe->oem;\r\nbreak;\r\n}\r\n}\r\nif (fcoe->oem) {\r\nif (!fc_exch_mgr_add(lport, fcoe->oem, fcoe_oem_match)) {\r\nprintk(KERN_ERR "fcoe_em_config: failed to add "\r\n"offload em:%p on interface:%s\n",\r\nfcoe->oem, fcoe->netdev->name);\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\nfcoe->oem = fc_exch_mgr_alloc(lport, FC_CLASS_3,\r\nFCOE_MIN_XID, lport->lro_xid,\r\nfcoe_oem_match);\r\nif (!fcoe->oem) {\r\nprintk(KERN_ERR "fcoe_em_config: failed to allocate "\r\n"em for offload exches on interface:%s\n",\r\nfcoe->netdev->name);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmin_xid += lport->lro_xid + 1;\r\nskip_oem:\r\nif (!fc_exch_mgr_alloc(lport, FC_CLASS_3, min_xid, max_xid, NULL)) {\r\nprintk(KERN_ERR "fcoe_em_config: failed to "\r\n"allocate em on interface %s\n", fcoe->netdev->name);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fcoe_if_destroy(struct fc_lport *lport)\r\n{\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct fcoe_interface *fcoe = port->priv;\r\nstruct net_device *netdev = fcoe->netdev;\r\nFCOE_NETDEV_DBG(netdev, "Destroying interface\n");\r\nfc_fabric_logoff(lport);\r\nfc_lport_destroy(lport);\r\ndel_timer_sync(&port->timer);\r\nfcoe_clean_pending_queue(lport);\r\nrtnl_lock();\r\nif (!is_zero_ether_addr(port->data_src_addr))\r\ndev_uc_del(netdev, port->data_src_addr);\r\nif (lport->vport)\r\nsynchronize_net();\r\nelse\r\nfcoe_interface_remove(fcoe);\r\nrtnl_unlock();\r\nfcoe_percpu_clean(lport);\r\nfc_remove_host(lport->host);\r\nscsi_remove_host(lport->host);\r\nfc_fcp_destroy(lport);\r\nfc_exch_mgr_free(lport);\r\nfc_lport_free_stats(lport);\r\nif (lport->vport)\r\nscsi_host_put(lport->host);\r\n}\r\nstatic int fcoe_ddp_setup(struct fc_lport *lport, u16 xid,\r\nstruct scatterlist *sgl, unsigned int sgc)\r\n{\r\nstruct net_device *netdev = fcoe_netdev(lport);\r\nif (netdev->netdev_ops->ndo_fcoe_ddp_setup)\r\nreturn netdev->netdev_ops->ndo_fcoe_ddp_setup(netdev,\r\nxid, sgl,\r\nsgc);\r\nreturn 0;\r\n}\r\nstatic int fcoe_ddp_target(struct fc_lport *lport, u16 xid,\r\nstruct scatterlist *sgl, unsigned int sgc)\r\n{\r\nstruct net_device *netdev = fcoe_netdev(lport);\r\nif (netdev->netdev_ops->ndo_fcoe_ddp_target)\r\nreturn netdev->netdev_ops->ndo_fcoe_ddp_target(netdev, xid,\r\nsgl, sgc);\r\nreturn 0;\r\n}\r\nstatic int fcoe_ddp_done(struct fc_lport *lport, u16 xid)\r\n{\r\nstruct net_device *netdev = fcoe_netdev(lport);\r\nif (netdev->netdev_ops->ndo_fcoe_ddp_done)\r\nreturn netdev->netdev_ops->ndo_fcoe_ddp_done(netdev, xid);\r\nreturn 0;\r\n}\r\nstatic struct fc_lport *fcoe_if_create(struct fcoe_interface *fcoe,\r\nstruct device *parent, int npiv)\r\n{\r\nstruct fcoe_ctlr *ctlr = fcoe_to_ctlr(fcoe);\r\nstruct net_device *netdev = fcoe->netdev;\r\nstruct fc_lport *lport, *n_port;\r\nstruct fcoe_port *port;\r\nstruct Scsi_Host *shost;\r\nint rc;\r\nstruct fc_vport *vport = dev_to_vport(parent);\r\nFCOE_NETDEV_DBG(netdev, "Create Interface\n");\r\nif (!npiv)\r\nlport = libfc_host_alloc(&fcoe_shost_template, sizeof(*port));\r\nelse\r\nlport = libfc_vport_create(vport, sizeof(*port));\r\nif (!lport) {\r\nFCOE_NETDEV_DBG(netdev, "Could not allocate host structure\n");\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nport = lport_priv(lport);\r\nport->lport = lport;\r\nport->priv = fcoe;\r\nport->get_netdev = fcoe_netdev;\r\nport->max_queue_depth = FCOE_MAX_QUEUE_DEPTH;\r\nport->min_queue_depth = FCOE_MIN_QUEUE_DEPTH;\r\nINIT_WORK(&port->destroy_work, fcoe_destroy_work);\r\nfcoe_hostlist_add(lport);\r\nrc = fcoe_lport_config(lport);\r\nif (rc) {\r\nFCOE_NETDEV_DBG(netdev, "Could not configure lport for the "\r\n"interface\n");\r\ngoto out_host_put;\r\n}\r\nif (npiv) {\r\nFCOE_NETDEV_DBG(netdev, "Setting vport names, "\r\n"%16.16llx %16.16llx\n",\r\nvport->node_name, vport->port_name);\r\nfc_set_wwnn(lport, vport->node_name);\r\nfc_set_wwpn(lport, vport->port_name);\r\n}\r\nrc = fcoe_netdev_config(lport, netdev);\r\nif (rc) {\r\nFCOE_NETDEV_DBG(netdev, "Could not configure netdev for the "\r\n"interface\n");\r\ngoto out_lp_destroy;\r\n}\r\nrc = fcoe_shost_config(lport, parent);\r\nif (rc) {\r\nFCOE_NETDEV_DBG(netdev, "Could not configure shost for the "\r\n"interface\n");\r\ngoto out_lp_destroy;\r\n}\r\nrc = fcoe_libfc_config(lport, ctlr, &fcoe_libfc_fcn_templ, 1);\r\nif (rc) {\r\nFCOE_NETDEV_DBG(netdev, "Could not configure libfc for the "\r\n"interface\n");\r\ngoto out_lp_destroy;\r\n}\r\nfcoe_fdmi_info(lport, netdev);\r\nif (!npiv)\r\nrc = fcoe_em_config(lport);\r\nelse {\r\nshost = vport_to_shost(vport);\r\nn_port = shost_priv(shost);\r\nrc = fc_exch_mgr_list_clone(n_port, lport);\r\n}\r\nif (rc) {\r\nFCOE_NETDEV_DBG(netdev, "Could not configure the EM\n");\r\ngoto out_lp_destroy;\r\n}\r\nreturn lport;\r\nout_lp_destroy:\r\nfc_exch_mgr_free(lport);\r\nout_host_put:\r\nfcoe_hostlist_del(lport);\r\nscsi_host_put(lport->host);\r\nout:\r\nreturn ERR_PTR(rc);\r\n}\r\nstatic int __init fcoe_if_init(void)\r\n{\r\nfcoe_nport_scsi_transport =\r\nfc_attach_transport(&fcoe_nport_fc_functions);\r\nfcoe_vport_scsi_transport =\r\nfc_attach_transport(&fcoe_vport_fc_functions);\r\nif (!fcoe_nport_scsi_transport) {\r\nprintk(KERN_ERR "fcoe: Failed to attach to the FC transport\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __exit fcoe_if_exit(void)\r\n{\r\nfc_release_transport(fcoe_nport_scsi_transport);\r\nfc_release_transport(fcoe_vport_scsi_transport);\r\nfcoe_nport_scsi_transport = NULL;\r\nfcoe_vport_scsi_transport = NULL;\r\nreturn 0;\r\n}\r\nstatic void fcoe_thread_cleanup_local(unsigned int cpu)\r\n{\r\nstruct page *crc_eof;\r\nstruct fcoe_percpu_s *p;\r\np = per_cpu_ptr(&fcoe_percpu, cpu);\r\nspin_lock_bh(&p->fcoe_rx_list.lock);\r\ncrc_eof = p->crc_eof_page;\r\np->crc_eof_page = NULL;\r\np->crc_eof_offset = 0;\r\nspin_unlock_bh(&p->fcoe_rx_list.lock);\r\nif (crc_eof)\r\nput_page(crc_eof);\r\nflush_work(&p->work);\r\n}\r\nstatic inline unsigned int fcoe_select_cpu(void)\r\n{\r\nstatic unsigned int selected_cpu;\r\nselected_cpu = cpumask_next(selected_cpu, cpu_online_mask);\r\nif (selected_cpu >= nr_cpu_ids)\r\nselected_cpu = cpumask_first(cpu_online_mask);\r\nreturn selected_cpu;\r\n}\r\nstatic int fcoe_rcv(struct sk_buff *skb, struct net_device *netdev,\r\nstruct packet_type *ptype, struct net_device *olddev)\r\n{\r\nstruct fc_lport *lport;\r\nstruct fcoe_rcv_info *fr;\r\nstruct fcoe_ctlr *ctlr;\r\nstruct fcoe_interface *fcoe;\r\nstruct fc_frame_header *fh;\r\nstruct fcoe_percpu_s *fps;\r\nstruct ethhdr *eh;\r\nunsigned int cpu;\r\nfcoe = container_of(ptype, struct fcoe_interface, fcoe_packet_type);\r\nctlr = fcoe_to_ctlr(fcoe);\r\nlport = ctlr->lp;\r\nif (unlikely(!lport)) {\r\nFCOE_NETDEV_DBG(netdev, "Cannot find hba structure\n");\r\ngoto err2;\r\n}\r\nif (!lport->link_up)\r\ngoto err2;\r\nFCOE_NETDEV_DBG(netdev,\r\n"skb_info: len:%d data_len:%d head:%p data:%p tail:%p end:%p sum:%d dev:%s\n",\r\nskb->len, skb->data_len, skb->head, skb->data,\r\nskb_tail_pointer(skb), skb_end_pointer(skb),\r\nskb->csum, skb->dev ? skb->dev->name : "<NULL>");\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn NET_RX_DROP;\r\neh = eth_hdr(skb);\r\nif (is_fip_mode(ctlr) &&\r\n!ether_addr_equal(eh->h_source, ctlr->dest_addr)) {\r\nFCOE_NETDEV_DBG(netdev, "wrong source mac address:%pM\n",\r\neh->h_source);\r\ngoto err;\r\n}\r\nif (unlikely((skb->len < FCOE_MIN_FRAME) ||\r\n!pskb_may_pull(skb, FCOE_HEADER_LEN)))\r\ngoto err;\r\nskb_set_transport_header(skb, sizeof(struct fcoe_hdr));\r\nfh = (struct fc_frame_header *) skb_transport_header(skb);\r\nif (ntoh24(&eh->h_dest[3]) != ntoh24(fh->fh_d_id)) {\r\nFCOE_NETDEV_DBG(netdev, "FC frame d_id mismatch with MAC:%pM\n",\r\neh->h_dest);\r\ngoto err;\r\n}\r\nfr = fcoe_dev_from_skb(skb);\r\nfr->fr_dev = lport;\r\nif (ntoh24(fh->fh_f_ctl) & FC_FC_EX_CTX)\r\ncpu = ntohs(fh->fh_ox_id) & fc_cpu_mask;\r\nelse {\r\nif (ntohs(fh->fh_rx_id) == FC_XID_UNKNOWN)\r\ncpu = fcoe_select_cpu();\r\nelse\r\ncpu = ntohs(fh->fh_rx_id) & fc_cpu_mask;\r\n}\r\nif (cpu >= nr_cpu_ids)\r\ngoto err;\r\nfps = &per_cpu(fcoe_percpu, cpu);\r\nspin_lock(&fps->fcoe_rx_list.lock);\r\n__skb_queue_tail(&fps->fcoe_rx_list, skb);\r\nschedule_work_on(cpu, &fps->work);\r\nspin_unlock(&fps->fcoe_rx_list.lock);\r\nreturn NET_RX_SUCCESS;\r\nerr:\r\nper_cpu_ptr(lport->stats, get_cpu())->ErrorFrames++;\r\nput_cpu();\r\nerr2:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int fcoe_alloc_paged_crc_eof(struct sk_buff *skb, int tlen)\r\n{\r\nstruct fcoe_percpu_s *fps;\r\nint rc;\r\nfps = &get_cpu_var(fcoe_percpu);\r\nrc = fcoe_get_paged_crc_eof(skb, tlen, fps);\r\nput_cpu_var(fcoe_percpu);\r\nreturn rc;\r\n}\r\nstatic int fcoe_xmit(struct fc_lport *lport, struct fc_frame *fp)\r\n{\r\nint wlen;\r\nu32 crc;\r\nstruct ethhdr *eh;\r\nstruct fcoe_crc_eof *cp;\r\nstruct sk_buff *skb;\r\nstruct fc_stats *stats;\r\nstruct fc_frame_header *fh;\r\nunsigned int hlen;\r\nunsigned int tlen;\r\nunsigned int elen;\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct fcoe_interface *fcoe = port->priv;\r\nstruct fcoe_ctlr *ctlr = fcoe_to_ctlr(fcoe);\r\nu8 sof, eof;\r\nstruct fcoe_hdr *hp;\r\nWARN_ON((fr_len(fp) % sizeof(u32)) != 0);\r\nfh = fc_frame_header_get(fp);\r\nskb = fp_skb(fp);\r\nwlen = skb->len / FCOE_WORD_TO_BYTE;\r\nif (!lport->link_up) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nif (unlikely(fh->fh_type == FC_TYPE_ELS) &&\r\nfcoe_ctlr_els_send(ctlr, lport, skb))\r\nreturn 0;\r\nsof = fr_sof(fp);\r\neof = fr_eof(fp);\r\nelen = sizeof(struct ethhdr);\r\nhlen = sizeof(struct fcoe_hdr);\r\ntlen = sizeof(struct fcoe_crc_eof);\r\nwlen = (skb->len - tlen + sizeof(crc)) / FCOE_WORD_TO_BYTE;\r\nif (likely(lport->crc_offload)) {\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nskb->csum_start = skb_headroom(skb);\r\nskb->csum_offset = skb->len;\r\ncrc = 0;\r\n} else {\r\nskb->ip_summed = CHECKSUM_NONE;\r\ncrc = fcoe_fc_crc(fp);\r\n}\r\nif (skb_is_nonlinear(skb)) {\r\nskb_frag_t *frag;\r\nif (fcoe_alloc_paged_crc_eof(skb, tlen)) {\r\nkfree_skb(skb);\r\nreturn -ENOMEM;\r\n}\r\nfrag = &skb_shinfo(skb)->frags[skb_shinfo(skb)->nr_frags - 1];\r\ncp = kmap_atomic(skb_frag_page(frag))\r\n+ frag->page_offset;\r\n} else {\r\ncp = skb_put(skb, tlen);\r\n}\r\nmemset(cp, 0, sizeof(*cp));\r\ncp->fcoe_eof = eof;\r\ncp->fcoe_crc32 = cpu_to_le32(~crc);\r\nif (skb_is_nonlinear(skb)) {\r\nkunmap_atomic(cp);\r\ncp = NULL;\r\n}\r\nskb_push(skb, elen + hlen);\r\nskb_reset_mac_header(skb);\r\nskb_reset_network_header(skb);\r\nskb->mac_len = elen;\r\nskb->protocol = htons(ETH_P_FCOE);\r\nskb->priority = fcoe->priority;\r\nif (is_vlan_dev(fcoe->netdev) &&\r\nfcoe->realdev->features & NETIF_F_HW_VLAN_CTAG_TX) {\r\nskb->dev = fcoe->realdev;\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\r\nvlan_dev_vlan_id(fcoe->netdev));\r\n} else\r\nskb->dev = fcoe->netdev;\r\neh = eth_hdr(skb);\r\neh->h_proto = htons(ETH_P_FCOE);\r\nmemcpy(eh->h_dest, ctlr->dest_addr, ETH_ALEN);\r\nif (ctlr->map_dest)\r\nmemcpy(eh->h_dest + 3, fh->fh_d_id, 3);\r\nif (unlikely(ctlr->flogi_oxid != FC_XID_UNKNOWN))\r\nmemcpy(eh->h_source, ctlr->ctl_src_addr, ETH_ALEN);\r\nelse\r\nmemcpy(eh->h_source, port->data_src_addr, ETH_ALEN);\r\nhp = (struct fcoe_hdr *)(eh + 1);\r\nmemset(hp, 0, sizeof(*hp));\r\nif (FC_FCOE_VER)\r\nFC_FCOE_ENCAPS_VER(hp, FC_FCOE_VER);\r\nhp->fcoe_sof = sof;\r\nif (lport->seq_offload && fr_max_payload(fp)) {\r\nskb_shinfo(skb)->gso_type = SKB_GSO_FCOE;\r\nskb_shinfo(skb)->gso_size = fr_max_payload(fp);\r\n} else {\r\nskb_shinfo(skb)->gso_type = 0;\r\nskb_shinfo(skb)->gso_size = 0;\r\n}\r\nstats = per_cpu_ptr(lport->stats, get_cpu());\r\nstats->TxFrames++;\r\nstats->TxWords += wlen;\r\nput_cpu();\r\nfr_dev(fp) = lport;\r\nfcoe_port_send(port, skb);\r\nreturn 0;\r\n}\r\nstatic inline int fcoe_filter_frames(struct fc_lport *lport,\r\nstruct fc_frame *fp)\r\n{\r\nstruct fcoe_ctlr *ctlr;\r\nstruct fcoe_interface *fcoe;\r\nstruct fc_frame_header *fh;\r\nstruct sk_buff *skb = (struct sk_buff *)fp;\r\nstruct fc_stats *stats;\r\nif (lport->crc_offload && skb->ip_summed == CHECKSUM_UNNECESSARY)\r\nfr_flags(fp) &= ~FCPHF_CRC_UNCHECKED;\r\nelse\r\nfr_flags(fp) |= FCPHF_CRC_UNCHECKED;\r\nfh = (struct fc_frame_header *) skb_transport_header(skb);\r\nfh = fc_frame_header_get(fp);\r\nif (fh->fh_r_ctl == FC_RCTL_DD_SOL_DATA && fh->fh_type == FC_TYPE_FCP)\r\nreturn 0;\r\nfcoe = ((struct fcoe_port *)lport_priv(lport))->priv;\r\nctlr = fcoe_to_ctlr(fcoe);\r\nif (is_fip_mode(ctlr) && fc_frame_payload_op(fp) == ELS_LOGO &&\r\nntoh24(fh->fh_s_id) == FC_FID_FLOGI) {\r\nFCOE_DBG("fcoe: dropping FCoE lport LOGO in fip mode\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(fr_flags(fp) & FCPHF_CRC_UNCHECKED) ||\r\nle32_to_cpu(fr_crc(fp)) == ~crc32(~0, skb->data, skb->len)) {\r\nfr_flags(fp) &= ~FCPHF_CRC_UNCHECKED;\r\nreturn 0;\r\n}\r\nstats = per_cpu_ptr(lport->stats, get_cpu());\r\nstats->InvalidCRCCount++;\r\nif (stats->InvalidCRCCount < 5)\r\nprintk(KERN_WARNING "fcoe: dropping frame with CRC error\n");\r\nput_cpu();\r\nreturn -EINVAL;\r\n}\r\nstatic void fcoe_recv_frame(struct sk_buff *skb)\r\n{\r\nu32 fr_len;\r\nstruct fc_lport *lport;\r\nstruct fcoe_rcv_info *fr;\r\nstruct fc_stats *stats;\r\nstruct fcoe_crc_eof crc_eof;\r\nstruct fc_frame *fp;\r\nstruct fcoe_port *port;\r\nstruct fcoe_hdr *hp;\r\nfr = fcoe_dev_from_skb(skb);\r\nlport = fr->fr_dev;\r\nif (unlikely(!lport)) {\r\nFCOE_NETDEV_DBG(skb->dev, "NULL lport in skb\n");\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nFCOE_NETDEV_DBG(skb->dev,\r\n"skb_info: len:%d data_len:%d head:%p data:%p tail:%p end:%p sum:%d dev:%s\n",\r\nskb->len, skb->data_len,\r\nskb->head, skb->data, skb_tail_pointer(skb),\r\nskb_end_pointer(skb), skb->csum,\r\nskb->dev ? skb->dev->name : "<NULL>");\r\nport = lport_priv(lport);\r\nskb_linearize(skb);\r\nhp = (struct fcoe_hdr *) skb_network_header(skb);\r\nstats = per_cpu_ptr(lport->stats, get_cpu());\r\nif (unlikely(FC_FCOE_DECAPS_VER(hp) != FC_FCOE_VER)) {\r\nif (stats->ErrorFrames < 5)\r\nprintk(KERN_WARNING "fcoe: FCoE version "\r\n"mismatch: The frame has "\r\n"version %x, but the "\r\n"initiator supports version "\r\n"%x\n", FC_FCOE_DECAPS_VER(hp),\r\nFC_FCOE_VER);\r\ngoto drop;\r\n}\r\nskb_pull(skb, sizeof(struct fcoe_hdr));\r\nfr_len = skb->len - sizeof(struct fcoe_crc_eof);\r\nstats->RxFrames++;\r\nstats->RxWords += fr_len / FCOE_WORD_TO_BYTE;\r\nfp = (struct fc_frame *)skb;\r\nfc_frame_init(fp);\r\nfr_dev(fp) = lport;\r\nfr_sof(fp) = hp->fcoe_sof;\r\nif (skb_copy_bits(skb, fr_len, &crc_eof, sizeof(crc_eof)))\r\ngoto drop;\r\nfr_eof(fp) = crc_eof.fcoe_eof;\r\nfr_crc(fp) = crc_eof.fcoe_crc32;\r\nif (pskb_trim(skb, fr_len))\r\ngoto drop;\r\nif (!fcoe_filter_frames(lport, fp)) {\r\nput_cpu();\r\nfc_exch_recv(lport, fp);\r\nreturn;\r\n}\r\ndrop:\r\nstats->ErrorFrames++;\r\nput_cpu();\r\nkfree_skb(skb);\r\n}\r\nstatic void fcoe_receive_work(struct work_struct *work)\r\n{\r\nstruct fcoe_percpu_s *p;\r\nstruct sk_buff *skb;\r\nstruct sk_buff_head tmp;\r\np = container_of(work, struct fcoe_percpu_s, work);\r\nskb_queue_head_init(&tmp);\r\nspin_lock_bh(&p->fcoe_rx_list.lock);\r\nskb_queue_splice_init(&p->fcoe_rx_list, &tmp);\r\nspin_unlock_bh(&p->fcoe_rx_list.lock);\r\nif (!skb_queue_len(&tmp))\r\nreturn;\r\nwhile ((skb = __skb_dequeue(&tmp)))\r\nfcoe_recv_frame(skb);\r\n}\r\nstatic void fcoe_dev_setup(void)\r\n{\r\nregister_dcbevent_notifier(&dcb_notifier);\r\nregister_netdevice_notifier(&fcoe_notifier);\r\n}\r\nstatic void fcoe_dev_cleanup(void)\r\n{\r\nunregister_dcbevent_notifier(&dcb_notifier);\r\nunregister_netdevice_notifier(&fcoe_notifier);\r\n}\r\nstatic struct fcoe_interface *\r\nfcoe_hostlist_lookup_realdev_port(struct net_device *netdev)\r\n{\r\nstruct fcoe_interface *fcoe;\r\nstruct net_device *real_dev;\r\nlist_for_each_entry(fcoe, &fcoe_hostlist, list) {\r\nif (is_vlan_dev(fcoe->netdev))\r\nreal_dev = vlan_dev_real_dev(fcoe->netdev);\r\nelse\r\nreal_dev = fcoe->netdev;\r\nif (netdev == real_dev)\r\nreturn fcoe;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int fcoe_dcb_app_notification(struct notifier_block *notifier,\r\nulong event, void *ptr)\r\n{\r\nstruct dcb_app_type *entry = ptr;\r\nstruct fcoe_ctlr *ctlr;\r\nstruct fcoe_interface *fcoe;\r\nstruct net_device *netdev;\r\nint prio;\r\nif (entry->app.selector != DCB_APP_IDTYPE_ETHTYPE)\r\nreturn NOTIFY_OK;\r\nnetdev = dev_get_by_index(&init_net, entry->ifindex);\r\nif (!netdev)\r\nreturn NOTIFY_OK;\r\nfcoe = fcoe_hostlist_lookup_realdev_port(netdev);\r\ndev_put(netdev);\r\nif (!fcoe)\r\nreturn NOTIFY_OK;\r\nctlr = fcoe_to_ctlr(fcoe);\r\nif (entry->dcbx & DCB_CAP_DCBX_VER_CEE)\r\nprio = ffs(entry->app.priority) - 1;\r\nelse\r\nprio = entry->app.priority;\r\nif (prio < 0)\r\nreturn NOTIFY_OK;\r\nif (entry->app.protocol == ETH_P_FIP ||\r\nentry->app.protocol == ETH_P_FCOE)\r\nctlr->priority = prio;\r\nif (entry->app.protocol == ETH_P_FCOE)\r\nfcoe->priority = prio;\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int fcoe_device_notification(struct notifier_block *notifier,\r\nulong event, void *ptr)\r\n{\r\nstruct fcoe_ctlr_device *cdev;\r\nstruct fc_lport *lport = NULL;\r\nstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\r\nstruct fcoe_ctlr *ctlr;\r\nstruct fcoe_interface *fcoe;\r\nstruct fcoe_port *port;\r\nstruct fc_stats *stats;\r\nu32 link_possible = 1;\r\nu32 mfs;\r\nint rc = NOTIFY_OK;\r\nlist_for_each_entry(fcoe, &fcoe_hostlist, list) {\r\nif (fcoe->netdev == netdev) {\r\nctlr = fcoe_to_ctlr(fcoe);\r\nlport = ctlr->lp;\r\nbreak;\r\n}\r\n}\r\nif (!lport) {\r\nrc = NOTIFY_DONE;\r\ngoto out;\r\n}\r\nswitch (event) {\r\ncase NETDEV_DOWN:\r\ncase NETDEV_GOING_DOWN:\r\nlink_possible = 0;\r\nbreak;\r\ncase NETDEV_UP:\r\ncase NETDEV_CHANGE:\r\nbreak;\r\ncase NETDEV_CHANGEMTU:\r\nif (netdev->features & NETIF_F_FCOE_MTU)\r\nbreak;\r\nmfs = netdev->mtu - (sizeof(struct fcoe_hdr) +\r\nsizeof(struct fcoe_crc_eof));\r\nif (mfs >= FC_MIN_MAX_FRAME)\r\nfc_set_mfs(lport, mfs);\r\nbreak;\r\ncase NETDEV_REGISTER:\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nlist_del(&fcoe->list);\r\nport = lport_priv(ctlr->lp);\r\nqueue_work(fcoe_wq, &port->destroy_work);\r\ngoto out;\r\nbreak;\r\ncase NETDEV_FEAT_CHANGE:\r\nfcoe_netdev_features_change(lport, netdev);\r\nbreak;\r\ndefault:\r\nFCOE_NETDEV_DBG(netdev, "Unknown event %ld "\r\n"from netdev netlink\n", event);\r\n}\r\nfcoe_link_speed_update(lport);\r\ncdev = fcoe_ctlr_to_ctlr_dev(ctlr);\r\nif (link_possible && !fcoe_link_ok(lport)) {\r\nswitch (cdev->enabled) {\r\ncase FCOE_CTLR_DISABLED:\r\npr_info("Link up while interface is disabled.\n");\r\nbreak;\r\ncase FCOE_CTLR_ENABLED:\r\ncase FCOE_CTLR_UNUSED:\r\nfcoe_ctlr_link_up(ctlr);\r\n};\r\n} else if (fcoe_ctlr_link_down(ctlr)) {\r\nswitch (cdev->enabled) {\r\ncase FCOE_CTLR_DISABLED:\r\npr_info("Link down while interface is disabled.\n");\r\nbreak;\r\ncase FCOE_CTLR_ENABLED:\r\ncase FCOE_CTLR_UNUSED:\r\nstats = per_cpu_ptr(lport->stats, get_cpu());\r\nstats->LinkFailureCount++;\r\nput_cpu();\r\nfcoe_clean_pending_queue(lport);\r\n};\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int fcoe_disable(struct net_device *netdev)\r\n{\r\nstruct fcoe_ctlr *ctlr;\r\nstruct fcoe_interface *fcoe;\r\nint rc = 0;\r\nmutex_lock(&fcoe_config_mutex);\r\nrtnl_lock();\r\nfcoe = fcoe_hostlist_lookup_port(netdev);\r\nrtnl_unlock();\r\nif (fcoe) {\r\nctlr = fcoe_to_ctlr(fcoe);\r\nfcoe_ctlr_link_down(ctlr);\r\nfcoe_clean_pending_queue(ctlr->lp);\r\n} else\r\nrc = -ENODEV;\r\nmutex_unlock(&fcoe_config_mutex);\r\nreturn rc;\r\n}\r\nstatic int fcoe_enable(struct net_device *netdev)\r\n{\r\nstruct fcoe_ctlr *ctlr;\r\nstruct fcoe_interface *fcoe;\r\nint rc = 0;\r\nmutex_lock(&fcoe_config_mutex);\r\nrtnl_lock();\r\nfcoe = fcoe_hostlist_lookup_port(netdev);\r\nrtnl_unlock();\r\nif (!fcoe) {\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nctlr = fcoe_to_ctlr(fcoe);\r\nif (!fcoe_link_ok(ctlr->lp))\r\nfcoe_ctlr_link_up(ctlr);\r\nout:\r\nmutex_unlock(&fcoe_config_mutex);\r\nreturn rc;\r\n}\r\nstatic int fcoe_ctlr_enabled(struct fcoe_ctlr_device *cdev)\r\n{\r\nstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(cdev);\r\nstruct fc_lport *lport = ctlr->lp;\r\nstruct net_device *netdev = fcoe_netdev(lport);\r\nswitch (cdev->enabled) {\r\ncase FCOE_CTLR_ENABLED:\r\nreturn fcoe_enable(netdev);\r\ncase FCOE_CTLR_DISABLED:\r\nreturn fcoe_disable(netdev);\r\ncase FCOE_CTLR_UNUSED:\r\ndefault:\r\nreturn -ENOTSUPP;\r\n};\r\n}\r\nstatic void fcoe_ctlr_mode(struct fcoe_ctlr_device *ctlr_dev)\r\n{\r\nstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(ctlr_dev);\r\nstruct fcoe_interface *fcoe = fcoe_ctlr_priv(ctlr);\r\nif (ctlr_dev->mode == FIP_CONN_TYPE_VN2VN &&\r\nctlr->mode != FIP_MODE_VN2VN) {\r\ndev_mc_del(fcoe->netdev, FIP_ALL_ENODE_MACS);\r\ndev_mc_add(fcoe->netdev, FIP_ALL_VN2VN_MACS);\r\ndev_mc_add(fcoe->netdev, FIP_ALL_P2P_MACS);\r\n} else if (ctlr->mode != FIP_MODE_FABRIC) {\r\ndev_mc_del(fcoe->netdev, FIP_ALL_VN2VN_MACS);\r\ndev_mc_del(fcoe->netdev, FIP_ALL_P2P_MACS);\r\ndev_mc_add(fcoe->netdev, FIP_ALL_ENODE_MACS);\r\n}\r\nfcoe_ctlr_set_fip_mode(ctlr_dev);\r\n}\r\nstatic int fcoe_destroy(struct net_device *netdev)\r\n{\r\nstruct fcoe_ctlr *ctlr;\r\nstruct fcoe_interface *fcoe;\r\nstruct fc_lport *lport;\r\nstruct fcoe_port *port;\r\nint rc = 0;\r\nmutex_lock(&fcoe_config_mutex);\r\nrtnl_lock();\r\nfcoe = fcoe_hostlist_lookup_port(netdev);\r\nif (!fcoe) {\r\nrc = -ENODEV;\r\ngoto out_nodev;\r\n}\r\nctlr = fcoe_to_ctlr(fcoe);\r\nlport = ctlr->lp;\r\nport = lport_priv(lport);\r\nlist_del(&fcoe->list);\r\nqueue_work(fcoe_wq, &port->destroy_work);\r\nout_nodev:\r\nrtnl_unlock();\r\nmutex_unlock(&fcoe_config_mutex);\r\nreturn rc;\r\n}\r\nstatic void fcoe_destroy_work(struct work_struct *work)\r\n{\r\nstruct fcoe_ctlr_device *cdev;\r\nstruct fcoe_ctlr *ctlr;\r\nstruct fcoe_port *port;\r\nstruct fcoe_interface *fcoe;\r\nstruct Scsi_Host *shost;\r\nstruct fc_host_attrs *fc_host;\r\nunsigned long flags;\r\nstruct fc_vport *vport;\r\nstruct fc_vport *next_vport;\r\nport = container_of(work, struct fcoe_port, destroy_work);\r\nshost = port->lport->host;\r\nfc_host = shost_to_fc_host(shost);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nlist_for_each_entry_safe(vport, next_vport, &fc_host->vports, peers) {\r\nif (vport->flags & (FC_VPORT_DEL | FC_VPORT_CREATING)) {\r\ncontinue;\r\n} else {\r\nvport->flags |= FC_VPORT_DELETING;\r\nqueue_work(fc_host_work_q(shost),\r\n&vport->vport_delete_work);\r\n}\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nflush_workqueue(fc_host_work_q(shost));\r\nmutex_lock(&fcoe_config_mutex);\r\nfcoe = port->priv;\r\nctlr = fcoe_to_ctlr(fcoe);\r\ncdev = fcoe_ctlr_to_ctlr_dev(ctlr);\r\nfcoe_if_destroy(port->lport);\r\nfcoe_interface_cleanup(fcoe);\r\nmutex_unlock(&fcoe_config_mutex);\r\nfcoe_ctlr_device_delete(cdev);\r\n}\r\nstatic bool fcoe_match(struct net_device *netdev)\r\n{\r\nreturn true;\r\n}\r\nstatic void fcoe_dcb_create(struct fcoe_interface *fcoe)\r\n{\r\nint ctlr_prio = TC_PRIO_BESTEFFORT;\r\nint fcoe_prio = TC_PRIO_INTERACTIVE;\r\nstruct fcoe_ctlr *ctlr = fcoe_to_ctlr(fcoe);\r\n#ifdef CONFIG_DCB\r\nint dcbx;\r\nu8 fup, up;\r\nstruct net_device *netdev = fcoe->realdev;\r\nstruct dcb_app app = {\r\n.priority = 0,\r\n.protocol = ETH_P_FCOE\r\n};\r\nif (netdev && netdev->dcbnl_ops && netdev->dcbnl_ops->getdcbx) {\r\ndcbx = netdev->dcbnl_ops->getdcbx(netdev);\r\nif (dcbx & DCB_CAP_DCBX_VER_IEEE) {\r\napp.selector = IEEE_8021QAZ_APP_SEL_ETHERTYPE;\r\nup = dcb_ieee_getapp_mask(netdev, &app);\r\napp.protocol = ETH_P_FIP;\r\nfup = dcb_ieee_getapp_mask(netdev, &app);\r\n} else {\r\napp.selector = DCB_APP_IDTYPE_ETHTYPE;\r\nup = dcb_getapp(netdev, &app);\r\napp.protocol = ETH_P_FIP;\r\nfup = dcb_getapp(netdev, &app);\r\n}\r\nfcoe_prio = ffs(up) ? ffs(up) - 1 : 0;\r\nctlr_prio = ffs(fup) ? ffs(fup) - 1 : fcoe_prio;\r\n}\r\n#endif\r\nfcoe->priority = fcoe_prio;\r\nctlr->priority = ctlr_prio;\r\n}\r\nstatic int _fcoe_create(struct net_device *netdev, enum fip_mode fip_mode,\r\nenum fcoe_create_link_state link_state)\r\n{\r\nint rc = 0;\r\nstruct fcoe_ctlr_device *ctlr_dev;\r\nstruct fcoe_ctlr *ctlr;\r\nstruct fcoe_interface *fcoe;\r\nstruct fc_lport *lport;\r\nmutex_lock(&fcoe_config_mutex);\r\nrtnl_lock();\r\nif (fcoe_hostlist_lookup(netdev)) {\r\nrc = -EEXIST;\r\ngoto out_nodev;\r\n}\r\nfcoe = fcoe_interface_create(netdev, fip_mode);\r\nif (IS_ERR(fcoe)) {\r\nrc = PTR_ERR(fcoe);\r\ngoto out_nodev;\r\n}\r\nctlr = fcoe_to_ctlr(fcoe);\r\nctlr_dev = fcoe_ctlr_to_ctlr_dev(ctlr);\r\nlport = fcoe_if_create(fcoe, &ctlr_dev->dev, 0);\r\nif (IS_ERR(lport)) {\r\nprintk(KERN_ERR "fcoe: Failed to create interface (%s)\n",\r\nnetdev->name);\r\nrc = -EIO;\r\nrtnl_unlock();\r\nfcoe_interface_cleanup(fcoe);\r\nmutex_unlock(&fcoe_config_mutex);\r\nfcoe_ctlr_device_delete(ctlr_dev);\r\nreturn rc;\r\n}\r\nctlr->lp = lport;\r\nfcoe_dcb_create(fcoe);\r\nlport->boot_time = jiffies;\r\nfc_fabric_login(lport);\r\nif (link_state == FCOE_CREATE_LINK_UP)\r\nctlr_dev->enabled = FCOE_CTLR_ENABLED;\r\nelse\r\nctlr_dev->enabled = FCOE_CTLR_DISABLED;\r\nif (link_state == FCOE_CREATE_LINK_UP &&\r\n!fcoe_link_ok(lport)) {\r\nrtnl_unlock();\r\nfcoe_ctlr_link_up(ctlr);\r\nmutex_unlock(&fcoe_config_mutex);\r\nreturn rc;\r\n}\r\nout_nodev:\r\nrtnl_unlock();\r\nmutex_unlock(&fcoe_config_mutex);\r\nreturn rc;\r\n}\r\nstatic int fcoe_create(struct net_device *netdev, enum fip_mode fip_mode)\r\n{\r\nreturn _fcoe_create(netdev, fip_mode, FCOE_CREATE_LINK_UP);\r\n}\r\nstatic int fcoe_ctlr_alloc(struct net_device *netdev)\r\n{\r\nreturn _fcoe_create(netdev, FIP_MODE_FABRIC,\r\nFCOE_CREATE_LINK_DOWN);\r\n}\r\nstatic int fcoe_link_ok(struct fc_lport *lport)\r\n{\r\nstruct net_device *netdev = fcoe_netdev(lport);\r\nif (netif_oper_up(netdev))\r\nreturn 0;\r\nreturn -1;\r\n}\r\nstatic void fcoe_percpu_clean(struct fc_lport *lport)\r\n{\r\nstruct fcoe_percpu_s *pp;\r\nunsigned int cpu;\r\nfor_each_possible_cpu(cpu) {\r\npp = &per_cpu(fcoe_percpu, cpu);\r\nflush_work(&pp->work);\r\n}\r\n}\r\nstatic int fcoe_reset(struct Scsi_Host *shost)\r\n{\r\nstruct fc_lport *lport = shost_priv(shost);\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct fcoe_interface *fcoe = port->priv;\r\nstruct fcoe_ctlr *ctlr = fcoe_to_ctlr(fcoe);\r\nstruct fcoe_ctlr_device *cdev = fcoe_ctlr_to_ctlr_dev(ctlr);\r\nfcoe_ctlr_link_down(ctlr);\r\nfcoe_clean_pending_queue(ctlr->lp);\r\nif (cdev->enabled != FCOE_CTLR_DISABLED &&\r\n!fcoe_link_ok(ctlr->lp))\r\nfcoe_ctlr_link_up(ctlr);\r\nreturn 0;\r\n}\r\nstatic struct fcoe_interface *\r\nfcoe_hostlist_lookup_port(const struct net_device *netdev)\r\n{\r\nstruct fcoe_interface *fcoe;\r\nlist_for_each_entry(fcoe, &fcoe_hostlist, list) {\r\nif (fcoe->netdev == netdev)\r\nreturn fcoe;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct fc_lport *fcoe_hostlist_lookup(const struct net_device *netdev)\r\n{\r\nstruct fcoe_ctlr *ctlr;\r\nstruct fcoe_interface *fcoe;\r\nfcoe = fcoe_hostlist_lookup_port(netdev);\r\nctlr = fcoe_to_ctlr(fcoe);\r\nreturn (fcoe) ? ctlr->lp : NULL;\r\n}\r\nstatic int fcoe_hostlist_add(const struct fc_lport *lport)\r\n{\r\nstruct fcoe_interface *fcoe;\r\nstruct fcoe_port *port;\r\nfcoe = fcoe_hostlist_lookup_port(fcoe_netdev(lport));\r\nif (!fcoe) {\r\nport = lport_priv(lport);\r\nfcoe = port->priv;\r\nlist_add_tail(&fcoe->list, &fcoe_hostlist);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fcoe_hostlist_del(const struct fc_lport *lport)\r\n{\r\nstruct fcoe_interface *fcoe;\r\nstruct fcoe_port *port;\r\nport = lport_priv(lport);\r\nfcoe = port->priv;\r\nlist_del(&fcoe->list);\r\nreturn;\r\n}\r\nstatic int __init fcoe_init(void)\r\n{\r\nstruct fcoe_percpu_s *p;\r\nunsigned int cpu;\r\nint rc = 0;\r\nfcoe_wq = alloc_workqueue("fcoe", 0, 0);\r\nif (!fcoe_wq)\r\nreturn -ENOMEM;\r\nrc = fcoe_transport_attach(&fcoe_sw_transport);\r\nif (rc) {\r\nprintk(KERN_ERR "failed to register an fcoe transport, check "\r\n"if libfcoe is loaded\n");\r\ngoto out_destroy;\r\n}\r\nmutex_lock(&fcoe_config_mutex);\r\nfor_each_possible_cpu(cpu) {\r\np = per_cpu_ptr(&fcoe_percpu, cpu);\r\nINIT_WORK(&p->work, fcoe_receive_work);\r\nskb_queue_head_init(&p->fcoe_rx_list);\r\n}\r\nfcoe_dev_setup();\r\nrc = fcoe_if_init();\r\nif (rc)\r\ngoto out_free;\r\nmutex_unlock(&fcoe_config_mutex);\r\nreturn 0;\r\nout_free:\r\nmutex_unlock(&fcoe_config_mutex);\r\nout_destroy:\r\ndestroy_workqueue(fcoe_wq);\r\nreturn rc;\r\n}\r\nstatic void __exit fcoe_exit(void)\r\n{\r\nstruct fcoe_interface *fcoe, *tmp;\r\nstruct fcoe_ctlr *ctlr;\r\nstruct fcoe_port *port;\r\nunsigned int cpu;\r\nmutex_lock(&fcoe_config_mutex);\r\nfcoe_dev_cleanup();\r\nrtnl_lock();\r\nlist_for_each_entry_safe(fcoe, tmp, &fcoe_hostlist, list) {\r\nctlr = fcoe_to_ctlr(fcoe);\r\nport = lport_priv(ctlr->lp);\r\nfcoe_hostlist_del(port->lport);\r\nqueue_work(fcoe_wq, &port->destroy_work);\r\n}\r\nrtnl_unlock();\r\nfor_each_possible_cpu(cpu)\r\nfcoe_thread_cleanup_local(cpu);\r\nmutex_unlock(&fcoe_config_mutex);\r\ndestroy_workqueue(fcoe_wq);\r\nfcoe_if_exit();\r\nfcoe_transport_detach(&fcoe_sw_transport);\r\n}\r\nstatic void fcoe_flogi_resp(struct fc_seq *seq, struct fc_frame *fp, void *arg)\r\n{\r\nstruct fcoe_ctlr *fip = arg;\r\nstruct fc_exch *exch = fc_seq_exch(seq);\r\nstruct fc_lport *lport = exch->lp;\r\nu8 *mac;\r\nif (IS_ERR(fp))\r\ngoto done;\r\nmac = fr_cb(fp)->granted_mac;\r\nif (is_zero_ether_addr(mac))\r\nfcoe_ctlr_recv_flogi(fip, lport, fp);\r\nif (!is_zero_ether_addr(mac))\r\nfcoe_update_src_mac(lport, mac);\r\ndone:\r\nfc_lport_flogi_resp(seq, fp, lport);\r\n}\r\nstatic void fcoe_logo_resp(struct fc_seq *seq, struct fc_frame *fp, void *arg)\r\n{\r\nstruct fc_lport *lport = arg;\r\nstatic u8 zero_mac[ETH_ALEN] = { 0 };\r\nif (!IS_ERR(fp))\r\nfcoe_update_src_mac(lport, zero_mac);\r\nfc_lport_logo_resp(seq, fp, lport);\r\n}\r\nstatic struct fc_seq *fcoe_elsct_send(struct fc_lport *lport, u32 did,\r\nstruct fc_frame *fp, unsigned int op,\r\nvoid (*resp)(struct fc_seq *,\r\nstruct fc_frame *,\r\nvoid *),\r\nvoid *arg, u32 timeout)\r\n{\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct fcoe_interface *fcoe = port->priv;\r\nstruct fcoe_ctlr *fip = fcoe_to_ctlr(fcoe);\r\nstruct fc_frame_header *fh = fc_frame_header_get(fp);\r\nswitch (op) {\r\ncase ELS_FLOGI:\r\ncase ELS_FDISC:\r\nif (lport->point_to_multipoint)\r\nbreak;\r\nreturn fc_elsct_send(lport, did, fp, op, fcoe_flogi_resp,\r\nfip, timeout);\r\ncase ELS_LOGO:\r\nif (ntoh24(fh->fh_d_id) != FC_FID_FLOGI)\r\nbreak;\r\nreturn fc_elsct_send(lport, did, fp, op, fcoe_logo_resp,\r\nlport, timeout);\r\n}\r\nreturn fc_elsct_send(lport, did, fp, op, resp, arg, timeout);\r\n}\r\nstatic int fcoe_vport_create(struct fc_vport *vport, bool disabled)\r\n{\r\nstruct Scsi_Host *shost = vport_to_shost(vport);\r\nstruct fc_lport *n_port = shost_priv(shost);\r\nstruct fcoe_port *port = lport_priv(n_port);\r\nstruct fcoe_interface *fcoe = port->priv;\r\nstruct net_device *netdev = fcoe->netdev;\r\nstruct fc_lport *vn_port;\r\nint rc;\r\nchar buf[32];\r\nrc = fcoe_validate_vport_create(vport);\r\nif (rc) {\r\nfcoe_wwn_to_str(vport->port_name, buf, sizeof(buf));\r\nprintk(KERN_ERR "fcoe: Failed to create vport, "\r\n"WWPN (0x%s) already exists\n",\r\nbuf);\r\nreturn rc;\r\n}\r\nmutex_lock(&fcoe_config_mutex);\r\nrtnl_lock();\r\nvn_port = fcoe_if_create(fcoe, &vport->dev, 1);\r\nrtnl_unlock();\r\nmutex_unlock(&fcoe_config_mutex);\r\nif (IS_ERR(vn_port)) {\r\nprintk(KERN_ERR "fcoe: fcoe_vport_create(%s) failed\n",\r\nnetdev->name);\r\nreturn -EIO;\r\n}\r\nif (disabled) {\r\nfc_vport_set_state(vport, FC_VPORT_DISABLED);\r\n} else {\r\nvn_port->boot_time = jiffies;\r\nfc_fabric_login(vn_port);\r\nfc_vport_setlink(vn_port);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fcoe_vport_destroy(struct fc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost = vport_to_shost(vport);\r\nstruct fc_lport *n_port = shost_priv(shost);\r\nstruct fc_lport *vn_port = vport->dd_data;\r\nmutex_lock(&n_port->lp_mutex);\r\nlist_del(&vn_port->list);\r\nmutex_unlock(&n_port->lp_mutex);\r\nmutex_lock(&fcoe_config_mutex);\r\nfcoe_if_destroy(vn_port);\r\nmutex_unlock(&fcoe_config_mutex);\r\nreturn 0;\r\n}\r\nstatic int fcoe_vport_disable(struct fc_vport *vport, bool disable)\r\n{\r\nstruct fc_lport *lport = vport->dd_data;\r\nif (disable) {\r\nfc_vport_set_state(vport, FC_VPORT_DISABLED);\r\nfc_fabric_logoff(lport);\r\n} else {\r\nlport->boot_time = jiffies;\r\nfc_fabric_login(lport);\r\nfc_vport_setlink(lport);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fcoe_set_vport_symbolic_name(struct fc_vport *vport)\r\n{\r\nstruct fc_lport *lport = vport->dd_data;\r\nstruct fc_frame *fp;\r\nsize_t len;\r\nsnprintf(fc_host_symbolic_name(lport->host), FC_SYMBOLIC_NAME_SIZE,\r\n"%s v%s over %s : %s", FCOE_NAME, FCOE_VERSION,\r\nfcoe_netdev(lport)->name, vport->symbolic_name);\r\nif (lport->state != LPORT_ST_READY)\r\nreturn;\r\nlen = strnlen(fc_host_symbolic_name(lport->host), 255);\r\nfp = fc_frame_alloc(lport,\r\nsizeof(struct fc_ct_hdr) +\r\nsizeof(struct fc_ns_rspn) + len);\r\nif (!fp)\r\nreturn;\r\nlport->tt.elsct_send(lport, FC_FID_DIR_SERV, fp, FC_NS_RSPN_ID,\r\nNULL, NULL, 3 * lport->r_a_tov);\r\n}\r\nstatic void fcoe_fcf_get_vlan_id(struct fcoe_fcf_device *fcf_dev)\r\n{\r\nstruct fcoe_ctlr_device *ctlr_dev =\r\nfcoe_fcf_dev_to_ctlr_dev(fcf_dev);\r\nstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(ctlr_dev);\r\nstruct fcoe_interface *fcoe = fcoe_ctlr_priv(ctlr);\r\nfcf_dev->vlan_id = vlan_dev_vlan_id(fcoe->netdev);\r\n}\r\nstatic void fcoe_set_port_id(struct fc_lport *lport,\r\nu32 port_id, struct fc_frame *fp)\r\n{\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct fcoe_interface *fcoe = port->priv;\r\nstruct fcoe_ctlr *ctlr = fcoe_to_ctlr(fcoe);\r\nif (fp && fc_frame_payload_op(fp) == ELS_FLOGI)\r\nfcoe_ctlr_recv_flogi(ctlr, lport, fp);\r\n}
