static int ext4_get_inline_size(struct inode *inode)\r\n{\r\nif (EXT4_I(inode)->i_inline_off)\r\nreturn EXT4_I(inode)->i_inline_size;\r\nreturn 0;\r\n}\r\nstatic int get_max_inline_xattr_value_size(struct inode *inode,\r\nstruct ext4_iloc *iloc)\r\n{\r\nstruct ext4_xattr_ibody_header *header;\r\nstruct ext4_xattr_entry *entry;\r\nstruct ext4_inode *raw_inode;\r\nint free, min_offs;\r\nmin_offs = EXT4_SB(inode->i_sb)->s_inode_size -\r\nEXT4_GOOD_OLD_INODE_SIZE -\r\nEXT4_I(inode)->i_extra_isize -\r\nsizeof(struct ext4_xattr_ibody_header);\r\nif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\r\nreturn EXT4_XATTR_SIZE(min_offs -\r\nEXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA)) -\r\nEXT4_XATTR_ROUND - sizeof(__u32));\r\nraw_inode = ext4_raw_inode(iloc);\r\nheader = IHDR(inode, raw_inode);\r\nentry = IFIRST(header);\r\nfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\r\nif (!entry->e_value_inum && entry->e_value_size) {\r\nsize_t offs = le16_to_cpu(entry->e_value_offs);\r\nif (offs < min_offs)\r\nmin_offs = offs;\r\n}\r\n}\r\nfree = min_offs -\r\n((void *)entry - (void *)IFIRST(header)) - sizeof(__u32);\r\nif (EXT4_I(inode)->i_inline_off) {\r\nentry = (struct ext4_xattr_entry *)\r\n((void *)raw_inode + EXT4_I(inode)->i_inline_off);\r\nfree += EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size));\r\ngoto out;\r\n}\r\nfree -= EXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA));\r\nif (free > EXT4_XATTR_ROUND)\r\nfree = EXT4_XATTR_SIZE(free - EXT4_XATTR_ROUND);\r\nelse\r\nfree = 0;\r\nout:\r\nreturn free;\r\n}\r\nint ext4_get_max_inline_size(struct inode *inode)\r\n{\r\nint error, max_inline_size;\r\nstruct ext4_iloc iloc;\r\nif (EXT4_I(inode)->i_extra_isize == 0)\r\nreturn 0;\r\nerror = ext4_get_inode_loc(inode, &iloc);\r\nif (error) {\r\next4_error_inode(inode, __func__, __LINE__, 0,\r\n"can't get inode location %lu",\r\ninode->i_ino);\r\nreturn 0;\r\n}\r\ndown_read(&EXT4_I(inode)->xattr_sem);\r\nmax_inline_size = get_max_inline_xattr_value_size(inode, &iloc);\r\nup_read(&EXT4_I(inode)->xattr_sem);\r\nbrelse(iloc.bh);\r\nif (!max_inline_size)\r\nreturn 0;\r\nreturn max_inline_size + EXT4_MIN_INLINE_DATA_SIZE;\r\n}\r\nint ext4_find_inline_data_nolock(struct inode *inode)\r\n{\r\nstruct ext4_xattr_ibody_find is = {\r\n.s = { .not_found = -ENODATA, },\r\n};\r\nstruct ext4_xattr_info i = {\r\n.name_index = EXT4_XATTR_INDEX_SYSTEM,\r\n.name = EXT4_XATTR_SYSTEM_DATA,\r\n};\r\nint error;\r\nif (EXT4_I(inode)->i_extra_isize == 0)\r\nreturn 0;\r\nerror = ext4_get_inode_loc(inode, &is.iloc);\r\nif (error)\r\nreturn error;\r\nerror = ext4_xattr_ibody_find(inode, &i, &is);\r\nif (error)\r\ngoto out;\r\nif (!is.s.not_found) {\r\nEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\r\n(void *)ext4_raw_inode(&is.iloc));\r\nEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\r\nle32_to_cpu(is.s.here->e_value_size);\r\next4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\r\n}\r\nout:\r\nbrelse(is.iloc.bh);\r\nreturn error;\r\n}\r\nstatic int ext4_read_inline_data(struct inode *inode, void *buffer,\r\nunsigned int len,\r\nstruct ext4_iloc *iloc)\r\n{\r\nstruct ext4_xattr_entry *entry;\r\nstruct ext4_xattr_ibody_header *header;\r\nint cp_len = 0;\r\nstruct ext4_inode *raw_inode;\r\nif (!len)\r\nreturn 0;\r\nBUG_ON(len > EXT4_I(inode)->i_inline_size);\r\ncp_len = len < EXT4_MIN_INLINE_DATA_SIZE ?\r\nlen : EXT4_MIN_INLINE_DATA_SIZE;\r\nraw_inode = ext4_raw_inode(iloc);\r\nmemcpy(buffer, (void *)(raw_inode->i_block), cp_len);\r\nlen -= cp_len;\r\nbuffer += cp_len;\r\nif (!len)\r\ngoto out;\r\nheader = IHDR(inode, raw_inode);\r\nentry = (struct ext4_xattr_entry *)((void *)raw_inode +\r\nEXT4_I(inode)->i_inline_off);\r\nlen = min_t(unsigned int, len,\r\n(unsigned int)le32_to_cpu(entry->e_value_size));\r\nmemcpy(buffer,\r\n(void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs), len);\r\ncp_len += len;\r\nout:\r\nreturn cp_len;\r\n}\r\nstatic void ext4_write_inline_data(struct inode *inode, struct ext4_iloc *iloc,\r\nvoid *buffer, loff_t pos, unsigned int len)\r\n{\r\nstruct ext4_xattr_entry *entry;\r\nstruct ext4_xattr_ibody_header *header;\r\nstruct ext4_inode *raw_inode;\r\nint cp_len = 0;\r\nif (unlikely(ext4_forced_shutdown(EXT4_SB(inode->i_sb))))\r\nreturn;\r\nBUG_ON(!EXT4_I(inode)->i_inline_off);\r\nBUG_ON(pos + len > EXT4_I(inode)->i_inline_size);\r\nraw_inode = ext4_raw_inode(iloc);\r\nbuffer += pos;\r\nif (pos < EXT4_MIN_INLINE_DATA_SIZE) {\r\ncp_len = pos + len > EXT4_MIN_INLINE_DATA_SIZE ?\r\nEXT4_MIN_INLINE_DATA_SIZE - pos : len;\r\nmemcpy((void *)raw_inode->i_block + pos, buffer, cp_len);\r\nlen -= cp_len;\r\nbuffer += cp_len;\r\npos += cp_len;\r\n}\r\nif (!len)\r\nreturn;\r\npos -= EXT4_MIN_INLINE_DATA_SIZE;\r\nheader = IHDR(inode, raw_inode);\r\nentry = (struct ext4_xattr_entry *)((void *)raw_inode +\r\nEXT4_I(inode)->i_inline_off);\r\nmemcpy((void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs) + pos,\r\nbuffer, len);\r\n}\r\nstatic int ext4_create_inline_data(handle_t *handle,\r\nstruct inode *inode, unsigned len)\r\n{\r\nint error;\r\nvoid *value = NULL;\r\nstruct ext4_xattr_ibody_find is = {\r\n.s = { .not_found = -ENODATA, },\r\n};\r\nstruct ext4_xattr_info i = {\r\n.name_index = EXT4_XATTR_INDEX_SYSTEM,\r\n.name = EXT4_XATTR_SYSTEM_DATA,\r\n};\r\nerror = ext4_get_inode_loc(inode, &is.iloc);\r\nif (error)\r\nreturn error;\r\nBUFFER_TRACE(is.iloc.bh, "get_write_access");\r\nerror = ext4_journal_get_write_access(handle, is.iloc.bh);\r\nif (error)\r\ngoto out;\r\nif (len > EXT4_MIN_INLINE_DATA_SIZE) {\r\nvalue = EXT4_ZERO_XATTR_VALUE;\r\nlen -= EXT4_MIN_INLINE_DATA_SIZE;\r\n} else {\r\nvalue = "";\r\nlen = 0;\r\n}\r\ni.value = value;\r\ni.value_len = len;\r\nerror = ext4_xattr_ibody_find(inode, &i, &is);\r\nif (error)\r\ngoto out;\r\nBUG_ON(!is.s.not_found);\r\nerror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\r\nif (error) {\r\nif (error == -ENOSPC)\r\next4_clear_inode_state(inode,\r\nEXT4_STATE_MAY_INLINE_DATA);\r\ngoto out;\r\n}\r\nmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\r\n0, EXT4_MIN_INLINE_DATA_SIZE);\r\nEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\r\n(void *)ext4_raw_inode(&is.iloc));\r\nEXT4_I(inode)->i_inline_size = len + EXT4_MIN_INLINE_DATA_SIZE;\r\next4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\r\next4_set_inode_flag(inode, EXT4_INODE_INLINE_DATA);\r\next4_set_inode_flags(inode);\r\nget_bh(is.iloc.bh);\r\nerror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\r\nout:\r\nbrelse(is.iloc.bh);\r\nreturn error;\r\n}\r\nstatic int ext4_update_inline_data(handle_t *handle, struct inode *inode,\r\nunsigned int len)\r\n{\r\nint error;\r\nvoid *value = NULL;\r\nstruct ext4_xattr_ibody_find is = {\r\n.s = { .not_found = -ENODATA, },\r\n};\r\nstruct ext4_xattr_info i = {\r\n.name_index = EXT4_XATTR_INDEX_SYSTEM,\r\n.name = EXT4_XATTR_SYSTEM_DATA,\r\n};\r\nif (len <= EXT4_I(inode)->i_inline_size)\r\nreturn 0;\r\nerror = ext4_get_inode_loc(inode, &is.iloc);\r\nif (error)\r\nreturn error;\r\nerror = ext4_xattr_ibody_find(inode, &i, &is);\r\nif (error)\r\ngoto out;\r\nBUG_ON(is.s.not_found);\r\nlen -= EXT4_MIN_INLINE_DATA_SIZE;\r\nvalue = kzalloc(len, GFP_NOFS);\r\nif (!value) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nerror = ext4_xattr_ibody_get(inode, i.name_index, i.name,\r\nvalue, len);\r\nif (error == -ENODATA)\r\ngoto out;\r\nBUFFER_TRACE(is.iloc.bh, "get_write_access");\r\nerror = ext4_journal_get_write_access(handle, is.iloc.bh);\r\nif (error)\r\ngoto out;\r\ni.value = value;\r\ni.value_len = len;\r\nerror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\r\nif (error)\r\ngoto out;\r\nEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\r\n(void *)ext4_raw_inode(&is.iloc));\r\nEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\r\nle32_to_cpu(is.s.here->e_value_size);\r\next4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\r\nget_bh(is.iloc.bh);\r\nerror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\r\nout:\r\nkfree(value);\r\nbrelse(is.iloc.bh);\r\nreturn error;\r\n}\r\nstatic int ext4_prepare_inline_data(handle_t *handle, struct inode *inode,\r\nunsigned int len)\r\n{\r\nint ret, size, no_expand;\r\nstruct ext4_inode_info *ei = EXT4_I(inode);\r\nif (!ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA))\r\nreturn -ENOSPC;\r\nsize = ext4_get_max_inline_size(inode);\r\nif (size < len)\r\nreturn -ENOSPC;\r\next4_write_lock_xattr(inode, &no_expand);\r\nif (ei->i_inline_off)\r\nret = ext4_update_inline_data(handle, inode, len);\r\nelse\r\nret = ext4_create_inline_data(handle, inode, len);\r\next4_write_unlock_xattr(inode, &no_expand);\r\nreturn ret;\r\n}\r\nstatic int ext4_destroy_inline_data_nolock(handle_t *handle,\r\nstruct inode *inode)\r\n{\r\nstruct ext4_inode_info *ei = EXT4_I(inode);\r\nstruct ext4_xattr_ibody_find is = {\r\n.s = { .not_found = 0, },\r\n};\r\nstruct ext4_xattr_info i = {\r\n.name_index = EXT4_XATTR_INDEX_SYSTEM,\r\n.name = EXT4_XATTR_SYSTEM_DATA,\r\n.value = NULL,\r\n.value_len = 0,\r\n};\r\nint error;\r\nif (!ei->i_inline_off)\r\nreturn 0;\r\nerror = ext4_get_inode_loc(inode, &is.iloc);\r\nif (error)\r\nreturn error;\r\nerror = ext4_xattr_ibody_find(inode, &i, &is);\r\nif (error)\r\ngoto out;\r\nBUFFER_TRACE(is.iloc.bh, "get_write_access");\r\nerror = ext4_journal_get_write_access(handle, is.iloc.bh);\r\nif (error)\r\ngoto out;\r\nerror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\r\nif (error)\r\ngoto out;\r\nmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\r\n0, EXT4_MIN_INLINE_DATA_SIZE);\r\nif (ext4_has_feature_extents(inode->i_sb)) {\r\nif (S_ISDIR(inode->i_mode) ||\r\nS_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {\r\next4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\r\next4_ext_tree_init(handle, inode);\r\n}\r\n}\r\next4_clear_inode_flag(inode, EXT4_INODE_INLINE_DATA);\r\next4_set_inode_flags(inode);\r\nget_bh(is.iloc.bh);\r\nerror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\r\nEXT4_I(inode)->i_inline_off = 0;\r\nEXT4_I(inode)->i_inline_size = 0;\r\next4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\r\nout:\r\nbrelse(is.iloc.bh);\r\nif (error == -ENODATA)\r\nerror = 0;\r\nreturn error;\r\n}\r\nstatic int ext4_read_inline_page(struct inode *inode, struct page *page)\r\n{\r\nvoid *kaddr;\r\nint ret = 0;\r\nsize_t len;\r\nstruct ext4_iloc iloc;\r\nBUG_ON(!PageLocked(page));\r\nBUG_ON(!ext4_has_inline_data(inode));\r\nBUG_ON(page->index);\r\nif (!EXT4_I(inode)->i_inline_off) {\r\next4_warning(inode->i_sb, "inode %lu doesn't have inline data.",\r\ninode->i_ino);\r\ngoto out;\r\n}\r\nret = ext4_get_inode_loc(inode, &iloc);\r\nif (ret)\r\ngoto out;\r\nlen = min_t(size_t, ext4_get_inline_size(inode), i_size_read(inode));\r\nkaddr = kmap_atomic(page);\r\nret = ext4_read_inline_data(inode, kaddr, len, &iloc);\r\nflush_dcache_page(page);\r\nkunmap_atomic(kaddr);\r\nzero_user_segment(page, len, PAGE_SIZE);\r\nSetPageUptodate(page);\r\nbrelse(iloc.bh);\r\nout:\r\nreturn ret;\r\n}\r\nint ext4_readpage_inline(struct inode *inode, struct page *page)\r\n{\r\nint ret = 0;\r\ndown_read(&EXT4_I(inode)->xattr_sem);\r\nif (!ext4_has_inline_data(inode)) {\r\nup_read(&EXT4_I(inode)->xattr_sem);\r\nreturn -EAGAIN;\r\n}\r\nif (!page->index)\r\nret = ext4_read_inline_page(inode, page);\r\nelse if (!PageUptodate(page)) {\r\nzero_user_segment(page, 0, PAGE_SIZE);\r\nSetPageUptodate(page);\r\n}\r\nup_read(&EXT4_I(inode)->xattr_sem);\r\nunlock_page(page);\r\nreturn ret >= 0 ? 0 : ret;\r\n}\r\nstatic int ext4_convert_inline_data_to_extent(struct address_space *mapping,\r\nstruct inode *inode,\r\nunsigned flags)\r\n{\r\nint ret, needed_blocks, no_expand;\r\nhandle_t *handle = NULL;\r\nint retries = 0, sem_held = 0;\r\nstruct page *page = NULL;\r\nunsigned from, to;\r\nstruct ext4_iloc iloc;\r\nif (!ext4_has_inline_data(inode)) {\r\next4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\r\nreturn 0;\r\n}\r\nneeded_blocks = ext4_writepage_trans_blocks(inode);\r\nret = ext4_get_inode_loc(inode, &iloc);\r\nif (ret)\r\nreturn ret;\r\nretry:\r\nhandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\r\nif (IS_ERR(handle)) {\r\nret = PTR_ERR(handle);\r\nhandle = NULL;\r\ngoto out;\r\n}\r\nflags |= AOP_FLAG_NOFS;\r\npage = grab_cache_page_write_begin(mapping, 0, flags);\r\nif (!page) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\next4_write_lock_xattr(inode, &no_expand);\r\nsem_held = 1;\r\nif (!ext4_has_inline_data(inode)) {\r\nret = 0;\r\ngoto out;\r\n}\r\nfrom = 0;\r\nto = ext4_get_inline_size(inode);\r\nif (!PageUptodate(page)) {\r\nret = ext4_read_inline_page(inode, page);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nret = ext4_destroy_inline_data_nolock(handle, inode);\r\nif (ret)\r\ngoto out;\r\nif (ext4_should_dioread_nolock(inode)) {\r\nret = __block_write_begin(page, from, to,\r\next4_get_block_unwritten);\r\n} else\r\nret = __block_write_begin(page, from, to, ext4_get_block);\r\nif (!ret && ext4_should_journal_data(inode)) {\r\nret = ext4_walk_page_buffers(handle, page_buffers(page),\r\nfrom, to, NULL,\r\ndo_journal_get_write_access);\r\n}\r\nif (ret) {\r\nunlock_page(page);\r\nput_page(page);\r\npage = NULL;\r\next4_orphan_add(handle, inode);\r\next4_write_unlock_xattr(inode, &no_expand);\r\nsem_held = 0;\r\next4_journal_stop(handle);\r\nhandle = NULL;\r\next4_truncate_failed_write(inode);\r\nif (inode->i_nlink)\r\next4_orphan_del(NULL, inode);\r\n}\r\nif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\r\ngoto retry;\r\nif (page)\r\nblock_commit_write(page, from, to);\r\nout:\r\nif (page) {\r\nunlock_page(page);\r\nput_page(page);\r\n}\r\nif (sem_held)\r\next4_write_unlock_xattr(inode, &no_expand);\r\nif (handle)\r\next4_journal_stop(handle);\r\nbrelse(iloc.bh);\r\nreturn ret;\r\n}\r\nint ext4_try_to_write_inline_data(struct address_space *mapping,\r\nstruct inode *inode,\r\nloff_t pos, unsigned len,\r\nunsigned flags,\r\nstruct page **pagep)\r\n{\r\nint ret;\r\nhandle_t *handle;\r\nstruct page *page;\r\nstruct ext4_iloc iloc;\r\nif (pos + len > ext4_get_max_inline_size(inode))\r\ngoto convert;\r\nret = ext4_get_inode_loc(inode, &iloc);\r\nif (ret)\r\nreturn ret;\r\nhandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\r\nif (IS_ERR(handle)) {\r\nret = PTR_ERR(handle);\r\nhandle = NULL;\r\ngoto out;\r\n}\r\nret = ext4_prepare_inline_data(handle, inode, pos + len);\r\nif (ret && ret != -ENOSPC)\r\ngoto out;\r\nif (ret == -ENOSPC) {\r\next4_journal_stop(handle);\r\nbrelse(iloc.bh);\r\ngoto convert;\r\n}\r\nflags |= AOP_FLAG_NOFS;\r\npage = grab_cache_page_write_begin(mapping, 0, flags);\r\nif (!page) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\n*pagep = page;\r\ndown_read(&EXT4_I(inode)->xattr_sem);\r\nif (!ext4_has_inline_data(inode)) {\r\nret = 0;\r\nunlock_page(page);\r\nput_page(page);\r\ngoto out_up_read;\r\n}\r\nif (!PageUptodate(page)) {\r\nret = ext4_read_inline_page(inode, page);\r\nif (ret < 0)\r\ngoto out_up_read;\r\n}\r\nret = 1;\r\nhandle = NULL;\r\nout_up_read:\r\nup_read(&EXT4_I(inode)->xattr_sem);\r\nout:\r\nif (handle)\r\next4_journal_stop(handle);\r\nbrelse(iloc.bh);\r\nreturn ret;\r\nconvert:\r\nreturn ext4_convert_inline_data_to_extent(mapping,\r\ninode, flags);\r\n}\r\nint ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\r\nunsigned copied, struct page *page)\r\n{\r\nint ret, no_expand;\r\nvoid *kaddr;\r\nstruct ext4_iloc iloc;\r\nif (unlikely(copied < len)) {\r\nif (!PageUptodate(page)) {\r\ncopied = 0;\r\ngoto out;\r\n}\r\n}\r\nret = ext4_get_inode_loc(inode, &iloc);\r\nif (ret) {\r\next4_std_error(inode->i_sb, ret);\r\ncopied = 0;\r\ngoto out;\r\n}\r\next4_write_lock_xattr(inode, &no_expand);\r\nBUG_ON(!ext4_has_inline_data(inode));\r\nkaddr = kmap_atomic(page);\r\next4_write_inline_data(inode, &iloc, kaddr, pos, len);\r\nkunmap_atomic(kaddr);\r\nSetPageUptodate(page);\r\nClearPageDirty(page);\r\next4_write_unlock_xattr(inode, &no_expand);\r\nbrelse(iloc.bh);\r\nout:\r\nreturn copied;\r\n}\r\nstruct buffer_head *\r\next4_journalled_write_inline_data(struct inode *inode,\r\nunsigned len,\r\nstruct page *page)\r\n{\r\nint ret, no_expand;\r\nvoid *kaddr;\r\nstruct ext4_iloc iloc;\r\nret = ext4_get_inode_loc(inode, &iloc);\r\nif (ret) {\r\next4_std_error(inode->i_sb, ret);\r\nreturn NULL;\r\n}\r\next4_write_lock_xattr(inode, &no_expand);\r\nkaddr = kmap_atomic(page);\r\next4_write_inline_data(inode, &iloc, kaddr, 0, len);\r\nkunmap_atomic(kaddr);\r\next4_write_unlock_xattr(inode, &no_expand);\r\nreturn iloc.bh;\r\n}\r\nstatic int ext4_da_convert_inline_data_to_extent(struct address_space *mapping,\r\nstruct inode *inode,\r\nunsigned flags,\r\nvoid **fsdata)\r\n{\r\nint ret = 0, inline_size;\r\nstruct page *page;\r\npage = grab_cache_page_write_begin(mapping, 0, flags);\r\nif (!page)\r\nreturn -ENOMEM;\r\ndown_read(&EXT4_I(inode)->xattr_sem);\r\nif (!ext4_has_inline_data(inode)) {\r\next4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\r\ngoto out;\r\n}\r\ninline_size = ext4_get_inline_size(inode);\r\nif (!PageUptodate(page)) {\r\nret = ext4_read_inline_page(inode, page);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nret = __block_write_begin(page, 0, inline_size,\r\next4_da_get_block_prep);\r\nif (ret) {\r\nup_read(&EXT4_I(inode)->xattr_sem);\r\nunlock_page(page);\r\nput_page(page);\r\next4_truncate_failed_write(inode);\r\nreturn ret;\r\n}\r\nSetPageDirty(page);\r\nSetPageUptodate(page);\r\next4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\r\n*fsdata = (void *)CONVERT_INLINE_DATA;\r\nout:\r\nup_read(&EXT4_I(inode)->xattr_sem);\r\nif (page) {\r\nunlock_page(page);\r\nput_page(page);\r\n}\r\nreturn ret;\r\n}\r\nint ext4_da_write_inline_data_begin(struct address_space *mapping,\r\nstruct inode *inode,\r\nloff_t pos, unsigned len,\r\nunsigned flags,\r\nstruct page **pagep,\r\nvoid **fsdata)\r\n{\r\nint ret, inline_size;\r\nhandle_t *handle;\r\nstruct page *page;\r\nstruct ext4_iloc iloc;\r\nint retries;\r\nret = ext4_get_inode_loc(inode, &iloc);\r\nif (ret)\r\nreturn ret;\r\nretry_journal:\r\nhandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\r\nif (IS_ERR(handle)) {\r\nret = PTR_ERR(handle);\r\ngoto out;\r\n}\r\ninline_size = ext4_get_max_inline_size(inode);\r\nret = -ENOSPC;\r\nif (inline_size >= pos + len) {\r\nret = ext4_prepare_inline_data(handle, inode, pos + len);\r\nif (ret && ret != -ENOSPC)\r\ngoto out_journal;\r\n}\r\nflags |= AOP_FLAG_NOFS;\r\nif (ret == -ENOSPC) {\r\nret = ext4_da_convert_inline_data_to_extent(mapping,\r\ninode,\r\nflags,\r\nfsdata);\r\next4_journal_stop(handle);\r\nif (ret == -ENOSPC &&\r\next4_should_retry_alloc(inode->i_sb, &retries))\r\ngoto retry_journal;\r\ngoto out;\r\n}\r\npage = grab_cache_page_write_begin(mapping, 0, flags);\r\nif (!page) {\r\nret = -ENOMEM;\r\ngoto out_journal;\r\n}\r\ndown_read(&EXT4_I(inode)->xattr_sem);\r\nif (!ext4_has_inline_data(inode)) {\r\nret = 0;\r\ngoto out_release_page;\r\n}\r\nif (!PageUptodate(page)) {\r\nret = ext4_read_inline_page(inode, page);\r\nif (ret < 0)\r\ngoto out_release_page;\r\n}\r\nup_read(&EXT4_I(inode)->xattr_sem);\r\n*pagep = page;\r\nbrelse(iloc.bh);\r\nreturn 1;\r\nout_release_page:\r\nup_read(&EXT4_I(inode)->xattr_sem);\r\nunlock_page(page);\r\nput_page(page);\r\nout_journal:\r\next4_journal_stop(handle);\r\nout:\r\nbrelse(iloc.bh);\r\nreturn ret;\r\n}\r\nint ext4_da_write_inline_data_end(struct inode *inode, loff_t pos,\r\nunsigned len, unsigned copied,\r\nstruct page *page)\r\n{\r\nint i_size_changed = 0;\r\nint ret;\r\nret = ext4_write_inline_data_end(inode, pos, len, copied, page);\r\nif (ret < 0) {\r\nunlock_page(page);\r\nput_page(page);\r\nreturn ret;\r\n}\r\ncopied = ret;\r\nif (pos+copied > inode->i_size) {\r\ni_size_write(inode, pos+copied);\r\ni_size_changed = 1;\r\n}\r\nunlock_page(page);\r\nput_page(page);\r\nif (i_size_changed)\r\nmark_inode_dirty(inode);\r\nreturn copied;\r\n}\r\nvoid ext4_show_inline_dir(struct inode *dir, struct buffer_head *bh,\r\nvoid *inline_start, int inline_size)\r\n{\r\nint offset;\r\nunsigned short de_len;\r\nstruct ext4_dir_entry_2 *de = inline_start;\r\nvoid *dlimit = inline_start + inline_size;\r\ntrace_printk("inode %lu\n", dir->i_ino);\r\noffset = 0;\r\nwhile ((void *)de < dlimit) {\r\nde_len = ext4_rec_len_from_disk(de->rec_len, inline_size);\r\ntrace_printk("de: off %u rlen %u name %.*s nlen %u ino %u\n",\r\noffset, de_len, de->name_len, de->name,\r\nde->name_len, le32_to_cpu(de->inode));\r\nif (ext4_check_dir_entry(dir, NULL, de, bh,\r\ninline_start, inline_size, offset))\r\nBUG();\r\noffset += de_len;\r\nde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\r\n}\r\n}\r\nstatic int ext4_add_dirent_to_inline(handle_t *handle,\r\nstruct ext4_filename *fname,\r\nstruct inode *dir,\r\nstruct inode *inode,\r\nstruct ext4_iloc *iloc,\r\nvoid *inline_start, int inline_size)\r\n{\r\nint err;\r\nstruct ext4_dir_entry_2 *de;\r\nerr = ext4_find_dest_de(dir, inode, iloc->bh, inline_start,\r\ninline_size, fname, &de);\r\nif (err)\r\nreturn err;\r\nBUFFER_TRACE(iloc->bh, "get_write_access");\r\nerr = ext4_journal_get_write_access(handle, iloc->bh);\r\nif (err)\r\nreturn err;\r\next4_insert_dentry(inode, de, inline_size, fname);\r\next4_show_inline_dir(dir, iloc->bh, inline_start, inline_size);\r\ndir->i_mtime = dir->i_ctime = current_time(dir);\r\next4_update_dx_flag(dir);\r\ndir->i_version++;\r\nreturn 1;\r\n}\r\nstatic void *ext4_get_inline_xattr_pos(struct inode *inode,\r\nstruct ext4_iloc *iloc)\r\n{\r\nstruct ext4_xattr_entry *entry;\r\nstruct ext4_xattr_ibody_header *header;\r\nBUG_ON(!EXT4_I(inode)->i_inline_off);\r\nheader = IHDR(inode, ext4_raw_inode(iloc));\r\nentry = (struct ext4_xattr_entry *)((void *)ext4_raw_inode(iloc) +\r\nEXT4_I(inode)->i_inline_off);\r\nreturn (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs);\r\n}\r\nstatic void ext4_update_final_de(void *de_buf, int old_size, int new_size)\r\n{\r\nstruct ext4_dir_entry_2 *de, *prev_de;\r\nvoid *limit;\r\nint de_len;\r\nde = (struct ext4_dir_entry_2 *)de_buf;\r\nif (old_size) {\r\nlimit = de_buf + old_size;\r\ndo {\r\nprev_de = de;\r\nde_len = ext4_rec_len_from_disk(de->rec_len, old_size);\r\nde_buf += de_len;\r\nde = (struct ext4_dir_entry_2 *)de_buf;\r\n} while (de_buf < limit);\r\nprev_de->rec_len = ext4_rec_len_to_disk(de_len + new_size -\r\nold_size, new_size);\r\n} else {\r\nde->inode = 0;\r\nde->rec_len = ext4_rec_len_to_disk(new_size, new_size);\r\n}\r\n}\r\nstatic int ext4_update_inline_dir(handle_t *handle, struct inode *dir,\r\nstruct ext4_iloc *iloc)\r\n{\r\nint ret;\r\nint old_size = EXT4_I(dir)->i_inline_size - EXT4_MIN_INLINE_DATA_SIZE;\r\nint new_size = get_max_inline_xattr_value_size(dir, iloc);\r\nif (new_size - old_size <= EXT4_DIR_REC_LEN(1))\r\nreturn -ENOSPC;\r\nret = ext4_update_inline_data(handle, dir,\r\nnew_size + EXT4_MIN_INLINE_DATA_SIZE);\r\nif (ret)\r\nreturn ret;\r\next4_update_final_de(ext4_get_inline_xattr_pos(dir, iloc), old_size,\r\nEXT4_I(dir)->i_inline_size -\r\nEXT4_MIN_INLINE_DATA_SIZE);\r\ndir->i_size = EXT4_I(dir)->i_disksize = EXT4_I(dir)->i_inline_size;\r\nreturn 0;\r\n}\r\nstatic void ext4_restore_inline_data(handle_t *handle, struct inode *inode,\r\nstruct ext4_iloc *iloc,\r\nvoid *buf, int inline_size)\r\n{\r\next4_create_inline_data(handle, inode, inline_size);\r\next4_write_inline_data(inode, iloc, buf, 0, inline_size);\r\next4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\r\n}\r\nstatic int ext4_finish_convert_inline_dir(handle_t *handle,\r\nstruct inode *inode,\r\nstruct buffer_head *dir_block,\r\nvoid *buf,\r\nint inline_size)\r\n{\r\nint err, csum_size = 0, header_size = 0;\r\nstruct ext4_dir_entry_2 *de;\r\nstruct ext4_dir_entry_tail *t;\r\nvoid *target = dir_block->b_data;\r\nde = (struct ext4_dir_entry_2 *)target;\r\nde = ext4_init_dot_dotdot(inode, de,\r\ninode->i_sb->s_blocksize, csum_size,\r\nle32_to_cpu(((struct ext4_dir_entry_2 *)buf)->inode), 1);\r\nheader_size = (void *)de - target;\r\nmemcpy((void *)de, buf + EXT4_INLINE_DOTDOT_SIZE,\r\ninline_size - EXT4_INLINE_DOTDOT_SIZE);\r\nif (ext4_has_metadata_csum(inode->i_sb))\r\ncsum_size = sizeof(struct ext4_dir_entry_tail);\r\ninode->i_size = inode->i_sb->s_blocksize;\r\ni_size_write(inode, inode->i_sb->s_blocksize);\r\nEXT4_I(inode)->i_disksize = inode->i_sb->s_blocksize;\r\next4_update_final_de(dir_block->b_data,\r\ninline_size - EXT4_INLINE_DOTDOT_SIZE + header_size,\r\ninode->i_sb->s_blocksize - csum_size);\r\nif (csum_size) {\r\nt = EXT4_DIRENT_TAIL(dir_block->b_data,\r\ninode->i_sb->s_blocksize);\r\ninitialize_dirent_tail(t, inode->i_sb->s_blocksize);\r\n}\r\nset_buffer_uptodate(dir_block);\r\nerr = ext4_handle_dirty_dirent_node(handle, inode, dir_block);\r\nif (err)\r\nreturn err;\r\nset_buffer_verified(dir_block);\r\nreturn ext4_mark_inode_dirty(handle, inode);\r\n}\r\nstatic int ext4_convert_inline_data_nolock(handle_t *handle,\r\nstruct inode *inode,\r\nstruct ext4_iloc *iloc)\r\n{\r\nint error;\r\nvoid *buf = NULL;\r\nstruct buffer_head *data_bh = NULL;\r\nstruct ext4_map_blocks map;\r\nint inline_size;\r\ninline_size = ext4_get_inline_size(inode);\r\nbuf = kmalloc(inline_size, GFP_NOFS);\r\nif (!buf) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nerror = ext4_read_inline_data(inode, buf, inline_size, iloc);\r\nif (error < 0)\r\ngoto out;\r\nif (S_ISDIR(inode->i_mode)) {\r\nerror = ext4_check_all_de(inode, iloc->bh,\r\nbuf + EXT4_INLINE_DOTDOT_SIZE,\r\ninline_size - EXT4_INLINE_DOTDOT_SIZE);\r\nif (error)\r\ngoto out;\r\n}\r\nerror = ext4_destroy_inline_data_nolock(handle, inode);\r\nif (error)\r\ngoto out;\r\nmap.m_lblk = 0;\r\nmap.m_len = 1;\r\nmap.m_flags = 0;\r\nerror = ext4_map_blocks(handle, inode, &map, EXT4_GET_BLOCKS_CREATE);\r\nif (error < 0)\r\ngoto out_restore;\r\nif (!(map.m_flags & EXT4_MAP_MAPPED)) {\r\nerror = -EIO;\r\ngoto out_restore;\r\n}\r\ndata_bh = sb_getblk(inode->i_sb, map.m_pblk);\r\nif (!data_bh) {\r\nerror = -ENOMEM;\r\ngoto out_restore;\r\n}\r\nlock_buffer(data_bh);\r\nerror = ext4_journal_get_create_access(handle, data_bh);\r\nif (error) {\r\nunlock_buffer(data_bh);\r\nerror = -EIO;\r\ngoto out_restore;\r\n}\r\nmemset(data_bh->b_data, 0, inode->i_sb->s_blocksize);\r\nif (!S_ISDIR(inode->i_mode)) {\r\nmemcpy(data_bh->b_data, buf, inline_size);\r\nset_buffer_uptodate(data_bh);\r\nerror = ext4_handle_dirty_metadata(handle,\r\ninode, data_bh);\r\n} else {\r\nerror = ext4_finish_convert_inline_dir(handle, inode, data_bh,\r\nbuf, inline_size);\r\n}\r\nunlock_buffer(data_bh);\r\nout_restore:\r\nif (error)\r\next4_restore_inline_data(handle, inode, iloc, buf, inline_size);\r\nout:\r\nbrelse(data_bh);\r\nkfree(buf);\r\nreturn error;\r\n}\r\nint ext4_try_add_inline_entry(handle_t *handle, struct ext4_filename *fname,\r\nstruct inode *dir, struct inode *inode)\r\n{\r\nint ret, inline_size, no_expand;\r\nvoid *inline_start;\r\nstruct ext4_iloc iloc;\r\nret = ext4_get_inode_loc(dir, &iloc);\r\nif (ret)\r\nreturn ret;\r\next4_write_lock_xattr(dir, &no_expand);\r\nif (!ext4_has_inline_data(dir))\r\ngoto out;\r\ninline_start = (void *)ext4_raw_inode(&iloc)->i_block +\r\nEXT4_INLINE_DOTDOT_SIZE;\r\ninline_size = EXT4_MIN_INLINE_DATA_SIZE - EXT4_INLINE_DOTDOT_SIZE;\r\nret = ext4_add_dirent_to_inline(handle, fname, dir, inode, &iloc,\r\ninline_start, inline_size);\r\nif (ret != -ENOSPC)\r\ngoto out;\r\ninline_size = EXT4_I(dir)->i_inline_size -\r\nEXT4_MIN_INLINE_DATA_SIZE;\r\nif (!inline_size) {\r\nret = ext4_update_inline_dir(handle, dir, &iloc);\r\nif (ret && ret != -ENOSPC)\r\ngoto out;\r\ninline_size = EXT4_I(dir)->i_inline_size -\r\nEXT4_MIN_INLINE_DATA_SIZE;\r\n}\r\nif (inline_size) {\r\ninline_start = ext4_get_inline_xattr_pos(dir, &iloc);\r\nret = ext4_add_dirent_to_inline(handle, fname, dir,\r\ninode, &iloc, inline_start,\r\ninline_size);\r\nif (ret != -ENOSPC)\r\ngoto out;\r\n}\r\nret = ext4_convert_inline_data_nolock(handle, dir, &iloc);\r\nout:\r\next4_write_unlock_xattr(dir, &no_expand);\r\next4_mark_inode_dirty(handle, dir);\r\nbrelse(iloc.bh);\r\nreturn ret;\r\n}\r\nint htree_inlinedir_to_tree(struct file *dir_file,\r\nstruct inode *dir, ext4_lblk_t block,\r\nstruct dx_hash_info *hinfo,\r\n__u32 start_hash, __u32 start_minor_hash,\r\nint *has_inline_data)\r\n{\r\nint err = 0, count = 0;\r\nunsigned int parent_ino;\r\nint pos;\r\nstruct ext4_dir_entry_2 *de;\r\nstruct inode *inode = file_inode(dir_file);\r\nint ret, inline_size = 0;\r\nstruct ext4_iloc iloc;\r\nvoid *dir_buf = NULL;\r\nstruct ext4_dir_entry_2 fake;\r\nstruct fscrypt_str tmp_str;\r\nret = ext4_get_inode_loc(inode, &iloc);\r\nif (ret)\r\nreturn ret;\r\ndown_read(&EXT4_I(inode)->xattr_sem);\r\nif (!ext4_has_inline_data(inode)) {\r\nup_read(&EXT4_I(inode)->xattr_sem);\r\n*has_inline_data = 0;\r\ngoto out;\r\n}\r\ninline_size = ext4_get_inline_size(inode);\r\ndir_buf = kmalloc(inline_size, GFP_NOFS);\r\nif (!dir_buf) {\r\nret = -ENOMEM;\r\nup_read(&EXT4_I(inode)->xattr_sem);\r\ngoto out;\r\n}\r\nret = ext4_read_inline_data(inode, dir_buf, inline_size, &iloc);\r\nup_read(&EXT4_I(inode)->xattr_sem);\r\nif (ret < 0)\r\ngoto out;\r\npos = 0;\r\nparent_ino = le32_to_cpu(((struct ext4_dir_entry_2 *)dir_buf)->inode);\r\nwhile (pos < inline_size) {\r\nif (pos == 0) {\r\nfake.inode = cpu_to_le32(inode->i_ino);\r\nfake.name_len = 1;\r\nstrcpy(fake.name, ".");\r\nfake.rec_len = ext4_rec_len_to_disk(\r\nEXT4_DIR_REC_LEN(fake.name_len),\r\ninline_size);\r\next4_set_de_type(inode->i_sb, &fake, S_IFDIR);\r\nde = &fake;\r\npos = EXT4_INLINE_DOTDOT_OFFSET;\r\n} else if (pos == EXT4_INLINE_DOTDOT_OFFSET) {\r\nfake.inode = cpu_to_le32(parent_ino);\r\nfake.name_len = 2;\r\nstrcpy(fake.name, "..");\r\nfake.rec_len = ext4_rec_len_to_disk(\r\nEXT4_DIR_REC_LEN(fake.name_len),\r\ninline_size);\r\next4_set_de_type(inode->i_sb, &fake, S_IFDIR);\r\nde = &fake;\r\npos = EXT4_INLINE_DOTDOT_SIZE;\r\n} else {\r\nde = (struct ext4_dir_entry_2 *)(dir_buf + pos);\r\npos += ext4_rec_len_from_disk(de->rec_len, inline_size);\r\nif (ext4_check_dir_entry(inode, dir_file, de,\r\niloc.bh, dir_buf,\r\ninline_size, pos)) {\r\nret = count;\r\ngoto out;\r\n}\r\n}\r\next4fs_dirhash(de->name, de->name_len, hinfo);\r\nif ((hinfo->hash < start_hash) ||\r\n((hinfo->hash == start_hash) &&\r\n(hinfo->minor_hash < start_minor_hash)))\r\ncontinue;\r\nif (de->inode == 0)\r\ncontinue;\r\ntmp_str.name = de->name;\r\ntmp_str.len = de->name_len;\r\nerr = ext4_htree_store_dirent(dir_file, hinfo->hash,\r\nhinfo->minor_hash, de, &tmp_str);\r\nif (err) {\r\ncount = err;\r\ngoto out;\r\n}\r\ncount++;\r\n}\r\nret = count;\r\nout:\r\nkfree(dir_buf);\r\nbrelse(iloc.bh);\r\nreturn ret;\r\n}\r\nint ext4_read_inline_dir(struct file *file,\r\nstruct dir_context *ctx,\r\nint *has_inline_data)\r\n{\r\nunsigned int offset, parent_ino;\r\nint i;\r\nstruct ext4_dir_entry_2 *de;\r\nstruct super_block *sb;\r\nstruct inode *inode = file_inode(file);\r\nint ret, inline_size = 0;\r\nstruct ext4_iloc iloc;\r\nvoid *dir_buf = NULL;\r\nint dotdot_offset, dotdot_size, extra_offset, extra_size;\r\nret = ext4_get_inode_loc(inode, &iloc);\r\nif (ret)\r\nreturn ret;\r\ndown_read(&EXT4_I(inode)->xattr_sem);\r\nif (!ext4_has_inline_data(inode)) {\r\nup_read(&EXT4_I(inode)->xattr_sem);\r\n*has_inline_data = 0;\r\ngoto out;\r\n}\r\ninline_size = ext4_get_inline_size(inode);\r\ndir_buf = kmalloc(inline_size, GFP_NOFS);\r\nif (!dir_buf) {\r\nret = -ENOMEM;\r\nup_read(&EXT4_I(inode)->xattr_sem);\r\ngoto out;\r\n}\r\nret = ext4_read_inline_data(inode, dir_buf, inline_size, &iloc);\r\nup_read(&EXT4_I(inode)->xattr_sem);\r\nif (ret < 0)\r\ngoto out;\r\nret = 0;\r\nsb = inode->i_sb;\r\nparent_ino = le32_to_cpu(((struct ext4_dir_entry_2 *)dir_buf)->inode);\r\noffset = ctx->pos;\r\ndotdot_offset = EXT4_DIR_REC_LEN(1);\r\ndotdot_size = dotdot_offset + EXT4_DIR_REC_LEN(2);\r\nextra_offset = dotdot_size - EXT4_INLINE_DOTDOT_SIZE;\r\nextra_size = extra_offset + inline_size;\r\nif (file->f_version != inode->i_version) {\r\nfor (i = 0; i < extra_size && i < offset;) {\r\nif (!i) {\r\ni = dotdot_offset;\r\ncontinue;\r\n} else if (i == dotdot_offset) {\r\ni = dotdot_size;\r\ncontinue;\r\n}\r\nde = (struct ext4_dir_entry_2 *)\r\n(dir_buf + i - extra_offset);\r\nif (ext4_rec_len_from_disk(de->rec_len, extra_size)\r\n< EXT4_DIR_REC_LEN(1))\r\nbreak;\r\ni += ext4_rec_len_from_disk(de->rec_len,\r\nextra_size);\r\n}\r\noffset = i;\r\nctx->pos = offset;\r\nfile->f_version = inode->i_version;\r\n}\r\nwhile (ctx->pos < extra_size) {\r\nif (ctx->pos == 0) {\r\nif (!dir_emit(ctx, ".", 1, inode->i_ino, DT_DIR))\r\ngoto out;\r\nctx->pos = dotdot_offset;\r\ncontinue;\r\n}\r\nif (ctx->pos == dotdot_offset) {\r\nif (!dir_emit(ctx, "..", 2, parent_ino, DT_DIR))\r\ngoto out;\r\nctx->pos = dotdot_size;\r\ncontinue;\r\n}\r\nde = (struct ext4_dir_entry_2 *)\r\n(dir_buf + ctx->pos - extra_offset);\r\nif (ext4_check_dir_entry(inode, file, de, iloc.bh, dir_buf,\r\nextra_size, ctx->pos))\r\ngoto out;\r\nif (le32_to_cpu(de->inode)) {\r\nif (!dir_emit(ctx, de->name, de->name_len,\r\nle32_to_cpu(de->inode),\r\nget_dtype(sb, de->file_type)))\r\ngoto out;\r\n}\r\nctx->pos += ext4_rec_len_from_disk(de->rec_len, extra_size);\r\n}\r\nout:\r\nkfree(dir_buf);\r\nbrelse(iloc.bh);\r\nreturn ret;\r\n}\r\nstruct buffer_head *ext4_get_first_inline_block(struct inode *inode,\r\nstruct ext4_dir_entry_2 **parent_de,\r\nint *retval)\r\n{\r\nstruct ext4_iloc iloc;\r\n*retval = ext4_get_inode_loc(inode, &iloc);\r\nif (*retval)\r\nreturn NULL;\r\n*parent_de = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\r\nreturn iloc.bh;\r\n}\r\nint ext4_try_create_inline_dir(handle_t *handle, struct inode *parent,\r\nstruct inode *inode)\r\n{\r\nint ret, inline_size = EXT4_MIN_INLINE_DATA_SIZE;\r\nstruct ext4_iloc iloc;\r\nstruct ext4_dir_entry_2 *de;\r\nret = ext4_get_inode_loc(inode, &iloc);\r\nif (ret)\r\nreturn ret;\r\nret = ext4_prepare_inline_data(handle, inode, inline_size);\r\nif (ret)\r\ngoto out;\r\nde = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\r\nde->inode = cpu_to_le32(parent->i_ino);\r\nde = (struct ext4_dir_entry_2 *)((void *)de + EXT4_INLINE_DOTDOT_SIZE);\r\nde->inode = 0;\r\nde->rec_len = ext4_rec_len_to_disk(\r\ninline_size - EXT4_INLINE_DOTDOT_SIZE,\r\ninline_size);\r\nset_nlink(inode, 2);\r\ninode->i_size = EXT4_I(inode)->i_disksize = inline_size;\r\nout:\r\nbrelse(iloc.bh);\r\nreturn ret;\r\n}\r\nstruct buffer_head *ext4_find_inline_entry(struct inode *dir,\r\nstruct ext4_filename *fname,\r\nstruct ext4_dir_entry_2 **res_dir,\r\nint *has_inline_data)\r\n{\r\nint ret;\r\nstruct ext4_iloc iloc;\r\nvoid *inline_start;\r\nint inline_size;\r\nif (ext4_get_inode_loc(dir, &iloc))\r\nreturn NULL;\r\ndown_read(&EXT4_I(dir)->xattr_sem);\r\nif (!ext4_has_inline_data(dir)) {\r\n*has_inline_data = 0;\r\ngoto out;\r\n}\r\ninline_start = (void *)ext4_raw_inode(&iloc)->i_block +\r\nEXT4_INLINE_DOTDOT_SIZE;\r\ninline_size = EXT4_MIN_INLINE_DATA_SIZE - EXT4_INLINE_DOTDOT_SIZE;\r\nret = ext4_search_dir(iloc.bh, inline_start, inline_size,\r\ndir, fname, 0, res_dir);\r\nif (ret == 1)\r\ngoto out_find;\r\nif (ret < 0)\r\ngoto out;\r\nif (ext4_get_inline_size(dir) == EXT4_MIN_INLINE_DATA_SIZE)\r\ngoto out;\r\ninline_start = ext4_get_inline_xattr_pos(dir, &iloc);\r\ninline_size = ext4_get_inline_size(dir) - EXT4_MIN_INLINE_DATA_SIZE;\r\nret = ext4_search_dir(iloc.bh, inline_start, inline_size,\r\ndir, fname, 0, res_dir);\r\nif (ret == 1)\r\ngoto out_find;\r\nout:\r\nbrelse(iloc.bh);\r\niloc.bh = NULL;\r\nout_find:\r\nup_read(&EXT4_I(dir)->xattr_sem);\r\nreturn iloc.bh;\r\n}\r\nint ext4_delete_inline_entry(handle_t *handle,\r\nstruct inode *dir,\r\nstruct ext4_dir_entry_2 *de_del,\r\nstruct buffer_head *bh,\r\nint *has_inline_data)\r\n{\r\nint err, inline_size, no_expand;\r\nstruct ext4_iloc iloc;\r\nvoid *inline_start;\r\nerr = ext4_get_inode_loc(dir, &iloc);\r\nif (err)\r\nreturn err;\r\next4_write_lock_xattr(dir, &no_expand);\r\nif (!ext4_has_inline_data(dir)) {\r\n*has_inline_data = 0;\r\ngoto out;\r\n}\r\nif ((void *)de_del - ((void *)ext4_raw_inode(&iloc)->i_block) <\r\nEXT4_MIN_INLINE_DATA_SIZE) {\r\ninline_start = (void *)ext4_raw_inode(&iloc)->i_block +\r\nEXT4_INLINE_DOTDOT_SIZE;\r\ninline_size = EXT4_MIN_INLINE_DATA_SIZE -\r\nEXT4_INLINE_DOTDOT_SIZE;\r\n} else {\r\ninline_start = ext4_get_inline_xattr_pos(dir, &iloc);\r\ninline_size = ext4_get_inline_size(dir) -\r\nEXT4_MIN_INLINE_DATA_SIZE;\r\n}\r\nBUFFER_TRACE(bh, "get_write_access");\r\nerr = ext4_journal_get_write_access(handle, bh);\r\nif (err)\r\ngoto out;\r\nerr = ext4_generic_delete_entry(handle, dir, de_del, bh,\r\ninline_start, inline_size, 0);\r\nif (err)\r\ngoto out;\r\next4_show_inline_dir(dir, iloc.bh, inline_start, inline_size);\r\nout:\r\next4_write_unlock_xattr(dir, &no_expand);\r\nif (likely(err == 0))\r\nerr = ext4_mark_inode_dirty(handle, dir);\r\nbrelse(iloc.bh);\r\nif (err != -ENOENT)\r\next4_std_error(dir->i_sb, err);\r\nreturn err;\r\n}\r\nstatic inline struct ext4_dir_entry_2 *\r\next4_get_inline_entry(struct inode *inode,\r\nstruct ext4_iloc *iloc,\r\nunsigned int offset,\r\nvoid **inline_start,\r\nint *inline_size)\r\n{\r\nvoid *inline_pos;\r\nBUG_ON(offset > ext4_get_inline_size(inode));\r\nif (offset < EXT4_MIN_INLINE_DATA_SIZE) {\r\ninline_pos = (void *)ext4_raw_inode(iloc)->i_block;\r\n*inline_size = EXT4_MIN_INLINE_DATA_SIZE;\r\n} else {\r\ninline_pos = ext4_get_inline_xattr_pos(inode, iloc);\r\noffset -= EXT4_MIN_INLINE_DATA_SIZE;\r\n*inline_size = ext4_get_inline_size(inode) -\r\nEXT4_MIN_INLINE_DATA_SIZE;\r\n}\r\nif (inline_start)\r\n*inline_start = inline_pos;\r\nreturn (struct ext4_dir_entry_2 *)(inline_pos + offset);\r\n}\r\nbool empty_inline_dir(struct inode *dir, int *has_inline_data)\r\n{\r\nint err, inline_size;\r\nstruct ext4_iloc iloc;\r\nvoid *inline_pos;\r\nunsigned int offset;\r\nstruct ext4_dir_entry_2 *de;\r\nbool ret = true;\r\nerr = ext4_get_inode_loc(dir, &iloc);\r\nif (err) {\r\nEXT4_ERROR_INODE(dir, "error %d getting inode %lu block",\r\nerr, dir->i_ino);\r\nreturn true;\r\n}\r\ndown_read(&EXT4_I(dir)->xattr_sem);\r\nif (!ext4_has_inline_data(dir)) {\r\n*has_inline_data = 0;\r\ngoto out;\r\n}\r\nde = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\r\nif (!le32_to_cpu(de->inode)) {\r\next4_warning(dir->i_sb,\r\n"bad inline directory (dir #%lu) - no `..'",\r\ndir->i_ino);\r\nret = true;\r\ngoto out;\r\n}\r\noffset = EXT4_INLINE_DOTDOT_SIZE;\r\nwhile (offset < dir->i_size) {\r\nde = ext4_get_inline_entry(dir, &iloc, offset,\r\n&inline_pos, &inline_size);\r\nif (ext4_check_dir_entry(dir, NULL, de,\r\niloc.bh, inline_pos,\r\ninline_size, offset)) {\r\next4_warning(dir->i_sb,\r\n"bad inline directory (dir #%lu) - "\r\n"inode %u, rec_len %u, name_len %d"\r\n"inline size %d",\r\ndir->i_ino, le32_to_cpu(de->inode),\r\nle16_to_cpu(de->rec_len), de->name_len,\r\ninline_size);\r\nret = true;\r\ngoto out;\r\n}\r\nif (le32_to_cpu(de->inode)) {\r\nret = false;\r\ngoto out;\r\n}\r\noffset += ext4_rec_len_from_disk(de->rec_len, inline_size);\r\n}\r\nout:\r\nup_read(&EXT4_I(dir)->xattr_sem);\r\nbrelse(iloc.bh);\r\nreturn ret;\r\n}\r\nint ext4_destroy_inline_data(handle_t *handle, struct inode *inode)\r\n{\r\nint ret, no_expand;\r\next4_write_lock_xattr(inode, &no_expand);\r\nret = ext4_destroy_inline_data_nolock(handle, inode);\r\next4_write_unlock_xattr(inode, &no_expand);\r\nreturn ret;\r\n}\r\nint ext4_inline_data_fiemap(struct inode *inode,\r\nstruct fiemap_extent_info *fieinfo,\r\nint *has_inline, __u64 start, __u64 len)\r\n{\r\n__u64 physical = 0;\r\n__u64 inline_len;\r\n__u32 flags = FIEMAP_EXTENT_DATA_INLINE | FIEMAP_EXTENT_NOT_ALIGNED |\r\nFIEMAP_EXTENT_LAST;\r\nint error = 0;\r\nstruct ext4_iloc iloc;\r\ndown_read(&EXT4_I(inode)->xattr_sem);\r\nif (!ext4_has_inline_data(inode)) {\r\n*has_inline = 0;\r\ngoto out;\r\n}\r\ninline_len = min_t(size_t, ext4_get_inline_size(inode),\r\ni_size_read(inode));\r\nif (start >= inline_len)\r\ngoto out;\r\nif (start + len < inline_len)\r\ninline_len = start + len;\r\ninline_len -= start;\r\nerror = ext4_get_inode_loc(inode, &iloc);\r\nif (error)\r\ngoto out;\r\nphysical = (__u64)iloc.bh->b_blocknr << inode->i_sb->s_blocksize_bits;\r\nphysical += (char *)ext4_raw_inode(&iloc) - iloc.bh->b_data;\r\nphysical += offsetof(struct ext4_inode, i_block);\r\nif (physical)\r\nerror = fiemap_fill_next_extent(fieinfo, start, physical,\r\ninline_len, flags);\r\nbrelse(iloc.bh);\r\nout:\r\nup_read(&EXT4_I(inode)->xattr_sem);\r\nreturn (error < 0 ? error : 0);\r\n}\r\nint ext4_try_to_evict_inline_data(handle_t *handle,\r\nstruct inode *inode,\r\nint needed)\r\n{\r\nint error;\r\nstruct ext4_xattr_entry *entry;\r\nstruct ext4_inode *raw_inode;\r\nstruct ext4_iloc iloc;\r\nerror = ext4_get_inode_loc(inode, &iloc);\r\nif (error)\r\nreturn error;\r\nraw_inode = ext4_raw_inode(&iloc);\r\nentry = (struct ext4_xattr_entry *)((void *)raw_inode +\r\nEXT4_I(inode)->i_inline_off);\r\nif (EXT4_XATTR_LEN(entry->e_name_len) +\r\nEXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size)) < needed) {\r\nerror = -ENOSPC;\r\ngoto out;\r\n}\r\nerror = ext4_convert_inline_data_nolock(handle, inode, &iloc);\r\nout:\r\nbrelse(iloc.bh);\r\nreturn error;\r\n}\r\nint ext4_inline_data_truncate(struct inode *inode, int *has_inline)\r\n{\r\nhandle_t *handle;\r\nint inline_size, value_len, needed_blocks, no_expand, err = 0;\r\nsize_t i_size;\r\nvoid *value = NULL;\r\nstruct ext4_xattr_ibody_find is = {\r\n.s = { .not_found = -ENODATA, },\r\n};\r\nstruct ext4_xattr_info i = {\r\n.name_index = EXT4_XATTR_INDEX_SYSTEM,\r\n.name = EXT4_XATTR_SYSTEM_DATA,\r\n};\r\nneeded_blocks = ext4_writepage_trans_blocks(inode);\r\nhandle = ext4_journal_start(inode, EXT4_HT_INODE, needed_blocks);\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\next4_write_lock_xattr(inode, &no_expand);\r\nif (!ext4_has_inline_data(inode)) {\r\n*has_inline = 0;\r\next4_journal_stop(handle);\r\nreturn 0;\r\n}\r\nif ((err = ext4_orphan_add(handle, inode)) != 0)\r\ngoto out;\r\nif ((err = ext4_get_inode_loc(inode, &is.iloc)) != 0)\r\ngoto out;\r\ndown_write(&EXT4_I(inode)->i_data_sem);\r\ni_size = inode->i_size;\r\ninline_size = ext4_get_inline_size(inode);\r\nEXT4_I(inode)->i_disksize = i_size;\r\nif (i_size < inline_size) {\r\nif (inline_size > EXT4_MIN_INLINE_DATA_SIZE) {\r\nif ((err = ext4_xattr_ibody_find(inode, &i, &is)) != 0)\r\ngoto out_error;\r\nBUG_ON(is.s.not_found);\r\nvalue_len = le32_to_cpu(is.s.here->e_value_size);\r\nvalue = kmalloc(value_len, GFP_NOFS);\r\nif (!value) {\r\nerr = -ENOMEM;\r\ngoto out_error;\r\n}\r\nerr = ext4_xattr_ibody_get(inode, i.name_index,\r\ni.name, value, value_len);\r\nif (err <= 0)\r\ngoto out_error;\r\ni.value = value;\r\ni.value_len = i_size > EXT4_MIN_INLINE_DATA_SIZE ?\r\ni_size - EXT4_MIN_INLINE_DATA_SIZE : 0;\r\nerr = ext4_xattr_ibody_inline_set(handle, inode,\r\n&i, &is);\r\nif (err)\r\ngoto out_error;\r\n}\r\nif (i_size < EXT4_MIN_INLINE_DATA_SIZE) {\r\nvoid *p = (void *) ext4_raw_inode(&is.iloc)->i_block;\r\nmemset(p + i_size, 0,\r\nEXT4_MIN_INLINE_DATA_SIZE - i_size);\r\n}\r\nEXT4_I(inode)->i_inline_size = i_size <\r\nEXT4_MIN_INLINE_DATA_SIZE ?\r\nEXT4_MIN_INLINE_DATA_SIZE : i_size;\r\n}\r\nout_error:\r\nup_write(&EXT4_I(inode)->i_data_sem);\r\nout:\r\nbrelse(is.iloc.bh);\r\next4_write_unlock_xattr(inode, &no_expand);\r\nkfree(value);\r\nif (inode->i_nlink)\r\next4_orphan_del(handle, inode);\r\nif (err == 0) {\r\ninode->i_mtime = inode->i_ctime = current_time(inode);\r\nerr = ext4_mark_inode_dirty(handle, inode);\r\nif (IS_SYNC(inode))\r\next4_handle_sync(handle);\r\n}\r\next4_journal_stop(handle);\r\nreturn err;\r\n}\r\nint ext4_convert_inline_data(struct inode *inode)\r\n{\r\nint error, needed_blocks, no_expand;\r\nhandle_t *handle;\r\nstruct ext4_iloc iloc;\r\nif (!ext4_has_inline_data(inode)) {\r\next4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\r\nreturn 0;\r\n}\r\nneeded_blocks = ext4_writepage_trans_blocks(inode);\r\niloc.bh = NULL;\r\nerror = ext4_get_inode_loc(inode, &iloc);\r\nif (error)\r\nreturn error;\r\nhandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\r\nif (IS_ERR(handle)) {\r\nerror = PTR_ERR(handle);\r\ngoto out_free;\r\n}\r\next4_write_lock_xattr(inode, &no_expand);\r\nif (ext4_has_inline_data(inode))\r\nerror = ext4_convert_inline_data_nolock(handle, inode, &iloc);\r\next4_write_unlock_xattr(inode, &no_expand);\r\next4_journal_stop(handle);\r\nout_free:\r\nbrelse(iloc.bh);\r\nreturn error;\r\n}
