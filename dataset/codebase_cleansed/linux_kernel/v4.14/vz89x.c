static bool vz89x_measurement_is_valid(struct vz89x_data *data)\r\n{\r\nif (data->buffer[VZ89X_VOC_SHORT_IDX] == 0)\r\nreturn true;\r\nreturn !!(data->buffer[data->chip->read_size - 1] > 0);\r\n}\r\nstatic bool vz89te_measurement_is_valid(struct vz89x_data *data)\r\n{\r\nu8 crc = 0;\r\nint i, sum = 0;\r\nfor (i = 0; i < (data->chip->read_size - 1); i++) {\r\nsum = crc + data->buffer[i];\r\ncrc = sum;\r\ncrc += sum / 256;\r\n}\r\nreturn !((0xff - crc) == data->buffer[data->chip->read_size - 1]);\r\n}\r\nstatic int vz89x_i2c_xfer(struct vz89x_data *data, u8 cmd)\r\n{\r\nconst struct vz89x_chip_data *chip = data->chip;\r\nstruct i2c_client *client = data->client;\r\nstruct i2c_msg msg[2];\r\nint ret;\r\nu8 buf[6] = { cmd, 0, 0, 0, 0, 0xf3 };\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = client->flags;\r\nmsg[0].len = chip->write_size;\r\nmsg[0].buf = (char *) &buf;\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = client->flags | I2C_M_RD;\r\nmsg[1].len = chip->read_size;\r\nmsg[1].buf = (char *) &data->buffer;\r\nret = i2c_transfer(client->adapter, msg, 2);\r\nreturn (ret == 2) ? 0 : ret;\r\n}\r\nstatic int vz89x_smbus_xfer(struct vz89x_data *data, u8 cmd)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nint i;\r\nret = i2c_smbus_write_word_data(client, cmd, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < data->chip->read_size; i++) {\r\nret = i2c_smbus_read_byte(client);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->buffer[i] = ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vz89x_get_measurement(struct vz89x_data *data)\r\n{\r\nconst struct vz89x_chip_data *chip = data->chip;\r\nint ret;\r\nif (!time_after(jiffies, data->last_update + HZ))\r\nreturn data->is_valid ? 0 : -EAGAIN;\r\ndata->is_valid = false;\r\ndata->last_update = jiffies;\r\nret = data->xfer(data, chip->cmd);\r\nif (ret < 0)\r\nreturn ret;\r\nret = chip->valid(data);\r\nif (ret)\r\nreturn -EAGAIN;\r\ndata->is_valid = true;\r\nreturn 0;\r\n}\r\nstatic int vz89x_get_resistance_reading(struct vz89x_data *data,\r\nstruct iio_chan_spec const *chan,\r\nint *val)\r\n{\r\nu8 *tmp = (u8 *) &data->buffer[chan->address];\r\nswitch (chan->scan_type.endianness) {\r\ncase IIO_LE:\r\n*val = le32_to_cpup((__le32 *) tmp) & GENMASK(23, 0);\r\nbreak;\r\ncase IIO_BE:\r\n*val = be32_to_cpup((__be32 *) tmp) >> 8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vz89x_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val,\r\nint *val2, long mask)\r\n{\r\nstruct vz89x_data *data = iio_priv(indio_dev);\r\nint ret = -EINVAL;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&data->lock);\r\nret = vz89x_get_measurement(data);\r\nmutex_unlock(&data->lock);\r\nif (ret)\r\nreturn ret;\r\nswitch (chan->type) {\r\ncase IIO_CONCENTRATION:\r\n*val = data->buffer[chan->address];\r\nreturn IIO_VAL_INT;\r\ncase IIO_RESISTANCE:\r\nret = vz89x_get_resistance_reading(data, chan, val);\r\nif (!ret)\r\nreturn IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_RESISTANCE:\r\n*val = 10;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_OFFSET:\r\nswitch (chan->channel2) {\r\ncase IIO_MOD_CO2:\r\n*val = 44;\r\n*val2 = 250000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_MOD_VOC:\r\n*val = -13;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int vz89x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct vz89x_data *data;\r\nconst struct of_device_id *of_id;\r\nint chip_id;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\ndata->xfer = vz89x_i2c_xfer;\r\nelse if (i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_BYTE))\r\ndata->xfer = vz89x_smbus_xfer;\r\nelse\r\nreturn -EOPNOTSUPP;\r\nof_id = of_match_device(vz89x_dt_ids, &client->dev);\r\nif (!of_id)\r\nchip_id = id->driver_data;\r\nelse\r\nchip_id = (unsigned long)of_id->data;\r\ni2c_set_clientdata(client, indio_dev);\r\ndata->client = client;\r\ndata->chip = &vz89x_chips[chip_id];\r\ndata->last_update = jiffies - HZ;\r\nmutex_init(&data->lock);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->info = &vz89x_info;\r\nindio_dev->name = dev_name(&client->dev);\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = data->chip->channels;\r\nindio_dev->num_channels = data->chip->num_channels;\r\nreturn devm_iio_device_register(&client->dev, indio_dev);\r\n}
