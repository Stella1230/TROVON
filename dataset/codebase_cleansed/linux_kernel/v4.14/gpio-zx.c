static int zx_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct zx_gpio *chip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nu16 gpiodir;\r\nif (offset >= gc->ngpio)\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\ngpiodir = readw_relaxed(chip->base + ZX_GPIO_DIR);\r\ngpiodir &= ~BIT(offset);\r\nwritew_relaxed(gpiodir, chip->base + ZX_GPIO_DIR);\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int zx_direction_output(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nstruct zx_gpio *chip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nu16 gpiodir;\r\nif (offset >= gc->ngpio)\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\ngpiodir = readw_relaxed(chip->base + ZX_GPIO_DIR);\r\ngpiodir |= BIT(offset);\r\nwritew_relaxed(gpiodir, chip->base + ZX_GPIO_DIR);\r\nif (value)\r\nwritew_relaxed(BIT(offset), chip->base + ZX_GPIO_DO1);\r\nelse\r\nwritew_relaxed(BIT(offset), chip->base + ZX_GPIO_DO0);\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int zx_get_value(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct zx_gpio *chip = gpiochip_get_data(gc);\r\nreturn !!(readw_relaxed(chip->base + ZX_GPIO_DI) & BIT(offset));\r\n}\r\nstatic void zx_set_value(struct gpio_chip *gc, unsigned offset, int value)\r\n{\r\nstruct zx_gpio *chip = gpiochip_get_data(gc);\r\nif (value)\r\nwritew_relaxed(BIT(offset), chip->base + ZX_GPIO_DO1);\r\nelse\r\nwritew_relaxed(BIT(offset), chip->base + ZX_GPIO_DO0);\r\n}\r\nstatic int zx_irq_type(struct irq_data *d, unsigned trigger)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct zx_gpio *chip = gpiochip_get_data(gc);\r\nint offset = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nu16 gpiois, gpioi_epos, gpioi_eneg, gpioiev;\r\nu16 bit = BIT(offset);\r\nif (offset < 0 || offset >= ZX_GPIO_NR)\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\ngpioiev = readw_relaxed(chip->base + ZX_GPIO_IV);\r\ngpiois = readw_relaxed(chip->base + ZX_GPIO_IVE);\r\ngpioi_epos = readw_relaxed(chip->base + ZX_GPIO_IEP);\r\ngpioi_eneg = readw_relaxed(chip->base + ZX_GPIO_IEN);\r\nif (trigger & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {\r\ngpiois |= bit;\r\nif (trigger & IRQ_TYPE_LEVEL_HIGH)\r\ngpioiev |= bit;\r\nelse\r\ngpioiev &= ~bit;\r\n} else\r\ngpiois &= ~bit;\r\nif ((trigger & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {\r\ngpioi_epos |= bit;\r\ngpioi_eneg |= bit;\r\n} else {\r\nif (trigger & IRQ_TYPE_EDGE_RISING) {\r\ngpioi_epos |= bit;\r\ngpioi_eneg &= ~bit;\r\n} else if (trigger & IRQ_TYPE_EDGE_FALLING) {\r\ngpioi_eneg |= bit;\r\ngpioi_epos &= ~bit;\r\n}\r\n}\r\nwritew_relaxed(gpiois, chip->base + ZX_GPIO_IVE);\r\nwritew_relaxed(gpioi_epos, chip->base + ZX_GPIO_IEP);\r\nwritew_relaxed(gpioi_eneg, chip->base + ZX_GPIO_IEN);\r\nwritew_relaxed(gpioiev, chip->base + ZX_GPIO_IV);\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void zx_irq_handler(struct irq_desc *desc)\r\n{\r\nunsigned long pending;\r\nint offset;\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nstruct zx_gpio *chip = gpiochip_get_data(gc);\r\nstruct irq_chip *irqchip = irq_desc_get_chip(desc);\r\nchained_irq_enter(irqchip, desc);\r\npending = readw_relaxed(chip->base + ZX_GPIO_MIS);\r\nwritew_relaxed(pending, chip->base + ZX_GPIO_IC);\r\nif (pending) {\r\nfor_each_set_bit(offset, &pending, ZX_GPIO_NR)\r\ngeneric_handle_irq(irq_find_mapping(gc->irqdomain,\r\noffset));\r\n}\r\nchained_irq_exit(irqchip, desc);\r\n}\r\nstatic void zx_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct zx_gpio *chip = gpiochip_get_data(gc);\r\nu16 mask = BIT(irqd_to_hwirq(d) % ZX_GPIO_NR);\r\nu16 gpioie;\r\nraw_spin_lock(&chip->lock);\r\ngpioie = readw_relaxed(chip->base + ZX_GPIO_IM) | mask;\r\nwritew_relaxed(gpioie, chip->base + ZX_GPIO_IM);\r\ngpioie = readw_relaxed(chip->base + ZX_GPIO_IE) & ~mask;\r\nwritew_relaxed(gpioie, chip->base + ZX_GPIO_IE);\r\nraw_spin_unlock(&chip->lock);\r\n}\r\nstatic void zx_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct zx_gpio *chip = gpiochip_get_data(gc);\r\nu16 mask = BIT(irqd_to_hwirq(d) % ZX_GPIO_NR);\r\nu16 gpioie;\r\nraw_spin_lock(&chip->lock);\r\ngpioie = readw_relaxed(chip->base + ZX_GPIO_IM) & ~mask;\r\nwritew_relaxed(gpioie, chip->base + ZX_GPIO_IM);\r\ngpioie = readw_relaxed(chip->base + ZX_GPIO_IE) | mask;\r\nwritew_relaxed(gpioie, chip->base + ZX_GPIO_IE);\r\nraw_spin_unlock(&chip->lock);\r\n}\r\nstatic int zx_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct zx_gpio *chip;\r\nstruct resource *res;\r\nint irq, id, ret;\r\nchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nchip->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(chip->base))\r\nreturn PTR_ERR(chip->base);\r\nraw_spin_lock_init(&chip->lock);\r\nif (of_property_read_bool(dev->of_node, "gpio-ranges")) {\r\nchip->gc.request = gpiochip_generic_request;\r\nchip->gc.free = gpiochip_generic_free;\r\n}\r\nid = of_alias_get_id(dev->of_node, "gpio");\r\nchip->gc.direction_input = zx_direction_input;\r\nchip->gc.direction_output = zx_direction_output;\r\nchip->gc.get = zx_get_value;\r\nchip->gc.set = zx_set_value;\r\nchip->gc.base = ZX_GPIO_NR * id;\r\nchip->gc.ngpio = ZX_GPIO_NR;\r\nchip->gc.label = dev_name(dev);\r\nchip->gc.parent = dev;\r\nchip->gc.owner = THIS_MODULE;\r\nret = gpiochip_add_data(&chip->gc, chip);\r\nif (ret)\r\nreturn ret;\r\nwritew_relaxed(0xffff, chip->base + ZX_GPIO_IM);\r\nwritew_relaxed(0, chip->base + ZX_GPIO_IE);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "invalid IRQ\n");\r\ngpiochip_remove(&chip->gc);\r\nreturn -ENODEV;\r\n}\r\nret = gpiochip_irqchip_add(&chip->gc, &zx_irqchip,\r\n0, handle_simple_irq,\r\nIRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(dev, "could not add irqchip\n");\r\ngpiochip_remove(&chip->gc);\r\nreturn ret;\r\n}\r\ngpiochip_set_chained_irqchip(&chip->gc, &zx_irqchip,\r\nirq, zx_irq_handler);\r\nplatform_set_drvdata(pdev, chip);\r\ndev_info(dev, "ZX GPIO chip registered\n");\r\nreturn 0;\r\n}
