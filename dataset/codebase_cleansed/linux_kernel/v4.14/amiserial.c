static inline int serial_paranoia_check(struct serial_state *info,\r\nchar *name, const char *routine)\r\n{\r\n#ifdef SERIAL_PARANOIA_CHECK\r\nstatic const char *badmagic =\r\n"Warning: bad magic number for serial struct (%s) in %s\n";\r\nstatic const char *badinfo =\r\n"Warning: null async_struct for (%s) in %s\n";\r\nif (!info) {\r\nprintk(badinfo, name, routine);\r\nreturn 1;\r\n}\r\nif (info->magic != SERIAL_MAGIC) {\r\nprintk(badmagic, name, routine);\r\nreturn 1;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic __inline__ void rtsdtr_ctrl(int bits)\r\n{\r\nciab.pra = ((bits & (SER_RTS | SER_DTR)) ^ (SER_RTS | SER_DTR)) | (ciab.pra & ~(SER_RTS | SER_DTR));\r\n}\r\nstatic void rs_stop(struct tty_struct *tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_stop"))\r\nreturn;\r\nlocal_irq_save(flags);\r\nif (info->IER & UART_IER_THRI) {\r\ninfo->IER &= ~UART_IER_THRI;\r\ncustom.intena = IF_TBE;\r\nmb();\r\ncustom.intreq = IF_TBE;\r\nmb();\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void rs_start(struct tty_struct *tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_start"))\r\nreturn;\r\nlocal_irq_save(flags);\r\nif (info->xmit.head != info->xmit.tail\r\n&& info->xmit.buf\r\n&& !(info->IER & UART_IER_THRI)) {\r\ninfo->IER |= UART_IER_THRI;\r\ncustom.intena = IF_SETCLR | IF_TBE;\r\nmb();\r\ncustom.intreq = IF_SETCLR | IF_TBE;\r\nmb();\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void receive_chars(struct serial_state *info)\r\n{\r\nint status;\r\nint serdatr;\r\nunsigned char ch, flag;\r\nstruct async_icount *icount;\r\nint oe = 0;\r\nicount = &info->icount;\r\nstatus = UART_LSR_DR;\r\nserdatr = custom.serdatr;\r\nmb();\r\ncustom.intreq = IF_RBF;\r\nmb();\r\nif((serdatr & 0x1ff) == 0)\r\nstatus |= UART_LSR_BI;\r\nif(serdatr & SDR_OVRUN)\r\nstatus |= UART_LSR_OE;\r\nch = serdatr & 0xff;\r\nicount->rx++;\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("DR%02x:%02x...", ch, status);\r\n#endif\r\nflag = TTY_NORMAL;\r\nif (status & (UART_LSR_BI | UART_LSR_PE |\r\nUART_LSR_FE | UART_LSR_OE)) {\r\nif (status & UART_LSR_BI) {\r\nstatus &= ~(UART_LSR_FE | UART_LSR_PE);\r\nicount->brk++;\r\n} else if (status & UART_LSR_PE)\r\nicount->parity++;\r\nelse if (status & UART_LSR_FE)\r\nicount->frame++;\r\nif (status & UART_LSR_OE)\r\nicount->overrun++;\r\nif (status & info->ignore_status_mask)\r\ngoto out;\r\nstatus &= info->read_status_mask;\r\nif (status & (UART_LSR_BI)) {\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("handling break....");\r\n#endif\r\nflag = TTY_BREAK;\r\nif (info->tport.flags & ASYNC_SAK)\r\ndo_SAK(info->tport.tty);\r\n} else if (status & UART_LSR_PE)\r\nflag = TTY_PARITY;\r\nelse if (status & UART_LSR_FE)\r\nflag = TTY_FRAME;\r\nif (status & UART_LSR_OE) {\r\noe = 1;\r\n}\r\n}\r\ntty_insert_flip_char(&info->tport, ch, flag);\r\nif (oe == 1)\r\ntty_insert_flip_char(&info->tport, 0, TTY_OVERRUN);\r\ntty_flip_buffer_push(&info->tport);\r\nout:\r\nreturn;\r\n}\r\nstatic void transmit_chars(struct serial_state *info)\r\n{\r\ncustom.intreq = IF_TBE;\r\nmb();\r\nif (info->x_char) {\r\ncustom.serdat = info->x_char | 0x100;\r\nmb();\r\ninfo->icount.tx++;\r\ninfo->x_char = 0;\r\nreturn;\r\n}\r\nif (info->xmit.head == info->xmit.tail\r\n|| info->tport.tty->stopped\r\n|| info->tport.tty->hw_stopped) {\r\ninfo->IER &= ~UART_IER_THRI;\r\ncustom.intena = IF_TBE;\r\nmb();\r\nreturn;\r\n}\r\ncustom.serdat = info->xmit.buf[info->xmit.tail++] | 0x100;\r\nmb();\r\ninfo->xmit.tail = info->xmit.tail & (SERIAL_XMIT_SIZE-1);\r\ninfo->icount.tx++;\r\nif (CIRC_CNT(info->xmit.head,\r\ninfo->xmit.tail,\r\nSERIAL_XMIT_SIZE) < WAKEUP_CHARS)\r\ntty_wakeup(info->tport.tty);\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("THRE...");\r\n#endif\r\nif (info->xmit.head == info->xmit.tail) {\r\ncustom.intena = IF_TBE;\r\nmb();\r\ninfo->IER &= ~UART_IER_THRI;\r\n}\r\n}\r\nstatic void check_modem_status(struct serial_state *info)\r\n{\r\nstruct tty_port *port = &info->tport;\r\nunsigned char status = ciab.pra & (SER_DCD | SER_CTS | SER_DSR);\r\nunsigned char dstatus;\r\nstruct async_icount *icount;\r\ndstatus = status ^ current_ctl_bits;\r\ncurrent_ctl_bits = status;\r\nif (dstatus) {\r\nicount = &info->icount;\r\nif (dstatus & SER_DSR)\r\nicount->dsr++;\r\nif (dstatus & SER_DCD) {\r\nicount->dcd++;\r\n}\r\nif (dstatus & SER_CTS)\r\nicount->cts++;\r\nwake_up_interruptible(&port->delta_msr_wait);\r\n}\r\nif (tty_port_check_carrier(port) && (dstatus & SER_DCD)) {\r\n#if (defined(SERIAL_DEBUG_OPEN) || defined(SERIAL_DEBUG_INTR))\r\nprintk("ttyS%d CD now %s...", info->line,\r\n(!(status & SER_DCD)) ? "on" : "off");\r\n#endif\r\nif (!(status & SER_DCD))\r\nwake_up_interruptible(&port->open_wait);\r\nelse {\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("doing serial hangup...");\r\n#endif\r\nif (port->tty)\r\ntty_hangup(port->tty);\r\n}\r\n}\r\nif (tty_port_cts_enabled(port)) {\r\nif (port->tty->hw_stopped) {\r\nif (!(status & SER_CTS)) {\r\n#if (defined(SERIAL_DEBUG_INTR) || defined(SERIAL_DEBUG_FLOW))\r\nprintk("CTS tx start...");\r\n#endif\r\nport->tty->hw_stopped = 0;\r\ninfo->IER |= UART_IER_THRI;\r\ncustom.intena = IF_SETCLR | IF_TBE;\r\nmb();\r\ncustom.intreq = IF_SETCLR | IF_TBE;\r\nmb();\r\ntty_wakeup(port->tty);\r\nreturn;\r\n}\r\n} else {\r\nif ((status & SER_CTS)) {\r\n#if (defined(SERIAL_DEBUG_INTR) || defined(SERIAL_DEBUG_FLOW))\r\nprintk("CTS tx stop...");\r\n#endif\r\nport->tty->hw_stopped = 1;\r\ninfo->IER &= ~UART_IER_THRI;\r\ncustom.intena = IF_TBE;\r\nmb();\r\ncustom.intreq = IF_TBE;\r\nmb();\r\n}\r\n}\r\n}\r\n}\r\nstatic irqreturn_t ser_vbl_int( int irq, void *data)\r\n{\r\nstruct serial_state *info = data;\r\nif(info->IER & UART_IER_MSI)\r\ncheck_modem_status(info);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ser_rx_int(int irq, void *dev_id)\r\n{\r\nstruct serial_state *info = dev_id;\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("ser_rx_int...");\r\n#endif\r\nif (!info->tport.tty)\r\nreturn IRQ_NONE;\r\nreceive_chars(info);\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("end.\n");\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ser_tx_int(int irq, void *dev_id)\r\n{\r\nstruct serial_state *info = dev_id;\r\nif (custom.serdatr & SDR_TBE) {\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("ser_tx_int...");\r\n#endif\r\nif (!info->tport.tty)\r\nreturn IRQ_NONE;\r\ntransmit_chars(info);\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("end.\n");\r\n#endif\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int startup(struct tty_struct *tty, struct serial_state *info)\r\n{\r\nstruct tty_port *port = &info->tport;\r\nunsigned long flags;\r\nint retval=0;\r\nunsigned long page;\r\npage = get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\nlocal_irq_save(flags);\r\nif (tty_port_initialized(port)) {\r\nfree_page(page);\r\ngoto errout;\r\n}\r\nif (info->xmit.buf)\r\nfree_page(page);\r\nelse\r\ninfo->xmit.buf = (unsigned char *) page;\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("starting up ttys%d ...", info->line);\r\n#endif\r\ncustom.intreq = IF_RBF;\r\nmb();\r\nretval = request_irq(IRQ_AMIGA_VERTB, ser_vbl_int, 0, "serial status", info);\r\nif (retval) {\r\nif (serial_isroot()) {\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\nretval = 0;\r\n}\r\ngoto errout;\r\n}\r\ncustom.intena = IF_SETCLR | IF_RBF | IF_TBE;\r\nmb();\r\ninfo->IER = UART_IER_MSI;\r\ncurrent_ctl_bits = ciab.pra & (SER_DCD | SER_CTS | SER_DSR);\r\ninfo->MCR = 0;\r\nif (C_BAUD(tty))\r\ninfo->MCR = SER_DTR | SER_RTS;\r\nrtsdtr_ctrl(info->MCR);\r\nclear_bit(TTY_IO_ERROR, &tty->flags);\r\ninfo->xmit.head = info->xmit.tail = 0;\r\nchange_speed(tty, info, NULL);\r\ntty_port_set_initialized(port, 1);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\nerrout:\r\nlocal_irq_restore(flags);\r\nreturn retval;\r\n}\r\nstatic void shutdown(struct tty_struct *tty, struct serial_state *info)\r\n{\r\nunsigned long flags;\r\nstruct serial_state *state;\r\nif (!tty_port_initialized(&info->tport))\r\nreturn;\r\nstate = info;\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("Shutting down serial port %d ....\n", info->line);\r\n#endif\r\nlocal_irq_save(flags);\r\nwake_up_interruptible(&info->tport.delta_msr_wait);\r\nfree_irq(IRQ_AMIGA_VERTB, info);\r\nif (info->xmit.buf) {\r\nfree_page((unsigned long) info->xmit.buf);\r\ninfo->xmit.buf = NULL;\r\n}\r\ninfo->IER = 0;\r\ncustom.intena = IF_RBF | IF_TBE;\r\nmb();\r\ncustom.adkcon = AC_UARTBRK;\r\nmb();\r\nif (C_HUPCL(tty))\r\ninfo->MCR &= ~(SER_DTR|SER_RTS);\r\nrtsdtr_ctrl(info->MCR);\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\ntty_port_set_initialized(&info->tport, 0);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void change_speed(struct tty_struct *tty, struct serial_state *info,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct tty_port *port = &info->tport;\r\nint quot = 0, baud_base, baud;\r\nunsigned cflag, cval = 0;\r\nint bits;\r\nunsigned long flags;\r\ncflag = tty->termios.c_cflag;\r\ncval = 3; bits = 10;\r\nif (cflag & CSTOPB) {\r\ncval |= 0x04;\r\nbits++;\r\n}\r\nif (cflag & PARENB) {\r\ncval |= UART_LCR_PARITY;\r\nbits++;\r\n}\r\nif (!(cflag & PARODD))\r\ncval |= UART_LCR_EPAR;\r\n#ifdef CMSPAR\r\nif (cflag & CMSPAR)\r\ncval |= UART_LCR_SPAR;\r\n#endif\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud)\r\nbaud = 9600;\r\nbaud_base = info->baud_base;\r\nif (baud == 38400 && (port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST)\r\nquot = info->custom_divisor;\r\nelse {\r\nif (baud == 134)\r\nquot = (2*baud_base / 269);\r\nelse if (baud)\r\nquot = baud_base / baud;\r\n}\r\nif (!quot && old_termios) {\r\ntty->termios.c_cflag &= ~CBAUD;\r\ntty->termios.c_cflag |= (old_termios->c_cflag & CBAUD);\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud)\r\nbaud = 9600;\r\nif (baud == 38400 &&\r\n(port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST)\r\nquot = info->custom_divisor;\r\nelse {\r\nif (baud == 134)\r\nquot = (2*baud_base / 269);\r\nelse if (baud)\r\nquot = baud_base / baud;\r\n}\r\n}\r\nif (!quot)\r\nquot = baud_base / 9600;\r\ninfo->quot = quot;\r\ninfo->timeout = ((info->xmit_fifo_size*HZ*bits*quot) / baud_base);\r\ninfo->timeout += HZ/50;\r\ninfo->IER &= ~UART_IER_MSI;\r\nif (port->flags & ASYNC_HARDPPS_CD)\r\ninfo->IER |= UART_IER_MSI;\r\ntty_port_set_cts_flow(port, cflag & CRTSCTS);\r\nif (cflag & CRTSCTS)\r\ninfo->IER |= UART_IER_MSI;\r\ntty_port_set_check_carrier(port, ~cflag & CLOCAL);\r\nif (~cflag & CLOCAL)\r\ninfo->IER |= UART_IER_MSI;\r\ninfo->read_status_mask = UART_LSR_OE | UART_LSR_DR;\r\nif (I_INPCK(tty))\r\ninfo->read_status_mask |= UART_LSR_FE | UART_LSR_PE;\r\nif (I_BRKINT(tty) || I_PARMRK(tty))\r\ninfo->read_status_mask |= UART_LSR_BI;\r\ninfo->ignore_status_mask = 0;\r\nif (I_IGNPAR(tty))\r\ninfo->ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\r\nif (I_IGNBRK(tty)) {\r\ninfo->ignore_status_mask |= UART_LSR_BI;\r\nif (I_IGNPAR(tty))\r\ninfo->ignore_status_mask |= UART_LSR_OE;\r\n}\r\nif ((cflag & CREAD) == 0)\r\ninfo->ignore_status_mask |= UART_LSR_DR;\r\nlocal_irq_save(flags);\r\n{\r\nshort serper;\r\nserper = quot - 1;\r\nif(cval & UART_LCR_PARITY)\r\nserper |= (SERPER_PARENB);\r\ncustom.serper = serper;\r\nmb();\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int rs_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nstruct serial_state *info;\r\nunsigned long flags;\r\ninfo = tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_put_char"))\r\nreturn 0;\r\nif (!info->xmit.buf)\r\nreturn 0;\r\nlocal_irq_save(flags);\r\nif (CIRC_SPACE(info->xmit.head,\r\ninfo->xmit.tail,\r\nSERIAL_XMIT_SIZE) == 0) {\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\ninfo->xmit.buf[info->xmit.head++] = ch;\r\ninfo->xmit.head &= SERIAL_XMIT_SIZE-1;\r\nlocal_irq_restore(flags);\r\nreturn 1;\r\n}\r\nstatic void rs_flush_chars(struct tty_struct *tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_flush_chars"))\r\nreturn;\r\nif (info->xmit.head == info->xmit.tail\r\n|| tty->stopped\r\n|| tty->hw_stopped\r\n|| !info->xmit.buf)\r\nreturn;\r\nlocal_irq_save(flags);\r\ninfo->IER |= UART_IER_THRI;\r\ncustom.intena = IF_SETCLR | IF_TBE;\r\nmb();\r\ncustom.intreq = IF_SETCLR | IF_TBE;\r\nmb();\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int rs_write(struct tty_struct * tty, const unsigned char *buf, int count)\r\n{\r\nint c, ret = 0;\r\nstruct serial_state *info = tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_write"))\r\nreturn 0;\r\nif (!info->xmit.buf)\r\nreturn 0;\r\nlocal_irq_save(flags);\r\nwhile (1) {\r\nc = CIRC_SPACE_TO_END(info->xmit.head,\r\ninfo->xmit.tail,\r\nSERIAL_XMIT_SIZE);\r\nif (count < c)\r\nc = count;\r\nif (c <= 0) {\r\nbreak;\r\n}\r\nmemcpy(info->xmit.buf + info->xmit.head, buf, c);\r\ninfo->xmit.head = ((info->xmit.head + c) &\r\n(SERIAL_XMIT_SIZE-1));\r\nbuf += c;\r\ncount -= c;\r\nret += c;\r\n}\r\nlocal_irq_restore(flags);\r\nif (info->xmit.head != info->xmit.tail\r\n&& !tty->stopped\r\n&& !tty->hw_stopped\r\n&& !(info->IER & UART_IER_THRI)) {\r\ninfo->IER |= UART_IER_THRI;\r\nlocal_irq_disable();\r\ncustom.intena = IF_SETCLR | IF_TBE;\r\nmb();\r\ncustom.intreq = IF_SETCLR | IF_TBE;\r\nmb();\r\nlocal_irq_restore(flags);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rs_write_room(struct tty_struct *tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_write_room"))\r\nreturn 0;\r\nreturn CIRC_SPACE(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\n}\r\nstatic int rs_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_chars_in_buffer"))\r\nreturn 0;\r\nreturn CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\n}\r\nstatic void rs_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_flush_buffer"))\r\nreturn;\r\nlocal_irq_save(flags);\r\ninfo->xmit.head = info->xmit.tail = 0;\r\nlocal_irq_restore(flags);\r\ntty_wakeup(tty);\r\n}\r\nstatic void rs_send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_send_xchar"))\r\nreturn;\r\ninfo->x_char = ch;\r\nif (ch) {\r\nlocal_irq_save(flags);\r\nif(!(custom.intenar & IF_TBE)) {\r\ncustom.intena = IF_SETCLR | IF_TBE;\r\nmb();\r\ncustom.intreq = IF_SETCLR | IF_TBE;\r\nmb();\r\n}\r\nlocal_irq_restore(flags);\r\ninfo->IER |= UART_IER_THRI;\r\n}\r\n}\r\nstatic void rs_throttle(struct tty_struct * tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nunsigned long flags;\r\n#ifdef SERIAL_DEBUG_THROTTLE\r\nprintk("throttle %s ....\n", tty_name(tty));\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "rs_throttle"))\r\nreturn;\r\nif (I_IXOFF(tty))\r\nrs_send_xchar(tty, STOP_CHAR(tty));\r\nif (C_CRTSCTS(tty))\r\ninfo->MCR &= ~SER_RTS;\r\nlocal_irq_save(flags);\r\nrtsdtr_ctrl(info->MCR);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void rs_unthrottle(struct tty_struct * tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nunsigned long flags;\r\n#ifdef SERIAL_DEBUG_THROTTLE\r\nprintk("unthrottle %s ....\n", tty_name(tty));\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "rs_unthrottle"))\r\nreturn;\r\nif (I_IXOFF(tty)) {\r\nif (info->x_char)\r\ninfo->x_char = 0;\r\nelse\r\nrs_send_xchar(tty, START_CHAR(tty));\r\n}\r\nif (C_CRTSCTS(tty))\r\ninfo->MCR |= SER_RTS;\r\nlocal_irq_save(flags);\r\nrtsdtr_ctrl(info->MCR);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int get_serial_info(struct tty_struct *tty, struct serial_state *state,\r\nstruct serial_struct __user * retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntty_lock(tty);\r\ntmp.line = tty->index;\r\ntmp.port = state->port;\r\ntmp.flags = state->tport.flags;\r\ntmp.xmit_fifo_size = state->xmit_fifo_size;\r\ntmp.baud_base = state->baud_base;\r\ntmp.close_delay = state->tport.close_delay;\r\ntmp.closing_wait = state->tport.closing_wait;\r\ntmp.custom_divisor = state->custom_divisor;\r\ntty_unlock(tty);\r\nif (copy_to_user(retinfo,&tmp,sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_serial_info(struct tty_struct *tty, struct serial_state *state,\r\nstruct serial_struct __user * new_info)\r\n{\r\nstruct tty_port *port = &state->tport;\r\nstruct serial_struct new_serial;\r\nbool change_spd;\r\nint retval = 0;\r\nif (copy_from_user(&new_serial,new_info,sizeof(new_serial)))\r\nreturn -EFAULT;\r\ntty_lock(tty);\r\nchange_spd = ((new_serial.flags ^ port->flags) & ASYNC_SPD_MASK) ||\r\nnew_serial.custom_divisor != state->custom_divisor;\r\nif (new_serial.irq || new_serial.port != state->port ||\r\nnew_serial.xmit_fifo_size != state->xmit_fifo_size) {\r\ntty_unlock(tty);\r\nreturn -EINVAL;\r\n}\r\nif (!serial_isroot()) {\r\nif ((new_serial.baud_base != state->baud_base) ||\r\n(new_serial.close_delay != port->close_delay) ||\r\n(new_serial.xmit_fifo_size != state->xmit_fifo_size) ||\r\n((new_serial.flags & ~ASYNC_USR_MASK) !=\r\n(port->flags & ~ASYNC_USR_MASK))) {\r\ntty_unlock(tty);\r\nreturn -EPERM;\r\n}\r\nport->flags = ((port->flags & ~ASYNC_USR_MASK) |\r\n(new_serial.flags & ASYNC_USR_MASK));\r\nstate->custom_divisor = new_serial.custom_divisor;\r\ngoto check_and_exit;\r\n}\r\nif (new_serial.baud_base < 9600) {\r\ntty_unlock(tty);\r\nreturn -EINVAL;\r\n}\r\nstate->baud_base = new_serial.baud_base;\r\nport->flags = ((port->flags & ~ASYNC_FLAGS) |\r\n(new_serial.flags & ASYNC_FLAGS));\r\nstate->custom_divisor = new_serial.custom_divisor;\r\nport->close_delay = new_serial.close_delay * HZ/100;\r\nport->closing_wait = new_serial.closing_wait * HZ/100;\r\nport->low_latency = (port->flags & ASYNC_LOW_LATENCY) ? 1 : 0;\r\ncheck_and_exit:\r\nif (tty_port_initialized(port)) {\r\nif (change_spd) {\r\nif (new_serial.flags & ASYNC_SPD_MASK)\r\ndev_warn_ratelimited(tty->dev, "use of SPD flags is deprecated\n");\r\nchange_speed(tty, state, NULL);\r\n}\r\n} else\r\nretval = startup(tty, state);\r\ntty_unlock(tty);\r\nreturn retval;\r\n}\r\nstatic int get_lsr_info(struct serial_state *info, unsigned int __user *value)\r\n{\r\nunsigned char status;\r\nunsigned int result;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nstatus = custom.serdatr;\r\nmb();\r\nlocal_irq_restore(flags);\r\nresult = ((status & SDR_TSRE) ? TIOCSER_TEMT : 0);\r\nif (copy_to_user(value, &result, sizeof(int)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int rs_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nunsigned char control, status;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_ioctl"))\r\nreturn -ENODEV;\r\nif (tty_io_error(tty))\r\nreturn -EIO;\r\ncontrol = info->MCR;\r\nlocal_irq_save(flags);\r\nstatus = ciab.pra;\r\nlocal_irq_restore(flags);\r\nreturn ((control & SER_RTS) ? TIOCM_RTS : 0)\r\n| ((control & SER_DTR) ? TIOCM_DTR : 0)\r\n| (!(status & SER_DCD) ? TIOCM_CAR : 0)\r\n| (!(status & SER_DSR) ? TIOCM_DSR : 0)\r\n| (!(status & SER_CTS) ? TIOCM_CTS : 0);\r\n}\r\nstatic int rs_tiocmset(struct tty_struct *tty, unsigned int set,\r\nunsigned int clear)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_ioctl"))\r\nreturn -ENODEV;\r\nif (tty_io_error(tty))\r\nreturn -EIO;\r\nlocal_irq_save(flags);\r\nif (set & TIOCM_RTS)\r\ninfo->MCR |= SER_RTS;\r\nif (set & TIOCM_DTR)\r\ninfo->MCR |= SER_DTR;\r\nif (clear & TIOCM_RTS)\r\ninfo->MCR &= ~SER_RTS;\r\nif (clear & TIOCM_DTR)\r\ninfo->MCR &= ~SER_DTR;\r\nrtsdtr_ctrl(info->MCR);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int rs_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nunsigned long flags;\r\nif (serial_paranoia_check(info, tty->name, "rs_break"))\r\nreturn -EINVAL;\r\nlocal_irq_save(flags);\r\nif (break_state == -1)\r\ncustom.adkcon = AC_SETCLR | AC_UARTBRK;\r\nelse\r\ncustom.adkcon = AC_UARTBRK;\r\nmb();\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int rs_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nstruct async_icount cnow;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ncnow = info->icount;\r\nlocal_irq_restore(flags);\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nicount->rx = cnow.rx;\r\nicount->tx = cnow.tx;\r\nicount->frame = cnow.frame;\r\nicount->overrun = cnow.overrun;\r\nicount->parity = cnow.parity;\r\nicount->brk = cnow.brk;\r\nicount->buf_overrun = cnow.buf_overrun;\r\nreturn 0;\r\n}\r\nstatic int rs_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nstruct async_icount cprev, cnow;\r\nvoid __user *argp = (void __user *)arg;\r\nunsigned long flags;\r\nDEFINE_WAIT(wait);\r\nint ret;\r\nif (serial_paranoia_check(info, tty->name, "rs_ioctl"))\r\nreturn -ENODEV;\r\nif ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&\r\n(cmd != TIOCSERCONFIG) && (cmd != TIOCSERGSTRUCT) &&\r\n(cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)) {\r\nif (tty_io_error(tty))\r\nreturn -EIO;\r\n}\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nreturn get_serial_info(tty, info, argp);\r\ncase TIOCSSERIAL:\r\nreturn set_serial_info(tty, info, argp);\r\ncase TIOCSERCONFIG:\r\nreturn 0;\r\ncase TIOCSERGETLSR:\r\nreturn get_lsr_info(info, argp);\r\ncase TIOCSERGSTRUCT:\r\nif (copy_to_user(argp,\r\ninfo, sizeof(struct serial_state)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase TIOCMIWAIT:\r\nlocal_irq_save(flags);\r\ncprev = info->icount;\r\nlocal_irq_restore(flags);\r\nwhile (1) {\r\nprepare_to_wait(&info->tport.delta_msr_wait,\r\n&wait, TASK_INTERRUPTIBLE);\r\nlocal_irq_save(flags);\r\ncnow = info->icount;\r\nlocal_irq_restore(flags);\r\nif (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&\r\ncnow.dcd == cprev.dcd && cnow.cts == cprev.cts) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif ( ((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||\r\n((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||\r\n((arg & TIOCM_CD) && (cnow.dcd != cprev.dcd)) ||\r\n((arg & TIOCM_CTS) && (cnow.cts != cprev.cts)) ) {\r\nret = 0;\r\nbreak;\r\n}\r\nschedule();\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\ncprev = cnow;\r\n}\r\nfinish_wait(&info->tport.delta_msr_wait, &wait);\r\nreturn ret;\r\ncase TIOCSERGWILD:\r\ncase TIOCSERSWILD:\r\nprintk ("TIOCSER?WILD ioctl obsolete, ignored.\n");\r\nreturn 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rs_set_termios(struct tty_struct *tty, struct ktermios *old_termios)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nunsigned long flags;\r\nunsigned int cflag = tty->termios.c_cflag;\r\nchange_speed(tty, info, old_termios);\r\nif ((old_termios->c_cflag & CBAUD) && !(cflag & CBAUD)) {\r\ninfo->MCR &= ~(SER_DTR|SER_RTS);\r\nlocal_irq_save(flags);\r\nrtsdtr_ctrl(info->MCR);\r\nlocal_irq_restore(flags);\r\n}\r\nif (!(old_termios->c_cflag & CBAUD) && (cflag & CBAUD)) {\r\ninfo->MCR |= SER_DTR;\r\nif (!C_CRTSCTS(tty) || !tty_throttled(tty))\r\ninfo->MCR |= SER_RTS;\r\nlocal_irq_save(flags);\r\nrtsdtr_ctrl(info->MCR);\r\nlocal_irq_restore(flags);\r\n}\r\nif ((old_termios->c_cflag & CRTSCTS) && !C_CRTSCTS(tty)) {\r\ntty->hw_stopped = 0;\r\nrs_start(tty);\r\n}\r\n#if 0\r\nif (!(old_termios->c_cflag & CLOCAL) && C_CLOCAL(tty))\r\nwake_up_interruptible(&info->open_wait);\r\n#endif\r\n}\r\nstatic void rs_close(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct serial_state *state = tty->driver_data;\r\nstruct tty_port *port = &state->tport;\r\nif (serial_paranoia_check(state, tty->name, "rs_close"))\r\nreturn;\r\nif (tty_port_close_start(port, tty, filp) == 0)\r\nreturn;\r\nstate->read_status_mask &= ~UART_LSR_DR;\r\nif (tty_port_initialized(port)) {\r\ncustom.intena = IF_RBF;\r\nmb();\r\ncustom.intreq = IF_RBF;\r\nmb();\r\nrs_wait_until_sent(tty, state->timeout);\r\n}\r\nshutdown(tty, state);\r\nrs_flush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\nport->tty = NULL;\r\ntty_port_close_end(port, tty);\r\n}\r\nstatic void rs_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nunsigned long orig_jiffies, char_time;\r\nint lsr;\r\nif (serial_paranoia_check(info, tty->name, "rs_wait_until_sent"))\r\nreturn;\r\nif (info->xmit_fifo_size == 0)\r\nreturn;\r\norig_jiffies = jiffies;\r\nchar_time = (info->timeout - HZ/50) / info->xmit_fifo_size;\r\nchar_time = char_time / 5;\r\nif (char_time == 0)\r\nchar_time = 1;\r\nif (timeout)\r\nchar_time = min_t(unsigned long, char_time, timeout);\r\nif (!timeout || timeout > 2*info->timeout)\r\ntimeout = 2*info->timeout;\r\n#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT\r\nprintk("In rs_wait_until_sent(%d) check=%lu...", timeout, char_time);\r\nprintk("jiff=%lu...", jiffies);\r\n#endif\r\nwhile(!((lsr = custom.serdatr) & SDR_TSRE)) {\r\n#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT\r\nprintk("serdatr = %d (jiff=%lu)...", lsr, jiffies);\r\n#endif\r\nmsleep_interruptible(jiffies_to_msecs(char_time));\r\nif (signal_pending(current))\r\nbreak;\r\nif (timeout && time_after(jiffies, orig_jiffies + timeout))\r\nbreak;\r\n}\r\n__set_current_state(TASK_RUNNING);\r\n#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT\r\nprintk("lsr = %d (jiff=%lu)...done\n", lsr, jiffies);\r\n#endif\r\n}\r\nstatic void rs_hangup(struct tty_struct *tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_hangup"))\r\nreturn;\r\nrs_flush_buffer(tty);\r\nshutdown(tty, info);\r\ninfo->tport.count = 0;\r\ntty_port_set_active(&info->tport, 0);\r\ninfo->tport.tty = NULL;\r\nwake_up_interruptible(&info->tport.open_wait);\r\n}\r\nstatic int rs_open(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct serial_state *info = rs_table + tty->index;\r\nstruct tty_port *port = &info->tport;\r\nint retval;\r\nport->count++;\r\nport->tty = tty;\r\ntty->driver_data = info;\r\ntty->port = port;\r\nif (serial_paranoia_check(info, tty->name, "rs_open"))\r\nreturn -ENODEV;\r\nport->low_latency = (port->flags & ASYNC_LOW_LATENCY) ? 1 : 0;\r\nretval = startup(tty, info);\r\nif (retval) {\r\nreturn retval;\r\n}\r\nreturn tty_port_block_til_ready(port, tty, filp);\r\n}\r\nstatic inline void line_info(struct seq_file *m, int line,\r\nstruct serial_state *state)\r\n{\r\nchar stat_buf[30], control, status;\r\nunsigned long flags;\r\nseq_printf(m, "%d: uart:amiga_builtin", line);\r\nlocal_irq_save(flags);\r\nstatus = ciab.pra;\r\ncontrol = tty_port_initialized(&state->tport) ? state->MCR : status;\r\nlocal_irq_restore(flags);\r\nstat_buf[0] = 0;\r\nstat_buf[1] = 0;\r\nif(!(control & SER_RTS))\r\nstrcat(stat_buf, "|RTS");\r\nif(!(status & SER_CTS))\r\nstrcat(stat_buf, "|CTS");\r\nif(!(control & SER_DTR))\r\nstrcat(stat_buf, "|DTR");\r\nif(!(status & SER_DSR))\r\nstrcat(stat_buf, "|DSR");\r\nif(!(status & SER_DCD))\r\nstrcat(stat_buf, "|CD");\r\nif (state->quot)\r\nseq_printf(m, " baud:%d", state->baud_base / state->quot);\r\nseq_printf(m, " tx:%d rx:%d", state->icount.tx, state->icount.rx);\r\nif (state->icount.frame)\r\nseq_printf(m, " fe:%d", state->icount.frame);\r\nif (state->icount.parity)\r\nseq_printf(m, " pe:%d", state->icount.parity);\r\nif (state->icount.brk)\r\nseq_printf(m, " brk:%d", state->icount.brk);\r\nif (state->icount.overrun)\r\nseq_printf(m, " oe:%d", state->icount.overrun);\r\nseq_printf(m, " %s\n", stat_buf+1);\r\n}\r\nstatic int rs_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "serinfo:1.0 driver:%s\n", serial_version);\r\nline_info(m, 0, &rs_table[0]);\r\nreturn 0;\r\n}\r\nstatic int rs_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, rs_proc_show, NULL);\r\n}\r\nstatic void show_serial_version(void)\r\n{\r\nprintk(KERN_INFO "%s version %s\n", serial_name, serial_version);\r\n}\r\nstatic int amiga_carrier_raised(struct tty_port *port)\r\n{\r\nreturn !(ciab.pra & SER_DCD);\r\n}\r\nstatic void amiga_dtr_rts(struct tty_port *port, int raise)\r\n{\r\nstruct serial_state *info = container_of(port, struct serial_state,\r\ntport);\r\nunsigned long flags;\r\nif (raise)\r\ninfo->MCR |= SER_DTR|SER_RTS;\r\nelse\r\ninfo->MCR &= ~(SER_DTR|SER_RTS);\r\nlocal_irq_save(flags);\r\nrtsdtr_ctrl(info->MCR);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int __init amiga_serial_probe(struct platform_device *pdev)\r\n{\r\nunsigned long flags;\r\nstruct serial_state * state;\r\nint error;\r\nserial_driver = alloc_tty_driver(NR_PORTS);\r\nif (!serial_driver)\r\nreturn -ENOMEM;\r\nshow_serial_version();\r\nserial_driver->driver_name = "amiserial";\r\nserial_driver->name = "ttyS";\r\nserial_driver->major = TTY_MAJOR;\r\nserial_driver->minor_start = 64;\r\nserial_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nserial_driver->subtype = SERIAL_TYPE_NORMAL;\r\nserial_driver->init_termios = tty_std_termios;\r\nserial_driver->init_termios.c_cflag =\r\nB9600 | CS8 | CREAD | HUPCL | CLOCAL;\r\nserial_driver->flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(serial_driver, &serial_ops);\r\nstate = rs_table;\r\nstate->port = (int)&custom.serdatr;\r\nstate->custom_divisor = 0;\r\nstate->icount.cts = state->icount.dsr =\r\nstate->icount.rng = state->icount.dcd = 0;\r\nstate->icount.rx = state->icount.tx = 0;\r\nstate->icount.frame = state->icount.parity = 0;\r\nstate->icount.overrun = state->icount.brk = 0;\r\ntty_port_init(&state->tport);\r\nstate->tport.ops = &amiga_port_ops;\r\ntty_port_link_device(&state->tport, serial_driver, 0);\r\nerror = tty_register_driver(serial_driver);\r\nif (error)\r\ngoto fail_put_tty_driver;\r\nprintk(KERN_INFO "ttyS0 is the amiga builtin serial port\n");\r\nstate->baud_base = amiga_colorclock;\r\nstate->xmit_fifo_size = 1;\r\nerror = request_irq(IRQ_AMIGA_TBE, ser_tx_int, 0, "serial TX", state);\r\nif (error)\r\ngoto fail_unregister;\r\nerror = request_irq(IRQ_AMIGA_RBF, ser_rx_int, 0,\r\n"serial RX", state);\r\nif (error)\r\ngoto fail_free_irq;\r\nlocal_irq_save(flags);\r\ncustom.intena = IF_RBF | IF_TBE;\r\nmb();\r\ncustom.intreq = IF_RBF | IF_TBE;\r\nmb();\r\nlocal_irq_restore(flags);\r\nciab.ddra |= (SER_DTR | SER_RTS);\r\nciab.ddra &= ~(SER_DCD | SER_CTS | SER_DSR);\r\nplatform_set_drvdata(pdev, state);\r\nreturn 0;\r\nfail_free_irq:\r\nfree_irq(IRQ_AMIGA_TBE, state);\r\nfail_unregister:\r\ntty_unregister_driver(serial_driver);\r\nfail_put_tty_driver:\r\ntty_port_destroy(&state->tport);\r\nput_tty_driver(serial_driver);\r\nreturn error;\r\n}\r\nstatic int __exit amiga_serial_remove(struct platform_device *pdev)\r\n{\r\nint error;\r\nstruct serial_state *state = platform_get_drvdata(pdev);\r\nerror = tty_unregister_driver(serial_driver);\r\nif (error)\r\nprintk("SERIAL: failed to unregister serial driver (%d)\n",\r\nerror);\r\nput_tty_driver(serial_driver);\r\ntty_port_destroy(&state->tport);\r\nfree_irq(IRQ_AMIGA_TBE, state);\r\nfree_irq(IRQ_AMIGA_RBF, state);\r\nreturn error;\r\n}\r\nstatic void amiga_serial_putc(char c)\r\n{\r\ncustom.serdat = (unsigned char)c | 0x100;\r\nwhile (!(custom.serdatr & 0x2000))\r\nbarrier();\r\n}\r\nstatic void serial_console_write(struct console *co, const char *s,\r\nunsigned count)\r\n{\r\nunsigned short intena = custom.intenar;\r\ncustom.intena = IF_TBE;\r\nwhile (count--) {\r\nif (*s == '\n')\r\namiga_serial_putc('\r');\r\namiga_serial_putc(*s++);\r\n}\r\ncustom.intena = IF_SETCLR | (intena & IF_TBE);\r\n}\r\nstatic struct tty_driver *serial_console_device(struct console *c, int *index)\r\n{\r\n*index = 0;\r\nreturn serial_driver;\r\n}\r\nstatic int __init amiserial_console_init(void)\r\n{\r\nif (!MACH_IS_AMIGA)\r\nreturn -ENODEV;\r\nregister_console(&sercons);\r\nreturn 0;\r\n}
