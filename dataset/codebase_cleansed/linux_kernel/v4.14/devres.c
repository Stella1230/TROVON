static void set_node_dbginfo(struct devres_node *node, const char *name,\r\nsize_t size)\r\n{\r\nnode->name = name;\r\nnode->size = size;\r\n}\r\nstatic void devres_log(struct device *dev, struct devres_node *node,\r\nconst char *op)\r\n{\r\nif (unlikely(log_devres))\r\ndev_err(dev, "DEVRES %3s %p %s (%lu bytes)\n",\r\nop, node, node->name, (unsigned long)node->size);\r\n}\r\nstatic void group_open_release(struct device *dev, void *res)\r\n{\r\n}\r\nstatic void group_close_release(struct device *dev, void *res)\r\n{\r\n}\r\nstatic struct devres_group * node_to_group(struct devres_node *node)\r\n{\r\nif (node->release == &group_open_release)\r\nreturn container_of(node, struct devres_group, node[0]);\r\nif (node->release == &group_close_release)\r\nreturn container_of(node, struct devres_group, node[1]);\r\nreturn NULL;\r\n}\r\nvoid add_dr(struct device *dev, struct devres_node *node)\r\n{\r\ndevres_log(dev, node, "ADD");\r\nBUG_ON(!list_empty(&node->entry));\r\nlist_add_tail(&node->entry, &dev->devres_head);\r\n}\r\nvoid * __devres_alloc_node(dr_release_t release, size_t size, gfp_t gfp, int nid,\r\nconst char *name)\r\n{\r\nstruct devres *dr;\r\ndr = alloc_dr(release, size, gfp | __GFP_ZERO, nid);\r\nif (unlikely(!dr))\r\nreturn NULL;\r\nset_node_dbginfo(&dr->node, name, size);\r\nreturn dr->data;\r\n}\r\nvoid * devres_alloc_node(dr_release_t release, size_t size, gfp_t gfp, int nid)\r\n{\r\nstruct devres *dr;\r\ndr = alloc_dr(release, size, gfp | __GFP_ZERO, nid);\r\nif (unlikely(!dr))\r\nreturn NULL;\r\nreturn dr->data;\r\n}\r\nvoid devres_for_each_res(struct device *dev, dr_release_t release,\r\ndr_match_t match, void *match_data,\r\nvoid (*fn)(struct device *, void *, void *),\r\nvoid *data)\r\n{\r\nstruct devres_node *node;\r\nstruct devres_node *tmp;\r\nunsigned long flags;\r\nif (!fn)\r\nreturn;\r\nspin_lock_irqsave(&dev->devres_lock, flags);\r\nlist_for_each_entry_safe_reverse(node, tmp,\r\n&dev->devres_head, entry) {\r\nstruct devres *dr = container_of(node, struct devres, node);\r\nif (node->release != release)\r\ncontinue;\r\nif (match && !match(dev, dr->data, match_data))\r\ncontinue;\r\nfn(dev, dr->data, data);\r\n}\r\nspin_unlock_irqrestore(&dev->devres_lock, flags);\r\n}\r\nvoid devres_free(void *res)\r\n{\r\nif (res) {\r\nstruct devres *dr = container_of(res, struct devres, data);\r\nBUG_ON(!list_empty(&dr->node.entry));\r\nkfree(dr);\r\n}\r\n}\r\nvoid devres_add(struct device *dev, void *res)\r\n{\r\nstruct devres *dr = container_of(res, struct devres, data);\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->devres_lock, flags);\r\nadd_dr(dev, &dr->node);\r\nspin_unlock_irqrestore(&dev->devres_lock, flags);\r\n}\r\nstatic struct devres *find_dr(struct device *dev, dr_release_t release,\r\ndr_match_t match, void *match_data)\r\n{\r\nstruct devres_node *node;\r\nlist_for_each_entry_reverse(node, &dev->devres_head, entry) {\r\nstruct devres *dr = container_of(node, struct devres, node);\r\nif (node->release != release)\r\ncontinue;\r\nif (match && !match(dev, dr->data, match_data))\r\ncontinue;\r\nreturn dr;\r\n}\r\nreturn NULL;\r\n}\r\nvoid * devres_find(struct device *dev, dr_release_t release,\r\ndr_match_t match, void *match_data)\r\n{\r\nstruct devres *dr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->devres_lock, flags);\r\ndr = find_dr(dev, release, match, match_data);\r\nspin_unlock_irqrestore(&dev->devres_lock, flags);\r\nif (dr)\r\nreturn dr->data;\r\nreturn NULL;\r\n}\r\nvoid * devres_get(struct device *dev, void *new_res,\r\ndr_match_t match, void *match_data)\r\n{\r\nstruct devres *new_dr = container_of(new_res, struct devres, data);\r\nstruct devres *dr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->devres_lock, flags);\r\ndr = find_dr(dev, new_dr->node.release, match, match_data);\r\nif (!dr) {\r\nadd_dr(dev, &new_dr->node);\r\ndr = new_dr;\r\nnew_res = NULL;\r\n}\r\nspin_unlock_irqrestore(&dev->devres_lock, flags);\r\ndevres_free(new_res);\r\nreturn dr->data;\r\n}\r\nvoid * devres_remove(struct device *dev, dr_release_t release,\r\ndr_match_t match, void *match_data)\r\n{\r\nstruct devres *dr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->devres_lock, flags);\r\ndr = find_dr(dev, release, match, match_data);\r\nif (dr) {\r\nlist_del_init(&dr->node.entry);\r\ndevres_log(dev, &dr->node, "REM");\r\n}\r\nspin_unlock_irqrestore(&dev->devres_lock, flags);\r\nif (dr)\r\nreturn dr->data;\r\nreturn NULL;\r\n}\r\nint devres_destroy(struct device *dev, dr_release_t release,\r\ndr_match_t match, void *match_data)\r\n{\r\nvoid *res;\r\nres = devres_remove(dev, release, match, match_data);\r\nif (unlikely(!res))\r\nreturn -ENOENT;\r\ndevres_free(res);\r\nreturn 0;\r\n}\r\nint devres_release(struct device *dev, dr_release_t release,\r\ndr_match_t match, void *match_data)\r\n{\r\nvoid *res;\r\nres = devres_remove(dev, release, match, match_data);\r\nif (unlikely(!res))\r\nreturn -ENOENT;\r\n(*release)(dev, res);\r\ndevres_free(res);\r\nreturn 0;\r\n}\r\nstatic int remove_nodes(struct device *dev,\r\nstruct list_head *first, struct list_head *end,\r\nstruct list_head *todo)\r\n{\r\nint cnt = 0, nr_groups = 0;\r\nstruct list_head *cur;\r\ncur = first;\r\nwhile (cur != end) {\r\nstruct devres_node *node;\r\nstruct devres_group *grp;\r\nnode = list_entry(cur, struct devres_node, entry);\r\ncur = cur->next;\r\ngrp = node_to_group(node);\r\nif (grp) {\r\ngrp->color = 0;\r\nnr_groups++;\r\n} else {\r\nif (&node->entry == first)\r\nfirst = first->next;\r\nlist_move_tail(&node->entry, todo);\r\ncnt++;\r\n}\r\n}\r\nif (!nr_groups)\r\nreturn cnt;\r\ncur = first;\r\nwhile (cur != end) {\r\nstruct devres_node *node;\r\nstruct devres_group *grp;\r\nnode = list_entry(cur, struct devres_node, entry);\r\ncur = cur->next;\r\ngrp = node_to_group(node);\r\nBUG_ON(!grp || list_empty(&grp->node[0].entry));\r\ngrp->color++;\r\nif (list_empty(&grp->node[1].entry))\r\ngrp->color++;\r\nBUG_ON(grp->color <= 0 || grp->color > 2);\r\nif (grp->color == 2) {\r\nlist_move_tail(&grp->node[0].entry, todo);\r\nlist_del_init(&grp->node[1].entry);\r\n}\r\n}\r\nreturn cnt;\r\n}\r\nstatic int release_nodes(struct device *dev, struct list_head *first,\r\nstruct list_head *end, unsigned long flags)\r\n__releases(&dev->devres_lock\r\nint devres_release_all(struct device *dev)\r\n{\r\nunsigned long flags;\r\nif (WARN_ON(dev->devres_head.next == NULL))\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&dev->devres_lock, flags);\r\nreturn release_nodes(dev, dev->devres_head.next, &dev->devres_head,\r\nflags);\r\n}\r\nvoid * devres_open_group(struct device *dev, void *id, gfp_t gfp)\r\n{\r\nstruct devres_group *grp;\r\nunsigned long flags;\r\ngrp = kmalloc(sizeof(*grp), gfp);\r\nif (unlikely(!grp))\r\nreturn NULL;\r\ngrp->node[0].release = &group_open_release;\r\ngrp->node[1].release = &group_close_release;\r\nINIT_LIST_HEAD(&grp->node[0].entry);\r\nINIT_LIST_HEAD(&grp->node[1].entry);\r\nset_node_dbginfo(&grp->node[0], "grp<", 0);\r\nset_node_dbginfo(&grp->node[1], "grp>", 0);\r\ngrp->id = grp;\r\nif (id)\r\ngrp->id = id;\r\nspin_lock_irqsave(&dev->devres_lock, flags);\r\nadd_dr(dev, &grp->node[0]);\r\nspin_unlock_irqrestore(&dev->devres_lock, flags);\r\nreturn grp->id;\r\n}\r\nstatic struct devres_group * find_group(struct device *dev, void *id)\r\n{\r\nstruct devres_node *node;\r\nlist_for_each_entry_reverse(node, &dev->devres_head, entry) {\r\nstruct devres_group *grp;\r\nif (node->release != &group_open_release)\r\ncontinue;\r\ngrp = container_of(node, struct devres_group, node[0]);\r\nif (id) {\r\nif (grp->id == id)\r\nreturn grp;\r\n} else if (list_empty(&grp->node[1].entry))\r\nreturn grp;\r\n}\r\nreturn NULL;\r\n}\r\nvoid devres_close_group(struct device *dev, void *id)\r\n{\r\nstruct devres_group *grp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->devres_lock, flags);\r\ngrp = find_group(dev, id);\r\nif (grp)\r\nadd_dr(dev, &grp->node[1]);\r\nelse\r\nWARN_ON(1);\r\nspin_unlock_irqrestore(&dev->devres_lock, flags);\r\n}\r\nvoid devres_remove_group(struct device *dev, void *id)\r\n{\r\nstruct devres_group *grp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->devres_lock, flags);\r\ngrp = find_group(dev, id);\r\nif (grp) {\r\nlist_del_init(&grp->node[0].entry);\r\nlist_del_init(&grp->node[1].entry);\r\ndevres_log(dev, &grp->node[0], "REM");\r\n} else\r\nWARN_ON(1);\r\nspin_unlock_irqrestore(&dev->devres_lock, flags);\r\nkfree(grp);\r\n}\r\nint devres_release_group(struct device *dev, void *id)\r\n{\r\nstruct devres_group *grp;\r\nunsigned long flags;\r\nint cnt = 0;\r\nspin_lock_irqsave(&dev->devres_lock, flags);\r\ngrp = find_group(dev, id);\r\nif (grp) {\r\nstruct list_head *first = &grp->node[0].entry;\r\nstruct list_head *end = &dev->devres_head;\r\nif (!list_empty(&grp->node[1].entry))\r\nend = grp->node[1].entry.next;\r\ncnt = release_nodes(dev, first, end, flags);\r\n} else {\r\nWARN_ON(1);\r\nspin_unlock_irqrestore(&dev->devres_lock, flags);\r\n}\r\nreturn cnt;\r\n}\r\nstatic int devm_action_match(struct device *dev, void *res, void *p)\r\n{\r\nstruct action_devres *devres = res;\r\nstruct action_devres *target = p;\r\nreturn devres->action == target->action &&\r\ndevres->data == target->data;\r\n}\r\nstatic void devm_action_release(struct device *dev, void *res)\r\n{\r\nstruct action_devres *devres = res;\r\ndevres->action(devres->data);\r\n}\r\nint devm_add_action(struct device *dev, void (*action)(void *), void *data)\r\n{\r\nstruct action_devres *devres;\r\ndevres = devres_alloc(devm_action_release,\r\nsizeof(struct action_devres), GFP_KERNEL);\r\nif (!devres)\r\nreturn -ENOMEM;\r\ndevres->data = data;\r\ndevres->action = action;\r\ndevres_add(dev, devres);\r\nreturn 0;\r\n}\r\nvoid devm_remove_action(struct device *dev, void (*action)(void *), void *data)\r\n{\r\nstruct action_devres devres = {\r\n.data = data,\r\n.action = action,\r\n};\r\nWARN_ON(devres_destroy(dev, devm_action_release, devm_action_match,\r\n&devres));\r\n}\r\nstatic void devm_kmalloc_release(struct device *dev, void *res)\r\n{\r\n}\r\nstatic int devm_kmalloc_match(struct device *dev, void *res, void *data)\r\n{\r\nreturn res == data;\r\n}\r\nvoid * devm_kmalloc(struct device *dev, size_t size, gfp_t gfp)\r\n{\r\nstruct devres *dr;\r\ndr = alloc_dr(devm_kmalloc_release, size, gfp, dev_to_node(dev));\r\nif (unlikely(!dr))\r\nreturn NULL;\r\nset_node_dbginfo(&dr->node, "devm_kzalloc_release", size);\r\ndevres_add(dev, dr->data);\r\nreturn dr->data;\r\n}\r\nchar *devm_kstrdup(struct device *dev, const char *s, gfp_t gfp)\r\n{\r\nsize_t size;\r\nchar *buf;\r\nif (!s)\r\nreturn NULL;\r\nsize = strlen(s) + 1;\r\nbuf = devm_kmalloc(dev, size, gfp);\r\nif (buf)\r\nmemcpy(buf, s, size);\r\nreturn buf;\r\n}\r\nchar *devm_kvasprintf(struct device *dev, gfp_t gfp, const char *fmt,\r\nva_list ap)\r\n{\r\nunsigned int len;\r\nchar *p;\r\nva_list aq;\r\nva_copy(aq, ap);\r\nlen = vsnprintf(NULL, 0, fmt, aq);\r\nva_end(aq);\r\np = devm_kmalloc(dev, len+1, gfp);\r\nif (!p)\r\nreturn NULL;\r\nvsnprintf(p, len+1, fmt, ap);\r\nreturn p;\r\n}\r\nchar *devm_kasprintf(struct device *dev, gfp_t gfp, const char *fmt, ...)\r\n{\r\nva_list ap;\r\nchar *p;\r\nva_start(ap, fmt);\r\np = devm_kvasprintf(dev, gfp, fmt, ap);\r\nva_end(ap);\r\nreturn p;\r\n}\r\nvoid devm_kfree(struct device *dev, void *p)\r\n{\r\nint rc;\r\nrc = devres_destroy(dev, devm_kmalloc_release, devm_kmalloc_match, p);\r\nWARN_ON(rc);\r\n}\r\nvoid *devm_kmemdup(struct device *dev, const void *src, size_t len, gfp_t gfp)\r\n{\r\nvoid *p;\r\np = devm_kmalloc(dev, len, gfp);\r\nif (p)\r\nmemcpy(p, src, len);\r\nreturn p;\r\n}\r\nstatic int devm_pages_match(struct device *dev, void *res, void *p)\r\n{\r\nstruct pages_devres *devres = res;\r\nstruct pages_devres *target = p;\r\nreturn devres->addr == target->addr;\r\n}\r\nstatic void devm_pages_release(struct device *dev, void *res)\r\n{\r\nstruct pages_devres *devres = res;\r\nfree_pages(devres->addr, devres->order);\r\n}\r\nunsigned long devm_get_free_pages(struct device *dev,\r\ngfp_t gfp_mask, unsigned int order)\r\n{\r\nstruct pages_devres *devres;\r\nunsigned long addr;\r\naddr = __get_free_pages(gfp_mask, order);\r\nif (unlikely(!addr))\r\nreturn 0;\r\ndevres = devres_alloc(devm_pages_release,\r\nsizeof(struct pages_devres), GFP_KERNEL);\r\nif (unlikely(!devres)) {\r\nfree_pages(addr, order);\r\nreturn 0;\r\n}\r\ndevres->addr = addr;\r\ndevres->order = order;\r\ndevres_add(dev, devres);\r\nreturn addr;\r\n}\r\nvoid devm_free_pages(struct device *dev, unsigned long addr)\r\n{\r\nstruct pages_devres devres = { .addr = addr };\r\nWARN_ON(devres_release(dev, devm_pages_release, devm_pages_match,\r\n&devres));\r\n}\r\nstatic void devm_percpu_release(struct device *dev, void *pdata)\r\n{\r\nvoid __percpu *p;\r\np = *(void __percpu **)pdata;\r\nfree_percpu(p);\r\n}\r\nstatic int devm_percpu_match(struct device *dev, void *data, void *p)\r\n{\r\nstruct devres *devr = container_of(data, struct devres, data);\r\nreturn *(void **)devr->data == p;\r\n}\r\nvoid __percpu *__devm_alloc_percpu(struct device *dev, size_t size,\r\nsize_t align)\r\n{\r\nvoid *p;\r\nvoid __percpu *pcpu;\r\npcpu = __alloc_percpu(size, align);\r\nif (!pcpu)\r\nreturn NULL;\r\np = devres_alloc(devm_percpu_release, sizeof(void *), GFP_KERNEL);\r\nif (!p) {\r\nfree_percpu(pcpu);\r\nreturn NULL;\r\n}\r\n*(void __percpu **)p = pcpu;\r\ndevres_add(dev, p);\r\nreturn pcpu;\r\n}\r\nvoid devm_free_percpu(struct device *dev, void __percpu *pdata)\r\n{\r\nWARN_ON(devres_destroy(dev, devm_percpu_release, devm_percpu_match,\r\n(void *)pdata));\r\n}
