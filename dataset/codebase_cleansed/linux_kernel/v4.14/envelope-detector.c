static int envelope_detector_comp_latch(struct envelope *env)\r\n{\r\nint comp;\r\nspin_lock_irq(&env->comp_lock);\r\ncomp = env->comp;\r\nenv->comp = 0;\r\nspin_unlock_irq(&env->comp_lock);\r\nif (!comp)\r\nreturn 0;\r\nenable_irq(env->comp_irq);\r\nsynchronize_irq(env->comp_irq);\r\nspin_lock_irq(&env->comp_lock);\r\ncomp = env->comp;\r\nenv->comp = 0;\r\nspin_unlock_irq(&env->comp_lock);\r\nif (comp)\r\nenable_irq(env->comp_irq);\r\nreturn 1;\r\n}\r\nstatic irqreturn_t envelope_detector_comp_isr(int irq, void *ctx)\r\n{\r\nstruct envelope *env = ctx;\r\nspin_lock(&env->comp_lock);\r\nenv->comp = 1;\r\ndisable_irq_nosync(env->comp_irq);\r\nspin_unlock(&env->comp_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void envelope_detector_setup_compare(struct envelope *env)\r\n{\r\nint ret;\r\nenv->level = (env->high + env->low + !env->invert) / 2;\r\nif (env->high == env->low + 1) {\r\ncomplete(&env->done);\r\nreturn;\r\n}\r\nret = iio_write_channel_raw(env->dac, env->invert ? 0 : env->dac_max);\r\nif (ret < 0)\r\ngoto err;\r\nenvelope_detector_comp_latch(env);\r\nret = iio_write_channel_raw(env->dac, env->level);\r\nif (ret < 0)\r\ngoto err;\r\nschedule_delayed_work(&env->comp_timeout,\r\nmsecs_to_jiffies(env->comp_interval));\r\nreturn;\r\nerr:\r\nenv->level = ret;\r\ncomplete(&env->done);\r\n}\r\nstatic void envelope_detector_timeout(struct work_struct *work)\r\n{\r\nstruct envelope *env = container_of(work, struct envelope,\r\ncomp_timeout.work);\r\nif (!envelope_detector_comp_latch(env) ^ !env->invert)\r\nenv->low = env->level;\r\nelse\r\nenv->high = env->level;\r\nenvelope_detector_setup_compare(env);\r\n}\r\nstatic int envelope_detector_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct envelope *env = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&env->read_lock);\r\nenv->high = env->dac_max + env->invert;\r\nenv->low = -1 + env->invert;\r\nenvelope_detector_setup_compare(env);\r\nwait_for_completion(&env->done);\r\nif (env->level < 0) {\r\nret = env->level;\r\ngoto err_unlock;\r\n}\r\n*val = env->invert ? env->dac_max - env->level : env->level;\r\nmutex_unlock(&env->read_lock);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nreturn iio_read_channel_scale(env->dac, val, val2);\r\n}\r\nreturn -EINVAL;\r\nerr_unlock:\r\nmutex_unlock(&env->read_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t envelope_show_invert(struct iio_dev *indio_dev,\r\nuintptr_t private,\r\nstruct iio_chan_spec const *ch, char *buf)\r\n{\r\nstruct envelope *env = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%u\n", env->invert);\r\n}\r\nstatic ssize_t envelope_store_invert(struct iio_dev *indio_dev,\r\nuintptr_t private,\r\nstruct iio_chan_spec const *ch,\r\nconst char *buf, size_t len)\r\n{\r\nstruct envelope *env = iio_priv(indio_dev);\r\nunsigned long invert;\r\nint ret;\r\nu32 trigger;\r\nret = kstrtoul(buf, 0, &invert);\r\nif (ret < 0)\r\nreturn ret;\r\nif (invert > 1)\r\nreturn -EINVAL;\r\ntrigger = invert ? env->comp_irq_trigger_inv : env->comp_irq_trigger;\r\nmutex_lock(&env->read_lock);\r\nif (invert != env->invert)\r\nret = irq_set_irq_type(env->comp_irq, trigger);\r\nif (!ret) {\r\nenv->invert = invert;\r\nret = len;\r\n}\r\nmutex_unlock(&env->read_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t envelope_show_comp_interval(struct iio_dev *indio_dev,\r\nuintptr_t private,\r\nstruct iio_chan_spec const *ch,\r\nchar *buf)\r\n{\r\nstruct envelope *env = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%u\n", env->comp_interval);\r\n}\r\nstatic ssize_t envelope_store_comp_interval(struct iio_dev *indio_dev,\r\nuintptr_t private,\r\nstruct iio_chan_spec const *ch,\r\nconst char *buf, size_t len)\r\n{\r\nstruct envelope *env = iio_priv(indio_dev);\r\nunsigned long interval;\r\nint ret;\r\nret = kstrtoul(buf, 0, &interval);\r\nif (ret < 0)\r\nreturn ret;\r\nif (interval > 1000)\r\nreturn -EINVAL;\r\nmutex_lock(&env->read_lock);\r\nenv->comp_interval = interval;\r\nmutex_unlock(&env->read_lock);\r\nreturn len;\r\n}\r\nstatic int envelope_detector_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct iio_dev *indio_dev;\r\nstruct envelope *env;\r\nenum iio_chan_type type;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(*env));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, indio_dev);\r\nenv = iio_priv(indio_dev);\r\nenv->comp_interval = 50;\r\nspin_lock_init(&env->comp_lock);\r\nmutex_init(&env->read_lock);\r\ninit_completion(&env->done);\r\nINIT_DELAYED_WORK(&env->comp_timeout, envelope_detector_timeout);\r\nindio_dev->name = dev_name(dev);\r\nindio_dev->dev.parent = dev;\r\nindio_dev->dev.of_node = dev->of_node;\r\nindio_dev->info = &envelope_detector_info;\r\nindio_dev->channels = &envelope_detector_iio_channel;\r\nindio_dev->num_channels = 1;\r\nenv->dac = devm_iio_channel_get(dev, "dac");\r\nif (IS_ERR(env->dac)) {\r\nif (PTR_ERR(env->dac) != -EPROBE_DEFER)\r\ndev_err(dev, "failed to get dac input channel\n");\r\nreturn PTR_ERR(env->dac);\r\n}\r\nenv->comp_irq = platform_get_irq_byname(pdev, "comp");\r\nif (env->comp_irq < 0) {\r\nif (env->comp_irq != -EPROBE_DEFER)\r\ndev_err(dev, "failed to get compare interrupt\n");\r\nreturn env->comp_irq;\r\n}\r\nret = devm_request_irq(dev, env->comp_irq, envelope_detector_comp_isr,\r\n0, "envelope-detector", env);\r\nif (ret) {\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(dev, "failed to request interrupt\n");\r\nreturn ret;\r\n}\r\nenv->comp_irq_trigger = irq_get_trigger_type(env->comp_irq);\r\nif (env->comp_irq_trigger & IRQF_TRIGGER_RISING)\r\nenv->comp_irq_trigger_inv |= IRQF_TRIGGER_FALLING;\r\nif (env->comp_irq_trigger & IRQF_TRIGGER_FALLING)\r\nenv->comp_irq_trigger_inv |= IRQF_TRIGGER_RISING;\r\nif (env->comp_irq_trigger & IRQF_TRIGGER_HIGH)\r\nenv->comp_irq_trigger_inv |= IRQF_TRIGGER_LOW;\r\nif (env->comp_irq_trigger & IRQF_TRIGGER_LOW)\r\nenv->comp_irq_trigger_inv |= IRQF_TRIGGER_HIGH;\r\nret = iio_get_channel_type(env->dac, &type);\r\nif (ret < 0)\r\nreturn ret;\r\nif (type != IIO_VOLTAGE) {\r\ndev_err(dev, "dac is of the wrong type\n");\r\nreturn -EINVAL;\r\n}\r\nret = iio_read_max_channel_raw(env->dac, &env->dac_max);\r\nif (ret < 0) {\r\ndev_err(dev, "dac does not indicate its raw maximum value\n");\r\nreturn ret;\r\n}\r\nreturn devm_iio_device_register(dev, indio_dev);\r\n}
