static int usb_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs, int num)\r\n{\r\nunsigned char *pstatus;\r\nstruct i2c_msg *pmsg;\r\nint i, ret;\r\ndev_dbg(&adapter->dev, "master xfer %d messages:\n", num);\r\npstatus = kmalloc(sizeof(*pstatus), GFP_KERNEL);\r\nif (!pstatus)\r\nreturn -ENOMEM;\r\nfor (i = 0 ; i < num ; i++) {\r\nint cmd = CMD_I2C_IO;\r\nif (i == 0)\r\ncmd |= CMD_I2C_IO_BEGIN;\r\nif (i == num-1)\r\ncmd |= CMD_I2C_IO_END;\r\npmsg = &msgs[i];\r\ndev_dbg(&adapter->dev,\r\n" %d: %s (flags %d) %d bytes to 0x%02x\n",\r\ni, pmsg->flags & I2C_M_RD ? "read" : "write",\r\npmsg->flags, pmsg->len, pmsg->addr);\r\nif (pmsg->flags & I2C_M_RD) {\r\nif (usb_read(adapter, cmd,\r\npmsg->flags, pmsg->addr,\r\npmsg->buf, pmsg->len) != pmsg->len) {\r\ndev_err(&adapter->dev,\r\n"failure reading data\n");\r\nret = -EREMOTEIO;\r\ngoto out;\r\n}\r\n} else {\r\nif (usb_write(adapter, cmd,\r\npmsg->flags, pmsg->addr,\r\npmsg->buf, pmsg->len) != pmsg->len) {\r\ndev_err(&adapter->dev,\r\n"failure writing data\n");\r\nret = -EREMOTEIO;\r\ngoto out;\r\n}\r\n}\r\nif (usb_read(adapter, CMD_GET_STATUS, 0, 0, pstatus, 1) != 1) {\r\ndev_err(&adapter->dev, "failure reading status\n");\r\nret = -EREMOTEIO;\r\ngoto out;\r\n}\r\ndev_dbg(&adapter->dev, " status = %d\n", *pstatus);\r\nif (*pstatus == STATUS_ADDRESS_NAK) {\r\nret = -EREMOTEIO;\r\ngoto out;\r\n}\r\n}\r\nret = i;\r\nout:\r\nkfree(pstatus);\r\nreturn ret;\r\n}\r\nstatic u32 usb_func(struct i2c_adapter *adapter)\r\n{\r\n__le32 *pfunc;\r\nu32 ret;\r\npfunc = kmalloc(sizeof(*pfunc), GFP_KERNEL);\r\nif (!pfunc || usb_read(adapter, CMD_GET_FUNC, 0, 0, pfunc,\r\nsizeof(*pfunc)) != sizeof(*pfunc)) {\r\ndev_err(&adapter->dev, "failure reading functionality\n");\r\nret = 0;\r\ngoto out;\r\n}\r\nret = le32_to_cpup(pfunc);\r\nout:\r\nkfree(pfunc);\r\nreturn ret;\r\n}\r\nstatic int usb_read(struct i2c_adapter *adapter, int cmd,\r\nint value, int index, void *data, int len)\r\n{\r\nstruct i2c_tiny_usb *dev = (struct i2c_tiny_usb *)adapter->algo_data;\r\nvoid *dmadata = kmalloc(len, GFP_KERNEL);\r\nint ret;\r\nif (!dmadata)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(dev->usb_dev, usb_rcvctrlpipe(dev->usb_dev, 0),\r\ncmd, USB_TYPE_VENDOR | USB_RECIP_INTERFACE |\r\nUSB_DIR_IN, value, index, dmadata, len, 2000);\r\nmemcpy(data, dmadata, len);\r\nkfree(dmadata);\r\nreturn ret;\r\n}\r\nstatic int usb_write(struct i2c_adapter *adapter, int cmd,\r\nint value, int index, void *data, int len)\r\n{\r\nstruct i2c_tiny_usb *dev = (struct i2c_tiny_usb *)adapter->algo_data;\r\nvoid *dmadata = kmemdup(data, len, GFP_KERNEL);\r\nint ret;\r\nif (!dmadata)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(dev->usb_dev, usb_sndctrlpipe(dev->usb_dev, 0),\r\ncmd, USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\nvalue, index, dmadata, len, 2000);\r\nkfree(dmadata);\r\nreturn ret;\r\n}\r\nstatic void i2c_tiny_usb_free(struct i2c_tiny_usb *dev)\r\n{\r\nusb_put_dev(dev->usb_dev);\r\nkfree(dev);\r\n}\r\nstatic int i2c_tiny_usb_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct i2c_tiny_usb *dev;\r\nint retval = -ENOMEM;\r\nu16 version;\r\ndev_dbg(&interface->dev, "probing usb device\n");\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\ngoto error;\r\n}\r\ndev->usb_dev = usb_get_dev(interface_to_usbdev(interface));\r\ndev->interface = interface;\r\nusb_set_intfdata(interface, dev);\r\nversion = le16_to_cpu(dev->usb_dev->descriptor.bcdDevice);\r\ndev_info(&interface->dev,\r\n"version %x.%02x found at bus %03d address %03d\n",\r\nversion >> 8, version & 0xff,\r\ndev->usb_dev->bus->busnum, dev->usb_dev->devnum);\r\ndev->adapter.owner = THIS_MODULE;\r\ndev->adapter.class = I2C_CLASS_HWMON;\r\ndev->adapter.algo = &usb_algorithm;\r\ndev->adapter.algo_data = dev;\r\nsnprintf(dev->adapter.name, sizeof(dev->adapter.name),\r\n"i2c-tiny-usb at bus %03d device %03d",\r\ndev->usb_dev->bus->busnum, dev->usb_dev->devnum);\r\nif (usb_write(&dev->adapter, CMD_SET_DELAY, delay, 0, NULL, 0) != 0) {\r\ndev_err(&dev->adapter.dev,\r\n"failure setting delay to %dus\n", delay);\r\nretval = -EIO;\r\ngoto error;\r\n}\r\ndev->adapter.dev.parent = &dev->interface->dev;\r\ni2c_add_adapter(&dev->adapter);\r\ndev_info(&dev->adapter.dev, "connected i2c-tiny-usb device\n");\r\nreturn 0;\r\nerror:\r\nif (dev)\r\ni2c_tiny_usb_free(dev);\r\nreturn retval;\r\n}\r\nstatic void i2c_tiny_usb_disconnect(struct usb_interface *interface)\r\n{\r\nstruct i2c_tiny_usb *dev = usb_get_intfdata(interface);\r\ni2c_del_adapter(&dev->adapter);\r\nusb_set_intfdata(interface, NULL);\r\ni2c_tiny_usb_free(dev);\r\ndev_dbg(&interface->dev, "disconnected\n");\r\n}
