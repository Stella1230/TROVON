static void _rtl92c_enable_fw_download(struct ieee80211_hw *hw, bool enable)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8192CU) {\r\nu32 value32 = rtl_read_dword(rtlpriv, REG_MCUFWDL);\r\nif (enable)\r\nvalue32 |= MCUFWDL_EN;\r\nelse\r\nvalue32 &= ~MCUFWDL_EN;\r\nrtl_write_dword(rtlpriv, REG_MCUFWDL, value32);\r\n} else if (rtlhal->hw_type == HARDWARE_TYPE_RTL8192CE) {\r\nu8 tmp;\r\nif (enable) {\r\ntmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1,\r\ntmp | 0x04);\r\ntmp = rtl_read_byte(rtlpriv, REG_MCUFWDL);\r\nrtl_write_byte(rtlpriv, REG_MCUFWDL, tmp | 0x01);\r\ntmp = rtl_read_byte(rtlpriv, REG_MCUFWDL + 2);\r\nrtl_write_byte(rtlpriv, REG_MCUFWDL + 2, tmp & 0xf7);\r\n} else {\r\ntmp = rtl_read_byte(rtlpriv, REG_MCUFWDL);\r\nrtl_write_byte(rtlpriv, REG_MCUFWDL, tmp & 0xfe);\r\nrtl_write_byte(rtlpriv, REG_MCUFWDL + 1, 0x00);\r\n}\r\n}\r\n}\r\nstatic void _rtl92c_write_fw(struct ieee80211_hw *hw,\r\nenum version_8192c version, u8 *buffer, u32 size)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nbool is_version_b;\r\nu8 *bufferptr = (u8 *)buffer;\r\nRT_TRACE(rtlpriv, COMP_FW, DBG_TRACE, "FW size is %d bytes,\n", size);\r\nis_version_b = IS_NORMAL_CHIP(version);\r\nif (is_version_b) {\r\nu32 pageNums, remainsize;\r\nu32 page, offset;\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8192CE)\r\nrtl_fill_dummy(bufferptr, &size);\r\npageNums = size / FW_8192C_PAGE_SIZE;\r\nremainsize = size % FW_8192C_PAGE_SIZE;\r\nif (pageNums > 4)\r\npr_err("Page numbers should not greater then 4\n");\r\nfor (page = 0; page < pageNums; page++) {\r\noffset = page * FW_8192C_PAGE_SIZE;\r\nrtl_fw_page_write(hw, page, (bufferptr + offset),\r\nFW_8192C_PAGE_SIZE);\r\n}\r\nif (remainsize) {\r\noffset = pageNums * FW_8192C_PAGE_SIZE;\r\npage = pageNums;\r\nrtl_fw_page_write(hw, page, (bufferptr + offset),\r\nremainsize);\r\n}\r\n} else {\r\nrtl_fw_block_write(hw, buffer, size);\r\n}\r\n}\r\nstatic int _rtl92c_fw_free_to_go(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nint err = -EIO;\r\nu32 counter = 0;\r\nu32 value32;\r\ndo {\r\nvalue32 = rtl_read_dword(rtlpriv, REG_MCUFWDL);\r\n} while ((counter++ < FW_8192C_POLLING_TIMEOUT_COUNT) &&\r\n(!(value32 & FWDL_ChkSum_rpt)));\r\nif (counter >= FW_8192C_POLLING_TIMEOUT_COUNT) {\r\npr_err("chksum report fail! REG_MCUFWDL:0x%08x .\n",\r\nvalue32);\r\ngoto exit;\r\n}\r\nvalue32 = rtl_read_dword(rtlpriv, REG_MCUFWDL);\r\nvalue32 |= MCUFWDL_RDY;\r\nvalue32 &= ~WINTINI_RDY;\r\nrtl_write_dword(rtlpriv, REG_MCUFWDL, value32);\r\ncounter = 0;\r\ndo {\r\nvalue32 = rtl_read_dword(rtlpriv, REG_MCUFWDL);\r\nif (value32 & WINTINI_RDY)\r\nreturn 0;\r\nmdelay(FW_8192C_POLLING_DELAY);\r\n} while (counter++ < FW_8192C_POLLING_TIMEOUT_COUNT);\r\npr_err("Polling FW ready fail! REG_MCUFWDL:0x%08x.\n",\r\nvalue32);\r\nexit:\r\nreturn err;\r\n}\r\nint rtl92c_download_fw(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtlwifi_firmware_header *pfwheader;\r\nu8 *pfwdata;\r\nu32 fwsize;\r\nint err;\r\nenum version_8192c version = rtlhal->version;\r\nif (!rtlhal->pfirmware)\r\nreturn 1;\r\npfwheader = (struct rtlwifi_firmware_header *)rtlhal->pfirmware;\r\npfwdata = (u8 *)rtlhal->pfirmware;\r\nfwsize = rtlhal->fwsize;\r\nif (IS_FW_HEADER_EXIST(pfwheader)) {\r\nRT_TRACE(rtlpriv, COMP_FW, DBG_DMESG,\r\n"Firmware Version(%d), Signature(%#x),Size(%d)\n",\r\npfwheader->version, pfwheader->signature,\r\n(int)sizeof(struct rtlwifi_firmware_header));\r\nrtlhal->fw_version = le16_to_cpu(pfwheader->version);\r\nrtlhal->fw_subversion = pfwheader->subversion;\r\npfwdata = pfwdata + sizeof(struct rtlwifi_firmware_header);\r\nfwsize = fwsize - sizeof(struct rtlwifi_firmware_header);\r\n}\r\n_rtl92c_enable_fw_download(hw, true);\r\n_rtl92c_write_fw(hw, version, pfwdata, fwsize);\r\n_rtl92c_enable_fw_download(hw, false);\r\nerr = _rtl92c_fw_free_to_go(hw);\r\nif (err)\r\npr_err("Firmware is not ready to run!\n");\r\nreturn 0;\r\n}\r\nstatic bool _rtl92c_check_fw_read_last_h2c(struct ieee80211_hw *hw, u8 boxnum)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 val_hmetfr, val_mcutst_1;\r\nbool result = false;\r\nval_hmetfr = rtl_read_byte(rtlpriv, REG_HMETFR);\r\nval_mcutst_1 = rtl_read_byte(rtlpriv, (REG_MCUTST_1 + boxnum));\r\nif (((val_hmetfr >> boxnum) & BIT(0)) == 0 && val_mcutst_1 == 0)\r\nresult = true;\r\nreturn result;\r\n}\r\nstatic void _rtl92c_fill_h2c_command(struct ieee80211_hw *hw,\r\nu8 element_id, u32 cmd_len, u8 *cmdbuffer)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu8 boxnum;\r\nu16 box_reg = 0, box_extreg = 0;\r\nu8 u1b_tmp;\r\nbool isfw_read = false;\r\nu8 buf_index = 0;\r\nbool bwrite_sucess = false;\r\nu8 wait_h2c_limmit = 100;\r\nu8 wait_writeh2c_limmit = 100;\r\nu8 boxcontent[4], boxextcontent[2];\r\nu32 h2c_waitcounter = 0;\r\nunsigned long flag;\r\nu8 idx;\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD, "come in\n");\r\nwhile (true) {\r\nspin_lock_irqsave(&rtlpriv->locks.h2c_lock, flag);\r\nif (rtlhal->h2c_setinprogress) {\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD,\r\n"H2C set in progress! Wait to set..element_id(%d).\n",\r\nelement_id);\r\nwhile (rtlhal->h2c_setinprogress) {\r\nspin_unlock_irqrestore(&rtlpriv->locks.h2c_lock,\r\nflag);\r\nh2c_waitcounter++;\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD,\r\n"Wait 100 us (%d times)...\n",\r\nh2c_waitcounter);\r\nudelay(100);\r\nif (h2c_waitcounter > 1000)\r\nreturn;\r\nspin_lock_irqsave(&rtlpriv->locks.h2c_lock,\r\nflag);\r\n}\r\nspin_unlock_irqrestore(&rtlpriv->locks.h2c_lock, flag);\r\n} else {\r\nrtlhal->h2c_setinprogress = true;\r\nspin_unlock_irqrestore(&rtlpriv->locks.h2c_lock, flag);\r\nbreak;\r\n}\r\n}\r\nwhile (!bwrite_sucess) {\r\nwait_writeh2c_limmit--;\r\nif (wait_writeh2c_limmit == 0) {\r\npr_err("Write H2C fail because no trigger for FW INT!\n");\r\nbreak;\r\n}\r\nboxnum = rtlhal->last_hmeboxnum;\r\nswitch (boxnum) {\r\ncase 0:\r\nbox_reg = REG_HMEBOX_0;\r\nbox_extreg = REG_HMEBOX_EXT_0;\r\nbreak;\r\ncase 1:\r\nbox_reg = REG_HMEBOX_1;\r\nbox_extreg = REG_HMEBOX_EXT_1;\r\nbreak;\r\ncase 2:\r\nbox_reg = REG_HMEBOX_2;\r\nbox_extreg = REG_HMEBOX_EXT_2;\r\nbreak;\r\ncase 3:\r\nbox_reg = REG_HMEBOX_3;\r\nbox_extreg = REG_HMEBOX_EXT_3;\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,\r\n"switch case %#x not processed\n", boxnum);\r\nbreak;\r\n}\r\nisfw_read = _rtl92c_check_fw_read_last_h2c(hw, boxnum);\r\nwhile (!isfw_read) {\r\nwait_h2c_limmit--;\r\nif (wait_h2c_limmit == 0) {\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD,\r\n"Waiting too long for FW read clear HMEBox(%d)!\n",\r\nboxnum);\r\nbreak;\r\n}\r\nudelay(10);\r\nisfw_read = _rtl92c_check_fw_read_last_h2c(hw, boxnum);\r\nu1b_tmp = rtl_read_byte(rtlpriv, 0x1BF);\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD,\r\n"Waiting for FW read clear HMEBox(%d)!!! 0x1BF = %2x\n",\r\nboxnum, u1b_tmp);\r\n}\r\nif (!isfw_read) {\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD,\r\n"Write H2C register BOX[%d] fail!!!!! Fw do not read.\n",\r\nboxnum);\r\nbreak;\r\n}\r\nmemset(boxcontent, 0, sizeof(boxcontent));\r\nmemset(boxextcontent, 0, sizeof(boxextcontent));\r\nboxcontent[0] = element_id;\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD,\r\n"Write element_id box_reg(%4x) = %2x\n",\r\nbox_reg, element_id);\r\nswitch (cmd_len) {\r\ncase 1:\r\nboxcontent[0] &= ~(BIT(7));\r\nmemcpy((u8 *)(boxcontent) + 1,\r\ncmdbuffer + buf_index, 1);\r\nfor (idx = 0; idx < 4; idx++) {\r\nrtl_write_byte(rtlpriv, box_reg + idx,\r\nboxcontent[idx]);\r\n}\r\nbreak;\r\ncase 2:\r\nboxcontent[0] &= ~(BIT(7));\r\nmemcpy((u8 *)(boxcontent) + 1,\r\ncmdbuffer + buf_index, 2);\r\nfor (idx = 0; idx < 4; idx++) {\r\nrtl_write_byte(rtlpriv, box_reg + idx,\r\nboxcontent[idx]);\r\n}\r\nbreak;\r\ncase 3:\r\nboxcontent[0] &= ~(BIT(7));\r\nmemcpy((u8 *)(boxcontent) + 1,\r\ncmdbuffer + buf_index, 3);\r\nfor (idx = 0; idx < 4; idx++) {\r\nrtl_write_byte(rtlpriv, box_reg + idx,\r\nboxcontent[idx]);\r\n}\r\nbreak;\r\ncase 4:\r\nboxcontent[0] |= (BIT(7));\r\nmemcpy((u8 *)(boxextcontent),\r\ncmdbuffer + buf_index, 2);\r\nmemcpy((u8 *)(boxcontent) + 1,\r\ncmdbuffer + buf_index + 2, 2);\r\nfor (idx = 0; idx < 2; idx++) {\r\nrtl_write_byte(rtlpriv, box_extreg + idx,\r\nboxextcontent[idx]);\r\n}\r\nfor (idx = 0; idx < 4; idx++) {\r\nrtl_write_byte(rtlpriv, box_reg + idx,\r\nboxcontent[idx]);\r\n}\r\nbreak;\r\ncase 5:\r\nboxcontent[0] |= (BIT(7));\r\nmemcpy((u8 *)(boxextcontent),\r\ncmdbuffer + buf_index, 2);\r\nmemcpy((u8 *)(boxcontent) + 1,\r\ncmdbuffer + buf_index + 2, 3);\r\nfor (idx = 0; idx < 2; idx++) {\r\nrtl_write_byte(rtlpriv, box_extreg + idx,\r\nboxextcontent[idx]);\r\n}\r\nfor (idx = 0; idx < 4; idx++) {\r\nrtl_write_byte(rtlpriv, box_reg + idx,\r\nboxcontent[idx]);\r\n}\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,\r\n"switch case %#x not processed\n", cmd_len);\r\nbreak;\r\n}\r\nbwrite_sucess = true;\r\nrtlhal->last_hmeboxnum = boxnum + 1;\r\nif (rtlhal->last_hmeboxnum == 4)\r\nrtlhal->last_hmeboxnum = 0;\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD,\r\n"pHalData->last_hmeboxnum = %d\n",\r\nrtlhal->last_hmeboxnum);\r\n}\r\nspin_lock_irqsave(&rtlpriv->locks.h2c_lock, flag);\r\nrtlhal->h2c_setinprogress = false;\r\nspin_unlock_irqrestore(&rtlpriv->locks.h2c_lock, flag);\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD, "go out\n");\r\n}\r\nvoid rtl92c_fill_h2c_cmd(struct ieee80211_hw *hw,\r\nu8 element_id, u32 cmd_len, u8 *cmdbuffer)\r\n{\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu32 tmp_cmdbuf[2];\r\nif (!rtlhal->fw_ready) {\r\nWARN_ONCE(true,\r\n"rtl8192c-common: return H2C cmd because of Fw download fail!!!\n");\r\nreturn;\r\n}\r\nmemset(tmp_cmdbuf, 0, 8);\r\nmemcpy(tmp_cmdbuf, cmdbuffer, cmd_len);\r\n_rtl92c_fill_h2c_command(hw, element_id, cmd_len, (u8 *)&tmp_cmdbuf);\r\nreturn;\r\n}\r\nvoid rtl92c_firmware_selfreset(struct ieee80211_hw *hw)\r\n{\r\nu8 u1b_tmp;\r\nu8 delay = 100;\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nrtl_write_byte(rtlpriv, REG_HMETFR + 3, 0x20);\r\nu1b_tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\r\nwhile (u1b_tmp & BIT(2)) {\r\ndelay--;\r\nif (delay == 0) {\r\nWARN_ONCE(true, "rtl8192c-common: 8051 reset fail.\n");\r\nbreak;\r\n}\r\nudelay(50);\r\nu1b_tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\r\n}\r\n}\r\nvoid rtl92c_set_fw_pwrmode_cmd(struct ieee80211_hw *hw, u8 mode)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 u1_h2c_set_pwrmode[3] = { 0 };\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "FW LPS mode = %d\n", mode);\r\nSET_H2CCMD_PWRMODE_PARM_MODE(u1_h2c_set_pwrmode, mode);\r\nSET_H2CCMD_PWRMODE_PARM_SMART_PS(u1_h2c_set_pwrmode,\r\n(rtlpriv->mac80211.p2p) ? ppsc->smart_ps : 1);\r\nSET_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(u1_h2c_set_pwrmode,\r\nppsc->reg_max_lps_awakeintvl);\r\nRT_PRINT_DATA(rtlpriv, COMP_CMD, DBG_DMESG,\r\n"rtl92c_set_fw_rsvdpagepkt(): u1_h2c_set_pwrmode\n",\r\nu1_h2c_set_pwrmode, 3);\r\nrtl92c_fill_h2c_cmd(hw, H2C_SETPWRMODE, 3, u1_h2c_set_pwrmode);\r\n}\r\nvoid rtl92c_set_fw_rsvdpagepkt(struct ieee80211_hw *hw,\r\nbool (*cmd_send_packet)(struct ieee80211_hw *, struct sk_buff *))\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct sk_buff *skb = NULL;\r\nu32 totalpacketlen;\r\nbool rtstatus;\r\nu8 u1rsvdpageloc[3] = { 0 };\r\nbool b_dlok = false;\r\nu8 *beacon;\r\nu8 *p_pspoll;\r\nu8 *nullfunc;\r\nu8 *p_probersp;\r\nbeacon = &reserved_page_packet[BEACON_PG * 128];\r\nSET_80211_HDR_ADDRESS2(beacon, mac->mac_addr);\r\nSET_80211_HDR_ADDRESS3(beacon, mac->bssid);\r\np_pspoll = &reserved_page_packet[PSPOLL_PG * 128];\r\nSET_80211_PS_POLL_AID(p_pspoll, (mac->assoc_id | 0xc000));\r\nSET_80211_PS_POLL_BSSID(p_pspoll, mac->bssid);\r\nSET_80211_PS_POLL_TA(p_pspoll, mac->mac_addr);\r\nSET_H2CCMD_RSVDPAGE_LOC_PSPOLL(u1rsvdpageloc, PSPOLL_PG);\r\nnullfunc = &reserved_page_packet[NULL_PG * 128];\r\nSET_80211_HDR_ADDRESS1(nullfunc, mac->bssid);\r\nSET_80211_HDR_ADDRESS2(nullfunc, mac->mac_addr);\r\nSET_80211_HDR_ADDRESS3(nullfunc, mac->bssid);\r\nSET_H2CCMD_RSVDPAGE_LOC_NULL_DATA(u1rsvdpageloc, NULL_PG);\r\np_probersp = &reserved_page_packet[PROBERSP_PG * 128];\r\nSET_80211_HDR_ADDRESS1(p_probersp, mac->bssid);\r\nSET_80211_HDR_ADDRESS2(p_probersp, mac->mac_addr);\r\nSET_80211_HDR_ADDRESS3(p_probersp, mac->bssid);\r\nSET_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(u1rsvdpageloc, PROBERSP_PG);\r\ntotalpacketlen = TOTAL_RESERVED_PKT_LEN;\r\nRT_PRINT_DATA(rtlpriv, COMP_CMD, DBG_LOUD,\r\n"rtl92c_set_fw_rsvdpagepkt(): HW_VAR_SET_TX_CMD: ALL\n",\r\n&reserved_page_packet[0], totalpacketlen);\r\nRT_PRINT_DATA(rtlpriv, COMP_CMD, DBG_DMESG,\r\n"rtl92c_set_fw_rsvdpagepkt(): HW_VAR_SET_TX_CMD: ALL\n",\r\nu1rsvdpageloc, 3);\r\nskb = dev_alloc_skb(totalpacketlen);\r\nskb_put_data(skb, &reserved_page_packet, totalpacketlen);\r\nif (cmd_send_packet)\r\nrtstatus = cmd_send_packet(hw, skb);\r\nelse\r\nrtstatus = rtl_cmd_send_packet(hw, skb);\r\nif (rtstatus)\r\nb_dlok = true;\r\nif (b_dlok) {\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"Set RSVD page location to Fw.\n");\r\nRT_PRINT_DATA(rtlpriv, COMP_CMD, DBG_DMESG,\r\n"H2C_RSVDPAGE:\n",\r\nu1rsvdpageloc, 3);\r\nrtl92c_fill_h2c_cmd(hw, H2C_RSVDPAGE,\r\nsizeof(u1rsvdpageloc), u1rsvdpageloc);\r\n} else\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,\r\n"Set RSVD page location to Fw FAIL!!!!!!.\n");\r\n}\r\nvoid rtl92c_set_fw_joinbss_report_cmd(struct ieee80211_hw *hw, u8 mstatus)\r\n{\r\nu8 u1_joinbssrpt_parm[1] = { 0 };\r\nSET_H2CCMD_JOINBSSRPT_PARM_OPMODE(u1_joinbssrpt_parm, mstatus);\r\nrtl92c_fill_h2c_cmd(hw, H2C_JOINBSSRPT, 1, u1_joinbssrpt_parm);\r\n}\r\nstatic void rtl92c_set_p2p_ctw_period_cmd(struct ieee80211_hw *hw, u8 ctwindow)\r\n{\r\nu8 u1_ctwindow_period[1] = { ctwindow};\r\nrtl92c_fill_h2c_cmd(hw, H2C_P2P_PS_CTW_CMD, 1, u1_ctwindow_period);\r\n}\r\nstatic void set_noa_data(struct rtl_priv *rtlpriv,\r\nstruct rtl_p2p_ps_info *p2pinfo,\r\nstruct p2p_ps_offload_t *p2p_ps_offload)\r\n{\r\nint i;\r\nu32 start_time, tsf_low;\r\nfor (i = 0 ; i < p2pinfo->noa_num ; i++) {\r\nrtl_write_byte(rtlpriv, 0x5cf, (i << 4));\r\nif (i == 0)\r\np2p_ps_offload->noa0_en = 1;\r\nelse\r\np2p_ps_offload->noa1_en = 1;\r\nrtl_write_dword(rtlpriv, 0x5E0,\r\np2pinfo->noa_duration[i]);\r\nrtl_write_dword(rtlpriv, 0x5E4,\r\np2pinfo->noa_interval[i]);\r\ntsf_low = rtl_read_dword(rtlpriv, REG_TSFTR);\r\nstart_time = p2pinfo->noa_start_time[i];\r\nif (p2pinfo->noa_count_type[i] != 1) {\r\nwhile (start_time <= (tsf_low+(50*1024))) {\r\nstart_time += p2pinfo->noa_interval[i];\r\nif (p2pinfo->noa_count_type[i] != 255)\r\np2pinfo->noa_count_type[i]--;\r\n}\r\n}\r\nrtl_write_dword(rtlpriv, 0x5E8, start_time);\r\nrtl_write_dword(rtlpriv, 0x5EC,\r\np2pinfo->noa_count_type[i]);\r\n}\r\n}\r\nvoid rtl92c_set_p2p_ps_offload_cmd(struct ieee80211_hw *hw, u8 p2p_ps_state)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_ps_ctl *rtlps = rtl_psc(rtl_priv(hw));\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtl_p2p_ps_info *p2pinfo = &(rtlps->p2p_ps_info);\r\nstruct p2p_ps_offload_t *p2p_ps_offload = &rtlhal->p2p_ps_offload;\r\nu16 ctwindow;\r\nswitch (p2p_ps_state) {\r\ncase P2P_PS_DISABLE:\r\nRT_TRACE(rtlpriv, COMP_FW, DBG_LOUD,\r\n"P2P_PS_DISABLE\n");\r\nmemset(p2p_ps_offload, 0, sizeof(*p2p_ps_offload));\r\nbreak;\r\ncase P2P_PS_ENABLE:\r\nRT_TRACE(rtlpriv, COMP_FW, DBG_LOUD,\r\n"P2P_PS_ENABLE\n");\r\nif (p2pinfo->ctwindow > 0) {\r\np2p_ps_offload->ctwindow_en = 1;\r\nctwindow = p2pinfo->ctwindow;\r\nrtl92c_set_p2p_ctw_period_cmd(hw, ctwindow);\r\n}\r\nset_noa_data(rtlpriv, p2pinfo, p2p_ps_offload);\r\nif ((p2pinfo->opp_ps == 1) || (p2pinfo->noa_num > 0)) {\r\nrtl_write_byte(rtlpriv, REG_DUAL_TSF_RST,\r\nBIT(4));\r\np2p_ps_offload->offload_en = 1;\r\nif (P2P_ROLE_GO == rtlpriv->mac80211.p2p) {\r\np2p_ps_offload->role = 1;\r\np2p_ps_offload->allstasleep = 0;\r\n} else {\r\np2p_ps_offload->role = 0;\r\n}\r\np2p_ps_offload->discovery = 0;\r\n}\r\nbreak;\r\ncase P2P_PS_SCAN:\r\nRT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "P2P_PS_SCAN\n");\r\np2p_ps_offload->discovery = 1;\r\nbreak;\r\ncase P2P_PS_SCAN_DONE:\r\nRT_TRACE(rtlpriv, COMP_FW, DBG_LOUD,\r\n"P2P_PS_SCAN_DONE\n");\r\np2p_ps_offload->discovery = 0;\r\np2pinfo->p2p_ps_state = P2P_PS_ENABLE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nrtl92c_fill_h2c_cmd(hw, H2C_P2P_PS_OFFLOAD, 1, (u8 *)p2p_ps_offload);\r\n}
