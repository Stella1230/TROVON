static int guc_log_flush_complete(struct intel_guc *guc)\r\n{\r\nu32 action[] = {\r\nINTEL_GUC_ACTION_LOG_BUFFER_FILE_FLUSH_COMPLETE\r\n};\r\nreturn intel_guc_send(guc, action, ARRAY_SIZE(action));\r\n}\r\nstatic int guc_log_flush(struct intel_guc *guc)\r\n{\r\nu32 action[] = {\r\nINTEL_GUC_ACTION_FORCE_LOG_BUFFER_FLUSH,\r\n0\r\n};\r\nreturn intel_guc_send(guc, action, ARRAY_SIZE(action));\r\n}\r\nstatic int guc_log_control(struct intel_guc *guc, u32 control_val)\r\n{\r\nu32 action[] = {\r\nINTEL_GUC_ACTION_UK_LOG_ENABLE_LOGGING,\r\ncontrol_val\r\n};\r\nreturn intel_guc_send(guc, action, ARRAY_SIZE(action));\r\n}\r\nstatic int subbuf_start_callback(struct rchan_buf *buf,\r\nvoid *subbuf,\r\nvoid *prev_subbuf,\r\nsize_t prev_padding)\r\n{\r\nif (relay_buf_full(buf))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic struct dentry *create_buf_file_callback(const char *filename,\r\nstruct dentry *parent,\r\numode_t mode,\r\nstruct rchan_buf *buf,\r\nint *is_global)\r\n{\r\nstruct dentry *buf_file;\r\n*is_global = 1;\r\nif (!parent)\r\nreturn NULL;\r\nbuf_file = debugfs_create_file("guc_log", mode,\r\nparent, buf, &relay_file_operations);\r\nreturn buf_file;\r\n}\r\nstatic int remove_buf_file_callback(struct dentry *dentry)\r\n{\r\ndebugfs_remove(dentry);\r\nreturn 0;\r\n}\r\nstatic int guc_log_relay_file_create(struct intel_guc *guc)\r\n{\r\nstruct drm_i915_private *dev_priv = guc_to_i915(guc);\r\nstruct dentry *log_dir;\r\nint ret;\r\nif (i915.guc_log_level < 0)\r\nreturn 0;\r\nlog_dir = dev_priv->drm.primary->debugfs_root;\r\nif (!log_dir) {\r\nDRM_ERROR("Debugfs dir not available yet for GuC log file\n");\r\nreturn -ENODEV;\r\n}\r\nret = relay_late_setup_files(guc->log.runtime.relay_chan, "guc_log", log_dir);\r\nif (ret < 0 && ret != -EEXIST) {\r\nDRM_ERROR("Couldn't associate relay chan with file %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void guc_move_to_next_buf(struct intel_guc *guc)\r\n{\r\nsmp_wmb();\r\nrelay_reserve(guc->log.runtime.relay_chan, guc->log.vma->obj->base.size);\r\nrelay_flush(guc->log.runtime.relay_chan);\r\n}\r\nstatic void *guc_get_write_buffer(struct intel_guc *guc)\r\n{\r\nif (!guc->log.runtime.relay_chan)\r\nreturn NULL;\r\nreturn relay_reserve(guc->log.runtime.relay_chan, 0);\r\n}\r\nstatic bool guc_check_log_buf_overflow(struct intel_guc *guc,\r\nenum guc_log_buffer_type type,\r\nunsigned int full_cnt)\r\n{\r\nunsigned int prev_full_cnt = guc->log.prev_overflow_count[type];\r\nbool overflow = false;\r\nif (full_cnt != prev_full_cnt) {\r\noverflow = true;\r\nguc->log.prev_overflow_count[type] = full_cnt;\r\nguc->log.total_overflow_count[type] += full_cnt - prev_full_cnt;\r\nif (full_cnt < prev_full_cnt) {\r\nguc->log.total_overflow_count[type] += 16;\r\n}\r\nDRM_ERROR_RATELIMITED("GuC log buffer overflow\n");\r\n}\r\nreturn overflow;\r\n}\r\nstatic unsigned int guc_get_log_buffer_size(enum guc_log_buffer_type type)\r\n{\r\nswitch (type) {\r\ncase GUC_ISR_LOG_BUFFER:\r\nreturn (GUC_LOG_ISR_PAGES + 1) * PAGE_SIZE;\r\ncase GUC_DPC_LOG_BUFFER:\r\nreturn (GUC_LOG_DPC_PAGES + 1) * PAGE_SIZE;\r\ncase GUC_CRASH_DUMP_LOG_BUFFER:\r\nreturn (GUC_LOG_CRASH_PAGES + 1) * PAGE_SIZE;\r\ndefault:\r\nMISSING_CASE(type);\r\n}\r\nreturn 0;\r\n}\r\nstatic void guc_read_update_log_buffer(struct intel_guc *guc)\r\n{\r\nunsigned int buffer_size, read_offset, write_offset, bytes_to_copy, full_cnt;\r\nstruct guc_log_buffer_state *log_buf_state, *log_buf_snapshot_state;\r\nstruct guc_log_buffer_state log_buf_state_local;\r\nenum guc_log_buffer_type type;\r\nvoid *src_data, *dst_data;\r\nbool new_overflow;\r\nif (WARN_ON(!guc->log.runtime.buf_addr))\r\nreturn;\r\nlog_buf_state = src_data = guc->log.runtime.buf_addr;\r\nlog_buf_snapshot_state = dst_data = guc_get_write_buffer(guc);\r\nsrc_data += PAGE_SIZE;\r\ndst_data += PAGE_SIZE;\r\nfor (type = GUC_ISR_LOG_BUFFER; type < GUC_MAX_LOG_BUFFER; type++) {\r\nmemcpy(&log_buf_state_local, log_buf_state,\r\nsizeof(struct guc_log_buffer_state));\r\nbuffer_size = guc_get_log_buffer_size(type);\r\nread_offset = log_buf_state_local.read_ptr;\r\nwrite_offset = log_buf_state_local.sampled_write_ptr;\r\nfull_cnt = log_buf_state_local.buffer_full_cnt;\r\nguc->log.flush_count[type] += log_buf_state_local.flush_to_file;\r\nnew_overflow = guc_check_log_buf_overflow(guc, type, full_cnt);\r\nlog_buf_state->read_ptr = write_offset;\r\nlog_buf_state->flush_to_file = 0;\r\nlog_buf_state++;\r\nif (unlikely(!log_buf_snapshot_state))\r\ncontinue;\r\nmemcpy(log_buf_snapshot_state, &log_buf_state_local,\r\nsizeof(struct guc_log_buffer_state));\r\nlog_buf_snapshot_state->write_ptr = write_offset;\r\nlog_buf_snapshot_state++;\r\nif (unlikely(new_overflow)) {\r\nread_offset = 0;\r\nwrite_offset = buffer_size;\r\n} else if (unlikely((read_offset > buffer_size) ||\r\n(write_offset > buffer_size))) {\r\nDRM_ERROR("invalid log buffer state\n");\r\nread_offset = 0;\r\nwrite_offset = buffer_size;\r\n}\r\nif (read_offset > write_offset) {\r\ni915_memcpy_from_wc(dst_data, src_data, write_offset);\r\nbytes_to_copy = buffer_size - read_offset;\r\n} else {\r\nbytes_to_copy = write_offset - read_offset;\r\n}\r\ni915_memcpy_from_wc(dst_data + read_offset,\r\nsrc_data + read_offset, bytes_to_copy);\r\nsrc_data += buffer_size;\r\ndst_data += buffer_size;\r\n}\r\nif (log_buf_snapshot_state)\r\nguc_move_to_next_buf(guc);\r\nelse {\r\nDRM_ERROR_RATELIMITED("no sub-buffer to capture logs\n");\r\nguc->log.capture_miss_count++;\r\n}\r\n}\r\nstatic void capture_logs_work(struct work_struct *work)\r\n{\r\nstruct intel_guc *guc =\r\ncontainer_of(work, struct intel_guc, log.runtime.flush_work);\r\nguc_log_capture_logs(guc);\r\n}\r\nstatic bool guc_log_has_runtime(struct intel_guc *guc)\r\n{\r\nreturn guc->log.runtime.buf_addr != NULL;\r\n}\r\nstatic int guc_log_runtime_create(struct intel_guc *guc)\r\n{\r\nstruct drm_i915_private *dev_priv = guc_to_i915(guc);\r\nvoid *vaddr;\r\nstruct rchan *guc_log_relay_chan;\r\nsize_t n_subbufs, subbuf_size;\r\nint ret;\r\nlockdep_assert_held(&dev_priv->drm.struct_mutex);\r\nGEM_BUG_ON(guc_log_has_runtime(guc));\r\nret = i915_gem_object_set_to_wc_domain(guc->log.vma->obj, true);\r\nif (ret)\r\nreturn ret;\r\nvaddr = i915_gem_object_pin_map(guc->log.vma->obj, I915_MAP_WC);\r\nif (IS_ERR(vaddr)) {\r\nDRM_ERROR("Couldn't map log buffer pages %d\n", ret);\r\nreturn PTR_ERR(vaddr);\r\n}\r\nguc->log.runtime.buf_addr = vaddr;\r\nsubbuf_size = guc->log.vma->obj->base.size;\r\nn_subbufs = 8;\r\nguc_log_relay_chan = relay_open(NULL, NULL, subbuf_size,\r\nn_subbufs, &relay_callbacks, dev_priv);\r\nif (!guc_log_relay_chan) {\r\nDRM_ERROR("Couldn't create relay chan for GuC logging\n");\r\nret = -ENOMEM;\r\ngoto err_vaddr;\r\n}\r\nGEM_BUG_ON(guc_log_relay_chan->subbuf_size < subbuf_size);\r\nguc->log.runtime.relay_chan = guc_log_relay_chan;\r\nINIT_WORK(&guc->log.runtime.flush_work, capture_logs_work);\r\nguc->log.runtime.flush_wq = alloc_ordered_workqueue("i915-guc_log",\r\nWQ_HIGHPRI | WQ_FREEZABLE);\r\nif (!guc->log.runtime.flush_wq) {\r\nDRM_ERROR("Couldn't allocate the wq for GuC logging\n");\r\nret = -ENOMEM;\r\ngoto err_relaychan;\r\n}\r\nreturn 0;\r\nerr_relaychan:\r\nrelay_close(guc->log.runtime.relay_chan);\r\nerr_vaddr:\r\ni915_gem_object_unpin_map(guc->log.vma->obj);\r\nguc->log.runtime.buf_addr = NULL;\r\nreturn ret;\r\n}\r\nstatic void guc_log_runtime_destroy(struct intel_guc *guc)\r\n{\r\nif (!guc_log_has_runtime(guc))\r\nreturn;\r\ndestroy_workqueue(guc->log.runtime.flush_wq);\r\nrelay_close(guc->log.runtime.relay_chan);\r\ni915_gem_object_unpin_map(guc->log.vma->obj);\r\nguc->log.runtime.buf_addr = NULL;\r\n}\r\nstatic int guc_log_late_setup(struct intel_guc *guc)\r\n{\r\nstruct drm_i915_private *dev_priv = guc_to_i915(guc);\r\nint ret;\r\nlockdep_assert_held(&dev_priv->drm.struct_mutex);\r\nif (!guc_log_has_runtime(guc)) {\r\nret = guc_log_runtime_create(guc);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = guc_log_relay_file_create(guc);\r\nif (ret)\r\ngoto err_runtime;\r\nreturn 0;\r\nerr_runtime:\r\nguc_log_runtime_destroy(guc);\r\nerr:\r\ni915.guc_log_level = -1;\r\nreturn ret;\r\n}\r\nstatic void guc_log_capture_logs(struct intel_guc *guc)\r\n{\r\nstruct drm_i915_private *dev_priv = guc_to_i915(guc);\r\nguc_read_update_log_buffer(guc);\r\nintel_runtime_pm_get(dev_priv);\r\nguc_log_flush_complete(guc);\r\nintel_runtime_pm_put(dev_priv);\r\n}\r\nstatic void guc_flush_logs(struct intel_guc *guc)\r\n{\r\nstruct drm_i915_private *dev_priv = guc_to_i915(guc);\r\nif (!i915.enable_guc_submission || (i915.guc_log_level < 0))\r\nreturn;\r\ngen9_disable_guc_interrupts(dev_priv);\r\nflush_work(&guc->log.runtime.flush_work);\r\nguc_log_flush(guc);\r\nguc_log_capture_logs(guc);\r\n}\r\nint intel_guc_log_create(struct intel_guc *guc)\r\n{\r\nstruct i915_vma *vma;\r\nunsigned long offset;\r\nuint32_t size, flags;\r\nint ret;\r\nGEM_BUG_ON(guc->log.vma);\r\nif (i915.guc_log_level > GUC_LOG_VERBOSITY_MAX)\r\ni915.guc_log_level = GUC_LOG_VERBOSITY_MAX;\r\nsize = (1 + GUC_LOG_DPC_PAGES + 1 +\r\nGUC_LOG_ISR_PAGES + 1 +\r\nGUC_LOG_CRASH_PAGES + 1) << PAGE_SHIFT;\r\nif (WARN_ON(!i915_has_memcpy_from_wc())) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nvma = intel_guc_allocate_vma(guc, size);\r\nif (IS_ERR(vma)) {\r\nret = PTR_ERR(vma);\r\ngoto err;\r\n}\r\nguc->log.vma = vma;\r\nif (i915.guc_log_level >= 0) {\r\nret = guc_log_runtime_create(guc);\r\nif (ret < 0)\r\ngoto err_vma;\r\n}\r\nflags = GUC_LOG_VALID | GUC_LOG_NOTIFY_ON_HALF_FULL |\r\n(GUC_LOG_DPC_PAGES << GUC_LOG_DPC_SHIFT) |\r\n(GUC_LOG_ISR_PAGES << GUC_LOG_ISR_SHIFT) |\r\n(GUC_LOG_CRASH_PAGES << GUC_LOG_CRASH_SHIFT);\r\noffset = guc_ggtt_offset(vma) >> PAGE_SHIFT;\r\nguc->log.flags = (offset << GUC_LOG_BUF_ADDR_SHIFT) | flags;\r\nreturn 0;\r\nerr_vma:\r\ni915_vma_unpin_and_release(&guc->log.vma);\r\nerr:\r\ni915.guc_log_level = -1;\r\nreturn ret;\r\n}\r\nvoid intel_guc_log_destroy(struct intel_guc *guc)\r\n{\r\nguc_log_runtime_destroy(guc);\r\ni915_vma_unpin_and_release(&guc->log.vma);\r\n}\r\nint i915_guc_log_control(struct drm_i915_private *dev_priv, u64 control_val)\r\n{\r\nstruct intel_guc *guc = &dev_priv->guc;\r\nunion guc_log_control log_param;\r\nint ret;\r\nlog_param.value = control_val;\r\nif (log_param.verbosity < GUC_LOG_VERBOSITY_MIN ||\r\nlog_param.verbosity > GUC_LOG_VERBOSITY_MAX)\r\nreturn -EINVAL;\r\nif (!log_param.logging_enabled && (i915.guc_log_level < 0))\r\nreturn 0;\r\nret = guc_log_control(guc, log_param.value);\r\nif (ret < 0) {\r\nDRM_DEBUG_DRIVER("guc_logging_control action failed %d\n", ret);\r\nreturn ret;\r\n}\r\nif (log_param.logging_enabled) {\r\ni915.guc_log_level = log_param.verbosity;\r\nret = guc_log_late_setup(guc);\r\nif (ret < 0) {\r\nDRM_DEBUG_DRIVER("GuC log late setup failed %d\n", ret);\r\nreturn ret;\r\n}\r\ngen9_enable_guc_interrupts(dev_priv);\r\n} else {\r\nguc_flush_logs(guc);\r\ni915.guc_log_level = -1;\r\n}\r\nreturn ret;\r\n}\r\nvoid i915_guc_log_register(struct drm_i915_private *dev_priv)\r\n{\r\nif (!i915.enable_guc_submission || i915.guc_log_level < 0)\r\nreturn;\r\nmutex_lock(&dev_priv->drm.struct_mutex);\r\nguc_log_late_setup(&dev_priv->guc);\r\nmutex_unlock(&dev_priv->drm.struct_mutex);\r\n}\r\nvoid i915_guc_log_unregister(struct drm_i915_private *dev_priv)\r\n{\r\nif (!i915.enable_guc_submission)\r\nreturn;\r\nmutex_lock(&dev_priv->drm.struct_mutex);\r\ngen9_disable_guc_interrupts(dev_priv);\r\nguc_log_runtime_destroy(&dev_priv->guc);\r\nmutex_unlock(&dev_priv->drm.struct_mutex);\r\n}
