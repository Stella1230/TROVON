void\r\nacpi_db_set_method_breakpoint(char *location,\r\nstruct acpi_walk_state *walk_state,\r\nunion acpi_parse_object *op)\r\n{\r\nu32 address;\r\nu32 aml_offset;\r\nif (!op) {\r\nacpi_os_printf("There is no method currently executing\n");\r\nreturn;\r\n}\r\naddress = strtoul(location, NULL, 16);\r\naml_offset = (u32)ACPI_PTR_DIFF(op->common.aml,\r\nwalk_state->parser_state.aml_start);\r\nif (address <= aml_offset) {\r\nacpi_os_printf("Breakpoint %X is beyond current address %X\n",\r\naddress, aml_offset);\r\n}\r\nwalk_state->user_breakpoint = address;\r\nacpi_os_printf("Breakpoint set at AML offset %X\n", address);\r\n}\r\nvoid acpi_db_set_method_call_breakpoint(union acpi_parse_object *op)\r\n{\r\nif (!op) {\r\nacpi_os_printf("There is no method currently executing\n");\r\nreturn;\r\n}\r\nacpi_gbl_step_to_next_call = TRUE;\r\n}\r\nvoid acpi_db_set_method_data(char *type_arg, char *index_arg, char *value_arg)\r\n{\r\nchar type;\r\nu32 index;\r\nu32 value;\r\nstruct acpi_walk_state *walk_state;\r\nunion acpi_operand_object *obj_desc;\r\nacpi_status status;\r\nstruct acpi_namespace_node *node;\r\nacpi_ut_strupr(type_arg);\r\ntype = type_arg[0];\r\nif ((type != 'L') && (type != 'A') && (type != 'N')) {\r\nacpi_os_printf("Invalid SET operand: %s\n", type_arg);\r\nreturn;\r\n}\r\nvalue = strtoul(value_arg, NULL, 16);\r\nif (type == 'N') {\r\nnode = acpi_db_convert_to_node(index_arg);\r\nif (!node) {\r\nreturn;\r\n}\r\nif (node->type != ACPI_TYPE_INTEGER) {\r\nacpi_os_printf("Can only set Integer nodes\n");\r\nreturn;\r\n}\r\nobj_desc = node->object;\r\nobj_desc->integer.value = value;\r\nreturn;\r\n}\r\nindex = strtoul(index_arg, NULL, 16);\r\nwalk_state = acpi_ds_get_current_walk_state(acpi_gbl_current_walk_list);\r\nif (!walk_state) {\r\nacpi_os_printf("There is no method currently executing\n");\r\nreturn;\r\n}\r\nobj_desc = acpi_ut_create_integer_object((u64)value);\r\nif (!obj_desc) {\r\nacpi_os_printf("Could not create an internal object\n");\r\nreturn;\r\n}\r\nswitch (type) {\r\ncase 'A':\r\nif (index > ACPI_METHOD_MAX_ARG) {\r\nacpi_os_printf("Arg%u - Invalid argument name\n",\r\nindex);\r\ngoto cleanup;\r\n}\r\nstatus = acpi_ds_store_object_to_local(ACPI_REFCLASS_ARG,\r\nindex, obj_desc,\r\nwalk_state);\r\nif (ACPI_FAILURE(status)) {\r\ngoto cleanup;\r\n}\r\nobj_desc = walk_state->arguments[index].object;\r\nacpi_os_printf("Arg%u: ", index);\r\nacpi_db_display_internal_object(obj_desc, walk_state);\r\nbreak;\r\ncase 'L':\r\nif (index > ACPI_METHOD_MAX_LOCAL) {\r\nacpi_os_printf\r\n("Local%u - Invalid local variable name\n", index);\r\ngoto cleanup;\r\n}\r\nstatus = acpi_ds_store_object_to_local(ACPI_REFCLASS_LOCAL,\r\nindex, obj_desc,\r\nwalk_state);\r\nif (ACPI_FAILURE(status)) {\r\ngoto cleanup;\r\n}\r\nobj_desc = walk_state->local_variables[index].object;\r\nacpi_os_printf("Local%u: ", index);\r\nacpi_db_display_internal_object(obj_desc, walk_state);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncleanup:\r\nacpi_ut_remove_reference(obj_desc);\r\n}\r\nvoid acpi_db_disassemble_aml(char *statements, union acpi_parse_object *op)\r\n{\r\nu32 num_statements = 8;\r\nif (!op) {\r\nacpi_os_printf("There is no method currently executing\n");\r\nreturn;\r\n}\r\nif (statements) {\r\nnum_statements = strtoul(statements, NULL, 0);\r\n}\r\n#ifdef ACPI_DISASSEMBLER\r\nacpi_dm_disassemble(NULL, op, num_statements);\r\n#endif\r\n}\r\nacpi_status acpi_db_disassemble_method(char *name)\r\n{\r\nacpi_status status;\r\nunion acpi_parse_object *op;\r\nstruct acpi_walk_state *walk_state;\r\nunion acpi_operand_object *obj_desc;\r\nstruct acpi_namespace_node *method;\r\nmethod = acpi_db_convert_to_node(name);\r\nif (!method) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nif (method->type != ACPI_TYPE_METHOD) {\r\nACPI_ERROR((AE_INFO, "%s (%s): Object must be a control method",\r\nname, acpi_ut_get_type_name(method->type)));\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nobj_desc = method->object;\r\nop = acpi_ps_create_scope_op(obj_desc->method.aml_start);\r\nif (!op) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nwalk_state = acpi_ds_create_walk_state(0, op, NULL, NULL);\r\nif (!walk_state) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nstatus = acpi_ds_init_aml_walk(walk_state, op, NULL,\r\nobj_desc->method.aml_start,\r\nobj_desc->method.aml_length, NULL,\r\nACPI_IMODE_LOAD_PASS1);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nstatus = acpi_ut_allocate_owner_id(&obj_desc->method.owner_id);\r\nwalk_state->owner_id = obj_desc->method.owner_id;\r\nstatus = acpi_ds_scope_stack_push(method, method->type, walk_state);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nwalk_state->parse_flags &= ~ACPI_PARSE_DELETE_TREE;\r\nwalk_state->parse_flags |= ACPI_PARSE_DISASSEMBLE;\r\nstatus = acpi_ps_parse_aml(walk_state);\r\n#ifdef ACPI_DISASSEMBLER\r\n(void)acpi_dm_parse_deferred_ops(op);\r\nacpi_gbl_dm_opt_verbose = FALSE;\r\nacpi_dm_disassemble(NULL, op, 0);\r\nacpi_gbl_dm_opt_verbose = TRUE;\r\n#endif\r\nacpi_ps_delete_parse_tree(op);\r\nacpi_ns_delete_namespace_subtree(method);\r\nacpi_ns_delete_namespace_by_owner(obj_desc->method.owner_id);\r\nacpi_ut_release_owner_id(&obj_desc->method.owner_id);\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_db_walk_for_execute(acpi_handle obj_handle,\r\nu32 nesting_level, void *context, void **return_value)\r\n{\r\nstruct acpi_namespace_node *node =\r\n(struct acpi_namespace_node *)obj_handle;\r\nstruct acpi_db_execute_walk *info =\r\n(struct acpi_db_execute_walk *)context;\r\nstruct acpi_buffer return_obj;\r\nacpi_status status;\r\nchar *pathname;\r\nu32 i;\r\nstruct acpi_device_info *obj_info;\r\nstruct acpi_object_list param_objects;\r\nunion acpi_object params[ACPI_METHOD_NUM_ARGS];\r\nconst union acpi_predefined_info *predefined;\r\npredefined = acpi_ut_match_predefined_method(node->name.ascii);\r\nif (!predefined) {\r\nreturn (AE_OK);\r\n}\r\nif (node->type == ACPI_TYPE_LOCAL_SCOPE) {\r\nreturn (AE_OK);\r\n}\r\npathname = acpi_ns_get_external_pathname(node);\r\nif (!pathname) {\r\nreturn (AE_OK);\r\n}\r\nstatus = acpi_get_object_info(obj_handle, &obj_info);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_FREE(pathname);\r\nreturn (status);\r\n}\r\nparam_objects.pointer = NULL;\r\nparam_objects.count = 0;\r\nif (obj_info->type == ACPI_TYPE_METHOD) {\r\nfor (i = 0; i < obj_info->param_count; i++) {\r\nparams[i].type = ACPI_TYPE_INTEGER;\r\nparams[i].integer.value = 1;\r\n}\r\nparam_objects.pointer = params;\r\nparam_objects.count = obj_info->param_count;\r\n}\r\nACPI_FREE(obj_info);\r\nreturn_obj.pointer = NULL;\r\nreturn_obj.length = ACPI_ALLOCATE_BUFFER;\r\nacpi_gbl_method_executing = TRUE;\r\nstatus = acpi_evaluate_object(node, NULL, &param_objects, &return_obj);\r\nacpi_os_printf("%-32s returned %s\n", pathname,\r\nacpi_format_exception(status));\r\nacpi_gbl_method_executing = FALSE;\r\nACPI_FREE(pathname);\r\nstatus = AE_OK;\r\ninfo->count++;\r\nif (info->count >= info->max_count) {\r\nstatus = AE_CTRL_TERMINATE;\r\n}\r\nreturn (status);\r\n}\r\nvoid acpi_db_evaluate_predefined_names(void)\r\n{\r\nstruct acpi_db_execute_walk info;\r\ninfo.count = 0;\r\ninfo.max_count = ACPI_UINT32_MAX;\r\n(void)acpi_walk_namespace(ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, acpi_db_walk_for_execute,\r\nNULL, (void *)&info, NULL);\r\nacpi_os_printf("Evaluated %u predefined names in the namespace\n",\r\ninfo.count);\r\n}
