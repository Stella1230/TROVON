static void ftide010_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct ftide010 *ftide = ap->host->private_data;\r\nu8 speed = adev->dma_mode;\r\nu8 devno = adev->devno & 1;\r\nu8 udma_en_mask;\r\nu8 f66m_en_mask;\r\nu8 clkreg;\r\nu8 timreg;\r\nu8 i;\r\nif (!devno) {\r\nudma_en_mask = FTIDE010_CLK_MOD_DEV0_UDMA_EN;\r\nf66m_en_mask = FTIDE010_CLK_MOD_DEV0_CLK_SEL;\r\n} else {\r\nudma_en_mask = FTIDE010_CLK_MOD_DEV1_UDMA_EN;\r\nf66m_en_mask = FTIDE010_CLK_MOD_DEV1_CLK_SEL;\r\n}\r\nclkreg = readb(ftide->base + FTIDE010_CLK_MOD);\r\nclkreg &= ~udma_en_mask;\r\nclkreg &= ~f66m_en_mask;\r\nif (speed & XFER_UDMA_0) {\r\ni = speed & ~XFER_UDMA_0;\r\ndev_dbg(ftide->dev, "set UDMA mode %02x, index %d\n",\r\nspeed, i);\r\nclkreg |= udma_en_mask;\r\nif (set_udma_66_mhz[i]) {\r\nclkreg |= f66m_en_mask;\r\ntimreg = udma_66_setup_time[i] << 4 |\r\nudma_66_hold_time[i];\r\n} else {\r\ntimreg = udma_50_setup_time[i] << 4 |\r\nudma_50_hold_time[i];\r\n}\r\nif (i >= 5)\r\ntimreg |= FTIDE010_UDMA_TIMING_MODE_56;\r\ndev_dbg(ftide->dev, "UDMA write clkreg = %02x, timreg = %02x\n",\r\nclkreg, timreg);\r\nwriteb(clkreg, ftide->base + FTIDE010_CLK_MOD);\r\nwriteb(timreg, ftide->base + FTIDE010_UDMA_TIMING0 + devno);\r\n} else {\r\ni = speed & ~XFER_MW_DMA_0;\r\ndev_dbg(ftide->dev, "set MWDMA mode %02x, index %d\n",\r\nspeed, i);\r\nif (set_mdma_66_mhz[i]) {\r\nclkreg |= f66m_en_mask;\r\ntimreg = mwdma_66_active_time[i] << 4 |\r\nmwdma_66_recovery_time[i];\r\n} else {\r\ntimreg = mwdma_50_active_time[i] << 4 |\r\nmwdma_50_recovery_time[i];\r\n}\r\ndev_dbg(ftide->dev,\r\n"MWDMA write clkreg = %02x, timreg = %02x\n",\r\nclkreg, timreg);\r\nwriteb(clkreg, ftide->base + FTIDE010_CLK_MOD);\r\nwriteb(timreg, ftide->base + FTIDE010_MWDMA_TIMING);\r\n}\r\nap->private_data = adev;\r\nreturn;\r\n}\r\nstatic void ftide010_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct ftide010 *ftide = ap->host->private_data;\r\nu8 pio = adev->pio_mode - XFER_PIO_0;\r\ndev_dbg(ftide->dev, "set PIO mode %02x, index %d\n",\r\nadev->pio_mode, pio);\r\nwriteb(pio_active_time[pio] << 4 | pio_recovery_time[pio],\r\nftide->base + FTIDE010_PIO_TIMING);\r\n}\r\nstatic unsigned int ftide010_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ata_device *adev = qc->dev;\r\nif (adev != ap->private_data && ata_dma_enabled(adev))\r\nftide010_set_dmamode(ap, adev);\r\nreturn ata_bmdma_qc_issue(qc);\r\n}\r\nstatic int pata_ftide010_gemini_port_start(struct ata_port *ap)\r\n{\r\nstruct ftide010 *ftide = ap->host->private_data;\r\nstruct device *dev = ftide->dev;\r\nstruct sata_gemini *sg = ftide->sg;\r\nint bridges = 0;\r\nint ret;\r\nret = ata_bmdma_port_start(ap);\r\nif (ret)\r\nreturn ret;\r\nif (ftide->master_to_sata0) {\r\ndev_info(dev, "SATA0 (master) start\n");\r\nret = gemini_sata_start_bridge(sg, 0);\r\nif (!ret)\r\nbridges++;\r\n}\r\nif (ftide->master_to_sata1) {\r\ndev_info(dev, "SATA1 (master) start\n");\r\nret = gemini_sata_start_bridge(sg, 1);\r\nif (!ret)\r\nbridges++;\r\n}\r\nif (ftide->slave_to_sata0 && !ftide->master_to_sata0) {\r\ndev_info(dev, "SATA0 (slave) start\n");\r\nret = gemini_sata_start_bridge(sg, 0);\r\nif (!ret)\r\nbridges++;\r\n}\r\nif (ftide->slave_to_sata1 && !ftide->master_to_sata1) {\r\ndev_info(dev, "SATA1 (slave) start\n");\r\nret = gemini_sata_start_bridge(sg, 1);\r\nif (!ret)\r\nbridges++;\r\n}\r\ndev_info(dev, "brought %d bridges online\n", bridges);\r\nreturn (bridges > 0) ? 0 : -EINVAL;\r\n}\r\nstatic void pata_ftide010_gemini_port_stop(struct ata_port *ap)\r\n{\r\nstruct ftide010 *ftide = ap->host->private_data;\r\nstruct device *dev = ftide->dev;\r\nstruct sata_gemini *sg = ftide->sg;\r\nif (ftide->master_to_sata0) {\r\ndev_info(dev, "SATA0 (master) stop\n");\r\ngemini_sata_stop_bridge(sg, 0);\r\n}\r\nif (ftide->master_to_sata1) {\r\ndev_info(dev, "SATA1 (master) stop\n");\r\ngemini_sata_stop_bridge(sg, 1);\r\n}\r\nif (ftide->slave_to_sata0 && !ftide->master_to_sata0) {\r\ndev_info(dev, "SATA0 (slave) stop\n");\r\ngemini_sata_stop_bridge(sg, 0);\r\n}\r\nif (ftide->slave_to_sata1 && !ftide->master_to_sata1) {\r\ndev_info(dev, "SATA1 (slave) stop\n");\r\ngemini_sata_stop_bridge(sg, 1);\r\n}\r\n}\r\nstatic int pata_ftide010_gemini_cable_detect(struct ata_port *ap)\r\n{\r\nstruct ftide010 *ftide = ap->host->private_data;\r\nreturn ftide->master_cbl;\r\n}\r\nstatic int pata_ftide010_gemini_init(struct ftide010 *ftide,\r\nbool is_ata1)\r\n{\r\nstruct device *dev = ftide->dev;\r\nstruct sata_gemini *sg;\r\nenum gemini_muxmode muxmode;\r\nsg = gemini_sata_bridge_get();\r\nif (IS_ERR(sg))\r\nreturn PTR_ERR(sg);\r\nftide->sg = sg;\r\nmuxmode = gemini_sata_get_muxmode(sg);\r\npata_ftide010_port_ops.port_start =\r\npata_ftide010_gemini_port_start;\r\npata_ftide010_port_ops.port_stop =\r\npata_ftide010_gemini_port_stop;\r\npata_ftide010_port_ops.cable_detect =\r\npata_ftide010_gemini_cable_detect;\r\nif (gemini_sata_bridge_enabled(sg, is_ata1))\r\nftide010_port_info[0].flags |= ATA_FLAG_SATA;\r\nif (!is_ata1) {\r\nswitch (muxmode) {\r\ncase GEMINI_MUXMODE_0:\r\nftide->master_cbl = ATA_CBL_SATA;\r\nftide->slave_cbl = ATA_CBL_PATA40;\r\nftide->master_to_sata0 = true;\r\nbreak;\r\ncase GEMINI_MUXMODE_1:\r\nftide->master_cbl = ATA_CBL_SATA;\r\nftide->slave_cbl = ATA_CBL_NONE;\r\nftide->master_to_sata0 = true;\r\nbreak;\r\ncase GEMINI_MUXMODE_2:\r\nftide->master_cbl = ATA_CBL_PATA40;\r\nftide->slave_cbl = ATA_CBL_PATA40;\r\nbreak;\r\ncase GEMINI_MUXMODE_3:\r\nftide->master_cbl = ATA_CBL_SATA;\r\nftide->slave_cbl = ATA_CBL_SATA;\r\nftide->master_to_sata0 = true;\r\nftide->slave_to_sata1 = true;\r\nbreak;\r\n}\r\n} else {\r\nswitch (muxmode) {\r\ncase GEMINI_MUXMODE_0:\r\nftide->master_cbl = ATA_CBL_SATA;\r\nftide->slave_cbl = ATA_CBL_NONE;\r\nftide->master_to_sata1 = true;\r\nbreak;\r\ncase GEMINI_MUXMODE_1:\r\nftide->master_cbl = ATA_CBL_SATA;\r\nftide->slave_cbl = ATA_CBL_PATA40;\r\nftide->master_to_sata1 = true;\r\nbreak;\r\ncase GEMINI_MUXMODE_2:\r\nftide->master_cbl = ATA_CBL_SATA;\r\nftide->slave_cbl = ATA_CBL_SATA;\r\nftide->slave_to_sata0 = true;\r\nftide->master_to_sata1 = true;\r\nbreak;\r\ncase GEMINI_MUXMODE_3:\r\nftide->master_cbl = ATA_CBL_PATA40;\r\nftide->slave_cbl = ATA_CBL_PATA40;\r\nbreak;\r\n}\r\n}\r\ndev_info(dev, "set up Gemini PATA%d\n", is_ata1);\r\nreturn 0;\r\n}\r\nstatic int pata_ftide010_gemini_init(struct ftide010 *ftide,\r\nbool is_ata1)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int pata_ftide010_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nconst struct ata_port_info pi = ftide010_port_info[0];\r\nconst struct ata_port_info *ppi[] = { &pi, NULL };\r\nstruct ftide010 *ftide;\r\nstruct resource *res;\r\nint irq;\r\nint ret;\r\nint i;\r\nftide = devm_kzalloc(dev, sizeof(*ftide), GFP_KERNEL);\r\nif (!ftide)\r\nreturn -ENOMEM;\r\nftide->dev = dev;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nftide->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(ftide->base))\r\nreturn PTR_ERR(ftide->base);\r\nftide->pclk = devm_clk_get(dev, "PCLK");\r\nif (!IS_ERR(ftide->pclk)) {\r\nret = clk_prepare_enable(ftide->pclk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable PCLK\n");\r\nreturn ret;\r\n}\r\n}\r\nif (of_device_is_compatible(np, "cortina,gemini-pata")) {\r\nret = pata_ftide010_gemini_init(ftide,\r\n(res->start == 0x63400000));\r\nif (ret)\r\ngoto err_dis_clk;\r\n} else {\r\nftide->master_cbl = ATA_CBL_PATA40;\r\nftide->slave_cbl = ATA_CBL_PATA40;\r\n}\r\nftide->host = ata_host_alloc_pinfo(dev, ppi, 1);\r\nif (!ftide->host) {\r\nret = -ENOMEM;\r\ngoto err_dis_clk;\r\n}\r\nftide->host->private_data = ftide;\r\nfor (i = 0; i < ftide->host->n_ports; i++) {\r\nstruct ata_port *ap = ftide->host->ports[i];\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nioaddr->bmdma_addr = ftide->base + FTIDE010_DMA_REG;\r\nioaddr->cmd_addr = ftide->base + FTIDE010_CMD_DATA;\r\nioaddr->ctl_addr = ftide->base + FTIDE010_ALTSTAT_CTRL;\r\nioaddr->altstatus_addr = ftide->base + FTIDE010_ALTSTAT_CTRL;\r\nata_sff_std_ports(ioaddr);\r\n}\r\ndev_info(dev, "device ID %08x, irq %d, reg %pR\n",\r\nreadl(ftide->base + FTIDE010_IDE_DEVICE_ID), irq, res);\r\nret = ata_host_activate(ftide->host, irq, ata_bmdma_interrupt,\r\n0, &pata_ftide010_sht);\r\nif (ret)\r\ngoto err_dis_clk;\r\nreturn 0;\r\nerr_dis_clk:\r\nif (!IS_ERR(ftide->pclk))\r\nclk_disable_unprepare(ftide->pclk);\r\nreturn ret;\r\n}\r\nstatic int pata_ftide010_remove(struct platform_device *pdev)\r\n{\r\nstruct ata_host *host = platform_get_drvdata(pdev);\r\nstruct ftide010 *ftide = host->private_data;\r\nata_host_detach(ftide->host);\r\nif (!IS_ERR(ftide->pclk))\r\nclk_disable_unprepare(ftide->pclk);\r\nreturn 0;\r\n}
