unsigned long __clear_user(void __user *addr, unsigned long size)\r\n{\r\nlong __d0;\r\nmight_fault();\r\nstac();\r\nasm volatile(\r\n" testq %[size8],%[size8]\n"\r\n" jz 4f\n"\r\n"0: movq %[zero],(%[dst])\n"\r\n" addq %[eight],%[dst]\n"\r\n" decl %%ecx ; jnz 0b\n"\r\n"4: movq %[size1],%%rcx\n"\r\n" testl %%ecx,%%ecx\n"\r\n" jz 2f\n"\r\n"1: movb %b[zero],(%[dst])\n"\r\n" incq %[dst]\n"\r\n" decl %%ecx ; jnz 1b\n"\r\n"2:\n"\r\n".section .fixup,\"ax\"\n"\r\n"3: lea 0(%[size1],%[size8],8),%[size8]\n"\r\n" jmp 2b\n"\r\n".previous\n"\r\n_ASM_EXTABLE(0b,3b)\r\n_ASM_EXTABLE(1b,2b)\r\n: [size8] "=&c"(size), [dst] "=&D" (__d0)\r\n: [size1] "r"(size & 7), "[size8]" (size / 8), "[dst]"(addr),\r\n[zero] "r" (0UL), [eight] "r" (8UL));\r\nclac();\r\nreturn size;\r\n}\r\nunsigned long clear_user(void __user *to, unsigned long n)\r\n{\r\nif (access_ok(VERIFY_WRITE, to, n))\r\nreturn __clear_user(to, n);\r\nreturn n;\r\n}\r\n__visible unsigned long\r\ncopy_user_handle_tail(char *to, char *from, unsigned len)\r\n{\r\nfor (; len; --len, to++) {\r\nchar c;\r\nif (__get_user_nocheck(c, from++, sizeof(char)))\r\nbreak;\r\nif (__put_user_nocheck(c, to, sizeof(char)))\r\nbreak;\r\n}\r\nclac();\r\nreturn len;\r\n}\r\nstatic void clean_cache_range(void *addr, size_t size)\r\n{\r\nu16 x86_clflush_size = boot_cpu_data.x86_clflush_size;\r\nunsigned long clflush_mask = x86_clflush_size - 1;\r\nvoid *vend = addr + size;\r\nvoid *p;\r\nfor (p = (void *)((unsigned long)addr & ~clflush_mask);\r\np < vend; p += x86_clflush_size)\r\nclwb(p);\r\n}\r\nvoid arch_wb_cache_pmem(void *addr, size_t size)\r\n{\r\nclean_cache_range(addr, size);\r\n}\r\nlong __copy_user_flushcache(void *dst, const void __user *src, unsigned size)\r\n{\r\nunsigned long flushed, dest = (unsigned long) dst;\r\nlong rc = __copy_user_nocache(dst, src, size, 0);\r\nif (size < 8) {\r\nif (!IS_ALIGNED(dest, 4) || size != 4)\r\nclean_cache_range(dst, 1);\r\n} else {\r\nif (!IS_ALIGNED(dest, 8)) {\r\ndest = ALIGN(dest, boot_cpu_data.x86_clflush_size);\r\nclean_cache_range(dst, 1);\r\n}\r\nflushed = dest - (unsigned long) dst;\r\nif (size > flushed && !IS_ALIGNED(size - flushed, 8))\r\nclean_cache_range(dst + size - 1, 1);\r\n}\r\nreturn rc;\r\n}\r\nvoid memcpy_flushcache(void *_dst, const void *_src, size_t size)\r\n{\r\nunsigned long dest = (unsigned long) _dst;\r\nunsigned long source = (unsigned long) _src;\r\nif (!IS_ALIGNED(dest, 8)) {\r\nunsigned len = min_t(unsigned, size, ALIGN(dest, 8) - dest);\r\nmemcpy((void *) dest, (void *) source, len);\r\nclean_cache_range((void *) dest, len);\r\ndest += len;\r\nsource += len;\r\nsize -= len;\r\nif (!size)\r\nreturn;\r\n}\r\nwhile (size >= 32) {\r\nasm("movq (%0), %%r8\n"\r\n"movq 8(%0), %%r9\n"\r\n"movq 16(%0), %%r10\n"\r\n"movq 24(%0), %%r11\n"\r\n"movnti %%r8, (%1)\n"\r\n"movnti %%r9, 8(%1)\n"\r\n"movnti %%r10, 16(%1)\n"\r\n"movnti %%r11, 24(%1)\n"\r\n:: "r" (source), "r" (dest)\r\n: "memory", "r8", "r9", "r10", "r11");\r\ndest += 32;\r\nsource += 32;\r\nsize -= 32;\r\n}\r\nwhile (size >= 8) {\r\nasm("movq (%0), %%r8\n"\r\n"movnti %%r8, (%1)\n"\r\n:: "r" (source), "r" (dest)\r\n: "memory", "r8");\r\ndest += 8;\r\nsource += 8;\r\nsize -= 8;\r\n}\r\nwhile (size >= 4) {\r\nasm("movl (%0), %%r8d\n"\r\n"movnti %%r8d, (%1)\n"\r\n:: "r" (source), "r" (dest)\r\n: "memory", "r8");\r\ndest += 4;\r\nsource += 4;\r\nsize -= 4;\r\n}\r\nif (size) {\r\nmemcpy((void *) dest, (void *) source, size);\r\nclean_cache_range((void *) dest, size);\r\n}\r\n}\r\nvoid memcpy_page_flushcache(char *to, struct page *page, size_t offset,\r\nsize_t len)\r\n{\r\nchar *from = kmap_atomic(page);\r\nmemcpy_flushcache(to, from + offset, len);\r\nkunmap_atomic(from);\r\n}
