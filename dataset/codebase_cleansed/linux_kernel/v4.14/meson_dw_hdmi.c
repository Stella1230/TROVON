static inline int dw_hdmi_is_compatible(struct meson_dw_hdmi *dw_hdmi,\r\nconst char *compat)\r\n{\r\nreturn of_device_is_compatible(dw_hdmi->dev->of_node, compat);\r\n}\r\nstatic unsigned int dw_hdmi_top_read(struct meson_dw_hdmi *dw_hdmi,\r\nunsigned int addr)\r\n{\r\nunsigned long flags;\r\nunsigned int data;\r\nspin_lock_irqsave(&reg_lock, flags);\r\nwritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_TOP_ADDR_REG);\r\nwritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_TOP_ADDR_REG);\r\ndata = readl(dw_hdmi->hdmitx + HDMITX_TOP_DATA_REG);\r\ndata = readl(dw_hdmi->hdmitx + HDMITX_TOP_DATA_REG);\r\nspin_unlock_irqrestore(&reg_lock, flags);\r\nreturn data;\r\n}\r\nstatic inline void dw_hdmi_top_write(struct meson_dw_hdmi *dw_hdmi,\r\nunsigned int addr, unsigned int data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&reg_lock, flags);\r\nwritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_TOP_ADDR_REG);\r\nwritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_TOP_ADDR_REG);\r\nwritel(data, dw_hdmi->hdmitx + HDMITX_TOP_DATA_REG);\r\nspin_unlock_irqrestore(&reg_lock, flags);\r\n}\r\nstatic inline void dw_hdmi_top_write_bits(struct meson_dw_hdmi *dw_hdmi,\r\nunsigned int addr,\r\nunsigned int mask,\r\nunsigned int val)\r\n{\r\nunsigned int data = dw_hdmi_top_read(dw_hdmi, addr);\r\ndata &= ~mask;\r\ndata |= val;\r\ndw_hdmi_top_write(dw_hdmi, addr, data);\r\n}\r\nstatic unsigned int dw_hdmi_dwc_read(struct meson_dw_hdmi *dw_hdmi,\r\nunsigned int addr)\r\n{\r\nunsigned long flags;\r\nunsigned int data;\r\nspin_lock_irqsave(&reg_lock, flags);\r\nwritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_DWC_ADDR_REG);\r\nwritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_DWC_ADDR_REG);\r\ndata = readl(dw_hdmi->hdmitx + HDMITX_DWC_DATA_REG);\r\ndata = readl(dw_hdmi->hdmitx + HDMITX_DWC_DATA_REG);\r\nspin_unlock_irqrestore(&reg_lock, flags);\r\nreturn data;\r\n}\r\nstatic inline void dw_hdmi_dwc_write(struct meson_dw_hdmi *dw_hdmi,\r\nunsigned int addr, unsigned int data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&reg_lock, flags);\r\nwritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_DWC_ADDR_REG);\r\nwritel(addr & 0xffff, dw_hdmi->hdmitx + HDMITX_DWC_ADDR_REG);\r\nwritel(data, dw_hdmi->hdmitx + HDMITX_DWC_DATA_REG);\r\nspin_unlock_irqrestore(&reg_lock, flags);\r\n}\r\nstatic inline void dw_hdmi_dwc_write_bits(struct meson_dw_hdmi *dw_hdmi,\r\nunsigned int addr,\r\nunsigned int mask,\r\nunsigned int val)\r\n{\r\nunsigned int data = dw_hdmi_dwc_read(dw_hdmi, addr);\r\ndata &= ~mask;\r\ndata |= val;\r\ndw_hdmi_dwc_write(dw_hdmi, addr, data);\r\n}\r\nstatic void meson_hdmi_phy_setup_mode(struct meson_dw_hdmi *dw_hdmi,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct meson_drm *priv = dw_hdmi->priv;\r\nunsigned int pixel_clock = mode->clock;\r\nif (dw_hdmi_is_compatible(dw_hdmi, "amlogic,meson-gxl-dw-hdmi") ||\r\ndw_hdmi_is_compatible(dw_hdmi, "amlogic,meson-gxm-dw-hdmi")) {\r\nif (pixel_clock >= 371250) {\r\nregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x333d3282);\r\nregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0x2136315b);\r\n} else if (pixel_clock >= 297000) {\r\nregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x33303382);\r\nregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0x2036315b);\r\n} else if (pixel_clock >= 148500) {\r\nregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x33303362);\r\nregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0x2016315b);\r\n} else {\r\nregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x33604142);\r\nregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0x0016315b);\r\n}\r\n} else if (dw_hdmi_is_compatible(dw_hdmi,\r\n"amlogic,meson-gxbb-dw-hdmi")) {\r\nif (pixel_clock >= 371250) {\r\nregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x33353245);\r\nregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0x2100115b);\r\n} else if (pixel_clock >= 297000) {\r\nregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x33634283);\r\nregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0xb000115b);\r\n} else {\r\nregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0x33632122);\r\nregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL3, 0x2000115b);\r\n}\r\n}\r\n}\r\nstatic inline void dw_hdmi_phy_reset(struct meson_dw_hdmi *dw_hdmi)\r\n{\r\nstruct meson_drm *priv = dw_hdmi->priv;\r\nregmap_update_bits(priv->hhi, HHI_HDMI_PHY_CNTL1, 0xf, 0xf);\r\nmdelay(2);\r\nregmap_update_bits(priv->hhi, HHI_HDMI_PHY_CNTL1, 0xf, 0xe);\r\nmdelay(2);\r\n}\r\nstatic void dw_hdmi_set_vclk(struct meson_dw_hdmi *dw_hdmi,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct meson_drm *priv = dw_hdmi->priv;\r\nint vic = drm_match_cea_mode(mode);\r\nunsigned int vclk_freq;\r\nunsigned int venc_freq;\r\nunsigned int hdmi_freq;\r\nvclk_freq = mode->clock;\r\nif (mode->flags & DRM_MODE_FLAG_DBLCLK)\r\nvclk_freq *= 2;\r\nvenc_freq = vclk_freq;\r\nhdmi_freq = vclk_freq;\r\nif (meson_venc_hdmi_venc_repeat(vic))\r\nvenc_freq *= 2;\r\nvclk_freq = max(venc_freq, hdmi_freq);\r\nif (mode->flags & DRM_MODE_FLAG_DBLCLK)\r\nvenc_freq /= 2;\r\nDRM_DEBUG_DRIVER("vclk:%d venc=%d hdmi=%d enci=%d\n",\r\nvclk_freq, venc_freq, hdmi_freq,\r\npriv->venc.hdmi_use_enci);\r\nmeson_vclk_setup(priv, MESON_VCLK_TARGET_HDMI, vclk_freq,\r\nvenc_freq, hdmi_freq, priv->venc.hdmi_use_enci);\r\n}\r\nstatic int dw_hdmi_phy_init(struct dw_hdmi *hdmi, void *data,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct meson_dw_hdmi *dw_hdmi = (struct meson_dw_hdmi *)data;\r\nstruct meson_drm *priv = dw_hdmi->priv;\r\nunsigned int wr_clk =\r\nreadl_relaxed(priv->io_base + _REG(VPU_HDMI_SETTING));\r\nDRM_DEBUG_DRIVER("%d:\"%s\"\n", mode->base.id, mode->name);\r\nregmap_update_bits(priv->hhi, HHI_HDMI_CLK_CNTL, 0xffff, 0x100);\r\nregmap_update_bits(priv->hhi, HHI_MEM_PD_REG0, 0xff << 8, 0);\r\ndw_hdmi_top_write(dw_hdmi, HDMITX_TOP_SW_RESET, 0);\r\ndw_hdmi_top_write_bits(dw_hdmi, HDMITX_TOP_CLK_CNTL,\r\n0x3, 0x3);\r\ndw_hdmi_top_write_bits(dw_hdmi, HDMITX_TOP_CLK_CNTL,\r\n0x3 << 4, 0x3 << 4);\r\ndw_hdmi_top_write(dw_hdmi, HDMITX_TOP_BIST_CNTL, BIT(12));\r\ndw_hdmi_top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_01, 0x001f001f);\r\ndw_hdmi_top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_23, 0x001f001f);\r\ndw_hdmi_top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 0x1);\r\nmsleep(20);\r\ndw_hdmi_top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 0x2);\r\nmeson_hdmi_phy_setup_mode(dw_hdmi, mode);\r\nregmap_update_bits(priv->hhi, HHI_HDMI_PHY_CNTL1,\r\n0xffff << 16, 0x0390 << 16);\r\nif (dw_hdmi_is_compatible(dw_hdmi, "amlogic,meson-gxl-dw-hdmi") ||\r\ndw_hdmi_is_compatible(dw_hdmi, "amlogic,meson-gxm-dw-hdmi"))\r\nregmap_update_bits(priv->hhi, HHI_HDMI_PHY_CNTL1,\r\nBIT(17), 0);\r\nelse\r\nregmap_update_bits(priv->hhi, HHI_HDMI_PHY_CNTL1,\r\nBIT(17), BIT(17));\r\nregmap_update_bits(priv->hhi, HHI_HDMI_PHY_CNTL1, 0xf, 0);\r\nmsleep(100);\r\ndw_hdmi_phy_reset(dw_hdmi);\r\ndw_hdmi_phy_reset(dw_hdmi);\r\ndw_hdmi_phy_reset(dw_hdmi);\r\nif (priv->venc.hdmi_use_enci)\r\nwritel_relaxed(0, priv->io_base + _REG(ENCI_VIDEO_EN));\r\nelse\r\nwritel_relaxed(0, priv->io_base + _REG(ENCP_VIDEO_EN));\r\nwritel_bits_relaxed(0x3, 0,\r\npriv->io_base + _REG(VPU_HDMI_SETTING));\r\nwritel_bits_relaxed(0xf << 8, 0,\r\npriv->io_base + _REG(VPU_HDMI_SETTING));\r\nif (priv->venc.hdmi_use_enci)\r\nwritel_relaxed(1, priv->io_base + _REG(ENCI_VIDEO_EN));\r\nelse\r\nwritel_relaxed(1, priv->io_base + _REG(ENCP_VIDEO_EN));\r\nwritel_bits_relaxed(0xf << 8, wr_clk & (0xf << 8),\r\npriv->io_base + _REG(VPU_HDMI_SETTING));\r\nif (priv->venc.hdmi_use_enci)\r\nwritel_bits_relaxed(0x3, MESON_VENC_SOURCE_ENCI,\r\npriv->io_base + _REG(VPU_HDMI_SETTING));\r\nelse\r\nwritel_bits_relaxed(0x3, MESON_VENC_SOURCE_ENCP,\r\npriv->io_base + _REG(VPU_HDMI_SETTING));\r\nreturn 0;\r\n}\r\nstatic void dw_hdmi_phy_disable(struct dw_hdmi *hdmi,\r\nvoid *data)\r\n{\r\nstruct meson_dw_hdmi *dw_hdmi = (struct meson_dw_hdmi *)data;\r\nstruct meson_drm *priv = dw_hdmi->priv;\r\nDRM_DEBUG_DRIVER("\n");\r\nregmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0);\r\n}\r\nstatic enum drm_connector_status dw_hdmi_read_hpd(struct dw_hdmi *hdmi,\r\nvoid *data)\r\n{\r\nstruct meson_dw_hdmi *dw_hdmi = (struct meson_dw_hdmi *)data;\r\nreturn !!dw_hdmi_top_read(dw_hdmi, HDMITX_TOP_STAT0) ?\r\nconnector_status_connected : connector_status_disconnected;\r\n}\r\nstatic void dw_hdmi_setup_hpd(struct dw_hdmi *hdmi,\r\nvoid *data)\r\n{\r\nstruct meson_dw_hdmi *dw_hdmi = (struct meson_dw_hdmi *)data;\r\ndw_hdmi_top_write(dw_hdmi, HDMITX_TOP_HPD_FILTER,\r\n(0xa << 12) | 0xa0);\r\ndw_hdmi_top_write(dw_hdmi, HDMITX_TOP_INTR_STAT_CLR,\r\nHDMITX_TOP_INTR_HPD_RISE | HDMITX_TOP_INTR_HPD_FALL);\r\ndw_hdmi_top_write_bits(dw_hdmi, HDMITX_TOP_INTR_MASKN,\r\nHDMITX_TOP_INTR_HPD_RISE | HDMITX_TOP_INTR_HPD_FALL,\r\nHDMITX_TOP_INTR_HPD_RISE | HDMITX_TOP_INTR_HPD_FALL);\r\n}\r\nstatic irqreturn_t dw_hdmi_top_irq(int irq, void *dev_id)\r\n{\r\nstruct meson_dw_hdmi *dw_hdmi = dev_id;\r\nu32 stat;\r\nstat = dw_hdmi_top_read(dw_hdmi, HDMITX_TOP_INTR_STAT);\r\ndw_hdmi_top_write(dw_hdmi, HDMITX_TOP_INTR_STAT_CLR, stat);\r\nif (stat & (HDMITX_TOP_INTR_HPD_RISE | HDMITX_TOP_INTR_HPD_FALL)) {\r\ndw_hdmi->irq_stat = stat;\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nif (stat & 1)\r\nreturn IRQ_NONE;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t dw_hdmi_top_thread_irq(int irq, void *dev_id)\r\n{\r\nstruct meson_dw_hdmi *dw_hdmi = dev_id;\r\nu32 stat = dw_hdmi->irq_stat;\r\nif (stat & (HDMITX_TOP_INTR_HPD_RISE | HDMITX_TOP_INTR_HPD_FALL)) {\r\nbool hpd_connected = false;\r\nif (stat & HDMITX_TOP_INTR_HPD_RISE)\r\nhpd_connected = true;\r\ndw_hdmi_setup_rx_sense(dw_hdmi->dev, hpd_connected,\r\nhpd_connected);\r\ndrm_helper_hpd_irq_event(dw_hdmi->encoder.dev);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic enum drm_mode_status\r\ndw_hdmi_mode_valid(struct drm_connector *connector,\r\nconst struct drm_display_mode *mode)\r\n{\r\nunsigned int vclk_freq;\r\nunsigned int venc_freq;\r\nunsigned int hdmi_freq;\r\nint vic = drm_match_cea_mode(mode);\r\nDRM_DEBUG_DRIVER("Modeline %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x\n",\r\nmode->base.id, mode->name, mode->vrefresh, mode->clock,\r\nmode->hdisplay, mode->hsync_start,\r\nmode->hsync_end, mode->htotal,\r\nmode->vdisplay, mode->vsync_start,\r\nmode->vsync_end, mode->vtotal, mode->type, mode->flags);\r\nif (!vic)\r\nreturn MODE_BAD;\r\nif (!meson_venc_hdmi_supported_vic(vic))\r\nreturn MODE_BAD;\r\nvclk_freq = mode->clock;\r\nif (mode->flags & DRM_MODE_FLAG_DBLCLK)\r\nvclk_freq *= 2;\r\nvenc_freq = vclk_freq;\r\nhdmi_freq = vclk_freq;\r\nif (meson_venc_hdmi_venc_repeat(vic))\r\nvenc_freq *= 2;\r\nvclk_freq = max(venc_freq, hdmi_freq);\r\nif (mode->flags & DRM_MODE_FLAG_DBLCLK)\r\nvenc_freq /= 2;\r\ndev_dbg(connector->dev->dev, "%s: vclk:%d venc=%d hdmi=%d\n", __func__,\r\nvclk_freq, venc_freq, hdmi_freq);\r\nswitch (vclk_freq) {\r\ncase 54000:\r\ncase 74250:\r\ncase 148500:\r\ncase 297000:\r\ncase 594000:\r\nreturn MODE_OK;\r\n}\r\nreturn MODE_CLOCK_RANGE;\r\n}\r\nstatic void meson_venc_hdmi_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\n}\r\nstatic int meson_venc_hdmi_encoder_atomic_check(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nreturn 0;\r\n}\r\nstatic void meson_venc_hdmi_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct meson_dw_hdmi *dw_hdmi = encoder_to_meson_dw_hdmi(encoder);\r\nstruct meson_drm *priv = dw_hdmi->priv;\r\nDRM_DEBUG_DRIVER("\n");\r\nwritel_bits_relaxed(0x3, 0,\r\npriv->io_base + _REG(VPU_HDMI_SETTING));\r\nwritel_relaxed(0, priv->io_base + _REG(ENCI_VIDEO_EN));\r\nwritel_relaxed(0, priv->io_base + _REG(ENCP_VIDEO_EN));\r\n}\r\nstatic void meson_venc_hdmi_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct meson_dw_hdmi *dw_hdmi = encoder_to_meson_dw_hdmi(encoder);\r\nstruct meson_drm *priv = dw_hdmi->priv;\r\nDRM_DEBUG_DRIVER("%s\n", priv->venc.hdmi_use_enci ? "VENCI" : "VENCP");\r\nif (priv->venc.hdmi_use_enci)\r\nwritel_relaxed(1, priv->io_base + _REG(ENCI_VIDEO_EN));\r\nelse\r\nwritel_relaxed(1, priv->io_base + _REG(ENCP_VIDEO_EN));\r\n}\r\nstatic void meson_venc_hdmi_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct meson_dw_hdmi *dw_hdmi = encoder_to_meson_dw_hdmi(encoder);\r\nstruct meson_drm *priv = dw_hdmi->priv;\r\nint vic = drm_match_cea_mode(mode);\r\nDRM_DEBUG_DRIVER("%d:\"%s\" vic %d\n",\r\nmode->base.id, mode->name, vic);\r\nif (!vic)\r\nreturn;\r\nmeson_venc_hdmi_mode_set(priv, vic, mode);\r\ndw_hdmi_set_vclk(dw_hdmi, mode);\r\nwritel_relaxed(0, priv->io_base + _REG(VPU_HDMI_FMT_CTRL));\r\n}\r\nstatic int meson_dw_hdmi_reg_read(void *context, unsigned int reg,\r\nunsigned int *result)\r\n{\r\n*result = dw_hdmi_dwc_read(context, reg);\r\nreturn 0;\r\n}\r\nstatic int meson_dw_hdmi_reg_write(void *context, unsigned int reg,\r\nunsigned int val)\r\n{\r\ndw_hdmi_dwc_write(context, reg, val);\r\nreturn 0;\r\n}\r\nstatic bool meson_hdmi_connector_is_available(struct device *dev)\r\n{\r\nstruct device_node *ep, *remote;\r\nep = of_graph_get_endpoint_by_regs(dev->of_node, 1, 0);\r\nif (!ep)\r\nreturn false;\r\nremote = of_graph_get_remote_port(ep);\r\nif (remote) {\r\nof_node_put(ep);\r\nreturn true;\r\n}\r\nof_node_put(ep);\r\nof_node_put(remote);\r\nreturn false;\r\n}\r\nstatic int meson_dw_hdmi_bind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct meson_dw_hdmi *meson_dw_hdmi;\r\nstruct drm_device *drm = data;\r\nstruct meson_drm *priv = drm->dev_private;\r\nstruct dw_hdmi_plat_data *dw_plat_data;\r\nstruct drm_encoder *encoder;\r\nstruct resource *res;\r\nint irq;\r\nint ret;\r\nDRM_DEBUG_DRIVER("\n");\r\nif (!meson_hdmi_connector_is_available(dev)) {\r\ndev_info(drm->dev, "HDMI Output connector not available\n");\r\nreturn -ENODEV;\r\n}\r\nmeson_dw_hdmi = devm_kzalloc(dev, sizeof(*meson_dw_hdmi),\r\nGFP_KERNEL);\r\nif (!meson_dw_hdmi)\r\nreturn -ENOMEM;\r\nmeson_dw_hdmi->priv = priv;\r\nmeson_dw_hdmi->dev = dev;\r\ndw_plat_data = &meson_dw_hdmi->dw_plat_data;\r\nencoder = &meson_dw_hdmi->encoder;\r\nmeson_dw_hdmi->hdmitx_apb = devm_reset_control_get_exclusive(dev,\r\n"hdmitx_apb");\r\nif (IS_ERR(meson_dw_hdmi->hdmitx_apb)) {\r\ndev_err(dev, "Failed to get hdmitx_apb reset\n");\r\nreturn PTR_ERR(meson_dw_hdmi->hdmitx_apb);\r\n}\r\nmeson_dw_hdmi->hdmitx_ctrl = devm_reset_control_get_exclusive(dev,\r\n"hdmitx");\r\nif (IS_ERR(meson_dw_hdmi->hdmitx_ctrl)) {\r\ndev_err(dev, "Failed to get hdmitx reset\n");\r\nreturn PTR_ERR(meson_dw_hdmi->hdmitx_ctrl);\r\n}\r\nmeson_dw_hdmi->hdmitx_phy = devm_reset_control_get_exclusive(dev,\r\n"hdmitx_phy");\r\nif (IS_ERR(meson_dw_hdmi->hdmitx_phy)) {\r\ndev_err(dev, "Failed to get hdmitx_phy reset\n");\r\nreturn PTR_ERR(meson_dw_hdmi->hdmitx_phy);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmeson_dw_hdmi->hdmitx = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(meson_dw_hdmi->hdmitx))\r\nreturn PTR_ERR(meson_dw_hdmi->hdmitx);\r\nmeson_dw_hdmi->hdmi_pclk = devm_clk_get(dev, "isfr");\r\nif (IS_ERR(meson_dw_hdmi->hdmi_pclk)) {\r\ndev_err(dev, "Unable to get HDMI pclk\n");\r\nreturn PTR_ERR(meson_dw_hdmi->hdmi_pclk);\r\n}\r\nclk_prepare_enable(meson_dw_hdmi->hdmi_pclk);\r\nmeson_dw_hdmi->venci_clk = devm_clk_get(dev, "venci");\r\nif (IS_ERR(meson_dw_hdmi->venci_clk)) {\r\ndev_err(dev, "Unable to get venci clk\n");\r\nreturn PTR_ERR(meson_dw_hdmi->venci_clk);\r\n}\r\nclk_prepare_enable(meson_dw_hdmi->venci_clk);\r\ndw_plat_data->regm = devm_regmap_init(dev, NULL, meson_dw_hdmi,\r\n&meson_dw_hdmi_regmap_config);\r\nif (IS_ERR(dw_plat_data->regm))\r\nreturn PTR_ERR(dw_plat_data->regm);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "Failed to get hdmi top irq\n");\r\nreturn irq;\r\n}\r\nret = devm_request_threaded_irq(dev, irq, dw_hdmi_top_irq,\r\ndw_hdmi_top_thread_irq, IRQF_SHARED,\r\n"dw_hdmi_top_irq", meson_dw_hdmi);\r\nif (ret) {\r\ndev_err(dev, "Failed to request hdmi top irq\n");\r\nreturn ret;\r\n}\r\ndrm_encoder_helper_add(encoder, &meson_venc_hdmi_encoder_helper_funcs);\r\nret = drm_encoder_init(drm, encoder, &meson_venc_hdmi_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS, "meson_hdmi");\r\nif (ret) {\r\ndev_err(priv->dev, "Failed to init HDMI encoder\n");\r\nreturn ret;\r\n}\r\nencoder->possible_crtcs = BIT(0);\r\nDRM_DEBUG_DRIVER("encoder initialized\n");\r\nregmap_update_bits(priv->hhi, HHI_HDMI_CLK_CNTL, 0xffff, 0x100);\r\nregmap_update_bits(priv->hhi, HHI_MEM_PD_REG0, 0xff << 8, 0);\r\nreset_control_reset(meson_dw_hdmi->hdmitx_apb);\r\nreset_control_reset(meson_dw_hdmi->hdmitx_ctrl);\r\nreset_control_reset(meson_dw_hdmi->hdmitx_phy);\r\nwritel_bits_relaxed(BIT(15), BIT(15),\r\nmeson_dw_hdmi->hdmitx + HDMITX_TOP_CTRL_REG);\r\nwritel_bits_relaxed(BIT(15), BIT(15),\r\nmeson_dw_hdmi->hdmitx + HDMITX_DWC_CTRL_REG);\r\ndw_hdmi_top_write(meson_dw_hdmi, HDMITX_TOP_SW_RESET, 0);\r\nmsleep(20);\r\ndw_hdmi_top_write(meson_dw_hdmi, HDMITX_TOP_CLK_CNTL, 0xff);\r\ndw_hdmi_top_write(meson_dw_hdmi, HDMITX_TOP_INTR_STAT_CLR,\r\nHDMITX_TOP_INTR_CORE);\r\ndw_hdmi_top_write(meson_dw_hdmi, HDMITX_TOP_INTR_MASKN,\r\nHDMITX_TOP_INTR_CORE);\r\ndw_plat_data->mode_valid = dw_hdmi_mode_valid;\r\ndw_plat_data->phy_ops = &meson_dw_hdmi_phy_ops;\r\ndw_plat_data->phy_name = "meson_dw_hdmi_phy";\r\ndw_plat_data->phy_data = meson_dw_hdmi;\r\ndw_plat_data->input_bus_format = MEDIA_BUS_FMT_YUV8_1X24;\r\ndw_plat_data->input_bus_encoding = V4L2_YCBCR_ENC_709;\r\nret = dw_hdmi_bind(pdev, encoder, &meson_dw_hdmi->dw_plat_data);\r\nif (ret)\r\nreturn ret;\r\nDRM_DEBUG_DRIVER("HDMI controller initialized\n");\r\nreturn 0;\r\n}\r\nstatic void meson_dw_hdmi_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\ndw_hdmi_unbind(dev);\r\n}\r\nstatic int meson_dw_hdmi_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &meson_dw_hdmi_ops);\r\n}\r\nstatic int meson_dw_hdmi_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &meson_dw_hdmi_ops);\r\nreturn 0;\r\n}
