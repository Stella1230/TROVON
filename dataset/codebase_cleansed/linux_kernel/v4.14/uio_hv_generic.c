static int\r\nhv_uio_mmap(struct uio_info *info, struct vm_area_struct *vma)\r\n{\r\nint mi;\r\nif (vma->vm_pgoff >= MAX_UIO_MAPS)\r\nreturn -EINVAL;\r\nif (info->mem[vma->vm_pgoff].size == 0)\r\nreturn -EINVAL;\r\nmi = (int)vma->vm_pgoff;\r\nreturn remap_pfn_range(vma, vma->vm_start,\r\ninfo->mem[mi].addr >> PAGE_SHIFT,\r\nvma->vm_end - vma->vm_start, vma->vm_page_prot);\r\n}\r\nstatic int\r\nhv_uio_irqcontrol(struct uio_info *info, s32 irq_state)\r\n{\r\nstruct hv_uio_private_data *pdata = info->priv;\r\nstruct hv_device *dev = pdata->device;\r\ndev->channel->inbound.ring_buffer->interrupt_mask = !irq_state;\r\nvirt_mb();\r\nreturn 0;\r\n}\r\nstatic void hv_uio_channel_cb(void *context)\r\n{\r\nstruct hv_uio_private_data *pdata = context;\r\nstruct hv_device *dev = pdata->device;\r\ndev->channel->inbound.ring_buffer->interrupt_mask = 1;\r\nvirt_mb();\r\nuio_event_notify(&pdata->info);\r\n}\r\nstatic int\r\nhv_uio_probe(struct hv_device *dev,\r\nconst struct hv_vmbus_device_id *dev_id)\r\n{\r\nstruct hv_uio_private_data *pdata;\r\nint ret;\r\npdata = kzalloc(sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nret = vmbus_open(dev->channel, HV_RING_SIZE * PAGE_SIZE,\r\nHV_RING_SIZE * PAGE_SIZE, NULL, 0,\r\nhv_uio_channel_cb, pdata);\r\nif (ret)\r\ngoto fail;\r\ndev->channel->inbound.ring_buffer->interrupt_mask = 1;\r\nset_channel_read_mode(dev->channel, HV_CALL_DIRECT);\r\npdata->info.name = "uio_hv_generic";\r\npdata->info.version = DRIVER_VERSION;\r\npdata->info.irqcontrol = hv_uio_irqcontrol;\r\npdata->info.mmap = hv_uio_mmap;\r\npdata->info.irq = UIO_IRQ_CUSTOM;\r\npdata->info.mem[TXRX_RING_MAP].name = "txrx_rings";\r\npdata->info.mem[TXRX_RING_MAP].addr\r\n= virt_to_phys(dev->channel->ringbuffer_pages);\r\npdata->info.mem[TXRX_RING_MAP].size\r\n= dev->channel->ringbuffer_pagecount * PAGE_SIZE;\r\npdata->info.mem[TXRX_RING_MAP].memtype = UIO_MEM_LOGICAL;\r\npdata->info.mem[INT_PAGE_MAP].name = "int_page";\r\npdata->info.mem[INT_PAGE_MAP].addr =\r\nvirt_to_phys(vmbus_connection.int_page);\r\npdata->info.mem[INT_PAGE_MAP].size = PAGE_SIZE;\r\npdata->info.mem[INT_PAGE_MAP].memtype = UIO_MEM_LOGICAL;\r\npdata->info.mem[MON_PAGE_MAP].name = "monitor_pages";\r\npdata->info.mem[MON_PAGE_MAP].addr =\r\nvirt_to_phys(vmbus_connection.monitor_pages[1]);\r\npdata->info.mem[MON_PAGE_MAP].size = PAGE_SIZE;\r\npdata->info.mem[MON_PAGE_MAP].memtype = UIO_MEM_LOGICAL;\r\npdata->info.priv = pdata;\r\npdata->device = dev;\r\nret = uio_register_device(&dev->device, &pdata->info);\r\nif (ret) {\r\ndev_err(&dev->device, "hv_uio register failed\n");\r\ngoto fail_close;\r\n}\r\nhv_set_drvdata(dev, pdata);\r\nreturn 0;\r\nfail_close:\r\nvmbus_close(dev->channel);\r\nfail:\r\nkfree(pdata);\r\nreturn ret;\r\n}\r\nstatic int\r\nhv_uio_remove(struct hv_device *dev)\r\n{\r\nstruct hv_uio_private_data *pdata = hv_get_drvdata(dev);\r\nif (!pdata)\r\nreturn 0;\r\nuio_unregister_device(&pdata->info);\r\nhv_set_drvdata(dev, NULL);\r\nvmbus_close(dev->channel);\r\nkfree(pdata);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nhyperv_module_init(void)\r\n{\r\nreturn vmbus_driver_register(&hv_uio_drv);\r\n}\r\nstatic void __exit\r\nhyperv_module_exit(void)\r\n{\r\nvmbus_driver_unregister(&hv_uio_drv);\r\n}
