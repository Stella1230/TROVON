static enum mac_mode hns_get_enet_interface(const struct hns_mac_cb *mac_cb)\r\n{\r\nswitch (mac_cb->max_speed) {\r\ncase MAC_SPEED_100:\r\nreturn g_mac_mode_100[mac_cb->phy_if];\r\ncase MAC_SPEED_1000:\r\nreturn g_mac_mode_1000[mac_cb->phy_if];\r\ncase MAC_SPEED_10000:\r\nreturn MAC_MODE_XGMII_10000;\r\ndefault:\r\nreturn MAC_MODE_MII_100;\r\n}\r\n}\r\nvoid hns_mac_get_link_status(struct hns_mac_cb *mac_cb, u32 *link_status)\r\n{\r\nstruct mac_driver *mac_ctrl_drv;\r\nint ret, sfp_prsnt;\r\nmac_ctrl_drv = hns_mac_get_drv(mac_cb);\r\nif (mac_ctrl_drv->get_link_status)\r\nmac_ctrl_drv->get_link_status(mac_ctrl_drv, link_status);\r\nelse\r\n*link_status = 0;\r\nif (mac_cb->media_type == HNAE_MEDIA_TYPE_FIBER) {\r\nret = mac_cb->dsaf_dev->misc_op->get_sfp_prsnt(mac_cb,\r\n&sfp_prsnt);\r\nif (!ret)\r\n*link_status = *link_status && sfp_prsnt;\r\n}\r\nmac_cb->link = *link_status;\r\n}\r\nint hns_mac_get_port_info(struct hns_mac_cb *mac_cb,\r\nu8 *auto_neg, u16 *speed, u8 *duplex)\r\n{\r\nstruct mac_driver *mac_ctrl_drv;\r\nstruct mac_info info;\r\nmac_ctrl_drv = hns_mac_get_drv(mac_cb);\r\nif (!mac_ctrl_drv->get_info)\r\nreturn -ENODEV;\r\nmac_ctrl_drv->get_info(mac_ctrl_drv, &info);\r\nif (auto_neg)\r\n*auto_neg = info.auto_neg;\r\nif (speed)\r\n*speed = info.speed;\r\nif (duplex)\r\n*duplex = info.duplex;\r\nreturn 0;\r\n}\r\nvoid hns_mac_adjust_link(struct hns_mac_cb *mac_cb, int speed, int duplex)\r\n{\r\nint ret;\r\nstruct mac_driver *mac_ctrl_drv;\r\nmac_ctrl_drv = (struct mac_driver *)(mac_cb->priv.mac);\r\nmac_cb->speed = speed;\r\nmac_cb->half_duplex = !duplex;\r\nif (mac_ctrl_drv->adjust_link) {\r\nret = mac_ctrl_drv->adjust_link(mac_ctrl_drv,\r\n(enum mac_speed)speed, duplex);\r\nif (ret) {\r\ndev_err(mac_cb->dev,\r\n"adjust_link failed, %s mac%d ret = %#x!\n",\r\nmac_cb->dsaf_dev->ae_dev.name,\r\nmac_cb->mac_id, ret);\r\nreturn;\r\n}\r\n}\r\n}\r\nint hns_mac_get_inner_port_num(struct hns_mac_cb *mac_cb, u8 vmid, u8 *port_num)\r\n{\r\nint q_num_per_vf, vf_num_per_port;\r\nint vm_queue_id;\r\nu8 tmp_port;\r\nif (mac_cb->dsaf_dev->dsaf_mode <= DSAF_MODE_ENABLE) {\r\nif (mac_cb->mac_id != DSAF_MAX_PORT_NUM) {\r\ndev_err(mac_cb->dev,\r\n"input invalid, %s mac%d vmid%d !\n",\r\nmac_cb->dsaf_dev->ae_dev.name,\r\nmac_cb->mac_id, vmid);\r\nreturn -EINVAL;\r\n}\r\n} else if (mac_cb->dsaf_dev->dsaf_mode < DSAF_MODE_MAX) {\r\nif (mac_cb->mac_id >= DSAF_MAX_PORT_NUM) {\r\ndev_err(mac_cb->dev,\r\n"input invalid, %s mac%d vmid%d!\n",\r\nmac_cb->dsaf_dev->ae_dev.name,\r\nmac_cb->mac_id, vmid);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ndev_err(mac_cb->dev, "dsaf mode invalid, %s mac%d!\n",\r\nmac_cb->dsaf_dev->ae_dev.name, mac_cb->mac_id);\r\nreturn -EINVAL;\r\n}\r\nif (vmid >= mac_cb->dsaf_dev->rcb_common[0]->max_vfn) {\r\ndev_err(mac_cb->dev, "input invalid, %s mac%d vmid%d !\n",\r\nmac_cb->dsaf_dev->ae_dev.name, mac_cb->mac_id, vmid);\r\nreturn -EINVAL;\r\n}\r\nq_num_per_vf = mac_cb->dsaf_dev->rcb_common[0]->max_q_per_vf;\r\nvf_num_per_port = mac_cb->dsaf_dev->rcb_common[0]->max_vfn;\r\nvm_queue_id = vmid * q_num_per_vf +\r\nvf_num_per_port * q_num_per_vf * mac_cb->mac_id;\r\nswitch (mac_cb->dsaf_dev->dsaf_mode) {\r\ncase DSAF_MODE_ENABLE_FIX:\r\ntmp_port = 0;\r\nbreak;\r\ncase DSAF_MODE_DISABLE_FIX:\r\ntmp_port = 0;\r\nbreak;\r\ncase DSAF_MODE_ENABLE_0VM:\r\ncase DSAF_MODE_ENABLE_8VM:\r\ncase DSAF_MODE_ENABLE_16VM:\r\ncase DSAF_MODE_ENABLE_32VM:\r\ncase DSAF_MODE_ENABLE_128VM:\r\ncase DSAF_MODE_DISABLE_2PORT_8VM:\r\ncase DSAF_MODE_DISABLE_2PORT_16VM:\r\ncase DSAF_MODE_DISABLE_2PORT_64VM:\r\ncase DSAF_MODE_DISABLE_6PORT_0VM:\r\ncase DSAF_MODE_DISABLE_6PORT_2VM:\r\ncase DSAF_MODE_DISABLE_6PORT_4VM:\r\ncase DSAF_MODE_DISABLE_6PORT_16VM:\r\ntmp_port = vm_queue_id;\r\nbreak;\r\ndefault:\r\ndev_err(mac_cb->dev, "dsaf mode invalid, %s mac%d!\n",\r\nmac_cb->dsaf_dev->ae_dev.name, mac_cb->mac_id);\r\nreturn -EINVAL;\r\n}\r\ntmp_port += DSAF_BASE_INNER_PORT_NUM;\r\n*port_num = tmp_port;\r\nreturn 0;\r\n}\r\nint hns_mac_change_vf_addr(struct hns_mac_cb *mac_cb,\r\nu32 vmid, char *addr)\r\n{\r\nint ret;\r\nstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\r\nstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\r\nstruct dsaf_drv_mac_single_dest_entry mac_entry;\r\nstruct mac_entry_idx *old_entry;\r\nold_entry = &mac_cb->addr_entry_idx[vmid];\r\nif (!HNS_DSAF_IS_DEBUG(dsaf_dev)) {\r\nmemcpy(mac_entry.addr, addr, sizeof(mac_entry.addr));\r\nmac_entry.in_vlan_id = old_entry->vlan_id;\r\nmac_entry.in_port_num = mac_cb->mac_id;\r\nret = hns_mac_get_inner_port_num(mac_cb, (u8)vmid,\r\n&mac_entry.port_num);\r\nif (ret)\r\nreturn ret;\r\nif ((old_entry->valid != 0) &&\r\n(memcmp(old_entry->addr,\r\naddr, sizeof(mac_entry.addr)) != 0)) {\r\nret = hns_dsaf_del_mac_entry(dsaf_dev,\r\nold_entry->vlan_id,\r\nmac_cb->mac_id,\r\nold_entry->addr);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = hns_dsaf_set_mac_uc_entry(dsaf_dev, &mac_entry);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif ((mac_ctrl_drv->set_mac_addr) && (vmid == 0))\r\nmac_ctrl_drv->set_mac_addr(mac_cb->priv.mac, addr);\r\nmemcpy(old_entry->addr, addr, sizeof(old_entry->addr));\r\nold_entry->valid = 1;\r\nreturn 0;\r\n}\r\nint hns_mac_add_uc_addr(struct hns_mac_cb *mac_cb, u8 vf_id,\r\nconst unsigned char *addr)\r\n{\r\nstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\r\nstruct dsaf_drv_mac_single_dest_entry mac_entry;\r\nint ret;\r\nif (HNS_DSAF_IS_DEBUG(dsaf_dev))\r\nreturn -ENOSPC;\r\nmemset(&mac_entry, 0, sizeof(mac_entry));\r\nmemcpy(mac_entry.addr, addr, sizeof(mac_entry.addr));\r\nmac_entry.in_port_num = mac_cb->mac_id;\r\nret = hns_mac_get_inner_port_num(mac_cb, vf_id, &mac_entry.port_num);\r\nif (ret)\r\nreturn ret;\r\nreturn hns_dsaf_set_mac_uc_entry(dsaf_dev, &mac_entry);\r\n}\r\nint hns_mac_rm_uc_addr(struct hns_mac_cb *mac_cb, u8 vf_id,\r\nconst unsigned char *addr)\r\n{\r\nstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\r\nstruct dsaf_drv_mac_single_dest_entry mac_entry;\r\nint ret;\r\nif (HNS_DSAF_IS_DEBUG(dsaf_dev))\r\nreturn -ENOSPC;\r\nmemset(&mac_entry, 0, sizeof(mac_entry));\r\nmemcpy(mac_entry.addr, addr, sizeof(mac_entry.addr));\r\nmac_entry.in_port_num = mac_cb->mac_id;\r\nret = hns_mac_get_inner_port_num(mac_cb, vf_id, &mac_entry.port_num);\r\nif (ret)\r\nreturn ret;\r\nreturn hns_dsaf_rm_mac_addr(dsaf_dev, &mac_entry);\r\n}\r\nint hns_mac_set_multi(struct hns_mac_cb *mac_cb,\r\nu32 port_num, char *addr, bool enable)\r\n{\r\nint ret;\r\nstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\r\nstruct dsaf_drv_mac_single_dest_entry mac_entry;\r\nif (!HNS_DSAF_IS_DEBUG(dsaf_dev) && addr) {\r\nmemcpy(mac_entry.addr, addr, sizeof(mac_entry.addr));\r\nmac_entry.in_vlan_id = 0;\r\nmac_entry.in_port_num = mac_cb->mac_id;\r\nmac_entry.port_num = port_num;\r\nif (!enable)\r\nret = hns_dsaf_del_mac_mc_port(dsaf_dev, &mac_entry);\r\nelse\r\nret = hns_dsaf_add_mac_mc_port(dsaf_dev, &mac_entry);\r\nif (ret) {\r\ndev_err(dsaf_dev->dev,\r\n"set mac mc port failed, %s mac%d ret = %#x!\n",\r\nmac_cb->dsaf_dev->ae_dev.name,\r\nmac_cb->mac_id, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint hns_mac_clr_multicast(struct hns_mac_cb *mac_cb, int vfn)\r\n{\r\nstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\r\nu8 port_num;\r\nint ret = hns_mac_get_inner_port_num(mac_cb, vfn, &port_num);\r\nif (ret)\r\nreturn ret;\r\nreturn hns_dsaf_clr_mac_mc_port(dsaf_dev, mac_cb->mac_id, port_num);\r\n}\r\nstatic void hns_mac_param_get(struct mac_params *param,\r\nstruct hns_mac_cb *mac_cb)\r\n{\r\nparam->vaddr = (void *)mac_cb->vaddr;\r\nparam->mac_mode = hns_get_enet_interface(mac_cb);\r\nether_addr_copy(param->addr, mac_cb->addr_entry_idx[0].addr);\r\nparam->mac_id = mac_cb->mac_id;\r\nparam->dev = mac_cb->dev;\r\n}\r\nstatic int hns_mac_port_config_bc_en(struct hns_mac_cb *mac_cb,\r\nu32 port_num, u16 vlan_id, bool enable)\r\n{\r\nint ret;\r\nstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\r\nu8 addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nstruct dsaf_drv_mac_single_dest_entry mac_entry;\r\nif (mac_cb->mac_type == HNAE_PORT_DEBUG)\r\nreturn 0;\r\nif (!HNS_DSAF_IS_DEBUG(dsaf_dev)) {\r\nmemcpy(mac_entry.addr, addr, sizeof(mac_entry.addr));\r\nmac_entry.in_vlan_id = vlan_id;\r\nmac_entry.in_port_num = mac_cb->mac_id;\r\nmac_entry.port_num = port_num;\r\nif (!enable)\r\nret = hns_dsaf_del_mac_mc_port(dsaf_dev, &mac_entry);\r\nelse\r\nret = hns_dsaf_add_mac_mc_port(dsaf_dev, &mac_entry);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint hns_mac_vm_config_bc_en(struct hns_mac_cb *mac_cb, u32 vmid, bool enable)\r\n{\r\nint ret;\r\nstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\r\nu8 port_num;\r\nu8 addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nstruct mac_entry_idx *uc_mac_entry;\r\nstruct dsaf_drv_mac_single_dest_entry mac_entry;\r\nif (mac_cb->mac_type == HNAE_PORT_DEBUG)\r\nreturn 0;\r\nuc_mac_entry = &mac_cb->addr_entry_idx[vmid];\r\nif (!HNS_DSAF_IS_DEBUG(dsaf_dev)) {\r\nmemcpy(mac_entry.addr, addr, sizeof(mac_entry.addr));\r\nmac_entry.in_vlan_id = uc_mac_entry->vlan_id;\r\nmac_entry.in_port_num = mac_cb->mac_id;\r\nret = hns_mac_get_inner_port_num(mac_cb, vmid, &port_num);\r\nif (ret)\r\nreturn ret;\r\nmac_entry.port_num = port_num;\r\nif (!enable)\r\nret = hns_dsaf_del_mac_mc_port(dsaf_dev, &mac_entry);\r\nelse\r\nret = hns_dsaf_add_mac_mc_port(dsaf_dev, &mac_entry);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid hns_mac_reset(struct hns_mac_cb *mac_cb)\r\n{\r\nstruct mac_driver *drv = hns_mac_get_drv(mac_cb);\r\nbool is_ver1 = AE_IS_VER1(mac_cb->dsaf_dev->dsaf_ver);\r\ndrv->mac_init(drv);\r\nif (drv->config_max_frame_length)\r\ndrv->config_max_frame_length(drv, mac_cb->max_frm);\r\nif (drv->set_tx_auto_pause_frames)\r\ndrv->set_tx_auto_pause_frames(drv, mac_cb->tx_pause_frm_time);\r\nif (drv->set_an_mode)\r\ndrv->set_an_mode(drv, 1);\r\nif (drv->mac_pausefrm_cfg) {\r\nif (mac_cb->mac_type == HNAE_PORT_DEBUG)\r\ndrv->mac_pausefrm_cfg(drv, !is_ver1, !is_ver1);\r\nelse\r\ndrv->mac_pausefrm_cfg(drv, 0, 1);\r\n}\r\n}\r\nint hns_mac_set_mtu(struct hns_mac_cb *mac_cb, u32 new_mtu, u32 buf_size)\r\n{\r\nstruct mac_driver *drv = hns_mac_get_drv(mac_cb);\r\nu32 new_frm = new_mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN;\r\nu32 max_frm = AE_IS_VER1(mac_cb->dsaf_dev->dsaf_ver) ?\r\nMAC_MAX_MTU : MAC_MAX_MTU_V2;\r\nif (mac_cb->mac_type == HNAE_PORT_DEBUG)\r\nmax_frm = MAC_MAX_MTU_DBG;\r\nif (new_frm > HNS_RCB_RING_MAX_BD_PER_PKT * buf_size)\r\nreturn -EINVAL;\r\nif (!drv->config_max_frame_length)\r\nreturn -ECHILD;\r\nif (new_frm < (ETH_FRAME_LEN + ETH_FCS_LEN + VLAN_HLEN))\r\nnew_frm = (ETH_FRAME_LEN + ETH_FCS_LEN + VLAN_HLEN);\r\ndrv->config_max_frame_length(drv, new_frm);\r\nmac_cb->max_frm = new_frm;\r\nreturn 0;\r\n}\r\nvoid hns_mac_start(struct hns_mac_cb *mac_cb)\r\n{\r\nstruct mac_driver *mac_drv = hns_mac_get_drv(mac_cb);\r\nif (mac_drv->mac_en_flg == MAC_EN_FLAG_V) {\r\nmac_drv->virt_dev_num += 1;\r\nreturn;\r\n}\r\nif (mac_drv->mac_enable) {\r\nmac_drv->mac_enable(mac_cb->priv.mac, MAC_COMM_MODE_RX_AND_TX);\r\nmac_drv->mac_en_flg = MAC_EN_FLAG_V;\r\n}\r\n}\r\nvoid hns_mac_stop(struct hns_mac_cb *mac_cb)\r\n{\r\nstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\r\nif (mac_ctrl_drv->virt_dev_num > 0) {\r\nmac_ctrl_drv->virt_dev_num -= 1;\r\nif (mac_ctrl_drv->virt_dev_num > 0)\r\nreturn;\r\n}\r\nif (mac_ctrl_drv->mac_disable)\r\nmac_ctrl_drv->mac_disable(mac_cb->priv.mac,\r\nMAC_COMM_MODE_RX_AND_TX);\r\nmac_ctrl_drv->mac_en_flg = 0;\r\nmac_cb->link = 0;\r\nmac_cb->dsaf_dev->misc_op->cpld_reset_led(mac_cb);\r\n}\r\nvoid hns_mac_get_autoneg(struct hns_mac_cb *mac_cb, u32 *auto_neg)\r\n{\r\nstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\r\nif (mac_ctrl_drv->autoneg_stat)\r\nmac_ctrl_drv->autoneg_stat(mac_ctrl_drv, auto_neg);\r\nelse\r\n*auto_neg = 0;\r\n}\r\nvoid hns_mac_get_pauseparam(struct hns_mac_cb *mac_cb, u32 *rx_en, u32 *tx_en)\r\n{\r\nstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\r\nif (mac_ctrl_drv->get_pause_enable) {\r\nmac_ctrl_drv->get_pause_enable(mac_ctrl_drv, rx_en, tx_en);\r\n} else {\r\n*rx_en = 0;\r\n*tx_en = 0;\r\n}\r\n}\r\nint hns_mac_set_autoneg(struct hns_mac_cb *mac_cb, u8 enable)\r\n{\r\nstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\r\nif (mac_cb->phy_if == PHY_INTERFACE_MODE_XGMII && enable) {\r\ndev_err(mac_cb->dev, "enabling autoneg is not allowed!\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (mac_ctrl_drv->set_an_mode)\r\nmac_ctrl_drv->set_an_mode(mac_ctrl_drv, enable);\r\nreturn 0;\r\n}\r\nint hns_mac_set_pauseparam(struct hns_mac_cb *mac_cb, u32 rx_en, u32 tx_en)\r\n{\r\nstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\r\nbool is_ver1 = AE_IS_VER1(mac_cb->dsaf_dev->dsaf_ver);\r\nif (mac_cb->mac_type == HNAE_PORT_DEBUG) {\r\nif (is_ver1 && (tx_en || rx_en)) {\r\ndev_err(mac_cb->dev, "macv1 can't enable tx/rx_pause!\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (mac_ctrl_drv->mac_pausefrm_cfg)\r\nmac_ctrl_drv->mac_pausefrm_cfg(mac_ctrl_drv, rx_en, tx_en);\r\nreturn 0;\r\n}\r\nstatic int hns_mac_init_ex(struct hns_mac_cb *mac_cb)\r\n{\r\nint ret;\r\nstruct mac_params param;\r\nstruct mac_driver *drv;\r\nhns_dsaf_fix_mac_mode(mac_cb);\r\nmemset(&param, 0, sizeof(struct mac_params));\r\nhns_mac_param_get(&param, mac_cb);\r\nif (MAC_SPEED_FROM_MODE(param.mac_mode) < MAC_SPEED_10000)\r\ndrv = (struct mac_driver *)hns_gmac_config(mac_cb, &param);\r\nelse\r\ndrv = (struct mac_driver *)hns_xgmac_config(mac_cb, &param);\r\nif (!drv)\r\nreturn -ENOMEM;\r\nmac_cb->priv.mac = (void *)drv;\r\nhns_mac_reset(mac_cb);\r\nhns_mac_adjust_link(mac_cb, mac_cb->speed, !mac_cb->half_duplex);\r\nret = hns_mac_port_config_bc_en(mac_cb, mac_cb->mac_id, 0, true);\r\nif (ret)\r\ngoto free_mac_drv;\r\nreturn 0;\r\nfree_mac_drv:\r\ndrv->mac_free(mac_cb->priv.mac);\r\nmac_cb->priv.mac = NULL;\r\nreturn ret;\r\n}\r\nstatic int\r\nhns_mac_phy_parse_addr(struct device *dev, struct fwnode_handle *fwnode)\r\n{\r\nu32 addr;\r\nint ret;\r\nret = fwnode_property_read_u32(fwnode, "phy-addr", &addr);\r\nif (ret) {\r\ndev_err(dev, "has invalid PHY address ret:%d\n", ret);\r\nreturn ret;\r\n}\r\nif (addr >= PHY_MAX_ADDR) {\r\ndev_err(dev, "PHY address %i is too large\n", addr);\r\nreturn -EINVAL;\r\n}\r\nreturn addr;\r\n}\r\nstatic int\r\nhns_mac_register_phydev(struct mii_bus *mdio, struct hns_mac_cb *mac_cb,\r\nu32 addr)\r\n{\r\nstruct phy_device *phy;\r\nconst char *phy_type;\r\nbool is_c45;\r\nint rc;\r\nrc = fwnode_property_read_string(mac_cb->fw_port,\r\n"phy-mode", &phy_type);\r\nif (rc < 0)\r\nreturn rc;\r\nif (!strcmp(phy_type, phy_modes(PHY_INTERFACE_MODE_XGMII)))\r\nis_c45 = 1;\r\nelse if (!strcmp(phy_type, phy_modes(PHY_INTERFACE_MODE_SGMII)))\r\nis_c45 = 0;\r\nelse\r\nreturn -ENODATA;\r\nphy = get_phy_device(mdio, addr, is_c45);\r\nif (!phy || IS_ERR(phy))\r\nreturn -EIO;\r\nphy->irq = mdio->irq[addr];\r\nrc = phy_device_register(phy);\r\nif (rc) {\r\nphy_device_free(phy);\r\ndev_err(&mdio->dev, "registered phy fail at address %i\n",\r\naddr);\r\nreturn -ENODEV;\r\n}\r\nmac_cb->phy_dev = phy;\r\ndev_dbg(&mdio->dev, "registered phy at address %i\n", addr);\r\nreturn 0;\r\n}\r\nstatic int hns_mac_register_phy(struct hns_mac_cb *mac_cb)\r\n{\r\nstruct acpi_reference_args args;\r\nstruct platform_device *pdev;\r\nstruct mii_bus *mii_bus;\r\nint rc;\r\nint addr;\r\nif (!to_acpi_device_node(mac_cb->fw_port))\r\nreturn -ENODEV;\r\nrc = acpi_node_get_property_reference(\r\nmac_cb->fw_port, "mdio-node", 0, &args);\r\nif (rc)\r\nreturn rc;\r\naddr = hns_mac_phy_parse_addr(mac_cb->dev, mac_cb->fw_port);\r\nif (addr < 0)\r\nreturn addr;\r\npdev = hns_dsaf_find_platform_device(acpi_fwnode_handle(args.adev));\r\nif (!pdev) {\r\ndev_err(mac_cb->dev, "mac%d mdio pdev is NULL\n",\r\nmac_cb->mac_id);\r\nreturn -EINVAL;\r\n}\r\nmii_bus = platform_get_drvdata(pdev);\r\nif (!mii_bus) {\r\ndev_err(mac_cb->dev,\r\n"mac%d mdio is NULL, dsaf will probe again later\n",\r\nmac_cb->mac_id);\r\nreturn -EPROBE_DEFER;\r\n}\r\nrc = hns_mac_register_phydev(mii_bus, mac_cb, addr);\r\nif (!rc)\r\ndev_dbg(mac_cb->dev, "mac%d register phy addr:%d\n",\r\nmac_cb->mac_id, addr);\r\nreturn rc;\r\n}\r\nstatic int hns_mac_get_info(struct hns_mac_cb *mac_cb)\r\n{\r\nstruct device_node *np;\r\nstruct regmap *syscon;\r\nstruct of_phandle_args cpld_args;\r\nconst char *media_type;\r\nu32 i;\r\nu32 ret;\r\nmac_cb->link = false;\r\nmac_cb->half_duplex = false;\r\nmac_cb->media_type = HNAE_MEDIA_TYPE_UNKNOWN;\r\nmac_cb->speed = mac_phy_to_speed[mac_cb->phy_if];\r\nmac_cb->max_speed = mac_cb->speed;\r\nif (mac_cb->phy_if == PHY_INTERFACE_MODE_SGMII) {\r\nmac_cb->if_support = MAC_GMAC_SUPPORTED;\r\nmac_cb->if_support |= SUPPORTED_1000baseT_Full;\r\n} else if (mac_cb->phy_if == PHY_INTERFACE_MODE_XGMII) {\r\nmac_cb->if_support = SUPPORTED_10000baseR_FEC;\r\nmac_cb->if_support |= SUPPORTED_10000baseKR_Full;\r\n}\r\nmac_cb->max_frm = MAC_DEFAULT_MTU;\r\nmac_cb->tx_pause_frm_time = MAC_DEFAULT_PAUSE_TIME;\r\nmac_cb->port_rst_off = mac_cb->mac_id;\r\nmac_cb->port_mode_off = 0;\r\nif (!mac_cb->fw_port) {\r\nnp = of_parse_phandle(mac_cb->dev->of_node, "phy-handle",\r\nmac_cb->mac_id);\r\nmac_cb->phy_dev = of_phy_find_device(np);\r\nif (mac_cb->phy_dev) {\r\nput_device(&mac_cb->phy_dev->mdio.dev);\r\ndev_dbg(mac_cb->dev, "mac%d phy_node: %s\n",\r\nmac_cb->mac_id, np->name);\r\n}\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nif (is_of_node(mac_cb->fw_port)) {\r\nnp = of_parse_phandle(to_of_node(mac_cb->fw_port),\r\n"phy-handle", 0);\r\nmac_cb->phy_dev = of_phy_find_device(np);\r\nif (mac_cb->phy_dev) {\r\nput_device(&mac_cb->phy_dev->mdio.dev);\r\ndev_dbg(mac_cb->dev, "mac%d phy_node: %s\n",\r\nmac_cb->mac_id, np->name);\r\n}\r\nof_node_put(np);\r\nnp = of_parse_phandle(to_of_node(mac_cb->fw_port),\r\n"serdes-syscon", 0);\r\nsyscon = syscon_node_to_regmap(np);\r\nof_node_put(np);\r\nif (IS_ERR_OR_NULL(syscon)) {\r\ndev_err(mac_cb->dev, "serdes-syscon is needed!\n");\r\nreturn -EINVAL;\r\n}\r\nmac_cb->serdes_ctrl = syscon;\r\nret = fwnode_property_read_u32(mac_cb->fw_port,\r\n"port-rst-offset",\r\n&mac_cb->port_rst_off);\r\nif (ret) {\r\ndev_dbg(mac_cb->dev,\r\n"mac%d port-rst-offset not found, use default value.\n",\r\nmac_cb->mac_id);\r\n}\r\nret = fwnode_property_read_u32(mac_cb->fw_port,\r\n"port-mode-offset",\r\n&mac_cb->port_mode_off);\r\nif (ret) {\r\ndev_dbg(mac_cb->dev,\r\n"mac%d port-mode-offset not found, use default value.\n",\r\nmac_cb->mac_id);\r\n}\r\nret = of_parse_phandle_with_fixed_args(\r\nto_of_node(mac_cb->fw_port), "cpld-syscon", 1, 0,\r\n&cpld_args);\r\nif (ret) {\r\ndev_dbg(mac_cb->dev, "mac%d no cpld-syscon found.\n",\r\nmac_cb->mac_id);\r\nmac_cb->cpld_ctrl = NULL;\r\n} else {\r\nsyscon = syscon_node_to_regmap(cpld_args.np);\r\nif (IS_ERR_OR_NULL(syscon)) {\r\ndev_dbg(mac_cb->dev, "no cpld-syscon found!\n");\r\nmac_cb->cpld_ctrl = NULL;\r\n} else {\r\nmac_cb->cpld_ctrl = syscon;\r\nmac_cb->cpld_ctrl_reg = cpld_args.args[0];\r\n}\r\n}\r\n} else if (is_acpi_node(mac_cb->fw_port)) {\r\nret = hns_mac_register_phy(mac_cb);\r\nif (ret == -EPROBE_DEFER)\r\nreturn ret;\r\n} else {\r\ndev_err(mac_cb->dev, "mac%d cannot find phy node\n",\r\nmac_cb->mac_id);\r\n}\r\nif (!fwnode_property_read_string(mac_cb->fw_port, "media-type",\r\n&media_type)) {\r\nfor (i = 0; i < ARRAY_SIZE(media_type_defs); i++) {\r\nif (!strncmp(media_type_defs[i].name, media_type,\r\nMAC_MEDIA_TYPE_MAX_LEN)) {\r\nmac_cb->media_type = media_type_defs[i].value;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (fwnode_property_read_u8_array(mac_cb->fw_port, "mc-mac-mask",\r\nmac_cb->mc_mask, ETH_ALEN)) {\r\ndev_warn(mac_cb->dev,\r\n"no mc-mac-mask property, set to default value.\n");\r\neth_broadcast_addr(mac_cb->mc_mask);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hns_mac_get_mode(phy_interface_t phy_if)\r\n{\r\nswitch (phy_if) {\r\ncase PHY_INTERFACE_MODE_SGMII:\r\nreturn MAC_GMAC_IDX;\r\ncase PHY_INTERFACE_MODE_XGMII:\r\nreturn MAC_XGMAC_IDX;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nu8 __iomem *hns_mac_get_vaddr(struct dsaf_device *dsaf_dev,\r\nstruct hns_mac_cb *mac_cb, u32 mac_mode_idx)\r\n{\r\nu8 __iomem *base = dsaf_dev->io_base;\r\nint mac_id = mac_cb->mac_id;\r\nif (mac_cb->mac_type == HNAE_PORT_SERVICE)\r\nreturn base + 0x40000 + mac_id * 0x4000 -\r\nmac_mode_idx * 0x20000;\r\nelse\r\nreturn dsaf_dev->ppe_base + 0x1000;\r\n}\r\nint hns_mac_get_cfg(struct dsaf_device *dsaf_dev, struct hns_mac_cb *mac_cb)\r\n{\r\nint ret;\r\nu32 mac_mode_idx;\r\nmac_cb->dsaf_dev = dsaf_dev;\r\nmac_cb->dev = dsaf_dev->dev;\r\nmac_cb->sys_ctl_vaddr = dsaf_dev->sc_base;\r\nmac_cb->serdes_vaddr = dsaf_dev->sds_base;\r\nmac_cb->sfp_prsnt = 0;\r\nmac_cb->txpkt_for_led = 0;\r\nmac_cb->rxpkt_for_led = 0;\r\nif (!HNS_DSAF_IS_DEBUG(dsaf_dev))\r\nmac_cb->mac_type = HNAE_PORT_SERVICE;\r\nelse\r\nmac_cb->mac_type = HNAE_PORT_DEBUG;\r\nmac_cb->phy_if = dsaf_dev->misc_op->get_phy_if(mac_cb);\r\nret = hns_mac_get_mode(mac_cb->phy_if);\r\nif (ret < 0) {\r\ndev_err(dsaf_dev->dev,\r\n"hns_mac_get_mode failed, mac%d ret = %#x!\n",\r\nmac_cb->mac_id, ret);\r\nreturn ret;\r\n}\r\nmac_mode_idx = (u32)ret;\r\nret = hns_mac_get_info(mac_cb);\r\nif (ret)\r\nreturn ret;\r\nmac_cb->dsaf_dev->misc_op->cpld_reset_led(mac_cb);\r\nmac_cb->vaddr = hns_mac_get_vaddr(dsaf_dev, mac_cb, mac_mode_idx);\r\nreturn 0;\r\n}\r\nstatic int hns_mac_get_max_port_num(struct dsaf_device *dsaf_dev)\r\n{\r\nif (HNS_DSAF_IS_DEBUG(dsaf_dev))\r\nreturn 1;\r\nelse\r\nreturn DSAF_MAX_PORT_NUM;\r\n}\r\nint hns_mac_init(struct dsaf_device *dsaf_dev)\r\n{\r\nbool found = false;\r\nint ret;\r\nu32 port_id;\r\nint max_port_num = hns_mac_get_max_port_num(dsaf_dev);\r\nstruct hns_mac_cb *mac_cb;\r\nstruct fwnode_handle *child;\r\ndevice_for_each_child_node(dsaf_dev->dev, child) {\r\nret = fwnode_property_read_u32(child, "reg", &port_id);\r\nif (ret) {\r\ndev_err(dsaf_dev->dev,\r\n"get reg fail, ret=%d!\n", ret);\r\nreturn ret;\r\n}\r\nif (port_id >= max_port_num) {\r\ndev_err(dsaf_dev->dev,\r\n"reg(%u) out of range!\n", port_id);\r\nreturn -EINVAL;\r\n}\r\nmac_cb = devm_kzalloc(dsaf_dev->dev, sizeof(*mac_cb),\r\nGFP_KERNEL);\r\nif (!mac_cb)\r\nreturn -ENOMEM;\r\nmac_cb->fw_port = child;\r\nmac_cb->mac_id = (u8)port_id;\r\ndsaf_dev->mac_cb[port_id] = mac_cb;\r\nfound = true;\r\n}\r\nif (!found) {\r\nfor (port_id = 0; port_id < max_port_num; port_id++) {\r\nmac_cb = devm_kzalloc(dsaf_dev->dev, sizeof(*mac_cb),\r\nGFP_KERNEL);\r\nif (!mac_cb)\r\nreturn -ENOMEM;\r\nmac_cb->mac_id = port_id;\r\ndsaf_dev->mac_cb[port_id] = mac_cb;\r\n}\r\n}\r\nfor (port_id = 0; port_id < max_port_num; port_id++) {\r\nmac_cb = dsaf_dev->mac_cb[port_id];\r\nif (!mac_cb)\r\ncontinue;\r\nret = hns_mac_get_cfg(dsaf_dev, mac_cb);\r\nif (ret)\r\nreturn ret;\r\nret = hns_mac_init_ex(mac_cb);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid hns_mac_uninit(struct dsaf_device *dsaf_dev)\r\n{\r\nint i;\r\nint max_port_num = hns_mac_get_max_port_num(dsaf_dev);\r\nfor (i = 0; i < max_port_num; i++) {\r\ndsaf_dev->misc_op->cpld_reset_led(dsaf_dev->mac_cb[i]);\r\ndsaf_dev->mac_cb[i] = NULL;\r\n}\r\n}\r\nint hns_mac_config_mac_loopback(struct hns_mac_cb *mac_cb,\r\nenum hnae_loop loop, int en)\r\n{\r\nint ret;\r\nstruct mac_driver *drv = hns_mac_get_drv(mac_cb);\r\nif (drv->config_loopback)\r\nret = drv->config_loopback(drv, loop, en);\r\nelse\r\nret = -ENOTSUPP;\r\nreturn ret;\r\n}\r\nvoid hns_mac_update_stats(struct hns_mac_cb *mac_cb)\r\n{\r\nstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\r\nmac_ctrl_drv->update_stats(mac_ctrl_drv);\r\n}\r\nvoid hns_mac_get_stats(struct hns_mac_cb *mac_cb, u64 *data)\r\n{\r\nstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\r\nmac_ctrl_drv->get_ethtool_stats(mac_ctrl_drv, data);\r\n}\r\nvoid hns_mac_get_strings(struct hns_mac_cb *mac_cb,\r\nint stringset, u8 *data)\r\n{\r\nstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\r\nmac_ctrl_drv->get_strings(stringset, data);\r\n}\r\nint hns_mac_get_sset_count(struct hns_mac_cb *mac_cb, int stringset)\r\n{\r\nstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\r\nreturn mac_ctrl_drv->get_sset_count(stringset);\r\n}\r\nvoid hns_mac_set_promisc(struct hns_mac_cb *mac_cb, u8 en)\r\n{\r\nstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\r\nhns_dsaf_set_promisc_tcam(mac_cb->dsaf_dev, mac_cb->mac_id, !!en);\r\nif (mac_ctrl_drv->set_promiscuous)\r\nmac_ctrl_drv->set_promiscuous(mac_ctrl_drv, en);\r\n}\r\nint hns_mac_get_regs_count(struct hns_mac_cb *mac_cb)\r\n{\r\nstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\r\nreturn mac_ctrl_drv->get_regs_count();\r\n}\r\nvoid hns_mac_get_regs(struct hns_mac_cb *mac_cb, void *data)\r\n{\r\nstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\r\nmac_ctrl_drv->get_regs(mac_ctrl_drv, data);\r\n}\r\nvoid hns_set_led_opt(struct hns_mac_cb *mac_cb)\r\n{\r\nint nic_data = 0;\r\nint txpkts, rxpkts;\r\ntxpkts = mac_cb->txpkt_for_led - mac_cb->hw_stats.tx_good_pkts;\r\nrxpkts = mac_cb->rxpkt_for_led - mac_cb->hw_stats.rx_good_pkts;\r\nif (txpkts || rxpkts)\r\nnic_data = 1;\r\nelse\r\nnic_data = 0;\r\nmac_cb->txpkt_for_led = mac_cb->hw_stats.tx_good_pkts;\r\nmac_cb->rxpkt_for_led = mac_cb->hw_stats.rx_good_pkts;\r\nmac_cb->dsaf_dev->misc_op->cpld_set_led(mac_cb, (int)mac_cb->link,\r\nmac_cb->speed, nic_data);\r\n}\r\nint hns_cpld_led_set_id(struct hns_mac_cb *mac_cb,\r\nenum hnae_led_state status)\r\n{\r\nif (!mac_cb || !mac_cb->cpld_ctrl)\r\nreturn 0;\r\nreturn mac_cb->dsaf_dev->misc_op->cpld_set_led_id(mac_cb, status);\r\n}
