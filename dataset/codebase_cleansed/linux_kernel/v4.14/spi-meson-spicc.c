static inline bool meson_spicc_txfull(struct meson_spicc_device *spicc)\r\n{\r\nreturn !!FIELD_GET(SPICC_TF,\r\nreadl_relaxed(spicc->base + SPICC_STATREG));\r\n}\r\nstatic inline bool meson_spicc_rxready(struct meson_spicc_device *spicc)\r\n{\r\nreturn FIELD_GET(SPICC_RH | SPICC_RR | SPICC_RF_EN,\r\nreadl_relaxed(spicc->base + SPICC_STATREG));\r\n}\r\nstatic inline u32 meson_spicc_pull_data(struct meson_spicc_device *spicc)\r\n{\r\nunsigned int bytes = spicc->bytes_per_word;\r\nunsigned int byte_shift = 0;\r\nu32 data = 0;\r\nu8 byte;\r\nwhile (bytes--) {\r\nbyte = *spicc->tx_buf++;\r\ndata |= (byte & 0xff) << byte_shift;\r\nbyte_shift += 8;\r\n}\r\nspicc->tx_remain--;\r\nreturn data;\r\n}\r\nstatic inline void meson_spicc_push_data(struct meson_spicc_device *spicc,\r\nu32 data)\r\n{\r\nunsigned int bytes = spicc->bytes_per_word;\r\nunsigned int byte_shift = 0;\r\nu8 byte;\r\nwhile (bytes--) {\r\nbyte = (data >> byte_shift) & 0xff;\r\n*spicc->rx_buf++ = byte;\r\nbyte_shift += 8;\r\n}\r\nspicc->rx_remain--;\r\n}\r\nstatic inline void meson_spicc_rx(struct meson_spicc_device *spicc)\r\n{\r\nwhile (spicc->rx_remain &&\r\nmeson_spicc_rxready(spicc))\r\nmeson_spicc_push_data(spicc,\r\nreadl_relaxed(spicc->base + SPICC_RXDATA));\r\n}\r\nstatic inline void meson_spicc_tx(struct meson_spicc_device *spicc)\r\n{\r\nwhile (spicc->tx_remain &&\r\n!meson_spicc_txfull(spicc))\r\nwritel_relaxed(meson_spicc_pull_data(spicc),\r\nspicc->base + SPICC_TXDATA);\r\n}\r\nstatic inline u32 meson_spicc_setup_rx_irq(struct meson_spicc_device *spicc,\r\nu32 irq_ctrl)\r\n{\r\nif (spicc->rx_remain > SPICC_FIFO_HALF)\r\nirq_ctrl |= SPICC_RH_EN;\r\nelse\r\nirq_ctrl |= SPICC_RR_EN;\r\nreturn irq_ctrl;\r\n}\r\nstatic inline void meson_spicc_setup_burst(struct meson_spicc_device *spicc,\r\nunsigned int burst_len)\r\n{\r\nspicc->tx_remain = burst_len;\r\nspicc->rx_remain = burst_len;\r\nspicc->xfer_remain -= burst_len * spicc->bytes_per_word;\r\nspicc->is_burst_end = false;\r\nif (burst_len < SPICC_BURST_MAX || !spicc->xfer_remain)\r\nspicc->is_last_burst = true;\r\nelse\r\nspicc->is_last_burst = false;\r\nwritel_bits_relaxed(SPICC_BURSTLENGTH_MASK,\r\nFIELD_PREP(SPICC_BURSTLENGTH_MASK,\r\nburst_len),\r\nspicc->base + SPICC_CONREG);\r\nmeson_spicc_tx(spicc);\r\n}\r\nstatic irqreturn_t meson_spicc_irq(int irq, void *data)\r\n{\r\nstruct meson_spicc_device *spicc = (void *) data;\r\nu32 ctrl = readl_relaxed(spicc->base + SPICC_INTREG);\r\nu32 stat = readl_relaxed(spicc->base + SPICC_STATREG) & ctrl;\r\nctrl &= ~(SPICC_RH_EN | SPICC_RR_EN);\r\nmeson_spicc_rx(spicc);\r\nif (!spicc->tx_remain && !spicc->rx_remain) {\r\nspicc->is_burst_end = true;\r\nctrl |= SPICC_TC_EN;\r\nstat = readl_relaxed(spicc->base + SPICC_STATREG) & ctrl;\r\n}\r\nif ((stat & SPICC_TC) && spicc->is_burst_end) {\r\nunsigned int burst_len;\r\nwritel_relaxed(SPICC_TC, spicc->base + SPICC_STATREG);\r\nctrl &= ~SPICC_TC_EN;\r\nif (spicc->is_last_burst) {\r\nwritel(0, spicc->base + SPICC_INTREG);\r\nspi_finalize_current_transfer(spicc->master);\r\nreturn IRQ_HANDLED;\r\n}\r\nburst_len = min_t(unsigned int,\r\nspicc->xfer_remain / spicc->bytes_per_word,\r\nSPICC_BURST_MAX);\r\nmeson_spicc_setup_burst(spicc, burst_len);\r\nwritel_bits_relaxed(SPICC_XCH, SPICC_XCH,\r\nspicc->base + SPICC_CONREG);\r\n}\r\nctrl = meson_spicc_setup_rx_irq(spicc, ctrl);\r\nwritel(ctrl, spicc->base + SPICC_INTREG);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u32 meson_spicc_setup_speed(struct meson_spicc_device *spicc, u32 conf,\r\nu32 speed)\r\n{\r\nunsigned long parent, value;\r\nunsigned int i, div;\r\nparent = clk_get_rate(spicc->core);\r\nfor (i = 0 ; i < 7 ; ++i) {\r\nvalue = parent >> (i + 2);\r\nif (value <= speed)\r\nbreak;\r\n}\r\nif (i > 7) {\r\ndiv = 7;\r\ndev_warn_once(&spicc->pdev->dev, "unable to get close to speed %u\n",\r\nspeed);\r\n} else\r\ndiv = i;\r\ndev_dbg(&spicc->pdev->dev, "parent %lu, speed %u -> %lu (%u)\n",\r\nparent, speed, value, div);\r\nconf &= ~SPICC_DATARATE_MASK;\r\nconf |= FIELD_PREP(SPICC_DATARATE_MASK, div);\r\nreturn conf;\r\n}\r\nstatic void meson_spicc_setup_xfer(struct meson_spicc_device *spicc,\r\nstruct spi_transfer *xfer)\r\n{\r\nu32 conf, conf_orig;\r\nconf = conf_orig = readl_relaxed(spicc->base + SPICC_CONREG);\r\nconf = meson_spicc_setup_speed(spicc, conf, xfer->speed_hz);\r\nconf &= ~SPICC_BITLENGTH_MASK;\r\nconf |= FIELD_PREP(SPICC_BITLENGTH_MASK,\r\n(spicc->bytes_per_word << 3) - 1);\r\nif (conf != conf_orig)\r\nwritel_relaxed(conf, spicc->base + SPICC_CONREG);\r\n}\r\nstatic int meson_spicc_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct meson_spicc_device *spicc = spi_master_get_devdata(master);\r\nunsigned int burst_len;\r\nu32 irq = 0;\r\nspicc->xfer = xfer;\r\nspicc->tx_buf = (u8 *)xfer->tx_buf;\r\nspicc->rx_buf = (u8 *)xfer->rx_buf;\r\nspicc->xfer_remain = xfer->len;\r\nspicc->bytes_per_word =\r\nDIV_ROUND_UP(spicc->xfer->bits_per_word, 8);\r\nmeson_spicc_setup_xfer(spicc, xfer);\r\nburst_len = min_t(unsigned int,\r\nspicc->xfer_remain / spicc->bytes_per_word,\r\nSPICC_BURST_MAX);\r\nmeson_spicc_setup_burst(spicc, burst_len);\r\nirq = meson_spicc_setup_rx_irq(spicc, irq);\r\nwritel_bits_relaxed(SPICC_XCH, SPICC_XCH, spicc->base + SPICC_CONREG);\r\nwritel_relaxed(irq, spicc->base + SPICC_INTREG);\r\nreturn 1;\r\n}\r\nstatic int meson_spicc_prepare_message(struct spi_master *master,\r\nstruct spi_message *message)\r\n{\r\nstruct meson_spicc_device *spicc = spi_master_get_devdata(master);\r\nstruct spi_device *spi = message->spi;\r\nu32 conf = 0;\r\nspicc->message = message;\r\nconf |= SPICC_ENABLE;\r\nconf |= SPICC_MODE_MASTER;\r\nif (spi->mode & SPI_CPOL)\r\nconf |= SPICC_POL;\r\nelse\r\nconf &= ~SPICC_POL;\r\nif (spi->mode & SPI_CPHA)\r\nconf |= SPICC_PHA;\r\nelse\r\nconf &= ~SPICC_PHA;\r\nif (spi->mode & SPI_CS_HIGH)\r\nconf |= SPICC_SSPOL;\r\nelse\r\nconf &= ~SPICC_SSPOL;\r\nif (spi->mode & SPI_READY)\r\nconf |= FIELD_PREP(SPICC_DRCTL_MASK, SPICC_DRCTL_LOWLEVEL);\r\nelse\r\nconf |= FIELD_PREP(SPICC_DRCTL_MASK, SPICC_DRCTL_IGNORE);\r\nconf |= FIELD_PREP(SPICC_CS_MASK, spi->chip_select);\r\nconf |= FIELD_PREP(SPICC_BITLENGTH_MASK, 8 - 1);\r\nwritel_relaxed(conf, spicc->base + SPICC_CONREG);\r\nwritel_relaxed(0, spicc->base + SPICC_PERIODREG);\r\nwritel_bits_relaxed(BIT(24), BIT(24), spicc->base + SPICC_TESTREG);\r\nreturn 0;\r\n}\r\nstatic int meson_spicc_unprepare_transfer(struct spi_master *master)\r\n{\r\nstruct meson_spicc_device *spicc = spi_master_get_devdata(master);\r\nwritel(0, spicc->base + SPICC_INTREG);\r\nwritel_bits_relaxed(SPICC_ENABLE, 0, spicc->base + SPICC_CONREG);\r\ndevice_reset_optional(&spicc->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int meson_spicc_setup(struct spi_device *spi)\r\n{\r\nint ret = 0;\r\nif (!spi->controller_state)\r\nspi->controller_state = spi_master_get_devdata(spi->master);\r\nelse if (gpio_is_valid(spi->cs_gpio))\r\ngoto out_gpio;\r\nelse if (spi->cs_gpio == -ENOENT)\r\nreturn 0;\r\nif (gpio_is_valid(spi->cs_gpio)) {\r\nret = gpio_request(spi->cs_gpio, dev_name(&spi->dev));\r\nif (ret) {\r\ndev_err(&spi->dev, "failed to request cs gpio\n");\r\nreturn ret;\r\n}\r\n}\r\nout_gpio:\r\nret = gpio_direction_output(spi->cs_gpio,\r\n!(spi->mode & SPI_CS_HIGH));\r\nreturn ret;\r\n}\r\nstatic void meson_spicc_cleanup(struct spi_device *spi)\r\n{\r\nif (gpio_is_valid(spi->cs_gpio))\r\ngpio_free(spi->cs_gpio);\r\nspi->controller_state = NULL;\r\n}\r\nstatic int meson_spicc_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct meson_spicc_device *spicc;\r\nstruct resource *res;\r\nint ret, irq, rate;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*spicc));\r\nif (!master) {\r\ndev_err(&pdev->dev, "master allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nspicc = spi_master_get_devdata(master);\r\nspicc->master = master;\r\nspicc->pdev = pdev;\r\nplatform_set_drvdata(pdev, spicc);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nspicc->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(spicc->base)) {\r\ndev_err(&pdev->dev, "io resource mapping failed\n");\r\nret = PTR_ERR(spicc->base);\r\ngoto out_master;\r\n}\r\nwritel_relaxed(0, spicc->base + SPICC_INTREG);\r\nirq = platform_get_irq(pdev, 0);\r\nret = devm_request_irq(&pdev->dev, irq, meson_spicc_irq,\r\n0, NULL, spicc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "irq request failed\n");\r\ngoto out_master;\r\n}\r\nspicc->core = devm_clk_get(&pdev->dev, "core");\r\nif (IS_ERR(spicc->core)) {\r\ndev_err(&pdev->dev, "core clock request failed\n");\r\nret = PTR_ERR(spicc->core);\r\ngoto out_master;\r\n}\r\nret = clk_prepare_enable(spicc->core);\r\nif (ret) {\r\ndev_err(&pdev->dev, "core clock enable failed\n");\r\ngoto out_master;\r\n}\r\nrate = clk_get_rate(spicc->core);\r\ndevice_reset_optional(&pdev->dev);\r\nmaster->num_chipselect = 4;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->mode_bits = SPI_CPHA | SPI_CPOL | SPI_CS_HIGH;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(32) |\r\nSPI_BPW_MASK(24) |\r\nSPI_BPW_MASK(16) |\r\nSPI_BPW_MASK(8);\r\nmaster->flags = (SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX);\r\nmaster->min_speed_hz = rate >> 9;\r\nmaster->setup = meson_spicc_setup;\r\nmaster->cleanup = meson_spicc_cleanup;\r\nmaster->prepare_message = meson_spicc_prepare_message;\r\nmaster->unprepare_transfer_hardware = meson_spicc_unprepare_transfer;\r\nmaster->transfer_one = meson_spicc_transfer_one;\r\nif ((rate >> 2) > SPICC_MAX_FREQ)\r\nmaster->max_speed_hz = SPICC_MAX_FREQ;\r\nelse\r\nmaster->max_speed_hz = rate >> 2;\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (!ret)\r\nreturn 0;\r\ndev_err(&pdev->dev, "spi master registration failed\n");\r\nout_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int meson_spicc_remove(struct platform_device *pdev)\r\n{\r\nstruct meson_spicc_device *spicc = platform_get_drvdata(pdev);\r\nwritel(0, spicc->base + SPICC_CONREG);\r\nclk_disable_unprepare(spicc->core);\r\nreturn 0;\r\n}
