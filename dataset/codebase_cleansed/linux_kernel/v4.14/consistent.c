void *consistent_alloc(gfp_t gfp, size_t size, dma_addr_t *dma_handle)\r\n{\r\nunsigned long order, vaddr;\r\nvoid *ret;\r\nunsigned int i, err = 0;\r\nstruct page *page, *end;\r\n#ifdef CONFIG_MMU\r\nphys_addr_t pa;\r\nstruct vm_struct *area;\r\nunsigned long va;\r\n#endif\r\nif (in_interrupt())\r\nBUG();\r\nsize = PAGE_ALIGN(size);\r\norder = get_order(size);\r\nvaddr = __get_free_pages(gfp, order);\r\nif (!vaddr)\r\nreturn NULL;\r\nflush_dcache_range(virt_to_phys((void *)vaddr),\r\nvirt_to_phys((void *)vaddr) + size);\r\n#ifndef CONFIG_MMU\r\nret = (void *)vaddr;\r\n# ifdef CONFIG_XILINX_UNCACHED_SHADOW\r\nret = (void *)((unsigned) ret | UNCACHED_SHADOW_MASK);\r\n# endif\r\nif ((unsigned int)ret > cpuinfo.dcache_base &&\r\n(unsigned int)ret < cpuinfo.dcache_high)\r\npr_warn("ERROR: Your cache coherent area is CACHED!!!\n");\r\n*dma_handle = (dma_addr_t)ret;\r\n#else\r\narea = get_vm_area(size, VM_ALLOC);\r\nif (!area) {\r\nfree_pages(vaddr, order);\r\nreturn NULL;\r\n}\r\nva = (unsigned long) area->addr;\r\nret = (void *)va;\r\n*dma_handle = pa = __virt_to_phys(vaddr);\r\n#endif\r\npage = virt_to_page(vaddr);\r\nend = page + (1 << order);\r\nsplit_page(page, order);\r\nfor (i = 0; i < size && err == 0; i += PAGE_SIZE) {\r\n#ifdef CONFIG_MMU\r\nerr = map_page(va + i, pa + i, _PAGE_KERNEL | _PAGE_NO_CACHE);\r\n#endif\r\nSetPageReserved(page);\r\npage++;\r\n}\r\nwhile (page < end) {\r\n__free_page(page);\r\npage++;\r\n}\r\nif (err) {\r\nfree_pages(vaddr, order);\r\nreturn NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic pte_t *consistent_virt_to_pte(void *vaddr)\r\n{\r\nunsigned long addr = (unsigned long)vaddr;\r\nreturn pte_offset_kernel(pmd_offset(pgd_offset_k(addr), addr), addr);\r\n}\r\nunsigned long consistent_virt_to_pfn(void *vaddr)\r\n{\r\npte_t *ptep = consistent_virt_to_pte(vaddr);\r\nif (pte_none(*ptep) || !pte_present(*ptep))\r\nreturn 0;\r\nreturn pte_pfn(*ptep);\r\n}\r\nvoid consistent_free(size_t size, void *vaddr)\r\n{\r\nstruct page *page;\r\nif (in_interrupt())\r\nBUG();\r\nsize = PAGE_ALIGN(size);\r\n#ifndef CONFIG_MMU\r\n# ifdef CONFIG_XILINX_UNCACHED_SHADOW\r\nvaddr = (void *)((unsigned)vaddr & ~UNCACHED_SHADOW_MASK);\r\n# endif\r\npage = virt_to_page(vaddr);\r\ndo {\r\n__free_reserved_page(page);\r\npage++;\r\n} while (size -= PAGE_SIZE);\r\n#else\r\ndo {\r\npte_t *ptep = consistent_virt_to_pte(vaddr);\r\nunsigned long pfn;\r\nif (!pte_none(*ptep) && pte_present(*ptep)) {\r\npfn = pte_pfn(*ptep);\r\npte_clear(&init_mm, (unsigned int)vaddr, ptep);\r\nif (pfn_valid(pfn)) {\r\npage = pfn_to_page(pfn);\r\n__free_reserved_page(page);\r\n}\r\n}\r\nvaddr += PAGE_SIZE;\r\n} while (size -= PAGE_SIZE);\r\nflush_tlb_all();\r\n#endif\r\n}\r\nvoid consistent_sync(void *vaddr, size_t size, int direction)\r\n{\r\nunsigned long start;\r\nunsigned long end;\r\nstart = (unsigned long)vaddr;\r\n#ifdef CONFIG_XILINX_UNCACHED_SHADOW\r\nstart &= ~UNCACHED_SHADOW_MASK;\r\n#endif\r\nend = start + size;\r\nswitch (direction) {\r\ncase PCI_DMA_NONE:\r\nBUG();\r\ncase PCI_DMA_FROMDEVICE:\r\ninvalidate_dcache_range(start, end);\r\nbreak;\r\ncase PCI_DMA_TODEVICE:\r\nflush_dcache_range(start, end);\r\nbreak;\r\ncase PCI_DMA_BIDIRECTIONAL:\r\nflush_dcache_range(start, end);\r\nbreak;\r\n}\r\n}\r\nvoid consistent_sync_page(struct page *page, unsigned long offset,\r\nsize_t size, int direction)\r\n{\r\nunsigned long start = (unsigned long)page_address(page) + offset;\r\nconsistent_sync((void *)start, size, direction);\r\n}
