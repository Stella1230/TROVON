static int vmw_open_channel(struct rpc_channel *channel, unsigned int protocol)\r\n{\r\nunsigned long eax, ebx, ecx, edx, si = 0, di = 0;\r\nVMW_PORT(VMW_PORT_CMD_OPEN_CHANNEL,\r\n(protocol | GUESTMSG_FLAG_COOKIE), si, di,\r\nVMW_HYPERVISOR_PORT,\r\nVMW_HYPERVISOR_MAGIC,\r\neax, ebx, ecx, edx, si, di);\r\nif ((HIGH_WORD(ecx) & MESSAGE_STATUS_SUCCESS) == 0)\r\nreturn -EINVAL;\r\nchannel->channel_id = HIGH_WORD(edx);\r\nchannel->cookie_high = si;\r\nchannel->cookie_low = di;\r\nreturn 0;\r\n}\r\nstatic int vmw_close_channel(struct rpc_channel *channel)\r\n{\r\nunsigned long eax, ebx, ecx, edx, si, di;\r\nsi = channel->cookie_high;\r\ndi = channel->cookie_low;\r\nVMW_PORT(VMW_PORT_CMD_CLOSE_CHANNEL,\r\n0, si, di,\r\n(VMW_HYPERVISOR_PORT | (channel->channel_id << 16)),\r\nVMW_HYPERVISOR_MAGIC,\r\neax, ebx, ecx, edx, si, di);\r\nif ((HIGH_WORD(ecx) & MESSAGE_STATUS_SUCCESS) == 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int vmw_send_msg(struct rpc_channel *channel, const char *msg)\r\n{\r\nunsigned long eax, ebx, ecx, edx, si, di, bp;\r\nsize_t msg_len = strlen(msg);\r\nint retries = 0;\r\nwhile (retries < RETRIES) {\r\nretries++;\r\nsi = channel->cookie_high;\r\ndi = channel->cookie_low;\r\nVMW_PORT(VMW_PORT_CMD_SENDSIZE,\r\nmsg_len, si, di,\r\nVMW_HYPERVISOR_PORT | (channel->channel_id << 16),\r\nVMW_HYPERVISOR_MAGIC,\r\neax, ebx, ecx, edx, si, di);\r\nif ((HIGH_WORD(ecx) & MESSAGE_STATUS_SUCCESS) == 0 ||\r\n(HIGH_WORD(ecx) & MESSAGE_STATUS_HB) == 0) {\r\nreturn -EINVAL;\r\n}\r\nsi = (uintptr_t) msg;\r\ndi = channel->cookie_low;\r\nbp = channel->cookie_high;\r\nVMW_PORT_HB_OUT(\r\n(MESSAGE_STATUS_SUCCESS << 16) | VMW_PORT_CMD_HB_MSG,\r\nmsg_len, si, di,\r\nVMW_HYPERVISOR_HB_PORT | (channel->channel_id << 16),\r\nVMW_HYPERVISOR_MAGIC, bp,\r\neax, ebx, ecx, edx, si, di);\r\nif ((HIGH_WORD(ebx) & MESSAGE_STATUS_SUCCESS) != 0) {\r\nreturn 0;\r\n} else if ((HIGH_WORD(ebx) & MESSAGE_STATUS_CPT) != 0) {\r\ncontinue;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vmw_recv_msg(struct rpc_channel *channel, void **msg,\r\nsize_t *msg_len)\r\n{\r\nunsigned long eax, ebx, ecx, edx, si, di, bp;\r\nchar *reply;\r\nsize_t reply_len;\r\nint retries = 0;\r\n*msg_len = 0;\r\n*msg = NULL;\r\nwhile (retries < RETRIES) {\r\nretries++;\r\nsi = channel->cookie_high;\r\ndi = channel->cookie_low;\r\nVMW_PORT(VMW_PORT_CMD_RECVSIZE,\r\n0, si, di,\r\n(VMW_HYPERVISOR_PORT | (channel->channel_id << 16)),\r\nVMW_HYPERVISOR_MAGIC,\r\neax, ebx, ecx, edx, si, di);\r\nif ((HIGH_WORD(ecx) & MESSAGE_STATUS_SUCCESS) == 0 ||\r\n(HIGH_WORD(ecx) & MESSAGE_STATUS_HB) == 0) {\r\nDRM_ERROR("Failed to get reply size\n");\r\nreturn -EINVAL;\r\n}\r\nif ((HIGH_WORD(ecx) & MESSAGE_STATUS_DORECV) == 0)\r\nreturn 0;\r\nreply_len = ebx;\r\nreply = kzalloc(reply_len + 1, GFP_KERNEL);\r\nif (!reply) {\r\nDRM_ERROR("Cannot allocate memory for reply\n");\r\nreturn -ENOMEM;\r\n}\r\nsi = channel->cookie_high;\r\ndi = (uintptr_t) reply;\r\nbp = channel->cookie_low;\r\nVMW_PORT_HB_IN(\r\n(MESSAGE_STATUS_SUCCESS << 16) | VMW_PORT_CMD_HB_MSG,\r\nreply_len, si, di,\r\nVMW_HYPERVISOR_HB_PORT | (channel->channel_id << 16),\r\nVMW_HYPERVISOR_MAGIC, bp,\r\neax, ebx, ecx, edx, si, di);\r\nif ((HIGH_WORD(ebx) & MESSAGE_STATUS_SUCCESS) == 0) {\r\nkfree(reply);\r\nif ((HIGH_WORD(ebx) & MESSAGE_STATUS_CPT) != 0) {\r\ncontinue;\r\n}\r\nreturn -EINVAL;\r\n}\r\nreply[reply_len] = '\0';\r\nsi = channel->cookie_high;\r\ndi = channel->cookie_low;\r\nVMW_PORT(VMW_PORT_CMD_RECVSTATUS,\r\nMESSAGE_STATUS_SUCCESS, si, di,\r\n(VMW_HYPERVISOR_PORT | (channel->channel_id << 16)),\r\nVMW_HYPERVISOR_MAGIC,\r\neax, ebx, ecx, edx, si, di);\r\nif ((HIGH_WORD(ecx) & MESSAGE_STATUS_SUCCESS) == 0) {\r\nkfree(reply);\r\nif ((HIGH_WORD(ecx) & MESSAGE_STATUS_CPT) != 0) {\r\ncontinue;\r\n}\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\nif (retries == RETRIES)\r\nreturn -EINVAL;\r\n*msg_len = reply_len;\r\n*msg = reply;\r\nreturn 0;\r\n}\r\nint vmw_host_get_guestinfo(const char *guest_info_param,\r\nchar *buffer, size_t *length)\r\n{\r\nstruct rpc_channel channel;\r\nchar *msg, *reply = NULL;\r\nsize_t msg_len, reply_len = 0;\r\nint ret = 0;\r\nif (!vmw_msg_enabled)\r\nreturn -ENODEV;\r\nif (!guest_info_param || !length)\r\nreturn -EINVAL;\r\nmsg_len = strlen(guest_info_param) + strlen("info-get ") + 1;\r\nmsg = kzalloc(msg_len, GFP_KERNEL);\r\nif (!msg) {\r\nDRM_ERROR("Cannot allocate memory to get %s", guest_info_param);\r\nreturn -ENOMEM;\r\n}\r\nsprintf(msg, "info-get %s", guest_info_param);\r\nif (vmw_open_channel(&channel, RPCI_PROTOCOL_NUM) ||\r\nvmw_send_msg(&channel, msg) ||\r\nvmw_recv_msg(&channel, (void *) &reply, &reply_len) ||\r\nvmw_close_channel(&channel)) {\r\nDRM_ERROR("Failed to get %s", guest_info_param);\r\nret = -EINVAL;\r\n}\r\nif (buffer && reply && reply_len > 0) {\r\nreply_len = max(reply_len - 2, (size_t) 0);\r\nreply_len = min(reply_len, *length);\r\nif (reply_len > 0)\r\nmemcpy(buffer, reply + 2, reply_len);\r\n}\r\n*length = reply_len;\r\nkfree(reply);\r\nkfree(msg);\r\nreturn ret;\r\n}\r\nint vmw_host_log(const char *log)\r\n{\r\nstruct rpc_channel channel;\r\nchar *msg;\r\nint msg_len;\r\nint ret = 0;\r\nif (!vmw_msg_enabled)\r\nreturn -ENODEV;\r\nif (!log)\r\nreturn ret;\r\nmsg_len = strlen(log) + strlen("log ") + 1;\r\nmsg = kzalloc(msg_len, GFP_KERNEL);\r\nif (!msg) {\r\nDRM_ERROR("Cannot allocate memory for log message\n");\r\nreturn -ENOMEM;\r\n}\r\nsprintf(msg, "log %s", log);\r\nif (vmw_open_channel(&channel, RPCI_PROTOCOL_NUM) ||\r\nvmw_send_msg(&channel, msg) ||\r\nvmw_close_channel(&channel)) {\r\nDRM_ERROR("Failed to send log\n");\r\nret = -EINVAL;\r\n}\r\nkfree(msg);\r\nreturn ret;\r\n}
