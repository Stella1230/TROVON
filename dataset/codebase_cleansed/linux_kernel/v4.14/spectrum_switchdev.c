static struct mlxsw_sp_bridge_device *\r\nmlxsw_sp_bridge_device_find(const struct mlxsw_sp_bridge *bridge,\r\nconst struct net_device *br_dev)\r\n{\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nlist_for_each_entry(bridge_device, &bridge->bridges_list, list)\r\nif (bridge_device->dev == br_dev)\r\nreturn bridge_device;\r\nreturn NULL;\r\n}\r\nstatic struct mlxsw_sp_bridge_device *\r\nmlxsw_sp_bridge_device_create(struct mlxsw_sp_bridge *bridge,\r\nstruct net_device *br_dev)\r\n{\r\nstruct device *dev = bridge->mlxsw_sp->bus_info->dev;\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nbool vlan_enabled = br_vlan_enabled(br_dev);\r\nif (vlan_enabled && bridge->vlan_enabled_exists) {\r\ndev_err(dev, "Only one VLAN-aware bridge is supported\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nbridge_device = kzalloc(sizeof(*bridge_device), GFP_KERNEL);\r\nif (!bridge_device)\r\nreturn ERR_PTR(-ENOMEM);\r\nbridge_device->dev = br_dev;\r\nbridge_device->vlan_enabled = vlan_enabled;\r\nbridge_device->multicast_enabled = br_multicast_enabled(br_dev);\r\nINIT_LIST_HEAD(&bridge_device->ports_list);\r\nif (vlan_enabled) {\r\nbridge->vlan_enabled_exists = true;\r\nbridge_device->ops = bridge->bridge_8021q_ops;\r\n} else {\r\nbridge_device->ops = bridge->bridge_8021d_ops;\r\n}\r\nlist_add(&bridge_device->list, &bridge->bridges_list);\r\nreturn bridge_device;\r\n}\r\nstatic void\r\nmlxsw_sp_bridge_device_destroy(struct mlxsw_sp_bridge *bridge,\r\nstruct mlxsw_sp_bridge_device *bridge_device)\r\n{\r\nlist_del(&bridge_device->list);\r\nif (bridge_device->vlan_enabled)\r\nbridge->vlan_enabled_exists = false;\r\nWARN_ON(!list_empty(&bridge_device->ports_list));\r\nkfree(bridge_device);\r\n}\r\nstatic struct mlxsw_sp_bridge_device *\r\nmlxsw_sp_bridge_device_get(struct mlxsw_sp_bridge *bridge,\r\nstruct net_device *br_dev)\r\n{\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nbridge_device = mlxsw_sp_bridge_device_find(bridge, br_dev);\r\nif (bridge_device)\r\nreturn bridge_device;\r\nreturn mlxsw_sp_bridge_device_create(bridge, br_dev);\r\n}\r\nstatic void\r\nmlxsw_sp_bridge_device_put(struct mlxsw_sp_bridge *bridge,\r\nstruct mlxsw_sp_bridge_device *bridge_device)\r\n{\r\nif (list_empty(&bridge_device->ports_list))\r\nmlxsw_sp_bridge_device_destroy(bridge, bridge_device);\r\n}\r\nstatic struct mlxsw_sp_bridge_port *\r\n__mlxsw_sp_bridge_port_find(const struct mlxsw_sp_bridge_device *bridge_device,\r\nconst struct net_device *brport_dev)\r\n{\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nlist_for_each_entry(bridge_port, &bridge_device->ports_list, list) {\r\nif (bridge_port->dev == brport_dev)\r\nreturn bridge_port;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mlxsw_sp_bridge_port *\r\nmlxsw_sp_bridge_port_find(struct mlxsw_sp_bridge *bridge,\r\nstruct net_device *brport_dev)\r\n{\r\nstruct net_device *br_dev = netdev_master_upper_dev_get(brport_dev);\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nif (!br_dev)\r\nreturn NULL;\r\nbridge_device = mlxsw_sp_bridge_device_find(bridge, br_dev);\r\nif (!bridge_device)\r\nreturn NULL;\r\nreturn __mlxsw_sp_bridge_port_find(bridge_device, brport_dev);\r\n}\r\nstatic struct mlxsw_sp_bridge_port *\r\nmlxsw_sp_bridge_port_create(struct mlxsw_sp_bridge_device *bridge_device,\r\nstruct net_device *brport_dev)\r\n{\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nstruct mlxsw_sp_port *mlxsw_sp_port;\r\nbridge_port = kzalloc(sizeof(*bridge_port), GFP_KERNEL);\r\nif (!bridge_port)\r\nreturn NULL;\r\nmlxsw_sp_port = mlxsw_sp_port_dev_lower_find(brport_dev);\r\nbridge_port->lagged = mlxsw_sp_port->lagged;\r\nif (bridge_port->lagged)\r\nbridge_port->lag_id = mlxsw_sp_port->lag_id;\r\nelse\r\nbridge_port->system_port = mlxsw_sp_port->local_port;\r\nbridge_port->dev = brport_dev;\r\nbridge_port->bridge_device = bridge_device;\r\nbridge_port->stp_state = BR_STATE_DISABLED;\r\nbridge_port->flags = BR_LEARNING | BR_FLOOD | BR_LEARNING_SYNC;\r\nINIT_LIST_HEAD(&bridge_port->vlans_list);\r\nlist_add(&bridge_port->list, &bridge_device->ports_list);\r\nbridge_port->ref_count = 1;\r\nreturn bridge_port;\r\n}\r\nstatic void\r\nmlxsw_sp_bridge_port_destroy(struct mlxsw_sp_bridge_port *bridge_port)\r\n{\r\nlist_del(&bridge_port->list);\r\nWARN_ON(!list_empty(&bridge_port->vlans_list));\r\nkfree(bridge_port);\r\n}\r\nstatic bool\r\nmlxsw_sp_bridge_port_should_destroy(const struct mlxsw_sp_bridge_port *\r\nbridge_port)\r\n{\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(bridge_port->dev);\r\nif (!mlxsw_sp && list_empty(&bridge_port->vlans_list))\r\nreturn true;\r\nelse if (bridge_port->ref_count == 0)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic struct mlxsw_sp_bridge_port *\r\nmlxsw_sp_bridge_port_get(struct mlxsw_sp_bridge *bridge,\r\nstruct net_device *brport_dev)\r\n{\r\nstruct net_device *br_dev = netdev_master_upper_dev_get(brport_dev);\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nint err;\r\nbridge_port = mlxsw_sp_bridge_port_find(bridge, brport_dev);\r\nif (bridge_port) {\r\nbridge_port->ref_count++;\r\nreturn bridge_port;\r\n}\r\nbridge_device = mlxsw_sp_bridge_device_get(bridge, br_dev);\r\nif (IS_ERR(bridge_device))\r\nreturn ERR_CAST(bridge_device);\r\nbridge_port = mlxsw_sp_bridge_port_create(bridge_device, brport_dev);\r\nif (!bridge_port) {\r\nerr = -ENOMEM;\r\ngoto err_bridge_port_create;\r\n}\r\nreturn bridge_port;\r\nerr_bridge_port_create:\r\nmlxsw_sp_bridge_device_put(bridge, bridge_device);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void mlxsw_sp_bridge_port_put(struct mlxsw_sp_bridge *bridge,\r\nstruct mlxsw_sp_bridge_port *bridge_port)\r\n{\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nbridge_port->ref_count--;\r\nif (!mlxsw_sp_bridge_port_should_destroy(bridge_port))\r\nreturn;\r\nbridge_device = bridge_port->bridge_device;\r\nmlxsw_sp_bridge_port_destroy(bridge_port);\r\nmlxsw_sp_bridge_device_put(bridge, bridge_device);\r\n}\r\nstatic struct mlxsw_sp_port_vlan *\r\nmlxsw_sp_port_vlan_find_by_bridge(struct mlxsw_sp_port *mlxsw_sp_port,\r\nconst struct mlxsw_sp_bridge_device *\r\nbridge_device,\r\nu16 vid)\r\n{\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nlist_for_each_entry(mlxsw_sp_port_vlan, &mlxsw_sp_port->vlans_list,\r\nlist) {\r\nif (!mlxsw_sp_port_vlan->bridge_port)\r\ncontinue;\r\nif (mlxsw_sp_port_vlan->bridge_port->bridge_device !=\r\nbridge_device)\r\ncontinue;\r\nif (bridge_device->vlan_enabled &&\r\nmlxsw_sp_port_vlan->vid != vid)\r\ncontinue;\r\nreturn mlxsw_sp_port_vlan;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mlxsw_sp_port_vlan*\r\nmlxsw_sp_port_vlan_find_by_fid(struct mlxsw_sp_port *mlxsw_sp_port,\r\nu16 fid_index)\r\n{\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nlist_for_each_entry(mlxsw_sp_port_vlan, &mlxsw_sp_port->vlans_list,\r\nlist) {\r\nstruct mlxsw_sp_fid *fid = mlxsw_sp_port_vlan->fid;\r\nif (fid && mlxsw_sp_fid_index(fid) == fid_index)\r\nreturn mlxsw_sp_port_vlan;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mlxsw_sp_bridge_vlan *\r\nmlxsw_sp_bridge_vlan_find(const struct mlxsw_sp_bridge_port *bridge_port,\r\nu16 vid)\r\n{\r\nstruct mlxsw_sp_bridge_vlan *bridge_vlan;\r\nlist_for_each_entry(bridge_vlan, &bridge_port->vlans_list, list) {\r\nif (bridge_vlan->vid == vid)\r\nreturn bridge_vlan;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mlxsw_sp_bridge_vlan *\r\nmlxsw_sp_bridge_vlan_create(struct mlxsw_sp_bridge_port *bridge_port, u16 vid)\r\n{\r\nstruct mlxsw_sp_bridge_vlan *bridge_vlan;\r\nbridge_vlan = kzalloc(sizeof(*bridge_vlan), GFP_KERNEL);\r\nif (!bridge_vlan)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&bridge_vlan->port_vlan_list);\r\nbridge_vlan->vid = vid;\r\nlist_add(&bridge_vlan->list, &bridge_port->vlans_list);\r\nreturn bridge_vlan;\r\n}\r\nstatic void\r\nmlxsw_sp_bridge_vlan_destroy(struct mlxsw_sp_bridge_vlan *bridge_vlan)\r\n{\r\nlist_del(&bridge_vlan->list);\r\nWARN_ON(!list_empty(&bridge_vlan->port_vlan_list));\r\nkfree(bridge_vlan);\r\n}\r\nstatic struct mlxsw_sp_bridge_vlan *\r\nmlxsw_sp_bridge_vlan_get(struct mlxsw_sp_bridge_port *bridge_port, u16 vid)\r\n{\r\nstruct mlxsw_sp_bridge_vlan *bridge_vlan;\r\nbridge_vlan = mlxsw_sp_bridge_vlan_find(bridge_port, vid);\r\nif (bridge_vlan)\r\nreturn bridge_vlan;\r\nreturn mlxsw_sp_bridge_vlan_create(bridge_port, vid);\r\n}\r\nstatic void mlxsw_sp_bridge_vlan_put(struct mlxsw_sp_bridge_vlan *bridge_vlan)\r\n{\r\nif (list_empty(&bridge_vlan->port_vlan_list))\r\nmlxsw_sp_bridge_vlan_destroy(bridge_vlan);\r\n}\r\nstatic void mlxsw_sp_port_bridge_flags_get(struct mlxsw_sp_bridge *bridge,\r\nstruct net_device *dev,\r\nunsigned long *brport_flags)\r\n{\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nbridge_port = mlxsw_sp_bridge_port_find(bridge, dev);\r\nif (WARN_ON(!bridge_port))\r\nreturn;\r\nmemcpy(brport_flags, &bridge_port->flags, sizeof(*brport_flags));\r\n}\r\nstatic int mlxsw_sp_port_attr_get(struct net_device *dev,\r\nstruct switchdev_attr *attr)\r\n{\r\nstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\r\nswitch (attr->id) {\r\ncase SWITCHDEV_ATTR_ID_PORT_PARENT_ID:\r\nattr->u.ppid.id_len = sizeof(mlxsw_sp->base_mac);\r\nmemcpy(&attr->u.ppid.id, &mlxsw_sp->base_mac,\r\nattr->u.ppid.id_len);\r\nbreak;\r\ncase SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:\r\nmlxsw_sp_port_bridge_flags_get(mlxsw_sp->bridge, attr->orig_dev,\r\n&attr->u.brport_flags);\r\nbreak;\r\ncase SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS_SUPPORT:\r\nattr->u.brport_flags_support = BR_LEARNING | BR_FLOOD;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmlxsw_sp_port_bridge_vlan_stp_set(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct mlxsw_sp_bridge_vlan *bridge_vlan,\r\nu8 state)\r\n{\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nlist_for_each_entry(mlxsw_sp_port_vlan, &bridge_vlan->port_vlan_list,\r\nbridge_vlan_node) {\r\nif (mlxsw_sp_port_vlan->mlxsw_sp_port != mlxsw_sp_port)\r\ncontinue;\r\nreturn mlxsw_sp_port_vid_stp_set(mlxsw_sp_port,\r\nbridge_vlan->vid, state);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sp_port_attr_stp_state_set(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct switchdev_trans *trans,\r\nstruct net_device *orig_dev,\r\nu8 state)\r\n{\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nstruct mlxsw_sp_bridge_vlan *bridge_vlan;\r\nint err;\r\nif (switchdev_trans_ph_prepare(trans))\r\nreturn 0;\r\nbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp_port->mlxsw_sp->bridge,\r\norig_dev);\r\nif (!bridge_port)\r\nreturn 0;\r\nlist_for_each_entry(bridge_vlan, &bridge_port->vlans_list, list) {\r\nerr = mlxsw_sp_port_bridge_vlan_stp_set(mlxsw_sp_port,\r\nbridge_vlan, state);\r\nif (err)\r\ngoto err_port_bridge_vlan_stp_set;\r\n}\r\nbridge_port->stp_state = state;\r\nreturn 0;\r\nerr_port_bridge_vlan_stp_set:\r\nlist_for_each_entry_continue_reverse(bridge_vlan,\r\n&bridge_port->vlans_list, list)\r\nmlxsw_sp_port_bridge_vlan_stp_set(mlxsw_sp_port, bridge_vlan,\r\nbridge_port->stp_state);\r\nreturn err;\r\n}\r\nstatic int\r\nmlxsw_sp_port_bridge_vlan_flood_set(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct mlxsw_sp_bridge_vlan *bridge_vlan,\r\nenum mlxsw_sp_flood_type packet_type,\r\nbool member)\r\n{\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nlist_for_each_entry(mlxsw_sp_port_vlan, &bridge_vlan->port_vlan_list,\r\nbridge_vlan_node) {\r\nif (mlxsw_sp_port_vlan->mlxsw_sp_port != mlxsw_sp_port)\r\ncontinue;\r\nreturn mlxsw_sp_fid_flood_set(mlxsw_sp_port_vlan->fid,\r\npacket_type,\r\nmlxsw_sp_port->local_port,\r\nmember);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmlxsw_sp_bridge_port_flood_table_set(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct mlxsw_sp_bridge_port *bridge_port,\r\nenum mlxsw_sp_flood_type packet_type,\r\nbool member)\r\n{\r\nstruct mlxsw_sp_bridge_vlan *bridge_vlan;\r\nint err;\r\nlist_for_each_entry(bridge_vlan, &bridge_port->vlans_list, list) {\r\nerr = mlxsw_sp_port_bridge_vlan_flood_set(mlxsw_sp_port,\r\nbridge_vlan,\r\npacket_type,\r\nmember);\r\nif (err)\r\ngoto err_port_bridge_vlan_flood_set;\r\n}\r\nreturn 0;\r\nerr_port_bridge_vlan_flood_set:\r\nlist_for_each_entry_continue_reverse(bridge_vlan,\r\n&bridge_port->vlans_list, list)\r\nmlxsw_sp_port_bridge_vlan_flood_set(mlxsw_sp_port, bridge_vlan,\r\npacket_type, !member);\r\nreturn err;\r\n}\r\nstatic int\r\nmlxsw_sp_port_bridge_vlan_learning_set(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct mlxsw_sp_bridge_vlan *bridge_vlan,\r\nbool set)\r\n{\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nu16 vid = bridge_vlan->vid;\r\nlist_for_each_entry(mlxsw_sp_port_vlan, &bridge_vlan->port_vlan_list,\r\nbridge_vlan_node) {\r\nif (mlxsw_sp_port_vlan->mlxsw_sp_port != mlxsw_sp_port)\r\ncontinue;\r\nreturn mlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, set);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmlxsw_sp_bridge_port_learning_set(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct mlxsw_sp_bridge_port *bridge_port,\r\nbool set)\r\n{\r\nstruct mlxsw_sp_bridge_vlan *bridge_vlan;\r\nint err;\r\nlist_for_each_entry(bridge_vlan, &bridge_port->vlans_list, list) {\r\nerr = mlxsw_sp_port_bridge_vlan_learning_set(mlxsw_sp_port,\r\nbridge_vlan, set);\r\nif (err)\r\ngoto err_port_bridge_vlan_learning_set;\r\n}\r\nreturn 0;\r\nerr_port_bridge_vlan_learning_set:\r\nlist_for_each_entry_continue_reverse(bridge_vlan,\r\n&bridge_port->vlans_list, list)\r\nmlxsw_sp_port_bridge_vlan_learning_set(mlxsw_sp_port,\r\nbridge_vlan, !set);\r\nreturn err;\r\n}\r\nstatic int mlxsw_sp_port_attr_br_flags_set(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct switchdev_trans *trans,\r\nstruct net_device *orig_dev,\r\nunsigned long brport_flags)\r\n{\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nint err;\r\nif (switchdev_trans_ph_prepare(trans))\r\nreturn 0;\r\nbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp_port->mlxsw_sp->bridge,\r\norig_dev);\r\nif (!bridge_port)\r\nreturn 0;\r\nerr = mlxsw_sp_bridge_port_flood_table_set(mlxsw_sp_port, bridge_port,\r\nMLXSW_SP_FLOOD_TYPE_UC,\r\nbrport_flags & BR_FLOOD);\r\nif (err)\r\nreturn err;\r\nerr = mlxsw_sp_bridge_port_learning_set(mlxsw_sp_port, bridge_port,\r\nbrport_flags & BR_LEARNING);\r\nif (err)\r\nreturn err;\r\nmemcpy(&bridge_port->flags, &brport_flags, sizeof(brport_flags));\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sp_ageing_set(struct mlxsw_sp *mlxsw_sp, u32 ageing_time)\r\n{\r\nchar sfdat_pl[MLXSW_REG_SFDAT_LEN];\r\nint err;\r\nmlxsw_reg_sfdat_pack(sfdat_pl, ageing_time);\r\nerr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfdat), sfdat_pl);\r\nif (err)\r\nreturn err;\r\nmlxsw_sp->bridge->ageing_time = ageing_time;\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sp_port_attr_br_ageing_set(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct switchdev_trans *trans,\r\nunsigned long ageing_clock_t)\r\n{\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\r\nunsigned long ageing_jiffies = clock_t_to_jiffies(ageing_clock_t);\r\nu32 ageing_time = jiffies_to_msecs(ageing_jiffies) / 1000;\r\nif (switchdev_trans_ph_prepare(trans)) {\r\nif (ageing_time < MLXSW_SP_MIN_AGEING_TIME ||\r\nageing_time > MLXSW_SP_MAX_AGEING_TIME)\r\nreturn -ERANGE;\r\nelse\r\nreturn 0;\r\n}\r\nreturn mlxsw_sp_ageing_set(mlxsw_sp, ageing_time);\r\n}\r\nstatic int mlxsw_sp_port_attr_br_vlan_set(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct switchdev_trans *trans,\r\nstruct net_device *orig_dev,\r\nbool vlan_enabled)\r\n{\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nif (!switchdev_trans_ph_prepare(trans))\r\nreturn 0;\r\nbridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, orig_dev);\r\nif (WARN_ON(!bridge_device))\r\nreturn -EINVAL;\r\nif (bridge_device->vlan_enabled == vlan_enabled)\r\nreturn 0;\r\nnetdev_err(bridge_device->dev, "VLAN filtering can't be changed for existing bridge\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int mlxsw_sp_port_attr_mc_router_set(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct switchdev_trans *trans,\r\nstruct net_device *orig_dev,\r\nbool is_port_mc_router)\r\n{\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nint err;\r\nif (switchdev_trans_ph_prepare(trans))\r\nreturn 0;\r\nbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp_port->mlxsw_sp->bridge,\r\norig_dev);\r\nif (!bridge_port)\r\nreturn 0;\r\nif (!bridge_port->bridge_device->multicast_enabled)\r\ngoto out;\r\nerr = mlxsw_sp_bridge_port_flood_table_set(mlxsw_sp_port, bridge_port,\r\nMLXSW_SP_FLOOD_TYPE_MC,\r\nis_port_mc_router);\r\nif (err)\r\nreturn err;\r\nout:\r\nbridge_port->mrouter = is_port_mc_router;\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sp_port_mc_disabled_set(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct switchdev_trans *trans,\r\nstruct net_device *orig_dev,\r\nbool mc_disabled)\r\n{\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nint err;\r\nif (switchdev_trans_ph_prepare(trans))\r\nreturn 0;\r\nbridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, orig_dev);\r\nif (!bridge_device)\r\nreturn 0;\r\nlist_for_each_entry(bridge_port, &bridge_device->ports_list, list) {\r\nenum mlxsw_sp_flood_type packet_type = MLXSW_SP_FLOOD_TYPE_MC;\r\nbool member = mc_disabled ? true : bridge_port->mrouter;\r\nerr = mlxsw_sp_bridge_port_flood_table_set(mlxsw_sp_port,\r\nbridge_port,\r\npacket_type, member);\r\nif (err)\r\nreturn err;\r\n}\r\nbridge_device->multicast_enabled = !mc_disabled;\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sp_port_attr_set(struct net_device *dev,\r\nconst struct switchdev_attr *attr,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\r\nint err;\r\nswitch (attr->id) {\r\ncase SWITCHDEV_ATTR_ID_PORT_STP_STATE:\r\nerr = mlxsw_sp_port_attr_stp_state_set(mlxsw_sp_port, trans,\r\nattr->orig_dev,\r\nattr->u.stp_state);\r\nbreak;\r\ncase SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:\r\nerr = mlxsw_sp_port_attr_br_flags_set(mlxsw_sp_port, trans,\r\nattr->orig_dev,\r\nattr->u.brport_flags);\r\nbreak;\r\ncase SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME:\r\nerr = mlxsw_sp_port_attr_br_ageing_set(mlxsw_sp_port, trans,\r\nattr->u.ageing_time);\r\nbreak;\r\ncase SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING:\r\nerr = mlxsw_sp_port_attr_br_vlan_set(mlxsw_sp_port, trans,\r\nattr->orig_dev,\r\nattr->u.vlan_filtering);\r\nbreak;\r\ncase SWITCHDEV_ATTR_ID_PORT_MROUTER:\r\nerr = mlxsw_sp_port_attr_mc_router_set(mlxsw_sp_port, trans,\r\nattr->orig_dev,\r\nattr->u.mrouter);\r\nbreak;\r\ncase SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED:\r\nerr = mlxsw_sp_port_mc_disabled_set(mlxsw_sp_port, trans,\r\nattr->orig_dev,\r\nattr->u.mc_disabled);\r\nbreak;\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic bool mlxsw_sp_mc_flood(const struct mlxsw_sp_bridge_port *bridge_port)\r\n{\r\nconst struct mlxsw_sp_bridge_device *bridge_device;\r\nbridge_device = bridge_port->bridge_device;\r\nreturn !bridge_device->multicast_enabled ? true : bridge_port->mrouter;\r\n}\r\nstatic int\r\nmlxsw_sp_port_vlan_fid_join(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan,\r\nstruct mlxsw_sp_bridge_port *bridge_port)\r\n{\r\nstruct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nu8 local_port = mlxsw_sp_port->local_port;\r\nu16 vid = mlxsw_sp_port_vlan->vid;\r\nstruct mlxsw_sp_fid *fid;\r\nint err;\r\nbridge_device = bridge_port->bridge_device;\r\nfid = bridge_device->ops->fid_get(bridge_device, vid);\r\nif (IS_ERR(fid))\r\nreturn PTR_ERR(fid);\r\nerr = mlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_UC, local_port,\r\nbridge_port->flags & BR_FLOOD);\r\nif (err)\r\ngoto err_fid_uc_flood_set;\r\nerr = mlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_MC, local_port,\r\nmlxsw_sp_mc_flood(bridge_port));\r\nif (err)\r\ngoto err_fid_mc_flood_set;\r\nerr = mlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_BC, local_port,\r\ntrue);\r\nif (err)\r\ngoto err_fid_bc_flood_set;\r\nerr = mlxsw_sp_fid_port_vid_map(fid, mlxsw_sp_port, vid);\r\nif (err)\r\ngoto err_fid_port_vid_map;\r\nmlxsw_sp_port_vlan->fid = fid;\r\nreturn 0;\r\nerr_fid_port_vid_map:\r\nmlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_BC, local_port, false);\r\nerr_fid_bc_flood_set:\r\nmlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_MC, local_port, false);\r\nerr_fid_mc_flood_set:\r\nmlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_UC, local_port, false);\r\nerr_fid_uc_flood_set:\r\nmlxsw_sp_fid_put(fid);\r\nreturn err;\r\n}\r\nstatic void\r\nmlxsw_sp_port_vlan_fid_leave(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan)\r\n{\r\nstruct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;\r\nstruct mlxsw_sp_fid *fid = mlxsw_sp_port_vlan->fid;\r\nu8 local_port = mlxsw_sp_port->local_port;\r\nu16 vid = mlxsw_sp_port_vlan->vid;\r\nmlxsw_sp_port_vlan->fid = NULL;\r\nmlxsw_sp_fid_port_vid_unmap(fid, mlxsw_sp_port, vid);\r\nmlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_BC, local_port, false);\r\nmlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_MC, local_port, false);\r\nmlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_UC, local_port, false);\r\nmlxsw_sp_fid_put(fid);\r\n}\r\nstatic u16\r\nmlxsw_sp_port_pvid_determine(const struct mlxsw_sp_port *mlxsw_sp_port,\r\nu16 vid, bool is_pvid)\r\n{\r\nif (is_pvid)\r\nreturn vid;\r\nelse if (mlxsw_sp_port->pvid == vid)\r\nreturn 0;\r\nelse\r\nreturn mlxsw_sp_port->pvid;\r\n}\r\nstatic int\r\nmlxsw_sp_port_vlan_bridge_join(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan,\r\nstruct mlxsw_sp_bridge_port *bridge_port)\r\n{\r\nstruct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;\r\nstruct mlxsw_sp_bridge_vlan *bridge_vlan;\r\nu16 vid = mlxsw_sp_port_vlan->vid;\r\nint err;\r\nif (mlxsw_sp_port_vlan->bridge_port)\r\nreturn 0;\r\nerr = mlxsw_sp_port_vlan_fid_join(mlxsw_sp_port_vlan, bridge_port);\r\nif (err)\r\nreturn err;\r\nerr = mlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid,\r\nbridge_port->flags & BR_LEARNING);\r\nif (err)\r\ngoto err_port_vid_learning_set;\r\nerr = mlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid,\r\nbridge_port->stp_state);\r\nif (err)\r\ngoto err_port_vid_stp_set;\r\nbridge_vlan = mlxsw_sp_bridge_vlan_get(bridge_port, vid);\r\nif (!bridge_vlan) {\r\nerr = -ENOMEM;\r\ngoto err_bridge_vlan_get;\r\n}\r\nlist_add(&mlxsw_sp_port_vlan->bridge_vlan_node,\r\n&bridge_vlan->port_vlan_list);\r\nmlxsw_sp_bridge_port_get(mlxsw_sp_port->mlxsw_sp->bridge,\r\nbridge_port->dev);\r\nmlxsw_sp_port_vlan->bridge_port = bridge_port;\r\nreturn 0;\r\nerr_bridge_vlan_get:\r\nmlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid, BR_STATE_DISABLED);\r\nerr_port_vid_stp_set:\r\nmlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, false);\r\nerr_port_vid_learning_set:\r\nmlxsw_sp_port_vlan_fid_leave(mlxsw_sp_port_vlan);\r\nreturn err;\r\n}\r\nvoid\r\nmlxsw_sp_port_vlan_bridge_leave(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan)\r\n{\r\nstruct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;\r\nstruct mlxsw_sp_fid *fid = mlxsw_sp_port_vlan->fid;\r\nstruct mlxsw_sp_bridge_vlan *bridge_vlan;\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nu16 vid = mlxsw_sp_port_vlan->vid;\r\nbool last;\r\nif (WARN_ON(mlxsw_sp_fid_type(fid) != MLXSW_SP_FID_TYPE_8021Q &&\r\nmlxsw_sp_fid_type(fid) != MLXSW_SP_FID_TYPE_8021D))\r\nreturn;\r\nbridge_port = mlxsw_sp_port_vlan->bridge_port;\r\nbridge_vlan = mlxsw_sp_bridge_vlan_find(bridge_port, vid);\r\nlast = list_is_singular(&bridge_vlan->port_vlan_list);\r\nlist_del(&mlxsw_sp_port_vlan->bridge_vlan_node);\r\nmlxsw_sp_bridge_vlan_put(bridge_vlan);\r\nmlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid, BR_STATE_DISABLED);\r\nmlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, false);\r\nif (last)\r\nmlxsw_sp_bridge_port_fdb_flush(mlxsw_sp_port->mlxsw_sp,\r\nbridge_port,\r\nmlxsw_sp_fid_index(fid));\r\nmlxsw_sp_port_vlan_fid_leave(mlxsw_sp_port_vlan);\r\nmlxsw_sp_bridge_port_put(mlxsw_sp_port->mlxsw_sp->bridge, bridge_port);\r\nmlxsw_sp_port_vlan->bridge_port = NULL;\r\n}\r\nstatic int\r\nmlxsw_sp_bridge_port_vlan_add(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct mlxsw_sp_bridge_port *bridge_port,\r\nu16 vid, bool is_untagged, bool is_pvid)\r\n{\r\nu16 pvid = mlxsw_sp_port_pvid_determine(mlxsw_sp_port, vid, is_pvid);\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nu16 old_pvid = mlxsw_sp_port->pvid;\r\nint err;\r\nmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_get(mlxsw_sp_port, vid);\r\nif (IS_ERR(mlxsw_sp_port_vlan))\r\nreturn PTR_ERR(mlxsw_sp_port_vlan);\r\nerr = mlxsw_sp_port_vlan_set(mlxsw_sp_port, vid, vid, true,\r\nis_untagged);\r\nif (err)\r\ngoto err_port_vlan_set;\r\nerr = mlxsw_sp_port_pvid_set(mlxsw_sp_port, pvid);\r\nif (err)\r\ngoto err_port_pvid_set;\r\nerr = mlxsw_sp_port_vlan_bridge_join(mlxsw_sp_port_vlan, bridge_port);\r\nif (err)\r\ngoto err_port_vlan_bridge_join;\r\nreturn 0;\r\nerr_port_vlan_bridge_join:\r\nmlxsw_sp_port_pvid_set(mlxsw_sp_port, old_pvid);\r\nerr_port_pvid_set:\r\nmlxsw_sp_port_vlan_set(mlxsw_sp_port, vid, vid, false, false);\r\nerr_port_vlan_set:\r\nmlxsw_sp_port_vlan_put(mlxsw_sp_port_vlan);\r\nreturn err;\r\n}\r\nstatic int mlxsw_sp_port_vlans_add(struct mlxsw_sp_port *mlxsw_sp_port,\r\nconst struct switchdev_obj_port_vlan *vlan,\r\nstruct switchdev_trans *trans)\r\n{\r\nbool flag_untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\r\nbool flag_pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\r\nstruct net_device *orig_dev = vlan->obj.orig_dev;\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nu16 vid;\r\nif (switchdev_trans_ph_prepare(trans))\r\nreturn 0;\r\nbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp->bridge, orig_dev);\r\nif (WARN_ON(!bridge_port))\r\nreturn -EINVAL;\r\nif (!bridge_port->bridge_device->vlan_enabled)\r\nreturn 0;\r\nfor (vid = vlan->vid_begin; vid <= vlan->vid_end; vid++) {\r\nint err;\r\nerr = mlxsw_sp_bridge_port_vlan_add(mlxsw_sp_port, bridge_port,\r\nvid, flag_untagged,\r\nflag_pvid);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic enum mlxsw_reg_sfdf_flush_type mlxsw_sp_fdb_flush_type(bool lagged)\r\n{\r\nreturn lagged ? MLXSW_REG_SFDF_FLUSH_PER_LAG_AND_FID :\r\nMLXSW_REG_SFDF_FLUSH_PER_PORT_AND_FID;\r\n}\r\nstatic int\r\nmlxsw_sp_bridge_port_fdb_flush(struct mlxsw_sp *mlxsw_sp,\r\nstruct mlxsw_sp_bridge_port *bridge_port,\r\nu16 fid_index)\r\n{\r\nbool lagged = bridge_port->lagged;\r\nchar sfdf_pl[MLXSW_REG_SFDF_LEN];\r\nu16 system_port;\r\nsystem_port = lagged ? bridge_port->lag_id : bridge_port->system_port;\r\nmlxsw_reg_sfdf_pack(sfdf_pl, mlxsw_sp_fdb_flush_type(lagged));\r\nmlxsw_reg_sfdf_fid_set(sfdf_pl, fid_index);\r\nmlxsw_reg_sfdf_port_fid_system_port_set(sfdf_pl, system_port);\r\nreturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfdf), sfdf_pl);\r\n}\r\nstatic enum mlxsw_reg_sfd_rec_policy mlxsw_sp_sfd_rec_policy(bool dynamic)\r\n{\r\nreturn dynamic ? MLXSW_REG_SFD_REC_POLICY_DYNAMIC_ENTRY_INGRESS :\r\nMLXSW_REG_SFD_REC_POLICY_STATIC_ENTRY;\r\n}\r\nstatic enum mlxsw_reg_sfd_op mlxsw_sp_sfd_op(bool adding)\r\n{\r\nreturn adding ? MLXSW_REG_SFD_OP_WRITE_EDIT :\r\nMLXSW_REG_SFD_OP_WRITE_REMOVE;\r\n}\r\nstatic int __mlxsw_sp_port_fdb_uc_op(struct mlxsw_sp *mlxsw_sp, u8 local_port,\r\nconst char *mac, u16 fid, bool adding,\r\nenum mlxsw_reg_sfd_rec_action action,\r\nbool dynamic)\r\n{\r\nchar *sfd_pl;\r\nint err;\r\nsfd_pl = kmalloc(MLXSW_REG_SFD_LEN, GFP_KERNEL);\r\nif (!sfd_pl)\r\nreturn -ENOMEM;\r\nmlxsw_reg_sfd_pack(sfd_pl, mlxsw_sp_sfd_op(adding), 0);\r\nmlxsw_reg_sfd_uc_pack(sfd_pl, 0, mlxsw_sp_sfd_rec_policy(dynamic),\r\nmac, fid, action, local_port);\r\nerr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfd), sfd_pl);\r\nkfree(sfd_pl);\r\nreturn err;\r\n}\r\nstatic int mlxsw_sp_port_fdb_uc_op(struct mlxsw_sp *mlxsw_sp, u8 local_port,\r\nconst char *mac, u16 fid, bool adding,\r\nbool dynamic)\r\n{\r\nreturn __mlxsw_sp_port_fdb_uc_op(mlxsw_sp, local_port, mac, fid, adding,\r\nMLXSW_REG_SFD_REC_ACTION_NOP, dynamic);\r\n}\r\nint mlxsw_sp_rif_fdb_op(struct mlxsw_sp *mlxsw_sp, const char *mac, u16 fid,\r\nbool adding)\r\n{\r\nreturn __mlxsw_sp_port_fdb_uc_op(mlxsw_sp, 0, mac, fid, adding,\r\nMLXSW_REG_SFD_REC_ACTION_FORWARD_IP_ROUTER,\r\nfalse);\r\n}\r\nstatic int mlxsw_sp_port_fdb_uc_lag_op(struct mlxsw_sp *mlxsw_sp, u16 lag_id,\r\nconst char *mac, u16 fid, u16 lag_vid,\r\nbool adding, bool dynamic)\r\n{\r\nchar *sfd_pl;\r\nint err;\r\nsfd_pl = kmalloc(MLXSW_REG_SFD_LEN, GFP_KERNEL);\r\nif (!sfd_pl)\r\nreturn -ENOMEM;\r\nmlxsw_reg_sfd_pack(sfd_pl, mlxsw_sp_sfd_op(adding), 0);\r\nmlxsw_reg_sfd_uc_lag_pack(sfd_pl, 0, mlxsw_sp_sfd_rec_policy(dynamic),\r\nmac, fid, MLXSW_REG_SFD_REC_ACTION_NOP,\r\nlag_vid, lag_id);\r\nerr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfd), sfd_pl);\r\nkfree(sfd_pl);\r\nreturn err;\r\n}\r\nstatic int\r\nmlxsw_sp_port_fdb_set(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct switchdev_notifier_fdb_info *fdb_info, bool adding)\r\n{\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\r\nstruct net_device *orig_dev = fdb_info->info.dev;\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nu16 fid_index, vid;\r\nbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp->bridge, orig_dev);\r\nif (!bridge_port)\r\nreturn -EINVAL;\r\nbridge_device = bridge_port->bridge_device;\r\nmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_bridge(mlxsw_sp_port,\r\nbridge_device,\r\nfdb_info->vid);\r\nif (!mlxsw_sp_port_vlan)\r\nreturn 0;\r\nfid_index = mlxsw_sp_fid_index(mlxsw_sp_port_vlan->fid);\r\nvid = mlxsw_sp_port_vlan->vid;\r\nif (!bridge_port->lagged)\r\nreturn mlxsw_sp_port_fdb_uc_op(mlxsw_sp,\r\nbridge_port->system_port,\r\nfdb_info->addr, fid_index,\r\nadding, false);\r\nelse\r\nreturn mlxsw_sp_port_fdb_uc_lag_op(mlxsw_sp,\r\nbridge_port->lag_id,\r\nfdb_info->addr, fid_index,\r\nvid, adding, false);\r\n}\r\nstatic int mlxsw_sp_port_mdb_op(struct mlxsw_sp *mlxsw_sp, const char *addr,\r\nu16 fid, u16 mid, bool adding)\r\n{\r\nchar *sfd_pl;\r\nint err;\r\nsfd_pl = kmalloc(MLXSW_REG_SFD_LEN, GFP_KERNEL);\r\nif (!sfd_pl)\r\nreturn -ENOMEM;\r\nmlxsw_reg_sfd_pack(sfd_pl, mlxsw_sp_sfd_op(adding), 0);\r\nmlxsw_reg_sfd_mc_pack(sfd_pl, 0, addr, fid,\r\nMLXSW_REG_SFD_REC_ACTION_NOP, mid);\r\nerr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfd), sfd_pl);\r\nkfree(sfd_pl);\r\nreturn err;\r\n}\r\nstatic int mlxsw_sp_port_smid_set(struct mlxsw_sp_port *mlxsw_sp_port, u16 mid,\r\nbool add, bool clear_all_ports)\r\n{\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\r\nchar *smid_pl;\r\nint err, i;\r\nsmid_pl = kmalloc(MLXSW_REG_SMID_LEN, GFP_KERNEL);\r\nif (!smid_pl)\r\nreturn -ENOMEM;\r\nmlxsw_reg_smid_pack(smid_pl, mid, mlxsw_sp_port->local_port, add);\r\nif (clear_all_ports) {\r\nfor (i = 1; i < mlxsw_core_max_ports(mlxsw_sp->core); i++)\r\nif (mlxsw_sp->ports[i])\r\nmlxsw_reg_smid_port_mask_set(smid_pl, i, 1);\r\n}\r\nerr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(smid), smid_pl);\r\nkfree(smid_pl);\r\nreturn err;\r\n}\r\nstatic struct mlxsw_sp_mid *__mlxsw_sp_mc_get(struct mlxsw_sp *mlxsw_sp,\r\nconst unsigned char *addr,\r\nu16 fid)\r\n{\r\nstruct mlxsw_sp_mid *mid;\r\nlist_for_each_entry(mid, &mlxsw_sp->bridge->mids_list, list) {\r\nif (ether_addr_equal(mid->addr, addr) && mid->fid == fid)\r\nreturn mid;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mlxsw_sp_mid *__mlxsw_sp_mc_alloc(struct mlxsw_sp *mlxsw_sp,\r\nconst unsigned char *addr,\r\nu16 fid)\r\n{\r\nstruct mlxsw_sp_mid *mid;\r\nu16 mid_idx;\r\nmid_idx = find_first_zero_bit(mlxsw_sp->bridge->mids_bitmap,\r\nMLXSW_SP_MID_MAX);\r\nif (mid_idx == MLXSW_SP_MID_MAX)\r\nreturn NULL;\r\nmid = kzalloc(sizeof(*mid), GFP_KERNEL);\r\nif (!mid)\r\nreturn NULL;\r\nset_bit(mid_idx, mlxsw_sp->bridge->mids_bitmap);\r\nether_addr_copy(mid->addr, addr);\r\nmid->fid = fid;\r\nmid->mid = mid_idx;\r\nmid->ref_count = 0;\r\nlist_add_tail(&mid->list, &mlxsw_sp->bridge->mids_list);\r\nreturn mid;\r\n}\r\nstatic int __mlxsw_sp_mc_dec_ref(struct mlxsw_sp *mlxsw_sp,\r\nstruct mlxsw_sp_mid *mid)\r\n{\r\nif (--mid->ref_count == 0) {\r\nlist_del(&mid->list);\r\nclear_bit(mid->mid, mlxsw_sp->bridge->mids_bitmap);\r\nkfree(mid);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sp_port_mdb_add(struct mlxsw_sp_port *mlxsw_sp_port,\r\nconst struct switchdev_obj_port_mdb *mdb,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\r\nstruct net_device *orig_dev = mdb->obj.orig_dev;\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nstruct net_device *dev = mlxsw_sp_port->dev;\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nstruct mlxsw_sp_mid *mid;\r\nu16 fid_index;\r\nint err = 0;\r\nif (switchdev_trans_ph_prepare(trans))\r\nreturn 0;\r\nbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp->bridge, orig_dev);\r\nif (!bridge_port)\r\nreturn 0;\r\nbridge_device = bridge_port->bridge_device;\r\nmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_bridge(mlxsw_sp_port,\r\nbridge_device,\r\nmdb->vid);\r\nif (!mlxsw_sp_port_vlan)\r\nreturn 0;\r\nfid_index = mlxsw_sp_fid_index(mlxsw_sp_port_vlan->fid);\r\nmid = __mlxsw_sp_mc_get(mlxsw_sp, mdb->addr, fid_index);\r\nif (!mid) {\r\nmid = __mlxsw_sp_mc_alloc(mlxsw_sp, mdb->addr, fid_index);\r\nif (!mid) {\r\nnetdev_err(dev, "Unable to allocate MC group\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmid->ref_count++;\r\nerr = mlxsw_sp_port_smid_set(mlxsw_sp_port, mid->mid, true,\r\nmid->ref_count == 1);\r\nif (err) {\r\nnetdev_err(dev, "Unable to set SMID\n");\r\ngoto err_out;\r\n}\r\nif (mid->ref_count == 1) {\r\nerr = mlxsw_sp_port_mdb_op(mlxsw_sp, mdb->addr, fid_index,\r\nmid->mid, true);\r\nif (err) {\r\nnetdev_err(dev, "Unable to set MC SFD\n");\r\ngoto err_out;\r\n}\r\n}\r\nreturn 0;\r\nerr_out:\r\n__mlxsw_sp_mc_dec_ref(mlxsw_sp, mid);\r\nreturn err;\r\n}\r\nstatic int mlxsw_sp_port_obj_add(struct net_device *dev,\r\nconst struct switchdev_obj *obj,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\r\nint err = 0;\r\nswitch (obj->id) {\r\ncase SWITCHDEV_OBJ_ID_PORT_VLAN:\r\nerr = mlxsw_sp_port_vlans_add(mlxsw_sp_port,\r\nSWITCHDEV_OBJ_PORT_VLAN(obj),\r\ntrans);\r\nbreak;\r\ncase SWITCHDEV_OBJ_ID_PORT_MDB:\r\nerr = mlxsw_sp_port_mdb_add(mlxsw_sp_port,\r\nSWITCHDEV_OBJ_PORT_MDB(obj),\r\ntrans);\r\nbreak;\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic void\r\nmlxsw_sp_bridge_port_vlan_del(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct mlxsw_sp_bridge_port *bridge_port, u16 vid)\r\n{\r\nu16 pvid = mlxsw_sp_port->pvid == vid ? 0 : vid;\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, vid);\r\nif (WARN_ON(!mlxsw_sp_port_vlan))\r\nreturn;\r\nmlxsw_sp_port_vlan_bridge_leave(mlxsw_sp_port_vlan);\r\nmlxsw_sp_port_pvid_set(mlxsw_sp_port, pvid);\r\nmlxsw_sp_port_vlan_set(mlxsw_sp_port, vid, vid, false, false);\r\nmlxsw_sp_port_vlan_put(mlxsw_sp_port_vlan);\r\n}\r\nstatic int mlxsw_sp_port_vlans_del(struct mlxsw_sp_port *mlxsw_sp_port,\r\nconst struct switchdev_obj_port_vlan *vlan)\r\n{\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\r\nstruct net_device *orig_dev = vlan->obj.orig_dev;\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nu16 vid;\r\nbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp->bridge, orig_dev);\r\nif (WARN_ON(!bridge_port))\r\nreturn -EINVAL;\r\nif (!bridge_port->bridge_device->vlan_enabled)\r\nreturn 0;\r\nfor (vid = vlan->vid_begin; vid <= vlan->vid_end; vid++)\r\nmlxsw_sp_bridge_port_vlan_del(mlxsw_sp_port, bridge_port, vid);\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sp_port_mdb_del(struct mlxsw_sp_port *mlxsw_sp_port,\r\nconst struct switchdev_obj_port_mdb *mdb)\r\n{\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\r\nstruct net_device *orig_dev = mdb->obj.orig_dev;\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nstruct net_device *dev = mlxsw_sp_port->dev;\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nstruct mlxsw_sp_mid *mid;\r\nu16 fid_index;\r\nu16 mid_idx;\r\nint err = 0;\r\nbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp->bridge, orig_dev);\r\nif (!bridge_port)\r\nreturn 0;\r\nbridge_device = bridge_port->bridge_device;\r\nmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_bridge(mlxsw_sp_port,\r\nbridge_device,\r\nmdb->vid);\r\nif (!mlxsw_sp_port_vlan)\r\nreturn 0;\r\nfid_index = mlxsw_sp_fid_index(mlxsw_sp_port_vlan->fid);\r\nmid = __mlxsw_sp_mc_get(mlxsw_sp, mdb->addr, fid_index);\r\nif (!mid) {\r\nnetdev_err(dev, "Unable to remove port from MC DB\n");\r\nreturn -EINVAL;\r\n}\r\nerr = mlxsw_sp_port_smid_set(mlxsw_sp_port, mid->mid, false, false);\r\nif (err)\r\nnetdev_err(dev, "Unable to remove port from SMID\n");\r\nmid_idx = mid->mid;\r\nif (__mlxsw_sp_mc_dec_ref(mlxsw_sp, mid)) {\r\nerr = mlxsw_sp_port_mdb_op(mlxsw_sp, mdb->addr, fid_index,\r\nmid_idx, false);\r\nif (err)\r\nnetdev_err(dev, "Unable to remove MC SFD\n");\r\n}\r\nreturn err;\r\n}\r\nstatic int mlxsw_sp_port_obj_del(struct net_device *dev,\r\nconst struct switchdev_obj *obj)\r\n{\r\nstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\r\nint err = 0;\r\nswitch (obj->id) {\r\ncase SWITCHDEV_OBJ_ID_PORT_VLAN:\r\nerr = mlxsw_sp_port_vlans_del(mlxsw_sp_port,\r\nSWITCHDEV_OBJ_PORT_VLAN(obj));\r\nbreak;\r\ncase SWITCHDEV_OBJ_ID_PORT_MDB:\r\nerr = mlxsw_sp_port_mdb_del(mlxsw_sp_port,\r\nSWITCHDEV_OBJ_PORT_MDB(obj));\r\nbreak;\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic struct mlxsw_sp_port *mlxsw_sp_lag_rep_port(struct mlxsw_sp *mlxsw_sp,\r\nu16 lag_id)\r\n{\r\nstruct mlxsw_sp_port *mlxsw_sp_port;\r\nu64 max_lag_members;\r\nint i;\r\nmax_lag_members = MLXSW_CORE_RES_GET(mlxsw_sp->core,\r\nMAX_LAG_MEMBERS);\r\nfor (i = 0; i < max_lag_members; i++) {\r\nmlxsw_sp_port = mlxsw_sp_port_lagged_get(mlxsw_sp, lag_id, i);\r\nif (mlxsw_sp_port)\r\nreturn mlxsw_sp_port;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nmlxsw_sp_bridge_8021q_port_join(struct mlxsw_sp_bridge_device *bridge_device,\r\nstruct mlxsw_sp_bridge_port *bridge_port,\r\nstruct mlxsw_sp_port *mlxsw_sp_port)\r\n{\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nif (is_vlan_dev(bridge_port->dev))\r\nreturn -EINVAL;\r\nmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, 1);\r\nif (WARN_ON(!mlxsw_sp_port_vlan))\r\nreturn -EINVAL;\r\nmlxsw_sp_port_vlan_put(mlxsw_sp_port_vlan);\r\nreturn 0;\r\n}\r\nstatic void\r\nmlxsw_sp_bridge_8021q_port_leave(struct mlxsw_sp_bridge_device *bridge_device,\r\nstruct mlxsw_sp_bridge_port *bridge_port,\r\nstruct mlxsw_sp_port *mlxsw_sp_port)\r\n{\r\nmlxsw_sp_port_vlan_get(mlxsw_sp_port, 1);\r\nmlxsw_sp_port_pvid_set(mlxsw_sp_port, 1);\r\n}\r\nstatic struct mlxsw_sp_fid *\r\nmlxsw_sp_bridge_8021q_fid_get(struct mlxsw_sp_bridge_device *bridge_device,\r\nu16 vid)\r\n{\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(bridge_device->dev);\r\nreturn mlxsw_sp_fid_8021q_get(mlxsw_sp, vid);\r\n}\r\nstatic bool\r\nmlxsw_sp_port_is_br_member(const struct mlxsw_sp_port *mlxsw_sp_port,\r\nconst struct net_device *br_dev)\r\n{\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nlist_for_each_entry(mlxsw_sp_port_vlan, &mlxsw_sp_port->vlans_list,\r\nlist) {\r\nif (mlxsw_sp_port_vlan->bridge_port &&\r\nmlxsw_sp_port_vlan->bridge_port->bridge_device->dev ==\r\nbr_dev)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int\r\nmlxsw_sp_bridge_8021d_port_join(struct mlxsw_sp_bridge_device *bridge_device,\r\nstruct mlxsw_sp_bridge_port *bridge_port,\r\nstruct mlxsw_sp_port *mlxsw_sp_port)\r\n{\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nu16 vid;\r\nif (!is_vlan_dev(bridge_port->dev))\r\nreturn -EINVAL;\r\nvid = vlan_dev_vlan_id(bridge_port->dev);\r\nmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, vid);\r\nif (WARN_ON(!mlxsw_sp_port_vlan))\r\nreturn -EINVAL;\r\nif (mlxsw_sp_port_is_br_member(mlxsw_sp_port, bridge_device->dev)) {\r\nnetdev_err(mlxsw_sp_port->dev, "Can't bridge VLAN uppers of the same port\n");\r\nreturn -EINVAL;\r\n}\r\nif (mlxsw_sp_port_vlan->fid)\r\nmlxsw_sp_port_vlan_router_leave(mlxsw_sp_port_vlan);\r\nreturn mlxsw_sp_port_vlan_bridge_join(mlxsw_sp_port_vlan, bridge_port);\r\n}\r\nstatic void\r\nmlxsw_sp_bridge_8021d_port_leave(struct mlxsw_sp_bridge_device *bridge_device,\r\nstruct mlxsw_sp_bridge_port *bridge_port,\r\nstruct mlxsw_sp_port *mlxsw_sp_port)\r\n{\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nu16 vid = vlan_dev_vlan_id(bridge_port->dev);\r\nmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, vid);\r\nif (WARN_ON(!mlxsw_sp_port_vlan))\r\nreturn;\r\nmlxsw_sp_port_vlan_bridge_leave(mlxsw_sp_port_vlan);\r\n}\r\nstatic struct mlxsw_sp_fid *\r\nmlxsw_sp_bridge_8021d_fid_get(struct mlxsw_sp_bridge_device *bridge_device,\r\nu16 vid)\r\n{\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(bridge_device->dev);\r\nreturn mlxsw_sp_fid_8021d_get(mlxsw_sp, bridge_device->dev->ifindex);\r\n}\r\nint mlxsw_sp_port_bridge_join(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct net_device *brport_dev,\r\nstruct net_device *br_dev)\r\n{\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nint err;\r\nbridge_port = mlxsw_sp_bridge_port_get(mlxsw_sp->bridge, brport_dev);\r\nif (IS_ERR(bridge_port))\r\nreturn PTR_ERR(bridge_port);\r\nbridge_device = bridge_port->bridge_device;\r\nerr = bridge_device->ops->port_join(bridge_device, bridge_port,\r\nmlxsw_sp_port);\r\nif (err)\r\ngoto err_port_join;\r\nreturn 0;\r\nerr_port_join:\r\nmlxsw_sp_bridge_port_put(mlxsw_sp->bridge, bridge_port);\r\nreturn err;\r\n}\r\nvoid mlxsw_sp_port_bridge_leave(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct net_device *brport_dev,\r\nstruct net_device *br_dev)\r\n{\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nbridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);\r\nif (!bridge_device)\r\nreturn;\r\nbridge_port = __mlxsw_sp_bridge_port_find(bridge_device, brport_dev);\r\nif (!bridge_port)\r\nreturn;\r\nbridge_device->ops->port_leave(bridge_device, bridge_port,\r\nmlxsw_sp_port);\r\nmlxsw_sp_bridge_port_put(mlxsw_sp->bridge, bridge_port);\r\n}\r\nstatic void\r\nmlxsw_sp_fdb_call_notifiers(enum switchdev_notifier_type type,\r\nconst char *mac, u16 vid,\r\nstruct net_device *dev)\r\n{\r\nstruct switchdev_notifier_fdb_info info;\r\ninfo.addr = mac;\r\ninfo.vid = vid;\r\ncall_switchdev_notifiers(type, dev, &info.info);\r\n}\r\nstatic void mlxsw_sp_fdb_notify_mac_process(struct mlxsw_sp *mlxsw_sp,\r\nchar *sfn_pl, int rec_index,\r\nbool adding)\r\n{\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nstruct mlxsw_sp_port *mlxsw_sp_port;\r\nenum switchdev_notifier_type type;\r\nchar mac[ETH_ALEN];\r\nu8 local_port;\r\nu16 vid, fid;\r\nbool do_notification = true;\r\nint err;\r\nmlxsw_reg_sfn_mac_unpack(sfn_pl, rec_index, mac, &fid, &local_port);\r\nmlxsw_sp_port = mlxsw_sp->ports[local_port];\r\nif (!mlxsw_sp_port) {\r\ndev_err_ratelimited(mlxsw_sp->bus_info->dev, "Incorrect local port in FDB notification\n");\r\ngoto just_remove;\r\n}\r\nmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_fid(mlxsw_sp_port, fid);\r\nif (!mlxsw_sp_port_vlan) {\r\nnetdev_err(mlxsw_sp_port->dev, "Failed to find a matching {Port, VID} following FDB notification\n");\r\ngoto just_remove;\r\n}\r\nbridge_port = mlxsw_sp_port_vlan->bridge_port;\r\nif (!bridge_port) {\r\nnetdev_err(mlxsw_sp_port->dev, "{Port, VID} not associated with a bridge\n");\r\ngoto just_remove;\r\n}\r\nbridge_device = bridge_port->bridge_device;\r\nvid = bridge_device->vlan_enabled ? mlxsw_sp_port_vlan->vid : 0;\r\ndo_fdb_op:\r\nerr = mlxsw_sp_port_fdb_uc_op(mlxsw_sp, local_port, mac, fid,\r\nadding, true);\r\nif (err) {\r\ndev_err_ratelimited(mlxsw_sp->bus_info->dev, "Failed to set FDB entry\n");\r\nreturn;\r\n}\r\nif (!do_notification)\r\nreturn;\r\ntype = adding ? SWITCHDEV_FDB_ADD_TO_BRIDGE : SWITCHDEV_FDB_DEL_TO_BRIDGE;\r\nmlxsw_sp_fdb_call_notifiers(type, mac, vid, bridge_port->dev);\r\nreturn;\r\njust_remove:\r\nadding = false;\r\ndo_notification = false;\r\ngoto do_fdb_op;\r\n}\r\nstatic void mlxsw_sp_fdb_notify_mac_lag_process(struct mlxsw_sp *mlxsw_sp,\r\nchar *sfn_pl, int rec_index,\r\nbool adding)\r\n{\r\nstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\r\nstruct mlxsw_sp_bridge_device *bridge_device;\r\nstruct mlxsw_sp_bridge_port *bridge_port;\r\nstruct mlxsw_sp_port *mlxsw_sp_port;\r\nenum switchdev_notifier_type type;\r\nchar mac[ETH_ALEN];\r\nu16 lag_vid = 0;\r\nu16 lag_id;\r\nu16 vid, fid;\r\nbool do_notification = true;\r\nint err;\r\nmlxsw_reg_sfn_mac_lag_unpack(sfn_pl, rec_index, mac, &fid, &lag_id);\r\nmlxsw_sp_port = mlxsw_sp_lag_rep_port(mlxsw_sp, lag_id);\r\nif (!mlxsw_sp_port) {\r\ndev_err_ratelimited(mlxsw_sp->bus_info->dev, "Cannot find port representor for LAG\n");\r\ngoto just_remove;\r\n}\r\nmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_fid(mlxsw_sp_port, fid);\r\nif (!mlxsw_sp_port_vlan) {\r\nnetdev_err(mlxsw_sp_port->dev, "Failed to find a matching {Port, VID} following FDB notification\n");\r\ngoto just_remove;\r\n}\r\nbridge_port = mlxsw_sp_port_vlan->bridge_port;\r\nif (!bridge_port) {\r\nnetdev_err(mlxsw_sp_port->dev, "{Port, VID} not associated with a bridge\n");\r\ngoto just_remove;\r\n}\r\nbridge_device = bridge_port->bridge_device;\r\nvid = bridge_device->vlan_enabled ? mlxsw_sp_port_vlan->vid : 0;\r\nlag_vid = mlxsw_sp_port_vlan->vid;\r\ndo_fdb_op:\r\nerr = mlxsw_sp_port_fdb_uc_lag_op(mlxsw_sp, lag_id, mac, fid, lag_vid,\r\nadding, true);\r\nif (err) {\r\ndev_err_ratelimited(mlxsw_sp->bus_info->dev, "Failed to set FDB entry\n");\r\nreturn;\r\n}\r\nif (!do_notification)\r\nreturn;\r\ntype = adding ? SWITCHDEV_FDB_ADD_TO_BRIDGE : SWITCHDEV_FDB_DEL_TO_BRIDGE;\r\nmlxsw_sp_fdb_call_notifiers(type, mac, vid, bridge_port->dev);\r\nreturn;\r\njust_remove:\r\nadding = false;\r\ndo_notification = false;\r\ngoto do_fdb_op;\r\n}\r\nstatic void mlxsw_sp_fdb_notify_rec_process(struct mlxsw_sp *mlxsw_sp,\r\nchar *sfn_pl, int rec_index)\r\n{\r\nswitch (mlxsw_reg_sfn_rec_type_get(sfn_pl, rec_index)) {\r\ncase MLXSW_REG_SFN_REC_TYPE_LEARNED_MAC:\r\nmlxsw_sp_fdb_notify_mac_process(mlxsw_sp, sfn_pl,\r\nrec_index, true);\r\nbreak;\r\ncase MLXSW_REG_SFN_REC_TYPE_AGED_OUT_MAC:\r\nmlxsw_sp_fdb_notify_mac_process(mlxsw_sp, sfn_pl,\r\nrec_index, false);\r\nbreak;\r\ncase MLXSW_REG_SFN_REC_TYPE_LEARNED_MAC_LAG:\r\nmlxsw_sp_fdb_notify_mac_lag_process(mlxsw_sp, sfn_pl,\r\nrec_index, true);\r\nbreak;\r\ncase MLXSW_REG_SFN_REC_TYPE_AGED_OUT_MAC_LAG:\r\nmlxsw_sp_fdb_notify_mac_lag_process(mlxsw_sp, sfn_pl,\r\nrec_index, false);\r\nbreak;\r\n}\r\n}\r\nstatic void mlxsw_sp_fdb_notify_work_schedule(struct mlxsw_sp *mlxsw_sp)\r\n{\r\nstruct mlxsw_sp_bridge *bridge = mlxsw_sp->bridge;\r\nmlxsw_core_schedule_dw(&bridge->fdb_notify.dw,\r\nmsecs_to_jiffies(bridge->fdb_notify.interval));\r\n}\r\nstatic void mlxsw_sp_fdb_notify_work(struct work_struct *work)\r\n{\r\nstruct mlxsw_sp_bridge *bridge;\r\nstruct mlxsw_sp *mlxsw_sp;\r\nchar *sfn_pl;\r\nu8 num_rec;\r\nint i;\r\nint err;\r\nsfn_pl = kmalloc(MLXSW_REG_SFN_LEN, GFP_KERNEL);\r\nif (!sfn_pl)\r\nreturn;\r\nbridge = container_of(work, struct mlxsw_sp_bridge, fdb_notify.dw.work);\r\nmlxsw_sp = bridge->mlxsw_sp;\r\nrtnl_lock();\r\nmlxsw_reg_sfn_pack(sfn_pl);\r\nerr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(sfn), sfn_pl);\r\nif (err) {\r\ndev_err_ratelimited(mlxsw_sp->bus_info->dev, "Failed to get FDB notifications\n");\r\ngoto out;\r\n}\r\nnum_rec = mlxsw_reg_sfn_num_rec_get(sfn_pl);\r\nfor (i = 0; i < num_rec; i++)\r\nmlxsw_sp_fdb_notify_rec_process(mlxsw_sp, sfn_pl, i);\r\nout:\r\nrtnl_unlock();\r\nkfree(sfn_pl);\r\nmlxsw_sp_fdb_notify_work_schedule(mlxsw_sp);\r\n}\r\nstatic void mlxsw_sp_switchdev_event_work(struct work_struct *work)\r\n{\r\nstruct mlxsw_sp_switchdev_event_work *switchdev_work =\r\ncontainer_of(work, struct mlxsw_sp_switchdev_event_work, work);\r\nstruct net_device *dev = switchdev_work->dev;\r\nstruct switchdev_notifier_fdb_info *fdb_info;\r\nstruct mlxsw_sp_port *mlxsw_sp_port;\r\nint err;\r\nrtnl_lock();\r\nmlxsw_sp_port = mlxsw_sp_port_dev_lower_find(dev);\r\nif (!mlxsw_sp_port)\r\ngoto out;\r\nswitch (switchdev_work->event) {\r\ncase SWITCHDEV_FDB_ADD_TO_DEVICE:\r\nfdb_info = &switchdev_work->fdb_info;\r\nerr = mlxsw_sp_port_fdb_set(mlxsw_sp_port, fdb_info, true);\r\nif (err)\r\nbreak;\r\nmlxsw_sp_fdb_call_notifiers(SWITCHDEV_FDB_OFFLOADED,\r\nfdb_info->addr,\r\nfdb_info->vid, dev);\r\nbreak;\r\ncase SWITCHDEV_FDB_DEL_TO_DEVICE:\r\nfdb_info = &switchdev_work->fdb_info;\r\nmlxsw_sp_port_fdb_set(mlxsw_sp_port, fdb_info, false);\r\nbreak;\r\n}\r\nout:\r\nrtnl_unlock();\r\nkfree(switchdev_work->fdb_info.addr);\r\nkfree(switchdev_work);\r\ndev_put(dev);\r\n}\r\nstatic int mlxsw_sp_switchdev_event(struct notifier_block *unused,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\r\nstruct mlxsw_sp_switchdev_event_work *switchdev_work;\r\nstruct switchdev_notifier_fdb_info *fdb_info = ptr;\r\nif (!mlxsw_sp_port_dev_lower_find_rcu(dev))\r\nreturn NOTIFY_DONE;\r\nswitchdev_work = kzalloc(sizeof(*switchdev_work), GFP_ATOMIC);\r\nif (!switchdev_work)\r\nreturn NOTIFY_BAD;\r\nINIT_WORK(&switchdev_work->work, mlxsw_sp_switchdev_event_work);\r\nswitchdev_work->dev = dev;\r\nswitchdev_work->event = event;\r\nswitch (event) {\r\ncase SWITCHDEV_FDB_ADD_TO_DEVICE:\r\ncase SWITCHDEV_FDB_DEL_TO_DEVICE:\r\nmemcpy(&switchdev_work->fdb_info, ptr,\r\nsizeof(switchdev_work->fdb_info));\r\nswitchdev_work->fdb_info.addr = kzalloc(ETH_ALEN, GFP_ATOMIC);\r\nif (!switchdev_work->fdb_info.addr)\r\ngoto err_addr_alloc;\r\nether_addr_copy((u8 *)switchdev_work->fdb_info.addr,\r\nfdb_info->addr);\r\ndev_hold(dev);\r\nbreak;\r\ndefault:\r\nkfree(switchdev_work);\r\nreturn NOTIFY_DONE;\r\n}\r\nmlxsw_core_schedule_work(&switchdev_work->work);\r\nreturn NOTIFY_DONE;\r\nerr_addr_alloc:\r\nkfree(switchdev_work);\r\nreturn NOTIFY_BAD;\r\n}\r\nstatic int mlxsw_sp_fdb_init(struct mlxsw_sp *mlxsw_sp)\r\n{\r\nstruct mlxsw_sp_bridge *bridge = mlxsw_sp->bridge;\r\nint err;\r\nerr = mlxsw_sp_ageing_set(mlxsw_sp, MLXSW_SP_DEFAULT_AGEING_TIME);\r\nif (err) {\r\ndev_err(mlxsw_sp->bus_info->dev, "Failed to set default ageing time\n");\r\nreturn err;\r\n}\r\nerr = register_switchdev_notifier(&mlxsw_sp_switchdev_notifier);\r\nif (err) {\r\ndev_err(mlxsw_sp->bus_info->dev, "Failed to register switchdev notifier\n");\r\nreturn err;\r\n}\r\nINIT_DELAYED_WORK(&bridge->fdb_notify.dw, mlxsw_sp_fdb_notify_work);\r\nbridge->fdb_notify.interval = MLXSW_SP_DEFAULT_LEARNING_INTERVAL;\r\nmlxsw_sp_fdb_notify_work_schedule(mlxsw_sp);\r\nreturn 0;\r\n}\r\nstatic void mlxsw_sp_fdb_fini(struct mlxsw_sp *mlxsw_sp)\r\n{\r\ncancel_delayed_work_sync(&mlxsw_sp->bridge->fdb_notify.dw);\r\nunregister_switchdev_notifier(&mlxsw_sp_switchdev_notifier);\r\n}\r\nstatic void mlxsw_sp_mids_fini(struct mlxsw_sp *mlxsw_sp)\r\n{\r\nstruct mlxsw_sp_mid *mid, *tmp;\r\nlist_for_each_entry_safe(mid, tmp, &mlxsw_sp->bridge->mids_list, list) {\r\nlist_del(&mid->list);\r\nclear_bit(mid->mid, mlxsw_sp->bridge->mids_bitmap);\r\nkfree(mid);\r\n}\r\n}\r\nint mlxsw_sp_switchdev_init(struct mlxsw_sp *mlxsw_sp)\r\n{\r\nstruct mlxsw_sp_bridge *bridge;\r\nbridge = kzalloc(sizeof(*mlxsw_sp->bridge), GFP_KERNEL);\r\nif (!bridge)\r\nreturn -ENOMEM;\r\nmlxsw_sp->bridge = bridge;\r\nbridge->mlxsw_sp = mlxsw_sp;\r\nINIT_LIST_HEAD(&mlxsw_sp->bridge->bridges_list);\r\nINIT_LIST_HEAD(&mlxsw_sp->bridge->mids_list);\r\nbridge->bridge_8021q_ops = &mlxsw_sp_bridge_8021q_ops;\r\nbridge->bridge_8021d_ops = &mlxsw_sp_bridge_8021d_ops;\r\nreturn mlxsw_sp_fdb_init(mlxsw_sp);\r\n}\r\nvoid mlxsw_sp_switchdev_fini(struct mlxsw_sp *mlxsw_sp)\r\n{\r\nmlxsw_sp_fdb_fini(mlxsw_sp);\r\nmlxsw_sp_mids_fini(mlxsw_sp);\r\nWARN_ON(!list_empty(&mlxsw_sp->bridge->bridges_list));\r\nkfree(mlxsw_sp->bridge);\r\n}\r\nvoid mlxsw_sp_port_switchdev_init(struct mlxsw_sp_port *mlxsw_sp_port)\r\n{\r\nmlxsw_sp_port->dev->switchdev_ops = &mlxsw_sp_port_switchdev_ops;\r\n}\r\nvoid mlxsw_sp_port_switchdev_fini(struct mlxsw_sp_port *mlxsw_sp_port)\r\n{\r\n}
