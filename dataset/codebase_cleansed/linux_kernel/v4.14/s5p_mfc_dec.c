static struct s5p_mfc_fmt *find_format(struct v4l2_format *f, unsigned int t)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < NUM_FORMATS; i++) {\r\nif (formats[i].fourcc == f->fmt.pix_mp.pixelformat &&\r\nformats[i].type == t)\r\nreturn &formats[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int s5p_mfc_ctx_ready(struct s5p_mfc_ctx *ctx)\r\n{\r\nif (ctx->src_queue_cnt >= 1 && ctx->state == MFCINST_GOT_INST)\r\nreturn 1;\r\nif (ctx->src_queue_cnt >= 1 &&\r\nctx->state == MFCINST_RUNNING &&\r\nctx->dst_queue_cnt >= ctx->pb_count)\r\nreturn 1;\r\nif (ctx->state == MFCINST_FINISHING &&\r\nctx->dst_queue_cnt >= ctx->pb_count)\r\nreturn 1;\r\nif (ctx->src_queue_cnt >= 1 &&\r\nctx->state == MFCINST_HEAD_PARSED &&\r\nctx->capture_state == QUEUE_BUFS_MMAPED)\r\nreturn 1;\r\nif ((ctx->state == MFCINST_RES_CHANGE_INIT ||\r\nctx->state == MFCINST_RES_CHANGE_FLUSH) &&\r\nctx->dst_queue_cnt >= ctx->pb_count)\r\nreturn 1;\r\nif (ctx->state == MFCINST_RES_CHANGE_END &&\r\nctx->src_queue_cnt >= 1)\r\nreturn 1;\r\nmfc_debug(2, "ctx is not ready\n");\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct s5p_mfc_dev *dev = video_drvdata(file);\r\nstrncpy(cap->driver, S5P_MFC_NAME, sizeof(cap->driver) - 1);\r\nstrncpy(cap->card, dev->vfd_dec->name, sizeof(cap->card) - 1);\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",\r\ndev_name(&dev->plat_dev->dev));\r\ncap->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt(struct file *file, struct v4l2_fmtdesc *f,\r\nbool out)\r\n{\r\nstruct s5p_mfc_dev *dev = video_drvdata(file);\r\nstruct s5p_mfc_fmt *fmt;\r\nint i, j = 0;\r\nfor (i = 0; i < ARRAY_SIZE(formats); ++i) {\r\nif (out && formats[i].type != MFC_FMT_DEC)\r\ncontinue;\r\nelse if (!out && formats[i].type != MFC_FMT_RAW)\r\ncontinue;\r\nelse if ((dev->variant->version_bit & formats[i].versions) == 0)\r\ncontinue;\r\nif (j == f->index)\r\nbreak;\r\n++j;\r\n}\r\nif (i == ARRAY_SIZE(formats))\r\nreturn -EINVAL;\r\nfmt = &formats[i];\r\nstrlcpy(f->description, fmt->name, sizeof(f->description));\r\nf->pixelformat = fmt->fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap_mplane(struct file *file, void *pirv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn vidioc_enum_fmt(file, f, false);\r\n}\r\nstatic int vidioc_enum_fmt_vid_out_mplane(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn vidioc_enum_fmt(file, f, true);\r\n}\r\nstatic int vidioc_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nstruct v4l2_pix_format_mplane *pix_mp;\r\nmfc_debug_enter();\r\npix_mp = &f->fmt.pix_mp;\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\r\n(ctx->state == MFCINST_GOT_INST || ctx->state ==\r\nMFCINST_RES_CHANGE_END)) {\r\ns5p_mfc_wait_for_done_ctx(ctx, S5P_MFC_R2H_CMD_SEQ_DONE_RET,\r\n0);\r\n}\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\r\nctx->state >= MFCINST_HEAD_PARSED &&\r\nctx->state < MFCINST_ABORT) {\r\npix_mp->width = ctx->buf_width;\r\npix_mp->height = ctx->buf_height;\r\npix_mp->field = V4L2_FIELD_NONE;\r\npix_mp->num_planes = 2;\r\npix_mp->pixelformat = ctx->dst_fmt->fourcc;\r\npix_mp->plane_fmt[0].bytesperline = ctx->buf_width;\r\npix_mp->plane_fmt[0].sizeimage = ctx->luma_size;\r\npix_mp->plane_fmt[1].bytesperline = ctx->buf_width;\r\npix_mp->plane_fmt[1].sizeimage = ctx->chroma_size;\r\n} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\npix_mp->width = 0;\r\npix_mp->height = 0;\r\npix_mp->field = V4L2_FIELD_NONE;\r\npix_mp->plane_fmt[0].bytesperline = ctx->dec_src_buf_size;\r\npix_mp->plane_fmt[0].sizeimage = ctx->dec_src_buf_size;\r\npix_mp->pixelformat = ctx->src_fmt->fourcc;\r\npix_mp->num_planes = ctx->src_fmt->num_planes;\r\n} else {\r\nmfc_err("Format could not be read\n");\r\nmfc_debug(2, "%s-- with error\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmfc_debug_leave();\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct s5p_mfc_dev *dev = video_drvdata(file);\r\nstruct s5p_mfc_fmt *fmt;\r\nmfc_debug(2, "Type is %d\n", f->type);\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nfmt = find_format(f, MFC_FMT_DEC);\r\nif (!fmt) {\r\nmfc_err("Unsupported format for source.\n");\r\nreturn -EINVAL;\r\n}\r\nif (fmt->codec_mode == S5P_FIMV_CODEC_NONE) {\r\nmfc_err("Unknown codec\n");\r\nreturn -EINVAL;\r\n}\r\nif ((dev->variant->version_bit & fmt->versions) == 0) {\r\nmfc_err("Unsupported format by this MFC version.\n");\r\nreturn -EINVAL;\r\n}\r\n} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nfmt = find_format(f, MFC_FMT_RAW);\r\nif (!fmt) {\r\nmfc_err("Unsupported format for destination.\n");\r\nreturn -EINVAL;\r\n}\r\nif ((dev->variant->version_bit & fmt->versions) == 0) {\r\nmfc_err("Unsupported format by this MFC version.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct s5p_mfc_dev *dev = video_drvdata(file);\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nint ret = 0;\r\nstruct v4l2_pix_format_mplane *pix_mp;\r\nstruct s5p_mfc_buf_size *buf_size = dev->variant->buf_size;\r\nmfc_debug_enter();\r\nret = vidioc_try_fmt(file, priv, f);\r\npix_mp = &f->fmt.pix_mp;\r\nif (ret)\r\nreturn ret;\r\nif (vb2_is_streaming(&ctx->vq_src) || vb2_is_streaming(&ctx->vq_dst)) {\r\nv4l2_err(&dev->v4l2_dev, "%s queue busy\n", __func__);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nctx->dst_fmt = find_format(f, MFC_FMT_RAW);\r\nret = 0;\r\ngoto out;\r\n} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nctx->src_fmt = find_format(f, MFC_FMT_DEC);\r\nctx->codec_mode = ctx->src_fmt->codec_mode;\r\nmfc_debug(2, "The codec number is: %d\n", ctx->codec_mode);\r\npix_mp->height = 0;\r\npix_mp->width = 0;\r\nif (pix_mp->plane_fmt[0].sizeimage == 0)\r\npix_mp->plane_fmt[0].sizeimage = ctx->dec_src_buf_size =\r\nDEF_CPB_SIZE;\r\nelse if (pix_mp->plane_fmt[0].sizeimage > buf_size->cpb)\r\nctx->dec_src_buf_size = buf_size->cpb;\r\nelse\r\nctx->dec_src_buf_size = pix_mp->plane_fmt[0].sizeimage;\r\npix_mp->plane_fmt[0].bytesperline = 0;\r\nctx->state = MFCINST_INIT;\r\nret = 0;\r\ngoto out;\r\n} else {\r\nmfc_err("Wrong type error for S_FMT : %d", f->type);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nout:\r\nmfc_debug_leave();\r\nreturn ret;\r\n}\r\nstatic int reqbufs_output(struct s5p_mfc_dev *dev, struct s5p_mfc_ctx *ctx,\r\nstruct v4l2_requestbuffers *reqbufs)\r\n{\r\nint ret = 0;\r\ns5p_mfc_clock_on();\r\nif (reqbufs->count == 0) {\r\nmfc_debug(2, "Freeing buffers\n");\r\nret = vb2_reqbufs(&ctx->vq_src, reqbufs);\r\nif (ret)\r\ngoto out;\r\nctx->src_bufs_cnt = 0;\r\nctx->output_state = QUEUE_FREE;\r\n} else if (ctx->output_state == QUEUE_FREE) {\r\nWARN_ON(ctx->src_bufs_cnt != 0);\r\nif (ctx->state != MFCINST_INIT) {\r\nmfc_err("Reqbufs called in an invalid state\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmfc_debug(2, "Allocating %d buffers for OUTPUT queue\n",\r\nreqbufs->count);\r\nret = vb2_reqbufs(&ctx->vq_src, reqbufs);\r\nif (ret)\r\ngoto out;\r\nret = s5p_mfc_open_mfc_inst(dev, ctx);\r\nif (ret) {\r\nreqbufs->count = 0;\r\nvb2_reqbufs(&ctx->vq_src, reqbufs);\r\ngoto out;\r\n}\r\nctx->output_state = QUEUE_BUFS_REQUESTED;\r\n} else {\r\nmfc_err("Buffers have already been requested\n");\r\nret = -EINVAL;\r\n}\r\nout:\r\ns5p_mfc_clock_off();\r\nif (ret)\r\nmfc_err("Failed allocating buffers for OUTPUT queue\n");\r\nreturn ret;\r\n}\r\nstatic int reqbufs_capture(struct s5p_mfc_dev *dev, struct s5p_mfc_ctx *ctx,\r\nstruct v4l2_requestbuffers *reqbufs)\r\n{\r\nint ret = 0;\r\ns5p_mfc_clock_on();\r\nif (reqbufs->count == 0) {\r\nmfc_debug(2, "Freeing buffers\n");\r\nret = vb2_reqbufs(&ctx->vq_dst, reqbufs);\r\nif (ret)\r\ngoto out;\r\ns5p_mfc_hw_call(dev->mfc_ops, release_codec_buffers, ctx);\r\nctx->dst_bufs_cnt = 0;\r\n} else if (ctx->capture_state == QUEUE_FREE) {\r\nWARN_ON(ctx->dst_bufs_cnt != 0);\r\nmfc_debug(2, "Allocating %d buffers for CAPTURE queue\n",\r\nreqbufs->count);\r\nret = vb2_reqbufs(&ctx->vq_dst, reqbufs);\r\nif (ret)\r\ngoto out;\r\nctx->capture_state = QUEUE_BUFS_REQUESTED;\r\nctx->total_dpb_count = reqbufs->count;\r\nret = s5p_mfc_hw_call(dev->mfc_ops, alloc_codec_buffers, ctx);\r\nif (ret) {\r\nmfc_err("Failed to allocate decoding buffers\n");\r\nreqbufs->count = 0;\r\nvb2_reqbufs(&ctx->vq_dst, reqbufs);\r\nret = -ENOMEM;\r\nctx->capture_state = QUEUE_FREE;\r\ngoto out;\r\n}\r\nWARN_ON(ctx->dst_bufs_cnt != ctx->total_dpb_count);\r\nctx->capture_state = QUEUE_BUFS_MMAPED;\r\nif (s5p_mfc_ctx_ready(ctx))\r\nset_work_bit_irqsave(ctx);\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\ns5p_mfc_wait_for_done_ctx(ctx, S5P_MFC_R2H_CMD_INIT_BUFFERS_RET,\r\n0);\r\n} else {\r\nmfc_err("Buffers have already been requested\n");\r\nret = -EINVAL;\r\n}\r\nout:\r\ns5p_mfc_clock_off();\r\nif (ret)\r\nmfc_err("Failed allocating buffers for CAPTURE queue\n");\r\nreturn ret;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *reqbufs)\r\n{\r\nstruct s5p_mfc_dev *dev = video_drvdata(file);\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nif (reqbufs->memory != V4L2_MEMORY_MMAP) {\r\nmfc_debug(2, "Only V4L2_MEMORY_MMAP is supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (reqbufs->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nreturn reqbufs_output(dev, ctx, reqbufs);\r\n} else if (reqbufs->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nreturn reqbufs_capture(dev, ctx, reqbufs);\r\n} else {\r\nmfc_err("Invalid type requested\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nint ret;\r\nint i;\r\nif (buf->memory != V4L2_MEMORY_MMAP) {\r\nmfc_err("Only mmaped buffers can be used\n");\r\nreturn -EINVAL;\r\n}\r\nmfc_debug(2, "State: %d, buf->type: %d\n", ctx->state, buf->type);\r\nif (ctx->state == MFCINST_GOT_INST &&\r\nbuf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nret = vb2_querybuf(&ctx->vq_src, buf);\r\n} else if (ctx->state == MFCINST_RUNNING &&\r\nbuf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nret = vb2_querybuf(&ctx->vq_dst, buf);\r\nfor (i = 0; i < buf->length; i++)\r\nbuf->m.planes[i].m.mem_offset += DST_QUEUE_OFF_BASE;\r\n} else {\r\nmfc_err("vidioc_querybuf called in an inappropriate state\n");\r\nret = -EINVAL;\r\n}\r\nmfc_debug_leave();\r\nreturn ret;\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nif (ctx->state == MFCINST_ERROR) {\r\nmfc_err("Call on QBUF after unrecoverable error\n");\r\nreturn -EIO;\r\n}\r\nif (buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nreturn vb2_qbuf(&ctx->vq_src, buf);\r\nelse if (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nreturn vb2_qbuf(&ctx->vq_dst, buf);\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nconst struct v4l2_event ev = {\r\n.type = V4L2_EVENT_EOS\r\n};\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nint ret;\r\nif (ctx->state == MFCINST_ERROR) {\r\nmfc_err_limited("Call on DQBUF after unrecoverable error\n");\r\nreturn -EIO;\r\n}\r\nswitch (buf->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nreturn vb2_dqbuf(&ctx->vq_src, buf, file->f_flags & O_NONBLOCK);\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\nret = vb2_dqbuf(&ctx->vq_dst, buf, file->f_flags & O_NONBLOCK);\r\nif (ret)\r\nreturn ret;\r\nif (ctx->state == MFCINST_FINISHED &&\r\n(ctx->dst_bufs[buf->index].flags & MFC_BUF_FLAG_EOS))\r\nv4l2_event_queue_fh(&ctx->fh, &ev);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int vidioc_expbuf(struct file *file, void *priv,\r\nstruct v4l2_exportbuffer *eb)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nif (eb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nreturn vb2_expbuf(&ctx->vq_src, eb);\r\nif (eb->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nreturn vb2_expbuf(&ctx->vq_dst, eb);\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nint ret = -EINVAL;\r\nmfc_debug_enter();\r\nif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nret = vb2_streamon(&ctx->vq_src, type);\r\nelse if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nret = vb2_streamon(&ctx->vq_dst, type);\r\nmfc_debug_leave();\r\nreturn ret;\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nreturn vb2_streamoff(&ctx->vq_src, type);\r\nelse if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nreturn vb2_streamoff(&ctx->vq_dst, type);\r\nreturn -EINVAL;\r\n}\r\nstatic int s5p_mfc_dec_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct s5p_mfc_ctx *ctx = ctrl_to_ctx(ctrl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY:\r\nctx->display_delay = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY_ENABLE:\r\nctx->display_delay_enable = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER:\r\nctx->loop_filter_mpeg4 = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE:\r\nctx->slice_interface = ctrl->val;\r\nbreak;\r\ndefault:\r\nmfc_err("Invalid control 0x%08x\n", ctrl->id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_dec_g_v_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct s5p_mfc_ctx *ctx = ctrl_to_ctx(ctrl);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:\r\nif (ctx->state >= MFCINST_HEAD_PARSED &&\r\nctx->state < MFCINST_ABORT) {\r\nctrl->val = ctx->pb_count;\r\nbreak;\r\n} else if (ctx->state != MFCINST_INIT &&\r\nctx->state != MFCINST_RES_CHANGE_END) {\r\nv4l2_err(&dev->v4l2_dev, "Decoding not initialised\n");\r\nreturn -EINVAL;\r\n}\r\ns5p_mfc_wait_for_done_ctx(ctx,\r\nS5P_MFC_R2H_CMD_SEQ_DONE_RET, 0);\r\nif (ctx->state >= MFCINST_HEAD_PARSED &&\r\nctx->state < MFCINST_ABORT) {\r\nctrl->val = ctx->pb_count;\r\n} else {\r\nv4l2_err(&dev->v4l2_dev, "Decoding not initialised\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_crop(struct file *file, void *priv,\r\nstruct v4l2_crop *cr)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nu32 left, right, top, bottom;\r\nif (ctx->state != MFCINST_HEAD_PARSED &&\r\nctx->state != MFCINST_RUNNING &&\r\nctx->state != MFCINST_FINISHING &&\r\nctx->state != MFCINST_FINISHED) {\r\nmfc_err("Can not get crop information\n");\r\nreturn -EINVAL;\r\n}\r\nif (ctx->src_fmt->fourcc == V4L2_PIX_FMT_H264) {\r\nleft = s5p_mfc_hw_call(dev->mfc_ops, get_crop_info_h, ctx);\r\nright = left >> S5P_FIMV_SHARED_CROP_RIGHT_SHIFT;\r\nleft = left & S5P_FIMV_SHARED_CROP_LEFT_MASK;\r\ntop = s5p_mfc_hw_call(dev->mfc_ops, get_crop_info_v, ctx);\r\nbottom = top >> S5P_FIMV_SHARED_CROP_BOTTOM_SHIFT;\r\ntop = top & S5P_FIMV_SHARED_CROP_TOP_MASK;\r\ncr->c.left = left;\r\ncr->c.top = top;\r\ncr->c.width = ctx->img_width - left - right;\r\ncr->c.height = ctx->img_height - top - bottom;\r\nmfc_debug(2, "Cropping info [h264]: l=%d t=%d w=%d h=%d (r=%d b=%d fw=%d fh=%d\n",\r\nleft, top, cr->c.width, cr->c.height, right, bottom,\r\nctx->buf_width, ctx->buf_height);\r\n} else {\r\ncr->c.left = 0;\r\ncr->c.top = 0;\r\ncr->c.width = ctx->img_width;\r\ncr->c.height = ctx->img_height;\r\nmfc_debug(2, "Cropping info: w=%d h=%d fw=%d fh=%d\n",\r\ncr->c.width, cr->c.height, ctx->buf_width,\r\nctx->buf_height);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_decoder_cmd(struct file *file, void *priv,\r\nstruct v4l2_decoder_cmd *cmd)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_buf *buf;\r\nunsigned long flags;\r\nswitch (cmd->cmd) {\r\ncase V4L2_DEC_CMD_STOP:\r\nif (cmd->flags != 0)\r\nreturn -EINVAL;\r\nif (!vb2_is_streaming(&ctx->vq_src))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nif (list_empty(&ctx->src_queue)) {\r\nmfc_err("EOS: empty src queue, entering finishing state");\r\nctx->state = MFCINST_FINISHING;\r\nif (s5p_mfc_ctx_ready(ctx))\r\nset_work_bit_irqsave(ctx);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\n} else {\r\nmfc_err("EOS: marking last buffer of stream");\r\nbuf = list_entry(ctx->src_queue.prev,\r\nstruct s5p_mfc_buf, list);\r\nif (buf->flags & MFC_BUF_FLAG_USED)\r\nctx->state = MFCINST_FINISHING;\r\nelse\r\nbuf->flags |= MFC_BUF_FLAG_EOS;\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_subscribe_event(struct v4l2_fh *fh,\r\nconst struct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_EOS:\r\nreturn v4l2_event_subscribe(fh, sub, 2, NULL);\r\ncase V4L2_EVENT_SOURCE_CHANGE:\r\nreturn v4l2_src_change_event_subscribe(fh, sub);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int s5p_mfc_queue_setup(struct vb2_queue *vq,\r\nunsigned int *buf_count,\r\nunsigned int *plane_count, unsigned int psize[],\r\nstruct device *alloc_devs[])\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nif (ctx->state == MFCINST_INIT &&\r\nvq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\n*plane_count = 1;\r\nif (*buf_count < 1)\r\n*buf_count = 1;\r\nif (*buf_count > MFC_MAX_BUFFERS)\r\n*buf_count = MFC_MAX_BUFFERS;\r\n} else if (ctx->state == MFCINST_HEAD_PARSED &&\r\nvq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\n*plane_count = 2;\r\nif (*buf_count < ctx->pb_count)\r\n*buf_count = ctx->pb_count;\r\nif (*buf_count > ctx->pb_count + MFC_MAX_EXTRA_DPB)\r\n*buf_count = ctx->pb_count + MFC_MAX_EXTRA_DPB;\r\nif (*buf_count > MFC_MAX_BUFFERS)\r\n*buf_count = MFC_MAX_BUFFERS;\r\n} else {\r\nmfc_err("State seems invalid. State = %d, vq->type = %d\n",\r\nctx->state, vq->type);\r\nreturn -EINVAL;\r\n}\r\nmfc_debug(2, "Buffer count=%d, plane count=%d\n",\r\n*buf_count, *plane_count);\r\nif (ctx->state == MFCINST_HEAD_PARSED &&\r\nvq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\npsize[0] = ctx->luma_size;\r\npsize[1] = ctx->chroma_size;\r\nif (IS_MFCV6_PLUS(dev))\r\nalloc_devs[0] = ctx->dev->mem_dev[BANK_L_CTX];\r\nelse\r\nalloc_devs[0] = ctx->dev->mem_dev[BANK_R_CTX];\r\nalloc_devs[1] = ctx->dev->mem_dev[BANK_L_CTX];\r\n} else if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE &&\r\nctx->state == MFCINST_INIT) {\r\npsize[0] = ctx->dec_src_buf_size;\r\nalloc_devs[0] = ctx->dev->mem_dev[BANK_L_CTX];\r\n} else {\r\nmfc_err("This video node is dedicated to decoding. Decoding not initialized\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_buf_init(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\r\nunsigned int i;\r\nif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nif (ctx->capture_state == QUEUE_BUFS_MMAPED)\r\nreturn 0;\r\nfor (i = 0; i < ctx->dst_fmt->num_planes; i++) {\r\nif (IS_ERR_OR_NULL(ERR_PTR(\r\nvb2_dma_contig_plane_dma_addr(vb, i)))) {\r\nmfc_err("Plane mem not allocated\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (vb2_plane_size(vb, 0) < ctx->luma_size ||\r\nvb2_plane_size(vb, 1) < ctx->chroma_size) {\r\nmfc_err("Plane buffer (CAPTURE) is too small\n");\r\nreturn -EINVAL;\r\n}\r\ni = vb->index;\r\nctx->dst_bufs[i].b = vbuf;\r\nctx->dst_bufs[i].cookie.raw.luma =\r\nvb2_dma_contig_plane_dma_addr(vb, 0);\r\nctx->dst_bufs[i].cookie.raw.chroma =\r\nvb2_dma_contig_plane_dma_addr(vb, 1);\r\nctx->dst_bufs_cnt++;\r\n} else if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nif (IS_ERR_OR_NULL(ERR_PTR(\r\nvb2_dma_contig_plane_dma_addr(vb, 0)))) {\r\nmfc_err("Plane memory not allocated\n");\r\nreturn -EINVAL;\r\n}\r\nif (vb2_plane_size(vb, 0) < ctx->dec_src_buf_size) {\r\nmfc_err("Plane buffer (OUTPUT) is too small\n");\r\nreturn -EINVAL;\r\n}\r\ni = vb->index;\r\nctx->src_bufs[i].b = vbuf;\r\nctx->src_bufs[i].cookie.stream =\r\nvb2_dma_contig_plane_dma_addr(vb, 0);\r\nctx->src_bufs_cnt++;\r\n} else {\r\nmfc_err("s5p_mfc_buf_init: unknown queue type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(q->drv_priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nv4l2_ctrl_handler_setup(&ctx->ctrl_handler);\r\nif (ctx->state == MFCINST_FINISHING ||\r\nctx->state == MFCINST_FINISHED)\r\nctx->state = MFCINST_RUNNING;\r\nif (s5p_mfc_ctx_ready(ctx))\r\nset_work_bit_irqsave(ctx);\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\nreturn 0;\r\n}\r\nstatic void s5p_mfc_stop_streaming(struct vb2_queue *q)\r\n{\r\nunsigned long flags;\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(q->drv_priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nint aborted = 0;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nif ((ctx->state == MFCINST_FINISHING ||\r\nctx->state == MFCINST_RUNNING) &&\r\ndev->curr_ctx == ctx->num && dev->hw_lock) {\r\nctx->state = MFCINST_ABORT;\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\ns5p_mfc_wait_for_done_ctx(ctx,\r\nS5P_MFC_R2H_CMD_FRAME_DONE_RET, 0);\r\naborted = 1;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\n}\r\nif (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\ns5p_mfc_cleanup_queue(&ctx->dst_queue, &ctx->vq_dst);\r\nINIT_LIST_HEAD(&ctx->dst_queue);\r\nctx->dst_queue_cnt = 0;\r\nctx->dpb_flush_flag = 1;\r\nctx->dec_dst_flag = 0;\r\nif (IS_MFCV6_PLUS(dev) && (ctx->state == MFCINST_RUNNING)) {\r\nctx->state = MFCINST_FLUSH;\r\nset_work_bit_irqsave(ctx);\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nif (s5p_mfc_wait_for_done_ctx(ctx,\r\nS5P_MFC_R2H_CMD_DPB_FLUSH_RET, 0))\r\nmfc_err("Err flushing buffers\n");\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\n}\r\n} else if (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\ns5p_mfc_cleanup_queue(&ctx->src_queue, &ctx->vq_src);\r\nINIT_LIST_HEAD(&ctx->src_queue);\r\nctx->src_queue_cnt = 0;\r\n}\r\nif (aborted)\r\nctx->state = MFCINST_RUNNING;\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\n}\r\nstatic void s5p_mfc_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nstruct s5p_mfc_buf *mfc_buf;\r\nif (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nmfc_buf = &ctx->src_bufs[vb->index];\r\nmfc_buf->flags &= ~MFC_BUF_FLAG_USED;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nlist_add_tail(&mfc_buf->list, &ctx->src_queue);\r\nctx->src_queue_cnt++;\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\n} else if (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nmfc_buf = &ctx->dst_bufs[vb->index];\r\nmfc_buf->flags &= ~MFC_BUF_FLAG_USED;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nset_bit(vb->index, &ctx->dec_dst_flag);\r\nlist_add_tail(&mfc_buf->list, &ctx->dst_queue);\r\nctx->dst_queue_cnt++;\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\n} else {\r\nmfc_err("Unsupported buffer type (%d)\n", vq->type);\r\n}\r\nif (s5p_mfc_ctx_ready(ctx))\r\nset_work_bit_irqsave(ctx);\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\n}\r\nconst struct s5p_mfc_codec_ops *get_dec_codec_ops(void)\r\n{\r\nreturn &decoder_codec_ops;\r\n}\r\nstruct vb2_ops *get_dec_queue_ops(void)\r\n{\r\nreturn &s5p_mfc_dec_qops;\r\n}\r\nconst struct v4l2_ioctl_ops *get_dec_v4l2_ioctl_ops(void)\r\n{\r\nreturn &s5p_mfc_dec_ioctl_ops;\r\n}\r\nint s5p_mfc_dec_ctrls_setup(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct v4l2_ctrl_config cfg;\r\nint i;\r\nv4l2_ctrl_handler_init(&ctx->ctrl_handler, NUM_CTRLS);\r\nif (ctx->ctrl_handler.error) {\r\nmfc_err("v4l2_ctrl_handler_init failed\n");\r\nreturn ctx->ctrl_handler.error;\r\n}\r\nfor (i = 0; i < NUM_CTRLS; i++) {\r\nif (IS_MFC51_PRIV(controls[i].id)) {\r\nmemset(&cfg, 0, sizeof(struct v4l2_ctrl_config));\r\ncfg.ops = &s5p_mfc_dec_ctrl_ops;\r\ncfg.id = controls[i].id;\r\ncfg.min = controls[i].minimum;\r\ncfg.max = controls[i].maximum;\r\ncfg.def = controls[i].default_value;\r\ncfg.name = controls[i].name;\r\ncfg.type = controls[i].type;\r\ncfg.step = controls[i].step;\r\ncfg.menu_skip_mask = 0;\r\nctx->ctrls[i] = v4l2_ctrl_new_custom(&ctx->ctrl_handler,\r\n&cfg, NULL);\r\n} else {\r\nctx->ctrls[i] = v4l2_ctrl_new_std(&ctx->ctrl_handler,\r\n&s5p_mfc_dec_ctrl_ops,\r\ncontrols[i].id, controls[i].minimum,\r\ncontrols[i].maximum, controls[i].step,\r\ncontrols[i].default_value);\r\n}\r\nif (ctx->ctrl_handler.error) {\r\nmfc_err("Adding control (%d) failed\n", i);\r\nreturn ctx->ctrl_handler.error;\r\n}\r\nif (controls[i].is_volatile && ctx->ctrls[i])\r\nctx->ctrls[i]->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\n}\r\nreturn 0;\r\n}\r\nvoid s5p_mfc_dec_ctrls_delete(struct s5p_mfc_ctx *ctx)\r\n{\r\nint i;\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nfor (i = 0; i < NUM_CTRLS; i++)\r\nctx->ctrls[i] = NULL;\r\n}\r\nvoid s5p_mfc_dec_init(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct v4l2_format f;\r\nf.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H264;\r\nctx->src_fmt = find_format(&f, MFC_FMT_DEC);\r\nif (IS_MFCV8(ctx->dev))\r\nf.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M;\r\nelse if (IS_MFCV6_PLUS(ctx->dev))\r\nf.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12MT_16X16;\r\nelse\r\nf.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12MT;\r\nctx->dst_fmt = find_format(&f, MFC_FMT_RAW);\r\nmfc_debug(2, "Default src_fmt is %p, dest_fmt is %p\n",\r\nctx->src_fmt, ctx->dst_fmt);\r\n}
