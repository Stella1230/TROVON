static inline u32 gpio_reg_v2_convert(unsigned int offset)\r\n{\r\nswitch (offset) {\r\ncase GPIO_INTMASK:\r\nreturn GPIO_INTMASK_V2;\r\ncase GPIO_INTTYPE_LEVEL:\r\nreturn GPIO_INTTYPE_LEVEL_V2;\r\ncase GPIO_INT_POLARITY:\r\nreturn GPIO_INT_POLARITY_V2;\r\ncase GPIO_INTSTATUS:\r\nreturn GPIO_INTSTATUS_V2;\r\ncase GPIO_PORTA_EOI:\r\nreturn GPIO_PORTA_EOI_V2;\r\n}\r\nreturn offset;\r\n}\r\nstatic inline u32 gpio_reg_convert(struct dwapb_gpio *gpio, unsigned int offset)\r\n{\r\nif (gpio->flags & GPIO_REG_OFFSET_V2)\r\nreturn gpio_reg_v2_convert(offset);\r\nreturn offset;\r\n}\r\nstatic inline u32 dwapb_read(struct dwapb_gpio *gpio, unsigned int offset)\r\n{\r\nstruct gpio_chip *gc = &gpio->ports[0].gc;\r\nvoid __iomem *reg_base = gpio->regs;\r\nreturn gc->read_reg(reg_base + gpio_reg_convert(gpio, offset));\r\n}\r\nstatic inline void dwapb_write(struct dwapb_gpio *gpio, unsigned int offset,\r\nu32 val)\r\n{\r\nstruct gpio_chip *gc = &gpio->ports[0].gc;\r\nvoid __iomem *reg_base = gpio->regs;\r\ngc->write_reg(reg_base + gpio_reg_convert(gpio, offset), val);\r\n}\r\nstatic int dwapb_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct dwapb_gpio_port *port = gpiochip_get_data(gc);\r\nstruct dwapb_gpio *gpio = port->gpio;\r\nreturn irq_find_mapping(gpio->domain, offset);\r\n}\r\nstatic void dwapb_toggle_trigger(struct dwapb_gpio *gpio, unsigned int offs)\r\n{\r\nu32 v = dwapb_read(gpio, GPIO_INT_POLARITY);\r\nif (gpio_get_value(gpio->ports[0].gc.base + offs))\r\nv &= ~BIT(offs);\r\nelse\r\nv |= BIT(offs);\r\ndwapb_write(gpio, GPIO_INT_POLARITY, v);\r\n}\r\nstatic u32 dwapb_do_irq(struct dwapb_gpio *gpio)\r\n{\r\nu32 irq_status = dwapb_read(gpio, GPIO_INTSTATUS);\r\nu32 ret = irq_status;\r\nwhile (irq_status) {\r\nint hwirq = fls(irq_status) - 1;\r\nint gpio_irq = irq_find_mapping(gpio->domain, hwirq);\r\ngeneric_handle_irq(gpio_irq);\r\nirq_status &= ~BIT(hwirq);\r\nif ((irq_get_trigger_type(gpio_irq) & IRQ_TYPE_SENSE_MASK)\r\n== IRQ_TYPE_EDGE_BOTH)\r\ndwapb_toggle_trigger(gpio, hwirq);\r\n}\r\nreturn ret;\r\n}\r\nstatic void dwapb_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct dwapb_gpio *gpio = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\ndwapb_do_irq(gpio);\r\nif (chip->irq_eoi)\r\nchip->irq_eoi(irq_desc_get_irq_data(desc));\r\n}\r\nstatic void dwapb_irq_enable(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *igc = irq_data_get_irq_chip_data(d);\r\nstruct dwapb_gpio *gpio = igc->private;\r\nstruct gpio_chip *gc = &gpio->ports[0].gc;\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&gc->bgpio_lock, flags);\r\nval = dwapb_read(gpio, GPIO_INTEN);\r\nval |= BIT(d->hwirq);\r\ndwapb_write(gpio, GPIO_INTEN, val);\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\n}\r\nstatic void dwapb_irq_disable(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *igc = irq_data_get_irq_chip_data(d);\r\nstruct dwapb_gpio *gpio = igc->private;\r\nstruct gpio_chip *gc = &gpio->ports[0].gc;\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&gc->bgpio_lock, flags);\r\nval = dwapb_read(gpio, GPIO_INTEN);\r\nval &= ~BIT(d->hwirq);\r\ndwapb_write(gpio, GPIO_INTEN, val);\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\n}\r\nstatic int dwapb_irq_reqres(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *igc = irq_data_get_irq_chip_data(d);\r\nstruct dwapb_gpio *gpio = igc->private;\r\nstruct gpio_chip *gc = &gpio->ports[0].gc;\r\nif (gpiochip_lock_as_irq(gc, irqd_to_hwirq(d))) {\r\ndev_err(gpio->dev, "unable to lock HW IRQ %lu for IRQ\n",\r\nirqd_to_hwirq(d));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dwapb_irq_relres(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *igc = irq_data_get_irq_chip_data(d);\r\nstruct dwapb_gpio *gpio = igc->private;\r\nstruct gpio_chip *gc = &gpio->ports[0].gc;\r\ngpiochip_unlock_as_irq(gc, irqd_to_hwirq(d));\r\n}\r\nstatic int dwapb_irq_set_type(struct irq_data *d, u32 type)\r\n{\r\nstruct irq_chip_generic *igc = irq_data_get_irq_chip_data(d);\r\nstruct dwapb_gpio *gpio = igc->private;\r\nstruct gpio_chip *gc = &gpio->ports[0].gc;\r\nint bit = d->hwirq;\r\nunsigned long level, polarity, flags;\r\nif (type & ~(IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING |\r\nIRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&gc->bgpio_lock, flags);\r\nlevel = dwapb_read(gpio, GPIO_INTTYPE_LEVEL);\r\npolarity = dwapb_read(gpio, GPIO_INT_POLARITY);\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nlevel |= BIT(bit);\r\ndwapb_toggle_trigger(gpio, bit);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nlevel |= BIT(bit);\r\npolarity |= BIT(bit);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nlevel |= BIT(bit);\r\npolarity &= ~BIT(bit);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nlevel &= ~BIT(bit);\r\npolarity |= BIT(bit);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nlevel &= ~BIT(bit);\r\npolarity &= ~BIT(bit);\r\nbreak;\r\n}\r\nirq_setup_alt_chip(d, type);\r\ndwapb_write(gpio, GPIO_INTTYPE_LEVEL, level);\r\nif (type != IRQ_TYPE_EDGE_BOTH)\r\ndwapb_write(gpio, GPIO_INT_POLARITY, polarity);\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dwapb_gpio_set_debounce(struct gpio_chip *gc,\r\nunsigned offset, unsigned debounce)\r\n{\r\nstruct dwapb_gpio_port *port = gpiochip_get_data(gc);\r\nstruct dwapb_gpio *gpio = port->gpio;\r\nunsigned long flags, val_deb;\r\nunsigned long mask = gc->pin2mask(gc, offset);\r\nspin_lock_irqsave(&gc->bgpio_lock, flags);\r\nval_deb = dwapb_read(gpio, GPIO_PORTA_DEBOUNCE);\r\nif (debounce)\r\ndwapb_write(gpio, GPIO_PORTA_DEBOUNCE, val_deb | mask);\r\nelse\r\ndwapb_write(gpio, GPIO_PORTA_DEBOUNCE, val_deb & ~mask);\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dwapb_gpio_set_config(struct gpio_chip *gc, unsigned offset,\r\nunsigned long config)\r\n{\r\nu32 debounce;\r\nif (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)\r\nreturn -ENOTSUPP;\r\ndebounce = pinconf_to_config_argument(config);\r\nreturn dwapb_gpio_set_debounce(gc, offset, debounce);\r\n}\r\nstatic irqreturn_t dwapb_irq_handler_mfd(int irq, void *dev_id)\r\n{\r\nu32 worked;\r\nstruct dwapb_gpio *gpio = dev_id;\r\nworked = dwapb_do_irq(gpio);\r\nreturn worked ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void dwapb_configure_irqs(struct dwapb_gpio *gpio,\r\nstruct dwapb_gpio_port *port,\r\nstruct dwapb_port_property *pp)\r\n{\r\nstruct gpio_chip *gc = &port->gc;\r\nstruct fwnode_handle *fwnode = pp->fwnode;\r\nstruct irq_chip_generic *irq_gc = NULL;\r\nunsigned int hwirq, ngpio = gc->ngpio;\r\nstruct irq_chip_type *ct;\r\nint err, i;\r\ngpio->domain = irq_domain_create_linear(fwnode, ngpio,\r\n&irq_generic_chip_ops, gpio);\r\nif (!gpio->domain)\r\nreturn;\r\nerr = irq_alloc_domain_generic_chips(gpio->domain, ngpio, 2,\r\n"gpio-dwapb", handle_level_irq,\r\nIRQ_NOREQUEST, 0,\r\nIRQ_GC_INIT_NESTED_LOCK);\r\nif (err) {\r\ndev_info(gpio->dev, "irq_alloc_domain_generic_chips failed\n");\r\nirq_domain_remove(gpio->domain);\r\ngpio->domain = NULL;\r\nreturn;\r\n}\r\nirq_gc = irq_get_domain_generic_chip(gpio->domain, 0);\r\nif (!irq_gc) {\r\nirq_domain_remove(gpio->domain);\r\ngpio->domain = NULL;\r\nreturn;\r\n}\r\nirq_gc->reg_base = gpio->regs;\r\nirq_gc->private = gpio;\r\nfor (i = 0; i < 2; i++) {\r\nct = &irq_gc->chip_types[i];\r\nct->chip.irq_ack = irq_gc_ack_set_bit;\r\nct->chip.irq_mask = irq_gc_mask_set_bit;\r\nct->chip.irq_unmask = irq_gc_mask_clr_bit;\r\nct->chip.irq_set_type = dwapb_irq_set_type;\r\nct->chip.irq_enable = dwapb_irq_enable;\r\nct->chip.irq_disable = dwapb_irq_disable;\r\nct->chip.irq_request_resources = dwapb_irq_reqres;\r\nct->chip.irq_release_resources = dwapb_irq_relres;\r\nct->regs.ack = gpio_reg_convert(gpio, GPIO_PORTA_EOI);\r\nct->regs.mask = gpio_reg_convert(gpio, GPIO_INTMASK);\r\nct->type = IRQ_TYPE_LEVEL_MASK;\r\n}\r\nirq_gc->chip_types[0].type = IRQ_TYPE_LEVEL_MASK;\r\nirq_gc->chip_types[1].type = IRQ_TYPE_EDGE_BOTH;\r\nirq_gc->chip_types[1].handler = handle_edge_irq;\r\nif (!pp->irq_shared) {\r\nirq_set_chained_handler_and_data(pp->irq, dwapb_irq_handler,\r\ngpio);\r\n} else {\r\nerr = devm_request_irq(gpio->dev, pp->irq,\r\ndwapb_irq_handler_mfd,\r\nIRQF_SHARED, "gpio-dwapb-mfd", gpio);\r\nif (err) {\r\ndev_err(gpio->dev, "error requesting IRQ\n");\r\nirq_domain_remove(gpio->domain);\r\ngpio->domain = NULL;\r\nreturn;\r\n}\r\n}\r\nfor (hwirq = 0 ; hwirq < ngpio ; hwirq++)\r\nirq_create_mapping(gpio->domain, hwirq);\r\nport->gc.to_irq = dwapb_gpio_to_irq;\r\n}\r\nstatic void dwapb_irq_teardown(struct dwapb_gpio *gpio)\r\n{\r\nstruct dwapb_gpio_port *port = &gpio->ports[0];\r\nstruct gpio_chip *gc = &port->gc;\r\nunsigned int ngpio = gc->ngpio;\r\nirq_hw_number_t hwirq;\r\nif (!gpio->domain)\r\nreturn;\r\nfor (hwirq = 0 ; hwirq < ngpio ; hwirq++)\r\nirq_dispose_mapping(irq_find_mapping(gpio->domain, hwirq));\r\nirq_domain_remove(gpio->domain);\r\ngpio->domain = NULL;\r\n}\r\nstatic int dwapb_gpio_add_port(struct dwapb_gpio *gpio,\r\nstruct dwapb_port_property *pp,\r\nunsigned int offs)\r\n{\r\nstruct dwapb_gpio_port *port;\r\nvoid __iomem *dat, *set, *dirout;\r\nint err;\r\nport = &gpio->ports[offs];\r\nport->gpio = gpio;\r\nport->idx = pp->idx;\r\n#ifdef CONFIG_PM_SLEEP\r\nport->ctx = devm_kzalloc(gpio->dev, sizeof(*port->ctx), GFP_KERNEL);\r\nif (!port->ctx)\r\nreturn -ENOMEM;\r\n#endif\r\ndat = gpio->regs + GPIO_EXT_PORTA + (pp->idx * GPIO_EXT_PORT_SIZE);\r\nset = gpio->regs + GPIO_SWPORTA_DR + (pp->idx * GPIO_SWPORT_DR_SIZE);\r\ndirout = gpio->regs + GPIO_SWPORTA_DDR +\r\n(pp->idx * GPIO_SWPORT_DDR_SIZE);\r\nerr = bgpio_init(&port->gc, gpio->dev, 4, dat, set, NULL, dirout,\r\nNULL, false);\r\nif (err) {\r\ndev_err(gpio->dev, "failed to init gpio chip for port%d\n",\r\nport->idx);\r\nreturn err;\r\n}\r\n#ifdef CONFIG_OF_GPIO\r\nport->gc.of_node = to_of_node(pp->fwnode);\r\n#endif\r\nport->gc.ngpio = pp->ngpio;\r\nport->gc.base = pp->gpio_base;\r\nif (pp->idx == 0)\r\nport->gc.set_config = dwapb_gpio_set_config;\r\nif (pp->irq)\r\ndwapb_configure_irqs(gpio, port, pp);\r\nerr = gpiochip_add_data(&port->gc, port);\r\nif (err)\r\ndev_err(gpio->dev, "failed to register gpiochip for port%d\n",\r\nport->idx);\r\nelse\r\nport->is_registered = true;\r\nif (pp->irq)\r\nacpi_gpiochip_request_interrupts(&port->gc);\r\nreturn err;\r\n}\r\nstatic void dwapb_gpio_unregister(struct dwapb_gpio *gpio)\r\n{\r\nunsigned int m;\r\nfor (m = 0; m < gpio->nr_ports; ++m)\r\nif (gpio->ports[m].is_registered)\r\ngpiochip_remove(&gpio->ports[m].gc);\r\n}\r\nstatic struct dwapb_platform_data *\r\ndwapb_gpio_get_pdata(struct device *dev)\r\n{\r\nstruct fwnode_handle *fwnode;\r\nstruct dwapb_platform_data *pdata;\r\nstruct dwapb_port_property *pp;\r\nint nports;\r\nint i;\r\nnports = device_get_child_node_count(dev);\r\nif (nports == 0)\r\nreturn ERR_PTR(-ENODEV);\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\npdata->properties = devm_kcalloc(dev, nports, sizeof(*pp), GFP_KERNEL);\r\nif (!pdata->properties)\r\nreturn ERR_PTR(-ENOMEM);\r\npdata->nports = nports;\r\ni = 0;\r\ndevice_for_each_child_node(dev, fwnode) {\r\npp = &pdata->properties[i++];\r\npp->fwnode = fwnode;\r\nif (fwnode_property_read_u32(fwnode, "reg", &pp->idx) ||\r\npp->idx >= DWAPB_MAX_PORTS) {\r\ndev_err(dev,\r\n"missing/invalid port index for port%d\n", i);\r\nfwnode_handle_put(fwnode);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (fwnode_property_read_u32(fwnode, "snps,nr-gpios",\r\n&pp->ngpio)) {\r\ndev_info(dev,\r\n"failed to get number of gpios for port%d\n",\r\ni);\r\npp->ngpio = 32;\r\n}\r\nif (dev->of_node && pp->idx == 0 &&\r\nfwnode_property_read_bool(fwnode,\r\n"interrupt-controller")) {\r\npp->irq = irq_of_parse_and_map(to_of_node(fwnode), 0);\r\nif (!pp->irq)\r\ndev_warn(dev, "no irq for port%d\n", pp->idx);\r\n}\r\nif (has_acpi_companion(dev) && pp->idx == 0)\r\npp->irq = platform_get_irq(to_platform_device(dev), 0);\r\npp->irq_shared = false;\r\npp->gpio_base = -1;\r\n}\r\nreturn pdata;\r\n}\r\nstatic int dwapb_gpio_probe(struct platform_device *pdev)\r\n{\r\nunsigned int i;\r\nstruct resource *res;\r\nstruct dwapb_gpio *gpio;\r\nint err;\r\nstruct device *dev = &pdev->dev;\r\nstruct dwapb_platform_data *pdata = dev_get_platdata(dev);\r\nif (!pdata) {\r\npdata = dwapb_gpio_get_pdata(dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n}\r\nif (!pdata->nports)\r\nreturn -ENODEV;\r\ngpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);\r\nif (!gpio)\r\nreturn -ENOMEM;\r\ngpio->dev = &pdev->dev;\r\ngpio->nr_ports = pdata->nports;\r\ngpio->ports = devm_kcalloc(&pdev->dev, gpio->nr_ports,\r\nsizeof(*gpio->ports), GFP_KERNEL);\r\nif (!gpio->ports)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ngpio->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(gpio->regs))\r\nreturn PTR_ERR(gpio->regs);\r\ngpio->flags = 0;\r\nif (dev->of_node) {\r\nconst struct of_device_id *of_devid;\r\nof_devid = of_match_device(dwapb_of_match, dev);\r\nif (of_devid) {\r\nif (of_devid->data)\r\ngpio->flags = (uintptr_t)of_devid->data;\r\n}\r\n} else if (has_acpi_companion(dev)) {\r\nconst struct acpi_device_id *acpi_id;\r\nacpi_id = acpi_match_device(dwapb_acpi_match, dev);\r\nif (acpi_id) {\r\nif (acpi_id->driver_data)\r\ngpio->flags = acpi_id->driver_data;\r\n}\r\n}\r\nfor (i = 0; i < gpio->nr_ports; i++) {\r\nerr = dwapb_gpio_add_port(gpio, &pdata->properties[i], i);\r\nif (err)\r\ngoto out_unregister;\r\n}\r\nplatform_set_drvdata(pdev, gpio);\r\nreturn 0;\r\nout_unregister:\r\ndwapb_gpio_unregister(gpio);\r\ndwapb_irq_teardown(gpio);\r\nreturn err;\r\n}\r\nstatic int dwapb_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct dwapb_gpio *gpio = platform_get_drvdata(pdev);\r\ndwapb_gpio_unregister(gpio);\r\ndwapb_irq_teardown(gpio);\r\nreturn 0;\r\n}\r\nstatic int dwapb_gpio_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct dwapb_gpio *gpio = platform_get_drvdata(pdev);\r\nstruct gpio_chip *gc = &gpio->ports[0].gc;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&gc->bgpio_lock, flags);\r\nfor (i = 0; i < gpio->nr_ports; i++) {\r\nunsigned int offset;\r\nunsigned int idx = gpio->ports[i].idx;\r\nstruct dwapb_context *ctx = gpio->ports[i].ctx;\r\nBUG_ON(!ctx);\r\noffset = GPIO_SWPORTA_DDR + idx * GPIO_SWPORT_DDR_SIZE;\r\nctx->dir = dwapb_read(gpio, offset);\r\noffset = GPIO_SWPORTA_DR + idx * GPIO_SWPORT_DR_SIZE;\r\nctx->data = dwapb_read(gpio, offset);\r\noffset = GPIO_EXT_PORTA + idx * GPIO_EXT_PORT_SIZE;\r\nctx->ext = dwapb_read(gpio, offset);\r\nif (idx == 0) {\r\nctx->int_mask = dwapb_read(gpio, GPIO_INTMASK);\r\nctx->int_en = dwapb_read(gpio, GPIO_INTEN);\r\nctx->int_pol = dwapb_read(gpio, GPIO_INT_POLARITY);\r\nctx->int_type = dwapb_read(gpio, GPIO_INTTYPE_LEVEL);\r\nctx->int_deb = dwapb_read(gpio, GPIO_PORTA_DEBOUNCE);\r\ndwapb_write(gpio, GPIO_INTMASK, 0xffffffff);\r\n}\r\n}\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dwapb_gpio_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct dwapb_gpio *gpio = platform_get_drvdata(pdev);\r\nstruct gpio_chip *gc = &gpio->ports[0].gc;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&gc->bgpio_lock, flags);\r\nfor (i = 0; i < gpio->nr_ports; i++) {\r\nunsigned int offset;\r\nunsigned int idx = gpio->ports[i].idx;\r\nstruct dwapb_context *ctx = gpio->ports[i].ctx;\r\nBUG_ON(!ctx);\r\noffset = GPIO_SWPORTA_DR + idx * GPIO_SWPORT_DR_SIZE;\r\ndwapb_write(gpio, offset, ctx->data);\r\noffset = GPIO_SWPORTA_DDR + idx * GPIO_SWPORT_DDR_SIZE;\r\ndwapb_write(gpio, offset, ctx->dir);\r\noffset = GPIO_EXT_PORTA + idx * GPIO_EXT_PORT_SIZE;\r\ndwapb_write(gpio, offset, ctx->ext);\r\nif (idx == 0) {\r\ndwapb_write(gpio, GPIO_INTTYPE_LEVEL, ctx->int_type);\r\ndwapb_write(gpio, GPIO_INT_POLARITY, ctx->int_pol);\r\ndwapb_write(gpio, GPIO_PORTA_DEBOUNCE, ctx->int_deb);\r\ndwapb_write(gpio, GPIO_INTEN, ctx->int_en);\r\ndwapb_write(gpio, GPIO_INTMASK, ctx->int_mask);\r\ndwapb_write(gpio, GPIO_PORTA_EOI, 0xffffffff);\r\n}\r\n}\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\nreturn 0;\r\n}
