static inline u8 port100_checksum(u16 value)\r\n{\r\nreturn ~(((u8 *)&value)[0] + ((u8 *)&value)[1]) + 1;\r\n}\r\nstatic u8 port100_data_checksum(u8 *data, int datalen)\r\n{\r\nu8 sum = 0;\r\nint i;\r\nfor (i = 0; i < datalen; i++)\r\nsum += data[i];\r\nreturn port100_checksum(sum);\r\n}\r\nstatic void port100_tx_frame_init(void *_frame, u8 cmd_code)\r\n{\r\nstruct port100_frame *frame = _frame;\r\nframe->preamble = 0;\r\nframe->start_frame = cpu_to_be16(PORT100_FRAME_SOF);\r\nframe->extended_frame = cpu_to_be16(PORT100_FRAME_EXT);\r\nPORT100_FRAME_DIRECTION(frame) = PORT100_FRAME_DIR_OUT;\r\nPORT100_FRAME_CMD(frame) = cmd_code;\r\nframe->datalen = cpu_to_le16(2);\r\n}\r\nstatic void port100_tx_frame_finish(void *_frame)\r\n{\r\nstruct port100_frame *frame = _frame;\r\nframe->datalen_checksum = port100_checksum(le16_to_cpu(frame->datalen));\r\nPORT100_FRAME_CHECKSUM(frame) =\r\nport100_data_checksum(frame->data, le16_to_cpu(frame->datalen));\r\nPORT100_FRAME_POSTAMBLE(frame) = 0;\r\n}\r\nstatic void port100_tx_update_payload_len(void *_frame, int len)\r\n{\r\nstruct port100_frame *frame = _frame;\r\nframe->datalen = cpu_to_le16(le16_to_cpu(frame->datalen) + len);\r\n}\r\nstatic bool port100_rx_frame_is_valid(void *_frame)\r\n{\r\nu8 checksum;\r\nstruct port100_frame *frame = _frame;\r\nif (frame->start_frame != cpu_to_be16(PORT100_FRAME_SOF) ||\r\nframe->extended_frame != cpu_to_be16(PORT100_FRAME_EXT))\r\nreturn false;\r\nchecksum = port100_checksum(le16_to_cpu(frame->datalen));\r\nif (checksum != frame->datalen_checksum)\r\nreturn false;\r\nchecksum = port100_data_checksum(frame->data,\r\nle16_to_cpu(frame->datalen));\r\nif (checksum != PORT100_FRAME_CHECKSUM(frame))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool port100_rx_frame_is_ack(struct port100_ack_frame *frame)\r\n{\r\nreturn (frame->start_frame == cpu_to_be16(PORT100_FRAME_SOF) &&\r\nframe->ack_frame == cpu_to_be16(PORT100_FRAME_ACK));\r\n}\r\nstatic inline int port100_rx_frame_size(void *frame)\r\n{\r\nstruct port100_frame *f = frame;\r\nreturn sizeof(struct port100_frame) + le16_to_cpu(f->datalen) +\r\nPORT100_FRAME_TAIL_LEN;\r\n}\r\nstatic bool port100_rx_frame_is_cmd_response(struct port100 *dev, void *frame)\r\n{\r\nstruct port100_frame *f = frame;\r\nreturn (PORT100_FRAME_CMD(f) == PORT100_CMD_RESPONSE(dev->cmd->code));\r\n}\r\nstatic void port100_recv_response(struct urb *urb)\r\n{\r\nstruct port100 *dev = urb->context;\r\nstruct port100_cmd *cmd = dev->cmd;\r\nu8 *in_frame;\r\ncmd->status = urb->status;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\nnfc_err(&dev->interface->dev,\r\n"The urb has been canceled (status %d)\n", urb->status);\r\ngoto sched_wq;\r\ncase -ESHUTDOWN:\r\ndefault:\r\nnfc_err(&dev->interface->dev, "Urb failure (status %d)\n",\r\nurb->status);\r\ngoto sched_wq;\r\n}\r\nin_frame = dev->in_urb->transfer_buffer;\r\nif (!port100_rx_frame_is_valid(in_frame)) {\r\nnfc_err(&dev->interface->dev, "Received an invalid frame\n");\r\ncmd->status = -EIO;\r\ngoto sched_wq;\r\n}\r\nprint_hex_dump_debug("PORT100 RX: ", DUMP_PREFIX_NONE, 16, 1, in_frame,\r\nport100_rx_frame_size(in_frame), false);\r\nif (!port100_rx_frame_is_cmd_response(dev, in_frame)) {\r\nnfc_err(&dev->interface->dev,\r\n"It's not the response to the last command\n");\r\ncmd->status = -EIO;\r\ngoto sched_wq;\r\n}\r\nsched_wq:\r\nschedule_work(&dev->cmd_complete_work);\r\n}\r\nstatic int port100_submit_urb_for_response(struct port100 *dev, gfp_t flags)\r\n{\r\ndev->in_urb->complete = port100_recv_response;\r\nreturn usb_submit_urb(dev->in_urb, flags);\r\n}\r\nstatic void port100_recv_ack(struct urb *urb)\r\n{\r\nstruct port100 *dev = urb->context;\r\nstruct port100_cmd *cmd = dev->cmd;\r\nstruct port100_ack_frame *in_frame;\r\nint rc;\r\ncmd->status = urb->status;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\nnfc_err(&dev->interface->dev,\r\n"The urb has been stopped (status %d)\n", urb->status);\r\ngoto sched_wq;\r\ncase -ESHUTDOWN:\r\ndefault:\r\nnfc_err(&dev->interface->dev, "Urb failure (status %d)\n",\r\nurb->status);\r\ngoto sched_wq;\r\n}\r\nin_frame = dev->in_urb->transfer_buffer;\r\nif (!port100_rx_frame_is_ack(in_frame)) {\r\nnfc_err(&dev->interface->dev, "Received an invalid ack\n");\r\ncmd->status = -EIO;\r\ngoto sched_wq;\r\n}\r\nrc = port100_submit_urb_for_response(dev, GFP_ATOMIC);\r\nif (rc) {\r\nnfc_err(&dev->interface->dev,\r\n"usb_submit_urb failed with result %d\n", rc);\r\ncmd->status = rc;\r\ngoto sched_wq;\r\n}\r\nreturn;\r\nsched_wq:\r\nschedule_work(&dev->cmd_complete_work);\r\n}\r\nstatic int port100_submit_urb_for_ack(struct port100 *dev, gfp_t flags)\r\n{\r\ndev->in_urb->complete = port100_recv_ack;\r\nreturn usb_submit_urb(dev->in_urb, flags);\r\n}\r\nstatic int port100_send_ack(struct port100 *dev)\r\n{\r\nint rc = 0;\r\nmutex_lock(&dev->out_urb_lock);\r\nif (!dev->cmd_cancel) {\r\nreinit_completion(&dev->cmd_cancel_done);\r\nusb_kill_urb(dev->out_urb);\r\ndev->out_urb->transfer_buffer = ack_frame;\r\ndev->out_urb->transfer_buffer_length = sizeof(ack_frame);\r\nrc = usb_submit_urb(dev->out_urb, GFP_KERNEL);\r\ndev->cmd_cancel = !rc;\r\n}\r\nmutex_unlock(&dev->out_urb_lock);\r\nif (!rc)\r\nwait_for_completion(&dev->cmd_cancel_done);\r\nreturn rc;\r\n}\r\nstatic int port100_send_frame_async(struct port100 *dev, struct sk_buff *out,\r\nstruct sk_buff *in, int in_len)\r\n{\r\nint rc;\r\nmutex_lock(&dev->out_urb_lock);\r\nif (dev->cmd_cancel) {\r\nrc = -EAGAIN;\r\ngoto exit;\r\n}\r\ndev->out_urb->transfer_buffer = out->data;\r\ndev->out_urb->transfer_buffer_length = out->len;\r\ndev->in_urb->transfer_buffer = in->data;\r\ndev->in_urb->transfer_buffer_length = in_len;\r\nprint_hex_dump_debug("PORT100 TX: ", DUMP_PREFIX_NONE, 16, 1,\r\nout->data, out->len, false);\r\nrc = usb_submit_urb(dev->out_urb, GFP_KERNEL);\r\nif (rc)\r\ngoto exit;\r\nrc = port100_submit_urb_for_ack(dev, GFP_KERNEL);\r\nif (rc)\r\nusb_unlink_urb(dev->out_urb);\r\nexit:\r\nmutex_unlock(&dev->out_urb_lock);\r\nreturn rc;\r\n}\r\nstatic void port100_build_cmd_frame(struct port100 *dev, u8 cmd_code,\r\nstruct sk_buff *skb)\r\n{\r\nint payload_len = skb->len;\r\nskb_push(skb, PORT100_FRAME_HEADER_LEN);\r\nskb_put(skb, PORT100_FRAME_TAIL_LEN);\r\nport100_tx_frame_init(skb->data, cmd_code);\r\nport100_tx_update_payload_len(skb->data, payload_len);\r\nport100_tx_frame_finish(skb->data);\r\n}\r\nstatic void port100_send_async_complete(struct port100 *dev)\r\n{\r\nstruct port100_cmd *cmd = dev->cmd;\r\nint status = cmd->status;\r\nstruct sk_buff *req = cmd->req;\r\nstruct sk_buff *resp = cmd->resp;\r\ndev_kfree_skb(req);\r\ndev->cmd = NULL;\r\nif (status < 0) {\r\ncmd->complete_cb(dev, cmd->complete_cb_context,\r\nERR_PTR(status));\r\ndev_kfree_skb(resp);\r\ngoto done;\r\n}\r\nskb_put(resp, port100_rx_frame_size(resp->data));\r\nskb_pull(resp, PORT100_FRAME_HEADER_LEN);\r\nskb_trim(resp, resp->len - PORT100_FRAME_TAIL_LEN);\r\ncmd->complete_cb(dev, cmd->complete_cb_context, resp);\r\ndone:\r\nkfree(cmd);\r\n}\r\nstatic int port100_send_cmd_async(struct port100 *dev, u8 cmd_code,\r\nstruct sk_buff *req,\r\nport100_send_async_complete_t complete_cb,\r\nvoid *complete_cb_context)\r\n{\r\nstruct port100_cmd *cmd;\r\nstruct sk_buff *resp;\r\nint rc;\r\nint resp_len = PORT100_FRAME_HEADER_LEN +\r\nPORT100_FRAME_MAX_PAYLOAD_LEN +\r\nPORT100_FRAME_TAIL_LEN;\r\nif (dev->cmd) {\r\nnfc_err(&dev->interface->dev,\r\n"A command is still in process\n");\r\nreturn -EBUSY;\r\n}\r\nresp = alloc_skb(resp_len, GFP_KERNEL);\r\nif (!resp)\r\nreturn -ENOMEM;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (!cmd) {\r\ndev_kfree_skb(resp);\r\nreturn -ENOMEM;\r\n}\r\ncmd->code = cmd_code;\r\ncmd->req = req;\r\ncmd->resp = resp;\r\ncmd->resp_len = resp_len;\r\ncmd->complete_cb = complete_cb;\r\ncmd->complete_cb_context = complete_cb_context;\r\nport100_build_cmd_frame(dev, cmd_code, req);\r\ndev->cmd = cmd;\r\nrc = port100_send_frame_async(dev, req, resp, resp_len);\r\nif (rc) {\r\nkfree(cmd);\r\ndev_kfree_skb(resp);\r\ndev->cmd = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstatic void port100_wq_cmd_complete(struct work_struct *work)\r\n{\r\nstruct port100 *dev = container_of(work, struct port100,\r\ncmd_complete_work);\r\nport100_send_async_complete(dev);\r\n}\r\nstatic void port100_send_sync_complete(struct port100 *dev, void *_arg,\r\nstruct sk_buff *resp)\r\n{\r\nstruct port100_sync_cmd_response *arg = _arg;\r\narg->resp = resp;\r\ncomplete(&arg->done);\r\n}\r\nstatic struct sk_buff *port100_send_cmd_sync(struct port100 *dev, u8 cmd_code,\r\nstruct sk_buff *req)\r\n{\r\nint rc;\r\nstruct port100_sync_cmd_response arg;\r\ninit_completion(&arg.done);\r\nrc = port100_send_cmd_async(dev, cmd_code, req,\r\nport100_send_sync_complete, &arg);\r\nif (rc) {\r\ndev_kfree_skb(req);\r\nreturn ERR_PTR(rc);\r\n}\r\nwait_for_completion(&arg.done);\r\nreturn arg.resp;\r\n}\r\nstatic void port100_send_complete(struct urb *urb)\r\n{\r\nstruct port100 *dev = urb->context;\r\nif (dev->cmd_cancel) {\r\ncomplete_all(&dev->cmd_cancel_done);\r\ndev->cmd_cancel = false;\r\n}\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\nnfc_err(&dev->interface->dev,\r\n"The urb has been stopped (status %d)\n", urb->status);\r\nbreak;\r\ncase -ESHUTDOWN:\r\ndefault:\r\nnfc_err(&dev->interface->dev, "Urb failure (status %d)\n",\r\nurb->status);\r\n}\r\n}\r\nstatic void port100_abort_cmd(struct nfc_digital_dev *ddev)\r\n{\r\nstruct port100 *dev = nfc_digital_get_drvdata(ddev);\r\nport100_send_ack(dev);\r\nusb_kill_urb(dev->in_urb);\r\n}\r\nstatic struct sk_buff *port100_alloc_skb(struct port100 *dev, unsigned int size)\r\n{\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(dev->skb_headroom + dev->skb_tailroom + size,\r\nGFP_KERNEL);\r\nif (skb)\r\nskb_reserve(skb, dev->skb_headroom);\r\nreturn skb;\r\n}\r\nstatic int port100_set_command_type(struct port100 *dev, u8 command_type)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sk_buff *resp;\r\nint rc;\r\nskb = port100_alloc_skb(dev, 1);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_put_u8(skb, command_type);\r\nresp = port100_send_cmd_sync(dev, PORT100_CMD_SET_COMMAND_TYPE, skb);\r\nif (IS_ERR(resp))\r\nreturn PTR_ERR(resp);\r\nrc = resp->data[0];\r\ndev_kfree_skb(resp);\r\nreturn rc;\r\n}\r\nstatic u64 port100_get_command_type_mask(struct port100 *dev)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sk_buff *resp;\r\nu64 mask;\r\nskb = port100_alloc_skb(dev, 0);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nresp = port100_send_cmd_sync(dev, PORT100_CMD_GET_COMMAND_TYPE, skb);\r\nif (IS_ERR(resp))\r\nreturn PTR_ERR(resp);\r\nif (resp->len < 8)\r\nmask = 0;\r\nelse\r\nmask = be64_to_cpu(*(__be64 *)resp->data);\r\ndev_kfree_skb(resp);\r\nreturn mask;\r\n}\r\nstatic u16 port100_get_firmware_version(struct port100 *dev)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sk_buff *resp;\r\nu16 fw_ver;\r\nskb = port100_alloc_skb(dev, 0);\r\nif (!skb)\r\nreturn 0;\r\nresp = port100_send_cmd_sync(dev, PORT100_CMD_GET_FIRMWARE_VERSION,\r\nskb);\r\nif (IS_ERR(resp))\r\nreturn 0;\r\nfw_ver = le16_to_cpu(*(__le16 *)resp->data);\r\ndev_kfree_skb(resp);\r\nreturn fw_ver;\r\n}\r\nstatic int port100_switch_rf(struct nfc_digital_dev *ddev, bool on)\r\n{\r\nstruct port100 *dev = nfc_digital_get_drvdata(ddev);\r\nstruct sk_buff *skb, *resp;\r\nskb = port100_alloc_skb(dev, 1);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_put_u8(skb, on ? 1 : 0);\r\nif (!on)\r\nport100_abort_cmd(ddev);\r\nresp = port100_send_cmd_sync(dev, PORT100_CMD_SWITCH_RF, skb);\r\nif (IS_ERR(resp))\r\nreturn PTR_ERR(resp);\r\ndev_kfree_skb(resp);\r\nreturn 0;\r\n}\r\nstatic int port100_in_set_rf(struct nfc_digital_dev *ddev, u8 rf)\r\n{\r\nstruct port100 *dev = nfc_digital_get_drvdata(ddev);\r\nstruct sk_buff *skb;\r\nstruct sk_buff *resp;\r\nint rc;\r\nif (rf >= NFC_DIGITAL_RF_TECH_LAST)\r\nreturn -EINVAL;\r\nskb = port100_alloc_skb(dev, sizeof(struct port100_in_rf_setting));\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_put_data(skb, &in_rf_settings[rf],\r\nsizeof(struct port100_in_rf_setting));\r\nresp = port100_send_cmd_sync(dev, PORT100_CMD_IN_SET_RF, skb);\r\nif (IS_ERR(resp))\r\nreturn PTR_ERR(resp);\r\nrc = resp->data[0];\r\ndev_kfree_skb(resp);\r\nreturn rc;\r\n}\r\nstatic int port100_in_set_framing(struct nfc_digital_dev *ddev, int param)\r\n{\r\nstruct port100 *dev = nfc_digital_get_drvdata(ddev);\r\nstruct port100_protocol *protocols;\r\nstruct sk_buff *skb;\r\nstruct sk_buff *resp;\r\nint num_protocols;\r\nsize_t size;\r\nint rc;\r\nif (param >= NFC_DIGITAL_FRAMING_LAST)\r\nreturn -EINVAL;\r\nprotocols = in_protocols[param];\r\nnum_protocols = 0;\r\nwhile (protocols[num_protocols].number != PORT100_IN_PROT_END)\r\nnum_protocols++;\r\nif (!num_protocols)\r\nreturn 0;\r\nsize = sizeof(struct port100_protocol) * num_protocols;\r\nskb = port100_alloc_skb(dev, size);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_put_data(skb, protocols, size);\r\nresp = port100_send_cmd_sync(dev, PORT100_CMD_IN_SET_PROTOCOL, skb);\r\nif (IS_ERR(resp))\r\nreturn PTR_ERR(resp);\r\nrc = resp->data[0];\r\ndev_kfree_skb(resp);\r\nreturn rc;\r\n}\r\nstatic int port100_in_configure_hw(struct nfc_digital_dev *ddev, int type,\r\nint param)\r\n{\r\nif (type == NFC_DIGITAL_CONFIG_RF_TECH)\r\nreturn port100_in_set_rf(ddev, param);\r\nif (type == NFC_DIGITAL_CONFIG_FRAMING)\r\nreturn port100_in_set_framing(ddev, param);\r\nreturn -EINVAL;\r\n}\r\nstatic void port100_in_comm_rf_complete(struct port100 *dev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nstruct port100_cb_arg *cb_arg = arg;\r\nnfc_digital_cmd_complete_t cb = cb_arg->complete_cb;\r\nu32 status;\r\nint rc;\r\nif (IS_ERR(resp)) {\r\nrc = PTR_ERR(resp);\r\ngoto exit;\r\n}\r\nif (resp->len < 4) {\r\nnfc_err(&dev->interface->dev,\r\n"Invalid packet length received\n");\r\nrc = -EIO;\r\ngoto error;\r\n}\r\nstatus = le32_to_cpu(*(__le32 *)resp->data);\r\nskb_pull(resp, sizeof(u32));\r\nif (status == PORT100_CMD_STATUS_TIMEOUT) {\r\nrc = -ETIMEDOUT;\r\ngoto error;\r\n}\r\nif (status != PORT100_CMD_STATUS_OK) {\r\nnfc_err(&dev->interface->dev,\r\n"in_comm_rf failed with status 0x%08x\n", status);\r\nrc = -EIO;\r\ngoto error;\r\n}\r\nskb_pull(resp, 1);\r\ngoto exit;\r\nerror:\r\nkfree_skb(resp);\r\nresp = ERR_PTR(rc);\r\nexit:\r\ncb(dev->nfc_digital_dev, cb_arg->complete_arg, resp);\r\nkfree(cb_arg);\r\n}\r\nstatic int port100_in_send_cmd(struct nfc_digital_dev *ddev,\r\nstruct sk_buff *skb, u16 _timeout,\r\nnfc_digital_cmd_complete_t cb, void *arg)\r\n{\r\nstruct port100 *dev = nfc_digital_get_drvdata(ddev);\r\nstruct port100_cb_arg *cb_arg;\r\n__le16 timeout;\r\ncb_arg = kzalloc(sizeof(struct port100_cb_arg), GFP_KERNEL);\r\nif (!cb_arg)\r\nreturn -ENOMEM;\r\ncb_arg->complete_cb = cb;\r\ncb_arg->complete_arg = arg;\r\ntimeout = cpu_to_le16(_timeout * 10);\r\nmemcpy(skb_push(skb, sizeof(__le16)), &timeout, sizeof(__le16));\r\nreturn port100_send_cmd_async(dev, PORT100_CMD_IN_COMM_RF, skb,\r\nport100_in_comm_rf_complete, cb_arg);\r\n}\r\nstatic int port100_tg_set_rf(struct nfc_digital_dev *ddev, u8 rf)\r\n{\r\nstruct port100 *dev = nfc_digital_get_drvdata(ddev);\r\nstruct sk_buff *skb;\r\nstruct sk_buff *resp;\r\nint rc;\r\nif (rf >= NFC_DIGITAL_RF_TECH_LAST)\r\nreturn -EINVAL;\r\nskb = port100_alloc_skb(dev, sizeof(struct port100_tg_rf_setting));\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_put_data(skb, &tg_rf_settings[rf],\r\nsizeof(struct port100_tg_rf_setting));\r\nresp = port100_send_cmd_sync(dev, PORT100_CMD_TG_SET_RF, skb);\r\nif (IS_ERR(resp))\r\nreturn PTR_ERR(resp);\r\nrc = resp->data[0];\r\ndev_kfree_skb(resp);\r\nreturn rc;\r\n}\r\nstatic int port100_tg_set_framing(struct nfc_digital_dev *ddev, int param)\r\n{\r\nstruct port100 *dev = nfc_digital_get_drvdata(ddev);\r\nstruct port100_protocol *protocols;\r\nstruct sk_buff *skb;\r\nstruct sk_buff *resp;\r\nint rc;\r\nint num_protocols;\r\nsize_t size;\r\nif (param >= NFC_DIGITAL_FRAMING_LAST)\r\nreturn -EINVAL;\r\nprotocols = tg_protocols[param];\r\nnum_protocols = 0;\r\nwhile (protocols[num_protocols].number != PORT100_TG_PROT_END)\r\nnum_protocols++;\r\nif (!num_protocols)\r\nreturn 0;\r\nsize = sizeof(struct port100_protocol) * num_protocols;\r\nskb = port100_alloc_skb(dev, size);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_put_data(skb, protocols, size);\r\nresp = port100_send_cmd_sync(dev, PORT100_CMD_TG_SET_PROTOCOL, skb);\r\nif (IS_ERR(resp))\r\nreturn PTR_ERR(resp);\r\nrc = resp->data[0];\r\ndev_kfree_skb(resp);\r\nreturn rc;\r\n}\r\nstatic int port100_tg_configure_hw(struct nfc_digital_dev *ddev, int type,\r\nint param)\r\n{\r\nif (type == NFC_DIGITAL_CONFIG_RF_TECH)\r\nreturn port100_tg_set_rf(ddev, param);\r\nif (type == NFC_DIGITAL_CONFIG_FRAMING)\r\nreturn port100_tg_set_framing(ddev, param);\r\nreturn -EINVAL;\r\n}\r\nstatic bool port100_tg_target_activated(struct port100 *dev, u8 tgt_activated)\r\n{\r\nu8 mask;\r\nswitch (dev->cmd_type) {\r\ncase PORT100_CMD_TYPE_0:\r\nmask = PORT100_MDAA_TGT_HAS_BEEN_ACTIVATED_MASK;\r\nbreak;\r\ncase PORT100_CMD_TYPE_1:\r\nmask = PORT100_MDAA_TGT_HAS_BEEN_ACTIVATED_MASK |\r\nPORT100_MDAA_TGT_WAS_ACTIVATED_MASK;\r\nbreak;\r\ndefault:\r\nnfc_err(&dev->interface->dev, "Unknown command type\n");\r\nreturn false;\r\n}\r\nreturn ((tgt_activated & mask) == mask);\r\n}\r\nstatic void port100_tg_comm_rf_complete(struct port100 *dev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nu32 status;\r\nstruct port100_cb_arg *cb_arg = arg;\r\nnfc_digital_cmd_complete_t cb = cb_arg->complete_cb;\r\nstruct port100_tg_comm_rf_res *hdr;\r\nif (IS_ERR(resp))\r\ngoto exit;\r\nhdr = (struct port100_tg_comm_rf_res *)resp->data;\r\nstatus = le32_to_cpu(hdr->status);\r\nif (cb_arg->mdaa &&\r\n!port100_tg_target_activated(dev, hdr->target_activated)) {\r\nkfree_skb(resp);\r\nresp = ERR_PTR(-ETIMEDOUT);\r\ngoto exit;\r\n}\r\nskb_pull(resp, sizeof(struct port100_tg_comm_rf_res));\r\nif (status != PORT100_CMD_STATUS_OK) {\r\nkfree_skb(resp);\r\nif (status == PORT100_CMD_STATUS_TIMEOUT)\r\nresp = ERR_PTR(-ETIMEDOUT);\r\nelse\r\nresp = ERR_PTR(-EIO);\r\n}\r\nexit:\r\ncb(dev->nfc_digital_dev, cb_arg->complete_arg, resp);\r\nkfree(cb_arg);\r\n}\r\nstatic int port100_tg_send_cmd(struct nfc_digital_dev *ddev,\r\nstruct sk_buff *skb, u16 timeout,\r\nnfc_digital_cmd_complete_t cb, void *arg)\r\n{\r\nstruct port100 *dev = nfc_digital_get_drvdata(ddev);\r\nstruct port100_tg_comm_rf_cmd *hdr;\r\nstruct port100_cb_arg *cb_arg;\r\ncb_arg = kzalloc(sizeof(struct port100_cb_arg), GFP_KERNEL);\r\nif (!cb_arg)\r\nreturn -ENOMEM;\r\ncb_arg->complete_cb = cb;\r\ncb_arg->complete_arg = arg;\r\nskb_push(skb, sizeof(struct port100_tg_comm_rf_cmd));\r\nhdr = (struct port100_tg_comm_rf_cmd *)skb->data;\r\nmemset(hdr, 0, sizeof(struct port100_tg_comm_rf_cmd));\r\nhdr->guard_time = cpu_to_le16(500);\r\nhdr->send_timeout = cpu_to_le16(0xFFFF);\r\nhdr->recv_timeout = cpu_to_le16(timeout);\r\nreturn port100_send_cmd_async(dev, PORT100_CMD_TG_COMM_RF, skb,\r\nport100_tg_comm_rf_complete, cb_arg);\r\n}\r\nstatic int port100_listen_mdaa(struct nfc_digital_dev *ddev,\r\nstruct digital_tg_mdaa_params *params,\r\nu16 timeout,\r\nnfc_digital_cmd_complete_t cb, void *arg)\r\n{\r\nstruct port100 *dev = nfc_digital_get_drvdata(ddev);\r\nstruct port100_tg_comm_rf_cmd *hdr;\r\nstruct port100_cb_arg *cb_arg;\r\nstruct sk_buff *skb;\r\nint rc;\r\nrc = port100_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_RF_TECH,\r\nNFC_DIGITAL_RF_TECH_106A);\r\nif (rc)\r\nreturn rc;\r\nrc = port100_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\r\nNFC_DIGITAL_FRAMING_NFCA_NFC_DEP);\r\nif (rc)\r\nreturn rc;\r\ncb_arg = kzalloc(sizeof(struct port100_cb_arg), GFP_KERNEL);\r\nif (!cb_arg)\r\nreturn -ENOMEM;\r\ncb_arg->complete_cb = cb;\r\ncb_arg->complete_arg = arg;\r\ncb_arg->mdaa = 1;\r\nskb = port100_alloc_skb(dev, 0);\r\nif (!skb) {\r\nkfree(cb_arg);\r\nreturn -ENOMEM;\r\n}\r\nskb_push(skb, sizeof(struct port100_tg_comm_rf_cmd));\r\nhdr = (struct port100_tg_comm_rf_cmd *)skb->data;\r\nmemset(hdr, 0, sizeof(struct port100_tg_comm_rf_cmd));\r\nhdr->guard_time = 0;\r\nhdr->send_timeout = cpu_to_le16(0xFFFF);\r\nhdr->mdaa = 1;\r\nhdr->nfca_param[0] = (params->sens_res >> 8) & 0xFF;\r\nhdr->nfca_param[1] = params->sens_res & 0xFF;\r\nmemcpy(hdr->nfca_param + 2, params->nfcid1, 3);\r\nhdr->nfca_param[5] = params->sel_res;\r\nmemcpy(hdr->nfcf_param, params->nfcid2, 8);\r\nhdr->nfcf_param[16] = (params->sc >> 8) & 0xFF;\r\nhdr->nfcf_param[17] = params->sc & 0xFF;\r\nhdr->recv_timeout = cpu_to_le16(timeout);\r\nreturn port100_send_cmd_async(dev, PORT100_CMD_TG_COMM_RF, skb,\r\nport100_tg_comm_rf_complete, cb_arg);\r\n}\r\nstatic int port100_listen(struct nfc_digital_dev *ddev, u16 timeout,\r\nnfc_digital_cmd_complete_t cb, void *arg)\r\n{\r\nstruct port100 *dev = nfc_digital_get_drvdata(ddev);\r\nstruct sk_buff *skb;\r\nskb = port100_alloc_skb(dev, 0);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nreturn port100_tg_send_cmd(ddev, skb, timeout, cb, arg);\r\n}\r\nstatic int port100_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct port100 *dev;\r\nint rc;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint in_endpoint;\r\nint out_endpoint;\r\nu16 fw_version;\r\nu64 cmd_type_mask;\r\nint i;\r\ndev = devm_kzalloc(&interface->dev, sizeof(struct port100), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nmutex_init(&dev->out_urb_lock);\r\ndev->udev = usb_get_dev(interface_to_usbdev(interface));\r\ndev->interface = interface;\r\nusb_set_intfdata(interface, dev);\r\nin_endpoint = out_endpoint = 0;\r\niface_desc = interface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (!in_endpoint && usb_endpoint_is_bulk_in(endpoint))\r\nin_endpoint = endpoint->bEndpointAddress;\r\nif (!out_endpoint && usb_endpoint_is_bulk_out(endpoint))\r\nout_endpoint = endpoint->bEndpointAddress;\r\n}\r\nif (!in_endpoint || !out_endpoint) {\r\nnfc_err(&interface->dev,\r\n"Could not find bulk-in or bulk-out endpoint\n");\r\nrc = -ENODEV;\r\ngoto error;\r\n}\r\ndev->in_urb = usb_alloc_urb(0, GFP_KERNEL);\r\ndev->out_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->in_urb || !dev->out_urb) {\r\nnfc_err(&interface->dev, "Could not allocate USB URBs\n");\r\nrc = -ENOMEM;\r\ngoto error;\r\n}\r\nusb_fill_bulk_urb(dev->in_urb, dev->udev,\r\nusb_rcvbulkpipe(dev->udev, in_endpoint),\r\nNULL, 0, NULL, dev);\r\nusb_fill_bulk_urb(dev->out_urb, dev->udev,\r\nusb_sndbulkpipe(dev->udev, out_endpoint),\r\nNULL, 0, port100_send_complete, dev);\r\ndev->out_urb->transfer_flags = URB_ZERO_PACKET;\r\ndev->skb_headroom = PORT100_FRAME_HEADER_LEN +\r\nPORT100_COMM_RF_HEAD_MAX_LEN;\r\ndev->skb_tailroom = PORT100_FRAME_TAIL_LEN;\r\ninit_completion(&dev->cmd_cancel_done);\r\nINIT_WORK(&dev->cmd_complete_work, port100_wq_cmd_complete);\r\ncmd_type_mask = port100_get_command_type_mask(dev);\r\nif (!cmd_type_mask) {\r\nnfc_err(&interface->dev,\r\n"Could not get supported command types\n");\r\nrc = -ENODEV;\r\ngoto error;\r\n}\r\nif (PORT100_CMD_TYPE_IS_SUPPORTED(cmd_type_mask, PORT100_CMD_TYPE_1))\r\ndev->cmd_type = PORT100_CMD_TYPE_1;\r\nelse\r\ndev->cmd_type = PORT100_CMD_TYPE_0;\r\nrc = port100_set_command_type(dev, dev->cmd_type);\r\nif (rc) {\r\nnfc_err(&interface->dev,\r\n"The device does not support command type %u\n",\r\ndev->cmd_type);\r\ngoto error;\r\n}\r\nfw_version = port100_get_firmware_version(dev);\r\nif (!fw_version)\r\nnfc_err(&interface->dev,\r\n"Could not get device firmware version\n");\r\nnfc_info(&interface->dev,\r\n"Sony NFC Port-100 Series attached (firmware v%x.%02x)\n",\r\n(fw_version & 0xFF00) >> 8, fw_version & 0xFF);\r\ndev->nfc_digital_dev = nfc_digital_allocate_device(&port100_digital_ops,\r\nPORT100_PROTOCOLS,\r\nPORT100_CAPABILITIES,\r\ndev->skb_headroom,\r\ndev->skb_tailroom);\r\nif (!dev->nfc_digital_dev) {\r\nnfc_err(&interface->dev,\r\n"Could not allocate nfc_digital_dev\n");\r\nrc = -ENOMEM;\r\ngoto error;\r\n}\r\nnfc_digital_set_parent_dev(dev->nfc_digital_dev, &interface->dev);\r\nnfc_digital_set_drvdata(dev->nfc_digital_dev, dev);\r\nrc = nfc_digital_register_device(dev->nfc_digital_dev);\r\nif (rc) {\r\nnfc_err(&interface->dev,\r\n"Could not register digital device\n");\r\ngoto free_nfc_dev;\r\n}\r\nreturn 0;\r\nfree_nfc_dev:\r\nnfc_digital_free_device(dev->nfc_digital_dev);\r\nerror:\r\nusb_free_urb(dev->in_urb);\r\nusb_free_urb(dev->out_urb);\r\nusb_put_dev(dev->udev);\r\nreturn rc;\r\n}\r\nstatic void port100_disconnect(struct usb_interface *interface)\r\n{\r\nstruct port100 *dev;\r\ndev = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\nnfc_digital_unregister_device(dev->nfc_digital_dev);\r\nnfc_digital_free_device(dev->nfc_digital_dev);\r\nusb_kill_urb(dev->in_urb);\r\nusb_kill_urb(dev->out_urb);\r\nusb_free_urb(dev->in_urb);\r\nusb_free_urb(dev->out_urb);\r\nusb_put_dev(dev->udev);\r\nkfree(dev->cmd);\r\nnfc_info(&interface->dev, "Sony Port-100 NFC device disconnected\n");\r\n}
