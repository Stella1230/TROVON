static int tilcdc_external_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct tilcdc_drm_private *priv = connector->dev->dev_private;\r\nint ret;\r\nret = tilcdc_crtc_mode_valid(priv->crtc, mode);\r\nif (ret != MODE_OK)\r\nreturn ret;\r\nBUG_ON(priv->external_connector != connector);\r\nBUG_ON(!priv->connector_funcs);\r\nif (!IS_ERR(priv->connector_funcs) &&\r\npriv->connector_funcs->mode_valid)\r\nreturn priv->connector_funcs->mode_valid(connector, mode);\r\nreturn MODE_OK;\r\n}\r\nstatic int tilcdc_add_external_connector(struct drm_device *dev,\r\nstruct drm_connector *connector)\r\n{\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nstruct drm_connector_helper_funcs *connector_funcs;\r\nif (WARN_ON(priv->external_connector))\r\nreturn -EINVAL;\r\npriv->external_connector = connector;\r\nconnector_funcs = devm_kzalloc(dev->dev, sizeof(*connector_funcs),\r\nGFP_KERNEL);\r\nif (!connector_funcs)\r\nreturn -ENOMEM;\r\nif (connector->helper_private) {\r\npriv->connector_funcs = connector->helper_private;\r\n*connector_funcs = *priv->connector_funcs;\r\n} else {\r\npriv->connector_funcs = ERR_PTR(-ENOENT);\r\n}\r\nconnector_funcs->mode_valid = tilcdc_external_mode_valid;\r\ndrm_connector_helper_add(connector, connector_funcs);\r\ndev_dbg(dev->dev, "External connector '%s' connected\n",\r\nconnector->name);\r\nreturn 0;\r\n}\r\nstatic\r\nstruct drm_connector *tilcdc_encoder_find_connector(struct drm_device *ddev,\r\nstruct drm_encoder *encoder)\r\n{\r\nstruct drm_connector *connector;\r\nint i;\r\nlist_for_each_entry(connector, &ddev->mode_config.connector_list, head)\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++)\r\nif (connector->encoder_ids[i] == encoder->base.id)\r\nreturn connector;\r\ndev_err(ddev->dev, "No connector found for %s encoder (id %d)\n",\r\nencoder->name, encoder->base.id);\r\nreturn NULL;\r\n}\r\nint tilcdc_add_component_encoder(struct drm_device *ddev)\r\n{\r\nstruct tilcdc_drm_private *priv = ddev->dev_private;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nlist_for_each_entry(encoder, &ddev->mode_config.encoder_list, head)\r\nif (encoder->possible_crtcs & (1 << priv->crtc->index))\r\nbreak;\r\nif (!encoder) {\r\ndev_err(ddev->dev, "%s: No suitable encoder found\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nconnector = tilcdc_encoder_find_connector(ddev, encoder);\r\nif (!connector)\r\nreturn -ENODEV;\r\ntilcdc_crtc_set_simulate_vesa_sync(priv->crtc, true);\r\ntilcdc_crtc_set_panel_info(priv->crtc, &panel_info_tda998x);\r\nreturn tilcdc_add_external_connector(ddev, connector);\r\n}\r\nvoid tilcdc_remove_external_device(struct drm_device *dev)\r\n{\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nif (IS_ERR(priv->connector_funcs))\r\ndrm_connector_helper_add(priv->external_connector, NULL);\r\nelse if (priv->connector_funcs)\r\ndrm_connector_helper_add(priv->external_connector,\r\npriv->connector_funcs);\r\n}\r\nstatic\r\nint tilcdc_attach_bridge(struct drm_device *ddev, struct drm_bridge *bridge)\r\n{\r\nstruct tilcdc_drm_private *priv = ddev->dev_private;\r\nstruct drm_connector *connector;\r\nint ret;\r\npriv->external_encoder->possible_crtcs = BIT(0);\r\nret = drm_bridge_attach(priv->external_encoder, bridge, NULL);\r\nif (ret) {\r\ndev_err(ddev->dev, "drm_bridge_attach() failed %d\n", ret);\r\nreturn ret;\r\n}\r\ntilcdc_crtc_set_panel_info(priv->crtc, &panel_info_default);\r\nconnector = tilcdc_encoder_find_connector(ddev, priv->external_encoder);\r\nif (!connector)\r\nreturn -ENODEV;\r\nret = tilcdc_add_external_connector(ddev, connector);\r\nreturn ret;\r\n}\r\nint tilcdc_attach_external_device(struct drm_device *ddev)\r\n{\r\nstruct tilcdc_drm_private *priv = ddev->dev_private;\r\nstruct device_node *remote_node;\r\nstruct drm_bridge *bridge;\r\nint ret;\r\nremote_node = of_graph_get_remote_node(ddev->dev->of_node, 0, 0);\r\nif (!remote_node)\r\nreturn 0;\r\nbridge = of_drm_find_bridge(remote_node);\r\nof_node_put(remote_node);\r\nif (!bridge)\r\nreturn -EPROBE_DEFER;\r\npriv->external_encoder = devm_kzalloc(ddev->dev,\r\nsizeof(*priv->external_encoder),\r\nGFP_KERNEL);\r\nif (!priv->external_encoder)\r\nreturn -ENOMEM;\r\nret = drm_encoder_init(ddev, priv->external_encoder,\r\n&tilcdc_external_encoder_funcs,\r\nDRM_MODE_ENCODER_NONE, NULL);\r\nif (ret) {\r\ndev_err(ddev->dev, "drm_encoder_init() failed %d\n", ret);\r\nreturn ret;\r\n}\r\nret = tilcdc_attach_bridge(ddev, bridge);\r\nif (ret)\r\ndrm_encoder_cleanup(priv->external_encoder);\r\nreturn ret;\r\n}\r\nstatic int dev_match_of(struct device *dev, void *data)\r\n{\r\nreturn dev->of_node == data;\r\n}\r\nint tilcdc_get_external_components(struct device *dev,\r\nstruct component_match **match)\r\n{\r\nstruct device_node *node;\r\nnode = of_graph_get_remote_node(dev->of_node, 0, 0);\r\nif (!of_device_is_compatible(node, "nxp,tda998x")) {\r\nof_node_put(node);\r\nreturn 0;\r\n}\r\nif (match)\r\ndrm_of_component_match_add(dev, match, dev_match_of, node);\r\nof_node_put(node);\r\nreturn 1;\r\n}
