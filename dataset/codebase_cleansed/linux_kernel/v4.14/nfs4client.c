static int nfs_get_cb_ident_idr(struct nfs_client *clp, int minorversion)\r\n{\r\nint ret = 0;\r\nstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\r\nif (clp->rpc_ops->version != 4 || minorversion != 0)\r\nreturn ret;\r\nidr_preload(GFP_KERNEL);\r\nspin_lock(&nn->nfs_client_lock);\r\nret = idr_alloc(&nn->cb_ident_idr, clp, 1, 0, GFP_NOWAIT);\r\nif (ret >= 0)\r\nclp->cl_cb_ident = ret;\r\nspin_unlock(&nn->nfs_client_lock);\r\nidr_preload_end();\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic struct nfs4_ds_server *\r\nnfs4_find_ds_client(struct nfs_client *ds_clp, rpc_authflavor_t flavor)\r\n{\r\nstruct nfs4_ds_server *dss;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(dss, &ds_clp->cl_ds_clients, list) {\r\nif (dss->rpc_clnt->cl_auth->au_flavor != flavor)\r\ncontinue;\r\ngoto out;\r\n}\r\ndss = NULL;\r\nout:\r\nrcu_read_unlock();\r\nreturn dss;\r\n}\r\nstatic struct nfs4_ds_server *\r\nnfs4_add_ds_client(struct nfs_client *ds_clp, rpc_authflavor_t flavor,\r\nstruct nfs4_ds_server *new)\r\n{\r\nstruct nfs4_ds_server *dss;\r\nspin_lock(&ds_clp->cl_lock);\r\nlist_for_each_entry(dss, &ds_clp->cl_ds_clients, list) {\r\nif (dss->rpc_clnt->cl_auth->au_flavor != flavor)\r\ncontinue;\r\ngoto out;\r\n}\r\nif (new)\r\nlist_add_rcu(&new->list, &ds_clp->cl_ds_clients);\r\ndss = new;\r\nout:\r\nspin_unlock(&ds_clp->cl_lock);\r\nreturn dss;\r\n}\r\nstatic struct nfs4_ds_server *\r\nnfs4_alloc_ds_server(struct nfs_client *ds_clp, rpc_authflavor_t flavor)\r\n{\r\nstruct nfs4_ds_server *dss;\r\ndss = kmalloc(sizeof(*dss), GFP_NOFS);\r\nif (dss == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\ndss->rpc_clnt = rpc_clone_client_set_auth(ds_clp->cl_rpcclient, flavor);\r\nif (IS_ERR(dss->rpc_clnt)) {\r\nint err = PTR_ERR(dss->rpc_clnt);\r\nkfree (dss);\r\nreturn ERR_PTR(err);\r\n}\r\nINIT_LIST_HEAD(&dss->list);\r\nreturn dss;\r\n}\r\nstatic void\r\nnfs4_free_ds_server(struct nfs4_ds_server *dss)\r\n{\r\nrpc_release_client(dss->rpc_clnt);\r\nkfree(dss);\r\n}\r\nstruct rpc_clnt *\r\nnfs4_find_or_create_ds_client(struct nfs_client *ds_clp, struct inode *inode)\r\n{\r\nstruct nfs4_ds_server *dss, *new;\r\nrpc_authflavor_t flavor = NFS_SERVER(inode)->client->cl_auth->au_flavor;\r\ndss = nfs4_find_ds_client(ds_clp, flavor);\r\nif (dss != NULL)\r\ngoto out;\r\nnew = nfs4_alloc_ds_server(ds_clp, flavor);\r\nif (IS_ERR(new))\r\nreturn ERR_CAST(new);\r\ndss = nfs4_add_ds_client(ds_clp, flavor, new);\r\nif (dss != new)\r\nnfs4_free_ds_server(new);\r\nout:\r\nreturn dss->rpc_clnt;\r\n}\r\nstatic void\r\nnfs4_shutdown_ds_clients(struct nfs_client *clp)\r\n{\r\nstruct nfs4_ds_server *dss;\r\nLIST_HEAD(shutdown_list);\r\nwhile (!list_empty(&clp->cl_ds_clients)) {\r\ndss = list_entry(clp->cl_ds_clients.next,\r\nstruct nfs4_ds_server, list);\r\nlist_del(&dss->list);\r\nrpc_shutdown_client(dss->rpc_clnt);\r\nkfree (dss);\r\n}\r\n}\r\nvoid nfs41_shutdown_client(struct nfs_client *clp)\r\n{\r\nif (nfs4_has_session(clp)) {\r\nnfs4_shutdown_ds_clients(clp);\r\nnfs4_destroy_session(clp->cl_session);\r\nnfs4_destroy_clientid(clp);\r\n}\r\n}\r\nvoid nfs40_shutdown_client(struct nfs_client *clp)\r\n{\r\nif (clp->cl_slot_tbl) {\r\nnfs4_shutdown_slot_table(clp->cl_slot_tbl);\r\nkfree(clp->cl_slot_tbl);\r\n}\r\n}\r\nstruct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *cl_init)\r\n{\r\nint err;\r\nstruct nfs_client *clp = nfs_alloc_client(cl_init);\r\nif (IS_ERR(clp))\r\nreturn clp;\r\nerr = nfs_get_cb_ident_idr(clp, cl_init->minorversion);\r\nif (err)\r\ngoto error;\r\nif (cl_init->minorversion > NFS4_MAX_MINOR_VERSION) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nspin_lock_init(&clp->cl_lock);\r\nINIT_DELAYED_WORK(&clp->cl_renewd, nfs4_renew_state);\r\nINIT_LIST_HEAD(&clp->cl_ds_clients);\r\nrpc_init_wait_queue(&clp->cl_rpcwaitq, "NFS client");\r\nclp->cl_state = 1 << NFS4CLNT_LEASE_EXPIRED;\r\nclp->cl_minorversion = cl_init->minorversion;\r\nclp->cl_mvops = nfs_v4_minor_ops[cl_init->minorversion];\r\nclp->cl_mig_gen = 1;\r\n#if IS_ENABLED(CONFIG_NFS_V4_1)\r\ninit_waitqueue_head(&clp->cl_lock_waitq);\r\n#endif\r\nreturn clp;\r\nerror:\r\nnfs_free_client(clp);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void nfs4_destroy_callback(struct nfs_client *clp)\r\n{\r\nif (__test_and_clear_bit(NFS_CS_CALLBACK, &clp->cl_res_state))\r\nnfs_callback_down(clp->cl_mvops->minor_version, clp->cl_net);\r\n}\r\nstatic void nfs4_shutdown_client(struct nfs_client *clp)\r\n{\r\nif (__test_and_clear_bit(NFS_CS_RENEWD, &clp->cl_res_state))\r\nnfs4_kill_renewd(clp);\r\nclp->cl_mvops->shutdown_client(clp);\r\nnfs4_destroy_callback(clp);\r\nif (__test_and_clear_bit(NFS_CS_IDMAP, &clp->cl_res_state))\r\nnfs_idmap_delete(clp);\r\nrpc_destroy_wait_queue(&clp->cl_rpcwaitq);\r\nkfree(clp->cl_serverowner);\r\nkfree(clp->cl_serverscope);\r\nkfree(clp->cl_implid);\r\nkfree(clp->cl_owner_id);\r\n}\r\nvoid nfs4_free_client(struct nfs_client *clp)\r\n{\r\nnfs4_shutdown_client(clp);\r\nnfs_free_client(clp);\r\n}\r\nstatic int nfs4_init_callback(struct nfs_client *clp)\r\n{\r\nstruct rpc_xprt *xprt;\r\nint error;\r\nxprt = rcu_dereference_raw(clp->cl_rpcclient->cl_xprt);\r\nif (nfs4_has_session(clp)) {\r\nerror = xprt_setup_backchannel(xprt, NFS41_BC_MIN_CALLBACKS);\r\nif (error < 0)\r\nreturn error;\r\n}\r\nerror = nfs_callback_up(clp->cl_mvops->minor_version, xprt);\r\nif (error < 0) {\r\ndprintk("%s: failed to start callback. Error = %d\n",\r\n__func__, error);\r\nreturn error;\r\n}\r\n__set_bit(NFS_CS_CALLBACK, &clp->cl_res_state);\r\nreturn 0;\r\n}\r\nint nfs40_init_client(struct nfs_client *clp)\r\n{\r\nstruct nfs4_slot_table *tbl;\r\nint ret;\r\ntbl = kzalloc(sizeof(*tbl), GFP_NOFS);\r\nif (tbl == NULL)\r\nreturn -ENOMEM;\r\nret = nfs4_setup_slot_table(tbl, NFS4_MAX_SLOT_TABLE,\r\n"NFSv4.0 transport Slot table");\r\nif (ret) {\r\nkfree(tbl);\r\nreturn ret;\r\n}\r\nclp->cl_slot_tbl = tbl;\r\nreturn 0;\r\n}\r\nint nfs41_init_client(struct nfs_client *clp)\r\n{\r\nstruct nfs4_session *session = NULL;\r\nsession = nfs4_alloc_session(clp);\r\nif (!session)\r\nreturn -ENOMEM;\r\nclp->cl_session = session;\r\nnfs_mark_client_ready(clp, NFS_CS_SESSION_INITING);\r\nreturn 0;\r\n}\r\nstatic int nfs4_init_client_minor_version(struct nfs_client *clp)\r\n{\r\nint ret;\r\nret = clp->cl_mvops->init_client(clp);\r\nif (ret)\r\nreturn ret;\r\nreturn nfs4_init_callback(clp);\r\n}\r\nstruct nfs_client *nfs4_init_client(struct nfs_client *clp,\r\nconst struct nfs_client_initdata *cl_init)\r\n{\r\nchar buf[INET6_ADDRSTRLEN + 1];\r\nconst char *ip_addr = cl_init->ip_addr;\r\nstruct nfs_client *old;\r\nint error;\r\nif (clp->cl_cons_state == NFS_CS_READY)\r\nreturn clp;\r\nclp->rpc_ops = &nfs_v4_clientops;\r\nif (clp->cl_minorversion != 0)\r\n__set_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags);\r\n__set_bit(NFS_CS_DISCRTRY, &clp->cl_flags);\r\n__set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags);\r\nerror = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_GSS_KRB5I);\r\nif (error == -EINVAL)\r\nerror = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_UNIX);\r\nif (error < 0)\r\ngoto error;\r\nif (ip_addr == NULL) {\r\nstruct sockaddr_storage cb_addr;\r\nstruct sockaddr *sap = (struct sockaddr *)&cb_addr;\r\nerror = rpc_localaddr(clp->cl_rpcclient, sap, sizeof(cb_addr));\r\nif (error < 0)\r\ngoto error;\r\nerror = rpc_ntop(sap, buf, sizeof(buf));\r\nif (error < 0)\r\ngoto error;\r\nip_addr = (const char *)buf;\r\n}\r\nstrlcpy(clp->cl_ipaddr, ip_addr, sizeof(clp->cl_ipaddr));\r\nerror = nfs_idmap_new(clp);\r\nif (error < 0) {\r\ndprintk("%s: failed to create idmapper. Error = %d\n",\r\n__func__, error);\r\ngoto error;\r\n}\r\n__set_bit(NFS_CS_IDMAP, &clp->cl_res_state);\r\nerror = nfs4_init_client_minor_version(clp);\r\nif (error < 0)\r\ngoto error;\r\nif (!nfs4_has_session(clp))\r\nnfs_mark_client_ready(clp, NFS_CS_READY);\r\nerror = nfs4_discover_server_trunking(clp, &old);\r\nif (error < 0)\r\ngoto error;\r\nif (clp != old)\r\nclp->cl_preserve_clid = true;\r\nnfs_put_client(clp);\r\nclear_bit(NFS_CS_TSM_POSSIBLE, &clp->cl_flags);\r\nreturn old;\r\nerror:\r\nnfs_mark_client_ready(clp, error);\r\nnfs_put_client(clp);\r\nreturn ERR_PTR(error);\r\n}\r\nstatic void nfs4_swap_callback_idents(struct nfs_client *keep,\r\nstruct nfs_client *drop)\r\n{\r\nstruct nfs_net *nn = net_generic(keep->cl_net, nfs_net_id);\r\nunsigned int save = keep->cl_cb_ident;\r\nif (keep->cl_cb_ident == drop->cl_cb_ident)\r\nreturn;\r\ndprintk("%s: keeping callback ident %u and dropping ident %u\n",\r\n__func__, keep->cl_cb_ident, drop->cl_cb_ident);\r\nspin_lock(&nn->nfs_client_lock);\r\nidr_replace(&nn->cb_ident_idr, keep, drop->cl_cb_ident);\r\nkeep->cl_cb_ident = drop->cl_cb_ident;\r\nidr_replace(&nn->cb_ident_idr, drop, save);\r\ndrop->cl_cb_ident = save;\r\nspin_unlock(&nn->nfs_client_lock);\r\n}\r\nstatic bool nfs4_match_client_owner_id(const struct nfs_client *clp1,\r\nconst struct nfs_client *clp2)\r\n{\r\nif (clp1->cl_owner_id == NULL || clp2->cl_owner_id == NULL)\r\nreturn true;\r\nreturn strcmp(clp1->cl_owner_id, clp2->cl_owner_id) == 0;\r\n}\r\nstatic bool nfs4_same_verifier(nfs4_verifier *v1, nfs4_verifier *v2)\r\n{\r\nreturn memcmp(v1->data, v2->data, sizeof(v1->data)) == 0;\r\n}\r\nstatic int nfs4_match_client(struct nfs_client *pos, struct nfs_client *new,\r\nstruct nfs_client **prev, struct nfs_net *nn)\r\n{\r\nint status;\r\nif (pos->rpc_ops != new->rpc_ops)\r\nreturn 1;\r\nif (pos->cl_minorversion != new->cl_minorversion)\r\nreturn 1;\r\nif (pos->cl_cons_state > NFS_CS_READY) {\r\natomic_inc(&pos->cl_count);\r\nspin_unlock(&nn->nfs_client_lock);\r\nnfs_put_client(*prev);\r\n*prev = pos;\r\nstatus = nfs_wait_client_init_complete(pos);\r\nspin_lock(&nn->nfs_client_lock);\r\nif (status < 0)\r\nreturn status;\r\n}\r\nif (pos->cl_cons_state != NFS_CS_READY)\r\nreturn 1;\r\nif (pos->cl_clientid != new->cl_clientid)\r\nreturn 1;\r\nif (!nfs4_match_client_owner_id(pos, new))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint nfs40_walk_client_list(struct nfs_client *new,\r\nstruct nfs_client **result,\r\nstruct rpc_cred *cred)\r\n{\r\nstruct nfs_net *nn = net_generic(new->cl_net, nfs_net_id);\r\nstruct nfs_client *pos, *prev = NULL;\r\nstruct nfs4_setclientid_res clid = {\r\n.clientid = new->cl_clientid,\r\n.confirm = new->cl_confirm,\r\n};\r\nint status = -NFS4ERR_STALE_CLIENTID;\r\nspin_lock(&nn->nfs_client_lock);\r\nlist_for_each_entry(pos, &nn->nfs_client_list, cl_share_link) {\r\nstatus = nfs4_match_client(pos, new, &prev, nn);\r\nif (status < 0)\r\ngoto out_unlock;\r\nif (status != 0)\r\ncontinue;\r\nif ((new != pos) && nfs4_same_verifier(&pos->cl_confirm,\r\n&new->cl_confirm))\r\ncontinue;\r\natomic_inc(&pos->cl_count);\r\nspin_unlock(&nn->nfs_client_lock);\r\nnfs_put_client(prev);\r\nprev = pos;\r\nstatus = nfs4_proc_setclientid_confirm(pos, &clid, cred);\r\nswitch (status) {\r\ncase -NFS4ERR_STALE_CLIENTID:\r\nbreak;\r\ncase 0:\r\nnfs4_swap_callback_idents(pos, new);\r\npos->cl_confirm = new->cl_confirm;\r\nprev = NULL;\r\n*result = pos;\r\ngoto out;\r\ncase -ERESTARTSYS:\r\ncase -ETIMEDOUT:\r\nnfs4_schedule_path_down_recovery(pos);\r\ndefault:\r\ngoto out;\r\n}\r\nspin_lock(&nn->nfs_client_lock);\r\n}\r\nout_unlock:\r\nspin_unlock(&nn->nfs_client_lock);\r\nout:\r\nnfs_put_client(prev);\r\nreturn status;\r\n}\r\nstatic bool\r\nnfs4_check_serverowner_major_id(struct nfs41_server_owner *o1,\r\nstruct nfs41_server_owner *o2)\r\n{\r\nif (o1->major_id_sz != o2->major_id_sz)\r\nreturn false;\r\nreturn memcmp(o1->major_id, o2->major_id, o1->major_id_sz) == 0;\r\n}\r\nstatic bool\r\nnfs4_check_server_scope(struct nfs41_server_scope *s1,\r\nstruct nfs41_server_scope *s2)\r\n{\r\nif (s1->server_scope_sz != s2->server_scope_sz)\r\nreturn false;\r\nreturn memcmp(s1->server_scope, s2->server_scope,\r\ns1->server_scope_sz) == 0;\r\n}\r\nint nfs4_detect_session_trunking(struct nfs_client *clp,\r\nstruct nfs41_exchange_id_res *res,\r\nstruct rpc_xprt *xprt)\r\n{\r\nif (clp->cl_clientid != res->clientid)\r\ngoto out_err;\r\nif (!nfs4_check_serverowner_major_id(clp->cl_serverowner,\r\nres->server_owner))\r\ngoto out_err;\r\nif (clp->cl_serverowner->minor_id != res->server_owner->minor_id)\r\ngoto out_err;\r\nif (!nfs4_check_server_scope(clp->cl_serverscope, res->server_scope))\r\ngoto out_err;\r\npr_info("NFS: %s: Session trunking succeeded for %s\n",\r\nclp->cl_hostname,\r\nxprt->address_strings[RPC_DISPLAY_ADDR]);\r\nreturn 0;\r\nout_err:\r\npr_info("NFS: %s: Session trunking failed for %s\n", clp->cl_hostname,\r\nxprt->address_strings[RPC_DISPLAY_ADDR]);\r\nreturn -EINVAL;\r\n}\r\nint nfs41_walk_client_list(struct nfs_client *new,\r\nstruct nfs_client **result,\r\nstruct rpc_cred *cred)\r\n{\r\nstruct nfs_net *nn = net_generic(new->cl_net, nfs_net_id);\r\nstruct nfs_client *pos, *prev = NULL;\r\nint status = -NFS4ERR_STALE_CLIENTID;\r\nspin_lock(&nn->nfs_client_lock);\r\nlist_for_each_entry(pos, &nn->nfs_client_list, cl_share_link) {\r\nif (pos == new)\r\ngoto found;\r\nstatus = nfs4_match_client(pos, new, &prev, nn);\r\nif (status < 0)\r\ngoto out;\r\nif (status != 0)\r\ncontinue;\r\nif (!nfs4_check_serverowner_major_id(pos->cl_serverowner,\r\nnew->cl_serverowner))\r\ncontinue;\r\nfound:\r\natomic_inc(&pos->cl_count);\r\n*result = pos;\r\nstatus = 0;\r\nbreak;\r\n}\r\nout:\r\nspin_unlock(&nn->nfs_client_lock);\r\nnfs_put_client(prev);\r\nreturn status;\r\n}\r\nstatic void nfs4_destroy_server(struct nfs_server *server)\r\n{\r\nnfs_server_return_all_delegations(server);\r\nunset_pnfs_layoutdriver(server);\r\nnfs4_purge_state_owners(server);\r\n}\r\nstruct nfs_client *\r\nnfs4_find_client_ident(struct net *net, int cb_ident)\r\n{\r\nstruct nfs_client *clp;\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nspin_lock(&nn->nfs_client_lock);\r\nclp = idr_find(&nn->cb_ident_idr, cb_ident);\r\nif (clp)\r\natomic_inc(&clp->cl_count);\r\nspin_unlock(&nn->nfs_client_lock);\r\nreturn clp;\r\n}\r\nstatic bool nfs4_cb_match_client(const struct sockaddr *addr,\r\nstruct nfs_client *clp, u32 minorversion)\r\n{\r\nstruct sockaddr *clap = (struct sockaddr *)&clp->cl_addr;\r\nif (!(clp->cl_cons_state == NFS_CS_READY ||\r\nclp->cl_cons_state == NFS_CS_SESSION_INITING))\r\nreturn false;\r\nsmp_rmb();\r\nif (clp->rpc_ops->version != 4 ||\r\nclp->cl_minorversion != minorversion)\r\nreturn false;\r\nreturn rpc_cmp_addr(addr, clap);\r\n}\r\nstruct nfs_client *\r\nnfs4_find_client_sessionid(struct net *net, const struct sockaddr *addr,\r\nstruct nfs4_sessionid *sid, u32 minorversion)\r\n{\r\nstruct nfs_client *clp;\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nspin_lock(&nn->nfs_client_lock);\r\nlist_for_each_entry(clp, &nn->nfs_client_list, cl_share_link) {\r\nif (nfs4_cb_match_client(addr, clp, minorversion) == false)\r\ncontinue;\r\nif (!nfs4_has_session(clp))\r\ncontinue;\r\nif (memcmp(clp->cl_session->sess_id.data,\r\nsid->data, NFS4_MAX_SESSIONID_LEN) != 0)\r\ncontinue;\r\natomic_inc(&clp->cl_count);\r\nspin_unlock(&nn->nfs_client_lock);\r\nreturn clp;\r\n}\r\nspin_unlock(&nn->nfs_client_lock);\r\nreturn NULL;\r\n}\r\nstruct nfs_client *\r\nnfs4_find_client_sessionid(struct net *net, const struct sockaddr *addr,\r\nstruct nfs4_sessionid *sid, u32 minorversion)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int nfs4_set_client(struct nfs_server *server,\r\nconst char *hostname,\r\nconst struct sockaddr *addr,\r\nconst size_t addrlen,\r\nconst char *ip_addr,\r\nint proto, const struct rpc_timeout *timeparms,\r\nu32 minorversion, struct net *net)\r\n{\r\nstruct nfs_client_initdata cl_init = {\r\n.hostname = hostname,\r\n.addr = addr,\r\n.addrlen = addrlen,\r\n.ip_addr = ip_addr,\r\n.nfs_mod = &nfs_v4,\r\n.proto = proto,\r\n.minorversion = minorversion,\r\n.net = net,\r\n.timeparms = timeparms,\r\n};\r\nstruct nfs_client *clp;\r\nif (server->flags & NFS_MOUNT_NORESVPORT)\r\nset_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);\r\nif (server->options & NFS_OPTION_MIGRATION)\r\nset_bit(NFS_CS_MIGRATION, &cl_init.init_flags);\r\nif (test_bit(NFS_MIG_TSM_POSSIBLE, &server->mig_status))\r\nset_bit(NFS_CS_TSM_POSSIBLE, &cl_init.init_flags);\r\nclp = nfs_get_client(&cl_init);\r\nif (IS_ERR(clp))\r\nreturn PTR_ERR(clp);\r\nif (server->nfs_client == clp)\r\nreturn -ELOOP;\r\nset_bit(NFS_CS_CHECK_LEASE_TIME, &clp->cl_res_state);\r\nserver->nfs_client = clp;\r\nreturn 0;\r\n}\r\nstruct nfs_client *nfs4_set_ds_client(struct nfs_server *mds_srv,\r\nconst struct sockaddr *ds_addr, int ds_addrlen,\r\nint ds_proto, unsigned int ds_timeo, unsigned int ds_retrans,\r\nu32 minor_version)\r\n{\r\nstruct rpc_timeout ds_timeout;\r\nstruct nfs_client *mds_clp = mds_srv->nfs_client;\r\nstruct nfs_client_initdata cl_init = {\r\n.addr = ds_addr,\r\n.addrlen = ds_addrlen,\r\n.nodename = mds_clp->cl_rpcclient->cl_nodename,\r\n.ip_addr = mds_clp->cl_ipaddr,\r\n.nfs_mod = &nfs_v4,\r\n.proto = ds_proto,\r\n.minorversion = minor_version,\r\n.net = mds_clp->cl_net,\r\n.timeparms = &ds_timeout,\r\n};\r\nchar buf[INET6_ADDRSTRLEN + 1];\r\nif (rpc_ntop(ds_addr, buf, sizeof(buf)) <= 0)\r\nreturn ERR_PTR(-EINVAL);\r\ncl_init.hostname = buf;\r\nif (mds_srv->flags & NFS_MOUNT_NORESVPORT)\r\n__set_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);\r\nnfs_init_timeout_values(&ds_timeout, ds_proto, ds_timeo, ds_retrans);\r\nreturn nfs_get_client(&cl_init);\r\n}\r\nstatic void nfs4_session_set_rwsize(struct nfs_server *server)\r\n{\r\n#ifdef CONFIG_NFS_V4_1\r\nstruct nfs4_session *sess;\r\nu32 server_resp_sz;\r\nu32 server_rqst_sz;\r\nif (!nfs4_has_session(server->nfs_client))\r\nreturn;\r\nsess = server->nfs_client->cl_session;\r\nserver_resp_sz = sess->fc_attrs.max_resp_sz - nfs41_maxread_overhead;\r\nserver_rqst_sz = sess->fc_attrs.max_rqst_sz - nfs41_maxwrite_overhead;\r\nif (!server->rsize || server->rsize > server_resp_sz)\r\nserver->rsize = server_resp_sz;\r\nif (!server->wsize || server->wsize > server_rqst_sz)\r\nserver->wsize = server_rqst_sz;\r\n#endif\r\n}\r\nstatic int nfs4_server_common_setup(struct nfs_server *server,\r\nstruct nfs_fh *mntfh, bool auth_probe)\r\n{\r\nstruct nfs_fattr *fattr;\r\nint error;\r\nif (is_ds_only_client(server->nfs_client))\r\nreturn -EPROTONOSUPPORT;\r\nfattr = nfs_alloc_fattr();\r\nif (fattr == NULL)\r\nreturn -ENOMEM;\r\nerror = nfs4_init_session(server->nfs_client);\r\nif (error < 0)\r\ngoto out;\r\nserver->caps |= server->nfs_client->cl_mvops->init_caps;\r\nif (server->flags & NFS_MOUNT_NORDIRPLUS)\r\nserver->caps &= ~NFS_CAP_READDIRPLUS;\r\nif (nfs4_disable_idmapping &&\r\nserver->client->cl_auth->au_flavor == RPC_AUTH_UNIX)\r\nserver->caps |= NFS_CAP_UIDGID_NOMAP;\r\nerror = nfs4_get_rootfh(server, mntfh, auth_probe);\r\nif (error < 0)\r\ngoto out;\r\ndprintk("Server FSID: %llx:%llx\n",\r\n(unsigned long long) server->fsid.major,\r\n(unsigned long long) server->fsid.minor);\r\nnfs_display_fhandle(mntfh, "Pseudo-fs root FH");\r\nnfs4_session_set_rwsize(server);\r\nerror = nfs_probe_fsinfo(server, mntfh, fattr);\r\nif (error < 0)\r\ngoto out;\r\nif (server->namelen == 0 || server->namelen > NFS4_MAXNAMLEN)\r\nserver->namelen = NFS4_MAXNAMLEN;\r\nnfs_server_insert_lists(server);\r\nserver->mount_time = jiffies;\r\nserver->destroy = nfs4_destroy_server;\r\nout:\r\nnfs_free_fattr(fattr);\r\nreturn error;\r\n}\r\nstatic int nfs4_init_server(struct nfs_server *server,\r\nstruct nfs_parsed_mount_data *data)\r\n{\r\nstruct rpc_timeout timeparms;\r\nint error;\r\nnfs_init_timeout_values(&timeparms, data->nfs_server.protocol,\r\ndata->timeo, data->retrans);\r\nserver->flags = data->flags;\r\nserver->options = data->options;\r\nserver->auth_info = data->auth_info;\r\nif (data->auth_info.flavor_len >= 1)\r\ndata->selected_flavor = data->auth_info.flavors[0];\r\nelse\r\ndata->selected_flavor = RPC_AUTH_UNIX;\r\nerror = nfs4_set_client(server,\r\ndata->nfs_server.hostname,\r\n(const struct sockaddr *)&data->nfs_server.address,\r\ndata->nfs_server.addrlen,\r\ndata->client_address,\r\ndata->nfs_server.protocol,\r\n&timeparms,\r\ndata->minorversion,\r\ndata->net);\r\nif (error < 0)\r\nreturn error;\r\nif (data->rsize)\r\nserver->rsize = nfs_block_size(data->rsize, NULL);\r\nif (data->wsize)\r\nserver->wsize = nfs_block_size(data->wsize, NULL);\r\nserver->acregmin = data->acregmin * HZ;\r\nserver->acregmax = data->acregmax * HZ;\r\nserver->acdirmin = data->acdirmin * HZ;\r\nserver->acdirmax = data->acdirmax * HZ;\r\nserver->port = data->nfs_server.port;\r\nreturn nfs_init_server_rpcclient(server, &timeparms,\r\ndata->selected_flavor);\r\n}\r\nstruct nfs_server *nfs4_create_server(struct nfs_mount_info *mount_info,\r\nstruct nfs_subversion *nfs_mod)\r\n{\r\nstruct nfs_server *server;\r\nbool auth_probe;\r\nint error;\r\nserver = nfs_alloc_server();\r\nif (!server)\r\nreturn ERR_PTR(-ENOMEM);\r\nauth_probe = mount_info->parsed->auth_info.flavor_len < 1;\r\nerror = nfs4_init_server(server, mount_info->parsed);\r\nif (error < 0)\r\ngoto error;\r\nerror = nfs4_server_common_setup(server, mount_info->mntfh, auth_probe);\r\nif (error < 0)\r\ngoto error;\r\nreturn server;\r\nerror:\r\nnfs_free_server(server);\r\nreturn ERR_PTR(error);\r\n}\r\nstruct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *data,\r\nstruct nfs_fh *mntfh)\r\n{\r\nstruct nfs_client *parent_client;\r\nstruct nfs_server *server, *parent_server;\r\nbool auth_probe;\r\nint error;\r\nserver = nfs_alloc_server();\r\nif (!server)\r\nreturn ERR_PTR(-ENOMEM);\r\nparent_server = NFS_SB(data->sb);\r\nparent_client = parent_server->nfs_client;\r\nnfs_server_copy_userdata(server, parent_server);\r\nerror = nfs4_set_client(server, data->hostname,\r\ndata->addr,\r\ndata->addrlen,\r\nparent_client->cl_ipaddr,\r\nrpc_protocol(parent_server->client),\r\nparent_server->client->cl_timeout,\r\nparent_client->cl_mvops->minor_version,\r\nparent_client->cl_net);\r\nif (error < 0)\r\ngoto error;\r\nerror = nfs_init_server_rpcclient(server, parent_server->client->cl_timeout, data->authflavor);\r\nif (error < 0)\r\ngoto error;\r\nauth_probe = parent_server->auth_info.flavor_len < 1;\r\nerror = nfs4_server_common_setup(server, mntfh, auth_probe);\r\nif (error < 0)\r\ngoto error;\r\nreturn server;\r\nerror:\r\nnfs_free_server(server);\r\nreturn ERR_PTR(error);\r\n}\r\nstatic int nfs_probe_destination(struct nfs_server *server)\r\n{\r\nstruct inode *inode = d_inode(server->super->s_root);\r\nstruct nfs_fattr *fattr;\r\nint error;\r\nfattr = nfs_alloc_fattr();\r\nif (fattr == NULL)\r\nreturn -ENOMEM;\r\nerror = nfs_probe_fsinfo(server, NFS_FH(inode), fattr);\r\nnfs_free_fattr(fattr);\r\nreturn error;\r\n}\r\nint nfs4_update_server(struct nfs_server *server, const char *hostname,\r\nstruct sockaddr *sap, size_t salen, struct net *net)\r\n{\r\nstruct nfs_client *clp = server->nfs_client;\r\nstruct rpc_clnt *clnt = server->client;\r\nstruct xprt_create xargs = {\r\n.ident = clp->cl_proto,\r\n.net = net,\r\n.dstaddr = sap,\r\n.addrlen = salen,\r\n.servername = hostname,\r\n};\r\nchar buf[INET6_ADDRSTRLEN + 1];\r\nstruct sockaddr_storage address;\r\nstruct sockaddr *localaddr = (struct sockaddr *)&address;\r\nint error;\r\nerror = rpc_switch_client_transport(clnt, &xargs, clnt->cl_timeout);\r\nif (error != 0)\r\nreturn error;\r\nerror = rpc_localaddr(clnt, localaddr, sizeof(address));\r\nif (error != 0)\r\nreturn error;\r\nif (rpc_ntop(localaddr, buf, sizeof(buf)) == 0)\r\nreturn -EAFNOSUPPORT;\r\nnfs_server_remove_lists(server);\r\nset_bit(NFS_MIG_TSM_POSSIBLE, &server->mig_status);\r\nerror = nfs4_set_client(server, hostname, sap, salen, buf,\r\nclp->cl_proto, clnt->cl_timeout,\r\nclp->cl_minorversion, net);\r\nclear_bit(NFS_MIG_TSM_POSSIBLE, &server->mig_status);\r\nnfs_put_client(clp);\r\nif (error != 0) {\r\nnfs_server_insert_lists(server);\r\nreturn error;\r\n}\r\nif (server->nfs_client->cl_hostname == NULL)\r\nserver->nfs_client->cl_hostname = kstrdup(hostname, GFP_KERNEL);\r\nnfs_server_insert_lists(server);\r\nreturn nfs_probe_destination(server);\r\n}
