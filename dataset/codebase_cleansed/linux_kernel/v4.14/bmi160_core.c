static enum bmi160_sensor_type bmi160_to_sensor(enum iio_chan_type iio_type)\r\n{\r\nswitch (iio_type) {\r\ncase IIO_ACCEL:\r\nreturn BMI160_ACCEL;\r\ncase IIO_ANGL_VEL:\r\nreturn BMI160_GYRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic\r\nint bmi160_set_mode(struct bmi160_data *data, enum bmi160_sensor_type t,\r\nbool mode)\r\n{\r\nint ret;\r\nu8 cmd;\r\nif (mode)\r\ncmd = bmi160_regs[t].pmu_cmd_normal;\r\nelse\r\ncmd = bmi160_regs[t].pmu_cmd_suspend;\r\nret = regmap_write(data->regmap, BMI160_REG_CMD, cmd);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(bmi160_pmu_time[t], bmi160_pmu_time[t] + 1000);\r\nreturn 0;\r\n}\r\nstatic\r\nint bmi160_set_scale(struct bmi160_data *data, enum bmi160_sensor_type t,\r\nint uscale)\r\n{\r\nint i;\r\nfor (i = 0; i < bmi160_scale_table[t].num; i++)\r\nif (bmi160_scale_table[t].tbl[i].uscale == uscale)\r\nbreak;\r\nif (i == bmi160_scale_table[t].num)\r\nreturn -EINVAL;\r\nreturn regmap_write(data->regmap, bmi160_regs[t].range,\r\nbmi160_scale_table[t].tbl[i].bits);\r\n}\r\nstatic\r\nint bmi160_get_scale(struct bmi160_data *data, enum bmi160_sensor_type t,\r\nint *uscale)\r\n{\r\nint i, ret, val;\r\nret = regmap_read(data->regmap, bmi160_regs[t].range, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < bmi160_scale_table[t].num; i++)\r\nif (bmi160_scale_table[t].tbl[i].bits == val) {\r\n*uscale = bmi160_scale_table[t].tbl[i].uscale;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int bmi160_get_data(struct bmi160_data *data, int chan_type,\r\nint axis, int *val)\r\n{\r\nu8 reg;\r\nint ret;\r\n__le16 sample;\r\nenum bmi160_sensor_type t = bmi160_to_sensor(chan_type);\r\nreg = bmi160_regs[t].data + (axis - IIO_MOD_X) * sizeof(sample);\r\nret = regmap_bulk_read(data->regmap, reg, &sample, sizeof(sample));\r\nif (ret < 0)\r\nreturn ret;\r\n*val = sign_extend32(le16_to_cpu(sample), 15);\r\nreturn 0;\r\n}\r\nstatic\r\nint bmi160_set_odr(struct bmi160_data *data, enum bmi160_sensor_type t,\r\nint odr, int uodr)\r\n{\r\nint i;\r\nfor (i = 0; i < bmi160_odr_table[t].num; i++)\r\nif (bmi160_odr_table[t].tbl[i].odr == odr &&\r\nbmi160_odr_table[t].tbl[i].uodr == uodr)\r\nbreak;\r\nif (i >= bmi160_odr_table[t].num)\r\nreturn -EINVAL;\r\nreturn regmap_update_bits(data->regmap,\r\nbmi160_regs[t].config,\r\nbmi160_regs[t].config_odr_mask,\r\nbmi160_odr_table[t].tbl[i].bits);\r\n}\r\nstatic int bmi160_get_odr(struct bmi160_data *data, enum bmi160_sensor_type t,\r\nint *odr, int *uodr)\r\n{\r\nint i, val, ret;\r\nret = regmap_read(data->regmap, bmi160_regs[t].config, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nval &= bmi160_regs[t].config_odr_mask;\r\nfor (i = 0; i < bmi160_odr_table[t].num; i++)\r\nif (val == bmi160_odr_table[t].tbl[i].bits)\r\nbreak;\r\nif (i >= bmi160_odr_table[t].num)\r\nreturn -EINVAL;\r\n*odr = bmi160_odr_table[t].tbl[i].odr;\r\n*uodr = bmi160_odr_table[t].tbl[i].uodr;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t bmi160_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct bmi160_data *data = iio_priv(indio_dev);\r\n__le16 buf[16];\r\nint i, ret, j = 0, base = BMI160_REG_DATA_MAGN_XOUT_L;\r\n__le16 sample;\r\nfor_each_set_bit(i, indio_dev->active_scan_mask,\r\nindio_dev->masklength) {\r\nret = regmap_bulk_read(data->regmap, base + i * sizeof(sample),\r\n&sample, sizeof(sample));\r\nif (ret < 0)\r\ngoto done;\r\nbuf[j++] = sample;\r\n}\r\niio_push_to_buffers_with_timestamp(indio_dev, buf,\r\niio_get_time_ns(indio_dev));\r\ndone:\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bmi160_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nint ret;\r\nstruct bmi160_data *data = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = bmi160_get_data(data, chan->type, chan->channel2, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = 0;\r\nret = bmi160_get_scale(data,\r\nbmi160_to_sensor(chan->type), val2);\r\nreturn ret < 0 ? ret : IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nret = bmi160_get_odr(data, bmi160_to_sensor(chan->type),\r\nval, val2);\r\nreturn ret < 0 ? ret : IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bmi160_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct bmi160_data *data = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nreturn bmi160_set_scale(data,\r\nbmi160_to_sensor(chan->type), val2);\r\nbreak;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nreturn bmi160_set_odr(data, bmi160_to_sensor(chan->type),\r\nval, val2);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic const char *bmi160_match_acpi_device(struct device *dev)\r\n{\r\nconst struct acpi_device_id *id;\r\nid = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!id)\r\nreturn NULL;\r\nreturn dev_name(dev);\r\n}\r\nstatic int bmi160_chip_init(struct bmi160_data *data, bool use_spi)\r\n{\r\nint ret;\r\nunsigned int val;\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nret = regmap_write(data->regmap, BMI160_REG_CMD, BMI160_CMD_SOFTRESET);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(BMI160_SOFTRESET_USLEEP, BMI160_SOFTRESET_USLEEP + 1);\r\nif (use_spi) {\r\nret = regmap_read(data->regmap, BMI160_REG_DUMMY, &val);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = regmap_read(data->regmap, BMI160_REG_CHIP_ID, &val);\r\nif (ret < 0) {\r\ndev_err(dev, "Error reading chip id\n");\r\nreturn ret;\r\n}\r\nif (val != BMI160_CHIP_ID_VAL) {\r\ndev_err(dev, "Wrong chip id, got %x expected %x\n",\r\nval, BMI160_CHIP_ID_VAL);\r\nreturn -ENODEV;\r\n}\r\nret = bmi160_set_mode(data, BMI160_ACCEL, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = bmi160_set_mode(data, BMI160_GYRO, true);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void bmi160_chip_uninit(struct bmi160_data *data)\r\n{\r\nbmi160_set_mode(data, BMI160_GYRO, false);\r\nbmi160_set_mode(data, BMI160_ACCEL, false);\r\n}\r\nint bmi160_core_probe(struct device *dev, struct regmap *regmap,\r\nconst char *name, bool use_spi)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct bmi160_data *data;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ndev_set_drvdata(dev, indio_dev);\r\ndata->regmap = regmap;\r\nret = bmi160_chip_init(data, use_spi);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!name && ACPI_HANDLE(dev))\r\nname = bmi160_match_acpi_device(dev);\r\nindio_dev->dev.parent = dev;\r\nindio_dev->channels = bmi160_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(bmi160_channels);\r\nindio_dev->name = name;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &bmi160_info;\r\nret = iio_triggered_buffer_setup(indio_dev, NULL,\r\nbmi160_trigger_handler, NULL);\r\nif (ret < 0)\r\ngoto uninit;\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0)\r\ngoto buffer_cleanup;\r\nreturn 0;\r\nbuffer_cleanup:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nuninit:\r\nbmi160_chip_uninit(data);\r\nreturn ret;\r\n}\r\nvoid bmi160_core_remove(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct bmi160_data *data = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nbmi160_chip_uninit(data);\r\n}
