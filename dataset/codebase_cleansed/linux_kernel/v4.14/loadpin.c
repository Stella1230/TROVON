static void report_load(const char *origin, struct file *file, char *operation)\r\n{\r\nchar *cmdline, *pathname;\r\npathname = kstrdup_quotable_file(file, GFP_KERNEL);\r\ncmdline = kstrdup_quotable_cmdline(current, GFP_KERNEL);\r\npr_notice("%s %s obj=%s%s%s pid=%d cmdline=%s%s%s\n",\r\norigin, operation,\r\n(pathname && pathname[0] != '<') ? "\"" : "",\r\npathname,\r\n(pathname && pathname[0] != '<') ? "\"" : "",\r\ntask_pid_nr(current),\r\ncmdline ? "\"" : "", cmdline, cmdline ? "\"" : "");\r\nkfree(cmdline);\r\nkfree(pathname);\r\n}\r\nstatic void check_pinning_enforcement(struct super_block *mnt_sb)\r\n{\r\nbool ro = false;\r\nif (mnt_sb->s_bdev) {\r\nro = bdev_read_only(mnt_sb->s_bdev);\r\npr_info("dev(%u,%u): %s\n",\r\nMAJOR(mnt_sb->s_bdev->bd_dev),\r\nMINOR(mnt_sb->s_bdev->bd_dev),\r\nro ? "read-only" : "writable");\r\n} else\r\npr_info("mnt_sb lacks block device, treating as: writable\n");\r\nif (!ro) {\r\nif (!register_sysctl_paths(loadpin_sysctl_path,\r\nloadpin_sysctl_table))\r\npr_notice("sysctl registration failed!\n");\r\nelse\r\npr_info("load pinning can be disabled.\n");\r\n} else\r\npr_info("load pinning engaged.\n");\r\n}\r\nstatic void check_pinning_enforcement(struct super_block *mnt_sb)\r\n{\r\npr_info("load pinning engaged.\n");\r\n}\r\nstatic void loadpin_sb_free_security(struct super_block *mnt_sb)\r\n{\r\nif (!IS_ERR_OR_NULL(pinned_root) && mnt_sb == pinned_root) {\r\npinned_root = ERR_PTR(-EIO);\r\npr_info("umount pinned fs: refusing further loads\n");\r\n}\r\n}\r\nstatic int loadpin_read_file(struct file *file, enum kernel_read_file_id id)\r\n{\r\nstruct super_block *load_root;\r\nconst char *origin = kernel_read_file_id_str(id);\r\nif (!file) {\r\nif (!enabled) {\r\nreport_load(origin, NULL, "old-api-pinning-ignored");\r\nreturn 0;\r\n}\r\nreport_load(origin, NULL, "old-api-denied");\r\nreturn -EPERM;\r\n}\r\nload_root = file->f_path.mnt->mnt_sb;\r\nspin_lock(&pinned_root_spinlock);\r\nif (!pinned_root) {\r\npinned_root = load_root;\r\nspin_unlock(&pinned_root_spinlock);\r\ncheck_pinning_enforcement(pinned_root);\r\nreport_load(origin, file, "pinned");\r\n} else {\r\nspin_unlock(&pinned_root_spinlock);\r\n}\r\nif (IS_ERR_OR_NULL(pinned_root) || load_root != pinned_root) {\r\nif (unlikely(!enabled)) {\r\nreport_load(origin, file, "pinning-ignored");\r\nreturn 0;\r\n}\r\nreport_load(origin, file, "denied");\r\nreturn -EPERM;\r\n}\r\nreturn 0;\r\n}\r\nvoid __init loadpin_add_hooks(void)\r\n{\r\npr_info("ready to pin (currently %sabled)", enabled ? "en" : "dis");\r\nsecurity_add_hooks(loadpin_hooks, ARRAY_SIZE(loadpin_hooks), "loadpin");\r\n}
