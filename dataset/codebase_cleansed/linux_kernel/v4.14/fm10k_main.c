static int __init fm10k_init_module(void)\r\n{\r\npr_info("%s - version %s\n", fm10k_driver_string, fm10k_driver_version);\r\npr_info("%s\n", fm10k_copyright);\r\nfm10k_workqueue = alloc_workqueue("%s", WQ_MEM_RECLAIM, 0,\r\nfm10k_driver_name);\r\nfm10k_dbg_init();\r\nreturn fm10k_register_pci_driver();\r\n}\r\nstatic void __exit fm10k_exit_module(void)\r\n{\r\nfm10k_unregister_pci_driver();\r\nfm10k_dbg_exit();\r\ndestroy_workqueue(fm10k_workqueue);\r\n}\r\nstatic bool fm10k_alloc_mapped_page(struct fm10k_ring *rx_ring,\r\nstruct fm10k_rx_buffer *bi)\r\n{\r\nstruct page *page = bi->page;\r\ndma_addr_t dma;\r\nif (likely(page))\r\nreturn true;\r\npage = dev_alloc_page();\r\nif (unlikely(!page)) {\r\nrx_ring->rx_stats.alloc_failed++;\r\nreturn false;\r\n}\r\ndma = dma_map_page(rx_ring->dev, page, 0, PAGE_SIZE, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(rx_ring->dev, dma)) {\r\n__free_page(page);\r\nrx_ring->rx_stats.alloc_failed++;\r\nreturn false;\r\n}\r\nbi->dma = dma;\r\nbi->page = page;\r\nbi->page_offset = 0;\r\nreturn true;\r\n}\r\nvoid fm10k_alloc_rx_buffers(struct fm10k_ring *rx_ring, u16 cleaned_count)\r\n{\r\nunion fm10k_rx_desc *rx_desc;\r\nstruct fm10k_rx_buffer *bi;\r\nu16 i = rx_ring->next_to_use;\r\nif (!cleaned_count)\r\nreturn;\r\nrx_desc = FM10K_RX_DESC(rx_ring, i);\r\nbi = &rx_ring->rx_buffer[i];\r\ni -= rx_ring->count;\r\ndo {\r\nif (!fm10k_alloc_mapped_page(rx_ring, bi))\r\nbreak;\r\nrx_desc->q.pkt_addr = cpu_to_le64(bi->dma + bi->page_offset);\r\nrx_desc++;\r\nbi++;\r\ni++;\r\nif (unlikely(!i)) {\r\nrx_desc = FM10K_RX_DESC(rx_ring, 0);\r\nbi = rx_ring->rx_buffer;\r\ni -= rx_ring->count;\r\n}\r\nrx_desc->d.staterr = 0;\r\ncleaned_count--;\r\n} while (cleaned_count);\r\ni += rx_ring->count;\r\nif (rx_ring->next_to_use != i) {\r\nrx_ring->next_to_use = i;\r\nrx_ring->next_to_alloc = i;\r\nwmb();\r\nwritel(i, rx_ring->tail);\r\n}\r\n}\r\nstatic void fm10k_reuse_rx_page(struct fm10k_ring *rx_ring,\r\nstruct fm10k_rx_buffer *old_buff)\r\n{\r\nstruct fm10k_rx_buffer *new_buff;\r\nu16 nta = rx_ring->next_to_alloc;\r\nnew_buff = &rx_ring->rx_buffer[nta];\r\nnta++;\r\nrx_ring->next_to_alloc = (nta < rx_ring->count) ? nta : 0;\r\n*new_buff = *old_buff;\r\ndma_sync_single_range_for_device(rx_ring->dev, old_buff->dma,\r\nold_buff->page_offset,\r\nFM10K_RX_BUFSZ,\r\nDMA_FROM_DEVICE);\r\n}\r\nstatic inline bool fm10k_page_is_reserved(struct page *page)\r\n{\r\nreturn (page_to_nid(page) != numa_mem_id()) || page_is_pfmemalloc(page);\r\n}\r\nstatic bool fm10k_can_reuse_rx_page(struct fm10k_rx_buffer *rx_buffer,\r\nstruct page *page,\r\nunsigned int __maybe_unused truesize)\r\n{\r\nif (unlikely(fm10k_page_is_reserved(page)))\r\nreturn false;\r\n#if (PAGE_SIZE < 8192)\r\nif (unlikely(page_count(page) != 1))\r\nreturn false;\r\nrx_buffer->page_offset ^= FM10K_RX_BUFSZ;\r\n#else\r\nrx_buffer->page_offset += truesize;\r\nif (rx_buffer->page_offset > (PAGE_SIZE - FM10K_RX_BUFSZ))\r\nreturn false;\r\n#endif\r\npage_ref_inc(page);\r\nreturn true;\r\n}\r\nstatic bool fm10k_add_rx_frag(struct fm10k_rx_buffer *rx_buffer,\r\nunsigned int size,\r\nunion fm10k_rx_desc *rx_desc,\r\nstruct sk_buff *skb)\r\n{\r\nstruct page *page = rx_buffer->page;\r\nunsigned char *va = page_address(page) + rx_buffer->page_offset;\r\n#if (PAGE_SIZE < 8192)\r\nunsigned int truesize = FM10K_RX_BUFSZ;\r\n#else\r\nunsigned int truesize = ALIGN(size, 512);\r\n#endif\r\nunsigned int pull_len;\r\nif (unlikely(skb_is_nonlinear(skb)))\r\ngoto add_tail_frag;\r\nif (likely(size <= FM10K_RX_HDR_LEN)) {\r\nmemcpy(__skb_put(skb, size), va, ALIGN(size, sizeof(long)));\r\nif (likely(!fm10k_page_is_reserved(page)))\r\nreturn true;\r\n__free_page(page);\r\nreturn false;\r\n}\r\npull_len = eth_get_headlen(va, FM10K_RX_HDR_LEN);\r\nmemcpy(__skb_put(skb, pull_len), va, ALIGN(pull_len, sizeof(long)));\r\nva += pull_len;\r\nsize -= pull_len;\r\nadd_tail_frag:\r\nskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,\r\n(unsigned long)va & ~PAGE_MASK, size, truesize);\r\nreturn fm10k_can_reuse_rx_page(rx_buffer, page, truesize);\r\n}\r\nstatic struct sk_buff *fm10k_fetch_rx_buffer(struct fm10k_ring *rx_ring,\r\nunion fm10k_rx_desc *rx_desc,\r\nstruct sk_buff *skb)\r\n{\r\nunsigned int size = le16_to_cpu(rx_desc->w.length);\r\nstruct fm10k_rx_buffer *rx_buffer;\r\nstruct page *page;\r\nrx_buffer = &rx_ring->rx_buffer[rx_ring->next_to_clean];\r\npage = rx_buffer->page;\r\nprefetchw(page);\r\nif (likely(!skb)) {\r\nvoid *page_addr = page_address(page) +\r\nrx_buffer->page_offset;\r\nprefetch(page_addr);\r\n#if L1_CACHE_BYTES < 128\r\nprefetch(page_addr + L1_CACHE_BYTES);\r\n#endif\r\nskb = napi_alloc_skb(&rx_ring->q_vector->napi,\r\nFM10K_RX_HDR_LEN);\r\nif (unlikely(!skb)) {\r\nrx_ring->rx_stats.alloc_failed++;\r\nreturn NULL;\r\n}\r\nprefetchw(skb->data);\r\n}\r\ndma_sync_single_range_for_cpu(rx_ring->dev,\r\nrx_buffer->dma,\r\nrx_buffer->page_offset,\r\nsize,\r\nDMA_FROM_DEVICE);\r\nif (fm10k_add_rx_frag(rx_buffer, size, rx_desc, skb)) {\r\nfm10k_reuse_rx_page(rx_ring, rx_buffer);\r\n} else {\r\ndma_unmap_page(rx_ring->dev, rx_buffer->dma,\r\nPAGE_SIZE, DMA_FROM_DEVICE);\r\n}\r\nrx_buffer->page = NULL;\r\nreturn skb;\r\n}\r\nstatic inline void fm10k_rx_checksum(struct fm10k_ring *ring,\r\nunion fm10k_rx_desc *rx_desc,\r\nstruct sk_buff *skb)\r\n{\r\nskb_checksum_none_assert(skb);\r\nif (!(ring->netdev->features & NETIF_F_RXCSUM))\r\nreturn;\r\nif (fm10k_test_staterr(rx_desc,\r\nFM10K_RXD_STATUS_L4E |\r\nFM10K_RXD_STATUS_L4E2 |\r\nFM10K_RXD_STATUS_IPE |\r\nFM10K_RXD_STATUS_IPE2)) {\r\nring->rx_stats.csum_err++;\r\nreturn;\r\n}\r\nif (fm10k_test_staterr(rx_desc, FM10K_RXD_STATUS_L4CS2))\r\nskb->encapsulation = true;\r\nelse if (!fm10k_test_staterr(rx_desc, FM10K_RXD_STATUS_L4CS))\r\nreturn;\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nring->rx_stats.csum_good++;\r\n}\r\nstatic inline void fm10k_rx_hash(struct fm10k_ring *ring,\r\nunion fm10k_rx_desc *rx_desc,\r\nstruct sk_buff *skb)\r\n{\r\nu16 rss_type;\r\nif (!(ring->netdev->features & NETIF_F_RXHASH))\r\nreturn;\r\nrss_type = le16_to_cpu(rx_desc->w.pkt_info) & FM10K_RXD_RSSTYPE_MASK;\r\nif (!rss_type)\r\nreturn;\r\nskb_set_hash(skb, le32_to_cpu(rx_desc->d.rss),\r\n(BIT(rss_type) & FM10K_RSS_L4_TYPES_MASK) ?\r\nPKT_HASH_TYPE_L4 : PKT_HASH_TYPE_L3);\r\n}\r\nstatic void fm10k_type_trans(struct fm10k_ring *rx_ring,\r\nunion fm10k_rx_desc __maybe_unused *rx_desc,\r\nstruct sk_buff *skb)\r\n{\r\nstruct net_device *dev = rx_ring->netdev;\r\nstruct fm10k_l2_accel *l2_accel = rcu_dereference_bh(rx_ring->l2_accel);\r\nif (l2_accel) {\r\nu16 idx = le16_to_cpu(FM10K_CB(skb)->fi.w.dglort) - 1;\r\nidx -= l2_accel->dglort;\r\nif (idx < l2_accel->size && l2_accel->macvlan[idx])\r\ndev = l2_accel->macvlan[idx];\r\nelse\r\nl2_accel = NULL;\r\n}\r\nskb->protocol = eth_type_trans(skb, dev);\r\nif (!l2_accel)\r\nreturn;\r\nmacvlan_count_rx(netdev_priv(dev), skb->len + ETH_HLEN, 1,\r\n!!(rx_desc->w.hdr_info &\r\ncpu_to_le16(FM10K_RXD_HDR_INFO_XC_MASK)));\r\n}\r\nstatic unsigned int fm10k_process_skb_fields(struct fm10k_ring *rx_ring,\r\nunion fm10k_rx_desc *rx_desc,\r\nstruct sk_buff *skb)\r\n{\r\nunsigned int len = skb->len;\r\nfm10k_rx_hash(rx_ring, rx_desc, skb);\r\nfm10k_rx_checksum(rx_ring, rx_desc, skb);\r\nFM10K_CB(skb)->tstamp = rx_desc->q.timestamp;\r\nFM10K_CB(skb)->fi.w.vlan = rx_desc->w.vlan;\r\nskb_record_rx_queue(skb, rx_ring->queue_index);\r\nFM10K_CB(skb)->fi.d.glort = rx_desc->d.glort;\r\nif (rx_desc->w.vlan) {\r\nu16 vid = le16_to_cpu(rx_desc->w.vlan);\r\nif ((vid & VLAN_VID_MASK) != rx_ring->vid)\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);\r\nelse if (vid & VLAN_PRIO_MASK)\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\r\nvid & VLAN_PRIO_MASK);\r\n}\r\nfm10k_type_trans(rx_ring, rx_desc, skb);\r\nreturn len;\r\n}\r\nstatic bool fm10k_is_non_eop(struct fm10k_ring *rx_ring,\r\nunion fm10k_rx_desc *rx_desc)\r\n{\r\nu32 ntc = rx_ring->next_to_clean + 1;\r\nntc = (ntc < rx_ring->count) ? ntc : 0;\r\nrx_ring->next_to_clean = ntc;\r\nprefetch(FM10K_RX_DESC(rx_ring, ntc));\r\nif (likely(fm10k_test_staterr(rx_desc, FM10K_RXD_STATUS_EOP)))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool fm10k_cleanup_headers(struct fm10k_ring *rx_ring,\r\nunion fm10k_rx_desc *rx_desc,\r\nstruct sk_buff *skb)\r\n{\r\nif (unlikely((fm10k_test_staterr(rx_desc,\r\nFM10K_RXD_STATUS_RXE)))) {\r\n#define FM10K_TEST_RXD_BIT(rxd, bit) \\r\n((rxd)->w.csum_err & cpu_to_le16(bit))\r\nif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_SWITCH_ERROR))\r\nrx_ring->rx_stats.switch_errors++;\r\nif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_NO_DESCRIPTOR))\r\nrx_ring->rx_stats.drops++;\r\nif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_PP_ERROR))\r\nrx_ring->rx_stats.pp_errors++;\r\nif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_SWITCH_READY))\r\nrx_ring->rx_stats.link_errors++;\r\nif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_TOO_BIG))\r\nrx_ring->rx_stats.length_errors++;\r\ndev_kfree_skb_any(skb);\r\nrx_ring->rx_stats.errors++;\r\nreturn true;\r\n}\r\nif (eth_skb_pad(skb))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void fm10k_receive_skb(struct fm10k_q_vector *q_vector,\r\nstruct sk_buff *skb)\r\n{\r\nnapi_gro_receive(&q_vector->napi, skb);\r\n}\r\nstatic int fm10k_clean_rx_irq(struct fm10k_q_vector *q_vector,\r\nstruct fm10k_ring *rx_ring,\r\nint budget)\r\n{\r\nstruct sk_buff *skb = rx_ring->skb;\r\nunsigned int total_bytes = 0, total_packets = 0;\r\nu16 cleaned_count = fm10k_desc_unused(rx_ring);\r\nwhile (likely(total_packets < budget)) {\r\nunion fm10k_rx_desc *rx_desc;\r\nif (cleaned_count >= FM10K_RX_BUFFER_WRITE) {\r\nfm10k_alloc_rx_buffers(rx_ring, cleaned_count);\r\ncleaned_count = 0;\r\n}\r\nrx_desc = FM10K_RX_DESC(rx_ring, rx_ring->next_to_clean);\r\nif (!rx_desc->d.staterr)\r\nbreak;\r\ndma_rmb();\r\nskb = fm10k_fetch_rx_buffer(rx_ring, rx_desc, skb);\r\nif (!skb)\r\nbreak;\r\ncleaned_count++;\r\nif (fm10k_is_non_eop(rx_ring, rx_desc))\r\ncontinue;\r\nif (fm10k_cleanup_headers(rx_ring, rx_desc, skb)) {\r\nskb = NULL;\r\ncontinue;\r\n}\r\ntotal_bytes += fm10k_process_skb_fields(rx_ring, rx_desc, skb);\r\nfm10k_receive_skb(q_vector, skb);\r\nskb = NULL;\r\ntotal_packets++;\r\n}\r\nrx_ring->skb = skb;\r\nu64_stats_update_begin(&rx_ring->syncp);\r\nrx_ring->stats.packets += total_packets;\r\nrx_ring->stats.bytes += total_bytes;\r\nu64_stats_update_end(&rx_ring->syncp);\r\nq_vector->rx.total_packets += total_packets;\r\nq_vector->rx.total_bytes += total_bytes;\r\nreturn total_packets;\r\n}\r\nstatic struct ethhdr *fm10k_port_is_vxlan(struct sk_buff *skb)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(skb->dev);\r\nstruct fm10k_udp_port *vxlan_port;\r\nvxlan_port = list_first_entry_or_null(&interface->vxlan_port,\r\nstruct fm10k_udp_port, list);\r\nif (!vxlan_port)\r\nreturn NULL;\r\nif (vxlan_port->port != udp_hdr(skb)->dest)\r\nreturn NULL;\r\nreturn (struct ethhdr *)(skb_transport_header(skb) + VXLAN_HLEN);\r\n}\r\nstatic struct ethhdr *fm10k_gre_is_nvgre(struct sk_buff *skb)\r\n{\r\nstruct fm10k_nvgre_hdr *nvgre_hdr;\r\nint hlen = ip_hdrlen(skb);\r\nif (vlan_get_protocol(skb) != htons(ETH_P_IP))\r\nreturn NULL;\r\nnvgre_hdr = (struct fm10k_nvgre_hdr *)(skb_network_header(skb) + hlen);\r\nif (nvgre_hdr->flags & FM10K_NVGRE_RESERVED0_FLAGS)\r\nreturn NULL;\r\nif (nvgre_hdr->flags & NVGRE_TNI)\r\nreturn (struct ethhdr *)(nvgre_hdr + 1);\r\nreturn (struct ethhdr *)(&nvgre_hdr->tni);\r\n}\r\n__be16 fm10k_tx_encap_offload(struct sk_buff *skb)\r\n{\r\nu8 l4_hdr = 0, inner_l4_hdr = 0, inner_l4_hlen;\r\nstruct ethhdr *eth_hdr;\r\nif (skb->inner_protocol_type != ENCAP_TYPE_ETHER ||\r\nskb->inner_protocol != htons(ETH_P_TEB))\r\nreturn 0;\r\nswitch (vlan_get_protocol(skb)) {\r\ncase htons(ETH_P_IP):\r\nl4_hdr = ip_hdr(skb)->protocol;\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nl4_hdr = ipv6_hdr(skb)->nexthdr;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nswitch (l4_hdr) {\r\ncase IPPROTO_UDP:\r\neth_hdr = fm10k_port_is_vxlan(skb);\r\nbreak;\r\ncase IPPROTO_GRE:\r\neth_hdr = fm10k_gre_is_nvgre(skb);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (!eth_hdr)\r\nreturn 0;\r\nswitch (eth_hdr->h_proto) {\r\ncase htons(ETH_P_IP):\r\ninner_l4_hdr = inner_ip_hdr(skb)->protocol;\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\ninner_l4_hdr = inner_ipv6_hdr(skb)->nexthdr;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nswitch (inner_l4_hdr) {\r\ncase IPPROTO_TCP:\r\ninner_l4_hlen = inner_tcp_hdrlen(skb);\r\nbreak;\r\ncase IPPROTO_UDP:\r\ninner_l4_hlen = 8;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (skb_inner_transport_header(skb) + inner_l4_hlen -\r\nskb_mac_header(skb) > FM10K_TUNNEL_HEADER_LENGTH)\r\nreturn 0;\r\nreturn eth_hdr->h_proto;\r\n}\r\nstatic int fm10k_tso(struct fm10k_ring *tx_ring,\r\nstruct fm10k_tx_buffer *first)\r\n{\r\nstruct sk_buff *skb = first->skb;\r\nstruct fm10k_tx_desc *tx_desc;\r\nunsigned char *th;\r\nu8 hdrlen;\r\nif (skb->ip_summed != CHECKSUM_PARTIAL)\r\nreturn 0;\r\nif (!skb_is_gso(skb))\r\nreturn 0;\r\nif (skb->encapsulation) {\r\nif (!fm10k_tx_encap_offload(skb))\r\ngoto err_vxlan;\r\nth = skb_inner_transport_header(skb);\r\n} else {\r\nth = skb_transport_header(skb);\r\n}\r\nhdrlen = (th - skb->data) + (((struct tcphdr *)th)->doff << 2);\r\nfirst->tx_flags |= FM10K_TX_FLAGS_CSUM;\r\nfirst->gso_segs = skb_shinfo(skb)->gso_segs;\r\nfirst->bytecount += (first->gso_segs - 1) * hdrlen;\r\ntx_desc = FM10K_TX_DESC(tx_ring, tx_ring->next_to_use);\r\ntx_desc->hdrlen = hdrlen;\r\ntx_desc->mss = cpu_to_le16(skb_shinfo(skb)->gso_size);\r\nreturn 1;\r\nerr_vxlan:\r\ntx_ring->netdev->features &= ~NETIF_F_GSO_UDP_TUNNEL;\r\nif (!net_ratelimit())\r\nnetdev_err(tx_ring->netdev,\r\n"TSO requested for unsupported tunnel, disabling offload\n");\r\nreturn -1;\r\n}\r\nstatic void fm10k_tx_csum(struct fm10k_ring *tx_ring,\r\nstruct fm10k_tx_buffer *first)\r\n{\r\nstruct sk_buff *skb = first->skb;\r\nstruct fm10k_tx_desc *tx_desc;\r\nunion {\r\nstruct iphdr *ipv4;\r\nstruct ipv6hdr *ipv6;\r\nu8 *raw;\r\n} network_hdr;\r\nu8 *transport_hdr;\r\n__be16 frag_off;\r\n__be16 protocol;\r\nu8 l4_hdr = 0;\r\nif (skb->ip_summed != CHECKSUM_PARTIAL)\r\ngoto no_csum;\r\nif (skb->encapsulation) {\r\nprotocol = fm10k_tx_encap_offload(skb);\r\nif (!protocol) {\r\nif (skb_checksum_help(skb)) {\r\ndev_warn(tx_ring->dev,\r\n"failed to offload encap csum!\n");\r\ntx_ring->tx_stats.csum_err++;\r\n}\r\ngoto no_csum;\r\n}\r\nnetwork_hdr.raw = skb_inner_network_header(skb);\r\ntransport_hdr = skb_inner_transport_header(skb);\r\n} else {\r\nprotocol = vlan_get_protocol(skb);\r\nnetwork_hdr.raw = skb_network_header(skb);\r\ntransport_hdr = skb_transport_header(skb);\r\n}\r\nswitch (protocol) {\r\ncase htons(ETH_P_IP):\r\nl4_hdr = network_hdr.ipv4->protocol;\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nl4_hdr = network_hdr.ipv6->nexthdr;\r\nif (likely((transport_hdr - network_hdr.raw) ==\r\nsizeof(struct ipv6hdr)))\r\nbreak;\r\nipv6_skip_exthdr(skb, network_hdr.raw - skb->data +\r\nsizeof(struct ipv6hdr),\r\n&l4_hdr, &frag_off);\r\nif (unlikely(frag_off))\r\nl4_hdr = NEXTHDR_FRAGMENT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (l4_hdr) {\r\ncase IPPROTO_TCP:\r\ncase IPPROTO_UDP:\r\nbreak;\r\ncase IPPROTO_GRE:\r\nif (skb->encapsulation)\r\nbreak;\r\ndefault:\r\nif (unlikely(net_ratelimit())) {\r\ndev_warn(tx_ring->dev,\r\n"partial checksum, version=%d l4 proto=%x\n",\r\nprotocol, l4_hdr);\r\n}\r\nskb_checksum_help(skb);\r\ntx_ring->tx_stats.csum_err++;\r\ngoto no_csum;\r\n}\r\nfirst->tx_flags |= FM10K_TX_FLAGS_CSUM;\r\ntx_ring->tx_stats.csum_good++;\r\nno_csum:\r\ntx_desc = FM10K_TX_DESC(tx_ring, tx_ring->next_to_use);\r\ntx_desc->hdrlen = 0;\r\ntx_desc->mss = 0;\r\n}\r\nstatic u8 fm10k_tx_desc_flags(struct sk_buff *skb, u32 tx_flags)\r\n{\r\nu32 desc_flags = 0;\r\ndesc_flags |= FM10K_SET_FLAG(tx_flags, FM10K_TX_FLAGS_CSUM,\r\nFM10K_TXD_FLAG_CSUM);\r\nreturn desc_flags;\r\n}\r\nstatic bool fm10k_tx_desc_push(struct fm10k_ring *tx_ring,\r\nstruct fm10k_tx_desc *tx_desc, u16 i,\r\ndma_addr_t dma, unsigned int size, u8 desc_flags)\r\n{\r\nif ((++i & (FM10K_TXD_WB_FIFO_SIZE - 1)) == 0)\r\ndesc_flags |= FM10K_TXD_FLAG_RS | FM10K_TXD_FLAG_INT;\r\ntx_desc->buffer_addr = cpu_to_le64(dma);\r\ntx_desc->flags = desc_flags;\r\ntx_desc->buflen = cpu_to_le16(size);\r\nreturn i == tx_ring->count;\r\n}\r\nstatic int __fm10k_maybe_stop_tx(struct fm10k_ring *tx_ring, u16 size)\r\n{\r\nnetif_stop_subqueue(tx_ring->netdev, tx_ring->queue_index);\r\nsmp_mb();\r\nif (likely(fm10k_desc_unused(tx_ring) < size))\r\nreturn -EBUSY;\r\nnetif_start_subqueue(tx_ring->netdev, tx_ring->queue_index);\r\n++tx_ring->tx_stats.restart_queue;\r\nreturn 0;\r\n}\r\nstatic inline int fm10k_maybe_stop_tx(struct fm10k_ring *tx_ring, u16 size)\r\n{\r\nif (likely(fm10k_desc_unused(tx_ring) >= size))\r\nreturn 0;\r\nreturn __fm10k_maybe_stop_tx(tx_ring, size);\r\n}\r\nstatic void fm10k_tx_map(struct fm10k_ring *tx_ring,\r\nstruct fm10k_tx_buffer *first)\r\n{\r\nstruct sk_buff *skb = first->skb;\r\nstruct fm10k_tx_buffer *tx_buffer;\r\nstruct fm10k_tx_desc *tx_desc;\r\nstruct skb_frag_struct *frag;\r\nunsigned char *data;\r\ndma_addr_t dma;\r\nunsigned int data_len, size;\r\nu32 tx_flags = first->tx_flags;\r\nu16 i = tx_ring->next_to_use;\r\nu8 flags = fm10k_tx_desc_flags(skb, tx_flags);\r\ntx_desc = FM10K_TX_DESC(tx_ring, i);\r\nif (skb_vlan_tag_present(skb))\r\ntx_desc->vlan = cpu_to_le16(skb_vlan_tag_get(skb));\r\nelse\r\ntx_desc->vlan = 0;\r\nsize = skb_headlen(skb);\r\ndata = skb->data;\r\ndma = dma_map_single(tx_ring->dev, data, size, DMA_TO_DEVICE);\r\ndata_len = skb->data_len;\r\ntx_buffer = first;\r\nfor (frag = &skb_shinfo(skb)->frags[0];; frag++) {\r\nif (dma_mapping_error(tx_ring->dev, dma))\r\ngoto dma_error;\r\ndma_unmap_len_set(tx_buffer, len, size);\r\ndma_unmap_addr_set(tx_buffer, dma, dma);\r\nwhile (unlikely(size > FM10K_MAX_DATA_PER_TXD)) {\r\nif (fm10k_tx_desc_push(tx_ring, tx_desc++, i++, dma,\r\nFM10K_MAX_DATA_PER_TXD, flags)) {\r\ntx_desc = FM10K_TX_DESC(tx_ring, 0);\r\ni = 0;\r\n}\r\ndma += FM10K_MAX_DATA_PER_TXD;\r\nsize -= FM10K_MAX_DATA_PER_TXD;\r\n}\r\nif (likely(!data_len))\r\nbreak;\r\nif (fm10k_tx_desc_push(tx_ring, tx_desc++, i++,\r\ndma, size, flags)) {\r\ntx_desc = FM10K_TX_DESC(tx_ring, 0);\r\ni = 0;\r\n}\r\nsize = skb_frag_size(frag);\r\ndata_len -= size;\r\ndma = skb_frag_dma_map(tx_ring->dev, frag, 0, size,\r\nDMA_TO_DEVICE);\r\ntx_buffer = &tx_ring->tx_buffer[i];\r\n}\r\nflags |= FM10K_TXD_FLAG_LAST;\r\nif (fm10k_tx_desc_push(tx_ring, tx_desc, i++, dma, size, flags))\r\ni = 0;\r\nnetdev_tx_sent_queue(txring_txq(tx_ring), first->bytecount);\r\nskb_tx_timestamp(first->skb);\r\nwmb();\r\nfirst->next_to_watch = tx_desc;\r\ntx_ring->next_to_use = i;\r\nfm10k_maybe_stop_tx(tx_ring, DESC_NEEDED);\r\nif (netif_xmit_stopped(txring_txq(tx_ring)) || !skb->xmit_more) {\r\nwritel(i, tx_ring->tail);\r\nmmiowb();\r\n}\r\nreturn;\r\ndma_error:\r\ndev_err(tx_ring->dev, "TX DMA map failed\n");\r\nfor (;;) {\r\ntx_buffer = &tx_ring->tx_buffer[i];\r\nfm10k_unmap_and_free_tx_resource(tx_ring, tx_buffer);\r\nif (tx_buffer == first)\r\nbreak;\r\nif (i == 0)\r\ni = tx_ring->count;\r\ni--;\r\n}\r\ntx_ring->next_to_use = i;\r\n}\r\nnetdev_tx_t fm10k_xmit_frame_ring(struct sk_buff *skb,\r\nstruct fm10k_ring *tx_ring)\r\n{\r\nu16 count = TXD_USE_COUNT(skb_headlen(skb));\r\nstruct fm10k_tx_buffer *first;\r\nunsigned short f;\r\nu32 tx_flags = 0;\r\nint tso;\r\nfor (f = 0; f < skb_shinfo(skb)->nr_frags; f++)\r\ncount += TXD_USE_COUNT(skb_shinfo(skb)->frags[f].size);\r\nif (fm10k_maybe_stop_tx(tx_ring, count + 3)) {\r\ntx_ring->tx_stats.tx_busy++;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nfirst = &tx_ring->tx_buffer[tx_ring->next_to_use];\r\nfirst->skb = skb;\r\nfirst->bytecount = max_t(unsigned int, skb->len, ETH_ZLEN);\r\nfirst->gso_segs = 1;\r\nfirst->tx_flags = tx_flags;\r\ntso = fm10k_tso(tx_ring, first);\r\nif (tso < 0)\r\ngoto out_drop;\r\nelse if (!tso)\r\nfm10k_tx_csum(tx_ring, first);\r\nfm10k_tx_map(tx_ring, first);\r\nreturn NETDEV_TX_OK;\r\nout_drop:\r\ndev_kfree_skb_any(first->skb);\r\nfirst->skb = NULL;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic u64 fm10k_get_tx_completed(struct fm10k_ring *ring)\r\n{\r\nreturn ring->stats.packets;\r\n}\r\nu64 fm10k_get_tx_pending(struct fm10k_ring *ring, bool in_sw)\r\n{\r\nstruct fm10k_intfc *interface = ring->q_vector->interface;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nu32 head, tail;\r\nif (likely(in_sw)) {\r\nhead = ring->next_to_clean;\r\ntail = ring->next_to_use;\r\n} else {\r\nhead = fm10k_read_reg(hw, FM10K_TDH(ring->reg_idx));\r\ntail = fm10k_read_reg(hw, FM10K_TDT(ring->reg_idx));\r\n}\r\nreturn ((head <= tail) ? tail : tail + ring->count) - head;\r\n}\r\nbool fm10k_check_tx_hang(struct fm10k_ring *tx_ring)\r\n{\r\nu32 tx_done = fm10k_get_tx_completed(tx_ring);\r\nu32 tx_done_old = tx_ring->tx_stats.tx_done_old;\r\nu32 tx_pending = fm10k_get_tx_pending(tx_ring, true);\r\nclear_check_for_tx_hang(tx_ring);\r\nif (!tx_pending || (tx_done_old != tx_done)) {\r\ntx_ring->tx_stats.tx_done_old = tx_done;\r\nclear_bit(__FM10K_HANG_CHECK_ARMED, tx_ring->state);\r\nreturn false;\r\n}\r\nreturn test_and_set_bit(__FM10K_HANG_CHECK_ARMED, tx_ring->state);\r\n}\r\nvoid fm10k_tx_timeout_reset(struct fm10k_intfc *interface)\r\n{\r\nif (!test_bit(__FM10K_DOWN, interface->state)) {\r\ninterface->tx_timeout_count++;\r\nset_bit(FM10K_FLAG_RESET_REQUESTED, interface->flags);\r\nfm10k_service_event_schedule(interface);\r\n}\r\n}\r\nstatic bool fm10k_clean_tx_irq(struct fm10k_q_vector *q_vector,\r\nstruct fm10k_ring *tx_ring, int napi_budget)\r\n{\r\nstruct fm10k_intfc *interface = q_vector->interface;\r\nstruct fm10k_tx_buffer *tx_buffer;\r\nstruct fm10k_tx_desc *tx_desc;\r\nunsigned int total_bytes = 0, total_packets = 0;\r\nunsigned int budget = q_vector->tx.work_limit;\r\nunsigned int i = tx_ring->next_to_clean;\r\nif (test_bit(__FM10K_DOWN, interface->state))\r\nreturn true;\r\ntx_buffer = &tx_ring->tx_buffer[i];\r\ntx_desc = FM10K_TX_DESC(tx_ring, i);\r\ni -= tx_ring->count;\r\ndo {\r\nstruct fm10k_tx_desc *eop_desc = tx_buffer->next_to_watch;\r\nif (!eop_desc)\r\nbreak;\r\nread_barrier_depends();\r\nif (!(eop_desc->flags & FM10K_TXD_FLAG_DONE))\r\nbreak;\r\ntx_buffer->next_to_watch = NULL;\r\ntotal_bytes += tx_buffer->bytecount;\r\ntotal_packets += tx_buffer->gso_segs;\r\nnapi_consume_skb(tx_buffer->skb, napi_budget);\r\ndma_unmap_single(tx_ring->dev,\r\ndma_unmap_addr(tx_buffer, dma),\r\ndma_unmap_len(tx_buffer, len),\r\nDMA_TO_DEVICE);\r\ntx_buffer->skb = NULL;\r\ndma_unmap_len_set(tx_buffer, len, 0);\r\nwhile (tx_desc != eop_desc) {\r\ntx_buffer++;\r\ntx_desc++;\r\ni++;\r\nif (unlikely(!i)) {\r\ni -= tx_ring->count;\r\ntx_buffer = tx_ring->tx_buffer;\r\ntx_desc = FM10K_TX_DESC(tx_ring, 0);\r\n}\r\nif (dma_unmap_len(tx_buffer, len)) {\r\ndma_unmap_page(tx_ring->dev,\r\ndma_unmap_addr(tx_buffer, dma),\r\ndma_unmap_len(tx_buffer, len),\r\nDMA_TO_DEVICE);\r\ndma_unmap_len_set(tx_buffer, len, 0);\r\n}\r\n}\r\ntx_buffer++;\r\ntx_desc++;\r\ni++;\r\nif (unlikely(!i)) {\r\ni -= tx_ring->count;\r\ntx_buffer = tx_ring->tx_buffer;\r\ntx_desc = FM10K_TX_DESC(tx_ring, 0);\r\n}\r\nprefetch(tx_desc);\r\nbudget--;\r\n} while (likely(budget));\r\ni += tx_ring->count;\r\ntx_ring->next_to_clean = i;\r\nu64_stats_update_begin(&tx_ring->syncp);\r\ntx_ring->stats.bytes += total_bytes;\r\ntx_ring->stats.packets += total_packets;\r\nu64_stats_update_end(&tx_ring->syncp);\r\nq_vector->tx.total_bytes += total_bytes;\r\nq_vector->tx.total_packets += total_packets;\r\nif (check_for_tx_hang(tx_ring) && fm10k_check_tx_hang(tx_ring)) {\r\nstruct fm10k_hw *hw = &interface->hw;\r\nnetif_err(interface, drv, tx_ring->netdev,\r\n"Detected Tx Unit Hang\n"\r\n" Tx Queue <%d>\n"\r\n" TDH, TDT <%x>, <%x>\n"\r\n" next_to_use <%x>\n"\r\n" next_to_clean <%x>\n",\r\ntx_ring->queue_index,\r\nfm10k_read_reg(hw, FM10K_TDH(tx_ring->reg_idx)),\r\nfm10k_read_reg(hw, FM10K_TDT(tx_ring->reg_idx)),\r\ntx_ring->next_to_use, i);\r\nnetif_stop_subqueue(tx_ring->netdev,\r\ntx_ring->queue_index);\r\nnetif_info(interface, probe, tx_ring->netdev,\r\n"tx hang %d detected on queue %d, resetting interface\n",\r\ninterface->tx_timeout_count + 1,\r\ntx_ring->queue_index);\r\nfm10k_tx_timeout_reset(interface);\r\nreturn true;\r\n}\r\nnetdev_tx_completed_queue(txring_txq(tx_ring),\r\ntotal_packets, total_bytes);\r\n#define TX_WAKE_THRESHOLD min_t(u16, FM10K_MIN_TXD - 1, DESC_NEEDED * 2)\r\nif (unlikely(total_packets && netif_carrier_ok(tx_ring->netdev) &&\r\n(fm10k_desc_unused(tx_ring) >= TX_WAKE_THRESHOLD))) {\r\nsmp_mb();\r\nif (__netif_subqueue_stopped(tx_ring->netdev,\r\ntx_ring->queue_index) &&\r\n!test_bit(__FM10K_DOWN, interface->state)) {\r\nnetif_wake_subqueue(tx_ring->netdev,\r\ntx_ring->queue_index);\r\n++tx_ring->tx_stats.restart_queue;\r\n}\r\n}\r\nreturn !!budget;\r\n}\r\nstatic void fm10k_update_itr(struct fm10k_ring_container *ring_container)\r\n{\r\nunsigned int avg_wire_size, packets, itr_round;\r\nif (!ITR_IS_ADAPTIVE(ring_container->itr))\r\ngoto clear_counts;\r\npackets = ring_container->total_packets;\r\nif (!packets)\r\ngoto clear_counts;\r\navg_wire_size = ring_container->total_bytes / packets;\r\nif (avg_wire_size <= 360) {\r\navg_wire_size *= 8;\r\navg_wire_size += 376;\r\n} else if (avg_wire_size <= 1152) {\r\navg_wire_size *= 3;\r\navg_wire_size += 2176;\r\n} else if (avg_wire_size <= 1920) {\r\navg_wire_size += 4480;\r\n} else {\r\navg_wire_size = 6656;\r\n}\r\nitr_round = READ_ONCE(ring_container->itr_scale) + 8;\r\navg_wire_size += BIT(itr_round) - 1;\r\navg_wire_size >>= itr_round;\r\nring_container->itr = avg_wire_size | FM10K_ITR_ADAPTIVE;\r\nclear_counts:\r\nring_container->total_bytes = 0;\r\nring_container->total_packets = 0;\r\n}\r\nstatic void fm10k_qv_enable(struct fm10k_q_vector *q_vector)\r\n{\r\nu32 itr = FM10K_ITR_ENABLE;\r\nfm10k_update_itr(&q_vector->tx);\r\nfm10k_update_itr(&q_vector->rx);\r\nitr |= (q_vector->tx.itr & FM10K_ITR_MAX);\r\nitr |= (q_vector->rx.itr & FM10K_ITR_MAX) << FM10K_ITR_INTERVAL1_SHIFT;\r\nwritel(itr, q_vector->itr);\r\n}\r\nstatic int fm10k_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct fm10k_q_vector *q_vector =\r\ncontainer_of(napi, struct fm10k_q_vector, napi);\r\nstruct fm10k_ring *ring;\r\nint per_ring_budget, work_done = 0;\r\nbool clean_complete = true;\r\nfm10k_for_each_ring(ring, q_vector->tx) {\r\nif (!fm10k_clean_tx_irq(q_vector, ring, budget))\r\nclean_complete = false;\r\n}\r\nif (budget <= 0)\r\nreturn budget;\r\nif (q_vector->rx.count > 1)\r\nper_ring_budget = max(budget / q_vector->rx.count, 1);\r\nelse\r\nper_ring_budget = budget;\r\nfm10k_for_each_ring(ring, q_vector->rx) {\r\nint work = fm10k_clean_rx_irq(q_vector, ring, per_ring_budget);\r\nwork_done += work;\r\nif (work >= per_ring_budget)\r\nclean_complete = false;\r\n}\r\nif (!clean_complete)\r\nreturn budget;\r\nnapi_complete_done(napi, work_done);\r\nfm10k_qv_enable(q_vector);\r\nreturn min(work_done, budget - 1);\r\n}\r\nstatic bool fm10k_set_qos_queues(struct fm10k_intfc *interface)\r\n{\r\nstruct net_device *dev = interface->netdev;\r\nstruct fm10k_ring_feature *f;\r\nint rss_i, i;\r\nint pcs;\r\npcs = netdev_get_num_tc(dev);\r\nif (pcs <= 1)\r\nreturn false;\r\nf = &interface->ring_feature[RING_F_QOS];\r\nf->indices = pcs;\r\nf->mask = BIT(fls(pcs - 1)) - 1;\r\nrss_i = interface->hw.mac.max_queues / pcs;\r\nrss_i = BIT(fls(rss_i) - 1);\r\nf = &interface->ring_feature[RING_F_RSS];\r\nrss_i = min_t(u16, rss_i, f->limit);\r\nf->indices = rss_i;\r\nf->mask = BIT(fls(rss_i - 1)) - 1;\r\nfor (i = 0; i < pcs; i++)\r\nnetdev_set_tc_queue(dev, i, rss_i, rss_i * i);\r\ninterface->num_rx_queues = rss_i * pcs;\r\ninterface->num_tx_queues = rss_i * pcs;\r\nreturn true;\r\n}\r\nstatic bool fm10k_set_rss_queues(struct fm10k_intfc *interface)\r\n{\r\nstruct fm10k_ring_feature *f;\r\nu16 rss_i;\r\nf = &interface->ring_feature[RING_F_RSS];\r\nrss_i = min_t(u16, interface->hw.mac.max_queues, f->limit);\r\nf->indices = rss_i;\r\nf->mask = BIT(fls(rss_i - 1)) - 1;\r\ninterface->num_rx_queues = rss_i;\r\ninterface->num_tx_queues = rss_i;\r\nreturn true;\r\n}\r\nstatic void fm10k_set_num_queues(struct fm10k_intfc *interface)\r\n{\r\nif (fm10k_set_qos_queues(interface))\r\nreturn;\r\nfm10k_set_rss_queues(interface);\r\n}\r\nstatic void fm10k_reset_num_queues(struct fm10k_intfc *interface)\r\n{\r\ninterface->num_tx_queues = 0;\r\ninterface->num_rx_queues = 0;\r\ninterface->num_q_vectors = 0;\r\n}\r\nstatic int fm10k_alloc_q_vector(struct fm10k_intfc *interface,\r\nunsigned int v_count, unsigned int v_idx,\r\nunsigned int txr_count, unsigned int txr_idx,\r\nunsigned int rxr_count, unsigned int rxr_idx)\r\n{\r\nstruct fm10k_q_vector *q_vector;\r\nstruct fm10k_ring *ring;\r\nint ring_count, size;\r\nring_count = txr_count + rxr_count;\r\nsize = sizeof(struct fm10k_q_vector) +\r\n(sizeof(struct fm10k_ring) * ring_count);\r\nq_vector = kzalloc(size, GFP_KERNEL);\r\nif (!q_vector)\r\nreturn -ENOMEM;\r\nnetif_napi_add(interface->netdev, &q_vector->napi,\r\nfm10k_poll, NAPI_POLL_WEIGHT);\r\ninterface->q_vector[v_idx] = q_vector;\r\nq_vector->interface = interface;\r\nq_vector->v_idx = v_idx;\r\nring = q_vector->ring;\r\nq_vector->tx.ring = ring;\r\nq_vector->tx.work_limit = FM10K_DEFAULT_TX_WORK;\r\nq_vector->tx.itr = interface->tx_itr;\r\nq_vector->tx.itr_scale = interface->hw.mac.itr_scale;\r\nq_vector->tx.count = txr_count;\r\nwhile (txr_count) {\r\nring->dev = &interface->pdev->dev;\r\nring->netdev = interface->netdev;\r\nring->q_vector = q_vector;\r\nring->count = interface->tx_ring_count;\r\nring->queue_index = txr_idx;\r\ninterface->tx_ring[txr_idx] = ring;\r\ntxr_count--;\r\ntxr_idx += v_count;\r\nring++;\r\n}\r\nq_vector->rx.ring = ring;\r\nq_vector->rx.itr = interface->rx_itr;\r\nq_vector->rx.itr_scale = interface->hw.mac.itr_scale;\r\nq_vector->rx.count = rxr_count;\r\nwhile (rxr_count) {\r\nring->dev = &interface->pdev->dev;\r\nring->netdev = interface->netdev;\r\nrcu_assign_pointer(ring->l2_accel, interface->l2_accel);\r\nring->q_vector = q_vector;\r\nring->count = interface->rx_ring_count;\r\nring->queue_index = rxr_idx;\r\ninterface->rx_ring[rxr_idx] = ring;\r\nrxr_count--;\r\nrxr_idx += v_count;\r\nring++;\r\n}\r\nfm10k_dbg_q_vector_init(q_vector);\r\nreturn 0;\r\n}\r\nstatic void fm10k_free_q_vector(struct fm10k_intfc *interface, int v_idx)\r\n{\r\nstruct fm10k_q_vector *q_vector = interface->q_vector[v_idx];\r\nstruct fm10k_ring *ring;\r\nfm10k_dbg_q_vector_exit(q_vector);\r\nfm10k_for_each_ring(ring, q_vector->tx)\r\ninterface->tx_ring[ring->queue_index] = NULL;\r\nfm10k_for_each_ring(ring, q_vector->rx)\r\ninterface->rx_ring[ring->queue_index] = NULL;\r\ninterface->q_vector[v_idx] = NULL;\r\nnetif_napi_del(&q_vector->napi);\r\nkfree_rcu(q_vector, rcu);\r\n}\r\nstatic int fm10k_alloc_q_vectors(struct fm10k_intfc *interface)\r\n{\r\nunsigned int q_vectors = interface->num_q_vectors;\r\nunsigned int rxr_remaining = interface->num_rx_queues;\r\nunsigned int txr_remaining = interface->num_tx_queues;\r\nunsigned int rxr_idx = 0, txr_idx = 0, v_idx = 0;\r\nint err;\r\nif (q_vectors >= (rxr_remaining + txr_remaining)) {\r\nfor (; rxr_remaining; v_idx++) {\r\nerr = fm10k_alloc_q_vector(interface, q_vectors, v_idx,\r\n0, 0, 1, rxr_idx);\r\nif (err)\r\ngoto err_out;\r\nrxr_remaining--;\r\nrxr_idx++;\r\n}\r\n}\r\nfor (; v_idx < q_vectors; v_idx++) {\r\nint rqpv = DIV_ROUND_UP(rxr_remaining, q_vectors - v_idx);\r\nint tqpv = DIV_ROUND_UP(txr_remaining, q_vectors - v_idx);\r\nerr = fm10k_alloc_q_vector(interface, q_vectors, v_idx,\r\ntqpv, txr_idx,\r\nrqpv, rxr_idx);\r\nif (err)\r\ngoto err_out;\r\nrxr_remaining -= rqpv;\r\ntxr_remaining -= tqpv;\r\nrxr_idx++;\r\ntxr_idx++;\r\n}\r\nreturn 0;\r\nerr_out:\r\nfm10k_reset_num_queues(interface);\r\nwhile (v_idx--)\r\nfm10k_free_q_vector(interface, v_idx);\r\nreturn -ENOMEM;\r\n}\r\nstatic void fm10k_free_q_vectors(struct fm10k_intfc *interface)\r\n{\r\nint v_idx = interface->num_q_vectors;\r\nfm10k_reset_num_queues(interface);\r\nwhile (v_idx--)\r\nfm10k_free_q_vector(interface, v_idx);\r\n}\r\nstatic void fm10k_reset_msix_capability(struct fm10k_intfc *interface)\r\n{\r\npci_disable_msix(interface->pdev);\r\nkfree(interface->msix_entries);\r\ninterface->msix_entries = NULL;\r\n}\r\nstatic int fm10k_init_msix_capability(struct fm10k_intfc *interface)\r\n{\r\nstruct fm10k_hw *hw = &interface->hw;\r\nint v_budget, vector;\r\nv_budget = max(interface->num_rx_queues, interface->num_tx_queues);\r\nv_budget = min_t(u16, v_budget, num_online_cpus());\r\nv_budget += NON_Q_VECTORS(hw);\r\nv_budget = min_t(int, v_budget, hw->mac.max_msix_vectors);\r\ninterface->msix_entries = kcalloc(v_budget, sizeof(struct msix_entry),\r\nGFP_KERNEL);\r\nif (!interface->msix_entries)\r\nreturn -ENOMEM;\r\nfor (vector = 0; vector < v_budget; vector++)\r\ninterface->msix_entries[vector].entry = vector;\r\nv_budget = pci_enable_msix_range(interface->pdev,\r\ninterface->msix_entries,\r\nMIN_MSIX_COUNT(hw),\r\nv_budget);\r\nif (v_budget < 0) {\r\nkfree(interface->msix_entries);\r\ninterface->msix_entries = NULL;\r\nreturn v_budget;\r\n}\r\ninterface->num_q_vectors = v_budget - NON_Q_VECTORS(hw);\r\nreturn 0;\r\n}\r\nstatic bool fm10k_cache_ring_qos(struct fm10k_intfc *interface)\r\n{\r\nstruct net_device *dev = interface->netdev;\r\nint pc, offset, rss_i, i, q_idx;\r\nu16 pc_stride = interface->ring_feature[RING_F_QOS].mask + 1;\r\nu8 num_pcs = netdev_get_num_tc(dev);\r\nif (num_pcs <= 1)\r\nreturn false;\r\nrss_i = interface->ring_feature[RING_F_RSS].indices;\r\nfor (pc = 0, offset = 0; pc < num_pcs; pc++, offset += rss_i) {\r\nq_idx = pc;\r\nfor (i = 0; i < rss_i; i++) {\r\ninterface->tx_ring[offset + i]->reg_idx = q_idx;\r\ninterface->tx_ring[offset + i]->qos_pc = pc;\r\ninterface->rx_ring[offset + i]->reg_idx = q_idx;\r\ninterface->rx_ring[offset + i]->qos_pc = pc;\r\nq_idx += pc_stride;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic void fm10k_cache_ring_rss(struct fm10k_intfc *interface)\r\n{\r\nint i;\r\nfor (i = 0; i < interface->num_rx_queues; i++)\r\ninterface->rx_ring[i]->reg_idx = i;\r\nfor (i = 0; i < interface->num_tx_queues; i++)\r\ninterface->tx_ring[i]->reg_idx = i;\r\n}\r\nstatic void fm10k_assign_rings(struct fm10k_intfc *interface)\r\n{\r\nif (fm10k_cache_ring_qos(interface))\r\nreturn;\r\nfm10k_cache_ring_rss(interface);\r\n}\r\nstatic void fm10k_init_reta(struct fm10k_intfc *interface)\r\n{\r\nu16 i, rss_i = interface->ring_feature[RING_F_RSS].indices;\r\nu32 reta;\r\nif (netif_is_rxfh_configured(interface->netdev)) {\r\nfor (i = FM10K_RETA_SIZE; i--;) {\r\nreta = interface->reta[i];\r\nif ((((reta << 24) >> 24) < rss_i) &&\r\n(((reta << 16) >> 24) < rss_i) &&\r\n(((reta << 8) >> 24) < rss_i) &&\r\n(((reta) >> 24) < rss_i))\r\ncontinue;\r\ndev_err(&interface->pdev->dev,\r\n"RSS indirection table assigned flows out of queue bounds. Reconfiguring.\n");\r\ngoto repopulate_reta;\r\n}\r\nreturn;\r\n}\r\nrepopulate_reta:\r\nfm10k_write_reta(interface, NULL);\r\n}\r\nint fm10k_init_queueing_scheme(struct fm10k_intfc *interface)\r\n{\r\nint err;\r\nfm10k_set_num_queues(interface);\r\nerr = fm10k_init_msix_capability(interface);\r\nif (err) {\r\ndev_err(&interface->pdev->dev,\r\n"Unable to initialize MSI-X capability\n");\r\ngoto err_init_msix;\r\n}\r\nerr = fm10k_alloc_q_vectors(interface);\r\nif (err) {\r\ndev_err(&interface->pdev->dev,\r\n"Unable to allocate queue vectors\n");\r\ngoto err_alloc_q_vectors;\r\n}\r\nfm10k_assign_rings(interface);\r\nfm10k_init_reta(interface);\r\nreturn 0;\r\nerr_alloc_q_vectors:\r\nfm10k_reset_msix_capability(interface);\r\nerr_init_msix:\r\nfm10k_reset_num_queues(interface);\r\nreturn err;\r\n}\r\nvoid fm10k_clear_queueing_scheme(struct fm10k_intfc *interface)\r\n{\r\nfm10k_free_q_vectors(interface);\r\nfm10k_reset_msix_capability(interface);\r\n}
