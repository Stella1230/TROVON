static void wake_up_ctx(struct mtk_vcodec_ctx *ctx, unsigned int reason)\r\n{\r\nctx->int_cond = 1;\r\nctx->int_type = reason;\r\nwake_up_interruptible(&ctx->queue);\r\n}\r\nstatic void clean_irq_status(unsigned int irq_status, void __iomem *addr)\r\n{\r\nif (irq_status & MTK_VENC_IRQ_STATUS_PAUSE)\r\nwritel(MTK_VENC_IRQ_STATUS_PAUSE, addr);\r\nif (irq_status & MTK_VENC_IRQ_STATUS_SWITCH)\r\nwritel(MTK_VENC_IRQ_STATUS_SWITCH, addr);\r\nif (irq_status & MTK_VENC_IRQ_STATUS_DRAM)\r\nwritel(MTK_VENC_IRQ_STATUS_DRAM, addr);\r\nif (irq_status & MTK_VENC_IRQ_STATUS_SPS)\r\nwritel(MTK_VENC_IRQ_STATUS_SPS, addr);\r\nif (irq_status & MTK_VENC_IRQ_STATUS_PPS)\r\nwritel(MTK_VENC_IRQ_STATUS_PPS, addr);\r\nif (irq_status & MTK_VENC_IRQ_STATUS_FRM)\r\nwritel(MTK_VENC_IRQ_STATUS_FRM, addr);\r\n}\r\nstatic irqreturn_t mtk_vcodec_enc_irq_handler(int irq, void *priv)\r\n{\r\nstruct mtk_vcodec_dev *dev = priv;\r\nstruct mtk_vcodec_ctx *ctx;\r\nunsigned long flags;\r\nvoid __iomem *addr;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nctx = dev->curr_ctx;\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nmtk_v4l2_debug(1, "id=%d", ctx->id);\r\naddr = dev->reg_base[VENC_SYS] + MTK_VENC_IRQ_ACK_OFFSET;\r\nctx->irq_status = readl(dev->reg_base[VENC_SYS] +\r\n(MTK_VENC_IRQ_STATUS_OFFSET));\r\nclean_irq_status(ctx->irq_status, addr);\r\nwake_up_ctx(ctx, MTK_INST_IRQ_RECEIVED);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mtk_vcodec_enc_lt_irq_handler(int irq, void *priv)\r\n{\r\nstruct mtk_vcodec_dev *dev = priv;\r\nstruct mtk_vcodec_ctx *ctx;\r\nunsigned long flags;\r\nvoid __iomem *addr;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nctx = dev->curr_ctx;\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nmtk_v4l2_debug(1, "id=%d", ctx->id);\r\nctx->irq_status = readl(dev->reg_base[VENC_LT_SYS] +\r\n(MTK_VENC_IRQ_STATUS_OFFSET));\r\naddr = dev->reg_base[VENC_LT_SYS] + MTK_VENC_IRQ_ACK_OFFSET;\r\nclean_irq_status(ctx->irq_status, addr);\r\nwake_up_ctx(ctx, MTK_INST_IRQ_RECEIVED);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mtk_vcodec_enc_reset_handler(void *priv)\r\n{\r\nstruct mtk_vcodec_dev *dev = priv;\r\nstruct mtk_vcodec_ctx *ctx;\r\nmtk_v4l2_debug(0, "Watchdog timeout!!");\r\nmutex_lock(&dev->dev_mutex);\r\nlist_for_each_entry(ctx, &dev->ctx_list, list) {\r\nctx->state = MTK_STATE_ABORT;\r\nmtk_v4l2_debug(0, "[%d] Change to state MTK_STATE_ABORT",\r\nctx->id);\r\n}\r\nmutex_unlock(&dev->dev_mutex);\r\n}\r\nstatic int fops_vcodec_open(struct file *file)\r\n{\r\nstruct mtk_vcodec_dev *dev = video_drvdata(file);\r\nstruct mtk_vcodec_ctx *ctx = NULL;\r\nint ret = 0;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nmutex_lock(&dev->dev_mutex);\r\nctx->id = dev->id_counter++;\r\nv4l2_fh_init(&ctx->fh, video_devdata(file));\r\nfile->private_data = &ctx->fh;\r\nv4l2_fh_add(&ctx->fh);\r\nINIT_LIST_HEAD(&ctx->list);\r\nctx->dev = dev;\r\ninit_waitqueue_head(&ctx->queue);\r\nctx->type = MTK_INST_ENCODER;\r\nret = mtk_vcodec_enc_ctrls_setup(ctx);\r\nif (ret) {\r\nmtk_v4l2_err("Failed to setup controls() (%d)",\r\nret);\r\ngoto err_ctrls_setup;\r\n}\r\nctx->m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev_enc, ctx,\r\n&mtk_vcodec_enc_queue_init);\r\nif (IS_ERR((__force void *)ctx->m2m_ctx)) {\r\nret = PTR_ERR((__force void *)ctx->m2m_ctx);\r\nmtk_v4l2_err("Failed to v4l2_m2m_ctx_init() (%d)",\r\nret);\r\ngoto err_m2m_ctx_init;\r\n}\r\nmtk_vcodec_enc_set_default_params(ctx);\r\nif (v4l2_fh_is_singular(&ctx->fh)) {\r\nret = vpu_load_firmware(dev->vpu_plat_dev);\r\nif (ret < 0) {\r\nmtk_v4l2_err("vpu_load_firmware failed!");\r\ngoto err_load_fw;\r\n}\r\ndev->enc_capability =\r\nvpu_get_venc_hw_capa(dev->vpu_plat_dev);\r\nmtk_v4l2_debug(0, "encoder capability %x", dev->enc_capability);\r\n}\r\nmtk_v4l2_debug(2, "Create instance [%d]@%p m2m_ctx=%p ",\r\nctx->id, ctx, ctx->m2m_ctx);\r\nlist_add(&ctx->list, &dev->ctx_list);\r\nmutex_unlock(&dev->dev_mutex);\r\nmtk_v4l2_debug(0, "%s encoder [%d]", dev_name(&dev->plat_dev->dev),\r\nctx->id);\r\nreturn ret;\r\nerr_load_fw:\r\nv4l2_m2m_ctx_release(ctx->m2m_ctx);\r\nerr_m2m_ctx_init:\r\nv4l2_ctrl_handler_free(&ctx->ctrl_hdl);\r\nerr_ctrls_setup:\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx);\r\nmutex_unlock(&dev->dev_mutex);\r\nreturn ret;\r\n}\r\nstatic int fops_vcodec_release(struct file *file)\r\n{\r\nstruct mtk_vcodec_dev *dev = video_drvdata(file);\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(file->private_data);\r\nmtk_v4l2_debug(1, "[%d] encoder", ctx->id);\r\nmutex_lock(&dev->dev_mutex);\r\nmtk_vcodec_enc_release(ctx);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nv4l2_ctrl_handler_free(&ctx->ctrl_hdl);\r\nv4l2_m2m_ctx_release(ctx->m2m_ctx);\r\nlist_del_init(&ctx->list);\r\nkfree(ctx);\r\nmutex_unlock(&dev->dev_mutex);\r\nreturn 0;\r\n}\r\nstatic int mtk_vcodec_probe(struct platform_device *pdev)\r\n{\r\nstruct mtk_vcodec_dev *dev;\r\nstruct video_device *vfd_enc;\r\nstruct resource *res;\r\nint i, j, ret;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&dev->ctx_list);\r\ndev->plat_dev = pdev;\r\ndev->vpu_plat_dev = vpu_get_plat_device(dev->plat_dev);\r\nif (dev->vpu_plat_dev == NULL) {\r\nmtk_v4l2_err("[VPU] vpu device in not ready");\r\nreturn -EPROBE_DEFER;\r\n}\r\nvpu_wdt_reg_handler(dev->vpu_plat_dev, mtk_vcodec_enc_reset_handler,\r\ndev, VPU_RST_ENC);\r\nret = mtk_vcodec_init_enc_pm(dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to get mt vcodec clock source!");\r\nreturn ret;\r\n}\r\nfor (i = VENC_SYS, j = 0; i < NUM_MAX_VCODEC_REG_BASE; i++, j++) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, j);\r\ndev->reg_base[i] = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR((__force void *)dev->reg_base[i])) {\r\nret = PTR_ERR((__force void *)dev->reg_base[i]);\r\ngoto err_res;\r\n}\r\nmtk_v4l2_debug(2, "reg[%d] base=0x%p", i, dev->reg_base[i]);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "failed to get irq resource");\r\nret = -ENOENT;\r\ngoto err_res;\r\n}\r\ndev->enc_irq = platform_get_irq(pdev, 0);\r\nret = devm_request_irq(&pdev->dev, dev->enc_irq,\r\nmtk_vcodec_enc_irq_handler,\r\n0, pdev->name, dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to install dev->enc_irq %d (%d)",\r\ndev->enc_irq,\r\nret);\r\nret = -EINVAL;\r\ngoto err_res;\r\n}\r\ndev->enc_lt_irq = platform_get_irq(pdev, 1);\r\nret = devm_request_irq(&pdev->dev,\r\ndev->enc_lt_irq, mtk_vcodec_enc_lt_irq_handler,\r\n0, pdev->name, dev);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Failed to install dev->enc_lt_irq %d (%d)",\r\ndev->enc_lt_irq, ret);\r\nret = -EINVAL;\r\ngoto err_res;\r\n}\r\ndisable_irq(dev->enc_irq);\r\ndisable_irq(dev->enc_lt_irq);\r\nmutex_init(&dev->enc_mutex);\r\nmutex_init(&dev->dev_mutex);\r\nspin_lock_init(&dev->irqlock);\r\nsnprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name), "%s",\r\n"[MTK_V4L2_VENC]");\r\nret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\r\nif (ret) {\r\nmtk_v4l2_err("v4l2_device_register err=%d", ret);\r\ngoto err_res;\r\n}\r\ninit_waitqueue_head(&dev->queue);\r\nvfd_enc = video_device_alloc();\r\nif (!vfd_enc) {\r\nmtk_v4l2_err("Failed to allocate video device");\r\nret = -ENOMEM;\r\ngoto err_enc_alloc;\r\n}\r\nvfd_enc->fops = &mtk_vcodec_fops;\r\nvfd_enc->ioctl_ops = &mtk_venc_ioctl_ops;\r\nvfd_enc->release = video_device_release;\r\nvfd_enc->lock = &dev->dev_mutex;\r\nvfd_enc->v4l2_dev = &dev->v4l2_dev;\r\nvfd_enc->vfl_dir = VFL_DIR_M2M;\r\nvfd_enc->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE |\r\nV4L2_CAP_STREAMING;\r\nsnprintf(vfd_enc->name, sizeof(vfd_enc->name), "%s",\r\nMTK_VCODEC_ENC_NAME);\r\nvideo_set_drvdata(vfd_enc, dev);\r\ndev->vfd_enc = vfd_enc;\r\nplatform_set_drvdata(pdev, dev);\r\ndev->m2m_dev_enc = v4l2_m2m_init(&mtk_venc_m2m_ops);\r\nif (IS_ERR((__force void *)dev->m2m_dev_enc)) {\r\nmtk_v4l2_err("Failed to init mem2mem enc device");\r\nret = PTR_ERR((__force void *)dev->m2m_dev_enc);\r\ngoto err_enc_mem_init;\r\n}\r\ndev->encode_workqueue =\r\nalloc_ordered_workqueue(MTK_VCODEC_ENC_NAME,\r\nWQ_MEM_RECLAIM |\r\nWQ_FREEZABLE);\r\nif (!dev->encode_workqueue) {\r\nmtk_v4l2_err("Failed to create encode workqueue");\r\nret = -EINVAL;\r\ngoto err_event_workq;\r\n}\r\nret = video_register_device(vfd_enc, VFL_TYPE_GRABBER, 1);\r\nif (ret) {\r\nmtk_v4l2_err("Failed to register video device");\r\ngoto err_enc_reg;\r\n}\r\nmtk_v4l2_debug(0, "encoder registered as /dev/video%d",\r\nvfd_enc->num);\r\nreturn 0;\r\nerr_enc_reg:\r\ndestroy_workqueue(dev->encode_workqueue);\r\nerr_event_workq:\r\nv4l2_m2m_release(dev->m2m_dev_enc);\r\nerr_enc_mem_init:\r\nvideo_unregister_device(vfd_enc);\r\nerr_enc_alloc:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nerr_res:\r\nmtk_vcodec_release_enc_pm(dev);\r\nreturn ret;\r\n}\r\nstatic int mtk_vcodec_enc_remove(struct platform_device *pdev)\r\n{\r\nstruct mtk_vcodec_dev *dev = platform_get_drvdata(pdev);\r\nmtk_v4l2_debug_enter();\r\nflush_workqueue(dev->encode_workqueue);\r\ndestroy_workqueue(dev->encode_workqueue);\r\nif (dev->m2m_dev_enc)\r\nv4l2_m2m_release(dev->m2m_dev_enc);\r\nif (dev->vfd_enc)\r\nvideo_unregister_device(dev->vfd_enc);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nmtk_vcodec_release_enc_pm(dev);\r\nreturn 0;\r\n}
