static int __init hash_setup(char *str)\r\n{\r\nstruct ima_template_desc *template_desc = ima_template_desc_current();\r\nint i;\r\nif (hash_setup_done)\r\nreturn 1;\r\nif (strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) == 0) {\r\nif (strncmp(str, "sha1", 4) == 0)\r\nima_hash_algo = HASH_ALGO_SHA1;\r\nelse if (strncmp(str, "md5", 3) == 0)\r\nima_hash_algo = HASH_ALGO_MD5;\r\ngoto out;\r\n}\r\nfor (i = 0; i < HASH_ALGO__LAST; i++) {\r\nif (strcmp(str, hash_algo_name[i]) == 0) {\r\nima_hash_algo = i;\r\nbreak;\r\n}\r\n}\r\nout:\r\nhash_setup_done = 1;\r\nreturn 1;\r\n}\r\nstatic void ima_rdwr_violation_check(struct file *file,\r\nstruct integrity_iint_cache *iint,\r\nint must_measure,\r\nchar **pathbuf,\r\nconst char **pathname)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nchar filename[NAME_MAX];\r\nfmode_t mode = file->f_mode;\r\nbool send_tomtou = false, send_writers = false;\r\nif (mode & FMODE_WRITE) {\r\nif (atomic_read(&inode->i_readcount) && IS_IMA(inode)) {\r\nif (!iint)\r\niint = integrity_iint_find(inode);\r\nif (iint && (iint->flags & IMA_MEASURE))\r\nsend_tomtou = true;\r\n}\r\n} else {\r\nif ((atomic_read(&inode->i_writecount) > 0) && must_measure)\r\nsend_writers = true;\r\n}\r\nif (!send_tomtou && !send_writers)\r\nreturn;\r\n*pathname = ima_d_path(&file->f_path, pathbuf, filename);\r\nif (send_tomtou)\r\nima_add_violation(file, *pathname, iint,\r\n"invalid_pcr", "ToMToU");\r\nif (send_writers)\r\nima_add_violation(file, *pathname, iint,\r\n"invalid_pcr", "open_writers");\r\n}\r\nstatic void ima_check_last_writer(struct integrity_iint_cache *iint,\r\nstruct inode *inode, struct file *file)\r\n{\r\nfmode_t mode = file->f_mode;\r\nif (!(mode & FMODE_WRITE))\r\nreturn;\r\ninode_lock(inode);\r\nif (atomic_read(&inode->i_writecount) == 1) {\r\nif ((iint->version != inode->i_version) ||\r\n(iint->flags & IMA_NEW_FILE)) {\r\niint->flags &= ~(IMA_DONE_MASK | IMA_NEW_FILE);\r\niint->measured_pcrs = 0;\r\nif (iint->flags & IMA_APPRAISE)\r\nima_update_xattr(iint, file);\r\n}\r\n}\r\ninode_unlock(inode);\r\n}\r\nvoid ima_file_free(struct file *file)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstruct integrity_iint_cache *iint;\r\nif (!ima_policy_flag || !S_ISREG(inode->i_mode))\r\nreturn;\r\niint = integrity_iint_find(inode);\r\nif (!iint)\r\nreturn;\r\nima_check_last_writer(iint, inode, file);\r\n}\r\nstatic int process_measurement(struct file *file, char *buf, loff_t size,\r\nint mask, enum ima_hooks func, int opened)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstruct integrity_iint_cache *iint = NULL;\r\nstruct ima_template_desc *template_desc;\r\nchar *pathbuf = NULL;\r\nchar filename[NAME_MAX];\r\nconst char *pathname = NULL;\r\nint rc = -ENOMEM, action, must_appraise;\r\nint pcr = CONFIG_IMA_MEASURE_PCR_IDX;\r\nstruct evm_ima_xattr_data *xattr_value = NULL;\r\nint xattr_len = 0;\r\nbool violation_check;\r\nenum hash_algo hash_algo;\r\nif (!ima_policy_flag || !S_ISREG(inode->i_mode))\r\nreturn 0;\r\naction = ima_get_action(inode, mask, func, &pcr);\r\nviolation_check = ((func == FILE_CHECK || func == MMAP_CHECK) &&\r\n(ima_policy_flag & IMA_MEASURE));\r\nif (!action && !violation_check)\r\nreturn 0;\r\nmust_appraise = action & IMA_APPRAISE;\r\nif (action & IMA_FILE_APPRAISE)\r\nfunc = FILE_CHECK;\r\ninode_lock(inode);\r\nif (action) {\r\niint = integrity_inode_get(inode);\r\nif (!iint)\r\ngoto out;\r\n}\r\nif (violation_check) {\r\nima_rdwr_violation_check(file, iint, action & IMA_MEASURE,\r\n&pathbuf, &pathname);\r\nif (!action) {\r\nrc = 0;\r\ngoto out_free;\r\n}\r\n}\r\niint->flags |= action;\r\naction &= IMA_DO_MASK;\r\naction &= ~((iint->flags & (IMA_DONE_MASK ^ IMA_MEASURED)) >> 1);\r\nif ((action & IMA_MEASURE) && (iint->measured_pcrs & (0x1 << pcr)))\r\naction ^= IMA_MEASURE;\r\nif (!action) {\r\nif (must_appraise)\r\nrc = ima_get_cache_status(iint, func);\r\ngoto out_digsig;\r\n}\r\ntemplate_desc = ima_template_desc_current();\r\nif ((action & IMA_APPRAISE_SUBMASK) ||\r\nstrcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) != 0)\r\nxattr_len = ima_read_xattr(file_dentry(file), &xattr_value);\r\nhash_algo = ima_get_hash_algo(xattr_value, xattr_len);\r\nrc = ima_collect_measurement(iint, file, buf, size, hash_algo);\r\nif (rc != 0) {\r\nif (file->f_flags & O_DIRECT)\r\nrc = (iint->flags & IMA_PERMIT_DIRECTIO) ? 0 : -EACCES;\r\ngoto out_digsig;\r\n}\r\nif (!pathbuf)\r\npathname = ima_d_path(&file->f_path, &pathbuf, filename);\r\nif (action & IMA_MEASURE)\r\nima_store_measurement(iint, file, pathname,\r\nxattr_value, xattr_len, pcr);\r\nif (action & IMA_APPRAISE_SUBMASK)\r\nrc = ima_appraise_measurement(func, iint, file, pathname,\r\nxattr_value, xattr_len, opened);\r\nif (action & IMA_AUDIT)\r\nima_audit_measurement(iint, pathname);\r\nout_digsig:\r\nif ((mask & MAY_WRITE) && (iint->flags & IMA_DIGSIG) &&\r\n!(iint->flags & IMA_NEW_FILE))\r\nrc = -EACCES;\r\nkfree(xattr_value);\r\nout_free:\r\nif (pathbuf)\r\n__putname(pathbuf);\r\nout:\r\ninode_unlock(inode);\r\nif ((rc && must_appraise) && (ima_appraise & IMA_APPRAISE_ENFORCE))\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nint ima_file_mmap(struct file *file, unsigned long prot)\r\n{\r\nif (file && (prot & PROT_EXEC))\r\nreturn process_measurement(file, NULL, 0, MAY_EXEC,\r\nMMAP_CHECK, 0);\r\nreturn 0;\r\n}\r\nint ima_bprm_check(struct linux_binprm *bprm)\r\n{\r\nreturn process_measurement(bprm->file, NULL, 0, MAY_EXEC,\r\nBPRM_CHECK, 0);\r\n}\r\nint ima_file_check(struct file *file, int mask, int opened)\r\n{\r\nreturn process_measurement(file, NULL, 0,\r\nmask & (MAY_READ | MAY_WRITE | MAY_EXEC |\r\nMAY_APPEND), FILE_CHECK, opened);\r\n}\r\nvoid ima_post_path_mknod(struct dentry *dentry)\r\n{\r\nstruct integrity_iint_cache *iint;\r\nstruct inode *inode = dentry->d_inode;\r\nint must_appraise;\r\nmust_appraise = ima_must_appraise(inode, MAY_ACCESS, FILE_CHECK);\r\nif (!must_appraise)\r\nreturn;\r\niint = integrity_inode_get(inode);\r\nif (iint)\r\niint->flags |= IMA_NEW_FILE;\r\n}\r\nint ima_read_file(struct file *file, enum kernel_read_file_id read_id)\r\n{\r\nif (!file && read_id == READING_MODULE) {\r\n#ifndef CONFIG_MODULE_SIG_FORCE\r\nif ((ima_appraise & IMA_APPRAISE_MODULES) &&\r\n(ima_appraise & IMA_APPRAISE_ENFORCE))\r\nreturn -EACCES;\r\n#endif\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nint ima_post_read_file(struct file *file, void *buf, loff_t size,\r\nenum kernel_read_file_id read_id)\r\n{\r\nenum ima_hooks func;\r\nif (!file && read_id == READING_FIRMWARE) {\r\nif ((ima_appraise & IMA_APPRAISE_FIRMWARE) &&\r\n(ima_appraise & IMA_APPRAISE_ENFORCE))\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nif (!file && read_id == READING_MODULE)\r\nreturn 0;\r\nif (!file || !buf || size == 0) {\r\nif (ima_appraise & IMA_APPRAISE_ENFORCE)\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nfunc = read_idmap[read_id] ?: FILE_CHECK;\r\nreturn process_measurement(file, buf, size, MAY_READ, func, 0);\r\n}\r\nstatic int __init init_ima(void)\r\n{\r\nint error;\r\nima_init_template_list();\r\nhash_setup(CONFIG_IMA_DEFAULT_HASH);\r\nerror = ima_init();\r\nif (!error) {\r\nima_initialized = 1;\r\nima_update_policy_flag();\r\n}\r\nreturn error;\r\n}
