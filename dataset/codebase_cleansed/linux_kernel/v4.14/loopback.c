static void gb_loopback_check_attr(struct gb_loopback *gb)\r\n{\r\nif (gb->us_wait > GB_LOOPBACK_US_WAIT_MAX)\r\ngb->us_wait = GB_LOOPBACK_US_WAIT_MAX;\r\nif (gb->size > gb_dev.size_max)\r\ngb->size = gb_dev.size_max;\r\ngb->requests_timedout = 0;\r\ngb->requests_completed = 0;\r\ngb->iteration_count = 0;\r\ngb->send_count = 0;\r\ngb->error = 0;\r\nif (kfifo_depth < gb->iteration_max) {\r\ndev_warn(gb->dev,\r\n"cannot log bytes %u kfifo_depth %u\n",\r\ngb->iteration_max, kfifo_depth);\r\n}\r\nkfifo_reset_out(&gb->kfifo_lat);\r\nkfifo_reset_out(&gb->kfifo_ts);\r\nswitch (gb->type) {\r\ncase GB_LOOPBACK_TYPE_PING:\r\ncase GB_LOOPBACK_TYPE_TRANSFER:\r\ncase GB_LOOPBACK_TYPE_SINK:\r\ngb->jiffy_timeout = usecs_to_jiffies(gb->timeout);\r\nif (!gb->jiffy_timeout)\r\ngb->jiffy_timeout = GB_LOOPBACK_TIMEOUT_MIN;\r\nelse if (gb->jiffy_timeout > GB_LOOPBACK_TIMEOUT_MAX)\r\ngb->jiffy_timeout = GB_LOOPBACK_TIMEOUT_MAX;\r\ngb_loopback_reset_stats(gb);\r\nwake_up(&gb->wq);\r\nbreak;\r\ndefault:\r\ngb->type = 0;\r\nbreak;\r\n}\r\n}\r\nstatic u32 gb_loopback_nsec_to_usec_latency(u64 elapsed_nsecs)\r\n{\r\ndo_div(elapsed_nsecs, NSEC_PER_USEC);\r\nreturn elapsed_nsecs;\r\n}\r\nstatic u64 __gb_loopback_calc_latency(u64 t1, u64 t2)\r\n{\r\nif (t2 > t1)\r\nreturn t2 - t1;\r\nelse\r\nreturn NSEC_PER_DAY - t2 + t1;\r\n}\r\nstatic u64 gb_loopback_calc_latency(struct timeval *ts, struct timeval *te)\r\n{\r\nu64 t1, t2;\r\nt1 = timeval_to_ns(ts);\r\nt2 = timeval_to_ns(te);\r\nreturn __gb_loopback_calc_latency(t1, t2);\r\n}\r\nstatic void gb_loopback_push_latency_ts(struct gb_loopback *gb,\r\nstruct timeval *ts, struct timeval *te)\r\n{\r\nkfifo_in(&gb->kfifo_ts, (unsigned char *)ts, sizeof(*ts));\r\nkfifo_in(&gb->kfifo_ts, (unsigned char *)te, sizeof(*te));\r\n}\r\nstatic int gb_loopback_operation_sync(struct gb_loopback *gb, int type,\r\nvoid *request, int request_size,\r\nvoid *response, int response_size)\r\n{\r\nstruct gb_operation *operation;\r\nstruct timeval ts, te;\r\nint ret;\r\ndo_gettimeofday(&ts);\r\noperation = gb_operation_create(gb->connection, type, request_size,\r\nresponse_size, GFP_KERNEL);\r\nif (!operation)\r\nreturn -ENOMEM;\r\nif (request_size)\r\nmemcpy(operation->request->payload, request, request_size);\r\nret = gb_operation_request_send_sync(operation);\r\nif (ret) {\r\ndev_err(&gb->connection->bundle->dev,\r\n"synchronous operation failed: %d\n", ret);\r\ngoto out_put_operation;\r\n} else {\r\nif (response_size == operation->response->payload_size) {\r\nmemcpy(response, operation->response->payload,\r\nresponse_size);\r\n} else {\r\ndev_err(&gb->connection->bundle->dev,\r\n"response size %zu expected %d\n",\r\noperation->response->payload_size,\r\nresponse_size);\r\nret = -EINVAL;\r\ngoto out_put_operation;\r\n}\r\n}\r\ndo_gettimeofday(&te);\r\ngb_loopback_push_latency_ts(gb, &ts, &te);\r\ngb->elapsed_nsecs = gb_loopback_calc_latency(&ts, &te);\r\nout_put_operation:\r\ngb_operation_put(operation);\r\nreturn ret;\r\n}\r\nstatic void __gb_loopback_async_operation_destroy(struct kref *kref)\r\n{\r\nstruct gb_loopback_async_operation *op_async;\r\nop_async = container_of(kref, struct gb_loopback_async_operation, kref);\r\nlist_del(&op_async->entry);\r\nif (op_async->operation)\r\ngb_operation_put(op_async->operation);\r\natomic_dec(&op_async->gb->outstanding_operations);\r\nwake_up(&op_async->gb->wq_completion);\r\nkfree(op_async);\r\n}\r\nstatic void gb_loopback_async_operation_get(struct gb_loopback_async_operation\r\n*op_async)\r\n{\r\nkref_get(&op_async->kref);\r\n}\r\nstatic void gb_loopback_async_operation_put(struct gb_loopback_async_operation\r\n*op_async)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&gb_dev.lock, flags);\r\nkref_put(&op_async->kref, __gb_loopback_async_operation_destroy);\r\nspin_unlock_irqrestore(&gb_dev.lock, flags);\r\n}\r\nstatic struct gb_loopback_async_operation *\r\ngb_loopback_operation_find(u16 id)\r\n{\r\nstruct gb_loopback_async_operation *op_async;\r\nbool found = false;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gb_dev.lock, flags);\r\nlist_for_each_entry(op_async, &gb_dev.list_op_async, entry) {\r\nif (op_async->operation->id == id) {\r\ngb_loopback_async_operation_get(op_async);\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&gb_dev.lock, flags);\r\nreturn found ? op_async : NULL;\r\n}\r\nstatic void gb_loopback_async_wait_all(struct gb_loopback *gb)\r\n{\r\nwait_event(gb->wq_completion,\r\n!atomic_read(&gb->outstanding_operations));\r\n}\r\nstatic void gb_loopback_async_operation_callback(struct gb_operation *operation)\r\n{\r\nstruct gb_loopback_async_operation *op_async;\r\nstruct gb_loopback *gb;\r\nstruct timeval te;\r\nbool err = false;\r\ndo_gettimeofday(&te);\r\nop_async = gb_loopback_operation_find(operation->id);\r\nif (!op_async)\r\nreturn;\r\ngb = op_async->gb;\r\nmutex_lock(&gb->mutex);\r\nif (!op_async->pending || gb_operation_result(operation)) {\r\nerr = true;\r\n} else {\r\nif (op_async->completion)\r\nif (op_async->completion(op_async))\r\nerr = true;\r\n}\r\nif (!err) {\r\ngb_loopback_push_latency_ts(gb, &op_async->ts, &te);\r\ngb->elapsed_nsecs = gb_loopback_calc_latency(&op_async->ts,\r\n&te);\r\n}\r\nif (op_async->pending) {\r\nif (err)\r\ngb->error++;\r\ngb->iteration_count++;\r\nop_async->pending = false;\r\ndel_timer_sync(&op_async->timer);\r\ngb_loopback_async_operation_put(op_async);\r\ngb_loopback_calculate_stats(gb, err);\r\n}\r\nmutex_unlock(&gb->mutex);\r\ndev_dbg(&gb->connection->bundle->dev, "complete operation %d\n",\r\noperation->id);\r\ngb_loopback_async_operation_put(op_async);\r\n}\r\nstatic void gb_loopback_async_operation_work(struct work_struct *work)\r\n{\r\nstruct gb_loopback *gb;\r\nstruct gb_operation *operation;\r\nstruct gb_loopback_async_operation *op_async;\r\nop_async = container_of(work, struct gb_loopback_async_operation, work);\r\ngb = op_async->gb;\r\noperation = op_async->operation;\r\nmutex_lock(&gb->mutex);\r\nif (op_async->pending) {\r\ngb->requests_timedout++;\r\ngb->error++;\r\ngb->iteration_count++;\r\nop_async->pending = false;\r\ngb_loopback_async_operation_put(op_async);\r\ngb_loopback_calculate_stats(gb, true);\r\n}\r\nmutex_unlock(&gb->mutex);\r\ndev_dbg(&gb->connection->bundle->dev, "timeout operation %d\n",\r\noperation->id);\r\ngb_operation_cancel(operation, -ETIMEDOUT);\r\ngb_loopback_async_operation_put(op_async);\r\n}\r\nstatic void gb_loopback_async_operation_timeout(unsigned long data)\r\n{\r\nstruct gb_loopback_async_operation *op_async;\r\nu16 id = data;\r\nop_async = gb_loopback_operation_find(id);\r\nif (!op_async) {\r\npr_err("operation %d not found - time out ?\n", id);\r\nreturn;\r\n}\r\nschedule_work(&op_async->work);\r\n}\r\nstatic int gb_loopback_async_operation(struct gb_loopback *gb, int type,\r\nvoid *request, int request_size,\r\nint response_size,\r\nvoid *completion)\r\n{\r\nstruct gb_loopback_async_operation *op_async;\r\nstruct gb_operation *operation;\r\nint ret;\r\nunsigned long flags;\r\nop_async = kzalloc(sizeof(*op_async), GFP_KERNEL);\r\nif (!op_async)\r\nreturn -ENOMEM;\r\nINIT_WORK(&op_async->work, gb_loopback_async_operation_work);\r\nkref_init(&op_async->kref);\r\noperation = gb_operation_create(gb->connection, type, request_size,\r\nresponse_size, GFP_KERNEL);\r\nif (!operation) {\r\nkfree(op_async);\r\nreturn -ENOMEM;\r\n}\r\nif (request_size)\r\nmemcpy(operation->request->payload, request, request_size);\r\nop_async->gb = gb;\r\nop_async->operation = operation;\r\nop_async->completion = completion;\r\nspin_lock_irqsave(&gb_dev.lock, flags);\r\nlist_add_tail(&op_async->entry, &gb_dev.list_op_async);\r\nspin_unlock_irqrestore(&gb_dev.lock, flags);\r\ndo_gettimeofday(&op_async->ts);\r\nop_async->pending = true;\r\natomic_inc(&gb->outstanding_operations);\r\nmutex_lock(&gb->mutex);\r\nret = gb_operation_request_send(operation,\r\ngb_loopback_async_operation_callback,\r\n0,\r\nGFP_KERNEL);\r\nif (ret)\r\ngoto error;\r\nsetup_timer(&op_async->timer, gb_loopback_async_operation_timeout,\r\n(unsigned long)operation->id);\r\nop_async->timer.expires = jiffies + gb->jiffy_timeout;\r\nadd_timer(&op_async->timer);\r\ngoto done;\r\nerror:\r\ngb_loopback_async_operation_put(op_async);\r\ndone:\r\nmutex_unlock(&gb->mutex);\r\nreturn ret;\r\n}\r\nstatic int gb_loopback_sync_sink(struct gb_loopback *gb, u32 len)\r\n{\r\nstruct gb_loopback_transfer_request *request;\r\nint retval;\r\nrequest = kmalloc(len + sizeof(*request), GFP_KERNEL);\r\nif (!request)\r\nreturn -ENOMEM;\r\nrequest->len = cpu_to_le32(len);\r\nretval = gb_loopback_operation_sync(gb, GB_LOOPBACK_TYPE_SINK,\r\nrequest, len + sizeof(*request),\r\nNULL, 0);\r\nkfree(request);\r\nreturn retval;\r\n}\r\nstatic int gb_loopback_sync_transfer(struct gb_loopback *gb, u32 len)\r\n{\r\nstruct gb_loopback_transfer_request *request;\r\nstruct gb_loopback_transfer_response *response;\r\nint retval;\r\ngb->apbridge_latency_ts = 0;\r\ngb->gbphy_latency_ts = 0;\r\nrequest = kmalloc(len + sizeof(*request), GFP_KERNEL);\r\nif (!request)\r\nreturn -ENOMEM;\r\nresponse = kmalloc(len + sizeof(*response), GFP_KERNEL);\r\nif (!response) {\r\nkfree(request);\r\nreturn -ENOMEM;\r\n}\r\nmemset(request->data, 0x5A, len);\r\nrequest->len = cpu_to_le32(len);\r\nretval = gb_loopback_operation_sync(gb, GB_LOOPBACK_TYPE_TRANSFER,\r\nrequest, len + sizeof(*request),\r\nresponse, len + sizeof(*response));\r\nif (retval)\r\ngoto gb_error;\r\nif (memcmp(request->data, response->data, len)) {\r\ndev_err(&gb->connection->bundle->dev,\r\n"Loopback Data doesn't match\n");\r\nretval = -EREMOTEIO;\r\n}\r\ngb->apbridge_latency_ts = (u32)__le32_to_cpu(response->reserved0);\r\ngb->gbphy_latency_ts = (u32)__le32_to_cpu(response->reserved1);\r\ngb_error:\r\nkfree(request);\r\nkfree(response);\r\nreturn retval;\r\n}\r\nstatic int gb_loopback_sync_ping(struct gb_loopback *gb)\r\n{\r\nreturn gb_loopback_operation_sync(gb, GB_LOOPBACK_TYPE_PING,\r\nNULL, 0, NULL, 0);\r\n}\r\nstatic int gb_loopback_async_sink(struct gb_loopback *gb, u32 len)\r\n{\r\nstruct gb_loopback_transfer_request *request;\r\nint retval;\r\nrequest = kmalloc(len + sizeof(*request), GFP_KERNEL);\r\nif (!request)\r\nreturn -ENOMEM;\r\nrequest->len = cpu_to_le32(len);\r\nretval = gb_loopback_async_operation(gb, GB_LOOPBACK_TYPE_SINK,\r\nrequest, len + sizeof(*request),\r\n0, NULL);\r\nkfree(request);\r\nreturn retval;\r\n}\r\nstatic int gb_loopback_async_transfer_complete(\r\nstruct gb_loopback_async_operation *op_async)\r\n{\r\nstruct gb_loopback *gb;\r\nstruct gb_operation *operation;\r\nstruct gb_loopback_transfer_request *request;\r\nstruct gb_loopback_transfer_response *response;\r\nsize_t len;\r\nint retval = 0;\r\ngb = op_async->gb;\r\noperation = op_async->operation;\r\nrequest = operation->request->payload;\r\nresponse = operation->response->payload;\r\nlen = le32_to_cpu(request->len);\r\nif (memcmp(request->data, response->data, len)) {\r\ndev_err(&gb->connection->bundle->dev,\r\n"Loopback Data doesn't match operation id %d\n",\r\noperation->id);\r\nretval = -EREMOTEIO;\r\n} else {\r\ngb->apbridge_latency_ts =\r\n(u32)__le32_to_cpu(response->reserved0);\r\ngb->gbphy_latency_ts =\r\n(u32)__le32_to_cpu(response->reserved1);\r\n}\r\nreturn retval;\r\n}\r\nstatic int gb_loopback_async_transfer(struct gb_loopback *gb, u32 len)\r\n{\r\nstruct gb_loopback_transfer_request *request;\r\nint retval, response_len;\r\nrequest = kmalloc(len + sizeof(*request), GFP_KERNEL);\r\nif (!request)\r\nreturn -ENOMEM;\r\nmemset(request->data, 0x5A, len);\r\nrequest->len = cpu_to_le32(len);\r\nresponse_len = sizeof(struct gb_loopback_transfer_response);\r\nretval = gb_loopback_async_operation(gb, GB_LOOPBACK_TYPE_TRANSFER,\r\nrequest, len + sizeof(*request),\r\nlen + response_len,\r\ngb_loopback_async_transfer_complete);\r\nif (retval)\r\ngoto gb_error;\r\ngb_error:\r\nkfree(request);\r\nreturn retval;\r\n}\r\nstatic int gb_loopback_async_ping(struct gb_loopback *gb)\r\n{\r\nreturn gb_loopback_async_operation(gb, GB_LOOPBACK_TYPE_PING,\r\nNULL, 0, 0, NULL);\r\n}\r\nstatic int gb_loopback_request_handler(struct gb_operation *operation)\r\n{\r\nstruct gb_connection *connection = operation->connection;\r\nstruct gb_loopback_transfer_request *request;\r\nstruct gb_loopback_transfer_response *response;\r\nstruct device *dev = &connection->bundle->dev;\r\nsize_t len;\r\nswitch (operation->type) {\r\ncase GB_LOOPBACK_TYPE_PING:\r\ncase GB_LOOPBACK_TYPE_SINK:\r\nreturn 0;\r\ncase GB_LOOPBACK_TYPE_TRANSFER:\r\nif (operation->request->payload_size < sizeof(*request)) {\r\ndev_err(dev, "transfer request too small (%zu < %zu)\n",\r\noperation->request->payload_size,\r\nsizeof(*request));\r\nreturn -EINVAL;\r\n}\r\nrequest = operation->request->payload;\r\nlen = le32_to_cpu(request->len);\r\nif (len > gb_dev.size_max) {\r\ndev_err(dev, "transfer request too large (%zu > %zu)\n",\r\nlen, gb_dev.size_max);\r\nreturn -EINVAL;\r\n}\r\nif (!gb_operation_response_alloc(operation,\r\nlen + sizeof(*response), GFP_KERNEL)) {\r\ndev_err(dev, "error allocating response\n");\r\nreturn -ENOMEM;\r\n}\r\nresponse = operation->response->payload;\r\nresponse->len = cpu_to_le32(len);\r\nif (len)\r\nmemcpy(response->data, request->data, len);\r\nreturn 0;\r\ndefault:\r\ndev_err(dev, "unsupported request: %u\n", operation->type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void gb_loopback_reset_stats(struct gb_loopback *gb)\r\n{\r\nstruct gb_loopback_stats reset = {\r\n.min = U32_MAX,\r\n};\r\nmemcpy(&gb->latency, &reset,\r\nsizeof(struct gb_loopback_stats));\r\nmemcpy(&gb->throughput, &reset,\r\nsizeof(struct gb_loopback_stats));\r\nmemcpy(&gb->requests_per_second, &reset,\r\nsizeof(struct gb_loopback_stats));\r\nmemcpy(&gb->apbridge_unipro_latency, &reset,\r\nsizeof(struct gb_loopback_stats));\r\nmemcpy(&gb->gbphy_firmware_latency, &reset,\r\nsizeof(struct gb_loopback_stats));\r\ngb->apbridge_latency_ts = 0;\r\ngb->gbphy_latency_ts = 0;\r\nmemset(&gb->ts, 0, sizeof(struct timeval));\r\n}\r\nstatic void gb_loopback_update_stats(struct gb_loopback_stats *stats, u32 val)\r\n{\r\nif (stats->min > val)\r\nstats->min = val;\r\nif (stats->max < val)\r\nstats->max = val;\r\nstats->sum += val;\r\nstats->count++;\r\n}\r\nstatic void gb_loopback_update_stats_window(struct gb_loopback_stats *stats,\r\nu64 val, u32 count)\r\n{\r\nstats->sum += val;\r\nstats->count += count;\r\ndo_div(val, count);\r\nif (stats->min > val)\r\nstats->min = val;\r\nif (stats->max < val)\r\nstats->max = val;\r\n}\r\nstatic void gb_loopback_requests_update(struct gb_loopback *gb, u32 latency)\r\n{\r\nu64 req = gb->requests_completed * USEC_PER_SEC;\r\ngb_loopback_update_stats_window(&gb->requests_per_second, req, latency);\r\n}\r\nstatic void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)\r\n{\r\nu64 aggregate_size = sizeof(struct gb_operation_msg_hdr) * 2;\r\nswitch (gb->type) {\r\ncase GB_LOOPBACK_TYPE_PING:\r\nbreak;\r\ncase GB_LOOPBACK_TYPE_SINK:\r\naggregate_size += sizeof(struct gb_loopback_transfer_request) +\r\ngb->size;\r\nbreak;\r\ncase GB_LOOPBACK_TYPE_TRANSFER:\r\naggregate_size += sizeof(struct gb_loopback_transfer_request) +\r\nsizeof(struct gb_loopback_transfer_response) +\r\ngb->size * 2;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\naggregate_size *= gb->requests_completed;\r\naggregate_size *= USEC_PER_SEC;\r\ngb_loopback_update_stats_window(&gb->throughput, aggregate_size,\r\nlatency);\r\n}\r\nstatic void gb_loopback_calculate_latency_stats(struct gb_loopback *gb)\r\n{\r\nu32 lat;\r\nlat = gb_loopback_nsec_to_usec_latency(gb->elapsed_nsecs);\r\ngb_loopback_update_stats(&gb->latency, lat);\r\nkfifo_in(&gb->kfifo_lat, (unsigned char *)&lat, sizeof(lat));\r\ngb_loopback_update_stats(&gb->apbridge_unipro_latency,\r\ngb->apbridge_latency_ts);\r\ngb_loopback_update_stats(&gb->gbphy_firmware_latency,\r\ngb->gbphy_latency_ts);\r\n}\r\nstatic void gb_loopback_calculate_stats(struct gb_loopback *gb, bool error)\r\n{\r\nu64 nlat;\r\nu32 lat;\r\nstruct timeval te;\r\nif (!error) {\r\ngb->requests_completed++;\r\ngb_loopback_calculate_latency_stats(gb);\r\n}\r\ndo_gettimeofday(&te);\r\nnlat = gb_loopback_calc_latency(&gb->ts, &te);\r\nif (nlat >= NSEC_PER_SEC || gb->iteration_count == gb->iteration_max) {\r\nlat = gb_loopback_nsec_to_usec_latency(nlat);\r\ngb_loopback_throughput_update(gb, lat);\r\ngb_loopback_requests_update(gb, lat);\r\nif (gb->iteration_count != gb->iteration_max) {\r\ngb->ts = te;\r\ngb->requests_completed = 0;\r\n}\r\n}\r\n}\r\nstatic void gb_loopback_async_wait_to_send(struct gb_loopback *gb)\r\n{\r\nif (!(gb->async && gb->outstanding_operations_max))\r\nreturn;\r\nwait_event_interruptible(gb->wq_completion,\r\n(atomic_read(&gb->outstanding_operations) <\r\ngb->outstanding_operations_max) ||\r\nkthread_should_stop());\r\n}\r\nstatic int gb_loopback_fn(void *data)\r\n{\r\nint error = 0;\r\nint us_wait = 0;\r\nint type;\r\nint ret;\r\nu32 size;\r\nstruct gb_loopback *gb = data;\r\nstruct gb_bundle *bundle = gb->connection->bundle;\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\nreturn ret;\r\nwhile (1) {\r\nif (!gb->type) {\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nwait_event_interruptible(gb->wq, gb->type ||\r\nkthread_should_stop());\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (kthread_should_stop())\r\nbreak;\r\ngb_loopback_async_wait_to_send(gb);\r\nif (kthread_should_stop())\r\nbreak;\r\nmutex_lock(&gb->mutex);\r\nif (gb->send_count == gb->iteration_max) {\r\nmutex_unlock(&gb->mutex);\r\ngb_loopback_async_wait_all(gb);\r\nmutex_lock(&gb->mutex);\r\nif (gb->iteration_count == gb->iteration_max) {\r\ngb->type = 0;\r\ngb->send_count = 0;\r\nsysfs_notify(&gb->dev->kobj, NULL,\r\n"iteration_count");\r\ndev_dbg(&bundle->dev, "load test complete\n");\r\n} else {\r\ndev_dbg(&bundle->dev,\r\n"continuing on with new test set\n");\r\n}\r\nmutex_unlock(&gb->mutex);\r\ncontinue;\r\n}\r\nsize = gb->size;\r\nus_wait = gb->us_wait;\r\ntype = gb->type;\r\nif (gb->ts.tv_usec == 0 && gb->ts.tv_sec == 0)\r\ndo_gettimeofday(&gb->ts);\r\nmutex_unlock(&gb->mutex);\r\nif (gb->async) {\r\nif (type == GB_LOOPBACK_TYPE_PING)\r\nerror = gb_loopback_async_ping(gb);\r\nelse if (type == GB_LOOPBACK_TYPE_TRANSFER)\r\nerror = gb_loopback_async_transfer(gb, size);\r\nelse if (type == GB_LOOPBACK_TYPE_SINK)\r\nerror = gb_loopback_async_sink(gb, size);\r\nif (error)\r\ngb->error++;\r\n} else {\r\nif (type == GB_LOOPBACK_TYPE_PING)\r\nerror = gb_loopback_sync_ping(gb);\r\nelse if (type == GB_LOOPBACK_TYPE_TRANSFER)\r\nerror = gb_loopback_sync_transfer(gb, size);\r\nelse if (type == GB_LOOPBACK_TYPE_SINK)\r\nerror = gb_loopback_sync_sink(gb, size);\r\nif (error)\r\ngb->error++;\r\ngb->iteration_count++;\r\ngb_loopback_calculate_stats(gb, !!error);\r\n}\r\ngb->send_count++;\r\nif (us_wait) {\r\nif (us_wait < 20000)\r\nusleep_range(us_wait, us_wait + 100);\r\nelse\r\nmsleep(us_wait / 1000);\r\n}\r\n}\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn 0;\r\n}\r\nstatic int gb_loopback_dbgfs_latency_show_common(struct seq_file *s,\r\nstruct kfifo *kfifo,\r\nstruct mutex *mutex)\r\n{\r\nu32 latency;\r\nint retval;\r\nif (kfifo_len(kfifo) == 0) {\r\nretval = -EAGAIN;\r\ngoto done;\r\n}\r\nmutex_lock(mutex);\r\nretval = kfifo_out(kfifo, &latency, sizeof(latency));\r\nif (retval > 0) {\r\nseq_printf(s, "%u", latency);\r\nretval = 0;\r\n}\r\nmutex_unlock(mutex);\r\ndone:\r\nreturn retval;\r\n}\r\nstatic int gb_loopback_dbgfs_latency_show(struct seq_file *s, void *unused)\r\n{\r\nstruct gb_loopback *gb = s->private;\r\nreturn gb_loopback_dbgfs_latency_show_common(s, &gb->kfifo_lat,\r\n&gb->mutex);\r\n}\r\nstatic int gb_loopback_latency_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, gb_loopback_dbgfs_latency_show,\r\ninode->i_private);\r\n}\r\nstatic int gb_loopback_bus_id_compare(void *priv, struct list_head *lha,\r\nstruct list_head *lhb)\r\n{\r\nstruct gb_loopback *a = list_entry(lha, struct gb_loopback, entry);\r\nstruct gb_loopback *b = list_entry(lhb, struct gb_loopback, entry);\r\nstruct gb_connection *ca = a->connection;\r\nstruct gb_connection *cb = b->connection;\r\nif (ca->bundle->intf->interface_id < cb->bundle->intf->interface_id)\r\nreturn -1;\r\nif (cb->bundle->intf->interface_id < ca->bundle->intf->interface_id)\r\nreturn 1;\r\nif (ca->bundle->id < cb->bundle->id)\r\nreturn -1;\r\nif (cb->bundle->id < ca->bundle->id)\r\nreturn 1;\r\nif (ca->intf_cport_id < cb->intf_cport_id)\r\nreturn -1;\r\nelse if (cb->intf_cport_id < ca->intf_cport_id)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void gb_loopback_insert_id(struct gb_loopback *gb)\r\n{\r\nstruct gb_loopback *gb_list;\r\nu32 new_lbid = 0;\r\nlist_add_tail(&gb->entry, &gb_dev.list);\r\nlist_sort(NULL, &gb_dev.list, gb_loopback_bus_id_compare);\r\nlist_for_each_entry(gb_list, &gb_dev.list, entry) {\r\ngb_list->lbid = 1 << new_lbid;\r\nnew_lbid++;\r\n}\r\n}\r\nstatic int gb_loopback_probe(struct gb_bundle *bundle,\r\nconst struct greybus_bundle_id *id)\r\n{\r\nstruct greybus_descriptor_cport *cport_desc;\r\nstruct gb_connection *connection;\r\nstruct gb_loopback *gb;\r\nstruct device *dev;\r\nint retval;\r\nchar name[DEBUGFS_NAMELEN];\r\nunsigned long flags;\r\nif (bundle->num_cports != 1)\r\nreturn -ENODEV;\r\ncport_desc = &bundle->cport_desc[0];\r\nif (cport_desc->protocol_id != GREYBUS_PROTOCOL_LOOPBACK)\r\nreturn -ENODEV;\r\ngb = kzalloc(sizeof(*gb), GFP_KERNEL);\r\nif (!gb)\r\nreturn -ENOMEM;\r\nconnection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),\r\ngb_loopback_request_handler);\r\nif (IS_ERR(connection)) {\r\nretval = PTR_ERR(connection);\r\ngoto out_kzalloc;\r\n}\r\ngb->connection = connection;\r\ngreybus_set_drvdata(bundle, gb);\r\ninit_waitqueue_head(&gb->wq);\r\ninit_waitqueue_head(&gb->wq_completion);\r\natomic_set(&gb->outstanding_operations, 0);\r\ngb_loopback_reset_stats(gb);\r\ngb->timeout_min = jiffies_to_usecs(GB_LOOPBACK_TIMEOUT_MIN);\r\ngb->timeout_max = jiffies_to_usecs(GB_LOOPBACK_TIMEOUT_MAX);\r\nif (!gb_dev.count) {\r\ngb_dev.size_max = gb_operation_get_payload_size_max(connection);\r\nif (gb_dev.size_max <=\r\nsizeof(struct gb_loopback_transfer_request)) {\r\nretval = -EINVAL;\r\ngoto out_connection_destroy;\r\n}\r\ngb_dev.size_max -= sizeof(struct gb_loopback_transfer_request);\r\n}\r\nsnprintf(name, sizeof(name), "raw_latency_%s",\r\ndev_name(&connection->bundle->dev));\r\ngb->file = debugfs_create_file(name, S_IFREG | 0444, gb_dev.root, gb,\r\n&gb_loopback_debugfs_latency_ops);\r\ngb->id = ida_simple_get(&loopback_ida, 0, 0, GFP_KERNEL);\r\nif (gb->id < 0) {\r\nretval = gb->id;\r\ngoto out_debugfs_remove;\r\n}\r\nretval = gb_connection_enable(connection);\r\nif (retval)\r\ngoto out_ida_remove;\r\ndev = device_create_with_groups(&loopback_class,\r\n&connection->bundle->dev,\r\nMKDEV(0, 0), gb, loopback_groups,\r\n"gb_loopback%d", gb->id);\r\nif (IS_ERR(dev)) {\r\nretval = PTR_ERR(dev);\r\ngoto out_connection_disable;\r\n}\r\ngb->dev = dev;\r\nif (kfifo_alloc(&gb->kfifo_lat, kfifo_depth * sizeof(u32),\r\nGFP_KERNEL)) {\r\nretval = -ENOMEM;\r\ngoto out_conn;\r\n}\r\nif (kfifo_alloc(&gb->kfifo_ts, kfifo_depth * sizeof(struct timeval) * 2,\r\nGFP_KERNEL)) {\r\nretval = -ENOMEM;\r\ngoto out_kfifo0;\r\n}\r\nmutex_init(&gb->mutex);\r\ngb->task = kthread_run(gb_loopback_fn, gb, "gb_loopback");\r\nif (IS_ERR(gb->task)) {\r\nretval = PTR_ERR(gb->task);\r\ngoto out_kfifo1;\r\n}\r\nspin_lock_irqsave(&gb_dev.lock, flags);\r\ngb_loopback_insert_id(gb);\r\ngb_dev.count++;\r\nspin_unlock_irqrestore(&gb_dev.lock, flags);\r\ngb_connection_latency_tag_enable(connection);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn 0;\r\nout_kfifo1:\r\nkfifo_free(&gb->kfifo_ts);\r\nout_kfifo0:\r\nkfifo_free(&gb->kfifo_lat);\r\nout_conn:\r\ndevice_unregister(dev);\r\nout_connection_disable:\r\ngb_connection_disable(connection);\r\nout_ida_remove:\r\nida_simple_remove(&loopback_ida, gb->id);\r\nout_debugfs_remove:\r\ndebugfs_remove(gb->file);\r\nout_connection_destroy:\r\ngb_connection_destroy(connection);\r\nout_kzalloc:\r\nkfree(gb);\r\nreturn retval;\r\n}\r\nstatic void gb_loopback_disconnect(struct gb_bundle *bundle)\r\n{\r\nstruct gb_loopback *gb = greybus_get_drvdata(bundle);\r\nunsigned long flags;\r\nint ret;\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\ngb_pm_runtime_get_noresume(bundle);\r\ngb_connection_disable(gb->connection);\r\nif (!IS_ERR_OR_NULL(gb->task))\r\nkthread_stop(gb->task);\r\nkfifo_free(&gb->kfifo_lat);\r\nkfifo_free(&gb->kfifo_ts);\r\ngb_connection_latency_tag_disable(gb->connection);\r\ndebugfs_remove(gb->file);\r\ngb_loopback_async_wait_all(gb);\r\nspin_lock_irqsave(&gb_dev.lock, flags);\r\ngb_dev.count--;\r\nlist_del(&gb->entry);\r\nspin_unlock_irqrestore(&gb_dev.lock, flags);\r\ndevice_unregister(gb->dev);\r\nida_simple_remove(&loopback_ida, gb->id);\r\ngb_connection_destroy(gb->connection);\r\nkfree(gb);\r\n}\r\nstatic int loopback_init(void)\r\n{\r\nint retval;\r\nINIT_LIST_HEAD(&gb_dev.list);\r\nINIT_LIST_HEAD(&gb_dev.list_op_async);\r\nspin_lock_init(&gb_dev.lock);\r\ngb_dev.root = debugfs_create_dir("gb_loopback", NULL);\r\nretval = class_register(&loopback_class);\r\nif (retval)\r\ngoto err;\r\nretval = greybus_register(&gb_loopback_driver);\r\nif (retval)\r\ngoto err_unregister;\r\nreturn 0;\r\nerr_unregister:\r\nclass_unregister(&loopback_class);\r\nerr:\r\ndebugfs_remove_recursive(gb_dev.root);\r\nreturn retval;\r\n}\r\nstatic void __exit loopback_exit(void)\r\n{\r\ndebugfs_remove_recursive(gb_dev.root);\r\ngreybus_deregister(&gb_loopback_driver);\r\nclass_unregister(&loopback_class);\r\nida_destroy(&loopback_ida);\r\n}
