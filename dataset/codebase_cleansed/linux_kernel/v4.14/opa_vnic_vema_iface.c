void opa_vnic_vema_report_event(struct opa_vnic_adapter *adapter, u8 event)\r\n{\r\nstruct __opa_veswport_info *info = &adapter->info;\r\nstruct __opa_veswport_trap trap_data;\r\ntrap_data.fabric_id = info->vesw.fabric_id;\r\ntrap_data.veswid = info->vesw.vesw_id;\r\ntrap_data.veswportnum = info->vport.port_num;\r\ntrap_data.opaportnum = adapter->port_num;\r\ntrap_data.veswportindex = adapter->vport_num;\r\ntrap_data.opcode = event;\r\nopa_vnic_vema_send_trap(adapter, &trap_data, info->vport.encap_slid);\r\n}\r\nvoid opa_vnic_get_summary_counters(struct opa_vnic_adapter *adapter,\r\nstruct opa_veswport_summary_counters *cntrs)\r\n{\r\nstruct opa_vnic_stats vstats;\r\n__be64 *dst;\r\nu64 *src;\r\nmemset(&vstats, 0, sizeof(vstats));\r\nspin_lock(&adapter->stats_lock);\r\nadapter->rn_ops->ndo_get_stats64(adapter->netdev, &vstats.netstats);\r\nspin_unlock(&adapter->stats_lock);\r\ncntrs->vp_instance = cpu_to_be16(adapter->vport_num);\r\ncntrs->vesw_id = cpu_to_be16(adapter->info.vesw.vesw_id);\r\ncntrs->veswport_num = cpu_to_be32(adapter->port_num);\r\ncntrs->tx_errors = cpu_to_be64(vstats.netstats.tx_errors);\r\ncntrs->rx_errors = cpu_to_be64(vstats.netstats.rx_errors);\r\ncntrs->tx_packets = cpu_to_be64(vstats.netstats.tx_packets);\r\ncntrs->rx_packets = cpu_to_be64(vstats.netstats.rx_packets);\r\ncntrs->tx_bytes = cpu_to_be64(vstats.netstats.tx_bytes);\r\ncntrs->rx_bytes = cpu_to_be64(vstats.netstats.rx_bytes);\r\nfor (dst = &cntrs->tx_unicast, src = &vstats.tx_grp.unicast;\r\ndst < &cntrs->reserved[0]; dst++, src++) {\r\n*dst = cpu_to_be64(*src);\r\n}\r\n}\r\nvoid opa_vnic_get_error_counters(struct opa_vnic_adapter *adapter,\r\nstruct opa_veswport_error_counters *cntrs)\r\n{\r\nstruct opa_vnic_stats vstats;\r\nmemset(&vstats, 0, sizeof(vstats));\r\nspin_lock(&adapter->stats_lock);\r\nadapter->rn_ops->ndo_get_stats64(adapter->netdev, &vstats.netstats);\r\nspin_unlock(&adapter->stats_lock);\r\ncntrs->vp_instance = cpu_to_be16(adapter->vport_num);\r\ncntrs->vesw_id = cpu_to_be16(adapter->info.vesw.vesw_id);\r\ncntrs->veswport_num = cpu_to_be32(adapter->port_num);\r\ncntrs->tx_errors = cpu_to_be64(vstats.netstats.tx_errors);\r\ncntrs->rx_errors = cpu_to_be64(vstats.netstats.rx_errors);\r\ncntrs->tx_dlid_zero = cpu_to_be64(vstats.tx_dlid_zero);\r\ncntrs->tx_drop_state = cpu_to_be64(vstats.tx_drop_state);\r\ncntrs->tx_logic = cpu_to_be64(vstats.netstats.tx_fifo_errors +\r\nvstats.netstats.tx_carrier_errors);\r\ncntrs->rx_bad_veswid = cpu_to_be64(vstats.netstats.rx_nohandler);\r\ncntrs->rx_runt = cpu_to_be64(vstats.rx_runt);\r\ncntrs->rx_oversize = cpu_to_be64(vstats.rx_oversize);\r\ncntrs->rx_drop_state = cpu_to_be64(vstats.rx_drop_state);\r\ncntrs->rx_logic = cpu_to_be64(vstats.netstats.rx_fifo_errors);\r\n}\r\nvoid opa_vnic_get_vesw_info(struct opa_vnic_adapter *adapter,\r\nstruct opa_vesw_info *info)\r\n{\r\nstruct __opa_vesw_info *src = &adapter->info.vesw;\r\nint i;\r\ninfo->fabric_id = cpu_to_be16(src->fabric_id);\r\ninfo->vesw_id = cpu_to_be16(src->vesw_id);\r\nmemcpy(info->rsvd0, src->rsvd0, ARRAY_SIZE(src->rsvd0));\r\ninfo->def_port_mask = cpu_to_be16(src->def_port_mask);\r\nmemcpy(info->rsvd1, src->rsvd1, ARRAY_SIZE(src->rsvd1));\r\ninfo->pkey = cpu_to_be16(src->pkey);\r\nmemcpy(info->rsvd2, src->rsvd2, ARRAY_SIZE(src->rsvd2));\r\ninfo->u_mcast_dlid = cpu_to_be32(src->u_mcast_dlid);\r\nfor (i = 0; i < OPA_VESW_MAX_NUM_DEF_PORT; i++)\r\ninfo->u_ucast_dlid[i] = cpu_to_be32(src->u_ucast_dlid[i]);\r\nmemcpy(info->rsvd3, src->rsvd3, ARRAY_SIZE(src->rsvd3));\r\nfor (i = 0; i < OPA_VNIC_MAX_NUM_PCP; i++)\r\ninfo->eth_mtu[i] = cpu_to_be16(src->eth_mtu[i]);\r\ninfo->eth_mtu_non_vlan = cpu_to_be16(src->eth_mtu_non_vlan);\r\nmemcpy(info->rsvd4, src->rsvd4, ARRAY_SIZE(src->rsvd4));\r\n}\r\nvoid opa_vnic_set_vesw_info(struct opa_vnic_adapter *adapter,\r\nstruct opa_vesw_info *info)\r\n{\r\nstruct __opa_vesw_info *dst = &adapter->info.vesw;\r\nint i;\r\ndst->fabric_id = be16_to_cpu(info->fabric_id);\r\ndst->vesw_id = be16_to_cpu(info->vesw_id);\r\nmemcpy(dst->rsvd0, info->rsvd0, ARRAY_SIZE(info->rsvd0));\r\ndst->def_port_mask = be16_to_cpu(info->def_port_mask);\r\nmemcpy(dst->rsvd1, info->rsvd1, ARRAY_SIZE(info->rsvd1));\r\ndst->pkey = be16_to_cpu(info->pkey);\r\nmemcpy(dst->rsvd2, info->rsvd2, ARRAY_SIZE(info->rsvd2));\r\ndst->u_mcast_dlid = be32_to_cpu(info->u_mcast_dlid);\r\nfor (i = 0; i < OPA_VESW_MAX_NUM_DEF_PORT; i++)\r\ndst->u_ucast_dlid[i] = be32_to_cpu(info->u_ucast_dlid[i]);\r\nmemcpy(dst->rsvd3, info->rsvd3, ARRAY_SIZE(info->rsvd3));\r\nfor (i = 0; i < OPA_VNIC_MAX_NUM_PCP; i++)\r\ndst->eth_mtu[i] = be16_to_cpu(info->eth_mtu[i]);\r\ndst->eth_mtu_non_vlan = be16_to_cpu(info->eth_mtu_non_vlan);\r\nmemcpy(dst->rsvd4, info->rsvd4, ARRAY_SIZE(info->rsvd4));\r\n}\r\nvoid opa_vnic_get_per_veswport_info(struct opa_vnic_adapter *adapter,\r\nstruct opa_per_veswport_info *info)\r\n{\r\nstruct __opa_per_veswport_info *src = &adapter->info.vport;\r\ninfo->port_num = cpu_to_be32(src->port_num);\r\ninfo->eth_link_status = src->eth_link_status;\r\nmemcpy(info->rsvd0, src->rsvd0, ARRAY_SIZE(src->rsvd0));\r\nmemcpy(info->base_mac_addr, src->base_mac_addr,\r\nARRAY_SIZE(info->base_mac_addr));\r\ninfo->config_state = src->config_state;\r\ninfo->oper_state = src->oper_state;\r\ninfo->max_mac_tbl_ent = cpu_to_be16(src->max_mac_tbl_ent);\r\ninfo->max_smac_ent = cpu_to_be16(src->max_smac_ent);\r\ninfo->mac_tbl_digest = cpu_to_be32(src->mac_tbl_digest);\r\nmemcpy(info->rsvd1, src->rsvd1, ARRAY_SIZE(src->rsvd1));\r\ninfo->encap_slid = cpu_to_be32(src->encap_slid);\r\nmemcpy(info->pcp_to_sc_uc, src->pcp_to_sc_uc,\r\nARRAY_SIZE(info->pcp_to_sc_uc));\r\nmemcpy(info->pcp_to_vl_uc, src->pcp_to_vl_uc,\r\nARRAY_SIZE(info->pcp_to_vl_uc));\r\nmemcpy(info->pcp_to_sc_mc, src->pcp_to_sc_mc,\r\nARRAY_SIZE(info->pcp_to_sc_mc));\r\nmemcpy(info->pcp_to_vl_mc, src->pcp_to_vl_mc,\r\nARRAY_SIZE(info->pcp_to_vl_mc));\r\ninfo->non_vlan_sc_uc = src->non_vlan_sc_uc;\r\ninfo->non_vlan_vl_uc = src->non_vlan_vl_uc;\r\ninfo->non_vlan_sc_mc = src->non_vlan_sc_mc;\r\ninfo->non_vlan_vl_mc = src->non_vlan_vl_mc;\r\nmemcpy(info->rsvd2, src->rsvd2, ARRAY_SIZE(src->rsvd2));\r\ninfo->uc_macs_gen_count = cpu_to_be16(src->uc_macs_gen_count);\r\ninfo->mc_macs_gen_count = cpu_to_be16(src->mc_macs_gen_count);\r\nmemcpy(info->rsvd3, src->rsvd3, ARRAY_SIZE(src->rsvd3));\r\n}\r\nvoid opa_vnic_set_per_veswport_info(struct opa_vnic_adapter *adapter,\r\nstruct opa_per_veswport_info *info)\r\n{\r\nstruct __opa_per_veswport_info *dst = &adapter->info.vport;\r\ndst->port_num = be32_to_cpu(info->port_num);\r\nmemcpy(dst->rsvd0, info->rsvd0, ARRAY_SIZE(info->rsvd0));\r\nmemcpy(dst->base_mac_addr, info->base_mac_addr,\r\nARRAY_SIZE(dst->base_mac_addr));\r\ndst->config_state = info->config_state;\r\nmemcpy(dst->rsvd1, info->rsvd1, ARRAY_SIZE(info->rsvd1));\r\ndst->encap_slid = be32_to_cpu(info->encap_slid);\r\nmemcpy(dst->pcp_to_sc_uc, info->pcp_to_sc_uc,\r\nARRAY_SIZE(dst->pcp_to_sc_uc));\r\nmemcpy(dst->pcp_to_vl_uc, info->pcp_to_vl_uc,\r\nARRAY_SIZE(dst->pcp_to_vl_uc));\r\nmemcpy(dst->pcp_to_sc_mc, info->pcp_to_sc_mc,\r\nARRAY_SIZE(dst->pcp_to_sc_mc));\r\nmemcpy(dst->pcp_to_vl_mc, info->pcp_to_vl_mc,\r\nARRAY_SIZE(dst->pcp_to_vl_mc));\r\ndst->non_vlan_sc_uc = info->non_vlan_sc_uc;\r\ndst->non_vlan_vl_uc = info->non_vlan_vl_uc;\r\ndst->non_vlan_sc_mc = info->non_vlan_sc_mc;\r\ndst->non_vlan_vl_mc = info->non_vlan_vl_mc;\r\nmemcpy(dst->rsvd2, info->rsvd2, ARRAY_SIZE(info->rsvd2));\r\nmemcpy(dst->rsvd3, info->rsvd3, ARRAY_SIZE(info->rsvd3));\r\n}\r\nvoid opa_vnic_query_mcast_macs(struct opa_vnic_adapter *adapter,\r\nstruct opa_veswport_iface_macs *macs)\r\n{\r\nu16 start_idx, num_macs, idx = 0, count = 0;\r\nstruct netdev_hw_addr *ha;\r\nstart_idx = be16_to_cpu(macs->start_idx);\r\nnum_macs = be16_to_cpu(macs->num_macs_in_msg);\r\nnetdev_for_each_mc_addr(ha, adapter->netdev) {\r\nstruct opa_vnic_iface_mac_entry *entry = &macs->entry[count];\r\nif (start_idx > idx++)\r\ncontinue;\r\nelse if (num_macs == count)\r\nbreak;\r\nmemcpy(entry, ha->addr, sizeof(*entry));\r\ncount++;\r\n}\r\nmacs->tot_macs_in_lst = cpu_to_be16(netdev_mc_count(adapter->netdev));\r\nmacs->num_macs_in_msg = cpu_to_be16(count);\r\nmacs->gen_count = cpu_to_be16(adapter->info.vport.mc_macs_gen_count);\r\n}\r\nvoid opa_vnic_query_ucast_macs(struct opa_vnic_adapter *adapter,\r\nstruct opa_veswport_iface_macs *macs)\r\n{\r\nu16 start_idx, tot_macs, num_macs, idx = 0, count = 0;\r\nstruct netdev_hw_addr *ha;\r\nstart_idx = be16_to_cpu(macs->start_idx);\r\nnum_macs = be16_to_cpu(macs->num_macs_in_msg);\r\nfor_each_dev_addr(adapter->netdev, ha) {\r\nstruct opa_vnic_iface_mac_entry *entry = &macs->entry[count];\r\nif (!memcmp(adapter->info.vport.base_mac_addr, ha->addr,\r\nARRAY_SIZE(adapter->info.vport.base_mac_addr)))\r\ncontinue;\r\nif (start_idx > idx++)\r\ncontinue;\r\nelse if (num_macs == count)\r\nbreak;\r\nmemcpy(entry, ha->addr, sizeof(*entry));\r\ncount++;\r\n}\r\nnetdev_for_each_uc_addr(ha, adapter->netdev) {\r\nstruct opa_vnic_iface_mac_entry *entry = &macs->entry[count];\r\nif (start_idx > idx++)\r\ncontinue;\r\nelse if (num_macs == count)\r\nbreak;\r\nmemcpy(entry, ha->addr, sizeof(*entry));\r\ncount++;\r\n}\r\ntot_macs = netdev_hw_addr_list_count(&adapter->netdev->dev_addrs) +\r\nnetdev_uc_count(adapter->netdev);\r\nmacs->tot_macs_in_lst = cpu_to_be16(tot_macs);\r\nmacs->num_macs_in_msg = cpu_to_be16(count);\r\nmacs->gen_count = cpu_to_be16(adapter->info.vport.uc_macs_gen_count);\r\n}
