static int of_thermal_get_temp(struct thermal_zone_device *tz,\r\nint *temp)\r\n{\r\nstruct __thermal_zone *data = tz->devdata;\r\nif (!data->ops->get_temp)\r\nreturn -EINVAL;\r\nreturn data->ops->get_temp(data->sensor_data, temp);\r\n}\r\nstatic int of_thermal_set_trips(struct thermal_zone_device *tz,\r\nint low, int high)\r\n{\r\nstruct __thermal_zone *data = tz->devdata;\r\nif (!data->ops || !data->ops->set_trips)\r\nreturn -EINVAL;\r\nreturn data->ops->set_trips(data->sensor_data, low, high);\r\n}\r\nint of_thermal_get_ntrips(struct thermal_zone_device *tz)\r\n{\r\nstruct __thermal_zone *data = tz->devdata;\r\nif (!data || IS_ERR(data))\r\nreturn -ENODEV;\r\nreturn data->ntrips;\r\n}\r\nbool of_thermal_is_trip_valid(struct thermal_zone_device *tz, int trip)\r\n{\r\nstruct __thermal_zone *data = tz->devdata;\r\nif (!data || trip >= data->ntrips || trip < 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nconst struct thermal_trip *\r\nof_thermal_get_trip_points(struct thermal_zone_device *tz)\r\n{\r\nstruct __thermal_zone *data = tz->devdata;\r\nif (!data)\r\nreturn NULL;\r\nreturn data->trips;\r\n}\r\nstatic int of_thermal_set_emul_temp(struct thermal_zone_device *tz,\r\nint temp)\r\n{\r\nstruct __thermal_zone *data = tz->devdata;\r\nreturn data->ops->set_emul_temp(data->sensor_data, temp);\r\n}\r\nstatic int of_thermal_get_trend(struct thermal_zone_device *tz, int trip,\r\nenum thermal_trend *trend)\r\n{\r\nstruct __thermal_zone *data = tz->devdata;\r\nif (!data->ops->get_trend)\r\nreturn -EINVAL;\r\nreturn data->ops->get_trend(data->sensor_data, trip, trend);\r\n}\r\nstatic int of_thermal_bind(struct thermal_zone_device *thermal,\r\nstruct thermal_cooling_device *cdev)\r\n{\r\nstruct __thermal_zone *data = thermal->devdata;\r\nint i;\r\nif (!data || IS_ERR(data))\r\nreturn -ENODEV;\r\nfor (i = 0; i < data->num_tbps; i++) {\r\nstruct __thermal_bind_params *tbp = data->tbps + i;\r\nif (tbp->cooling_device == cdev->np) {\r\nint ret;\r\nret = thermal_zone_bind_cooling_device(thermal,\r\ntbp->trip_id, cdev,\r\ntbp->max,\r\ntbp->min,\r\ntbp->usage);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int of_thermal_unbind(struct thermal_zone_device *thermal,\r\nstruct thermal_cooling_device *cdev)\r\n{\r\nstruct __thermal_zone *data = thermal->devdata;\r\nint i;\r\nif (!data || IS_ERR(data))\r\nreturn -ENODEV;\r\nfor (i = 0; i < data->num_tbps; i++) {\r\nstruct __thermal_bind_params *tbp = data->tbps + i;\r\nif (tbp->cooling_device == cdev->np) {\r\nint ret;\r\nret = thermal_zone_unbind_cooling_device(thermal,\r\ntbp->trip_id, cdev);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int of_thermal_get_mode(struct thermal_zone_device *tz,\r\nenum thermal_device_mode *mode)\r\n{\r\nstruct __thermal_zone *data = tz->devdata;\r\n*mode = data->mode;\r\nreturn 0;\r\n}\r\nstatic int of_thermal_set_mode(struct thermal_zone_device *tz,\r\nenum thermal_device_mode mode)\r\n{\r\nstruct __thermal_zone *data = tz->devdata;\r\nmutex_lock(&tz->lock);\r\nif (mode == THERMAL_DEVICE_ENABLED)\r\ntz->polling_delay = data->polling_delay;\r\nelse\r\ntz->polling_delay = 0;\r\nmutex_unlock(&tz->lock);\r\ndata->mode = mode;\r\nthermal_zone_device_update(tz, THERMAL_EVENT_UNSPECIFIED);\r\nreturn 0;\r\n}\r\nstatic int of_thermal_get_trip_type(struct thermal_zone_device *tz, int trip,\r\nenum thermal_trip_type *type)\r\n{\r\nstruct __thermal_zone *data = tz->devdata;\r\nif (trip >= data->ntrips || trip < 0)\r\nreturn -EDOM;\r\n*type = data->trips[trip].type;\r\nreturn 0;\r\n}\r\nstatic int of_thermal_get_trip_temp(struct thermal_zone_device *tz, int trip,\r\nint *temp)\r\n{\r\nstruct __thermal_zone *data = tz->devdata;\r\nif (trip >= data->ntrips || trip < 0)\r\nreturn -EDOM;\r\n*temp = data->trips[trip].temperature;\r\nreturn 0;\r\n}\r\nstatic int of_thermal_set_trip_temp(struct thermal_zone_device *tz, int trip,\r\nint temp)\r\n{\r\nstruct __thermal_zone *data = tz->devdata;\r\nif (trip >= data->ntrips || trip < 0)\r\nreturn -EDOM;\r\nif (data->ops->set_trip_temp) {\r\nint ret;\r\nret = data->ops->set_trip_temp(data->sensor_data, trip, temp);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndata->trips[trip].temperature = temp;\r\nreturn 0;\r\n}\r\nstatic int of_thermal_get_trip_hyst(struct thermal_zone_device *tz, int trip,\r\nint *hyst)\r\n{\r\nstruct __thermal_zone *data = tz->devdata;\r\nif (trip >= data->ntrips || trip < 0)\r\nreturn -EDOM;\r\n*hyst = data->trips[trip].hysteresis;\r\nreturn 0;\r\n}\r\nstatic int of_thermal_set_trip_hyst(struct thermal_zone_device *tz, int trip,\r\nint hyst)\r\n{\r\nstruct __thermal_zone *data = tz->devdata;\r\nif (trip >= data->ntrips || trip < 0)\r\nreturn -EDOM;\r\ndata->trips[trip].hysteresis = hyst;\r\nreturn 0;\r\n}\r\nstatic int of_thermal_get_crit_temp(struct thermal_zone_device *tz,\r\nint *temp)\r\n{\r\nstruct __thermal_zone *data = tz->devdata;\r\nint i;\r\nfor (i = 0; i < data->ntrips; i++)\r\nif (data->trips[i].type == THERMAL_TRIP_CRITICAL) {\r\n*temp = data->trips[i].temperature;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic struct thermal_zone_device *\r\nthermal_zone_of_add_sensor(struct device_node *zone,\r\nstruct device_node *sensor, void *data,\r\nconst struct thermal_zone_of_device_ops *ops)\r\n{\r\nstruct thermal_zone_device *tzd;\r\nstruct __thermal_zone *tz;\r\ntzd = thermal_zone_get_zone_by_name(zone->name);\r\nif (IS_ERR(tzd))\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\ntz = tzd->devdata;\r\nif (!ops)\r\nreturn ERR_PTR(-EINVAL);\r\nmutex_lock(&tzd->lock);\r\ntz->ops = ops;\r\ntz->sensor_data = data;\r\ntzd->ops->get_temp = of_thermal_get_temp;\r\ntzd->ops->get_trend = of_thermal_get_trend;\r\nif (ops->set_trips)\r\ntzd->ops->set_trips = of_thermal_set_trips;\r\nif (ops->set_emul_temp)\r\ntzd->ops->set_emul_temp = of_thermal_set_emul_temp;\r\nmutex_unlock(&tzd->lock);\r\nreturn tzd;\r\n}\r\nstruct thermal_zone_device *\r\nthermal_zone_of_sensor_register(struct device *dev, int sensor_id, void *data,\r\nconst struct thermal_zone_of_device_ops *ops)\r\n{\r\nstruct device_node *np, *child, *sensor_np;\r\nstruct thermal_zone_device *tzd = ERR_PTR(-ENODEV);\r\nnp = of_find_node_by_name(NULL, "thermal-zones");\r\nif (!np)\r\nreturn ERR_PTR(-ENODEV);\r\nif (!dev || !dev->of_node) {\r\nof_node_put(np);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nsensor_np = of_node_get(dev->of_node);\r\nfor_each_available_child_of_node(np, child) {\r\nstruct of_phandle_args sensor_specs;\r\nint ret, id;\r\nret = of_parse_phandle_with_args(child, "thermal-sensors",\r\n"#thermal-sensor-cells",\r\n0, &sensor_specs);\r\nif (ret)\r\ncontinue;\r\nif (sensor_specs.args_count >= 1) {\r\nid = sensor_specs.args[0];\r\nWARN(sensor_specs.args_count > 1,\r\n"%s: too many cells in sensor specifier %d\n",\r\nsensor_specs.np->name, sensor_specs.args_count);\r\n} else {\r\nid = 0;\r\n}\r\nif (sensor_specs.np == sensor_np && id == sensor_id) {\r\ntzd = thermal_zone_of_add_sensor(child, sensor_np,\r\ndata, ops);\r\nif (!IS_ERR(tzd))\r\ntzd->ops->set_mode(tzd, THERMAL_DEVICE_ENABLED);\r\nof_node_put(sensor_specs.np);\r\nof_node_put(child);\r\ngoto exit;\r\n}\r\nof_node_put(sensor_specs.np);\r\n}\r\nexit:\r\nof_node_put(sensor_np);\r\nof_node_put(np);\r\nreturn tzd;\r\n}\r\nvoid thermal_zone_of_sensor_unregister(struct device *dev,\r\nstruct thermal_zone_device *tzd)\r\n{\r\nstruct __thermal_zone *tz;\r\nif (!dev || !tzd || !tzd->devdata)\r\nreturn;\r\ntz = tzd->devdata;\r\nif (!tz)\r\nreturn;\r\nmutex_lock(&tzd->lock);\r\ntzd->ops->get_temp = NULL;\r\ntzd->ops->get_trend = NULL;\r\ntzd->ops->set_emul_temp = NULL;\r\ntz->ops = NULL;\r\ntz->sensor_data = NULL;\r\nmutex_unlock(&tzd->lock);\r\n}\r\nstatic void devm_thermal_zone_of_sensor_release(struct device *dev, void *res)\r\n{\r\nthermal_zone_of_sensor_unregister(dev,\r\n*(struct thermal_zone_device **)res);\r\n}\r\nstatic int devm_thermal_zone_of_sensor_match(struct device *dev, void *res,\r\nvoid *data)\r\n{\r\nstruct thermal_zone_device **r = res;\r\nif (WARN_ON(!r || !*r))\r\nreturn 0;\r\nreturn *r == data;\r\n}\r\nstruct thermal_zone_device *devm_thermal_zone_of_sensor_register(\r\nstruct device *dev, int sensor_id,\r\nvoid *data, const struct thermal_zone_of_device_ops *ops)\r\n{\r\nstruct thermal_zone_device **ptr, *tzd;\r\nptr = devres_alloc(devm_thermal_zone_of_sensor_release, sizeof(*ptr),\r\nGFP_KERNEL);\r\nif (!ptr)\r\nreturn ERR_PTR(-ENOMEM);\r\ntzd = thermal_zone_of_sensor_register(dev, sensor_id, data, ops);\r\nif (IS_ERR(tzd)) {\r\ndevres_free(ptr);\r\nreturn tzd;\r\n}\r\n*ptr = tzd;\r\ndevres_add(dev, ptr);\r\nreturn tzd;\r\n}\r\nvoid devm_thermal_zone_of_sensor_unregister(struct device *dev,\r\nstruct thermal_zone_device *tzd)\r\n{\r\nWARN_ON(devres_release(dev, devm_thermal_zone_of_sensor_release,\r\ndevm_thermal_zone_of_sensor_match, tzd));\r\n}\r\nstatic int thermal_of_populate_bind_params(struct device_node *np,\r\nstruct __thermal_bind_params *__tbp,\r\nstruct thermal_trip *trips,\r\nint ntrips)\r\n{\r\nstruct of_phandle_args cooling_spec;\r\nstruct device_node *trip;\r\nint ret, i;\r\nu32 prop;\r\n__tbp->usage = THERMAL_WEIGHT_DEFAULT;\r\nret = of_property_read_u32(np, "contribution", &prop);\r\nif (ret == 0)\r\n__tbp->usage = prop;\r\ntrip = of_parse_phandle(np, "trip", 0);\r\nif (!trip) {\r\npr_err("missing trip property\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < ntrips; i++)\r\nif (trip == trips[i].np) {\r\n__tbp->trip_id = i;\r\nbreak;\r\n}\r\nif (i == ntrips) {\r\nret = -ENODEV;\r\ngoto end;\r\n}\r\nret = of_parse_phandle_with_args(np, "cooling-device", "#cooling-cells",\r\n0, &cooling_spec);\r\nif (ret < 0) {\r\npr_err("missing cooling_device property\n");\r\ngoto end;\r\n}\r\n__tbp->cooling_device = cooling_spec.np;\r\nif (cooling_spec.args_count >= 2) {\r\n__tbp->min = cooling_spec.args[0];\r\n__tbp->max = cooling_spec.args[1];\r\n} else {\r\npr_err("wrong reference to cooling device, missing limits\n");\r\n}\r\nend:\r\nof_node_put(trip);\r\nreturn ret;\r\n}\r\nstatic int thermal_of_get_trip_type(struct device_node *np,\r\nenum thermal_trip_type *type)\r\n{\r\nconst char *t;\r\nint err, i;\r\nerr = of_property_read_string(np, "type", &t);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < ARRAY_SIZE(trip_types); i++)\r\nif (!strcasecmp(t, trip_types[i])) {\r\n*type = i;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int thermal_of_populate_trip(struct device_node *np,\r\nstruct thermal_trip *trip)\r\n{\r\nint prop;\r\nint ret;\r\nret = of_property_read_u32(np, "temperature", &prop);\r\nif (ret < 0) {\r\npr_err("missing temperature property\n");\r\nreturn ret;\r\n}\r\ntrip->temperature = prop;\r\nret = of_property_read_u32(np, "hysteresis", &prop);\r\nif (ret < 0) {\r\npr_err("missing hysteresis property\n");\r\nreturn ret;\r\n}\r\ntrip->hysteresis = prop;\r\nret = thermal_of_get_trip_type(np, &trip->type);\r\nif (ret < 0) {\r\npr_err("wrong trip type property\n");\r\nreturn ret;\r\n}\r\ntrip->np = np;\r\nof_node_get(np);\r\nreturn 0;\r\n}\r\nstatic struct __thermal_zone\r\n__init *thermal_of_build_thermal_zone(struct device_node *np)\r\n{\r\nstruct device_node *child = NULL, *gchild;\r\nstruct __thermal_zone *tz;\r\nint ret, i;\r\nu32 prop, coef[2];\r\nif (!np) {\r\npr_err("no thermal zone np\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ntz = kzalloc(sizeof(*tz), GFP_KERNEL);\r\nif (!tz)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = of_property_read_u32(np, "polling-delay-passive", &prop);\r\nif (ret < 0) {\r\npr_err("missing polling-delay-passive property\n");\r\ngoto free_tz;\r\n}\r\ntz->passive_delay = prop;\r\nret = of_property_read_u32(np, "polling-delay", &prop);\r\nif (ret < 0) {\r\npr_err("missing polling-delay property\n");\r\ngoto free_tz;\r\n}\r\ntz->polling_delay = prop;\r\nret = of_property_read_u32_array(np, "coefficients", coef, 2);\r\nif (ret == 0) {\r\ntz->slope = coef[0];\r\ntz->offset = coef[1];\r\n} else {\r\ntz->slope = 1;\r\ntz->offset = 0;\r\n}\r\nchild = of_get_child_by_name(np, "trips");\r\nif (!child)\r\ngoto finish;\r\ntz->ntrips = of_get_child_count(child);\r\nif (tz->ntrips == 0)\r\ngoto finish;\r\ntz->trips = kzalloc(tz->ntrips * sizeof(*tz->trips), GFP_KERNEL);\r\nif (!tz->trips) {\r\nret = -ENOMEM;\r\ngoto free_tz;\r\n}\r\ni = 0;\r\nfor_each_child_of_node(child, gchild) {\r\nret = thermal_of_populate_trip(gchild, &tz->trips[i++]);\r\nif (ret)\r\ngoto free_trips;\r\n}\r\nof_node_put(child);\r\nchild = of_get_child_by_name(np, "cooling-maps");\r\nif (!child)\r\ngoto finish;\r\ntz->num_tbps = of_get_child_count(child);\r\nif (tz->num_tbps == 0)\r\ngoto finish;\r\ntz->tbps = kzalloc(tz->num_tbps * sizeof(*tz->tbps), GFP_KERNEL);\r\nif (!tz->tbps) {\r\nret = -ENOMEM;\r\ngoto free_trips;\r\n}\r\ni = 0;\r\nfor_each_child_of_node(child, gchild) {\r\nret = thermal_of_populate_bind_params(gchild, &tz->tbps[i++],\r\ntz->trips, tz->ntrips);\r\nif (ret)\r\ngoto free_tbps;\r\n}\r\nfinish:\r\nof_node_put(child);\r\ntz->mode = THERMAL_DEVICE_DISABLED;\r\nreturn tz;\r\nfree_tbps:\r\nfor (i = i - 1; i >= 0; i--)\r\nof_node_put(tz->tbps[i].cooling_device);\r\nkfree(tz->tbps);\r\nfree_trips:\r\nfor (i = 0; i < tz->ntrips; i++)\r\nof_node_put(tz->trips[i].np);\r\nkfree(tz->trips);\r\nof_node_put(gchild);\r\nfree_tz:\r\nkfree(tz);\r\nof_node_put(child);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic inline void of_thermal_free_zone(struct __thermal_zone *tz)\r\n{\r\nint i;\r\nfor (i = 0; i < tz->num_tbps; i++)\r\nof_node_put(tz->tbps[i].cooling_device);\r\nkfree(tz->tbps);\r\nfor (i = 0; i < tz->ntrips; i++)\r\nof_node_put(tz->trips[i].np);\r\nkfree(tz->trips);\r\nkfree(tz);\r\n}\r\nint __init of_parse_thermal_zones(void)\r\n{\r\nstruct device_node *np, *child;\r\nstruct __thermal_zone *tz;\r\nstruct thermal_zone_device_ops *ops;\r\nnp = of_find_node_by_name(NULL, "thermal-zones");\r\nif (!np) {\r\npr_debug("unable to find thermal zones\n");\r\nreturn 0;\r\n}\r\nfor_each_available_child_of_node(np, child) {\r\nstruct thermal_zone_device *zone;\r\nstruct thermal_zone_params *tzp;\r\nint i, mask = 0;\r\nu32 prop;\r\ntz = thermal_of_build_thermal_zone(child);\r\nif (IS_ERR(tz)) {\r\npr_err("failed to build thermal zone %s: %ld\n",\r\nchild->name,\r\nPTR_ERR(tz));\r\ncontinue;\r\n}\r\nops = kmemdup(&of_thermal_ops, sizeof(*ops), GFP_KERNEL);\r\nif (!ops)\r\ngoto exit_free;\r\ntzp = kzalloc(sizeof(*tzp), GFP_KERNEL);\r\nif (!tzp) {\r\nkfree(ops);\r\ngoto exit_free;\r\n}\r\ntzp->no_hwmon = true;\r\nif (!of_property_read_u32(child, "sustainable-power", &prop))\r\ntzp->sustainable_power = prop;\r\nfor (i = 0; i < tz->ntrips; i++)\r\nmask |= 1 << i;\r\ntzp->slope = tz->slope;\r\ntzp->offset = tz->offset;\r\nzone = thermal_zone_device_register(child->name, tz->ntrips,\r\nmask, tz,\r\nops, tzp,\r\ntz->passive_delay,\r\ntz->polling_delay);\r\nif (IS_ERR(zone)) {\r\npr_err("Failed to build %s zone %ld\n", child->name,\r\nPTR_ERR(zone));\r\nkfree(tzp);\r\nkfree(ops);\r\nof_thermal_free_zone(tz);\r\n}\r\n}\r\nof_node_put(np);\r\nreturn 0;\r\nexit_free:\r\nof_node_put(child);\r\nof_node_put(np);\r\nof_thermal_free_zone(tz);\r\nof_thermal_destroy_zones();\r\nreturn -ENOMEM;\r\n}\r\nvoid of_thermal_destroy_zones(void)\r\n{\r\nstruct device_node *np, *child;\r\nnp = of_find_node_by_name(NULL, "thermal-zones");\r\nif (!np) {\r\npr_debug("unable to find thermal zones\n");\r\nreturn;\r\n}\r\nfor_each_available_child_of_node(np, child) {\r\nstruct thermal_zone_device *zone;\r\nzone = thermal_zone_get_zone_by_name(child->name);\r\nif (IS_ERR(zone))\r\ncontinue;\r\nthermal_zone_device_unregister(zone);\r\nkfree(zone->tzp);\r\nkfree(zone->ops);\r\nof_thermal_free_zone(zone->devdata);\r\n}\r\nof_node_put(np);\r\n}
