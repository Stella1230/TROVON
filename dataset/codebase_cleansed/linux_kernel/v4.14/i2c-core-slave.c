int i2c_slave_register(struct i2c_client *client, i2c_slave_cb_t slave_cb)\r\n{\r\nint ret;\r\nif (!client || !slave_cb) {\r\nWARN(1, "insufficient data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(client->flags & I2C_CLIENT_SLAVE))\r\ndev_warn(&client->dev, "%s: client slave flag not set. You might see address collisions\n",\r\n__func__);\r\nif (!(client->flags & I2C_CLIENT_TEN)) {\r\nret = i2c_check_7bit_addr_validity_strict(client->addr);\r\nif (ret) {\r\ndev_err(&client->dev, "%s: invalid address\n", __func__);\r\nreturn ret;\r\n}\r\n}\r\nif (!client->adapter->algo->reg_slave) {\r\ndev_err(&client->dev, "%s: not supported by adapter\n", __func__);\r\nreturn -EOPNOTSUPP;\r\n}\r\nclient->slave_cb = slave_cb;\r\ni2c_lock_adapter(client->adapter);\r\nret = client->adapter->algo->reg_slave(client);\r\ni2c_unlock_adapter(client->adapter);\r\nif (ret) {\r\nclient->slave_cb = NULL;\r\ndev_err(&client->dev, "%s: adapter returned error %d\n", __func__, ret);\r\n}\r\nreturn ret;\r\n}\r\nint i2c_slave_unregister(struct i2c_client *client)\r\n{\r\nint ret;\r\nif (!client->adapter->algo->unreg_slave) {\r\ndev_err(&client->dev, "%s: not supported by adapter\n", __func__);\r\nreturn -EOPNOTSUPP;\r\n}\r\ni2c_lock_adapter(client->adapter);\r\nret = client->adapter->algo->unreg_slave(client);\r\ni2c_unlock_adapter(client->adapter);\r\nif (ret == 0)\r\nclient->slave_cb = NULL;\r\nelse\r\ndev_err(&client->dev, "%s: adapter returned error %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nbool i2c_detect_slave_mode(struct device *dev)\r\n{\r\nif (IS_BUILTIN(CONFIG_OF) && dev->of_node) {\r\nstruct device_node *child;\r\nu32 reg;\r\nfor_each_child_of_node(dev->of_node, child) {\r\nof_property_read_u32(child, "reg", &reg);\r\nif (reg & I2C_OWN_SLAVE_ADDRESS) {\r\nof_node_put(child);\r\nreturn true;\r\n}\r\n}\r\n} else if (IS_BUILTIN(CONFIG_ACPI) && ACPI_HANDLE(dev)) {\r\ndev_dbg(dev, "ACPI slave is not supported yet\n");\r\n}\r\nreturn false;\r\n}
