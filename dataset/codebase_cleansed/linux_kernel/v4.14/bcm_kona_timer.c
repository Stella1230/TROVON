static void kona_timer_disable_and_clear(void __iomem *base)\r\n{\r\nuint32_t reg;\r\nreg = readl(base + KONA_GPTIMER_STCS_OFFSET);\r\nreg |= 1 << KONA_GPTIMER_STCS_TIMER_MATCH_SHIFT;\r\nreg &= ~(1 << KONA_GPTIMER_STCS_COMPARE_ENABLE_SHIFT);\r\nwritel(reg, base + KONA_GPTIMER_STCS_OFFSET);\r\n}\r\nstatic int\r\nkona_timer_get_counter(void __iomem *timer_base, uint32_t *msw, uint32_t *lsw)\r\n{\r\nint loop_limit = 3;\r\ndo {\r\n*msw = readl(timer_base + KONA_GPTIMER_STCHI_OFFSET);\r\n*lsw = readl(timer_base + KONA_GPTIMER_STCLO_OFFSET);\r\nif (*msw == readl(timer_base + KONA_GPTIMER_STCHI_OFFSET))\r\nbreak;\r\n} while (--loop_limit);\r\nif (!loop_limit) {\r\npr_err("bcm_kona_timer: getting counter failed.\n");\r\npr_err(" Timer will be impacted\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kona_timer_set_next_event(unsigned long clc,\r\nstruct clock_event_device *unused)\r\n{\r\nuint32_t lsw, msw;\r\nuint32_t reg;\r\nint ret;\r\nret = kona_timer_get_counter(timers.tmr_regs, &msw, &lsw);\r\nif (ret)\r\nreturn ret;\r\nwritel(lsw + clc, timers.tmr_regs + KONA_GPTIMER_STCM0_OFFSET);\r\nreg = readl(timers.tmr_regs + KONA_GPTIMER_STCS_OFFSET);\r\nreg |= (1 << KONA_GPTIMER_STCS_COMPARE_ENABLE_SHIFT);\r\nwritel(reg, timers.tmr_regs + KONA_GPTIMER_STCS_OFFSET);\r\nreturn 0;\r\n}\r\nstatic int kona_timer_shutdown(struct clock_event_device *evt)\r\n{\r\nkona_timer_disable_and_clear(timers.tmr_regs);\r\nreturn 0;\r\n}\r\nstatic void __init kona_timer_clockevents_init(void)\r\n{\r\nkona_clockevent_timer.cpumask = cpumask_of(0);\r\nclockevents_config_and_register(&kona_clockevent_timer,\r\narch_timer_rate, 6, 0xffffffff);\r\n}\r\nstatic irqreturn_t kona_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = &kona_clockevent_timer;\r\nkona_timer_disable_and_clear(timers.tmr_regs);\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init kona_timer_init(struct device_node *node)\r\n{\r\nu32 freq;\r\nstruct clk *external_clk;\r\nexternal_clk = of_clk_get_by_name(node, NULL);\r\nif (!IS_ERR(external_clk)) {\r\narch_timer_rate = clk_get_rate(external_clk);\r\nclk_prepare_enable(external_clk);\r\n} else if (!of_property_read_u32(node, "clock-frequency", &freq)) {\r\narch_timer_rate = freq;\r\n} else {\r\npr_err("Kona Timer v1 unable to determine clock-frequency\n");\r\nreturn -EINVAL;\r\n}\r\ntimers.tmr_irq = irq_of_parse_and_map(node, 0);\r\ntimers.tmr_regs = of_iomap(node, 0);\r\nkona_timer_disable_and_clear(timers.tmr_regs);\r\nkona_timer_clockevents_init();\r\nsetup_irq(timers.tmr_irq, &kona_timer_irq);\r\nkona_timer_set_next_event((arch_timer_rate / HZ), NULL);\r\nreturn 0;\r\n}
