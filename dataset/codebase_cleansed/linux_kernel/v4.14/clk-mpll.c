static long rate_from_params(unsigned long parent_rate,\r\nunsigned long sdm,\r\nunsigned long n2)\r\n{\r\nunsigned long divisor = (SDM_DEN * n2) + sdm;\r\nif (n2 < N2_MIN)\r\nreturn -EINVAL;\r\nreturn DIV_ROUND_UP_ULL((u64)parent_rate * SDM_DEN, divisor);\r\n}\r\nstatic void params_from_rate(unsigned long requested_rate,\r\nunsigned long parent_rate,\r\nunsigned long *sdm,\r\nunsigned long *n2)\r\n{\r\nuint64_t div = parent_rate;\r\nunsigned long rem = do_div(div, requested_rate);\r\nif (div < N2_MIN) {\r\n*n2 = N2_MIN;\r\n*sdm = 0;\r\n} else if (div > N2_MAX) {\r\n*n2 = N2_MAX;\r\n*sdm = SDM_DEN - 1;\r\n} else {\r\n*n2 = div;\r\n*sdm = DIV_ROUND_UP(rem * SDM_DEN, requested_rate);\r\n}\r\n}\r\nstatic unsigned long mpll_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct meson_clk_mpll *mpll = to_meson_clk_mpll(hw);\r\nstruct parm *p;\r\nunsigned long reg, sdm, n2;\r\nlong rate;\r\np = &mpll->sdm;\r\nreg = readl(mpll->base + p->reg_off);\r\nsdm = PARM_GET(p->width, p->shift, reg);\r\np = &mpll->n2;\r\nreg = readl(mpll->base + p->reg_off);\r\nn2 = PARM_GET(p->width, p->shift, reg);\r\nrate = rate_from_params(parent_rate, sdm, n2);\r\nif (rate < 0)\r\nreturn 0;\r\nreturn rate;\r\n}\r\nstatic long mpll_round_rate(struct clk_hw *hw,\r\nunsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned long sdm, n2;\r\nparams_from_rate(rate, *parent_rate, &sdm, &n2);\r\nreturn rate_from_params(*parent_rate, sdm, n2);\r\n}\r\nstatic int mpll_set_rate(struct clk_hw *hw,\r\nunsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct meson_clk_mpll *mpll = to_meson_clk_mpll(hw);\r\nstruct parm *p;\r\nunsigned long reg, sdm, n2;\r\nunsigned long flags = 0;\r\nparams_from_rate(rate, parent_rate, &sdm, &n2);\r\nif (mpll->lock)\r\nspin_lock_irqsave(mpll->lock, flags);\r\nelse\r\n__acquire(mpll->lock);\r\np = &mpll->sdm;\r\nreg = readl(mpll->base + p->reg_off);\r\nreg = PARM_SET(p->width, p->shift, reg, sdm);\r\nwritel(reg, mpll->base + p->reg_off);\r\np = &mpll->sdm_en;\r\nreg = readl(mpll->base + p->reg_off);\r\nreg = PARM_SET(p->width, p->shift, reg, 1);\r\nwritel(reg, mpll->base + p->reg_off);\r\np = &mpll->ssen;\r\nif (p->width != 0) {\r\nreg = readl(mpll->base + p->reg_off);\r\nreg = PARM_SET(p->width, p->shift, reg, 1);\r\nwritel(reg, mpll->base + p->reg_off);\r\n}\r\np = &mpll->n2;\r\nreg = readl(mpll->base + p->reg_off);\r\nreg = PARM_SET(p->width, p->shift, reg, n2);\r\nwritel(reg, mpll->base + p->reg_off);\r\nif (mpll->lock)\r\nspin_unlock_irqrestore(mpll->lock, flags);\r\nelse\r\n__release(mpll->lock);\r\nreturn 0;\r\n}\r\nstatic void mpll_enable_core(struct clk_hw *hw, int enable)\r\n{\r\nstruct meson_clk_mpll *mpll = to_meson_clk_mpll(hw);\r\nstruct parm *p;\r\nunsigned long reg;\r\nunsigned long flags = 0;\r\nif (mpll->lock)\r\nspin_lock_irqsave(mpll->lock, flags);\r\nelse\r\n__acquire(mpll->lock);\r\np = &mpll->en;\r\nreg = readl(mpll->base + p->reg_off);\r\nreg = PARM_SET(p->width, p->shift, reg, enable ? 1 : 0);\r\nwritel(reg, mpll->base + p->reg_off);\r\nif (mpll->lock)\r\nspin_unlock_irqrestore(mpll->lock, flags);\r\nelse\r\n__release(mpll->lock);\r\n}\r\nstatic int mpll_enable(struct clk_hw *hw)\r\n{\r\nmpll_enable_core(hw, 1);\r\nreturn 0;\r\n}\r\nstatic void mpll_disable(struct clk_hw *hw)\r\n{\r\nmpll_enable_core(hw, 0);\r\n}\r\nstatic int mpll_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct meson_clk_mpll *mpll = to_meson_clk_mpll(hw);\r\nstruct parm *p;\r\nunsigned long reg;\r\nint en;\r\np = &mpll->en;\r\nreg = readl(mpll->base + p->reg_off);\r\nen = PARM_GET(p->width, p->shift, reg);\r\nreturn en;\r\n}
