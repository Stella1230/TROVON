static int mlxfw_fsm_state_wait(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\r\nenum mlxfw_fsm_state fsm_state)\r\n{\r\nenum mlxfw_fsm_state_err fsm_state_err;\r\nenum mlxfw_fsm_state curr_fsm_state;\r\nint times;\r\nint err;\r\ntimes = MLXFW_FSM_STATE_WAIT_ROUNDS;\r\nretry:\r\nerr = mlxfw_dev->ops->fsm_query_state(mlxfw_dev, fwhandle,\r\n&curr_fsm_state, &fsm_state_err);\r\nif (err)\r\nreturn err;\r\nif (fsm_state_err != MLXFW_FSM_STATE_ERR_OK) {\r\npr_err("Firmware flash failed: %s\n",\r\nmlxfw_fsm_state_err_str[fsm_state_err]);\r\nreturn -EINVAL;\r\n}\r\nif (curr_fsm_state != fsm_state) {\r\nif (--times == 0) {\r\npr_err("Timeout reached on FSM state change");\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(MLXFW_FSM_STATE_WAIT_CYCLE_MS);\r\ngoto retry;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlxfw_flash_component(struct mlxfw_dev *mlxfw_dev,\r\nu32 fwhandle,\r\nstruct mlxfw_mfa2_component *comp)\r\n{\r\nu16 comp_max_write_size;\r\nu8 comp_align_bits;\r\nu32 comp_max_size;\r\nu16 block_size;\r\nu8 *block_ptr;\r\nu32 offset;\r\nint err;\r\nerr = mlxfw_dev->ops->component_query(mlxfw_dev, comp->index,\r\n&comp_max_size, &comp_align_bits,\r\n&comp_max_write_size);\r\nif (err)\r\nreturn err;\r\ncomp_max_size = min_t(u32, comp_max_size, MLXFW_FSM_MAX_COMPONENT_SIZE);\r\nif (comp->data_size > comp_max_size) {\r\npr_err("Component %d is of size %d which is bigger than limit %d\n",\r\ncomp->index, comp->data_size, comp_max_size);\r\nreturn -EINVAL;\r\n}\r\ncomp_max_write_size = MLXFW_ALIGN_DOWN(comp_max_write_size,\r\ncomp_align_bits);\r\npr_debug("Component update\n");\r\nerr = mlxfw_dev->ops->fsm_component_update(mlxfw_dev, fwhandle,\r\ncomp->index,\r\ncomp->data_size);\r\nif (err)\r\nreturn err;\r\nerr = mlxfw_fsm_state_wait(mlxfw_dev, fwhandle,\r\nMLXFW_FSM_STATE_DOWNLOAD);\r\nif (err)\r\ngoto err_out;\r\npr_debug("Component download\n");\r\nfor (offset = 0;\r\noffset < MLXFW_ALIGN_UP(comp->data_size, comp_align_bits);\r\noffset += comp_max_write_size) {\r\nblock_ptr = comp->data + offset;\r\nblock_size = (u16) min_t(u32, comp->data_size - offset,\r\ncomp_max_write_size);\r\nerr = mlxfw_dev->ops->fsm_block_download(mlxfw_dev, fwhandle,\r\nblock_ptr, block_size,\r\noffset);\r\nif (err)\r\ngoto err_out;\r\n}\r\npr_debug("Component verify\n");\r\nerr = mlxfw_dev->ops->fsm_component_verify(mlxfw_dev, fwhandle,\r\ncomp->index);\r\nif (err)\r\ngoto err_out;\r\nerr = mlxfw_fsm_state_wait(mlxfw_dev, fwhandle, MLXFW_FSM_STATE_LOCKED);\r\nif (err)\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\nmlxfw_dev->ops->fsm_cancel(mlxfw_dev, fwhandle);\r\nreturn err;\r\n}\r\nstatic int mlxfw_flash_components(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\r\nstruct mlxfw_mfa2_file *mfa2_file)\r\n{\r\nu32 component_count;\r\nint err;\r\nint i;\r\nerr = mlxfw_mfa2_file_component_count(mfa2_file, mlxfw_dev->psid,\r\nmlxfw_dev->psid_size,\r\n&component_count);\r\nif (err) {\r\npr_err("Could not find device PSID in MFA2 file\n");\r\nreturn err;\r\n}\r\nfor (i = 0; i < component_count; i++) {\r\nstruct mlxfw_mfa2_component *comp;\r\ncomp = mlxfw_mfa2_file_component_get(mfa2_file, mlxfw_dev->psid,\r\nmlxfw_dev->psid_size, i);\r\nif (IS_ERR(comp))\r\nreturn PTR_ERR(comp);\r\npr_info("Flashing component type %d\n", comp->index);\r\nerr = mlxfw_flash_component(mlxfw_dev, fwhandle, comp);\r\nmlxfw_mfa2_file_component_put(comp);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint mlxfw_firmware_flash(struct mlxfw_dev *mlxfw_dev,\r\nconst struct firmware *firmware)\r\n{\r\nstruct mlxfw_mfa2_file *mfa2_file;\r\nu32 fwhandle;\r\nint err;\r\nif (!mlxfw_mfa2_check(firmware)) {\r\npr_err("Firmware file is not MFA2\n");\r\nreturn -EINVAL;\r\n}\r\nmfa2_file = mlxfw_mfa2_file_init(firmware);\r\nif (IS_ERR(mfa2_file))\r\nreturn PTR_ERR(mfa2_file);\r\npr_info("Initialize firmware flash process\n");\r\nerr = mlxfw_dev->ops->fsm_lock(mlxfw_dev, &fwhandle);\r\nif (err) {\r\npr_err("Could not lock the firmware FSM\n");\r\ngoto err_fsm_lock;\r\n}\r\nerr = mlxfw_fsm_state_wait(mlxfw_dev, fwhandle,\r\nMLXFW_FSM_STATE_LOCKED);\r\nif (err)\r\ngoto err_state_wait_idle_to_locked;\r\nerr = mlxfw_flash_components(mlxfw_dev, fwhandle, mfa2_file);\r\nif (err)\r\ngoto err_flash_components;\r\npr_debug("Activate image\n");\r\nerr = mlxfw_dev->ops->fsm_activate(mlxfw_dev, fwhandle);\r\nif (err) {\r\npr_err("Could not activate the downloaded image\n");\r\ngoto err_fsm_activate;\r\n}\r\nerr = mlxfw_fsm_state_wait(mlxfw_dev, fwhandle, MLXFW_FSM_STATE_LOCKED);\r\nif (err)\r\ngoto err_state_wait_activate_to_locked;\r\npr_debug("Handle release\n");\r\nmlxfw_dev->ops->fsm_release(mlxfw_dev, fwhandle);\r\npr_info("Firmware flash done.\n");\r\nmlxfw_mfa2_file_fini(mfa2_file);\r\nreturn 0;\r\nerr_state_wait_activate_to_locked:\r\nerr_fsm_activate:\r\nerr_flash_components:\r\nerr_state_wait_idle_to_locked:\r\nmlxfw_dev->ops->fsm_release(mlxfw_dev, fwhandle);\r\nerr_fsm_lock:\r\nmlxfw_mfa2_file_fini(mfa2_file);\r\nreturn err;\r\n}
