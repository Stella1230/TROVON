fsm_instance *\r\ninit_fsm(char *name, const char **state_names, const char **event_names, int nr_states,\r\nint nr_events, const fsm_node *tmpl, int tmpl_len, gfp_t order)\r\n{\r\nint i;\r\nfsm_instance *this;\r\nfsm_function_t *m;\r\nfsm *f;\r\nthis = kzalloc(sizeof(fsm_instance), order);\r\nif (this == NULL) {\r\nprintk(KERN_WARNING\r\n"fsm(%s): init_fsm: Couldn't alloc instance\n", name);\r\nreturn NULL;\r\n}\r\nstrlcpy(this->name, name, sizeof(this->name));\r\ninit_waitqueue_head(&this->wait_q);\r\nf = kzalloc(sizeof(fsm), order);\r\nif (f == NULL) {\r\nprintk(KERN_WARNING\r\n"fsm(%s): init_fsm: Couldn't alloc fsm\n", name);\r\nkfree_fsm(this);\r\nreturn NULL;\r\n}\r\nf->nr_events = nr_events;\r\nf->nr_states = nr_states;\r\nf->event_names = event_names;\r\nf->state_names = state_names;\r\nthis->f = f;\r\nm = kcalloc(nr_states*nr_events, sizeof(fsm_function_t), order);\r\nif (m == NULL) {\r\nprintk(KERN_WARNING\r\n"fsm(%s): init_fsm: Couldn't alloc jumptable\n", name);\r\nkfree_fsm(this);\r\nreturn NULL;\r\n}\r\nf->jumpmatrix = m;\r\nfor (i = 0; i < tmpl_len; i++) {\r\nif ((tmpl[i].cond_state >= nr_states) ||\r\n(tmpl[i].cond_event >= nr_events) ) {\r\nprintk(KERN_ERR\r\n"fsm(%s): init_fsm: Bad template l=%d st(%ld/%ld) ev(%ld/%ld)\n",\r\nname, i, (long)tmpl[i].cond_state, (long)f->nr_states,\r\n(long)tmpl[i].cond_event, (long)f->nr_events);\r\nkfree_fsm(this);\r\nreturn NULL;\r\n} else\r\nm[nr_states * tmpl[i].cond_event + tmpl[i].cond_state] =\r\ntmpl[i].function;\r\n}\r\nreturn this;\r\n}\r\nvoid\r\nkfree_fsm(fsm_instance *this)\r\n{\r\nif (this) {\r\nif (this->f) {\r\nkfree(this->f->jumpmatrix);\r\nkfree(this->f);\r\n}\r\nkfree(this);\r\n} else\r\nprintk(KERN_WARNING\r\n"fsm: kfree_fsm called with NULL argument\n");\r\n}\r\nvoid\r\nfsm_print_history(fsm_instance *fi)\r\n{\r\nint idx = 0;\r\nint i;\r\nif (fi->history_size >= FSM_HISTORY_SIZE)\r\nidx = fi->history_index;\r\nprintk(KERN_DEBUG "fsm(%s): History:\n", fi->name);\r\nfor (i = 0; i < fi->history_size; i++) {\r\nint e = fi->history[idx].event;\r\nint s = fi->history[idx++].state;\r\nidx %= FSM_HISTORY_SIZE;\r\nif (e == -1)\r\nprintk(KERN_DEBUG " S=%s\n",\r\nfi->f->state_names[s]);\r\nelse\r\nprintk(KERN_DEBUG " S=%s E=%s\n",\r\nfi->f->state_names[s],\r\nfi->f->event_names[e]);\r\n}\r\nfi->history_size = fi->history_index = 0;\r\n}\r\nvoid\r\nfsm_record_history(fsm_instance *fi, int state, int event)\r\n{\r\nfi->history[fi->history_index].state = state;\r\nfi->history[fi->history_index++].event = event;\r\nfi->history_index %= FSM_HISTORY_SIZE;\r\nif (fi->history_size < FSM_HISTORY_SIZE)\r\nfi->history_size++;\r\n}\r\nconst char *\r\nfsm_getstate_str(fsm_instance *fi)\r\n{\r\nint st = atomic_read(&fi->state);\r\nif (st >= fi->f->nr_states)\r\nreturn "Invalid";\r\nreturn fi->f->state_names[st];\r\n}\r\nstatic void\r\nfsm_expire_timer(fsm_timer *this)\r\n{\r\n#if FSM_TIMER_DEBUG\r\nprintk(KERN_DEBUG "fsm(%s): Timer %p expired\n",\r\nthis->fi->name, this);\r\n#endif\r\nfsm_event(this->fi, this->expire_event, this->event_arg);\r\n}\r\nvoid\r\nfsm_settimer(fsm_instance *fi, fsm_timer *this)\r\n{\r\nthis->fi = fi;\r\nthis->tl.function = (void *)fsm_expire_timer;\r\nthis->tl.data = (long)this;\r\n#if FSM_TIMER_DEBUG\r\nprintk(KERN_DEBUG "fsm(%s): Create timer %p\n", fi->name,\r\nthis);\r\n#endif\r\ninit_timer(&this->tl);\r\n}\r\nvoid\r\nfsm_deltimer(fsm_timer *this)\r\n{\r\n#if FSM_TIMER_DEBUG\r\nprintk(KERN_DEBUG "fsm(%s): Delete timer %p\n", this->fi->name,\r\nthis);\r\n#endif\r\ndel_timer(&this->tl);\r\n}\r\nint\r\nfsm_addtimer(fsm_timer *this, int millisec, int event, void *arg)\r\n{\r\n#if FSM_TIMER_DEBUG\r\nprintk(KERN_DEBUG "fsm(%s): Add timer %p %dms\n",\r\nthis->fi->name, this, millisec);\r\n#endif\r\ninit_timer(&this->tl);\r\nthis->tl.function = (void *)fsm_expire_timer;\r\nthis->tl.data = (long)this;\r\nthis->expire_event = event;\r\nthis->event_arg = arg;\r\nthis->tl.expires = jiffies + (millisec * HZ) / 1000;\r\nadd_timer(&this->tl);\r\nreturn 0;\r\n}\r\nvoid\r\nfsm_modtimer(fsm_timer *this, int millisec, int event, void *arg)\r\n{\r\n#if FSM_TIMER_DEBUG\r\nprintk(KERN_DEBUG "fsm(%s): Restart timer %p %dms\n",\r\nthis->fi->name, this, millisec);\r\n#endif\r\ndel_timer(&this->tl);\r\ninit_timer(&this->tl);\r\nthis->tl.function = (void *)fsm_expire_timer;\r\nthis->tl.data = (long)this;\r\nthis->expire_event = event;\r\nthis->event_arg = arg;\r\nthis->tl.expires = jiffies + (millisec * HZ) / 1000;\r\nadd_timer(&this->tl);\r\n}
