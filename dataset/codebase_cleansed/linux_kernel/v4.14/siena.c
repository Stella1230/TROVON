static void siena_push_irq_moderation(struct efx_channel *channel)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nefx_dword_t timer_cmd;\r\nif (channel->irq_moderation_us) {\r\nunsigned int ticks;\r\nticks = efx_usecs_to_ticks(efx, channel->irq_moderation_us);\r\nEFX_POPULATE_DWORD_2(timer_cmd,\r\nFRF_CZ_TC_TIMER_MODE,\r\nFFE_CZ_TIMER_MODE_INT_HLDOFF,\r\nFRF_CZ_TC_TIMER_VAL,\r\nticks - 1);\r\n} else {\r\nEFX_POPULATE_DWORD_2(timer_cmd,\r\nFRF_CZ_TC_TIMER_MODE,\r\nFFE_CZ_TIMER_MODE_DIS,\r\nFRF_CZ_TC_TIMER_VAL, 0);\r\n}\r\nefx_writed_page_locked(channel->efx, &timer_cmd, FR_BZ_TIMER_COMMAND_P0,\r\nchannel->channel);\r\n}\r\nvoid siena_prepare_flush(struct efx_nic *efx)\r\n{\r\nif (efx->fc_disable++ == 0)\r\nefx_mcdi_set_mac(efx);\r\n}\r\nvoid siena_finish_flush(struct efx_nic *efx)\r\n{\r\nif (--efx->fc_disable == 0)\r\nefx_mcdi_set_mac(efx);\r\n}\r\nstatic int siena_test_chip(struct efx_nic *efx, struct efx_self_tests *tests)\r\n{\r\nenum reset_type reset_method = RESET_TYPE_ALL;\r\nint rc, rc2;\r\nefx_reset_down(efx, reset_method);\r\nrc = efx_mcdi_reset(efx, reset_method);\r\nif (rc)\r\ngoto out;\r\ntests->registers =\r\nefx_farch_test_registers(efx, siena_register_tests,\r\nARRAY_SIZE(siena_register_tests))\r\n? -1 : 1;\r\nrc = efx_mcdi_reset(efx, reset_method);\r\nout:\r\nrc2 = efx_reset_up(efx, reset_method, rc == 0);\r\nreturn rc ? rc : rc2;\r\n}\r\nstatic void siena_ptp_write_host_time(struct efx_nic *efx, u32 host_time)\r\n{\r\n_efx_writed(efx, cpu_to_le32(host_time),\r\nFR_CZ_MC_TREG_SMEM + MC_SMEM_P0_PTP_TIME_OFST);\r\n}\r\nstatic int siena_ptp_set_ts_config(struct efx_nic *efx,\r\nstruct hwtstamp_config *init)\r\n{\r\nint rc;\r\nswitch (init->rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\nreturn efx_ptp_change_mode(efx,\r\ninit->tx_type != HWTSTAMP_TX_OFF,\r\nefx_ptp_get_mode(efx));\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\ninit->rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\r\nreturn efx_ptp_change_mode(efx, true, MC_CMD_PTP_MODE_V1);\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\ninit->rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\r\nrc = efx_ptp_change_mode(efx, true,\r\nMC_CMD_PTP_MODE_V2_ENHANCED);\r\nif (rc != 0)\r\nrc = efx_ptp_change_mode(efx, true, MC_CMD_PTP_MODE_V2);\r\nreturn rc;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\n}\r\nstatic int siena_map_reset_flags(u32 *flags)\r\n{\r\nenum {\r\nSIENA_RESET_PORT = (ETH_RESET_DMA | ETH_RESET_FILTER |\r\nETH_RESET_OFFLOAD | ETH_RESET_MAC |\r\nETH_RESET_PHY),\r\nSIENA_RESET_MC = (SIENA_RESET_PORT |\r\nETH_RESET_MGMT << ETH_RESET_SHARED_SHIFT),\r\n};\r\nif ((*flags & SIENA_RESET_MC) == SIENA_RESET_MC) {\r\n*flags &= ~SIENA_RESET_MC;\r\nreturn RESET_TYPE_WORLD;\r\n}\r\nif ((*flags & SIENA_RESET_PORT) == SIENA_RESET_PORT) {\r\n*flags &= ~SIENA_RESET_PORT;\r\nreturn RESET_TYPE_ALL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void siena_monitor(struct efx_nic *efx)\r\n{\r\nstruct eeh_dev *eehdev = pci_dev_to_eeh_dev(efx->pci_dev);\r\neeh_dev_check_failure(eehdev);\r\n}\r\nstatic int siena_probe_nvconfig(struct efx_nic *efx)\r\n{\r\nu32 caps = 0;\r\nint rc;\r\nrc = efx_mcdi_get_board_cfg(efx, efx->net_dev->perm_addr, NULL, &caps);\r\nefx->timer_quantum_ns =\r\n(caps & (1 << MC_CMD_CAPABILITIES_TURBO_ACTIVE_LBN)) ?\r\n3072 : 6144;\r\nefx->timer_max_ns = efx->type->timer_period_max *\r\nefx->timer_quantum_ns;\r\nreturn rc;\r\n}\r\nstatic int siena_dimension_resources(struct efx_nic *efx)\r\n{\r\nefx_farch_dimension_resources(efx, FR_CZ_BUF_FULL_TBL_ROWS / 2);\r\nreturn 0;\r\n}\r\nstatic unsigned int siena_mem_map_size(struct efx_nic *efx)\r\n{\r\nreturn FR_CZ_MC_TREG_SMEM +\r\nFR_CZ_MC_TREG_SMEM_STEP * FR_CZ_MC_TREG_SMEM_ROWS;\r\n}\r\nstatic int siena_probe_nic(struct efx_nic *efx)\r\n{\r\nstruct siena_nic_data *nic_data;\r\nefx_oword_t reg;\r\nint rc;\r\nnic_data = kzalloc(sizeof(struct siena_nic_data), GFP_KERNEL);\r\nif (!nic_data)\r\nreturn -ENOMEM;\r\nnic_data->efx = efx;\r\nefx->nic_data = nic_data;\r\nif (efx_farch_fpga_ver(efx) != 0) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Siena FPGA not supported\n");\r\nrc = -ENODEV;\r\ngoto fail1;\r\n}\r\nefx->max_channels = EFX_MAX_CHANNELS;\r\nefx->max_tx_channels = EFX_MAX_CHANNELS;\r\nefx_reado(efx, &reg, FR_AZ_CS_DEBUG);\r\nefx->port_num = EFX_OWORD_FIELD(reg, FRF_CZ_CS_PORT_NUM) - 1;\r\nrc = efx_mcdi_init(efx);\r\nif (rc)\r\ngoto fail1;\r\nrc = efx_mcdi_reset(efx, RESET_TYPE_ALL);\r\nif (rc) {\r\nnetif_err(efx, probe, efx->net_dev, "failed to reset NIC\n");\r\ngoto fail3;\r\n}\r\nsiena_init_wol(efx);\r\nrc = efx_nic_alloc_buffer(efx, &efx->irq_status, sizeof(efx_oword_t),\r\nGFP_KERNEL);\r\nif (rc)\r\ngoto fail4;\r\nBUG_ON(efx->irq_status.dma_addr & 0x0f);\r\nnetif_dbg(efx, probe, efx->net_dev,\r\n"INT_KER at %llx (virt %p phys %llx)\n",\r\n(unsigned long long)efx->irq_status.dma_addr,\r\nefx->irq_status.addr,\r\n(unsigned long long)virt_to_phys(efx->irq_status.addr));\r\nrc = siena_probe_nvconfig(efx);\r\nif (rc == -EINVAL) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"NVRAM is invalid therefore using defaults\n");\r\nefx->phy_type = PHY_TYPE_NONE;\r\nefx->mdio.prtad = MDIO_PRTAD_NONE;\r\n} else if (rc) {\r\ngoto fail5;\r\n}\r\nrc = efx_mcdi_mon_probe(efx);\r\nif (rc)\r\ngoto fail5;\r\n#ifdef CONFIG_SFC_SRIOV\r\nefx_siena_sriov_probe(efx);\r\n#endif\r\nefx_ptp_defer_probe_with_channel(efx);\r\nreturn 0;\r\nfail5:\r\nefx_nic_free_buffer(efx, &efx->irq_status);\r\nfail4:\r\nfail3:\r\nefx_mcdi_detach(efx);\r\nefx_mcdi_fini(efx);\r\nfail1:\r\nkfree(efx->nic_data);\r\nreturn rc;\r\n}\r\nstatic int siena_rx_pull_rss_config(struct efx_nic *efx)\r\n{\r\nefx_oword_t temp;\r\nefx_reado(efx, &temp, FR_CZ_RX_RSS_IPV6_REG1);\r\nmemcpy(efx->rx_hash_key, &temp, sizeof(temp));\r\nefx_reado(efx, &temp, FR_CZ_RX_RSS_IPV6_REG2);\r\nmemcpy(efx->rx_hash_key + sizeof(temp), &temp, sizeof(temp));\r\nefx_reado(efx, &temp, FR_CZ_RX_RSS_IPV6_REG3);\r\nmemcpy(efx->rx_hash_key + 2 * sizeof(temp), &temp,\r\nFRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH / 8);\r\nefx_farch_rx_pull_indir_table(efx);\r\nreturn 0;\r\n}\r\nstatic int siena_rx_push_rss_config(struct efx_nic *efx, bool user,\r\nconst u32 *rx_indir_table, const u8 *key)\r\n{\r\nefx_oword_t temp;\r\nif (key)\r\nmemcpy(efx->rx_hash_key, key, sizeof(temp));\r\nmemcpy(&temp, efx->rx_hash_key, sizeof(temp));\r\nefx_writeo(efx, &temp, FR_BZ_RX_RSS_TKEY);\r\nBUILD_BUG_ON(sizeof(efx->rx_hash_key) <\r\n2 * sizeof(temp) + FRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH / 8 ||\r\nFRF_CZ_RX_RSS_IPV6_TKEY_HI_LBN != 0);\r\nmemcpy(&temp, efx->rx_hash_key, sizeof(temp));\r\nefx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG1);\r\nmemcpy(&temp, efx->rx_hash_key + sizeof(temp), sizeof(temp));\r\nefx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG2);\r\nEFX_POPULATE_OWORD_2(temp, FRF_CZ_RX_RSS_IPV6_THASH_ENABLE, 1,\r\nFRF_CZ_RX_RSS_IPV6_IP_THASH_ENABLE, 1);\r\nmemcpy(&temp, efx->rx_hash_key + 2 * sizeof(temp),\r\nFRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH / 8);\r\nefx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG3);\r\nmemcpy(efx->rx_indir_table, rx_indir_table,\r\nsizeof(efx->rx_indir_table));\r\nefx_farch_rx_push_indir_table(efx);\r\nreturn 0;\r\n}\r\nstatic int siena_init_nic(struct efx_nic *efx)\r\n{\r\nefx_oword_t temp;\r\nint rc;\r\nrc = efx_mcdi_handle_assertion(efx);\r\nif (rc)\r\nreturn rc;\r\nefx_reado(efx, &temp, FR_AZ_TX_RESERVED);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_TX_FLUSH_MIN_LEN_EN, 1);\r\nefx_writeo(efx, &temp, FR_AZ_TX_RESERVED);\r\nefx_reado(efx, &temp, FR_AZ_TX_CFG);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_NO_EOP_DISC_EN, 0);\r\nEFX_SET_OWORD_FIELD(temp, FRF_CZ_TX_FILTER_EN_BIT, 1);\r\nefx_writeo(efx, &temp, FR_AZ_TX_CFG);\r\nefx_reado(efx, &temp, FR_AZ_RX_CFG);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_DESC_PUSH_EN, 0);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_INGR_EN, 1);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_HASH_INSRT_HDR, 1);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_HASH_ALG, 1);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_IP_HASH, 1);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_USR_BUF_SIZE,\r\nEFX_RX_USR_BUF_SIZE >> 5);\r\nefx_writeo(efx, &temp, FR_AZ_RX_CFG);\r\nsiena_rx_push_rss_config(efx, false, efx->rx_indir_table, NULL);\r\nefx->rss_active = true;\r\nrc = efx_mcdi_log_ctrl(efx, true, false, 0);\r\nif (rc)\r\nreturn rc;\r\nEFX_POPULATE_OWORD_1(temp, FRF_BZ_FLS_EVQ_ID, 0);\r\nefx_writeo(efx, &temp, FR_BZ_DP_CTRL);\r\nEFX_POPULATE_OWORD_1(temp, FRF_CZ_USREV_DIS, 1);\r\nefx_writeo(efx, &temp, FR_CZ_USR_EV_CFG);\r\nefx_farch_init_common(efx);\r\nreturn 0;\r\n}\r\nstatic void siena_remove_nic(struct efx_nic *efx)\r\n{\r\nefx_mcdi_mon_remove(efx);\r\nefx_nic_free_buffer(efx, &efx->irq_status);\r\nefx_mcdi_reset(efx, RESET_TYPE_ALL);\r\nefx_mcdi_detach(efx);\r\nefx_mcdi_fini(efx);\r\nkfree(efx->nic_data);\r\nefx->nic_data = NULL;\r\n}\r\nstatic size_t siena_describe_nic_stats(struct efx_nic *efx, u8 *names)\r\n{\r\nreturn efx_nic_describe_stats(siena_stat_desc, SIENA_STAT_COUNT,\r\nsiena_stat_mask, names);\r\n}\r\nstatic int siena_try_update_nic_stats(struct efx_nic *efx)\r\n{\r\nstruct siena_nic_data *nic_data = efx->nic_data;\r\nu64 *stats = nic_data->stats;\r\n__le64 *dma_stats;\r\n__le64 generation_start, generation_end;\r\ndma_stats = efx->stats_buffer.addr;\r\ngeneration_end = dma_stats[MC_CMD_MAC_GENERATION_END];\r\nif (generation_end == EFX_MC_STATS_GENERATION_INVALID)\r\nreturn 0;\r\nrmb();\r\nefx_nic_update_stats(siena_stat_desc, SIENA_STAT_COUNT, siena_stat_mask,\r\nstats, efx->stats_buffer.addr, false);\r\nrmb();\r\ngeneration_start = dma_stats[MC_CMD_MAC_GENERATION_START];\r\nif (generation_end != generation_start)\r\nreturn -EAGAIN;\r\nefx_nic_fix_nodesc_drop_stat(efx,\r\n&stats[SIENA_STAT_rx_nodesc_drop_cnt]);\r\nefx_update_diff_stat(&stats[SIENA_STAT_tx_good_bytes],\r\nstats[SIENA_STAT_tx_bytes] -\r\nstats[SIENA_STAT_tx_bad_bytes]);\r\nstats[SIENA_STAT_tx_collision] =\r\nstats[SIENA_STAT_tx_single_collision] +\r\nstats[SIENA_STAT_tx_multiple_collision] +\r\nstats[SIENA_STAT_tx_excessive_collision] +\r\nstats[SIENA_STAT_tx_late_collision];\r\nefx_update_diff_stat(&stats[SIENA_STAT_rx_good_bytes],\r\nstats[SIENA_STAT_rx_bytes] -\r\nstats[SIENA_STAT_rx_bad_bytes]);\r\nefx_update_sw_stats(efx, stats);\r\nreturn 0;\r\n}\r\nstatic size_t siena_update_nic_stats(struct efx_nic *efx, u64 *full_stats,\r\nstruct rtnl_link_stats64 *core_stats)\r\n{\r\nstruct siena_nic_data *nic_data = efx->nic_data;\r\nu64 *stats = nic_data->stats;\r\nint retry;\r\nfor (retry = 0; retry < 100; ++retry) {\r\nif (siena_try_update_nic_stats(efx) == 0)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (full_stats)\r\nmemcpy(full_stats, stats, sizeof(u64) * SIENA_STAT_COUNT);\r\nif (core_stats) {\r\ncore_stats->rx_packets = stats[SIENA_STAT_rx_packets];\r\ncore_stats->tx_packets = stats[SIENA_STAT_tx_packets];\r\ncore_stats->rx_bytes = stats[SIENA_STAT_rx_bytes];\r\ncore_stats->tx_bytes = stats[SIENA_STAT_tx_bytes];\r\ncore_stats->rx_dropped = stats[SIENA_STAT_rx_nodesc_drop_cnt] +\r\nstats[GENERIC_STAT_rx_nodesc_trunc] +\r\nstats[GENERIC_STAT_rx_noskb_drops];\r\ncore_stats->multicast = stats[SIENA_STAT_rx_multicast];\r\ncore_stats->collisions = stats[SIENA_STAT_tx_collision];\r\ncore_stats->rx_length_errors =\r\nstats[SIENA_STAT_rx_gtjumbo] +\r\nstats[SIENA_STAT_rx_length_error];\r\ncore_stats->rx_crc_errors = stats[SIENA_STAT_rx_bad];\r\ncore_stats->rx_frame_errors = stats[SIENA_STAT_rx_align_error];\r\ncore_stats->rx_fifo_errors = stats[SIENA_STAT_rx_overflow];\r\ncore_stats->tx_window_errors =\r\nstats[SIENA_STAT_tx_late_collision];\r\ncore_stats->rx_errors = (core_stats->rx_length_errors +\r\ncore_stats->rx_crc_errors +\r\ncore_stats->rx_frame_errors +\r\nstats[SIENA_STAT_rx_symbol_error]);\r\ncore_stats->tx_errors = (core_stats->tx_window_errors +\r\nstats[SIENA_STAT_tx_bad]);\r\n}\r\nreturn SIENA_STAT_COUNT;\r\n}\r\nstatic int siena_mac_reconfigure(struct efx_nic *efx)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_SET_MCAST_HASH_IN_LEN);\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_SET_MCAST_HASH_IN_LEN !=\r\nMC_CMD_SET_MCAST_HASH_IN_HASH0_OFST +\r\nsizeof(efx->multicast_hash));\r\nefx_farch_filter_sync_rx_mode(efx);\r\nWARN_ON(!mutex_is_locked(&efx->mac_lock));\r\nrc = efx_mcdi_set_mac(efx);\r\nif (rc != 0)\r\nreturn rc;\r\nmemcpy(MCDI_PTR(inbuf, SET_MCAST_HASH_IN_HASH0),\r\nefx->multicast_hash.byte, sizeof(efx->multicast_hash));\r\nreturn efx_mcdi_rpc(efx, MC_CMD_SET_MCAST_HASH,\r\ninbuf, sizeof(inbuf), NULL, 0, NULL);\r\n}\r\nstatic void siena_get_wol(struct efx_nic *efx, struct ethtool_wolinfo *wol)\r\n{\r\nstruct siena_nic_data *nic_data = efx->nic_data;\r\nwol->supported = WAKE_MAGIC;\r\nif (nic_data->wol_filter_id != -1)\r\nwol->wolopts = WAKE_MAGIC;\r\nelse\r\nwol->wolopts = 0;\r\nmemset(&wol->sopass, 0, sizeof(wol->sopass));\r\n}\r\nstatic int siena_set_wol(struct efx_nic *efx, u32 type)\r\n{\r\nstruct siena_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nif (type & ~WAKE_MAGIC)\r\nreturn -EINVAL;\r\nif (type & WAKE_MAGIC) {\r\nif (nic_data->wol_filter_id != -1)\r\nefx_mcdi_wol_filter_remove(efx,\r\nnic_data->wol_filter_id);\r\nrc = efx_mcdi_wol_filter_set_magic(efx, efx->net_dev->dev_addr,\r\n&nic_data->wol_filter_id);\r\nif (rc)\r\ngoto fail;\r\npci_wake_from_d3(efx->pci_dev, true);\r\n} else {\r\nrc = efx_mcdi_wol_filter_reset(efx);\r\nnic_data->wol_filter_id = -1;\r\npci_wake_from_d3(efx->pci_dev, false);\r\nif (rc)\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s failed: type=%d rc=%d\n",\r\n__func__, type, rc);\r\nreturn rc;\r\n}\r\nstatic void siena_init_wol(struct efx_nic *efx)\r\n{\r\nstruct siena_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nrc = efx_mcdi_wol_filter_get_magic(efx, &nic_data->wol_filter_id);\r\nif (rc != 0) {\r\nefx_mcdi_wol_filter_reset(efx);\r\nnic_data->wol_filter_id = -1;\r\n} else if (nic_data->wol_filter_id != -1) {\r\npci_wake_from_d3(efx->pci_dev, true);\r\n}\r\n}\r\nstatic void siena_mcdi_request(struct efx_nic *efx,\r\nconst efx_dword_t *hdr, size_t hdr_len,\r\nconst efx_dword_t *sdu, size_t sdu_len)\r\n{\r\nunsigned pdu = FR_CZ_MC_TREG_SMEM + MCDI_PDU(efx);\r\nunsigned doorbell = FR_CZ_MC_TREG_SMEM + MCDI_DOORBELL(efx);\r\nunsigned int i;\r\nunsigned int inlen_dw = DIV_ROUND_UP(sdu_len, 4);\r\nEFX_WARN_ON_PARANOID(hdr_len != 4);\r\nefx_writed(efx, hdr, pdu);\r\nfor (i = 0; i < inlen_dw; i++)\r\nefx_writed(efx, &sdu[i], pdu + hdr_len + 4 * i);\r\nwmb();\r\n_efx_writed(efx, (__force __le32) 0x45789abc, doorbell);\r\n}\r\nstatic bool siena_mcdi_poll_response(struct efx_nic *efx)\r\n{\r\nunsigned int pdu = FR_CZ_MC_TREG_SMEM + MCDI_PDU(efx);\r\nefx_dword_t hdr;\r\nefx_readd(efx, &hdr, pdu);\r\nreturn EFX_DWORD_FIELD(hdr, EFX_DWORD_0) != 0xffffffff &&\r\nEFX_DWORD_FIELD(hdr, MCDI_HEADER_RESPONSE);\r\n}\r\nstatic void siena_mcdi_read_response(struct efx_nic *efx, efx_dword_t *outbuf,\r\nsize_t offset, size_t outlen)\r\n{\r\nunsigned int pdu = FR_CZ_MC_TREG_SMEM + MCDI_PDU(efx);\r\nunsigned int outlen_dw = DIV_ROUND_UP(outlen, 4);\r\nint i;\r\nfor (i = 0; i < outlen_dw; i++)\r\nefx_readd(efx, &outbuf[i], pdu + offset + 4 * i);\r\n}\r\nstatic int siena_mcdi_poll_reboot(struct efx_nic *efx)\r\n{\r\nstruct siena_nic_data *nic_data = efx->nic_data;\r\nunsigned int addr = FR_CZ_MC_TREG_SMEM + MCDI_STATUS(efx);\r\nefx_dword_t reg;\r\nu32 value;\r\nefx_readd(efx, &reg, addr);\r\nvalue = EFX_DWORD_FIELD(reg, EFX_DWORD_0);\r\nif (value == 0)\r\nreturn 0;\r\nEFX_ZERO_DWORD(reg);\r\nefx_writed(efx, &reg, addr);\r\nnic_data->stats[SIENA_STAT_tx_good_bytes] = 0;\r\nnic_data->stats[SIENA_STAT_rx_good_bytes] = 0;\r\nif (value == MC_STATUS_DWORD_ASSERT)\r\nreturn -EINTR;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int siena_mtd_probe_partition(struct efx_nic *efx,\r\nstruct efx_mcdi_mtd_partition *part,\r\nunsigned int type)\r\n{\r\nconst struct siena_nvram_type_info *info;\r\nsize_t size, erase_size;\r\nbool protected;\r\nint rc;\r\nif (type >= ARRAY_SIZE(siena_nvram_types) ||\r\nsiena_nvram_types[type].name == NULL)\r\nreturn -ENODEV;\r\ninfo = &siena_nvram_types[type];\r\nif (info->port != efx_port_num(efx))\r\nreturn -ENODEV;\r\nrc = efx_mcdi_nvram_info(efx, type, &size, &erase_size, &protected);\r\nif (rc)\r\nreturn rc;\r\nif (protected)\r\nreturn -ENODEV;\r\npart->nvram_type = type;\r\npart->common.dev_type_name = "Siena NVRAM manager";\r\npart->common.type_name = info->name;\r\npart->common.mtd.type = MTD_NORFLASH;\r\npart->common.mtd.flags = MTD_CAP_NORFLASH;\r\npart->common.mtd.size = size;\r\npart->common.mtd.erasesize = erase_size;\r\nreturn 0;\r\n}\r\nstatic int siena_mtd_get_fw_subtypes(struct efx_nic *efx,\r\nstruct efx_mcdi_mtd_partition *parts,\r\nsize_t n_parts)\r\n{\r\nuint16_t fw_subtype_list[\r\nMC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_MAXNUM];\r\nsize_t i;\r\nint rc;\r\nrc = efx_mcdi_get_board_cfg(efx, NULL, fw_subtype_list, NULL);\r\nif (rc)\r\nreturn rc;\r\nfor (i = 0; i < n_parts; i++)\r\nparts[i].fw_subtype = fw_subtype_list[parts[i].nvram_type];\r\nreturn 0;\r\n}\r\nstatic int siena_mtd_probe(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_mtd_partition *parts;\r\nu32 nvram_types;\r\nunsigned int type;\r\nsize_t n_parts;\r\nint rc;\r\nASSERT_RTNL();\r\nrc = efx_mcdi_nvram_types(efx, &nvram_types);\r\nif (rc)\r\nreturn rc;\r\nparts = kcalloc(hweight32(nvram_types), sizeof(*parts), GFP_KERNEL);\r\nif (!parts)\r\nreturn -ENOMEM;\r\ntype = 0;\r\nn_parts = 0;\r\nwhile (nvram_types != 0) {\r\nif (nvram_types & 1) {\r\nrc = siena_mtd_probe_partition(efx, &parts[n_parts],\r\ntype);\r\nif (rc == 0)\r\nn_parts++;\r\nelse if (rc != -ENODEV)\r\ngoto fail;\r\n}\r\ntype++;\r\nnvram_types >>= 1;\r\n}\r\nrc = siena_mtd_get_fw_subtypes(efx, parts, n_parts);\r\nif (rc)\r\ngoto fail;\r\nrc = efx_mtd_add(efx, &parts[0].common, n_parts, sizeof(*parts));\r\nfail:\r\nif (rc)\r\nkfree(parts);\r\nreturn rc;\r\n}
