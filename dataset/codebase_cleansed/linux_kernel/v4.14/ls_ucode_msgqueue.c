static int\r\nacr_ls_ucode_load_msgqueue(const struct nvkm_subdev *subdev, const char *name,\r\nstruct ls_ucode_img *img)\r\n{\r\nconst struct firmware *image, *desc, *sig;\r\nchar f[64];\r\nint ret;\r\nsnprintf(f, sizeof(f), "%s/image", name);\r\nret = nvkm_firmware_get(subdev->device, f, &image);\r\nif (ret)\r\nreturn ret;\r\nimg->ucode_data = kmemdup(image->data, image->size, GFP_KERNEL);\r\nnvkm_firmware_put(image);\r\nif (!img->ucode_data)\r\nreturn -ENOMEM;\r\nsnprintf(f, sizeof(f), "%s/desc", name);\r\nret = nvkm_firmware_get(subdev->device, f, &desc);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(&img->ucode_desc, desc->data, sizeof(img->ucode_desc));\r\nimg->ucode_size = ALIGN(img->ucode_desc.app_start_offset + img->ucode_desc.app_size, 256);\r\nnvkm_firmware_put(desc);\r\nsnprintf(f, sizeof(f), "%s/sig", name);\r\nret = nvkm_firmware_get(subdev->device, f, &sig);\r\nif (ret)\r\nreturn ret;\r\nimg->sig_size = sig->size;\r\nimg->sig = kmemdup(sig->data, sig->size, GFP_KERNEL);\r\nnvkm_firmware_put(sig);\r\nif (!img->sig)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int\r\nacr_ls_msgqueue_post_run(struct nvkm_msgqueue *queue,\r\nstruct nvkm_falcon *falcon, u32 addr_args)\r\n{\r\nstruct nvkm_device *device = falcon->owner->device;\r\nu32 cmdline_size = NVKM_MSGQUEUE_CMDLINE_SIZE;\r\nu8 buf[cmdline_size];\r\nmemset(buf, 0, cmdline_size);\r\nnvkm_msgqueue_write_cmdline(queue, buf);\r\nnvkm_falcon_load_dmem(falcon, buf, addr_args, cmdline_size, 0);\r\nnvkm_msgqueue_reinit(queue);\r\nnvkm_falcon_wr32(falcon, 0x10, 0xff);\r\nnvkm_mc_intr_mask(device, falcon->owner->index, true);\r\nnvkm_falcon_start(falcon);\r\nreturn 0;\r\n}\r\nint\r\nacr_ls_ucode_load_pmu(const struct nvkm_secboot *sb, struct ls_ucode_img *img)\r\n{\r\nstruct nvkm_pmu *pmu = sb->subdev.device->pmu;\r\nint ret;\r\nret = acr_ls_ucode_load_msgqueue(&sb->subdev, "pmu", img);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_msgqueue_new(img->ucode_desc.app_version, pmu->falcon,\r\nsb, &pmu->queue);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint\r\nacr_ls_pmu_post_run(const struct nvkm_acr *acr, const struct nvkm_secboot *sb)\r\n{\r\nstruct nvkm_device *device = sb->subdev.device;\r\nstruct nvkm_pmu *pmu = device->pmu;\r\nu32 addr_args = pmu->falcon->data.limit - NVKM_MSGQUEUE_CMDLINE_SIZE;\r\nint ret;\r\nret = acr_ls_msgqueue_post_run(pmu->queue, pmu->falcon, addr_args);\r\nif (ret)\r\nreturn ret;\r\nnvkm_debug(&sb->subdev, "%s started\n",\r\nnvkm_secboot_falcon_name[acr->boot_falcon]);\r\nreturn 0;\r\n}\r\nint\r\nacr_ls_ucode_load_sec2(const struct nvkm_secboot *sb, struct ls_ucode_img *img)\r\n{\r\nstruct nvkm_sec2 *sec = sb->subdev.device->sec2;\r\nint ret;\r\nret = acr_ls_ucode_load_msgqueue(&sb->subdev, "sec2", img);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_msgqueue_new(img->ucode_desc.app_version, sec->falcon,\r\nsb, &sec->queue);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint\r\nacr_ls_sec2_post_run(const struct nvkm_acr *acr, const struct nvkm_secboot *sb)\r\n{\r\nconst struct nvkm_subdev *subdev = &sb->subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nstruct nvkm_sec2 *sec = device->sec2;\r\nconst u32 addr_args = 0x01000000;\r\nu32 reg;\r\nint ret;\r\nret = acr_ls_msgqueue_post_run(sec->queue, sec->falcon, addr_args);\r\nif (ret)\r\nreturn ret;\r\nnvkm_msec(device, 1,\r\nif ((reg = nvkm_falcon_rd32(sb->boot_falcon, 0x100) & 0x30) != 0)\r\nbreak;\r\n);\r\nif (reg & BIT(4)) {\r\nnvkm_debug(subdev, "applying workaround for start bug...");\r\nnvkm_falcon_start(sb->boot_falcon);\r\nnvkm_msec(subdev->device, 1,\r\nif ((reg = nvkm_rd32(subdev->device,\r\nsb->boot_falcon->addr + 0x100)\r\n& 0x30) != 0)\r\nbreak;\r\n);\r\nif (reg & BIT(4)) {\r\nnvkm_error(subdev, "%s failed to start\n",\r\nnvkm_secboot_falcon_name[acr->boot_falcon]);\r\nreturn -EINVAL;\r\n}\r\n}\r\nnvkm_debug(&sb->subdev, "%s started\n",\r\nnvkm_secboot_falcon_name[acr->boot_falcon]);\r\nreturn 0;\r\n}
