static inline bool is_field_set(u32 val, u32 mask)\r\n{\r\nreturn val || mask;\r\n}\r\nstatic inline bool unsupported(u32 conf, u32 conf_mask, u32 val, u32 mask)\r\n{\r\nreturn !(conf & conf_mask) && is_field_set(val, mask);\r\n}\r\nstatic int validate_filter(struct net_device *dev,\r\nstruct ch_filter_specification *fs)\r\n{\r\nstruct adapter *adapter = netdev2adap(dev);\r\nu32 fconf, iconf;\r\nfconf = adapter->params.tp.vlan_pri_map;\r\niconf = adapter->params.tp.ingress_config;\r\nif (unsupported(fconf, FCOE_F, fs->val.fcoe, fs->mask.fcoe) ||\r\nunsupported(fconf, PORT_F, fs->val.iport, fs->mask.iport) ||\r\nunsupported(fconf, TOS_F, fs->val.tos, fs->mask.tos) ||\r\nunsupported(fconf, ETHERTYPE_F, fs->val.ethtype,\r\nfs->mask.ethtype) ||\r\nunsupported(fconf, MACMATCH_F, fs->val.macidx, fs->mask.macidx) ||\r\nunsupported(fconf, MPSHITTYPE_F, fs->val.matchtype,\r\nfs->mask.matchtype) ||\r\nunsupported(fconf, FRAGMENTATION_F, fs->val.frag, fs->mask.frag) ||\r\nunsupported(fconf, PROTOCOL_F, fs->val.proto, fs->mask.proto) ||\r\nunsupported(fconf, VNIC_ID_F, fs->val.pfvf_vld,\r\nfs->mask.pfvf_vld) ||\r\nunsupported(fconf, VNIC_ID_F, fs->val.ovlan_vld,\r\nfs->mask.ovlan_vld) ||\r\nunsupported(fconf, VLAN_F, fs->val.ivlan_vld, fs->mask.ivlan_vld))\r\nreturn -EOPNOTSUPP;\r\nif (is_field_set(fs->val.pfvf_vld, fs->mask.pfvf_vld) &&\r\nis_field_set(fs->val.ovlan_vld, fs->mask.ovlan_vld))\r\nreturn -EOPNOTSUPP;\r\nif (unsupported(iconf, VNIC_F, fs->val.pfvf_vld, fs->mask.pfvf_vld) ||\r\n(is_field_set(fs->val.ovlan_vld, fs->mask.ovlan_vld) &&\r\n(iconf & VNIC_F)))\r\nreturn -EOPNOTSUPP;\r\nif (fs->val.pf > 0x7 || fs->val.vf > 0x7f)\r\nreturn -ERANGE;\r\nfs->mask.pf &= 0x7;\r\nfs->mask.vf &= 0x7f;\r\nif (fs->action == FILTER_SWITCH &&\r\nfs->eport >= adapter->params.nports)\r\nreturn -ERANGE;\r\nif (fs->val.iport >= adapter->params.nports)\r\nreturn -ERANGE;\r\nif (is_t4(adapter->params.chip) &&\r\nfs->action == FILTER_SWITCH &&\r\n(fs->newvlan == VLAN_REMOVE ||\r\nfs->newvlan == VLAN_REWRITE))\r\nreturn -EOPNOTSUPP;\r\nreturn 0;\r\n}\r\nstatic int get_filter_steerq(struct net_device *dev,\r\nstruct ch_filter_specification *fs)\r\n{\r\nstruct adapter *adapter = netdev2adap(dev);\r\nint iq;\r\nif (!fs->dirsteer) {\r\nif (fs->iq)\r\nreturn -EINVAL;\r\niq = 0;\r\n} else {\r\nstruct port_info *pi = netdev_priv(dev);\r\nif (fs->iq < pi->nqsets)\r\niq = adapter->sge.ethrxq[pi->first_qset +\r\nfs->iq].rspq.abs_id;\r\nelse\r\niq = fs->iq;\r\n}\r\nreturn iq;\r\n}\r\nstatic int cxgb4_set_ftid(struct tid_info *t, int fidx, int family)\r\n{\r\nspin_lock_bh(&t->ftid_lock);\r\nif (test_bit(fidx, t->ftid_bmap)) {\r\nspin_unlock_bh(&t->ftid_lock);\r\nreturn -EBUSY;\r\n}\r\nif (family == PF_INET)\r\n__set_bit(fidx, t->ftid_bmap);\r\nelse\r\nbitmap_allocate_region(t->ftid_bmap, fidx, 2);\r\nspin_unlock_bh(&t->ftid_lock);\r\nreturn 0;\r\n}\r\nstatic void cxgb4_clear_ftid(struct tid_info *t, int fidx, int family)\r\n{\r\nspin_lock_bh(&t->ftid_lock);\r\nif (family == PF_INET)\r\n__clear_bit(fidx, t->ftid_bmap);\r\nelse\r\nbitmap_release_region(t->ftid_bmap, fidx, 2);\r\nspin_unlock_bh(&t->ftid_lock);\r\n}\r\nstatic int del_filter_wr(struct adapter *adapter, int fidx)\r\n{\r\nstruct filter_entry *f = &adapter->tids.ftid_tab[fidx];\r\nstruct fw_filter_wr *fwr;\r\nstruct sk_buff *skb;\r\nunsigned int len;\r\nlen = sizeof(*fwr);\r\nskb = alloc_skb(len, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nfwr = __skb_put(skb, len);\r\nt4_mk_filtdelwr(f->tid, fwr, adapter->sge.fw_evtq.abs_id);\r\nf->pending = 1;\r\nt4_mgmt_tx(adapter, skb);\r\nreturn 0;\r\n}\r\nint set_filter_wr(struct adapter *adapter, int fidx)\r\n{\r\nstruct filter_entry *f = &adapter->tids.ftid_tab[fidx];\r\nstruct fw_filter_wr *fwr;\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(sizeof(*fwr), GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nif (f->fs.newdmac || f->fs.newvlan) {\r\nf->l2t = t4_l2t_alloc_switching(adapter, f->fs.vlan,\r\nf->fs.eport, f->fs.dmac);\r\nif (!f->l2t) {\r\nkfree_skb(skb);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfwr = __skb_put_zero(skb, sizeof(*fwr));\r\nfwr->op_pkd = htonl(FW_WR_OP_V(FW_FILTER_WR));\r\nfwr->len16_pkd = htonl(FW_WR_LEN16_V(sizeof(*fwr) / 16));\r\nfwr->tid_to_iq =\r\nhtonl(FW_FILTER_WR_TID_V(f->tid) |\r\nFW_FILTER_WR_RQTYPE_V(f->fs.type) |\r\nFW_FILTER_WR_NOREPLY_V(0) |\r\nFW_FILTER_WR_IQ_V(f->fs.iq));\r\nfwr->del_filter_to_l2tix =\r\nhtonl(FW_FILTER_WR_RPTTID_V(f->fs.rpttid) |\r\nFW_FILTER_WR_DROP_V(f->fs.action == FILTER_DROP) |\r\nFW_FILTER_WR_DIRSTEER_V(f->fs.dirsteer) |\r\nFW_FILTER_WR_MASKHASH_V(f->fs.maskhash) |\r\nFW_FILTER_WR_DIRSTEERHASH_V(f->fs.dirsteerhash) |\r\nFW_FILTER_WR_LPBK_V(f->fs.action == FILTER_SWITCH) |\r\nFW_FILTER_WR_DMAC_V(f->fs.newdmac) |\r\nFW_FILTER_WR_SMAC_V(f->fs.newsmac) |\r\nFW_FILTER_WR_INSVLAN_V(f->fs.newvlan == VLAN_INSERT ||\r\nf->fs.newvlan == VLAN_REWRITE) |\r\nFW_FILTER_WR_RMVLAN_V(f->fs.newvlan == VLAN_REMOVE ||\r\nf->fs.newvlan == VLAN_REWRITE) |\r\nFW_FILTER_WR_HITCNTS_V(f->fs.hitcnts) |\r\nFW_FILTER_WR_TXCHAN_V(f->fs.eport) |\r\nFW_FILTER_WR_PRIO_V(f->fs.prio) |\r\nFW_FILTER_WR_L2TIX_V(f->l2t ? f->l2t->idx : 0));\r\nfwr->ethtype = htons(f->fs.val.ethtype);\r\nfwr->ethtypem = htons(f->fs.mask.ethtype);\r\nfwr->frag_to_ovlan_vldm =\r\n(FW_FILTER_WR_FRAG_V(f->fs.val.frag) |\r\nFW_FILTER_WR_FRAGM_V(f->fs.mask.frag) |\r\nFW_FILTER_WR_IVLAN_VLD_V(f->fs.val.ivlan_vld) |\r\nFW_FILTER_WR_OVLAN_VLD_V(f->fs.val.ovlan_vld) |\r\nFW_FILTER_WR_IVLAN_VLDM_V(f->fs.mask.ivlan_vld) |\r\nFW_FILTER_WR_OVLAN_VLDM_V(f->fs.mask.ovlan_vld));\r\nfwr->smac_sel = 0;\r\nfwr->rx_chan_rx_rpl_iq =\r\nhtons(FW_FILTER_WR_RX_CHAN_V(0) |\r\nFW_FILTER_WR_RX_RPL_IQ_V(adapter->sge.fw_evtq.abs_id));\r\nfwr->maci_to_matchtypem =\r\nhtonl(FW_FILTER_WR_MACI_V(f->fs.val.macidx) |\r\nFW_FILTER_WR_MACIM_V(f->fs.mask.macidx) |\r\nFW_FILTER_WR_FCOE_V(f->fs.val.fcoe) |\r\nFW_FILTER_WR_FCOEM_V(f->fs.mask.fcoe) |\r\nFW_FILTER_WR_PORT_V(f->fs.val.iport) |\r\nFW_FILTER_WR_PORTM_V(f->fs.mask.iport) |\r\nFW_FILTER_WR_MATCHTYPE_V(f->fs.val.matchtype) |\r\nFW_FILTER_WR_MATCHTYPEM_V(f->fs.mask.matchtype));\r\nfwr->ptcl = f->fs.val.proto;\r\nfwr->ptclm = f->fs.mask.proto;\r\nfwr->ttyp = f->fs.val.tos;\r\nfwr->ttypm = f->fs.mask.tos;\r\nfwr->ivlan = htons(f->fs.val.ivlan);\r\nfwr->ivlanm = htons(f->fs.mask.ivlan);\r\nfwr->ovlan = htons(f->fs.val.ovlan);\r\nfwr->ovlanm = htons(f->fs.mask.ovlan);\r\nmemcpy(fwr->lip, f->fs.val.lip, sizeof(fwr->lip));\r\nmemcpy(fwr->lipm, f->fs.mask.lip, sizeof(fwr->lipm));\r\nmemcpy(fwr->fip, f->fs.val.fip, sizeof(fwr->fip));\r\nmemcpy(fwr->fipm, f->fs.mask.fip, sizeof(fwr->fipm));\r\nfwr->lp = htons(f->fs.val.lport);\r\nfwr->lpm = htons(f->fs.mask.lport);\r\nfwr->fp = htons(f->fs.val.fport);\r\nfwr->fpm = htons(f->fs.mask.fport);\r\nif (f->fs.newsmac)\r\nmemcpy(fwr->sma, f->fs.smac, sizeof(fwr->sma));\r\nf->pending = 1;\r\nset_wr_txq(skb, CPL_PRIORITY_CONTROL, f->fs.val.iport & 0x3);\r\nt4_ofld_send(adapter, skb);\r\nreturn 0;\r\n}\r\nint writable_filter(struct filter_entry *f)\r\n{\r\nif (f->locked)\r\nreturn -EPERM;\r\nif (f->pending)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nint delete_filter(struct adapter *adapter, unsigned int fidx)\r\n{\r\nstruct filter_entry *f;\r\nint ret;\r\nif (fidx >= adapter->tids.nftids + adapter->tids.nsftids)\r\nreturn -EINVAL;\r\nf = &adapter->tids.ftid_tab[fidx];\r\nret = writable_filter(f);\r\nif (ret)\r\nreturn ret;\r\nif (f->valid)\r\nreturn del_filter_wr(adapter, fidx);\r\nreturn 0;\r\n}\r\nvoid clear_filter(struct adapter *adap, struct filter_entry *f)\r\n{\r\nif (f->l2t)\r\ncxgb4_l2t_release(f->l2t);\r\nmemset(f, 0, sizeof(*f));\r\n}\r\nvoid clear_all_filters(struct adapter *adapter)\r\n{\r\nunsigned int i;\r\nif (adapter->tids.ftid_tab) {\r\nstruct filter_entry *f = &adapter->tids.ftid_tab[0];\r\nunsigned int max_ftid = adapter->tids.nftids +\r\nadapter->tids.nsftids;\r\nfor (i = 0; i < max_ftid; i++, f++)\r\nif (f->valid || f->pending)\r\nclear_filter(adapter, f);\r\n}\r\n}\r\nstatic void fill_default_mask(struct ch_filter_specification *fs)\r\n{\r\nunsigned int lip = 0, lip_mask = 0;\r\nunsigned int fip = 0, fip_mask = 0;\r\nunsigned int i;\r\nif (fs->val.iport && !fs->mask.iport)\r\nfs->mask.iport |= ~0;\r\nif (fs->val.fcoe && !fs->mask.fcoe)\r\nfs->mask.fcoe |= ~0;\r\nif (fs->val.matchtype && !fs->mask.matchtype)\r\nfs->mask.matchtype |= ~0;\r\nif (fs->val.macidx && !fs->mask.macidx)\r\nfs->mask.macidx |= ~0;\r\nif (fs->val.ethtype && !fs->mask.ethtype)\r\nfs->mask.ethtype |= ~0;\r\nif (fs->val.ivlan && !fs->mask.ivlan)\r\nfs->mask.ivlan |= ~0;\r\nif (fs->val.ovlan && !fs->mask.ovlan)\r\nfs->mask.ovlan |= ~0;\r\nif (fs->val.frag && !fs->mask.frag)\r\nfs->mask.frag |= ~0;\r\nif (fs->val.tos && !fs->mask.tos)\r\nfs->mask.tos |= ~0;\r\nif (fs->val.proto && !fs->mask.proto)\r\nfs->mask.proto |= ~0;\r\nfor (i = 0; i < ARRAY_SIZE(fs->val.lip); i++) {\r\nlip |= fs->val.lip[i];\r\nlip_mask |= fs->mask.lip[i];\r\nfip |= fs->val.fip[i];\r\nfip_mask |= fs->mask.fip[i];\r\n}\r\nif (lip && !lip_mask)\r\nmemset(fs->mask.lip, ~0, sizeof(fs->mask.lip));\r\nif (fip && !fip_mask)\r\nmemset(fs->mask.fip, ~0, sizeof(fs->mask.lip));\r\nif (fs->val.lport && !fs->mask.lport)\r\nfs->mask.lport = ~0;\r\nif (fs->val.fport && !fs->mask.fport)\r\nfs->mask.fport = ~0;\r\n}\r\nint __cxgb4_set_filter(struct net_device *dev, int filter_id,\r\nstruct ch_filter_specification *fs,\r\nstruct filter_ctx *ctx)\r\n{\r\nstruct adapter *adapter = netdev2adap(dev);\r\nunsigned int max_fidx, fidx;\r\nstruct filter_entry *f;\r\nu32 iconf;\r\nint iq, ret;\r\nmax_fidx = adapter->tids.nftids;\r\nif (filter_id != (max_fidx + adapter->tids.nsftids - 1) &&\r\nfilter_id >= max_fidx)\r\nreturn -E2BIG;\r\nfill_default_mask(fs);\r\nret = validate_filter(dev, fs);\r\nif (ret)\r\nreturn ret;\r\niq = get_filter_steerq(dev, fs);\r\nif (iq < 0)\r\nreturn iq;\r\nif (fs->type == 0) {\r\nfidx = filter_id & ~0x3;\r\nif (fidx != filter_id &&\r\nadapter->tids.ftid_tab[fidx].fs.type) {\r\nf = &adapter->tids.ftid_tab[fidx];\r\nif (f->valid) {\r\ndev_err(adapter->pdev_dev,\r\n"Invalid location. IPv6 requires 4 slots and is occupying slots %u to %u\n",\r\nfidx, fidx + 3);\r\nreturn -EINVAL;\r\n}\r\n}\r\n} else {\r\nif (filter_id & 0x3) {\r\ndev_err(adapter->pdev_dev,\r\n"Invalid location. IPv6 must be aligned on a 4-slot boundary\n");\r\nreturn -EINVAL;\r\n}\r\nfor (fidx = filter_id + 1; fidx < filter_id + 4; fidx++) {\r\nf = &adapter->tids.ftid_tab[fidx];\r\nif (f->valid) {\r\ndev_err(adapter->pdev_dev,\r\n"Invalid location. IPv6 requires 4 slots and an IPv4 filter exists at %u\n",\r\nfidx);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nf = &adapter->tids.ftid_tab[filter_id];\r\nif (f->valid)\r\nreturn -EBUSY;\r\nfidx = filter_id + adapter->tids.ftid_base;\r\nret = cxgb4_set_ftid(&adapter->tids, filter_id,\r\nfs->type ? PF_INET6 : PF_INET);\r\nif (ret)\r\nreturn ret;\r\nret = writable_filter(f);\r\nif (ret) {\r\ncxgb4_clear_ftid(&adapter->tids, filter_id,\r\nfs->type ? PF_INET6 : PF_INET);\r\nreturn ret;\r\n}\r\nif (f->valid)\r\nclear_filter(adapter, f);\r\nf->fs = *fs;\r\nf->fs.iq = iq;\r\nf->dev = dev;\r\niconf = adapter->params.tp.ingress_config;\r\nif (iconf & VNIC_F) {\r\nf->fs.val.ovlan = (fs->val.pf << 13) | fs->val.vf;\r\nf->fs.mask.ovlan = (fs->mask.pf << 13) | fs->mask.vf;\r\nf->fs.val.ovlan_vld = fs->val.pfvf_vld;\r\nf->fs.mask.ovlan_vld = fs->mask.pfvf_vld;\r\n}\r\nf->ctx = ctx;\r\nf->tid = fidx;\r\nret = set_filter_wr(adapter, filter_id);\r\nif (ret) {\r\ncxgb4_clear_ftid(&adapter->tids, filter_id,\r\nfs->type ? PF_INET6 : PF_INET);\r\nclear_filter(adapter, f);\r\n}\r\nreturn ret;\r\n}\r\nint __cxgb4_del_filter(struct net_device *dev, int filter_id,\r\nstruct filter_ctx *ctx)\r\n{\r\nstruct adapter *adapter = netdev2adap(dev);\r\nstruct filter_entry *f;\r\nunsigned int max_fidx;\r\nint ret;\r\nmax_fidx = adapter->tids.nftids;\r\nif (filter_id != (max_fidx + adapter->tids.nsftids - 1) &&\r\nfilter_id >= max_fidx)\r\nreturn -E2BIG;\r\nf = &adapter->tids.ftid_tab[filter_id];\r\nret = writable_filter(f);\r\nif (ret)\r\nreturn ret;\r\nif (f->valid) {\r\nf->ctx = ctx;\r\ncxgb4_clear_ftid(&adapter->tids, filter_id,\r\nf->fs.type ? PF_INET6 : PF_INET);\r\nreturn del_filter_wr(adapter, filter_id);\r\n}\r\nif (ctx) {\r\nctx->result = 0;\r\ncomplete(&ctx->completion);\r\n}\r\nreturn ret;\r\n}\r\nint cxgb4_set_filter(struct net_device *dev, int filter_id,\r\nstruct ch_filter_specification *fs)\r\n{\r\nstruct filter_ctx ctx;\r\nint ret;\r\ninit_completion(&ctx.completion);\r\nret = __cxgb4_set_filter(dev, filter_id, fs, &ctx);\r\nif (ret)\r\ngoto out;\r\nret = wait_for_completion_timeout(&ctx.completion, 10 * HZ);\r\nif (!ret)\r\nreturn -ETIMEDOUT;\r\nret = ctx.result;\r\nout:\r\nreturn ret;\r\n}\r\nint cxgb4_del_filter(struct net_device *dev, int filter_id)\r\n{\r\nstruct filter_ctx ctx;\r\nint ret;\r\ninit_completion(&ctx.completion);\r\nret = __cxgb4_del_filter(dev, filter_id, &ctx);\r\nif (ret)\r\ngoto out;\r\nret = wait_for_completion_timeout(&ctx.completion, 10 * HZ);\r\nif (!ret)\r\nreturn -ETIMEDOUT;\r\nret = ctx.result;\r\nout:\r\nreturn ret;\r\n}\r\nvoid filter_rpl(struct adapter *adap, const struct cpl_set_tcb_rpl *rpl)\r\n{\r\nunsigned int tid = GET_TID(rpl);\r\nstruct filter_entry *f = NULL;\r\nunsigned int max_fidx;\r\nint idx;\r\nmax_fidx = adap->tids.nftids + adap->tids.nsftids;\r\nif (adap->tids.ftid_tab) {\r\nidx = tid - adap->tids.ftid_base;\r\nif (idx >= max_fidx)\r\nreturn;\r\nf = &adap->tids.ftid_tab[idx];\r\nif (f->tid != tid)\r\nreturn;\r\n}\r\nif (f) {\r\nunsigned int ret = TCB_COOKIE_G(rpl->cookie);\r\nstruct filter_ctx *ctx;\r\nctx = f->ctx;\r\nf->ctx = NULL;\r\nif (ret == FW_FILTER_WR_FLT_DELETED) {\r\nclear_filter(adap, f);\r\nif (ctx)\r\nctx->result = 0;\r\n} else if (ret == FW_FILTER_WR_SMT_TBL_FULL) {\r\ndev_err(adap->pdev_dev, "filter %u setup failed due to full SMT\n",\r\nidx);\r\nclear_filter(adap, f);\r\nif (ctx)\r\nctx->result = -ENOMEM;\r\n} else if (ret == FW_FILTER_WR_FLT_ADDED) {\r\nf->smtidx = (be64_to_cpu(rpl->oldval) >> 24) & 0xff;\r\nf->pending = 0;\r\nf->valid = 1;\r\nif (ctx) {\r\nctx->result = 0;\r\nctx->tid = idx;\r\n}\r\n} else {\r\ndev_err(adap->pdev_dev, "filter %u setup failed with error %u\n",\r\nidx, ret);\r\nclear_filter(adap, f);\r\nif (ctx)\r\nctx->result = -EINVAL;\r\n}\r\nif (ctx)\r\ncomplete(&ctx->completion);\r\n}\r\n}
