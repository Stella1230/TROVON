static void blk_stat_init(struct blk_rq_stat *stat)\r\n{\r\nstat->min = -1ULL;\r\nstat->max = stat->nr_samples = stat->mean = 0;\r\nstat->batch = stat->nr_batch = 0;\r\n}\r\nstatic void blk_stat_flush_batch(struct blk_rq_stat *stat)\r\n{\r\nconst s32 nr_batch = READ_ONCE(stat->nr_batch);\r\nconst s32 nr_samples = READ_ONCE(stat->nr_samples);\r\nif (!nr_batch)\r\nreturn;\r\nif (!nr_samples)\r\nstat->mean = div64_s64(stat->batch, nr_batch);\r\nelse {\r\nstat->mean = div64_s64((stat->mean * nr_samples) +\r\nstat->batch,\r\nnr_batch + nr_samples);\r\n}\r\nstat->nr_samples += nr_batch;\r\nstat->nr_batch = stat->batch = 0;\r\n}\r\nstatic void blk_stat_sum(struct blk_rq_stat *dst, struct blk_rq_stat *src)\r\n{\r\nblk_stat_flush_batch(src);\r\nif (!src->nr_samples)\r\nreturn;\r\ndst->min = min(dst->min, src->min);\r\ndst->max = max(dst->max, src->max);\r\nif (!dst->nr_samples)\r\ndst->mean = src->mean;\r\nelse {\r\ndst->mean = div64_s64((src->mean * src->nr_samples) +\r\n(dst->mean * dst->nr_samples),\r\ndst->nr_samples + src->nr_samples);\r\n}\r\ndst->nr_samples += src->nr_samples;\r\n}\r\nstatic void __blk_stat_add(struct blk_rq_stat *stat, u64 value)\r\n{\r\nstat->min = min(stat->min, value);\r\nstat->max = max(stat->max, value);\r\nif (stat->batch + value < stat->batch ||\r\nstat->nr_batch + 1 == BLK_RQ_STAT_BATCH)\r\nblk_stat_flush_batch(stat);\r\nstat->batch += value;\r\nstat->nr_batch++;\r\n}\r\nvoid blk_stat_add(struct request *rq)\r\n{\r\nstruct request_queue *q = rq->q;\r\nstruct blk_stat_callback *cb;\r\nstruct blk_rq_stat *stat;\r\nint bucket;\r\ns64 now, value;\r\nnow = __blk_stat_time(ktime_to_ns(ktime_get()));\r\nif (now < blk_stat_time(&rq->issue_stat))\r\nreturn;\r\nvalue = now - blk_stat_time(&rq->issue_stat);\r\nblk_throtl_stat_add(rq, value);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(cb, &q->stats->callbacks, list) {\r\nif (!blk_stat_is_active(cb))\r\ncontinue;\r\nbucket = cb->bucket_fn(rq);\r\nif (bucket < 0)\r\ncontinue;\r\nstat = &get_cpu_ptr(cb->cpu_stat)[bucket];\r\n__blk_stat_add(stat, value);\r\nput_cpu_ptr(cb->cpu_stat);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void blk_stat_timer_fn(unsigned long data)\r\n{\r\nstruct blk_stat_callback *cb = (void *)data;\r\nunsigned int bucket;\r\nint cpu;\r\nfor (bucket = 0; bucket < cb->buckets; bucket++)\r\nblk_stat_init(&cb->stat[bucket]);\r\nfor_each_online_cpu(cpu) {\r\nstruct blk_rq_stat *cpu_stat;\r\ncpu_stat = per_cpu_ptr(cb->cpu_stat, cpu);\r\nfor (bucket = 0; bucket < cb->buckets; bucket++) {\r\nblk_stat_sum(&cb->stat[bucket], &cpu_stat[bucket]);\r\nblk_stat_init(&cpu_stat[bucket]);\r\n}\r\n}\r\ncb->timer_fn(cb);\r\n}\r\nstruct blk_stat_callback *\r\nblk_stat_alloc_callback(void (*timer_fn)(struct blk_stat_callback *),\r\nint (*bucket_fn)(const struct request *),\r\nunsigned int buckets, void *data)\r\n{\r\nstruct blk_stat_callback *cb;\r\ncb = kmalloc(sizeof(*cb), GFP_KERNEL);\r\nif (!cb)\r\nreturn NULL;\r\ncb->stat = kmalloc_array(buckets, sizeof(struct blk_rq_stat),\r\nGFP_KERNEL);\r\nif (!cb->stat) {\r\nkfree(cb);\r\nreturn NULL;\r\n}\r\ncb->cpu_stat = __alloc_percpu(buckets * sizeof(struct blk_rq_stat),\r\n__alignof__(struct blk_rq_stat));\r\nif (!cb->cpu_stat) {\r\nkfree(cb->stat);\r\nkfree(cb);\r\nreturn NULL;\r\n}\r\ncb->timer_fn = timer_fn;\r\ncb->bucket_fn = bucket_fn;\r\ncb->data = data;\r\ncb->buckets = buckets;\r\nsetup_timer(&cb->timer, blk_stat_timer_fn, (unsigned long)cb);\r\nreturn cb;\r\n}\r\nvoid blk_stat_add_callback(struct request_queue *q,\r\nstruct blk_stat_callback *cb)\r\n{\r\nunsigned int bucket;\r\nint cpu;\r\nfor_each_possible_cpu(cpu) {\r\nstruct blk_rq_stat *cpu_stat;\r\ncpu_stat = per_cpu_ptr(cb->cpu_stat, cpu);\r\nfor (bucket = 0; bucket < cb->buckets; bucket++)\r\nblk_stat_init(&cpu_stat[bucket]);\r\n}\r\nspin_lock(&q->stats->lock);\r\nlist_add_tail_rcu(&cb->list, &q->stats->callbacks);\r\nset_bit(QUEUE_FLAG_STATS, &q->queue_flags);\r\nspin_unlock(&q->stats->lock);\r\n}\r\nvoid blk_stat_remove_callback(struct request_queue *q,\r\nstruct blk_stat_callback *cb)\r\n{\r\nspin_lock(&q->stats->lock);\r\nlist_del_rcu(&cb->list);\r\nif (list_empty(&q->stats->callbacks) && !q->stats->enable_accounting)\r\nclear_bit(QUEUE_FLAG_STATS, &q->queue_flags);\r\nspin_unlock(&q->stats->lock);\r\ndel_timer_sync(&cb->timer);\r\n}\r\nstatic void blk_stat_free_callback_rcu(struct rcu_head *head)\r\n{\r\nstruct blk_stat_callback *cb;\r\ncb = container_of(head, struct blk_stat_callback, rcu);\r\nfree_percpu(cb->cpu_stat);\r\nkfree(cb->stat);\r\nkfree(cb);\r\n}\r\nvoid blk_stat_free_callback(struct blk_stat_callback *cb)\r\n{\r\nif (cb)\r\ncall_rcu(&cb->rcu, blk_stat_free_callback_rcu);\r\n}\r\nvoid blk_stat_enable_accounting(struct request_queue *q)\r\n{\r\nspin_lock(&q->stats->lock);\r\nq->stats->enable_accounting = true;\r\nset_bit(QUEUE_FLAG_STATS, &q->queue_flags);\r\nspin_unlock(&q->stats->lock);\r\n}\r\nstruct blk_queue_stats *blk_alloc_queue_stats(void)\r\n{\r\nstruct blk_queue_stats *stats;\r\nstats = kmalloc(sizeof(*stats), GFP_KERNEL);\r\nif (!stats)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&stats->callbacks);\r\nspin_lock_init(&stats->lock);\r\nstats->enable_accounting = false;\r\nreturn stats;\r\n}\r\nvoid blk_free_queue_stats(struct blk_queue_stats *stats)\r\n{\r\nif (!stats)\r\nreturn;\r\nWARN_ON(!list_empty(&stats->callbacks));\r\nkfree(stats);\r\n}
