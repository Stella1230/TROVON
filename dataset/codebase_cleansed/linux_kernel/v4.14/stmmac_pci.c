static int stmmac_pci_find_phy_addr(struct pci_dev *pdev,\r\nconst struct dmi_system_id *dmi_list)\r\n{\r\nconst struct stmmac_pci_func_data *func_data;\r\nconst struct stmmac_pci_dmi_data *dmi_data;\r\nconst struct dmi_system_id *dmi_id;\r\nint func = PCI_FUNC(pdev->devfn);\r\nsize_t n;\r\ndmi_id = dmi_first_match(dmi_list);\r\nif (!dmi_id)\r\nreturn -ENODEV;\r\ndmi_data = dmi_id->driver_data;\r\nfunc_data = dmi_data->func;\r\nfor (n = 0; n < dmi_data->nfuncs; n++, func_data++)\r\nif (func_data->func == func)\r\nreturn func_data->phy_addr;\r\nreturn -ENODEV;\r\n}\r\nstatic void common_default_data(struct plat_stmmacenet_data *plat)\r\n{\r\nplat->clk_csr = 2;\r\nplat->has_gmac = 1;\r\nplat->force_sf_dma_mode = 1;\r\nplat->mdio_bus_data->phy_reset = NULL;\r\nplat->mdio_bus_data->phy_mask = 0;\r\nplat->multicast_filter_bins = HASH_TABLE_SIZE;\r\nplat->unicast_filter_entries = 1;\r\nplat->maxmtu = JUMBO_LEN;\r\nplat->tx_queues_to_use = 1;\r\nplat->rx_queues_to_use = 1;\r\nplat->tx_queues_cfg[0].use_prio = false;\r\nplat->rx_queues_cfg[0].use_prio = false;\r\nplat->rx_queues_cfg[0].pkt_route = 0x0;\r\n}\r\nstatic int stmmac_default_data(struct pci_dev *pdev,\r\nstruct plat_stmmacenet_data *plat)\r\n{\r\ncommon_default_data(plat);\r\nplat->bus_id = 1;\r\nplat->phy_addr = 0;\r\nplat->interface = PHY_INTERFACE_MODE_GMII;\r\nplat->dma_cfg->pbl = 32;\r\nplat->dma_cfg->pblx8 = true;\r\nreturn 0;\r\n}\r\nstatic int quark_default_data(struct pci_dev *pdev,\r\nstruct plat_stmmacenet_data *plat)\r\n{\r\nint ret;\r\ncommon_default_data(plat);\r\nret = stmmac_pci_find_phy_addr(pdev, quark_pci_dmi);\r\nif (ret < 0) {\r\nif (dmi_get_system_info(DMI_BOARD_NAME))\r\nreturn ret;\r\nret = 1;\r\n}\r\nplat->bus_id = PCI_DEVID(pdev->bus->number, pdev->devfn);\r\nplat->phy_addr = ret;\r\nplat->interface = PHY_INTERFACE_MODE_RMII;\r\nplat->dma_cfg->pbl = 16;\r\nplat->dma_cfg->pblx8 = true;\r\nplat->dma_cfg->fixed_burst = 1;\r\nreturn 0;\r\n}\r\nstatic int stmmac_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct stmmac_pci_info *info = (struct stmmac_pci_info *)id->driver_data;\r\nstruct plat_stmmacenet_data *plat;\r\nstruct stmmac_resources res;\r\nint i;\r\nint ret;\r\nplat = devm_kzalloc(&pdev->dev, sizeof(*plat), GFP_KERNEL);\r\nif (!plat)\r\nreturn -ENOMEM;\r\nplat->mdio_bus_data = devm_kzalloc(&pdev->dev,\r\nsizeof(*plat->mdio_bus_data),\r\nGFP_KERNEL);\r\nif (!plat->mdio_bus_data)\r\nreturn -ENOMEM;\r\nplat->dma_cfg = devm_kzalloc(&pdev->dev, sizeof(*plat->dma_cfg),\r\nGFP_KERNEL);\r\nif (!plat->dma_cfg)\r\nreturn -ENOMEM;\r\nret = pcim_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s: ERROR: failed to enable device\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nfor (i = 0; i <= PCI_STD_RESOURCE_END; i++) {\r\nif (pci_resource_len(pdev, i) == 0)\r\ncontinue;\r\nret = pcim_iomap_regions(pdev, BIT(i), pci_name(pdev));\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\n}\r\npci_set_master(pdev);\r\nret = info->setup(pdev, plat);\r\nif (ret)\r\nreturn ret;\r\npci_enable_msi(pdev);\r\nmemset(&res, 0, sizeof(res));\r\nres.addr = pcim_iomap_table(pdev)[i];\r\nres.wol_irq = pdev->irq;\r\nres.irq = pdev->irq;\r\nreturn stmmac_dvr_probe(&pdev->dev, plat, &res);\r\n}\r\nstatic void stmmac_pci_remove(struct pci_dev *pdev)\r\n{\r\nstmmac_dvr_remove(&pdev->dev);\r\n}
