static void da8xx_musb_enable(struct musb *musb)\r\n{\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\nu32 mask;\r\nmask = ((musb->epmask & DA8XX_USB_TX_EP_MASK) << DA8XX_INTR_TX_SHIFT) |\r\n((musb->epmask & DA8XX_USB_RX_EP_MASK) << DA8XX_INTR_RX_SHIFT) |\r\nDA8XX_INTR_USB_MASK;\r\nmusb_writel(reg_base, DA8XX_USB_INTR_MASK_SET_REG, mask);\r\nmusb_writel(reg_base, DA8XX_USB_INTR_SRC_SET_REG,\r\nDA8XX_INTR_DRVVBUS << DA8XX_INTR_USB_SHIFT);\r\n}\r\nstatic void da8xx_musb_disable(struct musb *musb)\r\n{\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\nmusb_writel(reg_base, DA8XX_USB_INTR_MASK_CLEAR_REG,\r\nDA8XX_INTR_USB_MASK |\r\nDA8XX_INTR_TX_MASK | DA8XX_INTR_RX_MASK);\r\nmusb_writel(reg_base, DA8XX_USB_END_OF_INTR_REG, 0);\r\n}\r\nstatic void da8xx_musb_set_vbus(struct musb *musb, int is_on)\r\n{\r\nWARN_ON(is_on && is_peripheral_active(musb));\r\n}\r\nstatic void otg_timer(unsigned long _musb)\r\n{\r\nstruct musb *musb = (void *)_musb;\r\nvoid __iomem *mregs = musb->mregs;\r\nu8 devctl;\r\nunsigned long flags;\r\ndevctl = musb_readb(mregs, MUSB_DEVCTL);\r\ndev_dbg(musb->controller, "Poll devctl %02x (%s)\n", devctl,\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\nspin_lock_irqsave(&musb->lock, flags);\r\nswitch (musb->xceiv->otg->state) {\r\ncase OTG_STATE_A_WAIT_BCON:\r\ndevctl &= ~MUSB_DEVCTL_SESSION;\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nif (devctl & MUSB_DEVCTL_BDEVICE) {\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\nMUSB_DEV_MODE(musb);\r\n} else {\r\nmusb->xceiv->otg->state = OTG_STATE_A_IDLE;\r\nMUSB_HST_MODE(musb);\r\n}\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nif (devctl & MUSB_DEVCTL_VBUS) {\r\nmod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);\r\nbreak;\r\n}\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\r\nmusb_writel(musb->ctrl_base, DA8XX_USB_INTR_SRC_SET_REG,\r\nMUSB_INTR_VBUSERROR << DA8XX_INTR_USB_SHIFT);\r\nbreak;\r\ncase OTG_STATE_B_IDLE:\r\nmusb_writeb(mregs, MUSB_DEVCTL, devctl | MUSB_DEVCTL_SESSION);\r\ndevctl = musb_readb(mregs, MUSB_DEVCTL);\r\nif (devctl & MUSB_DEVCTL_BDEVICE)\r\nmod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);\r\nelse\r\nmusb->xceiv->otg->state = OTG_STATE_A_IDLE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nstatic void da8xx_musb_try_idle(struct musb *musb, unsigned long timeout)\r\n{\r\nstatic unsigned long last_timer;\r\nif (timeout == 0)\r\ntimeout = jiffies + msecs_to_jiffies(3);\r\nif (musb->is_active || (musb->a_wait_bcon == 0 &&\r\nmusb->xceiv->otg->state == OTG_STATE_A_WAIT_BCON)) {\r\ndev_dbg(musb->controller, "%s active, deleting timer\n",\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\ndel_timer(&otg_workaround);\r\nlast_timer = jiffies;\r\nreturn;\r\n}\r\nif (time_after(last_timer, timeout) && timer_pending(&otg_workaround)) {\r\ndev_dbg(musb->controller, "Longer idle timer already pending, ignoring...\n");\r\nreturn;\r\n}\r\nlast_timer = timeout;\r\ndev_dbg(musb->controller, "%s inactive, starting idle timer for %u ms\n",\r\nusb_otg_state_string(musb->xceiv->otg->state),\r\njiffies_to_msecs(timeout - jiffies));\r\nmod_timer(&otg_workaround, timeout);\r\n}\r\nstatic irqreturn_t da8xx_musb_interrupt(int irq, void *hci)\r\n{\r\nstruct musb *musb = hci;\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\nstruct usb_otg *otg = musb->xceiv->otg;\r\nunsigned long flags;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 status;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nstatus = musb_readl(reg_base, DA8XX_USB_INTR_SRC_MASKED_REG);\r\nif (!status)\r\ngoto eoi;\r\nmusb_writel(reg_base, DA8XX_USB_INTR_SRC_CLEAR_REG, status);\r\ndev_dbg(musb->controller, "USB IRQ %08x\n", status);\r\nmusb->int_rx = (status & DA8XX_INTR_RX_MASK) >> DA8XX_INTR_RX_SHIFT;\r\nmusb->int_tx = (status & DA8XX_INTR_TX_MASK) >> DA8XX_INTR_TX_SHIFT;\r\nmusb->int_usb = (status & DA8XX_INTR_USB_MASK) >> DA8XX_INTR_USB_SHIFT;\r\nif (status & (DA8XX_INTR_DRVVBUS << DA8XX_INTR_USB_SHIFT)) {\r\nint drvvbus = musb_readl(reg_base, DA8XX_USB_STAT_REG);\r\nvoid __iomem *mregs = musb->mregs;\r\nu8 devctl = musb_readb(mregs, MUSB_DEVCTL);\r\nint err;\r\nerr = musb->int_usb & MUSB_INTR_VBUSERROR;\r\nif (err) {\r\nmusb->int_usb &= ~MUSB_INTR_VBUSERROR;\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VFALL;\r\nmod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);\r\nWARNING("VBUS error workaround (delay coming)\n");\r\n} else if (drvvbus) {\r\nMUSB_HST_MODE(musb);\r\notg->default_a = 1;\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\r\nportstate(musb->port1_status |= USB_PORT_STAT_POWER);\r\ndel_timer(&otg_workaround);\r\n} else {\r\nmusb->is_active = 0;\r\nMUSB_DEV_MODE(musb);\r\notg->default_a = 0;\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\nportstate(musb->port1_status &= ~USB_PORT_STAT_POWER);\r\n}\r\ndev_dbg(musb->controller, "VBUS %s (%s)%s, devctl %02x\n",\r\ndrvvbus ? "on" : "off",\r\nusb_otg_state_string(musb->xceiv->otg->state),\r\nerr ? " ERROR" : "",\r\ndevctl);\r\nret = IRQ_HANDLED;\r\n}\r\nif (musb->int_tx || musb->int_rx || musb->int_usb)\r\nret |= musb_interrupt(musb);\r\neoi:\r\nif (ret == IRQ_HANDLED || status)\r\nmusb_writel(reg_base, DA8XX_USB_END_OF_INTR_REG, 0);\r\nif (musb->xceiv->otg->state == OTG_STATE_B_IDLE)\r\nmod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int da8xx_musb_set_mode(struct musb *musb, u8 musb_mode)\r\n{\r\nstruct da8xx_glue *glue = dev_get_drvdata(musb->controller->parent);\r\nenum phy_mode phy_mode;\r\nif (!musb->is_initialized)\r\nreturn phy_set_mode(glue->phy, PHY_MODE_USB_OTG);\r\nswitch (musb_mode) {\r\ncase MUSB_HOST:\r\nphy_mode = PHY_MODE_USB_HOST;\r\nbreak;\r\ncase MUSB_PERIPHERAL:\r\nphy_mode = PHY_MODE_USB_DEVICE;\r\nbreak;\r\ncase MUSB_OTG:\r\nphy_mode = PHY_MODE_USB_OTG;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn phy_set_mode(glue->phy, phy_mode);\r\n}\r\nstatic int da8xx_musb_init(struct musb *musb)\r\n{\r\nstruct da8xx_glue *glue = dev_get_drvdata(musb->controller->parent);\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\nu32 rev;\r\nint ret = -ENODEV;\r\nmusb->mregs += DA8XX_MENTOR_CORE_OFFSET;\r\nret = clk_prepare_enable(glue->clk);\r\nif (ret) {\r\ndev_err(glue->dev, "failed to enable clock\n");\r\nreturn ret;\r\n}\r\nrev = musb_readl(reg_base, DA8XX_USB_REVISION_REG);\r\nif (!rev)\r\ngoto fail;\r\nmusb->xceiv = usb_get_phy(USB_PHY_TYPE_USB2);\r\nif (IS_ERR_OR_NULL(musb->xceiv)) {\r\nret = -EPROBE_DEFER;\r\ngoto fail;\r\n}\r\nsetup_timer(&otg_workaround, otg_timer, (unsigned long)musb);\r\nmusb_writel(reg_base, DA8XX_USB_CTRL_REG, DA8XX_SOFT_RESET_MASK);\r\nret = phy_init(glue->phy);\r\nif (ret) {\r\ndev_err(glue->dev, "Failed to init phy.\n");\r\ngoto fail;\r\n}\r\nret = phy_power_on(glue->phy);\r\nif (ret) {\r\ndev_err(glue->dev, "Failed to power on phy.\n");\r\ngoto err_phy_power_on;\r\n}\r\nmsleep(5);\r\npr_debug("DA8xx OTG revision %08x, control %02x\n", rev,\r\nmusb_readb(reg_base, DA8XX_USB_CTRL_REG));\r\nmusb->isr = da8xx_musb_interrupt;\r\nreturn 0;\r\nerr_phy_power_on:\r\nphy_exit(glue->phy);\r\nfail:\r\nclk_disable_unprepare(glue->clk);\r\nreturn ret;\r\n}\r\nstatic int da8xx_musb_exit(struct musb *musb)\r\n{\r\nstruct da8xx_glue *glue = dev_get_drvdata(musb->controller->parent);\r\ndel_timer_sync(&otg_workaround);\r\nphy_power_off(glue->phy);\r\nphy_exit(glue->phy);\r\nclk_disable_unprepare(glue->clk);\r\nusb_put_phy(musb->xceiv);\r\nreturn 0;\r\n}\r\nstatic inline u8 get_vbus_power(struct device *dev)\r\n{\r\nstruct regulator *vbus_supply;\r\nint current_uA;\r\nvbus_supply = regulator_get_optional(dev, "vbus");\r\nif (IS_ERR(vbus_supply))\r\nreturn 255;\r\ncurrent_uA = regulator_get_current_limit(vbus_supply);\r\nregulator_put(vbus_supply);\r\nif (current_uA <= 0 || current_uA > 510000)\r\nreturn 255;\r\nreturn current_uA / 1000 / 2;\r\n}\r\nstatic void da8xx_dma_controller_callback(struct dma_controller *c)\r\n{\r\nstruct musb *musb = c->musb;\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\nmusb_writel(reg_base, DA8XX_USB_END_OF_INTR_REG, 0);\r\n}\r\nstatic struct dma_controller *\r\nda8xx_dma_controller_create(struct musb *musb, void __iomem *base)\r\n{\r\nstruct dma_controller *controller;\r\ncontroller = cppi41_dma_controller_create(musb, base);\r\nif (IS_ERR_OR_NULL(controller))\r\nreturn controller;\r\ncontroller->dma_callback = da8xx_dma_controller_callback;\r\nreturn controller;\r\n}\r\nstatic int da8xx_probe(struct platform_device *pdev)\r\n{\r\nstruct resource musb_resources[2];\r\nstruct musb_hdrc_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct da8xx_glue *glue;\r\nstruct platform_device_info pinfo;\r\nstruct clk *clk;\r\nstruct device_node *np = pdev->dev.of_node;\r\nint ret;\r\nglue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);\r\nif (!glue)\r\nreturn -ENOMEM;\r\nclk = devm_clk_get(&pdev->dev, "usb20");\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nglue->phy = devm_phy_get(&pdev->dev, "usb-phy");\r\nif (IS_ERR(glue->phy)) {\r\nif (PTR_ERR(glue->phy) != -EPROBE_DEFER)\r\ndev_err(&pdev->dev, "failed to get phy\n");\r\nreturn PTR_ERR(glue->phy);\r\n}\r\nglue->dev = &pdev->dev;\r\nglue->clk = clk;\r\nif (IS_ENABLED(CONFIG_OF) && np) {\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\npdata->config = &da8xx_config;\r\npdata->mode = musb_get_mode(&pdev->dev);\r\npdata->power = get_vbus_power(&pdev->dev);\r\n}\r\npdata->platform_ops = &da8xx_ops;\r\nglue->usb_phy = usb_phy_generic_register();\r\nret = PTR_ERR_OR_ZERO(glue->usb_phy);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register usb_phy\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, glue);\r\nret = of_platform_populate(pdev->dev.of_node, NULL,\r\nda8xx_auxdata_lookup, &pdev->dev);\r\nif (ret)\r\nreturn ret;\r\nmemset(musb_resources, 0x00, sizeof(*musb_resources) *\r\nARRAY_SIZE(musb_resources));\r\nmusb_resources[0].name = pdev->resource[0].name;\r\nmusb_resources[0].start = pdev->resource[0].start;\r\nmusb_resources[0].end = pdev->resource[0].end;\r\nmusb_resources[0].flags = pdev->resource[0].flags;\r\nmusb_resources[1].name = pdev->resource[1].name;\r\nmusb_resources[1].start = pdev->resource[1].start;\r\nmusb_resources[1].end = pdev->resource[1].end;\r\nmusb_resources[1].flags = pdev->resource[1].flags;\r\npinfo = da8xx_dev_info;\r\npinfo.parent = &pdev->dev;\r\npinfo.res = musb_resources;\r\npinfo.num_res = ARRAY_SIZE(musb_resources);\r\npinfo.data = pdata;\r\npinfo.size_data = sizeof(*pdata);\r\nglue->musb = platform_device_register_full(&pinfo);\r\nret = PTR_ERR_OR_ZERO(glue->musb);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register musb device: %d\n", ret);\r\nusb_phy_generic_unregister(glue->usb_phy);\r\n}\r\nreturn ret;\r\n}\r\nstatic int da8xx_remove(struct platform_device *pdev)\r\n{\r\nstruct da8xx_glue *glue = platform_get_drvdata(pdev);\r\nplatform_device_unregister(glue->musb);\r\nusb_phy_generic_unregister(glue->usb_phy);\r\nreturn 0;\r\n}\r\nstatic int da8xx_suspend(struct device *dev)\r\n{\r\nint ret;\r\nstruct da8xx_glue *glue = dev_get_drvdata(dev);\r\nret = phy_power_off(glue->phy);\r\nif (ret)\r\nreturn ret;\r\nclk_disable_unprepare(glue->clk);\r\nreturn 0;\r\n}\r\nstatic int da8xx_resume(struct device *dev)\r\n{\r\nint ret;\r\nstruct da8xx_glue *glue = dev_get_drvdata(dev);\r\nret = clk_prepare_enable(glue->clk);\r\nif (ret)\r\nreturn ret;\r\nreturn phy_power_on(glue->phy);\r\n}
