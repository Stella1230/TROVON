int st_lsm6dsx_write_with_mask(struct st_lsm6dsx_hw *hw, u8 addr, u8 mask,\r\nu8 val)\r\n{\r\nu8 data;\r\nint err;\r\nmutex_lock(&hw->lock);\r\nerr = hw->tf->read(hw->dev, addr, sizeof(data), &data);\r\nif (err < 0) {\r\ndev_err(hw->dev, "failed to read %02x register\n", addr);\r\ngoto out;\r\n}\r\ndata = (data & ~mask) | ((val << __ffs(mask)) & mask);\r\nerr = hw->tf->write(hw->dev, addr, sizeof(data), &data);\r\nif (err < 0)\r\ndev_err(hw->dev, "failed to write %02x register\n", addr);\r\nout:\r\nmutex_unlock(&hw->lock);\r\nreturn err;\r\n}\r\nstatic int st_lsm6dsx_check_whoami(struct st_lsm6dsx_hw *hw, int id)\r\n{\r\nint err, i, j;\r\nu8 data;\r\nfor (i = 0; i < ARRAY_SIZE(st_lsm6dsx_sensor_settings); i++) {\r\nfor (j = 0; j < ST_LSM6DSX_MAX_ID; j++) {\r\nif (id == st_lsm6dsx_sensor_settings[i].id[j])\r\nbreak;\r\n}\r\nif (j < ST_LSM6DSX_MAX_ID)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(st_lsm6dsx_sensor_settings)) {\r\ndev_err(hw->dev, "unsupported hw id [%02x]\n", id);\r\nreturn -ENODEV;\r\n}\r\nerr = hw->tf->read(hw->dev, ST_LSM6DSX_REG_WHOAMI_ADDR, sizeof(data),\r\n&data);\r\nif (err < 0) {\r\ndev_err(hw->dev, "failed to read whoami register\n");\r\nreturn err;\r\n}\r\nif (data != st_lsm6dsx_sensor_settings[i].wai) {\r\ndev_err(hw->dev, "unsupported whoami [%02x]\n", data);\r\nreturn -ENODEV;\r\n}\r\nhw->settings = &st_lsm6dsx_sensor_settings[i];\r\nreturn 0;\r\n}\r\nstatic int st_lsm6dsx_set_full_scale(struct st_lsm6dsx_sensor *sensor,\r\nu32 gain)\r\n{\r\nenum st_lsm6dsx_sensor_id id = sensor->id;\r\nint i, err;\r\nu8 val;\r\nfor (i = 0; i < ST_LSM6DSX_FS_LIST_SIZE; i++)\r\nif (st_lsm6dsx_fs_table[id].fs_avl[i].gain == gain)\r\nbreak;\r\nif (i == ST_LSM6DSX_FS_LIST_SIZE)\r\nreturn -EINVAL;\r\nval = st_lsm6dsx_fs_table[id].fs_avl[i].val;\r\nerr = st_lsm6dsx_write_with_mask(sensor->hw,\r\nst_lsm6dsx_fs_table[id].reg.addr,\r\nst_lsm6dsx_fs_table[id].reg.mask,\r\nval);\r\nif (err < 0)\r\nreturn err;\r\nsensor->gain = gain;\r\nreturn 0;\r\n}\r\nstatic int st_lsm6dsx_check_odr(struct st_lsm6dsx_sensor *sensor, u16 odr,\r\nu8 *val)\r\n{\r\nint i;\r\nfor (i = 0; i < ST_LSM6DSX_ODR_LIST_SIZE; i++)\r\nif (st_lsm6dsx_odr_table[sensor->id].odr_avl[i].hz == odr)\r\nbreak;\r\nif (i == ST_LSM6DSX_ODR_LIST_SIZE)\r\nreturn -EINVAL;\r\n*val = st_lsm6dsx_odr_table[sensor->id].odr_avl[i].val;\r\nsensor->odr = odr;\r\nreturn 0;\r\n}\r\nstatic int st_lsm6dsx_set_odr(struct st_lsm6dsx_sensor *sensor, u16 odr)\r\n{\r\nenum st_lsm6dsx_sensor_id id = sensor->id;\r\nint err;\r\nu8 val;\r\nerr = st_lsm6dsx_check_odr(sensor, odr, &val);\r\nif (err < 0)\r\nreturn err;\r\nreturn st_lsm6dsx_write_with_mask(sensor->hw,\r\nst_lsm6dsx_odr_table[id].reg.addr,\r\nst_lsm6dsx_odr_table[id].reg.mask,\r\nval);\r\n}\r\nint st_lsm6dsx_sensor_enable(struct st_lsm6dsx_sensor *sensor)\r\n{\r\nint err;\r\nerr = st_lsm6dsx_set_odr(sensor, sensor->odr);\r\nif (err < 0)\r\nreturn err;\r\nsensor->hw->enable_mask |= BIT(sensor->id);\r\nreturn 0;\r\n}\r\nint st_lsm6dsx_sensor_disable(struct st_lsm6dsx_sensor *sensor)\r\n{\r\nenum st_lsm6dsx_sensor_id id = sensor->id;\r\nint err;\r\nerr = st_lsm6dsx_write_with_mask(sensor->hw,\r\nst_lsm6dsx_odr_table[id].reg.addr,\r\nst_lsm6dsx_odr_table[id].reg.mask, 0);\r\nif (err < 0)\r\nreturn err;\r\nsensor->hw->enable_mask &= ~BIT(id);\r\nreturn 0;\r\n}\r\nstatic int st_lsm6dsx_read_oneshot(struct st_lsm6dsx_sensor *sensor,\r\nu8 addr, int *val)\r\n{\r\nint err, delay;\r\n__le16 data;\r\nerr = st_lsm6dsx_sensor_enable(sensor);\r\nif (err < 0)\r\nreturn err;\r\ndelay = 1000000 / sensor->odr;\r\nusleep_range(delay, 2 * delay);\r\nerr = sensor->hw->tf->read(sensor->hw->dev, addr, sizeof(data),\r\n(u8 *)&data);\r\nif (err < 0)\r\nreturn err;\r\nst_lsm6dsx_sensor_disable(sensor);\r\n*val = (s16)data;\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int st_lsm6dsx_read_raw(struct iio_dev *iio_dev,\r\nstruct iio_chan_spec const *ch,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = iio_device_claim_direct_mode(iio_dev);\r\nif (ret)\r\nbreak;\r\nret = st_lsm6dsx_read_oneshot(sensor, ch->address, val);\r\niio_device_release_direct_mode(iio_dev);\r\nbreak;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\n*val = sensor->odr;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = 0;\r\n*val2 = sensor->gain;\r\nret = IIO_VAL_INT_PLUS_MICRO;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int st_lsm6dsx_write_raw(struct iio_dev *iio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\r\nint err;\r\nerr = iio_device_claim_direct_mode(iio_dev);\r\nif (err)\r\nreturn err;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nerr = st_lsm6dsx_set_full_scale(sensor, val2);\r\nbreak;\r\ncase IIO_CHAN_INFO_SAMP_FREQ: {\r\nu8 data;\r\nerr = st_lsm6dsx_check_odr(sensor, val, &data);\r\nbreak;\r\n}\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\niio_device_release_direct_mode(iio_dev);\r\nreturn err;\r\n}\r\nstatic int st_lsm6dsx_set_watermark(struct iio_dev *iio_dev, unsigned int val)\r\n{\r\nstruct st_lsm6dsx_sensor *sensor = iio_priv(iio_dev);\r\nstruct st_lsm6dsx_hw *hw = sensor->hw;\r\nint err, max_fifo_len;\r\nmax_fifo_len = hw->settings->max_fifo_size / ST_LSM6DSX_SAMPLE_SIZE;\r\nif (val < 1 || val > max_fifo_len)\r\nreturn -EINVAL;\r\nerr = st_lsm6dsx_update_watermark(sensor, val);\r\nif (err < 0)\r\nreturn err;\r\nsensor->watermark = val;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nst_lsm6dsx_sysfs_sampling_frequency_avail(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct st_lsm6dsx_sensor *sensor = iio_priv(dev_get_drvdata(dev));\r\nenum st_lsm6dsx_sensor_id id = sensor->id;\r\nint i, len = 0;\r\nfor (i = 0; i < ST_LSM6DSX_ODR_LIST_SIZE; i++)\r\nlen += scnprintf(buf + len, PAGE_SIZE - len, "%d ",\r\nst_lsm6dsx_odr_table[id].odr_avl[i].hz);\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nstatic ssize_t st_lsm6dsx_sysfs_scale_avail(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct st_lsm6dsx_sensor *sensor = iio_priv(dev_get_drvdata(dev));\r\nenum st_lsm6dsx_sensor_id id = sensor->id;\r\nint i, len = 0;\r\nfor (i = 0; i < ST_LSM6DSX_FS_LIST_SIZE; i++)\r\nlen += scnprintf(buf + len, PAGE_SIZE - len, "0.%06u ",\r\nst_lsm6dsx_fs_table[id].fs_avl[i].gain);\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nstatic int st_lsm6dsx_of_get_drdy_pin(struct st_lsm6dsx_hw *hw, int *drdy_pin)\r\n{\r\nstruct device_node *np = hw->dev->of_node;\r\nif (!np)\r\nreturn -EINVAL;\r\nreturn of_property_read_u32(np, "st,drdy-int-pin", drdy_pin);\r\n}\r\nstatic int st_lsm6dsx_get_drdy_reg(struct st_lsm6dsx_hw *hw, u8 *drdy_reg)\r\n{\r\nint err = 0, drdy_pin;\r\nif (st_lsm6dsx_of_get_drdy_pin(hw, &drdy_pin) < 0) {\r\nstruct st_sensors_platform_data *pdata;\r\nstruct device *dev = hw->dev;\r\npdata = (struct st_sensors_platform_data *)dev->platform_data;\r\ndrdy_pin = pdata ? pdata->drdy_int_pin : 1;\r\n}\r\nswitch (drdy_pin) {\r\ncase 1:\r\n*drdy_reg = ST_LSM6DSX_REG_INT1_ADDR;\r\nbreak;\r\ncase 2:\r\n*drdy_reg = ST_LSM6DSX_REG_INT2_ADDR;\r\nbreak;\r\ndefault:\r\ndev_err(hw->dev, "unsupported data ready pin\n");\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int st_lsm6dsx_init_device(struct st_lsm6dsx_hw *hw)\r\n{\r\nu8 data, drdy_int_reg;\r\nint err;\r\ndata = ST_LSM6DSX_REG_RESET_MASK;\r\nerr = hw->tf->write(hw->dev, ST_LSM6DSX_REG_RESET_ADDR, sizeof(data),\r\n&data);\r\nif (err < 0)\r\nreturn err;\r\nmsleep(200);\r\nerr = st_lsm6dsx_write_with_mask(hw, ST_LSM6DSX_REG_LIR_ADDR,\r\nST_LSM6DSX_REG_LIR_MASK, 1);\r\nif (err < 0)\r\nreturn err;\r\nerr = st_lsm6dsx_write_with_mask(hw, ST_LSM6DSX_REG_BDU_ADDR,\r\nST_LSM6DSX_REG_BDU_MASK, 1);\r\nif (err < 0)\r\nreturn err;\r\nerr = st_lsm6dsx_write_with_mask(hw, ST_LSM6DSX_REG_ROUNDING_ADDR,\r\nST_LSM6DSX_REG_ROUNDING_MASK, 1);\r\nif (err < 0)\r\nreturn err;\r\nerr = st_lsm6dsx_get_drdy_reg(hw, &drdy_int_reg);\r\nif (err < 0)\r\nreturn err;\r\nreturn st_lsm6dsx_write_with_mask(hw, drdy_int_reg,\r\nST_LSM6DSX_REG_FIFO_FTH_IRQ_MASK, 1);\r\n}\r\nstatic struct iio_dev *st_lsm6dsx_alloc_iiodev(struct st_lsm6dsx_hw *hw,\r\nenum st_lsm6dsx_sensor_id id,\r\nconst char *name)\r\n{\r\nstruct st_lsm6dsx_sensor *sensor;\r\nstruct iio_dev *iio_dev;\r\niio_dev = devm_iio_device_alloc(hw->dev, sizeof(*sensor));\r\nif (!iio_dev)\r\nreturn NULL;\r\niio_dev->modes = INDIO_DIRECT_MODE;\r\niio_dev->dev.parent = hw->dev;\r\niio_dev->available_scan_masks = st_lsm6dsx_available_scan_masks;\r\nsensor = iio_priv(iio_dev);\r\nsensor->id = id;\r\nsensor->hw = hw;\r\nsensor->odr = st_lsm6dsx_odr_table[id].odr_avl[0].hz;\r\nsensor->gain = st_lsm6dsx_fs_table[id].fs_avl[0].gain;\r\nsensor->watermark = 1;\r\nswitch (id) {\r\ncase ST_LSM6DSX_ID_ACC:\r\niio_dev->channels = st_lsm6dsx_acc_channels;\r\niio_dev->num_channels = ARRAY_SIZE(st_lsm6dsx_acc_channels);\r\niio_dev->info = &st_lsm6dsx_acc_info;\r\nsensor->decimator_mask = ST_LSM6DSX_REG_ACC_DEC_MASK;\r\nscnprintf(sensor->name, sizeof(sensor->name), "%s_accel",\r\nname);\r\nbreak;\r\ncase ST_LSM6DSX_ID_GYRO:\r\niio_dev->channels = st_lsm6dsx_gyro_channels;\r\niio_dev->num_channels = ARRAY_SIZE(st_lsm6dsx_gyro_channels);\r\niio_dev->info = &st_lsm6dsx_gyro_info;\r\nsensor->decimator_mask = ST_LSM6DSX_REG_GYRO_DEC_MASK;\r\nscnprintf(sensor->name, sizeof(sensor->name), "%s_gyro",\r\nname);\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\niio_dev->name = sensor->name;\r\nreturn iio_dev;\r\n}\r\nint st_lsm6dsx_probe(struct device *dev, int irq, int hw_id, const char *name,\r\nconst struct st_lsm6dsx_transfer_function *tf_ops)\r\n{\r\nstruct st_lsm6dsx_hw *hw;\r\nint i, err;\r\nhw = devm_kzalloc(dev, sizeof(*hw), GFP_KERNEL);\r\nif (!hw)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, (void *)hw);\r\nmutex_init(&hw->lock);\r\nmutex_init(&hw->fifo_lock);\r\nhw->dev = dev;\r\nhw->irq = irq;\r\nhw->tf = tf_ops;\r\nerr = st_lsm6dsx_check_whoami(hw, hw_id);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < ST_LSM6DSX_ID_MAX; i++) {\r\nhw->iio_devs[i] = st_lsm6dsx_alloc_iiodev(hw, i, name);\r\nif (!hw->iio_devs[i])\r\nreturn -ENOMEM;\r\n}\r\nerr = st_lsm6dsx_init_device(hw);\r\nif (err < 0)\r\nreturn err;\r\nif (hw->irq > 0) {\r\nerr = st_lsm6dsx_fifo_setup(hw);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ST_LSM6DSX_ID_MAX; i++) {\r\nerr = devm_iio_device_register(hw->dev, hw->iio_devs[i]);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused st_lsm6dsx_suspend(struct device *dev)\r\n{\r\nstruct st_lsm6dsx_hw *hw = dev_get_drvdata(dev);\r\nstruct st_lsm6dsx_sensor *sensor;\r\nint i, err = 0;\r\nfor (i = 0; i < ST_LSM6DSX_ID_MAX; i++) {\r\nsensor = iio_priv(hw->iio_devs[i]);\r\nif (!(hw->enable_mask & BIT(sensor->id)))\r\ncontinue;\r\nerr = st_lsm6dsx_write_with_mask(hw,\r\nst_lsm6dsx_odr_table[sensor->id].reg.addr,\r\nst_lsm6dsx_odr_table[sensor->id].reg.mask, 0);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (hw->fifo_mode != ST_LSM6DSX_FIFO_BYPASS)\r\nerr = st_lsm6dsx_flush_fifo(hw);\r\nreturn err;\r\n}\r\nstatic int __maybe_unused st_lsm6dsx_resume(struct device *dev)\r\n{\r\nstruct st_lsm6dsx_hw *hw = dev_get_drvdata(dev);\r\nstruct st_lsm6dsx_sensor *sensor;\r\nint i, err = 0;\r\nfor (i = 0; i < ST_LSM6DSX_ID_MAX; i++) {\r\nsensor = iio_priv(hw->iio_devs[i]);\r\nif (!(hw->enable_mask & BIT(sensor->id)))\r\ncontinue;\r\nerr = st_lsm6dsx_set_odr(sensor, sensor->odr);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (hw->enable_mask)\r\nerr = st_lsm6dsx_set_fifo_mode(hw, ST_LSM6DSX_FIFO_CONT);\r\nreturn err;\r\n}
