static void ti_thermal_work(struct work_struct *work)\r\n{\r\nstruct ti_thermal_data *data = container_of(work,\r\nstruct ti_thermal_data, thermal_wq);\r\nthermal_zone_device_update(data->ti_thermal, THERMAL_EVENT_UNSPECIFIED);\r\ndev_dbg(&data->ti_thermal->device, "updated thermal zone %s\n",\r\ndata->ti_thermal->type);\r\n}\r\nstatic inline int ti_thermal_hotspot_temperature(int t, int s, int c)\r\n{\r\nint delta = t * s / 1000 + c;\r\nif (delta < 0)\r\ndelta = 0;\r\nreturn t + delta;\r\n}\r\nstatic inline int __ti_thermal_get_temp(void *devdata, int *temp)\r\n{\r\nstruct thermal_zone_device *pcb_tz = NULL;\r\nstruct ti_thermal_data *data = devdata;\r\nstruct ti_bandgap *bgp;\r\nconst struct ti_temp_sensor *s;\r\nint ret, tmp, slope, constant;\r\nint pcb_temp;\r\nif (!data)\r\nreturn 0;\r\nbgp = data->bgp;\r\ns = &bgp->conf->sensors[data->sensor_id];\r\nret = ti_bandgap_read_temperature(bgp, data->sensor_id, &tmp);\r\nif (ret)\r\nreturn ret;\r\nslope = thermal_zone_get_slope(data->ti_thermal);\r\nconstant = thermal_zone_get_offset(data->ti_thermal);\r\npcb_tz = data->pcb_tz;\r\nif (!IS_ERR(pcb_tz)) {\r\nret = thermal_zone_get_temp(pcb_tz, &pcb_temp);\r\nif (!ret) {\r\ntmp -= pcb_temp;\r\nslope = s->slope_pcb;\r\nconstant = s->constant_pcb;\r\n} else {\r\ndev_err(bgp->dev,\r\n"Failed to read PCB state. Using defaults\n");\r\nret = 0;\r\n}\r\n}\r\n*temp = ti_thermal_hotspot_temperature(tmp, slope, constant);\r\nreturn ret;\r\n}\r\nstatic inline int ti_thermal_get_temp(struct thermal_zone_device *thermal,\r\nint *temp)\r\n{\r\nstruct ti_thermal_data *data = thermal->devdata;\r\nreturn __ti_thermal_get_temp(data, temp);\r\n}\r\nstatic int __ti_thermal_get_trend(void *p, int trip, enum thermal_trend *trend)\r\n{\r\nstruct ti_thermal_data *data = p;\r\nstruct ti_bandgap *bgp;\r\nint id, tr, ret = 0;\r\nbgp = data->bgp;\r\nid = data->sensor_id;\r\nret = ti_bandgap_get_trend(bgp, id, &tr);\r\nif (ret)\r\nreturn ret;\r\nif (tr > 0)\r\n*trend = THERMAL_TREND_RAISING;\r\nelse if (tr < 0)\r\n*trend = THERMAL_TREND_DROPPING;\r\nelse\r\n*trend = THERMAL_TREND_STABLE;\r\nreturn 0;\r\n}\r\nstatic struct ti_thermal_data\r\n*ti_thermal_build_data(struct ti_bandgap *bgp, int id)\r\n{\r\nstruct ti_thermal_data *data;\r\ndata = devm_kzalloc(bgp->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\ndev_err(bgp->dev, "kzalloc fail\n");\r\nreturn NULL;\r\n}\r\ndata->sensor_id = id;\r\ndata->bgp = bgp;\r\ndata->mode = THERMAL_DEVICE_ENABLED;\r\ndata->pcb_tz = thermal_zone_get_zone_by_name("pcb");\r\nINIT_WORK(&data->thermal_wq, ti_thermal_work);\r\nreturn data;\r\n}\r\nint ti_thermal_expose_sensor(struct ti_bandgap *bgp, int id,\r\nchar *domain)\r\n{\r\nstruct ti_thermal_data *data;\r\ndata = ti_bandgap_get_sensor_data(bgp, id);\r\nif (!data || IS_ERR(data))\r\ndata = ti_thermal_build_data(bgp, id);\r\nif (!data)\r\nreturn -EINVAL;\r\ndata->ti_thermal = devm_thermal_zone_of_sensor_register(bgp->dev, id,\r\ndata, &ti_of_thermal_ops);\r\nif (IS_ERR(data->ti_thermal)) {\r\ndev_err(bgp->dev, "thermal zone device is NULL\n");\r\nreturn PTR_ERR(data->ti_thermal);\r\n}\r\nti_bandgap_set_sensor_data(bgp, id, data);\r\nti_bandgap_write_update_interval(bgp, data->sensor_id,\r\ndata->ti_thermal->polling_delay);\r\nreturn 0;\r\n}\r\nint ti_thermal_remove_sensor(struct ti_bandgap *bgp, int id)\r\n{\r\nstruct ti_thermal_data *data;\r\ndata = ti_bandgap_get_sensor_data(bgp, id);\r\nif (data && data->ti_thermal) {\r\nif (data->our_zone)\r\nthermal_zone_device_unregister(data->ti_thermal);\r\n}\r\nreturn 0;\r\n}\r\nint ti_thermal_report_sensor_temperature(struct ti_bandgap *bgp, int id)\r\n{\r\nstruct ti_thermal_data *data;\r\ndata = ti_bandgap_get_sensor_data(bgp, id);\r\nschedule_work(&data->thermal_wq);\r\nreturn 0;\r\n}\r\nint ti_thermal_register_cpu_cooling(struct ti_bandgap *bgp, int id)\r\n{\r\nstruct ti_thermal_data *data;\r\nstruct device_node *np = bgp->dev->of_node;\r\nif (of_find_property(np, "#thermal-sensor-cells", NULL))\r\nreturn 0;\r\ndata = ti_bandgap_get_sensor_data(bgp, id);\r\nif (!data || IS_ERR(data))\r\ndata = ti_thermal_build_data(bgp, id);\r\nif (!data)\r\nreturn -EINVAL;\r\ndata->policy = cpufreq_cpu_get(0);\r\nif (!data->policy) {\r\npr_debug("%s: CPUFreq policy not found\n", __func__);\r\nreturn -EPROBE_DEFER;\r\n}\r\ndata->cool_dev = cpufreq_cooling_register(data->policy);\r\nif (IS_ERR(data->cool_dev)) {\r\nint ret = PTR_ERR(data->cool_dev);\r\ndev_err(bgp->dev, "Failed to register cpu cooling device %d\n",\r\nret);\r\ncpufreq_cpu_put(data->policy);\r\nreturn ret;\r\n}\r\nti_bandgap_set_sensor_data(bgp, id, data);\r\nreturn 0;\r\n}\r\nint ti_thermal_unregister_cpu_cooling(struct ti_bandgap *bgp, int id)\r\n{\r\nstruct ti_thermal_data *data;\r\ndata = ti_bandgap_get_sensor_data(bgp, id);\r\nif (data) {\r\ncpufreq_cooling_unregister(data->cool_dev);\r\ncpufreq_cpu_put(data->policy);\r\n}\r\nreturn 0;\r\n}
