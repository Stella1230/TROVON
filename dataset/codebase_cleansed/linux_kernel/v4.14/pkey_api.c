static void __init pkey_debug_init(void)\r\n{\r\ndebug_info = debug_register("pkey", 1, 1, 4 * sizeof(long));\r\ndebug_register_view(debug_info, &debug_sprintf_view);\r\ndebug_set_level(debug_info, 3);\r\n}\r\nstatic void __exit pkey_debug_exit(void)\r\n{\r\ndebug_unregister(debug_info);\r\n}\r\nstatic int check_secaeskeytoken(const u8 *token, int keybitsize)\r\n{\r\nstruct secaeskeytoken *t = (struct secaeskeytoken *) token;\r\nif (t->type != 0x01) {\r\nDEBUG_ERR(\r\n"check_secaeskeytoken secure token check failed, type mismatch 0x%02x != 0x01\n",\r\n(int) t->type);\r\nreturn -EINVAL;\r\n}\r\nif (t->version != 0x04) {\r\nDEBUG_ERR(\r\n"check_secaeskeytoken secure token check failed, version mismatch 0x%02x != 0x04\n",\r\n(int) t->version);\r\nreturn -EINVAL;\r\n}\r\nif (keybitsize > 0 && t->bitsize != keybitsize) {\r\nDEBUG_ERR(\r\n"check_secaeskeytoken secure token check failed, bitsize mismatch %d != %d\n",\r\n(int) t->bitsize, keybitsize);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alloc_and_prep_cprbmem(size_t paramblen,\r\nu8 **pcprbmem,\r\nstruct CPRBX **preqCPRB,\r\nstruct CPRBX **prepCPRB)\r\n{\r\nu8 *cprbmem;\r\nsize_t cprbplusparamblen = sizeof(struct CPRBX) + paramblen;\r\nstruct CPRBX *preqcblk, *prepcblk;\r\ncprbmem = kmalloc(2 * cprbplusparamblen, GFP_KERNEL);\r\nif (!cprbmem)\r\nreturn -ENOMEM;\r\nmemset(cprbmem, 0, 2 * cprbplusparamblen);\r\npreqcblk = (struct CPRBX *) cprbmem;\r\nprepcblk = (struct CPRBX *) (cprbmem + cprbplusparamblen);\r\npreqcblk->cprb_len = sizeof(struct CPRBX);\r\npreqcblk->cprb_ver_id = 0x02;\r\nmemcpy(preqcblk->func_id, "T2", 2);\r\npreqcblk->rpl_msgbl = cprbplusparamblen;\r\nif (paramblen) {\r\npreqcblk->req_parmb =\r\n((u8 *) preqcblk) + sizeof(struct CPRBX);\r\npreqcblk->rpl_parmb =\r\n((u8 *) prepcblk) + sizeof(struct CPRBX);\r\n}\r\n*pcprbmem = cprbmem;\r\n*preqCPRB = preqcblk;\r\n*prepCPRB = prepcblk;\r\nreturn 0;\r\n}\r\nstatic void free_cprbmem(void *mem, size_t paramblen, int scrub)\r\n{\r\nif (scrub)\r\nmemzero_explicit(mem, 2 * (sizeof(struct CPRBX) + paramblen));\r\nkfree(mem);\r\n}\r\nstatic inline void prep_xcrb(struct ica_xcRB *pxcrb,\r\nu16 cardnr,\r\nstruct CPRBX *preqcblk,\r\nstruct CPRBX *prepcblk)\r\n{\r\nmemset(pxcrb, 0, sizeof(*pxcrb));\r\npxcrb->agent_ID = 0x4341;\r\npxcrb->user_defined = (cardnr == 0xFFFF ? AUTOSELECT : cardnr);\r\npxcrb->request_control_blk_length =\r\npreqcblk->cprb_len + preqcblk->req_parml;\r\npxcrb->request_control_blk_addr = (void __user *) preqcblk;\r\npxcrb->reply_control_blk_length = preqcblk->rpl_msgbl;\r\npxcrb->reply_control_blk_addr = (void __user *) prepcblk;\r\n}\r\nstatic inline int _zcrypt_send_cprb(struct ica_xcRB *xcrb)\r\n{\r\nint rc;\r\nmm_segment_t old_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nrc = zcrypt_send_cprb(xcrb);\r\nset_fs(old_fs);\r\nreturn rc;\r\n}\r\nint pkey_genseckey(u16 cardnr, u16 domain,\r\nu32 keytype, struct pkey_seckey *seckey)\r\n{\r\nint i, rc, keysize;\r\nint seckeysize;\r\nu8 *mem;\r\nstruct CPRBX *preqcblk, *prepcblk;\r\nstruct ica_xcRB xcrb;\r\nstruct kgreqparm {\r\nu8 subfunc_code[2];\r\nu16 rule_array_len;\r\nstruct lv1 {\r\nu16 len;\r\nchar key_form[8];\r\nchar key_length[8];\r\nchar key_type1[8];\r\nchar key_type2[8];\r\n} lv1;\r\nstruct lv2 {\r\nu16 len;\r\nstruct keyid {\r\nu16 len;\r\nu16 attr;\r\nu8 data[SECKEYBLOBSIZE];\r\n} keyid[6];\r\n} lv2;\r\n} *preqparm;\r\nstruct kgrepparm {\r\nu8 subfunc_code[2];\r\nu16 rule_array_len;\r\nstruct lv3 {\r\nu16 len;\r\nu16 keyblocklen;\r\nstruct {\r\nu16 toklen;\r\nu16 tokattr;\r\nu8 tok[0];\r\n} keyblock;\r\n} lv3;\r\n} *prepparm;\r\nrc = alloc_and_prep_cprbmem(PARMBSIZE, &mem, &preqcblk, &prepcblk);\r\nif (rc)\r\nreturn rc;\r\npreqcblk->domain = domain;\r\npreqparm = (struct kgreqparm *) preqcblk->req_parmb;\r\nmemcpy(preqparm->subfunc_code, "KG", 2);\r\npreqparm->rule_array_len = sizeof(preqparm->rule_array_len);\r\npreqparm->lv1.len = sizeof(struct lv1);\r\nmemcpy(preqparm->lv1.key_form, "OP ", 8);\r\nswitch (keytype) {\r\ncase PKEY_KEYTYPE_AES_128:\r\nkeysize = 16;\r\nmemcpy(preqparm->lv1.key_length, "KEYLN16 ", 8);\r\nbreak;\r\ncase PKEY_KEYTYPE_AES_192:\r\nkeysize = 24;\r\nmemcpy(preqparm->lv1.key_length, "KEYLN24 ", 8);\r\nbreak;\r\ncase PKEY_KEYTYPE_AES_256:\r\nkeysize = 32;\r\nmemcpy(preqparm->lv1.key_length, "KEYLN32 ", 8);\r\nbreak;\r\ndefault:\r\nDEBUG_ERR(\r\n"pkey_genseckey unknown/unsupported keytype %d\n",\r\nkeytype);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nmemcpy(preqparm->lv1.key_type1, "AESDATA ", 8);\r\npreqparm->lv2.len = sizeof(struct lv2);\r\nfor (i = 0; i < 6; i++) {\r\npreqparm->lv2.keyid[i].len = sizeof(struct keyid);\r\npreqparm->lv2.keyid[i].attr = (i == 2 ? 0x30 : 0x10);\r\n}\r\npreqcblk->req_parml = sizeof(struct kgreqparm);\r\nprep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);\r\nrc = _zcrypt_send_cprb(&xcrb);\r\nif (rc) {\r\nDEBUG_ERR(\r\n"pkey_genseckey zcrypt_send_cprb (cardnr=%d domain=%d) failed with errno %d\n",\r\n(int) cardnr, (int) domain, rc);\r\ngoto out;\r\n}\r\nif (prepcblk->ccp_rtcode != 0) {\r\nDEBUG_ERR(\r\n"pkey_genseckey secure key generate failure, card response %d/%d\n",\r\n(int) prepcblk->ccp_rtcode,\r\n(int) prepcblk->ccp_rscode);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nprepcblk->rpl_parmb = ((u8 *) prepcblk) + sizeof(struct CPRBX);\r\nprepparm = (struct kgrepparm *) prepcblk->rpl_parmb;\r\nseckeysize = prepparm->lv3.keyblock.toklen\r\n- sizeof(prepparm->lv3.keyblock.toklen)\r\n- sizeof(prepparm->lv3.keyblock.tokattr);\r\nif (seckeysize != SECKEYBLOBSIZE) {\r\nDEBUG_ERR(\r\n"pkey_genseckey secure token size mismatch %d != %d bytes\n",\r\nseckeysize, SECKEYBLOBSIZE);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nrc = check_secaeskeytoken(prepparm->lv3.keyblock.tok, 8*keysize);\r\nif (rc) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nmemcpy(seckey->seckey, prepparm->lv3.keyblock.tok, SECKEYBLOBSIZE);\r\nout:\r\nfree_cprbmem(mem, PARMBSIZE, 0);\r\nreturn rc;\r\n}\r\nint pkey_clr2seckey(u16 cardnr, u16 domain, u32 keytype,\r\nconst struct pkey_clrkey *clrkey,\r\nstruct pkey_seckey *seckey)\r\n{\r\nint rc, keysize, seckeysize;\r\nu8 *mem;\r\nstruct CPRBX *preqcblk, *prepcblk;\r\nstruct ica_xcRB xcrb;\r\nstruct cmreqparm {\r\nu8 subfunc_code[2];\r\nu16 rule_array_len;\r\nchar rule_array[8];\r\nstruct lv1 {\r\nu16 len;\r\nu8 clrkey[0];\r\n} lv1;\r\nstruct lv2 {\r\nu16 len;\r\nstruct keyid {\r\nu16 len;\r\nu16 attr;\r\nu8 data[SECKEYBLOBSIZE];\r\n} keyid;\r\n} lv2;\r\n} *preqparm;\r\nstruct lv2 *plv2;\r\nstruct cmrepparm {\r\nu8 subfunc_code[2];\r\nu16 rule_array_len;\r\nstruct lv3 {\r\nu16 len;\r\nu16 keyblocklen;\r\nstruct {\r\nu16 toklen;\r\nu16 tokattr;\r\nu8 tok[0];\r\n} keyblock;\r\n} lv3;\r\n} *prepparm;\r\nrc = alloc_and_prep_cprbmem(PARMBSIZE, &mem, &preqcblk, &prepcblk);\r\nif (rc)\r\nreturn rc;\r\npreqcblk->domain = domain;\r\npreqparm = (struct cmreqparm *) preqcblk->req_parmb;\r\nmemcpy(preqparm->subfunc_code, "CM", 2);\r\nmemcpy(preqparm->rule_array, "AES ", 8);\r\npreqparm->rule_array_len =\r\nsizeof(preqparm->rule_array_len) + sizeof(preqparm->rule_array);\r\nswitch (keytype) {\r\ncase PKEY_KEYTYPE_AES_128:\r\nkeysize = 16;\r\nbreak;\r\ncase PKEY_KEYTYPE_AES_192:\r\nkeysize = 24;\r\nbreak;\r\ncase PKEY_KEYTYPE_AES_256:\r\nkeysize = 32;\r\nbreak;\r\ndefault:\r\nDEBUG_ERR(\r\n"pkey_clr2seckey unknown/unsupported keytype %d\n",\r\nkeytype);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\npreqparm->lv1.len = sizeof(struct lv1) + keysize;\r\nmemcpy(preqparm->lv1.clrkey, clrkey->clrkey, keysize);\r\nplv2 = (struct lv2 *) (((u8 *) &preqparm->lv2) + keysize);\r\nplv2->len = sizeof(struct lv2);\r\nplv2->keyid.len = sizeof(struct keyid);\r\nplv2->keyid.attr = 0x30;\r\npreqcblk->req_parml = sizeof(struct cmreqparm) + keysize;\r\nprep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);\r\nrc = _zcrypt_send_cprb(&xcrb);\r\nif (rc) {\r\nDEBUG_ERR(\r\n"pkey_clr2seckey zcrypt_send_cprb (cardnr=%d domain=%d) failed with errno %d\n",\r\n(int) cardnr, (int) domain, rc);\r\ngoto out;\r\n}\r\nif (prepcblk->ccp_rtcode != 0) {\r\nDEBUG_ERR(\r\n"pkey_clr2seckey clear key import failure, card response %d/%d\n",\r\n(int) prepcblk->ccp_rtcode,\r\n(int) prepcblk->ccp_rscode);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nprepcblk->rpl_parmb = ((u8 *) prepcblk) + sizeof(struct CPRBX);\r\nprepparm = (struct cmrepparm *) prepcblk->rpl_parmb;\r\nseckeysize = prepparm->lv3.keyblock.toklen\r\n- sizeof(prepparm->lv3.keyblock.toklen)\r\n- sizeof(prepparm->lv3.keyblock.tokattr);\r\nif (seckeysize != SECKEYBLOBSIZE) {\r\nDEBUG_ERR(\r\n"pkey_clr2seckey secure token size mismatch %d != %d bytes\n",\r\nseckeysize, SECKEYBLOBSIZE);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nrc = check_secaeskeytoken(prepparm->lv3.keyblock.tok, 8*keysize);\r\nif (rc) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nmemcpy(seckey->seckey, prepparm->lv3.keyblock.tok, SECKEYBLOBSIZE);\r\nout:\r\nfree_cprbmem(mem, PARMBSIZE, 1);\r\nreturn rc;\r\n}\r\nint pkey_sec2protkey(u16 cardnr, u16 domain,\r\nconst struct pkey_seckey *seckey,\r\nstruct pkey_protkey *protkey)\r\n{\r\nint rc;\r\nu8 *mem;\r\nstruct CPRBX *preqcblk, *prepcblk;\r\nstruct ica_xcRB xcrb;\r\nstruct uskreqparm {\r\nu8 subfunc_code[2];\r\nu16 rule_array_len;\r\nstruct lv1 {\r\nu16 len;\r\nu16 attr_len;\r\nu16 attr_flags;\r\n} lv1;\r\nstruct lv2 {\r\nu16 len;\r\nu16 attr_len;\r\nu16 attr_flags;\r\nu8 token[0];\r\n} lv2 __packed;\r\n} *preqparm;\r\nstruct uskrepparm {\r\nu8 subfunc_code[2];\r\nu16 rule_array_len;\r\nstruct lv3 {\r\nu16 len;\r\nu16 attr_len;\r\nu16 attr_flags;\r\nstruct cpacfkeyblock {\r\nu8 version;\r\nu8 flags[2];\r\nu8 algo;\r\nu8 form;\r\nu8 pad1[3];\r\nu16 keylen;\r\nu8 key[64];\r\nu16 keyattrlen;\r\nu8 keyattr[32];\r\nu8 pad2[1];\r\nu8 vptype;\r\nu8 vp[32];\r\n} keyblock;\r\n} lv3 __packed;\r\n} *prepparm;\r\nrc = alloc_and_prep_cprbmem(PARMBSIZE, &mem, &preqcblk, &prepcblk);\r\nif (rc)\r\nreturn rc;\r\npreqcblk->domain = domain;\r\npreqparm = (struct uskreqparm *) preqcblk->req_parmb;\r\nmemcpy(preqparm->subfunc_code, "US", 2);\r\npreqparm->rule_array_len = sizeof(preqparm->rule_array_len);\r\npreqparm->lv1.len = sizeof(struct lv1);\r\npreqparm->lv1.attr_len = sizeof(struct lv1) - sizeof(preqparm->lv1.len);\r\npreqparm->lv1.attr_flags = 0x0001;\r\npreqparm->lv2.len = sizeof(struct lv2) + SECKEYBLOBSIZE;\r\npreqparm->lv2.attr_len = sizeof(struct lv2)\r\n- sizeof(preqparm->lv2.len) + SECKEYBLOBSIZE;\r\npreqparm->lv2.attr_flags = 0x0000;\r\nmemcpy(preqparm->lv2.token, seckey->seckey, SECKEYBLOBSIZE);\r\npreqcblk->req_parml = sizeof(struct uskreqparm) + SECKEYBLOBSIZE;\r\nprep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);\r\nrc = _zcrypt_send_cprb(&xcrb);\r\nif (rc) {\r\nDEBUG_ERR(\r\n"pkey_sec2protkey zcrypt_send_cprb (cardnr=%d domain=%d) failed with errno %d\n",\r\n(int) cardnr, (int) domain, rc);\r\ngoto out;\r\n}\r\nif (prepcblk->ccp_rtcode != 0) {\r\nDEBUG_ERR(\r\n"pkey_sec2protkey unwrap secure key failure, card response %d/%d\n",\r\n(int) prepcblk->ccp_rtcode,\r\n(int) prepcblk->ccp_rscode);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nif (prepcblk->ccp_rscode != 0) {\r\nDEBUG_WARN(\r\n"pkey_sec2protkey unwrap secure key warning, card response %d/%d\n",\r\n(int) prepcblk->ccp_rtcode,\r\n(int) prepcblk->ccp_rscode);\r\n}\r\nprepcblk->rpl_parmb = ((u8 *) prepcblk) + sizeof(struct CPRBX);\r\nprepparm = (struct uskrepparm *) prepcblk->rpl_parmb;\r\nif (prepparm->lv3.keyblock.version != 0x01) {\r\nDEBUG_ERR(\r\n"pkey_sec2protkey reply param keyblock version mismatch 0x%02x != 0x01\n",\r\n(int) prepparm->lv3.keyblock.version);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nswitch (prepparm->lv3.keyblock.keylen) {\r\ncase 16+32:\r\nprotkey->type = PKEY_KEYTYPE_AES_128;\r\nbreak;\r\ncase 24+32:\r\nprotkey->type = PKEY_KEYTYPE_AES_192;\r\nbreak;\r\ncase 32+32:\r\nprotkey->type = PKEY_KEYTYPE_AES_256;\r\nbreak;\r\ndefault:\r\nDEBUG_ERR("pkey_sec2protkey unknown/unsupported keytype %d\n",\r\nprepparm->lv3.keyblock.keylen);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nprotkey->len = prepparm->lv3.keyblock.keylen;\r\nmemcpy(protkey->protkey, prepparm->lv3.keyblock.key, protkey->len);\r\nout:\r\nfree_cprbmem(mem, PARMBSIZE, 0);\r\nreturn rc;\r\n}\r\nint pkey_clr2protkey(u32 keytype,\r\nconst struct pkey_clrkey *clrkey,\r\nstruct pkey_protkey *protkey)\r\n{\r\nlong fc;\r\nint keysize;\r\nu8 paramblock[64];\r\nswitch (keytype) {\r\ncase PKEY_KEYTYPE_AES_128:\r\nkeysize = 16;\r\nfc = CPACF_PCKMO_ENC_AES_128_KEY;\r\nbreak;\r\ncase PKEY_KEYTYPE_AES_192:\r\nkeysize = 24;\r\nfc = CPACF_PCKMO_ENC_AES_192_KEY;\r\nbreak;\r\ncase PKEY_KEYTYPE_AES_256:\r\nkeysize = 32;\r\nfc = CPACF_PCKMO_ENC_AES_256_KEY;\r\nbreak;\r\ndefault:\r\nDEBUG_ERR("pkey_clr2protkey unknown/unsupported keytype %d\n",\r\nkeytype);\r\nreturn -EINVAL;\r\n}\r\nmemset(paramblock, 0, sizeof(paramblock));\r\nmemcpy(paramblock, clrkey->clrkey, keysize);\r\ncpacf_pckmo(fc, paramblock);\r\nprotkey->type = keytype;\r\nprotkey->len = keysize + 32;\r\nmemcpy(protkey->protkey, paramblock, keysize + 32);\r\nreturn 0;\r\n}\r\nstatic int query_crypto_facility(u16 cardnr, u16 domain,\r\nconst char *keyword,\r\nu8 *rarray, size_t *rarraylen,\r\nu8 *varray, size_t *varraylen)\r\n{\r\nint rc;\r\nu16 len;\r\nu8 *mem, *ptr;\r\nstruct CPRBX *preqcblk, *prepcblk;\r\nstruct ica_xcRB xcrb;\r\nstruct fqreqparm {\r\nu8 subfunc_code[2];\r\nu16 rule_array_len;\r\nchar rule_array[8];\r\nstruct lv1 {\r\nu16 len;\r\nu8 data[VARDATASIZE];\r\n} lv1;\r\nu16 dummylen;\r\n} *preqparm;\r\nsize_t parmbsize = sizeof(struct fqreqparm);\r\nstruct fqrepparm {\r\nu8 subfunc_code[2];\r\nu8 lvdata[0];\r\n} *prepparm;\r\nrc = alloc_and_prep_cprbmem(parmbsize, &mem, &preqcblk, &prepcblk);\r\nif (rc)\r\nreturn rc;\r\npreqcblk->domain = domain;\r\npreqparm = (struct fqreqparm *) preqcblk->req_parmb;\r\nmemcpy(preqparm->subfunc_code, "FQ", 2);\r\nstrncpy(preqparm->rule_array, keyword, sizeof(preqparm->rule_array));\r\npreqparm->rule_array_len =\r\nsizeof(preqparm->rule_array_len) + sizeof(preqparm->rule_array);\r\npreqparm->lv1.len = sizeof(preqparm->lv1);\r\npreqparm->dummylen = sizeof(preqparm->dummylen);\r\npreqcblk->req_parml = parmbsize;\r\nprep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);\r\nrc = _zcrypt_send_cprb(&xcrb);\r\nif (rc) {\r\nDEBUG_ERR(\r\n"query_crypto_facility zcrypt_send_cprb (cardnr=%d domain=%d) failed with errno %d\n",\r\n(int) cardnr, (int) domain, rc);\r\ngoto out;\r\n}\r\nif (prepcblk->ccp_rtcode != 0) {\r\nDEBUG_ERR(\r\n"query_crypto_facility unwrap secure key failure, card response %d/%d\n",\r\n(int) prepcblk->ccp_rtcode,\r\n(int) prepcblk->ccp_rscode);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nprepcblk->rpl_parmb = ((u8 *) prepcblk) + sizeof(struct CPRBX);\r\nprepparm = (struct fqrepparm *) prepcblk->rpl_parmb;\r\nptr = prepparm->lvdata;\r\nlen = *((u16 *) ptr);\r\nif (len > sizeof(u16)) {\r\nptr += sizeof(u16);\r\nlen -= sizeof(u16);\r\nif (rarray && rarraylen && *rarraylen > 0) {\r\n*rarraylen = (len > *rarraylen ? *rarraylen : len);\r\nmemcpy(rarray, ptr, *rarraylen);\r\n}\r\nptr += len;\r\n}\r\nlen = *((u16 *) ptr);\r\nif (len > sizeof(u16)) {\r\nptr += sizeof(u16);\r\nlen -= sizeof(u16);\r\nif (varray && varraylen && *varraylen > 0) {\r\n*varraylen = (len > *varraylen ? *varraylen : len);\r\nmemcpy(varray, ptr, *varraylen);\r\n}\r\nptr += len;\r\n}\r\nout:\r\nfree_cprbmem(mem, parmbsize, 0);\r\nreturn rc;\r\n}\r\nstatic int fetch_mkvp(u16 cardnr, u16 domain, u64 mkvp[2])\r\n{\r\nint rc, found = 0;\r\nsize_t rlen, vlen;\r\nu8 *rarray, *varray, *pg;\r\npg = (u8 *) __get_free_page(GFP_KERNEL);\r\nif (!pg)\r\nreturn -ENOMEM;\r\nrarray = pg;\r\nvarray = pg + PAGE_SIZE/2;\r\nrlen = vlen = PAGE_SIZE/2;\r\nrc = query_crypto_facility(cardnr, domain, "STATICSA",\r\nrarray, &rlen, varray, &vlen);\r\nif (rc == 0 && rlen > 8*8 && vlen > 184+8) {\r\nif (rarray[8*8] == '2') {\r\nmkvp[0] = *((u64 *)(varray + 184));\r\nmkvp[1] = *((u64 *)(varray + 172));\r\nfound = 1;\r\n}\r\n}\r\nfree_page((unsigned long) pg);\r\nreturn found ? 0 : -ENOENT;\r\n}\r\nstatic int mkvp_cache_fetch(u16 cardnr, u16 domain, u64 mkvp[2])\r\n{\r\nint rc = -ENOENT;\r\nstruct mkvp_info *ptr;\r\nspin_lock_bh(&mkvp_list_lock);\r\nlist_for_each_entry(ptr, &mkvp_list, list) {\r\nif (ptr->cardnr == cardnr &&\r\nptr->domain == domain) {\r\nmemcpy(mkvp, ptr->mkvp, 2 * sizeof(u64));\r\nrc = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&mkvp_list_lock);\r\nreturn rc;\r\n}\r\nstatic void mkvp_cache_update(u16 cardnr, u16 domain, u64 mkvp[2])\r\n{\r\nint found = 0;\r\nstruct mkvp_info *ptr;\r\nspin_lock_bh(&mkvp_list_lock);\r\nlist_for_each_entry(ptr, &mkvp_list, list) {\r\nif (ptr->cardnr == cardnr &&\r\nptr->domain == domain) {\r\nmemcpy(ptr->mkvp, mkvp, 2 * sizeof(u64));\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nptr = kmalloc(sizeof(*ptr), GFP_ATOMIC);\r\nif (!ptr) {\r\nspin_unlock_bh(&mkvp_list_lock);\r\nreturn;\r\n}\r\nptr->cardnr = cardnr;\r\nptr->domain = domain;\r\nmemcpy(ptr->mkvp, mkvp, 2 * sizeof(u64));\r\nlist_add(&ptr->list, &mkvp_list);\r\n}\r\nspin_unlock_bh(&mkvp_list_lock);\r\n}\r\nstatic void mkvp_cache_scrub(u16 cardnr, u16 domain)\r\n{\r\nstruct mkvp_info *ptr;\r\nspin_lock_bh(&mkvp_list_lock);\r\nlist_for_each_entry(ptr, &mkvp_list, list) {\r\nif (ptr->cardnr == cardnr &&\r\nptr->domain == domain) {\r\nlist_del(&ptr->list);\r\nkfree(ptr);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&mkvp_list_lock);\r\n}\r\nstatic void __exit mkvp_cache_free(void)\r\n{\r\nstruct mkvp_info *ptr, *pnext;\r\nspin_lock_bh(&mkvp_list_lock);\r\nlist_for_each_entry_safe(ptr, pnext, &mkvp_list, list) {\r\nlist_del(&ptr->list);\r\nkfree(ptr);\r\n}\r\nspin_unlock_bh(&mkvp_list_lock);\r\n}\r\nint pkey_findcard(const struct pkey_seckey *seckey,\r\nu16 *pcardnr, u16 *pdomain, int verify)\r\n{\r\nstruct secaeskeytoken *t = (struct secaeskeytoken *) seckey;\r\nstruct zcrypt_device_matrix *device_matrix;\r\nu16 card, dom;\r\nu64 mkvp[2];\r\nint i, rc, oi = -1;\r\nif (t->mkvp == 0)\r\nreturn -EINVAL;\r\ndevice_matrix = kmalloc(sizeof(struct zcrypt_device_matrix),\r\nGFP_KERNEL);\r\nif (!device_matrix)\r\nreturn -ENOMEM;\r\nzcrypt_device_status_mask(device_matrix);\r\nfor (i = 0; i < MAX_ZDEV_ENTRIES; i++) {\r\ncard = AP_QID_CARD(device_matrix->device[i].qid);\r\ndom = AP_QID_QUEUE(device_matrix->device[i].qid);\r\nif (device_matrix->device[i].online &&\r\ndevice_matrix->device[i].functions & 0x04) {\r\nif (mkvp_cache_fetch(card, dom, mkvp) == 0 &&\r\nt->mkvp == mkvp[0]) {\r\nif (!verify)\r\nbreak;\r\nif (fetch_mkvp(card, dom, mkvp) == 0) {\r\nmkvp_cache_update(card, dom, mkvp);\r\nif (t->mkvp == mkvp[0])\r\nbreak;\r\n}\r\n}\r\n} else {\r\nmkvp_cache_scrub(card, dom);\r\n}\r\n}\r\nif (i >= MAX_ZDEV_ENTRIES) {\r\nfor (i = 0; i < MAX_ZDEV_ENTRIES; i++) {\r\nif (!(device_matrix->device[i].online &&\r\ndevice_matrix->device[i].functions & 0x04))\r\ncontinue;\r\ncard = AP_QID_CARD(device_matrix->device[i].qid);\r\ndom = AP_QID_QUEUE(device_matrix->device[i].qid);\r\nif (fetch_mkvp(card, dom, mkvp) == 0) {\r\nmkvp_cache_update(card, dom, mkvp);\r\nif (t->mkvp == mkvp[0])\r\nbreak;\r\nif (t->mkvp == mkvp[1] && oi < 0)\r\noi = i;\r\n}\r\n}\r\nif (i >= MAX_ZDEV_ENTRIES && oi >= 0) {\r\ncard = AP_QID_CARD(device_matrix->device[oi].qid);\r\ndom = AP_QID_QUEUE(device_matrix->device[oi].qid);\r\n}\r\n}\r\nif (i < MAX_ZDEV_ENTRIES || oi >= 0) {\r\nif (pcardnr)\r\n*pcardnr = card;\r\nif (pdomain)\r\n*pdomain = dom;\r\nrc = 0;\r\n} else\r\nrc = -ENODEV;\r\nkfree(device_matrix);\r\nreturn rc;\r\n}\r\nint pkey_skey2pkey(const struct pkey_seckey *seckey,\r\nstruct pkey_protkey *protkey)\r\n{\r\nu16 cardnr, domain;\r\nint rc, verify;\r\nfor (verify = 0; verify < 2; verify++) {\r\nrc = pkey_findcard(seckey, &cardnr, &domain, verify);\r\nif (rc)\r\ncontinue;\r\nrc = pkey_sec2protkey(cardnr, domain, seckey, protkey);\r\nif (rc == 0)\r\nbreak;\r\n}\r\nif (rc)\r\nDEBUG_DBG("pkey_skey2pkey failed rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nint pkey_verifykey(const struct pkey_seckey *seckey,\r\nu16 *pcardnr, u16 *pdomain,\r\nu16 *pkeysize, u32 *pattributes)\r\n{\r\nstruct secaeskeytoken *t = (struct secaeskeytoken *) seckey;\r\nu16 cardnr, domain;\r\nu64 mkvp[2];\r\nint rc;\r\nrc = check_secaeskeytoken((u8 *) seckey, 0);\r\nif (rc)\r\ngoto out;\r\nif (pattributes)\r\n*pattributes = PKEY_VERIFY_ATTR_AES;\r\nif (pkeysize)\r\n*pkeysize = t->bitsize;\r\nrc = pkey_findcard(seckey, &cardnr, &domain, 1);\r\nif (rc)\r\ngoto out;\r\nrc = mkvp_cache_fetch(cardnr, domain, mkvp);\r\nif (rc)\r\ngoto out;\r\nif (t->mkvp == mkvp[1]) {\r\nDEBUG_DBG("pkey_verifykey secure key has old mkvp\n");\r\nif (pattributes)\r\n*pattributes |= PKEY_VERIFY_ATTR_OLD_MKVP;\r\n}\r\nif (pcardnr)\r\n*pcardnr = cardnr;\r\nif (pdomain)\r\n*pdomain = domain;\r\nout:\r\nDEBUG_DBG("pkey_verifykey rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic long pkey_unlocked_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint rc;\r\nswitch (cmd) {\r\ncase PKEY_GENSECK: {\r\nstruct pkey_genseck __user *ugs = (void __user *) arg;\r\nstruct pkey_genseck kgs;\r\nif (copy_from_user(&kgs, ugs, sizeof(kgs)))\r\nreturn -EFAULT;\r\nrc = pkey_genseckey(kgs.cardnr, kgs.domain,\r\nkgs.keytype, &kgs.seckey);\r\nDEBUG_DBG("pkey_ioctl pkey_genseckey()=%d\n", rc);\r\nif (rc)\r\nbreak;\r\nif (copy_to_user(ugs, &kgs, sizeof(kgs)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase PKEY_CLR2SECK: {\r\nstruct pkey_clr2seck __user *ucs = (void __user *) arg;\r\nstruct pkey_clr2seck kcs;\r\nif (copy_from_user(&kcs, ucs, sizeof(kcs)))\r\nreturn -EFAULT;\r\nrc = pkey_clr2seckey(kcs.cardnr, kcs.domain, kcs.keytype,\r\n&kcs.clrkey, &kcs.seckey);\r\nDEBUG_DBG("pkey_ioctl pkey_clr2seckey()=%d\n", rc);\r\nif (rc)\r\nbreak;\r\nif (copy_to_user(ucs, &kcs, sizeof(kcs)))\r\nreturn -EFAULT;\r\nmemzero_explicit(&kcs, sizeof(kcs));\r\nbreak;\r\n}\r\ncase PKEY_SEC2PROTK: {\r\nstruct pkey_sec2protk __user *usp = (void __user *) arg;\r\nstruct pkey_sec2protk ksp;\r\nif (copy_from_user(&ksp, usp, sizeof(ksp)))\r\nreturn -EFAULT;\r\nrc = pkey_sec2protkey(ksp.cardnr, ksp.domain,\r\n&ksp.seckey, &ksp.protkey);\r\nDEBUG_DBG("pkey_ioctl pkey_sec2protkey()=%d\n", rc);\r\nif (rc)\r\nbreak;\r\nif (copy_to_user(usp, &ksp, sizeof(ksp)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase PKEY_CLR2PROTK: {\r\nstruct pkey_clr2protk __user *ucp = (void __user *) arg;\r\nstruct pkey_clr2protk kcp;\r\nif (copy_from_user(&kcp, ucp, sizeof(kcp)))\r\nreturn -EFAULT;\r\nrc = pkey_clr2protkey(kcp.keytype,\r\n&kcp.clrkey, &kcp.protkey);\r\nDEBUG_DBG("pkey_ioctl pkey_clr2protkey()=%d\n", rc);\r\nif (rc)\r\nbreak;\r\nif (copy_to_user(ucp, &kcp, sizeof(kcp)))\r\nreturn -EFAULT;\r\nmemzero_explicit(&kcp, sizeof(kcp));\r\nbreak;\r\n}\r\ncase PKEY_FINDCARD: {\r\nstruct pkey_findcard __user *ufc = (void __user *) arg;\r\nstruct pkey_findcard kfc;\r\nif (copy_from_user(&kfc, ufc, sizeof(kfc)))\r\nreturn -EFAULT;\r\nrc = pkey_findcard(&kfc.seckey,\r\n&kfc.cardnr, &kfc.domain, 1);\r\nDEBUG_DBG("pkey_ioctl pkey_findcard()=%d\n", rc);\r\nif (rc)\r\nbreak;\r\nif (copy_to_user(ufc, &kfc, sizeof(kfc)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase PKEY_SKEY2PKEY: {\r\nstruct pkey_skey2pkey __user *usp = (void __user *) arg;\r\nstruct pkey_skey2pkey ksp;\r\nif (copy_from_user(&ksp, usp, sizeof(ksp)))\r\nreturn -EFAULT;\r\nrc = pkey_skey2pkey(&ksp.seckey, &ksp.protkey);\r\nDEBUG_DBG("pkey_ioctl pkey_skey2pkey()=%d\n", rc);\r\nif (rc)\r\nbreak;\r\nif (copy_to_user(usp, &ksp, sizeof(ksp)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase PKEY_VERIFYKEY: {\r\nstruct pkey_verifykey __user *uvk = (void __user *) arg;\r\nstruct pkey_verifykey kvk;\r\nif (copy_from_user(&kvk, uvk, sizeof(kvk)))\r\nreturn -EFAULT;\r\nrc = pkey_verifykey(&kvk.seckey, &kvk.cardnr, &kvk.domain,\r\n&kvk.keysize, &kvk.attributes);\r\nDEBUG_DBG("pkey_ioctl pkey_verifykey()=%d\n", rc);\r\nif (rc)\r\nbreak;\r\nif (copy_to_user(uvk, &kvk, sizeof(kvk)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn rc;\r\n}\r\nstatic int __init pkey_init(void)\r\n{\r\ncpacf_mask_t pckmo_functions;\r\nif (!cpacf_query(CPACF_PCKMO, &pckmo_functions))\r\nreturn -EOPNOTSUPP;\r\nif (!cpacf_test_func(&pckmo_functions, CPACF_PCKMO_ENC_AES_128_KEY) ||\r\n!cpacf_test_func(&pckmo_functions, CPACF_PCKMO_ENC_AES_192_KEY) ||\r\n!cpacf_test_func(&pckmo_functions, CPACF_PCKMO_ENC_AES_256_KEY))\r\nreturn -EOPNOTSUPP;\r\npkey_debug_init();\r\nreturn misc_register(&pkey_dev);\r\n}\r\nstatic void __exit pkey_exit(void)\r\n{\r\nmisc_deregister(&pkey_dev);\r\nmkvp_cache_free();\r\npkey_debug_exit();\r\n}
