static void mdio_write_reg(void *base, u32 reg, u32 value)\r\n{\r\nu8 __iomem *reg_addr = (u8 __iomem *)base;\r\nwritel_relaxed(value, reg_addr + reg);\r\n}\r\nstatic u32 mdio_read_reg(void *base, u32 reg)\r\n{\r\nu8 __iomem *reg_addr = (u8 __iomem *)base;\r\nreturn readl_relaxed(reg_addr + reg);\r\n}\r\nstatic void mdio_set_reg_field(void *base, u32 reg, u32 mask, u32 shift,\r\nu32 val)\r\n{\r\nu32 origin = mdio_read_reg(base, reg);\r\nmdio_set_field(origin, mask, shift, val);\r\nmdio_write_reg(base, reg, origin);\r\n}\r\nstatic u32 mdio_get_reg_field(void *base, u32 reg, u32 mask, u32 shift)\r\n{\r\nu32 origin;\r\norigin = mdio_read_reg(base, reg);\r\nreturn mdio_get_field(origin, mask, shift);\r\n}\r\nstatic int mdio_sc_cfg_reg_write(struct hns_mdio_device *mdio_dev,\r\nu32 cfg_reg, u32 set_val,\r\nu32 st_reg, u32 st_msk, u8 check_st)\r\n{\r\nu32 time_cnt;\r\nu32 reg_value;\r\nregmap_write(mdio_dev->subctrl_vbase, cfg_reg, set_val);\r\nfor (time_cnt = MDIO_TIMEOUT; time_cnt; time_cnt--) {\r\nregmap_read(mdio_dev->subctrl_vbase, st_reg, &reg_value);\r\nreg_value &= st_msk;\r\nif ((!!check_st) == (!!reg_value))\r\nbreak;\r\n}\r\nif ((!!check_st) != (!!reg_value))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int hns_mdio_wait_ready(struct mii_bus *bus)\r\n{\r\nstruct hns_mdio_device *mdio_dev = bus->priv;\r\nu32 cmd_reg_value;\r\nint i;\r\nfor (i = 0; i < MDIO_TIMEOUT; i++) {\r\ncmd_reg_value = MDIO_GET_REG_BIT(mdio_dev,\r\nMDIO_COMMAND_REG,\r\nMDIO_CMD_START_B);\r\nif (!cmd_reg_value)\r\nbreak;\r\n}\r\nif ((i == MDIO_TIMEOUT) && cmd_reg_value)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic void hns_mdio_cmd_write(struct hns_mdio_device *mdio_dev,\r\nu8 is_c45, u8 op, u8 phy_id, u16 cmd)\r\n{\r\nu32 cmd_reg_value;\r\nu8 st = is_c45 ? MDIO_ST_CLAUSE_45 : MDIO_ST_CLAUSE_22;\r\ncmd_reg_value = st << MDIO_CMD_ST_S;\r\ncmd_reg_value |= op << MDIO_CMD_OP_S;\r\ncmd_reg_value |=\r\n(phy_id & MDIO_CMD_PRTAD_M) << MDIO_CMD_PRTAD_S;\r\ncmd_reg_value |= (cmd & MDIO_CMD_DEVAD_M) << MDIO_CMD_DEVAD_S;\r\ncmd_reg_value |= 1 << MDIO_CMD_START_B;\r\nMDIO_WRITE_REG(mdio_dev, MDIO_COMMAND_REG, cmd_reg_value);\r\n}\r\nstatic int hns_mdio_write(struct mii_bus *bus,\r\nint phy_id, int regnum, u16 data)\r\n{\r\nint ret;\r\nstruct hns_mdio_device *mdio_dev = (struct hns_mdio_device *)bus->priv;\r\nu8 devad = ((regnum >> 16) & 0x1f);\r\nu8 is_c45 = !!(regnum & MII_ADDR_C45);\r\nu16 reg = (u16)(regnum & 0xffff);\r\nu8 op;\r\nu16 cmd_reg_cfg;\r\ndev_dbg(&bus->dev, "mdio write %s,base is %p\n",\r\nbus->id, mdio_dev->vbase);\r\ndev_dbg(&bus->dev, "phy id=%d, is_c45=%d, devad=%d, reg=%#x, write data=%d\n",\r\nphy_id, is_c45, devad, reg, data);\r\nret = hns_mdio_wait_ready(bus);\r\nif (ret) {\r\ndev_err(&bus->dev, "MDIO bus is busy\n");\r\nreturn ret;\r\n}\r\nif (!is_c45) {\r\ncmd_reg_cfg = reg;\r\nop = MDIO_C22_WRITE;\r\n} else {\r\nMDIO_SET_REG_FIELD(mdio_dev, MDIO_ADDR_REG, MDIO_ADDR_DATA_M,\r\nMDIO_ADDR_DATA_S, reg);\r\nhns_mdio_cmd_write(mdio_dev, is_c45,\r\nMDIO_C45_WRITE_ADDR, phy_id, devad);\r\nret = hns_mdio_wait_ready(bus);\r\nif (ret) {\r\ndev_err(&bus->dev, "MDIO bus is busy\n");\r\nreturn ret;\r\n}\r\ncmd_reg_cfg = devad;\r\nop = MDIO_C45_WRITE_DATA;\r\n}\r\nMDIO_SET_REG_FIELD(mdio_dev, MDIO_WDATA_REG, MDIO_WDATA_DATA_M,\r\nMDIO_WDATA_DATA_S, data);\r\nhns_mdio_cmd_write(mdio_dev, is_c45, op, phy_id, cmd_reg_cfg);\r\nreturn 0;\r\n}\r\nstatic int hns_mdio_read(struct mii_bus *bus, int phy_id, int regnum)\r\n{\r\nint ret;\r\nu16 reg_val = 0;\r\nu8 devad = ((regnum >> 16) & 0x1f);\r\nu8 is_c45 = !!(regnum & MII_ADDR_C45);\r\nu16 reg = (u16)(regnum & 0xffff);\r\nstruct hns_mdio_device *mdio_dev = (struct hns_mdio_device *)bus->priv;\r\ndev_dbg(&bus->dev, "mdio read %s,base is %p\n",\r\nbus->id, mdio_dev->vbase);\r\ndev_dbg(&bus->dev, "phy id=%d, is_c45=%d, devad=%d, reg=%#x!\n",\r\nphy_id, is_c45, devad, reg);\r\nret = hns_mdio_wait_ready(bus);\r\nif (ret) {\r\ndev_err(&bus->dev, "MDIO bus is busy\n");\r\nreturn ret;\r\n}\r\nif (!is_c45) {\r\nhns_mdio_cmd_write(mdio_dev, is_c45,\r\nMDIO_C22_READ, phy_id, reg);\r\n} else {\r\nMDIO_SET_REG_FIELD(mdio_dev, MDIO_ADDR_REG, MDIO_ADDR_DATA_M,\r\nMDIO_ADDR_DATA_S, reg);\r\nhns_mdio_cmd_write(mdio_dev, is_c45,\r\nMDIO_C45_WRITE_ADDR, phy_id, devad);\r\nret = hns_mdio_wait_ready(bus);\r\nif (ret) {\r\ndev_err(&bus->dev, "MDIO bus is busy\n");\r\nreturn ret;\r\n}\r\nhns_mdio_cmd_write(mdio_dev, is_c45,\r\nMDIO_C45_WRITE_ADDR, phy_id, devad);\r\n}\r\nret = hns_mdio_wait_ready(bus);\r\nif (ret) {\r\ndev_err(&bus->dev, "MDIO bus is busy\n");\r\nreturn ret;\r\n}\r\nreg_val = MDIO_GET_REG_BIT(mdio_dev, MDIO_STA_REG, MDIO_STATE_STA_B);\r\nif (reg_val) {\r\ndev_err(&bus->dev, " ERROR! MDIO Read failed!\n");\r\nreturn -EBUSY;\r\n}\r\nreg_val = (u16)MDIO_GET_REG_FIELD(mdio_dev, MDIO_RDATA_REG,\r\nMDIO_RDATA_DATA_M, MDIO_RDATA_DATA_S);\r\nreturn reg_val;\r\n}\r\nstatic int hns_mdio_reset(struct mii_bus *bus)\r\n{\r\nstruct hns_mdio_device *mdio_dev = (struct hns_mdio_device *)bus->priv;\r\nconst struct hns_mdio_sc_reg *sc_reg;\r\nint ret;\r\nif (dev_of_node(bus->parent)) {\r\nif (!mdio_dev->subctrl_vbase) {\r\ndev_err(&bus->dev, "mdio sys ctl reg has not maped\n");\r\nreturn -ENODEV;\r\n}\r\nsc_reg = &mdio_dev->sc_reg;\r\nret = mdio_sc_cfg_reg_write(mdio_dev, sc_reg->mdio_reset_req,\r\n0x1, sc_reg->mdio_reset_st, 0x1,\r\nMDIO_CHECK_SET_ST);\r\nif (ret) {\r\ndev_err(&bus->dev, "MDIO reset fail\n");\r\nreturn ret;\r\n}\r\nret = mdio_sc_cfg_reg_write(mdio_dev, sc_reg->mdio_clk_dis,\r\n0x1, sc_reg->mdio_clk_st, 0x1,\r\nMDIO_CHECK_CLR_ST);\r\nif (ret) {\r\ndev_err(&bus->dev, "MDIO dis clk fail\n");\r\nreturn ret;\r\n}\r\nret = mdio_sc_cfg_reg_write(mdio_dev, sc_reg->mdio_reset_dreq,\r\n0x1, sc_reg->mdio_reset_st, 0x1,\r\nMDIO_CHECK_CLR_ST);\r\nif (ret) {\r\ndev_err(&bus->dev, "MDIO dis clk fail\n");\r\nreturn ret;\r\n}\r\nret = mdio_sc_cfg_reg_write(mdio_dev, sc_reg->mdio_clk_en,\r\n0x1, sc_reg->mdio_clk_st, 0x1,\r\nMDIO_CHECK_SET_ST);\r\nif (ret)\r\ndev_err(&bus->dev, "MDIO en clk fail\n");\r\n} else if (is_acpi_node(bus->parent->fwnode)) {\r\nacpi_status s;\r\ns = acpi_evaluate_object(ACPI_HANDLE(bus->parent),\r\n"_RST", NULL, NULL);\r\nif (ACPI_FAILURE(s)) {\r\ndev_err(&bus->dev, "Reset failed, return:%#x\n", s);\r\nret = -EBUSY;\r\n} else {\r\nret = 0;\r\n}\r\n} else {\r\ndev_err(&bus->dev, "Can not get cfg data from DT or ACPI\n");\r\nret = -ENXIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int hns_mdio_probe(struct platform_device *pdev)\r\n{\r\nstruct hns_mdio_device *mdio_dev;\r\nstruct mii_bus *new_bus;\r\nstruct resource *res;\r\nint ret = -ENODEV;\r\nif (!pdev) {\r\ndev_err(NULL, "pdev is NULL!\r\n");\r\nreturn -ENODEV;\r\n}\r\nmdio_dev = devm_kzalloc(&pdev->dev, sizeof(*mdio_dev), GFP_KERNEL);\r\nif (!mdio_dev)\r\nreturn -ENOMEM;\r\nnew_bus = devm_mdiobus_alloc(&pdev->dev);\r\nif (!new_bus) {\r\ndev_err(&pdev->dev, "mdiobus_alloc fail!\n");\r\nreturn -ENOMEM;\r\n}\r\nnew_bus->name = MDIO_BUS_NAME;\r\nnew_bus->read = hns_mdio_read;\r\nnew_bus->write = hns_mdio_write;\r\nnew_bus->reset = hns_mdio_reset;\r\nnew_bus->priv = mdio_dev;\r\nnew_bus->parent = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmdio_dev->vbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mdio_dev->vbase)) {\r\nret = PTR_ERR(mdio_dev->vbase);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, new_bus);\r\nsnprintf(new_bus->id, MII_BUS_ID_SIZE, "%s-%s", "Mii",\r\ndev_name(&pdev->dev));\r\nif (dev_of_node(&pdev->dev)) {\r\nstruct of_phandle_args reg_args;\r\nret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,\r\n"subctrl-vbase",\r\n4,\r\n0,\r\n&reg_args);\r\nif (!ret) {\r\nmdio_dev->subctrl_vbase =\r\nsyscon_node_to_regmap(reg_args.np);\r\nif (IS_ERR(mdio_dev->subctrl_vbase)) {\r\ndev_warn(&pdev->dev, "syscon_node_to_regmap error\n");\r\nmdio_dev->subctrl_vbase = NULL;\r\n} else {\r\nif (reg_args.args_count == 4) {\r\nmdio_dev->sc_reg.mdio_clk_en =\r\n(u16)reg_args.args[0];\r\nmdio_dev->sc_reg.mdio_clk_dis =\r\n(u16)reg_args.args[0] + 4;\r\nmdio_dev->sc_reg.mdio_reset_req =\r\n(u16)reg_args.args[1];\r\nmdio_dev->sc_reg.mdio_reset_dreq =\r\n(u16)reg_args.args[1] + 4;\r\nmdio_dev->sc_reg.mdio_clk_st =\r\n(u16)reg_args.args[2];\r\nmdio_dev->sc_reg.mdio_reset_st =\r\n(u16)reg_args.args[3];\r\n} else {\r\nmdio_dev->sc_reg.mdio_clk_en =\r\nMDIO_SC_CLK_EN;\r\nmdio_dev->sc_reg.mdio_clk_dis =\r\nMDIO_SC_CLK_DIS;\r\nmdio_dev->sc_reg.mdio_reset_req =\r\nMDIO_SC_RESET_REQ;\r\nmdio_dev->sc_reg.mdio_reset_dreq =\r\nMDIO_SC_RESET_DREQ;\r\nmdio_dev->sc_reg.mdio_clk_st =\r\nMDIO_SC_CLK_ST;\r\nmdio_dev->sc_reg.mdio_reset_st =\r\nMDIO_SC_RESET_ST;\r\n}\r\n}\r\n} else {\r\ndev_warn(&pdev->dev, "find syscon ret = %#x\n", ret);\r\nmdio_dev->subctrl_vbase = NULL;\r\n}\r\nret = of_mdiobus_register(new_bus, pdev->dev.of_node);\r\n} else if (is_acpi_node(pdev->dev.fwnode)) {\r\nmemset(new_bus->irq, PHY_POLL, 4 * PHY_MAX_ADDR);\r\nnew_bus->phy_mask = ~0;\r\nret = mdiobus_register(new_bus);\r\n} else {\r\ndev_err(&pdev->dev, "Can not get cfg data from DT or ACPI\n");\r\nret = -ENXIO;\r\n}\r\nif (ret) {\r\ndev_err(&pdev->dev, "Cannot register as MDIO bus!\n");\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hns_mdio_remove(struct platform_device *pdev)\r\n{\r\nstruct mii_bus *bus;\r\nbus = platform_get_drvdata(pdev);\r\nmdiobus_unregister(bus);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
