static void db2k_write_acq_scan_list_entry(struct comedi_device *dev, u16 entry)\r\n{\r\nwritew(entry & 0x00ff, dev->mmio + DB2K_REG_ACQ_SCAN_LIST_FIFO);\r\nwritew((entry >> 8) & 0x00ff,\r\ndev->mmio + DB2K_REG_ACQ_SCAN_LIST_FIFO);\r\n}\r\nstatic void db2k_setup_sampling(struct comedi_device *dev, int chan, int gain)\r\n{\r\nu16 word0, word1, word2, word3;\r\nword0 = 0;\r\nword1 = 0x0004;\r\nword2 = (chan << 6) & 0x00c0;\r\nswitch (chan / 4) {\r\ncase 0:\r\nword3 = 0x0001;\r\nbreak;\r\ncase 1:\r\nword3 = 0x0002;\r\nbreak;\r\ncase 2:\r\nword3 = 0x0005;\r\nbreak;\r\ncase 3:\r\nword3 = 0x0006;\r\nbreak;\r\ncase 4:\r\nword3 = 0x0041;\r\nbreak;\r\ncase 5:\r\nword3 = 0x0042;\r\nbreak;\r\ndefault:\r\nword3 = 0;\r\nbreak;\r\n}\r\nword2 |= 0x0800;\r\nword3 |= 0xc000;\r\ndb2k_write_acq_scan_list_entry(dev, word0);\r\ndb2k_write_acq_scan_list_entry(dev, word1);\r\ndb2k_write_acq_scan_list_entry(dev, word2);\r\ndb2k_write_acq_scan_list_entry(dev, word3);\r\n}\r\nstatic int db2k_ai_status(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = readw(dev->mmio + DB2K_REG_ACQ_STATUS);\r\nif (status & context)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int db2k_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint gain, chan;\r\nint ret;\r\nint i;\r\nwritew(DB2K_ACQ_CONTROL_RESET_SCAN_LIST_FIFO |\r\nDB2K_ACQ_CONTROL_RESET_RESULTS_FIFO |\r\nDB2K_ACQ_CONTROL_RESET_CONFIG_PIPE,\r\ndev->mmio + DB2K_REG_ACQ_CONTROL);\r\nwritel(1000000, dev->mmio + DB2K_REG_ACQ_PACER_CLOCK_DIV_LOW);\r\nwritew(0, dev->mmio + DB2K_REG_ACQ_PACER_CLOCK_DIV_HIGH);\r\ngain = CR_RANGE(insn->chanspec);\r\nchan = CR_CHAN(insn->chanspec);\r\nfor (i = 0; i < insn->n; i++) {\r\ndb2k_setup_sampling(dev, chan, gain);\r\nwritew(DB2K_ACQ_CONTROL_SEQ_START_SCAN_LIST,\r\ndev->mmio + DB2K_REG_ACQ_CONTROL);\r\nret = comedi_timeout(dev, s, insn, db2k_ai_status,\r\nDB2K_ACQ_STATUS_CONFIG_PIPE_FULL);\r\nif (ret)\r\nreturn ret;\r\nwritew(DB2K_ACQ_CONTROL_ADC_PACER_ENABLE,\r\ndev->mmio + DB2K_REG_ACQ_CONTROL);\r\nret = comedi_timeout(dev, s, insn, db2k_ai_status,\r\nDB2K_ACQ_STATUS_LOGIC_SCANNING);\r\nif (ret)\r\nreturn ret;\r\nret =\r\ncomedi_timeout(dev, s, insn, db2k_ai_status,\r\nDB2K_ACQ_STATUS_RESULTS_FIFO_HAS_DATA);\r\nif (ret)\r\nreturn ret;\r\ndata[i] = readw(dev->mmio + DB2K_REG_ACQ_RESULTS_FIFO);\r\nwritew(DB2K_ACQ_CONTROL_ADC_PACER_DISABLE,\r\ndev->mmio + DB2K_REG_ACQ_CONTROL);\r\nwritew(DB2K_ACQ_CONTROL_SEQ_STOP_SCAN_LIST,\r\ndev->mmio + DB2K_REG_ACQ_CONTROL);\r\n}\r\nreturn i;\r\n}\r\nstatic int db2k_ao_eoc(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned long context)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int status;\r\nstatus = readw(dev->mmio + DB2K_REG_DAC_STATUS);\r\nif ((status & DB2K_DAC_STATUS_DAC_BUSY(chan)) == 0)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int db2k_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nunsigned int val = data[i];\r\nint ret;\r\nwritew(val, dev->mmio + DB2K_REG_DAC_SETTING(chan));\r\nret = comedi_timeout(dev, s, insn, db2k_ao_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\ns->readback[chan] = val;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic void db2k_reset_local_bus(struct comedi_device *dev)\r\n{\r\nstruct db2k_private *devpriv = dev->private;\r\nu32 cntrl;\r\ncntrl = readl(devpriv->plx + PLX_REG_CNTRL);\r\ncntrl |= PLX_CNTRL_RESET;\r\nwritel(cntrl, devpriv->plx + PLX_REG_CNTRL);\r\nmdelay(10);\r\ncntrl &= ~PLX_CNTRL_RESET;\r\nwritel(cntrl, devpriv->plx + PLX_REG_CNTRL);\r\nmdelay(10);\r\n}\r\nstatic void db2k_reload_plx(struct comedi_device *dev)\r\n{\r\nstruct db2k_private *devpriv = dev->private;\r\nu32 cntrl;\r\ncntrl = readl(devpriv->plx + PLX_REG_CNTRL);\r\ncntrl &= ~PLX_CNTRL_EERELOAD;\r\nwritel(cntrl, devpriv->plx + PLX_REG_CNTRL);\r\nmdelay(10);\r\ncntrl |= PLX_CNTRL_EERELOAD;\r\nwritel(cntrl, devpriv->plx + PLX_REG_CNTRL);\r\nmdelay(10);\r\ncntrl &= ~PLX_CNTRL_EERELOAD;\r\nwritel(cntrl, devpriv->plx + PLX_REG_CNTRL);\r\nmdelay(10);\r\n}\r\nstatic void db2k_pulse_prog_pin(struct comedi_device *dev)\r\n{\r\nstruct db2k_private *devpriv = dev->private;\r\nu32 cntrl;\r\ncntrl = readl(devpriv->plx + PLX_REG_CNTRL);\r\ncntrl |= PLX_CNTRL_USERO;\r\nwritel(cntrl, devpriv->plx + PLX_REG_CNTRL);\r\nmdelay(10);\r\ncntrl &= ~PLX_CNTRL_USERO;\r\nwritel(cntrl, devpriv->plx + PLX_REG_CNTRL);\r\nmdelay(10);\r\n}\r\nstatic int db2k_wait_cpld_init(struct comedi_device *dev)\r\n{\r\nint result = -ETIMEDOUT;\r\nint i;\r\nu16 cpld;\r\nfor (i = 0; i < 50; i++) {\r\ncpld = readw(dev->mmio + DB2K_REG_CPLD_STATUS);\r\nif (cpld & DB2K_CPLD_STATUS_INIT) {\r\nresult = 0;\r\nbreak;\r\n}\r\nusleep_range(100, 1000);\r\n}\r\nudelay(5);\r\nreturn result;\r\n}\r\nstatic int db2k_wait_cpld_txready(struct comedi_device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < 100; i++) {\r\nif (readw(dev->mmio + DB2K_REG_CPLD_STATUS) &\r\nDB2K_CPLD_STATUS_TXREADY) {\r\nreturn 0;\r\n}\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int db2k_write_cpld(struct comedi_device *dev, u16 data, bool new_cpld)\r\n{\r\nint result = 0;\r\nif (new_cpld) {\r\nresult = db2k_wait_cpld_txready(dev);\r\nif (result)\r\nreturn result;\r\n} else {\r\nusleep_range(10, 20);\r\n}\r\nwritew(data, dev->mmio + DB2K_REG_CPLD_WDATA);\r\nif (!(readw(dev->mmio + DB2K_REG_CPLD_STATUS) & DB2K_CPLD_STATUS_INIT))\r\nresult = -EIO;\r\nreturn result;\r\n}\r\nstatic int db2k_wait_fpga_programmed(struct comedi_device *dev)\r\n{\r\nstruct db2k_private *devpriv = dev->private;\r\nint i;\r\nfor (i = 0; i < 200; i++) {\r\nu32 cntrl = readl(devpriv->plx + PLX_REG_CNTRL);\r\nif (cntrl & PLX_CNTRL_USERI)\r\nreturn 0;\r\nusleep_range(100, 1000);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int db2k_load_firmware(struct comedi_device *dev, const u8 *cpld_array,\r\nsize_t len, unsigned long context)\r\n{\r\nstruct db2k_private *devpriv = dev->private;\r\nint result = -EIO;\r\nu32 cntrl;\r\nint retry;\r\nsize_t i;\r\nbool new_cpld;\r\nfor (i = 0; i + 1 < len; i++) {\r\nif (cpld_array[i] == 0xff && cpld_array[i + 1] == 0x20)\r\nbreak;\r\n}\r\nif (i + 1 >= len) {\r\ndev_err(dev->class_dev, "bad firmware - no start sequence\n");\r\nreturn -EINVAL;\r\n}\r\nif ((len - i) & 1) {\r\ndev_err(dev->class_dev,\r\n"bad firmware - odd length (%zu = %zu - %zu)\n",\r\nlen - i, len, i);\r\nreturn -EINVAL;\r\n}\r\ncpld_array += i;\r\nlen -= i;\r\ncntrl = readl(devpriv->plx + PLX_REG_CNTRL);\r\nif (!(cntrl & PLX_CNTRL_EEPRESENT))\r\nreturn -EIO;\r\nfor (retry = 0; retry < 3; retry++) {\r\ndb2k_reset_local_bus(dev);\r\ndb2k_reload_plx(dev);\r\ndb2k_pulse_prog_pin(dev);\r\nresult = db2k_wait_cpld_init(dev);\r\nif (result)\r\ncontinue;\r\nnew_cpld = (readw(dev->mmio + DB2K_REG_CPLD_STATUS) &\r\nDB2K_CPLD_VERSION_MASK) == DB2K_CPLD_VERSION_NEW;\r\nfor (; i < len; i += 2) {\r\nu16 data = (cpld_array[i] << 8) + cpld_array[i + 1];\r\nresult = db2k_write_cpld(dev, data, new_cpld);\r\nif (result)\r\nbreak;\r\n}\r\nif (result == 0)\r\nresult = db2k_wait_fpga_programmed(dev);\r\nif (result == 0) {\r\ndb2k_reset_local_bus(dev);\r\ndb2k_reload_plx(dev);\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic void db2k_adc_stop_dma_transfer(struct comedi_device *dev)\r\n{\r\n}\r\nstatic void db2k_adc_disarm(struct comedi_device *dev)\r\n{\r\nudelay(2);\r\nwritew(DB2K_TRIG_CONTROL_TYPE_ANALOG | DB2K_TRIG_CONTROL_DISABLE,\r\ndev->mmio + DB2K_REG_TRIG_CONTROL);\r\nudelay(2);\r\nwritew(DB2K_TRIG_CONTROL_TYPE_TTL | DB2K_TRIG_CONTROL_DISABLE,\r\ndev->mmio + DB2K_REG_TRIG_CONTROL);\r\nudelay(2);\r\nwritew(DB2K_ACQ_CONTROL_SEQ_STOP_SCAN_LIST,\r\ndev->mmio + DB2K_REG_ACQ_CONTROL);\r\nudelay(2);\r\nwritew(DB2K_ACQ_CONTROL_ADC_PACER_DISABLE,\r\ndev->mmio + DB2K_REG_ACQ_CONTROL);\r\ndb2k_adc_stop_dma_transfer(dev);\r\n}\r\nstatic void db2k_activate_reference_dacs(struct comedi_device *dev)\r\n{\r\nunsigned int val;\r\nint timeout;\r\nwritew(DB2K_REF_DACS_SET | DB2K_REF_DACS_SELECT_POS_REF,\r\ndev->mmio + DB2K_REG_REF_DACS);\r\nfor (timeout = 0; timeout < 20; timeout++) {\r\nval = readw(dev->mmio + DB2K_REG_DAC_STATUS);\r\nif ((val & DB2K_DAC_STATUS_REF_BUSY) == 0)\r\nbreak;\r\nudelay(2);\r\n}\r\nwritew(DB2K_REF_DACS_SET | DB2K_REF_DACS_SELECT_NEG_REF,\r\ndev->mmio + DB2K_REG_REF_DACS);\r\nfor (timeout = 0; timeout < 20; timeout++) {\r\nval = readw(dev->mmio + DB2K_REG_DAC_STATUS);\r\nif ((val & DB2K_DAC_STATUS_REF_BUSY) == 0)\r\nbreak;\r\nudelay(2);\r\n}\r\n}\r\nstatic void db2k_initialize_ctrs(struct comedi_device *dev)\r\n{\r\n}\r\nstatic void db2k_initialize_tmrs(struct comedi_device *dev)\r\n{\r\n}\r\nstatic void db2k_dac_disarm(struct comedi_device *dev)\r\n{\r\n}\r\nstatic void db2k_initialize_adc(struct comedi_device *dev)\r\n{\r\ndb2k_adc_disarm(dev);\r\ndb2k_activate_reference_dacs(dev);\r\ndb2k_initialize_ctrs(dev);\r\ndb2k_initialize_tmrs(dev);\r\n}\r\nstatic void db2k_initialize_dac(struct comedi_device *dev)\r\n{\r\ndb2k_dac_disarm(dev);\r\n}\r\nstatic int db2k_8255_cb(struct comedi_device *dev, int dir, int port, int data,\r\nunsigned long iobase)\r\n{\r\nif (dir) {\r\nwritew(data, dev->mmio + iobase + port * 2);\r\nreturn 0;\r\n}\r\nreturn readw(dev->mmio + iobase + port * 2);\r\n}\r\nstatic int db2k_auto_attach(struct comedi_device *dev, unsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct db2k_boardtype *board;\r\nstruct db2k_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint result;\r\nif (context >= ARRAY_SIZE(db2k_boardtypes))\r\nreturn -ENODEV;\r\nboard = &db2k_boardtypes[context];\r\nif (!board->name)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nresult = comedi_pci_enable(dev);\r\nif (result)\r\nreturn result;\r\ndevpriv->plx = pci_ioremap_bar(pcidev, 0);\r\ndev->mmio = pci_ioremap_bar(pcidev, 2);\r\nif (!devpriv->plx || !dev->mmio)\r\nreturn -ENOMEM;\r\nresult = comedi_alloc_subdevices(dev, 3);\r\nif (result)\r\nreturn result;\r\nresult = comedi_load_firmware(dev, &comedi_to_pci_dev(dev)->dev,\r\nDB2K_FIRMWARE, db2k_load_firmware, 0);\r\nif (result < 0)\r\nreturn result;\r\ndb2k_initialize_adc(dev);\r\ndb2k_initialize_dac(dev);\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND;\r\ns->n_chan = 24;\r\ns->maxdata = 0xffff;\r\ns->insn_read = db2k_ai_insn_read;\r\ns->range_table = &db2k_ai_range;\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = board->has_2_ao ? 2 : 4;\r\ns->maxdata = 0xffff;\r\ns->insn_write = db2k_ao_insn_write;\r\ns->range_table = &range_bipolar10;\r\nresult = comedi_alloc_subdev_readback(s);\r\nif (result)\r\nreturn result;\r\ns = &dev->subdevices[2];\r\nreturn subdev_8255_init(dev, s, db2k_8255_cb,\r\nDB2K_REG_DIO_P2_EXP_IO_8_BIT);\r\n}\r\nstatic void db2k_detach(struct comedi_device *dev)\r\n{\r\nstruct db2k_private *devpriv = dev->private;\r\nif (devpriv && devpriv->plx)\r\niounmap(devpriv->plx);\r\ncomedi_pci_detach(dev);\r\n}\r\nstatic int db2k_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &db2k_driver, id->driver_data);\r\n}
