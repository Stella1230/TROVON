void xhci_dbg_regs(struct xhci_hcd *xhci)\r\n{\r\nu32 temp;\r\nxhci_dbg(xhci, "// xHCI capability registers at %p:\n",\r\nxhci->cap_regs);\r\ntemp = readl(&xhci->cap_regs->hc_capbase);\r\nxhci_dbg(xhci, "// @%p = 0x%x (CAPLENGTH AND HCIVERSION)\n",\r\n&xhci->cap_regs->hc_capbase, temp);\r\nxhci_dbg(xhci, "// CAPLENGTH: 0x%x\n",\r\n(unsigned int) HC_LENGTH(temp));\r\nxhci_dbg(xhci, "// HCIVERSION: 0x%x\n",\r\n(unsigned int) HC_VERSION(temp));\r\nxhci_dbg(xhci, "// xHCI operational registers at %p:\n", xhci->op_regs);\r\ntemp = readl(&xhci->cap_regs->run_regs_off);\r\nxhci_dbg(xhci, "// @%p = 0x%x RTSOFF\n",\r\n&xhci->cap_regs->run_regs_off,\r\n(unsigned int) temp & RTSOFF_MASK);\r\nxhci_dbg(xhci, "// xHCI runtime registers at %p:\n", xhci->run_regs);\r\ntemp = readl(&xhci->cap_regs->db_off);\r\nxhci_dbg(xhci, "// @%p = 0x%x DBOFF\n", &xhci->cap_regs->db_off, temp);\r\nxhci_dbg(xhci, "// Doorbell array at %p:\n", xhci->dba);\r\n}\r\nstatic void xhci_print_cap_regs(struct xhci_hcd *xhci)\r\n{\r\nu32 temp;\r\nu32 hci_version;\r\nxhci_dbg(xhci, "xHCI capability registers at %p:\n", xhci->cap_regs);\r\ntemp = readl(&xhci->cap_regs->hc_capbase);\r\nhci_version = HC_VERSION(temp);\r\nxhci_dbg(xhci, "CAPLENGTH AND HCIVERSION 0x%x:\n",\r\n(unsigned int) temp);\r\nxhci_dbg(xhci, "CAPLENGTH: 0x%x\n",\r\n(unsigned int) HC_LENGTH(temp));\r\nxhci_dbg(xhci, "HCIVERSION: 0x%x\n", hci_version);\r\ntemp = readl(&xhci->cap_regs->hcs_params1);\r\nxhci_dbg(xhci, "HCSPARAMS 1: 0x%x\n",\r\n(unsigned int) temp);\r\nxhci_dbg(xhci, " Max device slots: %u\n",\r\n(unsigned int) HCS_MAX_SLOTS(temp));\r\nxhci_dbg(xhci, " Max interrupters: %u\n",\r\n(unsigned int) HCS_MAX_INTRS(temp));\r\nxhci_dbg(xhci, " Max ports: %u\n",\r\n(unsigned int) HCS_MAX_PORTS(temp));\r\ntemp = readl(&xhci->cap_regs->hcs_params2);\r\nxhci_dbg(xhci, "HCSPARAMS 2: 0x%x\n",\r\n(unsigned int) temp);\r\nxhci_dbg(xhci, " Isoc scheduling threshold: %u\n",\r\n(unsigned int) HCS_IST(temp));\r\nxhci_dbg(xhci, " Maximum allowed segments in event ring: %u\n",\r\n(unsigned int) HCS_ERST_MAX(temp));\r\ntemp = readl(&xhci->cap_regs->hcs_params3);\r\nxhci_dbg(xhci, "HCSPARAMS 3 0x%x:\n",\r\n(unsigned int) temp);\r\nxhci_dbg(xhci, " Worst case U1 device exit latency: %u\n",\r\n(unsigned int) HCS_U1_LATENCY(temp));\r\nxhci_dbg(xhci, " Worst case U2 device exit latency: %u\n",\r\n(unsigned int) HCS_U2_LATENCY(temp));\r\ntemp = readl(&xhci->cap_regs->hcc_params);\r\nxhci_dbg(xhci, "HCC PARAMS 0x%x:\n", (unsigned int) temp);\r\nxhci_dbg(xhci, " HC generates %s bit addresses\n",\r\nHCC_64BIT_ADDR(temp) ? "64" : "32");\r\nxhci_dbg(xhci, " HC %s Contiguous Frame ID Capability\n",\r\nHCC_CFC(temp) ? "has" : "hasn't");\r\nxhci_dbg(xhci, " HC %s generate Stopped - Short Package event\n",\r\nHCC_SPC(temp) ? "can" : "can't");\r\nxhci_dbg(xhci, " FIXME: more HCCPARAMS debugging\n");\r\ntemp = readl(&xhci->cap_regs->run_regs_off);\r\nxhci_dbg(xhci, "RTSOFF 0x%x:\n", temp & RTSOFF_MASK);\r\nif (hci_version > 0x100) {\r\ntemp = readl(&xhci->cap_regs->hcc_params2);\r\nxhci_dbg(xhci, "HCC PARAMS2 0x%x:\n", (unsigned int) temp);\r\nxhci_dbg(xhci, " HC %s Force save context capability",\r\nHCC2_FSC(temp) ? "supports" : "doesn't support");\r\nxhci_dbg(xhci, " HC %s Large ESIT Payload Capability",\r\nHCC2_LEC(temp) ? "supports" : "doesn't support");\r\nxhci_dbg(xhci, " HC %s Extended TBC capability",\r\nHCC2_ETC(temp) ? "supports" : "doesn't support");\r\n}\r\n}\r\nstatic void xhci_print_command_reg(struct xhci_hcd *xhci)\r\n{\r\nu32 temp;\r\ntemp = readl(&xhci->op_regs->command);\r\nxhci_dbg(xhci, "USBCMD 0x%x:\n", temp);\r\nxhci_dbg(xhci, " HC is %s\n",\r\n(temp & CMD_RUN) ? "running" : "being stopped");\r\nxhci_dbg(xhci, " HC has %sfinished hard reset\n",\r\n(temp & CMD_RESET) ? "not " : "");\r\nxhci_dbg(xhci, " Event Interrupts %s\n",\r\n(temp & CMD_EIE) ? "enabled " : "disabled");\r\nxhci_dbg(xhci, " Host System Error Interrupts %s\n",\r\n(temp & CMD_HSEIE) ? "enabled " : "disabled");\r\nxhci_dbg(xhci, " HC has %sfinished light reset\n",\r\n(temp & CMD_LRESET) ? "not " : "");\r\n}\r\nstatic void xhci_print_status(struct xhci_hcd *xhci)\r\n{\r\nu32 temp;\r\ntemp = readl(&xhci->op_regs->status);\r\nxhci_dbg(xhci, "USBSTS 0x%x:\n", temp);\r\nxhci_dbg(xhci, " Event ring is %sempty\n",\r\n(temp & STS_EINT) ? "not " : "");\r\nxhci_dbg(xhci, " %sHost System Error\n",\r\n(temp & STS_FATAL) ? "WARNING: " : "No ");\r\nxhci_dbg(xhci, " HC is %s\n",\r\n(temp & STS_HALT) ? "halted" : "running");\r\n}\r\nstatic void xhci_print_op_regs(struct xhci_hcd *xhci)\r\n{\r\nxhci_dbg(xhci, "xHCI operational registers at %p:\n", xhci->op_regs);\r\nxhci_print_command_reg(xhci);\r\nxhci_print_status(xhci);\r\n}\r\nstatic void xhci_print_ports(struct xhci_hcd *xhci)\r\n{\r\n__le32 __iomem *addr;\r\nint i, j;\r\nint ports;\r\nchar *names[NUM_PORT_REGS] = {\r\n"status",\r\n"power",\r\n"link",\r\n"reserved",\r\n};\r\nports = HCS_MAX_PORTS(xhci->hcs_params1);\r\naddr = &xhci->op_regs->port_status_base;\r\nfor (i = 0; i < ports; i++) {\r\nfor (j = 0; j < NUM_PORT_REGS; j++) {\r\nxhci_dbg(xhci, "%p port %s reg = 0x%x\n",\r\naddr, names[j],\r\n(unsigned int) readl(addr));\r\naddr++;\r\n}\r\n}\r\n}\r\nvoid xhci_print_ir_set(struct xhci_hcd *xhci, int set_num)\r\n{\r\nstruct xhci_intr_reg __iomem *ir_set = &xhci->run_regs->ir_set[set_num];\r\nvoid __iomem *addr;\r\nu32 temp;\r\nu64 temp_64;\r\naddr = &ir_set->irq_pending;\r\ntemp = readl(addr);\r\nif (temp == XHCI_INIT_VALUE)\r\nreturn;\r\nxhci_dbg(xhci, " %p: ir_set[%i]\n", ir_set, set_num);\r\nxhci_dbg(xhci, " %p: ir_set.pending = 0x%x\n", addr,\r\n(unsigned int)temp);\r\naddr = &ir_set->irq_control;\r\ntemp = readl(addr);\r\nxhci_dbg(xhci, " %p: ir_set.control = 0x%x\n", addr,\r\n(unsigned int)temp);\r\naddr = &ir_set->erst_size;\r\ntemp = readl(addr);\r\nxhci_dbg(xhci, " %p: ir_set.erst_size = 0x%x\n", addr,\r\n(unsigned int)temp);\r\naddr = &ir_set->rsvd;\r\ntemp = readl(addr);\r\nif (temp != XHCI_INIT_VALUE)\r\nxhci_dbg(xhci, " WARN: %p: ir_set.rsvd = 0x%x\n",\r\naddr, (unsigned int)temp);\r\naddr = &ir_set->erst_base;\r\ntemp_64 = xhci_read_64(xhci, addr);\r\nxhci_dbg(xhci, " %p: ir_set.erst_base = @%08llx\n",\r\naddr, temp_64);\r\naddr = &ir_set->erst_dequeue;\r\ntemp_64 = xhci_read_64(xhci, addr);\r\nxhci_dbg(xhci, " %p: ir_set.erst_dequeue = @%08llx\n",\r\naddr, temp_64);\r\n}\r\nvoid xhci_print_run_regs(struct xhci_hcd *xhci)\r\n{\r\nu32 temp;\r\nint i;\r\nxhci_dbg(xhci, "xHCI runtime registers at %p:\n", xhci->run_regs);\r\ntemp = readl(&xhci->run_regs->microframe_index);\r\nxhci_dbg(xhci, " %p: Microframe index = 0x%x\n",\r\n&xhci->run_regs->microframe_index,\r\n(unsigned int) temp);\r\nfor (i = 0; i < 7; i++) {\r\ntemp = readl(&xhci->run_regs->rsvd[i]);\r\nif (temp != XHCI_INIT_VALUE)\r\nxhci_dbg(xhci, " WARN: %p: Rsvd[%i] = 0x%x\n",\r\n&xhci->run_regs->rsvd[i],\r\ni, (unsigned int) temp);\r\n}\r\n}\r\nvoid xhci_print_registers(struct xhci_hcd *xhci)\r\n{\r\nxhci_print_cap_regs(xhci);\r\nxhci_print_op_regs(xhci);\r\nxhci_print_ports(xhci);\r\n}\r\nvoid xhci_dbg_erst(struct xhci_hcd *xhci, struct xhci_erst *erst)\r\n{\r\nu64 addr = erst->erst_dma_addr;\r\nint i;\r\nstruct xhci_erst_entry *entry;\r\nfor (i = 0; i < erst->num_entries; i++) {\r\nentry = &erst->entries[i];\r\nxhci_dbg(xhci, "@%016llx %08x %08x %08x %08x\n",\r\naddr,\r\nlower_32_bits(le64_to_cpu(entry->seg_addr)),\r\nupper_32_bits(le64_to_cpu(entry->seg_addr)),\r\nle32_to_cpu(entry->seg_size),\r\nle32_to_cpu(entry->rsvd));\r\naddr += sizeof(*entry);\r\n}\r\n}\r\nvoid xhci_dbg_cmd_ptrs(struct xhci_hcd *xhci)\r\n{\r\nu64 val;\r\nval = xhci_read_64(xhci, &xhci->op_regs->cmd_ring);\r\nxhci_dbg(xhci, "// xHC command ring deq ptr low bits + flags = @%08x\n",\r\nlower_32_bits(val));\r\nxhci_dbg(xhci, "// xHC command ring deq ptr high bits = @%08x\n",\r\nupper_32_bits(val));\r\n}\r\nchar *xhci_get_slot_state(struct xhci_hcd *xhci,\r\nstruct xhci_container_ctx *ctx)\r\n{\r\nstruct xhci_slot_ctx *slot_ctx = xhci_get_slot_ctx(xhci, ctx);\r\nint state = GET_SLOT_STATE(le32_to_cpu(slot_ctx->dev_state));\r\nreturn xhci_slot_state_string(state);\r\n}\r\nvoid xhci_dbg_trace(struct xhci_hcd *xhci, void (*trace)(struct va_format *),\r\nconst char *fmt, ...)\r\n{\r\nstruct va_format vaf;\r\nva_list args;\r\nva_start(args, fmt);\r\nvaf.fmt = fmt;\r\nvaf.va = &args;\r\nxhci_dbg(xhci, "%pV\n", &vaf);\r\ntrace(&vaf);\r\nva_end(args);\r\n}
