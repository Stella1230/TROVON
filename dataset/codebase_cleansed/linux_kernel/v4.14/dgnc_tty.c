static struct tty_driver *dgnc_tty_create(char *serial_name, uint maxports,\r\nint major, int minor)\r\n{\r\nint rc;\r\nstruct tty_driver *drv;\r\ndrv = tty_alloc_driver(maxports,\r\nTTY_DRIVER_REAL_RAW |\r\nTTY_DRIVER_DYNAMIC_DEV |\r\nTTY_DRIVER_HARDWARE_BREAK);\r\nif (IS_ERR(drv))\r\nreturn drv;\r\ndrv->name = serial_name;\r\ndrv->name_base = 0;\r\ndrv->major = major;\r\ndrv->minor_start = minor;\r\ndrv->type = TTY_DRIVER_TYPE_SERIAL;\r\ndrv->subtype = SERIAL_TYPE_NORMAL;\r\ndrv->init_termios = tty_std_termios;\r\ndrv->init_termios.c_cflag = (B9600 | CS8 | CREAD | HUPCL | CLOCAL);\r\ndrv->init_termios.c_ispeed = 9600;\r\ndrv->init_termios.c_ospeed = 9600;\r\ndrv->driver_name = DRVSTR;\r\ntty_set_operations(drv, &dgnc_tty_ops);\r\nrc = tty_register_driver(drv);\r\nif (rc < 0) {\r\nput_tty_driver(drv);\r\nreturn ERR_PTR(rc);\r\n}\r\nreturn drv;\r\n}\r\nstatic void dgnc_tty_free(struct tty_driver *drv)\r\n{\r\ntty_unregister_driver(drv);\r\nput_tty_driver(drv);\r\n}\r\nint dgnc_tty_register(struct dgnc_board *brd)\r\n{\r\nint rc;\r\nsnprintf(brd->serial_name, MAXTTYNAMELEN, "tty_dgnc_%d_",\r\nbrd->boardnum);\r\nbrd->serial_driver = dgnc_tty_create(brd->serial_name,\r\nbrd->maxports, 0, 0);\r\nif (IS_ERR(brd->serial_driver)) {\r\nrc = PTR_ERR(brd->serial_driver);\r\ndev_dbg(&brd->pdev->dev, "Can't register tty device (%d)\n",\r\nrc);\r\nreturn rc;\r\n}\r\nsnprintf(brd->print_name, MAXTTYNAMELEN, "pr_dgnc_%d_", brd->boardnum);\r\nbrd->print_driver = dgnc_tty_create(brd->print_name, brd->maxports,\r\n0x80,\r\nbrd->serial_driver->major);\r\nif (IS_ERR(brd->print_driver)) {\r\nrc = PTR_ERR(brd->print_driver);\r\ndev_dbg(&brd->pdev->dev,\r\n"Can't register Transparent Print device(%d)\n", rc);\r\ndgnc_tty_free(brd->serial_driver);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nvoid dgnc_tty_unregister(struct dgnc_board *brd)\r\n{\r\ndgnc_tty_free(brd->print_driver);\r\ndgnc_tty_free(brd->serial_driver);\r\n}\r\nint dgnc_tty_init(struct dgnc_board *brd)\r\n{\r\nint i;\r\nint rc;\r\nvoid __iomem *vaddr;\r\nstruct channel_t *ch;\r\nif (!brd)\r\nreturn -ENXIO;\r\nvaddr = brd->re_map_membase;\r\nbrd->nasync = brd->maxports;\r\nfor (i = 0; i < brd->nasync; i++) {\r\nbrd->channels[i] = kzalloc(sizeof(*brd->channels[i]),\r\nGFP_KERNEL);\r\nif (!brd->channels[i]) {\r\nrc = -ENOMEM;\r\ngoto err_free_channels;\r\n}\r\n}\r\nch = brd->channels[0];\r\nvaddr = brd->re_map_membase;\r\nfor (i = 0; i < brd->nasync; i++, ch = brd->channels[i]) {\r\nspin_lock_init(&ch->ch_lock);\r\nch->ch_tun.un_ch = ch;\r\nch->ch_tun.un_type = DGNC_SERIAL;\r\nch->ch_tun.un_dev = i;\r\nch->ch_pun.un_ch = ch;\r\nch->ch_pun.un_type = DGNC_PRINT;\r\nch->ch_pun.un_dev = i + 128;\r\nif (brd->bd_uart_offset == 0x200)\r\nch->ch_neo_uart = vaddr + (brd->bd_uart_offset * i);\r\nelse\r\nch->ch_cls_uart = vaddr + (brd->bd_uart_offset * i);\r\nch->ch_bd = brd;\r\nch->ch_portnum = i;\r\nch->ch_digi = dgnc_digi_init;\r\nch->ch_close_delay = 250;\r\ninit_waitqueue_head(&ch->ch_flags_wait);\r\ninit_waitqueue_head(&ch->ch_tun.un_flags_wait);\r\ninit_waitqueue_head(&ch->ch_pun.un_flags_wait);\r\n{\r\nstruct device *classp;\r\nclassp = tty_register_device(brd->serial_driver, i,\r\n&ch->ch_bd->pdev->dev);\r\nch->ch_tun.un_sysfs = classp;\r\nclassp = tty_register_device(brd->print_driver, i,\r\n&ch->ch_bd->pdev->dev);\r\nch->ch_pun.un_sysfs = classp;\r\n}\r\n}\r\nreturn 0;\r\nerr_free_channels:\r\nfor (i = i - 1; i >= 0; --i) {\r\nkfree(brd->channels[i]);\r\nbrd->channels[i] = NULL;\r\n}\r\nreturn rc;\r\n}\r\nvoid dgnc_cleanup_tty(struct dgnc_board *brd)\r\n{\r\nint i = 0;\r\nfor (i = 0; i < brd->nasync; i++)\r\ntty_unregister_device(brd->serial_driver, i);\r\ntty_unregister_driver(brd->serial_driver);\r\nfor (i = 0; i < brd->nasync; i++)\r\ntty_unregister_device(brd->print_driver, i);\r\ntty_unregister_driver(brd->print_driver);\r\nput_tty_driver(brd->serial_driver);\r\nput_tty_driver(brd->print_driver);\r\n}\r\nstatic void dgnc_wmove(struct channel_t *ch, char *buf, uint n)\r\n{\r\nint remain;\r\nuint head;\r\nif (!ch)\r\nreturn;\r\nhead = ch->ch_w_head & WQUEUEMASK;\r\nremain = WQUEUESIZE - head;\r\nif (n >= remain) {\r\nn -= remain;\r\nmemcpy(ch->ch_wqueue + head, buf, remain);\r\nhead = 0;\r\nbuf += remain;\r\n}\r\nif (n > 0) {\r\nremain = n;\r\nmemcpy(ch->ch_wqueue + head, buf, remain);\r\nhead += remain;\r\n}\r\nhead &= WQUEUEMASK;\r\nch->ch_w_head = head;\r\n}\r\nvoid dgnc_input(struct channel_t *ch)\r\n{\r\nstruct dgnc_board *bd;\r\nstruct tty_struct *tp;\r\nstruct tty_ldisc *ld = NULL;\r\nuint rmask;\r\nushort head;\r\nushort tail;\r\nint data_len;\r\nunsigned long flags;\r\nint flip_len;\r\nint len = 0;\r\nint n = 0;\r\nint s = 0;\r\nint i = 0;\r\nif (!ch)\r\nreturn;\r\ntp = ch->ch_tun.un_tty;\r\nbd = ch->ch_bd;\r\nif (!bd)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nrmask = RQUEUEMASK;\r\nhead = ch->ch_r_head & rmask;\r\ntail = ch->ch_r_tail & rmask;\r\ndata_len = (head - tail) & rmask;\r\nif (data_len == 0)\r\ngoto exit_unlock;\r\nif (!tp ||\r\n!(ch->ch_tun.un_flags & UN_ISOPEN) ||\r\n!C_CREAD(tp) ||\r\n(ch->ch_tun.un_flags & UN_CLOSING)) {\r\nch->ch_r_head = tail;\r\ndgnc_check_queue_flow_control(ch);\r\ngoto exit_unlock;\r\n}\r\nif (ch->ch_flags & CH_FORCED_STOPI)\r\ngoto exit_unlock;\r\nflip_len = TTY_FLIPBUF_SIZE;\r\nlen = min(data_len, flip_len);\r\nlen = min(len, (N_TTY_BUF_SIZE - 1));\r\nld = tty_ldisc_ref(tp);\r\nif (!ld) {\r\nlen = 0;\r\n} else {\r\nif (!ld->ops->receive_buf) {\r\nch->ch_r_head = ch->ch_r_tail;\r\nlen = 0;\r\n}\r\n}\r\nif (len <= 0)\r\ngoto exit_unlock;\r\nlen = tty_buffer_request_room(tp->port, len);\r\nn = len;\r\nwhile (n) {\r\nunsigned char *ch_pos = ch->ch_equeue + tail;\r\ns = ((head >= tail) ? head : RQUEUESIZE) - tail;\r\ns = min(s, n);\r\nif (s <= 0)\r\nbreak;\r\nif (I_PARMRK(tp) || I_BRKINT(tp) || I_INPCK(tp)) {\r\nfor (i = 0; i < s; i++) {\r\nunsigned char ch = *(ch_pos + i);\r\nchar flag = TTY_NORMAL;\r\nif (ch & UART_LSR_BI)\r\nflag = TTY_BREAK;\r\nelse if (ch & UART_LSR_PE)\r\nflag = TTY_PARITY;\r\nelse if (ch & UART_LSR_FE)\r\nflag = TTY_FRAME;\r\ntty_insert_flip_char(tp->port, ch, flag);\r\n}\r\n} else {\r\ntty_insert_flip_string(tp->port, ch_pos, s);\r\n}\r\ntail += s;\r\nn -= s;\r\ntail &= rmask;\r\n}\r\nch->ch_r_tail = tail & rmask;\r\nch->ch_e_tail = tail & rmask;\r\ndgnc_check_queue_flow_control(ch);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\ntty_flip_buffer_push(tp->port);\r\nif (ld)\r\ntty_ldisc_deref(ld);\r\nreturn;\r\nexit_unlock:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nif (ld)\r\ntty_ldisc_deref(ld);\r\n}\r\nvoid dgnc_carrier(struct channel_t *ch)\r\n{\r\nint virt_carrier = 0;\r\nint phys_carrier = 0;\r\nif (!ch)\r\nreturn;\r\nif (ch->ch_mistat & UART_MSR_DCD)\r\nphys_carrier = 1;\r\nif (ch->ch_digi.digi_flags & DIGI_FORCEDCD)\r\nvirt_carrier = 1;\r\nif (ch->ch_c_cflag & CLOCAL)\r\nvirt_carrier = 1;\r\nif (((ch->ch_flags & CH_FCAR) == 0) && (virt_carrier == 1)) {\r\nif (waitqueue_active(&ch->ch_flags_wait))\r\nwake_up_interruptible(&ch->ch_flags_wait);\r\n}\r\nif (((ch->ch_flags & CH_CD) == 0) && (phys_carrier == 1)) {\r\nif (waitqueue_active(&ch->ch_flags_wait))\r\nwake_up_interruptible(&ch->ch_flags_wait);\r\n}\r\nif ((virt_carrier == 0) && ((ch->ch_flags & CH_CD) != 0) &&\r\n(phys_carrier == 0)) {\r\nif (waitqueue_active(&ch->ch_flags_wait))\r\nwake_up_interruptible(&ch->ch_flags_wait);\r\nif (ch->ch_tun.un_open_count > 0)\r\ntty_hangup(ch->ch_tun.un_tty);\r\nif (ch->ch_pun.un_open_count > 0)\r\ntty_hangup(ch->ch_pun.un_tty);\r\n}\r\nif (virt_carrier == 1)\r\nch->ch_flags |= CH_FCAR;\r\nelse\r\nch->ch_flags &= ~CH_FCAR;\r\nif (phys_carrier == 1)\r\nch->ch_flags |= CH_CD;\r\nelse\r\nch->ch_flags &= ~CH_CD;\r\n}\r\nstatic void dgnc_set_custom_speed(struct channel_t *ch, uint newrate)\r\n{\r\nint testdiv;\r\nint testrate_high;\r\nint testrate_low;\r\nint deltahigh;\r\nint deltalow;\r\nif (newrate <= 0) {\r\nch->ch_custom_speed = 0;\r\nreturn;\r\n}\r\nif (newrate && newrate < ((ch->ch_bd->bd_dividend / 0xFFFF) + 1))\r\nnewrate = (ch->ch_bd->bd_dividend / 0xFFFF) + 1;\r\nif (newrate && newrate > ch->ch_bd->bd_dividend)\r\nnewrate = ch->ch_bd->bd_dividend;\r\nif (newrate > 0) {\r\ntestdiv = ch->ch_bd->bd_dividend / newrate;\r\ntestrate_high = ch->ch_bd->bd_dividend / testdiv;\r\ntestrate_low = ch->ch_bd->bd_dividend / (testdiv + 1);\r\nif (testrate_high != newrate) {\r\ndeltahigh = testrate_high - newrate;\r\ndeltalow = newrate - testrate_low;\r\nif (deltahigh < deltalow)\r\nnewrate = testrate_high;\r\nelse\r\nnewrate = testrate_low;\r\n}\r\n}\r\nch->ch_custom_speed = newrate;\r\n}\r\nvoid dgnc_check_queue_flow_control(struct channel_t *ch)\r\n{\r\nint qleft;\r\nqleft = ch->ch_r_tail - ch->ch_r_head - 1;\r\nif (qleft < 0)\r\nqleft += RQUEUEMASK + 1;\r\nif (qleft < 256) {\r\nif (ch->ch_digi.digi_flags & CTSPACE ||\r\nch->ch_c_cflag & CRTSCTS) {\r\nif (!(ch->ch_flags & CH_RECEIVER_OFF)) {\r\nch->ch_bd->bd_ops->disable_receiver(ch);\r\nch->ch_flags |= (CH_RECEIVER_OFF);\r\n}\r\n}\r\nelse if (ch->ch_c_iflag & IXOFF) {\r\nif (ch->ch_stops_sent <= MAX_STOPS_SENT) {\r\nch->ch_bd->bd_ops->send_stop_character(ch);\r\nch->ch_stops_sent++;\r\n}\r\n}\r\n}\r\nif (qleft > (RQUEUESIZE / 2)) {\r\nif (ch->ch_digi.digi_flags & RTSPACE ||\r\nch->ch_c_cflag & CRTSCTS) {\r\nif (ch->ch_flags & CH_RECEIVER_OFF) {\r\nch->ch_bd->bd_ops->enable_receiver(ch);\r\nch->ch_flags &= ~(CH_RECEIVER_OFF);\r\n}\r\n}\r\nelse if (ch->ch_c_iflag & IXOFF && ch->ch_stops_sent) {\r\nch->ch_stops_sent = 0;\r\nch->ch_bd->bd_ops->send_start_character(ch);\r\n}\r\n}\r\n}\r\nstatic void dgnc_set_signal_low(struct channel_t *ch, const unsigned char sig)\r\n{\r\nch->ch_mostat &= ~(sig);\r\nch->ch_bd->bd_ops->assert_modem_signals(ch);\r\n}\r\nvoid dgnc_wakeup_writes(struct channel_t *ch)\r\n{\r\nint qlen = 0;\r\nunsigned long flags;\r\nif (!ch)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nqlen = ch->ch_w_head - ch->ch_w_tail;\r\nif (qlen < 0)\r\nqlen += WQUEUESIZE;\r\nif (qlen >= (WQUEUESIZE - 256)) {\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn;\r\n}\r\nif (ch->ch_tun.un_flags & UN_ISOPEN) {\r\ntty_wakeup(ch->ch_tun.un_tty);\r\nif (ch->ch_tun.un_flags & UN_EMPTY) {\r\nif ((qlen == 0) &&\r\n(ch->ch_bd->bd_ops->get_uart_bytes_left(ch) == 0)) {\r\nch->ch_tun.un_flags &= ~(UN_EMPTY);\r\nif (ch->ch_digi.digi_flags & DIGI_RTS_TOGGLE)\r\ndgnc_set_signal_low(ch, UART_MCR_RTS);\r\nif (ch->ch_digi.digi_flags & DIGI_DTR_TOGGLE)\r\ndgnc_set_signal_low(ch, UART_MCR_DTR);\r\n}\r\n}\r\nwake_up_interruptible(&ch->ch_tun.un_flags_wait);\r\n}\r\nif (ch->ch_pun.un_flags & UN_ISOPEN) {\r\ntty_wakeup(ch->ch_pun.un_tty);\r\nif (ch->ch_pun.un_flags & UN_EMPTY) {\r\nif ((qlen == 0) &&\r\n(ch->ch_bd->bd_ops->get_uart_bytes_left(ch) == 0))\r\nch->ch_pun.un_flags &= ~(UN_EMPTY);\r\n}\r\nwake_up_interruptible(&ch->ch_pun.un_flags_wait);\r\n}\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\n}\r\nstatic struct dgnc_board *find_board_by_major(unsigned int major)\r\n{\r\nint i;\r\nfor (i = 0; i < MAXBOARDS; i++) {\r\nstruct dgnc_board *brd = dgnc_board[i];\r\nif (!brd)\r\nreturn NULL;\r\nif (major == brd->serial_driver->major ||\r\nmajor == brd->print_driver->major)\r\nreturn brd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int dgnc_tty_open(struct tty_struct *tty, struct file *file)\r\n{\r\nstruct dgnc_board *brd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nuint major = 0;\r\nuint minor = 0;\r\nint rc = 0;\r\nunsigned long flags;\r\nrc = 0;\r\nmajor = MAJOR(tty_devnum(tty));\r\nminor = MINOR(tty_devnum(tty));\r\nif (major > 255)\r\nreturn -ENXIO;\r\nbrd = find_board_by_major(major);\r\nif (!brd)\r\nreturn -ENXIO;\r\nrc = wait_event_interruptible(brd->state_wait,\r\n(brd->state & BOARD_READY));\r\nif (rc)\r\nreturn rc;\r\nspin_lock_irqsave(&brd->bd_lock, flags);\r\nif (PORT_NUM(minor) >= brd->nasync) {\r\nrc = -ENXIO;\r\ngoto err_brd_unlock;\r\n}\r\nch = brd->channels[PORT_NUM(minor)];\r\nif (!ch) {\r\nrc = -ENXIO;\r\ngoto err_brd_unlock;\r\n}\r\nspin_unlock_irqrestore(&brd->bd_lock, flags);\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nif (!IS_PRINT(minor)) {\r\nun = &brd->channels[PORT_NUM(minor)]->ch_tun;\r\nun->un_type = DGNC_SERIAL;\r\n} else if (IS_PRINT(minor)) {\r\nun = &brd->channels[PORT_NUM(minor)]->ch_pun;\r\nun->un_type = DGNC_PRINT;\r\n} else {\r\nrc = -ENXIO;\r\ngoto err_ch_unlock;\r\n}\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nrc = wait_event_interruptible(ch->ch_flags_wait,\r\n((ch->ch_flags & CH_OPENING) == 0));\r\nif (rc)\r\nreturn -EINTR;\r\nrc = wait_event_interruptible(\r\nch->ch_flags_wait,\r\n(((ch->ch_tun.un_flags |\r\nch->ch_pun.un_flags) & UN_CLOSING) == 0));\r\nif (rc)\r\nreturn -EINTR;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\ntty->driver_data = un;\r\nif (!(un->un_flags & UN_ISOPEN)) {\r\nun->un_tty = tty;\r\n}\r\nch->ch_flags |= (CH_OPENING);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nif (!ch->ch_rqueue)\r\nch->ch_rqueue = kzalloc(RQUEUESIZE, GFP_KERNEL);\r\nif (!ch->ch_equeue)\r\nch->ch_equeue = kzalloc(EQUEUESIZE, GFP_KERNEL);\r\nif (!ch->ch_wqueue)\r\nch->ch_wqueue = kzalloc(WQUEUESIZE, GFP_KERNEL);\r\nif (!ch->ch_rqueue || !ch->ch_equeue || !ch->ch_wqueue) {\r\nkfree(ch->ch_rqueue);\r\nkfree(ch->ch_equeue);\r\nkfree(ch->ch_wqueue);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nch->ch_flags &= ~(CH_OPENING);\r\nwake_up_interruptible(&ch->ch_flags_wait);\r\nif (!((ch->ch_tun.un_flags | ch->ch_pun.un_flags) & UN_ISOPEN)) {\r\nch->ch_r_head = 0;\r\nch->ch_r_tail = 0;\r\nch->ch_e_head = 0;\r\nch->ch_e_tail = 0;\r\nch->ch_w_head = 0;\r\nch->ch_w_tail = 0;\r\nbrd->bd_ops->flush_uart_write(ch);\r\nbrd->bd_ops->flush_uart_read(ch);\r\nch->ch_flags = 0;\r\nch->ch_cached_lsr = 0;\r\nch->ch_stop_sending_break = 0;\r\nch->ch_stops_sent = 0;\r\nch->ch_c_cflag = tty->termios.c_cflag;\r\nch->ch_c_iflag = tty->termios.c_iflag;\r\nch->ch_c_oflag = tty->termios.c_oflag;\r\nch->ch_c_lflag = tty->termios.c_lflag;\r\nch->ch_startc = tty->termios.c_cc[VSTART];\r\nch->ch_stopc = tty->termios.c_cc[VSTOP];\r\nif (!(ch->ch_digi.digi_flags & DIGI_RTS_TOGGLE))\r\nch->ch_mostat |= (UART_MCR_RTS);\r\nif (!(ch->ch_digi.digi_flags & DIGI_DTR_TOGGLE))\r\nch->ch_mostat |= (UART_MCR_DTR);\r\nbrd->bd_ops->uart_init(ch);\r\n}\r\nbrd->bd_ops->param(tty);\r\ndgnc_carrier(ch);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nrc = dgnc_block_til_ready(tty, file, ch);\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nch->ch_open_count++;\r\nun->un_open_count++;\r\nun->un_flags |= (UN_ISOPEN);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn rc;\r\nerr_brd_unlock:\r\nspin_unlock_irqrestore(&brd->bd_lock, flags);\r\nreturn rc;\r\nerr_ch_unlock:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn rc;\r\n}\r\nstatic int dgnc_block_til_ready(struct tty_struct *tty,\r\nstruct file *file,\r\nstruct channel_t *ch)\r\n{\r\nint rc = 0;\r\nstruct un_t *un = tty->driver_data;\r\nunsigned long flags;\r\nuint old_flags = 0;\r\nint sleep_on_un_flags = 0;\r\nif (!file)\r\nreturn -ENXIO;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nch->ch_wopen++;\r\nwhile (1) {\r\nsleep_on_un_flags = 0;\r\nif (ch->ch_bd->state == BOARD_FAILED) {\r\nrc = -ENXIO;\r\nbreak;\r\n}\r\nif (tty_hung_up_p(file)) {\r\nrc = -EAGAIN;\r\nbreak;\r\n}\r\nif (!((ch->ch_tun.un_flags |\r\nch->ch_pun.un_flags) &\r\nUN_CLOSING)) {\r\nif (file->f_flags & O_NONBLOCK)\r\nbreak;\r\nif (tty_io_error(tty)) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\nif (ch->ch_flags & CH_CD)\r\nbreak;\r\nif (ch->ch_flags & CH_FCAR)\r\nbreak;\r\n} else {\r\nsleep_on_un_flags = 1;\r\n}\r\nif (signal_pending(current)) {\r\nrc = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (sleep_on_un_flags)\r\nold_flags = ch->ch_tun.un_flags | ch->ch_pun.un_flags;\r\nelse\r\nold_flags = ch->ch_flags;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nif (sleep_on_un_flags)\r\nrc = wait_event_interruptible\r\n(un->un_flags_wait,\r\n(old_flags != (ch->ch_tun.un_flags |\r\nch->ch_pun.un_flags)));\r\nelse\r\nrc = wait_event_interruptible(\r\nch->ch_flags_wait,\r\n(old_flags != ch->ch_flags));\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\n}\r\nch->ch_wopen--;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn rc;\r\n}\r\nstatic void dgnc_tty_hangup(struct tty_struct *tty)\r\n{\r\nif (!tty)\r\nreturn;\r\ndgnc_tty_flush_buffer(tty);\r\n}\r\nstatic void dgnc_tty_close(struct tty_struct *tty, struct file *file)\r\n{\r\nstruct dgnc_board *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nunsigned long flags;\r\nif (!tty)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nif ((tty->count == 1) && (un->un_open_count != 1)) {\r\ndev_dbg(tty->dev,\r\n"tty->count is 1, un open count is %d\n",\r\nun->un_open_count);\r\nun->un_open_count = 1;\r\n}\r\nif (un->un_open_count)\r\nun->un_open_count--;\r\nelse\r\ndev_dbg(tty->dev,\r\n"bad serial port open count of %d\n",\r\nun->un_open_count);\r\nch->ch_open_count--;\r\nif (ch->ch_open_count && un->un_open_count) {\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn;\r\n}\r\nun->un_flags |= UN_CLOSING;\r\ntty->closing = 1;\r\nif ((ch->ch_open_count == 0) &&\r\n!(ch->ch_digi.digi_flags & DIGI_PRINTER)) {\r\nch->ch_flags &= ~(CH_STOPI | CH_FORCED_STOPI);\r\nif ((un->un_type == DGNC_PRINT) && (ch->ch_flags & CH_PRON)) {\r\ndgnc_wmove(ch, ch->ch_digi.digi_offstr,\r\n(int)ch->ch_digi.digi_offlen);\r\nch->ch_flags &= ~CH_PRON;\r\n}\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nbd->bd_ops->drain(tty, 0);\r\ndgnc_tty_flush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\ntty->closing = 0;\r\nif (ch->ch_c_cflag & HUPCL) {\r\nch->ch_mostat &= ~(UART_MCR_DTR | UART_MCR_RTS);\r\nbd->bd_ops->assert_modem_signals(ch);\r\nif (ch->ch_close_delay) {\r\nspin_unlock_irqrestore(&ch->ch_lock,\r\nflags);\r\ndgnc_ms_sleep(ch->ch_close_delay);\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\n}\r\n}\r\nch->ch_old_baud = 0;\r\nch->ch_bd->bd_ops->uart_off(ch);\r\n} else {\r\nif ((un->un_type == DGNC_PRINT) && (ch->ch_flags & CH_PRON)) {\r\ndgnc_wmove(ch, ch->ch_digi.digi_offstr,\r\n(int)ch->ch_digi.digi_offlen);\r\nch->ch_flags &= ~CH_PRON;\r\n}\r\n}\r\nun->un_tty = NULL;\r\nun->un_flags &= ~(UN_ISOPEN | UN_CLOSING);\r\nwake_up_interruptible(&ch->ch_flags_wait);\r\nwake_up_interruptible(&un->un_flags_wait);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\n}\r\nstatic int dgnc_tty_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct channel_t *ch = NULL;\r\nstruct un_t *un = NULL;\r\nushort thead;\r\nushort ttail;\r\nuint tmask;\r\nuint chars;\r\nunsigned long flags;\r\nif (!tty)\r\nreturn 0;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn 0;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\ntmask = WQUEUEMASK;\r\nthead = ch->ch_w_head & tmask;\r\nttail = ch->ch_w_tail & tmask;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nif (ttail == thead)\r\nchars = 0;\r\nelse if (thead > ttail)\r\nchars = thead - ttail;\r\nelse\r\nchars = thead - ttail + WQUEUESIZE;\r\nreturn chars;\r\n}\r\nstatic int dgnc_maxcps_room(struct channel_t *ch, int bytes_available)\r\n{\r\nint rc = bytes_available;\r\nif (ch->ch_digi.digi_maxcps > 0 && ch->ch_digi.digi_bufsize > 0) {\r\nint cps_limit = 0;\r\nunsigned long current_time = jiffies;\r\nunsigned long buffer_time = current_time +\r\n(HZ * ch->ch_digi.digi_bufsize) /\r\nch->ch_digi.digi_maxcps;\r\nif (ch->ch_cpstime < current_time) {\r\nch->ch_cpstime = current_time;\r\ncps_limit = ch->ch_digi.digi_bufsize;\r\n} else if (ch->ch_cpstime < buffer_time) {\r\ncps_limit = ((buffer_time - ch->ch_cpstime) *\r\nch->ch_digi.digi_maxcps) / HZ;\r\n} else {\r\ncps_limit = 0;\r\n}\r\nrc = min(cps_limit, bytes_available);\r\n}\r\nreturn rc;\r\n}\r\nstatic int dgnc_tty_write_room(struct tty_struct *tty)\r\n{\r\nstruct channel_t *ch = NULL;\r\nstruct un_t *un = NULL;\r\nushort head;\r\nushort tail;\r\nushort tmask;\r\nint room = 0;\r\nunsigned long flags;\r\nif (!tty)\r\nreturn 0;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn 0;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\ntmask = WQUEUEMASK;\r\nhead = (ch->ch_w_head) & tmask;\r\ntail = (ch->ch_w_tail) & tmask;\r\nroom = tail - head - 1;\r\nif (room < 0)\r\nroom += WQUEUESIZE;\r\nif (un->un_type != DGNC_PRINT)\r\nroom = dgnc_maxcps_room(ch, room);\r\nif (un->un_type == DGNC_PRINT) {\r\nif (!(ch->ch_flags & CH_PRON))\r\nroom -= ch->ch_digi.digi_onlen;\r\nroom -= ch->ch_digi.digi_offlen;\r\n} else {\r\nif (ch->ch_flags & CH_PRON)\r\nroom -= ch->ch_digi.digi_offlen;\r\n}\r\nif (room < 0)\r\nroom = 0;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn room;\r\n}\r\nstatic int dgnc_tty_put_char(struct tty_struct *tty, unsigned char c)\r\n{\r\ndgnc_tty_write(tty, &c, 1);\r\nreturn 1;\r\n}\r\nstatic int dgnc_tty_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct channel_t *ch = NULL;\r\nstruct un_t *un = NULL;\r\nint bufcount = 0, n = 0;\r\nunsigned long flags;\r\nushort head;\r\nushort tail;\r\nushort tmask;\r\nuint remain;\r\nif (!tty)\r\nreturn 0;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn 0;\r\nif (!count)\r\nreturn 0;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\ntmask = WQUEUEMASK;\r\nhead = (ch->ch_w_head) & tmask;\r\ntail = (ch->ch_w_tail) & tmask;\r\nbufcount = tail - head - 1;\r\nif (bufcount < 0)\r\nbufcount += WQUEUESIZE;\r\nif (un->un_type != DGNC_PRINT)\r\nbufcount = dgnc_maxcps_room(ch, bufcount);\r\ncount = min(count, bufcount);\r\nif (count <= 0)\r\ngoto exit_retry;\r\nif ((un->un_type == DGNC_PRINT) && !(ch->ch_flags & CH_PRON)) {\r\ndgnc_wmove(ch, ch->ch_digi.digi_onstr,\r\n(int)ch->ch_digi.digi_onlen);\r\nhead = (ch->ch_w_head) & tmask;\r\nch->ch_flags |= CH_PRON;\r\n}\r\nif ((un->un_type != DGNC_PRINT) && (ch->ch_flags & CH_PRON)) {\r\ndgnc_wmove(ch, ch->ch_digi.digi_offstr,\r\n(int)ch->ch_digi.digi_offlen);\r\nhead = (ch->ch_w_head) & tmask;\r\nch->ch_flags &= ~CH_PRON;\r\n}\r\nn = count;\r\nremain = WQUEUESIZE - head;\r\nif (n >= remain) {\r\nn -= remain;\r\nmemcpy(ch->ch_wqueue + head, buf, remain);\r\nhead = 0;\r\nbuf += remain;\r\n}\r\nif (n > 0) {\r\nremain = n;\r\nmemcpy(ch->ch_wqueue + head, buf, remain);\r\nhead += remain;\r\n}\r\nif (count) {\r\nhead &= tmask;\r\nch->ch_w_head = head;\r\n}\r\nif ((un->un_type == DGNC_PRINT) && (ch->ch_digi.digi_maxcps > 0) &&\r\n(ch->ch_digi.digi_bufsize > 0)) {\r\nch->ch_cpstime += (HZ * count) / ch->ch_digi.digi_maxcps;\r\n}\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nif (count)\r\nch->ch_bd->bd_ops->copy_data_from_queue_to_uart(ch);\r\nreturn count;\r\nexit_retry:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dgnc_tty_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nint rc;\r\nunsigned char mstat = 0;\r\nunsigned long flags;\r\nif (!tty)\r\nreturn -EIO;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn -EIO;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn -EIO;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nmstat = ch->ch_mostat | ch->ch_mistat;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nrc = 0;\r\nif (mstat & UART_MCR_DTR)\r\nrc |= TIOCM_DTR;\r\nif (mstat & UART_MCR_RTS)\r\nrc |= TIOCM_RTS;\r\nif (mstat & UART_MSR_CTS)\r\nrc |= TIOCM_CTS;\r\nif (mstat & UART_MSR_DSR)\r\nrc |= TIOCM_DSR;\r\nif (mstat & UART_MSR_RI)\r\nrc |= TIOCM_RI;\r\nif (mstat & UART_MSR_DCD)\r\nrc |= TIOCM_CD;\r\nreturn rc;\r\n}\r\nstatic int dgnc_tty_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct dgnc_board *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nunsigned long flags;\r\nif (!tty)\r\nreturn -EIO;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn -EIO;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn -EIO;\r\nbd = ch->ch_bd;\r\nif (!bd)\r\nreturn -EIO;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nif (set & TIOCM_RTS)\r\nch->ch_mostat |= UART_MCR_RTS;\r\nif (set & TIOCM_DTR)\r\nch->ch_mostat |= UART_MCR_DTR;\r\nif (clear & TIOCM_RTS)\r\nch->ch_mostat &= ~(UART_MCR_RTS);\r\nif (clear & TIOCM_DTR)\r\nch->ch_mostat &= ~(UART_MCR_DTR);\r\nbd->bd_ops->assert_modem_signals(ch);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dgnc_tty_send_break(struct tty_struct *tty, int msec)\r\n{\r\nstruct dgnc_board *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nunsigned long flags;\r\nif (!tty)\r\nreturn -EIO;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn -EIO;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn -EIO;\r\nbd = ch->ch_bd;\r\nif (!bd)\r\nreturn -EIO;\r\nif (msec < 0)\r\nmsec = 0xFFFF;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nbd->bd_ops->send_break(ch, msec);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void dgnc_tty_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nstruct dgnc_board *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!tty)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd)\r\nreturn;\r\nbd->bd_ops->drain(tty, 0);\r\n}\r\nstatic void dgnc_tty_send_xchar(struct tty_struct *tty, char c)\r\n{\r\nstruct dgnc_board *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nunsigned long flags;\r\nif (!tty)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nbd->bd_ops->send_immediate_char(ch, c);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\n}\r\nstatic inline int dgnc_get_mstat(struct channel_t *ch)\r\n{\r\nunsigned char mstat;\r\nunsigned long flags;\r\nint rc;\r\nif (!ch)\r\nreturn -ENXIO;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nmstat = ch->ch_mostat | ch->ch_mistat;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nrc = 0;\r\nif (mstat & UART_MCR_DTR)\r\nrc |= TIOCM_DTR;\r\nif (mstat & UART_MCR_RTS)\r\nrc |= TIOCM_RTS;\r\nif (mstat & UART_MSR_CTS)\r\nrc |= TIOCM_CTS;\r\nif (mstat & UART_MSR_DSR)\r\nrc |= TIOCM_DSR;\r\nif (mstat & UART_MSR_RI)\r\nrc |= TIOCM_RI;\r\nif (mstat & UART_MSR_DCD)\r\nrc |= TIOCM_CD;\r\nreturn rc;\r\n}\r\nstatic int dgnc_get_modem_info(struct channel_t *ch,\r\nunsigned int __user *value)\r\n{\r\nreturn put_user(dgnc_get_mstat(ch), value);\r\n}\r\nstatic int dgnc_set_modem_info(struct channel_t *ch,\r\nunsigned int command,\r\nunsigned int __user *value)\r\n{\r\nint rc;\r\nunsigned int arg = 0;\r\nunsigned long flags;\r\nrc = get_user(arg, value);\r\nif (rc)\r\nreturn rc;\r\nswitch (command) {\r\ncase TIOCMBIS:\r\nif (arg & TIOCM_RTS)\r\nch->ch_mostat |= UART_MCR_RTS;\r\nif (arg & TIOCM_DTR)\r\nch->ch_mostat |= UART_MCR_DTR;\r\nbreak;\r\ncase TIOCMBIC:\r\nif (arg & TIOCM_RTS)\r\nch->ch_mostat &= ~(UART_MCR_RTS);\r\nif (arg & TIOCM_DTR)\r\nch->ch_mostat &= ~(UART_MCR_DTR);\r\nbreak;\r\ncase TIOCMSET:\r\nif (arg & TIOCM_RTS)\r\nch->ch_mostat |= UART_MCR_RTS;\r\nelse\r\nch->ch_mostat &= ~(UART_MCR_RTS);\r\nif (arg & TIOCM_DTR)\r\nch->ch_mostat |= UART_MCR_DTR;\r\nelse\r\nch->ch_mostat &= ~(UART_MCR_DTR);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nch->ch_bd->bd_ops->assert_modem_signals(ch);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dgnc_tty_digigeta(struct tty_struct *tty,\r\nstruct digi_t __user *retinfo)\r\n{\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nstruct digi_t tmp;\r\nunsigned long flags;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nif (!tty)\r\nreturn -EFAULT;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn -EFAULT;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nmemcpy(&tmp, &ch->ch_digi, sizeof(tmp));\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int dgnc_tty_digiseta(struct tty_struct *tty,\r\nstruct digi_t __user *new_info)\r\n{\r\nstruct dgnc_board *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nstruct digi_t new_digi;\r\nunsigned long flags;\r\nif (!tty)\r\nreturn -EFAULT;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn -EFAULT;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn -EFAULT;\r\nbd = ch->ch_bd;\r\nif (!bd)\r\nreturn -EFAULT;\r\nif (copy_from_user(&new_digi, new_info, sizeof(new_digi)))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nif (!(ch->ch_digi.digi_flags & DIGI_RTS_TOGGLE) &&\r\n(new_digi.digi_flags & DIGI_RTS_TOGGLE))\r\nch->ch_mostat &= ~(UART_MCR_RTS);\r\nif ((ch->ch_digi.digi_flags & DIGI_RTS_TOGGLE) &&\r\n!(new_digi.digi_flags & DIGI_RTS_TOGGLE))\r\nch->ch_mostat |= (UART_MCR_RTS);\r\nif (!(ch->ch_digi.digi_flags & DIGI_DTR_TOGGLE) &&\r\n(new_digi.digi_flags & DIGI_DTR_TOGGLE))\r\nch->ch_mostat &= ~(UART_MCR_DTR);\r\nif ((ch->ch_digi.digi_flags & DIGI_DTR_TOGGLE) &&\r\n!(new_digi.digi_flags & DIGI_DTR_TOGGLE))\r\nch->ch_mostat |= (UART_MCR_DTR);\r\nmemcpy(&ch->ch_digi, &new_digi, sizeof(new_digi));\r\nif (ch->ch_digi.digi_maxcps < 1)\r\nch->ch_digi.digi_maxcps = 1;\r\nif (ch->ch_digi.digi_maxcps > 10000)\r\nch->ch_digi.digi_maxcps = 10000;\r\nif (ch->ch_digi.digi_bufsize < 10)\r\nch->ch_digi.digi_bufsize = 10;\r\nif (ch->ch_digi.digi_maxchar < 1)\r\nch->ch_digi.digi_maxchar = 1;\r\nif (ch->ch_digi.digi_maxchar > ch->ch_digi.digi_bufsize)\r\nch->ch_digi.digi_maxchar = ch->ch_digi.digi_bufsize;\r\nif (ch->ch_digi.digi_onlen > DIGI_PLEN)\r\nch->ch_digi.digi_onlen = DIGI_PLEN;\r\nif (ch->ch_digi.digi_offlen > DIGI_PLEN)\r\nch->ch_digi.digi_offlen = DIGI_PLEN;\r\nbd->bd_ops->param(tty);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void dgnc_tty_set_termios(struct tty_struct *tty,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct dgnc_board *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nunsigned long flags;\r\nif (!tty)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nch->ch_c_cflag = tty->termios.c_cflag;\r\nch->ch_c_iflag = tty->termios.c_iflag;\r\nch->ch_c_oflag = tty->termios.c_oflag;\r\nch->ch_c_lflag = tty->termios.c_lflag;\r\nch->ch_startc = tty->termios.c_cc[VSTART];\r\nch->ch_stopc = tty->termios.c_cc[VSTOP];\r\nbd->bd_ops->param(tty);\r\ndgnc_carrier(ch);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\n}\r\nstatic void dgnc_tty_throttle(struct tty_struct *tty)\r\n{\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nunsigned long flags;\r\nif (!tty)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nch->ch_flags |= (CH_FORCED_STOPI);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\n}\r\nstatic void dgnc_tty_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nunsigned long flags;\r\nif (!tty)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nch->ch_flags &= ~(CH_FORCED_STOPI);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\n}\r\nstatic void dgnc_tty_start(struct tty_struct *tty)\r\n{\r\nstruct dgnc_board *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nunsigned long flags;\r\nif (!tty)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nch->ch_flags &= ~(CH_FORCED_STOP);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\n}\r\nstatic void dgnc_tty_stop(struct tty_struct *tty)\r\n{\r\nstruct dgnc_board *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nunsigned long flags;\r\nif (!tty)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nch->ch_flags |= (CH_FORCED_STOP);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\n}\r\nstatic void dgnc_tty_flush_chars(struct tty_struct *tty)\r\n{\r\nstruct dgnc_board *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nunsigned long flags;\r\nif (!tty)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\n}\r\nstatic void dgnc_tty_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nunsigned long flags;\r\nif (!tty)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nch->ch_flags &= ~CH_STOP;\r\nch->ch_w_head = ch->ch_w_tail;\r\nch->ch_bd->bd_ops->flush_uart_write(ch);\r\nif (ch->ch_tun.un_flags & (UN_LOW | UN_EMPTY)) {\r\nch->ch_tun.un_flags &= ~(UN_LOW | UN_EMPTY);\r\nwake_up_interruptible(&ch->ch_tun.un_flags_wait);\r\n}\r\nif (ch->ch_pun.un_flags & (UN_LOW | UN_EMPTY)) {\r\nch->ch_pun.un_flags &= ~(UN_LOW | UN_EMPTY);\r\nwake_up_interruptible(&ch->ch_pun.un_flags_wait);\r\n}\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\n}\r\nstatic void dgnc_wake_up_unit(struct un_t *unit)\r\n{\r\nunit->un_flags &= ~(UN_LOW | UN_EMPTY);\r\nwake_up_interruptible(&unit->un_flags_wait);\r\n}\r\nstatic int dgnc_tty_ioctl(struct tty_struct *tty, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct dgnc_board *bd;\r\nstruct board_ops *ch_bd_ops;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nint rc;\r\nunsigned long flags;\r\nvoid __user *uarg = (void __user *)arg;\r\nif (!tty)\r\nreturn -ENODEV;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn -ENODEV;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn -ENODEV;\r\nbd = ch->ch_bd;\r\nif (!bd)\r\nreturn -ENODEV;\r\nch_bd_ops = bd->bd_ops;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nif (un->un_open_count <= 0) {\r\nrc = -EIO;\r\ngoto err_unlock;\r\n}\r\nswitch (cmd) {\r\ncase TCSBRK:\r\nrc = tty_check_change(tty);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nif (rc)\r\nreturn rc;\r\nrc = ch_bd_ops->drain(tty, 0);\r\nif (rc)\r\nreturn -EINTR;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nif (((cmd == TCSBRK) && (!arg)) || (cmd == TCSBRKP))\r\nch_bd_ops->send_break(ch, 250);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn 0;\r\ncase TCSBRKP:\r\nrc = tty_check_change(tty);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nif (rc)\r\nreturn rc;\r\nrc = ch_bd_ops->drain(tty, 0);\r\nif (rc)\r\nreturn -EINTR;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nch_bd_ops->send_break(ch, 250);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn 0;\r\ncase TIOCSBRK:\r\nrc = tty_check_change(tty);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nif (rc)\r\nreturn rc;\r\nrc = ch_bd_ops->drain(tty, 0);\r\nif (rc)\r\nreturn -EINTR;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nch_bd_ops->send_break(ch, 250);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn 0;\r\ncase TIOCCBRK:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn 0;\r\ncase TIOCGSOFTCAR:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn put_user(C_CLOCAL(tty) ? 1 : 0,\r\n(unsigned long __user *)arg);\r\ncase TIOCSSOFTCAR:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nrc = get_user(arg, (unsigned long __user *)arg);\r\nif (rc)\r\nreturn rc;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\ntty->termios.c_cflag = ((tty->termios.c_cflag & ~CLOCAL) |\r\n(arg ? CLOCAL : 0));\r\nch_bd_ops->param(tty);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn 0;\r\ncase TIOCMGET:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn dgnc_get_modem_info(ch, uarg);\r\ncase TIOCMBIS:\r\ncase TIOCMBIC:\r\ncase TIOCMSET:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn dgnc_set_modem_info(ch, cmd, uarg);\r\ncase TCFLSH:\r\nrc = tty_check_change(tty);\r\nif (rc)\r\ngoto err_unlock;\r\nif ((arg == TCIFLUSH) || (arg == TCIOFLUSH)) {\r\nch->ch_r_head = ch->ch_r_tail;\r\nch_bd_ops->flush_uart_read(ch);\r\ndgnc_check_queue_flow_control(ch);\r\n}\r\nif ((arg == TCOFLUSH) || (arg == TCIOFLUSH)) {\r\nif (!(un->un_type == DGNC_PRINT)) {\r\nch->ch_w_head = ch->ch_w_tail;\r\nch_bd_ops->flush_uart_write(ch);\r\nif (ch->ch_tun.un_flags & (UN_LOW | UN_EMPTY))\r\ndgnc_wake_up_unit(&ch->ch_tun);\r\nif (ch->ch_pun.un_flags & (UN_LOW | UN_EMPTY))\r\ndgnc_wake_up_unit(&ch->ch_pun);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn -ENOIOCTLCMD;\r\ncase TCSETSF:\r\ncase TCSETSW:\r\nif (cmd == TCSETSF) {\r\nch->ch_flags &= ~CH_STOP;\r\nch->ch_r_head = ch->ch_r_tail;\r\nch_bd_ops->flush_uart_read(ch);\r\ndgnc_check_queue_flow_control(ch);\r\n}\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nrc = ch_bd_ops->drain(tty, 0);\r\nif (rc)\r\nreturn -EINTR;\r\nreturn -ENOIOCTLCMD;\r\ncase TCSETAW:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nrc = ch_bd_ops->drain(tty, 0);\r\nif (rc)\r\nreturn -EINTR;\r\nreturn -ENOIOCTLCMD;\r\ncase TCXONC:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn -ENOIOCTLCMD;\r\ncase DIGI_GETA:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn dgnc_tty_digigeta(tty, uarg);\r\ncase DIGI_SETAW:\r\ncase DIGI_SETAF:\r\nif (cmd == (DIGI_SETAW)) {\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nrc = ch_bd_ops->drain(tty, 0);\r\nif (rc)\r\nreturn -EINTR;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\n} else {\r\ntty_ldisc_flush(tty);\r\n}\r\ncase DIGI_SETA:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn dgnc_tty_digiseta(tty, uarg);\r\ncase DIGI_LOOPBACK:\r\n{\r\nuint loopback = 0;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nrc = get_user(loopback, (unsigned int __user *)arg);\r\nif (rc)\r\nreturn rc;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nif (loopback)\r\nch->ch_flags |= CH_LOOPBACK;\r\nelse\r\nch->ch_flags &= ~(CH_LOOPBACK);\r\nch_bd_ops->param(tty);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn 0;\r\n}\r\ncase DIGI_GETCUSTOMBAUD:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn put_user(ch->ch_custom_speed,\r\n(unsigned int __user *)arg);\r\ncase DIGI_SETCUSTOMBAUD:\r\n{\r\nint new_rate;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nrc = get_user(new_rate, (int __user *)arg);\r\nif (rc)\r\nreturn rc;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\ndgnc_set_custom_speed(ch, new_rate);\r\nch_bd_ops->param(tty);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn 0;\r\n}\r\ncase DIGI_REALPORT_SENDIMMEDIATE:\r\n{\r\nunsigned char c;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nrc = get_user(c, (unsigned char __user *)arg);\r\nif (rc)\r\nreturn rc;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nch_bd_ops->send_immediate_char(ch, c);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn 0;\r\n}\r\ncase DIGI_REALPORT_GETCOUNTERS:\r\n{\r\nstruct digi_getcounter buf;\r\nbuf.norun = ch->ch_err_overrun;\r\nbuf.noflow = 0;\r\nbuf.nframe = ch->ch_err_frame;\r\nbuf.nparity = ch->ch_err_parity;\r\nbuf.nbreak = ch->ch_err_break;\r\nbuf.rbytes = ch->ch_rxcount;\r\nbuf.tbytes = ch->ch_txcount;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nif (copy_to_user(uarg, &buf, sizeof(buf)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase DIGI_REALPORT_GETEVENTS:\r\n{\r\nunsigned int events = 0;\r\nif (ch->ch_flags & CH_BREAK_SENDING)\r\nevents |= EV_TXB;\r\nif ((ch->ch_flags & CH_STOP) ||\r\n(ch->ch_flags & CH_FORCED_STOP))\r\nevents |= (EV_OPU | EV_OPS);\r\nif ((ch->ch_flags & CH_STOPI) ||\r\n(ch->ch_flags & CH_FORCED_STOPI))\r\nevents |= (EV_IPU | EV_IPS);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn put_user(events, (unsigned int __user *)arg);\r\n}\r\ncase DIGI_REALPORT_GETBUFFERS:\r\n{\r\nstruct digi_getbuffer buf;\r\nint tdist;\r\nint count;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nif (copy_from_user(&buf, uarg, sizeof(buf)))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nbuf.rxbuf = (ch->ch_r_head - ch->ch_r_tail) & RQUEUEMASK;\r\nbuf.txbuf = (ch->ch_w_head - ch->ch_w_tail) & WQUEUEMASK;\r\ncount = buf.txbuf + ch_bd_ops->get_uart_bytes_left(ch);\r\ntdist = (buf.tx_in - buf.tx_out) & 0xffff;\r\nif (buf.txbuf > tdist)\r\nbuf.txbuf = tdist;\r\nif (count)\r\nbuf.txdone = 0;\r\nelse\r\nbuf.txdone = 1;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nif (copy_to_user(uarg, &buf, sizeof(buf)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ndefault:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nerr_unlock:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn rc;\r\n}
