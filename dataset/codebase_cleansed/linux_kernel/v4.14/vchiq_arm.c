static VCHIQ_STATUS_T\r\nadd_completion(VCHIQ_INSTANCE_T instance, VCHIQ_REASON_T reason,\r\nVCHIQ_HEADER_T *header, USER_SERVICE_T *user_service,\r\nvoid *bulk_userdata)\r\n{\r\nVCHIQ_COMPLETION_DATA_T *completion;\r\nint insert;\r\nDEBUG_INITIALISE(g_state.local)\r\ninsert = instance->completion_insert;\r\nwhile ((insert - instance->completion_remove) >= MAX_COMPLETIONS) {\r\nDEBUG_TRACE(SERVICE_CALLBACK_LINE);\r\nvchiq_log_trace(vchiq_arm_log_level,\r\n"add_completion - completion queue full");\r\nDEBUG_COUNT(COMPLETION_QUEUE_FULL_COUNT);\r\nif (down_interruptible(&instance->remove_event) != 0) {\r\nvchiq_log_info(vchiq_arm_log_level,\r\n"service_callback interrupted");\r\nreturn VCHIQ_RETRY;\r\n} else if (instance->closing) {\r\nvchiq_log_info(vchiq_arm_log_level,\r\n"service_callback closing");\r\nreturn VCHIQ_SUCCESS;\r\n}\r\nDEBUG_TRACE(SERVICE_CALLBACK_LINE);\r\n}\r\ncompletion = &instance->completions[insert & (MAX_COMPLETIONS - 1)];\r\ncompletion->header = header;\r\ncompletion->reason = reason;\r\ncompletion->service_userdata = user_service->service;\r\ncompletion->bulk_userdata = bulk_userdata;\r\nif (reason == VCHIQ_SERVICE_CLOSED) {\r\nlock_service(user_service->service);\r\nif (instance->use_close_delivered)\r\nuser_service->close_pending = 1;\r\n}\r\nwmb();\r\nif (reason == VCHIQ_MESSAGE_AVAILABLE)\r\nuser_service->message_available_pos = insert;\r\ninsert++;\r\ninstance->completion_insert = insert;\r\nup(&instance->insert_event);\r\nreturn VCHIQ_SUCCESS;\r\n}\r\nstatic VCHIQ_STATUS_T\r\nservice_callback(VCHIQ_REASON_T reason, VCHIQ_HEADER_T *header,\r\nVCHIQ_SERVICE_HANDLE_T handle, void *bulk_userdata)\r\n{\r\nUSER_SERVICE_T *user_service;\r\nVCHIQ_SERVICE_T *service;\r\nVCHIQ_INSTANCE_T instance;\r\nbool skip_completion = false;\r\nDEBUG_INITIALISE(g_state.local)\r\nDEBUG_TRACE(SERVICE_CALLBACK_LINE);\r\nservice = handle_to_service(handle);\r\nBUG_ON(!service);\r\nuser_service = (USER_SERVICE_T *)service->base.userdata;\r\ninstance = user_service->instance;\r\nif (!instance || instance->closing)\r\nreturn VCHIQ_SUCCESS;\r\nvchiq_log_trace(vchiq_arm_log_level,\r\n"service_callback - service %lx(%d,%p), reason %d, header %lx, "\r\n"instance %lx, bulk_userdata %lx",\r\n(unsigned long)user_service,\r\nservice->localport, user_service->userdata,\r\nreason, (unsigned long)header,\r\n(unsigned long)instance, (unsigned long)bulk_userdata);\r\nif (header && user_service->is_vchi) {\r\nspin_lock(&msg_queue_spinlock);\r\nwhile (user_service->msg_insert ==\r\n(user_service->msg_remove + MSG_QUEUE_SIZE)) {\r\nspin_unlock(&msg_queue_spinlock);\r\nDEBUG_TRACE(SERVICE_CALLBACK_LINE);\r\nDEBUG_COUNT(MSG_QUEUE_FULL_COUNT);\r\nvchiq_log_trace(vchiq_arm_log_level,\r\n"service_callback - msg queue full");\r\nif ((user_service->message_available_pos -\r\ninstance->completion_remove) < 0) {\r\nVCHIQ_STATUS_T status;\r\nvchiq_log_info(vchiq_arm_log_level,\r\n"Inserting extra MESSAGE_AVAILABLE");\r\nDEBUG_TRACE(SERVICE_CALLBACK_LINE);\r\nstatus = add_completion(instance, reason,\r\nNULL, user_service, bulk_userdata);\r\nif (status != VCHIQ_SUCCESS) {\r\nDEBUG_TRACE(SERVICE_CALLBACK_LINE);\r\nreturn status;\r\n}\r\n}\r\nDEBUG_TRACE(SERVICE_CALLBACK_LINE);\r\nif (down_interruptible(&user_service->remove_event)\r\n!= 0) {\r\nvchiq_log_info(vchiq_arm_log_level,\r\n"service_callback interrupted");\r\nDEBUG_TRACE(SERVICE_CALLBACK_LINE);\r\nreturn VCHIQ_RETRY;\r\n} else if (instance->closing) {\r\nvchiq_log_info(vchiq_arm_log_level,\r\n"service_callback closing");\r\nDEBUG_TRACE(SERVICE_CALLBACK_LINE);\r\nreturn VCHIQ_ERROR;\r\n}\r\nDEBUG_TRACE(SERVICE_CALLBACK_LINE);\r\nspin_lock(&msg_queue_spinlock);\r\n}\r\nuser_service->msg_queue[user_service->msg_insert &\r\n(MSG_QUEUE_SIZE - 1)] = header;\r\nuser_service->msg_insert++;\r\nif (((user_service->message_available_pos -\r\ninstance->completion_remove) >= 0) ||\r\nuser_service->dequeue_pending) {\r\nuser_service->dequeue_pending = 0;\r\nskip_completion = true;\r\n}\r\nspin_unlock(&msg_queue_spinlock);\r\nup(&user_service->insert_event);\r\nheader = NULL;\r\n}\r\nDEBUG_TRACE(SERVICE_CALLBACK_LINE);\r\nif (skip_completion)\r\nreturn VCHIQ_SUCCESS;\r\nreturn add_completion(instance, reason, header, user_service,\r\nbulk_userdata);\r\n}\r\nstatic void\r\nuser_service_free(void *userdata)\r\n{\r\nkfree(userdata);\r\n}\r\nstatic void close_delivered(USER_SERVICE_T *user_service)\r\n{\r\nvchiq_log_info(vchiq_arm_log_level,\r\n"close_delivered(handle=%x)",\r\nuser_service->service->handle);\r\nif (user_service->close_pending) {\r\nunlock_service(user_service->service);\r\nup(&user_service->close_event);\r\nuser_service->close_pending = 0;\r\n}\r\n}\r\nstatic ssize_t\r\nvchiq_ioc_copy_element_data(\r\nvoid *context,\r\nvoid *dest,\r\nsize_t offset,\r\nsize_t maxsize)\r\n{\r\nlong res;\r\nsize_t bytes_this_round;\r\nstruct vchiq_io_copy_callback_context *copy_context =\r\n(struct vchiq_io_copy_callback_context *)context;\r\nif (offset != copy_context->current_offset)\r\nreturn 0;\r\nif (!copy_context->elements_to_go)\r\nreturn 0;\r\nwhile (1) {\r\nbytes_this_round = min(copy_context->current_element->size -\r\ncopy_context->current_element_offset,\r\nmaxsize);\r\nif (bytes_this_round)\r\nbreak;\r\ncopy_context->elements_to_go--;\r\ncopy_context->current_element++;\r\ncopy_context->current_element_offset = 0;\r\nif (!copy_context->elements_to_go)\r\nreturn 0;\r\n}\r\nres = copy_from_user(dest,\r\ncopy_context->current_element->data +\r\ncopy_context->current_element_offset,\r\nbytes_this_round);\r\nif (res != 0)\r\nreturn -EFAULT;\r\ncopy_context->current_element_offset += bytes_this_round;\r\ncopy_context->current_offset += bytes_this_round;\r\nif (copy_context->current_element_offset ==\r\ncopy_context->current_element->size) {\r\ncopy_context->elements_to_go--;\r\ncopy_context->current_element++;\r\ncopy_context->current_element_offset = 0;\r\n}\r\nreturn bytes_this_round;\r\n}\r\nstatic VCHIQ_STATUS_T\r\nvchiq_ioc_queue_message(VCHIQ_SERVICE_HANDLE_T handle,\r\nstruct vchiq_element *elements,\r\nunsigned long count)\r\n{\r\nstruct vchiq_io_copy_callback_context context;\r\nunsigned long i;\r\nsize_t total_size = 0;\r\ncontext.current_element = elements;\r\ncontext.current_element_offset = 0;\r\ncontext.elements_to_go = count;\r\ncontext.current_offset = 0;\r\nfor (i = 0; i < count; i++) {\r\nif (!elements[i].data && elements[i].size != 0)\r\nreturn -EFAULT;\r\ntotal_size += elements[i].size;\r\n}\r\nreturn vchiq_queue_message(handle, vchiq_ioc_copy_element_data,\r\n&context, total_size);\r\n}\r\nstatic long\r\nvchiq_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nVCHIQ_INSTANCE_T instance = file->private_data;\r\nVCHIQ_STATUS_T status = VCHIQ_SUCCESS;\r\nVCHIQ_SERVICE_T *service = NULL;\r\nlong ret = 0;\r\nint i, rc;\r\nDEBUG_INITIALISE(g_state.local)\r\nvchiq_log_trace(vchiq_arm_log_level,\r\n"vchiq_ioctl - instance %pK, cmd %s, arg %lx",\r\ninstance,\r\n((_IOC_TYPE(cmd) == VCHIQ_IOC_MAGIC) &&\r\n(_IOC_NR(cmd) <= VCHIQ_IOC_MAX)) ?\r\nioctl_names[_IOC_NR(cmd)] : "<invalid>", arg);\r\nswitch (cmd) {\r\ncase VCHIQ_IOC_SHUTDOWN:\r\nif (!instance->connected)\r\nbreak;\r\ni = 0;\r\nwhile ((service = next_service_by_instance(instance->state,\r\ninstance, &i)) != NULL) {\r\nstatus = vchiq_remove_service(service->handle);\r\nunlock_service(service);\r\nif (status != VCHIQ_SUCCESS)\r\nbreak;\r\n}\r\nservice = NULL;\r\nif (status == VCHIQ_SUCCESS) {\r\ninstance->closing = 1;\r\nup(&instance->insert_event);\r\n}\r\nbreak;\r\ncase VCHIQ_IOC_CONNECT:\r\nif (instance->connected) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nrc = mutex_lock_killable(&instance->state->mutex);\r\nif (rc != 0) {\r\nvchiq_log_error(vchiq_arm_log_level,\r\n"vchiq: connect: could not lock mutex for "\r\n"state %d: %d",\r\ninstance->state->id, rc);\r\nret = -EINTR;\r\nbreak;\r\n}\r\nstatus = vchiq_connect_internal(instance->state, instance);\r\nmutex_unlock(&instance->state->mutex);\r\nif (status == VCHIQ_SUCCESS)\r\ninstance->connected = 1;\r\nelse\r\nvchiq_log_error(vchiq_arm_log_level,\r\n"vchiq: could not connect: %d", status);\r\nbreak;\r\ncase VCHIQ_IOC_CREATE_SERVICE: {\r\nVCHIQ_CREATE_SERVICE_T args;\r\nUSER_SERVICE_T *user_service = NULL;\r\nvoid *userdata;\r\nint srvstate;\r\nif (copy_from_user\r\n(&args, (const void __user *)arg,\r\nsizeof(args)) != 0) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nuser_service = kmalloc(sizeof(USER_SERVICE_T), GFP_KERNEL);\r\nif (!user_service) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nif (args.is_open) {\r\nif (!instance->connected) {\r\nret = -ENOTCONN;\r\nkfree(user_service);\r\nbreak;\r\n}\r\nsrvstate = VCHIQ_SRVSTATE_OPENING;\r\n} else {\r\nsrvstate =\r\ninstance->connected ?\r\nVCHIQ_SRVSTATE_LISTENING :\r\nVCHIQ_SRVSTATE_HIDDEN;\r\n}\r\nuserdata = args.params.userdata;\r\nargs.params.callback = service_callback;\r\nargs.params.userdata = user_service;\r\nservice = vchiq_add_service_internal(\r\ninstance->state,\r\n&args.params, srvstate,\r\ninstance, user_service_free);\r\nif (service != NULL) {\r\nuser_service->service = service;\r\nuser_service->userdata = userdata;\r\nuser_service->instance = instance;\r\nuser_service->is_vchi = (args.is_vchi != 0);\r\nuser_service->dequeue_pending = 0;\r\nuser_service->close_pending = 0;\r\nuser_service->message_available_pos =\r\ninstance->completion_remove - 1;\r\nuser_service->msg_insert = 0;\r\nuser_service->msg_remove = 0;\r\nsema_init(&user_service->insert_event, 0);\r\nsema_init(&user_service->remove_event, 0);\r\nsema_init(&user_service->close_event, 0);\r\nif (args.is_open) {\r\nstatus = vchiq_open_service_internal\r\n(service, instance->pid);\r\nif (status != VCHIQ_SUCCESS) {\r\nvchiq_remove_service(service->handle);\r\nservice = NULL;\r\nret = (status == VCHIQ_RETRY) ?\r\n-EINTR : -EIO;\r\nbreak;\r\n}\r\n}\r\nif (copy_to_user((void __user *)\r\n&(((VCHIQ_CREATE_SERVICE_T __user *)\r\narg)->handle),\r\n(const void *)&service->handle,\r\nsizeof(service->handle)) != 0) {\r\nret = -EFAULT;\r\nvchiq_remove_service(service->handle);\r\n}\r\nservice = NULL;\r\n} else {\r\nret = -EEXIST;\r\nkfree(user_service);\r\n}\r\n} break;\r\ncase VCHIQ_IOC_CLOSE_SERVICE: {\r\nVCHIQ_SERVICE_HANDLE_T handle = (VCHIQ_SERVICE_HANDLE_T)arg;\r\nservice = find_service_for_instance(instance, handle);\r\nif (service != NULL) {\r\nUSER_SERVICE_T *user_service =\r\n(USER_SERVICE_T *)service->base.userdata;\r\nif (!user_service->close_pending) {\r\nstatus = vchiq_close_service(service->handle);\r\nif (status != VCHIQ_SUCCESS)\r\nbreak;\r\n}\r\nif (user_service->close_pending &&\r\ndown_interruptible(&user_service->close_event))\r\nstatus = VCHIQ_RETRY;\r\n}\r\nelse\r\nret = -EINVAL;\r\n} break;\r\ncase VCHIQ_IOC_REMOVE_SERVICE: {\r\nVCHIQ_SERVICE_HANDLE_T handle = (VCHIQ_SERVICE_HANDLE_T)arg;\r\nservice = find_service_for_instance(instance, handle);\r\nif (service != NULL) {\r\nUSER_SERVICE_T *user_service =\r\n(USER_SERVICE_T *)service->base.userdata;\r\nif (!user_service->close_pending) {\r\nstatus = vchiq_remove_service(service->handle);\r\nif (status != VCHIQ_SUCCESS)\r\nbreak;\r\n}\r\nif (user_service->close_pending &&\r\ndown_interruptible(&user_service->close_event))\r\nstatus = VCHIQ_RETRY;\r\n}\r\nelse\r\nret = -EINVAL;\r\n} break;\r\ncase VCHIQ_IOC_USE_SERVICE:\r\ncase VCHIQ_IOC_RELEASE_SERVICE: {\r\nVCHIQ_SERVICE_HANDLE_T handle = (VCHIQ_SERVICE_HANDLE_T)arg;\r\nservice = find_service_for_instance(instance, handle);\r\nif (service != NULL) {\r\nstatus = (cmd == VCHIQ_IOC_USE_SERVICE) ?\r\nvchiq_use_service_internal(service) :\r\nvchiq_release_service_internal(service);\r\nif (status != VCHIQ_SUCCESS) {\r\nvchiq_log_error(vchiq_susp_log_level,\r\n"%s: cmd %s returned error %d for "\r\n"service %c%c%c%c:%03d",\r\n__func__,\r\n(cmd == VCHIQ_IOC_USE_SERVICE) ?\r\n"VCHIQ_IOC_USE_SERVICE" :\r\n"VCHIQ_IOC_RELEASE_SERVICE",\r\nstatus,\r\nVCHIQ_FOURCC_AS_4CHARS(\r\nservice->base.fourcc),\r\nservice->client_id);\r\nret = -EINVAL;\r\n}\r\n} else\r\nret = -EINVAL;\r\n} break;\r\ncase VCHIQ_IOC_QUEUE_MESSAGE: {\r\nVCHIQ_QUEUE_MESSAGE_T args;\r\nif (copy_from_user\r\n(&args, (const void __user *)arg,\r\nsizeof(args)) != 0) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nservice = find_service_for_instance(instance, args.handle);\r\nif ((service != NULL) && (args.count <= MAX_ELEMENTS)) {\r\nstruct vchiq_element elements[MAX_ELEMENTS];\r\nif (copy_from_user(elements, args.elements,\r\nargs.count * sizeof(struct vchiq_element)) == 0)\r\nstatus = vchiq_ioc_queue_message\r\n(args.handle,\r\nelements, args.count);\r\nelse\r\nret = -EFAULT;\r\n} else {\r\nret = -EINVAL;\r\n}\r\n} break;\r\ncase VCHIQ_IOC_QUEUE_BULK_TRANSMIT:\r\ncase VCHIQ_IOC_QUEUE_BULK_RECEIVE: {\r\nVCHIQ_QUEUE_BULK_TRANSFER_T args;\r\nstruct bulk_waiter_node *waiter = NULL;\r\nVCHIQ_BULK_DIR_T dir =\r\n(cmd == VCHIQ_IOC_QUEUE_BULK_TRANSMIT) ?\r\nVCHIQ_BULK_TRANSMIT : VCHIQ_BULK_RECEIVE;\r\nif (copy_from_user\r\n(&args, (const void __user *)arg,\r\nsizeof(args)) != 0) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nservice = find_service_for_instance(instance, args.handle);\r\nif (!service) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (args.mode == VCHIQ_BULK_MODE_BLOCKING) {\r\nwaiter = kzalloc(sizeof(struct bulk_waiter_node),\r\nGFP_KERNEL);\r\nif (!waiter) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nargs.userdata = &waiter->bulk_waiter;\r\n} else if (args.mode == VCHIQ_BULK_MODE_WAITING) {\r\nstruct list_head *pos;\r\nmutex_lock(&instance->bulk_waiter_list_mutex);\r\nlist_for_each(pos, &instance->bulk_waiter_list) {\r\nif (list_entry(pos, struct bulk_waiter_node,\r\nlist)->pid == current->pid) {\r\nwaiter = list_entry(pos,\r\nstruct bulk_waiter_node,\r\nlist);\r\nlist_del(pos);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&instance->bulk_waiter_list_mutex);\r\nif (!waiter) {\r\nvchiq_log_error(vchiq_arm_log_level,\r\n"no bulk_waiter found for pid %d",\r\ncurrent->pid);\r\nret = -ESRCH;\r\nbreak;\r\n}\r\nvchiq_log_info(vchiq_arm_log_level,\r\n"found bulk_waiter %pK for pid %d", waiter,\r\ncurrent->pid);\r\nargs.userdata = &waiter->bulk_waiter;\r\n}\r\nstatus = vchiq_bulk_transfer\r\n(args.handle,\r\nVCHI_MEM_HANDLE_INVALID,\r\nargs.data, args.size,\r\nargs.userdata, args.mode,\r\ndir);\r\nif (!waiter)\r\nbreak;\r\nif ((status != VCHIQ_RETRY) || fatal_signal_pending(current) ||\r\n!waiter->bulk_waiter.bulk) {\r\nif (waiter->bulk_waiter.bulk) {\r\nspin_lock(&bulk_waiter_spinlock);\r\nwaiter->bulk_waiter.bulk->userdata = NULL;\r\nspin_unlock(&bulk_waiter_spinlock);\r\n}\r\nkfree(waiter);\r\n} else {\r\nconst VCHIQ_BULK_MODE_T mode_waiting =\r\nVCHIQ_BULK_MODE_WAITING;\r\nwaiter->pid = current->pid;\r\nmutex_lock(&instance->bulk_waiter_list_mutex);\r\nlist_add(&waiter->list, &instance->bulk_waiter_list);\r\nmutex_unlock(&instance->bulk_waiter_list_mutex);\r\nvchiq_log_info(vchiq_arm_log_level,\r\n"saved bulk_waiter %pK for pid %d",\r\nwaiter, current->pid);\r\nif (copy_to_user((void __user *)\r\n&(((VCHIQ_QUEUE_BULK_TRANSFER_T __user *)\r\narg)->mode),\r\n(const void *)&mode_waiting,\r\nsizeof(mode_waiting)) != 0)\r\nret = -EFAULT;\r\n}\r\n} break;\r\ncase VCHIQ_IOC_AWAIT_COMPLETION: {\r\nVCHIQ_AWAIT_COMPLETION_T args;\r\nDEBUG_TRACE(AWAIT_COMPLETION_LINE);\r\nif (!instance->connected) {\r\nret = -ENOTCONN;\r\nbreak;\r\n}\r\nif (copy_from_user(&args, (const void __user *)arg,\r\nsizeof(args)) != 0) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nmutex_lock(&instance->completion_mutex);\r\nDEBUG_TRACE(AWAIT_COMPLETION_LINE);\r\nwhile ((instance->completion_remove ==\r\ninstance->completion_insert)\r\n&& !instance->closing) {\r\nint rc;\r\nDEBUG_TRACE(AWAIT_COMPLETION_LINE);\r\nmutex_unlock(&instance->completion_mutex);\r\nrc = down_interruptible(&instance->insert_event);\r\nmutex_lock(&instance->completion_mutex);\r\nif (rc != 0) {\r\nDEBUG_TRACE(AWAIT_COMPLETION_LINE);\r\nvchiq_log_info(vchiq_arm_log_level,\r\n"AWAIT_COMPLETION interrupted");\r\nret = -EINTR;\r\nbreak;\r\n}\r\n}\r\nDEBUG_TRACE(AWAIT_COMPLETION_LINE);\r\nif (ret == 0) {\r\nint msgbufcount = args.msgbufcount;\r\nint remove = instance->completion_remove;\r\nfor (ret = 0; ret < args.count; ret++) {\r\nVCHIQ_COMPLETION_DATA_T *completion;\r\nVCHIQ_SERVICE_T *service;\r\nUSER_SERVICE_T *user_service;\r\nVCHIQ_HEADER_T *header;\r\nif (remove == instance->completion_insert)\r\nbreak;\r\ncompletion = &instance->completions[\r\nremove & (MAX_COMPLETIONS - 1)];\r\nrmb();\r\nservice = completion->service_userdata;\r\nuser_service = service->base.userdata;\r\ncompletion->service_userdata =\r\nuser_service->userdata;\r\nheader = completion->header;\r\nif (header) {\r\nvoid __user *msgbuf;\r\nint msglen;\r\nmsglen = header->size +\r\nsizeof(VCHIQ_HEADER_T);\r\nif (args.msgbufsize < msglen) {\r\nvchiq_log_error(\r\nvchiq_arm_log_level,\r\n"header %pK: msgbufsize %x < msglen %x",\r\nheader, args.msgbufsize,\r\nmsglen);\r\nWARN(1, "invalid message "\r\n"size\n");\r\nif (ret == 0)\r\nret = -EMSGSIZE;\r\nbreak;\r\n}\r\nif (msgbufcount <= 0)\r\nbreak;\r\nmsgbufcount--;\r\nif (copy_from_user(&msgbuf,\r\n(const void __user *)\r\n&args.msgbufs[msgbufcount],\r\nsizeof(msgbuf)) != 0) {\r\nif (ret == 0)\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (copy_to_user(msgbuf, header,\r\nmsglen) != 0) {\r\nif (ret == 0)\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nvchiq_release_message(service->handle,\r\nheader);\r\ncompletion->header = msgbuf;\r\n}\r\nif ((completion->reason ==\r\nVCHIQ_SERVICE_CLOSED) &&\r\n!instance->use_close_delivered)\r\nunlock_service(service);\r\nif (copy_to_user((void __user *)(\r\n(size_t)args.buf +\r\nret * sizeof(VCHIQ_COMPLETION_DATA_T)),\r\ncompletion,\r\nsizeof(VCHIQ_COMPLETION_DATA_T)) != 0) {\r\nif (ret == 0)\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nmb();\r\nremove++;\r\ninstance->completion_remove = remove;\r\n}\r\nif (msgbufcount != args.msgbufcount) {\r\nif (copy_to_user((void __user *)\r\n&((VCHIQ_AWAIT_COMPLETION_T *)arg)->\r\nmsgbufcount,\r\n&msgbufcount,\r\nsizeof(msgbufcount)) != 0) {\r\nret = -EFAULT;\r\n}\r\n}\r\n}\r\nif (ret != 0)\r\nup(&instance->remove_event);\r\nmutex_unlock(&instance->completion_mutex);\r\nDEBUG_TRACE(AWAIT_COMPLETION_LINE);\r\n} break;\r\ncase VCHIQ_IOC_DEQUEUE_MESSAGE: {\r\nVCHIQ_DEQUEUE_MESSAGE_T args;\r\nUSER_SERVICE_T *user_service;\r\nVCHIQ_HEADER_T *header;\r\nDEBUG_TRACE(DEQUEUE_MESSAGE_LINE);\r\nif (copy_from_user\r\n(&args, (const void __user *)arg,\r\nsizeof(args)) != 0) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nservice = find_service_for_instance(instance, args.handle);\r\nif (!service) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nuser_service = (USER_SERVICE_T *)service->base.userdata;\r\nif (user_service->is_vchi == 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nspin_lock(&msg_queue_spinlock);\r\nif (user_service->msg_remove == user_service->msg_insert) {\r\nif (!args.blocking) {\r\nspin_unlock(&msg_queue_spinlock);\r\nDEBUG_TRACE(DEQUEUE_MESSAGE_LINE);\r\nret = -EWOULDBLOCK;\r\nbreak;\r\n}\r\nuser_service->dequeue_pending = 1;\r\ndo {\r\nspin_unlock(&msg_queue_spinlock);\r\nDEBUG_TRACE(DEQUEUE_MESSAGE_LINE);\r\nif (down_interruptible(\r\n&user_service->insert_event) != 0) {\r\nvchiq_log_info(vchiq_arm_log_level,\r\n"DEQUEUE_MESSAGE interrupted");\r\nret = -EINTR;\r\nbreak;\r\n}\r\nspin_lock(&msg_queue_spinlock);\r\n} while (user_service->msg_remove ==\r\nuser_service->msg_insert);\r\nif (ret)\r\nbreak;\r\n}\r\nBUG_ON((int)(user_service->msg_insert -\r\nuser_service->msg_remove) < 0);\r\nheader = user_service->msg_queue[user_service->msg_remove &\r\n(MSG_QUEUE_SIZE - 1)];\r\nuser_service->msg_remove++;\r\nspin_unlock(&msg_queue_spinlock);\r\nup(&user_service->remove_event);\r\nif (header == NULL)\r\nret = -ENOTCONN;\r\nelse if (header->size <= args.bufsize) {\r\nif ((args.buf == NULL) ||\r\n(copy_to_user((void __user *)args.buf,\r\nheader->data,\r\nheader->size) == 0)) {\r\nret = header->size;\r\nvchiq_release_message(\r\nservice->handle,\r\nheader);\r\n} else\r\nret = -EFAULT;\r\n} else {\r\nvchiq_log_error(vchiq_arm_log_level,\r\n"header %pK: bufsize %x < size %x",\r\nheader, args.bufsize, header->size);\r\nWARN(1, "invalid size\n");\r\nret = -EMSGSIZE;\r\n}\r\nDEBUG_TRACE(DEQUEUE_MESSAGE_LINE);\r\n} break;\r\ncase VCHIQ_IOC_GET_CLIENT_ID: {\r\nVCHIQ_SERVICE_HANDLE_T handle = (VCHIQ_SERVICE_HANDLE_T)arg;\r\nret = vchiq_get_client_id(handle);\r\n} break;\r\ncase VCHIQ_IOC_GET_CONFIG: {\r\nVCHIQ_GET_CONFIG_T args;\r\nVCHIQ_CONFIG_T config;\r\nif (copy_from_user(&args, (const void __user *)arg,\r\nsizeof(args)) != 0) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (args.config_size > sizeof(config)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nstatus = vchiq_get_config(instance, args.config_size, &config);\r\nif (status == VCHIQ_SUCCESS) {\r\nif (copy_to_user((void __user *)args.pconfig,\r\n&config, args.config_size) != 0) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\n}\r\n} break;\r\ncase VCHIQ_IOC_SET_SERVICE_OPTION: {\r\nVCHIQ_SET_SERVICE_OPTION_T args;\r\nif (copy_from_user(\r\n&args, (const void __user *)arg,\r\nsizeof(args)) != 0) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nservice = find_service_for_instance(instance, args.handle);\r\nif (!service) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nstatus = vchiq_set_service_option(\r\nargs.handle, args.option, args.value);\r\n} break;\r\n#if defined(CONFIG_BCM2835_VCHIQ_SUPPORT_MEMDUMP)\r\ncase VCHIQ_IOC_DUMP_PHYS_MEM: {\r\nVCHIQ_DUMP_MEM_T args;\r\nif (copy_from_user\r\n(&args, (const void __user *)arg,\r\nsizeof(args)) != 0) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\ndump_phys_mem(args.virt_addr, args.num_bytes);\r\n} break;\r\n#endif\r\ncase VCHIQ_IOC_LIB_VERSION: {\r\nunsigned int lib_version = (unsigned int)arg;\r\nif (lib_version < VCHIQ_VERSION_MIN)\r\nret = -EINVAL;\r\nelse if (lib_version >= VCHIQ_VERSION_CLOSE_DELIVERED)\r\ninstance->use_close_delivered = 1;\r\n} break;\r\ncase VCHIQ_IOC_CLOSE_DELIVERED: {\r\nVCHIQ_SERVICE_HANDLE_T handle = (VCHIQ_SERVICE_HANDLE_T)arg;\r\nservice = find_closed_service_for_instance(instance, handle);\r\nif (service != NULL) {\r\nUSER_SERVICE_T *user_service =\r\n(USER_SERVICE_T *)service->base.userdata;\r\nclose_delivered(user_service);\r\n}\r\nelse\r\nret = -EINVAL;\r\n} break;\r\ndefault:\r\nret = -ENOTTY;\r\nbreak;\r\n}\r\nif (service)\r\nunlock_service(service);\r\nif (ret == 0) {\r\nif (status == VCHIQ_ERROR)\r\nret = -EIO;\r\nelse if (status == VCHIQ_RETRY)\r\nret = -EINTR;\r\n}\r\nif ((status == VCHIQ_SUCCESS) && (ret < 0) && (ret != -EINTR) &&\r\n(ret != -EWOULDBLOCK))\r\nvchiq_log_info(vchiq_arm_log_level,\r\n" ioctl instance %lx, cmd %s -> status %d, %ld",\r\n(unsigned long)instance,\r\n(_IOC_NR(cmd) <= VCHIQ_IOC_MAX) ?\r\nioctl_names[_IOC_NR(cmd)] :\r\n"<invalid>",\r\nstatus, ret);\r\nelse\r\nvchiq_log_trace(vchiq_arm_log_level,\r\n" ioctl instance %lx, cmd %s -> status %d, %ld",\r\n(unsigned long)instance,\r\n(_IOC_NR(cmd) <= VCHIQ_IOC_MAX) ?\r\nioctl_names[_IOC_NR(cmd)] :\r\n"<invalid>",\r\nstatus, ret);\r\nreturn ret;\r\n}\r\nstatic long\r\nvchiq_compat_ioctl_create_service(\r\nstruct file *file,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nVCHIQ_CREATE_SERVICE_T __user *args;\r\nstruct vchiq_create_service32 __user *ptrargs32 =\r\n(struct vchiq_create_service32 __user *)arg;\r\nstruct vchiq_create_service32 args32;\r\nlong ret;\r\nargs = compat_alloc_user_space(sizeof(*args));\r\nif (!args)\r\nreturn -EFAULT;\r\nif (copy_from_user(&args32,\r\n(struct vchiq_create_service32 __user *)arg,\r\nsizeof(args32)))\r\nreturn -EFAULT;\r\nif (put_user(args32.params.fourcc, &args->params.fourcc) ||\r\nput_user(compat_ptr(args32.params.callback),\r\n&args->params.callback) ||\r\nput_user(compat_ptr(args32.params.userdata),\r\n&args->params.userdata) ||\r\nput_user(args32.params.version, &args->params.version) ||\r\nput_user(args32.params.version_min,\r\n&args->params.version_min) ||\r\nput_user(args32.is_open, &args->is_open) ||\r\nput_user(args32.is_vchi, &args->is_vchi) ||\r\nput_user(args32.handle, &args->handle))\r\nreturn -EFAULT;\r\nret = vchiq_ioctl(file, VCHIQ_IOC_CREATE_SERVICE, (unsigned long)args);\r\nif (ret < 0)\r\nreturn ret;\r\nif (get_user(args32.handle, &args->handle))\r\nreturn -EFAULT;\r\nif (copy_to_user(&ptrargs32->handle,\r\n&args32.handle,\r\nsizeof(args32.handle)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long\r\nvchiq_compat_ioctl_queue_message(struct file *file,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nVCHIQ_QUEUE_MESSAGE_T *args;\r\nstruct vchiq_element *elements;\r\nstruct vchiq_queue_message32 args32;\r\nunsigned int count;\r\nif (copy_from_user(&args32,\r\n(struct vchiq_queue_message32 __user *)arg,\r\nsizeof(args32)))\r\nreturn -EFAULT;\r\nargs = compat_alloc_user_space(sizeof(*args) +\r\n(sizeof(*elements) * MAX_ELEMENTS));\r\nif (!args)\r\nreturn -EFAULT;\r\nif (put_user(args32.handle, &args->handle) ||\r\nput_user(args32.count, &args->count) ||\r\nput_user(compat_ptr(args32.elements), &args->elements))\r\nreturn -EFAULT;\r\nif (args32.count > MAX_ELEMENTS)\r\nreturn -EINVAL;\r\nif (args32.elements && args32.count) {\r\nstruct vchiq_element32 tempelement32[MAX_ELEMENTS];\r\nelements = (struct vchiq_element __user *)(args + 1);\r\nif (copy_from_user(&tempelement32,\r\ncompat_ptr(args32.elements),\r\nsizeof(tempelement32)))\r\nreturn -EFAULT;\r\nfor (count = 0; count < args32.count; count++) {\r\nif (put_user(compat_ptr(tempelement32[count].data),\r\n&elements[count].data) ||\r\nput_user(tempelement32[count].size,\r\n&elements[count].size))\r\nreturn -EFAULT;\r\n}\r\nif (put_user(elements, &args->elements))\r\nreturn -EFAULT;\r\n}\r\nreturn vchiq_ioctl(file, VCHIQ_IOC_QUEUE_MESSAGE, (unsigned long)args);\r\n}\r\nstatic long\r\nvchiq_compat_ioctl_queue_bulk(struct file *file,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nVCHIQ_QUEUE_BULK_TRANSFER_T *args;\r\nstruct vchiq_queue_bulk_transfer32 args32;\r\nstruct vchiq_queue_bulk_transfer32 *ptrargs32 =\r\n(struct vchiq_queue_bulk_transfer32 *)arg;\r\nlong ret;\r\nargs = compat_alloc_user_space(sizeof(*args));\r\nif (!args)\r\nreturn -EFAULT;\r\nif (copy_from_user(&args32,\r\n(struct vchiq_queue_bulk_transfer32 __user *)arg,\r\nsizeof(args32)))\r\nreturn -EFAULT;\r\nif (put_user(args32.handle, &args->handle) ||\r\nput_user(compat_ptr(args32.data), &args->data) ||\r\nput_user(args32.size, &args->size) ||\r\nput_user(compat_ptr(args32.userdata), &args->userdata) ||\r\nput_user(args32.mode, &args->mode))\r\nreturn -EFAULT;\r\nif (cmd == VCHIQ_IOC_QUEUE_BULK_TRANSMIT32)\r\ncmd = VCHIQ_IOC_QUEUE_BULK_TRANSMIT;\r\nelse\r\ncmd = VCHIQ_IOC_QUEUE_BULK_RECEIVE;\r\nret = vchiq_ioctl(file, cmd, (unsigned long)args);\r\nif (ret < 0)\r\nreturn ret;\r\nif (get_user(args32.mode, &args->mode))\r\nreturn -EFAULT;\r\nif (copy_to_user(&ptrargs32->mode,\r\n&args32.mode,\r\nsizeof(args32.mode)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long\r\nvchiq_compat_ioctl_await_completion(struct file *file,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nVCHIQ_AWAIT_COMPLETION_T *args;\r\nVCHIQ_COMPLETION_DATA_T *completion;\r\nVCHIQ_COMPLETION_DATA_T completiontemp;\r\nstruct vchiq_await_completion32 args32;\r\nstruct vchiq_completion_data32 completion32;\r\nunsigned int *msgbufcount32;\r\ncompat_uptr_t msgbuf32;\r\nvoid *msgbuf;\r\nvoid **msgbufptr;\r\nlong ret;\r\nargs = compat_alloc_user_space(sizeof(*args) +\r\nsizeof(*completion) +\r\nsizeof(*msgbufptr));\r\nif (!args)\r\nreturn -EFAULT;\r\ncompletion = (VCHIQ_COMPLETION_DATA_T *)(args + 1);\r\nmsgbufptr = (void __user **)(completion + 1);\r\nif (copy_from_user(&args32,\r\n(struct vchiq_completion_data32 *)arg,\r\nsizeof(args32)))\r\nreturn -EFAULT;\r\nif (put_user(args32.count, &args->count) ||\r\nput_user(compat_ptr(args32.buf), &args->buf) ||\r\nput_user(args32.msgbufsize, &args->msgbufsize) ||\r\nput_user(args32.msgbufcount, &args->msgbufcount) ||\r\nput_user(compat_ptr(args32.msgbufs), &args->msgbufs))\r\nreturn -EFAULT;\r\nif (!args32.count || !args32.buf || !args32.msgbufcount)\r\nreturn vchiq_ioctl(file,\r\nVCHIQ_IOC_AWAIT_COMPLETION,\r\n(unsigned long)args);\r\nif (copy_from_user(&msgbuf32,\r\ncompat_ptr(args32.msgbufs) +\r\n(sizeof(compat_uptr_t) *\r\n(args32.msgbufcount - 1)),\r\nsizeof(msgbuf32)))\r\nreturn -EFAULT;\r\nmsgbuf = compat_ptr(msgbuf32);\r\nif (copy_to_user(msgbufptr,\r\n&msgbuf,\r\nsizeof(msgbuf)))\r\nreturn -EFAULT;\r\nif (copy_to_user(&args->msgbufs,\r\n&msgbufptr,\r\nsizeof(msgbufptr)))\r\nreturn -EFAULT;\r\nif (put_user(1U, &args->count) ||\r\nput_user(completion, &args->buf) ||\r\nput_user(1U, &args->msgbufcount))\r\nreturn -EFAULT;\r\nret = vchiq_ioctl(file,\r\nVCHIQ_IOC_AWAIT_COMPLETION,\r\n(unsigned long)args);\r\nif (ret <= 0)\r\nreturn ret;\r\nif (copy_from_user(&completiontemp, completion, sizeof(*completion)))\r\nreturn -EFAULT;\r\ncompletion32.reason = completiontemp.reason;\r\ncompletion32.header = ptr_to_compat(completiontemp.header);\r\ncompletion32.service_userdata =\r\nptr_to_compat(completiontemp.service_userdata);\r\ncompletion32.bulk_userdata =\r\nptr_to_compat(completiontemp.bulk_userdata);\r\nif (copy_to_user(compat_ptr(args32.buf),\r\n&completion32,\r\nsizeof(completion32)))\r\nreturn -EFAULT;\r\nargs32.msgbufcount--;\r\nmsgbufcount32 =\r\n&((struct vchiq_await_completion32 __user *)arg)->msgbufcount;\r\nif (copy_to_user(msgbufcount32,\r\n&args32.msgbufcount,\r\nsizeof(args32.msgbufcount)))\r\nreturn -EFAULT;\r\nreturn 1;\r\n}\r\nstatic long\r\nvchiq_compat_ioctl_dequeue_message(struct file *file,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nVCHIQ_DEQUEUE_MESSAGE_T *args;\r\nstruct vchiq_dequeue_message32 args32;\r\nargs = compat_alloc_user_space(sizeof(*args));\r\nif (!args)\r\nreturn -EFAULT;\r\nif (copy_from_user(&args32,\r\n(struct vchiq_dequeue_message32 *)arg,\r\nsizeof(args32)))\r\nreturn -EFAULT;\r\nif (put_user(args32.handle, &args->handle) ||\r\nput_user(args32.blocking, &args->blocking) ||\r\nput_user(args32.bufsize, &args->bufsize) ||\r\nput_user(compat_ptr(args32.buf), &args->buf))\r\nreturn -EFAULT;\r\nreturn vchiq_ioctl(file, VCHIQ_IOC_DEQUEUE_MESSAGE,\r\n(unsigned long)args);\r\n}\r\nstatic long\r\nvchiq_compat_ioctl_get_config(struct file *file,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nVCHIQ_GET_CONFIG_T *args;\r\nstruct vchiq_get_config32 args32;\r\nargs = compat_alloc_user_space(sizeof(*args));\r\nif (!args)\r\nreturn -EFAULT;\r\nif (copy_from_user(&args32,\r\n(struct vchiq_get_config32 *)arg,\r\nsizeof(args32)))\r\nreturn -EFAULT;\r\nif (put_user(args32.config_size, &args->config_size) ||\r\nput_user(compat_ptr(args32.pconfig), &args->pconfig))\r\nreturn -EFAULT;\r\nreturn vchiq_ioctl(file, VCHIQ_IOC_GET_CONFIG, (unsigned long)args);\r\n}\r\nstatic long\r\nvchiq_compat_ioctl_dump_phys_mem(struct file *file,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nVCHIQ_DUMP_MEM_T *args;\r\nstruct vchiq_dump_mem32 args32;\r\nargs = compat_alloc_user_space(sizeof(*args));\r\nif (!args)\r\nreturn -EFAULT;\r\nif (copy_from_user(&args32,\r\n(struct vchiq_dump_mem32 *)arg,\r\nsizeof(args32)))\r\nreturn -EFAULT;\r\nif (put_user(compat_ptr(args32.virt_addr), &args->virt_addr) ||\r\nput_user(args32.num_bytes, &args->num_bytes))\r\nreturn -EFAULT;\r\nreturn vchiq_ioctl(file, VCHIQ_IOC_DUMP_PHYS_MEM, (unsigned long)args);\r\n}\r\nstatic long\r\nvchiq_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase VCHIQ_IOC_CREATE_SERVICE32:\r\nreturn vchiq_compat_ioctl_create_service(file, cmd, arg);\r\ncase VCHIQ_IOC_QUEUE_MESSAGE32:\r\nreturn vchiq_compat_ioctl_queue_message(file, cmd, arg);\r\ncase VCHIQ_IOC_QUEUE_BULK_TRANSMIT32:\r\ncase VCHIQ_IOC_QUEUE_BULK_RECEIVE32:\r\nreturn vchiq_compat_ioctl_queue_bulk(file, cmd, arg);\r\ncase VCHIQ_IOC_AWAIT_COMPLETION32:\r\nreturn vchiq_compat_ioctl_await_completion(file, cmd, arg);\r\ncase VCHIQ_IOC_DEQUEUE_MESSAGE32:\r\nreturn vchiq_compat_ioctl_dequeue_message(file, cmd, arg);\r\ncase VCHIQ_IOC_GET_CONFIG32:\r\nreturn vchiq_compat_ioctl_get_config(file, cmd, arg);\r\n#if defined(CONFIG_BCM2835_VCHIQ_SUPPORT_MEMDUMP)\r\ncase VCHIQ_IOC_DUMP_PHYS_MEM32:\r\nreturn vchiq_compat_ioctl_dump_phys_mem(file, cmd, arg);\r\n#endif\r\ndefault:\r\nreturn vchiq_ioctl(file, cmd, arg);\r\n}\r\n}\r\nstatic int\r\nvchiq_open(struct inode *inode, struct file *file)\r\n{\r\nint dev = iminor(inode) & 0x0f;\r\nvchiq_log_info(vchiq_arm_log_level, "vchiq_open");\r\nswitch (dev) {\r\ncase VCHIQ_MINOR: {\r\nint ret;\r\nVCHIQ_STATE_T *state = vchiq_get_state();\r\nVCHIQ_INSTANCE_T instance;\r\nif (!state) {\r\nvchiq_log_error(vchiq_arm_log_level,\r\n"vchiq has no connection to VideoCore");\r\nreturn -ENOTCONN;\r\n}\r\ninstance = kzalloc(sizeof(*instance), GFP_KERNEL);\r\nif (!instance)\r\nreturn -ENOMEM;\r\ninstance->state = state;\r\ninstance->pid = current->tgid;\r\nret = vchiq_debugfs_add_instance(instance);\r\nif (ret != 0) {\r\nkfree(instance);\r\nreturn ret;\r\n}\r\nsema_init(&instance->insert_event, 0);\r\nsema_init(&instance->remove_event, 0);\r\nmutex_init(&instance->completion_mutex);\r\nmutex_init(&instance->bulk_waiter_list_mutex);\r\nINIT_LIST_HEAD(&instance->bulk_waiter_list);\r\nfile->private_data = instance;\r\n} break;\r\ndefault:\r\nvchiq_log_error(vchiq_arm_log_level,\r\n"Unknown minor device: %d", dev);\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nvchiq_release(struct inode *inode, struct file *file)\r\n{\r\nint dev = iminor(inode) & 0x0f;\r\nint ret = 0;\r\nswitch (dev) {\r\ncase VCHIQ_MINOR: {\r\nVCHIQ_INSTANCE_T instance = file->private_data;\r\nVCHIQ_STATE_T *state = vchiq_get_state();\r\nVCHIQ_SERVICE_T *service;\r\nint i;\r\nvchiq_log_info(vchiq_arm_log_level,\r\n"vchiq_release: instance=%lx",\r\n(unsigned long)instance);\r\nif (!state) {\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nvchiq_use_internal(instance->state, NULL,\r\nUSE_TYPE_VCHIQ);\r\nmutex_lock(&instance->completion_mutex);\r\ninstance->closing = 1;\r\nup(&instance->insert_event);\r\nmutex_unlock(&instance->completion_mutex);\r\nup(&instance->remove_event);\r\ni = 0;\r\nwhile ((service = next_service_by_instance(state, instance,\r\n&i)) != NULL) {\r\nUSER_SERVICE_T *user_service = service->base.userdata;\r\nup(&user_service->remove_event);\r\nvchiq_terminate_service_internal(service);\r\nunlock_service(service);\r\n}\r\ni = 0;\r\nwhile ((service = next_service_by_instance(state, instance, &i))\r\n!= NULL) {\r\nUSER_SERVICE_T *user_service = service->base.userdata;\r\ndown(&service->remove_event);\r\nBUG_ON(service->srvstate != VCHIQ_SRVSTATE_FREE);\r\nspin_lock(&msg_queue_spinlock);\r\nwhile (user_service->msg_remove !=\r\nuser_service->msg_insert) {\r\nVCHIQ_HEADER_T *header = user_service->\r\nmsg_queue[user_service->msg_remove &\r\n(MSG_QUEUE_SIZE - 1)];\r\nuser_service->msg_remove++;\r\nspin_unlock(&msg_queue_spinlock);\r\nif (header)\r\nvchiq_release_message(\r\nservice->handle,\r\nheader);\r\nspin_lock(&msg_queue_spinlock);\r\n}\r\nspin_unlock(&msg_queue_spinlock);\r\nunlock_service(service);\r\n}\r\nwhile (instance->completion_remove !=\r\ninstance->completion_insert) {\r\nVCHIQ_COMPLETION_DATA_T *completion;\r\nVCHIQ_SERVICE_T *service;\r\ncompletion = &instance->completions[\r\ninstance->completion_remove &\r\n(MAX_COMPLETIONS - 1)];\r\nservice = completion->service_userdata;\r\nif (completion->reason == VCHIQ_SERVICE_CLOSED)\r\n{\r\nUSER_SERVICE_T *user_service =\r\nservice->base.userdata;\r\nif (instance->use_close_delivered)\r\nup(&user_service->close_event);\r\nunlock_service(service);\r\n}\r\ninstance->completion_remove++;\r\n}\r\nvchiq_release_internal(instance->state, NULL);\r\n{\r\nstruct list_head *pos, *next;\r\nlist_for_each_safe(pos, next,\r\n&instance->bulk_waiter_list) {\r\nstruct bulk_waiter_node *waiter;\r\nwaiter = list_entry(pos,\r\nstruct bulk_waiter_node,\r\nlist);\r\nlist_del(pos);\r\nvchiq_log_info(vchiq_arm_log_level,\r\n"bulk_waiter - cleaned up %pK for pid %d",\r\nwaiter, waiter->pid);\r\nkfree(waiter);\r\n}\r\n}\r\nvchiq_debugfs_remove_instance(instance);\r\nkfree(instance);\r\nfile->private_data = NULL;\r\n} break;\r\ndefault:\r\nvchiq_log_error(vchiq_arm_log_level,\r\n"Unknown minor device: %d", dev);\r\nret = -ENXIO;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nvoid\r\nvchiq_dump(void *dump_context, const char *str, int len)\r\n{\r\nDUMP_CONTEXT_T *context = (DUMP_CONTEXT_T *)dump_context;\r\nif (context->actual < context->space) {\r\nint copy_bytes;\r\nif (context->offset > 0) {\r\nint skip_bytes = min(len, (int)context->offset);\r\nstr += skip_bytes;\r\nlen -= skip_bytes;\r\ncontext->offset -= skip_bytes;\r\nif (context->offset > 0)\r\nreturn;\r\n}\r\ncopy_bytes = min(len, (int)(context->space - context->actual));\r\nif (copy_bytes == 0)\r\nreturn;\r\nif (copy_to_user(context->buf + context->actual, str,\r\ncopy_bytes))\r\ncontext->actual = -EFAULT;\r\ncontext->actual += copy_bytes;\r\nlen -= copy_bytes;\r\nif ((len == 0) && (str[copy_bytes - 1] == '\0')) {\r\nchar cr = '\n';\r\nif (copy_to_user(context->buf + context->actual - 1,\r\n&cr, 1))\r\ncontext->actual = -EFAULT;\r\n}\r\n}\r\n}\r\nvoid\r\nvchiq_dump_platform_instances(void *dump_context)\r\n{\r\nVCHIQ_STATE_T *state = vchiq_get_state();\r\nchar buf[80];\r\nint len;\r\nint i;\r\nfor (i = 0; i < state->unused_service; i++) {\r\nVCHIQ_SERVICE_T *service = state->services[i];\r\nVCHIQ_INSTANCE_T instance;\r\nif (service && (service->base.callback == service_callback)) {\r\ninstance = service->instance;\r\nif (instance)\r\ninstance->mark = 0;\r\n}\r\n}\r\nfor (i = 0; i < state->unused_service; i++) {\r\nVCHIQ_SERVICE_T *service = state->services[i];\r\nVCHIQ_INSTANCE_T instance;\r\nif (service && (service->base.callback == service_callback)) {\r\ninstance = service->instance;\r\nif (instance && !instance->mark) {\r\nlen = snprintf(buf, sizeof(buf),\r\n"Instance %pK: pid %d,%s completions %d/%d",\r\ninstance, instance->pid,\r\ninstance->connected ? " connected, " :\r\n"",\r\ninstance->completion_insert -\r\ninstance->completion_remove,\r\nMAX_COMPLETIONS);\r\nvchiq_dump(dump_context, buf, len + 1);\r\ninstance->mark = 1;\r\n}\r\n}\r\n}\r\n}\r\nvoid\r\nvchiq_dump_platform_service_state(void *dump_context, VCHIQ_SERVICE_T *service)\r\n{\r\nUSER_SERVICE_T *user_service = (USER_SERVICE_T *)service->base.userdata;\r\nchar buf[80];\r\nint len;\r\nlen = snprintf(buf, sizeof(buf), " instance %pK", service->instance);\r\nif ((service->base.callback == service_callback) &&\r\nuser_service->is_vchi) {\r\nlen += snprintf(buf + len, sizeof(buf) - len,\r\n", %d/%d messages",\r\nuser_service->msg_insert - user_service->msg_remove,\r\nMSG_QUEUE_SIZE);\r\nif (user_service->dequeue_pending)\r\nlen += snprintf(buf + len, sizeof(buf) - len,\r\n" (dequeue pending)");\r\n}\r\nvchiq_dump(dump_context, buf, len + 1);\r\n}\r\nstatic void\r\ndump_phys_mem(void *virt_addr, u32 num_bytes)\r\n{\r\nint rc;\r\nu8 *end_virt_addr = virt_addr + num_bytes;\r\nint num_pages;\r\nint offset;\r\nint end_offset;\r\nint page_idx;\r\nint prev_idx;\r\nstruct page *page;\r\nstruct page **pages;\r\nu8 *kmapped_virt_ptr;\r\nvirt_addr = (void *)((unsigned long)virt_addr & ~0x0fuL);\r\nend_virt_addr = (void *)(((unsigned long)end_virt_addr + 15uL) &\r\n~0x0fuL);\r\noffset = (int)(long)virt_addr & (PAGE_SIZE - 1);\r\nend_offset = (int)(long)end_virt_addr & (PAGE_SIZE - 1);\r\nnum_pages = DIV_ROUND_UP(offset + num_bytes, PAGE_SIZE);\r\npages = kmalloc(sizeof(struct page *) * num_pages, GFP_KERNEL);\r\nif (!pages) {\r\nvchiq_log_error(vchiq_arm_log_level,\r\n"Unable to allocation memory for %d pages\n",\r\nnum_pages);\r\nreturn;\r\n}\r\ndown_read(&current->mm->mmap_sem);\r\nrc = get_user_pages(\r\n(unsigned long)virt_addr,\r\nnum_pages,\r\n0,\r\npages,\r\nNULL);\r\nup_read(&current->mm->mmap_sem);\r\nprev_idx = -1;\r\npage = NULL;\r\nif (rc < 0) {\r\nvchiq_log_error(vchiq_arm_log_level,\r\n"Failed to get user pages: %d\n", rc);\r\ngoto out;\r\n}\r\nwhile (offset < end_offset) {\r\nint page_offset = offset % PAGE_SIZE;\r\npage_idx = offset / PAGE_SIZE;\r\nif (page_idx != prev_idx) {\r\nif (page != NULL)\r\nkunmap(page);\r\npage = pages[page_idx];\r\nkmapped_virt_ptr = kmap(page);\r\nprev_idx = page_idx;\r\n}\r\nif (vchiq_arm_log_level >= VCHIQ_LOG_TRACE)\r\nvchiq_log_dump_mem("ph",\r\n(u32)(unsigned long)&kmapped_virt_ptr[\r\npage_offset],\r\n&kmapped_virt_ptr[page_offset], 16);\r\noffset += 16;\r\n}\r\nout:\r\nif (page != NULL)\r\nkunmap(page);\r\nfor (page_idx = 0; page_idx < num_pages; page_idx++)\r\nput_page(pages[page_idx]);\r\nkfree(pages);\r\n}\r\nstatic ssize_t\r\nvchiq_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nDUMP_CONTEXT_T context;\r\ncontext.buf = buf;\r\ncontext.actual = 0;\r\ncontext.space = count;\r\ncontext.offset = *ppos;\r\nvchiq_dump_state(&context, &g_state);\r\n*ppos += context.actual;\r\nreturn context.actual;\r\n}\r\nVCHIQ_STATE_T *\r\nvchiq_get_state(void)\r\n{\r\nif (g_state.remote == NULL)\r\nprintk(KERN_ERR "%s: g_state.remote == NULL\n", __func__);\r\nelse if (g_state.remote->initialised != 1)\r\nprintk(KERN_NOTICE "%s: g_state.remote->initialised != 1 (%d)\n",\r\n__func__, g_state.remote->initialised);\r\nreturn ((g_state.remote != NULL) &&\r\n(g_state.remote->initialised == 1)) ? &g_state : NULL;\r\n}\r\nint\r\nvchiq_videocore_wanted(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nif (!arm_state)\r\nreturn 1;\r\nelse if (arm_state->blocked_count)\r\nreturn 1;\r\nelse if (!arm_state->videocore_use_count)\r\nif (arm_state->resume_blocked)\r\nreturn 0;\r\nelse\r\nreturn vchiq_platform_videocore_wanted(state);\r\nelse\r\nreturn 1;\r\n}\r\nstatic VCHIQ_STATUS_T\r\nvchiq_keepalive_vchiq_callback(VCHIQ_REASON_T reason,\r\nVCHIQ_HEADER_T *header,\r\nVCHIQ_SERVICE_HANDLE_T service_user,\r\nvoid *bulk_user)\r\n{\r\nvchiq_log_error(vchiq_susp_log_level,\r\n"%s callback reason %d", __func__, reason);\r\nreturn 0;\r\n}\r\nstatic int\r\nvchiq_keepalive_thread_func(void *v)\r\n{\r\nVCHIQ_STATE_T *state = (VCHIQ_STATE_T *) v;\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nVCHIQ_STATUS_T status;\r\nVCHIQ_INSTANCE_T instance;\r\nVCHIQ_SERVICE_HANDLE_T ka_handle;\r\nVCHIQ_SERVICE_PARAMS_T params = {\r\n.fourcc = VCHIQ_MAKE_FOURCC('K', 'E', 'E', 'P'),\r\n.callback = vchiq_keepalive_vchiq_callback,\r\n.version = KEEPALIVE_VER,\r\n.version_min = KEEPALIVE_VER_MIN\r\n};\r\nstatus = vchiq_initialise(&instance);\r\nif (status != VCHIQ_SUCCESS) {\r\nvchiq_log_error(vchiq_susp_log_level,\r\n"%s vchiq_initialise failed %d", __func__, status);\r\ngoto exit;\r\n}\r\nstatus = vchiq_connect(instance);\r\nif (status != VCHIQ_SUCCESS) {\r\nvchiq_log_error(vchiq_susp_log_level,\r\n"%s vchiq_connect failed %d", __func__, status);\r\ngoto shutdown;\r\n}\r\nstatus = vchiq_add_service(instance, &params, &ka_handle);\r\nif (status != VCHIQ_SUCCESS) {\r\nvchiq_log_error(vchiq_susp_log_level,\r\n"%s vchiq_open_service failed %d", __func__, status);\r\ngoto shutdown;\r\n}\r\nwhile (1) {\r\nlong rc = 0, uc = 0;\r\nif (wait_for_completion_interruptible(&arm_state->ka_evt)\r\n!= 0) {\r\nvchiq_log_error(vchiq_susp_log_level,\r\n"%s interrupted", __func__);\r\nflush_signals(current);\r\ncontinue;\r\n}\r\nrc = atomic_xchg(&arm_state->ka_release_count, 0);\r\nuc = atomic_xchg(&arm_state->ka_use_count, 0);\r\nwhile (uc--) {\r\natomic_inc(&arm_state->ka_use_ack_count);\r\nstatus = vchiq_use_service(ka_handle);\r\nif (status != VCHIQ_SUCCESS) {\r\nvchiq_log_error(vchiq_susp_log_level,\r\n"%s vchiq_use_service error %d",\r\n__func__, status);\r\n}\r\n}\r\nwhile (rc--) {\r\nstatus = vchiq_release_service(ka_handle);\r\nif (status != VCHIQ_SUCCESS) {\r\nvchiq_log_error(vchiq_susp_log_level,\r\n"%s vchiq_release_service error %d",\r\n__func__, status);\r\n}\r\n}\r\n}\r\nshutdown:\r\nvchiq_shutdown(instance);\r\nexit:\r\nreturn 0;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_arm_init_state(VCHIQ_STATE_T *state, VCHIQ_ARM_STATE_T *arm_state)\r\n{\r\nif (arm_state) {\r\nrwlock_init(&arm_state->susp_res_lock);\r\ninit_completion(&arm_state->ka_evt);\r\natomic_set(&arm_state->ka_use_count, 0);\r\natomic_set(&arm_state->ka_use_ack_count, 0);\r\natomic_set(&arm_state->ka_release_count, 0);\r\ninit_completion(&arm_state->vc_suspend_complete);\r\ninit_completion(&arm_state->vc_resume_complete);\r\nset_resume_state(arm_state, VC_RESUME_RESUMED);\r\ninit_completion(&arm_state->resume_blocker);\r\ncomplete_all(&arm_state->resume_blocker);\r\ninit_completion(&arm_state->blocked_blocker);\r\ncomplete_all(&arm_state->blocked_blocker);\r\narm_state->suspend_timer_timeout = SUSPEND_TIMER_TIMEOUT_MS;\r\narm_state->suspend_timer_running = 0;\r\nsetup_timer(&arm_state->suspend_timer, suspend_timer_callback,\r\n(unsigned long)(state));\r\narm_state->first_connect = 0;\r\n}\r\nreturn VCHIQ_SUCCESS;\r\n}\r\nvoid\r\nset_suspend_state(VCHIQ_ARM_STATE_T *arm_state,\r\nenum vc_suspend_status new_state)\r\n{\r\narm_state->vc_suspend_state = new_state;\r\nswitch (new_state) {\r\ncase VC_SUSPEND_FORCE_CANCELED:\r\ncomplete_all(&arm_state->vc_suspend_complete);\r\nbreak;\r\ncase VC_SUSPEND_REJECTED:\r\ncomplete_all(&arm_state->vc_suspend_complete);\r\nbreak;\r\ncase VC_SUSPEND_FAILED:\r\ncomplete_all(&arm_state->vc_suspend_complete);\r\narm_state->vc_resume_state = VC_RESUME_RESUMED;\r\ncomplete_all(&arm_state->vc_resume_complete);\r\nbreak;\r\ncase VC_SUSPEND_IDLE:\r\nreinit_completion(&arm_state->vc_suspend_complete);\r\nbreak;\r\ncase VC_SUSPEND_REQUESTED:\r\nbreak;\r\ncase VC_SUSPEND_IN_PROGRESS:\r\nset_resume_state(arm_state, VC_RESUME_IDLE);\r\nbreak;\r\ncase VC_SUSPEND_SUSPENDED:\r\ncomplete_all(&arm_state->vc_suspend_complete);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nvoid\r\nset_resume_state(VCHIQ_ARM_STATE_T *arm_state,\r\nenum vc_resume_status new_state)\r\n{\r\narm_state->vc_resume_state = new_state;\r\nswitch (new_state) {\r\ncase VC_RESUME_FAILED:\r\nbreak;\r\ncase VC_RESUME_IDLE:\r\nreinit_completion(&arm_state->vc_resume_complete);\r\nbreak;\r\ncase VC_RESUME_REQUESTED:\r\nbreak;\r\ncase VC_RESUME_IN_PROGRESS:\r\nbreak;\r\ncase VC_RESUME_RESUMED:\r\ncomplete_all(&arm_state->vc_resume_complete);\r\nset_suspend_state(arm_state, VC_SUSPEND_IDLE);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\ninline void\r\nstart_suspend_timer(VCHIQ_ARM_STATE_T *arm_state)\r\n{\r\ndel_timer(&arm_state->suspend_timer);\r\narm_state->suspend_timer.expires = jiffies +\r\nmsecs_to_jiffies(arm_state->\r\nsuspend_timer_timeout);\r\nadd_timer(&arm_state->suspend_timer);\r\narm_state->suspend_timer_running = 1;\r\n}\r\nstatic inline void\r\nstop_suspend_timer(VCHIQ_ARM_STATE_T *arm_state)\r\n{\r\nif (arm_state->suspend_timer_running) {\r\ndel_timer(&arm_state->suspend_timer);\r\narm_state->suspend_timer_running = 0;\r\n}\r\n}\r\nstatic inline int\r\nneed_resume(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nreturn (arm_state->vc_suspend_state > VC_SUSPEND_IDLE) &&\r\n(arm_state->vc_resume_state < VC_RESUME_REQUESTED) &&\r\nvchiq_videocore_wanted(state);\r\n}\r\nstatic int\r\nblock_resume(VCHIQ_ARM_STATE_T *arm_state)\r\n{\r\nint status = VCHIQ_SUCCESS;\r\nconst unsigned long timeout_val =\r\nmsecs_to_jiffies(FORCE_SUSPEND_TIMEOUT_MS);\r\nint resume_count = 0;\r\nif (arm_state->blocked_count) {\r\nreinit_completion(&arm_state->blocked_blocker);\r\nwrite_unlock_bh(&arm_state->susp_res_lock);\r\nvchiq_log_info(vchiq_susp_log_level, "%s wait for previously "\r\n"blocked clients", __func__);\r\nif (wait_for_completion_interruptible_timeout(\r\n&arm_state->blocked_blocker, timeout_val)\r\n<= 0) {\r\nvchiq_log_error(vchiq_susp_log_level, "%s wait for "\r\n"previously blocked clients failed", __func__);\r\nstatus = VCHIQ_ERROR;\r\nwrite_lock_bh(&arm_state->susp_res_lock);\r\ngoto out;\r\n}\r\nvchiq_log_info(vchiq_susp_log_level, "%s previously blocked "\r\n"clients resumed", __func__);\r\nwrite_lock_bh(&arm_state->susp_res_lock);\r\n}\r\nwhile (arm_state->vc_resume_state != VC_RESUME_RESUMED &&\r\narm_state->vc_resume_state > VC_RESUME_IDLE) {\r\nif (resume_count > 1) {\r\nstatus = VCHIQ_ERROR;\r\nvchiq_log_error(vchiq_susp_log_level, "%s waited too "\r\n"many times for resume", __func__);\r\ngoto out;\r\n}\r\nwrite_unlock_bh(&arm_state->susp_res_lock);\r\nvchiq_log_info(vchiq_susp_log_level, "%s wait for resume",\r\n__func__);\r\nif (wait_for_completion_interruptible_timeout(\r\n&arm_state->vc_resume_complete, timeout_val)\r\n<= 0) {\r\nvchiq_log_error(vchiq_susp_log_level, "%s wait for "\r\n"resume failed (%s)", __func__,\r\nresume_state_names[arm_state->vc_resume_state +\r\nVC_RESUME_NUM_OFFSET]);\r\nstatus = VCHIQ_ERROR;\r\nwrite_lock_bh(&arm_state->susp_res_lock);\r\ngoto out;\r\n}\r\nvchiq_log_info(vchiq_susp_log_level, "%s resumed", __func__);\r\nwrite_lock_bh(&arm_state->susp_res_lock);\r\nresume_count++;\r\n}\r\nreinit_completion(&arm_state->resume_blocker);\r\narm_state->resume_blocked = 1;\r\nout:\r\nreturn status;\r\n}\r\nstatic inline void\r\nunblock_resume(VCHIQ_ARM_STATE_T *arm_state)\r\n{\r\ncomplete_all(&arm_state->resume_blocker);\r\narm_state->resume_blocked = 0;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_arm_vcsuspend(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_STATUS_T status = VCHIQ_ERROR;\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nif (!arm_state)\r\ngoto out;\r\nvchiq_log_trace(vchiq_susp_log_level, "%s", __func__);\r\nstatus = VCHIQ_SUCCESS;\r\nswitch (arm_state->vc_suspend_state) {\r\ncase VC_SUSPEND_REQUESTED:\r\nvchiq_log_info(vchiq_susp_log_level, "%s: suspend already "\r\n"requested", __func__);\r\nbreak;\r\ncase VC_SUSPEND_IN_PROGRESS:\r\nvchiq_log_info(vchiq_susp_log_level, "%s: suspend already in "\r\n"progress", __func__);\r\nbreak;\r\ndefault:\r\nvchiq_log_error(vchiq_susp_log_level,\r\n"%s unexpected suspend state %s", __func__,\r\nsuspend_state_names[arm_state->vc_suspend_state +\r\nVC_SUSPEND_NUM_OFFSET]);\r\ncase VC_SUSPEND_REJECTED:\r\ncase VC_SUSPEND_FAILED:\r\nset_suspend_state(arm_state, VC_SUSPEND_IDLE);\r\ncase VC_SUSPEND_IDLE:\r\nvchiq_log_info(vchiq_susp_log_level,\r\n"%s: suspending", __func__);\r\nset_suspend_state(arm_state, VC_SUSPEND_REQUESTED);\r\nrequest_poll(state, NULL, 0);\r\nbreak;\r\n}\r\nout:\r\nvchiq_log_trace(vchiq_susp_log_level, "%s exit %d", __func__, status);\r\nreturn status;\r\n}\r\nvoid\r\nvchiq_platform_check_suspend(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nint susp = 0;\r\nif (!arm_state)\r\ngoto out;\r\nvchiq_log_trace(vchiq_susp_log_level, "%s", __func__);\r\nwrite_lock_bh(&arm_state->susp_res_lock);\r\nif (arm_state->vc_suspend_state == VC_SUSPEND_REQUESTED &&\r\narm_state->vc_resume_state == VC_RESUME_RESUMED) {\r\nset_suspend_state(arm_state, VC_SUSPEND_IN_PROGRESS);\r\nsusp = 1;\r\n}\r\nwrite_unlock_bh(&arm_state->susp_res_lock);\r\nif (susp)\r\nvchiq_platform_suspend(state);\r\nout:\r\nvchiq_log_trace(vchiq_susp_log_level, "%s exit", __func__);\r\nreturn;\r\n}\r\nstatic void\r\noutput_timeout_error(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nchar err[50] = "";\r\nint vc_use_count = arm_state->videocore_use_count;\r\nint active_services = state->unused_service;\r\nint i;\r\nif (!arm_state->videocore_use_count) {\r\nsnprintf(err, sizeof(err), " Videocore usecount is 0");\r\ngoto output_msg;\r\n}\r\nfor (i = 0; i < active_services; i++) {\r\nVCHIQ_SERVICE_T *service_ptr = state->services[i];\r\nif (service_ptr && service_ptr->service_use_count &&\r\n(service_ptr->srvstate != VCHIQ_SRVSTATE_FREE)) {\r\nsnprintf(err, sizeof(err), " %c%c%c%c(%d) service has "\r\n"use count %d%s", VCHIQ_FOURCC_AS_4CHARS(\r\nservice_ptr->base.fourcc),\r\nservice_ptr->client_id,\r\nservice_ptr->service_use_count,\r\nservice_ptr->service_use_count ==\r\nvc_use_count ? "" : " (+ more)");\r\nbreak;\r\n}\r\n}\r\noutput_msg:\r\nvchiq_log_error(vchiq_susp_log_level,\r\n"timed out waiting for vc suspend (%d).%s",\r\narm_state->autosuspend_override, err);\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_arm_force_suspend(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nVCHIQ_STATUS_T status = VCHIQ_ERROR;\r\nlong rc = 0;\r\nint repeat = -1;\r\nif (!arm_state)\r\ngoto out;\r\nvchiq_log_trace(vchiq_susp_log_level, "%s", __func__);\r\nwrite_lock_bh(&arm_state->susp_res_lock);\r\nstatus = block_resume(arm_state);\r\nif (status != VCHIQ_SUCCESS)\r\ngoto unlock;\r\nif (arm_state->vc_suspend_state == VC_SUSPEND_SUSPENDED) {\r\nvchiq_log_info(vchiq_susp_log_level, "%s already suspended",\r\n__func__);\r\nstatus = VCHIQ_SUCCESS;\r\ngoto unlock;\r\n} else if (arm_state->vc_suspend_state <= VC_SUSPEND_IDLE) {\r\nstop_suspend_timer(arm_state);\r\nif (!vchiq_videocore_wanted(state)) {\r\nvchiq_log_info(vchiq_susp_log_level, "%s videocore "\r\n"idle, initiating suspend", __func__);\r\nstatus = vchiq_arm_vcsuspend(state);\r\n} else if (arm_state->autosuspend_override <\r\nFORCE_SUSPEND_FAIL_MAX) {\r\nvchiq_log_info(vchiq_susp_log_level, "%s letting "\r\n"videocore go idle", __func__);\r\nstatus = VCHIQ_SUCCESS;\r\n} else {\r\nvchiq_log_warning(vchiq_susp_log_level, "%s failed too "\r\n"many times - attempting suspend", __func__);\r\nstatus = vchiq_arm_vcsuspend(state);\r\n}\r\n} else {\r\nvchiq_log_info(vchiq_susp_log_level, "%s videocore suspend "\r\n"in progress - wait for completion", __func__);\r\nstatus = VCHIQ_SUCCESS;\r\n}\r\nif (status != VCHIQ_SUCCESS)\r\ngoto unblock_resume;\r\ndo {\r\nwrite_unlock_bh(&arm_state->susp_res_lock);\r\nrc = wait_for_completion_interruptible_timeout(\r\n&arm_state->vc_suspend_complete,\r\nmsecs_to_jiffies(FORCE_SUSPEND_TIMEOUT_MS));\r\nwrite_lock_bh(&arm_state->susp_res_lock);\r\nif (rc < 0) {\r\nvchiq_log_warning(vchiq_susp_log_level, "%s "\r\n"interrupted waiting for suspend", __func__);\r\nstatus = VCHIQ_ERROR;\r\ngoto unblock_resume;\r\n} else if (rc == 0) {\r\nif (arm_state->vc_suspend_state > VC_SUSPEND_IDLE) {\r\nif (repeat < 0) {\r\nrepeat = 1;\r\ncontinue;\r\n}\r\n}\r\narm_state->autosuspend_override++;\r\noutput_timeout_error(state);\r\nstatus = VCHIQ_RETRY;\r\ngoto unblock_resume;\r\n}\r\n} while (0 < (repeat--));\r\nif (arm_state->vc_suspend_state != VC_SUSPEND_SUSPENDED) {\r\nstatus = VCHIQ_RETRY;\r\nvchiq_log_error(vchiq_susp_log_level,\r\n"%s videocore suspend failed (state %s)", __func__,\r\nsuspend_state_names[arm_state->vc_suspend_state +\r\nVC_SUSPEND_NUM_OFFSET]);\r\nif (arm_state->vc_suspend_state < VC_SUSPEND_IDLE)\r\nset_suspend_state(arm_state, VC_SUSPEND_IDLE);\r\ngoto unblock_resume;\r\n}\r\ngoto unlock;\r\nunblock_resume:\r\nunblock_resume(arm_state);\r\nunlock:\r\nwrite_unlock_bh(&arm_state->susp_res_lock);\r\nout:\r\nvchiq_log_trace(vchiq_susp_log_level, "%s exit %d", __func__, status);\r\nreturn status;\r\n}\r\nvoid\r\nvchiq_check_suspend(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nif (!arm_state)\r\ngoto out;\r\nvchiq_log_trace(vchiq_susp_log_level, "%s", __func__);\r\nwrite_lock_bh(&arm_state->susp_res_lock);\r\nif (arm_state->vc_suspend_state != VC_SUSPEND_SUSPENDED &&\r\narm_state->first_connect &&\r\n!vchiq_videocore_wanted(state)) {\r\nvchiq_arm_vcsuspend(state);\r\n}\r\nwrite_unlock_bh(&arm_state->susp_res_lock);\r\nout:\r\nvchiq_log_trace(vchiq_susp_log_level, "%s exit", __func__);\r\nreturn;\r\n}\r\nint\r\nvchiq_arm_allow_resume(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nint resume = 0;\r\nint ret = -1;\r\nif (!arm_state)\r\ngoto out;\r\nvchiq_log_trace(vchiq_susp_log_level, "%s", __func__);\r\nwrite_lock_bh(&arm_state->susp_res_lock);\r\nunblock_resume(arm_state);\r\nresume = vchiq_check_resume(state);\r\nwrite_unlock_bh(&arm_state->susp_res_lock);\r\nif (resume) {\r\nif (wait_for_completion_interruptible(\r\n&arm_state->vc_resume_complete) < 0) {\r\nvchiq_log_error(vchiq_susp_log_level,\r\n"%s interrupted", __func__);\r\ngoto out;\r\n}\r\n}\r\nread_lock_bh(&arm_state->susp_res_lock);\r\nif (arm_state->vc_suspend_state == VC_SUSPEND_SUSPENDED) {\r\nvchiq_log_info(vchiq_susp_log_level,\r\n"%s: Videocore remains suspended", __func__);\r\n} else {\r\nvchiq_log_info(vchiq_susp_log_level,\r\n"%s: Videocore resumed", __func__);\r\nret = 0;\r\n}\r\nread_unlock_bh(&arm_state->susp_res_lock);\r\nout:\r\nvchiq_log_trace(vchiq_susp_log_level, "%s exit %d", __func__, ret);\r\nreturn ret;\r\n}\r\nint\r\nvchiq_check_resume(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nint resume = 0;\r\nif (!arm_state)\r\ngoto out;\r\nvchiq_log_trace(vchiq_susp_log_level, "%s", __func__);\r\nif (need_resume(state)) {\r\nset_resume_state(arm_state, VC_RESUME_REQUESTED);\r\nrequest_poll(state, NULL, 0);\r\nresume = 1;\r\n}\r\nout:\r\nvchiq_log_trace(vchiq_susp_log_level, "%s exit", __func__);\r\nreturn resume;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_use_internal(VCHIQ_STATE_T *state, VCHIQ_SERVICE_T *service,\r\nenum USE_TYPE_E use_type)\r\n{\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nVCHIQ_STATUS_T ret = VCHIQ_SUCCESS;\r\nchar entity[16];\r\nint *entity_uc;\r\nint local_uc, local_entity_uc;\r\nif (!arm_state)\r\ngoto out;\r\nvchiq_log_trace(vchiq_susp_log_level, "%s", __func__);\r\nif (use_type == USE_TYPE_VCHIQ) {\r\nsprintf(entity, "VCHIQ: ");\r\nentity_uc = &arm_state->peer_use_count;\r\n} else if (service) {\r\nsprintf(entity, "%c%c%c%c:%03d",\r\nVCHIQ_FOURCC_AS_4CHARS(service->base.fourcc),\r\nservice->client_id);\r\nentity_uc = &service->service_use_count;\r\n} else {\r\nvchiq_log_error(vchiq_susp_log_level, "%s null service "\r\n"ptr", __func__);\r\nret = VCHIQ_ERROR;\r\ngoto out;\r\n}\r\nwrite_lock_bh(&arm_state->susp_res_lock);\r\nwhile (arm_state->resume_blocked) {\r\nif (arm_state->resume_blocked && arm_state->vc_suspend_state ==\r\nVC_SUSPEND_IDLE) {\r\nset_suspend_state(arm_state, VC_SUSPEND_FORCE_CANCELED);\r\nbreak;\r\n}\r\nif (!try_wait_for_completion(&arm_state->resume_blocker)) {\r\narm_state->blocked_count++;\r\nwrite_unlock_bh(&arm_state->susp_res_lock);\r\nvchiq_log_info(vchiq_susp_log_level, "%s %s resume "\r\n"blocked - waiting...", __func__, entity);\r\nif (wait_for_completion_killable(\r\n&arm_state->resume_blocker) != 0) {\r\nvchiq_log_error(vchiq_susp_log_level, "%s %s "\r\n"wait for resume blocker interrupted",\r\n__func__, entity);\r\nret = VCHIQ_ERROR;\r\nwrite_lock_bh(&arm_state->susp_res_lock);\r\narm_state->blocked_count--;\r\nwrite_unlock_bh(&arm_state->susp_res_lock);\r\ngoto out;\r\n}\r\nvchiq_log_info(vchiq_susp_log_level, "%s %s resume "\r\n"unblocked", __func__, entity);\r\nwrite_lock_bh(&arm_state->susp_res_lock);\r\nif (--arm_state->blocked_count == 0)\r\ncomplete_all(&arm_state->blocked_blocker);\r\n}\r\n}\r\nstop_suspend_timer(arm_state);\r\nlocal_uc = ++arm_state->videocore_use_count;\r\nlocal_entity_uc = ++(*entity_uc);\r\nif (arm_state->vc_suspend_state <= VC_SUSPEND_REQUESTED)\r\nset_suspend_state(arm_state, VC_SUSPEND_IDLE);\r\nif ((use_type != USE_TYPE_SERVICE_NO_RESUME) && need_resume(state)) {\r\nset_resume_state(arm_state, VC_RESUME_REQUESTED);\r\nvchiq_log_info(vchiq_susp_log_level,\r\n"%s %s count %d, state count %d",\r\n__func__, entity, local_entity_uc, local_uc);\r\nrequest_poll(state, NULL, 0);\r\n} else\r\nvchiq_log_trace(vchiq_susp_log_level,\r\n"%s %s count %d, state count %d",\r\n__func__, entity, *entity_uc, local_uc);\r\nwrite_unlock_bh(&arm_state->susp_res_lock);\r\nif (!try_wait_for_completion(&arm_state->vc_resume_complete)) {\r\nvchiq_log_info(vchiq_susp_log_level, "%s %s wait for resume",\r\n__func__, entity);\r\nif (wait_for_completion_killable(\r\n&arm_state->vc_resume_complete) != 0) {\r\nvchiq_log_error(vchiq_susp_log_level, "%s %s wait for "\r\n"resume interrupted", __func__, entity);\r\nret = VCHIQ_ERROR;\r\ngoto out;\r\n}\r\nvchiq_log_info(vchiq_susp_log_level, "%s %s resumed", __func__,\r\nentity);\r\n}\r\nif (ret == VCHIQ_SUCCESS) {\r\nVCHIQ_STATUS_T status = VCHIQ_SUCCESS;\r\nlong ack_cnt = atomic_xchg(&arm_state->ka_use_ack_count, 0);\r\nwhile (ack_cnt && (status == VCHIQ_SUCCESS)) {\r\nstatus = vchiq_send_remote_use_active(state);\r\nif (status == VCHIQ_SUCCESS)\r\nack_cnt--;\r\nelse\r\natomic_add(ack_cnt,\r\n&arm_state->ka_use_ack_count);\r\n}\r\n}\r\nout:\r\nvchiq_log_trace(vchiq_susp_log_level, "%s exit %d", __func__, ret);\r\nreturn ret;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_release_internal(VCHIQ_STATE_T *state, VCHIQ_SERVICE_T *service)\r\n{\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nVCHIQ_STATUS_T ret = VCHIQ_SUCCESS;\r\nchar entity[16];\r\nint *entity_uc;\r\nint local_uc, local_entity_uc;\r\nif (!arm_state)\r\ngoto out;\r\nvchiq_log_trace(vchiq_susp_log_level, "%s", __func__);\r\nif (service) {\r\nsprintf(entity, "%c%c%c%c:%03d",\r\nVCHIQ_FOURCC_AS_4CHARS(service->base.fourcc),\r\nservice->client_id);\r\nentity_uc = &service->service_use_count;\r\n} else {\r\nsprintf(entity, "PEER: ");\r\nentity_uc = &arm_state->peer_use_count;\r\n}\r\nwrite_lock_bh(&arm_state->susp_res_lock);\r\nif (!arm_state->videocore_use_count || !(*entity_uc)) {\r\nWARN_ON(!arm_state->videocore_use_count);\r\nWARN_ON(!(*entity_uc));\r\nret = VCHIQ_ERROR;\r\ngoto unlock;\r\n}\r\nlocal_uc = --arm_state->videocore_use_count;\r\nlocal_entity_uc = --(*entity_uc);\r\nif (!vchiq_videocore_wanted(state)) {\r\nif (vchiq_platform_use_suspend_timer() &&\r\n!arm_state->resume_blocked) {\r\nstart_suspend_timer(arm_state);\r\n} else {\r\nvchiq_log_info(vchiq_susp_log_level,\r\n"%s %s count %d, state count %d - suspending",\r\n__func__, entity, *entity_uc,\r\narm_state->videocore_use_count);\r\nvchiq_arm_vcsuspend(state);\r\n}\r\n} else\r\nvchiq_log_trace(vchiq_susp_log_level,\r\n"%s %s count %d, state count %d",\r\n__func__, entity, *entity_uc,\r\narm_state->videocore_use_count);\r\nunlock:\r\nwrite_unlock_bh(&arm_state->susp_res_lock);\r\nout:\r\nvchiq_log_trace(vchiq_susp_log_level, "%s exit %d", __func__, ret);\r\nreturn ret;\r\n}\r\nvoid\r\nvchiq_on_remote_use(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nvchiq_log_trace(vchiq_susp_log_level, "%s", __func__);\r\natomic_inc(&arm_state->ka_use_count);\r\ncomplete(&arm_state->ka_evt);\r\n}\r\nvoid\r\nvchiq_on_remote_release(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nvchiq_log_trace(vchiq_susp_log_level, "%s", __func__);\r\natomic_inc(&arm_state->ka_release_count);\r\ncomplete(&arm_state->ka_evt);\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_use_service_internal(VCHIQ_SERVICE_T *service)\r\n{\r\nreturn vchiq_use_internal(service->state, service, USE_TYPE_SERVICE);\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_release_service_internal(VCHIQ_SERVICE_T *service)\r\n{\r\nreturn vchiq_release_internal(service->state, service);\r\n}\r\nVCHIQ_DEBUGFS_NODE_T *\r\nvchiq_instance_get_debugfs_node(VCHIQ_INSTANCE_T instance)\r\n{\r\nreturn &instance->debugfs_node;\r\n}\r\nint\r\nvchiq_instance_get_use_count(VCHIQ_INSTANCE_T instance)\r\n{\r\nVCHIQ_SERVICE_T *service;\r\nint use_count = 0, i;\r\ni = 0;\r\nwhile ((service = next_service_by_instance(instance->state,\r\ninstance, &i)) != NULL) {\r\nuse_count += service->service_use_count;\r\nunlock_service(service);\r\n}\r\nreturn use_count;\r\n}\r\nint\r\nvchiq_instance_get_pid(VCHIQ_INSTANCE_T instance)\r\n{\r\nreturn instance->pid;\r\n}\r\nint\r\nvchiq_instance_get_trace(VCHIQ_INSTANCE_T instance)\r\n{\r\nreturn instance->trace;\r\n}\r\nvoid\r\nvchiq_instance_set_trace(VCHIQ_INSTANCE_T instance, int trace)\r\n{\r\nVCHIQ_SERVICE_T *service;\r\nint i;\r\ni = 0;\r\nwhile ((service = next_service_by_instance(instance->state,\r\ninstance, &i)) != NULL) {\r\nservice->trace = trace;\r\nunlock_service(service);\r\n}\r\ninstance->trace = (trace != 0);\r\n}\r\nstatic void suspend_timer_callback(unsigned long context)\r\n{\r\nVCHIQ_STATE_T *state = (VCHIQ_STATE_T *)context;\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nif (!arm_state)\r\ngoto out;\r\nvchiq_log_info(vchiq_susp_log_level,\r\n"%s - suspend timer expired - check suspend", __func__);\r\nvchiq_check_suspend(state);\r\nout:\r\nreturn;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_use_service_no_resume(VCHIQ_SERVICE_HANDLE_T handle)\r\n{\r\nVCHIQ_STATUS_T ret = VCHIQ_ERROR;\r\nVCHIQ_SERVICE_T *service = find_service_by_handle(handle);\r\nif (service) {\r\nret = vchiq_use_internal(service->state, service,\r\nUSE_TYPE_SERVICE_NO_RESUME);\r\nunlock_service(service);\r\n}\r\nreturn ret;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_use_service(VCHIQ_SERVICE_HANDLE_T handle)\r\n{\r\nVCHIQ_STATUS_T ret = VCHIQ_ERROR;\r\nVCHIQ_SERVICE_T *service = find_service_by_handle(handle);\r\nif (service) {\r\nret = vchiq_use_internal(service->state, service,\r\nUSE_TYPE_SERVICE);\r\nunlock_service(service);\r\n}\r\nreturn ret;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_release_service(VCHIQ_SERVICE_HANDLE_T handle)\r\n{\r\nVCHIQ_STATUS_T ret = VCHIQ_ERROR;\r\nVCHIQ_SERVICE_T *service = find_service_by_handle(handle);\r\nif (service) {\r\nret = vchiq_release_internal(service->state, service);\r\nunlock_service(service);\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nvchiq_dump_service_use_state(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nint i, j = 0;\r\nstatic const int local_max_services = 64;\r\nint only_nonzero = 0;\r\nstatic const char *nz = "<-- preventing suspend";\r\nenum vc_suspend_status vc_suspend_state;\r\nenum vc_resume_status vc_resume_state;\r\nint peer_count;\r\nint vc_use_count;\r\nint active_services;\r\nstruct service_data_struct {\r\nint fourcc;\r\nint clientid;\r\nint use_count;\r\n} service_data[local_max_services];\r\nif (!arm_state)\r\nreturn;\r\nread_lock_bh(&arm_state->susp_res_lock);\r\nvc_suspend_state = arm_state->vc_suspend_state;\r\nvc_resume_state = arm_state->vc_resume_state;\r\npeer_count = arm_state->peer_use_count;\r\nvc_use_count = arm_state->videocore_use_count;\r\nactive_services = state->unused_service;\r\nif (active_services > local_max_services)\r\nonly_nonzero = 1;\r\nfor (i = 0; (i < active_services) && (j < local_max_services); i++) {\r\nVCHIQ_SERVICE_T *service_ptr = state->services[i];\r\nif (!service_ptr)\r\ncontinue;\r\nif (only_nonzero && !service_ptr->service_use_count)\r\ncontinue;\r\nif (service_ptr->srvstate == VCHIQ_SRVSTATE_FREE)\r\ncontinue;\r\nservice_data[j].fourcc = service_ptr->base.fourcc;\r\nservice_data[j].clientid = service_ptr->client_id;\r\nservice_data[j++].use_count = service_ptr->service_use_count;\r\n}\r\nread_unlock_bh(&arm_state->susp_res_lock);\r\nvchiq_log_warning(vchiq_susp_log_level,\r\n"-- Videcore suspend state: %s --",\r\nsuspend_state_names[vc_suspend_state + VC_SUSPEND_NUM_OFFSET]);\r\nvchiq_log_warning(vchiq_susp_log_level,\r\n"-- Videcore resume state: %s --",\r\nresume_state_names[vc_resume_state + VC_RESUME_NUM_OFFSET]);\r\nif (only_nonzero)\r\nvchiq_log_warning(vchiq_susp_log_level, "Too many active "\r\n"services (%d). Only dumping up to first %d services "\r\n"with non-zero use-count", active_services,\r\nlocal_max_services);\r\nfor (i = 0; i < j; i++) {\r\nvchiq_log_warning(vchiq_susp_log_level,\r\n"----- %c%c%c%c:%d service count %d %s",\r\nVCHIQ_FOURCC_AS_4CHARS(service_data[i].fourcc),\r\nservice_data[i].clientid,\r\nservice_data[i].use_count,\r\nservice_data[i].use_count ? nz : "");\r\n}\r\nvchiq_log_warning(vchiq_susp_log_level,\r\n"----- VCHIQ use count count %d", peer_count);\r\nvchiq_log_warning(vchiq_susp_log_level,\r\n"--- Overall vchiq instance use count %d", vc_use_count);\r\nvchiq_dump_platform_use_state(state);\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_check_service(VCHIQ_SERVICE_T *service)\r\n{\r\nVCHIQ_ARM_STATE_T *arm_state;\r\nVCHIQ_STATUS_T ret = VCHIQ_ERROR;\r\nif (!service || !service->state)\r\ngoto out;\r\nvchiq_log_trace(vchiq_susp_log_level, "%s", __func__);\r\narm_state = vchiq_platform_get_arm_state(service->state);\r\nread_lock_bh(&arm_state->susp_res_lock);\r\nif (service->service_use_count)\r\nret = VCHIQ_SUCCESS;\r\nread_unlock_bh(&arm_state->susp_res_lock);\r\nif (ret == VCHIQ_ERROR) {\r\nvchiq_log_error(vchiq_susp_log_level,\r\n"%s ERROR - %c%c%c%c:%d service count %d, "\r\n"state count %d, videocore suspend state %s", __func__,\r\nVCHIQ_FOURCC_AS_4CHARS(service->base.fourcc),\r\nservice->client_id, service->service_use_count,\r\narm_state->videocore_use_count,\r\nsuspend_state_names[arm_state->vc_suspend_state +\r\nVC_SUSPEND_NUM_OFFSET]);\r\nvchiq_dump_service_use_state(service->state);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nvoid vchiq_on_remote_use_active(VCHIQ_STATE_T *state)\r\n{\r\n(void)state;\r\n}\r\nvoid vchiq_platform_conn_state_changed(VCHIQ_STATE_T *state,\r\nVCHIQ_CONNSTATE_T oldstate, VCHIQ_CONNSTATE_T newstate)\r\n{\r\nVCHIQ_ARM_STATE_T *arm_state = vchiq_platform_get_arm_state(state);\r\nvchiq_log_info(vchiq_susp_log_level, "%d: %s->%s", state->id,\r\nget_conn_state_name(oldstate), get_conn_state_name(newstate));\r\nif (state->conn_state == VCHIQ_CONNSTATE_CONNECTED) {\r\nwrite_lock_bh(&arm_state->susp_res_lock);\r\nif (!arm_state->first_connect) {\r\nchar threadname[16];\r\narm_state->first_connect = 1;\r\nwrite_unlock_bh(&arm_state->susp_res_lock);\r\nsnprintf(threadname, sizeof(threadname), "vchiq-keep/%d",\r\nstate->id);\r\narm_state->ka_thread = kthread_create(\r\n&vchiq_keepalive_thread_func,\r\n(void *)state,\r\nthreadname);\r\nif (IS_ERR(arm_state->ka_thread)) {\r\nvchiq_log_error(vchiq_susp_log_level,\r\n"vchiq: FATAL: couldn't create thread %s",\r\nthreadname);\r\n} else {\r\nwake_up_process(arm_state->ka_thread);\r\n}\r\n} else\r\nwrite_unlock_bh(&arm_state->susp_res_lock);\r\n}\r\n}\r\nstatic int vchiq_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *fw_node;\r\nstruct rpi_firmware *fw;\r\nint err;\r\nfw_node = of_parse_phandle(pdev->dev.of_node, "firmware", 0);\r\nif (!fw_node) {\r\ndev_err(&pdev->dev, "Missing firmware node\n");\r\nreturn -ENOENT;\r\n}\r\nfw = rpi_firmware_get(fw_node);\r\nof_node_put(fw_node);\r\nif (!fw)\r\nreturn -EPROBE_DEFER;\r\nplatform_set_drvdata(pdev, fw);\r\nerr = vchiq_platform_init(pdev, &g_state);\r\nif (err != 0)\r\ngoto failed_platform_init;\r\nerr = alloc_chrdev_region(&vchiq_devid, VCHIQ_MINOR, 1, DEVICE_NAME);\r\nif (err != 0) {\r\nvchiq_log_error(vchiq_arm_log_level,\r\n"Unable to allocate device number");\r\ngoto failed_platform_init;\r\n}\r\ncdev_init(&vchiq_cdev, &vchiq_fops);\r\nvchiq_cdev.owner = THIS_MODULE;\r\nerr = cdev_add(&vchiq_cdev, vchiq_devid, 1);\r\nif (err != 0) {\r\nvchiq_log_error(vchiq_arm_log_level,\r\n"Unable to register device");\r\ngoto failed_cdev_add;\r\n}\r\nvchiq_class = class_create(THIS_MODULE, DEVICE_NAME);\r\nerr = PTR_ERR(vchiq_class);\r\nif (IS_ERR(vchiq_class))\r\ngoto failed_class_create;\r\nvchiq_dev = device_create(vchiq_class, NULL,\r\nvchiq_devid, NULL, "vchiq");\r\nerr = PTR_ERR(vchiq_dev);\r\nif (IS_ERR(vchiq_dev))\r\ngoto failed_device_create;\r\nerr = vchiq_debugfs_init();\r\nif (err != 0)\r\ngoto failed_debugfs_init;\r\nvchiq_log_info(vchiq_arm_log_level,\r\n"vchiq: initialised - version %d (min %d), device %d.%d",\r\nVCHIQ_VERSION, VCHIQ_VERSION_MIN,\r\nMAJOR(vchiq_devid), MINOR(vchiq_devid));\r\nreturn 0;\r\nfailed_debugfs_init:\r\ndevice_destroy(vchiq_class, vchiq_devid);\r\nfailed_device_create:\r\nclass_destroy(vchiq_class);\r\nfailed_class_create:\r\ncdev_del(&vchiq_cdev);\r\nfailed_cdev_add:\r\nunregister_chrdev_region(vchiq_devid, 1);\r\nfailed_platform_init:\r\nvchiq_log_warning(vchiq_arm_log_level, "could not load vchiq");\r\nreturn err;\r\n}\r\nstatic int vchiq_remove(struct platform_device *pdev)\r\n{\r\nvchiq_debugfs_deinit();\r\ndevice_destroy(vchiq_class, vchiq_devid);\r\nclass_destroy(vchiq_class);\r\ncdev_del(&vchiq_cdev);\r\nunregister_chrdev_region(vchiq_devid, 1);\r\nreturn 0;\r\n}
