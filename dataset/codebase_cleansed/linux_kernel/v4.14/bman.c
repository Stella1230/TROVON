static inline u32 bm_in(struct bm_portal *p, u32 offset)\r\n{\r\nreturn be32_to_cpu(__raw_readl(p->addr.ci + offset));\r\n}\r\nstatic inline void bm_out(struct bm_portal *p, u32 offset, u32 val)\r\n{\r\n__raw_writel(cpu_to_be32(val), p->addr.ci + offset);\r\n}\r\nstatic inline void bm_cl_invalidate(struct bm_portal *p, u32 offset)\r\n{\r\ndpaa_invalidate(p->addr.ce + offset);\r\n}\r\nstatic inline void bm_cl_touch_ro(struct bm_portal *p, u32 offset)\r\n{\r\ndpaa_touch_ro(p->addr.ce + offset);\r\n}\r\nstatic inline u32 bm_ce_in(struct bm_portal *p, u32 offset)\r\n{\r\nreturn be32_to_cpu(__raw_readl(p->addr.ce + offset));\r\n}\r\nstatic inline struct bman_portal *get_affine_portal(void)\r\n{\r\nreturn &get_cpu_var(bman_affine_portal);\r\n}\r\nstatic inline void put_affine_portal(void)\r\n{\r\nput_cpu_var(bman_affine_portal);\r\n}\r\nstatic irqreturn_t portal_isr(int irq, void *ptr)\r\n{\r\nstruct bman_portal *p = ptr;\r\nstruct bm_portal *portal = &p->p;\r\nu32 clear = p->irq_sources;\r\nu32 is = bm_in(portal, BM_REG_ISR) & p->irq_sources;\r\nif (unlikely(!is))\r\nreturn IRQ_NONE;\r\nclear |= poll_portal_slow(p, is);\r\nbm_out(portal, BM_REG_ISR, clear);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct bm_rcr_entry *rcr_carryclear(struct bm_rcr_entry *p)\r\n{\r\nuintptr_t addr = (uintptr_t)p;\r\naddr &= ~RCR_CARRY;\r\nreturn (struct bm_rcr_entry *)addr;\r\n}\r\nstatic int rcr_ptr2idx(struct bm_rcr_entry *e)\r\n{\r\nreturn ((uintptr_t)e >> RCR_SHIFT) & (BM_RCR_SIZE - 1);\r\n}\r\nstatic inline void rcr_inc(struct bm_rcr *rcr)\r\n{\r\nstruct bm_rcr_entry *partial = rcr->cursor + 1;\r\nrcr->cursor = rcr_carryclear(partial);\r\nif (partial != rcr->cursor)\r\nrcr->vbit ^= BM_RCR_VERB_VBIT;\r\n}\r\nstatic int bm_rcr_get_avail(struct bm_portal *portal)\r\n{\r\nstruct bm_rcr *rcr = &portal->rcr;\r\nreturn rcr->available;\r\n}\r\nstatic int bm_rcr_get_fill(struct bm_portal *portal)\r\n{\r\nstruct bm_rcr *rcr = &portal->rcr;\r\nreturn BM_RCR_SIZE - 1 - rcr->available;\r\n}\r\nstatic void bm_rcr_set_ithresh(struct bm_portal *portal, u8 ithresh)\r\n{\r\nstruct bm_rcr *rcr = &portal->rcr;\r\nrcr->ithresh = ithresh;\r\nbm_out(portal, BM_REG_RCR_ITR, ithresh);\r\n}\r\nstatic void bm_rcr_cce_prefetch(struct bm_portal *portal)\r\n{\r\n__maybe_unused struct bm_rcr *rcr = &portal->rcr;\r\nDPAA_ASSERT(rcr->cmode == bm_rcr_cce);\r\nbm_cl_touch_ro(portal, BM_CL_RCR_CI_CENA);\r\n}\r\nstatic u8 bm_rcr_cce_update(struct bm_portal *portal)\r\n{\r\nstruct bm_rcr *rcr = &portal->rcr;\r\nu8 diff, old_ci = rcr->ci;\r\nDPAA_ASSERT(rcr->cmode == bm_rcr_cce);\r\nrcr->ci = bm_ce_in(portal, BM_CL_RCR_CI_CENA) & (BM_RCR_SIZE - 1);\r\nbm_cl_invalidate(portal, BM_CL_RCR_CI_CENA);\r\ndiff = dpaa_cyc_diff(BM_RCR_SIZE, old_ci, rcr->ci);\r\nrcr->available += diff;\r\nreturn diff;\r\n}\r\nstatic inline struct bm_rcr_entry *bm_rcr_start(struct bm_portal *portal)\r\n{\r\nstruct bm_rcr *rcr = &portal->rcr;\r\nDPAA_ASSERT(!rcr->busy);\r\nif (!rcr->available)\r\nreturn NULL;\r\n#ifdef CONFIG_FSL_DPAA_CHECKING\r\nrcr->busy = 1;\r\n#endif\r\ndpaa_zero(rcr->cursor);\r\nreturn rcr->cursor;\r\n}\r\nstatic inline void bm_rcr_pvb_commit(struct bm_portal *portal, u8 myverb)\r\n{\r\nstruct bm_rcr *rcr = &portal->rcr;\r\nstruct bm_rcr_entry *rcursor;\r\nDPAA_ASSERT(rcr->busy);\r\nDPAA_ASSERT(rcr->pmode == bm_rcr_pvb);\r\nDPAA_ASSERT(rcr->available >= 1);\r\ndma_wmb();\r\nrcursor = rcr->cursor;\r\nrcursor->_ncw_verb = myverb | rcr->vbit;\r\ndpaa_flush(rcursor);\r\nrcr_inc(rcr);\r\nrcr->available--;\r\n#ifdef CONFIG_FSL_DPAA_CHECKING\r\nrcr->busy = 0;\r\n#endif\r\n}\r\nstatic int bm_rcr_init(struct bm_portal *portal, enum bm_rcr_pmode pmode,\r\nenum bm_rcr_cmode cmode)\r\n{\r\nstruct bm_rcr *rcr = &portal->rcr;\r\nu32 cfg;\r\nu8 pi;\r\nrcr->ring = portal->addr.ce + BM_CL_RCR;\r\nrcr->ci = bm_in(portal, BM_REG_RCR_CI_CINH) & (BM_RCR_SIZE - 1);\r\npi = bm_in(portal, BM_REG_RCR_PI_CINH) & (BM_RCR_SIZE - 1);\r\nrcr->cursor = rcr->ring + pi;\r\nrcr->vbit = (bm_in(portal, BM_REG_RCR_PI_CINH) & BM_RCR_SIZE) ?\r\nBM_RCR_VERB_VBIT : 0;\r\nrcr->available = BM_RCR_SIZE - 1\r\n- dpaa_cyc_diff(BM_RCR_SIZE, rcr->ci, pi);\r\nrcr->ithresh = bm_in(portal, BM_REG_RCR_ITR);\r\n#ifdef CONFIG_FSL_DPAA_CHECKING\r\nrcr->busy = 0;\r\nrcr->pmode = pmode;\r\nrcr->cmode = cmode;\r\n#endif\r\ncfg = (bm_in(portal, BM_REG_CFG) & 0xffffffe0)\r\n| (pmode & 0x3);\r\nbm_out(portal, BM_REG_CFG, cfg);\r\nreturn 0;\r\n}\r\nstatic void bm_rcr_finish(struct bm_portal *portal)\r\n{\r\n#ifdef CONFIG_FSL_DPAA_CHECKING\r\nstruct bm_rcr *rcr = &portal->rcr;\r\nint i;\r\nDPAA_ASSERT(!rcr->busy);\r\ni = bm_in(portal, BM_REG_RCR_PI_CINH) & (BM_RCR_SIZE - 1);\r\nif (i != rcr_ptr2idx(rcr->cursor))\r\npr_crit("losing uncommitted RCR entries\n");\r\ni = bm_in(portal, BM_REG_RCR_CI_CINH) & (BM_RCR_SIZE - 1);\r\nif (i != rcr->ci)\r\npr_crit("missing existing RCR completions\n");\r\nif (rcr->ci != rcr_ptr2idx(rcr->cursor))\r\npr_crit("RCR destroyed unquiesced\n");\r\n#endif\r\n}\r\nstatic int bm_mc_init(struct bm_portal *portal)\r\n{\r\nstruct bm_mc *mc = &portal->mc;\r\nmc->cr = portal->addr.ce + BM_CL_CR;\r\nmc->rr = portal->addr.ce + BM_CL_RR0;\r\nmc->rridx = (__raw_readb(&mc->cr->_ncw_verb) & BM_MCC_VERB_VBIT) ?\r\n0 : 1;\r\nmc->vbit = mc->rridx ? BM_MCC_VERB_VBIT : 0;\r\n#ifdef CONFIG_FSL_DPAA_CHECKING\r\nmc->state = mc_idle;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void bm_mc_finish(struct bm_portal *portal)\r\n{\r\n#ifdef CONFIG_FSL_DPAA_CHECKING\r\nstruct bm_mc *mc = &portal->mc;\r\nDPAA_ASSERT(mc->state == mc_idle);\r\nif (mc->state != mc_idle)\r\npr_crit("Losing incomplete MC command\n");\r\n#endif\r\n}\r\nstatic inline struct bm_mc_command *bm_mc_start(struct bm_portal *portal)\r\n{\r\nstruct bm_mc *mc = &portal->mc;\r\nDPAA_ASSERT(mc->state == mc_idle);\r\n#ifdef CONFIG_FSL_DPAA_CHECKING\r\nmc->state = mc_user;\r\n#endif\r\ndpaa_zero(mc->cr);\r\nreturn mc->cr;\r\n}\r\nstatic inline void bm_mc_commit(struct bm_portal *portal, u8 myverb)\r\n{\r\nstruct bm_mc *mc = &portal->mc;\r\nunion bm_mc_result *rr = mc->rr + mc->rridx;\r\nDPAA_ASSERT(mc->state == mc_user);\r\ndma_wmb();\r\nmc->cr->_ncw_verb = myverb | mc->vbit;\r\ndpaa_flush(mc->cr);\r\ndpaa_invalidate_touch_ro(rr);\r\n#ifdef CONFIG_FSL_DPAA_CHECKING\r\nmc->state = mc_hw;\r\n#endif\r\n}\r\nstatic inline union bm_mc_result *bm_mc_result(struct bm_portal *portal)\r\n{\r\nstruct bm_mc *mc = &portal->mc;\r\nunion bm_mc_result *rr = mc->rr + mc->rridx;\r\nDPAA_ASSERT(mc->state == mc_hw);\r\nif (!__raw_readb(&rr->verb)) {\r\ndpaa_invalidate_touch_ro(rr);\r\nreturn NULL;\r\n}\r\nmc->rridx ^= 1;\r\nmc->vbit ^= BM_MCC_VERB_VBIT;\r\n#ifdef CONFIG_FSL_DPAA_CHECKING\r\nmc->state = mc_idle;\r\n#endif\r\nreturn rr;\r\n}\r\nstatic inline int bm_mc_result_timeout(struct bm_portal *portal,\r\nunion bm_mc_result **mcr)\r\n{\r\nint timeout = BM_MCR_TIMEOUT;\r\ndo {\r\n*mcr = bm_mc_result(portal);\r\nif (*mcr)\r\nbreak;\r\nudelay(1);\r\n} while (--timeout);\r\nreturn timeout;\r\n}\r\nstatic void bm_isr_bscn_disable(struct bm_portal *portal)\r\n{\r\nbm_out(portal, BM_REG_SCN(0), 0);\r\nbm_out(portal, BM_REG_SCN(1), 0);\r\n}\r\nstatic int bman_create_portal(struct bman_portal *portal,\r\nconst struct bm_portal_config *c)\r\n{\r\nstruct bm_portal *p;\r\nint ret;\r\np = &portal->p;\r\np->addr.ce = c->addr_virt[DPAA_PORTAL_CE];\r\np->addr.ci = c->addr_virt[DPAA_PORTAL_CI];\r\nif (bm_rcr_init(p, bm_rcr_pvb, bm_rcr_cce)) {\r\ndev_err(c->dev, "RCR initialisation failed\n");\r\ngoto fail_rcr;\r\n}\r\nif (bm_mc_init(p)) {\r\ndev_err(c->dev, "MC initialisation failed\n");\r\ngoto fail_mc;\r\n}\r\nbm_isr_bscn_disable(p);\r\nbm_out(p, BM_REG_ISDR, 0xffffffff);\r\nportal->irq_sources = 0;\r\nbm_out(p, BM_REG_IER, 0);\r\nbm_out(p, BM_REG_ISR, 0xffffffff);\r\nsnprintf(portal->irqname, MAX_IRQNAME, IRQNAME, c->cpu);\r\nif (request_irq(c->irq, portal_isr, 0, portal->irqname, portal)) {\r\ndev_err(c->dev, "request_irq() failed\n");\r\ngoto fail_irq;\r\n}\r\nif (c->cpu != -1 && irq_can_set_affinity(c->irq) &&\r\nirq_set_affinity(c->irq, cpumask_of(c->cpu))) {\r\ndev_err(c->dev, "irq_set_affinity() failed\n");\r\ngoto fail_affinity;\r\n}\r\nret = bm_rcr_get_fill(p);\r\nif (ret) {\r\ndev_err(c->dev, "RCR unclean\n");\r\ngoto fail_rcr_empty;\r\n}\r\nportal->config = c;\r\nbm_out(p, BM_REG_ISDR, 0);\r\nbm_out(p, BM_REG_IIR, 0);\r\nreturn 0;\r\nfail_rcr_empty:\r\nfail_affinity:\r\nfree_irq(c->irq, portal);\r\nfail_irq:\r\nbm_mc_finish(p);\r\nfail_mc:\r\nbm_rcr_finish(p);\r\nfail_rcr:\r\nreturn -EIO;\r\n}\r\nstruct bman_portal *bman_create_affine_portal(const struct bm_portal_config *c)\r\n{\r\nstruct bman_portal *portal;\r\nint err;\r\nportal = &per_cpu(bman_affine_portal, c->cpu);\r\nerr = bman_create_portal(portal, c);\r\nif (err)\r\nreturn NULL;\r\nspin_lock(&affine_mask_lock);\r\ncpumask_set_cpu(c->cpu, &affine_mask);\r\nspin_unlock(&affine_mask_lock);\r\nreturn portal;\r\n}\r\nstatic u32 poll_portal_slow(struct bman_portal *p, u32 is)\r\n{\r\nu32 ret = is;\r\nif (is & BM_PIRQ_RCRI) {\r\nbm_rcr_cce_update(&p->p);\r\nbm_rcr_set_ithresh(&p->p, 0);\r\nbm_out(&p->p, BM_REG_ISR, BM_PIRQ_RCRI);\r\nis &= ~BM_PIRQ_RCRI;\r\n}\r\nDPAA_ASSERT(!is);\r\nreturn ret;\r\n}\r\nint bman_p_irqsource_add(struct bman_portal *p, u32 bits)\r\n{\r\nunsigned long irqflags;\r\nlocal_irq_save(irqflags);\r\nset_bits(bits & BM_PIRQ_VISIBLE, &p->irq_sources);\r\nbm_out(&p->p, BM_REG_IER, p->irq_sources);\r\nlocal_irq_restore(irqflags);\r\nreturn 0;\r\n}\r\nstatic int bm_shutdown_pool(u32 bpid)\r\n{\r\nstruct bm_mc_command *bm_cmd;\r\nunion bm_mc_result *bm_res;\r\nwhile (1) {\r\nstruct bman_portal *p = get_affine_portal();\r\nbm_cmd = bm_mc_start(&p->p);\r\nbm_cmd->bpid = bpid;\r\nbm_mc_commit(&p->p, BM_MCC_VERB_CMD_ACQUIRE | 1);\r\nif (!bm_mc_result_timeout(&p->p, &bm_res)) {\r\nput_affine_portal();\r\npr_crit("BMan Acquire Command timedout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!(bm_res->verb & BM_MCR_VERB_ACQUIRE_BUFCOUNT)) {\r\nput_affine_portal();\r\nreturn 0;\r\n}\r\nput_affine_portal();\r\n}\r\nreturn 0;\r\n}\r\nstatic int bm_alloc_bpid_range(u32 *result, u32 count)\r\n{\r\nunsigned long addr;\r\naddr = gen_pool_alloc(bm_bpalloc, count);\r\nif (!addr)\r\nreturn -ENOMEM;\r\n*result = addr & ~DPAA_GENALLOC_OFF;\r\nreturn 0;\r\n}\r\nstatic int bm_release_bpid(u32 bpid)\r\n{\r\nint ret;\r\nret = bm_shutdown_pool(bpid);\r\nif (ret) {\r\npr_debug("BPID %d leaked\n", bpid);\r\nreturn ret;\r\n}\r\ngen_pool_free(bm_bpalloc, bpid | DPAA_GENALLOC_OFF, 1);\r\nreturn 0;\r\n}\r\nstruct bman_pool *bman_new_pool(void)\r\n{\r\nstruct bman_pool *pool = NULL;\r\nu32 bpid;\r\nif (bm_alloc_bpid_range(&bpid, 1))\r\nreturn NULL;\r\npool = kmalloc(sizeof(*pool), GFP_KERNEL);\r\nif (!pool)\r\ngoto err;\r\npool->bpid = bpid;\r\nreturn pool;\r\nerr:\r\nbm_release_bpid(bpid);\r\nkfree(pool);\r\nreturn NULL;\r\n}\r\nvoid bman_free_pool(struct bman_pool *pool)\r\n{\r\nbm_release_bpid(pool->bpid);\r\nkfree(pool);\r\n}\r\nint bman_get_bpid(const struct bman_pool *pool)\r\n{\r\nreturn pool->bpid;\r\n}\r\nstatic void update_rcr_ci(struct bman_portal *p, int avail)\r\n{\r\nif (avail)\r\nbm_rcr_cce_prefetch(&p->p);\r\nelse\r\nbm_rcr_cce_update(&p->p);\r\n}\r\nint bman_release(struct bman_pool *pool, const struct bm_buffer *bufs, u8 num)\r\n{\r\nstruct bman_portal *p;\r\nstruct bm_rcr_entry *r;\r\nunsigned long irqflags;\r\nint avail, timeout = 1000;\r\nint i = num - 1;\r\nDPAA_ASSERT(num > 0 && num <= 8);\r\ndo {\r\np = get_affine_portal();\r\nlocal_irq_save(irqflags);\r\navail = bm_rcr_get_avail(&p->p);\r\nif (avail < 2)\r\nupdate_rcr_ci(p, avail);\r\nr = bm_rcr_start(&p->p);\r\nlocal_irq_restore(irqflags);\r\nput_affine_portal();\r\nif (likely(r))\r\nbreak;\r\nudelay(1);\r\n} while (--timeout);\r\nif (unlikely(!timeout))\r\nreturn -ETIMEDOUT;\r\np = get_affine_portal();\r\nlocal_irq_save(irqflags);\r\nbm_buffer_set64(r->bufs, bm_buffer_get64(bufs));\r\nbm_buffer_set_bpid(r->bufs, pool->bpid);\r\nif (i)\r\nmemcpy(&r->bufs[1], &bufs[1], i * sizeof(bufs[0]));\r\nbm_rcr_pvb_commit(&p->p, BM_RCR_VERB_CMD_BPID_SINGLE |\r\n(num & BM_RCR_VERB_BUFCOUNT_MASK));\r\nlocal_irq_restore(irqflags);\r\nput_affine_portal();\r\nreturn 0;\r\n}\r\nint bman_acquire(struct bman_pool *pool, struct bm_buffer *bufs, u8 num)\r\n{\r\nstruct bman_portal *p = get_affine_portal();\r\nstruct bm_mc_command *mcc;\r\nunion bm_mc_result *mcr;\r\nint ret;\r\nDPAA_ASSERT(num > 0 && num <= 8);\r\nmcc = bm_mc_start(&p->p);\r\nmcc->bpid = pool->bpid;\r\nbm_mc_commit(&p->p, BM_MCC_VERB_CMD_ACQUIRE |\r\n(num & BM_MCC_VERB_ACQUIRE_BUFCOUNT));\r\nif (!bm_mc_result_timeout(&p->p, &mcr)) {\r\nput_affine_portal();\r\npr_crit("BMan Acquire Timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nret = mcr->verb & BM_MCR_VERB_ACQUIRE_BUFCOUNT;\r\nif (bufs)\r\nmemcpy(&bufs[0], &mcr->bufs[0], num * sizeof(bufs[0]));\r\nput_affine_portal();\r\nif (ret != num)\r\nret = -ENOMEM;\r\nreturn ret;\r\n}\r\nconst struct bm_portal_config *\r\nbman_get_bm_portal_config(const struct bman_portal *portal)\r\n{\r\nreturn portal->config;\r\n}
