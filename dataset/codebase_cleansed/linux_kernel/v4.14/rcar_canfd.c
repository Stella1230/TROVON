static inline void rcar_canfd_update(u32 mask, u32 val, u32 __iomem *reg)\r\n{\r\nu32 data = readl(reg);\r\ndata &= ~mask;\r\ndata |= (val & mask);\r\nwritel(data, reg);\r\n}\r\nstatic inline u32 rcar_canfd_read(void __iomem *base, u32 offset)\r\n{\r\nreturn readl(base + (offset));\r\n}\r\nstatic inline void rcar_canfd_write(void __iomem *base, u32 offset, u32 val)\r\n{\r\nwritel(val, base + (offset));\r\n}\r\nstatic void rcar_canfd_set_bit(void __iomem *base, u32 reg, u32 val)\r\n{\r\nrcar_canfd_update(val, val, base + (reg));\r\n}\r\nstatic void rcar_canfd_clear_bit(void __iomem *base, u32 reg, u32 val)\r\n{\r\nrcar_canfd_update(val, 0, base + (reg));\r\n}\r\nstatic void rcar_canfd_update_bit(void __iomem *base, u32 reg,\r\nu32 mask, u32 val)\r\n{\r\nrcar_canfd_update(mask, val, base + (reg));\r\n}\r\nstatic void rcar_canfd_get_data(struct rcar_canfd_channel *priv,\r\nstruct canfd_frame *cf, u32 off)\r\n{\r\nu32 i, lwords;\r\nlwords = DIV_ROUND_UP(cf->len, sizeof(u32));\r\nfor (i = 0; i < lwords; i++)\r\n*((u32 *)cf->data + i) =\r\nrcar_canfd_read(priv->base, off + (i * sizeof(u32)));\r\n}\r\nstatic void rcar_canfd_put_data(struct rcar_canfd_channel *priv,\r\nstruct canfd_frame *cf, u32 off)\r\n{\r\nu32 i, lwords;\r\nlwords = DIV_ROUND_UP(cf->len, sizeof(u32));\r\nfor (i = 0; i < lwords; i++)\r\nrcar_canfd_write(priv->base, off + (i * sizeof(u32)),\r\n*((u32 *)cf->data + i));\r\n}\r\nstatic void rcar_canfd_tx_failure_cleanup(struct net_device *ndev)\r\n{\r\nu32 i;\r\nfor (i = 0; i < RCANFD_FIFO_DEPTH; i++)\r\ncan_free_echo_skb(ndev, i);\r\n}\r\nstatic int rcar_canfd_reset_controller(struct rcar_canfd_global *gpriv)\r\n{\r\nu32 sts, ch;\r\nint err;\r\nerr = readl_poll_timeout((gpriv->base + RCANFD_GSTS), sts,\r\n!(sts & RCANFD_GSTS_GRAMINIT), 2, 500000);\r\nif (err) {\r\ndev_dbg(&gpriv->pdev->dev, "global raminit failed\n");\r\nreturn err;\r\n}\r\nrcar_canfd_clear_bit(gpriv->base, RCANFD_GCTR, RCANFD_GCTR_GSLPR);\r\nrcar_canfd_update_bit(gpriv->base, RCANFD_GCTR,\r\nRCANFD_GCTR_GMDC_MASK, RCANFD_GCTR_GMDC_GRESET);\r\nerr = readl_poll_timeout((gpriv->base + RCANFD_GSTS), sts,\r\n(sts & RCANFD_GSTS_GRSTSTS), 2, 500000);\r\nif (err) {\r\ndev_dbg(&gpriv->pdev->dev, "global reset failed\n");\r\nreturn err;\r\n}\r\nrcar_canfd_write(gpriv->base, RCANFD_GERFL, 0x0);\r\nif (gpriv->fdmode)\r\nrcar_canfd_set_bit(gpriv->base, RCANFD_GRMCFG,\r\nRCANFD_GRMCFG_RCMC);\r\nelse\r\nrcar_canfd_clear_bit(gpriv->base, RCANFD_GRMCFG,\r\nRCANFD_GRMCFG_RCMC);\r\nfor_each_set_bit(ch, &gpriv->channels_mask, RCANFD_NUM_CHANNELS) {\r\nrcar_canfd_clear_bit(gpriv->base,\r\nRCANFD_CCTR(ch), RCANFD_CCTR_CSLPR);\r\nrcar_canfd_update_bit(gpriv->base, RCANFD_CCTR(ch),\r\nRCANFD_CCTR_CHMDC_MASK,\r\nRCANFD_CCTR_CHDMC_CRESET);\r\nerr = readl_poll_timeout((gpriv->base + RCANFD_CSTS(ch)), sts,\r\n(sts & RCANFD_CSTS_CRSTSTS),\r\n2, 500000);\r\nif (err) {\r\ndev_dbg(&gpriv->pdev->dev,\r\n"channel %u reset failed\n", ch);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void rcar_canfd_configure_controller(struct rcar_canfd_global *gpriv)\r\n{\r\nu32 cfg, ch;\r\ncfg = RCANFD_GCFG_EEFE;\r\nif (gpriv->fdmode)\r\ncfg |= RCANFD_GCFG_CMPOC;\r\nif (gpriv->fcan != RCANFD_CANFDCLK)\r\ncfg |= RCANFD_GCFG_DCS;\r\nrcar_canfd_set_bit(gpriv->base, RCANFD_GCFG, cfg);\r\nfor_each_set_bit(ch, &gpriv->channels_mask, RCANFD_NUM_CHANNELS) {\r\nrcar_canfd_set_bit(gpriv->base, RCANFD_CCTR(ch),\r\nRCANFD_CCTR_ERRD);\r\nrcar_canfd_update_bit(gpriv->base, RCANFD_CCTR(ch),\r\nRCANFD_CCTR_BOM_MASK,\r\nRCANFD_CCTR_BOM_BENTRY);\r\n}\r\n}\r\nstatic void rcar_canfd_configure_afl_rules(struct rcar_canfd_global *gpriv,\r\nu32 ch)\r\n{\r\nu32 cfg;\r\nint offset, start, page, num_rules = RCANFD_CHANNEL_NUMRULES;\r\nu32 ridx = ch + RCANFD_RFFIFO_IDX;\r\nif (ch == 0) {\r\nstart = 0;\r\n} else {\r\ncfg = rcar_canfd_read(gpriv->base, RCANFD_GAFLCFG0);\r\nstart = RCANFD_GAFLCFG_GETRNC(0, cfg);\r\n}\r\npage = RCANFD_GAFL_PAGENUM(start);\r\nrcar_canfd_set_bit(gpriv->base, RCANFD_GAFLECTR,\r\n(RCANFD_GAFLECTR_AFLPN(page) |\r\nRCANFD_GAFLECTR_AFLDAE));\r\nrcar_canfd_set_bit(gpriv->base, RCANFD_GAFLCFG0,\r\nRCANFD_GAFLCFG_SETRNC(ch, num_rules));\r\nif (gpriv->fdmode)\r\noffset = RCANFD_F_GAFL_OFFSET;\r\nelse\r\noffset = RCANFD_C_GAFL_OFFSET;\r\nrcar_canfd_write(gpriv->base, RCANFD_GAFLID(offset, start), 0);\r\nrcar_canfd_write(gpriv->base, RCANFD_GAFLM(offset, start), 0);\r\nrcar_canfd_write(gpriv->base, RCANFD_GAFLP0(offset, start), 0);\r\nrcar_canfd_write(gpriv->base, RCANFD_GAFLP1(offset, start),\r\nRCANFD_GAFLP1_GAFLFDP(ridx));\r\nrcar_canfd_clear_bit(gpriv->base,\r\nRCANFD_GAFLECTR, RCANFD_GAFLECTR_AFLDAE);\r\n}\r\nstatic void rcar_canfd_configure_rx(struct rcar_canfd_global *gpriv, u32 ch)\r\n{\r\nu32 cfg;\r\nu16 rfdc, rfpls;\r\nu32 ridx = ch + RCANFD_RFFIFO_IDX;\r\nrfdc = 2;\r\nif (gpriv->fdmode)\r\nrfpls = 7;\r\nelse\r\nrfpls = 0;\r\ncfg = (RCANFD_RFCC_RFIM | RCANFD_RFCC_RFDC(rfdc) |\r\nRCANFD_RFCC_RFPLS(rfpls) | RCANFD_RFCC_RFIE);\r\nrcar_canfd_write(gpriv->base, RCANFD_RFCC(ridx), cfg);\r\n}\r\nstatic void rcar_canfd_configure_tx(struct rcar_canfd_global *gpriv, u32 ch)\r\n{\r\nu32 cfg;\r\nu16 cftml, cfm, cfdc, cfpls;\r\ncftml = 0;\r\ncfm = 1;\r\ncfdc = 2;\r\nif (gpriv->fdmode)\r\ncfpls = 7;\r\nelse\r\ncfpls = 0;\r\ncfg = (RCANFD_CFCC_CFTML(cftml) | RCANFD_CFCC_CFM(cfm) |\r\nRCANFD_CFCC_CFIM | RCANFD_CFCC_CFDC(cfdc) |\r\nRCANFD_CFCC_CFPLS(cfpls) | RCANFD_CFCC_CFTXIE);\r\nrcar_canfd_write(gpriv->base, RCANFD_CFCC(ch, RCANFD_CFFIFO_IDX), cfg);\r\nif (gpriv->fdmode)\r\nrcar_canfd_write(gpriv->base,\r\nRCANFD_F_CFFDCSTS(ch, RCANFD_CFFIFO_IDX), 0);\r\n}\r\nstatic void rcar_canfd_enable_global_interrupts(struct rcar_canfd_global *gpriv)\r\n{\r\nu32 ctr;\r\nrcar_canfd_write(gpriv->base, RCANFD_GERFL, 0);\r\nctr = RCANFD_GCTR_MEIE;\r\nif (gpriv->fdmode)\r\nctr |= RCANFD_GCTR_CFMPOFIE;\r\nrcar_canfd_set_bit(gpriv->base, RCANFD_GCTR, ctr);\r\n}\r\nstatic void rcar_canfd_disable_global_interrupts(struct rcar_canfd_global\r\n*gpriv)\r\n{\r\nrcar_canfd_write(gpriv->base, RCANFD_GCTR, 0);\r\nrcar_canfd_write(gpriv->base, RCANFD_GERFL, 0);\r\n}\r\nstatic void rcar_canfd_enable_channel_interrupts(struct rcar_canfd_channel\r\n*priv)\r\n{\r\nu32 ctr, ch = priv->channel;\r\nrcar_canfd_write(priv->base, RCANFD_CERFL(ch), 0);\r\nctr = (RCANFD_CCTR_TAIE |\r\nRCANFD_CCTR_ALIE | RCANFD_CCTR_BLIE |\r\nRCANFD_CCTR_OLIE | RCANFD_CCTR_BORIE |\r\nRCANFD_CCTR_BOEIE | RCANFD_CCTR_EPIE |\r\nRCANFD_CCTR_EWIE | RCANFD_CCTR_BEIE);\r\nrcar_canfd_set_bit(priv->base, RCANFD_CCTR(ch), ctr);\r\n}\r\nstatic void rcar_canfd_disable_channel_interrupts(struct rcar_canfd_channel\r\n*priv)\r\n{\r\nu32 ctr, ch = priv->channel;\r\nctr = (RCANFD_CCTR_TAIE |\r\nRCANFD_CCTR_ALIE | RCANFD_CCTR_BLIE |\r\nRCANFD_CCTR_OLIE | RCANFD_CCTR_BORIE |\r\nRCANFD_CCTR_BOEIE | RCANFD_CCTR_EPIE |\r\nRCANFD_CCTR_EWIE | RCANFD_CCTR_BEIE);\r\nrcar_canfd_clear_bit(priv->base, RCANFD_CCTR(ch), ctr);\r\nrcar_canfd_write(priv->base, RCANFD_CERFL(ch), 0);\r\n}\r\nstatic void rcar_canfd_global_error(struct net_device *ndev)\r\n{\r\nstruct rcar_canfd_channel *priv = netdev_priv(ndev);\r\nstruct rcar_canfd_global *gpriv = priv->gpriv;\r\nstruct net_device_stats *stats = &ndev->stats;\r\nu32 ch = priv->channel;\r\nu32 gerfl, sts;\r\nu32 ridx = ch + RCANFD_RFFIFO_IDX;\r\ngerfl = rcar_canfd_read(priv->base, RCANFD_GERFL);\r\nif ((gerfl & RCANFD_GERFL_EEF0) && (ch == 0)) {\r\nnetdev_dbg(ndev, "Ch0: ECC Error flag\n");\r\nstats->tx_dropped++;\r\n}\r\nif ((gerfl & RCANFD_GERFL_EEF1) && (ch == 1)) {\r\nnetdev_dbg(ndev, "Ch1: ECC Error flag\n");\r\nstats->tx_dropped++;\r\n}\r\nif (gerfl & RCANFD_GERFL_MES) {\r\nsts = rcar_canfd_read(priv->base,\r\nRCANFD_CFSTS(ch, RCANFD_CFFIFO_IDX));\r\nif (sts & RCANFD_CFSTS_CFMLT) {\r\nnetdev_dbg(ndev, "Tx Message Lost flag\n");\r\nstats->tx_dropped++;\r\nrcar_canfd_write(priv->base,\r\nRCANFD_CFSTS(ch, RCANFD_CFFIFO_IDX),\r\nsts & ~RCANFD_CFSTS_CFMLT);\r\n}\r\nsts = rcar_canfd_read(priv->base, RCANFD_RFSTS(ridx));\r\nif (sts & RCANFD_RFSTS_RFMLT) {\r\nnetdev_dbg(ndev, "Rx Message Lost flag\n");\r\nstats->rx_dropped++;\r\nrcar_canfd_write(priv->base, RCANFD_RFSTS(ridx),\r\nsts & ~RCANFD_RFSTS_RFMLT);\r\n}\r\n}\r\nif (gpriv->fdmode && gerfl & RCANFD_GERFL_CMPOF) {\r\nnetdev_dbg(ndev, "global payload overflow interrupt\n");\r\n}\r\nrcar_canfd_write(priv->base, RCANFD_GERFL, 0);\r\n}\r\nstatic void rcar_canfd_error(struct net_device *ndev, u32 cerfl,\r\nu16 txerr, u16 rxerr)\r\n{\r\nstruct rcar_canfd_channel *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &ndev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nu32 ch = priv->channel;\r\nnetdev_dbg(ndev, "ch erfl %x txerr %u rxerr %u\n", cerfl, txerr, rxerr);\r\nskb = alloc_can_err_skb(ndev, &cf);\r\nif (!skb) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\nif (cerfl & RCANFD_CERFL_BEF) {\r\nnetdev_dbg(ndev, "Bus error\n");\r\ncf->can_id |= CAN_ERR_BUSERROR | CAN_ERR_PROT;\r\ncf->data[2] = CAN_ERR_PROT_UNSPEC;\r\npriv->can.can_stats.bus_error++;\r\n}\r\nif (cerfl & RCANFD_CERFL_ADERR) {\r\nnetdev_dbg(ndev, "ACK Delimiter Error\n");\r\nstats->tx_errors++;\r\ncf->data[3] |= CAN_ERR_PROT_LOC_ACK_DEL;\r\n}\r\nif (cerfl & RCANFD_CERFL_B0ERR) {\r\nnetdev_dbg(ndev, "Bit Error (dominant)\n");\r\nstats->tx_errors++;\r\ncf->data[2] |= CAN_ERR_PROT_BIT0;\r\n}\r\nif (cerfl & RCANFD_CERFL_B1ERR) {\r\nnetdev_dbg(ndev, "Bit Error (recessive)\n");\r\nstats->tx_errors++;\r\ncf->data[2] |= CAN_ERR_PROT_BIT1;\r\n}\r\nif (cerfl & RCANFD_CERFL_CERR) {\r\nnetdev_dbg(ndev, "CRC Error\n");\r\nstats->rx_errors++;\r\ncf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;\r\n}\r\nif (cerfl & RCANFD_CERFL_AERR) {\r\nnetdev_dbg(ndev, "ACK Error\n");\r\nstats->tx_errors++;\r\ncf->can_id |= CAN_ERR_ACK;\r\ncf->data[3] |= CAN_ERR_PROT_LOC_ACK;\r\n}\r\nif (cerfl & RCANFD_CERFL_FERR) {\r\nnetdev_dbg(ndev, "Form Error\n");\r\nstats->rx_errors++;\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\n}\r\nif (cerfl & RCANFD_CERFL_SERR) {\r\nnetdev_dbg(ndev, "Stuff Error\n");\r\nstats->rx_errors++;\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\n}\r\nif (cerfl & RCANFD_CERFL_ALF) {\r\nnetdev_dbg(ndev, "Arbitration lost Error\n");\r\npriv->can.can_stats.arbitration_lost++;\r\ncf->can_id |= CAN_ERR_LOSTARB;\r\ncf->data[0] |= CAN_ERR_LOSTARB_UNSPEC;\r\n}\r\nif (cerfl & RCANFD_CERFL_BLF) {\r\nnetdev_dbg(ndev, "Bus Lock Error\n");\r\nstats->rx_errors++;\r\ncf->can_id |= CAN_ERR_BUSERROR;\r\n}\r\nif (cerfl & RCANFD_CERFL_EWF) {\r\nnetdev_dbg(ndev, "Error warning interrupt\n");\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\npriv->can.can_stats.error_warning++;\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = txerr > rxerr ? CAN_ERR_CRTL_TX_WARNING :\r\nCAN_ERR_CRTL_RX_WARNING;\r\ncf->data[6] = txerr;\r\ncf->data[7] = rxerr;\r\n}\r\nif (cerfl & RCANFD_CERFL_EPF) {\r\nnetdev_dbg(ndev, "Error passive interrupt\n");\r\npriv->can.state = CAN_STATE_ERROR_PASSIVE;\r\npriv->can.can_stats.error_passive++;\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = txerr > rxerr ? CAN_ERR_CRTL_TX_PASSIVE :\r\nCAN_ERR_CRTL_RX_PASSIVE;\r\ncf->data[6] = txerr;\r\ncf->data[7] = rxerr;\r\n}\r\nif (cerfl & RCANFD_CERFL_BOEF) {\r\nnetdev_dbg(ndev, "Bus-off entry interrupt\n");\r\nrcar_canfd_tx_failure_cleanup(ndev);\r\npriv->can.state = CAN_STATE_BUS_OFF;\r\npriv->can.can_stats.bus_off++;\r\ncan_bus_off(ndev);\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\n}\r\nif (cerfl & RCANFD_CERFL_OVLF) {\r\nnetdev_dbg(ndev,\r\n"Overload Frame Transmission error interrupt\n");\r\nstats->tx_errors++;\r\ncf->can_id |= CAN_ERR_PROT;\r\ncf->data[2] |= CAN_ERR_PROT_OVERLOAD;\r\n}\r\nrcar_canfd_write(priv->base, RCANFD_CERFL(ch),\r\nRCANFD_CERFL_ERR(~cerfl));\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\n}\r\nstatic void rcar_canfd_tx_done(struct net_device *ndev)\r\n{\r\nstruct rcar_canfd_channel *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &ndev->stats;\r\nu32 sts;\r\nunsigned long flags;\r\nu32 ch = priv->channel;\r\ndo {\r\nu8 unsent, sent;\r\nsent = priv->tx_tail % RCANFD_FIFO_DEPTH;\r\nstats->tx_packets++;\r\nstats->tx_bytes += priv->tx_len[sent];\r\npriv->tx_len[sent] = 0;\r\ncan_get_echo_skb(ndev, sent);\r\nspin_lock_irqsave(&priv->tx_lock, flags);\r\npriv->tx_tail++;\r\nsts = rcar_canfd_read(priv->base,\r\nRCANFD_CFSTS(ch, RCANFD_CFFIFO_IDX));\r\nunsent = RCANFD_CFSTS_CFMC(sts);\r\nif (unsent != RCANFD_FIFO_DEPTH)\r\nnetif_wake_queue(ndev);\r\nif (priv->tx_head - priv->tx_tail <= unsent) {\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\n} while (1);\r\nrcar_canfd_write(priv->base, RCANFD_CFSTS(ch, RCANFD_CFFIFO_IDX),\r\nsts & ~RCANFD_CFSTS_CFTXIF);\r\ncan_led_event(ndev, CAN_LED_EVENT_TX);\r\n}\r\nstatic irqreturn_t rcar_canfd_global_interrupt(int irq, void *dev_id)\r\n{\r\nstruct rcar_canfd_global *gpriv = dev_id;\r\nstruct net_device *ndev;\r\nstruct rcar_canfd_channel *priv;\r\nu32 sts, gerfl;\r\nu32 ch, ridx;\r\nfor_each_set_bit(ch, &gpriv->channels_mask, RCANFD_NUM_CHANNELS) {\r\npriv = gpriv->ch[ch];\r\nndev = priv->ndev;\r\nridx = ch + RCANFD_RFFIFO_IDX;\r\ngerfl = rcar_canfd_read(priv->base, RCANFD_GERFL);\r\nif (unlikely(RCANFD_GERFL_ERR(gpriv, gerfl)))\r\nrcar_canfd_global_error(ndev);\r\nsts = rcar_canfd_read(priv->base, RCANFD_RFSTS(ridx));\r\nif (likely(sts & RCANFD_RFSTS_RFIF)) {\r\nif (napi_schedule_prep(&priv->napi)) {\r\nrcar_canfd_clear_bit(priv->base,\r\nRCANFD_RFCC(ridx),\r\nRCANFD_RFCC_RFIE);\r\n__napi_schedule(&priv->napi);\r\n}\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void rcar_canfd_state_change(struct net_device *ndev,\r\nu16 txerr, u16 rxerr)\r\n{\r\nstruct rcar_canfd_channel *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &ndev->stats;\r\nenum can_state rx_state, tx_state, state = priv->can.state;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nif (txerr < 96 && rxerr < 96)\r\nstate = CAN_STATE_ERROR_ACTIVE;\r\nelse if (txerr < 128 && rxerr < 128)\r\nstate = CAN_STATE_ERROR_WARNING;\r\nif (state != priv->can.state) {\r\nnetdev_dbg(ndev, "state: new %d, old %d: txerr %u, rxerr %u\n",\r\nstate, priv->can.state, txerr, rxerr);\r\nskb = alloc_can_err_skb(ndev, &cf);\r\nif (!skb) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\ntx_state = txerr >= rxerr ? state : 0;\r\nrx_state = txerr <= rxerr ? state : 0;\r\ncan_change_state(ndev, cf, tx_state, rx_state);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\n}\r\n}\r\nstatic irqreturn_t rcar_canfd_channel_interrupt(int irq, void *dev_id)\r\n{\r\nstruct rcar_canfd_global *gpriv = dev_id;\r\nstruct net_device *ndev;\r\nstruct rcar_canfd_channel *priv;\r\nu32 sts, ch, cerfl;\r\nu16 txerr, rxerr;\r\nfor_each_set_bit(ch, &gpriv->channels_mask, RCANFD_NUM_CHANNELS) {\r\npriv = gpriv->ch[ch];\r\nndev = priv->ndev;\r\ncerfl = rcar_canfd_read(priv->base, RCANFD_CERFL(ch));\r\nsts = rcar_canfd_read(priv->base, RCANFD_CSTS(ch));\r\ntxerr = RCANFD_CSTS_TECCNT(sts);\r\nrxerr = RCANFD_CSTS_RECCNT(sts);\r\nif (unlikely(RCANFD_CERFL_ERR(cerfl)))\r\nrcar_canfd_error(ndev, cerfl, txerr, rxerr);\r\nif (unlikely((priv->can.state != CAN_STATE_ERROR_ACTIVE) &&\r\n(priv->can.state != CAN_STATE_BUS_OFF)))\r\nrcar_canfd_state_change(ndev, txerr, rxerr);\r\nsts = rcar_canfd_read(priv->base,\r\nRCANFD_CFSTS(ch, RCANFD_CFFIFO_IDX));\r\nif (likely(sts & RCANFD_CFSTS_CFTXIF))\r\nrcar_canfd_tx_done(ndev);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void rcar_canfd_set_bittiming(struct net_device *dev)\r\n{\r\nstruct rcar_canfd_channel *priv = netdev_priv(dev);\r\nconst struct can_bittiming *bt = &priv->can.bittiming;\r\nconst struct can_bittiming *dbt = &priv->can.data_bittiming;\r\nu16 brp, sjw, tseg1, tseg2;\r\nu32 cfg;\r\nu32 ch = priv->channel;\r\nbrp = bt->brp - 1;\r\nsjw = bt->sjw - 1;\r\ntseg1 = bt->prop_seg + bt->phase_seg1 - 1;\r\ntseg2 = bt->phase_seg2 - 1;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_FD) {\r\ncfg = (RCANFD_NCFG_NTSEG1(tseg1) | RCANFD_NCFG_NBRP(brp) |\r\nRCANFD_NCFG_NSJW(sjw) | RCANFD_NCFG_NTSEG2(tseg2));\r\nrcar_canfd_write(priv->base, RCANFD_CCFG(ch), cfg);\r\nnetdev_dbg(priv->ndev, "nrate: brp %u, sjw %u, tseg1 %u, tseg2 %u\n",\r\nbrp, sjw, tseg1, tseg2);\r\nbrp = dbt->brp - 1;\r\nsjw = dbt->sjw - 1;\r\ntseg1 = dbt->prop_seg + dbt->phase_seg1 - 1;\r\ntseg2 = dbt->phase_seg2 - 1;\r\ncfg = (RCANFD_DCFG_DTSEG1(tseg1) | RCANFD_DCFG_DBRP(brp) |\r\nRCANFD_DCFG_DSJW(sjw) | RCANFD_DCFG_DTSEG2(tseg2));\r\nrcar_canfd_write(priv->base, RCANFD_F_DCFG(ch), cfg);\r\nnetdev_dbg(priv->ndev, "drate: brp %u, sjw %u, tseg1 %u, tseg2 %u\n",\r\nbrp, sjw, tseg1, tseg2);\r\n} else {\r\ncfg = (RCANFD_CFG_TSEG1(tseg1) | RCANFD_CFG_BRP(brp) |\r\nRCANFD_CFG_SJW(sjw) | RCANFD_CFG_TSEG2(tseg2));\r\nrcar_canfd_write(priv->base, RCANFD_CCFG(ch), cfg);\r\nnetdev_dbg(priv->ndev,\r\n"rate: brp %u, sjw %u, tseg1 %u, tseg2 %u\n",\r\nbrp, sjw, tseg1, tseg2);\r\n}\r\n}\r\nstatic int rcar_canfd_start(struct net_device *ndev)\r\n{\r\nstruct rcar_canfd_channel *priv = netdev_priv(ndev);\r\nint err = -EOPNOTSUPP;\r\nu32 sts, ch = priv->channel;\r\nu32 ridx = ch + RCANFD_RFFIFO_IDX;\r\nrcar_canfd_set_bittiming(ndev);\r\nrcar_canfd_enable_channel_interrupts(priv);\r\nrcar_canfd_update_bit(priv->base, RCANFD_CCTR(ch),\r\nRCANFD_CCTR_CHMDC_MASK, RCANFD_CCTR_CHDMC_COPM);\r\nerr = readl_poll_timeout((priv->base + RCANFD_CSTS(ch)), sts,\r\n(sts & RCANFD_CSTS_COMSTS), 2, 500000);\r\nif (err) {\r\nnetdev_err(ndev, "channel %u communication state failed\n", ch);\r\ngoto fail_mode_change;\r\n}\r\nrcar_canfd_set_bit(priv->base, RCANFD_CFCC(ch, RCANFD_CFFIFO_IDX),\r\nRCANFD_CFCC_CFE);\r\nrcar_canfd_set_bit(priv->base, RCANFD_RFCC(ridx), RCANFD_RFCC_RFE);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn 0;\r\nfail_mode_change:\r\nrcar_canfd_disable_channel_interrupts(priv);\r\nreturn err;\r\n}\r\nstatic int rcar_canfd_open(struct net_device *ndev)\r\n{\r\nstruct rcar_canfd_channel *priv = netdev_priv(ndev);\r\nstruct rcar_canfd_global *gpriv = priv->gpriv;\r\nint err;\r\nerr = clk_prepare_enable(gpriv->can_clk);\r\nif (err) {\r\nnetdev_err(ndev, "failed to enable CAN clock, error %d\n", err);\r\ngoto out_clock;\r\n}\r\nerr = open_candev(ndev);\r\nif (err) {\r\nnetdev_err(ndev, "open_candev() failed, error %d\n", err);\r\ngoto out_can_clock;\r\n}\r\nnapi_enable(&priv->napi);\r\nerr = rcar_canfd_start(ndev);\r\nif (err)\r\ngoto out_close;\r\nnetif_start_queue(ndev);\r\ncan_led_event(ndev, CAN_LED_EVENT_OPEN);\r\nreturn 0;\r\nout_close:\r\nnapi_disable(&priv->napi);\r\nclose_candev(ndev);\r\nout_can_clock:\r\nclk_disable_unprepare(gpriv->can_clk);\r\nout_clock:\r\nreturn err;\r\n}\r\nstatic void rcar_canfd_stop(struct net_device *ndev)\r\n{\r\nstruct rcar_canfd_channel *priv = netdev_priv(ndev);\r\nint err;\r\nu32 sts, ch = priv->channel;\r\nu32 ridx = ch + RCANFD_RFFIFO_IDX;\r\nrcar_canfd_update_bit(priv->base, RCANFD_CCTR(ch),\r\nRCANFD_CCTR_CHMDC_MASK, RCANFD_CCTR_CHDMC_CRESET);\r\nerr = readl_poll_timeout((priv->base + RCANFD_CSTS(ch)), sts,\r\n(sts & RCANFD_CSTS_CRSTSTS), 2, 500000);\r\nif (err)\r\nnetdev_err(ndev, "channel %u reset failed\n", ch);\r\nrcar_canfd_disable_channel_interrupts(priv);\r\nrcar_canfd_clear_bit(priv->base, RCANFD_CFCC(ch, RCANFD_CFFIFO_IDX),\r\nRCANFD_CFCC_CFE);\r\nrcar_canfd_clear_bit(priv->base, RCANFD_RFCC(ridx), RCANFD_RFCC_RFE);\r\npriv->can.state = CAN_STATE_STOPPED;\r\n}\r\nstatic int rcar_canfd_close(struct net_device *ndev)\r\n{\r\nstruct rcar_canfd_channel *priv = netdev_priv(ndev);\r\nstruct rcar_canfd_global *gpriv = priv->gpriv;\r\nnetif_stop_queue(ndev);\r\nrcar_canfd_stop(ndev);\r\nnapi_disable(&priv->napi);\r\nclk_disable_unprepare(gpriv->can_clk);\r\nclose_candev(ndev);\r\ncan_led_event(ndev, CAN_LED_EVENT_STOP);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t rcar_canfd_start_xmit(struct sk_buff *skb,\r\nstruct net_device *ndev)\r\n{\r\nstruct rcar_canfd_channel *priv = netdev_priv(ndev);\r\nstruct canfd_frame *cf = (struct canfd_frame *)skb->data;\r\nu32 sts = 0, id, dlc;\r\nunsigned long flags;\r\nu32 ch = priv->channel;\r\nif (can_dropped_invalid_skb(ndev, skb))\r\nreturn NETDEV_TX_OK;\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\nid = cf->can_id & CAN_EFF_MASK;\r\nid |= RCANFD_CFID_CFIDE;\r\n} else {\r\nid = cf->can_id & CAN_SFF_MASK;\r\n}\r\nif (cf->can_id & CAN_RTR_FLAG)\r\nid |= RCANFD_CFID_CFRTR;\r\ndlc = RCANFD_CFPTR_CFDLC(can_len2dlc(cf->len));\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_FD) {\r\nrcar_canfd_write(priv->base,\r\nRCANFD_F_CFID(ch, RCANFD_CFFIFO_IDX), id);\r\nrcar_canfd_write(priv->base,\r\nRCANFD_F_CFPTR(ch, RCANFD_CFFIFO_IDX), dlc);\r\nif (can_is_canfd_skb(skb)) {\r\nsts |= RCANFD_CFFDCSTS_CFFDF;\r\nif (cf->flags & CANFD_BRS)\r\nsts |= RCANFD_CFFDCSTS_CFBRS;\r\nif (priv->can.state == CAN_STATE_ERROR_PASSIVE)\r\nsts |= RCANFD_CFFDCSTS_CFESI;\r\n}\r\nrcar_canfd_write(priv->base,\r\nRCANFD_F_CFFDCSTS(ch, RCANFD_CFFIFO_IDX), sts);\r\nrcar_canfd_put_data(priv, cf,\r\nRCANFD_F_CFDF(ch, RCANFD_CFFIFO_IDX, 0));\r\n} else {\r\nrcar_canfd_write(priv->base,\r\nRCANFD_C_CFID(ch, RCANFD_CFFIFO_IDX), id);\r\nrcar_canfd_write(priv->base,\r\nRCANFD_C_CFPTR(ch, RCANFD_CFFIFO_IDX), dlc);\r\nrcar_canfd_put_data(priv, cf,\r\nRCANFD_C_CFDF(ch, RCANFD_CFFIFO_IDX, 0));\r\n}\r\npriv->tx_len[priv->tx_head % RCANFD_FIFO_DEPTH] = cf->len;\r\ncan_put_echo_skb(skb, ndev, priv->tx_head % RCANFD_FIFO_DEPTH);\r\nspin_lock_irqsave(&priv->tx_lock, flags);\r\npriv->tx_head++;\r\nif (priv->tx_head - priv->tx_tail >= RCANFD_FIFO_DEPTH)\r\nnetif_stop_queue(ndev);\r\nrcar_canfd_write(priv->base,\r\nRCANFD_CFPCTR(ch, RCANFD_CFFIFO_IDX), 0xff);\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void rcar_canfd_rx_pkt(struct rcar_canfd_channel *priv)\r\n{\r\nstruct net_device_stats *stats = &priv->ndev->stats;\r\nstruct canfd_frame *cf;\r\nstruct sk_buff *skb;\r\nu32 sts = 0, id, dlc;\r\nu32 ch = priv->channel;\r\nu32 ridx = ch + RCANFD_RFFIFO_IDX;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_FD) {\r\nid = rcar_canfd_read(priv->base, RCANFD_F_RFID(ridx));\r\ndlc = rcar_canfd_read(priv->base, RCANFD_F_RFPTR(ridx));\r\nsts = rcar_canfd_read(priv->base, RCANFD_F_RFFDSTS(ridx));\r\nif (sts & RCANFD_RFFDSTS_RFFDF)\r\nskb = alloc_canfd_skb(priv->ndev, &cf);\r\nelse\r\nskb = alloc_can_skb(priv->ndev,\r\n(struct can_frame **)&cf);\r\n} else {\r\nid = rcar_canfd_read(priv->base, RCANFD_C_RFID(ridx));\r\ndlc = rcar_canfd_read(priv->base, RCANFD_C_RFPTR(ridx));\r\nskb = alloc_can_skb(priv->ndev, (struct can_frame **)&cf);\r\n}\r\nif (!skb) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\nif (id & RCANFD_RFID_RFIDE)\r\ncf->can_id = (id & CAN_EFF_MASK) | CAN_EFF_FLAG;\r\nelse\r\ncf->can_id = id & CAN_SFF_MASK;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_FD) {\r\nif (sts & RCANFD_RFFDSTS_RFFDF)\r\ncf->len = can_dlc2len(RCANFD_RFPTR_RFDLC(dlc));\r\nelse\r\ncf->len = get_can_dlc(RCANFD_RFPTR_RFDLC(dlc));\r\nif (sts & RCANFD_RFFDSTS_RFESI) {\r\ncf->flags |= CANFD_ESI;\r\nnetdev_dbg(priv->ndev, "ESI Error\n");\r\n}\r\nif (!(sts & RCANFD_RFFDSTS_RFFDF) && (id & RCANFD_RFID_RFRTR)) {\r\ncf->can_id |= CAN_RTR_FLAG;\r\n} else {\r\nif (sts & RCANFD_RFFDSTS_RFBRS)\r\ncf->flags |= CANFD_BRS;\r\nrcar_canfd_get_data(priv, cf, RCANFD_F_RFDF(ridx, 0));\r\n}\r\n} else {\r\ncf->len = get_can_dlc(RCANFD_RFPTR_RFDLC(dlc));\r\nif (id & RCANFD_RFID_RFRTR)\r\ncf->can_id |= CAN_RTR_FLAG;\r\nelse\r\nrcar_canfd_get_data(priv, cf, RCANFD_C_RFDF(ridx, 0));\r\n}\r\nrcar_canfd_write(priv->base, RCANFD_RFPCTR(ridx), 0xff);\r\ncan_led_event(priv->ndev, CAN_LED_EVENT_RX);\r\nstats->rx_bytes += cf->len;\r\nstats->rx_packets++;\r\nnetif_receive_skb(skb);\r\n}\r\nstatic int rcar_canfd_rx_poll(struct napi_struct *napi, int quota)\r\n{\r\nstruct rcar_canfd_channel *priv =\r\ncontainer_of(napi, struct rcar_canfd_channel, napi);\r\nint num_pkts;\r\nu32 sts;\r\nu32 ch = priv->channel;\r\nu32 ridx = ch + RCANFD_RFFIFO_IDX;\r\nfor (num_pkts = 0; num_pkts < quota; num_pkts++) {\r\nsts = rcar_canfd_read(priv->base, RCANFD_RFSTS(ridx));\r\nif (sts & RCANFD_RFSTS_RFEMP)\r\nbreak;\r\nrcar_canfd_rx_pkt(priv);\r\nif (sts & RCANFD_RFSTS_RFIF)\r\nrcar_canfd_write(priv->base, RCANFD_RFSTS(ridx),\r\nsts & ~RCANFD_RFSTS_RFIF);\r\n}\r\nif (num_pkts < quota) {\r\nnapi_complete_done(napi, num_pkts);\r\nrcar_canfd_set_bit(priv->base, RCANFD_RFCC(ridx),\r\nRCANFD_RFCC_RFIE);\r\n}\r\nreturn num_pkts;\r\n}\r\nstatic int rcar_canfd_do_set_mode(struct net_device *ndev, enum can_mode mode)\r\n{\r\nint err;\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nerr = rcar_canfd_start(ndev);\r\nif (err)\r\nreturn err;\r\nnetif_wake_queue(ndev);\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int rcar_canfd_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct rcar_canfd_channel *priv = netdev_priv(dev);\r\nu32 val, ch = priv->channel;\r\nval = rcar_canfd_read(priv->base, RCANFD_CSTS(ch));\r\nbec->txerr = RCANFD_CSTS_TECCNT(val);\r\nbec->rxerr = RCANFD_CSTS_RECCNT(val);\r\nreturn 0;\r\n}\r\nstatic int rcar_canfd_channel_probe(struct rcar_canfd_global *gpriv, u32 ch,\r\nu32 fcan_freq)\r\n{\r\nstruct platform_device *pdev = gpriv->pdev;\r\nstruct rcar_canfd_channel *priv;\r\nstruct net_device *ndev;\r\nint err = -ENODEV;\r\nndev = alloc_candev(sizeof(*priv), RCANFD_FIFO_DEPTH);\r\nif (!ndev) {\r\ndev_err(&pdev->dev, "alloc_candev() failed\n");\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\npriv = netdev_priv(ndev);\r\nndev->netdev_ops = &rcar_canfd_netdev_ops;\r\nndev->flags |= IFF_ECHO;\r\npriv->ndev = ndev;\r\npriv->base = gpriv->base;\r\npriv->channel = ch;\r\npriv->can.clock.freq = fcan_freq;\r\ndev_info(&pdev->dev, "can_clk rate is %u\n", priv->can.clock.freq);\r\nif (gpriv->fdmode) {\r\npriv->can.bittiming_const = &rcar_canfd_nom_bittiming_const;\r\npriv->can.data_bittiming_const =\r\n&rcar_canfd_data_bittiming_const;\r\ncan_set_static_ctrlmode(ndev, CAN_CTRLMODE_FD);\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_BERR_REPORTING;\r\n} else {\r\npriv->can.bittiming_const = &rcar_canfd_bittiming_const;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_BERR_REPORTING;\r\n}\r\npriv->can.do_set_mode = rcar_canfd_do_set_mode;\r\npriv->can.do_get_berr_counter = rcar_canfd_get_berr_counter;\r\npriv->gpriv = gpriv;\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nnetif_napi_add(ndev, &priv->napi, rcar_canfd_rx_poll,\r\nRCANFD_NAPI_WEIGHT);\r\nerr = register_candev(ndev);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"register_candev() failed, error %d\n", err);\r\ngoto fail_candev;\r\n}\r\nspin_lock_init(&priv->tx_lock);\r\ndevm_can_led_init(ndev);\r\ngpriv->ch[priv->channel] = priv;\r\ndev_info(&pdev->dev, "device registered (channel %u)\n", priv->channel);\r\nreturn 0;\r\nfail_candev:\r\nnetif_napi_del(&priv->napi);\r\nfree_candev(ndev);\r\nfail:\r\nreturn err;\r\n}\r\nstatic void rcar_canfd_channel_remove(struct rcar_canfd_global *gpriv, u32 ch)\r\n{\r\nstruct rcar_canfd_channel *priv = gpriv->ch[ch];\r\nif (priv) {\r\nunregister_candev(priv->ndev);\r\nnetif_napi_del(&priv->napi);\r\nfree_candev(priv->ndev);\r\n}\r\n}\r\nstatic int rcar_canfd_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *mem;\r\nvoid __iomem *addr;\r\nu32 sts, ch, fcan_freq;\r\nstruct rcar_canfd_global *gpriv;\r\nstruct device_node *of_child;\r\nunsigned long channels_mask = 0;\r\nint err, ch_irq, g_irq;\r\nbool fdmode = true;\r\nif (of_property_read_bool(pdev->dev.of_node, "renesas,no-can-fd"))\r\nfdmode = false;\r\nof_child = of_get_child_by_name(pdev->dev.of_node, "channel0");\r\nif (of_child && of_device_is_available(of_child))\r\nchannels_mask |= BIT(0);\r\nof_child = of_get_child_by_name(pdev->dev.of_node, "channel1");\r\nif (of_child && of_device_is_available(of_child))\r\nchannels_mask |= BIT(1);\r\nch_irq = platform_get_irq(pdev, 0);\r\nif (ch_irq < 0) {\r\ndev_err(&pdev->dev, "no Channel IRQ resource\n");\r\nerr = ch_irq;\r\ngoto fail_dev;\r\n}\r\ng_irq = platform_get_irq(pdev, 1);\r\nif (g_irq < 0) {\r\ndev_err(&pdev->dev, "no Global IRQ resource\n");\r\nerr = g_irq;\r\ngoto fail_dev;\r\n}\r\ngpriv = devm_kzalloc(&pdev->dev, sizeof(*gpriv), GFP_KERNEL);\r\nif (!gpriv) {\r\nerr = -ENOMEM;\r\ngoto fail_dev;\r\n}\r\ngpriv->pdev = pdev;\r\ngpriv->channels_mask = channels_mask;\r\ngpriv->fdmode = fdmode;\r\ngpriv->clkp = devm_clk_get(&pdev->dev, "fck");\r\nif (IS_ERR(gpriv->clkp)) {\r\nerr = PTR_ERR(gpriv->clkp);\r\ndev_err(&pdev->dev, "cannot get peripheral clock, error %d\n",\r\nerr);\r\ngoto fail_dev;\r\n}\r\ngpriv->can_clk = devm_clk_get(&pdev->dev, "can_clk");\r\nif (IS_ERR(gpriv->can_clk) || (clk_get_rate(gpriv->can_clk) == 0)) {\r\ngpriv->can_clk = devm_clk_get(&pdev->dev, "canfd");\r\nif (IS_ERR(gpriv->can_clk)) {\r\nerr = PTR_ERR(gpriv->can_clk);\r\ndev_err(&pdev->dev,\r\n"cannot get canfd clock, error %d\n", err);\r\ngoto fail_dev;\r\n}\r\ngpriv->fcan = RCANFD_CANFDCLK;\r\n} else {\r\ngpriv->fcan = RCANFD_EXTCLK;\r\n}\r\nfcan_freq = clk_get_rate(gpriv->can_clk);\r\nif (gpriv->fcan == RCANFD_CANFDCLK)\r\nfcan_freq /= 2;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naddr = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(addr)) {\r\nerr = PTR_ERR(addr);\r\ngoto fail_dev;\r\n}\r\ngpriv->base = addr;\r\nerr = devm_request_irq(&pdev->dev, ch_irq,\r\nrcar_canfd_channel_interrupt, 0,\r\n"canfd.chn", gpriv);\r\nif (err) {\r\ndev_err(&pdev->dev, "devm_request_irq(%d) failed, error %d\n",\r\nch_irq, err);\r\ngoto fail_dev;\r\n}\r\nerr = devm_request_irq(&pdev->dev, g_irq,\r\nrcar_canfd_global_interrupt, 0,\r\n"canfd.gbl", gpriv);\r\nif (err) {\r\ndev_err(&pdev->dev, "devm_request_irq(%d) failed, error %d\n",\r\ng_irq, err);\r\ngoto fail_dev;\r\n}\r\nerr = clk_prepare_enable(gpriv->clkp);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"failed to enable peripheral clock, error %d\n", err);\r\ngoto fail_dev;\r\n}\r\nerr = rcar_canfd_reset_controller(gpriv);\r\nif (err) {\r\ndev_err(&pdev->dev, "reset controller failed\n");\r\ngoto fail_clk;\r\n}\r\nrcar_canfd_configure_controller(gpriv);\r\nfor_each_set_bit(ch, &gpriv->channels_mask, RCANFD_NUM_CHANNELS) {\r\nrcar_canfd_configure_rx(gpriv, ch);\r\nrcar_canfd_configure_tx(gpriv, ch);\r\nrcar_canfd_configure_afl_rules(gpriv, ch);\r\n}\r\nrcar_canfd_enable_global_interrupts(gpriv);\r\nrcar_canfd_update_bit(gpriv->base, RCANFD_GCTR, RCANFD_GCTR_GMDC_MASK,\r\nRCANFD_GCTR_GMDC_GOPM);\r\nerr = readl_poll_timeout((gpriv->base + RCANFD_GSTS), sts,\r\n!(sts & RCANFD_GSTS_GNOPM), 2, 500000);\r\nif (err) {\r\ndev_err(&pdev->dev, "global operational mode failed\n");\r\ngoto fail_mode;\r\n}\r\nfor_each_set_bit(ch, &gpriv->channels_mask, RCANFD_NUM_CHANNELS) {\r\nerr = rcar_canfd_channel_probe(gpriv, ch, fcan_freq);\r\nif (err)\r\ngoto fail_channel;\r\n}\r\nplatform_set_drvdata(pdev, gpriv);\r\ndev_info(&pdev->dev, "global operational state (clk %d, fdmode %d)\n",\r\ngpriv->fcan, gpriv->fdmode);\r\nreturn 0;\r\nfail_channel:\r\nfor_each_set_bit(ch, &gpriv->channels_mask, RCANFD_NUM_CHANNELS)\r\nrcar_canfd_channel_remove(gpriv, ch);\r\nfail_mode:\r\nrcar_canfd_disable_global_interrupts(gpriv);\r\nfail_clk:\r\nclk_disable_unprepare(gpriv->clkp);\r\nfail_dev:\r\nreturn err;\r\n}\r\nstatic int rcar_canfd_remove(struct platform_device *pdev)\r\n{\r\nstruct rcar_canfd_global *gpriv = platform_get_drvdata(pdev);\r\nu32 ch;\r\nrcar_canfd_reset_controller(gpriv);\r\nrcar_canfd_disable_global_interrupts(gpriv);\r\nfor_each_set_bit(ch, &gpriv->channels_mask, RCANFD_NUM_CHANNELS) {\r\nrcar_canfd_disable_channel_interrupts(gpriv->ch[ch]);\r\nrcar_canfd_channel_remove(gpriv, ch);\r\n}\r\nrcar_canfd_set_bit(gpriv->base, RCANFD_GCTR, RCANFD_GCTR_GSLPR);\r\nclk_disable_unprepare(gpriv->clkp);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused rcar_canfd_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused rcar_canfd_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}
