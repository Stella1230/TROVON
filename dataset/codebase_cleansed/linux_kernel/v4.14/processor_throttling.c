static int acpi_processor_update_tsd_coord(void)\r\n{\r\nint count, count_target;\r\nint retval = 0;\r\nunsigned int i, j;\r\ncpumask_var_t covered_cpus;\r\nstruct acpi_processor *pr, *match_pr;\r\nstruct acpi_tsd_package *pdomain, *match_pdomain;\r\nstruct acpi_processor_throttling *pthrottling, *match_pthrottling;\r\nif (!zalloc_cpumask_var(&covered_cpus, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nfor_each_possible_cpu(i) {\r\npr = per_cpu(processors, i);\r\nif (!pr)\r\ncontinue;\r\npthrottling = &(pr->throttling);\r\nif (!pthrottling->tsd_valid_flag) {\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nif (retval)\r\ngoto err_ret;\r\nfor_each_possible_cpu(i) {\r\npr = per_cpu(processors, i);\r\nif (!pr)\r\ncontinue;\r\nif (cpumask_test_cpu(i, covered_cpus))\r\ncontinue;\r\npthrottling = &pr->throttling;\r\npdomain = &(pthrottling->domain_info);\r\ncpumask_set_cpu(i, pthrottling->shared_cpu_map);\r\ncpumask_set_cpu(i, covered_cpus);\r\nif (pdomain->num_processors <= 1)\r\ncontinue;\r\ncount_target = pdomain->num_processors;\r\ncount = 1;\r\nfor_each_possible_cpu(j) {\r\nif (i == j)\r\ncontinue;\r\nmatch_pr = per_cpu(processors, j);\r\nif (!match_pr)\r\ncontinue;\r\nmatch_pthrottling = &(match_pr->throttling);\r\nmatch_pdomain = &(match_pthrottling->domain_info);\r\nif (match_pdomain->domain != pdomain->domain)\r\ncontinue;\r\nif (match_pdomain->num_processors != count_target) {\r\nretval = -EINVAL;\r\ngoto err_ret;\r\n}\r\nif (pdomain->coord_type != match_pdomain->coord_type) {\r\nretval = -EINVAL;\r\ngoto err_ret;\r\n}\r\ncpumask_set_cpu(j, covered_cpus);\r\ncpumask_set_cpu(j, pthrottling->shared_cpu_map);\r\ncount++;\r\n}\r\nfor_each_possible_cpu(j) {\r\nif (i == j)\r\ncontinue;\r\nmatch_pr = per_cpu(processors, j);\r\nif (!match_pr)\r\ncontinue;\r\nmatch_pthrottling = &(match_pr->throttling);\r\nmatch_pdomain = &(match_pthrottling->domain_info);\r\nif (match_pdomain->domain != pdomain->domain)\r\ncontinue;\r\ncpumask_copy(match_pthrottling->shared_cpu_map,\r\npthrottling->shared_cpu_map);\r\n}\r\n}\r\nerr_ret:\r\nfree_cpumask_var(covered_cpus);\r\nfor_each_possible_cpu(i) {\r\npr = per_cpu(processors, i);\r\nif (!pr)\r\ncontinue;\r\nif (retval) {\r\npthrottling = &(pr->throttling);\r\ncpumask_clear(pthrottling->shared_cpu_map);\r\ncpumask_set_cpu(i, pthrottling->shared_cpu_map);\r\npthrottling->shared_type = DOMAIN_COORD_TYPE_SW_ALL;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nvoid acpi_processor_throttling_init(void)\r\n{\r\nif (acpi_processor_update_tsd_coord()) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Assume no T-state coordination\n"));\r\n}\r\nreturn;\r\n}\r\nstatic int acpi_processor_throttling_notifier(unsigned long event, void *data)\r\n{\r\nstruct throttling_tstate *p_tstate = data;\r\nstruct acpi_processor *pr;\r\nunsigned int cpu ;\r\nint target_state;\r\nstruct acpi_processor_limit *p_limit;\r\nstruct acpi_processor_throttling *p_throttling;\r\ncpu = p_tstate->cpu;\r\npr = per_cpu(processors, cpu);\r\nif (!pr) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Invalid pr pointer\n"));\r\nreturn 0;\r\n}\r\nif (!pr->flags.throttling) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Throttling control is "\r\n"unsupported on CPU %d\n", cpu));\r\nreturn 0;\r\n}\r\ntarget_state = p_tstate->target_state;\r\np_throttling = &(pr->throttling);\r\nswitch (event) {\r\ncase THROTTLING_PRECHANGE:\r\np_limit = &pr->limit;\r\nif (p_limit->thermal.tx > target_state)\r\ntarget_state = p_limit->thermal.tx;\r\nif (p_limit->user.tx > target_state)\r\ntarget_state = p_limit->user.tx;\r\nif (pr->throttling_platform_limit > target_state)\r\ntarget_state = pr->throttling_platform_limit;\r\nif (target_state >= p_throttling->state_count) {\r\nprintk(KERN_WARNING\r\n"Exceed the limit of T-state \n");\r\ntarget_state = p_throttling->state_count - 1;\r\n}\r\np_tstate->target_state = target_state;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "PreChange Event:"\r\n"target T-state of CPU %d is T%d\n",\r\ncpu, target_state));\r\nbreak;\r\ncase THROTTLING_POSTCHANGE:\r\np_throttling->state = target_state;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "PostChange Event:"\r\n"CPU %d is switched to T%d\n",\r\ncpu, target_state));\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"Unsupported Throttling notifier event\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_processor_get_platform_limit(struct acpi_processor *pr)\r\n{\r\nacpi_status status = 0;\r\nunsigned long long tpc = 0;\r\nif (!pr)\r\nreturn -EINVAL;\r\nif (ignore_tpc)\r\ngoto end;\r\nstatus = acpi_evaluate_integer(pr->handle, "_TPC", NULL, &tpc);\r\nif (ACPI_FAILURE(status)) {\r\nif (status != AE_NOT_FOUND) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _TPC"));\r\n}\r\nreturn -ENODEV;\r\n}\r\nend:\r\npr->throttling_platform_limit = (int)tpc;\r\nreturn 0;\r\n}\r\nint acpi_processor_tstate_has_changed(struct acpi_processor *pr)\r\n{\r\nint result = 0;\r\nint throttling_limit;\r\nint current_state;\r\nstruct acpi_processor_limit *limit;\r\nint target_state;\r\nif (ignore_tpc)\r\nreturn 0;\r\nresult = acpi_processor_get_platform_limit(pr);\r\nif (result) {\r\nreturn result;\r\n}\r\nthrottling_limit = pr->throttling_platform_limit;\r\nif (throttling_limit >= pr->throttling.state_count) {\r\nreturn -EINVAL;\r\n}\r\ncurrent_state = pr->throttling.state;\r\nif (current_state > throttling_limit) {\r\nlimit = &pr->limit;\r\ntarget_state = throttling_limit;\r\nif (limit->thermal.tx > target_state)\r\ntarget_state = limit->thermal.tx;\r\nif (limit->user.tx > target_state)\r\ntarget_state = limit->user.tx;\r\n} else if (current_state == throttling_limit) {\r\nreturn 0;\r\n} else {\r\ntarget_state = throttling_limit;\r\n}\r\nreturn acpi_processor_set_throttling(pr, target_state, false);\r\n}\r\nvoid acpi_processor_reevaluate_tstate(struct acpi_processor *pr,\r\nbool is_dead)\r\n{\r\nint result = 0;\r\nif (is_dead) {\r\npr->flags.throttling = 0;\r\nreturn;\r\n}\r\nif (!pr->throttling.state_count) {\r\npr->flags.throttling = 0;\r\nreturn;\r\n}\r\npr->flags.throttling = 1;\r\nresult = acpi_processor_get_throttling(pr);\r\nif (result)\r\ngoto end;\r\nif (pr->throttling.state) {\r\nresult = acpi_processor_set_throttling(pr, 0, false);\r\nif (result)\r\ngoto end;\r\n}\r\nend:\r\nif (result)\r\npr->flags.throttling = 0;\r\n}\r\nstatic int acpi_processor_get_throttling_control(struct acpi_processor *pr)\r\n{\r\nint result = 0;\r\nacpi_status status = 0;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *ptc = NULL;\r\nunion acpi_object obj = { 0 };\r\nstruct acpi_processor_throttling *throttling;\r\nstatus = acpi_evaluate_object(pr->handle, "_PTC", NULL, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nif (status != AE_NOT_FOUND) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _PTC"));\r\n}\r\nreturn -ENODEV;\r\n}\r\nptc = (union acpi_object *)buffer.pointer;\r\nif (!ptc || (ptc->type != ACPI_TYPE_PACKAGE)\r\n|| (ptc->package.count != 2)) {\r\nprintk(KERN_ERR PREFIX "Invalid _PTC data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nobj = ptc->package.elements[0];\r\nif ((obj.type != ACPI_TYPE_BUFFER)\r\n|| (obj.buffer.length < sizeof(struct acpi_ptc_register))\r\n|| (obj.buffer.pointer == NULL)) {\r\nprintk(KERN_ERR PREFIX\r\n"Invalid _PTC data (control_register)\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nmemcpy(&pr->throttling.control_register, obj.buffer.pointer,\r\nsizeof(struct acpi_ptc_register));\r\nobj = ptc->package.elements[1];\r\nif ((obj.type != ACPI_TYPE_BUFFER)\r\n|| (obj.buffer.length < sizeof(struct acpi_ptc_register))\r\n|| (obj.buffer.pointer == NULL)) {\r\nprintk(KERN_ERR PREFIX "Invalid _PTC data (status_register)\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nmemcpy(&pr->throttling.status_register, obj.buffer.pointer,\r\nsizeof(struct acpi_ptc_register));\r\nthrottling = &pr->throttling;\r\nif ((throttling->control_register.bit_width +\r\nthrottling->control_register.bit_offset) > 32) {\r\nprintk(KERN_ERR PREFIX "Invalid _PTC control register\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nif ((throttling->status_register.bit_width +\r\nthrottling->status_register.bit_offset) > 32) {\r\nprintk(KERN_ERR PREFIX "Invalid _PTC status register\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nend:\r\nkfree(buffer.pointer);\r\nreturn result;\r\n}\r\nstatic int acpi_processor_get_throttling_states(struct acpi_processor *pr)\r\n{\r\nint result = 0;\r\nacpi_status status = AE_OK;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_buffer format = { sizeof("NNNNN"), "NNNNN" };\r\nstruct acpi_buffer state = { 0, NULL };\r\nunion acpi_object *tss = NULL;\r\nint i;\r\nstatus = acpi_evaluate_object(pr->handle, "_TSS", NULL, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nif (status != AE_NOT_FOUND) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _TSS"));\r\n}\r\nreturn -ENODEV;\r\n}\r\ntss = buffer.pointer;\r\nif (!tss || (tss->type != ACPI_TYPE_PACKAGE)) {\r\nprintk(KERN_ERR PREFIX "Invalid _TSS data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d throttling states\n",\r\ntss->package.count));\r\npr->throttling.state_count = tss->package.count;\r\npr->throttling.states_tss =\r\nkmalloc(sizeof(struct acpi_processor_tx_tss) * tss->package.count,\r\nGFP_KERNEL);\r\nif (!pr->throttling.states_tss) {\r\nresult = -ENOMEM;\r\ngoto end;\r\n}\r\nfor (i = 0; i < pr->throttling.state_count; i++) {\r\nstruct acpi_processor_tx_tss *tx =\r\n(struct acpi_processor_tx_tss *)&(pr->throttling.\r\nstates_tss[i]);\r\nstate.length = sizeof(struct acpi_processor_tx_tss);\r\nstate.pointer = tx;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Extracting state %d\n", i));\r\nstatus = acpi_extract_package(&(tss->package.elements[i]),\r\n&format, &state);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Invalid _TSS data"));\r\nresult = -EFAULT;\r\nkfree(pr->throttling.states_tss);\r\ngoto end;\r\n}\r\nif (!tx->freqpercentage) {\r\nprintk(KERN_ERR PREFIX\r\n"Invalid _TSS data: freq is zero\n");\r\nresult = -EFAULT;\r\nkfree(pr->throttling.states_tss);\r\ngoto end;\r\n}\r\n}\r\nend:\r\nkfree(buffer.pointer);\r\nreturn result;\r\n}\r\nstatic int acpi_processor_get_tsd(struct acpi_processor *pr)\r\n{\r\nint result = 0;\r\nacpi_status status = AE_OK;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_buffer format = { sizeof("NNNNN"), "NNNNN" };\r\nstruct acpi_buffer state = { 0, NULL };\r\nunion acpi_object *tsd = NULL;\r\nstruct acpi_tsd_package *pdomain;\r\nstruct acpi_processor_throttling *pthrottling;\r\npthrottling = &pr->throttling;\r\npthrottling->tsd_valid_flag = 0;\r\nstatus = acpi_evaluate_object(pr->handle, "_TSD", NULL, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nif (status != AE_NOT_FOUND) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _TSD"));\r\n}\r\nreturn -ENODEV;\r\n}\r\ntsd = buffer.pointer;\r\nif (!tsd || (tsd->type != ACPI_TYPE_PACKAGE)) {\r\nprintk(KERN_ERR PREFIX "Invalid _TSD data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nif (tsd->package.count != 1) {\r\nprintk(KERN_ERR PREFIX "Invalid _TSD data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\npdomain = &(pr->throttling.domain_info);\r\nstate.length = sizeof(struct acpi_tsd_package);\r\nstate.pointer = pdomain;\r\nstatus = acpi_extract_package(&(tsd->package.elements[0]),\r\n&format, &state);\r\nif (ACPI_FAILURE(status)) {\r\nprintk(KERN_ERR PREFIX "Invalid _TSD data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nif (pdomain->num_entries != ACPI_TSD_REV0_ENTRIES) {\r\nprintk(KERN_ERR PREFIX "Unknown _TSD:num_entries\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nif (pdomain->revision != ACPI_TSD_REV0_REVISION) {\r\nprintk(KERN_ERR PREFIX "Unknown _TSD:revision\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\npthrottling = &pr->throttling;\r\npthrottling->tsd_valid_flag = 1;\r\npthrottling->shared_type = pdomain->coord_type;\r\ncpumask_set_cpu(pr->id, pthrottling->shared_cpu_map);\r\nif (pdomain->coord_type != DOMAIN_COORD_TYPE_SW_ALL &&\r\npdomain->coord_type != DOMAIN_COORD_TYPE_SW_ANY &&\r\npdomain->coord_type != DOMAIN_COORD_TYPE_HW_ALL) {\r\npthrottling->tsd_valid_flag = 0;\r\npthrottling->shared_type = DOMAIN_COORD_TYPE_SW_ALL;\r\n}\r\nend:\r\nkfree(buffer.pointer);\r\nreturn result;\r\n}\r\nstatic int acpi_processor_get_throttling_fadt(struct acpi_processor *pr)\r\n{\r\nint state = 0;\r\nu32 value = 0;\r\nu32 duty_mask = 0;\r\nu32 duty_value = 0;\r\nif (!pr)\r\nreturn -EINVAL;\r\nif (!pr->flags.throttling)\r\nreturn -ENODEV;\r\nrequest_region(pr->throttling.address, 6, "ACPI CPU throttle");\r\npr->throttling.state = 0;\r\nduty_mask = pr->throttling.state_count - 1;\r\nduty_mask <<= pr->throttling.duty_offset;\r\nlocal_irq_disable();\r\nvalue = inl(pr->throttling.address);\r\nif (value & 0x10) {\r\nduty_value = value & duty_mask;\r\nduty_value >>= pr->throttling.duty_offset;\r\nif (duty_value)\r\nstate = pr->throttling.state_count - duty_value;\r\n}\r\npr->throttling.state = state;\r\nlocal_irq_enable();\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Throttling state is T%d (%d%% throttling applied)\n",\r\nstate, pr->throttling.states[state].performance));\r\nreturn 0;\r\n}\r\nstatic int acpi_throttling_rdmsr(u64 *value)\r\n{\r\nu64 msr_high, msr_low;\r\nu64 msr = 0;\r\nint ret = -1;\r\nif ((this_cpu_read(cpu_info.x86_vendor) != X86_VENDOR_INTEL) ||\r\n!this_cpu_has(X86_FEATURE_ACPI)) {\r\nprintk(KERN_ERR PREFIX\r\n"HARDWARE addr space,NOT supported yet\n");\r\n} else {\r\nmsr_low = 0;\r\nmsr_high = 0;\r\nrdmsr_safe(MSR_IA32_THERM_CONTROL,\r\n(u32 *)&msr_low , (u32 *) &msr_high);\r\nmsr = (msr_high << 32) | msr_low;\r\n*value = (u64) msr;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int acpi_throttling_wrmsr(u64 value)\r\n{\r\nint ret = -1;\r\nu64 msr;\r\nif ((this_cpu_read(cpu_info.x86_vendor) != X86_VENDOR_INTEL) ||\r\n!this_cpu_has(X86_FEATURE_ACPI)) {\r\nprintk(KERN_ERR PREFIX\r\n"HARDWARE addr space,NOT supported yet\n");\r\n} else {\r\nmsr = value;\r\nwrmsr_safe(MSR_IA32_THERM_CONTROL,\r\nmsr & 0xffffffff, msr >> 32);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int acpi_throttling_rdmsr(u64 *value)\r\n{\r\nprintk(KERN_ERR PREFIX\r\n"HARDWARE addr space,NOT supported yet\n");\r\nreturn -1;\r\n}\r\nstatic int acpi_throttling_wrmsr(u64 value)\r\n{\r\nprintk(KERN_ERR PREFIX\r\n"HARDWARE addr space,NOT supported yet\n");\r\nreturn -1;\r\n}\r\nstatic int acpi_read_throttling_status(struct acpi_processor *pr,\r\nu64 *value)\r\n{\r\nu32 bit_width, bit_offset;\r\nu32 ptc_value;\r\nu64 ptc_mask;\r\nstruct acpi_processor_throttling *throttling;\r\nint ret = -1;\r\nthrottling = &pr->throttling;\r\nswitch (throttling->status_register.space_id) {\r\ncase ACPI_ADR_SPACE_SYSTEM_IO:\r\nbit_width = throttling->status_register.bit_width;\r\nbit_offset = throttling->status_register.bit_offset;\r\nacpi_os_read_port((acpi_io_address) throttling->status_register.\r\naddress, &ptc_value,\r\n(u32) (bit_width + bit_offset));\r\nptc_mask = (1 << bit_width) - 1;\r\n*value = (u64) ((ptc_value >> bit_offset) & ptc_mask);\r\nret = 0;\r\nbreak;\r\ncase ACPI_ADR_SPACE_FIXED_HARDWARE:\r\nret = acpi_throttling_rdmsr(value);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR PREFIX "Unknown addr space %d\n",\r\n(u32) (throttling->status_register.space_id));\r\n}\r\nreturn ret;\r\n}\r\nstatic int acpi_write_throttling_state(struct acpi_processor *pr,\r\nu64 value)\r\n{\r\nu32 bit_width, bit_offset;\r\nu64 ptc_value;\r\nu64 ptc_mask;\r\nstruct acpi_processor_throttling *throttling;\r\nint ret = -1;\r\nthrottling = &pr->throttling;\r\nswitch (throttling->control_register.space_id) {\r\ncase ACPI_ADR_SPACE_SYSTEM_IO:\r\nbit_width = throttling->control_register.bit_width;\r\nbit_offset = throttling->control_register.bit_offset;\r\nptc_mask = (1 << bit_width) - 1;\r\nptc_value = value & ptc_mask;\r\nacpi_os_write_port((acpi_io_address) throttling->\r\ncontrol_register.address,\r\n(u32) (ptc_value << bit_offset),\r\n(u32) (bit_width + bit_offset));\r\nret = 0;\r\nbreak;\r\ncase ACPI_ADR_SPACE_FIXED_HARDWARE:\r\nret = acpi_throttling_wrmsr(value);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR PREFIX "Unknown addr space %d\n",\r\n(u32) (throttling->control_register.space_id));\r\n}\r\nreturn ret;\r\n}\r\nstatic int acpi_get_throttling_state(struct acpi_processor *pr,\r\nu64 value)\r\n{\r\nint i;\r\nfor (i = 0; i < pr->throttling.state_count; i++) {\r\nstruct acpi_processor_tx_tss *tx =\r\n(struct acpi_processor_tx_tss *)&(pr->throttling.\r\nstates_tss[i]);\r\nif (tx->control == value)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic int acpi_get_throttling_value(struct acpi_processor *pr,\r\nint state, u64 *value)\r\n{\r\nint ret = -1;\r\nif (state >= 0 && state <= pr->throttling.state_count) {\r\nstruct acpi_processor_tx_tss *tx =\r\n(struct acpi_processor_tx_tss *)&(pr->throttling.\r\nstates_tss[state]);\r\n*value = tx->control;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int acpi_processor_get_throttling_ptc(struct acpi_processor *pr)\r\n{\r\nint state = 0;\r\nint ret;\r\nu64 value;\r\nif (!pr)\r\nreturn -EINVAL;\r\nif (!pr->flags.throttling)\r\nreturn -ENODEV;\r\npr->throttling.state = 0;\r\nvalue = 0;\r\nret = acpi_read_throttling_status(pr, &value);\r\nif (ret >= 0) {\r\nstate = acpi_get_throttling_state(pr, value);\r\nif (state == -1) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Invalid throttling state, reset\n"));\r\nstate = 0;\r\nret = __acpi_processor_set_throttling(pr, state, true,\r\ntrue);\r\nif (ret)\r\nreturn ret;\r\n}\r\npr->throttling.state = state;\r\n}\r\nreturn 0;\r\n}\r\nstatic long __acpi_processor_get_throttling(void *data)\r\n{\r\nstruct acpi_processor *pr = data;\r\nreturn pr->throttling.acpi_processor_get_throttling(pr);\r\n}\r\nstatic int call_on_cpu(int cpu, long (*fn)(void *), void *arg, bool direct)\r\n{\r\nif (direct || (is_percpu_thread() && cpu == smp_processor_id()))\r\nreturn fn(arg);\r\nreturn work_on_cpu(cpu, fn, arg);\r\n}\r\nstatic int acpi_processor_get_throttling(struct acpi_processor *pr)\r\n{\r\nif (!pr)\r\nreturn -EINVAL;\r\nif (!pr->flags.throttling)\r\nreturn -ENODEV;\r\nif (!cpu_online(pr->id))\r\nreturn -ENODEV;\r\nreturn call_on_cpu(pr->id, __acpi_processor_get_throttling, pr, false);\r\n}\r\nstatic int acpi_processor_get_fadt_info(struct acpi_processor *pr)\r\n{\r\nint i, step;\r\nif (!pr->throttling.address) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling register\n"));\r\nreturn -EINVAL;\r\n} else if (!pr->throttling.duty_width) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling states\n"));\r\nreturn -EINVAL;\r\n}\r\nelse if ((pr->throttling.duty_offset + pr->throttling.duty_width) > 4) {\r\nprintk(KERN_WARNING PREFIX "duty_cycle spans bit 4\n");\r\nreturn -EINVAL;\r\n}\r\npr->throttling.state_count = 1 << acpi_gbl_FADT.duty_width;\r\nstep = (1000 / pr->throttling.state_count);\r\nfor (i = 0; i < pr->throttling.state_count; i++) {\r\npr->throttling.states[i].performance = 1000 - step * i;\r\npr->throttling.states[i].power = 1000 - step * i;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_processor_set_throttling_fadt(struct acpi_processor *pr,\r\nint state, bool force)\r\n{\r\nu32 value = 0;\r\nu32 duty_mask = 0;\r\nu32 duty_value = 0;\r\nif (!pr)\r\nreturn -EINVAL;\r\nif ((state < 0) || (state > (pr->throttling.state_count - 1)))\r\nreturn -EINVAL;\r\nif (!pr->flags.throttling)\r\nreturn -ENODEV;\r\nif (!force && (state == pr->throttling.state))\r\nreturn 0;\r\nif (state < pr->throttling_platform_limit)\r\nreturn -EPERM;\r\nif (state) {\r\nduty_value = pr->throttling.state_count - state;\r\nduty_value <<= pr->throttling.duty_offset;\r\nduty_mask = pr->throttling.state_count - 1;\r\nduty_mask <<= acpi_gbl_FADT.duty_offset;\r\nduty_mask = ~duty_mask;\r\n}\r\nlocal_irq_disable();\r\nvalue = inl(pr->throttling.address);\r\nif (value & 0x10) {\r\nvalue &= 0xFFFFFFEF;\r\noutl(value, pr->throttling.address);\r\n}\r\nif (state) {\r\nvalue &= duty_mask;\r\nvalue |= duty_value;\r\noutl(value, pr->throttling.address);\r\nvalue |= 0x00000010;\r\noutl(value, pr->throttling.address);\r\n}\r\npr->throttling.state = state;\r\nlocal_irq_enable();\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Throttling state set to T%d (%d%%)\n", state,\r\n(pr->throttling.states[state].performance ? pr->\r\nthrottling.states[state].performance / 10 : 0)));\r\nreturn 0;\r\n}\r\nstatic int acpi_processor_set_throttling_ptc(struct acpi_processor *pr,\r\nint state, bool force)\r\n{\r\nint ret;\r\nu64 value;\r\nif (!pr)\r\nreturn -EINVAL;\r\nif ((state < 0) || (state > (pr->throttling.state_count - 1)))\r\nreturn -EINVAL;\r\nif (!pr->flags.throttling)\r\nreturn -ENODEV;\r\nif (!force && (state == pr->throttling.state))\r\nreturn 0;\r\nif (state < pr->throttling_platform_limit)\r\nreturn -EPERM;\r\nvalue = 0;\r\nret = acpi_get_throttling_value(pr, state, &value);\r\nif (ret >= 0) {\r\nacpi_write_throttling_state(pr, value);\r\npr->throttling.state = state;\r\n}\r\nreturn 0;\r\n}\r\nstatic long acpi_processor_throttling_fn(void *data)\r\n{\r\nstruct acpi_processor_throttling_arg *arg = data;\r\nstruct acpi_processor *pr = arg->pr;\r\nreturn pr->throttling.acpi_processor_set_throttling(pr,\r\narg->target_state, arg->force);\r\n}\r\nstatic int __acpi_processor_set_throttling(struct acpi_processor *pr,\r\nint state, bool force, bool direct)\r\n{\r\nint ret = 0;\r\nunsigned int i;\r\nstruct acpi_processor *match_pr;\r\nstruct acpi_processor_throttling *p_throttling;\r\nstruct acpi_processor_throttling_arg arg;\r\nstruct throttling_tstate t_state;\r\nif (!pr)\r\nreturn -EINVAL;\r\nif (!pr->flags.throttling)\r\nreturn -ENODEV;\r\nif ((state < 0) || (state > (pr->throttling.state_count - 1)))\r\nreturn -EINVAL;\r\nif (cpu_is_offline(pr->id)) {\r\nreturn -ENODEV;\r\n}\r\nt_state.target_state = state;\r\np_throttling = &(pr->throttling);\r\nfor_each_cpu_and(i, cpu_online_mask, p_throttling->shared_cpu_map) {\r\nt_state.cpu = i;\r\nacpi_processor_throttling_notifier(THROTTLING_PRECHANGE,\r\n&t_state);\r\n}\r\nif (p_throttling->shared_type == DOMAIN_COORD_TYPE_SW_ANY) {\r\narg.pr = pr;\r\narg.target_state = state;\r\narg.force = force;\r\nret = call_on_cpu(pr->id, acpi_processor_throttling_fn, &arg,\r\ndirect);\r\n} else {\r\nfor_each_cpu_and(i, cpu_online_mask,\r\np_throttling->shared_cpu_map) {\r\nmatch_pr = per_cpu(processors, i);\r\nif (!match_pr) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Invalid Pointer for CPU %d\n", i));\r\ncontinue;\r\n}\r\nif (!match_pr->flags.throttling) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Throttling Control is unsupported "\r\n"on CPU %d\n", i));\r\ncontinue;\r\n}\r\narg.pr = match_pr;\r\narg.target_state = state;\r\narg.force = force;\r\nret = call_on_cpu(pr->id, acpi_processor_throttling_fn,\r\n&arg, direct);\r\n}\r\n}\r\nfor_each_cpu_and(i, cpu_online_mask, p_throttling->shared_cpu_map) {\r\nt_state.cpu = i;\r\nacpi_processor_throttling_notifier(THROTTLING_POSTCHANGE,\r\n&t_state);\r\n}\r\nreturn ret;\r\n}\r\nint acpi_processor_set_throttling(struct acpi_processor *pr, int state,\r\nbool force)\r\n{\r\nreturn __acpi_processor_set_throttling(pr, state, force, false);\r\n}\r\nint acpi_processor_get_throttling_info(struct acpi_processor *pr)\r\n{\r\nint result = 0;\r\nstruct acpi_processor_throttling *pthrottling;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"pblk_address[0x%08x] duty_offset[%d] duty_width[%d]\n",\r\npr->throttling.address,\r\npr->throttling.duty_offset,\r\npr->throttling.duty_width));\r\nif (acpi_processor_get_throttling_control(pr) ||\r\nacpi_processor_get_throttling_states(pr) ||\r\nacpi_processor_get_platform_limit(pr))\r\n{\r\npr->throttling.acpi_processor_get_throttling =\r\n&acpi_processor_get_throttling_fadt;\r\npr->throttling.acpi_processor_set_throttling =\r\n&acpi_processor_set_throttling_fadt;\r\nif (acpi_processor_get_fadt_info(pr))\r\nreturn 0;\r\n} else {\r\npr->throttling.acpi_processor_get_throttling =\r\n&acpi_processor_get_throttling_ptc;\r\npr->throttling.acpi_processor_set_throttling =\r\n&acpi_processor_set_throttling_ptc;\r\n}\r\nif (acpi_processor_get_tsd(pr)) {\r\npthrottling = &pr->throttling;\r\npthrottling->tsd_valid_flag = 0;\r\ncpumask_set_cpu(pr->id, pthrottling->shared_cpu_map);\r\npthrottling->shared_type = DOMAIN_COORD_TYPE_SW_ALL;\r\n}\r\nif (errata.piix4.throttle) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Throttling not supported on PIIX4 A- or B-step\n"));\r\nreturn 0;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d throttling states\n",\r\npr->throttling.state_count));\r\npr->flags.throttling = 1;\r\nresult = acpi_processor_get_throttling(pr);\r\nif (result)\r\ngoto end;\r\nif (pr->throttling.state) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Disabling throttling (was T%d)\n",\r\npr->throttling.state));\r\nresult = acpi_processor_set_throttling(pr, 0, false);\r\nif (result)\r\ngoto end;\r\n}\r\nend:\r\nif (result)\r\npr->flags.throttling = 0;\r\nreturn result;\r\n}
