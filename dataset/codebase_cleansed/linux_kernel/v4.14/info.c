void rds_info_register_func(int optname, rds_info_func func)\r\n{\r\nint offset = optname - RDS_INFO_FIRST;\r\nBUG_ON(optname < RDS_INFO_FIRST || optname > RDS_INFO_LAST);\r\nspin_lock(&rds_info_lock);\r\nBUG_ON(rds_info_funcs[offset]);\r\nrds_info_funcs[offset] = func;\r\nspin_unlock(&rds_info_lock);\r\n}\r\nvoid rds_info_deregister_func(int optname, rds_info_func func)\r\n{\r\nint offset = optname - RDS_INFO_FIRST;\r\nBUG_ON(optname < RDS_INFO_FIRST || optname > RDS_INFO_LAST);\r\nspin_lock(&rds_info_lock);\r\nBUG_ON(rds_info_funcs[offset] != func);\r\nrds_info_funcs[offset] = NULL;\r\nspin_unlock(&rds_info_lock);\r\n}\r\nvoid rds_info_iter_unmap(struct rds_info_iterator *iter)\r\n{\r\nif (iter->addr) {\r\nkunmap_atomic(iter->addr);\r\niter->addr = NULL;\r\n}\r\n}\r\nvoid rds_info_copy(struct rds_info_iterator *iter, void *data,\r\nunsigned long bytes)\r\n{\r\nunsigned long this;\r\nwhile (bytes) {\r\nif (!iter->addr)\r\niter->addr = kmap_atomic(*iter->pages);\r\nthis = min(bytes, PAGE_SIZE - iter->offset);\r\nrdsdebug("page %p addr %p offset %lu this %lu data %p "\r\n"bytes %lu\n", *iter->pages, iter->addr,\r\niter->offset, this, data, bytes);\r\nmemcpy(iter->addr + iter->offset, data, this);\r\ndata += this;\r\nbytes -= this;\r\niter->offset += this;\r\nif (iter->offset == PAGE_SIZE) {\r\nkunmap_atomic(iter->addr);\r\niter->addr = NULL;\r\niter->offset = 0;\r\niter->pages++;\r\n}\r\n}\r\n}\r\nint rds_info_getsockopt(struct socket *sock, int optname, char __user *optval,\r\nint __user *optlen)\r\n{\r\nstruct rds_info_iterator iter;\r\nstruct rds_info_lengths lens;\r\nunsigned long nr_pages = 0;\r\nunsigned long start;\r\nunsigned long i;\r\nrds_info_func func;\r\nstruct page **pages = NULL;\r\nint ret;\r\nint len;\r\nint total;\r\nif (get_user(len, optlen)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nstart = (unsigned long)optval;\r\nif (len < 0 || len > INT_MAX - PAGE_SIZE + 1 || start + len < start) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (len == 0)\r\ngoto call_func;\r\nnr_pages = (PAGE_ALIGN(start + len) - (start & PAGE_MASK))\r\n>> PAGE_SHIFT;\r\npages = kmalloc(nr_pages * sizeof(struct page *), GFP_KERNEL);\r\nif (!pages) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = get_user_pages_fast(start, nr_pages, 1, pages);\r\nif (ret != nr_pages) {\r\nif (ret > 0)\r\nnr_pages = ret;\r\nelse\r\nnr_pages = 0;\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nrdsdebug("len %d nr_pages %lu\n", len, nr_pages);\r\ncall_func:\r\nfunc = rds_info_funcs[optname - RDS_INFO_FIRST];\r\nif (!func) {\r\nret = -ENOPROTOOPT;\r\ngoto out;\r\n}\r\niter.pages = pages;\r\niter.addr = NULL;\r\niter.offset = start & (PAGE_SIZE - 1);\r\nfunc(sock, len, &iter, &lens);\r\nBUG_ON(lens.each == 0);\r\ntotal = lens.nr * lens.each;\r\nrds_info_iter_unmap(&iter);\r\nif (total > len) {\r\nlen = total;\r\nret = -ENOSPC;\r\n} else {\r\nlen = total;\r\nret = lens.each;\r\n}\r\nif (put_user(len, optlen))\r\nret = -EFAULT;\r\nout:\r\nfor (i = 0; pages && i < nr_pages; i++)\r\nput_page(pages[i]);\r\nkfree(pages);\r\nreturn ret;\r\n}
