static inline u32 regr(u32 offset)\r\n{\r\nreturn __raw_readl(ccdc_cfg.base_addr + offset);\r\n}\r\nstatic inline void regw(u32 val, u32 offset)\r\n{\r\n__raw_writel(val, ccdc_cfg.base_addr + offset);\r\n}\r\nstatic void ccdc_enable(int en)\r\n{\r\nunsigned int temp;\r\ntemp = regr(SYNCEN);\r\ntemp &= (~CCDC_SYNCEN_VDHDEN_MASK);\r\ntemp |= (en & CCDC_SYNCEN_VDHDEN_MASK);\r\nregw(temp, SYNCEN);\r\n}\r\nstatic void ccdc_enable_output_to_sdram(int en)\r\n{\r\nunsigned int temp;\r\ntemp = regr(SYNCEN);\r\ntemp &= (~(CCDC_SYNCEN_WEN_MASK));\r\ntemp |= ((en << CCDC_SYNCEN_WEN_SHIFT) & CCDC_SYNCEN_WEN_MASK);\r\nregw(temp, SYNCEN);\r\n}\r\nstatic void ccdc_config_gain_offset(void)\r\n{\r\nregw(ccdc_cfg.bayer.gain.r_ye, RYEGAIN);\r\nregw(ccdc_cfg.bayer.gain.gr_cy, GRCYGAIN);\r\nregw(ccdc_cfg.bayer.gain.gb_g, GBGGAIN);\r\nregw(ccdc_cfg.bayer.gain.b_mg, BMGGAIN);\r\nregw(ccdc_cfg.bayer.ccdc_offset, OFFSET);\r\n}\r\nstatic int ccdc_restore_defaults(void)\r\n{\r\nint i;\r\ndev_dbg(ccdc_cfg.dev, "\nstarting ccdc_restore_defaults...");\r\nfor (i = 0; i <= CCDC_REG_LAST; i += 4)\r\nregw(0, i);\r\nregw(MODESET_DEFAULT, MODESET);\r\nregw(CULH_DEFAULT, CULH);\r\nregw(CULV_DEFAULT, CULV);\r\nccdc_cfg.bayer.gain.r_ye = GAIN_DEFAULT;\r\nccdc_cfg.bayer.gain.gb_g = GAIN_DEFAULT;\r\nccdc_cfg.bayer.gain.gr_cy = GAIN_DEFAULT;\r\nccdc_cfg.bayer.gain.b_mg = GAIN_DEFAULT;\r\nccdc_config_gain_offset();\r\nregw(OUTCLIP_DEFAULT, OUTCLIP);\r\nregw(LSCCFG2_DEFAULT, LSCCFG2);\r\nif (vpss_select_ccdc_source(VPSS_CCDCIN)) {\r\ndev_dbg(ccdc_cfg.dev, "\ncouldn't select ccdc input source");\r\nreturn -EFAULT;\r\n}\r\nif (vpss_enable_clock(VPSS_CCDC_CLOCK, 1) < 0) {\r\ndev_dbg(ccdc_cfg.dev, "\ncouldn't enable ccdc clock");\r\nreturn -EFAULT;\r\n}\r\ndev_dbg(ccdc_cfg.dev, "\nEnd of ccdc_restore_defaults...");\r\nreturn 0;\r\n}\r\nstatic int ccdc_open(struct device *device)\r\n{\r\nreturn ccdc_restore_defaults();\r\n}\r\nstatic int ccdc_close(struct device *device)\r\n{\r\nvpss_enable_clock(VPSS_CCDC_CLOCK, 0);\r\nreturn 0;\r\n}\r\nstatic void ccdc_setwin(struct v4l2_rect *image_win,\r\nenum ccdc_frmfmt frm_fmt, int ppc)\r\n{\r\nint horz_start, horz_nr_pixels;\r\nint vert_start, vert_nr_lines;\r\nint mid_img = 0;\r\ndev_dbg(ccdc_cfg.dev, "\nStarting ccdc_setwin...");\r\nhorz_start = image_win->left << (ppc - 1);\r\nhorz_nr_pixels = ((image_win->width) << (ppc - 1)) - 1;\r\nregw(horz_start, SPH);\r\nregw(horz_nr_pixels, NPH);\r\nvert_start = image_win->top;\r\nif (frm_fmt == CCDC_FRMFMT_INTERLACED) {\r\nvert_nr_lines = (image_win->height >> 1) - 1;\r\nvert_start >>= 1;\r\nvert_start += 1;\r\nregw(vert_start, VDINT0);\r\n} else {\r\nvert_start += 1;\r\nvert_nr_lines = image_win->height - 1;\r\nmid_img = vert_start + (image_win->height / 2);\r\nregw(vert_start, VDINT0);\r\nregw(mid_img, VDINT1);\r\n}\r\nregw(vert_start & CCDC_START_VER_ONE_MASK, SLV0);\r\nregw(vert_start & CCDC_START_VER_TWO_MASK, SLV1);\r\nregw(vert_nr_lines & CCDC_NUM_LINES_VER, NLV);\r\ndev_dbg(ccdc_cfg.dev, "\nEnd of ccdc_setwin...");\r\n}\r\nstatic void ccdc_config_ycbcr(void)\r\n{\r\nstruct ccdc_params_ycbcr *params = &ccdc_cfg.ycbcr;\r\nu32 temp;\r\ndev_dbg(ccdc_cfg.dev, "\nStarting ccdc_config_ycbcr...");\r\nccdc_restore_defaults();\r\ntemp = (((params->pix_fmt & CCDC_INPUT_MODE_MASK) <<\r\nCCDC_INPUT_MODE_SHIFT) |\r\n((params->frm_fmt & CCDC_FRM_FMT_MASK) <<\r\nCCDC_FRM_FMT_SHIFT));\r\nif (params->bt656_enable) {\r\nregw(CCDC_REC656IF_BT656_EN, REC656IF);\r\ntemp |= CCDC_VD_POL_NEGATIVE;\r\n} else {\r\ntemp |= (((params->fid_pol & CCDC_FID_POL_MASK) <<\r\nCCDC_FID_POL_SHIFT) |\r\n((params->hd_pol & CCDC_HD_POL_MASK) <<\r\nCCDC_HD_POL_SHIFT) |\r\n((params->vd_pol & CCDC_VD_POL_MASK) <<\r\nCCDC_VD_POL_SHIFT));\r\n}\r\ntemp |= CCDC_DATA_PACK_ENABLE;\r\nregw(temp, MODESET);\r\nccdc_setwin(&params->win, params->frm_fmt, 2);\r\ntemp = (params->pix_order << CCDC_Y8POS_SHIFT);\r\ntemp |= CCDC_LATCH_ON_VSYNC_DISABLE | CCDC_CCDCFG_FIDMD_NO_LATCH_VSYNC;\r\nregw(temp, CCDCFG);\r\nregw(((params->win.width * 2 + 31) >> 5), HSIZE);\r\nif (params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED) {\r\nregw(CCDC_SDOFST_FIELD_INTERLEAVED, SDOFST);\r\n}\r\ndev_dbg(ccdc_cfg.dev, "\nEnd of ccdc_config_ycbcr...\n");\r\n}\r\nstatic void ccdc_config_black_clamp(struct ccdc_black_clamp *bclamp)\r\n{\r\nu32 val;\r\nif (!bclamp->b_clamp_enable) {\r\nregw(bclamp->dc_sub & CCDC_BLK_DC_SUB_MASK, DCSUB);\r\nregw(0x0000, CLAMP);\r\nreturn;\r\n}\r\nval = (bclamp->start_pixel & CCDC_BLK_ST_PXL_MASK) |\r\n((bclamp->sample_pixel & CCDC_BLK_SAMPLE_LN_MASK) <<\r\nCCDC_BLK_SAMPLE_LN_SHIFT) | CCDC_BLK_CLAMP_ENABLE;\r\nregw(val, CLAMP);\r\nval = (bclamp->sample_ln & CCDC_NUM_LINE_CALC_MASK)\r\n<< CCDC_NUM_LINE_CALC_SHIFT;\r\nregw(val, DCSUB);\r\n}\r\nstatic void ccdc_config_black_compense(struct ccdc_black_compensation *bcomp)\r\n{\r\nu32 val;\r\nval = (bcomp->b & CCDC_BLK_COMP_MASK) |\r\n((bcomp->gb & CCDC_BLK_COMP_MASK) <<\r\nCCDC_BLK_COMP_GB_COMP_SHIFT);\r\nregw(val, BLKCMP1);\r\nval = ((bcomp->gr & CCDC_BLK_COMP_MASK) <<\r\nCCDC_BLK_COMP_GR_COMP_SHIFT) |\r\n((bcomp->r & CCDC_BLK_COMP_MASK) <<\r\nCCDC_BLK_COMP_R_COMP_SHIFT);\r\nregw(val, BLKCMP0);\r\n}\r\nstatic int ccdc_write_dfc_entry(int index, struct ccdc_vertical_dft *dfc)\r\n{\r\n#define DFC_WRITE_WAIT_COUNT 1000\r\nu32 val, count = DFC_WRITE_WAIT_COUNT;\r\nregw(dfc->dft_corr_vert[index], DFCMEM0);\r\nregw(dfc->dft_corr_horz[index], DFCMEM1);\r\nregw(dfc->dft_corr_sub1[index], DFCMEM2);\r\nregw(dfc->dft_corr_sub2[index], DFCMEM3);\r\nregw(dfc->dft_corr_sub3[index], DFCMEM4);\r\nval = regr(DFCMEMCTL) | CCDC_DFCMEMCTL_DFCMWR_MASK;\r\nregw(val, DFCMEMCTL);\r\nwhile (regr(DFCMEMCTL) & CCDC_DFCMEMCTL_DFCMWR_MASK)\r\ncount--;\r\nif (count) {\r\ndev_err(ccdc_cfg.dev, "defect table write timeout !!!\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ccdc_config_vdfc(struct ccdc_vertical_dft *dfc)\r\n{\r\nu32 val;\r\nint i;\r\nval = dfc->gen_dft_en & CCDC_DFCCTL_GDFCEN_MASK;\r\nif (!dfc->ver_dft_en) {\r\nregw(val, DFCCTL);\r\nreturn 0;\r\n}\r\nif (dfc->table_size > CCDC_DFT_TABLE_SIZE)\r\nreturn -EINVAL;\r\nval |= CCDC_DFCCTL_VDFC_DISABLE;\r\nval |= (dfc->dft_corr_ctl.vdfcsl & CCDC_DFCCTL_VDFCSL_MASK) <<\r\nCCDC_DFCCTL_VDFCSL_SHIFT;\r\nval |= (dfc->dft_corr_ctl.vdfcuda & CCDC_DFCCTL_VDFCUDA_MASK) <<\r\nCCDC_DFCCTL_VDFCUDA_SHIFT;\r\nval |= (dfc->dft_corr_ctl.vdflsft & CCDC_DFCCTL_VDFLSFT_MASK) <<\r\nCCDC_DFCCTL_VDFLSFT_SHIFT;\r\nregw(val , DFCCTL);\r\nval = CCDC_DFCMEMCTL_DFCMARST_MASK << CCDC_DFCMEMCTL_DFCMARST_SHIFT;\r\nfor (i = 0; i < dfc->table_size; i++) {\r\nif (i != 0)\r\nval = CCDC_DFCMEMCTL_INC_ADDR;\r\nregw(val, DFCMEMCTL);\r\nif (ccdc_write_dfc_entry(i, dfc) < 0)\r\nreturn -EFAULT;\r\n}\r\nregw(dfc->saturation_ctl & CCDC_VDC_DFCVSAT_MASK, DFCVSAT);\r\nval = regr(DFCCTL) | (CCDC_DFCCTL_VDFCEN_MASK <<\r\nCCDC_DFCCTL_VDFCEN_SHIFT);\r\nregw(val, DFCCTL);\r\nreturn 0;\r\n}\r\nstatic void ccdc_config_csc(struct ccdc_csc *csc)\r\n{\r\nu32 val1 = 0, val2;\r\nint i;\r\nif (!csc->enable)\r\nreturn;\r\nregw(CCDC_CSC_ENABLE, CSCCTL);\r\nfor (i = 0; i < CCDC_CSC_COEFF_TABLE_SIZE; i++) {\r\nif ((i % 2) == 0) {\r\nval1 = (csc->coeff[i].integer &\r\nCCDC_CSC_COEF_INTEG_MASK)\r\n<< CCDC_CSC_COEF_INTEG_SHIFT;\r\nval1 |= (((csc->coeff[i].decimal &\r\nCCDC_CSC_COEF_DECIMAL_MASK) *\r\nCCDC_CSC_DEC_MAX) / 100);\r\n} else {\r\nval2 = (csc->coeff[i].integer &\r\nCCDC_CSC_COEF_INTEG_MASK)\r\n<< CCDC_CSC_COEF_INTEG_SHIFT;\r\nval2 |= (((csc->coeff[i].decimal &\r\nCCDC_CSC_COEF_DECIMAL_MASK) *\r\nCCDC_CSC_DEC_MAX) / 100);\r\nval2 <<= CCDC_CSCM_MSB_SHIFT;\r\nval2 |= val1;\r\nregw(val2, (CSCM0 + ((i - 1) << 1)));\r\n}\r\n}\r\n}\r\nstatic void ccdc_config_color_patterns(struct ccdc_col_pat *pat0,\r\nstruct ccdc_col_pat *pat1)\r\n{\r\nu32 val;\r\nval = (pat0->olop | (pat0->olep << 2) | (pat0->elop << 4) |\r\n(pat0->elep << 6) | (pat1->olop << 8) | (pat1->olep << 10) |\r\n(pat1->elop << 12) | (pat1->elep << 14));\r\nregw(val, COLPTN);\r\n}\r\nstatic int ccdc_config_raw(void)\r\n{\r\nstruct ccdc_params_raw *params = &ccdc_cfg.bayer;\r\nstruct ccdc_config_params_raw *config_params =\r\n&ccdc_cfg.bayer.config_params;\r\nunsigned int val;\r\ndev_dbg(ccdc_cfg.dev, "\nStarting ccdc_config_raw...");\r\nccdc_restore_defaults();\r\nregw(CCDC_YCINSWP_RAW | CCDC_CCDCFG_FIDMD_LATCH_VSYNC |\r\nCCDC_CCDCFG_WENLOG_AND | CCDC_CCDCFG_TRGSEL_WEN |\r\nCCDC_CCDCFG_EXTRG_DISABLE | CCDC_LATCH_ON_VSYNC_DISABLE, CCDCFG);\r\nval = (CCDC_VDHDOUT_INPUT | CCDC_RAW_IP_MODE | CCDC_DATAPOL_NORMAL |\r\nCCDC_EXWEN_DISABLE);\r\nval |= (((params->vd_pol & CCDC_VD_POL_MASK) << CCDC_VD_POL_SHIFT) |\r\n((params->hd_pol & CCDC_HD_POL_MASK) << CCDC_HD_POL_SHIFT) |\r\n((params->fid_pol & CCDC_FID_POL_MASK) << CCDC_FID_POL_SHIFT) |\r\n((params->frm_fmt & CCDC_FRM_FMT_MASK) << CCDC_FRM_FMT_SHIFT) |\r\n((params->pix_fmt & CCDC_PIX_FMT_MASK) << CCDC_PIX_FMT_SHIFT));\r\nif ((config_params->data_sz == CCDC_DATA_8BITS) ||\r\nconfig_params->alaw.enable)\r\nval |= CCDC_DATA_PACK_ENABLE;\r\nif (config_params->lpf_enable)\r\nval |= (config_params->lpf_enable & CCDC_LPF_MASK) <<\r\nCCDC_LPF_SHIFT;\r\nval |= (config_params->datasft & CCDC_DATASFT_MASK) <<\r\nCCDC_DATASFT_SHIFT;\r\nregw(val , MODESET);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x%x to MODESET...\n", val);\r\nregw((config_params->med_filt_thres) & CCDC_MED_FILT_THRESH, MEDFILT);\r\nval = CCDC_GAMMA_BITS_11_2 << CCDC_GAMMAWD_INPUT_SHIFT |\r\nCCDC_CFA_MOSAIC;\r\nif (config_params->alaw.enable) {\r\nval |= (CCDC_ALAW_ENABLE |\r\n((config_params->alaw.gamma_wd &\r\nCCDC_ALAW_GAMMA_WD_MASK) <<\r\nCCDC_GAMMAWD_INPUT_SHIFT));\r\n}\r\nval |= ((config_params->mfilt1 << CCDC_MFILT1_SHIFT) |\r\n(config_params->mfilt2 << CCDC_MFILT2_SHIFT));\r\nregw(val, GAMMAWD);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x%x to GAMMAWD...\n", val);\r\nccdc_setwin(&params->win, params->frm_fmt, 1);\r\nccdc_config_black_clamp(&config_params->blk_clamp);\r\nccdc_config_black_compense(&config_params->blk_comp);\r\nif (ccdc_config_vdfc(&config_params->vertical_dft) < 0)\r\nreturn -EFAULT;\r\nccdc_config_csc(&config_params->csc);\r\nccdc_config_color_patterns(&config_params->col_pat_field0,\r\n&config_params->col_pat_field1);\r\nccdc_config_gain_offset();\r\ndev_dbg(ccdc_cfg.dev, "\nWriting %x to COLPTN...\n", val);\r\nval = (config_params->data_offset.horz_offset & CCDC_DATAOFST_MASK) <<\r\nCCDC_DATAOFST_H_SHIFT;\r\nval |= (config_params->data_offset.vert_offset & CCDC_DATAOFST_MASK) <<\r\nCCDC_DATAOFST_V_SHIFT;\r\nregw(val, DATAOFST);\r\nval = (params->horz_flip_enable & CCDC_HSIZE_FLIP_MASK) <<\r\nCCDC_HSIZE_FLIP_SHIFT;\r\nif ((config_params->data_sz == CCDC_DATA_8BITS) ||\r\nconfig_params->alaw.enable) {\r\nval |= (((params->win.width) + 31) >> 5) &\r\nCCDC_HSIZE_VAL_MASK;\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x%x to HSIZE...\n",\r\n(((params->win.width) + 31) >> 5) &\r\nCCDC_HSIZE_VAL_MASK);\r\n} else {\r\nval |= (((params->win.width * 2) + 31) >> 5) &\r\nCCDC_HSIZE_VAL_MASK;\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x%x to HSIZE...\n",\r\n(((params->win.width * 2) + 31) >> 5) &\r\nCCDC_HSIZE_VAL_MASK);\r\n}\r\nregw(val, HSIZE);\r\nif (params->frm_fmt == CCDC_FRMFMT_INTERLACED) {\r\nif (params->image_invert_enable) {\r\nregw(CCDC_SDOFST_INTERLACE_INVERSE, SDOFST);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting %x to SDOFST...\n",\r\nCCDC_SDOFST_INTERLACE_INVERSE);\r\n} else {\r\nregw(CCDC_SDOFST_INTERLACE_NORMAL, SDOFST);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting %x to SDOFST...\n",\r\nCCDC_SDOFST_INTERLACE_NORMAL);\r\n}\r\n} else if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {\r\nif (params->image_invert_enable) {\r\nregw(CCDC_SDOFST_PROGRESSIVE_INVERSE, SDOFST);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting %x to SDOFST...\n",\r\nCCDC_SDOFST_PROGRESSIVE_INVERSE);\r\n} else {\r\nregw(CCDC_SDOFST_PROGRESSIVE_NORMAL, SDOFST);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting %x to SDOFST...\n",\r\nCCDC_SDOFST_PROGRESSIVE_NORMAL);\r\n}\r\n}\r\ndev_dbg(ccdc_cfg.dev, "\nend of ccdc_config_raw...");\r\nreturn 0;\r\n}\r\nstatic int ccdc_configure(void)\r\n{\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nreturn ccdc_config_raw();\r\nelse\r\nccdc_config_ycbcr();\r\nreturn 0;\r\n}\r\nstatic int ccdc_set_buftype(enum ccdc_buftype buf_type)\r\n{\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nccdc_cfg.bayer.buf_type = buf_type;\r\nelse\r\nccdc_cfg.ycbcr.buf_type = buf_type;\r\nreturn 0;\r\n}\r\nstatic enum ccdc_buftype ccdc_get_buftype(void)\r\n{\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nreturn ccdc_cfg.bayer.buf_type;\r\nreturn ccdc_cfg.ycbcr.buf_type;\r\n}\r\nstatic int ccdc_enum_pix(u32 *pix, int i)\r\n{\r\nint ret = -EINVAL;\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER) {\r\nif (i < ARRAY_SIZE(ccdc_raw_bayer_pix_formats)) {\r\n*pix = ccdc_raw_bayer_pix_formats[i];\r\nret = 0;\r\n}\r\n} else {\r\nif (i < ARRAY_SIZE(ccdc_raw_yuv_pix_formats)) {\r\n*pix = ccdc_raw_yuv_pix_formats[i];\r\nret = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ccdc_set_pixel_format(u32 pixfmt)\r\n{\r\nstruct ccdc_a_law *alaw = &ccdc_cfg.bayer.config_params.alaw;\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER) {\r\nccdc_cfg.bayer.pix_fmt = CCDC_PIXFMT_RAW;\r\nif (pixfmt == V4L2_PIX_FMT_SBGGR8)\r\nalaw->enable = 1;\r\nelse if (pixfmt != V4L2_PIX_FMT_SBGGR16)\r\nreturn -EINVAL;\r\n} else {\r\nif (pixfmt == V4L2_PIX_FMT_YUYV)\r\nccdc_cfg.ycbcr.pix_order = CCDC_PIXORDER_YCBYCR;\r\nelse if (pixfmt == V4L2_PIX_FMT_UYVY)\r\nccdc_cfg.ycbcr.pix_order = CCDC_PIXORDER_CBYCRY;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 ccdc_get_pixel_format(void)\r\n{\r\nstruct ccdc_a_law *alaw = &ccdc_cfg.bayer.config_params.alaw;\r\nu32 pixfmt;\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nif (alaw->enable)\r\npixfmt = V4L2_PIX_FMT_SBGGR8;\r\nelse\r\npixfmt = V4L2_PIX_FMT_SBGGR16;\r\nelse {\r\nif (ccdc_cfg.ycbcr.pix_order == CCDC_PIXORDER_YCBYCR)\r\npixfmt = V4L2_PIX_FMT_YUYV;\r\nelse\r\npixfmt = V4L2_PIX_FMT_UYVY;\r\n}\r\nreturn pixfmt;\r\n}\r\nstatic int ccdc_set_image_window(struct v4l2_rect *win)\r\n{\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nccdc_cfg.bayer.win = *win;\r\nelse\r\nccdc_cfg.ycbcr.win = *win;\r\nreturn 0;\r\n}\r\nstatic void ccdc_get_image_window(struct v4l2_rect *win)\r\n{\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\n*win = ccdc_cfg.bayer.win;\r\nelse\r\n*win = ccdc_cfg.ycbcr.win;\r\n}\r\nstatic unsigned int ccdc_get_line_length(void)\r\n{\r\nstruct ccdc_config_params_raw *config_params =\r\n&ccdc_cfg.bayer.config_params;\r\nunsigned int len;\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER) {\r\nif ((config_params->alaw.enable) ||\r\n(config_params->data_sz == CCDC_DATA_8BITS))\r\nlen = ccdc_cfg.bayer.win.width;\r\nelse\r\nlen = ccdc_cfg.bayer.win.width * 2;\r\n} else\r\nlen = ccdc_cfg.ycbcr.win.width * 2;\r\nreturn ALIGN(len, 32);\r\n}\r\nstatic int ccdc_set_frame_format(enum ccdc_frmfmt frm_fmt)\r\n{\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nccdc_cfg.bayer.frm_fmt = frm_fmt;\r\nelse\r\nccdc_cfg.ycbcr.frm_fmt = frm_fmt;\r\nreturn 0;\r\n}\r\nstatic enum ccdc_frmfmt ccdc_get_frame_format(void)\r\n{\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nreturn ccdc_cfg.bayer.frm_fmt;\r\nelse\r\nreturn ccdc_cfg.ycbcr.frm_fmt;\r\n}\r\nstatic int ccdc_getfid(void)\r\n{\r\nreturn (regr(MODESET) >> 15) & 1;\r\n}\r\nstatic inline void ccdc_setfbaddr(unsigned long addr)\r\n{\r\nregw((addr >> 21) & 0x007f, STADRH);\r\nregw((addr >> 5) & 0x0ffff, STADRL);\r\n}\r\nstatic int ccdc_set_hw_if_params(struct vpfe_hw_if_param *params)\r\n{\r\nccdc_cfg.if_type = params->if_type;\r\nswitch (params->if_type) {\r\ncase VPFE_BT656:\r\ncase VPFE_YCBCR_SYNC_16:\r\ncase VPFE_YCBCR_SYNC_8:\r\nccdc_cfg.ycbcr.vd_pol = params->vdpol;\r\nccdc_cfg.ycbcr.hd_pol = params->hdpol;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dm355_ccdc_probe(struct platform_device *pdev)\r\n{\r\nvoid (*setup_pinmux)(void);\r\nstruct resource *res;\r\nint status = 0;\r\nstatus = vpfe_register_ccdc_device(&ccdc_hw_dev);\r\nif (status < 0)\r\nreturn status;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nstatus = -ENODEV;\r\ngoto fail_nores;\r\n}\r\nres = request_mem_region(res->start, resource_size(res), res->name);\r\nif (!res) {\r\nstatus = -EBUSY;\r\ngoto fail_nores;\r\n}\r\nccdc_cfg.base_addr = ioremap_nocache(res->start, resource_size(res));\r\nif (!ccdc_cfg.base_addr) {\r\nstatus = -ENOMEM;\r\ngoto fail_nomem;\r\n}\r\nif (NULL == pdev->dev.platform_data) {\r\nstatus = -ENODEV;\r\ngoto fail_nomap;\r\n}\r\nsetup_pinmux = pdev->dev.platform_data;\r\nsetup_pinmux();\r\nccdc_cfg.dev = &pdev->dev;\r\nprintk(KERN_NOTICE "%s is registered with vpfe.\n", ccdc_hw_dev.name);\r\nreturn 0;\r\nfail_nomap:\r\niounmap(ccdc_cfg.base_addr);\r\nfail_nomem:\r\nrelease_mem_region(res->start, resource_size(res));\r\nfail_nores:\r\nvpfe_unregister_ccdc_device(&ccdc_hw_dev);\r\nreturn status;\r\n}\r\nstatic int dm355_ccdc_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\niounmap(ccdc_cfg.base_addr);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\nvpfe_unregister_ccdc_device(&ccdc_hw_dev);\r\nreturn 0;\r\n}
