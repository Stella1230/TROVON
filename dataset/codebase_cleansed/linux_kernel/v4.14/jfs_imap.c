int diMount(struct inode *ipimap)\r\n{\r\nstruct inomap *imap;\r\nstruct metapage *mp;\r\nint index;\r\nstruct dinomap_disk *dinom_le;\r\nimap = kmalloc(sizeof(struct inomap), GFP_KERNEL);\r\nif (imap == NULL) {\r\njfs_err("diMount: kmalloc returned NULL!");\r\nreturn -ENOMEM;\r\n}\r\nmp = read_metapage(ipimap,\r\nIMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\r\nPSIZE, 0);\r\nif (mp == NULL) {\r\nkfree(imap);\r\nreturn -EIO;\r\n}\r\ndinom_le = (struct dinomap_disk *) mp->data;\r\nimap->im_freeiag = le32_to_cpu(dinom_le->in_freeiag);\r\nimap->im_nextiag = le32_to_cpu(dinom_le->in_nextiag);\r\natomic_set(&imap->im_numinos, le32_to_cpu(dinom_le->in_numinos));\r\natomic_set(&imap->im_numfree, le32_to_cpu(dinom_le->in_numfree));\r\nimap->im_nbperiext = le32_to_cpu(dinom_le->in_nbperiext);\r\nimap->im_l2nbperiext = le32_to_cpu(dinom_le->in_l2nbperiext);\r\nfor (index = 0; index < MAXAG; index++) {\r\nimap->im_agctl[index].inofree =\r\nle32_to_cpu(dinom_le->in_agctl[index].inofree);\r\nimap->im_agctl[index].extfree =\r\nle32_to_cpu(dinom_le->in_agctl[index].extfree);\r\nimap->im_agctl[index].numinos =\r\nle32_to_cpu(dinom_le->in_agctl[index].numinos);\r\nimap->im_agctl[index].numfree =\r\nle32_to_cpu(dinom_le->in_agctl[index].numfree);\r\n}\r\nrelease_metapage(mp);\r\nIAGFREE_LOCK_INIT(imap);\r\nfor (index = 0; index < MAXAG; index++) {\r\nAG_LOCK_INIT(imap, index);\r\n}\r\nimap->im_ipimap = ipimap;\r\nJFS_IP(ipimap)->i_imap = imap;\r\nreturn (0);\r\n}\r\nint diUnmount(struct inode *ipimap, int mounterror)\r\n{\r\nstruct inomap *imap = JFS_IP(ipimap)->i_imap;\r\nif (!(mounterror || isReadOnly(ipimap)))\r\ndiSync(ipimap);\r\ntruncate_inode_pages(ipimap->i_mapping, 0);\r\nkfree(imap);\r\nreturn (0);\r\n}\r\nint diSync(struct inode *ipimap)\r\n{\r\nstruct dinomap_disk *dinom_le;\r\nstruct inomap *imp = JFS_IP(ipimap)->i_imap;\r\nstruct metapage *mp;\r\nint index;\r\nmp = get_metapage(ipimap,\r\nIMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\r\nPSIZE, 0);\r\nif (mp == NULL) {\r\njfs_err("diSync: get_metapage failed!");\r\nreturn -EIO;\r\n}\r\ndinom_le = (struct dinomap_disk *) mp->data;\r\ndinom_le->in_freeiag = cpu_to_le32(imp->im_freeiag);\r\ndinom_le->in_nextiag = cpu_to_le32(imp->im_nextiag);\r\ndinom_le->in_numinos = cpu_to_le32(atomic_read(&imp->im_numinos));\r\ndinom_le->in_numfree = cpu_to_le32(atomic_read(&imp->im_numfree));\r\ndinom_le->in_nbperiext = cpu_to_le32(imp->im_nbperiext);\r\ndinom_le->in_l2nbperiext = cpu_to_le32(imp->im_l2nbperiext);\r\nfor (index = 0; index < MAXAG; index++) {\r\ndinom_le->in_agctl[index].inofree =\r\ncpu_to_le32(imp->im_agctl[index].inofree);\r\ndinom_le->in_agctl[index].extfree =\r\ncpu_to_le32(imp->im_agctl[index].extfree);\r\ndinom_le->in_agctl[index].numinos =\r\ncpu_to_le32(imp->im_agctl[index].numinos);\r\ndinom_le->in_agctl[index].numfree =\r\ncpu_to_le32(imp->im_agctl[index].numfree);\r\n}\r\nwrite_metapage(mp);\r\nfilemap_write_and_wait(ipimap->i_mapping);\r\ndiWriteSpecial(ipimap, 0);\r\nreturn (0);\r\n}\r\nint diRead(struct inode *ip)\r\n{\r\nstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\r\nint iagno, ino, extno, rc;\r\nstruct inode *ipimap;\r\nstruct dinode *dp;\r\nstruct iag *iagp;\r\nstruct metapage *mp;\r\ns64 blkno, agstart;\r\nstruct inomap *imap;\r\nint block_offset;\r\nint inodes_left;\r\nunsigned long pageno;\r\nint rel_inode;\r\njfs_info("diRead: ino = %ld", ip->i_ino);\r\nipimap = sbi->ipimap;\r\nJFS_IP(ip)->ipimap = ipimap;\r\niagno = INOTOIAG(ip->i_ino);\r\nimap = JFS_IP(ipimap)->i_imap;\r\nIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\r\nrc = diIAGRead(imap, iagno, &mp);\r\nIREAD_UNLOCK(ipimap);\r\nif (rc) {\r\njfs_err("diRead: diIAGRead returned %d", rc);\r\nreturn (rc);\r\n}\r\niagp = (struct iag *) mp->data;\r\nino = ip->i_ino & (INOSPERIAG - 1);\r\nextno = ino >> L2INOSPEREXT;\r\nif ((lengthPXD(&iagp->inoext[extno]) != imap->im_nbperiext) ||\r\n(addressPXD(&iagp->inoext[extno]) == 0)) {\r\nrelease_metapage(mp);\r\nreturn -ESTALE;\r\n}\r\nblkno = INOPBLK(&iagp->inoext[extno], ino, sbi->l2nbperpage);\r\nagstart = le64_to_cpu(iagp->agstart);\r\nrelease_metapage(mp);\r\nrel_inode = (ino & (INOSPERPAGE - 1));\r\npageno = blkno >> sbi->l2nbperpage;\r\nif ((block_offset = ((u32) blkno & (sbi->nbperpage - 1)))) {\r\ninodes_left =\r\n(sbi->nbperpage - block_offset) << sbi->l2niperblk;\r\nif (rel_inode < inodes_left)\r\nrel_inode += block_offset << sbi->l2niperblk;\r\nelse {\r\npageno += 1;\r\nrel_inode -= inodes_left;\r\n}\r\n}\r\nmp = read_metapage(ipimap, pageno << sbi->l2nbperpage, PSIZE, 1);\r\nif (!mp) {\r\njfs_err("diRead: read_metapage failed");\r\nreturn -EIO;\r\n}\r\ndp = (struct dinode *) mp->data;\r\ndp += rel_inode;\r\nif (ip->i_ino != le32_to_cpu(dp->di_number)) {\r\njfs_error(ip->i_sb, "i_ino != di_number\n");\r\nrc = -EIO;\r\n} else if (le32_to_cpu(dp->di_nlink) == 0)\r\nrc = -ESTALE;\r\nelse\r\nrc = copy_from_dinode(dp, ip);\r\nrelease_metapage(mp);\r\nJFS_IP(ip)->agstart = agstart;\r\nJFS_IP(ip)->active_ag = -1;\r\nreturn (rc);\r\n}\r\nstruct inode *diReadSpecial(struct super_block *sb, ino_t inum, int secondary)\r\n{\r\nstruct jfs_sb_info *sbi = JFS_SBI(sb);\r\nuint address;\r\nstruct dinode *dp;\r\nstruct inode *ip;\r\nstruct metapage *mp;\r\nip = new_inode(sb);\r\nif (ip == NULL) {\r\njfs_err("diReadSpecial: new_inode returned NULL!");\r\nreturn ip;\r\n}\r\nif (secondary) {\r\naddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\r\nJFS_IP(ip)->ipimap = sbi->ipaimap2;\r\n} else {\r\naddress = AITBL_OFF >> L2PSIZE;\r\nJFS_IP(ip)->ipimap = sbi->ipaimap;\r\n}\r\nASSERT(inum < INOSPEREXT);\r\nip->i_ino = inum;\r\naddress += inum >> 3;\r\nmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\r\nif (mp == NULL) {\r\nset_nlink(ip, 1);\r\niput(ip);\r\nreturn (NULL);\r\n}\r\ndp = (struct dinode *) (mp->data);\r\ndp += inum % 8;\r\nif ((copy_from_dinode(dp, ip)) != 0) {\r\nset_nlink(ip, 1);\r\niput(ip);\r\nrelease_metapage(mp);\r\nreturn (NULL);\r\n}\r\nip->i_mapping->a_ops = &jfs_metapage_aops;\r\nmapping_set_gfp_mask(ip->i_mapping, GFP_NOFS);\r\nip->i_flags |= S_NOQUOTA;\r\nif ((inum == FILESYSTEM_I) && (JFS_IP(ip)->ipimap == sbi->ipaimap)) {\r\nsbi->gengen = le32_to_cpu(dp->di_gengen);\r\nsbi->inostamp = le32_to_cpu(dp->di_inostamp);\r\n}\r\nrelease_metapage(mp);\r\nhlist_add_fake(&ip->i_hash);\r\nreturn (ip);\r\n}\r\nvoid diWriteSpecial(struct inode *ip, int secondary)\r\n{\r\nstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\r\nuint address;\r\nstruct dinode *dp;\r\nino_t inum = ip->i_ino;\r\nstruct metapage *mp;\r\nif (secondary)\r\naddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\r\nelse\r\naddress = AITBL_OFF >> L2PSIZE;\r\nASSERT(inum < INOSPEREXT);\r\naddress += inum >> 3;\r\nmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\r\nif (mp == NULL) {\r\njfs_err("diWriteSpecial: failed to read aggregate inode extent!");\r\nreturn;\r\n}\r\ndp = (struct dinode *) (mp->data);\r\ndp += inum % 8;\r\ncopy_to_dinode(dp, ip);\r\nmemcpy(&dp->di_xtroot, &JFS_IP(ip)->i_xtroot, 288);\r\nif (inum == FILESYSTEM_I)\r\ndp->di_gengen = cpu_to_le32(sbi->gengen);\r\nwrite_metapage(mp);\r\n}\r\nvoid diFreeSpecial(struct inode *ip)\r\n{\r\nif (ip == NULL) {\r\njfs_err("diFreeSpecial called with NULL ip!");\r\nreturn;\r\n}\r\nfilemap_write_and_wait(ip->i_mapping);\r\ntruncate_inode_pages(ip->i_mapping, 0);\r\niput(ip);\r\n}\r\nint diWrite(tid_t tid, struct inode *ip)\r\n{\r\nstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\r\nstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\r\nint rc = 0;\r\ns32 ino;\r\nstruct dinode *dp;\r\ns64 blkno;\r\nint block_offset;\r\nint inodes_left;\r\nstruct metapage *mp;\r\nunsigned long pageno;\r\nint rel_inode;\r\nint dioffset;\r\nstruct inode *ipimap;\r\nuint type;\r\nlid_t lid;\r\nstruct tlock *ditlck, *tlck;\r\nstruct linelock *dilinelock, *ilinelock;\r\nstruct lv *lv;\r\nint n;\r\nipimap = jfs_ip->ipimap;\r\nino = ip->i_ino & (INOSPERIAG - 1);\r\nif (!addressPXD(&(jfs_ip->ixpxd)) ||\r\n(lengthPXD(&(jfs_ip->ixpxd)) !=\r\nJFS_IP(ipimap)->i_imap->im_nbperiext)) {\r\njfs_error(ip->i_sb, "ixpxd invalid\n");\r\nreturn -EIO;\r\n}\r\nblkno = INOPBLK(&(jfs_ip->ixpxd), ino, sbi->l2nbperpage);\r\nrel_inode = (ino & (INOSPERPAGE - 1));\r\npageno = blkno >> sbi->l2nbperpage;\r\nif ((block_offset = ((u32) blkno & (sbi->nbperpage - 1)))) {\r\ninodes_left =\r\n(sbi->nbperpage - block_offset) << sbi->l2niperblk;\r\nif (rel_inode < inodes_left)\r\nrel_inode += block_offset << sbi->l2niperblk;\r\nelse {\r\npageno += 1;\r\nrel_inode -= inodes_left;\r\n}\r\n}\r\nretry:\r\nmp = read_metapage(ipimap, pageno << sbi->l2nbperpage, PSIZE, 1);\r\nif (!mp)\r\nreturn -EIO;\r\ndp = (struct dinode *) mp->data;\r\ndp += rel_inode;\r\ndioffset = (ino & (INOSPERPAGE - 1)) << L2DISIZE;\r\nif ((ditlck =\r\ntxLock(tid, ipimap, mp, tlckINODE | tlckENTRY)) == NULL)\r\ngoto retry;\r\ndilinelock = (struct linelock *) & ditlck->lock;\r\nif (S_ISDIR(ip->i_mode) && (lid = jfs_ip->xtlid)) {\r\nxtpage_t *p, *xp;\r\nxad_t *xad;\r\njfs_ip->xtlid = 0;\r\ntlck = lid_to_tlock(lid);\r\nassert(tlck->type & tlckXTREE);\r\ntlck->type |= tlckBTROOT;\r\ntlck->mp = mp;\r\nilinelock = (struct linelock *) & tlck->lock;\r\np = &jfs_ip->i_xtroot;\r\nxp = (xtpage_t *) &dp->di_dirtable;\r\nlv = ilinelock->lv;\r\nfor (n = 0; n < ilinelock->index; n++, lv++) {\r\nmemcpy(&xp->xad[lv->offset], &p->xad[lv->offset],\r\nlv->length << L2XTSLOTSIZE);\r\n}\r\nxad = &xp->xad[XTENTRYSTART];\r\nfor (n = XTENTRYSTART;\r\nn < le16_to_cpu(xp->header.nextindex); n++, xad++)\r\nif (xad->flag & (XAD_NEW | XAD_EXTENDED))\r\nxad->flag &= ~(XAD_NEW | XAD_EXTENDED);\r\n}\r\nif ((lid = jfs_ip->blid) == 0)\r\ngoto inlineData;\r\njfs_ip->blid = 0;\r\ntlck = lid_to_tlock(lid);\r\ntype = tlck->type;\r\ntlck->type |= tlckBTROOT;\r\ntlck->mp = mp;\r\nilinelock = (struct linelock *) & tlck->lock;\r\nif (type & tlckXTREE) {\r\nxtpage_t *p, *xp;\r\nxad_t *xad;\r\np = &jfs_ip->i_xtroot;\r\nxp = &dp->di_xtroot;\r\nlv = ilinelock->lv;\r\nfor (n = 0; n < ilinelock->index; n++, lv++) {\r\nmemcpy(&xp->xad[lv->offset], &p->xad[lv->offset],\r\nlv->length << L2XTSLOTSIZE);\r\n}\r\nxad = &xp->xad[XTENTRYSTART];\r\nfor (n = XTENTRYSTART;\r\nn < le16_to_cpu(xp->header.nextindex); n++, xad++)\r\nif (xad->flag & (XAD_NEW | XAD_EXTENDED))\r\nxad->flag &= ~(XAD_NEW | XAD_EXTENDED);\r\n}\r\nelse if (type & tlckDTREE) {\r\ndtpage_t *p, *xp;\r\np = (dtpage_t *) &jfs_ip->i_dtroot;\r\nxp = (dtpage_t *) & dp->di_dtroot;\r\nlv = ilinelock->lv;\r\nfor (n = 0; n < ilinelock->index; n++, lv++) {\r\nmemcpy(&xp->slot[lv->offset], &p->slot[lv->offset],\r\nlv->length << L2DTSLOTSIZE);\r\n}\r\n} else {\r\njfs_err("diWrite: UFO tlock");\r\n}\r\ninlineData:\r\nif (S_ISLNK(ip->i_mode) && ip->i_size < IDATASIZE) {\r\nlv = & dilinelock->lv[dilinelock->index];\r\nlv->offset = (dioffset + 2 * 128) >> L2INODESLOTSIZE;\r\nlv->length = 2;\r\nmemcpy(&dp->di_fastsymlink, jfs_ip->i_inline, IDATASIZE);\r\ndilinelock->index++;\r\n}\r\nif (test_cflag(COMMIT_Inlineea, ip)) {\r\nlv = & dilinelock->lv[dilinelock->index];\r\nlv->offset = (dioffset + 3 * 128) >> L2INODESLOTSIZE;\r\nlv->length = 1;\r\nmemcpy(&dp->di_inlineea, jfs_ip->i_inline_ea, INODESLOTSIZE);\r\ndilinelock->index++;\r\nclear_cflag(COMMIT_Inlineea, ip);\r\n}\r\nlv = & dilinelock->lv[dilinelock->index];\r\nlv->offset = dioffset >> L2INODESLOTSIZE;\r\ncopy_to_dinode(dp, ip);\r\nif (test_and_clear_cflag(COMMIT_Dirtable, ip)) {\r\nlv->length = 2;\r\nmemcpy(&dp->di_dirtable, &jfs_ip->i_dirtable, 96);\r\n} else\r\nlv->length = 1;\r\ndilinelock->index++;\r\nwrite_metapage(mp);\r\nreturn (rc);\r\n}\r\nint diFree(struct inode *ip)\r\n{\r\nint rc;\r\nino_t inum = ip->i_ino;\r\nstruct iag *iagp, *aiagp, *biagp, *ciagp, *diagp;\r\nstruct metapage *mp, *amp, *bmp, *cmp, *dmp;\r\nint iagno, ino, extno, bitno, sword, agno;\r\nint back, fwd;\r\nu32 bitmap, mask;\r\nstruct inode *ipimap = JFS_SBI(ip->i_sb)->ipimap;\r\nstruct inomap *imap = JFS_IP(ipimap)->i_imap;\r\npxd_t freepxd;\r\ntid_t tid;\r\nstruct inode *iplist[3];\r\nstruct tlock *tlck;\r\nstruct pxd_lock *pxdlock;\r\naiagp = biagp = ciagp = diagp = NULL;\r\niagno = INOTOIAG(inum);\r\nif (iagno >= imap->im_nextiag) {\r\nprint_hex_dump(KERN_ERR, "imap: ", DUMP_PREFIX_ADDRESS, 16, 4,\r\nimap, 32, 0);\r\njfs_error(ip->i_sb, "inum = %d, iagno = %d, nextiag = %d\n",\r\n(uint) inum, iagno, imap->im_nextiag);\r\nreturn -EIO;\r\n}\r\nagno = BLKTOAG(JFS_IP(ip)->agstart, JFS_SBI(ip->i_sb));\r\nAG_LOCK(imap, agno);\r\nIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\r\nif ((rc = diIAGRead(imap, iagno, &mp))) {\r\nIREAD_UNLOCK(ipimap);\r\nAG_UNLOCK(imap, agno);\r\nreturn (rc);\r\n}\r\niagp = (struct iag *) mp->data;\r\nino = inum & (INOSPERIAG - 1);\r\nextno = ino >> L2INOSPEREXT;\r\nbitno = ino & (INOSPEREXT - 1);\r\nmask = HIGHORDER >> bitno;\r\nif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\r\njfs_error(ip->i_sb, "wmap shows inode already free\n");\r\n}\r\nif (!addressPXD(&iagp->inoext[extno])) {\r\nrelease_metapage(mp);\r\nIREAD_UNLOCK(ipimap);\r\nAG_UNLOCK(imap, agno);\r\njfs_error(ip->i_sb, "invalid inoext\n");\r\nreturn -EIO;\r\n}\r\nbitmap = le32_to_cpu(iagp->wmap[extno]) & ~mask;\r\nif (imap->im_agctl[agno].numfree > imap->im_agctl[agno].numinos) {\r\nrelease_metapage(mp);\r\nIREAD_UNLOCK(ipimap);\r\nAG_UNLOCK(imap, agno);\r\njfs_error(ip->i_sb, "numfree > numinos\n");\r\nreturn -EIO;\r\n}\r\nif (bitmap ||\r\nimap->im_agctl[agno].numfree < 96 ||\r\n(imap->im_agctl[agno].numfree < 288 &&\r\n(((imap->im_agctl[agno].numfree * 100) /\r\nimap->im_agctl[agno].numinos) <= 25))) {\r\nif (iagp->nfreeinos == 0) {\r\nif ((fwd = imap->im_agctl[agno].inofree) >= 0) {\r\nif ((rc = diIAGRead(imap, fwd, &amp))) {\r\nIREAD_UNLOCK(ipimap);\r\nAG_UNLOCK(imap, agno);\r\nrelease_metapage(mp);\r\nreturn (rc);\r\n}\r\naiagp = (struct iag *) amp->data;\r\naiagp->inofreeback = cpu_to_le32(iagno);\r\nwrite_metapage(amp);\r\n}\r\niagp->inofreefwd =\r\ncpu_to_le32(imap->im_agctl[agno].inofree);\r\niagp->inofreeback = cpu_to_le32(-1);\r\nimap->im_agctl[agno].inofree = iagno;\r\n}\r\nIREAD_UNLOCK(ipimap);\r\nif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\r\nsword = extno >> L2EXTSPERSUM;\r\nbitno = extno & (EXTSPERSUM - 1);\r\niagp->inosmap[sword] &=\r\ncpu_to_le32(~(HIGHORDER >> bitno));\r\n}\r\niagp->wmap[extno] = cpu_to_le32(bitmap);\r\nle32_add_cpu(&iagp->nfreeinos, 1);\r\nimap->im_agctl[agno].numfree += 1;\r\natomic_inc(&imap->im_numfree);\r\nAG_UNLOCK(imap, agno);\r\nwrite_metapage(mp);\r\nreturn (0);\r\n}\r\namp = bmp = cmp = dmp = NULL;\r\nfwd = back = -1;\r\nif (iagp->nfreeexts == 0) {\r\nif ((fwd = imap->im_agctl[agno].extfree) >= 0) {\r\nif ((rc = diIAGRead(imap, fwd, &amp)))\r\ngoto error_out;\r\naiagp = (struct iag *) amp->data;\r\n}\r\n} else {\r\nif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {\r\nif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {\r\nif ((rc = diIAGRead(imap, fwd, &amp)))\r\ngoto error_out;\r\naiagp = (struct iag *) amp->data;\r\n}\r\nif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {\r\nif ((rc = diIAGRead(imap, back, &bmp)))\r\ngoto error_out;\r\nbiagp = (struct iag *) bmp->data;\r\n}\r\n}\r\n}\r\nif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {\r\nint inofreeback = le32_to_cpu(iagp->inofreeback);\r\nint inofreefwd = le32_to_cpu(iagp->inofreefwd);\r\nif (inofreefwd >= 0) {\r\nif (inofreefwd == fwd)\r\nciagp = (struct iag *) amp->data;\r\nelse if (inofreefwd == back)\r\nciagp = (struct iag *) bmp->data;\r\nelse {\r\nif ((rc =\r\ndiIAGRead(imap, inofreefwd, &cmp)))\r\ngoto error_out;\r\nciagp = (struct iag *) cmp->data;\r\n}\r\nassert(ciagp != NULL);\r\n}\r\nif (inofreeback >= 0) {\r\nif (inofreeback == fwd)\r\ndiagp = (struct iag *) amp->data;\r\nelse if (inofreeback == back)\r\ndiagp = (struct iag *) bmp->data;\r\nelse {\r\nif ((rc =\r\ndiIAGRead(imap, inofreeback, &dmp)))\r\ngoto error_out;\r\ndiagp = (struct iag *) dmp->data;\r\n}\r\nassert(diagp != NULL);\r\n}\r\n}\r\nIREAD_UNLOCK(ipimap);\r\nfreepxd = iagp->inoext[extno];\r\ninvalidate_pxd_metapages(ip, freepxd);\r\nif (iagp->nfreeexts == 0) {\r\nif (fwd >= 0)\r\naiagp->extfreeback = cpu_to_le32(iagno);\r\niagp->extfreefwd =\r\ncpu_to_le32(imap->im_agctl[agno].extfree);\r\niagp->extfreeback = cpu_to_le32(-1);\r\nimap->im_agctl[agno].extfree = iagno;\r\n} else {\r\nif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {\r\nif (fwd >= 0)\r\naiagp->extfreeback = iagp->extfreeback;\r\nif (back >= 0)\r\nbiagp->extfreefwd = iagp->extfreefwd;\r\nelse\r\nimap->im_agctl[agno].extfree =\r\nle32_to_cpu(iagp->extfreefwd);\r\niagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\r\nIAGFREE_LOCK(imap);\r\niagp->iagfree = cpu_to_le32(imap->im_freeiag);\r\nimap->im_freeiag = iagno;\r\nIAGFREE_UNLOCK(imap);\r\n}\r\n}\r\nif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {\r\nif ((int) le32_to_cpu(iagp->inofreefwd) >= 0)\r\nciagp->inofreeback = iagp->inofreeback;\r\nif ((int) le32_to_cpu(iagp->inofreeback) >= 0)\r\ndiagp->inofreefwd = iagp->inofreefwd;\r\nelse\r\nimap->im_agctl[agno].inofree =\r\nle32_to_cpu(iagp->inofreefwd);\r\niagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\r\n}\r\nif (iagp->pmap[extno] != 0) {\r\njfs_error(ip->i_sb, "the pmap does not show inode free\n");\r\n}\r\niagp->wmap[extno] = 0;\r\nPXDlength(&iagp->inoext[extno], 0);\r\nPXDaddress(&iagp->inoext[extno], 0);\r\nsword = extno >> L2EXTSPERSUM;\r\nbitno = extno & (EXTSPERSUM - 1);\r\nmask = HIGHORDER >> bitno;\r\niagp->inosmap[sword] |= cpu_to_le32(mask);\r\niagp->extsmap[sword] &= cpu_to_le32(~mask);\r\nle32_add_cpu(&iagp->nfreeinos, -(INOSPEREXT - 1));\r\nle32_add_cpu(&iagp->nfreeexts, 1);\r\nimap->im_agctl[agno].numfree -= (INOSPEREXT - 1);\r\nimap->im_agctl[agno].numinos -= INOSPEREXT;\r\natomic_sub(INOSPEREXT - 1, &imap->im_numfree);\r\natomic_sub(INOSPEREXT, &imap->im_numinos);\r\nif (amp)\r\nwrite_metapage(amp);\r\nif (bmp)\r\nwrite_metapage(bmp);\r\nif (cmp)\r\nwrite_metapage(cmp);\r\nif (dmp)\r\nwrite_metapage(dmp);\r\ntid = txBegin(ipimap->i_sb, COMMIT_FORCE);\r\nmutex_lock(&JFS_IP(ipimap)->commit_mutex);\r\ntlck = txLock(tid, ipimap, mp, tlckINODE | tlckFREE);\r\npxdlock = (struct pxd_lock *) & tlck->lock;\r\npxdlock->flag = mlckFREEPXD;\r\npxdlock->pxd = freepxd;\r\npxdlock->index = 1;\r\nwrite_metapage(mp);\r\niplist[0] = ipimap;\r\niplist[1] = (struct inode *) (size_t)iagno;\r\niplist[2] = (struct inode *) (size_t)extno;\r\nrc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\r\ntxEnd(tid);\r\nmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\r\nAG_UNLOCK(imap, agno);\r\nreturn (0);\r\nerror_out:\r\nIREAD_UNLOCK(ipimap);\r\nif (amp)\r\nrelease_metapage(amp);\r\nif (bmp)\r\nrelease_metapage(bmp);\r\nif (cmp)\r\nrelease_metapage(cmp);\r\nif (dmp)\r\nrelease_metapage(dmp);\r\nAG_UNLOCK(imap, agno);\r\nrelease_metapage(mp);\r\nreturn (rc);\r\n}\r\nstatic inline void\r\ndiInitInode(struct inode *ip, int iagno, int ino, int extno, struct iag * iagp)\r\n{\r\nstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\r\nip->i_ino = (iagno << L2INOSPERIAG) + ino;\r\njfs_ip->ixpxd = iagp->inoext[extno];\r\njfs_ip->agstart = le64_to_cpu(iagp->agstart);\r\njfs_ip->active_ag = -1;\r\n}\r\nint diAlloc(struct inode *pip, bool dir, struct inode *ip)\r\n{\r\nint rc, ino, iagno, addext, extno, bitno, sword;\r\nint nwords, rem, i, agno;\r\nu32 mask, inosmap, extsmap;\r\nstruct inode *ipimap;\r\nstruct metapage *mp;\r\nino_t inum;\r\nstruct iag *iagp;\r\nstruct inomap *imap;\r\nipimap = JFS_SBI(pip->i_sb)->ipimap;\r\nimap = JFS_IP(ipimap)->i_imap;\r\nJFS_IP(ip)->ipimap = ipimap;\r\nJFS_IP(ip)->fileset = FILESYSTEM_I;\r\nif (dir) {\r\nagno = dbNextAG(JFS_SBI(pip->i_sb)->ipbmap);\r\nAG_LOCK(imap, agno);\r\ngoto tryag;\r\n}\r\nagno = BLKTOAG(JFS_IP(pip)->agstart, JFS_SBI(pip->i_sb));\r\nif (atomic_read(&JFS_SBI(pip->i_sb)->bmap->db_active[agno])) {\r\nagno = dbNextAG(JFS_SBI(pip->i_sb)->ipbmap);\r\nAG_LOCK(imap, agno);\r\ngoto tryag;\r\n}\r\ninum = pip->i_ino + 1;\r\nino = inum & (INOSPERIAG - 1);\r\nif (ino == 0)\r\ninum = pip->i_ino;\r\nAG_LOCK(imap, agno);\r\nIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\r\niagno = INOTOIAG(inum);\r\nif ((rc = diIAGRead(imap, iagno, &mp))) {\r\nIREAD_UNLOCK(ipimap);\r\nAG_UNLOCK(imap, agno);\r\nreturn (rc);\r\n}\r\niagp = (struct iag *) mp->data;\r\naddext = (imap->im_agctl[agno].numfree < 32 && iagp->nfreeexts);\r\nif (iagp->nfreeinos || addext) {\r\nextno = ino >> L2INOSPEREXT;\r\nif (addressPXD(&iagp->inoext[extno])) {\r\nbitno = ino & (INOSPEREXT - 1);\r\nif ((bitno =\r\ndiFindFree(le32_to_cpu(iagp->wmap[extno]),\r\nbitno))\r\n< INOSPEREXT) {\r\nino = (extno << L2INOSPEREXT) + bitno;\r\nrc = diAllocBit(imap, iagp, ino);\r\nIREAD_UNLOCK(ipimap);\r\nif (rc) {\r\nassert(rc == -EIO);\r\n} else {\r\ndiInitInode(ip, iagno, ino, extno,\r\niagp);\r\nmark_metapage_dirty(mp);\r\n}\r\nrelease_metapage(mp);\r\nAG_UNLOCK(imap, agno);\r\nreturn (rc);\r\n}\r\nif (!addext)\r\nextno =\r\n(extno ==\r\nEXTSPERIAG - 1) ? 0 : extno + 1;\r\n}\r\nbitno = extno & (EXTSPERSUM - 1);\r\nnwords = (bitno == 0) ? SMAPSZ : SMAPSZ + 1;\r\nsword = extno >> L2EXTSPERSUM;\r\nmask = (bitno == 0) ? 0 : (ONES << (EXTSPERSUM - bitno));\r\ninosmap = le32_to_cpu(iagp->inosmap[sword]) | mask;\r\nextsmap = le32_to_cpu(iagp->extsmap[sword]) | mask;\r\nfor (i = 0; i < nwords; i++) {\r\nif (~inosmap) {\r\nrem = diFindFree(inosmap, 0);\r\nextno = (sword << L2EXTSPERSUM) + rem;\r\nrem = diFindFree(le32_to_cpu(iagp->wmap[extno]),\r\n0);\r\nif (rem >= INOSPEREXT) {\r\nIREAD_UNLOCK(ipimap);\r\nrelease_metapage(mp);\r\nAG_UNLOCK(imap, agno);\r\njfs_error(ip->i_sb,\r\n"can't find free bit in wmap\n");\r\nreturn -EIO;\r\n}\r\nino = (extno << L2INOSPEREXT) + rem;\r\nrc = diAllocBit(imap, iagp, ino);\r\nIREAD_UNLOCK(ipimap);\r\nif (rc)\r\nassert(rc == -EIO);\r\nelse {\r\ndiInitInode(ip, iagno, ino, extno,\r\niagp);\r\nmark_metapage_dirty(mp);\r\n}\r\nrelease_metapage(mp);\r\nAG_UNLOCK(imap, agno);\r\nreturn (rc);\r\n}\r\nif (addext && ~extsmap) {\r\nrem = diFindFree(extsmap, 0);\r\nextno = (sword << L2EXTSPERSUM) + rem;\r\nif ((rc = diNewExt(imap, iagp, extno))) {\r\nif (rc == -ENOSPC)\r\nbreak;\r\nassert(rc == -EIO);\r\n} else {\r\ndiInitInode(ip, iagno,\r\nextno << L2INOSPEREXT,\r\nextno, iagp);\r\nmark_metapage_dirty(mp);\r\n}\r\nrelease_metapage(mp);\r\nIREAD_UNLOCK(ipimap);\r\nAG_UNLOCK(imap, agno);\r\nreturn (rc);\r\n}\r\nsword = (sword == SMAPSZ - 1) ? 0 : sword + 1;\r\ninosmap = le32_to_cpu(iagp->inosmap[sword]);\r\nextsmap = le32_to_cpu(iagp->extsmap[sword]);\r\n}\r\n}\r\nIREAD_UNLOCK(ipimap);\r\nrelease_metapage(mp);\r\ntryag:\r\nrc = diAllocAG(imap, agno, dir, ip);\r\nAG_UNLOCK(imap, agno);\r\nif (rc != -ENOSPC)\r\nreturn (rc);\r\nreturn (diAllocAny(imap, agno, dir, ip));\r\n}\r\nstatic int\r\ndiAllocAG(struct inomap * imap, int agno, bool dir, struct inode *ip)\r\n{\r\nint rc, addext, numfree, numinos;\r\nnumfree = imap->im_agctl[agno].numfree;\r\nnuminos = imap->im_agctl[agno].numinos;\r\nif (numfree > numinos) {\r\njfs_error(ip->i_sb, "numfree > numinos\n");\r\nreturn -EIO;\r\n}\r\nif (dir)\r\naddext = (numfree < 64 ||\r\n(numfree < 256\r\n&& ((numfree * 100) / numinos) <= 20));\r\nelse\r\naddext = (numfree == 0);\r\nif (addext) {\r\nif ((rc = diAllocExt(imap, agno, ip)) != -ENOSPC)\r\nreturn (rc);\r\n}\r\nreturn (diAllocIno(imap, agno, ip));\r\n}\r\nstatic int\r\ndiAllocAny(struct inomap * imap, int agno, bool dir, struct inode *ip)\r\n{\r\nint ag, rc;\r\nint maxag = JFS_SBI(imap->im_ipimap->i_sb)->bmap->db_maxag;\r\nfor (ag = agno + 1; ag <= maxag; ag++) {\r\nAG_LOCK(imap, ag);\r\nrc = diAllocAG(imap, ag, dir, ip);\r\nAG_UNLOCK(imap, ag);\r\nif (rc != -ENOSPC)\r\nreturn (rc);\r\n}\r\nfor (ag = 0; ag < agno; ag++) {\r\nAG_LOCK(imap, ag);\r\nrc = diAllocAG(imap, ag, dir, ip);\r\nAG_UNLOCK(imap, ag);\r\nif (rc != -ENOSPC)\r\nreturn (rc);\r\n}\r\nreturn -ENOSPC;\r\n}\r\nstatic int diAllocIno(struct inomap * imap, int agno, struct inode *ip)\r\n{\r\nint iagno, ino, rc, rem, extno, sword;\r\nstruct metapage *mp;\r\nstruct iag *iagp;\r\nif ((iagno = imap->im_agctl[agno].inofree) < 0)\r\nreturn -ENOSPC;\r\nIREAD_LOCK(imap->im_ipimap, RDWRLOCK_IMAP);\r\nif ((rc = diIAGRead(imap, iagno, &mp))) {\r\nIREAD_UNLOCK(imap->im_ipimap);\r\nreturn (rc);\r\n}\r\niagp = (struct iag *) mp->data;\r\nif (!iagp->nfreeinos) {\r\nIREAD_UNLOCK(imap->im_ipimap);\r\nrelease_metapage(mp);\r\njfs_error(ip->i_sb, "nfreeinos = 0, but iag on freelist\n");\r\nreturn -EIO;\r\n}\r\nfor (sword = 0;; sword++) {\r\nif (sword >= SMAPSZ) {\r\nIREAD_UNLOCK(imap->im_ipimap);\r\nrelease_metapage(mp);\r\njfs_error(ip->i_sb,\r\n"free inode not found in summary map\n");\r\nreturn -EIO;\r\n}\r\nif (~iagp->inosmap[sword])\r\nbreak;\r\n}\r\nrem = diFindFree(le32_to_cpu(iagp->inosmap[sword]), 0);\r\nif (rem >= EXTSPERSUM) {\r\nIREAD_UNLOCK(imap->im_ipimap);\r\nrelease_metapage(mp);\r\njfs_error(ip->i_sb, "no free extent found\n");\r\nreturn -EIO;\r\n}\r\nextno = (sword << L2EXTSPERSUM) + rem;\r\nrem = diFindFree(le32_to_cpu(iagp->wmap[extno]), 0);\r\nif (rem >= INOSPEREXT) {\r\nIREAD_UNLOCK(imap->im_ipimap);\r\nrelease_metapage(mp);\r\njfs_error(ip->i_sb, "free inode not found\n");\r\nreturn -EIO;\r\n}\r\nino = (extno << L2INOSPEREXT) + rem;\r\nrc = diAllocBit(imap, iagp, ino);\r\nIREAD_UNLOCK(imap->im_ipimap);\r\nif (rc) {\r\nrelease_metapage(mp);\r\nreturn (rc);\r\n}\r\ndiInitInode(ip, iagno, ino, extno, iagp);\r\nwrite_metapage(mp);\r\nreturn (0);\r\n}\r\nstatic int diAllocExt(struct inomap * imap, int agno, struct inode *ip)\r\n{\r\nint rem, iagno, sword, extno, rc;\r\nstruct metapage *mp;\r\nstruct iag *iagp;\r\nif ((iagno = imap->im_agctl[agno].extfree) < 0) {\r\nif ((rc = diNewIAG(imap, &iagno, agno, &mp))) {\r\nreturn (rc);\r\n}\r\niagp = (struct iag *) mp->data;\r\niagp->agstart =\r\ncpu_to_le64(AGTOBLK(agno, imap->im_ipimap));\r\n} else {\r\nIREAD_LOCK(imap->im_ipimap, RDWRLOCK_IMAP);\r\nif ((rc = diIAGRead(imap, iagno, &mp))) {\r\nIREAD_UNLOCK(imap->im_ipimap);\r\njfs_error(ip->i_sb, "error reading iag\n");\r\nreturn rc;\r\n}\r\niagp = (struct iag *) mp->data;\r\n}\r\nfor (sword = 0;; sword++) {\r\nif (sword >= SMAPSZ) {\r\nrelease_metapage(mp);\r\nIREAD_UNLOCK(imap->im_ipimap);\r\njfs_error(ip->i_sb, "free ext summary map not found\n");\r\nreturn -EIO;\r\n}\r\nif (~iagp->extsmap[sword])\r\nbreak;\r\n}\r\nrem = diFindFree(le32_to_cpu(iagp->extsmap[sword]), 0);\r\nif (rem >= EXTSPERSUM) {\r\nrelease_metapage(mp);\r\nIREAD_UNLOCK(imap->im_ipimap);\r\njfs_error(ip->i_sb, "free extent not found\n");\r\nreturn -EIO;\r\n}\r\nextno = (sword << L2EXTSPERSUM) + rem;\r\nrc = diNewExt(imap, iagp, extno);\r\nIREAD_UNLOCK(imap->im_ipimap);\r\nif (rc) {\r\nif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\r\nIAGFREE_LOCK(imap);\r\niagp->iagfree = cpu_to_le32(imap->im_freeiag);\r\nimap->im_freeiag = iagno;\r\nIAGFREE_UNLOCK(imap);\r\n}\r\nwrite_metapage(mp);\r\nreturn (rc);\r\n}\r\ndiInitInode(ip, iagno, extno << L2INOSPEREXT, extno, iagp);\r\nwrite_metapage(mp);\r\nreturn (0);\r\n}\r\nstatic int diAllocBit(struct inomap * imap, struct iag * iagp, int ino)\r\n{\r\nint extno, bitno, agno, sword, rc;\r\nstruct metapage *amp = NULL, *bmp = NULL;\r\nstruct iag *aiagp = NULL, *biagp = NULL;\r\nu32 mask;\r\nif (iagp->nfreeinos == cpu_to_le32(1)) {\r\nif ((int) le32_to_cpu(iagp->inofreefwd) >= 0) {\r\nif ((rc =\r\ndiIAGRead(imap, le32_to_cpu(iagp->inofreefwd),\r\n&amp)))\r\nreturn (rc);\r\naiagp = (struct iag *) amp->data;\r\n}\r\nif ((int) le32_to_cpu(iagp->inofreeback) >= 0) {\r\nif ((rc =\r\ndiIAGRead(imap,\r\nle32_to_cpu(iagp->inofreeback),\r\n&bmp))) {\r\nif (amp)\r\nrelease_metapage(amp);\r\nreturn (rc);\r\n}\r\nbiagp = (struct iag *) bmp->data;\r\n}\r\n}\r\nagno = BLKTOAG(le64_to_cpu(iagp->agstart), JFS_SBI(imap->im_ipimap->i_sb));\r\nextno = ino >> L2INOSPEREXT;\r\nbitno = ino & (INOSPEREXT - 1);\r\nmask = HIGHORDER >> bitno;\r\nif (((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) ||\r\n((le32_to_cpu(iagp->wmap[extno]) & mask) != 0) ||\r\n(addressPXD(&iagp->inoext[extno]) == 0)) {\r\nif (amp)\r\nrelease_metapage(amp);\r\nif (bmp)\r\nrelease_metapage(bmp);\r\njfs_error(imap->im_ipimap->i_sb, "iag inconsistent\n");\r\nreturn -EIO;\r\n}\r\niagp->wmap[extno] |= cpu_to_le32(mask);\r\nif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\r\nsword = extno >> L2EXTSPERSUM;\r\nbitno = extno & (EXTSPERSUM - 1);\r\niagp->inosmap[sword] |= cpu_to_le32(HIGHORDER >> bitno);\r\n}\r\nif (iagp->nfreeinos == cpu_to_le32(1)) {\r\nif (amp) {\r\naiagp->inofreeback = iagp->inofreeback;\r\nwrite_metapage(amp);\r\n}\r\nif (bmp) {\r\nbiagp->inofreefwd = iagp->inofreefwd;\r\nwrite_metapage(bmp);\r\n} else {\r\nimap->im_agctl[agno].inofree =\r\nle32_to_cpu(iagp->inofreefwd);\r\n}\r\niagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\r\n}\r\nle32_add_cpu(&iagp->nfreeinos, -1);\r\nimap->im_agctl[agno].numfree -= 1;\r\natomic_dec(&imap->im_numfree);\r\nreturn (0);\r\n}\r\nstatic int diNewExt(struct inomap * imap, struct iag * iagp, int extno)\r\n{\r\nint agno, iagno, fwd, back, freei = 0, sword, rc;\r\nstruct iag *aiagp = NULL, *biagp = NULL, *ciagp = NULL;\r\nstruct metapage *amp, *bmp, *cmp, *dmp;\r\nstruct inode *ipimap;\r\ns64 blkno, hint;\r\nint i, j;\r\nu32 mask;\r\nino_t ino;\r\nstruct dinode *dp;\r\nstruct jfs_sb_info *sbi;\r\nif (!iagp->nfreeexts) {\r\njfs_error(imap->im_ipimap->i_sb, "no free extents\n");\r\nreturn -EIO;\r\n}\r\nipimap = imap->im_ipimap;\r\nsbi = JFS_SBI(ipimap->i_sb);\r\namp = bmp = cmp = NULL;\r\nagno = BLKTOAG(le64_to_cpu(iagp->agstart), sbi);\r\niagno = le32_to_cpu(iagp->iagnum);\r\nif (iagp->nfreeexts == cpu_to_le32(1)) {\r\nif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {\r\nif ((rc = diIAGRead(imap, fwd, &amp)))\r\nreturn (rc);\r\naiagp = (struct iag *) amp->data;\r\n}\r\nif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {\r\nif ((rc = diIAGRead(imap, back, &bmp)))\r\ngoto error_out;\r\nbiagp = (struct iag *) bmp->data;\r\n}\r\n} else {\r\nfwd = back = -1;\r\nif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\r\nif ((fwd = imap->im_agctl[agno].extfree) >= 0) {\r\nif ((rc = diIAGRead(imap, fwd, &amp)))\r\ngoto error_out;\r\naiagp = (struct iag *) amp->data;\r\n}\r\n}\r\n}\r\nif (iagp->nfreeinos == 0) {\r\nfreei = imap->im_agctl[agno].inofree;\r\nif (freei >= 0) {\r\nif (freei == fwd) {\r\nciagp = aiagp;\r\n} else if (freei == back) {\r\nciagp = biagp;\r\n} else {\r\nif ((rc = diIAGRead(imap, freei, &cmp)))\r\ngoto error_out;\r\nciagp = (struct iag *) cmp->data;\r\n}\r\nif (ciagp == NULL) {\r\njfs_error(imap->im_ipimap->i_sb,\r\n"ciagp == NULL\n");\r\nrc = -EIO;\r\ngoto error_out;\r\n}\r\n}\r\n}\r\nif ((extno == 0) || (addressPXD(&iagp->inoext[extno - 1]) == 0))\r\nhint = ((s64) agno << sbi->bmap->db_agl2size) - 1;\r\nelse\r\nhint = addressPXD(&iagp->inoext[extno - 1]) +\r\nlengthPXD(&iagp->inoext[extno - 1]) - 1;\r\nif ((rc = dbAlloc(ipimap, hint, (s64) imap->im_nbperiext, &blkno)))\r\ngoto error_out;\r\nino = (iagno << L2INOSPERIAG) + (extno << L2INOSPEREXT);\r\nfor (i = 0; i < imap->im_nbperiext; i += sbi->nbperpage) {\r\ndmp = get_metapage(ipimap, blkno + i, PSIZE, 1);\r\nif (dmp == NULL) {\r\nrc = -EIO;\r\ngoto error_out;\r\n}\r\ndp = (struct dinode *) dmp->data;\r\nfor (j = 0; j < INOSPERPAGE; j++, dp++, ino++) {\r\ndp->di_inostamp = cpu_to_le32(sbi->inostamp);\r\ndp->di_number = cpu_to_le32(ino);\r\ndp->di_fileset = cpu_to_le32(FILESYSTEM_I);\r\ndp->di_mode = 0;\r\ndp->di_nlink = 0;\r\nPXDaddress(&(dp->di_ixpxd), blkno);\r\nPXDlength(&(dp->di_ixpxd), imap->im_nbperiext);\r\n}\r\nwrite_metapage(dmp);\r\n}\r\nif (iagp->nfreeexts == cpu_to_le32(1)) {\r\nif (fwd >= 0)\r\naiagp->extfreeback = iagp->extfreeback;\r\nif (back >= 0)\r\nbiagp->extfreefwd = iagp->extfreefwd;\r\nelse\r\nimap->im_agctl[agno].extfree =\r\nle32_to_cpu(iagp->extfreefwd);\r\niagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\r\n} else {\r\nif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\r\nif (fwd >= 0)\r\naiagp->extfreeback = cpu_to_le32(iagno);\r\niagp->extfreefwd = cpu_to_le32(fwd);\r\niagp->extfreeback = cpu_to_le32(-1);\r\nimap->im_agctl[agno].extfree = iagno;\r\n}\r\n}\r\nif (iagp->nfreeinos == 0) {\r\nif (freei >= 0)\r\nciagp->inofreeback = cpu_to_le32(iagno);\r\niagp->inofreefwd =\r\ncpu_to_le32(imap->im_agctl[agno].inofree);\r\niagp->inofreeback = cpu_to_le32(-1);\r\nimap->im_agctl[agno].inofree = iagno;\r\n}\r\nPXDlength(&iagp->inoext[extno], imap->im_nbperiext);\r\nPXDaddress(&iagp->inoext[extno], blkno);\r\niagp->wmap[extno] = cpu_to_le32(HIGHORDER);\r\niagp->pmap[extno] = 0;\r\nsword = extno >> L2EXTSPERSUM;\r\nmask = HIGHORDER >> (extno & (EXTSPERSUM - 1));\r\niagp->extsmap[sword] |= cpu_to_le32(mask);\r\niagp->inosmap[sword] &= cpu_to_le32(~mask);\r\nle32_add_cpu(&iagp->nfreeinos, (INOSPEREXT - 1));\r\nle32_add_cpu(&iagp->nfreeexts, -1);\r\nimap->im_agctl[agno].numfree += (INOSPEREXT - 1);\r\nimap->im_agctl[agno].numinos += INOSPEREXT;\r\natomic_add(INOSPEREXT - 1, &imap->im_numfree);\r\natomic_add(INOSPEREXT, &imap->im_numinos);\r\nif (amp)\r\nwrite_metapage(amp);\r\nif (bmp)\r\nwrite_metapage(bmp);\r\nif (cmp)\r\nwrite_metapage(cmp);\r\nreturn (0);\r\nerror_out:\r\nif (amp)\r\nrelease_metapage(amp);\r\nif (bmp)\r\nrelease_metapage(bmp);\r\nif (cmp)\r\nrelease_metapage(cmp);\r\nreturn (rc);\r\n}\r\nstatic int\r\ndiNewIAG(struct inomap * imap, int *iagnop, int agno, struct metapage ** mpp)\r\n{\r\nint rc;\r\nint iagno, i, xlen;\r\nstruct inode *ipimap;\r\nstruct super_block *sb;\r\nstruct jfs_sb_info *sbi;\r\nstruct metapage *mp;\r\nstruct iag *iagp;\r\ns64 xaddr = 0;\r\ns64 blkno;\r\ntid_t tid;\r\nstruct inode *iplist[1];\r\nipimap = imap->im_ipimap;\r\nsb = ipimap->i_sb;\r\nsbi = JFS_SBI(sb);\r\nIAGFREE_LOCK(imap);\r\nif (imap->im_freeiag >= 0) {\r\niagno = imap->im_freeiag;\r\nblkno = IAGTOLBLK(iagno, sbi->l2nbperpage);\r\n} else {\r\nIWRITE_LOCK(ipimap, RDWRLOCK_IMAP);\r\nif (ipimap->i_size >> L2PSIZE != imap->im_nextiag + 1) {\r\nIWRITE_UNLOCK(ipimap);\r\nIAGFREE_UNLOCK(imap);\r\njfs_error(imap->im_ipimap->i_sb,\r\n"ipimap->i_size is wrong\n");\r\nreturn -EIO;\r\n}\r\niagno = imap->im_nextiag;\r\nif (iagno > (MAXIAGS - 1)) {\r\nIWRITE_UNLOCK(ipimap);\r\nrc = -ENOSPC;\r\ngoto out;\r\n}\r\nblkno = IAGTOLBLK(iagno, sbi->l2nbperpage);\r\nxlen = sbi->nbperpage;\r\nif ((rc = dbAlloc(ipimap, 0, (s64) xlen, &xaddr))) {\r\nIWRITE_UNLOCK(ipimap);\r\ngoto out;\r\n}\r\ntid = txBegin(sb, COMMIT_FORCE);\r\nmutex_lock(&JFS_IP(ipimap)->commit_mutex);\r\nif ((rc =\r\nxtInsert(tid, ipimap, 0, blkno, xlen, &xaddr, 0))) {\r\ntxEnd(tid);\r\nmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\r\ndbFree(ipimap, xaddr, (s64) xlen);\r\nIWRITE_UNLOCK(ipimap);\r\ngoto out;\r\n}\r\nipimap->i_size += PSIZE;\r\ninode_add_bytes(ipimap, PSIZE);\r\nmp = get_metapage(ipimap, blkno, PSIZE, 0);\r\nif (!mp) {\r\nxtTruncate(tid, ipimap, ipimap->i_size - PSIZE,\r\nCOMMIT_PWMAP);\r\ntxAbort(tid, 0);\r\ntxEnd(tid);\r\nmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\r\nIWRITE_UNLOCK(ipimap);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\niagp = (struct iag *) mp->data;\r\nmemset(iagp, 0, sizeof(struct iag));\r\niagp->iagnum = cpu_to_le32(iagno);\r\niagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\r\niagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\r\niagp->iagfree = cpu_to_le32(-1);\r\niagp->nfreeinos = 0;\r\niagp->nfreeexts = cpu_to_le32(EXTSPERIAG);\r\nfor (i = 0; i < SMAPSZ; i++)\r\niagp->inosmap[i] = cpu_to_le32(ONES);\r\nflush_metapage(mp);\r\niplist[0] = ipimap;\r\nrc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\r\ntxEnd(tid);\r\nmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\r\nduplicateIXtree(sb, blkno, xlen, &xaddr);\r\nimap->im_nextiag += 1;\r\nimap->im_freeiag = iagno;\r\ndiSync(ipimap);\r\nIWRITE_UNLOCK(ipimap);\r\n}\r\nIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\r\nif ((rc = diIAGRead(imap, iagno, &mp))) {\r\nIREAD_UNLOCK(ipimap);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\niagp = (struct iag *) mp->data;\r\nimap->im_freeiag = le32_to_cpu(iagp->iagfree);\r\niagp->iagfree = cpu_to_le32(-1);\r\n*iagnop = iagno;\r\n*mpp = mp;\r\nout:\r\nIAGFREE_UNLOCK(imap);\r\nreturn (rc);\r\n}\r\nstatic int diIAGRead(struct inomap * imap, int iagno, struct metapage ** mpp)\r\n{\r\nstruct inode *ipimap = imap->im_ipimap;\r\ns64 blkno;\r\nblkno = IAGTOLBLK(iagno, JFS_SBI(ipimap->i_sb)->l2nbperpage);\r\n*mpp = read_metapage(ipimap, blkno, PSIZE, 0);\r\nif (*mpp == NULL) {\r\nreturn -EIO;\r\n}\r\nreturn (0);\r\n}\r\nstatic int diFindFree(u32 word, int start)\r\n{\r\nint bitno;\r\nassert(start < 32);\r\nfor (word <<= start, bitno = start; bitno < 32;\r\nbitno++, word <<= 1) {\r\nif ((word & HIGHORDER) == 0)\r\nbreak;\r\n}\r\nreturn (bitno);\r\n}\r\nint\r\ndiUpdatePMap(struct inode *ipimap,\r\nunsigned long inum, bool is_free, struct tblock * tblk)\r\n{\r\nint rc;\r\nstruct iag *iagp;\r\nstruct metapage *mp;\r\nint iagno, ino, extno, bitno;\r\nstruct inomap *imap;\r\nu32 mask;\r\nstruct jfs_log *log;\r\nint lsn, difft, diffp;\r\nunsigned long flags;\r\nimap = JFS_IP(ipimap)->i_imap;\r\niagno = INOTOIAG(inum);\r\nif (iagno >= imap->im_nextiag) {\r\njfs_error(ipimap->i_sb, "the iag is outside the map\n");\r\nreturn -EIO;\r\n}\r\nIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\r\nrc = diIAGRead(imap, iagno, &mp);\r\nIREAD_UNLOCK(ipimap);\r\nif (rc)\r\nreturn (rc);\r\nmetapage_wait_for_io(mp);\r\niagp = (struct iag *) mp->data;\r\nino = inum & (INOSPERIAG - 1);\r\nextno = ino >> L2INOSPEREXT;\r\nbitno = ino & (INOSPEREXT - 1);\r\nmask = HIGHORDER >> bitno;\r\nif (is_free) {\r\nif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\r\njfs_error(ipimap->i_sb,\r\n"inode %ld not marked as allocated in wmap!\n",\r\ninum);\r\n}\r\nif (!(le32_to_cpu(iagp->pmap[extno]) & mask)) {\r\njfs_error(ipimap->i_sb,\r\n"inode %ld not marked as allocated in pmap!\n",\r\ninum);\r\n}\r\niagp->pmap[extno] &= cpu_to_le32(~mask);\r\n}\r\nelse {\r\nif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\r\nrelease_metapage(mp);\r\njfs_error(ipimap->i_sb,\r\n"the inode is not allocated in the working map\n");\r\nreturn -EIO;\r\n}\r\nif ((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) {\r\nrelease_metapage(mp);\r\njfs_error(ipimap->i_sb,\r\n"the inode is not free in the persistent map\n");\r\nreturn -EIO;\r\n}\r\niagp->pmap[extno] |= cpu_to_le32(mask);\r\n}\r\nlsn = tblk->lsn;\r\nlog = JFS_SBI(tblk->sb)->log;\r\nLOGSYNC_LOCK(log, flags);\r\nif (mp->lsn != 0) {\r\nlogdiff(difft, lsn, log);\r\nlogdiff(diffp, mp->lsn, log);\r\nif (difft < diffp) {\r\nmp->lsn = lsn;\r\nlist_move(&mp->synclist, &tblk->synclist);\r\n}\r\nassert(mp->clsn);\r\nlogdiff(difft, tblk->clsn, log);\r\nlogdiff(diffp, mp->clsn, log);\r\nif (difft > diffp)\r\nmp->clsn = tblk->clsn;\r\n} else {\r\nmp->log = log;\r\nmp->lsn = lsn;\r\nlog->count++;\r\nlist_add(&mp->synclist, &tblk->synclist);\r\nmp->clsn = tblk->clsn;\r\n}\r\nLOGSYNC_UNLOCK(log, flags);\r\nwrite_metapage(mp);\r\nreturn (0);\r\n}\r\nint diExtendFS(struct inode *ipimap, struct inode *ipbmap)\r\n{\r\nint rc, rcx = 0;\r\nstruct inomap *imap = JFS_IP(ipimap)->i_imap;\r\nstruct iag *iagp = NULL, *hiagp = NULL;\r\nstruct bmap *mp = JFS_SBI(ipbmap->i_sb)->bmap;\r\nstruct metapage *bp, *hbp;\r\nint i, n, head;\r\nint numinos, xnuminos = 0, xnumfree = 0;\r\ns64 agstart;\r\njfs_info("diExtendFS: nextiag:%d numinos:%d numfree:%d",\r\nimap->im_nextiag, atomic_read(&imap->im_numinos),\r\natomic_read(&imap->im_numfree));\r\nfor (i = 0; i < MAXAG; i++) {\r\nimap->im_agctl[i].inofree = -1;\r\nimap->im_agctl[i].extfree = -1;\r\nimap->im_agctl[i].numinos = 0;\r\nimap->im_agctl[i].numfree = 0;\r\n}\r\nfor (i = 0; i < imap->im_nextiag; i++) {\r\nif ((rc = diIAGRead(imap, i, &bp))) {\r\nrcx = rc;\r\ncontinue;\r\n}\r\niagp = (struct iag *) bp->data;\r\nif (le32_to_cpu(iagp->iagnum) != i) {\r\nrelease_metapage(bp);\r\njfs_error(ipimap->i_sb, "unexpected value of iagnum\n");\r\nreturn -EIO;\r\n}\r\nif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG)) {\r\nrelease_metapage(bp);\r\ncontinue;\r\n}\r\nagstart = le64_to_cpu(iagp->agstart);\r\nn = agstart >> mp->db_agl2size;\r\niagp->agstart = cpu_to_le64((s64)n << mp->db_agl2size);\r\nnuminos = (EXTSPERIAG - le32_to_cpu(iagp->nfreeexts))\r\n<< L2INOSPEREXT;\r\nif (numinos > 0) {\r\nimap->im_agctl[n].numinos += numinos;\r\nxnuminos += numinos;\r\n}\r\nif ((int) le32_to_cpu(iagp->nfreeinos) > 0) {\r\nif ((head = imap->im_agctl[n].inofree) == -1) {\r\niagp->inofreefwd = cpu_to_le32(-1);\r\niagp->inofreeback = cpu_to_le32(-1);\r\n} else {\r\nif ((rc = diIAGRead(imap, head, &hbp))) {\r\nrcx = rc;\r\ngoto nextiag;\r\n}\r\nhiagp = (struct iag *) hbp->data;\r\nhiagp->inofreeback = iagp->iagnum;\r\niagp->inofreefwd = cpu_to_le32(head);\r\niagp->inofreeback = cpu_to_le32(-1);\r\nwrite_metapage(hbp);\r\n}\r\nimap->im_agctl[n].inofree =\r\nle32_to_cpu(iagp->iagnum);\r\nimap->im_agctl[n].numfree +=\r\nle32_to_cpu(iagp->nfreeinos);\r\nxnumfree += le32_to_cpu(iagp->nfreeinos);\r\n}\r\nif (le32_to_cpu(iagp->nfreeexts) > 0) {\r\nif ((head = imap->im_agctl[n].extfree) == -1) {\r\niagp->extfreefwd = cpu_to_le32(-1);\r\niagp->extfreeback = cpu_to_le32(-1);\r\n} else {\r\nif ((rc = diIAGRead(imap, head, &hbp))) {\r\nrcx = rc;\r\ngoto nextiag;\r\n}\r\nhiagp = (struct iag *) hbp->data;\r\nhiagp->extfreeback = iagp->iagnum;\r\niagp->extfreefwd = cpu_to_le32(head);\r\niagp->extfreeback = cpu_to_le32(-1);\r\nwrite_metapage(hbp);\r\n}\r\nimap->im_agctl[n].extfree =\r\nle32_to_cpu(iagp->iagnum);\r\n}\r\nnextiag:\r\nwrite_metapage(bp);\r\n}\r\nif (xnuminos != atomic_read(&imap->im_numinos) ||\r\nxnumfree != atomic_read(&imap->im_numfree)) {\r\njfs_error(ipimap->i_sb, "numinos or numfree incorrect\n");\r\nreturn -EIO;\r\n}\r\nreturn rcx;\r\n}\r\nstatic void duplicateIXtree(struct super_block *sb, s64 blkno,\r\nint xlen, s64 *xaddr)\r\n{\r\nstruct jfs_superblock *j_sb;\r\nstruct buffer_head *bh;\r\nstruct inode *ip;\r\ntid_t tid;\r\nif (JFS_SBI(sb)->mntflag & JFS_BAD_SAIT)\r\nreturn;\r\nip = diReadSpecial(sb, FILESYSTEM_I, 1);\r\nif (ip == NULL) {\r\nJFS_SBI(sb)->mntflag |= JFS_BAD_SAIT;\r\nif (readSuper(sb, &bh))\r\nreturn;\r\nj_sb = (struct jfs_superblock *)bh->b_data;\r\nj_sb->s_flag |= cpu_to_le32(JFS_BAD_SAIT);\r\nmark_buffer_dirty(bh);\r\nsync_dirty_buffer(bh);\r\nbrelse(bh);\r\nreturn;\r\n}\r\ntid = txBegin(sb, COMMIT_FORCE);\r\nif (xtInsert(tid, ip, 0, blkno, xlen, xaddr, 0)) {\r\nJFS_SBI(sb)->mntflag |= JFS_BAD_SAIT;\r\ntxAbort(tid, 1);\r\ngoto cleanup;\r\n}\r\nip->i_size += PSIZE;\r\ninode_add_bytes(ip, PSIZE);\r\ntxCommit(tid, 1, &ip, COMMIT_FORCE);\r\ncleanup:\r\ntxEnd(tid);\r\ndiFreeSpecial(ip);\r\n}\r\nstatic int copy_from_dinode(struct dinode * dip, struct inode *ip)\r\n{\r\nstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\r\nstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\r\njfs_ip->fileset = le32_to_cpu(dip->di_fileset);\r\njfs_ip->mode2 = le32_to_cpu(dip->di_mode);\r\njfs_set_inode_flags(ip);\r\nip->i_mode = le32_to_cpu(dip->di_mode) & 0xffff;\r\nif (sbi->umask != -1) {\r\nip->i_mode = (ip->i_mode & ~0777) | (0777 & ~sbi->umask);\r\nif (S_ISDIR(ip->i_mode)) {\r\nif (ip->i_mode & 0400)\r\nip->i_mode |= 0100;\r\nif (ip->i_mode & 0040)\r\nip->i_mode |= 0010;\r\nif (ip->i_mode & 0004)\r\nip->i_mode |= 0001;\r\n}\r\n}\r\nset_nlink(ip, le32_to_cpu(dip->di_nlink));\r\njfs_ip->saved_uid = make_kuid(&init_user_ns, le32_to_cpu(dip->di_uid));\r\nif (!uid_valid(sbi->uid))\r\nip->i_uid = jfs_ip->saved_uid;\r\nelse {\r\nip->i_uid = sbi->uid;\r\n}\r\njfs_ip->saved_gid = make_kgid(&init_user_ns, le32_to_cpu(dip->di_gid));\r\nif (!gid_valid(sbi->gid))\r\nip->i_gid = jfs_ip->saved_gid;\r\nelse {\r\nip->i_gid = sbi->gid;\r\n}\r\nip->i_size = le64_to_cpu(dip->di_size);\r\nip->i_atime.tv_sec = le32_to_cpu(dip->di_atime.tv_sec);\r\nip->i_atime.tv_nsec = le32_to_cpu(dip->di_atime.tv_nsec);\r\nip->i_mtime.tv_sec = le32_to_cpu(dip->di_mtime.tv_sec);\r\nip->i_mtime.tv_nsec = le32_to_cpu(dip->di_mtime.tv_nsec);\r\nip->i_ctime.tv_sec = le32_to_cpu(dip->di_ctime.tv_sec);\r\nip->i_ctime.tv_nsec = le32_to_cpu(dip->di_ctime.tv_nsec);\r\nip->i_blocks = LBLK2PBLK(ip->i_sb, le64_to_cpu(dip->di_nblocks));\r\nip->i_generation = le32_to_cpu(dip->di_gen);\r\njfs_ip->ixpxd = dip->di_ixpxd;\r\njfs_ip->acl = dip->di_acl;\r\njfs_ip->ea = dip->di_ea;\r\njfs_ip->next_index = le32_to_cpu(dip->di_next_index);\r\njfs_ip->otime = le32_to_cpu(dip->di_otime.tv_sec);\r\njfs_ip->acltype = le32_to_cpu(dip->di_acltype);\r\nif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode)) {\r\njfs_ip->dev = le32_to_cpu(dip->di_rdev);\r\nip->i_rdev = new_decode_dev(jfs_ip->dev);\r\n}\r\nif (S_ISDIR(ip->i_mode)) {\r\nmemcpy(&jfs_ip->i_dirtable, &dip->di_dirtable, 384);\r\n} else if (S_ISREG(ip->i_mode) || S_ISLNK(ip->i_mode)) {\r\nmemcpy(&jfs_ip->i_xtroot, &dip->di_xtroot, 288);\r\n} else\r\nmemcpy(&jfs_ip->i_inline_ea, &dip->di_inlineea, 128);\r\njfs_ip->cflag = 0;\r\njfs_ip->btindex = 0;\r\njfs_ip->btorder = 0;\r\njfs_ip->bxflag = 0;\r\njfs_ip->blid = 0;\r\njfs_ip->atlhead = 0;\r\njfs_ip->atltail = 0;\r\njfs_ip->xtlid = 0;\r\nreturn (0);\r\n}\r\nstatic void copy_to_dinode(struct dinode * dip, struct inode *ip)\r\n{\r\nstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\r\nstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\r\ndip->di_fileset = cpu_to_le32(jfs_ip->fileset);\r\ndip->di_inostamp = cpu_to_le32(sbi->inostamp);\r\ndip->di_number = cpu_to_le32(ip->i_ino);\r\ndip->di_gen = cpu_to_le32(ip->i_generation);\r\ndip->di_size = cpu_to_le64(ip->i_size);\r\ndip->di_nblocks = cpu_to_le64(PBLK2LBLK(ip->i_sb, ip->i_blocks));\r\ndip->di_nlink = cpu_to_le32(ip->i_nlink);\r\nif (!uid_valid(sbi->uid))\r\ndip->di_uid = cpu_to_le32(i_uid_read(ip));\r\nelse\r\ndip->di_uid =cpu_to_le32(from_kuid(&init_user_ns,\r\njfs_ip->saved_uid));\r\nif (!gid_valid(sbi->gid))\r\ndip->di_gid = cpu_to_le32(i_gid_read(ip));\r\nelse\r\ndip->di_gid = cpu_to_le32(from_kgid(&init_user_ns,\r\njfs_ip->saved_gid));\r\nif (sbi->umask == -1)\r\ndip->di_mode = cpu_to_le32((jfs_ip->mode2 & 0xffff0000) |\r\nip->i_mode);\r\nelse\r\ndip->di_mode = cpu_to_le32(jfs_ip->mode2);\r\ndip->di_atime.tv_sec = cpu_to_le32(ip->i_atime.tv_sec);\r\ndip->di_atime.tv_nsec = cpu_to_le32(ip->i_atime.tv_nsec);\r\ndip->di_ctime.tv_sec = cpu_to_le32(ip->i_ctime.tv_sec);\r\ndip->di_ctime.tv_nsec = cpu_to_le32(ip->i_ctime.tv_nsec);\r\ndip->di_mtime.tv_sec = cpu_to_le32(ip->i_mtime.tv_sec);\r\ndip->di_mtime.tv_nsec = cpu_to_le32(ip->i_mtime.tv_nsec);\r\ndip->di_ixpxd = jfs_ip->ixpxd;\r\ndip->di_acl = jfs_ip->acl;\r\ndip->di_ea = jfs_ip->ea;\r\ndip->di_next_index = cpu_to_le32(jfs_ip->next_index);\r\ndip->di_otime.tv_sec = cpu_to_le32(jfs_ip->otime);\r\ndip->di_otime.tv_nsec = 0;\r\ndip->di_acltype = cpu_to_le32(jfs_ip->acltype);\r\nif (S_ISCHR(ip->i_mode) || S_ISBLK(ip->i_mode))\r\ndip->di_rdev = cpu_to_le32(jfs_ip->dev);\r\n}
