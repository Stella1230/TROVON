static inline unsigned int s3c2410wdt_max_timeout(struct clk *clock)\r\n{\r\nunsigned long freq = clk_get_rate(clock);\r\nreturn S3C2410_WTCNT_MAXCNT / (freq / (S3C2410_WTCON_PRESCALE_MAX + 1)\r\n/ S3C2410_WTCON_MAXDIV);\r\n}\r\nstatic inline struct s3c2410_wdt *freq_to_wdt(struct notifier_block *nb)\r\n{\r\nreturn container_of(nb, struct s3c2410_wdt, freq_transition);\r\n}\r\nstatic int s3c2410wdt_mask_and_disable_reset(struct s3c2410_wdt *wdt, bool mask)\r\n{\r\nint ret;\r\nu32 mask_val = 1 << wdt->drv_data->mask_bit;\r\nu32 val = 0;\r\nif (!(wdt->drv_data->quirks & QUIRK_HAS_PMU_CONFIG))\r\nreturn 0;\r\nif (mask)\r\nval = mask_val;\r\nret = regmap_update_bits(wdt->pmureg,\r\nwdt->drv_data->disable_reg,\r\nmask_val, val);\r\nif (ret < 0)\r\ngoto error;\r\nret = regmap_update_bits(wdt->pmureg,\r\nwdt->drv_data->mask_reset_reg,\r\nmask_val, val);\r\nerror:\r\nif (ret < 0)\r\ndev_err(wdt->dev, "failed to update reg(%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic int s3c2410wdt_keepalive(struct watchdog_device *wdd)\r\n{\r\nstruct s3c2410_wdt *wdt = watchdog_get_drvdata(wdd);\r\nspin_lock(&wdt->lock);\r\nwritel(wdt->count, wdt->reg_base + S3C2410_WTCNT);\r\nspin_unlock(&wdt->lock);\r\nreturn 0;\r\n}\r\nstatic void __s3c2410wdt_stop(struct s3c2410_wdt *wdt)\r\n{\r\nunsigned long wtcon;\r\nwtcon = readl(wdt->reg_base + S3C2410_WTCON);\r\nwtcon &= ~(S3C2410_WTCON_ENABLE | S3C2410_WTCON_RSTEN);\r\nwritel(wtcon, wdt->reg_base + S3C2410_WTCON);\r\n}\r\nstatic int s3c2410wdt_stop(struct watchdog_device *wdd)\r\n{\r\nstruct s3c2410_wdt *wdt = watchdog_get_drvdata(wdd);\r\nspin_lock(&wdt->lock);\r\n__s3c2410wdt_stop(wdt);\r\nspin_unlock(&wdt->lock);\r\nreturn 0;\r\n}\r\nstatic int s3c2410wdt_start(struct watchdog_device *wdd)\r\n{\r\nunsigned long wtcon;\r\nstruct s3c2410_wdt *wdt = watchdog_get_drvdata(wdd);\r\nspin_lock(&wdt->lock);\r\n__s3c2410wdt_stop(wdt);\r\nwtcon = readl(wdt->reg_base + S3C2410_WTCON);\r\nwtcon |= S3C2410_WTCON_ENABLE | S3C2410_WTCON_DIV128;\r\nif (soft_noboot) {\r\nwtcon |= S3C2410_WTCON_INTEN;\r\nwtcon &= ~S3C2410_WTCON_RSTEN;\r\n} else {\r\nwtcon &= ~S3C2410_WTCON_INTEN;\r\nwtcon |= S3C2410_WTCON_RSTEN;\r\n}\r\ndev_dbg(wdt->dev, "Starting watchdog: count=0x%08x, wtcon=%08lx\n",\r\nwdt->count, wtcon);\r\nwritel(wdt->count, wdt->reg_base + S3C2410_WTDAT);\r\nwritel(wdt->count, wdt->reg_base + S3C2410_WTCNT);\r\nwritel(wtcon, wdt->reg_base + S3C2410_WTCON);\r\nspin_unlock(&wdt->lock);\r\nreturn 0;\r\n}\r\nstatic inline int s3c2410wdt_is_running(struct s3c2410_wdt *wdt)\r\n{\r\nreturn readl(wdt->reg_base + S3C2410_WTCON) & S3C2410_WTCON_ENABLE;\r\n}\r\nstatic int s3c2410wdt_set_heartbeat(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nstruct s3c2410_wdt *wdt = watchdog_get_drvdata(wdd);\r\nunsigned long freq = clk_get_rate(wdt->clock);\r\nunsigned int count;\r\nunsigned int divisor = 1;\r\nunsigned long wtcon;\r\nif (timeout < 1)\r\nreturn -EINVAL;\r\nfreq = DIV_ROUND_UP(freq, 128);\r\ncount = timeout * freq;\r\ndev_dbg(wdt->dev, "Heartbeat: count=%d, timeout=%d, freq=%lu\n",\r\ncount, timeout, freq);\r\nif (count >= 0x10000) {\r\ndivisor = DIV_ROUND_UP(count, 0xffff);\r\nif (divisor > 0x100) {\r\ndev_err(wdt->dev, "timeout %d too big\n", timeout);\r\nreturn -EINVAL;\r\n}\r\n}\r\ndev_dbg(wdt->dev, "Heartbeat: timeout=%d, divisor=%d, count=%d (%08x)\n",\r\ntimeout, divisor, count, DIV_ROUND_UP(count, divisor));\r\ncount = DIV_ROUND_UP(count, divisor);\r\nwdt->count = count;\r\nwtcon = readl(wdt->reg_base + S3C2410_WTCON);\r\nwtcon &= ~S3C2410_WTCON_PRESCALE_MASK;\r\nwtcon |= S3C2410_WTCON_PRESCALE(divisor-1);\r\nwritel(count, wdt->reg_base + S3C2410_WTDAT);\r\nwritel(wtcon, wdt->reg_base + S3C2410_WTCON);\r\nwdd->timeout = (count * divisor) / freq;\r\nreturn 0;\r\n}\r\nstatic int s3c2410wdt_restart(struct watchdog_device *wdd, unsigned long action,\r\nvoid *data)\r\n{\r\nstruct s3c2410_wdt *wdt = watchdog_get_drvdata(wdd);\r\nvoid __iomem *wdt_base = wdt->reg_base;\r\nwritel(0, wdt_base + S3C2410_WTCON);\r\nwritel(0x80, wdt_base + S3C2410_WTCNT);\r\nwritel(0x80, wdt_base + S3C2410_WTDAT);\r\nwritel(S3C2410_WTCON_ENABLE | S3C2410_WTCON_DIV16 |\r\nS3C2410_WTCON_RSTEN | S3C2410_WTCON_PRESCALE(0x20),\r\nwdt_base + S3C2410_WTCON);\r\nmdelay(500);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t s3c2410wdt_irq(int irqno, void *param)\r\n{\r\nstruct s3c2410_wdt *wdt = platform_get_drvdata(param);\r\ndev_info(wdt->dev, "watchdog timer expired (irq)\n");\r\ns3c2410wdt_keepalive(&wdt->wdt_device);\r\nif (wdt->drv_data->quirks & QUIRK_HAS_WTCLRINT_REG)\r\nwritel(0x1, wdt->reg_base + S3C2410_WTCLRINT);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s3c2410wdt_cpufreq_transition(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nint ret;\r\nstruct s3c2410_wdt *wdt = freq_to_wdt(nb);\r\nif (!s3c2410wdt_is_running(wdt))\r\ngoto done;\r\nif (val == CPUFREQ_PRECHANGE) {\r\ns3c2410wdt_keepalive(&wdt->wdt_device);\r\n} else if (val == CPUFREQ_POSTCHANGE) {\r\ns3c2410wdt_stop(&wdt->wdt_device);\r\nret = s3c2410wdt_set_heartbeat(&wdt->wdt_device,\r\nwdt->wdt_device.timeout);\r\nif (ret >= 0)\r\ns3c2410wdt_start(&wdt->wdt_device);\r\nelse\r\ngoto err;\r\n}\r\ndone:\r\nreturn 0;\r\nerr:\r\ndev_err(wdt->dev, "cannot set new value for timeout %d\n",\r\nwdt->wdt_device.timeout);\r\nreturn ret;\r\n}\r\nstatic inline int s3c2410wdt_cpufreq_register(struct s3c2410_wdt *wdt)\r\n{\r\nwdt->freq_transition.notifier_call = s3c2410wdt_cpufreq_transition;\r\nreturn cpufreq_register_notifier(&wdt->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline void s3c2410wdt_cpufreq_deregister(struct s3c2410_wdt *wdt)\r\n{\r\nwdt->freq_transition.notifier_call = s3c2410wdt_cpufreq_transition;\r\ncpufreq_unregister_notifier(&wdt->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline int s3c2410wdt_cpufreq_register(struct s3c2410_wdt *wdt)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void s3c2410wdt_cpufreq_deregister(struct s3c2410_wdt *wdt)\r\n{\r\n}\r\nstatic inline unsigned int s3c2410wdt_get_bootstatus(struct s3c2410_wdt *wdt)\r\n{\r\nunsigned int rst_stat;\r\nint ret;\r\nif (!(wdt->drv_data->quirks & QUIRK_HAS_RST_STAT))\r\nreturn 0;\r\nret = regmap_read(wdt->pmureg, wdt->drv_data->rst_stat_reg, &rst_stat);\r\nif (ret)\r\ndev_warn(wdt->dev, "Couldn't get RST_STAT register\n");\r\nelse if (rst_stat & BIT(wdt->drv_data->rst_stat_bit))\r\nreturn WDIOF_CARDRESET;\r\nreturn 0;\r\n}\r\nstatic inline const struct s3c2410_wdt_variant *\r\ns3c2410_get_wdt_drv_data(struct platform_device *pdev)\r\n{\r\nconst struct s3c2410_wdt_variant *variant;\r\nvariant = of_device_get_match_data(&pdev->dev);\r\nif (!variant) {\r\nvariant = (struct s3c2410_wdt_variant *)\r\nplatform_get_device_id(pdev)->driver_data;\r\n}\r\nreturn variant;\r\n}\r\nstatic int s3c2410wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct s3c2410_wdt *wdt;\r\nstruct resource *wdt_mem;\r\nstruct resource *wdt_irq;\r\nunsigned int wtcon;\r\nint started = 0;\r\nint ret;\r\nwdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\nwdt->dev = dev;\r\nspin_lock_init(&wdt->lock);\r\nwdt->wdt_device = s3c2410_wdd;\r\nwdt->drv_data = s3c2410_get_wdt_drv_data(pdev);\r\nif (wdt->drv_data->quirks & QUIRKS_HAVE_PMUREG) {\r\nwdt->pmureg = syscon_regmap_lookup_by_phandle(dev->of_node,\r\n"samsung,syscon-phandle");\r\nif (IS_ERR(wdt->pmureg)) {\r\ndev_err(dev, "syscon regmap lookup failed.\n");\r\nreturn PTR_ERR(wdt->pmureg);\r\n}\r\n}\r\nwdt_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (wdt_irq == NULL) {\r\ndev_err(dev, "no irq resource specified\n");\r\nret = -ENOENT;\r\ngoto err;\r\n}\r\nwdt_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nwdt->reg_base = devm_ioremap_resource(dev, wdt_mem);\r\nif (IS_ERR(wdt->reg_base)) {\r\nret = PTR_ERR(wdt->reg_base);\r\ngoto err;\r\n}\r\nwdt->clock = devm_clk_get(dev, "watchdog");\r\nif (IS_ERR(wdt->clock)) {\r\ndev_err(dev, "failed to find watchdog clock source\n");\r\nret = PTR_ERR(wdt->clock);\r\ngoto err;\r\n}\r\nret = clk_prepare_enable(wdt->clock);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to enable clock\n");\r\nreturn ret;\r\n}\r\nwdt->wdt_device.min_timeout = 1;\r\nwdt->wdt_device.max_timeout = s3c2410wdt_max_timeout(wdt->clock);\r\nret = s3c2410wdt_cpufreq_register(wdt);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to register cpufreq\n");\r\ngoto err_clk;\r\n}\r\nwatchdog_set_drvdata(&wdt->wdt_device, wdt);\r\nwatchdog_init_timeout(&wdt->wdt_device, tmr_margin, dev);\r\nret = s3c2410wdt_set_heartbeat(&wdt->wdt_device,\r\nwdt->wdt_device.timeout);\r\nif (ret) {\r\nstarted = s3c2410wdt_set_heartbeat(&wdt->wdt_device,\r\nS3C2410_WATCHDOG_DEFAULT_TIME);\r\nif (started == 0)\r\ndev_info(dev,\r\n"tmr_margin value out of range, default %d used\n",\r\nS3C2410_WATCHDOG_DEFAULT_TIME);\r\nelse\r\ndev_info(dev, "default timer value is out of range, cannot start\n");\r\n}\r\nret = devm_request_irq(dev, wdt_irq->start, s3c2410wdt_irq, 0,\r\npdev->name, pdev);\r\nif (ret != 0) {\r\ndev_err(dev, "failed to install irq (%d)\n", ret);\r\ngoto err_cpufreq;\r\n}\r\nwatchdog_set_nowayout(&wdt->wdt_device, nowayout);\r\nwatchdog_set_restart_priority(&wdt->wdt_device, 128);\r\nwdt->wdt_device.bootstatus = s3c2410wdt_get_bootstatus(wdt);\r\nwdt->wdt_device.parent = dev;\r\nret = watchdog_register_device(&wdt->wdt_device);\r\nif (ret) {\r\ndev_err(dev, "cannot register watchdog (%d)\n", ret);\r\ngoto err_cpufreq;\r\n}\r\nret = s3c2410wdt_mask_and_disable_reset(wdt, false);\r\nif (ret < 0)\r\ngoto err_unregister;\r\nif (tmr_atboot && started == 0) {\r\ndev_info(dev, "starting watchdog timer\n");\r\ns3c2410wdt_start(&wdt->wdt_device);\r\n} else if (!tmr_atboot) {\r\ns3c2410wdt_stop(&wdt->wdt_device);\r\n}\r\nplatform_set_drvdata(pdev, wdt);\r\nwtcon = readl(wdt->reg_base + S3C2410_WTCON);\r\ndev_info(dev, "watchdog %sactive, reset %sabled, irq %sabled\n",\r\n(wtcon & S3C2410_WTCON_ENABLE) ? "" : "in",\r\n(wtcon & S3C2410_WTCON_RSTEN) ? "en" : "dis",\r\n(wtcon & S3C2410_WTCON_INTEN) ? "en" : "dis");\r\nreturn 0;\r\nerr_unregister:\r\nwatchdog_unregister_device(&wdt->wdt_device);\r\nerr_cpufreq:\r\ns3c2410wdt_cpufreq_deregister(wdt);\r\nerr_clk:\r\nclk_disable_unprepare(wdt->clock);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int s3c2410wdt_remove(struct platform_device *dev)\r\n{\r\nint ret;\r\nstruct s3c2410_wdt *wdt = platform_get_drvdata(dev);\r\nret = s3c2410wdt_mask_and_disable_reset(wdt, true);\r\nif (ret < 0)\r\nreturn ret;\r\nwatchdog_unregister_device(&wdt->wdt_device);\r\ns3c2410wdt_cpufreq_deregister(wdt);\r\nclk_disable_unprepare(wdt->clock);\r\nreturn 0;\r\n}\r\nstatic void s3c2410wdt_shutdown(struct platform_device *dev)\r\n{\r\nstruct s3c2410_wdt *wdt = platform_get_drvdata(dev);\r\ns3c2410wdt_mask_and_disable_reset(wdt, true);\r\ns3c2410wdt_stop(&wdt->wdt_device);\r\n}\r\nstatic int s3c2410wdt_suspend(struct device *dev)\r\n{\r\nint ret;\r\nstruct s3c2410_wdt *wdt = dev_get_drvdata(dev);\r\nwdt->wtcon_save = readl(wdt->reg_base + S3C2410_WTCON);\r\nwdt->wtdat_save = readl(wdt->reg_base + S3C2410_WTDAT);\r\nret = s3c2410wdt_mask_and_disable_reset(wdt, true);\r\nif (ret < 0)\r\nreturn ret;\r\ns3c2410wdt_stop(&wdt->wdt_device);\r\nreturn 0;\r\n}\r\nstatic int s3c2410wdt_resume(struct device *dev)\r\n{\r\nint ret;\r\nstruct s3c2410_wdt *wdt = dev_get_drvdata(dev);\r\nwritel(wdt->wtdat_save, wdt->reg_base + S3C2410_WTDAT);\r\nwritel(wdt->wtdat_save, wdt->reg_base + S3C2410_WTCNT);\r\nwritel(wdt->wtcon_save, wdt->reg_base + S3C2410_WTCON);\r\nret = s3c2410wdt_mask_and_disable_reset(wdt, false);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_info(dev, "watchdog %sabled\n",\r\n(wdt->wtcon_save & S3C2410_WTCON_ENABLE) ? "en" : "dis");\r\nreturn 0;\r\n}
