int omap2_clk_deny_idle(struct clk *clk)\r\n{\r\nstruct clk_hw_omap *c;\r\nc = to_clk_hw_omap(__clk_get_hw(clk));\r\nif (c->ops && c->ops->deny_idle)\r\nc->ops->deny_idle(c);\r\nreturn 0;\r\n}\r\nint omap2_clk_allow_idle(struct clk *clk)\r\n{\r\nstruct clk_hw_omap *c;\r\nc = to_clk_hw_omap(__clk_get_hw(clk));\r\nif (c->ops && c->ops->allow_idle)\r\nc->ops->allow_idle(c);\r\nreturn 0;\r\n}\r\nstatic void _allow_autoidle(struct clk_ti_autoidle *clk)\r\n{\r\nu32 val;\r\nval = ti_clk_ll_ops->clk_readl(&clk->reg);\r\nif (clk->flags & AUTOIDLE_LOW)\r\nval &= ~(1 << clk->shift);\r\nelse\r\nval |= (1 << clk->shift);\r\nti_clk_ll_ops->clk_writel(val, &clk->reg);\r\n}\r\nstatic void _deny_autoidle(struct clk_ti_autoidle *clk)\r\n{\r\nu32 val;\r\nval = ti_clk_ll_ops->clk_readl(&clk->reg);\r\nif (clk->flags & AUTOIDLE_LOW)\r\nval |= (1 << clk->shift);\r\nelse\r\nval &= ~(1 << clk->shift);\r\nti_clk_ll_ops->clk_writel(val, &clk->reg);\r\n}\r\nstatic void _clk_generic_allow_autoidle_all(void)\r\n{\r\nstruct clk_ti_autoidle *c;\r\nlist_for_each_entry(c, &autoidle_clks, node)\r\n_allow_autoidle(c);\r\n}\r\nstatic void _clk_generic_deny_autoidle_all(void)\r\n{\r\nstruct clk_ti_autoidle *c;\r\nlist_for_each_entry(c, &autoidle_clks, node)\r\n_deny_autoidle(c);\r\n}\r\nint __init of_ti_clk_autoidle_setup(struct device_node *node)\r\n{\r\nu32 shift;\r\nstruct clk_ti_autoidle *clk;\r\nint ret;\r\nif (of_property_read_u32(node, "ti,autoidle-shift", &shift))\r\nreturn 0;\r\nclk = kzalloc(sizeof(*clk), GFP_KERNEL);\r\nif (!clk)\r\nreturn -ENOMEM;\r\nclk->shift = shift;\r\nclk->name = node->name;\r\nret = ti_clk_get_reg_addr(node, 0, &clk->reg);\r\nif (ret) {\r\nkfree(clk);\r\nreturn ret;\r\n}\r\nif (of_property_read_bool(node, "ti,invert-autoidle-bit"))\r\nclk->flags |= AUTOIDLE_LOW;\r\nlist_add(&clk->node, &autoidle_clks);\r\nreturn 0;\r\n}\r\nvoid omap2_init_clk_hw_omap_clocks(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *c;\r\nif (clk_hw_get_flags(hw) & CLK_IS_BASIC)\r\nreturn;\r\nc = to_clk_hw_omap(hw);\r\nlist_add(&c->node, &clk_hw_omap_clocks);\r\n}\r\nint omap2_clk_enable_autoidle_all(void)\r\n{\r\nstruct clk_hw_omap *c;\r\nlist_for_each_entry(c, &clk_hw_omap_clocks, node)\r\nif (c->ops && c->ops->allow_idle)\r\nc->ops->allow_idle(c);\r\n_clk_generic_allow_autoidle_all();\r\nreturn 0;\r\n}\r\nint omap2_clk_disable_autoidle_all(void)\r\n{\r\nstruct clk_hw_omap *c;\r\nlist_for_each_entry(c, &clk_hw_omap_clocks, node)\r\nif (c->ops && c->ops->deny_idle)\r\nc->ops->deny_idle(c);\r\n_clk_generic_deny_autoidle_all();\r\nreturn 0;\r\n}
