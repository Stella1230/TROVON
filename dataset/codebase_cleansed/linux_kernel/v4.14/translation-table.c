static bool batadv_compare_tt(const struct hlist_node *node, const void *data2)\r\n{\r\nconst void *data1 = container_of(node, struct batadv_tt_common_entry,\r\nhash_entry);\r\nconst struct batadv_tt_common_entry *tt1 = data1;\r\nconst struct batadv_tt_common_entry *tt2 = data2;\r\nreturn (tt1->vid == tt2->vid) && batadv_compare_eth(data1, data2);\r\n}\r\nstatic inline u32 batadv_choose_tt(const void *data, u32 size)\r\n{\r\nstruct batadv_tt_common_entry *tt;\r\nu32 hash = 0;\r\ntt = (struct batadv_tt_common_entry *)data;\r\nhash = jhash(&tt->addr, ETH_ALEN, hash);\r\nhash = jhash(&tt->vid, sizeof(tt->vid), hash);\r\nreturn hash % size;\r\n}\r\nstatic struct batadv_tt_common_entry *\r\nbatadv_tt_hash_find(struct batadv_hashtable *hash, const u8 *addr,\r\nunsigned short vid)\r\n{\r\nstruct hlist_head *head;\r\nstruct batadv_tt_common_entry to_search, *tt, *tt_tmp = NULL;\r\nu32 index;\r\nif (!hash)\r\nreturn NULL;\r\nether_addr_copy(to_search.addr, addr);\r\nto_search.vid = vid;\r\nindex = batadv_choose_tt(&to_search, hash->size);\r\nhead = &hash->table[index];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tt, head, hash_entry) {\r\nif (!batadv_compare_eth(tt, addr))\r\ncontinue;\r\nif (tt->vid != vid)\r\ncontinue;\r\nif (!kref_get_unless_zero(&tt->refcount))\r\ncontinue;\r\ntt_tmp = tt;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn tt_tmp;\r\n}\r\nstatic struct batadv_tt_local_entry *\r\nbatadv_tt_local_hash_find(struct batadv_priv *bat_priv, const u8 *addr,\r\nunsigned short vid)\r\n{\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_tt_local_entry *tt_local_entry = NULL;\r\ntt_common_entry = batadv_tt_hash_find(bat_priv->tt.local_hash, addr,\r\nvid);\r\nif (tt_common_entry)\r\ntt_local_entry = container_of(tt_common_entry,\r\nstruct batadv_tt_local_entry,\r\ncommon);\r\nreturn tt_local_entry;\r\n}\r\nstatic struct batadv_tt_global_entry *\r\nbatadv_tt_global_hash_find(struct batadv_priv *bat_priv, const u8 *addr,\r\nunsigned short vid)\r\n{\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_tt_global_entry *tt_global_entry = NULL;\r\ntt_common_entry = batadv_tt_hash_find(bat_priv->tt.global_hash, addr,\r\nvid);\r\nif (tt_common_entry)\r\ntt_global_entry = container_of(tt_common_entry,\r\nstruct batadv_tt_global_entry,\r\ncommon);\r\nreturn tt_global_entry;\r\n}\r\nstatic void batadv_tt_local_entry_free_rcu(struct rcu_head *rcu)\r\n{\r\nstruct batadv_tt_local_entry *tt_local_entry;\r\ntt_local_entry = container_of(rcu, struct batadv_tt_local_entry,\r\ncommon.rcu);\r\nkmem_cache_free(batadv_tl_cache, tt_local_entry);\r\n}\r\nstatic void batadv_tt_local_entry_release(struct kref *ref)\r\n{\r\nstruct batadv_tt_local_entry *tt_local_entry;\r\ntt_local_entry = container_of(ref, struct batadv_tt_local_entry,\r\ncommon.refcount);\r\nbatadv_softif_vlan_put(tt_local_entry->vlan);\r\ncall_rcu(&tt_local_entry->common.rcu, batadv_tt_local_entry_free_rcu);\r\n}\r\nstatic void\r\nbatadv_tt_local_entry_put(struct batadv_tt_local_entry *tt_local_entry)\r\n{\r\nkref_put(&tt_local_entry->common.refcount,\r\nbatadv_tt_local_entry_release);\r\n}\r\nstatic void batadv_tt_global_entry_free_rcu(struct rcu_head *rcu)\r\n{\r\nstruct batadv_tt_global_entry *tt_global_entry;\r\ntt_global_entry = container_of(rcu, struct batadv_tt_global_entry,\r\ncommon.rcu);\r\nkmem_cache_free(batadv_tg_cache, tt_global_entry);\r\n}\r\nstatic void batadv_tt_global_entry_release(struct kref *ref)\r\n{\r\nstruct batadv_tt_global_entry *tt_global_entry;\r\ntt_global_entry = container_of(ref, struct batadv_tt_global_entry,\r\ncommon.refcount);\r\nbatadv_tt_global_del_orig_list(tt_global_entry);\r\ncall_rcu(&tt_global_entry->common.rcu, batadv_tt_global_entry_free_rcu);\r\n}\r\nstatic void\r\nbatadv_tt_global_entry_put(struct batadv_tt_global_entry *tt_global_entry)\r\n{\r\nkref_put(&tt_global_entry->common.refcount,\r\nbatadv_tt_global_entry_release);\r\n}\r\nint batadv_tt_global_hash_count(struct batadv_priv *bat_priv,\r\nconst u8 *addr, unsigned short vid)\r\n{\r\nstruct batadv_tt_global_entry *tt_global_entry;\r\nint count;\r\ntt_global_entry = batadv_tt_global_hash_find(bat_priv, addr, vid);\r\nif (!tt_global_entry)\r\nreturn 0;\r\ncount = atomic_read(&tt_global_entry->orig_list_count);\r\nbatadv_tt_global_entry_put(tt_global_entry);\r\nreturn count;\r\n}\r\nstatic void batadv_tt_local_size_mod(struct batadv_priv *bat_priv,\r\nunsigned short vid, int v)\r\n{\r\nstruct batadv_softif_vlan *vlan;\r\nvlan = batadv_softif_vlan_get(bat_priv, vid);\r\nif (!vlan)\r\nreturn;\r\natomic_add(v, &vlan->tt.num_entries);\r\nbatadv_softif_vlan_put(vlan);\r\n}\r\nstatic void batadv_tt_local_size_inc(struct batadv_priv *bat_priv,\r\nunsigned short vid)\r\n{\r\nbatadv_tt_local_size_mod(bat_priv, vid, 1);\r\n}\r\nstatic void batadv_tt_local_size_dec(struct batadv_priv *bat_priv,\r\nunsigned short vid)\r\n{\r\nbatadv_tt_local_size_mod(bat_priv, vid, -1);\r\n}\r\nstatic void batadv_tt_global_size_mod(struct batadv_orig_node *orig_node,\r\nunsigned short vid, int v)\r\n{\r\nstruct batadv_orig_node_vlan *vlan;\r\nvlan = batadv_orig_node_vlan_new(orig_node, vid);\r\nif (!vlan)\r\nreturn;\r\nif (atomic_add_return(v, &vlan->tt.num_entries) == 0) {\r\nspin_lock_bh(&orig_node->vlan_list_lock);\r\nif (!hlist_unhashed(&vlan->list)) {\r\nhlist_del_init_rcu(&vlan->list);\r\nbatadv_orig_node_vlan_put(vlan);\r\n}\r\nspin_unlock_bh(&orig_node->vlan_list_lock);\r\n}\r\nbatadv_orig_node_vlan_put(vlan);\r\n}\r\nstatic void batadv_tt_global_size_inc(struct batadv_orig_node *orig_node,\r\nunsigned short vid)\r\n{\r\nbatadv_tt_global_size_mod(orig_node, vid, 1);\r\n}\r\nstatic void batadv_tt_global_size_dec(struct batadv_orig_node *orig_node,\r\nunsigned short vid)\r\n{\r\nbatadv_tt_global_size_mod(orig_node, vid, -1);\r\n}\r\nstatic void batadv_tt_orig_list_entry_free_rcu(struct rcu_head *rcu)\r\n{\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\norig_entry = container_of(rcu, struct batadv_tt_orig_list_entry, rcu);\r\nkmem_cache_free(batadv_tt_orig_cache, orig_entry);\r\n}\r\nstatic void batadv_tt_orig_list_entry_release(struct kref *ref)\r\n{\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\norig_entry = container_of(ref, struct batadv_tt_orig_list_entry,\r\nrefcount);\r\nbatadv_orig_node_put(orig_entry->orig_node);\r\ncall_rcu(&orig_entry->rcu, batadv_tt_orig_list_entry_free_rcu);\r\n}\r\nstatic void\r\nbatadv_tt_orig_list_entry_put(struct batadv_tt_orig_list_entry *orig_entry)\r\n{\r\nkref_put(&orig_entry->refcount, batadv_tt_orig_list_entry_release);\r\n}\r\nstatic void batadv_tt_local_event(struct batadv_priv *bat_priv,\r\nstruct batadv_tt_local_entry *tt_local_entry,\r\nu8 event_flags)\r\n{\r\nstruct batadv_tt_change_node *tt_change_node, *entry, *safe;\r\nstruct batadv_tt_common_entry *common = &tt_local_entry->common;\r\nu8 flags = common->flags | event_flags;\r\nbool event_removed = false;\r\nbool del_op_requested, del_op_entry;\r\ntt_change_node = kmem_cache_alloc(batadv_tt_change_cache, GFP_ATOMIC);\r\nif (!tt_change_node)\r\nreturn;\r\ntt_change_node->change.flags = flags;\r\nmemset(tt_change_node->change.reserved, 0,\r\nsizeof(tt_change_node->change.reserved));\r\nether_addr_copy(tt_change_node->change.addr, common->addr);\r\ntt_change_node->change.vid = htons(common->vid);\r\ndel_op_requested = flags & BATADV_TT_CLIENT_DEL;\r\nspin_lock_bh(&bat_priv->tt.changes_list_lock);\r\nlist_for_each_entry_safe(entry, safe, &bat_priv->tt.changes_list,\r\nlist) {\r\nif (!batadv_compare_eth(entry->change.addr, common->addr))\r\ncontinue;\r\ndel_op_entry = entry->change.flags & BATADV_TT_CLIENT_DEL;\r\nif (!del_op_requested && del_op_entry)\r\ngoto del;\r\nif (del_op_requested && !del_op_entry)\r\ngoto del;\r\nif (!del_op_requested && !del_op_entry)\r\nentry->change.flags = flags;\r\ncontinue;\r\ndel:\r\nlist_del(&entry->list);\r\nkmem_cache_free(batadv_tt_change_cache, entry);\r\nkmem_cache_free(batadv_tt_change_cache, tt_change_node);\r\nevent_removed = true;\r\ngoto unlock;\r\n}\r\nlist_add_tail(&tt_change_node->list, &bat_priv->tt.changes_list);\r\nunlock:\r\nspin_unlock_bh(&bat_priv->tt.changes_list_lock);\r\nif (event_removed)\r\natomic_dec(&bat_priv->tt.local_changes);\r\nelse\r\natomic_inc(&bat_priv->tt.local_changes);\r\n}\r\nstatic int batadv_tt_len(int changes_num)\r\n{\r\nreturn changes_num * sizeof(struct batadv_tvlv_tt_change);\r\n}\r\nstatic u16 batadv_tt_entries(u16 tt_len)\r\n{\r\nreturn tt_len / batadv_tt_len(1);\r\n}\r\nstatic int batadv_tt_local_table_transmit_size(struct batadv_priv *bat_priv)\r\n{\r\nu16 num_vlan = 0;\r\nu16 tt_local_entries = 0;\r\nstruct batadv_softif_vlan *vlan;\r\nint hdr_size;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(vlan, &bat_priv->softif_vlan_list, list) {\r\nnum_vlan++;\r\ntt_local_entries += atomic_read(&vlan->tt.num_entries);\r\n}\r\nrcu_read_unlock();\r\nhdr_size = sizeof(struct batadv_unicast_tvlv_packet);\r\nhdr_size += sizeof(struct batadv_tvlv_hdr);\r\nhdr_size += sizeof(struct batadv_tvlv_tt_data);\r\nhdr_size += num_vlan * sizeof(struct batadv_tvlv_tt_vlan_data);\r\nreturn hdr_size + batadv_tt_len(tt_local_entries);\r\n}\r\nstatic int batadv_tt_local_init(struct batadv_priv *bat_priv)\r\n{\r\nif (bat_priv->tt.local_hash)\r\nreturn 0;\r\nbat_priv->tt.local_hash = batadv_hash_new(1024);\r\nif (!bat_priv->tt.local_hash)\r\nreturn -ENOMEM;\r\nbatadv_hash_set_lock_class(bat_priv->tt.local_hash,\r\n&batadv_tt_local_hash_lock_class_key);\r\nreturn 0;\r\n}\r\nstatic void batadv_tt_global_free(struct batadv_priv *bat_priv,\r\nstruct batadv_tt_global_entry *tt_global,\r\nconst char *message)\r\n{\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Deleting global tt entry %pM (vid: %d): %s\n",\r\ntt_global->common.addr,\r\nbatadv_print_vid(tt_global->common.vid), message);\r\nbatadv_hash_remove(bat_priv->tt.global_hash, batadv_compare_tt,\r\nbatadv_choose_tt, &tt_global->common);\r\nbatadv_tt_global_entry_put(tt_global);\r\n}\r\nbool batadv_tt_local_add(struct net_device *soft_iface, const u8 *addr,\r\nunsigned short vid, int ifindex, u32 mark)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\r\nstruct batadv_tt_local_entry *tt_local;\r\nstruct batadv_tt_global_entry *tt_global = NULL;\r\nstruct net *net = dev_net(soft_iface);\r\nstruct batadv_softif_vlan *vlan;\r\nstruct net_device *in_dev = NULL;\r\nstruct batadv_hard_iface *in_hardif = NULL;\r\nstruct hlist_head *head;\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\nint hash_added, table_size, packet_size_max;\r\nbool ret = false;\r\nbool roamed_back = false;\r\nu8 remote_flags;\r\nu32 match_mark;\r\nif (ifindex != BATADV_NULL_IFINDEX)\r\nin_dev = dev_get_by_index(net, ifindex);\r\nif (in_dev)\r\nin_hardif = batadv_hardif_get_by_netdev(in_dev);\r\ntt_local = batadv_tt_local_hash_find(bat_priv, addr, vid);\r\nif (!is_multicast_ether_addr(addr))\r\ntt_global = batadv_tt_global_hash_find(bat_priv, addr, vid);\r\nif (tt_local) {\r\ntt_local->last_seen = jiffies;\r\nif (tt_local->common.flags & BATADV_TT_CLIENT_PENDING) {\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Re-adding pending client %pM (vid: %d)\n",\r\naddr, batadv_print_vid(vid));\r\ntt_local->common.flags &= ~BATADV_TT_CLIENT_PENDING;\r\ngoto add_event;\r\n}\r\nif (tt_local->common.flags & BATADV_TT_CLIENT_ROAM) {\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Roaming client %pM (vid: %d) came back to its original location\n",\r\naddr, batadv_print_vid(vid));\r\ntt_local->common.flags &= ~BATADV_TT_CLIENT_ROAM;\r\nroamed_back = true;\r\n}\r\ngoto check_roaming;\r\n}\r\ntable_size = batadv_tt_local_table_transmit_size(bat_priv);\r\ntable_size += batadv_tt_len(1);\r\npacket_size_max = atomic_read(&bat_priv->packet_size_max);\r\nif (table_size > packet_size_max) {\r\nnet_ratelimited_function(batadv_info, soft_iface,\r\n"Local translation table size (%i) exceeds maximum packet size (%i); Ignoring new local tt entry: %pM\n",\r\ntable_size, packet_size_max, addr);\r\ngoto out;\r\n}\r\ntt_local = kmem_cache_alloc(batadv_tl_cache, GFP_ATOMIC);\r\nif (!tt_local)\r\ngoto out;\r\nvlan = batadv_softif_vlan_get(bat_priv, vid);\r\nif (!vlan) {\r\nnet_ratelimited_function(batadv_info, soft_iface,\r\n"adding TT local entry %pM to non-existent VLAN %d\n",\r\naddr, batadv_print_vid(vid));\r\nkmem_cache_free(batadv_tl_cache, tt_local);\r\ntt_local = NULL;\r\ngoto out;\r\n}\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Creating new local tt entry: %pM (vid: %d, ttvn: %d)\n",\r\naddr, batadv_print_vid(vid),\r\n(u8)atomic_read(&bat_priv->tt.vn));\r\nether_addr_copy(tt_local->common.addr, addr);\r\ntt_local->common.flags = BATADV_TT_CLIENT_NEW;\r\ntt_local->common.vid = vid;\r\nif (batadv_is_wifi_hardif(in_hardif))\r\ntt_local->common.flags |= BATADV_TT_CLIENT_WIFI;\r\nkref_init(&tt_local->common.refcount);\r\ntt_local->last_seen = jiffies;\r\ntt_local->common.added_at = tt_local->last_seen;\r\ntt_local->vlan = vlan;\r\nif (batadv_compare_eth(addr, soft_iface->dev_addr) ||\r\nis_multicast_ether_addr(addr))\r\ntt_local->common.flags |= BATADV_TT_CLIENT_NOPURGE;\r\nkref_get(&tt_local->common.refcount);\r\nhash_added = batadv_hash_add(bat_priv->tt.local_hash, batadv_compare_tt,\r\nbatadv_choose_tt, &tt_local->common,\r\n&tt_local->common.hash_entry);\r\nif (unlikely(hash_added != 0)) {\r\nbatadv_tt_local_entry_put(tt_local);\r\ngoto out;\r\n}\r\nadd_event:\r\nbatadv_tt_local_event(bat_priv, tt_local, BATADV_NO_FLAGS);\r\ncheck_roaming:\r\nif (tt_global && !(tt_global->common.flags & BATADV_TT_CLIENT_ROAM)) {\r\nhead = &tt_global->orig_list;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(orig_entry, head, list) {\r\nbatadv_send_roam_adv(bat_priv, tt_global->common.addr,\r\ntt_global->common.vid,\r\norig_entry->orig_node);\r\n}\r\nrcu_read_unlock();\r\nif (roamed_back) {\r\nbatadv_tt_global_free(bat_priv, tt_global,\r\n"Roaming canceled");\r\ntt_global = NULL;\r\n} else {\r\ntt_global->common.flags |= BATADV_TT_CLIENT_ROAM;\r\ntt_global->roam_at = jiffies;\r\n}\r\n}\r\nremote_flags = tt_local->common.flags & BATADV_TT_REMOTE_MASK;\r\nif (batadv_is_wifi_hardif(in_hardif))\r\ntt_local->common.flags |= BATADV_TT_CLIENT_WIFI;\r\nelse\r\ntt_local->common.flags &= ~BATADV_TT_CLIENT_WIFI;\r\nmatch_mark = (mark & bat_priv->isolation_mark_mask);\r\nif (bat_priv->isolation_mark_mask &&\r\nmatch_mark == bat_priv->isolation_mark)\r\ntt_local->common.flags |= BATADV_TT_CLIENT_ISOLA;\r\nelse\r\ntt_local->common.flags &= ~BATADV_TT_CLIENT_ISOLA;\r\nif (remote_flags ^ (tt_local->common.flags & BATADV_TT_REMOTE_MASK))\r\nbatadv_tt_local_event(bat_priv, tt_local, BATADV_NO_FLAGS);\r\nret = true;\r\nout:\r\nif (in_hardif)\r\nbatadv_hardif_put(in_hardif);\r\nif (in_dev)\r\ndev_put(in_dev);\r\nif (tt_local)\r\nbatadv_tt_local_entry_put(tt_local);\r\nif (tt_global)\r\nbatadv_tt_global_entry_put(tt_global);\r\nreturn ret;\r\n}\r\nstatic u16\r\nbatadv_tt_prepare_tvlv_global_data(struct batadv_orig_node *orig_node,\r\nstruct batadv_tvlv_tt_data **tt_data,\r\nstruct batadv_tvlv_tt_change **tt_change,\r\ns32 *tt_len)\r\n{\r\nu16 num_vlan = 0;\r\nu16 num_entries = 0;\r\nu16 change_offset;\r\nu16 tvlv_len;\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan;\r\nstruct batadv_orig_node_vlan *vlan;\r\nu8 *tt_change_ptr;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(vlan, &orig_node->vlan_list, list) {\r\nnum_vlan++;\r\nnum_entries += atomic_read(&vlan->tt.num_entries);\r\n}\r\nchange_offset = sizeof(**tt_data);\r\nchange_offset += num_vlan * sizeof(*tt_vlan);\r\nif (*tt_len < 0)\r\n*tt_len = batadv_tt_len(num_entries);\r\ntvlv_len = *tt_len;\r\ntvlv_len += change_offset;\r\n*tt_data = kmalloc(tvlv_len, GFP_ATOMIC);\r\nif (!*tt_data) {\r\n*tt_len = 0;\r\ngoto out;\r\n}\r\n(*tt_data)->flags = BATADV_NO_FLAGS;\r\n(*tt_data)->ttvn = atomic_read(&orig_node->last_ttvn);\r\n(*tt_data)->num_vlan = htons(num_vlan);\r\ntt_vlan = (struct batadv_tvlv_tt_vlan_data *)(*tt_data + 1);\r\nhlist_for_each_entry_rcu(vlan, &orig_node->vlan_list, list) {\r\ntt_vlan->vid = htons(vlan->vid);\r\ntt_vlan->crc = htonl(vlan->tt.crc);\r\ntt_vlan++;\r\n}\r\ntt_change_ptr = (u8 *)*tt_data + change_offset;\r\n*tt_change = (struct batadv_tvlv_tt_change *)tt_change_ptr;\r\nout:\r\nrcu_read_unlock();\r\nreturn tvlv_len;\r\n}\r\nstatic u16\r\nbatadv_tt_prepare_tvlv_local_data(struct batadv_priv *bat_priv,\r\nstruct batadv_tvlv_tt_data **tt_data,\r\nstruct batadv_tvlv_tt_change **tt_change,\r\ns32 *tt_len)\r\n{\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan;\r\nstruct batadv_softif_vlan *vlan;\r\nu16 num_vlan = 0;\r\nu16 num_entries = 0;\r\nu16 tvlv_len;\r\nu8 *tt_change_ptr;\r\nint change_offset;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(vlan, &bat_priv->softif_vlan_list, list) {\r\nnum_vlan++;\r\nnum_entries += atomic_read(&vlan->tt.num_entries);\r\n}\r\nchange_offset = sizeof(**tt_data);\r\nchange_offset += num_vlan * sizeof(*tt_vlan);\r\nif (*tt_len < 0)\r\n*tt_len = batadv_tt_len(num_entries);\r\ntvlv_len = *tt_len;\r\ntvlv_len += change_offset;\r\n*tt_data = kmalloc(tvlv_len, GFP_ATOMIC);\r\nif (!*tt_data) {\r\ntvlv_len = 0;\r\ngoto out;\r\n}\r\n(*tt_data)->flags = BATADV_NO_FLAGS;\r\n(*tt_data)->ttvn = atomic_read(&bat_priv->tt.vn);\r\n(*tt_data)->num_vlan = htons(num_vlan);\r\ntt_vlan = (struct batadv_tvlv_tt_vlan_data *)(*tt_data + 1);\r\nhlist_for_each_entry_rcu(vlan, &bat_priv->softif_vlan_list, list) {\r\ntt_vlan->vid = htons(vlan->vid);\r\ntt_vlan->crc = htonl(vlan->tt.crc);\r\ntt_vlan++;\r\n}\r\ntt_change_ptr = (u8 *)*tt_data + change_offset;\r\n*tt_change = (struct batadv_tvlv_tt_change *)tt_change_ptr;\r\nout:\r\nrcu_read_unlock();\r\nreturn tvlv_len;\r\n}\r\nstatic void batadv_tt_tvlv_container_update(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_tt_change_node *entry, *safe;\r\nstruct batadv_tvlv_tt_data *tt_data;\r\nstruct batadv_tvlv_tt_change *tt_change;\r\nint tt_diff_len, tt_change_len = 0;\r\nint tt_diff_entries_num = 0;\r\nint tt_diff_entries_count = 0;\r\nu16 tvlv_len;\r\ntt_diff_entries_num = atomic_read(&bat_priv->tt.local_changes);\r\ntt_diff_len = batadv_tt_len(tt_diff_entries_num);\r\nif (tt_diff_len > bat_priv->soft_iface->mtu)\r\ntt_diff_len = 0;\r\ntvlv_len = batadv_tt_prepare_tvlv_local_data(bat_priv, &tt_data,\r\n&tt_change, &tt_diff_len);\r\nif (!tvlv_len)\r\nreturn;\r\ntt_data->flags = BATADV_TT_OGM_DIFF;\r\nif (tt_diff_len == 0)\r\ngoto container_register;\r\nspin_lock_bh(&bat_priv->tt.changes_list_lock);\r\natomic_set(&bat_priv->tt.local_changes, 0);\r\nlist_for_each_entry_safe(entry, safe, &bat_priv->tt.changes_list,\r\nlist) {\r\nif (tt_diff_entries_count < tt_diff_entries_num) {\r\nmemcpy(tt_change + tt_diff_entries_count,\r\n&entry->change,\r\nsizeof(struct batadv_tvlv_tt_change));\r\ntt_diff_entries_count++;\r\n}\r\nlist_del(&entry->list);\r\nkmem_cache_free(batadv_tt_change_cache, entry);\r\n}\r\nspin_unlock_bh(&bat_priv->tt.changes_list_lock);\r\nspin_lock_bh(&bat_priv->tt.last_changeset_lock);\r\nkfree(bat_priv->tt.last_changeset);\r\nbat_priv->tt.last_changeset_len = 0;\r\nbat_priv->tt.last_changeset = NULL;\r\ntt_change_len = batadv_tt_len(tt_diff_entries_count);\r\nif (tt_diff_entries_count > 0) {\r\nbat_priv->tt.last_changeset = kzalloc(tt_diff_len, GFP_ATOMIC);\r\nif (bat_priv->tt.last_changeset) {\r\nmemcpy(bat_priv->tt.last_changeset,\r\ntt_change, tt_change_len);\r\nbat_priv->tt.last_changeset_len = tt_diff_len;\r\n}\r\n}\r\nspin_unlock_bh(&bat_priv->tt.last_changeset_lock);\r\ncontainer_register:\r\nbatadv_tvlv_container_register(bat_priv, BATADV_TVLV_TT, 1, tt_data,\r\ntvlv_len);\r\nkfree(tt_data);\r\n}\r\nint batadv_tt_local_seq_print_text(struct seq_file *seq, void *offset)\r\n{\r\nstruct net_device *net_dev = (struct net_device *)seq->private;\r\nstruct batadv_priv *bat_priv = netdev_priv(net_dev);\r\nstruct batadv_hashtable *hash = bat_priv->tt.local_hash;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_tt_local_entry *tt_local;\r\nstruct batadv_hard_iface *primary_if;\r\nstruct hlist_head *head;\r\nu32 i;\r\nint last_seen_secs;\r\nint last_seen_msecs;\r\nunsigned long last_seen_jiffies;\r\nbool no_purge;\r\nu16 np_flag = BATADV_TT_CLIENT_NOPURGE;\r\nprimary_if = batadv_seq_print_text_primary_if_get(seq);\r\nif (!primary_if)\r\ngoto out;\r\nseq_printf(seq,\r\n"Locally retrieved addresses (from %s) announced via TT (TTVN: %u):\n",\r\nnet_dev->name, (u8)atomic_read(&bat_priv->tt.vn));\r\nseq_puts(seq,\r\n" Client VID Flags Last seen (CRC )\n");\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tt_common_entry,\r\nhead, hash_entry) {\r\ntt_local = container_of(tt_common_entry,\r\nstruct batadv_tt_local_entry,\r\ncommon);\r\nlast_seen_jiffies = jiffies - tt_local->last_seen;\r\nlast_seen_msecs = jiffies_to_msecs(last_seen_jiffies);\r\nlast_seen_secs = last_seen_msecs / 1000;\r\nlast_seen_msecs = last_seen_msecs % 1000;\r\nno_purge = tt_common_entry->flags & np_flag;\r\nseq_printf(seq,\r\n" * %pM %4i [%c%c%c%c%c%c] %3u.%03u (%#.8x)\n",\r\ntt_common_entry->addr,\r\nbatadv_print_vid(tt_common_entry->vid),\r\n((tt_common_entry->flags &\r\nBATADV_TT_CLIENT_ROAM) ? 'R' : '.'),\r\nno_purge ? 'P' : '.',\r\n((tt_common_entry->flags &\r\nBATADV_TT_CLIENT_NEW) ? 'N' : '.'),\r\n((tt_common_entry->flags &\r\nBATADV_TT_CLIENT_PENDING) ? 'X' : '.'),\r\n((tt_common_entry->flags &\r\nBATADV_TT_CLIENT_WIFI) ? 'W' : '.'),\r\n((tt_common_entry->flags &\r\nBATADV_TT_CLIENT_ISOLA) ? 'I' : '.'),\r\nno_purge ? 0 : last_seen_secs,\r\nno_purge ? 0 : last_seen_msecs,\r\ntt_local->vlan->tt.crc);\r\n}\r\nrcu_read_unlock();\r\n}\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\nreturn 0;\r\n}\r\nstatic int\r\nbatadv_tt_local_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,\r\nstruct batadv_priv *bat_priv,\r\nstruct batadv_tt_common_entry *common)\r\n{\r\nvoid *hdr;\r\nstruct batadv_softif_vlan *vlan;\r\nstruct batadv_tt_local_entry *local;\r\nunsigned int last_seen_msecs;\r\nu32 crc;\r\nlocal = container_of(common, struct batadv_tt_local_entry, common);\r\nlast_seen_msecs = jiffies_to_msecs(jiffies - local->last_seen);\r\nvlan = batadv_softif_vlan_get(bat_priv, common->vid);\r\nif (!vlan)\r\nreturn 0;\r\ncrc = vlan->tt.crc;\r\nbatadv_softif_vlan_put(vlan);\r\nhdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family,\r\nNLM_F_MULTI,\r\nBATADV_CMD_GET_TRANSTABLE_LOCAL);\r\nif (!hdr)\r\nreturn -ENOBUFS;\r\nif (nla_put(msg, BATADV_ATTR_TT_ADDRESS, ETH_ALEN, common->addr) ||\r\nnla_put_u32(msg, BATADV_ATTR_TT_CRC32, crc) ||\r\nnla_put_u16(msg, BATADV_ATTR_TT_VID, common->vid) ||\r\nnla_put_u32(msg, BATADV_ATTR_TT_FLAGS, common->flags))\r\ngoto nla_put_failure;\r\nif (!(common->flags & BATADV_TT_CLIENT_NOPURGE) &&\r\nnla_put_u32(msg, BATADV_ATTR_LAST_SEEN_MSECS, last_seen_msecs))\r\ngoto nla_put_failure;\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nbatadv_tt_local_dump_bucket(struct sk_buff *msg, u32 portid, u32 seq,\r\nstruct batadv_priv *bat_priv,\r\nstruct hlist_head *head, int *idx_s)\r\n{\r\nstruct batadv_tt_common_entry *common;\r\nint idx = 0;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(common, head, hash_entry) {\r\nif (idx++ < *idx_s)\r\ncontinue;\r\nif (batadv_tt_local_dump_entry(msg, portid, seq, bat_priv,\r\ncommon)) {\r\nrcu_read_unlock();\r\n*idx_s = idx - 1;\r\nreturn -EMSGSIZE;\r\n}\r\n}\r\nrcu_read_unlock();\r\n*idx_s = 0;\r\nreturn 0;\r\n}\r\nint batadv_tt_local_dump(struct sk_buff *msg, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(cb->skb->sk);\r\nstruct net_device *soft_iface;\r\nstruct batadv_priv *bat_priv;\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nstruct batadv_hashtable *hash;\r\nstruct hlist_head *head;\r\nint ret;\r\nint ifindex;\r\nint bucket = cb->args[0];\r\nint idx = cb->args[1];\r\nint portid = NETLINK_CB(cb->skb).portid;\r\nifindex = batadv_netlink_get_ifindex(cb->nlh, BATADV_ATTR_MESH_IFINDEX);\r\nif (!ifindex)\r\nreturn -EINVAL;\r\nsoft_iface = dev_get_by_index(net, ifindex);\r\nif (!soft_iface || !batadv_softif_is_valid(soft_iface)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nbat_priv = netdev_priv(soft_iface);\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nhash = bat_priv->tt.local_hash;\r\nwhile (bucket < hash->size) {\r\nhead = &hash->table[bucket];\r\nif (batadv_tt_local_dump_bucket(msg, portid, cb->nlh->nlmsg_seq,\r\nbat_priv, head, &idx))\r\nbreak;\r\nbucket++;\r\n}\r\nret = msg->len;\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\nif (soft_iface)\r\ndev_put(soft_iface);\r\ncb->args[0] = bucket;\r\ncb->args[1] = idx;\r\nreturn ret;\r\n}\r\nstatic void\r\nbatadv_tt_local_set_pending(struct batadv_priv *bat_priv,\r\nstruct batadv_tt_local_entry *tt_local_entry,\r\nu16 flags, const char *message)\r\n{\r\nbatadv_tt_local_event(bat_priv, tt_local_entry, flags);\r\ntt_local_entry->common.flags |= BATADV_TT_CLIENT_PENDING;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Local tt entry (%pM, vid: %d) pending to be removed: %s\n",\r\ntt_local_entry->common.addr,\r\nbatadv_print_vid(tt_local_entry->common.vid), message);\r\n}\r\nu16 batadv_tt_local_remove(struct batadv_priv *bat_priv, const u8 *addr,\r\nunsigned short vid, const char *message,\r\nbool roaming)\r\n{\r\nstruct batadv_tt_local_entry *tt_local_entry;\r\nu16 flags, curr_flags = BATADV_NO_FLAGS;\r\nvoid *tt_entry_exists;\r\ntt_local_entry = batadv_tt_local_hash_find(bat_priv, addr, vid);\r\nif (!tt_local_entry)\r\ngoto out;\r\ncurr_flags = tt_local_entry->common.flags;\r\nflags = BATADV_TT_CLIENT_DEL;\r\nif (roaming) {\r\nflags |= BATADV_TT_CLIENT_ROAM;\r\ntt_local_entry->common.flags |= BATADV_TT_CLIENT_ROAM;\r\n}\r\nif (!(tt_local_entry->common.flags & BATADV_TT_CLIENT_NEW)) {\r\nbatadv_tt_local_set_pending(bat_priv, tt_local_entry, flags,\r\nmessage);\r\ngoto out;\r\n}\r\nbatadv_tt_local_event(bat_priv, tt_local_entry, BATADV_TT_CLIENT_DEL);\r\ntt_entry_exists = batadv_hash_remove(bat_priv->tt.local_hash,\r\nbatadv_compare_tt,\r\nbatadv_choose_tt,\r\n&tt_local_entry->common);\r\nif (!tt_entry_exists)\r\ngoto out;\r\nbatadv_tt_local_entry_put(tt_local_entry);\r\nout:\r\nif (tt_local_entry)\r\nbatadv_tt_local_entry_put(tt_local_entry);\r\nreturn curr_flags;\r\n}\r\nstatic void batadv_tt_local_purge_list(struct batadv_priv *bat_priv,\r\nstruct hlist_head *head,\r\nint timeout)\r\n{\r\nstruct batadv_tt_local_entry *tt_local_entry;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct hlist_node *node_tmp;\r\nhlist_for_each_entry_safe(tt_common_entry, node_tmp, head,\r\nhash_entry) {\r\ntt_local_entry = container_of(tt_common_entry,\r\nstruct batadv_tt_local_entry,\r\ncommon);\r\nif (tt_local_entry->common.flags & BATADV_TT_CLIENT_NOPURGE)\r\ncontinue;\r\nif (tt_local_entry->common.flags & BATADV_TT_CLIENT_PENDING)\r\ncontinue;\r\nif (!batadv_has_timed_out(tt_local_entry->last_seen, timeout))\r\ncontinue;\r\nbatadv_tt_local_set_pending(bat_priv, tt_local_entry,\r\nBATADV_TT_CLIENT_DEL, "timed out");\r\n}\r\n}\r\nstatic void batadv_tt_local_purge(struct batadv_priv *bat_priv,\r\nint timeout)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->tt.local_hash;\r\nstruct hlist_head *head;\r\nspinlock_t *list_lock;\r\nu32 i;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nbatadv_tt_local_purge_list(bat_priv, head, timeout);\r\nspin_unlock_bh(list_lock);\r\n}\r\n}\r\nstatic void batadv_tt_local_table_free(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_hashtable *hash;\r\nspinlock_t *list_lock;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_tt_local_entry *tt_local;\r\nstruct hlist_node *node_tmp;\r\nstruct hlist_head *head;\r\nu32 i;\r\nif (!bat_priv->tt.local_hash)\r\nreturn;\r\nhash = bat_priv->tt.local_hash;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nhlist_for_each_entry_safe(tt_common_entry, node_tmp,\r\nhead, hash_entry) {\r\nhlist_del_rcu(&tt_common_entry->hash_entry);\r\ntt_local = container_of(tt_common_entry,\r\nstruct batadv_tt_local_entry,\r\ncommon);\r\nbatadv_tt_local_entry_put(tt_local);\r\n}\r\nspin_unlock_bh(list_lock);\r\n}\r\nbatadv_hash_destroy(hash);\r\nbat_priv->tt.local_hash = NULL;\r\n}\r\nstatic int batadv_tt_global_init(struct batadv_priv *bat_priv)\r\n{\r\nif (bat_priv->tt.global_hash)\r\nreturn 0;\r\nbat_priv->tt.global_hash = batadv_hash_new(1024);\r\nif (!bat_priv->tt.global_hash)\r\nreturn -ENOMEM;\r\nbatadv_hash_set_lock_class(bat_priv->tt.global_hash,\r\n&batadv_tt_global_hash_lock_class_key);\r\nreturn 0;\r\n}\r\nstatic void batadv_tt_changes_list_free(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_tt_change_node *entry, *safe;\r\nspin_lock_bh(&bat_priv->tt.changes_list_lock);\r\nlist_for_each_entry_safe(entry, safe, &bat_priv->tt.changes_list,\r\nlist) {\r\nlist_del(&entry->list);\r\nkmem_cache_free(batadv_tt_change_cache, entry);\r\n}\r\natomic_set(&bat_priv->tt.local_changes, 0);\r\nspin_unlock_bh(&bat_priv->tt.changes_list_lock);\r\n}\r\nstatic struct batadv_tt_orig_list_entry *\r\nbatadv_tt_global_orig_entry_find(const struct batadv_tt_global_entry *entry,\r\nconst struct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_tt_orig_list_entry *tmp_orig_entry, *orig_entry = NULL;\r\nconst struct hlist_head *head;\r\nrcu_read_lock();\r\nhead = &entry->orig_list;\r\nhlist_for_each_entry_rcu(tmp_orig_entry, head, list) {\r\nif (tmp_orig_entry->orig_node != orig_node)\r\ncontinue;\r\nif (!kref_get_unless_zero(&tmp_orig_entry->refcount))\r\ncontinue;\r\norig_entry = tmp_orig_entry;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn orig_entry;\r\n}\r\nstatic bool\r\nbatadv_tt_global_entry_has_orig(const struct batadv_tt_global_entry *entry,\r\nconst struct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\nbool found = false;\r\norig_entry = batadv_tt_global_orig_entry_find(entry, orig_node);\r\nif (orig_entry) {\r\nfound = true;\r\nbatadv_tt_orig_list_entry_put(orig_entry);\r\n}\r\nreturn found;\r\n}\r\nstatic void\r\nbatadv_tt_global_sync_flags(struct batadv_tt_global_entry *tt_global)\r\n{\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\nconst struct hlist_head *head;\r\nu16 flags = BATADV_NO_FLAGS;\r\nrcu_read_lock();\r\nhead = &tt_global->orig_list;\r\nhlist_for_each_entry_rcu(orig_entry, head, list)\r\nflags |= orig_entry->flags;\r\nrcu_read_unlock();\r\nflags |= tt_global->common.flags & (~BATADV_TT_SYNC_MASK);\r\ntt_global->common.flags = flags;\r\n}\r\nstatic void\r\nbatadv_tt_global_orig_entry_add(struct batadv_tt_global_entry *tt_global,\r\nstruct batadv_orig_node *orig_node, int ttvn,\r\nu8 flags)\r\n{\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\norig_entry = batadv_tt_global_orig_entry_find(tt_global, orig_node);\r\nif (orig_entry) {\r\norig_entry->ttvn = ttvn;\r\norig_entry->flags = flags;\r\ngoto sync_flags;\r\n}\r\norig_entry = kmem_cache_zalloc(batadv_tt_orig_cache, GFP_ATOMIC);\r\nif (!orig_entry)\r\ngoto out;\r\nINIT_HLIST_NODE(&orig_entry->list);\r\nkref_get(&orig_node->refcount);\r\nbatadv_tt_global_size_inc(orig_node, tt_global->common.vid);\r\norig_entry->orig_node = orig_node;\r\norig_entry->ttvn = ttvn;\r\norig_entry->flags = flags;\r\nkref_init(&orig_entry->refcount);\r\nspin_lock_bh(&tt_global->list_lock);\r\nkref_get(&orig_entry->refcount);\r\nhlist_add_head_rcu(&orig_entry->list,\r\n&tt_global->orig_list);\r\nspin_unlock_bh(&tt_global->list_lock);\r\natomic_inc(&tt_global->orig_list_count);\r\nsync_flags:\r\nbatadv_tt_global_sync_flags(tt_global);\r\nout:\r\nif (orig_entry)\r\nbatadv_tt_orig_list_entry_put(orig_entry);\r\n}\r\nstatic bool batadv_tt_global_add(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nconst unsigned char *tt_addr,\r\nunsigned short vid, u16 flags, u8 ttvn)\r\n{\r\nstruct batadv_tt_global_entry *tt_global_entry;\r\nstruct batadv_tt_local_entry *tt_local_entry;\r\nbool ret = false;\r\nint hash_added;\r\nstruct batadv_tt_common_entry *common;\r\nu16 local_flags;\r\nif (batadv_bla_is_backbone_gw_orig(bat_priv, orig_node->orig, vid))\r\nreturn true;\r\ntt_global_entry = batadv_tt_global_hash_find(bat_priv, tt_addr, vid);\r\ntt_local_entry = batadv_tt_local_hash_find(bat_priv, tt_addr, vid);\r\nif ((flags & BATADV_TT_CLIENT_TEMP) && tt_local_entry &&\r\n!(tt_local_entry->common.flags & BATADV_TT_CLIENT_NEW))\r\ngoto out;\r\nif (!tt_global_entry) {\r\ntt_global_entry = kmem_cache_zalloc(batadv_tg_cache,\r\nGFP_ATOMIC);\r\nif (!tt_global_entry)\r\ngoto out;\r\ncommon = &tt_global_entry->common;\r\nether_addr_copy(common->addr, tt_addr);\r\ncommon->vid = vid;\r\ncommon->flags = flags;\r\ntt_global_entry->roam_at = 0;\r\nif (flags & BATADV_TT_CLIENT_ROAM)\r\ntt_global_entry->roam_at = jiffies;\r\nkref_init(&common->refcount);\r\ncommon->added_at = jiffies;\r\nINIT_HLIST_HEAD(&tt_global_entry->orig_list);\r\natomic_set(&tt_global_entry->orig_list_count, 0);\r\nspin_lock_init(&tt_global_entry->list_lock);\r\nkref_get(&common->refcount);\r\nhash_added = batadv_hash_add(bat_priv->tt.global_hash,\r\nbatadv_compare_tt,\r\nbatadv_choose_tt, common,\r\n&common->hash_entry);\r\nif (unlikely(hash_added != 0)) {\r\nbatadv_tt_global_entry_put(tt_global_entry);\r\ngoto out_remove;\r\n}\r\n} else {\r\ncommon = &tt_global_entry->common;\r\nif (flags & BATADV_TT_CLIENT_TEMP) {\r\nif (!(common->flags & BATADV_TT_CLIENT_TEMP))\r\ngoto out;\r\nif (batadv_tt_global_entry_has_orig(tt_global_entry,\r\norig_node))\r\ngoto out_remove;\r\nbatadv_tt_global_del_orig_list(tt_global_entry);\r\ngoto add_orig_entry;\r\n}\r\nif (common->flags & BATADV_TT_CLIENT_TEMP) {\r\nbatadv_tt_global_del_orig_list(tt_global_entry);\r\ncommon->flags &= ~BATADV_TT_CLIENT_TEMP;\r\n}\r\ncommon->flags |= flags & (~BATADV_TT_SYNC_MASK);\r\nif (common->flags & BATADV_TT_CLIENT_ROAM) {\r\nbatadv_tt_global_del_orig_list(tt_global_entry);\r\ncommon->flags &= ~BATADV_TT_CLIENT_ROAM;\r\ntt_global_entry->roam_at = 0;\r\n}\r\n}\r\nadd_orig_entry:\r\nbatadv_tt_global_orig_entry_add(tt_global_entry, orig_node, ttvn,\r\nflags & BATADV_TT_SYNC_MASK);\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Creating new global tt entry: %pM (vid: %d, via %pM)\n",\r\ncommon->addr, batadv_print_vid(common->vid),\r\norig_node->orig);\r\nret = true;\r\nout_remove:\r\nif (is_multicast_ether_addr(tt_addr))\r\ngoto out;\r\nlocal_flags = batadv_tt_local_remove(bat_priv, tt_addr, vid,\r\n"global tt received",\r\nflags & BATADV_TT_CLIENT_ROAM);\r\ntt_global_entry->common.flags |= local_flags & BATADV_TT_CLIENT_WIFI;\r\nif (!(flags & BATADV_TT_CLIENT_ROAM))\r\ntt_global_entry->common.flags &= ~BATADV_TT_CLIENT_ROAM;\r\nout:\r\nif (tt_global_entry)\r\nbatadv_tt_global_entry_put(tt_global_entry);\r\nif (tt_local_entry)\r\nbatadv_tt_local_entry_put(tt_local_entry);\r\nreturn ret;\r\n}\r\nstatic struct batadv_tt_orig_list_entry *\r\nbatadv_transtable_best_orig(struct batadv_priv *bat_priv,\r\nstruct batadv_tt_global_entry *tt_global_entry)\r\n{\r\nstruct batadv_neigh_node *router, *best_router = NULL;\r\nstruct batadv_algo_ops *bao = bat_priv->algo_ops;\r\nstruct hlist_head *head;\r\nstruct batadv_tt_orig_list_entry *orig_entry, *best_entry = NULL;\r\nhead = &tt_global_entry->orig_list;\r\nhlist_for_each_entry_rcu(orig_entry, head, list) {\r\nrouter = batadv_orig_router_get(orig_entry->orig_node,\r\nBATADV_IF_DEFAULT);\r\nif (!router)\r\ncontinue;\r\nif (best_router &&\r\nbao->neigh.cmp(router, BATADV_IF_DEFAULT, best_router,\r\nBATADV_IF_DEFAULT) <= 0) {\r\nbatadv_neigh_node_put(router);\r\ncontinue;\r\n}\r\nif (best_router)\r\nbatadv_neigh_node_put(best_router);\r\nbest_entry = orig_entry;\r\nbest_router = router;\r\n}\r\nif (best_router)\r\nbatadv_neigh_node_put(best_router);\r\nreturn best_entry;\r\n}\r\nstatic void\r\nbatadv_tt_global_print_entry(struct batadv_priv *bat_priv,\r\nstruct batadv_tt_global_entry *tt_global_entry,\r\nstruct seq_file *seq)\r\n{\r\nstruct batadv_tt_orig_list_entry *orig_entry, *best_entry;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_orig_node_vlan *vlan;\r\nstruct hlist_head *head;\r\nu8 last_ttvn;\r\nu16 flags;\r\ntt_common_entry = &tt_global_entry->common;\r\nflags = tt_common_entry->flags;\r\nbest_entry = batadv_transtable_best_orig(bat_priv, tt_global_entry);\r\nif (best_entry) {\r\nvlan = batadv_orig_node_vlan_get(best_entry->orig_node,\r\ntt_common_entry->vid);\r\nif (!vlan) {\r\nseq_printf(seq,\r\n" * Cannot retrieve VLAN %d for originator %pM\n",\r\nbatadv_print_vid(tt_common_entry->vid),\r\nbest_entry->orig_node->orig);\r\ngoto print_list;\r\n}\r\nlast_ttvn = atomic_read(&best_entry->orig_node->last_ttvn);\r\nseq_printf(seq,\r\n" %c %pM %4i (%3u) via %pM (%3u) (%#.8x) [%c%c%c%c]\n",\r\n'*', tt_global_entry->common.addr,\r\nbatadv_print_vid(tt_global_entry->common.vid),\r\nbest_entry->ttvn, best_entry->orig_node->orig,\r\nlast_ttvn, vlan->tt.crc,\r\n((flags & BATADV_TT_CLIENT_ROAM) ? 'R' : '.'),\r\n((flags & BATADV_TT_CLIENT_WIFI) ? 'W' : '.'),\r\n((flags & BATADV_TT_CLIENT_ISOLA) ? 'I' : '.'),\r\n((flags & BATADV_TT_CLIENT_TEMP) ? 'T' : '.'));\r\nbatadv_orig_node_vlan_put(vlan);\r\n}\r\nprint_list:\r\nhead = &tt_global_entry->orig_list;\r\nhlist_for_each_entry_rcu(orig_entry, head, list) {\r\nif (best_entry == orig_entry)\r\ncontinue;\r\nvlan = batadv_orig_node_vlan_get(orig_entry->orig_node,\r\ntt_common_entry->vid);\r\nif (!vlan) {\r\nseq_printf(seq,\r\n" + Cannot retrieve VLAN %d for originator %pM\n",\r\nbatadv_print_vid(tt_common_entry->vid),\r\norig_entry->orig_node->orig);\r\ncontinue;\r\n}\r\nlast_ttvn = atomic_read(&orig_entry->orig_node->last_ttvn);\r\nseq_printf(seq,\r\n" %c %pM %4d (%3u) via %pM (%3u) (%#.8x) [%c%c%c%c]\n",\r\n'+', tt_global_entry->common.addr,\r\nbatadv_print_vid(tt_global_entry->common.vid),\r\norig_entry->ttvn, orig_entry->orig_node->orig,\r\nlast_ttvn, vlan->tt.crc,\r\n((flags & BATADV_TT_CLIENT_ROAM) ? 'R' : '.'),\r\n((flags & BATADV_TT_CLIENT_WIFI) ? 'W' : '.'),\r\n((flags & BATADV_TT_CLIENT_ISOLA) ? 'I' : '.'),\r\n((flags & BATADV_TT_CLIENT_TEMP) ? 'T' : '.'));\r\nbatadv_orig_node_vlan_put(vlan);\r\n}\r\n}\r\nint batadv_tt_global_seq_print_text(struct seq_file *seq, void *offset)\r\n{\r\nstruct net_device *net_dev = (struct net_device *)seq->private;\r\nstruct batadv_priv *bat_priv = netdev_priv(net_dev);\r\nstruct batadv_hashtable *hash = bat_priv->tt.global_hash;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_tt_global_entry *tt_global;\r\nstruct batadv_hard_iface *primary_if;\r\nstruct hlist_head *head;\r\nu32 i;\r\nprimary_if = batadv_seq_print_text_primary_if_get(seq);\r\nif (!primary_if)\r\ngoto out;\r\nseq_printf(seq,\r\n"Globally announced TT entries received via the mesh %s\n",\r\nnet_dev->name);\r\nseq_puts(seq,\r\n" Client VID (TTVN) Originator (Curr TTVN) (CRC ) Flags\n");\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tt_common_entry,\r\nhead, hash_entry) {\r\ntt_global = container_of(tt_common_entry,\r\nstruct batadv_tt_global_entry,\r\ncommon);\r\nbatadv_tt_global_print_entry(bat_priv, tt_global, seq);\r\n}\r\nrcu_read_unlock();\r\n}\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\nreturn 0;\r\n}\r\nstatic int\r\nbatadv_tt_global_dump_subentry(struct sk_buff *msg, u32 portid, u32 seq,\r\nstruct batadv_tt_common_entry *common,\r\nstruct batadv_tt_orig_list_entry *orig,\r\nbool best)\r\n{\r\nu16 flags = (common->flags & (~BATADV_TT_SYNC_MASK)) | orig->flags;\r\nvoid *hdr;\r\nstruct batadv_orig_node_vlan *vlan;\r\nu8 last_ttvn;\r\nu32 crc;\r\nvlan = batadv_orig_node_vlan_get(orig->orig_node,\r\ncommon->vid);\r\nif (!vlan)\r\nreturn 0;\r\ncrc = vlan->tt.crc;\r\nbatadv_orig_node_vlan_put(vlan);\r\nhdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family,\r\nNLM_F_MULTI,\r\nBATADV_CMD_GET_TRANSTABLE_GLOBAL);\r\nif (!hdr)\r\nreturn -ENOBUFS;\r\nlast_ttvn = atomic_read(&orig->orig_node->last_ttvn);\r\nif (nla_put(msg, BATADV_ATTR_TT_ADDRESS, ETH_ALEN, common->addr) ||\r\nnla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN,\r\norig->orig_node->orig) ||\r\nnla_put_u8(msg, BATADV_ATTR_TT_TTVN, orig->ttvn) ||\r\nnla_put_u8(msg, BATADV_ATTR_TT_LAST_TTVN, last_ttvn) ||\r\nnla_put_u32(msg, BATADV_ATTR_TT_CRC32, crc) ||\r\nnla_put_u16(msg, BATADV_ATTR_TT_VID, common->vid) ||\r\nnla_put_u32(msg, BATADV_ATTR_TT_FLAGS, flags))\r\ngoto nla_put_failure;\r\nif (best && nla_put_flag(msg, BATADV_ATTR_FLAG_BEST))\r\ngoto nla_put_failure;\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nbatadv_tt_global_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,\r\nstruct batadv_priv *bat_priv,\r\nstruct batadv_tt_common_entry *common, int *sub_s)\r\n{\r\nstruct batadv_tt_orig_list_entry *orig_entry, *best_entry;\r\nstruct batadv_tt_global_entry *global;\r\nstruct hlist_head *head;\r\nint sub = 0;\r\nbool best;\r\nglobal = container_of(common, struct batadv_tt_global_entry, common);\r\nbest_entry = batadv_transtable_best_orig(bat_priv, global);\r\nhead = &global->orig_list;\r\nhlist_for_each_entry_rcu(orig_entry, head, list) {\r\nif (sub++ < *sub_s)\r\ncontinue;\r\nbest = (orig_entry == best_entry);\r\nif (batadv_tt_global_dump_subentry(msg, portid, seq, common,\r\norig_entry, best)) {\r\n*sub_s = sub - 1;\r\nreturn -EMSGSIZE;\r\n}\r\n}\r\n*sub_s = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nbatadv_tt_global_dump_bucket(struct sk_buff *msg, u32 portid, u32 seq,\r\nstruct batadv_priv *bat_priv,\r\nstruct hlist_head *head, int *idx_s, int *sub)\r\n{\r\nstruct batadv_tt_common_entry *common;\r\nint idx = 0;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(common, head, hash_entry) {\r\nif (idx++ < *idx_s)\r\ncontinue;\r\nif (batadv_tt_global_dump_entry(msg, portid, seq, bat_priv,\r\ncommon, sub)) {\r\nrcu_read_unlock();\r\n*idx_s = idx - 1;\r\nreturn -EMSGSIZE;\r\n}\r\n}\r\nrcu_read_unlock();\r\n*idx_s = 0;\r\n*sub = 0;\r\nreturn 0;\r\n}\r\nint batadv_tt_global_dump(struct sk_buff *msg, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(cb->skb->sk);\r\nstruct net_device *soft_iface;\r\nstruct batadv_priv *bat_priv;\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nstruct batadv_hashtable *hash;\r\nstruct hlist_head *head;\r\nint ret;\r\nint ifindex;\r\nint bucket = cb->args[0];\r\nint idx = cb->args[1];\r\nint sub = cb->args[2];\r\nint portid = NETLINK_CB(cb->skb).portid;\r\nifindex = batadv_netlink_get_ifindex(cb->nlh, BATADV_ATTR_MESH_IFINDEX);\r\nif (!ifindex)\r\nreturn -EINVAL;\r\nsoft_iface = dev_get_by_index(net, ifindex);\r\nif (!soft_iface || !batadv_softif_is_valid(soft_iface)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nbat_priv = netdev_priv(soft_iface);\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nhash = bat_priv->tt.global_hash;\r\nwhile (bucket < hash->size) {\r\nhead = &hash->table[bucket];\r\nif (batadv_tt_global_dump_bucket(msg, portid,\r\ncb->nlh->nlmsg_seq, bat_priv,\r\nhead, &idx, &sub))\r\nbreak;\r\nbucket++;\r\n}\r\nret = msg->len;\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\nif (soft_iface)\r\ndev_put(soft_iface);\r\ncb->args[0] = bucket;\r\ncb->args[1] = idx;\r\ncb->args[2] = sub;\r\nreturn ret;\r\n}\r\nstatic void\r\n_batadv_tt_global_del_orig_entry(struct batadv_tt_global_entry *tt_global_entry,\r\nstruct batadv_tt_orig_list_entry *orig_entry)\r\n{\r\nlockdep_assert_held(&tt_global_entry->list_lock);\r\nbatadv_tt_global_size_dec(orig_entry->orig_node,\r\ntt_global_entry->common.vid);\r\natomic_dec(&tt_global_entry->orig_list_count);\r\nhlist_del_rcu(&orig_entry->list);\r\nbatadv_tt_orig_list_entry_put(orig_entry);\r\n}\r\nstatic void\r\nbatadv_tt_global_del_orig_list(struct batadv_tt_global_entry *tt_global_entry)\r\n{\r\nstruct hlist_head *head;\r\nstruct hlist_node *safe;\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\nspin_lock_bh(&tt_global_entry->list_lock);\r\nhead = &tt_global_entry->orig_list;\r\nhlist_for_each_entry_safe(orig_entry, safe, head, list)\r\n_batadv_tt_global_del_orig_entry(tt_global_entry, orig_entry);\r\nspin_unlock_bh(&tt_global_entry->list_lock);\r\n}\r\nstatic void\r\nbatadv_tt_global_del_orig_node(struct batadv_priv *bat_priv,\r\nstruct batadv_tt_global_entry *tt_global_entry,\r\nstruct batadv_orig_node *orig_node,\r\nconst char *message)\r\n{\r\nstruct hlist_head *head;\r\nstruct hlist_node *safe;\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\nunsigned short vid;\r\nspin_lock_bh(&tt_global_entry->list_lock);\r\nhead = &tt_global_entry->orig_list;\r\nhlist_for_each_entry_safe(orig_entry, safe, head, list) {\r\nif (orig_entry->orig_node == orig_node) {\r\nvid = tt_global_entry->common.vid;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Deleting %pM from global tt entry %pM (vid: %d): %s\n",\r\norig_node->orig,\r\ntt_global_entry->common.addr,\r\nbatadv_print_vid(vid), message);\r\n_batadv_tt_global_del_orig_entry(tt_global_entry,\r\norig_entry);\r\n}\r\n}\r\nspin_unlock_bh(&tt_global_entry->list_lock);\r\n}\r\nstatic void\r\nbatadv_tt_global_del_roaming(struct batadv_priv *bat_priv,\r\nstruct batadv_tt_global_entry *tt_global_entry,\r\nstruct batadv_orig_node *orig_node,\r\nconst char *message)\r\n{\r\nbool last_entry = true;\r\nstruct hlist_head *head;\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\nrcu_read_lock();\r\nhead = &tt_global_entry->orig_list;\r\nhlist_for_each_entry_rcu(orig_entry, head, list) {\r\nif (orig_entry->orig_node != orig_node) {\r\nlast_entry = false;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (last_entry) {\r\ntt_global_entry->common.flags |= BATADV_TT_CLIENT_ROAM;\r\ntt_global_entry->roam_at = jiffies;\r\n} else {\r\nbatadv_tt_global_del_orig_node(bat_priv, tt_global_entry,\r\norig_node, message);\r\n}\r\n}\r\nstatic void batadv_tt_global_del(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nconst unsigned char *addr, unsigned short vid,\r\nconst char *message, bool roaming)\r\n{\r\nstruct batadv_tt_global_entry *tt_global_entry;\r\nstruct batadv_tt_local_entry *local_entry = NULL;\r\ntt_global_entry = batadv_tt_global_hash_find(bat_priv, addr, vid);\r\nif (!tt_global_entry)\r\ngoto out;\r\nif (!roaming) {\r\nbatadv_tt_global_del_orig_node(bat_priv, tt_global_entry,\r\norig_node, message);\r\nif (hlist_empty(&tt_global_entry->orig_list))\r\nbatadv_tt_global_free(bat_priv, tt_global_entry,\r\nmessage);\r\ngoto out;\r\n}\r\nlocal_entry = batadv_tt_local_hash_find(bat_priv,\r\ntt_global_entry->common.addr,\r\nvid);\r\nif (local_entry) {\r\nbatadv_tt_global_del_orig_list(tt_global_entry);\r\nbatadv_tt_global_free(bat_priv, tt_global_entry, message);\r\n} else {\r\nbatadv_tt_global_del_roaming(bat_priv, tt_global_entry,\r\norig_node, message);\r\n}\r\nout:\r\nif (tt_global_entry)\r\nbatadv_tt_global_entry_put(tt_global_entry);\r\nif (local_entry)\r\nbatadv_tt_local_entry_put(local_entry);\r\n}\r\nvoid batadv_tt_global_del_orig(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\ns32 match_vid,\r\nconst char *message)\r\n{\r\nstruct batadv_tt_global_entry *tt_global;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nu32 i;\r\nstruct batadv_hashtable *hash = bat_priv->tt.global_hash;\r\nstruct hlist_node *safe;\r\nstruct hlist_head *head;\r\nspinlock_t *list_lock;\r\nunsigned short vid;\r\nif (!hash)\r\nreturn;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nhlist_for_each_entry_safe(tt_common_entry, safe,\r\nhead, hash_entry) {\r\nif (match_vid >= 0 && tt_common_entry->vid != match_vid)\r\ncontinue;\r\ntt_global = container_of(tt_common_entry,\r\nstruct batadv_tt_global_entry,\r\ncommon);\r\nbatadv_tt_global_del_orig_node(bat_priv, tt_global,\r\norig_node, message);\r\nif (hlist_empty(&tt_global->orig_list)) {\r\nvid = tt_global->common.vid;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Deleting global tt entry %pM (vid: %d): %s\n",\r\ntt_global->common.addr,\r\nbatadv_print_vid(vid), message);\r\nhlist_del_rcu(&tt_common_entry->hash_entry);\r\nbatadv_tt_global_entry_put(tt_global);\r\n}\r\n}\r\nspin_unlock_bh(list_lock);\r\n}\r\nclear_bit(BATADV_ORIG_CAPA_HAS_TT, &orig_node->capa_initialized);\r\n}\r\nstatic bool batadv_tt_global_to_purge(struct batadv_tt_global_entry *tt_global,\r\nchar **msg)\r\n{\r\nbool purge = false;\r\nunsigned long roam_timeout = BATADV_TT_CLIENT_ROAM_TIMEOUT;\r\nunsigned long temp_timeout = BATADV_TT_CLIENT_TEMP_TIMEOUT;\r\nif ((tt_global->common.flags & BATADV_TT_CLIENT_ROAM) &&\r\nbatadv_has_timed_out(tt_global->roam_at, roam_timeout)) {\r\npurge = true;\r\n*msg = "Roaming timeout\n";\r\n}\r\nif ((tt_global->common.flags & BATADV_TT_CLIENT_TEMP) &&\r\nbatadv_has_timed_out(tt_global->common.added_at, temp_timeout)) {\r\npurge = true;\r\n*msg = "Temporary client timeout\n";\r\n}\r\nreturn purge;\r\n}\r\nstatic void batadv_tt_global_purge(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->tt.global_hash;\r\nstruct hlist_head *head;\r\nstruct hlist_node *node_tmp;\r\nspinlock_t *list_lock;\r\nu32 i;\r\nchar *msg = NULL;\r\nstruct batadv_tt_common_entry *tt_common;\r\nstruct batadv_tt_global_entry *tt_global;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nhlist_for_each_entry_safe(tt_common, node_tmp, head,\r\nhash_entry) {\r\ntt_global = container_of(tt_common,\r\nstruct batadv_tt_global_entry,\r\ncommon);\r\nif (!batadv_tt_global_to_purge(tt_global, &msg))\r\ncontinue;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Deleting global tt entry %pM (vid: %d): %s\n",\r\ntt_global->common.addr,\r\nbatadv_print_vid(tt_global->common.vid),\r\nmsg);\r\nhlist_del_rcu(&tt_common->hash_entry);\r\nbatadv_tt_global_entry_put(tt_global);\r\n}\r\nspin_unlock_bh(list_lock);\r\n}\r\n}\r\nstatic void batadv_tt_global_table_free(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_hashtable *hash;\r\nspinlock_t *list_lock;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_tt_global_entry *tt_global;\r\nstruct hlist_node *node_tmp;\r\nstruct hlist_head *head;\r\nu32 i;\r\nif (!bat_priv->tt.global_hash)\r\nreturn;\r\nhash = bat_priv->tt.global_hash;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nhlist_for_each_entry_safe(tt_common_entry, node_tmp,\r\nhead, hash_entry) {\r\nhlist_del_rcu(&tt_common_entry->hash_entry);\r\ntt_global = container_of(tt_common_entry,\r\nstruct batadv_tt_global_entry,\r\ncommon);\r\nbatadv_tt_global_entry_put(tt_global);\r\n}\r\nspin_unlock_bh(list_lock);\r\n}\r\nbatadv_hash_destroy(hash);\r\nbat_priv->tt.global_hash = NULL;\r\n}\r\nstatic bool\r\n_batadv_is_ap_isolated(struct batadv_tt_local_entry *tt_local_entry,\r\nstruct batadv_tt_global_entry *tt_global_entry)\r\n{\r\nif (tt_local_entry->common.flags & BATADV_TT_CLIENT_WIFI &&\r\ntt_global_entry->common.flags & BATADV_TT_CLIENT_WIFI)\r\nreturn true;\r\nif (tt_local_entry->common.flags & BATADV_TT_CLIENT_ISOLA &&\r\ntt_global_entry->common.flags & BATADV_TT_CLIENT_ISOLA)\r\nreturn true;\r\nreturn false;\r\n}\r\nstruct batadv_orig_node *batadv_transtable_search(struct batadv_priv *bat_priv,\r\nconst u8 *src,\r\nconst u8 *addr,\r\nunsigned short vid)\r\n{\r\nstruct batadv_tt_local_entry *tt_local_entry = NULL;\r\nstruct batadv_tt_global_entry *tt_global_entry = NULL;\r\nstruct batadv_orig_node *orig_node = NULL;\r\nstruct batadv_tt_orig_list_entry *best_entry;\r\nif (src && batadv_vlan_ap_isola_get(bat_priv, vid)) {\r\ntt_local_entry = batadv_tt_local_hash_find(bat_priv, src, vid);\r\nif (!tt_local_entry ||\r\n(tt_local_entry->common.flags & BATADV_TT_CLIENT_PENDING))\r\ngoto out;\r\n}\r\ntt_global_entry = batadv_tt_global_hash_find(bat_priv, addr, vid);\r\nif (!tt_global_entry)\r\ngoto out;\r\nif (tt_local_entry &&\r\n_batadv_is_ap_isolated(tt_local_entry, tt_global_entry))\r\ngoto out;\r\nrcu_read_lock();\r\nbest_entry = batadv_transtable_best_orig(bat_priv, tt_global_entry);\r\nif (best_entry)\r\norig_node = best_entry->orig_node;\r\nif (orig_node && !kref_get_unless_zero(&orig_node->refcount))\r\norig_node = NULL;\r\nrcu_read_unlock();\r\nout:\r\nif (tt_global_entry)\r\nbatadv_tt_global_entry_put(tt_global_entry);\r\nif (tt_local_entry)\r\nbatadv_tt_local_entry_put(tt_local_entry);\r\nreturn orig_node;\r\n}\r\nstatic u32 batadv_tt_global_crc(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nunsigned short vid)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->tt.global_hash;\r\nstruct batadv_tt_orig_list_entry *tt_orig;\r\nstruct batadv_tt_common_entry *tt_common;\r\nstruct batadv_tt_global_entry *tt_global;\r\nstruct hlist_head *head;\r\nu32 i, crc_tmp, crc = 0;\r\nu8 flags;\r\n__be16 tmp_vid;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tt_common, head, hash_entry) {\r\ntt_global = container_of(tt_common,\r\nstruct batadv_tt_global_entry,\r\ncommon);\r\nif (tt_common->vid != vid)\r\ncontinue;\r\nif (tt_common->flags & BATADV_TT_CLIENT_ROAM)\r\ncontinue;\r\nif (tt_common->flags & BATADV_TT_CLIENT_TEMP)\r\ncontinue;\r\ntt_orig = batadv_tt_global_orig_entry_find(tt_global,\r\norig_node);\r\nif (!tt_orig)\r\ncontinue;\r\ntmp_vid = htons(tt_common->vid);\r\ncrc_tmp = crc32c(0, &tmp_vid, sizeof(tmp_vid));\r\nflags = tt_orig->flags;\r\ncrc_tmp = crc32c(crc_tmp, &flags, sizeof(flags));\r\ncrc ^= crc32c(crc_tmp, tt_common->addr, ETH_ALEN);\r\nbatadv_tt_orig_list_entry_put(tt_orig);\r\n}\r\nrcu_read_unlock();\r\n}\r\nreturn crc;\r\n}\r\nstatic u32 batadv_tt_local_crc(struct batadv_priv *bat_priv,\r\nunsigned short vid)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->tt.local_hash;\r\nstruct batadv_tt_common_entry *tt_common;\r\nstruct hlist_head *head;\r\nu32 i, crc_tmp, crc = 0;\r\nu8 flags;\r\n__be16 tmp_vid;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tt_common, head, hash_entry) {\r\nif (tt_common->vid != vid)\r\ncontinue;\r\nif (tt_common->flags & BATADV_TT_CLIENT_NEW)\r\ncontinue;\r\ntmp_vid = htons(tt_common->vid);\r\ncrc_tmp = crc32c(0, &tmp_vid, sizeof(tmp_vid));\r\nflags = tt_common->flags & BATADV_TT_SYNC_MASK;\r\ncrc_tmp = crc32c(crc_tmp, &flags, sizeof(flags));\r\ncrc ^= crc32c(crc_tmp, tt_common->addr, ETH_ALEN);\r\n}\r\nrcu_read_unlock();\r\n}\r\nreturn crc;\r\n}\r\nstatic void batadv_tt_req_node_release(struct kref *ref)\r\n{\r\nstruct batadv_tt_req_node *tt_req_node;\r\ntt_req_node = container_of(ref, struct batadv_tt_req_node, refcount);\r\nkmem_cache_free(batadv_tt_req_cache, tt_req_node);\r\n}\r\nstatic void batadv_tt_req_node_put(struct batadv_tt_req_node *tt_req_node)\r\n{\r\nkref_put(&tt_req_node->refcount, batadv_tt_req_node_release);\r\n}\r\nstatic void batadv_tt_req_list_free(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_tt_req_node *node;\r\nstruct hlist_node *safe;\r\nspin_lock_bh(&bat_priv->tt.req_list_lock);\r\nhlist_for_each_entry_safe(node, safe, &bat_priv->tt.req_list, list) {\r\nhlist_del_init(&node->list);\r\nbatadv_tt_req_node_put(node);\r\n}\r\nspin_unlock_bh(&bat_priv->tt.req_list_lock);\r\n}\r\nstatic void batadv_tt_save_orig_buffer(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nconst void *tt_buff,\r\nu16 tt_buff_len)\r\n{\r\nspin_lock_bh(&orig_node->tt_buff_lock);\r\nif (tt_buff_len > 0) {\r\nkfree(orig_node->tt_buff);\r\norig_node->tt_buff_len = 0;\r\norig_node->tt_buff = kmalloc(tt_buff_len, GFP_ATOMIC);\r\nif (orig_node->tt_buff) {\r\nmemcpy(orig_node->tt_buff, tt_buff, tt_buff_len);\r\norig_node->tt_buff_len = tt_buff_len;\r\n}\r\n}\r\nspin_unlock_bh(&orig_node->tt_buff_lock);\r\n}\r\nstatic void batadv_tt_req_purge(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_tt_req_node *node;\r\nstruct hlist_node *safe;\r\nspin_lock_bh(&bat_priv->tt.req_list_lock);\r\nhlist_for_each_entry_safe(node, safe, &bat_priv->tt.req_list, list) {\r\nif (batadv_has_timed_out(node->issued_at,\r\nBATADV_TT_REQUEST_TIMEOUT)) {\r\nhlist_del_init(&node->list);\r\nbatadv_tt_req_node_put(node);\r\n}\r\n}\r\nspin_unlock_bh(&bat_priv->tt.req_list_lock);\r\n}\r\nstatic struct batadv_tt_req_node *\r\nbatadv_tt_req_node_new(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_tt_req_node *tt_req_node_tmp, *tt_req_node = NULL;\r\nspin_lock_bh(&bat_priv->tt.req_list_lock);\r\nhlist_for_each_entry(tt_req_node_tmp, &bat_priv->tt.req_list, list) {\r\nif (batadv_compare_eth(tt_req_node_tmp, orig_node) &&\r\n!batadv_has_timed_out(tt_req_node_tmp->issued_at,\r\nBATADV_TT_REQUEST_TIMEOUT))\r\ngoto unlock;\r\n}\r\ntt_req_node = kmem_cache_alloc(batadv_tt_req_cache, GFP_ATOMIC);\r\nif (!tt_req_node)\r\ngoto unlock;\r\nkref_init(&tt_req_node->refcount);\r\nether_addr_copy(tt_req_node->addr, orig_node->orig);\r\ntt_req_node->issued_at = jiffies;\r\nkref_get(&tt_req_node->refcount);\r\nhlist_add_head(&tt_req_node->list, &bat_priv->tt.req_list);\r\nunlock:\r\nspin_unlock_bh(&bat_priv->tt.req_list_lock);\r\nreturn tt_req_node;\r\n}\r\nstatic bool batadv_tt_local_valid(const void *entry_ptr, const void *data_ptr)\r\n{\r\nconst struct batadv_tt_common_entry *tt_common_entry = entry_ptr;\r\nif (tt_common_entry->flags & BATADV_TT_CLIENT_NEW)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool batadv_tt_global_valid(const void *entry_ptr,\r\nconst void *data_ptr)\r\n{\r\nconst struct batadv_tt_common_entry *tt_common_entry = entry_ptr;\r\nconst struct batadv_tt_global_entry *tt_global_entry;\r\nconst struct batadv_orig_node *orig_node = data_ptr;\r\nif (tt_common_entry->flags & BATADV_TT_CLIENT_ROAM ||\r\ntt_common_entry->flags & BATADV_TT_CLIENT_TEMP)\r\nreturn false;\r\ntt_global_entry = container_of(tt_common_entry,\r\nstruct batadv_tt_global_entry,\r\ncommon);\r\nreturn batadv_tt_global_entry_has_orig(tt_global_entry, orig_node);\r\n}\r\nstatic void batadv_tt_tvlv_generate(struct batadv_priv *bat_priv,\r\nstruct batadv_hashtable *hash,\r\nvoid *tvlv_buff, u16 tt_len,\r\nbool (*valid_cb)(const void *,\r\nconst void *),\r\nvoid *cb_data)\r\n{\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_tvlv_tt_change *tt_change;\r\nstruct hlist_head *head;\r\nu16 tt_tot, tt_num_entries = 0;\r\nu32 i;\r\ntt_tot = batadv_tt_entries(tt_len);\r\ntt_change = (struct batadv_tvlv_tt_change *)tvlv_buff;\r\nrcu_read_lock();\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nhlist_for_each_entry_rcu(tt_common_entry,\r\nhead, hash_entry) {\r\nif (tt_tot == tt_num_entries)\r\nbreak;\r\nif ((valid_cb) && (!valid_cb(tt_common_entry, cb_data)))\r\ncontinue;\r\nether_addr_copy(tt_change->addr, tt_common_entry->addr);\r\ntt_change->flags = tt_common_entry->flags;\r\ntt_change->vid = htons(tt_common_entry->vid);\r\nmemset(tt_change->reserved, 0,\r\nsizeof(tt_change->reserved));\r\ntt_num_entries++;\r\ntt_change++;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic bool batadv_tt_global_check_crc(struct batadv_orig_node *orig_node,\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan,\r\nu16 num_vlan)\r\n{\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan_tmp;\r\nstruct batadv_orig_node_vlan *vlan;\r\nint i, orig_num_vlan;\r\nu32 crc;\r\nfor (i = 0; i < num_vlan; i++) {\r\ntt_vlan_tmp = tt_vlan + i;\r\nif (batadv_bla_is_backbone_gw_orig(orig_node->bat_priv,\r\norig_node->orig,\r\nntohs(tt_vlan_tmp->vid)))\r\ncontinue;\r\nvlan = batadv_orig_node_vlan_get(orig_node,\r\nntohs(tt_vlan_tmp->vid));\r\nif (!vlan)\r\nreturn false;\r\ncrc = vlan->tt.crc;\r\nbatadv_orig_node_vlan_put(vlan);\r\nif (crc != ntohl(tt_vlan_tmp->crc))\r\nreturn false;\r\n}\r\nrcu_read_lock();\r\norig_num_vlan = 0;\r\nhlist_for_each_entry_rcu(vlan, &orig_node->vlan_list, list)\r\norig_num_vlan++;\r\nrcu_read_unlock();\r\nif (orig_num_vlan > num_vlan)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void batadv_tt_local_update_crc(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_softif_vlan *vlan;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(vlan, &bat_priv->softif_vlan_list, list) {\r\nvlan->tt.crc = batadv_tt_local_crc(bat_priv, vlan->vid);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void batadv_tt_global_update_crc(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_orig_node_vlan *vlan;\r\nu32 crc;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(vlan, &orig_node->vlan_list, list) {\r\nif (batadv_bla_is_backbone_gw_orig(bat_priv, orig_node->orig,\r\nvlan->vid))\r\ncontinue;\r\ncrc = batadv_tt_global_crc(bat_priv, orig_node, vlan->vid);\r\nvlan->tt.crc = crc;\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic bool batadv_send_tt_request(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *dst_orig_node,\r\nu8 ttvn,\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan,\r\nu16 num_vlan, bool full_table)\r\n{\r\nstruct batadv_tvlv_tt_data *tvlv_tt_data = NULL;\r\nstruct batadv_tt_req_node *tt_req_node = NULL;\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan_req;\r\nstruct batadv_hard_iface *primary_if;\r\nbool ret = false;\r\nint i, size;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\ntt_req_node = batadv_tt_req_node_new(bat_priv, dst_orig_node);\r\nif (!tt_req_node)\r\ngoto out;\r\nsize = sizeof(*tvlv_tt_data) + sizeof(*tt_vlan_req) * num_vlan;\r\ntvlv_tt_data = kzalloc(size, GFP_ATOMIC);\r\nif (!tvlv_tt_data)\r\ngoto out;\r\ntvlv_tt_data->flags = BATADV_TT_REQUEST;\r\ntvlv_tt_data->ttvn = ttvn;\r\ntvlv_tt_data->num_vlan = htons(num_vlan);\r\ntt_vlan_req = (struct batadv_tvlv_tt_vlan_data *)(tvlv_tt_data + 1);\r\nfor (i = 0; i < num_vlan; i++) {\r\ntt_vlan_req->vid = tt_vlan->vid;\r\ntt_vlan_req->crc = tt_vlan->crc;\r\ntt_vlan_req++;\r\ntt_vlan++;\r\n}\r\nif (full_table)\r\ntvlv_tt_data->flags |= BATADV_TT_FULL_TABLE;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv, "Sending TT_REQUEST to %pM [%c]\n",\r\ndst_orig_node->orig, full_table ? 'F' : '.');\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TT_REQUEST_TX);\r\nbatadv_tvlv_unicast_send(bat_priv, primary_if->net_dev->dev_addr,\r\ndst_orig_node->orig, BATADV_TVLV_TT, 1,\r\ntvlv_tt_data, size);\r\nret = true;\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\nif (ret && tt_req_node) {\r\nspin_lock_bh(&bat_priv->tt.req_list_lock);\r\nif (!hlist_unhashed(&tt_req_node->list)) {\r\nhlist_del_init(&tt_req_node->list);\r\nbatadv_tt_req_node_put(tt_req_node);\r\n}\r\nspin_unlock_bh(&bat_priv->tt.req_list_lock);\r\n}\r\nif (tt_req_node)\r\nbatadv_tt_req_node_put(tt_req_node);\r\nkfree(tvlv_tt_data);\r\nreturn ret;\r\n}\r\nstatic bool batadv_send_other_tt_response(struct batadv_priv *bat_priv,\r\nstruct batadv_tvlv_tt_data *tt_data,\r\nu8 *req_src, u8 *req_dst)\r\n{\r\nstruct batadv_orig_node *req_dst_orig_node;\r\nstruct batadv_orig_node *res_dst_orig_node = NULL;\r\nstruct batadv_tvlv_tt_change *tt_change;\r\nstruct batadv_tvlv_tt_data *tvlv_tt_data = NULL;\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan;\r\nbool ret = false, full_table;\r\nu8 orig_ttvn, req_ttvn;\r\nu16 tvlv_len;\r\ns32 tt_len;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Received TT_REQUEST from %pM for ttvn: %u (%pM) [%c]\n",\r\nreq_src, tt_data->ttvn, req_dst,\r\n((tt_data->flags & BATADV_TT_FULL_TABLE) ? 'F' : '.'));\r\nreq_dst_orig_node = batadv_orig_hash_find(bat_priv, req_dst);\r\nif (!req_dst_orig_node)\r\ngoto out;\r\nres_dst_orig_node = batadv_orig_hash_find(bat_priv, req_src);\r\nif (!res_dst_orig_node)\r\ngoto out;\r\norig_ttvn = (u8)atomic_read(&req_dst_orig_node->last_ttvn);\r\nreq_ttvn = tt_data->ttvn;\r\ntt_vlan = (struct batadv_tvlv_tt_vlan_data *)(tt_data + 1);\r\nif (orig_ttvn != req_ttvn ||\r\n!batadv_tt_global_check_crc(req_dst_orig_node, tt_vlan,\r\nntohs(tt_data->num_vlan)))\r\ngoto out;\r\nif (tt_data->flags & BATADV_TT_FULL_TABLE ||\r\n!req_dst_orig_node->tt_buff)\r\nfull_table = true;\r\nelse\r\nfull_table = false;\r\nif (!full_table) {\r\nspin_lock_bh(&req_dst_orig_node->tt_buff_lock);\r\ntt_len = req_dst_orig_node->tt_buff_len;\r\ntvlv_len = batadv_tt_prepare_tvlv_global_data(req_dst_orig_node,\r\n&tvlv_tt_data,\r\n&tt_change,\r\n&tt_len);\r\nif (!tt_len)\r\ngoto unlock;\r\nmemcpy(tt_change, req_dst_orig_node->tt_buff,\r\nreq_dst_orig_node->tt_buff_len);\r\nspin_unlock_bh(&req_dst_orig_node->tt_buff_lock);\r\n} else {\r\ntt_len = -1;\r\ntvlv_len = batadv_tt_prepare_tvlv_global_data(req_dst_orig_node,\r\n&tvlv_tt_data,\r\n&tt_change,\r\n&tt_len);\r\nif (!tt_len)\r\ngoto out;\r\nbatadv_tt_tvlv_generate(bat_priv, bat_priv->tt.global_hash,\r\ntt_change, tt_len,\r\nbatadv_tt_global_valid,\r\nreq_dst_orig_node);\r\n}\r\ntt_len = sizeof(struct batadv_unicast_tvlv_packet) + tvlv_len;\r\nif (tt_len > atomic_read(&bat_priv->packet_size_max)) {\r\nnet_ratelimited_function(batadv_info, bat_priv->soft_iface,\r\n"Ignoring TT_REQUEST from %pM; Response size exceeds max packet size.\n",\r\nres_dst_orig_node->orig);\r\ngoto out;\r\n}\r\ntvlv_tt_data->flags = BATADV_TT_RESPONSE;\r\ntvlv_tt_data->ttvn = req_ttvn;\r\nif (full_table)\r\ntvlv_tt_data->flags |= BATADV_TT_FULL_TABLE;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Sending TT_RESPONSE %pM for %pM [%c] (ttvn: %u)\n",\r\nres_dst_orig_node->orig, req_dst_orig_node->orig,\r\nfull_table ? 'F' : '.', req_ttvn);\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TT_RESPONSE_TX);\r\nbatadv_tvlv_unicast_send(bat_priv, req_dst_orig_node->orig,\r\nreq_src, BATADV_TVLV_TT, 1, tvlv_tt_data,\r\ntvlv_len);\r\nret = true;\r\ngoto out;\r\nunlock:\r\nspin_unlock_bh(&req_dst_orig_node->tt_buff_lock);\r\nout:\r\nif (res_dst_orig_node)\r\nbatadv_orig_node_put(res_dst_orig_node);\r\nif (req_dst_orig_node)\r\nbatadv_orig_node_put(req_dst_orig_node);\r\nkfree(tvlv_tt_data);\r\nreturn ret;\r\n}\r\nstatic bool batadv_send_my_tt_response(struct batadv_priv *bat_priv,\r\nstruct batadv_tvlv_tt_data *tt_data,\r\nu8 *req_src)\r\n{\r\nstruct batadv_tvlv_tt_data *tvlv_tt_data = NULL;\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nstruct batadv_tvlv_tt_change *tt_change;\r\nstruct batadv_orig_node *orig_node;\r\nu8 my_ttvn, req_ttvn;\r\nu16 tvlv_len;\r\nbool full_table;\r\ns32 tt_len;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Received TT_REQUEST from %pM for ttvn: %u (me) [%c]\n",\r\nreq_src, tt_data->ttvn,\r\n((tt_data->flags & BATADV_TT_FULL_TABLE) ? 'F' : '.'));\r\nspin_lock_bh(&bat_priv->tt.commit_lock);\r\nmy_ttvn = (u8)atomic_read(&bat_priv->tt.vn);\r\nreq_ttvn = tt_data->ttvn;\r\norig_node = batadv_orig_hash_find(bat_priv, req_src);\r\nif (!orig_node)\r\ngoto out;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\nif (tt_data->flags & BATADV_TT_FULL_TABLE || my_ttvn != req_ttvn ||\r\n!bat_priv->tt.last_changeset)\r\nfull_table = true;\r\nelse\r\nfull_table = false;\r\nif (!full_table) {\r\nspin_lock_bh(&bat_priv->tt.last_changeset_lock);\r\ntt_len = bat_priv->tt.last_changeset_len;\r\ntvlv_len = batadv_tt_prepare_tvlv_local_data(bat_priv,\r\n&tvlv_tt_data,\r\n&tt_change,\r\n&tt_len);\r\nif (!tt_len || !tvlv_len)\r\ngoto unlock;\r\nmemcpy(tt_change, bat_priv->tt.last_changeset,\r\nbat_priv->tt.last_changeset_len);\r\nspin_unlock_bh(&bat_priv->tt.last_changeset_lock);\r\n} else {\r\nreq_ttvn = (u8)atomic_read(&bat_priv->tt.vn);\r\ntt_len = -1;\r\ntvlv_len = batadv_tt_prepare_tvlv_local_data(bat_priv,\r\n&tvlv_tt_data,\r\n&tt_change,\r\n&tt_len);\r\nif (!tt_len || !tvlv_len)\r\ngoto out;\r\nbatadv_tt_tvlv_generate(bat_priv, bat_priv->tt.local_hash,\r\ntt_change, tt_len,\r\nbatadv_tt_local_valid, NULL);\r\n}\r\ntvlv_tt_data->flags = BATADV_TT_RESPONSE;\r\ntvlv_tt_data->ttvn = req_ttvn;\r\nif (full_table)\r\ntvlv_tt_data->flags |= BATADV_TT_FULL_TABLE;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Sending TT_RESPONSE to %pM [%c] (ttvn: %u)\n",\r\norig_node->orig, full_table ? 'F' : '.', req_ttvn);\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TT_RESPONSE_TX);\r\nbatadv_tvlv_unicast_send(bat_priv, primary_if->net_dev->dev_addr,\r\nreq_src, BATADV_TVLV_TT, 1, tvlv_tt_data,\r\ntvlv_len);\r\ngoto out;\r\nunlock:\r\nspin_unlock_bh(&bat_priv->tt.last_changeset_lock);\r\nout:\r\nspin_unlock_bh(&bat_priv->tt.commit_lock);\r\nif (orig_node)\r\nbatadv_orig_node_put(orig_node);\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\nkfree(tvlv_tt_data);\r\nreturn true;\r\n}\r\nstatic bool batadv_send_tt_response(struct batadv_priv *bat_priv,\r\nstruct batadv_tvlv_tt_data *tt_data,\r\nu8 *req_src, u8 *req_dst)\r\n{\r\nif (batadv_is_my_mac(bat_priv, req_dst))\r\nreturn batadv_send_my_tt_response(bat_priv, tt_data, req_src);\r\nreturn batadv_send_other_tt_response(bat_priv, tt_data, req_src,\r\nreq_dst);\r\n}\r\nstatic void _batadv_tt_update_changes(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_tvlv_tt_change *tt_change,\r\nu16 tt_num_changes, u8 ttvn)\r\n{\r\nint i;\r\nint roams;\r\nfor (i = 0; i < tt_num_changes; i++) {\r\nif ((tt_change + i)->flags & BATADV_TT_CLIENT_DEL) {\r\nroams = (tt_change + i)->flags & BATADV_TT_CLIENT_ROAM;\r\nbatadv_tt_global_del(bat_priv, orig_node,\r\n(tt_change + i)->addr,\r\nntohs((tt_change + i)->vid),\r\n"tt removed by changes",\r\nroams);\r\n} else {\r\nif (!batadv_tt_global_add(bat_priv, orig_node,\r\n(tt_change + i)->addr,\r\nntohs((tt_change + i)->vid),\r\n(tt_change + i)->flags, ttvn))\r\nreturn;\r\n}\r\n}\r\nset_bit(BATADV_ORIG_CAPA_HAS_TT, &orig_node->capa_initialized);\r\n}\r\nstatic void batadv_tt_fill_gtable(struct batadv_priv *bat_priv,\r\nstruct batadv_tvlv_tt_change *tt_change,\r\nu8 ttvn, u8 *resp_src,\r\nu16 num_entries)\r\n{\r\nstruct batadv_orig_node *orig_node;\r\norig_node = batadv_orig_hash_find(bat_priv, resp_src);\r\nif (!orig_node)\r\ngoto out;\r\nbatadv_tt_global_del_orig(bat_priv, orig_node, -1,\r\n"Received full table");\r\n_batadv_tt_update_changes(bat_priv, orig_node, tt_change, num_entries,\r\nttvn);\r\nspin_lock_bh(&orig_node->tt_buff_lock);\r\nkfree(orig_node->tt_buff);\r\norig_node->tt_buff_len = 0;\r\norig_node->tt_buff = NULL;\r\nspin_unlock_bh(&orig_node->tt_buff_lock);\r\natomic_set(&orig_node->last_ttvn, ttvn);\r\nout:\r\nif (orig_node)\r\nbatadv_orig_node_put(orig_node);\r\n}\r\nstatic void batadv_tt_update_changes(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nu16 tt_num_changes, u8 ttvn,\r\nstruct batadv_tvlv_tt_change *tt_change)\r\n{\r\n_batadv_tt_update_changes(bat_priv, orig_node, tt_change,\r\ntt_num_changes, ttvn);\r\nbatadv_tt_save_orig_buffer(bat_priv, orig_node, tt_change,\r\nbatadv_tt_len(tt_num_changes));\r\natomic_set(&orig_node->last_ttvn, ttvn);\r\n}\r\nbool batadv_is_my_client(struct batadv_priv *bat_priv, const u8 *addr,\r\nunsigned short vid)\r\n{\r\nstruct batadv_tt_local_entry *tt_local_entry;\r\nbool ret = false;\r\ntt_local_entry = batadv_tt_local_hash_find(bat_priv, addr, vid);\r\nif (!tt_local_entry)\r\ngoto out;\r\nif ((tt_local_entry->common.flags & BATADV_TT_CLIENT_PENDING) ||\r\n(tt_local_entry->common.flags & BATADV_TT_CLIENT_ROAM))\r\ngoto out;\r\nret = true;\r\nout:\r\nif (tt_local_entry)\r\nbatadv_tt_local_entry_put(tt_local_entry);\r\nreturn ret;\r\n}\r\nstatic void batadv_handle_tt_response(struct batadv_priv *bat_priv,\r\nstruct batadv_tvlv_tt_data *tt_data,\r\nu8 *resp_src, u16 num_entries)\r\n{\r\nstruct batadv_tt_req_node *node;\r\nstruct hlist_node *safe;\r\nstruct batadv_orig_node *orig_node = NULL;\r\nstruct batadv_tvlv_tt_change *tt_change;\r\nu8 *tvlv_ptr = (u8 *)tt_data;\r\nu16 change_offset;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Received TT_RESPONSE from %pM for ttvn %d t_size: %d [%c]\n",\r\nresp_src, tt_data->ttvn, num_entries,\r\n((tt_data->flags & BATADV_TT_FULL_TABLE) ? 'F' : '.'));\r\norig_node = batadv_orig_hash_find(bat_priv, resp_src);\r\nif (!orig_node)\r\ngoto out;\r\nspin_lock_bh(&orig_node->tt_lock);\r\nchange_offset = sizeof(struct batadv_tvlv_tt_vlan_data);\r\nchange_offset *= ntohs(tt_data->num_vlan);\r\nchange_offset += sizeof(*tt_data);\r\ntvlv_ptr += change_offset;\r\ntt_change = (struct batadv_tvlv_tt_change *)tvlv_ptr;\r\nif (tt_data->flags & BATADV_TT_FULL_TABLE) {\r\nbatadv_tt_fill_gtable(bat_priv, tt_change, tt_data->ttvn,\r\nresp_src, num_entries);\r\n} else {\r\nbatadv_tt_update_changes(bat_priv, orig_node, num_entries,\r\ntt_data->ttvn, tt_change);\r\n}\r\nbatadv_tt_global_update_crc(bat_priv, orig_node);\r\nspin_unlock_bh(&orig_node->tt_lock);\r\nspin_lock_bh(&bat_priv->tt.req_list_lock);\r\nhlist_for_each_entry_safe(node, safe, &bat_priv->tt.req_list, list) {\r\nif (!batadv_compare_eth(node->addr, resp_src))\r\ncontinue;\r\nhlist_del_init(&node->list);\r\nbatadv_tt_req_node_put(node);\r\n}\r\nspin_unlock_bh(&bat_priv->tt.req_list_lock);\r\nout:\r\nif (orig_node)\r\nbatadv_orig_node_put(orig_node);\r\n}\r\nstatic void batadv_tt_roam_list_free(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_tt_roam_node *node, *safe;\r\nspin_lock_bh(&bat_priv->tt.roam_list_lock);\r\nlist_for_each_entry_safe(node, safe, &bat_priv->tt.roam_list, list) {\r\nlist_del(&node->list);\r\nkmem_cache_free(batadv_tt_roam_cache, node);\r\n}\r\nspin_unlock_bh(&bat_priv->tt.roam_list_lock);\r\n}\r\nstatic void batadv_tt_roam_purge(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_tt_roam_node *node, *safe;\r\nspin_lock_bh(&bat_priv->tt.roam_list_lock);\r\nlist_for_each_entry_safe(node, safe, &bat_priv->tt.roam_list, list) {\r\nif (!batadv_has_timed_out(node->first_time,\r\nBATADV_ROAMING_MAX_TIME))\r\ncontinue;\r\nlist_del(&node->list);\r\nkmem_cache_free(batadv_tt_roam_cache, node);\r\n}\r\nspin_unlock_bh(&bat_priv->tt.roam_list_lock);\r\n}\r\nstatic bool batadv_tt_check_roam_count(struct batadv_priv *bat_priv, u8 *client)\r\n{\r\nstruct batadv_tt_roam_node *tt_roam_node;\r\nbool ret = false;\r\nspin_lock_bh(&bat_priv->tt.roam_list_lock);\r\nlist_for_each_entry(tt_roam_node, &bat_priv->tt.roam_list, list) {\r\nif (!batadv_compare_eth(tt_roam_node->addr, client))\r\ncontinue;\r\nif (batadv_has_timed_out(tt_roam_node->first_time,\r\nBATADV_ROAMING_MAX_TIME))\r\ncontinue;\r\nif (!batadv_atomic_dec_not_zero(&tt_roam_node->counter))\r\ngoto unlock;\r\nret = true;\r\nbreak;\r\n}\r\nif (!ret) {\r\ntt_roam_node = kmem_cache_alloc(batadv_tt_roam_cache,\r\nGFP_ATOMIC);\r\nif (!tt_roam_node)\r\ngoto unlock;\r\ntt_roam_node->first_time = jiffies;\r\natomic_set(&tt_roam_node->counter,\r\nBATADV_ROAMING_MAX_COUNT - 1);\r\nether_addr_copy(tt_roam_node->addr, client);\r\nlist_add(&tt_roam_node->list, &bat_priv->tt.roam_list);\r\nret = true;\r\n}\r\nunlock:\r\nspin_unlock_bh(&bat_priv->tt.roam_list_lock);\r\nreturn ret;\r\n}\r\nstatic void batadv_send_roam_adv(struct batadv_priv *bat_priv, u8 *client,\r\nunsigned short vid,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_hard_iface *primary_if;\r\nstruct batadv_tvlv_roam_adv tvlv_roam;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\nif (!batadv_tt_check_roam_count(bat_priv, client))\r\ngoto out;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Sending ROAMING_ADV to %pM (client %pM, vid: %d)\n",\r\norig_node->orig, client, batadv_print_vid(vid));\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TT_ROAM_ADV_TX);\r\nmemcpy(tvlv_roam.client, client, sizeof(tvlv_roam.client));\r\ntvlv_roam.vid = htons(vid);\r\nbatadv_tvlv_unicast_send(bat_priv, primary_if->net_dev->dev_addr,\r\norig_node->orig, BATADV_TVLV_ROAM, 1,\r\n&tvlv_roam, sizeof(tvlv_roam));\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\n}\r\nstatic void batadv_tt_purge(struct work_struct *work)\r\n{\r\nstruct delayed_work *delayed_work;\r\nstruct batadv_priv_tt *priv_tt;\r\nstruct batadv_priv *bat_priv;\r\ndelayed_work = to_delayed_work(work);\r\npriv_tt = container_of(delayed_work, struct batadv_priv_tt, work);\r\nbat_priv = container_of(priv_tt, struct batadv_priv, tt);\r\nbatadv_tt_local_purge(bat_priv, BATADV_TT_LOCAL_TIMEOUT);\r\nbatadv_tt_global_purge(bat_priv);\r\nbatadv_tt_req_purge(bat_priv);\r\nbatadv_tt_roam_purge(bat_priv);\r\nqueue_delayed_work(batadv_event_workqueue, &bat_priv->tt.work,\r\nmsecs_to_jiffies(BATADV_TT_WORK_PERIOD));\r\n}\r\nvoid batadv_tt_free(struct batadv_priv *bat_priv)\r\n{\r\nbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_TT, 1);\r\nbatadv_tvlv_handler_unregister(bat_priv, BATADV_TVLV_TT, 1);\r\ncancel_delayed_work_sync(&bat_priv->tt.work);\r\nbatadv_tt_local_table_free(bat_priv);\r\nbatadv_tt_global_table_free(bat_priv);\r\nbatadv_tt_req_list_free(bat_priv);\r\nbatadv_tt_changes_list_free(bat_priv);\r\nbatadv_tt_roam_list_free(bat_priv);\r\nkfree(bat_priv->tt.last_changeset);\r\n}\r\nstatic void batadv_tt_local_set_flags(struct batadv_priv *bat_priv, u16 flags,\r\nbool enable, bool count)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->tt.local_hash;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct hlist_head *head;\r\nu32 i;\r\nif (!hash)\r\nreturn;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tt_common_entry,\r\nhead, hash_entry) {\r\nif (enable) {\r\nif ((tt_common_entry->flags & flags) == flags)\r\ncontinue;\r\ntt_common_entry->flags |= flags;\r\n} else {\r\nif (!(tt_common_entry->flags & flags))\r\ncontinue;\r\ntt_common_entry->flags &= ~flags;\r\n}\r\nif (!count)\r\ncontinue;\r\nbatadv_tt_local_size_inc(bat_priv,\r\ntt_common_entry->vid);\r\n}\r\nrcu_read_unlock();\r\n}\r\n}\r\nstatic void batadv_tt_local_purge_pending_clients(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->tt.local_hash;\r\nstruct batadv_tt_common_entry *tt_common;\r\nstruct batadv_tt_local_entry *tt_local;\r\nstruct hlist_node *node_tmp;\r\nstruct hlist_head *head;\r\nspinlock_t *list_lock;\r\nu32 i;\r\nif (!hash)\r\nreturn;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nhlist_for_each_entry_safe(tt_common, node_tmp, head,\r\nhash_entry) {\r\nif (!(tt_common->flags & BATADV_TT_CLIENT_PENDING))\r\ncontinue;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Deleting local tt entry (%pM, vid: %d): pending\n",\r\ntt_common->addr,\r\nbatadv_print_vid(tt_common->vid));\r\nbatadv_tt_local_size_dec(bat_priv, tt_common->vid);\r\nhlist_del_rcu(&tt_common->hash_entry);\r\ntt_local = container_of(tt_common,\r\nstruct batadv_tt_local_entry,\r\ncommon);\r\nbatadv_tt_local_entry_put(tt_local);\r\n}\r\nspin_unlock_bh(list_lock);\r\n}\r\n}\r\nstatic void batadv_tt_local_commit_changes_nolock(struct batadv_priv *bat_priv)\r\n{\r\nlockdep_assert_held(&bat_priv->tt.commit_lock);\r\nif (atomic_read(&bat_priv->tt.local_changes) < 1) {\r\nif (!batadv_atomic_dec_not_zero(&bat_priv->tt.ogm_append_cnt))\r\nbatadv_tt_tvlv_container_update(bat_priv);\r\nreturn;\r\n}\r\nbatadv_tt_local_set_flags(bat_priv, BATADV_TT_CLIENT_NEW, false, true);\r\nbatadv_tt_local_purge_pending_clients(bat_priv);\r\nbatadv_tt_local_update_crc(bat_priv);\r\natomic_inc(&bat_priv->tt.vn);\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Local changes committed, updating to ttvn %u\n",\r\n(u8)atomic_read(&bat_priv->tt.vn));\r\natomic_set(&bat_priv->tt.ogm_append_cnt, BATADV_TT_OGM_APPEND_MAX);\r\nbatadv_tt_tvlv_container_update(bat_priv);\r\n}\r\nvoid batadv_tt_local_commit_changes(struct batadv_priv *bat_priv)\r\n{\r\nspin_lock_bh(&bat_priv->tt.commit_lock);\r\nbatadv_tt_local_commit_changes_nolock(bat_priv);\r\nspin_unlock_bh(&bat_priv->tt.commit_lock);\r\n}\r\nbool batadv_is_ap_isolated(struct batadv_priv *bat_priv, u8 *src, u8 *dst,\r\nunsigned short vid)\r\n{\r\nstruct batadv_tt_local_entry *tt_local_entry;\r\nstruct batadv_tt_global_entry *tt_global_entry;\r\nstruct batadv_softif_vlan *vlan;\r\nbool ret = false;\r\nvlan = batadv_softif_vlan_get(bat_priv, vid);\r\nif (!vlan)\r\nreturn false;\r\nif (!atomic_read(&vlan->ap_isolation))\r\ngoto vlan_put;\r\ntt_local_entry = batadv_tt_local_hash_find(bat_priv, dst, vid);\r\nif (!tt_local_entry)\r\ngoto vlan_put;\r\ntt_global_entry = batadv_tt_global_hash_find(bat_priv, src, vid);\r\nif (!tt_global_entry)\r\ngoto local_entry_put;\r\nif (_batadv_is_ap_isolated(tt_local_entry, tt_global_entry))\r\nret = true;\r\nbatadv_tt_global_entry_put(tt_global_entry);\r\nlocal_entry_put:\r\nbatadv_tt_local_entry_put(tt_local_entry);\r\nvlan_put:\r\nbatadv_softif_vlan_put(vlan);\r\nreturn ret;\r\n}\r\nstatic void batadv_tt_update_orig(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nconst void *tt_buff, u16 tt_num_vlan,\r\nstruct batadv_tvlv_tt_change *tt_change,\r\nu16 tt_num_changes, u8 ttvn)\r\n{\r\nu8 orig_ttvn = (u8)atomic_read(&orig_node->last_ttvn);\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan;\r\nbool full_table = true;\r\nbool has_tt_init;\r\ntt_vlan = (struct batadv_tvlv_tt_vlan_data *)tt_buff;\r\nhas_tt_init = test_bit(BATADV_ORIG_CAPA_HAS_TT,\r\n&orig_node->capa_initialized);\r\nif ((!has_tt_init && ttvn == 1) || ttvn - orig_ttvn == 1) {\r\nif (!tt_num_changes) {\r\nfull_table = false;\r\ngoto request_table;\r\n}\r\nspin_lock_bh(&orig_node->tt_lock);\r\nbatadv_tt_update_changes(bat_priv, orig_node, tt_num_changes,\r\nttvn, tt_change);\r\nbatadv_tt_global_update_crc(bat_priv, orig_node);\r\nspin_unlock_bh(&orig_node->tt_lock);\r\nif (!batadv_tt_global_check_crc(orig_node, tt_vlan,\r\ntt_num_vlan))\r\ngoto request_table;\r\n} else {\r\nif (!has_tt_init || ttvn != orig_ttvn ||\r\n!batadv_tt_global_check_crc(orig_node, tt_vlan,\r\ntt_num_vlan)) {\r\nrequest_table:\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"TT inconsistency for %pM. Need to retrieve the correct information (ttvn: %u last_ttvn: %u num_changes: %u)\n",\r\norig_node->orig, ttvn, orig_ttvn,\r\ntt_num_changes);\r\nbatadv_send_tt_request(bat_priv, orig_node, ttvn,\r\ntt_vlan, tt_num_vlan,\r\nfull_table);\r\nreturn;\r\n}\r\n}\r\n}\r\nbool batadv_tt_global_client_is_roaming(struct batadv_priv *bat_priv,\r\nu8 *addr, unsigned short vid)\r\n{\r\nstruct batadv_tt_global_entry *tt_global_entry;\r\nbool ret = false;\r\ntt_global_entry = batadv_tt_global_hash_find(bat_priv, addr, vid);\r\nif (!tt_global_entry)\r\ngoto out;\r\nret = tt_global_entry->common.flags & BATADV_TT_CLIENT_ROAM;\r\nbatadv_tt_global_entry_put(tt_global_entry);\r\nout:\r\nreturn ret;\r\n}\r\nbool batadv_tt_local_client_is_roaming(struct batadv_priv *bat_priv,\r\nu8 *addr, unsigned short vid)\r\n{\r\nstruct batadv_tt_local_entry *tt_local_entry;\r\nbool ret = false;\r\ntt_local_entry = batadv_tt_local_hash_find(bat_priv, addr, vid);\r\nif (!tt_local_entry)\r\ngoto out;\r\nret = tt_local_entry->common.flags & BATADV_TT_CLIENT_ROAM;\r\nbatadv_tt_local_entry_put(tt_local_entry);\r\nout:\r\nreturn ret;\r\n}\r\nbool batadv_tt_add_temporary_global_entry(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nconst unsigned char *addr,\r\nunsigned short vid)\r\n{\r\nif (batadv_bla_is_loopdetect_mac(addr))\r\nreturn false;\r\nif (!batadv_tt_global_add(bat_priv, orig_node, addr, vid,\r\nBATADV_TT_CLIENT_TEMP,\r\natomic_read(&orig_node->last_ttvn)))\r\nreturn false;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Added temporary global client (addr: %pM, vid: %d, orig: %pM)\n",\r\naddr, batadv_print_vid(vid), orig_node->orig);\r\nreturn true;\r\n}\r\nvoid batadv_tt_local_resize_to_mtu(struct net_device *soft_iface)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\r\nint packet_size_max = atomic_read(&bat_priv->packet_size_max);\r\nint table_size, timeout = BATADV_TT_LOCAL_TIMEOUT / 2;\r\nbool reduced = false;\r\nspin_lock_bh(&bat_priv->tt.commit_lock);\r\nwhile (true) {\r\ntable_size = batadv_tt_local_table_transmit_size(bat_priv);\r\nif (packet_size_max >= table_size)\r\nbreak;\r\nbatadv_tt_local_purge(bat_priv, timeout);\r\nbatadv_tt_local_purge_pending_clients(bat_priv);\r\ntimeout /= 2;\r\nreduced = true;\r\nnet_ratelimited_function(batadv_info, soft_iface,\r\n"Forced to purge local tt entries to fit new maximum fragment MTU (%i)\n",\r\npacket_size_max);\r\n}\r\nif (reduced)\r\nbatadv_tt_local_commit_changes_nolock(bat_priv);\r\nspin_unlock_bh(&bat_priv->tt.commit_lock);\r\n}\r\nstatic void batadv_tt_tvlv_ogm_handler_v1(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig,\r\nu8 flags, void *tvlv_value,\r\nu16 tvlv_value_len)\r\n{\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan;\r\nstruct batadv_tvlv_tt_change *tt_change;\r\nstruct batadv_tvlv_tt_data *tt_data;\r\nu16 num_entries, num_vlan;\r\nif (tvlv_value_len < sizeof(*tt_data))\r\nreturn;\r\ntt_data = (struct batadv_tvlv_tt_data *)tvlv_value;\r\ntvlv_value_len -= sizeof(*tt_data);\r\nnum_vlan = ntohs(tt_data->num_vlan);\r\nif (tvlv_value_len < sizeof(*tt_vlan) * num_vlan)\r\nreturn;\r\ntt_vlan = (struct batadv_tvlv_tt_vlan_data *)(tt_data + 1);\r\ntt_change = (struct batadv_tvlv_tt_change *)(tt_vlan + num_vlan);\r\ntvlv_value_len -= sizeof(*tt_vlan) * num_vlan;\r\nnum_entries = batadv_tt_entries(tvlv_value_len);\r\nbatadv_tt_update_orig(bat_priv, orig, tt_vlan, num_vlan, tt_change,\r\nnum_entries, tt_data->ttvn);\r\n}\r\nstatic int batadv_tt_tvlv_unicast_handler_v1(struct batadv_priv *bat_priv,\r\nu8 *src, u8 *dst,\r\nvoid *tvlv_value,\r\nu16 tvlv_value_len)\r\n{\r\nstruct batadv_tvlv_tt_data *tt_data;\r\nu16 tt_vlan_len, tt_num_entries;\r\nchar tt_flag;\r\nbool ret;\r\nif (tvlv_value_len < sizeof(*tt_data))\r\nreturn NET_RX_SUCCESS;\r\ntt_data = (struct batadv_tvlv_tt_data *)tvlv_value;\r\ntvlv_value_len -= sizeof(*tt_data);\r\ntt_vlan_len = sizeof(struct batadv_tvlv_tt_vlan_data);\r\ntt_vlan_len *= ntohs(tt_data->num_vlan);\r\nif (tvlv_value_len < tt_vlan_len)\r\nreturn NET_RX_SUCCESS;\r\ntvlv_value_len -= tt_vlan_len;\r\ntt_num_entries = batadv_tt_entries(tvlv_value_len);\r\nswitch (tt_data->flags & BATADV_TT_DATA_TYPE_MASK) {\r\ncase BATADV_TT_REQUEST:\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TT_REQUEST_RX);\r\nret = batadv_send_tt_response(bat_priv, tt_data, src, dst);\r\nif (!ret) {\r\nif (tt_data->flags & BATADV_TT_FULL_TABLE)\r\ntt_flag = 'F';\r\nelse\r\ntt_flag = '.';\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Routing TT_REQUEST to %pM [%c]\n",\r\ndst, tt_flag);\r\nreturn NET_RX_DROP;\r\n}\r\nbreak;\r\ncase BATADV_TT_RESPONSE:\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TT_RESPONSE_RX);\r\nif (batadv_is_my_mac(bat_priv, dst)) {\r\nbatadv_handle_tt_response(bat_priv, tt_data,\r\nsrc, tt_num_entries);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nif (tt_data->flags & BATADV_TT_FULL_TABLE)\r\ntt_flag = 'F';\r\nelse\r\ntt_flag = '.';\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Routing TT_RESPONSE to %pM [%c]\n", dst, tt_flag);\r\nreturn NET_RX_DROP;\r\n}\r\nreturn NET_RX_SUCCESS;\r\n}\r\nstatic int batadv_roam_tvlv_unicast_handler_v1(struct batadv_priv *bat_priv,\r\nu8 *src, u8 *dst,\r\nvoid *tvlv_value,\r\nu16 tvlv_value_len)\r\n{\r\nstruct batadv_tvlv_roam_adv *roaming_adv;\r\nstruct batadv_orig_node *orig_node = NULL;\r\nif (!batadv_is_my_mac(bat_priv, dst))\r\nreturn NET_RX_DROP;\r\nif (tvlv_value_len < sizeof(*roaming_adv))\r\ngoto out;\r\norig_node = batadv_orig_hash_find(bat_priv, src);\r\nif (!orig_node)\r\ngoto out;\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TT_ROAM_ADV_RX);\r\nroaming_adv = (struct batadv_tvlv_roam_adv *)tvlv_value;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Received ROAMING_ADV from %pM (client %pM)\n",\r\nsrc, roaming_adv->client);\r\nbatadv_tt_global_add(bat_priv, orig_node, roaming_adv->client,\r\nntohs(roaming_adv->vid), BATADV_TT_CLIENT_ROAM,\r\natomic_read(&orig_node->last_ttvn) + 1);\r\nout:\r\nif (orig_node)\r\nbatadv_orig_node_put(orig_node);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nint batadv_tt_init(struct batadv_priv *bat_priv)\r\n{\r\nint ret;\r\nBUILD_BUG_ON(!(BATADV_TT_SYNC_MASK & BATADV_TT_REMOTE_MASK));\r\nret = batadv_tt_local_init(bat_priv);\r\nif (ret < 0)\r\nreturn ret;\r\nret = batadv_tt_global_init(bat_priv);\r\nif (ret < 0)\r\nreturn ret;\r\nbatadv_tvlv_handler_register(bat_priv, batadv_tt_tvlv_ogm_handler_v1,\r\nbatadv_tt_tvlv_unicast_handler_v1,\r\nBATADV_TVLV_TT, 1, BATADV_NO_FLAGS);\r\nbatadv_tvlv_handler_register(bat_priv, NULL,\r\nbatadv_roam_tvlv_unicast_handler_v1,\r\nBATADV_TVLV_ROAM, 1, BATADV_NO_FLAGS);\r\nINIT_DELAYED_WORK(&bat_priv->tt.work, batadv_tt_purge);\r\nqueue_delayed_work(batadv_event_workqueue, &bat_priv->tt.work,\r\nmsecs_to_jiffies(BATADV_TT_WORK_PERIOD));\r\nreturn 1;\r\n}\r\nbool batadv_tt_global_is_isolated(struct batadv_priv *bat_priv,\r\nconst u8 *addr, unsigned short vid)\r\n{\r\nstruct batadv_tt_global_entry *tt;\r\nbool ret;\r\ntt = batadv_tt_global_hash_find(bat_priv, addr, vid);\r\nif (!tt)\r\nreturn false;\r\nret = tt->common.flags & BATADV_TT_CLIENT_ISOLA;\r\nbatadv_tt_global_entry_put(tt);\r\nreturn ret;\r\n}\r\nint __init batadv_tt_cache_init(void)\r\n{\r\nsize_t tl_size = sizeof(struct batadv_tt_local_entry);\r\nsize_t tg_size = sizeof(struct batadv_tt_global_entry);\r\nsize_t tt_orig_size = sizeof(struct batadv_tt_orig_list_entry);\r\nsize_t tt_change_size = sizeof(struct batadv_tt_change_node);\r\nsize_t tt_req_size = sizeof(struct batadv_tt_req_node);\r\nsize_t tt_roam_size = sizeof(struct batadv_tt_roam_node);\r\nbatadv_tl_cache = kmem_cache_create("batadv_tl_cache", tl_size, 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!batadv_tl_cache)\r\nreturn -ENOMEM;\r\nbatadv_tg_cache = kmem_cache_create("batadv_tg_cache", tg_size, 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!batadv_tg_cache)\r\ngoto err_tt_tl_destroy;\r\nbatadv_tt_orig_cache = kmem_cache_create("batadv_tt_orig_cache",\r\ntt_orig_size, 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!batadv_tt_orig_cache)\r\ngoto err_tt_tg_destroy;\r\nbatadv_tt_change_cache = kmem_cache_create("batadv_tt_change_cache",\r\ntt_change_size, 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!batadv_tt_change_cache)\r\ngoto err_tt_orig_destroy;\r\nbatadv_tt_req_cache = kmem_cache_create("batadv_tt_req_cache",\r\ntt_req_size, 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!batadv_tt_req_cache)\r\ngoto err_tt_change_destroy;\r\nbatadv_tt_roam_cache = kmem_cache_create("batadv_tt_roam_cache",\r\ntt_roam_size, 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!batadv_tt_roam_cache)\r\ngoto err_tt_req_destroy;\r\nreturn 0;\r\nerr_tt_req_destroy:\r\nkmem_cache_destroy(batadv_tt_req_cache);\r\nbatadv_tt_req_cache = NULL;\r\nerr_tt_change_destroy:\r\nkmem_cache_destroy(batadv_tt_change_cache);\r\nbatadv_tt_change_cache = NULL;\r\nerr_tt_orig_destroy:\r\nkmem_cache_destroy(batadv_tt_orig_cache);\r\nbatadv_tt_orig_cache = NULL;\r\nerr_tt_tg_destroy:\r\nkmem_cache_destroy(batadv_tg_cache);\r\nbatadv_tg_cache = NULL;\r\nerr_tt_tl_destroy:\r\nkmem_cache_destroy(batadv_tl_cache);\r\nbatadv_tl_cache = NULL;\r\nreturn -ENOMEM;\r\n}\r\nvoid batadv_tt_cache_destroy(void)\r\n{\r\nkmem_cache_destroy(batadv_tl_cache);\r\nkmem_cache_destroy(batadv_tg_cache);\r\nkmem_cache_destroy(batadv_tt_orig_cache);\r\nkmem_cache_destroy(batadv_tt_change_cache);\r\nkmem_cache_destroy(batadv_tt_req_cache);\r\nkmem_cache_destroy(batadv_tt_roam_cache);\r\n}
