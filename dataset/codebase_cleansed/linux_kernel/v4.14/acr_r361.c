static void\r\nacr_r361_generate_flcn_bl_desc(const struct nvkm_acr *acr,\r\nconst struct ls_ucode_img *img, u64 wpr_addr,\r\nvoid *_desc)\r\n{\r\nstruct acr_r361_flcn_bl_desc *desc = _desc;\r\nconst struct ls_ucode_img_desc *pdesc = &img->ucode_desc;\r\nu64 base, addr_code, addr_data;\r\nbase = wpr_addr + img->ucode_off + pdesc->app_start_offset;\r\naddr_code = base + pdesc->app_resident_code_offset;\r\naddr_data = base + pdesc->app_resident_data_offset;\r\ndesc->ctx_dma = FALCON_DMAIDX_UCODE;\r\ndesc->code_dma_base = u64_to_flcn64(addr_code);\r\ndesc->non_sec_code_off = pdesc->app_resident_code_offset;\r\ndesc->non_sec_code_size = pdesc->app_resident_code_size;\r\ndesc->code_entry_point = pdesc->app_imem_entry;\r\ndesc->data_dma_base = u64_to_flcn64(addr_data);\r\ndesc->data_size = pdesc->app_resident_data_size;\r\n}\r\nvoid\r\nacr_r361_generate_hs_bl_desc(const struct hsf_load_header *hdr, void *_bl_desc,\r\nu64 offset)\r\n{\r\nstruct acr_r361_flcn_bl_desc *bl_desc = _bl_desc;\r\nbl_desc->ctx_dma = FALCON_DMAIDX_VIRT;\r\nbl_desc->code_dma_base = u64_to_flcn64(offset);\r\nbl_desc->non_sec_code_off = hdr->non_sec_code_off;\r\nbl_desc->non_sec_code_size = hdr->non_sec_code_size;\r\nbl_desc->sec_code_off = hsf_load_header_app_off(hdr, 0);\r\nbl_desc->sec_code_size = hsf_load_header_app_size(hdr, 0);\r\nbl_desc->code_entry_point = 0;\r\nbl_desc->data_dma_base = u64_to_flcn64(offset + hdr->data_dma_base);\r\nbl_desc->data_size = hdr->data_size;\r\n}\r\nstatic void\r\nacr_r361_generate_pmu_bl_desc(const struct nvkm_acr *acr,\r\nconst struct ls_ucode_img *img, u64 wpr_addr,\r\nvoid *_desc)\r\n{\r\nconst struct ls_ucode_img_desc *pdesc = &img->ucode_desc;\r\nconst struct nvkm_pmu *pmu = acr->subdev->device->pmu;\r\nstruct acr_r361_pmu_bl_desc *desc = _desc;\r\nu64 base, addr_code, addr_data;\r\nu32 addr_args;\r\nbase = wpr_addr + img->ucode_off + pdesc->app_start_offset;\r\naddr_code = base + pdesc->app_resident_code_offset;\r\naddr_data = base + pdesc->app_resident_data_offset;\r\naddr_args = pmu->falcon->data.limit;\r\naddr_args -= NVKM_MSGQUEUE_CMDLINE_SIZE;\r\ndesc->dma_idx = FALCON_DMAIDX_UCODE;\r\ndesc->code_dma_base = u64_to_flcn64(addr_code);\r\ndesc->total_code_size = pdesc->app_size;\r\ndesc->code_size_to_load = pdesc->app_resident_code_size;\r\ndesc->code_entry_point = pdesc->app_imem_entry;\r\ndesc->data_dma_base = u64_to_flcn64(addr_data);\r\ndesc->data_size = pdesc->app_resident_data_size;\r\ndesc->overlay_dma_base = u64_to_flcn64(addr_code);\r\ndesc->argc = 1;\r\ndesc->argv = addr_args;\r\n}\r\nstatic void\r\nacr_r361_generate_sec2_bl_desc(const struct nvkm_acr *acr,\r\nconst struct ls_ucode_img *img, u64 wpr_addr,\r\nvoid *_desc)\r\n{\r\nconst struct ls_ucode_img_desc *pdesc = &img->ucode_desc;\r\nconst struct nvkm_sec2 *sec = acr->subdev->device->sec2;\r\nstruct acr_r361_pmu_bl_desc *desc = _desc;\r\nu64 base, addr_code, addr_data;\r\nu32 addr_args;\r\nbase = wpr_addr + img->ucode_off + pdesc->app_start_offset;\r\naddr_code = base;\r\naddr_data = base + pdesc->app_resident_data_offset;\r\naddr_args = sec->falcon->data.limit;\r\naddr_args -= NVKM_MSGQUEUE_CMDLINE_SIZE;\r\ndesc->dma_idx = FALCON_SEC2_DMAIDX_UCODE;\r\ndesc->code_dma_base = u64_to_flcn64(addr_code);\r\ndesc->total_code_size = pdesc->app_size;\r\ndesc->code_size_to_load = pdesc->app_resident_code_size;\r\ndesc->code_entry_point = pdesc->app_imem_entry;\r\ndesc->data_dma_base = u64_to_flcn64(addr_data);\r\ndesc->data_size = pdesc->app_resident_data_size;\r\ndesc->overlay_dma_base = u64_to_flcn64(addr_code);\r\ndesc->argc = 1;\r\ndesc->argv = 0x01000000;\r\n}\r\nstruct nvkm_acr *\r\nacr_r361_new(unsigned long managed_falcons)\r\n{\r\nreturn acr_r352_new_(&acr_r361_func, NVKM_SECBOOT_FALCON_PMU,\r\nmanaged_falcons);\r\n}
