static void dwmac100_core_init(struct mac_device_info *hw, int mtu)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nu32 value = readl(ioaddr + MAC_CONTROL);\r\nwritel((value | MAC_CORE_INIT), ioaddr + MAC_CONTROL);\r\n#ifdef STMMAC_VLAN_TAG_USED\r\nwritel(ETH_P_8021Q, ioaddr + MAC_VLAN1);\r\n#endif\r\n}\r\nstatic void dwmac100_dump_mac_regs(struct mac_device_info *hw, u32 *reg_space)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nreg_space[MAC_CONTROL / 4] = readl(ioaddr + MAC_CONTROL);\r\nreg_space[MAC_ADDR_HIGH / 4] = readl(ioaddr + MAC_ADDR_HIGH);\r\nreg_space[MAC_ADDR_LOW / 4] = readl(ioaddr + MAC_ADDR_LOW);\r\nreg_space[MAC_HASH_HIGH / 4] = readl(ioaddr + MAC_HASH_HIGH);\r\nreg_space[MAC_HASH_LOW / 4] = readl(ioaddr + MAC_HASH_LOW);\r\nreg_space[MAC_FLOW_CTRL / 4] = readl(ioaddr + MAC_FLOW_CTRL);\r\nreg_space[MAC_VLAN1 / 4] = readl(ioaddr + MAC_VLAN1);\r\nreg_space[MAC_VLAN2 / 4] = readl(ioaddr + MAC_VLAN2);\r\n}\r\nstatic int dwmac100_rx_ipc_enable(struct mac_device_info *hw)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dwmac100_irq_status(struct mac_device_info *hw,\r\nstruct stmmac_extra_stats *x)\r\n{\r\nreturn 0;\r\n}\r\nstatic void dwmac100_set_umac_addr(struct mac_device_info *hw,\r\nunsigned char *addr,\r\nunsigned int reg_n)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nstmmac_set_mac_addr(ioaddr, addr, MAC_ADDR_HIGH, MAC_ADDR_LOW);\r\n}\r\nstatic void dwmac100_get_umac_addr(struct mac_device_info *hw,\r\nunsigned char *addr,\r\nunsigned int reg_n)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nstmmac_get_mac_addr(ioaddr, addr, MAC_ADDR_HIGH, MAC_ADDR_LOW);\r\n}\r\nstatic void dwmac100_set_filter(struct mac_device_info *hw,\r\nstruct net_device *dev)\r\n{\r\nvoid __iomem *ioaddr = (void __iomem *)dev->base_addr;\r\nu32 value = readl(ioaddr + MAC_CONTROL);\r\nif (dev->flags & IFF_PROMISC) {\r\nvalue |= MAC_CONTROL_PR;\r\nvalue &= ~(MAC_CONTROL_PM | MAC_CONTROL_IF | MAC_CONTROL_HO |\r\nMAC_CONTROL_HP);\r\n} else if ((netdev_mc_count(dev) > HASH_TABLE_SIZE)\r\n|| (dev->flags & IFF_ALLMULTI)) {\r\nvalue |= MAC_CONTROL_PM;\r\nvalue &= ~(MAC_CONTROL_PR | MAC_CONTROL_IF | MAC_CONTROL_HO);\r\nwritel(0xffffffff, ioaddr + MAC_HASH_HIGH);\r\nwritel(0xffffffff, ioaddr + MAC_HASH_LOW);\r\n} else if (netdev_mc_empty(dev)) {\r\nvalue &= ~(MAC_CONTROL_PM | MAC_CONTROL_PR | MAC_CONTROL_IF |\r\nMAC_CONTROL_HO | MAC_CONTROL_HP);\r\n} else {\r\nu32 mc_filter[2];\r\nstruct netdev_hw_addr *ha;\r\nvalue |= MAC_CONTROL_HP;\r\nvalue &= ~(MAC_CONTROL_PM | MAC_CONTROL_PR |\r\nMAC_CONTROL_IF | MAC_CONTROL_HO);\r\nmemset(mc_filter, 0, sizeof(mc_filter));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\r\n}\r\nwritel(mc_filter[0], ioaddr + MAC_HASH_LOW);\r\nwritel(mc_filter[1], ioaddr + MAC_HASH_HIGH);\r\n}\r\nwritel(value, ioaddr + MAC_CONTROL);\r\n}\r\nstatic void dwmac100_flow_ctrl(struct mac_device_info *hw, unsigned int duplex,\r\nunsigned int fc, unsigned int pause_time,\r\nu32 tx_cnt)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nunsigned int flow = MAC_FLOW_CTRL_ENABLE;\r\nif (duplex)\r\nflow |= (pause_time << MAC_FLOW_CTRL_PT_SHIFT);\r\nwritel(flow, ioaddr + MAC_FLOW_CTRL);\r\n}\r\nstatic void dwmac100_pmt(struct mac_device_info *hw, unsigned long mode)\r\n{\r\nreturn;\r\n}\r\nstruct mac_device_info *dwmac100_setup(void __iomem *ioaddr, int *synopsys_id)\r\n{\r\nstruct mac_device_info *mac;\r\nmac = kzalloc(sizeof(const struct mac_device_info), GFP_KERNEL);\r\nif (!mac)\r\nreturn NULL;\r\npr_info("\tDWMAC100\n");\r\nmac->pcsr = ioaddr;\r\nmac->mac = &dwmac100_ops;\r\nmac->dma = &dwmac100_dma_ops;\r\nmac->link.duplex = MAC_CONTROL_F;\r\nmac->link.speed10 = 0;\r\nmac->link.speed100 = 0;\r\nmac->link.speed1000 = 0;\r\nmac->link.speed_mask = MAC_CONTROL_PS;\r\nmac->mii.addr = MAC_MII_ADDR;\r\nmac->mii.data = MAC_MII_DATA;\r\nmac->mii.addr_shift = 11;\r\nmac->mii.addr_mask = 0x0000F800;\r\nmac->mii.reg_shift = 6;\r\nmac->mii.reg_mask = 0x000007C0;\r\nmac->mii.clk_csr_shift = 2;\r\nmac->mii.clk_csr_mask = GENMASK(5, 2);\r\n*synopsys_id = 0;\r\nreturn mac;\r\n}
