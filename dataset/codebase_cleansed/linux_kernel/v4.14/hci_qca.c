static void __serial_clock_on(struct tty_struct *tty)\r\n{\r\n}\r\nstatic void __serial_clock_off(struct tty_struct *tty)\r\n{\r\n}\r\nstatic void serial_clock_vote(unsigned long vote, struct hci_uart *hu)\r\n{\r\nstruct qca_data *qca = hu->priv;\r\nunsigned int diff;\r\nbool old_vote = (qca->tx_vote | qca->rx_vote);\r\nbool new_vote;\r\nswitch (vote) {\r\ncase HCI_IBS_VOTE_STATS_UPDATE:\r\ndiff = jiffies_to_msecs(jiffies - qca->vote_last_jif);\r\nif (old_vote)\r\nqca->vote_off_ms += diff;\r\nelse\r\nqca->vote_on_ms += diff;\r\nreturn;\r\ncase HCI_IBS_TX_VOTE_CLOCK_ON:\r\nqca->tx_vote = true;\r\nqca->tx_votes_on++;\r\nnew_vote = true;\r\nbreak;\r\ncase HCI_IBS_RX_VOTE_CLOCK_ON:\r\nqca->rx_vote = true;\r\nqca->rx_votes_on++;\r\nnew_vote = true;\r\nbreak;\r\ncase HCI_IBS_TX_VOTE_CLOCK_OFF:\r\nqca->tx_vote = false;\r\nqca->tx_votes_off++;\r\nnew_vote = qca->rx_vote | qca->tx_vote;\r\nbreak;\r\ncase HCI_IBS_RX_VOTE_CLOCK_OFF:\r\nqca->rx_vote = false;\r\nqca->rx_votes_off++;\r\nnew_vote = qca->rx_vote | qca->tx_vote;\r\nbreak;\r\ndefault:\r\nBT_ERR("Voting irregularity");\r\nreturn;\r\n}\r\nif (new_vote != old_vote) {\r\nif (new_vote)\r\n__serial_clock_on(hu->tty);\r\nelse\r\n__serial_clock_off(hu->tty);\r\nBT_DBG("Vote serial clock %s(%s)", new_vote ? "true" : "false",\r\nvote ? "true" : "false");\r\ndiff = jiffies_to_msecs(jiffies - qca->vote_last_jif);\r\nif (new_vote) {\r\nqca->votes_on++;\r\nqca->vote_off_ms += diff;\r\n} else {\r\nqca->votes_off++;\r\nqca->vote_on_ms += diff;\r\n}\r\nqca->vote_last_jif = jiffies;\r\n}\r\n}\r\nstatic int send_hci_ibs_cmd(u8 cmd, struct hci_uart *hu)\r\n{\r\nint err = 0;\r\nstruct sk_buff *skb = NULL;\r\nstruct qca_data *qca = hu->priv;\r\nBT_DBG("hu %p send hci ibs cmd 0x%x", hu, cmd);\r\nskb = bt_skb_alloc(1, GFP_ATOMIC);\r\nif (!skb) {\r\nBT_ERR("Failed to allocate memory for HCI_IBS packet");\r\nreturn -ENOMEM;\r\n}\r\nskb_put_u8(skb, cmd);\r\nskb_queue_tail(&qca->txq, skb);\r\nreturn err;\r\n}\r\nstatic void qca_wq_awake_device(struct work_struct *work)\r\n{\r\nstruct qca_data *qca = container_of(work, struct qca_data,\r\nws_awake_device);\r\nstruct hci_uart *hu = qca->hu;\r\nunsigned long retrans_delay;\r\nBT_DBG("hu %p wq awake device", hu);\r\nserial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_ON, hu);\r\nspin_lock(&qca->hci_ibs_lock);\r\nif (send_hci_ibs_cmd(HCI_IBS_WAKE_IND, hu) < 0)\r\nBT_ERR("Failed to send WAKE to device");\r\nqca->ibs_sent_wakes++;\r\nretrans_delay = msecs_to_jiffies(qca->wake_retrans);\r\nmod_timer(&qca->wake_retrans_timer, jiffies + retrans_delay);\r\nspin_unlock(&qca->hci_ibs_lock);\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic void qca_wq_awake_rx(struct work_struct *work)\r\n{\r\nstruct qca_data *qca = container_of(work, struct qca_data,\r\nws_awake_rx);\r\nstruct hci_uart *hu = qca->hu;\r\nBT_DBG("hu %p wq awake rx", hu);\r\nserial_clock_vote(HCI_IBS_RX_VOTE_CLOCK_ON, hu);\r\nspin_lock(&qca->hci_ibs_lock);\r\nqca->rx_ibs_state = HCI_IBS_RX_AWAKE;\r\nif (send_hci_ibs_cmd(HCI_IBS_WAKE_ACK, hu) < 0)\r\nBT_ERR("Failed to acknowledge device wake up");\r\nqca->ibs_sent_wacks++;\r\nspin_unlock(&qca->hci_ibs_lock);\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic void qca_wq_serial_rx_clock_vote_off(struct work_struct *work)\r\n{\r\nstruct qca_data *qca = container_of(work, struct qca_data,\r\nws_rx_vote_off);\r\nstruct hci_uart *hu = qca->hu;\r\nBT_DBG("hu %p rx clock vote off", hu);\r\nserial_clock_vote(HCI_IBS_RX_VOTE_CLOCK_OFF, hu);\r\n}\r\nstatic void qca_wq_serial_tx_clock_vote_off(struct work_struct *work)\r\n{\r\nstruct qca_data *qca = container_of(work, struct qca_data,\r\nws_tx_vote_off);\r\nstruct hci_uart *hu = qca->hu;\r\nBT_DBG("hu %p tx clock vote off", hu);\r\nhci_uart_tx_wakeup(hu);\r\nserial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_OFF, hu);\r\n}\r\nstatic void hci_ibs_tx_idle_timeout(unsigned long arg)\r\n{\r\nstruct hci_uart *hu = (struct hci_uart *)arg;\r\nstruct qca_data *qca = hu->priv;\r\nunsigned long flags;\r\nBT_DBG("hu %p idle timeout in %d state", hu, qca->tx_ibs_state);\r\nspin_lock_irqsave_nested(&qca->hci_ibs_lock,\r\nflags, SINGLE_DEPTH_NESTING);\r\nswitch (qca->tx_ibs_state) {\r\ncase HCI_IBS_TX_AWAKE:\r\nif (send_hci_ibs_cmd(HCI_IBS_SLEEP_IND, hu) < 0) {\r\nBT_ERR("Failed to send SLEEP to device");\r\nbreak;\r\n}\r\nqca->tx_ibs_state = HCI_IBS_TX_ASLEEP;\r\nqca->ibs_sent_slps++;\r\nqueue_work(qca->workqueue, &qca->ws_tx_vote_off);\r\nbreak;\r\ncase HCI_IBS_TX_ASLEEP:\r\ncase HCI_IBS_TX_WAKING:\r\ndefault:\r\nBT_ERR("Spurious timeout tx state %d", qca->tx_ibs_state);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\r\n}\r\nstatic void hci_ibs_wake_retrans_timeout(unsigned long arg)\r\n{\r\nstruct hci_uart *hu = (struct hci_uart *)arg;\r\nstruct qca_data *qca = hu->priv;\r\nunsigned long flags, retrans_delay;\r\nbool retransmit = false;\r\nBT_DBG("hu %p wake retransmit timeout in %d state",\r\nhu, qca->tx_ibs_state);\r\nspin_lock_irqsave_nested(&qca->hci_ibs_lock,\r\nflags, SINGLE_DEPTH_NESTING);\r\nswitch (qca->tx_ibs_state) {\r\ncase HCI_IBS_TX_WAKING:\r\nretransmit = true;\r\nif (send_hci_ibs_cmd(HCI_IBS_WAKE_IND, hu) < 0) {\r\nBT_ERR("Failed to acknowledge device wake up");\r\nbreak;\r\n}\r\nqca->ibs_sent_wakes++;\r\nretrans_delay = msecs_to_jiffies(qca->wake_retrans);\r\nmod_timer(&qca->wake_retrans_timer, jiffies + retrans_delay);\r\nbreak;\r\ncase HCI_IBS_TX_ASLEEP:\r\ncase HCI_IBS_TX_AWAKE:\r\ndefault:\r\nBT_ERR("Spurious timeout tx state %d", qca->tx_ibs_state);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\r\nif (retransmit)\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic int qca_open(struct hci_uart *hu)\r\n{\r\nstruct qca_data *qca;\r\nBT_DBG("hu %p qca_open", hu);\r\nqca = kzalloc(sizeof(struct qca_data), GFP_ATOMIC);\r\nif (!qca)\r\nreturn -ENOMEM;\r\nskb_queue_head_init(&qca->txq);\r\nskb_queue_head_init(&qca->tx_wait_q);\r\nspin_lock_init(&qca->hci_ibs_lock);\r\nqca->workqueue = alloc_ordered_workqueue("qca_wq", 0);\r\nif (!qca->workqueue) {\r\nBT_ERR("QCA Workqueue not initialized properly");\r\nkfree(qca);\r\nreturn -ENOMEM;\r\n}\r\nINIT_WORK(&qca->ws_awake_rx, qca_wq_awake_rx);\r\nINIT_WORK(&qca->ws_awake_device, qca_wq_awake_device);\r\nINIT_WORK(&qca->ws_rx_vote_off, qca_wq_serial_rx_clock_vote_off);\r\nINIT_WORK(&qca->ws_tx_vote_off, qca_wq_serial_tx_clock_vote_off);\r\nqca->hu = hu;\r\nqca->tx_ibs_state = HCI_IBS_TX_ASLEEP;\r\nqca->rx_ibs_state = HCI_IBS_RX_ASLEEP;\r\nqca->tx_vote = false;\r\nqca->rx_vote = false;\r\nqca->flags = 0;\r\nqca->ibs_sent_wacks = 0;\r\nqca->ibs_sent_slps = 0;\r\nqca->ibs_sent_wakes = 0;\r\nqca->ibs_recv_wacks = 0;\r\nqca->ibs_recv_slps = 0;\r\nqca->ibs_recv_wakes = 0;\r\nqca->vote_last_jif = jiffies;\r\nqca->vote_on_ms = 0;\r\nqca->vote_off_ms = 0;\r\nqca->votes_on = 0;\r\nqca->votes_off = 0;\r\nqca->tx_votes_on = 0;\r\nqca->tx_votes_off = 0;\r\nqca->rx_votes_on = 0;\r\nqca->rx_votes_off = 0;\r\nhu->priv = qca;\r\nsetup_timer(&qca->wake_retrans_timer, hci_ibs_wake_retrans_timeout,\r\n(u_long)hu);\r\nqca->wake_retrans = IBS_WAKE_RETRANS_TIMEOUT_MS;\r\nsetup_timer(&qca->tx_idle_timer, hci_ibs_tx_idle_timeout, (u_long)hu);\r\nqca->tx_idle_delay = IBS_TX_IDLE_TIMEOUT_MS;\r\nBT_DBG("HCI_UART_QCA open, tx_idle_delay=%u, wake_retrans=%u",\r\nqca->tx_idle_delay, qca->wake_retrans);\r\nreturn 0;\r\n}\r\nstatic void qca_debugfs_init(struct hci_dev *hdev)\r\n{\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nstruct qca_data *qca = hu->priv;\r\nstruct dentry *ibs_dir;\r\numode_t mode;\r\nif (!hdev->debugfs)\r\nreturn;\r\nibs_dir = debugfs_create_dir("ibs", hdev->debugfs);\r\nmode = S_IRUGO;\r\ndebugfs_create_u8("tx_ibs_state", mode, ibs_dir, &qca->tx_ibs_state);\r\ndebugfs_create_u8("rx_ibs_state", mode, ibs_dir, &qca->rx_ibs_state);\r\ndebugfs_create_u64("ibs_sent_sleeps", mode, ibs_dir,\r\n&qca->ibs_sent_slps);\r\ndebugfs_create_u64("ibs_sent_wakes", mode, ibs_dir,\r\n&qca->ibs_sent_wakes);\r\ndebugfs_create_u64("ibs_sent_wake_acks", mode, ibs_dir,\r\n&qca->ibs_sent_wacks);\r\ndebugfs_create_u64("ibs_recv_sleeps", mode, ibs_dir,\r\n&qca->ibs_recv_slps);\r\ndebugfs_create_u64("ibs_recv_wakes", mode, ibs_dir,\r\n&qca->ibs_recv_wakes);\r\ndebugfs_create_u64("ibs_recv_wake_acks", mode, ibs_dir,\r\n&qca->ibs_recv_wacks);\r\ndebugfs_create_bool("tx_vote", mode, ibs_dir, &qca->tx_vote);\r\ndebugfs_create_u64("tx_votes_on", mode, ibs_dir, &qca->tx_votes_on);\r\ndebugfs_create_u64("tx_votes_off", mode, ibs_dir, &qca->tx_votes_off);\r\ndebugfs_create_bool("rx_vote", mode, ibs_dir, &qca->rx_vote);\r\ndebugfs_create_u64("rx_votes_on", mode, ibs_dir, &qca->rx_votes_on);\r\ndebugfs_create_u64("rx_votes_off", mode, ibs_dir, &qca->rx_votes_off);\r\ndebugfs_create_u64("votes_on", mode, ibs_dir, &qca->votes_on);\r\ndebugfs_create_u64("votes_off", mode, ibs_dir, &qca->votes_off);\r\ndebugfs_create_u32("vote_on_ms", mode, ibs_dir, &qca->vote_on_ms);\r\ndebugfs_create_u32("vote_off_ms", mode, ibs_dir, &qca->vote_off_ms);\r\nmode = S_IRUGO | S_IWUSR;\r\ndebugfs_create_u32("wake_retrans", mode, ibs_dir, &qca->wake_retrans);\r\ndebugfs_create_u32("tx_idle_delay", mode, ibs_dir,\r\n&qca->tx_idle_delay);\r\n}\r\nstatic int qca_flush(struct hci_uart *hu)\r\n{\r\nstruct qca_data *qca = hu->priv;\r\nBT_DBG("hu %p qca flush", hu);\r\nskb_queue_purge(&qca->tx_wait_q);\r\nskb_queue_purge(&qca->txq);\r\nreturn 0;\r\n}\r\nstatic int qca_close(struct hci_uart *hu)\r\n{\r\nstruct qca_data *qca = hu->priv;\r\nBT_DBG("hu %p qca close", hu);\r\nserial_clock_vote(HCI_IBS_VOTE_STATS_UPDATE, hu);\r\nskb_queue_purge(&qca->tx_wait_q);\r\nskb_queue_purge(&qca->txq);\r\ndel_timer(&qca->tx_idle_timer);\r\ndel_timer(&qca->wake_retrans_timer);\r\ndestroy_workqueue(qca->workqueue);\r\nqca->hu = NULL;\r\nkfree_skb(qca->rx_skb);\r\nhu->priv = NULL;\r\nkfree(qca);\r\nreturn 0;\r\n}\r\nstatic void device_want_to_wakeup(struct hci_uart *hu)\r\n{\r\nunsigned long flags;\r\nstruct qca_data *qca = hu->priv;\r\nBT_DBG("hu %p want to wake up", hu);\r\nspin_lock_irqsave(&qca->hci_ibs_lock, flags);\r\nqca->ibs_recv_wakes++;\r\nswitch (qca->rx_ibs_state) {\r\ncase HCI_IBS_RX_ASLEEP:\r\nqueue_work(qca->workqueue, &qca->ws_awake_rx);\r\nspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\r\nreturn;\r\ncase HCI_IBS_RX_AWAKE:\r\nif (send_hci_ibs_cmd(HCI_IBS_WAKE_ACK, hu) < 0) {\r\nBT_ERR("Failed to acknowledge device wake up");\r\nbreak;\r\n}\r\nqca->ibs_sent_wacks++;\r\nbreak;\r\ndefault:\r\nBT_ERR("Received HCI_IBS_WAKE_IND in rx state %d",\r\nqca->rx_ibs_state);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic void device_want_to_sleep(struct hci_uart *hu)\r\n{\r\nunsigned long flags;\r\nstruct qca_data *qca = hu->priv;\r\nBT_DBG("hu %p want to sleep", hu);\r\nspin_lock_irqsave(&qca->hci_ibs_lock, flags);\r\nqca->ibs_recv_slps++;\r\nswitch (qca->rx_ibs_state) {\r\ncase HCI_IBS_RX_AWAKE:\r\nqca->rx_ibs_state = HCI_IBS_RX_ASLEEP;\r\nqueue_work(qca->workqueue, &qca->ws_rx_vote_off);\r\nbreak;\r\ncase HCI_IBS_RX_ASLEEP:\r\ndefault:\r\nBT_ERR("Received HCI_IBS_SLEEP_IND in rx state %d",\r\nqca->rx_ibs_state);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\r\n}\r\nstatic void device_woke_up(struct hci_uart *hu)\r\n{\r\nunsigned long flags, idle_delay;\r\nstruct qca_data *qca = hu->priv;\r\nstruct sk_buff *skb = NULL;\r\nBT_DBG("hu %p woke up", hu);\r\nspin_lock_irqsave(&qca->hci_ibs_lock, flags);\r\nqca->ibs_recv_wacks++;\r\nswitch (qca->tx_ibs_state) {\r\ncase HCI_IBS_TX_AWAKE:\r\nBT_DBG("Received HCI_IBS_WAKE_ACK in tx state %d",\r\nqca->tx_ibs_state);\r\nbreak;\r\ncase HCI_IBS_TX_WAKING:\r\nwhile ((skb = skb_dequeue(&qca->tx_wait_q)))\r\nskb_queue_tail(&qca->txq, skb);\r\ndel_timer(&qca->wake_retrans_timer);\r\nidle_delay = msecs_to_jiffies(qca->tx_idle_delay);\r\nmod_timer(&qca->tx_idle_timer, jiffies + idle_delay);\r\nqca->tx_ibs_state = HCI_IBS_TX_AWAKE;\r\nbreak;\r\ncase HCI_IBS_TX_ASLEEP:\r\ndefault:\r\nBT_ERR("Received HCI_IBS_WAKE_ACK in tx state %d",\r\nqca->tx_ibs_state);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic int qca_enqueue(struct hci_uart *hu, struct sk_buff *skb)\r\n{\r\nunsigned long flags = 0, idle_delay;\r\nstruct qca_data *qca = hu->priv;\r\nBT_DBG("hu %p qca enq skb %p tx_ibs_state %d", hu, skb,\r\nqca->tx_ibs_state);\r\nmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\r\nif (!test_bit(STATE_IN_BAND_SLEEP_ENABLED, &qca->flags)) {\r\nskb_queue_tail(&qca->txq, skb);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&qca->hci_ibs_lock, flags);\r\nswitch (qca->tx_ibs_state) {\r\ncase HCI_IBS_TX_AWAKE:\r\nBT_DBG("Device awake, sending normally");\r\nskb_queue_tail(&qca->txq, skb);\r\nidle_delay = msecs_to_jiffies(qca->tx_idle_delay);\r\nmod_timer(&qca->tx_idle_timer, jiffies + idle_delay);\r\nbreak;\r\ncase HCI_IBS_TX_ASLEEP:\r\nBT_DBG("Device asleep, waking up and queueing packet");\r\nskb_queue_tail(&qca->tx_wait_q, skb);\r\nqca->tx_ibs_state = HCI_IBS_TX_WAKING;\r\nqueue_work(qca->workqueue, &qca->ws_awake_device);\r\nbreak;\r\ncase HCI_IBS_TX_WAKING:\r\nBT_DBG("Device waking up, queueing packet");\r\nskb_queue_tail(&qca->tx_wait_q, skb);\r\nbreak;\r\ndefault:\r\nBT_ERR("Illegal tx state: %d (losing packet)",\r\nqca->tx_ibs_state);\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int qca_ibs_sleep_ind(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nBT_DBG("hu %p recv hci ibs cmd 0x%x", hu, HCI_IBS_SLEEP_IND);\r\ndevice_want_to_sleep(hu);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int qca_ibs_wake_ind(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nBT_DBG("hu %p recv hci ibs cmd 0x%x", hu, HCI_IBS_WAKE_IND);\r\ndevice_want_to_wakeup(hu);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int qca_ibs_wake_ack(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nBT_DBG("hu %p recv hci ibs cmd 0x%x", hu, HCI_IBS_WAKE_ACK);\r\ndevice_woke_up(hu);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int qca_recv(struct hci_uart *hu, const void *data, int count)\r\n{\r\nstruct qca_data *qca = hu->priv;\r\nif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\r\nreturn -EUNATCH;\r\nqca->rx_skb = h4_recv_buf(hu->hdev, qca->rx_skb, data, count,\r\nqca_recv_pkts, ARRAY_SIZE(qca_recv_pkts));\r\nif (IS_ERR(qca->rx_skb)) {\r\nint err = PTR_ERR(qca->rx_skb);\r\nBT_ERR("%s: Frame reassembly failed (%d)", hu->hdev->name, err);\r\nqca->rx_skb = NULL;\r\nreturn err;\r\n}\r\nreturn count;\r\n}\r\nstatic struct sk_buff *qca_dequeue(struct hci_uart *hu)\r\n{\r\nstruct qca_data *qca = hu->priv;\r\nreturn skb_dequeue(&qca->txq);\r\n}\r\nstatic uint8_t qca_get_baudrate_value(int speed)\r\n{\r\nswitch (speed) {\r\ncase 9600:\r\nreturn QCA_BAUDRATE_9600;\r\ncase 19200:\r\nreturn QCA_BAUDRATE_19200;\r\ncase 38400:\r\nreturn QCA_BAUDRATE_38400;\r\ncase 57600:\r\nreturn QCA_BAUDRATE_57600;\r\ncase 115200:\r\nreturn QCA_BAUDRATE_115200;\r\ncase 230400:\r\nreturn QCA_BAUDRATE_230400;\r\ncase 460800:\r\nreturn QCA_BAUDRATE_460800;\r\ncase 500000:\r\nreturn QCA_BAUDRATE_500000;\r\ncase 921600:\r\nreturn QCA_BAUDRATE_921600;\r\ncase 1000000:\r\nreturn QCA_BAUDRATE_1000000;\r\ncase 2000000:\r\nreturn QCA_BAUDRATE_2000000;\r\ncase 3000000:\r\nreturn QCA_BAUDRATE_3000000;\r\ncase 3500000:\r\nreturn QCA_BAUDRATE_3500000;\r\ndefault:\r\nreturn QCA_BAUDRATE_115200;\r\n}\r\n}\r\nstatic int qca_set_baudrate(struct hci_dev *hdev, uint8_t baudrate)\r\n{\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nstruct qca_data *qca = hu->priv;\r\nstruct sk_buff *skb;\r\nu8 cmd[] = { 0x01, 0x48, 0xFC, 0x01, 0x00 };\r\nif (baudrate > QCA_BAUDRATE_3000000)\r\nreturn -EINVAL;\r\ncmd[4] = baudrate;\r\nskb = bt_skb_alloc(sizeof(cmd), GFP_ATOMIC);\r\nif (!skb) {\r\nBT_ERR("Failed to allocate memory for baudrate packet");\r\nreturn -ENOMEM;\r\n}\r\nskb_put_data(skb, cmd, sizeof(cmd));\r\nhci_skb_pkt_type(skb) = HCI_COMMAND_PKT;\r\nskb_queue_tail(&qca->txq, skb);\r\nhci_uart_tx_wakeup(hu);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(msecs_to_jiffies(BAUDRATE_SETTLE_TIMEOUT_MS));\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nreturn 0;\r\n}\r\nstatic int qca_setup(struct hci_uart *hu)\r\n{\r\nstruct hci_dev *hdev = hu->hdev;\r\nstruct qca_data *qca = hu->priv;\r\nunsigned int speed, qca_baudrate = QCA_BAUDRATE_115200;\r\nint ret;\r\nBT_INFO("%s: ROME setup", hdev->name);\r\nclear_bit(STATE_IN_BAND_SLEEP_ENABLED, &qca->flags);\r\nspeed = 0;\r\nif (hu->init_speed)\r\nspeed = hu->init_speed;\r\nelse if (hu->proto->init_speed)\r\nspeed = hu->proto->init_speed;\r\nif (speed)\r\nhci_uart_set_baudrate(hu, speed);\r\nspeed = 0;\r\nif (hu->oper_speed)\r\nspeed = hu->oper_speed;\r\nelse if (hu->proto->oper_speed)\r\nspeed = hu->proto->oper_speed;\r\nif (speed) {\r\nqca_baudrate = qca_get_baudrate_value(speed);\r\nBT_INFO("%s: Set UART speed to %d", hdev->name, speed);\r\nret = qca_set_baudrate(hdev, qca_baudrate);\r\nif (ret) {\r\nBT_ERR("%s: Failed to change the baud rate (%d)",\r\nhdev->name, ret);\r\nreturn ret;\r\n}\r\nhci_uart_set_baudrate(hu, speed);\r\n}\r\nret = qca_uart_setup_rome(hdev, qca_baudrate);\r\nif (!ret) {\r\nset_bit(STATE_IN_BAND_SLEEP_ENABLED, &qca->flags);\r\nqca_debugfs_init(hdev);\r\n}\r\nhu->hdev->set_bdaddr = qca_set_bdaddr_rome;\r\nreturn ret;\r\n}\r\nint __init qca_init(void)\r\n{\r\nreturn hci_uart_register_proto(&qca_proto);\r\n}\r\nint __exit qca_deinit(void)\r\n{\r\nreturn hci_uart_unregister_proto(&qca_proto);\r\n}
