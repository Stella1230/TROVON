static int ina226_reg_to_interval(u16 config)\r\n{\r\nint avg = ina226_avg_tab[INA226_READ_AVG(config)];\r\nreturn DIV_ROUND_CLOSEST(avg * INA226_TOTAL_CONV_TIME_DEFAULT, 1000);\r\n}\r\nstatic u16 ina226_interval_to_reg(int interval)\r\n{\r\nint avg, avg_bits;\r\navg = DIV_ROUND_CLOSEST(interval * 1000,\r\nINA226_TOTAL_CONV_TIME_DEFAULT);\r\navg_bits = find_closest(avg, ina226_avg_tab,\r\nARRAY_SIZE(ina226_avg_tab));\r\nreturn INA226_SHIFT_AVG(avg_bits);\r\n}\r\nstatic int ina2xx_calibrate(struct ina2xx_data *data)\r\n{\r\nu16 val = DIV_ROUND_CLOSEST(data->config->calibration_factor,\r\ndata->rshunt);\r\nreturn regmap_write(data->regmap, INA2XX_CALIBRATION, val);\r\n}\r\nstatic int ina2xx_init(struct ina2xx_data *data)\r\n{\r\nint ret = regmap_write(data->regmap, INA2XX_CONFIG,\r\ndata->config->config_default);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ina2xx_calibrate(data);\r\n}\r\nstatic int ina2xx_read_reg(struct device *dev, int reg, unsigned int *regval)\r\n{\r\nstruct ina2xx_data *data = dev_get_drvdata(dev);\r\nint ret, retry;\r\ndev_dbg(dev, "Starting register %d read\n", reg);\r\nfor (retry = 5; retry; retry--) {\r\nret = regmap_read(data->regmap, reg, regval);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(dev, "read %d, val = 0x%04x\n", reg, *regval);\r\nif (*regval == 0) {\r\nunsigned int cal;\r\nret = regmap_read(data->regmap, INA2XX_CALIBRATION,\r\n&cal);\r\nif (ret < 0)\r\nreturn ret;\r\nif (cal == 0) {\r\ndev_warn(dev, "chip not calibrated, reinitializing\n");\r\nret = ina2xx_init(data);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(INA2XX_MAX_DELAY);\r\ncontinue;\r\n}\r\n}\r\nreturn 0;\r\n}\r\ndev_err(dev, "unable to reinitialize the chip\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int ina2xx_get_value(struct ina2xx_data *data, u8 reg,\r\nunsigned int regval)\r\n{\r\nint val;\r\nswitch (reg) {\r\ncase INA2XX_SHUNT_VOLTAGE:\r\nval = DIV_ROUND_CLOSEST((s16)regval, data->config->shunt_div);\r\nbreak;\r\ncase INA2XX_BUS_VOLTAGE:\r\nval = (regval >> data->config->bus_voltage_shift)\r\n* data->config->bus_voltage_lsb;\r\nval = DIV_ROUND_CLOSEST(val, 1000);\r\nbreak;\r\ncase INA2XX_POWER:\r\nval = regval * data->config->power_lsb;\r\nbreak;\r\ncase INA2XX_CURRENT:\r\nval = (s16)regval;\r\nbreak;\r\ncase INA2XX_CALIBRATION:\r\nval = DIV_ROUND_CLOSEST(data->config->calibration_factor,\r\nregval);\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nval = 0;\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nstatic ssize_t ina2xx_show_value(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct ina2xx_data *data = dev_get_drvdata(dev);\r\nunsigned int regval;\r\nint err = ina2xx_read_reg(dev, attr->index, &regval);\r\nif (err < 0)\r\nreturn err;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\nina2xx_get_value(data, attr->index, regval));\r\n}\r\nstatic ssize_t ina2xx_set_shunt(struct device *dev,\r\nstruct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long val;\r\nint status;\r\nstruct ina2xx_data *data = dev_get_drvdata(dev);\r\nstatus = kstrtoul(buf, 10, &val);\r\nif (status < 0)\r\nreturn status;\r\nif (val == 0 ||\r\nval > data->config->calibration_factor)\r\nreturn -EINVAL;\r\nmutex_lock(&data->config_lock);\r\ndata->rshunt = val;\r\nstatus = ina2xx_calibrate(data);\r\nmutex_unlock(&data->config_lock);\r\nif (status < 0)\r\nreturn status;\r\nreturn count;\r\n}\r\nstatic ssize_t ina226_set_interval(struct device *dev,\r\nstruct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ina2xx_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint status;\r\nstatus = kstrtoul(buf, 10, &val);\r\nif (status < 0)\r\nreturn status;\r\nif (val > INT_MAX || val == 0)\r\nreturn -EINVAL;\r\nstatus = regmap_update_bits(data->regmap, INA2XX_CONFIG,\r\nINA226_AVG_RD_MASK,\r\nina226_interval_to_reg(val));\r\nif (status < 0)\r\nreturn status;\r\nreturn count;\r\n}\r\nstatic ssize_t ina226_show_interval(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct ina2xx_data *data = dev_get_drvdata(dev);\r\nint status;\r\nunsigned int regval;\r\nstatus = regmap_read(data->regmap, INA2XX_CONFIG, &regval);\r\nif (status)\r\nreturn status;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ina226_reg_to_interval(regval));\r\n}\r\nstatic int ina2xx_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct ina2xx_data *data;\r\nstruct device *hwmon_dev;\r\nu32 val;\r\nint ret, group = 0;\r\nenum ina2xx_ids chip;\r\nif (client->dev.of_node)\r\nchip = (enum ina2xx_ids)of_device_get_match_data(&client->dev);\r\nelse\r\nchip = id->driver_data;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->config = &ina2xx_config[chip];\r\nif (of_property_read_u32(dev->of_node, "shunt-resistor", &val) < 0) {\r\nstruct ina2xx_platform_data *pdata = dev_get_platdata(dev);\r\nif (pdata)\r\nval = pdata->shunt_uohms;\r\nelse\r\nval = INA2XX_RSHUNT_DEFAULT;\r\n}\r\nif (val <= 0 || val > data->config->calibration_factor)\r\nreturn -ENODEV;\r\ndata->rshunt = val;\r\nina2xx_regmap_config.max_register = data->config->registers;\r\ndata->regmap = devm_regmap_init_i2c(client, &ina2xx_regmap_config);\r\nif (IS_ERR(data->regmap)) {\r\ndev_err(dev, "failed to allocate register map\n");\r\nreturn PTR_ERR(data->regmap);\r\n}\r\nret = ina2xx_init(data);\r\nif (ret < 0) {\r\ndev_err(dev, "error configuring the device: %d\n", ret);\r\nreturn -ENODEV;\r\n}\r\nmutex_init(&data->config_lock);\r\ndata->groups[group++] = &ina2xx_group;\r\nif (id->driver_data == ina226)\r\ndata->groups[group++] = &ina226_group;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\r\ndata, data->groups);\r\nif (IS_ERR(hwmon_dev))\r\nreturn PTR_ERR(hwmon_dev);\r\ndev_info(dev, "power monitor %s (Rshunt = %li uOhm)\n",\r\nid->name, data->rshunt);\r\nreturn 0;\r\n}
