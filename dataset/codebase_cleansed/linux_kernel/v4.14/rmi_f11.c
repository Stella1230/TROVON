static void rmi_f11_rel_pos_report(struct f11_data *f11, u8 n_finger)\r\n{\r\nstruct rmi_2d_sensor *sensor = &f11->sensor;\r\nstruct f11_2d_data *data = &f11->data;\r\ns8 x, y;\r\nx = data->rel_pos[n_finger * RMI_F11_REL_BYTES];\r\ny = data->rel_pos[n_finger * RMI_F11_REL_BYTES + 1];\r\nrmi_2d_sensor_rel_report(sensor, x, y);\r\n}\r\nstatic void rmi_f11_abs_pos_process(struct f11_data *f11,\r\nstruct rmi_2d_sensor *sensor,\r\nstruct rmi_2d_sensor_abs_object *obj,\r\nenum f11_finger_state finger_state,\r\nu8 n_finger)\r\n{\r\nstruct f11_2d_data *data = &f11->data;\r\nu8 *pos_data = &data->abs_pos[n_finger * RMI_F11_ABS_BYTES];\r\nint tool_type = MT_TOOL_FINGER;\r\nswitch (finger_state) {\r\ncase F11_PRESENT:\r\nobj->type = RMI_2D_OBJECT_FINGER;\r\nbreak;\r\ndefault:\r\nobj->type = RMI_2D_OBJECT_NONE;\r\n}\r\nobj->mt_tool = tool_type;\r\nobj->x = (pos_data[0] << 4) | (pos_data[2] & 0x0F);\r\nobj->y = (pos_data[1] << 4) | (pos_data[2] >> 4);\r\nobj->z = pos_data[4];\r\nobj->wx = pos_data[3] & 0x0f;\r\nobj->wy = pos_data[3] >> 4;\r\nrmi_2d_sensor_abs_process(sensor, obj, n_finger);\r\n}\r\nstatic inline u8 rmi_f11_parse_finger_state(const u8 *f_state, u8 n_finger)\r\n{\r\nreturn (f_state[n_finger / 4] >> (2 * (n_finger % 4))) &\r\nFINGER_STATE_MASK;\r\n}\r\nstatic void rmi_f11_finger_handler(struct f11_data *f11,\r\nstruct rmi_2d_sensor *sensor,\r\nunsigned long *irq_bits, int num_irq_regs,\r\nint size)\r\n{\r\nconst u8 *f_state = f11->data.f_state;\r\nu8 finger_state;\r\nu8 i;\r\nint abs_fingers;\r\nint rel_fingers;\r\nint abs_size = sensor->nbr_fingers * RMI_F11_ABS_BYTES;\r\nint abs_bits = bitmap_and(f11->result_bits, irq_bits, f11->abs_mask,\r\nnum_irq_regs * 8);\r\nint rel_bits = bitmap_and(f11->result_bits, irq_bits, f11->rel_mask,\r\nnum_irq_regs * 8);\r\nif (abs_bits) {\r\nif (abs_size > size)\r\nabs_fingers = size / RMI_F11_ABS_BYTES;\r\nelse\r\nabs_fingers = sensor->nbr_fingers;\r\nfor (i = 0; i < abs_fingers; i++) {\r\nfinger_state = rmi_f11_parse_finger_state(f_state, i);\r\nif (finger_state == F11_RESERVED) {\r\npr_err("Invalid finger state[%d]: 0x%02x", i,\r\nfinger_state);\r\ncontinue;\r\n}\r\nrmi_f11_abs_pos_process(f11, sensor, &sensor->objs[i],\r\nfinger_state, i);\r\n}\r\n}\r\nif (rel_bits) {\r\nif ((abs_size + sensor->nbr_fingers * RMI_F11_REL_BYTES) > size)\r\nrel_fingers = (size - abs_size) / RMI_F11_REL_BYTES;\r\nelse\r\nrel_fingers = sensor->nbr_fingers;\r\nfor (i = 0; i < rel_fingers; i++)\r\nrmi_f11_rel_pos_report(f11, i);\r\n}\r\nif (abs_bits) {\r\nif (sensor->kernel_tracking)\r\ninput_mt_assign_slots(sensor->input,\r\nsensor->tracking_slots,\r\nsensor->tracking_pos,\r\nsensor->nbr_fingers,\r\nsensor->dmax);\r\nfor (i = 0; i < abs_fingers; i++) {\r\nfinger_state = rmi_f11_parse_finger_state(f_state, i);\r\nif (finger_state == F11_RESERVED)\r\ncontinue;\r\nrmi_2d_sensor_abs_report(sensor, &sensor->objs[i], i);\r\n}\r\ninput_mt_sync_frame(sensor->input);\r\n}\r\n}\r\nstatic int f11_2d_construct_data(struct f11_data *f11)\r\n{\r\nstruct rmi_2d_sensor *sensor = &f11->sensor;\r\nstruct f11_2d_sensor_queries *query = &f11->sens_query;\r\nstruct f11_2d_data *data = &f11->data;\r\nint i;\r\nsensor->nbr_fingers = (query->nr_fingers == 5 ? 10 :\r\nquery->nr_fingers + 1);\r\nsensor->pkt_size = DIV_ROUND_UP(sensor->nbr_fingers, 4);\r\nif (query->has_abs) {\r\nsensor->pkt_size += (sensor->nbr_fingers * 5);\r\nsensor->attn_size = sensor->pkt_size;\r\n}\r\nif (query->has_rel)\r\nsensor->pkt_size += (sensor->nbr_fingers * 2);\r\nif (query->query7_nonzero)\r\nsensor->pkt_size += sizeof(u8);\r\nif (query->query7_nonzero || query->query8_nonzero)\r\nsensor->pkt_size += sizeof(u8);\r\nif (query->has_pinch || query->has_flick || query->has_rotate) {\r\nsensor->pkt_size += 3;\r\nif (!query->has_flick)\r\nsensor->pkt_size--;\r\nif (!query->has_rotate)\r\nsensor->pkt_size--;\r\n}\r\nif (query->has_touch_shapes)\r\nsensor->pkt_size +=\r\nDIV_ROUND_UP(query->nr_touch_shapes + 1, 8);\r\nsensor->data_pkt = devm_kzalloc(&sensor->fn->dev, sensor->pkt_size,\r\nGFP_KERNEL);\r\nif (!sensor->data_pkt)\r\nreturn -ENOMEM;\r\ndata->f_state = sensor->data_pkt;\r\ni = DIV_ROUND_UP(sensor->nbr_fingers, 4);\r\nif (query->has_abs) {\r\ndata->abs_pos = &sensor->data_pkt[i];\r\ni += (sensor->nbr_fingers * RMI_F11_ABS_BYTES);\r\n}\r\nif (query->has_rel) {\r\ndata->rel_pos = &sensor->data_pkt[i];\r\ni += (sensor->nbr_fingers * RMI_F11_REL_BYTES);\r\n}\r\nif (query->query7_nonzero) {\r\ndata->gest_1 = &sensor->data_pkt[i];\r\ni++;\r\n}\r\nif (query->query7_nonzero || query->query8_nonzero) {\r\ndata->gest_2 = &sensor->data_pkt[i];\r\ni++;\r\n}\r\nif (query->has_pinch) {\r\ndata->pinch = &sensor->data_pkt[i];\r\ni++;\r\n}\r\nif (query->has_flick) {\r\nif (query->has_pinch) {\r\ndata->flick = data->pinch;\r\ni += 2;\r\n} else {\r\ndata->flick = &sensor->data_pkt[i];\r\ni += 3;\r\n}\r\n}\r\nif (query->has_rotate) {\r\nif (query->has_flick) {\r\ndata->rotate = data->flick + 1;\r\n} else {\r\ndata->rotate = &sensor->data_pkt[i];\r\ni += 2;\r\n}\r\n}\r\nif (query->has_touch_shapes)\r\ndata->shapes = &sensor->data_pkt[i];\r\nreturn 0;\r\n}\r\nstatic int f11_read_control_regs(struct rmi_function *fn,\r\nstruct f11_2d_ctrl *ctrl, u16 ctrl_base_addr) {\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nint error = 0;\r\nctrl->ctrl0_11_address = ctrl_base_addr;\r\nerror = rmi_read_block(rmi_dev, ctrl_base_addr, ctrl->ctrl0_11,\r\nRMI_F11_CTRL_REG_COUNT);\r\nif (error < 0) {\r\ndev_err(&fn->dev, "Failed to read ctrl0, code: %d.\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int f11_write_control_regs(struct rmi_function *fn,\r\nstruct f11_2d_sensor_queries *query,\r\nstruct f11_2d_ctrl *ctrl,\r\nu16 ctrl_base_addr)\r\n{\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nint error;\r\nerror = rmi_write_block(rmi_dev, ctrl_base_addr, ctrl->ctrl0_11,\r\nRMI_F11_CTRL_REG_COUNT);\r\nif (error < 0)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int rmi_f11_get_query_parameters(struct rmi_device *rmi_dev,\r\nstruct f11_data *f11,\r\nstruct f11_2d_sensor_queries *sensor_query,\r\nu16 query_base_addr)\r\n{\r\nint query_size;\r\nint rc;\r\nu8 query_buf[RMI_F11_QUERY_SIZE];\r\nbool has_query36 = false;\r\nrc = rmi_read_block(rmi_dev, query_base_addr, query_buf,\r\nRMI_F11_QUERY_SIZE);\r\nif (rc < 0)\r\nreturn rc;\r\nsensor_query->nr_fingers = query_buf[0] & RMI_F11_NR_FINGERS_MASK;\r\nsensor_query->has_rel = !!(query_buf[0] & RMI_F11_HAS_REL);\r\nsensor_query->has_abs = !!(query_buf[0] & RMI_F11_HAS_ABS);\r\nsensor_query->has_gestures = !!(query_buf[0] & RMI_F11_HAS_GESTURES);\r\nsensor_query->has_sensitivity_adjust =\r\n!!(query_buf[0] & RMI_F11_HAS_SENSITIVITY_ADJ);\r\nsensor_query->configurable = !!(query_buf[0] & RMI_F11_CONFIGURABLE);\r\nsensor_query->nr_x_electrodes =\r\nquery_buf[1] & RMI_F11_NR_ELECTRODES_MASK;\r\nsensor_query->nr_y_electrodes =\r\nquery_buf[2] & RMI_F11_NR_ELECTRODES_MASK;\r\nsensor_query->max_electrodes =\r\nquery_buf[3] & RMI_F11_NR_ELECTRODES_MASK;\r\nquery_size = RMI_F11_QUERY_SIZE;\r\nif (sensor_query->has_abs) {\r\nrc = rmi_read(rmi_dev, query_base_addr + query_size, query_buf);\r\nif (rc < 0)\r\nreturn rc;\r\nsensor_query->abs_data_size =\r\nquery_buf[0] & RMI_F11_ABS_DATA_SIZE_MASK;\r\nsensor_query->has_anchored_finger =\r\n!!(query_buf[0] & RMI_F11_HAS_ANCHORED_FINGER);\r\nsensor_query->has_adj_hyst =\r\n!!(query_buf[0] & RMI_F11_HAS_ADJ_HYST);\r\nsensor_query->has_dribble =\r\n!!(query_buf[0] & RMI_F11_HAS_DRIBBLE);\r\nsensor_query->has_bending_correction =\r\n!!(query_buf[0] & RMI_F11_HAS_BENDING_CORRECTION);\r\nsensor_query->has_large_object_suppression =\r\n!!(query_buf[0] & RMI_F11_HAS_LARGE_OBJECT_SUPPRESSION);\r\nsensor_query->has_jitter_filter =\r\n!!(query_buf[0] & RMI_F11_HAS_JITTER_FILTER);\r\nquery_size++;\r\n}\r\nif (sensor_query->has_rel) {\r\nrc = rmi_read(rmi_dev, query_base_addr + query_size,\r\n&sensor_query->f11_2d_query6);\r\nif (rc < 0)\r\nreturn rc;\r\nquery_size++;\r\n}\r\nif (sensor_query->has_gestures) {\r\nrc = rmi_read_block(rmi_dev, query_base_addr + query_size,\r\nquery_buf, RMI_F11_QUERY_GESTURE_SIZE);\r\nif (rc < 0)\r\nreturn rc;\r\nsensor_query->has_single_tap =\r\n!!(query_buf[0] & RMI_F11_HAS_SINGLE_TAP);\r\nsensor_query->has_tap_n_hold =\r\n!!(query_buf[0] & RMI_F11_HAS_TAP_AND_HOLD);\r\nsensor_query->has_double_tap =\r\n!!(query_buf[0] & RMI_F11_HAS_DOUBLE_TAP);\r\nsensor_query->has_early_tap =\r\n!!(query_buf[0] & RMI_F11_HAS_EARLY_TAP);\r\nsensor_query->has_flick =\r\n!!(query_buf[0] & RMI_F11_HAS_FLICK);\r\nsensor_query->has_press =\r\n!!(query_buf[0] & RMI_F11_HAS_PRESS);\r\nsensor_query->has_pinch =\r\n!!(query_buf[0] & RMI_F11_HAS_PINCH);\r\nsensor_query->has_chiral =\r\n!!(query_buf[0] & RMI_F11_HAS_CHIRAL);\r\nsensor_query->has_palm_det =\r\n!!(query_buf[1] & RMI_F11_HAS_PALM_DET);\r\nsensor_query->has_rotate =\r\n!!(query_buf[1] & RMI_F11_HAS_ROTATE);\r\nsensor_query->has_touch_shapes =\r\n!!(query_buf[1] & RMI_F11_HAS_TOUCH_SHAPES);\r\nsensor_query->has_scroll_zones =\r\n!!(query_buf[1] & RMI_F11_HAS_SCROLL_ZONES);\r\nsensor_query->has_individual_scroll_zones =\r\n!!(query_buf[1] & RMI_F11_HAS_INDIVIDUAL_SCROLL_ZONES);\r\nsensor_query->has_mf_scroll =\r\n!!(query_buf[1] & RMI_F11_HAS_MF_SCROLL);\r\nsensor_query->has_mf_edge_motion =\r\n!!(query_buf[1] & RMI_F11_HAS_MF_EDGE_MOTION);\r\nsensor_query->has_mf_scroll_inertia =\r\n!!(query_buf[1] & RMI_F11_HAS_MF_SCROLL_INERTIA);\r\nsensor_query->query7_nonzero = !!(query_buf[0]);\r\nsensor_query->query8_nonzero = !!(query_buf[1]);\r\nquery_size += 2;\r\n}\r\nif (f11->has_query9) {\r\nrc = rmi_read(rmi_dev, query_base_addr + query_size, query_buf);\r\nif (rc < 0)\r\nreturn rc;\r\nsensor_query->has_pen =\r\n!!(query_buf[0] & RMI_F11_HAS_PEN);\r\nsensor_query->has_proximity =\r\n!!(query_buf[0] & RMI_F11_HAS_PROXIMITY);\r\nsensor_query->has_palm_det_sensitivity =\r\n!!(query_buf[0] & RMI_F11_HAS_PALM_DET_SENSITIVITY);\r\nsensor_query->has_suppress_on_palm_detect =\r\n!!(query_buf[0] & RMI_F11_HAS_SUPPRESS_ON_PALM_DETECT);\r\nsensor_query->has_two_pen_thresholds =\r\n!!(query_buf[0] & RMI_F11_HAS_TWO_PEN_THRESHOLDS);\r\nsensor_query->has_contact_geometry =\r\n!!(query_buf[0] & RMI_F11_HAS_CONTACT_GEOMETRY);\r\nsensor_query->has_pen_hover_discrimination =\r\n!!(query_buf[0] & RMI_F11_HAS_PEN_HOVER_DISCRIMINATION);\r\nsensor_query->has_pen_filters =\r\n!!(query_buf[0] & RMI_F11_HAS_PEN_FILTERS);\r\nquery_size++;\r\n}\r\nif (sensor_query->has_touch_shapes) {\r\nrc = rmi_read(rmi_dev, query_base_addr + query_size, query_buf);\r\nif (rc < 0)\r\nreturn rc;\r\nsensor_query->nr_touch_shapes = query_buf[0] &\r\nRMI_F11_NR_TOUCH_SHAPES_MASK;\r\nquery_size++;\r\n}\r\nif (f11->has_query11) {\r\nrc = rmi_read(rmi_dev, query_base_addr + query_size, query_buf);\r\nif (rc < 0)\r\nreturn rc;\r\nsensor_query->has_z_tuning =\r\n!!(query_buf[0] & RMI_F11_HAS_Z_TUNING);\r\nsensor_query->has_algorithm_selection =\r\n!!(query_buf[0] & RMI_F11_HAS_ALGORITHM_SELECTION);\r\nsensor_query->has_w_tuning =\r\n!!(query_buf[0] & RMI_F11_HAS_W_TUNING);\r\nsensor_query->has_pitch_info =\r\n!!(query_buf[0] & RMI_F11_HAS_PITCH_INFO);\r\nsensor_query->has_finger_size =\r\n!!(query_buf[0] & RMI_F11_HAS_FINGER_SIZE);\r\nsensor_query->has_segmentation_aggressiveness =\r\n!!(query_buf[0] &\r\nRMI_F11_HAS_SEGMENTATION_AGGRESSIVENESS);\r\nsensor_query->has_XY_clip =\r\n!!(query_buf[0] & RMI_F11_HAS_XY_CLIP);\r\nsensor_query->has_drumming_filter =\r\n!!(query_buf[0] & RMI_F11_HAS_DRUMMING_FILTER);\r\nquery_size++;\r\n}\r\nif (f11->has_query12) {\r\nrc = rmi_read(rmi_dev, query_base_addr + query_size, query_buf);\r\nif (rc < 0)\r\nreturn rc;\r\nsensor_query->has_gapless_finger =\r\n!!(query_buf[0] & RMI_F11_HAS_GAPLESS_FINGER);\r\nsensor_query->has_gapless_finger_tuning =\r\n!!(query_buf[0] & RMI_F11_HAS_GAPLESS_FINGER_TUNING);\r\nsensor_query->has_8bit_w =\r\n!!(query_buf[0] & RMI_F11_HAS_8BIT_W);\r\nsensor_query->has_adjustable_mapping =\r\n!!(query_buf[0] & RMI_F11_HAS_ADJUSTABLE_MAPPING);\r\nsensor_query->has_info2 =\r\n!!(query_buf[0] & RMI_F11_HAS_INFO2);\r\nsensor_query->has_physical_props =\r\n!!(query_buf[0] & RMI_F11_HAS_PHYSICAL_PROPS);\r\nsensor_query->has_finger_limit =\r\n!!(query_buf[0] & RMI_F11_HAS_FINGER_LIMIT);\r\nsensor_query->has_linear_coeff_2 =\r\n!!(query_buf[0] & RMI_F11_HAS_LINEAR_COEFF);\r\nquery_size++;\r\n}\r\nif (sensor_query->has_jitter_filter) {\r\nrc = rmi_read(rmi_dev, query_base_addr + query_size, query_buf);\r\nif (rc < 0)\r\nreturn rc;\r\nsensor_query->jitter_window_size = query_buf[0] &\r\nRMI_F11_JITTER_WINDOW_MASK;\r\nsensor_query->jitter_filter_type = (query_buf[0] &\r\nRMI_F11_JITTER_FILTER_MASK) >>\r\nRMI_F11_JITTER_FILTER_SHIFT;\r\nquery_size++;\r\n}\r\nif (sensor_query->has_info2) {\r\nrc = rmi_read(rmi_dev, query_base_addr + query_size, query_buf);\r\nif (rc < 0)\r\nreturn rc;\r\nsensor_query->light_control =\r\nquery_buf[0] & RMI_F11_LIGHT_CONTROL_MASK;\r\nsensor_query->is_clear =\r\n!!(query_buf[0] & RMI_F11_IS_CLEAR);\r\nsensor_query->clickpad_props =\r\n(query_buf[0] & RMI_F11_CLICKPAD_PROPS_MASK) >>\r\nRMI_F11_CLICKPAD_PROPS_SHIFT;\r\nsensor_query->mouse_buttons =\r\n(query_buf[0] & RMI_F11_MOUSE_BUTTONS_MASK) >>\r\nRMI_F11_MOUSE_BUTTONS_SHIFT;\r\nsensor_query->has_advanced_gestures =\r\n!!(query_buf[0] & RMI_F11_HAS_ADVANCED_GESTURES);\r\nquery_size++;\r\n}\r\nif (sensor_query->has_physical_props) {\r\nrc = rmi_read_block(rmi_dev, query_base_addr\r\n+ query_size, query_buf, 4);\r\nif (rc < 0)\r\nreturn rc;\r\nsensor_query->x_sensor_size_mm =\r\n(query_buf[0] | (query_buf[1] << 8)) / 10;\r\nsensor_query->y_sensor_size_mm =\r\n(query_buf[2] | (query_buf[3] << 8)) / 10;\r\nquery_size += 12;\r\n}\r\nif (f11->has_query27)\r\n++query_size;\r\nif (f11->has_query28) {\r\nrc = rmi_read(rmi_dev, query_base_addr + query_size,\r\nquery_buf);\r\nif (rc < 0)\r\nreturn rc;\r\nhas_query36 = !!(query_buf[0] & BIT(6));\r\n}\r\nif (has_query36) {\r\nquery_size += 2;\r\nrc = rmi_read(rmi_dev, query_base_addr + query_size,\r\nquery_buf);\r\nif (rc < 0)\r\nreturn rc;\r\nif (!!(query_buf[0] & BIT(5)))\r\nf11->has_acm = true;\r\n}\r\nreturn query_size;\r\n}\r\nstatic int rmi_f11_initialize(struct rmi_function *fn)\r\n{\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nstruct f11_data *f11;\r\nstruct f11_2d_ctrl *ctrl;\r\nu8 query_offset;\r\nu16 query_base_addr;\r\nu16 control_base_addr;\r\nu16 max_x_pos, max_y_pos;\r\nint rc;\r\nconst struct rmi_device_platform_data *pdata =\r\nrmi_get_platform_data(rmi_dev);\r\nstruct rmi_driver_data *drvdata = dev_get_drvdata(&rmi_dev->dev);\r\nstruct rmi_2d_sensor *sensor;\r\nu8 buf;\r\nint mask_size;\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev, "Initializing F11 values.\n");\r\nmask_size = BITS_TO_LONGS(drvdata->irq_count) * sizeof(unsigned long);\r\nf11 = devm_kzalloc(&fn->dev, sizeof(struct f11_data) + mask_size * 3,\r\nGFP_KERNEL);\r\nif (!f11)\r\nreturn -ENOMEM;\r\nif (fn->dev.of_node) {\r\nrc = rmi_2d_sensor_of_probe(&fn->dev, &f11->sensor_pdata);\r\nif (rc)\r\nreturn rc;\r\n} else {\r\nf11->sensor_pdata = pdata->sensor_pdata;\r\n}\r\nf11->rezero_wait_ms = f11->sensor_pdata.rezero_wait;\r\nf11->abs_mask = (unsigned long *)((char *)f11\r\n+ sizeof(struct f11_data));\r\nf11->rel_mask = (unsigned long *)((char *)f11\r\n+ sizeof(struct f11_data) + mask_size);\r\nf11->result_bits = (unsigned long *)((char *)f11\r\n+ sizeof(struct f11_data) + mask_size * 2);\r\nset_bit(fn->irq_pos, f11->abs_mask);\r\nset_bit(fn->irq_pos + 1, f11->rel_mask);\r\nquery_base_addr = fn->fd.query_base_addr;\r\ncontrol_base_addr = fn->fd.control_base_addr;\r\nrc = rmi_read(rmi_dev, query_base_addr, &buf);\r\nif (rc < 0)\r\nreturn rc;\r\nf11->has_query9 = !!(buf & RMI_F11_HAS_QUERY9);\r\nf11->has_query11 = !!(buf & RMI_F11_HAS_QUERY11);\r\nf11->has_query12 = !!(buf & RMI_F11_HAS_QUERY12);\r\nf11->has_query27 = !!(buf & RMI_F11_HAS_QUERY27);\r\nf11->has_query28 = !!(buf & RMI_F11_HAS_QUERY28);\r\nquery_offset = (query_base_addr + 1);\r\nsensor = &f11->sensor;\r\nsensor->fn = fn;\r\nrc = rmi_f11_get_query_parameters(rmi_dev, f11,\r\n&f11->sens_query, query_offset);\r\nif (rc < 0)\r\nreturn rc;\r\nquery_offset += rc;\r\nrc = f11_read_control_regs(fn, &f11->dev_controls,\r\ncontrol_base_addr);\r\nif (rc < 0) {\r\ndev_err(&fn->dev,\r\n"Failed to read F11 control params.\n");\r\nreturn rc;\r\n}\r\nif (f11->sens_query.has_info2) {\r\nif (f11->sens_query.is_clear)\r\nf11->sensor.sensor_type = rmi_sensor_touchscreen;\r\nelse\r\nf11->sensor.sensor_type = rmi_sensor_touchpad;\r\n}\r\nsensor->report_abs = f11->sens_query.has_abs;\r\nsensor->axis_align =\r\nf11->sensor_pdata.axis_align;\r\nsensor->topbuttonpad = f11->sensor_pdata.topbuttonpad;\r\nsensor->kernel_tracking = f11->sensor_pdata.kernel_tracking;\r\nsensor->dmax = f11->sensor_pdata.dmax;\r\nsensor->dribble = f11->sensor_pdata.dribble;\r\nsensor->palm_detect = f11->sensor_pdata.palm_detect;\r\nif (f11->sens_query.has_physical_props) {\r\nsensor->x_mm = f11->sens_query.x_sensor_size_mm;\r\nsensor->y_mm = f11->sens_query.y_sensor_size_mm;\r\n} else {\r\nsensor->x_mm = f11->sensor_pdata.x_mm;\r\nsensor->y_mm = f11->sensor_pdata.y_mm;\r\n}\r\nif (sensor->sensor_type == rmi_sensor_default)\r\nsensor->sensor_type =\r\nf11->sensor_pdata.sensor_type;\r\nsensor->report_abs = sensor->report_abs\r\n&& !(f11->sensor_pdata.disable_report_mask\r\n& RMI_F11_DISABLE_ABS_REPORT);\r\nif (!sensor->report_abs)\r\nsensor->report_rel = f11->sens_query.has_rel;\r\nrc = rmi_read_block(rmi_dev,\r\ncontrol_base_addr + F11_CTRL_SENSOR_MAX_X_POS_OFFSET,\r\n(u8 *)&max_x_pos, sizeof(max_x_pos));\r\nif (rc < 0)\r\nreturn rc;\r\nrc = rmi_read_block(rmi_dev,\r\ncontrol_base_addr + F11_CTRL_SENSOR_MAX_Y_POS_OFFSET,\r\n(u8 *)&max_y_pos, sizeof(max_y_pos));\r\nif (rc < 0)\r\nreturn rc;\r\nsensor->max_x = max_x_pos;\r\nsensor->max_y = max_y_pos;\r\nrc = f11_2d_construct_data(f11);\r\nif (rc < 0)\r\nreturn rc;\r\nif (f11->has_acm)\r\nf11->sensor.attn_size += f11->sensor.nbr_fingers * 2;\r\nsensor->tracking_pos = devm_kzalloc(&fn->dev,\r\nsizeof(struct input_mt_pos) * sensor->nbr_fingers,\r\nGFP_KERNEL);\r\nsensor->tracking_slots = devm_kzalloc(&fn->dev,\r\nsizeof(int) * sensor->nbr_fingers, GFP_KERNEL);\r\nsensor->objs = devm_kzalloc(&fn->dev,\r\nsizeof(struct rmi_2d_sensor_abs_object)\r\n* sensor->nbr_fingers, GFP_KERNEL);\r\nif (!sensor->tracking_pos || !sensor->tracking_slots || !sensor->objs)\r\nreturn -ENOMEM;\r\nctrl = &f11->dev_controls;\r\nif (sensor->axis_align.delta_x_threshold)\r\nctrl->ctrl0_11[RMI_F11_DELTA_X_THRESHOLD] =\r\nsensor->axis_align.delta_x_threshold;\r\nif (sensor->axis_align.delta_y_threshold)\r\nctrl->ctrl0_11[RMI_F11_DELTA_Y_THRESHOLD] =\r\nsensor->axis_align.delta_y_threshold;\r\nif (f11->sens_query.has_dribble) {\r\nswitch (sensor->dribble) {\r\ncase RMI_REG_STATE_OFF:\r\nctrl->ctrl0_11[0] &= ~BIT(6);\r\nbreak;\r\ncase RMI_REG_STATE_ON:\r\nctrl->ctrl0_11[0] |= BIT(6);\r\nbreak;\r\ncase RMI_REG_STATE_DEFAULT:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (f11->sens_query.has_palm_det) {\r\nswitch (sensor->palm_detect) {\r\ncase RMI_REG_STATE_OFF:\r\nctrl->ctrl0_11[11] &= ~BIT(0);\r\nbreak;\r\ncase RMI_REG_STATE_ON:\r\nctrl->ctrl0_11[11] |= BIT(0);\r\nbreak;\r\ncase RMI_REG_STATE_DEFAULT:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nrc = f11_write_control_regs(fn, &f11->sens_query,\r\n&f11->dev_controls, fn->fd.query_base_addr);\r\nif (rc)\r\ndev_warn(&fn->dev, "Failed to write control registers\n");\r\nmutex_init(&f11->dev_controls_mutex);\r\ndev_set_drvdata(&fn->dev, f11);\r\nreturn 0;\r\n}\r\nstatic int rmi_f11_config(struct rmi_function *fn)\r\n{\r\nstruct f11_data *f11 = dev_get_drvdata(&fn->dev);\r\nstruct rmi_driver *drv = fn->rmi_dev->driver;\r\nstruct rmi_2d_sensor *sensor = &f11->sensor;\r\nint rc;\r\nif (!sensor->report_abs)\r\ndrv->clear_irq_bits(fn->rmi_dev, f11->abs_mask);\r\nelse\r\ndrv->set_irq_bits(fn->rmi_dev, f11->abs_mask);\r\nif (!sensor->report_rel)\r\ndrv->clear_irq_bits(fn->rmi_dev, f11->rel_mask);\r\nelse\r\ndrv->set_irq_bits(fn->rmi_dev, f11->rel_mask);\r\nrc = f11_write_control_regs(fn, &f11->sens_query,\r\n&f11->dev_controls, fn->fd.query_base_addr);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int rmi_f11_attention(struct rmi_function *fn, unsigned long *irq_bits)\r\n{\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nstruct rmi_driver_data *drvdata = dev_get_drvdata(&rmi_dev->dev);\r\nstruct f11_data *f11 = dev_get_drvdata(&fn->dev);\r\nu16 data_base_addr = fn->fd.data_base_addr;\r\nint error;\r\nint valid_bytes = f11->sensor.pkt_size;\r\nif (drvdata->attn_data.data) {\r\nif (f11->sensor.attn_size > drvdata->attn_data.size)\r\nvalid_bytes = drvdata->attn_data.size;\r\nelse\r\nvalid_bytes = f11->sensor.attn_size;\r\nmemcpy(f11->sensor.data_pkt, drvdata->attn_data.data,\r\nvalid_bytes);\r\ndrvdata->attn_data.data += f11->sensor.attn_size;\r\ndrvdata->attn_data.size -= f11->sensor.attn_size;\r\n} else {\r\nerror = rmi_read_block(rmi_dev,\r\ndata_base_addr, f11->sensor.data_pkt,\r\nf11->sensor.pkt_size);\r\nif (error < 0)\r\nreturn error;\r\n}\r\nrmi_f11_finger_handler(f11, &f11->sensor, irq_bits,\r\ndrvdata->num_of_irq_regs, valid_bytes);\r\nreturn 0;\r\n}\r\nstatic int rmi_f11_resume(struct rmi_function *fn)\r\n{\r\nstruct f11_data *f11 = dev_get_drvdata(&fn->dev);\r\nint error;\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev, "Resuming...\n");\r\nif (!f11->rezero_wait_ms)\r\nreturn 0;\r\nmdelay(f11->rezero_wait_ms);\r\nerror = rmi_write(fn->rmi_dev, fn->fd.command_base_addr,\r\nRMI_F11_REZERO);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"%s: failed to issue rezero command, error = %d.",\r\n__func__, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f11_probe(struct rmi_function *fn)\r\n{\r\nint error;\r\nstruct f11_data *f11;\r\nerror = rmi_f11_initialize(fn);\r\nif (error)\r\nreturn error;\r\nf11 = dev_get_drvdata(&fn->dev);\r\nerror = rmi_2d_sensor_configure_input(fn, &f11->sensor);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}
