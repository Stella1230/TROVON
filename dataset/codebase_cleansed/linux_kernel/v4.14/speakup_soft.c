static char *get_initstring(void)\r\n{\r\nstatic char buf[40];\r\nchar *cp;\r\nstruct var_t *var;\r\nmemset(buf, 0, sizeof(buf));\r\ncp = buf;\r\nvar = synth_soft.vars;\r\nwhile (var->var_id != MAXVARS) {\r\nif (var->var_id != CAPS_START && var->var_id != CAPS_STOP &&\r\nvar->var_id != DIRECT)\r\ncp = cp + sprintf(cp, var->u.n.synth_fmt,\r\nvar->u.n.value);\r\nvar++;\r\n}\r\ncp = cp + sprintf(cp, "\n");\r\nreturn buf;\r\n}\r\nstatic int softsynth_open(struct inode *inode, struct file *fp)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nif (synth_soft.alive) {\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreturn -EBUSY;\r\n}\r\nsynth_soft.alive = 1;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int softsynth_close(struct inode *inode, struct file *fp)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nsynth_soft.alive = 0;\r\ninit_pos = 0;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nspeakup_start_ttys();\r\nreturn 0;\r\n}\r\nstatic ssize_t softsynthx_read(struct file *fp, char __user *buf, size_t count,\r\nloff_t *pos, int unicode)\r\n{\r\nint chars_sent = 0;\r\nchar __user *cp;\r\nchar *init;\r\nu16 ch;\r\nint empty;\r\nunsigned long flags;\r\nDEFINE_WAIT(wait);\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nwhile (1) {\r\nprepare_to_wait(&speakup_event, &wait, TASK_INTERRUPTIBLE);\r\nif (!unicode)\r\nsynth_buffer_skip_nonlatin1();\r\nif (!synth_buffer_empty() || speakup_info.flushing)\r\nbreak;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nif (fp->f_flags & O_NONBLOCK) {\r\nfinish_wait(&speakup_event, &wait);\r\nreturn -EAGAIN;\r\n}\r\nif (signal_pending(current)) {\r\nfinish_wait(&speakup_event, &wait);\r\nreturn -ERESTARTSYS;\r\n}\r\nschedule();\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\n}\r\nfinish_wait(&speakup_event, &wait);\r\ncp = buf;\r\ninit = get_initstring();\r\nwhile (chars_sent <= count - 3) {\r\nif (speakup_info.flushing) {\r\nspeakup_info.flushing = 0;\r\nch = '\x18';\r\n} else if (init[init_pos]) {\r\nch = init[init_pos++];\r\n} else {\r\nif (!unicode)\r\nsynth_buffer_skip_nonlatin1();\r\nif (synth_buffer_empty())\r\nbreak;\r\nch = synth_buffer_getc();\r\n}\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nif ((!unicode && ch < 0x100) || (unicode && ch < 0x80)) {\r\nu_char c = ch;\r\nif (copy_to_user(cp, &c, 1))\r\nreturn -EFAULT;\r\nchars_sent++;\r\ncp++;\r\n} else if (unicode && ch < 0x800) {\r\nu_char s[2] = {\r\n0xc0 | (ch >> 6),\r\n0x80 | (ch & 0x3f)\r\n};\r\nif (copy_to_user(cp, s, sizeof(s)))\r\nreturn -EFAULT;\r\nchars_sent += sizeof(s);\r\ncp += sizeof(s);\r\n} else if (unicode) {\r\nu_char s[3] = {\r\n0xe0 | (ch >> 12),\r\n0x80 | ((ch >> 6) & 0x3f),\r\n0x80 | (ch & 0x3f)\r\n};\r\nif (copy_to_user(cp, s, sizeof(s)))\r\nreturn -EFAULT;\r\nchars_sent += sizeof(s);\r\ncp += sizeof(s);\r\n}\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\n}\r\n*pos += chars_sent;\r\nempty = synth_buffer_empty();\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nif (empty) {\r\nspeakup_start_ttys();\r\n*pos = 0;\r\n}\r\nreturn chars_sent;\r\n}\r\nstatic ssize_t softsynth_read(struct file *fp, char __user *buf, size_t count,\r\nloff_t *pos)\r\n{\r\nreturn softsynthx_read(fp, buf, count, pos, 0);\r\n}\r\nstatic ssize_t softsynthu_read(struct file *fp, char __user *buf, size_t count,\r\nloff_t *pos)\r\n{\r\nreturn softsynthx_read(fp, buf, count, pos, 1);\r\n}\r\nstatic ssize_t softsynth_write(struct file *fp, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nunsigned long supplied_index = 0;\r\nint converted;\r\nconverted = kstrtoul_from_user(buf, count, 0, &supplied_index);\r\nif (converted < 0)\r\nreturn converted;\r\nlast_index = supplied_index;\r\nreturn count;\r\n}\r\nstatic unsigned int softsynth_poll(struct file *fp, struct poll_table_struct *wait)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\npoll_wait(fp, &speakup_event, wait);\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nif (!synth_buffer_empty() || speakup_info.flushing)\r\nret = POLLIN | POLLRDNORM;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreturn ret;\r\n}\r\nstatic unsigned char get_index(struct spk_synth *synth)\r\n{\r\nint rv;\r\nrv = last_index;\r\nlast_index = 0;\r\nreturn rv;\r\n}\r\nstatic int softsynth_probe(struct spk_synth *synth)\r\n{\r\nif (misc_registered != 0)\r\nreturn 0;\r\nmemset(&synth_device, 0, sizeof(synth_device));\r\nsynth_device.minor = SOFTSYNTH_MINOR;\r\nsynth_device.name = "softsynth";\r\nsynth_device.fops = &softsynth_fops;\r\nif (misc_register(&synth_device)) {\r\npr_warn("Couldn't initialize miscdevice /dev/softsynth.\n");\r\nreturn -ENODEV;\r\n}\r\nmemset(&synthu_device, 0, sizeof(synthu_device));\r\nsynthu_device.minor = SOFTSYNTHU_MINOR;\r\nsynthu_device.name = "softsynthu";\r\nsynthu_device.fops = &softsynthu_fops;\r\nif (misc_register(&synthu_device)) {\r\npr_warn("Couldn't initialize miscdevice /dev/softsynth.\n");\r\nreturn -ENODEV;\r\n}\r\nmisc_registered = 1;\r\npr_info("initialized device: /dev/softsynth, node (MAJOR 10, MINOR 26)\n");\r\npr_info("initialized device: /dev/softsynthu, node (MAJOR 10, MINOR 27)\n");\r\nreturn 0;\r\n}\r\nstatic void softsynth_release(void)\r\n{\r\nmisc_deregister(&synth_device);\r\nmisc_deregister(&synthu_device);\r\nmisc_registered = 0;\r\npr_info("unregistered /dev/softsynth\n");\r\npr_info("unregistered /dev/softsynthu\n");\r\n}\r\nstatic int softsynth_is_alive(struct spk_synth *synth)\r\n{\r\nif (synth_soft.alive)\r\nreturn 1;\r\nreturn 0;\r\n}
