static int netpoll_start_xmit(struct sk_buff *skb, struct net_device *dev,\r\nstruct netdev_queue *txq)\r\n{\r\nint status = NETDEV_TX_OK;\r\nnetdev_features_t features;\r\nfeatures = netif_skb_features(skb);\r\nif (skb_vlan_tag_present(skb) &&\r\n!vlan_hw_offload_capable(features, skb->vlan_proto)) {\r\nskb = __vlan_hwaccel_push_inside(skb);\r\nif (unlikely(!skb)) {\r\ngoto out;\r\n}\r\n}\r\nstatus = netdev_start_xmit(skb, dev, txq, false);\r\nout:\r\nreturn status;\r\n}\r\nstatic void queue_process(struct work_struct *work)\r\n{\r\nstruct netpoll_info *npinfo =\r\ncontainer_of(work, struct netpoll_info, tx_work.work);\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nwhile ((skb = skb_dequeue(&npinfo->txq))) {\r\nstruct net_device *dev = skb->dev;\r\nstruct netdev_queue *txq;\r\nunsigned int q_index;\r\nif (!netif_device_present(dev) || !netif_running(dev)) {\r\nkfree_skb(skb);\r\ncontinue;\r\n}\r\nlocal_irq_save(flags);\r\nq_index = skb_get_queue_mapping(skb);\r\nif (unlikely(q_index >= dev->real_num_tx_queues)) {\r\nq_index = q_index % dev->real_num_tx_queues;\r\nskb_set_queue_mapping(skb, q_index);\r\n}\r\ntxq = netdev_get_tx_queue(dev, q_index);\r\nHARD_TX_LOCK(dev, txq, smp_processor_id());\r\nif (netif_xmit_frozen_or_stopped(txq) ||\r\nnetpoll_start_xmit(skb, dev, txq) != NETDEV_TX_OK) {\r\nskb_queue_head(&npinfo->txq, skb);\r\nHARD_TX_UNLOCK(dev, txq);\r\nlocal_irq_restore(flags);\r\nschedule_delayed_work(&npinfo->tx_work, HZ/10);\r\nreturn;\r\n}\r\nHARD_TX_UNLOCK(dev, txq);\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nstatic void poll_one_napi(struct napi_struct *napi)\r\n{\r\nint work = 0;\r\nif (!test_bit(NAPI_STATE_SCHED, &napi->state))\r\nreturn;\r\nif (test_and_set_bit(NAPI_STATE_NPSVC, &napi->state))\r\nreturn;\r\nwork = napi->poll(napi, 0);\r\nWARN_ONCE(work, "%pF exceeded budget in poll\n", napi->poll);\r\ntrace_napi_poll(napi, work, 0);\r\nclear_bit(NAPI_STATE_NPSVC, &napi->state);\r\n}\r\nstatic void poll_napi(struct net_device *dev)\r\n{\r\nstruct napi_struct *napi;\r\nint cpu = smp_processor_id();\r\nlist_for_each_entry(napi, &dev->napi_list, dev_list) {\r\nif (cmpxchg(&napi->poll_owner, -1, cpu) == -1) {\r\npoll_one_napi(napi);\r\nsmp_store_release(&napi->poll_owner, -1);\r\n}\r\n}\r\n}\r\nstatic void netpoll_poll_dev(struct net_device *dev)\r\n{\r\nconst struct net_device_ops *ops;\r\nstruct netpoll_info *ni = rcu_dereference_bh(dev->npinfo);\r\nif (down_trylock(&ni->dev_lock))\r\nreturn;\r\nif (!netif_running(dev)) {\r\nup(&ni->dev_lock);\r\nreturn;\r\n}\r\nops = dev->netdev_ops;\r\nif (!ops->ndo_poll_controller) {\r\nup(&ni->dev_lock);\r\nreturn;\r\n}\r\nops->ndo_poll_controller(dev);\r\npoll_napi(dev);\r\nup(&ni->dev_lock);\r\nzap_completion_queue();\r\n}\r\nvoid netpoll_poll_disable(struct net_device *dev)\r\n{\r\nstruct netpoll_info *ni;\r\nint idx;\r\nmight_sleep();\r\nidx = srcu_read_lock(&netpoll_srcu);\r\nni = srcu_dereference(dev->npinfo, &netpoll_srcu);\r\nif (ni)\r\ndown(&ni->dev_lock);\r\nsrcu_read_unlock(&netpoll_srcu, idx);\r\n}\r\nvoid netpoll_poll_enable(struct net_device *dev)\r\n{\r\nstruct netpoll_info *ni;\r\nrcu_read_lock();\r\nni = rcu_dereference(dev->npinfo);\r\nif (ni)\r\nup(&ni->dev_lock);\r\nrcu_read_unlock();\r\n}\r\nstatic void refill_skbs(void)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&skb_pool.lock, flags);\r\nwhile (skb_pool.qlen < MAX_SKBS) {\r\nskb = alloc_skb(MAX_SKB_SIZE, GFP_ATOMIC);\r\nif (!skb)\r\nbreak;\r\n__skb_queue_tail(&skb_pool, skb);\r\n}\r\nspin_unlock_irqrestore(&skb_pool.lock, flags);\r\n}\r\nstatic void zap_completion_queue(void)\r\n{\r\nunsigned long flags;\r\nstruct softnet_data *sd = &get_cpu_var(softnet_data);\r\nif (sd->completion_queue) {\r\nstruct sk_buff *clist;\r\nlocal_irq_save(flags);\r\nclist = sd->completion_queue;\r\nsd->completion_queue = NULL;\r\nlocal_irq_restore(flags);\r\nwhile (clist != NULL) {\r\nstruct sk_buff *skb = clist;\r\nclist = clist->next;\r\nif (!skb_irq_freeable(skb)) {\r\nrefcount_set(&skb->users, 1);\r\ndev_kfree_skb_any(skb);\r\n} else {\r\n__kfree_skb(skb);\r\n}\r\n}\r\n}\r\nput_cpu_var(softnet_data);\r\n}\r\nstatic struct sk_buff *find_skb(struct netpoll *np, int len, int reserve)\r\n{\r\nint count = 0;\r\nstruct sk_buff *skb;\r\nzap_completion_queue();\r\nrefill_skbs();\r\nrepeat:\r\nskb = alloc_skb(len, GFP_ATOMIC);\r\nif (!skb)\r\nskb = skb_dequeue(&skb_pool);\r\nif (!skb) {\r\nif (++count < 10) {\r\nnetpoll_poll_dev(np->dev);\r\ngoto repeat;\r\n}\r\nreturn NULL;\r\n}\r\nrefcount_set(&skb->users, 1);\r\nskb_reserve(skb, reserve);\r\nreturn skb;\r\n}\r\nstatic int netpoll_owner_active(struct net_device *dev)\r\n{\r\nstruct napi_struct *napi;\r\nlist_for_each_entry(napi, &dev->napi_list, dev_list) {\r\nif (napi->poll_owner == smp_processor_id())\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid netpoll_send_skb_on_dev(struct netpoll *np, struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nint status = NETDEV_TX_BUSY;\r\nunsigned long tries;\r\nstruct netpoll_info *npinfo;\r\nWARN_ON_ONCE(!irqs_disabled());\r\nnpinfo = rcu_dereference_bh(np->dev->npinfo);\r\nif (!npinfo || !netif_running(dev) || !netif_device_present(dev)) {\r\ndev_kfree_skb_irq(skb);\r\nreturn;\r\n}\r\nif (skb_queue_len(&npinfo->txq) == 0 && !netpoll_owner_active(dev)) {\r\nstruct netdev_queue *txq;\r\ntxq = netdev_pick_tx(dev, skb, NULL);\r\nfor (tries = jiffies_to_usecs(1)/USEC_PER_POLL;\r\ntries > 0; --tries) {\r\nif (HARD_TX_TRYLOCK(dev, txq)) {\r\nif (!netif_xmit_stopped(txq))\r\nstatus = netpoll_start_xmit(skb, dev, txq);\r\nHARD_TX_UNLOCK(dev, txq);\r\nif (status == NETDEV_TX_OK)\r\nbreak;\r\n}\r\nnetpoll_poll_dev(np->dev);\r\nudelay(USEC_PER_POLL);\r\n}\r\nWARN_ONCE(!irqs_disabled(),\r\n"netpoll_send_skb_on_dev(): %s enabled interrupts in poll (%pF)\n",\r\ndev->name, dev->netdev_ops->ndo_start_xmit);\r\n}\r\nif (status != NETDEV_TX_OK) {\r\nskb_queue_tail(&npinfo->txq, skb);\r\nschedule_delayed_work(&npinfo->tx_work,0);\r\n}\r\n}\r\nvoid netpoll_send_udp(struct netpoll *np, const char *msg, int len)\r\n{\r\nint total_len, ip_len, udp_len;\r\nstruct sk_buff *skb;\r\nstruct udphdr *udph;\r\nstruct iphdr *iph;\r\nstruct ethhdr *eth;\r\nstatic atomic_t ip_ident;\r\nstruct ipv6hdr *ip6h;\r\nWARN_ON_ONCE(!irqs_disabled());\r\nudp_len = len + sizeof(*udph);\r\nif (np->ipv6)\r\nip_len = udp_len + sizeof(*ip6h);\r\nelse\r\nip_len = udp_len + sizeof(*iph);\r\ntotal_len = ip_len + LL_RESERVED_SPACE(np->dev);\r\nskb = find_skb(np, total_len + np->dev->needed_tailroom,\r\ntotal_len - len);\r\nif (!skb)\r\nreturn;\r\nskb_copy_to_linear_data(skb, msg, len);\r\nskb_put(skb, len);\r\nskb_push(skb, sizeof(*udph));\r\nskb_reset_transport_header(skb);\r\nudph = udp_hdr(skb);\r\nudph->source = htons(np->local_port);\r\nudph->dest = htons(np->remote_port);\r\nudph->len = htons(udp_len);\r\nif (np->ipv6) {\r\nudph->check = 0;\r\nudph->check = csum_ipv6_magic(&np->local_ip.in6,\r\n&np->remote_ip.in6,\r\nudp_len, IPPROTO_UDP,\r\ncsum_partial(udph, udp_len, 0));\r\nif (udph->check == 0)\r\nudph->check = CSUM_MANGLED_0;\r\nskb_push(skb, sizeof(*ip6h));\r\nskb_reset_network_header(skb);\r\nip6h = ipv6_hdr(skb);\r\nput_unaligned(0x60, (unsigned char *)ip6h);\r\nip6h->flow_lbl[0] = 0;\r\nip6h->flow_lbl[1] = 0;\r\nip6h->flow_lbl[2] = 0;\r\nip6h->payload_len = htons(sizeof(struct udphdr) + len);\r\nip6h->nexthdr = IPPROTO_UDP;\r\nip6h->hop_limit = 32;\r\nip6h->saddr = np->local_ip.in6;\r\nip6h->daddr = np->remote_ip.in6;\r\neth = skb_push(skb, ETH_HLEN);\r\nskb_reset_mac_header(skb);\r\nskb->protocol = eth->h_proto = htons(ETH_P_IPV6);\r\n} else {\r\nudph->check = 0;\r\nudph->check = csum_tcpudp_magic(np->local_ip.ip,\r\nnp->remote_ip.ip,\r\nudp_len, IPPROTO_UDP,\r\ncsum_partial(udph, udp_len, 0));\r\nif (udph->check == 0)\r\nudph->check = CSUM_MANGLED_0;\r\nskb_push(skb, sizeof(*iph));\r\nskb_reset_network_header(skb);\r\niph = ip_hdr(skb);\r\nput_unaligned(0x45, (unsigned char *)iph);\r\niph->tos = 0;\r\nput_unaligned(htons(ip_len), &(iph->tot_len));\r\niph->id = htons(atomic_inc_return(&ip_ident));\r\niph->frag_off = 0;\r\niph->ttl = 64;\r\niph->protocol = IPPROTO_UDP;\r\niph->check = 0;\r\nput_unaligned(np->local_ip.ip, &(iph->saddr));\r\nput_unaligned(np->remote_ip.ip, &(iph->daddr));\r\niph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);\r\neth = skb_push(skb, ETH_HLEN);\r\nskb_reset_mac_header(skb);\r\nskb->protocol = eth->h_proto = htons(ETH_P_IP);\r\n}\r\nether_addr_copy(eth->h_source, np->dev->dev_addr);\r\nether_addr_copy(eth->h_dest, np->remote_mac);\r\nskb->dev = np->dev;\r\nnetpoll_send_skb(np, skb);\r\n}\r\nvoid netpoll_print_options(struct netpoll *np)\r\n{\r\nnp_info(np, "local port %d\n", np->local_port);\r\nif (np->ipv6)\r\nnp_info(np, "local IPv6 address %pI6c\n", &np->local_ip.in6);\r\nelse\r\nnp_info(np, "local IPv4 address %pI4\n", &np->local_ip.ip);\r\nnp_info(np, "interface '%s'\n", np->dev_name);\r\nnp_info(np, "remote port %d\n", np->remote_port);\r\nif (np->ipv6)\r\nnp_info(np, "remote IPv6 address %pI6c\n", &np->remote_ip.in6);\r\nelse\r\nnp_info(np, "remote IPv4 address %pI4\n", &np->remote_ip.ip);\r\nnp_info(np, "remote ethernet address %pM\n", np->remote_mac);\r\n}\r\nstatic int netpoll_parse_ip_addr(const char *str, union inet_addr *addr)\r\n{\r\nconst char *end;\r\nif (!strchr(str, ':') &&\r\nin4_pton(str, -1, (void *)addr, -1, &end) > 0) {\r\nif (!*end)\r\nreturn 0;\r\n}\r\nif (in6_pton(str, -1, addr->in6.s6_addr, -1, &end) > 0) {\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (!*end)\r\nreturn 1;\r\n#else\r\nreturn -1;\r\n#endif\r\n}\r\nreturn -1;\r\n}\r\nint netpoll_parse_options(struct netpoll *np, char *opt)\r\n{\r\nchar *cur=opt, *delim;\r\nint ipv6;\r\nbool ipversion_set = false;\r\nif (*cur != '@') {\r\nif ((delim = strchr(cur, '@')) == NULL)\r\ngoto parse_failed;\r\n*delim = 0;\r\nif (kstrtou16(cur, 10, &np->local_port))\r\ngoto parse_failed;\r\ncur = delim;\r\n}\r\ncur++;\r\nif (*cur != '/') {\r\nipversion_set = true;\r\nif ((delim = strchr(cur, '/')) == NULL)\r\ngoto parse_failed;\r\n*delim = 0;\r\nipv6 = netpoll_parse_ip_addr(cur, &np->local_ip);\r\nif (ipv6 < 0)\r\ngoto parse_failed;\r\nelse\r\nnp->ipv6 = (bool)ipv6;\r\ncur = delim;\r\n}\r\ncur++;\r\nif (*cur != ',') {\r\nif ((delim = strchr(cur, ',')) == NULL)\r\ngoto parse_failed;\r\n*delim = 0;\r\nstrlcpy(np->dev_name, cur, sizeof(np->dev_name));\r\ncur = delim;\r\n}\r\ncur++;\r\nif (*cur != '@') {\r\nif ((delim = strchr(cur, '@')) == NULL)\r\ngoto parse_failed;\r\n*delim = 0;\r\nif (*cur == ' ' || *cur == '\t')\r\nnp_info(np, "warning: whitespace is not allowed\n");\r\nif (kstrtou16(cur, 10, &np->remote_port))\r\ngoto parse_failed;\r\ncur = delim;\r\n}\r\ncur++;\r\nif ((delim = strchr(cur, '/')) == NULL)\r\ngoto parse_failed;\r\n*delim = 0;\r\nipv6 = netpoll_parse_ip_addr(cur, &np->remote_ip);\r\nif (ipv6 < 0)\r\ngoto parse_failed;\r\nelse if (ipversion_set && np->ipv6 != (bool)ipv6)\r\ngoto parse_failed;\r\nelse\r\nnp->ipv6 = (bool)ipv6;\r\ncur = delim + 1;\r\nif (*cur != 0) {\r\nif (!mac_pton(cur, np->remote_mac))\r\ngoto parse_failed;\r\n}\r\nnetpoll_print_options(np);\r\nreturn 0;\r\nparse_failed:\r\nnp_info(np, "couldn't parse config at '%s'!\n", cur);\r\nreturn -1;\r\n}\r\nint __netpoll_setup(struct netpoll *np, struct net_device *ndev)\r\n{\r\nstruct netpoll_info *npinfo;\r\nconst struct net_device_ops *ops;\r\nint err;\r\nnp->dev = ndev;\r\nstrlcpy(np->dev_name, ndev->name, IFNAMSIZ);\r\nINIT_WORK(&np->cleanup_work, netpoll_async_cleanup);\r\nif ((ndev->priv_flags & IFF_DISABLE_NETPOLL) ||\r\n!ndev->netdev_ops->ndo_poll_controller) {\r\nnp_err(np, "%s doesn't support polling, aborting\n",\r\nnp->dev_name);\r\nerr = -ENOTSUPP;\r\ngoto out;\r\n}\r\nif (!ndev->npinfo) {\r\nnpinfo = kmalloc(sizeof(*npinfo), GFP_KERNEL);\r\nif (!npinfo) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nsema_init(&npinfo->dev_lock, 1);\r\nskb_queue_head_init(&npinfo->txq);\r\nINIT_DELAYED_WORK(&npinfo->tx_work, queue_process);\r\nrefcount_set(&npinfo->refcnt, 1);\r\nops = np->dev->netdev_ops;\r\nif (ops->ndo_netpoll_setup) {\r\nerr = ops->ndo_netpoll_setup(ndev, npinfo);\r\nif (err)\r\ngoto free_npinfo;\r\n}\r\n} else {\r\nnpinfo = rtnl_dereference(ndev->npinfo);\r\nrefcount_inc(&npinfo->refcnt);\r\n}\r\nnpinfo->netpoll = np;\r\nrcu_assign_pointer(ndev->npinfo, npinfo);\r\nreturn 0;\r\nfree_npinfo:\r\nkfree(npinfo);\r\nout:\r\nreturn err;\r\n}\r\nint netpoll_setup(struct netpoll *np)\r\n{\r\nstruct net_device *ndev = NULL;\r\nstruct in_device *in_dev;\r\nint err;\r\nrtnl_lock();\r\nif (np->dev_name[0]) {\r\nstruct net *net = current->nsproxy->net_ns;\r\nndev = __dev_get_by_name(net, np->dev_name);\r\n}\r\nif (!ndev) {\r\nnp_err(np, "%s doesn't exist, aborting\n", np->dev_name);\r\nerr = -ENODEV;\r\ngoto unlock;\r\n}\r\ndev_hold(ndev);\r\nif (netdev_master_upper_dev_get(ndev)) {\r\nnp_err(np, "%s is a slave device, aborting\n", np->dev_name);\r\nerr = -EBUSY;\r\ngoto put;\r\n}\r\nif (!netif_running(ndev)) {\r\nunsigned long atmost, atleast;\r\nnp_info(np, "device %s not up yet, forcing it\n", np->dev_name);\r\nerr = dev_open(ndev);\r\nif (err) {\r\nnp_err(np, "failed to open %s\n", ndev->name);\r\ngoto put;\r\n}\r\nrtnl_unlock();\r\natleast = jiffies + HZ/10;\r\natmost = jiffies + carrier_timeout * HZ;\r\nwhile (!netif_carrier_ok(ndev)) {\r\nif (time_after(jiffies, atmost)) {\r\nnp_notice(np, "timeout waiting for carrier\n");\r\nbreak;\r\n}\r\nmsleep(1);\r\n}\r\nif (time_before(jiffies, atleast)) {\r\nnp_notice(np, "carrier detect appears untrustworthy, waiting 4 seconds\n");\r\nmsleep(4000);\r\n}\r\nrtnl_lock();\r\n}\r\nif (!np->local_ip.ip) {\r\nif (!np->ipv6) {\r\nin_dev = __in_dev_get_rtnl(ndev);\r\nif (!in_dev || !in_dev->ifa_list) {\r\nnp_err(np, "no IP address for %s, aborting\n",\r\nnp->dev_name);\r\nerr = -EDESTADDRREQ;\r\ngoto put;\r\n}\r\nnp->local_ip.ip = in_dev->ifa_list->ifa_local;\r\nnp_info(np, "local IP %pI4\n", &np->local_ip.ip);\r\n} else {\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nstruct inet6_dev *idev;\r\nerr = -EDESTADDRREQ;\r\nidev = __in6_dev_get(ndev);\r\nif (idev) {\r\nstruct inet6_ifaddr *ifp;\r\nread_lock_bh(&idev->lock);\r\nlist_for_each_entry(ifp, &idev->addr_list, if_list) {\r\nif (ipv6_addr_type(&ifp->addr) & IPV6_ADDR_LINKLOCAL)\r\ncontinue;\r\nnp->local_ip.in6 = ifp->addr;\r\nerr = 0;\r\nbreak;\r\n}\r\nread_unlock_bh(&idev->lock);\r\n}\r\nif (err) {\r\nnp_err(np, "no IPv6 address for %s, aborting\n",\r\nnp->dev_name);\r\ngoto put;\r\n} else\r\nnp_info(np, "local IPv6 %pI6c\n", &np->local_ip.in6);\r\n#else\r\nnp_err(np, "IPv6 is not supported %s, aborting\n",\r\nnp->dev_name);\r\nerr = -EINVAL;\r\ngoto put;\r\n#endif\r\n}\r\n}\r\nrefill_skbs();\r\nerr = __netpoll_setup(np, ndev);\r\nif (err)\r\ngoto put;\r\nrtnl_unlock();\r\nreturn 0;\r\nput:\r\ndev_put(ndev);\r\nunlock:\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic int __init netpoll_init(void)\r\n{\r\nskb_queue_head_init(&skb_pool);\r\nreturn 0;\r\n}\r\nstatic void rcu_cleanup_netpoll_info(struct rcu_head *rcu_head)\r\n{\r\nstruct netpoll_info *npinfo =\r\ncontainer_of(rcu_head, struct netpoll_info, rcu);\r\nskb_queue_purge(&npinfo->txq);\r\ncancel_delayed_work(&npinfo->tx_work);\r\n__skb_queue_purge(&npinfo->txq);\r\ncancel_delayed_work(&npinfo->tx_work);\r\nkfree(npinfo);\r\n}\r\nvoid __netpoll_cleanup(struct netpoll *np)\r\n{\r\nstruct netpoll_info *npinfo;\r\nnpinfo = rtnl_dereference(np->dev->npinfo);\r\nif (!npinfo)\r\nreturn;\r\nsynchronize_srcu(&netpoll_srcu);\r\nif (refcount_dec_and_test(&npinfo->refcnt)) {\r\nconst struct net_device_ops *ops;\r\nops = np->dev->netdev_ops;\r\nif (ops->ndo_netpoll_cleanup)\r\nops->ndo_netpoll_cleanup(np->dev);\r\nRCU_INIT_POINTER(np->dev->npinfo, NULL);\r\ncall_rcu_bh(&npinfo->rcu, rcu_cleanup_netpoll_info);\r\n} else\r\nRCU_INIT_POINTER(np->dev->npinfo, NULL);\r\n}\r\nstatic void netpoll_async_cleanup(struct work_struct *work)\r\n{\r\nstruct netpoll *np = container_of(work, struct netpoll, cleanup_work);\r\nrtnl_lock();\r\n__netpoll_cleanup(np);\r\nrtnl_unlock();\r\nkfree(np);\r\n}\r\nvoid __netpoll_free_async(struct netpoll *np)\r\n{\r\nschedule_work(&np->cleanup_work);\r\n}\r\nvoid netpoll_cleanup(struct netpoll *np)\r\n{\r\nrtnl_lock();\r\nif (!np->dev)\r\ngoto out;\r\n__netpoll_cleanup(np);\r\ndev_put(np->dev);\r\nnp->dev = NULL;\r\nout:\r\nrtnl_unlock();\r\n}
