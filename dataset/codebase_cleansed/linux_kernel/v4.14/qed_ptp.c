static enum qed_resc_lock qed_ptcdev_to_resc(struct qed_hwfn *p_hwfn)\r\n{\r\nswitch (qed_device_get_port_id(p_hwfn->cdev)) {\r\ncase 0:\r\nreturn QED_RESC_LOCK_PTP_PORT0;\r\ncase 1:\r\nreturn QED_RESC_LOCK_PTP_PORT1;\r\ncase 2:\r\nreturn QED_RESC_LOCK_PTP_PORT2;\r\ncase 3:\r\nreturn QED_RESC_LOCK_PTP_PORT3;\r\ndefault:\r\nreturn QED_RESC_LOCK_RESC_INVALID;\r\n}\r\n}\r\nstatic int qed_ptp_res_lock(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\nstruct qed_resc_lock_params params;\r\nenum qed_resc_lock resource;\r\nint rc;\r\nresource = qed_ptcdev_to_resc(p_hwfn);\r\nif (resource == QED_RESC_LOCK_RESC_INVALID)\r\nreturn -EINVAL;\r\nqed_mcp_resc_lock_default_init(&params, NULL, resource, true);\r\nrc = qed_mcp_resc_lock(p_hwfn, p_ptt, &params);\r\nif (rc && rc != -EINVAL) {\r\nreturn rc;\r\n} else if (rc == -EINVAL) {\r\nif (p_hwfn->abs_pf_id < p_hwfn->cdev->num_ports_in_engine)\r\nreturn 0;\r\nDP_INFO(p_hwfn, "PF doesn't have lock ownership\n");\r\nreturn -EBUSY;\r\n} else if (!rc && !params.b_granted) {\r\nDP_INFO(p_hwfn, "Failed to acquire ptp resource lock\n");\r\nreturn -EBUSY;\r\n}\r\nreturn rc;\r\n}\r\nstatic int qed_ptp_res_unlock(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\nstruct qed_resc_unlock_params params;\r\nenum qed_resc_lock resource;\r\nint rc;\r\nresource = qed_ptcdev_to_resc(p_hwfn);\r\nif (resource == QED_RESC_LOCK_RESC_INVALID)\r\nreturn -EINVAL;\r\nqed_mcp_resc_lock_default_init(NULL, &params, resource, true);\r\nrc = qed_mcp_resc_unlock(p_hwfn, p_ptt, &params);\r\nif (rc == -EINVAL) {\r\nif (p_hwfn->abs_pf_id < p_hwfn->cdev->num_ports_in_engine) {\r\nrc = 0;\r\n} else {\r\nDP_INFO(p_hwfn, "PF doesn't have lock ownership\n");\r\nreturn -EINVAL;\r\n}\r\n} else if (rc) {\r\nDP_INFO(p_hwfn, "Failed to release the ptp resource lock\n");\r\n}\r\nreturn rc;\r\n}\r\nstatic int qed_ptp_hw_read_rx_ts(struct qed_dev *cdev, u64 *timestamp)\r\n{\r\nstruct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);\r\nstruct qed_ptt *p_ptt = p_hwfn->p_ptp_ptt;\r\nu32 val;\r\n*timestamp = 0;\r\nval = qed_rd(p_hwfn, p_ptt, NIG_REG_LLH_PTP_HOST_BUF_SEQID);\r\nif (!(val & QED_TIMESTAMP_MASK)) {\r\nDP_INFO(p_hwfn, "Invalid Rx timestamp, buf_seqid = %d\n", val);\r\nreturn -EINVAL;\r\n}\r\nval = qed_rd(p_hwfn, p_ptt, NIG_REG_LLH_PTP_HOST_BUF_TS_LSB);\r\n*timestamp = qed_rd(p_hwfn, p_ptt, NIG_REG_LLH_PTP_HOST_BUF_TS_MSB);\r\n*timestamp <<= 32;\r\n*timestamp |= val;\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_HOST_BUF_SEQID,\r\nQED_TIMESTAMP_MASK);\r\nreturn 0;\r\n}\r\nstatic int qed_ptp_hw_read_tx_ts(struct qed_dev *cdev, u64 *timestamp)\r\n{\r\nstruct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);\r\nstruct qed_ptt *p_ptt = p_hwfn->p_ptp_ptt;\r\nu32 val;\r\n*timestamp = 0;\r\nval = qed_rd(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_BUF_SEQID);\r\nif (!(val & QED_TIMESTAMP_MASK)) {\r\nDP_INFO(p_hwfn, "Invalid Tx timestamp, buf_seqid = %d\n", val);\r\nreturn -EINVAL;\r\n}\r\nval = qed_rd(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_BUF_TS_LSB);\r\n*timestamp = qed_rd(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_BUF_TS_MSB);\r\n*timestamp <<= 32;\r\n*timestamp |= val;\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_BUF_SEQID, QED_TIMESTAMP_MASK);\r\nreturn 0;\r\n}\r\nstatic int qed_ptp_hw_read_cc(struct qed_dev *cdev, u64 *phc_cycles)\r\n{\r\nstruct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);\r\nstruct qed_ptt *p_ptt = p_hwfn->p_ptp_ptt;\r\nu32 temp = 0;\r\ntemp = qed_rd(p_hwfn, p_ptt, NIG_REG_TSGEN_SYNC_TIME_LSB);\r\n*phc_cycles = qed_rd(p_hwfn, p_ptt, NIG_REG_TSGEN_SYNC_TIME_MSB);\r\n*phc_cycles <<= 32;\r\n*phc_cycles |= temp;\r\nreturn 0;\r\n}\r\nstatic int qed_ptp_hw_cfg_filters(struct qed_dev *cdev,\r\nenum qed_ptp_filter_type rx_type,\r\nenum qed_ptp_hwtstamp_tx_type tx_type)\r\n{\r\nstruct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);\r\nstruct qed_ptt *p_ptt = p_hwfn->p_ptp_ptt;\r\nu32 rule_mask, enable_cfg = 0x0;\r\nswitch (rx_type) {\r\ncase QED_PTP_FILTER_NONE:\r\nenable_cfg = 0x0;\r\nrule_mask = 0x3FFF;\r\nbreak;\r\ncase QED_PTP_FILTER_ALL:\r\nenable_cfg = 0x7;\r\nrule_mask = 0x3CAA;\r\nbreak;\r\ncase QED_PTP_FILTER_V1_L4_EVENT:\r\nenable_cfg = 0x3;\r\nrule_mask = 0x3FFA;\r\nbreak;\r\ncase QED_PTP_FILTER_V1_L4_GEN:\r\nenable_cfg = 0x3;\r\nrule_mask = 0x3FFE;\r\nbreak;\r\ncase QED_PTP_FILTER_V2_L4_EVENT:\r\nenable_cfg = 0x5;\r\nrule_mask = 0x3FAA;\r\nbreak;\r\ncase QED_PTP_FILTER_V2_L4_GEN:\r\nenable_cfg = 0x5;\r\nrule_mask = 0x3FEE;\r\nbreak;\r\ncase QED_PTP_FILTER_V2_L2_EVENT:\r\nenable_cfg = 0x5;\r\nrule_mask = 0x3CFF;\r\nbreak;\r\ncase QED_PTP_FILTER_V2_L2_GEN:\r\nenable_cfg = 0x5;\r\nrule_mask = 0x3EFF;\r\nbreak;\r\ncase QED_PTP_FILTER_V2_EVENT:\r\nenable_cfg = 0x5;\r\nrule_mask = 0x3CAA;\r\nbreak;\r\ncase QED_PTP_FILTER_V2_GEN:\r\nenable_cfg = 0x5;\r\nrule_mask = 0x3EEE;\r\nbreak;\r\ndefault:\r\nDP_INFO(p_hwfn, "Invalid PTP filter type %d\n", rx_type);\r\nreturn -EINVAL;\r\n}\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_PARAM_MASK, 0);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_RULE_MASK, rule_mask);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_RX_PTP_EN, enable_cfg);\r\nif (tx_type == QED_PTP_HWTSTAMP_TX_OFF) {\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TX_PTP_EN, 0x0);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_PARAM_MASK, 0x7FF);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_RULE_MASK, 0x3FFF);\r\n} else {\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TX_PTP_EN, enable_cfg);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_PARAM_MASK, 0);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_RULE_MASK, rule_mask);\r\n}\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_HOST_BUF_SEQID,\r\nQED_TIMESTAMP_MASK);\r\nreturn 0;\r\n}\r\nstatic int qed_ptp_hw_adjfreq(struct qed_dev *cdev, s32 ppb)\r\n{\r\ns64 best_val = 0, val, best_period = 0, period, approx_dev, dif, dif2;\r\nstruct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);\r\nstruct qed_ptt *p_ptt = p_hwfn->p_ptp_ptt;\r\nu32 drift_ctr_cfg = 0, drift_state;\r\nint drift_dir = 1;\r\nif (ppb < 0) {\r\nppb = -ppb;\r\ndrift_dir = 0;\r\n}\r\nif (ppb > 1) {\r\ns64 best_dif = ppb, best_approx_dev = 1;\r\nfor (val = 7; val > 0; val--) {\r\nperiod = div_s64(val * 1000000000, ppb);\r\nperiod -= 8;\r\nperiod >>= 4;\r\nif (period < 1)\r\nperiod = 1;\r\nif (period > 0xFFFFFFE)\r\nperiod = 0xFFFFFFE;\r\napprox_dev = period * 16 + 8;\r\ndif = ppb * approx_dev - val * 1000000000;\r\ndif2 = dif + 16 * ppb;\r\nif (dif < 0)\r\ndif = -dif;\r\nif (dif2 < 0)\r\ndif2 = -dif2;\r\nif (dif * (approx_dev + 16) > dif2 * approx_dev) {\r\nperiod++;\r\napprox_dev += 16;\r\ndif = dif2;\r\n}\r\nif (best_dif * approx_dev > dif * best_approx_dev) {\r\nbest_dif = dif;\r\nbest_val = val;\r\nbest_period = period;\r\nbest_approx_dev = approx_dev;\r\n}\r\n}\r\n} else if (ppb == 1) {\r\nbest_val = 4;\r\nbest_period = 0xee6b27f;\r\n} else {\r\nbest_val = 0;\r\nbest_period = 0xFFFFFFF;\r\n}\r\ndrift_ctr_cfg = (best_period << QED_DRIFT_CNTR_TIME_QUANTA_SHIFT) |\r\n(((int)best_val) << QED_DRIFT_CNTR_ADJUSTMENT_SHIFT) |\r\n(((int)drift_dir) << QED_DRIFT_CNTR_DIRECTION_SHIFT);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_RST_DRIFT_CNTR, 0x1);\r\ndrift_state = qed_rd(p_hwfn, p_ptt, NIG_REG_TSGEN_RST_DRIFT_CNTR);\r\nif (drift_state & 1) {\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_DRIFT_CNTR_CONF,\r\ndrift_ctr_cfg);\r\n} else {\r\nDP_INFO(p_hwfn, "Drift counter is not reset\n");\r\nreturn -EINVAL;\r\n}\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_RST_DRIFT_CNTR, 0x0);\r\nreturn 0;\r\n}\r\nstatic int qed_ptp_hw_enable(struct qed_dev *cdev)\r\n{\r\nstruct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);\r\nstruct qed_ptt *p_ptt;\r\nint rc;\r\np_ptt = qed_ptt_acquire(p_hwfn);\r\nif (!p_ptt) {\r\nDP_NOTICE(p_hwfn, "Failed to acquire PTT for PTP\n");\r\nreturn -EBUSY;\r\n}\r\np_hwfn->p_ptp_ptt = p_ptt;\r\nrc = qed_ptp_res_lock(p_hwfn, p_ptt);\r\nif (rc) {\r\nDP_INFO(p_hwfn,\r\n"Couldn't acquire the resource lock, skip ptp enable for this PF\n");\r\nqed_ptt_release(p_hwfn, p_ptt);\r\np_hwfn->p_ptp_ptt = NULL;\r\nreturn rc;\r\n}\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_PARAM_MASK, 0x7FF);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_RULE_MASK, 0x3FFF);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_PARAM_MASK, 0x7FF);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_RULE_MASK, 0x3FFF);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TX_PTP_EN, 7);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_RX_PTP_EN, 7);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TS_OUTPUT_ENABLE_PDA, 0x1);\r\nif (QED_IS_BB_B0(p_hwfn->cdev))\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TIMESYNC_GEN_REG_BB, 2);\r\nif (QED_IS_AH(p_hwfn->cdev))\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_FREECNT_UPDATE_K2, 2);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_FREE_CNT_VALUE_LSB, 0);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_FREE_CNT_VALUE_MSB, 0);\r\nif (QED_IS_BB_B0(p_hwfn->cdev))\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TIMESYNC_GEN_REG_BB, 4);\r\nif (QED_IS_AH(p_hwfn->cdev)) {\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_FREECNT_UPDATE_K2, 4);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_PTP_LATCH_OSTS_PKT_TIME, 1);\r\n}\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_DRIFT_CNTR_CONF, 0x0);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TSGEN_RST_DRIFT_CNTR, 0x0);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_HOST_BUF_SEQID,\r\nQED_TIMESTAMP_MASK);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_BUF_SEQID, QED_TIMESTAMP_MASK);\r\nreturn 0;\r\n}\r\nstatic int qed_ptp_hw_disable(struct qed_dev *cdev)\r\n{\r\nstruct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);\r\nstruct qed_ptt *p_ptt = p_hwfn->p_ptp_ptt;\r\nqed_ptp_res_unlock(p_hwfn, p_ptt);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_PARAM_MASK, 0x7FF);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_LLH_PTP_RULE_MASK, 0x3FFF);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_PARAM_MASK, 0x7FF);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TX_LLH_PTP_RULE_MASK, 0x3FFF);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_RX_PTP_EN, 0x0);\r\nqed_wr(p_hwfn, p_ptt, NIG_REG_TX_PTP_EN, 0x0);\r\nqed_ptt_release(p_hwfn, p_ptt);\r\np_hwfn->p_ptp_ptt = NULL;\r\nreturn 0;\r\n}
