struct nhlt_acpi_table *skl_nhlt_init(struct device *dev)\r\n{\r\nacpi_handle handle;\r\nunion acpi_object *obj;\r\nstruct nhlt_resource_desc *nhlt_ptr = NULL;\r\nstruct nhlt_acpi_table *nhlt_table = NULL;\r\nhandle = ACPI_HANDLE(dev);\r\nif (!handle) {\r\ndev_err(dev, "Didn't find ACPI_HANDLE\n");\r\nreturn NULL;\r\n}\r\nobj = acpi_evaluate_dsm(handle, &osc_guid, 1, 1, NULL);\r\nif (obj && obj->type == ACPI_TYPE_BUFFER) {\r\nnhlt_ptr = (struct nhlt_resource_desc *)obj->buffer.pointer;\r\nnhlt_table = (struct nhlt_acpi_table *)\r\nmemremap(nhlt_ptr->min_addr, nhlt_ptr->length,\r\nMEMREMAP_WB);\r\nACPI_FREE(obj);\r\nreturn nhlt_table;\r\n}\r\ndev_err(dev, "device specific method to extract NHLT blob failed\n");\r\nreturn NULL;\r\n}\r\nvoid skl_nhlt_free(struct nhlt_acpi_table *nhlt)\r\n{\r\nmemunmap((void *) nhlt);\r\n}\r\nstatic struct nhlt_specific_cfg *skl_get_specific_cfg(\r\nstruct device *dev, struct nhlt_fmt *fmt,\r\nu8 no_ch, u32 rate, u16 bps, u8 linktype)\r\n{\r\nstruct nhlt_specific_cfg *sp_config;\r\nstruct wav_fmt *wfmt;\r\nstruct nhlt_fmt_cfg *fmt_config = fmt->fmt_config;\r\nint i;\r\ndev_dbg(dev, "Format count =%d\n", fmt->fmt_count);\r\nfor (i = 0; i < fmt->fmt_count; i++) {\r\nwfmt = &fmt_config->fmt_ext.fmt;\r\ndev_dbg(dev, "ch=%d fmt=%d s_rate=%d\n", wfmt->channels,\r\nwfmt->bits_per_sample, wfmt->samples_per_sec);\r\nif (wfmt->channels == no_ch && wfmt->bits_per_sample == bps) {\r\nsp_config = &fmt_config->config;\r\nif (linktype == NHLT_LINK_DMIC)\r\nreturn sp_config;\r\nif (wfmt->samples_per_sec == rate)\r\nreturn sp_config;\r\n}\r\nfmt_config = (struct nhlt_fmt_cfg *)(fmt_config->config.caps +\r\nfmt_config->config.size);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void dump_config(struct device *dev, u32 instance_id, u8 linktype,\r\nu8 s_fmt, u8 num_channels, u32 s_rate, u8 dirn, u16 bps)\r\n{\r\ndev_dbg(dev, "Input configuration\n");\r\ndev_dbg(dev, "ch=%d fmt=%d s_rate=%d\n", num_channels, s_fmt, s_rate);\r\ndev_dbg(dev, "vbus_id=%d link_type=%d\n", instance_id, linktype);\r\ndev_dbg(dev, "bits_per_sample=%d\n", bps);\r\n}\r\nstatic bool skl_check_ep_match(struct device *dev, struct nhlt_endpoint *epnt,\r\nu32 instance_id, u8 link_type, u8 dirn, u8 dev_type)\r\n{\r\ndev_dbg(dev, "vbus_id=%d link_type=%d dir=%d dev_type = %d\n",\r\nepnt->virtual_bus_id, epnt->linktype,\r\nepnt->direction, epnt->device_type);\r\nif ((epnt->virtual_bus_id == instance_id) &&\r\n(epnt->linktype == link_type) &&\r\n(epnt->direction == dirn) &&\r\n(epnt->device_type == dev_type))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstruct nhlt_specific_cfg\r\n*skl_get_ep_blob(struct skl *skl, u32 instance, u8 link_type,\r\nu8 s_fmt, u8 num_ch, u32 s_rate,\r\nu8 dirn, u8 dev_type)\r\n{\r\nstruct nhlt_fmt *fmt;\r\nstruct nhlt_endpoint *epnt;\r\nstruct hdac_bus *bus = ebus_to_hbus(&skl->ebus);\r\nstruct device *dev = bus->dev;\r\nstruct nhlt_specific_cfg *sp_config;\r\nstruct nhlt_acpi_table *nhlt = skl->nhlt;\r\nu16 bps = (s_fmt == 16) ? 16 : 32;\r\nu8 j;\r\ndump_config(dev, instance, link_type, s_fmt, num_ch, s_rate, dirn, bps);\r\nepnt = (struct nhlt_endpoint *)nhlt->desc;\r\ndev_dbg(dev, "endpoint count =%d\n", nhlt->endpoint_count);\r\nfor (j = 0; j < nhlt->endpoint_count; j++) {\r\nif (skl_check_ep_match(dev, epnt, instance, link_type,\r\ndirn, dev_type)) {\r\nfmt = (struct nhlt_fmt *)(epnt->config.caps +\r\nepnt->config.size);\r\nsp_config = skl_get_specific_cfg(dev, fmt, num_ch,\r\ns_rate, bps, link_type);\r\nif (sp_config)\r\nreturn sp_config;\r\n}\r\nepnt = (struct nhlt_endpoint *)((u8 *)epnt + epnt->length);\r\n}\r\nreturn NULL;\r\n}\r\nint skl_get_dmic_geo(struct skl *skl)\r\n{\r\nstruct nhlt_acpi_table *nhlt = (struct nhlt_acpi_table *)skl->nhlt;\r\nstruct nhlt_endpoint *epnt;\r\nstruct nhlt_dmic_array_config *cfg;\r\nstruct device *dev = &skl->pci->dev;\r\nunsigned int dmic_geo = 0;\r\nu8 j;\r\nepnt = (struct nhlt_endpoint *)nhlt->desc;\r\nfor (j = 0; j < nhlt->endpoint_count; j++) {\r\nif (epnt->linktype == NHLT_LINK_DMIC) {\r\ncfg = (struct nhlt_dmic_array_config *)\r\n(epnt->config.caps);\r\nswitch (cfg->array_type) {\r\ncase NHLT_MIC_ARRAY_2CH_SMALL:\r\ncase NHLT_MIC_ARRAY_2CH_BIG:\r\ndmic_geo |= MIC_ARRAY_2CH;\r\nbreak;\r\ncase NHLT_MIC_ARRAY_4CH_1ST_GEOM:\r\ncase NHLT_MIC_ARRAY_4CH_L_SHAPED:\r\ncase NHLT_MIC_ARRAY_4CH_2ND_GEOM:\r\ndmic_geo |= MIC_ARRAY_4CH;\r\nbreak;\r\ndefault:\r\ndev_warn(dev, "undefined DMIC array_type 0x%0x\n",\r\ncfg->array_type);\r\n}\r\n}\r\nepnt = (struct nhlt_endpoint *)((u8 *)epnt + epnt->length);\r\n}\r\nreturn dmic_geo;\r\n}\r\nstatic void skl_nhlt_trim_space(char *trim)\r\n{\r\nchar *s = trim;\r\nint cnt;\r\nint i;\r\ncnt = 0;\r\nfor (i = 0; s[i]; i++) {\r\nif (!isspace(s[i]))\r\ns[cnt++] = s[i];\r\n}\r\ns[cnt] = '\0';\r\n}\r\nint skl_nhlt_update_topology_bin(struct skl *skl)\r\n{\r\nstruct nhlt_acpi_table *nhlt = (struct nhlt_acpi_table *)skl->nhlt;\r\nstruct hdac_bus *bus = ebus_to_hbus(&skl->ebus);\r\nstruct device *dev = bus->dev;\r\ndev_dbg(dev, "oem_id %.6s, oem_table_id %8s oem_revision %d\n",\r\nnhlt->header.oem_id, nhlt->header.oem_table_id,\r\nnhlt->header.oem_revision);\r\nsnprintf(skl->tplg_name, sizeof(skl->tplg_name), "%x-%.6s-%.8s-%d%s",\r\nskl->pci_id, nhlt->header.oem_id, nhlt->header.oem_table_id,\r\nnhlt->header.oem_revision, "-tplg.bin");\r\nskl_nhlt_trim_space(skl->tplg_name);\r\nreturn 0;\r\n}\r\nstatic ssize_t skl_nhlt_platform_id_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct hdac_ext_bus *ebus = pci_get_drvdata(pci);\r\nstruct skl *skl = ebus_to_skl(ebus);\r\nstruct nhlt_acpi_table *nhlt = (struct nhlt_acpi_table *)skl->nhlt;\r\nchar platform_id[32];\r\nsprintf(platform_id, "%x-%.6s-%.8s-%d", skl->pci_id,\r\nnhlt->header.oem_id, nhlt->header.oem_table_id,\r\nnhlt->header.oem_revision);\r\nskl_nhlt_trim_space(platform_id);\r\nreturn sprintf(buf, "%s\n", platform_id);\r\n}\r\nint skl_nhlt_create_sysfs(struct skl *skl)\r\n{\r\nstruct device *dev = &skl->pci->dev;\r\nif (sysfs_create_file(&dev->kobj, &dev_attr_platform_id.attr))\r\ndev_warn(dev, "Error creating sysfs entry\n");\r\nreturn 0;\r\n}\r\nvoid skl_nhlt_remove_sysfs(struct skl *skl)\r\n{\r\nstruct device *dev = &skl->pci->dev;\r\nsysfs_remove_file(&dev->kobj, &dev_attr_platform_id.attr);\r\n}
