static int compat_mga_init(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_mga_init32_t init32;\r\ndrm_mga_init_t init;\r\nif (copy_from_user(&init32, (void __user *)arg, sizeof(init32)))\r\nreturn -EFAULT;\r\ninit.func = init32.func;\r\ninit.sarea_priv_offset = init32.sarea_priv_offset;\r\nmemcpy(&init.chipset, &init32.chipset,\r\noffsetof(drm_mga_init_t, fb_offset) -\r\noffsetof(drm_mga_init_t, chipset));\r\ninit.fb_offset = init32.fb_offset;\r\ninit.mmio_offset = init32.mmio_offset;\r\ninit.status_offset = init32.status_offset;\r\ninit.warp_offset = init32.warp_offset;\r\ninit.primary_offset = init32.primary_offset;\r\ninit.buffers_offset = init32.buffers_offset;\r\nreturn drm_ioctl_kernel(file, mga_dma_init, &init,\r\nDRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY);\r\n}\r\nstatic int compat_mga_getparam(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_mga_getparam32_t getparam32;\r\ndrm_mga_getparam_t getparam;\r\nif (copy_from_user(&getparam32, (void __user *)arg, sizeof(getparam32)))\r\nreturn -EFAULT;\r\ngetparam.param = getparam32.param;\r\ngetparam.value = compat_ptr(getparam32.value);\r\nreturn drm_ioctl_kernel(file, mga_getparam, &getparam, DRM_AUTH);\r\n}\r\nstatic int compat_mga_dma_bootstrap(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_mga_dma_bootstrap32_t dma_bootstrap32;\r\ndrm_mga_dma_bootstrap_t dma_bootstrap;\r\nint err;\r\nif (copy_from_user(&dma_bootstrap32, (void __user *)arg,\r\nsizeof(dma_bootstrap32)))\r\nreturn -EFAULT;\r\ndma_bootstrap.texture_handle = dma_bootstrap32.texture_handle;\r\ndma_bootstrap.texture_size = dma_bootstrap32.texture_size;\r\ndma_bootstrap.primary_size = dma_bootstrap32.primary_size;\r\ndma_bootstrap.secondary_bin_count = dma_bootstrap32.secondary_bin_count;\r\ndma_bootstrap.secondary_bin_size = dma_bootstrap32.secondary_bin_size;\r\ndma_bootstrap.agp_mode = dma_bootstrap32.agp_mode;\r\ndma_bootstrap.agp_size = dma_bootstrap32.agp_size;\r\nerr = drm_ioctl_kernel(file, mga_dma_bootstrap, &dma_bootstrap,\r\nDRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY);\r\nif (err)\r\nreturn err;\r\ndma_bootstrap32.texture_handle = dma_bootstrap.texture_handle;\r\ndma_bootstrap32.texture_size = dma_bootstrap.texture_size;\r\ndma_bootstrap32.primary_size = dma_bootstrap.primary_size;\r\ndma_bootstrap32.secondary_bin_count = dma_bootstrap.secondary_bin_count;\r\ndma_bootstrap32.secondary_bin_size = dma_bootstrap.secondary_bin_size;\r\ndma_bootstrap32.agp_mode = dma_bootstrap.agp_mode;\r\ndma_bootstrap32.agp_size = dma_bootstrap.agp_size;\r\nif (copy_to_user((void __user *)arg, &dma_bootstrap32,\r\nsizeof(dma_bootstrap32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nlong mga_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nunsigned int nr = DRM_IOCTL_NR(cmd);\r\nstruct drm_file *file_priv = filp->private_data;\r\ndrm_ioctl_compat_t *fn = NULL;\r\nint ret;\r\nif (nr < DRM_COMMAND_BASE)\r\nreturn drm_compat_ioctl(filp, cmd, arg);\r\nif (nr >= DRM_COMMAND_BASE + ARRAY_SIZE(mga_compat_ioctls))\r\nreturn drm_ioctl(filp, cmd, arg);\r\nfn = mga_compat_ioctls[nr - DRM_COMMAND_BASE].fn;\r\nif (!fn)\r\nreturn drm_ioctl(filp, cmd, arg);\r\nDRM_DEBUG("pid=%d, dev=0x%lx, auth=%d, %s\n",\r\ntask_pid_nr(current),\r\n(long)old_encode_dev(file_priv->minor->kdev->devt),\r\nfile_priv->authenticated,\r\nmga_compat_ioctls[nr - DRM_COMMAND_BASE].name);\r\nret = (*fn) (filp, cmd, arg);\r\nif (ret)\r\nDRM_DEBUG("ret = %d\n", ret);\r\nreturn ret;\r\n}
