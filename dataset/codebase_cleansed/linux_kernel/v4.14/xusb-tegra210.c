static inline struct tegra210_xusb_padctl *\r\nto_tegra210_xusb_padctl(struct tegra_xusb_padctl *padctl)\r\n{\r\nreturn container_of(padctl, struct tegra210_xusb_padctl, base);\r\n}\r\nstatic int tegra210_pex_uphy_enable(struct tegra_xusb_padctl *padctl)\r\n{\r\nstruct tegra_xusb_pcie_pad *pcie = to_pcie_pad(padctl->pcie);\r\nunsigned long timeout;\r\nu32 value;\r\nint err;\r\nif (pcie->enable > 0) {\r\npcie->enable++;\r\nreturn 0;\r\n}\r\nerr = clk_prepare_enable(pcie->pll);\r\nif (err < 0)\r\nreturn err;\r\nerr = reset_control_deassert(pcie->rst);\r\nif (err < 0)\r\ngoto disable;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\r\nvalue &= ~(XUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_MASK <<\r\nXUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_SHIFT);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_VAL <<\r\nXUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_SHIFT;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL5);\r\nvalue &= ~(XUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_MASK <<\r\nXUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_SHIFT);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_VAL <<\r\nXUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_SHIFT;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL5);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL1_PWR_OVRD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL2_CAL_OVRD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_OVRD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL4);\r\nvalue &= ~((XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_MASK <<\r\nXUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_SHIFT) |\r\n(XUSB_PADCTL_UPHY_PLL_CTL4_REFCLK_SEL_MASK <<\r\nXUSB_PADCTL_UPHY_PLL_CTL4_REFCLK_SEL_SHIFT));\r\nvalue |= (XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_USB_VAL <<\r\nXUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_SHIFT) |\r\nXUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL4);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\r\nvalue &= ~((XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_MDIV_MASK <<\r\nXUSB_PADCTL_UPHY_PLL_CTL1_FREQ_MDIV_SHIFT) |\r\n(XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_MASK <<\r\nXUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_SHIFT));\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_USB_VAL <<\r\nXUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_SHIFT;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\r\nvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL1_IDDQ;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\r\nvalue &= ~(XUSB_PADCTL_UPHY_PLL_CTL1_SLEEP_MASK <<\r\nXUSB_PADCTL_UPHY_PLL_CTL1_SLEEP_SHIFT);\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\r\nusleep_range(10, 20);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL4);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL4_REFCLKBUF_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL4);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL2_CAL_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\r\nif (value & XUSB_PADCTL_UPHY_PLL_CTL2_CAL_DONE)\r\nbreak;\r\nusleep_range(10, 20);\r\n}\r\nif (time_after_eq(jiffies, timeout)) {\r\nerr = -ETIMEDOUT;\r\ngoto reset;\r\n}\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\r\nvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL2_CAL_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\r\nif (!(value & XUSB_PADCTL_UPHY_PLL_CTL2_CAL_DONE))\r\nbreak;\r\nusleep_range(10, 20);\r\n}\r\nif (time_after_eq(jiffies, timeout)) {\r\nerr = -ETIMEDOUT;\r\ngoto reset;\r\n}\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL1_ENABLE;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\r\nif (value & XUSB_PADCTL_UPHY_PLL_CTL1_LOCKDET_STATUS)\r\nbreak;\r\nusleep_range(10, 20);\r\n}\r\nif (time_after_eq(jiffies, timeout)) {\r\nerr = -ETIMEDOUT;\r\ngoto reset;\r\n}\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_EN |\r\nXUSB_PADCTL_UPHY_PLL_CTL8_RCAL_CLK_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\r\nif (value & XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_DONE)\r\nbreak;\r\nusleep_range(10, 20);\r\n}\r\nif (time_after_eq(jiffies, timeout)) {\r\nerr = -ETIMEDOUT;\r\ngoto reset;\r\n}\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\r\nvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\r\nif (!(value & XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_DONE))\r\nbreak;\r\nusleep_range(10, 20);\r\n}\r\nif (time_after_eq(jiffies, timeout)) {\r\nerr = -ETIMEDOUT;\r\ngoto reset;\r\n}\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\r\nvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_CLK_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\r\ntegra210_xusb_pll_hw_control_enable();\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\r\nvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL1_PWR_OVRD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\r\nvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL2_CAL_OVRD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\r\nvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_OVRD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\r\nusleep_range(10, 20);\r\ntegra210_xusb_pll_hw_sequence_start();\r\npcie->enable++;\r\nreturn 0;\r\nreset:\r\nreset_control_assert(pcie->rst);\r\ndisable:\r\nclk_disable_unprepare(pcie->pll);\r\nreturn err;\r\n}\r\nstatic void tegra210_pex_uphy_disable(struct tegra_xusb_padctl *padctl)\r\n{\r\nstruct tegra_xusb_pcie_pad *pcie = to_pcie_pad(padctl->pcie);\r\nmutex_lock(&padctl->lock);\r\nif (WARN_ON(pcie->enable == 0))\r\ngoto unlock;\r\nif (--pcie->enable > 0)\r\ngoto unlock;\r\nreset_control_assert(pcie->rst);\r\nclk_disable_unprepare(pcie->pll);\r\nunlock:\r\nmutex_unlock(&padctl->lock);\r\n}\r\nstatic int tegra210_sata_uphy_enable(struct tegra_xusb_padctl *padctl, bool usb)\r\n{\r\nstruct tegra_xusb_sata_pad *sata = to_sata_pad(padctl->sata);\r\nunsigned long timeout;\r\nu32 value;\r\nint err;\r\nif (sata->enable > 0) {\r\nsata->enable++;\r\nreturn 0;\r\n}\r\nerr = clk_prepare_enable(sata->pll);\r\nif (err < 0)\r\nreturn err;\r\nerr = reset_control_deassert(sata->rst);\r\nif (err < 0)\r\ngoto disable;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\r\nvalue &= ~(XUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_MASK <<\r\nXUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_SHIFT);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_VAL <<\r\nXUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_SHIFT;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL5);\r\nvalue &= ~(XUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_MASK <<\r\nXUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_SHIFT);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_VAL <<\r\nXUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_SHIFT;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL5);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL1_PWR_OVRD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL2_CAL_OVRD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_OVRD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL4);\r\nvalue &= ~((XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_MASK <<\r\nXUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_SHIFT) |\r\n(XUSB_PADCTL_UPHY_PLL_CTL4_REFCLK_SEL_MASK <<\r\nXUSB_PADCTL_UPHY_PLL_CTL4_REFCLK_SEL_SHIFT));\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_EN;\r\nif (usb)\r\nvalue |= (XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_USB_VAL <<\r\nXUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_SHIFT);\r\nelse\r\nvalue |= (XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_SATA_VAL <<\r\nXUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_SHIFT);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\r\nvalue &= ~((XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_MDIV_MASK <<\r\nXUSB_PADCTL_UPHY_PLL_CTL1_FREQ_MDIV_SHIFT) |\r\n(XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_MASK <<\r\nXUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_SHIFT));\r\nif (usb)\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_USB_VAL <<\r\nXUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_SHIFT;\r\nelse\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_SATA_VAL <<\r\nXUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_SHIFT;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\r\nvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL1_IDDQ;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\r\nvalue &= ~(XUSB_PADCTL_UPHY_PLL_CTL1_SLEEP_MASK <<\r\nXUSB_PADCTL_UPHY_PLL_CTL1_SLEEP_SHIFT);\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\r\nusleep_range(10, 20);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL4);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL4_REFCLKBUF_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL4);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL2_CAL_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\r\nif (value & XUSB_PADCTL_UPHY_PLL_CTL2_CAL_DONE)\r\nbreak;\r\nusleep_range(10, 20);\r\n}\r\nif (time_after_eq(jiffies, timeout)) {\r\nerr = -ETIMEDOUT;\r\ngoto reset;\r\n}\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\r\nvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL2_CAL_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\r\nif (!(value & XUSB_PADCTL_UPHY_PLL_CTL2_CAL_DONE))\r\nbreak;\r\nusleep_range(10, 20);\r\n}\r\nif (time_after_eq(jiffies, timeout)) {\r\nerr = -ETIMEDOUT;\r\ngoto reset;\r\n}\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL1_ENABLE;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\r\nif (value & XUSB_PADCTL_UPHY_PLL_CTL1_LOCKDET_STATUS)\r\nbreak;\r\nusleep_range(10, 20);\r\n}\r\nif (time_after_eq(jiffies, timeout)) {\r\nerr = -ETIMEDOUT;\r\ngoto reset;\r\n}\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\r\nvalue |= XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_EN |\r\nXUSB_PADCTL_UPHY_PLL_CTL8_RCAL_CLK_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\r\nif (value & XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_DONE)\r\nbreak;\r\nusleep_range(10, 20);\r\n}\r\nif (time_after_eq(jiffies, timeout)) {\r\nerr = -ETIMEDOUT;\r\ngoto reset;\r\n}\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\r\nvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\r\nif (!(value & XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_DONE))\r\nbreak;\r\nusleep_range(10, 20);\r\n}\r\nif (time_after_eq(jiffies, timeout)) {\r\nerr = -ETIMEDOUT;\r\ngoto reset;\r\n}\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\r\nvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_CLK_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\r\ntegra210_sata_pll_hw_control_enable();\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\r\nvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL1_PWR_OVRD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\r\nvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL2_CAL_OVRD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\r\nvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_OVRD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\r\nusleep_range(10, 20);\r\ntegra210_sata_pll_hw_sequence_start();\r\nsata->enable++;\r\nreturn 0;\r\nreset:\r\nreset_control_assert(sata->rst);\r\ndisable:\r\nclk_disable_unprepare(sata->pll);\r\nreturn err;\r\n}\r\nstatic void tegra210_sata_uphy_disable(struct tegra_xusb_padctl *padctl)\r\n{\r\nstruct tegra_xusb_sata_pad *sata = to_sata_pad(padctl->sata);\r\nmutex_lock(&padctl->lock);\r\nif (WARN_ON(sata->enable == 0))\r\ngoto unlock;\r\nif (--sata->enable > 0)\r\ngoto unlock;\r\nreset_control_assert(sata->rst);\r\nclk_disable_unprepare(sata->pll);\r\nunlock:\r\nmutex_unlock(&padctl->lock);\r\n}\r\nstatic int tegra210_xusb_padctl_enable(struct tegra_xusb_padctl *padctl)\r\n{\r\nu32 value;\r\nmutex_lock(&padctl->lock);\r\nif (padctl->enable++ > 0)\r\ngoto out;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\r\nvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_AUX_MUX_LP0_CLAMP_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\r\nvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_AUX_MUX_LP0_CLAMP_EN_EARLY;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\r\nvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_AUX_MUX_LP0_VCORE_DOWN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\r\nout:\r\nmutex_unlock(&padctl->lock);\r\nreturn 0;\r\n}\r\nstatic int tegra210_xusb_padctl_disable(struct tegra_xusb_padctl *padctl)\r\n{\r\nu32 value;\r\nmutex_lock(&padctl->lock);\r\nif (WARN_ON(padctl->enable == 0))\r\ngoto out;\r\nif (--padctl->enable > 0)\r\ngoto out;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\r\nvalue |= XUSB_PADCTL_ELPG_PROGRAM1_AUX_MUX_LP0_VCORE_DOWN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\r\nvalue |= XUSB_PADCTL_ELPG_PROGRAM1_AUX_MUX_LP0_CLAMP_EN_EARLY;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\r\nvalue |= XUSB_PADCTL_ELPG_PROGRAM1_AUX_MUX_LP0_CLAMP_EN;\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\r\nout:\r\nmutex_unlock(&padctl->lock);\r\nreturn 0;\r\n}\r\nstatic int tegra210_hsic_set_idle(struct tegra_xusb_padctl *padctl,\r\nunsigned int index, bool idle)\r\n{\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL0(index));\r\nvalue &= ~(XUSB_PADCTL_HSIC_PAD_CTL0_RPU_DATA0 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_RPU_DATA1 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_RPD_STROBE);\r\nif (idle)\r\nvalue |= XUSB_PADCTL_HSIC_PAD_CTL0_RPD_DATA0 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_RPD_DATA1 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_RPU_STROBE;\r\nelse\r\nvalue &= ~(XUSB_PADCTL_HSIC_PAD_CTL0_RPD_DATA0 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_RPD_DATA1 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_RPU_STROBE);\r\npadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL0(index));\r\nreturn 0;\r\n}\r\nstatic int tegra210_usb3_set_lfps_detect(struct tegra_xusb_padctl *padctl,\r\nunsigned int index, bool enable)\r\n{\r\nstruct tegra_xusb_port *port;\r\nstruct tegra_xusb_lane *lane;\r\nu32 value, offset;\r\nport = tegra_xusb_find_port(padctl, "usb3", index);\r\nif (!port)\r\nreturn -ENODEV;\r\nlane = port->lane;\r\nif (lane->pad == padctl->pcie)\r\noffset = XUSB_PADCTL_UPHY_MISC_PAD_PX_CTL1(lane->index);\r\nelse\r\noffset = XUSB_PADCTL_UPHY_MISC_PAD_S0_CTL1;\r\nvalue = padctl_readl(padctl, offset);\r\nvalue &= ~((XUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_IDLE_MODE_MASK <<\r\nXUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_IDLE_MODE_SHIFT) |\r\nXUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_TERM_EN |\r\nXUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_MODE_OVRD);\r\nif (!enable) {\r\nvalue |= (XUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_IDLE_MODE_VAL <<\r\nXUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_IDLE_MODE_SHIFT) |\r\nXUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_TERM_EN |\r\nXUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_MODE_OVRD;\r\n}\r\npadctl_writel(padctl, value, offset);\r\nreturn 0;\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra210_usb2_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_usb2_lane *usb2;\r\nint err;\r\nusb2 = kzalloc(sizeof(*usb2), GFP_KERNEL);\r\nif (!usb2)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&usb2->base.list);\r\nusb2->base.soc = &pad->soc->lanes[index];\r\nusb2->base.index = index;\r\nusb2->base.pad = pad;\r\nusb2->base.np = np;\r\nerr = tegra_xusb_lane_parse_dt(&usb2->base, np);\r\nif (err < 0) {\r\nkfree(usb2);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn &usb2->base;\r\n}\r\nstatic void tegra210_usb2_lane_remove(struct tegra_xusb_lane *lane)\r\n{\r\nstruct tegra_xusb_usb2_lane *usb2 = to_usb2_lane(lane);\r\nkfree(usb2);\r\n}\r\nstatic int tegra210_usb2_phy_init(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_PAD_MUX);\r\nvalue &= ~(XUSB_PADCTL_USB2_PAD_MUX_USB2_BIAS_PAD_MASK <<\r\nXUSB_PADCTL_USB2_PAD_MUX_USB2_BIAS_PAD_SHIFT);\r\nvalue |= XUSB_PADCTL_USB2_PAD_MUX_USB2_BIAS_PAD_XUSB <<\r\nXUSB_PADCTL_USB2_PAD_MUX_USB2_BIAS_PAD_SHIFT;\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_PAD_MUX);\r\nreturn tegra210_xusb_padctl_enable(padctl);\r\n}\r\nstatic int tegra210_usb2_phy_exit(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra210_xusb_padctl_disable(lane->pad->padctl);\r\n}\r\nstatic int tegra210_usb2_phy_power_on(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_usb2_lane *usb2 = to_usb2_lane(lane);\r\nstruct tegra_xusb_usb2_pad *pad = to_usb2_pad(lane->pad);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nstruct tegra210_xusb_padctl *priv;\r\nstruct tegra_xusb_usb2_port *port;\r\nunsigned int index = lane->index;\r\nu32 value;\r\nint err;\r\nport = tegra_xusb_find_usb2_port(padctl, index);\r\nif (!port) {\r\ndev_err(&phy->dev, "no port found for USB2 lane %u\n", index);\r\nreturn -ENODEV;\r\n}\r\npriv = to_tegra210_xusb_padctl(padctl);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\r\nvalue &= ~((XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_MASK <<\r\nXUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_SHIFT) |\r\n(XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_MASK <<\r\nXUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_SHIFT));\r\nvalue |= (XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_VAL <<\r\nXUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_SHIFT);\r\nif (tegra_sku_info.revision < TEGRA_REVISION_A02)\r\nvalue |=\r\n(XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_VAL <<\r\nXUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_SHIFT);\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_PORT_CAP);\r\nvalue &= ~XUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_MASK(index);\r\nvalue |= XUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_HOST(index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_PORT_CAP);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));\r\nvalue &= ~((XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_MASK <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_SHIFT) |\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL0_PD |\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL0_PD2 |\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL0_PD_ZI);\r\nvalue |= (priv->fuse.hs_curr_level[index] +\r\nusb2->hs_curr_level_offset) <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_SHIFT;\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));\r\nvalue &= ~((XUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_MASK <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_SHIFT) |\r\n(XUSB_PADCTL_USB2_OTG_PAD_CTL1_RPD_CTRL_MASK <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL1_RPD_CTRL_SHIFT) |\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_DR |\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_CHRP_OVRD |\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_DISC_OVRD);\r\nvalue |= (priv->fuse.hs_term_range_adj <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_SHIFT) |\r\n(priv->fuse.rpd_ctrl <<\r\nXUSB_PADCTL_USB2_OTG_PAD_CTL1_RPD_CTRL_SHIFT);\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));\r\nvalue = padctl_readl(padctl,\r\nXUSB_PADCTL_USB2_BATTERY_CHRG_OTGPADX_CTL1(index));\r\nvalue &= ~(XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL1_VREG_LEV_MASK <<\r\nXUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL1_VREG_LEV_SHIFT);\r\nvalue |= XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL1_VREG_FIX18;\r\npadctl_writel(padctl, value,\r\nXUSB_PADCTL_USB2_BATTERY_CHRG_OTGPADX_CTL1(index));\r\nerr = regulator_enable(port->supply);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&padctl->lock);\r\nif (pad->enable > 0) {\r\npad->enable++;\r\nmutex_unlock(&padctl->lock);\r\nreturn 0;\r\n}\r\nerr = clk_prepare_enable(pad->clk);\r\nif (err)\r\ngoto disable_regulator;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\r\nvalue &= ~((XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_START_TIMER_MASK <<\r\nXUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_START_TIMER_SHIFT) |\r\n(XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_DONE_RESET_TIMER_MASK <<\r\nXUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_DONE_RESET_TIMER_SHIFT));\r\nvalue |= (XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_START_TIMER_VAL <<\r\nXUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_START_TIMER_SHIFT) |\r\n(XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_DONE_RESET_TIMER_VAL <<\r\nXUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_DONE_RESET_TIMER_SHIFT);\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\r\nvalue &= ~XUSB_PADCTL_USB2_BIAS_PAD_CTL0_PD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\r\nudelay(1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\r\nvalue &= ~XUSB_PADCTL_USB2_BIAS_PAD_CTL1_PD_TRK;\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\r\nudelay(50);\r\nclk_disable_unprepare(pad->clk);\r\npad->enable++;\r\nmutex_unlock(&padctl->lock);\r\nreturn 0;\r\ndisable_regulator:\r\nregulator_disable(port->supply);\r\nmutex_unlock(&padctl->lock);\r\nreturn err;\r\n}\r\nstatic int tegra210_usb2_phy_power_off(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_usb2_pad *pad = to_usb2_pad(lane->pad);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nstruct tegra_xusb_usb2_port *port;\r\nu32 value;\r\nport = tegra_xusb_find_usb2_port(padctl, lane->index);\r\nif (!port) {\r\ndev_err(&phy->dev, "no port found for USB2 lane %u\n",\r\nlane->index);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&padctl->lock);\r\nif (WARN_ON(pad->enable == 0))\r\ngoto out;\r\nif (--pad->enable > 0)\r\ngoto out;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\r\nvalue |= XUSB_PADCTL_USB2_BIAS_PAD_CTL0_PD;\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\r\nout:\r\nregulator_disable(port->supply);\r\nmutex_unlock(&padctl->lock);\r\nreturn 0;\r\n}\r\nstatic struct tegra_xusb_pad *\r\ntegra210_usb2_pad_probe(struct tegra_xusb_padctl *padctl,\r\nconst struct tegra_xusb_pad_soc *soc,\r\nstruct device_node *np)\r\n{\r\nstruct tegra_xusb_usb2_pad *usb2;\r\nstruct tegra_xusb_pad *pad;\r\nint err;\r\nusb2 = kzalloc(sizeof(*usb2), GFP_KERNEL);\r\nif (!usb2)\r\nreturn ERR_PTR(-ENOMEM);\r\npad = &usb2->base;\r\npad->ops = &tegra210_usb2_lane_ops;\r\npad->soc = soc;\r\nerr = tegra_xusb_pad_init(pad, padctl, np);\r\nif (err < 0) {\r\nkfree(usb2);\r\ngoto out;\r\n}\r\nusb2->clk = devm_clk_get(&pad->dev, "trk");\r\nif (IS_ERR(usb2->clk)) {\r\nerr = PTR_ERR(usb2->clk);\r\ndev_err(&pad->dev, "failed to get trk clock: %d\n", err);\r\ngoto unregister;\r\n}\r\nerr = tegra_xusb_pad_register(pad, &tegra210_usb2_phy_ops);\r\nif (err < 0)\r\ngoto unregister;\r\ndev_set_drvdata(&pad->dev, pad);\r\nreturn pad;\r\nunregister:\r\ndevice_unregister(&pad->dev);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void tegra210_usb2_pad_remove(struct tegra_xusb_pad *pad)\r\n{\r\nstruct tegra_xusb_usb2_pad *usb2 = to_usb2_pad(pad);\r\nkfree(usb2);\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra210_hsic_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_hsic_lane *hsic;\r\nint err;\r\nhsic = kzalloc(sizeof(*hsic), GFP_KERNEL);\r\nif (!hsic)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&hsic->base.list);\r\nhsic->base.soc = &pad->soc->lanes[index];\r\nhsic->base.index = index;\r\nhsic->base.pad = pad;\r\nhsic->base.np = np;\r\nerr = tegra_xusb_lane_parse_dt(&hsic->base, np);\r\nif (err < 0) {\r\nkfree(hsic);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn &hsic->base;\r\n}\r\nstatic void tegra210_hsic_lane_remove(struct tegra_xusb_lane *lane)\r\n{\r\nstruct tegra_xusb_hsic_lane *hsic = to_hsic_lane(lane);\r\nkfree(hsic);\r\n}\r\nstatic int tegra210_hsic_phy_init(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_PAD_MUX);\r\nvalue &= ~(XUSB_PADCTL_USB2_PAD_MUX_HSIC_PAD_TRK_MASK <<\r\nXUSB_PADCTL_USB2_PAD_MUX_HSIC_PAD_TRK_SHIFT);\r\nvalue |= XUSB_PADCTL_USB2_PAD_MUX_HSIC_PAD_TRK_XUSB <<\r\nXUSB_PADCTL_USB2_PAD_MUX_HSIC_PAD_TRK_SHIFT;\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB2_PAD_MUX);\r\nreturn tegra210_xusb_padctl_enable(padctl);\r\n}\r\nstatic int tegra210_hsic_phy_exit(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra210_xusb_padctl_disable(lane->pad->padctl);\r\n}\r\nstatic int tegra210_hsic_phy_power_on(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_hsic_lane *hsic = to_hsic_lane(lane);\r\nstruct tegra_xusb_hsic_pad *pad = to_hsic_pad(lane->pad);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nstruct tegra210_xusb_padctl *priv;\r\nunsigned int index = lane->index;\r\nu32 value;\r\nint err;\r\npriv = to_tegra210_xusb_padctl(padctl);\r\nerr = regulator_enable(pad->supply);\r\nif (err)\r\nreturn err;\r\npadctl_writel(padctl, hsic->strobe_trim,\r\nXUSB_PADCTL_HSIC_STRB_TRIM_CONTROL);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL1(index));\r\nvalue &= ~(XUSB_PADCTL_HSIC_PAD_CTL1_TX_RTUNEP_MASK <<\r\nXUSB_PADCTL_HSIC_PAD_CTL1_TX_RTUNEP_SHIFT);\r\nvalue |= (hsic->tx_rtune_p <<\r\nXUSB_PADCTL_HSIC_PAD_CTL1_TX_RTUNEP_SHIFT);\r\npadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL1(index));\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL2(index));\r\nvalue &= ~((XUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_MASK <<\r\nXUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_SHIFT) |\r\n(XUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_MASK <<\r\nXUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_SHIFT));\r\nvalue |= (hsic->rx_strobe_trim <<\r\nXUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_SHIFT) |\r\n(hsic->rx_data_trim <<\r\nXUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_SHIFT);\r\npadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL2(index));\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL0(index));\r\nvalue &= ~(XUSB_PADCTL_HSIC_PAD_CTL0_RPU_DATA0 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_RPU_DATA1 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_RPU_STROBE |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_RX_DATA0 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_RX_DATA1 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_RX_STROBE |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_ZI_DATA0 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_ZI_DATA1 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_ZI_STROBE |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_TX_DATA0 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_TX_DATA1 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_TX_STROBE);\r\nvalue |= XUSB_PADCTL_HSIC_PAD_CTL0_RPD_DATA0 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_RPD_DATA1 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_RPD_STROBE;\r\npadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL0(index));\r\nerr = clk_prepare_enable(pad->clk);\r\nif (err)\r\ngoto disable;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PAD_TRK_CTL);\r\nvalue &= ~((XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_START_TIMER_MASK <<\r\nXUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_START_TIMER_SHIFT) |\r\n(XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_DONE_RESET_TIMER_MASK <<\r\nXUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_DONE_RESET_TIMER_SHIFT));\r\nvalue |= (XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_START_TIMER_VAL <<\r\nXUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_START_TIMER_SHIFT) |\r\n(XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_DONE_RESET_TIMER_VAL <<\r\nXUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_DONE_RESET_TIMER_SHIFT);\r\npadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PAD_TRK_CTL);\r\nudelay(1);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PAD_TRK_CTL);\r\nvalue &= ~XUSB_PADCTL_HSIC_PAD_TRK_CTL_PD_TRK;\r\npadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PAD_TRK_CTL);\r\nudelay(50);\r\nclk_disable_unprepare(pad->clk);\r\nreturn 0;\r\ndisable:\r\nregulator_disable(pad->supply);\r\nreturn err;\r\n}\r\nstatic int tegra210_hsic_phy_power_off(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_hsic_pad *pad = to_hsic_pad(lane->pad);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nunsigned int index = lane->index;\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL0(index));\r\nvalue |= XUSB_PADCTL_HSIC_PAD_CTL0_PD_RX_DATA0 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_RX_DATA1 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_RX_STROBE |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_ZI_DATA0 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_ZI_DATA1 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_ZI_STROBE |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_TX_DATA0 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_TX_DATA1 |\r\nXUSB_PADCTL_HSIC_PAD_CTL0_PD_TX_STROBE;\r\npadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL1(index));\r\nregulator_disable(pad->supply);\r\nreturn 0;\r\n}\r\nstatic struct tegra_xusb_pad *\r\ntegra210_hsic_pad_probe(struct tegra_xusb_padctl *padctl,\r\nconst struct tegra_xusb_pad_soc *soc,\r\nstruct device_node *np)\r\n{\r\nstruct tegra_xusb_hsic_pad *hsic;\r\nstruct tegra_xusb_pad *pad;\r\nint err;\r\nhsic = kzalloc(sizeof(*hsic), GFP_KERNEL);\r\nif (!hsic)\r\nreturn ERR_PTR(-ENOMEM);\r\npad = &hsic->base;\r\npad->ops = &tegra210_hsic_lane_ops;\r\npad->soc = soc;\r\nerr = tegra_xusb_pad_init(pad, padctl, np);\r\nif (err < 0) {\r\nkfree(hsic);\r\ngoto out;\r\n}\r\nhsic->clk = devm_clk_get(&pad->dev, "trk");\r\nif (IS_ERR(hsic->clk)) {\r\nerr = PTR_ERR(hsic->clk);\r\ndev_err(&pad->dev, "failed to get trk clock: %d\n", err);\r\ngoto unregister;\r\n}\r\nerr = tegra_xusb_pad_register(pad, &tegra210_hsic_phy_ops);\r\nif (err < 0)\r\ngoto unregister;\r\ndev_set_drvdata(&pad->dev, pad);\r\nreturn pad;\r\nunregister:\r\ndevice_unregister(&pad->dev);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void tegra210_hsic_pad_remove(struct tegra_xusb_pad *pad)\r\n{\r\nstruct tegra_xusb_hsic_pad *hsic = to_hsic_pad(pad);\r\nkfree(hsic);\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra210_pcie_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_pcie_lane *pcie;\r\nint err;\r\npcie = kzalloc(sizeof(*pcie), GFP_KERNEL);\r\nif (!pcie)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&pcie->base.list);\r\npcie->base.soc = &pad->soc->lanes[index];\r\npcie->base.index = index;\r\npcie->base.pad = pad;\r\npcie->base.np = np;\r\nerr = tegra_xusb_lane_parse_dt(&pcie->base, np);\r\nif (err < 0) {\r\nkfree(pcie);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn &pcie->base;\r\n}\r\nstatic void tegra210_pcie_lane_remove(struct tegra_xusb_lane *lane)\r\n{\r\nstruct tegra_xusb_pcie_lane *pcie = to_pcie_lane(lane);\r\nkfree(pcie);\r\n}\r\nstatic int tegra210_pcie_phy_init(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra210_xusb_padctl_enable(lane->pad->padctl);\r\n}\r\nstatic int tegra210_pcie_phy_exit(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra210_xusb_padctl_disable(lane->pad->padctl);\r\n}\r\nstatic int tegra210_pcie_phy_power_on(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nu32 value;\r\nint err;\r\nmutex_lock(&padctl->lock);\r\nerr = tegra210_pex_uphy_enable(padctl);\r\nif (err < 0)\r\ngoto unlock;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\r\nvalue |= XUSB_PADCTL_USB3_PAD_MUX_PCIE_IDDQ_DISABLE(lane->index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\r\nunlock:\r\nmutex_unlock(&padctl->lock);\r\nreturn err;\r\n}\r\nstatic int tegra210_pcie_phy_power_off(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\r\nvalue &= ~XUSB_PADCTL_USB3_PAD_MUX_PCIE_IDDQ_DISABLE(lane->index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\r\ntegra210_pex_uphy_disable(padctl);\r\nreturn 0;\r\n}\r\nstatic struct tegra_xusb_pad *\r\ntegra210_pcie_pad_probe(struct tegra_xusb_padctl *padctl,\r\nconst struct tegra_xusb_pad_soc *soc,\r\nstruct device_node *np)\r\n{\r\nstruct tegra_xusb_pcie_pad *pcie;\r\nstruct tegra_xusb_pad *pad;\r\nint err;\r\npcie = kzalloc(sizeof(*pcie), GFP_KERNEL);\r\nif (!pcie)\r\nreturn ERR_PTR(-ENOMEM);\r\npad = &pcie->base;\r\npad->ops = &tegra210_pcie_lane_ops;\r\npad->soc = soc;\r\nerr = tegra_xusb_pad_init(pad, padctl, np);\r\nif (err < 0) {\r\nkfree(pcie);\r\ngoto out;\r\n}\r\npcie->pll = devm_clk_get(&pad->dev, "pll");\r\nif (IS_ERR(pcie->pll)) {\r\nerr = PTR_ERR(pcie->pll);\r\ndev_err(&pad->dev, "failed to get PLL: %d\n", err);\r\ngoto unregister;\r\n}\r\npcie->rst = devm_reset_control_get(&pad->dev, "phy");\r\nif (IS_ERR(pcie->rst)) {\r\nerr = PTR_ERR(pcie->rst);\r\ndev_err(&pad->dev, "failed to get PCIe pad reset: %d\n", err);\r\ngoto unregister;\r\n}\r\nerr = tegra_xusb_pad_register(pad, &tegra210_pcie_phy_ops);\r\nif (err < 0)\r\ngoto unregister;\r\ndev_set_drvdata(&pad->dev, pad);\r\nreturn pad;\r\nunregister:\r\ndevice_unregister(&pad->dev);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void tegra210_pcie_pad_remove(struct tegra_xusb_pad *pad)\r\n{\r\nstruct tegra_xusb_pcie_pad *pcie = to_pcie_pad(pad);\r\nkfree(pcie);\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra210_sata_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_sata_lane *sata;\r\nint err;\r\nsata = kzalloc(sizeof(*sata), GFP_KERNEL);\r\nif (!sata)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&sata->base.list);\r\nsata->base.soc = &pad->soc->lanes[index];\r\nsata->base.index = index;\r\nsata->base.pad = pad;\r\nsata->base.np = np;\r\nerr = tegra_xusb_lane_parse_dt(&sata->base, np);\r\nif (err < 0) {\r\nkfree(sata);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn &sata->base;\r\n}\r\nstatic void tegra210_sata_lane_remove(struct tegra_xusb_lane *lane)\r\n{\r\nstruct tegra_xusb_sata_lane *sata = to_sata_lane(lane);\r\nkfree(sata);\r\n}\r\nstatic int tegra210_sata_phy_init(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra210_xusb_padctl_enable(lane->pad->padctl);\r\n}\r\nstatic int tegra210_sata_phy_exit(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nreturn tegra210_xusb_padctl_disable(lane->pad->padctl);\r\n}\r\nstatic int tegra210_sata_phy_power_on(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nu32 value;\r\nint err;\r\nmutex_lock(&padctl->lock);\r\nerr = tegra210_sata_uphy_enable(padctl, false);\r\nif (err < 0)\r\ngoto unlock;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\r\nvalue |= XUSB_PADCTL_USB3_PAD_MUX_SATA_IDDQ_DISABLE(lane->index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\r\nunlock:\r\nmutex_unlock(&padctl->lock);\r\nreturn err;\r\n}\r\nstatic int tegra210_sata_phy_power_off(struct phy *phy)\r\n{\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\r\nvalue &= ~XUSB_PADCTL_USB3_PAD_MUX_SATA_IDDQ_DISABLE(lane->index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\r\ntegra210_sata_uphy_disable(lane->pad->padctl);\r\nreturn 0;\r\n}\r\nstatic struct tegra_xusb_pad *\r\ntegra210_sata_pad_probe(struct tegra_xusb_padctl *padctl,\r\nconst struct tegra_xusb_pad_soc *soc,\r\nstruct device_node *np)\r\n{\r\nstruct tegra_xusb_sata_pad *sata;\r\nstruct tegra_xusb_pad *pad;\r\nint err;\r\nsata = kzalloc(sizeof(*sata), GFP_KERNEL);\r\nif (!sata)\r\nreturn ERR_PTR(-ENOMEM);\r\npad = &sata->base;\r\npad->ops = &tegra210_sata_lane_ops;\r\npad->soc = soc;\r\nerr = tegra_xusb_pad_init(pad, padctl, np);\r\nif (err < 0) {\r\nkfree(sata);\r\ngoto out;\r\n}\r\nsata->rst = devm_reset_control_get(&pad->dev, "phy");\r\nif (IS_ERR(sata->rst)) {\r\nerr = PTR_ERR(sata->rst);\r\ndev_err(&pad->dev, "failed to get SATA pad reset: %d\n", err);\r\ngoto unregister;\r\n}\r\nerr = tegra_xusb_pad_register(pad, &tegra210_sata_phy_ops);\r\nif (err < 0)\r\ngoto unregister;\r\ndev_set_drvdata(&pad->dev, pad);\r\nreturn pad;\r\nunregister:\r\ndevice_unregister(&pad->dev);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void tegra210_sata_pad_remove(struct tegra_xusb_pad *pad)\r\n{\r\nstruct tegra_xusb_sata_pad *sata = to_sata_pad(pad);\r\nkfree(sata);\r\n}\r\nstatic int tegra210_usb2_port_enable(struct tegra_xusb_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void tegra210_usb2_port_disable(struct tegra_xusb_port *port)\r\n{\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra210_usb2_port_map(struct tegra_xusb_port *port)\r\n{\r\nreturn tegra_xusb_find_lane(port->padctl, "usb2", port->index);\r\n}\r\nstatic int tegra210_hsic_port_enable(struct tegra_xusb_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void tegra210_hsic_port_disable(struct tegra_xusb_port *port)\r\n{\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra210_hsic_port_map(struct tegra_xusb_port *port)\r\n{\r\nreturn tegra_xusb_find_lane(port->padctl, "hsic", port->index);\r\n}\r\nstatic int tegra210_usb3_port_enable(struct tegra_xusb_port *port)\r\n{\r\nstruct tegra_xusb_usb3_port *usb3 = to_usb3_port(port);\r\nstruct tegra_xusb_padctl *padctl = port->padctl;\r\nstruct tegra_xusb_lane *lane = usb3->base.lane;\r\nunsigned int index = port->index;\r\nu32 value;\r\nint err;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_SS_PORT_MAP);\r\nif (!usb3->internal)\r\nvalue &= ~XUSB_PADCTL_SS_PORT_MAP_PORTX_INTERNAL(index);\r\nelse\r\nvalue |= XUSB_PADCTL_SS_PORT_MAP_PORTX_INTERNAL(index);\r\nvalue &= ~XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP_MASK(index);\r\nvalue |= XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP(index, usb3->port);\r\npadctl_writel(padctl, value, XUSB_PADCTL_SS_PORT_MAP);\r\nerr = regulator_enable(usb3->supply);\r\nif (err < 0)\r\nreturn err;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_USB3_PADX_ECTL1(index));\r\nvalue &= ~(XUSB_PADCTL_UPHY_USB3_PAD_ECTL1_TX_TERM_CTRL_MASK <<\r\nXUSB_PADCTL_UPHY_USB3_PAD_ECTL1_TX_TERM_CTRL_SHIFT);\r\nvalue |= XUSB_PADCTL_UPHY_USB3_PAD_ECTL1_TX_TERM_CTRL_VAL <<\r\nXUSB_PADCTL_UPHY_USB3_PAD_ECTL1_TX_TERM_CTRL_SHIFT;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_USB3_PADX_ECTL1(index));\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_USB3_PADX_ECTL2(index));\r\nvalue &= ~(XUSB_PADCTL_UPHY_USB3_PAD_ECTL2_RX_CTLE_MASK <<\r\nXUSB_PADCTL_UPHY_USB3_PAD_ECTL2_RX_CTLE_SHIFT);\r\nvalue |= XUSB_PADCTL_UPHY_USB3_PAD_ECTL2_RX_CTLE_VAL <<\r\nXUSB_PADCTL_UPHY_USB3_PAD_ECTL2_RX_CTLE_SHIFT;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_USB3_PADX_ECTL2(index));\r\npadctl_writel(padctl, XUSB_PADCTL_UPHY_USB3_PAD_ECTL3_RX_DFE_VAL,\r\nXUSB_PADCTL_UPHY_USB3_PADX_ECTL3(index));\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_USB3_PADX_ECTL4(index));\r\nvalue &= ~(XUSB_PADCTL_UPHY_USB3_PAD_ECTL4_RX_CDR_CTRL_MASK <<\r\nXUSB_PADCTL_UPHY_USB3_PAD_ECTL4_RX_CDR_CTRL_SHIFT);\r\nvalue |= XUSB_PADCTL_UPHY_USB3_PAD_ECTL4_RX_CDR_CTRL_VAL <<\r\nXUSB_PADCTL_UPHY_USB3_PAD_ECTL4_RX_CDR_CTRL_SHIFT;\r\npadctl_writel(padctl, value, XUSB_PADCTL_UPHY_USB3_PADX_ECTL4(index));\r\npadctl_writel(padctl, XUSB_PADCTL_UPHY_USB3_PAD_ECTL6_RX_EQ_CTRL_H_VAL,\r\nXUSB_PADCTL_UPHY_USB3_PADX_ECTL6(index));\r\nif (lane->pad == padctl->sata)\r\nerr = tegra210_sata_uphy_enable(padctl, true);\r\nelse\r\nerr = tegra210_pex_uphy_enable(padctl);\r\nif (err) {\r\ndev_err(&port->dev, "%s: failed to enable UPHY: %d\n",\r\n__func__, err);\r\nreturn err;\r\n}\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\r\nvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_VCORE_DOWN(index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\r\nvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN_EARLY(index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\r\nvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN(index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\r\nreturn 0;\r\n}\r\nstatic void tegra210_usb3_port_disable(struct tegra_xusb_port *port)\r\n{\r\nstruct tegra_xusb_usb3_port *usb3 = to_usb3_port(port);\r\nstruct tegra_xusb_padctl *padctl = port->padctl;\r\nstruct tegra_xusb_lane *lane = port->lane;\r\nunsigned int index = port->index;\r\nu32 value;\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\r\nvalue |= XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN_EARLY(index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\r\nusleep_range(100, 200);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\r\nvalue |= XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN(index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\r\nusleep_range(250, 350);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\r\nvalue |= XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_VCORE_DOWN(index);\r\npadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\r\nif (lane->pad == padctl->sata)\r\ntegra210_sata_uphy_disable(padctl);\r\nelse\r\ntegra210_pex_uphy_disable(padctl);\r\nregulator_disable(usb3->supply);\r\nvalue = padctl_readl(padctl, XUSB_PADCTL_SS_PORT_MAP);\r\nvalue &= ~XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP_MASK(index);\r\nvalue |= XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP(index, 0x7);\r\npadctl_writel(padctl, value, XUSB_PADCTL_SS_PORT_MAP);\r\n}\r\nstatic struct tegra_xusb_lane *\r\ntegra210_usb3_port_map(struct tegra_xusb_port *port)\r\n{\r\nreturn tegra_xusb_port_find_lane(port, tegra210_usb3_map, "usb3-ss");\r\n}\r\nstatic int\r\ntegra210_xusb_read_fuse_calibration(struct tegra210_xusb_fuse_calibration *fuse)\r\n{\r\nunsigned int i;\r\nu32 value;\r\nint err;\r\nerr = tegra_fuse_readl(TEGRA_FUSE_SKU_CALIB_0, &value);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < ARRAY_SIZE(fuse->hs_curr_level); i++) {\r\nfuse->hs_curr_level[i] =\r\n(value >> FUSE_SKU_CALIB_HS_CURR_LEVEL_PADX_SHIFT(i)) &\r\nFUSE_SKU_CALIB_HS_CURR_LEVEL_PAD_MASK;\r\n}\r\nfuse->hs_term_range_adj =\r\n(value >> FUSE_SKU_CALIB_HS_TERM_RANGE_ADJ_SHIFT) &\r\nFUSE_SKU_CALIB_HS_TERM_RANGE_ADJ_MASK;\r\nerr = tegra_fuse_readl(TEGRA_FUSE_USB_CALIB_EXT_0, &value);\r\nif (err < 0)\r\nreturn err;\r\nfuse->rpd_ctrl =\r\n(value >> FUSE_USB_CALIB_EXT_RPD_CTRL_SHIFT) &\r\nFUSE_USB_CALIB_EXT_RPD_CTRL_MASK;\r\nreturn 0;\r\n}\r\nstatic struct tegra_xusb_padctl *\r\ntegra210_xusb_padctl_probe(struct device *dev,\r\nconst struct tegra_xusb_padctl_soc *soc)\r\n{\r\nstruct tegra210_xusb_padctl *padctl;\r\nint err;\r\npadctl = devm_kzalloc(dev, sizeof(*padctl), GFP_KERNEL);\r\nif (!padctl)\r\nreturn ERR_PTR(-ENOMEM);\r\npadctl->base.dev = dev;\r\npadctl->base.soc = soc;\r\nerr = tegra210_xusb_read_fuse_calibration(&padctl->fuse);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nreturn &padctl->base;\r\n}\r\nstatic void tegra210_xusb_padctl_remove(struct tegra_xusb_padctl *padctl)\r\n{\r\n}
