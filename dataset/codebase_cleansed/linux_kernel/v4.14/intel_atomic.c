int intel_digital_connector_atomic_get_property(struct drm_connector *connector,\r\nconst struct drm_connector_state *state,\r\nstruct drm_property *property,\r\nuint64_t *val)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nstruct intel_digital_connector_state *intel_conn_state =\r\nto_intel_digital_connector_state(state);\r\nif (property == dev_priv->force_audio_property)\r\n*val = intel_conn_state->force_audio;\r\nelse if (property == dev_priv->broadcast_rgb_property)\r\n*val = intel_conn_state->broadcast_rgb;\r\nelse {\r\nDRM_DEBUG_ATOMIC("Unknown property %s\n", property->name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint intel_digital_connector_atomic_set_property(struct drm_connector *connector,\r\nstruct drm_connector_state *state,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nstruct intel_digital_connector_state *intel_conn_state =\r\nto_intel_digital_connector_state(state);\r\nif (property == dev_priv->force_audio_property) {\r\nintel_conn_state->force_audio = val;\r\nreturn 0;\r\n}\r\nif (property == dev_priv->broadcast_rgb_property) {\r\nintel_conn_state->broadcast_rgb = val;\r\nreturn 0;\r\n}\r\nDRM_DEBUG_ATOMIC("Unknown property %s\n", property->name);\r\nreturn -EINVAL;\r\n}\r\nint intel_digital_connector_atomic_check(struct drm_connector *conn,\r\nstruct drm_connector_state *new_state)\r\n{\r\nstruct intel_digital_connector_state *new_conn_state =\r\nto_intel_digital_connector_state(new_state);\r\nstruct drm_connector_state *old_state =\r\ndrm_atomic_get_old_connector_state(new_state->state, conn);\r\nstruct intel_digital_connector_state *old_conn_state =\r\nto_intel_digital_connector_state(old_state);\r\nstruct drm_crtc_state *crtc_state;\r\nif (!new_state->crtc)\r\nreturn 0;\r\ncrtc_state = drm_atomic_get_new_crtc_state(new_state->state, new_state->crtc);\r\nif (new_conn_state->force_audio != old_conn_state->force_audio ||\r\nnew_conn_state->broadcast_rgb != old_conn_state->broadcast_rgb ||\r\nnew_conn_state->base.picture_aspect_ratio != old_conn_state->base.picture_aspect_ratio ||\r\nnew_conn_state->base.scaling_mode != old_conn_state->base.scaling_mode)\r\ncrtc_state->mode_changed = true;\r\nreturn 0;\r\n}\r\nstruct drm_connector_state *\r\nintel_digital_connector_duplicate_state(struct drm_connector *connector)\r\n{\r\nstruct intel_digital_connector_state *state;\r\nstate = kmemdup(connector->state, sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn NULL;\r\n__drm_atomic_helper_connector_duplicate_state(connector, &state->base);\r\nreturn &state->base;\r\n}\r\nstruct drm_crtc_state *\r\nintel_crtc_duplicate_state(struct drm_crtc *crtc)\r\n{\r\nstruct intel_crtc_state *crtc_state;\r\ncrtc_state = kmemdup(crtc->state, sizeof(*crtc_state), GFP_KERNEL);\r\nif (!crtc_state)\r\nreturn NULL;\r\n__drm_atomic_helper_crtc_duplicate_state(crtc, &crtc_state->base);\r\ncrtc_state->update_pipe = false;\r\ncrtc_state->disable_lp_wm = false;\r\ncrtc_state->disable_cxsr = false;\r\ncrtc_state->update_wm_pre = false;\r\ncrtc_state->update_wm_post = false;\r\ncrtc_state->fb_changed = false;\r\ncrtc_state->fifo_changed = false;\r\ncrtc_state->wm.need_postvbl_update = false;\r\ncrtc_state->fb_bits = 0;\r\nreturn &crtc_state->base;\r\n}\r\nvoid\r\nintel_crtc_destroy_state(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\ndrm_atomic_helper_crtc_destroy_state(crtc, state);\r\n}\r\nint intel_atomic_setup_scalers(struct drm_i915_private *dev_priv,\r\nstruct intel_crtc *intel_crtc,\r\nstruct intel_crtc_state *crtc_state)\r\n{\r\nstruct drm_plane *plane = NULL;\r\nstruct intel_plane *intel_plane;\r\nstruct intel_plane_state *plane_state = NULL;\r\nstruct intel_crtc_scaler_state *scaler_state =\r\n&crtc_state->scaler_state;\r\nstruct drm_atomic_state *drm_state = crtc_state->base.state;\r\nint num_scalers_need;\r\nint i, j;\r\nnum_scalers_need = hweight32(scaler_state->scaler_users);\r\nif (num_scalers_need > intel_crtc->num_scalers){\r\nDRM_DEBUG_KMS("Too many scaling requests %d > %d\n",\r\nnum_scalers_need, intel_crtc->num_scalers);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < sizeof(scaler_state->scaler_users) * 8; i++) {\r\nint *scaler_id;\r\nconst char *name;\r\nint idx;\r\nif (!(scaler_state->scaler_users & (1 << i)))\r\ncontinue;\r\nif (i == SKL_CRTC_INDEX) {\r\nname = "CRTC";\r\nidx = intel_crtc->base.base.id;\r\nscaler_id = &scaler_state->scaler_id;\r\n} else {\r\nname = "PLANE";\r\nplane = drm_state->planes[i].ptr;\r\nif (!plane) {\r\nstruct drm_plane_state *state;\r\nplane = drm_plane_from_index(&dev_priv->drm, i);\r\nstate = drm_atomic_get_plane_state(drm_state, plane);\r\nif (IS_ERR(state)) {\r\nDRM_DEBUG_KMS("Failed to add [PLANE:%d] to drm_state\n",\r\nplane->base.id);\r\nreturn PTR_ERR(state);\r\n}\r\ncrtc_state->base.planes_changed = true;\r\n}\r\nintel_plane = to_intel_plane(plane);\r\nidx = plane->base.id;\r\nif (WARN_ON(intel_plane->pipe != intel_crtc->pipe)) {\r\ncontinue;\r\n}\r\nplane_state = intel_atomic_get_existing_plane_state(drm_state,\r\nintel_plane);\r\nscaler_id = &plane_state->scaler_id;\r\n}\r\nif (*scaler_id < 0) {\r\nfor (j = 0; j < intel_crtc->num_scalers; j++) {\r\nif (!scaler_state->scalers[j].in_use) {\r\nscaler_state->scalers[j].in_use = 1;\r\n*scaler_id = j;\r\nDRM_DEBUG_KMS("Attached scaler id %u.%u to %s:%d\n",\r\nintel_crtc->pipe, *scaler_id, name, idx);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (WARN_ON(*scaler_id < 0)) {\r\nDRM_DEBUG_KMS("Cannot find scaler for %s:%d\n", name, idx);\r\ncontinue;\r\n}\r\nif (IS_GEMINILAKE(dev_priv) || IS_CANNONLAKE(dev_priv)) {\r\nscaler_state->scalers[*scaler_id].mode = 0;\r\n} else if (num_scalers_need == 1 && intel_crtc->pipe != PIPE_C) {\r\n*scaler_id = 0;\r\nscaler_state->scalers[0].in_use = 1;\r\nscaler_state->scalers[0].mode = PS_SCALER_MODE_HQ;\r\nscaler_state->scalers[1].in_use = 0;\r\n} else {\r\nscaler_state->scalers[*scaler_id].mode = PS_SCALER_MODE_DYN;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstruct drm_atomic_state *\r\nintel_atomic_state_alloc(struct drm_device *dev)\r\n{\r\nstruct intel_atomic_state *state = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state || drm_atomic_state_init(dev, &state->base) < 0) {\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nreturn &state->base;\r\n}\r\nvoid intel_atomic_state_clear(struct drm_atomic_state *s)\r\n{\r\nstruct intel_atomic_state *state = to_intel_atomic_state(s);\r\ndrm_atomic_state_default_clear(&state->base);\r\nstate->dpll_set = state->modeset = false;\r\n}
