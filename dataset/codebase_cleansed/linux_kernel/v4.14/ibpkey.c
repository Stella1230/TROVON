static unsigned int sel_ib_pkey_hashfn(u16 pkey)\r\n{\r\nreturn (pkey & (SEL_PKEY_HASH_SIZE - 1));\r\n}\r\nstatic struct sel_ib_pkey *sel_ib_pkey_find(u64 subnet_prefix, u16 pkey_num)\r\n{\r\nunsigned int idx;\r\nstruct sel_ib_pkey *pkey;\r\nidx = sel_ib_pkey_hashfn(pkey_num);\r\nlist_for_each_entry_rcu(pkey, &sel_ib_pkey_hash[idx].list, list) {\r\nif (pkey->psec.pkey == pkey_num &&\r\npkey->psec.subnet_prefix == subnet_prefix)\r\nreturn pkey;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void sel_ib_pkey_insert(struct sel_ib_pkey *pkey)\r\n{\r\nunsigned int idx;\r\nidx = sel_ib_pkey_hashfn(pkey->psec.pkey);\r\nlist_add_rcu(&pkey->list, &sel_ib_pkey_hash[idx].list);\r\nif (sel_ib_pkey_hash[idx].size == SEL_PKEY_HASH_BKT_LIMIT) {\r\nstruct sel_ib_pkey *tail;\r\ntail = list_entry(\r\nrcu_dereference_protected(\r\nsel_ib_pkey_hash[idx].list.prev,\r\nlockdep_is_held(&sel_ib_pkey_lock)),\r\nstruct sel_ib_pkey, list);\r\nlist_del_rcu(&tail->list);\r\nkfree_rcu(tail, rcu);\r\n} else {\r\nsel_ib_pkey_hash[idx].size++;\r\n}\r\n}\r\nstatic int sel_ib_pkey_sid_slow(u64 subnet_prefix, u16 pkey_num, u32 *sid)\r\n{\r\nint ret;\r\nstruct sel_ib_pkey *pkey;\r\nstruct sel_ib_pkey *new = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sel_ib_pkey_lock, flags);\r\npkey = sel_ib_pkey_find(subnet_prefix, pkey_num);\r\nif (pkey) {\r\n*sid = pkey->psec.sid;\r\nspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\r\nreturn 0;\r\n}\r\nret = security_ib_pkey_sid(subnet_prefix, pkey_num, sid);\r\nif (ret)\r\ngoto out;\r\nnew = kzalloc(sizeof(*new), GFP_ATOMIC);\r\nif (!new)\r\ngoto out;\r\nnew->psec.subnet_prefix = subnet_prefix;\r\nnew->psec.pkey = pkey_num;\r\nnew->psec.sid = *sid;\r\nsel_ib_pkey_insert(new);\r\nout:\r\nspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\r\nreturn ret;\r\n}\r\nint sel_ib_pkey_sid(u64 subnet_prefix, u16 pkey_num, u32 *sid)\r\n{\r\nstruct sel_ib_pkey *pkey;\r\nrcu_read_lock();\r\npkey = sel_ib_pkey_find(subnet_prefix, pkey_num);\r\nif (pkey) {\r\n*sid = pkey->psec.sid;\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nrcu_read_unlock();\r\nreturn sel_ib_pkey_sid_slow(subnet_prefix, pkey_num, sid);\r\n}\r\nvoid sel_ib_pkey_flush(void)\r\n{\r\nunsigned int idx;\r\nstruct sel_ib_pkey *pkey, *pkey_tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sel_ib_pkey_lock, flags);\r\nfor (idx = 0; idx < SEL_PKEY_HASH_SIZE; idx++) {\r\nlist_for_each_entry_safe(pkey, pkey_tmp,\r\n&sel_ib_pkey_hash[idx].list, list) {\r\nlist_del_rcu(&pkey->list);\r\nkfree_rcu(pkey, rcu);\r\n}\r\nsel_ib_pkey_hash[idx].size = 0;\r\n}\r\nspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\r\n}\r\nstatic __init int sel_ib_pkey_init(void)\r\n{\r\nint iter;\r\nif (!selinux_enabled)\r\nreturn 0;\r\nfor (iter = 0; iter < SEL_PKEY_HASH_SIZE; iter++) {\r\nINIT_LIST_HEAD(&sel_ib_pkey_hash[iter].list);\r\nsel_ib_pkey_hash[iter].size = 0;\r\n}\r\nreturn 0;\r\n}
