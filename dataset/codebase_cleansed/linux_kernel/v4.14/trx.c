static u8 _rtl92ce_map_hwqueue_to_fwqueue(struct sk_buff *skb, u8 hw_queue)\r\n{\r\n__le16 fc = rtl_get_fc(skb);\r\nif (unlikely(ieee80211_is_beacon(fc)))\r\nreturn QSLT_BEACON;\r\nif (ieee80211_is_mgmt(fc) || ieee80211_is_ctl(fc))\r\nreturn QSLT_MGNT;\r\nreturn skb->priority;\r\n}\r\nstatic u8 _rtl92c_query_rxpwrpercentage(s8 antpower)\r\n{\r\nif ((antpower <= -100) || (antpower >= 20))\r\nreturn 0;\r\nelse if (antpower >= 0)\r\nreturn 100;\r\nelse\r\nreturn 100 + antpower;\r\n}\r\nstatic u8 _rtl92c_evm_db_to_percentage(s8 value)\r\n{\r\ns8 ret_val;\r\nret_val = value;\r\nif (ret_val >= 0)\r\nret_val = 0;\r\nif (ret_val <= -33)\r\nret_val = -33;\r\nret_val = 0 - ret_val;\r\nret_val *= 3;\r\nif (ret_val == 99)\r\nret_val = 100;\r\nreturn ret_val;\r\n}\r\nstatic long _rtl92ce_signal_scale_mapping(struct ieee80211_hw *hw,\r\nlong currsig)\r\n{\r\nlong retsig;\r\nif (currsig >= 61 && currsig <= 100)\r\nretsig = 90 + ((currsig - 60) / 4);\r\nelse if (currsig >= 41 && currsig <= 60)\r\nretsig = 78 + ((currsig - 40) / 2);\r\nelse if (currsig >= 31 && currsig <= 40)\r\nretsig = 66 + (currsig - 30);\r\nelse if (currsig >= 21 && currsig <= 30)\r\nretsig = 54 + (currsig - 20);\r\nelse if (currsig >= 5 && currsig <= 20)\r\nretsig = 42 + (((currsig - 5) * 2) / 3);\r\nelse if (currsig == 4)\r\nretsig = 36;\r\nelse if (currsig == 3)\r\nretsig = 27;\r\nelse if (currsig == 2)\r\nretsig = 18;\r\nelse if (currsig == 1)\r\nretsig = 9;\r\nelse\r\nretsig = currsig;\r\nreturn retsig;\r\n}\r\nstatic void _rtl92ce_query_rxphystatus(struct ieee80211_hw *hw,\r\nstruct rtl_stats *pstats,\r\nstruct rx_desc_92c *pdesc,\r\nstruct rx_fwinfo_92c *p_drvinfo,\r\nbool packet_match_bssid,\r\nbool packet_toself,\r\nbool packet_beacon)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct phy_sts_cck_8192s_t *cck_buf;\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtlpriv);\r\ns8 rx_pwr_all = 0, rx_pwr[4];\r\nu8 evm, pwdb_all, rf_rx_num = 0;\r\nu8 i, max_spatial_stream;\r\nu32 rssi, total_rssi = 0;\r\nbool is_cck_rate;\r\nis_cck_rate = RX_HAL_IS_CCK_RATE(pdesc->rxmcs);\r\npstats->packet_matchbssid = packet_match_bssid;\r\npstats->packet_toself = packet_toself;\r\npstats->is_cck = is_cck_rate;\r\npstats->packet_beacon = packet_beacon;\r\npstats->rx_mimo_sig_qual[0] = -1;\r\npstats->rx_mimo_sig_qual[1] = -1;\r\nif (is_cck_rate) {\r\nu8 report, cck_highpwr;\r\ncck_buf = (struct phy_sts_cck_8192s_t *)p_drvinfo;\r\nif (ppsc->rfpwr_state == ERFON)\r\ncck_highpwr = (u8) rtl_get_bbreg(hw,\r\nRFPGA0_XA_HSSIPARAMETER2,\r\nBIT(9));\r\nelse\r\ncck_highpwr = false;\r\nif (!cck_highpwr) {\r\nu8 cck_agc_rpt = cck_buf->cck_agc_rpt;\r\nreport = cck_buf->cck_agc_rpt & 0xc0;\r\nreport = report >> 6;\r\nswitch (report) {\r\ncase 0x3:\r\nrx_pwr_all = -46 - (cck_agc_rpt & 0x3e);\r\nbreak;\r\ncase 0x2:\r\nrx_pwr_all = -26 - (cck_agc_rpt & 0x3e);\r\nbreak;\r\ncase 0x1:\r\nrx_pwr_all = -12 - (cck_agc_rpt & 0x3e);\r\nbreak;\r\ncase 0x0:\r\nrx_pwr_all = 16 - (cck_agc_rpt & 0x3e);\r\nbreak;\r\n}\r\n} else {\r\nu8 cck_agc_rpt = cck_buf->cck_agc_rpt;\r\nreport = p_drvinfo->cfosho[0] & 0x60;\r\nreport = report >> 5;\r\nswitch (report) {\r\ncase 0x3:\r\nrx_pwr_all = -46 - ((cck_agc_rpt & 0x1f) << 1);\r\nbreak;\r\ncase 0x2:\r\nrx_pwr_all = -26 - ((cck_agc_rpt & 0x1f) << 1);\r\nbreak;\r\ncase 0x1:\r\nrx_pwr_all = -12 - ((cck_agc_rpt & 0x1f) << 1);\r\nbreak;\r\ncase 0x0:\r\nrx_pwr_all = 16 - ((cck_agc_rpt & 0x1f) << 1);\r\nbreak;\r\n}\r\n}\r\npwdb_all = rtl_query_rxpwrpercentage(rx_pwr_all);\r\npwdb_all += 6;\r\nif (pwdb_all > 100)\r\npwdb_all = 100;\r\nif (pwdb_all > 34 && pwdb_all <= 42)\r\npwdb_all -= 2;\r\nelse if (pwdb_all > 26 && pwdb_all <= 34)\r\npwdb_all -= 6;\r\nelse if (pwdb_all > 14 && pwdb_all <= 26)\r\npwdb_all -= 8;\r\nelse if (pwdb_all > 4 && pwdb_all <= 14)\r\npwdb_all -= 4;\r\npstats->rx_pwdb_all = pwdb_all;\r\npstats->recvsignalpower = rx_pwr_all;\r\nif (packet_match_bssid) {\r\nu8 sq;\r\nif (pstats->rx_pwdb_all > 40)\r\nsq = 100;\r\nelse {\r\nsq = cck_buf->sq_rpt;\r\nif (sq > 64)\r\nsq = 0;\r\nelse if (sq < 20)\r\nsq = 100;\r\nelse\r\nsq = ((64 - sq) * 100) / 44;\r\n}\r\npstats->signalquality = sq;\r\npstats->rx_mimo_sig_qual[0] = sq;\r\npstats->rx_mimo_sig_qual[1] = -1;\r\n}\r\n} else {\r\nrtlpriv->dm.rfpath_rxenable[0] =\r\nrtlpriv->dm.rfpath_rxenable[1] = true;\r\nfor (i = RF90_PATH_A; i < RF90_PATH_MAX; i++) {\r\nif (rtlpriv->dm.rfpath_rxenable[i])\r\nrf_rx_num++;\r\nrx_pwr[i] =\r\n((p_drvinfo->gain_trsw[i] & 0x3f) * 2) - 110;\r\nrssi = _rtl92c_query_rxpwrpercentage(rx_pwr[i]);\r\ntotal_rssi += rssi;\r\nrtlpriv->stats.rx_snr_db[i] =\r\n(long)(p_drvinfo->rxsnr[i] / 2);\r\nif (packet_match_bssid)\r\npstats->rx_mimo_signalstrength[i] = (u8) rssi;\r\n}\r\nrx_pwr_all = ((p_drvinfo->pwdb_all >> 1) & 0x7f) - 110;\r\npwdb_all = _rtl92c_query_rxpwrpercentage(rx_pwr_all);\r\npstats->rx_pwdb_all = pwdb_all;\r\npstats->rxpower = rx_pwr_all;\r\npstats->recvsignalpower = rx_pwr_all;\r\nif (pstats->is_ht && pstats->rate >= DESC_RATEMCS8 &&\r\npstats->rate <= DESC_RATEMCS15)\r\nmax_spatial_stream = 2;\r\nelse\r\nmax_spatial_stream = 1;\r\nfor (i = 0; i < max_spatial_stream; i++) {\r\nevm = _rtl92c_evm_db_to_percentage(p_drvinfo->rxevm[i]);\r\nif (packet_match_bssid) {\r\nif (i == 0)\r\npstats->signalquality =\r\n(u8) (evm & 0xff);\r\npstats->rx_mimo_sig_qual[i] = (u8) (evm & 0xff);\r\n}\r\n}\r\n}\r\nif (is_cck_rate)\r\npstats->signalstrength =\r\n(u8) (_rtl92ce_signal_scale_mapping(hw, pwdb_all));\r\nelse if (rf_rx_num != 0)\r\npstats->signalstrength =\r\n(u8) (_rtl92ce_signal_scale_mapping\r\n(hw, total_rssi /= rf_rx_num));\r\n}\r\nstatic void _rtl92ce_translate_rx_signal_stuff(struct ieee80211_hw *hw,\r\nstruct sk_buff *skb,\r\nstruct rtl_stats *pstats,\r\nstruct rx_desc_92c *pdesc,\r\nstruct rx_fwinfo_92c *p_drvinfo)\r\n{\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nstruct ieee80211_hdr *hdr;\r\nu8 *tmp_buf;\r\nu8 *praddr;\r\n__le16 fc;\r\nu16 type, c_fc;\r\nbool packet_matchbssid, packet_toself, packet_beacon = false;\r\ntmp_buf = skb->data + pstats->rx_drvinfo_size + pstats->rx_bufshift;\r\nhdr = (struct ieee80211_hdr *)tmp_buf;\r\nfc = hdr->frame_control;\r\nc_fc = le16_to_cpu(fc);\r\ntype = WLAN_FC_GET_TYPE(fc);\r\npraddr = hdr->addr1;\r\npacket_matchbssid =\r\n((IEEE80211_FTYPE_CTL != type) &&\r\nether_addr_equal(mac->bssid,\r\n(c_fc & IEEE80211_FCTL_TODS) ? hdr->addr1 :\r\n(c_fc & IEEE80211_FCTL_FROMDS) ? hdr->addr2 :\r\nhdr->addr3) &&\r\n(!pstats->hwerror) && (!pstats->crc) && (!pstats->icv));\r\npacket_toself = packet_matchbssid &&\r\nether_addr_equal(praddr, rtlefuse->dev_addr);\r\nif (ieee80211_is_beacon(fc))\r\npacket_beacon = true;\r\n_rtl92ce_query_rxphystatus(hw, pstats, pdesc, p_drvinfo,\r\npacket_matchbssid, packet_toself,\r\npacket_beacon);\r\nrtl_process_phyinfo(hw, tmp_buf, pstats);\r\n}\r\nbool rtl92ce_rx_query_desc(struct ieee80211_hw *hw,\r\nstruct rtl_stats *stats,\r\nstruct ieee80211_rx_status *rx_status,\r\nu8 *p_desc, struct sk_buff *skb)\r\n{\r\nstruct rx_fwinfo_92c *p_drvinfo;\r\nstruct rx_desc_92c *pdesc = (struct rx_desc_92c *)p_desc;\r\nstruct ieee80211_hdr *hdr;\r\nu32 phystatus = GET_RX_DESC_PHYST(pdesc);\r\nstats->length = (u16) GET_RX_DESC_PKT_LEN(pdesc);\r\nstats->rx_drvinfo_size = (u8) GET_RX_DESC_DRV_INFO_SIZE(pdesc) *\r\nRX_DRV_INFO_SIZE_UNIT;\r\nstats->rx_bufshift = (u8) (GET_RX_DESC_SHIFT(pdesc) & 0x03);\r\nstats->icv = (u16) GET_RX_DESC_ICV(pdesc);\r\nstats->crc = (u16) GET_RX_DESC_CRC32(pdesc);\r\nstats->hwerror = (stats->crc | stats->icv);\r\nstats->decrypted = !GET_RX_DESC_SWDEC(pdesc);\r\nstats->rate = (u8) GET_RX_DESC_RXMCS(pdesc);\r\nstats->shortpreamble = (u16) GET_RX_DESC_SPLCP(pdesc);\r\nstats->isampdu = (bool) (GET_RX_DESC_PAGGR(pdesc) == 1);\r\nstats->isfirst_ampdu = (bool) ((GET_RX_DESC_PAGGR(pdesc) == 1)\r\n&& (GET_RX_DESC_FAGGR(pdesc) == 1));\r\nstats->timestamp_low = GET_RX_DESC_TSFL(pdesc);\r\nstats->rx_is40Mhzpacket = (bool) GET_RX_DESC_BW(pdesc);\r\nstats->is_ht = (bool)GET_RX_DESC_RXHT(pdesc);\r\nstats->is_cck = RX_HAL_IS_CCK_RATE(pdesc->rxmcs);\r\nrx_status->freq = hw->conf.chandef.chan->center_freq;\r\nrx_status->band = hw->conf.chandef.chan->band;\r\nhdr = (struct ieee80211_hdr *)(skb->data + stats->rx_drvinfo_size\r\n+ stats->rx_bufshift);\r\nif (stats->crc)\r\nrx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\r\nif (stats->rx_is40Mhzpacket)\r\nrx_status->bw = RATE_INFO_BW_40;\r\nif (stats->is_ht)\r\nrx_status->encoding = RX_ENC_HT;\r\nrx_status->flag |= RX_FLAG_MACTIME_START;\r\nif (stats->decrypted) {\r\nif ((_ieee80211_is_robust_mgmt_frame(hdr)) &&\r\n(ieee80211_has_protected(hdr->frame_control)))\r\nrx_status->flag &= ~RX_FLAG_DECRYPTED;\r\nelse\r\nrx_status->flag |= RX_FLAG_DECRYPTED;\r\n}\r\nrx_status->rate_idx = rtlwifi_rate_mapping(hw, stats->is_ht,\r\nfalse, stats->rate);\r\nrx_status->mactime = stats->timestamp_low;\r\nif (phystatus) {\r\np_drvinfo = (struct rx_fwinfo_92c *)(skb->data +\r\nstats->rx_bufshift);\r\n_rtl92ce_translate_rx_signal_stuff(hw,\r\nskb, stats, pdesc,\r\np_drvinfo);\r\n}\r\nrx_status->signal = stats->recvsignalpower + 10;\r\nreturn true;\r\n}\r\nvoid rtl92ce_tx_fill_desc(struct ieee80211_hw *hw,\r\nstruct ieee80211_hdr *hdr, u8 *pdesc_tx,\r\nu8 *pbd_desc_tx, struct ieee80211_tx_info *info,\r\nstruct ieee80211_sta *sta,\r\nstruct sk_buff *skb,\r\nu8 hw_queue, struct rtl_tcb_desc *tcb_desc)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nbool defaultadapter = true;\r\nu8 *pdesc = pdesc_tx;\r\nu16 seq_number;\r\n__le16 fc = hdr->frame_control;\r\nu8 fw_qsel = _rtl92ce_map_hwqueue_to_fwqueue(skb, hw_queue);\r\nbool firstseg = ((hdr->seq_ctrl &\r\ncpu_to_le16(IEEE80211_SCTL_FRAG)) == 0);\r\nbool lastseg = ((hdr->frame_control &\r\ncpu_to_le16(IEEE80211_FCTL_MOREFRAGS)) == 0);\r\ndma_addr_t mapping = pci_map_single(rtlpci->pdev,\r\nskb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\nu8 bw_40 = 0;\r\nif (pci_dma_mapping_error(rtlpci->pdev, mapping)) {\r\nRT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE,\r\n"DMA mapping error\n");\r\nreturn;\r\n}\r\nrcu_read_lock();\r\nsta = get_sta(hw, mac->vif, mac->bssid);\r\nif (mac->opmode == NL80211_IFTYPE_STATION) {\r\nbw_40 = mac->bw_40;\r\n} else if (mac->opmode == NL80211_IFTYPE_AP ||\r\nmac->opmode == NL80211_IFTYPE_ADHOC ||\r\nmac->opmode == NL80211_IFTYPE_MESH_POINT) {\r\nif (sta)\r\nbw_40 = sta->bandwidth >= IEEE80211_STA_RX_BW_40;\r\n}\r\nseq_number = (le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_SEQ) >> 4;\r\nrtl_get_tcb_desc(hw, info, sta, skb, tcb_desc);\r\nCLEAR_PCI_TX_DESC_CONTENT(pdesc, sizeof(struct tx_desc_92c));\r\nif (ieee80211_is_nullfunc(fc) || ieee80211_is_ctl(fc)) {\r\nfirstseg = true;\r\nlastseg = true;\r\n}\r\nif (firstseg) {\r\nSET_TX_DESC_OFFSET(pdesc, USB_HWDESC_HEADER_LEN);\r\nSET_TX_DESC_TX_RATE(pdesc, tcb_desc->hw_rate);\r\nif (tcb_desc->use_shortgi || tcb_desc->use_shortpreamble)\r\nSET_TX_DESC_DATA_SHORTGI(pdesc, 1);\r\nif (info->flags & IEEE80211_TX_CTL_AMPDU) {\r\nSET_TX_DESC_AGG_BREAK(pdesc, 1);\r\nSET_TX_DESC_MAX_AGG_NUM(pdesc, 0x14);\r\n}\r\nSET_TX_DESC_SEQ(pdesc, seq_number);\r\nSET_TX_DESC_RTS_ENABLE(pdesc, ((tcb_desc->rts_enable &&\r\n!tcb_desc->\r\ncts_enable) ? 1 : 0));\r\nSET_TX_DESC_HW_RTS_ENABLE(pdesc,\r\n((tcb_desc->rts_enable\r\n|| tcb_desc->cts_enable) ? 1 : 0));\r\nSET_TX_DESC_CTS2SELF(pdesc, ((tcb_desc->cts_enable) ? 1 : 0));\r\nSET_TX_DESC_RTS_STBC(pdesc, ((tcb_desc->rts_stbc) ? 1 : 0));\r\nSET_TX_DESC_RTS_RATE(pdesc, tcb_desc->rts_rate);\r\nSET_TX_DESC_RTS_BW(pdesc, 0);\r\nSET_TX_DESC_RTS_SC(pdesc, tcb_desc->rts_sc);\r\nSET_TX_DESC_RTS_SHORT(pdesc,\r\n((tcb_desc->rts_rate <= DESC_RATE54M) ?\r\n(tcb_desc->rts_use_shortpreamble ? 1 : 0)\r\n: (tcb_desc->rts_use_shortgi ? 1 : 0)));\r\nif (bw_40) {\r\nif (tcb_desc->packet_bw) {\r\nSET_TX_DESC_DATA_BW(pdesc, 1);\r\nSET_TX_DESC_TX_SUB_CARRIER(pdesc, 3);\r\n} else {\r\nSET_TX_DESC_DATA_BW(pdesc, 0);\r\nSET_TX_DESC_TX_SUB_CARRIER(pdesc,\r\nmac->cur_40_prime_sc);\r\n}\r\n} else {\r\nSET_TX_DESC_DATA_BW(pdesc, 0);\r\nSET_TX_DESC_TX_SUB_CARRIER(pdesc, 0);\r\n}\r\nSET_TX_DESC_LINIP(pdesc, 0);\r\nSET_TX_DESC_PKT_SIZE(pdesc, (u16) skb->len);\r\nif (sta) {\r\nu8 ampdu_density = sta->ht_cap.ampdu_density;\r\nSET_TX_DESC_AMPDU_DENSITY(pdesc, ampdu_density);\r\n}\r\nif (info->control.hw_key) {\r\nstruct ieee80211_key_conf *keyconf =\r\ninfo->control.hw_key;\r\nswitch (keyconf->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nSET_TX_DESC_SEC_TYPE(pdesc, 0x1);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nSET_TX_DESC_SEC_TYPE(pdesc, 0x3);\r\nbreak;\r\ndefault:\r\nSET_TX_DESC_SEC_TYPE(pdesc, 0x0);\r\nbreak;\r\n}\r\n}\r\nSET_TX_DESC_PKT_ID(pdesc, 0);\r\nSET_TX_DESC_QUEUE_SEL(pdesc, fw_qsel);\r\nSET_TX_DESC_DATA_RATE_FB_LIMIT(pdesc, 0x1F);\r\nSET_TX_DESC_RTS_RATE_FB_LIMIT(pdesc, 0xF);\r\nSET_TX_DESC_DISABLE_FB(pdesc, 0);\r\nSET_TX_DESC_USE_RATE(pdesc, tcb_desc->use_driver_rate ? 1 : 0);\r\nif (ieee80211_is_data_qos(fc)) {\r\nif (mac->rdg_en) {\r\nRT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE,\r\n"Enable RDG function\n");\r\nSET_TX_DESC_RDG_ENABLE(pdesc, 1);\r\nSET_TX_DESC_HTC(pdesc, 1);\r\n}\r\n}\r\n}\r\nrcu_read_unlock();\r\nSET_TX_DESC_FIRST_SEG(pdesc, (firstseg ? 1 : 0));\r\nSET_TX_DESC_LAST_SEG(pdesc, (lastseg ? 1 : 0));\r\nSET_TX_DESC_TX_BUFFER_SIZE(pdesc, (u16) skb->len);\r\nSET_TX_DESC_TX_BUFFER_ADDRESS(pdesc, mapping);\r\nif (rtlpriv->dm.useramask) {\r\nSET_TX_DESC_RATE_ID(pdesc, tcb_desc->ratr_index);\r\nSET_TX_DESC_MACID(pdesc, tcb_desc->mac_id);\r\n} else {\r\nSET_TX_DESC_RATE_ID(pdesc, 0xC + tcb_desc->ratr_index);\r\nSET_TX_DESC_MACID(pdesc, tcb_desc->ratr_index);\r\n}\r\nif ((!ieee80211_is_data_qos(fc)) && ppsc->fwctrl_lps) {\r\nSET_TX_DESC_HWSEQ_EN(pdesc, 1);\r\nSET_TX_DESC_PKT_ID(pdesc, 8);\r\nif (!defaultadapter)\r\nSET_TX_DESC_QOS(pdesc, 1);\r\n}\r\nSET_TX_DESC_MORE_FRAG(pdesc, (lastseg ? 0 : 1));\r\nif (is_multicast_ether_addr(ieee80211_get_DA(hdr)) ||\r\nis_broadcast_ether_addr(ieee80211_get_DA(hdr))) {\r\nSET_TX_DESC_BMC(pdesc, 1);\r\n}\r\nRT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE, "\n");\r\n}\r\nvoid rtl92ce_tx_fill_cmddesc(struct ieee80211_hw *hw,\r\nu8 *pdesc, bool firstseg,\r\nbool lastseg, struct sk_buff *skb)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nu8 fw_queue = QSLT_BEACON;\r\ndma_addr_t mapping = pci_map_single(rtlpci->pdev,\r\nskb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)(skb->data);\r\n__le16 fc = hdr->frame_control;\r\nif (pci_dma_mapping_error(rtlpci->pdev, mapping)) {\r\nRT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE,\r\n"DMA mapping error\n");\r\nreturn;\r\n}\r\nCLEAR_PCI_TX_DESC_CONTENT(pdesc, TX_DESC_SIZE);\r\nif (firstseg)\r\nSET_TX_DESC_OFFSET(pdesc, USB_HWDESC_HEADER_LEN);\r\nSET_TX_DESC_TX_RATE(pdesc, DESC_RATE1M);\r\nSET_TX_DESC_SEQ(pdesc, 0);\r\nSET_TX_DESC_LINIP(pdesc, 0);\r\nSET_TX_DESC_QUEUE_SEL(pdesc, fw_queue);\r\nSET_TX_DESC_FIRST_SEG(pdesc, 1);\r\nSET_TX_DESC_LAST_SEG(pdesc, 1);\r\nSET_TX_DESC_TX_BUFFER_SIZE(pdesc, (u16) (skb->len));\r\nSET_TX_DESC_TX_BUFFER_ADDRESS(pdesc, mapping);\r\nSET_TX_DESC_RATE_ID(pdesc, 7);\r\nSET_TX_DESC_MACID(pdesc, 0);\r\nSET_TX_DESC_OWN(pdesc, 1);\r\nSET_TX_DESC_PKT_SIZE(pdesc, (u16) (skb->len));\r\nSET_TX_DESC_FIRST_SEG(pdesc, 1);\r\nSET_TX_DESC_LAST_SEG(pdesc, 1);\r\nSET_TX_DESC_OFFSET(pdesc, 0x20);\r\nSET_TX_DESC_USE_RATE(pdesc, 1);\r\nif (!ieee80211_is_data_qos(fc)) {\r\nSET_TX_DESC_HWSEQ_EN(pdesc, 1);\r\nSET_TX_DESC_PKT_ID(pdesc, 8);\r\n}\r\nRT_PRINT_DATA(rtlpriv, COMP_CMD, DBG_LOUD,\r\n"H2C Tx Cmd Content", pdesc, TX_DESC_SIZE);\r\n}\r\nvoid rtl92ce_set_desc(struct ieee80211_hw *hw, u8 *pdesc, bool istx,\r\nu8 desc_name, u8 *val)\r\n{\r\nif (istx) {\r\nswitch (desc_name) {\r\ncase HW_DESC_OWN:\r\nwmb();\r\nSET_TX_DESC_OWN(pdesc, 1);\r\nbreak;\r\ncase HW_DESC_TX_NEXTDESC_ADDR:\r\nSET_TX_DESC_NEXT_DESC_ADDRESS(pdesc, *(u32 *) val);\r\nbreak;\r\ndefault:\r\nWARN_ONCE(true, "rtl8192ce: ERR txdesc :%d not processed\n",\r\ndesc_name);\r\nbreak;\r\n}\r\n} else {\r\nswitch (desc_name) {\r\ncase HW_DESC_RXOWN:\r\nwmb();\r\nSET_RX_DESC_OWN(pdesc, 1);\r\nbreak;\r\ncase HW_DESC_RXBUFF_ADDR:\r\nSET_RX_DESC_BUFF_ADDR(pdesc, *(u32 *) val);\r\nbreak;\r\ncase HW_DESC_RXPKT_LEN:\r\nSET_RX_DESC_PKT_LEN(pdesc, *(u32 *) val);\r\nbreak;\r\ncase HW_DESC_RXERO:\r\nSET_RX_DESC_EOR(pdesc, 1);\r\nbreak;\r\ndefault:\r\nWARN_ONCE(true, "rtl8192ce: ERR rxdesc :%d not processed\n",\r\ndesc_name);\r\nbreak;\r\n}\r\n}\r\n}\r\nu32 rtl92ce_get_desc(u8 *p_desc, bool istx, u8 desc_name)\r\n{\r\nu32 ret = 0;\r\nif (istx) {\r\nswitch (desc_name) {\r\ncase HW_DESC_OWN:\r\nret = GET_TX_DESC_OWN(p_desc);\r\nbreak;\r\ncase HW_DESC_TXBUFF_ADDR:\r\nret = GET_TX_DESC_TX_BUFFER_ADDRESS(p_desc);\r\nbreak;\r\ndefault:\r\nWARN_ONCE(true, "rtl8192ce: ERR txdesc :%d not processed\n",\r\ndesc_name);\r\nbreak;\r\n}\r\n} else {\r\nswitch (desc_name) {\r\ncase HW_DESC_OWN:\r\nret = GET_RX_DESC_OWN(p_desc);\r\nbreak;\r\ncase HW_DESC_RXPKT_LEN:\r\nret = GET_RX_DESC_PKT_LEN(p_desc);\r\nbreak;\r\ncase HW_DESC_RXBUFF_ADDR:\r\nret = GET_RX_DESC_BUFF_ADDR(p_desc);\r\nbreak;\r\ndefault:\r\nWARN_ONCE(true, "rtl8192ce: ERR rxdesc :%d not processed\n",\r\ndesc_name);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nbool rtl92ce_is_tx_desc_closed(struct ieee80211_hw *hw,\r\nu8 hw_queue, u16 index)\r\n{\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl8192_tx_ring *ring = &rtlpci->tx_ring[hw_queue];\r\nu8 *entry = (u8 *)(&ring->desc[ring->idx]);\r\nu8 own = (u8)rtl92ce_get_desc(entry, true, HW_DESC_OWN);\r\nif (own)\r\nreturn false;\r\nreturn true;\r\n}\r\nvoid rtl92ce_tx_polling(struct ieee80211_hw *hw, u8 hw_queue)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nif (hw_queue == BEACON_QUEUE) {\r\nrtl_write_word(rtlpriv, REG_PCIE_CTRL_REG, BIT(4));\r\n} else {\r\nrtl_write_word(rtlpriv, REG_PCIE_CTRL_REG,\r\nBIT(0) << (hw_queue));\r\n}\r\n}
