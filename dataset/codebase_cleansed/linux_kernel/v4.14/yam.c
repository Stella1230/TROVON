static void delay(int ms)\r\n{\r\nunsigned long timeout = jiffies + ((ms * HZ) / 1000);\r\nwhile (time_before(jiffies, timeout))\r\ncpu_relax();\r\n}\r\nstatic void fpga_reset(int iobase)\r\n{\r\noutb(0, IER(iobase));\r\noutb(LCR_DLAB | LCR_BIT5, LCR(iobase));\r\noutb(1, DLL(iobase));\r\noutb(0, DLM(iobase));\r\noutb(LCR_BIT5, LCR(iobase));\r\ninb(LSR(iobase));\r\ninb(MSR(iobase));\r\noutb(MCR_OUT1 | MCR_OUT2, MCR(iobase));\r\ndelay(100);\r\noutb(MCR_DTR | MCR_RTS | MCR_OUT1 | MCR_OUT2, MCR(iobase));\r\ndelay(100);\r\n}\r\nstatic int fpga_write(int iobase, unsigned char wrd)\r\n{\r\nunsigned char bit;\r\nint k;\r\nunsigned long timeout = jiffies + HZ / 10;\r\nfor (k = 0; k < 8; k++) {\r\nbit = (wrd & 0x80) ? (MCR_RTS | MCR_DTR) : MCR_DTR;\r\noutb(bit | MCR_OUT1 | MCR_OUT2, MCR(iobase));\r\nwrd <<= 1;\r\noutb(0xfc, THR(iobase));\r\nwhile ((inb(LSR(iobase)) & LSR_TSRE) == 0)\r\nif (time_after(jiffies, timeout))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char *add_mcs(unsigned char *bits, int bitrate,\r\nunsigned int predef)\r\n{\r\nconst char *fw_name[2] = {FIRMWARE_9600, FIRMWARE_1200};\r\nconst struct firmware *fw;\r\nstruct platform_device *pdev;\r\nstruct yam_mcs *p;\r\nint err;\r\nswitch (predef) {\r\ncase 0:\r\nfw = NULL;\r\nbreak;\r\ncase YAM_1200:\r\ncase YAM_9600:\r\npredef--;\r\npdev = platform_device_register_simple("yam", 0, NULL, 0);\r\nif (IS_ERR(pdev)) {\r\nprintk(KERN_ERR "yam: Failed to register firmware\n");\r\nreturn NULL;\r\n}\r\nerr = request_firmware(&fw, fw_name[predef], &pdev->dev);\r\nplatform_device_unregister(pdev);\r\nif (err) {\r\nprintk(KERN_ERR "Failed to load firmware \"%s\"\n",\r\nfw_name[predef]);\r\nreturn NULL;\r\n}\r\nif (fw->size != YAM_FPGA_SIZE) {\r\nprintk(KERN_ERR "Bogus length %zu in firmware \"%s\"\n",\r\nfw->size, fw_name[predef]);\r\nrelease_firmware(fw);\r\nreturn NULL;\r\n}\r\nbits = (unsigned char *)fw->data;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "yam: Invalid predef number %u\n", predef);\r\nreturn NULL;\r\n}\r\np = yam_data;\r\nwhile (p) {\r\nif (p->bitrate == bitrate) {\r\nmemcpy(p->bits, bits, YAM_FPGA_SIZE);\r\ngoto out;\r\n}\r\np = p->next;\r\n}\r\nif ((p = kmalloc(sizeof(struct yam_mcs), GFP_KERNEL)) == NULL) {\r\nrelease_firmware(fw);\r\nreturn NULL;\r\n}\r\nmemcpy(p->bits, bits, YAM_FPGA_SIZE);\r\np->bitrate = bitrate;\r\np->next = yam_data;\r\nyam_data = p;\r\nout:\r\nrelease_firmware(fw);\r\nreturn p->bits;\r\n}\r\nstatic unsigned char *get_mcs(int bitrate)\r\n{\r\nstruct yam_mcs *p;\r\np = yam_data;\r\nwhile (p) {\r\nif (p->bitrate == bitrate)\r\nreturn p->bits;\r\np = p->next;\r\n}\r\nswitch (bitrate) {\r\ncase 1200:\r\nreturn add_mcs(NULL, bitrate, YAM_1200);\r\ndefault:\r\nreturn add_mcs(NULL, bitrate, YAM_9600);\r\n}\r\n}\r\nstatic int fpga_download(int iobase, int bitrate)\r\n{\r\nint i, rc;\r\nunsigned char *pbits;\r\npbits = get_mcs(bitrate);\r\nif (pbits == NULL)\r\nreturn -1;\r\nfpga_reset(iobase);\r\nfor (i = 0; i < YAM_FPGA_SIZE; i++) {\r\nif (fpga_write(iobase, pbits[i])) {\r\nprintk(KERN_ERR "yam: error in write cycle\n");\r\nreturn -1;\r\n}\r\n}\r\nfpga_write(iobase, 0xFF);\r\nrc = inb(MSR(iobase));\r\ndelay(50);\r\nreturn (rc & MSR_DSR) ? 0 : -1;\r\n}\r\nstatic void yam_set_uart(struct net_device *dev)\r\n{\r\nstruct yam_port *yp = netdev_priv(dev);\r\nint divisor = 115200 / yp->baudrate;\r\noutb(0, IER(dev->base_addr));\r\noutb(LCR_DLAB | LCR_BIT8, LCR(dev->base_addr));\r\noutb(divisor, DLL(dev->base_addr));\r\noutb(0, DLM(dev->base_addr));\r\noutb(LCR_BIT8, LCR(dev->base_addr));\r\noutb(PTT_OFF, MCR(dev->base_addr));\r\noutb(0x00, FCR(dev->base_addr));\r\ninb(RBR(dev->base_addr));\r\ninb(MSR(dev->base_addr));\r\noutb(ENABLE_RTXINT, IER(dev->base_addr));\r\n}\r\nstatic enum uart yam_check_uart(unsigned int iobase)\r\n{\r\nunsigned char b1, b2, b3;\r\nenum uart u;\r\nenum uart uart_tab[] =\r\n{c_uart_16450, c_uart_unknown, c_uart_16550, c_uart_16550A};\r\nb1 = inb(MCR(iobase));\r\noutb(b1 | 0x10, MCR(iobase));\r\nb2 = inb(MSR(iobase));\r\noutb(0x1a, MCR(iobase));\r\nb3 = inb(MSR(iobase)) & 0xf0;\r\noutb(b1, MCR(iobase));\r\noutb(b2, MSR(iobase));\r\nif (b3 != 0x90)\r\nreturn c_uart_unknown;\r\ninb(RBR(iobase));\r\ninb(RBR(iobase));\r\noutb(0x01, FCR(iobase));\r\nu = uart_tab[(inb(IIR(iobase)) >> 6) & 3];\r\nif (u == c_uart_16450) {\r\noutb(0x5a, SCR(iobase));\r\nb1 = inb(SCR(iobase));\r\noutb(0xa5, SCR(iobase));\r\nb2 = inb(SCR(iobase));\r\nif ((b1 != 0x5a) || (b2 != 0xa5))\r\nu = c_uart_8250;\r\n}\r\nreturn u;\r\n}\r\nstatic inline void yam_rx_flag(struct net_device *dev, struct yam_port *yp)\r\n{\r\nif (yp->dcd && yp->rx_len >= 3 && yp->rx_len < YAM_MAX_FRAME) {\r\nint pkt_len = yp->rx_len - 2 + 1;\r\nstruct sk_buff *skb;\r\nif ((yp->rx_crch & yp->rx_crcl) != 0xFF) {\r\n} else {\r\nif (!(skb = dev_alloc_skb(pkt_len))) {\r\nprintk(KERN_WARNING "%s: memory squeeze, dropping packet\n", dev->name);\r\n++dev->stats.rx_dropped;\r\n} else {\r\nunsigned char *cp;\r\ncp = skb_put(skb, pkt_len);\r\n*cp++ = 0;\r\nmemcpy(cp, yp->rx_buf, pkt_len - 1);\r\nskb->protocol = ax25_type_trans(skb, dev);\r\nnetif_rx(skb);\r\n++dev->stats.rx_packets;\r\n}\r\n}\r\n}\r\nyp->rx_len = 0;\r\nyp->rx_crcl = 0x21;\r\nyp->rx_crch = 0xf3;\r\n}\r\nstatic inline void yam_rx_byte(struct net_device *dev, struct yam_port *yp, unsigned char rxb)\r\n{\r\nif (yp->rx_len < YAM_MAX_FRAME) {\r\nunsigned char c = yp->rx_crcl;\r\nyp->rx_crcl = (chktabl[c] ^ yp->rx_crch);\r\nyp->rx_crch = (chktabh[c] ^ rxb);\r\nyp->rx_buf[yp->rx_len++] = rxb;\r\n}\r\n}\r\nstatic void ptt_on(struct net_device *dev)\r\n{\r\noutb(PTT_ON, MCR(dev->base_addr));\r\n}\r\nstatic void ptt_off(struct net_device *dev)\r\n{\r\noutb(PTT_OFF, MCR(dev->base_addr));\r\n}\r\nstatic netdev_tx_t yam_send_packet(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct yam_port *yp = netdev_priv(dev);\r\nif (skb->protocol == htons(ETH_P_IP))\r\nreturn ax25_ip_xmit(skb);\r\nskb_queue_tail(&yp->send_queue, skb);\r\nnetif_trans_update(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void yam_start_tx(struct net_device *dev, struct yam_port *yp)\r\n{\r\nif ((yp->tx_state == TX_TAIL) || (yp->txd == 0))\r\nyp->tx_count = 1;\r\nelse\r\nyp->tx_count = (yp->bitrate * yp->txd) / 8000;\r\nyp->tx_state = TX_HEAD;\r\nptt_on(dev);\r\n}\r\nstatic void yam_arbitrate(struct net_device *dev)\r\n{\r\nstruct yam_port *yp = netdev_priv(dev);\r\nif (yp->magic != YAM_MAGIC || yp->tx_state != TX_OFF ||\r\nskb_queue_empty(&yp->send_queue))\r\nreturn;\r\nif (yp->dupmode) {\r\nyam_start_tx(dev, yp);\r\nreturn;\r\n}\r\nif (yp->dcd) {\r\nyp->slotcnt = yp->slot / 10;\r\nreturn;\r\n}\r\nif ((--yp->slotcnt) > 0)\r\nreturn;\r\nyp->slotcnt = yp->slot / 10;\r\nif ((prandom_u32() % 256) > yp->pers)\r\nreturn;\r\nyam_start_tx(dev, yp);\r\n}\r\nstatic void yam_dotimer(unsigned long dummy)\r\n{\r\nint i;\r\nfor (i = 0; i < NR_PORTS; i++) {\r\nstruct net_device *dev = yam_devs[i];\r\nif (dev && netif_running(dev))\r\nyam_arbitrate(dev);\r\n}\r\nyam_timer.expires = jiffies + HZ / 100;\r\nadd_timer(&yam_timer);\r\n}\r\nstatic void yam_tx_byte(struct net_device *dev, struct yam_port *yp)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char b, temp;\r\nswitch (yp->tx_state) {\r\ncase TX_OFF:\r\nbreak;\r\ncase TX_HEAD:\r\nif (--yp->tx_count <= 0) {\r\nif (!(skb = skb_dequeue(&yp->send_queue))) {\r\nptt_off(dev);\r\nyp->tx_state = TX_OFF;\r\nbreak;\r\n}\r\nyp->tx_state = TX_DATA;\r\nif (skb->data[0] != 0) {\r\ndev_kfree_skb_any(skb);\r\nbreak;\r\n}\r\nyp->tx_len = skb->len - 1;\r\nif (yp->tx_len >= YAM_MAX_FRAME || yp->tx_len < 2) {\r\ndev_kfree_skb_any(skb);\r\nbreak;\r\n}\r\nskb_copy_from_linear_data_offset(skb, 1,\r\nyp->tx_buf,\r\nyp->tx_len);\r\ndev_kfree_skb_any(skb);\r\nyp->tx_count = 0;\r\nyp->tx_crcl = 0x21;\r\nyp->tx_crch = 0xf3;\r\nyp->tx_state = TX_DATA;\r\n}\r\nbreak;\r\ncase TX_DATA:\r\nb = yp->tx_buf[yp->tx_count++];\r\noutb(b, THR(dev->base_addr));\r\ntemp = yp->tx_crcl;\r\nyp->tx_crcl = chktabl[temp] ^ yp->tx_crch;\r\nyp->tx_crch = chktabh[temp] ^ b;\r\nif (yp->tx_count >= yp->tx_len) {\r\nyp->tx_state = TX_CRC1;\r\n}\r\nbreak;\r\ncase TX_CRC1:\r\nyp->tx_crch = chktabl[yp->tx_crcl] ^ yp->tx_crch;\r\nyp->tx_crcl = chktabh[yp->tx_crcl] ^ chktabl[yp->tx_crch] ^ 0xff;\r\noutb(yp->tx_crcl, THR(dev->base_addr));\r\nyp->tx_state = TX_CRC2;\r\nbreak;\r\ncase TX_CRC2:\r\noutb(chktabh[yp->tx_crch] ^ 0xFF, THR(dev->base_addr));\r\nif (skb_queue_empty(&yp->send_queue)) {\r\nyp->tx_count = (yp->bitrate * yp->txtail) / 8000;\r\nif (yp->dupmode == 2)\r\nyp->tx_count += (yp->bitrate * yp->holdd) / 8;\r\nif (yp->tx_count == 0)\r\nyp->tx_count = 1;\r\nyp->tx_state = TX_TAIL;\r\n} else {\r\nyp->tx_count = 1;\r\nyp->tx_state = TX_HEAD;\r\n}\r\n++dev->stats.tx_packets;\r\nbreak;\r\ncase TX_TAIL:\r\nif (--yp->tx_count <= 0) {\r\nyp->tx_state = TX_OFF;\r\nptt_off(dev);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t yam_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev;\r\nstruct yam_port *yp;\r\nunsigned char iir;\r\nint counter = 100;\r\nint i;\r\nint handled = 0;\r\nfor (i = 0; i < NR_PORTS; i++) {\r\ndev = yam_devs[i];\r\nyp = netdev_priv(dev);\r\nif (!netif_running(dev))\r\ncontinue;\r\nwhile ((iir = IIR_MASK & inb(IIR(dev->base_addr))) != IIR_NOPEND) {\r\nunsigned char msr = inb(MSR(dev->base_addr));\r\nunsigned char lsr = inb(LSR(dev->base_addr));\r\nunsigned char rxb;\r\nhandled = 1;\r\nif (lsr & LSR_OE)\r\n++dev->stats.rx_fifo_errors;\r\nyp->dcd = (msr & RX_DCD) ? 1 : 0;\r\nif (--counter <= 0) {\r\nprintk(KERN_ERR "%s: too many irq iir=%d\n",\r\ndev->name, iir);\r\ngoto out;\r\n}\r\nif (msr & TX_RDY) {\r\n++yp->nb_mdint;\r\nyam_tx_byte(dev, yp);\r\n}\r\nif (lsr & LSR_RXC) {\r\n++yp->nb_rxint;\r\nrxb = inb(RBR(dev->base_addr));\r\nif (msr & RX_FLAG)\r\nyam_rx_flag(dev, yp);\r\nelse\r\nyam_rx_byte(dev, yp, rxb);\r\n}\r\n}\r\n}\r\nout:\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void *yam_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nreturn (*pos < NR_PORTS) ? yam_devs[*pos] : NULL;\r\n}\r\nstatic void *yam_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn (*pos < NR_PORTS) ? yam_devs[*pos] : NULL;\r\n}\r\nstatic void yam_seq_stop(struct seq_file *seq, void *v)\r\n{\r\n}\r\nstatic int yam_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct net_device *dev = v;\r\nconst struct yam_port *yp = netdev_priv(dev);\r\nseq_printf(seq, "Device %s\n", dev->name);\r\nseq_printf(seq, " Up %d\n", netif_running(dev));\r\nseq_printf(seq, " Speed %u\n", yp->bitrate);\r\nseq_printf(seq, " IoBase 0x%x\n", yp->iobase);\r\nseq_printf(seq, " BaudRate %u\n", yp->baudrate);\r\nseq_printf(seq, " IRQ %u\n", yp->irq);\r\nseq_printf(seq, " TxState %u\n", yp->tx_state);\r\nseq_printf(seq, " Duplex %u\n", yp->dupmode);\r\nseq_printf(seq, " HoldDly %u\n", yp->holdd);\r\nseq_printf(seq, " TxDelay %u\n", yp->txd);\r\nseq_printf(seq, " TxTail %u\n", yp->txtail);\r\nseq_printf(seq, " SlotTime %u\n", yp->slot);\r\nseq_printf(seq, " Persist %u\n", yp->pers);\r\nseq_printf(seq, " TxFrames %lu\n", dev->stats.tx_packets);\r\nseq_printf(seq, " RxFrames %lu\n", dev->stats.rx_packets);\r\nseq_printf(seq, " TxInt %u\n", yp->nb_mdint);\r\nseq_printf(seq, " RxInt %u\n", yp->nb_rxint);\r\nseq_printf(seq, " RxOver %lu\n", dev->stats.rx_fifo_errors);\r\nseq_printf(seq, "\n");\r\nreturn 0;\r\n}\r\nstatic int yam_info_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &yam_seqops);\r\n}\r\nstatic int yam_open(struct net_device *dev)\r\n{\r\nstruct yam_port *yp = netdev_priv(dev);\r\nenum uart u;\r\nint i;\r\nint ret=0;\r\nprintk(KERN_INFO "Trying %s at iobase 0x%lx irq %u\n", dev->name, dev->base_addr, dev->irq);\r\nif (!yp->bitrate)\r\nreturn -ENXIO;\r\nif (!dev->base_addr || dev->base_addr > 0x1000 - YAM_EXTENT ||\r\ndev->irq < 2 || dev->irq > 15) {\r\nreturn -ENXIO;\r\n}\r\nif (!request_region(dev->base_addr, YAM_EXTENT, dev->name))\r\n{\r\nprintk(KERN_ERR "%s: cannot 0x%lx busy\n", dev->name, dev->base_addr);\r\nreturn -EACCES;\r\n}\r\nif ((u = yam_check_uart(dev->base_addr)) == c_uart_unknown) {\r\nprintk(KERN_ERR "%s: cannot find uart type\n", dev->name);\r\nret = -EIO;\r\ngoto out_release_base;\r\n}\r\nif (fpga_download(dev->base_addr, yp->bitrate)) {\r\nprintk(KERN_ERR "%s: cannot init FPGA\n", dev->name);\r\nret = -EIO;\r\ngoto out_release_base;\r\n}\r\noutb(0, IER(dev->base_addr));\r\nif (request_irq(dev->irq, yam_interrupt, IRQF_SHARED, dev->name, dev)) {\r\nprintk(KERN_ERR "%s: irq %d busy\n", dev->name, dev->irq);\r\nret = -EBUSY;\r\ngoto out_release_base;\r\n}\r\nyam_set_uart(dev);\r\nnetif_start_queue(dev);\r\nyp->slotcnt = yp->slot / 10;\r\nfor (i = 0; i < NR_PORTS; i++) {\r\nstruct net_device *yam_dev = yam_devs[i];\r\ninb(LSR(yam_dev->base_addr));\r\nyam_dev->stats.rx_fifo_errors = 0;\r\n}\r\nprintk(KERN_INFO "%s at iobase 0x%lx irq %u uart %s\n", dev->name, dev->base_addr, dev->irq,\r\nuart_str[u]);\r\nreturn 0;\r\nout_release_base:\r\nrelease_region(dev->base_addr, YAM_EXTENT);\r\nreturn ret;\r\n}\r\nstatic int yam_close(struct net_device *dev)\r\n{\r\nstruct sk_buff *skb;\r\nstruct yam_port *yp = netdev_priv(dev);\r\nif (!dev)\r\nreturn -EINVAL;\r\noutb(0, IER(dev->base_addr));\r\noutb(1, MCR(dev->base_addr));\r\nfree_irq(dev->irq,dev);\r\nrelease_region(dev->base_addr, YAM_EXTENT);\r\nnetif_stop_queue(dev);\r\nwhile ((skb = skb_dequeue(&yp->send_queue)))\r\ndev_kfree_skb(skb);\r\nprintk(KERN_INFO "%s: close yam at iobase 0x%lx irq %u\n",\r\nyam_drvname, dev->base_addr, dev->irq);\r\nreturn 0;\r\n}\r\nstatic int yam_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct yam_port *yp = netdev_priv(dev);\r\nstruct yamdrv_ioctl_cfg yi;\r\nstruct yamdrv_ioctl_mcs *ym;\r\nint ioctl_cmd;\r\nif (copy_from_user(&ioctl_cmd, ifr->ifr_data, sizeof(int)))\r\nreturn -EFAULT;\r\nif (yp->magic != YAM_MAGIC)\r\nreturn -EINVAL;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (cmd != SIOCDEVPRIVATE)\r\nreturn -EINVAL;\r\nswitch (ioctl_cmd) {\r\ncase SIOCYAMRESERVED:\r\nreturn -EINVAL;\r\ncase SIOCYAMSMCS:\r\nif (netif_running(dev))\r\nreturn -EINVAL;\r\nym = memdup_user(ifr->ifr_data,\r\nsizeof(struct yamdrv_ioctl_mcs));\r\nif (IS_ERR(ym))\r\nreturn PTR_ERR(ym);\r\nif (ym->bitrate > YAM_MAXBITRATE) {\r\nkfree(ym);\r\nreturn -EINVAL;\r\n}\r\nadd_mcs(ym->bits, ym->bitrate, 0);\r\nkfree(ym);\r\nbreak;\r\ncase SIOCYAMSCFG:\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nif (copy_from_user(&yi, ifr->ifr_data, sizeof(struct yamdrv_ioctl_cfg)))\r\nreturn -EFAULT;\r\nif ((yi.cfg.mask & YAM_IOBASE) && netif_running(dev))\r\nreturn -EINVAL;\r\nif ((yi.cfg.mask & YAM_IRQ) && netif_running(dev))\r\nreturn -EINVAL;\r\nif ((yi.cfg.mask & YAM_BITRATE) && netif_running(dev))\r\nreturn -EINVAL;\r\nif ((yi.cfg.mask & YAM_BAUDRATE) && netif_running(dev))\r\nreturn -EINVAL;\r\nif (yi.cfg.mask & YAM_IOBASE) {\r\nyp->iobase = yi.cfg.iobase;\r\ndev->base_addr = yi.cfg.iobase;\r\n}\r\nif (yi.cfg.mask & YAM_IRQ) {\r\nif (yi.cfg.irq > 15)\r\nreturn -EINVAL;\r\nyp->irq = yi.cfg.irq;\r\ndev->irq = yi.cfg.irq;\r\n}\r\nif (yi.cfg.mask & YAM_BITRATE) {\r\nif (yi.cfg.bitrate > YAM_MAXBITRATE)\r\nreturn -EINVAL;\r\nyp->bitrate = yi.cfg.bitrate;\r\n}\r\nif (yi.cfg.mask & YAM_BAUDRATE) {\r\nif (yi.cfg.baudrate > YAM_MAXBAUDRATE)\r\nreturn -EINVAL;\r\nyp->baudrate = yi.cfg.baudrate;\r\n}\r\nif (yi.cfg.mask & YAM_MODE) {\r\nif (yi.cfg.mode > YAM_MAXMODE)\r\nreturn -EINVAL;\r\nyp->dupmode = yi.cfg.mode;\r\n}\r\nif (yi.cfg.mask & YAM_HOLDDLY) {\r\nif (yi.cfg.holddly > YAM_MAXHOLDDLY)\r\nreturn -EINVAL;\r\nyp->holdd = yi.cfg.holddly;\r\n}\r\nif (yi.cfg.mask & YAM_TXDELAY) {\r\nif (yi.cfg.txdelay > YAM_MAXTXDELAY)\r\nreturn -EINVAL;\r\nyp->txd = yi.cfg.txdelay;\r\n}\r\nif (yi.cfg.mask & YAM_TXTAIL) {\r\nif (yi.cfg.txtail > YAM_MAXTXTAIL)\r\nreturn -EINVAL;\r\nyp->txtail = yi.cfg.txtail;\r\n}\r\nif (yi.cfg.mask & YAM_PERSIST) {\r\nif (yi.cfg.persist > YAM_MAXPERSIST)\r\nreturn -EINVAL;\r\nyp->pers = yi.cfg.persist;\r\n}\r\nif (yi.cfg.mask & YAM_SLOTTIME) {\r\nif (yi.cfg.slottime > YAM_MAXSLOTTIME)\r\nreturn -EINVAL;\r\nyp->slot = yi.cfg.slottime;\r\nyp->slotcnt = yp->slot / 10;\r\n}\r\nbreak;\r\ncase SIOCYAMGCFG:\r\nmemset(&yi, 0, sizeof(yi));\r\nyi.cfg.mask = 0xffffffff;\r\nyi.cfg.iobase = yp->iobase;\r\nyi.cfg.irq = yp->irq;\r\nyi.cfg.bitrate = yp->bitrate;\r\nyi.cfg.baudrate = yp->baudrate;\r\nyi.cfg.mode = yp->dupmode;\r\nyi.cfg.txdelay = yp->txd;\r\nyi.cfg.holddly = yp->holdd;\r\nyi.cfg.txtail = yp->txtail;\r\nyi.cfg.persist = yp->pers;\r\nyi.cfg.slottime = yp->slot;\r\nif (copy_to_user(ifr->ifr_data, &yi, sizeof(struct yamdrv_ioctl_cfg)))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int yam_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *sa = (struct sockaddr *) addr;\r\nmemcpy(dev->dev_addr, sa->sa_data, dev->addr_len);\r\nreturn 0;\r\n}\r\nstatic void yam_setup(struct net_device *dev)\r\n{\r\nstruct yam_port *yp = netdev_priv(dev);\r\nyp->magic = YAM_MAGIC;\r\nyp->bitrate = DEFAULT_BITRATE;\r\nyp->baudrate = DEFAULT_BITRATE * 2;\r\nyp->iobase = 0;\r\nyp->irq = 0;\r\nyp->dupmode = 0;\r\nyp->holdd = DEFAULT_HOLDD;\r\nyp->txd = DEFAULT_TXD;\r\nyp->txtail = DEFAULT_TXTAIL;\r\nyp->slot = DEFAULT_SLOT;\r\nyp->pers = DEFAULT_PERS;\r\nyp->dev = dev;\r\ndev->base_addr = yp->iobase;\r\ndev->irq = yp->irq;\r\nskb_queue_head_init(&yp->send_queue);\r\ndev->netdev_ops = &yam_netdev_ops;\r\ndev->header_ops = &ax25_header_ops;\r\ndev->type = ARPHRD_AX25;\r\ndev->hard_header_len = AX25_MAX_HEADER_LEN;\r\ndev->mtu = AX25_MTU;\r\ndev->addr_len = AX25_ADDR_LEN;\r\nmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\r\nmemcpy(dev->dev_addr, &ax25_defaddr, AX25_ADDR_LEN);\r\n}\r\nstatic int __init yam_init_driver(void)\r\n{\r\nstruct net_device *dev;\r\nint i, err;\r\nchar name[IFNAMSIZ];\r\nprintk(yam_drvinfo);\r\nfor (i = 0; i < NR_PORTS; i++) {\r\nsprintf(name, "yam%d", i);\r\ndev = alloc_netdev(sizeof(struct yam_port), name,\r\nNET_NAME_UNKNOWN, yam_setup);\r\nif (!dev) {\r\npr_err("yam: cannot allocate net device\n");\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nerr = register_netdev(dev);\r\nif (err) {\r\nprintk(KERN_WARNING "yam: cannot register net device %s\n", dev->name);\r\ngoto error;\r\n}\r\nyam_devs[i] = dev;\r\n}\r\nyam_timer.function = yam_dotimer;\r\nyam_timer.expires = jiffies + HZ / 100;\r\nadd_timer(&yam_timer);\r\nproc_create("yam", S_IRUGO, init_net.proc_net, &yam_info_fops);\r\nreturn 0;\r\nerror:\r\nwhile (--i >= 0) {\r\nunregister_netdev(yam_devs[i]);\r\nfree_netdev(yam_devs[i]);\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit yam_cleanup_driver(void)\r\n{\r\nstruct yam_mcs *p;\r\nint i;\r\ndel_timer_sync(&yam_timer);\r\nfor (i = 0; i < NR_PORTS; i++) {\r\nstruct net_device *dev = yam_devs[i];\r\nif (dev) {\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\nwhile (yam_data) {\r\np = yam_data;\r\nyam_data = yam_data->next;\r\nkfree(p);\r\n}\r\nremove_proc_entry("yam", init_net.proc_net);\r\n}
