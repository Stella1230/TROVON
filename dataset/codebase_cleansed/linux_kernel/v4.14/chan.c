static int\r\nnvkm_fifo_chan_child_fini(struct nvkm_oproxy *base, bool suspend)\r\n{\r\nstruct nvkm_fifo_chan_object *object =\r\ncontainer_of(base, typeof(*object), oproxy);\r\nstruct nvkm_engine *engine = object->oproxy.object->engine;\r\nstruct nvkm_fifo_chan *chan = object->chan;\r\nstruct nvkm_fifo_engn *engn = &chan->engn[engine->subdev.index];\r\nconst char *name = nvkm_subdev_name[engine->subdev.index];\r\nint ret = 0;\r\nif (--engn->usecount)\r\nreturn 0;\r\nif (chan->func->engine_fini) {\r\nret = chan->func->engine_fini(chan, engine, suspend);\r\nif (ret) {\r\nnvif_error(&chan->object,\r\n"detach %s failed, %d\n", name, ret);\r\nreturn ret;\r\n}\r\n}\r\nif (engn->object) {\r\nret = nvkm_object_fini(engn->object, suspend);\r\nif (ret && suspend)\r\nreturn ret;\r\n}\r\nnvif_trace(&chan->object, "detached %s\n", name);\r\nreturn ret;\r\n}\r\nstatic int\r\nnvkm_fifo_chan_child_init(struct nvkm_oproxy *base)\r\n{\r\nstruct nvkm_fifo_chan_object *object =\r\ncontainer_of(base, typeof(*object), oproxy);\r\nstruct nvkm_engine *engine = object->oproxy.object->engine;\r\nstruct nvkm_fifo_chan *chan = object->chan;\r\nstruct nvkm_fifo_engn *engn = &chan->engn[engine->subdev.index];\r\nconst char *name = nvkm_subdev_name[engine->subdev.index];\r\nint ret;\r\nif (engn->usecount++)\r\nreturn 0;\r\nif (engn->object) {\r\nret = nvkm_object_init(engn->object);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (chan->func->engine_init) {\r\nret = chan->func->engine_init(chan, engine);\r\nif (ret) {\r\nnvif_error(&chan->object,\r\n"attach %s failed, %d\n", name, ret);\r\nreturn ret;\r\n}\r\n}\r\nnvif_trace(&chan->object, "attached %s\n", name);\r\nreturn 0;\r\n}\r\nstatic void\r\nnvkm_fifo_chan_child_del(struct nvkm_oproxy *base)\r\n{\r\nstruct nvkm_fifo_chan_object *object =\r\ncontainer_of(base, typeof(*object), oproxy);\r\nstruct nvkm_engine *engine = object->oproxy.base.engine;\r\nstruct nvkm_fifo_chan *chan = object->chan;\r\nstruct nvkm_fifo_engn *engn = &chan->engn[engine->subdev.index];\r\nif (chan->func->object_dtor)\r\nchan->func->object_dtor(chan, object->hash);\r\nif (!--engn->refcount) {\r\nif (chan->func->engine_dtor)\r\nchan->func->engine_dtor(chan, engine);\r\nnvkm_object_del(&engn->object);\r\nif (chan->vm)\r\natomic_dec(&chan->vm->engref[engine->subdev.index]);\r\n}\r\n}\r\nstatic int\r\nnvkm_fifo_chan_child_new(const struct nvkm_oclass *oclass, void *data, u32 size,\r\nstruct nvkm_object **pobject)\r\n{\r\nstruct nvkm_engine *engine = oclass->engine;\r\nstruct nvkm_fifo_chan *chan = nvkm_fifo_chan(oclass->parent);\r\nstruct nvkm_fifo_engn *engn = &chan->engn[engine->subdev.index];\r\nstruct nvkm_fifo_chan_object *object;\r\nint ret = 0;\r\nif (!(object = kzalloc(sizeof(*object), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nnvkm_oproxy_ctor(&nvkm_fifo_chan_child_func, oclass, &object->oproxy);\r\nobject->chan = chan;\r\n*pobject = &object->oproxy.base;\r\nif (!engn->refcount++) {\r\nstruct nvkm_oclass cclass = {\r\n.client = oclass->client,\r\n.engine = oclass->engine,\r\n};\r\nif (chan->vm)\r\natomic_inc(&chan->vm->engref[engine->subdev.index]);\r\nif (engine->func->fifo.cclass) {\r\nret = engine->func->fifo.cclass(chan, &cclass,\r\n&engn->object);\r\n} else\r\nif (engine->func->cclass) {\r\nret = nvkm_object_new_(engine->func->cclass, &cclass,\r\nNULL, 0, &engn->object);\r\n}\r\nif (ret)\r\nreturn ret;\r\nif (chan->func->engine_ctor) {\r\nret = chan->func->engine_ctor(chan, oclass->engine,\r\nengn->object);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nret = oclass->base.ctor(&(const struct nvkm_oclass) {\r\n.base = oclass->base,\r\n.engn = oclass->engn,\r\n.handle = oclass->handle,\r\n.object = oclass->object,\r\n.client = oclass->client,\r\n.parent = engn->object ?\r\nengn->object :\r\noclass->parent,\r\n.engine = engine,\r\n}, data, size, &object->oproxy.object);\r\nif (ret)\r\nreturn ret;\r\nif (chan->func->object_ctor) {\r\nobject->hash =\r\nchan->func->object_ctor(chan, object->oproxy.object);\r\nif (object->hash < 0)\r\nreturn object->hash;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnvkm_fifo_chan_child_get(struct nvkm_object *object, int index,\r\nstruct nvkm_oclass *oclass)\r\n{\r\nstruct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);\r\nstruct nvkm_fifo *fifo = chan->fifo;\r\nstruct nvkm_device *device = fifo->engine.subdev.device;\r\nstruct nvkm_engine *engine;\r\nu64 mask = chan->engines;\r\nint ret, i, c;\r\nfor (; c = 0, i = __ffs64(mask), mask; mask &= ~(1ULL << i)) {\r\nif (!(engine = nvkm_device_engine(device, i)))\r\ncontinue;\r\noclass->engine = engine;\r\noclass->base.oclass = 0;\r\nif (engine->func->fifo.sclass) {\r\nret = engine->func->fifo.sclass(oclass, index);\r\nif (oclass->base.oclass) {\r\nif (!oclass->base.ctor)\r\noclass->base.ctor = nvkm_object_new;\r\noclass->ctor = nvkm_fifo_chan_child_new;\r\nreturn 0;\r\n}\r\nindex -= ret;\r\ncontinue;\r\n}\r\nwhile (engine->func->sclass[c].oclass) {\r\nif (c++ == index) {\r\noclass->base = engine->func->sclass[index];\r\nif (!oclass->base.ctor)\r\noclass->base.ctor = nvkm_object_new;\r\noclass->ctor = nvkm_fifo_chan_child_new;\r\nreturn 0;\r\n}\r\n}\r\nindex -= c;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nnvkm_fifo_chan_ntfy(struct nvkm_object *object, u32 type,\r\nstruct nvkm_event **pevent)\r\n{\r\nstruct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);\r\nif (chan->func->ntfy)\r\nreturn chan->func->ntfy(chan, type, pevent);\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nnvkm_fifo_chan_map(struct nvkm_object *object, u64 *addr, u32 *size)\r\n{\r\nstruct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);\r\n*addr = chan->addr;\r\n*size = chan->size;\r\nreturn 0;\r\n}\r\nstatic int\r\nnvkm_fifo_chan_rd32(struct nvkm_object *object, u64 addr, u32 *data)\r\n{\r\nstruct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);\r\nif (unlikely(!chan->user)) {\r\nchan->user = ioremap(chan->addr, chan->size);\r\nif (!chan->user)\r\nreturn -ENOMEM;\r\n}\r\nif (unlikely(addr + 4 > chan->size))\r\nreturn -EINVAL;\r\n*data = ioread32_native(chan->user + addr);\r\nreturn 0;\r\n}\r\nstatic int\r\nnvkm_fifo_chan_wr32(struct nvkm_object *object, u64 addr, u32 data)\r\n{\r\nstruct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);\r\nif (unlikely(!chan->user)) {\r\nchan->user = ioremap(chan->addr, chan->size);\r\nif (!chan->user)\r\nreturn -ENOMEM;\r\n}\r\nif (unlikely(addr + 4 > chan->size))\r\nreturn -EINVAL;\r\niowrite32_native(data, chan->user + addr);\r\nreturn 0;\r\n}\r\nstatic int\r\nnvkm_fifo_chan_fini(struct nvkm_object *object, bool suspend)\r\n{\r\nstruct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);\r\nchan->func->fini(chan);\r\nreturn 0;\r\n}\r\nstatic int\r\nnvkm_fifo_chan_init(struct nvkm_object *object)\r\n{\r\nstruct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);\r\nchan->func->init(chan);\r\nreturn 0;\r\n}\r\nstatic void *\r\nnvkm_fifo_chan_dtor(struct nvkm_object *object)\r\n{\r\nstruct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);\r\nstruct nvkm_fifo *fifo = chan->fifo;\r\nvoid *data = chan->func->dtor(chan);\r\nunsigned long flags;\r\nspin_lock_irqsave(&fifo->lock, flags);\r\nif (!list_empty(&chan->head)) {\r\n__clear_bit(chan->chid, fifo->mask);\r\nlist_del(&chan->head);\r\n}\r\nspin_unlock_irqrestore(&fifo->lock, flags);\r\nif (chan->user)\r\niounmap(chan->user);\r\nnvkm_vm_ref(NULL, &chan->vm, NULL);\r\nnvkm_gpuobj_del(&chan->push);\r\nnvkm_gpuobj_del(&chan->inst);\r\nreturn data;\r\n}\r\nint\r\nnvkm_fifo_chan_ctor(const struct nvkm_fifo_chan_func *func,\r\nstruct nvkm_fifo *fifo, u32 size, u32 align, bool zero,\r\nu64 vm, u64 push, u64 engines, int bar, u32 base, u32 user,\r\nconst struct nvkm_oclass *oclass,\r\nstruct nvkm_fifo_chan *chan)\r\n{\r\nstruct nvkm_client *client = oclass->client;\r\nstruct nvkm_device *device = fifo->engine.subdev.device;\r\nstruct nvkm_mmu *mmu = device->mmu;\r\nstruct nvkm_dmaobj *dmaobj;\r\nunsigned long flags;\r\nint ret;\r\nnvkm_object_ctor(&nvkm_fifo_chan_func, oclass, &chan->object);\r\nchan->func = func;\r\nchan->fifo = fifo;\r\nchan->engines = engines;\r\nINIT_LIST_HEAD(&chan->head);\r\nret = nvkm_gpuobj_new(device, size, align, zero, NULL, &chan->inst);\r\nif (ret)\r\nreturn ret;\r\nif (push) {\r\ndmaobj = nvkm_dmaobj_search(client, push);\r\nif (IS_ERR(dmaobj))\r\nreturn PTR_ERR(dmaobj);\r\nret = nvkm_object_bind(&dmaobj->object, chan->inst, -16,\r\n&chan->push);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!vm && mmu) {\r\nif (!client->vm || client->vm->mmu == mmu) {\r\nret = nvkm_vm_ref(client->vm, &chan->vm, NULL);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nreturn -ENOENT;\r\n}\r\nspin_lock_irqsave(&fifo->lock, flags);\r\nchan->chid = find_first_zero_bit(fifo->mask, NVKM_FIFO_CHID_NR);\r\nif (chan->chid >= NVKM_FIFO_CHID_NR) {\r\nspin_unlock_irqrestore(&fifo->lock, flags);\r\nreturn -ENOSPC;\r\n}\r\nlist_add(&chan->head, &fifo->chan);\r\n__set_bit(chan->chid, fifo->mask);\r\nspin_unlock_irqrestore(&fifo->lock, flags);\r\nchan->addr = device->func->resource_addr(device, bar) +\r\nbase + user * chan->chid;\r\nchan->size = user;\r\nnvkm_fifo_cevent(fifo);\r\nreturn 0;\r\n}
