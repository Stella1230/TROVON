static void tpm2_flush_sessions(struct tpm_chip *chip, struct tpm_space *space)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(space->session_tbl); i++) {\r\nif (space->session_tbl[i])\r\ntpm2_flush_context_cmd(chip, space->session_tbl[i],\r\nTPM_TRANSMIT_UNLOCKED);\r\n}\r\n}\r\nint tpm2_init_space(struct tpm_space *space)\r\n{\r\nspace->context_buf = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!space->context_buf)\r\nreturn -ENOMEM;\r\nspace->session_buf = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (space->session_buf == NULL) {\r\nkfree(space->context_buf);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid tpm2_del_space(struct tpm_chip *chip, struct tpm_space *space)\r\n{\r\nmutex_lock(&chip->tpm_mutex);\r\ntpm2_flush_sessions(chip, space);\r\nmutex_unlock(&chip->tpm_mutex);\r\nkfree(space->context_buf);\r\nkfree(space->session_buf);\r\n}\r\nstatic int tpm2_load_context(struct tpm_chip *chip, u8 *buf,\r\nunsigned int *offset, u32 *handle)\r\n{\r\nstruct tpm_buf tbuf;\r\nstruct tpm2_context *ctx;\r\nunsigned int body_size;\r\nint rc;\r\nrc = tpm_buf_init(&tbuf, TPM2_ST_NO_SESSIONS, TPM2_CC_CONTEXT_LOAD);\r\nif (rc)\r\nreturn rc;\r\nctx = (struct tpm2_context *)&buf[*offset];\r\nbody_size = sizeof(*ctx) + be16_to_cpu(ctx->blob_size);\r\ntpm_buf_append(&tbuf, &buf[*offset], body_size);\r\nrc = tpm_transmit_cmd(chip, NULL, tbuf.data, PAGE_SIZE, 4,\r\nTPM_TRANSMIT_UNLOCKED, NULL);\r\nif (rc < 0) {\r\ndev_warn(&chip->dev, "%s: failed with a system error %d\n",\r\n__func__, rc);\r\ntpm_buf_destroy(&tbuf);\r\nreturn -EFAULT;\r\n} else if (tpm2_rc_value(rc) == TPM2_RC_HANDLE ||\r\nrc == TPM2_RC_REFERENCE_H0) {\r\nrc = -ENOENT;\r\ntpm_buf_destroy(&tbuf);\r\n} else if (rc > 0) {\r\ndev_warn(&chip->dev, "%s: failed with a TPM error 0x%04X\n",\r\n__func__, rc);\r\ntpm_buf_destroy(&tbuf);\r\nreturn -EFAULT;\r\n}\r\n*handle = be32_to_cpup((__be32 *)&tbuf.data[TPM_HEADER_SIZE]);\r\n*offset += body_size;\r\ntpm_buf_destroy(&tbuf);\r\nreturn 0;\r\n}\r\nstatic int tpm2_save_context(struct tpm_chip *chip, u32 handle, u8 *buf,\r\nunsigned int buf_size, unsigned int *offset)\r\n{\r\nstruct tpm_buf tbuf;\r\nunsigned int body_size;\r\nint rc;\r\nrc = tpm_buf_init(&tbuf, TPM2_ST_NO_SESSIONS, TPM2_CC_CONTEXT_SAVE);\r\nif (rc)\r\nreturn rc;\r\ntpm_buf_append_u32(&tbuf, handle);\r\nrc = tpm_transmit_cmd(chip, NULL, tbuf.data, PAGE_SIZE, 0,\r\nTPM_TRANSMIT_UNLOCKED, NULL);\r\nif (rc < 0) {\r\ndev_warn(&chip->dev, "%s: failed with a system error %d\n",\r\n__func__, rc);\r\ntpm_buf_destroy(&tbuf);\r\nreturn -EFAULT;\r\n} else if (tpm2_rc_value(rc) == TPM2_RC_REFERENCE_H0) {\r\ntpm_buf_destroy(&tbuf);\r\nreturn -ENOENT;\r\n} else if (rc) {\r\ndev_warn(&chip->dev, "%s: failed with a TPM error 0x%04X\n",\r\n__func__, rc);\r\ntpm_buf_destroy(&tbuf);\r\nreturn -EFAULT;\r\n}\r\nbody_size = tpm_buf_length(&tbuf) - TPM_HEADER_SIZE;\r\nif ((*offset + body_size) > buf_size) {\r\ndev_warn(&chip->dev, "%s: out of backing storage\n", __func__);\r\ntpm_buf_destroy(&tbuf);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(&buf[*offset], &tbuf.data[TPM_HEADER_SIZE], body_size);\r\n*offset += body_size;\r\ntpm_buf_destroy(&tbuf);\r\nreturn 0;\r\n}\r\nstatic void tpm2_flush_space(struct tpm_chip *chip)\r\n{\r\nstruct tpm_space *space = &chip->work_space;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(space->context_tbl); i++)\r\nif (space->context_tbl[i] && ~space->context_tbl[i])\r\ntpm2_flush_context_cmd(chip, space->context_tbl[i],\r\nTPM_TRANSMIT_UNLOCKED);\r\ntpm2_flush_sessions(chip, space);\r\n}\r\nstatic int tpm2_load_space(struct tpm_chip *chip)\r\n{\r\nstruct tpm_space *space = &chip->work_space;\r\nunsigned int offset;\r\nint i;\r\nint rc;\r\nfor (i = 0, offset = 0; i < ARRAY_SIZE(space->context_tbl); i++) {\r\nif (!space->context_tbl[i])\r\ncontinue;\r\nif (~space->context_tbl[i]) {\r\ndev_err(&chip->dev, "context table is inconsistent");\r\nreturn -EFAULT;\r\n}\r\nrc = tpm2_load_context(chip, space->context_buf, &offset,\r\n&space->context_tbl[i]);\r\nif (rc)\r\nreturn rc;\r\n}\r\nfor (i = 0, offset = 0; i < ARRAY_SIZE(space->session_tbl); i++) {\r\nu32 handle;\r\nif (!space->session_tbl[i])\r\ncontinue;\r\nrc = tpm2_load_context(chip, space->session_buf,\r\n&offset, &handle);\r\nif (rc == -ENOENT) {\r\nspace->session_tbl[i] = 0;\r\n} else if (rc) {\r\ntpm2_flush_space(chip);\r\nreturn rc;\r\n}\r\nif (handle != space->session_tbl[i]) {\r\ndev_warn(&chip->dev, "session restored to wrong handle\n");\r\ntpm2_flush_space(chip);\r\nreturn -EFAULT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic bool tpm2_map_to_phandle(struct tpm_space *space, void *handle)\r\n{\r\nu32 vhandle = be32_to_cpup((__be32 *)handle);\r\nu32 phandle;\r\nint i;\r\ni = 0xFFFFFF - (vhandle & 0xFFFFFF);\r\nif (i >= ARRAY_SIZE(space->context_tbl) || !space->context_tbl[i])\r\nreturn false;\r\nphandle = space->context_tbl[i];\r\n*((__be32 *)handle) = cpu_to_be32(phandle);\r\nreturn true;\r\n}\r\nstatic int tpm2_map_command(struct tpm_chip *chip, u32 cc, u8 *cmd)\r\n{\r\nstruct tpm_space *space = &chip->work_space;\r\nunsigned int nr_handles;\r\nu32 attrs;\r\nu32 *handle;\r\nint i;\r\ni = tpm2_find_cc(chip, cc);\r\nif (i < 0)\r\nreturn -EINVAL;\r\nattrs = chip->cc_attrs_tbl[i];\r\nnr_handles = (attrs >> TPM2_CC_ATTR_CHANDLES) & GENMASK(2, 0);\r\nhandle = (u32 *)&cmd[TPM_HEADER_SIZE];\r\nfor (i = 0; i < nr_handles; i++, handle++) {\r\nif ((be32_to_cpu(*handle) & 0xFF000000) == TPM2_HT_TRANSIENT) {\r\nif (!tpm2_map_to_phandle(space, handle))\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint tpm2_prepare_space(struct tpm_chip *chip, struct tpm_space *space, u32 cc,\r\nu8 *cmd)\r\n{\r\nint rc;\r\nif (!space)\r\nreturn 0;\r\nmemcpy(&chip->work_space.context_tbl, &space->context_tbl,\r\nsizeof(space->context_tbl));\r\nmemcpy(&chip->work_space.session_tbl, &space->session_tbl,\r\nsizeof(space->session_tbl));\r\nmemcpy(chip->work_space.context_buf, space->context_buf, PAGE_SIZE);\r\nmemcpy(chip->work_space.session_buf, space->session_buf, PAGE_SIZE);\r\nrc = tpm2_load_space(chip);\r\nif (rc) {\r\ntpm2_flush_space(chip);\r\nreturn rc;\r\n}\r\nrc = tpm2_map_command(chip, cc, cmd);\r\nif (rc) {\r\ntpm2_flush_space(chip);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool tpm2_add_session(struct tpm_chip *chip, u32 handle)\r\n{\r\nstruct tpm_space *space = &chip->work_space;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(space->session_tbl); i++)\r\nif (space->session_tbl[i] == 0)\r\nbreak;\r\nif (i == ARRAY_SIZE(space->session_tbl))\r\nreturn false;\r\nspace->session_tbl[i] = handle;\r\nreturn true;\r\n}\r\nstatic u32 tpm2_map_to_vhandle(struct tpm_space *space, u32 phandle, bool alloc)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(space->context_tbl); i++) {\r\nif (alloc) {\r\nif (!space->context_tbl[i]) {\r\nspace->context_tbl[i] = phandle;\r\nbreak;\r\n}\r\n} else if (space->context_tbl[i] == phandle)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(space->context_tbl))\r\nreturn 0;\r\nreturn TPM2_HT_TRANSIENT | (0xFFFFFF - i);\r\n}\r\nstatic int tpm2_map_response_header(struct tpm_chip *chip, u32 cc, u8 *rsp,\r\nsize_t len)\r\n{\r\nstruct tpm_space *space = &chip->work_space;\r\nstruct tpm_output_header *header = (void *)rsp;\r\nu32 phandle;\r\nu32 phandle_type;\r\nu32 vhandle;\r\nu32 attrs;\r\nint i;\r\nif (be32_to_cpu(header->return_code) != TPM2_RC_SUCCESS)\r\nreturn 0;\r\ni = tpm2_find_cc(chip, cc);\r\nif (i < 0)\r\nreturn -EFAULT;\r\nattrs = chip->cc_attrs_tbl[i];\r\nif (!((attrs >> TPM2_CC_ATTR_RHANDLE) & 1))\r\nreturn 0;\r\nphandle = be32_to_cpup((__be32 *)&rsp[TPM_HEADER_SIZE]);\r\nphandle_type = phandle & 0xFF000000;\r\nswitch (phandle_type) {\r\ncase TPM2_HT_TRANSIENT:\r\nvhandle = tpm2_map_to_vhandle(space, phandle, true);\r\nif (!vhandle)\r\ngoto out_no_slots;\r\n*(__be32 *)&rsp[TPM_HEADER_SIZE] = cpu_to_be32(vhandle);\r\nbreak;\r\ncase TPM2_HT_HMAC_SESSION:\r\ncase TPM2_HT_POLICY_SESSION:\r\nif (!tpm2_add_session(chip, phandle))\r\ngoto out_no_slots;\r\nbreak;\r\ndefault:\r\ndev_err(&chip->dev, "%s: unknown handle 0x%08X\n",\r\n__func__, phandle);\r\nbreak;\r\n};\r\nreturn 0;\r\nout_no_slots:\r\ntpm2_flush_context_cmd(chip, phandle, TPM_TRANSMIT_UNLOCKED);\r\ndev_warn(&chip->dev, "%s: out of slots for 0x%08X\n", __func__,\r\nphandle);\r\nreturn -ENOMEM;\r\n}\r\nstatic int tpm2_map_response_body(struct tpm_chip *chip, u32 cc, u8 *rsp,\r\nsize_t len)\r\n{\r\nstruct tpm_space *space = &chip->work_space;\r\nstruct tpm_output_header *header = (void *)rsp;\r\nstruct tpm2_cap_handles *data;\r\nu32 phandle;\r\nu32 phandle_type;\r\nu32 vhandle;\r\nint i;\r\nint j;\r\nif (cc != TPM2_CC_GET_CAPABILITY ||\r\nbe32_to_cpu(header->return_code) != TPM2_RC_SUCCESS) {\r\nreturn 0;\r\n}\r\nif (len < TPM_HEADER_SIZE + 9)\r\nreturn -EFAULT;\r\ndata = (void *)&rsp[TPM_HEADER_SIZE];\r\nif (be32_to_cpu(data->capability) != TPM2_CAP_HANDLES)\r\nreturn 0;\r\nif (len != TPM_HEADER_SIZE + 9 + 4 * be32_to_cpu(data->count))\r\nreturn -EFAULT;\r\nfor (i = 0, j = 0; i < be32_to_cpu(data->count); i++) {\r\nphandle = be32_to_cpup((__be32 *)&data->handles[i]);\r\nphandle_type = phandle & 0xFF000000;\r\nswitch (phandle_type) {\r\ncase TPM2_HT_TRANSIENT:\r\nvhandle = tpm2_map_to_vhandle(space, phandle, false);\r\nif (!vhandle)\r\nbreak;\r\ndata->handles[j] = cpu_to_be32(vhandle);\r\nj++;\r\nbreak;\r\ndefault:\r\ndata->handles[j] = cpu_to_be32(phandle);\r\nj++;\r\nbreak;\r\n}\r\n}\r\nheader->length = cpu_to_be32(TPM_HEADER_SIZE + 9 + 4 * j);\r\ndata->count = cpu_to_be32(j);\r\nreturn 0;\r\n}\r\nstatic int tpm2_save_space(struct tpm_chip *chip)\r\n{\r\nstruct tpm_space *space = &chip->work_space;\r\nunsigned int offset;\r\nint i;\r\nint rc;\r\nfor (i = 0, offset = 0; i < ARRAY_SIZE(space->context_tbl); i++) {\r\nif (!(space->context_tbl[i] && ~space->context_tbl[i]))\r\ncontinue;\r\nrc = tpm2_save_context(chip, space->context_tbl[i],\r\nspace->context_buf, PAGE_SIZE,\r\n&offset);\r\nif (rc == -ENOENT) {\r\nspace->context_tbl[i] = 0;\r\ncontinue;\r\n} else if (rc)\r\nreturn rc;\r\ntpm2_flush_context_cmd(chip, space->context_tbl[i],\r\nTPM_TRANSMIT_UNLOCKED);\r\nspace->context_tbl[i] = ~0;\r\n}\r\nfor (i = 0, offset = 0; i < ARRAY_SIZE(space->session_tbl); i++) {\r\nif (!space->session_tbl[i])\r\ncontinue;\r\nrc = tpm2_save_context(chip, space->session_tbl[i],\r\nspace->session_buf, PAGE_SIZE,\r\n&offset);\r\nif (rc == -ENOENT) {\r\nspace->session_tbl[i] = 0;\r\n} else if (rc < 0) {\r\ntpm2_flush_space(chip);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint tpm2_commit_space(struct tpm_chip *chip, struct tpm_space *space,\r\nu32 cc, u8 *buf, size_t *bufsiz)\r\n{\r\nstruct tpm_output_header *header = (void *)buf;\r\nint rc;\r\nif (!space)\r\nreturn 0;\r\nrc = tpm2_map_response_header(chip, cc, buf, *bufsiz);\r\nif (rc) {\r\ntpm2_flush_space(chip);\r\nreturn rc;\r\n}\r\nrc = tpm2_map_response_body(chip, cc, buf, *bufsiz);\r\nif (rc) {\r\ntpm2_flush_space(chip);\r\nreturn rc;\r\n}\r\nrc = tpm2_save_space(chip);\r\nif (rc) {\r\ntpm2_flush_space(chip);\r\nreturn rc;\r\n}\r\n*bufsiz = be32_to_cpu(header->length);\r\nmemcpy(&space->context_tbl, &chip->work_space.context_tbl,\r\nsizeof(space->context_tbl));\r\nmemcpy(&space->session_tbl, &chip->work_space.session_tbl,\r\nsizeof(space->session_tbl));\r\nmemcpy(space->context_buf, chip->work_space.context_buf, PAGE_SIZE);\r\nmemcpy(space->session_buf, chip->work_space.session_buf, PAGE_SIZE);\r\nreturn 0;\r\n}
