static int adf_enable_msi(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct adf_accel_pci *pci_dev_info = &accel_dev->accel_pci_dev;\r\nint stat = pci_enable_msi(pci_dev_info->pci_dev);\r\nif (stat) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"Failed to enable MSI interrupts\n");\r\nreturn stat;\r\n}\r\naccel_dev->vf.irq_name = kzalloc(ADF_MAX_MSIX_VECTOR_NAME, GFP_KERNEL);\r\nif (!accel_dev->vf.irq_name)\r\nreturn -ENOMEM;\r\nreturn stat;\r\n}\r\nstatic void adf_disable_msi(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct pci_dev *pdev = accel_to_pci_dev(accel_dev);\r\nkfree(accel_dev->vf.irq_name);\r\npci_disable_msi(pdev);\r\n}\r\nstatic void adf_dev_stop_async(struct work_struct *work)\r\n{\r\nstruct adf_vf_stop_data *stop_data =\r\ncontainer_of(work, struct adf_vf_stop_data, work);\r\nstruct adf_accel_dev *accel_dev = stop_data->accel_dev;\r\nadf_dev_stop(accel_dev);\r\nadf_dev_shutdown(accel_dev);\r\nadf_enable_pf2vf_interrupts(accel_dev);\r\nkfree(stop_data);\r\n}\r\nstatic void adf_pf2vf_bh_handler(void *data)\r\n{\r\nstruct adf_accel_dev *accel_dev = data;\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nstruct adf_bar *pmisc =\r\n&GET_BARS(accel_dev)[hw_data->get_misc_bar_id(hw_data)];\r\nvoid __iomem *pmisc_bar_addr = pmisc->virt_addr;\r\nu32 msg;\r\nmsg = ADF_CSR_RD(pmisc_bar_addr, hw_data->get_pf2vf_offset(0));\r\nif (!(msg & ADF_PF2VF_MSGORIGIN_SYSTEM))\r\ngoto err;\r\nswitch ((msg & ADF_PF2VF_MSGTYPE_MASK) >> ADF_PF2VF_MSGTYPE_SHIFT) {\r\ncase ADF_PF2VF_MSGTYPE_RESTARTING: {\r\nstruct adf_vf_stop_data *stop_data;\r\ndev_dbg(&GET_DEV(accel_dev),\r\n"Restarting msg received from PF 0x%x\n", msg);\r\nclear_bit(ADF_STATUS_PF_RUNNING, &accel_dev->status);\r\nstop_data = kzalloc(sizeof(*stop_data), GFP_ATOMIC);\r\nif (!stop_data) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"Couldn't schedule stop for vf_%d\n",\r\naccel_dev->accel_id);\r\nreturn;\r\n}\r\nstop_data->accel_dev = accel_dev;\r\nINIT_WORK(&stop_data->work, adf_dev_stop_async);\r\nqueue_work(adf_vf_stop_wq, &stop_data->work);\r\nmsg &= ~ADF_PF2VF_INT;\r\nADF_CSR_WR(pmisc_bar_addr, hw_data->get_pf2vf_offset(0), msg);\r\nreturn;\r\n}\r\ncase ADF_PF2VF_MSGTYPE_VERSION_RESP:\r\ndev_dbg(&GET_DEV(accel_dev),\r\n"Version resp received from PF 0x%x\n", msg);\r\naccel_dev->vf.pf_version =\r\n(msg & ADF_PF2VF_VERSION_RESP_VERS_MASK) >>\r\nADF_PF2VF_VERSION_RESP_VERS_SHIFT;\r\naccel_dev->vf.compatible =\r\n(msg & ADF_PF2VF_VERSION_RESP_RESULT_MASK) >>\r\nADF_PF2VF_VERSION_RESP_RESULT_SHIFT;\r\ncomplete(&accel_dev->vf.iov_msg_completion);\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\nmsg &= ~ADF_PF2VF_INT;\r\nADF_CSR_WR(pmisc_bar_addr, hw_data->get_pf2vf_offset(0), msg);\r\nadf_enable_pf2vf_interrupts(accel_dev);\r\nreturn;\r\nerr:\r\ndev_err(&GET_DEV(accel_dev),\r\n"Unknown message from PF (0x%x); leaving PF2VF ints disabled\n",\r\nmsg);\r\n}\r\nstatic int adf_setup_pf2vf_bh(struct adf_accel_dev *accel_dev)\r\n{\r\ntasklet_init(&accel_dev->vf.pf2vf_bh_tasklet,\r\n(void *)adf_pf2vf_bh_handler, (unsigned long)accel_dev);\r\nmutex_init(&accel_dev->vf.vf2pf_lock);\r\nreturn 0;\r\n}\r\nstatic void adf_cleanup_pf2vf_bh(struct adf_accel_dev *accel_dev)\r\n{\r\ntasklet_disable(&accel_dev->vf.pf2vf_bh_tasklet);\r\ntasklet_kill(&accel_dev->vf.pf2vf_bh_tasklet);\r\nmutex_destroy(&accel_dev->vf.vf2pf_lock);\r\n}\r\nstatic irqreturn_t adf_isr(int irq, void *privdata)\r\n{\r\nstruct adf_accel_dev *accel_dev = privdata;\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nstruct adf_bar *pmisc =\r\n&GET_BARS(accel_dev)[hw_data->get_misc_bar_id(hw_data)];\r\nvoid __iomem *pmisc_bar_addr = pmisc->virt_addr;\r\nu32 v_int;\r\nv_int = ADF_CSR_RD(pmisc_bar_addr, ADF_VINTSOU_OFFSET);\r\nif (v_int & ADF_VINTSOU_PF2VF) {\r\nadf_disable_pf2vf_interrupts(accel_dev);\r\ntasklet_hi_schedule(&accel_dev->vf.pf2vf_bh_tasklet);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (v_int & ADF_VINTSOU_BUN) {\r\nstruct adf_etr_data *etr_data = accel_dev->transport;\r\nstruct adf_etr_bank_data *bank = &etr_data->banks[0];\r\nWRITE_CSR_INT_FLAG_AND_COL(bank->csr_addr, bank->bank_number,\r\n0);\r\ntasklet_hi_schedule(&bank->resp_handler);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int adf_request_msi_irq(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct pci_dev *pdev = accel_to_pci_dev(accel_dev);\r\nunsigned int cpu;\r\nint ret;\r\nsnprintf(accel_dev->vf.irq_name, ADF_MAX_MSIX_VECTOR_NAME,\r\n"qat_%02x:%02d.%02d", pdev->bus->number, PCI_SLOT(pdev->devfn),\r\nPCI_FUNC(pdev->devfn));\r\nret = request_irq(pdev->irq, adf_isr, 0, accel_dev->vf.irq_name,\r\n(void *)accel_dev);\r\nif (ret) {\r\ndev_err(&GET_DEV(accel_dev), "failed to enable irq for %s\n",\r\naccel_dev->vf.irq_name);\r\nreturn ret;\r\n}\r\ncpu = accel_dev->accel_id % num_online_cpus();\r\nirq_set_affinity_hint(pdev->irq, get_cpu_mask(cpu));\r\nreturn ret;\r\n}\r\nstatic int adf_setup_bh(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct adf_etr_data *priv_data = accel_dev->transport;\r\ntasklet_init(&priv_data->banks[0].resp_handler, adf_response_handler,\r\n(unsigned long)priv_data->banks);\r\nreturn 0;\r\n}\r\nstatic void adf_cleanup_bh(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct adf_etr_data *priv_data = accel_dev->transport;\r\ntasklet_disable(&priv_data->banks[0].resp_handler);\r\ntasklet_kill(&priv_data->banks[0].resp_handler);\r\n}\r\nvoid adf_vf_isr_resource_free(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct pci_dev *pdev = accel_to_pci_dev(accel_dev);\r\nirq_set_affinity_hint(pdev->irq, NULL);\r\nfree_irq(pdev->irq, (void *)accel_dev);\r\nadf_cleanup_bh(accel_dev);\r\nadf_cleanup_pf2vf_bh(accel_dev);\r\nadf_disable_msi(accel_dev);\r\n}\r\nint adf_vf_isr_resource_alloc(struct adf_accel_dev *accel_dev)\r\n{\r\nif (adf_enable_msi(accel_dev))\r\ngoto err_out;\r\nif (adf_setup_pf2vf_bh(accel_dev))\r\ngoto err_out;\r\nif (adf_setup_bh(accel_dev))\r\ngoto err_out;\r\nif (adf_request_msi_irq(accel_dev))\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\nadf_vf_isr_resource_free(accel_dev);\r\nreturn -EFAULT;\r\n}\r\nint __init adf_init_vf_wq(void)\r\n{\r\nadf_vf_stop_wq = alloc_workqueue("adf_vf_stop_wq", WQ_MEM_RECLAIM, 0);\r\nreturn !adf_vf_stop_wq ? -EFAULT : 0;\r\n}\r\nvoid adf_exit_vf_wq(void)\r\n{\r\nif (adf_vf_stop_wq)\r\ndestroy_workqueue(adf_vf_stop_wq);\r\nadf_vf_stop_wq = NULL;\r\n}
