static inline struct ov5647 *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct ov5647, sd);\r\n}\r\nstatic int ov5647_write(struct v4l2_subdev *sd, u16 reg, u8 val)\r\n{\r\nint ret;\r\nunsigned char data[3] = { reg >> 8, reg & 0xff, val};\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nret = i2c_master_send(client, data, 3);\r\nif (ret < 0)\r\ndev_dbg(&client->dev, "%s: i2c write error, reg: %x\n",\r\n__func__, reg);\r\nreturn ret;\r\n}\r\nstatic int ov5647_read(struct v4l2_subdev *sd, u16 reg, u8 *val)\r\n{\r\nint ret;\r\nunsigned char data_w[2] = { reg >> 8, reg & 0xff };\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nret = i2c_master_send(client, data_w, 2);\r\nif (ret < 0) {\r\ndev_dbg(&client->dev, "%s: i2c write error, reg: %x\n",\r\n__func__, reg);\r\nreturn ret;\r\n}\r\nret = i2c_master_recv(client, val, 1);\r\nif (ret < 0)\r\ndev_dbg(&client->dev, "%s: i2c read error, reg: %x\n",\r\n__func__, reg);\r\nreturn ret;\r\n}\r\nstatic int ov5647_write_array(struct v4l2_subdev *sd,\r\nstruct regval_list *regs, int array_size)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < array_size; i++) {\r\nret = ov5647_write(sd, regs[i].addr, regs[i].data);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov5647_set_virtual_channel(struct v4l2_subdev *sd, int channel)\r\n{\r\nu8 channel_id;\r\nint ret;\r\nret = ov5647_read(sd, 0x4814, &channel_id);\r\nif (ret < 0)\r\nreturn ret;\r\nchannel_id &= ~(3 << 6);\r\nreturn ov5647_write(sd, 0x4814, channel_id | (channel << 6));\r\n}\r\nstatic int ov5647_stream_on(struct v4l2_subdev *sd)\r\n{\r\nint ret;\r\nret = ov5647_write(sd, 0x4202, 0x00);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ov5647_write(sd, 0x300D, 0x00);\r\n}\r\nstatic int ov5647_stream_off(struct v4l2_subdev *sd)\r\n{\r\nint ret;\r\nret = ov5647_write(sd, 0x4202, 0x0f);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ov5647_write(sd, 0x300D, 0x01);\r\n}\r\nstatic int set_sw_standby(struct v4l2_subdev *sd, bool standby)\r\n{\r\nint ret;\r\nu8 rdval;\r\nret = ov5647_read(sd, 0x0100, &rdval);\r\nif (ret < 0)\r\nreturn ret;\r\nif (standby)\r\nrdval &= ~0x01;\r\nelse\r\nrdval |= 0x01;\r\nreturn ov5647_write(sd, 0x0100, rdval);\r\n}\r\nstatic int __sensor_init(struct v4l2_subdev *sd)\r\n{\r\nint ret;\r\nu8 resetval, rdval;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nret = ov5647_read(sd, 0x0100, &rdval);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov5647_write_array(sd, ov5647_640x480,\r\nARRAY_SIZE(ov5647_640x480));\r\nif (ret < 0) {\r\ndev_err(&client->dev, "write sensor default regs error\n");\r\nreturn ret;\r\n}\r\nret = ov5647_set_virtual_channel(sd, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov5647_read(sd, 0x0100, &resetval);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(resetval & 0x01)) {\r\ndev_err(&client->dev, "Device was in SW standby");\r\nret = ov5647_write(sd, 0x0100, 0x01);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn ov5647_write(sd, 0x4800, 0x04);\r\n}\r\nstatic int ov5647_sensor_power(struct v4l2_subdev *sd, int on)\r\n{\r\nint ret = 0;\r\nstruct ov5647 *ov5647 = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nmutex_lock(&ov5647->lock);\r\nif (on && !ov5647->power_count) {\r\ndev_dbg(&client->dev, "OV5647 power on\n");\r\nret = clk_prepare_enable(ov5647->xclk);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "clk prepare enable failed\n");\r\ngoto out;\r\n}\r\nret = ov5647_write_array(sd, sensor_oe_enable_regs,\r\nARRAY_SIZE(sensor_oe_enable_regs));\r\nif (ret < 0) {\r\nclk_disable_unprepare(ov5647->xclk);\r\ndev_err(&client->dev,\r\n"write sensor_oe_enable_regs error\n");\r\ngoto out;\r\n}\r\nret = __sensor_init(sd);\r\nif (ret < 0) {\r\nclk_disable_unprepare(ov5647->xclk);\r\ndev_err(&client->dev,\r\n"Camera not available, check Power\n");\r\ngoto out;\r\n}\r\n} else if (!on && ov5647->power_count == 1) {\r\ndev_dbg(&client->dev, "OV5647 power off\n");\r\nret = ov5647_write_array(sd, sensor_oe_disable_regs,\r\nARRAY_SIZE(sensor_oe_disable_regs));\r\nif (ret < 0)\r\ndev_dbg(&client->dev, "disable oe failed\n");\r\nret = set_sw_standby(sd, true);\r\nif (ret < 0)\r\ndev_dbg(&client->dev, "soft stby failed\n");\r\nclk_disable_unprepare(ov5647->xclk);\r\n}\r\nov5647->power_count += on ? 1 : -1;\r\nWARN_ON(ov5647->power_count < 0);\r\nout:\r\nmutex_unlock(&ov5647->lock);\r\nreturn ret;\r\n}\r\nstatic int ov5647_sensor_get_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nu8 val;\r\nint ret;\r\nret = ov5647_read(sd, reg->reg & 0xff, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nreg->val = val;\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nstatic int ov5647_sensor_set_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nreturn ov5647_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\n}\r\nstatic int ov5647_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nif (enable)\r\nreturn ov5647_stream_on(sd);\r\nelse\r\nreturn ov5647_stream_off(sd);\r\n}\r\nstatic int ov5647_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index > 0)\r\nreturn -EINVAL;\r\ncode->code = MEDIA_BUS_FMT_SBGGR8_1X8;\r\nreturn 0;\r\n}\r\nstatic int ov5647_detect(struct v4l2_subdev *sd)\r\n{\r\nu8 read;\r\nint ret;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nret = ov5647_write(sd, OV5647_SW_RESET, 0x01);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov5647_read(sd, OV5647_REG_CHIPID_H, &read);\r\nif (ret < 0)\r\nreturn ret;\r\nif (read != 0x56) {\r\ndev_err(&client->dev, "ID High expected 0x56 got %x", read);\r\nreturn -ENODEV;\r\n}\r\nret = ov5647_read(sd, OV5647_REG_CHIPID_L, &read);\r\nif (ret < 0)\r\nreturn ret;\r\nif (read != 0x47) {\r\ndev_err(&client->dev, "ID Low expected 0x47 got %x", read);\r\nreturn -ENODEV;\r\n}\r\nreturn ov5647_write(sd, OV5647_SW_RESET, 0x00);\r\n}\r\nstatic int ov5647_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_mbus_framefmt *format =\r\nv4l2_subdev_get_try_format(sd, fh->pad, 0);\r\nstruct v4l2_rect *crop =\r\nv4l2_subdev_get_try_crop(sd, fh->pad, 0);\r\ncrop->left = OV5647_COLUMN_START_DEF;\r\ncrop->top = OV5647_ROW_START_DEF;\r\ncrop->width = OV5647_WINDOW_WIDTH_DEF;\r\ncrop->height = OV5647_WINDOW_HEIGHT_DEF;\r\nformat->code = MEDIA_BUS_FMT_SBGGR8_1X8;\r\nformat->width = OV5647_WINDOW_WIDTH_DEF;\r\nformat->height = OV5647_WINDOW_HEIGHT_DEF;\r\nformat->field = V4L2_FIELD_NONE;\r\nformat->colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn 0;\r\n}\r\nstatic int ov5647_parse_dt(struct device_node *np)\r\n{\r\nstruct v4l2_fwnode_endpoint bus_cfg;\r\nstruct device_node *ep;\r\nint ret;\r\nep = of_graph_get_next_endpoint(np, NULL);\r\nif (!ep)\r\nreturn -EINVAL;\r\nret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep), &bus_cfg);\r\nof_node_put(ep);\r\nreturn ret;\r\n}\r\nstatic int ov5647_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct ov5647 *sensor;\r\nint ret;\r\nstruct v4l2_subdev *sd;\r\nstruct device_node *np = client->dev.of_node;\r\nu32 xclk_freq;\r\nsensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);\r\nif (!sensor)\r\nreturn -ENOMEM;\r\nif (IS_ENABLED(CONFIG_OF) && np) {\r\nret = ov5647_parse_dt(np);\r\nif (ret) {\r\ndev_err(dev, "DT parsing error: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nsensor->xclk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(sensor->xclk)) {\r\ndev_err(dev, "could not get xclk");\r\nreturn PTR_ERR(sensor->xclk);\r\n}\r\nxclk_freq = clk_get_rate(sensor->xclk);\r\nif (xclk_freq != 25000000) {\r\ndev_err(dev, "Unsupported clock frequency: %u\n", xclk_freq);\r\nreturn -EINVAL;\r\n}\r\nmutex_init(&sensor->lock);\r\nsd = &sensor->sd;\r\nv4l2_i2c_subdev_init(sd, client, &ov5647_subdev_ops);\r\nsensor->sd.internal_ops = &ov5647_subdev_internal_ops;\r\nsensor->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nsensor->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nsd->entity.function = MEDIA_ENT_F_CAM_SENSOR;\r\nret = media_entity_pads_init(&sd->entity, 1, &sensor->pad);\r\nif (ret < 0)\r\ngoto mutex_remove;\r\nret = ov5647_detect(sd);\r\nif (ret < 0)\r\ngoto error;\r\nret = v4l2_async_register_subdev(sd);\r\nif (ret < 0)\r\ngoto error;\r\ndev_dbg(dev, "OmniVision OV5647 camera driver probed\n");\r\nreturn 0;\r\nerror:\r\nmedia_entity_cleanup(&sd->entity);\r\nmutex_remove:\r\nmutex_destroy(&sensor->lock);\r\nreturn ret;\r\n}\r\nstatic int ov5647_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct ov5647 *ov5647 = to_state(sd);\r\nv4l2_async_unregister_subdev(&ov5647->sd);\r\nmedia_entity_cleanup(&ov5647->sd.entity);\r\nv4l2_device_unregister_subdev(sd);\r\nmutex_destroy(&ov5647->lock);\r\nreturn 0;\r\n}
