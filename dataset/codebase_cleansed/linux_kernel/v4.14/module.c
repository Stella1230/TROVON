int apply_relocate(Elf32_Shdr *sechdrs,\r\nconst char *strtab,\r\nunsigned int symindex,\r\nunsigned int relsec,\r\nstruct module *me)\r\n{\r\nunsigned int i;\r\nElf32_Rel *rel = (void *)sechdrs[relsec].sh_addr;\r\nElf32_Sym *sym;\r\nuint32_t *location;\r\nDEBUGP("Applying relocate section %u to %u\n", relsec,\r\nsechdrs[relsec].sh_info);\r\nfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {\r\nlocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\r\n+ rel[i].r_offset;\r\nsym = (Elf32_Sym *)sechdrs[symindex].sh_addr\r\n+ ELF32_R_SYM(rel[i].r_info);\r\nswitch (ELF32_R_TYPE(rel[i].r_info)) {\r\ncase R_68K_32:\r\n*location += sym->st_value;\r\nbreak;\r\ncase R_68K_PC32:\r\n*location += sym->st_value - (uint32_t)location;\r\nbreak;\r\ndefault:\r\npr_err("module %s: Unknown relocation: %u\n", me->name,\r\nELF32_R_TYPE(rel[i].r_info));\r\nreturn -ENOEXEC;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint apply_relocate_add(Elf32_Shdr *sechdrs,\r\nconst char *strtab,\r\nunsigned int symindex,\r\nunsigned int relsec,\r\nstruct module *me)\r\n{\r\nunsigned int i;\r\nElf32_Rela *rel = (void *)sechdrs[relsec].sh_addr;\r\nElf32_Sym *sym;\r\nuint32_t *location;\r\nDEBUGP("Applying relocate_add section %u to %u\n", relsec,\r\nsechdrs[relsec].sh_info);\r\nfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {\r\nlocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\r\n+ rel[i].r_offset;\r\nsym = (Elf32_Sym *)sechdrs[symindex].sh_addr\r\n+ ELF32_R_SYM(rel[i].r_info);\r\nswitch (ELF32_R_TYPE(rel[i].r_info)) {\r\ncase R_68K_32:\r\n*location = rel[i].r_addend + sym->st_value;\r\nbreak;\r\ncase R_68K_PC32:\r\n*location = rel[i].r_addend + sym->st_value - (uint32_t)location;\r\nbreak;\r\ndefault:\r\npr_err("module %s: Unknown relocation: %u\n", me->name,\r\nELF32_R_TYPE(rel[i].r_info));\r\nreturn -ENOEXEC;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint module_finalize(const Elf_Ehdr *hdr,\r\nconst Elf_Shdr *sechdrs,\r\nstruct module *mod)\r\n{\r\nmodule_fixup(mod, mod->arch.fixup_start, mod->arch.fixup_end);\r\nreturn 0;\r\n}\r\nvoid module_fixup(struct module *mod, struct m68k_fixup_info *start,\r\nstruct m68k_fixup_info *end)\r\n{\r\n#ifdef CONFIG_MMU\r\nstruct m68k_fixup_info *fixup;\r\nfor (fixup = start; fixup < end; fixup++) {\r\nswitch (fixup->type) {\r\ncase m68k_fixup_memoffset:\r\n*(u32 *)fixup->addr = m68k_memoffset;\r\nbreak;\r\ncase m68k_fixup_vnode_shift:\r\n*(u16 *)fixup->addr += m68k_virt_to_node_shift;\r\nbreak;\r\n}\r\n}\r\n#endif\r\n}
