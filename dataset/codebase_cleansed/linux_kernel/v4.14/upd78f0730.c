static int upd78f0730_send_ctl(struct usb_serial_port *port,\r\nconst void *data, int size)\r\n{\r\nstruct usb_device *usbdev = port->serial->dev;\r\nvoid *buf;\r\nint res;\r\nif (size <= 0 || !data)\r\nreturn -EINVAL;\r\nbuf = kmemdup(data, size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nres = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0), 0x00,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\r\n0x0000, 0x0000, buf, size, USB_CTRL_SET_TIMEOUT);\r\nkfree(buf);\r\nif (res != size) {\r\nstruct device *dev = &port->dev;\r\ndev_err(dev, "failed to send control request %02x: %d\n",\r\n*(u8 *)data, res);\r\nif (res >= 0)\r\nres = -EIO;\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int upd78f0730_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct upd78f0730_port_private *private;\r\nprivate = kzalloc(sizeof(*private), GFP_KERNEL);\r\nif (!private)\r\nreturn -ENOMEM;\r\nmutex_init(&private->lock);\r\nusb_set_serial_port_data(port, private);\r\nreturn 0;\r\n}\r\nstatic int upd78f0730_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct upd78f0730_port_private *private;\r\nprivate = usb_get_serial_port_data(port);\r\nmutex_destroy(&private->lock);\r\nkfree(private);\r\nreturn 0;\r\n}\r\nstatic int upd78f0730_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct device *dev = tty->dev;\r\nstruct upd78f0730_port_private *private;\r\nstruct usb_serial_port *port = tty->driver_data;\r\nint signals;\r\nint res;\r\nprivate = usb_get_serial_port_data(port);\r\nmutex_lock(&private->lock);\r\nsignals = private->line_signals;\r\nmutex_unlock(&private->lock);\r\nres = ((signals & UPD78F0730_DTR) ? TIOCM_DTR : 0) |\r\n((signals & UPD78F0730_RTS) ? TIOCM_RTS : 0);\r\ndev_dbg(dev, "%s - res = %x\n", __func__, res);\r\nreturn res;\r\n}\r\nstatic int upd78f0730_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct device *dev = tty->dev;\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct upd78f0730_port_private *private;\r\nstruct upd78f0730_set_dtr_rts request;\r\nint res;\r\nprivate = usb_get_serial_port_data(port);\r\nmutex_lock(&private->lock);\r\nif (set & TIOCM_DTR) {\r\nprivate->line_signals |= UPD78F0730_DTR;\r\ndev_dbg(dev, "%s - set DTR\n", __func__);\r\n}\r\nif (set & TIOCM_RTS) {\r\nprivate->line_signals |= UPD78F0730_RTS;\r\ndev_dbg(dev, "%s - set RTS\n", __func__);\r\n}\r\nif (clear & TIOCM_DTR) {\r\nprivate->line_signals &= ~UPD78F0730_DTR;\r\ndev_dbg(dev, "%s - clear DTR\n", __func__);\r\n}\r\nif (clear & TIOCM_RTS) {\r\nprivate->line_signals &= ~UPD78F0730_RTS;\r\ndev_dbg(dev, "%s - clear RTS\n", __func__);\r\n}\r\nrequest.opcode = UPD78F0730_CMD_SET_DTR_RTS;\r\nrequest.params = private->line_signals;\r\nres = upd78f0730_send_ctl(port, &request, sizeof(request));\r\nmutex_unlock(&private->lock);\r\nreturn res;\r\n}\r\nstatic void upd78f0730_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct device *dev = tty->dev;\r\nstruct upd78f0730_port_private *private;\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct upd78f0730_set_dtr_rts request;\r\nprivate = usb_get_serial_port_data(port);\r\nmutex_lock(&private->lock);\r\nif (break_state) {\r\nprivate->line_signals |= UPD78F0730_BREAK;\r\ndev_dbg(dev, "%s - set BREAK\n", __func__);\r\n} else {\r\nprivate->line_signals &= ~UPD78F0730_BREAK;\r\ndev_dbg(dev, "%s - clear BREAK\n", __func__);\r\n}\r\nrequest.opcode = UPD78F0730_CMD_SET_DTR_RTS;\r\nrequest.params = private->line_signals;\r\nupd78f0730_send_ctl(port, &request, sizeof(request));\r\nmutex_unlock(&private->lock);\r\n}\r\nstatic void upd78f0730_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct tty_struct *tty = port->port.tty;\r\nunsigned int set = 0;\r\nunsigned int clear = 0;\r\nif (on)\r\nset = TIOCM_DTR | TIOCM_RTS;\r\nelse\r\nclear = TIOCM_DTR | TIOCM_RTS;\r\nupd78f0730_tiocmset(tty, set, clear);\r\n}\r\nstatic speed_t upd78f0730_get_baud_rate(struct tty_struct *tty)\r\n{\r\nconst speed_t baud_rate = tty_get_baud_rate(tty);\r\nstatic const speed_t supported[] = {\r\n0, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 153600\r\n};\r\nint i;\r\nfor (i = ARRAY_SIZE(supported) - 1; i >= 0; i--) {\r\nif (baud_rate == supported[i])\r\nreturn baud_rate;\r\n}\r\ntty_encode_baud_rate(tty, 9600, 9600);\r\nreturn tty_get_baud_rate(tty);\r\n}\r\nstatic void upd78f0730_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct device *dev = &port->dev;\r\nstruct upd78f0730_line_control request;\r\nspeed_t baud_rate;\r\nif (old_termios && !tty_termios_hw_change(&tty->termios, old_termios))\r\nreturn;\r\nif (C_BAUD(tty) == B0)\r\nupd78f0730_dtr_rts(port, 0);\r\nelse if (old_termios && (old_termios->c_cflag & CBAUD) == B0)\r\nupd78f0730_dtr_rts(port, 1);\r\nbaud_rate = upd78f0730_get_baud_rate(tty);\r\nrequest.opcode = UPD78F0730_CMD_LINE_CONTROL;\r\nrequest.baud_rate = cpu_to_le32(baud_rate);\r\nrequest.params = 0;\r\ndev_dbg(dev, "%s - baud rate = %d\n", __func__, baud_rate);\r\nswitch (C_CSIZE(tty)) {\r\ncase CS7:\r\nrequest.params |= UPD78F0730_DATA_SIZE_7_BITS;\r\ndev_dbg(dev, "%s - 7 data bits\n", __func__);\r\nbreak;\r\ndefault:\r\ntty->termios.c_cflag &= ~CSIZE;\r\ntty->termios.c_cflag |= CS8;\r\ndev_warn(dev, "data size is not supported, using 8 bits\n");\r\ncase CS8:\r\nrequest.params |= UPD78F0730_DATA_SIZE_8_BITS;\r\ndev_dbg(dev, "%s - 8 data bits\n", __func__);\r\nbreak;\r\n}\r\nif (C_PARENB(tty)) {\r\nif (C_PARODD(tty)) {\r\nrequest.params |= UPD78F0730_PARITY_ODD;\r\ndev_dbg(dev, "%s - odd parity\n", __func__);\r\n} else {\r\nrequest.params |= UPD78F0730_PARITY_EVEN;\r\ndev_dbg(dev, "%s - even parity\n", __func__);\r\n}\r\nif (C_CMSPAR(tty)) {\r\ntty->termios.c_cflag &= ~CMSPAR;\r\ndev_warn(dev, "MARK/SPACE parity is not supported\n");\r\n}\r\n} else {\r\nrequest.params |= UPD78F0730_PARITY_NONE;\r\ndev_dbg(dev, "%s - no parity\n", __func__);\r\n}\r\nif (C_CSTOPB(tty)) {\r\nrequest.params |= UPD78F0730_STOP_BIT_2_BIT;\r\ndev_dbg(dev, "%s - 2 stop bits\n", __func__);\r\n} else {\r\nrequest.params |= UPD78F0730_STOP_BIT_1_BIT;\r\ndev_dbg(dev, "%s - 1 stop bit\n", __func__);\r\n}\r\nif (C_CRTSCTS(tty)) {\r\ntty->termios.c_cflag &= ~CRTSCTS;\r\ndev_warn(dev, "RTSCTS flow control is not supported\n");\r\n}\r\nif (I_IXOFF(tty) || I_IXON(tty)) {\r\ntty->termios.c_iflag &= ~(IXOFF | IXON);\r\ndev_warn(dev, "XON/XOFF flow control is not supported\n");\r\n}\r\nrequest.params |= UPD78F0730_FLOW_CONTROL_NONE;\r\ndev_dbg(dev, "%s - no flow control\n", __func__);\r\nupd78f0730_send_ctl(port, &request, sizeof(request));\r\n}\r\nstatic int upd78f0730_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstatic const struct upd78f0730_open_close request = {\r\n.opcode = UPD78F0730_CMD_OPEN_CLOSE,\r\n.state = UPD78F0730_PORT_OPEN\r\n};\r\nint res;\r\nres = upd78f0730_send_ctl(port, &request, sizeof(request));\r\nif (res)\r\nreturn res;\r\nif (tty)\r\nupd78f0730_set_termios(tty, port, NULL);\r\nreturn usb_serial_generic_open(tty, port);\r\n}\r\nstatic void upd78f0730_close(struct usb_serial_port *port)\r\n{\r\nstatic const struct upd78f0730_open_close request = {\r\n.opcode = UPD78F0730_CMD_OPEN_CLOSE,\r\n.state = UPD78F0730_PORT_CLOSE\r\n};\r\nusb_serial_generic_close(port);\r\nupd78f0730_send_ctl(port, &request, sizeof(request));\r\n}
