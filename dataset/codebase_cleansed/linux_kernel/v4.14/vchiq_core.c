static const char *msg_type_str(unsigned int msg_type)\r\n{\r\nswitch (msg_type) {\r\ncase VCHIQ_MSG_PADDING: return "PADDING";\r\ncase VCHIQ_MSG_CONNECT: return "CONNECT";\r\ncase VCHIQ_MSG_OPEN: return "OPEN";\r\ncase VCHIQ_MSG_OPENACK: return "OPENACK";\r\ncase VCHIQ_MSG_CLOSE: return "CLOSE";\r\ncase VCHIQ_MSG_DATA: return "DATA";\r\ncase VCHIQ_MSG_BULK_RX: return "BULK_RX";\r\ncase VCHIQ_MSG_BULK_TX: return "BULK_TX";\r\ncase VCHIQ_MSG_BULK_RX_DONE: return "BULK_RX_DONE";\r\ncase VCHIQ_MSG_BULK_TX_DONE: return "BULK_TX_DONE";\r\ncase VCHIQ_MSG_PAUSE: return "PAUSE";\r\ncase VCHIQ_MSG_RESUME: return "RESUME";\r\ncase VCHIQ_MSG_REMOTE_USE: return "REMOTE_USE";\r\ncase VCHIQ_MSG_REMOTE_RELEASE: return "REMOTE_RELEASE";\r\ncase VCHIQ_MSG_REMOTE_USE_ACTIVE: return "REMOTE_USE_ACTIVE";\r\n}\r\nreturn "???";\r\n}\r\nstatic inline void\r\nvchiq_set_service_state(VCHIQ_SERVICE_T *service, int newstate)\r\n{\r\nvchiq_log_info(vchiq_core_log_level, "%d: srv:%d %s->%s",\r\nservice->state->id, service->localport,\r\nsrvstate_names[service->srvstate],\r\nsrvstate_names[newstate]);\r\nservice->srvstate = newstate;\r\n}\r\nVCHIQ_SERVICE_T *\r\nfind_service_by_handle(VCHIQ_SERVICE_HANDLE_T handle)\r\n{\r\nVCHIQ_SERVICE_T *service;\r\nspin_lock(&service_spinlock);\r\nservice = handle_to_service(handle);\r\nif (service && (service->srvstate != VCHIQ_SRVSTATE_FREE) &&\r\n(service->handle == handle)) {\r\nWARN_ON(service->ref_count == 0);\r\nservice->ref_count++;\r\n} else\r\nservice = NULL;\r\nspin_unlock(&service_spinlock);\r\nif (!service)\r\nvchiq_log_info(vchiq_core_log_level,\r\n"Invalid service handle 0x%x", handle);\r\nreturn service;\r\n}\r\nVCHIQ_SERVICE_T *\r\nfind_service_by_port(VCHIQ_STATE_T *state, int localport)\r\n{\r\nVCHIQ_SERVICE_T *service = NULL;\r\nif ((unsigned int)localport <= VCHIQ_PORT_MAX) {\r\nspin_lock(&service_spinlock);\r\nservice = state->services[localport];\r\nif (service && (service->srvstate != VCHIQ_SRVSTATE_FREE)) {\r\nWARN_ON(service->ref_count == 0);\r\nservice->ref_count++;\r\n} else\r\nservice = NULL;\r\nspin_unlock(&service_spinlock);\r\n}\r\nif (!service)\r\nvchiq_log_info(vchiq_core_log_level,\r\n"Invalid port %d", localport);\r\nreturn service;\r\n}\r\nVCHIQ_SERVICE_T *\r\nfind_service_for_instance(VCHIQ_INSTANCE_T instance,\r\nVCHIQ_SERVICE_HANDLE_T handle) {\r\nVCHIQ_SERVICE_T *service;\r\nspin_lock(&service_spinlock);\r\nservice = handle_to_service(handle);\r\nif (service && (service->srvstate != VCHIQ_SRVSTATE_FREE) &&\r\n(service->handle == handle) &&\r\n(service->instance == instance)) {\r\nWARN_ON(service->ref_count == 0);\r\nservice->ref_count++;\r\n} else\r\nservice = NULL;\r\nspin_unlock(&service_spinlock);\r\nif (!service)\r\nvchiq_log_info(vchiq_core_log_level,\r\n"Invalid service handle 0x%x", handle);\r\nreturn service;\r\n}\r\nVCHIQ_SERVICE_T *\r\nfind_closed_service_for_instance(VCHIQ_INSTANCE_T instance,\r\nVCHIQ_SERVICE_HANDLE_T handle) {\r\nVCHIQ_SERVICE_T *service;\r\nspin_lock(&service_spinlock);\r\nservice = handle_to_service(handle);\r\nif (service &&\r\n((service->srvstate == VCHIQ_SRVSTATE_FREE) ||\r\n(service->srvstate == VCHIQ_SRVSTATE_CLOSED)) &&\r\n(service->handle == handle) &&\r\n(service->instance == instance)) {\r\nWARN_ON(service->ref_count == 0);\r\nservice->ref_count++;\r\n} else\r\nservice = NULL;\r\nspin_unlock(&service_spinlock);\r\nif (!service)\r\nvchiq_log_info(vchiq_core_log_level,\r\n"Invalid service handle 0x%x", handle);\r\nreturn service;\r\n}\r\nVCHIQ_SERVICE_T *\r\nnext_service_by_instance(VCHIQ_STATE_T *state, VCHIQ_INSTANCE_T instance,\r\nint *pidx)\r\n{\r\nVCHIQ_SERVICE_T *service = NULL;\r\nint idx = *pidx;\r\nspin_lock(&service_spinlock);\r\nwhile (idx < state->unused_service) {\r\nVCHIQ_SERVICE_T *srv = state->services[idx++];\r\nif (srv && (srv->srvstate != VCHIQ_SRVSTATE_FREE) &&\r\n(srv->instance == instance)) {\r\nservice = srv;\r\nWARN_ON(service->ref_count == 0);\r\nservice->ref_count++;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&service_spinlock);\r\n*pidx = idx;\r\nreturn service;\r\n}\r\nvoid\r\nlock_service(VCHIQ_SERVICE_T *service)\r\n{\r\nspin_lock(&service_spinlock);\r\nWARN_ON(!service);\r\nif (service) {\r\nWARN_ON(service->ref_count == 0);\r\nservice->ref_count++;\r\n}\r\nspin_unlock(&service_spinlock);\r\n}\r\nvoid\r\nunlock_service(VCHIQ_SERVICE_T *service)\r\n{\r\nspin_lock(&service_spinlock);\r\nif (!service) {\r\nWARN(1, "%s: service is NULL\n", __func__);\r\ngoto unlock;\r\n}\r\nif (!service->ref_count) {\r\nWARN(1, "%s: ref_count is zero\n", __func__);\r\ngoto unlock;\r\n}\r\nservice->ref_count--;\r\nif (!service->ref_count) {\r\nVCHIQ_STATE_T *state = service->state;\r\nWARN_ON(service->srvstate != VCHIQ_SRVSTATE_FREE);\r\nstate->services[service->localport] = NULL;\r\n} else {\r\nservice = NULL;\r\n}\r\nunlock:\r\nspin_unlock(&service_spinlock);\r\nif (service && service->userdata_term)\r\nservice->userdata_term(service->base.userdata);\r\nkfree(service);\r\n}\r\nint\r\nvchiq_get_client_id(VCHIQ_SERVICE_HANDLE_T handle)\r\n{\r\nVCHIQ_SERVICE_T *service = find_service_by_handle(handle);\r\nint id;\r\nid = service ? service->client_id : 0;\r\nif (service)\r\nunlock_service(service);\r\nreturn id;\r\n}\r\nvoid *\r\nvchiq_get_service_userdata(VCHIQ_SERVICE_HANDLE_T handle)\r\n{\r\nVCHIQ_SERVICE_T *service = handle_to_service(handle);\r\nreturn service ? service->base.userdata : NULL;\r\n}\r\nint\r\nvchiq_get_service_fourcc(VCHIQ_SERVICE_HANDLE_T handle)\r\n{\r\nVCHIQ_SERVICE_T *service = handle_to_service(handle);\r\nreturn service ? service->base.fourcc : 0;\r\n}\r\nstatic void\r\nmark_service_closing_internal(VCHIQ_SERVICE_T *service, int sh_thread)\r\n{\r\nVCHIQ_STATE_T *state = service->state;\r\nVCHIQ_SERVICE_QUOTA_T *service_quota;\r\nservice->closing = 1;\r\nmutex_lock(&state->recycle_mutex);\r\nmutex_unlock(&state->recycle_mutex);\r\nif (!sh_thread || (state->conn_state != VCHIQ_CONNSTATE_PAUSE_SENT)) {\r\nmutex_lock(&state->slot_mutex);\r\nmutex_unlock(&state->slot_mutex);\r\n}\r\nservice_quota = &state->service_quotas[service->localport];\r\nup(&service_quota->quota_event);\r\n}\r\nstatic void\r\nmark_service_closing(VCHIQ_SERVICE_T *service)\r\n{\r\nmark_service_closing_internal(service, 0);\r\n}\r\nstatic inline VCHIQ_STATUS_T\r\nmake_service_callback(VCHIQ_SERVICE_T *service, VCHIQ_REASON_T reason,\r\nVCHIQ_HEADER_T *header, void *bulk_userdata)\r\n{\r\nVCHIQ_STATUS_T status;\r\nvchiq_log_trace(vchiq_core_log_level, "%d: callback:%d (%s, %pK, %pK)",\r\nservice->state->id, service->localport, reason_names[reason],\r\nheader, bulk_userdata);\r\nstatus = service->base.callback(reason, header, service->handle,\r\nbulk_userdata);\r\nif (status == VCHIQ_ERROR) {\r\nvchiq_log_warning(vchiq_core_log_level,\r\n"%d: ignoring ERROR from callback to service %x",\r\nservice->state->id, service->handle);\r\nstatus = VCHIQ_SUCCESS;\r\n}\r\nreturn status;\r\n}\r\ninline void\r\nvchiq_set_conn_state(VCHIQ_STATE_T *state, VCHIQ_CONNSTATE_T newstate)\r\n{\r\nVCHIQ_CONNSTATE_T oldstate = state->conn_state;\r\nvchiq_log_info(vchiq_core_log_level, "%d: %s->%s", state->id,\r\nconn_state_names[oldstate],\r\nconn_state_names[newstate]);\r\nstate->conn_state = newstate;\r\nvchiq_platform_conn_state_changed(state, oldstate, newstate);\r\n}\r\nstatic inline void\r\nremote_event_create(VCHIQ_STATE_T *state, REMOTE_EVENT_T *event)\r\n{\r\nevent->armed = 0;\r\nsema_init((struct semaphore *)((char *)state + event->event), 0);\r\n}\r\nstatic inline int\r\nremote_event_wait(VCHIQ_STATE_T *state, REMOTE_EVENT_T *event)\r\n{\r\nif (!event->fired) {\r\nevent->armed = 1;\r\ndsb(sy);\r\nif (!event->fired) {\r\nif (down_interruptible(\r\n(struct semaphore *)\r\n((char *)state + event->event)) != 0) {\r\nevent->armed = 0;\r\nreturn 0;\r\n}\r\n}\r\nevent->armed = 0;\r\nwmb();\r\n}\r\nevent->fired = 0;\r\nreturn 1;\r\n}\r\nstatic inline void\r\nremote_event_signal_local(VCHIQ_STATE_T *state, REMOTE_EVENT_T *event)\r\n{\r\nevent->armed = 0;\r\nup((struct semaphore *)((char *)state + event->event));\r\n}\r\nstatic inline void\r\nremote_event_poll(VCHIQ_STATE_T *state, REMOTE_EVENT_T *event)\r\n{\r\nif (event->fired && event->armed)\r\nremote_event_signal_local(state, event);\r\n}\r\nvoid\r\nremote_event_pollall(VCHIQ_STATE_T *state)\r\n{\r\nremote_event_poll(state, &state->local->sync_trigger);\r\nremote_event_poll(state, &state->local->sync_release);\r\nremote_event_poll(state, &state->local->trigger);\r\nremote_event_poll(state, &state->local->recycle);\r\n}\r\nstatic inline size_t\r\ncalc_stride(size_t size)\r\n{\r\nsize += sizeof(VCHIQ_HEADER_T);\r\nreturn (size + sizeof(VCHIQ_HEADER_T) - 1) & ~(sizeof(VCHIQ_HEADER_T)\r\n- 1);\r\n}\r\nstatic VCHIQ_SERVICE_T *\r\nget_listening_service(VCHIQ_STATE_T *state, int fourcc)\r\n{\r\nint i;\r\nWARN_ON(fourcc == VCHIQ_FOURCC_INVALID);\r\nfor (i = 0; i < state->unused_service; i++) {\r\nVCHIQ_SERVICE_T *service = state->services[i];\r\nif (service &&\r\n(service->public_fourcc == fourcc) &&\r\n((service->srvstate == VCHIQ_SRVSTATE_LISTENING) ||\r\n((service->srvstate == VCHIQ_SRVSTATE_OPEN) &&\r\n(service->remoteport == VCHIQ_PORT_FREE)))) {\r\nlock_service(service);\r\nreturn service;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic VCHIQ_SERVICE_T *\r\nget_connected_service(VCHIQ_STATE_T *state, unsigned int port)\r\n{\r\nint i;\r\nfor (i = 0; i < state->unused_service; i++) {\r\nVCHIQ_SERVICE_T *service = state->services[i];\r\nif (service && (service->srvstate == VCHIQ_SRVSTATE_OPEN)\r\n&& (service->remoteport == port)) {\r\nlock_service(service);\r\nreturn service;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\ninline void\r\nrequest_poll(VCHIQ_STATE_T *state, VCHIQ_SERVICE_T *service, int poll_type)\r\n{\r\nu32 value;\r\nif (service) {\r\ndo {\r\nvalue = atomic_read(&service->poll_flags);\r\n} while (atomic_cmpxchg(&service->poll_flags, value,\r\nvalue | (1 << poll_type)) != value);\r\ndo {\r\nvalue = atomic_read(&state->poll_services[\r\nservice->localport>>5]);\r\n} while (atomic_cmpxchg(\r\n&state->poll_services[service->localport>>5],\r\nvalue, value | (1 << (service->localport & 0x1f)))\r\n!= value);\r\n}\r\nstate->poll_needed = 1;\r\nwmb();\r\nremote_event_signal_local(state, &state->local->trigger);\r\n}\r\nstatic VCHIQ_HEADER_T *\r\nreserve_space(VCHIQ_STATE_T *state, size_t space, int is_blocking)\r\n{\r\nVCHIQ_SHARED_STATE_T *local = state->local;\r\nint tx_pos = state->local_tx_pos;\r\nint slot_space = VCHIQ_SLOT_SIZE - (tx_pos & VCHIQ_SLOT_MASK);\r\nif (space > slot_space) {\r\nVCHIQ_HEADER_T *header;\r\nWARN_ON(state->tx_data == NULL);\r\nheader = (VCHIQ_HEADER_T *)\r\n(state->tx_data + (tx_pos & VCHIQ_SLOT_MASK));\r\nheader->msgid = VCHIQ_MSGID_PADDING;\r\nheader->size = slot_space - sizeof(VCHIQ_HEADER_T);\r\ntx_pos += slot_space;\r\n}\r\nif ((tx_pos & VCHIQ_SLOT_MASK) == 0) {\r\nint slot_index;\r\nif (down_trylock(&state->slot_available_event) != 0) {\r\nVCHIQ_STATS_INC(state, slot_stalls);\r\nstate->local_tx_pos = tx_pos;\r\nlocal->tx_pos = tx_pos;\r\nremote_event_signal(&state->remote->trigger);\r\nif (!is_blocking ||\r\n(down_interruptible(\r\n&state->slot_available_event) != 0))\r\nreturn NULL;\r\n}\r\nif (tx_pos == (state->slot_queue_available * VCHIQ_SLOT_SIZE)) {\r\npr_warn("%s: invalid tx_pos: %d\n", __func__, tx_pos);\r\nreturn NULL;\r\n}\r\nslot_index = local->slot_queue[\r\nSLOT_QUEUE_INDEX_FROM_POS(tx_pos) &\r\nVCHIQ_SLOT_QUEUE_MASK];\r\nstate->tx_data =\r\n(char *)SLOT_DATA_FROM_INDEX(state, slot_index);\r\n}\r\nstate->local_tx_pos = tx_pos + space;\r\nreturn (VCHIQ_HEADER_T *)(state->tx_data + (tx_pos & VCHIQ_SLOT_MASK));\r\n}\r\nstatic void\r\nprocess_free_queue(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_SHARED_STATE_T *local = state->local;\r\nBITSET_T service_found[BITSET_SIZE(VCHIQ_MAX_SERVICES)];\r\nint slot_queue_available;\r\nslot_queue_available = state->slot_queue_available;\r\nmb();\r\nwhile (slot_queue_available != local->slot_queue_recycle) {\r\nunsigned int pos;\r\nint slot_index = local->slot_queue[slot_queue_available++ &\r\nVCHIQ_SLOT_QUEUE_MASK];\r\nchar *data = (char *)SLOT_DATA_FROM_INDEX(state, slot_index);\r\nint data_found = 0;\r\nrmb();\r\nvchiq_log_trace(vchiq_core_log_level, "%d: pfq %d=%pK %x %x",\r\nstate->id, slot_index, data,\r\nlocal->slot_queue_recycle, slot_queue_available);\r\nBITSET_ZERO(service_found);\r\npos = 0;\r\nwhile (pos < VCHIQ_SLOT_SIZE) {\r\nVCHIQ_HEADER_T *header =\r\n(VCHIQ_HEADER_T *)(data + pos);\r\nint msgid = header->msgid;\r\nif (VCHIQ_MSG_TYPE(msgid) == VCHIQ_MSG_DATA) {\r\nint port = VCHIQ_MSG_SRCPORT(msgid);\r\nVCHIQ_SERVICE_QUOTA_T *service_quota =\r\n&state->service_quotas[port];\r\nint count;\r\nspin_lock(&quota_spinlock);\r\ncount = service_quota->message_use_count;\r\nif (count > 0)\r\nservice_quota->message_use_count =\r\ncount - 1;\r\nspin_unlock(&quota_spinlock);\r\nif (count == service_quota->message_quota)\r\nup(&service_quota->quota_event);\r\nelse if (count == 0) {\r\nvchiq_log_error(vchiq_core_log_level,\r\n"service %d message_use_count=%d (header %pK, msgid %x, header->msgid %x, header->size %x)",\r\nport,\r\nservice_quota->message_use_count,\r\nheader, msgid, header->msgid,\r\nheader->size);\r\nWARN(1, "invalid message use count\n");\r\n}\r\nif (!BITSET_IS_SET(service_found, port)) {\r\nBITSET_SET(service_found, port);\r\nspin_lock(&quota_spinlock);\r\ncount = service_quota->slot_use_count;\r\nif (count > 0)\r\nservice_quota->slot_use_count =\r\ncount - 1;\r\nspin_unlock(&quota_spinlock);\r\nif (count > 0) {\r\nup(&service_quota->quota_event);\r\nvchiq_log_trace(\r\nvchiq_core_log_level,\r\n"%d: pfq:%d %x@%pK - slot_use->%d",\r\nstate->id, port,\r\nheader->size, header,\r\ncount - 1);\r\n} else {\r\nvchiq_log_error(\r\nvchiq_core_log_level,\r\n"service %d slot_use_count=%d (header %pK, msgid %x, header->msgid %x, header->size %x)",\r\nport, count, header,\r\nmsgid, header->msgid,\r\nheader->size);\r\nWARN(1, "bad slot use count\n");\r\n}\r\n}\r\ndata_found = 1;\r\n}\r\npos += calc_stride(header->size);\r\nif (pos > VCHIQ_SLOT_SIZE) {\r\nvchiq_log_error(vchiq_core_log_level,\r\n"pfq - pos %x: header %pK, msgid %x, header->msgid %x, header->size %x",\r\npos, header, msgid, header->msgid,\r\nheader->size);\r\nWARN(1, "invalid slot position\n");\r\n}\r\n}\r\nif (data_found) {\r\nint count;\r\nspin_lock(&quota_spinlock);\r\ncount = state->data_use_count;\r\nif (count > 0)\r\nstate->data_use_count =\r\ncount - 1;\r\nspin_unlock(&quota_spinlock);\r\nif (count == state->data_quota)\r\nup(&state->data_quota_event);\r\n}\r\nmb();\r\nstate->slot_queue_available = slot_queue_available;\r\nup(&state->slot_available_event);\r\n}\r\n}\r\nstatic ssize_t\r\nmemcpy_copy_callback(\r\nvoid *context, void *dest,\r\nsize_t offset, size_t maxsize)\r\n{\r\nmemcpy(dest + offset, context + offset, maxsize);\r\nreturn maxsize;\r\n}\r\nstatic ssize_t\r\ncopy_message_data(\r\nssize_t (*copy_callback)(void *context, void *dest,\r\nsize_t offset, size_t maxsize),\r\nvoid *context,\r\nvoid *dest,\r\nsize_t size)\r\n{\r\nsize_t pos = 0;\r\nwhile (pos < size) {\r\nssize_t callback_result;\r\nsize_t max_bytes = size - pos;\r\ncallback_result =\r\ncopy_callback(context, dest + pos,\r\npos, max_bytes);\r\nif (callback_result < 0)\r\nreturn callback_result;\r\nif (!callback_result)\r\nreturn -EIO;\r\nif (callback_result > max_bytes)\r\nreturn -EIO;\r\npos += callback_result;\r\n}\r\nreturn size;\r\n}\r\nstatic VCHIQ_STATUS_T\r\nqueue_message(VCHIQ_STATE_T *state, VCHIQ_SERVICE_T *service,\r\nint msgid,\r\nssize_t (*copy_callback)(void *context, void *dest,\r\nsize_t offset, size_t maxsize),\r\nvoid *context,\r\nsize_t size,\r\nint flags)\r\n{\r\nVCHIQ_SHARED_STATE_T *local;\r\nVCHIQ_SERVICE_QUOTA_T *service_quota = NULL;\r\nVCHIQ_HEADER_T *header;\r\nint type = VCHIQ_MSG_TYPE(msgid);\r\nsize_t stride;\r\nlocal = state->local;\r\nstride = calc_stride(size);\r\nWARN_ON(!(stride <= VCHIQ_SLOT_SIZE));\r\nif (!(flags & QMFLAGS_NO_MUTEX_LOCK) &&\r\n(mutex_lock_killable(&state->slot_mutex) != 0))\r\nreturn VCHIQ_RETRY;\r\nif (type == VCHIQ_MSG_DATA) {\r\nint tx_end_index;\r\nif (!service) {\r\nWARN(1, "%s: service is NULL\n", __func__);\r\nmutex_unlock(&state->slot_mutex);\r\nreturn VCHIQ_ERROR;\r\n}\r\nWARN_ON((flags & (QMFLAGS_NO_MUTEX_LOCK |\r\nQMFLAGS_NO_MUTEX_UNLOCK)) != 0);\r\nif (service->closing) {\r\nmutex_unlock(&state->slot_mutex);\r\nreturn VCHIQ_ERROR;\r\n}\r\nservice_quota = &state->service_quotas[service->localport];\r\nspin_lock(&quota_spinlock);\r\ntx_end_index = SLOT_QUEUE_INDEX_FROM_POS(\r\nstate->local_tx_pos + stride - 1);\r\nwhile ((tx_end_index != state->previous_data_index) &&\r\n(state->data_use_count == state->data_quota)) {\r\nVCHIQ_STATS_INC(state, data_stalls);\r\nspin_unlock(&quota_spinlock);\r\nmutex_unlock(&state->slot_mutex);\r\nif (down_interruptible(&state->data_quota_event)\r\n!= 0)\r\nreturn VCHIQ_RETRY;\r\nmutex_lock(&state->slot_mutex);\r\nspin_lock(&quota_spinlock);\r\ntx_end_index = SLOT_QUEUE_INDEX_FROM_POS(\r\nstate->local_tx_pos + stride - 1);\r\nif ((tx_end_index == state->previous_data_index) ||\r\n(state->data_use_count < state->data_quota)) {\r\nup(&state->data_quota_event);\r\nbreak;\r\n}\r\n}\r\nwhile ((service_quota->message_use_count ==\r\nservice_quota->message_quota) ||\r\n((tx_end_index != service_quota->previous_tx_index) &&\r\n(service_quota->slot_use_count ==\r\nservice_quota->slot_quota))) {\r\nspin_unlock(&quota_spinlock);\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%d: qm:%d %s,%zx - quota stall "\r\n"(msg %d, slot %d)",\r\nstate->id, service->localport,\r\nmsg_type_str(type), size,\r\nservice_quota->message_use_count,\r\nservice_quota->slot_use_count);\r\nVCHIQ_SERVICE_STATS_INC(service, quota_stalls);\r\nmutex_unlock(&state->slot_mutex);\r\nif (down_interruptible(&service_quota->quota_event)\r\n!= 0)\r\nreturn VCHIQ_RETRY;\r\nif (service->closing)\r\nreturn VCHIQ_ERROR;\r\nif (mutex_lock_killable(&state->slot_mutex) != 0)\r\nreturn VCHIQ_RETRY;\r\nif (service->srvstate != VCHIQ_SRVSTATE_OPEN) {\r\nmutex_unlock(&state->slot_mutex);\r\nreturn VCHIQ_ERROR;\r\n}\r\nspin_lock(&quota_spinlock);\r\ntx_end_index = SLOT_QUEUE_INDEX_FROM_POS(\r\nstate->local_tx_pos + stride - 1);\r\n}\r\nspin_unlock(&quota_spinlock);\r\n}\r\nheader = reserve_space(state, stride, flags & QMFLAGS_IS_BLOCKING);\r\nif (!header) {\r\nif (service)\r\nVCHIQ_SERVICE_STATS_INC(service, slot_stalls);\r\nif (!(flags & QMFLAGS_NO_MUTEX_LOCK))\r\nmutex_unlock(&state->slot_mutex);\r\nreturn VCHIQ_RETRY;\r\n}\r\nif (type == VCHIQ_MSG_DATA) {\r\nssize_t callback_result;\r\nint tx_end_index;\r\nint slot_use_count;\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%d: qm %s@%pK,%zx (%d->%d)",\r\nstate->id, msg_type_str(VCHIQ_MSG_TYPE(msgid)),\r\nheader, size, VCHIQ_MSG_SRCPORT(msgid),\r\nVCHIQ_MSG_DSTPORT(msgid));\r\nWARN_ON((flags & (QMFLAGS_NO_MUTEX_LOCK |\r\nQMFLAGS_NO_MUTEX_UNLOCK)) != 0);\r\ncallback_result =\r\ncopy_message_data(copy_callback, context,\r\nheader->data, size);\r\nif (callback_result < 0) {\r\nmutex_unlock(&state->slot_mutex);\r\nVCHIQ_SERVICE_STATS_INC(service,\r\nerror_count);\r\nreturn VCHIQ_ERROR;\r\n}\r\nif (SRVTRACE_ENABLED(service,\r\nVCHIQ_LOG_INFO))\r\nvchiq_log_dump_mem("Sent", 0,\r\nheader->data,\r\nmin((size_t)16,\r\n(size_t)callback_result));\r\nspin_lock(&quota_spinlock);\r\nservice_quota->message_use_count++;\r\ntx_end_index =\r\nSLOT_QUEUE_INDEX_FROM_POS(state->local_tx_pos - 1);\r\nif (tx_end_index != state->previous_data_index) {\r\nstate->previous_data_index = tx_end_index;\r\nstate->data_use_count++;\r\n}\r\nif (tx_end_index != service_quota->previous_tx_index) {\r\nservice_quota->previous_tx_index = tx_end_index;\r\nslot_use_count = ++service_quota->slot_use_count;\r\n} else {\r\nslot_use_count = 0;\r\n}\r\nspin_unlock(&quota_spinlock);\r\nif (slot_use_count)\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%d: qm:%d %s,%zx - slot_use->%d (hdr %p)",\r\nstate->id, service->localport,\r\nmsg_type_str(VCHIQ_MSG_TYPE(msgid)), size,\r\nslot_use_count, header);\r\nVCHIQ_SERVICE_STATS_INC(service, ctrl_tx_count);\r\nVCHIQ_SERVICE_STATS_ADD(service, ctrl_tx_bytes, size);\r\n} else {\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%d: qm %s@%pK,%zx (%d->%d)", state->id,\r\nmsg_type_str(VCHIQ_MSG_TYPE(msgid)),\r\nheader, size, VCHIQ_MSG_SRCPORT(msgid),\r\nVCHIQ_MSG_DSTPORT(msgid));\r\nif (size != 0) {\r\ncopy_message_data(copy_callback, context,\r\nheader->data, size);\r\n}\r\nVCHIQ_STATS_INC(state, ctrl_tx_count);\r\n}\r\nheader->msgid = msgid;\r\nheader->size = size;\r\n{\r\nint svc_fourcc;\r\nsvc_fourcc = service\r\n? service->base.fourcc\r\n: VCHIQ_MAKE_FOURCC('?', '?', '?', '?');\r\nvchiq_log_info(SRVTRACE_LEVEL(service),\r\n"Sent Msg %s(%u) to %c%c%c%c s:%u d:%d len:%zu",\r\nmsg_type_str(VCHIQ_MSG_TYPE(msgid)),\r\nVCHIQ_MSG_TYPE(msgid),\r\nVCHIQ_FOURCC_AS_4CHARS(svc_fourcc),\r\nVCHIQ_MSG_SRCPORT(msgid),\r\nVCHIQ_MSG_DSTPORT(msgid),\r\nsize);\r\n}\r\nwmb();\r\nlocal->tx_pos = state->local_tx_pos;\r\nwmb();\r\nif (service && (type == VCHIQ_MSG_CLOSE))\r\nvchiq_set_service_state(service, VCHIQ_SRVSTATE_CLOSESENT);\r\nif (!(flags & QMFLAGS_NO_MUTEX_UNLOCK))\r\nmutex_unlock(&state->slot_mutex);\r\nremote_event_signal(&state->remote->trigger);\r\nreturn VCHIQ_SUCCESS;\r\n}\r\nstatic VCHIQ_STATUS_T\r\nqueue_message_sync(VCHIQ_STATE_T *state, VCHIQ_SERVICE_T *service,\r\nint msgid,\r\nssize_t (*copy_callback)(void *context, void *dest,\r\nsize_t offset, size_t maxsize),\r\nvoid *context,\r\nint size,\r\nint is_blocking)\r\n{\r\nVCHIQ_SHARED_STATE_T *local;\r\nVCHIQ_HEADER_T *header;\r\nssize_t callback_result;\r\nlocal = state->local;\r\nif ((VCHIQ_MSG_TYPE(msgid) != VCHIQ_MSG_RESUME) &&\r\n(mutex_lock_killable(&state->sync_mutex) != 0))\r\nreturn VCHIQ_RETRY;\r\nremote_event_wait(state, &local->sync_release);\r\nrmb();\r\nheader = (VCHIQ_HEADER_T *)SLOT_DATA_FROM_INDEX(state,\r\nlocal->slot_sync);\r\n{\r\nint oldmsgid = header->msgid;\r\nif (oldmsgid != VCHIQ_MSGID_PADDING)\r\nvchiq_log_error(vchiq_core_log_level,\r\n"%d: qms - msgid %x, not PADDING",\r\nstate->id, oldmsgid);\r\n}\r\nvchiq_log_info(vchiq_sync_log_level,\r\n"%d: qms %s@%pK,%x (%d->%d)", state->id,\r\nmsg_type_str(VCHIQ_MSG_TYPE(msgid)),\r\nheader, size, VCHIQ_MSG_SRCPORT(msgid),\r\nVCHIQ_MSG_DSTPORT(msgid));\r\ncallback_result =\r\ncopy_message_data(copy_callback, context,\r\nheader->data, size);\r\nif (callback_result < 0) {\r\nmutex_unlock(&state->slot_mutex);\r\nVCHIQ_SERVICE_STATS_INC(service,\r\nerror_count);\r\nreturn VCHIQ_ERROR;\r\n}\r\nif (service) {\r\nif (SRVTRACE_ENABLED(service,\r\nVCHIQ_LOG_INFO))\r\nvchiq_log_dump_mem("Sent", 0,\r\nheader->data,\r\nmin((size_t)16,\r\n(size_t)callback_result));\r\nVCHIQ_SERVICE_STATS_INC(service, ctrl_tx_count);\r\nVCHIQ_SERVICE_STATS_ADD(service, ctrl_tx_bytes, size);\r\n} else {\r\nVCHIQ_STATS_INC(state, ctrl_tx_count);\r\n}\r\nheader->size = size;\r\nheader->msgid = msgid;\r\nif (vchiq_sync_log_level >= VCHIQ_LOG_TRACE) {\r\nint svc_fourcc;\r\nsvc_fourcc = service\r\n? service->base.fourcc\r\n: VCHIQ_MAKE_FOURCC('?', '?', '?', '?');\r\nvchiq_log_trace(vchiq_sync_log_level,\r\n"Sent Sync Msg %s(%u) to %c%c%c%c s:%u d:%d len:%d",\r\nmsg_type_str(VCHIQ_MSG_TYPE(msgid)),\r\nVCHIQ_MSG_TYPE(msgid),\r\nVCHIQ_FOURCC_AS_4CHARS(svc_fourcc),\r\nVCHIQ_MSG_SRCPORT(msgid),\r\nVCHIQ_MSG_DSTPORT(msgid),\r\nsize);\r\n}\r\nwmb();\r\nremote_event_signal(&state->remote->sync_trigger);\r\nif (VCHIQ_MSG_TYPE(msgid) != VCHIQ_MSG_PAUSE)\r\nmutex_unlock(&state->sync_mutex);\r\nreturn VCHIQ_SUCCESS;\r\n}\r\nstatic inline void\r\nclaim_slot(VCHIQ_SLOT_INFO_T *slot)\r\n{\r\nslot->use_count++;\r\n}\r\nstatic void\r\nrelease_slot(VCHIQ_STATE_T *state, VCHIQ_SLOT_INFO_T *slot_info,\r\nVCHIQ_HEADER_T *header, VCHIQ_SERVICE_T *service)\r\n{\r\nint release_count;\r\nmutex_lock(&state->recycle_mutex);\r\nif (header) {\r\nint msgid = header->msgid;\r\nif (((msgid & VCHIQ_MSGID_CLAIMED) == 0) ||\r\n(service && service->closing)) {\r\nmutex_unlock(&state->recycle_mutex);\r\nreturn;\r\n}\r\nheader->msgid = msgid & ~VCHIQ_MSGID_CLAIMED;\r\n}\r\nrelease_count = slot_info->release_count;\r\nslot_info->release_count = ++release_count;\r\nif (release_count == slot_info->use_count) {\r\nint slot_queue_recycle;\r\nrmb();\r\nslot_queue_recycle = state->remote->slot_queue_recycle;\r\nstate->remote->slot_queue[slot_queue_recycle &\r\nVCHIQ_SLOT_QUEUE_MASK] =\r\nSLOT_INDEX_FROM_INFO(state, slot_info);\r\nstate->remote->slot_queue_recycle = slot_queue_recycle + 1;\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%d: release_slot %d - recycle->%x",\r\nstate->id, SLOT_INDEX_FROM_INFO(state, slot_info),\r\nstate->remote->slot_queue_recycle);\r\nremote_event_signal(&state->remote->recycle);\r\n}\r\nmutex_unlock(&state->recycle_mutex);\r\n}\r\nstatic VCHIQ_STATUS_T\r\nnotify_bulks(VCHIQ_SERVICE_T *service, VCHIQ_BULK_QUEUE_T *queue,\r\nint retry_poll)\r\n{\r\nVCHIQ_STATUS_T status = VCHIQ_SUCCESS;\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%d: nb:%d %cx - p=%x rn=%x r=%x",\r\nservice->state->id, service->localport,\r\n(queue == &service->bulk_tx) ? 't' : 'r',\r\nqueue->process, queue->remote_notify, queue->remove);\r\nif (service->state->is_master) {\r\nwhile (queue->remote_notify != queue->process) {\r\nVCHIQ_BULK_T *bulk =\r\n&queue->bulks[BULK_INDEX(queue->remote_notify)];\r\nint msgtype = (bulk->dir == VCHIQ_BULK_TRANSMIT) ?\r\nVCHIQ_MSG_BULK_RX_DONE : VCHIQ_MSG_BULK_TX_DONE;\r\nint msgid = VCHIQ_MAKE_MSG(msgtype, service->localport,\r\nservice->remoteport);\r\nif (bulk->remote_data) {\r\nstatus = queue_message(\r\nservice->state,\r\nNULL,\r\nmsgid,\r\nmemcpy_copy_callback,\r\n&bulk->actual,\r\n4,\r\n0);\r\nif (status != VCHIQ_SUCCESS)\r\nbreak;\r\n}\r\nqueue->remote_notify++;\r\n}\r\n} else {\r\nqueue->remote_notify = queue->process;\r\n}\r\nif (status == VCHIQ_SUCCESS) {\r\nwhile (queue->remove != queue->remote_notify) {\r\nVCHIQ_BULK_T *bulk =\r\n&queue->bulks[BULK_INDEX(queue->remove)];\r\nif (bulk->data && service->instance) {\r\nif (bulk->actual != VCHIQ_BULK_ACTUAL_ABORTED) {\r\nif (bulk->dir == VCHIQ_BULK_TRANSMIT) {\r\nVCHIQ_SERVICE_STATS_INC(service,\r\nbulk_tx_count);\r\nVCHIQ_SERVICE_STATS_ADD(service,\r\nbulk_tx_bytes,\r\nbulk->actual);\r\n} else {\r\nVCHIQ_SERVICE_STATS_INC(service,\r\nbulk_rx_count);\r\nVCHIQ_SERVICE_STATS_ADD(service,\r\nbulk_rx_bytes,\r\nbulk->actual);\r\n}\r\n} else {\r\nVCHIQ_SERVICE_STATS_INC(service,\r\nbulk_aborted_count);\r\n}\r\nif (bulk->mode == VCHIQ_BULK_MODE_BLOCKING) {\r\nstruct bulk_waiter *waiter;\r\nspin_lock(&bulk_waiter_spinlock);\r\nwaiter = bulk->userdata;\r\nif (waiter) {\r\nwaiter->actual = bulk->actual;\r\nup(&waiter->event);\r\n}\r\nspin_unlock(&bulk_waiter_spinlock);\r\n} else if (bulk->mode ==\r\nVCHIQ_BULK_MODE_CALLBACK) {\r\nVCHIQ_REASON_T reason = (bulk->dir ==\r\nVCHIQ_BULK_TRANSMIT) ?\r\n((bulk->actual ==\r\nVCHIQ_BULK_ACTUAL_ABORTED) ?\r\nVCHIQ_BULK_TRANSMIT_ABORTED :\r\nVCHIQ_BULK_TRANSMIT_DONE) :\r\n((bulk->actual ==\r\nVCHIQ_BULK_ACTUAL_ABORTED) ?\r\nVCHIQ_BULK_RECEIVE_ABORTED :\r\nVCHIQ_BULK_RECEIVE_DONE);\r\nstatus = make_service_callback(service,\r\nreason, NULL, bulk->userdata);\r\nif (status == VCHIQ_RETRY)\r\nbreak;\r\n}\r\n}\r\nqueue->remove++;\r\nup(&service->bulk_remove_event);\r\n}\r\nif (!retry_poll)\r\nstatus = VCHIQ_SUCCESS;\r\n}\r\nif (status == VCHIQ_RETRY)\r\nrequest_poll(service->state, service,\r\n(queue == &service->bulk_tx) ?\r\nVCHIQ_POLL_TXNOTIFY : VCHIQ_POLL_RXNOTIFY);\r\nreturn status;\r\n}\r\nstatic void\r\npoll_services(VCHIQ_STATE_T *state)\r\n{\r\nint group, i;\r\nfor (group = 0; group < BITSET_SIZE(state->unused_service); group++) {\r\nu32 flags;\r\nflags = atomic_xchg(&state->poll_services[group], 0);\r\nfor (i = 0; flags; i++) {\r\nif (flags & (1 << i)) {\r\nVCHIQ_SERVICE_T *service =\r\nfind_service_by_port(state,\r\n(group<<5) + i);\r\nu32 service_flags;\r\nflags &= ~(1 << i);\r\nif (!service)\r\ncontinue;\r\nservice_flags =\r\natomic_xchg(&service->poll_flags, 0);\r\nif (service_flags &\r\n(1 << VCHIQ_POLL_REMOVE)) {\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%d: ps - remove %d<->%d",\r\nstate->id, service->localport,\r\nservice->remoteport);\r\nservice->public_fourcc =\r\nVCHIQ_FOURCC_INVALID;\r\nif (vchiq_close_service_internal(\r\nservice, 0) !=\r\nVCHIQ_SUCCESS)\r\nrequest_poll(state, service,\r\nVCHIQ_POLL_REMOVE);\r\n} else if (service_flags &\r\n(1 << VCHIQ_POLL_TERMINATE)) {\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%d: ps - terminate %d<->%d",\r\nstate->id, service->localport,\r\nservice->remoteport);\r\nif (vchiq_close_service_internal(\r\nservice, 0) !=\r\nVCHIQ_SUCCESS)\r\nrequest_poll(state, service,\r\nVCHIQ_POLL_TERMINATE);\r\n}\r\nif (service_flags & (1 << VCHIQ_POLL_TXNOTIFY))\r\nnotify_bulks(service,\r\n&service->bulk_tx,\r\n1);\r\nif (service_flags & (1 << VCHIQ_POLL_RXNOTIFY))\r\nnotify_bulks(service,\r\n&service->bulk_rx,\r\n1);\r\nunlock_service(service);\r\n}\r\n}\r\n}\r\n}\r\nstatic int\r\nresolve_bulks(VCHIQ_SERVICE_T *service, VCHIQ_BULK_QUEUE_T *queue)\r\n{\r\nVCHIQ_STATE_T *state = service->state;\r\nint resolved = 0;\r\nwhile ((queue->process != queue->local_insert) &&\r\n(queue->process != queue->remote_insert)) {\r\nVCHIQ_BULK_T *bulk = &queue->bulks[BULK_INDEX(queue->process)];\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%d: rb:%d %cx - li=%x ri=%x p=%x",\r\nstate->id, service->localport,\r\n(queue == &service->bulk_tx) ? 't' : 'r',\r\nqueue->local_insert, queue->remote_insert,\r\nqueue->process);\r\nWARN_ON(!((int)(queue->local_insert - queue->process) > 0));\r\nWARN_ON(!((int)(queue->remote_insert - queue->process) > 0));\r\nif (mutex_lock_killable(&state->bulk_transfer_mutex))\r\nbreak;\r\nvchiq_transfer_bulk(bulk);\r\nmutex_unlock(&state->bulk_transfer_mutex);\r\nif (SRVTRACE_ENABLED(service, VCHIQ_LOG_INFO)) {\r\nconst char *header = (queue == &service->bulk_tx) ?\r\n"Send Bulk to" : "Recv Bulk from";\r\nif (bulk->actual != VCHIQ_BULK_ACTUAL_ABORTED)\r\nvchiq_log_info(SRVTRACE_LEVEL(service),\r\n"%s %c%c%c%c d:%d len:%d %pK<->%pK",\r\nheader,\r\nVCHIQ_FOURCC_AS_4CHARS(\r\nservice->base.fourcc),\r\nservice->remoteport, bulk->size,\r\nbulk->data, bulk->remote_data);\r\nelse\r\nvchiq_log_info(SRVTRACE_LEVEL(service),\r\n"%s %c%c%c%c d:%d ABORTED - tx len:%d,"\r\n" rx len:%d %pK<->%pK",\r\nheader,\r\nVCHIQ_FOURCC_AS_4CHARS(\r\nservice->base.fourcc),\r\nservice->remoteport,\r\nbulk->size, bulk->remote_size,\r\nbulk->data, bulk->remote_data);\r\n}\r\nvchiq_complete_bulk(bulk);\r\nqueue->process++;\r\nresolved++;\r\n}\r\nreturn resolved;\r\n}\r\nstatic void\r\nabort_outstanding_bulks(VCHIQ_SERVICE_T *service, VCHIQ_BULK_QUEUE_T *queue)\r\n{\r\nint is_tx = (queue == &service->bulk_tx);\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%d: aob:%d %cx - li=%x ri=%x p=%x",\r\nservice->state->id, service->localport, is_tx ? 't' : 'r',\r\nqueue->local_insert, queue->remote_insert, queue->process);\r\nWARN_ON(!((int)(queue->local_insert - queue->process) >= 0));\r\nWARN_ON(!((int)(queue->remote_insert - queue->process) >= 0));\r\nwhile ((queue->process != queue->local_insert) ||\r\n(queue->process != queue->remote_insert)) {\r\nVCHIQ_BULK_T *bulk = &queue->bulks[BULK_INDEX(queue->process)];\r\nif (queue->process == queue->remote_insert) {\r\nbulk->remote_data = NULL;\r\nbulk->remote_size = 0;\r\nqueue->remote_insert++;\r\n}\r\nif (queue->process != queue->local_insert) {\r\nvchiq_complete_bulk(bulk);\r\nvchiq_log_info(SRVTRACE_LEVEL(service),\r\n"%s %c%c%c%c d:%d ABORTED - tx len:%d, "\r\n"rx len:%d",\r\nis_tx ? "Send Bulk to" : "Recv Bulk from",\r\nVCHIQ_FOURCC_AS_4CHARS(service->base.fourcc),\r\nservice->remoteport,\r\nbulk->size,\r\nbulk->remote_size);\r\n} else {\r\nbulk->data = NULL;\r\nbulk->size = 0;\r\nbulk->actual = VCHIQ_BULK_ACTUAL_ABORTED;\r\nbulk->dir = is_tx ? VCHIQ_BULK_TRANSMIT :\r\nVCHIQ_BULK_RECEIVE;\r\nqueue->local_insert++;\r\n}\r\nqueue->process++;\r\n}\r\n}\r\nstatic void\r\npause_bulks(VCHIQ_STATE_T *state)\r\n{\r\nif (unlikely(atomic_inc_return(&pause_bulks_count) != 1)) {\r\nWARN_ON_ONCE(1);\r\natomic_set(&pause_bulks_count, 1);\r\nreturn;\r\n}\r\nmutex_lock(&state->bulk_transfer_mutex);\r\n}\r\nstatic void\r\nresume_bulks(VCHIQ_STATE_T *state)\r\n{\r\nint i;\r\nif (unlikely(atomic_dec_return(&pause_bulks_count) != 0)) {\r\nWARN_ON_ONCE(1);\r\natomic_set(&pause_bulks_count, 0);\r\nreturn;\r\n}\r\nmutex_unlock(&state->bulk_transfer_mutex);\r\nif (state->deferred_bulks == 0)\r\nreturn;\r\nvchiq_log_info(vchiq_core_log_level, "%s: processing %d deferred bulks",\r\n__func__, state->deferred_bulks);\r\nfor (i = 0; i < state->unused_service; i++) {\r\nVCHIQ_SERVICE_T *service = state->services[i];\r\nint resolved_rx = 0;\r\nint resolved_tx = 0;\r\nif (!service || (service->srvstate != VCHIQ_SRVSTATE_OPEN))\r\ncontinue;\r\nmutex_lock(&service->bulk_mutex);\r\nresolved_rx = resolve_bulks(service, &service->bulk_rx);\r\nresolved_tx = resolve_bulks(service, &service->bulk_tx);\r\nmutex_unlock(&service->bulk_mutex);\r\nif (resolved_rx)\r\nnotify_bulks(service, &service->bulk_rx, 1);\r\nif (resolved_tx)\r\nnotify_bulks(service, &service->bulk_tx, 1);\r\n}\r\nstate->deferred_bulks = 0;\r\n}\r\nstatic int\r\nparse_open(VCHIQ_STATE_T *state, VCHIQ_HEADER_T *header)\r\n{\r\nVCHIQ_SERVICE_T *service = NULL;\r\nint msgid, size;\r\nunsigned int localport, remoteport;\r\nmsgid = header->msgid;\r\nsize = header->size;\r\nlocalport = VCHIQ_MSG_DSTPORT(msgid);\r\nremoteport = VCHIQ_MSG_SRCPORT(msgid);\r\nif (size >= sizeof(struct vchiq_open_payload)) {\r\nconst struct vchiq_open_payload *payload =\r\n(struct vchiq_open_payload *)header->data;\r\nunsigned int fourcc;\r\nfourcc = payload->fourcc;\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%d: prs OPEN@%pK (%d->'%c%c%c%c')",\r\nstate->id, header, localport,\r\nVCHIQ_FOURCC_AS_4CHARS(fourcc));\r\nservice = get_listening_service(state, fourcc);\r\nif (service) {\r\nshort version = payload->version;\r\nshort version_min = payload->version_min;\r\nif ((service->version < version_min) ||\r\n(version < service->version_min)) {\r\nvchiq_loud_error_header();\r\nvchiq_loud_error("%d: service %d (%c%c%c%c) "\r\n"version mismatch - local (%d, min %d)"\r\n" vs. remote (%d, min %d)",\r\nstate->id, service->localport,\r\nVCHIQ_FOURCC_AS_4CHARS(fourcc),\r\nservice->version, service->version_min,\r\nversion, version_min);\r\nvchiq_loud_error_footer();\r\nunlock_service(service);\r\nservice = NULL;\r\ngoto fail_open;\r\n}\r\nservice->peer_version = version;\r\nif (service->srvstate == VCHIQ_SRVSTATE_LISTENING) {\r\nstruct vchiq_openack_payload ack_payload = {\r\nservice->version\r\n};\r\nif (state->version_common <\r\nVCHIQ_VERSION_SYNCHRONOUS_MODE)\r\nservice->sync = 0;\r\nif (service->sync &&\r\n(state->version_common >=\r\nVCHIQ_VERSION_SYNCHRONOUS_MODE)) {\r\nif (queue_message_sync(\r\nstate,\r\nNULL,\r\nVCHIQ_MAKE_MSG(\r\nVCHIQ_MSG_OPENACK,\r\nservice->localport,\r\nremoteport),\r\nmemcpy_copy_callback,\r\n&ack_payload,\r\nsizeof(ack_payload),\r\n0) == VCHIQ_RETRY)\r\ngoto bail_not_ready;\r\n} else {\r\nif (queue_message(state,\r\nNULL,\r\nVCHIQ_MAKE_MSG(\r\nVCHIQ_MSG_OPENACK,\r\nservice->localport,\r\nremoteport),\r\nmemcpy_copy_callback,\r\n&ack_payload,\r\nsizeof(ack_payload),\r\n0) == VCHIQ_RETRY)\r\ngoto bail_not_ready;\r\n}\r\nvchiq_set_service_state(service,\r\nservice->sync ? VCHIQ_SRVSTATE_OPENSYNC\r\n: VCHIQ_SRVSTATE_OPEN);\r\n}\r\nservice->remoteport = remoteport;\r\nservice->client_id = ((int *)header->data)[1];\r\nif (make_service_callback(service, VCHIQ_SERVICE_OPENED,\r\nNULL, NULL) == VCHIQ_RETRY) {\r\nservice->remoteport = VCHIQ_PORT_FREE;\r\ngoto bail_not_ready;\r\n}\r\nunlock_service(service);\r\nreturn 1;\r\n}\r\n}\r\nfail_open:\r\nif (queue_message(state, NULL,\r\nVCHIQ_MAKE_MSG(VCHIQ_MSG_CLOSE, 0, VCHIQ_MSG_SRCPORT(msgid)),\r\nNULL, NULL, 0, 0) == VCHIQ_RETRY)\r\ngoto bail_not_ready;\r\nreturn 1;\r\nbail_not_ready:\r\nif (service)\r\nunlock_service(service);\r\nreturn 0;\r\n}\r\nstatic void\r\nparse_rx_slots(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_SHARED_STATE_T *remote = state->remote;\r\nVCHIQ_SERVICE_T *service = NULL;\r\nint tx_pos;\r\nDEBUG_INITIALISE(state->local)\r\ntx_pos = remote->tx_pos;\r\nwhile (state->rx_pos != tx_pos) {\r\nVCHIQ_HEADER_T *header;\r\nint msgid, size;\r\nint type;\r\nunsigned int localport, remoteport;\r\nDEBUG_TRACE(PARSE_LINE);\r\nif (!state->rx_data) {\r\nint rx_index;\r\nWARN_ON(!((state->rx_pos & VCHIQ_SLOT_MASK) == 0));\r\nrx_index = remote->slot_queue[\r\nSLOT_QUEUE_INDEX_FROM_POS(state->rx_pos) &\r\nVCHIQ_SLOT_QUEUE_MASK];\r\nstate->rx_data = (char *)SLOT_DATA_FROM_INDEX(state,\r\nrx_index);\r\nstate->rx_info = SLOT_INFO_FROM_INDEX(state, rx_index);\r\nstate->rx_info->use_count = 1;\r\nstate->rx_info->release_count = 0;\r\n}\r\nheader = (VCHIQ_HEADER_T *)(state->rx_data +\r\n(state->rx_pos & VCHIQ_SLOT_MASK));\r\nDEBUG_VALUE(PARSE_HEADER, (int)(long)header);\r\nmsgid = header->msgid;\r\nDEBUG_VALUE(PARSE_MSGID, msgid);\r\nsize = header->size;\r\ntype = VCHIQ_MSG_TYPE(msgid);\r\nlocalport = VCHIQ_MSG_DSTPORT(msgid);\r\nremoteport = VCHIQ_MSG_SRCPORT(msgid);\r\nif (type != VCHIQ_MSG_DATA)\r\nVCHIQ_STATS_INC(state, ctrl_rx_count);\r\nswitch (type) {\r\ncase VCHIQ_MSG_OPENACK:\r\ncase VCHIQ_MSG_CLOSE:\r\ncase VCHIQ_MSG_DATA:\r\ncase VCHIQ_MSG_BULK_RX:\r\ncase VCHIQ_MSG_BULK_TX:\r\ncase VCHIQ_MSG_BULK_RX_DONE:\r\ncase VCHIQ_MSG_BULK_TX_DONE:\r\nservice = find_service_by_port(state, localport);\r\nif ((!service ||\r\n((service->remoteport != remoteport) &&\r\n(service->remoteport != VCHIQ_PORT_FREE))) &&\r\n(localport == 0) &&\r\n(type == VCHIQ_MSG_CLOSE)) {\r\nif (service)\r\nunlock_service(service);\r\nservice = get_connected_service(state,\r\nremoteport);\r\nif (service)\r\nvchiq_log_warning(vchiq_core_log_level,\r\n"%d: prs %s@%pK (%d->%d) - found connected service %d",\r\nstate->id, msg_type_str(type),\r\nheader, remoteport, localport,\r\nservice->localport);\r\n}\r\nif (!service) {\r\nvchiq_log_error(vchiq_core_log_level,\r\n"%d: prs %s@%pK (%d->%d) - invalid/closed service %d",\r\nstate->id, msg_type_str(type),\r\nheader, remoteport, localport,\r\nlocalport);\r\ngoto skip_message;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (SRVTRACE_ENABLED(service, VCHIQ_LOG_INFO)) {\r\nint svc_fourcc;\r\nsvc_fourcc = service\r\n? service->base.fourcc\r\n: VCHIQ_MAKE_FOURCC('?', '?', '?', '?');\r\nvchiq_log_info(SRVTRACE_LEVEL(service),\r\n"Rcvd Msg %s(%u) from %c%c%c%c s:%d d:%d "\r\n"len:%d",\r\nmsg_type_str(type), type,\r\nVCHIQ_FOURCC_AS_4CHARS(svc_fourcc),\r\nremoteport, localport, size);\r\nif (size > 0)\r\nvchiq_log_dump_mem("Rcvd", 0, header->data,\r\nmin(16, size));\r\n}\r\nif (((unsigned long)header & VCHIQ_SLOT_MASK) +\r\ncalc_stride(size) > VCHIQ_SLOT_SIZE) {\r\nvchiq_log_error(vchiq_core_log_level,\r\n"header %pK (msgid %x) - size %x too big for slot",\r\nheader, (unsigned int)msgid,\r\n(unsigned int)size);\r\nWARN(1, "oversized for slot\n");\r\n}\r\nswitch (type) {\r\ncase VCHIQ_MSG_OPEN:\r\nWARN_ON(!(VCHIQ_MSG_DSTPORT(msgid) == 0));\r\nif (!parse_open(state, header))\r\ngoto bail_not_ready;\r\nbreak;\r\ncase VCHIQ_MSG_OPENACK:\r\nif (size >= sizeof(struct vchiq_openack_payload)) {\r\nconst struct vchiq_openack_payload *payload =\r\n(struct vchiq_openack_payload *)\r\nheader->data;\r\nservice->peer_version = payload->version;\r\n}\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%d: prs OPENACK@%pK,%x (%d->%d) v:%d",\r\nstate->id, header, size, remoteport, localport,\r\nservice->peer_version);\r\nif (service->srvstate ==\r\nVCHIQ_SRVSTATE_OPENING) {\r\nservice->remoteport = remoteport;\r\nvchiq_set_service_state(service,\r\nVCHIQ_SRVSTATE_OPEN);\r\nup(&service->remove_event);\r\n} else\r\nvchiq_log_error(vchiq_core_log_level,\r\n"OPENACK received in state %s",\r\nsrvstate_names[service->srvstate]);\r\nbreak;\r\ncase VCHIQ_MSG_CLOSE:\r\nWARN_ON(size != 0);\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%d: prs CLOSE@%pK (%d->%d)",\r\nstate->id, header, remoteport, localport);\r\nmark_service_closing_internal(service, 1);\r\nif (vchiq_close_service_internal(service,\r\n1) == VCHIQ_RETRY)\r\ngoto bail_not_ready;\r\nvchiq_log_info(vchiq_core_log_level,\r\n"Close Service %c%c%c%c s:%u d:%d",\r\nVCHIQ_FOURCC_AS_4CHARS(service->base.fourcc),\r\nservice->localport,\r\nservice->remoteport);\r\nbreak;\r\ncase VCHIQ_MSG_DATA:\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%d: prs DATA@%pK,%x (%d->%d)",\r\nstate->id, header, size, remoteport, localport);\r\nif ((service->remoteport == remoteport)\r\n&& (service->srvstate ==\r\nVCHIQ_SRVSTATE_OPEN)) {\r\nheader->msgid = msgid | VCHIQ_MSGID_CLAIMED;\r\nclaim_slot(state->rx_info);\r\nDEBUG_TRACE(PARSE_LINE);\r\nif (make_service_callback(service,\r\nVCHIQ_MESSAGE_AVAILABLE, header,\r\nNULL) == VCHIQ_RETRY) {\r\nDEBUG_TRACE(PARSE_LINE);\r\ngoto bail_not_ready;\r\n}\r\nVCHIQ_SERVICE_STATS_INC(service, ctrl_rx_count);\r\nVCHIQ_SERVICE_STATS_ADD(service, ctrl_rx_bytes,\r\nsize);\r\n} else {\r\nVCHIQ_STATS_INC(state, error_count);\r\n}\r\nbreak;\r\ncase VCHIQ_MSG_CONNECT:\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%d: prs CONNECT@%pK", state->id, header);\r\nstate->version_common = ((VCHIQ_SLOT_ZERO_T *)\r\nstate->slot_data)->version;\r\nup(&state->connect);\r\nbreak;\r\ncase VCHIQ_MSG_BULK_RX:\r\ncase VCHIQ_MSG_BULK_TX: {\r\nVCHIQ_BULK_QUEUE_T *queue;\r\nWARN_ON(!state->is_master);\r\nqueue = (type == VCHIQ_MSG_BULK_RX) ?\r\n&service->bulk_tx : &service->bulk_rx;\r\nif ((service->remoteport == remoteport)\r\n&& (service->srvstate ==\r\nVCHIQ_SRVSTATE_OPEN)) {\r\nVCHIQ_BULK_T *bulk;\r\nint resolved = 0;\r\nDEBUG_TRACE(PARSE_LINE);\r\nif (mutex_lock_killable(\r\n&service->bulk_mutex) != 0) {\r\nDEBUG_TRACE(PARSE_LINE);\r\ngoto bail_not_ready;\r\n}\r\nWARN_ON(!(queue->remote_insert < queue->remove +\r\nVCHIQ_NUM_SERVICE_BULKS));\r\nbulk = &queue->bulks[\r\nBULK_INDEX(queue->remote_insert)];\r\nbulk->remote_data =\r\n(void *)(long)((int *)header->data)[0];\r\nbulk->remote_size = ((int *)header->data)[1];\r\nwmb();\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%d: prs %s@%pK (%d->%d) %x@%pK",\r\nstate->id, msg_type_str(type),\r\nheader, remoteport, localport,\r\nbulk->remote_size, bulk->remote_data);\r\nqueue->remote_insert++;\r\nif (atomic_read(&pause_bulks_count)) {\r\nstate->deferred_bulks++;\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%s: deferring bulk (%d)",\r\n__func__,\r\nstate->deferred_bulks);\r\nif (state->conn_state !=\r\nVCHIQ_CONNSTATE_PAUSE_SENT)\r\nvchiq_log_error(\r\nvchiq_core_log_level,\r\n"%s: bulks paused in "\r\n"unexpected state %s",\r\n__func__,\r\nconn_state_names[\r\nstate->conn_state]);\r\n} else if (state->conn_state ==\r\nVCHIQ_CONNSTATE_CONNECTED) {\r\nDEBUG_TRACE(PARSE_LINE);\r\nresolved = resolve_bulks(service,\r\nqueue);\r\n}\r\nmutex_unlock(&service->bulk_mutex);\r\nif (resolved)\r\nnotify_bulks(service, queue,\r\n1);\r\n}\r\n} break;\r\ncase VCHIQ_MSG_BULK_RX_DONE:\r\ncase VCHIQ_MSG_BULK_TX_DONE:\r\nWARN_ON(state->is_master);\r\nif ((service->remoteport == remoteport)\r\n&& (service->srvstate !=\r\nVCHIQ_SRVSTATE_FREE)) {\r\nVCHIQ_BULK_QUEUE_T *queue;\r\nVCHIQ_BULK_T *bulk;\r\nqueue = (type == VCHIQ_MSG_BULK_RX_DONE) ?\r\n&service->bulk_rx : &service->bulk_tx;\r\nDEBUG_TRACE(PARSE_LINE);\r\nif (mutex_lock_killable(\r\n&service->bulk_mutex) != 0) {\r\nDEBUG_TRACE(PARSE_LINE);\r\ngoto bail_not_ready;\r\n}\r\nif ((int)(queue->remote_insert -\r\nqueue->local_insert) >= 0) {\r\nvchiq_log_error(vchiq_core_log_level,\r\n"%d: prs %s@%pK (%d->%d) "\r\n"unexpected (ri=%d,li=%d)",\r\nstate->id, msg_type_str(type),\r\nheader, remoteport, localport,\r\nqueue->remote_insert,\r\nqueue->local_insert);\r\nmutex_unlock(&service->bulk_mutex);\r\nbreak;\r\n}\r\nif (queue->process != queue->remote_insert) {\r\npr_err("%s: p %x != ri %x\n",\r\n__func__,\r\nqueue->process,\r\nqueue->remote_insert);\r\nmutex_unlock(&service->bulk_mutex);\r\ngoto bail_not_ready;\r\n}\r\nbulk = &queue->bulks[\r\nBULK_INDEX(queue->remote_insert)];\r\nbulk->actual = *(int *)header->data;\r\nqueue->remote_insert++;\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%d: prs %s@%pK (%d->%d) %x@%pK",\r\nstate->id, msg_type_str(type),\r\nheader, remoteport, localport,\r\nbulk->actual, bulk->data);\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%d: prs:%d %cx li=%x ri=%x p=%x",\r\nstate->id, localport,\r\n(type == VCHIQ_MSG_BULK_RX_DONE) ?\r\n'r' : 't',\r\nqueue->local_insert,\r\nqueue->remote_insert, queue->process);\r\nDEBUG_TRACE(PARSE_LINE);\r\nWARN_ON(queue->process == queue->local_insert);\r\nvchiq_complete_bulk(bulk);\r\nqueue->process++;\r\nmutex_unlock(&service->bulk_mutex);\r\nDEBUG_TRACE(PARSE_LINE);\r\nnotify_bulks(service, queue, 1);\r\nDEBUG_TRACE(PARSE_LINE);\r\n}\r\nbreak;\r\ncase VCHIQ_MSG_PADDING:\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%d: prs PADDING@%pK,%x",\r\nstate->id, header, size);\r\nbreak;\r\ncase VCHIQ_MSG_PAUSE:\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%d: prs PAUSE@%pK,%x",\r\nstate->id, header, size);\r\nif (state->conn_state == VCHIQ_CONNSTATE_PAUSED) {\r\nvchiq_log_error(vchiq_core_log_level,\r\n"%d: PAUSE received in state PAUSED",\r\nstate->id);\r\nbreak;\r\n}\r\nif (state->conn_state != VCHIQ_CONNSTATE_PAUSE_SENT) {\r\nif (queue_message(state, NULL,\r\nVCHIQ_MAKE_MSG(VCHIQ_MSG_PAUSE, 0, 0),\r\nNULL, NULL, 0, QMFLAGS_NO_MUTEX_UNLOCK)\r\n== VCHIQ_RETRY)\r\ngoto bail_not_ready;\r\nif (state->is_master)\r\npause_bulks(state);\r\n}\r\nvchiq_set_conn_state(state, VCHIQ_CONNSTATE_PAUSED);\r\nvchiq_platform_paused(state);\r\nbreak;\r\ncase VCHIQ_MSG_RESUME:\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%d: prs RESUME@%pK,%x",\r\nstate->id, header, size);\r\nmutex_unlock(&state->slot_mutex);\r\nif (state->is_master)\r\nresume_bulks(state);\r\nvchiq_set_conn_state(state, VCHIQ_CONNSTATE_CONNECTED);\r\nvchiq_platform_resumed(state);\r\nbreak;\r\ncase VCHIQ_MSG_REMOTE_USE:\r\nvchiq_on_remote_use(state);\r\nbreak;\r\ncase VCHIQ_MSG_REMOTE_RELEASE:\r\nvchiq_on_remote_release(state);\r\nbreak;\r\ncase VCHIQ_MSG_REMOTE_USE_ACTIVE:\r\nvchiq_on_remote_use_active(state);\r\nbreak;\r\ndefault:\r\nvchiq_log_error(vchiq_core_log_level,\r\n"%d: prs invalid msgid %x@%pK,%x",\r\nstate->id, msgid, header, size);\r\nWARN(1, "invalid message\n");\r\nbreak;\r\n}\r\nskip_message:\r\nif (service) {\r\nunlock_service(service);\r\nservice = NULL;\r\n}\r\nstate->rx_pos += calc_stride(size);\r\nDEBUG_TRACE(PARSE_LINE);\r\nif ((state->rx_pos & VCHIQ_SLOT_MASK) == 0) {\r\nrelease_slot(state, state->rx_info, NULL, NULL);\r\nstate->rx_data = NULL;\r\n}\r\n}\r\nbail_not_ready:\r\nif (service)\r\nunlock_service(service);\r\n}\r\nstatic int\r\nslot_handler_func(void *v)\r\n{\r\nVCHIQ_STATE_T *state = (VCHIQ_STATE_T *) v;\r\nVCHIQ_SHARED_STATE_T *local = state->local;\r\nDEBUG_INITIALISE(local)\r\nwhile (1) {\r\nDEBUG_COUNT(SLOT_HANDLER_COUNT);\r\nDEBUG_TRACE(SLOT_HANDLER_LINE);\r\nremote_event_wait(state, &local->trigger);\r\nrmb();\r\nDEBUG_TRACE(SLOT_HANDLER_LINE);\r\nif (state->poll_needed) {\r\nvchiq_platform_check_suspend(state);\r\nstate->poll_needed = 0;\r\nswitch (state->conn_state) {\r\ncase VCHIQ_CONNSTATE_CONNECTED:\r\npoll_services(state);\r\nbreak;\r\ncase VCHIQ_CONNSTATE_PAUSING:\r\nif (state->is_master)\r\npause_bulks(state);\r\nif (queue_message(state, NULL,\r\nVCHIQ_MAKE_MSG(VCHIQ_MSG_PAUSE, 0, 0),\r\nNULL, NULL, 0,\r\nQMFLAGS_NO_MUTEX_UNLOCK)\r\n!= VCHIQ_RETRY) {\r\nvchiq_set_conn_state(state,\r\nVCHIQ_CONNSTATE_PAUSE_SENT);\r\n} else {\r\nif (state->is_master)\r\nresume_bulks(state);\r\nstate->poll_needed = 1;\r\n}\r\nbreak;\r\ncase VCHIQ_CONNSTATE_PAUSED:\r\nvchiq_platform_resume(state);\r\nbreak;\r\ncase VCHIQ_CONNSTATE_RESUMING:\r\nif (queue_message(state, NULL,\r\nVCHIQ_MAKE_MSG(VCHIQ_MSG_RESUME, 0, 0),\r\nNULL, NULL, 0, QMFLAGS_NO_MUTEX_LOCK)\r\n!= VCHIQ_RETRY) {\r\nif (state->is_master)\r\nresume_bulks(state);\r\nvchiq_set_conn_state(state,\r\nVCHIQ_CONNSTATE_CONNECTED);\r\nvchiq_platform_resumed(state);\r\n} else {\r\nvchiq_log_error(vchiq_core_log_level,\r\n"Failed to send RESUME "\r\n"message");\r\n}\r\nbreak;\r\ncase VCHIQ_CONNSTATE_PAUSE_TIMEOUT:\r\ncase VCHIQ_CONNSTATE_RESUME_TIMEOUT:\r\nvchiq_platform_handle_timeout(state);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nDEBUG_TRACE(SLOT_HANDLER_LINE);\r\nparse_rx_slots(state);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nrecycle_func(void *v)\r\n{\r\nVCHIQ_STATE_T *state = (VCHIQ_STATE_T *) v;\r\nVCHIQ_SHARED_STATE_T *local = state->local;\r\nwhile (1) {\r\nremote_event_wait(state, &local->recycle);\r\nprocess_free_queue(state);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsync_func(void *v)\r\n{\r\nVCHIQ_STATE_T *state = (VCHIQ_STATE_T *) v;\r\nVCHIQ_SHARED_STATE_T *local = state->local;\r\nVCHIQ_HEADER_T *header = (VCHIQ_HEADER_T *)SLOT_DATA_FROM_INDEX(state,\r\nstate->remote->slot_sync);\r\nwhile (1) {\r\nVCHIQ_SERVICE_T *service;\r\nint msgid, size;\r\nint type;\r\nunsigned int localport, remoteport;\r\nremote_event_wait(state, &local->sync_trigger);\r\nrmb();\r\nmsgid = header->msgid;\r\nsize = header->size;\r\ntype = VCHIQ_MSG_TYPE(msgid);\r\nlocalport = VCHIQ_MSG_DSTPORT(msgid);\r\nremoteport = VCHIQ_MSG_SRCPORT(msgid);\r\nservice = find_service_by_port(state, localport);\r\nif (!service) {\r\nvchiq_log_error(vchiq_sync_log_level,\r\n"%d: sf %s@%pK (%d->%d) - invalid/closed service %d",\r\nstate->id, msg_type_str(type),\r\nheader, remoteport, localport, localport);\r\nrelease_message_sync(state, header);\r\ncontinue;\r\n}\r\nif (vchiq_sync_log_level >= VCHIQ_LOG_TRACE) {\r\nint svc_fourcc;\r\nsvc_fourcc = service\r\n? service->base.fourcc\r\n: VCHIQ_MAKE_FOURCC('?', '?', '?', '?');\r\nvchiq_log_trace(vchiq_sync_log_level,\r\n"Rcvd Msg %s from %c%c%c%c s:%d d:%d len:%d",\r\nmsg_type_str(type),\r\nVCHIQ_FOURCC_AS_4CHARS(svc_fourcc),\r\nremoteport, localport, size);\r\nif (size > 0)\r\nvchiq_log_dump_mem("Rcvd", 0, header->data,\r\nmin(16, size));\r\n}\r\nswitch (type) {\r\ncase VCHIQ_MSG_OPENACK:\r\nif (size >= sizeof(struct vchiq_openack_payload)) {\r\nconst struct vchiq_openack_payload *payload =\r\n(struct vchiq_openack_payload *)\r\nheader->data;\r\nservice->peer_version = payload->version;\r\n}\r\nvchiq_log_info(vchiq_sync_log_level,\r\n"%d: sf OPENACK@%pK,%x (%d->%d) v:%d",\r\nstate->id, header, size, remoteport, localport,\r\nservice->peer_version);\r\nif (service->srvstate == VCHIQ_SRVSTATE_OPENING) {\r\nservice->remoteport = remoteport;\r\nvchiq_set_service_state(service,\r\nVCHIQ_SRVSTATE_OPENSYNC);\r\nservice->sync = 1;\r\nup(&service->remove_event);\r\n}\r\nrelease_message_sync(state, header);\r\nbreak;\r\ncase VCHIQ_MSG_DATA:\r\nvchiq_log_trace(vchiq_sync_log_level,\r\n"%d: sf DATA@%pK,%x (%d->%d)",\r\nstate->id, header, size, remoteport, localport);\r\nif ((service->remoteport == remoteport) &&\r\n(service->srvstate ==\r\nVCHIQ_SRVSTATE_OPENSYNC)) {\r\nif (make_service_callback(service,\r\nVCHIQ_MESSAGE_AVAILABLE, header,\r\nNULL) == VCHIQ_RETRY)\r\nvchiq_log_error(vchiq_sync_log_level,\r\n"synchronous callback to "\r\n"service %d returns "\r\n"VCHIQ_RETRY",\r\nlocalport);\r\n}\r\nbreak;\r\ndefault:\r\nvchiq_log_error(vchiq_sync_log_level,\r\n"%d: sf unexpected msgid %x@%pK,%x",\r\nstate->id, msgid, header, size);\r\nrelease_message_sync(state, header);\r\nbreak;\r\n}\r\nunlock_service(service);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ninit_bulk_queue(VCHIQ_BULK_QUEUE_T *queue)\r\n{\r\nqueue->local_insert = 0;\r\nqueue->remote_insert = 0;\r\nqueue->process = 0;\r\nqueue->remote_notify = 0;\r\nqueue->remove = 0;\r\n}\r\ninline const char *\r\nget_conn_state_name(VCHIQ_CONNSTATE_T conn_state)\r\n{\r\nreturn conn_state_names[conn_state];\r\n}\r\nVCHIQ_SLOT_ZERO_T *\r\nvchiq_init_slots(void *mem_base, int mem_size)\r\n{\r\nint mem_align =\r\n(int)((VCHIQ_SLOT_SIZE - (long)mem_base) & VCHIQ_SLOT_MASK);\r\nVCHIQ_SLOT_ZERO_T *slot_zero =\r\n(VCHIQ_SLOT_ZERO_T *)((char *)mem_base + mem_align);\r\nint num_slots = (mem_size - mem_align)/VCHIQ_SLOT_SIZE;\r\nint first_data_slot = VCHIQ_SLOT_ZERO_SLOTS;\r\nnum_slots -= first_data_slot;\r\nif (num_slots < 4) {\r\nvchiq_log_error(vchiq_core_log_level,\r\n"vchiq_init_slots - insufficient memory %x bytes",\r\nmem_size);\r\nreturn NULL;\r\n}\r\nmemset(slot_zero, 0, sizeof(VCHIQ_SLOT_ZERO_T));\r\nslot_zero->magic = VCHIQ_MAGIC;\r\nslot_zero->version = VCHIQ_VERSION;\r\nslot_zero->version_min = VCHIQ_VERSION_MIN;\r\nslot_zero->slot_zero_size = sizeof(VCHIQ_SLOT_ZERO_T);\r\nslot_zero->slot_size = VCHIQ_SLOT_SIZE;\r\nslot_zero->max_slots = VCHIQ_MAX_SLOTS;\r\nslot_zero->max_slots_per_side = VCHIQ_MAX_SLOTS_PER_SIDE;\r\nslot_zero->master.slot_sync = first_data_slot;\r\nslot_zero->master.slot_first = first_data_slot + 1;\r\nslot_zero->master.slot_last = first_data_slot + (num_slots/2) - 1;\r\nslot_zero->slave.slot_sync = first_data_slot + (num_slots/2);\r\nslot_zero->slave.slot_first = first_data_slot + (num_slots/2) + 1;\r\nslot_zero->slave.slot_last = first_data_slot + num_slots - 1;\r\nreturn slot_zero;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_init_state(VCHIQ_STATE_T *state, VCHIQ_SLOT_ZERO_T *slot_zero,\r\nint is_master)\r\n{\r\nVCHIQ_SHARED_STATE_T *local;\r\nVCHIQ_SHARED_STATE_T *remote;\r\nVCHIQ_STATUS_T status;\r\nchar threadname[16];\r\nint i;\r\nvchiq_log_warning(vchiq_core_log_level,\r\n"%s: slot_zero = %pK, is_master = %d",\r\n__func__, slot_zero, is_master);\r\nif (vchiq_states[0]) {\r\npr_err("%s: VCHIQ state already initialized\n", __func__);\r\nreturn VCHIQ_ERROR;\r\n}\r\nif (slot_zero->magic != VCHIQ_MAGIC) {\r\nvchiq_loud_error_header();\r\nvchiq_loud_error("Invalid VCHIQ magic value found.");\r\nvchiq_loud_error("slot_zero=%pK: magic=%x (expected %x)",\r\nslot_zero, slot_zero->magic, VCHIQ_MAGIC);\r\nvchiq_loud_error_footer();\r\nreturn VCHIQ_ERROR;\r\n}\r\nif (slot_zero->version < VCHIQ_VERSION_MIN) {\r\nvchiq_loud_error_header();\r\nvchiq_loud_error("Incompatible VCHIQ versions found.");\r\nvchiq_loud_error("slot_zero=%pK: VideoCore version=%d (minimum %d)",\r\nslot_zero, slot_zero->version, VCHIQ_VERSION_MIN);\r\nvchiq_loud_error("Restart with a newer VideoCore image.");\r\nvchiq_loud_error_footer();\r\nreturn VCHIQ_ERROR;\r\n}\r\nif (VCHIQ_VERSION < slot_zero->version_min) {\r\nvchiq_loud_error_header();\r\nvchiq_loud_error("Incompatible VCHIQ versions found.");\r\nvchiq_loud_error("slot_zero=%pK: version=%d (VideoCore minimum %d)",\r\nslot_zero, VCHIQ_VERSION, slot_zero->version_min);\r\nvchiq_loud_error("Restart with a newer kernel.");\r\nvchiq_loud_error_footer();\r\nreturn VCHIQ_ERROR;\r\n}\r\nif ((slot_zero->slot_zero_size != sizeof(VCHIQ_SLOT_ZERO_T)) ||\r\n(slot_zero->slot_size != VCHIQ_SLOT_SIZE) ||\r\n(slot_zero->max_slots != VCHIQ_MAX_SLOTS) ||\r\n(slot_zero->max_slots_per_side != VCHIQ_MAX_SLOTS_PER_SIDE)) {\r\nvchiq_loud_error_header();\r\nif (slot_zero->slot_zero_size != sizeof(VCHIQ_SLOT_ZERO_T))\r\nvchiq_loud_error("slot_zero=%pK: slot_zero_size=%d (expected %d)",\r\nslot_zero, slot_zero->slot_zero_size,\r\n(int)sizeof(VCHIQ_SLOT_ZERO_T));\r\nif (slot_zero->slot_size != VCHIQ_SLOT_SIZE)\r\nvchiq_loud_error("slot_zero=%pK: slot_size=%d (expected %d)",\r\nslot_zero, slot_zero->slot_size,\r\nVCHIQ_SLOT_SIZE);\r\nif (slot_zero->max_slots != VCHIQ_MAX_SLOTS)\r\nvchiq_loud_error("slot_zero=%pK: max_slots=%d (expected %d)",\r\nslot_zero, slot_zero->max_slots,\r\nVCHIQ_MAX_SLOTS);\r\nif (slot_zero->max_slots_per_side != VCHIQ_MAX_SLOTS_PER_SIDE)\r\nvchiq_loud_error("slot_zero=%pK: max_slots_per_side=%d (expected %d)",\r\nslot_zero, slot_zero->max_slots_per_side,\r\nVCHIQ_MAX_SLOTS_PER_SIDE);\r\nvchiq_loud_error_footer();\r\nreturn VCHIQ_ERROR;\r\n}\r\nif (VCHIQ_VERSION < slot_zero->version)\r\nslot_zero->version = VCHIQ_VERSION;\r\nif (is_master) {\r\nlocal = &slot_zero->master;\r\nremote = &slot_zero->slave;\r\n} else {\r\nlocal = &slot_zero->slave;\r\nremote = &slot_zero->master;\r\n}\r\nif (local->initialised) {\r\nvchiq_loud_error_header();\r\nif (remote->initialised)\r\nvchiq_loud_error("local state has already been "\r\n"initialised");\r\nelse\r\nvchiq_loud_error("master/slave mismatch - two %ss",\r\nis_master ? "master" : "slave");\r\nvchiq_loud_error_footer();\r\nreturn VCHIQ_ERROR;\r\n}\r\nmemset(state, 0, sizeof(VCHIQ_STATE_T));\r\nstate->is_master = is_master;\r\nstate->local = local;\r\nstate->remote = remote;\r\nstate->slot_data = (VCHIQ_SLOT_T *)slot_zero;\r\nsema_init(&state->connect, 0);\r\nmutex_init(&state->mutex);\r\nsema_init(&state->trigger_event, 0);\r\nsema_init(&state->recycle_event, 0);\r\nsema_init(&state->sync_trigger_event, 0);\r\nsema_init(&state->sync_release_event, 0);\r\nmutex_init(&state->slot_mutex);\r\nmutex_init(&state->recycle_mutex);\r\nmutex_init(&state->sync_mutex);\r\nmutex_init(&state->bulk_transfer_mutex);\r\nsema_init(&state->slot_available_event, 0);\r\nsema_init(&state->slot_remove_event, 0);\r\nsema_init(&state->data_quota_event, 0);\r\nstate->slot_queue_available = 0;\r\nfor (i = 0; i < VCHIQ_MAX_SERVICES; i++) {\r\nVCHIQ_SERVICE_QUOTA_T *service_quota =\r\n&state->service_quotas[i];\r\nsema_init(&service_quota->quota_event, 0);\r\n}\r\nfor (i = local->slot_first; i <= local->slot_last; i++) {\r\nlocal->slot_queue[state->slot_queue_available++] = i;\r\nup(&state->slot_available_event);\r\n}\r\nstate->default_slot_quota = state->slot_queue_available/2;\r\nstate->default_message_quota =\r\nmin((unsigned short)(state->default_slot_quota * 256),\r\n(unsigned short)~0);\r\nstate->previous_data_index = -1;\r\nstate->data_use_count = 0;\r\nstate->data_quota = state->slot_queue_available - 1;\r\nlocal->trigger.event = offsetof(VCHIQ_STATE_T, trigger_event);\r\nremote_event_create(state, &local->trigger);\r\nlocal->tx_pos = 0;\r\nlocal->recycle.event = offsetof(VCHIQ_STATE_T, recycle_event);\r\nremote_event_create(state, &local->recycle);\r\nlocal->slot_queue_recycle = state->slot_queue_available;\r\nlocal->sync_trigger.event = offsetof(VCHIQ_STATE_T, sync_trigger_event);\r\nremote_event_create(state, &local->sync_trigger);\r\nlocal->sync_release.event = offsetof(VCHIQ_STATE_T, sync_release_event);\r\nremote_event_create(state, &local->sync_release);\r\n((VCHIQ_HEADER_T *)SLOT_DATA_FROM_INDEX(state, local->slot_sync))->msgid\r\n= VCHIQ_MSGID_PADDING;\r\nremote_event_signal_local(state, &local->sync_release);\r\nlocal->debug[DEBUG_ENTRIES] = DEBUG_MAX;\r\nstatus = vchiq_platform_init_state(state);\r\nsnprintf(threadname, sizeof(threadname), "vchiq-slot/%d", state->id);\r\nstate->slot_handler_thread = kthread_create(&slot_handler_func,\r\n(void *)state,\r\nthreadname);\r\nif (IS_ERR(state->slot_handler_thread)) {\r\nvchiq_loud_error_header();\r\nvchiq_loud_error("couldn't create thread %s", threadname);\r\nvchiq_loud_error_footer();\r\nreturn VCHIQ_ERROR;\r\n}\r\nset_user_nice(state->slot_handler_thread, -19);\r\nwake_up_process(state->slot_handler_thread);\r\nsnprintf(threadname, sizeof(threadname), "vchiq-recy/%d", state->id);\r\nstate->recycle_thread = kthread_create(&recycle_func,\r\n(void *)state,\r\nthreadname);\r\nif (IS_ERR(state->recycle_thread)) {\r\nvchiq_loud_error_header();\r\nvchiq_loud_error("couldn't create thread %s", threadname);\r\nvchiq_loud_error_footer();\r\nreturn VCHIQ_ERROR;\r\n}\r\nset_user_nice(state->recycle_thread, -19);\r\nwake_up_process(state->recycle_thread);\r\nsnprintf(threadname, sizeof(threadname), "vchiq-sync/%d", state->id);\r\nstate->sync_thread = kthread_create(&sync_func,\r\n(void *)state,\r\nthreadname);\r\nif (IS_ERR(state->sync_thread)) {\r\nvchiq_loud_error_header();\r\nvchiq_loud_error("couldn't create thread %s", threadname);\r\nvchiq_loud_error_footer();\r\nreturn VCHIQ_ERROR;\r\n}\r\nset_user_nice(state->sync_thread, -20);\r\nwake_up_process(state->sync_thread);\r\nvchiq_states[0] = state;\r\nlocal->initialised = 1;\r\nreturn status;\r\n}\r\nVCHIQ_SERVICE_T *\r\nvchiq_add_service_internal(VCHIQ_STATE_T *state,\r\nconst VCHIQ_SERVICE_PARAMS_T *params, int srvstate,\r\nVCHIQ_INSTANCE_T instance, VCHIQ_USERDATA_TERM_T userdata_term)\r\n{\r\nVCHIQ_SERVICE_T *service;\r\nVCHIQ_SERVICE_T **pservice = NULL;\r\nVCHIQ_SERVICE_QUOTA_T *service_quota;\r\nint i;\r\nservice = kmalloc(sizeof(VCHIQ_SERVICE_T), GFP_KERNEL);\r\nif (!service)\r\nreturn service;\r\nservice->base.fourcc = params->fourcc;\r\nservice->base.callback = params->callback;\r\nservice->base.userdata = params->userdata;\r\nservice->handle = VCHIQ_SERVICE_HANDLE_INVALID;\r\nservice->ref_count = 1;\r\nservice->srvstate = VCHIQ_SRVSTATE_FREE;\r\nservice->userdata_term = userdata_term;\r\nservice->localport = VCHIQ_PORT_FREE;\r\nservice->remoteport = VCHIQ_PORT_FREE;\r\nservice->public_fourcc = (srvstate == VCHIQ_SRVSTATE_OPENING) ?\r\nVCHIQ_FOURCC_INVALID : params->fourcc;\r\nservice->client_id = 0;\r\nservice->auto_close = 1;\r\nservice->sync = 0;\r\nservice->closing = 0;\r\nservice->trace = 0;\r\natomic_set(&service->poll_flags, 0);\r\nservice->version = params->version;\r\nservice->version_min = params->version_min;\r\nservice->state = state;\r\nservice->instance = instance;\r\nservice->service_use_count = 0;\r\ninit_bulk_queue(&service->bulk_tx);\r\ninit_bulk_queue(&service->bulk_rx);\r\nsema_init(&service->remove_event, 0);\r\nsema_init(&service->bulk_remove_event, 0);\r\nmutex_init(&service->bulk_mutex);\r\nmemset(&service->stats, 0, sizeof(service->stats));\r\nmutex_lock(&state->mutex);\r\nif (state->unused_service < VCHIQ_MAX_SERVICES)\r\npservice = &state->services[state->unused_service];\r\nif (srvstate == VCHIQ_SRVSTATE_OPENING) {\r\nfor (i = 0; i < state->unused_service; i++) {\r\nVCHIQ_SERVICE_T *srv = state->services[i];\r\nif (!srv) {\r\npservice = &state->services[i];\r\nbreak;\r\n}\r\n}\r\n} else {\r\nfor (i = (state->unused_service - 1); i >= 0; i--) {\r\nVCHIQ_SERVICE_T *srv = state->services[i];\r\nif (!srv)\r\npservice = &state->services[i];\r\nelse if ((srv->public_fourcc == params->fourcc)\r\n&& ((srv->instance != instance) ||\r\n(srv->base.callback !=\r\nparams->callback))) {\r\npservice = NULL;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (pservice) {\r\nservice->localport = (pservice - state->services);\r\nif (!handle_seq)\r\nhandle_seq = VCHIQ_MAX_STATES *\r\nVCHIQ_MAX_SERVICES;\r\nservice->handle = handle_seq |\r\n(state->id * VCHIQ_MAX_SERVICES) |\r\nservice->localport;\r\nhandle_seq += VCHIQ_MAX_STATES * VCHIQ_MAX_SERVICES;\r\n*pservice = service;\r\nif (pservice == &state->services[state->unused_service])\r\nstate->unused_service++;\r\n}\r\nmutex_unlock(&state->mutex);\r\nif (!pservice) {\r\nkfree(service);\r\nreturn NULL;\r\n}\r\nservice_quota = &state->service_quotas[service->localport];\r\nservice_quota->slot_quota = state->default_slot_quota;\r\nservice_quota->message_quota = state->default_message_quota;\r\nif (service_quota->slot_use_count == 0)\r\nservice_quota->previous_tx_index =\r\nSLOT_QUEUE_INDEX_FROM_POS(state->local_tx_pos)\r\n- 1;\r\nvchiq_set_service_state(service, srvstate);\r\nvchiq_log_info(vchiq_core_msg_log_level,\r\n"%s Service %c%c%c%c SrcPort:%d",\r\n(srvstate == VCHIQ_SRVSTATE_OPENING)\r\n? "Open" : "Add",\r\nVCHIQ_FOURCC_AS_4CHARS(params->fourcc),\r\nservice->localport);\r\nreturn service;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_open_service_internal(VCHIQ_SERVICE_T *service, int client_id)\r\n{\r\nstruct vchiq_open_payload payload = {\r\nservice->base.fourcc,\r\nclient_id,\r\nservice->version,\r\nservice->version_min\r\n};\r\nVCHIQ_STATUS_T status = VCHIQ_SUCCESS;\r\nservice->client_id = client_id;\r\nvchiq_use_service_internal(service);\r\nstatus = queue_message(service->state,\r\nNULL,\r\nVCHIQ_MAKE_MSG(VCHIQ_MSG_OPEN,\r\nservice->localport,\r\n0),\r\nmemcpy_copy_callback,\r\n&payload,\r\nsizeof(payload),\r\nQMFLAGS_IS_BLOCKING);\r\nif (status == VCHIQ_SUCCESS) {\r\nif (down_interruptible(&service->remove_event) != 0) {\r\nstatus = VCHIQ_RETRY;\r\nvchiq_release_service_internal(service);\r\n} else if ((service->srvstate != VCHIQ_SRVSTATE_OPEN) &&\r\n(service->srvstate != VCHIQ_SRVSTATE_OPENSYNC)) {\r\nif (service->srvstate != VCHIQ_SRVSTATE_CLOSEWAIT)\r\nvchiq_log_error(vchiq_core_log_level,\r\n"%d: osi - srvstate = %s (ref %d)",\r\nservice->state->id,\r\nsrvstate_names[service->srvstate],\r\nservice->ref_count);\r\nstatus = VCHIQ_ERROR;\r\nVCHIQ_SERVICE_STATS_INC(service, error_count);\r\nvchiq_release_service_internal(service);\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic void\r\nrelease_service_messages(VCHIQ_SERVICE_T *service)\r\n{\r\nVCHIQ_STATE_T *state = service->state;\r\nint slot_last = state->remote->slot_last;\r\nint i;\r\nif (service->sync) {\r\nVCHIQ_HEADER_T *header =\r\n(VCHIQ_HEADER_T *)SLOT_DATA_FROM_INDEX(state,\r\nstate->remote->slot_sync);\r\nif (VCHIQ_MSG_DSTPORT(header->msgid) == service->localport)\r\nrelease_message_sync(state, header);\r\nreturn;\r\n}\r\nfor (i = state->remote->slot_first; i <= slot_last; i++) {\r\nVCHIQ_SLOT_INFO_T *slot_info =\r\nSLOT_INFO_FROM_INDEX(state, i);\r\nif (slot_info->release_count != slot_info->use_count) {\r\nchar *data =\r\n(char *)SLOT_DATA_FROM_INDEX(state, i);\r\nunsigned int pos, end;\r\nend = VCHIQ_SLOT_SIZE;\r\nif (data == state->rx_data)\r\nend = state->rx_pos & VCHIQ_SLOT_MASK;\r\npos = 0;\r\nwhile (pos < end) {\r\nVCHIQ_HEADER_T *header =\r\n(VCHIQ_HEADER_T *)(data + pos);\r\nint msgid = header->msgid;\r\nint port = VCHIQ_MSG_DSTPORT(msgid);\r\nif ((port == service->localport) &&\r\n(msgid & VCHIQ_MSGID_CLAIMED)) {\r\nvchiq_log_info(vchiq_core_log_level,\r\n" fsi - hdr %pK", header);\r\nrelease_slot(state, slot_info, header,\r\nNULL);\r\n}\r\npos += calc_stride(header->size);\r\nif (pos > VCHIQ_SLOT_SIZE) {\r\nvchiq_log_error(vchiq_core_log_level,\r\n"fsi - pos %x: header %pK, msgid %x, header->msgid %x, header->size %x",\r\npos, header, msgid,\r\nheader->msgid, header->size);\r\nWARN(1, "invalid slot position\n");\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic int\r\ndo_abort_bulks(VCHIQ_SERVICE_T *service)\r\n{\r\nVCHIQ_STATUS_T status;\r\nif (mutex_lock_killable(&service->bulk_mutex) != 0)\r\nreturn 0;\r\nabort_outstanding_bulks(service, &service->bulk_tx);\r\nabort_outstanding_bulks(service, &service->bulk_rx);\r\nmutex_unlock(&service->bulk_mutex);\r\nstatus = notify_bulks(service, &service->bulk_tx, 0);\r\nif (status == VCHIQ_SUCCESS)\r\nstatus = notify_bulks(service, &service->bulk_rx,\r\n0);\r\nreturn (status == VCHIQ_SUCCESS);\r\n}\r\nstatic VCHIQ_STATUS_T\r\nclose_service_complete(VCHIQ_SERVICE_T *service, int failstate)\r\n{\r\nVCHIQ_STATUS_T status;\r\nint is_server = (service->public_fourcc != VCHIQ_FOURCC_INVALID);\r\nint newstate;\r\nswitch (service->srvstate) {\r\ncase VCHIQ_SRVSTATE_OPEN:\r\ncase VCHIQ_SRVSTATE_CLOSESENT:\r\ncase VCHIQ_SRVSTATE_CLOSERECVD:\r\nif (is_server) {\r\nif (service->auto_close) {\r\nservice->client_id = 0;\r\nservice->remoteport = VCHIQ_PORT_FREE;\r\nnewstate = VCHIQ_SRVSTATE_LISTENING;\r\n} else\r\nnewstate = VCHIQ_SRVSTATE_CLOSEWAIT;\r\n} else\r\nnewstate = VCHIQ_SRVSTATE_CLOSED;\r\nvchiq_set_service_state(service, newstate);\r\nbreak;\r\ncase VCHIQ_SRVSTATE_LISTENING:\r\nbreak;\r\ndefault:\r\nvchiq_log_error(vchiq_core_log_level,\r\n"close_service_complete(%x) called in state %s",\r\nservice->handle, srvstate_names[service->srvstate]);\r\nWARN(1, "close_service_complete in unexpected state\n");\r\nreturn VCHIQ_ERROR;\r\n}\r\nstatus = make_service_callback(service,\r\nVCHIQ_SERVICE_CLOSED, NULL, NULL);\r\nif (status != VCHIQ_RETRY) {\r\nint uc = service->service_use_count;\r\nint i;\r\nfor (i = 0; i < uc; i++)\r\nvchiq_release_service_internal(service);\r\nservice->client_id = 0;\r\nservice->remoteport = VCHIQ_PORT_FREE;\r\nif (service->srvstate == VCHIQ_SRVSTATE_CLOSED)\r\nvchiq_free_service_internal(service);\r\nelse if (service->srvstate != VCHIQ_SRVSTATE_CLOSEWAIT) {\r\nif (is_server)\r\nservice->closing = 0;\r\nup(&service->remove_event);\r\n}\r\n} else\r\nvchiq_set_service_state(service, failstate);\r\nreturn status;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_close_service_internal(VCHIQ_SERVICE_T *service, int close_recvd)\r\n{\r\nVCHIQ_STATE_T *state = service->state;\r\nVCHIQ_STATUS_T status = VCHIQ_SUCCESS;\r\nint is_server = (service->public_fourcc != VCHIQ_FOURCC_INVALID);\r\nvchiq_log_info(vchiq_core_log_level, "%d: csi:%d,%d (%s)",\r\nservice->state->id, service->localport, close_recvd,\r\nsrvstate_names[service->srvstate]);\r\nswitch (service->srvstate) {\r\ncase VCHIQ_SRVSTATE_CLOSED:\r\ncase VCHIQ_SRVSTATE_HIDDEN:\r\ncase VCHIQ_SRVSTATE_LISTENING:\r\ncase VCHIQ_SRVSTATE_CLOSEWAIT:\r\nif (close_recvd)\r\nvchiq_log_error(vchiq_core_log_level,\r\n"vchiq_close_service_internal(1) called "\r\n"in state %s",\r\nsrvstate_names[service->srvstate]);\r\nelse if (is_server) {\r\nif (service->srvstate == VCHIQ_SRVSTATE_LISTENING) {\r\nstatus = VCHIQ_ERROR;\r\n} else {\r\nservice->client_id = 0;\r\nservice->remoteport = VCHIQ_PORT_FREE;\r\nif (service->srvstate ==\r\nVCHIQ_SRVSTATE_CLOSEWAIT)\r\nvchiq_set_service_state(service,\r\nVCHIQ_SRVSTATE_LISTENING);\r\n}\r\nup(&service->remove_event);\r\n} else\r\nvchiq_free_service_internal(service);\r\nbreak;\r\ncase VCHIQ_SRVSTATE_OPENING:\r\nif (close_recvd) {\r\nvchiq_set_service_state(service,\r\nVCHIQ_SRVSTATE_CLOSEWAIT);\r\nup(&service->remove_event);\r\n} else {\r\nstatus = queue_message(state, service,\r\nVCHIQ_MAKE_MSG\r\n(VCHIQ_MSG_CLOSE,\r\nservice->localport,\r\nVCHIQ_MSG_DSTPORT(service->remoteport)),\r\nNULL, NULL, 0, 0);\r\n}\r\nbreak;\r\ncase VCHIQ_SRVSTATE_OPENSYNC:\r\nmutex_lock(&state->sync_mutex);\r\ncase VCHIQ_SRVSTATE_OPEN:\r\nif (state->is_master || close_recvd) {\r\nif (!do_abort_bulks(service))\r\nstatus = VCHIQ_RETRY;\r\n}\r\nrelease_service_messages(service);\r\nif (status == VCHIQ_SUCCESS)\r\nstatus = queue_message(state, service,\r\nVCHIQ_MAKE_MSG\r\n(VCHIQ_MSG_CLOSE,\r\nservice->localport,\r\nVCHIQ_MSG_DSTPORT(service->remoteport)),\r\nNULL, NULL, 0, QMFLAGS_NO_MUTEX_UNLOCK);\r\nif (status == VCHIQ_SUCCESS) {\r\nif (!close_recvd) {\r\nvchiq_set_service_state(service,\r\nVCHIQ_SRVSTATE_CLOSESENT);\r\nmutex_unlock(&state->slot_mutex);\r\nif (service->sync)\r\nmutex_unlock(&state->sync_mutex);\r\nbreak;\r\n}\r\n} else if (service->srvstate == VCHIQ_SRVSTATE_OPENSYNC) {\r\nmutex_unlock(&state->sync_mutex);\r\nbreak;\r\n} else\r\nbreak;\r\nvchiq_set_service_state(service, VCHIQ_SRVSTATE_CLOSERECVD);\r\nmutex_unlock(&state->slot_mutex);\r\nif (service->sync)\r\nmutex_unlock(&state->sync_mutex);\r\nstatus = close_service_complete(service,\r\nVCHIQ_SRVSTATE_CLOSERECVD);\r\nbreak;\r\ncase VCHIQ_SRVSTATE_CLOSESENT:\r\nif (!close_recvd)\r\nbreak;\r\nif (!state->is_master) {\r\nif (!do_abort_bulks(service)) {\r\nstatus = VCHIQ_RETRY;\r\nbreak;\r\n}\r\n}\r\nif (status == VCHIQ_SUCCESS)\r\nstatus = close_service_complete(service,\r\nVCHIQ_SRVSTATE_CLOSERECVD);\r\nbreak;\r\ncase VCHIQ_SRVSTATE_CLOSERECVD:\r\nif (!close_recvd && is_server)\r\nvchiq_set_service_state(service,\r\nVCHIQ_SRVSTATE_LISTENING);\r\nstatus = close_service_complete(service,\r\nVCHIQ_SRVSTATE_CLOSERECVD);\r\nbreak;\r\ndefault:\r\nvchiq_log_error(vchiq_core_log_level,\r\n"vchiq_close_service_internal(%d) called in state %s",\r\nclose_recvd, srvstate_names[service->srvstate]);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nvoid\r\nvchiq_terminate_service_internal(VCHIQ_SERVICE_T *service)\r\n{\r\nVCHIQ_STATE_T *state = service->state;\r\nvchiq_log_info(vchiq_core_log_level, "%d: tsi - (%d<->%d)",\r\nstate->id, service->localport, service->remoteport);\r\nmark_service_closing(service);\r\nrequest_poll(state, service, VCHIQ_POLL_REMOVE);\r\n}\r\nvoid\r\nvchiq_free_service_internal(VCHIQ_SERVICE_T *service)\r\n{\r\nVCHIQ_STATE_T *state = service->state;\r\nvchiq_log_info(vchiq_core_log_level, "%d: fsi - (%d)",\r\nstate->id, service->localport);\r\nswitch (service->srvstate) {\r\ncase VCHIQ_SRVSTATE_OPENING:\r\ncase VCHIQ_SRVSTATE_CLOSED:\r\ncase VCHIQ_SRVSTATE_HIDDEN:\r\ncase VCHIQ_SRVSTATE_LISTENING:\r\ncase VCHIQ_SRVSTATE_CLOSEWAIT:\r\nbreak;\r\ndefault:\r\nvchiq_log_error(vchiq_core_log_level,\r\n"%d: fsi - (%d) in state %s",\r\nstate->id, service->localport,\r\nsrvstate_names[service->srvstate]);\r\nreturn;\r\n}\r\nvchiq_set_service_state(service, VCHIQ_SRVSTATE_FREE);\r\nup(&service->remove_event);\r\nunlock_service(service);\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_connect_internal(VCHIQ_STATE_T *state, VCHIQ_INSTANCE_T instance)\r\n{\r\nVCHIQ_SERVICE_T *service;\r\nint i;\r\ni = 0;\r\nwhile ((service = next_service_by_instance(state, instance,\r\n&i)) != NULL) {\r\nif (service->srvstate == VCHIQ_SRVSTATE_HIDDEN)\r\nvchiq_set_service_state(service,\r\nVCHIQ_SRVSTATE_LISTENING);\r\nunlock_service(service);\r\n}\r\nif (state->conn_state == VCHIQ_CONNSTATE_DISCONNECTED) {\r\nif (queue_message(state, NULL,\r\nVCHIQ_MAKE_MSG(VCHIQ_MSG_CONNECT, 0, 0), NULL, NULL,\r\n0, QMFLAGS_IS_BLOCKING) == VCHIQ_RETRY)\r\nreturn VCHIQ_RETRY;\r\nvchiq_set_conn_state(state, VCHIQ_CONNSTATE_CONNECTING);\r\n}\r\nif (state->conn_state == VCHIQ_CONNSTATE_CONNECTING) {\r\nif (down_interruptible(&state->connect) != 0)\r\nreturn VCHIQ_RETRY;\r\nvchiq_set_conn_state(state, VCHIQ_CONNSTATE_CONNECTED);\r\nup(&state->connect);\r\n}\r\nreturn VCHIQ_SUCCESS;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_shutdown_internal(VCHIQ_STATE_T *state, VCHIQ_INSTANCE_T instance)\r\n{\r\nVCHIQ_SERVICE_T *service;\r\nint i;\r\ni = 0;\r\nwhile ((service = next_service_by_instance(state, instance,\r\n&i)) != NULL) {\r\n(void)vchiq_remove_service(service->handle);\r\nunlock_service(service);\r\n}\r\nreturn VCHIQ_SUCCESS;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_pause_internal(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_STATUS_T status = VCHIQ_SUCCESS;\r\nswitch (state->conn_state) {\r\ncase VCHIQ_CONNSTATE_CONNECTED:\r\nvchiq_set_conn_state(state, VCHIQ_CONNSTATE_PAUSING);\r\nrequest_poll(state, NULL, 0);\r\nbreak;\r\ndefault:\r\nvchiq_log_error(vchiq_core_log_level,\r\n"vchiq_pause_internal in state %s\n",\r\nconn_state_names[state->conn_state]);\r\nstatus = VCHIQ_ERROR;\r\nVCHIQ_STATS_INC(state, error_count);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_resume_internal(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_STATUS_T status = VCHIQ_SUCCESS;\r\nif (state->conn_state == VCHIQ_CONNSTATE_PAUSED) {\r\nvchiq_set_conn_state(state, VCHIQ_CONNSTATE_RESUMING);\r\nrequest_poll(state, NULL, 0);\r\n} else {\r\nstatus = VCHIQ_ERROR;\r\nVCHIQ_STATS_INC(state, error_count);\r\n}\r\nreturn status;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_close_service(VCHIQ_SERVICE_HANDLE_T handle)\r\n{\r\nVCHIQ_SERVICE_T *service = find_service_by_handle(handle);\r\nVCHIQ_STATUS_T status = VCHIQ_SUCCESS;\r\nif (!service)\r\nreturn VCHIQ_ERROR;\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%d: close_service:%d",\r\nservice->state->id, service->localport);\r\nif ((service->srvstate == VCHIQ_SRVSTATE_FREE) ||\r\n(service->srvstate == VCHIQ_SRVSTATE_LISTENING) ||\r\n(service->srvstate == VCHIQ_SRVSTATE_HIDDEN)) {\r\nunlock_service(service);\r\nreturn VCHIQ_ERROR;\r\n}\r\nmark_service_closing(service);\r\nif (current == service->state->slot_handler_thread) {\r\nstatus = vchiq_close_service_internal(service,\r\n0);\r\nWARN_ON(status == VCHIQ_RETRY);\r\n} else {\r\nrequest_poll(service->state, service, VCHIQ_POLL_TERMINATE);\r\n}\r\nwhile (1) {\r\nif (down_interruptible(&service->remove_event) != 0) {\r\nstatus = VCHIQ_RETRY;\r\nbreak;\r\n}\r\nif ((service->srvstate == VCHIQ_SRVSTATE_FREE) ||\r\n(service->srvstate == VCHIQ_SRVSTATE_LISTENING) ||\r\n(service->srvstate == VCHIQ_SRVSTATE_OPEN))\r\nbreak;\r\nvchiq_log_warning(vchiq_core_log_level,\r\n"%d: close_service:%d - waiting in state %s",\r\nservice->state->id, service->localport,\r\nsrvstate_names[service->srvstate]);\r\n}\r\nif ((status == VCHIQ_SUCCESS) &&\r\n(service->srvstate != VCHIQ_SRVSTATE_FREE) &&\r\n(service->srvstate != VCHIQ_SRVSTATE_LISTENING))\r\nstatus = VCHIQ_ERROR;\r\nunlock_service(service);\r\nreturn status;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_remove_service(VCHIQ_SERVICE_HANDLE_T handle)\r\n{\r\nVCHIQ_SERVICE_T *service = find_service_by_handle(handle);\r\nVCHIQ_STATUS_T status = VCHIQ_SUCCESS;\r\nif (!service)\r\nreturn VCHIQ_ERROR;\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%d: remove_service:%d",\r\nservice->state->id, service->localport);\r\nif (service->srvstate == VCHIQ_SRVSTATE_FREE) {\r\nunlock_service(service);\r\nreturn VCHIQ_ERROR;\r\n}\r\nmark_service_closing(service);\r\nif ((service->srvstate == VCHIQ_SRVSTATE_HIDDEN) ||\r\n(current == service->state->slot_handler_thread)) {\r\nservice->public_fourcc = VCHIQ_FOURCC_INVALID;\r\nstatus = vchiq_close_service_internal(service,\r\n0);\r\nWARN_ON(status == VCHIQ_RETRY);\r\n} else {\r\nrequest_poll(service->state, service, VCHIQ_POLL_REMOVE);\r\n}\r\nwhile (1) {\r\nif (down_interruptible(&service->remove_event) != 0) {\r\nstatus = VCHIQ_RETRY;\r\nbreak;\r\n}\r\nif ((service->srvstate == VCHIQ_SRVSTATE_FREE) ||\r\n(service->srvstate == VCHIQ_SRVSTATE_OPEN))\r\nbreak;\r\nvchiq_log_warning(vchiq_core_log_level,\r\n"%d: remove_service:%d - waiting in state %s",\r\nservice->state->id, service->localport,\r\nsrvstate_names[service->srvstate]);\r\n}\r\nif ((status == VCHIQ_SUCCESS) &&\r\n(service->srvstate != VCHIQ_SRVSTATE_FREE))\r\nstatus = VCHIQ_ERROR;\r\nunlock_service(service);\r\nreturn status;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_bulk_transfer(VCHIQ_SERVICE_HANDLE_T handle,\r\nVCHI_MEM_HANDLE_T memhandle, void *offset, int size, void *userdata,\r\nVCHIQ_BULK_MODE_T mode, VCHIQ_BULK_DIR_T dir)\r\n{\r\nVCHIQ_SERVICE_T *service = find_service_by_handle(handle);\r\nVCHIQ_BULK_QUEUE_T *queue;\r\nVCHIQ_BULK_T *bulk;\r\nVCHIQ_STATE_T *state;\r\nstruct bulk_waiter *bulk_waiter = NULL;\r\nconst char dir_char = (dir == VCHIQ_BULK_TRANSMIT) ? 't' : 'r';\r\nconst int dir_msgtype = (dir == VCHIQ_BULK_TRANSMIT) ?\r\nVCHIQ_MSG_BULK_TX : VCHIQ_MSG_BULK_RX;\r\nVCHIQ_STATUS_T status = VCHIQ_ERROR;\r\nif (!service ||\r\n(service->srvstate != VCHIQ_SRVSTATE_OPEN) ||\r\n((memhandle == VCHI_MEM_HANDLE_INVALID) && (offset == NULL)) ||\r\n(vchiq_check_service(service) != VCHIQ_SUCCESS))\r\ngoto error_exit;\r\nswitch (mode) {\r\ncase VCHIQ_BULK_MODE_NOCALLBACK:\r\ncase VCHIQ_BULK_MODE_CALLBACK:\r\nbreak;\r\ncase VCHIQ_BULK_MODE_BLOCKING:\r\nbulk_waiter = (struct bulk_waiter *)userdata;\r\nsema_init(&bulk_waiter->event, 0);\r\nbulk_waiter->actual = 0;\r\nbulk_waiter->bulk = NULL;\r\nbreak;\r\ncase VCHIQ_BULK_MODE_WAITING:\r\nbulk_waiter = (struct bulk_waiter *)userdata;\r\nbulk = bulk_waiter->bulk;\r\ngoto waiting;\r\ndefault:\r\ngoto error_exit;\r\n}\r\nstate = service->state;\r\nqueue = (dir == VCHIQ_BULK_TRANSMIT) ?\r\n&service->bulk_tx : &service->bulk_rx;\r\nif (mutex_lock_killable(&service->bulk_mutex) != 0) {\r\nstatus = VCHIQ_RETRY;\r\ngoto error_exit;\r\n}\r\nif (queue->local_insert == queue->remove + VCHIQ_NUM_SERVICE_BULKS) {\r\nVCHIQ_SERVICE_STATS_INC(service, bulk_stalls);\r\ndo {\r\nmutex_unlock(&service->bulk_mutex);\r\nif (down_interruptible(&service->bulk_remove_event)\r\n!= 0) {\r\nstatus = VCHIQ_RETRY;\r\ngoto error_exit;\r\n}\r\nif (mutex_lock_killable(&service->bulk_mutex)\r\n!= 0) {\r\nstatus = VCHIQ_RETRY;\r\ngoto error_exit;\r\n}\r\n} while (queue->local_insert == queue->remove +\r\nVCHIQ_NUM_SERVICE_BULKS);\r\n}\r\nbulk = &queue->bulks[BULK_INDEX(queue->local_insert)];\r\nbulk->mode = mode;\r\nbulk->dir = dir;\r\nbulk->userdata = userdata;\r\nbulk->size = size;\r\nbulk->actual = VCHIQ_BULK_ACTUAL_ABORTED;\r\nif (vchiq_prepare_bulk_data(bulk, memhandle, offset, size, dir) !=\r\nVCHIQ_SUCCESS)\r\ngoto unlock_error_exit;\r\nwmb();\r\nvchiq_log_info(vchiq_core_log_level,\r\n"%d: bt (%d->%d) %cx %x@%pK %pK",\r\nstate->id, service->localport, service->remoteport, dir_char,\r\nsize, bulk->data, userdata);\r\nif (mutex_lock_killable(&state->slot_mutex) != 0) {\r\nstatus = VCHIQ_RETRY;\r\ngoto cancel_bulk_error_exit;\r\n}\r\nif (service->srvstate != VCHIQ_SRVSTATE_OPEN)\r\ngoto unlock_both_error_exit;\r\nif (state->is_master) {\r\nqueue->local_insert++;\r\nif (resolve_bulks(service, queue))\r\nrequest_poll(state, service,\r\n(dir == VCHIQ_BULK_TRANSMIT) ?\r\nVCHIQ_POLL_TXNOTIFY : VCHIQ_POLL_RXNOTIFY);\r\n} else {\r\nint payload[2] = { (int)(long)bulk->data, bulk->size };\r\nstatus = queue_message(state,\r\nNULL,\r\nVCHIQ_MAKE_MSG(dir_msgtype,\r\nservice->localport,\r\nservice->remoteport),\r\nmemcpy_copy_callback,\r\n&payload,\r\nsizeof(payload),\r\nQMFLAGS_IS_BLOCKING |\r\nQMFLAGS_NO_MUTEX_LOCK |\r\nQMFLAGS_NO_MUTEX_UNLOCK);\r\nif (status != VCHIQ_SUCCESS) {\r\ngoto unlock_both_error_exit;\r\n}\r\nqueue->local_insert++;\r\n}\r\nmutex_unlock(&state->slot_mutex);\r\nmutex_unlock(&service->bulk_mutex);\r\nvchiq_log_trace(vchiq_core_log_level,\r\n"%d: bt:%d %cx li=%x ri=%x p=%x",\r\nstate->id,\r\nservice->localport, dir_char,\r\nqueue->local_insert, queue->remote_insert, queue->process);\r\nwaiting:\r\nunlock_service(service);\r\nstatus = VCHIQ_SUCCESS;\r\nif (bulk_waiter) {\r\nbulk_waiter->bulk = bulk;\r\nif (down_interruptible(&bulk_waiter->event) != 0)\r\nstatus = VCHIQ_RETRY;\r\nelse if (bulk_waiter->actual == VCHIQ_BULK_ACTUAL_ABORTED)\r\nstatus = VCHIQ_ERROR;\r\n}\r\nreturn status;\r\nunlock_both_error_exit:\r\nmutex_unlock(&state->slot_mutex);\r\ncancel_bulk_error_exit:\r\nvchiq_complete_bulk(bulk);\r\nunlock_error_exit:\r\nmutex_unlock(&service->bulk_mutex);\r\nerror_exit:\r\nif (service)\r\nunlock_service(service);\r\nreturn status;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_queue_message(VCHIQ_SERVICE_HANDLE_T handle,\r\nssize_t (*copy_callback)(void *context, void *dest,\r\nsize_t offset, size_t maxsize),\r\nvoid *context,\r\nsize_t size)\r\n{\r\nVCHIQ_SERVICE_T *service = find_service_by_handle(handle);\r\nVCHIQ_STATUS_T status = VCHIQ_ERROR;\r\nif (!service ||\r\n(vchiq_check_service(service) != VCHIQ_SUCCESS))\r\ngoto error_exit;\r\nif (!size) {\r\nVCHIQ_SERVICE_STATS_INC(service, error_count);\r\ngoto error_exit;\r\n}\r\nif (size > VCHIQ_MAX_MSG_SIZE) {\r\nVCHIQ_SERVICE_STATS_INC(service, error_count);\r\ngoto error_exit;\r\n}\r\nswitch (service->srvstate) {\r\ncase VCHIQ_SRVSTATE_OPEN:\r\nstatus = queue_message(service->state, service,\r\nVCHIQ_MAKE_MSG(VCHIQ_MSG_DATA,\r\nservice->localport,\r\nservice->remoteport),\r\ncopy_callback, context, size, 1);\r\nbreak;\r\ncase VCHIQ_SRVSTATE_OPENSYNC:\r\nstatus = queue_message_sync(service->state, service,\r\nVCHIQ_MAKE_MSG(VCHIQ_MSG_DATA,\r\nservice->localport,\r\nservice->remoteport),\r\ncopy_callback, context, size, 1);\r\nbreak;\r\ndefault:\r\nstatus = VCHIQ_ERROR;\r\nbreak;\r\n}\r\nerror_exit:\r\nif (service)\r\nunlock_service(service);\r\nreturn status;\r\n}\r\nvoid\r\nvchiq_release_message(VCHIQ_SERVICE_HANDLE_T handle, VCHIQ_HEADER_T *header)\r\n{\r\nVCHIQ_SERVICE_T *service = find_service_by_handle(handle);\r\nVCHIQ_SHARED_STATE_T *remote;\r\nVCHIQ_STATE_T *state;\r\nint slot_index;\r\nif (!service)\r\nreturn;\r\nstate = service->state;\r\nremote = state->remote;\r\nslot_index = SLOT_INDEX_FROM_DATA(state, (void *)header);\r\nif ((slot_index >= remote->slot_first) &&\r\n(slot_index <= remote->slot_last)) {\r\nint msgid = header->msgid;\r\nif (msgid & VCHIQ_MSGID_CLAIMED) {\r\nVCHIQ_SLOT_INFO_T *slot_info =\r\nSLOT_INFO_FROM_INDEX(state, slot_index);\r\nrelease_slot(state, slot_info, header, service);\r\n}\r\n} else if (slot_index == remote->slot_sync)\r\nrelease_message_sync(state, header);\r\nunlock_service(service);\r\n}\r\nstatic void\r\nrelease_message_sync(VCHIQ_STATE_T *state, VCHIQ_HEADER_T *header)\r\n{\r\nheader->msgid = VCHIQ_MSGID_PADDING;\r\nwmb();\r\nremote_event_signal(&state->remote->sync_release);\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_get_peer_version(VCHIQ_SERVICE_HANDLE_T handle, short *peer_version)\r\n{\r\nVCHIQ_STATUS_T status = VCHIQ_ERROR;\r\nVCHIQ_SERVICE_T *service = find_service_by_handle(handle);\r\nif (!service ||\r\n(vchiq_check_service(service) != VCHIQ_SUCCESS) ||\r\n!peer_version)\r\ngoto exit;\r\n*peer_version = service->peer_version;\r\nstatus = VCHIQ_SUCCESS;\r\nexit:\r\nif (service)\r\nunlock_service(service);\r\nreturn status;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_get_config(VCHIQ_INSTANCE_T instance,\r\nint config_size, VCHIQ_CONFIG_T *pconfig)\r\n{\r\nVCHIQ_CONFIG_T config;\r\n(void)instance;\r\nconfig.max_msg_size = VCHIQ_MAX_MSG_SIZE;\r\nconfig.bulk_threshold = VCHIQ_MAX_MSG_SIZE;\r\nconfig.max_outstanding_bulks = VCHIQ_NUM_SERVICE_BULKS;\r\nconfig.max_services = VCHIQ_MAX_SERVICES;\r\nconfig.version = VCHIQ_VERSION;\r\nconfig.version_min = VCHIQ_VERSION_MIN;\r\nif (config_size > sizeof(VCHIQ_CONFIG_T))\r\nreturn VCHIQ_ERROR;\r\nmemcpy(pconfig, &config,\r\nmin(config_size, (int)(sizeof(VCHIQ_CONFIG_T))));\r\nreturn VCHIQ_SUCCESS;\r\n}\r\nVCHIQ_STATUS_T\r\nvchiq_set_service_option(VCHIQ_SERVICE_HANDLE_T handle,\r\nVCHIQ_SERVICE_OPTION_T option, int value)\r\n{\r\nVCHIQ_SERVICE_T *service = find_service_by_handle(handle);\r\nVCHIQ_STATUS_T status = VCHIQ_ERROR;\r\nif (service) {\r\nswitch (option) {\r\ncase VCHIQ_SERVICE_OPTION_AUTOCLOSE:\r\nservice->auto_close = value;\r\nstatus = VCHIQ_SUCCESS;\r\nbreak;\r\ncase VCHIQ_SERVICE_OPTION_SLOT_QUOTA: {\r\nVCHIQ_SERVICE_QUOTA_T *service_quota =\r\n&service->state->service_quotas[\r\nservice->localport];\r\nif (value == 0)\r\nvalue = service->state->default_slot_quota;\r\nif ((value >= service_quota->slot_use_count) &&\r\n(value < (unsigned short)~0)) {\r\nservice_quota->slot_quota = value;\r\nif ((value >= service_quota->slot_use_count) &&\r\n(service_quota->message_quota >=\r\nservice_quota->message_use_count)) {\r\nup(&service_quota->quota_event);\r\n}\r\nstatus = VCHIQ_SUCCESS;\r\n}\r\n} break;\r\ncase VCHIQ_SERVICE_OPTION_MESSAGE_QUOTA: {\r\nVCHIQ_SERVICE_QUOTA_T *service_quota =\r\n&service->state->service_quotas[\r\nservice->localport];\r\nif (value == 0)\r\nvalue = service->state->default_message_quota;\r\nif ((value >= service_quota->message_use_count) &&\r\n(value < (unsigned short)~0)) {\r\nservice_quota->message_quota = value;\r\nif ((value >=\r\nservice_quota->message_use_count) &&\r\n(service_quota->slot_quota >=\r\nservice_quota->slot_use_count))\r\nup(&service_quota->quota_event);\r\nstatus = VCHIQ_SUCCESS;\r\n}\r\n} break;\r\ncase VCHIQ_SERVICE_OPTION_SYNCHRONOUS:\r\nif ((service->srvstate == VCHIQ_SRVSTATE_HIDDEN) ||\r\n(service->srvstate ==\r\nVCHIQ_SRVSTATE_LISTENING)) {\r\nservice->sync = value;\r\nstatus = VCHIQ_SUCCESS;\r\n}\r\nbreak;\r\ncase VCHIQ_SERVICE_OPTION_TRACE:\r\nservice->trace = value;\r\nstatus = VCHIQ_SUCCESS;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nunlock_service(service);\r\n}\r\nreturn status;\r\n}\r\nstatic void\r\nvchiq_dump_shared_state(void *dump_context, VCHIQ_STATE_T *state,\r\nVCHIQ_SHARED_STATE_T *shared, const char *label)\r\n{\r\nstatic const char *const debug_names[] = {\r\n"<entries>",\r\n"SLOT_HANDLER_COUNT",\r\n"SLOT_HANDLER_LINE",\r\n"PARSE_LINE",\r\n"PARSE_HEADER",\r\n"PARSE_MSGID",\r\n"AWAIT_COMPLETION_LINE",\r\n"DEQUEUE_MESSAGE_LINE",\r\n"SERVICE_CALLBACK_LINE",\r\n"MSG_QUEUE_FULL_COUNT",\r\n"COMPLETION_QUEUE_FULL_COUNT"\r\n};\r\nint i;\r\nchar buf[80];\r\nint len;\r\nlen = snprintf(buf, sizeof(buf),\r\n" %s: slots %d-%d tx_pos=%x recycle=%x",\r\nlabel, shared->slot_first, shared->slot_last,\r\nshared->tx_pos, shared->slot_queue_recycle);\r\nvchiq_dump(dump_context, buf, len + 1);\r\nlen = snprintf(buf, sizeof(buf),\r\n" Slots claimed:");\r\nvchiq_dump(dump_context, buf, len + 1);\r\nfor (i = shared->slot_first; i <= shared->slot_last; i++) {\r\nVCHIQ_SLOT_INFO_T slot_info = *SLOT_INFO_FROM_INDEX(state, i);\r\nif (slot_info.use_count != slot_info.release_count) {\r\nlen = snprintf(buf, sizeof(buf),\r\n" %d: %d/%d", i, slot_info.use_count,\r\nslot_info.release_count);\r\nvchiq_dump(dump_context, buf, len + 1);\r\n}\r\n}\r\nfor (i = 1; i < shared->debug[DEBUG_ENTRIES]; i++) {\r\nlen = snprintf(buf, sizeof(buf), " DEBUG: %s = %d(%x)",\r\ndebug_names[i], shared->debug[i], shared->debug[i]);\r\nvchiq_dump(dump_context, buf, len + 1);\r\n}\r\n}\r\nvoid\r\nvchiq_dump_state(void *dump_context, VCHIQ_STATE_T *state)\r\n{\r\nchar buf[80];\r\nint len;\r\nint i;\r\nlen = snprintf(buf, sizeof(buf), "State %d: %s", state->id,\r\nconn_state_names[state->conn_state]);\r\nvchiq_dump(dump_context, buf, len + 1);\r\nlen = snprintf(buf, sizeof(buf),\r\n" tx_pos=%x(@%pK), rx_pos=%x(@%pK)",\r\nstate->local->tx_pos,\r\nstate->tx_data + (state->local_tx_pos & VCHIQ_SLOT_MASK),\r\nstate->rx_pos,\r\nstate->rx_data + (state->rx_pos & VCHIQ_SLOT_MASK));\r\nvchiq_dump(dump_context, buf, len + 1);\r\nlen = snprintf(buf, sizeof(buf),\r\n" Version: %d (min %d)",\r\nVCHIQ_VERSION, VCHIQ_VERSION_MIN);\r\nvchiq_dump(dump_context, buf, len + 1);\r\nif (VCHIQ_ENABLE_STATS) {\r\nlen = snprintf(buf, sizeof(buf),\r\n" Stats: ctrl_tx_count=%d, ctrl_rx_count=%d, "\r\n"error_count=%d",\r\nstate->stats.ctrl_tx_count, state->stats.ctrl_rx_count,\r\nstate->stats.error_count);\r\nvchiq_dump(dump_context, buf, len + 1);\r\n}\r\nlen = snprintf(buf, sizeof(buf),\r\n" Slots: %d available (%d data), %d recyclable, %d stalls "\r\n"(%d data)",\r\n((state->slot_queue_available * VCHIQ_SLOT_SIZE) -\r\nstate->local_tx_pos) / VCHIQ_SLOT_SIZE,\r\nstate->data_quota - state->data_use_count,\r\nstate->local->slot_queue_recycle - state->slot_queue_available,\r\nstate->stats.slot_stalls, state->stats.data_stalls);\r\nvchiq_dump(dump_context, buf, len + 1);\r\nvchiq_dump_platform_state(dump_context);\r\nvchiq_dump_shared_state(dump_context, state, state->local, "Local");\r\nvchiq_dump_shared_state(dump_context, state, state->remote, "Remote");\r\nvchiq_dump_platform_instances(dump_context);\r\nfor (i = 0; i < state->unused_service; i++) {\r\nVCHIQ_SERVICE_T *service = find_service_by_port(state, i);\r\nif (service) {\r\nvchiq_dump_service_state(dump_context, service);\r\nunlock_service(service);\r\n}\r\n}\r\n}\r\nvoid\r\nvchiq_dump_service_state(void *dump_context, VCHIQ_SERVICE_T *service)\r\n{\r\nchar buf[80];\r\nint len;\r\nlen = snprintf(buf, sizeof(buf), "Service %u: %s (ref %u)",\r\nservice->localport, srvstate_names[service->srvstate],\r\nservice->ref_count - 1);\r\nif (service->srvstate != VCHIQ_SRVSTATE_FREE) {\r\nchar remoteport[30];\r\nVCHIQ_SERVICE_QUOTA_T *service_quota =\r\n&service->state->service_quotas[service->localport];\r\nint fourcc = service->base.fourcc;\r\nint tx_pending, rx_pending;\r\nif (service->remoteport != VCHIQ_PORT_FREE) {\r\nint len2 = snprintf(remoteport, sizeof(remoteport),\r\n"%u", service->remoteport);\r\nif (service->public_fourcc != VCHIQ_FOURCC_INVALID)\r\nsnprintf(remoteport + len2,\r\nsizeof(remoteport) - len2,\r\n" (client %x)", service->client_id);\r\n} else\r\nstrcpy(remoteport, "n/a");\r\nlen += snprintf(buf + len, sizeof(buf) - len,\r\n" '%c%c%c%c' remote %s (msg use %d/%d, slot use %d/%d)",\r\nVCHIQ_FOURCC_AS_4CHARS(fourcc),\r\nremoteport,\r\nservice_quota->message_use_count,\r\nservice_quota->message_quota,\r\nservice_quota->slot_use_count,\r\nservice_quota->slot_quota);\r\nvchiq_dump(dump_context, buf, len + 1);\r\ntx_pending = service->bulk_tx.local_insert -\r\nservice->bulk_tx.remote_insert;\r\nrx_pending = service->bulk_rx.local_insert -\r\nservice->bulk_rx.remote_insert;\r\nlen = snprintf(buf, sizeof(buf),\r\n" Bulk: tx_pending=%d (size %d),"\r\n" rx_pending=%d (size %d)",\r\ntx_pending,\r\ntx_pending ? service->bulk_tx.bulks[\r\nBULK_INDEX(service->bulk_tx.remove)].size : 0,\r\nrx_pending,\r\nrx_pending ? service->bulk_rx.bulks[\r\nBULK_INDEX(service->bulk_rx.remove)].size : 0);\r\nif (VCHIQ_ENABLE_STATS) {\r\nvchiq_dump(dump_context, buf, len + 1);\r\nlen = snprintf(buf, sizeof(buf),\r\n" Ctrl: tx_count=%d, tx_bytes=%llu, "\r\n"rx_count=%d, rx_bytes=%llu",\r\nservice->stats.ctrl_tx_count,\r\nservice->stats.ctrl_tx_bytes,\r\nservice->stats.ctrl_rx_count,\r\nservice->stats.ctrl_rx_bytes);\r\nvchiq_dump(dump_context, buf, len + 1);\r\nlen = snprintf(buf, sizeof(buf),\r\n" Bulk: tx_count=%d, tx_bytes=%llu, "\r\n"rx_count=%d, rx_bytes=%llu",\r\nservice->stats.bulk_tx_count,\r\nservice->stats.bulk_tx_bytes,\r\nservice->stats.bulk_rx_count,\r\nservice->stats.bulk_rx_bytes);\r\nvchiq_dump(dump_context, buf, len + 1);\r\nlen = snprintf(buf, sizeof(buf),\r\n" %d quota stalls, %d slot stalls, "\r\n"%d bulk stalls, %d aborted, %d errors",\r\nservice->stats.quota_stalls,\r\nservice->stats.slot_stalls,\r\nservice->stats.bulk_stalls,\r\nservice->stats.bulk_aborted_count,\r\nservice->stats.error_count);\r\n}\r\n}\r\nvchiq_dump(dump_context, buf, len + 1);\r\nif (service->srvstate != VCHIQ_SRVSTATE_FREE)\r\nvchiq_dump_platform_service_state(dump_context, service);\r\n}\r\nvoid\r\nvchiq_loud_error_header(void)\r\n{\r\nvchiq_log_error(vchiq_core_log_level,\r\n"============================================================"\r\n"================");\r\nvchiq_log_error(vchiq_core_log_level,\r\n"============================================================"\r\n"================");\r\nvchiq_log_error(vchiq_core_log_level, "=====");\r\n}\r\nvoid\r\nvchiq_loud_error_footer(void)\r\n{\r\nvchiq_log_error(vchiq_core_log_level, "=====");\r\nvchiq_log_error(vchiq_core_log_level,\r\n"============================================================"\r\n"================");\r\nvchiq_log_error(vchiq_core_log_level,\r\n"============================================================"\r\n"================");\r\n}\r\nVCHIQ_STATUS_T vchiq_send_remote_use(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_STATUS_T status = VCHIQ_RETRY;\r\nif (state->conn_state != VCHIQ_CONNSTATE_DISCONNECTED)\r\nstatus = queue_message(state, NULL,\r\nVCHIQ_MAKE_MSG(VCHIQ_MSG_REMOTE_USE, 0, 0),\r\nNULL, NULL, 0, 0);\r\nreturn status;\r\n}\r\nVCHIQ_STATUS_T vchiq_send_remote_release(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_STATUS_T status = VCHIQ_RETRY;\r\nif (state->conn_state != VCHIQ_CONNSTATE_DISCONNECTED)\r\nstatus = queue_message(state, NULL,\r\nVCHIQ_MAKE_MSG(VCHIQ_MSG_REMOTE_RELEASE, 0, 0),\r\nNULL, NULL, 0, 0);\r\nreturn status;\r\n}\r\nVCHIQ_STATUS_T vchiq_send_remote_use_active(VCHIQ_STATE_T *state)\r\n{\r\nVCHIQ_STATUS_T status = VCHIQ_RETRY;\r\nif (state->conn_state != VCHIQ_CONNSTATE_DISCONNECTED)\r\nstatus = queue_message(state, NULL,\r\nVCHIQ_MAKE_MSG(VCHIQ_MSG_REMOTE_USE_ACTIVE, 0, 0),\r\nNULL, NULL, 0, 0);\r\nreturn status;\r\n}\r\nvoid vchiq_log_dump_mem(const char *label, u32 addr, const void *void_mem,\r\nsize_t num_bytes)\r\n{\r\nconst u8 *mem = (const u8 *)void_mem;\r\nsize_t offset;\r\nchar line_buf[100];\r\nchar *s;\r\nwhile (num_bytes > 0) {\r\ns = line_buf;\r\nfor (offset = 0; offset < 16; offset++) {\r\nif (offset < num_bytes)\r\ns += snprintf(s, 4, "%02x ", mem[offset]);\r\nelse\r\ns += snprintf(s, 4, " ");\r\n}\r\nfor (offset = 0; offset < 16; offset++) {\r\nif (offset < num_bytes) {\r\nu8 ch = mem[offset];\r\nif ((ch < ' ') || (ch > '~'))\r\nch = '.';\r\n*s++ = (char)ch;\r\n}\r\n}\r\n*s++ = '\0';\r\nif ((label != NULL) && (*label != '\0'))\r\nvchiq_log_trace(VCHIQ_LOG_TRACE,\r\n"%s: %08x: %s", label, addr, line_buf);\r\nelse\r\nvchiq_log_trace(VCHIQ_LOG_TRACE,\r\n"%08x: %s", addr, line_buf);\r\naddr += 16;\r\nmem += 16;\r\nif (num_bytes > 16)\r\nnum_bytes -= 16;\r\nelse\r\nnum_bytes = 0;\r\n}\r\n}
