static bool\r\nshadow_fetch(struct nvkm_bios *bios, struct shadow *mthd, u32 upto)\r\n{\r\nconst u32 limit = (upto + 3) & ~3;\r\nconst u32 start = bios->size;\r\nvoid *data = mthd->data;\r\nif (nvbios_extend(bios, limit) > 0) {\r\nu32 read = mthd->func->read(data, start, limit - start, bios);\r\nbios->size = start + read;\r\n}\r\nreturn bios->size >= upto;\r\n}\r\nstatic int\r\nshadow_image(struct nvkm_bios *bios, int idx, u32 offset, struct shadow *mthd)\r\n{\r\nstruct nvkm_subdev *subdev = &bios->subdev;\r\nstruct nvbios_image image;\r\nint score = 1;\r\nif (mthd->func->no_pcir) {\r\nimage.base = 0;\r\nimage.type = 0;\r\nimage.size = mthd->func->size(mthd->data);\r\nimage.last = 1;\r\n} else {\r\nif (!shadow_fetch(bios, mthd, offset + 0x1000)) {\r\nnvkm_debug(subdev, "%08x: header fetch failed\n",\r\noffset);\r\nreturn 0;\r\n}\r\nif (!nvbios_image(bios, idx, &image)) {\r\nnvkm_debug(subdev, "image %d invalid\n", idx);\r\nreturn 0;\r\n}\r\n}\r\nnvkm_debug(subdev, "%08x: type %02x, %d bytes\n",\r\nimage.base, image.type, image.size);\r\nif (!shadow_fetch(bios, mthd, image.size)) {\r\nnvkm_debug(subdev, "%08x: fetch failed\n", image.base);\r\nreturn 0;\r\n}\r\nswitch (image.type) {\r\ncase 0x00:\r\nif (!mthd->func->ignore_checksum &&\r\nnvbios_checksum(&bios->data[image.base], image.size)) {\r\nnvkm_debug(subdev, "%08x: checksum failed\n",\r\nimage.base);\r\nif (!mthd->func->require_checksum) {\r\nif (mthd->func->rw)\r\nscore += 1;\r\nscore += 1;\r\n} else\r\nreturn 0;\r\n} else {\r\nscore += 3;\r\n}\r\nbreak;\r\ndefault:\r\nscore += 3;\r\nbreak;\r\n}\r\nif (!image.last)\r\nscore += shadow_image(bios, idx + 1, offset + image.size, mthd);\r\nreturn score;\r\n}\r\nstatic int\r\nshadow_method(struct nvkm_bios *bios, struct shadow *mthd, const char *name)\r\n{\r\nconst struct nvbios_source *func = mthd->func;\r\nstruct nvkm_subdev *subdev = &bios->subdev;\r\nif (func->name) {\r\nnvkm_debug(subdev, "trying %s...\n", name ? name : func->name);\r\nif (func->init) {\r\nmthd->data = func->init(bios, name);\r\nif (IS_ERR(mthd->data)) {\r\nmthd->data = NULL;\r\nreturn 0;\r\n}\r\n}\r\nmthd->score = shadow_image(bios, 0, 0, mthd);\r\nif (func->fini)\r\nfunc->fini(mthd->data);\r\nnvkm_debug(subdev, "scored %d\n", mthd->score);\r\nmthd->data = bios->data;\r\nmthd->size = bios->size;\r\nbios->data = NULL;\r\nbios->size = 0;\r\n}\r\nreturn mthd->score;\r\n}\r\nstatic u32\r\nshadow_fw_read(void *data, u32 offset, u32 length, struct nvkm_bios *bios)\r\n{\r\nconst struct firmware *fw = data;\r\nif (offset + length <= fw->size) {\r\nmemcpy(bios->data + offset, fw->data + offset, length);\r\nreturn length;\r\n}\r\nreturn 0;\r\n}\r\nstatic void *\r\nshadow_fw_init(struct nvkm_bios *bios, const char *name)\r\n{\r\nstruct device *dev = bios->subdev.device->dev;\r\nconst struct firmware *fw;\r\nint ret = request_firmware(&fw, name, dev);\r\nif (ret)\r\nreturn ERR_PTR(-ENOENT);\r\nreturn (void *)fw;\r\n}\r\nint\r\nnvbios_shadow(struct nvkm_bios *bios)\r\n{\r\nstruct nvkm_subdev *subdev = &bios->subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nstruct shadow mthds[] = {\r\n{ 0, &nvbios_of },\r\n{ 0, &nvbios_ramin },\r\n{ 0, &nvbios_rom },\r\n{ 0, &nvbios_acpi_fast },\r\n{ 4, &nvbios_acpi_slow },\r\n{ 1, &nvbios_pcirom },\r\n{ 1, &nvbios_platform },\r\n{}\r\n}, *mthd, *best = NULL;\r\nconst char *optarg;\r\nchar *source;\r\nint optlen;\r\noptarg = nvkm_stropt(device->cfgopt, "NvBios", &optlen);\r\nsource = optarg ? kstrndup(optarg, optlen, GFP_KERNEL) : NULL;\r\nif (source) {\r\nfor (mthd = mthds; mthd->func; mthd++) {\r\nif (mthd->func->name &&\r\n!strcasecmp(source, mthd->func->name)) {\r\nbest = mthd;\r\nif (shadow_method(bios, mthd, NULL))\r\nbreak;\r\n}\r\n}\r\nif (!best && (best = mthd)) {\r\nmthd->func = &shadow_fw;\r\nshadow_method(bios, mthd, source);\r\nmthd->func = NULL;\r\n}\r\nif (!best->score) {\r\nnvkm_error(subdev, "%s invalid\n", source);\r\nkfree(source);\r\nsource = NULL;\r\n}\r\n}\r\nif (!best || !best->score) {\r\nfor (mthd = mthds, best = mthd; mthd->func; mthd++) {\r\nif (!mthd->skip || best->score < mthd->skip) {\r\nif (shadow_method(bios, mthd, NULL)) {\r\nif (mthd->score > best->score)\r\nbest = mthd;\r\n}\r\n}\r\n}\r\n}\r\nfor (mthd = mthds; mthd->func; mthd++) {\r\nif (mthd != best)\r\nkfree(mthd->data);\r\n}\r\nif (!best->score) {\r\nnvkm_error(subdev, "unable to locate usable image\n");\r\nreturn -EINVAL;\r\n}\r\nnvkm_debug(subdev, "using image from %s\n", best->func ?\r\nbest->func->name : source);\r\nbios->data = best->data;\r\nbios->size = best->size;\r\nkfree(source);\r\nreturn 0;\r\n}
