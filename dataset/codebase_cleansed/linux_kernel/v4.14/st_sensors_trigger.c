static int st_sensors_new_samples_available(struct iio_dev *indio_dev,\r\nstruct st_sensor_data *sdata)\r\n{\r\nu8 status;\r\nint ret;\r\nif (!sdata->sensor_settings->drdy_irq.addr_stat_drdy)\r\nreturn -EINVAL;\r\nif (!indio_dev->active_scan_mask)\r\nreturn 0;\r\nret = sdata->tf->read_byte(&sdata->tb, sdata->dev,\r\nsdata->sensor_settings->drdy_irq.addr_stat_drdy,\r\n&status);\r\nif (ret < 0) {\r\ndev_err(sdata->dev,\r\n"error checking samples available\n");\r\nreturn ret;\r\n}\r\nstatus &= 0x07;\r\nif (status & (u8)indio_dev->active_scan_mask[0])\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t st_sensors_irq_handler(int irq, void *p)\r\n{\r\nstruct iio_trigger *trig = p;\r\nstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nsdata->hw_timestamp = iio_get_time_ns(indio_dev);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t st_sensors_irq_thread(int irq, void *p)\r\n{\r\nstruct iio_trigger *trig = p;\r\nstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nif (sdata->hw_irq_trigger &&\r\nst_sensors_new_samples_available(indio_dev, sdata)) {\r\niio_trigger_poll_chained(p);\r\n} else {\r\ndev_dbg(sdata->dev, "spurious IRQ\n");\r\nreturn IRQ_NONE;\r\n}\r\nif (!sdata->edge_irq)\r\nreturn IRQ_HANDLED;\r\nwhile (sdata->hw_irq_trigger &&\r\nst_sensors_new_samples_available(indio_dev, sdata)) {\r\ndev_dbg(sdata->dev, "more samples came in during polling\n");\r\nsdata->hw_timestamp = iio_get_time_ns(indio_dev);\r\niio_trigger_poll_chained(p);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nint st_sensors_allocate_trigger(struct iio_dev *indio_dev,\r\nconst struct iio_trigger_ops *trigger_ops)\r\n{\r\nint err, irq;\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\nunsigned long irq_trig;\r\nsdata->trig = iio_trigger_alloc("%s-trigger", indio_dev->name);\r\nif (sdata->trig == NULL) {\r\ndev_err(&indio_dev->dev, "failed to allocate iio trigger.\n");\r\nreturn -ENOMEM;\r\n}\r\niio_trigger_set_drvdata(sdata->trig, indio_dev);\r\nsdata->trig->ops = trigger_ops;\r\nsdata->trig->dev.parent = sdata->dev;\r\nirq = sdata->get_irq_data_ready(indio_dev);\r\nirq_trig = irqd_get_trigger_type(irq_get_irq_data(irq));\r\nswitch(irq_trig) {\r\ncase IRQF_TRIGGER_FALLING:\r\ncase IRQF_TRIGGER_LOW:\r\nif (!sdata->sensor_settings->drdy_irq.addr_ihl) {\r\ndev_err(&indio_dev->dev,\r\n"falling/low specified for IRQ "\r\n"but hardware only support rising/high: "\r\n"will request rising/high\n");\r\nif (irq_trig == IRQF_TRIGGER_FALLING)\r\nirq_trig = IRQF_TRIGGER_RISING;\r\nif (irq_trig == IRQF_TRIGGER_LOW)\r\nirq_trig = IRQF_TRIGGER_HIGH;\r\n} else {\r\nerr = st_sensors_write_data_with_mask(indio_dev,\r\nsdata->sensor_settings->drdy_irq.addr_ihl,\r\nsdata->sensor_settings->drdy_irq.mask_ihl, 1);\r\nif (err < 0)\r\ngoto iio_trigger_free;\r\ndev_info(&indio_dev->dev,\r\n"interrupts on the falling edge or "\r\n"active low level\n");\r\n}\r\nbreak;\r\ncase IRQF_TRIGGER_RISING:\r\ndev_info(&indio_dev->dev,\r\n"interrupts on the rising edge\n");\r\nbreak;\r\ncase IRQF_TRIGGER_HIGH:\r\ndev_info(&indio_dev->dev,\r\n"interrupts active high level\n");\r\nbreak;\r\ndefault:\r\ndev_err(&indio_dev->dev,\r\n"unsupported IRQ trigger specified (%lx), enforce "\r\n"rising edge\n", irq_trig);\r\nirq_trig = IRQF_TRIGGER_RISING;\r\n}\r\nif (irq_trig == IRQF_TRIGGER_FALLING ||\r\nirq_trig == IRQF_TRIGGER_RISING)\r\nsdata->edge_irq = true;\r\nelse\r\nirq_trig |= IRQF_ONESHOT;\r\nif (sdata->int_pin_open_drain &&\r\nsdata->sensor_settings->drdy_irq.addr_stat_drdy)\r\nirq_trig |= IRQF_SHARED;\r\nerr = request_threaded_irq(sdata->get_irq_data_ready(indio_dev),\r\nst_sensors_irq_handler,\r\nst_sensors_irq_thread,\r\nirq_trig,\r\nsdata->trig->name,\r\nsdata->trig);\r\nif (err) {\r\ndev_err(&indio_dev->dev, "failed to request trigger IRQ.\n");\r\ngoto iio_trigger_free;\r\n}\r\nerr = iio_trigger_register(sdata->trig);\r\nif (err < 0) {\r\ndev_err(&indio_dev->dev, "failed to register iio trigger.\n");\r\ngoto iio_trigger_register_error;\r\n}\r\nindio_dev->trig = iio_trigger_get(sdata->trig);\r\nreturn 0;\r\niio_trigger_register_error:\r\nfree_irq(sdata->get_irq_data_ready(indio_dev), sdata->trig);\r\niio_trigger_free:\r\niio_trigger_free(sdata->trig);\r\nreturn err;\r\n}\r\nvoid st_sensors_deallocate_trigger(struct iio_dev *indio_dev)\r\n{\r\nstruct st_sensor_data *sdata = iio_priv(indio_dev);\r\niio_trigger_unregister(sdata->trig);\r\nfree_irq(sdata->get_irq_data_ready(indio_dev), sdata->trig);\r\niio_trigger_free(sdata->trig);\r\n}\r\nint st_sensors_validate_device(struct iio_trigger *trig,\r\nstruct iio_dev *indio_dev)\r\n{\r\nstruct iio_dev *indio = iio_trigger_get_drvdata(trig);\r\nif (indio != indio_dev)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}
