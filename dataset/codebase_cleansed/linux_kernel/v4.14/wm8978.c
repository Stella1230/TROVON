static bool wm8978_volatile(struct device *dev, unsigned int reg)\r\n{\r\nreturn reg == WM8978_RESET;\r\n}\r\nstatic void pll_factors(struct snd_soc_codec *codec,\r\nstruct wm8978_pll_div *pll_div, unsigned int target, unsigned int source)\r\n{\r\nu64 k_part;\r\nunsigned int k, n_div, n_mod;\r\nn_div = target / source;\r\nif (n_div < 6) {\r\nsource >>= 1;\r\npll_div->div2 = 1;\r\nn_div = target / source;\r\n} else {\r\npll_div->div2 = 0;\r\n}\r\nif (n_div < 6 || n_div > 12)\r\ndev_warn(codec->dev,\r\n"WM8978 N value exceeds recommended range! N = %u\n",\r\nn_div);\r\npll_div->n = n_div;\r\nn_mod = target - source * n_div;\r\nk_part = FIXED_PLL_SIZE * (long long)n_mod + source / 2;\r\ndo_div(k_part, source);\r\nk = k_part & 0xFFFFFFFF;\r\npll_div->k = k;\r\n}\r\nstatic int wm8978_enum_mclk(unsigned int f_out, unsigned int f_mclk,\r\nunsigned int *f_pllout)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mclk_numerator); i++) {\r\nunsigned int f_pllout_x4 = 4 * f_out * mclk_numerator[i] /\r\nmclk_denominator[i];\r\nif (3 * f_mclk <= f_pllout_x4 && f_pllout_x4 < 13 * f_mclk) {\r\n*f_pllout = f_pllout_x4 / 4;\r\nreturn i;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int wm8978_configure_pll(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8978_priv *wm8978 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8978_pll_div pll_div;\r\nunsigned int f_opclk = wm8978->f_opclk, f_mclk = wm8978->f_mclk,\r\nf_256fs = wm8978->f_256fs;\r\nunsigned int f2;\r\nif (!f_mclk)\r\nreturn -EINVAL;\r\nif (f_opclk) {\r\nunsigned int opclk_div;\r\nwm8978->mclk_idx = -1;\r\nif (16 * f_opclk < 3 * f_mclk || 4 * f_opclk >= 13 * f_mclk)\r\nreturn -EINVAL;\r\nif (4 * f_opclk < 3 * f_mclk)\r\nopclk_div = (3 * f_mclk / 4 + f_opclk - 1) / f_opclk;\r\nelse\r\nopclk_div = 1;\r\ndev_dbg(codec->dev, "%s: OPCLKDIV=%d\n", __func__, opclk_div);\r\nsnd_soc_update_bits(codec, WM8978_GPIO_CONTROL, 0x30,\r\n(opclk_div - 1) << 4);\r\nwm8978->f_pllout = f_opclk * opclk_div;\r\n} else if (f_256fs) {\r\nint idx = wm8978_enum_mclk(f_256fs, f_mclk, &wm8978->f_pllout);\r\nif (idx < 0)\r\nreturn idx;\r\nwm8978->mclk_idx = idx;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nf2 = wm8978->f_pllout * 4;\r\ndev_dbg(codec->dev, "%s: f_MCLK=%uHz, f_PLLOUT=%uHz\n", __func__,\r\nwm8978->f_mclk, wm8978->f_pllout);\r\npll_factors(codec, &pll_div, f2, wm8978->f_mclk);\r\ndev_dbg(codec->dev, "%s: calculated PLL N=0x%x, K=0x%x, div2=%d\n",\r\n__func__, pll_div.n, pll_div.k, pll_div.div2);\r\nsnd_soc_update_bits(codec, WM8978_POWER_MANAGEMENT_1, 0x20, 0);\r\nsnd_soc_write(codec, WM8978_PLL_N, (pll_div.div2 << 4) | pll_div.n);\r\nsnd_soc_write(codec, WM8978_PLL_K1, pll_div.k >> 18);\r\nsnd_soc_write(codec, WM8978_PLL_K2, (pll_div.k >> 9) & 0x1ff);\r\nsnd_soc_write(codec, WM8978_PLL_K3, pll_div.k & 0x1ff);\r\nsnd_soc_update_bits(codec, WM8978_POWER_MANAGEMENT_1, 0x20, 0x20);\r\nif (f_opclk)\r\nsnd_soc_update_bits(codec, WM8978_GPIO_CONTROL, 7, 4);\r\nreturn 0;\r\n}\r\nstatic int wm8978_set_dai_clkdiv(struct snd_soc_dai *codec_dai,\r\nint div_id, int div)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct wm8978_priv *wm8978 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nswitch (div_id) {\r\ncase WM8978_OPCLKRATE:\r\nwm8978->f_opclk = div;\r\nif (wm8978->f_mclk)\r\nret = wm8978_configure_pll(codec);\r\nbreak;\r\ncase WM8978_BCLKDIV:\r\nif (div & ~0x1c)\r\nreturn -EINVAL;\r\nsnd_soc_update_bits(codec, WM8978_CLOCKING, 0x1c, div);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(codec->dev, "%s: ID %d, value %u\n", __func__, div_id, div);\r\nreturn ret;\r\n}\r\nstatic int wm8978_set_dai_sysclk(struct snd_soc_dai *codec_dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct wm8978_priv *wm8978 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\ndev_dbg(codec->dev, "%s: ID %d, freq %u\n", __func__, clk_id, freq);\r\nif (freq) {\r\nwm8978->f_mclk = freq;\r\nif (wm8978->f_opclk)\r\nret = wm8978_configure_pll(codec);\r\nif (!ret)\r\nwm8978->sysclk = clk_id;\r\n}\r\nif (wm8978->sysclk == WM8978_PLL && (!freq || clk_id == WM8978_MCLK)) {\r\nsnd_soc_update_bits(codec, WM8978_CLOCKING, 0x100, 0);\r\nsnd_soc_update_bits(codec, WM8978_GPIO_CONTROL, 7, 0);\r\nsnd_soc_update_bits(codec, WM8978_POWER_MANAGEMENT_1, 0x20, 0);\r\nwm8978->sysclk = WM8978_MCLK;\r\nwm8978->f_pllout = 0;\r\nwm8978->f_opclk = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wm8978_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 iface = snd_soc_read(codec, WM8978_AUDIO_INTERFACE) & ~0x198;\r\nu16 clk = snd_soc_read(codec, WM8978_CLOCKING);\r\ndev_dbg(codec->dev, "%s\n", __func__);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nclk |= 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nclk &= ~1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface |= 0x10;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface |= 0x8;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\niface |= 0x18;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\niface |= 0x180;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\niface |= 0x100;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\niface |= 0x80;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8978_AUDIO_INTERFACE, iface);\r\nsnd_soc_write(codec, WM8978_CLOCKING, clk);\r\nreturn 0;\r\n}\r\nstatic int wm8978_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8978_priv *wm8978 = snd_soc_codec_get_drvdata(codec);\r\nu16 iface_ctl = snd_soc_read(codec, WM8978_AUDIO_INTERFACE) & ~0x60;\r\nu16 add_ctl = snd_soc_read(codec, WM8978_ADDITIONAL_CONTROL) & ~0xe;\r\nu16 clking = snd_soc_read(codec, WM8978_CLOCKING);\r\nenum wm8978_sysclk_src current_clk_id = clking & 0x100 ?\r\nWM8978_PLL : WM8978_MCLK;\r\nunsigned int f_sel, diff, diff_best = INT_MAX;\r\nint i, best = 0;\r\nif (!wm8978->f_mclk)\r\nreturn -EINVAL;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nbreak;\r\ncase 20:\r\niface_ctl |= 0x20;\r\nbreak;\r\ncase 24:\r\niface_ctl |= 0x40;\r\nbreak;\r\ncase 32:\r\niface_ctl |= 0x60;\r\nbreak;\r\n}\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\nadd_ctl |= 0x5 << 1;\r\nbreak;\r\ncase 11025:\r\nadd_ctl |= 0x4 << 1;\r\nbreak;\r\ncase 16000:\r\nadd_ctl |= 0x3 << 1;\r\nbreak;\r\ncase 22050:\r\nadd_ctl |= 0x2 << 1;\r\nbreak;\r\ncase 32000:\r\nadd_ctl |= 0x1 << 1;\r\nbreak;\r\ncase 44100:\r\ncase 48000:\r\nbreak;\r\n}\r\nwm8978->f_256fs = params_rate(params) * 256;\r\nif (wm8978->sysclk == WM8978_MCLK) {\r\nwm8978->mclk_idx = -1;\r\nf_sel = wm8978->f_mclk;\r\n} else {\r\nif (!wm8978->f_opclk) {\r\nint ret = wm8978_configure_pll(codec);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nf_sel = wm8978->f_pllout;\r\n}\r\nif (wm8978->mclk_idx < 0) {\r\nif (f_sel < wm8978->f_256fs || f_sel > 12 * wm8978->f_256fs)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(mclk_numerator); i++) {\r\ndiff = abs(wm8978->f_256fs * 3 -\r\nf_sel * 3 * mclk_denominator[i] / mclk_numerator[i]);\r\nif (diff < diff_best) {\r\ndiff_best = diff;\r\nbest = i;\r\n}\r\nif (!diff)\r\nbreak;\r\n}\r\n} else {\r\nbest = wm8978->mclk_idx;\r\ndiff = 0;\r\n}\r\nif (diff)\r\ndev_warn(codec->dev, "Imprecise sampling rate: %uHz%s\n",\r\nf_sel * mclk_denominator[best] / mclk_numerator[best] / 256,\r\nwm8978->sysclk == WM8978_MCLK ?\r\n", consider using PLL" : "");\r\ndev_dbg(codec->dev, "%s: width %d, rate %u, MCLK divisor #%d\n", __func__,\r\nparams_width(params), params_rate(params), best);\r\nsnd_soc_update_bits(codec, WM8978_CLOCKING, 0xe0, best << 5);\r\nsnd_soc_write(codec, WM8978_AUDIO_INTERFACE, iface_ctl);\r\nsnd_soc_write(codec, WM8978_ADDITIONAL_CONTROL, add_ctl);\r\nif (wm8978->sysclk != current_clk_id) {\r\nif (wm8978->sysclk == WM8978_PLL)\r\nsnd_soc_update_bits(codec, WM8978_CLOCKING,\r\n0x100, 0x100);\r\nelse\r\nsnd_soc_update_bits(codec, WM8978_CLOCKING, 0x100, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8978_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\ndev_dbg(codec->dev, "%s: %d\n", __func__, mute);\r\nif (mute)\r\nsnd_soc_update_bits(codec, WM8978_DAC_CONTROL, 0x40, 0x40);\r\nelse\r\nsnd_soc_update_bits(codec, WM8978_DAC_CONTROL, 0x40, 0);\r\nreturn 0;\r\n}\r\nstatic int wm8978_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nu16 power1 = snd_soc_read(codec, WM8978_POWER_MANAGEMENT_1) & ~3;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\npower1 |= 1;\r\nsnd_soc_write(codec, WM8978_POWER_MANAGEMENT_1, power1);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\npower1 |= 0xc;\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nsnd_soc_write(codec, WM8978_POWER_MANAGEMENT_1,\r\npower1 | 0x3);\r\nmdelay(100);\r\n}\r\npower1 |= 0x2;\r\nsnd_soc_write(codec, WM8978_POWER_MANAGEMENT_1, power1);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, WM8978_POWER_MANAGEMENT_1, ~0x20, 0);\r\nsnd_soc_write(codec, WM8978_POWER_MANAGEMENT_2, 0);\r\nsnd_soc_write(codec, WM8978_POWER_MANAGEMENT_3, 0);\r\nbreak;\r\n}\r\ndev_dbg(codec->dev, "%s: %d, %x\n", __func__, level, power1);\r\nreturn 0;\r\n}\r\nstatic int wm8978_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8978_priv *wm8978 = snd_soc_codec_get_drvdata(codec);\r\nsnd_soc_codec_force_bias_level(codec, SND_SOC_BIAS_OFF);\r\nsnd_soc_write(codec, WM8978_POWER_MANAGEMENT_1, 0);\r\nregcache_mark_dirty(wm8978->regmap);\r\nreturn 0;\r\n}\r\nstatic int wm8978_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8978_priv *wm8978 = snd_soc_codec_get_drvdata(codec);\r\nregcache_sync(wm8978->regmap);\r\nsnd_soc_codec_force_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nif (wm8978->f_pllout)\r\nsnd_soc_update_bits(codec, WM8978_POWER_MANAGEMENT_1, 0x20, 0x20);\r\nreturn 0;\r\n}\r\nstatic int wm8978_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8978_priv *wm8978 = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\nwm8978->sysclk = WM8978_PLL;\r\nfor (i = 0; i < ARRAY_SIZE(update_reg); i++)\r\nsnd_soc_update_bits(codec, update_reg[i], 0x100, 0x100);\r\nreturn 0;\r\n}\r\nstatic int wm8978_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8978_priv *wm8978;\r\nint ret;\r\nwm8978 = devm_kzalloc(&i2c->dev, sizeof(struct wm8978_priv),\r\nGFP_KERNEL);\r\nif (wm8978 == NULL)\r\nreturn -ENOMEM;\r\nwm8978->regmap = devm_regmap_init_i2c(i2c, &wm8978_regmap_config);\r\nif (IS_ERR(wm8978->regmap)) {\r\nret = PTR_ERR(wm8978->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(i2c, wm8978);\r\nret = regmap_write(wm8978->regmap, WM8978_RESET, 0);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to issue reset: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8978, &wm8978_dai, 1);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to register CODEC: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8978_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
