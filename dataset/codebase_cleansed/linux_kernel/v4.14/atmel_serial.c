static inline struct atmel_uart_port *\r\nto_atmel_uart_port(struct uart_port *uart)\r\n{\r\nreturn container_of(uart, struct atmel_uart_port, uart);\r\n}\r\nstatic inline u32 atmel_uart_readl(struct uart_port *port, u32 reg)\r\n{\r\nreturn __raw_readl(port->membase + reg);\r\n}\r\nstatic inline void atmel_uart_writel(struct uart_port *port, u32 reg, u32 value)\r\n{\r\n__raw_writel(value, port->membase + reg);\r\n}\r\nstatic inline u8 atmel_uart_read_char(struct uart_port *port)\r\n{\r\nreturn __raw_readb(port->membase + ATMEL_US_RHR);\r\n}\r\nstatic inline void atmel_uart_write_char(struct uart_port *port, u8 value)\r\n{\r\n__raw_writeb(value, port->membase + ATMEL_US_THR);\r\n}\r\nstatic bool atmel_use_pdc_rx(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nreturn atmel_port->use_pdc_rx;\r\n}\r\nstatic bool atmel_use_pdc_tx(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nreturn atmel_port->use_pdc_tx;\r\n}\r\nstatic bool atmel_use_pdc_rx(struct uart_port *port)\r\n{\r\nreturn false;\r\n}\r\nstatic bool atmel_use_pdc_tx(struct uart_port *port)\r\n{\r\nreturn false;\r\n}\r\nstatic bool atmel_use_dma_tx(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nreturn atmel_port->use_dma_tx;\r\n}\r\nstatic bool atmel_use_dma_rx(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nreturn atmel_port->use_dma_rx;\r\n}\r\nstatic bool atmel_use_fifo(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nreturn atmel_port->fifo_size;\r\n}\r\nstatic void atmel_tasklet_schedule(struct atmel_uart_port *atmel_port,\r\nstruct tasklet_struct *t)\r\n{\r\nif (!atomic_read(&atmel_port->tasklet_shutdown))\r\ntasklet_schedule(t);\r\n}\r\nstatic unsigned int atmel_get_lines_status(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nunsigned int status, ret = 0;\r\nstatus = atmel_uart_readl(port, ATMEL_US_CSR);\r\nmctrl_gpio_get(atmel_port->gpios, &ret);\r\nif (!IS_ERR_OR_NULL(mctrl_gpio_to_gpiod(atmel_port->gpios,\r\nUART_GPIO_CTS))) {\r\nif (ret & TIOCM_CTS)\r\nstatus &= ~ATMEL_US_CTS;\r\nelse\r\nstatus |= ATMEL_US_CTS;\r\n}\r\nif (!IS_ERR_OR_NULL(mctrl_gpio_to_gpiod(atmel_port->gpios,\r\nUART_GPIO_DSR))) {\r\nif (ret & TIOCM_DSR)\r\nstatus &= ~ATMEL_US_DSR;\r\nelse\r\nstatus |= ATMEL_US_DSR;\r\n}\r\nif (!IS_ERR_OR_NULL(mctrl_gpio_to_gpiod(atmel_port->gpios,\r\nUART_GPIO_RI))) {\r\nif (ret & TIOCM_RI)\r\nstatus &= ~ATMEL_US_RI;\r\nelse\r\nstatus |= ATMEL_US_RI;\r\n}\r\nif (!IS_ERR_OR_NULL(mctrl_gpio_to_gpiod(atmel_port->gpios,\r\nUART_GPIO_DCD))) {\r\nif (ret & TIOCM_CD)\r\nstatus &= ~ATMEL_US_DCD;\r\nelse\r\nstatus |= ATMEL_US_DCD;\r\n}\r\nreturn status;\r\n}\r\nstatic int atmel_config_rs485(struct uart_port *port,\r\nstruct serial_rs485 *rs485conf)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nunsigned int mode;\r\natmel_uart_writel(port, ATMEL_US_IDR, atmel_port->tx_done_mask);\r\nmode = atmel_uart_readl(port, ATMEL_US_MR);\r\nmode &= ~ATMEL_US_USMODE;\r\nport->rs485 = *rs485conf;\r\nif (rs485conf->flags & SER_RS485_ENABLED) {\r\ndev_dbg(port->dev, "Setting UART to RS485\n");\r\natmel_port->tx_done_mask = ATMEL_US_TXEMPTY;\r\natmel_uart_writel(port, ATMEL_US_TTGR,\r\nrs485conf->delay_rts_after_send);\r\nmode |= ATMEL_US_USMODE_RS485;\r\n} else {\r\ndev_dbg(port->dev, "Setting UART to RS232\n");\r\nif (atmel_use_pdc_tx(port))\r\natmel_port->tx_done_mask = ATMEL_US_ENDTX |\r\nATMEL_US_TXBUFE;\r\nelse\r\natmel_port->tx_done_mask = ATMEL_US_TXRDY;\r\n}\r\natmel_uart_writel(port, ATMEL_US_MR, mode);\r\natmel_uart_writel(port, ATMEL_US_IER, atmel_port->tx_done_mask);\r\nreturn 0;\r\n}\r\nstatic u_int atmel_tx_empty(struct uart_port *port)\r\n{\r\nreturn (atmel_uart_readl(port, ATMEL_US_CSR) & ATMEL_US_TXEMPTY) ?\r\nTIOCSER_TEMT :\r\n0;\r\n}\r\nstatic void atmel_set_mctrl(struct uart_port *port, u_int mctrl)\r\n{\r\nunsigned int control = 0;\r\nunsigned int mode = atmel_uart_readl(port, ATMEL_US_MR);\r\nunsigned int rts_paused, rts_ready;\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (port->rs485.flags & SER_RS485_ENABLED) {\r\natmel_uart_writel(port, ATMEL_US_TTGR,\r\nport->rs485.delay_rts_after_send);\r\nmode &= ~ATMEL_US_USMODE;\r\nmode |= ATMEL_US_USMODE_RS485;\r\n}\r\nif ((mode & ATMEL_US_USMODE) == ATMEL_US_USMODE_HWHS) {\r\nrts_paused = ATMEL_US_RTSEN;\r\nrts_ready = ATMEL_US_RTSDIS;\r\n} else {\r\nrts_paused = ATMEL_US_RTSDIS;\r\nrts_ready = ATMEL_US_RTSEN;\r\n}\r\nif (mctrl & TIOCM_RTS)\r\ncontrol |= rts_ready;\r\nelse\r\ncontrol |= rts_paused;\r\nif (mctrl & TIOCM_DTR)\r\ncontrol |= ATMEL_US_DTREN;\r\nelse\r\ncontrol |= ATMEL_US_DTRDIS;\r\natmel_uart_writel(port, ATMEL_US_CR, control);\r\nmctrl_gpio_set(atmel_port->gpios, mctrl);\r\nmode &= ~ATMEL_US_CHMODE;\r\nif (mctrl & TIOCM_LOOP)\r\nmode |= ATMEL_US_CHMODE_LOC_LOOP;\r\nelse\r\nmode |= ATMEL_US_CHMODE_NORMAL;\r\natmel_uart_writel(port, ATMEL_US_MR, mode);\r\n}\r\nstatic u_int atmel_get_mctrl(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nunsigned int ret = 0, status;\r\nstatus = atmel_uart_readl(port, ATMEL_US_CSR);\r\nif (!(status & ATMEL_US_DCD))\r\nret |= TIOCM_CD;\r\nif (!(status & ATMEL_US_CTS))\r\nret |= TIOCM_CTS;\r\nif (!(status & ATMEL_US_DSR))\r\nret |= TIOCM_DSR;\r\nif (!(status & ATMEL_US_RI))\r\nret |= TIOCM_RI;\r\nreturn mctrl_gpio_get(atmel_port->gpios, &ret);\r\n}\r\nstatic void atmel_stop_tx(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (atmel_use_pdc_tx(port)) {\r\natmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTDIS);\r\n}\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXDIS);\r\natmel_uart_writel(port, ATMEL_US_IDR, atmel_port->tx_done_mask);\r\nif ((port->rs485.flags & SER_RS485_ENABLED) &&\r\n!(port->rs485.flags & SER_RS485_RX_DURING_TX))\r\natmel_start_rx(port);\r\n}\r\nstatic void atmel_start_tx(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (atmel_use_pdc_tx(port) && (atmel_uart_readl(port, ATMEL_PDC_PTSR)\r\n& ATMEL_PDC_TXTEN))\r\nreturn;\r\nif (atmel_use_pdc_tx(port) || atmel_use_dma_tx(port))\r\nif ((port->rs485.flags & SER_RS485_ENABLED) &&\r\n!(port->rs485.flags & SER_RS485_RX_DURING_TX))\r\natmel_stop_rx(port);\r\nif (atmel_use_pdc_tx(port))\r\natmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTEN);\r\natmel_uart_writel(port, ATMEL_US_IER, atmel_port->tx_done_mask);\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXEN);\r\n}\r\nstatic void atmel_start_rx(struct uart_port *port)\r\n{\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA);\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RXEN);\r\nif (atmel_use_pdc_rx(port)) {\r\natmel_uart_writel(port, ATMEL_US_IER,\r\nATMEL_US_ENDRX | ATMEL_US_TIMEOUT |\r\nport->read_status_mask);\r\natmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_RXTEN);\r\n} else {\r\natmel_uart_writel(port, ATMEL_US_IER, ATMEL_US_RXRDY);\r\n}\r\n}\r\nstatic void atmel_stop_rx(struct uart_port *port)\r\n{\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RXDIS);\r\nif (atmel_use_pdc_rx(port)) {\r\natmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_RXTDIS);\r\natmel_uart_writel(port, ATMEL_US_IDR,\r\nATMEL_US_ENDRX | ATMEL_US_TIMEOUT |\r\nport->read_status_mask);\r\n} else {\r\natmel_uart_writel(port, ATMEL_US_IDR, ATMEL_US_RXRDY);\r\n}\r\n}\r\nstatic void atmel_enable_ms(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nuint32_t ier = 0;\r\nif (atmel_port->ms_irq_enabled)\r\nreturn;\r\natmel_port->ms_irq_enabled = true;\r\nif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_CTS))\r\nier |= ATMEL_US_CTSIC;\r\nif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_DSR))\r\nier |= ATMEL_US_DSRIC;\r\nif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_RI))\r\nier |= ATMEL_US_RIIC;\r\nif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_DCD))\r\nier |= ATMEL_US_DCDIC;\r\natmel_uart_writel(port, ATMEL_US_IER, ier);\r\nmctrl_gpio_enable_ms(atmel_port->gpios);\r\n}\r\nstatic void atmel_disable_ms(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nuint32_t idr = 0;\r\nif (!atmel_port->ms_irq_enabled)\r\nreturn;\r\natmel_port->ms_irq_enabled = false;\r\nmctrl_gpio_disable_ms(atmel_port->gpios);\r\nif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_CTS))\r\nidr |= ATMEL_US_CTSIC;\r\nif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_DSR))\r\nidr |= ATMEL_US_DSRIC;\r\nif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_RI))\r\nidr |= ATMEL_US_RIIC;\r\nif (!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_DCD))\r\nidr |= ATMEL_US_DCDIC;\r\natmel_uart_writel(port, ATMEL_US_IDR, idr);\r\n}\r\nstatic void atmel_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nif (break_state != 0)\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_STTBRK);\r\nelse\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_STPBRK);\r\n}\r\nstatic void\r\natmel_buffer_rx_char(struct uart_port *port, unsigned int status,\r\nunsigned int ch)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct circ_buf *ring = &atmel_port->rx_ring;\r\nstruct atmel_uart_char *c;\r\nif (!CIRC_SPACE(ring->head, ring->tail, ATMEL_SERIAL_RINGSIZE))\r\nreturn;\r\nc = &((struct atmel_uart_char *)ring->buf)[ring->head];\r\nc->status = status;\r\nc->ch = ch;\r\nsmp_wmb();\r\nring->head = (ring->head + 1) & (ATMEL_SERIAL_RINGSIZE - 1);\r\n}\r\nstatic void atmel_pdc_rxerr(struct uart_port *port, unsigned int status)\r\n{\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA);\r\nif (status & ATMEL_US_RXBRK) {\r\nstatus &= ~(ATMEL_US_PARE | ATMEL_US_FRAME);\r\nport->icount.brk++;\r\n}\r\nif (status & ATMEL_US_PARE)\r\nport->icount.parity++;\r\nif (status & ATMEL_US_FRAME)\r\nport->icount.frame++;\r\nif (status & ATMEL_US_OVRE)\r\nport->icount.overrun++;\r\n}\r\nstatic void atmel_rx_chars(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nunsigned int status, ch;\r\nstatus = atmel_uart_readl(port, ATMEL_US_CSR);\r\nwhile (status & ATMEL_US_RXRDY) {\r\nch = atmel_uart_read_char(port);\r\nif (unlikely(status & (ATMEL_US_PARE | ATMEL_US_FRAME\r\n| ATMEL_US_OVRE | ATMEL_US_RXBRK)\r\n|| atmel_port->break_active)) {\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA);\r\nif (status & ATMEL_US_RXBRK\r\n&& !atmel_port->break_active) {\r\natmel_port->break_active = 1;\r\natmel_uart_writel(port, ATMEL_US_IER,\r\nATMEL_US_RXBRK);\r\n} else {\r\natmel_uart_writel(port, ATMEL_US_IDR,\r\nATMEL_US_RXBRK);\r\nstatus &= ~ATMEL_US_RXBRK;\r\natmel_port->break_active = 0;\r\n}\r\n}\r\natmel_buffer_rx_char(port, status, ch);\r\nstatus = atmel_uart_readl(port, ATMEL_US_CSR);\r\n}\r\natmel_tasklet_schedule(atmel_port, &atmel_port->tasklet_rx);\r\n}\r\nstatic void atmel_tx_chars(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (port->x_char &&\r\n(atmel_uart_readl(port, ATMEL_US_CSR) & atmel_port->tx_done_mask)) {\r\natmel_uart_write_char(port, port->x_char);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port))\r\nreturn;\r\nwhile (atmel_uart_readl(port, ATMEL_US_CSR) &\r\natmel_port->tx_done_mask) {\r\natmel_uart_write_char(port, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (!uart_circ_empty(xmit))\r\natmel_uart_writel(port, ATMEL_US_IER,\r\natmel_port->tx_done_mask);\r\n}\r\nstatic void atmel_complete_tx_dma(void *arg)\r\n{\r\nstruct atmel_uart_port *atmel_port = arg;\r\nstruct uart_port *port = &atmel_port->uart;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nstruct dma_chan *chan = atmel_port->chan_tx;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (chan)\r\ndmaengine_terminate_all(chan);\r\nxmit->tail += atmel_port->tx_len;\r\nxmit->tail &= UART_XMIT_SIZE - 1;\r\nport->icount.tx += atmel_port->tx_len;\r\nspin_lock_irq(&atmel_port->lock_tx);\r\nasync_tx_ack(atmel_port->desc_tx);\r\natmel_port->cookie_tx = -EINVAL;\r\natmel_port->desc_tx = NULL;\r\nspin_unlock_irq(&atmel_port->lock_tx);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (!uart_circ_empty(xmit))\r\natmel_tasklet_schedule(atmel_port, &atmel_port->tasklet_tx);\r\nelse if ((port->rs485.flags & SER_RS485_ENABLED) &&\r\n!(port->rs485.flags & SER_RS485_RX_DURING_TX)) {\r\natmel_start_rx(port);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void atmel_release_tx_dma(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct dma_chan *chan = atmel_port->chan_tx;\r\nif (chan) {\r\ndmaengine_terminate_all(chan);\r\ndma_release_channel(chan);\r\ndma_unmap_sg(port->dev, &atmel_port->sg_tx, 1,\r\nDMA_TO_DEVICE);\r\n}\r\natmel_port->desc_tx = NULL;\r\natmel_port->chan_tx = NULL;\r\natmel_port->cookie_tx = -EINVAL;\r\n}\r\nstatic void atmel_tx_dma(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nstruct dma_chan *chan = atmel_port->chan_tx;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct scatterlist sgl[2], *sg, *sg_tx = &atmel_port->sg_tx;\r\nunsigned int tx_len, part1_len, part2_len, sg_len;\r\ndma_addr_t phys_addr;\r\nif (atmel_port->desc_tx != NULL)\r\nreturn;\r\nif (!uart_circ_empty(xmit) && !uart_tx_stopped(port)) {\r\ntx_len = CIRC_CNT_TO_END(xmit->head,\r\nxmit->tail,\r\nUART_XMIT_SIZE);\r\nif (atmel_port->fifo_size) {\r\npart1_len = (tx_len & ~0x3);\r\npart2_len = (tx_len & 0x3);\r\n} else {\r\npart1_len = 0;\r\npart2_len = tx_len;\r\n}\r\nsg_init_table(sgl, 2);\r\nsg_len = 0;\r\nphys_addr = sg_dma_address(sg_tx) + xmit->tail;\r\nif (part1_len) {\r\nsg = &sgl[sg_len++];\r\nsg_dma_address(sg) = phys_addr;\r\nsg_dma_len(sg) = part1_len;\r\nphys_addr += part1_len;\r\n}\r\nif (part2_len) {\r\nsg = &sgl[sg_len++];\r\nsg_dma_address(sg) = phys_addr;\r\nsg_dma_len(sg) = part2_len;\r\n}\r\natmel_port->tx_len = tx_len;\r\ndesc = dmaengine_prep_slave_sg(chan,\r\nsgl,\r\nsg_len,\r\nDMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT |\r\nDMA_CTRL_ACK);\r\nif (!desc) {\r\ndev_err(port->dev, "Failed to send via dma!\n");\r\nreturn;\r\n}\r\ndma_sync_sg_for_device(port->dev, sg_tx, 1, DMA_TO_DEVICE);\r\natmel_port->desc_tx = desc;\r\ndesc->callback = atmel_complete_tx_dma;\r\ndesc->callback_param = atmel_port;\r\natmel_port->cookie_tx = dmaengine_submit(desc);\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic int atmel_prepare_tx_dma(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\ndma_cap_mask_t mask;\r\nstruct dma_slave_config config;\r\nint ret, nent;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\natmel_port->chan_tx = dma_request_slave_channel(port->dev, "tx");\r\nif (atmel_port->chan_tx == NULL)\r\ngoto chan_err;\r\ndev_info(port->dev, "using %s for tx DMA transfers\n",\r\ndma_chan_name(atmel_port->chan_tx));\r\nspin_lock_init(&atmel_port->lock_tx);\r\nsg_init_table(&atmel_port->sg_tx, 1);\r\nBUG_ON(!PAGE_ALIGNED(port->state->xmit.buf));\r\nsg_set_page(&atmel_port->sg_tx,\r\nvirt_to_page(port->state->xmit.buf),\r\nUART_XMIT_SIZE,\r\noffset_in_page(port->state->xmit.buf));\r\nnent = dma_map_sg(port->dev,\r\n&atmel_port->sg_tx,\r\n1,\r\nDMA_TO_DEVICE);\r\nif (!nent) {\r\ndev_dbg(port->dev, "need to release resource of dma\n");\r\ngoto chan_err;\r\n} else {\r\ndev_dbg(port->dev, "%s: mapped %d@%p to %pad\n", __func__,\r\nsg_dma_len(&atmel_port->sg_tx),\r\nport->state->xmit.buf,\r\n&sg_dma_address(&atmel_port->sg_tx));\r\n}\r\nmemset(&config, 0, sizeof(config));\r\nconfig.direction = DMA_MEM_TO_DEV;\r\nconfig.dst_addr_width = (atmel_port->fifo_size) ?\r\nDMA_SLAVE_BUSWIDTH_4_BYTES :\r\nDMA_SLAVE_BUSWIDTH_1_BYTE;\r\nconfig.dst_addr = port->mapbase + ATMEL_US_THR;\r\nconfig.dst_maxburst = 1;\r\nret = dmaengine_slave_config(atmel_port->chan_tx,\r\n&config);\r\nif (ret) {\r\ndev_err(port->dev, "DMA tx slave configuration failed\n");\r\ngoto chan_err;\r\n}\r\nreturn 0;\r\nchan_err:\r\ndev_err(port->dev, "TX channel not available, switch to pio\n");\r\natmel_port->use_dma_tx = 0;\r\nif (atmel_port->chan_tx)\r\natmel_release_tx_dma(port);\r\nreturn -EINVAL;\r\n}\r\nstatic void atmel_complete_rx_dma(void *arg)\r\n{\r\nstruct uart_port *port = arg;\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\natmel_tasklet_schedule(atmel_port, &atmel_port->tasklet_rx);\r\n}\r\nstatic void atmel_release_rx_dma(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct dma_chan *chan = atmel_port->chan_rx;\r\nif (chan) {\r\ndmaengine_terminate_all(chan);\r\ndma_release_channel(chan);\r\ndma_unmap_sg(port->dev, &atmel_port->sg_rx, 1,\r\nDMA_FROM_DEVICE);\r\n}\r\natmel_port->desc_rx = NULL;\r\natmel_port->chan_rx = NULL;\r\natmel_port->cookie_rx = -EINVAL;\r\n}\r\nstatic void atmel_rx_from_dma(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct tty_port *tport = &port->state->port;\r\nstruct circ_buf *ring = &atmel_port->rx_ring;\r\nstruct dma_chan *chan = atmel_port->chan_rx;\r\nstruct dma_tx_state state;\r\nenum dma_status dmastat;\r\nsize_t count;\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_STTTO);\r\ndmastat = dmaengine_tx_status(chan,\r\natmel_port->cookie_rx,\r\n&state);\r\nif (dmastat == DMA_ERROR) {\r\ndev_dbg(port->dev, "Get residue error, restart tasklet\n");\r\natmel_uart_writel(port, ATMEL_US_IER, ATMEL_US_TIMEOUT);\r\natmel_tasklet_schedule(atmel_port, &atmel_port->tasklet_rx);\r\nreturn;\r\n}\r\ndma_sync_sg_for_cpu(port->dev,\r\n&atmel_port->sg_rx,\r\n1,\r\nDMA_FROM_DEVICE);\r\nring->head = sg_dma_len(&atmel_port->sg_rx) - state.residue;\r\nBUG_ON(ring->head > sg_dma_len(&atmel_port->sg_rx));\r\nif (ring->head < ring->tail) {\r\ncount = sg_dma_len(&atmel_port->sg_rx) - ring->tail;\r\ntty_insert_flip_string(tport, ring->buf + ring->tail, count);\r\nring->tail = 0;\r\nport->icount.rx += count;\r\n}\r\nif (ring->tail < ring->head) {\r\ncount = ring->head - ring->tail;\r\ntty_insert_flip_string(tport, ring->buf + ring->tail, count);\r\nif (ring->head >= sg_dma_len(&atmel_port->sg_rx))\r\nring->head = 0;\r\nring->tail = ring->head;\r\nport->icount.rx += count;\r\n}\r\ndma_sync_sg_for_device(port->dev,\r\n&atmel_port->sg_rx,\r\n1,\r\nDMA_FROM_DEVICE);\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(tport);\r\nspin_lock(&port->lock);\r\natmel_uart_writel(port, ATMEL_US_IER, ATMEL_US_TIMEOUT);\r\n}\r\nstatic int atmel_prepare_rx_dma(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct dma_async_tx_descriptor *desc;\r\ndma_cap_mask_t mask;\r\nstruct dma_slave_config config;\r\nstruct circ_buf *ring;\r\nint ret, nent;\r\nring = &atmel_port->rx_ring;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_CYCLIC, mask);\r\natmel_port->chan_rx = dma_request_slave_channel(port->dev, "rx");\r\nif (atmel_port->chan_rx == NULL)\r\ngoto chan_err;\r\ndev_info(port->dev, "using %s for rx DMA transfers\n",\r\ndma_chan_name(atmel_port->chan_rx));\r\nspin_lock_init(&atmel_port->lock_rx);\r\nsg_init_table(&atmel_port->sg_rx, 1);\r\nBUG_ON(!PAGE_ALIGNED(ring->buf));\r\nsg_set_page(&atmel_port->sg_rx,\r\nvirt_to_page(ring->buf),\r\nsizeof(struct atmel_uart_char) * ATMEL_SERIAL_RINGSIZE,\r\noffset_in_page(ring->buf));\r\nnent = dma_map_sg(port->dev,\r\n&atmel_port->sg_rx,\r\n1,\r\nDMA_FROM_DEVICE);\r\nif (!nent) {\r\ndev_dbg(port->dev, "need to release resource of dma\n");\r\ngoto chan_err;\r\n} else {\r\ndev_dbg(port->dev, "%s: mapped %d@%p to %pad\n", __func__,\r\nsg_dma_len(&atmel_port->sg_rx),\r\nring->buf,\r\n&sg_dma_address(&atmel_port->sg_rx));\r\n}\r\nmemset(&config, 0, sizeof(config));\r\nconfig.direction = DMA_DEV_TO_MEM;\r\nconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nconfig.src_addr = port->mapbase + ATMEL_US_RHR;\r\nconfig.src_maxburst = 1;\r\nret = dmaengine_slave_config(atmel_port->chan_rx,\r\n&config);\r\nif (ret) {\r\ndev_err(port->dev, "DMA rx slave configuration failed\n");\r\ngoto chan_err;\r\n}\r\ndesc = dmaengine_prep_dma_cyclic(atmel_port->chan_rx,\r\nsg_dma_address(&atmel_port->sg_rx),\r\nsg_dma_len(&atmel_port->sg_rx),\r\nsg_dma_len(&atmel_port->sg_rx)/2,\r\nDMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT);\r\ndesc->callback = atmel_complete_rx_dma;\r\ndesc->callback_param = port;\r\natmel_port->desc_rx = desc;\r\natmel_port->cookie_rx = dmaengine_submit(desc);\r\nreturn 0;\r\nchan_err:\r\ndev_err(port->dev, "RX channel not available, switch to pio\n");\r\natmel_port->use_dma_rx = 0;\r\nif (atmel_port->chan_rx)\r\natmel_release_rx_dma(port);\r\nreturn -EINVAL;\r\n}\r\nstatic void atmel_uart_timer_callback(unsigned long data)\r\n{\r\nstruct uart_port *port = (void *)data;\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (!atomic_read(&atmel_port->tasklet_shutdown)) {\r\ntasklet_schedule(&atmel_port->tasklet_rx);\r\nmod_timer(&atmel_port->uart_timer,\r\njiffies + uart_poll_timeout(port));\r\n}\r\n}\r\nstatic void\r\natmel_handle_receive(struct uart_port *port, unsigned int pending)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (atmel_use_pdc_rx(port)) {\r\nif (pending & (ATMEL_US_ENDRX | ATMEL_US_TIMEOUT)) {\r\natmel_uart_writel(port, ATMEL_US_IDR,\r\n(ATMEL_US_ENDRX | ATMEL_US_TIMEOUT));\r\natmel_tasklet_schedule(atmel_port,\r\n&atmel_port->tasklet_rx);\r\n}\r\nif (pending & (ATMEL_US_RXBRK | ATMEL_US_OVRE |\r\nATMEL_US_FRAME | ATMEL_US_PARE))\r\natmel_pdc_rxerr(port, pending);\r\n}\r\nif (atmel_use_dma_rx(port)) {\r\nif (pending & ATMEL_US_TIMEOUT) {\r\natmel_uart_writel(port, ATMEL_US_IDR,\r\nATMEL_US_TIMEOUT);\r\natmel_tasklet_schedule(atmel_port,\r\n&atmel_port->tasklet_rx);\r\n}\r\n}\r\nif (pending & ATMEL_US_RXRDY)\r\natmel_rx_chars(port);\r\nelse if (pending & ATMEL_US_RXBRK) {\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA);\r\natmel_uart_writel(port, ATMEL_US_IDR, ATMEL_US_RXBRK);\r\natmel_port->break_active = 0;\r\n}\r\n}\r\nstatic void\r\natmel_handle_transmit(struct uart_port *port, unsigned int pending)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (pending & atmel_port->tx_done_mask) {\r\natmel_uart_writel(port, ATMEL_US_IDR,\r\natmel_port->tx_done_mask);\r\natmel_tasklet_schedule(atmel_port, &atmel_port->tasklet_tx);\r\n}\r\n}\r\nstatic void\r\natmel_handle_status(struct uart_port *port, unsigned int pending,\r\nunsigned int status)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nunsigned int status_change;\r\nif (pending & (ATMEL_US_RIIC | ATMEL_US_DSRIC | ATMEL_US_DCDIC\r\n| ATMEL_US_CTSIC)) {\r\nstatus_change = status ^ atmel_port->irq_status_prev;\r\natmel_port->irq_status_prev = status;\r\nif (status_change & (ATMEL_US_RI | ATMEL_US_DSR\r\n| ATMEL_US_DCD | ATMEL_US_CTS)) {\r\nif (status_change & ATMEL_US_RI)\r\nport->icount.rng++;\r\nif (status_change & ATMEL_US_DSR)\r\nport->icount.dsr++;\r\nif (status_change & ATMEL_US_DCD)\r\nuart_handle_dcd_change(port, !(status & ATMEL_US_DCD));\r\nif (status_change & ATMEL_US_CTS)\r\nuart_handle_cts_change(port, !(status & ATMEL_US_CTS));\r\nwake_up_interruptible(&port->state->port.delta_msr_wait);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t atmel_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nunsigned int status, pending, mask, pass_counter = 0;\r\nspin_lock(&atmel_port->lock_suspended);\r\ndo {\r\nstatus = atmel_get_lines_status(port);\r\nmask = atmel_uart_readl(port, ATMEL_US_IMR);\r\npending = status & mask;\r\nif (!pending)\r\nbreak;\r\nif (atmel_port->suspended) {\r\natmel_port->pending |= pending;\r\natmel_port->pending_status = status;\r\natmel_uart_writel(port, ATMEL_US_IDR, mask);\r\npm_system_wakeup();\r\nbreak;\r\n}\r\natmel_handle_receive(port, pending);\r\natmel_handle_status(port, pending, status);\r\natmel_handle_transmit(port, pending);\r\n} while (pass_counter++ < ATMEL_ISR_PASS_LIMIT);\r\nspin_unlock(&atmel_port->lock_suspended);\r\nreturn pass_counter ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void atmel_release_tx_pdc(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;\r\ndma_unmap_single(port->dev,\r\npdc->dma_addr,\r\npdc->dma_size,\r\nDMA_TO_DEVICE);\r\n}\r\nstatic void atmel_tx_pdc(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nstruct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;\r\nint count;\r\nif (atmel_uart_readl(port, ATMEL_PDC_TCR))\r\nreturn;\r\nxmit->tail += pdc->ofs;\r\nxmit->tail &= UART_XMIT_SIZE - 1;\r\nport->icount.tx += pdc->ofs;\r\npdc->ofs = 0;\r\natmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTDIS);\r\nif (!uart_circ_empty(xmit) && !uart_tx_stopped(port)) {\r\ndma_sync_single_for_device(port->dev,\r\npdc->dma_addr,\r\npdc->dma_size,\r\nDMA_TO_DEVICE);\r\ncount = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\r\npdc->ofs = count;\r\natmel_uart_writel(port, ATMEL_PDC_TPR,\r\npdc->dma_addr + xmit->tail);\r\natmel_uart_writel(port, ATMEL_PDC_TCR, count);\r\natmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTEN);\r\natmel_uart_writel(port, ATMEL_US_IER,\r\natmel_port->tx_done_mask);\r\n} else {\r\nif ((port->rs485.flags & SER_RS485_ENABLED) &&\r\n!(port->rs485.flags & SER_RS485_RX_DURING_TX)) {\r\natmel_start_rx(port);\r\n}\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic int atmel_prepare_tx_pdc(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\npdc->buf = xmit->buf;\r\npdc->dma_addr = dma_map_single(port->dev,\r\npdc->buf,\r\nUART_XMIT_SIZE,\r\nDMA_TO_DEVICE);\r\npdc->dma_size = UART_XMIT_SIZE;\r\npdc->ofs = 0;\r\nreturn 0;\r\n}\r\nstatic void atmel_rx_from_ring(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct circ_buf *ring = &atmel_port->rx_ring;\r\nunsigned int flg;\r\nunsigned int status;\r\nwhile (ring->head != ring->tail) {\r\nstruct atmel_uart_char c;\r\nsmp_rmb();\r\nc = ((struct atmel_uart_char *)ring->buf)[ring->tail];\r\nring->tail = (ring->tail + 1) & (ATMEL_SERIAL_RINGSIZE - 1);\r\nport->icount.rx++;\r\nstatus = c.status;\r\nflg = TTY_NORMAL;\r\nif (unlikely(status & (ATMEL_US_PARE | ATMEL_US_FRAME\r\n| ATMEL_US_OVRE | ATMEL_US_RXBRK))) {\r\nif (status & ATMEL_US_RXBRK) {\r\nstatus &= ~(ATMEL_US_PARE | ATMEL_US_FRAME);\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n}\r\nif (status & ATMEL_US_PARE)\r\nport->icount.parity++;\r\nif (status & ATMEL_US_FRAME)\r\nport->icount.frame++;\r\nif (status & ATMEL_US_OVRE)\r\nport->icount.overrun++;\r\nstatus &= port->read_status_mask;\r\nif (status & ATMEL_US_RXBRK)\r\nflg = TTY_BREAK;\r\nelse if (status & ATMEL_US_PARE)\r\nflg = TTY_PARITY;\r\nelse if (status & ATMEL_US_FRAME)\r\nflg = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(port, c.ch))\r\ncontinue;\r\nuart_insert_char(port, status, ATMEL_US_OVRE, c.ch, flg);\r\n}\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(&port->state->port);\r\nspin_lock(&port->lock);\r\n}\r\nstatic void atmel_release_rx_pdc(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nstruct atmel_dma_buffer *pdc = &atmel_port->pdc_rx[i];\r\ndma_unmap_single(port->dev,\r\npdc->dma_addr,\r\npdc->dma_size,\r\nDMA_FROM_DEVICE);\r\nkfree(pdc->buf);\r\n}\r\n}\r\nstatic void atmel_rx_from_pdc(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct tty_port *tport = &port->state->port;\r\nstruct atmel_dma_buffer *pdc;\r\nint rx_idx = atmel_port->pdc_rx_idx;\r\nunsigned int head;\r\nunsigned int tail;\r\nunsigned int count;\r\ndo {\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_STTTO);\r\npdc = &atmel_port->pdc_rx[rx_idx];\r\nhead = atmel_uart_readl(port, ATMEL_PDC_RPR) - pdc->dma_addr;\r\ntail = pdc->ofs;\r\nhead = min(head, pdc->dma_size);\r\nif (likely(head != tail)) {\r\ndma_sync_single_for_cpu(port->dev, pdc->dma_addr,\r\npdc->dma_size, DMA_FROM_DEVICE);\r\ncount = head - tail;\r\ntty_insert_flip_string(tport, pdc->buf + pdc->ofs,\r\ncount);\r\ndma_sync_single_for_device(port->dev, pdc->dma_addr,\r\npdc->dma_size, DMA_FROM_DEVICE);\r\nport->icount.rx += count;\r\npdc->ofs = head;\r\n}\r\nif (head >= pdc->dma_size) {\r\npdc->ofs = 0;\r\natmel_uart_writel(port, ATMEL_PDC_RNPR, pdc->dma_addr);\r\natmel_uart_writel(port, ATMEL_PDC_RNCR, pdc->dma_size);\r\nrx_idx = !rx_idx;\r\natmel_port->pdc_rx_idx = rx_idx;\r\n}\r\n} while (head >= pdc->dma_size);\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(tport);\r\nspin_lock(&port->lock);\r\natmel_uart_writel(port, ATMEL_US_IER,\r\nATMEL_US_ENDRX | ATMEL_US_TIMEOUT);\r\n}\r\nstatic int atmel_prepare_rx_pdc(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nstruct atmel_dma_buffer *pdc = &atmel_port->pdc_rx[i];\r\npdc->buf = kmalloc(PDC_BUFFER_SIZE, GFP_KERNEL);\r\nif (pdc->buf == NULL) {\r\nif (i != 0) {\r\ndma_unmap_single(port->dev,\r\natmel_port->pdc_rx[0].dma_addr,\r\nPDC_BUFFER_SIZE,\r\nDMA_FROM_DEVICE);\r\nkfree(atmel_port->pdc_rx[0].buf);\r\n}\r\natmel_port->use_pdc_rx = 0;\r\nreturn -ENOMEM;\r\n}\r\npdc->dma_addr = dma_map_single(port->dev,\r\npdc->buf,\r\nPDC_BUFFER_SIZE,\r\nDMA_FROM_DEVICE);\r\npdc->dma_size = PDC_BUFFER_SIZE;\r\npdc->ofs = 0;\r\n}\r\natmel_port->pdc_rx_idx = 0;\r\natmel_uart_writel(port, ATMEL_PDC_RPR, atmel_port->pdc_rx[0].dma_addr);\r\natmel_uart_writel(port, ATMEL_PDC_RCR, PDC_BUFFER_SIZE);\r\natmel_uart_writel(port, ATMEL_PDC_RNPR,\r\natmel_port->pdc_rx[1].dma_addr);\r\natmel_uart_writel(port, ATMEL_PDC_RNCR, PDC_BUFFER_SIZE);\r\nreturn 0;\r\n}\r\nstatic void atmel_tasklet_rx_func(unsigned long data)\r\n{\r\nstruct uart_port *port = (struct uart_port *)data;\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nspin_lock(&port->lock);\r\natmel_port->schedule_rx(port);\r\nspin_unlock(&port->lock);\r\n}\r\nstatic void atmel_tasklet_tx_func(unsigned long data)\r\n{\r\nstruct uart_port *port = (struct uart_port *)data;\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nspin_lock(&port->lock);\r\natmel_port->schedule_tx(port);\r\nspin_unlock(&port->lock);\r\n}\r\nstatic void atmel_init_property(struct atmel_uart_port *atmel_port,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nif (of_property_read_bool(np, "atmel,use-dma-rx")) {\r\nif (of_property_read_bool(np, "dmas")) {\r\natmel_port->use_dma_rx = true;\r\natmel_port->use_pdc_rx = false;\r\n} else {\r\natmel_port->use_dma_rx = false;\r\natmel_port->use_pdc_rx = true;\r\n}\r\n} else {\r\natmel_port->use_dma_rx = false;\r\natmel_port->use_pdc_rx = false;\r\n}\r\nif (of_property_read_bool(np, "atmel,use-dma-tx")) {\r\nif (of_property_read_bool(np, "dmas")) {\r\natmel_port->use_dma_tx = true;\r\natmel_port->use_pdc_tx = false;\r\n} else {\r\natmel_port->use_dma_tx = false;\r\natmel_port->use_pdc_tx = true;\r\n}\r\n} else {\r\natmel_port->use_dma_tx = false;\r\natmel_port->use_pdc_tx = false;\r\n}\r\n}\r\nstatic void atmel_init_rs485(struct uart_port *port,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct serial_rs485 *rs485conf = &port->rs485;\r\nu32 rs485_delay[2];\r\nif (of_property_read_u32_array(np, "rs485-rts-delay",\r\nrs485_delay, 2) == 0) {\r\nrs485conf->delay_rts_before_send = rs485_delay[0];\r\nrs485conf->delay_rts_after_send = rs485_delay[1];\r\nrs485conf->flags = 0;\r\n}\r\nif (of_get_property(np, "rs485-rx-during-tx", NULL))\r\nrs485conf->flags |= SER_RS485_RX_DURING_TX;\r\nif (of_get_property(np, "linux,rs485-enabled-at-boot-time", NULL))\r\nrs485conf->flags |= SER_RS485_ENABLED;\r\n}\r\nstatic void atmel_set_ops(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (atmel_use_dma_rx(port)) {\r\natmel_port->prepare_rx = &atmel_prepare_rx_dma;\r\natmel_port->schedule_rx = &atmel_rx_from_dma;\r\natmel_port->release_rx = &atmel_release_rx_dma;\r\n} else if (atmel_use_pdc_rx(port)) {\r\natmel_port->prepare_rx = &atmel_prepare_rx_pdc;\r\natmel_port->schedule_rx = &atmel_rx_from_pdc;\r\natmel_port->release_rx = &atmel_release_rx_pdc;\r\n} else {\r\natmel_port->prepare_rx = NULL;\r\natmel_port->schedule_rx = &atmel_rx_from_ring;\r\natmel_port->release_rx = NULL;\r\n}\r\nif (atmel_use_dma_tx(port)) {\r\natmel_port->prepare_tx = &atmel_prepare_tx_dma;\r\natmel_port->schedule_tx = &atmel_tx_dma;\r\natmel_port->release_tx = &atmel_release_tx_dma;\r\n} else if (atmel_use_pdc_tx(port)) {\r\natmel_port->prepare_tx = &atmel_prepare_tx_pdc;\r\natmel_port->schedule_tx = &atmel_tx_pdc;\r\natmel_port->release_tx = &atmel_release_tx_pdc;\r\n} else {\r\natmel_port->prepare_tx = NULL;\r\natmel_port->schedule_tx = &atmel_tx_chars;\r\natmel_port->release_tx = NULL;\r\n}\r\n}\r\nstatic void atmel_get_ip_name(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nint name = atmel_uart_readl(port, ATMEL_US_NAME);\r\nu32 version;\r\nu32 usart, dbgu_uart, new_uart;\r\nusart = 0x55534152;\r\ndbgu_uart = 0x44424755;\r\nnew_uart = 0x55415254;\r\natmel_port->has_frac_baudrate = false;\r\natmel_port->has_hw_timer = false;\r\nif (name == new_uart) {\r\ndev_dbg(port->dev, "Uart with hw timer");\r\natmel_port->has_hw_timer = true;\r\natmel_port->rtor = ATMEL_UA_RTOR;\r\n} else if (name == usart) {\r\ndev_dbg(port->dev, "Usart\n");\r\natmel_port->has_frac_baudrate = true;\r\natmel_port->has_hw_timer = true;\r\natmel_port->rtor = ATMEL_US_RTOR;\r\n} else if (name == dbgu_uart) {\r\ndev_dbg(port->dev, "Dbgu or uart without hw timer\n");\r\n} else {\r\nversion = atmel_uart_readl(port, ATMEL_US_VERSION);\r\nswitch (version) {\r\ncase 0x302:\r\ncase 0x10213:\r\ndev_dbg(port->dev, "This version is usart\n");\r\natmel_port->has_frac_baudrate = true;\r\natmel_port->has_hw_timer = true;\r\natmel_port->rtor = ATMEL_US_RTOR;\r\nbreak;\r\ncase 0x203:\r\ncase 0x10202:\r\ndev_dbg(port->dev, "This version is uart\n");\r\nbreak;\r\ndefault:\r\ndev_err(port->dev, "Not supported ip name nor version, set to uart\n");\r\n}\r\n}\r\n}\r\nstatic int atmel_startup(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct tty_struct *tty = port->state->port.tty;\r\nint retval;\r\natmel_uart_writel(port, ATMEL_US_IDR, -1);\r\natmel_port->ms_irq_enabled = false;\r\nretval = request_irq(port->irq, atmel_interrupt,\r\nIRQF_SHARED | IRQF_COND_SUSPEND,\r\ntty ? tty->name : "atmel_serial", port);\r\nif (retval) {\r\ndev_err(port->dev, "atmel_startup - Can't get irq\n");\r\nreturn retval;\r\n}\r\natomic_set(&atmel_port->tasklet_shutdown, 0);\r\ntasklet_init(&atmel_port->tasklet_rx, atmel_tasklet_rx_func,\r\n(unsigned long)port);\r\ntasklet_init(&atmel_port->tasklet_tx, atmel_tasklet_tx_func,\r\n(unsigned long)port);\r\natmel_init_property(atmel_port, pdev);\r\natmel_set_ops(port);\r\nif (atmel_port->prepare_rx) {\r\nretval = atmel_port->prepare_rx(port);\r\nif (retval < 0)\r\natmel_set_ops(port);\r\n}\r\nif (atmel_port->prepare_tx) {\r\nretval = atmel_port->prepare_tx(port);\r\nif (retval < 0)\r\natmel_set_ops(port);\r\n}\r\nif (atmel_port->fifo_size) {\r\nunsigned int txrdym = ATMEL_US_ONE_DATA;\r\nunsigned int rxrdym = ATMEL_US_ONE_DATA;\r\nunsigned int fmr;\r\natmel_uart_writel(port, ATMEL_US_CR,\r\nATMEL_US_FIFOEN |\r\nATMEL_US_RXFCLR |\r\nATMEL_US_TXFLCLR);\r\nif (atmel_use_dma_tx(port))\r\ntxrdym = ATMEL_US_FOUR_DATA;\r\nfmr = ATMEL_US_TXRDYM(txrdym) | ATMEL_US_RXRDYM(rxrdym);\r\nif (atmel_port->rts_high &&\r\natmel_port->rts_low)\r\nfmr |= ATMEL_US_FRTSC |\r\nATMEL_US_RXFTHRES(atmel_port->rts_high) |\r\nATMEL_US_RXFTHRES2(atmel_port->rts_low);\r\natmel_uart_writel(port, ATMEL_US_FMR, fmr);\r\n}\r\natmel_port->irq_status_prev = atmel_get_lines_status(port);\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA | ATMEL_US_RSTRX);\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXEN | ATMEL_US_RXEN);\r\nsetup_timer(&atmel_port->uart_timer,\r\natmel_uart_timer_callback,\r\n(unsigned long)port);\r\nif (atmel_use_pdc_rx(port)) {\r\nif (!atmel_port->has_hw_timer) {\r\nmod_timer(&atmel_port->uart_timer,\r\njiffies + uart_poll_timeout(port));\r\n} else {\r\natmel_uart_writel(port, atmel_port->rtor,\r\nPDC_RX_TIMEOUT);\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_STTTO);\r\natmel_uart_writel(port, ATMEL_US_IER,\r\nATMEL_US_ENDRX | ATMEL_US_TIMEOUT);\r\n}\r\natmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_RXTEN);\r\n} else if (atmel_use_dma_rx(port)) {\r\nif (!atmel_port->has_hw_timer) {\r\nmod_timer(&atmel_port->uart_timer,\r\njiffies + uart_poll_timeout(port));\r\n} else {\r\natmel_uart_writel(port, atmel_port->rtor,\r\nPDC_RX_TIMEOUT);\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_STTTO);\r\natmel_uart_writel(port, ATMEL_US_IER,\r\nATMEL_US_TIMEOUT);\r\n}\r\n} else {\r\natmel_uart_writel(port, ATMEL_US_IER, ATMEL_US_RXRDY);\r\n}\r\nreturn 0;\r\n}\r\nstatic void atmel_flush_buffer(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (atmel_use_pdc_tx(port)) {\r\natmel_uart_writel(port, ATMEL_PDC_TCR, 0);\r\natmel_port->pdc_tx.ofs = 0;\r\n}\r\natmel_port->tx_len = 0;\r\n}\r\nstatic void atmel_shutdown(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\natmel_disable_ms(port);\r\natmel_uart_writel(port, ATMEL_US_IDR, -1);\r\natomic_inc(&atmel_port->tasklet_shutdown);\r\ndel_timer_sync(&atmel_port->uart_timer);\r\nsynchronize_irq(port->irq);\r\ntasklet_kill(&atmel_port->tasklet_rx);\r\ntasklet_kill(&atmel_port->tasklet_tx);\r\natmel_stop_rx(port);\r\natmel_stop_tx(port);\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA);\r\nif (atmel_port->release_rx)\r\natmel_port->release_rx(port);\r\nif (atmel_port->release_tx)\r\natmel_port->release_tx(port);\r\natmel_port->rx_ring.head = 0;\r\natmel_port->rx_ring.tail = 0;\r\nfree_irq(port->irq, port);\r\natmel_flush_buffer(port);\r\n}\r\nstatic void atmel_serial_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nswitch (state) {\r\ncase 0:\r\nclk_prepare_enable(atmel_port->clk);\r\natmel_uart_writel(port, ATMEL_US_IER, atmel_port->backup_imr);\r\nbreak;\r\ncase 3:\r\natmel_port->backup_imr = atmel_uart_readl(port, ATMEL_US_IMR);\r\natmel_uart_writel(port, ATMEL_US_IDR, -1);\r\nclk_disable_unprepare(atmel_port->clk);\r\nbreak;\r\ndefault:\r\ndev_err(port->dev, "atmel_serial: unknown pm %d\n", state);\r\n}\r\n}\r\nstatic void atmel_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nunsigned long flags;\r\nunsigned int old_mode, mode, imr, quot, baud, div, cd, fp = 0;\r\nmode = old_mode = atmel_uart_readl(port, ATMEL_US_MR);\r\nmode &= ~(ATMEL_US_USCLKS | ATMEL_US_CHRL | ATMEL_US_NBSTOP |\r\nATMEL_US_PAR | ATMEL_US_USMODE);\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 16);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nmode |= ATMEL_US_CHRL_5;\r\nbreak;\r\ncase CS6:\r\nmode |= ATMEL_US_CHRL_6;\r\nbreak;\r\ncase CS7:\r\nmode |= ATMEL_US_CHRL_7;\r\nbreak;\r\ndefault:\r\nmode |= ATMEL_US_CHRL_8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nmode |= ATMEL_US_NBSTOP_2;\r\nif (termios->c_cflag & PARENB) {\r\nif (termios->c_cflag & CMSPAR) {\r\nif (termios->c_cflag & PARODD)\r\nmode |= ATMEL_US_PAR_MARK;\r\nelse\r\nmode |= ATMEL_US_PAR_SPACE;\r\n} else if (termios->c_cflag & PARODD)\r\nmode |= ATMEL_US_PAR_ODD;\r\nelse\r\nmode |= ATMEL_US_PAR_EVEN;\r\n} else\r\nmode |= ATMEL_US_PAR_NONE;\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->read_status_mask = ATMEL_US_OVRE;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= (ATMEL_US_FRAME | ATMEL_US_PARE);\r\nif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\nport->read_status_mask |= ATMEL_US_RXBRK;\r\nif (atmel_use_pdc_rx(port))\r\natmel_uart_writel(port, ATMEL_US_IER, port->read_status_mask);\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= (ATMEL_US_FRAME | ATMEL_US_PARE);\r\nif (termios->c_iflag & IGNBRK) {\r\nport->ignore_status_mask |= ATMEL_US_RXBRK;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= ATMEL_US_OVRE;\r\n}\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nimr = atmel_uart_readl(port, ATMEL_US_IMR);\r\natmel_uart_writel(port, ATMEL_US_IDR, -1);\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXDIS | ATMEL_US_RXDIS);\r\nif (port->rs485.flags & SER_RS485_ENABLED) {\r\natmel_uart_writel(port, ATMEL_US_TTGR,\r\nport->rs485.delay_rts_after_send);\r\nmode |= ATMEL_US_USMODE_RS485;\r\n} else if (termios->c_cflag & CRTSCTS) {\r\nif (atmel_use_fifo(port) &&\r\n!mctrl_gpio_to_gpiod(atmel_port->gpios, UART_GPIO_CTS)) {\r\nmode |= ATMEL_US_USMODE_HWHS;\r\n} else {\r\nmode |= ATMEL_US_USMODE_NORMAL;\r\n}\r\n} else {\r\nmode |= ATMEL_US_USMODE_NORMAL;\r\n}\r\natmel_uart_writel(port, ATMEL_US_MR, mode);\r\nif ((old_mode & ATMEL_US_USMODE) != (mode & ATMEL_US_USMODE)) {\r\nunsigned int rts_state;\r\nif ((mode & ATMEL_US_USMODE) == ATMEL_US_USMODE_HWHS) {\r\nrts_state = ATMEL_US_RTSDIS;\r\n} else {\r\nrts_state = ATMEL_US_RTSEN;\r\n}\r\natmel_uart_writel(port, ATMEL_US_CR, rts_state);\r\n}\r\nif (atmel_port->has_frac_baudrate) {\r\ndiv = DIV_ROUND_CLOSEST(port->uartclk, baud * 2);\r\ncd = div >> 3;\r\nfp = div & ATMEL_US_FP_MASK;\r\n} else {\r\ncd = uart_get_divisor(port, baud);\r\n}\r\nif (cd > 65535) {\r\ncd /= 8;\r\nmode |= ATMEL_US_USCLKS_MCK_DIV8;\r\n}\r\nquot = cd | fp << ATMEL_US_FP_OFFSET;\r\natmel_uart_writel(port, ATMEL_US_BRGR, quot);\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA | ATMEL_US_RSTRX);\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXEN | ATMEL_US_RXEN);\r\natmel_uart_writel(port, ATMEL_US_IER, imr);\r\nif (UART_ENABLE_MS(port, termios->c_cflag))\r\natmel_enable_ms(port);\r\nelse\r\natmel_disable_ms(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void atmel_set_ldisc(struct uart_port *port, struct ktermios *termios)\r\n{\r\nif (termios->c_line == N_PPS) {\r\nport->flags |= UPF_HARDPPS_CD;\r\nspin_lock_irq(&port->lock);\r\natmel_enable_ms(port);\r\nspin_unlock_irq(&port->lock);\r\n} else {\r\nport->flags &= ~UPF_HARDPPS_CD;\r\nif (!UART_ENABLE_MS(port, termios->c_cflag)) {\r\nspin_lock_irq(&port->lock);\r\natmel_disable_ms(port);\r\nspin_unlock_irq(&port->lock);\r\n}\r\n}\r\n}\r\nstatic const char *atmel_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_ATMEL) ? "ATMEL_SERIAL" : NULL;\r\n}\r\nstatic void atmel_release_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nint size = pdev->resource[0].end - pdev->resource[0].start + 1;\r\nrelease_mem_region(port->mapbase, size);\r\nif (port->flags & UPF_IOREMAP) {\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\n}\r\nstatic int atmel_request_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nint size = pdev->resource[0].end - pdev->resource[0].start + 1;\r\nif (!request_mem_region(port->mapbase, size, "atmel_serial"))\r\nreturn -EBUSY;\r\nif (port->flags & UPF_IOREMAP) {\r\nport->membase = ioremap(port->mapbase, size);\r\nif (port->membase == NULL) {\r\nrelease_mem_region(port->mapbase, size);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void atmel_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = PORT_ATMEL;\r\natmel_request_port(port);\r\n}\r\n}\r\nstatic int atmel_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_ATMEL)\r\nret = -EINVAL;\r\nif (port->irq != ser->irq)\r\nret = -EINVAL;\r\nif (ser->io_type != SERIAL_IO_MEM)\r\nret = -EINVAL;\r\nif (port->uartclk / 16 != ser->baud_base)\r\nret = -EINVAL;\r\nif (port->mapbase != (unsigned long)ser->iomem_base)\r\nret = -EINVAL;\r\nif (port->iobase != ser->port)\r\nret = -EINVAL;\r\nif (ser->hub6 != 0)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int atmel_poll_get_char(struct uart_port *port)\r\n{\r\nwhile (!(atmel_uart_readl(port, ATMEL_US_CSR) & ATMEL_US_RXRDY))\r\ncpu_relax();\r\nreturn atmel_uart_read_char(port);\r\n}\r\nstatic void atmel_poll_put_char(struct uart_port *port, unsigned char ch)\r\n{\r\nwhile (!(atmel_uart_readl(port, ATMEL_US_CSR) & ATMEL_US_TXRDY))\r\ncpu_relax();\r\natmel_uart_write_char(port, ch);\r\n}\r\nstatic int atmel_init_port(struct atmel_uart_port *atmel_port,\r\nstruct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct uart_port *port = &atmel_port->uart;\r\natmel_init_property(atmel_port, pdev);\r\natmel_set_ops(port);\r\natmel_init_rs485(port, pdev);\r\nport->iotype = UPIO_MEM;\r\nport->flags = UPF_BOOT_AUTOCONF | UPF_IOREMAP;\r\nport->ops = &atmel_pops;\r\nport->fifosize = 1;\r\nport->dev = &pdev->dev;\r\nport->mapbase = pdev->resource[0].start;\r\nport->irq = pdev->resource[1].start;\r\nport->rs485_config = atmel_config_rs485;\r\nport->membase = NULL;\r\nmemset(&atmel_port->rx_ring, 0, sizeof(atmel_port->rx_ring));\r\nif (!atmel_port->clk) {\r\natmel_port->clk = clk_get(&pdev->dev, "usart");\r\nif (IS_ERR(atmel_port->clk)) {\r\nret = PTR_ERR(atmel_port->clk);\r\natmel_port->clk = NULL;\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(atmel_port->clk);\r\nif (ret) {\r\nclk_put(atmel_port->clk);\r\natmel_port->clk = NULL;\r\nreturn ret;\r\n}\r\nport->uartclk = clk_get_rate(atmel_port->clk);\r\nclk_disable_unprepare(atmel_port->clk);\r\n}\r\nif (port->rs485.flags & SER_RS485_ENABLED)\r\natmel_port->tx_done_mask = ATMEL_US_TXEMPTY;\r\nelse if (atmel_use_pdc_tx(port)) {\r\nport->fifosize = PDC_BUFFER_SIZE;\r\natmel_port->tx_done_mask = ATMEL_US_ENDTX | ATMEL_US_TXBUFE;\r\n} else {\r\natmel_port->tx_done_mask = ATMEL_US_TXRDY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void atmel_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (!(atmel_uart_readl(port, ATMEL_US_CSR) & ATMEL_US_TXRDY))\r\ncpu_relax();\r\natmel_uart_write_char(port, ch);\r\n}\r\nstatic void atmel_console_write(struct console *co, const char *s, u_int count)\r\n{\r\nstruct uart_port *port = &atmel_ports[co->index].uart;\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nunsigned int status, imr;\r\nunsigned int pdc_tx;\r\nimr = atmel_uart_readl(port, ATMEL_US_IMR);\r\natmel_uart_writel(port, ATMEL_US_IDR,\r\nATMEL_US_RXRDY | atmel_port->tx_done_mask);\r\npdc_tx = atmel_uart_readl(port, ATMEL_PDC_PTSR) & ATMEL_PDC_TXTEN;\r\natmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTDIS);\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXEN);\r\nuart_console_write(port, s, count, atmel_console_putchar);\r\ndo {\r\nstatus = atmel_uart_readl(port, ATMEL_US_CSR);\r\n} while (!(status & ATMEL_US_TXRDY));\r\nif (pdc_tx)\r\natmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTEN);\r\natmel_uart_writel(port, ATMEL_US_IER, imr);\r\n}\r\nstatic void __init atmel_console_get_options(struct uart_port *port, int *baud,\r\nint *parity, int *bits)\r\n{\r\nunsigned int mr, quot;\r\nquot = atmel_uart_readl(port, ATMEL_US_BRGR) & ATMEL_US_CD;\r\nif (!quot)\r\nreturn;\r\nmr = atmel_uart_readl(port, ATMEL_US_MR) & ATMEL_US_CHRL;\r\nif (mr == ATMEL_US_CHRL_8)\r\n*bits = 8;\r\nelse\r\n*bits = 7;\r\nmr = atmel_uart_readl(port, ATMEL_US_MR) & ATMEL_US_PAR;\r\nif (mr == ATMEL_US_PAR_EVEN)\r\n*parity = 'e';\r\nelse if (mr == ATMEL_US_PAR_ODD)\r\n*parity = 'o';\r\n*baud = port->uartclk / (16 * (quot - 1));\r\n}\r\nstatic int __init atmel_console_setup(struct console *co, char *options)\r\n{\r\nint ret;\r\nstruct uart_port *port = &atmel_ports[co->index].uart;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (port->membase == NULL) {\r\nreturn -ENODEV;\r\n}\r\nret = clk_prepare_enable(atmel_ports[co->index].clk);\r\nif (ret)\r\nreturn ret;\r\natmel_uart_writel(port, ATMEL_US_IDR, -1);\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_RSTSTA | ATMEL_US_RSTRX);\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXEN | ATMEL_US_RXEN);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\natmel_console_get_options(port, &baud, &parity, &bits);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic inline bool atmel_is_console_port(struct uart_port *port)\r\n{\r\nreturn port->cons && port->cons->index == port->line;\r\n}\r\nstatic inline bool atmel_is_console_port(struct uart_port *port)\r\n{\r\nreturn false;\r\n}\r\nstatic bool atmel_serial_clk_will_stop(void)\r\n{\r\n#ifdef CONFIG_ARCH_AT91\r\nreturn at91_suspend_entering_slow_clock();\r\n#else\r\nreturn false;\r\n#endif\r\n}\r\nstatic int atmel_serial_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (atmel_is_console_port(port) && console_suspend_enabled) {\r\nwhile (!(atmel_uart_readl(port, ATMEL_US_CSR) &\r\nATMEL_US_TXEMPTY))\r\ncpu_relax();\r\n}\r\nif (atmel_is_console_port(port) && !console_suspend_enabled) {\r\natmel_port->cache.mr = atmel_uart_readl(port, ATMEL_US_MR);\r\natmel_port->cache.imr = atmel_uart_readl(port, ATMEL_US_IMR);\r\natmel_port->cache.brgr = atmel_uart_readl(port, ATMEL_US_BRGR);\r\natmel_port->cache.rtor = atmel_uart_readl(port,\r\natmel_port->rtor);\r\natmel_port->cache.ttgr = atmel_uart_readl(port, ATMEL_US_TTGR);\r\natmel_port->cache.fmr = atmel_uart_readl(port, ATMEL_US_FMR);\r\natmel_port->cache.fimr = atmel_uart_readl(port, ATMEL_US_FIMR);\r\n}\r\natmel_port->may_wakeup = device_may_wakeup(&pdev->dev);\r\nif (atmel_serial_clk_will_stop()) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&atmel_port->lock_suspended, flags);\r\natmel_port->suspended = true;\r\nspin_unlock_irqrestore(&atmel_port->lock_suspended, flags);\r\ndevice_set_wakeup_enable(&pdev->dev, 0);\r\n}\r\nuart_suspend_port(&atmel_uart, port);\r\nreturn 0;\r\n}\r\nstatic int atmel_serial_resume(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nunsigned long flags;\r\nif (atmel_is_console_port(port) && !console_suspend_enabled) {\r\natmel_uart_writel(port, ATMEL_US_MR, atmel_port->cache.mr);\r\natmel_uart_writel(port, ATMEL_US_IER, atmel_port->cache.imr);\r\natmel_uart_writel(port, ATMEL_US_BRGR, atmel_port->cache.brgr);\r\natmel_uart_writel(port, atmel_port->rtor,\r\natmel_port->cache.rtor);\r\natmel_uart_writel(port, ATMEL_US_TTGR, atmel_port->cache.ttgr);\r\nif (atmel_port->fifo_size) {\r\natmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_FIFOEN |\r\nATMEL_US_RXFCLR | ATMEL_US_TXFLCLR);\r\natmel_uart_writel(port, ATMEL_US_FMR,\r\natmel_port->cache.fmr);\r\natmel_uart_writel(port, ATMEL_US_FIER,\r\natmel_port->cache.fimr);\r\n}\r\natmel_start_rx(port);\r\n}\r\nspin_lock_irqsave(&atmel_port->lock_suspended, flags);\r\nif (atmel_port->pending) {\r\natmel_handle_receive(port, atmel_port->pending);\r\natmel_handle_status(port, atmel_port->pending,\r\natmel_port->pending_status);\r\natmel_handle_transmit(port, atmel_port->pending);\r\natmel_port->pending = 0;\r\n}\r\natmel_port->suspended = false;\r\nspin_unlock_irqrestore(&atmel_port->lock_suspended, flags);\r\nuart_resume_port(&atmel_uart, port);\r\ndevice_set_wakeup_enable(&pdev->dev, atmel_port->may_wakeup);\r\nreturn 0;\r\n}\r\nstatic void atmel_serial_probe_fifos(struct atmel_uart_port *atmel_port,\r\nstruct platform_device *pdev)\r\n{\r\natmel_port->fifo_size = 0;\r\natmel_port->rts_low = 0;\r\natmel_port->rts_high = 0;\r\nif (of_property_read_u32(pdev->dev.of_node,\r\n"atmel,fifo-size",\r\n&atmel_port->fifo_size))\r\nreturn;\r\nif (!atmel_port->fifo_size)\r\nreturn;\r\nif (atmel_port->fifo_size < ATMEL_MIN_FIFO_SIZE) {\r\natmel_port->fifo_size = 0;\r\ndev_err(&pdev->dev, "Invalid FIFO size\n");\r\nreturn;\r\n}\r\natmel_port->rts_high = max_t(int, atmel_port->fifo_size >> 1,\r\natmel_port->fifo_size - ATMEL_RTS_HIGH_OFFSET);\r\natmel_port->rts_low = max_t(int, atmel_port->fifo_size >> 2,\r\natmel_port->fifo_size - ATMEL_RTS_LOW_OFFSET);\r\ndev_info(&pdev->dev, "Using FIFO (%u data)\n",\r\natmel_port->fifo_size);\r\ndev_dbg(&pdev->dev, "RTS High Threshold : %2u data\n",\r\natmel_port->rts_high);\r\ndev_dbg(&pdev->dev, "RTS Low Threshold : %2u data\n",\r\natmel_port->rts_low);\r\n}\r\nstatic int atmel_serial_probe(struct platform_device *pdev)\r\n{\r\nstruct atmel_uart_port *atmel_port;\r\nstruct device_node *np = pdev->dev.of_node;\r\nvoid *data;\r\nint ret = -ENODEV;\r\nbool rs485_enabled;\r\nBUILD_BUG_ON(ATMEL_SERIAL_RINGSIZE & (ATMEL_SERIAL_RINGSIZE - 1));\r\nret = of_alias_get_id(np, "serial");\r\nif (ret < 0)\r\nret = find_first_zero_bit(atmel_ports_in_use, ATMEL_MAX_UART);\r\nif (ret >= ATMEL_MAX_UART) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nif (test_and_set_bit(ret, atmel_ports_in_use)) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\natmel_port = &atmel_ports[ret];\r\natmel_port->backup_imr = 0;\r\natmel_port->uart.line = ret;\r\natmel_serial_probe_fifos(atmel_port, pdev);\r\natomic_set(&atmel_port->tasklet_shutdown, 0);\r\nspin_lock_init(&atmel_port->lock_suspended);\r\nret = atmel_init_port(atmel_port, pdev);\r\nif (ret)\r\ngoto err_clear_bit;\r\natmel_port->gpios = mctrl_gpio_init(&atmel_port->uart, 0);\r\nif (IS_ERR(atmel_port->gpios)) {\r\nret = PTR_ERR(atmel_port->gpios);\r\ngoto err_clear_bit;\r\n}\r\nif (!atmel_use_pdc_rx(&atmel_port->uart)) {\r\nret = -ENOMEM;\r\ndata = kmalloc(sizeof(struct atmel_uart_char)\r\n* ATMEL_SERIAL_RINGSIZE, GFP_KERNEL);\r\nif (!data)\r\ngoto err_alloc_ring;\r\natmel_port->rx_ring.buf = data;\r\n}\r\nrs485_enabled = atmel_port->uart.rs485.flags & SER_RS485_ENABLED;\r\nret = uart_add_one_port(&atmel_uart, &atmel_port->uart);\r\nif (ret)\r\ngoto err_add_port;\r\n#ifdef CONFIG_SERIAL_ATMEL_CONSOLE\r\nif (atmel_is_console_port(&atmel_port->uart)\r\n&& ATMEL_CONSOLE_DEVICE->flags & CON_ENABLED) {\r\nclk_disable_unprepare(atmel_port->clk);\r\n}\r\n#endif\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nplatform_set_drvdata(pdev, atmel_port);\r\nclk_prepare_enable(atmel_port->clk);\r\nif (rs485_enabled) {\r\natmel_uart_writel(&atmel_port->uart, ATMEL_US_MR,\r\nATMEL_US_USMODE_NORMAL);\r\natmel_uart_writel(&atmel_port->uart, ATMEL_US_CR,\r\nATMEL_US_RTSEN);\r\n}\r\natmel_get_ip_name(&atmel_port->uart);\r\nclk_disable_unprepare(atmel_port->clk);\r\nreturn 0;\r\nerr_add_port:\r\nkfree(atmel_port->rx_ring.buf);\r\natmel_port->rx_ring.buf = NULL;\r\nerr_alloc_ring:\r\nif (!atmel_is_console_port(&atmel_port->uart)) {\r\nclk_put(atmel_port->clk);\r\natmel_port->clk = NULL;\r\n}\r\nerr_clear_bit:\r\nclear_bit(atmel_port->uart.line, atmel_ports_in_use);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int atmel_serial_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nint ret = 0;\r\ntasklet_kill(&atmel_port->tasklet_rx);\r\ntasklet_kill(&atmel_port->tasklet_tx);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nret = uart_remove_one_port(&atmel_uart, port);\r\nkfree(atmel_port->rx_ring.buf);\r\nclear_bit(port->line, atmel_ports_in_use);\r\nclk_put(atmel_port->clk);\r\natmel_port->clk = NULL;\r\nreturn ret;\r\n}\r\nstatic int __init atmel_serial_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&atmel_uart);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&atmel_serial_driver);\r\nif (ret)\r\nuart_unregister_driver(&atmel_uart);\r\nreturn ret;\r\n}
