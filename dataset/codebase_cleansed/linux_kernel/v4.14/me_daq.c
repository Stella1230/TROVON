static inline void sleep(unsigned int sec)\r\n{\r\nschedule_timeout_interruptible(sec * HZ);\r\n}\r\nstatic int me_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct me_private_data *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int mask;\r\nint ret;\r\nif (chan < 16)\r\nmask = 0x0000ffff;\r\nelse\r\nmask = 0xffff0000;\r\nret = comedi_dio_insn_config(dev, s, insn, data, mask);\r\nif (ret)\r\nreturn ret;\r\nif (s->io_bits & 0x0000ffff)\r\ndevpriv->ctrl2 |= ME_CTRL2_PORT_A_ENA;\r\nelse\r\ndevpriv->ctrl2 &= ~ME_CTRL2_PORT_A_ENA;\r\nif (s->io_bits & 0xffff0000)\r\ndevpriv->ctrl2 |= ME_CTRL2_PORT_B_ENA;\r\nelse\r\ndevpriv->ctrl2 &= ~ME_CTRL2_PORT_B_ENA;\r\nwritew(devpriv->ctrl2, dev->mmio + ME_CTRL2_REG);\r\nreturn insn->n;\r\n}\r\nstatic int me_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nvoid __iomem *mmio_porta = dev->mmio + ME_DIO_PORT_A_REG;\r\nvoid __iomem *mmio_portb = dev->mmio + ME_DIO_PORT_B_REG;\r\nunsigned int mask;\r\nunsigned int val;\r\nmask = comedi_dio_update_state(s, data);\r\nif (mask) {\r\nif (mask & 0x0000ffff)\r\nwritew((s->state & 0xffff), mmio_porta);\r\nif (mask & 0xffff0000)\r\nwritew(((s->state >> 16) & 0xffff), mmio_portb);\r\n}\r\nif (s->io_bits & 0x0000ffff)\r\nval = s->state & 0xffff;\r\nelse\r\nval = readw(mmio_porta);\r\nif (s->io_bits & 0xffff0000)\r\nval |= (s->state & 0xffff0000);\r\nelse\r\nval |= (readw(mmio_portb) << 16);\r\ndata[1] = val;\r\nreturn insn->n;\r\n}\r\nstatic int me_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = readw(dev->mmio + ME_STATUS_REG);\r\nif ((status & ME_STATUS_ADFIFO_EMPTY) == 0)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int me_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct me_private_data *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int aref = CR_AREF(insn->chanspec);\r\nunsigned int val;\r\nint ret = 0;\r\nint i;\r\nif (aref & AREF_DIFF) {\r\nif (chan > 7 || comedi_range_is_unipolar(s, range))\r\nreturn -EINVAL;\r\n}\r\ndevpriv->ctrl2 &= ~(ME_CTRL2_ADFIFO_ENA | ME_CTRL2_CHANLIST_ENA);\r\nwritew(devpriv->ctrl2, dev->mmio + ME_CTRL2_REG);\r\nwritew(0x00, dev->mmio + ME_STATUS_REG);\r\ndevpriv->ctrl2 |= (ME_CTRL2_ADFIFO_ENA | ME_CTRL2_CHANLIST_ENA);\r\nwritew(devpriv->ctrl2, dev->mmio + ME_CTRL2_REG);\r\nval = ME_AI_FIFO_CHANLIST_CHAN(chan) | ME_AI_FIFO_CHANLIST_GAIN(range);\r\nif (comedi_range_is_unipolar(s, range))\r\nval |= ME_AI_FIFO_CHANLIST_UNIPOLAR;\r\nif (aref & AREF_DIFF)\r\nval |= ME_AI_FIFO_CHANLIST_DIFF;\r\nwritew(val, dev->mmio + ME_AI_FIFO_REG);\r\ndevpriv->ctrl1 |= ME_CTRL1_ADC_MODE_SOFT_TRIG;\r\nwritew(devpriv->ctrl1, dev->mmio + ME_CTRL1_REG);\r\nfor (i = 0; i < insn->n; i++) {\r\nreadw(dev->mmio + ME_CTRL1_REG);\r\nret = comedi_timeout(dev, s, insn, me_ai_eoc, 0);\r\nif (ret)\r\nbreak;\r\nval = readw(dev->mmio + ME_AI_FIFO_REG) & s->maxdata;\r\ndata[i] = comedi_offset_munge(s, val);\r\n}\r\ndevpriv->ctrl1 &= ~ME_CTRL1_ADC_MODE_MASK;\r\nwritew(devpriv->ctrl1, dev->mmio + ME_CTRL1_REG);\r\nreturn ret ? ret : insn->n;\r\n}\r\nstatic int me_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct me_private_data *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int val = s->readback[chan];\r\nint i;\r\ndevpriv->ctrl2 |= ME_CTRL2_DAC_ENA;\r\nwritew(devpriv->ctrl2, dev->mmio + ME_CTRL2_REG);\r\ndevpriv->ctrl2 |= ME_CTRL2_BUFFERED_DAC;\r\nwritew(devpriv->ctrl2, dev->mmio + ME_CTRL2_REG);\r\ndevpriv->dac_ctrl &= ~ME_DAC_CTRL_MASK(chan);\r\nif (range == 0)\r\ndevpriv->dac_ctrl |= ME_DAC_CTRL_GAIN(chan);\r\nif (comedi_range_is_bipolar(s, range))\r\ndevpriv->dac_ctrl |= ME_DAC_CTRL_BIPOLAR(chan);\r\nwritew(devpriv->dac_ctrl, dev->mmio + ME_DAC_CTRL_REG);\r\nreadw(dev->mmio + ME_DAC_CTRL_REG);\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\nwritew(val, dev->mmio + ME_AO_DATA_REG(chan));\r\n}\r\ns->readback[chan] = val;\r\nreadw(dev->mmio + ME_CTRL2_REG);\r\nreturn insn->n;\r\n}\r\nstatic int me2600_xilinx_download(struct comedi_device *dev,\r\nconst u8 *data, size_t size,\r\nunsigned long context)\r\n{\r\nstruct me_private_data *devpriv = dev->private;\r\nunsigned int value;\r\nunsigned int file_length;\r\nunsigned int i;\r\nwritel(0x00, devpriv->plx_regbase + PLX9052_INTCSR);\r\nvalue = readw(dev->mmio + XILINX_DOWNLOAD_RESET);\r\nsleep(1);\r\nwriteb(0x00, dev->mmio + 0x0);\r\nsleep(1);\r\nif (size < 16)\r\nreturn -EINVAL;\r\nfile_length = (((unsigned int)data[0] & 0xff) << 24) +\r\n(((unsigned int)data[1] & 0xff) << 16) +\r\n(((unsigned int)data[2] & 0xff) << 8) +\r\n((unsigned int)data[3] & 0xff);\r\nfor (i = 0; i < file_length; i++)\r\nwriteb((data[16 + i] & 0xff), dev->mmio + 0x0);\r\nfor (i = 0; i < 5; i++)\r\nwriteb(0x00, dev->mmio + 0x0);\r\nvalue = readl(devpriv->plx_regbase + PLX9052_INTCSR);\r\nif (value & PLX9052_INTCSR_LI2STAT) {\r\nwritel(0x00, devpriv->plx_regbase + PLX9052_INTCSR);\r\ndev_err(dev->class_dev, "Xilinx download failed\n");\r\nreturn -EIO;\r\n}\r\nsleep(1);\r\nwritel(PLX9052_INTCSR_LI1ENAB |\r\nPLX9052_INTCSR_LI1POL |\r\nPLX9052_INTCSR_PCIENAB,\r\ndevpriv->plx_regbase + PLX9052_INTCSR);\r\nreturn 0;\r\n}\r\nstatic int me_reset(struct comedi_device *dev)\r\n{\r\nstruct me_private_data *devpriv = dev->private;\r\nwritew(0x00, dev->mmio + ME_CTRL1_REG);\r\nwritew(0x00, dev->mmio + ME_CTRL2_REG);\r\nwritew(0x00, dev->mmio + ME_STATUS_REG);\r\nwritew(0x00, dev->mmio + ME_DAC_CTRL_REG);\r\ndevpriv->dac_ctrl = 0;\r\ndevpriv->ctrl1 = 0;\r\ndevpriv->ctrl2 = 0;\r\nreturn 0;\r\n}\r\nstatic int me_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct me_board *board = NULL;\r\nstruct me_private_data *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nif (context < ARRAY_SIZE(me_boards))\r\nboard = &me_boards[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\ndevpriv->plx_regbase = pci_ioremap_bar(pcidev, 0);\r\nif (!devpriv->plx_regbase)\r\nreturn -ENOMEM;\r\ndev->mmio = pci_ioremap_bar(pcidev, 2);\r\nif (!dev->mmio)\r\nreturn -ENOMEM;\r\nif (board->needs_firmware) {\r\nret = comedi_load_firmware(dev, &comedi_to_pci_dev(dev)->dev,\r\nME2600_FIRMWARE,\r\nme2600_xilinx_download, 0);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nme_reset(dev);\r\nret = comedi_alloc_subdevices(dev, 3);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_DIFF;\r\ns->n_chan = 16;\r\ns->maxdata = 0x0fff;\r\ns->len_chanlist = 16;\r\ns->range_table = &me_ai_range;\r\ns->insn_read = me_ai_insn_read;\r\ns = &dev->subdevices[1];\r\nif (board->has_ao) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_COMMON;\r\ns->n_chan = 4;\r\ns->maxdata = 0x0fff;\r\ns->len_chanlist = 4;\r\ns->range_table = &me_ao_range;\r\ns->insn_write = me_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 32;\r\ns->maxdata = 1;\r\ns->len_chanlist = 32;\r\ns->range_table = &range_digital;\r\ns->insn_bits = me_dio_insn_bits;\r\ns->insn_config = me_dio_insn_config;\r\nreturn 0;\r\n}\r\nstatic void me_detach(struct comedi_device *dev)\r\n{\r\nstruct me_private_data *devpriv = dev->private;\r\nif (devpriv) {\r\nif (dev->mmio)\r\nme_reset(dev);\r\nif (devpriv->plx_regbase)\r\niounmap(devpriv->plx_regbase);\r\n}\r\ncomedi_pci_detach(dev);\r\n}\r\nstatic int me_daq_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &me_daq_driver, id->driver_data);\r\n}
