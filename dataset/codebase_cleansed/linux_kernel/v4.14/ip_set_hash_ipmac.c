static inline bool\r\nhash_ipmac4_data_equal(const struct hash_ipmac4_elem *e1,\r\nconst struct hash_ipmac4_elem *e2,\r\nu32 *multi)\r\n{\r\nreturn e1->ip == e2->ip && ether_addr_equal(e1->ether, e2->ether);\r\n}\r\nstatic bool\r\nhash_ipmac4_data_list(struct sk_buff *skb, const struct hash_ipmac4_elem *e)\r\n{\r\nif (nla_put_ipaddr4(skb, IPSET_ATTR_IP, e->ip) ||\r\nnla_put(skb, IPSET_ATTR_ETHER, ETH_ALEN, e->ether))\r\ngoto nla_put_failure;\r\nreturn false;\r\nnla_put_failure:\r\nreturn true;\r\n}\r\nstatic inline void\r\nhash_ipmac4_data_next(struct hash_ipmac4_elem *next,\r\nconst struct hash_ipmac4_elem *e)\r\n{\r\nnext->ip = e->ip;\r\n}\r\nstatic int\r\nhash_ipmac4_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, struct ip_set_adt_opt *opt)\r\n{\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_ipmac4_elem e = { .ip = 0, { .foo[0] = 0, .foo[1] = 0 } };\r\nstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\r\nif (!(opt->flags & IPSET_DIM_TWO_SRC))\r\nreturn 0;\r\nif (skb_mac_header(skb) < skb->head ||\r\n(skb_mac_header(skb) + ETH_HLEN) > skb->data)\r\nreturn -EINVAL;\r\nmemcpy(e.ether, eth_hdr(skb)->h_source, ETH_ALEN);\r\nif (ether_addr_equal(e.ether, invalid_ether))\r\nreturn -EINVAL;\r\nip4addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip);\r\nreturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\r\n}\r\nstatic int\r\nhash_ipmac4_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_ipmac4_elem e = { .ip = 0, { .foo[0] = 0, .foo[1] = 0 } };\r\nstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\r\nint ret;\r\nif (unlikely(!tb[IPSET_ATTR_IP] ||\r\n!tb[IPSET_ATTR_ETHER] ||\r\nnla_len(tb[IPSET_ATTR_ETHER]) != ETH_ALEN ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_PACKETS) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_BYTES) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_SKBMARK) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_SKBPRIO) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_SKBQUEUE)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nret = ip_set_get_ipaddr4(tb[IPSET_ATTR_IP], &e.ip) ||\r\nip_set_get_extensions(set, tb, &ext);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(e.ether, nla_data(tb[IPSET_ATTR_ETHER]), ETH_ALEN);\r\nif (ether_addr_equal(e.ether, invalid_ether))\r\nreturn -IPSET_ERR_HASH_ELEM;\r\nreturn adtfn(set, &e, &ext, &ext, flags);\r\n}\r\nstatic inline bool\r\nhash_ipmac6_data_equal(const struct hash_ipmac6_elem *e1,\r\nconst struct hash_ipmac6_elem *e2,\r\nu32 *multi)\r\n{\r\nreturn ipv6_addr_equal(&e1->ip.in6, &e2->ip.in6) &&\r\nether_addr_equal(e1->ether, e2->ether);\r\n}\r\nstatic bool\r\nhash_ipmac6_data_list(struct sk_buff *skb, const struct hash_ipmac6_elem *e)\r\n{\r\nif (nla_put_ipaddr6(skb, IPSET_ATTR_IP, &e->ip.in6) ||\r\nnla_put(skb, IPSET_ATTR_ETHER, ETH_ALEN, e->ether))\r\ngoto nla_put_failure;\r\nreturn false;\r\nnla_put_failure:\r\nreturn true;\r\n}\r\nstatic inline void\r\nhash_ipmac6_data_next(struct hash_ipmac6_elem *next,\r\nconst struct hash_ipmac6_elem *e)\r\n{\r\n}\r\nstatic int\r\nhash_ipmac6_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, struct ip_set_adt_opt *opt)\r\n{\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_ipmac6_elem e = {\r\n{ .all = { 0 } },\r\n{ .foo[0] = 0, .foo[1] = 0 }\r\n};\r\nstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\r\nif (!(opt->flags & IPSET_DIM_TWO_SRC))\r\nreturn 0;\r\nif (skb_mac_header(skb) < skb->head ||\r\n(skb_mac_header(skb) + ETH_HLEN) > skb->data)\r\nreturn -EINVAL;\r\nmemcpy(e.ether, eth_hdr(skb)->h_source, ETH_ALEN);\r\nif (ether_addr_equal(e.ether, invalid_ether))\r\nreturn -EINVAL;\r\nip6addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip.in6);\r\nreturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\r\n}\r\nstatic int\r\nhash_ipmac6_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_ipmac6_elem e = {\r\n{ .all = { 0 } },\r\n{ .foo[0] = 0, .foo[1] = 0 }\r\n};\r\nstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\r\nint ret;\r\nif (unlikely(!tb[IPSET_ATTR_IP] ||\r\n!tb[IPSET_ATTR_ETHER] ||\r\nnla_len(tb[IPSET_ATTR_ETHER]) != ETH_ALEN ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_PACKETS) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_BYTES) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_SKBMARK) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_SKBPRIO) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_SKBQUEUE)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nret = ip_set_get_ipaddr6(tb[IPSET_ATTR_IP], &e.ip) ||\r\nip_set_get_extensions(set, tb, &ext);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(e.ether, nla_data(tb[IPSET_ATTR_ETHER]), ETH_ALEN);\r\nif (ether_addr_equal(e.ether, invalid_ether))\r\nreturn -IPSET_ERR_HASH_ELEM;\r\nreturn adtfn(set, &e, &ext, &ext, flags);\r\n}\r\nstatic int __init\r\nhash_ipmac_init(void)\r\n{\r\nreturn ip_set_type_register(&hash_ipmac_type);\r\n}\r\nstatic void __exit\r\nhash_ipmac_fini(void)\r\n{\r\nip_set_type_unregister(&hash_ipmac_type);\r\n}
