const struct vimc_pix_map *vimc_pix_map_by_index(unsigned int i)\r\n{\r\nif (i >= ARRAY_SIZE(vimc_pix_map_list))\r\nreturn NULL;\r\nreturn &vimc_pix_map_list[i];\r\n}\r\nconst struct vimc_pix_map *vimc_pix_map_by_code(u32 code)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(vimc_pix_map_list); i++) {\r\nif (vimc_pix_map_list[i].code == code)\r\nreturn &vimc_pix_map_list[i];\r\n}\r\nreturn NULL;\r\n}\r\nconst struct vimc_pix_map *vimc_pix_map_by_pixelformat(u32 pixelformat)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(vimc_pix_map_list); i++) {\r\nif (vimc_pix_map_list[i].pixelformat == pixelformat)\r\nreturn &vimc_pix_map_list[i];\r\n}\r\nreturn NULL;\r\n}\r\nint vimc_propagate_frame(struct media_pad *src, const void *frame)\r\n{\r\nstruct media_link *link;\r\nif (!(src->flags & MEDIA_PAD_FL_SOURCE))\r\nreturn -EINVAL;\r\nlist_for_each_entry(link, &src->entity->links, list) {\r\nif (link->source == src &&\r\n(link->flags & MEDIA_LNK_FL_ENABLED)) {\r\nstruct vimc_ent_device *ved = NULL;\r\nstruct media_entity *entity = link->sink->entity;\r\nif (is_media_entity_v4l2_subdev(entity)) {\r\nstruct v4l2_subdev *sd =\r\ncontainer_of(entity, struct v4l2_subdev,\r\nentity);\r\nved = v4l2_get_subdevdata(sd);\r\n} else if (is_media_entity_v4l2_video_device(entity)) {\r\nstruct video_device *vdev =\r\ncontainer_of(entity,\r\nstruct video_device,\r\nentity);\r\nved = video_get_drvdata(vdev);\r\n}\r\nif (ved && ved->process_frame)\r\nved->process_frame(ved, link->sink, frame);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstruct media_pad *vimc_pads_init(u16 num_pads, const unsigned long *pads_flag)\r\n{\r\nstruct media_pad *pads;\r\nunsigned int i;\r\npads = kcalloc(num_pads, sizeof(*pads), GFP_KERNEL);\r\nif (!pads)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < num_pads; i++) {\r\npads[i].index = i;\r\npads[i].flags = pads_flag[i];\r\n}\r\nreturn pads;\r\n}\r\nint vimc_pipeline_s_stream(struct media_entity *ent, int enable)\r\n{\r\nstruct v4l2_subdev *sd;\r\nstruct media_pad *pad;\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < ent->num_pads; i++) {\r\nif (ent->pads[i].flags & MEDIA_PAD_FL_SOURCE)\r\ncontinue;\r\npad = media_entity_remote_pad(&ent->pads[i]);\r\nif (!is_media_entity_v4l2_subdev(pad->entity))\r\nreturn -EINVAL;\r\nsd = media_entity_to_v4l2_subdev(pad->entity);\r\nret = v4l2_subdev_call(sd, video, s_stream, enable);\r\nif (ret && ret != -ENOIOCTLCMD)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vimc_get_mbus_format(struct media_pad *pad,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nif (is_media_entity_v4l2_subdev(pad->entity)) {\r\nstruct v4l2_subdev *sd =\r\nmedia_entity_to_v4l2_subdev(pad->entity);\r\nint ret;\r\nfmt->which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nfmt->pad = pad->index;\r\nret = v4l2_subdev_call(sd, pad, get_fmt, NULL, fmt);\r\nif (ret)\r\nreturn ret;\r\n} else if (is_media_entity_v4l2_video_device(pad->entity)) {\r\nstruct video_device *vdev = container_of(pad->entity,\r\nstruct video_device,\r\nentity);\r\nstruct vimc_ent_device *ved = video_get_drvdata(vdev);\r\nconst struct vimc_pix_map *vpix;\r\nstruct v4l2_pix_format vdev_fmt;\r\nif (!ved->vdev_get_format)\r\nreturn -ENOIOCTLCMD;\r\nved->vdev_get_format(ved, &vdev_fmt);\r\nvpix = vimc_pix_map_by_pixelformat(vdev_fmt.pixelformat);\r\nv4l2_fill_mbus_format(&fmt->format, &vdev_fmt, vpix->code);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint vimc_link_validate(struct media_link *link)\r\n{\r\nstruct v4l2_subdev_format source_fmt, sink_fmt;\r\nint ret;\r\nret = vimc_get_mbus_format(link->source, &source_fmt);\r\nif (ret)\r\nreturn ret;\r\nret = vimc_get_mbus_format(link->sink, &sink_fmt);\r\nif (ret)\r\nreturn ret;\r\npr_info("vimc link validate: "\r\n"%s:src:%dx%d (0x%x, %d, %d, %d, %d) "\r\n"%s:snk:%dx%d (0x%x, %d, %d, %d, %d)\n",\r\nlink->source->entity->name,\r\nsource_fmt.format.width, source_fmt.format.height,\r\nsource_fmt.format.code, source_fmt.format.colorspace,\r\nsource_fmt.format.quantization, source_fmt.format.xfer_func,\r\nsource_fmt.format.ycbcr_enc,\r\nlink->sink->entity->name,\r\nsink_fmt.format.width, sink_fmt.format.height,\r\nsink_fmt.format.code, sink_fmt.format.colorspace,\r\nsink_fmt.format.quantization, sink_fmt.format.xfer_func,\r\nsink_fmt.format.ycbcr_enc);\r\nif (source_fmt.format.width != sink_fmt.format.width\r\n|| source_fmt.format.height != sink_fmt.format.height\r\n|| source_fmt.format.code != sink_fmt.format.code)\r\nreturn -EPIPE;\r\nif (source_fmt.format.field != sink_fmt.format.field &&\r\nsink_fmt.format.field != V4L2_FIELD_NONE)\r\nreturn -EPIPE;\r\nif (source_fmt.format.colorspace == V4L2_COLORSPACE_DEFAULT\r\n|| sink_fmt.format.colorspace == V4L2_COLORSPACE_DEFAULT)\r\nreturn 0;\r\nif (source_fmt.format.colorspace != sink_fmt.format.colorspace)\r\nreturn -EPIPE;\r\nif (source_fmt.format.ycbcr_enc != V4L2_YCBCR_ENC_DEFAULT\r\n&& sink_fmt.format.ycbcr_enc != V4L2_YCBCR_ENC_DEFAULT\r\n&& source_fmt.format.ycbcr_enc != sink_fmt.format.ycbcr_enc)\r\nreturn -EPIPE;\r\nif (source_fmt.format.quantization != V4L2_QUANTIZATION_DEFAULT\r\n&& sink_fmt.format.quantization != V4L2_QUANTIZATION_DEFAULT\r\n&& source_fmt.format.quantization != sink_fmt.format.quantization)\r\nreturn -EPIPE;\r\nif (source_fmt.format.xfer_func != V4L2_XFER_FUNC_DEFAULT\r\n&& sink_fmt.format.xfer_func != V4L2_XFER_FUNC_DEFAULT\r\n&& source_fmt.format.xfer_func != sink_fmt.format.xfer_func)\r\nreturn -EPIPE;\r\nreturn 0;\r\n}\r\nint vimc_ent_sd_register(struct vimc_ent_device *ved,\r\nstruct v4l2_subdev *sd,\r\nstruct v4l2_device *v4l2_dev,\r\nconst char *const name,\r\nu32 function,\r\nu16 num_pads,\r\nconst unsigned long *pads_flag,\r\nconst struct v4l2_subdev_ops *sd_ops)\r\n{\r\nint ret;\r\nved->pads = vimc_pads_init(num_pads, pads_flag);\r\nif (IS_ERR(ved->pads))\r\nreturn PTR_ERR(ved->pads);\r\nved->ent = &sd->entity;\r\nv4l2_subdev_init(sd, sd_ops);\r\nsd->entity.function = function;\r\nsd->entity.ops = &vimc_ent_sd_mops;\r\nsd->owner = THIS_MODULE;\r\nstrlcpy(sd->name, name, sizeof(sd->name));\r\nv4l2_set_subdevdata(sd, ved);\r\nsd->flags = V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nret = media_entity_pads_init(&sd->entity, num_pads, ved->pads);\r\nif (ret)\r\ngoto err_clean_pads;\r\nret = v4l2_device_register_subdev(v4l2_dev, sd);\r\nif (ret) {\r\ndev_err(v4l2_dev->dev,\r\n"%s: subdev register failed (err=%d)\n",\r\nname, ret);\r\ngoto err_clean_m_ent;\r\n}\r\nreturn 0;\r\nerr_clean_m_ent:\r\nmedia_entity_cleanup(&sd->entity);\r\nerr_clean_pads:\r\nvimc_pads_cleanup(ved->pads);\r\nreturn ret;\r\n}\r\nvoid vimc_ent_sd_unregister(struct vimc_ent_device *ved, struct v4l2_subdev *sd)\r\n{\r\nv4l2_device_unregister_subdev(sd);\r\nmedia_entity_cleanup(ved->ent);\r\nvimc_pads_cleanup(ved->pads);\r\n}
