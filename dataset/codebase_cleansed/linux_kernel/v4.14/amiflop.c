static irqreturn_t ms_isr(int irq, void *dummy)\r\n{\r\ncomplete(&ms_wait_completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ms_delay(int ms)\r\n{\r\nint ticks;\r\nstatic DEFINE_MUTEX(mutex);\r\nif (ms > 0) {\r\nmutex_lock(&mutex);\r\nticks = MS_TICKS*ms-1;\r\nciaa.tblo=ticks%256;\r\nciaa.tbhi=ticks/256;\r\nciaa.crb=0x19;\r\nwait_for_completion(&ms_wait_completion);\r\nmutex_unlock(&mutex);\r\n}\r\n}\r\nstatic inline int try_fdc(int drive)\r\n{\r\ndrive &= 3;\r\nreturn ((fdc_busy < 0) || (fdc_busy == drive));\r\n}\r\nstatic void get_fdc(int drive)\r\n{\r\nunsigned long flags;\r\ndrive &= 3;\r\n#ifdef DEBUG\r\nprintk("get_fdc: drive %d fdc_busy %d fdc_nested %d\n",drive,fdc_busy,fdc_nested);\r\n#endif\r\nlocal_irq_save(flags);\r\nwait_event(fdc_wait, try_fdc(drive));\r\nfdc_busy = drive;\r\nfdc_nested++;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline void rel_fdc(void)\r\n{\r\n#ifdef DEBUG\r\nif (fdc_nested == 0)\r\nprintk("fd: unmatched rel_fdc\n");\r\nprintk("rel_fdc: fdc_busy %d fdc_nested %d\n",fdc_busy,fdc_nested);\r\n#endif\r\nfdc_nested--;\r\nif (fdc_nested == 0) {\r\nfdc_busy = -1;\r\nwake_up(&fdc_wait);\r\n}\r\n}\r\nstatic void fd_select (int drive)\r\n{\r\nunsigned char prb = ~0;\r\ndrive&=3;\r\n#ifdef DEBUG\r\nprintk("selecting %d\n",drive);\r\n#endif\r\nif (drive == selected)\r\nreturn;\r\nget_fdc(drive);\r\nselected = drive;\r\nif (unit[drive].track % 2 != 0)\r\nprb &= ~DSKSIDE;\r\nif (unit[drive].motor == 1)\r\nprb &= ~DSKMOTOR;\r\nciab.prb |= (SELMASK(0)|SELMASK(1)|SELMASK(2)|SELMASK(3));\r\nciab.prb = prb;\r\nprb &= ~SELMASK(drive);\r\nciab.prb = prb;\r\nrel_fdc();\r\n}\r\nstatic void fd_deselect (int drive)\r\n{\r\nunsigned char prb;\r\nunsigned long flags;\r\ndrive&=3;\r\n#ifdef DEBUG\r\nprintk("deselecting %d\n",drive);\r\n#endif\r\nif (drive != selected) {\r\nprintk(KERN_WARNING "Deselecting drive %d while %d was selected!\n",drive,selected);\r\nreturn;\r\n}\r\nget_fdc(drive);\r\nlocal_irq_save(flags);\r\nselected = -1;\r\nprb = ciab.prb;\r\nprb |= (SELMASK(0)|SELMASK(1)|SELMASK(2)|SELMASK(3));\r\nciab.prb = prb;\r\nlocal_irq_restore (flags);\r\nrel_fdc();\r\n}\r\nstatic void motor_on_callback(unsigned long nr)\r\n{\r\nif (!(ciaa.pra & DSKRDY) || --on_attempts == 0) {\r\ncomplete_all(&motor_on_completion);\r\n} else {\r\nmotor_on_timer.expires = jiffies + HZ/10;\r\nadd_timer(&motor_on_timer);\r\n}\r\n}\r\nstatic int fd_motor_on(int nr)\r\n{\r\nnr &= 3;\r\ndel_timer(motor_off_timer + nr);\r\nif (!unit[nr].motor) {\r\nunit[nr].motor = 1;\r\nfd_select(nr);\r\nreinit_completion(&motor_on_completion);\r\nmotor_on_timer.data = nr;\r\nmod_timer(&motor_on_timer, jiffies + HZ/2);\r\non_attempts = 10;\r\nwait_for_completion(&motor_on_completion);\r\nfd_deselect(nr);\r\n}\r\nif (on_attempts == 0) {\r\non_attempts = -1;\r\n#if 0\r\nprintk (KERN_ERR "motor_on failed, turning motor off\n");\r\nfd_motor_off (nr);\r\nreturn 0;\r\n#else\r\nprintk (KERN_WARNING "DSKRDY not set after 1.5 seconds - assuming drive is spinning notwithstanding\n");\r\n#endif\r\n}\r\nreturn 1;\r\n}\r\nstatic void fd_motor_off(unsigned long drive)\r\n{\r\nlong calledfromint;\r\n#ifdef MODULE\r\nlong decusecount;\r\ndecusecount = drive & 0x40000000;\r\n#endif\r\ncalledfromint = drive & 0x80000000;\r\ndrive&=3;\r\nif (calledfromint && !try_fdc(drive)) {\r\nmotor_off_timer[drive].expires = jiffies + 1;\r\nadd_timer(motor_off_timer + drive);\r\nreturn;\r\n}\r\nunit[drive].motor = 0;\r\nfd_select(drive);\r\nudelay (1);\r\nfd_deselect(drive);\r\n}\r\nstatic void floppy_off (unsigned int nr)\r\n{\r\nint drive;\r\ndrive = nr & 3;\r\nmotor_off_timer[drive].data = nr | 0x80000000;\r\nmod_timer(motor_off_timer + drive, jiffies + 3*HZ);\r\n}\r\nstatic int fd_calibrate(int drive)\r\n{\r\nunsigned char prb;\r\nint n;\r\ndrive &= 3;\r\nget_fdc(drive);\r\nif (!fd_motor_on (drive))\r\nreturn 0;\r\nfd_select (drive);\r\nprb = ciab.prb;\r\nprb |= DSKSIDE;\r\nprb &= ~DSKDIREC;\r\nciab.prb = prb;\r\nfor (n = unit[drive].type->tracks/2; n != 0; --n) {\r\nif (ciaa.pra & DSKTRACK0)\r\nbreak;\r\nprb &= ~DSKSTEP;\r\nciab.prb = prb;\r\nprb |= DSKSTEP;\r\nudelay (2);\r\nciab.prb = prb;\r\nms_delay(unit[drive].type->step_delay);\r\n}\r\nms_delay (unit[drive].type->settle_time);\r\nprb |= DSKDIREC;\r\nn = unit[drive].type->tracks + 20;\r\nfor (;;) {\r\nprb &= ~DSKSTEP;\r\nciab.prb = prb;\r\nprb |= DSKSTEP;\r\nudelay (2);\r\nciab.prb = prb;\r\nms_delay(unit[drive].type->step_delay + 1);\r\nif ((ciaa.pra & DSKTRACK0) == 0)\r\nbreak;\r\nif (--n == 0) {\r\nprintk (KERN_ERR "fd%d: calibrate failed, turning motor off\n", drive);\r\nfd_motor_off (drive);\r\nunit[drive].track = -1;\r\nrel_fdc();\r\nreturn 0;\r\n}\r\n}\r\nunit[drive].track = 0;\r\nms_delay(unit[drive].type->settle_time);\r\nrel_fdc();\r\nfd_deselect(drive);\r\nreturn 1;\r\n}\r\nstatic int fd_seek(int drive, int track)\r\n{\r\nunsigned char prb;\r\nint cnt;\r\n#ifdef DEBUG\r\nprintk("seeking drive %d to track %d\n",drive,track);\r\n#endif\r\ndrive &= 3;\r\nget_fdc(drive);\r\nif (unit[drive].track == track) {\r\nrel_fdc();\r\nreturn 1;\r\n}\r\nif (!fd_motor_on(drive)) {\r\nrel_fdc();\r\nreturn 0;\r\n}\r\nif (unit[drive].track < 0 && !fd_calibrate(drive)) {\r\nrel_fdc();\r\nreturn 0;\r\n}\r\nfd_select (drive);\r\ncnt = unit[drive].track/2 - track/2;\r\nprb = ciab.prb;\r\nprb |= DSKSIDE | DSKDIREC;\r\nif (track % 2 != 0)\r\nprb &= ~DSKSIDE;\r\nif (cnt < 0) {\r\ncnt = - cnt;\r\nprb &= ~DSKDIREC;\r\n}\r\nciab.prb = prb;\r\nif (track % 2 != unit[drive].track % 2)\r\nms_delay (unit[drive].type->side_time);\r\nunit[drive].track = track;\r\nif (cnt == 0) {\r\nrel_fdc();\r\nfd_deselect(drive);\r\nreturn 1;\r\n}\r\ndo {\r\nprb &= ~DSKSTEP;\r\nciab.prb = prb;\r\nprb |= DSKSTEP;\r\nudelay (1);\r\nciab.prb = prb;\r\nms_delay (unit[drive].type->step_delay);\r\n} while (--cnt != 0);\r\nms_delay (unit[drive].type->settle_time);\r\nrel_fdc();\r\nfd_deselect(drive);\r\nreturn 1;\r\n}\r\nstatic unsigned long fd_get_drive_id(int drive)\r\n{\r\nint i;\r\nulong id = 0;\r\ndrive&=3;\r\nget_fdc(drive);\r\nMOTOR_ON;\r\nudelay(2);\r\nSELECT(SELMASK(drive));\r\nudelay(2);\r\nDESELECT(SELMASK(drive));\r\nudelay(2);\r\nMOTOR_OFF;\r\nudelay(2);\r\nSELECT(SELMASK(drive));\r\nudelay(2);\r\nDESELECT(SELMASK(drive));\r\nudelay(2);\r\nfor (i=0; i<32; i++) {\r\nSELECT(SELMASK(drive));\r\nudelay(2);\r\nid <<= 1;\r\nid |= (ciaa.pra & DSKRDY) ? 0 : 1;\r\nDESELECT(SELMASK(drive));\r\n}\r\nrel_fdc();\r\nif(drive == 0 && id == FD_NODRIVE)\r\n{\r\nid = fd_def_df0;\r\nprintk(KERN_NOTICE "fd: drive 0 didn't identify, setting default %08lx\n", (ulong)fd_def_df0);\r\n}\r\nreturn (id);\r\n}\r\nstatic irqreturn_t fd_block_done(int irq, void *dummy)\r\n{\r\nif (block_flag)\r\ncustom.dsklen = 0x4000;\r\nif (block_flag == 2) {\r\nwritepending = 2;\r\npost_write_timer.expires = jiffies + 1;\r\npost_write_timer.data = selected;\r\nadd_timer(&post_write_timer);\r\n}\r\nelse {\r\nblock_flag = 0;\r\nwake_up (&wait_fd_block);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void raw_read(int drive)\r\n{\r\ndrive&=3;\r\nget_fdc(drive);\r\nwait_event(wait_fd_block, !block_flag);\r\nfd_select(drive);\r\ncustom.adkcon = ADK_MSBSYNC;\r\ncustom.adkcon = ADK_SETCLR|ADK_WORDSYNC|ADK_FAST;\r\ncustom.dsksync = MFM_SYNC;\r\ncustom.dsklen = 0;\r\ncustom.dskptr = (u_char *)ZTWO_PADDR((u_char *)raw_buf);\r\ncustom.dsklen = unit[drive].type->read_size/sizeof(short) | DSKLEN_DMAEN;\r\ncustom.dsklen = unit[drive].type->read_size/sizeof(short) | DSKLEN_DMAEN;\r\nblock_flag = 1;\r\nwait_event(wait_fd_block, !block_flag);\r\ncustom.dsklen = 0;\r\nfd_deselect(drive);\r\nrel_fdc();\r\n}\r\nstatic int raw_write(int drive)\r\n{\r\nushort adk;\r\ndrive&=3;\r\nget_fdc(drive);\r\nif ((ciaa.pra & DSKPROT) == 0) {\r\nrel_fdc();\r\nreturn 0;\r\n}\r\nwait_event(wait_fd_block, !block_flag);\r\nfd_select(drive);\r\ncustom.adkcon = ADK_PRECOMP1|ADK_PRECOMP0|ADK_WORDSYNC|ADK_MSBSYNC;\r\nadk = ADK_SETCLR|ADK_FAST;\r\nif ((ulong)unit[drive].track >= unit[drive].type->precomp2)\r\nadk |= ADK_PRECOMP1;\r\nelse if ((ulong)unit[drive].track >= unit[drive].type->precomp1)\r\nadk |= ADK_PRECOMP0;\r\ncustom.adkcon = adk;\r\ncustom.dsklen = DSKLEN_WRITE;\r\ncustom.dskptr = (u_char *)ZTWO_PADDR((u_char *)raw_buf);\r\ncustom.dsklen = unit[drive].type->write_size/sizeof(short) | DSKLEN_DMAEN|DSKLEN_WRITE;\r\ncustom.dsklen = unit[drive].type->write_size/sizeof(short) | DSKLEN_DMAEN|DSKLEN_WRITE;\r\nblock_flag = 2;\r\nreturn 1;\r\n}\r\nstatic void post_write (unsigned long drive)\r\n{\r\n#ifdef DEBUG\r\nprintk("post_write for drive %ld\n",drive);\r\n#endif\r\ndrive &= 3;\r\ncustom.dsklen = 0;\r\nblock_flag = 0;\r\nwritepending = 0;\r\nwritefromint = 0;\r\nunit[drive].dirty = 0;\r\nwake_up(&wait_fd_block);\r\nfd_deselect(drive);\r\nrel_fdc();\r\n}\r\nstatic unsigned long scan_sync(unsigned long raw, unsigned long end)\r\n{\r\nushort *ptr = (ushort *)raw, *endp = (ushort *)end;\r\nwhile (ptr < endp && *ptr++ != 0x4489)\r\n;\r\nif (ptr < endp) {\r\nwhile (*ptr == 0x4489 && ptr < endp)\r\nptr++;\r\nreturn (ulong)ptr;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline unsigned long checksum(unsigned long *addr, int len)\r\n{\r\nunsigned long csum = 0;\r\nlen /= sizeof(*addr);\r\nwhile (len-- > 0)\r\ncsum ^= *addr++;\r\ncsum = ((csum>>1) & 0x55555555) ^ (csum & 0x55555555);\r\nreturn csum;\r\n}\r\nstatic unsigned long decode (unsigned long *data, unsigned long *raw,\r\nint len)\r\n{\r\nulong *odd, *even;\r\nlen >>= 2;\r\nodd = raw;\r\neven = odd + len;\r\nraw += len * 2;\r\ndo {\r\n*data++ = ((*odd++ & 0x55555555) << 1) | (*even++ & 0x55555555);\r\n} while (--len != 0);\r\nreturn (ulong)raw;\r\n}\r\nstatic int amiga_read(int drive)\r\n{\r\nunsigned long raw;\r\nunsigned long end;\r\nint scnt;\r\nunsigned long csum;\r\nstruct header hdr;\r\ndrive&=3;\r\nraw = (long) raw_buf;\r\nend = raw + unit[drive].type->read_size;\r\nfor (scnt = 0;scnt < unit[drive].dtype->sects * unit[drive].type->sect_mult; scnt++) {\r\nif (!(raw = scan_sync(raw, end))) {\r\nprintk (KERN_INFO "can't find sync for sector %d\n", scnt);\r\nreturn MFM_NOSYNC;\r\n}\r\nraw = decode ((ulong *)&hdr.magic, (ulong *)raw, 4);\r\nraw = decode ((ulong *)&hdr.labels, (ulong *)raw, 16);\r\nraw = decode ((ulong *)&hdr.hdrchk, (ulong *)raw, 4);\r\nraw = decode ((ulong *)&hdr.datachk, (ulong *)raw, 4);\r\ncsum = checksum((ulong *)&hdr,\r\n(char *)&hdr.hdrchk-(char *)&hdr);\r\n#ifdef DEBUG\r\nprintk ("(%x,%d,%d,%d) (%lx,%lx,%lx,%lx) %lx %lx\n",\r\nhdr.magic, hdr.track, hdr.sect, hdr.ord,\r\n*(ulong *)&hdr.labels[0], *(ulong *)&hdr.labels[4],\r\n*(ulong *)&hdr.labels[8], *(ulong *)&hdr.labels[12],\r\nhdr.hdrchk, hdr.datachk);\r\n#endif\r\nif (hdr.hdrchk != csum) {\r\nprintk(KERN_INFO "MFM_HEADER: %08lx,%08lx\n", hdr.hdrchk, csum);\r\nreturn MFM_HEADER;\r\n}\r\nif (hdr.track != unit[drive].track) {\r\nprintk(KERN_INFO "MFM_TRACK: %d, %d\n", hdr.track, unit[drive].track);\r\nreturn MFM_TRACK;\r\n}\r\nraw = decode ((ulong *)(unit[drive].trackbuf + hdr.sect*512),\r\n(ulong *)raw, 512);\r\ncsum = checksum((ulong *)(unit[drive].trackbuf + hdr.sect*512), 512);\r\nif (hdr.datachk != csum) {\r\nprintk(KERN_INFO "MFM_DATA: (%x:%d:%d:%d) sc=%d %lx, %lx\n",\r\nhdr.magic, hdr.track, hdr.sect, hdr.ord, scnt,\r\nhdr.datachk, csum);\r\nprintk (KERN_INFO "data=(%lx,%lx,%lx,%lx)\n",\r\n((ulong *)(unit[drive].trackbuf+hdr.sect*512))[0],\r\n((ulong *)(unit[drive].trackbuf+hdr.sect*512))[1],\r\n((ulong *)(unit[drive].trackbuf+hdr.sect*512))[2],\r\n((ulong *)(unit[drive].trackbuf+hdr.sect*512))[3]);\r\nreturn MFM_DATA;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void encode(unsigned long data, unsigned long *dest)\r\n{\r\nunsigned long data2;\r\ndata &= 0x55555555;\r\ndata2 = data ^ 0x55555555;\r\ndata |= ((data2 >> 1) | 0x80000000) & (data2 << 1);\r\nif (*(dest - 1) & 0x00000001)\r\ndata &= 0x7FFFFFFF;\r\n*dest = data;\r\n}\r\nstatic void encode_block(unsigned long *dest, unsigned long *src, int len)\r\n{\r\nint cnt, to_cnt = 0;\r\nunsigned long data;\r\nfor (cnt = 0; cnt < len / 4; cnt++) {\r\ndata = src[cnt] >> 1;\r\nencode(data, dest + to_cnt++);\r\n}\r\nfor (cnt = 0; cnt < len / 4; cnt++) {\r\ndata = src[cnt];\r\nencode(data, dest + to_cnt++);\r\n}\r\n}\r\nstatic unsigned long *putsec(int disk, unsigned long *raw, int cnt)\r\n{\r\nstruct header hdr;\r\nint i;\r\ndisk&=3;\r\n*raw = (raw[-1]&1) ? 0x2AAAAAAA : 0xAAAAAAAA;\r\nraw++;\r\n*raw++ = 0x44894489;\r\nhdr.magic = 0xFF;\r\nhdr.track = unit[disk].track;\r\nhdr.sect = cnt;\r\nhdr.ord = unit[disk].dtype->sects * unit[disk].type->sect_mult - cnt;\r\nfor (i = 0; i < 16; i++)\r\nhdr.labels[i] = 0;\r\nhdr.hdrchk = checksum((ulong *)&hdr,\r\n(char *)&hdr.hdrchk-(char *)&hdr);\r\nhdr.datachk = checksum((ulong *)(unit[disk].trackbuf+cnt*512), 512);\r\nencode_block(raw, (ulong *)&hdr.magic, 4);\r\nraw += 2;\r\nencode_block(raw, (ulong *)&hdr.labels, 16);\r\nraw += 8;\r\nencode_block(raw, (ulong *)&hdr.hdrchk, 4);\r\nraw += 2;\r\nencode_block(raw, (ulong *)&hdr.datachk, 4);\r\nraw += 2;\r\nencode_block(raw, (ulong *)(unit[disk].trackbuf+cnt*512), 512);\r\nraw += 256;\r\nreturn raw;\r\n}\r\nstatic void amiga_write(int disk)\r\n{\r\nunsigned int cnt;\r\nunsigned long *ptr = (unsigned long *)raw_buf;\r\ndisk&=3;\r\nfor (cnt = 0; cnt < 415 * unit[disk].type->sect_mult; cnt++)\r\n*ptr++ = 0xaaaaaaaa;\r\nfor (cnt = 0; cnt < unit[disk].dtype->sects * unit[disk].type->sect_mult; cnt++)\r\nptr = putsec (disk, ptr, cnt);\r\n*(ushort *)ptr = (ptr[-1]&1) ? 0x2AA8 : 0xAAA8;\r\n}\r\nstatic ushort dos_crc(void * data_a3, int data_d0, int data_d1, int data_d3)\r\n{\r\nstatic unsigned char CRCTable1[] = {\r\n0x00,0x10,0x20,0x30,0x40,0x50,0x60,0x70,0x81,0x91,0xa1,0xb1,0xc1,0xd1,0xe1,0xf1,\r\n0x12,0x02,0x32,0x22,0x52,0x42,0x72,0x62,0x93,0x83,0xb3,0xa3,0xd3,0xc3,0xf3,0xe3,\r\n0x24,0x34,0x04,0x14,0x64,0x74,0x44,0x54,0xa5,0xb5,0x85,0x95,0xe5,0xf5,0xc5,0xd5,\r\n0x36,0x26,0x16,0x06,0x76,0x66,0x56,0x46,0xb7,0xa7,0x97,0x87,0xf7,0xe7,0xd7,0xc7,\r\n0x48,0x58,0x68,0x78,0x08,0x18,0x28,0x38,0xc9,0xd9,0xe9,0xf9,0x89,0x99,0xa9,0xb9,\r\n0x5a,0x4a,0x7a,0x6a,0x1a,0x0a,0x3a,0x2a,0xdb,0xcb,0xfb,0xeb,0x9b,0x8b,0xbb,0xab,\r\n0x6c,0x7c,0x4c,0x5c,0x2c,0x3c,0x0c,0x1c,0xed,0xfd,0xcd,0xdd,0xad,0xbd,0x8d,0x9d,\r\n0x7e,0x6e,0x5e,0x4e,0x3e,0x2e,0x1e,0x0e,0xff,0xef,0xdf,0xcf,0xbf,0xaf,0x9f,0x8f,\r\n0x91,0x81,0xb1,0xa1,0xd1,0xc1,0xf1,0xe1,0x10,0x00,0x30,0x20,0x50,0x40,0x70,0x60,\r\n0x83,0x93,0xa3,0xb3,0xc3,0xd3,0xe3,0xf3,0x02,0x12,0x22,0x32,0x42,0x52,0x62,0x72,\r\n0xb5,0xa5,0x95,0x85,0xf5,0xe5,0xd5,0xc5,0x34,0x24,0x14,0x04,0x74,0x64,0x54,0x44,\r\n0xa7,0xb7,0x87,0x97,0xe7,0xf7,0xc7,0xd7,0x26,0x36,0x06,0x16,0x66,0x76,0x46,0x56,\r\n0xd9,0xc9,0xf9,0xe9,0x99,0x89,0xb9,0xa9,0x58,0x48,0x78,0x68,0x18,0x08,0x38,0x28,\r\n0xcb,0xdb,0xeb,0xfb,0x8b,0x9b,0xab,0xbb,0x4a,0x5a,0x6a,0x7a,0x0a,0x1a,0x2a,0x3a,\r\n0xfd,0xed,0xdd,0xcd,0xbd,0xad,0x9d,0x8d,0x7c,0x6c,0x5c,0x4c,0x3c,0x2c,0x1c,0x0c,\r\n0xef,0xff,0xcf,0xdf,0xaf,0xbf,0x8f,0x9f,0x6e,0x7e,0x4e,0x5e,0x2e,0x3e,0x0e,0x1e\r\n};\r\nstatic unsigned char CRCTable2[] = {\r\n0x00,0x21,0x42,0x63,0x84,0xa5,0xc6,0xe7,0x08,0x29,0x4a,0x6b,0x8c,0xad,0xce,0xef,\r\n0x31,0x10,0x73,0x52,0xb5,0x94,0xf7,0xd6,0x39,0x18,0x7b,0x5a,0xbd,0x9c,0xff,0xde,\r\n0x62,0x43,0x20,0x01,0xe6,0xc7,0xa4,0x85,0x6a,0x4b,0x28,0x09,0xee,0xcf,0xac,0x8d,\r\n0x53,0x72,0x11,0x30,0xd7,0xf6,0x95,0xb4,0x5b,0x7a,0x19,0x38,0xdf,0xfe,0x9d,0xbc,\r\n0xc4,0xe5,0x86,0xa7,0x40,0x61,0x02,0x23,0xcc,0xed,0x8e,0xaf,0x48,0x69,0x0a,0x2b,\r\n0xf5,0xd4,0xb7,0x96,0x71,0x50,0x33,0x12,0xfd,0xdc,0xbf,0x9e,0x79,0x58,0x3b,0x1a,\r\n0xa6,0x87,0xe4,0xc5,0x22,0x03,0x60,0x41,0xae,0x8f,0xec,0xcd,0x2a,0x0b,0x68,0x49,\r\n0x97,0xb6,0xd5,0xf4,0x13,0x32,0x51,0x70,0x9f,0xbe,0xdd,0xfc,0x1b,0x3a,0x59,0x78,\r\n0x88,0xa9,0xca,0xeb,0x0c,0x2d,0x4e,0x6f,0x80,0xa1,0xc2,0xe3,0x04,0x25,0x46,0x67,\r\n0xb9,0x98,0xfb,0xda,0x3d,0x1c,0x7f,0x5e,0xb1,0x90,0xf3,0xd2,0x35,0x14,0x77,0x56,\r\n0xea,0xcb,0xa8,0x89,0x6e,0x4f,0x2c,0x0d,0xe2,0xc3,0xa0,0x81,0x66,0x47,0x24,0x05,\r\n0xdb,0xfa,0x99,0xb8,0x5f,0x7e,0x1d,0x3c,0xd3,0xf2,0x91,0xb0,0x57,0x76,0x15,0x34,\r\n0x4c,0x6d,0x0e,0x2f,0xc8,0xe9,0x8a,0xab,0x44,0x65,0x06,0x27,0xc0,0xe1,0x82,0xa3,\r\n0x7d,0x5c,0x3f,0x1e,0xf9,0xd8,0xbb,0x9a,0x75,0x54,0x37,0x16,0xf1,0xd0,0xb3,0x92,\r\n0x2e,0x0f,0x6c,0x4d,0xaa,0x8b,0xe8,0xc9,0x26,0x07,0x64,0x45,0xa2,0x83,0xe0,0xc1,\r\n0x1f,0x3e,0x5d,0x7c,0x9b,0xba,0xd9,0xf8,0x17,0x36,0x55,0x74,0x93,0xb2,0xd1,0xf0\r\n};\r\nregister int i;\r\nregister unsigned char *CRCT1, *CRCT2, *data, c, crch, crcl;\r\nCRCT1=CRCTable1;\r\nCRCT2=CRCTable2;\r\ndata=data_a3;\r\ncrcl=data_d1;\r\ncrch=data_d0;\r\nfor (i=data_d3; i>=0; i--) {\r\nc = (*data++) ^ crch;\r\ncrch = CRCT1[c] ^ crcl;\r\ncrcl = CRCT2[c];\r\n}\r\nreturn (crch<<8)|crcl;\r\n}\r\nstatic inline ushort dos_hdr_crc (struct dos_header *hdr)\r\n{\r\nreturn dos_crc(&(hdr->track), 0xb2, 0x30, 3);\r\n}\r\nstatic inline ushort dos_data_crc(unsigned char *data)\r\n{\r\nreturn dos_crc(data, 0xe2, 0x95 ,511);\r\n}\r\nstatic inline unsigned char dos_decode_byte(ushort word)\r\n{\r\nregister ushort w2;\r\nregister unsigned char byte;\r\nregister unsigned char *dec = mfmdecode;\r\nw2=word;\r\nw2>>=8;\r\nw2&=127;\r\nbyte = dec[w2];\r\nbyte <<= 4;\r\nw2 = word & 127;\r\nbyte |= dec[w2];\r\nreturn byte;\r\n}\r\nstatic unsigned long dos_decode(unsigned char *data, unsigned short *raw, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\n*data++=dos_decode_byte(*raw++);\r\nreturn ((ulong)raw);\r\n}\r\nstatic void dbg(unsigned long ptr)\r\n{\r\nprintk("raw data @%08lx: %08lx, %08lx ,%08lx, %08lx\n", ptr,\r\n((ulong *)ptr)[0], ((ulong *)ptr)[1],\r\n((ulong *)ptr)[2], ((ulong *)ptr)[3]);\r\n}\r\nstatic int dos_read(int drive)\r\n{\r\nunsigned long end;\r\nunsigned long raw;\r\nint scnt;\r\nunsigned short crc,data_crc[2];\r\nstruct dos_header hdr;\r\ndrive&=3;\r\nraw = (long) raw_buf;\r\nend = raw + unit[drive].type->read_size;\r\nfor (scnt=0; scnt < unit[drive].dtype->sects * unit[drive].type->sect_mult; scnt++) {\r\ndo {\r\nif (!(raw = scan_sync (raw, end))) {\r\nprintk(KERN_INFO "dos_read: no hdr sync on "\r\n"track %d, unit %d for sector %d\n",\r\nunit[drive].track,drive,scnt);\r\nreturn MFM_NOSYNC;\r\n}\r\n#ifdef DEBUG\r\ndbg(raw);\r\n#endif\r\n} while (*((ushort *)raw)!=0x5554);\r\nraw+=2;\r\nraw = dos_decode((unsigned char *)&hdr,(ushort *) raw,8);\r\ncrc = dos_hdr_crc(&hdr);\r\n#ifdef DEBUG\r\nprintk("(%3d,%d,%2d,%d) %x\n", hdr.track, hdr.side,\r\nhdr.sec, hdr.len_desc, hdr.crc);\r\n#endif\r\nif (crc != hdr.crc) {\r\nprintk(KERN_INFO "dos_read: MFM_HEADER %04x,%04x\n",\r\nhdr.crc, crc);\r\nreturn MFM_HEADER;\r\n}\r\nif (hdr.track != unit[drive].track/unit[drive].type->heads) {\r\nprintk(KERN_INFO "dos_read: MFM_TRACK %d, %d\n",\r\nhdr.track,\r\nunit[drive].track/unit[drive].type->heads);\r\nreturn MFM_TRACK;\r\n}\r\nif (hdr.side != unit[drive].track%unit[drive].type->heads) {\r\nprintk(KERN_INFO "dos_read: MFM_SIDE %d, %d\n",\r\nhdr.side,\r\nunit[drive].track%unit[drive].type->heads);\r\nreturn MFM_TRACK;\r\n}\r\nif (hdr.len_desc != 2) {\r\nprintk(KERN_INFO "dos_read: unknown sector len "\r\n"descriptor %d\n", hdr.len_desc);\r\nreturn MFM_DATA;\r\n}\r\n#ifdef DEBUG\r\nprintk("hdr accepted\n");\r\n#endif\r\nif (!(raw = scan_sync (raw, end))) {\r\nprintk(KERN_INFO "dos_read: no data sync on track "\r\n"%d, unit %d for sector%d, disk sector %d\n",\r\nunit[drive].track, drive, scnt, hdr.sec);\r\nreturn MFM_NOSYNC;\r\n}\r\n#ifdef DEBUG\r\ndbg(raw);\r\n#endif\r\nif (*((ushort *)raw)!=0x5545) {\r\nprintk(KERN_INFO "dos_read: no data mark after "\r\n"sync (%d,%d,%d,%d) sc=%d\n",\r\nhdr.track,hdr.side,hdr.sec,hdr.len_desc,scnt);\r\nreturn MFM_NOSYNC;\r\n}\r\nraw+=2;\r\nraw = dos_decode((unsigned char *)(unit[drive].trackbuf + (hdr.sec - 1) * 512), (ushort *) raw, 512);\r\nraw = dos_decode((unsigned char *)data_crc,(ushort *) raw,4);\r\ncrc = dos_data_crc(unit[drive].trackbuf + (hdr.sec - 1) * 512);\r\nif (crc != data_crc[0]) {\r\nprintk(KERN_INFO "dos_read: MFM_DATA (%d,%d,%d,%d) "\r\n"sc=%d, %x %x\n", hdr.track, hdr.side,\r\nhdr.sec, hdr.len_desc, scnt,data_crc[0], crc);\r\nprintk(KERN_INFO "data=(%lx,%lx,%lx,%lx,...)\n",\r\n((ulong *)(unit[drive].trackbuf+(hdr.sec-1)*512))[0],\r\n((ulong *)(unit[drive].trackbuf+(hdr.sec-1)*512))[1],\r\n((ulong *)(unit[drive].trackbuf+(hdr.sec-1)*512))[2],\r\n((ulong *)(unit[drive].trackbuf+(hdr.sec-1)*512))[3]);\r\nreturn MFM_DATA;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline ushort dos_encode_byte(unsigned char byte)\r\n{\r\nregister unsigned char *enc, b2, b1;\r\nregister ushort word;\r\nenc=mfmencode;\r\nb1=byte;\r\nb2=b1>>4;\r\nb1&=15;\r\nword=enc[b2] <<8 | enc [b1];\r\nreturn (word|((word&(256|64)) ? 0: 128));\r\n}\r\nstatic void dos_encode_block(ushort *dest, unsigned char *src, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\n*dest=dos_encode_byte(*src++);\r\n*dest|=((dest[-1]&1)||(*dest&0x4000))? 0: 0x8000;\r\ndest++;\r\n}\r\n}\r\nstatic unsigned long *ms_putsec(int drive, unsigned long *raw, int cnt)\r\n{\r\nstatic struct dos_header hdr={0,0,0,2,0,\r\n{78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78}};\r\nint i;\r\nstatic ushort crc[2]={0,0x4e4e};\r\ndrive&=3;\r\nfor(i=0;i<6;i++)\r\n*raw++=0xaaaaaaaa;\r\n*raw++=0x44894489;\r\n*raw++=0x44895554;\r\nhdr.track=unit[drive].track/unit[drive].type->heads;\r\nhdr.side=unit[drive].track%unit[drive].type->heads;\r\nhdr.sec=cnt+1;\r\nhdr.crc=dos_hdr_crc(&hdr);\r\ndos_encode_block((ushort *)raw,(unsigned char *) &hdr.track,28);\r\nraw+=14;\r\nfor(i=0;i<6;i++)\r\n*raw++=0xaaaaaaaa;\r\n*raw++=0x44894489;\r\n*raw++=0x44895545;\r\ndos_encode_block((ushort *)raw,\r\n(unsigned char *)unit[drive].trackbuf+cnt*512,512);\r\nraw+=256;\r\ncrc[0]=dos_data_crc(unit[drive].trackbuf+cnt*512);\r\ndos_encode_block((ushort *) raw,(unsigned char *)crc,4);\r\nraw+=2;\r\nfor(i=0;i<38;i++)\r\n*raw++=0x92549254;\r\nreturn raw;\r\n}\r\nstatic void dos_write(int disk)\r\n{\r\nint cnt;\r\nunsigned long raw = (unsigned long) raw_buf;\r\nunsigned long *ptr=(unsigned long *)raw;\r\ndisk&=3;\r\nfor (cnt=0;cnt<425;cnt++)\r\n*ptr++=0x92549254;\r\nif (unit[disk].type->sect_mult==2)\r\nfor(cnt=0;cnt<473;cnt++)\r\n*ptr++=0x92549254;\r\nfor (cnt=0;cnt<20;cnt++)\r\n*ptr++=0x92549254;\r\nfor (cnt=0;cnt<6;cnt++)\r\n*ptr++=0xaaaaaaaa;\r\n*ptr++=0x52245224;\r\n*ptr++=0x52245552;\r\nfor (cnt=0;cnt<20;cnt++)\r\n*ptr++=0x92549254;\r\nfor(cnt = 0; cnt < unit[disk].dtype->sects * unit[disk].type->sect_mult; cnt++)\r\nptr=ms_putsec(disk,ptr,cnt);\r\n*(ushort *)ptr = 0xaaa8;\r\n}\r\nstatic void flush_track_callback(unsigned long nr)\r\n{\r\nnr&=3;\r\nwritefromint = 1;\r\nif (!try_fdc(nr)) {\r\nflush_track_timer[nr].expires = jiffies + 1;\r\nadd_timer(flush_track_timer + nr);\r\nreturn;\r\n}\r\nget_fdc(nr);\r\n(*unit[nr].dtype->write_fkt)(nr);\r\nif (!raw_write(nr)) {\r\nprintk (KERN_NOTICE "floppy disk write protected\n");\r\nwritefromint = 0;\r\nwritepending = 0;\r\n}\r\nrel_fdc();\r\n}\r\nstatic int non_int_flush_track (unsigned long nr)\r\n{\r\nunsigned long flags;\r\nnr&=3;\r\nwritefromint = 0;\r\ndel_timer(&post_write_timer);\r\nget_fdc(nr);\r\nif (!fd_motor_on(nr)) {\r\nwritepending = 0;\r\nrel_fdc();\r\nreturn 0;\r\n}\r\nlocal_irq_save(flags);\r\nif (writepending != 2) {\r\nlocal_irq_restore(flags);\r\n(*unit[nr].dtype->write_fkt)(nr);\r\nif (!raw_write(nr)) {\r\nprintk (KERN_NOTICE "floppy disk write protected "\r\n"in write!\n");\r\nwritepending = 0;\r\nreturn 0;\r\n}\r\nwait_event(wait_fd_block, block_flag != 2);\r\n}\r\nelse {\r\nlocal_irq_restore(flags);\r\nms_delay(2);\r\npost_write(nr);\r\n}\r\nrel_fdc();\r\nreturn 1;\r\n}\r\nstatic int get_track(int drive, int track)\r\n{\r\nint error, errcnt;\r\ndrive&=3;\r\nif (unit[drive].track == track)\r\nreturn 0;\r\nget_fdc(drive);\r\nif (!fd_motor_on(drive)) {\r\nrel_fdc();\r\nreturn -1;\r\n}\r\nif (unit[drive].dirty == 1) {\r\ndel_timer (flush_track_timer + drive);\r\nnon_int_flush_track (drive);\r\n}\r\nerrcnt = 0;\r\nwhile (errcnt < MAX_ERRORS) {\r\nif (!fd_seek(drive, track))\r\nreturn -1;\r\nraw_read(drive);\r\nerror = (*unit[drive].dtype->read_fkt)(drive);\r\nif (error == 0) {\r\nrel_fdc();\r\nreturn 0;\r\n}\r\nunit[drive].track = -1;\r\nerrcnt++;\r\n}\r\nrel_fdc();\r\nreturn -1;\r\n}\r\nstatic struct request *set_next_request(void)\r\n{\r\nstruct request_queue *q;\r\nint cnt = FD_MAX_UNITS;\r\nstruct request *rq = NULL;\r\nfdc_queue = fdc_queue + 1;\r\nif (fdc_queue == FD_MAX_UNITS)\r\nfdc_queue = 0;\r\nfor(cnt = FD_MAX_UNITS; cnt > 0; cnt--) {\r\nif (unit[fdc_queue].type->code == FD_NODRIVE) {\r\nif (++fdc_queue == FD_MAX_UNITS)\r\nfdc_queue = 0;\r\ncontinue;\r\n}\r\nq = unit[fdc_queue].gendisk->queue;\r\nif (q) {\r\nrq = blk_fetch_request(q);\r\nif (rq)\r\nbreak;\r\n}\r\nif (++fdc_queue == FD_MAX_UNITS)\r\nfdc_queue = 0;\r\n}\r\nreturn rq;\r\n}\r\nstatic void redo_fd_request(void)\r\n{\r\nstruct request *rq;\r\nunsigned int cnt, block, track, sector;\r\nint drive;\r\nstruct amiga_floppy_struct *floppy;\r\nchar *data;\r\nunsigned long flags;\r\nblk_status_t err;\r\nnext_req:\r\nrq = set_next_request();\r\nif (!rq) {\r\nreturn;\r\n}\r\nfloppy = rq->rq_disk->private_data;\r\ndrive = floppy - unit;\r\nnext_segment:\r\nfor (cnt = 0, err = BLK_STS_OK; cnt < blk_rq_cur_sectors(rq); cnt++) {\r\n#ifdef DEBUG\r\nprintk("fd: sector %ld + %d requested for %s\n",\r\nblk_rq_pos(rq), cnt,\r\n(rq_data_dir(rq) == READ) ? "read" : "write");\r\n#endif\r\nblock = blk_rq_pos(rq) + cnt;\r\nif ((int)block > floppy->blocks) {\r\nerr = BLK_STS_IOERR;\r\nbreak;\r\n}\r\ntrack = block / (floppy->dtype->sects * floppy->type->sect_mult);\r\nsector = block % (floppy->dtype->sects * floppy->type->sect_mult);\r\ndata = bio_data(rq->bio) + 512 * cnt;\r\n#ifdef DEBUG\r\nprintk("access to track %d, sector %d, with buffer at "\r\n"0x%08lx\n", track, sector, data);\r\n#endif\r\nif (get_track(drive, track) == -1) {\r\nerr = BLK_STS_IOERR;\r\nbreak;\r\n}\r\nif (rq_data_dir(rq) == READ) {\r\nmemcpy(data, floppy->trackbuf + sector * 512, 512);\r\n} else {\r\nmemcpy(floppy->trackbuf + sector * 512, data, 512);\r\nif (!fd_motor_on(drive)) {\r\nerr = BLK_STS_IOERR;\r\nbreak;\r\n}\r\nlocal_irq_save(flags);\r\nfloppy->dirty = 1;\r\nmod_timer (flush_track_timer + drive, jiffies + 1);\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nif (__blk_end_request_cur(rq, err))\r\ngoto next_segment;\r\ngoto next_req;\r\n}\r\nstatic void do_fd_request(struct request_queue * q)\r\n{\r\nredo_fd_request();\r\n}\r\nstatic int fd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nint drive = MINOR(bdev->bd_dev) & 3;\r\ngeo->heads = unit[drive].type->heads;\r\ngeo->sectors = unit[drive].dtype->sects * unit[drive].type->sect_mult;\r\ngeo->cylinders = unit[drive].type->tracks;\r\nreturn 0;\r\n}\r\nstatic int fd_locked_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long param)\r\n{\r\nstruct amiga_floppy_struct *p = bdev->bd_disk->private_data;\r\nint drive = p - unit;\r\nstatic struct floppy_struct getprm;\r\nvoid __user *argp = (void __user *)param;\r\nswitch(cmd){\r\ncase FDFMTBEG:\r\nget_fdc(drive);\r\nif (fd_ref[drive] > 1) {\r\nrel_fdc();\r\nreturn -EBUSY;\r\n}\r\nfsync_bdev(bdev);\r\nif (fd_motor_on(drive) == 0) {\r\nrel_fdc();\r\nreturn -ENODEV;\r\n}\r\nif (fd_calibrate(drive) == 0) {\r\nrel_fdc();\r\nreturn -ENXIO;\r\n}\r\nfloppy_off(drive);\r\nrel_fdc();\r\nbreak;\r\ncase FDFMTTRK:\r\nif (param < p->type->tracks * p->type->heads)\r\n{\r\nget_fdc(drive);\r\nif (fd_seek(drive,param) != 0){\r\nmemset(p->trackbuf, FD_FILL_BYTE,\r\np->dtype->sects * p->type->sect_mult * 512);\r\nnon_int_flush_track(drive);\r\n}\r\nfloppy_off(drive);\r\nrel_fdc();\r\n}\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase FDFMTEND:\r\nfloppy_off(drive);\r\ninvalidate_bdev(bdev);\r\nbreak;\r\ncase FDGETPRM:\r\nmemset((void *)&getprm, 0, sizeof (getprm));\r\ngetprm.track=p->type->tracks;\r\ngetprm.head=p->type->heads;\r\ngetprm.sect=p->dtype->sects * p->type->sect_mult;\r\ngetprm.size=p->blocks;\r\nif (copy_to_user(argp, &getprm, sizeof(struct floppy_struct)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase FDSETPRM:\r\ncase FDDEFPRM:\r\nreturn -EINVAL;\r\ncase FDFLUSH:\r\ndel_timer (flush_track_timer + drive);\r\nnon_int_flush_track(drive);\r\nbreak;\r\n#ifdef RAW_IOCTL\r\ncase IOCTL_RAW_TRACK:\r\nif (copy_to_user(argp, raw_buf, p->type->read_size))\r\nreturn -EFAULT;\r\nelse\r\nreturn p->type->read_size;\r\n#endif\r\ndefault:\r\nprintk(KERN_DEBUG "fd_ioctl: unknown cmd %d for drive %d.",\r\ncmd, drive);\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fd_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long param)\r\n{\r\nint ret;\r\nmutex_lock(&amiflop_mutex);\r\nret = fd_locked_ioctl(bdev, mode, cmd, param);\r\nmutex_unlock(&amiflop_mutex);\r\nreturn ret;\r\n}\r\nstatic void fd_probe(int dev)\r\n{\r\nunsigned long code;\r\nint type;\r\nint drive;\r\ndrive = dev & 3;\r\ncode = fd_get_drive_id(drive);\r\nfor (type = 0; type < num_dr_types; type++)\r\nif (drive_types[type].code == code)\r\nbreak;\r\nif (type >= num_dr_types) {\r\nprintk(KERN_WARNING "fd_probe: unsupported drive type "\r\n"%08lx found\n", code);\r\nunit[drive].type = &drive_types[num_dr_types-1];\r\nreturn;\r\n}\r\nunit[drive].type = drive_types + type;\r\nunit[drive].track = -1;\r\nunit[drive].disk = -1;\r\nunit[drive].motor = 0;\r\nunit[drive].busy = 0;\r\nunit[drive].status = -1;\r\n}\r\nstatic int floppy_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nint drive = MINOR(bdev->bd_dev) & 3;\r\nint system = (MINOR(bdev->bd_dev) & 4) >> 2;\r\nint old_dev;\r\nunsigned long flags;\r\nmutex_lock(&amiflop_mutex);\r\nold_dev = fd_device[drive];\r\nif (fd_ref[drive] && old_dev != system) {\r\nmutex_unlock(&amiflop_mutex);\r\nreturn -EBUSY;\r\n}\r\nif (mode & (FMODE_READ|FMODE_WRITE)) {\r\ncheck_disk_change(bdev);\r\nif (mode & FMODE_WRITE) {\r\nint wrprot;\r\nget_fdc(drive);\r\nfd_select (drive);\r\nwrprot = !(ciaa.pra & DSKPROT);\r\nfd_deselect (drive);\r\nrel_fdc();\r\nif (wrprot) {\r\nmutex_unlock(&amiflop_mutex);\r\nreturn -EROFS;\r\n}\r\n}\r\n}\r\nlocal_irq_save(flags);\r\nfd_ref[drive]++;\r\nfd_device[drive] = system;\r\nlocal_irq_restore(flags);\r\nunit[drive].dtype=&data_types[system];\r\nunit[drive].blocks=unit[drive].type->heads*unit[drive].type->tracks*\r\ndata_types[system].sects*unit[drive].type->sect_mult;\r\nset_capacity(unit[drive].gendisk, unit[drive].blocks);\r\nprintk(KERN_INFO "fd%d: accessing %s-disk with %s-layout\n",drive,\r\nunit[drive].type->name, data_types[system].name);\r\nmutex_unlock(&amiflop_mutex);\r\nreturn 0;\r\n}\r\nstatic void floppy_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct amiga_floppy_struct *p = disk->private_data;\r\nint drive = p - unit;\r\nmutex_lock(&amiflop_mutex);\r\nif (unit[drive].dirty == 1) {\r\ndel_timer (flush_track_timer + drive);\r\nnon_int_flush_track (drive);\r\n}\r\nif (!fd_ref[drive]--) {\r\nprintk(KERN_CRIT "floppy_release with fd_ref == 0");\r\nfd_ref[drive] = 0;\r\n}\r\n#ifdef MODULE\r\nfloppy_off (drive | 0x40000000);\r\n#endif\r\nmutex_unlock(&amiflop_mutex);\r\n}\r\nstatic unsigned amiga_check_events(struct gendisk *disk, unsigned int clearing)\r\n{\r\nstruct amiga_floppy_struct *p = disk->private_data;\r\nint drive = p - unit;\r\nint changed;\r\nstatic int first_time = 1;\r\nif (first_time)\r\nchanged = first_time--;\r\nelse {\r\nget_fdc(drive);\r\nfd_select (drive);\r\nchanged = !(ciaa.pra & DSKCHANGE);\r\nfd_deselect (drive);\r\nrel_fdc();\r\n}\r\nif (changed) {\r\nfd_probe(drive);\r\np->track = -1;\r\np->dirty = 0;\r\nwritepending = 0;\r\nwritefromint = 0;\r\nreturn DISK_EVENT_MEDIA_CHANGE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init fd_probe_drives(void)\r\n{\r\nint drive,drives,nomem;\r\nprintk(KERN_INFO "FD: probing units\nfound ");\r\ndrives=0;\r\nnomem=0;\r\nfor(drive=0;drive<FD_MAX_UNITS;drive++) {\r\nstruct gendisk *disk;\r\nfd_probe(drive);\r\nif (unit[drive].type->code == FD_NODRIVE)\r\ncontinue;\r\ndisk = alloc_disk(1);\r\nif (!disk) {\r\nunit[drive].type->code = FD_NODRIVE;\r\ncontinue;\r\n}\r\nunit[drive].gendisk = disk;\r\ndisk->queue = blk_init_queue(do_fd_request, &amiflop_lock);\r\nif (!disk->queue) {\r\nunit[drive].type->code = FD_NODRIVE;\r\ncontinue;\r\n}\r\ndrives++;\r\nif ((unit[drive].trackbuf = kmalloc(FLOPPY_MAX_SECTORS * 512, GFP_KERNEL)) == NULL) {\r\nprintk("no mem for ");\r\nunit[drive].type = &drive_types[num_dr_types - 1];\r\ndrives--;\r\nnomem = 1;\r\n}\r\nprintk("fd%d ",drive);\r\ndisk->major = FLOPPY_MAJOR;\r\ndisk->first_minor = drive;\r\ndisk->fops = &floppy_fops;\r\nsprintf(disk->disk_name, "fd%d", drive);\r\ndisk->private_data = &unit[drive];\r\nset_capacity(disk, 880*2);\r\nadd_disk(disk);\r\n}\r\nif ((drives > 0) || (nomem == 0)) {\r\nif (drives == 0)\r\nprintk("no drives");\r\nprintk("\n");\r\nreturn drives;\r\n}\r\nprintk("\n");\r\nreturn -ENOMEM;\r\n}\r\nstatic struct kobject *floppy_find(dev_t dev, int *part, void *data)\r\n{\r\nint drive = *part & 3;\r\nif (unit[drive].type->code == FD_NODRIVE)\r\nreturn NULL;\r\n*part = 0;\r\nreturn get_disk(unit[drive].gendisk);\r\n}\r\nstatic int __init amiga_floppy_probe(struct platform_device *pdev)\r\n{\r\nint i, ret;\r\nif (register_blkdev(FLOPPY_MAJOR,"fd"))\r\nreturn -EBUSY;\r\nret = -ENOMEM;\r\nraw_buf = amiga_chip_alloc(RAW_BUF_SIZE, "Floppy");\r\nif (!raw_buf) {\r\nprintk("fd: cannot get chip mem buffer\n");\r\ngoto out_blkdev;\r\n}\r\nret = -EBUSY;\r\nif (request_irq(IRQ_AMIGA_DSKBLK, fd_block_done, 0, "floppy_dma", NULL)) {\r\nprintk("fd: cannot get irq for dma\n");\r\ngoto out_irq;\r\n}\r\nif (request_irq(IRQ_AMIGA_CIAA_TB, ms_isr, 0, "floppy_timer", NULL)) {\r\nprintk("fd: cannot get irq for timer\n");\r\ngoto out_irq2;\r\n}\r\nret = -ENODEV;\r\nif (fd_probe_drives() < 1)\r\ngoto out_probe;\r\nblk_register_region(MKDEV(FLOPPY_MAJOR, 0), 256, THIS_MODULE,\r\nfloppy_find, NULL, NULL);\r\ninit_timer(&motor_on_timer);\r\nmotor_on_timer.expires = 0;\r\nmotor_on_timer.data = 0;\r\nmotor_on_timer.function = motor_on_callback;\r\nfor (i = 0; i < FD_MAX_UNITS; i++) {\r\ninit_timer(&motor_off_timer[i]);\r\nmotor_off_timer[i].expires = 0;\r\nmotor_off_timer[i].data = i|0x80000000;\r\nmotor_off_timer[i].function = fd_motor_off;\r\ninit_timer(&flush_track_timer[i]);\r\nflush_track_timer[i].expires = 0;\r\nflush_track_timer[i].data = i;\r\nflush_track_timer[i].function = flush_track_callback;\r\nunit[i].track = -1;\r\n}\r\ninit_timer(&post_write_timer);\r\npost_write_timer.expires = 0;\r\npost_write_timer.data = 0;\r\npost_write_timer.function = post_write;\r\nfor (i = 0; i < 128; i++)\r\nmfmdecode[i]=255;\r\nfor (i = 0; i < 16; i++)\r\nmfmdecode[mfmencode[i]]=i;\r\ncustom.dmacon = DMAF_SETCLR | DMAF_DISK;\r\nciaa.crb = 8;\r\nreturn 0;\r\nout_probe:\r\nfree_irq(IRQ_AMIGA_CIAA_TB, NULL);\r\nout_irq2:\r\nfree_irq(IRQ_AMIGA_DSKBLK, NULL);\r\nout_irq:\r\namiga_chip_free(raw_buf);\r\nout_blkdev:\r\nunregister_blkdev(FLOPPY_MAJOR,"fd");\r\nreturn ret;\r\n}\r\nstatic int __init amiga_floppy_init(void)\r\n{\r\nreturn platform_driver_probe(&amiga_floppy_driver, amiga_floppy_probe);\r\n}\r\nstatic int __init amiga_floppy_setup (char *str)\r\n{\r\nint n;\r\nif (!MACH_IS_AMIGA)\r\nreturn 0;\r\nif (!get_option(&str, &n))\r\nreturn 0;\r\nprintk (KERN_INFO "amiflop: Setting default df0 to %x\n", n);\r\nfd_def_df0 = n;\r\nreturn 1;\r\n}
