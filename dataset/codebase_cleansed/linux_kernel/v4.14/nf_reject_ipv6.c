const struct tcphdr *nf_reject_ip6_tcphdr_get(struct sk_buff *oldskb,\r\nstruct tcphdr *otcph,\r\nunsigned int *otcplen, int hook)\r\n{\r\nconst struct ipv6hdr *oip6h = ipv6_hdr(oldskb);\r\nu8 proto;\r\n__be16 frag_off;\r\nint tcphoff;\r\nproto = oip6h->nexthdr;\r\ntcphoff = ipv6_skip_exthdr(oldskb, ((u8 *)(oip6h + 1) - oldskb->data),\r\n&proto, &frag_off);\r\nif ((tcphoff < 0) || (tcphoff > oldskb->len)) {\r\npr_debug("Cannot get TCP header.\n");\r\nreturn NULL;\r\n}\r\n*otcplen = oldskb->len - tcphoff;\r\nif (proto != IPPROTO_TCP || *otcplen < sizeof(struct tcphdr)) {\r\npr_debug("proto(%d) != IPPROTO_TCP or too short (len = %d)\n",\r\nproto, *otcplen);\r\nreturn NULL;\r\n}\r\notcph = skb_header_pointer(oldskb, tcphoff, sizeof(struct tcphdr),\r\notcph);\r\nif (otcph == NULL)\r\nreturn NULL;\r\nif (otcph->rst) {\r\npr_debug("RST is set\n");\r\nreturn NULL;\r\n}\r\nif (nf_ip6_checksum(oldskb, hook, tcphoff, IPPROTO_TCP)) {\r\npr_debug("TCP checksum is invalid\n");\r\nreturn NULL;\r\n}\r\nreturn otcph;\r\n}\r\nstruct ipv6hdr *nf_reject_ip6hdr_put(struct sk_buff *nskb,\r\nconst struct sk_buff *oldskb,\r\n__u8 protocol, int hoplimit)\r\n{\r\nstruct ipv6hdr *ip6h;\r\nconst struct ipv6hdr *oip6h = ipv6_hdr(oldskb);\r\n#define DEFAULT_TOS_VALUE 0x0U\r\nconst __u8 tclass = DEFAULT_TOS_VALUE;\r\nskb_put(nskb, sizeof(struct ipv6hdr));\r\nskb_reset_network_header(nskb);\r\nip6h = ipv6_hdr(nskb);\r\nip6_flow_hdr(ip6h, tclass, 0);\r\nip6h->hop_limit = hoplimit;\r\nip6h->nexthdr = protocol;\r\nip6h->saddr = oip6h->daddr;\r\nip6h->daddr = oip6h->saddr;\r\nnskb->protocol = htons(ETH_P_IPV6);\r\nreturn ip6h;\r\n}\r\nvoid nf_reject_ip6_tcphdr_put(struct sk_buff *nskb,\r\nconst struct sk_buff *oldskb,\r\nconst struct tcphdr *oth, unsigned int otcplen)\r\n{\r\nstruct tcphdr *tcph;\r\nint needs_ack;\r\nskb_reset_transport_header(nskb);\r\ntcph = skb_put(nskb, sizeof(struct tcphdr));\r\ntcph->doff = sizeof(struct tcphdr)/4;\r\ntcph->source = oth->dest;\r\ntcph->dest = oth->source;\r\nif (oth->ack) {\r\nneeds_ack = 0;\r\ntcph->seq = oth->ack_seq;\r\ntcph->ack_seq = 0;\r\n} else {\r\nneeds_ack = 1;\r\ntcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn + oth->fin +\r\notcplen - (oth->doff<<2));\r\ntcph->seq = 0;\r\n}\r\n((u_int8_t *)tcph)[13] = 0;\r\ntcph->rst = 1;\r\ntcph->ack = needs_ack;\r\ntcph->window = 0;\r\ntcph->urg_ptr = 0;\r\ntcph->check = 0;\r\ntcph->check = csum_ipv6_magic(&ipv6_hdr(nskb)->saddr,\r\n&ipv6_hdr(nskb)->daddr,\r\nsizeof(struct tcphdr), IPPROTO_TCP,\r\ncsum_partial(tcph,\r\nsizeof(struct tcphdr), 0));\r\n}\r\nvoid nf_send_reset6(struct net *net, struct sk_buff *oldskb, int hook)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct tcphdr _otcph;\r\nconst struct tcphdr *otcph;\r\nunsigned int otcplen, hh_len;\r\nconst struct ipv6hdr *oip6h = ipv6_hdr(oldskb);\r\nstruct ipv6hdr *ip6h;\r\nstruct dst_entry *dst = NULL;\r\nstruct flowi6 fl6;\r\nif ((!(ipv6_addr_type(&oip6h->saddr) & IPV6_ADDR_UNICAST)) ||\r\n(!(ipv6_addr_type(&oip6h->daddr) & IPV6_ADDR_UNICAST))) {\r\npr_debug("addr is not unicast.\n");\r\nreturn;\r\n}\r\notcph = nf_reject_ip6_tcphdr_get(oldskb, &_otcph, &otcplen, hook);\r\nif (!otcph)\r\nreturn;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nfl6.flowi6_proto = IPPROTO_TCP;\r\nfl6.saddr = oip6h->daddr;\r\nfl6.daddr = oip6h->saddr;\r\nfl6.fl6_sport = otcph->dest;\r\nfl6.fl6_dport = otcph->source;\r\nfl6.flowi6_oif = l3mdev_master_ifindex(skb_dst(oldskb)->dev);\r\nfl6.flowi6_mark = IP6_REPLY_MARK(net, oldskb->mark);\r\nsecurity_skb_classify_flow(oldskb, flowi6_to_flowi(&fl6));\r\ndst = ip6_route_output(net, NULL, &fl6);\r\nif (dst->error) {\r\ndst_release(dst);\r\nreturn;\r\n}\r\ndst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), NULL, 0);\r\nif (IS_ERR(dst))\r\nreturn;\r\nhh_len = (dst->dev->hard_header_len + 15)&~15;\r\nnskb = alloc_skb(hh_len + 15 + dst->header_len + sizeof(struct ipv6hdr)\r\n+ sizeof(struct tcphdr) + dst->trailer_len,\r\nGFP_ATOMIC);\r\nif (!nskb) {\r\nnet_dbg_ratelimited("cannot alloc skb\n");\r\ndst_release(dst);\r\nreturn;\r\n}\r\nskb_dst_set(nskb, dst);\r\nnskb->mark = fl6.flowi6_mark;\r\nskb_reserve(nskb, hh_len + dst->header_len);\r\nip6h = nf_reject_ip6hdr_put(nskb, oldskb, IPPROTO_TCP,\r\nip6_dst_hoplimit(dst));\r\nnf_reject_ip6_tcphdr_put(nskb, oldskb, otcph, otcplen);\r\nnf_ct_attach(nskb, oldskb);\r\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\r\nif (oldskb->nf_bridge) {\r\nstruct ethhdr *oeth = eth_hdr(oldskb);\r\nnskb->dev = nf_bridge_get_physindev(oldskb);\r\nnskb->protocol = htons(ETH_P_IPV6);\r\nip6h->payload_len = htons(sizeof(struct tcphdr));\r\nif (dev_hard_header(nskb, nskb->dev, ntohs(nskb->protocol),\r\noeth->h_source, oeth->h_dest, nskb->len) < 0)\r\nreturn;\r\ndev_queue_xmit(nskb);\r\n} else\r\n#endif\r\nip6_local_out(net, nskb->sk, nskb);\r\n}\r\nstatic bool reject6_csum_ok(struct sk_buff *skb, int hook)\r\n{\r\nconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\r\nint thoff;\r\n__be16 fo;\r\nu8 proto;\r\nif (skb_csum_unnecessary(skb))\r\nreturn true;\r\nproto = ip6h->nexthdr;\r\nthoff = ipv6_skip_exthdr(skb, ((u8 *)(ip6h + 1) - skb->data), &proto, &fo);\r\nif (thoff < 0 || thoff >= skb->len || (fo & htons(~0x7)) != 0)\r\nreturn false;\r\nreturn nf_ip6_checksum(skb, hook, thoff, proto) == 0;\r\n}\r\nvoid nf_send_unreach6(struct net *net, struct sk_buff *skb_in,\r\nunsigned char code, unsigned int hooknum)\r\n{\r\nif (!reject6_csum_ok(skb_in, hooknum))\r\nreturn;\r\nif (hooknum == NF_INET_LOCAL_OUT && skb_in->dev == NULL)\r\nskb_in->dev = net->loopback_dev;\r\nicmpv6_send(skb_in, ICMPV6_DEST_UNREACH, code, 0);\r\n}
