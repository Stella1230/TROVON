static inline struct sierra_net_data *sierra_net_get_private(struct usbnet *dev)\r\n{\r\nreturn (struct sierra_net_data *)dev->data[0];\r\n}\r\nstatic inline void sierra_net_set_private(struct usbnet *dev,\r\nstruct sierra_net_data *priv)\r\n{\r\ndev->data[0] = (unsigned long)priv;\r\n}\r\nstatic inline int is_ip(struct sk_buff *skb)\r\n{\r\nreturn skb->protocol == cpu_to_be16(ETH_P_IP) ||\r\nskb->protocol == cpu_to_be16(ETH_P_IPV6);\r\n}\r\nstatic int check_ethip_packet(struct sk_buff *skb, struct usbnet *dev)\r\n{\r\nskb_reset_mac_header(skb);\r\nif (skb_is_nonlinear(skb)) {\r\nnetdev_err(dev->net, "Non linear buffer-dropping\n");\r\nreturn 0;\r\n}\r\nif (!pskb_may_pull(skb, ETH_HLEN))\r\nreturn 0;\r\nskb->protocol = eth_hdr(skb)->h_proto;\r\nreturn 1;\r\n}\r\nstatic const u8 *save16bit(struct param *p, const u8 *datap)\r\n{\r\np->is_present = 1;\r\np->word = get_unaligned_be16(datap);\r\nreturn datap + sizeof(p->word);\r\n}\r\nstatic const u8 *save8bit(struct param *p, const u8 *datap)\r\n{\r\np->is_present = 1;\r\np->byte = *datap;\r\nreturn datap + sizeof(p->byte);\r\n}\r\nstatic int parse_hip(const u8 *buf, const u32 buflen, struct hip_hdr *hh)\r\n{\r\nconst u8 *curp = buf;\r\nint padded;\r\nif (buflen < SIERRA_NET_HIP_HDR_LEN)\r\nreturn -EPROTO;\r\ncurp = save16bit(&hh->payload_len, curp);\r\ncurp = save8bit(&hh->msgid, curp);\r\ncurp = save8bit(&hh->msgspecific, curp);\r\npadded = hh->msgid.byte & 0x80;\r\nhh->msgid.byte &= 0x7F;\r\nhh->extmsgid.is_present = (hh->msgid.byte == SIERRA_NET_HIP_EXTENDEDID);\r\nif (hh->extmsgid.is_present) {\r\nif (buflen < SIERRA_NET_HIP_EXT_HDR_LEN)\r\nreturn -EPROTO;\r\nhh->payload_len.word &= 0x3FFF;\r\ncurp = save16bit(&hh->extmsgid, curp);\r\nhh->extmsgid.word &= 0x03FF;\r\nhh->hdrlen = SIERRA_NET_HIP_EXT_HDR_LEN;\r\n} else {\r\nhh->payload_len.word &= 0x07FF;\r\nhh->hdrlen = SIERRA_NET_HIP_HDR_LEN;\r\n}\r\nif (padded) {\r\nhh->hdrlen++;\r\nhh->payload_len.word--;\r\n}\r\nif (buflen < (hh->hdrlen + hh->payload_len.word))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void build_hip(u8 *buf, const u16 payloadlen,\r\nstruct sierra_net_data *priv)\r\n{\r\nput_unaligned_be16(payloadlen, buf);\r\nmemcpy(buf+2, priv->tx_hdr_template, sizeof(priv->tx_hdr_template));\r\n}\r\nstatic int sierra_net_send_cmd(struct usbnet *dev,\r\nu8 *cmd, int cmdlen, const char * cmd_name)\r\n{\r\nstruct sierra_net_data *priv = sierra_net_get_private(dev);\r\nint status;\r\nstatus = usbnet_write_cmd(dev, USB_CDC_SEND_ENCAPSULATED_COMMAND,\r\nUSB_DIR_OUT|USB_TYPE_CLASS|USB_RECIP_INTERFACE,\r\n0, priv->ifnum, cmd, cmdlen);\r\nif (status != cmdlen && status != -ENODEV)\r\nnetdev_err(dev->net, "Submit %s failed %d\n", cmd_name, status);\r\nreturn status;\r\n}\r\nstatic int sierra_net_send_sync(struct usbnet *dev)\r\n{\r\nint status;\r\nstruct sierra_net_data *priv = sierra_net_get_private(dev);\r\ndev_dbg(&dev->udev->dev, "%s", __func__);\r\nstatus = sierra_net_send_cmd(dev, priv->sync_msg,\r\nsizeof(priv->sync_msg), "SYNC");\r\nreturn status;\r\n}\r\nstatic void sierra_net_set_ctx_index(struct sierra_net_data *priv, u8 ctx_ix)\r\n{\r\ndev_dbg(&(priv->usbnet->udev->dev), "%s %d", __func__, ctx_ix);\r\npriv->tx_hdr_template[0] = 0x3F;\r\npriv->tx_hdr_template[1] = ctx_ix;\r\n*((__be16 *)&priv->tx_hdr_template[2]) =\r\ncpu_to_be16(SIERRA_NET_HIP_EXT_IP_OUT_ID);\r\n}\r\nstatic inline int sierra_net_is_valid_addrlen(u8 len)\r\n{\r\nreturn len == sizeof(struct in_addr);\r\n}\r\nstatic int sierra_net_parse_lsi(struct usbnet *dev, char *data, int datalen)\r\n{\r\nstruct lsi_umts *lsi = (struct lsi_umts *)data;\r\nu32 expected_length;\r\nif (datalen < sizeof(struct lsi_umts_single)) {\r\nnetdev_err(dev->net, "%s: Data length %d, exp >= %zu\n",\r\n__func__, datalen, sizeof(struct lsi_umts_single));\r\nreturn -1;\r\n}\r\nif (lsi->session_state == SIERRA_NET_SESSION_IDLE) {\r\nnetdev_err(dev->net, "Session idle, 0x%02x\n",\r\nlsi->session_state);\r\nreturn 0;\r\n}\r\nif (lsi->protocol == SIERRA_NET_PROTOCOL_UMTS) {\r\nstruct lsi_umts_single *single = (struct lsi_umts_single *)lsi;\r\nif (single->link_type != SIERRA_NET_AS_LINK_TYPE_IPV4 &&\r\nsingle->link_type != SIERRA_NET_AS_LINK_TYPE_IPV6) {\r\nnetdev_err(dev->net, "Link type unsupported: 0x%02x\n",\r\nsingle->link_type);\r\nreturn -1;\r\n}\r\nexpected_length = SIERRA_NET_LSI_UMTS_STATUS_LEN;\r\n} else if (lsi->protocol == SIERRA_NET_PROTOCOL_UMTS_DS) {\r\nexpected_length = SIERRA_NET_LSI_UMTS_DS_STATUS_LEN;\r\n} else {\r\nnetdev_err(dev->net, "Protocol unsupported, 0x%02x\n",\r\nlsi->protocol);\r\nreturn -1;\r\n}\r\nif (be16_to_cpu(lsi->length) != expected_length) {\r\nnetdev_err(dev->net, "%s: LSI_UMTS_STATUS_LEN %d, exp %u\n",\r\n__func__, be16_to_cpu(lsi->length), expected_length);\r\nreturn -1;\r\n}\r\nif (lsi->coverage == SIERRA_NET_COVERAGE_NONE ||\r\nlsi->coverage == SIERRA_NET_COVERAGE_NOPACKET) {\r\nnetdev_err(dev->net, "No coverage, 0x%02x\n", lsi->coverage);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void sierra_net_handle_lsi(struct usbnet *dev, char *data,\r\nstruct hip_hdr *hh)\r\n{\r\nstruct sierra_net_data *priv = sierra_net_get_private(dev);\r\nint link_up;\r\nlink_up = sierra_net_parse_lsi(dev, data + hh->hdrlen,\r\nhh->payload_len.word);\r\nif (link_up < 0) {\r\nnetdev_err(dev->net, "Invalid LSI\n");\r\nreturn;\r\n}\r\nif (link_up) {\r\nsierra_net_set_ctx_index(priv, hh->msgspecific.byte);\r\npriv->link_up = 1;\r\n} else {\r\npriv->link_up = 0;\r\n}\r\nusbnet_link_change(dev, link_up, 0);\r\n}\r\nstatic void sierra_net_dosync(struct usbnet *dev)\r\n{\r\nint status;\r\nstruct sierra_net_data *priv = sierra_net_get_private(dev);\r\ndev_dbg(&dev->udev->dev, "%s", __func__);\r\nstatus = sierra_net_send_sync(dev);\r\nif (status < 0)\r\nnetdev_err(dev->net,\r\n"Send SYNC failed, status %d\n", status);\r\nstatus = sierra_net_send_sync(dev);\r\nif (status < 0)\r\nnetdev_err(dev->net,\r\n"Send SYNC failed, status %d\n", status);\r\npriv->sync_timer.function = sierra_sync_timer;\r\npriv->sync_timer.data = (unsigned long) dev;\r\npriv->sync_timer.expires = jiffies + SIERRA_NET_SYNCDELAY;\r\nadd_timer(&priv->sync_timer);\r\n}\r\nstatic void sierra_net_kevent(struct work_struct *work)\r\n{\r\nstruct sierra_net_data *priv =\r\ncontainer_of(work, struct sierra_net_data, sierra_net_kevent);\r\nstruct usbnet *dev = priv->usbnet;\r\nint len;\r\nint err;\r\nu8 *buf;\r\nu8 ifnum;\r\nif (test_bit(SIERRA_NET_EVENT_RESP_AVAIL, &priv->kevent_flags)) {\r\nclear_bit(SIERRA_NET_EVENT_RESP_AVAIL, &priv->kevent_flags);\r\nbuf = kzalloc(SIERRA_NET_USBCTL_BUF_LEN, GFP_KERNEL);\r\nif (!buf)\r\nreturn;\r\nifnum = priv->ifnum;\r\nlen = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\r\nUSB_CDC_GET_ENCAPSULATED_RESPONSE,\r\nUSB_DIR_IN|USB_TYPE_CLASS|USB_RECIP_INTERFACE,\r\n0, ifnum, buf, SIERRA_NET_USBCTL_BUF_LEN,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (len < 0) {\r\nnetdev_err(dev->net,\r\n"usb_control_msg failed, status %d\n", len);\r\n} else {\r\nstruct hip_hdr hh;\r\ndev_dbg(&dev->udev->dev, "%s: Received status message,"\r\n" %04x bytes", __func__, len);\r\nerr = parse_hip(buf, len, &hh);\r\nif (err) {\r\nnetdev_err(dev->net, "%s: Bad packet,"\r\n" parse result %d\n", __func__, err);\r\nkfree(buf);\r\nreturn;\r\n}\r\nif (len != hh.hdrlen + hh.payload_len.word) {\r\nnetdev_err(dev->net, "%s: Bad packet, received"\r\n" %d, expected %d\n", __func__, len,\r\nhh.hdrlen + hh.payload_len.word);\r\nkfree(buf);\r\nreturn;\r\n}\r\nswitch (hh.msgid.byte) {\r\ncase SIERRA_NET_HIP_LSI_UMTSID:\r\ndev_dbg(&dev->udev->dev, "LSI for ctx:%d",\r\nhh.msgspecific.byte);\r\nsierra_net_handle_lsi(dev, buf, &hh);\r\nbreak;\r\ncase SIERRA_NET_HIP_RESTART_ID:\r\ndev_dbg(&dev->udev->dev, "Restart reported: %d,"\r\n" stopping sync timer",\r\nhh.msgspecific.byte);\r\ndel_timer_sync(&priv->sync_timer);\r\nclear_bit(SIERRA_NET_TIMER_EXPIRY,\r\n&priv->kevent_flags);\r\nbreak;\r\ncase SIERRA_NET_HIP_HSYNC_ID:\r\ndev_dbg(&dev->udev->dev, "SYNC received");\r\nerr = sierra_net_send_sync(dev);\r\nif (err < 0)\r\nnetdev_err(dev->net,\r\n"Send SYNC failed %d\n", err);\r\nbreak;\r\ncase SIERRA_NET_HIP_EXTENDEDID:\r\nnetdev_err(dev->net, "Unrecognized HIP msg, "\r\n"extmsgid 0x%04x\n", hh.extmsgid.word);\r\nbreak;\r\ncase SIERRA_NET_HIP_RCGI:\r\nbreak;\r\ndefault:\r\nnetdev_err(dev->net, "Unrecognized HIP msg, "\r\n"msgid 0x%02x\n", hh.msgid.byte);\r\nbreak;\r\n}\r\n}\r\nkfree(buf);\r\n}\r\nif (test_bit(SIERRA_NET_TIMER_EXPIRY, &priv->kevent_flags)) {\r\nclear_bit(SIERRA_NET_TIMER_EXPIRY, &priv->kevent_flags);\r\ndev_dbg(&dev->udev->dev, "Deferred sync timer expiry");\r\nsierra_net_dosync(priv->usbnet);\r\n}\r\nif (priv->kevent_flags)\r\ndev_dbg(&dev->udev->dev, "sierra_net_kevent done, "\r\n"kevent_flags = 0x%lx", priv->kevent_flags);\r\n}\r\nstatic void sierra_net_defer_kevent(struct usbnet *dev, int work)\r\n{\r\nstruct sierra_net_data *priv = sierra_net_get_private(dev);\r\nset_bit(work, &priv->kevent_flags);\r\nschedule_work(&priv->sierra_net_kevent);\r\n}\r\nstatic void sierra_sync_timer(unsigned long syncdata)\r\n{\r\nstruct usbnet *dev = (struct usbnet *)syncdata;\r\ndev_dbg(&dev->udev->dev, "%s", __func__);\r\nsierra_net_defer_kevent(dev, SIERRA_NET_TIMER_EXPIRY);\r\n}\r\nstatic void sierra_net_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nstruct usb_cdc_notification *event;\r\ndev_dbg(&dev->udev->dev, "%s", __func__);\r\nif (urb->actual_length < sizeof *event)\r\nreturn;\r\nevent = urb->transfer_buffer;\r\nswitch (event->bNotificationType) {\r\ncase USB_CDC_NOTIFY_NETWORK_CONNECTION:\r\ncase USB_CDC_NOTIFY_SPEED_CHANGE:\r\nbreak;\r\ncase USB_CDC_NOTIFY_RESPONSE_AVAILABLE:\r\nsierra_net_defer_kevent(dev, SIERRA_NET_EVENT_RESP_AVAIL);\r\nbreak;\r\ndefault:\r\nnetdev_err(dev->net, ": unexpected notification %02x!\n",\r\nevent->bNotificationType);\r\nbreak;\r\n}\r\n}\r\nstatic void sierra_net_get_drvinfo(struct net_device *net,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nusbnet_get_drvinfo(net, info);\r\nstrlcpy(info->driver, driver_name, sizeof(info->driver));\r\nstrlcpy(info->version, DRIVER_VERSION, sizeof(info->version));\r\n}\r\nstatic u32 sierra_net_get_link(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nreturn sierra_net_get_private(dev)->link_up && netif_running(net);\r\n}\r\nstatic int sierra_net_get_fw_attr(struct usbnet *dev, u16 *datap)\r\n{\r\nint result = 0;\r\n__le16 attrdata;\r\nresult = usbnet_read_cmd(dev,\r\nSWI_USB_REQUEST_GET_FW_ATTR,\r\nUSB_DIR_IN | USB_TYPE_VENDOR,\r\n0x0000,\r\n0x0000,\r\n&attrdata,\r\nsizeof(attrdata)\r\n);\r\nif (result < 0)\r\nreturn -EIO;\r\n*datap = le16_to_cpu(attrdata);\r\nreturn result;\r\n}\r\nstatic int sierra_net_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nu8 ifacenum;\r\nu8 numendpoints;\r\nu16 fwattr = 0;\r\nint status;\r\nstruct sierra_net_data *priv;\r\nstatic const u8 sync_tmplate[sizeof(priv->sync_msg)] = {\r\n0x00, 0x00, SIERRA_NET_HIP_MSYNC_ID, 0x00};\r\nstatic const u8 shdwn_tmplate[sizeof(priv->shdwn_msg)] = {\r\n0x00, 0x00, SIERRA_NET_HIP_SHUTD_ID, 0x00};\r\ndev_dbg(&dev->udev->dev, "%s", __func__);\r\nifacenum = intf->cur_altsetting->desc.bInterfaceNumber;\r\nnumendpoints = intf->cur_altsetting->desc.bNumEndpoints;\r\nif (numendpoints != 3) {\r\ndev_err(&dev->udev->dev, "Expected 3 endpoints, found: %d",\r\nnumendpoints);\r\nreturn -ENODEV;\r\n}\r\ndev->status = NULL;\r\nstatus = usbnet_get_endpoints(dev, intf);\r\nif (status < 0) {\r\ndev_err(&dev->udev->dev, "Error in usbnet_get_endpoints (%d)",\r\nstatus);\r\nreturn -ENODEV;\r\n}\r\npriv = kzalloc(sizeof *priv, GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->usbnet = dev;\r\npriv->ifnum = ifacenum;\r\ndev->net->netdev_ops = &sierra_net_device_ops;\r\ndev->net->dev_addr[ETH_ALEN-2] = atomic_inc_return(&iface_counter);\r\ndev->net->dev_addr[ETH_ALEN-1] = ifacenum;\r\nmemcpy(priv->shdwn_msg, shdwn_tmplate, sizeof(priv->shdwn_msg));\r\nsierra_net_set_ctx_index(priv, 0);\r\nmemcpy(priv->sync_msg, sync_tmplate, sizeof(priv->sync_msg));\r\ndev->rx_urb_size = SIERRA_NET_RX_URB_SIZE;\r\nif (dev->udev->speed != USB_SPEED_HIGH)\r\ndev->rx_urb_size = min_t(size_t, 4096, SIERRA_NET_RX_URB_SIZE);\r\ndev->net->hard_header_len += SIERRA_NET_HIP_EXT_HDR_LEN;\r\ndev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;\r\ndev->net->max_mtu = SIERRA_NET_MAX_SUPPORTED_MTU;\r\ndev->net->flags |= IFF_NOARP;\r\ndev->net->ethtool_ops = &sierra_net_ethtool_ops;\r\nnetif_carrier_off(dev->net);\r\nsierra_net_set_private(dev, priv);\r\npriv->kevent_flags = 0;\r\nINIT_WORK(&priv->sierra_net_kevent, sierra_net_kevent);\r\ninit_timer(&priv->sync_timer);\r\nstatus = sierra_net_get_fw_attr(dev, &fwattr);\r\ndev_dbg(&dev->udev->dev, "Fw attr: %x\n", fwattr);\r\nif (!(status == sizeof(fwattr) && (fwattr & SWI_GET_FW_ATTR_MASK))) {\r\ndev_err(&dev->udev->dev, "Incompatible driver and firmware"\r\n" versions\n");\r\nkfree(priv);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sierra_net_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint status;\r\nstruct sierra_net_data *priv = sierra_net_get_private(dev);\r\ndev_dbg(&dev->udev->dev, "%s", __func__);\r\ndel_timer_sync(&priv->sync_timer);\r\ncancel_work_sync(&priv->sierra_net_kevent);\r\nstatus = sierra_net_send_cmd(dev, priv->shdwn_msg,\r\nsizeof(priv->shdwn_msg), "Shutdown");\r\nif (status < 0)\r\nnetdev_err(dev->net,\r\n"usb_control_msg failed, status %d\n", status);\r\nusbnet_status_stop(dev);\r\nsierra_net_set_private(dev, NULL);\r\nkfree(priv);\r\n}\r\nstatic struct sk_buff *sierra_net_skb_clone(struct usbnet *dev,\r\nstruct sk_buff *skb, int len)\r\n{\r\nstruct sk_buff *new_skb;\r\nnew_skb = skb_clone(skb, GFP_ATOMIC);\r\nskb_pull(skb, len);\r\nif (new_skb) {\r\nskb_trim(new_skb, len);\r\n} else {\r\nif (netif_msg_rx_err(dev))\r\nnetdev_err(dev->net, "failed to get skb\n");\r\ndev->net->stats.rx_dropped++;\r\n}\r\nreturn new_skb;\r\n}\r\nstatic int sierra_net_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nint err;\r\nstruct hip_hdr hh;\r\nstruct sk_buff *new_skb;\r\ndev_dbg(&dev->udev->dev, "%s", __func__);\r\nwhile (likely(skb->len)) {\r\nerr = parse_hip(skb->data, skb->len, &hh);\r\nif (err) {\r\nif (netif_msg_rx_err(dev))\r\nnetdev_err(dev->net, "Invalid HIP header %d\n",\r\nerr);\r\ndev->net->stats.rx_length_errors++;\r\nreturn 0;\r\n}\r\nif (!hh.extmsgid.is_present\r\n|| hh.extmsgid.word != SIERRA_NET_HIP_EXT_IP_IN_ID) {\r\nif (netif_msg_rx_err(dev))\r\nnetdev_err(dev->net, "HIP/ETH: Invalid pkt\n");\r\ndev->net->stats.rx_frame_errors++;\r\nreturn 0;\r\n}\r\nskb_pull(skb, hh.hdrlen);\r\nskb_reset_mac_header(skb);\r\nif (eth_hdr(skb)->h_proto != cpu_to_be16(ETH_P_IPV6))\r\neth_hdr(skb)->h_proto = cpu_to_be16(ETH_P_IP);\r\neth_zero_addr(eth_hdr(skb)->h_source);\r\nmemcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);\r\nif (hh.payload_len.word == skb->len)\r\nreturn 1;\r\nnew_skb = sierra_net_skb_clone(dev, skb, hh.payload_len.word);\r\nif (new_skb)\r\nusbnet_skb_return(dev, new_skb);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *sierra_net_tx_fixup(struct usbnet *dev,\r\nstruct sk_buff *skb, gfp_t flags)\r\n{\r\nstruct sierra_net_data *priv = sierra_net_get_private(dev);\r\nu16 len;\r\nbool need_tail;\r\nBUILD_BUG_ON(FIELD_SIZEOF(struct usbnet, data)\r\n< sizeof(struct cdc_state));\r\ndev_dbg(&dev->udev->dev, "%s", __func__);\r\nif (priv->link_up && check_ethip_packet(skb, dev) && is_ip(skb)) {\r\nif (SIERRA_NET_HIP_EXT_HDR_LEN <= skb_headroom(skb)) {\r\nlen = skb->len;\r\nskb_push(skb, SIERRA_NET_HIP_EXT_HDR_LEN);\r\nneed_tail = ((len + SIERRA_NET_HIP_EXT_HDR_LEN)\r\n% dev->maxpacket == 0);\r\nif (need_tail) {\r\nif (unlikely(skb_tailroom(skb) == 0)) {\r\nnetdev_err(dev->net, "tx_fixup:"\r\n"no room for packet\n");\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n} else {\r\nskb->data[skb->len] = 0;\r\n__skb_put(skb, 1);\r\nlen = len + 1;\r\n}\r\n}\r\nbuild_hip(skb->data, len, priv);\r\nreturn skb;\r\n} else {\r\nnetdev_err(dev->net, "tx_fixup: no room for HIP\n");\r\n}\r\n}\r\nif (!priv->link_up)\r\ndev->net->stats.tx_carrier_errors++;\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n}\r\nstatic int\r\nsierra_net_probe(struct usb_interface *udev, const struct usb_device_id *prod)\r\n{\r\nint ret;\r\nret = usbnet_probe(udev, prod);\r\nif (ret == 0) {\r\nstruct usbnet *dev = usb_get_intfdata(udev);\r\nret = usbnet_status_start(dev, GFP_KERNEL);\r\nif (ret == 0) {\r\nsierra_net_dosync(dev);\r\n}\r\n}\r\nreturn ret;\r\n}
