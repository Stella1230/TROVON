static int pool_op_gen_alloc(struct tee_shm_pool_mgr *poolm,\r\nstruct tee_shm *shm, size_t size)\r\n{\r\nunsigned long va;\r\nstruct gen_pool *genpool = poolm->private_data;\r\nsize_t s = roundup(size, 1 << genpool->min_alloc_order);\r\nva = gen_pool_alloc(genpool, s);\r\nif (!va)\r\nreturn -ENOMEM;\r\nmemset((void *)va, 0, s);\r\nshm->kaddr = (void *)va;\r\nshm->paddr = gen_pool_virt_to_phys(genpool, va);\r\nshm->size = s;\r\nreturn 0;\r\n}\r\nstatic void pool_op_gen_free(struct tee_shm_pool_mgr *poolm,\r\nstruct tee_shm *shm)\r\n{\r\ngen_pool_free(poolm->private_data, (unsigned long)shm->kaddr,\r\nshm->size);\r\nshm->kaddr = NULL;\r\n}\r\nstatic void pool_res_mem_destroy(struct tee_shm_pool *pool)\r\n{\r\ngen_pool_destroy(pool->private_mgr.private_data);\r\ngen_pool_destroy(pool->dma_buf_mgr.private_data);\r\n}\r\nstatic int pool_res_mem_mgr_init(struct tee_shm_pool_mgr *mgr,\r\nstruct tee_shm_pool_mem_info *info,\r\nint min_alloc_order)\r\n{\r\nsize_t page_mask = PAGE_SIZE - 1;\r\nstruct gen_pool *genpool = NULL;\r\nint rc;\r\nif ((info->vaddr & page_mask) || (info->paddr & page_mask) ||\r\n(info->size & page_mask))\r\nreturn -EINVAL;\r\ngenpool = gen_pool_create(min_alloc_order, -1);\r\nif (!genpool)\r\nreturn -ENOMEM;\r\ngen_pool_set_algo(genpool, gen_pool_best_fit, NULL);\r\nrc = gen_pool_add_virt(genpool, info->vaddr, info->paddr, info->size,\r\n-1);\r\nif (rc) {\r\ngen_pool_destroy(genpool);\r\nreturn rc;\r\n}\r\nmgr->private_data = genpool;\r\nmgr->ops = &pool_ops_generic;\r\nreturn 0;\r\n}\r\nstruct tee_shm_pool *\r\ntee_shm_pool_alloc_res_mem(struct tee_shm_pool_mem_info *priv_info,\r\nstruct tee_shm_pool_mem_info *dmabuf_info)\r\n{\r\nstruct tee_shm_pool *pool = NULL;\r\nint ret;\r\npool = kzalloc(sizeof(*pool), GFP_KERNEL);\r\nif (!pool) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nret = pool_res_mem_mgr_init(&pool->private_mgr, priv_info,\r\n3 );\r\nif (ret)\r\ngoto err;\r\nret = pool_res_mem_mgr_init(&pool->dma_buf_mgr, dmabuf_info,\r\nPAGE_SHIFT);\r\nif (ret)\r\ngoto err;\r\npool->destroy = pool_res_mem_destroy;\r\nreturn pool;\r\nerr:\r\nif (ret == -ENOMEM)\r\npr_err("%s: can't allocate memory for res_mem shared memory pool\n", __func__);\r\nif (pool && pool->private_mgr.private_data)\r\ngen_pool_destroy(pool->private_mgr.private_data);\r\nkfree(pool);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid tee_shm_pool_free(struct tee_shm_pool *pool)\r\n{\r\npool->destroy(pool);\r\nkfree(pool);\r\n}
