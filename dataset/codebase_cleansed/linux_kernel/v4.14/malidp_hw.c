static int malidp500_query_hw(struct malidp_hw_device *hwdev)\r\n{\r\nu32 conf = malidp_hw_read(hwdev, MALIDP500_CONFIG_ID);\r\nu8 ln_size_mult = conf & 0x10 ? 2 : 1;\r\nhwdev->min_line_size = 2;\r\nhwdev->max_line_size = SZ_2K * ln_size_mult;\r\nhwdev->rotation_memory[0] = SZ_1K * 64 * ln_size_mult;\r\nhwdev->rotation_memory[1] = 0;\r\nreturn 0;\r\n}\r\nstatic void malidp500_enter_config_mode(struct malidp_hw_device *hwdev)\r\n{\r\nu32 status, count = 100;\r\nmalidp_hw_setbits(hwdev, MALIDP500_DC_CONFIG_REQ, MALIDP500_DC_CONTROL);\r\nwhile (count) {\r\nstatus = malidp_hw_read(hwdev, hwdev->map.dc_base + MALIDP_REG_STATUS);\r\nif ((status & MALIDP500_DC_CONFIG_REQ) == MALIDP500_DC_CONFIG_REQ)\r\nbreak;\r\nusleep_range(1000, 10000);\r\ncount--;\r\n}\r\nWARN(count == 0, "timeout while entering config mode");\r\n}\r\nstatic void malidp500_leave_config_mode(struct malidp_hw_device *hwdev)\r\n{\r\nu32 status, count = 100;\r\nmalidp_hw_clearbits(hwdev, MALIDP_CFG_VALID, MALIDP500_CONFIG_VALID);\r\nmalidp_hw_clearbits(hwdev, MALIDP500_DC_CONFIG_REQ, MALIDP500_DC_CONTROL);\r\nwhile (count) {\r\nstatus = malidp_hw_read(hwdev, hwdev->map.dc_base + MALIDP_REG_STATUS);\r\nif ((status & MALIDP500_DC_CONFIG_REQ) == 0)\r\nbreak;\r\nusleep_range(100, 1000);\r\ncount--;\r\n}\r\nWARN(count == 0, "timeout while leaving config mode");\r\n}\r\nstatic bool malidp500_in_config_mode(struct malidp_hw_device *hwdev)\r\n{\r\nu32 status;\r\nstatus = malidp_hw_read(hwdev, hwdev->map.dc_base + MALIDP_REG_STATUS);\r\nif ((status & MALIDP500_DC_CONFIG_REQ) == MALIDP500_DC_CONFIG_REQ)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void malidp500_set_config_valid(struct malidp_hw_device *hwdev)\r\n{\r\nmalidp_hw_setbits(hwdev, MALIDP_CFG_VALID, MALIDP500_CONFIG_VALID);\r\n}\r\nstatic void malidp500_modeset(struct malidp_hw_device *hwdev, struct videomode *mode)\r\n{\r\nu32 val = 0;\r\nmalidp_hw_clearbits(hwdev, MALIDP500_DC_CLEAR_MASK, MALIDP500_DC_CONTROL);\r\nif (mode->flags & DISPLAY_FLAGS_HSYNC_HIGH)\r\nval |= MALIDP500_HSYNCPOL;\r\nif (mode->flags & DISPLAY_FLAGS_VSYNC_HIGH)\r\nval |= MALIDP500_VSYNCPOL;\r\nval |= MALIDP_DE_DEFAULT_PREFETCH_START;\r\nmalidp_hw_setbits(hwdev, val, MALIDP500_DC_CONTROL);\r\nval = ((MALIDP_BGND_COLOR_G & 0xfff) << 16) |\r\n(MALIDP_BGND_COLOR_R & 0xfff);\r\nmalidp_hw_write(hwdev, val, MALIDP500_BGND_COLOR);\r\nmalidp_hw_write(hwdev, MALIDP_BGND_COLOR_B, MALIDP500_BGND_COLOR + 4);\r\nval = MALIDP_DE_H_FRONTPORCH(mode->hfront_porch) |\r\nMALIDP_DE_H_BACKPORCH(mode->hback_porch);\r\nmalidp_hw_write(hwdev, val, MALIDP500_TIMINGS_BASE + MALIDP_DE_H_TIMINGS);\r\nval = MALIDP500_DE_V_FRONTPORCH(mode->vfront_porch) |\r\nMALIDP_DE_V_BACKPORCH(mode->vback_porch);\r\nmalidp_hw_write(hwdev, val, MALIDP500_TIMINGS_BASE + MALIDP_DE_V_TIMINGS);\r\nval = MALIDP_DE_H_SYNCWIDTH(mode->hsync_len) |\r\nMALIDP_DE_V_SYNCWIDTH(mode->vsync_len);\r\nmalidp_hw_write(hwdev, val, MALIDP500_TIMINGS_BASE + MALIDP_DE_SYNC_WIDTH);\r\nval = MALIDP_DE_H_ACTIVE(mode->hactive) | MALIDP_DE_V_ACTIVE(mode->vactive);\r\nmalidp_hw_write(hwdev, val, MALIDP500_TIMINGS_BASE + MALIDP_DE_HV_ACTIVE);\r\nif (mode->flags & DISPLAY_FLAGS_INTERLACED)\r\nmalidp_hw_setbits(hwdev, MALIDP_DISP_FUNC_ILACED, MALIDP_DE_DISPLAY_FUNC);\r\nelse\r\nmalidp_hw_clearbits(hwdev, MALIDP_DISP_FUNC_ILACED, MALIDP_DE_DISPLAY_FUNC);\r\n}\r\nstatic int malidp500_rotmem_required(struct malidp_hw_device *hwdev, u16 w, u16 h, u32 fmt)\r\n{\r\nif ((fmt == DRM_FORMAT_RGB888) || (fmt == DRM_FORMAT_BGR888))\r\nreturn -EINVAL;\r\nreturn w * drm_format_plane_cpp(fmt, 0) * 8;\r\n}\r\nstatic void malidp500_se_write_pp_coefftab(struct malidp_hw_device *hwdev,\r\nu32 direction,\r\nu16 addr,\r\nu8 coeffs_id)\r\n{\r\nint i;\r\nu16 scaling_control = MALIDP500_SE_CONTROL + MALIDP_SE_SCALING_CONTROL;\r\nmalidp_hw_write(hwdev,\r\ndirection | (addr & MALIDP_SE_COEFFTAB_ADDR_MASK),\r\nscaling_control + MALIDP_SE_COEFFTAB_ADDR);\r\nfor (i = 0; i < ARRAY_SIZE(dp500_se_scaling_coeffs); ++i)\r\nmalidp_hw_write(hwdev, MALIDP_SE_SET_COEFFTAB_DATA(\r\ndp500_se_scaling_coeffs[coeffs_id][i]),\r\nscaling_control + MALIDP_SE_COEFFTAB_DATA);\r\n}\r\nstatic int malidp500_se_set_scaling_coeffs(struct malidp_hw_device *hwdev,\r\nstruct malidp_se_config *se_config,\r\nstruct malidp_se_config *old_config)\r\n{\r\nu8 h = (u8)se_config->hcoeff - 1;\r\nu8 v = (u8)se_config->vcoeff - 1;\r\nif (WARN_ON(h >= ARRAY_SIZE(dp500_se_scaling_coeffs) ||\r\nv >= ARRAY_SIZE(dp500_se_scaling_coeffs)))\r\nreturn -EINVAL;\r\nif ((h == v) && (se_config->hcoeff != old_config->hcoeff ||\r\nse_config->vcoeff != old_config->vcoeff)) {\r\nmalidp500_se_write_pp_coefftab(hwdev,\r\n(MALIDP_SE_V_COEFFTAB |\r\nMALIDP_SE_H_COEFFTAB),\r\n0, v);\r\n} else {\r\nif (se_config->vcoeff != old_config->vcoeff)\r\nmalidp500_se_write_pp_coefftab(hwdev,\r\nMALIDP_SE_V_COEFFTAB,\r\n0, v);\r\nif (se_config->hcoeff != old_config->hcoeff)\r\nmalidp500_se_write_pp_coefftab(hwdev,\r\nMALIDP_SE_H_COEFFTAB,\r\n0, h);\r\n}\r\nreturn 0;\r\n}\r\nstatic long malidp500_se_calc_mclk(struct malidp_hw_device *hwdev,\r\nstruct malidp_se_config *se_config,\r\nstruct videomode *vm)\r\n{\r\nunsigned long mclk;\r\nunsigned long pxlclk = vm->pixelclock;\r\nunsigned long htotal = vm->hactive + vm->hfront_porch +\r\nvm->hback_porch + vm->hsync_len;\r\nunsigned long input_size = se_config->input_w * se_config->input_h;\r\nunsigned long a = 10;\r\nlong ret;\r\nif (se_config->scale_enable) {\r\na = 15 * input_size / (htotal * se_config->output_h);\r\nif (a < 15)\r\na = 15;\r\n}\r\nmclk = a * pxlclk / 10;\r\nret = clk_get_rate(hwdev->mclk);\r\nif (ret < mclk) {\r\nDRM_DEBUG_DRIVER("mclk requirement of %lu kHz can't be met.\n",\r\nmclk / 1000);\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int malidp550_query_hw(struct malidp_hw_device *hwdev)\r\n{\r\nu32 conf = malidp_hw_read(hwdev, MALIDP550_CONFIG_ID);\r\nu8 ln_size = (conf >> 4) & 0x3, rsize;\r\nhwdev->min_line_size = 2;\r\nswitch (ln_size) {\r\ncase 0:\r\nhwdev->max_line_size = SZ_2K;\r\nrsize = 64;\r\nbreak;\r\ncase 1:\r\nhwdev->max_line_size = SZ_4K;\r\nrsize = 128;\r\nbreak;\r\ncase 2:\r\nhwdev->max_line_size = 1280;\r\nrsize = 40;\r\nbreak;\r\ncase 3:\r\nhwdev->max_line_size = 0;\r\nreturn -EINVAL;\r\n}\r\nhwdev->rotation_memory[0] = hwdev->rotation_memory[1] = rsize * SZ_1K;\r\nreturn 0;\r\n}\r\nstatic void malidp550_enter_config_mode(struct malidp_hw_device *hwdev)\r\n{\r\nu32 status, count = 100;\r\nmalidp_hw_setbits(hwdev, MALIDP550_DC_CONFIG_REQ, MALIDP550_DC_CONTROL);\r\nwhile (count) {\r\nstatus = malidp_hw_read(hwdev, hwdev->map.dc_base + MALIDP_REG_STATUS);\r\nif ((status & MALIDP550_DC_CONFIG_REQ) == MALIDP550_DC_CONFIG_REQ)\r\nbreak;\r\nusleep_range(1000, 10000);\r\ncount--;\r\n}\r\nWARN(count == 0, "timeout while entering config mode");\r\n}\r\nstatic void malidp550_leave_config_mode(struct malidp_hw_device *hwdev)\r\n{\r\nu32 status, count = 100;\r\nmalidp_hw_clearbits(hwdev, MALIDP_CFG_VALID, MALIDP550_CONFIG_VALID);\r\nmalidp_hw_clearbits(hwdev, MALIDP550_DC_CONFIG_REQ, MALIDP550_DC_CONTROL);\r\nwhile (count) {\r\nstatus = malidp_hw_read(hwdev, hwdev->map.dc_base + MALIDP_REG_STATUS);\r\nif ((status & MALIDP550_DC_CONFIG_REQ) == 0)\r\nbreak;\r\nusleep_range(100, 1000);\r\ncount--;\r\n}\r\nWARN(count == 0, "timeout while leaving config mode");\r\n}\r\nstatic bool malidp550_in_config_mode(struct malidp_hw_device *hwdev)\r\n{\r\nu32 status;\r\nstatus = malidp_hw_read(hwdev, hwdev->map.dc_base + MALIDP_REG_STATUS);\r\nif ((status & MALIDP550_DC_CONFIG_REQ) == MALIDP550_DC_CONFIG_REQ)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void malidp550_set_config_valid(struct malidp_hw_device *hwdev)\r\n{\r\nmalidp_hw_setbits(hwdev, MALIDP_CFG_VALID, MALIDP550_CONFIG_VALID);\r\n}\r\nstatic void malidp550_modeset(struct malidp_hw_device *hwdev, struct videomode *mode)\r\n{\r\nu32 val = MALIDP_DE_DEFAULT_PREFETCH_START;\r\nmalidp_hw_write(hwdev, val, MALIDP550_DE_CONTROL);\r\nval = (((MALIDP_BGND_COLOR_R >> 4) & 0xff) << 16) |\r\n(((MALIDP_BGND_COLOR_G >> 4) & 0xff) << 8) |\r\n((MALIDP_BGND_COLOR_B >> 4) & 0xff);\r\nmalidp_hw_write(hwdev, val, MALIDP550_DE_BGND_COLOR);\r\nval = MALIDP_DE_H_FRONTPORCH(mode->hfront_porch) |\r\nMALIDP_DE_H_BACKPORCH(mode->hback_porch);\r\nmalidp_hw_write(hwdev, val, MALIDP550_TIMINGS_BASE + MALIDP_DE_H_TIMINGS);\r\nval = MALIDP550_DE_V_FRONTPORCH(mode->vfront_porch) |\r\nMALIDP_DE_V_BACKPORCH(mode->vback_porch);\r\nmalidp_hw_write(hwdev, val, MALIDP550_TIMINGS_BASE + MALIDP_DE_V_TIMINGS);\r\nval = MALIDP_DE_H_SYNCWIDTH(mode->hsync_len) |\r\nMALIDP_DE_V_SYNCWIDTH(mode->vsync_len);\r\nif (mode->flags & DISPLAY_FLAGS_HSYNC_HIGH)\r\nval |= MALIDP550_HSYNCPOL;\r\nif (mode->flags & DISPLAY_FLAGS_VSYNC_HIGH)\r\nval |= MALIDP550_VSYNCPOL;\r\nmalidp_hw_write(hwdev, val, MALIDP550_TIMINGS_BASE + MALIDP_DE_SYNC_WIDTH);\r\nval = MALIDP_DE_H_ACTIVE(mode->hactive) | MALIDP_DE_V_ACTIVE(mode->vactive);\r\nmalidp_hw_write(hwdev, val, MALIDP550_TIMINGS_BASE + MALIDP_DE_HV_ACTIVE);\r\nif (mode->flags & DISPLAY_FLAGS_INTERLACED)\r\nmalidp_hw_setbits(hwdev, MALIDP_DISP_FUNC_ILACED, MALIDP_DE_DISPLAY_FUNC);\r\nelse\r\nmalidp_hw_clearbits(hwdev, MALIDP_DISP_FUNC_ILACED, MALIDP_DE_DISPLAY_FUNC);\r\n}\r\nstatic int malidp550_rotmem_required(struct malidp_hw_device *hwdev, u16 w, u16 h, u32 fmt)\r\n{\r\nu32 bytes_per_col;\r\nif ((fmt == DRM_FORMAT_RGB888) || (fmt == DRM_FORMAT_BGR888))\r\nreturn -EINVAL;\r\nswitch (fmt) {\r\ncase DRM_FORMAT_ARGB2101010:\r\ncase DRM_FORMAT_ABGR2101010:\r\ncase DRM_FORMAT_RGBA1010102:\r\ncase DRM_FORMAT_BGRA1010102:\r\ncase DRM_FORMAT_ARGB8888:\r\ncase DRM_FORMAT_ABGR8888:\r\ncase DRM_FORMAT_RGBA8888:\r\ncase DRM_FORMAT_BGRA8888:\r\ncase DRM_FORMAT_XRGB8888:\r\ncase DRM_FORMAT_XBGR8888:\r\ncase DRM_FORMAT_RGBX8888:\r\ncase DRM_FORMAT_BGRX8888:\r\ncase DRM_FORMAT_RGB888:\r\ncase DRM_FORMAT_BGR888:\r\ncase DRM_FORMAT_RGBA5551:\r\ncase DRM_FORMAT_ABGR1555:\r\ncase DRM_FORMAT_RGB565:\r\ncase DRM_FORMAT_BGR565:\r\ncase DRM_FORMAT_UYVY:\r\ncase DRM_FORMAT_YUYV:\r\nbytes_per_col = 32;\r\nbreak;\r\ncase DRM_FORMAT_NV12:\r\ncase DRM_FORMAT_YUV420:\r\nbytes_per_col = 24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn w * bytes_per_col;\r\n}\r\nstatic int malidp550_se_set_scaling_coeffs(struct malidp_hw_device *hwdev,\r\nstruct malidp_se_config *se_config,\r\nstruct malidp_se_config *old_config)\r\n{\r\nu32 mask = MALIDP550_SE_CTL_VCSEL(MALIDP550_SE_CTL_SEL_MASK) |\r\nMALIDP550_SE_CTL_HCSEL(MALIDP550_SE_CTL_SEL_MASK);\r\nu32 new_value = MALIDP550_SE_CTL_VCSEL(se_config->vcoeff) |\r\nMALIDP550_SE_CTL_HCSEL(se_config->hcoeff);\r\nmalidp_hw_clearbits(hwdev, mask, MALIDP550_SE_CONTROL);\r\nmalidp_hw_setbits(hwdev, new_value, MALIDP550_SE_CONTROL);\r\nreturn 0;\r\n}\r\nstatic long malidp550_se_calc_mclk(struct malidp_hw_device *hwdev,\r\nstruct malidp_se_config *se_config,\r\nstruct videomode *vm)\r\n{\r\nunsigned long mclk;\r\nunsigned long pxlclk = vm->pixelclock;\r\nunsigned long htotal = vm->hactive + vm->hfront_porch +\r\nvm->hback_porch + vm->hsync_len;\r\nunsigned long numerator = 1, denominator = 1;\r\nlong ret;\r\nif (se_config->scale_enable) {\r\nnumerator = max(se_config->input_w, se_config->output_w) *\r\nse_config->input_h;\r\nnumerator += se_config->output_w *\r\n(se_config->output_h -\r\nmin(se_config->input_h, se_config->output_h));\r\ndenominator = (htotal - 2) * se_config->output_h;\r\n}\r\nif (numerator < denominator)\r\nnumerator = denominator = 1;\r\nmclk = (pxlclk * numerator) / denominator;\r\nret = clk_get_rate(hwdev->mclk);\r\nif (ret < mclk) {\r\nDRM_DEBUG_DRIVER("mclk requirement of %lu kHz can't be met.\n",\r\nmclk / 1000);\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int malidp650_query_hw(struct malidp_hw_device *hwdev)\r\n{\r\nu32 conf = malidp_hw_read(hwdev, MALIDP550_CONFIG_ID);\r\nu8 ln_size = (conf >> 4) & 0x3, rsize;\r\nhwdev->min_line_size = 4;\r\nswitch (ln_size) {\r\ncase 0:\r\ncase 2:\r\nhwdev->max_line_size = 0;\r\nreturn -EINVAL;\r\ncase 1:\r\nhwdev->max_line_size = SZ_4K;\r\nrsize = 128;\r\nbreak;\r\ncase 3:\r\nhwdev->max_line_size = 2560;\r\nrsize = 80;\r\n}\r\nhwdev->rotation_memory[0] = hwdev->rotation_memory[1] = rsize * SZ_1K;\r\nreturn 0;\r\n}\r\nu8 malidp_hw_get_format_id(const struct malidp_hw_regmap *map,\r\nu8 layer_id, u32 format)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < map->n_pixel_formats; i++) {\r\nif (((map->pixel_formats[i].layer & layer_id) == layer_id) &&\r\n(map->pixel_formats[i].format == format))\r\nreturn map->pixel_formats[i].id;\r\n}\r\nreturn MALIDP_INVALID_FORMAT_ID;\r\n}\r\nstatic void malidp_hw_clear_irq(struct malidp_hw_device *hwdev, u8 block, u32 irq)\r\n{\r\nu32 base = malidp_get_block_base(hwdev, block);\r\nif (hwdev->map.features & MALIDP_REGMAP_HAS_CLEARIRQ)\r\nmalidp_hw_write(hwdev, irq, base + MALIDP_REG_CLEARIRQ);\r\nelse\r\nmalidp_hw_write(hwdev, irq, base + MALIDP_REG_STATUS);\r\n}\r\nstatic irqreturn_t malidp_de_irq(int irq, void *arg)\r\n{\r\nstruct drm_device *drm = arg;\r\nstruct malidp_drm *malidp = drm->dev_private;\r\nstruct malidp_hw_device *hwdev;\r\nconst struct malidp_irq_map *de;\r\nu32 status, mask, dc_status;\r\nirqreturn_t ret = IRQ_NONE;\r\nhwdev = malidp->dev;\r\nde = &hwdev->map.de_irq_map;\r\nif (hwdev->pm_suspended)\r\nreturn IRQ_NONE;\r\ndc_status = malidp_hw_read(hwdev, hwdev->map.dc_base + MALIDP_REG_STATUS);\r\nif (dc_status & hwdev->map.dc_irq_map.vsync_irq) {\r\natomic_set(&malidp->config_valid, 1);\r\nmalidp_hw_clear_irq(hwdev, MALIDP_DC_BLOCK, dc_status);\r\nret = IRQ_WAKE_THREAD;\r\n}\r\nstatus = malidp_hw_read(hwdev, MALIDP_REG_STATUS);\r\nif (!(status & de->irq_mask))\r\nreturn ret;\r\nmask = malidp_hw_read(hwdev, MALIDP_REG_MASKIRQ);\r\nstatus &= mask;\r\nif (status & de->vsync_irq)\r\ndrm_crtc_handle_vblank(&malidp->crtc);\r\nmalidp_hw_clear_irq(hwdev, MALIDP_DE_BLOCK, status);\r\nreturn (ret == IRQ_NONE) ? IRQ_HANDLED : ret;\r\n}\r\nstatic irqreturn_t malidp_de_irq_thread_handler(int irq, void *arg)\r\n{\r\nstruct drm_device *drm = arg;\r\nstruct malidp_drm *malidp = drm->dev_private;\r\nwake_up(&malidp->wq);\r\nreturn IRQ_HANDLED;\r\n}\r\nint malidp_de_irq_init(struct drm_device *drm, int irq)\r\n{\r\nstruct malidp_drm *malidp = drm->dev_private;\r\nstruct malidp_hw_device *hwdev = malidp->dev;\r\nint ret;\r\nmalidp_hw_disable_irq(hwdev, MALIDP_DE_BLOCK, 0xffffffff);\r\nmalidp_hw_clear_irq(hwdev, MALIDP_DE_BLOCK, 0xffffffff);\r\nmalidp_hw_disable_irq(hwdev, MALIDP_DC_BLOCK, 0xffffffff);\r\nmalidp_hw_clear_irq(hwdev, MALIDP_DC_BLOCK, 0xffffffff);\r\nret = devm_request_threaded_irq(drm->dev, irq, malidp_de_irq,\r\nmalidp_de_irq_thread_handler,\r\nIRQF_SHARED, "malidp-de", drm);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to install DE IRQ handler\n");\r\nreturn ret;\r\n}\r\nmalidp_hw_enable_irq(hwdev, MALIDP_DC_BLOCK,\r\nhwdev->map.dc_irq_map.irq_mask);\r\nmalidp_hw_enable_irq(hwdev, MALIDP_DE_BLOCK,\r\nhwdev->map.de_irq_map.irq_mask);\r\nreturn 0;\r\n}\r\nvoid malidp_de_irq_fini(struct drm_device *drm)\r\n{\r\nstruct malidp_drm *malidp = drm->dev_private;\r\nstruct malidp_hw_device *hwdev = malidp->dev;\r\nmalidp_hw_disable_irq(hwdev, MALIDP_DE_BLOCK,\r\nhwdev->map.de_irq_map.irq_mask);\r\nmalidp_hw_disable_irq(hwdev, MALIDP_DC_BLOCK,\r\nhwdev->map.dc_irq_map.irq_mask);\r\n}\r\nstatic irqreturn_t malidp_se_irq(int irq, void *arg)\r\n{\r\nstruct drm_device *drm = arg;\r\nstruct malidp_drm *malidp = drm->dev_private;\r\nstruct malidp_hw_device *hwdev = malidp->dev;\r\nu32 status, mask;\r\nif (hwdev->pm_suspended)\r\nreturn IRQ_NONE;\r\nstatus = malidp_hw_read(hwdev, hwdev->map.se_base + MALIDP_REG_STATUS);\r\nif (!(status & hwdev->map.se_irq_map.irq_mask))\r\nreturn IRQ_NONE;\r\nmask = malidp_hw_read(hwdev, hwdev->map.se_base + MALIDP_REG_MASKIRQ);\r\nstatus = malidp_hw_read(hwdev, hwdev->map.se_base + MALIDP_REG_STATUS);\r\nstatus &= mask;\r\nmalidp_hw_clear_irq(hwdev, MALIDP_SE_BLOCK, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t malidp_se_irq_thread_handler(int irq, void *arg)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nint malidp_se_irq_init(struct drm_device *drm, int irq)\r\n{\r\nstruct malidp_drm *malidp = drm->dev_private;\r\nstruct malidp_hw_device *hwdev = malidp->dev;\r\nint ret;\r\nmalidp_hw_disable_irq(hwdev, MALIDP_SE_BLOCK, 0xffffffff);\r\nmalidp_hw_clear_irq(hwdev, MALIDP_SE_BLOCK, 0xffffffff);\r\nret = devm_request_threaded_irq(drm->dev, irq, malidp_se_irq,\r\nmalidp_se_irq_thread_handler,\r\nIRQF_SHARED, "malidp-se", drm);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to install SE IRQ handler\n");\r\nreturn ret;\r\n}\r\nmalidp_hw_enable_irq(hwdev, MALIDP_SE_BLOCK,\r\nhwdev->map.se_irq_map.irq_mask);\r\nreturn 0;\r\n}\r\nvoid malidp_se_irq_fini(struct drm_device *drm)\r\n{\r\nstruct malidp_drm *malidp = drm->dev_private;\r\nstruct malidp_hw_device *hwdev = malidp->dev;\r\nmalidp_hw_disable_irq(hwdev, MALIDP_SE_BLOCK,\r\nhwdev->map.se_irq_map.irq_mask);\r\n}
