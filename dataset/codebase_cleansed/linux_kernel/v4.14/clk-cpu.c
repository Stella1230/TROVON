static const struct rockchip_cpuclk_rate_table *rockchip_get_cpuclk_settings(\r\nstruct rockchip_cpuclk *cpuclk, unsigned long rate)\r\n{\r\nconst struct rockchip_cpuclk_rate_table *rate_table =\r\ncpuclk->rate_table;\r\nint i;\r\nfor (i = 0; i < cpuclk->rate_count; i++) {\r\nif (rate == rate_table[i].prate)\r\nreturn &rate_table[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned long rockchip_cpuclk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct rockchip_cpuclk *cpuclk = to_rockchip_cpuclk_hw(hw);\r\nconst struct rockchip_cpuclk_reg_data *reg_data = cpuclk->reg_data;\r\nu32 clksel0 = readl_relaxed(cpuclk->reg_base + reg_data->core_reg);\r\nclksel0 >>= reg_data->div_core_shift;\r\nclksel0 &= reg_data->div_core_mask;\r\nreturn parent_rate / (clksel0 + 1);\r\n}\r\nstatic void rockchip_cpuclk_set_dividers(struct rockchip_cpuclk *cpuclk,\r\nconst struct rockchip_cpuclk_rate_table *rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(rate->divs); i++) {\r\nconst struct rockchip_cpuclk_clksel *clksel = &rate->divs[i];\r\nif (!clksel->reg)\r\ncontinue;\r\npr_debug("%s: setting reg 0x%x to 0x%x\n",\r\n__func__, clksel->reg, clksel->val);\r\nwritel(clksel->val, cpuclk->reg_base + clksel->reg);\r\n}\r\n}\r\nstatic int rockchip_cpuclk_pre_rate_change(struct rockchip_cpuclk *cpuclk,\r\nstruct clk_notifier_data *ndata)\r\n{\r\nconst struct rockchip_cpuclk_reg_data *reg_data = cpuclk->reg_data;\r\nconst struct rockchip_cpuclk_rate_table *rate;\r\nunsigned long alt_prate, alt_div;\r\nunsigned long flags;\r\nrate = rockchip_get_cpuclk_settings(cpuclk, ndata->new_rate);\r\nif (!rate) {\r\npr_err("%s: Invalid rate : %lu for cpuclk\n",\r\n__func__, ndata->new_rate);\r\nreturn -EINVAL;\r\n}\r\nalt_prate = clk_get_rate(cpuclk->alt_parent);\r\nspin_lock_irqsave(cpuclk->lock, flags);\r\nif (alt_prate > ndata->old_rate) {\r\nalt_div = DIV_ROUND_UP(alt_prate, ndata->old_rate) - 1;\r\nif (alt_div > reg_data->div_core_mask) {\r\npr_warn("%s: limiting alt-divider %lu to %d\n",\r\n__func__, alt_div, reg_data->div_core_mask);\r\nalt_div = reg_data->div_core_mask;\r\n}\r\npr_debug("%s: setting div %lu as alt-rate %lu > old-rate %lu\n",\r\n__func__, alt_div, alt_prate, ndata->old_rate);\r\nwritel(HIWORD_UPDATE(alt_div, reg_data->div_core_mask,\r\nreg_data->div_core_shift) |\r\nHIWORD_UPDATE(reg_data->mux_core_alt,\r\nreg_data->mux_core_mask,\r\nreg_data->mux_core_shift),\r\ncpuclk->reg_base + reg_data->core_reg);\r\n} else {\r\nwritel(HIWORD_UPDATE(reg_data->mux_core_alt,\r\nreg_data->mux_core_mask,\r\nreg_data->mux_core_shift),\r\ncpuclk->reg_base + reg_data->core_reg);\r\n}\r\nspin_unlock_irqrestore(cpuclk->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int rockchip_cpuclk_post_rate_change(struct rockchip_cpuclk *cpuclk,\r\nstruct clk_notifier_data *ndata)\r\n{\r\nconst struct rockchip_cpuclk_reg_data *reg_data = cpuclk->reg_data;\r\nconst struct rockchip_cpuclk_rate_table *rate;\r\nunsigned long flags;\r\nrate = rockchip_get_cpuclk_settings(cpuclk, ndata->new_rate);\r\nif (!rate) {\r\npr_err("%s: Invalid rate : %lu for cpuclk\n",\r\n__func__, ndata->new_rate);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(cpuclk->lock, flags);\r\nif (ndata->old_rate < ndata->new_rate)\r\nrockchip_cpuclk_set_dividers(cpuclk, rate);\r\nwritel(HIWORD_UPDATE(0, reg_data->div_core_mask,\r\nreg_data->div_core_shift) |\r\nHIWORD_UPDATE(reg_data->mux_core_main,\r\nreg_data->mux_core_mask,\r\nreg_data->mux_core_shift),\r\ncpuclk->reg_base + reg_data->core_reg);\r\nif (ndata->old_rate > ndata->new_rate)\r\nrockchip_cpuclk_set_dividers(cpuclk, rate);\r\nspin_unlock_irqrestore(cpuclk->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int rockchip_cpuclk_notifier_cb(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct clk_notifier_data *ndata = data;\r\nstruct rockchip_cpuclk *cpuclk = to_rockchip_cpuclk_nb(nb);\r\nint ret = 0;\r\npr_debug("%s: event %lu, old_rate %lu, new_rate: %lu\n",\r\n__func__, event, ndata->old_rate, ndata->new_rate);\r\nif (event == PRE_RATE_CHANGE)\r\nret = rockchip_cpuclk_pre_rate_change(cpuclk, ndata);\r\nelse if (event == POST_RATE_CHANGE)\r\nret = rockchip_cpuclk_post_rate_change(cpuclk, ndata);\r\nreturn notifier_from_errno(ret);\r\n}\r\nstruct clk *rockchip_clk_register_cpuclk(const char *name,\r\nconst char *const *parent_names, u8 num_parents,\r\nconst struct rockchip_cpuclk_reg_data *reg_data,\r\nconst struct rockchip_cpuclk_rate_table *rates,\r\nint nrates, void __iomem *reg_base, spinlock_t *lock)\r\n{\r\nstruct rockchip_cpuclk *cpuclk;\r\nstruct clk_init_data init;\r\nstruct clk *clk, *cclk;\r\nint ret;\r\nif (num_parents < 2) {\r\npr_err("%s: needs at least two parent clocks\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ncpuclk = kzalloc(sizeof(*cpuclk), GFP_KERNEL);\r\nif (!cpuclk)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.parent_names = &parent_names[reg_data->mux_core_main];\r\ninit.num_parents = 1;\r\ninit.ops = &rockchip_cpuclk_ops;\r\ninit.flags = (nrates > 0) ? CLK_SET_RATE_PARENT : 0;\r\ninit.flags |= CLK_SET_RATE_NO_REPARENT;\r\ninit.flags |= CLK_GET_RATE_NOCACHE;\r\ncpuclk->reg_base = reg_base;\r\ncpuclk->lock = lock;\r\ncpuclk->reg_data = reg_data;\r\ncpuclk->clk_nb.notifier_call = rockchip_cpuclk_notifier_cb;\r\ncpuclk->hw.init = &init;\r\ncpuclk->alt_parent = __clk_lookup(parent_names[reg_data->mux_core_alt]);\r\nif (!cpuclk->alt_parent) {\r\npr_err("%s: could not lookup alternate parent: (%d)\n",\r\n__func__, reg_data->mux_core_alt);\r\nret = -EINVAL;\r\ngoto free_cpuclk;\r\n}\r\nret = clk_prepare_enable(cpuclk->alt_parent);\r\nif (ret) {\r\npr_err("%s: could not enable alternate parent\n",\r\n__func__);\r\ngoto free_cpuclk;\r\n}\r\nclk = __clk_lookup(parent_names[reg_data->mux_core_main]);\r\nif (!clk) {\r\npr_err("%s: could not lookup parent clock: (%d) %s\n",\r\n__func__, reg_data->mux_core_main,\r\nparent_names[reg_data->mux_core_main]);\r\nret = -EINVAL;\r\ngoto free_alt_parent;\r\n}\r\nret = clk_notifier_register(clk, &cpuclk->clk_nb);\r\nif (ret) {\r\npr_err("%s: failed to register clock notifier for %s\n",\r\n__func__, name);\r\ngoto free_alt_parent;\r\n}\r\nif (nrates > 0) {\r\ncpuclk->rate_count = nrates;\r\ncpuclk->rate_table = kmemdup(rates,\r\nsizeof(*rates) * nrates,\r\nGFP_KERNEL);\r\nif (!cpuclk->rate_table) {\r\npr_err("%s: could not allocate memory for cpuclk rates\n",\r\n__func__);\r\nret = -ENOMEM;\r\ngoto unregister_notifier;\r\n}\r\n}\r\ncclk = clk_register(NULL, &cpuclk->hw);\r\nif (IS_ERR(cclk)) {\r\npr_err("%s: could not register cpuclk %s\n", __func__, name);\r\nret = PTR_ERR(cclk);\r\ngoto free_rate_table;\r\n}\r\nreturn cclk;\r\nfree_rate_table:\r\nkfree(cpuclk->rate_table);\r\nunregister_notifier:\r\nclk_notifier_unregister(clk, &cpuclk->clk_nb);\r\nfree_alt_parent:\r\nclk_disable_unprepare(cpuclk->alt_parent);\r\nfree_cpuclk:\r\nkfree(cpuclk);\r\nreturn ERR_PTR(ret);\r\n}
