static int mxs_lradc_adc_read_single(struct iio_dev *iio_dev, int chan,\r\nint *val)\r\n{\r\nstruct mxs_lradc_adc *adc = iio_priv(iio_dev);\r\nstruct mxs_lradc *lradc = adc->lradc;\r\nint ret;\r\nret = iio_device_claim_direct_mode(iio_dev);\r\nif (ret)\r\nreturn ret;\r\nreinit_completion(&adc->completion);\r\nif (lradc->soc == IMX28_LRADC)\r\nwritel(LRADC_CTRL1_LRADC_IRQ_EN(0),\r\nadc->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\r\nwritel(0x1, adc->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);\r\nif (test_bit(chan, &adc->is_divided))\r\nwritel(1 << LRADC_CTRL2_DIVIDE_BY_TWO_OFFSET,\r\nadc->base + LRADC_CTRL2 + STMP_OFFSET_REG_SET);\r\nelse\r\nwritel(1 << LRADC_CTRL2_DIVIDE_BY_TWO_OFFSET,\r\nadc->base + LRADC_CTRL2 + STMP_OFFSET_REG_CLR);\r\nwritel(LRADC_CTRL4_LRADCSELECT_MASK(0),\r\nadc->base + LRADC_CTRL4 + STMP_OFFSET_REG_CLR);\r\nwritel(chan, adc->base + LRADC_CTRL4 + STMP_OFFSET_REG_SET);\r\nwritel(0, adc->base + LRADC_CH(0));\r\nwritel(LRADC_CTRL1_LRADC_IRQ_EN(0),\r\nadc->base + LRADC_CTRL1 + STMP_OFFSET_REG_SET);\r\nwritel(BIT(0), adc->base + LRADC_CTRL0 + STMP_OFFSET_REG_SET);\r\nret = wait_for_completion_killable_timeout(&adc->completion, HZ);\r\nif (!ret)\r\nret = -ETIMEDOUT;\r\nif (ret < 0)\r\ngoto err;\r\n*val = readl(adc->base + LRADC_CH(0)) & LRADC_CH_VALUE_MASK;\r\nret = IIO_VAL_INT;\r\nerr:\r\nwritel(LRADC_CTRL1_LRADC_IRQ_EN(0),\r\nadc->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\r\niio_device_release_direct_mode(iio_dev);\r\nreturn ret;\r\n}\r\nstatic int mxs_lradc_adc_read_temp(struct iio_dev *iio_dev, int *val)\r\n{\r\nint ret, min, max;\r\nret = mxs_lradc_adc_read_single(iio_dev, 8, &min);\r\nif (ret != IIO_VAL_INT)\r\nreturn ret;\r\nret = mxs_lradc_adc_read_single(iio_dev, 9, &max);\r\nif (ret != IIO_VAL_INT)\r\nreturn ret;\r\n*val = max - min;\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int mxs_lradc_adc_read_raw(struct iio_dev *iio_dev,\r\nconst struct iio_chan_spec *chan,\r\nint *val, int *val2, long m)\r\n{\r\nstruct mxs_lradc_adc *adc = iio_priv(iio_dev);\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (chan->type == IIO_TEMP)\r\nreturn mxs_lradc_adc_read_temp(iio_dev, val);\r\nreturn mxs_lradc_adc_read_single(iio_dev, chan->channel, val);\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (chan->type == IIO_TEMP) {\r\n*val = 0;\r\n*val2 = 253000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\n*val = adc->vref_mv[chan->channel];\r\n*val2 = chan->scan_type.realbits -\r\ntest_bit(chan->channel, &adc->is_divided);\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ncase IIO_CHAN_INFO_OFFSET:\r\nif (chan->type == IIO_TEMP) {\r\n*val = -1079;\r\n*val2 = 644268;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nreturn -EINVAL;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mxs_lradc_adc_write_raw(struct iio_dev *iio_dev,\r\nconst struct iio_chan_spec *chan,\r\nint val, int val2, long m)\r\n{\r\nstruct mxs_lradc_adc *adc = iio_priv(iio_dev);\r\nstruct mxs_lradc_scale *scale_avail =\r\nadc->scale_avail[chan->channel];\r\nint ret;\r\nret = iio_device_claim_direct_mode(iio_dev);\r\nif (ret)\r\nreturn ret;\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nret = -EINVAL;\r\nif (val == scale_avail[MXS_LRADC_DIV_DISABLED].integer &&\r\nval2 == scale_avail[MXS_LRADC_DIV_DISABLED].nano) {\r\nclear_bit(chan->channel, &adc->is_divided);\r\nret = 0;\r\n} else if (val == scale_avail[MXS_LRADC_DIV_ENABLED].integer &&\r\nval2 == scale_avail[MXS_LRADC_DIV_ENABLED].nano) {\r\nset_bit(chan->channel, &adc->is_divided);\r\nret = 0;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\niio_device_release_direct_mode(iio_dev);\r\nreturn ret;\r\n}\r\nstatic int mxs_lradc_adc_write_raw_get_fmt(struct iio_dev *iio_dev,\r\nconst struct iio_chan_spec *chan,\r\nlong m)\r\n{\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\n}\r\nstatic ssize_t mxs_lradc_adc_show_scale_avail(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *iio = dev_to_iio_dev(dev);\r\nstruct mxs_lradc_adc *adc = iio_priv(iio);\r\nstruct iio_dev_attr *iio_attr = to_iio_dev_attr(attr);\r\nint i, ch, len = 0;\r\nch = iio_attr->address;\r\nfor (i = 0; i < ARRAY_SIZE(adc->scale_avail[ch]); i++)\r\nlen += sprintf(buf + len, "%u.%09u ",\r\nadc->scale_avail[ch][i].integer,\r\nadc->scale_avail[ch][i].nano);\r\nlen += sprintf(buf + len, "\n");\r\nreturn len;\r\n}\r\nstatic irqreturn_t mxs_lradc_adc_handle_irq(int irq, void *data)\r\n{\r\nstruct iio_dev *iio = data;\r\nstruct mxs_lradc_adc *adc = iio_priv(iio);\r\nstruct mxs_lradc *lradc = adc->lradc;\r\nunsigned long reg = readl(adc->base + LRADC_CTRL1);\r\nunsigned long flags;\r\nif (!(reg & mxs_lradc_irq_mask(lradc)))\r\nreturn IRQ_NONE;\r\nif (iio_buffer_enabled(iio)) {\r\nif (reg & lradc->buffer_vchans) {\r\nspin_lock_irqsave(&adc->lock, flags);\r\niio_trigger_poll(iio->trig);\r\nspin_unlock_irqrestore(&adc->lock, flags);\r\n}\r\n} else if (reg & LRADC_CTRL1_LRADC_IRQ(0)) {\r\ncomplete(&adc->completion);\r\n}\r\nwritel(reg & mxs_lradc_irq_mask(lradc),\r\nadc->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mxs_lradc_adc_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *iio = pf->indio_dev;\r\nstruct mxs_lradc_adc *adc = iio_priv(iio);\r\nconst u32 chan_value = LRADC_CH_ACCUMULATE |\r\n((LRADC_DELAY_TIMER_LOOP - 1) << LRADC_CH_NUM_SAMPLES_OFFSET);\r\nunsigned int i, j = 0;\r\nfor_each_set_bit(i, iio->active_scan_mask, LRADC_MAX_TOTAL_CHANS) {\r\nadc->buffer[j] = readl(adc->base + LRADC_CH(j));\r\nwritel(chan_value, adc->base + LRADC_CH(j));\r\nadc->buffer[j] &= LRADC_CH_VALUE_MASK;\r\nadc->buffer[j] /= LRADC_DELAY_TIMER_LOOP;\r\nj++;\r\n}\r\niio_push_to_buffers_with_timestamp(iio, adc->buffer, pf->timestamp);\r\niio_trigger_notify_done(iio->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mxs_lradc_adc_configure_trigger(struct iio_trigger *trig, bool state)\r\n{\r\nstruct iio_dev *iio = iio_trigger_get_drvdata(trig);\r\nstruct mxs_lradc_adc *adc = iio_priv(iio);\r\nconst u32 st = state ? STMP_OFFSET_REG_SET : STMP_OFFSET_REG_CLR;\r\nwritel(LRADC_DELAY_KICK, adc->base + (LRADC_DELAY(0) + st));\r\nreturn 0;\r\n}\r\nstatic int mxs_lradc_adc_trigger_init(struct iio_dev *iio)\r\n{\r\nint ret;\r\nstruct iio_trigger *trig;\r\nstruct mxs_lradc_adc *adc = iio_priv(iio);\r\ntrig = devm_iio_trigger_alloc(&iio->dev, "%s-dev%i", iio->name,\r\niio->id);\r\ntrig->dev.parent = adc->dev;\r\niio_trigger_set_drvdata(trig, iio);\r\ntrig->ops = &mxs_lradc_adc_trigger_ops;\r\nret = iio_trigger_register(trig);\r\nif (ret)\r\nreturn ret;\r\nadc->trig = trig;\r\nreturn 0;\r\n}\r\nstatic void mxs_lradc_adc_trigger_remove(struct iio_dev *iio)\r\n{\r\nstruct mxs_lradc_adc *adc = iio_priv(iio);\r\niio_trigger_unregister(adc->trig);\r\n}\r\nstatic int mxs_lradc_adc_buffer_preenable(struct iio_dev *iio)\r\n{\r\nstruct mxs_lradc_adc *adc = iio_priv(iio);\r\nstruct mxs_lradc *lradc = adc->lradc;\r\nint chan, ofs = 0;\r\nunsigned long enable = 0;\r\nu32 ctrl4_set = 0;\r\nu32 ctrl4_clr = 0;\r\nu32 ctrl1_irq = 0;\r\nconst u32 chan_value = LRADC_CH_ACCUMULATE |\r\n((LRADC_DELAY_TIMER_LOOP - 1) << LRADC_CH_NUM_SAMPLES_OFFSET);\r\nif (lradc->soc == IMX28_LRADC)\r\nwritel(lradc->buffer_vchans << LRADC_CTRL1_LRADC_IRQ_EN_OFFSET,\r\nadc->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\r\nwritel(lradc->buffer_vchans,\r\nadc->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);\r\nfor_each_set_bit(chan, iio->active_scan_mask, LRADC_MAX_TOTAL_CHANS) {\r\nctrl4_set |= chan << LRADC_CTRL4_LRADCSELECT_OFFSET(ofs);\r\nctrl4_clr |= LRADC_CTRL4_LRADCSELECT_MASK(ofs);\r\nctrl1_irq |= LRADC_CTRL1_LRADC_IRQ_EN(ofs);\r\nwritel(chan_value, adc->base + LRADC_CH(ofs));\r\nbitmap_set(&enable, ofs, 1);\r\nofs++;\r\n}\r\nwritel(LRADC_DELAY_TRIGGER_LRADCS_MASK | LRADC_DELAY_KICK,\r\nadc->base + LRADC_DELAY(0) + STMP_OFFSET_REG_CLR);\r\nwritel(ctrl4_clr, adc->base + LRADC_CTRL4 + STMP_OFFSET_REG_CLR);\r\nwritel(ctrl4_set, adc->base + LRADC_CTRL4 + STMP_OFFSET_REG_SET);\r\nwritel(ctrl1_irq, adc->base + LRADC_CTRL1 + STMP_OFFSET_REG_SET);\r\nwritel(enable << LRADC_DELAY_TRIGGER_LRADCS_OFFSET,\r\nadc->base + LRADC_DELAY(0) + STMP_OFFSET_REG_SET);\r\nreturn 0;\r\n}\r\nstatic int mxs_lradc_adc_buffer_postdisable(struct iio_dev *iio)\r\n{\r\nstruct mxs_lradc_adc *adc = iio_priv(iio);\r\nstruct mxs_lradc *lradc = adc->lradc;\r\nwritel(LRADC_DELAY_TRIGGER_LRADCS_MASK | LRADC_DELAY_KICK,\r\nadc->base + LRADC_DELAY(0) + STMP_OFFSET_REG_CLR);\r\nwritel(lradc->buffer_vchans,\r\nadc->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);\r\nif (lradc->soc == IMX28_LRADC)\r\nwritel(lradc->buffer_vchans << LRADC_CTRL1_LRADC_IRQ_EN_OFFSET,\r\nadc->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\r\nreturn 0;\r\n}\r\nstatic bool mxs_lradc_adc_validate_scan_mask(struct iio_dev *iio,\r\nconst unsigned long *mask)\r\n{\r\nstruct mxs_lradc_adc *adc = iio_priv(iio);\r\nstruct mxs_lradc *lradc = adc->lradc;\r\nconst int map_chans = bitmap_weight(mask, LRADC_MAX_TOTAL_CHANS);\r\nint rsvd_chans = 0;\r\nunsigned long rsvd_mask = 0;\r\nif (lradc->use_touchbutton)\r\nrsvd_mask |= CHAN_MASK_TOUCHBUTTON;\r\nif (lradc->touchscreen_wire == MXS_LRADC_TOUCHSCREEN_4WIRE)\r\nrsvd_mask |= CHAN_MASK_TOUCHSCREEN_4WIRE;\r\nif (lradc->touchscreen_wire == MXS_LRADC_TOUCHSCREEN_5WIRE)\r\nrsvd_mask |= CHAN_MASK_TOUCHSCREEN_5WIRE;\r\nif (lradc->use_touchbutton)\r\nrsvd_chans++;\r\nif (lradc->touchscreen_wire)\r\nrsvd_chans += 2;\r\nif (bitmap_intersects(mask, &rsvd_mask, LRADC_MAX_TOTAL_CHANS))\r\nreturn false;\r\nif (map_chans + rsvd_chans > LRADC_MAX_MAPPED_CHANS)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void mxs_lradc_adc_hw_init(struct mxs_lradc_adc *adc)\r\n{\r\nconst u32 adc_cfg =\r\n(1 << (LRADC_DELAY_TRIGGER_DELAYS_OFFSET + 0)) |\r\n(LRADC_DELAY_TIMER_PER << LRADC_DELAY_DELAY_OFFSET);\r\nwritel(adc_cfg, adc->base + LRADC_DELAY(0));\r\nwritel(0, adc->base + LRADC_CTRL2);\r\n}\r\nstatic void mxs_lradc_adc_hw_stop(struct mxs_lradc_adc *adc)\r\n{\r\nwritel(0, adc->base + LRADC_DELAY(0));\r\n}\r\nstatic int mxs_lradc_adc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mxs_lradc *lradc = dev_get_drvdata(dev->parent);\r\nstruct mxs_lradc_adc *adc;\r\nstruct iio_dev *iio;\r\nstruct resource *iores;\r\nint ret, irq, virq, i, s, n;\r\nu64 scale_uv;\r\nconst char **irq_name;\r\niio = devm_iio_device_alloc(dev, sizeof(*adc));\r\nif (!iio) {\r\ndev_err(dev, "Failed to allocate IIO device\n");\r\nreturn -ENOMEM;\r\n}\r\nadc = iio_priv(iio);\r\nadc->lradc = lradc;\r\nadc->dev = dev;\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!iores)\r\nreturn -EINVAL;\r\nadc->base = devm_ioremap(dev, iores->start, resource_size(iores));\r\nif (!adc->base)\r\nreturn -ENOMEM;\r\ninit_completion(&adc->completion);\r\nspin_lock_init(&adc->lock);\r\nplatform_set_drvdata(pdev, iio);\r\niio->name = pdev->name;\r\niio->dev.parent = dev;\r\niio->dev.of_node = dev->parent->of_node;\r\niio->info = &mxs_lradc_adc_iio_info;\r\niio->modes = INDIO_DIRECT_MODE;\r\niio->masklength = LRADC_MAX_TOTAL_CHANS;\r\nif (lradc->soc == IMX23_LRADC) {\r\niio->channels = mx23_lradc_chan_spec;\r\niio->num_channels = ARRAY_SIZE(mx23_lradc_chan_spec);\r\nirq_name = mx23_lradc_adc_irq_names;\r\nn = ARRAY_SIZE(mx23_lradc_adc_irq_names);\r\n} else {\r\niio->channels = mx28_lradc_chan_spec;\r\niio->num_channels = ARRAY_SIZE(mx28_lradc_chan_spec);\r\nirq_name = mx28_lradc_adc_irq_names;\r\nn = ARRAY_SIZE(mx28_lradc_adc_irq_names);\r\n}\r\nret = stmp_reset_block(adc->base);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < n; i++) {\r\nirq = platform_get_irq_byname(pdev, irq_name[i]);\r\nif (irq < 0)\r\nreturn irq;\r\nvirq = irq_of_parse_and_map(dev->parent->of_node, irq);\r\nret = devm_request_irq(dev, virq, mxs_lradc_adc_handle_irq,\r\n0, irq_name[i], iio);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = mxs_lradc_adc_trigger_init(iio);\r\nif (ret)\r\ngoto err_trig;\r\nret = iio_triggered_buffer_setup(iio, &iio_pollfunc_store_time,\r\n&mxs_lradc_adc_trigger_handler,\r\n&mxs_lradc_adc_buffer_ops);\r\nif (ret)\r\nreturn ret;\r\nadc->vref_mv = mxs_lradc_adc_vref_mv[lradc->soc];\r\nfor (i = 0; i < LRADC_MAX_TOTAL_CHANS; i++) {\r\nfor (s = 0; s < ARRAY_SIZE(adc->scale_avail[i]); s++) {\r\nscale_uv = ((u64)adc->vref_mv[i] * 100000000) >>\r\n(LRADC_RESOLUTION - s);\r\nadc->scale_avail[i][s].nano =\r\ndo_div(scale_uv, 100000000) * 10;\r\nadc->scale_avail[i][s].integer = scale_uv;\r\n}\r\n}\r\nmxs_lradc_adc_hw_init(adc);\r\nret = iio_device_register(iio);\r\nif (ret) {\r\ndev_err(dev, "Failed to register IIO device\n");\r\ngoto err_dev;\r\n}\r\nreturn 0;\r\nerr_dev:\r\nmxs_lradc_adc_hw_stop(adc);\r\nmxs_lradc_adc_trigger_remove(iio);\r\nerr_trig:\r\niio_triggered_buffer_cleanup(iio);\r\nreturn ret;\r\n}\r\nstatic int mxs_lradc_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *iio = platform_get_drvdata(pdev);\r\nstruct mxs_lradc_adc *adc = iio_priv(iio);\r\niio_device_unregister(iio);\r\nmxs_lradc_adc_hw_stop(adc);\r\nmxs_lradc_adc_trigger_remove(iio);\r\niio_triggered_buffer_cleanup(iio);\r\nreturn 0;\r\n}
