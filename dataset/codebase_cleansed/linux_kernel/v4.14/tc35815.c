static inline dma_addr_t fd_virt_to_bus(struct tc35815_local *lp, void *virt)\r\n{\r\nreturn lp->fd_buf_dma + ((u8 *)virt - (u8 *)lp->fd_buf);\r\n}\r\nstatic inline void *fd_bus_to_virt(struct tc35815_local *lp, dma_addr_t bus)\r\n{\r\nreturn (void *)((u8 *)lp->fd_buf + (bus - lp->fd_buf_dma));\r\n}\r\nstatic struct sk_buff *alloc_rxbuf_skb(struct net_device *dev,\r\nstruct pci_dev *hwdev,\r\ndma_addr_t *dma_handle)\r\n{\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb(dev, RX_BUF_SIZE);\r\nif (!skb)\r\nreturn NULL;\r\n*dma_handle = pci_map_single(hwdev, skb->data, RX_BUF_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(hwdev, *dma_handle)) {\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n}\r\nskb_reserve(skb, 2);\r\nreturn skb;\r\n}\r\nstatic void free_rxbuf_skb(struct pci_dev *hwdev, struct sk_buff *skb, dma_addr_t dma_handle)\r\n{\r\npci_unmap_single(hwdev, dma_handle, RX_BUF_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic int tc_mdio_read(struct mii_bus *bus, int mii_id, int regnum)\r\n{\r\nstruct net_device *dev = bus->priv;\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\nunsigned long timeout = jiffies + HZ;\r\ntc_writel(MD_CA_Busy | (mii_id << 5) | (regnum & 0x1f), &tr->MD_CA);\r\nudelay(12);\r\nwhile (tc_readl(&tr->MD_CA) & MD_CA_Busy) {\r\nif (time_after(jiffies, timeout))\r\nreturn -EIO;\r\ncpu_relax();\r\n}\r\nreturn tc_readl(&tr->MD_Data) & 0xffff;\r\n}\r\nstatic int tc_mdio_write(struct mii_bus *bus, int mii_id, int regnum, u16 val)\r\n{\r\nstruct net_device *dev = bus->priv;\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\nunsigned long timeout = jiffies + HZ;\r\ntc_writel(val, &tr->MD_Data);\r\ntc_writel(MD_CA_Busy | MD_CA_Wr | (mii_id << 5) | (regnum & 0x1f),\r\n&tr->MD_CA);\r\nudelay(12);\r\nwhile (tc_readl(&tr->MD_CA) & MD_CA_Busy) {\r\nif (time_after(jiffies, timeout))\r\nreturn -EIO;\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nstatic void tc_handle_link_change(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nstruct phy_device *phydev = dev->phydev;\r\nunsigned long flags;\r\nint status_change = 0;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif (phydev->link &&\r\n(lp->speed != phydev->speed || lp->duplex != phydev->duplex)) {\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\nu32 reg;\r\nreg = tc_readl(&tr->MAC_Ctl);\r\nreg |= MAC_HaltReq;\r\ntc_writel(reg, &tr->MAC_Ctl);\r\nif (phydev->duplex == DUPLEX_FULL)\r\nreg |= MAC_FullDup;\r\nelse\r\nreg &= ~MAC_FullDup;\r\ntc_writel(reg, &tr->MAC_Ctl);\r\nreg &= ~MAC_HaltReq;\r\ntc_writel(reg, &tr->MAC_Ctl);\r\nif (phydev->duplex == DUPLEX_HALF &&\r\nlp->chiptype != TC35815_TX4939)\r\ntc_writel(tc_readl(&tr->Tx_Ctl) | Tx_EnLCarr,\r\n&tr->Tx_Ctl);\r\nlp->speed = phydev->speed;\r\nlp->duplex = phydev->duplex;\r\nstatus_change = 1;\r\n}\r\nif (phydev->link != lp->link) {\r\nif (phydev->link) {\r\nif (dev->flags & IFF_PROMISC)\r\ntc35815_set_multicast_list(dev);\r\n} else {\r\nlp->speed = 0;\r\nlp->duplex = -1;\r\n}\r\nlp->link = phydev->link;\r\nstatus_change = 1;\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nif (status_change && netif_msg_link(lp)) {\r\nphy_print_status(phydev);\r\npr_debug("%s: MII BMCR %04x BMSR %04x LPA %04x\n",\r\ndev->name,\r\nphy_read(phydev, MII_BMCR),\r\nphy_read(phydev, MII_BMSR),\r\nphy_read(phydev, MII_LPA));\r\n}\r\n}\r\nstatic int tc_mii_probe(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nstruct phy_device *phydev;\r\nu32 dropmask;\r\nphydev = phy_find_first(lp->mii_bus);\r\nif (!phydev) {\r\nprintk(KERN_ERR "%s: no PHY found\n", dev->name);\r\nreturn -ENODEV;\r\n}\r\nphydev = phy_connect(dev, phydev_name(phydev),\r\n&tc_handle_link_change,\r\nlp->chiptype == TC35815_TX4939 ? PHY_INTERFACE_MODE_RMII : PHY_INTERFACE_MODE_MII);\r\nif (IS_ERR(phydev)) {\r\nprintk(KERN_ERR "%s: Could not attach to PHY\n", dev->name);\r\nreturn PTR_ERR(phydev);\r\n}\r\nphy_attached_info(phydev);\r\nphydev->supported &= PHY_BASIC_FEATURES;\r\ndropmask = 0;\r\nif (options.speed == 10)\r\ndropmask |= SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full;\r\nelse if (options.speed == 100)\r\ndropmask |= SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full;\r\nif (options.duplex == 1)\r\ndropmask |= SUPPORTED_10baseT_Full | SUPPORTED_100baseT_Full;\r\nelse if (options.duplex == 2)\r\ndropmask |= SUPPORTED_10baseT_Half | SUPPORTED_100baseT_Half;\r\nphydev->supported &= ~dropmask;\r\nphydev->advertising = phydev->supported;\r\nlp->link = 0;\r\nlp->speed = 0;\r\nlp->duplex = -1;\r\nreturn 0;\r\n}\r\nstatic int tc_mii_init(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nint err;\r\nlp->mii_bus = mdiobus_alloc();\r\nif (lp->mii_bus == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nlp->mii_bus->name = "tc35815_mii_bus";\r\nlp->mii_bus->read = tc_mdio_read;\r\nlp->mii_bus->write = tc_mdio_write;\r\nsnprintf(lp->mii_bus->id, MII_BUS_ID_SIZE, "%x",\r\n(lp->pci_dev->bus->number << 8) | lp->pci_dev->devfn);\r\nlp->mii_bus->priv = dev;\r\nlp->mii_bus->parent = &lp->pci_dev->dev;\r\nerr = mdiobus_register(lp->mii_bus);\r\nif (err)\r\ngoto err_out_free_mii_bus;\r\nerr = tc_mii_probe(dev);\r\nif (err)\r\ngoto err_out_unregister_bus;\r\nreturn 0;\r\nerr_out_unregister_bus:\r\nmdiobus_unregister(lp->mii_bus);\r\nerr_out_free_mii_bus:\r\nmdiobus_free(lp->mii_bus);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic int tc35815_mac_match(struct device *dev, void *data)\r\n{\r\nstruct platform_device *plat_dev = to_platform_device(dev);\r\nstruct pci_dev *pci_dev = data;\r\nunsigned int id = pci_dev->irq;\r\nreturn !strcmp(plat_dev->name, "tc35815-mac") && plat_dev->id == id;\r\n}\r\nstatic int tc35815_read_plat_dev_addr(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nstruct device *pd = bus_find_device(&platform_bus_type, NULL,\r\nlp->pci_dev, tc35815_mac_match);\r\nif (pd) {\r\nif (pd->platform_data)\r\nmemcpy(dev->dev_addr, pd->platform_data, ETH_ALEN);\r\nput_device(pd);\r\nreturn is_valid_ether_addr(dev->dev_addr) ? 0 : -ENODEV;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int tc35815_read_plat_dev_addr(struct net_device *dev)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int tc35815_init_dev_addr(struct net_device *dev)\r\n{\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\nint i;\r\nwhile (tc_readl(&tr->PROM_Ctl) & PROM_Busy)\r\n;\r\nfor (i = 0; i < 6; i += 2) {\r\nunsigned short data;\r\ntc_writel(PROM_Busy | PROM_Read | (i / 2 + 2), &tr->PROM_Ctl);\r\nwhile (tc_readl(&tr->PROM_Ctl) & PROM_Busy)\r\n;\r\ndata = tc_readl(&tr->PROM_Data);\r\ndev->dev_addr[i] = data & 0xff;\r\ndev->dev_addr[i+1] = data >> 8;\r\n}\r\nif (!is_valid_ether_addr(dev->dev_addr))\r\nreturn tc35815_read_plat_dev_addr(dev);\r\nreturn 0;\r\n}\r\nstatic int tc35815_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nvoid __iomem *ioaddr = NULL;\r\nstruct net_device *dev;\r\nstruct tc35815_local *lp;\r\nint rc;\r\nstatic int printed_version;\r\nif (!printed_version++) {\r\nprintk(version);\r\ndev_printk(KERN_DEBUG, &pdev->dev,\r\n"speed:%d duplex:%d\n",\r\noptions.speed, options.duplex);\r\n}\r\nif (!pdev->irq) {\r\ndev_warn(&pdev->dev, "no IRQ assigned.\n");\r\nreturn -ENODEV;\r\n}\r\ndev = alloc_etherdev(sizeof(*lp));\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nlp = netdev_priv(dev);\r\nlp->dev = dev;\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\ngoto err_out;\r\nrc = pcim_iomap_regions(pdev, 1 << 1, MODNAME);\r\nif (rc)\r\ngoto err_out;\r\npci_set_master(pdev);\r\nioaddr = pcim_iomap_table(pdev)[1];\r\ndev->netdev_ops = &tc35815_netdev_ops;\r\ndev->ethtool_ops = &tc35815_ethtool_ops;\r\ndev->watchdog_timeo = TC35815_TX_TIMEOUT;\r\nnetif_napi_add(dev, &lp->napi, tc35815_poll, NAPI_WEIGHT);\r\ndev->irq = pdev->irq;\r\ndev->base_addr = (unsigned long)ioaddr;\r\nINIT_WORK(&lp->restart_work, tc35815_restart_work);\r\nspin_lock_init(&lp->lock);\r\nspin_lock_init(&lp->rx_lock);\r\nlp->pci_dev = pdev;\r\nlp->chiptype = ent->driver_data;\r\nlp->msg_enable = NETIF_MSG_TX_ERR | NETIF_MSG_HW | NETIF_MSG_DRV | NETIF_MSG_LINK;\r\npci_set_drvdata(pdev, dev);\r\ntc35815_chip_reset(dev);\r\nif (tc35815_init_dev_addr(dev)) {\r\ndev_warn(&pdev->dev, "not valid ether addr\n");\r\neth_hw_addr_random(dev);\r\n}\r\nrc = register_netdev(dev);\r\nif (rc)\r\ngoto err_out;\r\nprintk(KERN_INFO "%s: %s at 0x%lx, %pM, IRQ %d\n",\r\ndev->name,\r\nchip_info[ent->driver_data].name,\r\ndev->base_addr,\r\ndev->dev_addr,\r\ndev->irq);\r\nrc = tc_mii_init(dev);\r\nif (rc)\r\ngoto err_out_unregister;\r\nreturn 0;\r\nerr_out_unregister:\r\nunregister_netdev(dev);\r\nerr_out:\r\nfree_netdev(dev);\r\nreturn rc;\r\n}\r\nstatic void tc35815_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nphy_disconnect(dev->phydev);\r\nmdiobus_unregister(lp->mii_bus);\r\nmdiobus_free(lp->mii_bus);\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\n}\r\nstatic int\r\ntc35815_init_queues(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nint i;\r\nunsigned long fd_addr;\r\nif (!lp->fd_buf) {\r\nBUG_ON(sizeof(struct FDesc) +\r\nsizeof(struct BDesc) * RX_BUF_NUM +\r\nsizeof(struct FDesc) * RX_FD_NUM +\r\nsizeof(struct TxFD) * TX_FD_NUM >\r\nPAGE_SIZE * FD_PAGE_NUM);\r\nlp->fd_buf = pci_alloc_consistent(lp->pci_dev,\r\nPAGE_SIZE * FD_PAGE_NUM,\r\n&lp->fd_buf_dma);\r\nif (!lp->fd_buf)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < RX_BUF_NUM; i++) {\r\nlp->rx_skbs[i].skb =\r\nalloc_rxbuf_skb(dev, lp->pci_dev,\r\n&lp->rx_skbs[i].skb_dma);\r\nif (!lp->rx_skbs[i].skb) {\r\nwhile (--i >= 0) {\r\nfree_rxbuf_skb(lp->pci_dev,\r\nlp->rx_skbs[i].skb,\r\nlp->rx_skbs[i].skb_dma);\r\nlp->rx_skbs[i].skb = NULL;\r\n}\r\npci_free_consistent(lp->pci_dev,\r\nPAGE_SIZE * FD_PAGE_NUM,\r\nlp->fd_buf,\r\nlp->fd_buf_dma);\r\nlp->fd_buf = NULL;\r\nreturn -ENOMEM;\r\n}\r\n}\r\nprintk(KERN_DEBUG "%s: FD buf %p DataBuf",\r\ndev->name, lp->fd_buf);\r\nprintk("\n");\r\n} else {\r\nfor (i = 0; i < FD_PAGE_NUM; i++)\r\nclear_page((void *)((unsigned long)lp->fd_buf +\r\ni * PAGE_SIZE));\r\n}\r\nfd_addr = (unsigned long)lp->fd_buf;\r\nlp->rfd_base = (struct RxFD *)fd_addr;\r\nfd_addr += sizeof(struct RxFD) * RX_FD_NUM;\r\nfor (i = 0; i < RX_FD_NUM; i++)\r\nlp->rfd_base[i].fd.FDCtl = cpu_to_le32(FD_CownsFD);\r\nlp->rfd_cur = lp->rfd_base;\r\nlp->rfd_limit = (struct RxFD *)fd_addr - (RX_FD_RESERVE + 1);\r\nlp->tfd_base = (struct TxFD *)fd_addr;\r\nfd_addr += sizeof(struct TxFD) * TX_FD_NUM;\r\nfor (i = 0; i < TX_FD_NUM; i++) {\r\nlp->tfd_base[i].fd.FDNext = cpu_to_le32(fd_virt_to_bus(lp, &lp->tfd_base[i+1]));\r\nlp->tfd_base[i].fd.FDSystem = cpu_to_le32(0xffffffff);\r\nlp->tfd_base[i].fd.FDCtl = cpu_to_le32(0);\r\n}\r\nlp->tfd_base[TX_FD_NUM-1].fd.FDNext = cpu_to_le32(fd_virt_to_bus(lp, &lp->tfd_base[0]));\r\nlp->tfd_start = 0;\r\nlp->tfd_end = 0;\r\nlp->fbl_ptr = (struct FrFD *)fd_addr;\r\nlp->fbl_ptr->fd.FDNext = cpu_to_le32(fd_virt_to_bus(lp, lp->fbl_ptr));\r\nlp->fbl_ptr->fd.FDCtl = cpu_to_le32(RX_BUF_NUM | FD_CownsFD);\r\nlp->fbl_count = 0;\r\nfor (i = 0; i < RX_BUF_NUM; i++) {\r\nif (lp->rx_skbs[i].skb) {\r\nif (i != lp->fbl_count) {\r\nlp->rx_skbs[lp->fbl_count].skb =\r\nlp->rx_skbs[i].skb;\r\nlp->rx_skbs[lp->fbl_count].skb_dma =\r\nlp->rx_skbs[i].skb_dma;\r\n}\r\nlp->fbl_count++;\r\n}\r\n}\r\nfor (i = 0; i < RX_BUF_NUM; i++) {\r\nif (i >= lp->fbl_count) {\r\nlp->fbl_ptr->bd[i].BuffData = 0;\r\nlp->fbl_ptr->bd[i].BDCtl = 0;\r\ncontinue;\r\n}\r\nlp->fbl_ptr->bd[i].BuffData =\r\ncpu_to_le32(lp->rx_skbs[i].skb_dma);\r\nlp->fbl_ptr->bd[i].BDCtl =\r\ncpu_to_le32(BD_CownsBD | (i << BD_RxBDID_SHIFT) |\r\nRX_BUF_SIZE);\r\n}\r\nprintk(KERN_DEBUG "%s: TxFD %p RxFD %p FrFD %p\n",\r\ndev->name, lp->tfd_base, lp->rfd_base, lp->fbl_ptr);\r\nreturn 0;\r\n}\r\nstatic void\r\ntc35815_clear_queues(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < TX_FD_NUM; i++) {\r\nu32 fdsystem = le32_to_cpu(lp->tfd_base[i].fd.FDSystem);\r\nstruct sk_buff *skb =\r\nfdsystem != 0xffffffff ?\r\nlp->tx_skbs[fdsystem].skb : NULL;\r\n#ifdef DEBUG\r\nif (lp->tx_skbs[i].skb != skb) {\r\nprintk("%s: tx_skbs mismatch(%d).\n", dev->name, i);\r\npanic_queues(dev);\r\n}\r\n#else\r\nBUG_ON(lp->tx_skbs[i].skb != skb);\r\n#endif\r\nif (skb) {\r\npci_unmap_single(lp->pci_dev, lp->tx_skbs[i].skb_dma, skb->len, PCI_DMA_TODEVICE);\r\nlp->tx_skbs[i].skb = NULL;\r\nlp->tx_skbs[i].skb_dma = 0;\r\ndev_kfree_skb_any(skb);\r\n}\r\nlp->tfd_base[i].fd.FDSystem = cpu_to_le32(0xffffffff);\r\n}\r\ntc35815_init_queues(dev);\r\n}\r\nstatic void\r\ntc35815_free_queues(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nint i;\r\nif (lp->tfd_base) {\r\nfor (i = 0; i < TX_FD_NUM; i++) {\r\nu32 fdsystem = le32_to_cpu(lp->tfd_base[i].fd.FDSystem);\r\nstruct sk_buff *skb =\r\nfdsystem != 0xffffffff ?\r\nlp->tx_skbs[fdsystem].skb : NULL;\r\n#ifdef DEBUG\r\nif (lp->tx_skbs[i].skb != skb) {\r\nprintk("%s: tx_skbs mismatch(%d).\n", dev->name, i);\r\npanic_queues(dev);\r\n}\r\n#else\r\nBUG_ON(lp->tx_skbs[i].skb != skb);\r\n#endif\r\nif (skb) {\r\npci_unmap_single(lp->pci_dev, lp->tx_skbs[i].skb_dma, skb->len, PCI_DMA_TODEVICE);\r\ndev_kfree_skb(skb);\r\nlp->tx_skbs[i].skb = NULL;\r\nlp->tx_skbs[i].skb_dma = 0;\r\n}\r\nlp->tfd_base[i].fd.FDSystem = cpu_to_le32(0xffffffff);\r\n}\r\n}\r\nlp->rfd_base = NULL;\r\nlp->rfd_limit = NULL;\r\nlp->rfd_cur = NULL;\r\nlp->fbl_ptr = NULL;\r\nfor (i = 0; i < RX_BUF_NUM; i++) {\r\nif (lp->rx_skbs[i].skb) {\r\nfree_rxbuf_skb(lp->pci_dev, lp->rx_skbs[i].skb,\r\nlp->rx_skbs[i].skb_dma);\r\nlp->rx_skbs[i].skb = NULL;\r\n}\r\n}\r\nif (lp->fd_buf) {\r\npci_free_consistent(lp->pci_dev, PAGE_SIZE * FD_PAGE_NUM,\r\nlp->fd_buf, lp->fd_buf_dma);\r\nlp->fd_buf = NULL;\r\n}\r\n}\r\nstatic void\r\ndump_txfd(struct TxFD *fd)\r\n{\r\nprintk("TxFD(%p): %08x %08x %08x %08x\n", fd,\r\nle32_to_cpu(fd->fd.FDNext),\r\nle32_to_cpu(fd->fd.FDSystem),\r\nle32_to_cpu(fd->fd.FDStat),\r\nle32_to_cpu(fd->fd.FDCtl));\r\nprintk("BD: ");\r\nprintk(" %08x %08x",\r\nle32_to_cpu(fd->bd.BuffData),\r\nle32_to_cpu(fd->bd.BDCtl));\r\nprintk("\n");\r\n}\r\nstatic int\r\ndump_rxfd(struct RxFD *fd)\r\n{\r\nint i, bd_count = (le32_to_cpu(fd->fd.FDCtl) & FD_BDCnt_MASK) >> FD_BDCnt_SHIFT;\r\nif (bd_count > 8)\r\nbd_count = 8;\r\nprintk("RxFD(%p): %08x %08x %08x %08x\n", fd,\r\nle32_to_cpu(fd->fd.FDNext),\r\nle32_to_cpu(fd->fd.FDSystem),\r\nle32_to_cpu(fd->fd.FDStat),\r\nle32_to_cpu(fd->fd.FDCtl));\r\nif (le32_to_cpu(fd->fd.FDCtl) & FD_CownsFD)\r\nreturn 0;\r\nprintk("BD: ");\r\nfor (i = 0; i < bd_count; i++)\r\nprintk(" %08x %08x",\r\nle32_to_cpu(fd->bd[i].BuffData),\r\nle32_to_cpu(fd->bd[i].BDCtl));\r\nprintk("\n");\r\nreturn bd_count;\r\n}\r\nstatic void\r\ndump_frfd(struct FrFD *fd)\r\n{\r\nint i;\r\nprintk("FrFD(%p): %08x %08x %08x %08x\n", fd,\r\nle32_to_cpu(fd->fd.FDNext),\r\nle32_to_cpu(fd->fd.FDSystem),\r\nle32_to_cpu(fd->fd.FDStat),\r\nle32_to_cpu(fd->fd.FDCtl));\r\nprintk("BD: ");\r\nfor (i = 0; i < RX_BUF_NUM; i++)\r\nprintk(" %08x %08x",\r\nle32_to_cpu(fd->bd[i].BuffData),\r\nle32_to_cpu(fd->bd[i].BDCtl));\r\nprintk("\n");\r\n}\r\nstatic void\r\npanic_queues(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nint i;\r\nprintk("TxFD base %p, start %u, end %u\n",\r\nlp->tfd_base, lp->tfd_start, lp->tfd_end);\r\nprintk("RxFD base %p limit %p cur %p\n",\r\nlp->rfd_base, lp->rfd_limit, lp->rfd_cur);\r\nprintk("FrFD %p\n", lp->fbl_ptr);\r\nfor (i = 0; i < TX_FD_NUM; i++)\r\ndump_txfd(&lp->tfd_base[i]);\r\nfor (i = 0; i < RX_FD_NUM; i++) {\r\nint bd_count = dump_rxfd(&lp->rfd_base[i]);\r\ni += (bd_count + 1) / 2;\r\n}\r\ndump_frfd(lp->fbl_ptr);\r\npanic("%s: Illegal queue state.", dev->name);\r\n}\r\nstatic void print_eth(const u8 *add)\r\n{\r\nprintk(KERN_DEBUG "print_eth(%p)\n", add);\r\nprintk(KERN_DEBUG " %pM => %pM : %02x%02x\n",\r\nadd + 6, add, add[12], add[13]);\r\n}\r\nstatic int tc35815_tx_full(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nreturn (lp->tfd_start + 1) % TX_FD_NUM == lp->tfd_end;\r\n}\r\nstatic void tc35815_restart(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nint ret;\r\nif (dev->phydev) {\r\nret = phy_init_hw(dev->phydev);\r\nif (ret)\r\nprintk(KERN_ERR "%s: PHY init failed.\n", dev->name);\r\n}\r\nspin_lock_bh(&lp->rx_lock);\r\nspin_lock_irq(&lp->lock);\r\ntc35815_chip_reset(dev);\r\ntc35815_clear_queues(dev);\r\ntc35815_chip_init(dev);\r\ntc35815_set_multicast_list(dev);\r\nspin_unlock_irq(&lp->lock);\r\nspin_unlock_bh(&lp->rx_lock);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void tc35815_restart_work(struct work_struct *work)\r\n{\r\nstruct tc35815_local *lp =\r\ncontainer_of(work, struct tc35815_local, restart_work);\r\nstruct net_device *dev = lp->dev;\r\ntc35815_restart(dev);\r\n}\r\nstatic void tc35815_schedule_restart(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\ntc_writel(0, &tr->Int_En);\r\ntc_writel(tc_readl(&tr->DMA_Ctl) | DMA_IntMask, &tr->DMA_Ctl);\r\nschedule_work(&lp->restart_work);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic void tc35815_tx_timeout(struct net_device *dev)\r\n{\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\nprintk(KERN_WARNING "%s: transmit timed out, status %#x\n",\r\ndev->name, tc_readl(&tr->Tx_Stat));\r\ntc35815_schedule_restart(dev);\r\ndev->stats.tx_errors++;\r\n}\r\nstatic int\r\ntc35815_open(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nif (request_irq(dev->irq, tc35815_interrupt, IRQF_SHARED,\r\ndev->name, dev))\r\nreturn -EAGAIN;\r\ntc35815_chip_reset(dev);\r\nif (tc35815_init_queues(dev) != 0) {\r\nfree_irq(dev->irq, dev);\r\nreturn -EAGAIN;\r\n}\r\nnapi_enable(&lp->napi);\r\nspin_lock_irq(&lp->lock);\r\ntc35815_chip_init(dev);\r\nspin_unlock_irq(&lp->lock);\r\nnetif_carrier_off(dev);\r\nphy_start(dev->phydev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int tc35815_send_packet(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nstruct TxFD *txfd;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif ((lp->tfd_start + TX_FD_NUM - lp->tfd_end) % TX_FD_NUM >\r\nTX_FD_NUM / 2)\r\ntc35815_txdone(dev);\r\nif (netif_msg_pktdata(lp))\r\nprint_eth(skb->data);\r\n#ifdef DEBUG\r\nif (lp->tx_skbs[lp->tfd_start].skb) {\r\nprintk("%s: tx_skbs conflict.\n", dev->name);\r\npanic_queues(dev);\r\n}\r\n#else\r\nBUG_ON(lp->tx_skbs[lp->tfd_start].skb);\r\n#endif\r\nlp->tx_skbs[lp->tfd_start].skb = skb;\r\nlp->tx_skbs[lp->tfd_start].skb_dma = pci_map_single(lp->pci_dev, skb->data, skb->len, PCI_DMA_TODEVICE);\r\ntxfd = &lp->tfd_base[lp->tfd_start];\r\ntxfd->bd.BuffData = cpu_to_le32(lp->tx_skbs[lp->tfd_start].skb_dma);\r\ntxfd->bd.BDCtl = cpu_to_le32(skb->len);\r\ntxfd->fd.FDSystem = cpu_to_le32(lp->tfd_start);\r\ntxfd->fd.FDCtl = cpu_to_le32(FD_CownsFD | (1 << FD_BDCnt_SHIFT));\r\nif (lp->tfd_start == lp->tfd_end) {\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\ntxfd->fd.FDNext |= cpu_to_le32(FD_Next_EOL);\r\ntxfd->fd.FDCtl |= cpu_to_le32(FD_FrmOpt_IntTx);\r\nif (netif_msg_tx_queued(lp)) {\r\nprintk("%s: starting TxFD.\n", dev->name);\r\ndump_txfd(txfd);\r\n}\r\ntc_writel(fd_virt_to_bus(lp, txfd), &tr->TxFrmPtr);\r\n} else {\r\ntxfd->fd.FDNext &= cpu_to_le32(~FD_Next_EOL);\r\nif (netif_msg_tx_queued(lp)) {\r\nprintk("%s: queueing TxFD.\n", dev->name);\r\ndump_txfd(txfd);\r\n}\r\n}\r\nlp->tfd_start = (lp->tfd_start + 1) % TX_FD_NUM;\r\nif (tc35815_tx_full(dev)) {\r\nif (netif_msg_tx_queued(lp))\r\nprintk(KERN_WARNING "%s: TxFD Exhausted.\n", dev->name);\r\nnetif_stop_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void tc35815_fatal_error_interrupt(struct net_device *dev, u32 status)\r\n{\r\nstatic int count;\r\nprintk(KERN_WARNING "%s: Fatal Error Interrupt (%#x):",\r\ndev->name, status);\r\nif (status & Int_IntPCI)\r\nprintk(" IntPCI");\r\nif (status & Int_DmParErr)\r\nprintk(" DmParErr");\r\nif (status & Int_IntNRAbt)\r\nprintk(" IntNRAbt");\r\nprintk("\n");\r\nif (count++ > 100)\r\npanic("%s: Too many fatal errors.", dev->name);\r\nprintk(KERN_WARNING "%s: Resetting ...\n", dev->name);\r\ntc35815_schedule_restart(dev);\r\n}\r\nstatic int tc35815_do_interrupt(struct net_device *dev, u32 status, int limit)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nint ret = -1;\r\nif (status & FATAL_ERROR_INT) {\r\ntc35815_fatal_error_interrupt(dev, status);\r\nreturn 0;\r\n}\r\nif (status & Int_IntFDAEx) {\r\nif (netif_msg_rx_err(lp))\r\ndev_warn(&dev->dev,\r\n"Free Descriptor Area Exhausted (%#x).\n",\r\nstatus);\r\ndev->stats.rx_dropped++;\r\nret = 0;\r\n}\r\nif (status & Int_IntBLEx) {\r\nif (netif_msg_rx_err(lp))\r\ndev_warn(&dev->dev,\r\n"Buffer List Exhausted (%#x).\n",\r\nstatus);\r\ndev->stats.rx_dropped++;\r\nret = 0;\r\n}\r\nif (status & Int_IntExBD) {\r\nif (netif_msg_rx_err(lp))\r\ndev_warn(&dev->dev,\r\n"Excessive Buffer Descriptors (%#x).\n",\r\nstatus);\r\ndev->stats.rx_length_errors++;\r\nret = 0;\r\n}\r\nif (status & Int_IntMacRx) {\r\nret = tc35815_rx(dev, limit);\r\nlp->lstats.rx_ints++;\r\n}\r\nif (status & Int_IntMacTx) {\r\nlp->lstats.tx_ints++;\r\nspin_lock_irq(&lp->lock);\r\ntc35815_txdone(dev);\r\nspin_unlock_irq(&lp->lock);\r\nif (ret < 0)\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t tc35815_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\nu32 dmactl = tc_readl(&tr->DMA_Ctl);\r\nif (!(dmactl & DMA_IntMask)) {\r\ntc_writel(dmactl | DMA_IntMask, &tr->DMA_Ctl);\r\nif (napi_schedule_prep(&lp->napi))\r\n__napi_schedule(&lp->napi);\r\nelse {\r\nprintk(KERN_ERR "%s: interrupt taken in poll\n",\r\ndev->name);\r\nBUG();\r\n}\r\n(void)tc_readl(&tr->Int_Src);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic void tc35815_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\ntc35815_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic int\r\ntc35815_rx(struct net_device *dev, int limit)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nunsigned int fdctl;\r\nint i;\r\nint received = 0;\r\nwhile (!((fdctl = le32_to_cpu(lp->rfd_cur->fd.FDCtl)) & FD_CownsFD)) {\r\nint status = le32_to_cpu(lp->rfd_cur->fd.FDStat);\r\nint pkt_len = fdctl & FD_FDLength_MASK;\r\nint bd_count = (fdctl & FD_BDCnt_MASK) >> FD_BDCnt_SHIFT;\r\n#ifdef DEBUG\r\nstruct RxFD *next_rfd;\r\n#endif\r\n#if (RX_CTL_CMD & Rx_StripCRC) == 0\r\npkt_len -= ETH_FCS_LEN;\r\n#endif\r\nif (netif_msg_rx_status(lp))\r\ndump_rxfd(lp->rfd_cur);\r\nif (status & Rx_Good) {\r\nstruct sk_buff *skb;\r\nunsigned char *data;\r\nint cur_bd;\r\nif (--limit < 0)\r\nbreak;\r\nBUG_ON(bd_count > 1);\r\ncur_bd = (le32_to_cpu(lp->rfd_cur->bd[0].BDCtl)\r\n& BD_RxBDID_MASK) >> BD_RxBDID_SHIFT;\r\n#ifdef DEBUG\r\nif (cur_bd >= RX_BUF_NUM) {\r\nprintk("%s: invalid BDID.\n", dev->name);\r\npanic_queues(dev);\r\n}\r\nBUG_ON(lp->rx_skbs[cur_bd].skb_dma !=\r\n(le32_to_cpu(lp->rfd_cur->bd[0].BuffData) & ~3));\r\nif (!lp->rx_skbs[cur_bd].skb) {\r\nprintk("%s: NULL skb.\n", dev->name);\r\npanic_queues(dev);\r\n}\r\n#else\r\nBUG_ON(cur_bd >= RX_BUF_NUM);\r\n#endif\r\nskb = lp->rx_skbs[cur_bd].skb;\r\nprefetch(skb->data);\r\nlp->rx_skbs[cur_bd].skb = NULL;\r\npci_unmap_single(lp->pci_dev,\r\nlp->rx_skbs[cur_bd].skb_dma,\r\nRX_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\nif (!HAVE_DMA_RXALIGN(lp) && NET_IP_ALIGN)\r\nmemmove(skb->data, skb->data - NET_IP_ALIGN,\r\npkt_len);\r\ndata = skb_put(skb, pkt_len);\r\nif (netif_msg_pktdata(lp))\r\nprint_eth(data);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_receive_skb(skb);\r\nreceived++;\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n} else {\r\ndev->stats.rx_errors++;\r\nif (netif_msg_rx_err(lp))\r\ndev_info(&dev->dev, "Rx error (status %x)\n",\r\nstatus & Rx_Stat_Mask);\r\nif ((status & Rx_LongErr) && (status & Rx_CRCErr)) {\r\nstatus &= ~(Rx_LongErr|Rx_CRCErr);\r\nstatus |= Rx_Over;\r\n}\r\nif (status & Rx_LongErr)\r\ndev->stats.rx_length_errors++;\r\nif (status & Rx_Over)\r\ndev->stats.rx_fifo_errors++;\r\nif (status & Rx_CRCErr)\r\ndev->stats.rx_crc_errors++;\r\nif (status & Rx_Align)\r\ndev->stats.rx_frame_errors++;\r\n}\r\nif (bd_count > 0) {\r\nint bdctl = le32_to_cpu(lp->rfd_cur->bd[bd_count - 1].BDCtl);\r\nunsigned char id =\r\n(bdctl & BD_RxBDID_MASK) >> BD_RxBDID_SHIFT;\r\n#ifdef DEBUG\r\nif (id >= RX_BUF_NUM) {\r\nprintk("%s: invalid BDID.\n", dev->name);\r\npanic_queues(dev);\r\n}\r\n#else\r\nBUG_ON(id >= RX_BUF_NUM);\r\n#endif\r\nlp->fbl_count--;\r\nwhile (lp->fbl_count < RX_BUF_NUM)\r\n{\r\nunsigned char curid =\r\n(id + 1 + lp->fbl_count) % RX_BUF_NUM;\r\nstruct BDesc *bd = &lp->fbl_ptr->bd[curid];\r\n#ifdef DEBUG\r\nbdctl = le32_to_cpu(bd->BDCtl);\r\nif (bdctl & BD_CownsBD) {\r\nprintk("%s: Freeing invalid BD.\n",\r\ndev->name);\r\npanic_queues(dev);\r\n}\r\n#endif\r\nif (!lp->rx_skbs[curid].skb) {\r\nlp->rx_skbs[curid].skb =\r\nalloc_rxbuf_skb(dev,\r\nlp->pci_dev,\r\n&lp->rx_skbs[curid].skb_dma);\r\nif (!lp->rx_skbs[curid].skb)\r\nbreak;\r\nbd->BuffData = cpu_to_le32(lp->rx_skbs[curid].skb_dma);\r\n}\r\nbd->BDCtl = cpu_to_le32(BD_CownsBD |\r\n(curid << BD_RxBDID_SHIFT) |\r\nRX_BUF_SIZE);\r\nlp->fbl_count++;\r\n}\r\n}\r\n#ifdef DEBUG\r\nnext_rfd = fd_bus_to_virt(lp,\r\nle32_to_cpu(lp->rfd_cur->fd.FDNext));\r\nif (next_rfd < lp->rfd_base || next_rfd > lp->rfd_limit) {\r\nprintk("%s: RxFD FDNext invalid.\n", dev->name);\r\npanic_queues(dev);\r\n}\r\n#endif\r\nfor (i = 0; i < (bd_count + 1) / 2 + 1; i++) {\r\n#ifdef DEBUG\r\nlp->rfd_cur->fd.FDNext = cpu_to_le32(0xdeaddead);\r\n#else\r\nlp->rfd_cur->fd.FDNext = cpu_to_le32(FD_Next_EOL);\r\n#endif\r\nlp->rfd_cur->fd.FDCtl = cpu_to_le32(FD_CownsFD);\r\nlp->rfd_cur++;\r\n}\r\nif (lp->rfd_cur > lp->rfd_limit)\r\nlp->rfd_cur = lp->rfd_base;\r\n#ifdef DEBUG\r\nif (lp->rfd_cur != next_rfd)\r\nprintk("rfd_cur = %p, next_rfd %p\n",\r\nlp->rfd_cur, next_rfd);\r\n#endif\r\n}\r\nreturn received;\r\n}\r\nstatic int tc35815_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct tc35815_local *lp = container_of(napi, struct tc35815_local, napi);\r\nstruct net_device *dev = lp->dev;\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\nint received = 0, handled;\r\nu32 status;\r\nif (budget <= 0)\r\nreturn received;\r\nspin_lock(&lp->rx_lock);\r\nstatus = tc_readl(&tr->Int_Src);\r\ndo {\r\ntc_writel(status & ~(Int_BLEx | Int_FDAEx),\r\n&tr->Int_Src);\r\nhandled = tc35815_do_interrupt(dev, status, budget - received);\r\nif (status & (Int_BLEx | Int_FDAEx))\r\ntc_writel(status & (Int_BLEx | Int_FDAEx),\r\n&tr->Int_Src);\r\nif (handled >= 0) {\r\nreceived += handled;\r\nif (received >= budget)\r\nbreak;\r\n}\r\nstatus = tc_readl(&tr->Int_Src);\r\n} while (status);\r\nspin_unlock(&lp->rx_lock);\r\nif (received < budget) {\r\nnapi_complete_done(napi, received);\r\ntc_writel(tc_readl(&tr->DMA_Ctl) & ~DMA_IntMask, &tr->DMA_Ctl);\r\n}\r\nreturn received;\r\n}\r\nstatic void\r\ntc35815_check_tx_stat(struct net_device *dev, int status)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nconst char *msg = NULL;\r\nif (status & Tx_ExColl)\r\ndev->stats.collisions += 16;\r\nif (status & Tx_TxColl_MASK)\r\ndev->stats.collisions += status & Tx_TxColl_MASK;\r\nif (lp->chiptype == TC35815_TX4939)\r\nstatus &= ~Tx_NCarr;\r\nif (!lp->link || lp->duplex == DUPLEX_FULL)\r\nstatus &= ~Tx_NCarr;\r\nif (!(status & TX_STA_ERR)) {\r\ndev->stats.tx_packets++;\r\nreturn;\r\n}\r\ndev->stats.tx_errors++;\r\nif (status & Tx_ExColl) {\r\ndev->stats.tx_aborted_errors++;\r\nmsg = "Excessive Collision.";\r\n}\r\nif (status & Tx_Under) {\r\ndev->stats.tx_fifo_errors++;\r\nmsg = "Tx FIFO Underrun.";\r\nif (lp->lstats.tx_underrun < TX_THRESHOLD_KEEP_LIMIT) {\r\nlp->lstats.tx_underrun++;\r\nif (lp->lstats.tx_underrun >= TX_THRESHOLD_KEEP_LIMIT) {\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\ntc_writel(TX_THRESHOLD_MAX, &tr->TxThrsh);\r\nmsg = "Tx FIFO Underrun.Change Tx threshold to max.";\r\n}\r\n}\r\n}\r\nif (status & Tx_Defer) {\r\ndev->stats.tx_fifo_errors++;\r\nmsg = "Excessive Deferral.";\r\n}\r\nif (status & Tx_NCarr) {\r\ndev->stats.tx_carrier_errors++;\r\nmsg = "Lost Carrier Sense.";\r\n}\r\nif (status & Tx_LateColl) {\r\ndev->stats.tx_aborted_errors++;\r\nmsg = "Late Collision.";\r\n}\r\nif (status & Tx_TxPar) {\r\ndev->stats.tx_fifo_errors++;\r\nmsg = "Transmit Parity Error.";\r\n}\r\nif (status & Tx_SQErr) {\r\ndev->stats.tx_heartbeat_errors++;\r\nmsg = "Signal Quality Error.";\r\n}\r\nif (msg && netif_msg_tx_err(lp))\r\nprintk(KERN_WARNING "%s: %s (%#x)\n", dev->name, msg, status);\r\n}\r\nstatic void\r\ntc35815_txdone(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nstruct TxFD *txfd;\r\nunsigned int fdctl;\r\ntxfd = &lp->tfd_base[lp->tfd_end];\r\nwhile (lp->tfd_start != lp->tfd_end &&\r\n!((fdctl = le32_to_cpu(txfd->fd.FDCtl)) & FD_CownsFD)) {\r\nint status = le32_to_cpu(txfd->fd.FDStat);\r\nstruct sk_buff *skb;\r\nunsigned long fdnext = le32_to_cpu(txfd->fd.FDNext);\r\nu32 fdsystem = le32_to_cpu(txfd->fd.FDSystem);\r\nif (netif_msg_tx_done(lp)) {\r\nprintk("%s: complete TxFD.\n", dev->name);\r\ndump_txfd(txfd);\r\n}\r\ntc35815_check_tx_stat(dev, status);\r\nskb = fdsystem != 0xffffffff ?\r\nlp->tx_skbs[fdsystem].skb : NULL;\r\n#ifdef DEBUG\r\nif (lp->tx_skbs[lp->tfd_end].skb != skb) {\r\nprintk("%s: tx_skbs mismatch.\n", dev->name);\r\npanic_queues(dev);\r\n}\r\n#else\r\nBUG_ON(lp->tx_skbs[lp->tfd_end].skb != skb);\r\n#endif\r\nif (skb) {\r\ndev->stats.tx_bytes += skb->len;\r\npci_unmap_single(lp->pci_dev, lp->tx_skbs[lp->tfd_end].skb_dma, skb->len, PCI_DMA_TODEVICE);\r\nlp->tx_skbs[lp->tfd_end].skb = NULL;\r\nlp->tx_skbs[lp->tfd_end].skb_dma = 0;\r\ndev_kfree_skb_any(skb);\r\n}\r\ntxfd->fd.FDSystem = cpu_to_le32(0xffffffff);\r\nlp->tfd_end = (lp->tfd_end + 1) % TX_FD_NUM;\r\ntxfd = &lp->tfd_base[lp->tfd_end];\r\n#ifdef DEBUG\r\nif ((fdnext & ~FD_Next_EOL) != fd_virt_to_bus(lp, txfd)) {\r\nprintk("%s: TxFD FDNext invalid.\n", dev->name);\r\npanic_queues(dev);\r\n}\r\n#endif\r\nif (fdnext & FD_Next_EOL) {\r\nif (lp->tfd_end != lp->tfd_start) {\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\nint head = (lp->tfd_start + TX_FD_NUM - 1) % TX_FD_NUM;\r\nstruct TxFD *txhead = &lp->tfd_base[head];\r\nint qlen = (lp->tfd_start + TX_FD_NUM\r\n- lp->tfd_end) % TX_FD_NUM;\r\n#ifdef DEBUG\r\nif (!(le32_to_cpu(txfd->fd.FDCtl) & FD_CownsFD)) {\r\nprintk("%s: TxFD FDCtl invalid.\n", dev->name);\r\npanic_queues(dev);\r\n}\r\n#endif\r\nif (lp->lstats.max_tx_qlen < qlen)\r\nlp->lstats.max_tx_qlen = qlen;\r\ntxhead->fd.FDNext |= cpu_to_le32(FD_Next_EOL);\r\ntxhead->fd.FDCtl |= cpu_to_le32(FD_FrmOpt_IntTx);\r\nif (netif_msg_tx_queued(lp)) {\r\nprintk("%s: start TxFD on queue.\n",\r\ndev->name);\r\ndump_txfd(txfd);\r\n}\r\ntc_writel(fd_virt_to_bus(lp, txfd), &tr->TxFrmPtr);\r\n}\r\nbreak;\r\n}\r\n}\r\nif (netif_queue_stopped(dev) && !tc35815_tx_full(dev))\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int\r\ntc35815_close(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&lp->napi);\r\nif (dev->phydev)\r\nphy_stop(dev->phydev);\r\ncancel_work_sync(&lp->restart_work);\r\ntc35815_chip_reset(dev);\r\nfree_irq(dev->irq, dev);\r\ntc35815_free_queues(dev);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *tc35815_get_stats(struct net_device *dev)\r\n{\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\nif (netif_running(dev))\r\ndev->stats.rx_missed_errors += tc_readl(&tr->Miss_Cnt);\r\nreturn &dev->stats;\r\n}\r\nstatic void tc35815_set_cam_entry(struct net_device *dev, int index, unsigned char *addr)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\nint cam_index = index * 6;\r\nu32 cam_data;\r\nu32 saved_addr;\r\nsaved_addr = tc_readl(&tr->CAM_Adr);\r\nif (netif_msg_hw(lp))\r\nprintk(KERN_DEBUG "%s: CAM %d: %pM\n",\r\ndev->name, index, addr);\r\nif (index & 1) {\r\ntc_writel(cam_index - 2, &tr->CAM_Adr);\r\ncam_data = tc_readl(&tr->CAM_Data) & 0xffff0000;\r\ncam_data |= addr[0] << 8 | addr[1];\r\ntc_writel(cam_data, &tr->CAM_Data);\r\ntc_writel(cam_index + 2, &tr->CAM_Adr);\r\ncam_data = (addr[2] << 24) | (addr[3] << 16) | (addr[4] << 8) | addr[5];\r\ntc_writel(cam_data, &tr->CAM_Data);\r\n} else {\r\ntc_writel(cam_index, &tr->CAM_Adr);\r\ncam_data = (addr[0] << 24) | (addr[1] << 16) | (addr[2] << 8) | addr[3];\r\ntc_writel(cam_data, &tr->CAM_Data);\r\ntc_writel(cam_index + 4, &tr->CAM_Adr);\r\ncam_data = tc_readl(&tr->CAM_Data) & 0x0000ffff;\r\ncam_data |= addr[4] << 24 | (addr[5] << 16);\r\ntc_writel(cam_data, &tr->CAM_Data);\r\n}\r\ntc_writel(saved_addr, &tr->CAM_Adr);\r\n}\r\nstatic void\r\ntc35815_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\nif (dev->flags & IFF_PROMISC) {\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nif (!lp->link)\r\nreturn;\r\ntc_writel(CAM_CompEn | CAM_BroadAcc | CAM_GroupAcc | CAM_StationAcc, &tr->CAM_Ctl);\r\n} else if ((dev->flags & IFF_ALLMULTI) ||\r\nnetdev_mc_count(dev) > CAM_ENTRY_MAX - 3) {\r\ntc_writel(CAM_CompEn | CAM_BroadAcc | CAM_GroupAcc, &tr->CAM_Ctl);\r\n} else if (!netdev_mc_empty(dev)) {\r\nstruct netdev_hw_addr *ha;\r\nint i;\r\nint ena_bits = CAM_Ena_Bit(CAM_ENTRY_SOURCE);\r\ntc_writel(0, &tr->CAM_Ctl);\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ntc35815_set_cam_entry(dev, i + 2, ha->addr);\r\nena_bits |= CAM_Ena_Bit(i + 2);\r\ni++;\r\n}\r\ntc_writel(ena_bits, &tr->CAM_Ena);\r\ntc_writel(CAM_CompEn | CAM_BroadAcc, &tr->CAM_Ctl);\r\n} else {\r\ntc_writel(CAM_Ena_Bit(CAM_ENTRY_SOURCE), &tr->CAM_Ena);\r\ntc_writel(CAM_CompEn | CAM_BroadAcc, &tr->CAM_Ctl);\r\n}\r\n}\r\nstatic void tc35815_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nstrlcpy(info->driver, MODNAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(lp->pci_dev), sizeof(info->bus_info));\r\n}\r\nstatic u32 tc35815_get_msglevel(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nreturn lp->msg_enable;\r\n}\r\nstatic void tc35815_set_msglevel(struct net_device *dev, u32 datum)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nlp->msg_enable = datum;\r\n}\r\nstatic int tc35815_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn sizeof(lp->lstats) / sizeof(int);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void tc35815_get_ethtool_stats(struct net_device *dev, struct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\ndata[0] = lp->lstats.max_tx_qlen;\r\ndata[1] = lp->lstats.tx_ints;\r\ndata[2] = lp->lstats.rx_ints;\r\ndata[3] = lp->lstats.tx_underrun;\r\n}\r\nstatic void tc35815_get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nmemcpy(data, ethtool_stats_keys, sizeof(ethtool_stats_keys));\r\n}\r\nstatic int tc35815_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nif (!dev->phydev)\r\nreturn -ENODEV;\r\nreturn phy_mii_ioctl(dev->phydev, rq, cmd);\r\n}\r\nstatic void tc35815_chip_reset(struct net_device *dev)\r\n{\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\nint i;\r\ntc_writel(MAC_Reset, &tr->MAC_Ctl);\r\nudelay(4);\r\ni = 0;\r\nwhile (tc_readl(&tr->MAC_Ctl) & MAC_Reset) {\r\nif (i++ > 100) {\r\nprintk(KERN_ERR "%s: MAC reset failed.\n", dev->name);\r\nbreak;\r\n}\r\nmdelay(1);\r\n}\r\ntc_writel(0, &tr->MAC_Ctl);\r\ntc_writel(0, &tr->DMA_Ctl);\r\ntc_writel(0, &tr->TxThrsh);\r\ntc_writel(0, &tr->TxPollCtr);\r\ntc_writel(0, &tr->RxFragSize);\r\ntc_writel(0, &tr->Int_En);\r\ntc_writel(0, &tr->FDA_Bas);\r\ntc_writel(0, &tr->FDA_Lim);\r\ntc_writel(0xffffffff, &tr->Int_Src);\r\ntc_writel(0, &tr->CAM_Ctl);\r\ntc_writel(0, &tr->Tx_Ctl);\r\ntc_writel(0, &tr->Rx_Ctl);\r\ntc_writel(0, &tr->CAM_Ena);\r\n(void)tc_readl(&tr->Miss_Cnt);\r\ntc_writel(DMA_TestMode, &tr->DMA_Ctl);\r\nfor (i = 0; i < 0x1000; i += 4) {\r\ntc_writel(i, &tr->CAM_Adr);\r\ntc_writel(0, &tr->CAM_Data);\r\n}\r\ntc_writel(0, &tr->DMA_Ctl);\r\n}\r\nstatic void tc35815_chip_init(struct net_device *dev)\r\n{\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nstruct tc35815_regs __iomem *tr =\r\n(struct tc35815_regs __iomem *)dev->base_addr;\r\nunsigned long txctl = TX_CTL_CMD;\r\ntc35815_set_cam_entry(dev, CAM_ENTRY_SOURCE, dev->dev_addr);\r\ntc_writel(CAM_Ena_Bit(CAM_ENTRY_SOURCE), &tr->CAM_Ena);\r\ntc_writel(CAM_CompEn | CAM_BroadAcc, &tr->CAM_Ctl);\r\nif (HAVE_DMA_RXALIGN(lp))\r\ntc_writel(DMA_BURST_SIZE | DMA_RxAlign_2, &tr->DMA_Ctl);\r\nelse\r\ntc_writel(DMA_BURST_SIZE, &tr->DMA_Ctl);\r\ntc_writel(0, &tr->TxPollCtr);\r\ntc_writel(TX_THRESHOLD, &tr->TxThrsh);\r\ntc_writel(INT_EN_CMD, &tr->Int_En);\r\ntc_writel(fd_virt_to_bus(lp, lp->rfd_base), &tr->FDA_Bas);\r\ntc_writel((unsigned long)lp->rfd_limit - (unsigned long)lp->rfd_base,\r\n&tr->FDA_Lim);\r\ntc_writel(fd_virt_to_bus(lp, lp->fbl_ptr), &tr->BLFrmPtr);\r\ntc_writel(RX_CTL_CMD, &tr->Rx_Ctl);\r\nif (lp->chiptype == TC35815_TX4939)\r\ntxctl &= ~Tx_EnLCarr;\r\nif (!dev->phydev || !lp->link || lp->duplex == DUPLEX_FULL)\r\ntxctl &= ~Tx_EnLCarr;\r\ntc_writel(txctl, &tr->Tx_Ctl);\r\n}\r\nstatic int tc35815_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct tc35815_local *lp = netdev_priv(dev);\r\nunsigned long flags;\r\npci_save_state(pdev);\r\nif (!netif_running(dev))\r\nreturn 0;\r\nnetif_device_detach(dev);\r\nif (dev->phydev)\r\nphy_stop(dev->phydev);\r\nspin_lock_irqsave(&lp->lock, flags);\r\ntc35815_chip_reset(dev);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\npci_set_power_state(pdev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int tc35815_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\npci_restore_state(pdev);\r\nif (!netif_running(dev))\r\nreturn 0;\r\npci_set_power_state(pdev, PCI_D0);\r\ntc35815_restart(dev);\r\nnetif_carrier_off(dev);\r\nif (dev->phydev)\r\nphy_start(dev->phydev);\r\nnetif_device_attach(dev);\r\nreturn 0;\r\n}
