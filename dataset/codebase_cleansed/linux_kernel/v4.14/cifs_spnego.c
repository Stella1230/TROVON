static int\r\ncifs_spnego_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\r\n{\r\nchar *payload;\r\nint ret;\r\nret = -ENOMEM;\r\npayload = kmemdup(prep->data, prep->datalen, GFP_KERNEL);\r\nif (!payload)\r\ngoto error;\r\nkey->payload.data[0] = payload;\r\nret = 0;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic void\r\ncifs_spnego_key_destroy(struct key *key)\r\n{\r\nkfree(key->payload.data[0]);\r\n}\r\nstruct key *\r\ncifs_get_spnego_key(struct cifs_ses *sesInfo)\r\n{\r\nstruct TCP_Server_Info *server = sesInfo->server;\r\nstruct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;\r\nstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;\r\nchar *description, *dp;\r\nsize_t desc_len;\r\nstruct key *spnego_key;\r\nconst char *hostname = server->hostname;\r\nconst struct cred *saved_cred;\r\ndesc_len = MAX_VER_STR_LEN +\r\nHOST_KEY_LEN + strlen(hostname) +\r\nIP_KEY_LEN + INET6_ADDRSTRLEN +\r\nMAX_MECH_STR_LEN +\r\nUID_KEY_LEN + (sizeof(uid_t) * 2) +\r\nCREDUID_KEY_LEN + (sizeof(uid_t) * 2) +\r\nPID_KEY_LEN + (sizeof(pid_t) * 2) + 1;\r\nif (sesInfo->user_name)\r\ndesc_len += USER_KEY_LEN + strlen(sesInfo->user_name);\r\nspnego_key = ERR_PTR(-ENOMEM);\r\ndescription = kzalloc(desc_len, GFP_KERNEL);\r\nif (description == NULL)\r\ngoto out;\r\ndp = description;\r\nspnego_key = ERR_PTR(-EINVAL);\r\nsprintf(dp, "ver=0x%x;host=%s;", CIFS_SPNEGO_UPCALL_VERSION,\r\nhostname);\r\ndp = description + strlen(description);\r\nif (server->dstaddr.ss_family == AF_INET)\r\nsprintf(dp, "ip4=%pI4", &sa->sin_addr);\r\nelse if (server->dstaddr.ss_family == AF_INET6)\r\nsprintf(dp, "ip6=%pI6", &sa6->sin6_addr);\r\nelse\r\ngoto out;\r\ndp = description + strlen(description);\r\nif (server->sec_kerberos)\r\nsprintf(dp, ";sec=krb5");\r\nelse if (server->sec_mskerberos)\r\nsprintf(dp, ";sec=mskrb5");\r\nelse\r\ngoto out;\r\ndp = description + strlen(description);\r\nsprintf(dp, ";uid=0x%x",\r\nfrom_kuid_munged(&init_user_ns, sesInfo->linux_uid));\r\ndp = description + strlen(description);\r\nsprintf(dp, ";creduid=0x%x",\r\nfrom_kuid_munged(&init_user_ns, sesInfo->cred_uid));\r\nif (sesInfo->user_name) {\r\ndp = description + strlen(description);\r\nsprintf(dp, ";user=%s", sesInfo->user_name);\r\n}\r\ndp = description + strlen(description);\r\nsprintf(dp, ";pid=0x%x", current->pid);\r\ncifs_dbg(FYI, "key description = %s\n", description);\r\nsaved_cred = override_creds(spnego_cred);\r\nspnego_key = request_key(&cifs_spnego_key_type, description, "");\r\nrevert_creds(saved_cred);\r\n#ifdef CONFIG_CIFS_DEBUG2\r\nif (cifsFYI && !IS_ERR(spnego_key)) {\r\nstruct cifs_spnego_msg *msg = spnego_key->payload.data[0];\r\ncifs_dump_mem("SPNEGO reply blob:", msg->data, min(1024U,\r\nmsg->secblob_len + msg->sesskey_len));\r\n}\r\n#endif\r\nout:\r\nkfree(description);\r\nreturn spnego_key;\r\n}\r\nint\r\ninit_cifs_spnego(void)\r\n{\r\nstruct cred *cred;\r\nstruct key *keyring;\r\nint ret;\r\ncifs_dbg(FYI, "Registering the %s key type\n",\r\ncifs_spnego_key_type.name);\r\ncred = prepare_kernel_cred(NULL);\r\nif (!cred)\r\nreturn -ENOMEM;\r\nkeyring = keyring_alloc(".cifs_spnego",\r\nGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\r\n(KEY_POS_ALL & ~KEY_POS_SETATTR) |\r\nKEY_USR_VIEW | KEY_USR_READ,\r\nKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\r\nif (IS_ERR(keyring)) {\r\nret = PTR_ERR(keyring);\r\ngoto failed_put_cred;\r\n}\r\nret = register_key_type(&cifs_spnego_key_type);\r\nif (ret < 0)\r\ngoto failed_put_key;\r\nset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\r\ncred->thread_keyring = keyring;\r\ncred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\r\nspnego_cred = cred;\r\ncifs_dbg(FYI, "cifs spnego keyring: %d\n", key_serial(keyring));\r\nreturn 0;\r\nfailed_put_key:\r\nkey_put(keyring);\r\nfailed_put_cred:\r\nput_cred(cred);\r\nreturn ret;\r\n}\r\nvoid\r\nexit_cifs_spnego(void)\r\n{\r\nkey_revoke(spnego_cred->thread_keyring);\r\nunregister_key_type(&cifs_spnego_key_type);\r\nput_cred(spnego_cred);\r\ncifs_dbg(FYI, "Unregistered %s key type\n", cifs_spnego_key_type.name);\r\n}
