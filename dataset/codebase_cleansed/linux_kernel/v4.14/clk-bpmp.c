static inline struct tegra_bpmp_clk *to_tegra_bpmp_clk(struct clk_hw *hw)\r\n{\r\nreturn container_of(hw, struct tegra_bpmp_clk, hw);\r\n}\r\nstatic int tegra_bpmp_clk_transfer(struct tegra_bpmp *bpmp,\r\nconst struct tegra_bpmp_clk_message *clk)\r\n{\r\nstruct mrq_clk_request request;\r\nstruct tegra_bpmp_message msg;\r\nvoid *req = &request;\r\nmemset(&request, 0, sizeof(request));\r\nrequest.cmd_and_id = (clk->cmd << 24) | clk->id;\r\nmemcpy(req + 4, clk->tx.data, clk->tx.size);\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.mrq = MRQ_CLK;\r\nmsg.tx.data = &request;\r\nmsg.tx.size = sizeof(request);\r\nmsg.rx.data = clk->rx.data;\r\nmsg.rx.size = clk->rx.size;\r\nreturn tegra_bpmp_transfer(bpmp, &msg);\r\n}\r\nstatic int tegra_bpmp_clk_prepare(struct clk_hw *hw)\r\n{\r\nstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\r\nstruct tegra_bpmp_clk_message msg;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.cmd = CMD_CLK_ENABLE;\r\nmsg.id = clk->id;\r\nreturn tegra_bpmp_clk_transfer(clk->bpmp, &msg);\r\n}\r\nstatic void tegra_bpmp_clk_unprepare(struct clk_hw *hw)\r\n{\r\nstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\r\nstruct tegra_bpmp_clk_message msg;\r\nint err;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.cmd = CMD_CLK_DISABLE;\r\nmsg.id = clk->id;\r\nerr = tegra_bpmp_clk_transfer(clk->bpmp, &msg);\r\nif (err < 0)\r\ndev_err(clk->bpmp->dev, "failed to disable clock %s: %d\n",\r\nclk_hw_get_name(hw), err);\r\n}\r\nstatic int tegra_bpmp_clk_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\r\nstruct cmd_clk_is_enabled_response response;\r\nstruct tegra_bpmp_clk_message msg;\r\nint err;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.cmd = CMD_CLK_IS_ENABLED;\r\nmsg.id = clk->id;\r\nmsg.rx.data = &response;\r\nmsg.rx.size = sizeof(response);\r\nerr = tegra_bpmp_clk_transfer(clk->bpmp, &msg);\r\nif (err < 0)\r\nreturn err;\r\nreturn response.state;\r\n}\r\nstatic unsigned long tegra_bpmp_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\r\nstruct cmd_clk_get_rate_response response;\r\nstruct cmd_clk_get_rate_request request;\r\nstruct tegra_bpmp_clk_message msg;\r\nint err;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.cmd = CMD_CLK_GET_RATE;\r\nmsg.id = clk->id;\r\nmsg.tx.data = &request;\r\nmsg.tx.size = sizeof(request);\r\nmsg.rx.data = &response;\r\nmsg.rx.size = sizeof(response);\r\nerr = tegra_bpmp_clk_transfer(clk->bpmp, &msg);\r\nif (err < 0)\r\nreturn err;\r\nreturn response.rate;\r\n}\r\nstatic long tegra_bpmp_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\r\nstruct cmd_clk_round_rate_response response;\r\nstruct cmd_clk_round_rate_request request;\r\nstruct tegra_bpmp_clk_message msg;\r\nint err;\r\nmemset(&request, 0, sizeof(request));\r\nrequest.rate = rate;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.cmd = CMD_CLK_ROUND_RATE;\r\nmsg.id = clk->id;\r\nmsg.tx.data = &request;\r\nmsg.tx.size = sizeof(request);\r\nmsg.rx.data = &response;\r\nmsg.rx.size = sizeof(response);\r\nerr = tegra_bpmp_clk_transfer(clk->bpmp, &msg);\r\nif (err < 0)\r\nreturn err;\r\nreturn response.rate;\r\n}\r\nstatic int tegra_bpmp_clk_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\r\nstruct cmd_clk_set_parent_response response;\r\nstruct cmd_clk_set_parent_request request;\r\nstruct tegra_bpmp_clk_message msg;\r\nint err;\r\nmemset(&request, 0, sizeof(request));\r\nrequest.parent_id = clk->parents[index];\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.cmd = CMD_CLK_SET_PARENT;\r\nmsg.id = clk->id;\r\nmsg.tx.data = &request;\r\nmsg.tx.size = sizeof(request);\r\nmsg.rx.data = &response;\r\nmsg.rx.size = sizeof(response);\r\nerr = tegra_bpmp_clk_transfer(clk->bpmp, &msg);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic u8 tegra_bpmp_clk_get_parent(struct clk_hw *hw)\r\n{\r\nstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\r\nstruct cmd_clk_get_parent_response response;\r\nstruct tegra_bpmp_clk_message msg;\r\nunsigned int i;\r\nint err;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.cmd = CMD_CLK_GET_PARENT;\r\nmsg.id = clk->id;\r\nmsg.rx.data = &response;\r\nmsg.rx.size = sizeof(response);\r\nerr = tegra_bpmp_clk_transfer(clk->bpmp, &msg);\r\nif (err < 0) {\r\ndev_err(clk->bpmp->dev, "failed to get parent for %s: %d\n",\r\nclk_hw_get_name(hw), err);\r\nreturn U8_MAX;\r\n}\r\nfor (i = 0; i < clk->num_parents; i++)\r\nif (clk->parents[i] == response.parent_id)\r\nreturn i;\r\nreturn U8_MAX;\r\n}\r\nstatic int tegra_bpmp_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct tegra_bpmp_clk *clk = to_tegra_bpmp_clk(hw);\r\nstruct cmd_clk_set_rate_response response;\r\nstruct cmd_clk_set_rate_request request;\r\nstruct tegra_bpmp_clk_message msg;\r\nmemset(&request, 0, sizeof(request));\r\nrequest.rate = rate;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.cmd = CMD_CLK_SET_RATE;\r\nmsg.id = clk->id;\r\nmsg.tx.data = &request;\r\nmsg.tx.size = sizeof(request);\r\nmsg.rx.data = &response;\r\nmsg.rx.size = sizeof(response);\r\nreturn tegra_bpmp_clk_transfer(clk->bpmp, &msg);\r\n}\r\nstatic int tegra_bpmp_clk_get_max_id(struct tegra_bpmp *bpmp)\r\n{\r\nstruct cmd_clk_get_max_clk_id_response response;\r\nstruct tegra_bpmp_clk_message msg;\r\nint err;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.cmd = CMD_CLK_GET_MAX_CLK_ID;\r\nmsg.rx.data = &response;\r\nmsg.rx.size = sizeof(response);\r\nerr = tegra_bpmp_clk_transfer(bpmp, &msg);\r\nif (err < 0)\r\nreturn err;\r\nif (response.max_id > INT_MAX)\r\nreturn -E2BIG;\r\nreturn response.max_id;\r\n}\r\nstatic int tegra_bpmp_clk_get_info(struct tegra_bpmp *bpmp, unsigned int id,\r\nstruct tegra_bpmp_clk_info *info)\r\n{\r\nstruct cmd_clk_get_all_info_response response;\r\nstruct tegra_bpmp_clk_message msg;\r\nunsigned int i;\r\nint err;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.cmd = CMD_CLK_GET_ALL_INFO;\r\nmsg.id = id;\r\nmsg.rx.data = &response;\r\nmsg.rx.size = sizeof(response);\r\nerr = tegra_bpmp_clk_transfer(bpmp, &msg);\r\nif (err < 0)\r\nreturn err;\r\nstrlcpy(info->name, response.name, MRQ_CLK_NAME_MAXLEN);\r\ninfo->num_parents = response.num_parents;\r\nfor (i = 0; i < info->num_parents; i++)\r\ninfo->parents[i] = response.parents[i];\r\ninfo->flags = response.flags;\r\nreturn 0;\r\n}\r\nstatic void tegra_bpmp_clk_info_dump(struct tegra_bpmp *bpmp,\r\nconst char *level,\r\nconst struct tegra_bpmp_clk_info *info)\r\n{\r\nconst char *prefix = "";\r\nstruct seq_buf buf;\r\nunsigned int i;\r\nchar flags[64];\r\nseq_buf_init(&buf, flags, sizeof(flags));\r\nif (info->flags)\r\nseq_buf_printf(&buf, "(");\r\nif (info->flags & TEGRA_BPMP_CLK_HAS_MUX) {\r\nseq_buf_printf(&buf, "%smux", prefix);\r\nprefix = ", ";\r\n}\r\nif ((info->flags & TEGRA_BPMP_CLK_HAS_SET_RATE) == 0) {\r\nseq_buf_printf(&buf, "%sfixed", prefix);\r\nprefix = ", ";\r\n}\r\nif (info->flags & TEGRA_BPMP_CLK_IS_ROOT) {\r\nseq_buf_printf(&buf, "%sroot", prefix);\r\nprefix = ", ";\r\n}\r\nif (info->flags)\r\nseq_buf_printf(&buf, ")");\r\ndev_printk(level, bpmp->dev, "%03u: %s\n", info->id, info->name);\r\ndev_printk(level, bpmp->dev, " flags: %lx %s\n", info->flags, flags);\r\ndev_printk(level, bpmp->dev, " parents: %u\n", info->num_parents);\r\nfor (i = 0; i < info->num_parents; i++)\r\ndev_printk(level, bpmp->dev, " %03u\n", info->parents[i]);\r\n}\r\nstatic int tegra_bpmp_probe_clocks(struct tegra_bpmp *bpmp,\r\nstruct tegra_bpmp_clk_info **clocksp)\r\n{\r\nstruct tegra_bpmp_clk_info *clocks;\r\nunsigned int max_id, id, count = 0;\r\nunsigned int holes = 0;\r\nint err;\r\nerr = tegra_bpmp_clk_get_max_id(bpmp);\r\nif (err < 0)\r\nreturn err;\r\nmax_id = err;\r\ndev_dbg(bpmp->dev, "maximum clock ID: %u\n", max_id);\r\nclocks = kcalloc(max_id + 1, sizeof(*clocks), GFP_KERNEL);\r\nif (!clocks)\r\nreturn -ENOMEM;\r\nfor (id = 0; id <= max_id; id++) {\r\nstruct tegra_bpmp_clk_info *info = &clocks[count];\r\nerr = tegra_bpmp_clk_get_info(bpmp, id, info);\r\nif (err < 0) {\r\ndev_err(bpmp->dev, "failed to query clock %u: %d\n",\r\nid, err);\r\ncontinue;\r\n}\r\nif (info->num_parents >= U8_MAX) {\r\ndev_err(bpmp->dev,\r\n"clock %u has too many parents (%u, max: %u)\n",\r\nid, info->num_parents, U8_MAX);\r\ncontinue;\r\n}\r\nif (info->name[0] == '\0') {\r\nholes++;\r\ncontinue;\r\n}\r\ninfo->id = id;\r\ncount++;\r\nif (TEGRA_BPMP_DUMP_CLOCK_INFO)\r\ntegra_bpmp_clk_info_dump(bpmp, KERN_DEBUG, info);\r\n}\r\ndev_dbg(bpmp->dev, "holes: %u\n", holes);\r\n*clocksp = clocks;\r\nreturn count;\r\n}\r\nstatic const struct tegra_bpmp_clk_info *\r\ntegra_bpmp_clk_find(const struct tegra_bpmp_clk_info *clocks,\r\nunsigned int num_clocks, unsigned int id)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num_clocks; i++)\r\nif (clocks[i].id == id)\r\nreturn &clocks[i];\r\nreturn NULL;\r\n}\r\nstatic struct tegra_bpmp_clk *\r\ntegra_bpmp_clk_register(struct tegra_bpmp *bpmp,\r\nconst struct tegra_bpmp_clk_info *info,\r\nconst struct tegra_bpmp_clk_info *clocks,\r\nunsigned int num_clocks)\r\n{\r\nstruct tegra_bpmp_clk *clk;\r\nstruct clk_init_data init;\r\nconst char **parents;\r\nunsigned int i;\r\nint err;\r\nclk = devm_kzalloc(bpmp->dev, sizeof(*clk), GFP_KERNEL);\r\nif (!clk)\r\nreturn ERR_PTR(-ENOMEM);\r\nclk->id = info->id;\r\nclk->bpmp = bpmp;\r\nclk->parents = devm_kcalloc(bpmp->dev, info->num_parents,\r\nsizeof(*clk->parents), GFP_KERNEL);\r\nif (!clk->parents)\r\nreturn ERR_PTR(-ENOMEM);\r\nclk->num_parents = info->num_parents;\r\nmemset(&init, 0, sizeof(init));\r\ninit.name = info->name;\r\nclk->hw.init = &init;\r\nif (info->flags & TEGRA_BPMP_CLK_HAS_MUX) {\r\nif (info->flags & TEGRA_BPMP_CLK_HAS_SET_RATE)\r\ninit.ops = &tegra_bpmp_clk_mux_rate_ops;\r\nelse\r\ninit.ops = &tegra_bpmp_clk_mux_ops;\r\n} else {\r\nif (info->flags & TEGRA_BPMP_CLK_HAS_SET_RATE)\r\ninit.ops = &tegra_bpmp_clk_rate_ops;\r\nelse\r\ninit.ops = &tegra_bpmp_clk_gate_ops;\r\n}\r\ninit.num_parents = info->num_parents;\r\nparents = kcalloc(info->num_parents, sizeof(*parents), GFP_KERNEL);\r\nif (!parents)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < info->num_parents; i++) {\r\nconst struct tegra_bpmp_clk_info *parent;\r\nclk->parents[i] = info->parents[i];\r\nparent = tegra_bpmp_clk_find(clocks, num_clocks,\r\ninfo->parents[i]);\r\nif (!parent) {\r\ndev_err(bpmp->dev, "no parent %u found for %u\n",\r\ninfo->parents[i], info->id);\r\ncontinue;\r\n}\r\nparents[i] = parent->name;\r\n}\r\ninit.parent_names = parents;\r\nerr = devm_clk_hw_register(bpmp->dev, &clk->hw);\r\nkfree(parents);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nreturn clk;\r\n}\r\nstatic int tegra_bpmp_register_clocks(struct tegra_bpmp *bpmp,\r\nstruct tegra_bpmp_clk_info *infos,\r\nunsigned int count)\r\n{\r\nstruct tegra_bpmp_clk *clk;\r\nunsigned int i;\r\nbpmp->num_clocks = count;\r\nbpmp->clocks = devm_kcalloc(bpmp->dev, count, sizeof(clk), GFP_KERNEL);\r\nif (!bpmp->clocks)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < count; i++) {\r\nstruct tegra_bpmp_clk_info *info = &infos[i];\r\nclk = tegra_bpmp_clk_register(bpmp, info, infos, count);\r\nif (IS_ERR(clk)) {\r\ndev_err(bpmp->dev,\r\n"failed to register clock %u (%s): %ld\n",\r\ninfo->id, info->name, PTR_ERR(clk));\r\ncontinue;\r\n}\r\nbpmp->clocks[i] = clk;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tegra_bpmp_unregister_clocks(struct tegra_bpmp *bpmp)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < bpmp->num_clocks; i++)\r\nclk_hw_unregister(&bpmp->clocks[i]->hw);\r\n}\r\nstatic struct clk_hw *tegra_bpmp_clk_of_xlate(struct of_phandle_args *clkspec,\r\nvoid *data)\r\n{\r\nunsigned int id = clkspec->args[0], i;\r\nstruct tegra_bpmp *bpmp = data;\r\nfor (i = 0; i < bpmp->num_clocks; i++)\r\nif (bpmp->clocks[i]->id == id)\r\nreturn &bpmp->clocks[i]->hw;\r\nreturn NULL;\r\n}\r\nint tegra_bpmp_init_clocks(struct tegra_bpmp *bpmp)\r\n{\r\nstruct tegra_bpmp_clk_info *clocks;\r\nunsigned int count;\r\nint err;\r\nerr = tegra_bpmp_probe_clocks(bpmp, &clocks);\r\nif (err < 0)\r\nreturn err;\r\ncount = err;\r\ndev_dbg(bpmp->dev, "%u clocks probed\n", count);\r\nerr = tegra_bpmp_register_clocks(bpmp, clocks, count);\r\nif (err < 0)\r\ngoto free;\r\nerr = of_clk_add_hw_provider(bpmp->dev->of_node,\r\ntegra_bpmp_clk_of_xlate,\r\nbpmp);\r\nif (err < 0) {\r\ntegra_bpmp_unregister_clocks(bpmp);\r\ngoto free;\r\n}\r\nfree:\r\nkfree(clocks);\r\nreturn err;\r\n}
