static bool set_baseband_agc_config(struct adapter *adapt)\r\n{\r\nu32 i;\r\nconst u32 arraylen = ARRAY_SIZE(array_agc_tab_1t_8188e);\r\nu32 *array = array_agc_tab_1t_8188e;\r\nfor (i = 0; i < arraylen; i += 2) {\r\nu32 v1 = array[i];\r\nu32 v2 = array[i + 1];\r\nif (v1 < 0xCDCDCDCD) {\r\nphy_set_bb_reg(adapt, v1, bMaskDWord, v2);\r\nudelay(1);\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic void rtl_bb_delay(struct adapter *adapt, u32 addr, u32 data)\r\n{\r\nif (addr == 0xfe) {\r\nmsleep(50);\r\n} else if (addr == 0xfd) {\r\nmdelay(5);\r\n} else if (addr == 0xfc) {\r\nmdelay(1);\r\n} else if (addr == 0xfb) {\r\nudelay(50);\r\n} else if (addr == 0xfa) {\r\nudelay(5);\r\n} else if (addr == 0xf9) {\r\nudelay(1);\r\n} else {\r\nphy_set_bb_reg(adapt, addr, bMaskDWord, data);\r\nudelay(1);\r\n}\r\n}\r\nstatic bool set_baseband_phy_config(struct adapter *adapt)\r\n{\r\nu32 i;\r\nconst u32 arraylen = ARRAY_SIZE(array_phy_reg_1t_8188e);\r\nu32 *array = array_phy_reg_1t_8188e;\r\nfor (i = 0; i < arraylen; i += 2) {\r\nu32 v1 = array[i];\r\nu32 v2 = array[i + 1];\r\nif (v1 < 0xCDCDCDCD)\r\nrtl_bb_delay(adapt, v1, v2);\r\n}\r\nreturn true;\r\n}\r\nstatic void store_pwrindex_offset(struct adapter *adapter,\r\nu32 regaddr, u32 bitmask, u32 data)\r\n{\r\nstruct hal_data_8188e *hal_data = adapter->HalData;\r\nu32 * const power_level_offset =\r\nhal_data->MCSTxPowerLevelOriginalOffset[hal_data->pwrGroupCnt];\r\nif (regaddr == rTxAGC_A_Rate18_06)\r\npower_level_offset[0] = data;\r\nif (regaddr == rTxAGC_A_Rate54_24)\r\npower_level_offset[1] = data;\r\nif (regaddr == rTxAGC_A_CCK1_Mcs32)\r\npower_level_offset[6] = data;\r\nif (regaddr == rTxAGC_B_CCK11_A_CCK2_11 && bitmask == 0xffffff00)\r\npower_level_offset[7] = data;\r\nif (regaddr == rTxAGC_A_Mcs03_Mcs00)\r\npower_level_offset[2] = data;\r\nif (regaddr == rTxAGC_A_Mcs07_Mcs04)\r\npower_level_offset[3] = data;\r\nif (regaddr == rTxAGC_A_Mcs11_Mcs08)\r\npower_level_offset[4] = data;\r\nif (regaddr == rTxAGC_A_Mcs15_Mcs12) {\r\npower_level_offset[5] = data;\r\nhal_data->pwrGroupCnt++;\r\n}\r\nif (regaddr == rTxAGC_B_Rate18_06)\r\npower_level_offset[8] = data;\r\nif (regaddr == rTxAGC_B_Rate54_24)\r\npower_level_offset[9] = data;\r\nif (regaddr == rTxAGC_B_CCK1_55_Mcs32)\r\npower_level_offset[14] = data;\r\nif (regaddr == rTxAGC_B_CCK11_A_CCK2_11 && bitmask == 0x000000ff)\r\npower_level_offset[15] = data;\r\nif (regaddr == rTxAGC_B_Mcs03_Mcs00)\r\npower_level_offset[10] = data;\r\nif (regaddr == rTxAGC_B_Mcs07_Mcs04)\r\npower_level_offset[11] = data;\r\nif (regaddr == rTxAGC_B_Mcs11_Mcs08)\r\npower_level_offset[12] = data;\r\nif (regaddr == rTxAGC_B_Mcs15_Mcs12)\r\npower_level_offset[13] = data;\r\n}\r\nstatic void rtl_addr_delay(struct adapter *adapt,\r\nu32 addr, u32 bit_mask, u32 data)\r\n{\r\nswitch (addr) {\r\ncase 0xfe:\r\nmsleep(50);\r\nbreak;\r\ncase 0xfd:\r\nmdelay(5);\r\nbreak;\r\ncase 0xfc:\r\nmdelay(1);\r\nbreak;\r\ncase 0xfb:\r\nudelay(50);\r\nbreak;\r\ncase 0xfa:\r\nudelay(5);\r\nbreak;\r\ncase 0xf9:\r\nudelay(1);\r\nbreak;\r\ndefault:\r\nstore_pwrindex_offset(adapt, addr, bit_mask, data);\r\n}\r\n}\r\nstatic bool config_bb_with_pgheader(struct adapter *adapt)\r\n{\r\nu32 i;\r\nconst u32 arraylen = ARRAY_SIZE(array_phy_reg_pg_8188e);\r\nu32 *array = array_phy_reg_pg_8188e;\r\nfor (i = 0; i < arraylen; i += 3) {\r\nu32 v1 = array[i];\r\nu32 v2 = array[i + 1];\r\nu32 v3 = array[i + 2];\r\nif (v1 < 0xCDCDCDCD)\r\nrtl_addr_delay(adapt, v1, v2, v3);\r\n}\r\nreturn true;\r\n}\r\nstatic void rtl88e_phy_init_bb_rf_register_definition(struct adapter *adapter)\r\n{\r\nstruct bb_reg_def *reg[4];\r\nreg[RF_PATH_A] = &adapter->HalData->PHYRegDef[RF_PATH_A];\r\nreg[RF_PATH_B] = &adapter->HalData->PHYRegDef[RF_PATH_B];\r\nreg[RF_PATH_A]->rfintfs = rFPGA0_XAB_RFInterfaceSW;\r\nreg[RF_PATH_B]->rfintfs = rFPGA0_XAB_RFInterfaceSW;\r\nreg[RF_PATH_A]->rfintfi = rFPGA0_XAB_RFInterfaceRB;\r\nreg[RF_PATH_B]->rfintfi = rFPGA0_XAB_RFInterfaceRB;\r\nreg[RF_PATH_A]->rfintfo = rFPGA0_XA_RFInterfaceOE;\r\nreg[RF_PATH_B]->rfintfo = rFPGA0_XB_RFInterfaceOE;\r\nreg[RF_PATH_A]->rfintfe = rFPGA0_XA_RFInterfaceOE;\r\nreg[RF_PATH_B]->rfintfe = rFPGA0_XB_RFInterfaceOE;\r\nreg[RF_PATH_A]->rf3wireOffset = rFPGA0_XA_LSSIParameter;\r\nreg[RF_PATH_B]->rf3wireOffset = rFPGA0_XB_LSSIParameter;\r\nreg[RF_PATH_A]->rfLSSI_Select = rFPGA0_XAB_RFParameter;\r\nreg[RF_PATH_B]->rfLSSI_Select = rFPGA0_XAB_RFParameter;\r\nreg[RF_PATH_A]->rfTxGainStage = rFPGA0_TxGainStage;\r\nreg[RF_PATH_B]->rfTxGainStage = rFPGA0_TxGainStage;\r\nreg[RF_PATH_A]->rfHSSIPara1 = rFPGA0_XA_HSSIParameter1;\r\nreg[RF_PATH_B]->rfHSSIPara1 = rFPGA0_XB_HSSIParameter1;\r\nreg[RF_PATH_A]->rfHSSIPara2 = rFPGA0_XA_HSSIParameter2;\r\nreg[RF_PATH_B]->rfHSSIPara2 = rFPGA0_XB_HSSIParameter2;\r\nreg[RF_PATH_A]->rfSwitchControl = rFPGA0_XAB_SwitchControl;\r\nreg[RF_PATH_B]->rfSwitchControl = rFPGA0_XAB_SwitchControl;\r\nreg[RF_PATH_A]->rfAGCControl1 = rOFDM0_XAAGCCore1;\r\nreg[RF_PATH_B]->rfAGCControl1 = rOFDM0_XBAGCCore1;\r\nreg[RF_PATH_A]->rfAGCControl2 = rOFDM0_XAAGCCore2;\r\nreg[RF_PATH_B]->rfAGCControl2 = rOFDM0_XBAGCCore2;\r\nreg[RF_PATH_A]->rfRxIQImbalance = rOFDM0_XARxIQImbalance;\r\nreg[RF_PATH_B]->rfRxIQImbalance = rOFDM0_XBRxIQImbalance;\r\nreg[RF_PATH_A]->rfRxAFE = rOFDM0_XARxAFE;\r\nreg[RF_PATH_B]->rfRxAFE = rOFDM0_XBRxAFE;\r\nreg[RF_PATH_A]->rfTxIQImbalance = rOFDM0_XATxIQImbalance;\r\nreg[RF_PATH_B]->rfTxIQImbalance = rOFDM0_XBTxIQImbalance;\r\nreg[RF_PATH_A]->rfTxAFE = rOFDM0_XATxAFE;\r\nreg[RF_PATH_B]->rfTxAFE = rOFDM0_XBTxAFE;\r\nreg[RF_PATH_A]->rfLSSIReadBack = rFPGA0_XA_LSSIReadBack;\r\nreg[RF_PATH_B]->rfLSSIReadBack = rFPGA0_XB_LSSIReadBack;\r\nreg[RF_PATH_A]->rfLSSIReadBackPi = TransceiverA_HSPI_Readback;\r\nreg[RF_PATH_B]->rfLSSIReadBackPi = TransceiverB_HSPI_Readback;\r\n}\r\nstatic bool config_parafile(struct adapter *adapt)\r\n{\r\nstruct eeprom_priv *eeprom = GET_EEPROM_EFUSE_PRIV(adapt);\r\nset_baseband_phy_config(adapt);\r\nif (!eeprom->bautoload_fail_flag) {\r\nadapt->HalData->pwrGroupCnt = 0;\r\nconfig_bb_with_pgheader(adapt);\r\n}\r\nset_baseband_agc_config(adapt);\r\nreturn true;\r\n}\r\nbool rtl88eu_phy_bb_config(struct adapter *adapt)\r\n{\r\nint rtstatus = true;\r\nu32 regval;\r\nu8 crystal_cap;\r\nrtl88e_phy_init_bb_rf_register_definition(adapt);\r\nregval = usb_read16(adapt, REG_SYS_FUNC_EN);\r\nusb_write16(adapt, REG_SYS_FUNC_EN,\r\n(u16)(regval | BIT(13) | BIT(0) | BIT(1)));\r\nusb_write8(adapt, REG_RF_CTRL, RF_EN | RF_RSTB | RF_SDMRSTB);\r\nusb_write8(adapt, REG_SYS_FUNC_EN, FEN_USBA |\r\nFEN_USBD | FEN_BB_GLB_RSTn | FEN_BBRSTB);\r\nrtstatus = config_parafile(adapt);\r\ncrystal_cap = adapt->HalData->CrystalCap & 0x3F;\r\nphy_set_bb_reg(adapt, REG_AFE_XTAL_CTRL, 0x7ff800,\r\n(crystal_cap | (crystal_cap << 6)));\r\nreturn rtstatus;\r\n}
