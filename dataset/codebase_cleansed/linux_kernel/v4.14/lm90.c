static inline s32 adm1032_write_byte(struct i2c_client *client, u8 value)\r\n{\r\nreturn i2c_smbus_xfer(client->adapter, client->addr,\r\nclient->flags & ~I2C_CLIENT_PEC,\r\nI2C_SMBUS_WRITE, value, I2C_SMBUS_BYTE, NULL);\r\n}\r\nstatic int lm90_read_reg(struct i2c_client *client, u8 reg)\r\n{\r\nint err;\r\nif (client->flags & I2C_CLIENT_PEC) {\r\nerr = adm1032_write_byte(client, reg);\r\nif (err >= 0)\r\nerr = i2c_smbus_read_byte(client);\r\n} else\r\nerr = i2c_smbus_read_byte_data(client, reg);\r\nreturn err;\r\n}\r\nstatic int lm90_read16(struct i2c_client *client, u8 regh, u8 regl)\r\n{\r\nint oldh, newh, l;\r\noldh = lm90_read_reg(client, regh);\r\nif (oldh < 0)\r\nreturn oldh;\r\nl = lm90_read_reg(client, regl);\r\nif (l < 0)\r\nreturn l;\r\nnewh = lm90_read_reg(client, regh);\r\nif (newh < 0)\r\nreturn newh;\r\nif (oldh != newh) {\r\nl = lm90_read_reg(client, regl);\r\nif (l < 0)\r\nreturn l;\r\n}\r\nreturn (newh << 8) | l;\r\n}\r\nstatic inline int lm90_select_remote_channel(struct i2c_client *client,\r\nstruct lm90_data *data,\r\nint channel)\r\n{\r\nint config;\r\nif (data->kind == max6696) {\r\nconfig = lm90_read_reg(client, LM90_REG_R_CONFIG1);\r\nif (config < 0)\r\nreturn config;\r\nconfig &= ~0x08;\r\nif (channel)\r\nconfig |= 0x08;\r\ni2c_smbus_write_byte_data(client, LM90_REG_W_CONFIG1,\r\nconfig);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lm90_set_convrate(struct i2c_client *client, struct lm90_data *data,\r\nunsigned int interval)\r\n{\r\nunsigned int update_interval;\r\nint i, err;\r\ninterval <<= 6;\r\nfor (i = 0, update_interval = LM90_MAX_CONVRATE_MS << 6;\r\ni < data->max_convrate; i++, update_interval >>= 1)\r\nif (interval >= update_interval * 3 / 4)\r\nbreak;\r\nerr = i2c_smbus_write_byte_data(client, LM90_REG_W_CONVRATE, i);\r\ndata->update_interval = DIV_ROUND_CLOSEST(update_interval, 64);\r\nreturn err;\r\n}\r\nstatic int lm90_update_limits(struct device *dev)\r\n{\r\nstruct lm90_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint val;\r\nval = lm90_read_reg(client, LM90_REG_R_LOCAL_CRIT);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp8[LOCAL_CRIT] = val;\r\nval = lm90_read_reg(client, LM90_REG_R_REMOTE_CRIT);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp8[REMOTE_CRIT] = val;\r\nval = lm90_read_reg(client, LM90_REG_R_TCRIT_HYST);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp_hyst = val;\r\nval = lm90_read_reg(client, LM90_REG_R_REMOTE_LOWH);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp11[REMOTE_LOW] = val << 8;\r\nif (data->flags & LM90_HAVE_REM_LIMIT_EXT) {\r\nval = lm90_read_reg(client, LM90_REG_R_REMOTE_LOWL);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp11[REMOTE_LOW] |= val;\r\n}\r\nval = lm90_read_reg(client, LM90_REG_R_REMOTE_HIGHH);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp11[REMOTE_HIGH] = val << 8;\r\nif (data->flags & LM90_HAVE_REM_LIMIT_EXT) {\r\nval = lm90_read_reg(client, LM90_REG_R_REMOTE_HIGHL);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp11[REMOTE_HIGH] |= val;\r\n}\r\nif (data->flags & LM90_HAVE_OFFSET) {\r\nval = lm90_read16(client, LM90_REG_R_REMOTE_OFFSH,\r\nLM90_REG_R_REMOTE_OFFSL);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp11[REMOTE_OFFSET] = val;\r\n}\r\nif (data->flags & LM90_HAVE_EMERGENCY) {\r\nval = lm90_read_reg(client, MAX6659_REG_R_LOCAL_EMERG);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp8[LOCAL_EMERG] = val;\r\nval = lm90_read_reg(client, MAX6659_REG_R_REMOTE_EMERG);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp8[REMOTE_EMERG] = val;\r\n}\r\nif (data->kind == max6696) {\r\nval = lm90_select_remote_channel(client, data, 1);\r\nif (val < 0)\r\nreturn val;\r\nval = lm90_read_reg(client, LM90_REG_R_REMOTE_CRIT);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp8[REMOTE2_CRIT] = val;\r\nval = lm90_read_reg(client, MAX6659_REG_R_REMOTE_EMERG);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp8[REMOTE2_EMERG] = val;\r\nval = lm90_read_reg(client, LM90_REG_R_REMOTE_LOWH);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp11[REMOTE2_LOW] = val << 8;\r\nval = lm90_read_reg(client, LM90_REG_R_REMOTE_HIGHH);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp11[REMOTE2_HIGH] = val << 8;\r\nlm90_select_remote_channel(client, data, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lm90_update_device(struct device *dev)\r\n{\r\nstruct lm90_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long next_update;\r\nint val;\r\nif (!data->valid) {\r\nval = lm90_update_limits(dev);\r\nif (val < 0)\r\nreturn val;\r\n}\r\nnext_update = data->last_updated +\r\nmsecs_to_jiffies(data->update_interval);\r\nif (time_after(jiffies, next_update) || !data->valid) {\r\ndev_dbg(&client->dev, "Updating lm90 data.\n");\r\ndata->valid = false;\r\nval = lm90_read_reg(client, LM90_REG_R_LOCAL_LOW);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp8[LOCAL_LOW] = val;\r\nval = lm90_read_reg(client, LM90_REG_R_LOCAL_HIGH);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp8[LOCAL_HIGH] = val;\r\nif (data->reg_local_ext) {\r\nval = lm90_read16(client, LM90_REG_R_LOCAL_TEMP,\r\ndata->reg_local_ext);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp11[LOCAL_TEMP] = val;\r\n} else {\r\nval = lm90_read_reg(client, LM90_REG_R_LOCAL_TEMP);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp11[LOCAL_TEMP] = val << 8;\r\n}\r\nval = lm90_read16(client, LM90_REG_R_REMOTE_TEMPH,\r\nLM90_REG_R_REMOTE_TEMPL);\r\nif (val < 0)\r\nreturn val;\r\ndata->temp11[REMOTE_TEMP] = val;\r\nval = lm90_read_reg(client, LM90_REG_R_STATUS);\r\nif (val < 0)\r\nreturn val;\r\ndata->alarms = val;\r\nif (data->kind == max6696) {\r\nval = lm90_select_remote_channel(client, data, 1);\r\nif (val < 0)\r\nreturn val;\r\nval = lm90_read16(client, LM90_REG_R_REMOTE_TEMPH,\r\nLM90_REG_R_REMOTE_TEMPL);\r\nif (val < 0) {\r\nlm90_select_remote_channel(client, data, 0);\r\nreturn val;\r\n}\r\ndata->temp11[REMOTE2_TEMP] = val;\r\nlm90_select_remote_channel(client, data, 0);\r\nval = lm90_read_reg(client, MAX6696_REG_R_STATUS2);\r\nif (val < 0)\r\nreturn val;\r\ndata->alarms |= val << 8;\r\n}\r\nif (!(data->config_orig & 0x80) &&\r\n!(data->alarms & data->alert_alarms)) {\r\nval = lm90_read_reg(client, LM90_REG_R_CONFIG1);\r\nif (val < 0)\r\nreturn val;\r\nif (val & 0x80) {\r\ndev_dbg(&client->dev, "Re-enabling ALERT#\n");\r\ni2c_smbus_write_byte_data(client,\r\nLM90_REG_W_CONFIG1,\r\nval & ~0x80);\r\n}\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int temp_from_s8(s8 val)\r\n{\r\nreturn val * 1000;\r\n}\r\nstatic inline int temp_from_u8(u8 val)\r\n{\r\nreturn val * 1000;\r\n}\r\nstatic inline int temp_from_s16(s16 val)\r\n{\r\nreturn val / 32 * 125;\r\n}\r\nstatic inline int temp_from_u16(u16 val)\r\n{\r\nreturn val / 32 * 125;\r\n}\r\nstatic s8 temp_to_s8(long val)\r\n{\r\nif (val <= -128000)\r\nreturn -128;\r\nif (val >= 127000)\r\nreturn 127;\r\nif (val < 0)\r\nreturn (val - 500) / 1000;\r\nreturn (val + 500) / 1000;\r\n}\r\nstatic u8 temp_to_u8(long val)\r\n{\r\nif (val <= 0)\r\nreturn 0;\r\nif (val >= 255000)\r\nreturn 255;\r\nreturn (val + 500) / 1000;\r\n}\r\nstatic s16 temp_to_s16(long val)\r\n{\r\nif (val <= -128000)\r\nreturn 0x8000;\r\nif (val >= 127875)\r\nreturn 0x7FE0;\r\nif (val < 0)\r\nreturn (val - 62) / 125 * 32;\r\nreturn (val + 62) / 125 * 32;\r\n}\r\nstatic u8 hyst_to_reg(long val)\r\n{\r\nif (val <= 0)\r\nreturn 0;\r\nif (val >= 30500)\r\nreturn 31;\r\nreturn (val + 500) / 1000;\r\n}\r\nstatic inline int temp_from_u8_adt7461(struct lm90_data *data, u8 val)\r\n{\r\nif (data->flags & LM90_FLAG_ADT7461_EXT)\r\nreturn (val - 64) * 1000;\r\nreturn temp_from_s8(val);\r\n}\r\nstatic inline int temp_from_u16_adt7461(struct lm90_data *data, u16 val)\r\n{\r\nif (data->flags & LM90_FLAG_ADT7461_EXT)\r\nreturn (val - 0x4000) / 64 * 250;\r\nreturn temp_from_s16(val);\r\n}\r\nstatic u8 temp_to_u8_adt7461(struct lm90_data *data, long val)\r\n{\r\nif (data->flags & LM90_FLAG_ADT7461_EXT) {\r\nif (val <= -64000)\r\nreturn 0;\r\nif (val >= 191000)\r\nreturn 0xFF;\r\nreturn (val + 500 + 64000) / 1000;\r\n}\r\nif (val <= 0)\r\nreturn 0;\r\nif (val >= 127000)\r\nreturn 127;\r\nreturn (val + 500) / 1000;\r\n}\r\nstatic u16 temp_to_u16_adt7461(struct lm90_data *data, long val)\r\n{\r\nif (data->flags & LM90_FLAG_ADT7461_EXT) {\r\nif (val <= -64000)\r\nreturn 0;\r\nif (val >= 191750)\r\nreturn 0xFFC0;\r\nreturn (val + 64000 + 125) / 250 * 64;\r\n}\r\nif (val <= 0)\r\nreturn 0;\r\nif (val >= 127750)\r\nreturn 0x7FC0;\r\nreturn (val + 125) / 250 * 64;\r\n}\r\nstatic ssize_t pec_show(struct device *dev, struct device_attribute *dummy,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nreturn sprintf(buf, "%d\n", !!(client->flags & I2C_CLIENT_PEC));\r\n}\r\nstatic ssize_t pec_store(struct device *dev, struct device_attribute *dummy,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nswitch (val) {\r\ncase 0:\r\nclient->flags &= ~I2C_CLIENT_PEC;\r\nbreak;\r\ncase 1:\r\nclient->flags |= I2C_CLIENT_PEC;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic int lm90_get_temp11(struct lm90_data *data, int index)\r\n{\r\ns16 temp11 = data->temp11[index];\r\nint temp;\r\nif (data->kind == adt7461 || data->kind == tmp451)\r\ntemp = temp_from_u16_adt7461(data, temp11);\r\nelse if (data->kind == max6646)\r\ntemp = temp_from_u16(temp11);\r\nelse\r\ntemp = temp_from_s16(temp11);\r\nif (data->kind == lm99 && index <= 2)\r\ntemp += 16000;\r\nreturn temp;\r\n}\r\nstatic int lm90_set_temp11(struct lm90_data *data, int index, long val)\r\n{\r\nstatic struct reg {\r\nu8 high;\r\nu8 low;\r\n} reg[] = {\r\n[REMOTE_LOW] = { LM90_REG_W_REMOTE_LOWH, LM90_REG_W_REMOTE_LOWL },\r\n[REMOTE_HIGH] = { LM90_REG_W_REMOTE_HIGHH, LM90_REG_W_REMOTE_HIGHL },\r\n[REMOTE_OFFSET] = { LM90_REG_W_REMOTE_OFFSH, LM90_REG_W_REMOTE_OFFSL },\r\n[REMOTE2_LOW] = { LM90_REG_W_REMOTE_LOWH, LM90_REG_W_REMOTE_LOWL },\r\n[REMOTE2_HIGH] = { LM90_REG_W_REMOTE_HIGHH, LM90_REG_W_REMOTE_HIGHL }\r\n};\r\nstruct i2c_client *client = data->client;\r\nstruct reg *regp = &reg[index];\r\nint err;\r\nif (data->kind == lm99 && index <= 2)\r\nval -= 16000;\r\nif (data->kind == adt7461 || data->kind == tmp451)\r\ndata->temp11[index] = temp_to_u16_adt7461(data, val);\r\nelse if (data->kind == max6646)\r\ndata->temp11[index] = temp_to_u8(val) << 8;\r\nelse if (data->flags & LM90_HAVE_REM_LIMIT_EXT)\r\ndata->temp11[index] = temp_to_s16(val);\r\nelse\r\ndata->temp11[index] = temp_to_s8(val) << 8;\r\nlm90_select_remote_channel(client, data, index >= 3);\r\nerr = i2c_smbus_write_byte_data(client, regp->high,\r\ndata->temp11[index] >> 8);\r\nif (err < 0)\r\nreturn err;\r\nif (data->flags & LM90_HAVE_REM_LIMIT_EXT)\r\nerr = i2c_smbus_write_byte_data(client, regp->low,\r\ndata->temp11[index] & 0xff);\r\nlm90_select_remote_channel(client, data, 0);\r\nreturn err;\r\n}\r\nstatic int lm90_get_temp8(struct lm90_data *data, int index)\r\n{\r\ns8 temp8 = data->temp8[index];\r\nint temp;\r\nif (data->kind == adt7461 || data->kind == tmp451)\r\ntemp = temp_from_u8_adt7461(data, temp8);\r\nelse if (data->kind == max6646)\r\ntemp = temp_from_u8(temp8);\r\nelse\r\ntemp = temp_from_s8(temp8);\r\nif (data->kind == lm99 && index == 3)\r\ntemp += 16000;\r\nreturn temp;\r\n}\r\nstatic int lm90_set_temp8(struct lm90_data *data, int index, long val)\r\n{\r\nstatic const u8 reg[TEMP8_REG_NUM] = {\r\nLM90_REG_W_LOCAL_LOW,\r\nLM90_REG_W_LOCAL_HIGH,\r\nLM90_REG_W_LOCAL_CRIT,\r\nLM90_REG_W_REMOTE_CRIT,\r\nMAX6659_REG_W_LOCAL_EMERG,\r\nMAX6659_REG_W_REMOTE_EMERG,\r\nLM90_REG_W_REMOTE_CRIT,\r\nMAX6659_REG_W_REMOTE_EMERG,\r\n};\r\nstruct i2c_client *client = data->client;\r\nint err;\r\nif (data->kind == lm99 && index == 3)\r\nval -= 16000;\r\nif (data->kind == adt7461 || data->kind == tmp451)\r\ndata->temp8[index] = temp_to_u8_adt7461(data, val);\r\nelse if (data->kind == max6646)\r\ndata->temp8[index] = temp_to_u8(val);\r\nelse\r\ndata->temp8[index] = temp_to_s8(val);\r\nlm90_select_remote_channel(client, data, index >= 6);\r\nerr = i2c_smbus_write_byte_data(client, reg[index], data->temp8[index]);\r\nlm90_select_remote_channel(client, data, 0);\r\nreturn err;\r\n}\r\nstatic int lm90_get_temphyst(struct lm90_data *data, int index)\r\n{\r\nint temp;\r\nif (data->kind == adt7461 || data->kind == tmp451)\r\ntemp = temp_from_u8_adt7461(data, data->temp8[index]);\r\nelse if (data->kind == max6646)\r\ntemp = temp_from_u8(data->temp8[index]);\r\nelse\r\ntemp = temp_from_s8(data->temp8[index]);\r\nif (data->kind == lm99 && index == 3)\r\ntemp += 16000;\r\nreturn temp - temp_from_s8(data->temp_hyst);\r\n}\r\nstatic int lm90_set_temphyst(struct lm90_data *data, long val)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint temp;\r\nint err;\r\nif (data->kind == adt7461 || data->kind == tmp451)\r\ntemp = temp_from_u8_adt7461(data, data->temp8[LOCAL_CRIT]);\r\nelse if (data->kind == max6646)\r\ntemp = temp_from_u8(data->temp8[LOCAL_CRIT]);\r\nelse\r\ntemp = temp_from_s8(data->temp8[LOCAL_CRIT]);\r\ndata->temp_hyst = hyst_to_reg(temp - val);\r\nerr = i2c_smbus_write_byte_data(client, LM90_REG_W_TCRIT_HYST,\r\ndata->temp_hyst);\r\nreturn err;\r\n}\r\nstatic int lm90_temp_read(struct device *dev, u32 attr, int channel, long *val)\r\n{\r\nstruct lm90_data *data = dev_get_drvdata(dev);\r\nint err;\r\nmutex_lock(&data->update_lock);\r\nerr = lm90_update_device(dev);\r\nmutex_unlock(&data->update_lock);\r\nif (err)\r\nreturn err;\r\nswitch (attr) {\r\ncase hwmon_temp_input:\r\n*val = lm90_get_temp11(data, lm90_temp_index[channel]);\r\nbreak;\r\ncase hwmon_temp_min_alarm:\r\n*val = (data->alarms >> lm90_min_alarm_bits[channel]) & 1;\r\nbreak;\r\ncase hwmon_temp_max_alarm:\r\n*val = (data->alarms >> lm90_max_alarm_bits[channel]) & 1;\r\nbreak;\r\ncase hwmon_temp_crit_alarm:\r\n*val = (data->alarms >> lm90_crit_alarm_bits[channel]) & 1;\r\nbreak;\r\ncase hwmon_temp_emergency_alarm:\r\n*val = (data->alarms >> lm90_emergency_alarm_bits[channel]) & 1;\r\nbreak;\r\ncase hwmon_temp_fault:\r\n*val = (data->alarms >> lm90_fault_bits[channel]) & 1;\r\nbreak;\r\ncase hwmon_temp_min:\r\nif (channel == 0)\r\n*val = lm90_get_temp8(data,\r\nlm90_temp_min_index[channel]);\r\nelse\r\n*val = lm90_get_temp11(data,\r\nlm90_temp_min_index[channel]);\r\nbreak;\r\ncase hwmon_temp_max:\r\nif (channel == 0)\r\n*val = lm90_get_temp8(data,\r\nlm90_temp_max_index[channel]);\r\nelse\r\n*val = lm90_get_temp11(data,\r\nlm90_temp_max_index[channel]);\r\nbreak;\r\ncase hwmon_temp_crit:\r\n*val = lm90_get_temp8(data, lm90_temp_crit_index[channel]);\r\nbreak;\r\ncase hwmon_temp_crit_hyst:\r\n*val = lm90_get_temphyst(data, lm90_temp_crit_index[channel]);\r\nbreak;\r\ncase hwmon_temp_emergency:\r\n*val = lm90_get_temp8(data, lm90_temp_emerg_index[channel]);\r\nbreak;\r\ncase hwmon_temp_emergency_hyst:\r\n*val = lm90_get_temphyst(data, lm90_temp_emerg_index[channel]);\r\nbreak;\r\ncase hwmon_temp_offset:\r\n*val = lm90_get_temp11(data, REMOTE_OFFSET);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lm90_temp_write(struct device *dev, u32 attr, int channel, long val)\r\n{\r\nstruct lm90_data *data = dev_get_drvdata(dev);\r\nint err;\r\nmutex_lock(&data->update_lock);\r\nerr = lm90_update_device(dev);\r\nif (err)\r\ngoto error;\r\nswitch (attr) {\r\ncase hwmon_temp_min:\r\nif (channel == 0)\r\nerr = lm90_set_temp8(data,\r\nlm90_temp_min_index[channel],\r\nval);\r\nelse\r\nerr = lm90_set_temp11(data,\r\nlm90_temp_min_index[channel],\r\nval);\r\nbreak;\r\ncase hwmon_temp_max:\r\nif (channel == 0)\r\nerr = lm90_set_temp8(data,\r\nlm90_temp_max_index[channel],\r\nval);\r\nelse\r\nerr = lm90_set_temp11(data,\r\nlm90_temp_max_index[channel],\r\nval);\r\nbreak;\r\ncase hwmon_temp_crit:\r\nerr = lm90_set_temp8(data, lm90_temp_crit_index[channel], val);\r\nbreak;\r\ncase hwmon_temp_crit_hyst:\r\nerr = lm90_set_temphyst(data, val);\r\nbreak;\r\ncase hwmon_temp_emergency:\r\nerr = lm90_set_temp8(data, lm90_temp_emerg_index[channel], val);\r\nbreak;\r\ncase hwmon_temp_offset:\r\nerr = lm90_set_temp11(data, REMOTE_OFFSET, val);\r\nbreak;\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nerror:\r\nmutex_unlock(&data->update_lock);\r\nreturn err;\r\n}\r\nstatic umode_t lm90_temp_is_visible(const void *data, u32 attr, int channel)\r\n{\r\nswitch (attr) {\r\ncase hwmon_temp_input:\r\ncase hwmon_temp_min_alarm:\r\ncase hwmon_temp_max_alarm:\r\ncase hwmon_temp_crit_alarm:\r\ncase hwmon_temp_emergency_alarm:\r\ncase hwmon_temp_emergency_hyst:\r\ncase hwmon_temp_fault:\r\nreturn S_IRUGO;\r\ncase hwmon_temp_min:\r\ncase hwmon_temp_max:\r\ncase hwmon_temp_crit:\r\ncase hwmon_temp_emergency:\r\ncase hwmon_temp_offset:\r\nreturn S_IRUGO | S_IWUSR;\r\ncase hwmon_temp_crit_hyst:\r\nif (channel == 0)\r\nreturn S_IRUGO | S_IWUSR;\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int lm90_chip_read(struct device *dev, u32 attr, int channel, long *val)\r\n{\r\nstruct lm90_data *data = dev_get_drvdata(dev);\r\nint err;\r\nmutex_lock(&data->update_lock);\r\nerr = lm90_update_device(dev);\r\nmutex_unlock(&data->update_lock);\r\nif (err)\r\nreturn err;\r\nswitch (attr) {\r\ncase hwmon_chip_update_interval:\r\n*val = data->update_interval;\r\nbreak;\r\ncase hwmon_chip_alarms:\r\n*val = data->alarms;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lm90_chip_write(struct device *dev, u32 attr, int channel, long val)\r\n{\r\nstruct lm90_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint err;\r\nmutex_lock(&data->update_lock);\r\nerr = lm90_update_device(dev);\r\nif (err)\r\ngoto error;\r\nswitch (attr) {\r\ncase hwmon_chip_update_interval:\r\nerr = lm90_set_convrate(client, data,\r\nclamp_val(val, 0, 100000));\r\nbreak;\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nerror:\r\nmutex_unlock(&data->update_lock);\r\nreturn err;\r\n}\r\nstatic umode_t lm90_chip_is_visible(const void *data, u32 attr, int channel)\r\n{\r\nswitch (attr) {\r\ncase hwmon_chip_update_interval:\r\nreturn S_IRUGO | S_IWUSR;\r\ncase hwmon_chip_alarms:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int lm90_read(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long *val)\r\n{\r\nswitch (type) {\r\ncase hwmon_chip:\r\nreturn lm90_chip_read(dev, attr, channel, val);\r\ncase hwmon_temp:\r\nreturn lm90_temp_read(dev, attr, channel, val);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int lm90_write(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long val)\r\n{\r\nswitch (type) {\r\ncase hwmon_chip:\r\nreturn lm90_chip_write(dev, attr, channel, val);\r\ncase hwmon_temp:\r\nreturn lm90_temp_write(dev, attr, channel, val);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic umode_t lm90_is_visible(const void *data, enum hwmon_sensor_types type,\r\nu32 attr, int channel)\r\n{\r\nswitch (type) {\r\ncase hwmon_chip:\r\nreturn lm90_chip_is_visible(data, attr, channel);\r\ncase hwmon_temp:\r\nreturn lm90_temp_is_visible(data, attr, channel);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int lm90_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint address = client->addr;\r\nconst char *name = NULL;\r\nint man_id, chip_id, config1, config2, convrate;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nman_id = i2c_smbus_read_byte_data(client, LM90_REG_R_MAN_ID);\r\nchip_id = i2c_smbus_read_byte_data(client, LM90_REG_R_CHIP_ID);\r\nconfig1 = i2c_smbus_read_byte_data(client, LM90_REG_R_CONFIG1);\r\nconvrate = i2c_smbus_read_byte_data(client, LM90_REG_R_CONVRATE);\r\nif (man_id < 0 || chip_id < 0 || config1 < 0 || convrate < 0)\r\nreturn -ENODEV;\r\nif (man_id == 0x01 || man_id == 0x5C || man_id == 0x41) {\r\nconfig2 = i2c_smbus_read_byte_data(client, LM90_REG_R_CONFIG2);\r\nif (config2 < 0)\r\nreturn -ENODEV;\r\n} else\r\nconfig2 = 0;\r\nif ((address == 0x4C || address == 0x4D)\r\n&& man_id == 0x01) {\r\nif ((config1 & 0x2A) == 0x00\r\n&& (config2 & 0xF8) == 0x00\r\n&& convrate <= 0x09) {\r\nif (address == 0x4C\r\n&& (chip_id & 0xF0) == 0x20) {\r\nname = "lm90";\r\n} else\r\nif ((chip_id & 0xF0) == 0x30) {\r\nname = "lm99";\r\ndev_info(&adapter->dev,\r\n"Assuming LM99 chip at 0x%02x\n",\r\naddress);\r\ndev_info(&adapter->dev,\r\n"If it is an LM89, instantiate it "\r\n"with the new_device sysfs "\r\n"interface\n");\r\n} else\r\nif (address == 0x4C\r\n&& (chip_id & 0xF0) == 0x10) {\r\nname = "lm86";\r\n}\r\n}\r\n} else\r\nif ((address == 0x4C || address == 0x4D)\r\n&& man_id == 0x41) {\r\nif ((chip_id & 0xF0) == 0x40\r\n&& (config1 & 0x3F) == 0x00\r\n&& convrate <= 0x0A) {\r\nname = "adm1032";\r\nif (i2c_check_functionality(adapter,\r\nI2C_FUNC_SMBUS_BYTE))\r\ninfo->flags |= I2C_CLIENT_PEC;\r\n} else\r\nif (chip_id == 0x51\r\n&& (config1 & 0x1B) == 0x00\r\n&& convrate <= 0x0A) {\r\nname = "adt7461";\r\n} else\r\nif (chip_id == 0x57\r\n&& (config1 & 0x1B) == 0x00\r\n&& convrate <= 0x0A) {\r\nname = "adt7461a";\r\n}\r\n} else\r\nif (man_id == 0x4D) {\r\nint emerg, emerg2, status2;\r\nemerg = i2c_smbus_read_byte_data(client,\r\nMAX6659_REG_R_REMOTE_EMERG);\r\nman_id = i2c_smbus_read_byte_data(client,\r\nLM90_REG_R_MAN_ID);\r\nemerg2 = i2c_smbus_read_byte_data(client,\r\nMAX6659_REG_R_REMOTE_EMERG);\r\nstatus2 = i2c_smbus_read_byte_data(client,\r\nMAX6696_REG_R_STATUS2);\r\nif (emerg < 0 || man_id < 0 || emerg2 < 0 || status2 < 0)\r\nreturn -ENODEV;\r\nif (chip_id == man_id\r\n&& (address == 0x4C || address == 0x4D || address == 0x4E)\r\n&& (config1 & 0x1F) == (man_id & 0x0F)\r\n&& convrate <= 0x09) {\r\nif (address == 0x4C)\r\nname = "max6657";\r\nelse\r\nname = "max6659";\r\n} else\r\nif (chip_id == 0x01\r\n&& (config1 & 0x10) == 0x00\r\n&& (status2 & 0x01) == 0x00\r\n&& emerg == emerg2\r\n&& convrate <= 0x07) {\r\nname = "max6696";\r\n} else\r\nif (chip_id == 0x01\r\n&& (config1 & 0x03) == 0x00\r\n&& convrate <= 0x07) {\r\nname = "max6680";\r\n} else\r\nif (chip_id == 0x59\r\n&& (config1 & 0x3f) == 0x00\r\n&& convrate <= 0x07) {\r\nname = "max6646";\r\n}\r\n} else\r\nif (address == 0x4C\r\n&& man_id == 0x5C) {\r\nif ((config1 & 0x2A) == 0x00\r\n&& (config2 & 0xF8) == 0x00) {\r\nif (chip_id == 0x01\r\n&& convrate <= 0x09) {\r\nname = "w83l771";\r\n} else\r\nif ((chip_id & 0xFE) == 0x10\r\n&& convrate <= 0x08) {\r\nname = "w83l771";\r\n}\r\n}\r\n} else\r\nif (address >= 0x48 && address <= 0x4F\r\n&& man_id == 0xA1) {\r\nif (chip_id == 0x00\r\n&& (config1 & 0x2A) == 0x00\r\n&& (config2 & 0xFE) == 0x00\r\n&& convrate <= 0x09) {\r\nname = "sa56004";\r\n}\r\n} else\r\nif ((address == 0x4C || address == 0x4D)\r\n&& man_id == 0x47) {\r\nif (chip_id == 0x01\r\n&& (config1 & 0x3F) == 0x00\r\n&& convrate <= 0x08)\r\nname = "g781";\r\n} else\r\nif (address == 0x4C\r\n&& man_id == 0x55) {\r\nint local_ext;\r\nlocal_ext = i2c_smbus_read_byte_data(client,\r\nTMP451_REG_R_LOCAL_TEMPL);\r\nif (chip_id == 0x00\r\n&& (config1 & 0x1B) == 0x00\r\n&& convrate <= 0x09\r\n&& (local_ext & 0x0F) == 0x00)\r\nname = "tmp451";\r\n}\r\nif (!name) {\r\ndev_dbg(&adapter->dev,\r\n"Unsupported chip at 0x%02x (man_id=0x%02X, "\r\n"chip_id=0x%02X)\n", address, man_id, chip_id);\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(info->type, name, I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic void lm90_restore_conf(void *_data)\r\n{\r\nstruct lm90_data *data = _data;\r\nstruct i2c_client *client = data->client;\r\ni2c_smbus_write_byte_data(client, LM90_REG_W_CONVRATE,\r\ndata->convrate_orig);\r\ni2c_smbus_write_byte_data(client, LM90_REG_W_CONFIG1,\r\ndata->config_orig);\r\n}\r\nstatic int lm90_init_client(struct i2c_client *client, struct lm90_data *data)\r\n{\r\nint config, convrate;\r\nconvrate = lm90_read_reg(client, LM90_REG_R_CONVRATE);\r\nif (convrate < 0)\r\nreturn convrate;\r\ndata->convrate_orig = convrate;\r\nlm90_set_convrate(client, data, 500);\r\nconfig = lm90_read_reg(client, LM90_REG_R_CONFIG1);\r\nif (config < 0)\r\nreturn config;\r\ndata->config_orig = config;\r\nif (data->kind == adt7461 || data->kind == tmp451) {\r\nif (config & 0x04)\r\ndata->flags |= LM90_FLAG_ADT7461_EXT;\r\n}\r\nif (data->kind == max6680)\r\nconfig |= 0x18;\r\nif (data->kind == max6696)\r\nconfig &= ~0x08;\r\nconfig &= 0xBF;\r\nif (config != data->config_orig)\r\ni2c_smbus_write_byte_data(client, LM90_REG_W_CONFIG1, config);\r\nreturn devm_add_action_or_reset(&client->dev, lm90_restore_conf, data);\r\n}\r\nstatic bool lm90_is_tripped(struct i2c_client *client, u16 *status)\r\n{\r\nstruct lm90_data *data = i2c_get_clientdata(client);\r\nint st, st2 = 0;\r\nst = lm90_read_reg(client, LM90_REG_R_STATUS);\r\nif (st < 0)\r\nreturn false;\r\nif (data->kind == max6696) {\r\nst2 = lm90_read_reg(client, MAX6696_REG_R_STATUS2);\r\nif (st2 < 0)\r\nreturn false;\r\n}\r\n*status = st | (st2 << 8);\r\nif ((st & 0x7f) == 0 && (st2 & 0xfe) == 0)\r\nreturn false;\r\nif ((st & (LM90_STATUS_LLOW | LM90_STATUS_LHIGH | LM90_STATUS_LTHRM)) ||\r\n(st2 & MAX6696_STATUS2_LOT2))\r\ndev_warn(&client->dev,\r\n"temp%d out of range, please check!\n", 1);\r\nif ((st & (LM90_STATUS_RLOW | LM90_STATUS_RHIGH | LM90_STATUS_RTHRM)) ||\r\n(st2 & MAX6696_STATUS2_ROT2))\r\ndev_warn(&client->dev,\r\n"temp%d out of range, please check!\n", 2);\r\nif (st & LM90_STATUS_ROPEN)\r\ndev_warn(&client->dev,\r\n"temp%d diode open, please check!\n", 2);\r\nif (st2 & (MAX6696_STATUS2_R2LOW | MAX6696_STATUS2_R2HIGH |\r\nMAX6696_STATUS2_R2THRM | MAX6696_STATUS2_R2OT2))\r\ndev_warn(&client->dev,\r\n"temp%d out of range, please check!\n", 3);\r\nif (st2 & MAX6696_STATUS2_R2OPEN)\r\ndev_warn(&client->dev,\r\n"temp%d diode open, please check!\n", 3);\r\nreturn true;\r\n}\r\nstatic irqreturn_t lm90_irq_thread(int irq, void *dev_id)\r\n{\r\nstruct i2c_client *client = dev_id;\r\nu16 status;\r\nif (lm90_is_tripped(client, &status))\r\nreturn IRQ_HANDLED;\r\nelse\r\nreturn IRQ_NONE;\r\n}\r\nstatic void lm90_remove_pec(void *dev)\r\n{\r\ndevice_remove_file(dev, &dev_attr_pec);\r\n}\r\nstatic void lm90_regulator_disable(void *regulator)\r\n{\r\nregulator_disable(regulator);\r\n}\r\nstatic int lm90_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct i2c_adapter *adapter = to_i2c_adapter(dev->parent);\r\nstruct hwmon_channel_info *info;\r\nstruct regulator *regulator;\r\nstruct device *hwmon_dev;\r\nstruct lm90_data *data;\r\nint err;\r\nregulator = devm_regulator_get(dev, "vcc");\r\nif (IS_ERR(regulator))\r\nreturn PTR_ERR(regulator);\r\nerr = regulator_enable(regulator);\r\nif (err < 0) {\r\ndev_err(dev, "Failed to enable regulator: %d\n", err);\r\nreturn err;\r\n}\r\nerr = devm_add_action_or_reset(dev, lm90_regulator_disable, regulator);\r\nif (err)\r\nreturn err;\r\ndata = devm_kzalloc(dev, sizeof(struct lm90_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->client = client;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\nif (client->dev.of_node)\r\ndata->kind = (enum chips)of_device_get_match_data(&client->dev);\r\nelse\r\ndata->kind = id->driver_data;\r\nif (data->kind == adm1032) {\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))\r\nclient->flags &= ~I2C_CLIENT_PEC;\r\n}\r\ndata->alert_alarms = lm90_params[data->kind].alert_alarms;\r\ndata->flags = lm90_params[data->kind].flags;\r\ndata->chip.ops = &lm90_ops;\r\ndata->chip.info = data->info;\r\ndata->info[0] = &lm90_chip_info;\r\ndata->info[1] = &data->temp_info;\r\ninfo = &data->temp_info;\r\ninfo->type = hwmon_temp;\r\ninfo->config = data->channel_config;\r\ndata->channel_config[0] = HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX |\r\nHWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_MIN_ALARM |\r\nHWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM;\r\ndata->channel_config[1] = HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX |\r\nHWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_MIN_ALARM |\r\nHWMON_T_MAX_ALARM | HWMON_T_CRIT_ALARM | HWMON_T_FAULT;\r\nif (data->flags & LM90_HAVE_OFFSET)\r\ndata->channel_config[1] |= HWMON_T_OFFSET;\r\nif (data->flags & LM90_HAVE_EMERGENCY) {\r\ndata->channel_config[0] |= HWMON_T_EMERGENCY |\r\nHWMON_T_EMERGENCY_HYST;\r\ndata->channel_config[1] |= HWMON_T_EMERGENCY |\r\nHWMON_T_EMERGENCY_HYST;\r\n}\r\nif (data->flags & LM90_HAVE_EMERGENCY_ALARM) {\r\ndata->channel_config[0] |= HWMON_T_EMERGENCY_ALARM;\r\ndata->channel_config[1] |= HWMON_T_EMERGENCY_ALARM;\r\n}\r\nif (data->flags & LM90_HAVE_TEMP3) {\r\ndata->channel_config[2] = HWMON_T_INPUT |\r\nHWMON_T_MIN | HWMON_T_MAX |\r\nHWMON_T_CRIT | HWMON_T_CRIT_HYST |\r\nHWMON_T_EMERGENCY | HWMON_T_EMERGENCY_HYST |\r\nHWMON_T_MIN_ALARM | HWMON_T_MAX_ALARM |\r\nHWMON_T_CRIT_ALARM | HWMON_T_EMERGENCY_ALARM |\r\nHWMON_T_FAULT;\r\n}\r\ndata->reg_local_ext = lm90_params[data->kind].reg_local_ext;\r\ndata->max_convrate = lm90_params[data->kind].max_convrate;\r\nerr = lm90_init_client(client, data);\r\nif (err < 0) {\r\ndev_err(dev, "Failed to initialize device\n");\r\nreturn err;\r\n}\r\nif (client->flags & I2C_CLIENT_PEC) {\r\nerr = device_create_file(dev, &dev_attr_pec);\r\nif (err)\r\nreturn err;\r\nerr = devm_add_action_or_reset(dev, lm90_remove_pec, dev);\r\nif (err)\r\nreturn err;\r\n}\r\nhwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\r\ndata, &data->chip,\r\nNULL);\r\nif (IS_ERR(hwmon_dev))\r\nreturn PTR_ERR(hwmon_dev);\r\nif (client->irq) {\r\ndev_dbg(dev, "IRQ: %d\n", client->irq);\r\nerr = devm_request_threaded_irq(dev, client->irq,\r\nNULL, lm90_irq_thread,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"lm90", client);\r\nif (err < 0) {\r\ndev_err(dev, "cannot request IRQ %d\n", client->irq);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void lm90_alert(struct i2c_client *client, enum i2c_alert_protocol type,\r\nunsigned int flag)\r\n{\r\nu16 alarms;\r\nif (type != I2C_PROTOCOL_SMBUS_ALERT)\r\nreturn;\r\nif (lm90_is_tripped(client, &alarms)) {\r\nstruct lm90_data *data = i2c_get_clientdata(client);\r\nif ((data->flags & LM90_HAVE_BROKEN_ALERT) &&\r\n(alarms & data->alert_alarms)) {\r\nint config;\r\ndev_dbg(&client->dev, "Disabling ALERT#\n");\r\nconfig = lm90_read_reg(client, LM90_REG_R_CONFIG1);\r\nif (config >= 0)\r\ni2c_smbus_write_byte_data(client,\r\nLM90_REG_W_CONFIG1,\r\nconfig | 0x80);\r\n}\r\n} else {\r\ndev_info(&client->dev, "Everything OK\n");\r\n}\r\n}
