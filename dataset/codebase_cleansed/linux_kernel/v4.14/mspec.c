static inline int\r\nmspec_zero_block(unsigned long addr, int len)\r\n{\r\nint status;\r\nif (is_sn2) {\r\nif (is_shub2()) {\r\nint nid;\r\nvoid *p;\r\nint i;\r\nnid = nasid_to_cnodeid(get_node_number(__pa(addr)));\r\np = (void *)TO_AMO(scratch_page[nid]);\r\nfor (i=0; i < SH2_AMO_CACHE_ENTRIES; i++) {\r\nFETCHOP_LOAD_OP(p, FETCHOP_LOAD);\r\np += FETCHOP_VAR_SIZE;\r\n}\r\n}\r\nstatus = bte_copy(0, addr & ~__IA64_UNCACHED_OFFSET, len,\r\nBTE_WACQUIRE | BTE_ZERO_FILL, NULL);\r\n} else {\r\nmemset((char *) addr, 0, len);\r\nstatus = 0;\r\n}\r\nreturn status;\r\n}\r\nstatic void\r\nmspec_open(struct vm_area_struct *vma)\r\n{\r\nstruct vma_data *vdata;\r\nvdata = vma->vm_private_data;\r\nrefcount_inc(&vdata->refcnt);\r\n}\r\nstatic void\r\nmspec_close(struct vm_area_struct *vma)\r\n{\r\nstruct vma_data *vdata;\r\nint index, last_index;\r\nunsigned long my_page;\r\nvdata = vma->vm_private_data;\r\nif (!refcount_dec_and_test(&vdata->refcnt))\r\nreturn;\r\nlast_index = (vdata->vm_end - vdata->vm_start) >> PAGE_SHIFT;\r\nfor (index = 0; index < last_index; index++) {\r\nif (vdata->maddr[index] == 0)\r\ncontinue;\r\nmy_page = vdata->maddr[index];\r\nvdata->maddr[index] = 0;\r\nif (!mspec_zero_block(my_page, PAGE_SIZE))\r\nuncached_free_page(my_page, 1);\r\nelse\r\nprintk(KERN_WARNING "mspec_close(): "\r\n"failed to zero page %ld\n", my_page);\r\n}\r\nkvfree(vdata);\r\n}\r\nstatic int\r\nmspec_fault(struct vm_fault *vmf)\r\n{\r\nunsigned long paddr, maddr;\r\nunsigned long pfn;\r\npgoff_t index = vmf->pgoff;\r\nstruct vma_data *vdata = vmf->vma->vm_private_data;\r\nmaddr = (volatile unsigned long) vdata->maddr[index];\r\nif (maddr == 0) {\r\nmaddr = uncached_alloc_page(numa_node_id(), 1);\r\nif (maddr == 0)\r\nreturn VM_FAULT_OOM;\r\nspin_lock(&vdata->lock);\r\nif (vdata->maddr[index] == 0) {\r\nvdata->count++;\r\nvdata->maddr[index] = maddr;\r\n} else {\r\nuncached_free_page(maddr, 1);\r\nmaddr = vdata->maddr[index];\r\n}\r\nspin_unlock(&vdata->lock);\r\n}\r\nif (vdata->type == MSPEC_FETCHOP)\r\npaddr = TO_AMO(maddr);\r\nelse\r\npaddr = maddr & ~__IA64_UNCACHED_OFFSET;\r\npfn = paddr >> PAGE_SHIFT;\r\nvm_insert_pfn(vmf->vma, vmf->address, pfn);\r\nreturn VM_FAULT_NOPAGE;\r\n}\r\nstatic int\r\nmspec_mmap(struct file *file, struct vm_area_struct *vma,\r\nenum mspec_page_type type)\r\n{\r\nstruct vma_data *vdata;\r\nint pages, vdata_size;\r\nif (vma->vm_pgoff != 0)\r\nreturn -EINVAL;\r\nif ((vma->vm_flags & VM_SHARED) == 0)\r\nreturn -EINVAL;\r\nif ((vma->vm_flags & VM_WRITE) == 0)\r\nreturn -EPERM;\r\npages = vma_pages(vma);\r\nvdata_size = sizeof(struct vma_data) + pages * sizeof(long);\r\nif (vdata_size <= PAGE_SIZE)\r\nvdata = kzalloc(vdata_size, GFP_KERNEL);\r\nelse\r\nvdata = vzalloc(vdata_size);\r\nif (!vdata)\r\nreturn -ENOMEM;\r\nvdata->vm_start = vma->vm_start;\r\nvdata->vm_end = vma->vm_end;\r\nvdata->type = type;\r\nspin_lock_init(&vdata->lock);\r\nrefcount_set(&vdata->refcnt, 1);\r\nvma->vm_private_data = vdata;\r\nvma->vm_flags |= VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP;\r\nif (vdata->type == MSPEC_FETCHOP || vdata->type == MSPEC_UNCACHED)\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nvma->vm_ops = &mspec_vm_ops;\r\nreturn 0;\r\n}\r\nstatic int\r\nfetchop_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nreturn mspec_mmap(file, vma, MSPEC_FETCHOP);\r\n}\r\nstatic int\r\ncached_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nreturn mspec_mmap(file, vma, MSPEC_CACHED);\r\n}\r\nstatic int\r\nuncached_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nreturn mspec_mmap(file, vma, MSPEC_UNCACHED);\r\n}\r\nstatic int __init\r\nmspec_init(void)\r\n{\r\nint ret;\r\nint nid;\r\n#ifdef CONFIG_SGI_SN\r\nif (ia64_platform_is("sn2")) {\r\nis_sn2 = 1;\r\nif (is_shub2()) {\r\nret = -ENOMEM;\r\nfor_each_node_state(nid, N_ONLINE) {\r\nint actual_nid;\r\nint nasid;\r\nunsigned long phys;\r\nscratch_page[nid] = uncached_alloc_page(nid, 1);\r\nif (scratch_page[nid] == 0)\r\ngoto free_scratch_pages;\r\nphys = __pa(scratch_page[nid]);\r\nnasid = get_node_number(phys);\r\nactual_nid = nasid_to_cnodeid(nasid);\r\nif (actual_nid != nid)\r\ngoto free_scratch_pages;\r\n}\r\n}\r\nret = misc_register(&fetchop_miscdev);\r\nif (ret) {\r\nprintk(KERN_ERR\r\n"%s: failed to register device %i\n",\r\nFETCHOP_ID, ret);\r\ngoto free_scratch_pages;\r\n}\r\n}\r\n#endif\r\nret = misc_register(&cached_miscdev);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: failed to register device %i\n",\r\nCACHED_ID, ret);\r\nif (is_sn2)\r\nmisc_deregister(&fetchop_miscdev);\r\ngoto free_scratch_pages;\r\n}\r\nret = misc_register(&uncached_miscdev);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: failed to register device %i\n",\r\nUNCACHED_ID, ret);\r\nmisc_deregister(&cached_miscdev);\r\nif (is_sn2)\r\nmisc_deregister(&fetchop_miscdev);\r\ngoto free_scratch_pages;\r\n}\r\nprintk(KERN_INFO "%s %s initialized devices: %s %s %s\n",\r\nMSPEC_BASENAME, REVISION, is_sn2 ? FETCHOP_ID : "",\r\nCACHED_ID, UNCACHED_ID);\r\nreturn 0;\r\nfree_scratch_pages:\r\nfor_each_node(nid) {\r\nif (scratch_page[nid] != 0)\r\nuncached_free_page(scratch_page[nid], 1);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit\r\nmspec_exit(void)\r\n{\r\nint nid;\r\nmisc_deregister(&uncached_miscdev);\r\nmisc_deregister(&cached_miscdev);\r\nif (is_sn2) {\r\nmisc_deregister(&fetchop_miscdev);\r\nfor_each_node(nid) {\r\nif (scratch_page[nid] != 0)\r\nuncached_free_page(scratch_page[nid], 1);\r\n}\r\n}\r\n}
