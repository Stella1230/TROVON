static int get_oc_core_priority(unsigned int cpu)\r\n{\r\nu64 value, cmd = OC_MAILBOX_FC_CONTROL_CMD;\r\nint ret, i;\r\nvalue = cmd << MSR_OC_MAILBOX_CMD_OFFSET;\r\nvalue |= BIT_ULL(MSR_OC_MAILBOX_BUSY_BIT);\r\nret = wrmsrl_safe(MSR_OC_MAILBOX, value);\r\nif (ret) {\r\npr_debug("cpu %d OC mailbox write failed\n", cpu);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < OC_MAILBOX_RETRY_COUNT; ++i) {\r\nret = rdmsrl_safe(MSR_OC_MAILBOX, &value);\r\nif (ret) {\r\npr_debug("cpu %d OC mailbox read failed\n", cpu);\r\nbreak;\r\n}\r\nif (value & BIT_ULL(MSR_OC_MAILBOX_BUSY_BIT)) {\r\npr_debug("cpu %d OC mailbox still processing\n", cpu);\r\nret = -EBUSY;\r\ncontinue;\r\n}\r\nif ((value >> MSR_OC_MAILBOX_RSP_OFFSET) & 0xff) {\r\npr_debug("cpu %d OC mailbox cmd failed\n", cpu);\r\nret = -ENXIO;\r\nbreak;\r\n}\r\nret = value & 0xff;\r\npr_debug("cpu %d max_ratio %d\n", cpu, ret);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void itmt_legacy_work_fn(struct work_struct *work)\r\n{\r\nsched_set_itmt_support();\r\n}\r\nstatic int itmt_legacy_cpu_online(unsigned int cpu)\r\n{\r\nstatic u32 max_highest_perf = 0, min_highest_perf = U32_MAX;\r\nint priority;\r\npriority = get_oc_core_priority(cpu);\r\nif (priority < 0)\r\nreturn 0;\r\nsched_set_itmt_core_prio(priority, cpu);\r\nif (max_highest_perf <= min_highest_perf) {\r\nif (priority > max_highest_perf)\r\nmax_highest_perf = priority;\r\nif (priority < min_highest_perf)\r\nmin_highest_perf = priority;\r\nif (max_highest_perf > min_highest_perf)\r\nschedule_work(&sched_itmt_work);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init itmt_legacy_init(void)\r\n{\r\nconst struct x86_cpu_id *id;\r\nint ret;\r\nid = x86_match_cpu(itmt_legacy_cpu_ids);\r\nif (!id)\r\nreturn -ENODEV;\r\nif (boot_cpu_has(X86_FEATURE_HWP))\r\nreturn -ENODEV;\r\nret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN,\r\n"platform/x86/turbo_max_3:online",\r\nitmt_legacy_cpu_online, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}
