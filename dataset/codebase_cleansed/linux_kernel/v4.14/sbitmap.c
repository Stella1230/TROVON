int sbitmap_init_node(struct sbitmap *sb, unsigned int depth, int shift,\r\ngfp_t flags, int node)\r\n{\r\nunsigned int bits_per_word;\r\nunsigned int i;\r\nif (shift < 0) {\r\nshift = ilog2(BITS_PER_LONG);\r\nif (depth >= 4) {\r\nwhile ((4U << shift) > depth)\r\nshift--;\r\n}\r\n}\r\nbits_per_word = 1U << shift;\r\nif (bits_per_word > BITS_PER_LONG)\r\nreturn -EINVAL;\r\nsb->shift = shift;\r\nsb->depth = depth;\r\nsb->map_nr = DIV_ROUND_UP(sb->depth, bits_per_word);\r\nif (depth == 0) {\r\nsb->map = NULL;\r\nreturn 0;\r\n}\r\nsb->map = kzalloc_node(sb->map_nr * sizeof(*sb->map), flags, node);\r\nif (!sb->map)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < sb->map_nr; i++) {\r\nsb->map[i].depth = min(depth, bits_per_word);\r\ndepth -= sb->map[i].depth;\r\n}\r\nreturn 0;\r\n}\r\nvoid sbitmap_resize(struct sbitmap *sb, unsigned int depth)\r\n{\r\nunsigned int bits_per_word = 1U << sb->shift;\r\nunsigned int i;\r\nsb->depth = depth;\r\nsb->map_nr = DIV_ROUND_UP(sb->depth, bits_per_word);\r\nfor (i = 0; i < sb->map_nr; i++) {\r\nsb->map[i].depth = min(depth, bits_per_word);\r\ndepth -= sb->map[i].depth;\r\n}\r\n}\r\nstatic int __sbitmap_get_word(unsigned long *word, unsigned long depth,\r\nunsigned int hint, bool wrap)\r\n{\r\nunsigned int orig_hint = hint;\r\nint nr;\r\nwhile (1) {\r\nnr = find_next_zero_bit(word, depth, hint);\r\nif (unlikely(nr >= depth)) {\r\nif (orig_hint && hint && wrap) {\r\nhint = orig_hint = 0;\r\ncontinue;\r\n}\r\nreturn -1;\r\n}\r\nif (!test_and_set_bit(nr, word))\r\nbreak;\r\nhint = nr + 1;\r\nif (hint >= depth - 1)\r\nhint = 0;\r\n}\r\nreturn nr;\r\n}\r\nint sbitmap_get(struct sbitmap *sb, unsigned int alloc_hint, bool round_robin)\r\n{\r\nunsigned int i, index;\r\nint nr = -1;\r\nindex = SB_NR_TO_INDEX(sb, alloc_hint);\r\nfor (i = 0; i < sb->map_nr; i++) {\r\nnr = __sbitmap_get_word(&sb->map[index].word,\r\nsb->map[index].depth,\r\nSB_NR_TO_BIT(sb, alloc_hint),\r\n!round_robin);\r\nif (nr != -1) {\r\nnr += index << sb->shift;\r\nbreak;\r\n}\r\nindex++;\r\nalloc_hint = index << sb->shift;\r\nif (index >= sb->map_nr) {\r\nindex = 0;\r\nalloc_hint = 0;\r\n}\r\n}\r\nreturn nr;\r\n}\r\nint sbitmap_get_shallow(struct sbitmap *sb, unsigned int alloc_hint,\r\nunsigned long shallow_depth)\r\n{\r\nunsigned int i, index;\r\nint nr = -1;\r\nindex = SB_NR_TO_INDEX(sb, alloc_hint);\r\nfor (i = 0; i < sb->map_nr; i++) {\r\nnr = __sbitmap_get_word(&sb->map[index].word,\r\nmin(sb->map[index].depth, shallow_depth),\r\nSB_NR_TO_BIT(sb, alloc_hint), true);\r\nif (nr != -1) {\r\nnr += index << sb->shift;\r\nbreak;\r\n}\r\nindex++;\r\nalloc_hint = index << sb->shift;\r\nif (index >= sb->map_nr) {\r\nindex = 0;\r\nalloc_hint = 0;\r\n}\r\n}\r\nreturn nr;\r\n}\r\nbool sbitmap_any_bit_set(const struct sbitmap *sb)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < sb->map_nr; i++) {\r\nif (sb->map[i].word)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nbool sbitmap_any_bit_clear(const struct sbitmap *sb)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < sb->map_nr; i++) {\r\nconst struct sbitmap_word *word = &sb->map[i];\r\nunsigned long ret;\r\nret = find_first_zero_bit(&word->word, word->depth);\r\nif (ret < word->depth)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nunsigned int sbitmap_weight(const struct sbitmap *sb)\r\n{\r\nunsigned int i, weight = 0;\r\nfor (i = 0; i < sb->map_nr; i++) {\r\nconst struct sbitmap_word *word = &sb->map[i];\r\nweight += bitmap_weight(&word->word, word->depth);\r\n}\r\nreturn weight;\r\n}\r\nvoid sbitmap_show(struct sbitmap *sb, struct seq_file *m)\r\n{\r\nseq_printf(m, "depth=%u\n", sb->depth);\r\nseq_printf(m, "busy=%u\n", sbitmap_weight(sb));\r\nseq_printf(m, "bits_per_word=%u\n", 1U << sb->shift);\r\nseq_printf(m, "map_nr=%u\n", sb->map_nr);\r\n}\r\nstatic inline void emit_byte(struct seq_file *m, unsigned int offset, u8 byte)\r\n{\r\nif ((offset & 0xf) == 0) {\r\nif (offset != 0)\r\nseq_putc(m, '\n');\r\nseq_printf(m, "%08x:", offset);\r\n}\r\nif ((offset & 0x1) == 0)\r\nseq_putc(m, ' ');\r\nseq_printf(m, "%02x", byte);\r\n}\r\nvoid sbitmap_bitmap_show(struct sbitmap *sb, struct seq_file *m)\r\n{\r\nu8 byte = 0;\r\nunsigned int byte_bits = 0;\r\nunsigned int offset = 0;\r\nint i;\r\nfor (i = 0; i < sb->map_nr; i++) {\r\nunsigned long word = READ_ONCE(sb->map[i].word);\r\nunsigned int word_bits = READ_ONCE(sb->map[i].depth);\r\nwhile (word_bits > 0) {\r\nunsigned int bits = min(8 - byte_bits, word_bits);\r\nbyte |= (word & (BIT(bits) - 1)) << byte_bits;\r\nbyte_bits += bits;\r\nif (byte_bits == 8) {\r\nemit_byte(m, offset, byte);\r\nbyte = 0;\r\nbyte_bits = 0;\r\noffset++;\r\n}\r\nword >>= bits;\r\nword_bits -= bits;\r\n}\r\n}\r\nif (byte_bits) {\r\nemit_byte(m, offset, byte);\r\noffset++;\r\n}\r\nif (offset)\r\nseq_putc(m, '\n');\r\n}\r\nstatic unsigned int sbq_calc_wake_batch(unsigned int depth)\r\n{\r\nunsigned int wake_batch;\r\nwake_batch = SBQ_WAKE_BATCH;\r\nif (wake_batch > depth / SBQ_WAIT_QUEUES)\r\nwake_batch = max(1U, depth / SBQ_WAIT_QUEUES);\r\nreturn wake_batch;\r\n}\r\nint sbitmap_queue_init_node(struct sbitmap_queue *sbq, unsigned int depth,\r\nint shift, bool round_robin, gfp_t flags, int node)\r\n{\r\nint ret;\r\nint i;\r\nret = sbitmap_init_node(&sbq->sb, depth, shift, flags, node);\r\nif (ret)\r\nreturn ret;\r\nsbq->alloc_hint = alloc_percpu_gfp(unsigned int, flags);\r\nif (!sbq->alloc_hint) {\r\nsbitmap_free(&sbq->sb);\r\nreturn -ENOMEM;\r\n}\r\nif (depth && !round_robin) {\r\nfor_each_possible_cpu(i)\r\n*per_cpu_ptr(sbq->alloc_hint, i) = prandom_u32() % depth;\r\n}\r\nsbq->wake_batch = sbq_calc_wake_batch(depth);\r\natomic_set(&sbq->wake_index, 0);\r\nsbq->ws = kzalloc_node(SBQ_WAIT_QUEUES * sizeof(*sbq->ws), flags, node);\r\nif (!sbq->ws) {\r\nfree_percpu(sbq->alloc_hint);\r\nsbitmap_free(&sbq->sb);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < SBQ_WAIT_QUEUES; i++) {\r\ninit_waitqueue_head(&sbq->ws[i].wait);\r\natomic_set(&sbq->ws[i].wait_cnt, sbq->wake_batch);\r\n}\r\nsbq->round_robin = round_robin;\r\nreturn 0;\r\n}\r\nvoid sbitmap_queue_resize(struct sbitmap_queue *sbq, unsigned int depth)\r\n{\r\nunsigned int wake_batch = sbq_calc_wake_batch(depth);\r\nint i;\r\nif (sbq->wake_batch != wake_batch) {\r\nWRITE_ONCE(sbq->wake_batch, wake_batch);\r\nsmp_mb__before_atomic();\r\nfor (i = 0; i < SBQ_WAIT_QUEUES; i++)\r\natomic_set(&sbq->ws[i].wait_cnt, 1);\r\n}\r\nsbitmap_resize(&sbq->sb, depth);\r\n}\r\nint __sbitmap_queue_get(struct sbitmap_queue *sbq)\r\n{\r\nunsigned int hint, depth;\r\nint nr;\r\nhint = this_cpu_read(*sbq->alloc_hint);\r\ndepth = READ_ONCE(sbq->sb.depth);\r\nif (unlikely(hint >= depth)) {\r\nhint = depth ? prandom_u32() % depth : 0;\r\nthis_cpu_write(*sbq->alloc_hint, hint);\r\n}\r\nnr = sbitmap_get(&sbq->sb, hint, sbq->round_robin);\r\nif (nr == -1) {\r\nthis_cpu_write(*sbq->alloc_hint, 0);\r\n} else if (nr == hint || unlikely(sbq->round_robin)) {\r\nhint = nr + 1;\r\nif (hint >= depth - 1)\r\nhint = 0;\r\nthis_cpu_write(*sbq->alloc_hint, hint);\r\n}\r\nreturn nr;\r\n}\r\nint __sbitmap_queue_get_shallow(struct sbitmap_queue *sbq,\r\nunsigned int shallow_depth)\r\n{\r\nunsigned int hint, depth;\r\nint nr;\r\nhint = this_cpu_read(*sbq->alloc_hint);\r\ndepth = READ_ONCE(sbq->sb.depth);\r\nif (unlikely(hint >= depth)) {\r\nhint = depth ? prandom_u32() % depth : 0;\r\nthis_cpu_write(*sbq->alloc_hint, hint);\r\n}\r\nnr = sbitmap_get_shallow(&sbq->sb, hint, shallow_depth);\r\nif (nr == -1) {\r\nthis_cpu_write(*sbq->alloc_hint, 0);\r\n} else if (nr == hint || unlikely(sbq->round_robin)) {\r\nhint = nr + 1;\r\nif (hint >= depth - 1)\r\nhint = 0;\r\nthis_cpu_write(*sbq->alloc_hint, hint);\r\n}\r\nreturn nr;\r\n}\r\nstatic struct sbq_wait_state *sbq_wake_ptr(struct sbitmap_queue *sbq)\r\n{\r\nint i, wake_index;\r\nwake_index = atomic_read(&sbq->wake_index);\r\nfor (i = 0; i < SBQ_WAIT_QUEUES; i++) {\r\nstruct sbq_wait_state *ws = &sbq->ws[wake_index];\r\nif (waitqueue_active(&ws->wait)) {\r\nint o = atomic_read(&sbq->wake_index);\r\nif (wake_index != o)\r\natomic_cmpxchg(&sbq->wake_index, o, wake_index);\r\nreturn ws;\r\n}\r\nwake_index = sbq_index_inc(wake_index);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void sbq_wake_up(struct sbitmap_queue *sbq)\r\n{\r\nstruct sbq_wait_state *ws;\r\nunsigned int wake_batch;\r\nint wait_cnt;\r\nsmp_mb__after_atomic();\r\nws = sbq_wake_ptr(sbq);\r\nif (!ws)\r\nreturn;\r\nwait_cnt = atomic_dec_return(&ws->wait_cnt);\r\nif (wait_cnt <= 0) {\r\nwake_batch = READ_ONCE(sbq->wake_batch);\r\nsmp_mb__before_atomic();\r\natomic_cmpxchg(&ws->wait_cnt, wait_cnt, wait_cnt + wake_batch);\r\nsbq_index_atomic_inc(&sbq->wake_index);\r\nwake_up(&ws->wait);\r\n}\r\n}\r\nvoid sbitmap_queue_clear(struct sbitmap_queue *sbq, unsigned int nr,\r\nunsigned int cpu)\r\n{\r\nsbitmap_clear_bit(&sbq->sb, nr);\r\nsbq_wake_up(sbq);\r\nif (likely(!sbq->round_robin && nr < sbq->sb.depth))\r\n*per_cpu_ptr(sbq->alloc_hint, cpu) = nr;\r\n}\r\nvoid sbitmap_queue_wake_all(struct sbitmap_queue *sbq)\r\n{\r\nint i, wake_index;\r\nsmp_mb();\r\nwake_index = atomic_read(&sbq->wake_index);\r\nfor (i = 0; i < SBQ_WAIT_QUEUES; i++) {\r\nstruct sbq_wait_state *ws = &sbq->ws[wake_index];\r\nif (waitqueue_active(&ws->wait))\r\nwake_up(&ws->wait);\r\nwake_index = sbq_index_inc(wake_index);\r\n}\r\n}\r\nvoid sbitmap_queue_show(struct sbitmap_queue *sbq, struct seq_file *m)\r\n{\r\nbool first;\r\nint i;\r\nsbitmap_show(&sbq->sb, m);\r\nseq_puts(m, "alloc_hint={");\r\nfirst = true;\r\nfor_each_possible_cpu(i) {\r\nif (!first)\r\nseq_puts(m, ", ");\r\nfirst = false;\r\nseq_printf(m, "%u", *per_cpu_ptr(sbq->alloc_hint, i));\r\n}\r\nseq_puts(m, "}\n");\r\nseq_printf(m, "wake_batch=%u\n", sbq->wake_batch);\r\nseq_printf(m, "wake_index=%d\n", atomic_read(&sbq->wake_index));\r\nseq_puts(m, "ws={\n");\r\nfor (i = 0; i < SBQ_WAIT_QUEUES; i++) {\r\nstruct sbq_wait_state *ws = &sbq->ws[i];\r\nseq_printf(m, "\t{.wait_cnt=%d, .wait=%s},\n",\r\natomic_read(&ws->wait_cnt),\r\nwaitqueue_active(&ws->wait) ? "active" : "inactive");\r\n}\r\nseq_puts(m, "}\n");\r\nseq_printf(m, "round_robin=%d\n", sbq->round_robin);\r\n}
