static int __must_check\r\nmmal_context_map_init(struct vchiq_mmal_context_map *context_map)\r\n{\r\nmutex_init(&context_map->lock);\r\ncontext_map->last_handle = 0;\r\nreturn btree_init32(&context_map->btree_head);\r\n}\r\nstatic void mmal_context_map_destroy(struct vchiq_mmal_context_map *context_map)\r\n{\r\nmutex_lock(&context_map->lock);\r\nbtree_destroy32(&context_map->btree_head);\r\nmutex_unlock(&context_map->lock);\r\n}\r\nstatic u32\r\nmmal_context_map_create_handle(struct vchiq_mmal_context_map *context_map,\r\nstruct mmal_msg_context *msg_context,\r\ngfp_t gfp)\r\n{\r\nu32 handle;\r\nmutex_lock(&context_map->lock);\r\nwhile (1) {\r\ncontext_map->last_handle++;\r\nif (!context_map->last_handle)\r\ncontext_map->last_handle++;\r\nhandle = context_map->last_handle;\r\nif (!btree_lookup32(&context_map->btree_head, handle))\r\nbreak;\r\n}\r\nif (btree_insert32(&context_map->btree_head, handle,\r\nmsg_context, gfp)) {\r\nmutex_unlock(&context_map->lock);\r\nreturn 0;\r\n}\r\nmutex_unlock(&context_map->lock);\r\nreturn handle;\r\n}\r\nstatic struct mmal_msg_context *\r\nmmal_context_map_lookup_handle(struct vchiq_mmal_context_map *context_map,\r\nu32 handle)\r\n{\r\nstruct mmal_msg_context *msg_context;\r\nif (!handle)\r\nreturn NULL;\r\nmutex_lock(&context_map->lock);\r\nmsg_context = btree_lookup32(&context_map->btree_head, handle);\r\nmutex_unlock(&context_map->lock);\r\nreturn msg_context;\r\n}\r\nstatic void\r\nmmal_context_map_destroy_handle(struct vchiq_mmal_context_map *context_map,\r\nu32 handle)\r\n{\r\nmutex_lock(&context_map->lock);\r\nbtree_remove32(&context_map->btree_head, handle);\r\nmutex_unlock(&context_map->lock);\r\n}\r\nstatic struct mmal_msg_context *\r\nget_msg_context(struct vchiq_mmal_instance *instance)\r\n{\r\nstruct mmal_msg_context *msg_context;\r\nmsg_context = kzalloc(sizeof(*msg_context), GFP_KERNEL);\r\nif (!msg_context)\r\nreturn ERR_PTR(-ENOMEM);\r\nmsg_context->instance = instance;\r\nmsg_context->handle =\r\nmmal_context_map_create_handle(&instance->context_map,\r\nmsg_context,\r\nGFP_KERNEL);\r\nif (!msg_context->handle) {\r\nkfree(msg_context);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn msg_context;\r\n}\r\nstatic struct mmal_msg_context *\r\nlookup_msg_context(struct vchiq_mmal_instance *instance, u32 handle)\r\n{\r\nreturn mmal_context_map_lookup_handle(&instance->context_map,\r\nhandle);\r\n}\r\nstatic void\r\nrelease_msg_context(struct mmal_msg_context *msg_context)\r\n{\r\nmmal_context_map_destroy_handle(&msg_context->instance->context_map,\r\nmsg_context->handle);\r\nkfree(msg_context);\r\n}\r\nstatic void event_to_host_cb(struct vchiq_mmal_instance *instance,\r\nstruct mmal_msg *msg, u32 msg_len)\r\n{\r\npr_debug("unhandled event\n");\r\npr_debug("component:%u port type:%d num:%d cmd:0x%x length:%d\n",\r\nmsg->u.event_to_host.client_component,\r\nmsg->u.event_to_host.port_type,\r\nmsg->u.event_to_host.port_num,\r\nmsg->u.event_to_host.cmd, msg->u.event_to_host.length);\r\n}\r\nstatic void buffer_work_cb(struct work_struct *work)\r\n{\r\nstruct mmal_msg_context *msg_context =\r\ncontainer_of(work, struct mmal_msg_context, u.bulk.work);\r\nmsg_context->u.bulk.port->buffer_cb(msg_context->u.bulk.instance,\r\nmsg_context->u.bulk.port,\r\nmsg_context->u.bulk.status,\r\nmsg_context->u.bulk.buffer,\r\nmsg_context->u.bulk.buffer_used,\r\nmsg_context->u.bulk.mmal_flags,\r\nmsg_context->u.bulk.dts,\r\nmsg_context->u.bulk.pts);\r\nrelease_msg_context(msg_context);\r\n}\r\nstatic int bulk_receive(struct vchiq_mmal_instance *instance,\r\nstruct mmal_msg *msg,\r\nstruct mmal_msg_context *msg_context)\r\n{\r\nunsigned long rd_len;\r\nunsigned long flags = 0;\r\nint ret;\r\nret = mutex_lock_interruptible(&instance->bulk_mutex);\r\nif (ret != 0)\r\nreturn ret;\r\nrd_len = msg->u.buffer_from_host.buffer_header.length;\r\nspin_lock_irqsave(&msg_context->u.bulk.port->slock, flags);\r\nif (list_empty(&msg_context->u.bulk.port->buffers)) {\r\nspin_unlock_irqrestore(&msg_context->u.bulk.port->slock, flags);\r\npr_err("buffer list empty trying to submit bulk receive\n");\r\nmutex_unlock(&instance->bulk_mutex);\r\nreturn -EINVAL;\r\n}\r\nmsg_context->u.bulk.buffer =\r\nlist_entry(msg_context->u.bulk.port->buffers.next,\r\nstruct mmal_buffer, list);\r\nlist_del(&msg_context->u.bulk.buffer->list);\r\nspin_unlock_irqrestore(&msg_context->u.bulk.port->slock, flags);\r\nif (rd_len > msg_context->u.bulk.buffer->buffer_size) {\r\nrd_len = msg_context->u.bulk.buffer->buffer_size;\r\npr_warn("short read as not enough receive buffer space\n");\r\n}\r\nmsg_context->u.bulk.buffer_used = rd_len;\r\nmsg_context->u.bulk.mmal_flags =\r\nmsg->u.buffer_from_host.buffer_header.flags;\r\nmsg_context->u.bulk.dts = msg->u.buffer_from_host.buffer_header.dts;\r\nmsg_context->u.bulk.pts = msg->u.buffer_from_host.buffer_header.pts;\r\nvchi_service_use(instance->handle);\r\nret = vchi_bulk_queue_receive(instance->handle,\r\nmsg_context->u.bulk.buffer->buffer,\r\n(rd_len + 3) & ~3,\r\nVCHI_FLAGS_CALLBACK_WHEN_OP_COMPLETE |\r\nVCHI_FLAGS_BLOCK_UNTIL_QUEUED,\r\nmsg_context);\r\nvchi_service_release(instance->handle);\r\nif (ret != 0) {\r\nmutex_unlock(&instance->bulk_mutex);\r\n}\r\nreturn ret;\r\n}\r\nstatic int dummy_bulk_receive(struct vchiq_mmal_instance *instance,\r\nstruct mmal_msg_context *msg_context)\r\n{\r\nint ret;\r\nret = mutex_lock_interruptible(&instance->bulk_mutex);\r\nif (ret != 0)\r\nreturn ret;\r\nmsg_context->u.bulk.buffer_used = 0;\r\nvchi_service_use(instance->handle);\r\nret = vchi_bulk_queue_receive(instance->handle,\r\ninstance->bulk_scratch,\r\n8,\r\nVCHI_FLAGS_CALLBACK_WHEN_OP_COMPLETE |\r\nVCHI_FLAGS_BLOCK_UNTIL_QUEUED,\r\nmsg_context);\r\nvchi_service_release(instance->handle);\r\nif (ret != 0) {\r\nmutex_unlock(&instance->bulk_mutex);\r\n}\r\nreturn ret;\r\n}\r\nstatic int inline_receive(struct vchiq_mmal_instance *instance,\r\nstruct mmal_msg *msg,\r\nstruct mmal_msg_context *msg_context)\r\n{\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&msg_context->u.bulk.port->slock, flags);\r\nif (list_empty(&msg_context->u.bulk.port->buffers)) {\r\nspin_unlock_irqrestore(&msg_context->u.bulk.port->slock, flags);\r\npr_err("buffer list empty trying to receive inline\n");\r\nreturn -EINVAL;\r\n}\r\nmsg_context->u.bulk.buffer =\r\nlist_entry(msg_context->u.bulk.port->buffers.next,\r\nstruct mmal_buffer, list);\r\nlist_del(&msg_context->u.bulk.buffer->list);\r\nspin_unlock_irqrestore(&msg_context->u.bulk.port->slock, flags);\r\nmemcpy(msg_context->u.bulk.buffer->buffer,\r\nmsg->u.buffer_from_host.short_data,\r\nmsg->u.buffer_from_host.payload_in_message);\r\nmsg_context->u.bulk.buffer_used =\r\nmsg->u.buffer_from_host.payload_in_message;\r\nreturn 0;\r\n}\r\nstatic int\r\nbuffer_from_host(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port, struct mmal_buffer *buf)\r\n{\r\nstruct mmal_msg_context *msg_context;\r\nstruct mmal_msg m;\r\nint ret;\r\npr_debug("instance:%p buffer:%p\n", instance->handle, buf);\r\nif (mutex_lock_interruptible(&instance->bulk_mutex))\r\nreturn -EINTR;\r\nmsg_context = get_msg_context(instance);\r\nif (IS_ERR(msg_context)) {\r\nret = PTR_ERR(msg_context);\r\ngoto unlock;\r\n}\r\nmsg_context->u.bulk.instance = instance;\r\nmsg_context->u.bulk.port = port;\r\nmsg_context->u.bulk.buffer = NULL;\r\nmsg_context->u.bulk.buffer_used = 0;\r\nINIT_WORK(&msg_context->u.bulk.work, buffer_work_cb);\r\nmemset(&m, 0xbc, sizeof(m));\r\nm.h.type = MMAL_MSG_TYPE_BUFFER_FROM_HOST;\r\nm.h.magic = MMAL_MAGIC;\r\nm.h.context = msg_context->handle;\r\nm.h.status = 0;\r\nm.u.buffer_from_host.drvbuf.magic = MMAL_MAGIC;\r\nm.u.buffer_from_host.drvbuf.component_handle = port->component->handle;\r\nm.u.buffer_from_host.drvbuf.port_handle = port->handle;\r\nm.u.buffer_from_host.drvbuf.client_context = msg_context->handle;\r\nm.u.buffer_from_host.buffer_header.cmd = 0;\r\nm.u.buffer_from_host.buffer_header.data =\r\n(u32)(unsigned long)buf->buffer;\r\nm.u.buffer_from_host.buffer_header.alloc_size = buf->buffer_size;\r\nm.u.buffer_from_host.buffer_header.length = 0;\r\nm.u.buffer_from_host.buffer_header.offset = 0;\r\nm.u.buffer_from_host.buffer_header.flags = 0;\r\nm.u.buffer_from_host.buffer_header.pts = MMAL_TIME_UNKNOWN;\r\nm.u.buffer_from_host.buffer_header.dts = MMAL_TIME_UNKNOWN;\r\nmemset(&m.u.buffer_from_host.buffer_header_type_specific, 0,\r\nsizeof(m.u.buffer_from_host.buffer_header_type_specific));\r\nm.u.buffer_from_host.payload_in_message = 0;\r\nvchi_service_use(instance->handle);\r\nret = vchi_queue_kernel_message(instance->handle,\r\n&m,\r\nsizeof(struct mmal_msg_header) +\r\nsizeof(m.u.buffer_from_host));\r\nif (ret != 0) {\r\nrelease_msg_context(msg_context);\r\n}\r\nvchi_service_release(instance->handle);\r\nunlock:\r\nmutex_unlock(&instance->bulk_mutex);\r\nreturn ret;\r\n}\r\nstatic int port_buffer_from_host(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port)\r\n{\r\nint ret;\r\nstruct mmal_buffer *buf;\r\nunsigned long flags = 0;\r\nif (!port->enabled)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&port->slock, flags);\r\nif (list_empty(&port->buffers)) {\r\nport->buffer_underflow++;\r\nspin_unlock_irqrestore(&port->slock, flags);\r\nreturn -ENOSPC;\r\n}\r\nbuf = list_entry(port->buffers.next, struct mmal_buffer, list);\r\nspin_unlock_irqrestore(&port->slock, flags);\r\nret = buffer_from_host(instance, port, buf);\r\nif (ret) {\r\npr_err("adding buffer header failed\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic void buffer_to_host_cb(struct vchiq_mmal_instance *instance,\r\nstruct mmal_msg *msg, u32 msg_len)\r\n{\r\nstruct mmal_msg_context *msg_context;\r\nu32 handle;\r\npr_debug("buffer_to_host_cb: instance:%p msg:%p msg_len:%d\n",\r\ninstance, msg, msg_len);\r\nif (msg->u.buffer_from_host.drvbuf.magic == MMAL_MAGIC) {\r\nhandle = msg->u.buffer_from_host.drvbuf.client_context;\r\nmsg_context = lookup_msg_context(instance, handle);\r\nif (!msg_context) {\r\npr_err("drvbuf.client_context(%u) is invalid\n",\r\nhandle);\r\nreturn;\r\n}\r\n} else {\r\npr_err("MMAL_MSG_TYPE_BUFFER_TO_HOST with bad magic\n");\r\nreturn;\r\n}\r\nif (msg->h.status != MMAL_MSG_STATUS_SUCCESS) {\r\npr_warn("error %d in reply\n", msg->h.status);\r\nmsg_context->u.bulk.status = msg->h.status;\r\n} else if (msg->u.buffer_from_host.buffer_header.length == 0) {\r\nif (msg->u.buffer_from_host.buffer_header.flags &\r\nMMAL_BUFFER_HEADER_FLAG_EOS) {\r\nmsg_context->u.bulk.status =\r\ndummy_bulk_receive(instance, msg_context);\r\nif (msg_context->u.bulk.status == 0)\r\nreturn;\r\n} else {\r\nmsg_context->u.bulk.status = 0;\r\nmsg_context->u.bulk.buffer_used = 0;\r\n}\r\n} else if (msg->u.buffer_from_host.payload_in_message == 0) {\r\nmsg_context->u.bulk.status =\r\nbulk_receive(instance, msg, msg_context);\r\nif (msg_context->u.bulk.status == 0)\r\nreturn;\r\npr_err("error %d on bulk submission\n",\r\nmsg_context->u.bulk.status);\r\n} else if (msg->u.buffer_from_host.payload_in_message <=\r\nMMAL_VC_SHORT_DATA) {\r\nmsg_context->u.bulk.status = inline_receive(instance, msg,\r\nmsg_context);\r\n} else {\r\npr_err("message with invalid short payload\n");\r\nmsg_context->u.bulk.status = -EINVAL;\r\nmsg_context->u.bulk.buffer_used =\r\nmsg->u.buffer_from_host.payload_in_message;\r\n}\r\nport_buffer_from_host(instance, msg_context->u.bulk.port);\r\nschedule_work(&msg_context->u.bulk.work);\r\n}\r\nstatic void bulk_receive_cb(struct vchiq_mmal_instance *instance,\r\nstruct mmal_msg_context *msg_context)\r\n{\r\nmutex_unlock(&msg_context->u.bulk.instance->bulk_mutex);\r\nport_buffer_from_host(msg_context->u.bulk.instance,\r\nmsg_context->u.bulk.port);\r\nmsg_context->u.bulk.status = 0;\r\nschedule_work(&msg_context->u.bulk.work);\r\n}\r\nstatic void bulk_abort_cb(struct vchiq_mmal_instance *instance,\r\nstruct mmal_msg_context *msg_context)\r\n{\r\npr_err("%s: bulk ABORTED msg_context:%p\n", __func__, msg_context);\r\nmutex_unlock(&msg_context->u.bulk.instance->bulk_mutex);\r\nport_buffer_from_host(msg_context->u.bulk.instance,\r\nmsg_context->u.bulk.port);\r\nmsg_context->u.bulk.status = -EINTR;\r\nschedule_work(&msg_context->u.bulk.work);\r\n}\r\nstatic void service_callback(void *param,\r\nconst VCHI_CALLBACK_REASON_T reason,\r\nvoid *bulk_ctx)\r\n{\r\nstruct vchiq_mmal_instance *instance = param;\r\nint status;\r\nu32 msg_len;\r\nstruct mmal_msg *msg;\r\nVCHI_HELD_MSG_T msg_handle;\r\nstruct mmal_msg_context *msg_context;\r\nif (!instance) {\r\npr_err("Message callback passed NULL instance\n");\r\nreturn;\r\n}\r\nswitch (reason) {\r\ncase VCHI_CALLBACK_MSG_AVAILABLE:\r\nstatus = vchi_msg_hold(instance->handle, (void **)&msg,\r\n&msg_len, VCHI_FLAGS_NONE, &msg_handle);\r\nif (status) {\r\npr_err("Unable to dequeue a message (%d)\n", status);\r\nbreak;\r\n}\r\nDBG_DUMP_MSG(msg, msg_len, "<<< reply message");\r\nswitch (msg->h.type) {\r\ncase MMAL_MSG_TYPE_BUFFER_FROM_HOST:\r\nvchi_held_msg_release(&msg_handle);\r\nbreak;\r\ncase MMAL_MSG_TYPE_EVENT_TO_HOST:\r\nevent_to_host_cb(instance, msg, msg_len);\r\nvchi_held_msg_release(&msg_handle);\r\nbreak;\r\ncase MMAL_MSG_TYPE_BUFFER_TO_HOST:\r\nbuffer_to_host_cb(instance, msg, msg_len);\r\nvchi_held_msg_release(&msg_handle);\r\nbreak;\r\ndefault:\r\nif (!msg->h.context) {\r\npr_err("received message context was null!\n");\r\nvchi_held_msg_release(&msg_handle);\r\nbreak;\r\n}\r\nmsg_context = lookup_msg_context(instance,\r\nmsg->h.context);\r\nif (!msg_context) {\r\npr_err("received invalid message context %u!\n",\r\nmsg->h.context);\r\nvchi_held_msg_release(&msg_handle);\r\nbreak;\r\n}\r\nmsg_context->u.sync.msg_handle = msg_handle;\r\nmsg_context->u.sync.msg = msg;\r\nmsg_context->u.sync.msg_len = msg_len;\r\ncomplete(&msg_context->u.sync.cmplt);\r\nbreak;\r\n}\r\nbreak;\r\ncase VCHI_CALLBACK_BULK_RECEIVED:\r\nbulk_receive_cb(instance, bulk_ctx);\r\nbreak;\r\ncase VCHI_CALLBACK_BULK_RECEIVE_ABORTED:\r\nbulk_abort_cb(instance, bulk_ctx);\r\nbreak;\r\ncase VCHI_CALLBACK_SERVICE_CLOSED:\r\nbreak;\r\ndefault:\r\npr_err("Received unhandled message reason %d\n", reason);\r\nbreak;\r\n}\r\n}\r\nstatic int send_synchronous_mmal_msg(struct vchiq_mmal_instance *instance,\r\nstruct mmal_msg *msg,\r\nunsigned int payload_len,\r\nstruct mmal_msg **msg_out,\r\nVCHI_HELD_MSG_T *msg_handle_out)\r\n{\r\nstruct mmal_msg_context *msg_context;\r\nint ret;\r\nif (payload_len >\r\n(MMAL_MSG_MAX_SIZE - sizeof(struct mmal_msg_header))) {\r\npr_err("payload length %d exceeds max:%d\n", payload_len,\r\n(int)(MMAL_MSG_MAX_SIZE -\r\nsizeof(struct mmal_msg_header)));\r\nreturn -EINVAL;\r\n}\r\nmsg_context = get_msg_context(instance);\r\nif (IS_ERR(msg_context))\r\nreturn PTR_ERR(msg_context);\r\ninit_completion(&msg_context->u.sync.cmplt);\r\nmsg->h.magic = MMAL_MAGIC;\r\nmsg->h.context = msg_context->handle;\r\nmsg->h.status = 0;\r\nDBG_DUMP_MSG(msg, (sizeof(struct mmal_msg_header) + payload_len),\r\n">>> sync message");\r\nvchi_service_use(instance->handle);\r\nret = vchi_queue_kernel_message(instance->handle,\r\nmsg,\r\nsizeof(struct mmal_msg_header) +\r\npayload_len);\r\nvchi_service_release(instance->handle);\r\nif (ret) {\r\npr_err("error %d queuing message\n", ret);\r\nrelease_msg_context(msg_context);\r\nreturn ret;\r\n}\r\nret = wait_for_completion_timeout(&msg_context->u.sync.cmplt, 3 * HZ);\r\nif (ret <= 0) {\r\npr_err("error %d waiting for sync completion\n", ret);\r\nif (ret == 0)\r\nret = -ETIME;\r\nrelease_msg_context(msg_context);\r\nreturn ret;\r\n}\r\n*msg_out = msg_context->u.sync.msg;\r\n*msg_handle_out = msg_context->u.sync.msg_handle;\r\nrelease_msg_context(msg_context);\r\nreturn 0;\r\n}\r\nstatic void dump_port_info(struct vchiq_mmal_port *port)\r\n{\r\npr_debug("port handle:0x%x enabled:%d\n", port->handle, port->enabled);\r\npr_debug("buffer minimum num:%d size:%d align:%d\n",\r\nport->minimum_buffer.num,\r\nport->minimum_buffer.size, port->minimum_buffer.alignment);\r\npr_debug("buffer recommended num:%d size:%d align:%d\n",\r\nport->recommended_buffer.num,\r\nport->recommended_buffer.size,\r\nport->recommended_buffer.alignment);\r\npr_debug("buffer current values num:%d size:%d align:%d\n",\r\nport->current_buffer.num,\r\nport->current_buffer.size, port->current_buffer.alignment);\r\npr_debug("elementary stream: type:%d encoding:0x%x variant:0x%x\n",\r\nport->format.type,\r\nport->format.encoding, port->format.encoding_variant);\r\npr_debug(" bitrate:%d flags:0x%x\n",\r\nport->format.bitrate, port->format.flags);\r\nif (port->format.type == MMAL_ES_TYPE_VIDEO) {\r\npr_debug\r\n("es video format: width:%d height:%d colourspace:0x%x\n",\r\nport->es.video.width, port->es.video.height,\r\nport->es.video.color_space);\r\npr_debug(" : crop xywh %d,%d,%d,%d\n",\r\nport->es.video.crop.x,\r\nport->es.video.crop.y,\r\nport->es.video.crop.width, port->es.video.crop.height);\r\npr_debug(" : framerate %d/%d aspect %d/%d\n",\r\nport->es.video.frame_rate.num,\r\nport->es.video.frame_rate.den,\r\nport->es.video.par.num, port->es.video.par.den);\r\n}\r\n}\r\nstatic void port_to_mmal_msg(struct vchiq_mmal_port *port, struct mmal_port *p)\r\n{\r\np->type = port->type;\r\np->index = port->index;\r\np->index_all = 0;\r\np->is_enabled = port->enabled;\r\np->buffer_num_min = port->minimum_buffer.num;\r\np->buffer_size_min = port->minimum_buffer.size;\r\np->buffer_alignment_min = port->minimum_buffer.alignment;\r\np->buffer_num_recommended = port->recommended_buffer.num;\r\np->buffer_size_recommended = port->recommended_buffer.size;\r\np->buffer_num = port->current_buffer.num;\r\np->buffer_size = port->current_buffer.size;\r\np->userdata = (u32)(unsigned long)port;\r\n}\r\nstatic int port_info_set(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port)\r\n{\r\nint ret;\r\nstruct mmal_msg m;\r\nstruct mmal_msg *rmsg;\r\nVCHI_HELD_MSG_T rmsg_handle;\r\npr_debug("setting port info port %p\n", port);\r\nif (!port)\r\nreturn -1;\r\ndump_port_info(port);\r\nm.h.type = MMAL_MSG_TYPE_PORT_INFO_SET;\r\nm.u.port_info_set.component_handle = port->component->handle;\r\nm.u.port_info_set.port_type = port->type;\r\nm.u.port_info_set.port_index = port->index;\r\nport_to_mmal_msg(port, &m.u.port_info_set.port);\r\nm.u.port_info_set.format.type = port->format.type;\r\nm.u.port_info_set.format.encoding = port->format.encoding;\r\nm.u.port_info_set.format.encoding_variant =\r\nport->format.encoding_variant;\r\nm.u.port_info_set.format.bitrate = port->format.bitrate;\r\nm.u.port_info_set.format.flags = port->format.flags;\r\nmemcpy(&m.u.port_info_set.es, &port->es,\r\nsizeof(union mmal_es_specific_format));\r\nm.u.port_info_set.format.extradata_size = port->format.extradata_size;\r\nmemcpy(&m.u.port_info_set.extradata, port->format.extradata,\r\nport->format.extradata_size);\r\nret = send_synchronous_mmal_msg(instance, &m,\r\nsizeof(m.u.port_info_set),\r\n&rmsg, &rmsg_handle);\r\nif (ret)\r\nreturn ret;\r\nif (rmsg->h.type != MMAL_MSG_TYPE_PORT_INFO_SET) {\r\nret = -EINVAL;\r\ngoto release_msg;\r\n}\r\nret = -rmsg->u.port_info_get_reply.status;\r\npr_debug("%s:result:%d component:0x%x port:%d\n", __func__, ret,\r\nport->component->handle, port->handle);\r\nrelease_msg:\r\nvchi_held_msg_release(&rmsg_handle);\r\nreturn ret;\r\n}\r\nstatic int port_info_get(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port)\r\n{\r\nint ret;\r\nstruct mmal_msg m;\r\nstruct mmal_msg *rmsg;\r\nVCHI_HELD_MSG_T rmsg_handle;\r\nm.h.type = MMAL_MSG_TYPE_PORT_INFO_GET;\r\nm.u.port_info_get.component_handle = port->component->handle;\r\nm.u.port_info_get.port_type = port->type;\r\nm.u.port_info_get.index = port->index;\r\nret = send_synchronous_mmal_msg(instance, &m,\r\nsizeof(m.u.port_info_get),\r\n&rmsg, &rmsg_handle);\r\nif (ret)\r\nreturn ret;\r\nif (rmsg->h.type != MMAL_MSG_TYPE_PORT_INFO_GET) {\r\nret = -EINVAL;\r\ngoto release_msg;\r\n}\r\nret = -rmsg->u.port_info_get_reply.status;\r\nif (ret != MMAL_MSG_STATUS_SUCCESS)\r\ngoto release_msg;\r\nif (rmsg->u.port_info_get_reply.port.is_enabled == 0)\r\nport->enabled = false;\r\nelse\r\nport->enabled = true;\r\nport->handle = rmsg->u.port_info_get_reply.port_handle;\r\nport->type = rmsg->u.port_info_get_reply.port_type;\r\nport->index = rmsg->u.port_info_get_reply.port_index;\r\nport->minimum_buffer.num =\r\nrmsg->u.port_info_get_reply.port.buffer_num_min;\r\nport->minimum_buffer.size =\r\nrmsg->u.port_info_get_reply.port.buffer_size_min;\r\nport->minimum_buffer.alignment =\r\nrmsg->u.port_info_get_reply.port.buffer_alignment_min;\r\nport->recommended_buffer.alignment =\r\nrmsg->u.port_info_get_reply.port.buffer_alignment_min;\r\nport->recommended_buffer.num =\r\nrmsg->u.port_info_get_reply.port.buffer_num_recommended;\r\nport->current_buffer.num = rmsg->u.port_info_get_reply.port.buffer_num;\r\nport->current_buffer.size =\r\nrmsg->u.port_info_get_reply.port.buffer_size;\r\nport->format.type = rmsg->u.port_info_get_reply.format.type;\r\nport->format.encoding = rmsg->u.port_info_get_reply.format.encoding;\r\nport->format.encoding_variant =\r\nrmsg->u.port_info_get_reply.format.encoding_variant;\r\nport->format.bitrate = rmsg->u.port_info_get_reply.format.bitrate;\r\nport->format.flags = rmsg->u.port_info_get_reply.format.flags;\r\nmemcpy(&port->es,\r\n&rmsg->u.port_info_get_reply.es,\r\nsizeof(union mmal_es_specific_format));\r\nport->format.es = &port->es;\r\nport->format.extradata_size =\r\nrmsg->u.port_info_get_reply.format.extradata_size;\r\nmemcpy(port->format.extradata,\r\nrmsg->u.port_info_get_reply.extradata,\r\nport->format.extradata_size);\r\npr_debug("received port info\n");\r\ndump_port_info(port);\r\nrelease_msg:\r\npr_debug("%s:result:%d component:0x%x port:%d\n",\r\n__func__, ret, port->component->handle, port->handle);\r\nvchi_held_msg_release(&rmsg_handle);\r\nreturn ret;\r\n}\r\nstatic int create_component(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_component *component,\r\nconst char *name)\r\n{\r\nint ret;\r\nstruct mmal_msg m;\r\nstruct mmal_msg *rmsg;\r\nVCHI_HELD_MSG_T rmsg_handle;\r\nm.h.type = MMAL_MSG_TYPE_COMPONENT_CREATE;\r\nm.u.component_create.client_component = (u32)(unsigned long)component;\r\nstrncpy(m.u.component_create.name, name,\r\nsizeof(m.u.component_create.name));\r\nret = send_synchronous_mmal_msg(instance, &m,\r\nsizeof(m.u.component_create),\r\n&rmsg, &rmsg_handle);\r\nif (ret)\r\nreturn ret;\r\nif (rmsg->h.type != m.h.type) {\r\nret = -EINVAL;\r\ngoto release_msg;\r\n}\r\nret = -rmsg->u.component_create_reply.status;\r\nif (ret != MMAL_MSG_STATUS_SUCCESS)\r\ngoto release_msg;\r\ncomponent->handle = rmsg->u.component_create_reply.component_handle;\r\ncomponent->inputs = rmsg->u.component_create_reply.input_num;\r\ncomponent->outputs = rmsg->u.component_create_reply.output_num;\r\ncomponent->clocks = rmsg->u.component_create_reply.clock_num;\r\npr_debug("Component handle:0x%x in:%d out:%d clock:%d\n",\r\ncomponent->handle,\r\ncomponent->inputs, component->outputs, component->clocks);\r\nrelease_msg:\r\nvchi_held_msg_release(&rmsg_handle);\r\nreturn ret;\r\n}\r\nstatic int destroy_component(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_component *component)\r\n{\r\nint ret;\r\nstruct mmal_msg m;\r\nstruct mmal_msg *rmsg;\r\nVCHI_HELD_MSG_T rmsg_handle;\r\nm.h.type = MMAL_MSG_TYPE_COMPONENT_DESTROY;\r\nm.u.component_destroy.component_handle = component->handle;\r\nret = send_synchronous_mmal_msg(instance, &m,\r\nsizeof(m.u.component_destroy),\r\n&rmsg, &rmsg_handle);\r\nif (ret)\r\nreturn ret;\r\nif (rmsg->h.type != m.h.type) {\r\nret = -EINVAL;\r\ngoto release_msg;\r\n}\r\nret = -rmsg->u.component_destroy_reply.status;\r\nrelease_msg:\r\nvchi_held_msg_release(&rmsg_handle);\r\nreturn ret;\r\n}\r\nstatic int enable_component(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_component *component)\r\n{\r\nint ret;\r\nstruct mmal_msg m;\r\nstruct mmal_msg *rmsg;\r\nVCHI_HELD_MSG_T rmsg_handle;\r\nm.h.type = MMAL_MSG_TYPE_COMPONENT_ENABLE;\r\nm.u.component_enable.component_handle = component->handle;\r\nret = send_synchronous_mmal_msg(instance, &m,\r\nsizeof(m.u.component_enable),\r\n&rmsg, &rmsg_handle);\r\nif (ret)\r\nreturn ret;\r\nif (rmsg->h.type != m.h.type) {\r\nret = -EINVAL;\r\ngoto release_msg;\r\n}\r\nret = -rmsg->u.component_enable_reply.status;\r\nrelease_msg:\r\nvchi_held_msg_release(&rmsg_handle);\r\nreturn ret;\r\n}\r\nstatic int disable_component(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_component *component)\r\n{\r\nint ret;\r\nstruct mmal_msg m;\r\nstruct mmal_msg *rmsg;\r\nVCHI_HELD_MSG_T rmsg_handle;\r\nm.h.type = MMAL_MSG_TYPE_COMPONENT_DISABLE;\r\nm.u.component_disable.component_handle = component->handle;\r\nret = send_synchronous_mmal_msg(instance, &m,\r\nsizeof(m.u.component_disable),\r\n&rmsg, &rmsg_handle);\r\nif (ret)\r\nreturn ret;\r\nif (rmsg->h.type != m.h.type) {\r\nret = -EINVAL;\r\ngoto release_msg;\r\n}\r\nret = -rmsg->u.component_disable_reply.status;\r\nrelease_msg:\r\nvchi_held_msg_release(&rmsg_handle);\r\nreturn ret;\r\n}\r\nstatic int get_version(struct vchiq_mmal_instance *instance,\r\nu32 *major_out, u32 *minor_out)\r\n{\r\nint ret;\r\nstruct mmal_msg m;\r\nstruct mmal_msg *rmsg;\r\nVCHI_HELD_MSG_T rmsg_handle;\r\nm.h.type = MMAL_MSG_TYPE_GET_VERSION;\r\nret = send_synchronous_mmal_msg(instance, &m,\r\nsizeof(m.u.version),\r\n&rmsg, &rmsg_handle);\r\nif (ret)\r\nreturn ret;\r\nif (rmsg->h.type != m.h.type) {\r\nret = -EINVAL;\r\ngoto release_msg;\r\n}\r\n*major_out = rmsg->u.version.major;\r\n*minor_out = rmsg->u.version.minor;\r\nrelease_msg:\r\nvchi_held_msg_release(&rmsg_handle);\r\nreturn ret;\r\n}\r\nstatic int port_action_port(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port,\r\nenum mmal_msg_port_action_type action_type)\r\n{\r\nint ret;\r\nstruct mmal_msg m;\r\nstruct mmal_msg *rmsg;\r\nVCHI_HELD_MSG_T rmsg_handle;\r\nm.h.type = MMAL_MSG_TYPE_PORT_ACTION;\r\nm.u.port_action_port.component_handle = port->component->handle;\r\nm.u.port_action_port.port_handle = port->handle;\r\nm.u.port_action_port.action = action_type;\r\nport_to_mmal_msg(port, &m.u.port_action_port.port);\r\nret = send_synchronous_mmal_msg(instance, &m,\r\nsizeof(m.u.port_action_port),\r\n&rmsg, &rmsg_handle);\r\nif (ret)\r\nreturn ret;\r\nif (rmsg->h.type != MMAL_MSG_TYPE_PORT_ACTION) {\r\nret = -EINVAL;\r\ngoto release_msg;\r\n}\r\nret = -rmsg->u.port_action_reply.status;\r\npr_debug("%s:result:%d component:0x%x port:%d action:%s(%d)\n",\r\n__func__,\r\nret, port->component->handle, port->handle,\r\nport_action_type_names[action_type], action_type);\r\nrelease_msg:\r\nvchi_held_msg_release(&rmsg_handle);\r\nreturn ret;\r\n}\r\nstatic int port_action_handle(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port,\r\nenum mmal_msg_port_action_type action_type,\r\nu32 connect_component_handle,\r\nu32 connect_port_handle)\r\n{\r\nint ret;\r\nstruct mmal_msg m;\r\nstruct mmal_msg *rmsg;\r\nVCHI_HELD_MSG_T rmsg_handle;\r\nm.h.type = MMAL_MSG_TYPE_PORT_ACTION;\r\nm.u.port_action_handle.component_handle = port->component->handle;\r\nm.u.port_action_handle.port_handle = port->handle;\r\nm.u.port_action_handle.action = action_type;\r\nm.u.port_action_handle.connect_component_handle =\r\nconnect_component_handle;\r\nm.u.port_action_handle.connect_port_handle = connect_port_handle;\r\nret = send_synchronous_mmal_msg(instance, &m,\r\nsizeof(m.u.port_action_handle),\r\n&rmsg, &rmsg_handle);\r\nif (ret)\r\nreturn ret;\r\nif (rmsg->h.type != MMAL_MSG_TYPE_PORT_ACTION) {\r\nret = -EINVAL;\r\ngoto release_msg;\r\n}\r\nret = -rmsg->u.port_action_reply.status;\r\npr_debug("%s:result:%d component:0x%x port:%d action:%s(%d)" \\r\n" connect component:0x%x connect port:%d\n",\r\n__func__,\r\nret, port->component->handle, port->handle,\r\nport_action_type_names[action_type],\r\naction_type, connect_component_handle, connect_port_handle);\r\nrelease_msg:\r\nvchi_held_msg_release(&rmsg_handle);\r\nreturn ret;\r\n}\r\nstatic int port_parameter_set(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port,\r\nu32 parameter_id, void *value, u32 value_size)\r\n{\r\nint ret;\r\nstruct mmal_msg m;\r\nstruct mmal_msg *rmsg;\r\nVCHI_HELD_MSG_T rmsg_handle;\r\nm.h.type = MMAL_MSG_TYPE_PORT_PARAMETER_SET;\r\nm.u.port_parameter_set.component_handle = port->component->handle;\r\nm.u.port_parameter_set.port_handle = port->handle;\r\nm.u.port_parameter_set.id = parameter_id;\r\nm.u.port_parameter_set.size = (2 * sizeof(u32)) + value_size;\r\nmemcpy(&m.u.port_parameter_set.value, value, value_size);\r\nret = send_synchronous_mmal_msg(instance, &m,\r\n(4 * sizeof(u32)) + value_size,\r\n&rmsg, &rmsg_handle);\r\nif (ret)\r\nreturn ret;\r\nif (rmsg->h.type != MMAL_MSG_TYPE_PORT_PARAMETER_SET) {\r\nret = -EINVAL;\r\ngoto release_msg;\r\n}\r\nret = -rmsg->u.port_parameter_set_reply.status;\r\npr_debug("%s:result:%d component:0x%x port:%d parameter:%d\n",\r\n__func__,\r\nret, port->component->handle, port->handle, parameter_id);\r\nrelease_msg:\r\nvchi_held_msg_release(&rmsg_handle);\r\nreturn ret;\r\n}\r\nstatic int port_parameter_get(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port,\r\nu32 parameter_id, void *value, u32 *value_size)\r\n{\r\nint ret;\r\nstruct mmal_msg m;\r\nstruct mmal_msg *rmsg;\r\nVCHI_HELD_MSG_T rmsg_handle;\r\nm.h.type = MMAL_MSG_TYPE_PORT_PARAMETER_GET;\r\nm.u.port_parameter_get.component_handle = port->component->handle;\r\nm.u.port_parameter_get.port_handle = port->handle;\r\nm.u.port_parameter_get.id = parameter_id;\r\nm.u.port_parameter_get.size = (2 * sizeof(u32)) + *value_size;\r\nret = send_synchronous_mmal_msg(instance, &m,\r\nsizeof(struct\r\nmmal_msg_port_parameter_get),\r\n&rmsg, &rmsg_handle);\r\nif (ret)\r\nreturn ret;\r\nif (rmsg->h.type != MMAL_MSG_TYPE_PORT_PARAMETER_GET) {\r\npr_err("Incorrect reply type %d\n", rmsg->h.type);\r\nret = -EINVAL;\r\ngoto release_msg;\r\n}\r\nret = -rmsg->u.port_parameter_get_reply.status;\r\nrmsg->u.port_parameter_get_reply.size -= (2 * sizeof(u32));\r\nif (ret || rmsg->u.port_parameter_get_reply.size > *value_size) {\r\nmemcpy(value, &rmsg->u.port_parameter_get_reply.value,\r\n*value_size);\r\n*value_size = rmsg->u.port_parameter_get_reply.size;\r\n} else\r\nmemcpy(value, &rmsg->u.port_parameter_get_reply.value,\r\nrmsg->u.port_parameter_get_reply.size);\r\npr_debug("%s:result:%d component:0x%x port:%d parameter:%d\n", __func__,\r\nret, port->component->handle, port->handle, parameter_id);\r\nrelease_msg:\r\nvchi_held_msg_release(&rmsg_handle);\r\nreturn ret;\r\n}\r\nstatic int port_disable(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port)\r\n{\r\nint ret;\r\nstruct list_head *q, *buf_head;\r\nunsigned long flags = 0;\r\nif (!port->enabled)\r\nreturn 0;\r\nport->enabled = false;\r\nret = port_action_port(instance, port,\r\nMMAL_MSG_PORT_ACTION_TYPE_DISABLE);\r\nif (ret == 0) {\r\nspin_lock_irqsave(&port->slock, flags);\r\nlist_for_each_safe(buf_head, q, &port->buffers) {\r\nstruct mmal_buffer *mmalbuf;\r\nmmalbuf = list_entry(buf_head, struct mmal_buffer,\r\nlist);\r\nlist_del(buf_head);\r\nif (port->buffer_cb)\r\nport->buffer_cb(instance,\r\nport, 0, mmalbuf, 0, 0,\r\nMMAL_TIME_UNKNOWN,\r\nMMAL_TIME_UNKNOWN);\r\n}\r\nspin_unlock_irqrestore(&port->slock, flags);\r\nret = port_info_get(instance, port);\r\n}\r\nreturn ret;\r\n}\r\nstatic int port_enable(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port)\r\n{\r\nunsigned int hdr_count;\r\nstruct list_head *buf_head;\r\nint ret;\r\nif (port->enabled)\r\nreturn 0;\r\nif (port->buffer_cb) {\r\nhdr_count = 0;\r\nlist_for_each(buf_head, &port->buffers) {\r\nhdr_count++;\r\n}\r\nif (hdr_count < port->current_buffer.num)\r\nreturn -ENOSPC;\r\n}\r\nret = port_action_port(instance, port,\r\nMMAL_MSG_PORT_ACTION_TYPE_ENABLE);\r\nif (ret)\r\ngoto done;\r\nport->enabled = true;\r\nif (port->buffer_cb) {\r\nhdr_count = 1;\r\nlist_for_each(buf_head, &port->buffers) {\r\nstruct mmal_buffer *mmalbuf;\r\nmmalbuf = list_entry(buf_head, struct mmal_buffer,\r\nlist);\r\nret = buffer_from_host(instance, port, mmalbuf);\r\nif (ret)\r\ngoto done;\r\nhdr_count++;\r\nif (hdr_count > port->current_buffer.num)\r\nbreak;\r\n}\r\n}\r\nret = port_info_get(instance, port);\r\ndone:\r\nreturn ret;\r\n}\r\nint vchiq_mmal_port_set_format(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&instance->vchiq_mutex))\r\nreturn -EINTR;\r\nret = port_info_set(instance, port);\r\nif (ret)\r\ngoto release_unlock;\r\nret = port_info_get(instance, port);\r\nrelease_unlock:\r\nmutex_unlock(&instance->vchiq_mutex);\r\nreturn ret;\r\n}\r\nint vchiq_mmal_port_parameter_set(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port,\r\nu32 parameter, void *value, u32 value_size)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&instance->vchiq_mutex))\r\nreturn -EINTR;\r\nret = port_parameter_set(instance, port, parameter, value, value_size);\r\nmutex_unlock(&instance->vchiq_mutex);\r\nreturn ret;\r\n}\r\nint vchiq_mmal_port_parameter_get(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port,\r\nu32 parameter, void *value, u32 *value_size)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&instance->vchiq_mutex))\r\nreturn -EINTR;\r\nret = port_parameter_get(instance, port, parameter, value, value_size);\r\nmutex_unlock(&instance->vchiq_mutex);\r\nreturn ret;\r\n}\r\nint vchiq_mmal_port_enable(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port,\r\nvchiq_mmal_buffer_cb buffer_cb)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&instance->vchiq_mutex))\r\nreturn -EINTR;\r\nif (port->enabled) {\r\nret = 0;\r\ngoto unlock;\r\n}\r\nport->buffer_cb = buffer_cb;\r\nret = port_enable(instance, port);\r\nunlock:\r\nmutex_unlock(&instance->vchiq_mutex);\r\nreturn ret;\r\n}\r\nint vchiq_mmal_port_disable(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&instance->vchiq_mutex))\r\nreturn -EINTR;\r\nif (!port->enabled) {\r\nmutex_unlock(&instance->vchiq_mutex);\r\nreturn 0;\r\n}\r\nret = port_disable(instance, port);\r\nmutex_unlock(&instance->vchiq_mutex);\r\nreturn ret;\r\n}\r\nint vchiq_mmal_port_connect_tunnel(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *src,\r\nstruct vchiq_mmal_port *dst)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&instance->vchiq_mutex))\r\nreturn -EINTR;\r\nif (src->connected) {\r\nret = port_disable(instance, src);\r\nif (ret) {\r\npr_err("failed disabling src port(%d)\n", ret);\r\ngoto release_unlock;\r\n}\r\nret = port_action_handle(instance, src,\r\nMMAL_MSG_PORT_ACTION_TYPE_DISCONNECT,\r\nsrc->connected->component->handle,\r\nsrc->connected->handle);\r\nif (ret < 0) {\r\npr_err("failed disconnecting src port\n");\r\ngoto release_unlock;\r\n}\r\nsrc->connected->enabled = false;\r\nsrc->connected = NULL;\r\n}\r\nif (!dst) {\r\nret = 0;\r\npr_debug("not making new connection\n");\r\ngoto release_unlock;\r\n}\r\ndst->format.encoding = src->format.encoding;\r\ndst->es.video.width = src->es.video.width;\r\ndst->es.video.height = src->es.video.height;\r\ndst->es.video.crop.x = src->es.video.crop.x;\r\ndst->es.video.crop.y = src->es.video.crop.y;\r\ndst->es.video.crop.width = src->es.video.crop.width;\r\ndst->es.video.crop.height = src->es.video.crop.height;\r\ndst->es.video.frame_rate.num = src->es.video.frame_rate.num;\r\ndst->es.video.frame_rate.den = src->es.video.frame_rate.den;\r\nret = port_info_set(instance, dst);\r\nif (ret) {\r\npr_debug("setting port info failed\n");\r\ngoto release_unlock;\r\n}\r\nret = port_info_get(instance, dst);\r\nif (ret) {\r\npr_debug("read back port info failed\n");\r\ngoto release_unlock;\r\n}\r\nret = port_action_handle(instance, src,\r\nMMAL_MSG_PORT_ACTION_TYPE_CONNECT,\r\ndst->component->handle, dst->handle);\r\nif (ret < 0) {\r\npr_debug("connecting port %d:%d to %d:%d failed\n",\r\nsrc->component->handle, src->handle,\r\ndst->component->handle, dst->handle);\r\ngoto release_unlock;\r\n}\r\nsrc->connected = dst;\r\nrelease_unlock:\r\nmutex_unlock(&instance->vchiq_mutex);\r\nreturn ret;\r\n}\r\nint vchiq_mmal_submit_buffer(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_port *port,\r\nstruct mmal_buffer *buffer)\r\n{\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&port->slock, flags);\r\nlist_add_tail(&buffer->list, &port->buffers);\r\nspin_unlock_irqrestore(&port->slock, flags);\r\nif (port->buffer_underflow) {\r\nport_buffer_from_host(instance, port);\r\nport->buffer_underflow--;\r\n}\r\nreturn 0;\r\n}\r\nint vchiq_mmal_component_init(struct vchiq_mmal_instance *instance,\r\nconst char *name,\r\nstruct vchiq_mmal_component **component_out)\r\n{\r\nint ret;\r\nint idx;\r\nstruct vchiq_mmal_component *component;\r\nif (mutex_lock_interruptible(&instance->vchiq_mutex))\r\nreturn -EINTR;\r\nif (instance->component_idx == VCHIQ_MMAL_MAX_COMPONENTS) {\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\ncomponent = &instance->component[instance->component_idx];\r\nret = create_component(instance, component, name);\r\nif (ret < 0)\r\ngoto unlock;\r\ncomponent->control.type = MMAL_PORT_TYPE_CONTROL;\r\ncomponent->control.index = 0;\r\ncomponent->control.component = component;\r\nspin_lock_init(&component->control.slock);\r\nINIT_LIST_HEAD(&component->control.buffers);\r\nret = port_info_get(instance, &component->control);\r\nif (ret < 0)\r\ngoto release_component;\r\nfor (idx = 0; idx < component->inputs; idx++) {\r\ncomponent->input[idx].type = MMAL_PORT_TYPE_INPUT;\r\ncomponent->input[idx].index = idx;\r\ncomponent->input[idx].component = component;\r\nspin_lock_init(&component->input[idx].slock);\r\nINIT_LIST_HEAD(&component->input[idx].buffers);\r\nret = port_info_get(instance, &component->input[idx]);\r\nif (ret < 0)\r\ngoto release_component;\r\n}\r\nfor (idx = 0; idx < component->outputs; idx++) {\r\ncomponent->output[idx].type = MMAL_PORT_TYPE_OUTPUT;\r\ncomponent->output[idx].index = idx;\r\ncomponent->output[idx].component = component;\r\nspin_lock_init(&component->output[idx].slock);\r\nINIT_LIST_HEAD(&component->output[idx].buffers);\r\nret = port_info_get(instance, &component->output[idx]);\r\nif (ret < 0)\r\ngoto release_component;\r\n}\r\nfor (idx = 0; idx < component->clocks; idx++) {\r\ncomponent->clock[idx].type = MMAL_PORT_TYPE_CLOCK;\r\ncomponent->clock[idx].index = idx;\r\ncomponent->clock[idx].component = component;\r\nspin_lock_init(&component->clock[idx].slock);\r\nINIT_LIST_HEAD(&component->clock[idx].buffers);\r\nret = port_info_get(instance, &component->clock[idx]);\r\nif (ret < 0)\r\ngoto release_component;\r\n}\r\ninstance->component_idx++;\r\n*component_out = component;\r\nmutex_unlock(&instance->vchiq_mutex);\r\nreturn 0;\r\nrelease_component:\r\ndestroy_component(instance, component);\r\nunlock:\r\nmutex_unlock(&instance->vchiq_mutex);\r\nreturn ret;\r\n}\r\nint vchiq_mmal_component_finalise(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_component *component)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&instance->vchiq_mutex))\r\nreturn -EINTR;\r\nif (component->enabled)\r\nret = disable_component(instance, component);\r\nret = destroy_component(instance, component);\r\nmutex_unlock(&instance->vchiq_mutex);\r\nreturn ret;\r\n}\r\nint vchiq_mmal_component_enable(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_component *component)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&instance->vchiq_mutex))\r\nreturn -EINTR;\r\nif (component->enabled) {\r\nmutex_unlock(&instance->vchiq_mutex);\r\nreturn 0;\r\n}\r\nret = enable_component(instance, component);\r\nif (ret == 0)\r\ncomponent->enabled = true;\r\nmutex_unlock(&instance->vchiq_mutex);\r\nreturn ret;\r\n}\r\nint vchiq_mmal_component_disable(struct vchiq_mmal_instance *instance,\r\nstruct vchiq_mmal_component *component)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&instance->vchiq_mutex))\r\nreturn -EINTR;\r\nif (!component->enabled) {\r\nmutex_unlock(&instance->vchiq_mutex);\r\nreturn 0;\r\n}\r\nret = disable_component(instance, component);\r\nif (ret == 0)\r\ncomponent->enabled = false;\r\nmutex_unlock(&instance->vchiq_mutex);\r\nreturn ret;\r\n}\r\nint vchiq_mmal_version(struct vchiq_mmal_instance *instance,\r\nu32 *major_out, u32 *minor_out)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&instance->vchiq_mutex))\r\nreturn -EINTR;\r\nret = get_version(instance, major_out, minor_out);\r\nmutex_unlock(&instance->vchiq_mutex);\r\nreturn ret;\r\n}\r\nint vchiq_mmal_finalise(struct vchiq_mmal_instance *instance)\r\n{\r\nint status = 0;\r\nif (!instance)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&instance->vchiq_mutex))\r\nreturn -EINTR;\r\nvchi_service_use(instance->handle);\r\nstatus = vchi_service_close(instance->handle);\r\nif (status != 0)\r\npr_err("mmal-vchiq: VCHIQ close failed");\r\nmutex_unlock(&instance->vchiq_mutex);\r\nvfree(instance->bulk_scratch);\r\nmmal_context_map_destroy(&instance->context_map);\r\nkfree(instance);\r\nreturn status;\r\n}\r\nint vchiq_mmal_init(struct vchiq_mmal_instance **out_instance)\r\n{\r\nint status;\r\nstruct vchiq_mmal_instance *instance;\r\nstatic VCHI_CONNECTION_T *vchi_connection;\r\nstatic VCHI_INSTANCE_T vchi_instance;\r\nSERVICE_CREATION_T params = {\r\n.version = VCHI_VERSION_EX(VC_MMAL_VER, VC_MMAL_MIN_VER),\r\n.service_id = VC_MMAL_SERVER_NAME,\r\n.connection = vchi_connection,\r\n.rx_fifo_size = 0,\r\n.tx_fifo_size = 0,\r\n.callback = service_callback,\r\n.callback_param = NULL,\r\n.want_unaligned_bulk_rx = 1,\r\n.want_unaligned_bulk_tx = 1,\r\n.want_crc = 0\r\n};\r\nBUILD_BUG_ON(sizeof(struct mmal_msg_header) != 24);\r\nBUILD_BUG_ON(sizeof(struct mmal_msg) > MMAL_MSG_MAX_SIZE);\r\nBUILD_BUG_ON(sizeof(struct mmal_port) != 64);\r\nstatus = vchi_initialise(&vchi_instance);\r\nif (status) {\r\npr_err("Failed to initialise VCHI instance (status=%d)\n",\r\nstatus);\r\nreturn -EIO;\r\n}\r\nstatus = vchi_connect(NULL, 0, vchi_instance);\r\nif (status) {\r\npr_err("Failed to connect VCHI instance (status=%d)\n", status);\r\nreturn -EIO;\r\n}\r\ninstance = kzalloc(sizeof(*instance), GFP_KERNEL);\r\nif (!instance)\r\nreturn -ENOMEM;\r\nmutex_init(&instance->vchiq_mutex);\r\nmutex_init(&instance->bulk_mutex);\r\ninstance->bulk_scratch = vmalloc(PAGE_SIZE);\r\nstatus = mmal_context_map_init(&instance->context_map);\r\nif (status) {\r\npr_err("Failed to init context map (status=%d)\n", status);\r\nkfree(instance);\r\nreturn status;\r\n}\r\nparams.callback_param = instance;\r\nstatus = vchi_service_open(vchi_instance, &params, &instance->handle);\r\nif (status) {\r\npr_err("Failed to open VCHI service connection (status=%d)\n",\r\nstatus);\r\ngoto err_close_services;\r\n}\r\nvchi_service_release(instance->handle);\r\n*out_instance = instance;\r\nreturn 0;\r\nerr_close_services:\r\nvchi_service_close(instance->handle);\r\nvfree(instance->bulk_scratch);\r\nkfree(instance);\r\nreturn -ENODEV;\r\n}
