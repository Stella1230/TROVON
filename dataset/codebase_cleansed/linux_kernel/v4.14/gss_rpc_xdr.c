static int gssx_enc_bool(struct xdr_stream *xdr, int v)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn -ENOSPC;\r\n*p = v ? xdr_one : xdr_zero;\r\nreturn 0;\r\n}\r\nstatic int gssx_dec_bool(struct xdr_stream *xdr, u32 *v)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn -ENOSPC;\r\n*v = be32_to_cpu(*p);\r\nreturn 0;\r\n}\r\nstatic int gssx_enc_buffer(struct xdr_stream *xdr,\r\nconst gssx_buffer *buf)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, sizeof(u32) + buf->len);\r\nif (!p)\r\nreturn -ENOSPC;\r\nxdr_encode_opaque(p, buf->data, buf->len);\r\nreturn 0;\r\n}\r\nstatic int gssx_enc_in_token(struct xdr_stream *xdr,\r\nconst struct gssp_in_token *in)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\nreturn -ENOSPC;\r\n*p = cpu_to_be32(in->page_len);\r\nxdr_write_pages(xdr, in->pages, in->page_base, in->page_len);\r\nreturn 0;\r\n}\r\nstatic int gssx_dec_buffer(struct xdr_stream *xdr,\r\ngssx_buffer *buf)\r\n{\r\nu32 length;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn -ENOSPC;\r\nlength = be32_to_cpup(p);\r\np = xdr_inline_decode(xdr, length);\r\nif (unlikely(p == NULL))\r\nreturn -ENOSPC;\r\nif (buf->len == 0) {\r\nreturn 0;\r\n}\r\nif (length > buf->len)\r\nreturn -ENOSPC;\r\nif (!buf->data) {\r\nbuf->data = kmemdup(p, length, GFP_KERNEL);\r\nif (!buf->data)\r\nreturn -ENOMEM;\r\n} else {\r\nmemcpy(buf->data, p, length);\r\n}\r\nbuf->len = length;\r\nreturn 0;\r\n}\r\nstatic int gssx_enc_option(struct xdr_stream *xdr,\r\nstruct gssx_option *opt)\r\n{\r\nint err;\r\nerr = gssx_enc_buffer(xdr, &opt->option);\r\nif (err)\r\nreturn err;\r\nerr = gssx_enc_buffer(xdr, &opt->value);\r\nreturn err;\r\n}\r\nstatic int gssx_dec_option(struct xdr_stream *xdr,\r\nstruct gssx_option *opt)\r\n{\r\nint err;\r\nerr = gssx_dec_buffer(xdr, &opt->option);\r\nif (err)\r\nreturn err;\r\nerr = gssx_dec_buffer(xdr, &opt->value);\r\nreturn err;\r\n}\r\nstatic int dummy_enc_opt_array(struct xdr_stream *xdr,\r\nconst struct gssx_option_array *oa)\r\n{\r\n__be32 *p;\r\nif (oa->count != 0)\r\nreturn -EINVAL;\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\nreturn -ENOSPC;\r\n*p = 0;\r\nreturn 0;\r\n}\r\nstatic int dummy_dec_opt_array(struct xdr_stream *xdr,\r\nstruct gssx_option_array *oa)\r\n{\r\nstruct gssx_option dummy;\r\nu32 count, i;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn -ENOSPC;\r\ncount = be32_to_cpup(p++);\r\nmemset(&dummy, 0, sizeof(dummy));\r\nfor (i = 0; i < count; i++) {\r\ngssx_dec_option(xdr, &dummy);\r\n}\r\noa->count = 0;\r\noa->data = NULL;\r\nreturn 0;\r\n}\r\nstatic int get_host_u32(struct xdr_stream *xdr, u32 *res)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (!p)\r\nreturn -EINVAL;\r\nmemcpy(res, p, sizeof(u32));\r\nreturn 0;\r\n}\r\nstatic int gssx_dec_linux_creds(struct xdr_stream *xdr,\r\nstruct svc_cred *creds)\r\n{\r\nu32 length;\r\n__be32 *p;\r\nu32 tmp;\r\nu32 N;\r\nint i, err;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn -ENOSPC;\r\nlength = be32_to_cpup(p);\r\nif (length > (3 + NGROUPS_MAX) * sizeof(u32))\r\nreturn -ENOSPC;\r\nerr = get_host_u32(xdr, &tmp);\r\nif (err)\r\nreturn err;\r\ncreds->cr_uid = make_kuid(&init_user_ns, tmp);\r\nerr = get_host_u32(xdr, &tmp);\r\nif (err)\r\nreturn err;\r\ncreds->cr_gid = make_kgid(&init_user_ns, tmp);\r\nerr = get_host_u32(xdr, &tmp);\r\nif (err)\r\nreturn err;\r\nN = tmp;\r\nif ((3 + N) * sizeof(u32) != length)\r\nreturn -EINVAL;\r\ncreds->cr_group_info = groups_alloc(N);\r\nif (creds->cr_group_info == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < N; i++) {\r\nkgid_t kgid;\r\nerr = get_host_u32(xdr, &tmp);\r\nif (err)\r\ngoto out_free_groups;\r\nerr = -EINVAL;\r\nkgid = make_kgid(&init_user_ns, tmp);\r\nif (!gid_valid(kgid))\r\ngoto out_free_groups;\r\ncreds->cr_group_info->gid[i] = kgid;\r\n}\r\nreturn 0;\r\nout_free_groups:\r\ngroups_free(creds->cr_group_info);\r\nreturn err;\r\n}\r\nstatic int gssx_dec_option_array(struct xdr_stream *xdr,\r\nstruct gssx_option_array *oa)\r\n{\r\nstruct svc_cred *creds;\r\nu32 count, i;\r\n__be32 *p;\r\nint err;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn -ENOSPC;\r\ncount = be32_to_cpup(p++);\r\nif (!count)\r\nreturn 0;\r\noa->count = 1;\r\noa->data = kmalloc(sizeof(struct gssx_option), GFP_KERNEL);\r\nif (!oa->data)\r\nreturn -ENOMEM;\r\ncreds = kzalloc(sizeof(struct svc_cred), GFP_KERNEL);\r\nif (!creds) {\r\nkfree(oa->data);\r\nreturn -ENOMEM;\r\n}\r\noa->data[0].option.data = CREDS_VALUE;\r\noa->data[0].option.len = sizeof(CREDS_VALUE);\r\noa->data[0].value.data = (void *)creds;\r\noa->data[0].value.len = 0;\r\nfor (i = 0; i < count; i++) {\r\ngssx_buffer dummy = { 0, NULL };\r\nu32 length;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn -ENOSPC;\r\nlength = be32_to_cpup(p);\r\np = xdr_inline_decode(xdr, length);\r\nif (unlikely(p == NULL))\r\nreturn -ENOSPC;\r\nif (length == sizeof(CREDS_VALUE) &&\r\nmemcmp(p, CREDS_VALUE, sizeof(CREDS_VALUE)) == 0) {\r\nerr = gssx_dec_linux_creds(xdr, creds);\r\nif (err)\r\nreturn err;\r\noa->data[0].value.len = 1;\r\n} else {\r\nerr = gssx_dec_buffer(xdr, &dummy);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int gssx_dec_status(struct xdr_stream *xdr,\r\nstruct gssx_status *status)\r\n{\r\n__be32 *p;\r\nint err;\r\np = xdr_inline_decode(xdr, 8);\r\nif (unlikely(p == NULL))\r\nreturn -ENOSPC;\r\np = xdr_decode_hyper(p, &status->major_status);\r\nerr = gssx_dec_buffer(xdr, &status->mech);\r\nif (err)\r\nreturn err;\r\np = xdr_inline_decode(xdr, 8);\r\nif (unlikely(p == NULL))\r\nreturn -ENOSPC;\r\np = xdr_decode_hyper(p, &status->minor_status);\r\nerr = gssx_dec_buffer(xdr, &status->major_status_string);\r\nif (err)\r\nreturn err;\r\nerr = gssx_dec_buffer(xdr, &status->minor_status_string);\r\nif (err)\r\nreturn err;\r\nerr = gssx_dec_buffer(xdr, &status->server_ctx);\r\nif (err)\r\nreturn err;\r\nerr = dummy_dec_opt_array(xdr, &status->options);\r\nreturn err;\r\n}\r\nstatic int gssx_enc_call_ctx(struct xdr_stream *xdr,\r\nconst struct gssx_call_ctx *ctx)\r\n{\r\nstruct gssx_option opt;\r\n__be32 *p;\r\nint err;\r\nerr = gssx_enc_buffer(xdr, &ctx->locale);\r\nif (err)\r\nreturn err;\r\nerr = gssx_enc_buffer(xdr, &ctx->server_ctx);\r\nif (err)\r\nreturn err;\r\np = xdr_reserve_space(xdr, 4);\r\n*p = cpu_to_be32(2);\r\nopt.option.data = LUCID_OPTION;\r\nopt.option.len = sizeof(LUCID_OPTION);\r\nopt.value.data = LUCID_VALUE;\r\nopt.value.len = sizeof(LUCID_VALUE);\r\nerr = gssx_enc_option(xdr, &opt);\r\nopt.option.data = CREDS_OPTION;\r\nopt.option.len = sizeof(CREDS_OPTION);\r\nopt.value.data = CREDS_VALUE;\r\nopt.value.len = sizeof(CREDS_VALUE);\r\nerr = gssx_enc_option(xdr, &opt);\r\nreturn err;\r\n}\r\nstatic int gssx_dec_name_attr(struct xdr_stream *xdr,\r\nstruct gssx_name_attr *attr)\r\n{\r\nint err;\r\nerr = gssx_dec_buffer(xdr, &attr->attr);\r\nif (err)\r\nreturn err;\r\nerr = gssx_dec_buffer(xdr, &attr->value);\r\nif (err)\r\nreturn err;\r\nerr = dummy_dec_opt_array(xdr, &attr->extensions);\r\nreturn err;\r\n}\r\nstatic int dummy_enc_nameattr_array(struct xdr_stream *xdr,\r\nstruct gssx_name_attr_array *naa)\r\n{\r\n__be32 *p;\r\nif (naa->count != 0)\r\nreturn -EINVAL;\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\nreturn -ENOSPC;\r\n*p = 0;\r\nreturn 0;\r\n}\r\nstatic int dummy_dec_nameattr_array(struct xdr_stream *xdr,\r\nstruct gssx_name_attr_array *naa)\r\n{\r\nstruct gssx_name_attr dummy = { .attr = {.len = 0} };\r\nu32 count, i;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn -ENOSPC;\r\ncount = be32_to_cpup(p++);\r\nfor (i = 0; i < count; i++) {\r\ngssx_dec_name_attr(xdr, &dummy);\r\n}\r\nnaa->count = 0;\r\nnaa->data = NULL;\r\nreturn 0;\r\n}\r\nstatic int gssx_enc_name(struct xdr_stream *xdr,\r\nstruct gssx_name *name)\r\n{\r\nint err;\r\nerr = gssx_enc_buffer(xdr, &name->display_name);\r\nif (err)\r\nreturn err;\r\nerr = gssx_enc_buffer(xdr, &zero_netobj);\r\nif (err)\r\nreturn err;\r\nerr = gssx_enc_buffer(xdr, &zero_netobj);\r\nif (err)\r\nreturn err;\r\nerr = gssx_enc_buffer(xdr, &zero_netobj);\r\nif (err)\r\nreturn err;\r\nerr = dummy_enc_nameattr_array(xdr, &zero_name_attr_array);\r\nif (err)\r\nreturn err;\r\nerr = dummy_enc_opt_array(xdr, &zero_option_array);\r\nreturn err;\r\n}\r\nstatic int gssx_dec_name(struct xdr_stream *xdr,\r\nstruct gssx_name *name)\r\n{\r\nstruct xdr_netobj dummy_netobj = { .len = 0 };\r\nstruct gssx_name_attr_array dummy_name_attr_array = { .count = 0 };\r\nstruct gssx_option_array dummy_option_array = { .count = 0 };\r\nint err;\r\nerr = gssx_dec_buffer(xdr, &name->display_name);\r\nif (err)\r\nreturn err;\r\nerr = gssx_dec_buffer(xdr, &dummy_netobj);\r\nif (err)\r\nreturn err;\r\nerr = gssx_dec_buffer(xdr, &dummy_netobj);\r\nif (err)\r\nreturn err;\r\nerr = gssx_dec_buffer(xdr, &dummy_netobj);\r\nif (err)\r\nreturn err;\r\nerr = dummy_dec_nameattr_array(xdr, &dummy_name_attr_array);\r\nif (err)\r\nreturn err;\r\nerr = dummy_dec_opt_array(xdr, &dummy_option_array);\r\nreturn err;\r\n}\r\nstatic int dummy_enc_credel_array(struct xdr_stream *xdr,\r\nstruct gssx_cred_element_array *cea)\r\n{\r\n__be32 *p;\r\nif (cea->count != 0)\r\nreturn -EINVAL;\r\np = xdr_reserve_space(xdr, 4);\r\nif (!p)\r\nreturn -ENOSPC;\r\n*p = 0;\r\nreturn 0;\r\n}\r\nstatic int gssx_enc_cred(struct xdr_stream *xdr,\r\nstruct gssx_cred *cred)\r\n{\r\nint err;\r\nerr = gssx_enc_name(xdr, &cred->desired_name);\r\nif (err)\r\nreturn err;\r\nerr = dummy_enc_credel_array(xdr, &cred->elements);\r\nif (err)\r\nreturn err;\r\nerr = gssx_enc_buffer(xdr, &cred->cred_handle_reference);\r\nif (err)\r\nreturn err;\r\nerr = gssx_enc_bool(xdr, cred->needs_release);\r\nreturn err;\r\n}\r\nstatic int gssx_enc_ctx(struct xdr_stream *xdr,\r\nstruct gssx_ctx *ctx)\r\n{\r\n__be32 *p;\r\nint err;\r\nerr = gssx_enc_buffer(xdr, &ctx->exported_context_token);\r\nif (err)\r\nreturn err;\r\nerr = gssx_enc_buffer(xdr, &ctx->state);\r\nif (err)\r\nreturn err;\r\nerr = gssx_enc_bool(xdr, ctx->need_release);\r\nif (err)\r\nreturn err;\r\nerr = gssx_enc_buffer(xdr, &ctx->mech);\r\nif (err)\r\nreturn err;\r\nerr = gssx_enc_name(xdr, &ctx->src_name);\r\nif (err)\r\nreturn err;\r\nerr = gssx_enc_name(xdr, &ctx->targ_name);\r\nif (err)\r\nreturn err;\r\np = xdr_reserve_space(xdr, 8+8);\r\nif (!p)\r\nreturn -ENOSPC;\r\np = xdr_encode_hyper(p, ctx->lifetime);\r\np = xdr_encode_hyper(p, ctx->ctx_flags);\r\nerr = gssx_enc_bool(xdr, ctx->locally_initiated);\r\nif (err)\r\nreturn err;\r\nerr = gssx_enc_bool(xdr, ctx->open);\r\nif (err)\r\nreturn err;\r\nerr = dummy_enc_opt_array(xdr, &ctx->options);\r\nreturn err;\r\n}\r\nstatic int gssx_dec_ctx(struct xdr_stream *xdr,\r\nstruct gssx_ctx *ctx)\r\n{\r\n__be32 *p;\r\nint err;\r\nerr = gssx_dec_buffer(xdr, &ctx->exported_context_token);\r\nif (err)\r\nreturn err;\r\nerr = gssx_dec_buffer(xdr, &ctx->state);\r\nif (err)\r\nreturn err;\r\nerr = gssx_dec_bool(xdr, &ctx->need_release);\r\nif (err)\r\nreturn err;\r\nerr = gssx_dec_buffer(xdr, &ctx->mech);\r\nif (err)\r\nreturn err;\r\nerr = gssx_dec_name(xdr, &ctx->src_name);\r\nif (err)\r\nreturn err;\r\nerr = gssx_dec_name(xdr, &ctx->targ_name);\r\nif (err)\r\nreturn err;\r\np = xdr_inline_decode(xdr, 8+8);\r\nif (unlikely(p == NULL))\r\nreturn -ENOSPC;\r\np = xdr_decode_hyper(p, &ctx->lifetime);\r\np = xdr_decode_hyper(p, &ctx->ctx_flags);\r\nerr = gssx_dec_bool(xdr, &ctx->locally_initiated);\r\nif (err)\r\nreturn err;\r\nerr = gssx_dec_bool(xdr, &ctx->open);\r\nif (err)\r\nreturn err;\r\nerr = dummy_dec_opt_array(xdr, &ctx->options);\r\nreturn err;\r\n}\r\nstatic int gssx_enc_cb(struct xdr_stream *xdr, struct gssx_cb *cb)\r\n{\r\n__be32 *p;\r\nint err;\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\nreturn -ENOSPC;\r\np = xdr_encode_hyper(p, cb->initiator_addrtype);\r\nerr = gssx_enc_buffer(xdr, &cb->initiator_address);\r\nif (err)\r\nreturn err;\r\np = xdr_reserve_space(xdr, 8);\r\nif (!p)\r\nreturn -ENOSPC;\r\np = xdr_encode_hyper(p, cb->acceptor_addrtype);\r\nerr = gssx_enc_buffer(xdr, &cb->acceptor_address);\r\nif (err)\r\nreturn err;\r\nerr = gssx_enc_buffer(xdr, &cb->application_data);\r\nreturn err;\r\n}\r\nvoid gssx_enc_accept_sec_context(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst void *data)\r\n{\r\nconst struct gssx_arg_accept_sec_context *arg = data;\r\nint err;\r\nerr = gssx_enc_call_ctx(xdr, &arg->call_ctx);\r\nif (err)\r\ngoto done;\r\nif (arg->context_handle)\r\nerr = gssx_enc_ctx(xdr, arg->context_handle);\r\nelse\r\nerr = gssx_enc_bool(xdr, 0);\r\nif (err)\r\ngoto done;\r\nif (arg->cred_handle)\r\nerr = gssx_enc_cred(xdr, arg->cred_handle);\r\nelse\r\nerr = gssx_enc_bool(xdr, 0);\r\nif (err)\r\ngoto done;\r\nerr = gssx_enc_in_token(xdr, &arg->input_token);\r\nif (err)\r\ngoto done;\r\nif (arg->input_cb)\r\nerr = gssx_enc_cb(xdr, arg->input_cb);\r\nelse\r\nerr = gssx_enc_bool(xdr, 0);\r\nif (err)\r\ngoto done;\r\nerr = gssx_enc_bool(xdr, arg->ret_deleg_cred);\r\nif (err)\r\ngoto done;\r\nerr = dummy_enc_opt_array(xdr, &arg->options);\r\nxdr_inline_pages(&req->rq_rcv_buf,\r\nPAGE_SIZE/2 ,\r\narg->pages, 0 , arg->npages * PAGE_SIZE);\r\ndone:\r\nif (err)\r\ndprintk("RPC: gssx_enc_accept_sec_context: %d\n", err);\r\n}\r\nint gssx_dec_accept_sec_context(struct rpc_rqst *rqstp,\r\nstruct xdr_stream *xdr,\r\nvoid *data)\r\n{\r\nstruct gssx_res_accept_sec_context *res = data;\r\nu32 value_follows;\r\nint err;\r\nstruct page *scratch;\r\nscratch = alloc_page(GFP_KERNEL);\r\nif (!scratch)\r\nreturn -ENOMEM;\r\nxdr_set_scratch_buffer(xdr, page_address(scratch), PAGE_SIZE);\r\nerr = gssx_dec_status(xdr, &res->status);\r\nif (err)\r\ngoto out_free;\r\nerr = gssx_dec_bool(xdr, &value_follows);\r\nif (err)\r\ngoto out_free;\r\nif (value_follows) {\r\nerr = gssx_dec_ctx(xdr, res->context_handle);\r\nif (err)\r\ngoto out_free;\r\n} else {\r\nres->context_handle = NULL;\r\n}\r\nerr = gssx_dec_bool(xdr, &value_follows);\r\nif (err)\r\ngoto out_free;\r\nif (value_follows) {\r\nerr = gssx_dec_buffer(xdr, res->output_token);\r\nif (err)\r\ngoto out_free;\r\n} else {\r\nres->output_token = NULL;\r\n}\r\nerr = gssx_dec_bool(xdr, &value_follows);\r\nif (err)\r\ngoto out_free;\r\nif (value_follows) {\r\nerr = -EINVAL;\r\ngoto out_free;\r\n}\r\nerr = gssx_dec_option_array(xdr, &res->options);\r\nout_free:\r\n__free_page(scratch);\r\nreturn err;\r\n}
