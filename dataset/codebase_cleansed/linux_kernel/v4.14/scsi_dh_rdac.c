static unsigned int rdac_failover_get(struct rdac_controller *ctlr,\r\nstruct list_head *list,\r\nunsigned char *cdb)\r\n{\r\nstruct rdac_mode_common *common;\r\nunsigned data_size;\r\nstruct rdac_queue_data *qdata;\r\nu8 *lun_table;\r\nif (ctlr->use_ms10) {\r\nstruct rdac_pg_expanded *rdac_pg;\r\ndata_size = sizeof(struct rdac_pg_expanded);\r\nrdac_pg = &ctlr->mode_select.expanded;\r\nmemset(rdac_pg, 0, data_size);\r\ncommon = &rdac_pg->common;\r\nrdac_pg->page_code = RDAC_PAGE_CODE_REDUNDANT_CONTROLLER + 0x40;\r\nrdac_pg->subpage_code = 0x1;\r\nrdac_pg->page_len[0] = 0x01;\r\nrdac_pg->page_len[1] = 0x28;\r\nlun_table = rdac_pg->lun_table;\r\n} else {\r\nstruct rdac_pg_legacy *rdac_pg;\r\ndata_size = sizeof(struct rdac_pg_legacy);\r\nrdac_pg = &ctlr->mode_select.legacy;\r\nmemset(rdac_pg, 0, data_size);\r\ncommon = &rdac_pg->common;\r\nrdac_pg->page_code = RDAC_PAGE_CODE_REDUNDANT_CONTROLLER;\r\nrdac_pg->page_len = 0x68;\r\nlun_table = rdac_pg->lun_table;\r\n}\r\ncommon->rdac_mode[1] = RDAC_MODE_TRANSFER_SPECIFIED_LUNS;\r\ncommon->quiescence_timeout = RDAC_QUIESCENCE_TIME;\r\ncommon->rdac_options = RDAC_FORCED_QUIESENCE;\r\nlist_for_each_entry(qdata, list, entry) {\r\nlun_table[qdata->h->lun] = 0x81;\r\n}\r\nif (ctlr->use_ms10) {\r\ncdb[0] = MODE_SELECT_10;\r\ncdb[7] = data_size >> 8;\r\ncdb[8] = data_size & 0xff;\r\n} else {\r\ncdb[0] = MODE_SELECT;\r\ncdb[4] = data_size;\r\n}\r\nreturn data_size;\r\n}\r\nstatic void release_controller(struct kref *kref)\r\n{\r\nstruct rdac_controller *ctlr;\r\nctlr = container_of(kref, struct rdac_controller, kref);\r\nlist_del(&ctlr->node);\r\nkfree(ctlr);\r\n}\r\nstatic struct rdac_controller *get_controller(int index, char *array_name,\r\nu8 *array_id, struct scsi_device *sdev)\r\n{\r\nstruct rdac_controller *ctlr, *tmp;\r\nlist_for_each_entry(tmp, &ctlr_list, node) {\r\nif ((memcmp(tmp->array_id, array_id, UNIQUE_ID_LEN) == 0) &&\r\n(tmp->index == index) &&\r\n(tmp->host == sdev->host)) {\r\nkref_get(&tmp->kref);\r\nreturn tmp;\r\n}\r\n}\r\nctlr = kmalloc(sizeof(*ctlr), GFP_ATOMIC);\r\nif (!ctlr)\r\nreturn NULL;\r\nmemcpy(ctlr->array_id, array_id, UNIQUE_ID_LEN);\r\nctlr->index = index;\r\nctlr->host = sdev->host;\r\nmemcpy(ctlr->array_name, array_name, ARRAY_LABEL_LEN);\r\nkref_init(&ctlr->kref);\r\nctlr->use_ms10 = -1;\r\nctlr->ms_queued = 0;\r\nctlr->ms_sdev = NULL;\r\nspin_lock_init(&ctlr->ms_lock);\r\nINIT_WORK(&ctlr->ms_work, send_mode_select);\r\nINIT_LIST_HEAD(&ctlr->ms_head);\r\nlist_add(&ctlr->node, &ctlr_list);\r\nINIT_LIST_HEAD(&ctlr->dh_list);\r\nreturn ctlr;\r\n}\r\nstatic int get_lun_info(struct scsi_device *sdev, struct rdac_dh_data *h,\r\nchar *array_name, u8 *array_id)\r\n{\r\nint err = SCSI_DH_IO, i;\r\nstruct c8_inquiry *inqp = &h->inq.c8;\r\nif (!scsi_get_vpd_page(sdev, 0xC8, (unsigned char *)inqp,\r\nsizeof(struct c8_inquiry))) {\r\nif (inqp->page_code != 0xc8)\r\nreturn SCSI_DH_NOSYS;\r\nif (inqp->page_id[0] != 'e' || inqp->page_id[1] != 'd' ||\r\ninqp->page_id[2] != 'i' || inqp->page_id[3] != 'd')\r\nreturn SCSI_DH_NOSYS;\r\nh->lun = inqp->lun[7];\r\nfor(i=0; i<ARRAY_LABEL_LEN-1; ++i)\r\n*(array_name+i) = inqp->array_user_label[(2*i)+1];\r\n*(array_name+ARRAY_LABEL_LEN-1) = '\0';\r\nmemset(array_id, 0, UNIQUE_ID_LEN);\r\nmemcpy(array_id, inqp->array_unique_id, inqp->array_uniq_id_len);\r\nerr = SCSI_DH_OK;\r\n}\r\nreturn err;\r\n}\r\nstatic int check_ownership(struct scsi_device *sdev, struct rdac_dh_data *h)\r\n{\r\nint err = SCSI_DH_IO, access_state;\r\nstruct rdac_dh_data *tmp;\r\nstruct c9_inquiry *inqp = &h->inq.c9;\r\nh->state = RDAC_STATE_ACTIVE;\r\nif (!scsi_get_vpd_page(sdev, 0xC9, (unsigned char *)inqp,\r\nsizeof(struct c9_inquiry))) {\r\nif ((inqp->avte_cvp >> 5) & 0x1)\r\nh->mode = RDAC_MODE_IOSHIP;\r\nelse if (inqp->avte_cvp >> 7)\r\nh->mode = RDAC_MODE_AVT;\r\nelse\r\nh->mode = RDAC_MODE;\r\nif (inqp->avte_cvp & 0x1) {\r\nh->lun_state = RDAC_LUN_OWNED;\r\naccess_state = SCSI_ACCESS_STATE_OPTIMAL;\r\n} else {\r\nh->lun_state = RDAC_LUN_UNOWNED;\r\nif (h->mode == RDAC_MODE) {\r\nh->state = RDAC_STATE_PASSIVE;\r\naccess_state = SCSI_ACCESS_STATE_STANDBY;\r\n} else\r\naccess_state = SCSI_ACCESS_STATE_ACTIVE;\r\n}\r\nif (inqp->path_prio & 0x1) {\r\nh->preferred = RDAC_PREFERRED;\r\naccess_state |= SCSI_ACCESS_STATE_PREFERRED;\r\n} else\r\nh->preferred = RDAC_NON_PREFERRED;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(tmp, &h->ctlr->dh_list, node) {\r\nBUG_ON(!tmp->sdev);\r\ntmp->sdev->access_state = access_state;\r\n}\r\nrcu_read_unlock();\r\nerr = SCSI_DH_OK;\r\n}\r\nreturn err;\r\n}\r\nstatic int initialize_controller(struct scsi_device *sdev,\r\nstruct rdac_dh_data *h, char *array_name, u8 *array_id)\r\n{\r\nint err = SCSI_DH_IO, index;\r\nstruct c4_inquiry *inqp = &h->inq.c4;\r\nif (!scsi_get_vpd_page(sdev, 0xC4, (unsigned char *)inqp,\r\nsizeof(struct c4_inquiry))) {\r\nif (inqp->slot_id[1] == 0x31)\r\nindex = 0;\r\nelse\r\nindex = 1;\r\nspin_lock(&list_lock);\r\nh->ctlr = get_controller(index, array_name, array_id, sdev);\r\nif (!h->ctlr)\r\nerr = SCSI_DH_RES_TEMP_UNAVAIL;\r\nelse {\r\nlist_add_rcu(&h->node, &h->ctlr->dh_list);\r\nh->sdev = sdev;\r\n}\r\nspin_unlock(&list_lock);\r\nerr = SCSI_DH_OK;\r\n}\r\nreturn err;\r\n}\r\nstatic int set_mode_select(struct scsi_device *sdev, struct rdac_dh_data *h)\r\n{\r\nint err = SCSI_DH_IO;\r\nstruct c2_inquiry *inqp = &h->inq.c2;\r\nif (!scsi_get_vpd_page(sdev, 0xC2, (unsigned char *)inqp,\r\nsizeof(struct c2_inquiry))) {\r\nif (inqp->max_lun_supported >= MODE6_MAX_LUN)\r\nh->ctlr->use_ms10 = 1;\r\nelse\r\nh->ctlr->use_ms10 = 0;\r\nerr = SCSI_DH_OK;\r\n}\r\nreturn err;\r\n}\r\nstatic int mode_select_handle_sense(struct scsi_device *sdev,\r\nstruct scsi_sense_hdr *sense_hdr)\r\n{\r\nint err = SCSI_DH_IO;\r\nstruct rdac_dh_data *h = sdev->handler_data;\r\nif (!scsi_sense_valid(sense_hdr))\r\ngoto done;\r\nswitch (sense_hdr->sense_key) {\r\ncase NO_SENSE:\r\ncase ABORTED_COMMAND:\r\ncase UNIT_ATTENTION:\r\nerr = SCSI_DH_RETRY;\r\nbreak;\r\ncase NOT_READY:\r\nif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x01)\r\nerr = SCSI_DH_RETRY;\r\nbreak;\r\ncase ILLEGAL_REQUEST:\r\nif (sense_hdr->asc == 0x91 && sense_hdr->ascq == 0x36)\r\nerr = SCSI_DH_IMM_RETRY;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nRDAC_LOG(RDAC_LOG_FAILOVER, sdev, "array %s, ctlr %d, "\r\n"MODE_SELECT returned with sense %02x/%02x/%02x",\r\n(char *) h->ctlr->array_name, h->ctlr->index,\r\nsense_hdr->sense_key, sense_hdr->asc, sense_hdr->ascq);\r\ndone:\r\nreturn err;\r\n}\r\nstatic void send_mode_select(struct work_struct *work)\r\n{\r\nstruct rdac_controller *ctlr =\r\ncontainer_of(work, struct rdac_controller, ms_work);\r\nstruct scsi_device *sdev = ctlr->ms_sdev;\r\nstruct rdac_dh_data *h = sdev->handler_data;\r\nint err = SCSI_DH_OK, retry_cnt = RDAC_RETRY_COUNT;\r\nstruct rdac_queue_data *tmp, *qdata;\r\nLIST_HEAD(list);\r\nunsigned char cdb[COMMAND_SIZE(MODE_SELECT_10)];\r\nstruct scsi_sense_hdr sshdr;\r\nunsigned int data_size;\r\nu64 req_flags = REQ_FAILFAST_DEV | REQ_FAILFAST_TRANSPORT |\r\nREQ_FAILFAST_DRIVER;\r\nspin_lock(&ctlr->ms_lock);\r\nlist_splice_init(&ctlr->ms_head, &list);\r\nctlr->ms_queued = 0;\r\nctlr->ms_sdev = NULL;\r\nspin_unlock(&ctlr->ms_lock);\r\nretry:\r\ndata_size = rdac_failover_get(ctlr, &list, cdb);\r\nRDAC_LOG(RDAC_LOG_FAILOVER, sdev, "array %s, ctlr %d, "\r\n"%s MODE_SELECT command",\r\n(char *) h->ctlr->array_name, h->ctlr->index,\r\n(retry_cnt == RDAC_RETRY_COUNT) ? "queueing" : "retrying");\r\nif (scsi_execute(sdev, cdb, DMA_TO_DEVICE, &h->ctlr->mode_select,\r\ndata_size, NULL, &sshdr, RDAC_TIMEOUT * HZ,\r\nRDAC_RETRIES, req_flags, 0, NULL)) {\r\nerr = mode_select_handle_sense(sdev, &sshdr);\r\nif (err == SCSI_DH_RETRY && retry_cnt--)\r\ngoto retry;\r\nif (err == SCSI_DH_IMM_RETRY)\r\ngoto retry;\r\n}\r\nif (err == SCSI_DH_OK) {\r\nh->state = RDAC_STATE_ACTIVE;\r\nRDAC_LOG(RDAC_LOG_FAILOVER, sdev, "array %s, ctlr %d, "\r\n"MODE_SELECT completed",\r\n(char *) h->ctlr->array_name, h->ctlr->index);\r\n}\r\nlist_for_each_entry_safe(qdata, tmp, &list, entry) {\r\nlist_del(&qdata->entry);\r\nif (err == SCSI_DH_OK)\r\nqdata->h->state = RDAC_STATE_ACTIVE;\r\nif (qdata->callback_fn)\r\nqdata->callback_fn(qdata->callback_data, err);\r\nkfree(qdata);\r\n}\r\nreturn;\r\n}\r\nstatic int queue_mode_select(struct scsi_device *sdev,\r\nactivate_complete fn, void *data)\r\n{\r\nstruct rdac_queue_data *qdata;\r\nstruct rdac_controller *ctlr;\r\nqdata = kzalloc(sizeof(*qdata), GFP_KERNEL);\r\nif (!qdata)\r\nreturn SCSI_DH_RETRY;\r\nqdata->h = sdev->handler_data;\r\nqdata->callback_fn = fn;\r\nqdata->callback_data = data;\r\nctlr = qdata->h->ctlr;\r\nspin_lock(&ctlr->ms_lock);\r\nlist_add_tail(&qdata->entry, &ctlr->ms_head);\r\nif (!ctlr->ms_queued) {\r\nctlr->ms_queued = 1;\r\nctlr->ms_sdev = sdev;\r\nqueue_work(kmpath_rdacd, &ctlr->ms_work);\r\n}\r\nspin_unlock(&ctlr->ms_lock);\r\nreturn SCSI_DH_OK;\r\n}\r\nstatic int rdac_activate(struct scsi_device *sdev,\r\nactivate_complete fn, void *data)\r\n{\r\nstruct rdac_dh_data *h = sdev->handler_data;\r\nint err = SCSI_DH_OK;\r\nint act = 0;\r\nerr = check_ownership(sdev, h);\r\nif (err != SCSI_DH_OK)\r\ngoto done;\r\nswitch (h->mode) {\r\ncase RDAC_MODE:\r\nif (h->lun_state == RDAC_LUN_UNOWNED)\r\nact = 1;\r\nbreak;\r\ncase RDAC_MODE_IOSHIP:\r\nif ((h->lun_state == RDAC_LUN_UNOWNED) &&\r\n(h->preferred == RDAC_PREFERRED))\r\nact = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (act) {\r\nerr = queue_mode_select(sdev, fn, data);\r\nif (err == SCSI_DH_OK)\r\nreturn 0;\r\n}\r\ndone:\r\nif (fn)\r\nfn(data, err);\r\nreturn 0;\r\n}\r\nstatic int rdac_prep_fn(struct scsi_device *sdev, struct request *req)\r\n{\r\nstruct rdac_dh_data *h = sdev->handler_data;\r\nint ret = BLKPREP_OK;\r\nif (h->state != RDAC_STATE_ACTIVE) {\r\nret = BLKPREP_KILL;\r\nreq->rq_flags |= RQF_QUIET;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rdac_check_sense(struct scsi_device *sdev,\r\nstruct scsi_sense_hdr *sense_hdr)\r\n{\r\nstruct rdac_dh_data *h = sdev->handler_data;\r\nRDAC_LOG(RDAC_LOG_SENSE, sdev, "array %s, ctlr %d, "\r\n"I/O returned with sense %02x/%02x/%02x",\r\n(char *) h->ctlr->array_name, h->ctlr->index,\r\nsense_hdr->sense_key, sense_hdr->asc, sense_hdr->ascq);\r\nswitch (sense_hdr->sense_key) {\r\ncase NOT_READY:\r\nif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x01)\r\nreturn ADD_TO_MLQUEUE;\r\nif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x81)\r\nreturn SUCCESS;\r\nif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0xA1)\r\nreturn ADD_TO_MLQUEUE;\r\nif (sense_hdr->asc == 0xA1 && sense_hdr->ascq == 0x02)\r\nreturn ADD_TO_MLQUEUE;\r\nbreak;\r\ncase ILLEGAL_REQUEST:\r\nif (sense_hdr->asc == 0x94 && sense_hdr->ascq == 0x01) {\r\nh->state = RDAC_STATE_PASSIVE;\r\nreturn SUCCESS;\r\n}\r\nbreak;\r\ncase UNIT_ATTENTION:\r\nif (sense_hdr->asc == 0x29 && sense_hdr->ascq == 0x00)\r\nreturn ADD_TO_MLQUEUE;\r\nif (sense_hdr->asc == 0x8b && sense_hdr->ascq == 0x02)\r\nreturn ADD_TO_MLQUEUE;\r\nbreak;\r\n}\r\nreturn SCSI_RETURN_NOT_HANDLED;\r\n}\r\nstatic int rdac_bus_attach(struct scsi_device *sdev)\r\n{\r\nstruct rdac_dh_data *h;\r\nint err;\r\nchar array_name[ARRAY_LABEL_LEN];\r\nchar array_id[UNIQUE_ID_LEN];\r\nh = kzalloc(sizeof(*h) , GFP_KERNEL);\r\nif (!h)\r\nreturn -ENOMEM;\r\nh->lun = UNINITIALIZED_LUN;\r\nh->state = RDAC_STATE_ACTIVE;\r\nerr = get_lun_info(sdev, h, array_name, array_id);\r\nif (err != SCSI_DH_OK)\r\ngoto failed;\r\nerr = initialize_controller(sdev, h, array_name, array_id);\r\nif (err != SCSI_DH_OK)\r\ngoto failed;\r\nerr = check_ownership(sdev, h);\r\nif (err != SCSI_DH_OK)\r\ngoto clean_ctlr;\r\nerr = set_mode_select(sdev, h);\r\nif (err != SCSI_DH_OK)\r\ngoto clean_ctlr;\r\nsdev_printk(KERN_NOTICE, sdev,\r\n"%s: LUN %d (%s) (%s)\n",\r\nRDAC_NAME, h->lun, mode[(int)h->mode],\r\nlun_state[(int)h->lun_state]);\r\nsdev->handler_data = h;\r\nreturn 0;\r\nclean_ctlr:\r\nspin_lock(&list_lock);\r\nkref_put(&h->ctlr->kref, release_controller);\r\nspin_unlock(&list_lock);\r\nfailed:\r\nkfree(h);\r\nreturn -EINVAL;\r\n}\r\nstatic void rdac_bus_detach( struct scsi_device *sdev )\r\n{\r\nstruct rdac_dh_data *h = sdev->handler_data;\r\nif (h->ctlr && h->ctlr->ms_queued)\r\nflush_workqueue(kmpath_rdacd);\r\nspin_lock(&list_lock);\r\nif (h->ctlr) {\r\nlist_del_rcu(&h->node);\r\nh->sdev = NULL;\r\nkref_put(&h->ctlr->kref, release_controller);\r\n}\r\nspin_unlock(&list_lock);\r\nsdev->handler_data = NULL;\r\nkfree(h);\r\n}\r\nstatic int __init rdac_init(void)\r\n{\r\nint r;\r\nr = scsi_register_device_handler(&rdac_dh);\r\nif (r != 0) {\r\nprintk(KERN_ERR "Failed to register scsi device handler.");\r\ngoto done;\r\n}\r\nkmpath_rdacd = create_singlethread_workqueue("kmpath_rdacd");\r\nif (!kmpath_rdacd) {\r\nscsi_unregister_device_handler(&rdac_dh);\r\nprintk(KERN_ERR "kmpath_rdacd creation failed.\n");\r\nr = -EINVAL;\r\n}\r\ndone:\r\nreturn r;\r\n}\r\nstatic void __exit rdac_exit(void)\r\n{\r\ndestroy_workqueue(kmpath_rdacd);\r\nscsi_unregister_device_handler(&rdac_dh);\r\n}
