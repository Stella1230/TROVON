static void sxgbe_verify_args(void)\r\n{\r\nif (unlikely(eee_timer < 0))\r\neee_timer = SXGBE_DEFAULT_LPI_TIMER;\r\n}\r\nstatic void sxgbe_enable_eee_mode(const struct sxgbe_priv_data *priv)\r\n{\r\nif (!priv->tx_path_in_lpi_mode)\r\npriv->hw->mac->set_eee_mode(priv->ioaddr);\r\n}\r\nvoid sxgbe_disable_eee_mode(struct sxgbe_priv_data * const priv)\r\n{\r\npriv->hw->mac->reset_eee_mode(priv->ioaddr);\r\ndel_timer_sync(&priv->eee_ctrl_timer);\r\npriv->tx_path_in_lpi_mode = false;\r\n}\r\nstatic void sxgbe_eee_ctrl_timer(unsigned long arg)\r\n{\r\nstruct sxgbe_priv_data *priv = (struct sxgbe_priv_data *)arg;\r\nsxgbe_enable_eee_mode(priv);\r\nmod_timer(&priv->eee_ctrl_timer, SXGBE_LPI_TIMER(eee_timer));\r\n}\r\nbool sxgbe_eee_init(struct sxgbe_priv_data * const priv)\r\n{\r\nstruct net_device *ndev = priv->dev;\r\nbool ret = false;\r\nif (priv->hw_cap.eee) {\r\nif (phy_init_eee(ndev->phydev, 1))\r\nreturn false;\r\npriv->eee_active = 1;\r\nsetup_timer(&priv->eee_ctrl_timer, sxgbe_eee_ctrl_timer,\r\n(unsigned long)priv);\r\npriv->eee_ctrl_timer.expires = SXGBE_LPI_TIMER(eee_timer);\r\nadd_timer(&priv->eee_ctrl_timer);\r\npriv->hw->mac->set_eee_timer(priv->ioaddr,\r\nSXGBE_DEFAULT_LPI_TIMER,\r\npriv->tx_lpi_timer);\r\npr_info("Energy-Efficient Ethernet initialized\n");\r\nret = true;\r\n}\r\nreturn ret;\r\n}\r\nstatic void sxgbe_eee_adjust(const struct sxgbe_priv_data *priv)\r\n{\r\nstruct net_device *ndev = priv->dev;\r\nif (priv->eee_enabled)\r\npriv->hw->mac->set_eee_pls(priv->ioaddr, ndev->phydev->link);\r\n}\r\nstatic void sxgbe_clk_csr_set(struct sxgbe_priv_data *priv)\r\n{\r\nu32 clk_rate = clk_get_rate(priv->sxgbe_clk);\r\nif (clk_rate < SXGBE_CSR_F_150M)\r\npriv->clk_csr = SXGBE_CSR_100_150M;\r\nelse if (clk_rate <= SXGBE_CSR_F_250M)\r\npriv->clk_csr = SXGBE_CSR_150_250M;\r\nelse if (clk_rate <= SXGBE_CSR_F_300M)\r\npriv->clk_csr = SXGBE_CSR_250_300M;\r\nelse if (clk_rate <= SXGBE_CSR_F_350M)\r\npriv->clk_csr = SXGBE_CSR_300_350M;\r\nelse if (clk_rate <= SXGBE_CSR_F_400M)\r\npriv->clk_csr = SXGBE_CSR_350_400M;\r\nelse if (clk_rate <= SXGBE_CSR_F_500M)\r\npriv->clk_csr = SXGBE_CSR_400_500M;\r\n}\r\nstatic inline u32 sxgbe_tx_avail(struct sxgbe_tx_queue *queue, int tx_qsize)\r\n{\r\nreturn queue->dirty_tx + tx_qsize - queue->cur_tx - 1;\r\n}\r\nstatic void sxgbe_adjust_link(struct net_device *dev)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nstruct phy_device *phydev = dev->phydev;\r\nu8 new_state = 0;\r\nu8 speed = 0xff;\r\nif (!phydev)\r\nreturn;\r\nif (phydev->link) {\r\nif (phydev->speed != priv->speed) {\r\nnew_state = 1;\r\nswitch (phydev->speed) {\r\ncase SPEED_10000:\r\nspeed = SXGBE_SPEED_10G;\r\nbreak;\r\ncase SPEED_2500:\r\nspeed = SXGBE_SPEED_2_5G;\r\nbreak;\r\ncase SPEED_1000:\r\nspeed = SXGBE_SPEED_1G;\r\nbreak;\r\ndefault:\r\nnetif_err(priv, link, dev,\r\n"Speed (%d) not supported\n",\r\nphydev->speed);\r\n}\r\npriv->speed = phydev->speed;\r\npriv->hw->mac->set_speed(priv->ioaddr, speed);\r\n}\r\nif (!priv->oldlink) {\r\nnew_state = 1;\r\npriv->oldlink = 1;\r\n}\r\n} else if (priv->oldlink) {\r\nnew_state = 1;\r\npriv->oldlink = 0;\r\npriv->speed = SPEED_UNKNOWN;\r\n}\r\nif (new_state & netif_msg_link(priv))\r\nphy_print_status(phydev);\r\nsxgbe_eee_adjust(priv);\r\n}\r\nstatic int sxgbe_init_phy(struct net_device *ndev)\r\n{\r\nchar phy_id_fmt[MII_BUS_ID_SIZE + 3];\r\nchar bus_id[MII_BUS_ID_SIZE];\r\nstruct phy_device *phydev;\r\nstruct sxgbe_priv_data *priv = netdev_priv(ndev);\r\nint phy_iface = priv->plat->interface;\r\npriv->oldlink = 0;\r\npriv->speed = SPEED_UNKNOWN;\r\npriv->oldduplex = DUPLEX_UNKNOWN;\r\nif (priv->plat->phy_bus_name)\r\nsnprintf(bus_id, MII_BUS_ID_SIZE, "%s-%x",\r\npriv->plat->phy_bus_name, priv->plat->bus_id);\r\nelse\r\nsnprintf(bus_id, MII_BUS_ID_SIZE, "sxgbe-%x",\r\npriv->plat->bus_id);\r\nsnprintf(phy_id_fmt, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, bus_id,\r\npriv->plat->phy_addr);\r\nnetdev_dbg(ndev, "%s: trying to attach to %s\n", __func__, phy_id_fmt);\r\nphydev = phy_connect(ndev, phy_id_fmt, &sxgbe_adjust_link, phy_iface);\r\nif (IS_ERR(phydev)) {\r\nnetdev_err(ndev, "Could not attach to PHY\n");\r\nreturn PTR_ERR(phydev);\r\n}\r\nif ((phy_iface == PHY_INTERFACE_MODE_MII) ||\r\n(phy_iface == PHY_INTERFACE_MODE_RMII))\r\nphydev->advertising &= ~(SUPPORTED_1000baseT_Half |\r\nSUPPORTED_1000baseT_Full);\r\nif (phydev->phy_id == 0) {\r\nphy_disconnect(phydev);\r\nreturn -ENODEV;\r\n}\r\nnetdev_dbg(ndev, "%s: attached to PHY (UID 0x%x) Link = %d\n",\r\n__func__, phydev->phy_id, phydev->link);\r\nreturn 0;\r\n}\r\nstatic void sxgbe_clear_descriptors(struct sxgbe_priv_data *priv)\r\n{\r\nint i, j;\r\nunsigned int txsize = priv->dma_tx_size;\r\nunsigned int rxsize = priv->dma_rx_size;\r\nfor (j = 0; j < SXGBE_RX_QUEUES; j++) {\r\nfor (i = 0; i < rxsize; i++)\r\npriv->hw->desc->init_rx_desc(&priv->rxq[j]->dma_rx[i],\r\npriv->use_riwt, priv->mode,\r\n(i == rxsize - 1));\r\n}\r\nfor (j = 0; j < SXGBE_TX_QUEUES; j++) {\r\nfor (i = 0; i < txsize; i++)\r\npriv->hw->desc->init_tx_desc(&priv->txq[j]->dma_tx[i]);\r\n}\r\n}\r\nstatic int sxgbe_init_rx_buffers(struct net_device *dev,\r\nstruct sxgbe_rx_norm_desc *p, int i,\r\nunsigned int dma_buf_sz,\r\nstruct sxgbe_rx_queue *rx_ring)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nskb = __netdev_alloc_skb_ip_align(dev, dma_buf_sz, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nrx_ring->rx_skbuff[i] = skb;\r\nrx_ring->rx_skbuff_dma[i] = dma_map_single(priv->device, skb->data,\r\ndma_buf_sz, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(priv->device, rx_ring->rx_skbuff_dma[i])) {\r\nnetdev_err(dev, "%s: DMA mapping error\n", __func__);\r\ndev_kfree_skb_any(skb);\r\nreturn -EINVAL;\r\n}\r\np->rdes23.rx_rd_des23.buf2_addr = rx_ring->rx_skbuff_dma[i];\r\nreturn 0;\r\n}\r\nstatic void sxgbe_free_rx_buffers(struct net_device *dev,\r\nstruct sxgbe_rx_norm_desc *p, int i,\r\nunsigned int dma_buf_sz,\r\nstruct sxgbe_rx_queue *rx_ring)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nkfree_skb(rx_ring->rx_skbuff[i]);\r\ndma_unmap_single(priv->device, rx_ring->rx_skbuff_dma[i],\r\ndma_buf_sz, DMA_FROM_DEVICE);\r\n}\r\nstatic int init_tx_ring(struct device *dev, u8 queue_no,\r\nstruct sxgbe_tx_queue *tx_ring, int tx_rsize)\r\n{\r\nif (!tx_ring) {\r\ndev_err(dev, "No memory for TX queue of SXGBE\n");\r\nreturn -ENOMEM;\r\n}\r\ntx_ring->dma_tx = dma_zalloc_coherent(dev,\r\ntx_rsize * sizeof(struct sxgbe_tx_norm_desc),\r\n&tx_ring->dma_tx_phy, GFP_KERNEL);\r\nif (!tx_ring->dma_tx)\r\nreturn -ENOMEM;\r\ntx_ring->tx_skbuff_dma = devm_kcalloc(dev, tx_rsize,\r\nsizeof(dma_addr_t), GFP_KERNEL);\r\nif (!tx_ring->tx_skbuff_dma)\r\ngoto dmamem_err;\r\ntx_ring->tx_skbuff = devm_kcalloc(dev, tx_rsize,\r\nsizeof(struct sk_buff *), GFP_KERNEL);\r\nif (!tx_ring->tx_skbuff)\r\ngoto dmamem_err;\r\ntx_ring->queue_no = queue_no;\r\ntx_ring->dirty_tx = 0;\r\ntx_ring->cur_tx = 0;\r\nreturn 0;\r\ndmamem_err:\r\ndma_free_coherent(dev, tx_rsize * sizeof(struct sxgbe_tx_norm_desc),\r\ntx_ring->dma_tx, tx_ring->dma_tx_phy);\r\nreturn -ENOMEM;\r\n}\r\nstatic void free_rx_ring(struct device *dev, struct sxgbe_rx_queue *rx_ring,\r\nint rx_rsize)\r\n{\r\ndma_free_coherent(dev, rx_rsize * sizeof(struct sxgbe_rx_norm_desc),\r\nrx_ring->dma_rx, rx_ring->dma_rx_phy);\r\nkfree(rx_ring->rx_skbuff_dma);\r\nkfree(rx_ring->rx_skbuff);\r\n}\r\nstatic int init_rx_ring(struct net_device *dev, u8 queue_no,\r\nstruct sxgbe_rx_queue *rx_ring, int rx_rsize)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nint desc_index;\r\nunsigned int bfsize = 0;\r\nunsigned int ret = 0;\r\nbfsize = ALIGN(dev->mtu + ETH_HLEN + ETH_FCS_LEN + NET_IP_ALIGN, 8);\r\nnetif_dbg(priv, probe, dev, "%s: bfsize %d\n", __func__, bfsize);\r\nif (rx_ring == NULL) {\r\nnetdev_err(dev, "No memory for RX queue\n");\r\nreturn -ENOMEM;\r\n}\r\nrx_ring->queue_no = queue_no;\r\nrx_ring->dma_rx = dma_zalloc_coherent(priv->device,\r\nrx_rsize * sizeof(struct sxgbe_rx_norm_desc),\r\n&rx_ring->dma_rx_phy, GFP_KERNEL);\r\nif (rx_ring->dma_rx == NULL)\r\nreturn -ENOMEM;\r\nrx_ring->rx_skbuff_dma = kmalloc_array(rx_rsize,\r\nsizeof(dma_addr_t), GFP_KERNEL);\r\nif (!rx_ring->rx_skbuff_dma) {\r\nret = -ENOMEM;\r\ngoto err_free_dma_rx;\r\n}\r\nrx_ring->rx_skbuff = kmalloc_array(rx_rsize,\r\nsizeof(struct sk_buff *), GFP_KERNEL);\r\nif (!rx_ring->rx_skbuff) {\r\nret = -ENOMEM;\r\ngoto err_free_skbuff_dma;\r\n}\r\nfor (desc_index = 0; desc_index < rx_rsize; desc_index++) {\r\nstruct sxgbe_rx_norm_desc *p;\r\np = rx_ring->dma_rx + desc_index;\r\nret = sxgbe_init_rx_buffers(dev, p, desc_index,\r\nbfsize, rx_ring);\r\nif (ret)\r\ngoto err_free_rx_buffers;\r\n}\r\nrx_ring->cur_rx = 0;\r\nrx_ring->dirty_rx = (unsigned int)(desc_index - rx_rsize);\r\npriv->dma_buf_sz = bfsize;\r\nreturn 0;\r\nerr_free_rx_buffers:\r\nwhile (--desc_index >= 0) {\r\nstruct sxgbe_rx_norm_desc *p;\r\np = rx_ring->dma_rx + desc_index;\r\nsxgbe_free_rx_buffers(dev, p, desc_index, bfsize, rx_ring);\r\n}\r\nkfree(rx_ring->rx_skbuff);\r\nerr_free_skbuff_dma:\r\nkfree(rx_ring->rx_skbuff_dma);\r\nerr_free_dma_rx:\r\ndma_free_coherent(priv->device,\r\nrx_rsize * sizeof(struct sxgbe_rx_norm_desc),\r\nrx_ring->dma_rx, rx_ring->dma_rx_phy);\r\nreturn ret;\r\n}\r\nstatic void free_tx_ring(struct device *dev, struct sxgbe_tx_queue *tx_ring,\r\nint tx_rsize)\r\n{\r\ndma_free_coherent(dev, tx_rsize * sizeof(struct sxgbe_tx_norm_desc),\r\ntx_ring->dma_tx, tx_ring->dma_tx_phy);\r\n}\r\nstatic int init_dma_desc_rings(struct net_device *netd)\r\n{\r\nint queue_num, ret;\r\nstruct sxgbe_priv_data *priv = netdev_priv(netd);\r\nint tx_rsize = priv->dma_tx_size;\r\nint rx_rsize = priv->dma_rx_size;\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\r\nret = init_tx_ring(priv->device, queue_num,\r\npriv->txq[queue_num], tx_rsize);\r\nif (ret) {\r\ndev_err(&netd->dev, "TX DMA ring allocation failed!\n");\r\ngoto txalloc_err;\r\n}\r\npriv->txq[queue_num]->priv_ptr = priv;\r\n}\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_RX_QUEUES, queue_num) {\r\nret = init_rx_ring(netd, queue_num,\r\npriv->rxq[queue_num], rx_rsize);\r\nif (ret) {\r\nnetdev_err(netd, "RX DMA ring allocation failed!!\n");\r\ngoto rxalloc_err;\r\n}\r\npriv->rxq[queue_num]->priv_ptr = priv;\r\n}\r\nsxgbe_clear_descriptors(priv);\r\nreturn 0;\r\ntxalloc_err:\r\nwhile (queue_num--)\r\nfree_tx_ring(priv->device, priv->txq[queue_num], tx_rsize);\r\nreturn ret;\r\nrxalloc_err:\r\nwhile (queue_num--)\r\nfree_rx_ring(priv->device, priv->rxq[queue_num], rx_rsize);\r\nreturn ret;\r\n}\r\nstatic void tx_free_ring_skbufs(struct sxgbe_tx_queue *txqueue)\r\n{\r\nint dma_desc;\r\nstruct sxgbe_priv_data *priv = txqueue->priv_ptr;\r\nint tx_rsize = priv->dma_tx_size;\r\nfor (dma_desc = 0; dma_desc < tx_rsize; dma_desc++) {\r\nstruct sxgbe_tx_norm_desc *tdesc = txqueue->dma_tx + dma_desc;\r\nif (txqueue->tx_skbuff_dma[dma_desc])\r\ndma_unmap_single(priv->device,\r\ntxqueue->tx_skbuff_dma[dma_desc],\r\npriv->hw->desc->get_tx_len(tdesc),\r\nDMA_TO_DEVICE);\r\ndev_kfree_skb_any(txqueue->tx_skbuff[dma_desc]);\r\ntxqueue->tx_skbuff[dma_desc] = NULL;\r\ntxqueue->tx_skbuff_dma[dma_desc] = 0;\r\n}\r\n}\r\nstatic void dma_free_tx_skbufs(struct sxgbe_priv_data *priv)\r\n{\r\nint queue_num;\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\r\nstruct sxgbe_tx_queue *tqueue = priv->txq[queue_num];\r\ntx_free_ring_skbufs(tqueue);\r\n}\r\n}\r\nstatic void free_dma_desc_resources(struct sxgbe_priv_data *priv)\r\n{\r\nint queue_num;\r\nint tx_rsize = priv->dma_tx_size;\r\nint rx_rsize = priv->dma_rx_size;\r\ndma_free_tx_skbufs(priv);\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\r\nfree_tx_ring(priv->device, priv->txq[queue_num], tx_rsize);\r\n}\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_RX_QUEUES, queue_num) {\r\nfree_rx_ring(priv->device, priv->rxq[queue_num], rx_rsize);\r\n}\r\n}\r\nstatic int txring_mem_alloc(struct sxgbe_priv_data *priv)\r\n{\r\nint queue_num;\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\r\npriv->txq[queue_num] = devm_kmalloc(priv->device,\r\nsizeof(struct sxgbe_tx_queue), GFP_KERNEL);\r\nif (!priv->txq[queue_num])\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rxring_mem_alloc(struct sxgbe_priv_data *priv)\r\n{\r\nint queue_num;\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_RX_QUEUES, queue_num) {\r\npriv->rxq[queue_num] = devm_kmalloc(priv->device,\r\nsizeof(struct sxgbe_rx_queue), GFP_KERNEL);\r\nif (!priv->rxq[queue_num])\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sxgbe_mtl_operation_mode(struct sxgbe_priv_data *priv)\r\n{\r\nint queue_num;\r\nif (likely(priv->plat->force_sf_dma_mode)) {\r\nSXGBE_FOR_EACH_QUEUE(priv->hw_cap.tx_mtl_queues, queue_num)\r\npriv->hw->mtl->set_tx_mtl_mode(priv->ioaddr, queue_num,\r\nSXGBE_MTL_SFMODE);\r\npriv->tx_tc = SXGBE_MTL_SFMODE;\r\nSXGBE_FOR_EACH_QUEUE(priv->hw_cap.rx_mtl_queues, queue_num)\r\npriv->hw->mtl->set_rx_mtl_mode(priv->ioaddr, queue_num,\r\nSXGBE_MTL_SFMODE);\r\npriv->rx_tc = SXGBE_MTL_SFMODE;\r\n} else if (unlikely(priv->plat->force_thresh_dma_mode)) {\r\nSXGBE_FOR_EACH_QUEUE(priv->hw_cap.tx_mtl_queues, queue_num)\r\npriv->hw->mtl->set_tx_mtl_mode(priv->ioaddr, queue_num,\r\npriv->tx_tc);\r\nSXGBE_FOR_EACH_QUEUE(priv->hw_cap.rx_mtl_queues, queue_num)\r\npriv->hw->mtl->set_rx_mtl_mode(priv->ioaddr, queue_num,\r\npriv->rx_tc);\r\n} else {\r\npr_err("ERROR: %s: Invalid TX threshold mode\n", __func__);\r\n}\r\n}\r\nstatic void sxgbe_tx_queue_clean(struct sxgbe_tx_queue *tqueue)\r\n{\r\nstruct sxgbe_priv_data *priv = tqueue->priv_ptr;\r\nunsigned int tx_rsize = priv->dma_tx_size;\r\nstruct netdev_queue *dev_txq;\r\nu8 queue_no = tqueue->queue_no;\r\ndev_txq = netdev_get_tx_queue(priv->dev, queue_no);\r\n__netif_tx_lock(dev_txq, smp_processor_id());\r\npriv->xstats.tx_clean++;\r\nwhile (tqueue->dirty_tx != tqueue->cur_tx) {\r\nunsigned int entry = tqueue->dirty_tx % tx_rsize;\r\nstruct sk_buff *skb = tqueue->tx_skbuff[entry];\r\nstruct sxgbe_tx_norm_desc *p;\r\np = tqueue->dma_tx + entry;\r\nif (priv->hw->desc->get_tx_owner(p))\r\nbreak;\r\nif (netif_msg_tx_done(priv))\r\npr_debug("%s: curr %d, dirty %d\n",\r\n__func__, tqueue->cur_tx, tqueue->dirty_tx);\r\nif (likely(tqueue->tx_skbuff_dma[entry])) {\r\ndma_unmap_single(priv->device,\r\ntqueue->tx_skbuff_dma[entry],\r\npriv->hw->desc->get_tx_len(p),\r\nDMA_TO_DEVICE);\r\ntqueue->tx_skbuff_dma[entry] = 0;\r\n}\r\nif (likely(skb)) {\r\ndev_kfree_skb(skb);\r\ntqueue->tx_skbuff[entry] = NULL;\r\n}\r\npriv->hw->desc->release_tx_desc(p);\r\ntqueue->dirty_tx++;\r\n}\r\nif (unlikely(netif_tx_queue_stopped(dev_txq) &&\r\nsxgbe_tx_avail(tqueue, tx_rsize) > SXGBE_TX_THRESH(priv))) {\r\nif (netif_msg_tx_done(priv))\r\npr_debug("%s: restart transmit\n", __func__);\r\nnetif_tx_wake_queue(dev_txq);\r\n}\r\n__netif_tx_unlock(dev_txq);\r\n}\r\nstatic void sxgbe_tx_all_clean(struct sxgbe_priv_data * const priv)\r\n{\r\nu8 queue_num;\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\r\nstruct sxgbe_tx_queue *tqueue = priv->txq[queue_num];\r\nsxgbe_tx_queue_clean(tqueue);\r\n}\r\nif ((priv->eee_enabled) && (!priv->tx_path_in_lpi_mode)) {\r\nsxgbe_enable_eee_mode(priv);\r\nmod_timer(&priv->eee_ctrl_timer, SXGBE_LPI_TIMER(eee_timer));\r\n}\r\n}\r\nstatic void sxgbe_restart_tx_queue(struct sxgbe_priv_data *priv, int queue_num)\r\n{\r\nstruct sxgbe_tx_queue *tx_ring = priv->txq[queue_num];\r\nstruct netdev_queue *dev_txq = netdev_get_tx_queue(priv->dev,\r\nqueue_num);\r\nnetif_tx_stop_queue(dev_txq);\r\npriv->hw->dma->stop_tx_queue(priv->ioaddr, queue_num);\r\ntx_free_ring_skbufs(tx_ring);\r\ntx_ring->cur_tx = 0;\r\ntx_ring->dirty_tx = 0;\r\npriv->hw->dma->start_tx_queue(priv->ioaddr, queue_num);\r\npriv->dev->stats.tx_errors++;\r\nnetif_tx_wake_queue(dev_txq);\r\n}\r\nstatic void sxgbe_reset_all_tx_queues(struct sxgbe_priv_data *priv)\r\n{\r\nint queue_num;\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num)\r\nsxgbe_restart_tx_queue(priv, queue_num);\r\n}\r\nstatic int sxgbe_get_hw_features(struct sxgbe_priv_data * const priv)\r\n{\r\nint rval = 0;\r\nstruct sxgbe_hw_features *features = &priv->hw_cap;\r\nrval = priv->hw->mac->get_hw_feature(priv->ioaddr, 0);\r\nif (rval) {\r\nfeatures->pmt_remote_wake_up =\r\nSXGBE_HW_FEAT_PMT_TEMOTE_WOP(rval);\r\nfeatures->pmt_magic_frame = SXGBE_HW_FEAT_PMT_MAGIC_PKT(rval);\r\nfeatures->atime_stamp = SXGBE_HW_FEAT_IEEE1500_2008(rval);\r\nfeatures->tx_csum_offload =\r\nSXGBE_HW_FEAT_TX_CSUM_OFFLOAD(rval);\r\nfeatures->rx_csum_offload =\r\nSXGBE_HW_FEAT_RX_CSUM_OFFLOAD(rval);\r\nfeatures->multi_macaddr = SXGBE_HW_FEAT_MACADDR_COUNT(rval);\r\nfeatures->tstamp_srcselect = SXGBE_HW_FEAT_TSTMAP_SRC(rval);\r\nfeatures->sa_vlan_insert = SXGBE_HW_FEAT_SRCADDR_VLAN(rval);\r\nfeatures->eee = SXGBE_HW_FEAT_EEE(rval);\r\n}\r\nrval = priv->hw->mac->get_hw_feature(priv->ioaddr, 1);\r\nif (rval) {\r\nfeatures->rxfifo_size = SXGBE_HW_FEAT_RX_FIFO_SIZE(rval);\r\nfeatures->txfifo_size = SXGBE_HW_FEAT_TX_FIFO_SIZE(rval);\r\nfeatures->atstmap_hword = SXGBE_HW_FEAT_TX_FIFO_SIZE(rval);\r\nfeatures->dcb_enable = SXGBE_HW_FEAT_DCB(rval);\r\nfeatures->splithead_enable = SXGBE_HW_FEAT_SPLIT_HDR(rval);\r\nfeatures->tcpseg_offload = SXGBE_HW_FEAT_TSO(rval);\r\nfeatures->debug_mem = SXGBE_HW_FEAT_DEBUG_MEM_IFACE(rval);\r\nfeatures->rss_enable = SXGBE_HW_FEAT_RSS(rval);\r\nfeatures->hash_tsize = SXGBE_HW_FEAT_HASH_TABLE_SIZE(rval);\r\nfeatures->l3l4_filer_size = SXGBE_HW_FEAT_L3L4_FILTER_NUM(rval);\r\n}\r\nrval = priv->hw->mac->get_hw_feature(priv->ioaddr, 2);\r\nif (rval) {\r\nfeatures->rx_mtl_queues = SXGBE_HW_FEAT_RX_MTL_QUEUES(rval);\r\nfeatures->tx_mtl_queues = SXGBE_HW_FEAT_TX_MTL_QUEUES(rval);\r\nfeatures->rx_dma_channels = SXGBE_HW_FEAT_RX_DMA_CHANNELS(rval);\r\nfeatures->tx_dma_channels = SXGBE_HW_FEAT_TX_DMA_CHANNELS(rval);\r\nfeatures->pps_output_count = SXGBE_HW_FEAT_PPS_OUTPUTS(rval);\r\nfeatures->aux_input_count = SXGBE_HW_FEAT_AUX_SNAPSHOTS(rval);\r\n}\r\nreturn rval;\r\n}\r\nstatic void sxgbe_check_ether_addr(struct sxgbe_priv_data *priv)\r\n{\r\nif (!is_valid_ether_addr(priv->dev->dev_addr)) {\r\npriv->hw->mac->get_umac_addr((void __iomem *)\r\npriv->ioaddr,\r\npriv->dev->dev_addr, 0);\r\nif (!is_valid_ether_addr(priv->dev->dev_addr))\r\neth_hw_addr_random(priv->dev);\r\n}\r\ndev_info(priv->device, "device MAC address %pM\n",\r\npriv->dev->dev_addr);\r\n}\r\nstatic int sxgbe_init_dma_engine(struct sxgbe_priv_data *priv)\r\n{\r\nint pbl = DEFAULT_DMA_PBL, fixed_burst = 0, burst_map = 0;\r\nint queue_num;\r\nif (priv->plat->dma_cfg) {\r\npbl = priv->plat->dma_cfg->pbl;\r\nfixed_burst = priv->plat->dma_cfg->fixed_burst;\r\nburst_map = priv->plat->dma_cfg->burst_map;\r\n}\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num)\r\npriv->hw->dma->cha_init(priv->ioaddr, queue_num,\r\nfixed_burst, pbl,\r\n(priv->txq[queue_num])->dma_tx_phy,\r\n(priv->rxq[queue_num])->dma_rx_phy,\r\npriv->dma_tx_size, priv->dma_rx_size);\r\nreturn priv->hw->dma->init(priv->ioaddr, fixed_burst, burst_map);\r\n}\r\nstatic void sxgbe_init_mtl_engine(struct sxgbe_priv_data *priv)\r\n{\r\nint queue_num;\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\r\npriv->hw->mtl->mtl_set_txfifosize(priv->ioaddr, queue_num,\r\npriv->hw_cap.tx_mtl_qsize);\r\npriv->hw->mtl->mtl_enable_txqueue(priv->ioaddr, queue_num);\r\n}\r\n}\r\nstatic void sxgbe_disable_mtl_engine(struct sxgbe_priv_data *priv)\r\n{\r\nint queue_num;\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num)\r\npriv->hw->mtl->mtl_disable_txqueue(priv->ioaddr, queue_num);\r\n}\r\nstatic void sxgbe_tx_timer(unsigned long data)\r\n{\r\nstruct sxgbe_tx_queue *p = (struct sxgbe_tx_queue *)data;\r\nsxgbe_tx_queue_clean(p);\r\n}\r\nstatic void sxgbe_tx_init_coalesce(struct sxgbe_priv_data *priv)\r\n{\r\nu8 queue_num;\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\r\nstruct sxgbe_tx_queue *p = priv->txq[queue_num];\r\np->tx_coal_frames = SXGBE_TX_FRAMES;\r\np->tx_coal_timer = SXGBE_COAL_TX_TIMER;\r\nsetup_timer(&p->txtimer, sxgbe_tx_timer,\r\n(unsigned long)&priv->txq[queue_num]);\r\np->txtimer.expires = SXGBE_COAL_TIMER(p->tx_coal_timer);\r\nadd_timer(&p->txtimer);\r\n}\r\n}\r\nstatic void sxgbe_tx_del_timer(struct sxgbe_priv_data *priv)\r\n{\r\nu8 queue_num;\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\r\nstruct sxgbe_tx_queue *p = priv->txq[queue_num];\r\ndel_timer_sync(&p->txtimer);\r\n}\r\n}\r\nstatic int sxgbe_open(struct net_device *dev)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nint ret, queue_num;\r\nclk_prepare_enable(priv->sxgbe_clk);\r\nsxgbe_check_ether_addr(priv);\r\nret = sxgbe_init_phy(dev);\r\nif (ret) {\r\nnetdev_err(dev, "%s: Cannot attach to PHY (error: %d)\n",\r\n__func__, ret);\r\ngoto phy_error;\r\n}\r\npriv->dma_tx_size = SXGBE_ALIGN(DMA_TX_SIZE);\r\npriv->dma_rx_size = SXGBE_ALIGN(DMA_RX_SIZE);\r\npriv->dma_buf_sz = SXGBE_ALIGN(DMA_BUFFER_SIZE);\r\npriv->tx_tc = TC_DEFAULT;\r\npriv->rx_tc = TC_DEFAULT;\r\ninit_dma_desc_rings(dev);\r\nret = sxgbe_init_dma_engine(priv);\r\nif (ret < 0) {\r\nnetdev_err(dev, "%s: DMA initialization failed\n", __func__);\r\ngoto init_error;\r\n}\r\nsxgbe_init_mtl_engine(priv);\r\npriv->hw->mac->set_umac_addr(priv->ioaddr, dev->dev_addr, 0);\r\npriv->hw->mac->core_init(priv->ioaddr);\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_RX_QUEUES, queue_num) {\r\npriv->hw->mac->enable_rxqueue(priv->ioaddr, queue_num);\r\n}\r\nret = devm_request_irq(priv->device, priv->irq, sxgbe_common_interrupt,\r\nIRQF_SHARED, dev->name, dev);\r\nif (unlikely(ret < 0)) {\r\nnetdev_err(dev, "%s: ERROR: allocating the IRQ %d (error: %d)\n",\r\n__func__, priv->irq, ret);\r\ngoto init_error;\r\n}\r\nif (priv->lpi_irq != dev->irq) {\r\nret = devm_request_irq(priv->device, priv->lpi_irq,\r\nsxgbe_common_interrupt,\r\nIRQF_SHARED, dev->name, dev);\r\nif (unlikely(ret < 0)) {\r\nnetdev_err(dev, "%s: ERROR: allocating the LPI IRQ %d (%d)\n",\r\n__func__, priv->lpi_irq, ret);\r\ngoto init_error;\r\n}\r\n}\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\r\nret = devm_request_irq(priv->device,\r\n(priv->txq[queue_num])->irq_no,\r\nsxgbe_tx_interrupt, 0,\r\ndev->name, priv->txq[queue_num]);\r\nif (unlikely(ret < 0)) {\r\nnetdev_err(dev, "%s: ERROR: allocating TX IRQ %d (error: %d)\n",\r\n__func__, priv->irq, ret);\r\ngoto init_error;\r\n}\r\n}\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_RX_QUEUES, queue_num) {\r\nret = devm_request_irq(priv->device,\r\n(priv->rxq[queue_num])->irq_no,\r\nsxgbe_rx_interrupt, 0,\r\ndev->name, priv->rxq[queue_num]);\r\nif (unlikely(ret < 0)) {\r\nnetdev_err(dev, "%s: ERROR: allocating TX IRQ %d (error: %d)\n",\r\n__func__, priv->irq, ret);\r\ngoto init_error;\r\n}\r\n}\r\npriv->hw->mac->enable_tx(priv->ioaddr, true);\r\npriv->hw->mac->enable_rx(priv->ioaddr, true);\r\nsxgbe_mtl_operation_mode(priv);\r\nmemset(&priv->xstats, 0, sizeof(struct sxgbe_extra_stats));\r\npriv->xstats.tx_threshold = priv->tx_tc;\r\npriv->xstats.rx_threshold = priv->rx_tc;\r\nnetdev_dbg(dev, "DMA RX/TX processes started...\n");\r\npriv->hw->dma->start_tx(priv->ioaddr, SXGBE_TX_QUEUES);\r\npriv->hw->dma->start_rx(priv->ioaddr, SXGBE_RX_QUEUES);\r\nif (dev->phydev)\r\nphy_start(dev->phydev);\r\nsxgbe_tx_init_coalesce(priv);\r\nif ((priv->use_riwt) && (priv->hw->dma->rx_watchdog)) {\r\npriv->rx_riwt = SXGBE_MAX_DMA_RIWT;\r\npriv->hw->dma->rx_watchdog(priv->ioaddr, SXGBE_MAX_DMA_RIWT);\r\n}\r\npriv->tx_lpi_timer = SXGBE_DEFAULT_LPI_TIMER;\r\npriv->eee_enabled = sxgbe_eee_init(priv);\r\nnapi_enable(&priv->napi);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\ninit_error:\r\nfree_dma_desc_resources(priv);\r\nif (dev->phydev)\r\nphy_disconnect(dev->phydev);\r\nphy_error:\r\nclk_disable_unprepare(priv->sxgbe_clk);\r\nreturn ret;\r\n}\r\nstatic int sxgbe_release(struct net_device *dev)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nif (priv->eee_enabled)\r\ndel_timer_sync(&priv->eee_ctrl_timer);\r\nif (dev->phydev) {\r\nphy_stop(dev->phydev);\r\nphy_disconnect(dev->phydev);\r\n}\r\nnetif_tx_stop_all_queues(dev);\r\nnapi_disable(&priv->napi);\r\nsxgbe_tx_del_timer(priv);\r\npriv->hw->dma->stop_tx(priv->ioaddr, SXGBE_TX_QUEUES);\r\npriv->hw->dma->stop_rx(priv->ioaddr, SXGBE_RX_QUEUES);\r\nsxgbe_disable_mtl_engine(priv);\r\nfree_dma_desc_resources(priv);\r\npriv->hw->mac->enable_tx(priv->ioaddr, false);\r\npriv->hw->mac->enable_rx(priv->ioaddr, false);\r\nclk_disable_unprepare(priv->sxgbe_clk);\r\nreturn 0;\r\n}\r\nstatic void sxgbe_tso_prepare(struct sxgbe_priv_data *priv,\r\nstruct sxgbe_tx_norm_desc *first_desc,\r\nstruct sk_buff *skb)\r\n{\r\nunsigned int total_hdr_len, tcp_hdr_len;\r\ntcp_hdr_len = tcp_hdrlen(skb);\r\ntotal_hdr_len = skb_transport_offset(skb) + tcp_hdr_len;\r\nfirst_desc->tdes01 = dma_map_single(priv->device, skb->data,\r\ntotal_hdr_len, DMA_TO_DEVICE);\r\nif (dma_mapping_error(priv->device, first_desc->tdes01))\r\npr_err("%s: TX dma mapping failed!!\n", __func__);\r\nfirst_desc->tdes23.tx_rd_des23.first_desc = 1;\r\npriv->hw->desc->tx_desc_enable_tse(first_desc, 1, total_hdr_len,\r\ntcp_hdr_len,\r\nskb->len - total_hdr_len);\r\n}\r\nstatic netdev_tx_t sxgbe_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nunsigned int entry, frag_num;\r\nint cksum_flag = 0;\r\nstruct netdev_queue *dev_txq;\r\nunsigned txq_index = skb_get_queue_mapping(skb);\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nunsigned int tx_rsize = priv->dma_tx_size;\r\nstruct sxgbe_tx_queue *tqueue = priv->txq[txq_index];\r\nstruct sxgbe_tx_norm_desc *tx_desc, *first_desc;\r\nstruct sxgbe_tx_ctxt_desc *ctxt_desc = NULL;\r\nint nr_frags = skb_shinfo(skb)->nr_frags;\r\nint no_pagedlen = skb_headlen(skb);\r\nint is_jumbo = 0;\r\nu16 cur_mss = skb_shinfo(skb)->gso_size;\r\nu32 ctxt_desc_req = 0;\r\ndev_txq = netdev_get_tx_queue(dev, txq_index);\r\nif (unlikely(skb_is_gso(skb) && tqueue->prev_mss != cur_mss))\r\nctxt_desc_req = 1;\r\nif (unlikely(skb_vlan_tag_present(skb) ||\r\n((skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&\r\ntqueue->hwts_tx_en)))\r\nctxt_desc_req = 1;\r\nif (priv->tx_path_in_lpi_mode)\r\nsxgbe_disable_eee_mode(priv);\r\nif (unlikely(sxgbe_tx_avail(tqueue, tx_rsize) < nr_frags + 1)) {\r\nif (!netif_tx_queue_stopped(dev_txq)) {\r\nnetif_tx_stop_queue(dev_txq);\r\nnetdev_err(dev, "%s: Tx Ring is full when %d queue is awake\n",\r\n__func__, txq_index);\r\n}\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nentry = tqueue->cur_tx % tx_rsize;\r\ntx_desc = tqueue->dma_tx + entry;\r\nfirst_desc = tx_desc;\r\nif (ctxt_desc_req)\r\nctxt_desc = (struct sxgbe_tx_ctxt_desc *)first_desc;\r\ntqueue->tx_skbuff[entry] = skb;\r\nif (!is_jumbo) {\r\nif (likely(skb_is_gso(skb))) {\r\nif (unlikely(tqueue->prev_mss != cur_mss)) {\r\npriv->hw->desc->tx_ctxt_desc_set_mss(\r\nctxt_desc, cur_mss);\r\npriv->hw->desc->tx_ctxt_desc_set_tcmssv(\r\nctxt_desc);\r\npriv->hw->desc->tx_ctxt_desc_reset_ostc(\r\nctxt_desc);\r\npriv->hw->desc->tx_ctxt_desc_set_ctxt(\r\nctxt_desc);\r\npriv->hw->desc->tx_ctxt_desc_set_owner(\r\nctxt_desc);\r\nentry = (++tqueue->cur_tx) % tx_rsize;\r\nfirst_desc = tqueue->dma_tx + entry;\r\ntqueue->prev_mss = cur_mss;\r\n}\r\nsxgbe_tso_prepare(priv, first_desc, skb);\r\n} else {\r\ntx_desc->tdes01 = dma_map_single(priv->device,\r\nskb->data, no_pagedlen, DMA_TO_DEVICE);\r\nif (dma_mapping_error(priv->device, tx_desc->tdes01))\r\nnetdev_err(dev, "%s: TX dma mapping failed!!\n",\r\n__func__);\r\npriv->hw->desc->prepare_tx_desc(tx_desc, 1, no_pagedlen,\r\nno_pagedlen, cksum_flag);\r\n}\r\n}\r\nfor (frag_num = 0; frag_num < nr_frags; frag_num++) {\r\nconst skb_frag_t *frag = &skb_shinfo(skb)->frags[frag_num];\r\nint len = skb_frag_size(frag);\r\nentry = (++tqueue->cur_tx) % tx_rsize;\r\ntx_desc = tqueue->dma_tx + entry;\r\ntx_desc->tdes01 = skb_frag_dma_map(priv->device, frag, 0, len,\r\nDMA_TO_DEVICE);\r\ntqueue->tx_skbuff_dma[entry] = tx_desc->tdes01;\r\ntqueue->tx_skbuff[entry] = NULL;\r\npriv->hw->desc->prepare_tx_desc(tx_desc, 0, len,\r\nlen, cksum_flag);\r\nwmb();\r\npriv->hw->desc->set_tx_owner(tx_desc);\r\n}\r\npriv->hw->desc->close_tx_desc(tx_desc);\r\nwmb();\r\ntqueue->tx_count_frames += nr_frags + 1;\r\nif (tqueue->tx_count_frames > tqueue->tx_coal_frames) {\r\npriv->hw->desc->clear_tx_ic(tx_desc);\r\npriv->xstats.tx_reset_ic_bit++;\r\nmod_timer(&tqueue->txtimer,\r\nSXGBE_COAL_TIMER(tqueue->tx_coal_timer));\r\n} else {\r\ntqueue->tx_count_frames = 0;\r\n}\r\npriv->hw->desc->set_tx_owner(first_desc);\r\nwmb();\r\ntqueue->cur_tx++;\r\nnetif_dbg(priv, pktdata, dev, "%s: curr %d dirty=%d entry=%d, first=%p, nfrags=%d\n",\r\n__func__, tqueue->cur_tx % tx_rsize,\r\ntqueue->dirty_tx % tx_rsize, entry,\r\nfirst_desc, nr_frags);\r\nif (unlikely(sxgbe_tx_avail(tqueue, tx_rsize) <= (MAX_SKB_FRAGS + 1))) {\r\nnetif_dbg(priv, hw, dev, "%s: stop transmitted packets\n",\r\n__func__);\r\nnetif_tx_stop_queue(dev_txq);\r\n}\r\ndev->stats.tx_bytes += skb->len;\r\nif (unlikely((skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&\r\ntqueue->hwts_tx_en)) {\r\nskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\r\npriv->hw->desc->tx_enable_tstamp(first_desc);\r\n}\r\nskb_tx_timestamp(skb);\r\npriv->hw->dma->enable_dma_transmission(priv->ioaddr, txq_index);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void sxgbe_rx_refill(struct sxgbe_priv_data *priv)\r\n{\r\nunsigned int rxsize = priv->dma_rx_size;\r\nint bfsize = priv->dma_buf_sz;\r\nu8 qnum = priv->cur_rx_qnum;\r\nfor (; priv->rxq[qnum]->cur_rx - priv->rxq[qnum]->dirty_rx > 0;\r\npriv->rxq[qnum]->dirty_rx++) {\r\nunsigned int entry = priv->rxq[qnum]->dirty_rx % rxsize;\r\nstruct sxgbe_rx_norm_desc *p;\r\np = priv->rxq[qnum]->dma_rx + entry;\r\nif (likely(priv->rxq[qnum]->rx_skbuff[entry] == NULL)) {\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb_ip_align(priv->dev, bfsize);\r\nif (unlikely(skb == NULL))\r\nbreak;\r\npriv->rxq[qnum]->rx_skbuff[entry] = skb;\r\npriv->rxq[qnum]->rx_skbuff_dma[entry] =\r\ndma_map_single(priv->device, skb->data, bfsize,\r\nDMA_FROM_DEVICE);\r\np->rdes23.rx_rd_des23.buf2_addr =\r\npriv->rxq[qnum]->rx_skbuff_dma[entry];\r\n}\r\nwmb();\r\npriv->hw->desc->set_rx_owner(p);\r\npriv->hw->desc->set_rx_int_on_com(p);\r\nwmb();\r\n}\r\n}\r\nstatic int sxgbe_rx(struct sxgbe_priv_data *priv, int limit)\r\n{\r\nu8 qnum = priv->cur_rx_qnum;\r\nunsigned int rxsize = priv->dma_rx_size;\r\nunsigned int entry = priv->rxq[qnum]->cur_rx;\r\nunsigned int next_entry = 0;\r\nunsigned int count = 0;\r\nint checksum;\r\nint status;\r\nwhile (count < limit) {\r\nstruct sxgbe_rx_norm_desc *p;\r\nstruct sk_buff *skb;\r\nint frame_len;\r\np = priv->rxq[qnum]->dma_rx + entry;\r\nif (priv->hw->desc->get_rx_owner(p))\r\nbreak;\r\ncount++;\r\nnext_entry = (++priv->rxq[qnum]->cur_rx) % rxsize;\r\nprefetch(priv->rxq[qnum]->dma_rx + next_entry);\r\nstatus = priv->hw->desc->rx_wbstatus(p, &priv->xstats,\r\n&checksum);\r\nif (unlikely(status < 0)) {\r\nentry = next_entry;\r\ncontinue;\r\n}\r\nif (unlikely(!priv->rxcsum_insertion))\r\nchecksum = CHECKSUM_NONE;\r\nskb = priv->rxq[qnum]->rx_skbuff[entry];\r\nif (unlikely(!skb))\r\nnetdev_err(priv->dev, "rx descriptor is not consistent\n");\r\nprefetch(skb->data - NET_IP_ALIGN);\r\npriv->rxq[qnum]->rx_skbuff[entry] = NULL;\r\nframe_len = priv->hw->desc->get_rx_frame_len(p);\r\nskb_put(skb, frame_len);\r\nskb->ip_summed = checksum;\r\nif (checksum == CHECKSUM_NONE)\r\nnetif_receive_skb(skb);\r\nelse\r\nnapi_gro_receive(&priv->napi, skb);\r\nentry = next_entry;\r\n}\r\nsxgbe_rx_refill(priv);\r\nreturn count;\r\n}\r\nstatic int sxgbe_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct sxgbe_priv_data *priv = container_of(napi,\r\nstruct sxgbe_priv_data, napi);\r\nint work_done = 0;\r\nu8 qnum = priv->cur_rx_qnum;\r\npriv->xstats.napi_poll++;\r\nsxgbe_tx_all_clean(priv);\r\nwork_done = sxgbe_rx(priv, budget);\r\nif (work_done < budget) {\r\nnapi_complete_done(napi, work_done);\r\npriv->hw->dma->enable_dma_irq(priv->ioaddr, qnum);\r\n}\r\nreturn work_done;\r\n}\r\nstatic void sxgbe_tx_timeout(struct net_device *dev)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nsxgbe_reset_all_tx_queues(priv);\r\n}\r\nstatic irqreturn_t sxgbe_common_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *netdev = (struct net_device *)dev_id;\r\nstruct sxgbe_priv_data *priv = netdev_priv(netdev);\r\nint status;\r\nstatus = priv->hw->mac->host_irq_status(priv->ioaddr, &priv->xstats);\r\nif (status & TX_ENTRY_LPI_MODE) {\r\npriv->xstats.tx_lpi_entry_n++;\r\npriv->tx_path_in_lpi_mode = true;\r\n}\r\nif (status & TX_EXIT_LPI_MODE) {\r\npriv->xstats.tx_lpi_exit_n++;\r\npriv->tx_path_in_lpi_mode = false;\r\n}\r\nif (status & RX_ENTRY_LPI_MODE)\r\npriv->xstats.rx_lpi_entry_n++;\r\nif (status & RX_EXIT_LPI_MODE)\r\npriv->xstats.rx_lpi_exit_n++;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sxgbe_tx_interrupt(int irq, void *dev_id)\r\n{\r\nint status;\r\nstruct sxgbe_tx_queue *txq = (struct sxgbe_tx_queue *)dev_id;\r\nstruct sxgbe_priv_data *priv = txq->priv_ptr;\r\nstatus = priv->hw->dma->tx_dma_int_status(priv->ioaddr, txq->queue_no,\r\n&priv->xstats);\r\nif (likely((status & handle_tx)))\r\nnapi_schedule(&priv->napi);\r\nif (unlikely((status & tx_hard_error)))\r\nsxgbe_restart_tx_queue(priv, txq->queue_no);\r\nif (unlikely((status & tx_bump_tc) &&\r\n(priv->tx_tc != SXGBE_MTL_SFMODE) &&\r\n(priv->tx_tc < 512))) {\r\npriv->tx_tc += (priv->tx_tc < 128) ? 32 : 64;\r\npriv->hw->mtl->set_tx_mtl_mode(priv->ioaddr,\r\ntxq->queue_no, priv->tx_tc);\r\npriv->xstats.tx_threshold = priv->tx_tc;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sxgbe_rx_interrupt(int irq, void *dev_id)\r\n{\r\nint status;\r\nstruct sxgbe_rx_queue *rxq = (struct sxgbe_rx_queue *)dev_id;\r\nstruct sxgbe_priv_data *priv = rxq->priv_ptr;\r\nstatus = priv->hw->dma->rx_dma_int_status(priv->ioaddr, rxq->queue_no,\r\n&priv->xstats);\r\nif (likely((status & handle_rx) && (napi_schedule_prep(&priv->napi)))) {\r\npriv->hw->dma->disable_dma_irq(priv->ioaddr, rxq->queue_no);\r\n__napi_schedule(&priv->napi);\r\n}\r\nif (unlikely((status & rx_bump_tc) &&\r\n(priv->rx_tc != SXGBE_MTL_SFMODE) &&\r\n(priv->rx_tc < 128))) {\r\npriv->rx_tc += 32;\r\npriv->hw->mtl->set_rx_mtl_mode(priv->ioaddr,\r\nrxq->queue_no, priv->rx_tc);\r\npriv->xstats.rx_threshold = priv->rx_tc;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline u64 sxgbe_get_stat64(void __iomem *ioaddr, int reg_lo, int reg_hi)\r\n{\r\nu64 val = readl(ioaddr + reg_lo);\r\nval |= ((u64)readl(ioaddr + reg_hi)) << 32;\r\nreturn val;\r\n}\r\nstatic void sxgbe_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nvoid __iomem *ioaddr = priv->ioaddr;\r\nu64 count;\r\nspin_lock(&priv->stats_lock);\r\nwritel(SXGBE_MMC_CTRL_CNT_FRZ, ioaddr + SXGBE_MMC_CTL_REG);\r\nstats->rx_bytes = sxgbe_get_stat64(ioaddr,\r\nSXGBE_MMC_RXOCTETLO_GCNT_REG,\r\nSXGBE_MMC_RXOCTETHI_GCNT_REG);\r\nstats->rx_packets = sxgbe_get_stat64(ioaddr,\r\nSXGBE_MMC_RXFRAMELO_GBCNT_REG,\r\nSXGBE_MMC_RXFRAMEHI_GBCNT_REG);\r\nstats->multicast = sxgbe_get_stat64(ioaddr,\r\nSXGBE_MMC_RXMULTILO_GCNT_REG,\r\nSXGBE_MMC_RXMULTIHI_GCNT_REG);\r\nstats->rx_crc_errors = sxgbe_get_stat64(ioaddr,\r\nSXGBE_MMC_RXCRCERRLO_REG,\r\nSXGBE_MMC_RXCRCERRHI_REG);\r\nstats->rx_length_errors = sxgbe_get_stat64(ioaddr,\r\nSXGBE_MMC_RXLENERRLO_REG,\r\nSXGBE_MMC_RXLENERRHI_REG);\r\nstats->rx_missed_errors = sxgbe_get_stat64(ioaddr,\r\nSXGBE_MMC_RXFIFOOVERFLOWLO_GBCNT_REG,\r\nSXGBE_MMC_RXFIFOOVERFLOWHI_GBCNT_REG);\r\nstats->tx_bytes = sxgbe_get_stat64(ioaddr,\r\nSXGBE_MMC_TXOCTETLO_GCNT_REG,\r\nSXGBE_MMC_TXOCTETHI_GCNT_REG);\r\ncount = sxgbe_get_stat64(ioaddr, SXGBE_MMC_TXFRAMELO_GBCNT_REG,\r\nSXGBE_MMC_TXFRAMEHI_GBCNT_REG);\r\nstats->tx_errors = sxgbe_get_stat64(ioaddr, SXGBE_MMC_TXFRAMELO_GCNT_REG,\r\nSXGBE_MMC_TXFRAMEHI_GCNT_REG);\r\nstats->tx_errors = count - stats->tx_errors;\r\nstats->tx_packets = count;\r\nstats->tx_fifo_errors = sxgbe_get_stat64(ioaddr, SXGBE_MMC_TXUFLWLO_GBCNT_REG,\r\nSXGBE_MMC_TXUFLWHI_GBCNT_REG);\r\nwritel(0, ioaddr + SXGBE_MMC_CTL_REG);\r\nspin_unlock(&priv->stats_lock);\r\n}\r\nstatic int sxgbe_set_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nnetdev_features_t changed = dev->features ^ features;\r\nif (changed & NETIF_F_RXCSUM) {\r\nif (features & NETIF_F_RXCSUM) {\r\npriv->hw->mac->enable_rx_csum(priv->ioaddr);\r\npriv->rxcsum_insertion = true;\r\n} else {\r\npriv->hw->mac->disable_rx_csum(priv->ioaddr);\r\npriv->rxcsum_insertion = false;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sxgbe_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\ndev->mtu = new_mtu;\r\nif (!netif_running(dev))\r\nreturn 0;\r\nsxgbe_release(dev);\r\nreturn sxgbe_open(dev);\r\n}\r\nstatic void sxgbe_set_umac_addr(void __iomem *ioaddr, unsigned char *addr,\r\nunsigned int reg_n)\r\n{\r\nunsigned long data;\r\ndata = (addr[5] << 8) | addr[4];\r\nwritel(data | SXGBE_HI_REG_AE, ioaddr + SXGBE_ADDR_HIGH(reg_n));\r\ndata = (addr[3] << 24) | (addr[2] << 16) | (addr[1] << 8) | addr[0];\r\nwritel(data, ioaddr + SXGBE_ADDR_LOW(reg_n));\r\n}\r\nstatic void sxgbe_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\nvoid __iomem *ioaddr = (void __iomem *)priv->ioaddr;\r\nunsigned int value = 0;\r\nu32 mc_filter[2];\r\nstruct netdev_hw_addr *ha;\r\nint reg = 1;\r\nnetdev_dbg(dev, "%s: # mcasts %d, # unicast %d\n",\r\n__func__, netdev_mc_count(dev), netdev_uc_count(dev));\r\nif (dev->flags & IFF_PROMISC) {\r\nvalue = SXGBE_FRAME_FILTER_PR;\r\n} else if ((netdev_mc_count(dev) > SXGBE_HASH_TABLE_SIZE) ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\nvalue = SXGBE_FRAME_FILTER_PM;\r\nwritel(0xffffffff, ioaddr + SXGBE_HASH_HIGH);\r\nwritel(0xffffffff, ioaddr + SXGBE_HASH_LOW);\r\n} else if (!netdev_mc_empty(dev)) {\r\nvalue = SXGBE_FRAME_FILTER_HMC;\r\nmemset(mc_filter, 0, sizeof(mc_filter));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint bit_nr = bitrev32(~crc32_le(~0, ha->addr, 6)) >> 26;\r\nmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\r\n}\r\nwritel(mc_filter[0], ioaddr + SXGBE_HASH_LOW);\r\nwritel(mc_filter[1], ioaddr + SXGBE_HASH_HIGH);\r\n}\r\nif (netdev_uc_count(dev) > SXGBE_MAX_PERFECT_ADDRESSES)\r\nvalue |= SXGBE_FRAME_FILTER_PR;\r\nelse {\r\nnetdev_for_each_uc_addr(ha, dev) {\r\nsxgbe_set_umac_addr(ioaddr, ha->addr, reg);\r\nreg++;\r\n}\r\n}\r\n#ifdef FRAME_FILTER_DEBUG\r\nvalue |= SXGBE_FRAME_FILTER_RA;\r\n#endif\r\nwritel(value, ioaddr + SXGBE_FRAME_FILTER);\r\nnetdev_dbg(dev, "Filter: 0x%08x\n\tHash: HI 0x%08x, LO 0x%08x\n",\r\nreadl(ioaddr + SXGBE_FRAME_FILTER),\r\nreadl(ioaddr + SXGBE_HASH_HIGH),\r\nreadl(ioaddr + SXGBE_HASH_LOW));\r\n}\r\nstatic void sxgbe_poll_controller(struct net_device *dev)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(dev);\r\ndisable_irq(priv->irq);\r\nsxgbe_rx_interrupt(priv->irq, dev);\r\nenable_irq(priv->irq);\r\n}\r\nstatic int sxgbe_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nint ret = -EOPNOTSUPP;\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ncase SIOCGMIIREG:\r\ncase SIOCSMIIREG:\r\nif (!dev->phydev)\r\nreturn -EINVAL;\r\nret = phy_mii_ioctl(dev->phydev, rq, cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void sxgbe_get_ops(struct sxgbe_ops * const ops_ptr)\r\n{\r\nops_ptr->mac = sxgbe_get_core_ops();\r\nops_ptr->desc = sxgbe_get_desc_ops();\r\nops_ptr->dma = sxgbe_get_dma_ops();\r\nops_ptr->mtl = sxgbe_get_mtl_ops();\r\nops_ptr->mii.addr = SXGBE_MDIO_SCMD_ADD_REG;\r\nops_ptr->mii.data = SXGBE_MDIO_SCMD_DATA_REG;\r\nops_ptr->link.port = 0;\r\nops_ptr->link.duplex = 0;\r\nops_ptr->link.speed = SXGBE_SPEED_10G;\r\n}\r\nstatic int sxgbe_hw_init(struct sxgbe_priv_data * const priv)\r\n{\r\nu32 ctrl_ids;\r\npriv->hw = kmalloc(sizeof(*priv->hw), GFP_KERNEL);\r\nif(!priv->hw)\r\nreturn -ENOMEM;\r\nsxgbe_get_ops(priv->hw);\r\nctrl_ids = priv->hw->mac->get_controller_version(priv->ioaddr);\r\npriv->hw->ctrl_uid = (ctrl_ids & 0x00ff0000) >> 16;\r\npriv->hw->ctrl_id = (ctrl_ids & 0x000000ff);\r\npr_info("user ID: 0x%x, Controller ID: 0x%x\n",\r\npriv->hw->ctrl_uid, priv->hw->ctrl_id);\r\nif (!sxgbe_get_hw_features(priv))\r\npr_info("Hardware features not found\n");\r\nif (priv->hw_cap.tx_csum_offload)\r\npr_info("TX Checksum offload supported\n");\r\nif (priv->hw_cap.rx_csum_offload)\r\npr_info("RX Checksum offload supported\n");\r\nreturn 0;\r\n}\r\nstatic int sxgbe_sw_reset(void __iomem *addr)\r\n{\r\nint retry_count = 10;\r\nwritel(SXGBE_DMA_SOFT_RESET, addr + SXGBE_DMA_MODE_REG);\r\nwhile (retry_count--) {\r\nif (!(readl(addr + SXGBE_DMA_MODE_REG) &\r\nSXGBE_DMA_SOFT_RESET))\r\nbreak;\r\nmdelay(10);\r\n}\r\nif (retry_count < 0)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstruct sxgbe_priv_data *sxgbe_drv_probe(struct device *device,\r\nstruct sxgbe_plat_data *plat_dat,\r\nvoid __iomem *addr)\r\n{\r\nstruct sxgbe_priv_data *priv;\r\nstruct net_device *ndev;\r\nint ret;\r\nu8 queue_num;\r\nndev = alloc_etherdev_mqs(sizeof(struct sxgbe_priv_data),\r\nSXGBE_TX_QUEUES, SXGBE_RX_QUEUES);\r\nif (!ndev)\r\nreturn NULL;\r\nSET_NETDEV_DEV(ndev, device);\r\npriv = netdev_priv(ndev);\r\npriv->device = device;\r\npriv->dev = ndev;\r\nsxgbe_set_ethtool_ops(ndev);\r\npriv->plat = plat_dat;\r\npriv->ioaddr = addr;\r\nret = sxgbe_sw_reset(priv->ioaddr);\r\nif (ret)\r\ngoto error_free_netdev;\r\nsxgbe_verify_args();\r\nret = sxgbe_hw_init(priv);\r\nif (ret)\r\ngoto error_free_netdev;\r\nret = txring_mem_alloc(priv);\r\nif (ret)\r\ngoto error_free_hw;\r\nret = rxring_mem_alloc(priv);\r\nif (ret)\r\ngoto error_free_hw;\r\nndev->netdev_ops = &sxgbe_netdev_ops;\r\nndev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\r\nNETIF_F_RXCSUM | NETIF_F_TSO | NETIF_F_TSO6 |\r\nNETIF_F_GRO;\r\nndev->features |= ndev->hw_features | NETIF_F_HIGHDMA;\r\nndev->watchdog_timeo = msecs_to_jiffies(TX_TIMEO);\r\nndev->priv_flags |= IFF_UNICAST_FLT;\r\nndev->min_mtu = MIN_MTU;\r\nndev->max_mtu = MAX_MTU;\r\npriv->msg_enable = netif_msg_init(debug, default_msg_level);\r\nif (priv->hw_cap.tcpseg_offload) {\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\r\npriv->hw->dma->enable_tso(priv->ioaddr, queue_num);\r\n}\r\n}\r\nif (priv->hw_cap.rx_csum_offload) {\r\npriv->hw->mac->enable_rx_csum(priv->ioaddr);\r\npriv->rxcsum_insertion = true;\r\n}\r\npriv->rx_pause = 1;\r\npriv->tx_pause = 1;\r\nif (!priv->plat->riwt_off) {\r\npriv->use_riwt = 1;\r\npr_info("Enable RX Mitigation via HW Watchdog Timer\n");\r\n}\r\nnetif_napi_add(ndev, &priv->napi, sxgbe_poll, 64);\r\nspin_lock_init(&priv->stats_lock);\r\npriv->sxgbe_clk = clk_get(priv->device, SXGBE_RESOURCE_NAME);\r\nif (IS_ERR(priv->sxgbe_clk)) {\r\nnetdev_warn(ndev, "%s: warning: cannot get CSR clock\n",\r\n__func__);\r\ngoto error_napi_del;\r\n}\r\nif (!priv->plat->clk_csr)\r\nsxgbe_clk_csr_set(priv);\r\nelse\r\npriv->clk_csr = priv->plat->clk_csr;\r\nret = sxgbe_mdio_register(ndev);\r\nif (ret < 0) {\r\nnetdev_dbg(ndev, "%s: MDIO bus (id: %d) registration failed\n",\r\n__func__, priv->plat->bus_id);\r\ngoto error_clk_put;\r\n}\r\nret = register_netdev(ndev);\r\nif (ret) {\r\npr_err("%s: ERROR %i registering the device\n", __func__, ret);\r\ngoto error_mdio_unregister;\r\n}\r\nsxgbe_check_ether_addr(priv);\r\nreturn priv;\r\nerror_mdio_unregister:\r\nsxgbe_mdio_unregister(ndev);\r\nerror_clk_put:\r\nclk_put(priv->sxgbe_clk);\r\nerror_napi_del:\r\nnetif_napi_del(&priv->napi);\r\nerror_free_hw:\r\nkfree(priv->hw);\r\nerror_free_netdev:\r\nfree_netdev(ndev);\r\nreturn NULL;\r\n}\r\nint sxgbe_drv_remove(struct net_device *ndev)\r\n{\r\nstruct sxgbe_priv_data *priv = netdev_priv(ndev);\r\nu8 queue_num;\r\nnetdev_info(ndev, "%s: removing driver\n", __func__);\r\nSXGBE_FOR_EACH_QUEUE(SXGBE_RX_QUEUES, queue_num) {\r\npriv->hw->mac->disable_rxqueue(priv->ioaddr, queue_num);\r\n}\r\npriv->hw->dma->stop_rx(priv->ioaddr, SXGBE_RX_QUEUES);\r\npriv->hw->dma->stop_tx(priv->ioaddr, SXGBE_TX_QUEUES);\r\npriv->hw->mac->enable_tx(priv->ioaddr, false);\r\npriv->hw->mac->enable_rx(priv->ioaddr, false);\r\nunregister_netdev(ndev);\r\nsxgbe_mdio_unregister(ndev);\r\nclk_put(priv->sxgbe_clk);\r\nnetif_napi_del(&priv->napi);\r\nkfree(priv->hw);\r\nfree_netdev(ndev);\r\nreturn 0;\r\n}\r\nint sxgbe_suspend(struct net_device *ndev)\r\n{\r\nreturn 0;\r\n}\r\nint sxgbe_resume(struct net_device *ndev)\r\n{\r\nreturn 0;\r\n}\r\nint sxgbe_freeze(struct net_device *ndev)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nint sxgbe_restore(struct net_device *ndev)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int __init sxgbe_init(void)\r\n{\r\nint ret;\r\nret = sxgbe_register_platform();\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\npr_err("driver registration failed\n");\r\nreturn ret;\r\n}\r\nstatic void __exit sxgbe_exit(void)\r\n{\r\nsxgbe_unregister_platform();\r\n}\r\nstatic int __init sxgbe_cmdline_opt(char *str)\r\n{\r\nchar *opt;\r\nif (!str || !*str)\r\nreturn -EINVAL;\r\nwhile ((opt = strsep(&str, ",")) != NULL) {\r\nif (!strncmp(opt, "eee_timer:", 6)) {\r\nif (kstrtoint(opt + 10, 0, &eee_timer))\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\npr_err("%s: ERROR broken module parameter conversion\n", __func__);\r\nreturn -EINVAL;\r\n}
