static irqreturn_t ftrtc010_rtc_interrupt(int irq, void *dev)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ftrtc010_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct ftrtc010_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned int days, hour, min, sec;\r\nunsigned long offset, time;\r\nsec = readl(rtc->rtc_base + FTRTC010_RTC_SECOND);\r\nmin = readl(rtc->rtc_base + FTRTC010_RTC_MINUTE);\r\nhour = readl(rtc->rtc_base + FTRTC010_RTC_HOUR);\r\ndays = readl(rtc->rtc_base + FTRTC010_RTC_DAYS);\r\noffset = readl(rtc->rtc_base + FTRTC010_RTC_RECORD);\r\ntime = offset + days * 86400 + hour * 3600 + min * 60 + sec;\r\nrtc_time_to_tm(time, tm);\r\nreturn 0;\r\n}\r\nstatic int ftrtc010_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct ftrtc010_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned int sec, min, hour, day;\r\nunsigned long offset, time;\r\nif (tm->tm_year >= 2148)\r\nreturn -EINVAL;\r\nrtc_tm_to_time(tm, &time);\r\nsec = readl(rtc->rtc_base + FTRTC010_RTC_SECOND);\r\nmin = readl(rtc->rtc_base + FTRTC010_RTC_MINUTE);\r\nhour = readl(rtc->rtc_base + FTRTC010_RTC_HOUR);\r\nday = readl(rtc->rtc_base + FTRTC010_RTC_DAYS);\r\noffset = time - (day * 86400 + hour * 3600 + min * 60 + sec);\r\nwritel(offset, rtc->rtc_base + FTRTC010_RTC_RECORD);\r\nwritel(0x01, rtc->rtc_base + FTRTC010_RTC_CR);\r\nreturn 0;\r\n}\r\nstatic int ftrtc010_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct ftrtc010_rtc *rtc;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nint ret;\r\nrtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\r\nif (unlikely(!rtc))\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, rtc);\r\nrtc->pclk = devm_clk_get(dev, "PCLK");\r\nif (IS_ERR(rtc->pclk)) {\r\ndev_err(dev, "could not get PCLK\n");\r\n} else {\r\nret = clk_prepare_enable(rtc->pclk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable PCLK\n");\r\nreturn ret;\r\n}\r\n}\r\nrtc->extclk = devm_clk_get(dev, "EXTCLK");\r\nif (IS_ERR(rtc->extclk)) {\r\ndev_err(dev, "could not get EXTCLK\n");\r\n} else {\r\nret = clk_prepare_enable(rtc->extclk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable EXTCLK\n");\r\nreturn ret;\r\n}\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nrtc->rtc_irq = res->start;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nrtc->rtc_base = devm_ioremap(dev, res->start,\r\nresource_size(res));\r\nif (!rtc->rtc_base)\r\nreturn -ENOMEM;\r\nret = devm_request_irq(dev, rtc->rtc_irq, ftrtc010_rtc_interrupt,\r\nIRQF_SHARED, pdev->name, dev);\r\nif (unlikely(ret))\r\nreturn ret;\r\nrtc->rtc_dev = rtc_device_register(pdev->name, dev,\r\n&ftrtc010_rtc_ops, THIS_MODULE);\r\nreturn PTR_ERR_OR_ZERO(rtc->rtc_dev);\r\n}\r\nstatic int ftrtc010_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct ftrtc010_rtc *rtc = platform_get_drvdata(pdev);\r\nif (!IS_ERR(rtc->extclk))\r\nclk_disable_unprepare(rtc->extclk);\r\nif (!IS_ERR(rtc->pclk))\r\nclk_disable_unprepare(rtc->pclk);\r\nrtc_device_unregister(rtc->rtc_dev);\r\nreturn 0;\r\n}
