static bool slow_is_prime_number(unsigned long x)\r\n{\r\nunsigned long y = int_sqrt(x);\r\nwhile (y > 1) {\r\nif ((x % y) == 0)\r\nbreak;\r\ny--;\r\n}\r\nreturn y == 1;\r\n}\r\nstatic unsigned long slow_next_prime_number(unsigned long x)\r\n{\r\nwhile (x < ULONG_MAX && !slow_is_prime_number(++x))\r\n;\r\nreturn x;\r\n}\r\nstatic unsigned long clear_multiples(unsigned long x,\r\nunsigned long *p,\r\nunsigned long start,\r\nunsigned long end)\r\n{\r\nunsigned long m;\r\nm = 2 * x;\r\nif (m < start)\r\nm = roundup(start, x);\r\nwhile (m < end) {\r\n__clear_bit(m, p);\r\nm += x;\r\n}\r\nreturn x;\r\n}\r\nstatic bool expand_to_next_prime(unsigned long x)\r\n{\r\nconst struct primes *p;\r\nstruct primes *new;\r\nunsigned long sz, y;\r\nsz = 2 * x;\r\nif (sz < x)\r\nreturn false;\r\nsz = round_up(sz, BITS_PER_LONG);\r\nnew = kmalloc(sizeof(*new) + bitmap_size(sz),\r\nGFP_KERNEL | __GFP_NOWARN);\r\nif (!new)\r\nreturn false;\r\nmutex_lock(&lock);\r\np = rcu_dereference_protected(primes, lockdep_is_held(&lock));\r\nif (x < p->last) {\r\nkfree(new);\r\ngoto unlock;\r\n}\r\nbitmap_fill(new->primes, sz);\r\nbitmap_copy(new->primes, p->primes, p->sz);\r\nfor (y = 2UL; y < sz; y = find_next_bit(new->primes, sz, y + 1))\r\nnew->last = clear_multiples(y, new->primes, p->sz, sz);\r\nnew->sz = sz;\r\nBUG_ON(new->last <= x);\r\nrcu_assign_pointer(primes, new);\r\nif (p != &small_primes)\r\nkfree_rcu((struct primes *)p, rcu);\r\nunlock:\r\nmutex_unlock(&lock);\r\nreturn true;\r\n}\r\nstatic void free_primes(void)\r\n{\r\nconst struct primes *p;\r\nmutex_lock(&lock);\r\np = rcu_dereference_protected(primes, lockdep_is_held(&lock));\r\nif (p != &small_primes) {\r\nrcu_assign_pointer(primes, &small_primes);\r\nkfree_rcu((struct primes *)p, rcu);\r\n}\r\nmutex_unlock(&lock);\r\n}\r\nunsigned long next_prime_number(unsigned long x)\r\n{\r\nconst struct primes *p;\r\nrcu_read_lock();\r\np = rcu_dereference(primes);\r\nwhile (x >= p->last) {\r\nrcu_read_unlock();\r\nif (!expand_to_next_prime(x))\r\nreturn slow_next_prime_number(x);\r\nrcu_read_lock();\r\np = rcu_dereference(primes);\r\n}\r\nx = find_next_bit(p->primes, p->last, x + 1);\r\nrcu_read_unlock();\r\nreturn x;\r\n}\r\nbool is_prime_number(unsigned long x)\r\n{\r\nconst struct primes *p;\r\nbool result;\r\nrcu_read_lock();\r\np = rcu_dereference(primes);\r\nwhile (x >= p->sz) {\r\nrcu_read_unlock();\r\nif (!expand_to_next_prime(x))\r\nreturn slow_is_prime_number(x);\r\nrcu_read_lock();\r\np = rcu_dereference(primes);\r\n}\r\nresult = test_bit(x, p->primes);\r\nrcu_read_unlock();\r\nreturn result;\r\n}\r\nstatic void dump_primes(void)\r\n{\r\nconst struct primes *p;\r\nchar *buf;\r\nbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nrcu_read_lock();\r\np = rcu_dereference(primes);\r\nif (buf)\r\nbitmap_print_to_pagebuf(true, buf, p->primes, p->sz);\r\npr_info("primes.{last=%lu, .sz=%lu, .primes[]=...x%lx} = %s",\r\np->last, p->sz, p->primes[BITS_TO_LONGS(p->sz) - 1], buf);\r\nrcu_read_unlock();\r\nkfree(buf);\r\n}\r\nstatic int selftest(unsigned long max)\r\n{\r\nunsigned long x, last;\r\nif (!max)\r\nreturn 0;\r\nfor (last = 0, x = 2; x < max; x++) {\r\nbool slow = slow_is_prime_number(x);\r\nbool fast = is_prime_number(x);\r\nif (slow != fast) {\r\npr_err("inconsistent result for is-prime(%lu): slow=%s, fast=%s!",\r\nx, slow ? "yes" : "no", fast ? "yes" : "no");\r\ngoto err;\r\n}\r\nif (!slow)\r\ncontinue;\r\nif (next_prime_number(last) != x) {\r\npr_err("incorrect result for next-prime(%lu): expected %lu, got %lu",\r\nlast, x, next_prime_number(last));\r\ngoto err;\r\n}\r\nlast = x;\r\n}\r\npr_info("selftest(%lu) passed, last prime was %lu", x, last);\r\nreturn 0;\r\nerr:\r\ndump_primes();\r\nreturn -EINVAL;\r\n}\r\nstatic int __init primes_init(void)\r\n{\r\nreturn selftest(selftest_max);\r\n}\r\nstatic void __exit primes_exit(void)\r\n{\r\nfree_primes();\r\n}
