static int stx104_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val, int *val2, long mask)\r\n{\r\nstruct stx104_iio *const priv = iio_priv(indio_dev);\r\nunsigned int adc_config;\r\nint adbu;\r\nint gain;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_HARDWAREGAIN:\r\nadc_config = inb(priv->base + 11);\r\ngain = adc_config & 0x3;\r\n*val = 1 << gain;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_RAW:\r\nif (chan->output) {\r\n*val = priv->chan_out_states[chan->channel];\r\nreturn IIO_VAL_INT;\r\n}\r\noutb(chan->channel | (chan->channel << 4), priv->base + 2);\r\noutb(0, priv->base);\r\nwhile (inb(priv->base + 8) & BIT(7));\r\n*val = inw(priv->base);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_OFFSET:\r\nadc_config = inb(priv->base + 11);\r\nadbu = !(adc_config & BIT(2));\r\n*val = -32768 * adbu;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nadc_config = inb(priv->base + 11);\r\nadbu = !(adc_config & BIT(2));\r\ngain = adc_config & 0x3;\r\n*val = 5;\r\n*val2 = 15 - adbu + gain;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int stx104_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val, int val2, long mask)\r\n{\r\nstruct stx104_iio *const priv = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_HARDWAREGAIN:\r\nswitch (val) {\r\ncase 1:\r\noutb(0, priv->base + 11);\r\nbreak;\r\ncase 2:\r\noutb(1, priv->base + 11);\r\nbreak;\r\ncase 4:\r\noutb(2, priv->base + 11);\r\nbreak;\r\ncase 8:\r\noutb(3, priv->base + 11);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ncase IIO_CHAN_INFO_RAW:\r\nif (chan->output) {\r\nif ((unsigned int)val > 65535)\r\nreturn -EINVAL;\r\npriv->chan_out_states[chan->channel] = val;\r\noutw(val, priv->base + 4 + 2 * chan->channel);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int stx104_gpio_get_direction(struct gpio_chip *chip,\r\nunsigned int offset)\r\n{\r\nif (offset < 4)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int stx104_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned int offset)\r\n{\r\nif (offset >= 4)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int stx104_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned int offset, int value)\r\n{\r\nif (offset < 4)\r\nreturn -EINVAL;\r\nchip->set(chip, offset, value);\r\nreturn 0;\r\n}\r\nstatic int stx104_gpio_get(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nstruct stx104_gpio *const stx104gpio = gpiochip_get_data(chip);\r\nif (offset >= 4)\r\nreturn -EINVAL;\r\nreturn !!(inb(stx104gpio->base) & BIT(offset));\r\n}\r\nstatic void stx104_gpio_set(struct gpio_chip *chip, unsigned int offset,\r\nint value)\r\n{\r\nstruct stx104_gpio *const stx104gpio = gpiochip_get_data(chip);\r\nconst unsigned int mask = BIT(offset) >> 4;\r\nunsigned long flags;\r\nif (offset < 4)\r\nreturn;\r\nspin_lock_irqsave(&stx104gpio->lock, flags);\r\nif (value)\r\nstx104gpio->out_state |= mask;\r\nelse\r\nstx104gpio->out_state &= ~mask;\r\noutb(stx104gpio->out_state, stx104gpio->base);\r\nspin_unlock_irqrestore(&stx104gpio->lock, flags);\r\n}\r\nstatic void stx104_gpio_set_multiple(struct gpio_chip *chip,\r\nunsigned long *mask, unsigned long *bits)\r\n{\r\nstruct stx104_gpio *const stx104gpio = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nif (!(*mask & 0xF0))\r\nreturn;\r\n*mask >>= 4;\r\n*bits >>= 4;\r\nspin_lock_irqsave(&stx104gpio->lock, flags);\r\nstx104gpio->out_state &= ~*mask;\r\nstx104gpio->out_state |= *mask & *bits;\r\noutb(stx104gpio->out_state, stx104gpio->base);\r\nspin_unlock_irqrestore(&stx104gpio->lock, flags);\r\n}\r\nstatic int stx104_probe(struct device *dev, unsigned int id)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct stx104_iio *priv;\r\nstruct stx104_gpio *stx104gpio;\r\nint err;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(*priv));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nstx104gpio = devm_kzalloc(dev, sizeof(*stx104gpio), GFP_KERNEL);\r\nif (!stx104gpio)\r\nreturn -ENOMEM;\r\nif (!devm_request_region(dev, base[id], STX104_EXTENT,\r\ndev_name(dev))) {\r\ndev_err(dev, "Unable to lock port addresses (0x%X-0x%X)\n",\r\nbase[id], base[id] + STX104_EXTENT);\r\nreturn -EBUSY;\r\n}\r\nindio_dev->info = &stx104_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nif (inb(base[id] + 8) & BIT(5)) {\r\nindio_dev->num_channels = ARRAY_SIZE(stx104_channels_diff);\r\nindio_dev->channels = stx104_channels_diff;\r\n} else {\r\nindio_dev->num_channels = ARRAY_SIZE(stx104_channels_sing);\r\nindio_dev->channels = stx104_channels_sing;\r\n}\r\nindio_dev->name = dev_name(dev);\r\nindio_dev->dev.parent = dev;\r\npriv = iio_priv(indio_dev);\r\npriv->base = base[id];\r\noutb(0, base[id] + 9);\r\noutb(0, base[id] + 11);\r\noutw(0, base[id] + 4);\r\noutw(0, base[id] + 6);\r\nstx104gpio->chip.label = dev_name(dev);\r\nstx104gpio->chip.parent = dev;\r\nstx104gpio->chip.owner = THIS_MODULE;\r\nstx104gpio->chip.base = -1;\r\nstx104gpio->chip.ngpio = STX104_NGPIO;\r\nstx104gpio->chip.names = stx104_names;\r\nstx104gpio->chip.get_direction = stx104_gpio_get_direction;\r\nstx104gpio->chip.direction_input = stx104_gpio_direction_input;\r\nstx104gpio->chip.direction_output = stx104_gpio_direction_output;\r\nstx104gpio->chip.get = stx104_gpio_get;\r\nstx104gpio->chip.set = stx104_gpio_set;\r\nstx104gpio->chip.set_multiple = stx104_gpio_set_multiple;\r\nstx104gpio->base = base[id] + 3;\r\nstx104gpio->out_state = 0x0;\r\nspin_lock_init(&stx104gpio->lock);\r\nerr = devm_gpiochip_add_data(dev, &stx104gpio->chip, stx104gpio);\r\nif (err) {\r\ndev_err(dev, "GPIO registering failed (%d)\n", err);\r\nreturn err;\r\n}\r\nreturn devm_iio_device_register(dev, indio_dev);\r\n}
