struct net_device * __init sun3lance_probe(int unit)\r\n{\r\nstruct net_device *dev;\r\nstatic int found;\r\nint err = -ENODEV;\r\nif (!MACH_IS_SUN3 && !MACH_IS_SUN3X)\r\nreturn ERR_PTR(-ENODEV);\r\nswitch(idprom->id_machtype) {\r\ncase SM_SUN3|SM_3_50:\r\ncase SM_SUN3|SM_3_60:\r\ncase SM_SUN3X|SM_3_80:\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nif (found)\r\nreturn ERR_PTR(-ENODEV);\r\ndev = alloc_etherdev(sizeof(struct lance_private));\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\n}\r\nif (!lance_probe(dev))\r\ngoto out;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out1;\r\nfound = 1;\r\nreturn dev;\r\nout1:\r\n#ifdef CONFIG_SUN3\r\niounmap((void __iomem *)dev->base_addr);\r\n#endif\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init lance_probe( struct net_device *dev)\r\n{\r\nunsigned long ioaddr;\r\nstruct lance_private *lp;\r\nint i;\r\nstatic int did_version;\r\nvolatile unsigned short *ioaddr_probe;\r\nunsigned short tmp1, tmp2;\r\n#ifdef CONFIG_SUN3\r\nioaddr = (unsigned long)ioremap(LANCE_OBIO, PAGE_SIZE);\r\nif (!ioaddr)\r\nreturn 0;\r\n#else\r\nioaddr = SUN3X_LANCE;\r\n#endif\r\nioaddr_probe = (volatile unsigned short *)ioaddr;\r\ntmp1 = ioaddr_probe[0];\r\ntmp2 = ioaddr_probe[1];\r\nioaddr_probe[1] = CSR0;\r\nioaddr_probe[0] = CSR0_INIT | CSR0_STOP;\r\nif(ioaddr_probe[0] != CSR0_STOP) {\r\nioaddr_probe[0] = tmp1;\r\nioaddr_probe[1] = tmp2;\r\n#ifdef CONFIG_SUN3\r\niounmap((void __iomem *)ioaddr);\r\n#endif\r\nreturn 0;\r\n}\r\nlp = netdev_priv(dev);\r\nMEM = dvma_malloc_align(sizeof(struct lance_memory), 0x10000);\r\nif (MEM == NULL) {\r\n#ifdef CONFIG_SUN3\r\niounmap((void __iomem *)ioaddr);\r\n#endif\r\nprintk(KERN_WARNING "SUN3 Lance couldn't allocate DVMA memory\n");\r\nreturn 0;\r\n}\r\nlp->iobase = (volatile unsigned short *)ioaddr;\r\ndev->base_addr = (unsigned long)ioaddr;\r\nREGA(CSR0) = CSR0_STOP;\r\nif (request_irq(LANCE_IRQ, lance_interrupt, 0, "SUN3 Lance", dev) < 0) {\r\n#ifdef CONFIG_SUN3\r\niounmap((void __iomem *)ioaddr);\r\n#endif\r\ndvma_free((void *)MEM);\r\nprintk(KERN_WARNING "SUN3 Lance unable to allocate IRQ\n");\r\nreturn 0;\r\n}\r\ndev->irq = (unsigned short)LANCE_IRQ;\r\nprintk("%s: SUN3 Lance at io %#lx, mem %#lx, irq %d, hwaddr ",\r\ndev->name,\r\n(unsigned long)ioaddr,\r\n(unsigned long)MEM,\r\ndev->irq);\r\nfor(i = 0; i < 6 ; i++)\r\ndev->dev_addr[i] = idprom->id_ethaddr[i];\r\nMEM->init.hwaddr[0] = dev->dev_addr[1];\r\nMEM->init.hwaddr[1] = dev->dev_addr[0];\r\nMEM->init.hwaddr[2] = dev->dev_addr[3];\r\nMEM->init.hwaddr[3] = dev->dev_addr[2];\r\nMEM->init.hwaddr[4] = dev->dev_addr[5];\r\nMEM->init.hwaddr[5] = dev->dev_addr[4];\r\nprintk("%pM\n", dev->dev_addr);\r\nMEM->init.mode = 0x0000;\r\nMEM->init.filter[0] = 0x00000000;\r\nMEM->init.filter[1] = 0x00000000;\r\nMEM->init.rdra = dvma_vtob(MEM->rx_head);\r\nMEM->init.rlen = (RX_LOG_RING_SIZE << 13) |\r\n(dvma_vtob(MEM->rx_head) >> 16);\r\nMEM->init.tdra = dvma_vtob(MEM->tx_head);\r\nMEM->init.tlen = (TX_LOG_RING_SIZE << 13) |\r\n(dvma_vtob(MEM->tx_head) >> 16);\r\nDPRINTK(2, ("initaddr: %08lx rx_ring: %08lx tx_ring: %08lx\n",\r\ndvma_vtob(&(MEM->init)), dvma_vtob(MEM->rx_head),\r\n(dvma_vtob(MEM->tx_head))));\r\nif (did_version++ == 0)\r\nprintk( version );\r\ndev->netdev_ops = &lance_netdev_ops;\r\nset_bit(__LINK_STATE_PRESENT, &dev->state);\r\nreturn 1;\r\n}\r\nstatic int lance_open( struct net_device *dev )\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nint i;\r\nDPRINTK( 2, ( "%s: lance_open()\n", dev->name ));\r\nREGA(CSR0) = CSR0_STOP;\r\nlance_init_ring(dev);\r\nREGA(CSR0) = CSR0_INIT;\r\ni = 1000000;\r\nwhile (--i > 0)\r\nif (DREG & CSR0_IDON)\r\nbreak;\r\nif (i <= 0 || (DREG & CSR0_ERR)) {\r\nDPRINTK( 2, ( "lance_open(): opening %s failed, i=%d, csr0=%04x\n",\r\ndev->name, i, DREG ));\r\nDREG = CSR0_STOP;\r\nreturn -EIO;\r\n}\r\nDREG = CSR0_IDON | CSR0_STRT | CSR0_INEA;\r\nnetif_start_queue(dev);\r\nDPRINTK( 2, ( "%s: LANCE is open, csr0 %04x\n", dev->name, DREG ));\r\nreturn 0;\r\n}\r\nstatic void lance_init_ring( struct net_device *dev )\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nint i;\r\nlp->lock = 0;\r\nlp->tx_full = 0;\r\nlp->new_rx = lp->new_tx = 0;\r\nlp->old_rx = lp->old_tx = 0;\r\nfor( i = 0; i < TX_RING_SIZE; i++ ) {\r\nMEM->tx_head[i].base = dvma_vtob(MEM->tx_data[i]);\r\nMEM->tx_head[i].flag = 0;\r\nMEM->tx_head[i].base_hi =\r\n(dvma_vtob(MEM->tx_data[i])) >>16;\r\nMEM->tx_head[i].length = 0;\r\nMEM->tx_head[i].misc = 0;\r\n}\r\nfor( i = 0; i < RX_RING_SIZE; i++ ) {\r\nMEM->rx_head[i].base = dvma_vtob(MEM->rx_data[i]);\r\nMEM->rx_head[i].flag = RMD1_OWN_CHIP;\r\nMEM->rx_head[i].base_hi =\r\n(dvma_vtob(MEM->rx_data[i])) >> 16;\r\nMEM->rx_head[i].buf_length = -PKT_BUF_SZ | 0xf000;\r\nMEM->rx_head[i].msg_length = 0;\r\n}\r\nMEM->init.hwaddr[0] = dev->dev_addr[1];\r\nMEM->init.hwaddr[1] = dev->dev_addr[0];\r\nMEM->init.hwaddr[2] = dev->dev_addr[3];\r\nMEM->init.hwaddr[3] = dev->dev_addr[2];\r\nMEM->init.hwaddr[4] = dev->dev_addr[5];\r\nMEM->init.hwaddr[5] = dev->dev_addr[4];\r\nMEM->init.mode = 0x0000;\r\nMEM->init.filter[0] = 0x00000000;\r\nMEM->init.filter[1] = 0x00000000;\r\nMEM->init.rdra = dvma_vtob(MEM->rx_head);\r\nMEM->init.rlen = (RX_LOG_RING_SIZE << 13) |\r\n(dvma_vtob(MEM->rx_head) >> 16);\r\nMEM->init.tdra = dvma_vtob(MEM->tx_head);\r\nMEM->init.tlen = (TX_LOG_RING_SIZE << 13) |\r\n(dvma_vtob(MEM->tx_head) >> 16);\r\nREGA(CSR1) = dvma_vtob(&(MEM->init));\r\nREGA(CSR2) = dvma_vtob(&(MEM->init)) >> 16;\r\n#ifdef CONFIG_SUN3X\r\nREGA(CSR3) = CSR3_BSWP | CSR3_ACON | CSR3_BCON;\r\n#else\r\nREGA(CSR3) = CSR3_BSWP;\r\n#endif\r\n}\r\nstatic int lance_start_xmit( struct sk_buff *skb, struct net_device *dev )\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nint entry, len;\r\nstruct lance_tx_head *head;\r\nunsigned long flags;\r\nDPRINTK( 1, ( "%s: transmit start.\n",\r\ndev->name));\r\nif (netif_queue_stopped(dev)) {\r\nint tickssofar = jiffies - dev_trans_start(dev);\r\nif (tickssofar < HZ/5)\r\nreturn NETDEV_TX_BUSY;\r\nDPRINTK( 1, ( "%s: transmit timed out, status %04x, resetting.\n",\r\ndev->name, DREG ));\r\nDREG = CSR0_STOP;\r\nREGA(CSR3) = CSR3_BSWP;\r\ndev->stats.tx_errors++;\r\nif(lance_debug >= 2) {\r\nint i;\r\nprintk("Ring data: old_tx %d new_tx %d%s new_rx %d\n",\r\nlp->old_tx, lp->new_tx,\r\nlp->tx_full ? " (full)" : "",\r\nlp->new_rx );\r\nfor( i = 0 ; i < RX_RING_SIZE; i++ )\r\nprintk( "rx #%d: base=%04x blen=%04x mlen=%04x\n",\r\ni, MEM->rx_head[i].base,\r\n-MEM->rx_head[i].buf_length,\r\nMEM->rx_head[i].msg_length);\r\nfor( i = 0 ; i < TX_RING_SIZE; i++ )\r\nprintk("tx #%d: base=%04x len=%04x misc=%04x\n",\r\ni, MEM->tx_head[i].base,\r\n-MEM->tx_head[i].length,\r\nMEM->tx_head[i].misc );\r\n}\r\nlance_init_ring(dev);\r\nREGA( CSR0 ) = CSR0_INEA | CSR0_INIT | CSR0_STRT;\r\nnetif_start_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nnetif_stop_queue(dev);\r\nif (test_and_set_bit( 0, (void*)&lp->lock ) != 0) {\r\nprintk( "%s: tx queue lock!.\n", dev->name);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nAREG = CSR0;\r\nDPRINTK( 2, ( "%s: lance_start_xmit() called, csr0 %4.4x.\n",\r\ndev->name, DREG ));\r\n#ifdef CONFIG_SUN3X\r\nif(!(DREG & CSR0_INIT)) {\r\nDPRINTK( 1, ("INIT not set, reinitializing...\n"));\r\nREGA( CSR0 ) = CSR0_STOP;\r\nlance_init_ring(dev);\r\nREGA( CSR0 ) = CSR0_INIT | CSR0_STRT;\r\n}\r\n#endif\r\n#if 0\r\nif (lance_debug >= 2) {\r\nprintk( "%s: TX pkt %d type 0x%04x"\r\n" from %s to %s"\r\n" data at 0x%08x len %d\n",\r\ndev->name, lp->new_tx, ((u_short *)skb->data)[6],\r\nDEV_ADDR(&skb->data[6]), DEV_ADDR(skb->data),\r\n(int)skb->data, (int)skb->len );\r\n}\r\n#endif\r\nlocal_irq_save(flags);\r\nentry = lp->new_tx;\r\nhead = &(MEM->tx_head[entry]);\r\nlen = (ETH_ZLEN < skb->len) ? skb->len : ETH_ZLEN;\r\nhead->length = (-len) | 0xf000;\r\nhead->misc = 0;\r\nskb_copy_from_linear_data(skb, PKTBUF_ADDR(head), skb->len);\r\nif (len != skb->len)\r\nmemset(PKTBUF_ADDR(head) + skb->len, 0, len-skb->len);\r\nhead->flag = TMD1_OWN_CHIP | TMD1_ENP | TMD1_STP;\r\nlp->new_tx = (lp->new_tx + 1) & TX_RING_MOD_MASK;\r\ndev->stats.tx_bytes += skb->len;\r\nREGA(CSR0) = CSR0_INEA | CSR0_TDMD | CSR0_STRT;\r\nAREG = CSR0;\r\nDPRINTK( 2, ( "%s: lance_start_xmit() exiting, csr0 %4.4x.\n",\r\ndev->name, DREG ));\r\ndev_kfree_skb(skb);\r\nlp->lock = 0;\r\nif ((MEM->tx_head[(entry+1) & TX_RING_MOD_MASK].flag & TMD1_OWN) ==\r\nTMD1_OWN_HOST)\r\nnetif_start_queue(dev);\r\nlocal_irq_restore(flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t lance_interrupt( int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct lance_private *lp = netdev_priv(dev);\r\nint csr0;\r\nstatic int in_interrupt;\r\nif (dev == NULL) {\r\nDPRINTK( 1, ( "lance_interrupt(): invalid dev_id\n" ));\r\nreturn IRQ_NONE;\r\n}\r\nif (in_interrupt)\r\nDPRINTK( 2, ( "%s: Re-entering the interrupt handler.\n", dev->name ));\r\nin_interrupt = 1;\r\nstill_more:\r\nflush_cache_all();\r\nAREG = CSR0;\r\ncsr0 = DREG;\r\nDREG = csr0 & (CSR0_TINT | CSR0_RINT | CSR0_IDON);\r\nif(csr0 & CSR0_ERR)\r\nDREG = CSR0_BABL | CSR0_MERR | CSR0_CERR | CSR0_MISS;\r\nDPRINTK( 2, ( "%s: interrupt csr0=%04x new csr=%04x.\n",\r\ndev->name, csr0, DREG ));\r\nif (csr0 & CSR0_TINT) {\r\nint old_tx = lp->old_tx;\r\nwhile( old_tx != lp->new_tx) {\r\nstruct lance_tx_head *head = &(MEM->tx_head[old_tx]);\r\nDPRINTK(3, ("on tx_ring %d\n", old_tx));\r\nif (head->flag & TMD1_OWN_CHIP)\r\nbreak;\r\nif (head->flag & TMD1_ERR) {\r\nint status = head->misc;\r\ndev->stats.tx_errors++;\r\nif (status & TMD3_RTRY) dev->stats.tx_aborted_errors++;\r\nif (status & TMD3_LCAR) dev->stats.tx_carrier_errors++;\r\nif (status & TMD3_LCOL) dev->stats.tx_window_errors++;\r\nif (status & (TMD3_UFLO | TMD3_BUFF)) {\r\ndev->stats.tx_fifo_errors++;\r\nprintk("%s: Tx FIFO error\n",\r\ndev->name);\r\nREGA(CSR0) = CSR0_STOP;\r\nREGA(CSR3) = CSR3_BSWP;\r\nlance_init_ring(dev);\r\nREGA(CSR0) = CSR0_STRT | CSR0_INEA;\r\nreturn IRQ_HANDLED;\r\n}\r\n} else if(head->flag & (TMD1_ENP | TMD1_STP)) {\r\nhead->flag &= ~(TMD1_ENP | TMD1_STP);\r\nif(head->flag & (TMD1_ONE | TMD1_MORE))\r\ndev->stats.collisions++;\r\ndev->stats.tx_packets++;\r\nDPRINTK(3, ("cleared tx ring %d\n", old_tx));\r\n}\r\nold_tx = (old_tx +1) & TX_RING_MOD_MASK;\r\n}\r\nlp->old_tx = old_tx;\r\n}\r\nif (netif_queue_stopped(dev)) {\r\nnetif_start_queue(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nif (csr0 & CSR0_RINT)\r\nlance_rx( dev );\r\nif (csr0 & CSR0_BABL) dev->stats.tx_errors++;\r\nif (csr0 & CSR0_MISS) dev->stats.rx_errors++;\r\nif (csr0 & CSR0_MERR) {\r\nDPRINTK( 1, ( "%s: Bus master arbitration failure (?!?), "\r\n"status %04x.\n", dev->name, csr0 ));\r\nREGA(CSR0) = CSR0_STOP;\r\nREGA(CSR3) = CSR3_BSWP;\r\nlance_init_ring(dev);\r\nREGA(CSR0) = CSR0_STRT | CSR0_INEA;\r\n}\r\nREGA(CSR0) = CSR0_INEA;\r\nif(DREG & (CSR0_RINT | CSR0_TINT)) {\r\nDPRINTK(2, ("restarting interrupt, csr0=%#04x\n", DREG));\r\ngoto still_more;\r\n}\r\nDPRINTK( 2, ( "%s: exiting interrupt, csr0=%#04x.\n",\r\ndev->name, DREG ));\r\nin_interrupt = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lance_rx( struct net_device *dev )\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nint entry = lp->new_rx;\r\nwhile( (MEM->rx_head[entry].flag & RMD1_OWN) == RMD1_OWN_HOST ) {\r\nstruct lance_rx_head *head = &(MEM->rx_head[entry]);\r\nint status = head->flag;\r\nif (status != (RMD1_ENP|RMD1_STP)) {\r\nif (status & RMD1_ENP)\r\ndev->stats.rx_errors++;\r\nif (status & RMD1_FRAM) dev->stats.rx_frame_errors++;\r\nif (status & RMD1_OFLO) dev->stats.rx_over_errors++;\r\nif (status & RMD1_CRC) dev->stats.rx_crc_errors++;\r\nif (status & RMD1_BUFF) dev->stats.rx_fifo_errors++;\r\nhead->flag &= (RMD1_ENP|RMD1_STP);\r\n} else {\r\nshort pkt_len = (head->msg_length & 0xfff) - 4;\r\nstruct sk_buff *skb;\r\nif (pkt_len < 60) {\r\nprintk( "%s: Runt packet!\n", dev->name );\r\ndev->stats.rx_errors++;\r\n}\r\nelse {\r\nskb = netdev_alloc_skb(dev, pkt_len + 2);\r\nif (skb == NULL) {\r\ndev->stats.rx_dropped++;\r\nhead->msg_length = 0;\r\nhead->flag |= RMD1_OWN_CHIP;\r\nlp->new_rx = (lp->new_rx+1) &\r\nRX_RING_MOD_MASK;\r\n}\r\n#if 0\r\nif (lance_debug >= 3) {\r\nu_char *data = PKTBUF_ADDR(head);\r\nprintk("%s: RX pkt %d type 0x%04x"\r\n" from %pM to %pM",\r\ndev->name, lp->new_tx, ((u_short *)data)[6],\r\n&data[6], data);\r\nprintk(" data %02x %02x %02x %02x %02x %02x %02x %02x "\r\n"len %d at %08x\n",\r\ndata[15], data[16], data[17], data[18],\r\ndata[19], data[20], data[21], data[22],\r\npkt_len, data);\r\n}\r\n#endif\r\nif (lance_debug >= 3) {\r\nu_char *data = PKTBUF_ADDR(head);\r\nprintk( "%s: RX pkt %d type 0x%04x len %d\n ", dev->name, entry, ((u_short *)data)[6], pkt_len);\r\n}\r\nskb_reserve( skb, 2 );\r\nskb_put( skb, pkt_len );\r\nskb_copy_to_linear_data(skb,\r\nPKTBUF_ADDR(head),\r\npkt_len);\r\nskb->protocol = eth_type_trans( skb, dev );\r\nnetif_rx( skb );\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\n}\r\nhead->msg_length = 0;\r\nhead->flag = RMD1_OWN_CHIP;\r\nentry = lp->new_rx = (lp->new_rx +1) & RX_RING_MOD_MASK;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lance_close( struct net_device *dev )\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nAREG = CSR0;\r\nDPRINTK( 2, ( "%s: Shutting down ethercard, status was %2.2x.\n",\r\ndev->name, DREG ));\r\nDREG = CSR0_STOP;\r\nreturn 0;\r\n}\r\nstatic void set_multicast_list( struct net_device *dev )\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nif(netif_queue_stopped(dev))\r\nreturn;\r\nDREG = CSR0_STOP;\r\nif (dev->flags & IFF_PROMISC) {\r\nDPRINTK( 3, ( "%s: Promiscuous mode enabled.\n", dev->name ));\r\nREGA( CSR15 ) = 0x8000;\r\n} else {\r\nshort multicast_table[4];\r\nint num_addrs = netdev_mc_count(dev);\r\nint i;\r\nmemset( multicast_table, (num_addrs == 0) ? 0 : -1,\r\nsizeof(multicast_table) );\r\nfor( i = 0; i < 4; i++ )\r\nREGA( CSR8+i ) = multicast_table[i];\r\nREGA( CSR15 ) = 0;\r\n}\r\nREGA( CSR3 ) = CSR3_BSWP;\r\nREGA( CSR0 ) = CSR0_IDON | CSR0_INEA | CSR0_STRT;\r\n}\r\nint __init init_module(void)\r\n{\r\nsun3lance_dev = sun3lance_probe(-1);\r\nreturn PTR_ERR_OR_ZERO(sun3lance_dev);\r\n}\r\nvoid __exit cleanup_module(void)\r\n{\r\nunregister_netdev(sun3lance_dev);\r\n#ifdef CONFIG_SUN3\r\niounmap((void __iomem *)sun3lance_dev->base_addr);\r\n#endif\r\nfree_netdev(sun3lance_dev);\r\n}
