static inline void locomokbd_charge_all(unsigned long membase)\r\n{\r\nlocomo_writel(0x00FF, membase + LOCOMO_KSC);\r\n}\r\nstatic inline void locomokbd_activate_all(unsigned long membase)\r\n{\r\nunsigned long r;\r\nlocomo_writel(0, membase + LOCOMO_KSC);\r\nr = locomo_readl(membase + LOCOMO_KIC);\r\nr &= 0xFEFF;\r\nlocomo_writel(r, membase + LOCOMO_KIC);\r\n}\r\nstatic inline void locomokbd_activate_col(unsigned long membase, int col)\r\n{\r\nunsigned short nset;\r\nunsigned short nbset;\r\nnset = 0xFF & ~(1 << col);\r\nnbset = (nset << 8) + nset;\r\nlocomo_writel(nbset, membase + LOCOMO_KSC);\r\n}\r\nstatic inline void locomokbd_reset_col(unsigned long membase, int col)\r\n{\r\nunsigned short nbset;\r\nnbset = ((0xFF & ~(1 << col)) << 8) + 0xFF;\r\nlocomo_writel(nbset, membase + LOCOMO_KSC);\r\n}\r\nstatic void locomokbd_scankeyboard(struct locomokbd *locomokbd)\r\n{\r\nunsigned int row, col, rowd;\r\nunsigned long flags;\r\nunsigned int num_pressed;\r\nunsigned long membase = locomokbd->base;\r\nspin_lock_irqsave(&locomokbd->lock, flags);\r\nlocomokbd_charge_all(membase);\r\nnum_pressed = 0;\r\nfor (col = 0; col < KB_COLS; col++) {\r\nlocomokbd_activate_col(membase, col);\r\nudelay(KB_DELAY);\r\nrowd = ~locomo_readl(membase + LOCOMO_KIB);\r\nfor (row = 0; row < KB_ROWS; row++) {\r\nunsigned int scancode, pressed, key;\r\nscancode = SCANCODE(col, row);\r\npressed = rowd & KB_ROWMASK(row);\r\nkey = locomokbd->keycode[scancode];\r\ninput_report_key(locomokbd->input, key, pressed);\r\nif (likely(!pressed))\r\ncontinue;\r\nnum_pressed++;\r\nif (unlikely(key == KEY_ESC)) {\r\nif (!time_after(jiffies,\r\nlocomokbd->suspend_jiffies + HZ))\r\ncontinue;\r\nif (locomokbd->count_cancel++\r\n!= (HZ/SCAN_INTERVAL + 1))\r\ncontinue;\r\ninput_event(locomokbd->input, EV_PWR,\r\nKEY_SUSPEND, 1);\r\nlocomokbd->suspend_jiffies = jiffies;\r\n} else\r\nlocomokbd->count_cancel = 0;\r\n}\r\nlocomokbd_reset_col(membase, col);\r\n}\r\nlocomokbd_activate_all(membase);\r\ninput_sync(locomokbd->input);\r\nif (num_pressed)\r\nmod_timer(&locomokbd->timer, jiffies + SCAN_INTERVAL);\r\nelse\r\nlocomokbd->count_cancel = 0;\r\nspin_unlock_irqrestore(&locomokbd->lock, flags);\r\n}\r\nstatic irqreturn_t locomokbd_interrupt(int irq, void *dev_id)\r\n{\r\nstruct locomokbd *locomokbd = dev_id;\r\nu16 r;\r\nr = locomo_readl(locomokbd->base + LOCOMO_KIC);\r\nif ((r & 0x0001) == 0)\r\nreturn IRQ_HANDLED;\r\nlocomo_writel(r & ~0x0100, locomokbd->base + LOCOMO_KIC);\r\nudelay(100);\r\nlocomokbd_scankeyboard(locomokbd);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void locomokbd_timer_callback(unsigned long data)\r\n{\r\nstruct locomokbd *locomokbd = (struct locomokbd *) data;\r\nlocomokbd_scankeyboard(locomokbd);\r\n}\r\nstatic int locomokbd_open(struct input_dev *dev)\r\n{\r\nstruct locomokbd *locomokbd = input_get_drvdata(dev);\r\nu16 r;\r\nr = locomo_readl(locomokbd->base + LOCOMO_KIC) | 0x0010;\r\nlocomo_writel(r, locomokbd->base + LOCOMO_KIC);\r\nreturn 0;\r\n}\r\nstatic void locomokbd_close(struct input_dev *dev)\r\n{\r\nstruct locomokbd *locomokbd = input_get_drvdata(dev);\r\nu16 r;\r\nr = locomo_readl(locomokbd->base + LOCOMO_KIC) & ~0x0010;\r\nlocomo_writel(r, locomokbd->base + LOCOMO_KIC);\r\n}\r\nstatic int locomokbd_probe(struct locomo_dev *dev)\r\n{\r\nstruct locomokbd *locomokbd;\r\nstruct input_dev *input_dev;\r\nint i, err;\r\nlocomokbd = kzalloc(sizeof(struct locomokbd), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!locomokbd || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nif (!request_mem_region((unsigned long) dev->mapbase,\r\ndev->length,\r\nLOCOMO_DRIVER_NAME(dev))) {\r\nerr = -EBUSY;\r\nprintk(KERN_ERR "locomokbd: Can't acquire access to io memory for keyboard\n");\r\ngoto err_free_mem;\r\n}\r\nlocomo_set_drvdata(dev, locomokbd);\r\nlocomokbd->base = (unsigned long) dev->mapbase;\r\nspin_lock_init(&locomokbd->lock);\r\nsetup_timer(&locomokbd->timer, locomokbd_timer_callback,\r\n(unsigned long)locomokbd);\r\nlocomokbd->suspend_jiffies = jiffies;\r\nlocomokbd->input = input_dev;\r\nstrcpy(locomokbd->phys, "locomokbd/input0");\r\ninput_dev->name = "LoCoMo keyboard";\r\ninput_dev->phys = locomokbd->phys;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->id.vendor = 0x0001;\r\ninput_dev->id.product = 0x0001;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->open = locomokbd_open;\r\ninput_dev->close = locomokbd_close;\r\ninput_dev->dev.parent = &dev->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP) |\r\nBIT_MASK(EV_PWR);\r\ninput_dev->keycode = locomokbd->keycode;\r\ninput_dev->keycodesize = sizeof(locomokbd_keycode[0]);\r\ninput_dev->keycodemax = ARRAY_SIZE(locomokbd_keycode);\r\ninput_set_drvdata(input_dev, locomokbd);\r\nmemcpy(locomokbd->keycode, locomokbd_keycode, sizeof(locomokbd->keycode));\r\nfor (i = 0; i < LOCOMOKBD_NUMKEYS; i++)\r\nset_bit(locomokbd->keycode[i], input_dev->keybit);\r\nclear_bit(0, input_dev->keybit);\r\nerr = request_irq(dev->irq[0], locomokbd_interrupt, 0, "locomokbd", locomokbd);\r\nif (err) {\r\nprintk(KERN_ERR "locomokbd: Can't get irq for keyboard\n");\r\ngoto err_release_region;\r\n}\r\nerr = input_register_device(locomokbd->input);\r\nif (err)\r\ngoto err_free_irq;\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(dev->irq[0], locomokbd);\r\nerr_release_region:\r\nrelease_mem_region((unsigned long) dev->mapbase, dev->length);\r\nlocomo_set_drvdata(dev, NULL);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(locomokbd);\r\nreturn err;\r\n}\r\nstatic int locomokbd_remove(struct locomo_dev *dev)\r\n{\r\nstruct locomokbd *locomokbd = locomo_get_drvdata(dev);\r\nfree_irq(dev->irq[0], locomokbd);\r\ndel_timer_sync(&locomokbd->timer);\r\ninput_unregister_device(locomokbd->input);\r\nlocomo_set_drvdata(dev, NULL);\r\nrelease_mem_region((unsigned long) dev->mapbase, dev->length);\r\nkfree(locomokbd);\r\nreturn 0;\r\n}\r\nstatic int __init locomokbd_init(void)\r\n{\r\nreturn locomo_driver_register(&keyboard_driver);\r\n}\r\nstatic void __exit locomokbd_exit(void)\r\n{\r\nlocomo_driver_unregister(&keyboard_driver);\r\n}
