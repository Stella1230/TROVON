static int marvell_pata_active(struct pci_dev *pdev)\r\n{\r\nint i;\r\nu32 devices;\r\nvoid __iomem *barp;\r\nif (pdev->device != 0x6145)\r\nreturn 1;\r\nbarp = pci_iomap(pdev, 5, 0x10);\r\nif (barp == NULL)\r\nreturn -ENOMEM;\r\nprintk("BAR5:");\r\nfor(i = 0; i <= 0x0F; i++)\r\nprintk("%02X:%02X ", i, ioread8(barp + i));\r\nprintk("\n");\r\ndevices = ioread32(barp + 0x0C);\r\npci_iounmap(pdev, barp);\r\nif (devices & 0x10)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int marvell_pre_reset(struct ata_link *link, unsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nif (pdev->device == 0x6145 && ap->port_no == 0 &&\r\n!marvell_pata_active(pdev))\r\nreturn -ENOENT;\r\nreturn ata_sff_prereset(link, deadline);\r\n}\r\nstatic int marvell_cable_detect(struct ata_port *ap)\r\n{\r\nswitch(ap->port_no)\r\n{\r\ncase 0:\r\nif (ioread8(ap->ioaddr.bmdma_addr + 1) & 1)\r\nreturn ATA_CBL_PATA40;\r\nreturn ATA_CBL_PATA80;\r\ncase 1:\r\nreturn ATA_CBL_SATA;\r\n}\r\nBUG();\r\nreturn 0;\r\n}\r\nstatic int marvell_init_one (struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstatic const struct ata_port_info info = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &marvell_ops,\r\n};\r\nstatic const struct ata_port_info info_sata = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &marvell_ops,\r\n};\r\nconst struct ata_port_info *ppi[] = { &info, &info_sata };\r\nif (pdev->device == 0x6101)\r\nppi[1] = &ata_dummy_port_info;\r\n#if IS_ENABLED(CONFIG_SATA_AHCI)\r\nif (!marvell_pata_active(pdev)) {\r\nprintk(KERN_INFO DRV_NAME ": PATA port not active, deferring to AHCI driver.\n");\r\nreturn -ENODEV;\r\n}\r\n#endif\r\nreturn ata_pci_bmdma_init_one(pdev, ppi, &marvell_sht, NULL, 0);\r\n}
