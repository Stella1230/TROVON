static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)\r\n{\r\nstruct hw_fib * kfib;\r\nstruct fib *fibptr;\r\nstruct hw_fib * hw_fib = (struct hw_fib *)0;\r\ndma_addr_t hw_fib_pa = (dma_addr_t)0LL;\r\nunsigned int size, osize;\r\nint retval;\r\nif (dev->in_reset) {\r\nreturn -EBUSY;\r\n}\r\nfibptr = aac_fib_alloc(dev);\r\nif(fibptr == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nkfib = fibptr->hw_fib_va;\r\nif (copy_from_user((void *)kfib, arg, sizeof(struct aac_fibhdr))) {\r\naac_fib_free(fibptr);\r\nreturn -EFAULT;\r\n}\r\nosize = size = le16_to_cpu(kfib->header.Size) +\r\nsizeof(struct aac_fibhdr);\r\nif (size < le16_to_cpu(kfib->header.SenderSize))\r\nsize = le16_to_cpu(kfib->header.SenderSize);\r\nif (size > dev->max_fib_size) {\r\ndma_addr_t daddr;\r\nif (size > 2048) {\r\nretval = -EINVAL;\r\ngoto cleanup;\r\n}\r\nkfib = dma_alloc_coherent(&dev->pdev->dev, size, &daddr,\r\nGFP_KERNEL);\r\nif (!kfib) {\r\nretval = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nhw_fib = fibptr->hw_fib_va;\r\nhw_fib_pa = fibptr->hw_fib_pa;\r\nfibptr->hw_fib_va = kfib;\r\nfibptr->hw_fib_pa = daddr;\r\nmemset(((char *)kfib) + dev->max_fib_size, 0, size - dev->max_fib_size);\r\nmemcpy(kfib, hw_fib, dev->max_fib_size);\r\n}\r\nif (copy_from_user(kfib, arg, size)) {\r\nretval = -EFAULT;\r\ngoto cleanup;\r\n}\r\nif ((osize != le16_to_cpu(kfib->header.Size) +\r\nsizeof(struct aac_fibhdr))\r\n|| (size < le16_to_cpu(kfib->header.SenderSize))) {\r\nretval = -EINVAL;\r\ngoto cleanup;\r\n}\r\nif (kfib->header.Command == cpu_to_le16(TakeABreakPt)) {\r\naac_adapter_interrupt(dev);\r\nkfib->header.XferState = 0;\r\n} else {\r\nretval = aac_fib_send(le16_to_cpu(kfib->header.Command), fibptr,\r\nle16_to_cpu(kfib->header.Size) , FsaNormal,\r\n1, 1, NULL, NULL);\r\nif (retval) {\r\ngoto cleanup;\r\n}\r\nif (aac_fib_complete(fibptr) != 0) {\r\nretval = -EINVAL;\r\ngoto cleanup;\r\n}\r\n}\r\nretval = 0;\r\nif (copy_to_user(arg, (void *)kfib, size))\r\nretval = -EFAULT;\r\ncleanup:\r\nif (hw_fib) {\r\ndma_free_coherent(&dev->pdev->dev, size, kfib,\r\nfibptr->hw_fib_pa);\r\nfibptr->hw_fib_pa = hw_fib_pa;\r\nfibptr->hw_fib_va = hw_fib;\r\n}\r\nif (retval != -ERESTARTSYS)\r\naac_fib_free(fibptr);\r\nreturn retval;\r\n}\r\nstatic int open_getadapter_fib(struct aac_dev * dev, void __user *arg)\r\n{\r\nstruct aac_fib_context * fibctx;\r\nint status;\r\nfibctx = kmalloc(sizeof(struct aac_fib_context), GFP_KERNEL);\r\nif (fibctx == NULL) {\r\nstatus = -ENOMEM;\r\n} else {\r\nunsigned long flags;\r\nstruct list_head * entry;\r\nstruct aac_fib_context * context;\r\nfibctx->type = FSAFS_NTC_GET_ADAPTER_FIB_CONTEXT;\r\nfibctx->size = sizeof(struct aac_fib_context);\r\nfibctx->unique = (u32)((ulong)fibctx & 0xFFFFFFFF);\r\nsema_init(&fibctx->wait_sem, 0);\r\nfibctx->wait = 0;\r\nfibctx->count = 0;\r\nINIT_LIST_HEAD(&fibctx->fib_list);\r\nfibctx->jiffies = jiffies/HZ;\r\nspin_lock_irqsave(&dev->fib_lock, flags);\r\nentry = dev->fib_list.next;\r\nwhile (entry != &dev->fib_list) {\r\ncontext = list_entry(entry, struct aac_fib_context, next);\r\nif (context->unique == fibctx->unique) {\r\nfibctx->unique++;\r\nentry = dev->fib_list.next;\r\n} else {\r\nentry = entry->next;\r\n}\r\n}\r\nlist_add_tail(&fibctx->next, &dev->fib_list);\r\nspin_unlock_irqrestore(&dev->fib_lock, flags);\r\nif (copy_to_user(arg, &fibctx->unique,\r\nsizeof(fibctx->unique))) {\r\nstatus = -EFAULT;\r\n} else {\r\nstatus = 0;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int next_getadapter_fib(struct aac_dev * dev, void __user *arg)\r\n{\r\nstruct fib_ioctl f;\r\nstruct fib *fib;\r\nstruct aac_fib_context *fibctx;\r\nint status;\r\nstruct list_head * entry;\r\nunsigned long flags;\r\nif(copy_from_user((void *)&f, arg, sizeof(struct fib_ioctl)))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&dev->fib_lock, flags);\r\nentry = dev->fib_list.next;\r\nfibctx = NULL;\r\nwhile (entry != &dev->fib_list) {\r\nfibctx = list_entry(entry, struct aac_fib_context, next);\r\nif (fibctx->unique == f.fibctx) {\r\nbreak;\r\n}\r\nentry = entry->next;\r\nfibctx = NULL;\r\n}\r\nif (!fibctx) {\r\nspin_unlock_irqrestore(&dev->fib_lock, flags);\r\ndprintk ((KERN_INFO "Fib Context not found\n"));\r\nreturn -EINVAL;\r\n}\r\nif((fibctx->type != FSAFS_NTC_GET_ADAPTER_FIB_CONTEXT) ||\r\n(fibctx->size != sizeof(struct aac_fib_context))) {\r\nspin_unlock_irqrestore(&dev->fib_lock, flags);\r\ndprintk ((KERN_INFO "Fib Context corrupt?\n"));\r\nreturn -EINVAL;\r\n}\r\nstatus = 0;\r\nreturn_fib:\r\nif (!list_empty(&fibctx->fib_list)) {\r\nentry = fibctx->fib_list.next;\r\nlist_del(entry);\r\nfib = list_entry(entry, struct fib, fiblink);\r\nfibctx->count--;\r\nspin_unlock_irqrestore(&dev->fib_lock, flags);\r\nif (copy_to_user(f.fib, fib->hw_fib_va, sizeof(struct hw_fib))) {\r\nkfree(fib->hw_fib_va);\r\nkfree(fib);\r\nreturn -EFAULT;\r\n}\r\nkfree(fib->hw_fib_va);\r\nkfree(fib);\r\nstatus = 0;\r\n} else {\r\nspin_unlock_irqrestore(&dev->fib_lock, flags);\r\nstatus = !dev->aif_thread;\r\nif (status && !dev->in_reset && dev->queues && dev->fsa_dev) {\r\nkthread_stop(dev->thread);\r\nssleep(1);\r\ndev->aif_thread = 0;\r\ndev->thread = kthread_run(aac_command_thread, dev,\r\n"%s", dev->name);\r\nssleep(1);\r\n}\r\nif (f.wait) {\r\nif(down_interruptible(&fibctx->wait_sem) < 0) {\r\nstatus = -ERESTARTSYS;\r\n} else {\r\nspin_lock_irqsave(&dev->fib_lock, flags);\r\ngoto return_fib;\r\n}\r\n} else {\r\nstatus = -EAGAIN;\r\n}\r\n}\r\nfibctx->jiffies = jiffies/HZ;\r\nreturn status;\r\n}\r\nint aac_close_fib_context(struct aac_dev * dev, struct aac_fib_context * fibctx)\r\n{\r\nstruct fib *fib;\r\nwhile (!list_empty(&fibctx->fib_list)) {\r\nstruct list_head * entry;\r\nentry = fibctx->fib_list.next;\r\nlist_del(entry);\r\nfib = list_entry(entry, struct fib, fiblink);\r\nfibctx->count--;\r\nkfree(fib->hw_fib_va);\r\nkfree(fib);\r\n}\r\nlist_del(&fibctx->next);\r\nfibctx->type = 0;\r\nkfree(fibctx);\r\nreturn 0;\r\n}\r\nstatic int close_getadapter_fib(struct aac_dev * dev, void __user *arg)\r\n{\r\nstruct aac_fib_context *fibctx;\r\nint status;\r\nunsigned long flags;\r\nstruct list_head * entry;\r\nentry = dev->fib_list.next;\r\nfibctx = NULL;\r\nwhile(entry != &dev->fib_list) {\r\nfibctx = list_entry(entry, struct aac_fib_context, next);\r\nif (fibctx->unique == (u32)(uintptr_t)arg)\r\nbreak;\r\nentry = entry->next;\r\nfibctx = NULL;\r\n}\r\nif (!fibctx)\r\nreturn 0;\r\nif((fibctx->type != FSAFS_NTC_GET_ADAPTER_FIB_CONTEXT) ||\r\n(fibctx->size != sizeof(struct aac_fib_context)))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&dev->fib_lock, flags);\r\nstatus = aac_close_fib_context(dev, fibctx);\r\nspin_unlock_irqrestore(&dev->fib_lock, flags);\r\nreturn status;\r\n}\r\nstatic int check_revision(struct aac_dev *dev, void __user *arg)\r\n{\r\nstruct revision response;\r\nchar *driver_version = aac_driver_version;\r\nu32 version;\r\nresponse.compat = 1;\r\nversion = (simple_strtol(driver_version,\r\n&driver_version, 10) << 24) | 0x00000400;\r\nversion += simple_strtol(driver_version + 1, &driver_version, 10) << 16;\r\nversion += simple_strtol(driver_version + 1, NULL, 10);\r\nresponse.version = cpu_to_le32(version);\r\n# ifdef AAC_DRIVER_BUILD\r\nresponse.build = cpu_to_le32(AAC_DRIVER_BUILD);\r\n# else\r\nresponse.build = cpu_to_le32(9999);\r\n# endif\r\nif (copy_to_user(arg, &response, sizeof(response)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int aac_send_raw_srb(struct aac_dev* dev, void __user * arg)\r\n{\r\nstruct fib* srbfib;\r\nint status;\r\nstruct aac_srb *srbcmd = NULL;\r\nstruct aac_hba_cmd_req *hbacmd = NULL;\r\nstruct user_aac_srb *user_srbcmd = NULL;\r\nstruct user_aac_srb __user *user_srb = arg;\r\nstruct aac_srb_reply __user *user_reply;\r\nu32 chn;\r\nu32 fibsize = 0;\r\nu32 flags = 0;\r\ns32 rcode = 0;\r\nu32 data_dir;\r\nvoid __user *sg_user[HBA_MAX_SG_EMBEDDED];\r\nvoid *sg_list[HBA_MAX_SG_EMBEDDED];\r\nu32 sg_count[HBA_MAX_SG_EMBEDDED];\r\nu32 sg_indx = 0;\r\nu32 byte_count = 0;\r\nu32 actual_fibsize64, actual_fibsize = 0;\r\nint i;\r\nint is_native_device;\r\nu64 address;\r\nif (dev->in_reset) {\r\ndprintk((KERN_DEBUG"aacraid: send raw srb -EBUSY\n"));\r\nreturn -EBUSY;\r\n}\r\nif (!capable(CAP_SYS_ADMIN)){\r\ndprintk((KERN_DEBUG"aacraid: No permission to send raw srb\n"));\r\nreturn -EPERM;\r\n}\r\nif (!(srbfib = aac_fib_alloc(dev))) {\r\nreturn -ENOMEM;\r\n}\r\nmemset(sg_list, 0, sizeof(sg_list));\r\nif(copy_from_user(&fibsize, &user_srb->count,sizeof(u32))){\r\ndprintk((KERN_DEBUG"aacraid: Could not copy data size from user\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\nif ((fibsize < (sizeof(struct user_aac_srb) - sizeof(struct user_sgentry))) ||\r\n(fibsize > (dev->max_fib_size - sizeof(struct aac_fibhdr)))) {\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\nuser_srbcmd = kmalloc(fibsize, GFP_KERNEL);\r\nif (!user_srbcmd) {\r\ndprintk((KERN_DEBUG"aacraid: Could not make a copy of the srb\n"));\r\nrcode = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nif(copy_from_user(user_srbcmd, user_srb,fibsize)){\r\ndprintk((KERN_DEBUG"aacraid: Could not copy srb from user\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\nflags = user_srbcmd->flags;\r\nswitch (flags & (SRB_DataIn | SRB_DataOut)) {\r\ncase SRB_DataOut:\r\ndata_dir = DMA_TO_DEVICE;\r\nbreak;\r\ncase (SRB_DataIn | SRB_DataOut):\r\ndata_dir = DMA_BIDIRECTIONAL;\r\nbreak;\r\ncase SRB_DataIn:\r\ndata_dir = DMA_FROM_DEVICE;\r\nbreak;\r\ndefault:\r\ndata_dir = DMA_NONE;\r\n}\r\nif (user_srbcmd->sg.count > ARRAY_SIZE(sg_list)) {\r\ndprintk((KERN_DEBUG"aacraid: too many sg entries %d\n",\r\nuser_srbcmd->sg.count));\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\nif ((data_dir == DMA_NONE) && user_srbcmd->sg.count) {\r\ndprintk((KERN_DEBUG"aacraid:SG with no direction specified\n"));\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\nactual_fibsize = sizeof(struct aac_srb) - sizeof(struct sgentry) +\r\n((user_srbcmd->sg.count & 0xff) * sizeof(struct sgentry));\r\nactual_fibsize64 = actual_fibsize + (user_srbcmd->sg.count & 0xff) *\r\n(sizeof(struct sgentry64) - sizeof(struct sgentry));\r\nif ((actual_fibsize != fibsize) && (actual_fibsize64 != fibsize)) {\r\ndprintk((KERN_DEBUG"aacraid: Bad Size specified in "\r\n"Raw SRB command calculated fibsize=%lu;%lu "\r\n"user_srbcmd->sg.count=%d aac_srb=%lu sgentry=%lu;%lu "\r\n"issued fibsize=%d\n",\r\nactual_fibsize, actual_fibsize64, user_srbcmd->sg.count,\r\nsizeof(struct aac_srb), sizeof(struct sgentry),\r\nsizeof(struct sgentry64), fibsize));\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\nchn = user_srbcmd->channel;\r\nif (chn < AAC_MAX_BUSES && user_srbcmd->id < AAC_MAX_TARGETS &&\r\ndev->hba_map[chn][user_srbcmd->id].devtype ==\r\nAAC_DEVTYPE_NATIVE_RAW) {\r\nis_native_device = 1;\r\nhbacmd = (struct aac_hba_cmd_req *)srbfib->hw_fib_va;\r\nmemset(hbacmd, 0, 96);\r\nswitch (data_dir) {\r\ncase DMA_TO_DEVICE:\r\nhbacmd->byte1 = 2;\r\nbreak;\r\ncase DMA_FROM_DEVICE:\r\ncase DMA_BIDIRECTIONAL:\r\nhbacmd->byte1 = 1;\r\nbreak;\r\ncase DMA_NONE:\r\ndefault:\r\nbreak;\r\n}\r\nhbacmd->lun[1] = cpu_to_le32(user_srbcmd->lun);\r\nhbacmd->it_nexus = dev->hba_map[chn][user_srbcmd->id].rmw_nexus;\r\nmemcpy(hbacmd->cdb, user_srbcmd->cdb, sizeof(hbacmd->cdb));\r\naddress = (u64)srbfib->hw_error_pa;\r\nhbacmd->error_ptr_hi = cpu_to_le32((u32)(address >> 32));\r\nhbacmd->error_ptr_lo = cpu_to_le32((u32)(address & 0xffffffff));\r\nhbacmd->error_length = cpu_to_le32(FW_ERROR_BUFFER_SIZE);\r\nhbacmd->emb_data_desc_count =\r\ncpu_to_le32(user_srbcmd->sg.count);\r\nsrbfib->hbacmd_size = 64 +\r\nuser_srbcmd->sg.count * sizeof(struct aac_hba_sgl);\r\n} else {\r\nis_native_device = 0;\r\naac_fib_init(srbfib);\r\nsrbfib->hw_fib_va->header.XferState &=\r\n~cpu_to_le32(FastResponseCapable);\r\nsrbcmd = (struct aac_srb *) fib_data(srbfib);\r\nsrbcmd->function = cpu_to_le32(SRBF_ExecuteScsi);\r\nsrbcmd->channel = cpu_to_le32(user_srbcmd->channel);\r\nsrbcmd->id = cpu_to_le32(user_srbcmd->id);\r\nsrbcmd->lun = cpu_to_le32(user_srbcmd->lun);\r\nsrbcmd->timeout = cpu_to_le32(user_srbcmd->timeout);\r\nsrbcmd->flags = cpu_to_le32(flags);\r\nsrbcmd->retry_limit = 0;\r\nsrbcmd->cdb_size = cpu_to_le32(user_srbcmd->cdb_size);\r\nmemcpy(srbcmd->cdb, user_srbcmd->cdb, sizeof(srbcmd->cdb));\r\n}\r\nbyte_count = 0;\r\nif (is_native_device) {\r\nstruct user_sgmap *usg32 = &user_srbcmd->sg;\r\nstruct user_sgmap64 *usg64 =\r\n(struct user_sgmap64 *)&user_srbcmd->sg;\r\nfor (i = 0; i < usg32->count; i++) {\r\nvoid *p;\r\nu64 addr;\r\nsg_count[i] = (actual_fibsize64 == fibsize) ?\r\nusg64->sg[i].count : usg32->sg[i].count;\r\nif (sg_count[i] >\r\n(dev->scsi_host_ptr->max_sectors << 9)) {\r\npr_err("aacraid: upsg->sg[%d].count=%u>%u\n",\r\ni, sg_count[i],\r\ndev->scsi_host_ptr->max_sectors << 9);\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\np = kmalloc(sg_count[i], GFP_KERNEL);\r\nif (!p) {\r\nrcode = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nif (actual_fibsize64 == fibsize) {\r\naddr = (u64)usg64->sg[i].addr[0];\r\naddr += ((u64)usg64->sg[i].addr[1]) << 32;\r\n} else {\r\naddr = (u64)usg32->sg[i].addr;\r\n}\r\nsg_user[i] = (void __user *)(uintptr_t)addr;\r\nsg_list[i] = p;\r\nsg_indx = i;\r\nif (flags & SRB_DataOut) {\r\nif (copy_from_user(p, sg_user[i],\r\nsg_count[i])) {\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\n}\r\naddr = pci_map_single(dev->pdev, p, sg_count[i],\r\ndata_dir);\r\nhbacmd->sge[i].addr_hi = cpu_to_le32((u32)(addr>>32));\r\nhbacmd->sge[i].addr_lo = cpu_to_le32(\r\n(u32)(addr & 0xffffffff));\r\nhbacmd->sge[i].len = cpu_to_le32(sg_count[i]);\r\nhbacmd->sge[i].flags = 0;\r\nbyte_count += sg_count[i];\r\n}\r\nif (usg32->count > 0)\r\nhbacmd->sge[usg32->count-1].flags =\r\ncpu_to_le32(0x40000000);\r\nhbacmd->data_length = cpu_to_le32(byte_count);\r\nstatus = aac_hba_send(HBA_IU_TYPE_SCSI_CMD_REQ, srbfib,\r\nNULL, NULL);\r\n} else if (dev->adapter_info.options & AAC_OPT_SGMAP_HOST64) {\r\nstruct user_sgmap64* upsg = (struct user_sgmap64*)&user_srbcmd->sg;\r\nstruct sgmap64* psg = (struct sgmap64*)&srbcmd->sg;\r\nif (actual_fibsize64 == fibsize) {\r\nactual_fibsize = actual_fibsize64;\r\nfor (i = 0; i < upsg->count; i++) {\r\nu64 addr;\r\nvoid* p;\r\nsg_count[i] = upsg->sg[i].count;\r\nif (sg_count[i] >\r\n((dev->adapter_info.options &\r\nAAC_OPT_NEW_COMM) ?\r\n(dev->scsi_host_ptr->max_sectors << 9) :\r\n65536)) {\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\np = kmalloc(sg_count[i], GFP_KERNEL);\r\nif(!p) {\r\ndprintk((KERN_DEBUG"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n",\r\nsg_count[i], i, upsg->count));\r\nrcode = -ENOMEM;\r\ngoto cleanup;\r\n}\r\naddr = (u64)upsg->sg[i].addr[0];\r\naddr += ((u64)upsg->sg[i].addr[1]) << 32;\r\nsg_user[i] = (void __user *)(uintptr_t)addr;\r\nsg_list[i] = p;\r\nsg_indx = i;\r\nif (flags & SRB_DataOut) {\r\nif (copy_from_user(p, sg_user[i],\r\nsg_count[i])){\r\ndprintk((KERN_DEBUG"aacraid: Could not copy sg data from user\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\n}\r\naddr = pci_map_single(dev->pdev, p,\r\nsg_count[i], data_dir);\r\npsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\r\npsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\r\nbyte_count += sg_count[i];\r\npsg->sg[i].count = cpu_to_le32(sg_count[i]);\r\n}\r\n} else {\r\nstruct user_sgmap* usg;\r\nusg = kmemdup(upsg,\r\nactual_fibsize - sizeof(struct aac_srb)\r\n+ sizeof(struct sgmap), GFP_KERNEL);\r\nif (!usg) {\r\ndprintk((KERN_DEBUG"aacraid: Allocation error in Raw SRB command\n"));\r\nrcode = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nactual_fibsize = actual_fibsize64;\r\nfor (i = 0; i < usg->count; i++) {\r\nu64 addr;\r\nvoid* p;\r\nsg_count[i] = usg->sg[i].count;\r\nif (sg_count[i] >\r\n((dev->adapter_info.options &\r\nAAC_OPT_NEW_COMM) ?\r\n(dev->scsi_host_ptr->max_sectors << 9) :\r\n65536)) {\r\nkfree(usg);\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\np = kmalloc(sg_count[i], GFP_KERNEL);\r\nif(!p) {\r\ndprintk((KERN_DEBUG "aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n",\r\nsg_count[i], i, usg->count));\r\nkfree(usg);\r\nrcode = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nsg_user[i] = (void __user *)(uintptr_t)usg->sg[i].addr;\r\nsg_list[i] = p;\r\nsg_indx = i;\r\nif (flags & SRB_DataOut) {\r\nif (copy_from_user(p, sg_user[i],\r\nsg_count[i])) {\r\nkfree (usg);\r\ndprintk((KERN_DEBUG"aacraid: Could not copy sg data from user\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\n}\r\naddr = pci_map_single(dev->pdev, p,\r\nsg_count[i], data_dir);\r\npsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\r\npsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\r\nbyte_count += sg_count[i];\r\npsg->sg[i].count = cpu_to_le32(sg_count[i]);\r\n}\r\nkfree (usg);\r\n}\r\nsrbcmd->count = cpu_to_le32(byte_count);\r\nif (user_srbcmd->sg.count)\r\npsg->count = cpu_to_le32(sg_indx+1);\r\nelse\r\npsg->count = 0;\r\nstatus = aac_fib_send(ScsiPortCommand64, srbfib, actual_fibsize, FsaNormal, 1, 1,NULL,NULL);\r\n} else {\r\nstruct user_sgmap* upsg = &user_srbcmd->sg;\r\nstruct sgmap* psg = &srbcmd->sg;\r\nif (actual_fibsize64 == fibsize) {\r\nstruct user_sgmap64* usg = (struct user_sgmap64 *)upsg;\r\nfor (i = 0; i < upsg->count; i++) {\r\nuintptr_t addr;\r\nvoid* p;\r\nsg_count[i] = usg->sg[i].count;\r\nif (sg_count[i] >\r\n((dev->adapter_info.options &\r\nAAC_OPT_NEW_COMM) ?\r\n(dev->scsi_host_ptr->max_sectors << 9) :\r\n65536)) {\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\np = kmalloc(sg_count[i], GFP_KERNEL|GFP_DMA32);\r\nif (!p) {\r\ndprintk((KERN_DEBUG"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n",\r\nsg_count[i], i, usg->count));\r\nrcode = -ENOMEM;\r\ngoto cleanup;\r\n}\r\naddr = (u64)usg->sg[i].addr[0];\r\naddr += ((u64)usg->sg[i].addr[1]) << 32;\r\nsg_user[i] = (void __user *)addr;\r\nsg_list[i] = p;\r\nsg_indx = i;\r\nif (flags & SRB_DataOut) {\r\nif (copy_from_user(p, sg_user[i],\r\nsg_count[i])){\r\ndprintk((KERN_DEBUG"aacraid: Could not copy sg data from user\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\n}\r\naddr = pci_map_single(dev->pdev, p, usg->sg[i].count, data_dir);\r\npsg->sg[i].addr = cpu_to_le32(addr & 0xffffffff);\r\nbyte_count += usg->sg[i].count;\r\npsg->sg[i].count = cpu_to_le32(sg_count[i]);\r\n}\r\n} else {\r\nfor (i = 0; i < upsg->count; i++) {\r\ndma_addr_t addr;\r\nvoid* p;\r\nsg_count[i] = upsg->sg[i].count;\r\nif (sg_count[i] >\r\n((dev->adapter_info.options &\r\nAAC_OPT_NEW_COMM) ?\r\n(dev->scsi_host_ptr->max_sectors << 9) :\r\n65536)) {\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\np = kmalloc(sg_count[i], GFP_KERNEL|GFP_DMA32);\r\nif (!p) {\r\ndprintk((KERN_DEBUG"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n",\r\nsg_count[i], i, upsg->count));\r\nrcode = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nsg_user[i] = (void __user *)(uintptr_t)upsg->sg[i].addr;\r\nsg_list[i] = p;\r\nsg_indx = i;\r\nif (flags & SRB_DataOut) {\r\nif (copy_from_user(p, sg_user[i],\r\nsg_count[i])) {\r\ndprintk((KERN_DEBUG"aacraid: Could not copy sg data from user\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\n}\r\naddr = pci_map_single(dev->pdev, p,\r\nsg_count[i], data_dir);\r\npsg->sg[i].addr = cpu_to_le32(addr);\r\nbyte_count += sg_count[i];\r\npsg->sg[i].count = cpu_to_le32(sg_count[i]);\r\n}\r\n}\r\nsrbcmd->count = cpu_to_le32(byte_count);\r\nif (user_srbcmd->sg.count)\r\npsg->count = cpu_to_le32(sg_indx+1);\r\nelse\r\npsg->count = 0;\r\nstatus = aac_fib_send(ScsiPortCommand, srbfib, actual_fibsize, FsaNormal, 1, 1, NULL, NULL);\r\n}\r\nif (status == -ERESTARTSYS) {\r\nrcode = -ERESTARTSYS;\r\ngoto cleanup;\r\n}\r\nif (status != 0) {\r\ndprintk((KERN_DEBUG"aacraid: Could not send raw srb fib to hba\n"));\r\nrcode = -ENXIO;\r\ngoto cleanup;\r\n}\r\nif (flags & SRB_DataIn) {\r\nfor(i = 0 ; i <= sg_indx; i++){\r\nif (copy_to_user(sg_user[i], sg_list[i], sg_count[i])) {\r\ndprintk((KERN_DEBUG"aacraid: Could not copy sg data to user\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\n}\r\n}\r\nuser_reply = arg + fibsize;\r\nif (is_native_device) {\r\nstruct aac_hba_resp *err =\r\n&((struct aac_native_hba *)srbfib->hw_fib_va)->resp.err;\r\nstruct aac_srb_reply reply;\r\nmemset(&reply, 0, sizeof(reply));\r\nreply.status = ST_OK;\r\nif (srbfib->flags & FIB_CONTEXT_FLAG_FASTRESP) {\r\nreply.srb_status = SRB_STATUS_SUCCESS;\r\nreply.scsi_status = 0;\r\nreply.data_xfer_length = byte_count;\r\nreply.sense_data_size = 0;\r\nmemset(reply.sense_data, 0, AAC_SENSE_BUFFERSIZE);\r\n} else {\r\nreply.srb_status = err->service_response;\r\nreply.scsi_status = err->status;\r\nreply.data_xfer_length = byte_count -\r\nle32_to_cpu(err->residual_count);\r\nreply.sense_data_size = err->sense_response_data_len;\r\nmemcpy(reply.sense_data, err->sense_response_buf,\r\nAAC_SENSE_BUFFERSIZE);\r\n}\r\nif (copy_to_user(user_reply, &reply,\r\nsizeof(struct aac_srb_reply))) {\r\ndprintk((KERN_DEBUG"aacraid: Copy to user failed\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\n} else {\r\nstruct aac_srb_reply *reply;\r\nreply = (struct aac_srb_reply *) fib_data(srbfib);\r\nif (copy_to_user(user_reply, reply,\r\nsizeof(struct aac_srb_reply))) {\r\ndprintk((KERN_DEBUG"aacraid: Copy to user failed\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\n}\r\ncleanup:\r\nkfree(user_srbcmd);\r\nif (rcode != -ERESTARTSYS) {\r\nfor (i = 0; i <= sg_indx; i++)\r\nkfree(sg_list[i]);\r\naac_fib_complete(srbfib);\r\naac_fib_free(srbfib);\r\n}\r\nreturn rcode;\r\n}\r\nstatic int aac_get_pci_info(struct aac_dev* dev, void __user *arg)\r\n{\r\nstruct aac_pci_info pci_info;\r\npci_info.bus = dev->pdev->bus->number;\r\npci_info.slot = PCI_SLOT(dev->pdev->devfn);\r\nif (copy_to_user(arg, &pci_info, sizeof(struct aac_pci_info))) {\r\ndprintk((KERN_DEBUG "aacraid: Could not copy pci info\n"));\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aac_get_hba_info(struct aac_dev *dev, void __user *arg)\r\n{\r\nstruct aac_hba_info hbainfo;\r\nmemset(&hbainfo, 0, sizeof(hbainfo));\r\nhbainfo.adapter_number = (u8) dev->id;\r\nhbainfo.system_io_bus_number = dev->pdev->bus->number;\r\nhbainfo.device_number = (dev->pdev->devfn >> 3);\r\nhbainfo.function_number = (dev->pdev->devfn & 0x0007);\r\nhbainfo.vendor_id = dev->pdev->vendor;\r\nhbainfo.device_id = dev->pdev->device;\r\nhbainfo.sub_vendor_id = dev->pdev->subsystem_vendor;\r\nhbainfo.sub_system_id = dev->pdev->subsystem_device;\r\nif (copy_to_user(arg, &hbainfo, sizeof(struct aac_hba_info))) {\r\ndprintk((KERN_DEBUG "aacraid: Could not copy hba info\n"));\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aac_send_reset_adapter(struct aac_dev *dev, void __user *arg)\r\n{\r\nstruct aac_reset_iop reset;\r\nint retval;\r\nif (copy_from_user((void *)&reset, arg, sizeof(struct aac_reset_iop)))\r\nreturn -EFAULT;\r\nretval = aac_reset_adapter(dev, 0, reset.reset_type);\r\nreturn retval;\r\n}\r\nint aac_do_ioctl(struct aac_dev * dev, int cmd, void __user *arg)\r\n{\r\nint status;\r\nmutex_lock(&dev->ioctl_mutex);\r\nif (dev->adapter_shutdown) {\r\nstatus = -EACCES;\r\ngoto cleanup;\r\n}\r\nstatus = aac_dev_ioctl(dev, cmd, arg);\r\nif (status != -ENOTTY)\r\ngoto cleanup;\r\nswitch (cmd) {\r\ncase FSACTL_MINIPORT_REV_CHECK:\r\nstatus = check_revision(dev, arg);\r\nbreak;\r\ncase FSACTL_SEND_LARGE_FIB:\r\ncase FSACTL_SENDFIB:\r\nstatus = ioctl_send_fib(dev, arg);\r\nbreak;\r\ncase FSACTL_OPEN_GET_ADAPTER_FIB:\r\nstatus = open_getadapter_fib(dev, arg);\r\nbreak;\r\ncase FSACTL_GET_NEXT_ADAPTER_FIB:\r\nstatus = next_getadapter_fib(dev, arg);\r\nbreak;\r\ncase FSACTL_CLOSE_GET_ADAPTER_FIB:\r\nstatus = close_getadapter_fib(dev, arg);\r\nbreak;\r\ncase FSACTL_SEND_RAW_SRB:\r\nstatus = aac_send_raw_srb(dev,arg);\r\nbreak;\r\ncase FSACTL_GET_PCI_INFO:\r\nstatus = aac_get_pci_info(dev,arg);\r\nbreak;\r\ncase FSACTL_GET_HBA_INFO:\r\nstatus = aac_get_hba_info(dev, arg);\r\nbreak;\r\ncase FSACTL_RESET_IOP:\r\nstatus = aac_send_reset_adapter(dev, arg);\r\nbreak;\r\ndefault:\r\nstatus = -ENOTTY;\r\nbreak;\r\n}\r\ncleanup:\r\nmutex_unlock(&dev->ioctl_mutex);\r\nreturn status;\r\n}
