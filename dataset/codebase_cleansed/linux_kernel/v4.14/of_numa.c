static void __init of_numa_parse_cpu_nodes(void)\r\n{\r\nu32 nid;\r\nint r;\r\nstruct device_node *cpus;\r\nstruct device_node *np = NULL;\r\ncpus = of_find_node_by_path("/cpus");\r\nif (!cpus)\r\nreturn;\r\nfor_each_child_of_node(cpus, np) {\r\nif (of_node_cmp(np->type, "cpu") != 0)\r\ncontinue;\r\nr = of_property_read_u32(np, "numa-node-id", &nid);\r\nif (r)\r\ncontinue;\r\npr_debug("CPU on %u\n", nid);\r\nif (nid >= MAX_NUMNODES)\r\npr_warn("Node id %u exceeds maximum value\n", nid);\r\nelse\r\nnode_set(nid, numa_nodes_parsed);\r\n}\r\nof_node_put(cpus);\r\n}\r\nstatic int __init of_numa_parse_memory_nodes(void)\r\n{\r\nstruct device_node *np = NULL;\r\nstruct resource rsrc;\r\nu32 nid;\r\nint i, r;\r\nfor_each_node_by_type(np, "memory") {\r\nr = of_property_read_u32(np, "numa-node-id", &nid);\r\nif (r == -EINVAL)\r\ncontinue;\r\nif (nid >= MAX_NUMNODES) {\r\npr_warn("Node id %u exceeds maximum value\n", nid);\r\nr = -EINVAL;\r\n}\r\nfor (i = 0; !r && !of_address_to_resource(np, i, &rsrc); i++)\r\nr = numa_add_memblk(nid, rsrc.start, rsrc.end + 1);\r\nif (!i || r) {\r\nof_node_put(np);\r\npr_err("bad property in memory node\n");\r\nreturn r ? : -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init of_numa_parse_distance_map_v1(struct device_node *map)\r\n{\r\nconst __be32 *matrix;\r\nint entry_count;\r\nint i;\r\npr_info("parsing numa-distance-map-v1\n");\r\nmatrix = of_get_property(map, "distance-matrix", NULL);\r\nif (!matrix) {\r\npr_err("No distance-matrix property in distance-map\n");\r\nreturn -EINVAL;\r\n}\r\nentry_count = of_property_count_u32_elems(map, "distance-matrix");\r\nif (entry_count <= 0) {\r\npr_err("Invalid distance-matrix\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i + 2 < entry_count; i += 3) {\r\nu32 nodea, nodeb, distance;\r\nnodea = of_read_number(matrix, 1);\r\nmatrix++;\r\nnodeb = of_read_number(matrix, 1);\r\nmatrix++;\r\ndistance = of_read_number(matrix, 1);\r\nmatrix++;\r\nnuma_set_distance(nodea, nodeb, distance);\r\npr_debug("distance[node%d -> node%d] = %d\n",\r\nnodea, nodeb, distance);\r\nif (nodeb > nodea)\r\nnuma_set_distance(nodeb, nodea, distance);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init of_numa_parse_distance_map(void)\r\n{\r\nint ret = 0;\r\nstruct device_node *np;\r\nnp = of_find_compatible_node(NULL, NULL,\r\n"numa-distance-map-v1");\r\nif (np)\r\nret = of_numa_parse_distance_map_v1(np);\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\nint of_node_to_nid(struct device_node *device)\r\n{\r\nstruct device_node *np;\r\nu32 nid;\r\nint r = -ENODATA;\r\nnp = of_node_get(device);\r\nwhile (np) {\r\nr = of_property_read_u32(np, "numa-node-id", &nid);\r\nif (r != -EINVAL)\r\nbreak;\r\nnp = of_get_next_parent(np);\r\n}\r\nif (np && r)\r\npr_warn("Invalid \"numa-node-id\" property in node %s\n",\r\nnp->name);\r\nof_node_put(np);\r\nif (!r && nid < MAX_NUMNODES && node_possible(nid))\r\nreturn nid;\r\nreturn NUMA_NO_NODE;\r\n}\r\nint __init of_numa_init(void)\r\n{\r\nint r;\r\nof_numa_parse_cpu_nodes();\r\nr = of_numa_parse_memory_nodes();\r\nif (r)\r\nreturn r;\r\nreturn of_numa_parse_distance_map();\r\n}
