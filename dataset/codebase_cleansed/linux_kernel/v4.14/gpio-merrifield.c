static void __iomem *gpio_reg(struct gpio_chip *chip, unsigned int offset,\r\nunsigned int reg_type_offset)\r\n{\r\nstruct mrfld_gpio *priv = gpiochip_get_data(chip);\r\nu8 reg = offset / 32;\r\nreturn priv->reg_base + reg_type_offset + reg * 4;\r\n}\r\nstatic int mrfld_gpio_get(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nvoid __iomem *gplr = gpio_reg(chip, offset, GPLR);\r\nreturn !!(readl(gplr) & BIT(offset % 32));\r\n}\r\nstatic void mrfld_gpio_set(struct gpio_chip *chip, unsigned int offset,\r\nint value)\r\n{\r\nstruct mrfld_gpio *priv = gpiochip_get_data(chip);\r\nvoid __iomem *gpsr, *gpcr;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&priv->lock, flags);\r\nif (value) {\r\ngpsr = gpio_reg(chip, offset, GPSR);\r\nwritel(BIT(offset % 32), gpsr);\r\n} else {\r\ngpcr = gpio_reg(chip, offset, GPCR);\r\nwritel(BIT(offset % 32), gpcr);\r\n}\r\nraw_spin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic int mrfld_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned int offset)\r\n{\r\nstruct mrfld_gpio *priv = gpiochip_get_data(chip);\r\nvoid __iomem *gpdr = gpio_reg(chip, offset, GPDR);\r\nunsigned long flags;\r\nu32 value;\r\nraw_spin_lock_irqsave(&priv->lock, flags);\r\nvalue = readl(gpdr);\r\nvalue &= ~BIT(offset % 32);\r\nwritel(value, gpdr);\r\nraw_spin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mrfld_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned int offset, int value)\r\n{\r\nstruct mrfld_gpio *priv = gpiochip_get_data(chip);\r\nvoid __iomem *gpdr = gpio_reg(chip, offset, GPDR);\r\nunsigned long flags;\r\nmrfld_gpio_set(chip, offset, value);\r\nraw_spin_lock_irqsave(&priv->lock, flags);\r\nvalue = readl(gpdr);\r\nvalue |= BIT(offset % 32);\r\nwritel(value, gpdr);\r\nraw_spin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mrfld_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nvoid __iomem *gpdr = gpio_reg(chip, offset, GPDR);\r\nreturn !(readl(gpdr) & BIT(offset % 32));\r\n}\r\nstatic int mrfld_gpio_set_debounce(struct gpio_chip *chip, unsigned int offset,\r\nunsigned int debounce)\r\n{\r\nstruct mrfld_gpio *priv = gpiochip_get_data(chip);\r\nvoid __iomem *gfbr = gpio_reg(chip, offset, GFBR);\r\nunsigned long flags;\r\nu32 value;\r\nraw_spin_lock_irqsave(&priv->lock, flags);\r\nif (debounce)\r\nvalue = readl(gfbr) & ~BIT(offset % 32);\r\nelse\r\nvalue = readl(gfbr) | BIT(offset % 32);\r\nwritel(value, gfbr);\r\nraw_spin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mrfld_gpio_set_config(struct gpio_chip *chip, unsigned int offset,\r\nunsigned long config)\r\n{\r\nu32 debounce;\r\nif (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)\r\nreturn -ENOTSUPP;\r\ndebounce = pinconf_to_config_argument(config);\r\nreturn mrfld_gpio_set_debounce(chip, offset, debounce);\r\n}\r\nstatic void mrfld_irq_ack(struct irq_data *d)\r\n{\r\nstruct mrfld_gpio *priv = irq_data_get_irq_chip_data(d);\r\nu32 gpio = irqd_to_hwirq(d);\r\nvoid __iomem *gisr = gpio_reg(&priv->chip, gpio, GISR);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&priv->lock, flags);\r\nwritel(BIT(gpio % 32), gisr);\r\nraw_spin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void mrfld_irq_unmask_mask(struct irq_data *d, bool unmask)\r\n{\r\nstruct mrfld_gpio *priv = irq_data_get_irq_chip_data(d);\r\nu32 gpio = irqd_to_hwirq(d);\r\nvoid __iomem *gimr = gpio_reg(&priv->chip, gpio, GIMR);\r\nunsigned long flags;\r\nu32 value;\r\nraw_spin_lock_irqsave(&priv->lock, flags);\r\nif (unmask)\r\nvalue = readl(gimr) | BIT(gpio % 32);\r\nelse\r\nvalue = readl(gimr) & ~BIT(gpio % 32);\r\nwritel(value, gimr);\r\nraw_spin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void mrfld_irq_mask(struct irq_data *d)\r\n{\r\nmrfld_irq_unmask_mask(d, false);\r\n}\r\nstatic void mrfld_irq_unmask(struct irq_data *d)\r\n{\r\nmrfld_irq_unmask_mask(d, true);\r\n}\r\nstatic int mrfld_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct mrfld_gpio *priv = gpiochip_get_data(gc);\r\nu32 gpio = irqd_to_hwirq(d);\r\nvoid __iomem *grer = gpio_reg(&priv->chip, gpio, GRER);\r\nvoid __iomem *gfer = gpio_reg(&priv->chip, gpio, GFER);\r\nvoid __iomem *gitr = gpio_reg(&priv->chip, gpio, GITR);\r\nvoid __iomem *glpr = gpio_reg(&priv->chip, gpio, GLPR);\r\nunsigned long flags;\r\nu32 value;\r\nraw_spin_lock_irqsave(&priv->lock, flags);\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nvalue = readl(grer) | BIT(gpio % 32);\r\nelse\r\nvalue = readl(grer) & ~BIT(gpio % 32);\r\nwritel(value, grer);\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nvalue = readl(gfer) | BIT(gpio % 32);\r\nelse\r\nvalue = readl(gfer) & ~BIT(gpio % 32);\r\nwritel(value, gfer);\r\nif (type & IRQ_TYPE_LEVEL_LOW)\r\nvalue = readl(glpr) | BIT(gpio % 32);\r\nelse\r\nvalue = readl(glpr) & ~BIT(gpio % 32);\r\nwritel(value, glpr);\r\nif (type & IRQ_TYPE_LEVEL_MASK) {\r\nvalue = readl(gitr) | BIT(gpio % 32);\r\nwritel(value, gitr);\r\nirq_set_handler_locked(d, handle_level_irq);\r\n} else if (type & IRQ_TYPE_EDGE_BOTH) {\r\nvalue = readl(gitr) & ~BIT(gpio % 32);\r\nwritel(value, gitr);\r\nirq_set_handler_locked(d, handle_edge_irq);\r\n}\r\nraw_spin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mrfld_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct mrfld_gpio *priv = gpiochip_get_data(gc);\r\nu32 gpio = irqd_to_hwirq(d);\r\nvoid __iomem *gwmr = gpio_reg(&priv->chip, gpio, GWMR);\r\nvoid __iomem *gwsr = gpio_reg(&priv->chip, gpio, GWSR);\r\nunsigned long flags;\r\nu32 value;\r\nraw_spin_lock_irqsave(&priv->lock, flags);\r\nwritel(BIT(gpio % 32), gwsr);\r\nif (on)\r\nvalue = readl(gwmr) | BIT(gpio % 32);\r\nelse\r\nvalue = readl(gwmr) & ~BIT(gpio % 32);\r\nwritel(value, gwmr);\r\nraw_spin_unlock_irqrestore(&priv->lock, flags);\r\ndev_dbg(priv->dev, "%sable wake for gpio %u\n", on ? "en" : "dis", gpio);\r\nreturn 0;\r\n}\r\nstatic void mrfld_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nstruct mrfld_gpio *priv = gpiochip_get_data(gc);\r\nstruct irq_chip *irqchip = irq_desc_get_chip(desc);\r\nunsigned long base, gpio;\r\nchained_irq_enter(irqchip, desc);\r\nfor (base = 0; base < priv->chip.ngpio; base += 32) {\r\nvoid __iomem *gisr = gpio_reg(&priv->chip, base, GISR);\r\nvoid __iomem *gimr = gpio_reg(&priv->chip, base, GIMR);\r\nunsigned long pending, enabled;\r\npending = readl(gisr);\r\nenabled = readl(gimr);\r\npending &= enabled;\r\nfor_each_set_bit(gpio, &pending, 32) {\r\nunsigned int irq;\r\nirq = irq_find_mapping(gc->irqdomain, base + gpio);\r\ngeneric_handle_irq(irq);\r\n}\r\n}\r\nchained_irq_exit(irqchip, desc);\r\n}\r\nstatic void mrfld_irq_init_hw(struct mrfld_gpio *priv)\r\n{\r\nvoid __iomem *reg;\r\nunsigned int base;\r\nfor (base = 0; base < priv->chip.ngpio; base += 32) {\r\nreg = gpio_reg(&priv->chip, base, GRER);\r\nwritel(0, reg);\r\nreg = gpio_reg(&priv->chip, base, GFER);\r\nwritel(0, reg);\r\n}\r\n}\r\nstatic int mrfld_gpio_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nconst struct mrfld_gpio_pinrange *range;\r\nstruct mrfld_gpio *priv;\r\nu32 gpio_base, irq_base;\r\nvoid __iomem *base;\r\nunsigned int i;\r\nint retval;\r\nretval = pcim_enable_device(pdev);\r\nif (retval)\r\nreturn retval;\r\nretval = pcim_iomap_regions(pdev, BIT(1) | BIT(0), pci_name(pdev));\r\nif (retval) {\r\ndev_err(&pdev->dev, "I/O memory mapping error\n");\r\nreturn retval;\r\n}\r\nbase = pcim_iomap_table(pdev)[1];\r\nirq_base = readl(base);\r\ngpio_base = readl(sizeof(u32) + base);\r\npcim_iounmap_regions(pdev, BIT(1));\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&pdev->dev, "can't allocate chip data\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->dev = &pdev->dev;\r\npriv->reg_base = pcim_iomap_table(pdev)[0];\r\npriv->chip.label = dev_name(&pdev->dev);\r\npriv->chip.parent = &pdev->dev;\r\npriv->chip.request = gpiochip_generic_request;\r\npriv->chip.free = gpiochip_generic_free;\r\npriv->chip.direction_input = mrfld_gpio_direction_input;\r\npriv->chip.direction_output = mrfld_gpio_direction_output;\r\npriv->chip.get = mrfld_gpio_get;\r\npriv->chip.set = mrfld_gpio_set;\r\npriv->chip.get_direction = mrfld_gpio_get_direction;\r\npriv->chip.set_config = mrfld_gpio_set_config;\r\npriv->chip.base = gpio_base;\r\npriv->chip.ngpio = MRFLD_NGPIO;\r\npriv->chip.can_sleep = false;\r\nraw_spin_lock_init(&priv->lock);\r\npci_set_drvdata(pdev, priv);\r\nretval = devm_gpiochip_add_data(&pdev->dev, &priv->chip, priv);\r\nif (retval) {\r\ndev_err(&pdev->dev, "gpiochip_add error %d\n", retval);\r\nreturn retval;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(mrfld_gpio_ranges); i++) {\r\nrange = &mrfld_gpio_ranges[i];\r\nretval = gpiochip_add_pin_range(&priv->chip,\r\n"pinctrl-merrifield",\r\nrange->gpio_base,\r\nrange->pin_base,\r\nrange->npins);\r\nif (retval) {\r\ndev_err(&pdev->dev, "failed to add GPIO pin range\n");\r\nreturn retval;\r\n}\r\n}\r\nretval = gpiochip_irqchip_add(&priv->chip, &mrfld_irqchip, irq_base,\r\nhandle_bad_irq, IRQ_TYPE_NONE);\r\nif (retval) {\r\ndev_err(&pdev->dev, "could not connect irqchip to gpiochip\n");\r\nreturn retval;\r\n}\r\nmrfld_irq_init_hw(priv);\r\ngpiochip_set_chained_irqchip(&priv->chip, &mrfld_irqchip, pdev->irq,\r\nmrfld_irq_handler);\r\nreturn 0;\r\n}
