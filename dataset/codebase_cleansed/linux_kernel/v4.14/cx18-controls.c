static int cx18_s_stream_vbi_fmt(struct cx2341x_handler *cxhdl, u32 fmt)\r\n{\r\nstruct cx18 *cx = container_of(cxhdl, struct cx18, cxhdl);\r\nint type = cxhdl->stream_type->val;\r\nif (atomic_read(&cx->ana_capturing) > 0)\r\nreturn -EBUSY;\r\nif (fmt != V4L2_MPEG_STREAM_VBI_FMT_IVTV ||\r\n!(type == V4L2_MPEG_STREAM_TYPE_MPEG2_PS ||\r\ntype == V4L2_MPEG_STREAM_TYPE_MPEG2_DVD ||\r\ntype == V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD)) {\r\ncx->vbi.insert_mpeg = V4L2_MPEG_STREAM_VBI_FMT_NONE;\r\nCX18_DEBUG_INFO("disabled insertion of sliced VBI data into the MPEG stream\n");\r\nreturn 0;\r\n}\r\nif (cx->vbi.sliced_mpeg_data[0] == NULL) {\r\nint i;\r\nfor (i = 0; i < CX18_VBI_FRAMES; i++) {\r\ncx->vbi.sliced_mpeg_data[i] =\r\nkmalloc(CX18_SLICED_MPEG_DATA_BUFSZ, GFP_KERNEL);\r\nif (cx->vbi.sliced_mpeg_data[i] == NULL) {\r\nwhile (--i >= 0) {\r\nkfree(cx->vbi.sliced_mpeg_data[i]);\r\ncx->vbi.sliced_mpeg_data[i] = NULL;\r\n}\r\ncx->vbi.insert_mpeg =\r\nV4L2_MPEG_STREAM_VBI_FMT_NONE;\r\nCX18_WARN("Unable to allocate buffers for sliced VBI data insertion\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\n}\r\ncx->vbi.insert_mpeg = fmt;\r\nCX18_DEBUG_INFO("enabled insertion of sliced VBI data into the MPEG PS,when sliced VBI is enabled\n");\r\nif (cx18_get_service_set(cx->vbi.sliced_in) == 0) {\r\nif (cx->is_60hz)\r\ncx->vbi.sliced_in->service_set =\r\nV4L2_SLICED_CAPTION_525;\r\nelse\r\ncx->vbi.sliced_in->service_set = V4L2_SLICED_WSS_625;\r\ncx18_expand_service_set(cx->vbi.sliced_in, cx->is_50hz);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx18_s_video_encoding(struct cx2341x_handler *cxhdl, u32 val)\r\n{\r\nstruct cx18 *cx = container_of(cxhdl, struct cx18, cxhdl);\r\nint is_mpeg1 = val == V4L2_MPEG_VIDEO_ENCODING_MPEG_1;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nstruct v4l2_mbus_framefmt *fmt = &format.format;\r\nfmt->width = cxhdl->width / (is_mpeg1 ? 2 : 1);\r\nfmt->height = cxhdl->height;\r\nfmt->code = MEDIA_BUS_FMT_FIXED;\r\nv4l2_subdev_call(cx->sd_av, pad, set_fmt, NULL, &format);\r\nreturn 0;\r\n}\r\nstatic int cx18_s_audio_sampling_freq(struct cx2341x_handler *cxhdl, u32 idx)\r\n{\r\nstatic const u32 freqs[3] = { 44100, 48000, 32000 };\r\nstruct cx18 *cx = container_of(cxhdl, struct cx18, cxhdl);\r\nif (idx < ARRAY_SIZE(freqs))\r\ncx18_call_all(cx, audio, s_clock_freq, freqs[idx]);\r\nreturn 0;\r\n}\r\nstatic int cx18_s_audio_mode(struct cx2341x_handler *cxhdl, u32 val)\r\n{\r\nstruct cx18 *cx = container_of(cxhdl, struct cx18, cxhdl);\r\ncx->dualwatch_stereo_mode = val;\r\nreturn 0;\r\n}
