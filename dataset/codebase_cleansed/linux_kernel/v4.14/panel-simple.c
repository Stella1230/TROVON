static inline struct panel_simple *to_panel_simple(struct drm_panel *panel)\r\n{\r\nreturn container_of(panel, struct panel_simple, base);\r\n}\r\nstatic int panel_simple_get_fixed_modes(struct panel_simple *panel)\r\n{\r\nstruct drm_connector *connector = panel->base.connector;\r\nstruct drm_device *drm = panel->base.drm;\r\nstruct drm_display_mode *mode;\r\nunsigned int i, num = 0;\r\nif (!panel->desc)\r\nreturn 0;\r\nfor (i = 0; i < panel->desc->num_timings; i++) {\r\nconst struct display_timing *dt = &panel->desc->timings[i];\r\nstruct videomode vm;\r\nvideomode_from_timing(dt, &vm);\r\nmode = drm_mode_create(drm);\r\nif (!mode) {\r\ndev_err(drm->dev, "failed to add mode %ux%u\n",\r\ndt->hactive.typ, dt->vactive.typ);\r\ncontinue;\r\n}\r\ndrm_display_mode_from_videomode(&vm, mode);\r\nmode->type |= DRM_MODE_TYPE_DRIVER;\r\nif (panel->desc->num_timings == 1)\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(connector, mode);\r\nnum++;\r\n}\r\nfor (i = 0; i < panel->desc->num_modes; i++) {\r\nconst struct drm_display_mode *m = &panel->desc->modes[i];\r\nmode = drm_mode_duplicate(drm, m);\r\nif (!mode) {\r\ndev_err(drm->dev, "failed to add mode %ux%u@%u\n",\r\nm->hdisplay, m->vdisplay, m->vrefresh);\r\ncontinue;\r\n}\r\nmode->type |= DRM_MODE_TYPE_DRIVER;\r\nif (panel->desc->num_modes == 1)\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_set_name(mode);\r\ndrm_mode_probed_add(connector, mode);\r\nnum++;\r\n}\r\nconnector->display_info.bpc = panel->desc->bpc;\r\nconnector->display_info.width_mm = panel->desc->size.width;\r\nconnector->display_info.height_mm = panel->desc->size.height;\r\nif (panel->desc->bus_format)\r\ndrm_display_info_set_bus_formats(&connector->display_info,\r\n&panel->desc->bus_format, 1);\r\nconnector->display_info.bus_flags = panel->desc->bus_flags;\r\nreturn num;\r\n}\r\nstatic int panel_simple_disable(struct drm_panel *panel)\r\n{\r\nstruct panel_simple *p = to_panel_simple(panel);\r\nif (!p->enabled)\r\nreturn 0;\r\nif (p->backlight) {\r\np->backlight->props.power = FB_BLANK_POWERDOWN;\r\np->backlight->props.state |= BL_CORE_FBBLANK;\r\nbacklight_update_status(p->backlight);\r\n}\r\nif (p->desc->delay.disable)\r\nmsleep(p->desc->delay.disable);\r\np->enabled = false;\r\nreturn 0;\r\n}\r\nstatic int panel_simple_unprepare(struct drm_panel *panel)\r\n{\r\nstruct panel_simple *p = to_panel_simple(panel);\r\nif (!p->prepared)\r\nreturn 0;\r\nif (p->enable_gpio)\r\ngpiod_set_value_cansleep(p->enable_gpio, 0);\r\nregulator_disable(p->supply);\r\nif (p->desc->delay.unprepare)\r\nmsleep(p->desc->delay.unprepare);\r\np->prepared = false;\r\nreturn 0;\r\n}\r\nstatic int panel_simple_prepare(struct drm_panel *panel)\r\n{\r\nstruct panel_simple *p = to_panel_simple(panel);\r\nint err;\r\nif (p->prepared)\r\nreturn 0;\r\nerr = regulator_enable(p->supply);\r\nif (err < 0) {\r\ndev_err(panel->dev, "failed to enable supply: %d\n", err);\r\nreturn err;\r\n}\r\nif (p->enable_gpio)\r\ngpiod_set_value_cansleep(p->enable_gpio, 1);\r\nif (p->desc->delay.prepare)\r\nmsleep(p->desc->delay.prepare);\r\np->prepared = true;\r\nreturn 0;\r\n}\r\nstatic int panel_simple_enable(struct drm_panel *panel)\r\n{\r\nstruct panel_simple *p = to_panel_simple(panel);\r\nif (p->enabled)\r\nreturn 0;\r\nif (p->desc->delay.enable)\r\nmsleep(p->desc->delay.enable);\r\nif (p->backlight) {\r\np->backlight->props.state &= ~BL_CORE_FBBLANK;\r\np->backlight->props.power = FB_BLANK_UNBLANK;\r\nbacklight_update_status(p->backlight);\r\n}\r\np->enabled = true;\r\nreturn 0;\r\n}\r\nstatic int panel_simple_get_modes(struct drm_panel *panel)\r\n{\r\nstruct panel_simple *p = to_panel_simple(panel);\r\nint num = 0;\r\nif (p->ddc) {\r\nstruct edid *edid = drm_get_edid(panel->connector, p->ddc);\r\ndrm_mode_connector_update_edid_property(panel->connector, edid);\r\nif (edid) {\r\nnum += drm_add_edid_modes(panel->connector, edid);\r\nkfree(edid);\r\n}\r\n}\r\nnum += panel_simple_get_fixed_modes(p);\r\nreturn num;\r\n}\r\nstatic int panel_simple_get_timings(struct drm_panel *panel,\r\nunsigned int num_timings,\r\nstruct display_timing *timings)\r\n{\r\nstruct panel_simple *p = to_panel_simple(panel);\r\nunsigned int i;\r\nif (p->desc->num_timings < num_timings)\r\nnum_timings = p->desc->num_timings;\r\nif (timings)\r\nfor (i = 0; i < num_timings; i++)\r\ntimings[i] = p->desc->timings[i];\r\nreturn p->desc->num_timings;\r\n}\r\nstatic int panel_simple_probe(struct device *dev, const struct panel_desc *desc)\r\n{\r\nstruct device_node *backlight, *ddc;\r\nstruct panel_simple *panel;\r\nint err;\r\npanel = devm_kzalloc(dev, sizeof(*panel), GFP_KERNEL);\r\nif (!panel)\r\nreturn -ENOMEM;\r\npanel->enabled = false;\r\npanel->prepared = false;\r\npanel->desc = desc;\r\npanel->supply = devm_regulator_get(dev, "power");\r\nif (IS_ERR(panel->supply))\r\nreturn PTR_ERR(panel->supply);\r\npanel->enable_gpio = devm_gpiod_get_optional(dev, "enable",\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(panel->enable_gpio)) {\r\nerr = PTR_ERR(panel->enable_gpio);\r\ndev_err(dev, "failed to request GPIO: %d\n", err);\r\nreturn err;\r\n}\r\nbacklight = of_parse_phandle(dev->of_node, "backlight", 0);\r\nif (backlight) {\r\npanel->backlight = of_find_backlight_by_node(backlight);\r\nof_node_put(backlight);\r\nif (!panel->backlight)\r\nreturn -EPROBE_DEFER;\r\n}\r\nddc = of_parse_phandle(dev->of_node, "ddc-i2c-bus", 0);\r\nif (ddc) {\r\npanel->ddc = of_find_i2c_adapter_by_node(ddc);\r\nof_node_put(ddc);\r\nif (!panel->ddc) {\r\nerr = -EPROBE_DEFER;\r\ngoto free_backlight;\r\n}\r\n}\r\ndrm_panel_init(&panel->base);\r\npanel->base.dev = dev;\r\npanel->base.funcs = &panel_simple_funcs;\r\nerr = drm_panel_add(&panel->base);\r\nif (err < 0)\r\ngoto free_ddc;\r\ndev_set_drvdata(dev, panel);\r\nreturn 0;\r\nfree_ddc:\r\nif (panel->ddc)\r\nput_device(&panel->ddc->dev);\r\nfree_backlight:\r\nif (panel->backlight)\r\nput_device(&panel->backlight->dev);\r\nreturn err;\r\n}\r\nstatic int panel_simple_remove(struct device *dev)\r\n{\r\nstruct panel_simple *panel = dev_get_drvdata(dev);\r\ndrm_panel_detach(&panel->base);\r\ndrm_panel_remove(&panel->base);\r\npanel_simple_disable(&panel->base);\r\nif (panel->ddc)\r\nput_device(&panel->ddc->dev);\r\nif (panel->backlight)\r\nput_device(&panel->backlight->dev);\r\nreturn 0;\r\n}\r\nstatic void panel_simple_shutdown(struct device *dev)\r\n{\r\nstruct panel_simple *panel = dev_get_drvdata(dev);\r\npanel_simple_disable(&panel->base);\r\n}\r\nstatic int panel_simple_platform_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *id;\r\nid = of_match_node(platform_of_match, pdev->dev.of_node);\r\nif (!id)\r\nreturn -ENODEV;\r\nreturn panel_simple_probe(&pdev->dev, id->data);\r\n}\r\nstatic int panel_simple_platform_remove(struct platform_device *pdev)\r\n{\r\nreturn panel_simple_remove(&pdev->dev);\r\n}\r\nstatic void panel_simple_platform_shutdown(struct platform_device *pdev)\r\n{\r\npanel_simple_shutdown(&pdev->dev);\r\n}\r\nstatic int panel_simple_dsi_probe(struct mipi_dsi_device *dsi)\r\n{\r\nconst struct panel_desc_dsi *desc;\r\nconst struct of_device_id *id;\r\nint err;\r\nid = of_match_node(dsi_of_match, dsi->dev.of_node);\r\nif (!id)\r\nreturn -ENODEV;\r\ndesc = id->data;\r\nerr = panel_simple_probe(&dsi->dev, &desc->desc);\r\nif (err < 0)\r\nreturn err;\r\ndsi->mode_flags = desc->flags;\r\ndsi->format = desc->format;\r\ndsi->lanes = desc->lanes;\r\nreturn mipi_dsi_attach(dsi);\r\n}\r\nstatic int panel_simple_dsi_remove(struct mipi_dsi_device *dsi)\r\n{\r\nint err;\r\nerr = mipi_dsi_detach(dsi);\r\nif (err < 0)\r\ndev_err(&dsi->dev, "failed to detach from DSI host: %d\n", err);\r\nreturn panel_simple_remove(&dsi->dev);\r\n}\r\nstatic void panel_simple_dsi_shutdown(struct mipi_dsi_device *dsi)\r\n{\r\npanel_simple_shutdown(&dsi->dev);\r\n}\r\nstatic int __init panel_simple_init(void)\r\n{\r\nint err;\r\nerr = platform_driver_register(&panel_simple_platform_driver);\r\nif (err < 0)\r\nreturn err;\r\nif (IS_ENABLED(CONFIG_DRM_MIPI_DSI)) {\r\nerr = mipi_dsi_driver_register(&panel_simple_dsi_driver);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit panel_simple_exit(void)\r\n{\r\nif (IS_ENABLED(CONFIG_DRM_MIPI_DSI))\r\nmipi_dsi_driver_unregister(&panel_simple_dsi_driver);\r\nplatform_driver_unregister(&panel_simple_platform_driver);\r\n}
