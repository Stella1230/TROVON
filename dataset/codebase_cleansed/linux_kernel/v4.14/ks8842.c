static inline void ks8842_resume_dma(struct ks8842_adapter *adapter)\r\n{\r\niowrite32(1, adapter->hw_addr + REQ_TIMB_DMA_RESUME);\r\n}\r\nstatic inline void ks8842_select_bank(struct ks8842_adapter *adapter, u16 bank)\r\n{\r\niowrite16(bank, adapter->hw_addr + REG_SELECT_BANK);\r\n}\r\nstatic inline void ks8842_write8(struct ks8842_adapter *adapter, u16 bank,\r\nu8 value, int offset)\r\n{\r\nks8842_select_bank(adapter, bank);\r\niowrite8(value, adapter->hw_addr + offset);\r\n}\r\nstatic inline void ks8842_write16(struct ks8842_adapter *adapter, u16 bank,\r\nu16 value, int offset)\r\n{\r\nks8842_select_bank(adapter, bank);\r\niowrite16(value, adapter->hw_addr + offset);\r\n}\r\nstatic inline void ks8842_enable_bits(struct ks8842_adapter *adapter, u16 bank,\r\nu16 bits, int offset)\r\n{\r\nu16 reg;\r\nks8842_select_bank(adapter, bank);\r\nreg = ioread16(adapter->hw_addr + offset);\r\nreg |= bits;\r\niowrite16(reg, adapter->hw_addr + offset);\r\n}\r\nstatic inline void ks8842_clear_bits(struct ks8842_adapter *adapter, u16 bank,\r\nu16 bits, int offset)\r\n{\r\nu16 reg;\r\nks8842_select_bank(adapter, bank);\r\nreg = ioread16(adapter->hw_addr + offset);\r\nreg &= ~bits;\r\niowrite16(reg, adapter->hw_addr + offset);\r\n}\r\nstatic inline void ks8842_write32(struct ks8842_adapter *adapter, u16 bank,\r\nu32 value, int offset)\r\n{\r\nks8842_select_bank(adapter, bank);\r\niowrite32(value, adapter->hw_addr + offset);\r\n}\r\nstatic inline u8 ks8842_read8(struct ks8842_adapter *adapter, u16 bank,\r\nint offset)\r\n{\r\nks8842_select_bank(adapter, bank);\r\nreturn ioread8(adapter->hw_addr + offset);\r\n}\r\nstatic inline u16 ks8842_read16(struct ks8842_adapter *adapter, u16 bank,\r\nint offset)\r\n{\r\nks8842_select_bank(adapter, bank);\r\nreturn ioread16(adapter->hw_addr + offset);\r\n}\r\nstatic inline u32 ks8842_read32(struct ks8842_adapter *adapter, u16 bank,\r\nint offset)\r\n{\r\nks8842_select_bank(adapter, bank);\r\nreturn ioread32(adapter->hw_addr + offset);\r\n}\r\nstatic void ks8842_reset(struct ks8842_adapter *adapter)\r\n{\r\nif (adapter->conf_flags & MICREL_KS884X) {\r\nks8842_write16(adapter, 3, 1, REG_GRR);\r\nmsleep(10);\r\niowrite16(0, adapter->hw_addr + REG_GRR);\r\n} else {\r\niowrite32(0x1, adapter->hw_addr + REG_TIMB_RST);\r\nmsleep(20);\r\n}\r\n}\r\nstatic void ks8842_update_link_status(struct net_device *netdev,\r\nstruct ks8842_adapter *adapter)\r\n{\r\nif (ks8842_read16(adapter, 45, REG_P1MBSR) & 0x4) {\r\nnetif_carrier_on(netdev);\r\nnetif_wake_queue(netdev);\r\n} else {\r\nnetif_stop_queue(netdev);\r\nnetif_carrier_off(netdev);\r\n}\r\n}\r\nstatic void ks8842_enable_tx(struct ks8842_adapter *adapter)\r\n{\r\nks8842_enable_bits(adapter, 16, 0x01, REG_TXCR);\r\n}\r\nstatic void ks8842_disable_tx(struct ks8842_adapter *adapter)\r\n{\r\nks8842_clear_bits(adapter, 16, 0x01, REG_TXCR);\r\n}\r\nstatic void ks8842_enable_rx(struct ks8842_adapter *adapter)\r\n{\r\nks8842_enable_bits(adapter, 16, 0x01, REG_RXCR);\r\n}\r\nstatic void ks8842_disable_rx(struct ks8842_adapter *adapter)\r\n{\r\nks8842_clear_bits(adapter, 16, 0x01, REG_RXCR);\r\n}\r\nstatic void ks8842_reset_hw(struct ks8842_adapter *adapter)\r\n{\r\nks8842_reset(adapter);\r\nks8842_write16(adapter, 16, 0x000E, REG_TXCR);\r\nks8842_write16(adapter, 16, 0x8 | 0x20 | 0x40 | 0x80 | 0x400,\r\nREG_RXCR);\r\nks8842_write16(adapter, 17, 0x4000, REG_TXFDPR);\r\nks8842_write16(adapter, 17, 0x4000, REG_RXFDPR);\r\nks8842_write16(adapter, 0, 0x1000, REG_QRFCR);\r\nks8842_enable_bits(adapter, 32, 1 << 8, REG_SGCR1);\r\nks8842_enable_bits(adapter, 32, 1 << 3, REG_SGCR2);\r\nks8842_write16(adapter, 48, 0x1E07, REG_P1CR2);\r\nks8842_enable_bits(adapter, 49, 1 << 13, REG_P1CR4);\r\nks8842_enable_tx(adapter);\r\nks8842_enable_rx(adapter);\r\nks8842_write16(adapter, 18, 0xffff, REG_ISR);\r\nif (KS8842_USE_DMA(adapter)) {\r\niowrite16(ENABLED_IRQS_DMA_IP, adapter->hw_addr + REG_TIMB_IER);\r\nks8842_write16(adapter, 18, ENABLED_IRQS_DMA, REG_IER);\r\n} else {\r\nif (!(adapter->conf_flags & MICREL_KS884X))\r\niowrite16(ENABLED_IRQS,\r\nadapter->hw_addr + REG_TIMB_IER);\r\nks8842_write16(adapter, 18, ENABLED_IRQS, REG_IER);\r\n}\r\nks8842_write16(adapter, 32, 0x1, REG_SW_ID_AND_ENABLE);\r\n}\r\nstatic void ks8842_read_mac_addr(struct ks8842_adapter *adapter, u8 *dest)\r\n{\r\nint i;\r\nu16 mac;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\ndest[ETH_ALEN - i - 1] = ks8842_read8(adapter, 2, REG_MARL + i);\r\nif (adapter->conf_flags & MICREL_KS884X) {\r\nmac = ks8842_read16(adapter, 2, REG_MARL);\r\nks8842_write16(adapter, 39, mac, REG_MACAR3);\r\nmac = ks8842_read16(adapter, 2, REG_MARM);\r\nks8842_write16(adapter, 39, mac, REG_MACAR2);\r\nmac = ks8842_read16(adapter, 2, REG_MARH);\r\nks8842_write16(adapter, 39, mac, REG_MACAR1);\r\n} else {\r\nmac = ks8842_read16(adapter, 2, REG_MARL);\r\nks8842_write16(adapter, 39, mac, REG_MACAR1);\r\nmac = ks8842_read16(adapter, 2, REG_MARM);\r\nks8842_write16(adapter, 39, mac, REG_MACAR2);\r\nmac = ks8842_read16(adapter, 2, REG_MARH);\r\nks8842_write16(adapter, 39, mac, REG_MACAR3);\r\n}\r\n}\r\nstatic void ks8842_write_mac_addr(struct ks8842_adapter *adapter, u8 *mac)\r\n{\r\nunsigned long flags;\r\nunsigned i;\r\nspin_lock_irqsave(&adapter->lock, flags);\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\nks8842_write8(adapter, 2, mac[ETH_ALEN - i - 1], REG_MARL + i);\r\nif (!(adapter->conf_flags & MICREL_KS884X))\r\nks8842_write8(adapter, 39, mac[ETH_ALEN - i - 1],\r\nREG_MACAR1 + i);\r\n}\r\nif (adapter->conf_flags & MICREL_KS884X) {\r\nu16 mac;\r\nmac = ks8842_read16(adapter, 2, REG_MARL);\r\nks8842_write16(adapter, 39, mac, REG_MACAR3);\r\nmac = ks8842_read16(adapter, 2, REG_MARM);\r\nks8842_write16(adapter, 39, mac, REG_MACAR2);\r\nmac = ks8842_read16(adapter, 2, REG_MARH);\r\nks8842_write16(adapter, 39, mac, REG_MACAR1);\r\n}\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\n}\r\nstatic inline u16 ks8842_tx_fifo_space(struct ks8842_adapter *adapter)\r\n{\r\nreturn ks8842_read16(adapter, 16, REG_TXMIR) & 0x1fff;\r\n}\r\nstatic int ks8842_tx_frame_dma(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct ks8842_adapter *adapter = netdev_priv(netdev);\r\nstruct ks8842_tx_dma_ctl *ctl = &adapter->dma_tx;\r\nu8 *buf = ctl->buf;\r\nif (ctl->adesc) {\r\nnetdev_dbg(netdev, "%s: TX ongoing\n", __func__);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nsg_dma_len(&ctl->sg) = skb->len + sizeof(u32);\r\n*buf++ = 0x00;\r\n*buf++ = 0x01;\r\n*buf++ = skb->len & 0xff;\r\n*buf++ = (skb->len >> 8) & 0xff;\r\nskb_copy_from_linear_data(skb, buf, skb->len);\r\ndma_sync_single_range_for_device(adapter->dev,\r\nsg_dma_address(&ctl->sg), 0, sg_dma_len(&ctl->sg),\r\nDMA_TO_DEVICE);\r\nif (sg_dma_len(&ctl->sg) % 4)\r\nsg_dma_len(&ctl->sg) += 4 - sg_dma_len(&ctl->sg) % 4;\r\nctl->adesc = dmaengine_prep_slave_sg(ctl->chan,\r\n&ctl->sg, 1, DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT);\r\nif (!ctl->adesc)\r\nreturn NETDEV_TX_BUSY;\r\nctl->adesc->callback_param = netdev;\r\nctl->adesc->callback = ks8842_dma_tx_cb;\r\nctl->adesc->tx_submit(ctl->adesc);\r\nnetdev->stats.tx_bytes += skb->len;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ks8842_tx_frame(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct ks8842_adapter *adapter = netdev_priv(netdev);\r\nint len = skb->len;\r\nnetdev_dbg(netdev, "%s: len %u head %p data %p tail %p end %p\n",\r\n__func__, skb->len, skb->head, skb->data,\r\nskb_tail_pointer(skb), skb_end_pointer(skb));\r\nif (ks8842_tx_fifo_space(adapter) < len + 8)\r\nreturn NETDEV_TX_BUSY;\r\nif (adapter->conf_flags & KS884X_16BIT) {\r\nu16 *ptr16 = (u16 *)skb->data;\r\nks8842_write16(adapter, 17, 0x8000 | 0x100, REG_QMU_DATA_LO);\r\nks8842_write16(adapter, 17, (u16)len, REG_QMU_DATA_HI);\r\nnetdev->stats.tx_bytes += len;\r\nwhile (len > 0) {\r\niowrite16(*ptr16++, adapter->hw_addr + REG_QMU_DATA_LO);\r\niowrite16(*ptr16++, adapter->hw_addr + REG_QMU_DATA_HI);\r\nlen -= sizeof(u32);\r\n}\r\n} else {\r\nu32 *ptr = (u32 *)skb->data;\r\nu32 ctrl;\r\nctrl = 0x8000 | 0x100 | (len << 16);\r\nks8842_write32(adapter, 17, ctrl, REG_QMU_DATA_LO);\r\nnetdev->stats.tx_bytes += len;\r\nwhile (len > 0) {\r\niowrite32(*ptr, adapter->hw_addr + REG_QMU_DATA_LO);\r\nlen -= sizeof(u32);\r\nptr++;\r\n}\r\n}\r\nks8842_write16(adapter, 17, 1, REG_TXQCR);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void ks8842_update_rx_err_counters(struct net_device *netdev, u32 status)\r\n{\r\nnetdev_dbg(netdev, "RX error, status: %x\n", status);\r\nnetdev->stats.rx_errors++;\r\nif (status & RXSR_TOO_LONG)\r\nnetdev->stats.rx_length_errors++;\r\nif (status & RXSR_CRC_ERROR)\r\nnetdev->stats.rx_crc_errors++;\r\nif (status & RXSR_RUNT)\r\nnetdev->stats.rx_frame_errors++;\r\n}\r\nstatic void ks8842_update_rx_counters(struct net_device *netdev, u32 status,\r\nint len)\r\n{\r\nnetdev_dbg(netdev, "RX packet, len: %d\n", len);\r\nnetdev->stats.rx_packets++;\r\nnetdev->stats.rx_bytes += len;\r\nif (status & RXSR_MULTICAST)\r\nnetdev->stats.multicast++;\r\n}\r\nstatic int __ks8842_start_new_rx_dma(struct net_device *netdev)\r\n{\r\nstruct ks8842_adapter *adapter = netdev_priv(netdev);\r\nstruct ks8842_rx_dma_ctl *ctl = &adapter->dma_rx;\r\nstruct scatterlist *sg = &ctl->sg;\r\nint err;\r\nctl->skb = netdev_alloc_skb(netdev, DMA_BUFFER_SIZE);\r\nif (ctl->skb) {\r\nsg_init_table(sg, 1);\r\nsg_dma_address(sg) = dma_map_single(adapter->dev,\r\nctl->skb->data, DMA_BUFFER_SIZE, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(adapter->dev, sg_dma_address(sg))) {\r\nerr = -ENOMEM;\r\nsg_dma_address(sg) = 0;\r\ngoto out;\r\n}\r\nsg_dma_len(sg) = DMA_BUFFER_SIZE;\r\nctl->adesc = dmaengine_prep_slave_sg(ctl->chan,\r\nsg, 1, DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT);\r\nif (!ctl->adesc) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nctl->adesc->callback_param = netdev;\r\nctl->adesc->callback = ks8842_dma_rx_cb;\r\nctl->adesc->tx_submit(ctl->adesc);\r\n} else {\r\nerr = -ENOMEM;\r\nsg_dma_address(sg) = 0;\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nif (sg_dma_address(sg))\r\ndma_unmap_single(adapter->dev, sg_dma_address(sg),\r\nDMA_BUFFER_SIZE, DMA_FROM_DEVICE);\r\nsg_dma_address(sg) = 0;\r\nif (ctl->skb)\r\ndev_kfree_skb(ctl->skb);\r\nctl->skb = NULL;\r\nprintk(KERN_ERR DRV_NAME": Failed to start RX DMA: %d\n", err);\r\nreturn err;\r\n}\r\nstatic void ks8842_rx_frame_dma_tasklet(unsigned long arg)\r\n{\r\nstruct net_device *netdev = (struct net_device *)arg;\r\nstruct ks8842_adapter *adapter = netdev_priv(netdev);\r\nstruct ks8842_rx_dma_ctl *ctl = &adapter->dma_rx;\r\nstruct sk_buff *skb = ctl->skb;\r\ndma_addr_t addr = sg_dma_address(&ctl->sg);\r\nu32 status;\r\nctl->adesc = NULL;\r\n__ks8842_start_new_rx_dma(netdev);\r\ndma_unmap_single(adapter->dev, addr, DMA_BUFFER_SIZE, DMA_FROM_DEVICE);\r\nstatus = *((u32 *)skb->data);\r\nnetdev_dbg(netdev, "%s - rx_data: status: %x\n",\r\n__func__, status & 0xffff);\r\nif ((status & RXSR_VALID) && !(status & RXSR_ERROR)) {\r\nint len = (status >> 16) & 0x7ff;\r\nks8842_update_rx_counters(netdev, status, len);\r\nskb_reserve(skb, 4);\r\nskb_put(skb, len);\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nnetif_rx(skb);\r\n} else {\r\nks8842_update_rx_err_counters(netdev, status);\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\nstatic void ks8842_rx_frame(struct net_device *netdev,\r\nstruct ks8842_adapter *adapter)\r\n{\r\nu32 status;\r\nint len;\r\nif (adapter->conf_flags & KS884X_16BIT) {\r\nstatus = ks8842_read16(adapter, 17, REG_QMU_DATA_LO);\r\nlen = ks8842_read16(adapter, 17, REG_QMU_DATA_HI);\r\nnetdev_dbg(netdev, "%s - rx_data: status: %x\n",\r\n__func__, status);\r\n} else {\r\nstatus = ks8842_read32(adapter, 17, REG_QMU_DATA_LO);\r\nlen = (status >> 16) & 0x7ff;\r\nstatus &= 0xffff;\r\nnetdev_dbg(netdev, "%s - rx_data: status: %x\n",\r\n__func__, status);\r\n}\r\nif ((status & RXSR_VALID) && !(status & RXSR_ERROR)) {\r\nstruct sk_buff *skb = netdev_alloc_skb_ip_align(netdev, len + 3);\r\nif (skb) {\r\nks8842_update_rx_counters(netdev, status, len);\r\nif (adapter->conf_flags & KS884X_16BIT) {\r\nu16 *data16 = skb_put(skb, len);\r\nks8842_select_bank(adapter, 17);\r\nwhile (len > 0) {\r\n*data16++ = ioread16(adapter->hw_addr +\r\nREG_QMU_DATA_LO);\r\n*data16++ = ioread16(adapter->hw_addr +\r\nREG_QMU_DATA_HI);\r\nlen -= sizeof(u32);\r\n}\r\n} else {\r\nu32 *data = skb_put(skb, len);\r\nks8842_select_bank(adapter, 17);\r\nwhile (len > 0) {\r\n*data++ = ioread32(adapter->hw_addr +\r\nREG_QMU_DATA_LO);\r\nlen -= sizeof(u32);\r\n}\r\n}\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nnetif_rx(skb);\r\n} else\r\nnetdev->stats.rx_dropped++;\r\n} else\r\nks8842_update_rx_err_counters(netdev, status);\r\nks8842_clear_bits(adapter, 0, 1 << 12, REG_QRFCR);\r\nks8842_write16(adapter, 17, 0x01, REG_RXQCR);\r\nks8842_enable_bits(adapter, 0, 1 << 12, REG_QRFCR);\r\n}\r\nstatic void ks8842_handle_rx(struct net_device *netdev,\r\nstruct ks8842_adapter *adapter)\r\n{\r\nu16 rx_data = ks8842_read16(adapter, 16, REG_RXMIR) & 0x1fff;\r\nnetdev_dbg(netdev, "%s Entry - rx_data: %d\n", __func__, rx_data);\r\nwhile (rx_data) {\r\nks8842_rx_frame(netdev, adapter);\r\nrx_data = ks8842_read16(adapter, 16, REG_RXMIR) & 0x1fff;\r\n}\r\n}\r\nstatic void ks8842_handle_tx(struct net_device *netdev,\r\nstruct ks8842_adapter *adapter)\r\n{\r\nu16 sr = ks8842_read16(adapter, 16, REG_TXSR);\r\nnetdev_dbg(netdev, "%s - entry, sr: %x\n", __func__, sr);\r\nnetdev->stats.tx_packets++;\r\nif (netif_queue_stopped(netdev))\r\nnetif_wake_queue(netdev);\r\n}\r\nstatic void ks8842_handle_rx_overrun(struct net_device *netdev,\r\nstruct ks8842_adapter *adapter)\r\n{\r\nnetdev_dbg(netdev, "%s: entry\n", __func__);\r\nnetdev->stats.rx_errors++;\r\nnetdev->stats.rx_fifo_errors++;\r\n}\r\nstatic void ks8842_tasklet(unsigned long arg)\r\n{\r\nstruct net_device *netdev = (struct net_device *)arg;\r\nstruct ks8842_adapter *adapter = netdev_priv(netdev);\r\nu16 isr;\r\nunsigned long flags;\r\nu16 entry_bank;\r\nspin_lock_irqsave(&adapter->lock, flags);\r\nentry_bank = ioread16(adapter->hw_addr + REG_SELECT_BANK);\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\nisr = ks8842_read16(adapter, 18, REG_ISR);\r\nnetdev_dbg(netdev, "%s - ISR: 0x%x\n", __func__, isr);\r\nif (KS8842_USE_DMA(adapter))\r\nisr &= ~IRQ_RX;\r\nks8842_write16(adapter, 18, isr, REG_ISR);\r\nif (!(adapter->conf_flags & MICREL_KS884X))\r\niowrite32(0x1, adapter->hw_addr + REG_TIMB_IAR);\r\nif (!netif_running(netdev))\r\nreturn;\r\nif (isr & IRQ_LINK_CHANGE)\r\nks8842_update_link_status(netdev, adapter);\r\nif (isr & (IRQ_RX | IRQ_RX_ERROR) && !KS8842_USE_DMA(adapter))\r\nks8842_handle_rx(netdev, adapter);\r\nif (isr & IRQ_TX)\r\nks8842_handle_tx(netdev, adapter);\r\nif (isr & IRQ_RX_OVERRUN)\r\nks8842_handle_rx_overrun(netdev, adapter);\r\nif (isr & IRQ_TX_STOPPED) {\r\nks8842_disable_tx(adapter);\r\nks8842_enable_tx(adapter);\r\n}\r\nif (isr & IRQ_RX_STOPPED) {\r\nks8842_disable_rx(adapter);\r\nks8842_enable_rx(adapter);\r\n}\r\nspin_lock_irqsave(&adapter->lock, flags);\r\nif (KS8842_USE_DMA(adapter))\r\nks8842_write16(adapter, 18, ENABLED_IRQS_DMA, REG_IER);\r\nelse\r\nks8842_write16(adapter, 18, ENABLED_IRQS, REG_IER);\r\niowrite16(entry_bank, adapter->hw_addr + REG_SELECT_BANK);\r\nif (KS8842_USE_DMA(adapter))\r\nks8842_resume_dma(adapter);\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\n}\r\nstatic irqreturn_t ks8842_irq(int irq, void *devid)\r\n{\r\nstruct net_device *netdev = devid;\r\nstruct ks8842_adapter *adapter = netdev_priv(netdev);\r\nu16 isr;\r\nu16 entry_bank = ioread16(adapter->hw_addr + REG_SELECT_BANK);\r\nirqreturn_t ret = IRQ_NONE;\r\nisr = ks8842_read16(adapter, 18, REG_ISR);\r\nnetdev_dbg(netdev, "%s - ISR: 0x%x\n", __func__, isr);\r\nif (isr) {\r\nif (KS8842_USE_DMA(adapter))\r\nks8842_write16(adapter, 18, IRQ_RX, REG_IER);\r\nelse\r\nks8842_write16(adapter, 18, 0x00, REG_IER);\r\ntasklet_schedule(&adapter->tasklet);\r\nret = IRQ_HANDLED;\r\n}\r\niowrite16(entry_bank, adapter->hw_addr + REG_SELECT_BANK);\r\nks8842_resume_dma(adapter);\r\nreturn ret;\r\n}\r\nstatic void ks8842_dma_rx_cb(void *data)\r\n{\r\nstruct net_device *netdev = data;\r\nstruct ks8842_adapter *adapter = netdev_priv(netdev);\r\nnetdev_dbg(netdev, "RX DMA finished\n");\r\nif (adapter->dma_rx.adesc)\r\ntasklet_schedule(&adapter->dma_rx.tasklet);\r\n}\r\nstatic void ks8842_dma_tx_cb(void *data)\r\n{\r\nstruct net_device *netdev = data;\r\nstruct ks8842_adapter *adapter = netdev_priv(netdev);\r\nstruct ks8842_tx_dma_ctl *ctl = &adapter->dma_tx;\r\nnetdev_dbg(netdev, "TX DMA finished\n");\r\nif (!ctl->adesc)\r\nreturn;\r\nnetdev->stats.tx_packets++;\r\nctl->adesc = NULL;\r\nif (netif_queue_stopped(netdev))\r\nnetif_wake_queue(netdev);\r\n}\r\nstatic void ks8842_stop_dma(struct ks8842_adapter *adapter)\r\n{\r\nstruct ks8842_tx_dma_ctl *tx_ctl = &adapter->dma_tx;\r\nstruct ks8842_rx_dma_ctl *rx_ctl = &adapter->dma_rx;\r\ntx_ctl->adesc = NULL;\r\nif (tx_ctl->chan)\r\ndmaengine_terminate_all(tx_ctl->chan);\r\nrx_ctl->adesc = NULL;\r\nif (rx_ctl->chan)\r\ndmaengine_terminate_all(rx_ctl->chan);\r\nif (sg_dma_address(&rx_ctl->sg))\r\ndma_unmap_single(adapter->dev, sg_dma_address(&rx_ctl->sg),\r\nDMA_BUFFER_SIZE, DMA_FROM_DEVICE);\r\nsg_dma_address(&rx_ctl->sg) = 0;\r\ndev_kfree_skb(rx_ctl->skb);\r\nrx_ctl->skb = NULL;\r\n}\r\nstatic void ks8842_dealloc_dma_bufs(struct ks8842_adapter *adapter)\r\n{\r\nstruct ks8842_tx_dma_ctl *tx_ctl = &adapter->dma_tx;\r\nstruct ks8842_rx_dma_ctl *rx_ctl = &adapter->dma_rx;\r\nks8842_stop_dma(adapter);\r\nif (tx_ctl->chan)\r\ndma_release_channel(tx_ctl->chan);\r\ntx_ctl->chan = NULL;\r\nif (rx_ctl->chan)\r\ndma_release_channel(rx_ctl->chan);\r\nrx_ctl->chan = NULL;\r\ntasklet_kill(&rx_ctl->tasklet);\r\nif (sg_dma_address(&tx_ctl->sg))\r\ndma_unmap_single(adapter->dev, sg_dma_address(&tx_ctl->sg),\r\nDMA_BUFFER_SIZE, DMA_TO_DEVICE);\r\nsg_dma_address(&tx_ctl->sg) = 0;\r\nkfree(tx_ctl->buf);\r\ntx_ctl->buf = NULL;\r\n}\r\nstatic bool ks8842_dma_filter_fn(struct dma_chan *chan, void *filter_param)\r\n{\r\nreturn chan->chan_id == (long)filter_param;\r\n}\r\nstatic int ks8842_alloc_dma_bufs(struct net_device *netdev)\r\n{\r\nstruct ks8842_adapter *adapter = netdev_priv(netdev);\r\nstruct ks8842_tx_dma_ctl *tx_ctl = &adapter->dma_tx;\r\nstruct ks8842_rx_dma_ctl *rx_ctl = &adapter->dma_rx;\r\nint err;\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndma_cap_set(DMA_PRIVATE, mask);\r\nsg_init_table(&tx_ctl->sg, 1);\r\ntx_ctl->chan = dma_request_channel(mask, ks8842_dma_filter_fn,\r\n(void *)(long)tx_ctl->channel);\r\nif (!tx_ctl->chan) {\r\nerr = -ENODEV;\r\ngoto err;\r\n}\r\ntx_ctl->buf = kmalloc(DMA_BUFFER_SIZE, GFP_KERNEL);\r\nif (!tx_ctl->buf) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\nsg_dma_address(&tx_ctl->sg) = dma_map_single(adapter->dev,\r\ntx_ctl->buf, DMA_BUFFER_SIZE, DMA_TO_DEVICE);\r\nif (dma_mapping_error(adapter->dev, sg_dma_address(&tx_ctl->sg))) {\r\nerr = -ENOMEM;\r\nsg_dma_address(&tx_ctl->sg) = 0;\r\ngoto err;\r\n}\r\nrx_ctl->chan = dma_request_channel(mask, ks8842_dma_filter_fn,\r\n(void *)(long)rx_ctl->channel);\r\nif (!rx_ctl->chan) {\r\nerr = -ENODEV;\r\ngoto err;\r\n}\r\ntasklet_init(&rx_ctl->tasklet, ks8842_rx_frame_dma_tasklet,\r\n(unsigned long)netdev);\r\nreturn 0;\r\nerr:\r\nks8842_dealloc_dma_bufs(adapter);\r\nreturn err;\r\n}\r\nstatic int ks8842_open(struct net_device *netdev)\r\n{\r\nstruct ks8842_adapter *adapter = netdev_priv(netdev);\r\nint err;\r\nnetdev_dbg(netdev, "%s - entry\n", __func__);\r\nif (KS8842_USE_DMA(adapter)) {\r\nerr = ks8842_alloc_dma_bufs(netdev);\r\nif (!err) {\r\nerr = __ks8842_start_new_rx_dma(netdev);\r\nif (err)\r\nks8842_dealloc_dma_bufs(adapter);\r\n}\r\nif (err) {\r\nprintk(KERN_WARNING DRV_NAME\r\n": Failed to initiate DMA, running PIO\n");\r\nks8842_dealloc_dma_bufs(adapter);\r\nadapter->dma_rx.channel = -1;\r\nadapter->dma_tx.channel = -1;\r\n}\r\n}\r\nks8842_reset_hw(adapter);\r\nks8842_write_mac_addr(adapter, netdev->dev_addr);\r\nks8842_update_link_status(netdev, adapter);\r\nerr = request_irq(adapter->irq, ks8842_irq, IRQF_SHARED, DRV_NAME,\r\nnetdev);\r\nif (err) {\r\npr_err("Failed to request IRQ: %d: %d\n", adapter->irq, err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ks8842_close(struct net_device *netdev)\r\n{\r\nstruct ks8842_adapter *adapter = netdev_priv(netdev);\r\nnetdev_dbg(netdev, "%s - entry\n", __func__);\r\ncancel_work_sync(&adapter->timeout_work);\r\nif (KS8842_USE_DMA(adapter))\r\nks8842_dealloc_dma_bufs(adapter);\r\nfree_irq(adapter->irq, netdev);\r\nks8842_write16(adapter, 32, 0x0, REG_SW_ID_AND_ENABLE);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t ks8842_xmit_frame(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nint ret;\r\nstruct ks8842_adapter *adapter = netdev_priv(netdev);\r\nnetdev_dbg(netdev, "%s: entry\n", __func__);\r\nif (KS8842_USE_DMA(adapter)) {\r\nunsigned long flags;\r\nret = ks8842_tx_frame_dma(skb, netdev);\r\nspin_lock_irqsave(&adapter->lock, flags);\r\nif (adapter->dma_tx.adesc)\r\nnetif_stop_queue(netdev);\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\nreturn ret;\r\n}\r\nret = ks8842_tx_frame(skb, netdev);\r\nif (ks8842_tx_fifo_space(adapter) < netdev->mtu + 8)\r\nnetif_stop_queue(netdev);\r\nreturn ret;\r\n}\r\nstatic int ks8842_set_mac(struct net_device *netdev, void *p)\r\n{\r\nstruct ks8842_adapter *adapter = netdev_priv(netdev);\r\nstruct sockaddr *addr = p;\r\nchar *mac = (u8 *)addr->sa_data;\r\nnetdev_dbg(netdev, "%s: entry\n", __func__);\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(netdev->dev_addr, mac, netdev->addr_len);\r\nks8842_write_mac_addr(adapter, mac);\r\nreturn 0;\r\n}\r\nstatic void ks8842_tx_timeout_work(struct work_struct *work)\r\n{\r\nstruct ks8842_adapter *adapter =\r\ncontainer_of(work, struct ks8842_adapter, timeout_work);\r\nstruct net_device *netdev = adapter->netdev;\r\nunsigned long flags;\r\nnetdev_dbg(netdev, "%s: entry\n", __func__);\r\nspin_lock_irqsave(&adapter->lock, flags);\r\nif (KS8842_USE_DMA(adapter))\r\nks8842_stop_dma(adapter);\r\nks8842_write16(adapter, 18, 0, REG_IER);\r\nks8842_write16(adapter, 18, 0xFFFF, REG_ISR);\r\nnetif_stop_queue(netdev);\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\nks8842_reset_hw(adapter);\r\nks8842_write_mac_addr(adapter, netdev->dev_addr);\r\nks8842_update_link_status(netdev, adapter);\r\nif (KS8842_USE_DMA(adapter))\r\n__ks8842_start_new_rx_dma(netdev);\r\n}\r\nstatic void ks8842_tx_timeout(struct net_device *netdev)\r\n{\r\nstruct ks8842_adapter *adapter = netdev_priv(netdev);\r\nnetdev_dbg(netdev, "%s: entry\n", __func__);\r\nschedule_work(&adapter->timeout_work);\r\n}\r\nstatic int ks8842_probe(struct platform_device *pdev)\r\n{\r\nint err = -ENOMEM;\r\nstruct resource *iomem;\r\nstruct net_device *netdev;\r\nstruct ks8842_adapter *adapter;\r\nstruct ks8842_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nu16 id;\r\nunsigned i;\r\niomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!request_mem_region(iomem->start, resource_size(iomem), DRV_NAME))\r\ngoto err_mem_region;\r\nnetdev = alloc_etherdev(sizeof(struct ks8842_adapter));\r\nif (!netdev)\r\ngoto err_alloc_etherdev;\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\nadapter = netdev_priv(netdev);\r\nadapter->netdev = netdev;\r\nINIT_WORK(&adapter->timeout_work, ks8842_tx_timeout_work);\r\nadapter->hw_addr = ioremap(iomem->start, resource_size(iomem));\r\nadapter->conf_flags = iomem->flags;\r\nif (!adapter->hw_addr)\r\ngoto err_ioremap;\r\nadapter->irq = platform_get_irq(pdev, 0);\r\nif (adapter->irq < 0) {\r\nerr = adapter->irq;\r\ngoto err_get_irq;\r\n}\r\nadapter->dev = (pdev->dev.parent) ? pdev->dev.parent : &pdev->dev;\r\nif (!(adapter->conf_flags & MICREL_KS884X) && pdata &&\r\n(pdata->tx_dma_channel != -1) &&\r\n(pdata->rx_dma_channel != -1)) {\r\nadapter->dma_rx.channel = pdata->rx_dma_channel;\r\nadapter->dma_tx.channel = pdata->tx_dma_channel;\r\n} else {\r\nadapter->dma_rx.channel = -1;\r\nadapter->dma_tx.channel = -1;\r\n}\r\ntasklet_init(&adapter->tasklet, ks8842_tasklet, (unsigned long)netdev);\r\nspin_lock_init(&adapter->lock);\r\nnetdev->netdev_ops = &ks8842_netdev_ops;\r\nnetdev->ethtool_ops = &ks8842_ethtool_ops;\r\ni = netdev->addr_len;\r\nif (pdata) {\r\nfor (i = 0; i < netdev->addr_len; i++)\r\nif (pdata->macaddr[i] != 0)\r\nbreak;\r\nif (i < netdev->addr_len)\r\nmemcpy(netdev->dev_addr, pdata->macaddr,\r\nnetdev->addr_len);\r\n}\r\nif (i == netdev->addr_len) {\r\nks8842_read_mac_addr(adapter, netdev->dev_addr);\r\nif (!is_valid_ether_addr(netdev->dev_addr))\r\neth_hw_addr_random(netdev);\r\n}\r\nid = ks8842_read16(adapter, 32, REG_SW_ID_AND_ENABLE);\r\nstrcpy(netdev->name, "eth%d");\r\nerr = register_netdev(netdev);\r\nif (err)\r\ngoto err_register;\r\nplatform_set_drvdata(pdev, netdev);\r\npr_info("Found chip, family: 0x%x, id: 0x%x, rev: 0x%x\n",\r\n(id >> 8) & 0xff, (id >> 4) & 0xf, (id >> 1) & 0x7);\r\nreturn 0;\r\nerr_register:\r\nerr_get_irq:\r\niounmap(adapter->hw_addr);\r\nerr_ioremap:\r\nfree_netdev(netdev);\r\nerr_alloc_etherdev:\r\nrelease_mem_region(iomem->start, resource_size(iomem));\r\nerr_mem_region:\r\nreturn err;\r\n}\r\nstatic int ks8842_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *netdev = platform_get_drvdata(pdev);\r\nstruct ks8842_adapter *adapter = netdev_priv(netdev);\r\nstruct resource *iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nunregister_netdev(netdev);\r\ntasklet_kill(&adapter->tasklet);\r\niounmap(adapter->hw_addr);\r\nfree_netdev(netdev);\r\nrelease_mem_region(iomem->start, resource_size(iomem));\r\nreturn 0;\r\n}
