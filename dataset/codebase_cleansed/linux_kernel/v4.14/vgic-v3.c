void vgic_v3_set_underflow(struct kvm_vcpu *vcpu)\r\n{\r\nstruct vgic_v3_cpu_if *cpuif = &vcpu->arch.vgic_cpu.vgic_v3;\r\ncpuif->vgic_hcr |= ICH_HCR_UIE;\r\n}\r\nstatic bool lr_signals_eoi_mi(u64 lr_val)\r\n{\r\nreturn !(lr_val & ICH_LR_STATE) && (lr_val & ICH_LR_EOI) &&\r\n!(lr_val & ICH_LR_HW);\r\n}\r\nvoid vgic_v3_fold_lr_state(struct kvm_vcpu *vcpu)\r\n{\r\nstruct vgic_cpu *vgic_cpu = &vcpu->arch.vgic_cpu;\r\nstruct vgic_v3_cpu_if *cpuif = &vgic_cpu->vgic_v3;\r\nu32 model = vcpu->kvm->arch.vgic.vgic_model;\r\nint lr;\r\ncpuif->vgic_hcr &= ~ICH_HCR_UIE;\r\nfor (lr = 0; lr < vgic_cpu->used_lrs; lr++) {\r\nu64 val = cpuif->vgic_lr[lr];\r\nu32 intid;\r\nstruct vgic_irq *irq;\r\nif (model == KVM_DEV_TYPE_ARM_VGIC_V3)\r\nintid = val & ICH_LR_VIRTUAL_ID_MASK;\r\nelse\r\nintid = val & GICH_LR_VIRTUALID;\r\nif (lr_signals_eoi_mi(val) && vgic_valid_spi(vcpu->kvm, intid))\r\nkvm_notify_acked_irq(vcpu->kvm, 0,\r\nintid - VGIC_NR_PRIVATE_IRQS);\r\nirq = vgic_get_irq(vcpu->kvm, vcpu, intid);\r\nif (!irq)\r\ncontinue;\r\nspin_lock(&irq->irq_lock);\r\nirq->active = !!(val & ICH_LR_ACTIVE_BIT);\r\nif (irq->config == VGIC_CONFIG_EDGE &&\r\n(val & ICH_LR_PENDING_BIT)) {\r\nirq->pending_latch = true;\r\nif (vgic_irq_is_sgi(intid) &&\r\nmodel == KVM_DEV_TYPE_ARM_VGIC_V2) {\r\nu32 cpuid = val & GICH_LR_PHYSID_CPUID;\r\ncpuid >>= GICH_LR_PHYSID_CPUID_SHIFT;\r\nirq->source |= (1 << cpuid);\r\n}\r\n}\r\nif (irq->config == VGIC_CONFIG_LEVEL) {\r\nif (!(val & ICH_LR_PENDING_BIT))\r\nirq->pending_latch = false;\r\n}\r\nspin_unlock(&irq->irq_lock);\r\nvgic_put_irq(vcpu->kvm, irq);\r\n}\r\nvgic_cpu->used_lrs = 0;\r\n}\r\nvoid vgic_v3_populate_lr(struct kvm_vcpu *vcpu, struct vgic_irq *irq, int lr)\r\n{\r\nu32 model = vcpu->kvm->arch.vgic.vgic_model;\r\nu64 val = irq->intid;\r\nif (irq_is_pending(irq)) {\r\nval |= ICH_LR_PENDING_BIT;\r\nif (irq->config == VGIC_CONFIG_EDGE)\r\nirq->pending_latch = false;\r\nif (vgic_irq_is_sgi(irq->intid) &&\r\nmodel == KVM_DEV_TYPE_ARM_VGIC_V2) {\r\nu32 src = ffs(irq->source);\r\nBUG_ON(!src);\r\nval |= (src - 1) << GICH_LR_PHYSID_CPUID_SHIFT;\r\nirq->source &= ~(1 << (src - 1));\r\nif (irq->source)\r\nirq->pending_latch = true;\r\n}\r\n}\r\nif (irq->active)\r\nval |= ICH_LR_ACTIVE_BIT;\r\nif (irq->hw) {\r\nval |= ICH_LR_HW;\r\nval |= ((u64)irq->hwintid) << ICH_LR_PHYS_ID_SHIFT;\r\nif (irq->active && irq_is_pending(irq))\r\nval &= ~ICH_LR_PENDING_BIT;\r\n} else {\r\nif (irq->config == VGIC_CONFIG_LEVEL)\r\nval |= ICH_LR_EOI;\r\n}\r\nif (model == KVM_DEV_TYPE_ARM_VGIC_V3)\r\nval |= ICH_LR_GROUP;\r\nval |= (u64)irq->priority << ICH_LR_PRIORITY_SHIFT;\r\nvcpu->arch.vgic_cpu.vgic_v3.vgic_lr[lr] = val;\r\n}\r\nvoid vgic_v3_clear_lr(struct kvm_vcpu *vcpu, int lr)\r\n{\r\nvcpu->arch.vgic_cpu.vgic_v3.vgic_lr[lr] = 0;\r\n}\r\nvoid vgic_v3_set_vmcr(struct kvm_vcpu *vcpu, struct vgic_vmcr *vmcrp)\r\n{\r\nstruct vgic_v3_cpu_if *cpu_if = &vcpu->arch.vgic_cpu.vgic_v3;\r\nu32 model = vcpu->kvm->arch.vgic.vgic_model;\r\nu32 vmcr;\r\nif (model == KVM_DEV_TYPE_ARM_VGIC_V2) {\r\nvmcr = (vmcrp->ackctl << ICH_VMCR_ACK_CTL_SHIFT) &\r\nICH_VMCR_ACK_CTL_MASK;\r\nvmcr |= (vmcrp->fiqen << ICH_VMCR_FIQ_EN_SHIFT) &\r\nICH_VMCR_FIQ_EN_MASK;\r\n} else {\r\nvmcr = ICH_VMCR_FIQ_EN_MASK;\r\n}\r\nvmcr |= (vmcrp->cbpr << ICH_VMCR_CBPR_SHIFT) & ICH_VMCR_CBPR_MASK;\r\nvmcr |= (vmcrp->eoim << ICH_VMCR_EOIM_SHIFT) & ICH_VMCR_EOIM_MASK;\r\nvmcr |= (vmcrp->abpr << ICH_VMCR_BPR1_SHIFT) & ICH_VMCR_BPR1_MASK;\r\nvmcr |= (vmcrp->bpr << ICH_VMCR_BPR0_SHIFT) & ICH_VMCR_BPR0_MASK;\r\nvmcr |= (vmcrp->pmr << ICH_VMCR_PMR_SHIFT) & ICH_VMCR_PMR_MASK;\r\nvmcr |= (vmcrp->grpen0 << ICH_VMCR_ENG0_SHIFT) & ICH_VMCR_ENG0_MASK;\r\nvmcr |= (vmcrp->grpen1 << ICH_VMCR_ENG1_SHIFT) & ICH_VMCR_ENG1_MASK;\r\ncpu_if->vgic_vmcr = vmcr;\r\n}\r\nvoid vgic_v3_get_vmcr(struct kvm_vcpu *vcpu, struct vgic_vmcr *vmcrp)\r\n{\r\nstruct vgic_v3_cpu_if *cpu_if = &vcpu->arch.vgic_cpu.vgic_v3;\r\nu32 model = vcpu->kvm->arch.vgic.vgic_model;\r\nu32 vmcr;\r\nvmcr = cpu_if->vgic_vmcr;\r\nif (model == KVM_DEV_TYPE_ARM_VGIC_V2) {\r\nvmcrp->ackctl = (vmcr & ICH_VMCR_ACK_CTL_MASK) >>\r\nICH_VMCR_ACK_CTL_SHIFT;\r\nvmcrp->fiqen = (vmcr & ICH_VMCR_FIQ_EN_MASK) >>\r\nICH_VMCR_FIQ_EN_SHIFT;\r\n} else {\r\nvmcrp->fiqen = 1;\r\nvmcrp->ackctl = 0;\r\n}\r\nvmcrp->cbpr = (vmcr & ICH_VMCR_CBPR_MASK) >> ICH_VMCR_CBPR_SHIFT;\r\nvmcrp->eoim = (vmcr & ICH_VMCR_EOIM_MASK) >> ICH_VMCR_EOIM_SHIFT;\r\nvmcrp->abpr = (vmcr & ICH_VMCR_BPR1_MASK) >> ICH_VMCR_BPR1_SHIFT;\r\nvmcrp->bpr = (vmcr & ICH_VMCR_BPR0_MASK) >> ICH_VMCR_BPR0_SHIFT;\r\nvmcrp->pmr = (vmcr & ICH_VMCR_PMR_MASK) >> ICH_VMCR_PMR_SHIFT;\r\nvmcrp->grpen0 = (vmcr & ICH_VMCR_ENG0_MASK) >> ICH_VMCR_ENG0_SHIFT;\r\nvmcrp->grpen1 = (vmcr & ICH_VMCR_ENG1_MASK) >> ICH_VMCR_ENG1_SHIFT;\r\n}\r\nvoid vgic_v3_enable(struct kvm_vcpu *vcpu)\r\n{\r\nstruct vgic_v3_cpu_if *vgic_v3 = &vcpu->arch.vgic_cpu.vgic_v3;\r\nvgic_v3->vgic_vmcr = 0;\r\nvgic_v3->vgic_elrsr = ~0;\r\nif (vcpu->kvm->arch.vgic.vgic_model == KVM_DEV_TYPE_ARM_VGIC_V3) {\r\nvgic_v3->vgic_sre = (ICC_SRE_EL1_DIB |\r\nICC_SRE_EL1_DFB |\r\nICC_SRE_EL1_SRE);\r\nvcpu->arch.vgic_cpu.pendbaser = INITIAL_PENDBASER_VALUE;\r\n} else {\r\nvgic_v3->vgic_sre = 0;\r\n}\r\nvcpu->arch.vgic_cpu.num_id_bits = (kvm_vgic_global_state.ich_vtr_el2 &\r\nICH_VTR_ID_BITS_MASK) >>\r\nICH_VTR_ID_BITS_SHIFT;\r\nvcpu->arch.vgic_cpu.num_pri_bits = ((kvm_vgic_global_state.ich_vtr_el2 &\r\nICH_VTR_PRI_BITS_MASK) >>\r\nICH_VTR_PRI_BITS_SHIFT) + 1;\r\nvgic_v3->vgic_hcr = ICH_HCR_EN;\r\nif (group0_trap)\r\nvgic_v3->vgic_hcr |= ICH_HCR_TALL0;\r\nif (group1_trap)\r\nvgic_v3->vgic_hcr |= ICH_HCR_TALL1;\r\nif (common_trap)\r\nvgic_v3->vgic_hcr |= ICH_HCR_TC;\r\n}\r\nint vgic_v3_lpi_sync_pending_status(struct kvm *kvm, struct vgic_irq *irq)\r\n{\r\nstruct kvm_vcpu *vcpu;\r\nint byte_offset, bit_nr;\r\ngpa_t pendbase, ptr;\r\nbool status;\r\nu8 val;\r\nint ret;\r\nretry:\r\nvcpu = irq->target_vcpu;\r\nif (!vcpu)\r\nreturn 0;\r\npendbase = GICR_PENDBASER_ADDRESS(vcpu->arch.vgic_cpu.pendbaser);\r\nbyte_offset = irq->intid / BITS_PER_BYTE;\r\nbit_nr = irq->intid % BITS_PER_BYTE;\r\nptr = pendbase + byte_offset;\r\nret = kvm_read_guest(kvm, ptr, &val, 1);\r\nif (ret)\r\nreturn ret;\r\nstatus = val & (1 << bit_nr);\r\nspin_lock(&irq->irq_lock);\r\nif (irq->target_vcpu != vcpu) {\r\nspin_unlock(&irq->irq_lock);\r\ngoto retry;\r\n}\r\nirq->pending_latch = status;\r\nvgic_queue_irq_unlock(vcpu->kvm, irq);\r\nif (status) {\r\nval &= ~(1 << bit_nr);\r\nret = kvm_write_guest(kvm, ptr, &val, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint vgic_v3_save_pending_tables(struct kvm *kvm)\r\n{\r\nstruct vgic_dist *dist = &kvm->arch.vgic;\r\nint last_byte_offset = -1;\r\nstruct vgic_irq *irq;\r\nint ret;\r\nlist_for_each_entry(irq, &dist->lpi_list_head, lpi_list) {\r\nint byte_offset, bit_nr;\r\nstruct kvm_vcpu *vcpu;\r\ngpa_t pendbase, ptr;\r\nbool stored;\r\nu8 val;\r\nvcpu = irq->target_vcpu;\r\nif (!vcpu)\r\ncontinue;\r\npendbase = GICR_PENDBASER_ADDRESS(vcpu->arch.vgic_cpu.pendbaser);\r\nbyte_offset = irq->intid / BITS_PER_BYTE;\r\nbit_nr = irq->intid % BITS_PER_BYTE;\r\nptr = pendbase + byte_offset;\r\nif (byte_offset != last_byte_offset) {\r\nret = kvm_read_guest(kvm, ptr, &val, 1);\r\nif (ret)\r\nreturn ret;\r\nlast_byte_offset = byte_offset;\r\n}\r\nstored = val & (1U << bit_nr);\r\nif (stored == irq->pending_latch)\r\ncontinue;\r\nif (irq->pending_latch)\r\nval |= 1 << bit_nr;\r\nelse\r\nval &= ~(1 << bit_nr);\r\nret = kvm_write_guest(kvm, ptr, &val, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nbool vgic_v3_check_base(struct kvm *kvm)\r\n{\r\nstruct vgic_dist *d = &kvm->arch.vgic;\r\ngpa_t redist_size = KVM_VGIC_V3_REDIST_SIZE;\r\nredist_size *= atomic_read(&kvm->online_vcpus);\r\nif (!IS_VGIC_ADDR_UNDEF(d->vgic_dist_base) &&\r\nd->vgic_dist_base + KVM_VGIC_V3_DIST_SIZE < d->vgic_dist_base)\r\nreturn false;\r\nif (!IS_VGIC_ADDR_UNDEF(d->vgic_redist_base) &&\r\nd->vgic_redist_base + redist_size < d->vgic_redist_base)\r\nreturn false;\r\nif (IS_VGIC_ADDR_UNDEF(d->vgic_dist_base) ||\r\nIS_VGIC_ADDR_UNDEF(d->vgic_redist_base))\r\nreturn true;\r\nif (d->vgic_dist_base + KVM_VGIC_V3_DIST_SIZE <= d->vgic_redist_base)\r\nreturn true;\r\nif (d->vgic_redist_base + redist_size <= d->vgic_dist_base)\r\nreturn true;\r\nreturn false;\r\n}\r\nint vgic_v3_map_resources(struct kvm *kvm)\r\n{\r\nint ret = 0;\r\nstruct vgic_dist *dist = &kvm->arch.vgic;\r\nif (vgic_ready(kvm))\r\ngoto out;\r\nif (IS_VGIC_ADDR_UNDEF(dist->vgic_dist_base) ||\r\nIS_VGIC_ADDR_UNDEF(dist->vgic_redist_base)) {\r\nkvm_err("Need to set vgic distributor addresses first\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nif (!vgic_v3_check_base(kvm)) {\r\nkvm_err("VGIC redist and dist frames overlap\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (!vgic_initialized(kvm)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nret = vgic_register_dist_iodev(kvm, dist->vgic_dist_base, VGIC_V3);\r\nif (ret) {\r\nkvm_err("Unable to register VGICv3 dist MMIO regions\n");\r\ngoto out;\r\n}\r\ndist->ready = true;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init early_group0_trap_cfg(char *buf)\r\n{\r\nreturn strtobool(buf, &group0_trap);\r\n}\r\nstatic int __init early_group1_trap_cfg(char *buf)\r\n{\r\nreturn strtobool(buf, &group1_trap);\r\n}\r\nstatic int __init early_common_trap_cfg(char *buf)\r\n{\r\nreturn strtobool(buf, &common_trap);\r\n}\r\nint vgic_v3_probe(const struct gic_kvm_info *info)\r\n{\r\nu32 ich_vtr_el2 = kvm_call_hyp(__vgic_v3_get_ich_vtr_el2);\r\nint ret;\r\nkvm_vgic_global_state.nr_lr = (ich_vtr_el2 & 0xf) + 1;\r\nkvm_vgic_global_state.can_emulate_gicv2 = false;\r\nkvm_vgic_global_state.ich_vtr_el2 = ich_vtr_el2;\r\nif (!info->vcpu.start) {\r\nkvm_info("GICv3: no GICV resource entry\n");\r\nkvm_vgic_global_state.vcpu_base = 0;\r\n} else if (!PAGE_ALIGNED(info->vcpu.start)) {\r\npr_warn("GICV physical address 0x%llx not page aligned\n",\r\n(unsigned long long)info->vcpu.start);\r\nkvm_vgic_global_state.vcpu_base = 0;\r\n} else if (!PAGE_ALIGNED(resource_size(&info->vcpu))) {\r\npr_warn("GICV size 0x%llx not a multiple of page size 0x%lx\n",\r\n(unsigned long long)resource_size(&info->vcpu),\r\nPAGE_SIZE);\r\nkvm_vgic_global_state.vcpu_base = 0;\r\n} else {\r\nkvm_vgic_global_state.vcpu_base = info->vcpu.start;\r\nkvm_vgic_global_state.can_emulate_gicv2 = true;\r\nret = kvm_register_vgic_device(KVM_DEV_TYPE_ARM_VGIC_V2);\r\nif (ret) {\r\nkvm_err("Cannot register GICv2 KVM device.\n");\r\nreturn ret;\r\n}\r\nkvm_info("vgic-v2@%llx\n", info->vcpu.start);\r\n}\r\nret = kvm_register_vgic_device(KVM_DEV_TYPE_ARM_VGIC_V3);\r\nif (ret) {\r\nkvm_err("Cannot register GICv3 KVM device.\n");\r\nkvm_unregister_device_ops(KVM_DEV_TYPE_ARM_VGIC_V2);\r\nreturn ret;\r\n}\r\nif (kvm_vgic_global_state.vcpu_base == 0)\r\nkvm_info("disabling GICv2 emulation\n");\r\n#ifdef CONFIG_ARM64\r\nif (cpus_have_const_cap(ARM64_WORKAROUND_CAVIUM_30115)) {\r\ngroup0_trap = true;\r\ngroup1_trap = true;\r\n}\r\n#endif\r\nif (group0_trap || group1_trap || common_trap) {\r\nkvm_info("GICv3 sysreg trapping enabled ([%s%s%s], reduced performance)\n",\r\ngroup0_trap ? "G0" : "",\r\ngroup1_trap ? "G1" : "",\r\ncommon_trap ? "C" : "");\r\nstatic_branch_enable(&vgic_v3_cpuif_trap);\r\n}\r\nkvm_vgic_global_state.vctrl_base = NULL;\r\nkvm_vgic_global_state.type = VGIC_V3;\r\nkvm_vgic_global_state.max_gic_vcpus = VGIC_V3_MAX_CPUS;\r\nreturn 0;\r\n}\r\nvoid vgic_v3_load(struct kvm_vcpu *vcpu)\r\n{\r\nstruct vgic_v3_cpu_if *cpu_if = &vcpu->arch.vgic_cpu.vgic_v3;\r\nif (likely(cpu_if->vgic_sre))\r\nkvm_call_hyp(__vgic_v3_write_vmcr, cpu_if->vgic_vmcr);\r\n}\r\nvoid vgic_v3_put(struct kvm_vcpu *vcpu)\r\n{\r\nstruct vgic_v3_cpu_if *cpu_if = &vcpu->arch.vgic_cpu.vgic_v3;\r\nif (likely(cpu_if->vgic_sre))\r\ncpu_if->vgic_vmcr = kvm_call_hyp(__vgic_v3_read_vmcr);\r\n}
