static int timeriomem_rng_read(struct hwrng *hwrng, void *data,\r\nsize_t max, bool wait)\r\n{\r\nstruct timeriomem_rng_private *priv =\r\ncontainer_of(hwrng, struct timeriomem_rng_private, rng_ops);\r\nint retval = 0;\r\nint period_us = ktime_to_us(priv->period);\r\nif (max < sizeof(u32))\r\nreturn 0;\r\nif (!wait && !priv->present)\r\nreturn 0;\r\nwait_for_completion(&priv->completion);\r\ndo {\r\nif (retval > 0)\r\nusleep_range(period_us,\r\nperiod_us + min(1, period_us / 100));\r\n*(u32 *)data = readl(priv->io_base);\r\nretval += sizeof(u32);\r\ndata += sizeof(u32);\r\nmax -= sizeof(u32);\r\n} while (wait && max > sizeof(u32));\r\npriv->present = 0;\r\nreinit_completion(&priv->completion);\r\nhrtimer_forward_now(&priv->timer, priv->period);\r\nhrtimer_restart(&priv->timer);\r\nreturn retval;\r\n}\r\nstatic enum hrtimer_restart timeriomem_rng_trigger(struct hrtimer *timer)\r\n{\r\nstruct timeriomem_rng_private *priv\r\n= container_of(timer, struct timeriomem_rng_private, timer);\r\npriv->present = 1;\r\ncomplete(&priv->completion);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic int timeriomem_rng_probe(struct platform_device *pdev)\r\n{\r\nstruct timeriomem_rng_data *pdata = pdev->dev.platform_data;\r\nstruct timeriomem_rng_private *priv;\r\nstruct resource *res;\r\nint err = 0;\r\nint period;\r\nif (!pdev->dev.of_node && !pdata) {\r\ndev_err(&pdev->dev, "timeriomem_rng_data is missing\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENXIO;\r\nif (res->start % 4 != 0 || resource_size(res) != 4) {\r\ndev_err(&pdev->dev,\r\n"address must be four bytes wide and aligned\n");\r\nreturn -EINVAL;\r\n}\r\npriv = devm_kzalloc(&pdev->dev,\r\nsizeof(struct timeriomem_rng_private), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, priv);\r\nif (pdev->dev.of_node) {\r\nint i;\r\nif (!of_property_read_u32(pdev->dev.of_node,\r\n"period", &i))\r\nperiod = i;\r\nelse {\r\ndev_err(&pdev->dev, "missing period\n");\r\nreturn -EINVAL;\r\n}\r\nif (!of_property_read_u32(pdev->dev.of_node,\r\n"quality", &i))\r\npriv->rng_ops.quality = i;\r\nelse\r\npriv->rng_ops.quality = 0;\r\n} else {\r\nperiod = pdata->period;\r\npriv->rng_ops.quality = pdata->quality;\r\n}\r\npriv->period = ns_to_ktime(period * NSEC_PER_USEC);\r\ninit_completion(&priv->completion);\r\nhrtimer_init(&priv->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\npriv->timer.function = timeriomem_rng_trigger;\r\npriv->rng_ops.name = dev_name(&pdev->dev);\r\npriv->rng_ops.read = timeriomem_rng_read;\r\npriv->io_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(priv->io_base)) {\r\nreturn PTR_ERR(priv->io_base);\r\n}\r\npriv->present = 1;\r\ncomplete(&priv->completion);\r\nerr = hwrng_register(&priv->rng_ops);\r\nif (err) {\r\ndev_err(&pdev->dev, "problem registering\n");\r\nreturn err;\r\n}\r\ndev_info(&pdev->dev, "32bits from 0x%p @ %dus\n",\r\npriv->io_base, period);\r\nreturn 0;\r\n}\r\nstatic int timeriomem_rng_remove(struct platform_device *pdev)\r\n{\r\nstruct timeriomem_rng_private *priv = platform_get_drvdata(pdev);\r\nhwrng_unregister(&priv->rng_ops);\r\nhrtimer_cancel(&priv->timer);\r\nreturn 0;\r\n}
