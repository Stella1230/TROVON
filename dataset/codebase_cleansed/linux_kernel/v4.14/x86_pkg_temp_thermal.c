static int pkg_temp_debugfs_init(void)\r\n{\r\nstruct dentry *d;\r\ndebugfs = debugfs_create_dir("pkg_temp_thermal", NULL);\r\nif (!debugfs)\r\nreturn -ENOENT;\r\nd = debugfs_create_u32("pkg_thres_interrupt", S_IRUGO, debugfs,\r\n(u32 *)&pkg_interrupt_cnt);\r\nif (!d)\r\ngoto err_out;\r\nd = debugfs_create_u32("pkg_thres_work", S_IRUGO, debugfs,\r\n(u32 *)&pkg_work_cnt);\r\nif (!d)\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\ndebugfs_remove_recursive(debugfs);\r\nreturn -ENOENT;\r\n}\r\nstatic struct pkg_device *pkg_temp_thermal_get_dev(unsigned int cpu)\r\n{\r\nint pkgid = topology_logical_package_id(cpu);\r\nif (pkgid >= 0 && pkgid < max_packages)\r\nreturn packages[pkgid];\r\nreturn NULL;\r\n}\r\nstatic int get_tj_max(int cpu, u32 *tj_max)\r\n{\r\nu32 eax, edx, val;\r\nint err;\r\nerr = rdmsr_safe_on_cpu(cpu, MSR_IA32_TEMPERATURE_TARGET, &eax, &edx);\r\nif (err)\r\nreturn err;\r\nval = (eax >> 16) & 0xff;\r\n*tj_max = val * 1000;\r\nreturn val ? 0 : -EINVAL;\r\n}\r\nstatic int sys_get_curr_temp(struct thermal_zone_device *tzd, int *temp)\r\n{\r\nstruct pkg_device *pkgdev = tzd->devdata;\r\nu32 eax, edx;\r\nrdmsr_on_cpu(pkgdev->cpu, MSR_IA32_PACKAGE_THERM_STATUS, &eax, &edx);\r\nif (eax & 0x80000000) {\r\n*temp = pkgdev->tj_max - ((eax >> 16) & 0x7f) * 1000;\r\npr_debug("sys_get_curr_temp %d\n", *temp);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sys_get_trip_temp(struct thermal_zone_device *tzd,\r\nint trip, int *temp)\r\n{\r\nstruct pkg_device *pkgdev = tzd->devdata;\r\nunsigned long thres_reg_value;\r\nu32 mask, shift, eax, edx;\r\nint ret;\r\nif (trip >= MAX_NUMBER_OF_TRIPS)\r\nreturn -EINVAL;\r\nif (trip) {\r\nmask = THERM_MASK_THRESHOLD1;\r\nshift = THERM_SHIFT_THRESHOLD1;\r\n} else {\r\nmask = THERM_MASK_THRESHOLD0;\r\nshift = THERM_SHIFT_THRESHOLD0;\r\n}\r\nret = rdmsr_on_cpu(pkgdev->cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT,\r\n&eax, &edx);\r\nif (ret < 0)\r\nreturn ret;\r\nthres_reg_value = (eax & mask) >> shift;\r\nif (thres_reg_value)\r\n*temp = pkgdev->tj_max - thres_reg_value * 1000;\r\nelse\r\n*temp = 0;\r\npr_debug("sys_get_trip_temp %d\n", *temp);\r\nreturn 0;\r\n}\r\nstatic int\r\nsys_set_trip_temp(struct thermal_zone_device *tzd, int trip, int temp)\r\n{\r\nstruct pkg_device *pkgdev = tzd->devdata;\r\nu32 l, h, mask, shift, intr;\r\nint ret;\r\nif (trip >= MAX_NUMBER_OF_TRIPS || temp >= pkgdev->tj_max)\r\nreturn -EINVAL;\r\nret = rdmsr_on_cpu(pkgdev->cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT,\r\n&l, &h);\r\nif (ret < 0)\r\nreturn ret;\r\nif (trip) {\r\nmask = THERM_MASK_THRESHOLD1;\r\nshift = THERM_SHIFT_THRESHOLD1;\r\nintr = THERM_INT_THRESHOLD1_ENABLE;\r\n} else {\r\nmask = THERM_MASK_THRESHOLD0;\r\nshift = THERM_SHIFT_THRESHOLD0;\r\nintr = THERM_INT_THRESHOLD0_ENABLE;\r\n}\r\nl &= ~mask;\r\nif (!temp) {\r\nl &= ~intr;\r\n} else {\r\nl |= (pkgdev->tj_max - temp)/1000 << shift;\r\nl |= intr;\r\n}\r\nreturn wrmsr_on_cpu(pkgdev->cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\r\n}\r\nstatic int sys_get_trip_type(struct thermal_zone_device *thermal, int trip,\r\nenum thermal_trip_type *type)\r\n{\r\n*type = THERMAL_TRIP_PASSIVE;\r\nreturn 0;\r\n}\r\nstatic bool pkg_thermal_rate_control(void)\r\n{\r\nreturn true;\r\n}\r\nstatic inline void enable_pkg_thres_interrupt(void)\r\n{\r\nu8 thres_0, thres_1;\r\nu32 l, h;\r\nrdmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\r\nthres_0 = (l & THERM_MASK_THRESHOLD0) >> THERM_SHIFT_THRESHOLD0;\r\nthres_1 = (l & THERM_MASK_THRESHOLD1) >> THERM_SHIFT_THRESHOLD1;\r\nif (thres_0)\r\nl |= THERM_INT_THRESHOLD0_ENABLE;\r\nif (thres_1)\r\nl |= THERM_INT_THRESHOLD1_ENABLE;\r\nwrmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\r\n}\r\nstatic inline void disable_pkg_thres_interrupt(void)\r\n{\r\nu32 l, h;\r\nrdmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\r\nl &= ~(THERM_INT_THRESHOLD0_ENABLE | THERM_INT_THRESHOLD1_ENABLE);\r\nwrmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\r\n}\r\nstatic void pkg_temp_thermal_threshold_work_fn(struct work_struct *work)\r\n{\r\nstruct thermal_zone_device *tzone = NULL;\r\nint cpu = smp_processor_id();\r\nstruct pkg_device *pkgdev;\r\nu64 msr_val, wr_val;\r\nmutex_lock(&thermal_zone_mutex);\r\nspin_lock_irq(&pkg_temp_lock);\r\n++pkg_work_cnt;\r\npkgdev = pkg_temp_thermal_get_dev(cpu);\r\nif (!pkgdev) {\r\nspin_unlock_irq(&pkg_temp_lock);\r\nmutex_unlock(&thermal_zone_mutex);\r\nreturn;\r\n}\r\npkgdev->work_scheduled = false;\r\nrdmsrl(MSR_IA32_PACKAGE_THERM_STATUS, msr_val);\r\nwr_val = msr_val & ~(THERM_LOG_THRESHOLD0 | THERM_LOG_THRESHOLD1);\r\nif (wr_val != msr_val) {\r\nwrmsrl(MSR_IA32_PACKAGE_THERM_STATUS, wr_val);\r\ntzone = pkgdev->tzone;\r\n}\r\nenable_pkg_thres_interrupt();\r\nspin_unlock_irq(&pkg_temp_lock);\r\nif (tzone)\r\nthermal_zone_device_update(tzone, THERMAL_EVENT_UNSPECIFIED);\r\nmutex_unlock(&thermal_zone_mutex);\r\n}\r\nstatic void pkg_thermal_schedule_work(int cpu, struct delayed_work *work)\r\n{\r\nunsigned long ms = msecs_to_jiffies(notify_delay_ms);\r\nschedule_delayed_work_on(cpu, work, ms);\r\n}\r\nstatic int pkg_thermal_notify(u64 msr_val)\r\n{\r\nint cpu = smp_processor_id();\r\nstruct pkg_device *pkgdev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pkg_temp_lock, flags);\r\n++pkg_interrupt_cnt;\r\ndisable_pkg_thres_interrupt();\r\npkgdev = pkg_temp_thermal_get_dev(cpu);\r\nif (pkgdev && !pkgdev->work_scheduled) {\r\npkgdev->work_scheduled = true;\r\npkg_thermal_schedule_work(pkgdev->cpu, &pkgdev->work);\r\n}\r\nspin_unlock_irqrestore(&pkg_temp_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pkg_temp_thermal_device_add(unsigned int cpu)\r\n{\r\nint pkgid = topology_logical_package_id(cpu);\r\nu32 tj_max, eax, ebx, ecx, edx;\r\nstruct pkg_device *pkgdev;\r\nint thres_count, err;\r\nif (pkgid >= max_packages)\r\nreturn -ENOMEM;\r\ncpuid(6, &eax, &ebx, &ecx, &edx);\r\nthres_count = ebx & 0x07;\r\nif (!thres_count)\r\nreturn -ENODEV;\r\nthres_count = clamp_val(thres_count, 0, MAX_NUMBER_OF_TRIPS);\r\nerr = get_tj_max(cpu, &tj_max);\r\nif (err)\r\nreturn err;\r\npkgdev = kzalloc(sizeof(*pkgdev), GFP_KERNEL);\r\nif (!pkgdev)\r\nreturn -ENOMEM;\r\nINIT_DELAYED_WORK(&pkgdev->work, pkg_temp_thermal_threshold_work_fn);\r\npkgdev->cpu = cpu;\r\npkgdev->tj_max = tj_max;\r\npkgdev->tzone = thermal_zone_device_register("x86_pkg_temp",\r\nthres_count,\r\n(thres_count == MAX_NUMBER_OF_TRIPS) ? 0x03 : 0x01,\r\npkgdev, &tzone_ops, &pkg_temp_tz_params, 0, 0);\r\nif (IS_ERR(pkgdev->tzone)) {\r\nerr = PTR_ERR(pkgdev->tzone);\r\nkfree(pkgdev);\r\nreturn err;\r\n}\r\nrdmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT, pkgdev->msr_pkg_therm_low,\r\npkgdev->msr_pkg_therm_high);\r\ncpumask_set_cpu(cpu, &pkgdev->cpumask);\r\nspin_lock_irq(&pkg_temp_lock);\r\npackages[pkgid] = pkgdev;\r\nspin_unlock_irq(&pkg_temp_lock);\r\nreturn 0;\r\n}\r\nstatic int pkg_thermal_cpu_offline(unsigned int cpu)\r\n{\r\nstruct pkg_device *pkgdev = pkg_temp_thermal_get_dev(cpu);\r\nbool lastcpu, was_target;\r\nint target;\r\nif (!pkgdev)\r\nreturn 0;\r\ntarget = cpumask_any_but(&pkgdev->cpumask, cpu);\r\ncpumask_clear_cpu(cpu, &pkgdev->cpumask);\r\nlastcpu = target >= nr_cpu_ids;\r\nif (lastcpu) {\r\nstruct thermal_zone_device *tzone = pkgdev->tzone;\r\nmutex_lock(&thermal_zone_mutex);\r\npkgdev->tzone = NULL;\r\nmutex_unlock(&thermal_zone_mutex);\r\nthermal_zone_device_unregister(tzone);\r\n}\r\nspin_lock_irq(&pkg_temp_lock);\r\nwas_target = pkgdev->cpu == cpu;\r\npkgdev->cpu = target;\r\nif (lastcpu) {\r\npackages[topology_logical_package_id(cpu)] = NULL;\r\nwrmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT,\r\npkgdev->msr_pkg_therm_low, pkgdev->msr_pkg_therm_high);\r\n}\r\nif (pkgdev->work_scheduled && was_target) {\r\nspin_unlock_irq(&pkg_temp_lock);\r\ncancel_delayed_work_sync(&pkgdev->work);\r\nspin_lock_irq(&pkg_temp_lock);\r\nif (!lastcpu && pkgdev->work_scheduled)\r\npkg_thermal_schedule_work(target, &pkgdev->work);\r\n}\r\nspin_unlock_irq(&pkg_temp_lock);\r\nif (lastcpu)\r\nkfree(pkgdev);\r\nreturn 0;\r\n}\r\nstatic int pkg_thermal_cpu_online(unsigned int cpu)\r\n{\r\nstruct pkg_device *pkgdev = pkg_temp_thermal_get_dev(cpu);\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nif (!cpu_has(c, X86_FEATURE_DTHERM) || !cpu_has(c, X86_FEATURE_PTS))\r\nreturn -ENODEV;\r\nif (pkgdev) {\r\ncpumask_set_cpu(cpu, &pkgdev->cpumask);\r\nreturn 0;\r\n}\r\nreturn pkg_temp_thermal_device_add(cpu);\r\n}\r\nstatic int __init pkg_temp_thermal_init(void)\r\n{\r\nint ret;\r\nif (!x86_match_cpu(pkg_temp_thermal_ids))\r\nreturn -ENODEV;\r\nmax_packages = topology_max_packages();\r\npackages = kzalloc(max_packages * sizeof(struct pkg_device *), GFP_KERNEL);\r\nif (!packages)\r\nreturn -ENOMEM;\r\nret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "thermal/x86_pkg:online",\r\npkg_thermal_cpu_online, pkg_thermal_cpu_offline);\r\nif (ret < 0)\r\ngoto err;\r\npkg_thermal_hp_state = ret;\r\nplatform_thermal_package_notify = pkg_thermal_notify;\r\nplatform_thermal_package_rate_control = pkg_thermal_rate_control;\r\npkg_temp_debugfs_init();\r\nreturn 0;\r\nerr:\r\nkfree(packages);\r\nreturn ret;\r\n}\r\nstatic void __exit pkg_temp_thermal_exit(void)\r\n{\r\nplatform_thermal_package_notify = NULL;\r\nplatform_thermal_package_rate_control = NULL;\r\ncpuhp_remove_state(pkg_thermal_hp_state);\r\ndebugfs_remove_recursive(debugfs);\r\nkfree(packages);\r\n}
