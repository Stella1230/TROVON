static inline struct cros_ec_pwm_device *pwm_to_cros_ec_pwm(struct pwm_chip *c)\r\n{\r\nreturn container_of(c, struct cros_ec_pwm_device, chip);\r\n}\r\nstatic int cros_ec_pwm_set_duty(struct cros_ec_device *ec, u8 index, u16 duty)\r\n{\r\nstruct {\r\nstruct cros_ec_command msg;\r\nstruct ec_params_pwm_set_duty params;\r\n} __packed buf;\r\nstruct ec_params_pwm_set_duty *params = &buf.params;\r\nstruct cros_ec_command *msg = &buf.msg;\r\nmemset(&buf, 0, sizeof(buf));\r\nmsg->version = 0;\r\nmsg->command = EC_CMD_PWM_SET_DUTY;\r\nmsg->insize = 0;\r\nmsg->outsize = sizeof(*params);\r\nparams->duty = duty;\r\nparams->pwm_type = EC_PWM_TYPE_GENERIC;\r\nparams->index = index;\r\nreturn cros_ec_cmd_xfer_status(ec, msg);\r\n}\r\nstatic int __cros_ec_pwm_get_duty(struct cros_ec_device *ec, u8 index,\r\nu32 *result)\r\n{\r\nstruct {\r\nstruct cros_ec_command msg;\r\nunion {\r\nstruct ec_params_pwm_get_duty params;\r\nstruct ec_response_pwm_get_duty resp;\r\n};\r\n} __packed buf;\r\nstruct ec_params_pwm_get_duty *params = &buf.params;\r\nstruct ec_response_pwm_get_duty *resp = &buf.resp;\r\nstruct cros_ec_command *msg = &buf.msg;\r\nint ret;\r\nmemset(&buf, 0, sizeof(buf));\r\nmsg->version = 0;\r\nmsg->command = EC_CMD_PWM_GET_DUTY;\r\nmsg->insize = sizeof(*resp);\r\nmsg->outsize = sizeof(*params);\r\nparams->pwm_type = EC_PWM_TYPE_GENERIC;\r\nparams->index = index;\r\nret = cros_ec_cmd_xfer_status(ec, msg);\r\nif (result)\r\n*result = msg->result;\r\nif (ret < 0)\r\nreturn ret;\r\nreturn resp->duty;\r\n}\r\nstatic int cros_ec_pwm_get_duty(struct cros_ec_device *ec, u8 index)\r\n{\r\nreturn __cros_ec_pwm_get_duty(ec, index, NULL);\r\n}\r\nstatic int cros_ec_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct cros_ec_pwm_device *ec_pwm = pwm_to_cros_ec_pwm(chip);\r\nint duty_cycle;\r\nif (state->period != EC_PWM_MAX_DUTY)\r\nreturn -EINVAL;\r\nduty_cycle = state->enabled ? state->duty_cycle : 0;\r\nreturn cros_ec_pwm_set_duty(ec_pwm->ec, pwm->hwpwm, duty_cycle);\r\n}\r\nstatic void cros_ec_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct cros_ec_pwm_device *ec_pwm = pwm_to_cros_ec_pwm(chip);\r\nint ret;\r\nret = cros_ec_pwm_get_duty(ec_pwm->ec, pwm->hwpwm);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "error getting initial duty: %d\n", ret);\r\nreturn;\r\n}\r\nstate->enabled = (ret > 0);\r\nstate->period = EC_PWM_MAX_DUTY;\r\nstate->duty_cycle = ret;\r\n}\r\nstatic struct pwm_device *\r\ncros_ec_pwm_xlate(struct pwm_chip *pc, const struct of_phandle_args *args)\r\n{\r\nstruct pwm_device *pwm;\r\nif (args->args[0] >= pc->npwm)\r\nreturn ERR_PTR(-EINVAL);\r\npwm = pwm_request_from_chip(pc, args->args[0], NULL);\r\nif (IS_ERR(pwm))\r\nreturn pwm;\r\npwm->args.period = EC_PWM_MAX_DUTY;\r\nreturn pwm;\r\n}\r\nstatic int cros_ec_num_pwms(struct cros_ec_device *ec)\r\n{\r\nint i, ret;\r\nfor (i = 0; i <= U8_MAX; i++) {\r\nu32 result = 0;\r\nret = __cros_ec_pwm_get_duty(ec, i, &result);\r\nif (ret < 0 && !(ret == -EPROTO && result))\r\nreturn ret;\r\nif (result == EC_RES_INVALID_COMMAND)\r\nreturn -ENODEV;\r\nelse if (result == EC_RES_INVALID_PARAM)\r\nreturn i;\r\nelse if (result)\r\nreturn -EPROTO;\r\n}\r\nreturn U8_MAX;\r\n}\r\nstatic int cros_ec_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct cros_ec_device *ec = dev_get_drvdata(pdev->dev.parent);\r\nstruct device *dev = &pdev->dev;\r\nstruct cros_ec_pwm_device *ec_pwm;\r\nstruct pwm_chip *chip;\r\nint ret;\r\nif (!ec) {\r\ndev_err(dev, "no parent EC device\n");\r\nreturn -EINVAL;\r\n}\r\nec_pwm = devm_kzalloc(dev, sizeof(*ec_pwm), GFP_KERNEL);\r\nif (!ec_pwm)\r\nreturn -ENOMEM;\r\nchip = &ec_pwm->chip;\r\nec_pwm->ec = ec;\r\nchip->dev = dev;\r\nchip->ops = &cros_ec_pwm_ops;\r\nchip->of_xlate = cros_ec_pwm_xlate;\r\nchip->of_pwm_n_cells = 1;\r\nchip->base = -1;\r\nret = cros_ec_num_pwms(ec);\r\nif (ret < 0) {\r\ndev_err(dev, "Couldn't find PWMs: %d\n", ret);\r\nreturn ret;\r\n}\r\nchip->npwm = ret;\r\ndev_dbg(dev, "Probed %u PWMs\n", chip->npwm);\r\nret = pwmchip_add(chip);\r\nif (ret < 0) {\r\ndev_err(dev, "cannot register PWM: %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, ec_pwm);\r\nreturn ret;\r\n}\r\nstatic int cros_ec_pwm_remove(struct platform_device *dev)\r\n{\r\nstruct cros_ec_pwm_device *ec_pwm = platform_get_drvdata(dev);\r\nstruct pwm_chip *chip = &ec_pwm->chip;\r\nreturn pwmchip_remove(chip);\r\n}
