static struct max31790_data *max31790_update_device(struct device *dev)\r\n{\r\nstruct max31790_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nstruct max31790_data *ret = data;\r\nint i;\r\nint rv;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\nrv = i2c_smbus_read_byte_data(client,\r\nMAX31790_REG_FAN_FAULT_STATUS1);\r\nif (rv < 0)\r\ngoto abort;\r\ndata->fault_status = rv & 0x3F;\r\nrv = i2c_smbus_read_byte_data(client,\r\nMAX31790_REG_FAN_FAULT_STATUS2);\r\nif (rv < 0)\r\ngoto abort;\r\ndata->fault_status |= (rv & 0x3F) << 6;\r\nfor (i = 0; i < NR_CHANNEL; i++) {\r\nrv = i2c_smbus_read_word_swapped(client,\r\nMAX31790_REG_TACH_COUNT(i));\r\nif (rv < 0)\r\ngoto abort;\r\ndata->tach[i] = rv;\r\nif (data->fan_config[i]\r\n& MAX31790_FAN_CFG_TACH_INPUT) {\r\nrv = i2c_smbus_read_word_swapped(client,\r\nMAX31790_REG_TACH_COUNT(NR_CHANNEL\r\n+ i));\r\nif (rv < 0)\r\ngoto abort;\r\ndata->tach[NR_CHANNEL + i] = rv;\r\n} else {\r\nrv = i2c_smbus_read_word_swapped(client,\r\nMAX31790_REG_PWMOUT(i));\r\nif (rv < 0)\r\ngoto abort;\r\ndata->pwm[i] = rv;\r\nrv = i2c_smbus_read_word_swapped(client,\r\nMAX31790_REG_TARGET_COUNT(i));\r\nif (rv < 0)\r\ngoto abort;\r\ndata->target_count[i] = rv;\r\n}\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = true;\r\n}\r\ngoto done;\r\nabort:\r\ndata->valid = false;\r\nret = ERR_PTR(rv);\r\ndone:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic u8 get_tach_period(u8 fan_dynamics)\r\n{\r\nreturn tach_period[SR_FROM_REG(fan_dynamics)];\r\n}\r\nstatic u8 bits_for_tach_period(int rpm)\r\n{\r\nu8 bits;\r\nif (rpm < 500)\r\nbits = 0x0;\r\nelse if (rpm < 1000)\r\nbits = 0x1;\r\nelse if (rpm < 2000)\r\nbits = 0x2;\r\nelse if (rpm < 4000)\r\nbits = 0x3;\r\nelse if (rpm < 8000)\r\nbits = 0x4;\r\nelse\r\nbits = 0x5;\r\nreturn bits;\r\n}\r\nstatic int max31790_read_fan(struct device *dev, u32 attr, int channel,\r\nlong *val)\r\n{\r\nstruct max31790_data *data = max31790_update_device(dev);\r\nint sr, rpm;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nswitch (attr) {\r\ncase hwmon_fan_input:\r\nsr = get_tach_period(data->fan_dynamics[channel]);\r\nrpm = RPM_FROM_REG(data->tach[channel], sr);\r\n*val = rpm;\r\nreturn 0;\r\ncase hwmon_fan_target:\r\nsr = get_tach_period(data->fan_dynamics[channel]);\r\nrpm = RPM_FROM_REG(data->target_count[channel], sr);\r\n*val = rpm;\r\nreturn 0;\r\ncase hwmon_fan_fault:\r\n*val = !!(data->fault_status & (1 << channel));\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int max31790_write_fan(struct device *dev, u32 attr, int channel,\r\nlong val)\r\n{\r\nstruct max31790_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint target_count;\r\nint err = 0;\r\nu8 bits;\r\nint sr;\r\nmutex_lock(&data->update_lock);\r\nswitch (attr) {\r\ncase hwmon_fan_target:\r\nval = clamp_val(val, FAN_RPM_MIN, FAN_RPM_MAX);\r\nbits = bits_for_tach_period(val);\r\ndata->fan_dynamics[channel] =\r\n((data->fan_dynamics[channel] &\r\n~MAX31790_FAN_DYN_SR_MASK) |\r\n(bits << MAX31790_FAN_DYN_SR_SHIFT));\r\nerr = i2c_smbus_write_byte_data(client,\r\nMAX31790_REG_FAN_DYNAMICS(channel),\r\ndata->fan_dynamics[channel]);\r\nif (err < 0)\r\nbreak;\r\nsr = get_tach_period(data->fan_dynamics[channel]);\r\ntarget_count = RPM_TO_REG(val, sr);\r\ntarget_count = clamp_val(target_count, 0x1, 0x7FF);\r\ndata->target_count[channel] = target_count << 5;\r\nerr = i2c_smbus_write_word_swapped(client,\r\nMAX31790_REG_TARGET_COUNT(channel),\r\ndata->target_count[channel]);\r\nbreak;\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn err;\r\n}\r\nstatic umode_t max31790_fan_is_visible(const void *_data, u32 attr, int channel)\r\n{\r\nconst struct max31790_data *data = _data;\r\nu8 fan_config = data->fan_config[channel % NR_CHANNEL];\r\nswitch (attr) {\r\ncase hwmon_fan_input:\r\ncase hwmon_fan_fault:\r\nif (channel < NR_CHANNEL ||\r\n(fan_config & MAX31790_FAN_CFG_TACH_INPUT))\r\nreturn S_IRUGO;\r\nreturn 0;\r\ncase hwmon_fan_target:\r\nif (channel < NR_CHANNEL &&\r\n!(fan_config & MAX31790_FAN_CFG_TACH_INPUT))\r\nreturn S_IRUGO | S_IWUSR;\r\nreturn 0;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int max31790_read_pwm(struct device *dev, u32 attr, int channel,\r\nlong *val)\r\n{\r\nstruct max31790_data *data = max31790_update_device(dev);\r\nu8 fan_config;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nfan_config = data->fan_config[channel];\r\nswitch (attr) {\r\ncase hwmon_pwm_input:\r\n*val = data->pwm[channel] >> 8;\r\nreturn 0;\r\ncase hwmon_pwm_enable:\r\nif (fan_config & MAX31790_FAN_CFG_RPM_MODE)\r\n*val = 2;\r\nelse if (fan_config & MAX31790_FAN_CFG_TACH_INPUT_EN)\r\n*val = 1;\r\nelse\r\n*val = 0;\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int max31790_write_pwm(struct device *dev, u32 attr, int channel,\r\nlong val)\r\n{\r\nstruct max31790_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nu8 fan_config;\r\nint err = 0;\r\nmutex_lock(&data->update_lock);\r\nswitch (attr) {\r\ncase hwmon_pwm_input:\r\nif (val < 0 || val > 255) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\ndata->pwm[channel] = val << 8;\r\nerr = i2c_smbus_write_word_swapped(client,\r\nMAX31790_REG_PWMOUT(channel),\r\ndata->pwm[channel]);\r\nbreak;\r\ncase hwmon_pwm_enable:\r\nfan_config = data->fan_config[channel];\r\nif (val == 0) {\r\nfan_config &= ~(MAX31790_FAN_CFG_TACH_INPUT_EN |\r\nMAX31790_FAN_CFG_RPM_MODE);\r\n} else if (val == 1) {\r\nfan_config = (fan_config |\r\nMAX31790_FAN_CFG_TACH_INPUT_EN) &\r\n~MAX31790_FAN_CFG_RPM_MODE;\r\n} else if (val == 2) {\r\nfan_config |= MAX31790_FAN_CFG_TACH_INPUT_EN |\r\nMAX31790_FAN_CFG_RPM_MODE;\r\n} else {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\ndata->fan_config[channel] = fan_config;\r\nerr = i2c_smbus_write_byte_data(client,\r\nMAX31790_REG_FAN_CONFIG(channel),\r\nfan_config);\r\nbreak;\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn err;\r\n}\r\nstatic umode_t max31790_pwm_is_visible(const void *_data, u32 attr, int channel)\r\n{\r\nconst struct max31790_data *data = _data;\r\nu8 fan_config = data->fan_config[channel];\r\nswitch (attr) {\r\ncase hwmon_pwm_input:\r\ncase hwmon_pwm_enable:\r\nif (!(fan_config & MAX31790_FAN_CFG_TACH_INPUT))\r\nreturn S_IRUGO | S_IWUSR;\r\nreturn 0;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int max31790_read(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long *val)\r\n{\r\nswitch (type) {\r\ncase hwmon_fan:\r\nreturn max31790_read_fan(dev, attr, channel, val);\r\ncase hwmon_pwm:\r\nreturn max31790_read_pwm(dev, attr, channel, val);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int max31790_write(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long val)\r\n{\r\nswitch (type) {\r\ncase hwmon_fan:\r\nreturn max31790_write_fan(dev, attr, channel, val);\r\ncase hwmon_pwm:\r\nreturn max31790_write_pwm(dev, attr, channel, val);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic umode_t max31790_is_visible(const void *data,\r\nenum hwmon_sensor_types type,\r\nu32 attr, int channel)\r\n{\r\nswitch (type) {\r\ncase hwmon_fan:\r\nreturn max31790_fan_is_visible(data, attr, channel);\r\ncase hwmon_pwm:\r\nreturn max31790_pwm_is_visible(data, attr, channel);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int max31790_init_client(struct i2c_client *client,\r\nstruct max31790_data *data)\r\n{\r\nint i, rv;\r\nfor (i = 0; i < NR_CHANNEL; i++) {\r\nrv = i2c_smbus_read_byte_data(client,\r\nMAX31790_REG_FAN_CONFIG(i));\r\nif (rv < 0)\r\nreturn rv;\r\ndata->fan_config[i] = rv;\r\nrv = i2c_smbus_read_byte_data(client,\r\nMAX31790_REG_FAN_DYNAMICS(i));\r\nif (rv < 0)\r\nreturn rv;\r\ndata->fan_dynamics[i] = rv;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max31790_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct device *dev = &client->dev;\r\nstruct max31790_data *data;\r\nstruct device *hwmon_dev;\r\nint err;\r\nif (!i2c_check_functionality(adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(dev, sizeof(struct max31790_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->client = client;\r\nmutex_init(&data->update_lock);\r\nerr = max31790_init_client(client, data);\r\nif (err)\r\nreturn err;\r\nhwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\r\ndata,\r\n&max31790_chip_info,\r\nNULL);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
