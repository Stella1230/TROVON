static unsigned int pci230_clk_config(unsigned int chan, unsigned int src)\r\n{\r\nreturn ((chan & 3) << 3) | (src & 7);\r\n}\r\nstatic unsigned int pci230_gat_config(unsigned int chan, unsigned int src)\r\n{\r\nreturn ((chan & 3) << 3) | (src & 7);\r\n}\r\nstatic unsigned short pci230_ai_read(struct comedi_device *dev)\r\n{\r\nconst struct pci230_board *board = dev->board_ptr;\r\nstruct pci230_private *devpriv = dev->private;\r\nunsigned short data;\r\ndata = inw(devpriv->daqio + PCI230_ADCDATA);\r\nif (devpriv->ai_bipolar)\r\ndata ^= 0x8000;\r\ndata >>= (16 - board->ai_bits);\r\nreturn data;\r\n}\r\nstatic unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,\r\nunsigned short datum)\r\n{\r\nconst struct pci230_board *board = dev->board_ptr;\r\nstruct pci230_private *devpriv = dev->private;\r\ndatum <<= (16 - board->ao_bits);\r\nif (devpriv->ao_bipolar)\r\ndatum ^= 0x8000;\r\nreturn datum;\r\n}\r\nstatic void pci230_ao_write_nofifo(struct comedi_device *dev,\r\nunsigned short datum, unsigned int chan)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\noutw(pci230_ao_mangle_datum(dev, datum),\r\ndevpriv->daqio + ((chan == 0) ? PCI230_DACOUT1 : PCI230_DACOUT2));\r\n}\r\nstatic void pci230_ao_write_fifo(struct comedi_device *dev,\r\nunsigned short datum, unsigned int chan)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\noutw(pci230_ao_mangle_datum(dev, datum),\r\ndevpriv->daqio + PCI230P2_DACDATA);\r\n}\r\nstatic bool pci230_claim_shared(struct comedi_device *dev,\r\nunsigned char res_mask, unsigned int owner)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nunsigned int o;\r\nunsigned long irqflags;\r\nspin_lock_irqsave(&devpriv->res_spinlock, irqflags);\r\nfor (o = 0; o < NUM_OWNERS; o++) {\r\nif (o == owner)\r\ncontinue;\r\nif (devpriv->res_owned[o] & res_mask) {\r\nspin_unlock_irqrestore(&devpriv->res_spinlock,\r\nirqflags);\r\nreturn false;\r\n}\r\n}\r\ndevpriv->res_owned[owner] |= res_mask;\r\nspin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);\r\nreturn true;\r\n}\r\nstatic void pci230_release_shared(struct comedi_device *dev,\r\nunsigned char res_mask, unsigned int owner)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nunsigned long irqflags;\r\nspin_lock_irqsave(&devpriv->res_spinlock, irqflags);\r\ndevpriv->res_owned[owner] &= ~res_mask;\r\nspin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);\r\n}\r\nstatic void pci230_release_all_resources(struct comedi_device *dev,\r\nunsigned int owner)\r\n{\r\npci230_release_shared(dev, (unsigned char)~0, owner);\r\n}\r\nstatic unsigned int pci230_divide_ns(u64 ns, unsigned int timebase,\r\nunsigned int flags)\r\n{\r\nu64 div;\r\nunsigned int rem;\r\ndiv = ns;\r\nrem = do_div(div, timebase);\r\nswitch (flags & CMDF_ROUND_MASK) {\r\ndefault:\r\ncase CMDF_ROUND_NEAREST:\r\ndiv += DIV_ROUND_CLOSEST(rem, timebase);\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\nbreak;\r\ncase CMDF_ROUND_UP:\r\ndiv += DIV_ROUND_UP(rem, timebase);\r\nbreak;\r\n}\r\nreturn div > UINT_MAX ? UINT_MAX : (unsigned int)div;\r\n}\r\nstatic unsigned int pci230_choose_clk_count(u64 ns, unsigned int *count,\r\nunsigned int flags)\r\n{\r\nunsigned int clk_src, cnt;\r\nfor (clk_src = CLK_10MHZ;; clk_src++) {\r\ncnt = pci230_divide_ns(ns, pci230_timebase[clk_src], flags);\r\nif (cnt <= 65536 || clk_src == CLK_1KHZ)\r\nbreak;\r\n}\r\n*count = cnt;\r\nreturn clk_src;\r\n}\r\nstatic void pci230_ns_to_single_timer(unsigned int *ns, unsigned int flags)\r\n{\r\nunsigned int count;\r\nunsigned int clk_src;\r\nclk_src = pci230_choose_clk_count(*ns, &count, flags);\r\n*ns = count * pci230_timebase[clk_src];\r\n}\r\nstatic void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,\r\nunsigned int mode, u64 ns,\r\nunsigned int flags)\r\n{\r\nunsigned int clk_src;\r\nunsigned int count;\r\ncomedi_8254_set_mode(dev->pacer, ct, mode);\r\nclk_src = pci230_choose_clk_count(ns, &count, flags);\r\noutb(pci230_clk_config(ct, clk_src), dev->iobase + PCI230_ZCLK_SCE);\r\nif (count >= 65536)\r\ncount = 0;\r\ncomedi_8254_write(dev->pacer, ct, count);\r\n}\r\nstatic void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct)\r\n{\r\ncomedi_8254_set_mode(dev->pacer, ct, I8254_MODE1);\r\n}\r\nstatic int pci230_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nunsigned int status;\r\nstatus = inw(devpriv->daqio + PCI230_ADCCON);\r\nif ((status & PCI230_ADC_FIFO_EMPTY) == 0)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int pci230_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nunsigned int n;\r\nunsigned int chan, range, aref;\r\nunsigned int gainshift;\r\nunsigned short adccon, adcen;\r\nint ret;\r\nchan = CR_CHAN(insn->chanspec);\r\nrange = CR_RANGE(insn->chanspec);\r\naref = CR_AREF(insn->chanspec);\r\nif (aref == AREF_DIFF) {\r\nif (chan >= s->n_chan / 2) {\r\ndev_dbg(dev->class_dev,\r\n"%s: differential channel number out of range 0 to %u\n",\r\n__func__, (s->n_chan / 2) - 1);\r\nreturn -EINVAL;\r\n}\r\n}\r\nadccon = PCI230_ADC_TRIG_Z2CT2 | PCI230_ADC_FIFO_EN;\r\ncomedi_8254_set_mode(dev->pacer, 2, I8254_MODE0);\r\ndevpriv->ai_bipolar = comedi_range_is_bipolar(s, range);\r\nif (aref == AREF_DIFF) {\r\ngainshift = chan * 2;\r\nif (devpriv->hwver == 0) {\r\nadcen = 3 << gainshift;\r\n} else {\r\nadcen = 1 << gainshift;\r\n}\r\nadccon |= PCI230_ADC_IM_DIF;\r\n} else {\r\nadcen = 1 << chan;\r\ngainshift = chan & ~1;\r\nadccon |= PCI230_ADC_IM_SE;\r\n}\r\ndevpriv->adcg = (devpriv->adcg & ~(3 << gainshift)) |\r\n(pci230_ai_gain[range] << gainshift);\r\nif (devpriv->ai_bipolar)\r\nadccon |= PCI230_ADC_IR_BIP;\r\nelse\r\nadccon |= PCI230_ADC_IR_UNI;\r\noutw(adcen, devpriv->daqio + PCI230_ADCEN);\r\noutw(devpriv->adcg, devpriv->daqio + PCI230_ADCG);\r\ndevpriv->adccon = adccon;\r\noutw(adccon | PCI230_ADC_FIFO_RESET, devpriv->daqio + PCI230_ADCCON);\r\nfor (n = 0; n < insn->n; n++) {\r\ncomedi_8254_set_mode(dev->pacer, 2, I8254_MODE0);\r\ncomedi_8254_set_mode(dev->pacer, 2, I8254_MODE1);\r\nret = comedi_timeout(dev, s, insn, pci230_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\ndata[n] = pci230_ai_read(dev);\r\n}\r\nreturn n;\r\n}\r\nstatic int pci230_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int val = s->readback[chan];\r\nint i;\r\ndevpriv->ao_bipolar = comedi_range_is_bipolar(s, range);\r\noutw(range, devpriv->daqio + PCI230_DACCON);\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\npci230_ao_write_nofifo(dev, val, chan);\r\n}\r\ns->readback[chan] = val;\r\nreturn insn->n;\r\n}\r\nstatic int pci230_ao_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int prev_chan = CR_CHAN(cmd->chanlist[0]);\r\nunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\r\nint i;\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned int range = CR_RANGE(cmd->chanlist[i]);\r\nif (chan < prev_chan) {\r\ndev_dbg(dev->class_dev,\r\n"%s: channel numbers must increase\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (range != range0) {\r\ndev_dbg(dev->class_dev,\r\n"%s: channels must have the same range\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nprev_chan = chan;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci230_ao_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nconst struct pci230_board *board = dev->board_ptr;\r\nstruct pci230_private *devpriv = dev->private;\r\nint err = 0;\r\nunsigned int tmp;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);\r\ntmp = TRIG_TIMER | TRIG_INT;\r\nif (board->min_hwver > 0 && devpriv->hwver >= 2) {\r\ntmp |= TRIG_EXT;\r\n}\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, tmp);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\n#define MAX_SPEED_AO 8000\r\n#define MIN_SPEED_AO 4294967295u\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nMAX_SPEED_AO);\r\nerr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,\r\nMIN_SPEED_AO);\r\nbreak;\r\ncase TRIG_EXT:\r\nif (cmd->scan_begin_arg & ~CR_FLAGS_MASK) {\r\ncmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,\r\n~CR_FLAGS_MASK);\r\nerr |= -EINVAL;\r\n}\r\nif (cmd->scan_begin_arg & CR_FLAGS_MASK &\r\n~(CR_EDGE | CR_INVERT)) {\r\ncmd->scan_begin_arg =\r\nCOMBINE(cmd->scan_begin_arg, 0,\r\nCR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));\r\nerr |= -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nbreak;\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\npci230_ns_to_single_timer(&cmd->scan_begin_arg, cmd->flags);\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= pci230_ao_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic void pci230_ao_stop(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nunsigned long irqflags;\r\nunsigned char intsrc;\r\nbool started;\r\nstruct comedi_cmd *cmd;\r\nspin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);\r\nstarted = devpriv->ao_cmd_started;\r\ndevpriv->ao_cmd_started = false;\r\nspin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);\r\nif (!started)\r\nreturn;\r\ncmd = &s->async->cmd;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\npci230_cancel_ct(dev, 1);\r\n}\r\nif (devpriv->hwver < 2) {\r\nintsrc = PCI230_INT_ZCLK_CT1;\r\n} else {\r\nintsrc = PCI230P2_INT_DAC;\r\n}\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\ndevpriv->ier &= ~intsrc;\r\nwhile (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\n}\r\noutb(devpriv->ier, dev->iobase + PCI230_INT_SCE);\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\r\nif (devpriv->hwver >= 2) {\r\ndevpriv->daccon &= PCI230_DAC_OR_MASK;\r\noutw(devpriv->daccon | PCI230P2_DAC_FIFO_RESET |\r\nPCI230P2_DAC_FIFO_UNDERRUN_CLEAR,\r\ndevpriv->daqio + PCI230_DACCON);\r\n}\r\npci230_release_all_resources(dev, OWNER_AOCMD);\r\n}\r\nstatic void pci230_handle_ao_nofifo(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned short data;\r\nint i;\r\nif (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg)\r\nreturn;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nif (!comedi_buf_read_samples(s, &data, 1)) {\r\nasync->events |= COMEDI_CB_OVERFLOW;\r\nreturn;\r\n}\r\npci230_ao_write_nofifo(dev, data, chan);\r\ns->readback[chan] = data;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg)\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\nstatic bool pci230_handle_ao_fifo(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int num_scans = comedi_nscans_left(s, 0);\r\nunsigned int room;\r\nunsigned short dacstat;\r\nunsigned int i, n;\r\nunsigned int events = 0;\r\ndacstat = inw(devpriv->daqio + PCI230_DACCON);\r\nif (cmd->stop_src == TRIG_COUNT && num_scans == 0)\r\nevents |= COMEDI_CB_EOA;\r\nif (events == 0) {\r\nif (dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) {\r\ndev_err(dev->class_dev, "AO FIFO underrun\n");\r\nevents |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;\r\n}\r\nif (num_scans == 0 &&\r\n(dacstat & PCI230P2_DAC_FIFO_HALF) == 0) {\r\ndev_err(dev->class_dev, "AO buffer underrun\n");\r\nevents |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;\r\n}\r\n}\r\nif (events == 0) {\r\nif (dacstat & PCI230P2_DAC_FIFO_FULL)\r\nroom = PCI230P2_DAC_FIFOROOM_FULL;\r\nelse if (dacstat & PCI230P2_DAC_FIFO_HALF)\r\nroom = PCI230P2_DAC_FIFOROOM_HALFTOFULL;\r\nelse if (dacstat & PCI230P2_DAC_FIFO_EMPTY)\r\nroom = PCI230P2_DAC_FIFOROOM_EMPTY;\r\nelse\r\nroom = PCI230P2_DAC_FIFOROOM_ONETOHALF;\r\nroom /= cmd->chanlist_len;\r\nif (num_scans > room)\r\nnum_scans = room;\r\nfor (n = 0; n < num_scans; n++) {\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned short datum;\r\ncomedi_buf_read_samples(s, &datum, 1);\r\npci230_ao_write_fifo(dev, datum, chan);\r\ns->readback[chan] = datum;\r\n}\r\n}\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg) {\r\ndevpriv->daccon &= ~PCI230P2_DAC_INT_FIFO_MASK;\r\ndevpriv->daccon |= PCI230P2_DAC_INT_FIFO_EMPTY;\r\noutw(devpriv->daccon, devpriv->daqio + PCI230_DACCON);\r\n}\r\ndacstat = inw(devpriv->daqio + PCI230_DACCON);\r\nif (dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) {\r\ndev_err(dev->class_dev, "AO FIFO underrun\n");\r\nevents |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;\r\n}\r\n}\r\nasync->events |= events;\r\nreturn !(async->events & COMEDI_CB_CANCEL_MASK);\r\n}\r\nstatic int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nunsigned long irqflags;\r\nif (trig_num)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);\r\nif (!devpriv->ao_cmd_started) {\r\nspin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);\r\nreturn 1;\r\n}\r\nif (devpriv->hwver < 2) {\r\nspin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);\r\npci230_handle_ao_nofifo(dev, s);\r\ncomedi_handle_events(dev, s);\r\n} else {\r\ninw(devpriv->daqio + PCI230P2_DACSWTRIG);\r\nspin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);\r\n}\r\nudelay(8);\r\nreturn 1;\r\n}\r\nstatic void pci230_ao_start(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned long irqflags;\r\ndevpriv->ao_cmd_started = true;\r\nif (devpriv->hwver >= 2) {\r\nunsigned short scantrig;\r\nbool run;\r\nrun = pci230_handle_ao_fifo(dev, s);\r\ncomedi_handle_events(dev, s);\r\nif (!run) {\r\nreturn;\r\n}\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\nscantrig = PCI230P2_DAC_TRIG_Z2CT1;\r\nbreak;\r\ncase TRIG_EXT:\r\nif ((cmd->scan_begin_arg & CR_INVERT) == 0) {\r\nscantrig = PCI230P2_DAC_TRIG_EXTP;\r\n} else {\r\nscantrig = PCI230P2_DAC_TRIG_EXTN;\r\n}\r\nbreak;\r\ncase TRIG_INT:\r\nscantrig = PCI230P2_DAC_TRIG_SW;\r\nbreak;\r\ndefault:\r\nscantrig = PCI230P2_DAC_TRIG_NONE;\r\nbreak;\r\n}\r\ndevpriv->daccon =\r\n(devpriv->daccon & ~PCI230P2_DAC_TRIG_MASK) | scantrig;\r\noutw(devpriv->daccon, devpriv->daqio + PCI230_DACCON);\r\n}\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\nif (devpriv->hwver < 2) {\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\ndevpriv->ier |= PCI230_INT_ZCLK_CT1;\r\noutb(devpriv->ier, dev->iobase + PCI230_INT_SCE);\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock,\r\nirqflags);\r\n}\r\noutb(pci230_gat_config(1, GAT_VCC),\r\ndev->iobase + PCI230_ZGAT_SCE);\r\nbreak;\r\ncase TRIG_INT:\r\nasync->inttrig = pci230_ao_inttrig_scan_begin;\r\nbreak;\r\n}\r\nif (devpriv->hwver >= 2) {\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\ndevpriv->ier |= PCI230P2_INT_DAC;\r\noutb(devpriv->ier, dev->iobase + PCI230_INT_SCE);\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\r\n}\r\n}\r\nstatic int pci230_ao_inttrig_start(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (trig_num != cmd->start_src)\r\nreturn -EINVAL;\r\ns->async->inttrig = NULL;\r\npci230_ao_start(dev, s);\r\nreturn 1;\r\n}\r\nstatic int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nunsigned short daccon;\r\nunsigned int range;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (!pci230_claim_shared(dev, RES_Z2CT1, OWNER_AOCMD))\r\nreturn -EBUSY;\r\n}\r\nrange = CR_RANGE(cmd->chanlist[0]);\r\ndevpriv->ao_bipolar = comedi_range_is_bipolar(s, range);\r\ndaccon = devpriv->ao_bipolar ? PCI230_DAC_OR_BIP : PCI230_DAC_OR_UNI;\r\nif (devpriv->hwver >= 2) {\r\nunsigned short dacen;\r\nunsigned int i;\r\ndacen = 0;\r\nfor (i = 0; i < cmd->chanlist_len; i++)\r\ndacen |= 1 << CR_CHAN(cmd->chanlist[i]);\r\noutw(dacen, devpriv->daqio + PCI230P2_DACEN);\r\ndaccon |= PCI230P2_DAC_FIFO_EN | PCI230P2_DAC_FIFO_RESET |\r\nPCI230P2_DAC_FIFO_UNDERRUN_CLEAR |\r\nPCI230P2_DAC_TRIG_NONE | PCI230P2_DAC_INT_FIFO_NHALF;\r\n}\r\noutw(daccon, devpriv->daqio + PCI230_DACCON);\r\ndevpriv->daccon = daccon & ~(PCI230P2_DAC_FIFO_RESET |\r\nPCI230P2_DAC_FIFO_UNDERRUN_CLEAR);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\noutb(pci230_gat_config(1, GAT_GND),\r\ndev->iobase + PCI230_ZGAT_SCE);\r\npci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,\r\ncmd->scan_begin_arg,\r\ncmd->flags);\r\n}\r\ns->async->inttrig = pci230_ao_inttrig_start;\r\nreturn 0;\r\n}\r\nstatic int pci230_ao_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\npci230_ao_stop(dev, s);\r\nreturn 0;\r\n}\r\nstatic int pci230_ai_check_scan_period(struct comedi_cmd *cmd)\r\n{\r\nunsigned int min_scan_period, chanlist_len;\r\nint err = 0;\r\nchanlist_len = cmd->chanlist_len;\r\nif (cmd->chanlist_len == 0)\r\nchanlist_len = 1;\r\nmin_scan_period = chanlist_len * cmd->convert_arg;\r\nif (min_scan_period < chanlist_len ||\r\nmin_scan_period < cmd->convert_arg) {\r\nmin_scan_period = UINT_MAX;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_arg < min_scan_period) {\r\ncmd->scan_begin_arg = min_scan_period;\r\nerr++;\r\n}\r\nreturn !err;\r\n}\r\nstatic int pci230_ai_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nunsigned int max_diff_chan = (s->n_chan / 2) - 1;\r\nunsigned int prev_chan = 0;\r\nunsigned int prev_range = 0;\r\nunsigned int prev_aref = 0;\r\nbool prev_bipolar = false;\r\nunsigned int subseq_len = 0;\r\nint i;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int chanspec = cmd->chanlist[i];\r\nunsigned int chan = CR_CHAN(chanspec);\r\nunsigned int range = CR_RANGE(chanspec);\r\nunsigned int aref = CR_AREF(chanspec);\r\nbool bipolar = comedi_range_is_bipolar(s, range);\r\nif (aref == AREF_DIFF && chan >= max_diff_chan) {\r\ndev_dbg(dev->class_dev,\r\n"%s: differential channel number out of range 0 to %u\n",\r\n__func__, max_diff_chan);\r\nreturn -EINVAL;\r\n}\r\nif (i > 0) {\r\nif (chan <= prev_chan && subseq_len == 0)\r\nsubseq_len = i;\r\nif (subseq_len > 0 &&\r\ncmd->chanlist[i % subseq_len] != chanspec) {\r\ndev_dbg(dev->class_dev,\r\n"%s: channel numbers must increase or sequence must repeat exactly\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (aref != prev_aref) {\r\ndev_dbg(dev->class_dev,\r\n"%s: channel sequence analogue references must be all the same (single-ended or differential)\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (bipolar != prev_bipolar) {\r\ndev_dbg(dev->class_dev,\r\n"%s: channel sequence ranges must be all bipolar or all unipolar\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (aref != AREF_DIFF && range != prev_range &&\r\n((chan ^ prev_chan) & ~1) == 0) {\r\ndev_dbg(dev->class_dev,\r\n"%s: single-ended channel pairs must have the same range\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\nprev_chan = chan;\r\nprev_range = range;\r\nprev_aref = aref;\r\nprev_bipolar = bipolar;\r\n}\r\nif (subseq_len == 0)\r\nsubseq_len = cmd->chanlist_len;\r\nif (cmd->chanlist_len % subseq_len) {\r\ndev_dbg(dev->class_dev,\r\n"%s: sequence must repeat exactly\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (devpriv->hwver > 0 && devpriv->hwver < 4) {\r\nif (subseq_len > 1 && CR_CHAN(cmd->chanlist[0])) {\r\ndev_info(dev->class_dev,\r\n"amplc_pci230: ai_cmdtest: Buggy PCI230+/260+ h/w version %u requires first channel of multi-channel sequence to be 0 (corrected in h/w version 4)\n",\r\ndevpriv->hwver);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci230_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nconst struct pci230_board *board = dev->board_ptr;\r\nstruct pci230_private *devpriv = dev->private;\r\nint err = 0;\r\nunsigned int tmp;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\r\ntmp = TRIG_FOLLOW | TRIG_TIMER | TRIG_INT;\r\nif (board->have_dio || board->min_hwver > 0) {\r\ntmp |= TRIG_EXT;\r\n}\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, tmp);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src,\r\nTRIG_TIMER | TRIG_INT | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->convert_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (cmd->scan_begin_src != TRIG_FOLLOW &&\r\ncmd->convert_src != TRIG_TIMER)\r\nerr |= -EINVAL;\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\n#define MAX_SPEED_AI_SE 3200\r\n#define MAX_SPEED_AI_DIFF 8000\r\n#define MAX_SPEED_AI_PLUS 4000\r\n#define MIN_SPEED_AI 4294967295u\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nunsigned int max_speed_ai;\r\nif (devpriv->hwver == 0) {\r\nif (cmd->chanlist && cmd->chanlist_len > 0) {\r\nif (CR_AREF(cmd->chanlist[0]) == AREF_DIFF)\r\nmax_speed_ai = MAX_SPEED_AI_DIFF;\r\nelse\r\nmax_speed_ai = MAX_SPEED_AI_SE;\r\n} else {\r\nmax_speed_ai = MAX_SPEED_AI_SE;\r\n}\r\n} else {\r\nmax_speed_ai = MAX_SPEED_AI_PLUS;\r\n}\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\r\nmax_speed_ai);\r\nerr |= comedi_check_trigger_arg_max(&cmd->convert_arg,\r\nMIN_SPEED_AI);\r\n} else if (cmd->convert_src == TRIG_EXT) {\r\nif (cmd->convert_arg & CR_FLAGS_MASK) {\r\nif (cmd->convert_arg & ~CR_FLAGS_MASK) {\r\ncmd->convert_arg = COMBINE(cmd->convert_arg, 0,\r\n~CR_FLAGS_MASK);\r\nerr |= -EINVAL;\r\n}\r\nif ((cmd->convert_arg & CR_FLAGS_MASK & ~CR_INVERT) !=\r\nCR_EDGE) {\r\ncmd->convert_arg =\r\nCOMBINE(cmd->start_arg, CR_EDGE | 0,\r\nCR_FLAGS_MASK & ~CR_INVERT);\r\nerr |= -EINVAL;\r\n}\r\n} else {\r\nerr |= comedi_check_trigger_arg_max(&cmd->convert_arg,\r\n1);\r\n}\r\n} else {\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_EXT) {\r\nif (cmd->scan_begin_arg & ~CR_FLAGS_MASK) {\r\ncmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,\r\n~CR_FLAGS_MASK);\r\nerr |= -EINVAL;\r\n}\r\nif (cmd->scan_begin_arg & CR_FLAGS_MASK & ~CR_EDGE) {\r\ncmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,\r\nCR_FLAGS_MASK & ~CR_EDGE);\r\nerr |= -EINVAL;\r\n}\r\n} else if (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (!pci230_ai_check_scan_period(cmd))\r\nerr |= -EINVAL;\r\n} else {\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ntmp = cmd->convert_arg;\r\npci230_ns_to_single_timer(&cmd->convert_arg, cmd->flags);\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\npci230_ns_to_single_timer(&cmd->scan_begin_arg, cmd->flags);\r\nif (!pci230_ai_check_scan_period(cmd)) {\r\npci230_ns_to_single_timer(&cmd->scan_begin_arg,\r\nCMDF_ROUND_UP);\r\npci230_ai_check_scan_period(cmd);\r\n}\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= pci230_ai_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int wake;\r\nunsigned short triglev;\r\nunsigned short adccon;\r\nif (cmd->flags & CMDF_WAKE_EOS)\r\nwake = cmd->scan_end_arg - s->async->cur_chan;\r\nelse\r\nwake = comedi_nsamples_left(s, PCI230_ADC_FIFOLEVEL_HALFFULL);\r\nif (wake >= PCI230_ADC_FIFOLEVEL_HALFFULL) {\r\ntriglev = PCI230_ADC_INT_FIFO_HALF;\r\n} else if (wake > 1 && devpriv->hwver > 0) {\r\nif (devpriv->adcfifothresh != wake) {\r\ndevpriv->adcfifothresh = wake;\r\noutw(wake, devpriv->daqio + PCI230P_ADCFFTH);\r\n}\r\ntriglev = PCI230P_ADC_INT_FIFO_THRESH;\r\n} else {\r\ntriglev = PCI230_ADC_INT_FIFO_NEMPTY;\r\n}\r\nadccon = (devpriv->adccon & ~PCI230_ADC_INT_FIFO_MASK) | triglev;\r\nif (adccon != devpriv->adccon) {\r\ndevpriv->adccon = adccon;\r\noutw(adccon, devpriv->daqio + PCI230_ADCCON);\r\n}\r\n}\r\nstatic int pci230_ai_inttrig_convert(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nunsigned long irqflags;\r\nunsigned int delayus;\r\nif (trig_num)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);\r\nif (!devpriv->ai_cmd_started) {\r\nspin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);\r\nreturn 1;\r\n}\r\ncomedi_8254_set_mode(dev->pacer, 2, I8254_MODE0);\r\ncomedi_8254_set_mode(dev->pacer, 2, I8254_MODE1);\r\nif ((devpriv->adccon & PCI230_ADC_IM_MASK) == PCI230_ADC_IM_DIF &&\r\ndevpriv->hwver == 0) {\r\ndelayus = 8;\r\n} else {\r\ndelayus = 4;\r\n}\r\nspin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);\r\nudelay(delayus);\r\nreturn 1;\r\n}\r\nstatic int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nunsigned long irqflags;\r\nunsigned char zgat;\r\nif (trig_num)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);\r\nif (devpriv->ai_cmd_started) {\r\nzgat = pci230_gat_config(0, GAT_GND);\r\noutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\r\nzgat = pci230_gat_config(0, GAT_VCC);\r\noutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\r\n}\r\nspin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);\r\nreturn 1;\r\n}\r\nstatic void pci230_ai_stop(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nunsigned long irqflags;\r\nstruct comedi_cmd *cmd;\r\nbool started;\r\nspin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);\r\nstarted = devpriv->ai_cmd_started;\r\ndevpriv->ai_cmd_started = false;\r\nspin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);\r\nif (!started)\r\nreturn;\r\ncmd = &s->async->cmd;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\npci230_cancel_ct(dev, 2);\r\n}\r\nif (cmd->scan_begin_src != TRIG_FOLLOW) {\r\npci230_cancel_ct(dev, 0);\r\n}\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\ndevpriv->ier &= ~PCI230_INT_ADC;\r\nwhile (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\n}\r\noutb(devpriv->ier, dev->iobase + PCI230_INT_SCE);\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\r\ndevpriv->adccon =\r\n(devpriv->adccon & (PCI230_ADC_IR_MASK | PCI230_ADC_IM_MASK)) |\r\nPCI230_ADC_TRIG_NONE;\r\noutw(devpriv->adccon | PCI230_ADC_FIFO_RESET,\r\ndevpriv->daqio + PCI230_ADCCON);\r\npci230_release_all_resources(dev, OWNER_AICMD);\r\n}\r\nstatic void pci230_ai_start(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nunsigned long irqflags;\r\nunsigned short conv;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\ndevpriv->ai_cmd_started = true;\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\ndevpriv->ier |= PCI230_INT_ADC;\r\noutb(devpriv->ier, dev->iobase + PCI230_INT_SCE);\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\r\nswitch (cmd->convert_src) {\r\ndefault:\r\nconv = PCI230_ADC_TRIG_NONE;\r\nbreak;\r\ncase TRIG_TIMER:\r\nconv = PCI230_ADC_TRIG_Z2CT2;\r\nbreak;\r\ncase TRIG_EXT:\r\nif (cmd->convert_arg & CR_EDGE) {\r\nif ((cmd->convert_arg & CR_INVERT) == 0) {\r\nconv = PCI230_ADC_TRIG_EXTP;\r\n} else {\r\nconv = PCI230_ADC_TRIG_EXTN;\r\n}\r\n} else {\r\nif (cmd->convert_arg) {\r\nconv = PCI230_ADC_TRIG_EXTP;\r\n} else {\r\nconv = PCI230_ADC_TRIG_EXTN;\r\n}\r\n}\r\nbreak;\r\ncase TRIG_INT:\r\nconv = PCI230_ADC_TRIG_Z2CT2;\r\nbreak;\r\n}\r\ndevpriv->adccon = (devpriv->adccon & ~PCI230_ADC_TRIG_MASK) | conv;\r\noutw(devpriv->adccon, devpriv->daqio + PCI230_ADCCON);\r\nif (cmd->convert_src == TRIG_INT)\r\nasync->inttrig = pci230_ai_inttrig_convert;\r\npci230_ai_update_fifo_trigger_level(dev, s);\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nunsigned char zgat;\r\nif (cmd->scan_begin_src != TRIG_FOLLOW) {\r\nzgat = pci230_gat_config(2, GAT_NOUTNM2);\r\n} else {\r\nzgat = pci230_gat_config(2, GAT_VCC);\r\n}\r\noutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\r\nif (cmd->scan_begin_src != TRIG_FOLLOW) {\r\nswitch (cmd->scan_begin_src) {\r\ndefault:\r\nzgat = pci230_gat_config(0, GAT_VCC);\r\nbreak;\r\ncase TRIG_EXT:\r\nzgat = pci230_gat_config(0, GAT_EXT);\r\nbreak;\r\ncase TRIG_TIMER:\r\nzgat = pci230_gat_config(0, GAT_NOUTNM2);\r\nbreak;\r\ncase TRIG_INT:\r\nzgat = pci230_gat_config(0, GAT_VCC);\r\nbreak;\r\n}\r\noutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\nzgat = pci230_gat_config(1, GAT_VCC);\r\noutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\r\nbreak;\r\ncase TRIG_INT:\r\nasync->inttrig = pci230_ai_inttrig_scan_begin;\r\nbreak;\r\n}\r\n}\r\n} else if (cmd->convert_src != TRIG_INT) {\r\npci230_release_shared(dev, RES_Z2CT2, OWNER_AICMD);\r\n}\r\n}\r\nstatic int pci230_ai_inttrig_start(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\ns->async->inttrig = NULL;\r\npci230_ai_start(dev, s);\r\nreturn 1;\r\n}\r\nstatic void pci230_handle_ai(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int status_fifo;\r\nunsigned int i;\r\nunsigned int nsamples;\r\nunsigned int fifoamount;\r\nunsigned short val;\r\nnsamples = comedi_nsamples_left(s, PCI230_ADC_FIFOLEVEL_HALFFULL);\r\nif (nsamples == 0)\r\nreturn;\r\nfifoamount = 0;\r\nfor (i = 0; i < nsamples; i++) {\r\nif (fifoamount == 0) {\r\nstatus_fifo = inw(devpriv->daqio + PCI230_ADCCON);\r\nif (status_fifo & PCI230_ADC_FIFO_FULL_LATCHED) {\r\ndev_err(dev->class_dev, "AI FIFO overrun\n");\r\nasync->events |= COMEDI_CB_ERROR;\r\nbreak;\r\n} else if (status_fifo & PCI230_ADC_FIFO_EMPTY) {\r\nbreak;\r\n} else if (status_fifo & PCI230_ADC_FIFO_HALF) {\r\nfifoamount = PCI230_ADC_FIFOLEVEL_HALFFULL;\r\n} else if (devpriv->hwver > 0) {\r\nfifoamount = inw(devpriv->daqio +\r\nPCI230P_ADCFFLEV);\r\nif (fifoamount == 0)\r\nbreak;\r\n} else {\r\nfifoamount = 1;\r\n}\r\n}\r\nval = pci230_ai_read(dev);\r\nif (!comedi_buf_write_samples(s, &val, 1))\r\nbreak;\r\nfifoamount--;\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg) {\r\nasync->events |= COMEDI_CB_EOA;\r\nbreak;\r\n}\r\n}\r\nif (!(async->events & COMEDI_CB_CANCEL_MASK))\r\npci230_ai_update_fifo_trigger_level(dev, s);\r\n}\r\nstatic int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pci230_private *devpriv = dev->private;\r\nunsigned int i, chan, range, diff;\r\nunsigned int res_mask;\r\nunsigned short adccon, adcen;\r\nunsigned char zgat;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nres_mask = 0;\r\nres_mask |= RES_Z2CT2;\r\nif (cmd->scan_begin_src != TRIG_FOLLOW) {\r\nres_mask |= RES_Z2CT0;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nres_mask |= RES_Z2CT1;\r\n}\r\n}\r\nif (!pci230_claim_shared(dev, res_mask, OWNER_AICMD))\r\nreturn -EBUSY;\r\nadccon = PCI230_ADC_FIFO_EN;\r\nadcen = 0;\r\nif (CR_AREF(cmd->chanlist[0]) == AREF_DIFF) {\r\ndiff = 1;\r\nadccon |= PCI230_ADC_IM_DIF;\r\n} else {\r\ndiff = 0;\r\nadccon |= PCI230_ADC_IM_SE;\r\n}\r\nrange = CR_RANGE(cmd->chanlist[0]);\r\ndevpriv->ai_bipolar = comedi_range_is_bipolar(s, range);\r\nif (devpriv->ai_bipolar)\r\nadccon |= PCI230_ADC_IR_BIP;\r\nelse\r\nadccon |= PCI230_ADC_IR_UNI;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int gainshift;\r\nchan = CR_CHAN(cmd->chanlist[i]);\r\nrange = CR_RANGE(cmd->chanlist[i]);\r\nif (diff) {\r\ngainshift = 2 * chan;\r\nif (devpriv->hwver == 0) {\r\nadcen |= 3 << gainshift;\r\n} else {\r\nadcen |= 1 << gainshift;\r\n}\r\n} else {\r\ngainshift = chan & ~1;\r\nadcen |= 1 << chan;\r\n}\r\ndevpriv->adcg = (devpriv->adcg & ~(3 << gainshift)) |\r\n(pci230_ai_gain[range] << gainshift);\r\n}\r\noutw(adcen, devpriv->daqio + PCI230_ADCEN);\r\noutw(devpriv->adcg, devpriv->daqio + PCI230_ADCG);\r\ncomedi_8254_set_mode(dev->pacer, 2, I8254_MODE1);\r\nadccon |= PCI230_ADC_INT_FIFO_FULL | PCI230_ADC_TRIG_Z2CT2;\r\ndevpriv->adccon = adccon;\r\noutw(adccon | PCI230_ADC_FIFO_RESET, devpriv->daqio + PCI230_ADCCON);\r\nusleep_range(25, 100);\r\noutw(adccon | PCI230_ADC_FIFO_RESET, devpriv->daqio + PCI230_ADCCON);\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nzgat = pci230_gat_config(2, GAT_GND);\r\noutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\r\npci230_ct_setup_ns_mode(dev, 2, I8254_MODE3, cmd->convert_arg,\r\ncmd->flags);\r\nif (cmd->scan_begin_src != TRIG_FOLLOW) {\r\nzgat = pci230_gat_config(0, GAT_VCC);\r\noutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\r\npci230_ct_setup_ns_mode(dev, 0, I8254_MODE1,\r\n((u64)cmd->convert_arg *\r\ncmd->scan_end_arg),\r\nCMDF_ROUND_UP);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nzgat = pci230_gat_config(1, GAT_GND);\r\noutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\r\npci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,\r\ncmd->scan_begin_arg,\r\ncmd->flags);\r\n}\r\n}\r\n}\r\nif (cmd->start_src == TRIG_INT)\r\ns->async->inttrig = pci230_ai_inttrig_start;\r\nelse\r\npci230_ai_start(dev, s);\r\nreturn 0;\r\n}\r\nstatic int pci230_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\npci230_ai_stop(dev, s);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t pci230_interrupt(int irq, void *d)\r\n{\r\nunsigned char status_int, valid_status_int, temp_ier;\r\nstruct comedi_device *dev = d;\r\nstruct pci230_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s_ao = dev->write_subdev;\r\nstruct comedi_subdevice *s_ai = dev->read_subdev;\r\nunsigned long irqflags;\r\nstatus_int = inb(dev->iobase + PCI230_INT_STAT);\r\nif (status_int == PCI230_INT_DISABLE)\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\nvalid_status_int = devpriv->ier & status_int;\r\ntemp_ier = devpriv->ier & ~status_int;\r\noutb(temp_ier, dev->iobase + PCI230_INT_SCE);\r\ndevpriv->intr_running = true;\r\ndevpriv->intr_cpuid = THISCPU;\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\r\nif (valid_status_int & PCI230_INT_ZCLK_CT1)\r\npci230_handle_ao_nofifo(dev, s_ao);\r\nif (valid_status_int & PCI230P2_INT_DAC)\r\npci230_handle_ao_fifo(dev, s_ao);\r\nif (valid_status_int & PCI230_INT_ADC)\r\npci230_handle_ai(dev, s_ai);\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\nif (devpriv->ier != temp_ier)\r\noutb(devpriv->ier, dev->iobase + PCI230_INT_SCE);\r\ndevpriv->intr_running = false;\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\r\ncomedi_handle_events(dev, s_ao);\r\ncomedi_handle_events(dev, s_ai);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic bool pci230_match_pci_board(const struct pci230_board *board,\r\nstruct pci_dev *pci_dev)\r\n{\r\nif (board->id != pci_dev->device)\r\nreturn false;\r\nif (board->min_hwver == 0)\r\nreturn true;\r\nif (pci_resource_len(pci_dev, 3) < 32)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic const struct pci230_board *pci230_find_pci_board(struct pci_dev *pci_dev)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(pci230_boards); i++)\r\nif (pci230_match_pci_board(&pci230_boards[i], pci_dev))\r\nreturn &pci230_boards[i];\r\nreturn NULL;\r\n}\r\nstatic int pci230_auto_attach(struct comedi_device *dev,\r\nunsigned long context_unused)\r\n{\r\nstruct pci_dev *pci_dev = comedi_to_pci_dev(dev);\r\nconst struct pci230_board *board;\r\nstruct pci230_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint rc;\r\ndev_info(dev->class_dev, "amplc_pci230: attach pci %s\n",\r\npci_name(pci_dev));\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&devpriv->isr_spinlock);\r\nspin_lock_init(&devpriv->res_spinlock);\r\nspin_lock_init(&devpriv->ai_stop_spinlock);\r\nspin_lock_init(&devpriv->ao_stop_spinlock);\r\nboard = pci230_find_pci_board(pci_dev);\r\nif (!board) {\r\ndev_err(dev->class_dev,\r\n"amplc_pci230: BUG! cannot determine board type!\n");\r\nreturn -EINVAL;\r\n}\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\nrc = comedi_pci_enable(dev);\r\nif (rc)\r\nreturn rc;\r\ndev->iobase = pci_resource_start(pci_dev, 2);\r\ndevpriv->daqio = pci_resource_start(pci_dev, 3);\r\ndev_dbg(dev->class_dev,\r\n"%s I/O region 1 0x%04lx I/O region 2 0x%04lx\n",\r\ndev->board_name, dev->iobase, devpriv->daqio);\r\ndevpriv->daccon = inw(devpriv->daqio + PCI230_DACCON) &\r\nPCI230_DAC_OR_MASK;\r\nif (pci_resource_len(pci_dev, 3) >= 32) {\r\nunsigned short extfunc = 0;\r\ndevpriv->hwver = inw(devpriv->daqio + PCI230P_HWVER);\r\nif (devpriv->hwver < board->min_hwver) {\r\ndev_err(dev->class_dev,\r\n"%s - bad hardware version - got %u, need %u\n",\r\ndev->board_name, devpriv->hwver,\r\nboard->min_hwver);\r\nreturn -EIO;\r\n}\r\nif (devpriv->hwver > 0) {\r\nif (!board->have_dio) {\r\nextfunc |= PCI230P_EXTFUNC_GAT_EXTTRIG;\r\n}\r\nif (board->ao_bits && devpriv->hwver >= 2) {\r\nextfunc |= PCI230P2_EXTFUNC_DACFIFO;\r\n}\r\n}\r\noutw(extfunc, devpriv->daqio + PCI230P_EXTFUNC);\r\nif (extfunc & PCI230P2_EXTFUNC_DACFIFO) {\r\noutw(devpriv->daccon | PCI230P2_DAC_FIFO_EN |\r\nPCI230P2_DAC_FIFO_RESET,\r\ndevpriv->daqio + PCI230_DACCON);\r\noutw(0, devpriv->daqio + PCI230P2_DACEN);\r\noutw(devpriv->daccon, devpriv->daqio + PCI230_DACCON);\r\n}\r\n}\r\noutb(0, dev->iobase + PCI230_INT_SCE);\r\ndevpriv->adcg = 0;\r\ndevpriv->adccon = PCI230_ADC_TRIG_NONE | PCI230_ADC_IM_SE |\r\nPCI230_ADC_IR_BIP;\r\noutw(1 << 0, devpriv->daqio + PCI230_ADCEN);\r\noutw(devpriv->adcg, devpriv->daqio + PCI230_ADCG);\r\noutw(devpriv->adccon | PCI230_ADC_FIFO_RESET,\r\ndevpriv->daqio + PCI230_ADCCON);\r\nif (pci_dev->irq) {\r\nrc = request_irq(pci_dev->irq, pci230_interrupt, IRQF_SHARED,\r\ndev->board_name, dev);\r\nif (rc == 0)\r\ndev->irq = pci_dev->irq;\r\n}\r\ndev->pacer = comedi_8254_init(dev->iobase + PCI230_Z2_CT_BASE,\r\n0, I8254_IO8, 0);\r\nif (!dev->pacer)\r\nreturn -ENOMEM;\r\nrc = comedi_alloc_subdevices(dev, 3);\r\nif (rc)\r\nreturn rc;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND;\r\ns->n_chan = 16;\r\ns->maxdata = (1 << board->ai_bits) - 1;\r\ns->range_table = &pci230_ai_range;\r\ns->insn_read = pci230_ai_insn_read;\r\ns->len_chanlist = 256;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->do_cmd = pci230_ai_cmd;\r\ns->do_cmdtest = pci230_ai_cmdtest;\r\ns->cancel = pci230_ai_cancel;\r\n}\r\ns = &dev->subdevices[1];\r\nif (board->ao_bits) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND;\r\ns->n_chan = 2;\r\ns->maxdata = (1 << board->ao_bits) - 1;\r\ns->range_table = &pci230_ao_range;\r\ns->insn_write = pci230_ao_insn_write;\r\ns->len_chanlist = 2;\r\nif (dev->irq) {\r\ndev->write_subdev = s;\r\ns->subdev_flags |= SDF_CMD_WRITE;\r\ns->do_cmd = pci230_ao_cmd;\r\ns->do_cmdtest = pci230_ao_cmdtest;\r\ns->cancel = pci230_ao_cancel;\r\n}\r\nrc = comedi_alloc_subdev_readback(s);\r\nif (rc)\r\nreturn rc;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\nif (board->have_dio) {\r\nrc = subdev_8255_init(dev, s, NULL, PCI230_PPI_X_BASE);\r\nif (rc)\r\nreturn rc;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\nreturn 0;\r\n}\r\nstatic int amplc_pci230_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &amplc_pci230_driver,\r\nid->driver_data);\r\n}
