static int get_clk_div_sgmii(struct ipq806x_gmac *gmac, unsigned int speed)\r\n{\r\nstruct device *dev = &gmac->pdev->dev;\r\nint div;\r\nswitch (speed) {\r\ncase SPEED_1000:\r\ndiv = NSS_COMMON_CLK_DIV_SGMII_1000;\r\nbreak;\r\ncase SPEED_100:\r\ndiv = NSS_COMMON_CLK_DIV_SGMII_100;\r\nbreak;\r\ncase SPEED_10:\r\ndiv = NSS_COMMON_CLK_DIV_SGMII_10;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Speed %dMbps not supported in SGMII\n", speed);\r\nreturn -EINVAL;\r\n}\r\nreturn div;\r\n}\r\nstatic int get_clk_div_rgmii(struct ipq806x_gmac *gmac, unsigned int speed)\r\n{\r\nstruct device *dev = &gmac->pdev->dev;\r\nint div;\r\nswitch (speed) {\r\ncase SPEED_1000:\r\ndiv = NSS_COMMON_CLK_DIV_RGMII_1000;\r\nbreak;\r\ncase SPEED_100:\r\ndiv = NSS_COMMON_CLK_DIV_RGMII_100;\r\nbreak;\r\ncase SPEED_10:\r\ndiv = NSS_COMMON_CLK_DIV_RGMII_10;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Speed %dMbps not supported in RGMII\n", speed);\r\nreturn -EINVAL;\r\n}\r\nreturn div;\r\n}\r\nstatic int ipq806x_gmac_set_speed(struct ipq806x_gmac *gmac, unsigned int speed)\r\n{\r\nuint32_t clk_bits, val;\r\nint div;\r\nswitch (gmac->phy_mode) {\r\ncase PHY_INTERFACE_MODE_RGMII:\r\ndiv = get_clk_div_rgmii(gmac, speed);\r\nclk_bits = NSS_COMMON_CLK_GATE_RGMII_RX_EN(gmac->id) |\r\nNSS_COMMON_CLK_GATE_RGMII_TX_EN(gmac->id);\r\nbreak;\r\ncase PHY_INTERFACE_MODE_SGMII:\r\ndiv = get_clk_div_sgmii(gmac, speed);\r\nclk_bits = NSS_COMMON_CLK_GATE_GMII_RX_EN(gmac->id) |\r\nNSS_COMMON_CLK_GATE_GMII_TX_EN(gmac->id);\r\nbreak;\r\ndefault:\r\ndev_err(&gmac->pdev->dev, "Unsupported PHY mode: \"%s\"\n",\r\nphy_modes(gmac->phy_mode));\r\nreturn -EINVAL;\r\n}\r\nregmap_read(gmac->nss_common, NSS_COMMON_CLK_GATE, &val);\r\nval &= ~clk_bits;\r\nregmap_write(gmac->nss_common, NSS_COMMON_CLK_GATE, val);\r\nregmap_read(gmac->nss_common, NSS_COMMON_CLK_DIV0, &val);\r\nval &= ~(NSS_COMMON_CLK_DIV_MASK\r\n<< NSS_COMMON_CLK_DIV_OFFSET(gmac->id));\r\nval |= div << NSS_COMMON_CLK_DIV_OFFSET(gmac->id);\r\nregmap_write(gmac->nss_common, NSS_COMMON_CLK_DIV0, val);\r\nregmap_read(gmac->nss_common, NSS_COMMON_CLK_GATE, &val);\r\nval |= clk_bits;\r\nregmap_write(gmac->nss_common, NSS_COMMON_CLK_GATE, val);\r\nreturn 0;\r\n}\r\nstatic int ipq806x_gmac_of_parse(struct ipq806x_gmac *gmac)\r\n{\r\nstruct device *dev = &gmac->pdev->dev;\r\ngmac->phy_mode = of_get_phy_mode(dev->of_node);\r\nif (gmac->phy_mode < 0) {\r\ndev_err(dev, "missing phy mode property\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32(dev->of_node, "qcom,id", &gmac->id) < 0) {\r\ndev_err(dev, "missing qcom id property\n");\r\nreturn -EINVAL;\r\n}\r\nif (gmac->id < 0 || gmac->id > 3) {\r\ndev_err(dev, "invalid gmac id\n");\r\nreturn -EINVAL;\r\n}\r\ngmac->core_clk = devm_clk_get(dev, "stmmaceth");\r\nif (IS_ERR(gmac->core_clk)) {\r\ndev_err(dev, "missing stmmaceth clk property\n");\r\nreturn PTR_ERR(gmac->core_clk);\r\n}\r\nclk_set_rate(gmac->core_clk, 266000000);\r\ngmac->nss_common = syscon_regmap_lookup_by_phandle(dev->of_node,\r\n"qcom,nss-common");\r\nif (IS_ERR(gmac->nss_common)) {\r\ndev_err(dev, "missing nss-common node\n");\r\nreturn PTR_ERR(gmac->nss_common);\r\n}\r\ngmac->qsgmii_csr = syscon_regmap_lookup_by_phandle(dev->of_node,\r\n"qcom,qsgmii-csr");\r\nif (IS_ERR(gmac->qsgmii_csr))\r\ndev_err(dev, "missing qsgmii-csr node\n");\r\nreturn PTR_ERR_OR_ZERO(gmac->qsgmii_csr);\r\n}\r\nstatic void ipq806x_gmac_fix_mac_speed(void *priv, unsigned int speed)\r\n{\r\nstruct ipq806x_gmac *gmac = priv;\r\nipq806x_gmac_set_speed(gmac, speed);\r\n}\r\nstatic int ipq806x_gmac_probe(struct platform_device *pdev)\r\n{\r\nstruct plat_stmmacenet_data *plat_dat;\r\nstruct stmmac_resources stmmac_res;\r\nstruct device *dev = &pdev->dev;\r\nstruct ipq806x_gmac *gmac;\r\nint val;\r\nint err;\r\nval = stmmac_get_platform_resources(pdev, &stmmac_res);\r\nif (val)\r\nreturn val;\r\nplat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);\r\nif (IS_ERR(plat_dat))\r\nreturn PTR_ERR(plat_dat);\r\ngmac = devm_kzalloc(dev, sizeof(*gmac), GFP_KERNEL);\r\nif (!gmac) {\r\nerr = -ENOMEM;\r\ngoto err_remove_config_dt;\r\n}\r\ngmac->pdev = pdev;\r\nerr = ipq806x_gmac_of_parse(gmac);\r\nif (err) {\r\ndev_err(dev, "device tree parsing error\n");\r\ngoto err_remove_config_dt;\r\n}\r\nregmap_write(gmac->qsgmii_csr, QSGMII_PCS_CAL_LCKDT_CTL,\r\nQSGMII_PCS_CAL_LCKDT_CTL_RST);\r\nval = 12 << NSS_COMMON_GMAC_CTL_IFG_OFFSET |\r\n12 << NSS_COMMON_GMAC_CTL_IFG_LIMIT_OFFSET;\r\nval |= NSS_COMMON_GMAC_CTL_CSYS_REQ;\r\nswitch (gmac->phy_mode) {\r\ncase PHY_INTERFACE_MODE_RGMII:\r\nval |= NSS_COMMON_GMAC_CTL_PHY_IFACE_SEL;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_SGMII:\r\nval &= ~NSS_COMMON_GMAC_CTL_PHY_IFACE_SEL;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unsupported PHY mode: \"%s\"\n",\r\nphy_modes(gmac->phy_mode));\r\nerr = -EINVAL;\r\ngoto err_remove_config_dt;\r\n}\r\nregmap_write(gmac->nss_common, NSS_COMMON_GMAC_CTL(gmac->id), val);\r\nregmap_read(gmac->nss_common, NSS_COMMON_CLK_SRC_CTRL, &val);\r\nval &= ~(1 << NSS_COMMON_CLK_SRC_CTRL_OFFSET(gmac->id));\r\nswitch (gmac->phy_mode) {\r\ncase PHY_INTERFACE_MODE_RGMII:\r\nval |= NSS_COMMON_CLK_SRC_CTRL_RGMII(gmac->id) <<\r\nNSS_COMMON_CLK_SRC_CTRL_OFFSET(gmac->id);\r\nbreak;\r\ncase PHY_INTERFACE_MODE_SGMII:\r\nval |= NSS_COMMON_CLK_SRC_CTRL_SGMII(gmac->id) <<\r\nNSS_COMMON_CLK_SRC_CTRL_OFFSET(gmac->id);\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unsupported PHY mode: \"%s\"\n",\r\nphy_modes(gmac->phy_mode));\r\nerr = -EINVAL;\r\ngoto err_remove_config_dt;\r\n}\r\nregmap_write(gmac->nss_common, NSS_COMMON_CLK_SRC_CTRL, val);\r\nregmap_read(gmac->nss_common, NSS_COMMON_CLK_GATE, &val);\r\nval |= NSS_COMMON_CLK_GATE_PTP_EN(gmac->id);\r\nregmap_write(gmac->nss_common, NSS_COMMON_CLK_GATE, val);\r\nif (gmac->phy_mode == PHY_INTERFACE_MODE_SGMII) {\r\nregmap_write(gmac->qsgmii_csr, QSGMII_PHY_SGMII_CTL(gmac->id),\r\nQSGMII_PHY_CDR_EN |\r\nQSGMII_PHY_RX_FRONT_EN |\r\nQSGMII_PHY_RX_SIGNAL_DETECT_EN |\r\nQSGMII_PHY_TX_DRIVER_EN |\r\nQSGMII_PHY_QSGMII_EN |\r\n0x4ul << QSGMII_PHY_PHASE_LOOP_GAIN_OFFSET |\r\n0x3ul << QSGMII_PHY_RX_DC_BIAS_OFFSET |\r\n0x1ul << QSGMII_PHY_RX_INPUT_EQU_OFFSET |\r\n0x2ul << QSGMII_PHY_CDR_PI_SLEW_OFFSET |\r\n0xCul << QSGMII_PHY_TX_DRV_AMP_OFFSET);\r\n}\r\nplat_dat->has_gmac = true;\r\nplat_dat->bsp_priv = gmac;\r\nplat_dat->fix_mac_speed = ipq806x_gmac_fix_mac_speed;\r\nerr = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\r\nif (err)\r\ngoto err_remove_config_dt;\r\nreturn 0;\r\nerr_remove_config_dt:\r\nstmmac_remove_config_dt(pdev, plat_dat);\r\nreturn err;\r\n}
