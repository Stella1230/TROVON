static void *i915_sw_fence_debug_hint(void *addr)\r\n{\r\nreturn (void *)(((struct i915_sw_fence *)addr)->flags & I915_SW_FENCE_MASK);\r\n}\r\nstatic inline void debug_fence_init(struct i915_sw_fence *fence)\r\n{\r\ndebug_object_init(fence, &i915_sw_fence_debug_descr);\r\n}\r\nstatic inline void debug_fence_activate(struct i915_sw_fence *fence)\r\n{\r\ndebug_object_activate(fence, &i915_sw_fence_debug_descr);\r\n}\r\nstatic inline void debug_fence_set_state(struct i915_sw_fence *fence,\r\nint old, int new)\r\n{\r\ndebug_object_active_state(fence, &i915_sw_fence_debug_descr, old, new);\r\n}\r\nstatic inline void debug_fence_deactivate(struct i915_sw_fence *fence)\r\n{\r\ndebug_object_deactivate(fence, &i915_sw_fence_debug_descr);\r\n}\r\nstatic inline void debug_fence_destroy(struct i915_sw_fence *fence)\r\n{\r\ndebug_object_destroy(fence, &i915_sw_fence_debug_descr);\r\n}\r\nstatic inline void debug_fence_free(struct i915_sw_fence *fence)\r\n{\r\ndebug_object_free(fence, &i915_sw_fence_debug_descr);\r\nsmp_wmb();\r\n}\r\nstatic inline void debug_fence_assert(struct i915_sw_fence *fence)\r\n{\r\ndebug_object_assert_init(fence, &i915_sw_fence_debug_descr);\r\n}\r\nstatic inline void debug_fence_init(struct i915_sw_fence *fence)\r\n{\r\n}\r\nstatic inline void debug_fence_activate(struct i915_sw_fence *fence)\r\n{\r\n}\r\nstatic inline void debug_fence_set_state(struct i915_sw_fence *fence,\r\nint old, int new)\r\n{\r\n}\r\nstatic inline void debug_fence_deactivate(struct i915_sw_fence *fence)\r\n{\r\n}\r\nstatic inline void debug_fence_destroy(struct i915_sw_fence *fence)\r\n{\r\n}\r\nstatic inline void debug_fence_free(struct i915_sw_fence *fence)\r\n{\r\n}\r\nstatic inline void debug_fence_assert(struct i915_sw_fence *fence)\r\n{\r\n}\r\nstatic int __i915_sw_fence_notify(struct i915_sw_fence *fence,\r\nenum i915_sw_fence_notify state)\r\n{\r\ni915_sw_fence_notify_t fn;\r\nfn = (i915_sw_fence_notify_t)(fence->flags & I915_SW_FENCE_MASK);\r\nreturn fn(fence, state);\r\n}\r\nvoid i915_sw_fence_fini(struct i915_sw_fence *fence)\r\n{\r\ndebug_fence_free(fence);\r\n}\r\nstatic void __i915_sw_fence_wake_up_all(struct i915_sw_fence *fence,\r\nstruct list_head *continuation)\r\n{\r\nwait_queue_head_t *x = &fence->wait;\r\nwait_queue_entry_t *pos, *next;\r\nunsigned long flags;\r\ndebug_fence_deactivate(fence);\r\natomic_set_release(&fence->pending, -1);\r\nspin_lock_irqsave_nested(&x->lock, flags, 1 + !!continuation);\r\nif (continuation) {\r\nlist_for_each_entry_safe(pos, next, &x->head, entry) {\r\nif (pos->func == autoremove_wake_function)\r\npos->func(pos, TASK_NORMAL, 0, continuation);\r\nelse\r\nlist_move_tail(&pos->entry, continuation);\r\n}\r\n} else {\r\nLIST_HEAD(extra);\r\ndo {\r\nlist_for_each_entry_safe(pos, next, &x->head, entry)\r\npos->func(pos, TASK_NORMAL, 0, &extra);\r\nif (list_empty(&extra))\r\nbreak;\r\nlist_splice_tail_init(&extra, &x->head);\r\n} while (1);\r\n}\r\nspin_unlock_irqrestore(&x->lock, flags);\r\ndebug_fence_assert(fence);\r\n}\r\nstatic void __i915_sw_fence_complete(struct i915_sw_fence *fence,\r\nstruct list_head *continuation)\r\n{\r\ndebug_fence_assert(fence);\r\nif (!atomic_dec_and_test(&fence->pending))\r\nreturn;\r\ndebug_fence_set_state(fence, DEBUG_FENCE_IDLE, DEBUG_FENCE_NOTIFY);\r\nif (__i915_sw_fence_notify(fence, FENCE_COMPLETE) != NOTIFY_DONE)\r\nreturn;\r\ndebug_fence_set_state(fence, DEBUG_FENCE_NOTIFY, DEBUG_FENCE_IDLE);\r\n__i915_sw_fence_wake_up_all(fence, continuation);\r\ndebug_fence_destroy(fence);\r\n__i915_sw_fence_notify(fence, FENCE_FREE);\r\n}\r\nstatic void i915_sw_fence_complete(struct i915_sw_fence *fence)\r\n{\r\ndebug_fence_assert(fence);\r\nif (WARN_ON(i915_sw_fence_done(fence)))\r\nreturn;\r\n__i915_sw_fence_complete(fence, NULL);\r\n}\r\nstatic void i915_sw_fence_await(struct i915_sw_fence *fence)\r\n{\r\ndebug_fence_assert(fence);\r\nWARN_ON(atomic_inc_return(&fence->pending) <= 1);\r\n}\r\nvoid __i915_sw_fence_init(struct i915_sw_fence *fence,\r\ni915_sw_fence_notify_t fn,\r\nconst char *name,\r\nstruct lock_class_key *key)\r\n{\r\nBUG_ON(!fn || (unsigned long)fn & ~I915_SW_FENCE_MASK);\r\ndebug_fence_init(fence);\r\n__init_waitqueue_head(&fence->wait, name, key);\r\natomic_set(&fence->pending, 1);\r\nfence->flags = (unsigned long)fn;\r\n}\r\nvoid i915_sw_fence_commit(struct i915_sw_fence *fence)\r\n{\r\ndebug_fence_activate(fence);\r\ni915_sw_fence_complete(fence);\r\n}\r\nstatic int i915_sw_fence_wake(wait_queue_entry_t *wq, unsigned mode, int flags, void *key)\r\n{\r\nlist_del(&wq->entry);\r\n__i915_sw_fence_complete(wq->private, key);\r\nif (wq->flags & I915_SW_FENCE_FLAG_ALLOC)\r\nkfree(wq);\r\nreturn 0;\r\n}\r\nstatic bool __i915_sw_fence_check_if_after(struct i915_sw_fence *fence,\r\nconst struct i915_sw_fence * const signaler)\r\n{\r\nwait_queue_entry_t *wq;\r\nif (__test_and_set_bit(I915_SW_FENCE_CHECKED_BIT, &fence->flags))\r\nreturn false;\r\nif (fence == signaler)\r\nreturn true;\r\nlist_for_each_entry(wq, &fence->wait.head, entry) {\r\nif (wq->func != i915_sw_fence_wake)\r\ncontinue;\r\nif (__i915_sw_fence_check_if_after(wq->private, signaler))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void __i915_sw_fence_clear_checked_bit(struct i915_sw_fence *fence)\r\n{\r\nwait_queue_entry_t *wq;\r\nif (!__test_and_clear_bit(I915_SW_FENCE_CHECKED_BIT, &fence->flags))\r\nreturn;\r\nlist_for_each_entry(wq, &fence->wait.head, entry) {\r\nif (wq->func != i915_sw_fence_wake)\r\ncontinue;\r\n__i915_sw_fence_clear_checked_bit(wq->private);\r\n}\r\n}\r\nstatic bool i915_sw_fence_check_if_after(struct i915_sw_fence *fence,\r\nconst struct i915_sw_fence * const signaler)\r\n{\r\nunsigned long flags;\r\nbool err;\r\nif (!IS_ENABLED(CONFIG_DRM_I915_SW_FENCE_CHECK_DAG))\r\nreturn false;\r\nspin_lock_irqsave(&i915_sw_fence_lock, flags);\r\nerr = __i915_sw_fence_check_if_after(fence, signaler);\r\n__i915_sw_fence_clear_checked_bit(fence);\r\nspin_unlock_irqrestore(&i915_sw_fence_lock, flags);\r\nreturn err;\r\n}\r\nstatic int __i915_sw_fence_await_sw_fence(struct i915_sw_fence *fence,\r\nstruct i915_sw_fence *signaler,\r\nwait_queue_entry_t *wq, gfp_t gfp)\r\n{\r\nunsigned long flags;\r\nint pending;\r\ndebug_fence_assert(fence);\r\nif (i915_sw_fence_done(signaler))\r\nreturn 0;\r\ndebug_fence_assert(signaler);\r\nif (unlikely(i915_sw_fence_check_if_after(fence, signaler)))\r\nreturn -EINVAL;\r\npending = 0;\r\nif (!wq) {\r\nwq = kmalloc(sizeof(*wq), gfp);\r\nif (!wq) {\r\nif (!gfpflags_allow_blocking(gfp))\r\nreturn -ENOMEM;\r\ni915_sw_fence_wait(signaler);\r\nreturn 0;\r\n}\r\npending |= I915_SW_FENCE_FLAG_ALLOC;\r\n}\r\nINIT_LIST_HEAD(&wq->entry);\r\nwq->flags = pending;\r\nwq->func = i915_sw_fence_wake;\r\nwq->private = fence;\r\ni915_sw_fence_await(fence);\r\nspin_lock_irqsave(&signaler->wait.lock, flags);\r\nif (likely(!i915_sw_fence_done(signaler))) {\r\n__add_wait_queue_entry_tail(&signaler->wait, wq);\r\npending = 1;\r\n} else {\r\ni915_sw_fence_wake(wq, 0, 0, NULL);\r\npending = 0;\r\n}\r\nspin_unlock_irqrestore(&signaler->wait.lock, flags);\r\nreturn pending;\r\n}\r\nint i915_sw_fence_await_sw_fence(struct i915_sw_fence *fence,\r\nstruct i915_sw_fence *signaler,\r\nwait_queue_entry_t *wq)\r\n{\r\nreturn __i915_sw_fence_await_sw_fence(fence, signaler, wq, 0);\r\n}\r\nint i915_sw_fence_await_sw_fence_gfp(struct i915_sw_fence *fence,\r\nstruct i915_sw_fence *signaler,\r\ngfp_t gfp)\r\n{\r\nreturn __i915_sw_fence_await_sw_fence(fence, signaler, NULL, gfp);\r\n}\r\nstatic void timer_i915_sw_fence_wake(unsigned long data)\r\n{\r\nstruct i915_sw_dma_fence_cb *cb = (struct i915_sw_dma_fence_cb *)data;\r\npr_warn("asynchronous wait on fence %s:%s:%x timed out\n",\r\ncb->dma->ops->get_driver_name(cb->dma),\r\ncb->dma->ops->get_timeline_name(cb->dma),\r\ncb->dma->seqno);\r\ndma_fence_put(cb->dma);\r\ncb->dma = NULL;\r\ni915_sw_fence_complete(cb->fence);\r\ncb->timer.function = NULL;\r\n}\r\nstatic void dma_i915_sw_fence_wake(struct dma_fence *dma,\r\nstruct dma_fence_cb *data)\r\n{\r\nstruct i915_sw_dma_fence_cb *cb = container_of(data, typeof(*cb), base);\r\ndel_timer_sync(&cb->timer);\r\nif (cb->timer.function)\r\ni915_sw_fence_complete(cb->fence);\r\ndma_fence_put(cb->dma);\r\nkfree(cb);\r\n}\r\nint i915_sw_fence_await_dma_fence(struct i915_sw_fence *fence,\r\nstruct dma_fence *dma,\r\nunsigned long timeout,\r\ngfp_t gfp)\r\n{\r\nstruct i915_sw_dma_fence_cb *cb;\r\nint ret;\r\ndebug_fence_assert(fence);\r\nif (dma_fence_is_signaled(dma))\r\nreturn 0;\r\ncb = kmalloc(sizeof(*cb), gfp);\r\nif (!cb) {\r\nif (!gfpflags_allow_blocking(gfp))\r\nreturn -ENOMEM;\r\nreturn dma_fence_wait(dma, false);\r\n}\r\ncb->fence = fence;\r\ni915_sw_fence_await(fence);\r\ncb->dma = NULL;\r\n__setup_timer(&cb->timer,\r\ntimer_i915_sw_fence_wake, (unsigned long)cb,\r\nTIMER_IRQSAFE);\r\nif (timeout) {\r\ncb->dma = dma_fence_get(dma);\r\nmod_timer(&cb->timer, round_jiffies_up(jiffies + timeout));\r\n}\r\nret = dma_fence_add_callback(dma, &cb->base, dma_i915_sw_fence_wake);\r\nif (ret == 0) {\r\nret = 1;\r\n} else {\r\ndma_i915_sw_fence_wake(dma, &cb->base);\r\nif (ret == -ENOENT)\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nint i915_sw_fence_await_reservation(struct i915_sw_fence *fence,\r\nstruct reservation_object *resv,\r\nconst struct dma_fence_ops *exclude,\r\nbool write,\r\nunsigned long timeout,\r\ngfp_t gfp)\r\n{\r\nstruct dma_fence *excl;\r\nint ret = 0, pending;\r\ndebug_fence_assert(fence);\r\nif (write) {\r\nstruct dma_fence **shared;\r\nunsigned int count, i;\r\nret = reservation_object_get_fences_rcu(resv,\r\n&excl, &count, &shared);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < count; i++) {\r\nif (shared[i]->ops == exclude)\r\ncontinue;\r\npending = i915_sw_fence_await_dma_fence(fence,\r\nshared[i],\r\ntimeout,\r\ngfp);\r\nif (pending < 0) {\r\nret = pending;\r\nbreak;\r\n}\r\nret |= pending;\r\n}\r\nfor (i = 0; i < count; i++)\r\ndma_fence_put(shared[i]);\r\nkfree(shared);\r\n} else {\r\nexcl = reservation_object_get_excl_rcu(resv);\r\n}\r\nif (ret >= 0 && excl && excl->ops != exclude) {\r\npending = i915_sw_fence_await_dma_fence(fence,\r\nexcl,\r\ntimeout,\r\ngfp);\r\nif (pending < 0)\r\nret = pending;\r\nelse\r\nret |= pending;\r\n}\r\ndma_fence_put(excl);\r\nreturn ret;\r\n}
