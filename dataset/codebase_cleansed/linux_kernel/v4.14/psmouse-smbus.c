static void psmouse_smbus_check_adapter(struct i2c_adapter *adapter)\r\n{\r\nstruct psmouse_smbus_dev *smbdev;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_HOST_NOTIFY))\r\nreturn;\r\nmutex_lock(&psmouse_smbus_mutex);\r\nlist_for_each_entry(smbdev, &psmouse_smbus_list, node) {\r\nif (smbdev->dead)\r\ncontinue;\r\nif (smbdev->client)\r\ncontinue;\r\npsmouse_dbg(smbdev->psmouse,\r\n"SMBus candidate adapter appeared, triggering rescan\n");\r\nserio_rescan(smbdev->psmouse->ps2dev.serio);\r\n}\r\nmutex_unlock(&psmouse_smbus_mutex);\r\n}\r\nstatic void psmouse_smbus_detach_i2c_client(struct i2c_client *client)\r\n{\r\nstruct psmouse_smbus_dev *smbdev, *tmp;\r\nmutex_lock(&psmouse_smbus_mutex);\r\nlist_for_each_entry_safe(smbdev, tmp, &psmouse_smbus_list, node) {\r\nif (smbdev->client != client)\r\ncontinue;\r\nkfree(client->dev.platform_data);\r\nclient->dev.platform_data = NULL;\r\nif (!smbdev->dead) {\r\npsmouse_dbg(smbdev->psmouse,\r\n"Marking SMBus companion %s as gone\n",\r\ndev_name(&smbdev->client->dev));\r\nsmbdev->dead = true;\r\nserio_rescan(smbdev->psmouse->ps2dev.serio);\r\n} else {\r\nlist_del(&smbdev->node);\r\nkfree(smbdev);\r\n}\r\n}\r\nmutex_unlock(&psmouse_smbus_mutex);\r\n}\r\nstatic int psmouse_smbus_notifier_call(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct device *dev = data;\r\nswitch (action) {\r\ncase BUS_NOTIFY_ADD_DEVICE:\r\nif (dev->type == &i2c_adapter_type)\r\npsmouse_smbus_check_adapter(to_i2c_adapter(dev));\r\nbreak;\r\ncase BUS_NOTIFY_REMOVED_DEVICE:\r\nif (dev->type == &i2c_client_type)\r\npsmouse_smbus_detach_i2c_client(to_i2c_client(dev));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic psmouse_ret_t psmouse_smbus_process_byte(struct psmouse *psmouse)\r\n{\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nstatic int psmouse_smbus_reconnect(struct psmouse *psmouse)\r\n{\r\npsmouse_deactivate(psmouse);\r\nreturn 0;\r\n}\r\nstatic void psmouse_smbus_remove_i2c_device(struct work_struct *work)\r\n{\r\nstruct psmouse_smbus_removal_work *rwork =\r\ncontainer_of(work, struct psmouse_smbus_removal_work, work);\r\ndev_dbg(&rwork->client->dev, "destroying SMBus companion device\n");\r\ni2c_unregister_device(rwork->client);\r\nkfree(rwork);\r\n}\r\nstatic void psmouse_smbus_schedule_remove(struct i2c_client *client)\r\n{\r\nstruct psmouse_smbus_removal_work *rwork;\r\nrwork = kzalloc(sizeof(*rwork), GFP_KERNEL);\r\nif (rwork) {\r\nINIT_WORK(&rwork->work, psmouse_smbus_remove_i2c_device);\r\nrwork->client = client;\r\nschedule_work(&rwork->work);\r\n}\r\n}\r\nstatic void psmouse_smbus_disconnect(struct psmouse *psmouse)\r\n{\r\nstruct psmouse_smbus_dev *smbdev = psmouse->private;\r\nmutex_lock(&psmouse_smbus_mutex);\r\nif (smbdev->dead) {\r\nlist_del(&smbdev->node);\r\nkfree(smbdev);\r\n} else {\r\nsmbdev->dead = true;\r\npsmouse_dbg(smbdev->psmouse,\r\n"posting removal request for SMBus companion %s\n",\r\ndev_name(&smbdev->client->dev));\r\npsmouse_smbus_schedule_remove(smbdev->client);\r\n}\r\nmutex_unlock(&psmouse_smbus_mutex);\r\npsmouse->private = NULL;\r\n}\r\nstatic int psmouse_smbus_create_companion(struct device *dev, void *data)\r\n{\r\nstruct psmouse_smbus_dev *smbdev = data;\r\nunsigned short addr_list[] = { smbdev->board.addr, I2C_CLIENT_END };\r\nstruct i2c_adapter *adapter;\r\nadapter = i2c_verify_adapter(dev);\r\nif (!adapter)\r\nreturn 0;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_HOST_NOTIFY))\r\nreturn 0;\r\nsmbdev->client = i2c_new_probed_device(adapter, &smbdev->board,\r\naddr_list, NULL);\r\nif (!smbdev->client)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid psmouse_smbus_cleanup(struct psmouse *psmouse)\r\n{\r\nstruct psmouse_smbus_dev *smbdev, *tmp;\r\nmutex_lock(&psmouse_smbus_mutex);\r\nlist_for_each_entry_safe(smbdev, tmp, &psmouse_smbus_list, node) {\r\nif (psmouse == smbdev->psmouse) {\r\nlist_del(&smbdev->node);\r\nkfree(smbdev);\r\n}\r\n}\r\nmutex_unlock(&psmouse_smbus_mutex);\r\n}\r\nint psmouse_smbus_init(struct psmouse *psmouse,\r\nconst struct i2c_board_info *board,\r\nconst void *pdata, size_t pdata_size,\r\nbool leave_breadcrumbs)\r\n{\r\nstruct psmouse_smbus_dev *smbdev;\r\nint error;\r\nsmbdev = kzalloc(sizeof(*smbdev), GFP_KERNEL);\r\nif (!smbdev)\r\nreturn -ENOMEM;\r\nsmbdev->psmouse = psmouse;\r\nsmbdev->board = *board;\r\nsmbdev->board.platform_data = kmemdup(pdata, pdata_size, GFP_KERNEL);\r\nif (!smbdev->board.platform_data) {\r\nkfree(smbdev);\r\nreturn -ENOMEM;\r\n}\r\npsmouse->private = smbdev;\r\npsmouse->protocol_handler = psmouse_smbus_process_byte;\r\npsmouse->reconnect = psmouse_smbus_reconnect;\r\npsmouse->fast_reconnect = psmouse_smbus_reconnect;\r\npsmouse->disconnect = psmouse_smbus_disconnect;\r\npsmouse->resync_time = 0;\r\npsmouse_deactivate(psmouse);\r\nmutex_lock(&psmouse_smbus_mutex);\r\nlist_add_tail(&smbdev->node, &psmouse_smbus_list);\r\nmutex_unlock(&psmouse_smbus_mutex);\r\nerror = i2c_for_each_dev(smbdev, psmouse_smbus_create_companion);\r\nif (smbdev->client) {\r\nreturn 0;\r\n}\r\nkfree(smbdev->board.platform_data);\r\nsmbdev->board.platform_data = NULL;\r\nif (error < 0 || !leave_breadcrumbs) {\r\nmutex_lock(&psmouse_smbus_mutex);\r\nlist_del(&smbdev->node);\r\nmutex_unlock(&psmouse_smbus_mutex);\r\nkfree(smbdev);\r\n}\r\nreturn error < 0 ? error : -EAGAIN;\r\n}\r\nint __init psmouse_smbus_module_init(void)\r\n{\r\nint error;\r\nerror = bus_register_notifier(&i2c_bus_type, &psmouse_smbus_notifier);\r\nif (error) {\r\npr_err("failed to register i2c bus notifier: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nvoid psmouse_smbus_module_exit(void)\r\n{\r\nbus_unregister_notifier(&i2c_bus_type, &psmouse_smbus_notifier);\r\nflush_scheduled_work();\r\n}
