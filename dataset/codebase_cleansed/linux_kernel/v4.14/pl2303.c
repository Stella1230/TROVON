static int pl2303_vendor_read(struct usb_serial *serial, u16 value,\r\nunsigned char buf[1])\r\n{\r\nstruct device *dev = &serial->interface->dev;\r\nint res;\r\nres = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nVENDOR_READ_REQUEST, VENDOR_READ_REQUEST_TYPE,\r\nvalue, 0, buf, 1, 100);\r\nif (res != 1) {\r\ndev_err(dev, "%s - failed to read [%04x]: %d\n", __func__,\r\nvalue, res);\r\nif (res >= 0)\r\nres = -EIO;\r\nreturn res;\r\n}\r\ndev_dbg(dev, "%s - [%04x] = %02x\n", __func__, value, buf[0]);\r\nreturn 0;\r\n}\r\nstatic int pl2303_vendor_write(struct usb_serial *serial, u16 value, u16 index)\r\n{\r\nstruct device *dev = &serial->interface->dev;\r\nint res;\r\ndev_dbg(dev, "%s - [%04x] = %02x\n", __func__, value, index);\r\nres = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nVENDOR_WRITE_REQUEST, VENDOR_WRITE_REQUEST_TYPE,\r\nvalue, index, NULL, 0, 100);\r\nif (res) {\r\ndev_err(dev, "%s - failed to write [%04x]: %d\n", __func__,\r\nvalue, res);\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pl2303_probe(struct usb_serial *serial,\r\nconst struct usb_device_id *id)\r\n{\r\nusb_set_serial_data(serial, (void *)id->driver_info);\r\nreturn 0;\r\n}\r\nstatic int pl2303_endpoint_hack(struct usb_serial *serial,\r\nstruct usb_serial_endpoints *epds)\r\n{\r\nstruct usb_interface *interface = serial->interface;\r\nstruct usb_device *dev = serial->dev;\r\nstruct device *ddev = &interface->dev;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nunsigned int i;\r\nif (interface == dev->actconfig->interface[0])\r\nreturn 0;\r\niface_desc = dev->actconfig->interface[0]->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (!usb_endpoint_is_int_in(endpoint))\r\ncontinue;\r\ndev_dbg(ddev, "found interrupt in on separate interface\n");\r\nif (epds->num_interrupt_in < ARRAY_SIZE(epds->interrupt_in))\r\nepds->interrupt_in[epds->num_interrupt_in++] = endpoint;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pl2303_calc_num_ports(struct usb_serial *serial,\r\nstruct usb_serial_endpoints *epds)\r\n{\r\nunsigned long quirks = (unsigned long)usb_get_serial_data(serial);\r\nstruct device *dev = &serial->interface->dev;\r\nint ret;\r\nif (quirks & PL2303_QUIRK_ENDPOINT_HACK) {\r\nret = pl2303_endpoint_hack(serial, epds);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (epds->num_interrupt_in < 1) {\r\ndev_err(dev, "required interrupt-in endpoint missing\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 1;\r\n}\r\nstatic int pl2303_startup(struct usb_serial *serial)\r\n{\r\nstruct pl2303_serial_private *spriv;\r\nenum pl2303_type type = TYPE_01;\r\nunsigned char *buf;\r\nspriv = kzalloc(sizeof(*spriv), GFP_KERNEL);\r\nif (!spriv)\r\nreturn -ENOMEM;\r\nbuf = kmalloc(1, GFP_KERNEL);\r\nif (!buf) {\r\nkfree(spriv);\r\nreturn -ENOMEM;\r\n}\r\nif (serial->dev->descriptor.bDeviceClass == 0x02)\r\ntype = TYPE_01;\r\nelse if (serial->dev->descriptor.bMaxPacketSize0 == 0x40)\r\ntype = TYPE_HX;\r\nelse if (serial->dev->descriptor.bDeviceClass == 0x00)\r\ntype = TYPE_01;\r\nelse if (serial->dev->descriptor.bDeviceClass == 0xFF)\r\ntype = TYPE_01;\r\ndev_dbg(&serial->interface->dev, "device type: %d\n", type);\r\nspriv->type = &pl2303_type_data[type];\r\nspriv->quirks = (unsigned long)usb_get_serial_data(serial);\r\nspriv->quirks |= spriv->type->quirks;\r\nusb_set_serial_data(serial, spriv);\r\npl2303_vendor_read(serial, 0x8484, buf);\r\npl2303_vendor_write(serial, 0x0404, 0);\r\npl2303_vendor_read(serial, 0x8484, buf);\r\npl2303_vendor_read(serial, 0x8383, buf);\r\npl2303_vendor_read(serial, 0x8484, buf);\r\npl2303_vendor_write(serial, 0x0404, 1);\r\npl2303_vendor_read(serial, 0x8484, buf);\r\npl2303_vendor_read(serial, 0x8383, buf);\r\npl2303_vendor_write(serial, 0, 1);\r\npl2303_vendor_write(serial, 1, 0);\r\nif (spriv->quirks & PL2303_QUIRK_LEGACY)\r\npl2303_vendor_write(serial, 2, 0x24);\r\nelse\r\npl2303_vendor_write(serial, 2, 0x44);\r\nkfree(buf);\r\nreturn 0;\r\n}\r\nstatic void pl2303_release(struct usb_serial *serial)\r\n{\r\nstruct pl2303_serial_private *spriv = usb_get_serial_data(serial);\r\nkfree(spriv);\r\n}\r\nstatic int pl2303_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct pl2303_private *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&priv->lock);\r\nusb_set_serial_port_data(port, priv);\r\nport->port.drain_delay = 256;\r\nreturn 0;\r\n}\r\nstatic int pl2303_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int pl2303_set_control_lines(struct usb_serial_port *port, u8 value)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nint retval;\r\ndev_dbg(&port->dev, "%s - %02x\n", __func__, value);\r\nretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nSET_CONTROL_REQUEST, SET_CONTROL_REQUEST_TYPE,\r\nvalue, 0, NULL, 0, 100);\r\nif (retval)\r\ndev_err(&port->dev, "%s - failed: %d\n", __func__, retval);\r\nreturn retval;\r\n}\r\nstatic speed_t pl2303_get_supported_baud_rate(speed_t baud)\r\n{\r\nstatic const speed_t baud_sup[] = {\r\n75, 150, 300, 600, 1200, 1800, 2400, 3600, 4800, 7200, 9600,\r\n14400, 19200, 28800, 38400, 57600, 115200, 230400, 460800,\r\n614400, 921600, 1228800, 2457600, 3000000, 6000000\r\n};\r\nunsigned i;\r\nfor (i = 0; i < ARRAY_SIZE(baud_sup); ++i) {\r\nif (baud_sup[i] > baud)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(baud_sup))\r\nbaud = baud_sup[i - 1];\r\nelse if (i > 0 && (baud_sup[i] - baud) > (baud - baud_sup[i - 1]))\r\nbaud = baud_sup[i - 1];\r\nelse\r\nbaud = baud_sup[i];\r\nreturn baud;\r\n}\r\nstatic speed_t pl2303_encode_baud_rate_direct(unsigned char buf[4],\r\nspeed_t baud)\r\n{\r\nput_unaligned_le32(baud, buf);\r\nreturn baud;\r\n}\r\nstatic speed_t pl2303_encode_baud_rate_divisor(unsigned char buf[4],\r\nspeed_t baud)\r\n{\r\nunsigned int baseline, mantissa, exponent;\r\nbaseline = 12000000 * 32;\r\nmantissa = baseline / baud;\r\nif (mantissa == 0)\r\nmantissa = 1;\r\nexponent = 0;\r\nwhile (mantissa >= 512) {\r\nif (exponent < 7) {\r\nmantissa >>= 2;\r\nexponent++;\r\n} else {\r\nmantissa = 511;\r\nbreak;\r\n}\r\n}\r\nbuf[3] = 0x80;\r\nbuf[2] = 0;\r\nbuf[1] = exponent << 1 | mantissa >> 8;\r\nbuf[0] = mantissa & 0xff;\r\nbaud = (baseline / mantissa) >> (exponent << 1);\r\nreturn baud;\r\n}\r\nstatic void pl2303_encode_baud_rate(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nu8 buf[4])\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct pl2303_serial_private *spriv = usb_get_serial_data(serial);\r\nspeed_t baud_sup;\r\nspeed_t baud;\r\nbaud = tty_get_baud_rate(tty);\r\ndev_dbg(&port->dev, "baud requested = %u\n", baud);\r\nif (!baud)\r\nreturn;\r\nif (spriv->type->max_baud_rate)\r\nbaud = min_t(speed_t, baud, spriv->type->max_baud_rate);\r\nbaud_sup = pl2303_get_supported_baud_rate(baud);\r\nif (baud == baud_sup)\r\nbaud = pl2303_encode_baud_rate_direct(buf, baud);\r\nelse\r\nbaud = pl2303_encode_baud_rate_divisor(buf, baud);\r\ntty_encode_baud_rate(tty, baud, baud);\r\ndev_dbg(&port->dev, "baud set = %u\n", baud);\r\n}\r\nstatic int pl2303_get_line_request(struct usb_serial_port *port,\r\nunsigned char buf[7])\r\n{\r\nstruct usb_device *udev = port->serial->dev;\r\nint ret;\r\nret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nGET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,\r\n0, 0, buf, 7, 100);\r\nif (ret != 7) {\r\ndev_err(&port->dev, "%s - failed: %d\n", __func__, ret);\r\nif (ret >= 0)\r\nret = -EIO;\r\nreturn ret;\r\n}\r\ndev_dbg(&port->dev, "%s - %7ph\n", __func__, buf);\r\nreturn 0;\r\n}\r\nstatic int pl2303_set_line_request(struct usb_serial_port *port,\r\nunsigned char buf[7])\r\n{\r\nstruct usb_device *udev = port->serial->dev;\r\nint ret;\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nSET_LINE_REQUEST, SET_LINE_REQUEST_TYPE,\r\n0, 0, buf, 7, 100);\r\nif (ret < 0) {\r\ndev_err(&port->dev, "%s - failed: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\ndev_dbg(&port->dev, "%s - %7ph\n", __func__, buf);\r\nreturn 0;\r\n}\r\nstatic void pl2303_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct pl2303_serial_private *spriv = usb_get_serial_data(serial);\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nunsigned char *buf;\r\nint ret;\r\nu8 control;\r\nif (old_termios && !tty_termios_hw_change(&tty->termios, old_termios))\r\nreturn;\r\nbuf = kzalloc(7, GFP_KERNEL);\r\nif (!buf) {\r\nif (old_termios)\r\ntty->termios = *old_termios;\r\nreturn;\r\n}\r\npl2303_get_line_request(port, buf);\r\nswitch (C_CSIZE(tty)) {\r\ncase CS5:\r\nbuf[6] = 5;\r\nbreak;\r\ncase CS6:\r\nbuf[6] = 6;\r\nbreak;\r\ncase CS7:\r\nbuf[6] = 7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nbuf[6] = 8;\r\n}\r\ndev_dbg(&port->dev, "data bits = %d\n", buf[6]);\r\npl2303_encode_baud_rate(tty, port, &buf[0]);\r\nif (C_CSTOPB(tty)) {\r\nif (C_CSIZE(tty) == CS5) {\r\nbuf[4] = 1;\r\ndev_dbg(&port->dev, "stop bits = 1.5\n");\r\n} else {\r\nbuf[4] = 2;\r\ndev_dbg(&port->dev, "stop bits = 2\n");\r\n}\r\n} else {\r\nbuf[4] = 0;\r\ndev_dbg(&port->dev, "stop bits = 1\n");\r\n}\r\nif (C_PARENB(tty)) {\r\nif (C_PARODD(tty)) {\r\nif (C_CMSPAR(tty)) {\r\nbuf[5] = 3;\r\ndev_dbg(&port->dev, "parity = mark\n");\r\n} else {\r\nbuf[5] = 1;\r\ndev_dbg(&port->dev, "parity = odd\n");\r\n}\r\n} else {\r\nif (C_CMSPAR(tty)) {\r\nbuf[5] = 4;\r\ndev_dbg(&port->dev, "parity = space\n");\r\n} else {\r\nbuf[5] = 2;\r\ndev_dbg(&port->dev, "parity = even\n");\r\n}\r\n}\r\n} else {\r\nbuf[5] = 0;\r\ndev_dbg(&port->dev, "parity = none\n");\r\n}\r\nif (!old_termios || memcmp(buf, priv->line_settings, 7)) {\r\nret = pl2303_set_line_request(port, buf);\r\nif (!ret)\r\nmemcpy(priv->line_settings, buf, 7);\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncontrol = priv->line_control;\r\nif (C_BAUD(tty) == B0)\r\npriv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);\r\nelse if (old_termios && (old_termios->c_cflag & CBAUD) == B0)\r\npriv->line_control |= (CONTROL_DTR | CONTROL_RTS);\r\nif (control != priv->line_control) {\r\ncontrol = priv->line_control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\npl2303_set_control_lines(port, control);\r\n} else {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nif (C_CRTSCTS(tty)) {\r\nif (spriv->quirks & PL2303_QUIRK_LEGACY)\r\npl2303_vendor_write(serial, 0x0, 0x41);\r\nelse\r\npl2303_vendor_write(serial, 0x0, 0x61);\r\n} else {\r\npl2303_vendor_write(serial, 0x0, 0x0);\r\n}\r\nkfree(buf);\r\n}\r\nstatic void pl2303_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nu8 control;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (on)\r\npriv->line_control |= (CONTROL_DTR | CONTROL_RTS);\r\nelse\r\npriv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);\r\ncontrol = priv->line_control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\npl2303_set_control_lines(port, control);\r\n}\r\nstatic void pl2303_close(struct usb_serial_port *port)\r\n{\r\nusb_serial_generic_close(port);\r\nusb_kill_urb(port->interrupt_in_urb);\r\npl2303_set_break(port, false);\r\n}\r\nstatic int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct pl2303_serial_private *spriv = usb_get_serial_data(serial);\r\nint result;\r\nif (spriv->quirks & PL2303_QUIRK_LEGACY) {\r\nusb_clear_halt(serial->dev, port->write_urb->pipe);\r\nusb_clear_halt(serial->dev, port->read_urb->pipe);\r\n} else {\r\npl2303_vendor_write(serial, 8, 0);\r\npl2303_vendor_write(serial, 9, 0);\r\n}\r\nif (tty)\r\npl2303_set_termios(tty, port, NULL);\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (result) {\r\ndev_err(&port->dev, "failed to submit interrupt urb: %d\n",\r\nresult);\r\nreturn result;\r\n}\r\nresult = usb_serial_generic_open(tty, port);\r\nif (result) {\r\nusb_kill_urb(port->interrupt_in_urb);\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pl2303_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nu8 control;\r\nint ret;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (set & TIOCM_RTS)\r\npriv->line_control |= CONTROL_RTS;\r\nif (set & TIOCM_DTR)\r\npriv->line_control |= CONTROL_DTR;\r\nif (clear & TIOCM_RTS)\r\npriv->line_control &= ~CONTROL_RTS;\r\nif (clear & TIOCM_DTR)\r\npriv->line_control &= ~CONTROL_DTR;\r\ncontrol = priv->line_control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nret = pl2303_set_control_lines(port, control);\r\nif (ret)\r\nreturn usb_translate_errors(ret);\r\nreturn 0;\r\n}\r\nstatic int pl2303_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nunsigned int mcr;\r\nunsigned int status;\r\nunsigned int result;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nmcr = priv->line_control;\r\nstatus = priv->line_status;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nresult = ((mcr & CONTROL_DTR) ? TIOCM_DTR : 0)\r\n| ((mcr & CONTROL_RTS) ? TIOCM_RTS : 0)\r\n| ((status & UART_CTS) ? TIOCM_CTS : 0)\r\n| ((status & UART_DSR) ? TIOCM_DSR : 0)\r\n| ((status & UART_RING) ? TIOCM_RI : 0)\r\n| ((status & UART_DCD) ? TIOCM_CD : 0);\r\ndev_dbg(&port->dev, "%s - result = %x\n", __func__, result);\r\nreturn result;\r\n}\r\nstatic int pl2303_carrier_raised(struct usb_serial_port *port)\r\n{\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nif (priv->line_status & UART_DCD)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int pl2303_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct serial_struct ser;\r\nstruct usb_serial_port *port = tty->driver_data;\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nmemset(&ser, 0, sizeof ser);\r\nser.type = PORT_16654;\r\nser.line = port->minor;\r\nser.port = port->port_number;\r\nser.baud_base = 460800;\r\nif (copy_to_user((void __user *)arg, &ser, sizeof ser))\r\nreturn -EFAULT;\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void pl2303_set_break(struct usb_serial_port *port, bool enable)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nu16 state;\r\nint result;\r\nif (enable)\r\nstate = BREAK_ON;\r\nelse\r\nstate = BREAK_OFF;\r\ndev_dbg(&port->dev, "%s - turning break %s\n", __func__,\r\nstate == BREAK_OFF ? "off" : "on");\r\nresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nBREAK_REQUEST, BREAK_REQUEST_TYPE, state,\r\n0, NULL, 0, 100);\r\nif (result)\r\ndev_err(&port->dev, "error sending break = %d\n", result);\r\n}\r\nstatic void pl2303_break_ctl(struct tty_struct *tty, int state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\npl2303_set_break(port, state);\r\n}\r\nstatic void pl2303_update_line_status(struct usb_serial_port *port,\r\nunsigned char *data,\r\nunsigned int actual_length)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct pl2303_serial_private *spriv = usb_get_serial_data(serial);\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nstruct tty_struct *tty;\r\nunsigned long flags;\r\nunsigned int status_idx = UART_STATE_INDEX;\r\nu8 status;\r\nu8 delta;\r\nif (spriv->quirks & PL2303_QUIRK_UART_STATE_IDX0)\r\nstatus_idx = 0;\r\nif (actual_length < status_idx + 1)\r\nreturn;\r\nstatus = data[status_idx];\r\nspin_lock_irqsave(&priv->lock, flags);\r\ndelta = priv->line_status ^ status;\r\npriv->line_status = status;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (status & UART_BREAK_ERROR)\r\nusb_serial_handle_break(port);\r\nif (delta & UART_STATE_MSR_MASK) {\r\nif (delta & UART_CTS)\r\nport->icount.cts++;\r\nif (delta & UART_DSR)\r\nport->icount.dsr++;\r\nif (delta & UART_RING)\r\nport->icount.rng++;\r\nif (delta & UART_DCD) {\r\nport->icount.dcd++;\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty) {\r\nusb_serial_handle_dcd_change(port, tty,\r\nstatus & UART_DCD);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nwake_up_interruptible(&port->port.delta_msr_wait);\r\n}\r\n}\r\nstatic void pl2303_read_int_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nunsigned char *data = urb->transfer_buffer;\r\nunsigned int actual_length = urb->actual_length;\r\nint status = urb->status;\r\nint retval;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&port->dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&port->dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nusb_serial_debug_data(&port->dev, __func__,\r\nurb->actual_length, urb->transfer_buffer);\r\npl2303_update_line_status(port, data, actual_length);\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval) {\r\ndev_err(&port->dev,\r\n"%s - usb_submit_urb failed with result %d\n",\r\n__func__, retval);\r\n}\r\n}\r\nstatic void pl2303_process_read_urb(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nunsigned char *data = urb->transfer_buffer;\r\nchar tty_flag = TTY_NORMAL;\r\nunsigned long flags;\r\nu8 line_status;\r\nint i;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nline_status = priv->line_status;\r\npriv->line_status &= ~UART_STATE_TRANSIENT_MASK;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (!urb->actual_length)\r\nreturn;\r\nif (line_status & UART_BREAK_ERROR)\r\ntty_flag = TTY_BREAK;\r\nelse if (line_status & UART_PARITY_ERROR)\r\ntty_flag = TTY_PARITY;\r\nelse if (line_status & UART_FRAME_ERROR)\r\ntty_flag = TTY_FRAME;\r\nif (tty_flag != TTY_NORMAL)\r\ndev_dbg(&port->dev, "%s - tty_flag = %d\n", __func__,\r\ntty_flag);\r\nif (line_status & UART_OVERRUN_ERROR)\r\ntty_insert_flip_char(&port->port, 0, TTY_OVERRUN);\r\nif (port->port.console && port->sysrq) {\r\nfor (i = 0; i < urb->actual_length; ++i)\r\nif (!usb_serial_handle_sysrq_char(port, data[i]))\r\ntty_insert_flip_char(&port->port, data[i],\r\ntty_flag);\r\n} else {\r\ntty_insert_flip_string_fixed_flag(&port->port, data, tty_flag,\r\nurb->actual_length);\r\n}\r\ntty_flip_buffer_push(&port->port);\r\n}
