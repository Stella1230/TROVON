static void\r\nvc4_overflow_mem_work(struct work_struct *work)\r\n{\r\nstruct vc4_dev *vc4 =\r\ncontainer_of(work, struct vc4_dev, overflow_mem_work);\r\nstruct vc4_bo *bo = vc4->bin_bo;\r\nint bin_bo_slot;\r\nstruct vc4_exec_info *exec;\r\nunsigned long irqflags;\r\nbin_bo_slot = vc4_v3d_get_bin_slot(vc4);\r\nif (bin_bo_slot < 0) {\r\nDRM_ERROR("Couldn't allocate binner overflow mem\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&vc4->job_lock, irqflags);\r\nif (vc4->bin_alloc_overflow) {\r\nexec = vc4_first_bin_job(vc4);\r\nif (!exec)\r\nexec = vc4_last_render_job(vc4);\r\nif (exec) {\r\nexec->bin_slots |= vc4->bin_alloc_overflow;\r\n} else {\r\nvc4->bin_alloc_used &= ~vc4->bin_alloc_overflow;\r\n}\r\n}\r\nvc4->bin_alloc_overflow = BIT(bin_bo_slot);\r\nV3D_WRITE(V3D_BPOA, bo->base.paddr + bin_bo_slot * vc4->bin_alloc_size);\r\nV3D_WRITE(V3D_BPOS, bo->base.base.size);\r\nV3D_WRITE(V3D_INTCTL, V3D_INT_OUTOMEM);\r\nV3D_WRITE(V3D_INTENA, V3D_INT_OUTOMEM);\r\nspin_unlock_irqrestore(&vc4->job_lock, irqflags);\r\n}\r\nstatic void\r\nvc4_irq_finish_bin_job(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nstruct vc4_exec_info *exec = vc4_first_bin_job(vc4);\r\nif (!exec)\r\nreturn;\r\nvc4_move_job_to_render(dev, exec);\r\nvc4_submit_next_bin_job(dev);\r\n}\r\nstatic void\r\nvc4_cancel_bin_job(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nstruct vc4_exec_info *exec = vc4_first_bin_job(vc4);\r\nif (!exec)\r\nreturn;\r\nlist_move_tail(&exec->head, &vc4->bin_job_list);\r\nvc4_submit_next_bin_job(dev);\r\n}\r\nstatic void\r\nvc4_irq_finish_render_job(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nstruct vc4_exec_info *exec = vc4_first_render_job(vc4);\r\nif (!exec)\r\nreturn;\r\nvc4->finished_seqno++;\r\nlist_move_tail(&exec->head, &vc4->job_done_list);\r\nif (exec->fence) {\r\ndma_fence_signal_locked(exec->fence);\r\nexec->fence = NULL;\r\n}\r\nvc4_submit_next_render_job(dev);\r\nwake_up_all(&vc4->job_wait_queue);\r\nschedule_work(&vc4->job_done_work);\r\n}\r\nirqreturn_t\r\nvc4_irq(int irq, void *arg)\r\n{\r\nstruct drm_device *dev = arg;\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nuint32_t intctl;\r\nirqreturn_t status = IRQ_NONE;\r\nbarrier();\r\nintctl = V3D_READ(V3D_INTCTL);\r\nV3D_WRITE(V3D_INTCTL, intctl);\r\nif (intctl & V3D_INT_OUTOMEM) {\r\nV3D_WRITE(V3D_INTDIS, V3D_INT_OUTOMEM);\r\nschedule_work(&vc4->overflow_mem_work);\r\nstatus = IRQ_HANDLED;\r\n}\r\nif (intctl & V3D_INT_FLDONE) {\r\nspin_lock(&vc4->job_lock);\r\nvc4_irq_finish_bin_job(dev);\r\nspin_unlock(&vc4->job_lock);\r\nstatus = IRQ_HANDLED;\r\n}\r\nif (intctl & V3D_INT_FRDONE) {\r\nspin_lock(&vc4->job_lock);\r\nvc4_irq_finish_render_job(dev);\r\nspin_unlock(&vc4->job_lock);\r\nstatus = IRQ_HANDLED;\r\n}\r\nreturn status;\r\n}\r\nvoid\r\nvc4_irq_preinstall(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\ninit_waitqueue_head(&vc4->job_wait_queue);\r\nINIT_WORK(&vc4->overflow_mem_work, vc4_overflow_mem_work);\r\nV3D_WRITE(V3D_INTCTL, V3D_DRIVER_IRQS);\r\n}\r\nint\r\nvc4_irq_postinstall(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nV3D_WRITE(V3D_INTENA, V3D_DRIVER_IRQS);\r\nreturn 0;\r\n}\r\nvoid\r\nvc4_irq_uninstall(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nV3D_WRITE(V3D_INTDIS, V3D_DRIVER_IRQS);\r\nV3D_WRITE(V3D_INTCTL, V3D_DRIVER_IRQS);\r\ncancel_work_sync(&vc4->overflow_mem_work);\r\n}\r\nvoid vc4_irq_reset(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nunsigned long irqflags;\r\nV3D_WRITE(V3D_INTCTL, V3D_DRIVER_IRQS);\r\nV3D_WRITE(V3D_INTENA, V3D_DRIVER_IRQS);\r\nspin_lock_irqsave(&vc4->job_lock, irqflags);\r\nvc4_cancel_bin_job(dev);\r\nvc4_irq_finish_render_job(dev);\r\nspin_unlock_irqrestore(&vc4->job_lock, irqflags);\r\n}
