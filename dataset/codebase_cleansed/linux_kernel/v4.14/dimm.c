static int nvdimm_probe(struct device *dev)\r\n{\r\nstruct nvdimm_drvdata *ndd;\r\nint rc;\r\nrc = nvdimm_check_config_data(dev);\r\nif (rc) {\r\nif (rc == -ENOTTY)\r\nrc = 0;\r\nreturn rc;\r\n}\r\nndd = kzalloc(sizeof(*ndd), GFP_KERNEL);\r\nif (!ndd)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, ndd);\r\nndd->dpa.name = dev_name(dev);\r\nndd->ns_current = -1;\r\nndd->ns_next = -1;\r\nndd->dpa.start = 0;\r\nndd->dpa.end = -1;\r\nndd->dev = dev;\r\nget_device(dev);\r\nkref_init(&ndd->kref);\r\nrc = nvdimm_init_nsarea(ndd);\r\nif (rc == -EACCES)\r\nnvdimm_set_locked(dev);\r\nif (rc)\r\ngoto err;\r\nrc = nvdimm_init_config_data(ndd);\r\nif (rc)\r\ngoto err;\r\ndev_dbg(dev, "config data size: %d\n", ndd->nsarea.config_size);\r\nnvdimm_bus_lock(dev);\r\nndd->ns_current = nd_label_validate(ndd);\r\nndd->ns_next = nd_label_next_nsindex(ndd->ns_current);\r\nnd_label_copy(ndd, to_next_namespace_index(ndd),\r\nto_current_namespace_index(ndd));\r\nrc = nd_label_reserve_dpa(ndd);\r\nif (ndd->ns_current >= 0)\r\nnvdimm_set_aliasing(dev);\r\nnvdimm_bus_unlock(dev);\r\nif (rc)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nput_ndd(ndd);\r\nreturn rc;\r\n}\r\nstatic int nvdimm_remove(struct device *dev)\r\n{\r\nstruct nvdimm_drvdata *ndd = dev_get_drvdata(dev);\r\nif (!ndd)\r\nreturn 0;\r\nnvdimm_bus_lock(dev);\r\ndev_set_drvdata(dev, NULL);\r\nnvdimm_bus_unlock(dev);\r\nput_ndd(ndd);\r\nreturn 0;\r\n}\r\nint __init nvdimm_init(void)\r\n{\r\nreturn nd_driver_register(&nvdimm_driver);\r\n}\r\nvoid nvdimm_exit(void)\r\n{\r\ndriver_unregister(&nvdimm_driver.drv);\r\n}
