static int get_current_cpu(void)\r\n{\r\n#if defined(CONFIG_KVM) && defined(CONFIG_BOOKE)\r\nstruct kvm_vcpu *vcpu = current->thread.kvm_vcpu;\r\nreturn vcpu ? vcpu->arch.irq_cpu_id : -1;\r\n#else\r\nreturn -1;\r\n#endif\r\n}\r\nstatic void mpic_irq_raise(struct openpic *opp, struct irq_dest *dst,\r\nint output)\r\n{\r\nstruct kvm_interrupt irq = {\r\n.irq = KVM_INTERRUPT_SET_LEVEL,\r\n};\r\nif (!dst->vcpu) {\r\npr_debug("%s: destination cpu %d does not exist\n",\r\n__func__, (int)(dst - &opp->dst[0]));\r\nreturn;\r\n}\r\npr_debug("%s: cpu %d output %d\n", __func__, dst->vcpu->arch.irq_cpu_id,\r\noutput);\r\nif (output != ILR_INTTGT_INT)\r\nreturn;\r\nkvm_vcpu_ioctl_interrupt(dst->vcpu, &irq);\r\n}\r\nstatic void mpic_irq_lower(struct openpic *opp, struct irq_dest *dst,\r\nint output)\r\n{\r\nif (!dst->vcpu) {\r\npr_debug("%s: destination cpu %d does not exist\n",\r\n__func__, (int)(dst - &opp->dst[0]));\r\nreturn;\r\n}\r\npr_debug("%s: cpu %d output %d\n", __func__, dst->vcpu->arch.irq_cpu_id,\r\noutput);\r\nif (output != ILR_INTTGT_INT)\r\nreturn;\r\nkvmppc_core_dequeue_external(dst->vcpu);\r\n}\r\nstatic inline void IRQ_setbit(struct irq_queue *q, int n_IRQ)\r\n{\r\nset_bit(n_IRQ, q->queue);\r\n}\r\nstatic inline void IRQ_resetbit(struct irq_queue *q, int n_IRQ)\r\n{\r\nclear_bit(n_IRQ, q->queue);\r\n}\r\nstatic void IRQ_check(struct openpic *opp, struct irq_queue *q)\r\n{\r\nint irq = -1;\r\nint next = -1;\r\nint priority = -1;\r\nfor (;;) {\r\nirq = find_next_bit(q->queue, opp->max_irq, irq + 1);\r\nif (irq == opp->max_irq)\r\nbreak;\r\npr_debug("IRQ_check: irq %d set ivpr_pr=%d pr=%d\n",\r\nirq, IVPR_PRIORITY(opp->src[irq].ivpr), priority);\r\nif (IVPR_PRIORITY(opp->src[irq].ivpr) > priority) {\r\nnext = irq;\r\npriority = IVPR_PRIORITY(opp->src[irq].ivpr);\r\n}\r\n}\r\nq->next = next;\r\nq->priority = priority;\r\n}\r\nstatic int IRQ_get_next(struct openpic *opp, struct irq_queue *q)\r\n{\r\nIRQ_check(opp, q);\r\nreturn q->next;\r\n}\r\nstatic void IRQ_local_pipe(struct openpic *opp, int n_CPU, int n_IRQ,\r\nbool active, bool was_active)\r\n{\r\nstruct irq_dest *dst;\r\nstruct irq_source *src;\r\nint priority;\r\ndst = &opp->dst[n_CPU];\r\nsrc = &opp->src[n_IRQ];\r\npr_debug("%s: IRQ %d active %d was %d\n",\r\n__func__, n_IRQ, active, was_active);\r\nif (src->output != ILR_INTTGT_INT) {\r\npr_debug("%s: output %d irq %d active %d was %d count %d\n",\r\n__func__, src->output, n_IRQ, active, was_active,\r\ndst->outputs_active[src->output]);\r\nif (active) {\r\nif (!was_active &&\r\ndst->outputs_active[src->output]++ == 0) {\r\npr_debug("%s: Raise OpenPIC output %d cpu %d irq %d\n",\r\n__func__, src->output, n_CPU, n_IRQ);\r\nmpic_irq_raise(opp, dst, src->output);\r\n}\r\n} else {\r\nif (was_active &&\r\n--dst->outputs_active[src->output] == 0) {\r\npr_debug("%s: Lower OpenPIC output %d cpu %d irq %d\n",\r\n__func__, src->output, n_CPU, n_IRQ);\r\nmpic_irq_lower(opp, dst, src->output);\r\n}\r\n}\r\nreturn;\r\n}\r\npriority = IVPR_PRIORITY(src->ivpr);\r\nif (active)\r\nIRQ_setbit(&dst->raised, n_IRQ);\r\nelse\r\nIRQ_resetbit(&dst->raised, n_IRQ);\r\nIRQ_check(opp, &dst->raised);\r\nif (active && priority <= dst->ctpr) {\r\npr_debug("%s: IRQ %d priority %d too low for ctpr %d on CPU %d\n",\r\n__func__, n_IRQ, priority, dst->ctpr, n_CPU);\r\nactive = 0;\r\n}\r\nif (active) {\r\nif (IRQ_get_next(opp, &dst->servicing) >= 0 &&\r\npriority <= dst->servicing.priority) {\r\npr_debug("%s: IRQ %d is hidden by servicing IRQ %d on CPU %d\n",\r\n__func__, n_IRQ, dst->servicing.next, n_CPU);\r\n} else {\r\npr_debug("%s: Raise OpenPIC INT output cpu %d irq %d/%d\n",\r\n__func__, n_CPU, n_IRQ, dst->raised.next);\r\nmpic_irq_raise(opp, dst, ILR_INTTGT_INT);\r\n}\r\n} else {\r\nIRQ_get_next(opp, &dst->servicing);\r\nif (dst->raised.priority > dst->ctpr &&\r\ndst->raised.priority > dst->servicing.priority) {\r\npr_debug("%s: IRQ %d inactive, IRQ %d prio %d above %d/%d, CPU %d\n",\r\n__func__, n_IRQ, dst->raised.next,\r\ndst->raised.priority, dst->ctpr,\r\ndst->servicing.priority, n_CPU);\r\n} else {\r\npr_debug("%s: IRQ %d inactive, current prio %d/%d, CPU %d\n",\r\n__func__, n_IRQ, dst->ctpr,\r\ndst->servicing.priority, n_CPU);\r\nmpic_irq_lower(opp, dst, ILR_INTTGT_INT);\r\n}\r\n}\r\n}\r\nstatic void openpic_update_irq(struct openpic *opp, int n_IRQ)\r\n{\r\nstruct irq_source *src;\r\nbool active, was_active;\r\nint i;\r\nsrc = &opp->src[n_IRQ];\r\nactive = src->pending;\r\nif ((src->ivpr & IVPR_MASK_MASK) && !src->nomask) {\r\npr_debug("%s: IRQ %d is disabled\n", __func__, n_IRQ);\r\nactive = false;\r\n}\r\nwas_active = !!(src->ivpr & IVPR_ACTIVITY_MASK);\r\nif (!active && !was_active) {\r\npr_debug("%s: IRQ %d is already inactive\n", __func__, n_IRQ);\r\nreturn;\r\n}\r\nif (active)\r\nsrc->ivpr |= IVPR_ACTIVITY_MASK;\r\nelse\r\nsrc->ivpr &= ~IVPR_ACTIVITY_MASK;\r\nif (src->destmask == 0) {\r\npr_debug("%s: IRQ %d has no target\n", __func__, n_IRQ);\r\nreturn;\r\n}\r\nif (src->destmask == (1 << src->last_cpu)) {\r\nIRQ_local_pipe(opp, src->last_cpu, n_IRQ, active, was_active);\r\n} else if (!(src->ivpr & IVPR_MODE_MASK)) {\r\nfor (i = 0; i < opp->nb_cpus; i++) {\r\nif (src->destmask & (1 << i)) {\r\nIRQ_local_pipe(opp, i, n_IRQ, active,\r\nwas_active);\r\n}\r\n}\r\n} else {\r\nfor (i = src->last_cpu + 1; i != src->last_cpu; i++) {\r\nif (i == opp->nb_cpus)\r\ni = 0;\r\nif (src->destmask & (1 << i)) {\r\nIRQ_local_pipe(opp, i, n_IRQ, active,\r\nwas_active);\r\nsrc->last_cpu = i;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void openpic_set_irq(void *opaque, int n_IRQ, int level)\r\n{\r\nstruct openpic *opp = opaque;\r\nstruct irq_source *src;\r\nif (n_IRQ >= MAX_IRQ) {\r\nWARN_ONCE(1, "%s: IRQ %d out of range\n", __func__, n_IRQ);\r\nreturn;\r\n}\r\nsrc = &opp->src[n_IRQ];\r\npr_debug("openpic: set irq %d = %d ivpr=0x%08x\n",\r\nn_IRQ, level, src->ivpr);\r\nif (src->level) {\r\nsrc->pending = level;\r\nopenpic_update_irq(opp, n_IRQ);\r\n} else {\r\nif (level) {\r\nsrc->pending = 1;\r\nopenpic_update_irq(opp, n_IRQ);\r\n}\r\nif (src->output != ILR_INTTGT_INT) {\r\nsrc->pending = 0;\r\nopenpic_update_irq(opp, n_IRQ);\r\n}\r\n}\r\n}\r\nstatic void openpic_reset(struct openpic *opp)\r\n{\r\nint i;\r\nopp->gcr = GCR_RESET;\r\nopp->frr = ((opp->nb_irqs - 1) << FRR_NIRQ_SHIFT) |\r\n(opp->vid << FRR_VID_SHIFT);\r\nopp->pir = 0;\r\nopp->spve = -1 & opp->vector_mask;\r\nopp->tfrr = opp->tfrr_reset;\r\nfor (i = 0; i < opp->max_irq; i++) {\r\nopp->src[i].ivpr = opp->ivpr_reset;\r\nswitch (opp->src[i].type) {\r\ncase IRQ_TYPE_NORMAL:\r\nopp->src[i].level =\r\n!!(opp->ivpr_reset & IVPR_SENSE_MASK);\r\nbreak;\r\ncase IRQ_TYPE_FSLINT:\r\nopp->src[i].ivpr |= IVPR_POLARITY_MASK;\r\nbreak;\r\ncase IRQ_TYPE_FSLSPECIAL:\r\nbreak;\r\n}\r\nwrite_IRQreg_idr(opp, i, opp->idr_reset);\r\n}\r\nfor (i = 0; i < MAX_CPU; i++) {\r\nopp->dst[i].ctpr = 15;\r\nmemset(&opp->dst[i].raised, 0, sizeof(struct irq_queue));\r\nopp->dst[i].raised.next = -1;\r\nmemset(&opp->dst[i].servicing, 0, sizeof(struct irq_queue));\r\nopp->dst[i].servicing.next = -1;\r\n}\r\nfor (i = 0; i < MAX_TMR; i++) {\r\nopp->timers[i].tccr = 0;\r\nopp->timers[i].tbcr = TBCR_CI;\r\n}\r\nopp->gcr = 0;\r\n}\r\nstatic inline uint32_t read_IRQreg_idr(struct openpic *opp, int n_IRQ)\r\n{\r\nreturn opp->src[n_IRQ].idr;\r\n}\r\nstatic inline uint32_t read_IRQreg_ilr(struct openpic *opp, int n_IRQ)\r\n{\r\nif (opp->flags & OPENPIC_FLAG_ILR)\r\nreturn opp->src[n_IRQ].output;\r\nreturn 0xffffffff;\r\n}\r\nstatic inline uint32_t read_IRQreg_ivpr(struct openpic *opp, int n_IRQ)\r\n{\r\nreturn opp->src[n_IRQ].ivpr;\r\n}\r\nstatic inline void write_IRQreg_idr(struct openpic *opp, int n_IRQ,\r\nuint32_t val)\r\n{\r\nstruct irq_source *src = &opp->src[n_IRQ];\r\nuint32_t normal_mask = (1UL << opp->nb_cpus) - 1;\r\nuint32_t crit_mask = 0;\r\nuint32_t mask = normal_mask;\r\nint crit_shift = IDR_EP_SHIFT - opp->nb_cpus;\r\nint i;\r\nif (opp->flags & OPENPIC_FLAG_IDR_CRIT) {\r\ncrit_mask = mask << crit_shift;\r\nmask |= crit_mask | IDR_EP;\r\n}\r\nsrc->idr = val & mask;\r\npr_debug("Set IDR %d to 0x%08x\n", n_IRQ, src->idr);\r\nif (opp->flags & OPENPIC_FLAG_IDR_CRIT) {\r\nif (src->idr & crit_mask) {\r\nif (src->idr & normal_mask) {\r\npr_debug("%s: IRQ configured for multiple output types, using critical\n",\r\n__func__);\r\n}\r\nsrc->output = ILR_INTTGT_CINT;\r\nsrc->nomask = true;\r\nsrc->destmask = 0;\r\nfor (i = 0; i < opp->nb_cpus; i++) {\r\nint n_ci = IDR_CI0_SHIFT - i;\r\nif (src->idr & (1UL << n_ci))\r\nsrc->destmask |= 1UL << i;\r\n}\r\n} else {\r\nsrc->output = ILR_INTTGT_INT;\r\nsrc->nomask = false;\r\nsrc->destmask = src->idr & normal_mask;\r\n}\r\n} else {\r\nsrc->destmask = src->idr;\r\n}\r\n}\r\nstatic inline void write_IRQreg_ilr(struct openpic *opp, int n_IRQ,\r\nuint32_t val)\r\n{\r\nif (opp->flags & OPENPIC_FLAG_ILR) {\r\nstruct irq_source *src = &opp->src[n_IRQ];\r\nsrc->output = val & ILR_INTTGT_MASK;\r\npr_debug("Set ILR %d to 0x%08x, output %d\n", n_IRQ, src->idr,\r\nsrc->output);\r\n}\r\n}\r\nstatic inline void write_IRQreg_ivpr(struct openpic *opp, int n_IRQ,\r\nuint32_t val)\r\n{\r\nuint32_t mask;\r\nmask = IVPR_MASK_MASK | IVPR_PRIORITY_MASK | IVPR_SENSE_MASK |\r\nIVPR_POLARITY_MASK | opp->vector_mask;\r\nopp->src[n_IRQ].ivpr =\r\n(opp->src[n_IRQ].ivpr & IVPR_ACTIVITY_MASK) | (val & mask);\r\nswitch (opp->src[n_IRQ].type) {\r\ncase IRQ_TYPE_NORMAL:\r\nopp->src[n_IRQ].level =\r\n!!(opp->src[n_IRQ].ivpr & IVPR_SENSE_MASK);\r\nbreak;\r\ncase IRQ_TYPE_FSLINT:\r\nopp->src[n_IRQ].ivpr &= ~IVPR_SENSE_MASK;\r\nbreak;\r\ncase IRQ_TYPE_FSLSPECIAL:\r\nopp->src[n_IRQ].ivpr &= ~(IVPR_POLARITY_MASK | IVPR_SENSE_MASK);\r\nbreak;\r\n}\r\nopenpic_update_irq(opp, n_IRQ);\r\npr_debug("Set IVPR %d to 0x%08x -> 0x%08x\n", n_IRQ, val,\r\nopp->src[n_IRQ].ivpr);\r\n}\r\nstatic void openpic_gcr_write(struct openpic *opp, uint64_t val)\r\n{\r\nif (val & GCR_RESET) {\r\nopenpic_reset(opp);\r\nreturn;\r\n}\r\nopp->gcr &= ~opp->mpic_mode_mask;\r\nopp->gcr |= val & opp->mpic_mode_mask;\r\n}\r\nstatic int openpic_gbl_write(void *opaque, gpa_t addr, u32 val)\r\n{\r\nstruct openpic *opp = opaque;\r\nint err = 0;\r\npr_debug("%s: addr %#llx <= %08x\n", __func__, addr, val);\r\nif (addr & 0xF)\r\nreturn 0;\r\nswitch (addr) {\r\ncase 0x00:\r\nbreak;\r\ncase 0x40:\r\ncase 0x50:\r\ncase 0x60:\r\ncase 0x70:\r\ncase 0x80:\r\ncase 0x90:\r\ncase 0xA0:\r\ncase 0xB0:\r\nerr = openpic_cpu_write_internal(opp, addr, val,\r\nget_current_cpu());\r\nbreak;\r\ncase 0x1000:\r\nbreak;\r\ncase 0x1020:\r\nopenpic_gcr_write(opp, val);\r\nbreak;\r\ncase 0x1080:\r\nbreak;\r\ncase 0x1090:\r\nerr = -ENXIO;\r\nbreak;\r\ncase 0x10A0:\r\ncase 0x10B0:\r\ncase 0x10C0:\r\ncase 0x10D0: {\r\nint idx;\r\nidx = (addr - 0x10A0) >> 4;\r\nwrite_IRQreg_ivpr(opp, opp->irq_ipi0 + idx, val);\r\nbreak;\r\n}\r\ncase 0x10E0:\r\nopp->spve = val & opp->vector_mask;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int openpic_gbl_read(void *opaque, gpa_t addr, u32 *ptr)\r\n{\r\nstruct openpic *opp = opaque;\r\nu32 retval;\r\nint err = 0;\r\npr_debug("%s: addr %#llx\n", __func__, addr);\r\nretval = 0xFFFFFFFF;\r\nif (addr & 0xF)\r\ngoto out;\r\nswitch (addr) {\r\ncase 0x1000:\r\nretval = opp->frr;\r\nretval |= (opp->nb_cpus - 1) << FRR_NCPU_SHIFT;\r\nbreak;\r\ncase 0x1020:\r\nretval = opp->gcr;\r\nbreak;\r\ncase 0x1080:\r\nretval = opp->vir;\r\nbreak;\r\ncase 0x1090:\r\nretval = 0x00000000;\r\nbreak;\r\ncase 0x00:\r\nretval = opp->brr1;\r\nbreak;\r\ncase 0x40:\r\ncase 0x50:\r\ncase 0x60:\r\ncase 0x70:\r\ncase 0x80:\r\ncase 0x90:\r\ncase 0xA0:\r\ncase 0xB0:\r\nerr = openpic_cpu_read_internal(opp, addr,\r\n&retval, get_current_cpu());\r\nbreak;\r\ncase 0x10A0:\r\ncase 0x10B0:\r\ncase 0x10C0:\r\ncase 0x10D0:\r\n{\r\nint idx;\r\nidx = (addr - 0x10A0) >> 4;\r\nretval = read_IRQreg_ivpr(opp, opp->irq_ipi0 + idx);\r\n}\r\nbreak;\r\ncase 0x10E0:\r\nretval = opp->spve;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\npr_debug("%s: => 0x%08x\n", __func__, retval);\r\n*ptr = retval;\r\nreturn err;\r\n}\r\nstatic int openpic_tmr_write(void *opaque, gpa_t addr, u32 val)\r\n{\r\nstruct openpic *opp = opaque;\r\nint idx;\r\naddr += 0x10f0;\r\npr_debug("%s: addr %#llx <= %08x\n", __func__, addr, val);\r\nif (addr & 0xF)\r\nreturn 0;\r\nif (addr == 0x10f0) {\r\nopp->tfrr = val;\r\nreturn 0;\r\n}\r\nidx = (addr >> 6) & 0x3;\r\naddr = addr & 0x30;\r\nswitch (addr & 0x30) {\r\ncase 0x00:\r\nbreak;\r\ncase 0x10:\r\nif ((opp->timers[idx].tccr & TCCR_TOG) != 0 &&\r\n(val & TBCR_CI) == 0 &&\r\n(opp->timers[idx].tbcr & TBCR_CI) != 0)\r\nopp->timers[idx].tccr &= ~TCCR_TOG;\r\nopp->timers[idx].tbcr = val;\r\nbreak;\r\ncase 0x20:\r\nwrite_IRQreg_ivpr(opp, opp->irq_tim0 + idx, val);\r\nbreak;\r\ncase 0x30:\r\nwrite_IRQreg_idr(opp, opp->irq_tim0 + idx, val);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int openpic_tmr_read(void *opaque, gpa_t addr, u32 *ptr)\r\n{\r\nstruct openpic *opp = opaque;\r\nuint32_t retval = -1;\r\nint idx;\r\npr_debug("%s: addr %#llx\n", __func__, addr);\r\nif (addr & 0xF)\r\ngoto out;\r\nidx = (addr >> 6) & 0x3;\r\nif (addr == 0x0) {\r\nretval = opp->tfrr;\r\ngoto out;\r\n}\r\nswitch (addr & 0x30) {\r\ncase 0x00:\r\nretval = opp->timers[idx].tccr;\r\nbreak;\r\ncase 0x10:\r\nretval = opp->timers[idx].tbcr;\r\nbreak;\r\ncase 0x20:\r\nretval = read_IRQreg_ivpr(opp, opp->irq_tim0 + idx);\r\nbreak;\r\ncase 0x30:\r\nretval = read_IRQreg_idr(opp, opp->irq_tim0 + idx);\r\nbreak;\r\n}\r\nout:\r\npr_debug("%s: => 0x%08x\n", __func__, retval);\r\n*ptr = retval;\r\nreturn 0;\r\n}\r\nstatic int openpic_src_write(void *opaque, gpa_t addr, u32 val)\r\n{\r\nstruct openpic *opp = opaque;\r\nint idx;\r\npr_debug("%s: addr %#llx <= %08x\n", __func__, addr, val);\r\naddr = addr & 0xffff;\r\nidx = addr >> 5;\r\nswitch (addr & 0x1f) {\r\ncase 0x00:\r\nwrite_IRQreg_ivpr(opp, idx, val);\r\nbreak;\r\ncase 0x10:\r\nwrite_IRQreg_idr(opp, idx, val);\r\nbreak;\r\ncase 0x18:\r\nwrite_IRQreg_ilr(opp, idx, val);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int openpic_src_read(void *opaque, gpa_t addr, u32 *ptr)\r\n{\r\nstruct openpic *opp = opaque;\r\nuint32_t retval;\r\nint idx;\r\npr_debug("%s: addr %#llx\n", __func__, addr);\r\nretval = 0xFFFFFFFF;\r\naddr = addr & 0xffff;\r\nidx = addr >> 5;\r\nswitch (addr & 0x1f) {\r\ncase 0x00:\r\nretval = read_IRQreg_ivpr(opp, idx);\r\nbreak;\r\ncase 0x10:\r\nretval = read_IRQreg_idr(opp, idx);\r\nbreak;\r\ncase 0x18:\r\nretval = read_IRQreg_ilr(opp, idx);\r\nbreak;\r\n}\r\npr_debug("%s: => 0x%08x\n", __func__, retval);\r\n*ptr = retval;\r\nreturn 0;\r\n}\r\nstatic int openpic_msi_write(void *opaque, gpa_t addr, u32 val)\r\n{\r\nstruct openpic *opp = opaque;\r\nint idx = opp->irq_msi;\r\nint srs, ibs;\r\npr_debug("%s: addr %#llx <= 0x%08x\n", __func__, addr, val);\r\nif (addr & 0xF)\r\nreturn 0;\r\nswitch (addr) {\r\ncase MSIIR_OFFSET:\r\nsrs = val >> MSIIR_SRS_SHIFT;\r\nidx += srs;\r\nibs = (val & MSIIR_IBS_MASK) >> MSIIR_IBS_SHIFT;\r\nopp->msi[srs].msir |= 1 << ibs;\r\nopenpic_set_irq(opp, idx, 1);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int openpic_msi_read(void *opaque, gpa_t addr, u32 *ptr)\r\n{\r\nstruct openpic *opp = opaque;\r\nuint32_t r = 0;\r\nint i, srs;\r\npr_debug("%s: addr %#llx\n", __func__, addr);\r\nif (addr & 0xF)\r\nreturn -ENXIO;\r\nsrs = addr >> 4;\r\nswitch (addr) {\r\ncase 0x00:\r\ncase 0x10:\r\ncase 0x20:\r\ncase 0x30:\r\ncase 0x40:\r\ncase 0x50:\r\ncase 0x60:\r\ncase 0x70:\r\nr = opp->msi[srs].msir;\r\nopp->msi[srs].msir = 0;\r\nopenpic_set_irq(opp, opp->irq_msi + srs, 0);\r\nbreak;\r\ncase 0x120:\r\nfor (i = 0; i < MAX_MSI; i++)\r\nr |= (opp->msi[i].msir ? 1 : 0) << i;\r\nbreak;\r\n}\r\npr_debug("%s: => 0x%08x\n", __func__, r);\r\n*ptr = r;\r\nreturn 0;\r\n}\r\nstatic int openpic_summary_read(void *opaque, gpa_t addr, u32 *ptr)\r\n{\r\nuint32_t r = 0;\r\npr_debug("%s: addr %#llx\n", __func__, addr);\r\n*ptr = r;\r\nreturn 0;\r\n}\r\nstatic int openpic_summary_write(void *opaque, gpa_t addr, u32 val)\r\n{\r\npr_debug("%s: addr %#llx <= 0x%08x\n", __func__, addr, val);\r\nreturn 0;\r\n}\r\nstatic int openpic_cpu_write_internal(void *opaque, gpa_t addr,\r\nu32 val, int idx)\r\n{\r\nstruct openpic *opp = opaque;\r\nstruct irq_source *src;\r\nstruct irq_dest *dst;\r\nint s_IRQ, n_IRQ;\r\npr_debug("%s: cpu %d addr %#llx <= 0x%08x\n", __func__, idx,\r\naddr, val);\r\nif (idx < 0)\r\nreturn 0;\r\nif (addr & 0xF)\r\nreturn 0;\r\ndst = &opp->dst[idx];\r\naddr &= 0xFF0;\r\nswitch (addr) {\r\ncase 0x40:\r\ncase 0x50:\r\ncase 0x60:\r\ncase 0x70:\r\nidx = (addr - 0x40) >> 4;\r\nopp->src[opp->irq_ipi0 + idx].destmask |= val;\r\nopenpic_set_irq(opp, opp->irq_ipi0 + idx, 1);\r\nopenpic_set_irq(opp, opp->irq_ipi0 + idx, 0);\r\nbreak;\r\ncase 0x80:\r\ndst->ctpr = val & 0x0000000F;\r\npr_debug("%s: set CPU %d ctpr to %d, raised %d servicing %d\n",\r\n__func__, idx, dst->ctpr, dst->raised.priority,\r\ndst->servicing.priority);\r\nif (dst->raised.priority <= dst->ctpr) {\r\npr_debug("%s: Lower OpenPIC INT output cpu %d due to ctpr\n",\r\n__func__, idx);\r\nmpic_irq_lower(opp, dst, ILR_INTTGT_INT);\r\n} else if (dst->raised.priority > dst->servicing.priority) {\r\npr_debug("%s: Raise OpenPIC INT output cpu %d irq %d\n",\r\n__func__, idx, dst->raised.next);\r\nmpic_irq_raise(opp, dst, ILR_INTTGT_INT);\r\n}\r\nbreak;\r\ncase 0x90:\r\nbreak;\r\ncase 0xA0:\r\nbreak;\r\ncase 0xB0: {\r\nint notify_eoi;\r\npr_debug("EOI\n");\r\ns_IRQ = IRQ_get_next(opp, &dst->servicing);\r\nif (s_IRQ < 0) {\r\npr_debug("%s: EOI with no interrupt in service\n",\r\n__func__);\r\nbreak;\r\n}\r\nIRQ_resetbit(&dst->servicing, s_IRQ);\r\nnotify_eoi = s_IRQ;\r\ns_IRQ = IRQ_get_next(opp, &dst->servicing);\r\nn_IRQ = IRQ_get_next(opp, &dst->raised);\r\nsrc = &opp->src[n_IRQ];\r\nif (n_IRQ != -1 &&\r\n(s_IRQ == -1 ||\r\nIVPR_PRIORITY(src->ivpr) > dst->servicing.priority)) {\r\npr_debug("Raise OpenPIC INT output cpu %d irq %d\n",\r\nidx, n_IRQ);\r\nmpic_irq_raise(opp, dst, ILR_INTTGT_INT);\r\n}\r\nspin_unlock(&opp->lock);\r\nkvm_notify_acked_irq(opp->kvm, 0, notify_eoi);\r\nspin_lock(&opp->lock);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int openpic_cpu_write(void *opaque, gpa_t addr, u32 val)\r\n{\r\nstruct openpic *opp = opaque;\r\nreturn openpic_cpu_write_internal(opp, addr, val,\r\n(addr & 0x1f000) >> 12);\r\n}\r\nstatic uint32_t openpic_iack(struct openpic *opp, struct irq_dest *dst,\r\nint cpu)\r\n{\r\nstruct irq_source *src;\r\nint retval, irq;\r\npr_debug("Lower OpenPIC INT output\n");\r\nmpic_irq_lower(opp, dst, ILR_INTTGT_INT);\r\nirq = IRQ_get_next(opp, &dst->raised);\r\npr_debug("IACK: irq=%d\n", irq);\r\nif (irq == -1)\r\nreturn opp->spve;\r\nsrc = &opp->src[irq];\r\nif (!(src->ivpr & IVPR_ACTIVITY_MASK) ||\r\n!(IVPR_PRIORITY(src->ivpr) > dst->ctpr)) {\r\npr_err("%s: bad raised IRQ %d ctpr %d ivpr 0x%08x\n",\r\n__func__, irq, dst->ctpr, src->ivpr);\r\nopenpic_update_irq(opp, irq);\r\nretval = opp->spve;\r\n} else {\r\nIRQ_setbit(&dst->servicing, irq);\r\nretval = IVPR_VECTOR(opp, src->ivpr);\r\n}\r\nif (!src->level) {\r\nsrc->ivpr &= ~IVPR_ACTIVITY_MASK;\r\nsrc->pending = 0;\r\nIRQ_resetbit(&dst->raised, irq);\r\n}\r\nif ((irq >= opp->irq_ipi0) && (irq < (opp->irq_ipi0 + MAX_IPI))) {\r\nsrc->destmask &= ~(1 << cpu);\r\nif (src->destmask && !src->level) {\r\nopenpic_set_irq(opp, irq, 1);\r\nopenpic_set_irq(opp, irq, 0);\r\nsrc->ivpr |= IVPR_ACTIVITY_MASK;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nvoid kvmppc_mpic_set_epr(struct kvm_vcpu *vcpu)\r\n{\r\nstruct openpic *opp = vcpu->arch.mpic;\r\nint cpu = vcpu->arch.irq_cpu_id;\r\nunsigned long flags;\r\nspin_lock_irqsave(&opp->lock, flags);\r\nif ((opp->gcr & opp->mpic_mode_mask) == GCR_MODE_PROXY)\r\nkvmppc_set_epr(vcpu, openpic_iack(opp, &opp->dst[cpu], cpu));\r\nspin_unlock_irqrestore(&opp->lock, flags);\r\n}\r\nstatic int openpic_cpu_read_internal(void *opaque, gpa_t addr,\r\nu32 *ptr, int idx)\r\n{\r\nstruct openpic *opp = opaque;\r\nstruct irq_dest *dst;\r\nuint32_t retval;\r\npr_debug("%s: cpu %d addr %#llx\n", __func__, idx, addr);\r\nretval = 0xFFFFFFFF;\r\nif (idx < 0)\r\ngoto out;\r\nif (addr & 0xF)\r\ngoto out;\r\ndst = &opp->dst[idx];\r\naddr &= 0xFF0;\r\nswitch (addr) {\r\ncase 0x80:\r\nretval = dst->ctpr;\r\nbreak;\r\ncase 0x90:\r\nretval = idx;\r\nbreak;\r\ncase 0xA0:\r\nretval = openpic_iack(opp, dst, idx);\r\nbreak;\r\ncase 0xB0:\r\nretval = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npr_debug("%s: => 0x%08x\n", __func__, retval);\r\nout:\r\n*ptr = retval;\r\nreturn 0;\r\n}\r\nstatic int openpic_cpu_read(void *opaque, gpa_t addr, u32 *ptr)\r\n{\r\nstruct openpic *opp = opaque;\r\nreturn openpic_cpu_read_internal(opp, addr, ptr,\r\n(addr & 0x1f000) >> 12);\r\n}\r\nstatic void add_mmio_region(struct openpic *opp, const struct mem_reg *mr)\r\n{\r\nif (opp->num_mmio_regions >= MAX_MMIO_REGIONS) {\r\nWARN(1, "kvm mpic: too many mmio regions\n");\r\nreturn;\r\n}\r\nopp->mmio_regions[opp->num_mmio_regions++] = mr;\r\n}\r\nstatic void fsl_common_init(struct openpic *opp)\r\n{\r\nint i;\r\nint virq = MAX_SRC;\r\nadd_mmio_region(opp, &openpic_msi_mmio);\r\nadd_mmio_region(opp, &openpic_summary_mmio);\r\nopp->vid = VID_REVISION_1_2;\r\nopp->vir = VIR_GENERIC;\r\nopp->vector_mask = 0xFFFF;\r\nopp->tfrr_reset = 0;\r\nopp->ivpr_reset = IVPR_MASK_MASK;\r\nopp->idr_reset = 1 << 0;\r\nopp->max_irq = MAX_IRQ;\r\nopp->irq_ipi0 = virq;\r\nvirq += MAX_IPI;\r\nopp->irq_tim0 = virq;\r\nvirq += MAX_TMR;\r\nBUG_ON(virq > MAX_IRQ);\r\nopp->irq_msi = 224;\r\nfor (i = 0; i < opp->fsl->max_ext; i++)\r\nopp->src[i].level = false;\r\nfor (i = 16; i < MAX_SRC; i++) {\r\nopp->src[i].type = IRQ_TYPE_FSLINT;\r\nopp->src[i].level = true;\r\n}\r\nfor (i = MAX_SRC; i < virq; i++) {\r\nopp->src[i].type = IRQ_TYPE_FSLSPECIAL;\r\nopp->src[i].level = false;\r\n}\r\n}\r\nstatic int kvm_mpic_read_internal(struct openpic *opp, gpa_t addr, u32 *ptr)\r\n{\r\nint i;\r\nfor (i = 0; i < opp->num_mmio_regions; i++) {\r\nconst struct mem_reg *mr = opp->mmio_regions[i];\r\nif (mr->start_addr > addr || addr >= mr->start_addr + mr->size)\r\ncontinue;\r\nreturn mr->read(opp, addr - mr->start_addr, ptr);\r\n}\r\nreturn -ENXIO;\r\n}\r\nstatic int kvm_mpic_write_internal(struct openpic *opp, gpa_t addr, u32 val)\r\n{\r\nint i;\r\nfor (i = 0; i < opp->num_mmio_regions; i++) {\r\nconst struct mem_reg *mr = opp->mmio_regions[i];\r\nif (mr->start_addr > addr || addr >= mr->start_addr + mr->size)\r\ncontinue;\r\nreturn mr->write(opp, addr - mr->start_addr, val);\r\n}\r\nreturn -ENXIO;\r\n}\r\nstatic int kvm_mpic_read(struct kvm_vcpu *vcpu,\r\nstruct kvm_io_device *this,\r\ngpa_t addr, int len, void *ptr)\r\n{\r\nstruct openpic *opp = container_of(this, struct openpic, mmio);\r\nint ret;\r\nunion {\r\nu32 val;\r\nu8 bytes[4];\r\n} u;\r\nif (addr & (len - 1)) {\r\npr_debug("%s: bad alignment %llx/%d\n",\r\n__func__, addr, len);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irq(&opp->lock);\r\nret = kvm_mpic_read_internal(opp, addr - opp->reg_base, &u.val);\r\nspin_unlock_irq(&opp->lock);\r\nif (len == 4) {\r\n*(u32 *)ptr = u.val;\r\npr_debug("%s: addr %llx ret %d len 4 val %x\n",\r\n__func__, addr, ret, u.val);\r\n} else if (len == 1) {\r\n*(u8 *)ptr = u.bytes[addr & 3];\r\npr_debug("%s: addr %llx ret %d len 1 val %x\n",\r\n__func__, addr, ret, u.bytes[addr & 3]);\r\n} else {\r\npr_debug("%s: bad length %d\n", __func__, len);\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kvm_mpic_write(struct kvm_vcpu *vcpu,\r\nstruct kvm_io_device *this,\r\ngpa_t addr, int len, const void *ptr)\r\n{\r\nstruct openpic *opp = container_of(this, struct openpic, mmio);\r\nint ret;\r\nif (len != 4) {\r\npr_debug("%s: bad length %d\n", __func__, len);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (addr & 3) {\r\npr_debug("%s: bad alignment %llx/%d\n", __func__, addr, len);\r\nreturn -EOPNOTSUPP;\r\n}\r\nspin_lock_irq(&opp->lock);\r\nret = kvm_mpic_write_internal(opp, addr - opp->reg_base,\r\n*(const u32 *)ptr);\r\nspin_unlock_irq(&opp->lock);\r\npr_debug("%s: addr %llx ret %d val %x\n",\r\n__func__, addr, ret, *(const u32 *)ptr);\r\nreturn ret;\r\n}\r\nstatic void map_mmio(struct openpic *opp)\r\n{\r\nkvm_iodevice_init(&opp->mmio, &mpic_mmio_ops);\r\nkvm_io_bus_register_dev(opp->kvm, KVM_MMIO_BUS,\r\nopp->reg_base, OPENPIC_REG_SIZE,\r\n&opp->mmio);\r\n}\r\nstatic void unmap_mmio(struct openpic *opp)\r\n{\r\nkvm_io_bus_unregister_dev(opp->kvm, KVM_MMIO_BUS, &opp->mmio);\r\n}\r\nstatic int set_base_addr(struct openpic *opp, struct kvm_device_attr *attr)\r\n{\r\nu64 base;\r\nif (copy_from_user(&base, (u64 __user *)(long)attr->addr, sizeof(u64)))\r\nreturn -EFAULT;\r\nif (base & 0x3ffff) {\r\npr_debug("kvm mpic %s: KVM_DEV_MPIC_BASE_ADDR %08llx not aligned\n",\r\n__func__, base);\r\nreturn -EINVAL;\r\n}\r\nif (base == opp->reg_base)\r\nreturn 0;\r\nmutex_lock(&opp->kvm->slots_lock);\r\nunmap_mmio(opp);\r\nopp->reg_base = base;\r\npr_debug("kvm mpic %s: KVM_DEV_MPIC_BASE_ADDR %08llx\n",\r\n__func__, base);\r\nif (base == 0)\r\ngoto out;\r\nmap_mmio(opp);\r\nout:\r\nmutex_unlock(&opp->kvm->slots_lock);\r\nreturn 0;\r\n}\r\nstatic int access_reg(struct openpic *opp, gpa_t addr, u32 *val, int type)\r\n{\r\nint ret;\r\nif (addr & 3)\r\nreturn -ENXIO;\r\nspin_lock_irq(&opp->lock);\r\nif (type == ATTR_SET)\r\nret = kvm_mpic_write_internal(opp, addr, *val);\r\nelse\r\nret = kvm_mpic_read_internal(opp, addr, val);\r\nspin_unlock_irq(&opp->lock);\r\npr_debug("%s: type %d addr %llx val %x\n", __func__, type, addr, *val);\r\nreturn ret;\r\n}\r\nstatic int mpic_set_attr(struct kvm_device *dev, struct kvm_device_attr *attr)\r\n{\r\nstruct openpic *opp = dev->private;\r\nu32 attr32;\r\nswitch (attr->group) {\r\ncase KVM_DEV_MPIC_GRP_MISC:\r\nswitch (attr->attr) {\r\ncase KVM_DEV_MPIC_BASE_ADDR:\r\nreturn set_base_addr(opp, attr);\r\n}\r\nbreak;\r\ncase KVM_DEV_MPIC_GRP_REGISTER:\r\nif (get_user(attr32, (u32 __user *)(long)attr->addr))\r\nreturn -EFAULT;\r\nreturn access_reg(opp, attr->attr, &attr32, ATTR_SET);\r\ncase KVM_DEV_MPIC_GRP_IRQ_ACTIVE:\r\nif (attr->attr > MAX_SRC)\r\nreturn -EINVAL;\r\nif (get_user(attr32, (u32 __user *)(long)attr->addr))\r\nreturn -EFAULT;\r\nif (attr32 != 0 && attr32 != 1)\r\nreturn -EINVAL;\r\nspin_lock_irq(&opp->lock);\r\nopenpic_set_irq(opp, attr->attr, attr32);\r\nspin_unlock_irq(&opp->lock);\r\nreturn 0;\r\n}\r\nreturn -ENXIO;\r\n}\r\nstatic int mpic_get_attr(struct kvm_device *dev, struct kvm_device_attr *attr)\r\n{\r\nstruct openpic *opp = dev->private;\r\nu64 attr64;\r\nu32 attr32;\r\nint ret;\r\nswitch (attr->group) {\r\ncase KVM_DEV_MPIC_GRP_MISC:\r\nswitch (attr->attr) {\r\ncase KVM_DEV_MPIC_BASE_ADDR:\r\nmutex_lock(&opp->kvm->slots_lock);\r\nattr64 = opp->reg_base;\r\nmutex_unlock(&opp->kvm->slots_lock);\r\nif (copy_to_user((u64 __user *)(long)attr->addr,\r\n&attr64, sizeof(u64)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nbreak;\r\ncase KVM_DEV_MPIC_GRP_REGISTER:\r\nret = access_reg(opp, attr->attr, &attr32, ATTR_GET);\r\nif (ret)\r\nreturn ret;\r\nif (put_user(attr32, (u32 __user *)(long)attr->addr))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase KVM_DEV_MPIC_GRP_IRQ_ACTIVE:\r\nif (attr->attr > MAX_SRC)\r\nreturn -EINVAL;\r\nspin_lock_irq(&opp->lock);\r\nattr32 = opp->src[attr->attr].pending;\r\nspin_unlock_irq(&opp->lock);\r\nif (put_user(attr32, (u32 __user *)(long)attr->addr))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nreturn -ENXIO;\r\n}\r\nstatic int mpic_has_attr(struct kvm_device *dev, struct kvm_device_attr *attr)\r\n{\r\nswitch (attr->group) {\r\ncase KVM_DEV_MPIC_GRP_MISC:\r\nswitch (attr->attr) {\r\ncase KVM_DEV_MPIC_BASE_ADDR:\r\nreturn 0;\r\n}\r\nbreak;\r\ncase KVM_DEV_MPIC_GRP_REGISTER:\r\nreturn 0;\r\ncase KVM_DEV_MPIC_GRP_IRQ_ACTIVE:\r\nif (attr->attr > MAX_SRC)\r\nbreak;\r\nreturn 0;\r\n}\r\nreturn -ENXIO;\r\n}\r\nstatic void mpic_destroy(struct kvm_device *dev)\r\n{\r\nstruct openpic *opp = dev->private;\r\ndev->kvm->arch.mpic = NULL;\r\nkfree(opp);\r\nkfree(dev);\r\n}\r\nstatic int mpic_set_default_irq_routing(struct openpic *opp)\r\n{\r\nstruct kvm_irq_routing_entry *routing;\r\nrouting = kzalloc((sizeof(*routing)), GFP_KERNEL);\r\nif (!routing)\r\nreturn -ENOMEM;\r\nkvm_set_irq_routing(opp->kvm, routing, 0, 0);\r\nkfree(routing);\r\nreturn 0;\r\n}\r\nstatic int mpic_create(struct kvm_device *dev, u32 type)\r\n{\r\nstruct openpic *opp;\r\nint ret;\r\nif (dev->kvm->arch.mpic)\r\nreturn -EINVAL;\r\nopp = kzalloc(sizeof(struct openpic), GFP_KERNEL);\r\nif (!opp)\r\nreturn -ENOMEM;\r\ndev->private = opp;\r\nopp->kvm = dev->kvm;\r\nopp->dev = dev;\r\nopp->model = type;\r\nspin_lock_init(&opp->lock);\r\nadd_mmio_region(opp, &openpic_gbl_mmio);\r\nadd_mmio_region(opp, &openpic_tmr_mmio);\r\nadd_mmio_region(opp, &openpic_src_mmio);\r\nadd_mmio_region(opp, &openpic_cpu_mmio);\r\nswitch (opp->model) {\r\ncase KVM_DEV_TYPE_FSL_MPIC_20:\r\nopp->fsl = &fsl_mpic_20;\r\nopp->brr1 = 0x00400200;\r\nopp->flags |= OPENPIC_FLAG_IDR_CRIT;\r\nopp->nb_irqs = 80;\r\nopp->mpic_mode_mask = GCR_MODE_MIXED;\r\nfsl_common_init(opp);\r\nbreak;\r\ncase KVM_DEV_TYPE_FSL_MPIC_42:\r\nopp->fsl = &fsl_mpic_42;\r\nopp->brr1 = 0x00400402;\r\nopp->flags |= OPENPIC_FLAG_ILR;\r\nopp->nb_irqs = 196;\r\nopp->mpic_mode_mask = GCR_MODE_PROXY;\r\nfsl_common_init(opp);\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nret = mpic_set_default_irq_routing(opp);\r\nif (ret)\r\ngoto err;\r\nopenpic_reset(opp);\r\nsmp_wmb();\r\ndev->kvm->arch.mpic = opp;\r\nreturn 0;\r\nerr:\r\nkfree(opp);\r\nreturn ret;\r\n}\r\nint kvmppc_mpic_connect_vcpu(struct kvm_device *dev, struct kvm_vcpu *vcpu,\r\nu32 cpu)\r\n{\r\nstruct openpic *opp = dev->private;\r\nint ret = 0;\r\nif (dev->ops != &kvm_mpic_ops)\r\nreturn -EPERM;\r\nif (opp->kvm != vcpu->kvm)\r\nreturn -EPERM;\r\nif (cpu < 0 || cpu >= MAX_CPU)\r\nreturn -EPERM;\r\nspin_lock_irq(&opp->lock);\r\nif (opp->dst[cpu].vcpu) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\nif (vcpu->arch.irq_type) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nopp->dst[cpu].vcpu = vcpu;\r\nopp->nb_cpus = max(opp->nb_cpus, cpu + 1);\r\nvcpu->arch.mpic = opp;\r\nvcpu->arch.irq_cpu_id = cpu;\r\nvcpu->arch.irq_type = KVMPPC_IRQ_MPIC;\r\nif (opp->mpic_mode_mask == GCR_MODE_PROXY)\r\nvcpu->arch.epr_flags |= KVMPPC_EPR_KERNEL;\r\nout:\r\nspin_unlock_irq(&opp->lock);\r\nreturn ret;\r\n}\r\nvoid kvmppc_mpic_disconnect_vcpu(struct openpic *opp, struct kvm_vcpu *vcpu)\r\n{\r\nBUG_ON(!opp->dst[vcpu->arch.irq_cpu_id].vcpu);\r\nopp->dst[vcpu->arch.irq_cpu_id].vcpu = NULL;\r\n}\r\nstatic int mpic_set_irq(struct kvm_kernel_irq_routing_entry *e,\r\nstruct kvm *kvm, int irq_source_id, int level,\r\nbool line_status)\r\n{\r\nu32 irq = e->irqchip.pin;\r\nstruct openpic *opp = kvm->arch.mpic;\r\nunsigned long flags;\r\nspin_lock_irqsave(&opp->lock, flags);\r\nopenpic_set_irq(opp, irq, level);\r\nspin_unlock_irqrestore(&opp->lock, flags);\r\nreturn 0;\r\n}\r\nint kvm_set_msi(struct kvm_kernel_irq_routing_entry *e,\r\nstruct kvm *kvm, int irq_source_id, int level, bool line_status)\r\n{\r\nstruct openpic *opp = kvm->arch.mpic;\r\nunsigned long flags;\r\nspin_lock_irqsave(&opp->lock, flags);\r\nopenpic_msi_write(kvm->arch.mpic, MSIIR_OFFSET, e->msi.data);\r\nspin_unlock_irqrestore(&opp->lock, flags);\r\nreturn 0;\r\n}\r\nint kvm_set_routing_entry(struct kvm *kvm,\r\nstruct kvm_kernel_irq_routing_entry *e,\r\nconst struct kvm_irq_routing_entry *ue)\r\n{\r\nint r = -EINVAL;\r\nswitch (ue->type) {\r\ncase KVM_IRQ_ROUTING_IRQCHIP:\r\ne->set = mpic_set_irq;\r\ne->irqchip.irqchip = ue->u.irqchip.irqchip;\r\ne->irqchip.pin = ue->u.irqchip.pin;\r\nif (e->irqchip.pin >= KVM_IRQCHIP_NUM_PINS)\r\ngoto out;\r\nbreak;\r\ncase KVM_IRQ_ROUTING_MSI:\r\ne->set = kvm_set_msi;\r\ne->msi.address_lo = ue->u.msi.address_lo;\r\ne->msi.address_hi = ue->u.msi.address_hi;\r\ne->msi.data = ue->u.msi.data;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nr = 0;\r\nout:\r\nreturn r;\r\n}
