static inline void __mfp_config_run(struct mfp_pin *p)\r\n{\r\nif (mfp_configured(p))\r\nmfpr_writel(p->mfpr_off, p->mfpr_run);\r\n}\r\nstatic inline void __mfp_config_lpm(struct mfp_pin *p)\r\n{\r\nif (mfp_configured(p)) {\r\nunsigned long mfpr_clr = (p->mfpr_run & ~MFPR_EDGE_BOTH) | MFPR_EDGE_CLEAR;\r\nif (mfpr_clr != p->mfpr_run)\r\nmfpr_writel(p->mfpr_off, mfpr_clr);\r\nif (p->mfpr_lpm != mfpr_clr)\r\nmfpr_writel(p->mfpr_off, p->mfpr_lpm);\r\n}\r\n}\r\nvoid mfp_config(unsigned long *mfp_cfgs, int num)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&mfp_spin_lock, flags);\r\nfor (i = 0; i < num; i++, mfp_cfgs++) {\r\nunsigned long tmp, c = *mfp_cfgs;\r\nstruct mfp_pin *p;\r\nint pin, af, drv, lpm, edge, pull;\r\npin = MFP_PIN(c);\r\nBUG_ON(pin >= MFP_PIN_MAX);\r\np = &mfp_table[pin];\r\naf = MFP_AF(c);\r\ndrv = MFP_DS(c);\r\nlpm = MFP_LPM_STATE(c);\r\nedge = MFP_LPM_EDGE(c);\r\npull = MFP_PULL(c);\r\ntmp = MFPR_AF_SEL(af) | MFPR_DRIVE(drv);\r\nif (likely(pull == MFP_PULL_NONE)) {\r\np->mfpr_run = tmp | mfpr_lpm[lpm] | mfpr_edge[edge];\r\np->mfpr_lpm = p->mfpr_run;\r\n} else {\r\np->mfpr_lpm = tmp | mfpr_lpm[lpm] | mfpr_edge[edge];\r\np->mfpr_run = tmp | mfpr_pull[pull];\r\n}\r\np->config = c; __mfp_config_run(p);\r\n}\r\nmfpr_sync();\r\nspin_unlock_irqrestore(&mfp_spin_lock, flags);\r\n}\r\nunsigned long mfp_read(int mfp)\r\n{\r\nunsigned long val, flags;\r\nBUG_ON(mfp < 0 || mfp >= MFP_PIN_MAX);\r\nspin_lock_irqsave(&mfp_spin_lock, flags);\r\nval = mfpr_readl(mfp_table[mfp].mfpr_off);\r\nspin_unlock_irqrestore(&mfp_spin_lock, flags);\r\nreturn val;\r\n}\r\nvoid mfp_write(int mfp, unsigned long val)\r\n{\r\nunsigned long flags;\r\nBUG_ON(mfp < 0 || mfp >= MFP_PIN_MAX);\r\nspin_lock_irqsave(&mfp_spin_lock, flags);\r\nmfpr_writel(mfp_table[mfp].mfpr_off, val);\r\nmfpr_sync();\r\nspin_unlock_irqrestore(&mfp_spin_lock, flags);\r\n}\r\nvoid __init mfp_init_base(void __iomem *mfpr_base)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mfp_table); i++)\r\nmfp_table[i].config = -1;\r\nmfpr_mmio_base = mfpr_base;\r\n}\r\nvoid __init mfp_init_addr(struct mfp_addr_map *map)\r\n{\r\nstruct mfp_addr_map *p;\r\nunsigned long offset, flags;\r\nint i;\r\nspin_lock_irqsave(&mfp_spin_lock, flags);\r\nmfpr_off_readback = map[0].offset;\r\nfor (p = map; p->start != MFP_PIN_INVALID; p++) {\r\noffset = p->offset;\r\ni = p->start;\r\ndo {\r\nmfp_table[i].mfpr_off = offset;\r\nmfp_table[i].mfpr_run = 0;\r\nmfp_table[i].mfpr_lpm = 0;\r\noffset += 4; i++;\r\n} while ((i <= p->end) && (p->end != -1));\r\n}\r\nspin_unlock_irqrestore(&mfp_spin_lock, flags);\r\n}\r\nvoid mfp_config_lpm(void)\r\n{\r\nstruct mfp_pin *p = &mfp_table[0];\r\nint pin;\r\nfor (pin = 0; pin < ARRAY_SIZE(mfp_table); pin++, p++)\r\n__mfp_config_lpm(p);\r\n}\r\nvoid mfp_config_run(void)\r\n{\r\nstruct mfp_pin *p = &mfp_table[0];\r\nint pin;\r\nfor (pin = 0; pin < ARRAY_SIZE(mfp_table); pin++, p++)\r\n__mfp_config_run(p);\r\n}
