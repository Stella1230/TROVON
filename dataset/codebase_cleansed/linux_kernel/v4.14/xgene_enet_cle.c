static void xgene_cle_sband_to_hw(u8 frag, enum xgene_cle_prot_version ver,\r\nenum xgene_cle_prot_type type, u32 len,\r\nu32 *reg)\r\n{\r\n*reg = SET_VAL(SB_IPFRAG, frag) |\r\nSET_VAL(SB_IPPROT, type) |\r\nSET_VAL(SB_IPVER, ver) |\r\nSET_VAL(SB_HDRLEN, len);\r\n}\r\nstatic void xgene_cle_idt_to_hw(struct xgene_enet_pdata *pdata,\r\nu32 dstqid, u32 fpsel,\r\nu32 nfpsel, u32 *idt_reg)\r\n{\r\nif (pdata->enet_id == XGENE_ENET1) {\r\n*idt_reg = SET_VAL(IDT_DSTQID, dstqid) |\r\nSET_VAL(IDT_FPSEL1, fpsel) |\r\nSET_VAL(IDT_NFPSEL1, nfpsel);\r\n} else {\r\n*idt_reg = SET_VAL(IDT_DSTQID, dstqid) |\r\nSET_VAL(IDT_FPSEL, fpsel) |\r\nSET_VAL(IDT_NFPSEL, nfpsel);\r\n}\r\n}\r\nstatic void xgene_cle_dbptr_to_hw(struct xgene_enet_pdata *pdata,\r\nstruct xgene_cle_dbptr *dbptr, u32 *buf)\r\n{\r\nbuf[0] = SET_VAL(CLE_DROP, dbptr->drop);\r\nbuf[4] = SET_VAL(CLE_FPSEL, dbptr->fpsel) |\r\nSET_VAL(CLE_NFPSEL, dbptr->nxtfpsel) |\r\nSET_VAL(CLE_DSTQIDL, dbptr->dstqid);\r\nbuf[5] = SET_VAL(CLE_DSTQIDH, (u32)dbptr->dstqid >> CLE_DSTQIDL_LEN) |\r\nSET_VAL(CLE_PRIORITY, dbptr->cle_priority);\r\n}\r\nstatic void xgene_cle_kn_to_hw(struct xgene_cle_ptree_kn *kn, u32 *buf)\r\n{\r\nu32 i, j = 0;\r\nu32 data;\r\nbuf[j++] = SET_VAL(CLE_TYPE, kn->node_type);\r\nfor (i = 0; i < kn->num_keys; i++) {\r\nstruct xgene_cle_ptree_key *key = &kn->key[i];\r\nif (!(i % 2)) {\r\nbuf[j] = SET_VAL(CLE_KN_PRIO, key->priority) |\r\nSET_VAL(CLE_KN_RPTR, key->result_pointer);\r\n} else {\r\ndata = SET_VAL(CLE_KN_PRIO, key->priority) |\r\nSET_VAL(CLE_KN_RPTR, key->result_pointer);\r\nbuf[j++] |= (data << 16);\r\n}\r\n}\r\n}\r\nstatic void xgene_cle_dn_to_hw(const struct xgene_cle_ptree_ewdn *dn,\r\nu32 *buf, u32 jb)\r\n{\r\nconst struct xgene_cle_ptree_branch *br;\r\nu32 i, j = 0;\r\nu32 npp;\r\nbuf[j++] = SET_VAL(CLE_DN_TYPE, dn->node_type) |\r\nSET_VAL(CLE_DN_LASTN, dn->last_node) |\r\nSET_VAL(CLE_DN_HLS, dn->hdr_len_store) |\r\nSET_VAL(CLE_DN_EXT, dn->hdr_extn) |\r\nSET_VAL(CLE_DN_BSTOR, dn->byte_store) |\r\nSET_VAL(CLE_DN_SBSTOR, dn->search_byte_store) |\r\nSET_VAL(CLE_DN_RPTR, dn->result_pointer);\r\nfor (i = 0; i < dn->num_branches; i++) {\r\nbr = &dn->branch[i];\r\nnpp = br->next_packet_pointer;\r\nif ((br->jump_rel == JMP_ABS) && (npp < CLE_PKTRAM_SIZE))\r\nnpp += jb;\r\nbuf[j++] = SET_VAL(CLE_BR_VALID, br->valid) |\r\nSET_VAL(CLE_BR_NPPTR, npp) |\r\nSET_VAL(CLE_BR_JB, br->jump_bw) |\r\nSET_VAL(CLE_BR_JR, br->jump_rel) |\r\nSET_VAL(CLE_BR_OP, br->operation) |\r\nSET_VAL(CLE_BR_NNODE, br->next_node) |\r\nSET_VAL(CLE_BR_NBR, br->next_branch);\r\nbuf[j++] = SET_VAL(CLE_BR_DATA, br->data) |\r\nSET_VAL(CLE_BR_MASK, br->mask);\r\n}\r\n}\r\nstatic int xgene_cle_poll_cmd_done(void __iomem *base,\r\nenum xgene_cle_cmd_type cmd)\r\n{\r\nu32 status, loop = 10;\r\nint ret = -EBUSY;\r\nwhile (loop--) {\r\nstatus = ioread32(base + INDCMD_STATUS);\r\nif (status & cmd) {\r\nret = 0;\r\nbreak;\r\n}\r\nusleep_range(1000, 2000);\r\n}\r\nreturn ret;\r\n}\r\nstatic int xgene_cle_dram_wr(struct xgene_enet_cle *cle, u32 *data, u8 nregs,\r\nu32 index, enum xgene_cle_dram_type type,\r\nenum xgene_cle_cmd_type cmd)\r\n{\r\nenum xgene_cle_parser parser = cle->active_parser;\r\nvoid __iomem *base = cle->base;\r\nu32 i, j, ind_addr;\r\nu8 port, nparsers;\r\nint ret = 0;\r\nnparsers = (type >= PTREE_RAM) ? 1 : cle->parsers;\r\nfor (i = 0; i < nparsers; i++) {\r\nport = i;\r\nif ((type < PTREE_RAM) && (parser != PARSER_ALL))\r\nport = parser;\r\nind_addr = XGENE_CLE_DRAM(type + (port * 4)) | index;\r\niowrite32(ind_addr, base + INDADDR);\r\nfor (j = 0; j < nregs; j++)\r\niowrite32(data[j], base + DATA_RAM0 + (j * 4));\r\niowrite32(cmd, base + INDCMD);\r\nret = xgene_cle_poll_cmd_done(base, cmd);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void xgene_cle_enable_ptree(struct xgene_enet_pdata *pdata,\r\nstruct xgene_enet_cle *cle)\r\n{\r\nstruct xgene_cle_ptree *ptree = &cle->ptree;\r\nvoid __iomem *addr, *base = cle->base;\r\nu32 offset = CLE_PORT_OFFSET;\r\nu32 i;\r\nptree->start_pkt += cle->jump_bytes;\r\nfor (i = 0; i < cle->parsers; i++) {\r\nif (cle->active_parser != PARSER_ALL)\r\naddr = base + cle->active_parser * offset;\r\nelse\r\naddr = base + (i * offset);\r\niowrite32(ptree->start_node & 0x3fff, addr + SNPTR0);\r\niowrite32(ptree->start_pkt & 0x1ff, addr + SPPTR0);\r\n}\r\n}\r\nstatic int xgene_cle_setup_dbptr(struct xgene_enet_pdata *pdata,\r\nstruct xgene_enet_cle *cle)\r\n{\r\nstruct xgene_cle_ptree *ptree = &cle->ptree;\r\nu32 buf[CLE_DRAM_REGS];\r\nu32 i;\r\nint ret;\r\nmemset(buf, 0, sizeof(buf));\r\nfor (i = 0; i < ptree->num_dbptr; i++) {\r\nxgene_cle_dbptr_to_hw(pdata, &ptree->dbptr[i], buf);\r\nret = xgene_cle_dram_wr(cle, buf, 6, i + ptree->start_dbptr,\r\nDB_RAM, CLE_CMD_WR);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgene_cle_setup_node(struct xgene_enet_pdata *pdata,\r\nstruct xgene_enet_cle *cle)\r\n{\r\nstruct xgene_cle_ptree *ptree = &cle->ptree;\r\nconst struct xgene_cle_ptree_ewdn *dn = xgene_init_ptree_dn;\r\nint num_dn = ARRAY_SIZE(xgene_init_ptree_dn);\r\nstruct xgene_cle_ptree_kn *kn = ptree->kn;\r\nu32 buf[CLE_DRAM_REGS];\r\nint i, j, ret;\r\nmemset(buf, 0, sizeof(buf));\r\nfor (i = 0; i < num_dn; i++) {\r\nxgene_cle_dn_to_hw(&dn[i], buf, cle->jump_bytes);\r\nret = xgene_cle_dram_wr(cle, buf, 17, i + ptree->start_node,\r\nPTREE_RAM, CLE_CMD_WR);\r\nif (ret)\r\nreturn ret;\r\n}\r\nmemset(buf, 0, sizeof(buf));\r\nfor (j = i; j < (ptree->num_kn + num_dn); j++) {\r\nxgene_cle_kn_to_hw(&kn[j - num_dn], buf);\r\nret = xgene_cle_dram_wr(cle, buf, 17, j + ptree->start_node,\r\nPTREE_RAM, CLE_CMD_WR);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgene_cle_setup_ptree(struct xgene_enet_pdata *pdata,\r\nstruct xgene_enet_cle *cle)\r\n{\r\nint ret;\r\nret = xgene_cle_setup_node(pdata, cle);\r\nif (ret)\r\nreturn ret;\r\nret = xgene_cle_setup_dbptr(pdata, cle);\r\nif (ret)\r\nreturn ret;\r\nxgene_cle_enable_ptree(pdata, cle);\r\nreturn 0;\r\n}\r\nstatic void xgene_cle_setup_def_dbptr(struct xgene_enet_pdata *pdata,\r\nstruct xgene_enet_cle *enet_cle,\r\nstruct xgene_cle_dbptr *dbptr,\r\nu32 index, u8 priority)\r\n{\r\nvoid __iomem *base = enet_cle->base;\r\nvoid __iomem *base_addr;\r\nu32 buf[CLE_DRAM_REGS];\r\nu32 def_cls, offset;\r\nu32 i, j;\r\nmemset(buf, 0, sizeof(buf));\r\nxgene_cle_dbptr_to_hw(pdata, dbptr, buf);\r\nfor (i = 0; i < enet_cle->parsers; i++) {\r\nif (enet_cle->active_parser != PARSER_ALL) {\r\noffset = enet_cle->active_parser *\r\nCLE_PORT_OFFSET;\r\n} else {\r\noffset = i * CLE_PORT_OFFSET;\r\n}\r\nbase_addr = base + DFCLSRESDB00 + offset;\r\nfor (j = 0; j < 6; j++)\r\niowrite32(buf[j], base_addr + (j * 4));\r\ndef_cls = ((priority & 0x7) << 10) | (index & 0x3ff);\r\niowrite32(def_cls, base + DFCLSRESDBPTR0 + offset);\r\n}\r\n}\r\nstatic int xgene_cle_set_rss_sband(struct xgene_enet_cle *cle)\r\n{\r\nu32 idx = CLE_PKTRAM_SIZE / sizeof(u32);\r\nu32 mac_hdr_len = ETH_HLEN;\r\nu32 sband, reg = 0;\r\nu32 ipv4_ihl = 5;\r\nu32 hdr_len;\r\nint ret;\r\nhdr_len = (mac_hdr_len << 5) | ipv4_ihl;\r\nxgene_cle_sband_to_hw(0, XGENE_CLE_IPV4, XGENE_CLE_TCP, hdr_len, &reg);\r\nsband = reg;\r\nhdr_len = (mac_hdr_len << 5) | ipv4_ihl;\r\nxgene_cle_sband_to_hw(1, XGENE_CLE_IPV4, XGENE_CLE_UDP, hdr_len, &reg);\r\nsband |= (reg << 16);\r\nret = xgene_cle_dram_wr(cle, &sband, 1, idx, PKT_RAM, CLE_CMD_WR);\r\nif (ret)\r\nreturn ret;\r\nhdr_len = (mac_hdr_len << 5) | ipv4_ihl;\r\nxgene_cle_sband_to_hw(0, XGENE_CLE_IPV4, XGENE_CLE_OTHER,\r\nhdr_len, &reg);\r\nsband = reg;\r\nhdr_len = (mac_hdr_len << 5);\r\nxgene_cle_sband_to_hw(0, XGENE_CLE_IPV4, XGENE_CLE_OTHER,\r\nhdr_len, &reg);\r\nsband |= (reg << 16);\r\nret = xgene_cle_dram_wr(cle, &sband, 1, idx + 1, PKT_RAM, CLE_CMD_WR);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int xgene_cle_set_rss_skeys(struct xgene_enet_cle *cle)\r\n{\r\nu32 secret_key_ipv4[4];\r\nint ret = 0;\r\nget_random_bytes(secret_key_ipv4, 16);\r\nret = xgene_cle_dram_wr(cle, secret_key_ipv4, 4, 0,\r\nRSS_IPV4_HASH_SKEY, CLE_CMD_WR);\r\nreturn ret;\r\n}\r\nstatic int xgene_cle_set_rss_idt(struct xgene_enet_pdata *pdata)\r\n{\r\nu32 fpsel, dstqid, nfpsel, idt_reg, idx;\r\nint i, ret = 0;\r\nu16 pool_id;\r\nfor (i = 0; i < XGENE_CLE_IDT_ENTRIES; i++) {\r\nidx = i % pdata->rxq_cnt;\r\npool_id = pdata->rx_ring[idx]->buf_pool->id;\r\nfpsel = xgene_enet_get_fpsel(pool_id);\r\ndstqid = xgene_enet_dst_ring_num(pdata->rx_ring[idx]);\r\nnfpsel = 0;\r\nif (pdata->rx_ring[idx]->page_pool) {\r\npool_id = pdata->rx_ring[idx]->page_pool->id;\r\nnfpsel = xgene_enet_get_fpsel(pool_id);\r\n}\r\nidt_reg = 0;\r\nxgene_cle_idt_to_hw(pdata, dstqid, fpsel, nfpsel, &idt_reg);\r\nret = xgene_cle_dram_wr(&pdata->cle, &idt_reg, 1, i,\r\nRSS_IDT, CLE_CMD_WR);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = xgene_cle_set_rss_skeys(&pdata->cle);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int xgene_cle_setup_rss(struct xgene_enet_pdata *pdata)\r\n{\r\nstruct xgene_enet_cle *cle = &pdata->cle;\r\nvoid __iomem *base = cle->base;\r\nu32 offset, val = 0;\r\nint i, ret = 0;\r\noffset = CLE_PORT_OFFSET;\r\nfor (i = 0; i < cle->parsers; i++) {\r\nif (cle->active_parser != PARSER_ALL)\r\noffset = cle->active_parser * CLE_PORT_OFFSET;\r\nelse\r\noffset = i * CLE_PORT_OFFSET;\r\nval = (RSS_IPV4_12B << 1) | 0x1;\r\nwritel(val, base + RSS_CTRL0 + offset);\r\n}\r\nret = xgene_cle_set_rss_sband(cle);\r\nif (ret)\r\nreturn ret;\r\nret = xgene_cle_set_rss_idt(pdata);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int xgene_enet_cle_init(struct xgene_enet_pdata *pdata)\r\n{\r\nstruct xgene_enet_cle *enet_cle = &pdata->cle;\r\nu32 def_qid, def_fpsel, def_nxtfpsel, pool_id;\r\nstruct xgene_cle_dbptr dbptr[DB_MAX_PTRS];\r\nstruct xgene_cle_ptree *ptree;\r\nstruct xgene_cle_ptree_kn kn;\r\nint ret;\r\nif (pdata->phy_mode != PHY_INTERFACE_MODE_XGMII)\r\nreturn -EINVAL;\r\nptree = &enet_cle->ptree;\r\nptree->start_pkt = 12;\r\nret = xgene_cle_setup_rss(pdata);\r\nif (ret) {\r\nnetdev_err(pdata->ndev, "RSS initialization failed\n");\r\nreturn ret;\r\n}\r\ndef_qid = xgene_enet_dst_ring_num(pdata->rx_ring[0]);\r\npool_id = pdata->rx_ring[0]->buf_pool->id;\r\ndef_fpsel = xgene_enet_get_fpsel(pool_id);\r\ndef_nxtfpsel = 0;\r\nif (pdata->rx_ring[0]->page_pool) {\r\npool_id = pdata->rx_ring[0]->page_pool->id;\r\ndef_nxtfpsel = xgene_enet_get_fpsel(pool_id);\r\n}\r\nmemset(dbptr, 0, sizeof(struct xgene_cle_dbptr) * DB_MAX_PTRS);\r\ndbptr[DB_RES_ACCEPT].fpsel = def_fpsel;\r\ndbptr[DB_RES_ACCEPT].nxtfpsel = def_nxtfpsel;\r\ndbptr[DB_RES_ACCEPT].dstqid = def_qid;\r\ndbptr[DB_RES_ACCEPT].cle_priority = 1;\r\ndbptr[DB_RES_DEF].fpsel = def_fpsel;\r\ndbptr[DB_RES_DEF].nxtfpsel = def_nxtfpsel;\r\ndbptr[DB_RES_DEF].dstqid = def_qid;\r\ndbptr[DB_RES_DEF].cle_priority = 7;\r\nxgene_cle_setup_def_dbptr(pdata, enet_cle, &dbptr[DB_RES_DEF],\r\nDB_RES_ACCEPT, 7);\r\ndbptr[DB_RES_DROP].drop = 1;\r\nmemset(&kn, 0, sizeof(kn));\r\nkn.node_type = KN;\r\nkn.num_keys = 1;\r\nkn.key[0].priority = 0;\r\nkn.key[0].result_pointer = DB_RES_ACCEPT;\r\nptree->kn = &kn;\r\nptree->dbptr = dbptr;\r\nptree->num_kn = 1;\r\nptree->num_dbptr = DB_MAX_PTRS;\r\nreturn xgene_cle_setup_ptree(pdata, enet_cle);\r\n}
