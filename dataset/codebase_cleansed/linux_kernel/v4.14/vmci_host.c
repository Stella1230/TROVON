bool vmci_host_code_active(void)\r\n{\r\nreturn vmci_host_device_initialized &&\r\n(!vmci_guest_code_active() ||\r\natomic_read(&vmci_host_active_users) > 0);\r\n}\r\nstatic int vmci_host_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct vmci_host_dev *vmci_host_dev;\r\nvmci_host_dev = kzalloc(sizeof(struct vmci_host_dev), GFP_KERNEL);\r\nif (vmci_host_dev == NULL)\r\nreturn -ENOMEM;\r\nvmci_host_dev->ct_type = VMCIOBJ_NOT_SET;\r\nmutex_init(&vmci_host_dev->lock);\r\nfilp->private_data = vmci_host_dev;\r\nreturn 0;\r\n}\r\nstatic int vmci_host_close(struct inode *inode, struct file *filp)\r\n{\r\nstruct vmci_host_dev *vmci_host_dev = filp->private_data;\r\nif (vmci_host_dev->ct_type == VMCIOBJ_CONTEXT) {\r\nvmci_ctx_destroy(vmci_host_dev->context);\r\nvmci_host_dev->context = NULL;\r\natomic_dec(&vmci_host_active_users);\r\n}\r\nvmci_host_dev->ct_type = VMCIOBJ_NOT_SET;\r\nkfree(vmci_host_dev);\r\nfilp->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic unsigned int vmci_host_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct vmci_host_dev *vmci_host_dev = filp->private_data;\r\nstruct vmci_ctx *context = vmci_host_dev->context;\r\nunsigned int mask = 0;\r\nif (vmci_host_dev->ct_type == VMCIOBJ_CONTEXT) {\r\nif (wait)\r\npoll_wait(filp, &context->host_context.wait_queue,\r\nwait);\r\nspin_lock(&context->lock);\r\nif (context->pending_datagrams > 0 ||\r\nvmci_handle_arr_get_size(\r\ncontext->pending_doorbell_array) > 0) {\r\nmask = POLLIN;\r\n}\r\nspin_unlock(&context->lock);\r\n}\r\nreturn mask;\r\n}\r\nstatic int drv_cp_harray_to_user(void __user *user_buf_uva,\r\nu64 *user_buf_size,\r\nstruct vmci_handle_arr *handle_array,\r\nint *retval)\r\n{\r\nu32 array_size = 0;\r\nstruct vmci_handle *handles;\r\nif (handle_array)\r\narray_size = vmci_handle_arr_get_size(handle_array);\r\nif (array_size * sizeof(*handles) > *user_buf_size)\r\nreturn VMCI_ERROR_MORE_DATA;\r\n*user_buf_size = array_size * sizeof(*handles);\r\nif (*user_buf_size)\r\n*retval = copy_to_user(user_buf_uva,\r\nvmci_handle_arr_get_handles\r\n(handle_array), *user_buf_size);\r\nreturn VMCI_SUCCESS;\r\n}\r\nstatic int vmci_host_setup_notify(struct vmci_ctx *context,\r\nunsigned long uva)\r\n{\r\nint retval;\r\nif (context->notify_page) {\r\npr_devel("%s: Notify mechanism is already set up\n", __func__);\r\nreturn VMCI_ERROR_DUPLICATE_ENTRY;\r\n}\r\nBUILD_BUG_ON(sizeof(bool) != sizeof(u8));\r\nif (!access_ok(VERIFY_WRITE, (void __user *)uva, sizeof(u8)))\r\nreturn VMCI_ERROR_GENERIC;\r\nretval = get_user_pages_fast(uva, 1, 1, &context->notify_page);\r\nif (retval != 1) {\r\ncontext->notify_page = NULL;\r\nreturn VMCI_ERROR_GENERIC;\r\n}\r\ncontext->notify = kmap(context->notify_page) + (uva & (PAGE_SIZE - 1));\r\nvmci_ctx_check_signal_notify(context);\r\nreturn VMCI_SUCCESS;\r\n}\r\nstatic int vmci_host_get_version(struct vmci_host_dev *vmci_host_dev,\r\nunsigned int cmd, void __user *uptr)\r\n{\r\nif (cmd == IOCTL_VMCI_VERSION2) {\r\nint __user *vptr = uptr;\r\nif (get_user(vmci_host_dev->user_version, vptr))\r\nreturn -EFAULT;\r\n}\r\nif (vmci_host_dev->user_version > 0 &&\r\nvmci_host_dev->user_version < VMCI_VERSION_HOSTQP) {\r\nreturn vmci_host_dev->user_version;\r\n}\r\nreturn VMCI_VERSION;\r\n}\r\nstatic int vmci_host_do_init_context(struct vmci_host_dev *vmci_host_dev,\r\nconst char *ioctl_name,\r\nvoid __user *uptr)\r\n{\r\nstruct vmci_init_blk init_block;\r\nconst struct cred *cred;\r\nint retval;\r\nif (copy_from_user(&init_block, uptr, sizeof(init_block))) {\r\nvmci_ioctl_err("error reading init block\n");\r\nreturn -EFAULT;\r\n}\r\nmutex_lock(&vmci_host_dev->lock);\r\nif (vmci_host_dev->ct_type != VMCIOBJ_NOT_SET) {\r\nvmci_ioctl_err("received VMCI init on initialized handle\n");\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\nif (init_block.flags & ~VMCI_PRIVILEGE_FLAG_RESTRICTED) {\r\nvmci_ioctl_err("unsupported VMCI restriction flag\n");\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\ncred = get_current_cred();\r\nvmci_host_dev->context = vmci_ctx_create(init_block.cid,\r\ninit_block.flags, 0,\r\nvmci_host_dev->user_version,\r\ncred);\r\nput_cred(cred);\r\nif (IS_ERR(vmci_host_dev->context)) {\r\nretval = PTR_ERR(vmci_host_dev->context);\r\nvmci_ioctl_err("error initializing context\n");\r\ngoto out;\r\n}\r\ninit_block.cid = vmci_ctx_get_id(vmci_host_dev->context);\r\nif (copy_to_user(uptr, &init_block, sizeof(init_block))) {\r\nvmci_ctx_destroy(vmci_host_dev->context);\r\nvmci_host_dev->context = NULL;\r\nvmci_ioctl_err("error writing init block\n");\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\nvmci_host_dev->ct_type = VMCIOBJ_CONTEXT;\r\natomic_inc(&vmci_host_active_users);\r\nretval = 0;\r\nout:\r\nmutex_unlock(&vmci_host_dev->lock);\r\nreturn retval;\r\n}\r\nstatic int vmci_host_do_send_datagram(struct vmci_host_dev *vmci_host_dev,\r\nconst char *ioctl_name,\r\nvoid __user *uptr)\r\n{\r\nstruct vmci_datagram_snd_rcv_info send_info;\r\nstruct vmci_datagram *dg = NULL;\r\nu32 cid;\r\nif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\r\nvmci_ioctl_err("only valid for contexts\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&send_info, uptr, sizeof(send_info)))\r\nreturn -EFAULT;\r\nif (send_info.len > VMCI_MAX_DG_SIZE) {\r\nvmci_ioctl_err("datagram is too big (size=%d)\n",\r\nsend_info.len);\r\nreturn -EINVAL;\r\n}\r\nif (send_info.len < sizeof(*dg)) {\r\nvmci_ioctl_err("datagram is too small (size=%d)\n",\r\nsend_info.len);\r\nreturn -EINVAL;\r\n}\r\ndg = memdup_user((void __user *)(uintptr_t)send_info.addr,\r\nsend_info.len);\r\nif (IS_ERR(dg)) {\r\nvmci_ioctl_err(\r\n"cannot allocate memory to dispatch datagram\n");\r\nreturn PTR_ERR(dg);\r\n}\r\nif (VMCI_DG_SIZE(dg) != send_info.len) {\r\nvmci_ioctl_err("datagram size mismatch\n");\r\nkfree(dg);\r\nreturn -EINVAL;\r\n}\r\npr_devel("Datagram dst (handle=0x%x:0x%x) src (handle=0x%x:0x%x), payload (size=%llu bytes)\n",\r\ndg->dst.context, dg->dst.resource,\r\ndg->src.context, dg->src.resource,\r\n(unsigned long long)dg->payload_size);\r\ncid = vmci_ctx_get_id(vmci_host_dev->context);\r\nsend_info.result = vmci_datagram_dispatch(cid, dg, true);\r\nkfree(dg);\r\nreturn copy_to_user(uptr, &send_info, sizeof(send_info)) ? -EFAULT : 0;\r\n}\r\nstatic int vmci_host_do_receive_datagram(struct vmci_host_dev *vmci_host_dev,\r\nconst char *ioctl_name,\r\nvoid __user *uptr)\r\n{\r\nstruct vmci_datagram_snd_rcv_info recv_info;\r\nstruct vmci_datagram *dg = NULL;\r\nint retval;\r\nsize_t size;\r\nif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\r\nvmci_ioctl_err("only valid for contexts\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&recv_info, uptr, sizeof(recv_info)))\r\nreturn -EFAULT;\r\nsize = recv_info.len;\r\nrecv_info.result = vmci_ctx_dequeue_datagram(vmci_host_dev->context,\r\n&size, &dg);\r\nif (recv_info.result >= VMCI_SUCCESS) {\r\nvoid __user *ubuf = (void __user *)(uintptr_t)recv_info.addr;\r\nretval = copy_to_user(ubuf, dg, VMCI_DG_SIZE(dg));\r\nkfree(dg);\r\nif (retval != 0)\r\nreturn -EFAULT;\r\n}\r\nreturn copy_to_user(uptr, &recv_info, sizeof(recv_info)) ? -EFAULT : 0;\r\n}\r\nstatic int vmci_host_do_alloc_queuepair(struct vmci_host_dev *vmci_host_dev,\r\nconst char *ioctl_name,\r\nvoid __user *uptr)\r\n{\r\nstruct vmci_handle handle;\r\nint vmci_status;\r\nint __user *retptr;\r\nu32 cid;\r\nif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\r\nvmci_ioctl_err("only valid for contexts\n");\r\nreturn -EINVAL;\r\n}\r\ncid = vmci_ctx_get_id(vmci_host_dev->context);\r\nif (vmci_host_dev->user_version < VMCI_VERSION_NOVMVM) {\r\nstruct vmci_qp_alloc_info_vmvm alloc_info;\r\nstruct vmci_qp_alloc_info_vmvm __user *info = uptr;\r\nif (copy_from_user(&alloc_info, uptr, sizeof(alloc_info)))\r\nreturn -EFAULT;\r\nhandle = alloc_info.handle;\r\nretptr = &info->result;\r\nvmci_status = vmci_qp_broker_alloc(alloc_info.handle,\r\nalloc_info.peer,\r\nalloc_info.flags,\r\nVMCI_NO_PRIVILEGE_FLAGS,\r\nalloc_info.produce_size,\r\nalloc_info.consume_size,\r\nNULL,\r\nvmci_host_dev->context);\r\nif (vmci_status == VMCI_SUCCESS)\r\nvmci_status = VMCI_SUCCESS_QUEUEPAIR_CREATE;\r\n} else {\r\nstruct vmci_qp_alloc_info alloc_info;\r\nstruct vmci_qp_alloc_info __user *info = uptr;\r\nstruct vmci_qp_page_store page_store;\r\nif (copy_from_user(&alloc_info, uptr, sizeof(alloc_info)))\r\nreturn -EFAULT;\r\nhandle = alloc_info.handle;\r\nretptr = &info->result;\r\npage_store.pages = alloc_info.ppn_va;\r\npage_store.len = alloc_info.num_ppns;\r\nvmci_status = vmci_qp_broker_alloc(alloc_info.handle,\r\nalloc_info.peer,\r\nalloc_info.flags,\r\nVMCI_NO_PRIVILEGE_FLAGS,\r\nalloc_info.produce_size,\r\nalloc_info.consume_size,\r\n&page_store,\r\nvmci_host_dev->context);\r\n}\r\nif (put_user(vmci_status, retptr)) {\r\nif (vmci_status >= VMCI_SUCCESS) {\r\nvmci_status = vmci_qp_broker_detach(handle,\r\nvmci_host_dev->context);\r\n}\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmci_host_do_queuepair_setva(struct vmci_host_dev *vmci_host_dev,\r\nconst char *ioctl_name,\r\nvoid __user *uptr)\r\n{\r\nstruct vmci_qp_set_va_info set_va_info;\r\nstruct vmci_qp_set_va_info __user *info = uptr;\r\ns32 result;\r\nif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\r\nvmci_ioctl_err("only valid for contexts\n");\r\nreturn -EINVAL;\r\n}\r\nif (vmci_host_dev->user_version < VMCI_VERSION_NOVMVM) {\r\nvmci_ioctl_err("is not allowed\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&set_va_info, uptr, sizeof(set_va_info)))\r\nreturn -EFAULT;\r\nif (set_va_info.va) {\r\nresult = vmci_qp_broker_map(set_va_info.handle,\r\nvmci_host_dev->context,\r\nset_va_info.va);\r\n} else {\r\nresult = vmci_qp_broker_unmap(set_va_info.handle,\r\nvmci_host_dev->context, 0);\r\n}\r\nreturn put_user(result, &info->result) ? -EFAULT : 0;\r\n}\r\nstatic int vmci_host_do_queuepair_setpf(struct vmci_host_dev *vmci_host_dev,\r\nconst char *ioctl_name,\r\nvoid __user *uptr)\r\n{\r\nstruct vmci_qp_page_file_info page_file_info;\r\nstruct vmci_qp_page_file_info __user *info = uptr;\r\ns32 result;\r\nif (vmci_host_dev->user_version < VMCI_VERSION_HOSTQP ||\r\nvmci_host_dev->user_version >= VMCI_VERSION_NOVMVM) {\r\nvmci_ioctl_err("not supported on this VMX (version=%d)\n",\r\nvmci_host_dev->user_version);\r\nreturn -EINVAL;\r\n}\r\nif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\r\nvmci_ioctl_err("only valid for contexts\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&page_file_info, uptr, sizeof(*info)))\r\nreturn -EFAULT;\r\nif (put_user(VMCI_SUCCESS, &info->result)) {\r\nreturn -EFAULT;\r\n}\r\nresult = vmci_qp_broker_set_page_store(page_file_info.handle,\r\npage_file_info.produce_va,\r\npage_file_info.consume_va,\r\nvmci_host_dev->context);\r\nif (result < VMCI_SUCCESS) {\r\nif (put_user(result, &info->result)) {\r\nreturn -EFAULT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmci_host_do_qp_detach(struct vmci_host_dev *vmci_host_dev,\r\nconst char *ioctl_name,\r\nvoid __user *uptr)\r\n{\r\nstruct vmci_qp_dtch_info detach_info;\r\nstruct vmci_qp_dtch_info __user *info = uptr;\r\ns32 result;\r\nif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\r\nvmci_ioctl_err("only valid for contexts\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&detach_info, uptr, sizeof(detach_info)))\r\nreturn -EFAULT;\r\nresult = vmci_qp_broker_detach(detach_info.handle,\r\nvmci_host_dev->context);\r\nif (result == VMCI_SUCCESS &&\r\nvmci_host_dev->user_version < VMCI_VERSION_NOVMVM) {\r\nresult = VMCI_SUCCESS_LAST_DETACH;\r\n}\r\nreturn put_user(result, &info->result) ? -EFAULT : 0;\r\n}\r\nstatic int vmci_host_do_ctx_add_notify(struct vmci_host_dev *vmci_host_dev,\r\nconst char *ioctl_name,\r\nvoid __user *uptr)\r\n{\r\nstruct vmci_ctx_info ar_info;\r\nstruct vmci_ctx_info __user *info = uptr;\r\ns32 result;\r\nu32 cid;\r\nif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\r\nvmci_ioctl_err("only valid for contexts\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&ar_info, uptr, sizeof(ar_info)))\r\nreturn -EFAULT;\r\ncid = vmci_ctx_get_id(vmci_host_dev->context);\r\nresult = vmci_ctx_add_notification(cid, ar_info.remote_cid);\r\nreturn put_user(result, &info->result) ? -EFAULT : 0;\r\n}\r\nstatic int vmci_host_do_ctx_remove_notify(struct vmci_host_dev *vmci_host_dev,\r\nconst char *ioctl_name,\r\nvoid __user *uptr)\r\n{\r\nstruct vmci_ctx_info ar_info;\r\nstruct vmci_ctx_info __user *info = uptr;\r\nu32 cid;\r\nint result;\r\nif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\r\nvmci_ioctl_err("only valid for contexts\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&ar_info, uptr, sizeof(ar_info)))\r\nreturn -EFAULT;\r\ncid = vmci_ctx_get_id(vmci_host_dev->context);\r\nresult = vmci_ctx_remove_notification(cid,\r\nar_info.remote_cid);\r\nreturn put_user(result, &info->result) ? -EFAULT : 0;\r\n}\r\nstatic int vmci_host_do_ctx_get_cpt_state(struct vmci_host_dev *vmci_host_dev,\r\nconst char *ioctl_name,\r\nvoid __user *uptr)\r\n{\r\nstruct vmci_ctx_chkpt_buf_info get_info;\r\nu32 cid;\r\nvoid *cpt_buf;\r\nint retval;\r\nif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\r\nvmci_ioctl_err("only valid for contexts\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&get_info, uptr, sizeof(get_info)))\r\nreturn -EFAULT;\r\ncid = vmci_ctx_get_id(vmci_host_dev->context);\r\nget_info.result = vmci_ctx_get_chkpt_state(cid, get_info.cpt_type,\r\n&get_info.buf_size, &cpt_buf);\r\nif (get_info.result == VMCI_SUCCESS && get_info.buf_size) {\r\nvoid __user *ubuf = (void __user *)(uintptr_t)get_info.cpt_buf;\r\nretval = copy_to_user(ubuf, cpt_buf, get_info.buf_size);\r\nkfree(cpt_buf);\r\nif (retval)\r\nreturn -EFAULT;\r\n}\r\nreturn copy_to_user(uptr, &get_info, sizeof(get_info)) ? -EFAULT : 0;\r\n}\r\nstatic int vmci_host_do_ctx_set_cpt_state(struct vmci_host_dev *vmci_host_dev,\r\nconst char *ioctl_name,\r\nvoid __user *uptr)\r\n{\r\nstruct vmci_ctx_chkpt_buf_info set_info;\r\nu32 cid;\r\nvoid *cpt_buf;\r\nint retval;\r\nif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\r\nvmci_ioctl_err("only valid for contexts\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&set_info, uptr, sizeof(set_info)))\r\nreturn -EFAULT;\r\ncpt_buf = kmalloc(set_info.buf_size, GFP_KERNEL);\r\nif (!cpt_buf) {\r\nvmci_ioctl_err(\r\n"cannot allocate memory to set cpt state (type=%d)\n",\r\nset_info.cpt_type);\r\nreturn -ENOMEM;\r\n}\r\nif (copy_from_user(cpt_buf, (void __user *)(uintptr_t)set_info.cpt_buf,\r\nset_info.buf_size)) {\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\ncid = vmci_ctx_get_id(vmci_host_dev->context);\r\nset_info.result = vmci_ctx_set_chkpt_state(cid, set_info.cpt_type,\r\nset_info.buf_size, cpt_buf);\r\nretval = copy_to_user(uptr, &set_info, sizeof(set_info)) ? -EFAULT : 0;\r\nout:\r\nkfree(cpt_buf);\r\nreturn retval;\r\n}\r\nstatic int vmci_host_do_get_context_id(struct vmci_host_dev *vmci_host_dev,\r\nconst char *ioctl_name,\r\nvoid __user *uptr)\r\n{\r\nu32 __user *u32ptr = uptr;\r\nreturn put_user(VMCI_HOST_CONTEXT_ID, u32ptr) ? -EFAULT : 0;\r\n}\r\nstatic int vmci_host_do_set_notify(struct vmci_host_dev *vmci_host_dev,\r\nconst char *ioctl_name,\r\nvoid __user *uptr)\r\n{\r\nstruct vmci_set_notify_info notify_info;\r\nif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\r\nvmci_ioctl_err("only valid for contexts\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&notify_info, uptr, sizeof(notify_info)))\r\nreturn -EFAULT;\r\nif (notify_info.notify_uva) {\r\nnotify_info.result =\r\nvmci_host_setup_notify(vmci_host_dev->context,\r\nnotify_info.notify_uva);\r\n} else {\r\nvmci_ctx_unset_notify(vmci_host_dev->context);\r\nnotify_info.result = VMCI_SUCCESS;\r\n}\r\nreturn copy_to_user(uptr, &notify_info, sizeof(notify_info)) ?\r\n-EFAULT : 0;\r\n}\r\nstatic int vmci_host_do_notify_resource(struct vmci_host_dev *vmci_host_dev,\r\nconst char *ioctl_name,\r\nvoid __user *uptr)\r\n{\r\nstruct vmci_dbell_notify_resource_info info;\r\nu32 cid;\r\nif (vmci_host_dev->user_version < VMCI_VERSION_NOTIFY) {\r\nvmci_ioctl_err("invalid for current VMX versions\n");\r\nreturn -EINVAL;\r\n}\r\nif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\r\nvmci_ioctl_err("only valid for contexts\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&info, uptr, sizeof(info)))\r\nreturn -EFAULT;\r\ncid = vmci_ctx_get_id(vmci_host_dev->context);\r\nswitch (info.action) {\r\ncase VMCI_NOTIFY_RESOURCE_ACTION_NOTIFY:\r\nif (info.resource == VMCI_NOTIFY_RESOURCE_DOOR_BELL) {\r\nu32 flags = VMCI_NO_PRIVILEGE_FLAGS;\r\ninfo.result = vmci_ctx_notify_dbell(cid, info.handle,\r\nflags);\r\n} else {\r\ninfo.result = VMCI_ERROR_UNAVAILABLE;\r\n}\r\nbreak;\r\ncase VMCI_NOTIFY_RESOURCE_ACTION_CREATE:\r\ninfo.result = vmci_ctx_dbell_create(cid, info.handle);\r\nbreak;\r\ncase VMCI_NOTIFY_RESOURCE_ACTION_DESTROY:\r\ninfo.result = vmci_ctx_dbell_destroy(cid, info.handle);\r\nbreak;\r\ndefault:\r\nvmci_ioctl_err("got unknown action (action=%d)\n",\r\ninfo.action);\r\ninfo.result = VMCI_ERROR_INVALID_ARGS;\r\n}\r\nreturn copy_to_user(uptr, &info, sizeof(info)) ? -EFAULT : 0;\r\n}\r\nstatic int vmci_host_do_recv_notifications(struct vmci_host_dev *vmci_host_dev,\r\nconst char *ioctl_name,\r\nvoid __user *uptr)\r\n{\r\nstruct vmci_ctx_notify_recv_info info;\r\nstruct vmci_handle_arr *db_handle_array;\r\nstruct vmci_handle_arr *qp_handle_array;\r\nvoid __user *ubuf;\r\nu32 cid;\r\nint retval = 0;\r\nif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {\r\nvmci_ioctl_err("only valid for contexts\n");\r\nreturn -EINVAL;\r\n}\r\nif (vmci_host_dev->user_version < VMCI_VERSION_NOTIFY) {\r\nvmci_ioctl_err("not supported for the current vmx version\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&info, uptr, sizeof(info)))\r\nreturn -EFAULT;\r\nif ((info.db_handle_buf_size && !info.db_handle_buf_uva) ||\r\n(info.qp_handle_buf_size && !info.qp_handle_buf_uva)) {\r\nreturn -EINVAL;\r\n}\r\ncid = vmci_ctx_get_id(vmci_host_dev->context);\r\ninfo.result = vmci_ctx_rcv_notifications_get(cid,\r\n&db_handle_array, &qp_handle_array);\r\nif (info.result != VMCI_SUCCESS)\r\nreturn copy_to_user(uptr, &info, sizeof(info)) ? -EFAULT : 0;\r\nubuf = (void __user *)(uintptr_t)info.db_handle_buf_uva;\r\ninfo.result = drv_cp_harray_to_user(ubuf, &info.db_handle_buf_size,\r\ndb_handle_array, &retval);\r\nif (info.result == VMCI_SUCCESS && !retval) {\r\nubuf = (void __user *)(uintptr_t)info.qp_handle_buf_uva;\r\ninfo.result = drv_cp_harray_to_user(ubuf,\r\n&info.qp_handle_buf_size,\r\nqp_handle_array, &retval);\r\n}\r\nif (!retval && copy_to_user(uptr, &info, sizeof(info)))\r\nretval = -EFAULT;\r\nvmci_ctx_rcv_notifications_release(cid,\r\ndb_handle_array, qp_handle_array,\r\ninfo.result == VMCI_SUCCESS && !retval);\r\nreturn retval;\r\n}\r\nstatic long vmci_host_unlocked_ioctl(struct file *filp,\r\nunsigned int iocmd, unsigned long ioarg)\r\n{\r\n#define VMCI_DO_IOCTL(ioctl_name, ioctl_fn) do { \\r\nchar *name = __stringify(IOCTL_VMCI_ ## ioctl_name); \\r\nreturn vmci_host_do_ ## ioctl_fn( \\r\nvmci_host_dev, name, uptr); \\r\n} while (0)\r\nstruct vmci_host_dev *vmci_host_dev = filp->private_data;\r\nvoid __user *uptr = (void __user *)ioarg;\r\nswitch (iocmd) {\r\ncase IOCTL_VMCI_INIT_CONTEXT:\r\nVMCI_DO_IOCTL(INIT_CONTEXT, init_context);\r\ncase IOCTL_VMCI_DATAGRAM_SEND:\r\nVMCI_DO_IOCTL(DATAGRAM_SEND, send_datagram);\r\ncase IOCTL_VMCI_DATAGRAM_RECEIVE:\r\nVMCI_DO_IOCTL(DATAGRAM_RECEIVE, receive_datagram);\r\ncase IOCTL_VMCI_QUEUEPAIR_ALLOC:\r\nVMCI_DO_IOCTL(QUEUEPAIR_ALLOC, alloc_queuepair);\r\ncase IOCTL_VMCI_QUEUEPAIR_SETVA:\r\nVMCI_DO_IOCTL(QUEUEPAIR_SETVA, queuepair_setva);\r\ncase IOCTL_VMCI_QUEUEPAIR_SETPAGEFILE:\r\nVMCI_DO_IOCTL(QUEUEPAIR_SETPAGEFILE, queuepair_setpf);\r\ncase IOCTL_VMCI_QUEUEPAIR_DETACH:\r\nVMCI_DO_IOCTL(QUEUEPAIR_DETACH, qp_detach);\r\ncase IOCTL_VMCI_CTX_ADD_NOTIFICATION:\r\nVMCI_DO_IOCTL(CTX_ADD_NOTIFICATION, ctx_add_notify);\r\ncase IOCTL_VMCI_CTX_REMOVE_NOTIFICATION:\r\nVMCI_DO_IOCTL(CTX_REMOVE_NOTIFICATION, ctx_remove_notify);\r\ncase IOCTL_VMCI_CTX_GET_CPT_STATE:\r\nVMCI_DO_IOCTL(CTX_GET_CPT_STATE, ctx_get_cpt_state);\r\ncase IOCTL_VMCI_CTX_SET_CPT_STATE:\r\nVMCI_DO_IOCTL(CTX_SET_CPT_STATE, ctx_set_cpt_state);\r\ncase IOCTL_VMCI_GET_CONTEXT_ID:\r\nVMCI_DO_IOCTL(GET_CONTEXT_ID, get_context_id);\r\ncase IOCTL_VMCI_SET_NOTIFY:\r\nVMCI_DO_IOCTL(SET_NOTIFY, set_notify);\r\ncase IOCTL_VMCI_NOTIFY_RESOURCE:\r\nVMCI_DO_IOCTL(NOTIFY_RESOURCE, notify_resource);\r\ncase IOCTL_VMCI_NOTIFICATIONS_RECEIVE:\r\nVMCI_DO_IOCTL(NOTIFICATIONS_RECEIVE, recv_notifications);\r\ncase IOCTL_VMCI_VERSION:\r\ncase IOCTL_VMCI_VERSION2:\r\nreturn vmci_host_get_version(vmci_host_dev, iocmd, uptr);\r\ndefault:\r\npr_devel("%s: Unknown ioctl (iocmd=%d)\n", __func__, iocmd);\r\nreturn -EINVAL;\r\n}\r\n#undef VMCI_DO_IOCTL\r\n}\r\nint __init vmci_host_init(void)\r\n{\r\nint error;\r\nhost_context = vmci_ctx_create(VMCI_HOST_CONTEXT_ID,\r\nVMCI_DEFAULT_PROC_PRIVILEGE_FLAGS,\r\n-1, VMCI_VERSION, NULL);\r\nif (IS_ERR(host_context)) {\r\nerror = PTR_ERR(host_context);\r\npr_warn("Failed to initialize VMCIContext (error%d)\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = misc_register(&vmci_host_miscdev);\r\nif (error) {\r\npr_warn("Module registration error (name=%s, major=%d, minor=%d, err=%d)\n",\r\nvmci_host_miscdev.name,\r\nMISC_MAJOR, vmci_host_miscdev.minor,\r\nerror);\r\npr_warn("Unable to initialize host personality\n");\r\nvmci_ctx_destroy(host_context);\r\nreturn error;\r\n}\r\npr_info("VMCI host device registered (name=%s, major=%d, minor=%d)\n",\r\nvmci_host_miscdev.name, MISC_MAJOR, vmci_host_miscdev.minor);\r\nvmci_host_device_initialized = true;\r\nreturn 0;\r\n}\r\nvoid __exit vmci_host_exit(void)\r\n{\r\nvmci_host_device_initialized = false;\r\nmisc_deregister(&vmci_host_miscdev);\r\nvmci_ctx_destroy(host_context);\r\nvmci_qp_broker_exit();\r\npr_debug("VMCI host driver module unloaded\n");\r\n}
