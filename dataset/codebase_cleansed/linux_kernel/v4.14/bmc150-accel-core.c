static int bmc150_accel_set_mode(struct bmc150_accel_data *data,\r\nenum bmc150_power_modes mode,\r\nint dur_us)\r\n{\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nint i;\r\nint ret;\r\nu8 lpw_bits;\r\nint dur_val = -1;\r\nif (dur_us > 0) {\r\nfor (i = 0; i < ARRAY_SIZE(bmc150_accel_sleep_value_table);\r\n++i) {\r\nif (bmc150_accel_sleep_value_table[i].sleep_dur ==\r\ndur_us)\r\ndur_val =\r\nbmc150_accel_sleep_value_table[i].reg_value;\r\n}\r\n} else {\r\ndur_val = 0;\r\n}\r\nif (dur_val < 0)\r\nreturn -EINVAL;\r\nlpw_bits = mode << BMC150_ACCEL_PMU_MODE_SHIFT;\r\nlpw_bits |= (dur_val << BMC150_ACCEL_PMU_BIT_SLEEP_DUR_SHIFT);\r\ndev_dbg(dev, "Set Mode bits %x\n", lpw_bits);\r\nret = regmap_write(data->regmap, BMC150_ACCEL_REG_PMU_LPW, lpw_bits);\r\nif (ret < 0) {\r\ndev_err(dev, "Error writing reg_pmu_lpw\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bmc150_accel_set_bw(struct bmc150_accel_data *data, int val,\r\nint val2)\r\n{\r\nint i;\r\nint ret;\r\nfor (i = 0; i < ARRAY_SIZE(bmc150_accel_samp_freq_table); ++i) {\r\nif (bmc150_accel_samp_freq_table[i].val == val &&\r\nbmc150_accel_samp_freq_table[i].val2 == val2) {\r\nret = regmap_write(data->regmap,\r\nBMC150_ACCEL_REG_PMU_BW,\r\nbmc150_accel_samp_freq_table[i].bw_bits);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->bw_bits =\r\nbmc150_accel_samp_freq_table[i].bw_bits;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int bmc150_accel_update_slope(struct bmc150_accel_data *data)\r\n{\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nint ret;\r\nret = regmap_write(data->regmap, BMC150_ACCEL_REG_INT_6,\r\ndata->slope_thres);\r\nif (ret < 0) {\r\ndev_err(dev, "Error writing reg_int_6\n");\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(data->regmap, BMC150_ACCEL_REG_INT_5,\r\nBMC150_ACCEL_SLOPE_DUR_MASK, data->slope_dur);\r\nif (ret < 0) {\r\ndev_err(dev, "Error updating reg_int_5\n");\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "%s: %x %x\n", __func__, data->slope_thres,\r\ndata->slope_dur);\r\nreturn ret;\r\n}\r\nstatic int bmc150_accel_any_motion_setup(struct bmc150_accel_trigger *t,\r\nbool state)\r\n{\r\nif (state)\r\nreturn bmc150_accel_update_slope(t->data);\r\nreturn 0;\r\n}\r\nstatic int bmc150_accel_get_bw(struct bmc150_accel_data *data, int *val,\r\nint *val2)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(bmc150_accel_samp_freq_table); ++i) {\r\nif (bmc150_accel_samp_freq_table[i].bw_bits == data->bw_bits) {\r\n*val = bmc150_accel_samp_freq_table[i].val;\r\n*val2 = bmc150_accel_samp_freq_table[i].val2;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int bmc150_accel_get_startup_times(struct bmc150_accel_data *data)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(bmc150_accel_sample_upd_time); ++i) {\r\nif (bmc150_accel_sample_upd_time[i].bw_bits == data->bw_bits)\r\nreturn bmc150_accel_sample_upd_time[i].msec;\r\n}\r\nreturn BMC150_ACCEL_MAX_STARTUP_TIME_MS;\r\n}\r\nstatic int bmc150_accel_set_power_state(struct bmc150_accel_data *data, bool on)\r\n{\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nint ret;\r\nif (on) {\r\nret = pm_runtime_get_sync(dev);\r\n} else {\r\npm_runtime_mark_last_busy(dev);\r\nret = pm_runtime_put_autosuspend(dev);\r\n}\r\nif (ret < 0) {\r\ndev_err(dev,\r\n"Failed: bmc150_accel_set_power_state for %d\n", on);\r\nif (on)\r\npm_runtime_put_noidle(dev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bmc150_accel_set_power_state(struct bmc150_accel_data *data, bool on)\r\n{\r\nreturn 0;\r\n}\r\nstatic void bmc150_accel_interrupts_setup(struct iio_dev *indio_dev,\r\nstruct bmc150_accel_data *data)\r\n{\r\nint i;\r\nfor (i = 0; i < BMC150_ACCEL_INTERRUPTS; i++)\r\ndata->interrupts[i].info = &bmc150_accel_interrupts[i];\r\n}\r\nstatic int bmc150_accel_set_interrupt(struct bmc150_accel_data *data, int i,\r\nbool state)\r\n{\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nstruct bmc150_accel_interrupt *intr = &data->interrupts[i];\r\nconst struct bmc150_accel_interrupt_info *info = intr->info;\r\nint ret;\r\nif (state) {\r\nif (atomic_inc_return(&intr->users) > 1)\r\nreturn 0;\r\n} else {\r\nif (atomic_dec_return(&intr->users) > 0)\r\nreturn 0;\r\n}\r\nret = bmc150_accel_set_power_state(data, state);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_update_bits(data->regmap, info->map_reg, info->map_bitmask,\r\n(state ? info->map_bitmask : 0));\r\nif (ret < 0) {\r\ndev_err(dev, "Error updating reg_int_map\n");\r\ngoto out_fix_power_state;\r\n}\r\nret = regmap_update_bits(data->regmap, info->en_reg, info->en_bitmask,\r\n(state ? info->en_bitmask : 0));\r\nif (ret < 0) {\r\ndev_err(dev, "Error updating reg_int_en\n");\r\ngoto out_fix_power_state;\r\n}\r\nreturn 0;\r\nout_fix_power_state:\r\nbmc150_accel_set_power_state(data, false);\r\nreturn ret;\r\n}\r\nstatic int bmc150_accel_set_scale(struct bmc150_accel_data *data, int val)\r\n{\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nint ret, i;\r\nfor (i = 0; i < ARRAY_SIZE(data->chip_info->scale_table); ++i) {\r\nif (data->chip_info->scale_table[i].scale == val) {\r\nret = regmap_write(data->regmap,\r\nBMC150_ACCEL_REG_PMU_RANGE,\r\ndata->chip_info->scale_table[i].reg_range);\r\nif (ret < 0) {\r\ndev_err(dev, "Error writing pmu_range\n");\r\nreturn ret;\r\n}\r\ndata->range = data->chip_info->scale_table[i].reg_range;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int bmc150_accel_get_temp(struct bmc150_accel_data *data, int *val)\r\n{\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nint ret;\r\nunsigned int value;\r\nmutex_lock(&data->mutex);\r\nret = regmap_read(data->regmap, BMC150_ACCEL_REG_TEMP, &value);\r\nif (ret < 0) {\r\ndev_err(dev, "Error reading reg_temp\n");\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\n*val = sign_extend32(value, 7);\r\nmutex_unlock(&data->mutex);\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int bmc150_accel_get_axis(struct bmc150_accel_data *data,\r\nstruct iio_chan_spec const *chan,\r\nint *val)\r\n{\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nint ret;\r\nint axis = chan->scan_index;\r\n__le16 raw_val;\r\nmutex_lock(&data->mutex);\r\nret = bmc150_accel_set_power_state(data, true);\r\nif (ret < 0) {\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nret = regmap_bulk_read(data->regmap, BMC150_ACCEL_AXIS_TO_REG(axis),\r\n&raw_val, sizeof(raw_val));\r\nif (ret < 0) {\r\ndev_err(dev, "Error reading axis %d\n", axis);\r\nbmc150_accel_set_power_state(data, false);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\n*val = sign_extend32(le16_to_cpu(raw_val) >> chan->scan_type.shift,\r\nchan->scan_type.realbits - 1);\r\nret = bmc150_accel_set_power_state(data, false);\r\nmutex_unlock(&data->mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int bmc150_accel_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nswitch (chan->type) {\r\ncase IIO_TEMP:\r\nreturn bmc150_accel_get_temp(data, val);\r\ncase IIO_ACCEL:\r\nif (iio_buffer_enabled(indio_dev))\r\nreturn -EBUSY;\r\nelse\r\nreturn bmc150_accel_get_axis(data, chan, val);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_OFFSET:\r\nif (chan->type == IIO_TEMP) {\r\n*val = BMC150_ACCEL_TEMP_CENTER_VAL;\r\nreturn IIO_VAL_INT;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = 0;\r\nswitch (chan->type) {\r\ncase IIO_TEMP:\r\n*val2 = 500000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_ACCEL:\r\n{\r\nint i;\r\nconst struct bmc150_scale_info *si;\r\nint st_size = ARRAY_SIZE(data->chip_info->scale_table);\r\nfor (i = 0; i < st_size; ++i) {\r\nsi = &data->chip_info->scale_table[i];\r\nif (si->reg_range == data->range) {\r\n*val2 = si->scale;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nmutex_lock(&data->mutex);\r\nret = bmc150_accel_get_bw(data, val, val2);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int bmc150_accel_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nmutex_lock(&data->mutex);\r\nret = bmc150_accel_set_bw(data, val, val2);\r\nmutex_unlock(&data->mutex);\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (val)\r\nreturn -EINVAL;\r\nmutex_lock(&data->mutex);\r\nret = bmc150_accel_set_scale(data, val2);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int bmc150_accel_read_event(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint *val, int *val2)\r\n{\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\n*val2 = 0;\r\nswitch (info) {\r\ncase IIO_EV_INFO_VALUE:\r\n*val = data->slope_thres;\r\nbreak;\r\ncase IIO_EV_INFO_PERIOD:\r\n*val = data->slope_dur;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int bmc150_accel_write_event(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint val, int val2)\r\n{\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nif (data->ev_enable_state)\r\nreturn -EBUSY;\r\nswitch (info) {\r\ncase IIO_EV_INFO_VALUE:\r\ndata->slope_thres = val & BMC150_ACCEL_SLOPE_THRES_MASK;\r\nbreak;\r\ncase IIO_EV_INFO_PERIOD:\r\ndata->slope_dur = val & BMC150_ACCEL_SLOPE_DUR_MASK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bmc150_accel_read_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nreturn data->ev_enable_state;\r\n}\r\nstatic int bmc150_accel_write_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nint state)\r\n{\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nint ret;\r\nif (state == data->ev_enable_state)\r\nreturn 0;\r\nmutex_lock(&data->mutex);\r\nret = bmc150_accel_set_interrupt(data, BMC150_ACCEL_INT_ANY_MOTION,\r\nstate);\r\nif (ret < 0) {\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\ndata->ev_enable_state = state;\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nstatic int bmc150_accel_validate_trigger(struct iio_dev *indio_dev,\r\nstruct iio_trigger *trig)\r\n{\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nint i;\r\nfor (i = 0; i < BMC150_ACCEL_TRIGGERS; i++) {\r\nif (data->triggers[i].indio_trig == trig)\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t bmc150_accel_get_fifo_watermark(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nint wm;\r\nmutex_lock(&data->mutex);\r\nwm = data->watermark;\r\nmutex_unlock(&data->mutex);\r\nreturn sprintf(buf, "%d\n", wm);\r\n}\r\nstatic ssize_t bmc150_accel_get_fifo_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nbool state;\r\nmutex_lock(&data->mutex);\r\nstate = data->fifo_mode;\r\nmutex_unlock(&data->mutex);\r\nreturn sprintf(buf, "%d\n", state);\r\n}\r\nstatic int bmc150_accel_set_watermark(struct iio_dev *indio_dev, unsigned val)\r\n{\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nif (val > BMC150_ACCEL_FIFO_LENGTH)\r\nval = BMC150_ACCEL_FIFO_LENGTH;\r\nmutex_lock(&data->mutex);\r\ndata->watermark = val;\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nstatic int bmc150_accel_fifo_transfer(struct bmc150_accel_data *data,\r\nchar *buffer, int samples)\r\n{\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nint sample_length = 3 * 2;\r\nint ret;\r\nint total_length = samples * sample_length;\r\nint i;\r\nsize_t step = regmap_get_raw_read_max(data->regmap);\r\nif (!step || step > total_length)\r\nstep = total_length;\r\nelse if (step < total_length)\r\nstep = sample_length;\r\nfor (i = 0; i < total_length; i += step) {\r\nret = regmap_raw_read(data->regmap, BMC150_ACCEL_REG_FIFO_DATA,\r\n&buffer[i], step);\r\nif (ret)\r\nbreak;\r\n}\r\nif (ret)\r\ndev_err(dev,\r\n"Error transferring data from fifo in single steps of %zu\n",\r\nstep);\r\nreturn ret;\r\n}\r\nstatic int __bmc150_accel_fifo_flush(struct iio_dev *indio_dev,\r\nunsigned samples, bool irq)\r\n{\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nint ret, i;\r\nu8 count;\r\nu16 buffer[BMC150_ACCEL_FIFO_LENGTH * 3];\r\nint64_t tstamp;\r\nuint64_t sample_period;\r\nunsigned int val;\r\nret = regmap_read(data->regmap, BMC150_ACCEL_REG_FIFO_STATUS, &val);\r\nif (ret < 0) {\r\ndev_err(dev, "Error reading reg_fifo_status\n");\r\nreturn ret;\r\n}\r\ncount = val & 0x7F;\r\nif (!count)\r\nreturn 0;\r\nif (!irq) {\r\ndata->old_timestamp = data->timestamp;\r\ndata->timestamp = iio_get_time_ns(indio_dev);\r\n}\r\nsample_period = (data->timestamp - data->old_timestamp);\r\ndo_div(sample_period, count);\r\ntstamp = data->timestamp - (count - 1) * sample_period;\r\nif (samples && count > samples)\r\ncount = samples;\r\nret = bmc150_accel_fifo_transfer(data, (u8 *)buffer, count);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < count; i++) {\r\nu16 sample[8];\r\nint j, bit;\r\nj = 0;\r\nfor_each_set_bit(bit, indio_dev->active_scan_mask,\r\nindio_dev->masklength)\r\nmemcpy(&sample[j++], &buffer[i * 3 + bit], 2);\r\niio_push_to_buffers_with_timestamp(indio_dev, sample, tstamp);\r\ntstamp += sample_period;\r\n}\r\nreturn count;\r\n}\r\nstatic int bmc150_accel_fifo_flush(struct iio_dev *indio_dev, unsigned samples)\r\n{\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nret = __bmc150_accel_fifo_flush(indio_dev, samples, false);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t bmc150_accel_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nret = regmap_bulk_read(data->regmap, BMC150_ACCEL_REG_XOUT_L,\r\ndata->buffer, AXIS_MAX * 2);\r\nmutex_unlock(&data->mutex);\r\nif (ret < 0)\r\ngoto err_read;\r\niio_push_to_buffers_with_timestamp(indio_dev, data->buffer,\r\npf->timestamp);\r\nerr_read:\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bmc150_accel_trig_try_reen(struct iio_trigger *trig)\r\n{\r\nstruct bmc150_accel_trigger *t = iio_trigger_get_drvdata(trig);\r\nstruct bmc150_accel_data *data = t->data;\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nint ret;\r\nif (t == &t->data->triggers[BMC150_ACCEL_TRIGGER_DATA_READY])\r\nreturn 0;\r\nmutex_lock(&data->mutex);\r\nret = regmap_write(data->regmap, BMC150_ACCEL_REG_INT_RST_LATCH,\r\nBMC150_ACCEL_INT_MODE_LATCH_INT |\r\nBMC150_ACCEL_INT_MODE_LATCH_RESET);\r\nmutex_unlock(&data->mutex);\r\nif (ret < 0) {\r\ndev_err(dev, "Error writing reg_int_rst_latch\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bmc150_accel_trigger_set_state(struct iio_trigger *trig,\r\nbool state)\r\n{\r\nstruct bmc150_accel_trigger *t = iio_trigger_get_drvdata(trig);\r\nstruct bmc150_accel_data *data = t->data;\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nif (t->enabled == state) {\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nif (t->setup) {\r\nret = t->setup(t, state);\r\nif (ret < 0) {\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\n}\r\nret = bmc150_accel_set_interrupt(data, t->intr, state);\r\nif (ret < 0) {\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nt->enabled = state;\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nstatic int bmc150_accel_handle_roc_event(struct iio_dev *indio_dev)\r\n{\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nint dir;\r\nint ret;\r\nunsigned int val;\r\nret = regmap_read(data->regmap, BMC150_ACCEL_REG_INT_STATUS_2, &val);\r\nif (ret < 0) {\r\ndev_err(dev, "Error reading reg_int_status_2\n");\r\nreturn ret;\r\n}\r\nif (val & BMC150_ACCEL_ANY_MOTION_BIT_SIGN)\r\ndir = IIO_EV_DIR_FALLING;\r\nelse\r\ndir = IIO_EV_DIR_RISING;\r\nif (val & BMC150_ACCEL_ANY_MOTION_BIT_X)\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_ACCEL,\r\n0,\r\nIIO_MOD_X,\r\nIIO_EV_TYPE_ROC,\r\ndir),\r\ndata->timestamp);\r\nif (val & BMC150_ACCEL_ANY_MOTION_BIT_Y)\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_ACCEL,\r\n0,\r\nIIO_MOD_Y,\r\nIIO_EV_TYPE_ROC,\r\ndir),\r\ndata->timestamp);\r\nif (val & BMC150_ACCEL_ANY_MOTION_BIT_Z)\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_ACCEL,\r\n0,\r\nIIO_MOD_Z,\r\nIIO_EV_TYPE_ROC,\r\ndir),\r\ndata->timestamp);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t bmc150_accel_irq_thread_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nbool ack = false;\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nif (data->fifo_mode) {\r\nret = __bmc150_accel_fifo_flush(indio_dev,\r\nBMC150_ACCEL_FIFO_LENGTH, true);\r\nif (ret > 0)\r\nack = true;\r\n}\r\nif (data->ev_enable_state) {\r\nret = bmc150_accel_handle_roc_event(indio_dev);\r\nif (ret > 0)\r\nack = true;\r\n}\r\nif (ack) {\r\nret = regmap_write(data->regmap, BMC150_ACCEL_REG_INT_RST_LATCH,\r\nBMC150_ACCEL_INT_MODE_LATCH_INT |\r\nBMC150_ACCEL_INT_MODE_LATCH_RESET);\r\nif (ret)\r\ndev_err(dev, "Error writing reg_int_rst_latch\n");\r\nret = IRQ_HANDLED;\r\n} else {\r\nret = IRQ_NONE;\r\n}\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t bmc150_accel_irq_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nbool ack = false;\r\nint i;\r\ndata->old_timestamp = data->timestamp;\r\ndata->timestamp = iio_get_time_ns(indio_dev);\r\nfor (i = 0; i < BMC150_ACCEL_TRIGGERS; i++) {\r\nif (data->triggers[i].enabled) {\r\niio_trigger_poll(data->triggers[i].indio_trig);\r\nack = true;\r\nbreak;\r\n}\r\n}\r\nif (data->ev_enable_state || data->fifo_mode)\r\nreturn IRQ_WAKE_THREAD;\r\nif (ack)\r\nreturn IRQ_HANDLED;\r\nreturn IRQ_NONE;\r\n}\r\nstatic void bmc150_accel_unregister_triggers(struct bmc150_accel_data *data,\r\nint from)\r\n{\r\nint i;\r\nfor (i = from; i >= 0; i--) {\r\nif (data->triggers[i].indio_trig) {\r\niio_trigger_unregister(data->triggers[i].indio_trig);\r\ndata->triggers[i].indio_trig = NULL;\r\n}\r\n}\r\n}\r\nstatic int bmc150_accel_triggers_setup(struct iio_dev *indio_dev,\r\nstruct bmc150_accel_data *data)\r\n{\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nint i, ret;\r\nfor (i = 0; i < BMC150_ACCEL_TRIGGERS; i++) {\r\nstruct bmc150_accel_trigger *t = &data->triggers[i];\r\nt->indio_trig = devm_iio_trigger_alloc(dev,\r\nbmc150_accel_triggers[i].name,\r\nindio_dev->name,\r\nindio_dev->id);\r\nif (!t->indio_trig) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nt->indio_trig->dev.parent = dev;\r\nt->indio_trig->ops = &bmc150_accel_trigger_ops;\r\nt->intr = bmc150_accel_triggers[i].intr;\r\nt->data = data;\r\nt->setup = bmc150_accel_triggers[i].setup;\r\niio_trigger_set_drvdata(t->indio_trig, t);\r\nret = iio_trigger_register(t->indio_trig);\r\nif (ret)\r\nbreak;\r\n}\r\nif (ret)\r\nbmc150_accel_unregister_triggers(data, i - 1);\r\nreturn ret;\r\n}\r\nstatic int bmc150_accel_fifo_set_mode(struct bmc150_accel_data *data)\r\n{\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nu8 reg = BMC150_ACCEL_REG_FIFO_CONFIG1;\r\nint ret;\r\nret = regmap_write(data->regmap, reg, data->fifo_mode);\r\nif (ret < 0) {\r\ndev_err(dev, "Error writing reg_fifo_config1\n");\r\nreturn ret;\r\n}\r\nif (!data->fifo_mode)\r\nreturn 0;\r\nret = regmap_write(data->regmap, BMC150_ACCEL_REG_FIFO_CONFIG0,\r\ndata->watermark);\r\nif (ret < 0)\r\ndev_err(dev, "Error writing reg_fifo_config0\n");\r\nreturn ret;\r\n}\r\nstatic int bmc150_accel_buffer_preenable(struct iio_dev *indio_dev)\r\n{\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nreturn bmc150_accel_set_power_state(data, true);\r\n}\r\nstatic int bmc150_accel_buffer_postenable(struct iio_dev *indio_dev)\r\n{\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nint ret = 0;\r\nif (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED)\r\nreturn iio_triggered_buffer_postenable(indio_dev);\r\nmutex_lock(&data->mutex);\r\nif (!data->watermark)\r\ngoto out;\r\nret = bmc150_accel_set_interrupt(data, BMC150_ACCEL_INT_WATERMARK,\r\ntrue);\r\nif (ret)\r\ngoto out;\r\ndata->fifo_mode = BMC150_ACCEL_FIFO_MODE_FIFO;\r\nret = bmc150_accel_fifo_set_mode(data);\r\nif (ret) {\r\ndata->fifo_mode = 0;\r\nbmc150_accel_set_interrupt(data, BMC150_ACCEL_INT_WATERMARK,\r\nfalse);\r\n}\r\nout:\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nstatic int bmc150_accel_buffer_predisable(struct iio_dev *indio_dev)\r\n{\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nif (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED)\r\nreturn iio_triggered_buffer_predisable(indio_dev);\r\nmutex_lock(&data->mutex);\r\nif (!data->fifo_mode)\r\ngoto out;\r\nbmc150_accel_set_interrupt(data, BMC150_ACCEL_INT_WATERMARK, false);\r\n__bmc150_accel_fifo_flush(indio_dev, BMC150_ACCEL_FIFO_LENGTH, false);\r\ndata->fifo_mode = 0;\r\nbmc150_accel_fifo_set_mode(data);\r\nout:\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nstatic int bmc150_accel_buffer_postdisable(struct iio_dev *indio_dev)\r\n{\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nreturn bmc150_accel_set_power_state(data, false);\r\n}\r\nstatic int bmc150_accel_chip_init(struct bmc150_accel_data *data)\r\n{\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nint ret, i;\r\nunsigned int val;\r\nregmap_write(data->regmap, BMC150_ACCEL_REG_RESET,\r\nBMC150_ACCEL_RESET_VAL);\r\nusleep_range(1800, 2500);\r\nret = regmap_read(data->regmap, BMC150_ACCEL_REG_CHIP_ID, &val);\r\nif (ret < 0) {\r\ndev_err(dev, "Error: Reading chip id\n");\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "Chip Id %x\n", val);\r\nfor (i = 0; i < ARRAY_SIZE(bmc150_accel_chip_info_tbl); i++) {\r\nif (bmc150_accel_chip_info_tbl[i].chip_id == val) {\r\ndata->chip_info = &bmc150_accel_chip_info_tbl[i];\r\nbreak;\r\n}\r\n}\r\nif (!data->chip_info) {\r\ndev_err(dev, "Invalid chip %x\n", val);\r\nreturn -ENODEV;\r\n}\r\nret = bmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_NORMAL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = bmc150_accel_set_bw(data, BMC150_ACCEL_DEF_BW, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_write(data->regmap, BMC150_ACCEL_REG_PMU_RANGE,\r\nBMC150_ACCEL_DEF_RANGE_4G);\r\nif (ret < 0) {\r\ndev_err(dev, "Error writing reg_pmu_range\n");\r\nreturn ret;\r\n}\r\ndata->range = BMC150_ACCEL_DEF_RANGE_4G;\r\ndata->slope_thres = BMC150_ACCEL_DEF_SLOPE_THRESHOLD;\r\ndata->slope_dur = BMC150_ACCEL_DEF_SLOPE_DURATION;\r\nret = bmc150_accel_update_slope(data);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_write(data->regmap, BMC150_ACCEL_REG_INT_RST_LATCH,\r\nBMC150_ACCEL_INT_MODE_LATCH_INT |\r\nBMC150_ACCEL_INT_MODE_LATCH_RESET);\r\nif (ret < 0) {\r\ndev_err(dev, "Error writing reg_int_rst_latch\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint bmc150_accel_core_probe(struct device *dev, struct regmap *regmap, int irq,\r\nconst char *name, bool block_supported)\r\n{\r\nstruct bmc150_accel_data *data;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ndev_set_drvdata(dev, indio_dev);\r\ndata->irq = irq;\r\ndata->regmap = regmap;\r\nret = bmc150_accel_chip_init(data);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_init(&data->mutex);\r\nindio_dev->dev.parent = dev;\r\nindio_dev->channels = data->chip_info->channels;\r\nindio_dev->num_channels = data->chip_info->num_channels;\r\nindio_dev->name = name ? name : data->chip_info->name;\r\nindio_dev->available_scan_masks = bmc150_accel_scan_masks;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &bmc150_accel_info;\r\nret = iio_triggered_buffer_setup(indio_dev,\r\n&iio_pollfunc_store_time,\r\nbmc150_accel_trigger_handler,\r\n&bmc150_accel_buffer_ops);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed: iio triggered buffer setup\n");\r\nreturn ret;\r\n}\r\nif (data->irq > 0) {\r\nret = devm_request_threaded_irq(\r\ndev, data->irq,\r\nbmc150_accel_irq_handler,\r\nbmc150_accel_irq_thread_handler,\r\nIRQF_TRIGGER_RISING,\r\nBMC150_ACCEL_IRQ_NAME,\r\nindio_dev);\r\nif (ret)\r\ngoto err_buffer_cleanup;\r\nret = regmap_write(data->regmap, BMC150_ACCEL_REG_INT_RST_LATCH,\r\nBMC150_ACCEL_INT_MODE_LATCH_RESET);\r\nif (ret < 0) {\r\ndev_err(dev, "Error writing reg_int_rst_latch\n");\r\ngoto err_buffer_cleanup;\r\n}\r\nbmc150_accel_interrupts_setup(indio_dev, data);\r\nret = bmc150_accel_triggers_setup(indio_dev, data);\r\nif (ret)\r\ngoto err_buffer_cleanup;\r\nif (block_supported) {\r\nindio_dev->modes |= INDIO_BUFFER_SOFTWARE;\r\nindio_dev->info = &bmc150_accel_info_fifo;\r\niio_buffer_set_attrs(indio_dev->buffer,\r\nbmc150_accel_fifo_attributes);\r\n}\r\n}\r\nret = pm_runtime_set_active(dev);\r\nif (ret)\r\ngoto err_trigger_unregister;\r\npm_runtime_enable(dev);\r\npm_runtime_set_autosuspend_delay(dev, BMC150_AUTO_SUSPEND_DELAY_MS);\r\npm_runtime_use_autosuspend(dev);\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0) {\r\ndev_err(dev, "Unable to register iio device\n");\r\ngoto err_trigger_unregister;\r\n}\r\nreturn 0;\r\nerr_trigger_unregister:\r\nbmc150_accel_unregister_triggers(data, BMC150_ACCEL_TRIGGERS - 1);\r\nerr_buffer_cleanup:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nreturn ret;\r\n}\r\nint bmc150_accel_core_remove(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\npm_runtime_disable(dev);\r\npm_runtime_set_suspended(dev);\r\npm_runtime_put_noidle(dev);\r\nbmc150_accel_unregister_triggers(data, BMC150_ACCEL_TRIGGERS - 1);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nmutex_lock(&data->mutex);\r\nbmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_DEEP_SUSPEND, 0);\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nstatic int bmc150_accel_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nmutex_lock(&data->mutex);\r\nbmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_SUSPEND, 0);\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nstatic int bmc150_accel_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nmutex_lock(&data->mutex);\r\nbmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_NORMAL, 0);\r\nbmc150_accel_fifo_set_mode(data);\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nstatic int bmc150_accel_runtime_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nint ret;\r\ndev_dbg(dev, __func__);\r\nret = bmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_SUSPEND, 0);\r\nif (ret < 0)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int bmc150_accel_runtime_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct bmc150_accel_data *data = iio_priv(indio_dev);\r\nint ret;\r\nint sleep_val;\r\ndev_dbg(dev, __func__);\r\nret = bmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_NORMAL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = bmc150_accel_fifo_set_mode(data);\r\nif (ret < 0)\r\nreturn ret;\r\nsleep_val = bmc150_accel_get_startup_times(data);\r\nif (sleep_val < 20)\r\nusleep_range(sleep_val * 1000, 20000);\r\nelse\r\nmsleep_interruptible(sleep_val);\r\nreturn 0;\r\n}
