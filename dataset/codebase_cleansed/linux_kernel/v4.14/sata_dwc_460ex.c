static bool sata_dwc_dma_filter(struct dma_chan *chan, void *param)\r\n{\r\nstruct dw_dma_slave *dws = &sata_dwc_dma_dws;\r\nif (dws->dma_dev != chan->device->dev)\r\nreturn false;\r\nchan->private = dws;\r\nreturn true;\r\n}\r\nstatic int sata_dwc_dma_get_channel_old(struct sata_dwc_device_port *hsdevp)\r\n{\r\nstruct sata_dwc_device *hsdev = hsdevp->hsdev;\r\nstruct dw_dma_slave *dws = &sata_dwc_dma_dws;\r\ndma_cap_mask_t mask;\r\ndws->dma_dev = hsdev->dev;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nhsdevp->chan = dma_request_channel(mask, sata_dwc_dma_filter, hsdevp);\r\nif (!hsdevp->chan) {\r\ndev_err(hsdev->dev, "%s: dma channel unavailable\n",\r\n__func__);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sata_dwc_dma_init_old(struct platform_device *pdev,\r\nstruct sata_dwc_device *hsdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *res;\r\nhsdev->dma = devm_kzalloc(&pdev->dev, sizeof(*hsdev->dma), GFP_KERNEL);\r\nif (!hsdev->dma)\r\nreturn -ENOMEM;\r\nhsdev->dma->dev = &pdev->dev;\r\nhsdev->dma->irq = irq_of_parse_and_map(np, 1);\r\nif (hsdev->dma->irq == NO_IRQ) {\r\ndev_err(&pdev->dev, "no SATA DMA irq\n");\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nhsdev->dma->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(hsdev->dma->regs))\r\nreturn PTR_ERR(hsdev->dma->regs);\r\nreturn dw_dma_probe(hsdev->dma);\r\n}\r\nstatic void sata_dwc_dma_exit_old(struct sata_dwc_device *hsdev)\r\n{\r\nif (!hsdev->dma)\r\nreturn;\r\ndw_dma_remove(hsdev->dma);\r\n}\r\nstatic const char *get_prot_descript(u8 protocol)\r\n{\r\nswitch (protocol) {\r\ncase ATA_PROT_NODATA:\r\nreturn "ATA no data";\r\ncase ATA_PROT_PIO:\r\nreturn "ATA PIO";\r\ncase ATA_PROT_DMA:\r\nreturn "ATA DMA";\r\ncase ATA_PROT_NCQ:\r\nreturn "ATA NCQ";\r\ncase ATA_PROT_NCQ_NODATA:\r\nreturn "ATA NCQ no data";\r\ncase ATAPI_PROT_NODATA:\r\nreturn "ATAPI no data";\r\ncase ATAPI_PROT_PIO:\r\nreturn "ATAPI PIO";\r\ncase ATAPI_PROT_DMA:\r\nreturn "ATAPI DMA";\r\ndefault:\r\nreturn "unknown";\r\n}\r\n}\r\nstatic const char *get_dma_dir_descript(int dma_dir)\r\n{\r\nswitch ((enum dma_data_direction)dma_dir) {\r\ncase DMA_BIDIRECTIONAL:\r\nreturn "bidirectional";\r\ncase DMA_TO_DEVICE:\r\nreturn "to device";\r\ncase DMA_FROM_DEVICE:\r\nreturn "from device";\r\ndefault:\r\nreturn "none";\r\n}\r\n}\r\nstatic void sata_dwc_tf_dump(struct ata_port *ap, struct ata_taskfile *tf)\r\n{\r\ndev_vdbg(ap->dev,\r\n"taskfile cmd: 0x%02x protocol: %s flags: 0x%lx device: %x\n",\r\ntf->command, get_prot_descript(tf->protocol), tf->flags,\r\ntf->device);\r\ndev_vdbg(ap->dev,\r\n"feature: 0x%02x nsect: 0x%x lbal: 0x%x lbam: 0x%x lbah: 0x%x\n",\r\ntf->feature, tf->nsect, tf->lbal, tf->lbam, tf->lbah);\r\ndev_vdbg(ap->dev,\r\n"hob_feature: 0x%02x hob_nsect: 0x%x hob_lbal: 0x%x hob_lbam: 0x%x hob_lbah: 0x%x\n",\r\ntf->hob_feature, tf->hob_nsect, tf->hob_lbal, tf->hob_lbam,\r\ntf->hob_lbah);\r\n}\r\nstatic void dma_dwc_xfer_done(void *hsdev_instance)\r\n{\r\nunsigned long flags;\r\nstruct sata_dwc_device *hsdev = hsdev_instance;\r\nstruct ata_host *host = (struct ata_host *)hsdev->host;\r\nstruct ata_port *ap;\r\nstruct sata_dwc_device_port *hsdevp;\r\nu8 tag = 0;\r\nunsigned int port = 0;\r\nspin_lock_irqsave(&host->lock, flags);\r\nap = host->ports[port];\r\nhsdevp = HSDEVP_FROM_AP(ap);\r\ntag = ap->link.active_tag;\r\nhsdevp->dma_interrupt_count++;\r\nsata_dwc_clear_dmacr(hsdevp, tag);\r\nif (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_NONE) {\r\ndev_err(ap->dev, "DMA not pending tag=0x%02x pending=%d\n",\r\ntag, hsdevp->dma_pending[tag]);\r\n}\r\nif ((hsdevp->dma_interrupt_count % 2) == 0)\r\nsata_dwc_dma_xfer_complete(ap, 1);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic struct dma_async_tx_descriptor *dma_dwc_xfer_setup(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\r\nstruct sata_dwc_device *hsdev = HSDEV_FROM_AP(ap);\r\nstruct dma_slave_config sconf;\r\nstruct dma_async_tx_descriptor *desc;\r\nif (qc->dma_dir == DMA_DEV_TO_MEM) {\r\nsconf.src_addr = hsdev->dmadr;\r\nsconf.device_fc = false;\r\n} else {\r\nsconf.dst_addr = hsdev->dmadr;\r\nsconf.device_fc = false;\r\n}\r\nsconf.direction = qc->dma_dir;\r\nsconf.src_maxburst = AHB_DMA_BRST_DFLT / 4;\r\nsconf.dst_maxburst = AHB_DMA_BRST_DFLT / 4;\r\nsconf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nsconf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndmaengine_slave_config(hsdevp->chan, &sconf);\r\ndesc = dmaengine_prep_slave_sg(hsdevp->chan, qc->sg, qc->n_elem,\r\nqc->dma_dir,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc)\r\nreturn NULL;\r\ndesc->callback = dma_dwc_xfer_done;\r\ndesc->callback_param = hsdev;\r\ndev_dbg(hsdev->dev, "%s sg: 0x%p, count: %d addr: %pa\n", __func__,\r\nqc->sg, qc->n_elem, &hsdev->dmadr);\r\nreturn desc;\r\n}\r\nstatic int sata_dwc_scr_read(struct ata_link *link, unsigned int scr, u32 *val)\r\n{\r\nif (scr > SCR_NOTIFICATION) {\r\ndev_err(link->ap->dev, "%s: Incorrect SCR offset 0x%02x\n",\r\n__func__, scr);\r\nreturn -EINVAL;\r\n}\r\n*val = sata_dwc_readl(link->ap->ioaddr.scr_addr + (scr * 4));\r\ndev_dbg(link->ap->dev, "%s: id=%d reg=%d val=0x%08x\n", __func__,\r\nlink->ap->print_id, scr, *val);\r\nreturn 0;\r\n}\r\nstatic int sata_dwc_scr_write(struct ata_link *link, unsigned int scr, u32 val)\r\n{\r\ndev_dbg(link->ap->dev, "%s: id=%d reg=%d val=0x%08x\n", __func__,\r\nlink->ap->print_id, scr, val);\r\nif (scr > SCR_NOTIFICATION) {\r\ndev_err(link->ap->dev, "%s: Incorrect SCR offset 0x%02x\n",\r\n__func__, scr);\r\nreturn -EINVAL;\r\n}\r\nsata_dwc_writel(link->ap->ioaddr.scr_addr + (scr * 4), val);\r\nreturn 0;\r\n}\r\nstatic void clear_serror(struct ata_port *ap)\r\n{\r\nu32 val;\r\nsata_dwc_scr_read(&ap->link, SCR_ERROR, &val);\r\nsata_dwc_scr_write(&ap->link, SCR_ERROR, val);\r\n}\r\nstatic void clear_interrupt_bit(struct sata_dwc_device *hsdev, u32 bit)\r\n{\r\nsata_dwc_writel(&hsdev->sata_dwc_regs->intpr,\r\nsata_dwc_readl(&hsdev->sata_dwc_regs->intpr));\r\n}\r\nstatic u32 qcmd_tag_to_mask(u8 tag)\r\n{\r\nreturn 0x00000001 << (tag & 0x1f);\r\n}\r\nstatic void sata_dwc_error_intr(struct ata_port *ap,\r\nstruct sata_dwc_device *hsdev, uint intpr)\r\n{\r\nstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\r\nstruct ata_eh_info *ehi = &ap->link.eh_info;\r\nunsigned int err_mask = 0, action = 0;\r\nstruct ata_queued_cmd *qc;\r\nu32 serror;\r\nu8 status, tag;\r\nata_ehi_clear_desc(ehi);\r\nsata_dwc_scr_read(&ap->link, SCR_ERROR, &serror);\r\nstatus = ap->ops->sff_check_status(ap);\r\ntag = ap->link.active_tag;\r\ndev_err(ap->dev,\r\n"%s SCR_ERROR=0x%08x intpr=0x%08x status=0x%08x dma_intp=%d pending=%d issued=%d",\r\n__func__, serror, intpr, status, hsdevp->dma_interrupt_count,\r\nhsdevp->dma_pending[tag], hsdevp->cmd_issued[tag]);\r\nclear_serror(ap);\r\nclear_interrupt_bit(hsdev, SATA_DWC_INTPR_ERR);\r\nerr_mask |= AC_ERR_HOST_BUS;\r\naction |= ATA_EH_RESET;\r\nehi->serror |= serror;\r\nehi->action |= action;\r\nqc = ata_qc_from_tag(ap, tag);\r\nif (qc)\r\nqc->err_mask |= err_mask;\r\nelse\r\nehi->err_mask |= err_mask;\r\nata_port_abort(ap);\r\n}\r\nstatic irqreturn_t sata_dwc_isr(int irq, void *dev_instance)\r\n{\r\nstruct ata_host *host = (struct ata_host *)dev_instance;\r\nstruct sata_dwc_device *hsdev = HSDEV_FROM_HOST(host);\r\nstruct ata_port *ap;\r\nstruct ata_queued_cmd *qc;\r\nunsigned long flags;\r\nu8 status, tag;\r\nint handled, num_processed, port = 0;\r\nuint intpr, sactive, sactive2, tag_mask;\r\nstruct sata_dwc_device_port *hsdevp;\r\nhsdev->sactive_issued = 0;\r\nspin_lock_irqsave(&host->lock, flags);\r\nintpr = sata_dwc_readl(&hsdev->sata_dwc_regs->intpr);\r\nap = host->ports[port];\r\nhsdevp = HSDEVP_FROM_AP(ap);\r\ndev_dbg(ap->dev, "%s intpr=0x%08x active_tag=%d\n", __func__, intpr,\r\nap->link.active_tag);\r\nif (intpr & SATA_DWC_INTPR_ERR) {\r\nsata_dwc_error_intr(ap, hsdev, intpr);\r\nhandled = 1;\r\ngoto DONE;\r\n}\r\nif (intpr & SATA_DWC_INTPR_NEWFP) {\r\nclear_interrupt_bit(hsdev, SATA_DWC_INTPR_NEWFP);\r\ntag = (u8)(sata_dwc_readl(&hsdev->sata_dwc_regs->fptagr));\r\ndev_dbg(ap->dev, "%s: NEWFP tag=%d\n", __func__, tag);\r\nif (hsdevp->cmd_issued[tag] != SATA_DWC_CMD_ISSUED_PEND)\r\ndev_warn(ap->dev, "CMD tag=%d not pending?\n", tag);\r\nhsdev->sactive_issued |= qcmd_tag_to_mask(tag);\r\nqc = ata_qc_from_tag(ap, tag);\r\nqc->ap->link.active_tag = tag;\r\nsata_dwc_bmdma_start_by_tag(qc, tag);\r\nhandled = 1;\r\ngoto DONE;\r\n}\r\nsata_dwc_scr_read(&ap->link, SCR_ACTIVE, &sactive);\r\ntag_mask = (hsdev->sactive_issued | sactive) ^ sactive;\r\nif (hsdev->sactive_issued == 0 && tag_mask == 0) {\r\nif (ap->link.active_tag == ATA_TAG_POISON)\r\ntag = 0;\r\nelse\r\ntag = ap->link.active_tag;\r\nqc = ata_qc_from_tag(ap, tag);\r\nif (unlikely(!qc || (qc->tf.flags & ATA_TFLAG_POLLING))) {\r\ndev_err(ap->dev,\r\n"%s interrupt with no active qc qc=%p\n",\r\n__func__, qc);\r\nap->ops->sff_check_status(ap);\r\nhandled = 1;\r\ngoto DONE;\r\n}\r\nstatus = ap->ops->sff_check_status(ap);\r\nqc->ap->link.active_tag = tag;\r\nhsdevp->cmd_issued[tag] = SATA_DWC_CMD_ISSUED_NOT;\r\nif (status & ATA_ERR) {\r\ndev_dbg(ap->dev, "interrupt ATA_ERR (0x%x)\n", status);\r\nsata_dwc_qc_complete(ap, qc, 1);\r\nhandled = 1;\r\ngoto DONE;\r\n}\r\ndev_dbg(ap->dev, "%s non-NCQ cmd interrupt, protocol: %s\n",\r\n__func__, get_prot_descript(qc->tf.protocol));\r\nDRVSTILLBUSY:\r\nif (ata_is_dma(qc->tf.protocol)) {\r\nhsdevp->dma_interrupt_count++;\r\nif (hsdevp->dma_pending[tag] == \\r\nSATA_DWC_DMA_PENDING_NONE) {\r\ndev_err(ap->dev,\r\n"%s: DMA not pending intpr=0x%08x status=0x%08x pending=%d\n",\r\n__func__, intpr, status,\r\nhsdevp->dma_pending[tag]);\r\n}\r\nif ((hsdevp->dma_interrupt_count % 2) == 0)\r\nsata_dwc_dma_xfer_complete(ap, 1);\r\n} else if (ata_is_pio(qc->tf.protocol)) {\r\nata_sff_hsm_move(ap, qc, status, 0);\r\nhandled = 1;\r\ngoto DONE;\r\n} else {\r\nif (unlikely(sata_dwc_qc_complete(ap, qc, 1)))\r\ngoto DRVSTILLBUSY;\r\n}\r\nhandled = 1;\r\ngoto DONE;\r\n}\r\nsata_dwc_scr_read(&ap->link, SCR_ACTIVE, &sactive);\r\ntag_mask = (hsdev->sactive_issued | sactive) ^ sactive;\r\nif (sactive != 0 || hsdev->sactive_issued > 1 || tag_mask > 1) {\r\ndev_dbg(ap->dev,\r\n"%s NCQ:sactive=0x%08x sactive_issued=0x%08x tag_mask=0x%08x\n",\r\n__func__, sactive, hsdev->sactive_issued, tag_mask);\r\n}\r\nif ((tag_mask | hsdev->sactive_issued) != hsdev->sactive_issued) {\r\ndev_warn(ap->dev,\r\n"Bad tag mask? sactive=0x%08x sactive_issued=0x%08x tag_mask=0x%08x\n",\r\nsactive, hsdev->sactive_issued, tag_mask);\r\n}\r\nstatus = ap->ops->sff_check_status(ap);\r\ndev_dbg(ap->dev, "%s ATA status register=0x%x\n", __func__, status);\r\ntag = 0;\r\nnum_processed = 0;\r\nwhile (tag_mask) {\r\nnum_processed++;\r\nwhile (!(tag_mask & 0x00000001)) {\r\ntag++;\r\ntag_mask <<= 1;\r\n}\r\ntag_mask &= (~0x00000001);\r\nqc = ata_qc_from_tag(ap, tag);\r\nqc->ap->link.active_tag = tag;\r\nhsdevp->cmd_issued[tag] = SATA_DWC_CMD_ISSUED_NOT;\r\nif (status & ATA_ERR) {\r\ndev_dbg(ap->dev, "%s ATA_ERR (0x%x)\n", __func__,\r\nstatus);\r\nsata_dwc_qc_complete(ap, qc, 1);\r\nhandled = 1;\r\ngoto DONE;\r\n}\r\ndev_dbg(ap->dev, "%s NCQ command, protocol: %s\n", __func__,\r\nget_prot_descript(qc->tf.protocol));\r\nif (ata_is_dma(qc->tf.protocol)) {\r\nhsdevp->dma_interrupt_count++;\r\nif (hsdevp->dma_pending[tag] == \\r\nSATA_DWC_DMA_PENDING_NONE)\r\ndev_warn(ap->dev, "%s: DMA not pending?\n",\r\n__func__);\r\nif ((hsdevp->dma_interrupt_count % 2) == 0)\r\nsata_dwc_dma_xfer_complete(ap, 1);\r\n} else {\r\nif (unlikely(sata_dwc_qc_complete(ap, qc, 1)))\r\ngoto STILLBUSY;\r\n}\r\ncontinue;\r\nSTILLBUSY:\r\nap->stats.idle_irq++;\r\ndev_warn(ap->dev, "STILL BUSY IRQ ata%d: irq trap\n",\r\nap->print_id);\r\n}\r\nsata_dwc_scr_read(&ap->link, SCR_ACTIVE, &sactive2);\r\nif (sactive2 != sactive) {\r\ndev_dbg(ap->dev,\r\n"More completed - sactive=0x%x sactive2=0x%x\n",\r\nsactive, sactive2);\r\n}\r\nhandled = 1;\r\nDONE:\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void sata_dwc_clear_dmacr(struct sata_dwc_device_port *hsdevp, u8 tag)\r\n{\r\nstruct sata_dwc_device *hsdev = HSDEV_FROM_HSDEVP(hsdevp);\r\nu32 dmacr = sata_dwc_readl(&hsdev->sata_dwc_regs->dmacr);\r\nif (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_RX) {\r\ndmacr = SATA_DWC_DMACR_RX_CLEAR(dmacr);\r\nsata_dwc_writel(&hsdev->sata_dwc_regs->dmacr, dmacr);\r\n} else if (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_TX) {\r\ndmacr = SATA_DWC_DMACR_TX_CLEAR(dmacr);\r\nsata_dwc_writel(&hsdev->sata_dwc_regs->dmacr, dmacr);\r\n} else {\r\ndev_err(hsdev->dev,\r\n"%s DMA protocol RX and TX DMA not pending tag=0x%02x pending=%d dmacr: 0x%08x\n",\r\n__func__, tag, hsdevp->dma_pending[tag], dmacr);\r\nsata_dwc_writel(&hsdev->sata_dwc_regs->dmacr,\r\nSATA_DWC_DMACR_TXRXCH_CLEAR);\r\n}\r\n}\r\nstatic void sata_dwc_dma_xfer_complete(struct ata_port *ap, u32 check_status)\r\n{\r\nstruct ata_queued_cmd *qc;\r\nstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\r\nstruct sata_dwc_device *hsdev = HSDEV_FROM_AP(ap);\r\nu8 tag = 0;\r\ntag = ap->link.active_tag;\r\nqc = ata_qc_from_tag(ap, tag);\r\nif (!qc) {\r\ndev_err(ap->dev, "failed to get qc");\r\nreturn;\r\n}\r\n#ifdef DEBUG_NCQ\r\nif (tag > 0) {\r\ndev_info(ap->dev,\r\n"%s tag=%u cmd=0x%02x dma dir=%s proto=%s dmacr=0x%08x\n",\r\n__func__, qc->tag, qc->tf.command,\r\nget_dma_dir_descript(qc->dma_dir),\r\nget_prot_descript(qc->tf.protocol),\r\nsata_dwc_readl(&hsdev->sata_dwc_regs->dmacr));\r\n}\r\n#endif\r\nif (ata_is_dma(qc->tf.protocol)) {\r\nif (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_NONE) {\r\ndev_err(ap->dev,\r\n"%s DMA protocol RX and TX DMA not pending dmacr: 0x%08x\n",\r\n__func__,\r\nsata_dwc_readl(&hsdev->sata_dwc_regs->dmacr));\r\n}\r\nhsdevp->dma_pending[tag] = SATA_DWC_DMA_PENDING_NONE;\r\nsata_dwc_qc_complete(ap, qc, check_status);\r\nap->link.active_tag = ATA_TAG_POISON;\r\n} else {\r\nsata_dwc_qc_complete(ap, qc, check_status);\r\n}\r\n}\r\nstatic int sata_dwc_qc_complete(struct ata_port *ap, struct ata_queued_cmd *qc,\r\nu32 check_status)\r\n{\r\nu8 status = 0;\r\nu32 mask = 0x0;\r\nu8 tag = qc->tag;\r\nstruct sata_dwc_device *hsdev = HSDEV_FROM_AP(ap);\r\nstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\r\nhsdev->sactive_queued = 0;\r\ndev_dbg(ap->dev, "%s checkstatus? %x\n", __func__, check_status);\r\nif (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_TX)\r\ndev_err(ap->dev, "TX DMA PENDING\n");\r\nelse if (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_RX)\r\ndev_err(ap->dev, "RX DMA PENDING\n");\r\ndev_dbg(ap->dev,\r\n"QC complete cmd=0x%02x status=0x%02x ata%u: protocol=%d\n",\r\nqc->tf.command, status, ap->print_id, qc->tf.protocol);\r\nmask = (~(qcmd_tag_to_mask(tag)));\r\nhsdev->sactive_queued = hsdev->sactive_queued & mask;\r\nhsdev->sactive_issued = hsdev->sactive_issued & mask;\r\nata_qc_complete(qc);\r\nreturn 0;\r\n}\r\nstatic void sata_dwc_enable_interrupts(struct sata_dwc_device *hsdev)\r\n{\r\nsata_dwc_writel(&hsdev->sata_dwc_regs->intmr,\r\nSATA_DWC_INTMR_ERRM |\r\nSATA_DWC_INTMR_NEWFPM |\r\nSATA_DWC_INTMR_PMABRTM |\r\nSATA_DWC_INTMR_DMATM);\r\nsata_dwc_writel(&hsdev->sata_dwc_regs->errmr, SATA_DWC_SERROR_ERR_BITS);\r\ndev_dbg(hsdev->dev, "%s: INTMR = 0x%08x, ERRMR = 0x%08x\n",\r\n__func__, sata_dwc_readl(&hsdev->sata_dwc_regs->intmr),\r\nsata_dwc_readl(&hsdev->sata_dwc_regs->errmr));\r\n}\r\nstatic void sata_dwc_setup_port(struct ata_ioports *port, void __iomem *base)\r\n{\r\nport->cmd_addr = base + 0x00;\r\nport->data_addr = base + 0x00;\r\nport->error_addr = base + 0x04;\r\nport->feature_addr = base + 0x04;\r\nport->nsect_addr = base + 0x08;\r\nport->lbal_addr = base + 0x0c;\r\nport->lbam_addr = base + 0x10;\r\nport->lbah_addr = base + 0x14;\r\nport->device_addr = base + 0x18;\r\nport->command_addr = base + 0x1c;\r\nport->status_addr = base + 0x1c;\r\nport->altstatus_addr = base + 0x20;\r\nport->ctl_addr = base + 0x20;\r\n}\r\nstatic int sata_dwc_dma_get_channel(struct sata_dwc_device_port *hsdevp)\r\n{\r\nstruct sata_dwc_device *hsdev = hsdevp->hsdev;\r\nstruct device *dev = hsdev->dev;\r\n#ifdef CONFIG_SATA_DWC_OLD_DMA\r\nif (!of_find_property(dev->of_node, "dmas", NULL))\r\nreturn sata_dwc_dma_get_channel_old(hsdevp);\r\n#endif\r\nhsdevp->chan = dma_request_chan(dev, "sata-dma");\r\nif (IS_ERR(hsdevp->chan)) {\r\ndev_err(dev, "failed to allocate dma channel: %ld\n",\r\nPTR_ERR(hsdevp->chan));\r\nreturn PTR_ERR(hsdevp->chan);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sata_dwc_port_start(struct ata_port *ap)\r\n{\r\nint err = 0;\r\nstruct sata_dwc_device *hsdev;\r\nstruct sata_dwc_device_port *hsdevp = NULL;\r\nstruct device *pdev;\r\nint i;\r\nhsdev = HSDEV_FROM_AP(ap);\r\ndev_dbg(ap->dev, "%s: port_no=%d\n", __func__, ap->port_no);\r\nhsdev->host = ap->host;\r\npdev = ap->host->dev;\r\nif (!pdev) {\r\ndev_err(ap->dev, "%s: no ap->host->dev\n", __func__);\r\nerr = -ENODEV;\r\ngoto CLEANUP;\r\n}\r\nhsdevp = kzalloc(sizeof(*hsdevp), GFP_KERNEL);\r\nif (!hsdevp) {\r\ndev_err(ap->dev, "%s: kmalloc failed for hsdevp\n", __func__);\r\nerr = -ENOMEM;\r\ngoto CLEANUP;\r\n}\r\nhsdevp->hsdev = hsdev;\r\nerr = sata_dwc_dma_get_channel(hsdevp);\r\nif (err)\r\ngoto CLEANUP_ALLOC;\r\nerr = phy_power_on(hsdev->phy);\r\nif (err)\r\ngoto CLEANUP_ALLOC;\r\nfor (i = 0; i < SATA_DWC_QCMD_MAX; i++)\r\nhsdevp->cmd_issued[i] = SATA_DWC_CMD_ISSUED_NOT;\r\nap->bmdma_prd = NULL;\r\nap->bmdma_prd_dma = 0;\r\nif (ap->port_no == 0) {\r\ndev_dbg(ap->dev, "%s: clearing TXCHEN, RXCHEN in DMAC\n",\r\n__func__);\r\nsata_dwc_writel(&hsdev->sata_dwc_regs->dmacr,\r\nSATA_DWC_DMACR_TXRXCH_CLEAR);\r\ndev_dbg(ap->dev, "%s: setting burst size in DBTSR\n",\r\n__func__);\r\nsata_dwc_writel(&hsdev->sata_dwc_regs->dbtsr,\r\n(SATA_DWC_DBTSR_MWR(AHB_DMA_BRST_DFLT) |\r\nSATA_DWC_DBTSR_MRD(AHB_DMA_BRST_DFLT)));\r\n}\r\nclear_serror(ap);\r\nap->private_data = hsdevp;\r\ndev_dbg(ap->dev, "%s: done\n", __func__);\r\nreturn 0;\r\nCLEANUP_ALLOC:\r\nkfree(hsdevp);\r\nCLEANUP:\r\ndev_dbg(ap->dev, "%s: fail. ap->id = %d\n", __func__, ap->print_id);\r\nreturn err;\r\n}\r\nstatic void sata_dwc_port_stop(struct ata_port *ap)\r\n{\r\nstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\r\nstruct sata_dwc_device *hsdev = HSDEV_FROM_AP(ap);\r\ndev_dbg(ap->dev, "%s: ap->id = %d\n", __func__, ap->print_id);\r\ndmaengine_terminate_sync(hsdevp->chan);\r\ndma_release_channel(hsdevp->chan);\r\nphy_power_off(hsdev->phy);\r\nkfree(hsdevp);\r\nap->private_data = NULL;\r\n}\r\nstatic void sata_dwc_exec_command_by_tag(struct ata_port *ap,\r\nstruct ata_taskfile *tf,\r\nu8 tag, u32 cmd_issued)\r\n{\r\nstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\r\ndev_dbg(ap->dev, "%s cmd(0x%02x): %s tag=%d\n", __func__, tf->command,\r\nata_get_cmd_descript(tf->command), tag);\r\nhsdevp->cmd_issued[tag] = cmd_issued;\r\nclear_serror(ap);\r\nata_sff_exec_command(ap, tf);\r\n}\r\nstatic void sata_dwc_bmdma_setup_by_tag(struct ata_queued_cmd *qc, u8 tag)\r\n{\r\nsata_dwc_exec_command_by_tag(qc->ap, &qc->tf, tag,\r\nSATA_DWC_CMD_ISSUED_PEND);\r\n}\r\nstatic void sata_dwc_bmdma_setup(struct ata_queued_cmd *qc)\r\n{\r\nu8 tag = qc->tag;\r\nif (ata_is_ncq(qc->tf.protocol)) {\r\ndev_dbg(qc->ap->dev, "%s: ap->link.sactive=0x%08x tag=%d\n",\r\n__func__, qc->ap->link.sactive, tag);\r\n} else {\r\ntag = 0;\r\n}\r\nsata_dwc_bmdma_setup_by_tag(qc, tag);\r\n}\r\nstatic void sata_dwc_bmdma_start_by_tag(struct ata_queued_cmd *qc, u8 tag)\r\n{\r\nint start_dma;\r\nu32 reg;\r\nstruct sata_dwc_device *hsdev = HSDEV_FROM_QC(qc);\r\nstruct ata_port *ap = qc->ap;\r\nstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\r\nstruct dma_async_tx_descriptor *desc = hsdevp->desc[tag];\r\nint dir = qc->dma_dir;\r\nif (hsdevp->cmd_issued[tag] != SATA_DWC_CMD_ISSUED_NOT) {\r\nstart_dma = 1;\r\nif (dir == DMA_TO_DEVICE)\r\nhsdevp->dma_pending[tag] = SATA_DWC_DMA_PENDING_TX;\r\nelse\r\nhsdevp->dma_pending[tag] = SATA_DWC_DMA_PENDING_RX;\r\n} else {\r\ndev_err(ap->dev,\r\n"%s: Command not pending cmd_issued=%d (tag=%d) DMA NOT started\n",\r\n__func__, hsdevp->cmd_issued[tag], tag);\r\nstart_dma = 0;\r\n}\r\ndev_dbg(ap->dev,\r\n"%s qc=%p tag: %x cmd: 0x%02x dma_dir: %s start_dma? %x\n",\r\n__func__, qc, tag, qc->tf.command,\r\nget_dma_dir_descript(qc->dma_dir), start_dma);\r\nsata_dwc_tf_dump(ap, &qc->tf);\r\nif (start_dma) {\r\nsata_dwc_scr_read(&ap->link, SCR_ERROR, &reg);\r\nif (reg & SATA_DWC_SERROR_ERR_BITS) {\r\ndev_err(ap->dev, "%s: ****** SError=0x%08x ******\n",\r\n__func__, reg);\r\n}\r\nif (dir == DMA_TO_DEVICE)\r\nsata_dwc_writel(&hsdev->sata_dwc_regs->dmacr,\r\nSATA_DWC_DMACR_TXCHEN);\r\nelse\r\nsata_dwc_writel(&hsdev->sata_dwc_regs->dmacr,\r\nSATA_DWC_DMACR_RXCHEN);\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(hsdevp->chan);\r\n}\r\n}\r\nstatic void sata_dwc_bmdma_start(struct ata_queued_cmd *qc)\r\n{\r\nu8 tag = qc->tag;\r\nif (ata_is_ncq(qc->tf.protocol)) {\r\ndev_dbg(qc->ap->dev, "%s: ap->link.sactive=0x%08x tag=%d\n",\r\n__func__, qc->ap->link.sactive, tag);\r\n} else {\r\ntag = 0;\r\n}\r\ndev_dbg(qc->ap->dev, "%s\n", __func__);\r\nsata_dwc_bmdma_start_by_tag(qc, tag);\r\n}\r\nstatic unsigned int sata_dwc_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nu32 sactive;\r\nu8 tag = qc->tag;\r\nstruct ata_port *ap = qc->ap;\r\nstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\r\n#ifdef DEBUG_NCQ\r\nif (qc->tag > 0 || ap->link.sactive > 1)\r\ndev_info(ap->dev,\r\n"%s ap id=%d cmd(0x%02x)=%s qc tag=%d prot=%s ap active_tag=0x%08x ap sactive=0x%08x\n",\r\n__func__, ap->print_id, qc->tf.command,\r\nata_get_cmd_descript(qc->tf.command),\r\nqc->tag, get_prot_descript(qc->tf.protocol),\r\nap->link.active_tag, ap->link.sactive);\r\n#endif\r\nif (!ata_is_ncq(qc->tf.protocol))\r\ntag = 0;\r\nif (ata_is_dma(qc->tf.protocol)) {\r\nhsdevp->desc[tag] = dma_dwc_xfer_setup(qc);\r\nif (!hsdevp->desc[tag])\r\nreturn AC_ERR_SYSTEM;\r\n} else {\r\nhsdevp->desc[tag] = NULL;\r\n}\r\nif (ata_is_ncq(qc->tf.protocol)) {\r\nsata_dwc_scr_read(&ap->link, SCR_ACTIVE, &sactive);\r\nsactive |= (0x00000001 << tag);\r\nsata_dwc_scr_write(&ap->link, SCR_ACTIVE, sactive);\r\ndev_dbg(qc->ap->dev,\r\n"%s: tag=%d ap->link.sactive = 0x%08x sactive=0x%08x\n",\r\n__func__, tag, qc->ap->link.sactive, sactive);\r\nap->ops->sff_tf_load(ap, &qc->tf);\r\nsata_dwc_exec_command_by_tag(ap, &qc->tf, tag,\r\nSATA_DWC_CMD_ISSUED_PEND);\r\n} else {\r\nreturn ata_bmdma_qc_issue(qc);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sata_dwc_error_handler(struct ata_port *ap)\r\n{\r\nata_sff_error_handler(ap);\r\n}\r\nstatic int sata_dwc_hardreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nstruct sata_dwc_device *hsdev = HSDEV_FROM_AP(link->ap);\r\nint ret;\r\nret = sata_sff_hardreset(link, class, deadline);\r\nsata_dwc_enable_interrupts(hsdev);\r\nsata_dwc_writel(&hsdev->sata_dwc_regs->dmacr,\r\nSATA_DWC_DMACR_TXRXCH_CLEAR);\r\nsata_dwc_writel(&hsdev->sata_dwc_regs->dbtsr,\r\nSATA_DWC_DBTSR_MWR(AHB_DMA_BRST_DFLT) |\r\nSATA_DWC_DBTSR_MRD(AHB_DMA_BRST_DFLT));\r\nreturn ret;\r\n}\r\nstatic void sata_dwc_dev_select(struct ata_port *ap, unsigned int device)\r\n{\r\n}\r\nstatic int sata_dwc_probe(struct platform_device *ofdev)\r\n{\r\nstruct sata_dwc_device *hsdev;\r\nu32 idr, versionr;\r\nchar *ver = (char *)&versionr;\r\nvoid __iomem *base;\r\nint err = 0;\r\nint irq;\r\nstruct ata_host *host;\r\nstruct ata_port_info pi = sata_dwc_port_info[0];\r\nconst struct ata_port_info *ppi[] = { &pi, NULL };\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct resource *res;\r\nhost = ata_host_alloc_pinfo(&ofdev->dev, ppi, SATA_DWC_MAX_PORTS);\r\nhsdev = devm_kzalloc(&ofdev->dev, sizeof(*hsdev), GFP_KERNEL);\r\nif (!host || !hsdev)\r\nreturn -ENOMEM;\r\nhost->private_data = hsdev;\r\nres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&ofdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ndev_dbg(&ofdev->dev, "ioremap done for SATA register address\n");\r\nhsdev->sata_dwc_regs = base + SATA_DWC_REG_OFFSET;\r\nhsdev->dmadr = res->start + SATA_DWC_REG_OFFSET + offsetof(struct sata_dwc_regs, dmadr);\r\nhost->ports[0]->ioaddr.cmd_addr = base;\r\nhost->ports[0]->ioaddr.scr_addr = base + SATA_DWC_SCR_OFFSET;\r\nsata_dwc_setup_port(&host->ports[0]->ioaddr, base);\r\nidr = sata_dwc_readl(&hsdev->sata_dwc_regs->idr);\r\nversionr = sata_dwc_readl(&hsdev->sata_dwc_regs->versionr);\r\ndev_notice(&ofdev->dev, "id %d, controller version %c.%c%c\n",\r\nidr, ver[0], ver[1], ver[2]);\r\nhsdev->dev = &ofdev->dev;\r\nsata_dwc_enable_interrupts(hsdev);\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (irq == NO_IRQ) {\r\ndev_err(&ofdev->dev, "no SATA DMA irq\n");\r\nerr = -ENODEV;\r\ngoto error_out;\r\n}\r\n#ifdef CONFIG_SATA_DWC_OLD_DMA\r\nif (!of_find_property(np, "dmas", NULL)) {\r\nerr = sata_dwc_dma_init_old(ofdev, hsdev);\r\nif (err)\r\ngoto error_out;\r\n}\r\n#endif\r\nhsdev->phy = devm_phy_optional_get(hsdev->dev, "sata-phy");\r\nif (IS_ERR(hsdev->phy)) {\r\nerr = PTR_ERR(hsdev->phy);\r\nhsdev->phy = NULL;\r\ngoto error_out;\r\n}\r\nerr = phy_init(hsdev->phy);\r\nif (err)\r\ngoto error_out;\r\nerr = ata_host_activate(host, irq, sata_dwc_isr, 0, &sata_dwc_sht);\r\nif (err)\r\ndev_err(&ofdev->dev, "failed to activate host");\r\nreturn 0;\r\nerror_out:\r\nphy_exit(hsdev->phy);\r\nreturn err;\r\n}\r\nstatic int sata_dwc_remove(struct platform_device *ofdev)\r\n{\r\nstruct device *dev = &ofdev->dev;\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct sata_dwc_device *hsdev = host->private_data;\r\nata_host_detach(host);\r\nphy_exit(hsdev->phy);\r\n#ifdef CONFIG_SATA_DWC_OLD_DMA\r\nsata_dwc_dma_exit_old(hsdev);\r\n#endif\r\ndev_dbg(&ofdev->dev, "done\n");\r\nreturn 0;\r\n}
