int rmi_f03_overwrite_button(struct rmi_function *fn, unsigned int button,\r\nint value)\r\n{\r\nstruct f03_data *f03 = dev_get_drvdata(&fn->dev);\r\nunsigned int bit;\r\nif (button < BTN_LEFT || button > BTN_MIDDLE)\r\nreturn -EINVAL;\r\nbit = BIT(button - BTN_LEFT);\r\nif (value)\r\nf03->overwrite_buttons |= bit;\r\nelse\r\nf03->overwrite_buttons &= ~bit;\r\nreturn 0;\r\n}\r\nvoid rmi_f03_commit_buttons(struct rmi_function *fn)\r\n{\r\nstruct f03_data *f03 = dev_get_drvdata(&fn->dev);\r\nstruct serio *serio = f03->serio;\r\nserio_pause_rx(serio);\r\nif (serio->drv) {\r\nserio->drv->interrupt(serio, PSMOUSE_OOB_EXTRA_BTNS,\r\nSERIO_OOB_DATA);\r\nserio->drv->interrupt(serio, f03->overwrite_buttons,\r\nSERIO_OOB_DATA);\r\n}\r\nserio_continue_rx(serio);\r\n}\r\nstatic int rmi_f03_pt_write(struct serio *id, unsigned char val)\r\n{\r\nstruct f03_data *f03 = id->port_data;\r\nint error;\r\nrmi_dbg(RMI_DEBUG_FN, &f03->fn->dev,\r\n"%s: Wrote %.2hhx to PS/2 passthrough address",\r\n__func__, val);\r\nerror = rmi_write(f03->fn->rmi_dev, f03->fn->fd.data_base_addr, val);\r\nif (error) {\r\ndev_err(&f03->fn->dev,\r\n"%s: Failed to write to F03 TX register (%d).\n",\r\n__func__, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f03_initialize(struct f03_data *f03)\r\n{\r\nstruct rmi_function *fn = f03->fn;\r\nstruct device *dev = &fn->dev;\r\nint error;\r\nu8 bytes_per_device;\r\nu8 query1;\r\nu8 query2[RMI_F03_DEVICE_COUNT * RMI_F03_BYTES_PER_DEVICE];\r\nsize_t query2_len;\r\nerror = rmi_read(fn->rmi_dev, fn->fd.query_base_addr, &query1);\r\nif (error) {\r\ndev_err(dev, "Failed to read query register (%d).\n", error);\r\nreturn error;\r\n}\r\nf03->device_count = query1 & RMI_F03_DEVICE_COUNT;\r\nbytes_per_device = (query1 >> RMI_F03_BYTES_PER_DEVICE_SHIFT) &\r\nRMI_F03_BYTES_PER_DEVICE;\r\nquery2_len = f03->device_count * bytes_per_device;\r\nif (query2_len < 1) {\r\nf03->device_count = 1;\r\nf03->rx_queue_length = 7;\r\n} else {\r\nerror = rmi_read_block(fn->rmi_dev, fn->fd.query_base_addr + 1,\r\nquery2, query2_len);\r\nif (error) {\r\ndev_err(dev,\r\n"Failed to read second set of query registers (%d).\n",\r\nerror);\r\nreturn error;\r\n}\r\nf03->rx_queue_length = query2[0] & RMI_F03_QUEUE_LENGTH;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f03_register_pt(struct f03_data *f03)\r\n{\r\nstruct serio *serio;\r\nserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!serio)\r\nreturn -ENOMEM;\r\nserio->id.type = SERIO_PS_PSTHRU;\r\nserio->write = rmi_f03_pt_write;\r\nserio->port_data = f03;\r\nstrlcpy(serio->name, "Synaptics RMI4 PS/2 pass-through",\r\nsizeof(serio->name));\r\nstrlcpy(serio->phys, "synaptics-rmi4-pt/serio1",\r\nsizeof(serio->phys));\r\nserio->dev.parent = &f03->fn->dev;\r\nf03->serio = serio;\r\nserio_register_port(serio);\r\nreturn 0;\r\n}\r\nstatic int rmi_f03_probe(struct rmi_function *fn)\r\n{\r\nstruct device *dev = &fn->dev;\r\nstruct f03_data *f03;\r\nint error;\r\nf03 = devm_kzalloc(dev, sizeof(struct f03_data), GFP_KERNEL);\r\nif (!f03)\r\nreturn -ENOMEM;\r\nf03->fn = fn;\r\nerror = rmi_f03_initialize(f03);\r\nif (error < 0)\r\nreturn error;\r\nif (f03->device_count != 1)\r\ndev_warn(dev, "found %d devices on PS/2 passthrough",\r\nf03->device_count);\r\ndev_set_drvdata(dev, f03);\r\nerror = rmi_f03_register_pt(f03);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int rmi_f03_config(struct rmi_function *fn)\r\n{\r\nfn->rmi_dev->driver->set_irq_bits(fn->rmi_dev, fn->irq_mask);\r\nreturn 0;\r\n}\r\nstatic int rmi_f03_attention(struct rmi_function *fn, unsigned long *irq_bits)\r\n{\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nstruct rmi_driver_data *drvdata = dev_get_drvdata(&rmi_dev->dev);\r\nstruct f03_data *f03 = dev_get_drvdata(&fn->dev);\r\nu16 data_addr = fn->fd.data_base_addr;\r\nconst u8 ob_len = f03->rx_queue_length * RMI_F03_OB_SIZE;\r\nu8 obs[RMI_F03_QUEUE_LENGTH * RMI_F03_OB_SIZE];\r\nu8 ob_status;\r\nu8 ob_data;\r\nunsigned int serio_flags;\r\nint i;\r\nint error;\r\nif (drvdata->attn_data.data) {\r\nif (drvdata->attn_data.size < ob_len) {\r\ndev_warn(&fn->dev, "F03 interrupted, but data is missing!\n");\r\nreturn 0;\r\n}\r\nmemcpy(obs, drvdata->attn_data.data, ob_len);\r\ndrvdata->attn_data.data += ob_len;\r\ndrvdata->attn_data.size -= ob_len;\r\n} else {\r\nerror = rmi_read_block(fn->rmi_dev, data_addr + RMI_F03_OB_OFFSET,\r\n&obs, ob_len);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"%s: Failed to read F03 output buffers: %d\n",\r\n__func__, error);\r\nserio_interrupt(f03->serio, 0, SERIO_TIMEOUT);\r\nreturn error;\r\n}\r\n}\r\nfor (i = 0; i < ob_len; i += RMI_F03_OB_SIZE) {\r\nob_status = obs[i];\r\nob_data = obs[i + RMI_F03_OB_DATA_OFFSET];\r\nserio_flags = 0;\r\nif (!(ob_status & RMI_F03_RX_DATA_OFB))\r\ncontinue;\r\nif (ob_status & RMI_F03_OB_FLAG_TIMEOUT)\r\nserio_flags |= SERIO_TIMEOUT;\r\nif (ob_status & RMI_F03_OB_FLAG_PARITY)\r\nserio_flags |= SERIO_PARITY;\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev,\r\n"%s: Received %.2hhx from PS2 guest T: %c P: %c\n",\r\n__func__, ob_data,\r\nserio_flags & SERIO_TIMEOUT ? 'Y' : 'N',\r\nserio_flags & SERIO_PARITY ? 'Y' : 'N');\r\nserio_interrupt(f03->serio, ob_data, serio_flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void rmi_f03_remove(struct rmi_function *fn)\r\n{\r\nstruct f03_data *f03 = dev_get_drvdata(&fn->dev);\r\nserio_unregister_port(f03->serio);\r\n}
