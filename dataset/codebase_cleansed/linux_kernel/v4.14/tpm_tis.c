static inline struct tpm_tis_tcg_phy *to_tpm_tis_tcg_phy(struct tpm_tis_data *data)\r\n{\r\nreturn container_of(data, struct tpm_tis_tcg_phy, priv);\r\n}\r\nstatic int has_hid(struct acpi_device *dev, const char *hid)\r\n{\r\nstruct acpi_hardware_id *id;\r\nlist_for_each_entry(id, &dev->pnp.ids, list)\r\nif (!strcmp(hid, id->id))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int is_itpm(struct acpi_device *dev)\r\n{\r\nif (!dev)\r\nreturn 0;\r\nreturn has_hid(dev, "INTC0102");\r\n}\r\nstatic inline int is_itpm(struct acpi_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int check_acpi_tpm2(struct device *dev)\r\n{\r\nconst struct acpi_device_id *aid = acpi_match_device(tpm_acpi_tbl, dev);\r\nstruct acpi_table_tpm2 *tbl;\r\nacpi_status st;\r\nif (!aid || aid->driver_data != DEVICE_IS_TPM2)\r\nreturn 0;\r\nst =\r\nacpi_get_table(ACPI_SIG_TPM2, 1, (struct acpi_table_header **)&tbl);\r\nif (ACPI_FAILURE(st) || tbl->header.length < sizeof(*tbl)) {\r\ndev_err(dev, FW_BUG "failed to get TPM2 ACPI table\n");\r\nreturn -EINVAL;\r\n}\r\nif (tbl->start_method != ACPI_TPM2_MEMORY_MAPPED)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int check_acpi_tpm2(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline bool is_bsw(void)\r\n{\r\nreturn ((boot_cpu_data.x86_model == INTEL_FAM6_ATOM_AIRMONT) ? 1 : 0);\r\n}\r\nstatic void tpm_platform_begin_xfer(void)\r\n{\r\nu32 clkrun_val;\r\nif (!is_bsw())\r\nreturn;\r\nclkrun_val = ioread32(ilb_base_addr + LPC_CNTRL_REG_OFFSET);\r\nclkrun_val &= ~LPC_CLKRUN_EN;\r\niowrite32(clkrun_val, ilb_base_addr + LPC_CNTRL_REG_OFFSET);\r\noutb(0xCC, 0x80);\r\n}\r\nstatic void tpm_platform_end_xfer(void)\r\n{\r\nu32 clkrun_val;\r\nif (!is_bsw())\r\nreturn;\r\nclkrun_val = ioread32(ilb_base_addr + LPC_CNTRL_REG_OFFSET);\r\nclkrun_val |= LPC_CLKRUN_EN;\r\niowrite32(clkrun_val, ilb_base_addr + LPC_CNTRL_REG_OFFSET);\r\noutb(0xCC, 0x80);\r\n}\r\nstatic inline bool is_bsw(void)\r\n{\r\nreturn false;\r\n}\r\nstatic void tpm_platform_begin_xfer(void)\r\n{\r\n}\r\nstatic void tpm_platform_end_xfer(void)\r\n{\r\n}\r\nstatic int tpm_tcg_read_bytes(struct tpm_tis_data *data, u32 addr, u16 len,\r\nu8 *result)\r\n{\r\nstruct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);\r\ntpm_platform_begin_xfer();\r\nwhile (len--)\r\n*result++ = ioread8(phy->iobase + addr);\r\ntpm_platform_end_xfer();\r\nreturn 0;\r\n}\r\nstatic int tpm_tcg_write_bytes(struct tpm_tis_data *data, u32 addr, u16 len,\r\nu8 *value)\r\n{\r\nstruct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);\r\ntpm_platform_begin_xfer();\r\nwhile (len--)\r\niowrite8(*value++, phy->iobase + addr);\r\ntpm_platform_end_xfer();\r\nreturn 0;\r\n}\r\nstatic int tpm_tcg_read16(struct tpm_tis_data *data, u32 addr, u16 *result)\r\n{\r\nstruct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);\r\ntpm_platform_begin_xfer();\r\n*result = ioread16(phy->iobase + addr);\r\ntpm_platform_end_xfer();\r\nreturn 0;\r\n}\r\nstatic int tpm_tcg_read32(struct tpm_tis_data *data, u32 addr, u32 *result)\r\n{\r\nstruct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);\r\ntpm_platform_begin_xfer();\r\n*result = ioread32(phy->iobase + addr);\r\ntpm_platform_end_xfer();\r\nreturn 0;\r\n}\r\nstatic int tpm_tcg_write32(struct tpm_tis_data *data, u32 addr, u32 value)\r\n{\r\nstruct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);\r\ntpm_platform_begin_xfer();\r\niowrite32(value, phy->iobase + addr);\r\ntpm_platform_end_xfer();\r\nreturn 0;\r\n}\r\nstatic int tpm_tis_init(struct device *dev, struct tpm_info *tpm_info)\r\n{\r\nstruct tpm_tis_tcg_phy *phy;\r\nint irq = -1;\r\nint rc;\r\nrc = check_acpi_tpm2(dev);\r\nif (rc)\r\nreturn rc;\r\nphy = devm_kzalloc(dev, sizeof(struct tpm_tis_tcg_phy), GFP_KERNEL);\r\nif (phy == NULL)\r\nreturn -ENOMEM;\r\nphy->iobase = devm_ioremap_resource(dev, &tpm_info->res);\r\nif (IS_ERR(phy->iobase))\r\nreturn PTR_ERR(phy->iobase);\r\nif (interrupts)\r\nirq = tpm_info->irq;\r\nif (itpm || is_itpm(ACPI_COMPANION(dev)))\r\nphy->priv.flags |= TPM_TIS_ITPM_WORKAROUND;\r\nreturn tpm_tis_core_init(dev, &phy->priv, irq, &tpm_tcg,\r\nACPI_HANDLE(dev));\r\n}\r\nstatic int tpm_tis_pnp_init(struct pnp_dev *pnp_dev,\r\nconst struct pnp_device_id *pnp_id)\r\n{\r\nstruct tpm_info tpm_info = {};\r\nstruct resource *res;\r\nres = pnp_get_resource(pnp_dev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\ntpm_info.res = *res;\r\nif (pnp_irq_valid(pnp_dev, 0))\r\ntpm_info.irq = pnp_irq(pnp_dev, 0);\r\nelse\r\ntpm_info.irq = -1;\r\nreturn tpm_tis_init(&pnp_dev->dev, &tpm_info);\r\n}\r\nstatic void tpm_tis_pnp_remove(struct pnp_dev *dev)\r\n{\r\nstruct tpm_chip *chip = pnp_get_drvdata(dev);\r\ntpm_chip_unregister(chip);\r\ntpm_tis_remove(chip);\r\n}\r\nstatic int tpm_tis_plat_probe(struct platform_device *pdev)\r\n{\r\nstruct tpm_info tpm_info = {};\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "no memory resource defined\n");\r\nreturn -ENODEV;\r\n}\r\ntpm_info.res = *res;\r\ntpm_info.irq = platform_get_irq(pdev, 0);\r\nif (tpm_info.irq <= 0) {\r\nif (pdev != force_pdev)\r\ntpm_info.irq = -1;\r\nelse\r\ntpm_info.irq = 0;\r\n}\r\nreturn tpm_tis_init(&pdev->dev, &tpm_info);\r\n}\r\nstatic int tpm_tis_plat_remove(struct platform_device *pdev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(&pdev->dev);\r\ntpm_chip_unregister(chip);\r\ntpm_tis_remove(chip);\r\nreturn 0;\r\n}\r\nstatic int tpm_tis_force_device(void)\r\n{\r\nstruct platform_device *pdev;\r\nstatic const struct resource x86_resources[] = {\r\n{\r\n.start = 0xFED40000,\r\n.end = 0xFED40000 + TIS_MEM_LEN - 1,\r\n.flags = IORESOURCE_MEM,\r\n},\r\n};\r\nif (!force)\r\nreturn 0;\r\npdev = platform_device_register_simple("tpm_tis", -1, x86_resources,\r\nARRAY_SIZE(x86_resources));\r\nif (IS_ERR(pdev))\r\nreturn PTR_ERR(pdev);\r\nforce_pdev = pdev;\r\nreturn 0;\r\n}\r\nstatic int __init init_tis(void)\r\n{\r\nint rc;\r\nrc = tpm_tis_force_device();\r\nif (rc)\r\ngoto err_force;\r\n#ifdef CONFIG_X86\r\nif (is_bsw())\r\nilb_base_addr = ioremap(INTEL_LEGACY_BLK_BASE_ADDR,\r\nILB_REMAP_SIZE);\r\n#endif\r\nrc = platform_driver_register(&tis_drv);\r\nif (rc)\r\ngoto err_platform;\r\nif (IS_ENABLED(CONFIG_PNP)) {\r\nrc = pnp_register_driver(&tis_pnp_driver);\r\nif (rc)\r\ngoto err_pnp;\r\n}\r\nreturn 0;\r\nerr_pnp:\r\nplatform_driver_unregister(&tis_drv);\r\nerr_platform:\r\nif (force_pdev)\r\nplatform_device_unregister(force_pdev);\r\n#ifdef CONFIG_X86\r\nif (is_bsw())\r\niounmap(ilb_base_addr);\r\n#endif\r\nerr_force:\r\nreturn rc;\r\n}\r\nstatic void __exit cleanup_tis(void)\r\n{\r\npnp_unregister_driver(&tis_pnp_driver);\r\nplatform_driver_unregister(&tis_drv);\r\n#ifdef CONFIG_X86\r\nif (is_bsw())\r\niounmap(ilb_base_addr);\r\n#endif\r\nif (force_pdev)\r\nplatform_device_unregister(force_pdev);\r\n}
