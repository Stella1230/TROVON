static int helper_child(void *arg)\r\n{\r\nstruct helper_data *data = arg;\r\nchar **argv = data->argv;\r\nint err, ret;\r\nif (data->pre_exec != NULL)\r\n(*data->pre_exec)(data->pre_data);\r\nerr = execvp_noalloc(data->buf, argv[0], argv);\r\nCATCH_EINTR(ret = write(data->fd, &err, sizeof(err)));\r\nreturn 0;\r\n}\r\nint run_helper(void (*pre_exec)(void *), void *pre_data, char **argv)\r\n{\r\nstruct helper_data data;\r\nunsigned long stack, sp;\r\nint pid, fds[2], ret, n;\r\nstack = alloc_stack(0, __cant_sleep());\r\nif (stack == 0)\r\nreturn -ENOMEM;\r\nret = socketpair(AF_UNIX, SOCK_STREAM, 0, fds);\r\nif (ret < 0) {\r\nret = -errno;\r\nprintk(UM_KERN_ERR "run_helper : pipe failed, errno = %d\n",\r\nerrno);\r\ngoto out_free;\r\n}\r\nret = os_set_exec_close(fds[1]);\r\nif (ret < 0) {\r\nprintk(UM_KERN_ERR "run_helper : setting FD_CLOEXEC failed, "\r\n"ret = %d\n", -ret);\r\ngoto out_close;\r\n}\r\nsp = stack + UM_KERN_PAGE_SIZE - sizeof(void *);\r\ndata.pre_exec = pre_exec;\r\ndata.pre_data = pre_data;\r\ndata.argv = argv;\r\ndata.fd = fds[1];\r\ndata.buf = __cant_sleep() ? uml_kmalloc(PATH_MAX, UM_GFP_ATOMIC) :\r\numl_kmalloc(PATH_MAX, UM_GFP_KERNEL);\r\npid = clone(helper_child, (void *) sp, CLONE_VM, &data);\r\nif (pid < 0) {\r\nret = -errno;\r\nprintk(UM_KERN_ERR "run_helper : clone failed, errno = %d\n",\r\nerrno);\r\ngoto out_free2;\r\n}\r\nclose(fds[1]);\r\nfds[1] = -1;\r\nn = read(fds[0], &ret, sizeof(ret));\r\nif (n == 0) {\r\nret = pid;\r\n} else {\r\nif (n < 0) {\r\nn = -errno;\r\nprintk(UM_KERN_ERR "run_helper : read on pipe failed, "\r\n"ret = %d\n", -n);\r\nret = n;\r\n}\r\nCATCH_EINTR(waitpid(pid, NULL, __WALL));\r\n}\r\nout_free2:\r\nkfree(data.buf);\r\nout_close:\r\nif (fds[1] != -1)\r\nclose(fds[1]);\r\nclose(fds[0]);\r\nout_free:\r\nfree_stack(stack, 0);\r\nreturn ret;\r\n}\r\nint run_helper_thread(int (*proc)(void *), void *arg, unsigned int flags,\r\nunsigned long *stack_out)\r\n{\r\nunsigned long stack, sp;\r\nint pid, status, err;\r\nstack = alloc_stack(0, __cant_sleep());\r\nif (stack == 0)\r\nreturn -ENOMEM;\r\nsp = stack + UM_KERN_PAGE_SIZE - sizeof(void *);\r\npid = clone(proc, (void *) sp, flags, arg);\r\nif (pid < 0) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "run_helper_thread : clone failed, "\r\n"errno = %d\n", errno);\r\nreturn err;\r\n}\r\nif (stack_out == NULL) {\r\nCATCH_EINTR(pid = waitpid(pid, &status, __WALL));\r\nif (pid < 0) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "run_helper_thread - wait failed, "\r\n"errno = %d\n", errno);\r\npid = err;\r\n}\r\nif (!WIFEXITED(status) || (WEXITSTATUS(status) != 0))\r\nprintk(UM_KERN_ERR "run_helper_thread - thread "\r\n"returned status 0x%x\n", status);\r\nfree_stack(stack, 0);\r\n} else\r\n*stack_out = stack;\r\nreturn pid;\r\n}\r\nint helper_wait(int pid)\r\n{\r\nint ret, status;\r\nint wflags = __WALL;\r\nCATCH_EINTR(ret = waitpid(pid, &status, wflags));\r\nif (ret < 0) {\r\nprintk(UM_KERN_ERR "helper_wait : waitpid process %d failed, "\r\n"errno = %d\n", pid, errno);\r\nreturn -errno;\r\n} else if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {\r\nprintk(UM_KERN_ERR "helper_wait : process %d exited with "\r\n"status 0x%x\n", pid, status);\r\nreturn -ECHILD;\r\n} else\r\nreturn 0;\r\n}
