struct mdp5_hw_pipe *mdp5_pipe_assign(struct drm_atomic_state *s,\r\nstruct drm_plane *plane, uint32_t caps, uint32_t blkcfg)\r\n{\r\nstruct msm_drm_private *priv = s->dev->dev_private;\r\nstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(priv->kms));\r\nstruct mdp5_state *state;\r\nstruct mdp5_hw_pipe_state *old_state, *new_state;\r\nstruct mdp5_hw_pipe *hwpipe = NULL;\r\nint i;\r\nstate = mdp5_get_state(s);\r\nif (IS_ERR(state))\r\nreturn ERR_CAST(state);\r\nold_state = &mdp5_kms->state->hwpipe;\r\nnew_state = &state->hwpipe;\r\nfor (i = 0; i < mdp5_kms->num_hwpipes; i++) {\r\nstruct mdp5_hw_pipe *cur = mdp5_kms->hwpipes[i];\r\nif (new_state->hwpipe_to_plane[cur->idx] ||\r\nold_state->hwpipe_to_plane[cur->idx])\r\ncontinue;\r\nif (caps & ~cur->caps)\r\ncontinue;\r\nif (cur->caps & MDP_PIPE_CAP_CURSOR &&\r\nplane->type != DRM_PLANE_TYPE_CURSOR)\r\ncontinue;\r\nif (!hwpipe || (hweight_long(cur->caps & ~caps) <\r\nhweight_long(hwpipe->caps & ~caps)))\r\nhwpipe = cur;\r\n}\r\nif (!hwpipe)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (mdp5_kms->smp) {\r\nint ret;\r\nDBG("%s: alloc SMP blocks", hwpipe->name);\r\nret = mdp5_smp_assign(mdp5_kms->smp, &state->smp,\r\nhwpipe->pipe, blkcfg);\r\nif (ret)\r\nreturn ERR_PTR(-ENOMEM);\r\nhwpipe->blkcfg = blkcfg;\r\n}\r\nDBG("%s: assign to plane %s for caps %x",\r\nhwpipe->name, plane->name, caps);\r\nnew_state->hwpipe_to_plane[hwpipe->idx] = plane;\r\nreturn hwpipe;\r\n}\r\nvoid mdp5_pipe_release(struct drm_atomic_state *s, struct mdp5_hw_pipe *hwpipe)\r\n{\r\nstruct msm_drm_private *priv = s->dev->dev_private;\r\nstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(priv->kms));\r\nstruct mdp5_state *state = mdp5_get_state(s);\r\nstruct mdp5_hw_pipe_state *new_state = &state->hwpipe;\r\nif (!hwpipe)\r\nreturn;\r\nif (WARN_ON(!new_state->hwpipe_to_plane[hwpipe->idx]))\r\nreturn;\r\nDBG("%s: release from plane %s", hwpipe->name,\r\nnew_state->hwpipe_to_plane[hwpipe->idx]->name);\r\nif (mdp5_kms->smp) {\r\nDBG("%s: free SMP blocks", hwpipe->name);\r\nmdp5_smp_release(mdp5_kms->smp, &state->smp, hwpipe->pipe);\r\n}\r\nnew_state->hwpipe_to_plane[hwpipe->idx] = NULL;\r\n}\r\nvoid mdp5_pipe_destroy(struct mdp5_hw_pipe *hwpipe)\r\n{\r\nkfree(hwpipe);\r\n}\r\nstruct mdp5_hw_pipe *mdp5_pipe_init(enum mdp5_pipe pipe,\r\nuint32_t reg_offset, uint32_t caps)\r\n{\r\nstruct mdp5_hw_pipe *hwpipe;\r\nhwpipe = kzalloc(sizeof(*hwpipe), GFP_KERNEL);\r\nif (!hwpipe)\r\nreturn ERR_PTR(-ENOMEM);\r\nhwpipe->name = pipe2name(pipe);\r\nhwpipe->pipe = pipe;\r\nhwpipe->reg_offset = reg_offset;\r\nhwpipe->caps = caps;\r\nhwpipe->flush_mask = mdp_ctl_flush_mask_pipe(pipe);\r\nreturn hwpipe;\r\n}
