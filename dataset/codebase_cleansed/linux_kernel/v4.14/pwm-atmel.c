static inline struct atmel_pwm_chip *to_atmel_pwm_chip(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct atmel_pwm_chip, chip);\r\n}\r\nstatic inline u32 atmel_pwm_readl(struct atmel_pwm_chip *chip,\r\nunsigned long offset)\r\n{\r\nreturn readl_relaxed(chip->base + offset);\r\n}\r\nstatic inline void atmel_pwm_writel(struct atmel_pwm_chip *chip,\r\nunsigned long offset, unsigned long val)\r\n{\r\nwritel_relaxed(val, chip->base + offset);\r\n}\r\nstatic inline u32 atmel_pwm_ch_readl(struct atmel_pwm_chip *chip,\r\nunsigned int ch, unsigned long offset)\r\n{\r\nunsigned long base = PWM_CH_REG_OFFSET + ch * PWM_CH_REG_SIZE;\r\nreturn readl_relaxed(chip->base + base + offset);\r\n}\r\nstatic inline void atmel_pwm_ch_writel(struct atmel_pwm_chip *chip,\r\nunsigned int ch, unsigned long offset,\r\nunsigned long val)\r\n{\r\nunsigned long base = PWM_CH_REG_OFFSET + ch * PWM_CH_REG_SIZE;\r\nwritel_relaxed(val, chip->base + base + offset);\r\n}\r\nstatic int atmel_pwm_calculate_cprd_and_pres(struct pwm_chip *chip,\r\nconst struct pwm_state *state,\r\nunsigned long *cprd, u32 *pres)\r\n{\r\nstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\r\nunsigned long long cycles = state->period;\r\ncycles *= clk_get_rate(atmel_pwm->clk);\r\ndo_div(cycles, NSEC_PER_SEC);\r\nfor (*pres = 0; cycles > PWM_MAX_PRD; cycles >>= 1)\r\n(*pres)++;\r\nif (*pres > PRD_MAX_PRES) {\r\ndev_err(chip->dev, "pres exceeds the maximum value\n");\r\nreturn -EINVAL;\r\n}\r\n*cprd = cycles;\r\nreturn 0;\r\n}\r\nstatic void atmel_pwm_calculate_cdty(const struct pwm_state *state,\r\nunsigned long cprd, unsigned long *cdty)\r\n{\r\nunsigned long long cycles = state->duty_cycle;\r\ncycles *= cprd;\r\ndo_div(cycles, state->period);\r\n*cdty = cprd - cycles;\r\n}\r\nstatic void atmel_pwm_update_cdty(struct pwm_chip *chip, struct pwm_device *pwm,\r\nunsigned long cdty)\r\n{\r\nstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\r\nu32 val;\r\nif (atmel_pwm->regs->duty_upd ==\r\natmel_pwm->regs->period_upd) {\r\nval = atmel_pwm_ch_readl(atmel_pwm, pwm->hwpwm, PWM_CMR);\r\nval &= ~PWM_CMR_UPD_CDTY;\r\natmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm, PWM_CMR, val);\r\n}\r\natmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm,\r\natmel_pwm->regs->duty_upd, cdty);\r\n}\r\nstatic void atmel_pwm_set_cprd_cdty(struct pwm_chip *chip,\r\nstruct pwm_device *pwm,\r\nunsigned long cprd, unsigned long cdty)\r\n{\r\nstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\r\natmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm,\r\natmel_pwm->regs->duty, cdty);\r\natmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm,\r\natmel_pwm->regs->period, cprd);\r\n}\r\nstatic void atmel_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm,\r\nbool disable_clk)\r\n{\r\nstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\r\nunsigned long timeout = jiffies + 2 * HZ;\r\nmutex_lock(&atmel_pwm->isr_lock);\r\natmel_pwm->updated_pwms |= atmel_pwm_readl(atmel_pwm, PWM_ISR);\r\nwhile (!(atmel_pwm->updated_pwms & (1 << pwm->hwpwm)) &&\r\ntime_before(jiffies, timeout)) {\r\nusleep_range(10, 100);\r\natmel_pwm->updated_pwms |= atmel_pwm_readl(atmel_pwm, PWM_ISR);\r\n}\r\nmutex_unlock(&atmel_pwm->isr_lock);\r\natmel_pwm_writel(atmel_pwm, PWM_DIS, 1 << pwm->hwpwm);\r\ntimeout = jiffies + 2 * HZ;\r\nwhile ((atmel_pwm_readl(atmel_pwm, PWM_SR) & (1 << pwm->hwpwm)) &&\r\ntime_before(jiffies, timeout))\r\nusleep_range(10, 100);\r\nif (disable_clk)\r\nclk_disable(atmel_pwm->clk);\r\n}\r\nstatic int atmel_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\r\nstruct pwm_state cstate;\r\nunsigned long cprd, cdty;\r\nu32 pres, val;\r\nint ret;\r\npwm_get_state(pwm, &cstate);\r\nif (state->enabled) {\r\nif (cstate.enabled &&\r\ncstate.polarity == state->polarity &&\r\ncstate.period == state->period) {\r\ncprd = atmel_pwm_ch_readl(atmel_pwm, pwm->hwpwm,\r\natmel_pwm->regs->period);\r\natmel_pwm_calculate_cdty(state, cprd, &cdty);\r\natmel_pwm_update_cdty(chip, pwm, cdty);\r\nreturn 0;\r\n}\r\nret = atmel_pwm_calculate_cprd_and_pres(chip, state, &cprd,\r\n&pres);\r\nif (ret) {\r\ndev_err(chip->dev,\r\n"failed to calculate cprd and prescaler\n");\r\nreturn ret;\r\n}\r\natmel_pwm_calculate_cdty(state, cprd, &cdty);\r\nif (cstate.enabled) {\r\natmel_pwm_disable(chip, pwm, false);\r\n} else {\r\nret = clk_enable(atmel_pwm->clk);\r\nif (ret) {\r\ndev_err(chip->dev, "failed to enable clock\n");\r\nreturn ret;\r\n}\r\n}\r\nval = atmel_pwm_ch_readl(atmel_pwm, pwm->hwpwm, PWM_CMR);\r\nval = (val & ~PWM_CMR_CPRE_MSK) | (pres & PWM_CMR_CPRE_MSK);\r\nif (state->polarity == PWM_POLARITY_NORMAL)\r\nval &= ~PWM_CMR_CPOL;\r\nelse\r\nval |= PWM_CMR_CPOL;\r\natmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm, PWM_CMR, val);\r\natmel_pwm_set_cprd_cdty(chip, pwm, cprd, cdty);\r\nmutex_lock(&atmel_pwm->isr_lock);\r\natmel_pwm->updated_pwms |= atmel_pwm_readl(atmel_pwm, PWM_ISR);\r\natmel_pwm->updated_pwms &= ~(1 << pwm->hwpwm);\r\nmutex_unlock(&atmel_pwm->isr_lock);\r\natmel_pwm_writel(atmel_pwm, PWM_ENA, 1 << pwm->hwpwm);\r\n} else if (cstate.enabled) {\r\natmel_pwm_disable(chip, pwm, true);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline const struct atmel_pwm_registers *\r\natmel_pwm_get_driver_data(struct platform_device *pdev)\r\n{\r\nconst struct platform_device_id *id;\r\nif (pdev->dev.of_node)\r\nreturn of_device_get_match_data(&pdev->dev);\r\nid = platform_get_device_id(pdev);\r\nreturn (struct atmel_pwm_registers *)id->driver_data;\r\n}\r\nstatic int atmel_pwm_probe(struct platform_device *pdev)\r\n{\r\nconst struct atmel_pwm_registers *regs;\r\nstruct atmel_pwm_chip *atmel_pwm;\r\nstruct resource *res;\r\nint ret;\r\nregs = atmel_pwm_get_driver_data(pdev);\r\nif (!regs)\r\nreturn -ENODEV;\r\natmel_pwm = devm_kzalloc(&pdev->dev, sizeof(*atmel_pwm), GFP_KERNEL);\r\nif (!atmel_pwm)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\natmel_pwm->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(atmel_pwm->base))\r\nreturn PTR_ERR(atmel_pwm->base);\r\natmel_pwm->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(atmel_pwm->clk))\r\nreturn PTR_ERR(atmel_pwm->clk);\r\nret = clk_prepare(atmel_pwm->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to prepare PWM clock\n");\r\nreturn ret;\r\n}\r\natmel_pwm->chip.dev = &pdev->dev;\r\natmel_pwm->chip.ops = &atmel_pwm_ops;\r\nif (pdev->dev.of_node) {\r\natmel_pwm->chip.of_xlate = of_pwm_xlate_with_flags;\r\natmel_pwm->chip.of_pwm_n_cells = 3;\r\n}\r\natmel_pwm->chip.base = -1;\r\natmel_pwm->chip.npwm = 4;\r\natmel_pwm->regs = regs;\r\natmel_pwm->updated_pwms = 0;\r\nmutex_init(&atmel_pwm->isr_lock);\r\nret = pwmchip_add(&atmel_pwm->chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to add PWM chip %d\n", ret);\r\ngoto unprepare_clk;\r\n}\r\nplatform_set_drvdata(pdev, atmel_pwm);\r\nreturn ret;\r\nunprepare_clk:\r\nclk_unprepare(atmel_pwm->clk);\r\nreturn ret;\r\n}\r\nstatic int atmel_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_pwm_chip *atmel_pwm = platform_get_drvdata(pdev);\r\nclk_unprepare(atmel_pwm->clk);\r\nmutex_destroy(&atmel_pwm->isr_lock);\r\nreturn pwmchip_remove(&atmel_pwm->chip);\r\n}
