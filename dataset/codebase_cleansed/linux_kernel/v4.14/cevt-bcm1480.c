static int sibyte_set_periodic(struct clock_event_device *evt)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nvoid __iomem *cfg, *init;\r\ncfg = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));\r\ninit = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT));\r\n__raw_writeq(0, cfg);\r\n__raw_writeq((V_SCD_TIMER_FREQ / HZ) - 1, init);\r\n__raw_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS, cfg);\r\nreturn 0;\r\n}\r\nstatic int sibyte_shutdown(struct clock_event_device *evt)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nvoid __iomem *cfg;\r\ncfg = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));\r\n__raw_writeq(0, cfg);\r\nreturn 0;\r\n}\r\nstatic int sibyte_next_event(unsigned long delta, struct clock_event_device *cd)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nvoid __iomem *cfg, *init;\r\ncfg = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));\r\ninit = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT));\r\n__raw_writeq(0, cfg);\r\n__raw_writeq(delta - 1, init);\r\n__raw_writeq(M_SCD_TIMER_ENABLE, cfg);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sibyte_counter_handler(int irq, void *dev_id)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nstruct clock_event_device *cd = dev_id;\r\nvoid __iomem *cfg;\r\nunsigned long tmode;\r\nif (clockevent_state_periodic(cd))\r\ntmode = M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS;\r\nelse\r\ntmode = 0;\r\ncfg = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));\r\n____raw_writeq(tmode, cfg);\r\ncd->event_handler(cd);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid sb1480_clockevent_init(void)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nunsigned int irq = K_BCM1480_INT_TIMER_0 + cpu;\r\nstruct irqaction *action = &per_cpu(sibyte_hpt_irqaction, cpu);\r\nstruct clock_event_device *cd = &per_cpu(sibyte_hpt_clockevent, cpu);\r\nunsigned char *name = per_cpu(sibyte_hpt_name, cpu);\r\nBUG_ON(cpu > 3);\r\nsprintf(name, "bcm1480-counter-%d", cpu);\r\ncd->name = name;\r\ncd->features = CLOCK_EVT_FEAT_PERIODIC |\r\nCLOCK_EVT_FEAT_ONESHOT;\r\nclockevent_set_clock(cd, V_SCD_TIMER_FREQ);\r\ncd->max_delta_ns = clockevent_delta2ns(0x7fffff, cd);\r\ncd->max_delta_ticks = 0x7fffff;\r\ncd->min_delta_ns = clockevent_delta2ns(2, cd);\r\ncd->min_delta_ticks = 2;\r\ncd->rating = 200;\r\ncd->irq = irq;\r\ncd->cpumask = cpumask_of(cpu);\r\ncd->set_next_event = sibyte_next_event;\r\ncd->set_state_shutdown = sibyte_shutdown;\r\ncd->set_state_periodic = sibyte_set_periodic;\r\ncd->set_state_oneshot = sibyte_shutdown;\r\nclockevents_register_device(cd);\r\nbcm1480_mask_irq(cpu, irq);\r\n__raw_writeq(IMR_IP4_VAL,\r\nIOADDR(A_BCM1480_IMR_REGISTER(cpu,\r\nR_BCM1480_IMR_INTERRUPT_MAP_BASE_H) + (irq << 3)));\r\nbcm1480_unmask_irq(cpu, irq);\r\naction->handler = sibyte_counter_handler;\r\naction->flags = IRQF_PERCPU | IRQF_TIMER;\r\naction->name = name;\r\naction->dev_id = cd;\r\nirq_set_affinity(irq, cpumask_of(cpu));\r\nsetup_irq(irq, action);\r\n}
