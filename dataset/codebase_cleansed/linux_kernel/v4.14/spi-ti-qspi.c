static inline unsigned long ti_qspi_read(struct ti_qspi *qspi,\r\nunsigned long reg)\r\n{\r\nreturn readl(qspi->base + reg);\r\n}\r\nstatic inline void ti_qspi_write(struct ti_qspi *qspi,\r\nunsigned long val, unsigned long reg)\r\n{\r\nwritel(val, qspi->base + reg);\r\n}\r\nstatic int ti_qspi_setup(struct spi_device *spi)\r\n{\r\nstruct ti_qspi *qspi = spi_master_get_devdata(spi->master);\r\nstruct ti_qspi_regs *ctx_reg = &qspi->ctx_reg;\r\nint clk_div = 0, ret;\r\nu32 clk_ctrl_reg, clk_rate, clk_mask;\r\nif (spi->master->busy) {\r\ndev_dbg(qspi->dev, "master busy doing other transfers\n");\r\nreturn -EBUSY;\r\n}\r\nif (!qspi->spi_max_frequency) {\r\ndev_err(qspi->dev, "spi max frequency not defined\n");\r\nreturn -EINVAL;\r\n}\r\nclk_rate = clk_get_rate(qspi->fclk);\r\nclk_div = DIV_ROUND_UP(clk_rate, qspi->spi_max_frequency) - 1;\r\nif (clk_div < 0) {\r\ndev_dbg(qspi->dev, "clock divider < 0, using /1 divider\n");\r\nreturn -EINVAL;\r\n}\r\nif (clk_div > QSPI_CLK_DIV_MAX) {\r\ndev_dbg(qspi->dev, "clock divider >%d , using /%d divider\n",\r\nQSPI_CLK_DIV_MAX, QSPI_CLK_DIV_MAX + 1);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(qspi->dev, "hz: %d, clock divider %d\n",\r\nqspi->spi_max_frequency, clk_div);\r\nret = pm_runtime_get_sync(qspi->dev);\r\nif (ret < 0) {\r\ndev_err(qspi->dev, "pm_runtime_get_sync() failed\n");\r\nreturn ret;\r\n}\r\nclk_ctrl_reg = ti_qspi_read(qspi, QSPI_SPI_CLOCK_CNTRL_REG);\r\nclk_ctrl_reg &= ~QSPI_CLK_EN;\r\nti_qspi_write(qspi, clk_ctrl_reg, QSPI_SPI_CLOCK_CNTRL_REG);\r\nclk_mask = QSPI_CLK_EN | clk_div;\r\nti_qspi_write(qspi, clk_mask, QSPI_SPI_CLOCK_CNTRL_REG);\r\nctx_reg->clkctrl = clk_mask;\r\npm_runtime_mark_last_busy(qspi->dev);\r\nret = pm_runtime_put_autosuspend(qspi->dev);\r\nif (ret < 0) {\r\ndev_err(qspi->dev, "pm_runtime_put_autosuspend() failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ti_qspi_restore_ctx(struct ti_qspi *qspi)\r\n{\r\nstruct ti_qspi_regs *ctx_reg = &qspi->ctx_reg;\r\nti_qspi_write(qspi, ctx_reg->clkctrl, QSPI_SPI_CLOCK_CNTRL_REG);\r\n}\r\nstatic inline u32 qspi_is_busy(struct ti_qspi *qspi)\r\n{\r\nu32 stat;\r\nunsigned long timeout = jiffies + QSPI_COMPLETION_TIMEOUT;\r\nstat = ti_qspi_read(qspi, QSPI_SPI_STATUS_REG);\r\nwhile ((stat & BUSY) && time_after(timeout, jiffies)) {\r\ncpu_relax();\r\nstat = ti_qspi_read(qspi, QSPI_SPI_STATUS_REG);\r\n}\r\nWARN(stat & BUSY, "qspi busy\n");\r\nreturn stat & BUSY;\r\n}\r\nstatic inline int ti_qspi_poll_wc(struct ti_qspi *qspi)\r\n{\r\nu32 stat;\r\nunsigned long timeout = jiffies + QSPI_COMPLETION_TIMEOUT;\r\ndo {\r\nstat = ti_qspi_read(qspi, QSPI_SPI_STATUS_REG);\r\nif (stat & WC)\r\nreturn 0;\r\ncpu_relax();\r\n} while (time_after(timeout, jiffies));\r\nstat = ti_qspi_read(qspi, QSPI_SPI_STATUS_REG);\r\nif (stat & WC)\r\nreturn 0;\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int qspi_write_msg(struct ti_qspi *qspi, struct spi_transfer *t,\r\nint count)\r\n{\r\nint wlen, xfer_len;\r\nunsigned int cmd;\r\nconst u8 *txbuf;\r\nu32 data;\r\ntxbuf = t->tx_buf;\r\ncmd = qspi->cmd | QSPI_WR_SNGL;\r\nwlen = t->bits_per_word >> 3;\r\nxfer_len = wlen;\r\nwhile (count) {\r\nif (qspi_is_busy(qspi))\r\nreturn -EBUSY;\r\nswitch (wlen) {\r\ncase 1:\r\ndev_dbg(qspi->dev, "tx cmd %08x dc %08x data %02x\n",\r\ncmd, qspi->dc, *txbuf);\r\nif (count >= QSPI_WLEN_MAX_BYTES) {\r\nu32 *txp = (u32 *)txbuf;\r\ndata = cpu_to_be32(*txp++);\r\nwritel(data, qspi->base +\r\nQSPI_SPI_DATA_REG_3);\r\ndata = cpu_to_be32(*txp++);\r\nwritel(data, qspi->base +\r\nQSPI_SPI_DATA_REG_2);\r\ndata = cpu_to_be32(*txp++);\r\nwritel(data, qspi->base +\r\nQSPI_SPI_DATA_REG_1);\r\ndata = cpu_to_be32(*txp++);\r\nwritel(data, qspi->base +\r\nQSPI_SPI_DATA_REG);\r\nxfer_len = QSPI_WLEN_MAX_BYTES;\r\ncmd |= QSPI_WLEN(QSPI_WLEN_MAX_BITS);\r\n} else {\r\nwriteb(*txbuf, qspi->base + QSPI_SPI_DATA_REG);\r\ncmd = qspi->cmd | QSPI_WR_SNGL;\r\nxfer_len = wlen;\r\ncmd |= QSPI_WLEN(wlen);\r\n}\r\nbreak;\r\ncase 2:\r\ndev_dbg(qspi->dev, "tx cmd %08x dc %08x data %04x\n",\r\ncmd, qspi->dc, *txbuf);\r\nwritew(*((u16 *)txbuf), qspi->base + QSPI_SPI_DATA_REG);\r\nbreak;\r\ncase 4:\r\ndev_dbg(qspi->dev, "tx cmd %08x dc %08x data %08x\n",\r\ncmd, qspi->dc, *txbuf);\r\nwritel(*((u32 *)txbuf), qspi->base + QSPI_SPI_DATA_REG);\r\nbreak;\r\n}\r\nti_qspi_write(qspi, cmd, QSPI_SPI_CMD_REG);\r\nif (ti_qspi_poll_wc(qspi)) {\r\ndev_err(qspi->dev, "write timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ntxbuf += xfer_len;\r\ncount -= xfer_len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qspi_read_msg(struct ti_qspi *qspi, struct spi_transfer *t,\r\nint count)\r\n{\r\nint wlen;\r\nunsigned int cmd;\r\nu8 *rxbuf;\r\nrxbuf = t->rx_buf;\r\ncmd = qspi->cmd;\r\nswitch (t->rx_nbits) {\r\ncase SPI_NBITS_DUAL:\r\ncmd |= QSPI_RD_DUAL;\r\nbreak;\r\ncase SPI_NBITS_QUAD:\r\ncmd |= QSPI_RD_QUAD;\r\nbreak;\r\ndefault:\r\ncmd |= QSPI_RD_SNGL;\r\nbreak;\r\n}\r\nwlen = t->bits_per_word >> 3;\r\nwhile (count) {\r\ndev_dbg(qspi->dev, "rx cmd %08x dc %08x\n", cmd, qspi->dc);\r\nif (qspi_is_busy(qspi))\r\nreturn -EBUSY;\r\nti_qspi_write(qspi, cmd, QSPI_SPI_CMD_REG);\r\nif (ti_qspi_poll_wc(qspi)) {\r\ndev_err(qspi->dev, "read timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nswitch (wlen) {\r\ncase 1:\r\n*rxbuf = readb(qspi->base + QSPI_SPI_DATA_REG);\r\nbreak;\r\ncase 2:\r\n*((u16 *)rxbuf) = readw(qspi->base + QSPI_SPI_DATA_REG);\r\nbreak;\r\ncase 4:\r\n*((u32 *)rxbuf) = readl(qspi->base + QSPI_SPI_DATA_REG);\r\nbreak;\r\n}\r\nrxbuf += wlen;\r\ncount -= wlen;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qspi_transfer_msg(struct ti_qspi *qspi, struct spi_transfer *t,\r\nint count)\r\n{\r\nint ret;\r\nif (t->tx_buf) {\r\nret = qspi_write_msg(qspi, t, count);\r\nif (ret) {\r\ndev_dbg(qspi->dev, "Error while writing\n");\r\nreturn ret;\r\n}\r\n}\r\nif (t->rx_buf) {\r\nret = qspi_read_msg(qspi, t, count);\r\nif (ret) {\r\ndev_dbg(qspi->dev, "Error while reading\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ti_qspi_dma_callback(void *param)\r\n{\r\nstruct ti_qspi *qspi = param;\r\ncomplete(&qspi->transfer_complete);\r\n}\r\nstatic int ti_qspi_dma_xfer(struct ti_qspi *qspi, dma_addr_t dma_dst,\r\ndma_addr_t dma_src, size_t len)\r\n{\r\nstruct dma_chan *chan = qspi->rx_chan;\r\ndma_cookie_t cookie;\r\nenum dma_ctrl_flags flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;\r\nstruct dma_async_tx_descriptor *tx;\r\nint ret;\r\ntx = dmaengine_prep_dma_memcpy(chan, dma_dst, dma_src, len, flags);\r\nif (!tx) {\r\ndev_err(qspi->dev, "device_prep_dma_memcpy error\n");\r\nreturn -EIO;\r\n}\r\ntx->callback = ti_qspi_dma_callback;\r\ntx->callback_param = qspi;\r\ncookie = tx->tx_submit(tx);\r\nreinit_completion(&qspi->transfer_complete);\r\nret = dma_submit_error(cookie);\r\nif (ret) {\r\ndev_err(qspi->dev, "dma_submit_error %d\n", cookie);\r\nreturn -EIO;\r\n}\r\ndma_async_issue_pending(chan);\r\nret = wait_for_completion_timeout(&qspi->transfer_complete,\r\nmsecs_to_jiffies(len));\r\nif (ret <= 0) {\r\ndmaengine_terminate_sync(chan);\r\ndev_err(qspi->dev, "DMA wait_for_completion_timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_qspi_dma_bounce_buffer(struct ti_qspi *qspi,\r\nstruct spi_flash_read_message *msg)\r\n{\r\nsize_t readsize = msg->len;\r\nvoid *to = msg->buf;\r\ndma_addr_t dma_src = qspi->mmap_phys_base + msg->from;\r\nint ret = 0;\r\nwhile (readsize != 0) {\r\nsize_t xfer_len = min_t(size_t, QSPI_DMA_BUFFER_SIZE,\r\nreadsize);\r\nret = ti_qspi_dma_xfer(qspi, qspi->rx_bb_dma_addr,\r\ndma_src, xfer_len);\r\nif (ret != 0)\r\nreturn ret;\r\nmemcpy(to, qspi->rx_bb_addr, xfer_len);\r\nreadsize -= xfer_len;\r\ndma_src += xfer_len;\r\nto += xfer_len;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ti_qspi_dma_xfer_sg(struct ti_qspi *qspi, struct sg_table rx_sg,\r\nloff_t from)\r\n{\r\nstruct scatterlist *sg;\r\ndma_addr_t dma_src = qspi->mmap_phys_base + from;\r\ndma_addr_t dma_dst;\r\nint i, len, ret;\r\nfor_each_sg(rx_sg.sgl, sg, rx_sg.nents, i) {\r\ndma_dst = sg_dma_address(sg);\r\nlen = sg_dma_len(sg);\r\nret = ti_qspi_dma_xfer(qspi, dma_dst, dma_src, len);\r\nif (ret)\r\nreturn ret;\r\ndma_src += len;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ti_qspi_enable_memory_map(struct spi_device *spi)\r\n{\r\nstruct ti_qspi *qspi = spi_master_get_devdata(spi->master);\r\nti_qspi_write(qspi, MM_SWITCH, QSPI_SPI_SWITCH_REG);\r\nif (qspi->ctrl_base) {\r\nregmap_update_bits(qspi->ctrl_base, qspi->ctrl_reg,\r\nMEM_CS_EN(spi->chip_select),\r\nMEM_CS_MASK);\r\n}\r\nqspi->mmap_enabled = true;\r\n}\r\nstatic void ti_qspi_disable_memory_map(struct spi_device *spi)\r\n{\r\nstruct ti_qspi *qspi = spi_master_get_devdata(spi->master);\r\nti_qspi_write(qspi, 0, QSPI_SPI_SWITCH_REG);\r\nif (qspi->ctrl_base)\r\nregmap_update_bits(qspi->ctrl_base, qspi->ctrl_reg,\r\n0, MEM_CS_MASK);\r\nqspi->mmap_enabled = false;\r\n}\r\nstatic void ti_qspi_setup_mmap_read(struct spi_device *spi,\r\nstruct spi_flash_read_message *msg)\r\n{\r\nstruct ti_qspi *qspi = spi_master_get_devdata(spi->master);\r\nu32 memval = msg->read_opcode;\r\nswitch (msg->data_nbits) {\r\ncase SPI_NBITS_QUAD:\r\nmemval |= QSPI_SETUP_RD_QUAD;\r\nbreak;\r\ncase SPI_NBITS_DUAL:\r\nmemval |= QSPI_SETUP_RD_DUAL;\r\nbreak;\r\ndefault:\r\nmemval |= QSPI_SETUP_RD_NORMAL;\r\nbreak;\r\n}\r\nmemval |= ((msg->addr_width - 1) << QSPI_SETUP_ADDR_SHIFT |\r\nmsg->dummy_bytes << QSPI_SETUP_DUMMY_SHIFT);\r\nti_qspi_write(qspi, memval,\r\nQSPI_SPI_SETUP_REG(spi->chip_select));\r\n}\r\nstatic bool ti_qspi_spi_flash_can_dma(struct spi_device *spi,\r\nstruct spi_flash_read_message *msg)\r\n{\r\nreturn virt_addr_valid(msg->buf);\r\n}\r\nstatic int ti_qspi_spi_flash_read(struct spi_device *spi,\r\nstruct spi_flash_read_message *msg)\r\n{\r\nstruct ti_qspi *qspi = spi_master_get_devdata(spi->master);\r\nint ret = 0;\r\nmutex_lock(&qspi->list_lock);\r\nif (!qspi->mmap_enabled)\r\nti_qspi_enable_memory_map(spi);\r\nti_qspi_setup_mmap_read(spi, msg);\r\nif (qspi->rx_chan) {\r\nif (msg->cur_msg_mapped)\r\nret = ti_qspi_dma_xfer_sg(qspi, msg->rx_sg, msg->from);\r\nelse\r\nret = ti_qspi_dma_bounce_buffer(qspi, msg);\r\nif (ret)\r\ngoto err_unlock;\r\n} else {\r\nmemcpy_fromio(msg->buf, qspi->mmap_base + msg->from, msg->len);\r\n}\r\nmsg->retlen = msg->len;\r\nerr_unlock:\r\nmutex_unlock(&qspi->list_lock);\r\nreturn ret;\r\n}\r\nstatic int ti_qspi_start_transfer_one(struct spi_master *master,\r\nstruct spi_message *m)\r\n{\r\nstruct ti_qspi *qspi = spi_master_get_devdata(master);\r\nstruct spi_device *spi = m->spi;\r\nstruct spi_transfer *t;\r\nint status = 0, ret;\r\nunsigned int frame_len_words, transfer_len_words;\r\nint wlen;\r\nqspi->dc = 0;\r\nif (spi->mode & SPI_CPHA)\r\nqspi->dc |= QSPI_CKPHA(spi->chip_select);\r\nif (spi->mode & SPI_CPOL)\r\nqspi->dc |= QSPI_CKPOL(spi->chip_select);\r\nif (spi->mode & SPI_CS_HIGH)\r\nqspi->dc |= QSPI_CSPOL(spi->chip_select);\r\nframe_len_words = 0;\r\nlist_for_each_entry(t, &m->transfers, transfer_list)\r\nframe_len_words += t->len / (t->bits_per_word >> 3);\r\nframe_len_words = min_t(unsigned int, frame_len_words, QSPI_FRAME);\r\nqspi->cmd = 0;\r\nqspi->cmd |= QSPI_EN_CS(spi->chip_select);\r\nqspi->cmd |= QSPI_FLEN(frame_len_words);\r\nti_qspi_write(qspi, qspi->dc, QSPI_SPI_DC_REG);\r\nmutex_lock(&qspi->list_lock);\r\nif (qspi->mmap_enabled)\r\nti_qspi_disable_memory_map(spi);\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nqspi->cmd = ((qspi->cmd & ~QSPI_WLEN_MASK) |\r\nQSPI_WLEN(t->bits_per_word));\r\nwlen = t->bits_per_word >> 3;\r\ntransfer_len_words = min(t->len / wlen, frame_len_words);\r\nret = qspi_transfer_msg(qspi, t, transfer_len_words * wlen);\r\nif (ret) {\r\ndev_dbg(qspi->dev, "transfer message failed\n");\r\nmutex_unlock(&qspi->list_lock);\r\nreturn -EINVAL;\r\n}\r\nm->actual_length += transfer_len_words * wlen;\r\nframe_len_words -= transfer_len_words;\r\nif (frame_len_words == 0)\r\nbreak;\r\n}\r\nmutex_unlock(&qspi->list_lock);\r\nti_qspi_write(qspi, qspi->cmd | QSPI_INVAL, QSPI_SPI_CMD_REG);\r\nm->status = status;\r\nspi_finalize_current_message(master);\r\nreturn status;\r\n}\r\nstatic int ti_qspi_runtime_resume(struct device *dev)\r\n{\r\nstruct ti_qspi *qspi;\r\nqspi = dev_get_drvdata(dev);\r\nti_qspi_restore_ctx(qspi);\r\nreturn 0;\r\n}\r\nstatic int ti_qspi_probe(struct platform_device *pdev)\r\n{\r\nstruct ti_qspi *qspi;\r\nstruct spi_master *master;\r\nstruct resource *r, *res_mmap;\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 max_freq;\r\nint ret = 0, num_cs, irq;\r\ndma_cap_mask_t mask;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*qspi));\r\nif (!master)\r\nreturn -ENOMEM;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_RX_DUAL | SPI_RX_QUAD;\r\nmaster->flags = SPI_MASTER_HALF_DUPLEX;\r\nmaster->setup = ti_qspi_setup;\r\nmaster->auto_runtime_pm = true;\r\nmaster->transfer_one_message = ti_qspi_start_transfer_one;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(32) | SPI_BPW_MASK(16) |\r\nSPI_BPW_MASK(8);\r\nmaster->spi_flash_read = ti_qspi_spi_flash_read;\r\nif (!of_property_read_u32(np, "num-cs", &num_cs))\r\nmaster->num_chipselect = num_cs;\r\nqspi = spi_master_get_devdata(master);\r\nqspi->master = master;\r\nqspi->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, qspi);\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "qspi_base");\r\nif (r == NULL) {\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\ndev_err(&pdev->dev, "missing platform data\n");\r\nret = -ENODEV;\r\ngoto free_master;\r\n}\r\n}\r\nres_mmap = platform_get_resource_byname(pdev,\r\nIORESOURCE_MEM, "qspi_mmap");\r\nif (res_mmap == NULL) {\r\nres_mmap = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (res_mmap == NULL) {\r\ndev_err(&pdev->dev,\r\n"memory mapped resource not required\n");\r\n}\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nret = irq;\r\ngoto free_master;\r\n}\r\nmutex_init(&qspi->list_lock);\r\nqspi->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(qspi->base)) {\r\nret = PTR_ERR(qspi->base);\r\ngoto free_master;\r\n}\r\nif (of_property_read_bool(np, "syscon-chipselects")) {\r\nqspi->ctrl_base =\r\nsyscon_regmap_lookup_by_phandle(np,\r\n"syscon-chipselects");\r\nif (IS_ERR(qspi->ctrl_base)) {\r\nret = PTR_ERR(qspi->ctrl_base);\r\ngoto free_master;\r\n}\r\nret = of_property_read_u32_index(np,\r\n"syscon-chipselects",\r\n1, &qspi->ctrl_reg);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"couldn't get ctrl_mod reg index\n");\r\ngoto free_master;\r\n}\r\n}\r\nqspi->fclk = devm_clk_get(&pdev->dev, "fck");\r\nif (IS_ERR(qspi->fclk)) {\r\nret = PTR_ERR(qspi->fclk);\r\ndev_err(&pdev->dev, "could not get clk: %d\n", ret);\r\n}\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, QSPI_AUTOSUSPEND_TIMEOUT);\r\npm_runtime_enable(&pdev->dev);\r\nif (!of_property_read_u32(np, "spi-max-frequency", &max_freq))\r\nqspi->spi_max_frequency = max_freq;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_MEMCPY, mask);\r\nqspi->rx_chan = dma_request_chan_by_mask(&mask);\r\nif (IS_ERR(qspi->rx_chan)) {\r\ndev_err(qspi->dev,\r\n"No Rx DMA available, trying mmap mode\n");\r\nqspi->rx_chan = NULL;\r\nret = 0;\r\ngoto no_dma;\r\n}\r\nqspi->rx_bb_addr = dma_alloc_coherent(qspi->dev,\r\nQSPI_DMA_BUFFER_SIZE,\r\n&qspi->rx_bb_dma_addr,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!qspi->rx_bb_addr) {\r\ndev_err(qspi->dev,\r\n"dma_alloc_coherent failed, using PIO mode\n");\r\ndma_release_channel(qspi->rx_chan);\r\ngoto no_dma;\r\n}\r\nmaster->spi_flash_can_dma = ti_qspi_spi_flash_can_dma;\r\nmaster->dma_rx = qspi->rx_chan;\r\ninit_completion(&qspi->transfer_complete);\r\nif (res_mmap)\r\nqspi->mmap_phys_base = (dma_addr_t)res_mmap->start;\r\nno_dma:\r\nif (!qspi->rx_chan && res_mmap) {\r\nqspi->mmap_base = devm_ioremap_resource(&pdev->dev, res_mmap);\r\nif (IS_ERR(qspi->mmap_base)) {\r\ndev_info(&pdev->dev,\r\n"mmap failed with error %ld using PIO mode\n",\r\nPTR_ERR(qspi->mmap_base));\r\nqspi->mmap_base = NULL;\r\nmaster->spi_flash_read = NULL;\r\n}\r\n}\r\nqspi->mmap_enabled = false;\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (!ret)\r\nreturn 0;\r\npm_runtime_disable(&pdev->dev);\r\nfree_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int ti_qspi_remove(struct platform_device *pdev)\r\n{\r\nstruct ti_qspi *qspi = platform_get_drvdata(pdev);\r\nint rc;\r\nrc = spi_master_suspend(qspi->master);\r\nif (rc)\r\nreturn rc;\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nif (qspi->rx_bb_addr)\r\ndma_free_coherent(qspi->dev, QSPI_DMA_BUFFER_SIZE,\r\nqspi->rx_bb_addr,\r\nqspi->rx_bb_dma_addr);\r\nif (qspi->rx_chan)\r\ndma_release_channel(qspi->rx_chan);\r\nreturn 0;\r\n}
