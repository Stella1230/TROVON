static void pata_bk3710_setudmamode(void __iomem *base, unsigned int dev,\r\nunsigned int mode)\r\n{\r\nu32 val32;\r\nu16 val16;\r\nu8 tenv, trp, t0;\r\nt0 = DIV_ROUND_UP(pata_bk3710_udmatimings[mode].cycletime,\r\nideclk_period) - 1;\r\ntenv = DIV_ROUND_UP(20, ideclk_period) - 1;\r\ntrp = DIV_ROUND_UP(pata_bk3710_udmatimings[mode].rptime,\r\nideclk_period) - 1;\r\nval32 = ioread32(base + BK3710_UDMASTB) & (0xFF << (dev ? 0 : 8));\r\nval32 |= t0 << (dev ? 8 : 0);\r\niowrite32(val32, base + BK3710_UDMASTB);\r\nval32 = ioread32(base + BK3710_UDMATRP) & (0xFF << (dev ? 0 : 8));\r\nval32 |= trp << (dev ? 8 : 0);\r\niowrite32(val32, base + BK3710_UDMATRP);\r\nval32 = ioread32(base + BK3710_UDMAENV) & (0xFF << (dev ? 0 : 8));\r\nval32 |= tenv << (dev ? 8 : 0);\r\niowrite32(val32, base + BK3710_UDMAENV);\r\nval16 = ioread16(base + BK3710_UDMACTL) | (1 << dev);\r\niowrite16(val16, base + BK3710_UDMACTL);\r\n}\r\nstatic void pata_bk3710_setmwdmamode(void __iomem *base, unsigned int dev,\r\nunsigned short min_cycle,\r\nunsigned int mode)\r\n{\r\nconst struct ata_timing *t;\r\nint cycletime;\r\nu32 val32;\r\nu16 val16;\r\nu8 td, tkw, t0;\r\nt = ata_timing_find_mode(mode);\r\ncycletime = max_t(int, t->cycle, min_cycle);\r\nt0 = DIV_ROUND_UP(cycletime, ideclk_period);\r\ntd = DIV_ROUND_UP(t->active, ideclk_period);\r\ntkw = t0 - td - 1;\r\ntd--;\r\nval32 = ioread32(base + BK3710_DMASTB) & (0xFF << (dev ? 0 : 8));\r\nval32 |= td << (dev ? 8 : 0);\r\niowrite32(val32, base + BK3710_DMASTB);\r\nval32 = ioread32(base + BK3710_DMARCVR) & (0xFF << (dev ? 0 : 8));\r\nval32 |= tkw << (dev ? 8 : 0);\r\niowrite32(val32, base + BK3710_DMARCVR);\r\nval16 = ioread16(base + BK3710_UDMACTL) & ~(1 << dev);\r\niowrite16(val16, base + BK3710_UDMACTL);\r\n}\r\nstatic void pata_bk3710_set_dmamode(struct ata_port *ap,\r\nstruct ata_device *adev)\r\n{\r\nvoid __iomem *base = (void __iomem *)ap->ioaddr.bmdma_addr;\r\nint is_slave = adev->devno;\r\nconst u8 xferspeed = adev->dma_mode;\r\nif (xferspeed >= XFER_UDMA_0)\r\npata_bk3710_setudmamode(base, is_slave,\r\nxferspeed - XFER_UDMA_0);\r\nelse\r\npata_bk3710_setmwdmamode(base, is_slave,\r\nadev->id[ATA_ID_EIDE_DMA_MIN],\r\nxferspeed);\r\n}\r\nstatic void pata_bk3710_setpiomode(void __iomem *base, struct ata_device *pair,\r\nunsigned int dev, unsigned int cycletime,\r\nunsigned int mode)\r\n{\r\nconst struct ata_timing *t;\r\nu32 val32;\r\nu8 t2, t2i, t0;\r\nt = ata_timing_find_mode(XFER_PIO_0 + mode);\r\nt0 = DIV_ROUND_UP(cycletime, ideclk_period);\r\nt2 = DIV_ROUND_UP(t->active, ideclk_period);\r\nt2i = t0 - t2 - 1;\r\nt2--;\r\nval32 = ioread32(base + BK3710_DATSTB) & (0xFF << (dev ? 0 : 8));\r\nval32 |= t2 << (dev ? 8 : 0);\r\niowrite32(val32, base + BK3710_DATSTB);\r\nval32 = ioread32(base + BK3710_DATRCVR) & (0xFF << (dev ? 0 : 8));\r\nval32 |= t2i << (dev ? 8 : 0);\r\niowrite32(val32, base + BK3710_DATRCVR);\r\nif (pair) {\r\nu8 mode2 = pair->pio_mode - XFER_PIO_0;\r\nif (mode2 < mode)\r\nmode = mode2;\r\n}\r\nt0 = DIV_ROUND_UP(t->cyc8b, ideclk_period);\r\nt2 = DIV_ROUND_UP(t->act8b, ideclk_period);\r\nt2i = t0 - t2 - 1;\r\nt2--;\r\nval32 = ioread32(base + BK3710_REGSTB) & (0xFF << (dev ? 0 : 8));\r\nval32 |= t2 << (dev ? 8 : 0);\r\niowrite32(val32, base + BK3710_REGSTB);\r\nval32 = ioread32(base + BK3710_REGRCVR) & (0xFF << (dev ? 0 : 8));\r\nval32 |= t2i << (dev ? 8 : 0);\r\niowrite32(val32, base + BK3710_REGRCVR);\r\n}\r\nstatic void pata_bk3710_set_piomode(struct ata_port *ap,\r\nstruct ata_device *adev)\r\n{\r\nvoid __iomem *base = (void __iomem *)ap->ioaddr.bmdma_addr;\r\nstruct ata_device *pair = ata_dev_pair(adev);\r\nconst struct ata_timing *t = ata_timing_find_mode(adev->pio_mode);\r\nconst u16 *id = adev->id;\r\nunsigned int cycle_time = 0;\r\nint is_slave = adev->devno;\r\nconst u8 pio = adev->pio_mode - XFER_PIO_0;\r\nif (id[ATA_ID_FIELD_VALID] & 2) {\r\nif (ata_id_has_iordy(id))\r\ncycle_time = id[ATA_ID_EIDE_PIO_IORDY];\r\nelse\r\ncycle_time = id[ATA_ID_EIDE_PIO];\r\nif (pio < 3 && cycle_time < t->cycle)\r\ncycle_time = 0;\r\n}\r\nif (!cycle_time)\r\ncycle_time = t->cycle;\r\npata_bk3710_setpiomode(base, pair, is_slave, cycle_time, pio);\r\n}\r\nstatic void pata_bk3710_chipinit(void __iomem *base)\r\n{\r\niowrite16(BIT(15), base + BK3710_IDETIMP);\r\niowrite16(0, base + BK3710_UDMACTL);\r\niowrite32(0x001, base + BK3710_MISCCTL);\r\niowrite32(0, base + BK3710_IORDYTMP);\r\niowrite16(0xE, base + BK3710_BMISP);\r\npata_bk3710_setpiomode(base, NULL, 0, 600, 0);\r\npata_bk3710_setpiomode(base, NULL, 1, 600, 0);\r\n}\r\nstatic int __init pata_bk3710_probe(struct platform_device *pdev)\r\n{\r\nstruct clk *clk;\r\nstruct resource *mem;\r\nstruct ata_host *host;\r\nstruct ata_port *ap;\r\nvoid __iomem *base;\r\nunsigned long rate;\r\nint irq;\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk))\r\nreturn -ENODEV;\r\nclk_enable(clk);\r\nrate = clk_get_rate(clk);\r\nif (!rate)\r\nreturn -EINVAL;\r\nideclk_period = 1000000000UL / rate;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\npr_err(DRV_NAME ": failed to get IRQ resource\n");\r\nreturn irq;\r\n}\r\nbase = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\npata_bk3710_chipinit(base);\r\nhost = ata_host_alloc(&pdev->dev, 1);\r\nif (!host)\r\nreturn -ENOMEM;\r\nap = host->ports[0];\r\nap->ops = &pata_bk3710_ports_ops;\r\nap->pio_mask = ATA_PIO4;\r\nap->mwdma_mask = ATA_MWDMA2;\r\nap->udma_mask = rate < 100000000 ? ATA_UDMA4 : ATA_UDMA5;\r\nap->flags |= ATA_FLAG_SLAVE_POSS;\r\nap->ioaddr.data_addr = base + BK3710_TF_OFFSET;\r\nap->ioaddr.error_addr = base + BK3710_TF_OFFSET + 1;\r\nap->ioaddr.feature_addr = base + BK3710_TF_OFFSET + 1;\r\nap->ioaddr.nsect_addr = base + BK3710_TF_OFFSET + 2;\r\nap->ioaddr.lbal_addr = base + BK3710_TF_OFFSET + 3;\r\nap->ioaddr.lbam_addr = base + BK3710_TF_OFFSET + 4;\r\nap->ioaddr.lbah_addr = base + BK3710_TF_OFFSET + 5;\r\nap->ioaddr.device_addr = base + BK3710_TF_OFFSET + 6;\r\nap->ioaddr.status_addr = base + BK3710_TF_OFFSET + 7;\r\nap->ioaddr.command_addr = base + BK3710_TF_OFFSET + 7;\r\nap->ioaddr.altstatus_addr = base + BK3710_CTL_OFFSET;\r\nap->ioaddr.ctl_addr = base + BK3710_CTL_OFFSET;\r\nap->ioaddr.bmdma_addr = base;\r\nata_port_desc(ap, "cmd 0x%lx ctl 0x%lx",\r\n(unsigned long)base + BK3710_TF_OFFSET,\r\n(unsigned long)base + BK3710_CTL_OFFSET);\r\nreturn ata_host_activate(host, irq, ata_sff_interrupt, 0,\r\n&pata_bk3710_sht);\r\n}\r\nstatic int __init pata_bk3710_init(void)\r\n{\r\nreturn platform_driver_probe(&pata_bk3710_driver, pata_bk3710_probe);\r\n}
