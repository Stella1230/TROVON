static void dwmac4_dma_axi(void __iomem *ioaddr, struct stmmac_axi *axi)\r\n{\r\nu32 value = readl(ioaddr + DMA_SYS_BUS_MODE);\r\nint i;\r\npr_info("dwmac4: Master AXI performs %s burst length\n",\r\n(value & DMA_SYS_BUS_FB) ? "fixed" : "any");\r\nif (axi->axi_lpi_en)\r\nvalue |= DMA_AXI_EN_LPI;\r\nif (axi->axi_xit_frm)\r\nvalue |= DMA_AXI_LPI_XIT_FRM;\r\nvalue &= ~DMA_AXI_WR_OSR_LMT;\r\nvalue |= (axi->axi_wr_osr_lmt & DMA_AXI_OSR_MAX) <<\r\nDMA_AXI_WR_OSR_LMT_SHIFT;\r\nvalue &= ~DMA_AXI_RD_OSR_LMT;\r\nvalue |= (axi->axi_rd_osr_lmt & DMA_AXI_OSR_MAX) <<\r\nDMA_AXI_RD_OSR_LMT_SHIFT;\r\nfor (i = 0; i < AXI_BLEN; i++) {\r\nswitch (axi->axi_blen[i]) {\r\ncase 256:\r\nvalue |= DMA_AXI_BLEN256;\r\nbreak;\r\ncase 128:\r\nvalue |= DMA_AXI_BLEN128;\r\nbreak;\r\ncase 64:\r\nvalue |= DMA_AXI_BLEN64;\r\nbreak;\r\ncase 32:\r\nvalue |= DMA_AXI_BLEN32;\r\nbreak;\r\ncase 16:\r\nvalue |= DMA_AXI_BLEN16;\r\nbreak;\r\ncase 8:\r\nvalue |= DMA_AXI_BLEN8;\r\nbreak;\r\ncase 4:\r\nvalue |= DMA_AXI_BLEN4;\r\nbreak;\r\n}\r\n}\r\nwritel(value, ioaddr + DMA_SYS_BUS_MODE);\r\n}\r\nstatic void dwmac4_dma_init_rx_chan(void __iomem *ioaddr,\r\nstruct stmmac_dma_cfg *dma_cfg,\r\nu32 dma_rx_phy, u32 chan)\r\n{\r\nu32 value;\r\nu32 rxpbl = dma_cfg->rxpbl ?: dma_cfg->pbl;\r\nvalue = readl(ioaddr + DMA_CHAN_RX_CONTROL(chan));\r\nvalue = value | (rxpbl << DMA_BUS_MODE_RPBL_SHIFT);\r\nwritel(value, ioaddr + DMA_CHAN_RX_CONTROL(chan));\r\nwritel(dma_rx_phy, ioaddr + DMA_CHAN_RX_BASE_ADDR(chan));\r\n}\r\nstatic void dwmac4_dma_init_tx_chan(void __iomem *ioaddr,\r\nstruct stmmac_dma_cfg *dma_cfg,\r\nu32 dma_tx_phy, u32 chan)\r\n{\r\nu32 value;\r\nu32 txpbl = dma_cfg->txpbl ?: dma_cfg->pbl;\r\nvalue = readl(ioaddr + DMA_CHAN_TX_CONTROL(chan));\r\nvalue = value | (txpbl << DMA_BUS_MODE_PBL_SHIFT);\r\nwritel(value, ioaddr + DMA_CHAN_TX_CONTROL(chan));\r\nwritel(dma_tx_phy, ioaddr + DMA_CHAN_TX_BASE_ADDR(chan));\r\n}\r\nstatic void dwmac4_dma_init_channel(void __iomem *ioaddr,\r\nstruct stmmac_dma_cfg *dma_cfg, u32 chan)\r\n{\r\nu32 value;\r\nvalue = readl(ioaddr + DMA_CHAN_CONTROL(chan));\r\nif (dma_cfg->pblx8)\r\nvalue = value | DMA_BUS_MODE_PBL;\r\nwritel(value, ioaddr + DMA_CHAN_CONTROL(chan));\r\nwritel(DMA_CHAN_INTR_DEFAULT_MASK,\r\nioaddr + DMA_CHAN_INTR_ENA(chan));\r\n}\r\nstatic void dwmac4_dma_init(void __iomem *ioaddr,\r\nstruct stmmac_dma_cfg *dma_cfg,\r\nu32 dma_tx, u32 dma_rx, int atds)\r\n{\r\nu32 value = readl(ioaddr + DMA_SYS_BUS_MODE);\r\nif (dma_cfg->fixed_burst)\r\nvalue |= DMA_SYS_BUS_FB;\r\nif (dma_cfg->mixed_burst)\r\nvalue |= DMA_SYS_BUS_MB;\r\nif (dma_cfg->aal)\r\nvalue |= DMA_SYS_BUS_AAL;\r\nwritel(value, ioaddr + DMA_SYS_BUS_MODE);\r\n}\r\nstatic void _dwmac4_dump_dma_regs(void __iomem *ioaddr, u32 channel,\r\nu32 *reg_space)\r\n{\r\nreg_space[DMA_CHAN_CONTROL(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_CONTROL(channel));\r\nreg_space[DMA_CHAN_TX_CONTROL(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_TX_CONTROL(channel));\r\nreg_space[DMA_CHAN_RX_CONTROL(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_RX_CONTROL(channel));\r\nreg_space[DMA_CHAN_TX_BASE_ADDR(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_TX_BASE_ADDR(channel));\r\nreg_space[DMA_CHAN_RX_BASE_ADDR(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_RX_BASE_ADDR(channel));\r\nreg_space[DMA_CHAN_TX_END_ADDR(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_TX_END_ADDR(channel));\r\nreg_space[DMA_CHAN_RX_END_ADDR(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_RX_END_ADDR(channel));\r\nreg_space[DMA_CHAN_TX_RING_LEN(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_TX_RING_LEN(channel));\r\nreg_space[DMA_CHAN_RX_RING_LEN(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_RX_RING_LEN(channel));\r\nreg_space[DMA_CHAN_INTR_ENA(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_INTR_ENA(channel));\r\nreg_space[DMA_CHAN_RX_WATCHDOG(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_RX_WATCHDOG(channel));\r\nreg_space[DMA_CHAN_SLOT_CTRL_STATUS(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_SLOT_CTRL_STATUS(channel));\r\nreg_space[DMA_CHAN_CUR_TX_DESC(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_CUR_TX_DESC(channel));\r\nreg_space[DMA_CHAN_CUR_RX_DESC(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_CUR_RX_DESC(channel));\r\nreg_space[DMA_CHAN_CUR_TX_BUF_ADDR(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_CUR_TX_BUF_ADDR(channel));\r\nreg_space[DMA_CHAN_CUR_RX_BUF_ADDR(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_CUR_RX_BUF_ADDR(channel));\r\nreg_space[DMA_CHAN_STATUS(channel) / 4] =\r\nreadl(ioaddr + DMA_CHAN_STATUS(channel));\r\n}\r\nstatic void dwmac4_dump_dma_regs(void __iomem *ioaddr, u32 *reg_space)\r\n{\r\nint i;\r\nfor (i = 0; i < DMA_CHANNEL_NB_MAX; i++)\r\n_dwmac4_dump_dma_regs(ioaddr, i, reg_space);\r\n}\r\nstatic void dwmac4_rx_watchdog(void __iomem *ioaddr, u32 riwt, u32 number_chan)\r\n{\r\nu32 chan;\r\nfor (chan = 0; chan < number_chan; chan++)\r\nwritel(riwt, ioaddr + DMA_CHAN_RX_WATCHDOG(chan));\r\n}\r\nstatic void dwmac4_dma_rx_chan_op_mode(void __iomem *ioaddr, int mode,\r\nu32 channel, int fifosz)\r\n{\r\nunsigned int rqs = fifosz / 256 - 1;\r\nu32 mtl_rx_op, mtl_rx_int;\r\nmtl_rx_op = readl(ioaddr + MTL_CHAN_RX_OP_MODE(channel));\r\nif (mode == SF_DMA_MODE) {\r\npr_debug("GMAC: enable RX store and forward mode\n");\r\nmtl_rx_op |= MTL_OP_MODE_RSF;\r\n} else {\r\npr_debug("GMAC: disable RX SF mode (threshold %d)\n", mode);\r\nmtl_rx_op &= ~MTL_OP_MODE_RSF;\r\nmtl_rx_op &= MTL_OP_MODE_RTC_MASK;\r\nif (mode <= 32)\r\nmtl_rx_op |= MTL_OP_MODE_RTC_32;\r\nelse if (mode <= 64)\r\nmtl_rx_op |= MTL_OP_MODE_RTC_64;\r\nelse if (mode <= 96)\r\nmtl_rx_op |= MTL_OP_MODE_RTC_96;\r\nelse\r\nmtl_rx_op |= MTL_OP_MODE_RTC_128;\r\n}\r\nmtl_rx_op &= ~MTL_OP_MODE_RQS_MASK;\r\nmtl_rx_op |= rqs << MTL_OP_MODE_RQS_SHIFT;\r\nif (fifosz >= 4096) {\r\nunsigned int rfd, rfa;\r\nmtl_rx_op |= MTL_OP_MODE_EHFC;\r\nswitch (fifosz) {\r\ncase 4096:\r\nrfd = 0x03;\r\nrfa = 0x01;\r\nbreak;\r\ncase 8192:\r\nrfd = 0x06;\r\nrfa = 0x0a;\r\nbreak;\r\ncase 16384:\r\nrfd = 0x06;\r\nrfa = 0x12;\r\nbreak;\r\ndefault:\r\nrfd = 0x06;\r\nrfa = 0x1e;\r\nbreak;\r\n}\r\nmtl_rx_op &= ~MTL_OP_MODE_RFD_MASK;\r\nmtl_rx_op |= rfd << MTL_OP_MODE_RFD_SHIFT;\r\nmtl_rx_op &= ~MTL_OP_MODE_RFA_MASK;\r\nmtl_rx_op |= rfa << MTL_OP_MODE_RFA_SHIFT;\r\n}\r\nwritel(mtl_rx_op, ioaddr + MTL_CHAN_RX_OP_MODE(channel));\r\nmtl_rx_int = readl(ioaddr + MTL_CHAN_INT_CTRL(channel));\r\nwritel(mtl_rx_int | MTL_RX_OVERFLOW_INT_EN,\r\nioaddr + MTL_CHAN_INT_CTRL(channel));\r\n}\r\nstatic void dwmac4_dma_tx_chan_op_mode(void __iomem *ioaddr, int mode,\r\nu32 channel)\r\n{\r\nu32 mtl_tx_op = readl(ioaddr + MTL_CHAN_TX_OP_MODE(channel));\r\nif (mode == SF_DMA_MODE) {\r\npr_debug("GMAC: enable TX store and forward mode\n");\r\nmtl_tx_op |= MTL_OP_MODE_TSF;\r\n} else {\r\npr_debug("GMAC: disabling TX SF (threshold %d)\n", mode);\r\nmtl_tx_op &= ~MTL_OP_MODE_TSF;\r\nmtl_tx_op &= MTL_OP_MODE_TTC_MASK;\r\nif (mode <= 32)\r\nmtl_tx_op |= MTL_OP_MODE_TTC_32;\r\nelse if (mode <= 64)\r\nmtl_tx_op |= MTL_OP_MODE_TTC_64;\r\nelse if (mode <= 96)\r\nmtl_tx_op |= MTL_OP_MODE_TTC_96;\r\nelse if (mode <= 128)\r\nmtl_tx_op |= MTL_OP_MODE_TTC_128;\r\nelse if (mode <= 192)\r\nmtl_tx_op |= MTL_OP_MODE_TTC_192;\r\nelse if (mode <= 256)\r\nmtl_tx_op |= MTL_OP_MODE_TTC_256;\r\nelse if (mode <= 384)\r\nmtl_tx_op |= MTL_OP_MODE_TTC_384;\r\nelse\r\nmtl_tx_op |= MTL_OP_MODE_TTC_512;\r\n}\r\nmtl_tx_op |= MTL_OP_MODE_TXQEN | MTL_OP_MODE_TQS_MASK;\r\nwritel(mtl_tx_op, ioaddr + MTL_CHAN_TX_OP_MODE(channel));\r\n}\r\nstatic void dwmac4_get_hw_feature(void __iomem *ioaddr,\r\nstruct dma_features *dma_cap)\r\n{\r\nu32 hw_cap = readl(ioaddr + GMAC_HW_FEATURE0);\r\ndma_cap->mbps_10_100 = (hw_cap & GMAC_HW_FEAT_MIISEL);\r\ndma_cap->mbps_1000 = (hw_cap & GMAC_HW_FEAT_GMIISEL) >> 1;\r\ndma_cap->half_duplex = (hw_cap & GMAC_HW_FEAT_HDSEL) >> 2;\r\ndma_cap->hash_filter = (hw_cap & GMAC_HW_FEAT_VLHASH) >> 4;\r\ndma_cap->multi_addr = (hw_cap & GMAC_HW_FEAT_ADDMAC) >> 18;\r\ndma_cap->pcs = (hw_cap & GMAC_HW_FEAT_PCSSEL) >> 3;\r\ndma_cap->sma_mdio = (hw_cap & GMAC_HW_FEAT_SMASEL) >> 5;\r\ndma_cap->pmt_remote_wake_up = (hw_cap & GMAC_HW_FEAT_RWKSEL) >> 6;\r\ndma_cap->pmt_magic_frame = (hw_cap & GMAC_HW_FEAT_MGKSEL) >> 7;\r\ndma_cap->rmon = (hw_cap & GMAC_HW_FEAT_MMCSEL) >> 8;\r\ndma_cap->atime_stamp = (hw_cap & GMAC_HW_FEAT_TSSEL) >> 12;\r\ndma_cap->eee = (hw_cap & GMAC_HW_FEAT_EEESEL) >> 13;\r\ndma_cap->tx_coe = (hw_cap & GMAC_HW_FEAT_TXCOSEL) >> 14;\r\ndma_cap->rx_coe = (hw_cap & GMAC_HW_FEAT_RXCOESEL) >> 16;\r\nhw_cap = readl(ioaddr + GMAC_HW_FEATURE1);\r\ndma_cap->av = (hw_cap & GMAC_HW_FEAT_AVSEL) >> 20;\r\ndma_cap->tsoen = (hw_cap & GMAC_HW_TSOEN) >> 18;\r\ndma_cap->tx_fifo_size = 128 << ((hw_cap & GMAC_HW_TXFIFOSIZE) >> 6);\r\ndma_cap->rx_fifo_size = 128 << ((hw_cap & GMAC_HW_RXFIFOSIZE) >> 0);\r\nhw_cap = readl(ioaddr + GMAC_HW_FEATURE2);\r\ndma_cap->number_rx_channel =\r\n((hw_cap & GMAC_HW_FEAT_RXCHCNT) >> 12) + 1;\r\ndma_cap->number_tx_channel =\r\n((hw_cap & GMAC_HW_FEAT_TXCHCNT) >> 18) + 1;\r\ndma_cap->number_rx_queues =\r\n((hw_cap & GMAC_HW_FEAT_RXQCNT) >> 0) + 1;\r\ndma_cap->number_tx_queues =\r\n((hw_cap & GMAC_HW_FEAT_TXQCNT) >> 6) + 1;\r\ndma_cap->time_stamp = 0;\r\n}\r\nstatic void dwmac4_enable_tso(void __iomem *ioaddr, bool en, u32 chan)\r\n{\r\nu32 value;\r\nif (en) {\r\nvalue = readl(ioaddr + DMA_CHAN_TX_CONTROL(chan));\r\nwritel(value | DMA_CONTROL_TSE,\r\nioaddr + DMA_CHAN_TX_CONTROL(chan));\r\n} else {\r\nvalue = readl(ioaddr + DMA_CHAN_TX_CONTROL(chan));\r\nwritel(value & ~DMA_CONTROL_TSE,\r\nioaddr + DMA_CHAN_TX_CONTROL(chan));\r\n}\r\n}
