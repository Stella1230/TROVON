static acpi_status\r\nacpi_db_start_command(struct acpi_walk_state *walk_state,\r\nunion acpi_parse_object *op)\r\n{\r\nacpi_status status;\r\nacpi_gbl_method_executing = TRUE;\r\nstatus = AE_CTRL_TRUE;\r\nwhile (status == AE_CTRL_TRUE) {\r\nstatus = acpi_os_notify_command_complete();\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\nstatus = acpi_os_wait_command_ready();\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\nstatus =\r\nacpi_db_command_dispatch(acpi_gbl_db_line_buf, walk_state,\r\nop);\r\n}\r\nerror_exit:\r\nif (ACPI_FAILURE(status) && status != AE_CTRL_TERMINATE) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"While parsing/handling command line"));\r\n}\r\nreturn (status);\r\n}\r\nvoid acpi_db_signal_break_point(struct acpi_walk_state *walk_state)\r\n{\r\n#ifndef ACPI_APPLICATION\r\nif (acpi_gbl_db_thread_id != acpi_os_get_thread_id()) {\r\nreturn;\r\n}\r\n#endif\r\nacpi_gbl_cm_single_step = TRUE;\r\nacpi_os_printf("**break** Executed AML BreakPoint opcode\n");\r\n}\r\nacpi_status\r\nacpi_db_single_step(struct acpi_walk_state *walk_state,\r\nunion acpi_parse_object *op, u32 opcode_class)\r\n{\r\nunion acpi_parse_object *next;\r\nacpi_status status = AE_OK;\r\nu32 original_debug_level;\r\nunion acpi_parse_object *display_op;\r\nunion acpi_parse_object *parent_op;\r\nu32 aml_offset;\r\nACPI_FUNCTION_ENTRY();\r\n#ifndef ACPI_APPLICATION\r\nif (acpi_gbl_db_thread_id != acpi_os_get_thread_id()) {\r\nreturn (AE_OK);\r\n}\r\n#endif\r\nif (acpi_gbl_abort_method) {\r\nacpi_gbl_abort_method = FALSE;\r\nreturn (AE_ABORT_METHOD);\r\n}\r\naml_offset = (u32)ACPI_PTR_DIFF(op->common.aml,\r\nwalk_state->parser_state.aml_start);\r\nif (walk_state->method_breakpoint &&\r\n(walk_state->method_breakpoint <= aml_offset)) {\r\nacpi_os_printf("***Break*** at AML offset %X\n", aml_offset);\r\nacpi_gbl_cm_single_step = TRUE;\r\nacpi_gbl_step_to_next_call = FALSE;\r\nwalk_state->method_breakpoint = 0;\r\n}\r\nelse if (walk_state->user_breakpoint &&\r\n(walk_state->user_breakpoint == aml_offset)) {\r\nacpi_os_printf("***UserBreakpoint*** at AML offset %X\n",\r\naml_offset);\r\nacpi_gbl_cm_single_step = TRUE;\r\nacpi_gbl_step_to_next_call = FALSE;\r\nwalk_state->method_breakpoint = 0;\r\n}\r\nif (op->common.aml_opcode == AML_INT_NAMEDFIELD_OP) {\r\nreturn (AE_OK);\r\n}\r\nswitch (opcode_class) {\r\ncase AML_CLASS_UNKNOWN:\r\ncase AML_CLASS_ARGUMENT:\r\nreturn (AE_OK);\r\ndefault:\r\nbreak;\r\n}\r\nif ((acpi_gbl_db_output_to_file) ||\r\n(acpi_gbl_cm_single_step) || (acpi_dbg_level & ACPI_LV_PARSE)) {\r\nif ((acpi_gbl_db_output_to_file) ||\r\n(acpi_dbg_level & ACPI_LV_PARSE)) {\r\nacpi_os_printf\r\n("\nAML Debug: Next AML Opcode to execute:\n");\r\n}\r\noriginal_debug_level = acpi_dbg_level;\r\nacpi_dbg_level &= ~(ACPI_LV_PARSE | ACPI_LV_FUNCTIONS);\r\nnext = op->common.next;\r\nop->common.next = NULL;\r\ndisplay_op = op;\r\nparent_op = op->common.parent;\r\nif (parent_op) {\r\nif ((walk_state->control_state) &&\r\n(walk_state->control_state->common.state ==\r\nACPI_CONTROL_PREDICATE_EXECUTING)) {\r\nwhile (parent_op) {\r\nif ((parent_op->common.aml_opcode ==\r\nAML_IF_OP)\r\n|| (parent_op->common.aml_opcode ==\r\nAML_WHILE_OP)) {\r\ndisplay_op = parent_op;\r\nbreak;\r\n}\r\nparent_op = parent_op->common.parent;\r\n}\r\n} else {\r\nwhile (parent_op) {\r\nif ((parent_op->common.aml_opcode ==\r\nAML_IF_OP)\r\n|| (parent_op->common.aml_opcode ==\r\nAML_ELSE_OP)\r\n|| (parent_op->common.aml_opcode ==\r\nAML_SCOPE_OP)\r\n|| (parent_op->common.aml_opcode ==\r\nAML_METHOD_OP)\r\n|| (parent_op->common.aml_opcode ==\r\nAML_WHILE_OP)) {\r\nbreak;\r\n}\r\ndisplay_op = parent_op;\r\nparent_op = parent_op->common.parent;\r\n}\r\n}\r\n}\r\n#ifdef ACPI_DISASSEMBLER\r\nacpi_dm_disassemble(walk_state, display_op, ACPI_UINT32_MAX);\r\n#endif\r\nif ((op->common.aml_opcode == AML_IF_OP) ||\r\n(op->common.aml_opcode == AML_WHILE_OP)) {\r\nif (walk_state->control_state->common.value) {\r\nacpi_os_printf\r\n("Predicate = [True], IF block was executed\n");\r\n} else {\r\nacpi_os_printf\r\n("Predicate = [False], Skipping IF block\n");\r\n}\r\n} else if (op->common.aml_opcode == AML_ELSE_OP) {\r\nacpi_os_printf\r\n("Predicate = [False], ELSE block was executed\n");\r\n}\r\nop->common.next = next;\r\nacpi_os_printf("\n");\r\nif ((acpi_gbl_db_output_to_file) ||\r\n(acpi_dbg_level & ACPI_LV_PARSE)) {\r\nacpi_os_printf("\n");\r\n}\r\nacpi_dbg_level = original_debug_level;\r\n}\r\nif (!acpi_gbl_cm_single_step) {\r\nreturn (AE_OK);\r\n}\r\nif (acpi_gbl_step_to_next_call) {\r\nif (op->common.aml_opcode != AML_INT_METHODCALL_OP) {\r\nreturn (AE_OK);\r\n}\r\nacpi_gbl_step_to_next_call = FALSE;\r\n}\r\nif (op->common.aml_opcode == AML_INT_METHODCALL_OP) {\r\nacpi_gbl_cm_single_step = FALSE;\r\nwalk_state->method_breakpoint = 1;\r\n}\r\nacpi_ex_exit_interpreter();\r\nstatus = acpi_db_start_command(walk_state, op);\r\nacpi_ex_enter_interpreter();\r\nreturn (status);\r\n}\r\nacpi_status acpi_initialize_debugger(void)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_initialize_debugger);\r\nacpi_gbl_db_buffer = NULL;\r\nacpi_gbl_db_filename = NULL;\r\nacpi_gbl_db_output_to_file = FALSE;\r\nacpi_gbl_db_debug_level = ACPI_LV_VERBOSITY2;\r\nacpi_gbl_db_console_debug_level = ACPI_NORMAL_DEFAULT | ACPI_LV_TABLES;\r\nacpi_gbl_db_output_flags = ACPI_DB_CONSOLE_OUTPUT;\r\nacpi_gbl_db_opt_no_ini_methods = FALSE;\r\nacpi_gbl_db_buffer = acpi_os_allocate(ACPI_DEBUG_BUFFER_SIZE);\r\nif (!acpi_gbl_db_buffer) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nmemset(acpi_gbl_db_buffer, 0, ACPI_DEBUG_BUFFER_SIZE);\r\nacpi_gbl_db_scope_buf[0] = AML_ROOT_PREFIX;\r\nacpi_gbl_db_scope_buf[1] = 0;\r\nacpi_gbl_db_scope_node = acpi_gbl_root_node;\r\nacpi_gbl_db_terminate_loop = FALSE;\r\nif (acpi_gbl_debugger_configuration & DEBUGGER_MULTI_THREADED) {\r\nstatus = acpi_os_initialize_debugger();\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could not get debugger mutex\n");\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_gbl_db_threads_terminated = FALSE;\r\nstatus = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,\r\nacpi_db_execute_thread, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Could not start debugger thread"));\r\nacpi_gbl_db_threads_terminated = TRUE;\r\nreturn_ACPI_STATUS(status);\r\n}\r\n} else {\r\nacpi_gbl_db_thread_id = acpi_os_get_thread_id();\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nvoid acpi_terminate_debugger(void)\r\n{\r\nacpi_gbl_db_terminate_loop = TRUE;\r\nif (acpi_gbl_debugger_configuration & DEBUGGER_MULTI_THREADED) {\r\nwhile (!acpi_gbl_db_threads_terminated) {\r\nacpi_os_sleep(100);\r\n}\r\nacpi_os_terminate_debugger();\r\n}\r\nif (acpi_gbl_db_buffer) {\r\nacpi_os_free(acpi_gbl_db_buffer);\r\nacpi_gbl_db_buffer = NULL;\r\n}\r\nacpi_gbl_db_output_flags = ACPI_DB_DISABLE_OUTPUT;\r\n}\r\nvoid acpi_set_debugger_thread_id(acpi_thread_id thread_id)\r\n{\r\nacpi_gbl_db_thread_id = thread_id;\r\n}
