static void\r\nmptspi_setTargetNegoParms(MPT_SCSI_HOST *hd, VirtTarget *target,\r\nstruct scsi_device *sdev)\r\n{\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nSpiCfgData *pspi_data = &ioc->spi_data;\r\nint id = (int) target->id;\r\nint nvram;\r\nu8 width = MPT_NARROW;\r\nu8 factor = MPT_ASYNC;\r\nu8 offset = 0;\r\nu8 nfactor;\r\nu8 noQas = 1;\r\ntarget->negoFlags = pspi_data->noQas;\r\nif (sdev->scsi_level < SCSI_2) {\r\nwidth = 0;\r\nfactor = MPT_ULTRA2;\r\noffset = pspi_data->maxSyncOffset;\r\ntarget->tflags &= ~MPT_TARGET_FLAGS_Q_YES;\r\n} else {\r\nif (scsi_device_wide(sdev))\r\nwidth = 1;\r\nif (scsi_device_sync(sdev)) {\r\nfactor = pspi_data->minSyncFactor;\r\nif (!scsi_device_dt(sdev))\r\nfactor = MPT_ULTRA2;\r\nelse {\r\nif (!scsi_device_ius(sdev) &&\r\n!scsi_device_qas(sdev))\r\nfactor = MPT_ULTRA160;\r\nelse {\r\nfactor = MPT_ULTRA320;\r\nif (scsi_device_qas(sdev)) {\r\nddvprintk(ioc,\r\nprintk(MYIOC_s_DEBUG_FMT "Enabling QAS due to "\r\n"byte56=%02x on id=%d!\n", ioc->name,\r\nscsi_device_qas(sdev), id));\r\nnoQas = 0;\r\n}\r\nif (sdev->type == TYPE_TAPE &&\r\nscsi_device_ius(sdev))\r\ntarget->negoFlags |= MPT_TAPE_NEGO_IDP;\r\n}\r\n}\r\noffset = pspi_data->maxSyncOffset;\r\nif (target->raidVolume == 1)\r\nnoQas = 0;\r\n} else {\r\nfactor = MPT_ASYNC;\r\noffset = 0;\r\n}\r\n}\r\nif (!sdev->tagged_supported)\r\ntarget->tflags &= ~MPT_TARGET_FLAGS_Q_YES;\r\nif (pspi_data->nvram && (pspi_data->nvram[id] != MPT_HOST_NVRAM_INVALID)) {\r\nnvram = pspi_data->nvram[id];\r\nnfactor = (nvram & MPT_NVRAM_SYNC_MASK) >> 8;\r\nif (width)\r\nwidth = nvram & MPT_NVRAM_WIDE_DISABLE ? 0 : 1;\r\nif (offset > 0) {\r\nif (nfactor) {\r\nif (nfactor < pspi_data->minSyncFactor )\r\nnfactor = pspi_data->minSyncFactor;\r\nfactor = max(factor, nfactor);\r\nif (factor == MPT_ASYNC)\r\noffset = 0;\r\n} else {\r\noffset = 0;\r\nfactor = MPT_ASYNC;\r\n}\r\n} else {\r\nfactor = MPT_ASYNC;\r\n}\r\n}\r\nif ((!width) && (factor < MPT_ULTRA2))\r\nfactor = MPT_ULTRA2;\r\ntarget->minSyncFactor = factor;\r\ntarget->maxOffset = offset;\r\ntarget->maxWidth = width;\r\nspi_min_period(scsi_target(sdev)) = factor;\r\nspi_max_offset(scsi_target(sdev)) = offset;\r\nspi_max_width(scsi_target(sdev)) = width;\r\ntarget->tflags |= MPT_TARGET_FLAGS_VALID_NEGO;\r\nif (!width)\r\ntarget->negoFlags |= MPT_TARGET_NO_NEGO_WIDE;\r\nif (!offset)\r\ntarget->negoFlags |= MPT_TARGET_NO_NEGO_SYNC;\r\nif ( factor > MPT_ULTRA320 )\r\nnoQas = 0;\r\nif (noQas && (pspi_data->noQas == 0)) {\r\npspi_data->noQas |= MPT_TARGET_NO_NEGO_QAS;\r\ntarget->negoFlags |= MPT_TARGET_NO_NEGO_QAS;\r\nddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Disabling QAS due to noQas=%02x on id=%d!\n", ioc->name, noQas, id));\r\n}\r\n}\r\nstatic int\r\nmptspi_writeIOCPage4(MPT_SCSI_HOST *hd, u8 channel , u8 id)\r\n{\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nConfig_t *pReq;\r\nIOCPage4_t *IOCPage4Ptr;\r\nMPT_FRAME_HDR *mf;\r\ndma_addr_t dataDma;\r\nu16 req_idx;\r\nu32 frameOffset;\r\nu32 flagsLength;\r\nint ii;\r\nif ((mf = mpt_get_msg_frame(ioc->DoneCtx, ioc)) == NULL) {\r\ndfailprintk(ioc, printk(MYIOC_s_WARN_FMT\r\n"writeIOCPage4 : no msg frames!\n",ioc->name));\r\nreturn -EAGAIN;\r\n}\r\npReq = (Config_t *)mf;\r\nreq_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);\r\nframeOffset = ioc->req_sz - sizeof(IOCPage4_t);\r\npReq->Action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;\r\npReq->Reserved = 0;\r\npReq->ChainOffset = 0;\r\npReq->Function = MPI_FUNCTION_CONFIG;\r\npReq->ExtPageLength = 0;\r\npReq->ExtPageType = 0;\r\npReq->MsgFlags = 0;\r\nfor (ii=0; ii < 8; ii++) {\r\npReq->Reserved2[ii] = 0;\r\n}\r\nIOCPage4Ptr = ioc->spi_data.pIocPg4;\r\ndataDma = ioc->spi_data.IocPg4_dma;\r\nii = IOCPage4Ptr->ActiveSEP++;\r\nIOCPage4Ptr->SEP[ii].SEPTargetID = id;\r\nIOCPage4Ptr->SEP[ii].SEPBus = channel;\r\npReq->Header = IOCPage4Ptr->Header;\r\npReq->PageAddress = cpu_to_le32(id | (channel << 8 ));\r\nflagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE |\r\n(IOCPage4Ptr->Header.PageLength + ii) * 4;\r\nioc->add_sge((char *)&pReq->PageBufferSGE, flagsLength, dataDma);\r\nddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"writeIOCPage4: MaxSEP=%d ActiveSEP=%d id=%d bus=%d\n",\r\nioc->name, IOCPage4Ptr->MaxSEP, IOCPage4Ptr->ActiveSEP, id, channel));\r\nmpt_put_msg_frame(ioc->DoneCtx, ioc, mf);\r\nreturn 0;\r\n}\r\nstatic void\r\nmptspi_initTarget(MPT_SCSI_HOST *hd, VirtTarget *vtarget,\r\nstruct scsi_device *sdev)\r\n{\r\nif (sdev->inq_periph_qual != 0)\r\nreturn;\r\nif (vtarget == NULL)\r\nreturn;\r\nvtarget->type = sdev->type;\r\nif ((sdev->type == TYPE_PROCESSOR) && (hd->ioc->spi_data.Saf_Te)) {\r\nvtarget->tflags |= MPT_TARGET_FLAGS_SAF_TE_ISSUED;\r\nmptspi_writeIOCPage4(hd, vtarget->channel, vtarget->id);\r\n}else if ((sdev->type == TYPE_PROCESSOR) &&\r\n!(vtarget->tflags & MPT_TARGET_FLAGS_SAF_TE_ISSUED )) {\r\nif (sdev->inquiry_len > 49 ) {\r\nif (sdev->inquiry[44] == 'S' &&\r\nsdev->inquiry[45] == 'A' &&\r\nsdev->inquiry[46] == 'F' &&\r\nsdev->inquiry[47] == '-' &&\r\nsdev->inquiry[48] == 'T' &&\r\nsdev->inquiry[49] == 'E' ) {\r\nvtarget->tflags |= MPT_TARGET_FLAGS_SAF_TE_ISSUED;\r\nmptspi_writeIOCPage4(hd, vtarget->channel, vtarget->id);\r\n}\r\n}\r\n}\r\nmptspi_setTargetNegoParms(hd, vtarget, sdev);\r\n}\r\nstatic int\r\nmptspi_is_raid(struct _MPT_SCSI_HOST *hd, u32 id)\r\n{\r\nint i, rc = 0;\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nif (!ioc->raid_data.pIocPg2)\r\ngoto out;\r\nif (!ioc->raid_data.pIocPg2->NumActiveVolumes)\r\ngoto out;\r\nfor (i=0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++) {\r\nif (ioc->raid_data.pIocPg2->RaidVolume[i].VolumeID == id) {\r\nrc = 1;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int mptspi_target_alloc(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\r\nstruct _MPT_SCSI_HOST *hd = shost_priv(shost);\r\nVirtTarget *vtarget;\r\nMPT_ADAPTER *ioc;\r\nif (hd == NULL)\r\nreturn -ENODEV;\r\nioc = hd->ioc;\r\nvtarget = kzalloc(sizeof(VirtTarget), GFP_KERNEL);\r\nif (!vtarget)\r\nreturn -ENOMEM;\r\nvtarget->ioc_id = ioc->id;\r\nvtarget->tflags = MPT_TARGET_FLAGS_Q_YES;\r\nvtarget->id = (u8)starget->id;\r\nvtarget->channel = (u8)starget->channel;\r\nvtarget->starget = starget;\r\nstarget->hostdata = vtarget;\r\nif (starget->channel == 1) {\r\nif (mptscsih_is_phys_disk(ioc, 0, starget->id) == 0)\r\nreturn 0;\r\nvtarget->tflags |= MPT_TARGET_FLAGS_RAID_COMPONENT;\r\nvtarget->channel = 0;\r\nvtarget->id = mptscsih_raid_id_to_num(ioc, 0,\r\nstarget->id);\r\n}\r\nif (starget->channel == 0 &&\r\nmptspi_is_raid(hd, starget->id)) {\r\nvtarget->raidVolume = 1;\r\nddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"RAID Volume @ channel=%d id=%d\n", ioc->name, starget->channel,\r\nstarget->id));\r\n}\r\nif (ioc->spi_data.nvram &&\r\nioc->spi_data.nvram[starget->id] != MPT_HOST_NVRAM_INVALID) {\r\nu32 nvram = ioc->spi_data.nvram[starget->id];\r\nspi_min_period(starget) = (nvram & MPT_NVRAM_SYNC_MASK) >> MPT_NVRAM_SYNC_SHIFT;\r\nspi_max_width(starget) = nvram & MPT_NVRAM_WIDE_DISABLE ? 0 : 1;\r\n} else {\r\nspi_min_period(starget) = ioc->spi_data.minSyncFactor;\r\nspi_max_width(starget) = ioc->spi_data.maxBusWidth;\r\n}\r\nspi_max_offset(starget) = ioc->spi_data.maxSyncOffset;\r\nspi_offset(starget) = 0;\r\nspi_period(starget) = 0xFF;\r\nmptspi_write_width(starget, 0);\r\nreturn 0;\r\n}\r\nstatic void\r\nmptspi_target_destroy(struct scsi_target *starget)\r\n{\r\nkfree(starget->hostdata);\r\nstarget->hostdata = NULL;\r\n}\r\nstatic void\r\nmptspi_print_write_nego(struct _MPT_SCSI_HOST *hd, struct scsi_target *starget, u32 ii)\r\n{\r\nddvprintk(hd->ioc, printk(MYIOC_s_DEBUG_FMT "id=%d Requested = 0x%08x"\r\n" ( %s factor = 0x%02x @ offset = 0x%02x %s%s%s%s%s%s%s%s)\n",\r\nhd->ioc->name, starget->id, ii,\r\nii & MPI_SCSIDEVPAGE0_NP_WIDE ? "Wide ": "",\r\n((ii >> 8) & 0xFF), ((ii >> 16) & 0xFF),\r\nii & MPI_SCSIDEVPAGE0_NP_IU ? "IU ": "",\r\nii & MPI_SCSIDEVPAGE0_NP_DT ? "DT ": "",\r\nii & MPI_SCSIDEVPAGE0_NP_QAS ? "QAS ": "",\r\nii & MPI_SCSIDEVPAGE0_NP_HOLD_MCS ? "HOLDMCS ": "",\r\nii & MPI_SCSIDEVPAGE0_NP_WR_FLOW ? "WRFLOW ": "",\r\nii & MPI_SCSIDEVPAGE0_NP_RD_STRM ? "RDSTRM ": "",\r\nii & MPI_SCSIDEVPAGE0_NP_RTI ? "RTI ": "",\r\nii & MPI_SCSIDEVPAGE0_NP_PCOMP_EN ? "PCOMP ": ""));\r\n}\r\nstatic void\r\nmptspi_print_read_nego(struct _MPT_SCSI_HOST *hd, struct scsi_target *starget, u32 ii)\r\n{\r\nddvprintk(hd->ioc, printk(MYIOC_s_DEBUG_FMT "id=%d Read = 0x%08x"\r\n" ( %s factor = 0x%02x @ offset = 0x%02x %s%s%s%s%s%s%s%s)\n",\r\nhd->ioc->name, starget->id, ii,\r\nii & MPI_SCSIDEVPAGE0_NP_WIDE ? "Wide ": "",\r\n((ii >> 8) & 0xFF), ((ii >> 16) & 0xFF),\r\nii & MPI_SCSIDEVPAGE0_NP_IU ? "IU ": "",\r\nii & MPI_SCSIDEVPAGE0_NP_DT ? "DT ": "",\r\nii & MPI_SCSIDEVPAGE0_NP_QAS ? "QAS ": "",\r\nii & MPI_SCSIDEVPAGE0_NP_HOLD_MCS ? "HOLDMCS ": "",\r\nii & MPI_SCSIDEVPAGE0_NP_WR_FLOW ? "WRFLOW ": "",\r\nii & MPI_SCSIDEVPAGE0_NP_RD_STRM ? "RDSTRM ": "",\r\nii & MPI_SCSIDEVPAGE0_NP_RTI ? "RTI ": "",\r\nii & MPI_SCSIDEVPAGE0_NP_PCOMP_EN ? "PCOMP ": ""));\r\n}\r\nstatic int mptspi_read_spi_device_pg0(struct scsi_target *starget,\r\nstruct _CONFIG_PAGE_SCSI_DEVICE_0 *pass_pg0)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\r\nstruct _MPT_SCSI_HOST *hd = shost_priv(shost);\r\nstruct _MPT_ADAPTER *ioc = hd->ioc;\r\nstruct _CONFIG_PAGE_SCSI_DEVICE_0 *spi_dev_pg0;\r\ndma_addr_t spi_dev_pg0_dma;\r\nint size;\r\nstruct _x_config_parms cfg;\r\nstruct _CONFIG_PAGE_HEADER hdr;\r\nint err = -EBUSY;\r\nif (starget->channel == 0 &&\r\nmptspi_is_raid(hd, starget->id))\r\nreturn -1;\r\nsize = ioc->spi_data.sdp0length * 4;\r\nspi_dev_pg0 = dma_alloc_coherent(&ioc->pcidev->dev, size, &spi_dev_pg0_dma, GFP_KERNEL);\r\nif (spi_dev_pg0 == NULL) {\r\nstarget_printk(KERN_ERR, starget, MYIOC_s_FMT\r\n"dma_alloc_coherent for parameters failed\n", ioc->name);\r\nreturn -EINVAL;\r\n}\r\nmemset(&hdr, 0, sizeof(hdr));\r\nhdr.PageVersion = ioc->spi_data.sdp0version;\r\nhdr.PageLength = ioc->spi_data.sdp0length;\r\nhdr.PageNumber = 0;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.physAddr = spi_dev_pg0_dma;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\ncfg.dir = 0;\r\ncfg.pageAddr = starget->id;\r\ncfg.timeout = 60;\r\nif (mpt_config(ioc, &cfg)) {\r\nstarget_printk(KERN_ERR, starget, MYIOC_s_FMT "mpt_config failed\n", ioc->name);\r\ngoto out_free;\r\n}\r\nerr = 0;\r\nmemcpy(pass_pg0, spi_dev_pg0, size);\r\nmptspi_print_read_nego(hd, starget, le32_to_cpu(spi_dev_pg0->NegotiatedParameters));\r\nout_free:\r\ndma_free_coherent(&ioc->pcidev->dev, size, spi_dev_pg0, spi_dev_pg0_dma);\r\nreturn err;\r\n}\r\nstatic u32 mptspi_getRP(struct scsi_target *starget)\r\n{\r\nu32 nego = 0;\r\nnego |= spi_iu(starget) ? MPI_SCSIDEVPAGE1_RP_IU : 0;\r\nnego |= spi_dt(starget) ? MPI_SCSIDEVPAGE1_RP_DT : 0;\r\nnego |= spi_qas(starget) ? MPI_SCSIDEVPAGE1_RP_QAS : 0;\r\nnego |= spi_hold_mcs(starget) ? MPI_SCSIDEVPAGE1_RP_HOLD_MCS : 0;\r\nnego |= spi_wr_flow(starget) ? MPI_SCSIDEVPAGE1_RP_WR_FLOW : 0;\r\nnego |= spi_rd_strm(starget) ? MPI_SCSIDEVPAGE1_RP_RD_STRM : 0;\r\nnego |= spi_rti(starget) ? MPI_SCSIDEVPAGE1_RP_RTI : 0;\r\nnego |= spi_pcomp_en(starget) ? MPI_SCSIDEVPAGE1_RP_PCOMP_EN : 0;\r\nnego |= (spi_period(starget) << MPI_SCSIDEVPAGE1_RP_SHIFT_MIN_SYNC_PERIOD) & MPI_SCSIDEVPAGE1_RP_MIN_SYNC_PERIOD_MASK;\r\nnego |= (spi_offset(starget) << MPI_SCSIDEVPAGE1_RP_SHIFT_MAX_SYNC_OFFSET) & MPI_SCSIDEVPAGE1_RP_MAX_SYNC_OFFSET_MASK;\r\nnego |= spi_width(starget) ? MPI_SCSIDEVPAGE1_RP_WIDE : 0;\r\nreturn nego;\r\n}\r\nstatic void mptspi_read_parameters(struct scsi_target *starget)\r\n{\r\nint nego;\r\nstruct _CONFIG_PAGE_SCSI_DEVICE_0 spi_dev_pg0;\r\nmptspi_read_spi_device_pg0(starget, &spi_dev_pg0);\r\nnego = le32_to_cpu(spi_dev_pg0.NegotiatedParameters);\r\nspi_iu(starget) = (nego & MPI_SCSIDEVPAGE0_NP_IU) ? 1 : 0;\r\nspi_dt(starget) = (nego & MPI_SCSIDEVPAGE0_NP_DT) ? 1 : 0;\r\nspi_qas(starget) = (nego & MPI_SCSIDEVPAGE0_NP_QAS) ? 1 : 0;\r\nspi_wr_flow(starget) = (nego & MPI_SCSIDEVPAGE0_NP_WR_FLOW) ? 1 : 0;\r\nspi_rd_strm(starget) = (nego & MPI_SCSIDEVPAGE0_NP_RD_STRM) ? 1 : 0;\r\nspi_rti(starget) = (nego & MPI_SCSIDEVPAGE0_NP_RTI) ? 1 : 0;\r\nspi_pcomp_en(starget) = (nego & MPI_SCSIDEVPAGE0_NP_PCOMP_EN) ? 1 : 0;\r\nspi_hold_mcs(starget) = (nego & MPI_SCSIDEVPAGE0_NP_HOLD_MCS) ? 1 : 0;\r\nspi_period(starget) = (nego & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_PERIOD_MASK) >> MPI_SCSIDEVPAGE0_NP_SHIFT_SYNC_PERIOD;\r\nspi_offset(starget) = (nego & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_OFFSET_MASK) >> MPI_SCSIDEVPAGE0_NP_SHIFT_SYNC_OFFSET;\r\nspi_width(starget) = (nego & MPI_SCSIDEVPAGE0_NP_WIDE) ? 1 : 0;\r\n}\r\nstatic int\r\nmptscsih_quiesce_raid(MPT_SCSI_HOST *hd, int quiesce, u8 channel, u8 id)\r\n{\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nMpiRaidActionRequest_t *pReq;\r\nMPT_FRAME_HDR *mf;\r\nint ret;\r\nunsigned long timeleft;\r\nmutex_lock(&ioc->internal_cmds.mutex);\r\nif ((mf = mpt_get_msg_frame(ioc->InternalCtx, ioc)) == NULL) {\r\ndfailprintk(hd->ioc, printk(MYIOC_s_WARN_FMT\r\n"%s: no msg frames!\n", ioc->name, __func__));\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\npReq = (MpiRaidActionRequest_t *)mf;\r\nif (quiesce)\r\npReq->Action = MPI_RAID_ACTION_QUIESCE_PHYS_IO;\r\nelse\r\npReq->Action = MPI_RAID_ACTION_ENABLE_PHYS_IO;\r\npReq->Reserved1 = 0;\r\npReq->ChainOffset = 0;\r\npReq->Function = MPI_FUNCTION_RAID_ACTION;\r\npReq->VolumeID = id;\r\npReq->VolumeBus = channel;\r\npReq->PhysDiskNum = 0;\r\npReq->MsgFlags = 0;\r\npReq->Reserved2 = 0;\r\npReq->ActionDataWord = 0;\r\nioc->add_sge((char *)&pReq->ActionDataSGE,\r\nMPT_SGE_FLAGS_SSIMPLE_READ | 0, (dma_addr_t) -1);\r\nddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT "RAID Volume action=%x channel=%d id=%d\n",\r\nioc->name, pReq->Action, channel, id));\r\nINITIALIZE_MGMT_STATUS(ioc->internal_cmds.status)\r\nmpt_put_msg_frame(ioc->InternalCtx, ioc, mf);\r\ntimeleft = wait_for_completion_timeout(&ioc->internal_cmds.done, 10*HZ);\r\nif (!(ioc->internal_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\r\nret = -ETIME;\r\ndfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: TIMED OUT!\n",\r\nioc->name, __func__));\r\nif (ioc->internal_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)\r\ngoto out;\r\nif (!timeleft) {\r\nprintk(MYIOC_s_WARN_FMT "Issuing Reset from %s!!\n",\r\nioc->name, __func__);\r\nmpt_HardResetHandler(ioc, CAN_SLEEP);\r\nmpt_free_msg_frame(ioc, mf);\r\n}\r\ngoto out;\r\n}\r\nret = ioc->internal_cmds.completion_code;\r\nout:\r\nCLEAR_MGMT_STATUS(ioc->internal_cmds.status)\r\nmutex_unlock(&ioc->internal_cmds.mutex);\r\nreturn ret;\r\n}\r\nstatic void mptspi_dv_device(struct _MPT_SCSI_HOST *hd,\r\nstruct scsi_device *sdev)\r\n{\r\nVirtTarget *vtarget = scsi_target(sdev)->hostdata;\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nif (sdev->channel == 0 &&\r\nmptspi_is_raid(hd, sdev->id))\r\nreturn;\r\nif (sdev->channel == 1 &&\r\nmptscsih_quiesce_raid(hd, 1, vtarget->channel, vtarget->id) < 0) {\r\nstarget_printk(KERN_ERR, scsi_target(sdev), MYIOC_s_FMT\r\n"Integrated RAID quiesce failed\n", ioc->name);\r\nreturn;\r\n}\r\nhd->spi_pending |= (1 << sdev->id);\r\nspi_dv_device(sdev);\r\nhd->spi_pending &= ~(1 << sdev->id);\r\nif (sdev->channel == 1 &&\r\nmptscsih_quiesce_raid(hd, 0, vtarget->channel, vtarget->id) < 0)\r\nstarget_printk(KERN_ERR, scsi_target(sdev), MYIOC_s_FMT\r\n"Integrated RAID resume failed\n", ioc->name);\r\nmptspi_read_parameters(sdev->sdev_target);\r\nspi_display_xfer_agreement(sdev->sdev_target);\r\nmptspi_read_parameters(sdev->sdev_target);\r\n}\r\nstatic int mptspi_slave_alloc(struct scsi_device *sdev)\r\n{\r\nMPT_SCSI_HOST *hd = shost_priv(sdev->host);\r\nVirtTarget *vtarget;\r\nVirtDevice *vdevice;\r\nstruct scsi_target *starget;\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nif (sdev->channel == 1 &&\r\nmptscsih_is_phys_disk(ioc, 0, sdev->id) == 0)\r\nreturn -ENXIO;\r\nvdevice = kzalloc(sizeof(VirtDevice), GFP_KERNEL);\r\nif (!vdevice) {\r\nprintk(MYIOC_s_ERR_FMT "slave_alloc kmalloc(%zd) FAILED!\n",\r\nioc->name, sizeof(VirtDevice));\r\nreturn -ENOMEM;\r\n}\r\nvdevice->lun = sdev->lun;\r\nsdev->hostdata = vdevice;\r\nstarget = scsi_target(sdev);\r\nvtarget = starget->hostdata;\r\nvdevice->vtarget = vtarget;\r\nvtarget->num_luns++;\r\nif (sdev->channel == 1)\r\nsdev->no_uld_attach = 1;\r\nreturn 0;\r\n}\r\nstatic int mptspi_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct _MPT_SCSI_HOST *hd = shost_priv(sdev->host);\r\nVirtTarget *vtarget = scsi_target(sdev)->hostdata;\r\nint ret;\r\nmptspi_initTarget(hd, vtarget, sdev);\r\nret = mptscsih_slave_configure(sdev);\r\nif (ret)\r\nreturn ret;\r\nddvprintk(hd->ioc, printk(MYIOC_s_DEBUG_FMT "id=%d min_period=0x%02x"\r\n" max_offset=0x%02x max_width=%d\n", hd->ioc->name,\r\nsdev->id, spi_min_period(scsi_target(sdev)),\r\nspi_max_offset(scsi_target(sdev)),\r\nspi_max_width(scsi_target(sdev))));\r\nif ((sdev->channel == 1 ||\r\n!(mptspi_is_raid(hd, sdev->id))) &&\r\n!spi_initial_dv(sdev->sdev_target))\r\nmptspi_dv_device(hd, sdev);\r\nreturn 0;\r\n}\r\nstatic int\r\nmptspi_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *SCpnt)\r\n{\r\nstruct _MPT_SCSI_HOST *hd = shost_priv(shost);\r\nVirtDevice *vdevice = SCpnt->device->hostdata;\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nif (!vdevice || !vdevice->vtarget) {\r\nSCpnt->result = DID_NO_CONNECT << 16;\r\nSCpnt->scsi_done(SCpnt);\r\nreturn 0;\r\n}\r\nif (SCpnt->device->channel == 1 &&\r\nmptscsih_is_phys_disk(ioc, 0, SCpnt->device->id) == 0) {\r\nSCpnt->result = DID_NO_CONNECT << 16;\r\nSCpnt->scsi_done(SCpnt);\r\nreturn 0;\r\n}\r\nif (spi_dv_pending(scsi_target(SCpnt->device)))\r\nddvprintk(ioc, scsi_print_command(SCpnt));\r\nreturn mptscsih_qcmd(SCpnt);\r\n}\r\nstatic void mptspi_slave_destroy(struct scsi_device *sdev)\r\n{\r\nstruct scsi_target *starget = scsi_target(sdev);\r\nVirtTarget *vtarget = starget->hostdata;\r\nVirtDevice *vdevice = sdev->hostdata;\r\nif (vtarget->num_luns == 1 && vdevice->configured_lun) {\r\nstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\r\npg1.RequestedParameters = 0;\r\npg1.Reserved = 0;\r\npg1.Configuration = 0;\r\nmptspi_write_spi_device_pg1(starget, &pg1);\r\n}\r\nmptscsih_slave_destroy(sdev);\r\n}\r\nstatic int mptspi_write_spi_device_pg1(struct scsi_target *starget,\r\nstruct _CONFIG_PAGE_SCSI_DEVICE_1 *pass_pg1)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\r\nstruct _MPT_SCSI_HOST *hd = shost_priv(shost);\r\nstruct _MPT_ADAPTER *ioc = hd->ioc;\r\nstruct _CONFIG_PAGE_SCSI_DEVICE_1 *pg1;\r\ndma_addr_t pg1_dma;\r\nint size;\r\nstruct _x_config_parms cfg;\r\nstruct _CONFIG_PAGE_HEADER hdr;\r\nint err = -EBUSY;\r\nu32 nego_parms;\r\nu32 period;\r\nstruct scsi_device *sdev;\r\nint i;\r\nif (starget->channel == 0 &&\r\nmptspi_is_raid(hd, starget->id))\r\nreturn -1;\r\nsize = ioc->spi_data.sdp1length * 4;\r\npg1 = dma_alloc_coherent(&ioc->pcidev->dev, size, &pg1_dma, GFP_KERNEL);\r\nif (pg1 == NULL) {\r\nstarget_printk(KERN_ERR, starget, MYIOC_s_FMT\r\n"dma_alloc_coherent for parameters failed\n", ioc->name);\r\nreturn -EINVAL;\r\n}\r\nmemset(&hdr, 0, sizeof(hdr));\r\nhdr.PageVersion = ioc->spi_data.sdp1version;\r\nhdr.PageLength = ioc->spi_data.sdp1length;\r\nhdr.PageNumber = 1;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.physAddr = pg1_dma;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;\r\ncfg.dir = 1;\r\ncfg.pageAddr = starget->id;\r\nmemcpy(pg1, pass_pg1, size);\r\npg1->Header.PageVersion = hdr.PageVersion;\r\npg1->Header.PageLength = hdr.PageLength;\r\npg1->Header.PageNumber = hdr.PageNumber;\r\npg1->Header.PageType = hdr.PageType;\r\nnego_parms = le32_to_cpu(pg1->RequestedParameters);\r\nperiod = (nego_parms & MPI_SCSIDEVPAGE1_RP_MIN_SYNC_PERIOD_MASK) >>\r\nMPI_SCSIDEVPAGE1_RP_SHIFT_MIN_SYNC_PERIOD;\r\nif (period == 8) {\r\nfor (i = 0 ; i < 16; i++) {\r\nsdev = scsi_device_lookup_by_target(starget, i);\r\nif (sdev && sdev->type == TYPE_TAPE) {\r\nsdev_printk(KERN_DEBUG, sdev, MYIOC_s_FMT\r\n"IDP:ON\n", ioc->name);\r\nnego_parms |= MPI_SCSIDEVPAGE1_RP_IDP;\r\npg1->RequestedParameters =\r\ncpu_to_le32(nego_parms);\r\nbreak;\r\n}\r\n}\r\n}\r\nmptspi_print_write_nego(hd, starget, le32_to_cpu(pg1->RequestedParameters));\r\nif (mpt_config(ioc, &cfg)) {\r\nstarget_printk(KERN_ERR, starget, MYIOC_s_FMT\r\n"mpt_config failed\n", ioc->name);\r\ngoto out_free;\r\n}\r\nerr = 0;\r\nout_free:\r\ndma_free_coherent(&ioc->pcidev->dev, size, pg1, pg1_dma);\r\nreturn err;\r\n}\r\nstatic void mptspi_write_offset(struct scsi_target *starget, int offset)\r\n{\r\nstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\r\nu32 nego;\r\nif (offset < 0)\r\noffset = 0;\r\nif (offset > 255)\r\noffset = 255;\r\nif (spi_offset(starget) == -1)\r\nmptspi_read_parameters(starget);\r\nspi_offset(starget) = offset;\r\nnego = mptspi_getRP(starget);\r\npg1.RequestedParameters = cpu_to_le32(nego);\r\npg1.Reserved = 0;\r\npg1.Configuration = 0;\r\nmptspi_write_spi_device_pg1(starget, &pg1);\r\n}\r\nstatic void mptspi_write_period(struct scsi_target *starget, int period)\r\n{\r\nstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\r\nu32 nego;\r\nif (period < 8)\r\nperiod = 8;\r\nif (period > 255)\r\nperiod = 255;\r\nif (spi_period(starget) == -1)\r\nmptspi_read_parameters(starget);\r\nif (period == 8) {\r\nspi_iu(starget) = 1;\r\nspi_dt(starget) = 1;\r\n} else if (period == 9) {\r\nspi_dt(starget) = 1;\r\n}\r\nspi_period(starget) = period;\r\nnego = mptspi_getRP(starget);\r\npg1.RequestedParameters = cpu_to_le32(nego);\r\npg1.Reserved = 0;\r\npg1.Configuration = 0;\r\nmptspi_write_spi_device_pg1(starget, &pg1);\r\n}\r\nstatic void mptspi_write_dt(struct scsi_target *starget, int dt)\r\n{\r\nstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\r\nu32 nego;\r\nif (spi_period(starget) == -1)\r\nmptspi_read_parameters(starget);\r\nif (!dt && spi_period(starget) < 10)\r\nspi_period(starget) = 10;\r\nspi_dt(starget) = dt;\r\nnego = mptspi_getRP(starget);\r\npg1.RequestedParameters = cpu_to_le32(nego);\r\npg1.Reserved = 0;\r\npg1.Configuration = 0;\r\nmptspi_write_spi_device_pg1(starget, &pg1);\r\n}\r\nstatic void mptspi_write_iu(struct scsi_target *starget, int iu)\r\n{\r\nstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\r\nu32 nego;\r\nif (spi_period(starget) == -1)\r\nmptspi_read_parameters(starget);\r\nif (!iu && spi_period(starget) < 9)\r\nspi_period(starget) = 9;\r\nspi_iu(starget) = iu;\r\nnego = mptspi_getRP(starget);\r\npg1.RequestedParameters = cpu_to_le32(nego);\r\npg1.Reserved = 0;\r\npg1.Configuration = 0;\r\nmptspi_write_spi_device_pg1(starget, &pg1);\r\n}\r\nstatic void mptspi_write_qas(struct scsi_target *starget, int qas)\r\n{\r\nstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\r\nstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\r\nstruct _MPT_SCSI_HOST *hd = shost_priv(shost);\r\nVirtTarget *vtarget = starget->hostdata;\r\nu32 nego;\r\nif ((vtarget->negoFlags & MPT_TARGET_NO_NEGO_QAS) ||\r\nhd->ioc->spi_data.noQas)\r\nspi_qas(starget) = 0;\r\nelse\r\nspi_qas(starget) = qas;\r\nnego = mptspi_getRP(starget);\r\npg1.RequestedParameters = cpu_to_le32(nego);\r\npg1.Reserved = 0;\r\npg1.Configuration = 0;\r\nmptspi_write_spi_device_pg1(starget, &pg1);\r\n}\r\nstatic void mptspi_write_width(struct scsi_target *starget, int width)\r\n{\r\nstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\r\nu32 nego;\r\nif (!width) {\r\nspi_dt(starget) = 0;\r\nif (spi_period(starget) < 10)\r\nspi_period(starget) = 10;\r\n}\r\nspi_width(starget) = width;\r\nnego = mptspi_getRP(starget);\r\npg1.RequestedParameters = cpu_to_le32(nego);\r\npg1.Reserved = 0;\r\npg1.Configuration = 0;\r\nmptspi_write_spi_device_pg1(starget, &pg1);\r\n}\r\nstatic void mpt_work_wrapper(struct work_struct *work)\r\n{\r\nstruct work_queue_wrapper *wqw =\r\ncontainer_of(work, struct work_queue_wrapper, work);\r\nstruct _MPT_SCSI_HOST *hd = wqw->hd;\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nstruct Scsi_Host *shost = ioc->sh;\r\nstruct scsi_device *sdev;\r\nint disk = wqw->disk;\r\nstruct _CONFIG_PAGE_IOC_3 *pg3;\r\nkfree(wqw);\r\nmpt_findImVolumes(ioc);\r\npg3 = ioc->raid_data.pIocPg3;\r\nif (!pg3)\r\nreturn;\r\nshost_for_each_device(sdev,shost) {\r\nstruct scsi_target *starget = scsi_target(sdev);\r\nVirtTarget *vtarget = starget->hostdata;\r\nif (sdev->channel != 1)\r\ncontinue;\r\nif(vtarget->id != disk)\r\ncontinue;\r\nstarget_printk(KERN_INFO, vtarget->starget, MYIOC_s_FMT\r\n"Integrated RAID requests DV of new device\n", ioc->name);\r\nmptspi_dv_device(hd, sdev);\r\n}\r\nshost_printk(KERN_INFO, shost, MYIOC_s_FMT\r\n"Integrated RAID detects new device %d\n", ioc->name, disk);\r\nscsi_scan_target(&ioc->sh->shost_gendev, 1, disk, 0, SCSI_SCAN_RESCAN);\r\n}\r\nstatic void mpt_dv_raid(struct _MPT_SCSI_HOST *hd, int disk)\r\n{\r\nstruct work_queue_wrapper *wqw = kmalloc(sizeof(*wqw), GFP_ATOMIC);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nif (!wqw) {\r\nshost_printk(KERN_ERR, ioc->sh, MYIOC_s_FMT\r\n"Failed to act on RAID event for physical disk %d\n",\r\nioc->name, disk);\r\nreturn;\r\n}\r\nINIT_WORK(&wqw->work, mpt_work_wrapper);\r\nwqw->hd = hd;\r\nwqw->disk = disk;\r\nschedule_work(&wqw->work);\r\n}\r\nstatic int\r\nmptspi_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)\r\n{\r\nu8 event = le32_to_cpu(pEvReply->Event) & 0xFF;\r\nstruct _MPT_SCSI_HOST *hd = shost_priv(ioc->sh);\r\nif (ioc->bus_type != SPI)\r\nreturn 0;\r\nif (hd && event == MPI_EVENT_INTEGRATED_RAID) {\r\nint reason\r\n= (le32_to_cpu(pEvReply->Data[0]) & 0x00FF0000) >> 16;\r\nif (reason == MPI_EVENT_RAID_RC_DOMAIN_VAL_NEEDED) {\r\nint disk = (le32_to_cpu(pEvReply->Data[0]) & 0xFF000000) >> 24;\r\nmpt_dv_raid(hd, disk);\r\n}\r\n}\r\nreturn mptscsih_event_process(ioc, pEvReply);\r\n}\r\nstatic int\r\nmptspi_deny_binding(struct scsi_target *starget)\r\n{\r\nstruct _MPT_SCSI_HOST *hd =\r\n(struct _MPT_SCSI_HOST *)dev_to_shost(starget->dev.parent)->hostdata;\r\nreturn ((mptspi_is_raid(hd, starget->id)) &&\r\nstarget->channel == 0) ? 1 : 0;\r\n}\r\nstatic void\r\nmptspi_dv_renegotiate_work(struct work_struct *work)\r\n{\r\nstruct work_queue_wrapper *wqw =\r\ncontainer_of(work, struct work_queue_wrapper, work);\r\nstruct _MPT_SCSI_HOST *hd = wqw->hd;\r\nstruct scsi_device *sdev;\r\nstruct scsi_target *starget;\r\nstruct _CONFIG_PAGE_SCSI_DEVICE_1 pg1;\r\nu32 nego;\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nkfree(wqw);\r\nif (hd->spi_pending) {\r\nshost_for_each_device(sdev, ioc->sh) {\r\nif (hd->spi_pending & (1 << sdev->id))\r\ncontinue;\r\nstarget = scsi_target(sdev);\r\nnego = mptspi_getRP(starget);\r\npg1.RequestedParameters = cpu_to_le32(nego);\r\npg1.Reserved = 0;\r\npg1.Configuration = 0;\r\nmptspi_write_spi_device_pg1(starget, &pg1);\r\n}\r\n} else {\r\nshost_for_each_device(sdev, ioc->sh)\r\nmptspi_dv_device(hd, sdev);\r\n}\r\n}\r\nstatic void\r\nmptspi_dv_renegotiate(struct _MPT_SCSI_HOST *hd)\r\n{\r\nstruct work_queue_wrapper *wqw = kmalloc(sizeof(*wqw), GFP_ATOMIC);\r\nif (!wqw)\r\nreturn;\r\nINIT_WORK(&wqw->work, mptspi_dv_renegotiate_work);\r\nwqw->hd = hd;\r\nschedule_work(&wqw->work);\r\n}\r\nstatic int\r\nmptspi_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\r\n{\r\nint rc;\r\nrc = mptscsih_ioc_reset(ioc, reset_phase);\r\nif ((ioc->bus_type != SPI) || (!rc))\r\nreturn rc;\r\nif (reset_phase == MPT_IOC_POST_RESET &&\r\nioc->sh) {\r\nstruct _MPT_SCSI_HOST *hd = shost_priv(ioc->sh);\r\nmptspi_dv_renegotiate(hd);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nmptspi_resume(struct pci_dev *pdev)\r\n{\r\nMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\r\nstruct _MPT_SCSI_HOST *hd = shost_priv(ioc->sh);\r\nint rc;\r\nrc = mptscsih_resume(pdev);\r\nmptspi_dv_renegotiate(hd);\r\nreturn rc;\r\n}\r\nstatic int\r\nmptspi_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct Scsi_Host *sh;\r\nMPT_SCSI_HOST *hd;\r\nMPT_ADAPTER *ioc;\r\nunsigned long flags;\r\nint ii;\r\nint numSGE = 0;\r\nint scale;\r\nint ioc_cap;\r\nint error=0;\r\nint r;\r\nif ((r = mpt_attach(pdev,id)) != 0)\r\nreturn r;\r\nioc = pci_get_drvdata(pdev);\r\nioc->DoneCtx = mptspiDoneCtx;\r\nioc->TaskCtx = mptspiTaskCtx;\r\nioc->InternalCtx = mptspiInternalCtx;\r\nif (ioc->last_state != MPI_IOC_STATE_OPERATIONAL) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"Skipping because it's not operational!\n",\r\nioc->name);\r\nerror = -ENODEV;\r\ngoto out_mptspi_probe;\r\n}\r\nif (!ioc->active) {\r\nprintk(MYIOC_s_WARN_FMT "Skipping because it's disabled!\n",\r\nioc->name);\r\nerror = -ENODEV;\r\ngoto out_mptspi_probe;\r\n}\r\nioc_cap = 0;\r\nfor (ii=0; ii < ioc->facts.NumberOfPorts; ii++) {\r\nif (ioc->pfacts[ii].ProtocolFlags &\r\nMPI_PORTFACTS_PROTOCOL_INITIATOR)\r\nioc_cap ++;\r\n}\r\nif (!ioc_cap) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"Skipping ioc=%p because SCSI Initiator mode is NOT enabled!\n",\r\nioc->name, ioc);\r\nreturn 0;\r\n}\r\nsh = scsi_host_alloc(&mptspi_driver_template, sizeof(MPT_SCSI_HOST));\r\nif (!sh) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"Unable to register controller with SCSI subsystem\n",\r\nioc->name);\r\nerror = -1;\r\ngoto out_mptspi_probe;\r\n}\r\nif (pdev->subsystem_vendor == 0x15AD)\r\nsh->no_write_same = 1;\r\nspin_lock_irqsave(&ioc->FreeQlock, flags);\r\nioc->sh = sh;\r\nsh->io_port = 0;\r\nsh->n_io_port = 0;\r\nsh->irq = 0;\r\nsh->max_cmd_len = 16;\r\nsh->max_id = ioc->devices_per_bus;\r\nsh->max_lun = MPT_LAST_LUN + 1;\r\nif (ioc->ir_firmware)\r\nsh->max_channel = 1;\r\nelse\r\nsh->max_channel = 0;\r\nsh->this_id = ioc->pfacts[0].PortSCSIID;\r\nsh->unique_id = ioc->id;\r\nscale = ioc->req_sz/ioc->SGE_size;\r\nif (ioc->sg_addr_size == sizeof(u64)) {\r\nnumSGE = (scale - 1) *\r\n(ioc->facts.MaxChainDepth-1) + scale +\r\n(ioc->req_sz - 60) / ioc->SGE_size;\r\n} else {\r\nnumSGE = 1 + (scale - 1) *\r\n(ioc->facts.MaxChainDepth-1) + scale +\r\n(ioc->req_sz - 64) / ioc->SGE_size;\r\n}\r\nif (numSGE < sh->sg_tablesize) {\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Resetting sg_tablesize to %d from %d\n",\r\nioc->name, numSGE, sh->sg_tablesize));\r\nsh->sg_tablesize = numSGE;\r\n}\r\nspin_unlock_irqrestore(&ioc->FreeQlock, flags);\r\nhd = shost_priv(sh);\r\nhd->ioc = ioc;\r\nioc->ScsiLookup = kcalloc(ioc->req_depth, sizeof(void *), GFP_ATOMIC);\r\nif (!ioc->ScsiLookup) {\r\nerror = -ENOMEM;\r\ngoto out_mptspi_probe;\r\n}\r\nspin_lock_init(&ioc->scsi_lookup_lock);\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ScsiLookup @ %p\n",\r\nioc->name, ioc->ScsiLookup));\r\nioc->spi_data.Saf_Te = mpt_saf_te;\r\nddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"saf_te %x\n",\r\nioc->name,\r\nmpt_saf_te));\r\nioc->spi_data.noQas = 0;\r\nhd->last_queue_full = 0;\r\nhd->spi_pending = 0;\r\nif (ioc->spi_data.sdp0length != 0)\r\nsh->transportt = mptspi_transport_template;\r\nerror = scsi_add_host (sh, &ioc->pcidev->dev);\r\nif(error) {\r\ndprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"scsi_add_host failed\n", ioc->name));\r\ngoto out_mptspi_probe;\r\n}\r\nif (ioc->spi_data.bus_reset)\r\nmptscsih_IssueTaskMgmt(hd,\r\nMPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,\r\n0, 0, 0, 0, 5);\r\nscsi_scan_host(sh);\r\nreturn 0;\r\nout_mptspi_probe:\r\nmptscsih_remove(pdev);\r\nreturn error;\r\n}\r\nstatic void mptspi_remove(struct pci_dev *pdev)\r\n{\r\nMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\r\nscsi_remove_host(ioc->sh);\r\nmptscsih_remove(pdev);\r\n}\r\nstatic int __init\r\nmptspi_init(void)\r\n{\r\nint error;\r\nshow_mptmod_ver(my_NAME, my_VERSION);\r\nmptspi_transport_template = spi_attach_transport(&mptspi_transport_functions);\r\nif (!mptspi_transport_template)\r\nreturn -ENODEV;\r\nmptspiDoneCtx = mpt_register(mptscsih_io_done, MPTSPI_DRIVER,\r\n"mptscsih_io_done");\r\nmptspiTaskCtx = mpt_register(mptscsih_taskmgmt_complete, MPTSPI_DRIVER,\r\n"mptscsih_taskmgmt_complete");\r\nmptspiInternalCtx = mpt_register(mptscsih_scandv_complete,\r\nMPTSPI_DRIVER, "mptscsih_scandv_complete");\r\nmpt_event_register(mptspiDoneCtx, mptspi_event_process);\r\nmpt_reset_register(mptspiDoneCtx, mptspi_ioc_reset);\r\nerror = pci_register_driver(&mptspi_driver);\r\nif (error)\r\nspi_release_transport(mptspi_transport_template);\r\nreturn error;\r\n}\r\nstatic void __exit\r\nmptspi_exit(void)\r\n{\r\npci_unregister_driver(&mptspi_driver);\r\nmpt_reset_deregister(mptspiDoneCtx);\r\nmpt_event_deregister(mptspiDoneCtx);\r\nmpt_deregister(mptspiInternalCtx);\r\nmpt_deregister(mptspiTaskCtx);\r\nmpt_deregister(mptspiDoneCtx);\r\nspi_release_transport(mptspi_transport_template);\r\n}
