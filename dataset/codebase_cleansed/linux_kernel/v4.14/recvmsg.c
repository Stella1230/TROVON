void rxrpc_notify_socket(struct rxrpc_call *call)\r\n{\r\nstruct rxrpc_sock *rx;\r\nstruct sock *sk;\r\n_enter("%d", call->debug_id);\r\nif (!list_empty(&call->recvmsg_link))\r\nreturn;\r\nrcu_read_lock();\r\nrx = rcu_dereference(call->socket);\r\nsk = &rx->sk;\r\nif (rx && sk->sk_state < RXRPC_CLOSE) {\r\nif (call->notify_rx) {\r\ncall->notify_rx(sk, call, call->user_call_ID);\r\n} else {\r\nwrite_lock_bh(&rx->recvmsg_lock);\r\nif (list_empty(&call->recvmsg_link)) {\r\nrxrpc_get_call(call, rxrpc_call_got);\r\nlist_add_tail(&call->recvmsg_link, &rx->recvmsg_q);\r\n}\r\nwrite_unlock_bh(&rx->recvmsg_lock);\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\n_debug("call %ps", sk->sk_data_ready);\r\nsk->sk_data_ready(sk);\r\n}\r\n}\r\n}\r\nrcu_read_unlock();\r\n_leave("");\r\n}\r\nstatic int rxrpc_recvmsg_term(struct rxrpc_call *call, struct msghdr *msg)\r\n{\r\nu32 tmp = 0;\r\nint ret;\r\nswitch (call->completion) {\r\ncase RXRPC_CALL_SUCCEEDED:\r\nret = 0;\r\nif (rxrpc_is_service_call(call))\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_ACK, 0, &tmp);\r\nbreak;\r\ncase RXRPC_CALL_REMOTELY_ABORTED:\r\ntmp = call->abort_code;\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_ABORT, 4, &tmp);\r\nbreak;\r\ncase RXRPC_CALL_LOCALLY_ABORTED:\r\ntmp = call->abort_code;\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_ABORT, 4, &tmp);\r\nbreak;\r\ncase RXRPC_CALL_NETWORK_ERROR:\r\ntmp = -call->error;\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_NET_ERROR, 4, &tmp);\r\nbreak;\r\ncase RXRPC_CALL_LOCAL_ERROR:\r\ntmp = -call->error;\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_LOCAL_ERROR, 4, &tmp);\r\nbreak;\r\ndefault:\r\npr_err("Invalid terminal call state %u\n", call->state);\r\nBUG();\r\nbreak;\r\n}\r\ntrace_rxrpc_recvmsg(call, rxrpc_recvmsg_terminal, call->rx_hard_ack,\r\ncall->rx_pkt_offset, call->rx_pkt_len, ret);\r\nreturn ret;\r\n}\r\nstatic int rxrpc_recvmsg_new_call(struct rxrpc_sock *rx,\r\nstruct rxrpc_call *call,\r\nstruct msghdr *msg, int flags)\r\n{\r\nint tmp = 0, ret;\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_NEW_CALL, 0, &tmp);\r\nif (ret == 0 && !(flags & MSG_PEEK)) {\r\n_debug("to be accepted");\r\nwrite_lock_bh(&rx->recvmsg_lock);\r\nlist_del_init(&call->recvmsg_link);\r\nwrite_unlock_bh(&rx->recvmsg_lock);\r\nrxrpc_get_call(call, rxrpc_call_got);\r\nwrite_lock(&rx->call_lock);\r\nlist_add_tail(&call->accept_link, &rx->to_be_accepted);\r\nwrite_unlock(&rx->call_lock);\r\n}\r\ntrace_rxrpc_recvmsg(call, rxrpc_recvmsg_to_be_accepted, 1, 0, 0, ret);\r\nreturn ret;\r\n}\r\nstatic void rxrpc_end_rx_phase(struct rxrpc_call *call, rxrpc_serial_t serial)\r\n{\r\n_enter("%d,%s", call->debug_id, rxrpc_call_states[call->state]);\r\ntrace_rxrpc_receive(call, rxrpc_receive_end, 0, call->rx_top);\r\nASSERTCMP(call->rx_hard_ack, ==, call->rx_top);\r\nif (call->state == RXRPC_CALL_CLIENT_RECV_REPLY) {\r\nrxrpc_propose_ACK(call, RXRPC_ACK_IDLE, 0, serial, true, false,\r\nrxrpc_propose_ack_terminal_ack);\r\nrxrpc_send_ack_packet(call, false);\r\n}\r\nwrite_lock_bh(&call->state_lock);\r\nswitch (call->state) {\r\ncase RXRPC_CALL_CLIENT_RECV_REPLY:\r\n__rxrpc_call_completed(call);\r\nwrite_unlock_bh(&call->state_lock);\r\nbreak;\r\ncase RXRPC_CALL_SERVER_RECV_REQUEST:\r\ncall->tx_phase = true;\r\ncall->state = RXRPC_CALL_SERVER_ACK_REQUEST;\r\ncall->ack_at = call->expire_at;\r\nwrite_unlock_bh(&call->state_lock);\r\nrxrpc_propose_ACK(call, RXRPC_ACK_DELAY, 0, serial, false, true,\r\nrxrpc_propose_ack_processing_op);\r\nbreak;\r\ndefault:\r\nwrite_unlock_bh(&call->state_lock);\r\nbreak;\r\n}\r\n}\r\nstatic void rxrpc_rotate_rx_window(struct rxrpc_call *call)\r\n{\r\nstruct rxrpc_skb_priv *sp;\r\nstruct sk_buff *skb;\r\nrxrpc_serial_t serial;\r\nrxrpc_seq_t hard_ack, top;\r\nu8 flags;\r\nint ix;\r\n_enter("%d", call->debug_id);\r\nhard_ack = call->rx_hard_ack;\r\ntop = smp_load_acquire(&call->rx_top);\r\nASSERT(before(hard_ack, top));\r\nhard_ack++;\r\nix = hard_ack & RXRPC_RXTX_BUFF_MASK;\r\nskb = call->rxtx_buffer[ix];\r\nrxrpc_see_skb(skb, rxrpc_skb_rx_rotated);\r\nsp = rxrpc_skb(skb);\r\nflags = sp->hdr.flags;\r\nserial = sp->hdr.serial;\r\nif (call->rxtx_annotations[ix] & RXRPC_RX_ANNO_JUMBO)\r\nserial += (call->rxtx_annotations[ix] & RXRPC_RX_ANNO_JUMBO) - 1;\r\ncall->rxtx_buffer[ix] = NULL;\r\ncall->rxtx_annotations[ix] = 0;\r\nsmp_store_release(&call->rx_hard_ack, hard_ack);\r\nrxrpc_free_skb(skb, rxrpc_skb_rx_freed);\r\n_debug("%u,%u,%02x", hard_ack, top, flags);\r\ntrace_rxrpc_receive(call, rxrpc_receive_rotate, serial, hard_ack);\r\nif (flags & RXRPC_LAST_PACKET) {\r\nrxrpc_end_rx_phase(call, serial);\r\n} else {\r\nif (after_eq(hard_ack, call->ackr_consumed + 2) ||\r\nafter_eq(top, call->ackr_seen + 2) ||\r\n(hard_ack == top && after(hard_ack, call->ackr_consumed)))\r\nrxrpc_propose_ACK(call, RXRPC_ACK_DELAY, 0, serial,\r\ntrue, false,\r\nrxrpc_propose_ack_rotate_rx);\r\nif (call->ackr_reason)\r\nrxrpc_send_ack_packet(call, false);\r\n}\r\n}\r\nstatic int rxrpc_verify_packet(struct rxrpc_call *call, struct sk_buff *skb,\r\nu8 annotation,\r\nunsigned int offset, unsigned int len)\r\n{\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\nrxrpc_seq_t seq = sp->hdr.seq;\r\nu16 cksum = sp->hdr.cksum;\r\n_enter("");\r\nif ((annotation & RXRPC_RX_ANNO_JUMBO) > 1) {\r\n__be16 tmp;\r\nif (skb_copy_bits(skb, offset - 2, &tmp, 2) < 0)\r\nBUG();\r\ncksum = ntohs(tmp);\r\nseq += (annotation & RXRPC_RX_ANNO_JUMBO) - 1;\r\n}\r\nreturn call->conn->security->verify_packet(call, skb, offset, len,\r\nseq, cksum);\r\n}\r\nstatic int rxrpc_locate_data(struct rxrpc_call *call, struct sk_buff *skb,\r\nu8 *_annotation,\r\nunsigned int *_offset, unsigned int *_len)\r\n{\r\nunsigned int offset = sizeof(struct rxrpc_wire_header);\r\nunsigned int len = *_len;\r\nint ret;\r\nu8 annotation = *_annotation;\r\nlen = skb->len - offset;\r\nif ((annotation & RXRPC_RX_ANNO_JUMBO) > 0) {\r\noffset += (((annotation & RXRPC_RX_ANNO_JUMBO) - 1) *\r\nRXRPC_JUMBO_SUBPKTLEN);\r\nlen = (annotation & RXRPC_RX_ANNO_JLAST) ?\r\nskb->len - offset : RXRPC_JUMBO_SUBPKTLEN;\r\n}\r\nif (!(annotation & RXRPC_RX_ANNO_VERIFIED)) {\r\nret = rxrpc_verify_packet(call, skb, annotation, offset, len);\r\nif (ret < 0)\r\nreturn ret;\r\n*_annotation |= RXRPC_RX_ANNO_VERIFIED;\r\n}\r\n*_offset = offset;\r\n*_len = len;\r\ncall->conn->security->locate_data(call, skb, _offset, _len);\r\nreturn 0;\r\n}\r\nstatic int rxrpc_recvmsg_data(struct socket *sock, struct rxrpc_call *call,\r\nstruct msghdr *msg, struct iov_iter *iter,\r\nsize_t len, int flags, size_t *_offset)\r\n{\r\nstruct rxrpc_skb_priv *sp;\r\nstruct sk_buff *skb;\r\nrxrpc_seq_t hard_ack, top, seq;\r\nsize_t remain;\r\nbool last;\r\nunsigned int rx_pkt_offset, rx_pkt_len;\r\nint ix, copy, ret = -EAGAIN, ret2;\r\nrx_pkt_offset = call->rx_pkt_offset;\r\nrx_pkt_len = call->rx_pkt_len;\r\nif (call->state >= RXRPC_CALL_SERVER_ACK_REQUEST) {\r\nseq = call->rx_hard_ack;\r\nret = 1;\r\ngoto done;\r\n}\r\nhard_ack = call->rx_hard_ack;\r\nseq = hard_ack + 1;\r\nwhile (top = smp_load_acquire(&call->rx_top),\r\nbefore_eq(seq, top)\r\n) {\r\nix = seq & RXRPC_RXTX_BUFF_MASK;\r\nskb = call->rxtx_buffer[ix];\r\nif (!skb) {\r\ntrace_rxrpc_recvmsg(call, rxrpc_recvmsg_hole, seq,\r\nrx_pkt_offset, rx_pkt_len, 0);\r\nbreak;\r\n}\r\nsmp_rmb();\r\nrxrpc_see_skb(skb, rxrpc_skb_rx_seen);\r\nsp = rxrpc_skb(skb);\r\nif (!(flags & MSG_PEEK))\r\ntrace_rxrpc_receive(call, rxrpc_receive_front,\r\nsp->hdr.serial, seq);\r\nif (msg)\r\nsock_recv_timestamp(msg, sock->sk, skb);\r\nif (rx_pkt_offset == 0) {\r\nret2 = rxrpc_locate_data(call, skb,\r\n&call->rxtx_annotations[ix],\r\n&rx_pkt_offset, &rx_pkt_len);\r\ntrace_rxrpc_recvmsg(call, rxrpc_recvmsg_next, seq,\r\nrx_pkt_offset, rx_pkt_len, ret2);\r\nif (ret2 < 0) {\r\nret = ret2;\r\ngoto out;\r\n}\r\n} else {\r\ntrace_rxrpc_recvmsg(call, rxrpc_recvmsg_cont, seq,\r\nrx_pkt_offset, rx_pkt_len, 0);\r\n}\r\nremain = len - *_offset;\r\ncopy = rx_pkt_len;\r\nif (copy > remain)\r\ncopy = remain;\r\nif (copy > 0) {\r\nret2 = skb_copy_datagram_iter(skb, rx_pkt_offset, iter,\r\ncopy);\r\nif (ret2 < 0) {\r\nret = ret2;\r\ngoto out;\r\n}\r\nrx_pkt_offset += copy;\r\nrx_pkt_len -= copy;\r\n*_offset += copy;\r\n}\r\nif (rx_pkt_len > 0) {\r\ntrace_rxrpc_recvmsg(call, rxrpc_recvmsg_full, seq,\r\nrx_pkt_offset, rx_pkt_len, 0);\r\nASSERTCMP(*_offset, ==, len);\r\nret = 0;\r\nbreak;\r\n}\r\nlast = sp->hdr.flags & RXRPC_LAST_PACKET;\r\nif (!(flags & MSG_PEEK))\r\nrxrpc_rotate_rx_window(call);\r\nrx_pkt_offset = 0;\r\nrx_pkt_len = 0;\r\nif (last) {\r\nASSERTCMP(seq, ==, READ_ONCE(call->rx_top));\r\nret = 1;\r\ngoto out;\r\n}\r\nseq++;\r\n}\r\nout:\r\nif (!(flags & MSG_PEEK)) {\r\ncall->rx_pkt_offset = rx_pkt_offset;\r\ncall->rx_pkt_len = rx_pkt_len;\r\n}\r\ndone:\r\ntrace_rxrpc_recvmsg(call, rxrpc_recvmsg_data_return, seq,\r\nrx_pkt_offset, rx_pkt_len, ret);\r\nreturn ret;\r\n}\r\nint rxrpc_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\r\nint flags)\r\n{\r\nstruct rxrpc_call *call;\r\nstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\r\nstruct list_head *l;\r\nsize_t copied = 0;\r\nlong timeo;\r\nint ret;\r\nDEFINE_WAIT(wait);\r\ntrace_rxrpc_recvmsg(NULL, rxrpc_recvmsg_enter, 0, 0, 0, 0);\r\nif (flags & (MSG_OOB | MSG_TRUNC))\r\nreturn -EOPNOTSUPP;\r\ntimeo = sock_rcvtimeo(&rx->sk, flags & MSG_DONTWAIT);\r\ntry_again:\r\nlock_sock(&rx->sk);\r\nif (RB_EMPTY_ROOT(&rx->calls) &&\r\nlist_empty(&rx->recvmsg_q) &&\r\nrx->sk.sk_state != RXRPC_SERVER_LISTENING) {\r\nrelease_sock(&rx->sk);\r\nreturn -ENODATA;\r\n}\r\nif (list_empty(&rx->recvmsg_q)) {\r\nret = -EWOULDBLOCK;\r\nif (timeo == 0) {\r\ncall = NULL;\r\ngoto error_no_call;\r\n}\r\nrelease_sock(&rx->sk);\r\nprepare_to_wait_exclusive(sk_sleep(&rx->sk), &wait,\r\nTASK_INTERRUPTIBLE);\r\nret = sock_error(&rx->sk);\r\nif (ret)\r\ngoto wait_error;\r\nif (list_empty(&rx->recvmsg_q)) {\r\nif (signal_pending(current))\r\ngoto wait_interrupted;\r\ntrace_rxrpc_recvmsg(NULL, rxrpc_recvmsg_wait,\r\n0, 0, 0, 0);\r\ntimeo = schedule_timeout(timeo);\r\n}\r\nfinish_wait(sk_sleep(&rx->sk), &wait);\r\ngoto try_again;\r\n}\r\nwrite_lock_bh(&rx->recvmsg_lock);\r\nl = rx->recvmsg_q.next;\r\ncall = list_entry(l, struct rxrpc_call, recvmsg_link);\r\nif (!(flags & MSG_PEEK))\r\nlist_del_init(&call->recvmsg_link);\r\nelse\r\nrxrpc_get_call(call, rxrpc_call_got);\r\nwrite_unlock_bh(&rx->recvmsg_lock);\r\ntrace_rxrpc_recvmsg(call, rxrpc_recvmsg_dequeue, 0, 0, 0, 0);\r\nif (!mutex_trylock(&call->user_mutex)) {\r\nret = -EWOULDBLOCK;\r\nif (flags & MSG_DONTWAIT)\r\ngoto error_requeue_call;\r\nret = -ERESTARTSYS;\r\nif (mutex_lock_interruptible(&call->user_mutex) < 0)\r\ngoto error_requeue_call;\r\n}\r\nrelease_sock(&rx->sk);\r\nif (test_bit(RXRPC_CALL_RELEASED, &call->flags))\r\nBUG();\r\nif (test_bit(RXRPC_CALL_HAS_USERID, &call->flags)) {\r\nif (flags & MSG_CMSG_COMPAT) {\r\nunsigned int id32 = call->user_call_ID;\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_USER_CALL_ID,\r\nsizeof(unsigned int), &id32);\r\n} else {\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_USER_CALL_ID,\r\nsizeof(unsigned long),\r\n&call->user_call_ID);\r\n}\r\nif (ret < 0)\r\ngoto error_unlock_call;\r\n}\r\nif (msg->msg_name) {\r\nstruct sockaddr_rxrpc *srx = msg->msg_name;\r\nsize_t len = sizeof(call->peer->srx);\r\nmemcpy(msg->msg_name, &call->peer->srx, len);\r\nsrx->srx_service = call->service_id;\r\nmsg->msg_namelen = len;\r\n}\r\nswitch (READ_ONCE(call->state)) {\r\ncase RXRPC_CALL_SERVER_ACCEPTING:\r\nret = rxrpc_recvmsg_new_call(rx, call, msg, flags);\r\nbreak;\r\ncase RXRPC_CALL_CLIENT_RECV_REPLY:\r\ncase RXRPC_CALL_SERVER_RECV_REQUEST:\r\ncase RXRPC_CALL_SERVER_ACK_REQUEST:\r\nret = rxrpc_recvmsg_data(sock, call, msg, &msg->msg_iter, len,\r\nflags, &copied);\r\nif (ret == -EAGAIN)\r\nret = 0;\r\nif (after(call->rx_top, call->rx_hard_ack) &&\r\ncall->rxtx_buffer[(call->rx_hard_ack + 1) & RXRPC_RXTX_BUFF_MASK])\r\nrxrpc_notify_socket(call);\r\nbreak;\r\ndefault:\r\nret = 0;\r\nbreak;\r\n}\r\nif (ret < 0)\r\ngoto error_unlock_call;\r\nif (call->state == RXRPC_CALL_COMPLETE) {\r\nret = rxrpc_recvmsg_term(call, msg);\r\nif (ret < 0)\r\ngoto error_unlock_call;\r\nif (!(flags & MSG_PEEK))\r\nrxrpc_release_call(rx, call);\r\nmsg->msg_flags |= MSG_EOR;\r\nret = 1;\r\n}\r\nif (ret == 0)\r\nmsg->msg_flags |= MSG_MORE;\r\nelse\r\nmsg->msg_flags &= ~MSG_MORE;\r\nret = copied;\r\nerror_unlock_call:\r\nmutex_unlock(&call->user_mutex);\r\nrxrpc_put_call(call, rxrpc_call_put);\r\ntrace_rxrpc_recvmsg(call, rxrpc_recvmsg_return, 0, 0, 0, ret);\r\nreturn ret;\r\nerror_requeue_call:\r\nif (!(flags & MSG_PEEK)) {\r\nwrite_lock_bh(&rx->recvmsg_lock);\r\nlist_add(&call->recvmsg_link, &rx->recvmsg_q);\r\nwrite_unlock_bh(&rx->recvmsg_lock);\r\ntrace_rxrpc_recvmsg(call, rxrpc_recvmsg_requeue, 0, 0, 0, 0);\r\n} else {\r\nrxrpc_put_call(call, rxrpc_call_put);\r\n}\r\nerror_no_call:\r\nrelease_sock(&rx->sk);\r\ntrace_rxrpc_recvmsg(call, rxrpc_recvmsg_return, 0, 0, 0, ret);\r\nreturn ret;\r\nwait_interrupted:\r\nret = sock_intr_errno(timeo);\r\nwait_error:\r\nfinish_wait(sk_sleep(&rx->sk), &wait);\r\ncall = NULL;\r\ngoto error_no_call;\r\n}\r\nint rxrpc_kernel_recv_data(struct socket *sock, struct rxrpc_call *call,\r\nvoid *buf, size_t size, size_t *_offset,\r\nbool want_more, u32 *_abort)\r\n{\r\nstruct iov_iter iter;\r\nstruct kvec iov;\r\nint ret;\r\n_enter("{%d,%s},%zu/%zu,%d",\r\ncall->debug_id, rxrpc_call_states[call->state],\r\n*_offset, size, want_more);\r\nASSERTCMP(*_offset, <=, size);\r\nASSERTCMP(call->state, !=, RXRPC_CALL_SERVER_ACCEPTING);\r\niov.iov_base = buf + *_offset;\r\niov.iov_len = size - *_offset;\r\niov_iter_kvec(&iter, ITER_KVEC | READ, &iov, 1, size - *_offset);\r\nmutex_lock(&call->user_mutex);\r\nswitch (READ_ONCE(call->state)) {\r\ncase RXRPC_CALL_CLIENT_RECV_REPLY:\r\ncase RXRPC_CALL_SERVER_RECV_REQUEST:\r\ncase RXRPC_CALL_SERVER_ACK_REQUEST:\r\nret = rxrpc_recvmsg_data(sock, call, NULL, &iter, size, 0,\r\n_offset);\r\nif (ret < 0)\r\ngoto out;\r\nif (ret == 1) {\r\nif (*_offset < size)\r\ngoto short_data;\r\nif (!want_more)\r\ngoto read_phase_complete;\r\nret = 0;\r\ngoto out;\r\n}\r\nif (!want_more)\r\ngoto excess_data;\r\ngoto out;\r\ncase RXRPC_CALL_COMPLETE:\r\ngoto call_complete;\r\ndefault:\r\nret = -EINPROGRESS;\r\ngoto out;\r\n}\r\nread_phase_complete:\r\nret = 1;\r\nout:\r\nmutex_unlock(&call->user_mutex);\r\n_leave(" = %d [%zu,%d]", ret, *_offset, *_abort);\r\nreturn ret;\r\nshort_data:\r\ntrace_rxrpc_rx_eproto(call, 0, tracepoint_string("short_data"));\r\nret = -EBADMSG;\r\ngoto out;\r\nexcess_data:\r\ntrace_rxrpc_rx_eproto(call, 0, tracepoint_string("excess_data"));\r\nret = -EMSGSIZE;\r\ngoto out;\r\ncall_complete:\r\n*_abort = call->abort_code;\r\nret = call->error;\r\nif (call->completion == RXRPC_CALL_SUCCEEDED) {\r\nret = 1;\r\nif (size > 0)\r\nret = -ECONNRESET;\r\n}\r\ngoto out;\r\n}
