static int imx_pwm_config_v1(struct pwm_chip *chip,\r\nstruct pwm_device *pwm, int duty_ns, int period_ns)\r\n{\r\nstruct imx_chip *imx = to_imx_chip(chip);\r\nu32 max = readl(imx->mmio_base + MX1_PWMP);\r\nu32 p = max * duty_ns / period_ns;\r\nwritel(max - p, imx->mmio_base + MX1_PWMS);\r\nreturn 0;\r\n}\r\nstatic int imx_pwm_enable_v1(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct imx_chip *imx = to_imx_chip(chip);\r\nu32 val;\r\nint ret;\r\nret = clk_prepare_enable(imx->clk_per);\r\nif (ret < 0)\r\nreturn ret;\r\nval = readl(imx->mmio_base + MX1_PWMC);\r\nval |= MX1_PWMC_EN;\r\nwritel(val, imx->mmio_base + MX1_PWMC);\r\nreturn 0;\r\n}\r\nstatic void imx_pwm_disable_v1(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct imx_chip *imx = to_imx_chip(chip);\r\nu32 val;\r\nval = readl(imx->mmio_base + MX1_PWMC);\r\nval &= ~MX1_PWMC_EN;\r\nwritel(val, imx->mmio_base + MX1_PWMC);\r\nclk_disable_unprepare(imx->clk_per);\r\n}\r\nstatic void imx_pwm_sw_reset(struct pwm_chip *chip)\r\n{\r\nstruct imx_chip *imx = to_imx_chip(chip);\r\nstruct device *dev = chip->dev;\r\nint wait_count = 0;\r\nu32 cr;\r\nwritel(MX3_PWMCR_SWR, imx->mmio_base + MX3_PWMCR);\r\ndo {\r\nusleep_range(200, 1000);\r\ncr = readl(imx->mmio_base + MX3_PWMCR);\r\n} while ((cr & MX3_PWMCR_SWR) &&\r\n(wait_count++ < MX3_PWM_SWR_LOOP));\r\nif (cr & MX3_PWMCR_SWR)\r\ndev_warn(dev, "software reset timeout\n");\r\n}\r\nstatic void imx_pwm_wait_fifo_slot(struct pwm_chip *chip,\r\nstruct pwm_device *pwm)\r\n{\r\nstruct imx_chip *imx = to_imx_chip(chip);\r\nstruct device *dev = chip->dev;\r\nunsigned int period_ms;\r\nint fifoav;\r\nu32 sr;\r\nsr = readl(imx->mmio_base + MX3_PWMSR);\r\nfifoav = sr & MX3_PWMSR_FIFOAV_MASK;\r\nif (fifoav == MX3_PWMSR_FIFOAV_4WORDS) {\r\nperiod_ms = DIV_ROUND_UP(pwm_get_period(pwm),\r\nNSEC_PER_MSEC);\r\nmsleep(period_ms);\r\nsr = readl(imx->mmio_base + MX3_PWMSR);\r\nif (fifoav == (sr & MX3_PWMSR_FIFOAV_MASK))\r\ndev_warn(dev, "there is no free FIFO slot\n");\r\n}\r\n}\r\nstatic int imx_pwm_apply_v2(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nunsigned long period_cycles, duty_cycles, prescale;\r\nstruct imx_chip *imx = to_imx_chip(chip);\r\nstruct pwm_state cstate;\r\nunsigned long long c;\r\nint ret;\r\nu32 cr;\r\npwm_get_state(pwm, &cstate);\r\nif (state->enabled) {\r\nc = clk_get_rate(imx->clk_per);\r\nc *= state->period;\r\ndo_div(c, 1000000000);\r\nperiod_cycles = c;\r\nprescale = period_cycles / 0x10000 + 1;\r\nperiod_cycles /= prescale;\r\nc = (unsigned long long)period_cycles * state->duty_cycle;\r\ndo_div(c, state->period);\r\nduty_cycles = c;\r\nif (period_cycles > 2)\r\nperiod_cycles -= 2;\r\nelse\r\nperiod_cycles = 0;\r\nif (cstate.enabled) {\r\nimx_pwm_wait_fifo_slot(chip, pwm);\r\n} else {\r\nret = clk_prepare_enable(imx->clk_per);\r\nif (ret)\r\nreturn ret;\r\nimx_pwm_sw_reset(chip);\r\n}\r\nwritel(duty_cycles, imx->mmio_base + MX3_PWMSAR);\r\nwritel(period_cycles, imx->mmio_base + MX3_PWMPR);\r\ncr = MX3_PWMCR_PRESCALER(prescale) |\r\nMX3_PWMCR_DOZEEN | MX3_PWMCR_WAITEN |\r\nMX3_PWMCR_DBGEN | MX3_PWMCR_CLKSRC_IPG_HIGH |\r\nMX3_PWMCR_EN;\r\nif (state->polarity == PWM_POLARITY_INVERSED)\r\ncr |= MX3_PWMCR_POUTC;\r\nwritel(cr, imx->mmio_base + MX3_PWMCR);\r\n} else if (cstate.enabled) {\r\nwritel(0, imx->mmio_base + MX3_PWMCR);\r\nclk_disable_unprepare(imx->clk_per);\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_pwm_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(imx_pwm_dt_ids, &pdev->dev);\r\nconst struct imx_pwm_data *data;\r\nstruct imx_chip *imx;\r\nstruct resource *r;\r\nint ret = 0;\r\nif (!of_id)\r\nreturn -ENODEV;\r\ndata = of_id->data;\r\nimx = devm_kzalloc(&pdev->dev, sizeof(*imx), GFP_KERNEL);\r\nif (imx == NULL)\r\nreturn -ENOMEM;\r\nimx->clk_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(imx->clk_per)) {\r\ndev_err(&pdev->dev, "getting per clock failed with %ld\n",\r\nPTR_ERR(imx->clk_per));\r\nreturn PTR_ERR(imx->clk_per);\r\n}\r\nimx->chip.ops = data->ops;\r\nimx->chip.dev = &pdev->dev;\r\nimx->chip.base = -1;\r\nimx->chip.npwm = 1;\r\nif (data->polarity_supported) {\r\ndev_dbg(&pdev->dev, "PWM supports output inversion\n");\r\nimx->chip.of_xlate = of_pwm_xlate_with_flags;\r\nimx->chip.of_pwm_n_cells = 3;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nimx->mmio_base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(imx->mmio_base))\r\nreturn PTR_ERR(imx->mmio_base);\r\nret = pwmchip_add(&imx->chip);\r\nif (ret < 0)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, imx);\r\nreturn 0;\r\n}\r\nstatic int imx_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_chip *imx;\r\nimx = platform_get_drvdata(pdev);\r\nif (imx == NULL)\r\nreturn -ENODEV;\r\nreturn pwmchip_remove(&imx->chip);\r\n}
