static int vco_get(struct clk_icst *icst, struct icst_vco *vco)\r\n{\r\nu32 val;\r\nint ret;\r\nret = regmap_read(icst->map, icst->vcoreg_off, &val);\r\nif (ret)\r\nreturn ret;\r\nif (icst->ctype == ICST_INTEGRATOR_AP_CM) {\r\nvco->v = val & INTEGRATOR_AP_CM_BITS;\r\nvco->r = 22;\r\nvco->s = 1;\r\nreturn 0;\r\n}\r\nif (icst->ctype == ICST_INTEGRATOR_AP_SYS) {\r\nvco->v = val & INTEGRATOR_AP_SYS_BITS;\r\nvco->r = 46;\r\nvco->s = 3;\r\nreturn 0;\r\n}\r\nif (icst->ctype == ICST_INTEGRATOR_AP_PCI) {\r\nbool divxy = !!(val & INTEGRATOR_AP_PCI_25_33_MHZ);\r\nvco->v = divxy ? 17 : 14;\r\nvco->r = divxy ? 22 : 14;\r\nvco->s = 1;\r\nreturn 0;\r\n}\r\nif (icst->ctype == ICST_INTEGRATOR_CP_CM_CORE) {\r\nvco->v = val & 0xFF;\r\nvco->r = 22;\r\nvco->s = (val >> 8) & 7;\r\nreturn 0;\r\n}\r\nif (icst->ctype == ICST_INTEGRATOR_CP_CM_MEM) {\r\nvco->v = (val >> 12) & 0xFF;\r\nvco->r = 22;\r\nvco->s = (val >> 20) & 7;\r\nreturn 0;\r\n}\r\nvco->v = val & 0x1ff;\r\nvco->r = (val >> 9) & 0x7f;\r\nvco->s = (val >> 16) & 03;\r\nreturn 0;\r\n}\r\nstatic int vco_set(struct clk_icst *icst, struct icst_vco vco)\r\n{\r\nu32 mask;\r\nu32 val;\r\nint ret;\r\nswitch (icst->ctype) {\r\ncase ICST_INTEGRATOR_AP_CM:\r\nmask = INTEGRATOR_AP_CM_BITS;\r\nval = vco.v & 0xFF;\r\nif (vco.v & 0x100)\r\npr_err("ICST error: tried to set bit 8 of VDW\n");\r\nif (vco.s != 1)\r\npr_err("ICST error: tried to use VOD != 1\n");\r\nif (vco.r != 22)\r\npr_err("ICST error: tried to use RDW != 22\n");\r\nbreak;\r\ncase ICST_INTEGRATOR_AP_SYS:\r\nmask = INTEGRATOR_AP_SYS_BITS;\r\nval = vco.v & 0xFF;\r\nif (vco.v & 0x100)\r\npr_err("ICST error: tried to set bit 8 of VDW\n");\r\nif (vco.s != 3)\r\npr_err("ICST error: tried to use VOD != 1\n");\r\nif (vco.r != 46)\r\npr_err("ICST error: tried to use RDW != 22\n");\r\nbreak;\r\ncase ICST_INTEGRATOR_CP_CM_CORE:\r\nmask = INTEGRATOR_CP_CM_CORE_BITS;\r\nval = (vco.v & 0xFF) | vco.s << 8;\r\nif (vco.v & 0x100)\r\npr_err("ICST error: tried to set bit 8 of VDW\n");\r\nif (vco.r != 22)\r\npr_err("ICST error: tried to use RDW != 22\n");\r\nbreak;\r\ncase ICST_INTEGRATOR_CP_CM_MEM:\r\nmask = INTEGRATOR_CP_CM_MEM_BITS;\r\nval = ((vco.v & 0xFF) << 12) | (vco.s << 20);\r\nif (vco.v & 0x100)\r\npr_err("ICST error: tried to set bit 8 of VDW\n");\r\nif (vco.r != 22)\r\npr_err("ICST error: tried to use RDW != 22\n");\r\nbreak;\r\ndefault:\r\nmask = VERSATILE_AUX_OSC_BITS;\r\nval = vco.v | (vco.r << 9) | (vco.s << 16);\r\nbreak;\r\n}\r\npr_debug("ICST: new val = 0x%08x\n", val);\r\nret = regmap_write(icst->map, icst->lockreg_off, VERSATILE_LOCK_VAL);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(icst->map, icst->vcoreg_off, mask, val);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(icst->map, icst->lockreg_off, 0);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic unsigned long icst_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_icst *icst = to_icst(hw);\r\nstruct icst_vco vco;\r\nint ret;\r\nif (parent_rate)\r\nicst->params->ref = parent_rate;\r\nret = vco_get(icst, &vco);\r\nif (ret) {\r\npr_err("ICST: could not get VCO setting\n");\r\nreturn 0;\r\n}\r\nicst->rate = icst_hz(icst->params, vco);\r\nreturn icst->rate;\r\n}\r\nstatic long icst_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_icst *icst = to_icst(hw);\r\nstruct icst_vco vco;\r\nif (icst->ctype == ICST_INTEGRATOR_AP_CM ||\r\nicst->ctype == ICST_INTEGRATOR_CP_CM_CORE) {\r\nif (rate <= 12000000)\r\nreturn 12000000;\r\nif (rate >= 160000000)\r\nreturn 160000000;\r\nreturn DIV_ROUND_CLOSEST(rate, 1000000) * 1000000;\r\n}\r\nif (icst->ctype == ICST_INTEGRATOR_CP_CM_MEM) {\r\nif (rate <= 6000000)\r\nreturn 6000000;\r\nif (rate >= 66000000)\r\nreturn 66000000;\r\nreturn DIV_ROUND_CLOSEST(rate, 500000) * 500000;\r\n}\r\nif (icst->ctype == ICST_INTEGRATOR_AP_SYS) {\r\nif (rate <= 3000000)\r\nreturn 3000000;\r\nif (rate >= 50000000)\r\nreturn 5000000;\r\nreturn DIV_ROUND_CLOSEST(rate, 250000) * 250000;\r\n}\r\nif (icst->ctype == ICST_INTEGRATOR_AP_PCI) {\r\nif (rate <= 25000000 || rate < 29000000)\r\nreturn 25000000;\r\nreturn 33000000;\r\n}\r\nvco = icst_hz_to_vco(icst->params, rate);\r\nreturn icst_hz(icst->params, vco);\r\n}\r\nstatic int icst_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_icst *icst = to_icst(hw);\r\nstruct icst_vco vco;\r\nif (icst->ctype == ICST_INTEGRATOR_AP_PCI) {\r\nunsigned int val;\r\nint ret;\r\nif (rate == 25000000) {\r\nval = 0;\r\n} else if (rate == 33000000) {\r\nval = INTEGRATOR_AP_PCI_25_33_MHZ;\r\n} else {\r\npr_err("ICST: cannot set PCI frequency %lu\n",\r\nrate);\r\nreturn -EINVAL;\r\n}\r\nret = regmap_write(icst->map, icst->lockreg_off,\r\nVERSATILE_LOCK_VAL);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(icst->map, icst->vcoreg_off,\r\nINTEGRATOR_AP_PCI_25_33_MHZ,\r\nval);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(icst->map, icst->lockreg_off, 0);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nif (parent_rate)\r\nicst->params->ref = parent_rate;\r\nvco = icst_hz_to_vco(icst->params, rate);\r\nicst->rate = icst_hz(icst->params, vco);\r\nreturn vco_set(icst, vco);\r\n}\r\nstatic struct clk *icst_clk_setup(struct device *dev,\r\nconst struct clk_icst_desc *desc,\r\nconst char *name,\r\nconst char *parent_name,\r\nstruct regmap *map,\r\nenum icst_control_type ctype)\r\n{\r\nstruct clk *clk;\r\nstruct clk_icst *icst;\r\nstruct clk_init_data init;\r\nstruct icst_params *pclone;\r\nicst = kzalloc(sizeof(struct clk_icst), GFP_KERNEL);\r\nif (!icst) {\r\npr_err("could not allocate ICST clock!\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\npclone = kmemdup(desc->params, sizeof(*pclone), GFP_KERNEL);\r\nif (!pclone) {\r\nkfree(icst);\r\npr_err("could not clone ICST params\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.ops = &icst_ops;\r\ninit.flags = 0;\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\nicst->map = map;\r\nicst->hw.init = &init;\r\nicst->params = pclone;\r\nicst->vcoreg_off = desc->vco_offset;\r\nicst->lockreg_off = desc->lock_offset;\r\nicst->ctype = ctype;\r\nclk = clk_register(dev, &icst->hw);\r\nif (IS_ERR(clk)) {\r\nkfree(pclone);\r\nkfree(icst);\r\n}\r\nreturn clk;\r\n}\r\nstruct clk *icst_clk_register(struct device *dev,\r\nconst struct clk_icst_desc *desc,\r\nconst char *name,\r\nconst char *parent_name,\r\nvoid __iomem *base)\r\n{\r\nstruct regmap_config icst_regmap_conf = {\r\n.reg_bits = 32,\r\n.val_bits = 32,\r\n.reg_stride = 4,\r\n};\r\nstruct regmap *map;\r\nmap = regmap_init_mmio(dev, base, &icst_regmap_conf);\r\nif (IS_ERR(map)) {\r\npr_err("could not initialize ICST regmap\n");\r\nreturn ERR_CAST(map);\r\n}\r\nreturn icst_clk_setup(dev, desc, name, parent_name, map,\r\nICST_VERSATILE);\r\n}\r\nstatic void __init of_syscon_icst_setup(struct device_node *np)\r\n{\r\nstruct device_node *parent;\r\nstruct regmap *map;\r\nstruct clk_icst_desc icst_desc;\r\nconst char *name = np->name;\r\nconst char *parent_name;\r\nstruct clk *regclk;\r\nenum icst_control_type ctype;\r\nparent = of_get_parent(np);\r\nif (!parent) {\r\npr_err("no parent node for syscon ICST clock\n");\r\nreturn;\r\n}\r\nmap = syscon_node_to_regmap(parent);\r\nif (IS_ERR(map)) {\r\npr_err("no regmap for syscon ICST clock parent\n");\r\nreturn;\r\n}\r\nif (of_property_read_u32(np, "vco-offset", &icst_desc.vco_offset)) {\r\npr_err("no VCO register offset for ICST clock\n");\r\nreturn;\r\n}\r\nif (of_property_read_u32(np, "lock-offset", &icst_desc.lock_offset)) {\r\npr_err("no lock register offset for ICST clock\n");\r\nreturn;\r\n}\r\nif (of_device_is_compatible(np, "arm,syscon-icst525")) {\r\nicst_desc.params = &icst525_params;\r\nctype = ICST_VERSATILE;\r\n} else if (of_device_is_compatible(np, "arm,syscon-icst307")) {\r\nicst_desc.params = &icst307_params;\r\nctype = ICST_VERSATILE;\r\n} else if (of_device_is_compatible(np, "arm,syscon-icst525-integratorap-cm")) {\r\nicst_desc.params = &icst525_apcp_cm_params;\r\nctype = ICST_INTEGRATOR_AP_CM;\r\n} else if (of_device_is_compatible(np, "arm,syscon-icst525-integratorap-sys")) {\r\nicst_desc.params = &icst525_ap_sys_params;\r\nctype = ICST_INTEGRATOR_AP_SYS;\r\n} else if (of_device_is_compatible(np, "arm,syscon-icst525-integratorap-pci")) {\r\nicst_desc.params = &icst525_ap_pci_params;\r\nctype = ICST_INTEGRATOR_AP_PCI;\r\n} else if (of_device_is_compatible(np, "arm,syscon-icst525-integratorcp-cm-core")) {\r\nicst_desc.params = &icst525_apcp_cm_params;\r\nctype = ICST_INTEGRATOR_CP_CM_CORE;\r\n} else if (of_device_is_compatible(np, "arm,syscon-icst525-integratorcp-cm-mem")) {\r\nicst_desc.params = &icst525_apcp_cm_params;\r\nctype = ICST_INTEGRATOR_CP_CM_MEM;\r\n} else {\r\npr_err("unknown ICST clock %s\n", name);\r\nreturn;\r\n}\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nregclk = icst_clk_setup(NULL, &icst_desc, name, parent_name, map, ctype);\r\nif (IS_ERR(regclk)) {\r\npr_err("error setting up syscon ICST clock %s\n", name);\r\nreturn;\r\n}\r\nof_clk_add_provider(np, of_clk_src_simple_get, regclk);\r\npr_debug("registered syscon ICST clock %s\n", name);\r\n}
