static u64 clk_fepll_vco_calc_rate(struct clk_fepll *pll_div,\r\nunsigned long parent_rate)\r\n{\r\nconst struct clk_fepll_vco *pll_vco = pll_div->pll_vco;\r\nu32 fdbkdiv, refclkdiv, cdiv;\r\nu64 vco;\r\nregmap_read(pll_div->cdiv.clkr.regmap, pll_vco->reg, &cdiv);\r\nrefclkdiv = (cdiv >> pll_vco->refclkdiv_shift) &\r\n(BIT(pll_vco->refclkdiv_width) - 1);\r\nfdbkdiv = (cdiv >> pll_vco->fdbkdiv_shift) &\r\n(BIT(pll_vco->fdbkdiv_width) - 1);\r\nvco = parent_rate / refclkdiv;\r\nvco *= 2;\r\nvco *= fdbkdiv;\r\nreturn vco;\r\n}\r\nstatic long clk_cpu_div_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *p_rate)\r\n{\r\nstruct clk_fepll *pll = to_clk_fepll(hw);\r\nstruct clk_hw *p_hw;\r\nconst struct freq_tbl *f;\r\nf = qcom_find_freq(pll->freq_tbl, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\np_hw = clk_hw_get_parent_by_index(hw, f->src);\r\n*p_rate = clk_hw_get_rate(p_hw);\r\nreturn f->freq;\r\n}\r\nstatic int clk_cpu_div_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_fepll *pll = to_clk_fepll(hw);\r\nconst struct freq_tbl *f;\r\nu32 mask;\r\nint ret;\r\nf = qcom_find_freq(pll->freq_tbl, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nmask = (BIT(pll->cdiv.width) - 1) << pll->cdiv.shift;\r\nret = regmap_update_bits(pll->cdiv.clkr.regmap,\r\npll->cdiv.reg, mask,\r\nf->pre_div << pll->cdiv.shift);\r\nudelay(1);\r\nreturn 0;\r\n}\r\nstatic unsigned long\r\nclk_cpu_div_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_fepll *pll = to_clk_fepll(hw);\r\nu32 cdiv, pre_div;\r\nu64 rate;\r\nregmap_read(pll->cdiv.clkr.regmap, pll->cdiv.reg, &cdiv);\r\ncdiv = (cdiv >> pll->cdiv.shift) & (BIT(pll->cdiv.width) - 1);\r\nif (cdiv > 10)\r\npre_div = (cdiv + 1) * 2;\r\nelse\r\npre_div = cdiv + 12;\r\nrate = clk_fepll_vco_calc_rate(pll, parent_rate) * 2;\r\ndo_div(rate, pre_div);\r\nreturn rate;\r\n}\r\nstatic unsigned long\r\nclk_regmap_clk_div_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_fepll *pll = to_clk_fepll(hw);\r\nu32 cdiv, pre_div = 1;\r\nu64 rate;\r\nconst struct clk_div_table *clkt;\r\nif (pll->fixed_div) {\r\npre_div = pll->fixed_div;\r\n} else {\r\nregmap_read(pll->cdiv.clkr.regmap, pll->cdiv.reg, &cdiv);\r\ncdiv = (cdiv >> pll->cdiv.shift) & (BIT(pll->cdiv.width) - 1);\r\nfor (clkt = pll->div_table; clkt->div; clkt++) {\r\nif (clkt->val == cdiv)\r\npre_div = clkt->div;\r\n}\r\n}\r\nrate = clk_fepll_vco_calc_rate(pll, parent_rate);\r\ndo_div(rate, pre_div);\r\nreturn rate;\r\n}\r\nstatic int\r\ngcc_ipq4019_cpu_clk_notifier_fn(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nint err = 0;\r\nif (action == PRE_RATE_CHANGE)\r\nerr = clk_rcg2_ops.set_parent(&apps_clk_src.clkr.hw,\r\ngcc_ipq4019_cpu_safe_parent);\r\nreturn notifier_from_errno(err);\r\n}\r\nstatic int gcc_ipq4019_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nerr = qcom_cc_probe(pdev, &gcc_ipq4019_desc);\r\nif (err)\r\nreturn err;\r\nreturn clk_notifier_register(apps_clk_src.clkr.hw.clk,\r\n&gcc_ipq4019_cpu_clk_notifier);\r\n}\r\nstatic int gcc_ipq4019_remove(struct platform_device *pdev)\r\n{\r\nreturn clk_notifier_unregister(apps_clk_src.clkr.hw.clk,\r\n&gcc_ipq4019_cpu_clk_notifier);\r\n}\r\nstatic int __init gcc_ipq4019_init(void)\r\n{\r\nreturn platform_driver_register(&gcc_ipq4019_driver);\r\n}\r\nstatic void __exit gcc_ipq4019_exit(void)\r\n{\r\nplatform_driver_unregister(&gcc_ipq4019_driver);\r\n}
