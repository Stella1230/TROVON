static void odmi_compose_msi_msg(struct irq_data *d, struct msi_msg *msg)\r\n{\r\nstruct odmi_data *odmi;\r\nphys_addr_t addr;\r\nunsigned int odmin;\r\nif (WARN_ON(d->hwirq >= odmis_count * NODMIS_PER_FRAME))\r\nreturn;\r\nodmi = &odmis[d->hwirq >> NODMIS_SHIFT];\r\nodmin = d->hwirq & NODMIS_MASK;\r\naddr = odmi->res.start + GICP_ODMIN_SET;\r\nmsg->address_hi = upper_32_bits(addr);\r\nmsg->address_lo = lower_32_bits(addr);\r\nmsg->data = odmin << GICP_ODMI_INT_NUM_SHIFT;\r\n}\r\nstatic int odmi_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\r\nunsigned int nr_irqs, void *args)\r\n{\r\nstruct odmi_data *odmi = NULL;\r\nstruct irq_fwspec fwspec;\r\nstruct irq_data *d;\r\nunsigned int hwirq, odmin;\r\nint ret;\r\nspin_lock(&odmis_bm_lock);\r\nhwirq = find_first_zero_bit(odmis_bm, NODMIS_PER_FRAME * odmis_count);\r\nif (hwirq >= NODMIS_PER_FRAME * odmis_count) {\r\nspin_unlock(&odmis_bm_lock);\r\nreturn -ENOSPC;\r\n}\r\n__set_bit(hwirq, odmis_bm);\r\nspin_unlock(&odmis_bm_lock);\r\nodmi = &odmis[hwirq >> NODMIS_SHIFT];\r\nodmin = hwirq & NODMIS_MASK;\r\nfwspec.fwnode = domain->parent->fwnode;\r\nfwspec.param_count = 3;\r\nfwspec.param[0] = GIC_SPI;\r\nfwspec.param[1] = odmi->spi_base - 32 + odmin;\r\nfwspec.param[2] = IRQ_TYPE_EDGE_RISING;\r\nret = irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\r\nif (ret) {\r\npr_err("Cannot allocate parent IRQ\n");\r\nspin_lock(&odmis_bm_lock);\r\n__clear_bit(odmin, odmis_bm);\r\nspin_unlock(&odmis_bm_lock);\r\nreturn ret;\r\n}\r\nd = irq_domain_get_irq_data(domain->parent, virq);\r\nd->chip->irq_set_type(d, IRQ_TYPE_EDGE_RISING);\r\nirq_domain_set_hwirq_and_chip(domain, virq, hwirq,\r\n&odmi_irq_chip, NULL);\r\nreturn 0;\r\n}\r\nstatic void odmi_irq_domain_free(struct irq_domain *domain,\r\nunsigned int virq, unsigned int nr_irqs)\r\n{\r\nstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\r\nif (d->hwirq >= odmis_count * NODMIS_PER_FRAME) {\r\npr_err("Failed to teardown msi. Invalid hwirq %lu\n", d->hwirq);\r\nreturn;\r\n}\r\nirq_domain_free_irqs_parent(domain, virq, nr_irqs);\r\nspin_lock(&odmis_bm_lock);\r\n__clear_bit(d->hwirq, odmis_bm);\r\nspin_unlock(&odmis_bm_lock);\r\n}\r\nstatic int __init mvebu_odmi_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct irq_domain *inner_domain, *plat_domain;\r\nint ret, i;\r\nif (of_property_read_u32(node, "marvell,odmi-frames", &odmis_count))\r\nreturn -EINVAL;\r\nodmis = kcalloc(odmis_count, sizeof(struct odmi_data), GFP_KERNEL);\r\nif (!odmis)\r\nreturn -ENOMEM;\r\nodmis_bm = kcalloc(BITS_TO_LONGS(odmis_count * NODMIS_PER_FRAME),\r\nsizeof(long), GFP_KERNEL);\r\nif (!odmis_bm) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nfor (i = 0; i < odmis_count; i++) {\r\nstruct odmi_data *odmi = &odmis[i];\r\nret = of_address_to_resource(node, i, &odmi->res);\r\nif (ret)\r\ngoto err_unmap;\r\nodmi->base = of_io_request_and_map(node, i, "odmi");\r\nif (IS_ERR(odmi->base)) {\r\nret = PTR_ERR(odmi->base);\r\ngoto err_unmap;\r\n}\r\nif (of_property_read_u32_index(node, "marvell,spi-base",\r\ni, &odmi->spi_base)) {\r\nret = -EINVAL;\r\ngoto err_unmap;\r\n}\r\n}\r\ninner_domain = irq_domain_create_linear(of_node_to_fwnode(node),\r\nodmis_count * NODMIS_PER_FRAME,\r\n&odmi_domain_ops, NULL);\r\nif (!inner_domain) {\r\nret = -ENOMEM;\r\ngoto err_unmap;\r\n}\r\ninner_domain->parent = irq_find_host(parent);\r\nplat_domain = platform_msi_create_irq_domain(of_node_to_fwnode(node),\r\n&odmi_msi_domain_info,\r\ninner_domain);\r\nif (!plat_domain) {\r\nret = -ENOMEM;\r\ngoto err_remove_inner;\r\n}\r\nreturn 0;\r\nerr_remove_inner:\r\nirq_domain_remove(inner_domain);\r\nerr_unmap:\r\nfor (i = 0; i < odmis_count; i++) {\r\nstruct odmi_data *odmi = &odmis[i];\r\nif (odmi->base && !IS_ERR(odmi->base))\r\niounmap(odmis[i].base);\r\n}\r\nkfree(odmis_bm);\r\nerr_alloc:\r\nkfree(odmis);\r\nreturn ret;\r\n}
