static void secmark_save(const struct sk_buff *skb)\r\n{\r\nif (skb->secmark) {\r\nstruct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct && !ct->secmark) {\r\nct->secmark = skb->secmark;\r\nnf_conntrack_event_cache(IPCT_SECMARK, ct);\r\n}\r\n}\r\n}\r\nstatic void secmark_restore(struct sk_buff *skb)\r\n{\r\nif (!skb->secmark) {\r\nconst struct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct && ct->secmark)\r\nskb->secmark = ct->secmark;\r\n}\r\n}\r\nstatic unsigned int\r\nconnsecmark_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_connsecmark_target_info *info = par->targinfo;\r\nswitch (info->mode) {\r\ncase CONNSECMARK_SAVE:\r\nsecmark_save(skb);\r\nbreak;\r\ncase CONNSECMARK_RESTORE:\r\nsecmark_restore(skb);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn XT_CONTINUE;\r\n}\r\nstatic int connsecmark_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct xt_connsecmark_target_info *info = par->targinfo;\r\nint ret;\r\nif (strcmp(par->table, "mangle") != 0 &&\r\nstrcmp(par->table, "security") != 0) {\r\npr_info("target only valid in the \'mangle\' "\r\n"or \'security\' tables, not \'%s\'.\n", par->table);\r\nreturn -EINVAL;\r\n}\r\nswitch (info->mode) {\r\ncase CONNSECMARK_SAVE:\r\ncase CONNSECMARK_RESTORE:\r\nbreak;\r\ndefault:\r\npr_info("invalid mode: %hu\n", info->mode);\r\nreturn -EINVAL;\r\n}\r\nret = nf_ct_netns_get(par->net, par->family);\r\nif (ret < 0)\r\npr_info("cannot load conntrack support for proto=%u\n",\r\npar->family);\r\nreturn ret;\r\n}\r\nstatic void connsecmark_tg_destroy(const struct xt_tgdtor_param *par)\r\n{\r\nnf_ct_netns_put(par->net, par->family);\r\n}\r\nstatic int __init connsecmark_tg_init(void)\r\n{\r\nreturn xt_register_target(&connsecmark_tg_reg);\r\n}\r\nstatic void __exit connsecmark_tg_exit(void)\r\n{\r\nxt_unregister_target(&connsecmark_tg_reg);\r\n}
