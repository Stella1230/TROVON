unsigned long uv_undefined(char *str)\r\n{\r\nif (likely(!disable_uv_undefined_panic))\r\npanic("UV: error: undefined MMR: %s\n", str);\r\nelse\r\npr_crit("UV: error: undefined MMR: %s\n", str);\r\nreturn ~0ul;\r\n}\r\nstatic unsigned long __init uv_early_read_mmr(unsigned long addr)\r\n{\r\nunsigned long val, *mmr;\r\nmmr = early_ioremap(UV_LOCAL_MMR_BASE | addr, sizeof(*mmr));\r\nval = *mmr;\r\nearly_iounmap(mmr, sizeof(*mmr));\r\nreturn val;\r\n}\r\nstatic inline bool is_GRU_range(u64 start, u64 end)\r\n{\r\nif (gru_dist_base) {\r\nu64 su = start & gru_dist_umask;\r\nu64 sl = start & gru_dist_lmask;\r\nu64 eu = end & gru_dist_umask;\r\nu64 el = end & gru_dist_lmask;\r\nreturn (sl == gru_dist_base && el == gru_dist_base &&\r\nsu >= gru_first_node_paddr &&\r\nsu <= gru_last_node_paddr &&\r\neu == su);\r\n} else {\r\nreturn start >= gru_start_paddr && end <= gru_end_paddr;\r\n}\r\n}\r\nstatic bool uv_is_untracked_pat_range(u64 start, u64 end)\r\n{\r\nreturn is_ISA_range(start, end) || is_GRU_range(start, end);\r\n}\r\nstatic int __init early_get_pnodeid(void)\r\n{\r\nunion uvh_node_id_u node_id;\r\nunion uvh_rh_gam_config_mmr_u m_n_config;\r\nint pnode;\r\nnode_id.v = uv_early_read_mmr(UVH_NODE_ID);\r\nm_n_config.v = uv_early_read_mmr(UVH_RH_GAM_CONFIG_MMR);\r\nuv_min_hub_revision_id = node_id.s.revision;\r\nswitch (node_id.s.part_number) {\r\ncase UV2_HUB_PART_NUMBER:\r\ncase UV2_HUB_PART_NUMBER_X:\r\nuv_min_hub_revision_id += UV2_HUB_REVISION_BASE - 1;\r\nbreak;\r\ncase UV3_HUB_PART_NUMBER:\r\ncase UV3_HUB_PART_NUMBER_X:\r\nuv_min_hub_revision_id += UV3_HUB_REVISION_BASE;\r\nbreak;\r\ncase UV4_HUB_PART_NUMBER:\r\nuv_min_hub_revision_id += UV4_HUB_REVISION_BASE - 1;\r\nuv_cpuid.gnode_shift = 2;\r\nbreak;\r\n}\r\nuv_hub_info->hub_revision = uv_min_hub_revision_id;\r\nuv_cpuid.pnode_mask = (1 << m_n_config.s.n_skt) - 1;\r\npnode = (node_id.s.node_id >> 1) & uv_cpuid.pnode_mask;\r\nuv_cpuid.gpa_shift = 46;\r\npr_info("UV: rev:%d part#:%x nodeid:%04x n_skt:%d pnmsk:%x pn:%x\n",\r\nnode_id.s.revision, node_id.s.part_number, node_id.s.node_id,\r\nm_n_config.s.n_skt, uv_cpuid.pnode_mask, pnode);\r\nreturn pnode;\r\n}\r\nstatic void set_x2apic_bits(void)\r\n{\r\nunsigned int eax, ebx, ecx, edx, sub_index;\r\nunsigned int sid_shift;\r\ncpuid(0, &eax, &ebx, &ecx, &edx);\r\nif (eax < 0xb) {\r\npr_info("UV: CPU does not have CPUID.11\n");\r\nreturn;\r\n}\r\ncpuid_count(0xb, SMT_LEVEL, &eax, &ebx, &ecx, &edx);\r\nif (ebx == 0 || (LEAFB_SUBTYPE(ecx) != SMT_TYPE)) {\r\npr_info("UV: CPUID.11 not implemented\n");\r\nreturn;\r\n}\r\nsid_shift = BITS_SHIFT_NEXT_LEVEL(eax);\r\nsub_index = 1;\r\ndo {\r\ncpuid_count(0xb, sub_index, &eax, &ebx, &ecx, &edx);\r\nif (LEAFB_SUBTYPE(ecx) == CORE_TYPE) {\r\nsid_shift = BITS_SHIFT_NEXT_LEVEL(eax);\r\nbreak;\r\n}\r\nsub_index++;\r\n} while (LEAFB_SUBTYPE(ecx) != INVALID_TYPE);\r\nuv_cpuid.apicid_shift = 0;\r\nuv_cpuid.apicid_mask = (~(-1 << sid_shift));\r\nuv_cpuid.socketid_shift = sid_shift;\r\n}\r\nstatic void __init early_get_apic_socketid_shift(void)\r\n{\r\nif (is_uv2_hub() || is_uv3_hub())\r\nuvh_apicid.v = uv_early_read_mmr(UVH_APICID);\r\nset_x2apic_bits();\r\npr_info("UV: apicid_shift:%d apicid_mask:0x%x\n", uv_cpuid.apicid_shift, uv_cpuid.apicid_mask);\r\npr_info("UV: socketid_shift:%d pnode_mask:0x%x\n", uv_cpuid.socketid_shift, uv_cpuid.pnode_mask);\r\n}\r\nstatic void __init uv_set_apicid_hibit(void)\r\n{\r\nunion uv1h_lb_target_physical_apic_id_mask_u apicid_mask;\r\nif (is_uv1_hub()) {\r\napicid_mask.v = uv_early_read_mmr(UV1H_LB_TARGET_PHYSICAL_APIC_ID_MASK);\r\nuv_apicid_hibits = apicid_mask.s1.bit_enables & UV_APICID_HIBIT_MASK;\r\n}\r\n}\r\nstatic int __init uv_acpi_madt_oem_check(char *oem_id, char *oem_table_id)\r\n{\r\nint pnodeid;\r\nint uv_apic;\r\nif (strncmp(oem_id, "SGI", 3) != 0) {\r\nif (strncmp(oem_id, "NSGI", 4) == 0) {\r\nuv_hubless_system = true;\r\npr_info("UV: OEM IDs %s/%s, HUBLESS\n",\r\noem_id, oem_table_id);\r\n}\r\nreturn 0;\r\n}\r\nif (numa_off) {\r\npr_err("UV: NUMA is off, disabling UV support\n");\r\nreturn 0;\r\n}\r\nuv_cpu_info->p_uv_hub_info = &uv_hub_info_node0;\r\nuv_hub_info->hub_revision =\r\n!strncmp(oem_id, "SGI4", 4) ? UV4_HUB_REVISION_BASE :\r\n!strncmp(oem_id, "SGI3", 4) ? UV3_HUB_REVISION_BASE :\r\n!strcmp(oem_id, "SGI2") ? UV2_HUB_REVISION_BASE :\r\n!strcmp(oem_id, "SGI") ? UV1_HUB_REVISION_BASE : 0;\r\nif (uv_hub_info->hub_revision == 0)\r\ngoto badbios;\r\npnodeid = early_get_pnodeid();\r\nearly_get_apic_socketid_shift();\r\nx86_platform.is_untracked_pat_range = uv_is_untracked_pat_range;\r\nx86_platform.nmi_init = uv_nmi_init;\r\nif (!strcmp(oem_table_id, "UVX")) {\r\nuv_system_type = UV_X2APIC;\r\nuv_apic = 0;\r\n} else if (!strcmp(oem_table_id, "UVH")) {\r\nuv_system_type = UV_NON_UNIQUE_APIC;\r\n__this_cpu_write(x2apic_extra_bits, pnodeid << uvh_apicid.s.pnode_shift);\r\nuv_set_apicid_hibit();\r\nuv_apic = 1;\r\n} else if (!strcmp(oem_table_id, "UVL")) {\r\nuv_system_type = UV_LEGACY_APIC;\r\nuv_apic = 0;\r\n} else {\r\ngoto badbios;\r\n}\r\npr_info("UV: OEM IDs %s/%s, System/HUB Types %d/%d, uv_apic %d\n", oem_id, oem_table_id, uv_system_type, uv_min_hub_revision_id, uv_apic);\r\nreturn uv_apic;\r\nbadbios:\r\npr_err("UV: OEM_ID:%s OEM_TABLE_ID:%s\n", oem_id, oem_table_id);\r\npr_err("Current BIOS not supported, update kernel and/or BIOS\n");\r\nBUG();\r\n}\r\nenum uv_system_type get_uv_system_type(void)\r\n{\r\nreturn uv_system_type;\r\n}\r\nint is_uv_system(void)\r\n{\r\nreturn uv_system_type != UV_NONE;\r\n}\r\nint is_uv_hubless(void)\r\n{\r\nreturn uv_hubless_system;\r\n}\r\nextern int uv_hub_info_version(void)\r\n{\r\nreturn UV_HUB_INFO_VERSION;\r\n}\r\nstatic __init void build_uv_gr_table(void)\r\n{\r\nstruct uv_gam_range_entry *gre = uv_gre_table;\r\nstruct uv_gam_range_s *grt;\r\nunsigned long last_limit = 0, ram_limit = 0;\r\nint bytes, i, sid, lsid = -1, indx = 0, lindx = -1;\r\nif (!gre)\r\nreturn;\r\nbytes = _gr_table_len * sizeof(struct uv_gam_range_s);\r\ngrt = kzalloc(bytes, GFP_KERNEL);\r\nBUG_ON(!grt);\r\n_gr_table = grt;\r\nfor (; gre->type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {\r\nif (gre->type == UV_GAM_RANGE_TYPE_HOLE) {\r\nif (!ram_limit) {\r\nram_limit = last_limit;\r\nlast_limit = gre->limit;\r\nlsid++;\r\ncontinue;\r\n}\r\nlast_limit = gre->limit;\r\npr_info("UV: extra hole in GAM RE table @%d\n", (int)(gre - uv_gre_table));\r\ncontinue;\r\n}\r\nif (_max_socket < gre->sockid) {\r\npr_err("UV: GAM table sockid(%d) too large(>%d) @%d\n", gre->sockid, _max_socket, (int)(gre - uv_gre_table));\r\ncontinue;\r\n}\r\nsid = gre->sockid - _min_socket;\r\nif (lsid < sid) {\r\ngrt = &_gr_table[indx];\r\ngrt->base = lindx;\r\ngrt->nasid = gre->nasid;\r\ngrt->limit = last_limit = gre->limit;\r\nlsid = sid;\r\nlindx = indx++;\r\ncontinue;\r\n}\r\nif (lsid == sid && !ram_limit) {\r\nif (grt->limit == last_limit) {\r\ngrt->limit = last_limit = gre->limit;\r\ncontinue;\r\n}\r\n}\r\nif (!ram_limit) {\r\ngrt++;\r\ngrt->base = lindx;\r\ngrt->nasid = gre->nasid;\r\ngrt->limit = last_limit = gre->limit;\r\ncontinue;\r\n}\r\ngrt++;\r\ngrt->base = grt - _gr_table;\r\ngrt->nasid = gre->nasid;\r\ngrt->limit = last_limit = gre->limit;\r\nlsid++;\r\n}\r\ngrt++;\r\ni = grt - _gr_table;\r\nif (i < _gr_table_len) {\r\nvoid *ret;\r\nbytes = i * sizeof(struct uv_gam_range_s);\r\nret = krealloc(_gr_table, bytes, GFP_KERNEL);\r\nif (ret) {\r\n_gr_table = ret;\r\n_gr_table_len = i;\r\n}\r\n}\r\nfor (i = 0, grt = _gr_table; i < _gr_table_len; i++, grt++) {\r\nunsigned long start, end;\r\nint gb = grt->base;\r\nstart = gb < 0 ? 0 : (unsigned long)_gr_table[gb].limit << UV_GAM_RANGE_SHFT;\r\nend = (unsigned long)grt->limit << UV_GAM_RANGE_SHFT;\r\npr_info("UV: GAM Range %2d %04x 0x%013lx-0x%013lx (%d)\n", i, grt->nasid, start, end, gb);\r\n}\r\n}\r\nstatic int uv_wakeup_secondary(int phys_apicid, unsigned long start_rip)\r\n{\r\nunsigned long val;\r\nint pnode;\r\npnode = uv_apicid_to_pnode(phys_apicid);\r\nphys_apicid |= uv_apicid_hibits;\r\nval = (1UL << UVH_IPI_INT_SEND_SHFT) |\r\n(phys_apicid << UVH_IPI_INT_APIC_ID_SHFT) |\r\n((start_rip << UVH_IPI_INT_VECTOR_SHFT) >> 12) |\r\nAPIC_DM_INIT;\r\nuv_write_global_mmr64(pnode, UVH_IPI_INT, val);\r\nval = (1UL << UVH_IPI_INT_SEND_SHFT) |\r\n(phys_apicid << UVH_IPI_INT_APIC_ID_SHFT) |\r\n((start_rip << UVH_IPI_INT_VECTOR_SHFT) >> 12) |\r\nAPIC_DM_STARTUP;\r\nuv_write_global_mmr64(pnode, UVH_IPI_INT, val);\r\nreturn 0;\r\n}\r\nstatic void uv_send_IPI_one(int cpu, int vector)\r\n{\r\nunsigned long apicid;\r\nint pnode;\r\napicid = per_cpu(x86_cpu_to_apicid, cpu);\r\npnode = uv_apicid_to_pnode(apicid);\r\nuv_hub_send_ipi(pnode, apicid, vector);\r\n}\r\nstatic void uv_send_IPI_mask(const struct cpumask *mask, int vector)\r\n{\r\nunsigned int cpu;\r\nfor_each_cpu(cpu, mask)\r\nuv_send_IPI_one(cpu, vector);\r\n}\r\nstatic void uv_send_IPI_mask_allbutself(const struct cpumask *mask, int vector)\r\n{\r\nunsigned int this_cpu = smp_processor_id();\r\nunsigned int cpu;\r\nfor_each_cpu(cpu, mask) {\r\nif (cpu != this_cpu)\r\nuv_send_IPI_one(cpu, vector);\r\n}\r\n}\r\nstatic void uv_send_IPI_allbutself(int vector)\r\n{\r\nunsigned int this_cpu = smp_processor_id();\r\nunsigned int cpu;\r\nfor_each_online_cpu(cpu) {\r\nif (cpu != this_cpu)\r\nuv_send_IPI_one(cpu, vector);\r\n}\r\n}\r\nstatic void uv_send_IPI_all(int vector)\r\n{\r\nuv_send_IPI_mask(cpu_online_mask, vector);\r\n}\r\nstatic int uv_apic_id_valid(int apicid)\r\n{\r\nreturn 1;\r\n}\r\nstatic int uv_apic_id_registered(void)\r\n{\r\nreturn 1;\r\n}\r\nstatic void uv_init_apic_ldr(void)\r\n{\r\n}\r\nstatic int\r\nuv_cpu_mask_to_apicid(const struct cpumask *mask, struct irq_data *irqdata,\r\nunsigned int *apicid)\r\n{\r\nint ret = default_cpu_mask_to_apicid(mask, irqdata, apicid);\r\nif (!ret)\r\n*apicid |= uv_apicid_hibits;\r\nreturn ret;\r\n}\r\nstatic unsigned int x2apic_get_apic_id(unsigned long x)\r\n{\r\nunsigned int id;\r\nWARN_ON(preemptible() && num_online_cpus() > 1);\r\nid = x | __this_cpu_read(x2apic_extra_bits);\r\nreturn id;\r\n}\r\nstatic unsigned long set_apic_id(unsigned int id)\r\n{\r\nreturn id;\r\n}\r\nstatic unsigned int uv_read_apic_id(void)\r\n{\r\nreturn x2apic_get_apic_id(apic_read(APIC_ID));\r\n}\r\nstatic int uv_phys_pkg_id(int initial_apicid, int index_msb)\r\n{\r\nreturn uv_read_apic_id() >> index_msb;\r\n}\r\nstatic void uv_send_IPI_self(int vector)\r\n{\r\napic_write(APIC_SELF_IPI, vector);\r\n}\r\nstatic int uv_probe(void)\r\n{\r\nreturn apic == &apic_x2apic_uv_x;\r\n}\r\nstatic void set_x2apic_extra_bits(int pnode)\r\n{\r\n__this_cpu_write(x2apic_extra_bits, pnode << uvh_apicid.s.pnode_shift);\r\n}\r\nstatic __init void get_lowmem_redirect(unsigned long *base, unsigned long *size)\r\n{\r\nunion uvh_rh_gam_alias210_overlay_config_2_mmr_u alias;\r\nunion uvh_rh_gam_alias210_redirect_config_2_mmr_u redirect;\r\nunsigned long m_redirect;\r\nunsigned long m_overlay;\r\nint i;\r\nfor (i = 0; i < UVH_RH_GAM_ALIAS210_REDIRECT_CONFIG_LENGTH; i++) {\r\nswitch (i) {\r\ncase 0:\r\nm_redirect = UVH_RH_GAM_ALIAS210_REDIRECT_CONFIG_0_MMR;\r\nm_overlay = UVH_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR;\r\nbreak;\r\ncase 1:\r\nm_redirect = UVH_RH_GAM_ALIAS210_REDIRECT_CONFIG_1_MMR;\r\nm_overlay = UVH_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR;\r\nbreak;\r\ncase 2:\r\nm_redirect = UVH_RH_GAM_ALIAS210_REDIRECT_CONFIG_2_MMR;\r\nm_overlay = UVH_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR;\r\nbreak;\r\n}\r\nalias.v = uv_read_local_mmr(m_overlay);\r\nif (alias.s.enable && alias.s.base == 0) {\r\n*size = (1UL << alias.s.m_alias);\r\nredirect.v = uv_read_local_mmr(m_redirect);\r\n*base = (unsigned long)redirect.s.dest_base << DEST_SHIFT;\r\nreturn;\r\n}\r\n}\r\n*base = *size = 0;\r\n}\r\nstatic __init void map_high(char *id, unsigned long base, int pshift, int bshift, int max_pnode, enum map_type map_type)\r\n{\r\nunsigned long bytes, paddr;\r\npaddr = base << pshift;\r\nbytes = (1UL << bshift) * (max_pnode + 1);\r\nif (!paddr) {\r\npr_info("UV: Map %s_HI base address NULL\n", id);\r\nreturn;\r\n}\r\npr_debug("UV: Map %s_HI 0x%lx - 0x%lx\n", id, paddr, paddr + bytes);\r\nif (map_type == map_uc)\r\ninit_extra_mapping_uc(paddr, bytes);\r\nelse\r\ninit_extra_mapping_wb(paddr, bytes);\r\n}\r\nstatic __init void map_gru_distributed(unsigned long c)\r\n{\r\nunion uvh_rh_gam_gru_overlay_config_mmr_u gru;\r\nu64 paddr;\r\nunsigned long bytes;\r\nint nid;\r\ngru.v = c;\r\ngru_dist_base = gru.v & 0x000007fff0000000UL;\r\nif (!gru_dist_base) {\r\npr_info("UV: Map GRU_DIST base address NULL\n");\r\nreturn;\r\n}\r\nbytes = 1UL << UVH_RH_GAM_GRU_OVERLAY_CONFIG_MMR_BASE_SHFT;\r\ngru_dist_lmask = ((1UL << uv_hub_info->m_val) - 1) & ~(bytes - 1);\r\ngru_dist_umask = ~((1UL << uv_hub_info->m_val) - 1);\r\ngru_dist_base &= gru_dist_lmask;\r\nfor_each_online_node(nid) {\r\npaddr = ((u64)uv_node_to_pnode(nid) << uv_hub_info->m_val) |\r\ngru_dist_base;\r\ninit_extra_mapping_wb(paddr, bytes);\r\ngru_first_node_paddr = min(paddr, gru_first_node_paddr);\r\ngru_last_node_paddr = max(paddr, gru_last_node_paddr);\r\n}\r\ngru_first_node_paddr &= gru_dist_umask;\r\ngru_last_node_paddr &= gru_dist_umask;\r\npr_debug("UV: Map GRU_DIST base 0x%016llx 0x%016llx - 0x%016llx\n", gru_dist_base, gru_first_node_paddr, gru_last_node_paddr);\r\n}\r\nstatic __init void map_gru_high(int max_pnode)\r\n{\r\nunion uvh_rh_gam_gru_overlay_config_mmr_u gru;\r\nint shift = UVH_RH_GAM_GRU_OVERLAY_CONFIG_MMR_BASE_SHFT;\r\nunsigned long mask = UVH_RH_GAM_GRU_OVERLAY_CONFIG_MMR_BASE_MASK;\r\nunsigned long base;\r\ngru.v = uv_read_local_mmr(UVH_RH_GAM_GRU_OVERLAY_CONFIG_MMR);\r\nif (!gru.s.enable) {\r\npr_info("UV: GRU disabled\n");\r\nreturn;\r\n}\r\nif (is_uv3_hub() && gru.s3.mode) {\r\nmap_gru_distributed(gru.v);\r\nreturn;\r\n}\r\nbase = (gru.v & mask) >> shift;\r\nmap_high("GRU", base, shift, shift, max_pnode, map_wb);\r\ngru_start_paddr = ((u64)base << shift);\r\ngru_end_paddr = gru_start_paddr + (1UL << shift) * (max_pnode + 1);\r\n}\r\nstatic __init void map_mmr_high(int max_pnode)\r\n{\r\nunion uvh_rh_gam_mmr_overlay_config_mmr_u mmr;\r\nint shift = UVH_RH_GAM_MMR_OVERLAY_CONFIG_MMR_BASE_SHFT;\r\nmmr.v = uv_read_local_mmr(UVH_RH_GAM_MMR_OVERLAY_CONFIG_MMR);\r\nif (mmr.s.enable)\r\nmap_high("MMR", mmr.s.base, shift, shift, max_pnode, map_uc);\r\nelse\r\npr_info("UV: MMR disabled\n");\r\n}\r\nstatic __init void map_mmioh_high_uv3(int index, int min_pnode, int max_pnode)\r\n{\r\nunion uv3h_rh_gam_mmioh_overlay_config0_mmr_u overlay;\r\nunsigned long mmr;\r\nunsigned long base;\r\nint i, n, shift, m_io, max_io;\r\nint nasid, lnasid, fi, li;\r\nchar *id;\r\nid = mmiohs[index].id;\r\noverlay.v = uv_read_local_mmr(mmiohs[index].overlay);\r\npr_info("UV: %s overlay 0x%lx base:0x%x m_io:%d\n", id, overlay.v, overlay.s3.base, overlay.s3.m_io);\r\nif (!overlay.s3.enable) {\r\npr_info("UV: %s disabled\n", id);\r\nreturn;\r\n}\r\nshift = UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_SHFT;\r\nbase = (unsigned long)overlay.s3.base;\r\nm_io = overlay.s3.m_io;\r\nmmr = mmiohs[index].redirect;\r\nn = UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH;\r\nmin_pnode *= 2;\r\nmax_pnode *= 2;\r\nmax_io = lnasid = fi = li = -1;\r\nfor (i = 0; i < n; i++) {\r\nunion uv3h_rh_gam_mmioh_redirect_config0_mmr_u redirect;\r\nredirect.v = uv_read_local_mmr(mmr + i * 8);\r\nnasid = redirect.s3.nasid;\r\nif (nasid < min_pnode || max_pnode < nasid)\r\nnasid = -1;\r\nif (nasid == lnasid) {\r\nli = i;\r\nif (i != n-1)\r\ncontinue;\r\n}\r\nif (lnasid != -1 || (i == n-1 && nasid != -1)) {\r\nunsigned long addr1, addr2;\r\nint f, l;\r\nif (lnasid == -1) {\r\nf = l = i;\r\nlnasid = nasid;\r\n} else {\r\nf = fi;\r\nl = li;\r\n}\r\naddr1 = (base << shift) + f * (1ULL << m_io);\r\naddr2 = (base << shift) + (l + 1) * (1ULL << m_io);\r\npr_info("UV: %s[%03d..%03d] NASID 0x%04x ADDR 0x%016lx - 0x%016lx\n", id, fi, li, lnasid, addr1, addr2);\r\nif (max_io < l)\r\nmax_io = l;\r\n}\r\nfi = li = i;\r\nlnasid = nasid;\r\n}\r\npr_info("UV: %s base:0x%lx shift:%d M_IO:%d MAX_IO:%d\n", id, base, shift, m_io, max_io);\r\nif (max_io >= 0)\r\nmap_high(id, base, shift, m_io, max_io, map_uc);\r\n}\r\nstatic __init void map_mmioh_high(int min_pnode, int max_pnode)\r\n{\r\nunion uvh_rh_gam_mmioh_overlay_config_mmr_u mmioh;\r\nunsigned long mmr, base;\r\nint shift, enable, m_io, n_io;\r\nif (is_uv3_hub() || is_uv4_hub()) {\r\nmap_mmioh_high_uv3(0, min_pnode, max_pnode);\r\nmap_mmioh_high_uv3(1, min_pnode, max_pnode);\r\nreturn;\r\n}\r\nif (is_uv1_hub()) {\r\nmmr = UV1H_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR;\r\nshift = UV1H_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR_BASE_SHFT;\r\nmmioh.v = uv_read_local_mmr(mmr);\r\nenable = !!mmioh.s1.enable;\r\nbase = mmioh.s1.base;\r\nm_io = mmioh.s1.m_io;\r\nn_io = mmioh.s1.n_io;\r\n} else if (is_uv2_hub()) {\r\nmmr = UV2H_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR;\r\nshift = UV2H_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR_BASE_SHFT;\r\nmmioh.v = uv_read_local_mmr(mmr);\r\nenable = !!mmioh.s2.enable;\r\nbase = mmioh.s2.base;\r\nm_io = mmioh.s2.m_io;\r\nn_io = mmioh.s2.n_io;\r\n} else {\r\nreturn;\r\n}\r\nif (enable) {\r\nmax_pnode &= (1 << n_io) - 1;\r\npr_info("UV: base:0x%lx shift:%d N_IO:%d M_IO:%d max_pnode:0x%x\n", base, shift, m_io, n_io, max_pnode);\r\nmap_high("MMIOH", base, shift, m_io, max_pnode, map_uc);\r\n} else {\r\npr_info("UV: MMIOH disabled\n");\r\n}\r\n}\r\nstatic __init void map_low_mmrs(void)\r\n{\r\ninit_extra_mapping_uc(UV_GLOBAL_MMR32_BASE, UV_GLOBAL_MMR32_SIZE);\r\ninit_extra_mapping_uc(UV_LOCAL_MMR_BASE, UV_LOCAL_MMR_SIZE);\r\n}\r\nstatic __init void uv_rtc_init(void)\r\n{\r\nlong status;\r\nu64 ticks_per_sec;\r\nstatus = uv_bios_freq_base(BIOS_FREQ_BASE_REALTIME_CLOCK, &ticks_per_sec);\r\nif (status != BIOS_STATUS_SUCCESS || ticks_per_sec < 100000) {\r\npr_warn("UV: unable to determine platform RTC clock frequency, guessing.\n");\r\nsn_rtc_cycles_per_second = 1000000000000UL / 30000UL;\r\n} else {\r\nsn_rtc_cycles_per_second = ticks_per_sec;\r\n}\r\n}\r\nstatic void uv_heartbeat(unsigned long ignored)\r\n{\r\nstruct timer_list *timer = &uv_scir_info->timer;\r\nunsigned char bits = uv_scir_info->state;\r\nbits ^= SCIR_CPU_HEARTBEAT;\r\nif (idle_cpu(raw_smp_processor_id()))\r\nbits &= ~SCIR_CPU_ACTIVITY;\r\nelse\r\nbits |= SCIR_CPU_ACTIVITY;\r\nuv_set_scir_bits(bits);\r\nmod_timer(timer, jiffies + SCIR_CPU_HB_INTERVAL);\r\n}\r\nstatic int uv_heartbeat_enable(unsigned int cpu)\r\n{\r\nwhile (!uv_cpu_scir_info(cpu)->enabled) {\r\nstruct timer_list *timer = &uv_cpu_scir_info(cpu)->timer;\r\nuv_set_cpu_scir_bits(cpu, SCIR_CPU_HEARTBEAT|SCIR_CPU_ACTIVITY);\r\nsetup_pinned_timer(timer, uv_heartbeat, cpu);\r\ntimer->expires = jiffies + SCIR_CPU_HB_INTERVAL;\r\nadd_timer_on(timer, cpu);\r\nuv_cpu_scir_info(cpu)->enabled = 1;\r\ncpu = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uv_heartbeat_disable(unsigned int cpu)\r\n{\r\nif (uv_cpu_scir_info(cpu)->enabled) {\r\nuv_cpu_scir_info(cpu)->enabled = 0;\r\ndel_timer(&uv_cpu_scir_info(cpu)->timer);\r\n}\r\nuv_set_cpu_scir_bits(cpu, 0xff);\r\nreturn 0;\r\n}\r\nstatic __init void uv_scir_register_cpu_notifier(void)\r\n{\r\ncpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN, "x86/x2apic-uvx:online",\r\nuv_heartbeat_enable, uv_heartbeat_disable);\r\n}\r\nstatic __init void uv_scir_register_cpu_notifier(void)\r\n{\r\n}\r\nstatic __init int uv_init_heartbeat(void)\r\n{\r\nint cpu;\r\nif (is_uv_system()) {\r\nfor_each_online_cpu(cpu)\r\nuv_heartbeat_enable(cpu);\r\n}\r\nreturn 0;\r\n}\r\nint uv_set_vga_state(struct pci_dev *pdev, bool decode, unsigned int command_bits, u32 flags)\r\n{\r\nint domain, bus, rc;\r\nif (!(flags & PCI_VGA_STATE_CHANGE_BRIDGE))\r\nreturn 0;\r\nif ((command_bits & PCI_COMMAND_IO) == 0)\r\nreturn 0;\r\ndomain = pci_domain_nr(pdev->bus);\r\nbus = pdev->bus->number;\r\nrc = uv_bios_set_legacy_vga_target(decode, domain, bus);\r\nreturn rc;\r\n}\r\nvoid uv_cpu_init(void)\r\n{\r\nif (smp_processor_id() == 0)\r\nreturn;\r\nuv_hub_info->nr_online_cpus++;\r\nif (get_uv_system_type() == UV_NON_UNIQUE_APIC)\r\nset_x2apic_extra_bits(uv_hub_info->pnode);\r\n}\r\nstatic void get_mn(struct mn *mnp)\r\n{\r\nunion uvh_rh_gam_config_mmr_u m_n_config;\r\nunion uv3h_gr0_gam_gr_config_u m_gr_config;\r\nmemset(mnp, 0, sizeof(*mnp));\r\nm_n_config.v = uv_read_local_mmr(UVH_RH_GAM_CONFIG_MMR);\r\nmnp->n_val = m_n_config.s.n_skt;\r\nif (is_uv4_hub()) {\r\nmnp->m_val = 0;\r\nmnp->n_lshift = 0;\r\n} else if (is_uv3_hub()) {\r\nmnp->m_val = m_n_config.s3.m_skt;\r\nm_gr_config.v = uv_read_local_mmr(UV3H_GR0_GAM_GR_CONFIG);\r\nmnp->n_lshift = m_gr_config.s3.m_skt;\r\n} else if (is_uv2_hub()) {\r\nmnp->m_val = m_n_config.s2.m_skt;\r\nmnp->n_lshift = mnp->m_val == 40 ? 40 : 39;\r\n} else if (is_uv1_hub()) {\r\nmnp->m_val = m_n_config.s1.m_skt;\r\nmnp->n_lshift = mnp->m_val;\r\n}\r\nmnp->m_shift = mnp->m_val ? 64 - mnp->m_val : 0;\r\n}\r\nvoid __init uv_init_hub_info(struct uv_hub_info_s *hi)\r\n{\r\nunion uvh_node_id_u node_id;\r\nstruct mn mn;\r\nget_mn(&mn);\r\nhi->gpa_mask = mn.m_val ?\r\n(1UL << (mn.m_val + mn.n_val)) - 1 :\r\n(1UL << uv_cpuid.gpa_shift) - 1;\r\nhi->m_val = mn.m_val;\r\nhi->n_val = mn.n_val;\r\nhi->m_shift = mn.m_shift;\r\nhi->n_lshift = mn.n_lshift ? mn.n_lshift : 0;\r\nhi->hub_revision = uv_hub_info->hub_revision;\r\nhi->pnode_mask = uv_cpuid.pnode_mask;\r\nhi->min_pnode = _min_pnode;\r\nhi->min_socket = _min_socket;\r\nhi->pnode_to_socket = _pnode_to_socket;\r\nhi->socket_to_node = _socket_to_node;\r\nhi->socket_to_pnode = _socket_to_pnode;\r\nhi->gr_table_len = _gr_table_len;\r\nhi->gr_table = _gr_table;\r\nnode_id.v = uv_read_local_mmr(UVH_NODE_ID);\r\nuv_cpuid.gnode_shift = max_t(unsigned int, uv_cpuid.gnode_shift, mn.n_val);\r\nhi->gnode_extra = (node_id.s.node_id & ~((1 << uv_cpuid.gnode_shift) - 1)) >> 1;\r\nif (mn.m_val)\r\nhi->gnode_upper = (u64)hi->gnode_extra << mn.m_val;\r\nif (uv_gp_table) {\r\nhi->global_mmr_base = uv_gp_table->mmr_base;\r\nhi->global_mmr_shift = uv_gp_table->mmr_shift;\r\nhi->global_gru_base = uv_gp_table->gru_base;\r\nhi->global_gru_shift = uv_gp_table->gru_shift;\r\nhi->gpa_shift = uv_gp_table->gpa_shift;\r\nhi->gpa_mask = (1UL << hi->gpa_shift) - 1;\r\n} else {\r\nhi->global_mmr_base = uv_read_local_mmr(UVH_RH_GAM_MMR_OVERLAY_CONFIG_MMR) & ~UV_MMR_ENABLE;\r\nhi->global_mmr_shift = _UV_GLOBAL_MMR64_PNODE_SHIFT;\r\n}\r\nget_lowmem_redirect(&hi->lowmem_remap_base, &hi->lowmem_remap_top);\r\nhi->apic_pnode_shift = uv_cpuid.socketid_shift;\r\npr_info("UV: N:%d M:%d m_shift:%d n_lshift:%d\n", hi->n_val, hi->m_val, hi->m_shift, hi->n_lshift);\r\npr_info("UV: gpa_mask/shift:0x%lx/%d pnode_mask:0x%x apic_pns:%d\n", hi->gpa_mask, hi->gpa_shift, hi->pnode_mask, hi->apic_pnode_shift);\r\npr_info("UV: mmr_base/shift:0x%lx/%ld gru_base/shift:0x%lx/%ld\n", hi->global_mmr_base, hi->global_mmr_shift, hi->global_gru_base, hi->global_gru_shift);\r\npr_info("UV: gnode_upper:0x%lx gnode_extra:0x%x\n", hi->gnode_upper, hi->gnode_extra);\r\n}\r\nstatic void __init decode_gam_params(unsigned long ptr)\r\n{\r\nuv_gp_table = (struct uv_gam_parameters *)ptr;\r\npr_info("UV: GAM Params...\n");\r\npr_info("UV: mmr_base/shift:0x%llx/%d gru_base/shift:0x%llx/%d gpa_shift:%d\n",\r\nuv_gp_table->mmr_base, uv_gp_table->mmr_shift,\r\nuv_gp_table->gru_base, uv_gp_table->gru_shift,\r\nuv_gp_table->gpa_shift);\r\n}\r\nstatic void __init decode_gam_rng_tbl(unsigned long ptr)\r\n{\r\nstruct uv_gam_range_entry *gre = (struct uv_gam_range_entry *)ptr;\r\nunsigned long lgre = 0;\r\nint index = 0;\r\nint sock_min = 999999, pnode_min = 99999;\r\nint sock_max = -1, pnode_max = -1;\r\nuv_gre_table = gre;\r\nfor (; gre->type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {\r\nif (!index) {\r\npr_info("UV: GAM Range Table...\n");\r\npr_info("UV: # %20s %14s %5s %4s %5s %3s %2s\n", "Range", "", "Size", "Type", "NASID", "SID", "PN");\r\n}\r\npr_info("UV: %2d: 0x%014lx-0x%014lx %5luG %3d %04x %02x %02x\n",\r\nindex++,\r\n(unsigned long)lgre << UV_GAM_RANGE_SHFT,\r\n(unsigned long)gre->limit << UV_GAM_RANGE_SHFT,\r\n((unsigned long)(gre->limit - lgre)) >>\r\n(30 - UV_GAM_RANGE_SHFT),\r\ngre->type, gre->nasid, gre->sockid, gre->pnode);\r\nlgre = gre->limit;\r\nif (sock_min > gre->sockid)\r\nsock_min = gre->sockid;\r\nif (sock_max < gre->sockid)\r\nsock_max = gre->sockid;\r\nif (pnode_min > gre->pnode)\r\npnode_min = gre->pnode;\r\nif (pnode_max < gre->pnode)\r\npnode_max = gre->pnode;\r\n}\r\n_min_socket = sock_min;\r\n_max_socket = sock_max;\r\n_min_pnode = pnode_min;\r\n_max_pnode = pnode_max;\r\n_gr_table_len = index;\r\npr_info("UV: GRT: %d entries, sockets(min:%x,max:%x) pnodes(min:%x,max:%x)\n", index, _min_socket, _max_socket, _min_pnode, _max_pnode);\r\n}\r\nstatic int __init decode_uv_systab(void)\r\n{\r\nstruct uv_systab *st;\r\nint i;\r\nif (uv_hub_info->hub_revision < UV4_HUB_REVISION_BASE)\r\nreturn 0;\r\nst = uv_systab;\r\nif ((!st) || (st->revision < UV_SYSTAB_VERSION_UV4_LATEST)) {\r\nint rev = st ? st->revision : 0;\r\npr_err("UV: BIOS UVsystab version(%x) mismatch, expecting(%x)\n", rev, UV_SYSTAB_VERSION_UV4_LATEST);\r\npr_err("UV: Cannot support UV operations, switching to generic PC\n");\r\nuv_system_type = UV_NONE;\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; st->entry[i].type != UV_SYSTAB_TYPE_UNUSED; i++) {\r\nunsigned long ptr = st->entry[i].offset;\r\nif (!ptr)\r\ncontinue;\r\nptr = ptr + (unsigned long)st;\r\nswitch (st->entry[i].type) {\r\ncase UV_SYSTAB_TYPE_GAM_PARAMS:\r\ndecode_gam_params(ptr);\r\nbreak;\r\ncase UV_SYSTAB_TYPE_GAM_RNG_TBL:\r\ndecode_gam_rng_tbl(ptr);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic __init void boot_init_possible_blades(struct uv_hub_info_s *hub_info)\r\n{\r\nint i, uv_pb = 0;\r\npr_info("UV: NODE_PRESENT_DEPTH = %d\n", UVH_NODE_PRESENT_TABLE_DEPTH);\r\nfor (i = 0; i < UVH_NODE_PRESENT_TABLE_DEPTH; i++) {\r\nunsigned long np;\r\nnp = uv_read_local_mmr(UVH_NODE_PRESENT_TABLE + i * 8);\r\nif (np)\r\npr_info("UV: NODE_PRESENT(%d) = 0x%016lx\n", i, np);\r\nuv_pb += hweight64(np);\r\n}\r\nif (uv_possible_blades != uv_pb)\r\nuv_possible_blades = uv_pb;\r\n}\r\nstatic void __init build_socket_tables(void)\r\n{\r\nstruct uv_gam_range_entry *gre = uv_gre_table;\r\nint num, nump;\r\nint cpu, i, lnid;\r\nint minsock = _min_socket;\r\nint maxsock = _max_socket;\r\nint minpnode = _min_pnode;\r\nint maxpnode = _max_pnode;\r\nsize_t bytes;\r\nif (!gre) {\r\nif (is_uv1_hub() || is_uv2_hub() || is_uv3_hub()) {\r\npr_info("UV: No UVsystab socket table, ignoring\n");\r\nreturn;\r\n}\r\npr_crit("UV: Error: UVsystab address translations not available!\n");\r\nBUG();\r\n}\r\nnum = maxsock - minsock + 1;\r\nbytes = num * sizeof(_socket_to_node[0]);\r\n_socket_to_node = kmalloc(bytes, GFP_KERNEL);\r\n_socket_to_pnode = kmalloc(bytes, GFP_KERNEL);\r\nnump = maxpnode - minpnode + 1;\r\nbytes = nump * sizeof(_pnode_to_socket[0]);\r\n_pnode_to_socket = kmalloc(bytes, GFP_KERNEL);\r\nBUG_ON(!_socket_to_node || !_socket_to_pnode || !_pnode_to_socket);\r\nfor (i = 0; i < num; i++)\r\n_socket_to_node[i] = _socket_to_pnode[i] = SOCK_EMPTY;\r\nfor (i = 0; i < nump; i++)\r\n_pnode_to_socket[i] = SOCK_EMPTY;\r\npr_info("UV: GAM Building socket/pnode conversion tables\n");\r\nfor (; gre->type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {\r\nif (gre->type == UV_GAM_RANGE_TYPE_HOLE)\r\ncontinue;\r\ni = gre->sockid - minsock;\r\nif (_socket_to_pnode[i] != SOCK_EMPTY)\r\ncontinue;\r\n_socket_to_pnode[i] = gre->pnode;\r\ni = gre->pnode - minpnode;\r\n_pnode_to_socket[i] = gre->sockid;\r\npr_info("UV: sid:%02x type:%d nasid:%04x pn:%02x pn2s:%2x\n",\r\ngre->sockid, gre->type, gre->nasid,\r\n_socket_to_pnode[gre->sockid - minsock],\r\n_pnode_to_socket[gre->pnode - minpnode]);\r\n}\r\nlnid = -1;\r\nfor_each_present_cpu(cpu) {\r\nint nid = cpu_to_node(cpu);\r\nint apicid, sockid;\r\nif (lnid == nid)\r\ncontinue;\r\nlnid = nid;\r\napicid = per_cpu(x86_cpu_to_apicid, cpu);\r\nsockid = apicid >> uv_cpuid.socketid_shift;\r\n_socket_to_node[sockid - minsock] = nid;\r\npr_info("UV: sid:%02x: apicid:%04x node:%2d\n",\r\nsockid, apicid, nid);\r\n}\r\nbytes = num_possible_nodes() * sizeof(_node_to_pnode[0]);\r\n_node_to_pnode = kmalloc(bytes, GFP_KERNEL);\r\nBUG_ON(!_node_to_pnode);\r\nfor (lnid = 0; lnid < num_possible_nodes(); lnid++) {\r\nunsigned short sockid;\r\nfor (sockid = minsock; sockid <= maxsock; sockid++) {\r\nif (lnid == _socket_to_node[sockid - minsock]) {\r\n_node_to_pnode[lnid] = _socket_to_pnode[sockid - minsock];\r\nbreak;\r\n}\r\n}\r\nif (sockid > maxsock) {\r\npr_err("UV: socket for node %d not found!\n", lnid);\r\nBUG();\r\n}\r\n}\r\npr_info("UV: Checking socket->node/pnode for identity maps\n");\r\nif (minsock == 0) {\r\nfor (i = 0; i < num; i++)\r\nif (_socket_to_node[i] == SOCK_EMPTY || i != _socket_to_node[i])\r\nbreak;\r\nif (i >= num) {\r\nkfree(_socket_to_node);\r\n_socket_to_node = NULL;\r\npr_info("UV: 1:1 socket_to_node table removed\n");\r\n}\r\n}\r\nif (minsock == minpnode) {\r\nfor (i = 0; i < num; i++)\r\nif (_socket_to_pnode[i] != SOCK_EMPTY &&\r\n_socket_to_pnode[i] != i + minpnode)\r\nbreak;\r\nif (i >= num) {\r\nkfree(_socket_to_pnode);\r\n_socket_to_pnode = NULL;\r\npr_info("UV: 1:1 socket_to_pnode table removed\n");\r\n}\r\n}\r\n}\r\nstatic void __init uv_system_init_hub(void)\r\n{\r\nstruct uv_hub_info_s hub_info = {0};\r\nint bytes, cpu, nodeid;\r\nunsigned short min_pnode = 9999, max_pnode = 0;\r\nchar *hub = is_uv4_hub() ? "UV400" :\r\nis_uv3_hub() ? "UV300" :\r\nis_uv2_hub() ? "UV2000/3000" :\r\nis_uv1_hub() ? "UV100/1000" : NULL;\r\nif (!hub) {\r\npr_err("UV: Unknown/unsupported UV hub\n");\r\nreturn;\r\n}\r\npr_info("UV: Found %s hub\n", hub);\r\nmap_low_mmrs();\r\nuv_bios_init();\r\nif (decode_uv_systab() < 0)\r\nreturn;\r\nbuild_socket_tables();\r\nbuild_uv_gr_table();\r\nuv_init_hub_info(&hub_info);\r\nuv_possible_blades = num_possible_nodes();\r\nif (!_node_to_pnode)\r\nboot_init_possible_blades(&hub_info);\r\npr_info("UV: Found %d hubs, %d nodes, %d CPUs\n", uv_num_possible_blades(), num_possible_nodes(), num_possible_cpus());\r\nuv_bios_get_sn_info(0, &uv_type, &sn_partition_id, &sn_coherency_id, &sn_region_size, &system_serial_number);\r\nhub_info.coherency_domain_number = sn_coherency_id;\r\nuv_rtc_init();\r\nbytes = sizeof(void *) * uv_num_possible_blades();\r\n__uv_hub_info_list = kzalloc(bytes, GFP_KERNEL);\r\nBUG_ON(!__uv_hub_info_list);\r\nbytes = sizeof(struct uv_hub_info_s);\r\nfor_each_node(nodeid) {\r\nstruct uv_hub_info_s *new_hub;\r\nif (__uv_hub_info_list[nodeid]) {\r\npr_err("UV: Node %d UV HUB already initialized!?\n", nodeid);\r\nBUG();\r\n}\r\nnew_hub = (nodeid == 0) ? &uv_hub_info_node0 : kzalloc_node(bytes, GFP_KERNEL, nodeid);\r\nBUG_ON(!new_hub);\r\n__uv_hub_info_list[nodeid] = new_hub;\r\nnew_hub = uv_hub_info_list(nodeid);\r\nBUG_ON(!new_hub);\r\n*new_hub = hub_info;\r\nif (_node_to_pnode)\r\nnew_hub->pnode = _node_to_pnode[nodeid];\r\nelse\r\nnew_hub->pnode = 0xffff;\r\nnew_hub->numa_blade_id = uv_node_to_blade_id(nodeid);\r\nnew_hub->memory_nid = -1;\r\nnew_hub->nr_possible_cpus = 0;\r\nnew_hub->nr_online_cpus = 0;\r\n}\r\nfor_each_possible_cpu(cpu) {\r\nint apicid = per_cpu(x86_cpu_to_apicid, cpu);\r\nint numa_node_id;\r\nunsigned short pnode;\r\nnodeid = cpu_to_node(cpu);\r\nnuma_node_id = numa_cpu_node(cpu);\r\npnode = uv_apicid_to_pnode(apicid);\r\nuv_cpu_info_per(cpu)->p_uv_hub_info = uv_hub_info_list(nodeid);\r\nuv_cpu_info_per(cpu)->blade_cpu_id = uv_cpu_hub_info(cpu)->nr_possible_cpus++;\r\nif (uv_cpu_hub_info(cpu)->memory_nid == -1)\r\nuv_cpu_hub_info(cpu)->memory_nid = cpu_to_node(cpu);\r\nif (nodeid != numa_node_id &&\r\nuv_hub_info_list(numa_node_id)->pnode == 0xffff)\r\nuv_hub_info_list(numa_node_id)->pnode = pnode;\r\nelse if (uv_cpu_hub_info(cpu)->pnode == 0xffff)\r\nuv_cpu_hub_info(cpu)->pnode = pnode;\r\nuv_cpu_scir_info(cpu)->offset = uv_scir_offset(apicid);\r\n}\r\nfor_each_node(nodeid) {\r\nunsigned short pnode = uv_hub_info_list(nodeid)->pnode;\r\nif (pnode == 0xffff) {\r\nunsigned long paddr;\r\npaddr = node_start_pfn(nodeid) << PAGE_SHIFT;\r\npnode = uv_gpa_to_pnode(uv_soc_phys_ram_to_gpa(paddr));\r\nuv_hub_info_list(nodeid)->pnode = pnode;\r\n}\r\nmin_pnode = min(pnode, min_pnode);\r\nmax_pnode = max(pnode, max_pnode);\r\npr_info("UV: UVHUB node:%2d pn:%02x nrcpus:%d\n",\r\nnodeid,\r\nuv_hub_info_list(nodeid)->pnode,\r\nuv_hub_info_list(nodeid)->nr_possible_cpus);\r\n}\r\npr_info("UV: min_pnode:%02x max_pnode:%02x\n", min_pnode, max_pnode);\r\nmap_gru_high(max_pnode);\r\nmap_mmr_high(max_pnode);\r\nmap_mmioh_high(min_pnode, max_pnode);\r\nuv_nmi_setup();\r\nuv_cpu_init();\r\nuv_scir_register_cpu_notifier();\r\nproc_mkdir("sgi_uv", NULL);\r\npci_register_set_vga_state(uv_set_vga_state);\r\nif (is_kdump_kernel())\r\nreboot_type = BOOT_ACPI;\r\n}\r\nvoid __init uv_system_init(void)\r\n{\r\nif (likely(!is_uv_system() && !is_uv_hubless()))\r\nreturn;\r\nif (is_uv_system())\r\nuv_system_init_hub();\r\nelse\r\nuv_nmi_setup_hubless();\r\n}
