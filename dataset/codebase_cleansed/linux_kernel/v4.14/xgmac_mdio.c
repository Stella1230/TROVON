static u32 xgmac_read32(void __iomem *regs,\r\nbool is_little_endian)\r\n{\r\nif (is_little_endian)\r\nreturn ioread32(regs);\r\nelse\r\nreturn ioread32be(regs);\r\n}\r\nstatic void xgmac_write32(u32 value,\r\nvoid __iomem *regs,\r\nbool is_little_endian)\r\n{\r\nif (is_little_endian)\r\niowrite32(value, regs);\r\nelse\r\niowrite32be(value, regs);\r\n}\r\nstatic int xgmac_wait_until_free(struct device *dev,\r\nstruct tgec_mdio_controller __iomem *regs,\r\nbool is_little_endian)\r\n{\r\nunsigned int timeout;\r\ntimeout = TIMEOUT;\r\nwhile ((xgmac_read32(&regs->mdio_stat, is_little_endian) &\r\nMDIO_STAT_BSY) && timeout) {\r\ncpu_relax();\r\ntimeout--;\r\n}\r\nif (!timeout) {\r\ndev_err(dev, "timeout waiting for bus to be free\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgmac_wait_until_done(struct device *dev,\r\nstruct tgec_mdio_controller __iomem *regs,\r\nbool is_little_endian)\r\n{\r\nunsigned int timeout;\r\ntimeout = TIMEOUT;\r\nwhile ((xgmac_read32(&regs->mdio_stat, is_little_endian) &\r\nMDIO_STAT_BSY) && timeout) {\r\ncpu_relax();\r\ntimeout--;\r\n}\r\nif (!timeout) {\r\ndev_err(dev, "timeout waiting for operation to complete\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgmac_mdio_write(struct mii_bus *bus, int phy_id, int regnum, u16 value)\r\n{\r\nstruct mdio_fsl_priv *priv = (struct mdio_fsl_priv *)bus->priv;\r\nstruct tgec_mdio_controller __iomem *regs = priv->mdio_base;\r\nuint16_t dev_addr;\r\nu32 mdio_ctl, mdio_stat;\r\nint ret;\r\nbool endian = priv->is_little_endian;\r\nmdio_stat = xgmac_read32(&regs->mdio_stat, endian);\r\nif (regnum & MII_ADDR_C45) {\r\ndev_addr = (regnum >> 16) & 0x1f;\r\nmdio_stat |= MDIO_STAT_ENC;\r\n} else {\r\ndev_addr = regnum & 0x1f;\r\nmdio_stat &= ~MDIO_STAT_ENC;\r\n}\r\nxgmac_write32(mdio_stat, &regs->mdio_stat, endian);\r\nret = xgmac_wait_until_free(&bus->dev, regs, endian);\r\nif (ret)\r\nreturn ret;\r\nmdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);\r\nxgmac_write32(mdio_ctl, &regs->mdio_ctl, endian);\r\nif (regnum & MII_ADDR_C45) {\r\nxgmac_write32(regnum & 0xffff, &regs->mdio_addr, endian);\r\nret = xgmac_wait_until_free(&bus->dev, regs, endian);\r\nif (ret)\r\nreturn ret;\r\n}\r\nxgmac_write32(MDIO_DATA(value), &regs->mdio_data, endian);\r\nret = xgmac_wait_until_done(&bus->dev, regs, endian);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int xgmac_mdio_read(struct mii_bus *bus, int phy_id, int regnum)\r\n{\r\nstruct mdio_fsl_priv *priv = (struct mdio_fsl_priv *)bus->priv;\r\nstruct tgec_mdio_controller __iomem *regs = priv->mdio_base;\r\nuint16_t dev_addr;\r\nuint32_t mdio_stat;\r\nuint32_t mdio_ctl;\r\nuint16_t value;\r\nint ret;\r\nbool endian = priv->is_little_endian;\r\nmdio_stat = xgmac_read32(&regs->mdio_stat, endian);\r\nif (regnum & MII_ADDR_C45) {\r\ndev_addr = (regnum >> 16) & 0x1f;\r\nmdio_stat |= MDIO_STAT_ENC;\r\n} else {\r\ndev_addr = regnum & 0x1f;\r\nmdio_stat &= ~MDIO_STAT_ENC;\r\n}\r\nxgmac_write32(mdio_stat, &regs->mdio_stat, endian);\r\nret = xgmac_wait_until_free(&bus->dev, regs, endian);\r\nif (ret)\r\nreturn ret;\r\nmdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);\r\nxgmac_write32(mdio_ctl, &regs->mdio_ctl, endian);\r\nif (regnum & MII_ADDR_C45) {\r\nxgmac_write32(regnum & 0xffff, &regs->mdio_addr, endian);\r\nret = xgmac_wait_until_free(&bus->dev, regs, endian);\r\nif (ret)\r\nreturn ret;\r\n}\r\nxgmac_write32(mdio_ctl | MDIO_CTL_READ, &regs->mdio_ctl, endian);\r\nret = xgmac_wait_until_done(&bus->dev, regs, endian);\r\nif (ret)\r\nreturn ret;\r\nif (xgmac_read32(&regs->mdio_stat, endian) & MDIO_STAT_RD_ER) {\r\ndev_err(&bus->dev,\r\n"Error while reading PHY%d reg at %d.%hhu\n",\r\nphy_id, dev_addr, regnum);\r\nreturn 0xffff;\r\n}\r\nvalue = xgmac_read32(&regs->mdio_data, endian) & 0xffff;\r\ndev_dbg(&bus->dev, "read %04x\n", value);\r\nreturn value;\r\n}\r\nstatic int xgmac_mdio_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct mii_bus *bus;\r\nstruct resource res;\r\nstruct mdio_fsl_priv *priv;\r\nint ret;\r\nret = of_address_to_resource(np, 0, &res);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not obtain address\n");\r\nreturn ret;\r\n}\r\nbus = mdiobus_alloc_size(sizeof(struct mdio_fsl_priv));\r\nif (!bus)\r\nreturn -ENOMEM;\r\nbus->name = "Freescale XGMAC MDIO Bus";\r\nbus->read = xgmac_mdio_read;\r\nbus->write = xgmac_mdio_write;\r\nbus->parent = &pdev->dev;\r\nsnprintf(bus->id, MII_BUS_ID_SIZE, "%llx", (unsigned long long)res.start);\r\npriv = bus->priv;\r\npriv->mdio_base = of_iomap(np, 0);\r\nif (!priv->mdio_base) {\r\nret = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\npriv->is_little_endian = of_property_read_bool(pdev->dev.of_node,\r\n"little-endian");\r\nret = of_mdiobus_register(bus, np);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot register MDIO bus\n");\r\ngoto err_registration;\r\n}\r\nplatform_set_drvdata(pdev, bus);\r\nreturn 0;\r\nerr_registration:\r\niounmap(priv->mdio_base);\r\nerr_ioremap:\r\nmdiobus_free(bus);\r\nreturn ret;\r\n}\r\nstatic int xgmac_mdio_remove(struct platform_device *pdev)\r\n{\r\nstruct mii_bus *bus = platform_get_drvdata(pdev);\r\nmdiobus_unregister(bus);\r\niounmap(bus->priv);\r\nmdiobus_free(bus);\r\nreturn 0;\r\n}
