static bool ebt_mac_wormhash_contains(const struct ebt_mac_wormhash *wh,\r\nconst char *mac, __be32 ip)\r\n{\r\nconst struct ebt_mac_wormhash_tuple *p;\r\nint start, limit, i;\r\nuint32_t cmp[2] = { 0, 0 };\r\nint key = ((const unsigned char *)mac)[5];\r\nether_addr_copy(((char *) cmp) + 2, mac);\r\nstart = wh->table[key];\r\nlimit = wh->table[key + 1];\r\nif (ip) {\r\nfor (i = start; i < limit; i++) {\r\np = &wh->pool[i];\r\nif (cmp[1] == p->cmp[1] && cmp[0] == p->cmp[0])\r\nif (p->ip == 0 || p->ip == ip)\r\nreturn true;\r\n}\r\n} else {\r\nfor (i = start; i < limit; i++) {\r\np = &wh->pool[i];\r\nif (cmp[1] == p->cmp[1] && cmp[0] == p->cmp[0])\r\nif (p->ip == 0)\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic int ebt_mac_wormhash_check_integrity(const struct ebt_mac_wormhash\r\n*wh)\r\n{\r\nint i;\r\nfor (i = 0; i < 256; i++) {\r\nif (wh->table[i] > wh->table[i + 1])\r\nreturn -0x100 - i;\r\nif (wh->table[i] < 0)\r\nreturn -0x200 - i;\r\nif (wh->table[i] > wh->poolsize)\r\nreturn -0x300 - i;\r\n}\r\nif (wh->table[256] > wh->poolsize)\r\nreturn -0xc00;\r\nreturn 0;\r\n}\r\nstatic int get_ip_dst(const struct sk_buff *skb, __be32 *addr)\r\n{\r\nif (eth_hdr(skb)->h_proto == htons(ETH_P_IP)) {\r\nconst struct iphdr *ih;\r\nstruct iphdr _iph;\r\nih = skb_header_pointer(skb, 0, sizeof(_iph), &_iph);\r\nif (ih == NULL)\r\nreturn -1;\r\n*addr = ih->daddr;\r\n} else if (eth_hdr(skb)->h_proto == htons(ETH_P_ARP)) {\r\nconst struct arphdr *ah;\r\nstruct arphdr _arph;\r\nconst __be32 *bp;\r\n__be32 buf;\r\nah = skb_header_pointer(skb, 0, sizeof(_arph), &_arph);\r\nif (ah == NULL ||\r\nah->ar_pln != sizeof(__be32) ||\r\nah->ar_hln != ETH_ALEN)\r\nreturn -1;\r\nbp = skb_header_pointer(skb, sizeof(struct arphdr) +\r\n2 * ETH_ALEN + sizeof(__be32),\r\nsizeof(__be32), &buf);\r\nif (bp == NULL)\r\nreturn -1;\r\n*addr = *bp;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_ip_src(const struct sk_buff *skb, __be32 *addr)\r\n{\r\nif (eth_hdr(skb)->h_proto == htons(ETH_P_IP)) {\r\nconst struct iphdr *ih;\r\nstruct iphdr _iph;\r\nih = skb_header_pointer(skb, 0, sizeof(_iph), &_iph);\r\nif (ih == NULL)\r\nreturn -1;\r\n*addr = ih->saddr;\r\n} else if (eth_hdr(skb)->h_proto == htons(ETH_P_ARP)) {\r\nconst struct arphdr *ah;\r\nstruct arphdr _arph;\r\nconst __be32 *bp;\r\n__be32 buf;\r\nah = skb_header_pointer(skb, 0, sizeof(_arph), &_arph);\r\nif (ah == NULL ||\r\nah->ar_pln != sizeof(__be32) ||\r\nah->ar_hln != ETH_ALEN)\r\nreturn -1;\r\nbp = skb_header_pointer(skb, sizeof(struct arphdr) +\r\nETH_ALEN, sizeof(__be32), &buf);\r\nif (bp == NULL)\r\nreturn -1;\r\n*addr = *bp;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool\r\nebt_among_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct ebt_among_info *info = par->matchinfo;\r\nconst char *dmac, *smac;\r\nconst struct ebt_mac_wormhash *wh_dst, *wh_src;\r\n__be32 dip = 0, sip = 0;\r\nwh_dst = ebt_among_wh_dst(info);\r\nwh_src = ebt_among_wh_src(info);\r\nif (wh_src) {\r\nsmac = eth_hdr(skb)->h_source;\r\nif (get_ip_src(skb, &sip))\r\nreturn false;\r\nif (!(info->bitmask & EBT_AMONG_SRC_NEG)) {\r\nif (!ebt_mac_wormhash_contains(wh_src, smac, sip))\r\nreturn false;\r\n} else {\r\nif (ebt_mac_wormhash_contains(wh_src, smac, sip))\r\nreturn false;\r\n}\r\n}\r\nif (wh_dst) {\r\ndmac = eth_hdr(skb)->h_dest;\r\nif (get_ip_dst(skb, &dip))\r\nreturn false;\r\nif (!(info->bitmask & EBT_AMONG_DST_NEG)) {\r\nif (!ebt_mac_wormhash_contains(wh_dst, dmac, dip))\r\nreturn false;\r\n} else {\r\nif (ebt_mac_wormhash_contains(wh_dst, dmac, dip))\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int ebt_among_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct ebt_among_info *info = par->matchinfo;\r\nconst struct ebt_entry_match *em =\r\ncontainer_of(par->matchinfo, const struct ebt_entry_match, data);\r\nint expected_length = sizeof(struct ebt_among_info);\r\nconst struct ebt_mac_wormhash *wh_dst, *wh_src;\r\nint err;\r\nwh_dst = ebt_among_wh_dst(info);\r\nwh_src = ebt_among_wh_src(info);\r\nexpected_length += ebt_mac_wormhash_size(wh_dst);\r\nexpected_length += ebt_mac_wormhash_size(wh_src);\r\nif (em->match_size != EBT_ALIGN(expected_length)) {\r\npr_info("wrong size: %d against expected %d, rounded to %zd\n",\r\nem->match_size, expected_length,\r\nEBT_ALIGN(expected_length));\r\nreturn -EINVAL;\r\n}\r\nif (wh_dst && (err = ebt_mac_wormhash_check_integrity(wh_dst))) {\r\npr_info("dst integrity fail: %x\n", -err);\r\nreturn -EINVAL;\r\n}\r\nif (wh_src && (err = ebt_mac_wormhash_check_integrity(wh_src))) {\r\npr_info("src integrity fail: %x\n", -err);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ebt_among_init(void)\r\n{\r\nreturn xt_register_match(&ebt_among_mt_reg);\r\n}\r\nstatic void __exit ebt_among_fini(void)\r\n{\r\nxt_unregister_match(&ebt_among_mt_reg);\r\n}
