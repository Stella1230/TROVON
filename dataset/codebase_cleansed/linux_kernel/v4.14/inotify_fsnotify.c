static bool event_compare(struct fsnotify_event *old_fsn,\r\nstruct fsnotify_event *new_fsn)\r\n{\r\nstruct inotify_event_info *old, *new;\r\nif (old_fsn->mask & FS_IN_IGNORED)\r\nreturn false;\r\nold = INOTIFY_E(old_fsn);\r\nnew = INOTIFY_E(new_fsn);\r\nif ((old_fsn->mask == new_fsn->mask) &&\r\n(old_fsn->inode == new_fsn->inode) &&\r\n(old->name_len == new->name_len) &&\r\n(!old->name_len || !strcmp(old->name, new->name)))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int inotify_merge(struct list_head *list,\r\nstruct fsnotify_event *event)\r\n{\r\nstruct fsnotify_event *last_event;\r\nlast_event = list_entry(list->prev, struct fsnotify_event, list);\r\nreturn event_compare(last_event, event);\r\n}\r\nint inotify_handle_event(struct fsnotify_group *group,\r\nstruct inode *inode,\r\nstruct fsnotify_mark *inode_mark,\r\nstruct fsnotify_mark *vfsmount_mark,\r\nu32 mask, const void *data, int data_type,\r\nconst unsigned char *file_name, u32 cookie,\r\nstruct fsnotify_iter_info *iter_info)\r\n{\r\nstruct inotify_inode_mark *i_mark;\r\nstruct inotify_event_info *event;\r\nstruct fsnotify_event *fsn_event;\r\nint ret;\r\nint len = 0;\r\nint alloc_len = sizeof(struct inotify_event_info);\r\nBUG_ON(vfsmount_mark);\r\nif ((inode_mark->mask & FS_EXCL_UNLINK) &&\r\n(data_type == FSNOTIFY_EVENT_PATH)) {\r\nconst struct path *path = data;\r\nif (d_unlinked(path->dentry))\r\nreturn 0;\r\n}\r\nif (file_name) {\r\nlen = strlen(file_name);\r\nalloc_len += len + 1;\r\n}\r\npr_debug("%s: group=%p inode=%p mask=%x\n", __func__, group, inode,\r\nmask);\r\ni_mark = container_of(inode_mark, struct inotify_inode_mark,\r\nfsn_mark);\r\nevent = kmalloc(alloc_len, GFP_KERNEL);\r\nif (unlikely(!event))\r\nreturn -ENOMEM;\r\nfsn_event = &event->fse;\r\nfsnotify_init_event(fsn_event, inode, mask);\r\nevent->wd = i_mark->wd;\r\nevent->sync_cookie = cookie;\r\nevent->name_len = len;\r\nif (len)\r\nstrcpy(event->name, file_name);\r\nret = fsnotify_add_event(group, fsn_event, inotify_merge);\r\nif (ret) {\r\nfsnotify_destroy_event(group, fsn_event);\r\n}\r\nif (inode_mark->mask & IN_ONESHOT)\r\nfsnotify_destroy_mark(inode_mark, group);\r\nreturn 0;\r\n}\r\nstatic void inotify_freeing_mark(struct fsnotify_mark *fsn_mark, struct fsnotify_group *group)\r\n{\r\ninotify_ignored_and_remove_idr(fsn_mark, group);\r\n}\r\nstatic int idr_callback(int id, void *p, void *data)\r\n{\r\nstruct fsnotify_mark *fsn_mark;\r\nstruct inotify_inode_mark *i_mark;\r\nstatic bool warned = false;\r\nif (warned)\r\nreturn 0;\r\nwarned = true;\r\nfsn_mark = p;\r\ni_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\r\nWARN(1, "inotify closing but id=%d for fsn_mark=%p in group=%p still in "\r\n"idr. Probably leaking memory\n", id, p, data);\r\nif (fsn_mark)\r\nprintk(KERN_WARNING "fsn_mark->group=%p wd=%d\n",\r\nfsn_mark->group, i_mark->wd);\r\nreturn 0;\r\n}\r\nstatic void inotify_free_group_priv(struct fsnotify_group *group)\r\n{\r\nidr_for_each(&group->inotify_data.idr, idr_callback, group);\r\nidr_destroy(&group->inotify_data.idr);\r\nif (group->inotify_data.ucounts)\r\ndec_inotify_instances(group->inotify_data.ucounts);\r\n}\r\nstatic void inotify_free_event(struct fsnotify_event *fsn_event)\r\n{\r\nkfree(INOTIFY_E(fsn_event));\r\n}\r\nstatic void inotify_free_mark(struct fsnotify_mark *fsn_mark)\r\n{\r\nstruct inotify_inode_mark *i_mark;\r\ni_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\r\nkmem_cache_free(inotify_inode_mark_cachep, i_mark);\r\n}
