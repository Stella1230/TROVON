static int pm800_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nstruct pm800_regulator_info *info = rdev_get_drvdata(rdev);\r\nreturn info->max_ua;\r\n}\r\nstatic int pm800_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct pm80x_chip *chip = dev_get_drvdata(pdev->dev.parent);\r\nstruct pm80x_platform_data *pdata = dev_get_platdata(pdev->dev.parent);\r\nstruct pm800_regulators *pm800_data;\r\nstruct regulator_config config = { };\r\nstruct regulator_init_data *init_data;\r\nint i, ret;\r\nif (pdata && pdata->num_regulators) {\r\nunsigned int count = 0;\r\nfor (i = 0; i < ARRAY_SIZE(pdata->regulators); i++) {\r\nif (pdata->regulators[i])\r\ncount++;\r\n}\r\nif (count != pdata->num_regulators)\r\nreturn -EINVAL;\r\n}\r\npm800_data = devm_kzalloc(&pdev->dev, sizeof(*pm800_data),\r\nGFP_KERNEL);\r\nif (!pm800_data)\r\nreturn -ENOMEM;\r\npm800_data->map = chip->subchip->regmap_power;\r\npm800_data->chip = chip;\r\nplatform_set_drvdata(pdev, pm800_data);\r\nconfig.dev = chip->dev;\r\nconfig.regmap = pm800_data->map;\r\nfor (i = 0; i < PM800_ID_RG_MAX; i++) {\r\nstruct regulator_dev *regulator;\r\nif (pdata && pdata->num_regulators) {\r\ninit_data = pdata->regulators[i];\r\nif (!init_data)\r\ncontinue;\r\nconfig.init_data = init_data;\r\n}\r\nconfig.driver_data = &pm800_regulator_info[i];\r\nregulator = devm_regulator_register(&pdev->dev,\r\n&pm800_regulator_info[i].desc, &config);\r\nif (IS_ERR(regulator)) {\r\nret = PTR_ERR(regulator);\r\ndev_err(&pdev->dev, "Failed to register %s\n",\r\npm800_regulator_info[i].desc.name);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}
