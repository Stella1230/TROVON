int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)\r\n{\r\nreturn gid_index * hr_dev->caps.num_ports + port;\r\n}\r\nstatic void hns_roce_set_mac(struct hns_roce_dev *hr_dev, u8 port, u8 *addr)\r\n{\r\nu8 phy_port;\r\nu32 i = 0;\r\nif (!memcmp(hr_dev->dev_addr[port], addr, MAC_ADDR_OCTET_NUM))\r\nreturn;\r\nfor (i = 0; i < MAC_ADDR_OCTET_NUM; i++)\r\nhr_dev->dev_addr[port][i] = addr[i];\r\nphy_port = hr_dev->iboe.phy_port[port];\r\nhr_dev->hw->set_mac(hr_dev, phy_port, addr);\r\n}\r\nstatic int hns_roce_add_gid(struct ib_device *device, u8 port_num,\r\nunsigned int index, const union ib_gid *gid,\r\nconst struct ib_gid_attr *attr, void **context)\r\n{\r\nstruct hns_roce_dev *hr_dev = to_hr_dev(device);\r\nu8 port = port_num - 1;\r\nunsigned long flags;\r\nif (port >= hr_dev->caps.num_ports)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&hr_dev->iboe.lock, flags);\r\nhr_dev->hw->set_gid(hr_dev, port, index, (union ib_gid *)gid);\r\nspin_unlock_irqrestore(&hr_dev->iboe.lock, flags);\r\nreturn 0;\r\n}\r\nstatic int hns_roce_del_gid(struct ib_device *device, u8 port_num,\r\nunsigned int index, void **context)\r\n{\r\nstruct hns_roce_dev *hr_dev = to_hr_dev(device);\r\nunion ib_gid zgid = { {0} };\r\nu8 port = port_num - 1;\r\nunsigned long flags;\r\nif (port >= hr_dev->caps.num_ports)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&hr_dev->iboe.lock, flags);\r\nhr_dev->hw->set_gid(hr_dev, port, index, &zgid);\r\nspin_unlock_irqrestore(&hr_dev->iboe.lock, flags);\r\nreturn 0;\r\n}\r\nstatic int handle_en_event(struct hns_roce_dev *hr_dev, u8 port,\r\nunsigned long event)\r\n{\r\nstruct device *dev = &hr_dev->pdev->dev;\r\nstruct net_device *netdev;\r\nnetdev = hr_dev->iboe.netdevs[port];\r\nif (!netdev) {\r\ndev_err(dev, "port(%d) can't find netdev\n", port);\r\nreturn -ENODEV;\r\n}\r\nswitch (event) {\r\ncase NETDEV_UP:\r\ncase NETDEV_CHANGE:\r\ncase NETDEV_REGISTER:\r\ncase NETDEV_CHANGEADDR:\r\nhns_roce_set_mac(hr_dev, port, netdev->dev_addr);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "NETDEV event = 0x%x!\n", (u32)(event));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hns_roce_netdev_event(struct notifier_block *self,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct hns_roce_ib_iboe *iboe = NULL;\r\nstruct hns_roce_dev *hr_dev = NULL;\r\nu8 port = 0;\r\nint ret = 0;\r\nhr_dev = container_of(self, struct hns_roce_dev, iboe.nb);\r\niboe = &hr_dev->iboe;\r\nfor (port = 0; port < hr_dev->caps.num_ports; port++) {\r\nif (dev == iboe->netdevs[port]) {\r\nret = handle_en_event(hr_dev, port, event);\r\nif (ret)\r\nreturn NOTIFY_DONE;\r\nbreak;\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int hns_roce_setup_mtu_mac(struct hns_roce_dev *hr_dev)\r\n{\r\nu8 i;\r\nfor (i = 0; i < hr_dev->caps.num_ports; i++) {\r\nhr_dev->hw->set_mtu(hr_dev, hr_dev->iboe.phy_port[i],\r\nhr_dev->caps.max_mtu);\r\nhns_roce_set_mac(hr_dev, i, hr_dev->iboe.netdevs[i]->dev_addr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hns_roce_query_device(struct ib_device *ib_dev,\r\nstruct ib_device_attr *props,\r\nstruct ib_udata *uhw)\r\n{\r\nstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\r\nmemset(props, 0, sizeof(*props));\r\nprops->sys_image_guid = hr_dev->sys_image_guid;\r\nprops->max_mr_size = (u64)(~(0ULL));\r\nprops->page_size_cap = hr_dev->caps.page_size_cap;\r\nprops->vendor_id = hr_dev->vendor_id;\r\nprops->vendor_part_id = hr_dev->vendor_part_id;\r\nprops->hw_ver = hr_dev->hw_rev;\r\nprops->max_qp = hr_dev->caps.num_qps;\r\nprops->max_qp_wr = hr_dev->caps.max_wqes;\r\nprops->device_cap_flags = IB_DEVICE_PORT_ACTIVE_EVENT |\r\nIB_DEVICE_RC_RNR_NAK_GEN;\r\nprops->max_sge = hr_dev->caps.max_sq_sg;\r\nprops->max_sge_rd = 1;\r\nprops->max_cq = hr_dev->caps.num_cqs;\r\nprops->max_cqe = hr_dev->caps.max_cqes;\r\nprops->max_mr = hr_dev->caps.num_mtpts;\r\nprops->max_pd = hr_dev->caps.num_pds;\r\nprops->max_qp_rd_atom = hr_dev->caps.max_qp_dest_rdma;\r\nprops->max_qp_init_rd_atom = hr_dev->caps.max_qp_init_rdma;\r\nprops->atomic_cap = IB_ATOMIC_NONE;\r\nprops->max_pkeys = 1;\r\nprops->local_ca_ack_delay = hr_dev->caps.local_ca_ack_delay;\r\nreturn 0;\r\n}\r\nstatic struct net_device *hns_roce_get_netdev(struct ib_device *ib_dev,\r\nu8 port_num)\r\n{\r\nstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\r\nstruct net_device *ndev;\r\nif (port_num < 1 || port_num > hr_dev->caps.num_ports)\r\nreturn NULL;\r\nrcu_read_lock();\r\nndev = hr_dev->iboe.netdevs[port_num - 1];\r\nif (ndev)\r\ndev_hold(ndev);\r\nrcu_read_unlock();\r\nreturn ndev;\r\n}\r\nstatic int hns_roce_query_port(struct ib_device *ib_dev, u8 port_num,\r\nstruct ib_port_attr *props)\r\n{\r\nstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\r\nstruct device *dev = &hr_dev->pdev->dev;\r\nstruct net_device *net_dev;\r\nunsigned long flags;\r\nenum ib_mtu mtu;\r\nu8 port;\r\nassert(port_num > 0);\r\nport = port_num - 1;\r\nprops->max_mtu = hr_dev->caps.max_mtu;\r\nprops->gid_tbl_len = hr_dev->caps.gid_table_len[port];\r\nprops->port_cap_flags = IB_PORT_CM_SUP | IB_PORT_REINIT_SUP |\r\nIB_PORT_VENDOR_CLASS_SUP |\r\nIB_PORT_BOOT_MGMT_SUP;\r\nprops->max_msg_sz = HNS_ROCE_MAX_MSG_LEN;\r\nprops->pkey_tbl_len = 1;\r\nprops->active_width = IB_WIDTH_4X;\r\nprops->active_speed = 1;\r\nspin_lock_irqsave(&hr_dev->iboe.lock, flags);\r\nnet_dev = hr_dev->iboe.netdevs[port];\r\nif (!net_dev) {\r\nspin_unlock_irqrestore(&hr_dev->iboe.lock, flags);\r\ndev_err(dev, "find netdev %d failed!\r\n", port);\r\nreturn -EINVAL;\r\n}\r\nmtu = iboe_get_mtu(net_dev->mtu);\r\nprops->active_mtu = mtu ? min(props->max_mtu, mtu) : IB_MTU_256;\r\nprops->state = (netif_running(net_dev) && netif_carrier_ok(net_dev)) ?\r\nIB_PORT_ACTIVE : IB_PORT_DOWN;\r\nprops->phys_state = (props->state == IB_PORT_ACTIVE) ? 5 : 3;\r\nspin_unlock_irqrestore(&hr_dev->iboe.lock, flags);\r\nreturn 0;\r\n}\r\nstatic enum rdma_link_layer hns_roce_get_link_layer(struct ib_device *device,\r\nu8 port_num)\r\n{\r\nreturn IB_LINK_LAYER_ETHERNET;\r\n}\r\nstatic int hns_roce_query_gid(struct ib_device *ib_dev, u8 port_num, int index,\r\nunion ib_gid *gid)\r\n{\r\nreturn 0;\r\n}\r\nstatic int hns_roce_query_pkey(struct ib_device *ib_dev, u8 port, u16 index,\r\nu16 *pkey)\r\n{\r\n*pkey = PKEY_ID;\r\nreturn 0;\r\n}\r\nstatic int hns_roce_modify_device(struct ib_device *ib_dev, int mask,\r\nstruct ib_device_modify *props)\r\n{\r\nunsigned long flags;\r\nif (mask & ~IB_DEVICE_MODIFY_NODE_DESC)\r\nreturn -EOPNOTSUPP;\r\nif (mask & IB_DEVICE_MODIFY_NODE_DESC) {\r\nspin_lock_irqsave(&to_hr_dev(ib_dev)->sm_lock, flags);\r\nmemcpy(ib_dev->node_desc, props->node_desc, NODE_DESC_SIZE);\r\nspin_unlock_irqrestore(&to_hr_dev(ib_dev)->sm_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hns_roce_modify_port(struct ib_device *ib_dev, u8 port_num, int mask,\r\nstruct ib_port_modify *props)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\r\nstruct ib_udata *udata)\r\n{\r\nint ret = 0;\r\nstruct hns_roce_ucontext *context;\r\nstruct hns_roce_ib_alloc_ucontext_resp resp;\r\nstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\r\nresp.qp_tab_size = hr_dev->caps.num_qps;\r\ncontext = kmalloc(sizeof(*context), GFP_KERNEL);\r\nif (!context)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = hns_roce_uar_alloc(hr_dev, &context->uar);\r\nif (ret)\r\ngoto error_fail_uar_alloc;\r\nret = ib_copy_to_udata(udata, &resp, sizeof(resp));\r\nif (ret)\r\ngoto error_fail_copy_to_udata;\r\nreturn &context->ibucontext;\r\nerror_fail_copy_to_udata:\r\nhns_roce_uar_free(hr_dev, &context->uar);\r\nerror_fail_uar_alloc:\r\nkfree(context);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int hns_roce_dealloc_ucontext(struct ib_ucontext *ibcontext)\r\n{\r\nstruct hns_roce_ucontext *context = to_hr_ucontext(ibcontext);\r\nhns_roce_uar_free(to_hr_dev(ibcontext->device), &context->uar);\r\nkfree(context);\r\nreturn 0;\r\n}\r\nstatic int hns_roce_mmap(struct ib_ucontext *context,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct hns_roce_dev *hr_dev = to_hr_dev(context->device);\r\nif (((vma->vm_end - vma->vm_start) % PAGE_SIZE) != 0)\r\nreturn -EINVAL;\r\nif (vma->vm_pgoff == 0) {\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nif (io_remap_pfn_range(vma, vma->vm_start,\r\nto_hr_ucontext(context)->uar.pfn,\r\nPAGE_SIZE, vma->vm_page_prot))\r\nreturn -EAGAIN;\r\n} else if (vma->vm_pgoff == 1 && hr_dev->hw_rev == HNS_ROCE_HW_VER1) {\r\nif (io_remap_pfn_range(vma, vma->vm_start,\r\nhr_dev->tptr_dma_addr >> PAGE_SHIFT,\r\nhr_dev->tptr_size,\r\nvma->vm_page_prot))\r\nreturn -EAGAIN;\r\n} else\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int hns_roce_port_immutable(struct ib_device *ib_dev, u8 port_num,\r\nstruct ib_port_immutable *immutable)\r\n{\r\nstruct ib_port_attr attr;\r\nint ret;\r\nimmutable->core_cap_flags = RDMA_CORE_PORT_IBA_ROCE;\r\nret = ib_query_port(ib_dev, port_num, &attr);\r\nif (ret)\r\nreturn ret;\r\nimmutable->pkey_tbl_len = attr.pkey_tbl_len;\r\nimmutable->gid_tbl_len = attr.gid_tbl_len;\r\nimmutable->max_mad_size = IB_MGMT_MAD_SIZE;\r\nreturn 0;\r\n}\r\nstatic void hns_roce_unregister_device(struct hns_roce_dev *hr_dev)\r\n{\r\nstruct hns_roce_ib_iboe *iboe = &hr_dev->iboe;\r\nunregister_inetaddr_notifier(&iboe->nb_inet);\r\nunregister_netdevice_notifier(&iboe->nb);\r\nib_unregister_device(&hr_dev->ib_dev);\r\n}\r\nstatic int hns_roce_register_device(struct hns_roce_dev *hr_dev)\r\n{\r\nint ret;\r\nstruct hns_roce_ib_iboe *iboe = NULL;\r\nstruct ib_device *ib_dev = NULL;\r\nstruct device *dev = &hr_dev->pdev->dev;\r\niboe = &hr_dev->iboe;\r\nspin_lock_init(&iboe->lock);\r\nib_dev = &hr_dev->ib_dev;\r\nstrlcpy(ib_dev->name, "hns_%d", IB_DEVICE_NAME_MAX);\r\nib_dev->owner = THIS_MODULE;\r\nib_dev->node_type = RDMA_NODE_IB_CA;\r\nib_dev->dev.parent = dev;\r\nib_dev->phys_port_cnt = hr_dev->caps.num_ports;\r\nib_dev->local_dma_lkey = hr_dev->caps.reserved_lkey;\r\nib_dev->num_comp_vectors = hr_dev->caps.num_comp_vectors;\r\nib_dev->uverbs_abi_ver = 1;\r\nib_dev->uverbs_cmd_mask =\r\n(1ULL << IB_USER_VERBS_CMD_GET_CONTEXT) |\r\n(1ULL << IB_USER_VERBS_CMD_QUERY_DEVICE) |\r\n(1ULL << IB_USER_VERBS_CMD_QUERY_PORT) |\r\n(1ULL << IB_USER_VERBS_CMD_ALLOC_PD) |\r\n(1ULL << IB_USER_VERBS_CMD_DEALLOC_PD) |\r\n(1ULL << IB_USER_VERBS_CMD_REG_MR) |\r\n(1ULL << IB_USER_VERBS_CMD_DEREG_MR) |\r\n(1ULL << IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL) |\r\n(1ULL << IB_USER_VERBS_CMD_CREATE_CQ) |\r\n(1ULL << IB_USER_VERBS_CMD_DESTROY_CQ) |\r\n(1ULL << IB_USER_VERBS_CMD_CREATE_QP) |\r\n(1ULL << IB_USER_VERBS_CMD_MODIFY_QP) |\r\n(1ULL << IB_USER_VERBS_CMD_QUERY_QP) |\r\n(1ULL << IB_USER_VERBS_CMD_DESTROY_QP);\r\nib_dev->modify_device = hns_roce_modify_device;\r\nib_dev->query_device = hns_roce_query_device;\r\nib_dev->query_port = hns_roce_query_port;\r\nib_dev->modify_port = hns_roce_modify_port;\r\nib_dev->get_link_layer = hns_roce_get_link_layer;\r\nib_dev->get_netdev = hns_roce_get_netdev;\r\nib_dev->query_gid = hns_roce_query_gid;\r\nib_dev->add_gid = hns_roce_add_gid;\r\nib_dev->del_gid = hns_roce_del_gid;\r\nib_dev->query_pkey = hns_roce_query_pkey;\r\nib_dev->alloc_ucontext = hns_roce_alloc_ucontext;\r\nib_dev->dealloc_ucontext = hns_roce_dealloc_ucontext;\r\nib_dev->mmap = hns_roce_mmap;\r\nib_dev->alloc_pd = hns_roce_alloc_pd;\r\nib_dev->dealloc_pd = hns_roce_dealloc_pd;\r\nib_dev->create_ah = hns_roce_create_ah;\r\nib_dev->query_ah = hns_roce_query_ah;\r\nib_dev->destroy_ah = hns_roce_destroy_ah;\r\nib_dev->create_qp = hns_roce_create_qp;\r\nib_dev->modify_qp = hns_roce_modify_qp;\r\nib_dev->query_qp = hr_dev->hw->query_qp;\r\nib_dev->destroy_qp = hr_dev->hw->destroy_qp;\r\nib_dev->post_send = hr_dev->hw->post_send;\r\nib_dev->post_recv = hr_dev->hw->post_recv;\r\nib_dev->create_cq = hns_roce_ib_create_cq;\r\nib_dev->destroy_cq = hns_roce_ib_destroy_cq;\r\nib_dev->req_notify_cq = hr_dev->hw->req_notify_cq;\r\nib_dev->poll_cq = hr_dev->hw->poll_cq;\r\nib_dev->get_dma_mr = hns_roce_get_dma_mr;\r\nib_dev->reg_user_mr = hns_roce_reg_user_mr;\r\nib_dev->dereg_mr = hns_roce_dereg_mr;\r\nib_dev->get_port_immutable = hns_roce_port_immutable;\r\nret = ib_register_device(ib_dev, NULL);\r\nif (ret) {\r\ndev_err(dev, "ib_register_device failed!\n");\r\nreturn ret;\r\n}\r\nret = hns_roce_setup_mtu_mac(hr_dev);\r\nif (ret) {\r\ndev_err(dev, "setup_mtu_mac failed!\n");\r\ngoto error_failed_setup_mtu_mac;\r\n}\r\niboe->nb.notifier_call = hns_roce_netdev_event;\r\nret = register_netdevice_notifier(&iboe->nb);\r\nif (ret) {\r\ndev_err(dev, "register_netdevice_notifier failed!\n");\r\ngoto error_failed_setup_mtu_mac;\r\n}\r\nreturn 0;\r\nerror_failed_setup_mtu_mac:\r\nib_unregister_device(ib_dev);\r\nreturn ret;\r\n}\r\nstatic int hns_roce_node_match(struct device *dev, void *fwnode)\r\n{\r\nreturn dev->fwnode == fwnode;\r\n}\r\nstatic struct\r\nplatform_device *hns_roce_find_pdev(struct fwnode_handle *fwnode)\r\n{\r\nstruct device *dev;\r\ndev = bus_find_device(&platform_bus_type, NULL,\r\nfwnode, hns_roce_node_match);\r\nreturn dev ? to_platform_device(dev) : NULL;\r\n}\r\nstatic int hns_roce_get_cfg(struct hns_roce_dev *hr_dev)\r\n{\r\nint i;\r\nint ret;\r\nu8 phy_port;\r\nint port_cnt = 0;\r\nstruct device *dev = &hr_dev->pdev->dev;\r\nstruct device_node *net_node;\r\nstruct net_device *netdev = NULL;\r\nstruct platform_device *pdev = NULL;\r\nstruct resource *res;\r\nif (dev_of_node(dev)) {\r\nconst struct of_device_id *of_id;\r\nof_id = of_match_node(hns_roce_of_match, dev->of_node);\r\nif (!of_id) {\r\ndev_err(dev, "device is not compatible!\n");\r\nreturn -ENXIO;\r\n}\r\nhr_dev->hw = (struct hns_roce_hw *)of_id->data;\r\nif (!hr_dev->hw) {\r\ndev_err(dev, "couldn't get H/W specific DT data!\n");\r\nreturn -ENXIO;\r\n}\r\n} else if (is_acpi_device_node(dev->fwnode)) {\r\nconst struct acpi_device_id *acpi_id;\r\nacpi_id = acpi_match_device(hns_roce_acpi_match, dev);\r\nif (!acpi_id) {\r\ndev_err(dev, "device is not compatible!\n");\r\nreturn -ENXIO;\r\n}\r\nhr_dev->hw = (struct hns_roce_hw *) acpi_id->driver_data;\r\nif (!hr_dev->hw) {\r\ndev_err(dev, "couldn't get H/W specific ACPI data!\n");\r\nreturn -ENXIO;\r\n}\r\n} else {\r\ndev_err(dev, "can't read compatibility data from DT or ACPI\n");\r\nreturn -ENXIO;\r\n}\r\nres = platform_get_resource(hr_dev->pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "memory resource not found!\n");\r\nreturn -EINVAL;\r\n}\r\nhr_dev->reg_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(hr_dev->reg_base))\r\nreturn PTR_ERR(hr_dev->reg_base);\r\nret = device_property_read_u8_array(dev, "node-guid",\r\n(u8 *)&hr_dev->ib_dev.node_guid,\r\nGUID_LEN);\r\nif (ret) {\r\ndev_err(dev, "couldn't get node_guid from DT or ACPI!\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < HNS_ROCE_MAX_PORTS; i++) {\r\nif (dev_of_node(dev)) {\r\nnet_node = of_parse_phandle(dev->of_node, "eth-handle",\r\ni);\r\nif (!net_node)\r\ncontinue;\r\npdev = of_find_device_by_node(net_node);\r\n} else if (is_acpi_device_node(dev->fwnode)) {\r\nstruct acpi_reference_args args;\r\nstruct fwnode_handle *fwnode;\r\nret = acpi_node_get_property_reference(dev->fwnode,\r\n"eth-handle",\r\ni, &args);\r\nif (ret)\r\ncontinue;\r\nfwnode = acpi_fwnode_handle(args.adev);\r\npdev = hns_roce_find_pdev(fwnode);\r\n} else {\r\ndev_err(dev, "cannot read data from DT or ACPI\n");\r\nreturn -ENXIO;\r\n}\r\nif (pdev) {\r\nnetdev = platform_get_drvdata(pdev);\r\nphy_port = (u8)i;\r\nif (netdev) {\r\nhr_dev->iboe.netdevs[port_cnt] = netdev;\r\nhr_dev->iboe.phy_port[port_cnt] = phy_port;\r\n} else {\r\ndev_err(dev, "no netdev found with pdev %s\n",\r\npdev->name);\r\nreturn -ENODEV;\r\n}\r\nport_cnt++;\r\n}\r\n}\r\nif (port_cnt == 0) {\r\ndev_err(dev, "unable to get eth-handle for available ports!\n");\r\nreturn -EINVAL;\r\n}\r\nhr_dev->caps.num_ports = port_cnt;\r\nhr_dev->cmd_mod = 1;\r\nhr_dev->loop_idc = 0;\r\nret = device_property_read_string_array(dev, "interrupt-names",\r\nhr_dev->irq_names,\r\nHNS_ROCE_MAX_IRQ_NUM);\r\nif (ret < 0) {\r\ndev_err(dev, "couldn't get interrupt names from DT or ACPI!\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < HNS_ROCE_MAX_IRQ_NUM; i++) {\r\nhr_dev->irq[i] = platform_get_irq(hr_dev->pdev, i);\r\nif (hr_dev->irq[i] <= 0) {\r\ndev_err(dev, "platform get of irq[=%d] failed!\n", i);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int hns_roce_init_hem(struct hns_roce_dev *hr_dev)\r\n{\r\nint ret;\r\nstruct device *dev = &hr_dev->pdev->dev;\r\nret = hns_roce_init_hem_table(hr_dev, &hr_dev->mr_table.mtt_table,\r\nHEM_TYPE_MTT, hr_dev->caps.mtt_entry_sz,\r\nhr_dev->caps.num_mtt_segs, 1);\r\nif (ret) {\r\ndev_err(dev, "Failed to init MTT context memory, aborting.\n");\r\nreturn ret;\r\n}\r\nret = hns_roce_init_hem_table(hr_dev, &hr_dev->mr_table.mtpt_table,\r\nHEM_TYPE_MTPT, hr_dev->caps.mtpt_entry_sz,\r\nhr_dev->caps.num_mtpts, 1);\r\nif (ret) {\r\ndev_err(dev, "Failed to init MTPT context memory, aborting.\n");\r\ngoto err_unmap_mtt;\r\n}\r\nret = hns_roce_init_hem_table(hr_dev, &hr_dev->qp_table.qp_table,\r\nHEM_TYPE_QPC, hr_dev->caps.qpc_entry_sz,\r\nhr_dev->caps.num_qps, 1);\r\nif (ret) {\r\ndev_err(dev, "Failed to init QP context memory, aborting.\n");\r\ngoto err_unmap_dmpt;\r\n}\r\nret = hns_roce_init_hem_table(hr_dev, &hr_dev->qp_table.irrl_table,\r\nHEM_TYPE_IRRL,\r\nhr_dev->caps.irrl_entry_sz *\r\nhr_dev->caps.max_qp_init_rdma,\r\nhr_dev->caps.num_qps, 1);\r\nif (ret) {\r\ndev_err(dev, "Failed to init irrl_table memory, aborting.\n");\r\ngoto err_unmap_qp;\r\n}\r\nret = hns_roce_init_hem_table(hr_dev, &hr_dev->cq_table.table,\r\nHEM_TYPE_CQC, hr_dev->caps.cqc_entry_sz,\r\nhr_dev->caps.num_cqs, 1);\r\nif (ret) {\r\ndev_err(dev, "Failed to init CQ context memory, aborting.\n");\r\ngoto err_unmap_irrl;\r\n}\r\nreturn 0;\r\nerr_unmap_irrl:\r\nhns_roce_cleanup_hem_table(hr_dev, &hr_dev->qp_table.irrl_table);\r\nerr_unmap_qp:\r\nhns_roce_cleanup_hem_table(hr_dev, &hr_dev->qp_table.qp_table);\r\nerr_unmap_dmpt:\r\nhns_roce_cleanup_hem_table(hr_dev, &hr_dev->mr_table.mtpt_table);\r\nerr_unmap_mtt:\r\nhns_roce_cleanup_hem_table(hr_dev, &hr_dev->mr_table.mtt_table);\r\nreturn ret;\r\n}\r\nstatic int hns_roce_setup_hca(struct hns_roce_dev *hr_dev)\r\n{\r\nint ret;\r\nstruct device *dev = &hr_dev->pdev->dev;\r\nspin_lock_init(&hr_dev->sm_lock);\r\nspin_lock_init(&hr_dev->bt_cmd_lock);\r\nret = hns_roce_init_uar_table(hr_dev);\r\nif (ret) {\r\ndev_err(dev, "Failed to initialize uar table. aborting\n");\r\nreturn ret;\r\n}\r\nret = hns_roce_uar_alloc(hr_dev, &hr_dev->priv_uar);\r\nif (ret) {\r\ndev_err(dev, "Failed to allocate priv_uar.\n");\r\ngoto err_uar_table_free;\r\n}\r\nret = hns_roce_init_pd_table(hr_dev);\r\nif (ret) {\r\ndev_err(dev, "Failed to init protected domain table.\n");\r\ngoto err_uar_alloc_free;\r\n}\r\nret = hns_roce_init_mr_table(hr_dev);\r\nif (ret) {\r\ndev_err(dev, "Failed to init memory region table.\n");\r\ngoto err_pd_table_free;\r\n}\r\nret = hns_roce_init_cq_table(hr_dev);\r\nif (ret) {\r\ndev_err(dev, "Failed to init completion queue table.\n");\r\ngoto err_mr_table_free;\r\n}\r\nret = hns_roce_init_qp_table(hr_dev);\r\nif (ret) {\r\ndev_err(dev, "Failed to init queue pair table.\n");\r\ngoto err_cq_table_free;\r\n}\r\nreturn 0;\r\nerr_cq_table_free:\r\nhns_roce_cleanup_cq_table(hr_dev);\r\nerr_mr_table_free:\r\nhns_roce_cleanup_mr_table(hr_dev);\r\nerr_pd_table_free:\r\nhns_roce_cleanup_pd_table(hr_dev);\r\nerr_uar_alloc_free:\r\nhns_roce_uar_free(hr_dev, &hr_dev->priv_uar);\r\nerr_uar_table_free:\r\nhns_roce_cleanup_uar_table(hr_dev);\r\nreturn ret;\r\n}\r\nstatic int hns_roce_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct hns_roce_dev *hr_dev;\r\nstruct device *dev = &pdev->dev;\r\nhr_dev = (struct hns_roce_dev *)ib_alloc_device(sizeof(*hr_dev));\r\nif (!hr_dev)\r\nreturn -ENOMEM;\r\nhr_dev->pdev = pdev;\r\nplatform_set_drvdata(pdev, hr_dev);\r\nif (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64ULL)) &&\r\ndma_set_mask_and_coherent(dev, DMA_BIT_MASK(32ULL))) {\r\ndev_err(dev, "Not usable DMA addressing mode\n");\r\nret = -EIO;\r\ngoto error_failed_get_cfg;\r\n}\r\nret = hns_roce_get_cfg(hr_dev);\r\nif (ret) {\r\ndev_err(dev, "Get Configuration failed!\n");\r\ngoto error_failed_get_cfg;\r\n}\r\nret = hr_dev->hw->reset(hr_dev, true);\r\nif (ret) {\r\ndev_err(dev, "Reset RoCE engine failed!\n");\r\ngoto error_failed_get_cfg;\r\n}\r\nhr_dev->hw->hw_profile(hr_dev);\r\nret = hns_roce_cmd_init(hr_dev);\r\nif (ret) {\r\ndev_err(dev, "cmd init failed!\n");\r\ngoto error_failed_cmd_init;\r\n}\r\nret = hns_roce_init_eq_table(hr_dev);\r\nif (ret) {\r\ndev_err(dev, "eq init failed!\n");\r\ngoto error_failed_eq_table;\r\n}\r\nif (hr_dev->cmd_mod) {\r\nret = hns_roce_cmd_use_events(hr_dev);\r\nif (ret) {\r\ndev_err(dev, "Switch to event-driven cmd failed!\n");\r\ngoto error_failed_use_event;\r\n}\r\n}\r\nret = hns_roce_init_hem(hr_dev);\r\nif (ret) {\r\ndev_err(dev, "init HEM(Hardware Entry Memory) failed!\n");\r\ngoto error_failed_init_hem;\r\n}\r\nret = hns_roce_setup_hca(hr_dev);\r\nif (ret) {\r\ndev_err(dev, "setup hca failed!\n");\r\ngoto error_failed_setup_hca;\r\n}\r\nret = hr_dev->hw->hw_init(hr_dev);\r\nif (ret) {\r\ndev_err(dev, "hw_init failed!\n");\r\ngoto error_failed_engine_init;\r\n}\r\nret = hns_roce_register_device(hr_dev);\r\nif (ret)\r\ngoto error_failed_register_device;\r\nreturn 0;\r\nerror_failed_register_device:\r\nhr_dev->hw->hw_exit(hr_dev);\r\nerror_failed_engine_init:\r\nhns_roce_cleanup_bitmap(hr_dev);\r\nerror_failed_setup_hca:\r\nhns_roce_cleanup_hem(hr_dev);\r\nerror_failed_init_hem:\r\nif (hr_dev->cmd_mod)\r\nhns_roce_cmd_use_polling(hr_dev);\r\nerror_failed_use_event:\r\nhns_roce_cleanup_eq_table(hr_dev);\r\nerror_failed_eq_table:\r\nhns_roce_cmd_cleanup(hr_dev);\r\nerror_failed_cmd_init:\r\nret = hr_dev->hw->reset(hr_dev, false);\r\nif (ret)\r\ndev_err(&hr_dev->pdev->dev, "roce_engine reset fail\n");\r\nerror_failed_get_cfg:\r\nib_dealloc_device(&hr_dev->ib_dev);\r\nreturn ret;\r\n}\r\nstatic int hns_roce_remove(struct platform_device *pdev)\r\n{\r\nstruct hns_roce_dev *hr_dev = platform_get_drvdata(pdev);\r\nhns_roce_unregister_device(hr_dev);\r\nhr_dev->hw->hw_exit(hr_dev);\r\nhns_roce_cleanup_bitmap(hr_dev);\r\nhns_roce_cleanup_hem(hr_dev);\r\nif (hr_dev->cmd_mod)\r\nhns_roce_cmd_use_polling(hr_dev);\r\nhns_roce_cleanup_eq_table(hr_dev);\r\nhns_roce_cmd_cleanup(hr_dev);\r\nhr_dev->hw->reset(hr_dev, false);\r\nib_dealloc_device(&hr_dev->ib_dev);\r\nreturn 0;\r\n}
