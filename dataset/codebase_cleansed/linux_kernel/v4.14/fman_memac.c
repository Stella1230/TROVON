static void add_addr_in_paddr(struct memac_regs __iomem *regs, u8 *adr,\r\nu8 paddr_num)\r\n{\r\nu32 tmp0, tmp1;\r\ntmp0 = (u32)(adr[0] | adr[1] << 8 | adr[2] << 16 | adr[3] << 24);\r\ntmp1 = (u32)(adr[4] | adr[5] << 8);\r\nif (paddr_num == 0) {\r\niowrite32be(tmp0, &regs->mac_addr0.mac_addr_l);\r\niowrite32be(tmp1, &regs->mac_addr0.mac_addr_u);\r\n} else {\r\niowrite32be(tmp0, &regs->mac_addr[paddr_num - 1].mac_addr_l);\r\niowrite32be(tmp1, &regs->mac_addr[paddr_num - 1].mac_addr_u);\r\n}\r\n}\r\nstatic int reset(struct memac_regs __iomem *regs)\r\n{\r\nu32 tmp;\r\nint count;\r\ntmp = ioread32be(&regs->command_config);\r\ntmp |= CMD_CFG_SW_RESET;\r\niowrite32be(tmp, &regs->command_config);\r\ncount = 100;\r\ndo {\r\nudelay(1);\r\n} while ((ioread32be(&regs->command_config) & CMD_CFG_SW_RESET) &&\r\n--count);\r\nif (count == 0)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic void set_exception(struct memac_regs __iomem *regs, u32 val,\r\nbool enable)\r\n{\r\nu32 tmp;\r\ntmp = ioread32be(&regs->imask);\r\nif (enable)\r\ntmp |= val;\r\nelse\r\ntmp &= ~val;\r\niowrite32be(tmp, &regs->imask);\r\n}\r\nstatic int init(struct memac_regs __iomem *regs, struct memac_cfg *cfg,\r\nphy_interface_t phy_if, u16 speed, bool slow_10g_if,\r\nu32 exceptions)\r\n{\r\nu32 tmp;\r\ntmp = 0;\r\nif (cfg->promiscuous_mode_enable)\r\ntmp |= CMD_CFG_PROMIS_EN;\r\nif (cfg->pause_ignore)\r\ntmp |= CMD_CFG_PAUSE_IGNORE;\r\ntmp |= CMD_CFG_NO_LEN_CHK;\r\ntmp |= CMD_CFG_TX_PAD_EN;\r\ntmp |= CMD_CFG_CRC_FWD;\r\niowrite32be(tmp, &regs->command_config);\r\niowrite32be((u32)cfg->max_frame_length, &regs->maxfrm);\r\niowrite32be((u32)cfg->pause_quanta, &regs->pause_quanta[0]);\r\niowrite32be((u32)0, &regs->pause_thresh[0]);\r\ntmp = 0;\r\nswitch (phy_if) {\r\ncase PHY_INTERFACE_MODE_XGMII:\r\ntmp |= IF_MODE_XGMII;\r\nbreak;\r\ndefault:\r\ntmp |= IF_MODE_GMII;\r\nif (phy_if == PHY_INTERFACE_MODE_RGMII ||\r\nphy_if == PHY_INTERFACE_MODE_RGMII_ID ||\r\nphy_if == PHY_INTERFACE_MODE_RGMII_RXID ||\r\nphy_if == PHY_INTERFACE_MODE_RGMII_TXID)\r\ntmp |= IF_MODE_RGMII | IF_MODE_RGMII_AUTO;\r\n}\r\niowrite32be(tmp, &regs->if_mode);\r\ntmp = 0;\r\nif (phy_if == PHY_INTERFACE_MODE_XGMII) {\r\nif (slow_10g_if) {\r\ntmp |= (TX_FIFO_SECTIONS_TX_AVAIL_SLOW_10G |\r\nTX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_10G);\r\n} else {\r\ntmp |= (TX_FIFO_SECTIONS_TX_AVAIL_10G |\r\nTX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_10G);\r\n}\r\n} else {\r\ntmp |= (TX_FIFO_SECTIONS_TX_AVAIL_1G |\r\nTX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_1G);\r\n}\r\niowrite32be(tmp, &regs->tx_fifo_sections);\r\niowrite32be(0xffffffff, &regs->ievent);\r\nset_exception(regs, exceptions, true);\r\nreturn 0;\r\n}\r\nstatic void set_dflts(struct memac_cfg *cfg)\r\n{\r\ncfg->reset_on_init = false;\r\ncfg->promiscuous_mode_enable = false;\r\ncfg->pause_ignore = false;\r\ncfg->tx_ipg_length = DEFAULT_TX_IPG_LENGTH;\r\ncfg->max_frame_length = DEFAULT_FRAME_LENGTH;\r\ncfg->pause_quanta = DEFAULT_PAUSE_QUANTA;\r\n}\r\nstatic u32 get_mac_addr_hash_code(u64 eth_addr)\r\n{\r\nu64 mask1, mask2;\r\nu32 xor_val = 0;\r\nu8 i, j;\r\nfor (i = 0; i < 6; i++) {\r\nmask1 = eth_addr & (u64)0x01;\r\neth_addr >>= 1;\r\nfor (j = 0; j < 7; j++) {\r\nmask2 = eth_addr & (u64)0x01;\r\nmask1 ^= mask2;\r\neth_addr >>= 1;\r\n}\r\nxor_val |= (mask1 << (5 - i));\r\n}\r\nreturn xor_val;\r\n}\r\nstatic void setup_sgmii_internal_phy(struct fman_mac *memac,\r\nstruct fixed_phy_status *fixed_link)\r\n{\r\nu16 tmp_reg16;\r\nif (WARN_ON(!memac->pcsphy))\r\nreturn;\r\ntmp_reg16 = IF_MODE_SGMII_EN;\r\nif (!fixed_link)\r\ntmp_reg16 |= IF_MODE_USE_SGMII_AN;\r\nelse {\r\nswitch (fixed_link->speed) {\r\ncase 10:\r\nbreak;\r\ncase 100:\r\ntmp_reg16 |= IF_MODE_SGMII_SPEED_100M;\r\nbreak;\r\ncase 1000:\r\ndefault:\r\ntmp_reg16 |= IF_MODE_SGMII_SPEED_1G;\r\nbreak;\r\n}\r\nif (!fixed_link->duplex)\r\ntmp_reg16 |= IF_MODE_SGMII_DUPLEX_HALF;\r\n}\r\nphy_write(memac->pcsphy, MDIO_SGMII_IF_MODE, tmp_reg16);\r\ntmp_reg16 = MDIO_SGMII_DEV_ABIL_SGMII_MODE;\r\nphy_write(memac->pcsphy, MDIO_SGMII_DEV_ABIL_SGMII, tmp_reg16);\r\nphy_write(memac->pcsphy, MDIO_SGMII_LINK_TMR_H, LINK_TMR_H);\r\nphy_write(memac->pcsphy, MDIO_SGMII_LINK_TMR_L, LINK_TMR_L);\r\nif (!fixed_link)\r\ntmp_reg16 = SGMII_CR_DEF_VAL | SGMII_CR_RESTART_AN;\r\nelse\r\ntmp_reg16 = SGMII_CR_DEF_VAL & ~SGMII_CR_AN_EN;\r\nphy_write(memac->pcsphy, 0x0, tmp_reg16);\r\n}\r\nstatic void setup_sgmii_internal_phy_base_x(struct fman_mac *memac)\r\n{\r\nu16 tmp_reg16;\r\ntmp_reg16 = MDIO_SGMII_DEV_ABIL_BASEX_MODE;\r\nphy_write(memac->pcsphy, MDIO_SGMII_DEV_ABIL_SGMII, tmp_reg16);\r\nphy_write(memac->pcsphy, MDIO_SGMII_LINK_TMR_H, LINK_TMR_H_BASEX);\r\nphy_write(memac->pcsphy, MDIO_SGMII_LINK_TMR_L, LINK_TMR_L_BASEX);\r\ntmp_reg16 = SGMII_CR_DEF_VAL | SGMII_CR_RESTART_AN;\r\nphy_write(memac->pcsphy, 0x0, tmp_reg16);\r\n}\r\nstatic int check_init_parameters(struct fman_mac *memac)\r\n{\r\nif (memac->addr == 0) {\r\npr_err("Ethernet MAC must have a valid MAC address\n");\r\nreturn -EINVAL;\r\n}\r\nif (!memac->exception_cb) {\r\npr_err("Uninitialized exception handler\n");\r\nreturn -EINVAL;\r\n}\r\nif (!memac->event_cb) {\r\npr_warn("Uninitialize event handler\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_exception_flag(enum fman_mac_exceptions exception)\r\n{\r\nu32 bit_mask;\r\nswitch (exception) {\r\ncase FM_MAC_EX_10G_TX_ECC_ER:\r\nbit_mask = MEMAC_IMASK_TECC_ER;\r\nbreak;\r\ncase FM_MAC_EX_10G_RX_ECC_ER:\r\nbit_mask = MEMAC_IMASK_RECC_ER;\r\nbreak;\r\ncase FM_MAC_EX_TS_FIFO_ECC_ERR:\r\nbit_mask = MEMAC_IMASK_TSECC_ER;\r\nbreak;\r\ncase FM_MAC_EX_MAGIC_PACKET_INDICATION:\r\nbit_mask = MEMAC_IMASK_MGI;\r\nbreak;\r\ndefault:\r\nbit_mask = 0;\r\nbreak;\r\n}\r\nreturn bit_mask;\r\n}\r\nstatic void memac_err_exception(void *handle)\r\n{\r\nstruct fman_mac *memac = (struct fman_mac *)handle;\r\nstruct memac_regs __iomem *regs = memac->regs;\r\nu32 event, imask;\r\nevent = ioread32be(&regs->ievent);\r\nimask = ioread32be(&regs->imask);\r\nevent &= ((imask & MEMAC_ALL_ERRS_IMASK) >> 16);\r\niowrite32be(event, &regs->ievent);\r\nif (event & MEMAC_IEVNT_TS_ECC_ER)\r\nmemac->exception_cb(memac->dev_id, FM_MAC_EX_TS_FIFO_ECC_ERR);\r\nif (event & MEMAC_IEVNT_TX_ECC_ER)\r\nmemac->exception_cb(memac->dev_id, FM_MAC_EX_10G_TX_ECC_ER);\r\nif (event & MEMAC_IEVNT_RX_ECC_ER)\r\nmemac->exception_cb(memac->dev_id, FM_MAC_EX_10G_RX_ECC_ER);\r\n}\r\nstatic void memac_exception(void *handle)\r\n{\r\nstruct fman_mac *memac = (struct fman_mac *)handle;\r\nstruct memac_regs __iomem *regs = memac->regs;\r\nu32 event, imask;\r\nevent = ioread32be(&regs->ievent);\r\nimask = ioread32be(&regs->imask);\r\nevent &= ((imask & MEMAC_ALL_ERRS_IMASK) >> 16);\r\niowrite32be(event, &regs->ievent);\r\nif (event & MEMAC_IEVNT_MGI)\r\nmemac->exception_cb(memac->dev_id,\r\nFM_MAC_EX_MAGIC_PACKET_INDICATION);\r\n}\r\nstatic void free_init_resources(struct fman_mac *memac)\r\n{\r\nfman_unregister_intr(memac->fm, FMAN_MOD_MAC, memac->mac_id,\r\nFMAN_INTR_TYPE_ERR);\r\nfman_unregister_intr(memac->fm, FMAN_MOD_MAC, memac->mac_id,\r\nFMAN_INTR_TYPE_NORMAL);\r\nfree_hash_table(memac->multicast_addr_hash);\r\nmemac->multicast_addr_hash = NULL;\r\nfree_hash_table(memac->unicast_addr_hash);\r\nmemac->unicast_addr_hash = NULL;\r\n}\r\nstatic bool is_init_done(struct memac_cfg *memac_drv_params)\r\n{\r\nif (!memac_drv_params)\r\nreturn true;\r\nreturn false;\r\n}\r\nint memac_enable(struct fman_mac *memac, enum comm_mode mode)\r\n{\r\nstruct memac_regs __iomem *regs = memac->regs;\r\nu32 tmp;\r\nif (!is_init_done(memac->memac_drv_param))\r\nreturn -EINVAL;\r\ntmp = ioread32be(&regs->command_config);\r\nif (mode & COMM_MODE_RX)\r\ntmp |= CMD_CFG_RX_EN;\r\nif (mode & COMM_MODE_TX)\r\ntmp |= CMD_CFG_TX_EN;\r\niowrite32be(tmp, &regs->command_config);\r\nreturn 0;\r\n}\r\nint memac_disable(struct fman_mac *memac, enum comm_mode mode)\r\n{\r\nstruct memac_regs __iomem *regs = memac->regs;\r\nu32 tmp;\r\nif (!is_init_done(memac->memac_drv_param))\r\nreturn -EINVAL;\r\ntmp = ioread32be(&regs->command_config);\r\nif (mode & COMM_MODE_RX)\r\ntmp &= ~CMD_CFG_RX_EN;\r\nif (mode & COMM_MODE_TX)\r\ntmp &= ~CMD_CFG_TX_EN;\r\niowrite32be(tmp, &regs->command_config);\r\nreturn 0;\r\n}\r\nint memac_set_promiscuous(struct fman_mac *memac, bool new_val)\r\n{\r\nstruct memac_regs __iomem *regs = memac->regs;\r\nu32 tmp;\r\nif (!is_init_done(memac->memac_drv_param))\r\nreturn -EINVAL;\r\ntmp = ioread32be(&regs->command_config);\r\nif (new_val)\r\ntmp |= CMD_CFG_PROMIS_EN;\r\nelse\r\ntmp &= ~CMD_CFG_PROMIS_EN;\r\niowrite32be(tmp, &regs->command_config);\r\nreturn 0;\r\n}\r\nint memac_adjust_link(struct fman_mac *memac, u16 speed)\r\n{\r\nstruct memac_regs __iomem *regs = memac->regs;\r\nu32 tmp;\r\nif (!is_init_done(memac->memac_drv_param))\r\nreturn -EINVAL;\r\ntmp = ioread32be(&regs->if_mode);\r\ntmp &= ~IF_MODE_HD;\r\nif (memac->phy_if == PHY_INTERFACE_MODE_RGMII) {\r\ntmp &= ~IF_MODE_RGMII_AUTO;\r\ntmp &= ~IF_MODE_RGMII_SP_MASK;\r\ntmp |= IF_MODE_RGMII_FD;\r\nswitch (speed) {\r\ncase SPEED_1000:\r\ntmp |= IF_MODE_RGMII_1000;\r\nbreak;\r\ncase SPEED_100:\r\ntmp |= IF_MODE_RGMII_100;\r\nbreak;\r\ncase SPEED_10:\r\ntmp |= IF_MODE_RGMII_10;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\niowrite32be(tmp, &regs->if_mode);\r\nreturn 0;\r\n}\r\nint memac_cfg_max_frame_len(struct fman_mac *memac, u16 new_val)\r\n{\r\nif (is_init_done(memac->memac_drv_param))\r\nreturn -EINVAL;\r\nmemac->memac_drv_param->max_frame_length = new_val;\r\nreturn 0;\r\n}\r\nint memac_cfg_reset_on_init(struct fman_mac *memac, bool enable)\r\n{\r\nif (is_init_done(memac->memac_drv_param))\r\nreturn -EINVAL;\r\nmemac->memac_drv_param->reset_on_init = enable;\r\nreturn 0;\r\n}\r\nint memac_cfg_fixed_link(struct fman_mac *memac,\r\nstruct fixed_phy_status *fixed_link)\r\n{\r\nif (is_init_done(memac->memac_drv_param))\r\nreturn -EINVAL;\r\nmemac->memac_drv_param->fixed_link = fixed_link;\r\nreturn 0;\r\n}\r\nint memac_set_tx_pause_frames(struct fman_mac *memac, u8 priority,\r\nu16 pause_time, u16 thresh_time)\r\n{\r\nstruct memac_regs __iomem *regs = memac->regs;\r\nu32 tmp;\r\nif (!is_init_done(memac->memac_drv_param))\r\nreturn -EINVAL;\r\ntmp = ioread32be(&regs->tx_fifo_sections);\r\nGET_TX_EMPTY_DEFAULT_VALUE(tmp);\r\niowrite32be(tmp, &regs->tx_fifo_sections);\r\ntmp = ioread32be(&regs->command_config);\r\ntmp &= ~CMD_CFG_PFC_MODE;\r\npriority = 0;\r\niowrite32be(tmp, &regs->command_config);\r\ntmp = ioread32be(&regs->pause_quanta[priority / 2]);\r\nif (priority % 2)\r\ntmp &= CLXY_PAUSE_QUANTA_CLX_PQNT;\r\nelse\r\ntmp &= CLXY_PAUSE_QUANTA_CLY_PQNT;\r\ntmp |= ((u32)pause_time << (16 * (priority % 2)));\r\niowrite32be(tmp, &regs->pause_quanta[priority / 2]);\r\ntmp = ioread32be(&regs->pause_thresh[priority / 2]);\r\nif (priority % 2)\r\ntmp &= CLXY_PAUSE_THRESH_CLX_QTH;\r\nelse\r\ntmp &= CLXY_PAUSE_THRESH_CLY_QTH;\r\ntmp |= ((u32)thresh_time << (16 * (priority % 2)));\r\niowrite32be(tmp, &regs->pause_thresh[priority / 2]);\r\nreturn 0;\r\n}\r\nint memac_accept_rx_pause_frames(struct fman_mac *memac, bool en)\r\n{\r\nstruct memac_regs __iomem *regs = memac->regs;\r\nu32 tmp;\r\nif (!is_init_done(memac->memac_drv_param))\r\nreturn -EINVAL;\r\ntmp = ioread32be(&regs->command_config);\r\nif (en)\r\ntmp &= ~CMD_CFG_PAUSE_IGNORE;\r\nelse\r\ntmp |= CMD_CFG_PAUSE_IGNORE;\r\niowrite32be(tmp, &regs->command_config);\r\nreturn 0;\r\n}\r\nint memac_modify_mac_address(struct fman_mac *memac, enet_addr_t *enet_addr)\r\n{\r\nif (!is_init_done(memac->memac_drv_param))\r\nreturn -EINVAL;\r\nadd_addr_in_paddr(memac->regs, (u8 *)(*enet_addr), 0);\r\nreturn 0;\r\n}\r\nint memac_add_hash_mac_address(struct fman_mac *memac, enet_addr_t *eth_addr)\r\n{\r\nstruct memac_regs __iomem *regs = memac->regs;\r\nstruct eth_hash_entry *hash_entry;\r\nu32 hash;\r\nu64 addr;\r\nif (!is_init_done(memac->memac_drv_param))\r\nreturn -EINVAL;\r\naddr = ENET_ADDR_TO_UINT64(*eth_addr);\r\nif (!(addr & GROUP_ADDRESS)) {\r\npr_err("Unicast Address\n");\r\nreturn -EINVAL;\r\n}\r\nhash = get_mac_addr_hash_code(addr) & HASH_CTRL_ADDR_MASK;\r\nhash_entry = kmalloc(sizeof(*hash_entry), GFP_KERNEL);\r\nif (!hash_entry)\r\nreturn -ENOMEM;\r\nhash_entry->addr = addr;\r\nINIT_LIST_HEAD(&hash_entry->node);\r\nlist_add_tail(&hash_entry->node,\r\n&memac->multicast_addr_hash->lsts[hash]);\r\niowrite32be(hash | HASH_CTRL_MCAST_EN, &regs->hashtable_ctrl);\r\nreturn 0;\r\n}\r\nint memac_del_hash_mac_address(struct fman_mac *memac, enet_addr_t *eth_addr)\r\n{\r\nstruct memac_regs __iomem *regs = memac->regs;\r\nstruct eth_hash_entry *hash_entry = NULL;\r\nstruct list_head *pos;\r\nu32 hash;\r\nu64 addr;\r\nif (!is_init_done(memac->memac_drv_param))\r\nreturn -EINVAL;\r\naddr = ENET_ADDR_TO_UINT64(*eth_addr);\r\nhash = get_mac_addr_hash_code(addr) & HASH_CTRL_ADDR_MASK;\r\nlist_for_each(pos, &memac->multicast_addr_hash->lsts[hash]) {\r\nhash_entry = ETH_HASH_ENTRY_OBJ(pos);\r\nif (hash_entry->addr == addr) {\r\nlist_del_init(&hash_entry->node);\r\nkfree(hash_entry);\r\nbreak;\r\n}\r\n}\r\nif (list_empty(&memac->multicast_addr_hash->lsts[hash]))\r\niowrite32be(hash & ~HASH_CTRL_MCAST_EN, &regs->hashtable_ctrl);\r\nreturn 0;\r\n}\r\nint memac_set_exception(struct fman_mac *memac,\r\nenum fman_mac_exceptions exception, bool enable)\r\n{\r\nu32 bit_mask = 0;\r\nif (!is_init_done(memac->memac_drv_param))\r\nreturn -EINVAL;\r\nbit_mask = get_exception_flag(exception);\r\nif (bit_mask) {\r\nif (enable)\r\nmemac->exceptions |= bit_mask;\r\nelse\r\nmemac->exceptions &= ~bit_mask;\r\n} else {\r\npr_err("Undefined exception\n");\r\nreturn -EINVAL;\r\n}\r\nset_exception(memac->regs, bit_mask, enable);\r\nreturn 0;\r\n}\r\nint memac_init(struct fman_mac *memac)\r\n{\r\nstruct memac_cfg *memac_drv_param;\r\nu8 i;\r\nenet_addr_t eth_addr;\r\nbool slow_10g_if = false;\r\nstruct fixed_phy_status *fixed_link;\r\nint err;\r\nu32 reg32 = 0;\r\nif (is_init_done(memac->memac_drv_param))\r\nreturn -EINVAL;\r\nerr = check_init_parameters(memac);\r\nif (err)\r\nreturn err;\r\nmemac_drv_param = memac->memac_drv_param;\r\nif (memac->fm_rev_info.major == 6 && memac->fm_rev_info.minor == 4)\r\nslow_10g_if = true;\r\nif (memac_drv_param->reset_on_init) {\r\nerr = reset(memac->regs);\r\nif (err) {\r\npr_err("mEMAC reset failed\n");\r\nreturn err;\r\n}\r\n}\r\nMAKE_ENET_ADDR_FROM_UINT64(memac->addr, eth_addr);\r\nadd_addr_in_paddr(memac->regs, (u8 *)eth_addr, 0);\r\nfixed_link = memac_drv_param->fixed_link;\r\ninit(memac->regs, memac->memac_drv_param, memac->phy_if,\r\nmemac->max_speed, slow_10g_if, memac->exceptions);\r\nif ((memac->fm_rev_info.major == 6) &&\r\n((memac->fm_rev_info.minor == 0) ||\r\n(memac->fm_rev_info.minor == 3))) {\r\nreg32 = ioread32be(&memac->regs->command_config);\r\nreg32 &= ~CMD_CFG_CRC_FWD;\r\niowrite32be(reg32, &memac->regs->command_config);\r\n}\r\nif (memac->phy_if == PHY_INTERFACE_MODE_SGMII) {\r\nif (memac->basex_if)\r\nsetup_sgmii_internal_phy_base_x(memac);\r\nelse\r\nsetup_sgmii_internal_phy(memac, fixed_link);\r\n} else if (memac->phy_if == PHY_INTERFACE_MODE_QSGMII) {\r\nfor (i = 0; i < 4; i++) {\r\nu8 qsmgii_phy_addr, phy_addr;\r\nphy_addr = memac->pcsphy->mdio.addr;\r\nqsmgii_phy_addr = (u8)((phy_addr << 2) | i);\r\nmemac->pcsphy->mdio.addr = qsmgii_phy_addr;\r\nif (memac->basex_if)\r\nsetup_sgmii_internal_phy_base_x(memac);\r\nelse\r\nsetup_sgmii_internal_phy(memac, fixed_link);\r\nmemac->pcsphy->mdio.addr = phy_addr;\r\n}\r\n}\r\nerr = fman_set_mac_max_frame(memac->fm, memac->mac_id,\r\nmemac_drv_param->max_frame_length);\r\nif (err) {\r\npr_err("settings Mac max frame length is FAILED\n");\r\nreturn err;\r\n}\r\nmemac->multicast_addr_hash = alloc_hash_table(HASH_TABLE_SIZE);\r\nif (!memac->multicast_addr_hash) {\r\nfree_init_resources(memac);\r\npr_err("allocation hash table is FAILED\n");\r\nreturn -ENOMEM;\r\n}\r\nmemac->unicast_addr_hash = alloc_hash_table(HASH_TABLE_SIZE);\r\nif (!memac->unicast_addr_hash) {\r\nfree_init_resources(memac);\r\npr_err("allocation hash table is FAILED\n");\r\nreturn -ENOMEM;\r\n}\r\nfman_register_intr(memac->fm, FMAN_MOD_MAC, memac->mac_id,\r\nFMAN_INTR_TYPE_ERR, memac_err_exception, memac);\r\nfman_register_intr(memac->fm, FMAN_MOD_MAC, memac->mac_id,\r\nFMAN_INTR_TYPE_NORMAL, memac_exception, memac);\r\nkfree(memac_drv_param);\r\nmemac->memac_drv_param = NULL;\r\nreturn 0;\r\n}\r\nint memac_free(struct fman_mac *memac)\r\n{\r\nfree_init_resources(memac);\r\nif (memac->pcsphy)\r\nput_device(&memac->pcsphy->mdio.dev);\r\nkfree(memac->memac_drv_param);\r\nkfree(memac);\r\nreturn 0;\r\n}\r\nstruct fman_mac *memac_config(struct fman_mac_params *params)\r\n{\r\nstruct fman_mac *memac;\r\nstruct memac_cfg *memac_drv_param;\r\nvoid __iomem *base_addr;\r\nbase_addr = params->base_addr;\r\nmemac = kzalloc(sizeof(*memac), GFP_KERNEL);\r\nif (!memac)\r\nreturn NULL;\r\nmemac_drv_param = kzalloc(sizeof(*memac_drv_param), GFP_KERNEL);\r\nif (!memac_drv_param) {\r\nmemac_free(memac);\r\nreturn NULL;\r\n}\r\nmemac->memac_drv_param = memac_drv_param;\r\nset_dflts(memac_drv_param);\r\nmemac->addr = ENET_ADDR_TO_UINT64(params->addr);\r\nmemac->regs = base_addr;\r\nmemac->max_speed = params->max_speed;\r\nmemac->phy_if = params->phy_if;\r\nmemac->mac_id = params->mac_id;\r\nmemac->exceptions = (MEMAC_IMASK_TSECC_ER | MEMAC_IMASK_TECC_ER |\r\nMEMAC_IMASK_RECC_ER | MEMAC_IMASK_MGI);\r\nmemac->exception_cb = params->exception_cb;\r\nmemac->event_cb = params->event_cb;\r\nmemac->dev_id = params->dev_id;\r\nmemac->fm = params->fm;\r\nmemac->basex_if = params->basex_if;\r\nfman_get_revision(memac->fm, &memac->fm_rev_info);\r\nif (memac->phy_if == PHY_INTERFACE_MODE_SGMII ||\r\nmemac->phy_if == PHY_INTERFACE_MODE_QSGMII) {\r\nif (!params->internal_phy_node) {\r\npr_err("PCS PHY node is not available\n");\r\nmemac_free(memac);\r\nreturn NULL;\r\n}\r\nmemac->pcsphy = of_phy_find_device(params->internal_phy_node);\r\nif (!memac->pcsphy) {\r\npr_err("of_phy_find_device (PCS PHY) failed\n");\r\nmemac_free(memac);\r\nreturn NULL;\r\n}\r\n}\r\nreturn memac;\r\n}
