void zip_reg_write(u64 val, u64 __iomem *addr)\r\n{\r\nwriteq(val, addr);\r\n}\r\nu64 zip_reg_read(u64 __iomem *addr)\r\n{\r\nreturn readq(addr);\r\n}\r\nstatic struct zip_device *zip_alloc_device(struct pci_dev *pdev)\r\n{\r\nstruct zip_device *zip = NULL;\r\nint idx;\r\nfor (idx = 0; idx < MAX_ZIP_DEVICES; idx++) {\r\nif (!zip_dev[idx])\r\nbreak;\r\n}\r\nif (idx < MAX_ZIP_DEVICES)\r\nzip = devm_kzalloc(&pdev->dev, sizeof(*zip), GFP_KERNEL);\r\nif (!zip)\r\nreturn NULL;\r\nzip_dev[idx] = zip;\r\nzip->index = idx;\r\nreturn zip;\r\n}\r\nstruct zip_device *zip_get_device(int node)\r\n{\r\nif ((node < MAX_ZIP_DEVICES) && (node >= 0))\r\nreturn zip_dev[node];\r\nzip_err("ZIP device not found for node id %d\n", node);\r\nreturn NULL;\r\n}\r\nint zip_get_node_id(void)\r\n{\r\nreturn cpu_to_node(smp_processor_id());\r\n}\r\nstatic int zip_init_hw(struct zip_device *zip)\r\n{\r\nunion zip_cmd_ctl cmd_ctl;\r\nunion zip_constants constants;\r\nunion zip_que_ena que_ena;\r\nunion zip_quex_map que_map;\r\nunion zip_que_pri que_pri;\r\nunion zip_quex_sbuf_addr que_sbuf_addr;\r\nunion zip_quex_sbuf_ctl que_sbuf_ctl;\r\nint q = 0;\r\ncmd_ctl.u_reg64 = zip_reg_read(zip->reg_base + ZIP_CMD_CTL);\r\ncmd_ctl.s.forceclk = 1;\r\nzip_reg_write(cmd_ctl.u_reg64 & 0xFF, (zip->reg_base + ZIP_CMD_CTL));\r\nzip_msg("ZIP_CMD_CTL : 0x%016llx",\r\nzip_reg_read(zip->reg_base + ZIP_CMD_CTL));\r\nconstants.u_reg64 = zip_reg_read(zip->reg_base + ZIP_CONSTANTS);\r\nzip->depth = constants.s.depth;\r\nzip->onfsize = constants.s.onfsize;\r\nzip->ctxsize = constants.s.ctxsize;\r\nzip_msg("depth: 0x%016llx , onfsize : 0x%016llx , ctxsize : 0x%016llx",\r\nzip->depth, zip->onfsize, zip->ctxsize);\r\nfor (q = 0; q < ZIP_NUM_QUEUES; q++) {\r\nque_sbuf_ctl.u_reg64 = 0ull;\r\nque_sbuf_ctl.s.size = (ZIP_CMD_QBUF_SIZE / sizeof(u64));\r\nque_sbuf_ctl.s.inst_be = 0;\r\nque_sbuf_ctl.s.stream_id = 0;\r\nzip_reg_write(que_sbuf_ctl.u_reg64,\r\n(zip->reg_base + ZIP_QUEX_SBUF_CTL(q)));\r\nzip_msg("QUEX_SBUF_CTL[%d]: 0x%016llx", q,\r\nzip_reg_read(zip->reg_base + ZIP_QUEX_SBUF_CTL(q)));\r\n}\r\nfor (q = 0; q < ZIP_NUM_QUEUES; q++) {\r\nmemset(&zip->iq[q], 0x0, sizeof(struct zip_iq));\r\nspin_lock_init(&zip->iq[q].lock);\r\nif (zip_cmd_qbuf_alloc(zip, q)) {\r\nwhile (q != 0) {\r\nq--;\r\nzip_cmd_qbuf_free(zip, q);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nzip->iq[q].sw_tail = zip->iq[q].sw_head;\r\nzip->iq[q].hw_tail = zip->iq[q].sw_head;\r\nque_sbuf_addr.u_reg64 = 0ull;\r\nque_sbuf_addr.s.ptr = (__pa(zip->iq[q].sw_head) >>\r\nZIP_128B_ALIGN);\r\nzip_msg("QUE[%d]_PTR(PHYS): 0x%016llx", q,\r\n(u64)que_sbuf_addr.s.ptr);\r\nzip_reg_write(que_sbuf_addr.u_reg64,\r\n(zip->reg_base + ZIP_QUEX_SBUF_ADDR(q)));\r\nzip_msg("QUEX_SBUF_ADDR[%d]: 0x%016llx", q,\r\nzip_reg_read(zip->reg_base + ZIP_QUEX_SBUF_ADDR(q)));\r\nzip_dbg("sw_head :0x%lx sw_tail :0x%lx hw_tail :0x%lx",\r\nzip->iq[q].sw_head, zip->iq[q].sw_tail,\r\nzip->iq[q].hw_tail);\r\nzip_dbg("sw_head phy addr : 0x%lx", que_sbuf_addr.s.ptr);\r\n}\r\nque_ena.u_reg64 = 0x0ull;\r\nfor (q = 0; q < ZIP_NUM_QUEUES; q++)\r\nque_ena.s.ena |= (0x1 << q);\r\nzip_reg_write(que_ena.u_reg64, (zip->reg_base + ZIP_QUE_ENA));\r\nzip_msg("QUE_ENA : 0x%016llx",\r\nzip_reg_read(zip->reg_base + ZIP_QUE_ENA));\r\nfor (q = 0; q < ZIP_NUM_QUEUES; q++) {\r\nque_map.u_reg64 = 0ull;\r\nque_map.s.zce = 0x3;\r\nzip_reg_write(que_map.u_reg64,\r\n(zip->reg_base + ZIP_QUEX_MAP(q)));\r\nzip_msg("QUE_MAP(%d) : 0x%016llx", q,\r\nzip_reg_read(zip->reg_base + ZIP_QUEX_MAP(q)));\r\n}\r\nque_pri.u_reg64 = 0ull;\r\nfor (q = 0; q < ZIP_NUM_QUEUES; q++)\r\nque_pri.s.pri |= (0x1 << q);\r\nzip_reg_write(que_pri.u_reg64, (zip->reg_base + ZIP_QUE_PRI));\r\nzip_msg("QUE_PRI %016llx", zip_reg_read(zip->reg_base + ZIP_QUE_PRI));\r\nreturn 0;\r\n}\r\nstatic int zip_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct zip_device *zip = NULL;\r\nint err;\r\nzip = zip_alloc_device(pdev);\r\nif (!zip)\r\nreturn -ENOMEM;\r\ndev_info(dev, "Found ZIP device %d %x:%x on Node %d\n", zip->index,\r\npdev->vendor, pdev->device, dev_to_node(dev));\r\npci_set_drvdata(pdev, zip);\r\nzip->pdev = pdev;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(dev, "Failed to enable PCI device");\r\ngoto err_free_device;\r\n}\r\nerr = pci_request_regions(pdev, DRV_NAME);\r\nif (err) {\r\ndev_err(dev, "PCI request regions failed 0x%x", err);\r\ngoto err_disable_device;\r\n}\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(48));\r\nif (err) {\r\ndev_err(dev, "Unable to get usable DMA configuration\n");\r\ngoto err_release_regions;\r\n}\r\nerr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(48));\r\nif (err) {\r\ndev_err(dev, "Unable to get 48-bit DMA for allocations\n");\r\ngoto err_release_regions;\r\n}\r\nzip->reg_base = pci_ioremap_bar(pdev, PCI_CFG_ZIP_PF_BAR0);\r\nif (!zip->reg_base) {\r\ndev_err(dev, "ZIP: Cannot map BAR0 CSR memory space, aborting");\r\nerr = -ENOMEM;\r\ngoto err_release_regions;\r\n}\r\nerr = zip_init_hw(zip);\r\nif (err)\r\ngoto err_release_regions;\r\nreturn 0;\r\nerr_release_regions:\r\nif (zip->reg_base)\r\niounmap(zip->reg_base);\r\npci_release_regions(pdev);\r\nerr_disable_device:\r\npci_disable_device(pdev);\r\nerr_free_device:\r\npci_set_drvdata(pdev, NULL);\r\nzip_dev[zip->index] = NULL;\r\ndevm_kfree(dev, zip);\r\nreturn err;\r\n}\r\nstatic void zip_remove(struct pci_dev *pdev)\r\n{\r\nstruct zip_device *zip = pci_get_drvdata(pdev);\r\nunion zip_cmd_ctl cmd_ctl;\r\nint q = 0;\r\nif (!zip)\r\nreturn;\r\nif (zip->reg_base) {\r\ncmd_ctl.u_reg64 = 0x0ull;\r\ncmd_ctl.s.reset = 1;\r\nzip_reg_write(cmd_ctl.u_reg64, (zip->reg_base + ZIP_CMD_CTL));\r\niounmap(zip->reg_base);\r\n}\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nfor (q = 0; q < ZIP_NUM_QUEUES; q++)\r\nzip_cmd_qbuf_free(zip, q);\r\npci_set_drvdata(pdev, NULL);\r\nzip_dev[zip->index] = NULL;\r\n}\r\nstatic int zip_register_compression_device(void)\r\n{\r\nint ret;\r\nret = crypto_register_alg(&zip_comp_deflate);\r\nif (ret < 0) {\r\nzip_err("Deflate algorithm registration failed\n");\r\nreturn ret;\r\n}\r\nret = crypto_register_alg(&zip_comp_lzs);\r\nif (ret < 0) {\r\nzip_err("LZS algorithm registration failed\n");\r\ngoto err_unregister_alg_deflate;\r\n}\r\nret = crypto_register_scomp(&zip_scomp_deflate);\r\nif (ret < 0) {\r\nzip_err("Deflate scomp algorithm registration failed\n");\r\ngoto err_unregister_alg_lzs;\r\n}\r\nret = crypto_register_scomp(&zip_scomp_lzs);\r\nif (ret < 0) {\r\nzip_err("LZS scomp algorithm registration failed\n");\r\ngoto err_unregister_scomp_deflate;\r\n}\r\nreturn ret;\r\nerr_unregister_scomp_deflate:\r\ncrypto_unregister_scomp(&zip_scomp_deflate);\r\nerr_unregister_alg_lzs:\r\ncrypto_unregister_alg(&zip_comp_lzs);\r\nerr_unregister_alg_deflate:\r\ncrypto_unregister_alg(&zip_comp_deflate);\r\nreturn ret;\r\n}\r\nstatic void zip_unregister_compression_device(void)\r\n{\r\ncrypto_unregister_alg(&zip_comp_deflate);\r\ncrypto_unregister_alg(&zip_comp_lzs);\r\ncrypto_unregister_scomp(&zip_scomp_deflate);\r\ncrypto_unregister_scomp(&zip_scomp_lzs);\r\n}\r\nstatic int zip_show_stats(struct seq_file *s, void *unused)\r\n{\r\nu64 val = 0ull;\r\nu64 avg_chunk = 0ull, avg_cr = 0ull;\r\nu32 q = 0;\r\nint index = 0;\r\nstruct zip_device *zip;\r\nstruct zip_stats *st;\r\nfor (index = 0; index < MAX_ZIP_DEVICES; index++) {\r\nif (zip_dev[index]) {\r\nzip = zip_dev[index];\r\nst = &zip->stats;\r\nfor (q = 0; q < ZIP_NUM_QUEUES; q++) {\r\nval = zip_reg_read((zip->reg_base +\r\nZIP_DBG_COREX_STA(q)));\r\nval = (val >> 32);\r\nval = val & 0xffffff;\r\natomic64_add(val, &st->pending_req);\r\n}\r\navg_chunk = (atomic64_read(&st->comp_in_bytes) /\r\natomic64_read(&st->comp_req_complete));\r\navg_cr = (atomic64_read(&st->comp_in_bytes) /\r\natomic64_read(&st->comp_out_bytes));\r\nseq_printf(s, " ZIP Device %d Stats\n"\r\n"-----------------------------------\n"\r\n"Comp Req Submitted : \t%lld\n"\r\n"Comp Req Completed : \t%lld\n"\r\n"Compress In Bytes : \t%lld\n"\r\n"Compressed Out Bytes : \t%lld\n"\r\n"Average Chunk size : \t%llu\n"\r\n"Average Compression ratio : \t%llu\n"\r\n"Decomp Req Submitted : \t%lld\n"\r\n"Decomp Req Completed : \t%lld\n"\r\n"Decompress In Bytes : \t%lld\n"\r\n"Decompressed Out Bytes : \t%lld\n"\r\n"Decompress Bad requests : \t%lld\n"\r\n"Pending Req : \t%lld\n"\r\n"---------------------------------\n",\r\nindex,\r\n(u64)atomic64_read(&st->comp_req_submit),\r\n(u64)atomic64_read(&st->comp_req_complete),\r\n(u64)atomic64_read(&st->comp_in_bytes),\r\n(u64)atomic64_read(&st->comp_out_bytes),\r\navg_chunk,\r\navg_cr,\r\n(u64)atomic64_read(&st->decomp_req_submit),\r\n(u64)atomic64_read(&st->decomp_req_complete),\r\n(u64)atomic64_read(&st->decomp_in_bytes),\r\n(u64)atomic64_read(&st->decomp_out_bytes),\r\n(u64)atomic64_read(&st->decomp_bad_reqs),\r\n(u64)atomic64_read(&st->pending_req));\r\natomic64_set(&st->pending_req, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int zip_clear_stats(struct seq_file *s, void *unused)\r\n{\r\nint index = 0;\r\nfor (index = 0; index < MAX_ZIP_DEVICES; index++) {\r\nif (zip_dev[index]) {\r\nmemset(&zip_dev[index]->stats, 0,\r\nsizeof(struct zip_stats));\r\nseq_printf(s, "Cleared stats for zip %d\n", index);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int zip_print_regs(struct seq_file *s, void *unused)\r\n{\r\nu64 val = 0;\r\nint i = 0, index = 0;\r\nfor (index = 0; index < MAX_ZIP_DEVICES; index++) {\r\nif (zip_dev[index]) {\r\nseq_printf(s, "--------------------------------\n"\r\n" ZIP Device %d Registers\n"\r\n"--------------------------------\n",\r\nindex);\r\ni = 0;\r\nwhile (zipregs[i].reg_name) {\r\nval = zip_reg_read((zip_dev[index]->reg_base +\r\nzipregs[i].reg_offset));\r\nseq_printf(s, "%s: 0x%016llx\n",\r\nzipregs[i].reg_name, val);\r\ni++;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int zip_stats_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, zip_show_stats, NULL);\r\n}\r\nstatic int zip_clear_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, zip_clear_stats, NULL);\r\n}\r\nstatic int zip_regs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, zip_print_regs, NULL);\r\n}\r\nstatic int __init zip_debugfs_init(void)\r\n{\r\nstruct dentry *zip_stats, *zip_clear, *zip_regs;\r\nif (!debugfs_initialized())\r\nreturn -ENODEV;\r\nzip_debugfs_root = debugfs_create_dir("thunderx_zip", NULL);\r\nif (!zip_debugfs_root)\r\nreturn -ENOMEM;\r\nzip_stats = debugfs_create_file("zip_stats", 0444,\r\nzip_debugfs_root,\r\nNULL, &zip_stats_fops);\r\nif (!zip_stats)\r\ngoto failed_to_create;\r\nzip_clear = debugfs_create_file("zip_clear", 0444,\r\nzip_debugfs_root,\r\nNULL, &zip_clear_fops);\r\nif (!zip_clear)\r\ngoto failed_to_create;\r\nzip_regs = debugfs_create_file("zip_regs", 0444,\r\nzip_debugfs_root,\r\nNULL, &zip_regs_fops);\r\nif (!zip_regs)\r\ngoto failed_to_create;\r\nreturn 0;\r\nfailed_to_create:\r\ndebugfs_remove_recursive(zip_debugfs_root);\r\nreturn -ENOENT;\r\n}\r\nstatic void __exit zip_debugfs_exit(void)\r\n{\r\ndebugfs_remove_recursive(zip_debugfs_root);\r\n}\r\nstatic int __init zip_debugfs_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit zip_debugfs_exit(void) { }\r\nstatic int __init zip_init_module(void)\r\n{\r\nint ret;\r\nzip_msg("%s\n", DRV_NAME);\r\nret = pci_register_driver(&zip_driver);\r\nif (ret < 0) {\r\nzip_err("ZIP: pci_register_driver() failed\n");\r\nreturn ret;\r\n}\r\nret = zip_register_compression_device();\r\nif (ret < 0) {\r\nzip_err("ZIP: Kernel Crypto Registration failed\n");\r\ngoto err_pci_unregister;\r\n}\r\nret = zip_debugfs_init();\r\nif (ret < 0) {\r\nzip_err("ZIP: debugfs initialization failed\n");\r\ngoto err_crypto_unregister;\r\n}\r\nreturn ret;\r\nerr_crypto_unregister:\r\nzip_unregister_compression_device();\r\nerr_pci_unregister:\r\npci_unregister_driver(&zip_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit zip_cleanup_module(void)\r\n{\r\nzip_debugfs_exit();\r\nzip_unregister_compression_device();\r\npci_unregister_driver(&zip_driver);\r\n}
