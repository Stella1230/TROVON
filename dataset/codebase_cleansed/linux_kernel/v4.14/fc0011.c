static int fc0011_writereg(struct fc0011_priv *priv, u8 reg, u8 val)\r\n{\r\nu8 buf[2] = { reg, val };\r\nstruct i2c_msg msg = { .addr = priv->addr,\r\n.flags = 0, .buf = buf, .len = 2 };\r\nif (i2c_transfer(priv->i2c, &msg, 1) != 1) {\r\ndev_err(&priv->i2c->dev,\r\n"I2C write reg failed, reg: %02x, val: %02x\n",\r\nreg, val);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fc0011_readreg(struct fc0011_priv *priv, u8 reg, u8 *val)\r\n{\r\nu8 dummy;\r\nstruct i2c_msg msg[2] = {\r\n{ .addr = priv->addr,\r\n.flags = 0, .buf = &reg, .len = 1 },\r\n{ .addr = priv->addr,\r\n.flags = I2C_M_RD, .buf = val ? : &dummy, .len = 1 },\r\n};\r\nif (i2c_transfer(priv->i2c, msg, 2) != 2) {\r\ndev_err(&priv->i2c->dev,\r\n"I2C read failed, reg: %02x\n", reg);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fc0011_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\n}\r\nstatic int fc0011_init(struct dvb_frontend *fe)\r\n{\r\nstruct fc0011_priv *priv = fe->tuner_priv;\r\nint err;\r\nif (WARN_ON(!fe->callback))\r\nreturn -EINVAL;\r\nerr = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\r\nFC0011_FE_CALLBACK_POWER, priv->addr);\r\nif (err) {\r\ndev_err(&priv->i2c->dev, "Power-on callback failed\n");\r\nreturn err;\r\n}\r\nerr = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\r\nFC0011_FE_CALLBACK_RESET, priv->addr);\r\nif (err) {\r\ndev_err(&priv->i2c->dev, "Reset callback failed\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fc0011_vcocal_trigger(struct fc0011_priv *priv)\r\n{\r\nint err;\r\nerr = fc0011_writereg(priv, FC11_REG_VCOCAL, FC11_VCOCAL_RESET);\r\nif (err)\r\nreturn err;\r\nerr = fc0011_writereg(priv, FC11_REG_VCOCAL, FC11_VCOCAL_RUN);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int fc0011_vcocal_read(struct fc0011_priv *priv, u8 *value)\r\n{\r\nint err;\r\nerr = fc0011_writereg(priv, FC11_REG_VCOCAL, FC11_VCOCAL_RUN);\r\nif (err)\r\nreturn err;\r\nusleep_range(10000, 20000);\r\nerr = fc0011_readreg(priv, FC11_REG_VCOCAL, value);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int fc0011_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct fc0011_priv *priv = fe->tuner_priv;\r\nint err;\r\nunsigned int i, vco_retries;\r\nu32 freq = p->frequency / 1000;\r\nu32 bandwidth = p->bandwidth_hz / 1000;\r\nu32 fvco, xin, frac, xdiv, xdivr;\r\nu8 fa, fp, vco_sel, vco_cal;\r\nu8 regs[FC11_NR_REGS] = { };\r\nregs[FC11_REG_7] = 0x0F;\r\nregs[FC11_REG_8] = 0x3E;\r\nregs[FC11_REG_10] = 0xB8;\r\nregs[FC11_REG_11] = 0x80;\r\nregs[FC11_REG_RCCAL] = 0x04;\r\nerr = fc0011_writereg(priv, FC11_REG_7, regs[FC11_REG_7]);\r\nerr |= fc0011_writereg(priv, FC11_REG_8, regs[FC11_REG_8]);\r\nerr |= fc0011_writereg(priv, FC11_REG_10, regs[FC11_REG_10]);\r\nerr |= fc0011_writereg(priv, FC11_REG_11, regs[FC11_REG_11]);\r\nerr |= fc0011_writereg(priv, FC11_REG_RCCAL, regs[FC11_REG_RCCAL]);\r\nif (err)\r\nreturn -EIO;\r\nif (freq < 54000) {\r\nfvco = freq * 64;\r\nregs[FC11_REG_VCO] = 0x82;\r\n} else if (freq < 108000) {\r\nfvco = freq * 32;\r\nregs[FC11_REG_VCO] = 0x42;\r\n} else if (freq < 216000) {\r\nfvco = freq * 16;\r\nregs[FC11_REG_VCO] = 0x22;\r\n} else if (freq < 432000) {\r\nfvco = freq * 8;\r\nregs[FC11_REG_VCO] = 0x12;\r\n} else {\r\nfvco = freq * 4;\r\nregs[FC11_REG_VCO] = 0x0A;\r\n}\r\nxdiv = fvco / 18000;\r\nWARN_ON(xdiv > 0xFF);\r\nfrac = fvco - xdiv * 18000;\r\nfrac = (frac << 15) / 18000;\r\nif (frac >= 16384)\r\nfrac += 32786;\r\nif (!frac)\r\nxin = 0;\r\nelse\r\nxin = clamp_t(u32, frac, 512, 65024);\r\nregs[FC11_REG_XINHI] = xin >> 8;\r\nregs[FC11_REG_XINLO] = xin;\r\nxdivr = xdiv;\r\nif (fvco - xdiv * 18000 >= 9000)\r\nxdivr += 1;\r\nfp = xdivr / 8;\r\nfa = xdivr - fp * 8;\r\nif (fa < 2) {\r\nfp -= 1;\r\nfa += 8;\r\n}\r\nif (fp > 0x1F) {\r\nfp = 0x1F;\r\nfa = 0xF;\r\n}\r\nif (fa >= fp) {\r\ndev_warn(&priv->i2c->dev,\r\n"fa %02X >= fp %02X, but trying to continue\n",\r\n(unsigned int)(u8)fa, (unsigned int)(u8)fp);\r\n}\r\nregs[FC11_REG_FA] = fa;\r\nregs[FC11_REG_FP] = fp;\r\nswitch (bandwidth) {\r\ncase 8000:\r\nbreak;\r\ncase 7000:\r\nregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_BW7M;\r\nbreak;\r\ndefault:\r\ndev_warn(&priv->i2c->dev, "Unsupported bandwidth %u kHz. Using 6000 kHz.\n",\r\nbandwidth);\r\nbandwidth = 6000;\r\ncase 6000:\r\nregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_BW6M;\r\nbreak;\r\n}\r\nif (fvco < 2320000) {\r\nvco_sel = 0;\r\nregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\r\n} else if (fvco < 3080000) {\r\nvco_sel = 1;\r\nregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\r\nregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_1;\r\n} else {\r\nvco_sel = 2;\r\nregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\r\nregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_2;\r\n}\r\nif (freq < 45000) {\r\nregs[FC11_REG_FA] = 0x6;\r\nregs[FC11_REG_FP] = 0x11;\r\n}\r\nregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_CLKOUT;\r\nfor (i = FC11_REG_FA; i <= FC11_REG_VCOSEL; i++) {\r\nerr = fc0011_writereg(priv, i, regs[i]);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = fc0011_vcocal_trigger(priv);\r\nif (err)\r\nreturn err;\r\nerr = fc0011_vcocal_read(priv, &vco_cal);\r\nif (err)\r\nreturn err;\r\nvco_retries = 0;\r\nwhile (!(vco_cal & FC11_VCOCAL_OK) && vco_retries < 3) {\r\nerr = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\r\nFC0011_FE_CALLBACK_RESET, priv->addr);\r\nif (err) {\r\ndev_err(&priv->i2c->dev, "Failed to reset tuner\n");\r\nreturn err;\r\n}\r\nerr = 0;\r\nfor (i = FC11_REG_FA; i <= FC11_REG_VCOSEL; i++)\r\nerr |= fc0011_writereg(priv, i, regs[i]);\r\nerr |= fc0011_writereg(priv, FC11_REG_7, regs[FC11_REG_7]);\r\nerr |= fc0011_writereg(priv, FC11_REG_8, regs[FC11_REG_8]);\r\nerr |= fc0011_writereg(priv, FC11_REG_10, regs[FC11_REG_10]);\r\nerr |= fc0011_writereg(priv, FC11_REG_11, regs[FC11_REG_11]);\r\nerr |= fc0011_writereg(priv, FC11_REG_RCCAL, regs[FC11_REG_RCCAL]);\r\nif (err)\r\nreturn -EIO;\r\nerr = fc0011_vcocal_trigger(priv);\r\nif (err)\r\nreturn err;\r\nerr = fc0011_vcocal_read(priv, &vco_cal);\r\nif (err)\r\nreturn err;\r\nvco_retries++;\r\n}\r\nif (!(vco_cal & FC11_VCOCAL_OK)) {\r\ndev_err(&priv->i2c->dev,\r\n"Failed to read VCO calibration value (got %02X)\n",\r\n(unsigned int)vco_cal);\r\nreturn -EIO;\r\n}\r\nvco_cal &= FC11_VCOCAL_VALUEMASK;\r\nswitch (vco_sel) {\r\ndefault:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\ncase 0:\r\nif (vco_cal < 8) {\r\nregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\r\nregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_1;\r\nerr = fc0011_writereg(priv, FC11_REG_VCOSEL,\r\nregs[FC11_REG_VCOSEL]);\r\nif (err)\r\nreturn err;\r\nerr = fc0011_vcocal_trigger(priv);\r\nif (err)\r\nreturn err;\r\n} else {\r\nregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\r\nerr = fc0011_writereg(priv, FC11_REG_VCOSEL,\r\nregs[FC11_REG_VCOSEL]);\r\nif (err)\r\nreturn err;\r\n}\r\nbreak;\r\ncase 1:\r\nif (vco_cal < 5) {\r\nregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\r\nregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_2;\r\nerr = fc0011_writereg(priv, FC11_REG_VCOSEL,\r\nregs[FC11_REG_VCOSEL]);\r\nif (err)\r\nreturn err;\r\nerr = fc0011_vcocal_trigger(priv);\r\nif (err)\r\nreturn err;\r\n} else if (vco_cal <= 48) {\r\nregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\r\nregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_1;\r\nerr = fc0011_writereg(priv, FC11_REG_VCOSEL,\r\nregs[FC11_REG_VCOSEL]);\r\nif (err)\r\nreturn err;\r\n} else {\r\nregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\r\nerr = fc0011_writereg(priv, FC11_REG_VCOSEL,\r\nregs[FC11_REG_VCOSEL]);\r\nif (err)\r\nreturn err;\r\nerr = fc0011_vcocal_trigger(priv);\r\nif (err)\r\nreturn err;\r\n}\r\nbreak;\r\ncase 2:\r\nif (vco_cal > 53) {\r\nregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\r\nregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_1;\r\nerr = fc0011_writereg(priv, FC11_REG_VCOSEL,\r\nregs[FC11_REG_VCOSEL]);\r\nif (err)\r\nreturn err;\r\nerr = fc0011_vcocal_trigger(priv);\r\nif (err)\r\nreturn err;\r\n} else {\r\nregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\r\nregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_2;\r\nerr = fc0011_writereg(priv, FC11_REG_VCOSEL,\r\nregs[FC11_REG_VCOSEL]);\r\nif (err)\r\nreturn err;\r\n}\r\nbreak;\r\n}\r\nerr = fc0011_vcocal_read(priv, NULL);\r\nif (err)\r\nreturn err;\r\nusleep_range(10000, 50000);\r\nerr = fc0011_readreg(priv, FC11_REG_RCCAL, &regs[FC11_REG_RCCAL]);\r\nif (err)\r\nreturn err;\r\nregs[FC11_REG_RCCAL] |= FC11_RCCAL_FORCE;\r\nerr = fc0011_writereg(priv, FC11_REG_RCCAL, regs[FC11_REG_RCCAL]);\r\nif (err)\r\nreturn err;\r\nregs[FC11_REG_16] = 0xB;\r\nerr = fc0011_writereg(priv, FC11_REG_16, regs[FC11_REG_16]);\r\nif (err)\r\nreturn err;\r\ndev_dbg(&priv->i2c->dev, "Tuned to fa=%02X fp=%02X xin=%02X%02X vco=%02X vcosel=%02X vcocal=%02X(%u) bw=%u\n",\r\n(unsigned int)regs[FC11_REG_FA],\r\n(unsigned int)regs[FC11_REG_FP],\r\n(unsigned int)regs[FC11_REG_XINHI],\r\n(unsigned int)regs[FC11_REG_XINLO],\r\n(unsigned int)regs[FC11_REG_VCO],\r\n(unsigned int)regs[FC11_REG_VCOSEL],\r\n(unsigned int)vco_cal, vco_retries,\r\n(unsigned int)bandwidth);\r\npriv->frequency = p->frequency;\r\npriv->bandwidth = p->bandwidth_hz;\r\nreturn 0;\r\n}\r\nstatic int fc0011_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct fc0011_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency;\r\nreturn 0;\r\n}\r\nstatic int fc0011_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\n*frequency = 0;\r\nreturn 0;\r\n}\r\nstatic int fc0011_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\r\n{\r\nstruct fc0011_priv *priv = fe->tuner_priv;\r\n*bandwidth = priv->bandwidth;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *fc0011_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c,\r\nconst struct fc0011_config *config)\r\n{\r\nstruct fc0011_priv *priv;\r\npriv = kzalloc(sizeof(struct fc0011_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn NULL;\r\npriv->i2c = i2c;\r\npriv->addr = config->i2c_address;\r\nfe->tuner_priv = priv;\r\nfe->ops.tuner_ops = fc0011_tuner_ops;\r\ndev_info(&priv->i2c->dev, "Fitipower FC0011 tuner attached\n");\r\nreturn fe;\r\n}
