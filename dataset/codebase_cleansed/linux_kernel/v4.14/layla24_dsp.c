static int init_hw(struct echoaudio *chip, u16 device_id, u16 subdevice_id)\r\n{\r\nint err;\r\nif (snd_BUG_ON((subdevice_id & 0xfff0) != LAYLA24))\r\nreturn -ENODEV;\r\nif ((err = init_dsp_comm_page(chip))) {\r\ndev_err(chip->card->dev,\r\n"init_hw - could not initialize DSP comm page\n");\r\nreturn err;\r\n}\r\nchip->device_id = device_id;\r\nchip->subdevice_id = subdevice_id;\r\nchip->bad_board = true;\r\nchip->has_midi = true;\r\nchip->dsp_code_to_load = FW_LAYLA24_DSP;\r\nchip->input_clock_types =\r\nECHO_CLOCK_BIT_INTERNAL | ECHO_CLOCK_BIT_SPDIF |\r\nECHO_CLOCK_BIT_WORD | ECHO_CLOCK_BIT_ADAT;\r\nchip->digital_modes =\r\nECHOCAPS_HAS_DIGITAL_MODE_SPDIF_RCA |\r\nECHOCAPS_HAS_DIGITAL_MODE_SPDIF_OPTICAL |\r\nECHOCAPS_HAS_DIGITAL_MODE_ADAT;\r\nif ((err = load_firmware(chip)) < 0)\r\nreturn err;\r\nchip->bad_board = false;\r\nif ((err = init_line_levels(chip)) < 0)\r\nreturn err;\r\nreturn err;\r\n}\r\nstatic int set_mixer_defaults(struct echoaudio *chip)\r\n{\r\nchip->digital_mode = DIGITAL_MODE_SPDIF_RCA;\r\nchip->professional_spdif = false;\r\nchip->digital_in_automute = true;\r\nreturn init_line_levels(chip);\r\n}\r\nstatic u32 detect_input_clocks(const struct echoaudio *chip)\r\n{\r\nu32 clocks_from_dsp, clock_bits;\r\nclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\r\nclock_bits = ECHO_CLOCK_BIT_INTERNAL;\r\nif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_SPDIF)\r\nclock_bits |= ECHO_CLOCK_BIT_SPDIF;\r\nif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_ADAT)\r\nclock_bits |= ECHO_CLOCK_BIT_ADAT;\r\nif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_WORD)\r\nclock_bits |= ECHO_CLOCK_BIT_WORD;\r\nreturn clock_bits;\r\n}\r\nstatic int load_asic(struct echoaudio *chip)\r\n{\r\nint err;\r\nif (chip->asic_loaded)\r\nreturn 1;\r\nmdelay(10);\r\nerr = load_asic_generic(chip, DSP_FNC_LOAD_LAYLA24_PCI_CARD_ASIC,\r\nFW_LAYLA24_1_ASIC);\r\nif (err < 0)\r\nreturn err;\r\nchip->asic_code = FW_LAYLA24_2S_ASIC;\r\nmdelay(10);\r\nerr = load_asic_generic(chip, DSP_FNC_LOAD_LAYLA24_EXTERNAL_ASIC,\r\nFW_LAYLA24_2S_ASIC);\r\nif (err < 0)\r\nreturn err;\r\nmdelay(10);\r\nerr = check_asic_status(chip);\r\nif (!err)\r\nerr = write_control_reg(chip, GML_CONVERTER_ENABLE | GML_48KHZ,\r\ntrue);\r\nreturn err;\r\n}\r\nstatic int set_sample_rate(struct echoaudio *chip, u32 rate)\r\n{\r\nu32 control_reg, clock, base_rate;\r\nif (snd_BUG_ON(rate >= 50000 &&\r\nchip->digital_mode == DIGITAL_MODE_ADAT))\r\nreturn -EINVAL;\r\nif (chip->input_clock != ECHO_CLOCK_INTERNAL) {\r\ndev_warn(chip->card->dev,\r\n"Cannot set sample rate - clock not set to CLK_CLOCKININTERNAL\n");\r\nchip->comm_page->sample_rate = cpu_to_le32(rate);\r\nchip->sample_rate = rate;\r\nreturn 0;\r\n}\r\ncontrol_reg = le32_to_cpu(chip->comm_page->control_register);\r\ncontrol_reg &= GML_CLOCK_CLEAR_MASK & GML_SPDIF_RATE_CLEAR_MASK;\r\nclock = 0;\r\nswitch (rate) {\r\ncase 96000:\r\nclock = GML_96KHZ;\r\nbreak;\r\ncase 88200:\r\nclock = GML_88KHZ;\r\nbreak;\r\ncase 48000:\r\nclock = GML_48KHZ | GML_SPDIF_SAMPLE_RATE1;\r\nbreak;\r\ncase 44100:\r\nclock = GML_44KHZ;\r\nif (control_reg & GML_SPDIF_PRO_MODE)\r\nclock |= GML_SPDIF_SAMPLE_RATE0;\r\nbreak;\r\ncase 32000:\r\nclock = GML_32KHZ | GML_SPDIF_SAMPLE_RATE0 |\r\nGML_SPDIF_SAMPLE_RATE1;\r\nbreak;\r\ncase 22050:\r\nclock = GML_22KHZ;\r\nbreak;\r\ncase 16000:\r\nclock = GML_16KHZ;\r\nbreak;\r\ncase 11025:\r\nclock = GML_11KHZ;\r\nbreak;\r\ncase 8000:\r\nclock = GML_8KHZ;\r\nbreak;\r\ndefault:\r\nclock = LAYLA24_CONTINUOUS_CLOCK;\r\nif (rate > 50000) {\r\nbase_rate = rate >> 1;\r\ncontrol_reg |= GML_DOUBLE_SPEED_MODE;\r\n} else {\r\nbase_rate = rate;\r\n}\r\nif (base_rate < 25000)\r\nbase_rate = 25000;\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->comm_page->sample_rate =\r\ncpu_to_le32(LAYLA24_MAGIC_NUMBER / base_rate - 2);\r\nclear_handshake(chip);\r\nsend_vector(chip, DSP_VC_SET_LAYLA24_FREQUENCY_REG);\r\n}\r\ncontrol_reg |= clock;\r\nchip->comm_page->sample_rate = cpu_to_le32(rate);\r\nchip->sample_rate = rate;\r\ndev_dbg(chip->card->dev,\r\n"set_sample_rate: %d clock %d\n", rate, control_reg);\r\nreturn write_control_reg(chip, control_reg, false);\r\n}\r\nstatic int set_input_clock(struct echoaudio *chip, u16 clock)\r\n{\r\nu32 control_reg, clocks_from_dsp;\r\ncontrol_reg = le32_to_cpu(chip->comm_page->control_register) &\r\nGML_CLOCK_CLEAR_MASK;\r\nclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\r\nswitch (clock) {\r\ncase ECHO_CLOCK_INTERNAL:\r\nchip->input_clock = ECHO_CLOCK_INTERNAL;\r\nreturn set_sample_rate(chip, chip->sample_rate);\r\ncase ECHO_CLOCK_SPDIF:\r\nif (chip->digital_mode == DIGITAL_MODE_ADAT)\r\nreturn -EAGAIN;\r\ncontrol_reg |= GML_SPDIF_CLOCK;\r\ncontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\r\nbreak;\r\ncase ECHO_CLOCK_WORD:\r\ncontrol_reg |= GML_WORD_CLOCK;\r\nif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_WORD96)\r\ncontrol_reg |= GML_DOUBLE_SPEED_MODE;\r\nelse\r\ncontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\r\nbreak;\r\ncase ECHO_CLOCK_ADAT:\r\nif (chip->digital_mode != DIGITAL_MODE_ADAT)\r\nreturn -EAGAIN;\r\ncontrol_reg |= GML_ADAT_CLOCK;\r\ncontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\r\nbreak;\r\ndefault:\r\ndev_err(chip->card->dev,\r\n"Input clock 0x%x not supported for Layla24\n", clock);\r\nreturn -EINVAL;\r\n}\r\nchip->input_clock = clock;\r\nreturn write_control_reg(chip, control_reg, true);\r\n}\r\nstatic int switch_asic(struct echoaudio *chip, short asic)\r\n{\r\ns8 *monitors;\r\nif (asic != chip->asic_code) {\r\nmonitors = kmemdup(chip->comm_page->monitors,\r\nMONITOR_ARRAY_SIZE, GFP_KERNEL);\r\nif (! monitors)\r\nreturn -ENOMEM;\r\nmemset(chip->comm_page->monitors, ECHOGAIN_MUTED,\r\nMONITOR_ARRAY_SIZE);\r\nif (load_asic_generic(chip, DSP_FNC_LOAD_LAYLA24_EXTERNAL_ASIC,\r\nasic) < 0) {\r\nmemcpy(chip->comm_page->monitors, monitors,\r\nMONITOR_ARRAY_SIZE);\r\nkfree(monitors);\r\nreturn -EIO;\r\n}\r\nchip->asic_code = asic;\r\nmemcpy(chip->comm_page->monitors, monitors, MONITOR_ARRAY_SIZE);\r\nkfree(monitors);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsp_set_digital_mode(struct echoaudio *chip, u8 mode)\r\n{\r\nu32 control_reg;\r\nint err, incompatible_clock;\r\nshort asic;\r\nincompatible_clock = false;\r\nswitch (mode) {\r\ncase DIGITAL_MODE_SPDIF_OPTICAL:\r\ncase DIGITAL_MODE_SPDIF_RCA:\r\nif (chip->input_clock == ECHO_CLOCK_ADAT)\r\nincompatible_clock = true;\r\nasic = FW_LAYLA24_2S_ASIC;\r\nbreak;\r\ncase DIGITAL_MODE_ADAT:\r\nif (chip->input_clock == ECHO_CLOCK_SPDIF)\r\nincompatible_clock = true;\r\nasic = FW_LAYLA24_2A_ASIC;\r\nbreak;\r\ndefault:\r\ndev_err(chip->card->dev,\r\n"Digital mode not supported: %d\n", mode);\r\nreturn -EINVAL;\r\n}\r\nif (incompatible_clock) {\r\nchip->sample_rate = 48000;\r\nspin_lock_irq(&chip->lock);\r\nset_input_clock(chip, ECHO_CLOCK_INTERNAL);\r\nspin_unlock_irq(&chip->lock);\r\n}\r\nif (switch_asic(chip, asic) < 0)\r\nreturn -EIO;\r\nspin_lock_irq(&chip->lock);\r\ncontrol_reg = le32_to_cpu(chip->comm_page->control_register);\r\ncontrol_reg &= GML_DIGITAL_MODE_CLEAR_MASK;\r\nswitch (mode) {\r\ncase DIGITAL_MODE_SPDIF_OPTICAL:\r\ncontrol_reg |= GML_SPDIF_OPTICAL_MODE;\r\nbreak;\r\ncase DIGITAL_MODE_SPDIF_RCA:\r\nbreak;\r\ncase DIGITAL_MODE_ADAT:\r\ncontrol_reg |= GML_ADAT_MODE;\r\ncontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\r\nbreak;\r\n}\r\nerr = write_control_reg(chip, control_reg, true);\r\nspin_unlock_irq(&chip->lock);\r\nif (err < 0)\r\nreturn err;\r\nchip->digital_mode = mode;\r\ndev_dbg(chip->card->dev, "set_digital_mode to %d\n", mode);\r\nreturn incompatible_clock;\r\n}
