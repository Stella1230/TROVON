static int sun8i_dwmac_dma_reset(void __iomem *ioaddr)\r\n{\r\nwritel(0, ioaddr + EMAC_RX_CTL1);\r\nwritel(0, ioaddr + EMAC_TX_CTL1);\r\nwritel(0, ioaddr + EMAC_RX_FRM_FLT);\r\nwritel(0, ioaddr + EMAC_RX_DESC_LIST);\r\nwritel(0, ioaddr + EMAC_TX_DESC_LIST);\r\nwritel(0, ioaddr + EMAC_INT_EN);\r\nwritel(0x1FFFFFF, ioaddr + EMAC_INT_STA);\r\nreturn 0;\r\n}\r\nstatic void sun8i_dwmac_dma_init(void __iomem *ioaddr,\r\nstruct stmmac_dma_cfg *dma_cfg,\r\nu32 dma_tx, u32 dma_rx, int atds)\r\n{\r\nwritel(dma_rx, ioaddr + EMAC_RX_DESC_LIST);\r\nwritel(dma_tx, ioaddr + EMAC_TX_DESC_LIST);\r\nwritel(EMAC_RX_INT | EMAC_TX_INT, ioaddr + EMAC_INT_EN);\r\nwritel(0x1FFFFFF, ioaddr + EMAC_INT_STA);\r\n}\r\nstatic void sun8i_dwmac_dump_regs(void __iomem *ioaddr, u32 *reg_space)\r\n{\r\nint i;\r\nfor (i = 0; i < 0xC8; i += 4) {\r\nif (i == 0x32 || i == 0x3C)\r\ncontinue;\r\nreg_space[i / 4] = readl(ioaddr + i);\r\n}\r\n}\r\nstatic void sun8i_dwmac_dump_mac_regs(struct mac_device_info *hw,\r\nu32 *reg_space)\r\n{\r\nint i;\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nfor (i = 0; i < 0xC8; i += 4) {\r\nif (i == 0x32 || i == 0x3C)\r\ncontinue;\r\nreg_space[i / 4] = readl(ioaddr + i);\r\n}\r\n}\r\nstatic void sun8i_dwmac_enable_dma_irq(void __iomem *ioaddr, u32 chan)\r\n{\r\nwritel(EMAC_RX_INT | EMAC_TX_INT, ioaddr + EMAC_INT_EN);\r\n}\r\nstatic void sun8i_dwmac_disable_dma_irq(void __iomem *ioaddr, u32 chan)\r\n{\r\nwritel(0, ioaddr + EMAC_INT_EN);\r\n}\r\nstatic void sun8i_dwmac_dma_start_tx(void __iomem *ioaddr, u32 chan)\r\n{\r\nu32 v;\r\nv = readl(ioaddr + EMAC_TX_CTL1);\r\nv |= EMAC_TX_DMA_START;\r\nv |= EMAC_TX_DMA_EN;\r\nwritel(v, ioaddr + EMAC_TX_CTL1);\r\n}\r\nstatic void sun8i_dwmac_enable_dma_transmission(void __iomem *ioaddr)\r\n{\r\nu32 v;\r\nv = readl(ioaddr + EMAC_TX_CTL1);\r\nv |= EMAC_TX_DMA_START;\r\nv |= EMAC_TX_DMA_EN;\r\nwritel(v, ioaddr + EMAC_TX_CTL1);\r\n}\r\nstatic void sun8i_dwmac_dma_stop_tx(void __iomem *ioaddr, u32 chan)\r\n{\r\nu32 v;\r\nv = readl(ioaddr + EMAC_TX_CTL1);\r\nv &= ~EMAC_TX_DMA_EN;\r\nwritel(v, ioaddr + EMAC_TX_CTL1);\r\n}\r\nstatic void sun8i_dwmac_dma_start_rx(void __iomem *ioaddr, u32 chan)\r\n{\r\nu32 v;\r\nv = readl(ioaddr + EMAC_RX_CTL1);\r\nv |= EMAC_RX_DMA_START;\r\nv |= EMAC_RX_DMA_EN;\r\nwritel(v, ioaddr + EMAC_RX_CTL1);\r\n}\r\nstatic void sun8i_dwmac_dma_stop_rx(void __iomem *ioaddr, u32 chan)\r\n{\r\nu32 v;\r\nv = readl(ioaddr + EMAC_RX_CTL1);\r\nv &= ~EMAC_RX_DMA_EN;\r\nwritel(v, ioaddr + EMAC_RX_CTL1);\r\n}\r\nstatic int sun8i_dwmac_dma_interrupt(void __iomem *ioaddr,\r\nstruct stmmac_extra_stats *x, u32 chan)\r\n{\r\nu32 v;\r\nint ret = 0;\r\nv = readl(ioaddr + EMAC_INT_STA);\r\nif (v & EMAC_TX_INT) {\r\nret |= handle_tx;\r\nx->tx_normal_irq_n++;\r\n}\r\nif (v & EMAC_TX_DMA_STOP_INT)\r\nx->tx_process_stopped_irq++;\r\nif (v & EMAC_TX_BUF_UA_INT)\r\nx->tx_process_stopped_irq++;\r\nif (v & EMAC_TX_TIMEOUT_INT)\r\nret |= tx_hard_error;\r\nif (v & EMAC_TX_UNDERFLOW_INT) {\r\nret |= tx_hard_error;\r\nx->tx_undeflow_irq++;\r\n}\r\nif (v & EMAC_TX_EARLY_INT)\r\nx->tx_early_irq++;\r\nif (v & EMAC_RX_INT) {\r\nret |= handle_rx;\r\nx->rx_normal_irq_n++;\r\n}\r\nif (v & EMAC_RX_BUF_UA_INT)\r\nx->rx_buf_unav_irq++;\r\nif (v & EMAC_RX_DMA_STOP_INT)\r\nx->rx_process_stopped_irq++;\r\nif (v & EMAC_RX_TIMEOUT_INT)\r\nret |= tx_hard_error;\r\nif (v & EMAC_RX_OVERFLOW_INT) {\r\nret |= tx_hard_error;\r\nx->rx_overflow_irq++;\r\n}\r\nif (v & EMAC_RX_EARLY_INT)\r\nx->rx_early_irq++;\r\nif (v & EMAC_RGMII_STA_INT)\r\nx->irq_rgmii_n++;\r\nwritel(v, ioaddr + EMAC_INT_STA);\r\nreturn ret;\r\n}\r\nstatic void sun8i_dwmac_dma_operation_mode(void __iomem *ioaddr, int txmode,\r\nint rxmode, int rxfifosz)\r\n{\r\nu32 v;\r\nv = readl(ioaddr + EMAC_TX_CTL1);\r\nif (txmode == SF_DMA_MODE) {\r\nv |= EMAC_TX_MD;\r\nv |= EMAC_TX_NEXT_FRM;\r\n} else {\r\nv &= ~EMAC_TX_MD;\r\nv &= ~EMAC_TX_TH_MASK;\r\nif (txmode < 64)\r\nv |= EMAC_TX_TH_64;\r\nelse if (txmode < 128)\r\nv |= EMAC_TX_TH_128;\r\nelse if (txmode < 192)\r\nv |= EMAC_TX_TH_192;\r\nelse if (txmode < 256)\r\nv |= EMAC_TX_TH_256;\r\n}\r\nwritel(v, ioaddr + EMAC_TX_CTL1);\r\nv = readl(ioaddr + EMAC_RX_CTL1);\r\nif (rxmode == SF_DMA_MODE) {\r\nv |= EMAC_RX_MD;\r\n} else {\r\nv &= ~EMAC_RX_MD;\r\nv &= ~EMAC_RX_TH_MASK;\r\nif (rxmode < 32)\r\nv |= EMAC_RX_TH_32;\r\nelse if (rxmode < 64)\r\nv |= EMAC_RX_TH_64;\r\nelse if (rxmode < 96)\r\nv |= EMAC_RX_TH_96;\r\nelse if (rxmode < 128)\r\nv |= EMAC_RX_TH_128;\r\n}\r\nwritel(v, ioaddr + EMAC_RX_CTL1);\r\n}\r\nstatic int sun8i_dwmac_init(struct platform_device *pdev, void *priv)\r\n{\r\nstruct sunxi_priv_data *gmac = priv;\r\nint ret;\r\nif (gmac->regulator) {\r\nret = regulator_enable(gmac->regulator);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Fail to enable regulator\n");\r\nreturn ret;\r\n}\r\n}\r\nret = clk_prepare_enable(gmac->tx_clk);\r\nif (ret) {\r\nif (gmac->regulator)\r\nregulator_disable(gmac->regulator);\r\ndev_err(&pdev->dev, "Could not enable AHB clock\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sun8i_dwmac_core_init(struct mac_device_info *hw, int mtu)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nu32 v;\r\nv = (8 << EMAC_BURSTLEN_SHIFT);\r\nwritel(v, ioaddr + EMAC_BASIC_CTL1);\r\n}\r\nstatic void sun8i_dwmac_set_mac(void __iomem *ioaddr, bool enable)\r\n{\r\nu32 t, r;\r\nt = readl(ioaddr + EMAC_TX_CTL0);\r\nr = readl(ioaddr + EMAC_RX_CTL0);\r\nif (enable) {\r\nt |= EMAC_TX_TRANSMITTER_EN;\r\nr |= EMAC_RX_RECEIVER_EN;\r\n} else {\r\nt &= ~EMAC_TX_TRANSMITTER_EN;\r\nr &= ~EMAC_RX_RECEIVER_EN;\r\n}\r\nwritel(t, ioaddr + EMAC_TX_CTL0);\r\nwritel(r, ioaddr + EMAC_RX_CTL0);\r\n}\r\nstatic void sun8i_dwmac_set_umac_addr(struct mac_device_info *hw,\r\nunsigned char *addr,\r\nunsigned int reg_n)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nu32 v;\r\nif (!addr) {\r\nwritel(0, ioaddr + EMAC_MACADDR_HI(reg_n));\r\nreturn;\r\n}\r\nstmmac_set_mac_addr(ioaddr, addr, EMAC_MACADDR_HI(reg_n),\r\nEMAC_MACADDR_LO(reg_n));\r\nif (reg_n > 0) {\r\nv = readl(ioaddr + EMAC_MACADDR_HI(reg_n));\r\nv |= MAC_ADDR_TYPE_DST;\r\nwritel(v, ioaddr + EMAC_MACADDR_HI(reg_n));\r\n}\r\n}\r\nstatic void sun8i_dwmac_get_umac_addr(struct mac_device_info *hw,\r\nunsigned char *addr,\r\nunsigned int reg_n)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nstmmac_get_mac_addr(ioaddr, addr, EMAC_MACADDR_HI(reg_n),\r\nEMAC_MACADDR_LO(reg_n));\r\n}\r\nstatic int sun8i_dwmac_rx_ipc_enable(struct mac_device_info *hw)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nu32 v;\r\nv = readl(ioaddr + EMAC_RX_CTL0);\r\nv |= EMAC_RX_DO_CRC;\r\nwritel(v, ioaddr + EMAC_RX_CTL0);\r\nreturn 1;\r\n}\r\nstatic void sun8i_dwmac_set_filter(struct mac_device_info *hw,\r\nstruct net_device *dev)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nu32 v;\r\nint i = 1;\r\nstruct netdev_hw_addr *ha;\r\nint macaddrs = netdev_uc_count(dev) + netdev_mc_count(dev) + 1;\r\nv = EMAC_FRM_FLT_CTL;\r\nif (dev->flags & IFF_PROMISC) {\r\nv = EMAC_FRM_FLT_RXALL;\r\n} else if (dev->flags & IFF_ALLMULTI) {\r\nv |= EMAC_FRM_FLT_MULTICAST;\r\n} else if (macaddrs <= hw->unicast_filter_entries) {\r\nif (!netdev_mc_empty(dev)) {\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nsun8i_dwmac_set_umac_addr(hw, ha->addr, i);\r\ni++;\r\n}\r\n}\r\nif (!netdev_uc_empty(dev)) {\r\nnetdev_for_each_uc_addr(ha, dev) {\r\nsun8i_dwmac_set_umac_addr(hw, ha->addr, i);\r\ni++;\r\n}\r\n}\r\n} else {\r\nnetdev_info(dev, "Too many address, switching to promiscuous\n");\r\nv = EMAC_FRM_FLT_RXALL;\r\n}\r\nwhile (i < hw->unicast_filter_entries)\r\nsun8i_dwmac_set_umac_addr(hw, NULL, i++);\r\nwritel(v, ioaddr + EMAC_RX_FRM_FLT);\r\n}\r\nstatic void sun8i_dwmac_flow_ctrl(struct mac_device_info *hw,\r\nunsigned int duplex, unsigned int fc,\r\nunsigned int pause_time, u32 tx_cnt)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nu32 v;\r\nv = readl(ioaddr + EMAC_RX_CTL0);\r\nif (fc == FLOW_AUTO)\r\nv |= EMAC_RX_FLOW_CTL_EN;\r\nelse\r\nv &= ~EMAC_RX_FLOW_CTL_EN;\r\nwritel(v, ioaddr + EMAC_RX_CTL0);\r\nv = readl(ioaddr + EMAC_TX_FLOW_CTL);\r\nif (fc == FLOW_AUTO)\r\nv |= EMAC_TX_FLOW_CTL_EN;\r\nelse\r\nv &= ~EMAC_TX_FLOW_CTL_EN;\r\nwritel(v, ioaddr + EMAC_TX_FLOW_CTL);\r\n}\r\nstatic int sun8i_dwmac_reset(struct stmmac_priv *priv)\r\n{\r\nu32 v;\r\nint err;\r\nv = readl(priv->ioaddr + EMAC_BASIC_CTL1);\r\nwritel(v | 0x01, priv->ioaddr + EMAC_BASIC_CTL1);\r\nerr = readl_poll_timeout(priv->ioaddr + EMAC_BASIC_CTL1, v,\r\n!(v & 0x01), 100, 100000);\r\nif (err) {\r\ndev_err(priv->device, "EMAC reset timeout\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sun8i_dwmac_set_syscon(struct stmmac_priv *priv)\r\n{\r\nstruct sunxi_priv_data *gmac = priv->plat->bsp_priv;\r\nstruct device_node *node = priv->device->of_node;\r\nint ret;\r\nu32 reg, val;\r\nregmap_read(gmac->regmap, SYSCON_EMAC_REG, &val);\r\nreg = gmac->variant->default_syscon_value;\r\nif (reg != val)\r\ndev_warn(priv->device,\r\n"Current syscon value is not the default %x (expect %x)\n",\r\nval, reg);\r\nif (gmac->variant->internal_phy) {\r\nif (!gmac->use_internal_phy) {\r\nreg &= ~H3_EPHY_SELECT;\r\n} else {\r\nreg |= H3_EPHY_SELECT;\r\nreg &= ~H3_EPHY_SHUTDOWN;\r\ndev_dbg(priv->device, "Select internal_phy %x\n", reg);\r\nif (of_property_read_bool(priv->plat->phy_node,\r\n"allwinner,leds-active-low"))\r\nreg |= H3_EPHY_LED_POL;\r\nelse\r\nreg &= ~H3_EPHY_LED_POL;\r\nreg |= H3_EPHY_CLK_SEL;\r\nret = of_mdio_parse_addr(priv->device,\r\npriv->plat->phy_node);\r\nif (ret < 0) {\r\ndev_err(priv->device, "Could not parse MDIO addr\n");\r\nreturn ret;\r\n}\r\nreg |= ret << H3_EPHY_ADDR_SHIFT;\r\n}\r\n}\r\nif (!of_property_read_u32(node, "allwinner,tx-delay-ps", &val)) {\r\nif (val % 100) {\r\ndev_err(priv->device, "tx-delay must be a multiple of 100\n");\r\nreturn -EINVAL;\r\n}\r\nval /= 100;\r\ndev_dbg(priv->device, "set tx-delay to %x\n", val);\r\nif (val <= SYSCON_ETXDC_MASK) {\r\nreg &= ~(SYSCON_ETXDC_MASK << SYSCON_ETXDC_SHIFT);\r\nreg |= (val << SYSCON_ETXDC_SHIFT);\r\n} else {\r\ndev_err(priv->device, "Invalid TX clock delay: %d\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!of_property_read_u32(node, "allwinner,rx-delay-ps", &val)) {\r\nif (val % 100) {\r\ndev_err(priv->device, "rx-delay must be a multiple of 100\n");\r\nreturn -EINVAL;\r\n}\r\nval /= 100;\r\ndev_dbg(priv->device, "set rx-delay to %x\n", val);\r\nif (val <= SYSCON_ERXDC_MASK) {\r\nreg &= ~(SYSCON_ERXDC_MASK << SYSCON_ERXDC_SHIFT);\r\nreg |= (val << SYSCON_ERXDC_SHIFT);\r\n} else {\r\ndev_err(priv->device, "Invalid RX clock delay: %d\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreg &= ~(SYSCON_ETCS_MASK | SYSCON_EPIT);\r\nif (gmac->variant->support_rmii)\r\nreg &= ~SYSCON_RMII_EN;\r\nswitch (priv->plat->interface) {\r\ncase PHY_INTERFACE_MODE_MII:\r\nbreak;\r\ncase PHY_INTERFACE_MODE_RGMII:\r\nreg |= SYSCON_EPIT | SYSCON_ETCS_INT_GMII;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_RMII:\r\nreg |= SYSCON_RMII_EN | SYSCON_ETCS_EXT_GMII;\r\nbreak;\r\ndefault:\r\ndev_err(priv->device, "Unsupported interface mode: %s",\r\nphy_modes(priv->plat->interface));\r\nreturn -EINVAL;\r\n}\r\nregmap_write(gmac->regmap, SYSCON_EMAC_REG, reg);\r\nreturn 0;\r\n}\r\nstatic void sun8i_dwmac_unset_syscon(struct sunxi_priv_data *gmac)\r\n{\r\nu32 reg = gmac->variant->default_syscon_value;\r\nregmap_write(gmac->regmap, SYSCON_EMAC_REG, reg);\r\n}\r\nstatic int sun8i_dwmac_power_internal_phy(struct stmmac_priv *priv)\r\n{\r\nstruct sunxi_priv_data *gmac = priv->plat->bsp_priv;\r\nint ret;\r\nif (!gmac->use_internal_phy)\r\nreturn 0;\r\nret = clk_prepare_enable(gmac->ephy_clk);\r\nif (ret) {\r\ndev_err(priv->device, "Cannot enable ephy\n");\r\nreturn ret;\r\n}\r\nreset_control_assert(gmac->rst_ephy);\r\nret = reset_control_deassert(gmac->rst_ephy);\r\nif (ret) {\r\ndev_err(priv->device, "Cannot deassert ephy\n");\r\nclk_disable_unprepare(gmac->ephy_clk);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sun8i_dwmac_unpower_internal_phy(struct sunxi_priv_data *gmac)\r\n{\r\nif (!gmac->use_internal_phy)\r\nreturn 0;\r\nclk_disable_unprepare(gmac->ephy_clk);\r\nreset_control_assert(gmac->rst_ephy);\r\nreturn 0;\r\n}\r\nstatic int sun8i_power_phy(struct stmmac_priv *priv)\r\n{\r\nint ret;\r\nret = sun8i_dwmac_power_internal_phy(priv);\r\nif (ret)\r\nreturn ret;\r\nret = sun8i_dwmac_set_syscon(priv);\r\nif (ret)\r\nreturn ret;\r\nret = sun8i_dwmac_reset(priv);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void sun8i_unpower_phy(struct sunxi_priv_data *gmac)\r\n{\r\nsun8i_dwmac_unset_syscon(gmac);\r\nsun8i_dwmac_unpower_internal_phy(gmac);\r\n}\r\nstatic void sun8i_dwmac_exit(struct platform_device *pdev, void *priv)\r\n{\r\nstruct sunxi_priv_data *gmac = priv;\r\nsun8i_unpower_phy(gmac);\r\nclk_disable_unprepare(gmac->tx_clk);\r\nif (gmac->regulator)\r\nregulator_disable(gmac->regulator);\r\n}\r\nstatic struct mac_device_info *sun8i_dwmac_setup(void *ppriv)\r\n{\r\nstruct mac_device_info *mac;\r\nstruct stmmac_priv *priv = ppriv;\r\nint ret;\r\nmac = devm_kzalloc(priv->device, sizeof(*mac), GFP_KERNEL);\r\nif (!mac)\r\nreturn NULL;\r\nret = sun8i_power_phy(priv);\r\nif (ret)\r\nreturn NULL;\r\nmac->pcsr = priv->ioaddr;\r\nmac->mac = &sun8i_dwmac_ops;\r\nmac->dma = &sun8i_dwmac_dma_ops;\r\nmac->link.speed_mask = GENMASK(3, 2) | EMAC_LOOPBACK;\r\nmac->link.speed10 = EMAC_SPEED_10;\r\nmac->link.speed100 = EMAC_SPEED_100;\r\nmac->link.speed1000 = EMAC_SPEED_1000;\r\nmac->link.duplex = EMAC_DUPLEX_FULL;\r\nmac->mii.addr = EMAC_MDIO_CMD;\r\nmac->mii.data = EMAC_MDIO_DATA;\r\nmac->mii.reg_shift = 4;\r\nmac->mii.reg_mask = GENMASK(8, 4);\r\nmac->mii.addr_shift = 12;\r\nmac->mii.addr_mask = GENMASK(16, 12);\r\nmac->mii.clk_csr_shift = 20;\r\nmac->mii.clk_csr_mask = GENMASK(22, 20);\r\nmac->unicast_filter_entries = 8;\r\npriv->synopsys_id = 0;\r\nreturn mac;\r\n}\r\nstatic int sun8i_dwmac_probe(struct platform_device *pdev)\r\n{\r\nstruct plat_stmmacenet_data *plat_dat;\r\nstruct stmmac_resources stmmac_res;\r\nstruct sunxi_priv_data *gmac;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nret = stmmac_get_platform_resources(pdev, &stmmac_res);\r\nif (ret)\r\nreturn ret;\r\nplat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);\r\nif (IS_ERR(plat_dat))\r\nreturn PTR_ERR(plat_dat);\r\ngmac = devm_kzalloc(dev, sizeof(*gmac), GFP_KERNEL);\r\nif (!gmac)\r\nreturn -ENOMEM;\r\ngmac->variant = of_device_get_match_data(&pdev->dev);\r\nif (!gmac->variant) {\r\ndev_err(&pdev->dev, "Missing dwmac-sun8i variant\n");\r\nreturn -EINVAL;\r\n}\r\ngmac->tx_clk = devm_clk_get(dev, "stmmaceth");\r\nif (IS_ERR(gmac->tx_clk)) {\r\ndev_err(dev, "Could not get TX clock\n");\r\nreturn PTR_ERR(gmac->tx_clk);\r\n}\r\ngmac->regulator = devm_regulator_get_optional(dev, "phy");\r\nif (IS_ERR(gmac->regulator)) {\r\nif (PTR_ERR(gmac->regulator) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\ndev_info(dev, "No regulator found\n");\r\ngmac->regulator = NULL;\r\n}\r\ngmac->regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"syscon");\r\nif (IS_ERR(gmac->regmap)) {\r\nret = PTR_ERR(gmac->regmap);\r\ndev_err(&pdev->dev, "Unable to map syscon: %d\n", ret);\r\nreturn ret;\r\n}\r\nplat_dat->interface = of_get_phy_mode(dev->of_node);\r\nif (plat_dat->interface == gmac->variant->internal_phy) {\r\ndev_info(&pdev->dev, "Will use internal PHY\n");\r\ngmac->use_internal_phy = true;\r\ngmac->ephy_clk = of_clk_get(plat_dat->phy_node, 0);\r\nif (IS_ERR(gmac->ephy_clk)) {\r\nret = PTR_ERR(gmac->ephy_clk);\r\ndev_err(&pdev->dev, "Cannot get EPHY clock: %d\n", ret);\r\nreturn -EINVAL;\r\n}\r\ngmac->rst_ephy = of_reset_control_get(plat_dat->phy_node, NULL);\r\nif (IS_ERR(gmac->rst_ephy)) {\r\nret = PTR_ERR(gmac->rst_ephy);\r\nif (ret == -EPROBE_DEFER)\r\nreturn ret;\r\ndev_err(&pdev->dev, "No EPHY reset control found %d\n",\r\nret);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ndev_info(&pdev->dev, "Will use external PHY\n");\r\ngmac->use_internal_phy = false;\r\n}\r\nplat_dat->rx_coe = STMMAC_RX_COE_TYPE2;\r\nplat_dat->tx_coe = 1;\r\nplat_dat->has_sun8i = true;\r\nplat_dat->bsp_priv = gmac;\r\nplat_dat->init = sun8i_dwmac_init;\r\nplat_dat->exit = sun8i_dwmac_exit;\r\nplat_dat->setup = sun8i_dwmac_setup;\r\nret = sun8i_dwmac_init(pdev, plat_dat->bsp_priv);\r\nif (ret)\r\nreturn ret;\r\nret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\r\nif (ret)\r\nsun8i_dwmac_exit(pdev, plat_dat->bsp_priv);\r\nreturn ret;\r\n}
