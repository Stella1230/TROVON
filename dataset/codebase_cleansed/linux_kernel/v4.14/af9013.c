static int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)\r\n{\r\nstruct i2c_client *client = state->client;\r\nint ret;\r\nu8 pos;\r\nu16 addr;\r\ndev_dbg(&client->dev, "gpio %u, gpioval %02x\n", gpio, gpioval);\r\nswitch (gpio) {\r\ncase 0:\r\ncase 1:\r\naddr = 0xd735;\r\nbreak;\r\ncase 2:\r\ncase 3:\r\naddr = 0xd736;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nswitch (gpio) {\r\ncase 0:\r\ncase 2:\r\npos = 0;\r\nbreak;\r\ncase 1:\r\ncase 3:\r\ndefault:\r\npos = 4;\r\nbreak;\r\n}\r\nret = regmap_update_bits(state->regmap, addr, 0x0f << pos,\r\ngpioval << pos);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_statistics_ber_unc_start(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nstruct i2c_client *client = state->client;\r\nint ret;\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_update_bits(state->regmap, 0xd391, 0x10, 0x10);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_statistics_ber_unc_result(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nstruct i2c_client *client = state->client;\r\nint ret;\r\nunsigned int utmp;\r\nu8 buf[5];\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_read(state->regmap, 0xd391, &utmp);\r\nif (ret)\r\ngoto err;\r\nif (!((utmp >> 4) & 0x01)) {\r\ndev_dbg(&client->dev, "not ready\n");\r\nreturn 0;\r\n}\r\nret = regmap_bulk_read(state->regmap, 0xd387, buf, 5);\r\nif (ret)\r\ngoto err;\r\nstate->ber = (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\nstate->ucblocks += (buf[4] << 8) | buf[3];\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_statistics_snr_start(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nstruct i2c_client *client = state->client;\r\nint ret;\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_update_bits(state->regmap, 0xd2e1, 0x08, 0x08);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_statistics_snr_result(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nstruct i2c_client *client = state->client;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i, len;\r\nunsigned int utmp;\r\nu8 buf[3];\r\nu32 snr_val;\r\nconst struct af9013_snr *uninitialized_var(snr_lut);\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_read(state->regmap, 0xd2e1, &utmp);\r\nif (ret)\r\ngoto err;\r\nif (!((utmp >> 3) & 0x01)) {\r\ndev_dbg(&client->dev, "not ready\n");\r\nreturn 0;\r\n}\r\nret = regmap_bulk_read(state->regmap, 0xd2e3, buf, 3);\r\nif (ret)\r\ngoto err;\r\nsnr_val = (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\nret = regmap_read(state->regmap, 0xd3c1, &utmp);\r\nif (ret)\r\ngoto err;\r\nswitch ((utmp >> 6) & 3) {\r\ncase 0:\r\nlen = ARRAY_SIZE(qpsk_snr_lut);\r\nsnr_lut = qpsk_snr_lut;\r\nbreak;\r\ncase 1:\r\nlen = ARRAY_SIZE(qam16_snr_lut);\r\nsnr_lut = qam16_snr_lut;\r\nbreak;\r\ncase 2:\r\nlen = ARRAY_SIZE(qam64_snr_lut);\r\nsnr_lut = qam64_snr_lut;\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nutmp = snr_lut[i].snr;\r\nif (snr_val < snr_lut[i].val)\r\nbreak;\r\n}\r\nstate->snr = utmp * 10;\r\nc->cnr.stat[0].svalue = 1000 * utmp;\r\nc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_statistics_signal_strength(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nstruct i2c_client *client = state->client;\r\nint ret = 0;\r\nu8 buf[2], rf_gain, if_gain;\r\nint signal_strength;\r\ndev_dbg(&client->dev, "\n");\r\nif (!state->signal_strength_en)\r\nreturn 0;\r\nret = regmap_bulk_read(state->regmap, 0xd07c, buf, 2);\r\nif (ret)\r\ngoto err;\r\nrf_gain = buf[0];\r\nif_gain = buf[1];\r\nsignal_strength = (0xffff / \\r\n(9 * (state->rf_50 + state->if_50) - \\r\n11 * (state->rf_80 + state->if_80))) * \\r\n(10 * (rf_gain + if_gain) - \\r\n11 * (state->rf_80 + state->if_80));\r\nif (signal_strength < 0)\r\nsignal_strength = 0;\r\nelse if (signal_strength > 0xffff)\r\nsignal_strength = 0xffff;\r\nstate->signal_strength = signal_strength;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void af9013_statistics_work(struct work_struct *work)\r\n{\r\nstruct af9013_state *state = container_of(work,\r\nstruct af9013_state, statistics_work.work);\r\nunsigned int next_msec;\r\nif (!(state->fe_status & FE_HAS_LOCK)) {\r\nstate->statistics_step = 0;\r\nstate->ber = 0;\r\nstate->snr = 0;\r\n}\r\nswitch (state->statistics_step) {\r\ndefault:\r\nstate->statistics_step = 0;\r\ncase 0:\r\naf9013_statistics_signal_strength(&state->fe);\r\nstate->statistics_step++;\r\nnext_msec = 300;\r\nbreak;\r\ncase 1:\r\naf9013_statistics_snr_start(&state->fe);\r\nstate->statistics_step++;\r\nnext_msec = 200;\r\nbreak;\r\ncase 2:\r\naf9013_statistics_ber_unc_start(&state->fe);\r\nstate->statistics_step++;\r\nnext_msec = 1000;\r\nbreak;\r\ncase 3:\r\naf9013_statistics_snr_result(&state->fe);\r\nstate->statistics_step++;\r\nnext_msec = 400;\r\nbreak;\r\ncase 4:\r\naf9013_statistics_ber_unc_result(&state->fe);\r\nstate->statistics_step++;\r\nnext_msec = 100;\r\nbreak;\r\n}\r\nschedule_delayed_work(&state->statistics_work,\r\nmsecs_to_jiffies(next_msec));\r\n}\r\nstatic int af9013_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *fesettings)\r\n{\r\nfesettings->min_delay_ms = 800;\r\nfesettings->step_size = 0;\r\nfesettings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic int af9013_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nstruct i2c_client *client = state->client;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i, sampling_freq;\r\nbool auto_mode, spec_inv;\r\nu8 buf[6];\r\nu32 if_frequency, freq_cw;\r\ndev_dbg(&client->dev, "frequency %u, bandwidth_hz %u\n",\r\nc->frequency, c->bandwidth_hz);\r\nif (fe->ops.tuner_ops.set_params) {\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (c->bandwidth_hz != state->bandwidth_hz) {\r\nfor (i = 0; i < ARRAY_SIZE(coeff_lut); i++) {\r\nif (coeff_lut[i].clock == state->clk &&\r\ncoeff_lut[i].bandwidth_hz == c->bandwidth_hz) {\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(coeff_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = regmap_bulk_write(state->regmap, 0xae00, coeff_lut[i].val,\r\nsizeof(coeff_lut[i].val));\r\nif (ret)\r\ngoto err;\r\n}\r\nif (c->bandwidth_hz != state->bandwidth_hz || state->first_tune) {\r\nif (fe->ops.tuner_ops.get_if_frequency) {\r\nret = fe->ops.tuner_ops.get_if_frequency(fe,\r\n&if_frequency);\r\nif (ret)\r\ngoto err;\r\n} else {\r\nif_frequency = state->if_frequency;\r\n}\r\ndev_dbg(&client->dev, "if_frequency %u\n", if_frequency);\r\nsampling_freq = if_frequency;\r\nwhile (sampling_freq > (state->clk / 2))\r\nsampling_freq -= state->clk;\r\nif (sampling_freq < 0) {\r\nsampling_freq *= -1;\r\nspec_inv = state->spec_inv;\r\n} else {\r\nspec_inv = !state->spec_inv;\r\n}\r\nfreq_cw = DIV_ROUND_CLOSEST_ULL((u64)sampling_freq * 0x800000,\r\nstate->clk);\r\nif (spec_inv)\r\nfreq_cw = 0x800000 - freq_cw;\r\nbuf[0] = (freq_cw >> 0) & 0xff;\r\nbuf[1] = (freq_cw >> 8) & 0xff;\r\nbuf[2] = (freq_cw >> 16) & 0x7f;\r\nfreq_cw = 0x800000 - freq_cw;\r\nbuf[3] = (freq_cw >> 0) & 0xff;\r\nbuf[4] = (freq_cw >> 8) & 0xff;\r\nbuf[5] = (freq_cw >> 16) & 0x7f;\r\nret = regmap_bulk_write(state->regmap, 0xd140, buf, 3);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(state->regmap, 0x9be7, buf, 6);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = regmap_update_bits(state->regmap, 0xd330, 0x08, 0x08);\r\nif (ret)\r\ngoto err;\r\nret = regmap_update_bits(state->regmap, 0xd507, 0x40, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_update_bits(state->regmap, 0x9bfe, 0x01, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_update_bits(state->regmap, 0x9bc2, 0x01, 0x00);\r\nif (ret)\r\ngoto err;\r\nauto_mode = false;\r\nmemset(buf, 0, 3);\r\nswitch (c->transmission_mode) {\r\ncase TRANSMISSION_MODE_AUTO:\r\nauto_mode = true;\r\nbreak;\r\ncase TRANSMISSION_MODE_2K:\r\nbreak;\r\ncase TRANSMISSION_MODE_8K:\r\nbuf[0] |= (1 << 0);\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid transmission_mode\n");\r\nauto_mode = true;\r\n}\r\nswitch (c->guard_interval) {\r\ncase GUARD_INTERVAL_AUTO:\r\nauto_mode = true;\r\nbreak;\r\ncase GUARD_INTERVAL_1_32:\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\nbuf[0] |= (1 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\nbuf[0] |= (2 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_4:\r\nbuf[0] |= (3 << 2);\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid guard_interval\n");\r\nauto_mode = true;\r\n}\r\nswitch (c->hierarchy) {\r\ncase HIERARCHY_AUTO:\r\nauto_mode = true;\r\nbreak;\r\ncase HIERARCHY_NONE:\r\nbreak;\r\ncase HIERARCHY_1:\r\nbuf[0] |= (1 << 4);\r\nbreak;\r\ncase HIERARCHY_2:\r\nbuf[0] |= (2 << 4);\r\nbreak;\r\ncase HIERARCHY_4:\r\nbuf[0] |= (3 << 4);\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid hierarchy\n");\r\nauto_mode = true;\r\n}\r\nswitch (c->modulation) {\r\ncase QAM_AUTO:\r\nauto_mode = true;\r\nbreak;\r\ncase QPSK:\r\nbreak;\r\ncase QAM_16:\r\nbuf[1] |= (1 << 6);\r\nbreak;\r\ncase QAM_64:\r\nbuf[1] |= (2 << 6);\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid modulation\n");\r\nauto_mode = true;\r\n}\r\nbuf[1] |= (1 << 4);\r\nswitch (c->code_rate_HP) {\r\ncase FEC_AUTO:\r\nauto_mode = true;\r\nbreak;\r\ncase FEC_1_2:\r\nbreak;\r\ncase FEC_2_3:\r\nbuf[2] |= (1 << 0);\r\nbreak;\r\ncase FEC_3_4:\r\nbuf[2] |= (2 << 0);\r\nbreak;\r\ncase FEC_5_6:\r\nbuf[2] |= (3 << 0);\r\nbreak;\r\ncase FEC_7_8:\r\nbuf[2] |= (4 << 0);\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid code_rate_HP\n");\r\nauto_mode = true;\r\n}\r\nswitch (c->code_rate_LP) {\r\ncase FEC_AUTO:\r\nauto_mode = true;\r\nbreak;\r\ncase FEC_1_2:\r\nbreak;\r\ncase FEC_2_3:\r\nbuf[2] |= (1 << 3);\r\nbreak;\r\ncase FEC_3_4:\r\nbuf[2] |= (2 << 3);\r\nbreak;\r\ncase FEC_5_6:\r\nbuf[2] |= (3 << 3);\r\nbreak;\r\ncase FEC_7_8:\r\nbuf[2] |= (4 << 3);\r\nbreak;\r\ncase FEC_NONE:\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid code_rate_LP\n");\r\nauto_mode = true;\r\n}\r\nswitch (c->bandwidth_hz) {\r\ncase 6000000:\r\nbreak;\r\ncase 7000000:\r\nbuf[1] |= (1 << 2);\r\nbreak;\r\ncase 8000000:\r\nbuf[1] |= (2 << 2);\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid bandwidth_hz\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = regmap_bulk_write(state->regmap, 0xd3c0, buf, 3);\r\nif (ret)\r\ngoto err;\r\nif (auto_mode) {\r\nret = regmap_write(state->regmap, 0xaefd, 0x00);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "auto params\n");\r\n} else {\r\nret = regmap_write(state->regmap, 0xaefd, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(state->regmap, 0xaefe, 0x00);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "manual params\n");\r\n}\r\nret = regmap_write(state->regmap, 0xffff, 0x00);\r\nif (ret)\r\ngoto err;\r\nstate->bandwidth_hz = c->bandwidth_hz;\r\nstate->set_frontend_jiffies = jiffies;\r\nstate->first_tune = false;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *c)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nstruct i2c_client *client = state->client;\r\nint ret;\r\nu8 buf[3];\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_bulk_read(state->regmap, 0xd3c0, buf, 3);\r\nif (ret)\r\ngoto err;\r\nswitch ((buf[1] >> 6) & 3) {\r\ncase 0:\r\nc->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\nc->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\nc->modulation = QAM_64;\r\nbreak;\r\n}\r\nswitch ((buf[0] >> 0) & 3) {\r\ncase 0:\r\nc->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\n}\r\nswitch ((buf[0] >> 2) & 3) {\r\ncase 0:\r\nc->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\nc->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\nc->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch ((buf[0] >> 4) & 7) {\r\ncase 0:\r\nc->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\nc->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\nc->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\nc->hierarchy = HIERARCHY_4;\r\nbreak;\r\n}\r\nswitch ((buf[2] >> 0) & 7) {\r\ncase 0:\r\nc->code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_HP = FEC_7_8;\r\nbreak;\r\n}\r\nswitch ((buf[2] >> 3) & 7) {\r\ncase 0:\r\nc->code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_LP = FEC_7_8;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 2) & 3) {\r\ncase 0:\r\nc->bandwidth_hz = 6000000;\r\nbreak;\r\ncase 1:\r\nc->bandwidth_hz = 7000000;\r\nbreak;\r\ncase 2:\r\nc->bandwidth_hz = 8000000;\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nstruct i2c_client *client = state->client;\r\nint ret;\r\nunsigned int utmp;\r\nif (time_is_after_jiffies(\r\nstate->read_status_jiffies + msecs_to_jiffies(2000)) &&\r\ntime_is_before_jiffies(\r\nstate->set_frontend_jiffies + msecs_to_jiffies(4000))\r\n) {\r\n*status = state->fe_status;\r\nreturn 0;\r\n} else {\r\n*status = 0;\r\n}\r\nret = regmap_read(state->regmap, 0xd507, &utmp);\r\nif (ret)\r\ngoto err;\r\nif ((utmp >> 6) & 0x01)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |\r\nFE_HAS_SYNC | FE_HAS_LOCK;\r\nif (!*status) {\r\nret = regmap_read(state->regmap, 0xd330, &utmp);\r\nif (ret)\r\ngoto err;\r\nif ((utmp >> 3) & 0x01)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI;\r\n}\r\nstate->fe_status = *status;\r\nstate->read_status_jiffies = jiffies;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\n*snr = state->snr;\r\nreturn 0;\r\n}\r\nstatic int af9013_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\n*strength = state->signal_strength;\r\nreturn 0;\r\n}\r\nstatic int af9013_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\n*ber = state->ber;\r\nreturn 0;\r\n}\r\nstatic int af9013_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\n*ucblocks = state->ucblocks;\r\nreturn 0;\r\n}\r\nstatic int af9013_init(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nstruct i2c_client *client = state->client;\r\nint ret, i, len;\r\nunsigned int utmp;\r\nu8 buf[3];\r\nconst struct af9013_reg_bit *init;\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_update_bits(state->regmap, 0xd73a, 0x08, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_update_bits(state->regmap, 0xd417, 0x02, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_update_bits(state->regmap, 0xd417, 0x10, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(state->regmap, 0x9bf2, state->api_version, 4);\r\nif (ret)\r\ngoto err;\r\nswitch (state->clk) {\r\ncase 28800000:\r\nutmp = 0;\r\nbreak;\r\ncase 20480000:\r\nutmp = 1;\r\nbreak;\r\ncase 28000000:\r\nutmp = 2;\r\nbreak;\r\ncase 25000000:\r\nutmp = 3;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = regmap_update_bits(state->regmap, 0x9bd2, 0x0f, utmp);\r\nif (ret)\r\ngoto err;\r\nutmp = div_u64((u64)state->clk * 0x80000, 1000000);\r\nbuf[0] = (utmp >> 0) & 0xff;\r\nbuf[1] = (utmp >> 8) & 0xff;\r\nbuf[2] = (utmp >> 16) & 0xff;\r\nret = regmap_bulk_write(state->regmap, 0xd180, buf, 3);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "load ofsm settings\n");\r\nlen = ARRAY_SIZE(ofsm_init);\r\ninit = ofsm_init;\r\nfor (i = 0; i < len; i++) {\r\nu16 reg = init[i].addr;\r\nu8 mask = GENMASK(init[i].pos + init[i].len - 1, init[i].pos);\r\nu8 val = init[i].val << init[i].pos;\r\nret = regmap_update_bits(state->regmap, reg, mask, val);\r\nif (ret)\r\ngoto err;\r\n}\r\ndev_dbg(&client->dev, "load tuner specific settings\n");\r\nswitch (state->tuner) {\r\ncase AF9013_TUNER_MXL5003D:\r\nlen = ARRAY_SIZE(tuner_init_mxl5003d);\r\ninit = tuner_init_mxl5003d;\r\nbreak;\r\ncase AF9013_TUNER_MXL5005D:\r\ncase AF9013_TUNER_MXL5005R:\r\ncase AF9013_TUNER_MXL5007T:\r\nlen = ARRAY_SIZE(tuner_init_mxl5005);\r\ninit = tuner_init_mxl5005;\r\nbreak;\r\ncase AF9013_TUNER_ENV77H11D5:\r\nlen = ARRAY_SIZE(tuner_init_env77h11d5);\r\ninit = tuner_init_env77h11d5;\r\nbreak;\r\ncase AF9013_TUNER_MT2060:\r\nlen = ARRAY_SIZE(tuner_init_mt2060);\r\ninit = tuner_init_mt2060;\r\nbreak;\r\ncase AF9013_TUNER_MC44S803:\r\nlen = ARRAY_SIZE(tuner_init_mc44s803);\r\ninit = tuner_init_mc44s803;\r\nbreak;\r\ncase AF9013_TUNER_QT1010:\r\ncase AF9013_TUNER_QT1010A:\r\nlen = ARRAY_SIZE(tuner_init_qt1010);\r\ninit = tuner_init_qt1010;\r\nbreak;\r\ncase AF9013_TUNER_MT2060_2:\r\nlen = ARRAY_SIZE(tuner_init_mt2060_2);\r\ninit = tuner_init_mt2060_2;\r\nbreak;\r\ncase AF9013_TUNER_TDA18271:\r\ncase AF9013_TUNER_TDA18218:\r\nlen = ARRAY_SIZE(tuner_init_tda18271);\r\ninit = tuner_init_tda18271;\r\nbreak;\r\ncase AF9013_TUNER_UNKNOWN:\r\ndefault:\r\nlen = ARRAY_SIZE(tuner_init_unknown);\r\ninit = tuner_init_unknown;\r\nbreak;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nu16 reg = init[i].addr;\r\nu8 mask = GENMASK(init[i].pos + init[i].len - 1, init[i].pos);\r\nu8 val = init[i].val << init[i].pos;\r\nret = regmap_update_bits(state->regmap, reg, mask, val);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (state->ts_output_pin == 7)\r\nutmp = 1 << 3 | state->ts_mode << 1;\r\nelse\r\nutmp = 0 << 3 | state->ts_mode << 1;\r\nret = regmap_update_bits(state->regmap, 0xd500, 0x0e, utmp);\r\nif (ret)\r\ngoto err;\r\nret = regmap_update_bits(state->regmap, 0xd730, 0x01, 0x01);\r\nif (ret)\r\ngoto err;\r\nif (!state->signal_strength_en) {\r\nret = regmap_read(state->regmap, 0x9bee, &utmp);\r\nif (ret)\r\ngoto err;\r\nstate->signal_strength_en = (utmp >> 0) & 0x01;\r\n}\r\nif (state->signal_strength_en && !state->rf_50) {\r\nret = regmap_bulk_read(state->regmap, 0x9bbd, &state->rf_50, 1);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_read(state->regmap, 0x9bd0, &state->rf_80, 1);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_read(state->regmap, 0x9be2, &state->if_50, 1);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_read(state->regmap, 0x9be4, &state->if_80, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = regmap_write(state->regmap, 0xd2e2, 0x01);\r\nif (ret)\r\ngoto err;\r\nbuf[0] = (10000 >> 0) & 0xff;\r\nbuf[1] = (10000 >> 8) & 0xff;\r\nret = regmap_bulk_write(state->regmap, 0xd385, buf, 2);\r\nif (ret)\r\ngoto err;\r\nret = regmap_update_bits(state->regmap, 0xd392, 0x02, 0x02);\r\nif (ret)\r\ngoto err;\r\nstate->first_tune = true;\r\nschedule_delayed_work(&state->statistics_work, msecs_to_jiffies(400));\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nstruct i2c_client *client = state->client;\r\nint ret;\r\nunsigned int utmp;\r\ndev_dbg(&client->dev, "\n");\r\ncancel_delayed_work_sync(&state->statistics_work);\r\nret = regmap_update_bits(state->regmap, 0xd730, 0x01, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_update_bits(state->regmap, 0xd417, 0x10, 0x10);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(state->regmap, 0xaeff, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read_poll_timeout(state->regmap, 0xd417, utmp,\r\n(utmp >> 1) & 0x01, 5000, 1000000);\r\nif (ret)\r\ngoto err;\r\nif (!((utmp >> 1) & 0x01)) {\r\nret = -ETIMEDOUT;\r\ngoto err;\r\n}\r\nret = regmap_update_bits(state->regmap, 0xd73a, 0x08, 0x08);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nint ret;\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nstruct i2c_client *client = state->client;\r\ndev_dbg(&client->dev, "enable %d\n", enable);\r\nif (state->i2c_gate_state == enable)\r\nreturn 0;\r\nif (state->ts_mode == AF9013_TS_MODE_USB)\r\nret = regmap_update_bits(state->regmap, 0xd417, 0x08,\r\nenable << 3);\r\nelse\r\nret = regmap_update_bits(state->regmap, 0xd607, 0x04,\r\nenable << 2);\r\nif (ret)\r\ngoto err;\r\nstate->i2c_gate_state = enable;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void af9013_release(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nstruct i2c_client *client = state->client;\r\ndev_dbg(&client->dev, "\n");\r\ni2c_unregister_device(client);\r\n}\r\nstatic int af9013_download_firmware(struct af9013_state *state)\r\n{\r\nstruct i2c_client *client = state->client;\r\nint ret, i, len, rem;\r\nunsigned int utmp;\r\nu8 buf[4];\r\nu16 checksum = 0;\r\nconst struct firmware *firmware;\r\nconst char *name = AF9013_FIRMWARE;\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_read(state->regmap, 0x98be, &utmp);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "firmware status %02x\n", utmp);\r\nif (utmp == 0x0c)\r\nreturn 0;\r\ndev_info(&client->dev, "found a '%s' in cold state, will try to load a firmware\n",\r\naf9013_ops.info.name);\r\nret = request_firmware(&firmware, name, &client->dev);\r\nif (ret) {\r\ndev_info(&client->dev, "firmware file '%s' not found %d\n",\r\nname, ret);\r\ngoto err;\r\n}\r\ndev_info(&client->dev, "downloading firmware from file '%s'\n",\r\nname);\r\nfor (i = 0; i < firmware->size; i++)\r\nchecksum += firmware->data[i];\r\nbuf[0] = (checksum >> 8) & 0xff;\r\nbuf[1] = (checksum >> 0) & 0xff;\r\nbuf[2] = (firmware->size >> 8) & 0xff;\r\nbuf[3] = (firmware->size >> 0) & 0xff;\r\nret = regmap_bulk_write(state->regmap, 0x50fc, buf, 4);\r\nif (ret)\r\ngoto err_release_firmware;\r\n#define LEN_MAX 16\r\nfor (rem = firmware->size; rem > 0; rem -= LEN_MAX) {\r\nlen = min(LEN_MAX, rem);\r\nret = regmap_bulk_write(state->regmap,\r\n0x5100 + firmware->size - rem,\r\n&firmware->data[firmware->size - rem],\r\nlen);\r\nif (ret) {\r\ndev_err(&client->dev, "firmware download failed %d\n",\r\nret);\r\ngoto err_release_firmware;\r\n}\r\n}\r\nrelease_firmware(firmware);\r\nret = regmap_write(state->regmap, 0xe205, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read_poll_timeout(state->regmap, 0x98be, utmp,\r\n(utmp == 0x0c || utmp == 0x04),\r\n5000, 1000000);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "firmware status %02x\n", utmp);\r\nif (utmp == 0x04) {\r\nret = -ENODEV;\r\ndev_err(&client->dev, "firmware did not run\n");\r\ngoto err;\r\n} else if (utmp != 0x0c) {\r\nret = -ENODEV;\r\ndev_err(&client->dev, "firmware boot timeout\n");\r\ngoto err;\r\n}\r\ndev_info(&client->dev, "found a '%s' in warm state\n",\r\naf9013_ops.info.name);\r\nreturn 0;\r\nerr_release_firmware:\r\nrelease_firmware(firmware);\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstruct dvb_frontend *af9013_attach(const struct af9013_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct i2c_client *client;\r\nstruct i2c_board_info board_info;\r\nstruct af9013_platform_data pdata;\r\npdata.clk = config->clock;\r\npdata.tuner = config->tuner;\r\npdata.if_frequency = config->if_frequency;\r\npdata.ts_mode = config->ts_mode;\r\npdata.ts_output_pin = 7;\r\npdata.spec_inv = config->spec_inv;\r\nmemcpy(&pdata.api_version, config->api_version, sizeof(pdata.api_version));\r\nmemcpy(&pdata.gpio, config->gpio, sizeof(pdata.gpio));\r\npdata.attach_in_use = true;\r\nmemset(&board_info, 0, sizeof(board_info));\r\nstrlcpy(board_info.type, "af9013", sizeof(board_info.type));\r\nboard_info.addr = config->i2c_addr;\r\nboard_info.platform_data = &pdata;\r\nclient = i2c_new_device(i2c, &board_info);\r\nif (!client || !client->dev.driver)\r\nreturn NULL;\r\nreturn pdata.get_dvb_frontend(client);\r\n}\r\nstatic struct dvb_frontend *af9013_get_dvb_frontend(struct i2c_client *client)\r\n{\r\nstruct af9013_state *state = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nreturn &state->fe;\r\n}\r\nstatic int af9013_wregs(struct i2c_client *client, u8 cmd, u16 reg,\r\nconst u8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[21];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 3 + len,\r\n.buf = buf,\r\n}\r\n};\r\nif (3 + len > sizeof(buf)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nbuf[0] = (reg >> 8) & 0xff;\r\nbuf[1] = (reg >> 0) & 0xff;\r\nbuf[2] = cmd;\r\nmemcpy(&buf[3], val, len);\r\nret = i2c_transfer(client->adapter, msg, 1);\r\nif (ret < 0) {\r\ngoto err;\r\n} else if (ret != 1) {\r\nret = -EREMOTEIO;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_rregs(struct i2c_client *client, u8 cmd, u16 reg,\r\nu8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[3];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 3,\r\n.buf = buf,\r\n}, {\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = val,\r\n}\r\n};\r\nbuf[0] = (reg >> 8) & 0xff;\r\nbuf[1] = (reg >> 0) & 0xff;\r\nbuf[2] = cmd;\r\nret = i2c_transfer(client->adapter, msg, 2);\r\nif (ret < 0) {\r\ngoto err;\r\n} else if (ret != 2) {\r\nret = -EREMOTEIO;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_regmap_write(void *context, const void *data, size_t count)\r\n{\r\nstruct i2c_client *client = context;\r\nstruct af9013_state *state = i2c_get_clientdata(client);\r\nint ret, i;\r\nu8 cmd;\r\nu16 reg = ((u8 *)data)[0] << 8|((u8 *)data)[1] << 0;\r\nu8 *val = &((u8 *)data)[2];\r\nconst unsigned int len = count - 2;\r\nif (state->ts_mode == AF9013_TS_MODE_USB && (reg & 0xff00) != 0xae00) {\r\ncmd = 0 << 7|0 << 6|(len - 1) << 2|1 << 1|1 << 0;\r\nret = af9013_wregs(client, cmd, reg, val, len);\r\nif (ret)\r\ngoto err;\r\n} else if (reg >= 0x5100 && reg < 0x8fff) {\r\ncmd = 1 << 7|1 << 6|(len - 1) << 2|1 << 1|1 << 0;\r\nret = af9013_wregs(client, cmd, reg, val, len);\r\nif (ret)\r\ngoto err;\r\n} else {\r\ncmd = 0 << 7|0 << 6|(1 - 1) << 2|1 << 1|1 << 0;\r\nfor (i = 0; i < len; i++) {\r\nret = af9013_wregs(client, cmd, reg + i, val + i, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_regmap_read(void *context, const void *reg_buf,\r\nsize_t reg_size, void *val_buf, size_t val_size)\r\n{\r\nstruct i2c_client *client = context;\r\nstruct af9013_state *state = i2c_get_clientdata(client);\r\nint ret, i;\r\nu8 cmd;\r\nu16 reg = ((u8 *)reg_buf)[0] << 8|((u8 *)reg_buf)[1] << 0;\r\nu8 *val = &((u8 *)val_buf)[0];\r\nconst unsigned int len = val_size;\r\nif (state->ts_mode == AF9013_TS_MODE_USB && (reg & 0xff00) != 0xae00) {\r\ncmd = 0 << 7|0 << 6|(len - 1) << 2|1 << 1|0 << 0;\r\nret = af9013_rregs(client, cmd, reg, val_buf, len);\r\nif (ret)\r\ngoto err;\r\n} else {\r\ncmd = 0 << 7|0 << 6|(1 - 1) << 2|1 << 1|0 << 0;\r\nfor (i = 0; i < len; i++) {\r\nret = af9013_rregs(client, cmd, reg + i, val + i, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct af9013_state *state;\r\nstruct af9013_platform_data *pdata = client->dev.platform_data;\r\nstruct dtv_frontend_properties *c;\r\nint ret, i;\r\nu8 firmware_version[4];\r\nstatic const struct regmap_bus regmap_bus = {\r\n.read = af9013_regmap_read,\r\n.write = af9013_regmap_write,\r\n};\r\nstatic const struct regmap_config regmap_config = {\r\n.reg_bits = 16,\r\n.val_bits = 8,\r\n};\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nstate->client = client;\r\ni2c_set_clientdata(client, state);\r\nstate->clk = pdata->clk;\r\nstate->tuner = pdata->tuner;\r\nstate->if_frequency = pdata->if_frequency;\r\nstate->ts_mode = pdata->ts_mode;\r\nstate->ts_output_pin = pdata->ts_output_pin;\r\nstate->spec_inv = pdata->spec_inv;\r\nmemcpy(&state->api_version, pdata->api_version, sizeof(state->api_version));\r\nmemcpy(&state->gpio, pdata->gpio, sizeof(state->gpio));\r\nINIT_DELAYED_WORK(&state->statistics_work, af9013_statistics_work);\r\nstate->regmap = regmap_init(&client->dev, &regmap_bus, client,\r\n&regmap_config);\r\nif (IS_ERR(state->regmap)) {\r\nret = PTR_ERR(state->regmap);\r\ngoto err_kfree;\r\n}\r\nif (state->ts_mode != AF9013_TS_MODE_USB) {\r\nret = af9013_download_firmware(state);\r\nif (ret)\r\ngoto err_regmap_exit;\r\n}\r\nret = regmap_bulk_read(state->regmap, 0x5103, firmware_version,\r\nsizeof(firmware_version));\r\nif (ret)\r\ngoto err_regmap_exit;\r\nfor (i = 0; i < sizeof(state->gpio); i++) {\r\nret = af9013_set_gpio(state, i, state->gpio[i]);\r\nif (ret)\r\ngoto err_regmap_exit;\r\n}\r\nmemcpy(&state->fe.ops, &af9013_ops, sizeof(state->fe.ops));\r\nif (!pdata->attach_in_use)\r\nstate->fe.ops.release = NULL;\r\nstate->fe.demodulator_priv = state;\r\npdata->get_dvb_frontend = af9013_get_dvb_frontend;\r\nc = &state->fe.dtv_property_cache;\r\nc->cnr.len = 1;\r\ndev_info(&client->dev, "Afatech AF9013 successfully attached\n");\r\ndev_info(&client->dev, "firmware version: %d.%d.%d.%d\n",\r\nfirmware_version[0], firmware_version[1],\r\nfirmware_version[2], firmware_version[3]);\r\nreturn 0;\r\nerr_regmap_exit:\r\nregmap_exit(state->regmap);\r\nerr_kfree:\r\nkfree(state);\r\nerr:\r\ndev_dbg(&client->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9013_remove(struct i2c_client *client)\r\n{\r\nstruct af9013_state *state = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\ncancel_delayed_work_sync(&state->statistics_work);\r\nregmap_exit(state->regmap);\r\nkfree(state);\r\nreturn 0;\r\n}
