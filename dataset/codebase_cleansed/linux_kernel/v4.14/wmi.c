static const char *wmi_cmd_to_name(enum wmi_cmd_id wmi_cmd)\r\n{\r\nswitch (wmi_cmd) {\r\ncase WMI_ECHO_CMDID:\r\nreturn "WMI_ECHO_CMDID";\r\ncase WMI_ACCESS_MEMORY_CMDID:\r\nreturn "WMI_ACCESS_MEMORY_CMDID";\r\ncase WMI_GET_FW_VERSION:\r\nreturn "WMI_GET_FW_VERSION";\r\ncase WMI_DISABLE_INTR_CMDID:\r\nreturn "WMI_DISABLE_INTR_CMDID";\r\ncase WMI_ENABLE_INTR_CMDID:\r\nreturn "WMI_ENABLE_INTR_CMDID";\r\ncase WMI_ATH_INIT_CMDID:\r\nreturn "WMI_ATH_INIT_CMDID";\r\ncase WMI_ABORT_TXQ_CMDID:\r\nreturn "WMI_ABORT_TXQ_CMDID";\r\ncase WMI_STOP_TX_DMA_CMDID:\r\nreturn "WMI_STOP_TX_DMA_CMDID";\r\ncase WMI_ABORT_TX_DMA_CMDID:\r\nreturn "WMI_ABORT_TX_DMA_CMDID";\r\ncase WMI_DRAIN_TXQ_CMDID:\r\nreturn "WMI_DRAIN_TXQ_CMDID";\r\ncase WMI_DRAIN_TXQ_ALL_CMDID:\r\nreturn "WMI_DRAIN_TXQ_ALL_CMDID";\r\ncase WMI_START_RECV_CMDID:\r\nreturn "WMI_START_RECV_CMDID";\r\ncase WMI_STOP_RECV_CMDID:\r\nreturn "WMI_STOP_RECV_CMDID";\r\ncase WMI_FLUSH_RECV_CMDID:\r\nreturn "WMI_FLUSH_RECV_CMDID";\r\ncase WMI_SET_MODE_CMDID:\r\nreturn "WMI_SET_MODE_CMDID";\r\ncase WMI_NODE_CREATE_CMDID:\r\nreturn "WMI_NODE_CREATE_CMDID";\r\ncase WMI_NODE_REMOVE_CMDID:\r\nreturn "WMI_NODE_REMOVE_CMDID";\r\ncase WMI_VAP_REMOVE_CMDID:\r\nreturn "WMI_VAP_REMOVE_CMDID";\r\ncase WMI_VAP_CREATE_CMDID:\r\nreturn "WMI_VAP_CREATE_CMDID";\r\ncase WMI_REG_READ_CMDID:\r\nreturn "WMI_REG_READ_CMDID";\r\ncase WMI_REG_WRITE_CMDID:\r\nreturn "WMI_REG_WRITE_CMDID";\r\ncase WMI_REG_RMW_CMDID:\r\nreturn "WMI_REG_RMW_CMDID";\r\ncase WMI_RC_STATE_CHANGE_CMDID:\r\nreturn "WMI_RC_STATE_CHANGE_CMDID";\r\ncase WMI_RC_RATE_UPDATE_CMDID:\r\nreturn "WMI_RC_RATE_UPDATE_CMDID";\r\ncase WMI_TARGET_IC_UPDATE_CMDID:\r\nreturn "WMI_TARGET_IC_UPDATE_CMDID";\r\ncase WMI_TX_AGGR_ENABLE_CMDID:\r\nreturn "WMI_TX_AGGR_ENABLE_CMDID";\r\ncase WMI_TGT_DETACH_CMDID:\r\nreturn "WMI_TGT_DETACH_CMDID";\r\ncase WMI_NODE_UPDATE_CMDID:\r\nreturn "WMI_NODE_UPDATE_CMDID";\r\ncase WMI_INT_STATS_CMDID:\r\nreturn "WMI_INT_STATS_CMDID";\r\ncase WMI_TX_STATS_CMDID:\r\nreturn "WMI_TX_STATS_CMDID";\r\ncase WMI_RX_STATS_CMDID:\r\nreturn "WMI_RX_STATS_CMDID";\r\ncase WMI_BITRATE_MASK_CMDID:\r\nreturn "WMI_BITRATE_MASK_CMDID";\r\n}\r\nreturn "Bogus";\r\n}\r\nstruct wmi *ath9k_init_wmi(struct ath9k_htc_priv *priv)\r\n{\r\nstruct wmi *wmi;\r\nwmi = kzalloc(sizeof(struct wmi), GFP_KERNEL);\r\nif (!wmi)\r\nreturn NULL;\r\nwmi->drv_priv = priv;\r\nwmi->stopped = false;\r\nskb_queue_head_init(&wmi->wmi_event_queue);\r\nspin_lock_init(&wmi->wmi_lock);\r\nspin_lock_init(&wmi->event_lock);\r\nmutex_init(&wmi->op_mutex);\r\nmutex_init(&wmi->multi_write_mutex);\r\nmutex_init(&wmi->multi_rmw_mutex);\r\ninit_completion(&wmi->cmd_wait);\r\nINIT_LIST_HEAD(&wmi->pending_tx_events);\r\ntasklet_init(&wmi->wmi_event_tasklet, ath9k_wmi_event_tasklet,\r\n(unsigned long)wmi);\r\nreturn wmi;\r\n}\r\nvoid ath9k_deinit_wmi(struct ath9k_htc_priv *priv)\r\n{\r\nstruct wmi *wmi = priv->wmi;\r\nmutex_lock(&wmi->op_mutex);\r\nwmi->stopped = true;\r\nmutex_unlock(&wmi->op_mutex);\r\nkfree(priv->wmi);\r\n}\r\nvoid ath9k_wmi_event_drain(struct ath9k_htc_priv *priv)\r\n{\r\nunsigned long flags;\r\ntasklet_kill(&priv->wmi->wmi_event_tasklet);\r\nspin_lock_irqsave(&priv->wmi->wmi_lock, flags);\r\n__skb_queue_purge(&priv->wmi->wmi_event_queue);\r\nspin_unlock_irqrestore(&priv->wmi->wmi_lock, flags);\r\n}\r\nvoid ath9k_wmi_event_tasklet(unsigned long data)\r\n{\r\nstruct wmi *wmi = (struct wmi *)data;\r\nstruct ath9k_htc_priv *priv = wmi->drv_priv;\r\nstruct wmi_cmd_hdr *hdr;\r\nvoid *wmi_event;\r\nstruct wmi_event_swba *swba;\r\nstruct sk_buff *skb = NULL;\r\nunsigned long flags;\r\nu16 cmd_id;\r\ndo {\r\nspin_lock_irqsave(&wmi->wmi_lock, flags);\r\nskb = __skb_dequeue(&wmi->wmi_event_queue);\r\nif (!skb) {\r\nspin_unlock_irqrestore(&wmi->wmi_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&wmi->wmi_lock, flags);\r\nhdr = (struct wmi_cmd_hdr *) skb->data;\r\ncmd_id = be16_to_cpu(hdr->command_id);\r\nwmi_event = skb_pull(skb, sizeof(struct wmi_cmd_hdr));\r\nswitch (cmd_id) {\r\ncase WMI_SWBA_EVENTID:\r\nswba = (struct wmi_event_swba *) wmi_event;\r\nath9k_htc_swba(priv, swba);\r\nbreak;\r\ncase WMI_FATAL_EVENTID:\r\nieee80211_queue_work(wmi->drv_priv->hw,\r\n&wmi->drv_priv->fatal_work);\r\nbreak;\r\ncase WMI_TXSTATUS_EVENTID:\r\nspin_lock_bh(&priv->tx.tx_lock);\r\nif (priv->tx.flags & ATH9K_HTC_OP_TX_DRAIN) {\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\nbreak;\r\n}\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\nath9k_htc_txstatus(priv, wmi_event);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nkfree_skb(skb);\r\n} while (1);\r\n}\r\nvoid ath9k_fatal_work(struct work_struct *work)\r\n{\r\nstruct ath9k_htc_priv *priv = container_of(work, struct ath9k_htc_priv,\r\nfatal_work);\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nath_dbg(common, FATAL, "FATAL Event received, resetting device\n");\r\nath9k_htc_reset(priv);\r\n}\r\nstatic void ath9k_wmi_rsp_callback(struct wmi *wmi, struct sk_buff *skb)\r\n{\r\nskb_pull(skb, sizeof(struct wmi_cmd_hdr));\r\nif (wmi->cmd_rsp_buf != NULL && wmi->cmd_rsp_len != 0)\r\nmemcpy(wmi->cmd_rsp_buf, skb->data, wmi->cmd_rsp_len);\r\ncomplete(&wmi->cmd_wait);\r\n}\r\nstatic void ath9k_wmi_ctrl_rx(void *priv, struct sk_buff *skb,\r\nenum htc_endpoint_id epid)\r\n{\r\nstruct wmi *wmi = (struct wmi *) priv;\r\nstruct wmi_cmd_hdr *hdr;\r\nu16 cmd_id;\r\nif (unlikely(wmi->stopped))\r\ngoto free_skb;\r\nhdr = (struct wmi_cmd_hdr *) skb->data;\r\ncmd_id = be16_to_cpu(hdr->command_id);\r\nif (cmd_id & 0x1000) {\r\nspin_lock(&wmi->wmi_lock);\r\n__skb_queue_tail(&wmi->wmi_event_queue, skb);\r\nspin_unlock(&wmi->wmi_lock);\r\ntasklet_schedule(&wmi->wmi_event_tasklet);\r\nreturn;\r\n}\r\nspin_lock(&wmi->wmi_lock);\r\nif (be16_to_cpu(hdr->seq_no) != wmi->last_seq_id) {\r\nspin_unlock(&wmi->wmi_lock);\r\ngoto free_skb;\r\n}\r\nspin_unlock(&wmi->wmi_lock);\r\nath9k_wmi_rsp_callback(wmi, skb);\r\nfree_skb:\r\nkfree_skb(skb);\r\n}\r\nstatic void ath9k_wmi_ctrl_tx(void *priv, struct sk_buff *skb,\r\nenum htc_endpoint_id epid, bool txok)\r\n{\r\nkfree_skb(skb);\r\n}\r\nint ath9k_wmi_connect(struct htc_target *htc, struct wmi *wmi,\r\nenum htc_endpoint_id *wmi_ctrl_epid)\r\n{\r\nstruct htc_service_connreq connect;\r\nint ret;\r\nwmi->htc = htc;\r\nmemset(&connect, 0, sizeof(connect));\r\nconnect.ep_callbacks.priv = wmi;\r\nconnect.ep_callbacks.tx = ath9k_wmi_ctrl_tx;\r\nconnect.ep_callbacks.rx = ath9k_wmi_ctrl_rx;\r\nconnect.service_id = WMI_CONTROL_SVC;\r\nret = htc_connect_service(htc, &connect, &wmi->ctrl_epid);\r\nif (ret)\r\nreturn ret;\r\n*wmi_ctrl_epid = wmi->ctrl_epid;\r\nreturn 0;\r\n}\r\nstatic int ath9k_wmi_cmd_issue(struct wmi *wmi,\r\nstruct sk_buff *skb,\r\nenum wmi_cmd_id cmd, u16 len)\r\n{\r\nstruct wmi_cmd_hdr *hdr;\r\nunsigned long flags;\r\nhdr = skb_push(skb, sizeof(struct wmi_cmd_hdr));\r\nhdr->command_id = cpu_to_be16(cmd);\r\nhdr->seq_no = cpu_to_be16(++wmi->tx_seq_id);\r\nspin_lock_irqsave(&wmi->wmi_lock, flags);\r\nwmi->last_seq_id = wmi->tx_seq_id;\r\nspin_unlock_irqrestore(&wmi->wmi_lock, flags);\r\nreturn htc_send_epid(wmi->htc, skb, wmi->ctrl_epid);\r\n}\r\nint ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id cmd_id,\r\nu8 *cmd_buf, u32 cmd_len,\r\nu8 *rsp_buf, u32 rsp_len,\r\nu32 timeout)\r\n{\r\nstruct ath_hw *ah = wmi->drv_priv->ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nu16 headroom = sizeof(struct htc_frame_hdr) +\r\nsizeof(struct wmi_cmd_hdr);\r\nstruct sk_buff *skb;\r\nunsigned long time_left;\r\nint ret = 0;\r\nif (ah->ah_flags & AH_UNPLUGGED)\r\nreturn 0;\r\nskb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_reserve(skb, headroom);\r\nif (cmd_len != 0 && cmd_buf != NULL) {\r\nskb_put_data(skb, cmd_buf, cmd_len);\r\n}\r\nmutex_lock(&wmi->op_mutex);\r\nif (unlikely(wmi->stopped)) {\r\nret = -EPROTO;\r\ngoto out;\r\n}\r\nwmi->cmd_rsp_buf = rsp_buf;\r\nwmi->cmd_rsp_len = rsp_len;\r\nret = ath9k_wmi_cmd_issue(wmi, skb, cmd_id, cmd_len);\r\nif (ret)\r\ngoto out;\r\ntime_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);\r\nif (!time_left) {\r\nath_dbg(common, WMI, "Timeout waiting for WMI command: %s\n",\r\nwmi_cmd_to_name(cmd_id));\r\nmutex_unlock(&wmi->op_mutex);\r\nreturn -ETIMEDOUT;\r\n}\r\nmutex_unlock(&wmi->op_mutex);\r\nreturn 0;\r\nout:\r\nath_dbg(common, WMI, "WMI failure for: %s\n", wmi_cmd_to_name(cmd_id));\r\nmutex_unlock(&wmi->op_mutex);\r\nkfree_skb(skb);\r\nreturn ret;\r\n}
