static const struct da8xx_ddrctl_config_knob *\r\nda8xx_ddrctl_match_knob(const struct da8xx_ddrctl_setting *setting)\r\n{\r\nconst struct da8xx_ddrctl_config_knob *knob;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(da8xx_ddrctl_knobs); i++) {\r\nknob = &da8xx_ddrctl_knobs[i];\r\nif (strcmp(knob->name, setting->name) == 0)\r\nreturn knob;\r\n}\r\nreturn NULL;\r\n}\r\nstatic const struct da8xx_ddrctl_setting *da8xx_ddrctl_get_board_settings(void)\r\n{\r\nconst struct da8xx_ddrctl_board_settings *board_settings;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(da8xx_ddrctl_board_confs); i++) {\r\nboard_settings = &da8xx_ddrctl_board_confs[i];\r\nif (of_machine_is_compatible(board_settings->board))\r\nreturn board_settings->settings;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int da8xx_ddrctl_probe(struct platform_device *pdev)\r\n{\r\nconst struct da8xx_ddrctl_config_knob *knob;\r\nconst struct da8xx_ddrctl_setting *setting;\r\nstruct device_node *node;\r\nstruct resource *res;\r\nvoid __iomem *ddrctl;\r\nstruct device *dev;\r\nu32 reg;\r\ndev = &pdev->dev;\r\nnode = dev->of_node;\r\nsetting = da8xx_ddrctl_get_board_settings();\r\nif (!setting) {\r\ndev_err(dev, "no settings defined for this board\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nddrctl = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(ddrctl)) {\r\ndev_err(dev, "unable to map memory controller registers\n");\r\nreturn PTR_ERR(ddrctl);\r\n}\r\nfor (; setting->name; setting++) {\r\nknob = da8xx_ddrctl_match_knob(setting);\r\nif (!knob) {\r\ndev_warn(dev,\r\n"no such config option: %s\n", setting->name);\r\ncontinue;\r\n}\r\nif (knob->reg + sizeof(u32) > resource_size(res)) {\r\ndev_warn(dev,\r\n"register offset of '%s' exceeds mapped memory size\n",\r\nknob->name);\r\ncontinue;\r\n}\r\nreg = readl(ddrctl + knob->reg);\r\nreg &= knob->mask;\r\nreg |= setting->val << knob->shift;\r\ndev_dbg(dev, "writing 0x%08x to %s\n", reg, setting->name);\r\nwritel(reg, ddrctl + knob->reg);\r\n}\r\nreturn 0;\r\n}
