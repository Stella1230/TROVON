void gdc_lut_store(\r\nconst gdc_ID_t ID,\r\nconst int data[4][HRT_GDC_N])\r\n{\r\nunsigned int i, lut_offset = HRT_GDC_LUT_IDX;\r\nassert(ID < N_GDC_ID);\r\nassert(HRT_GDC_LUT_COEFF_OFFSET <= (4*sizeof(hrt_data)));\r\nfor (i = 0; i < HRT_GDC_N; i++) {\r\nhrt_data entry_0 = data[0][i] & HRT_GDC_BCI_COEF_MASK;\r\nhrt_data entry_1 = data[1][i] & HRT_GDC_BCI_COEF_MASK;\r\nhrt_data entry_2 = data[2][i] & HRT_GDC_BCI_COEF_MASK;\r\nhrt_data entry_3 = data[3][i] & HRT_GDC_BCI_COEF_MASK;\r\nhrt_data word_0 = entry_0 |\r\n(entry_1 << HRT_GDC_LUT_COEFF_OFFSET);\r\nhrt_data word_1 = entry_2 |\r\n(entry_3 << HRT_GDC_LUT_COEFF_OFFSET);\r\ngdc_reg_store(ID, lut_offset++, word_0);\r\ngdc_reg_store(ID, lut_offset++, word_1);\r\n}\r\nreturn;\r\n}\r\nvoid gdc_lut_convert_to_isp_format(const int in_lut[4][HRT_GDC_N],\r\nint out_lut[4][HRT_GDC_N])\r\n{\r\nunsigned int i;\r\nint *out = (int *)out_lut;\r\nfor (i = 0; i < HRT_GDC_N; i++) {\r\nout[0] = in_lut[0][i];\r\nout[1] = in_lut[1][i];\r\nout[2] = in_lut[2][i];\r\nout[3] = in_lut[3][i];\r\nout += 4;\r\n}\r\n}\r\nint gdc_get_unity(\r\nconst gdc_ID_t ID)\r\n{\r\nassert(ID < N_GDC_ID);\r\n(void)ID;\r\nreturn (int)(1UL << HRT_GDC_FRAC_BITS);\r\n}\r\nSTORAGE_CLASS_INLINE void gdc_reg_store(\r\nconst gdc_ID_t ID,\r\nconst unsigned int reg,\r\nconst hrt_data value)\r\n{\r\nia_css_device_store_uint32(GDC_BASE[ID] + reg*sizeof(hrt_data), value);\r\nreturn;\r\n}\r\nSTORAGE_CLASS_INLINE hrt_data gdc_reg_load(\r\nconst gdc_ID_t ID,\r\nconst unsigned int reg)\r\n{\r\nreturn ia_css_device_load_uint32(GDC_BASE[ID] + reg*sizeof(hrt_data));\r\n}
