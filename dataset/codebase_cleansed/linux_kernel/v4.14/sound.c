void snd_request_card(int card)\r\n{\r\nif (snd_card_locked(card))\r\nreturn;\r\nif (card < 0 || card >= cards_limit)\r\nreturn;\r\nrequest_module("snd-card-%i", card);\r\n}\r\nstatic void snd_request_other(int minor)\r\n{\r\nchar *str;\r\nswitch (minor) {\r\ncase SNDRV_MINOR_SEQUENCER: str = "snd-seq"; break;\r\ncase SNDRV_MINOR_TIMER: str = "snd-timer"; break;\r\ndefault: return;\r\n}\r\nrequest_module(str);\r\n}\r\nvoid *snd_lookup_minor_data(unsigned int minor, int type)\r\n{\r\nstruct snd_minor *mreg;\r\nvoid *private_data;\r\nif (minor >= ARRAY_SIZE(snd_minors))\r\nreturn NULL;\r\nmutex_lock(&sound_mutex);\r\nmreg = snd_minors[minor];\r\nif (mreg && mreg->type == type) {\r\nprivate_data = mreg->private_data;\r\nif (private_data && mreg->card_ptr)\r\nget_device(&mreg->card_ptr->card_dev);\r\n} else\r\nprivate_data = NULL;\r\nmutex_unlock(&sound_mutex);\r\nreturn private_data;\r\n}\r\nstatic struct snd_minor *autoload_device(unsigned int minor)\r\n{\r\nint dev;\r\nmutex_unlock(&sound_mutex);\r\ndev = SNDRV_MINOR_DEVICE(minor);\r\nif (dev == SNDRV_MINOR_CONTROL) {\r\nint card = SNDRV_MINOR_CARD(minor);\r\nif (snd_cards[card] == NULL)\r\nsnd_request_card(card);\r\n} else if (dev == SNDRV_MINOR_GLOBAL) {\r\nsnd_request_other(minor);\r\n}\r\nmutex_lock(&sound_mutex);\r\nreturn snd_minors[minor];\r\n}\r\nstatic int snd_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned int minor = iminor(inode);\r\nstruct snd_minor *mptr = NULL;\r\nconst struct file_operations *new_fops;\r\nint err = 0;\r\nif (minor >= ARRAY_SIZE(snd_minors))\r\nreturn -ENODEV;\r\nmutex_lock(&sound_mutex);\r\nmptr = snd_minors[minor];\r\nif (mptr == NULL) {\r\nmptr = autoload_device(minor);\r\nif (!mptr) {\r\nmutex_unlock(&sound_mutex);\r\nreturn -ENODEV;\r\n}\r\n}\r\nnew_fops = fops_get(mptr->f_ops);\r\nmutex_unlock(&sound_mutex);\r\nif (!new_fops)\r\nreturn -ENODEV;\r\nreplace_fops(file, new_fops);\r\nif (file->f_op->open)\r\nerr = file->f_op->open(inode, file);\r\nreturn err;\r\n}\r\nstatic int snd_find_free_minor(int type, struct snd_card *card, int dev)\r\n{\r\nint minor;\r\nif (type == SNDRV_DEVICE_TYPE_SEQUENCER)\r\nreturn SNDRV_MINOR_SEQUENCER;\r\nif (type == SNDRV_DEVICE_TYPE_TIMER)\r\nreturn SNDRV_MINOR_TIMER;\r\nfor (minor = 0; minor < ARRAY_SIZE(snd_minors); ++minor) {\r\nif (SNDRV_MINOR_DEVICE(minor) == SNDRV_MINOR_CONTROL)\r\ncontinue;\r\nif (minor == SNDRV_MINOR_SEQUENCER ||\r\nminor == SNDRV_MINOR_TIMER)\r\ncontinue;\r\nif (!snd_minors[minor])\r\nreturn minor;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int snd_find_free_minor(int type, struct snd_card *card, int dev)\r\n{\r\nint minor;\r\nswitch (type) {\r\ncase SNDRV_DEVICE_TYPE_SEQUENCER:\r\ncase SNDRV_DEVICE_TYPE_TIMER:\r\nminor = type;\r\nbreak;\r\ncase SNDRV_DEVICE_TYPE_CONTROL:\r\nif (snd_BUG_ON(!card))\r\nreturn -EINVAL;\r\nminor = SNDRV_MINOR(card->number, type);\r\nbreak;\r\ncase SNDRV_DEVICE_TYPE_HWDEP:\r\ncase SNDRV_DEVICE_TYPE_RAWMIDI:\r\ncase SNDRV_DEVICE_TYPE_PCM_PLAYBACK:\r\ncase SNDRV_DEVICE_TYPE_PCM_CAPTURE:\r\ncase SNDRV_DEVICE_TYPE_COMPRESS:\r\nif (snd_BUG_ON(!card))\r\nreturn -EINVAL;\r\nminor = SNDRV_MINOR(card->number, type + dev);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (snd_BUG_ON(minor < 0 || minor >= SNDRV_OS_MINORS))\r\nreturn -EINVAL;\r\nif (snd_minors[minor])\r\nreturn -EBUSY;\r\nreturn minor;\r\n}\r\nint snd_register_device(int type, struct snd_card *card, int dev,\r\nconst struct file_operations *f_ops,\r\nvoid *private_data, struct device *device)\r\n{\r\nint minor;\r\nint err = 0;\r\nstruct snd_minor *preg;\r\nif (snd_BUG_ON(!device))\r\nreturn -EINVAL;\r\npreg = kmalloc(sizeof *preg, GFP_KERNEL);\r\nif (preg == NULL)\r\nreturn -ENOMEM;\r\npreg->type = type;\r\npreg->card = card ? card->number : -1;\r\npreg->device = dev;\r\npreg->f_ops = f_ops;\r\npreg->private_data = private_data;\r\npreg->card_ptr = card;\r\nmutex_lock(&sound_mutex);\r\nminor = snd_find_free_minor(type, card, dev);\r\nif (minor < 0) {\r\nerr = minor;\r\ngoto error;\r\n}\r\npreg->dev = device;\r\ndevice->devt = MKDEV(major, minor);\r\nerr = device_add(device);\r\nif (err < 0)\r\ngoto error;\r\nsnd_minors[minor] = preg;\r\nerror:\r\nmutex_unlock(&sound_mutex);\r\nif (err < 0)\r\nkfree(preg);\r\nreturn err;\r\n}\r\nint snd_unregister_device(struct device *dev)\r\n{\r\nint minor;\r\nstruct snd_minor *preg;\r\nmutex_lock(&sound_mutex);\r\nfor (minor = 0; minor < ARRAY_SIZE(snd_minors); ++minor) {\r\npreg = snd_minors[minor];\r\nif (preg && preg->dev == dev) {\r\nsnd_minors[minor] = NULL;\r\ndevice_del(dev);\r\nkfree(preg);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&sound_mutex);\r\nif (minor >= ARRAY_SIZE(snd_minors))\r\nreturn -ENOENT;\r\nreturn 0;\r\n}\r\nstatic const char *snd_device_type_name(int type)\r\n{\r\nswitch (type) {\r\ncase SNDRV_DEVICE_TYPE_CONTROL:\r\nreturn "control";\r\ncase SNDRV_DEVICE_TYPE_HWDEP:\r\nreturn "hardware dependent";\r\ncase SNDRV_DEVICE_TYPE_RAWMIDI:\r\nreturn "raw midi";\r\ncase SNDRV_DEVICE_TYPE_PCM_PLAYBACK:\r\nreturn "digital audio playback";\r\ncase SNDRV_DEVICE_TYPE_PCM_CAPTURE:\r\nreturn "digital audio capture";\r\ncase SNDRV_DEVICE_TYPE_SEQUENCER:\r\nreturn "sequencer";\r\ncase SNDRV_DEVICE_TYPE_TIMER:\r\nreturn "timer";\r\ndefault:\r\nreturn "?";\r\n}\r\n}\r\nstatic void snd_minor_info_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\r\n{\r\nint minor;\r\nstruct snd_minor *mptr;\r\nmutex_lock(&sound_mutex);\r\nfor (minor = 0; minor < SNDRV_OS_MINORS; ++minor) {\r\nif (!(mptr = snd_minors[minor]))\r\ncontinue;\r\nif (mptr->card >= 0) {\r\nif (mptr->device >= 0)\r\nsnd_iprintf(buffer, "%3i: [%2i-%2i]: %s\n",\r\nminor, mptr->card, mptr->device,\r\nsnd_device_type_name(mptr->type));\r\nelse\r\nsnd_iprintf(buffer, "%3i: [%2i] : %s\n",\r\nminor, mptr->card,\r\nsnd_device_type_name(mptr->type));\r\n} else\r\nsnd_iprintf(buffer, "%3i: : %s\n", minor,\r\nsnd_device_type_name(mptr->type));\r\n}\r\nmutex_unlock(&sound_mutex);\r\n}\r\nint __init snd_minor_info_init(void)\r\n{\r\nstruct snd_info_entry *entry;\r\nentry = snd_info_create_module_entry(THIS_MODULE, "devices", NULL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->c.text.read = snd_minor_info_read;\r\nreturn snd_info_register(entry);\r\n}\r\nstatic int __init alsa_sound_init(void)\r\n{\r\nsnd_major = major;\r\nsnd_ecards_limit = cards_limit;\r\nif (register_chrdev(major, "alsa", &snd_fops)) {\r\npr_err("ALSA core: unable to register native major device number %d\n", major);\r\nreturn -EIO;\r\n}\r\nif (snd_info_init() < 0) {\r\nunregister_chrdev(major, "alsa");\r\nreturn -ENOMEM;\r\n}\r\n#ifndef MODULE\r\npr_info("Advanced Linux Sound Architecture Driver Initialized.\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_sound_exit(void)\r\n{\r\nsnd_info_done();\r\nunregister_chrdev(major, "alsa");\r\n}
