static void log_quirks(struct device *dev)\r\n{\r\nint map;\r\nbool has_dmic = false;\r\nbool has_mclk = false;\r\nbool has_ssp0 = false;\r\nbool has_ssp0_aif1 = false;\r\nbool has_ssp0_aif2 = false;\r\nbool has_ssp2_aif2 = false;\r\nmap = BYT_RT5640_MAP(byt_rt5640_quirk);\r\nswitch (map) {\r\ncase BYT_RT5640_DMIC1_MAP:\r\ndev_info(dev, "quirk DMIC1_MAP enabled\n");\r\nhas_dmic = true;\r\nbreak;\r\ncase BYT_RT5640_DMIC2_MAP:\r\ndev_info(dev, "quirk DMIC2_MAP enabled\n");\r\nhas_dmic = true;\r\nbreak;\r\ncase BYT_RT5640_IN1_MAP:\r\ndev_info(dev, "quirk IN1_MAP enabled\n");\r\nbreak;\r\ncase BYT_RT5640_IN3_MAP:\r\ndev_info(dev, "quirk IN3_MAP enabled\n");\r\nbreak;\r\ndefault:\r\ndev_err(dev, "quirk map 0x%x is not supported, microphone input will not work\n", map);\r\nbreak;\r\n}\r\nif (byt_rt5640_quirk & BYT_RT5640_DMIC_EN) {\r\nif (has_dmic)\r\ndev_info(dev, "quirk DMIC enabled\n");\r\nelse\r\ndev_err(dev, "quirk DMIC enabled but no DMIC input set, will be ignored\n");\r\n}\r\nif (byt_rt5640_quirk & BYT_RT5640_MONO_SPEAKER)\r\ndev_info(dev, "quirk MONO_SPEAKER enabled\n");\r\nif (byt_rt5640_quirk & BYT_RT5640_DIFF_MIC) {\r\nif (!has_dmic)\r\ndev_info(dev, "quirk DIFF_MIC enabled\n");\r\nelse\r\ndev_info(dev, "quirk DIFF_MIC enabled but DMIC input selected, will be ignored\n");\r\n}\r\nif (byt_rt5640_quirk & BYT_RT5640_SSP0_AIF1) {\r\ndev_info(dev, "quirk SSP0_AIF1 enabled\n");\r\nhas_ssp0 = true;\r\nhas_ssp0_aif1 = true;\r\n}\r\nif (byt_rt5640_quirk & BYT_RT5640_SSP0_AIF2) {\r\ndev_info(dev, "quirk SSP0_AIF2 enabled\n");\r\nhas_ssp0 = true;\r\nhas_ssp0_aif2 = true;\r\n}\r\nif (byt_rt5640_quirk & BYT_RT5640_SSP2_AIF2) {\r\ndev_info(dev, "quirk SSP2_AIF2 enabled\n");\r\nhas_ssp2_aif2 = true;\r\n}\r\nif (is_bytcr && !has_ssp0)\r\ndev_err(dev, "Invalid routing, bytcr detected but no SSP0-based quirk, audio cannot work with SSP2 on bytcr\n");\r\nif (has_ssp0_aif1 && has_ssp0_aif2)\r\ndev_err(dev, "Invalid routing, SSP0 cannot be connected to both AIF1 and AIF2\n");\r\nif (has_ssp0 && has_ssp2_aif2)\r\ndev_err(dev, "Invalid routing, cannot have both SSP0 and SSP2 connected to codec\n");\r\nif (byt_rt5640_quirk & BYT_RT5640_MCLK_EN) {\r\ndev_info(dev, "quirk MCLK_EN enabled\n");\r\nhas_mclk = true;\r\n}\r\nif (byt_rt5640_quirk & BYT_RT5640_MCLK_25MHZ) {\r\nif (has_mclk)\r\ndev_info(dev, "quirk MCLK_25MHZ enabled\n");\r\nelse\r\ndev_err(dev, "quirk MCLK_25MHZ enabled but quirk MCLK not selected, will be ignored\n");\r\n}\r\n}\r\nstatic inline struct snd_soc_dai *byt_get_codec_dai(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd;\r\nlist_for_each_entry(rtd, &card->rtd_list, list) {\r\nif (!strncmp(rtd->codec_dai->name, BYT_CODEC_DAI1,\r\nstrlen(BYT_CODEC_DAI1)))\r\nreturn rtd->codec_dai;\r\nif (!strncmp(rtd->codec_dai->name, BYT_CODEC_DAI2,\r\nstrlen(BYT_CODEC_DAI2)))\r\nreturn rtd->codec_dai;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int platform_clock_control(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nstruct snd_soc_dapm_context *dapm = w->dapm;\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct snd_soc_dai *codec_dai;\r\nstruct byt_rt5640_private *priv = snd_soc_card_get_drvdata(card);\r\nint ret;\r\ncodec_dai = byt_get_codec_dai(card);\r\nif (!codec_dai) {\r\ndev_err(card->dev,\r\n"Codec dai not found; Unable to set platform clock\n");\r\nreturn -EIO;\r\n}\r\nif (SND_SOC_DAPM_EVENT_ON(event)) {\r\nif ((byt_rt5640_quirk & BYT_RT5640_MCLK_EN) && priv->mclk) {\r\nret = clk_prepare_enable(priv->mclk);\r\nif (ret < 0) {\r\ndev_err(card->dev,\r\n"could not configure MCLK state\n");\r\nreturn ret;\r\n}\r\n}\r\nret = snd_soc_dai_set_sysclk(codec_dai, RT5640_SCLK_S_PLL1,\r\n48000 * 512,\r\nSND_SOC_CLOCK_IN);\r\n} else {\r\nret = snd_soc_dai_set_sysclk(codec_dai, RT5640_SCLK_S_RCCLK,\r\n48000 * 512,\r\nSND_SOC_CLOCK_IN);\r\nif (!ret) {\r\nif ((byt_rt5640_quirk & BYT_RT5640_MCLK_EN) && priv->mclk)\r\nclk_disable_unprepare(priv->mclk);\r\n}\r\n}\r\nif (ret < 0) {\r\ndev_err(card->dev, "can't set codec sysclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int byt_rt5640_aif1_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nint ret;\r\nret = snd_soc_dai_set_sysclk(codec_dai, RT5640_SCLK_S_PLL1,\r\nparams_rate(params) * 512,\r\nSND_SOC_CLOCK_IN);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set codec clock %d\n", ret);\r\nreturn ret;\r\n}\r\nif (!(byt_rt5640_quirk & BYT_RT5640_MCLK_EN)) {\r\nif ((byt_rt5640_quirk & BYT_RT5640_SSP0_AIF1) ||\r\n(byt_rt5640_quirk & BYT_RT5640_SSP0_AIF2)) {\r\nret = snd_soc_dai_set_pll(codec_dai, 0,\r\nRT5640_PLL1_S_BCLK1,\r\nparams_rate(params) * 32,\r\nparams_rate(params) * 512);\r\n} else {\r\nret = snd_soc_dai_set_pll(codec_dai, 0,\r\nRT5640_PLL1_S_BCLK1,\r\nparams_rate(params) * 50,\r\nparams_rate(params) * 512);\r\n}\r\n} else {\r\nif (byt_rt5640_quirk & BYT_RT5640_MCLK_25MHZ) {\r\nret = snd_soc_dai_set_pll(codec_dai, 0,\r\nRT5640_PLL1_S_MCLK,\r\n25000000,\r\nparams_rate(params) * 512);\r\n} else {\r\nret = snd_soc_dai_set_pll(codec_dai, 0,\r\nRT5640_PLL1_S_MCLK,\r\n19200000,\r\nparams_rate(params) * 512);\r\n}\r\n}\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set codec pll: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int byt_rt5640_quirk_cb(const struct dmi_system_id *id)\r\n{\r\nbyt_rt5640_quirk = (unsigned long)id->driver_data;\r\nreturn 1;\r\n}\r\nstatic int byt_rt5640_init(struct snd_soc_pcm_runtime *runtime)\r\n{\r\nint ret;\r\nstruct snd_soc_codec *codec = runtime->codec;\r\nstruct snd_soc_card *card = runtime->card;\r\nconst struct snd_soc_dapm_route *custom_map;\r\nstruct byt_rt5640_private *priv = snd_soc_card_get_drvdata(card);\r\nint num_routes;\r\ncard->dapm.idle_bias_off = true;\r\nrt5640_sel_asrc_clk_src(codec,\r\nRT5640_DA_STEREO_FILTER |\r\nRT5640_DA_MONO_L_FILTER |\r\nRT5640_DA_MONO_R_FILTER |\r\nRT5640_AD_STEREO_FILTER |\r\nRT5640_AD_MONO_L_FILTER |\r\nRT5640_AD_MONO_R_FILTER,\r\nRT5640_CLK_SEL_ASRC);\r\nret = snd_soc_add_card_controls(card, byt_rt5640_controls,\r\nARRAY_SIZE(byt_rt5640_controls));\r\nif (ret) {\r\ndev_err(card->dev, "unable to add card controls\n");\r\nreturn ret;\r\n}\r\nswitch (BYT_RT5640_MAP(byt_rt5640_quirk)) {\r\ncase BYT_RT5640_IN1_MAP:\r\ncustom_map = byt_rt5640_intmic_in1_map;\r\nnum_routes = ARRAY_SIZE(byt_rt5640_intmic_in1_map);\r\nbreak;\r\ncase BYT_RT5640_IN3_MAP:\r\ncustom_map = byt_rt5640_intmic_in3_map;\r\nnum_routes = ARRAY_SIZE(byt_rt5640_intmic_in3_map);\r\nbreak;\r\ncase BYT_RT5640_DMIC2_MAP:\r\ncustom_map = byt_rt5640_intmic_dmic2_map;\r\nnum_routes = ARRAY_SIZE(byt_rt5640_intmic_dmic2_map);\r\nbreak;\r\ndefault:\r\ncustom_map = byt_rt5640_intmic_dmic1_map;\r\nnum_routes = ARRAY_SIZE(byt_rt5640_intmic_dmic1_map);\r\n}\r\nret = snd_soc_dapm_add_routes(&card->dapm, custom_map, num_routes);\r\nif (ret)\r\nreturn ret;\r\nif (byt_rt5640_quirk & BYT_RT5640_SSP2_AIF2) {\r\nret = snd_soc_dapm_add_routes(&card->dapm,\r\nbyt_rt5640_ssp2_aif2_map,\r\nARRAY_SIZE(byt_rt5640_ssp2_aif2_map));\r\n} else if (byt_rt5640_quirk & BYT_RT5640_SSP0_AIF1) {\r\nret = snd_soc_dapm_add_routes(&card->dapm,\r\nbyt_rt5640_ssp0_aif1_map,\r\nARRAY_SIZE(byt_rt5640_ssp0_aif1_map));\r\n} else if (byt_rt5640_quirk & BYT_RT5640_SSP0_AIF2) {\r\nret = snd_soc_dapm_add_routes(&card->dapm,\r\nbyt_rt5640_ssp0_aif2_map,\r\nARRAY_SIZE(byt_rt5640_ssp0_aif2_map));\r\n} else {\r\nret = snd_soc_dapm_add_routes(&card->dapm,\r\nbyt_rt5640_ssp2_aif1_map,\r\nARRAY_SIZE(byt_rt5640_ssp2_aif1_map));\r\n}\r\nif (ret)\r\nreturn ret;\r\nif (byt_rt5640_quirk & BYT_RT5640_MONO_SPEAKER) {\r\nret = snd_soc_dapm_add_routes(&card->dapm,\r\nbyt_rt5640_mono_spk_map,\r\nARRAY_SIZE(byt_rt5640_mono_spk_map));\r\n} else {\r\nret = snd_soc_dapm_add_routes(&card->dapm,\r\nbyt_rt5640_stereo_spk_map,\r\nARRAY_SIZE(byt_rt5640_stereo_spk_map));\r\n}\r\nif (ret)\r\nreturn ret;\r\nif (byt_rt5640_quirk & BYT_RT5640_DIFF_MIC) {\r\nsnd_soc_update_bits(codec, RT5640_IN1_IN2, RT5640_IN_DF1,\r\nRT5640_IN_DF1);\r\n}\r\nif (byt_rt5640_quirk & BYT_RT5640_DMIC_EN) {\r\nret = rt5640_dmic_enable(codec, 0, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nsnd_soc_dapm_ignore_suspend(&card->dapm, "Headphone");\r\nsnd_soc_dapm_ignore_suspend(&card->dapm, "Speaker");\r\nif ((byt_rt5640_quirk & BYT_RT5640_MCLK_EN) && priv->mclk) {\r\nret = clk_prepare_enable(priv->mclk);\r\nif (!ret)\r\nclk_disable_unprepare(priv->mclk);\r\nif (byt_rt5640_quirk & BYT_RT5640_MCLK_25MHZ)\r\nret = clk_set_rate(priv->mclk, 25000000);\r\nelse\r\nret = clk_set_rate(priv->mclk, 19200000);\r\nif (ret)\r\ndev_err(card->dev, "unable to set MCLK rate\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int byt_rt5640_codec_fixup(struct snd_soc_pcm_runtime *rtd,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_interval *rate = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval *channels = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nint ret;\r\nrate->min = rate->max = 48000;\r\nchannels->min = channels->max = 2;\r\nif ((byt_rt5640_quirk & BYT_RT5640_SSP0_AIF1) ||\r\n(byt_rt5640_quirk & BYT_RT5640_SSP0_AIF2)) {\r\nparams_set_format(params, SNDRV_PCM_FORMAT_S16_LE);\r\nret = snd_soc_dai_set_fmt(rtd->cpu_dai,\r\nSND_SOC_DAIFMT_I2S |\r\nSND_SOC_DAIFMT_NB_NF |\r\nSND_SOC_DAIFMT_CBS_CFS\r\n);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set format to I2S, err %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_dai_set_tdm_slot(rtd->cpu_dai, 0x3, 0x3, 2, 16);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set I2S config, err %d\n", ret);\r\nreturn ret;\r\n}\r\n} else {\r\nparams_set_format(params, SNDRV_PCM_FORMAT_S24_LE);\r\nret = snd_soc_dai_set_fmt(rtd->cpu_dai,\r\nSND_SOC_DAIFMT_I2S |\r\nSND_SOC_DAIFMT_NB_NF |\r\nSND_SOC_DAIFMT_CBS_CFS\r\n);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set format to I2S, err %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_dai_set_tdm_slot(rtd->cpu_dai, 0x3, 0x3, 2, 24);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set I2S config, err %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int byt_rt5640_aif1_startup(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_hw_constraint_single(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE, 48000);\r\n}\r\nstatic bool is_valleyview(void)\r\n{\r\nstatic const struct x86_cpu_id cpu_ids[] = {\r\n{ X86_VENDOR_INTEL, 6, 55 },\r\n{}\r\n};\r\nif (!x86_match_cpu(cpu_ids))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int snd_byt_rt5640_mc_probe(struct platform_device *pdev)\r\n{\r\nint ret_val = 0;\r\nstruct sst_acpi_mach *mach;\r\nconst char *i2c_name = NULL;\r\nint i;\r\nint dai_index;\r\nstruct byt_rt5640_private *priv;\r\nis_bytcr = false;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_ATOMIC);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nbyt_rt5640_card.dev = &pdev->dev;\r\nmach = byt_rt5640_card.dev->platform_data;\r\nsnd_soc_card_set_drvdata(&byt_rt5640_card, priv);\r\ndai_index = MERR_DPCM_COMPR + 1;\r\nfor (i = 0; i < ARRAY_SIZE(byt_rt5640_dais); i++) {\r\nif (!strcmp(byt_rt5640_dais[i].codec_name, "i2c-10EC5640:00")) {\r\ndai_index = i;\r\nbreak;\r\n}\r\n}\r\ni2c_name = sst_acpi_find_name_from_hid(mach->id);\r\nif (i2c_name != NULL) {\r\nsnprintf(byt_rt5640_codec_name, sizeof(byt_rt5640_codec_name),\r\n"%s%s", "i2c-", i2c_name);\r\nbyt_rt5640_dais[dai_index].codec_name = byt_rt5640_codec_name;\r\n}\r\nif (is_valleyview()) {\r\nstruct sst_platform_info *p_info = mach->pdata;\r\nconst struct sst_res_info *res_info = p_info->res_info;\r\nif (res_info->acpi_ipc_irq_index == 0)\r\nis_bytcr = true;\r\n}\r\nif (is_bytcr) {\r\nstruct acpi_chan_package chan_package;\r\nstruct acpi_buffer format = {sizeof("NN"), "NN"};\r\nstruct acpi_buffer state = {0, NULL};\r\nstruct sst_acpi_package_context pkg_ctx;\r\nbool pkg_found = false;\r\nstate.length = sizeof(chan_package);\r\nstate.pointer = &chan_package;\r\npkg_ctx.name = "CHAN";\r\npkg_ctx.length = 2;\r\npkg_ctx.format = &format;\r\npkg_ctx.state = &state;\r\npkg_ctx.data_valid = false;\r\npkg_found = sst_acpi_find_package_from_hid(mach->id, &pkg_ctx);\r\nif (pkg_found) {\r\nif (chan_package.aif_value == 1) {\r\ndev_info(&pdev->dev, "BIOS Routing: AIF1 connected\n");\r\nbyt_rt5640_quirk |= BYT_RT5640_SSP0_AIF1;\r\n} else if (chan_package.aif_value == 2) {\r\ndev_info(&pdev->dev, "BIOS Routing: AIF2 connected\n");\r\nbyt_rt5640_quirk |= BYT_RT5640_SSP0_AIF2;\r\n} else {\r\ndev_info(&pdev->dev, "BIOS Routing isn't valid, ignored\n");\r\npkg_found = false;\r\n}\r\n}\r\nif (!pkg_found) {\r\nbyt_rt5640_quirk |= BYT_RT5640_SSP0_AIF2;\r\n}\r\nbyt_rt5640_quirk |= BYT_RT5640_IN1_MAP;\r\nbyt_rt5640_quirk |= BYT_RT5640_DIFF_MIC;\r\n} else {\r\nbyt_rt5640_quirk |= (BYT_RT5640_DMIC1_MAP |\r\nBYT_RT5640_DMIC_EN);\r\n}\r\ndmi_check_system(byt_rt5640_quirk_table);\r\nif (quirk_override) {\r\ndev_info(&pdev->dev, "Overriding quirk 0x%x => 0x%x\n",\r\n(unsigned int)byt_rt5640_quirk, quirk_override);\r\nbyt_rt5640_quirk = quirk_override;\r\n}\r\nlog_quirks(&pdev->dev);\r\nif ((byt_rt5640_quirk & BYT_RT5640_SSP2_AIF2) ||\r\n(byt_rt5640_quirk & BYT_RT5640_SSP0_AIF2)) {\r\nsnprintf(byt_rt5640_codec_aif_name,\r\nsizeof(byt_rt5640_codec_aif_name),\r\n"%s", "rt5640-aif2");\r\nbyt_rt5640_dais[dai_index].codec_dai_name =\r\nbyt_rt5640_codec_aif_name;\r\n}\r\nif ((byt_rt5640_quirk & BYT_RT5640_SSP0_AIF1) ||\r\n(byt_rt5640_quirk & BYT_RT5640_SSP0_AIF2)) {\r\nsnprintf(byt_rt5640_cpu_dai_name,\r\nsizeof(byt_rt5640_cpu_dai_name),\r\n"%s", "ssp0-port");\r\nbyt_rt5640_dais[dai_index].cpu_dai_name =\r\nbyt_rt5640_cpu_dai_name;\r\n}\r\nif ((byt_rt5640_quirk & BYT_RT5640_MCLK_EN) && (is_valleyview())) {\r\npriv->mclk = devm_clk_get(&pdev->dev, "pmc_plt_clk_3");\r\nif (IS_ERR(priv->mclk)) {\r\nret_val = PTR_ERR(priv->mclk);\r\ndev_err(&pdev->dev,\r\n"Failed to get MCLK from pmc_plt_clk_3: %d\n",\r\nret_val);\r\nif (ret_val != -ENOENT)\r\nreturn ret_val;\r\nbyt_rt5640_quirk &= ~BYT_RT5640_MCLK_EN;\r\n}\r\n}\r\nret_val = devm_snd_soc_register_card(&pdev->dev, &byt_rt5640_card);\r\nif (ret_val) {\r\ndev_err(&pdev->dev, "devm_snd_soc_register_card failed %d\n",\r\nret_val);\r\nreturn ret_val;\r\n}\r\nplatform_set_drvdata(pdev, &byt_rt5640_card);\r\nreturn ret_val;\r\n}
