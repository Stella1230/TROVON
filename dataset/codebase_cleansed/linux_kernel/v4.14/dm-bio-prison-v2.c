struct dm_bio_prison_v2 *dm_bio_prison_create_v2(struct workqueue_struct *wq)\r\n{\r\nstruct dm_bio_prison_v2 *prison = kmalloc(sizeof(*prison), GFP_KERNEL);\r\nif (!prison)\r\nreturn NULL;\r\nprison->wq = wq;\r\nspin_lock_init(&prison->lock);\r\nprison->cell_pool = mempool_create_slab_pool(MIN_CELLS, _cell_cache);\r\nif (!prison->cell_pool) {\r\nkfree(prison);\r\nreturn NULL;\r\n}\r\nprison->cells = RB_ROOT;\r\nreturn prison;\r\n}\r\nvoid dm_bio_prison_destroy_v2(struct dm_bio_prison_v2 *prison)\r\n{\r\nmempool_destroy(prison->cell_pool);\r\nkfree(prison);\r\n}\r\nstruct dm_bio_prison_cell_v2 *dm_bio_prison_alloc_cell_v2(struct dm_bio_prison_v2 *prison, gfp_t gfp)\r\n{\r\nreturn mempool_alloc(prison->cell_pool, gfp);\r\n}\r\nvoid dm_bio_prison_free_cell_v2(struct dm_bio_prison_v2 *prison,\r\nstruct dm_bio_prison_cell_v2 *cell)\r\n{\r\nmempool_free(cell, prison->cell_pool);\r\n}\r\nstatic void __setup_new_cell(struct dm_cell_key_v2 *key,\r\nstruct dm_bio_prison_cell_v2 *cell)\r\n{\r\nmemset(cell, 0, sizeof(*cell));\r\nmemcpy(&cell->key, key, sizeof(cell->key));\r\nbio_list_init(&cell->bios);\r\n}\r\nstatic int cmp_keys(struct dm_cell_key_v2 *lhs,\r\nstruct dm_cell_key_v2 *rhs)\r\n{\r\nif (lhs->virtual < rhs->virtual)\r\nreturn -1;\r\nif (lhs->virtual > rhs->virtual)\r\nreturn 1;\r\nif (lhs->dev < rhs->dev)\r\nreturn -1;\r\nif (lhs->dev > rhs->dev)\r\nreturn 1;\r\nif (lhs->block_end <= rhs->block_begin)\r\nreturn -1;\r\nif (lhs->block_begin >= rhs->block_end)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic bool __find_or_insert(struct dm_bio_prison_v2 *prison,\r\nstruct dm_cell_key_v2 *key,\r\nstruct dm_bio_prison_cell_v2 *cell_prealloc,\r\nstruct dm_bio_prison_cell_v2 **result)\r\n{\r\nint r;\r\nstruct rb_node **new = &prison->cells.rb_node, *parent = NULL;\r\nwhile (*new) {\r\nstruct dm_bio_prison_cell_v2 *cell =\r\nrb_entry(*new, struct dm_bio_prison_cell_v2, node);\r\nr = cmp_keys(key, &cell->key);\r\nparent = *new;\r\nif (r < 0)\r\nnew = &((*new)->rb_left);\r\nelse if (r > 0)\r\nnew = &((*new)->rb_right);\r\nelse {\r\n*result = cell;\r\nreturn true;\r\n}\r\n}\r\n__setup_new_cell(key, cell_prealloc);\r\n*result = cell_prealloc;\r\nrb_link_node(&cell_prealloc->node, parent, new);\r\nrb_insert_color(&cell_prealloc->node, &prison->cells);\r\nreturn false;\r\n}\r\nstatic bool __get(struct dm_bio_prison_v2 *prison,\r\nstruct dm_cell_key_v2 *key,\r\nunsigned lock_level,\r\nstruct bio *inmate,\r\nstruct dm_bio_prison_cell_v2 *cell_prealloc,\r\nstruct dm_bio_prison_cell_v2 **cell)\r\n{\r\nif (__find_or_insert(prison, key, cell_prealloc, cell)) {\r\nif ((*cell)->exclusive_lock) {\r\nif (lock_level <= (*cell)->exclusive_level) {\r\nbio_list_add(&(*cell)->bios, inmate);\r\nreturn false;\r\n}\r\n}\r\n(*cell)->shared_count++;\r\n} else\r\n(*cell)->shared_count = 1;\r\nreturn true;\r\n}\r\nbool dm_cell_get_v2(struct dm_bio_prison_v2 *prison,\r\nstruct dm_cell_key_v2 *key,\r\nunsigned lock_level,\r\nstruct bio *inmate,\r\nstruct dm_bio_prison_cell_v2 *cell_prealloc,\r\nstruct dm_bio_prison_cell_v2 **cell_result)\r\n{\r\nint r;\r\nunsigned long flags;\r\nspin_lock_irqsave(&prison->lock, flags);\r\nr = __get(prison, key, lock_level, inmate, cell_prealloc, cell_result);\r\nspin_unlock_irqrestore(&prison->lock, flags);\r\nreturn r;\r\n}\r\nstatic bool __put(struct dm_bio_prison_v2 *prison,\r\nstruct dm_bio_prison_cell_v2 *cell)\r\n{\r\nBUG_ON(!cell->shared_count);\r\ncell->shared_count--;\r\nif (!cell->shared_count) {\r\nif (cell->exclusive_lock){\r\nif (cell->quiesce_continuation) {\r\nqueue_work(prison->wq, cell->quiesce_continuation);\r\ncell->quiesce_continuation = NULL;\r\n}\r\n} else {\r\nrb_erase(&cell->node, &prison->cells);\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nbool dm_cell_put_v2(struct dm_bio_prison_v2 *prison,\r\nstruct dm_bio_prison_cell_v2 *cell)\r\n{\r\nbool r;\r\nunsigned long flags;\r\nspin_lock_irqsave(&prison->lock, flags);\r\nr = __put(prison, cell);\r\nspin_unlock_irqrestore(&prison->lock, flags);\r\nreturn r;\r\n}\r\nstatic int __lock(struct dm_bio_prison_v2 *prison,\r\nstruct dm_cell_key_v2 *key,\r\nunsigned lock_level,\r\nstruct dm_bio_prison_cell_v2 *cell_prealloc,\r\nstruct dm_bio_prison_cell_v2 **cell_result)\r\n{\r\nstruct dm_bio_prison_cell_v2 *cell;\r\nif (__find_or_insert(prison, key, cell_prealloc, &cell)) {\r\nif (cell->exclusive_lock)\r\nreturn -EBUSY;\r\ncell->exclusive_lock = true;\r\ncell->exclusive_level = lock_level;\r\n*cell_result = cell;\r\nreturn cell->shared_count > 0;\r\n} else {\r\ncell = cell_prealloc;\r\ncell->shared_count = 0;\r\ncell->exclusive_lock = true;\r\ncell->exclusive_level = lock_level;\r\n*cell_result = cell;\r\n}\r\nreturn 0;\r\n}\r\nint dm_cell_lock_v2(struct dm_bio_prison_v2 *prison,\r\nstruct dm_cell_key_v2 *key,\r\nunsigned lock_level,\r\nstruct dm_bio_prison_cell_v2 *cell_prealloc,\r\nstruct dm_bio_prison_cell_v2 **cell_result)\r\n{\r\nint r;\r\nunsigned long flags;\r\nspin_lock_irqsave(&prison->lock, flags);\r\nr = __lock(prison, key, lock_level, cell_prealloc, cell_result);\r\nspin_unlock_irqrestore(&prison->lock, flags);\r\nreturn r;\r\n}\r\nstatic void __quiesce(struct dm_bio_prison_v2 *prison,\r\nstruct dm_bio_prison_cell_v2 *cell,\r\nstruct work_struct *continuation)\r\n{\r\nif (!cell->shared_count)\r\nqueue_work(prison->wq, continuation);\r\nelse\r\ncell->quiesce_continuation = continuation;\r\n}\r\nvoid dm_cell_quiesce_v2(struct dm_bio_prison_v2 *prison,\r\nstruct dm_bio_prison_cell_v2 *cell,\r\nstruct work_struct *continuation)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&prison->lock, flags);\r\n__quiesce(prison, cell, continuation);\r\nspin_unlock_irqrestore(&prison->lock, flags);\r\n}\r\nstatic int __promote(struct dm_bio_prison_v2 *prison,\r\nstruct dm_bio_prison_cell_v2 *cell,\r\nunsigned new_lock_level)\r\n{\r\nif (!cell->exclusive_lock)\r\nreturn -EINVAL;\r\ncell->exclusive_level = new_lock_level;\r\nreturn cell->shared_count > 0;\r\n}\r\nint dm_cell_lock_promote_v2(struct dm_bio_prison_v2 *prison,\r\nstruct dm_bio_prison_cell_v2 *cell,\r\nunsigned new_lock_level)\r\n{\r\nint r;\r\nunsigned long flags;\r\nspin_lock_irqsave(&prison->lock, flags);\r\nr = __promote(prison, cell, new_lock_level);\r\nspin_unlock_irqrestore(&prison->lock, flags);\r\nreturn r;\r\n}\r\nstatic bool __unlock(struct dm_bio_prison_v2 *prison,\r\nstruct dm_bio_prison_cell_v2 *cell,\r\nstruct bio_list *bios)\r\n{\r\nBUG_ON(!cell->exclusive_lock);\r\nbio_list_merge(bios, &cell->bios);\r\nbio_list_init(&cell->bios);\r\nif (cell->shared_count) {\r\ncell->exclusive_lock = 0;\r\nreturn false;\r\n}\r\nrb_erase(&cell->node, &prison->cells);\r\nreturn true;\r\n}\r\nbool dm_cell_unlock_v2(struct dm_bio_prison_v2 *prison,\r\nstruct dm_bio_prison_cell_v2 *cell,\r\nstruct bio_list *bios)\r\n{\r\nbool r;\r\nunsigned long flags;\r\nspin_lock_irqsave(&prison->lock, flags);\r\nr = __unlock(prison, cell, bios);\r\nspin_unlock_irqrestore(&prison->lock, flags);\r\nreturn r;\r\n}\r\nint __init dm_bio_prison_init_v2(void)\r\n{\r\n_cell_cache = KMEM_CACHE(dm_bio_prison_cell_v2, 0);\r\nif (!_cell_cache)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid dm_bio_prison_exit_v2(void)\r\n{\r\nkmem_cache_destroy(_cell_cache);\r\n_cell_cache = NULL;\r\n}
