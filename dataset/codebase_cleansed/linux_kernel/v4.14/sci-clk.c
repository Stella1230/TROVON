static int sci_clk_prepare(struct clk_hw *hw)\r\n{\r\nstruct sci_clk *clk = to_sci_clk(hw);\r\nbool enable_ssc = clk->flags & SCI_CLK_SSC_ENABLE;\r\nbool allow_freq_change = clk->flags & SCI_CLK_ALLOW_FREQ_CHANGE;\r\nbool input_termination = clk->flags & SCI_CLK_INPUT_TERMINATION;\r\nreturn clk->provider->ops->get_clock(clk->provider->sci, clk->dev_id,\r\nclk->clk_id, enable_ssc,\r\nallow_freq_change,\r\ninput_termination);\r\n}\r\nstatic void sci_clk_unprepare(struct clk_hw *hw)\r\n{\r\nstruct sci_clk *clk = to_sci_clk(hw);\r\nint ret;\r\nret = clk->provider->ops->put_clock(clk->provider->sci, clk->dev_id,\r\nclk->clk_id);\r\nif (ret)\r\ndev_err(clk->provider->dev,\r\n"unprepare failed for dev=%d, clk=%d, ret=%d\n",\r\nclk->dev_id, clk->clk_id, ret);\r\n}\r\nstatic int sci_clk_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct sci_clk *clk = to_sci_clk(hw);\r\nbool req_state, current_state;\r\nint ret;\r\nret = clk->provider->ops->is_on(clk->provider->sci, clk->dev_id,\r\nclk->clk_id, &req_state,\r\n&current_state);\r\nif (ret) {\r\ndev_err(clk->provider->dev,\r\n"is_prepared failed for dev=%d, clk=%d, ret=%d\n",\r\nclk->dev_id, clk->clk_id, ret);\r\nreturn 0;\r\n}\r\nreturn req_state;\r\n}\r\nstatic unsigned long sci_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct sci_clk *clk = to_sci_clk(hw);\r\nu64 freq;\r\nint ret;\r\nret = clk->provider->ops->get_freq(clk->provider->sci, clk->dev_id,\r\nclk->clk_id, &freq);\r\nif (ret) {\r\ndev_err(clk->provider->dev,\r\n"recalc-rate failed for dev=%d, clk=%d, ret=%d\n",\r\nclk->dev_id, clk->clk_id, ret);\r\nreturn 0;\r\n}\r\nreturn freq;\r\n}\r\nstatic int sci_clk_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct sci_clk *clk = to_sci_clk(hw);\r\nint ret;\r\nu64 new_rate;\r\nret = clk->provider->ops->get_best_match_freq(clk->provider->sci,\r\nclk->dev_id,\r\nclk->clk_id,\r\nreq->min_rate,\r\nreq->rate,\r\nreq->max_rate,\r\n&new_rate);\r\nif (ret) {\r\ndev_err(clk->provider->dev,\r\n"determine-rate failed for dev=%d, clk=%d, ret=%d\n",\r\nclk->dev_id, clk->clk_id, ret);\r\nreturn ret;\r\n}\r\nreq->rate = new_rate;\r\nreturn 0;\r\n}\r\nstatic int sci_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct sci_clk *clk = to_sci_clk(hw);\r\nreturn clk->provider->ops->set_freq(clk->provider->sci, clk->dev_id,\r\nclk->clk_id, rate, rate, rate);\r\n}\r\nstatic u8 sci_clk_get_parent(struct clk_hw *hw)\r\n{\r\nstruct sci_clk *clk = to_sci_clk(hw);\r\nu8 parent_id;\r\nint ret;\r\nret = clk->provider->ops->get_parent(clk->provider->sci, clk->dev_id,\r\nclk->clk_id, &parent_id);\r\nif (ret) {\r\ndev_err(clk->provider->dev,\r\n"get-parent failed for dev=%d, clk=%d, ret=%d\n",\r\nclk->dev_id, clk->clk_id, ret);\r\nreturn 0;\r\n}\r\nreturn parent_id - clk->clk_id - 1;\r\n}\r\nstatic int sci_clk_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct sci_clk *clk = to_sci_clk(hw);\r\nreturn clk->provider->ops->set_parent(clk->provider->sci, clk->dev_id,\r\nclk->clk_id,\r\nindex + 1 + clk->clk_id);\r\n}\r\nstatic struct clk_hw *_sci_clk_build(struct sci_clk_provider *provider,\r\nu16 dev_id, u8 clk_id)\r\n{\r\nstruct clk_init_data init = { NULL };\r\nstruct sci_clk *sci_clk = NULL;\r\nchar *name = NULL;\r\nchar **parent_names = NULL;\r\nint i;\r\nint ret;\r\nsci_clk = devm_kzalloc(provider->dev, sizeof(*sci_clk), GFP_KERNEL);\r\nif (!sci_clk)\r\nreturn ERR_PTR(-ENOMEM);\r\nsci_clk->dev_id = dev_id;\r\nsci_clk->clk_id = clk_id;\r\nsci_clk->provider = provider;\r\nret = provider->ops->get_num_parents(provider->sci, dev_id,\r\nclk_id,\r\n&init.num_parents);\r\nif (ret)\r\ngoto err;\r\nname = kasprintf(GFP_KERNEL, "%s:%d:%d", dev_name(provider->dev),\r\nsci_clk->dev_id, sci_clk->clk_id);\r\ninit.name = name;\r\nif (init.num_parents < 2)\r\ninit.num_parents = 0;\r\nif (init.num_parents) {\r\nparent_names = kcalloc(init.num_parents, sizeof(char *),\r\nGFP_KERNEL);\r\nif (!parent_names) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nfor (i = 0; i < init.num_parents; i++) {\r\nchar *parent_name;\r\nparent_name = kasprintf(GFP_KERNEL, "%s:%d:%d",\r\ndev_name(provider->dev),\r\nsci_clk->dev_id,\r\nsci_clk->clk_id + 1 + i);\r\nif (!parent_name) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nparent_names[i] = parent_name;\r\n}\r\ninit.parent_names = (void *)parent_names;\r\n}\r\ninit.ops = &sci_clk_ops;\r\nsci_clk->hw.init = &init;\r\nret = devm_clk_hw_register(provider->dev, &sci_clk->hw);\r\nif (ret)\r\ndev_err(provider->dev, "failed clk register with %d\n", ret);\r\nerr:\r\nif (parent_names) {\r\nfor (i = 0; i < init.num_parents; i++)\r\nkfree(parent_names[i]);\r\nkfree(parent_names);\r\n}\r\nkfree(name);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn &sci_clk->hw;\r\n}\r\nstatic int _cmp_sci_clk(const void *a, const void *b)\r\n{\r\nconst struct sci_clk *ca = a;\r\nconst struct sci_clk *cb = *(struct sci_clk **)b;\r\nif (ca->dev_id == cb->dev_id && ca->clk_id == cb->clk_id)\r\nreturn 0;\r\nif (ca->dev_id > cb->dev_id ||\r\n(ca->dev_id == cb->dev_id && ca->clk_id > cb->clk_id))\r\nreturn 1;\r\nreturn -1;\r\n}\r\nstatic struct clk_hw *sci_clk_get(struct of_phandle_args *clkspec, void *data)\r\n{\r\nstruct sci_clk_provider *provider = data;\r\nstruct sci_clk **clk;\r\nstruct sci_clk key;\r\nif (clkspec->args_count != 2)\r\nreturn ERR_PTR(-EINVAL);\r\nkey.dev_id = clkspec->args[0];\r\nkey.clk_id = clkspec->args[1];\r\nclk = bsearch(&key, provider->clocks, provider->num_clocks,\r\nsizeof(clk), _cmp_sci_clk);\r\nif (!clk)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn &(*clk)->hw;\r\n}\r\nstatic int ti_sci_init_clocks(struct sci_clk_provider *p)\r\n{\r\nconst struct sci_clk_data *data = p->clk_data;\r\nstruct clk_hw *hw;\r\nint i;\r\nint num_clks = 0;\r\nwhile (data->num_clks) {\r\nnum_clks += data->num_clks;\r\ndata++;\r\n}\r\np->num_clocks = num_clks;\r\np->clocks = devm_kcalloc(p->dev, num_clks, sizeof(struct sci_clk),\r\nGFP_KERNEL);\r\nif (!p->clocks)\r\nreturn -ENOMEM;\r\nnum_clks = 0;\r\ndata = p->clk_data;\r\nwhile (data->num_clks) {\r\nfor (i = 0; i < data->num_clks; i++) {\r\nhw = _sci_clk_build(p, data->dev, i);\r\nif (!IS_ERR(hw)) {\r\np->clocks[num_clks++] = hw;\r\ncontinue;\r\n}\r\nif (PTR_ERR(hw) == -ENODEV)\r\ncontinue;\r\nreturn PTR_ERR(hw);\r\n}\r\ndata++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_sci_clk_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct sci_clk_provider *provider;\r\nconst struct ti_sci_handle *handle;\r\nconst struct sci_clk_data *data;\r\nint ret;\r\ndata = of_device_get_match_data(dev);\r\nif (!data)\r\nreturn -EINVAL;\r\nhandle = devm_ti_sci_get_handle(dev);\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\nprovider = devm_kzalloc(dev, sizeof(*provider), GFP_KERNEL);\r\nif (!provider)\r\nreturn -ENOMEM;\r\nprovider->clk_data = data;\r\nprovider->sci = handle;\r\nprovider->ops = &handle->ops.clk_ops;\r\nprovider->dev = dev;\r\nret = ti_sci_init_clocks(provider);\r\nif (ret) {\r\npr_err("ti-sci-init-clocks failed.\n");\r\nreturn ret;\r\n}\r\nreturn of_clk_add_hw_provider(np, sci_clk_get, provider);\r\n}\r\nstatic int ti_sci_clk_remove(struct platform_device *pdev)\r\n{\r\nof_clk_del_provider(pdev->dev.of_node);\r\nreturn 0;\r\n}
