u32 acpi_ps_get_opcode_size(u32 opcode)\r\n{\r\nif (opcode > 0x00FF) {\r\nreturn (2);\r\n}\r\nreturn (1);\r\n}\r\nu16 acpi_ps_peek_opcode(struct acpi_parse_state * parser_state)\r\n{\r\nu8 *aml;\r\nu16 opcode;\r\naml = parser_state->aml;\r\nopcode = (u16) ACPI_GET8(aml);\r\nif (opcode == AML_EXTENDED_PREFIX) {\r\naml++;\r\nopcode = (u16) ((opcode << 8) | ACPI_GET8(aml));\r\n}\r\nreturn (opcode);\r\n}\r\nacpi_status\r\nacpi_ps_complete_this_op(struct acpi_walk_state *walk_state,\r\nunion acpi_parse_object *op)\r\n{\r\nunion acpi_parse_object *prev;\r\nunion acpi_parse_object *next;\r\nconst struct acpi_opcode_info *parent_info;\r\nunion acpi_parse_object *replacement_op = NULL;\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE_PTR(ps_complete_this_op, op);\r\nif (!op) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_ex_stop_trace_opcode(op, walk_state);\r\nif (((walk_state->parse_flags & ACPI_PARSE_TREE_MASK) !=\r\nACPI_PARSE_DELETE_TREE)\r\n|| (walk_state->op_info->class == AML_CLASS_ARGUMENT)) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nif (op->common.parent) {\r\nprev = op->common.parent->common.value.arg;\r\nif (!prev) {\r\ngoto cleanup;\r\n}\r\nparent_info =\r\nacpi_ps_get_opcode_info(op->common.parent->common.\r\naml_opcode);\r\nswitch (parent_info->class) {\r\ncase AML_CLASS_CONTROL:\r\nbreak;\r\ncase AML_CLASS_CREATE:\r\nreplacement_op =\r\nacpi_ps_alloc_op(AML_INT_RETURN_VALUE_OP,\r\nop->common.aml);\r\nif (!replacement_op) {\r\nstatus = AE_NO_MEMORY;\r\n}\r\nbreak;\r\ncase AML_CLASS_NAMED_OBJECT:\r\nif ((op->common.parent->common.aml_opcode ==\r\nAML_REGION_OP)\r\n|| (op->common.parent->common.aml_opcode ==\r\nAML_DATA_REGION_OP)\r\n|| (op->common.parent->common.aml_opcode ==\r\nAML_BUFFER_OP)\r\n|| (op->common.parent->common.aml_opcode ==\r\nAML_PACKAGE_OP)\r\n|| (op->common.parent->common.aml_opcode ==\r\nAML_BANK_FIELD_OP)\r\n|| (op->common.parent->common.aml_opcode ==\r\nAML_VARIABLE_PACKAGE_OP)) {\r\nreplacement_op =\r\nacpi_ps_alloc_op(AML_INT_RETURN_VALUE_OP,\r\nop->common.aml);\r\nif (!replacement_op) {\r\nstatus = AE_NO_MEMORY;\r\n}\r\n} else\r\nif ((op->common.parent->common.aml_opcode ==\r\nAML_NAME_OP)\r\n&& (walk_state->pass_number <=\r\nACPI_IMODE_LOAD_PASS2)) {\r\nif ((op->common.aml_opcode == AML_BUFFER_OP)\r\n|| (op->common.aml_opcode == AML_PACKAGE_OP)\r\n|| (op->common.aml_opcode ==\r\nAML_VARIABLE_PACKAGE_OP)) {\r\nreplacement_op =\r\nacpi_ps_alloc_op(op->common.\r\naml_opcode,\r\nop->common.aml);\r\nif (!replacement_op) {\r\nstatus = AE_NO_MEMORY;\r\n} else {\r\nreplacement_op->named.data =\r\nop->named.data;\r\nreplacement_op->named.length =\r\nop->named.length;\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nreplacement_op =\r\nacpi_ps_alloc_op(AML_INT_RETURN_VALUE_OP,\r\nop->common.aml);\r\nif (!replacement_op) {\r\nstatus = AE_NO_MEMORY;\r\n}\r\n}\r\nif (prev == op) {\r\nif (replacement_op) {\r\nreplacement_op->common.parent =\r\nop->common.parent;\r\nreplacement_op->common.value.arg = NULL;\r\nreplacement_op->common.node = op->common.node;\r\nop->common.parent->common.value.arg =\r\nreplacement_op;\r\nreplacement_op->common.next = op->common.next;\r\n} else {\r\nop->common.parent->common.value.arg =\r\nop->common.next;\r\n}\r\n}\r\nelse\r\nwhile (prev) {\r\nnext = prev->common.next;\r\nif (next == op) {\r\nif (replacement_op) {\r\nreplacement_op->common.parent =\r\nop->common.parent;\r\nreplacement_op->common.value.\r\narg = NULL;\r\nreplacement_op->common.node =\r\nop->common.node;\r\nprev->common.next =\r\nreplacement_op;\r\nreplacement_op->common.next =\r\nop->common.next;\r\nnext = NULL;\r\n} else {\r\nprev->common.next =\r\nop->common.next;\r\nnext = NULL;\r\n}\r\n}\r\nprev = next;\r\n}\r\n}\r\ncleanup:\r\nacpi_ps_delete_parse_tree(op);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ps_next_parse_state(struct acpi_walk_state *walk_state,\r\nunion acpi_parse_object *op,\r\nacpi_status callback_status)\r\n{\r\nstruct acpi_parse_state *parser_state = &walk_state->parser_state;\r\nacpi_status status = AE_CTRL_PENDING;\r\nACPI_FUNCTION_TRACE_PTR(ps_next_parse_state, op);\r\nswitch (callback_status) {\r\ncase AE_CTRL_TERMINATE:\r\nparser_state->aml = parser_state->aml_end;\r\nstatus = AE_CTRL_TERMINATE;\r\nbreak;\r\ncase AE_CTRL_BREAK:\r\nparser_state->aml = walk_state->aml_last_while;\r\nwalk_state->control_state->common.value = FALSE;\r\nstatus = AE_CTRL_BREAK;\r\nbreak;\r\ncase AE_CTRL_CONTINUE:\r\nparser_state->aml = walk_state->aml_last_while;\r\nstatus = AE_CTRL_CONTINUE;\r\nbreak;\r\ncase AE_CTRL_PENDING:\r\nparser_state->aml = walk_state->aml_last_while;\r\nbreak;\r\n#if 0\r\ncase AE_CTRL_SKIP:\r\nparser_state->aml = parser_state->scope->parse_scope.pkg_end;\r\nstatus = AE_OK;\r\nbreak;\r\n#endif\r\ncase AE_CTRL_TRUE:\r\nparser_state->aml = acpi_ps_get_next_package_end(parser_state);\r\nstatus = AE_CTRL_PENDING;\r\nbreak;\r\ncase AE_CTRL_FALSE:\r\nparser_state->aml = parser_state->scope->parse_scope.pkg_end;\r\nwalk_state->control_state->common.value = FALSE;\r\nstatus = AE_CTRL_END;\r\nbreak;\r\ncase AE_CTRL_TRANSFER:\r\nstatus = AE_CTRL_TRANSFER;\r\nwalk_state->prev_op = op;\r\nwalk_state->method_call_op = op;\r\nwalk_state->method_call_node =\r\n(op->common.value.arg)->common.node;\r\nwalk_state->return_used =\r\nacpi_ds_is_result_used(op, walk_state);\r\nbreak;\r\ndefault:\r\nstatus = callback_status;\r\nif ((callback_status & AE_CODE_MASK) == AE_CODE_CONTROL) {\r\nstatus = AE_OK;\r\n}\r\nbreak;\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_ps_parse_aml(struct acpi_walk_state *walk_state)\r\n{\r\nacpi_status status;\r\nstruct acpi_thread_state *thread;\r\nstruct acpi_thread_state *prev_walk_list = acpi_gbl_current_walk_list;\r\nstruct acpi_walk_state *previous_walk_state;\r\nACPI_FUNCTION_TRACE(ps_parse_aml);\r\nACPI_DEBUG_PRINT((ACPI_DB_PARSE,\r\n"Entered with WalkState=%p Aml=%p size=%X\n",\r\nwalk_state, walk_state->parser_state.aml,\r\nwalk_state->parser_state.aml_size));\r\nif (!walk_state->parser_state.aml) {\r\nreturn_ACPI_STATUS(AE_NULL_OBJECT);\r\n}\r\nthread = acpi_ut_create_thread_state();\r\nif (!thread) {\r\nif (walk_state->method_desc) {\r\nacpi_ds_terminate_control_method(walk_state->\r\nmethod_desc,\r\nwalk_state);\r\n}\r\nacpi_ds_delete_walk_state(walk_state);\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nwalk_state->thread = thread;\r\nif (walk_state->method_desc) {\r\nwalk_state->thread->current_sync_level =\r\nwalk_state->method_desc->method.sync_level;\r\n}\r\nacpi_ds_push_walk_state(walk_state, thread);\r\nacpi_gbl_current_walk_list = thread;\r\nACPI_DEBUG_PRINT((ACPI_DB_PARSE, "State=%p\n", walk_state));\r\nstatus = AE_OK;\r\nwhile (walk_state) {\r\nif (ACPI_SUCCESS(status)) {\r\nstatus = acpi_ps_parse_loop(walk_state);\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_PARSE,\r\n"Completed one call to walk loop, %s State=%p\n",\r\nacpi_format_exception(status), walk_state));\r\nif (status == AE_CTRL_TRANSFER) {\r\nstatus =\r\nacpi_ds_call_control_method(thread, walk_state,\r\nNULL);\r\nif (ACPI_FAILURE(status)) {\r\nstatus =\r\nacpi_ds_method_error(status, walk_state);\r\n}\r\nwalk_state = acpi_ds_get_current_walk_state(thread);\r\ncontinue;\r\n} else if (status == AE_CTRL_TERMINATE) {\r\nstatus = AE_OK;\r\n} else if ((status != AE_OK) && (walk_state->method_desc)) {\r\nacpi_ex_exit_interpreter();\r\nif (status == AE_ABORT_METHOD) {\r\nacpi_ns_print_node_pathname(walk_state->\r\nmethod_node,\r\n"Method aborted:");\r\nacpi_os_printf("\n");\r\n} else {\r\nACPI_ERROR_METHOD\r\n("Method parse/execution failed",\r\nwalk_state->method_node, NULL, status);\r\n}\r\nacpi_ex_enter_interpreter();\r\nif ((status == AE_ALREADY_EXISTS) &&\r\n(!(walk_state->method_desc->method.info_flags &\r\nACPI_METHOD_SERIALIZED))) {\r\nwalk_state->method_desc->method.info_flags |=\r\nACPI_METHOD_SERIALIZED_PENDING;\r\n}\r\n}\r\nwalk_state = acpi_ds_pop_walk_state(thread);\r\nacpi_ds_scope_stack_clear(walk_state);\r\nif (((walk_state->parse_flags & ACPI_PARSE_MODE_MASK) ==\r\nACPI_PARSE_EXECUTE &&\r\n!(walk_state->parse_flags & ACPI_PARSE_MODULE_LEVEL)) ||\r\n(ACPI_FAILURE(status))) {\r\nacpi_ds_terminate_control_method(walk_state->\r\nmethod_desc,\r\nwalk_state);\r\n}\r\nacpi_ps_cleanup_scope(&walk_state->parser_state);\r\nprevious_walk_state = walk_state;\r\nACPI_DEBUG_PRINT((ACPI_DB_PARSE,\r\n"ReturnValue=%p, ImplicitValue=%p State=%p\n",\r\nwalk_state->return_desc,\r\nwalk_state->implicit_return_obj, walk_state));\r\nwalk_state = acpi_ds_get_current_walk_state(thread);\r\nif (walk_state) {\r\nif (ACPI_SUCCESS(status)) {\r\nif (!previous_walk_state->return_desc) {\r\nif (acpi_gbl_enable_interpreter_slack &&\r\n!previous_walk_state->\r\nimplicit_return_obj) {\r\nprevious_walk_state->\r\nimplicit_return_obj =\r\nacpi_ut_create_integer_object\r\n((u64) 0);\r\nif (!previous_walk_state->\r\nimplicit_return_obj) {\r\nreturn_ACPI_STATUS\r\n(AE_NO_MEMORY);\r\n}\r\n}\r\nstatus =\r\nacpi_ds_restart_control_method\r\n(walk_state,\r\nprevious_walk_state->\r\nimplicit_return_obj);\r\n} else {\r\nacpi_ds_clear_implicit_return\r\n(previous_walk_state);\r\nstatus =\r\nacpi_ds_restart_control_method\r\n(walk_state,\r\nprevious_walk_state->return_desc);\r\n}\r\nif (ACPI_SUCCESS(status)) {\r\nwalk_state->walk_type |=\r\nACPI_WALK_METHOD_RESTART;\r\n}\r\n} else {\r\nacpi_ut_remove_reference(previous_walk_state->\r\nreturn_desc);\r\nacpi_ds_clear_implicit_return\r\n(previous_walk_state);\r\n}\r\n}\r\nelse if (previous_walk_state->caller_return_desc) {\r\nif (previous_walk_state->implicit_return_obj) {\r\n*(previous_walk_state->caller_return_desc) =\r\nprevious_walk_state->implicit_return_obj;\r\n} else {\r\n*(previous_walk_state->caller_return_desc) =\r\nprevious_walk_state->return_desc;\r\n}\r\n} else {\r\nif (previous_walk_state->return_desc) {\r\nacpi_ut_remove_reference(previous_walk_state->\r\nreturn_desc);\r\n}\r\nif (previous_walk_state->implicit_return_obj) {\r\nacpi_ut_remove_reference(previous_walk_state->\r\nimplicit_return_obj);\r\n}\r\n}\r\nacpi_ds_delete_walk_state(previous_walk_state);\r\n}\r\nacpi_ex_release_all_mutexes(thread);\r\nacpi_ut_delete_generic_state(ACPI_CAST_PTR\r\n(union acpi_generic_state, thread));\r\nacpi_gbl_current_walk_list = prev_walk_list;\r\nreturn_ACPI_STATUS(status);\r\n}
