static inline void\r\ncommand(struct goku_udc_regs __iomem *regs, int command, unsigned epnum)\r\n{\r\nwritel(COMMAND_EP(epnum) | command, &regs->Command);\r\nudelay(300);\r\n}\r\nstatic int\r\ngoku_ep_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct goku_udc *dev;\r\nstruct goku_ep *ep;\r\nu32 mode;\r\nu16 max;\r\nunsigned long flags;\r\nep = container_of(_ep, struct goku_ep, ep);\r\nif (!_ep || !desc\r\n|| desc->bDescriptorType != USB_DT_ENDPOINT)\r\nreturn -EINVAL;\r\ndev = ep->dev;\r\nif (ep == &dev->ep[0])\r\nreturn -EINVAL;\r\nif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nif (ep->num != usb_endpoint_num(desc))\r\nreturn -EINVAL;\r\nswitch (usb_endpoint_type(desc)) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\ncase USB_ENDPOINT_XFER_INT:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((readl(ep->reg_status) & EPxSTATUS_EP_MASK)\r\n!= EPxSTATUS_EP_INVALID)\r\nreturn -EBUSY;\r\nmode = 0;\r\nmax = get_unaligned_le16(&desc->wMaxPacketSize);\r\nswitch (max) {\r\ncase 64: mode++;\r\ncase 32: mode++;\r\ncase 16: mode++;\r\ncase 8: mode <<= 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmode |= 2 << 1;\r\nep->is_in = usb_endpoint_dir_in(desc);\r\nif (ep->is_in) {\r\nmode |= 1;\r\nep->dma = (use_dma != 0) && (ep->num == UDC_MSTRD_ENDPOINT);\r\n} else {\r\nep->dma = (use_dma == 2) && (ep->num == UDC_MSTWR_ENDPOINT);\r\nif (ep->dma)\r\nDBG(dev, "%s out-dma hides short packets\n",\r\nep->ep.name);\r\n}\r\nspin_lock_irqsave(&ep->dev->lock, flags);\r\nif (ep->num < 3) {\r\nstruct goku_udc_regs __iomem *regs = ep->dev->regs;\r\nu32 tmp;\r\ntmp = ((ep->dma || !ep->is_in)\r\n? 0x10\r\n: 0x11\r\n) << ep->num;\r\ntmp |= readl(&regs->EPxSingle);\r\nwritel(tmp, &regs->EPxSingle);\r\ntmp = (ep->dma ? 0x10 : 0x11) << ep->num;\r\ntmp |= readl(&regs->EPxBCS);\r\nwritel(tmp, &regs->EPxBCS);\r\n}\r\nwritel(mode, ep->reg_mode);\r\ncommand(ep->dev->regs, COMMAND_RESET, ep->num);\r\nep->ep.maxpacket = max;\r\nep->stopped = 0;\r\nep->ep.desc = desc;\r\nspin_unlock_irqrestore(&ep->dev->lock, flags);\r\nDBG(dev, "enable %s %s %s maxpacket %u\n", ep->ep.name,\r\nep->is_in ? "IN" : "OUT",\r\nep->dma ? "dma" : "pio",\r\nmax);\r\nreturn 0;\r\n}\r\nstatic void ep_reset(struct goku_udc_regs __iomem *regs, struct goku_ep *ep)\r\n{\r\nstruct goku_udc *dev = ep->dev;\r\nif (regs) {\r\ncommand(regs, COMMAND_INVALID, ep->num);\r\nif (ep->num) {\r\nif (ep->num == UDC_MSTWR_ENDPOINT)\r\ndev->int_enable &= ~(INT_MSTWREND\r\n|INT_MSTWRTMOUT);\r\nelse if (ep->num == UDC_MSTRD_ENDPOINT)\r\ndev->int_enable &= ~INT_MSTRDEND;\r\ndev->int_enable &= ~INT_EPxDATASET (ep->num);\r\n} else\r\ndev->int_enable &= ~INT_EP0;\r\nwritel(dev->int_enable, &regs->int_enable);\r\nreadl(&regs->int_enable);\r\nif (ep->num < 3) {\r\nstruct goku_udc_regs __iomem *r = ep->dev->regs;\r\nu32 tmp;\r\ntmp = readl(&r->EPxSingle);\r\ntmp &= ~(0x11 << ep->num);\r\nwritel(tmp, &r->EPxSingle);\r\ntmp = readl(&r->EPxBCS);\r\ntmp &= ~(0x11 << ep->num);\r\nwritel(tmp, &r->EPxBCS);\r\n}\r\nif (ep->dma) {\r\nu32 master;\r\nmaster = readl(&regs->dma_master) & MST_RW_BITS;\r\nif (ep->num == UDC_MSTWR_ENDPOINT) {\r\nmaster &= ~MST_W_BITS;\r\nmaster |= MST_WR_RESET;\r\n} else {\r\nmaster &= ~MST_R_BITS;\r\nmaster |= MST_RD_RESET;\r\n}\r\nwritel(master, &regs->dma_master);\r\n}\r\n}\r\nusb_ep_set_maxpacket_limit(&ep->ep, MAX_FIFO_SIZE);\r\nep->ep.desc = NULL;\r\nep->stopped = 1;\r\nep->irqs = 0;\r\nep->dma = 0;\r\n}\r\nstatic int goku_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct goku_ep *ep;\r\nstruct goku_udc *dev;\r\nunsigned long flags;\r\nep = container_of(_ep, struct goku_ep, ep);\r\nif (!_ep || !ep->ep.desc)\r\nreturn -ENODEV;\r\ndev = ep->dev;\r\nif (dev->ep0state == EP0_SUSPEND)\r\nreturn -EBUSY;\r\nVDBG(dev, "disable %s\n", _ep->name);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nnuke(ep, -ESHUTDOWN);\r\nep_reset(dev->regs, ep);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *\r\ngoku_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\r\n{\r\nstruct goku_request *req;\r\nif (!_ep)\r\nreturn NULL;\r\nreq = kzalloc(sizeof *req, gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void\r\ngoku_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct goku_request *req;\r\nif (!_ep || !_req)\r\nreturn;\r\nreq = container_of(_req, struct goku_request, req);\r\nWARN_ON(!list_empty(&req->queue));\r\nkfree(req);\r\n}\r\nstatic void\r\ndone(struct goku_ep *ep, struct goku_request *req, int status)\r\n{\r\nstruct goku_udc *dev;\r\nunsigned stopped = ep->stopped;\r\nlist_del_init(&req->queue);\r\nif (likely(req->req.status == -EINPROGRESS))\r\nreq->req.status = status;\r\nelse\r\nstatus = req->req.status;\r\ndev = ep->dev;\r\nif (ep->dma)\r\nusb_gadget_unmap_request(&dev->gadget, &req->req, ep->is_in);\r\n#ifndef USB_TRACE\r\nif (status && status != -ESHUTDOWN)\r\n#endif\r\nVDBG(dev, "complete %s req %p stat %d len %u/%u\n",\r\nep->ep.name, &req->req, status,\r\nreq->req.actual, req->req.length);\r\nep->stopped = 1;\r\nspin_unlock(&dev->lock);\r\nusb_gadget_giveback_request(&ep->ep, &req->req);\r\nspin_lock(&dev->lock);\r\nep->stopped = stopped;\r\n}\r\nstatic inline int\r\nwrite_packet(u32 __iomem *fifo, u8 *buf, struct goku_request *req, unsigned max)\r\n{\r\nunsigned length, count;\r\nlength = min(req->req.length - req->req.actual, max);\r\nreq->req.actual += length;\r\ncount = length;\r\nwhile (likely(count--))\r\nwritel(*buf++, fifo);\r\nreturn length;\r\n}\r\nstatic int write_fifo(struct goku_ep *ep, struct goku_request *req)\r\n{\r\nstruct goku_udc *dev = ep->dev;\r\nu32 tmp;\r\nu8 *buf;\r\nunsigned count;\r\nint is_last;\r\ntmp = readl(&dev->regs->DataSet);\r\nbuf = req->req.buf + req->req.actual;\r\nprefetch(buf);\r\ndev = ep->dev;\r\nif (unlikely(ep->num == 0 && dev->ep0state != EP0_IN))\r\nreturn -EL2HLT;\r\nif (unlikely((tmp & DATASET_A(ep->num)) != 0))\r\nreturn 0;\r\nif (ep->num != 0)\r\nwritel(~INT_EPxDATASET(ep->num), &dev->regs->int_status);\r\ncount = write_packet(ep->reg_fifo, buf, req, ep->ep.maxpacket);\r\nif (unlikely(count != ep->ep.maxpacket)) {\r\nwritel(~(1<<ep->num), &dev->regs->EOP);\r\nif (ep->num == 0) {\r\ndev->ep[0].stopped = 1;\r\ndev->ep0state = EP0_STATUS;\r\n}\r\nis_last = 1;\r\n} else {\r\nif (likely(req->req.length != req->req.actual)\r\n|| req->req.zero)\r\nis_last = 0;\r\nelse\r\nis_last = 1;\r\n}\r\n#if 0\r\nVDBG(dev, "wrote %s %u bytes%s IN %u left %p\n",\r\nep->ep.name, count, is_last ? "/last" : "",\r\nreq->req.length - req->req.actual, req);\r\n#endif\r\nif (is_last) {\r\ndone(ep, req, 0);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_fifo(struct goku_ep *ep, struct goku_request *req)\r\n{\r\nstruct goku_udc_regs __iomem *regs;\r\nu32 size, set;\r\nu8 *buf;\r\nunsigned bufferspace, is_short, dbuff;\r\nregs = ep->dev->regs;\r\ntop:\r\nbuf = req->req.buf + req->req.actual;\r\nprefetchw(buf);\r\nif (unlikely(ep->num == 0 && ep->dev->ep0state != EP0_OUT))\r\nreturn -EL2HLT;\r\ndbuff = (ep->num == 1 || ep->num == 2);\r\ndo {\r\nif (ep->num != 0)\r\nwritel(~INT_EPxDATASET(ep->num), &regs->int_status);\r\nset = readl(&regs->DataSet) & DATASET_AB(ep->num);\r\nsize = readl(&regs->EPxSizeLA[ep->num]);\r\nbufferspace = req->req.length - req->req.actual;\r\nif (likely(ep->num != 0 || bufferspace != 0)) {\r\nif (unlikely(set == 0))\r\nbreak;\r\nif (!(size & PACKET_ACTIVE))\r\nsize = readl(&regs->EPxSizeLB[ep->num]);\r\nif (!(size & PACKET_ACTIVE))\r\nbreak;\r\nsize &= DATASIZE;\r\n} else\r\nsize = 0;\r\nreq->req.actual += size;\r\nis_short = (size < ep->ep.maxpacket);\r\n#ifdef USB_TRACE\r\nVDBG(ep->dev, "read %s %u bytes%s OUT req %p %u/%u\n",\r\nep->ep.name, size, is_short ? "/S" : "",\r\nreq, req->req.actual, req->req.length);\r\n#endif\r\nwhile (likely(size-- != 0)) {\r\nu8 byte = (u8) readl(ep->reg_fifo);\r\nif (unlikely(bufferspace == 0)) {\r\nif (req->req.status != -EOVERFLOW)\r\nDBG(ep->dev, "%s overflow %u\n",\r\nep->ep.name, size);\r\nreq->req.status = -EOVERFLOW;\r\n} else {\r\n*buf++ = byte;\r\nbufferspace--;\r\n}\r\n}\r\nif (unlikely(is_short || req->req.actual == req->req.length)) {\r\nif (unlikely(ep->num == 0)) {\r\nif (ep->dev->req_config)\r\nwritel(ep->dev->configured\r\n? USBSTATE_CONFIGURED\r\n: 0,\r\n&regs->UsbState);\r\nwritel(~(1<<0), &regs->EOP);\r\nep->stopped = 1;\r\nep->dev->ep0state = EP0_STATUS;\r\n}\r\ndone(ep, req, 0);\r\nif (dbuff && !list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct goku_request, queue);\r\ngoto top;\r\n}\r\nreturn 1;\r\n}\r\n} while (dbuff);\r\nreturn 0;\r\n}\r\nstatic inline void\r\npio_irq_enable(struct goku_udc *dev,\r\nstruct goku_udc_regs __iomem *regs, int epnum)\r\n{\r\ndev->int_enable |= INT_EPxDATASET (epnum);\r\nwritel(dev->int_enable, &regs->int_enable);\r\n}\r\nstatic inline void\r\npio_irq_disable(struct goku_udc *dev,\r\nstruct goku_udc_regs __iomem *regs, int epnum)\r\n{\r\ndev->int_enable &= ~INT_EPxDATASET (epnum);\r\nwritel(dev->int_enable, &regs->int_enable);\r\n}\r\nstatic inline void\r\npio_advance(struct goku_ep *ep)\r\n{\r\nstruct goku_request *req;\r\nif (unlikely(list_empty (&ep->queue)))\r\nreturn;\r\nreq = list_entry(ep->queue.next, struct goku_request, queue);\r\n(ep->is_in ? write_fifo : read_fifo)(ep, req);\r\n}\r\nstatic int start_dma(struct goku_ep *ep, struct goku_request *req)\r\n{\r\nstruct goku_udc_regs __iomem *regs = ep->dev->regs;\r\nu32 master;\r\nu32 start = req->req.dma;\r\nu32 end = start + req->req.length - 1;\r\nmaster = readl(&regs->dma_master) & MST_RW_BITS;\r\nif (likely(ep->is_in)) {\r\nif (unlikely(master & MST_RD_ENA)) {\r\nDBG (ep->dev, "start, IN active dma %03x!!\n",\r\nmaster);\r\n}\r\nwritel(end, &regs->in_dma_end);\r\nwritel(start, &regs->in_dma_start);\r\nmaster &= ~MST_R_BITS;\r\nif (unlikely(req->req.length == 0))\r\nmaster = MST_RD_ENA | MST_RD_EOPB;\r\nelse if ((req->req.length % ep->ep.maxpacket) != 0\r\n|| req->req.zero)\r\nmaster = MST_RD_ENA | MST_EOPB_ENA;\r\nelse\r\nmaster = MST_RD_ENA | MST_EOPB_DIS;\r\nep->dev->int_enable |= INT_MSTRDEND;\r\n} else {\r\nif (unlikely(master & MST_WR_ENA)) {\r\nDBG (ep->dev, "start, OUT active dma %03x!!\n",\r\nmaster);\r\n}\r\nwritel(end, &regs->out_dma_end);\r\nwritel(start, &regs->out_dma_start);\r\nmaster &= ~MST_W_BITS;\r\nmaster |= MST_WR_ENA | MST_TIMEOUT_DIS;\r\nep->dev->int_enable |= INT_MSTWREND|INT_MSTWRTMOUT;\r\n}\r\nwritel(master, &regs->dma_master);\r\nwritel(ep->dev->int_enable, &regs->int_enable);\r\nreturn 0;\r\n}\r\nstatic void dma_advance(struct goku_udc *dev, struct goku_ep *ep)\r\n{\r\nstruct goku_request *req;\r\nstruct goku_udc_regs __iomem *regs = ep->dev->regs;\r\nu32 master;\r\nmaster = readl(&regs->dma_master);\r\nif (unlikely(list_empty(&ep->queue))) {\r\nstop:\r\nif (ep->is_in)\r\ndev->int_enable &= ~INT_MSTRDEND;\r\nelse\r\ndev->int_enable &= ~(INT_MSTWREND|INT_MSTWRTMOUT);\r\nwritel(dev->int_enable, &regs->int_enable);\r\nreturn;\r\n}\r\nreq = list_entry(ep->queue.next, struct goku_request, queue);\r\nif (likely(ep->is_in)) {\r\nif (unlikely(master & MST_RD_ENA))\r\nreturn;\r\nreq->req.actual = readl(&regs->in_dma_current);\r\n} else {\r\nif (unlikely(master & MST_WR_ENA))\r\nreturn;\r\nreq->req.actual = readl(&regs->out_dma_current);\r\n}\r\nreq->req.actual -= req->req.dma;\r\nreq->req.actual++;\r\n#ifdef USB_TRACE\r\nVDBG(dev, "done %s %s dma, %u/%u bytes, req %p\n",\r\nep->ep.name, ep->is_in ? "IN" : "OUT",\r\nreq->req.actual, req->req.length, req);\r\n#endif\r\ndone(ep, req, 0);\r\nif (list_empty(&ep->queue))\r\ngoto stop;\r\nreq = list_entry(ep->queue.next, struct goku_request, queue);\r\n(void) start_dma(ep, req);\r\n}\r\nstatic void abort_dma(struct goku_ep *ep, int status)\r\n{\r\nstruct goku_udc_regs __iomem *regs = ep->dev->regs;\r\nstruct goku_request *req;\r\nu32 curr, master;\r\ncommand(regs, COMMAND_FIFO_DISABLE, ep->num);\r\nreq = list_entry(ep->queue.next, struct goku_request, queue);\r\nmaster = readl(&regs->dma_master) & MST_RW_BITS;\r\nif (ep->is_in) {\r\nif (unlikely((readl(&regs->dma_master) & MST_RD_ENA) == 0))\r\ngoto finished;\r\ncurr = readl(&regs->in_dma_current);\r\nwritel(curr, &regs->in_dma_end);\r\nwritel(curr, &regs->in_dma_start);\r\nmaster &= ~MST_R_BITS;\r\nmaster |= MST_RD_RESET;\r\nwritel(master, &regs->dma_master);\r\nif (readl(&regs->dma_master) & MST_RD_ENA)\r\nDBG(ep->dev, "IN dma active after reset!\n");\r\n} else {\r\nif (unlikely((readl(&regs->dma_master) & MST_WR_ENA) == 0))\r\ngoto finished;\r\ncurr = readl(&regs->out_dma_current);\r\nwritel(curr, &regs->out_dma_end);\r\nwritel(curr, &regs->out_dma_start);\r\nmaster &= ~MST_W_BITS;\r\nmaster |= MST_WR_RESET;\r\nwritel(master, &regs->dma_master);\r\nif (readl(&regs->dma_master) & MST_WR_ENA)\r\nDBG(ep->dev, "OUT dma active after reset!\n");\r\n}\r\nreq->req.actual = (curr - req->req.dma) + 1;\r\nreq->req.status = status;\r\nVDBG(ep->dev, "%s %s %s %d/%d\n", __func__, ep->ep.name,\r\nep->is_in ? "IN" : "OUT",\r\nreq->req.actual, req->req.length);\r\ncommand(regs, COMMAND_FIFO_ENABLE, ep->num);\r\nreturn;\r\nfinished:\r\ncommand(regs, COMMAND_FIFO_ENABLE, ep->num);\r\nreq->req.actual = req->req.length;\r\nreq->req.status = 0;\r\n}\r\nstatic int\r\ngoku_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\r\n{\r\nstruct goku_request *req;\r\nstruct goku_ep *ep;\r\nstruct goku_udc *dev;\r\nunsigned long flags;\r\nint status;\r\nreq = container_of(_req, struct goku_request, req);\r\nif (unlikely(!_req || !_req->complete\r\n|| !_req->buf || !list_empty(&req->queue)))\r\nreturn -EINVAL;\r\nep = container_of(_ep, struct goku_ep, ep);\r\nif (unlikely(!_ep || (!ep->ep.desc && ep->num != 0)))\r\nreturn -EINVAL;\r\ndev = ep->dev;\r\nif (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN))\r\nreturn -ESHUTDOWN;\r\nif (dev->ep0state == EP0_SUSPEND)\r\nreturn -EBUSY;\r\nif (ep->dma) {\r\nstatus = usb_gadget_map_request(&dev->gadget, &req->req,\r\nep->is_in);\r\nif (status)\r\nreturn status;\r\n}\r\n#ifdef USB_TRACE\r\nVDBG(dev, "%s queue req %p, len %u buf %p\n",\r\n_ep->name, _req, _req->length, _req->buf);\r\n#endif\r\nspin_lock_irqsave(&dev->lock, flags);\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\nif (unlikely(ep->num == 0 && ep->is_in))\r\n_req->zero = 1;\r\nstatus = 0;\r\nif (list_empty(&ep->queue) && likely(!ep->stopped)) {\r\nif (ep->dma)\r\nstatus = start_dma(ep, req);\r\nelse\r\nstatus = (ep->is_in ? write_fifo : read_fifo)(ep, req);\r\nif (unlikely(status != 0)) {\r\nif (status > 0)\r\nstatus = 0;\r\nreq = NULL;\r\n}\r\n}\r\nif (likely(req != NULL))\r\nlist_add_tail(&req->queue, &ep->queue);\r\nif (likely(!list_empty(&ep->queue))\r\n&& likely(ep->num != 0)\r\n&& !ep->dma\r\n&& !(dev->int_enable & INT_EPxDATASET (ep->num)))\r\npio_irq_enable(dev, dev->regs, ep->num);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn status;\r\n}\r\nstatic void nuke(struct goku_ep *ep, int status)\r\n{\r\nstruct goku_request *req;\r\nep->stopped = 1;\r\nif (list_empty(&ep->queue))\r\nreturn;\r\nif (ep->dma)\r\nabort_dma(ep, status);\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next, struct goku_request, queue);\r\ndone(ep, req, status);\r\n}\r\n}\r\nstatic int goku_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct goku_request *req;\r\nstruct goku_ep *ep;\r\nstruct goku_udc *dev;\r\nunsigned long flags;\r\nep = container_of(_ep, struct goku_ep, ep);\r\nif (!_ep || !_req || (!ep->ep.desc && ep->num != 0))\r\nreturn -EINVAL;\r\ndev = ep->dev;\r\nif (!dev->driver)\r\nreturn -ESHUTDOWN;\r\nif (dev->ep0state == EP0_SUSPEND)\r\nreturn -EBUSY;\r\nVDBG(dev, "%s %s %s %s %p\n", __func__, _ep->name,\r\nep->is_in ? "IN" : "OUT",\r\nep->dma ? "dma" : "pio",\r\n_req);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nlist_for_each_entry (req, &ep->queue, queue) {\r\nif (&req->req == _req)\r\nbreak;\r\n}\r\nif (&req->req != _req) {\r\nspin_unlock_irqrestore (&dev->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nif (ep->dma && ep->queue.next == &req->queue && !ep->stopped) {\r\nabort_dma(ep, -ECONNRESET);\r\ndone(ep, req, -ECONNRESET);\r\ndma_advance(dev, ep);\r\n} else if (!list_empty(&req->queue))\r\ndone(ep, req, -ECONNRESET);\r\nelse\r\nreq = NULL;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn req ? 0 : -EOPNOTSUPP;\r\n}\r\nstatic void goku_clear_halt(struct goku_ep *ep)\r\n{\r\nVDBG(ep->dev, "%s clear halt\n", ep->ep.name);\r\ncommand(ep->dev->regs, COMMAND_SETDATA0, ep->num);\r\ncommand(ep->dev->regs, COMMAND_STALL_CLEAR, ep->num);\r\nif (ep->stopped) {\r\nep->stopped = 0;\r\nif (ep->dma) {\r\nstruct goku_request *req;\r\nif (list_empty(&ep->queue))\r\nreturn;\r\nreq = list_entry(ep->queue.next, struct goku_request,\r\nqueue);\r\n(void) start_dma(ep, req);\r\n} else\r\npio_advance(ep);\r\n}\r\n}\r\nstatic int goku_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nstruct goku_ep *ep;\r\nunsigned long flags;\r\nint retval = 0;\r\nif (!_ep)\r\nreturn -ENODEV;\r\nep = container_of (_ep, struct goku_ep, ep);\r\nif (ep->num == 0) {\r\nif (value) {\r\nep->dev->ep0state = EP0_STALL;\r\nep->dev->ep[0].stopped = 1;\r\n} else\r\nreturn -EINVAL;\r\n} else if (!ep->ep.desc) {\r\nDBG(ep->dev, "%s %s inactive?\n", __func__, ep->ep.name);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&ep->dev->lock, flags);\r\nif (!list_empty(&ep->queue))\r\nretval = -EAGAIN;\r\nelse if (ep->is_in && value\r\n&& (readl(&ep->dev->regs->DataSet)\r\n& DATASET_AB(ep->num)))\r\nretval = -EAGAIN;\r\nelse if (!value)\r\ngoku_clear_halt(ep);\r\nelse {\r\nep->stopped = 1;\r\nVDBG(ep->dev, "%s set halt\n", ep->ep.name);\r\ncommand(ep->dev->regs, COMMAND_STALL, ep->num);\r\nreadl(ep->reg_status);\r\n}\r\nspin_unlock_irqrestore(&ep->dev->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int goku_fifo_status(struct usb_ep *_ep)\r\n{\r\nstruct goku_ep *ep;\r\nstruct goku_udc_regs __iomem *regs;\r\nu32 size;\r\nif (!_ep)\r\nreturn -ENODEV;\r\nep = container_of(_ep, struct goku_ep, ep);\r\nif (ep->is_in)\r\nreturn -EOPNOTSUPP;\r\nregs = ep->dev->regs;\r\nsize = readl(&regs->EPxSizeLA[ep->num]) & DATASIZE;\r\nsize += readl(&regs->EPxSizeLB[ep->num]) & DATASIZE;\r\nVDBG(ep->dev, "%s %s %u\n", __func__, ep->ep.name, size);\r\nreturn size;\r\n}\r\nstatic void goku_fifo_flush(struct usb_ep *_ep)\r\n{\r\nstruct goku_ep *ep;\r\nstruct goku_udc_regs __iomem *regs;\r\nu32 size;\r\nif (!_ep)\r\nreturn;\r\nep = container_of(_ep, struct goku_ep, ep);\r\nVDBG(ep->dev, "%s %s\n", __func__, ep->ep.name);\r\nif (!ep->ep.desc && ep->num != 0) {\r\nDBG(ep->dev, "%s %s inactive?\n", __func__, ep->ep.name);\r\nreturn;\r\n}\r\nregs = ep->dev->regs;\r\nsize = readl(&regs->EPxSizeLA[ep->num]);\r\nsize &= DATASIZE;\r\nif (size)\r\ncommand(regs, COMMAND_FIFO_CLEAR, ep->num);\r\n}\r\nstatic int goku_get_frame(struct usb_gadget *_gadget)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic struct usb_ep *goku_match_ep(struct usb_gadget *g,\r\nstruct usb_endpoint_descriptor *desc,\r\nstruct usb_ss_ep_comp_descriptor *ep_comp)\r\n{\r\nstruct goku_udc *dev = to_goku_udc(g);\r\nstruct usb_ep *ep;\r\nswitch (usb_endpoint_type(desc)) {\r\ncase USB_ENDPOINT_XFER_INT:\r\nep = &dev->ep[3].ep;\r\nif (usb_gadget_ep_match_desc(g, ep, desc, ep_comp))\r\nreturn ep;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (usb_endpoint_dir_in(desc)) {\r\nep = &dev->ep[2].ep;\r\nif (usb_gadget_ep_match_desc(g, ep, desc, ep_comp))\r\nreturn ep;\r\n}\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline const char *dmastr(void)\r\n{\r\nif (use_dma == 0)\r\nreturn "(dma disabled)";\r\nelse if (use_dma == 2)\r\nreturn "(dma IN and OUT)";\r\nelse\r\nreturn "(dma IN)";\r\n}\r\nstatic void dump_intmask(struct seq_file *m, const char *label, u32 mask)\r\n{\r\nseq_printf(m, "%s %05X =" FOURBITS EIGHTBITS EIGHTBITS "\n",\r\nlabel, mask,\r\n(mask & INT_PWRDETECT) ? " power" : "",\r\n(mask & INT_SYSERROR) ? " sys" : "",\r\n(mask & INT_MSTRDEND) ? " in-dma" : "",\r\n(mask & INT_MSTWRTMOUT) ? " wrtmo" : "",\r\n(mask & INT_MSTWREND) ? " out-dma" : "",\r\n(mask & INT_MSTWRSET) ? " wrset" : "",\r\n(mask & INT_ERR) ? " err" : "",\r\n(mask & INT_SOF) ? " sof" : "",\r\n(mask & INT_EP3NAK) ? " ep3nak" : "",\r\n(mask & INT_EP2NAK) ? " ep2nak" : "",\r\n(mask & INT_EP1NAK) ? " ep1nak" : "",\r\n(mask & INT_EP3DATASET) ? " ep3" : "",\r\n(mask & INT_EP2DATASET) ? " ep2" : "",\r\n(mask & INT_EP1DATASET) ? " ep1" : "",\r\n(mask & INT_STATUSNAK) ? " ep0snak" : "",\r\n(mask & INT_STATUS) ? " ep0status" : "",\r\n(mask & INT_SETUP) ? " setup" : "",\r\n(mask & INT_ENDPOINT0) ? " ep0" : "",\r\n(mask & INT_USBRESET) ? " reset" : "",\r\n(mask & INT_SUSPEND) ? " suspend" : "");\r\n}\r\nstatic const char *udc_ep_state(enum ep0state state)\r\n{\r\nswitch (state) {\r\ncase EP0_DISCONNECT:\r\nreturn "ep0_disconnect";\r\ncase EP0_IDLE:\r\nreturn "ep0_idle";\r\ncase EP0_IN:\r\nreturn "ep0_in";\r\ncase EP0_OUT:\r\nreturn "ep0_out";\r\ncase EP0_STATUS:\r\nreturn "ep0_status";\r\ncase EP0_STALL:\r\nreturn "ep0_stall";\r\ncase EP0_SUSPEND:\r\nreturn "ep0_suspend";\r\n}\r\nreturn "ep0_?";\r\n}\r\nstatic const char *udc_ep_status(u32 status)\r\n{\r\nswitch (status & EPxSTATUS_EP_MASK) {\r\ncase EPxSTATUS_EP_READY:\r\nreturn "ready";\r\ncase EPxSTATUS_EP_DATAIN:\r\nreturn "packet";\r\ncase EPxSTATUS_EP_FULL:\r\nreturn "full";\r\ncase EPxSTATUS_EP_TX_ERR:\r\nreturn "tx_err";\r\ncase EPxSTATUS_EP_RX_ERR:\r\nreturn "rx_err";\r\ncase EPxSTATUS_EP_BUSY:\r\nreturn "busy";\r\ncase EPxSTATUS_EP_STALL:\r\nreturn "stall";\r\ncase EPxSTATUS_EP_INVALID:\r\nreturn "invalid";\r\n}\r\nreturn "?";\r\n}\r\nstatic int udc_proc_read(struct seq_file *m, void *v)\r\n{\r\nstruct goku_udc *dev = m->private;\r\nstruct goku_udc_regs __iomem *regs = dev->regs;\r\nunsigned long flags;\r\nint i, is_usb_connected;\r\nu32 tmp;\r\nlocal_irq_save(flags);\r\ntmp = readl(&regs->power_detect);\r\nis_usb_connected = tmp & PW_DETECT;\r\nseq_printf(m,\r\n"%s - %s\n"\r\n"%s version: %s %s\n"\r\n"Gadget driver: %s\n"\r\n"Host %s, %s\n"\r\n"\n",\r\npci_name(dev->pdev), driver_desc,\r\ndriver_name, DRIVER_VERSION, dmastr(),\r\ndev->driver ? dev->driver->driver.name : "(none)",\r\nis_usb_connected\r\n? ((tmp & PW_PULLUP) ? "full speed" : "powered")\r\n: "disconnected",\r\nudc_ep_state(dev->ep0state));\r\ndump_intmask(m, "int_status", readl(&regs->int_status));\r\ndump_intmask(m, "int_enable", readl(&regs->int_enable));\r\nif (!is_usb_connected || !dev->driver || (tmp & PW_PULLUP) == 0)\r\ngoto done;\r\nseq_printf(m, "\nirqs %lu\ndataset %02x single.bcs %02x.%02x state %x addr %u\n",\r\ndev->irqs, readl(&regs->DataSet),\r\nreadl(&regs->EPxSingle), readl(&regs->EPxBCS),\r\nreadl(&regs->UsbState),\r\nreadl(&regs->address));\r\nif (seq_has_overflowed(m))\r\ngoto done;\r\ntmp = readl(&regs->dma_master);\r\nseq_printf(m, "dma %03X =" EIGHTBITS "%s %s\n",\r\ntmp,\r\n(tmp & MST_EOPB_DIS) ? " eopb-" : "",\r\n(tmp & MST_EOPB_ENA) ? " eopb+" : "",\r\n(tmp & MST_TIMEOUT_DIS) ? " tmo-" : "",\r\n(tmp & MST_TIMEOUT_ENA) ? " tmo+" : "",\r\n(tmp & MST_RD_EOPB) ? " eopb" : "",\r\n(tmp & MST_RD_RESET) ? " in_reset" : "",\r\n(tmp & MST_WR_RESET) ? " out_reset" : "",\r\n(tmp & MST_RD_ENA) ? " IN" : "",\r\n(tmp & MST_WR_ENA) ? " OUT" : "",\r\n(tmp & MST_CONNECTION) ? "ep1in/ep2out" : "ep1out/ep2in");\r\nif (seq_has_overflowed(m))\r\ngoto done;\r\nfor (i = 0; i < 4; i++) {\r\nstruct goku_ep *ep = &dev->ep [i];\r\nstruct goku_request *req;\r\nif (i && !ep->ep.desc)\r\ncontinue;\r\ntmp = readl(ep->reg_status);\r\nseq_printf(m, "%s %s max %u %s, irqs %lu, status %02x (%s) " FOURBITS "\n",\r\nep->ep.name,\r\nep->is_in ? "in" : "out",\r\nep->ep.maxpacket,\r\nep->dma ? "dma" : "pio",\r\nep->irqs,\r\ntmp, udc_ep_status(tmp),\r\n(tmp & EPxSTATUS_TOGGLE) ? "data1" : "data0",\r\n(tmp & EPxSTATUS_SUSPEND) ? " suspend" : "",\r\n(tmp & EPxSTATUS_FIFO_DISABLE) ? " disable" : "",\r\n(tmp & EPxSTATUS_STAGE_ERROR) ? " ep0stat" : "");\r\nif (seq_has_overflowed(m))\r\ngoto done;\r\nif (list_empty(&ep->queue)) {\r\nseq_puts(m, "\t(nothing queued)\n");\r\nif (seq_has_overflowed(m))\r\ngoto done;\r\ncontinue;\r\n}\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (ep->dma && req->queue.prev == &ep->queue) {\r\nif (i == UDC_MSTRD_ENDPOINT)\r\ntmp = readl(&regs->in_dma_current);\r\nelse\r\ntmp = readl(&regs->out_dma_current);\r\ntmp -= req->req.dma;\r\ntmp++;\r\n} else\r\ntmp = req->req.actual;\r\nseq_printf(m, "\treq %p len %u/%u buf %p\n",\r\n&req->req, tmp, req->req.length,\r\nreq->req.buf);\r\nif (seq_has_overflowed(m))\r\ngoto done;\r\n}\r\n}\r\ndone:\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int udc_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, udc_proc_read, PDE_DATA(file_inode(file)));\r\n}\r\nstatic void udc_reinit (struct goku_udc *dev)\r\n{\r\nstatic char *names [] = { "ep0", "ep1-bulk", "ep2-bulk", "ep3-bulk" };\r\nunsigned i;\r\nINIT_LIST_HEAD (&dev->gadget.ep_list);\r\ndev->gadget.ep0 = &dev->ep [0].ep;\r\ndev->gadget.speed = USB_SPEED_UNKNOWN;\r\ndev->ep0state = EP0_DISCONNECT;\r\ndev->irqs = 0;\r\nfor (i = 0; i < 4; i++) {\r\nstruct goku_ep *ep = &dev->ep[i];\r\nep->num = i;\r\nep->ep.name = names[i];\r\nep->reg_fifo = &dev->regs->ep_fifo [i];\r\nep->reg_status = &dev->regs->ep_status [i];\r\nep->reg_mode = &dev->regs->ep_mode[i];\r\nep->ep.ops = &goku_ep_ops;\r\nlist_add_tail (&ep->ep.ep_list, &dev->gadget.ep_list);\r\nep->dev = dev;\r\nINIT_LIST_HEAD (&ep->queue);\r\nep_reset(NULL, ep);\r\nif (i == 0)\r\nep->ep.caps.type_control = true;\r\nelse\r\nep->ep.caps.type_bulk = true;\r\nep->ep.caps.dir_in = true;\r\nep->ep.caps.dir_out = true;\r\n}\r\ndev->ep[0].reg_mode = NULL;\r\nusb_ep_set_maxpacket_limit(&dev->ep[0].ep, MAX_EP0_SIZE);\r\nlist_del_init (&dev->ep[0].ep.ep_list);\r\n}\r\nstatic void udc_reset(struct goku_udc *dev)\r\n{\r\nstruct goku_udc_regs __iomem *regs = dev->regs;\r\nwritel(0, &regs->power_detect);\r\nwritel(0, &regs->int_enable);\r\nreadl(&regs->int_enable);\r\ndev->int_enable = 0;\r\nudelay(250);\r\nwritel(PW_RESETB, &regs->power_detect);\r\nreadl(&regs->int_enable);\r\n}\r\nstatic void ep0_start(struct goku_udc *dev)\r\n{\r\nstruct goku_udc_regs __iomem *regs = dev->regs;\r\nunsigned i;\r\nVDBG(dev, "%s\n", __func__);\r\nudc_reset(dev);\r\nudc_reinit (dev);\r\nwritel( G_REQMODE_SET_INTF | G_REQMODE_GET_INTF\r\n| G_REQMODE_SET_CONF | G_REQMODE_GET_CONF\r\n| G_REQMODE_GET_DESC\r\n| G_REQMODE_CLEAR_FEAT\r\n, &regs->reqmode);\r\nfor (i = 0; i < 4; i++)\r\ndev->ep[i].irqs = 0;\r\nfor (i = 0; i < DESC_LEN; i++)\r\nwritel(0, &regs->descriptors[i]);\r\nwritel(0, &regs->UsbReady);\r\nwritel(PW_RESETB | PW_PULLUP, &regs->power_detect);\r\ndev->int_enable = INT_DEVWIDE | INT_EP0;\r\nwritel(dev->int_enable, &dev->regs->int_enable);\r\nreadl(&regs->int_enable);\r\ndev->gadget.speed = USB_SPEED_FULL;\r\ndev->ep0state = EP0_IDLE;\r\n}\r\nstatic void udc_enable(struct goku_udc *dev)\r\n{\r\nif (readl(&dev->regs->power_detect) & PW_DETECT)\r\nep0_start(dev);\r\nelse {\r\nDBG(dev, "%s\n", __func__);\r\ndev->int_enable = INT_PWRDETECT;\r\nwritel(dev->int_enable, &dev->regs->int_enable);\r\n}\r\n}\r\nstatic int goku_udc_start(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct goku_udc *dev = to_goku_udc(g);\r\ndriver->driver.bus = NULL;\r\ndev->driver = driver;\r\nudc_enable(dev);\r\nreturn 0;\r\n}\r\nstatic void stop_activity(struct goku_udc *dev)\r\n{\r\nunsigned i;\r\nDBG (dev, "%s\n", __func__);\r\nudc_reset (dev);\r\nfor (i = 0; i < 4; i++)\r\nnuke(&dev->ep [i], -ESHUTDOWN);\r\nif (dev->driver)\r\nudc_enable(dev);\r\n}\r\nstatic int goku_udc_stop(struct usb_gadget *g)\r\n{\r\nstruct goku_udc *dev = to_goku_udc(g);\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->driver = NULL;\r\nstop_activity(dev);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ep0_setup(struct goku_udc *dev)\r\n{\r\nstruct goku_udc_regs __iomem *regs = dev->regs;\r\nstruct usb_ctrlrequest ctrl;\r\nint tmp;\r\nctrl.bRequestType = readl(&regs->bRequestType);\r\nctrl.bRequest = readl(&regs->bRequest);\r\nctrl.wValue = cpu_to_le16((readl(&regs->wValueH) << 8)\r\n| readl(&regs->wValueL));\r\nctrl.wIndex = cpu_to_le16((readl(&regs->wIndexH) << 8)\r\n| readl(&regs->wIndexL));\r\nctrl.wLength = cpu_to_le16((readl(&regs->wLengthH) << 8)\r\n| readl(&regs->wLengthL));\r\nwritel(0, &regs->SetupRecv);\r\nnuke(&dev->ep[0], 0);\r\ndev->ep[0].stopped = 0;\r\nif (likely(ctrl.bRequestType & USB_DIR_IN)) {\r\ndev->ep[0].is_in = 1;\r\ndev->ep0state = EP0_IN;\r\nwritel(ICONTROL_STATUSNAK, &dev->regs->IntControl);\r\n} else {\r\ndev->ep[0].is_in = 0;\r\ndev->ep0state = EP0_OUT;\r\nswitch (ctrl.bRequest) {\r\ncase USB_REQ_CLEAR_FEATURE:\r\nswitch (ctrl.bRequestType) {\r\ncase USB_RECIP_ENDPOINT:\r\ntmp = le16_to_cpu(ctrl.wIndex) & 0x0f;\r\nif (tmp > 3 ||\r\n(!dev->ep[tmp].ep.desc && tmp != 0))\r\ngoto stall;\r\nif (ctrl.wIndex & cpu_to_le16(\r\nUSB_DIR_IN)) {\r\nif (!dev->ep[tmp].is_in)\r\ngoto stall;\r\n} else {\r\nif (dev->ep[tmp].is_in)\r\ngoto stall;\r\n}\r\nif (ctrl.wValue != cpu_to_le16(\r\nUSB_ENDPOINT_HALT))\r\ngoto stall;\r\nif (tmp)\r\ngoku_clear_halt(&dev->ep[tmp]);\r\nsucceed:\r\nwritel(~(1<<0), &regs->EOP);\r\ndev->ep[0].stopped = 1;\r\ndev->ep0state = EP0_STATUS;\r\nreturn;\r\ncase USB_RECIP_DEVICE:\r\nif (ctrl.wValue != cpu_to_le16(1))\r\ngoto stall;\r\nVDBG(dev, "clear dev remote wakeup\n");\r\ngoto succeed;\r\ncase USB_RECIP_INTERFACE:\r\ngoto stall;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n#ifdef USB_TRACE\r\nVDBG(dev, "SETUP %02x.%02x v%04x i%04x l%04x\n",\r\nctrl.bRequestType, ctrl.bRequest,\r\nle16_to_cpu(ctrl.wValue), le16_to_cpu(ctrl.wIndex),\r\nle16_to_cpu(ctrl.wLength));\r\n#endif\r\ndev->req_config = (ctrl.bRequest == USB_REQ_SET_CONFIGURATION\r\n&& ctrl.bRequestType == USB_RECIP_DEVICE);\r\nif (unlikely(dev->req_config))\r\ndev->configured = (ctrl.wValue != cpu_to_le16(0));\r\nspin_unlock (&dev->lock);\r\ntmp = dev->driver->setup(&dev->gadget, &ctrl);\r\nspin_lock (&dev->lock);\r\nif (unlikely(tmp < 0)) {\r\nstall:\r\n#ifdef USB_TRACE\r\nVDBG(dev, "req %02x.%02x protocol STALL; err %d\n",\r\nctrl.bRequestType, ctrl.bRequest, tmp);\r\n#endif\r\ncommand(regs, COMMAND_STALL, 0);\r\ndev->ep[0].stopped = 1;\r\ndev->ep0state = EP0_STALL;\r\n}\r\n}\r\nstatic irqreturn_t goku_irq(int irq, void *_dev)\r\n{\r\nstruct goku_udc *dev = _dev;\r\nstruct goku_udc_regs __iomem *regs = dev->regs;\r\nstruct goku_ep *ep;\r\nu32 stat, handled = 0;\r\nunsigned i, rescans = 5;\r\nspin_lock(&dev->lock);\r\nrescan:\r\nstat = readl(&regs->int_status) & dev->int_enable;\r\nif (!stat)\r\ngoto done;\r\ndev->irqs++;\r\nif (unlikely(stat & INT_DEVWIDE)) {\r\nif (stat & INT_SYSERROR) {\r\nERROR(dev, "system error\n");\r\nstop_activity(dev);\r\nstat = 0;\r\nhandled = 1;\r\ndev->driver = NULL;\r\ngoto done;\r\n}\r\nif (stat & INT_PWRDETECT) {\r\nwritel(~stat, &regs->int_status);\r\nif (readl(&dev->regs->power_detect) & PW_DETECT) {\r\nVDBG(dev, "connect\n");\r\nep0_start(dev);\r\n} else {\r\nDBG(dev, "disconnect\n");\r\nif (dev->gadget.speed == USB_SPEED_FULL)\r\nstop_activity(dev);\r\ndev->ep0state = EP0_DISCONNECT;\r\ndev->int_enable = INT_DEVWIDE;\r\nwritel(dev->int_enable, &dev->regs->int_enable);\r\n}\r\nstat = 0;\r\nhandled = 1;\r\ngoto done;\r\n}\r\nif (stat & INT_SUSPEND) {\r\nACK(INT_SUSPEND);\r\nif (readl(&regs->ep_status[0]) & EPxSTATUS_SUSPEND) {\r\nswitch (dev->ep0state) {\r\ncase EP0_DISCONNECT:\r\ncase EP0_SUSPEND:\r\ngoto pm_next;\r\ndefault:\r\nbreak;\r\n}\r\nDBG(dev, "USB suspend\n");\r\ndev->ep0state = EP0_SUSPEND;\r\nif (dev->gadget.speed != USB_SPEED_UNKNOWN\r\n&& dev->driver\r\n&& dev->driver->suspend) {\r\nspin_unlock(&dev->lock);\r\ndev->driver->suspend(&dev->gadget);\r\nspin_lock(&dev->lock);\r\n}\r\n} else {\r\nif (dev->ep0state != EP0_SUSPEND) {\r\nDBG(dev, "bogus USB resume %d\n",\r\ndev->ep0state);\r\ngoto pm_next;\r\n}\r\nDBG(dev, "USB resume\n");\r\ndev->ep0state = EP0_IDLE;\r\nif (dev->gadget.speed != USB_SPEED_UNKNOWN\r\n&& dev->driver\r\n&& dev->driver->resume) {\r\nspin_unlock(&dev->lock);\r\ndev->driver->resume(&dev->gadget);\r\nspin_lock(&dev->lock);\r\n}\r\n}\r\n}\r\npm_next:\r\nif (stat & INT_USBRESET) {\r\nACK(INT_USBRESET);\r\nINFO(dev, "USB reset done, gadget %s\n",\r\ndev->driver->driver.name);\r\n}\r\n}\r\nif (stat & INT_SETUP) {\r\nACK(INT_SETUP);\r\ndev->ep[0].irqs++;\r\nep0_setup(dev);\r\n}\r\nif (stat & INT_STATUSNAK) {\r\nACK(INT_STATUSNAK|INT_ENDPOINT0);\r\nif (dev->ep0state == EP0_IN) {\r\nep = &dev->ep[0];\r\nep->irqs++;\r\nnuke(ep, 0);\r\nwritel(~(1<<0), &regs->EOP);\r\ndev->ep0state = EP0_STATUS;\r\n}\r\n}\r\nif (stat & INT_ENDPOINT0) {\r\nACK(INT_ENDPOINT0);\r\nep = &dev->ep[0];\r\nep->irqs++;\r\npio_advance(ep);\r\n}\r\nif (stat & INT_MSTRDEND) {\r\nACK(INT_MSTRDEND);\r\nep = &dev->ep[UDC_MSTRD_ENDPOINT];\r\nep->irqs++;\r\ndma_advance(dev, ep);\r\n}\r\nif (stat & INT_MSTWREND) {\r\nACK(INT_MSTWREND);\r\nep = &dev->ep[UDC_MSTWR_ENDPOINT];\r\nep->irqs++;\r\ndma_advance(dev, ep);\r\n}\r\nif (stat & INT_MSTWRTMOUT) {\r\nACK(INT_MSTWRTMOUT);\r\nep = &dev->ep[UDC_MSTWR_ENDPOINT];\r\nep->irqs++;\r\nERROR(dev, "%s write timeout ?\n", ep->ep.name);\r\n}\r\nfor (i = 1; i < 4; i++) {\r\nu32 tmp = INT_EPxDATASET(i);\r\nif (!(stat & tmp))\r\ncontinue;\r\nep = &dev->ep[i];\r\npio_advance(ep);\r\nif (list_empty (&ep->queue))\r\npio_irq_disable(dev, regs, i);\r\nstat &= ~tmp;\r\nhandled = 1;\r\nep->irqs++;\r\n}\r\nif (rescans--)\r\ngoto rescan;\r\ndone:\r\n(void)readl(&regs->int_enable);\r\nspin_unlock(&dev->lock);\r\nif (stat)\r\nDBG(dev, "unhandled irq status: %05x (%05x, %05x)\n", stat,\r\nreadl(&regs->int_status), dev->int_enable);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void gadget_release(struct device *_dev)\r\n{\r\nstruct goku_udc *dev = dev_get_drvdata(_dev);\r\nkfree(dev);\r\n}\r\nstatic void goku_remove(struct pci_dev *pdev)\r\n{\r\nstruct goku_udc *dev = pci_get_drvdata(pdev);\r\nDBG(dev, "%s\n", __func__);\r\nusb_del_gadget_udc(&dev->gadget);\r\nBUG_ON(dev->driver);\r\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\r\nremove_proc_entry(proc_node_name, NULL);\r\n#endif\r\nif (dev->regs)\r\nudc_reset(dev);\r\nif (dev->got_irq)\r\nfree_irq(pdev->irq, dev);\r\nif (dev->regs)\r\niounmap(dev->regs);\r\nif (dev->got_region)\r\nrelease_mem_region(pci_resource_start (pdev, 0),\r\npci_resource_len (pdev, 0));\r\nif (dev->enabled)\r\npci_disable_device(pdev);\r\ndev->regs = NULL;\r\nINFO(dev, "unbind\n");\r\n}\r\nstatic int goku_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct goku_udc *dev = NULL;\r\nunsigned long resource, len;\r\nvoid __iomem *base = NULL;\r\nint retval;\r\nif (!pdev->irq) {\r\nprintk(KERN_ERR "Check PCI %s IRQ setup!\n", pci_name(pdev));\r\nretval = -ENODEV;\r\ngoto err;\r\n}\r\ndev = kzalloc (sizeof *dev, GFP_KERNEL);\r\nif (!dev) {\r\nretval = -ENOMEM;\r\ngoto err;\r\n}\r\nspin_lock_init(&dev->lock);\r\ndev->pdev = pdev;\r\ndev->gadget.ops = &goku_ops;\r\ndev->gadget.max_speed = USB_SPEED_FULL;\r\ndev->gadget.name = driver_name;\r\nretval = pci_enable_device(pdev);\r\nif (retval < 0) {\r\nDBG(dev, "can't enable, %d\n", retval);\r\ngoto err;\r\n}\r\ndev->enabled = 1;\r\nresource = pci_resource_start(pdev, 0);\r\nlen = pci_resource_len(pdev, 0);\r\nif (!request_mem_region(resource, len, driver_name)) {\r\nDBG(dev, "controller already in use\n");\r\nretval = -EBUSY;\r\ngoto err;\r\n}\r\ndev->got_region = 1;\r\nbase = ioremap_nocache(resource, len);\r\nif (base == NULL) {\r\nDBG(dev, "can't map memory\n");\r\nretval = -EFAULT;\r\ngoto err;\r\n}\r\ndev->regs = (struct goku_udc_regs __iomem *) base;\r\npci_set_drvdata(pdev, dev);\r\nINFO(dev, "%s\n", driver_desc);\r\nINFO(dev, "version: " DRIVER_VERSION " %s\n", dmastr());\r\nINFO(dev, "irq %d, pci mem %p\n", pdev->irq, base);\r\nudc_reset(dev);\r\nudc_reinit (dev);\r\nif (request_irq(pdev->irq, goku_irq, IRQF_SHARED,\r\ndriver_name, dev) != 0) {\r\nDBG(dev, "request interrupt %d failed\n", pdev->irq);\r\nretval = -EBUSY;\r\ngoto err;\r\n}\r\ndev->got_irq = 1;\r\nif (use_dma)\r\npci_set_master(pdev);\r\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\r\nproc_create_data(proc_node_name, 0, NULL, &udc_proc_fops, dev);\r\n#endif\r\nretval = usb_add_gadget_udc_release(&pdev->dev, &dev->gadget,\r\ngadget_release);\r\nif (retval)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nif (dev)\r\ngoku_remove (pdev);\r\nkfree(dev);\r\nreturn retval;\r\n}
