static inline struct csi2_dev *sd_to_dev(struct v4l2_subdev *sdev)\r\n{\r\nreturn container_of(sdev, struct csi2_dev, sd);\r\n}\r\nstatic void csi2_enable(struct csi2_dev *csi2, bool enable)\r\n{\r\nif (enable) {\r\nwritel(0x1, csi2->base + CSI2_PHY_SHUTDOWNZ);\r\nwritel(0x1, csi2->base + CSI2_DPHY_RSTZ);\r\nwritel(0x1, csi2->base + CSI2_RESETN);\r\n} else {\r\nwritel(0x0, csi2->base + CSI2_PHY_SHUTDOWNZ);\r\nwritel(0x0, csi2->base + CSI2_DPHY_RSTZ);\r\nwritel(0x0, csi2->base + CSI2_RESETN);\r\n}\r\n}\r\nstatic void csi2_set_lanes(struct csi2_dev *csi2)\r\n{\r\nint lanes = csi2->bus.num_data_lanes;\r\nwritel(lanes - 1, csi2->base + CSI2_N_LANES);\r\n}\r\nstatic void dw_mipi_csi2_phy_write(struct csi2_dev *csi2,\r\nu32 test_code, u32 test_data)\r\n{\r\nwritel(PHY_TESTCLR, csi2->base + CSI2_PHY_TST_CTRL0);\r\nwritel(0x0, csi2->base + CSI2_PHY_TST_CTRL1);\r\nwritel(0x0, csi2->base + CSI2_PHY_TST_CTRL0);\r\nwritel(PHY_TESTCLK, csi2->base + CSI2_PHY_TST_CTRL0);\r\nwritel(PHY_TESTEN | test_code, csi2->base + CSI2_PHY_TST_CTRL1);\r\nwritel(0x0, csi2->base + CSI2_PHY_TST_CTRL0);\r\nwritel(test_data, csi2->base + CSI2_PHY_TST_CTRL1);\r\nwritel(PHY_TESTCLK, csi2->base + CSI2_PHY_TST_CTRL0);\r\nwritel(0x0, csi2->base + CSI2_PHY_TST_CTRL0);\r\n}\r\nstatic int max_mbps_to_hsfreqrange_sel(u32 max_mbps)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(hsfreq_map); i++)\r\nif (hsfreq_map[i].max_mbps > max_mbps)\r\nreturn hsfreq_map[i].hsfreqrange_sel;\r\nreturn -EINVAL;\r\n}\r\nstatic int csi2_dphy_init(struct csi2_dev *csi2)\r\n{\r\nstruct v4l2_ctrl *ctrl;\r\nu32 mbps_per_lane;\r\nint sel;\r\nctrl = v4l2_ctrl_find(csi2->src_sd->ctrl_handler,\r\nV4L2_CID_LINK_FREQ);\r\nif (!ctrl)\r\nmbps_per_lane = CSI2_DEFAULT_MAX_MBPS;\r\nelse\r\nmbps_per_lane = DIV_ROUND_UP_ULL(2 * ctrl->qmenu_int[ctrl->val],\r\nUSEC_PER_SEC);\r\nsel = max_mbps_to_hsfreqrange_sel(mbps_per_lane);\r\nif (sel < 0)\r\nreturn sel;\r\ndw_mipi_csi2_phy_write(csi2, 0x44, sel);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused csi2_dphy_wait_ulp(struct csi2_dev *csi2)\r\n{\r\nu32 reg;\r\nint ret;\r\nret = readl_poll_timeout(csi2->base + CSI2_PHY_STATE, reg,\r\n!(reg & PHY_RXULPSCLKNOT), 0, 500000);\r\nif (ret) {\r\nv4l2_err(&csi2->sd, "ULP timeout, phy_state = 0x%08x\n", reg);\r\nreturn ret;\r\n}\r\nret = readl_poll_timeout(csi2->base + CSI2_ERR1, reg,\r\nreg == 0x0, 0, 500000);\r\nif (ret) {\r\nv4l2_err(&csi2->sd, "stable bus timeout, err1 = 0x%08x\n", reg);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int csi2_dphy_wait_stopstate(struct csi2_dev *csi2)\r\n{\r\nu32 mask, reg;\r\nint ret;\r\nmask = PHY_STOPSTATECLK |\r\n((csi2->bus.num_data_lanes - 1) << PHY_STOPSTATEDATA_BIT);\r\nret = readl_poll_timeout(csi2->base + CSI2_PHY_STATE, reg,\r\n(reg & mask) == mask, 0, 500000);\r\nif (ret) {\r\nv4l2_err(&csi2->sd, "LP-11 timeout, phy_state = 0x%08x\n", reg);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int csi2_dphy_wait_clock_lane(struct csi2_dev *csi2)\r\n{\r\nu32 reg;\r\nint ret;\r\nret = readl_poll_timeout(csi2->base + CSI2_PHY_STATE, reg,\r\n(reg & PHY_RXCLKACTIVEHS), 0, 500000);\r\nif (ret) {\r\nv4l2_err(&csi2->sd, "clock lane timeout, phy_state = 0x%08x\n",\r\nreg);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void csi2ipu_gasket_init(struct csi2_dev *csi2)\r\n{\r\nu32 reg = 0;\r\nswitch (csi2->format_mbus.code) {\r\ncase MEDIA_BUS_FMT_YUYV8_2X8:\r\ncase MEDIA_BUS_FMT_YUYV8_1X16:\r\nreg = CSI2IPU_YUV422_YUYV;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwritel(reg, csi2->base + CSI2IPU_GASKET);\r\n}\r\nstatic int csi2_start(struct csi2_dev *csi2)\r\n{\r\nint ret;\r\nret = clk_prepare_enable(csi2->pix_clk);\r\nif (ret)\r\nreturn ret;\r\ncsi2ipu_gasket_init(csi2);\r\nret = csi2_dphy_init(csi2);\r\nif (ret)\r\ngoto err_disable_clk;\r\ncsi2_set_lanes(csi2);\r\ncsi2_enable(csi2, true);\r\nret = csi2_dphy_wait_stopstate(csi2);\r\nif (ret)\r\ngoto err_assert_reset;\r\nret = v4l2_subdev_call(csi2->src_sd, video, s_stream, 1);\r\nret = (ret && ret != -ENOIOCTLCMD) ? ret : 0;\r\nif (ret)\r\ngoto err_assert_reset;\r\nret = csi2_dphy_wait_clock_lane(csi2);\r\nif (ret)\r\ngoto err_stop_upstream;\r\nreturn 0;\r\nerr_stop_upstream:\r\nv4l2_subdev_call(csi2->src_sd, video, s_stream, 0);\r\nerr_assert_reset:\r\ncsi2_enable(csi2, false);\r\nerr_disable_clk:\r\nclk_disable_unprepare(csi2->pix_clk);\r\nreturn ret;\r\n}\r\nstatic void csi2_stop(struct csi2_dev *csi2)\r\n{\r\nv4l2_subdev_call(csi2->src_sd, video, s_stream, 0);\r\ncsi2_enable(csi2, false);\r\nclk_disable_unprepare(csi2->pix_clk);\r\n}\r\nstatic int csi2_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct csi2_dev *csi2 = sd_to_dev(sd);\r\nint i, ret = 0;\r\nmutex_lock(&csi2->lock);\r\nif (!csi2->src_sd) {\r\nret = -EPIPE;\r\ngoto out;\r\n}\r\nfor (i = 0; i < CSI2_NUM_SRC_PADS; i++) {\r\nif (csi2->sink_linked[i])\r\nbreak;\r\n}\r\nif (i >= CSI2_NUM_SRC_PADS) {\r\nret = -EPIPE;\r\ngoto out;\r\n}\r\nif (csi2->stream_count != !enable)\r\ngoto update_count;\r\ndev_dbg(csi2->dev, "stream %s\n", enable ? "ON" : "OFF");\r\nif (enable)\r\nret = csi2_start(csi2);\r\nelse\r\ncsi2_stop(csi2);\r\nif (ret)\r\ngoto out;\r\nupdate_count:\r\ncsi2->stream_count += enable ? 1 : -1;\r\nif (csi2->stream_count < 0)\r\ncsi2->stream_count = 0;\r\nout:\r\nmutex_unlock(&csi2->lock);\r\nreturn ret;\r\n}\r\nstatic int csi2_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct csi2_dev *csi2 = sd_to_dev(sd);\r\nstruct v4l2_subdev *remote_sd;\r\nint ret = 0;\r\ndev_dbg(csi2->dev, "link setup %s -> %s", remote->entity->name,\r\nlocal->entity->name);\r\nremote_sd = media_entity_to_v4l2_subdev(remote->entity);\r\nmutex_lock(&csi2->lock);\r\nif (local->flags & MEDIA_PAD_FL_SOURCE) {\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (csi2->sink_linked[local->index - 1]) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ncsi2->sink_linked[local->index - 1] = true;\r\n} else {\r\ncsi2->sink_linked[local->index - 1] = false;\r\n}\r\n} else {\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (csi2->src_sd) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ncsi2->src_sd = remote_sd;\r\n} else {\r\ncsi2->src_sd = NULL;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&csi2->lock);\r\nreturn ret;\r\n}\r\nstatic int csi2_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *sdformat)\r\n{\r\nstruct csi2_dev *csi2 = sd_to_dev(sd);\r\nstruct v4l2_mbus_framefmt *fmt;\r\nmutex_lock(&csi2->lock);\r\nif (sdformat->which == V4L2_SUBDEV_FORMAT_TRY)\r\nfmt = v4l2_subdev_get_try_format(&csi2->sd, cfg,\r\nsdformat->pad);\r\nelse\r\nfmt = &csi2->format_mbus;\r\nsdformat->format = *fmt;\r\nmutex_unlock(&csi2->lock);\r\nreturn 0;\r\n}\r\nstatic int csi2_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *sdformat)\r\n{\r\nstruct csi2_dev *csi2 = sd_to_dev(sd);\r\nint ret = 0;\r\nif (sdformat->pad >= CSI2_NUM_PADS)\r\nreturn -EINVAL;\r\nmutex_lock(&csi2->lock);\r\nif (csi2->stream_count > 0) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (sdformat->pad != CSI2_SINK_PAD)\r\nsdformat->format = csi2->format_mbus;\r\nif (sdformat->which == V4L2_SUBDEV_FORMAT_TRY)\r\ncfg->try_fmt = sdformat->format;\r\nelse\r\ncsi2->format_mbus = sdformat->format;\r\nout:\r\nmutex_unlock(&csi2->lock);\r\nreturn ret;\r\n}\r\nstatic int csi2_registered(struct v4l2_subdev *sd)\r\n{\r\nstruct csi2_dev *csi2 = sd_to_dev(sd);\r\nint i, ret;\r\nfor (i = 0; i < CSI2_NUM_PADS; i++) {\r\ncsi2->pad[i].flags = (i == CSI2_SINK_PAD) ?\r\nMEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;\r\n}\r\nret = imx_media_init_mbus_fmt(&csi2->format_mbus,\r\n640, 480, 0, V4L2_FIELD_NONE, NULL);\r\nif (ret)\r\nreturn ret;\r\nreturn media_entity_pads_init(&sd->entity, CSI2_NUM_PADS, csi2->pad);\r\n}\r\nstatic int csi2_parse_endpoints(struct csi2_dev *csi2)\r\n{\r\nstruct device_node *node = csi2->dev->of_node;\r\nstruct device_node *epnode;\r\nstruct v4l2_fwnode_endpoint ep;\r\nepnode = of_graph_get_endpoint_by_regs(node, 0, -1);\r\nif (!epnode) {\r\nv4l2_err(&csi2->sd, "failed to get sink endpoint node\n");\r\nreturn -EINVAL;\r\n}\r\nv4l2_fwnode_endpoint_parse(of_fwnode_handle(epnode), &ep);\r\nof_node_put(epnode);\r\nif (ep.bus_type != V4L2_MBUS_CSI2) {\r\nv4l2_err(&csi2->sd, "invalid bus type, must be MIPI CSI2\n");\r\nreturn -EINVAL;\r\n}\r\ncsi2->bus = ep.bus.mipi_csi2;\r\ndev_dbg(csi2->dev, "data lanes: %d\n", csi2->bus.num_data_lanes);\r\ndev_dbg(csi2->dev, "flags: 0x%08x\n", csi2->bus.flags);\r\nreturn 0;\r\n}\r\nstatic int csi2_probe(struct platform_device *pdev)\r\n{\r\nstruct csi2_dev *csi2;\r\nstruct resource *res;\r\nint ret;\r\ncsi2 = devm_kzalloc(&pdev->dev, sizeof(*csi2), GFP_KERNEL);\r\nif (!csi2)\r\nreturn -ENOMEM;\r\ncsi2->dev = &pdev->dev;\r\nv4l2_subdev_init(&csi2->sd, &csi2_subdev_ops);\r\nv4l2_set_subdevdata(&csi2->sd, &pdev->dev);\r\ncsi2->sd.internal_ops = &csi2_internal_ops;\r\ncsi2->sd.entity.ops = &csi2_entity_ops;\r\ncsi2->sd.dev = &pdev->dev;\r\ncsi2->sd.owner = THIS_MODULE;\r\ncsi2->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nstrcpy(csi2->sd.name, DEVICE_NAME);\r\ncsi2->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\r\ncsi2->sd.grp_id = IMX_MEDIA_GRP_ID_CSI2;\r\nret = csi2_parse_endpoints(csi2);\r\nif (ret)\r\nreturn ret;\r\ncsi2->pllref_clk = devm_clk_get(&pdev->dev, "ref");\r\nif (IS_ERR(csi2->pllref_clk)) {\r\nv4l2_err(&csi2->sd, "failed to get pll reference clock\n");\r\nret = PTR_ERR(csi2->pllref_clk);\r\nreturn ret;\r\n}\r\ncsi2->dphy_clk = devm_clk_get(&pdev->dev, "dphy");\r\nif (IS_ERR(csi2->dphy_clk)) {\r\nv4l2_err(&csi2->sd, "failed to get dphy clock\n");\r\nret = PTR_ERR(csi2->dphy_clk);\r\nreturn ret;\r\n}\r\ncsi2->pix_clk = devm_clk_get(&pdev->dev, "pix");\r\nif (IS_ERR(csi2->pix_clk)) {\r\nv4l2_err(&csi2->sd, "failed to get pixel clock\n");\r\nret = PTR_ERR(csi2->pix_clk);\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nv4l2_err(&csi2->sd, "failed to get platform resources\n");\r\nreturn -ENODEV;\r\n}\r\ncsi2->base = devm_ioremap(&pdev->dev, res->start, PAGE_SIZE);\r\nif (!csi2->base) {\r\nv4l2_err(&csi2->sd, "failed to map CSI-2 registers\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&csi2->lock);\r\nret = clk_prepare_enable(csi2->pllref_clk);\r\nif (ret) {\r\nv4l2_err(&csi2->sd, "failed to enable pllref_clk\n");\r\ngoto rmmutex;\r\n}\r\nret = clk_prepare_enable(csi2->dphy_clk);\r\nif (ret) {\r\nv4l2_err(&csi2->sd, "failed to enable dphy_clk\n");\r\ngoto pllref_off;\r\n}\r\nplatform_set_drvdata(pdev, &csi2->sd);\r\nret = v4l2_async_register_subdev(&csi2->sd);\r\nif (ret)\r\ngoto dphy_off;\r\nreturn 0;\r\ndphy_off:\r\nclk_disable_unprepare(csi2->dphy_clk);\r\npllref_off:\r\nclk_disable_unprepare(csi2->pllref_clk);\r\nrmmutex:\r\nmutex_destroy(&csi2->lock);\r\nreturn ret;\r\n}\r\nstatic int csi2_remove(struct platform_device *pdev)\r\n{\r\nstruct v4l2_subdev *sd = platform_get_drvdata(pdev);\r\nstruct csi2_dev *csi2 = sd_to_dev(sd);\r\nv4l2_async_unregister_subdev(sd);\r\nclk_disable_unprepare(csi2->dphy_clk);\r\nclk_disable_unprepare(csi2->pllref_clk);\r\nmutex_destroy(&csi2->lock);\r\nmedia_entity_cleanup(&sd->entity);\r\nreturn 0;\r\n}
