static inline int __vmware_platform(void)\r\n{\r\nuint32_t eax, ebx, ecx, edx;\r\nVMWARE_PORT(GETVERSION, eax, ebx, ecx, edx);\r\nreturn eax != (uint32_t)-1 && ebx == VMWARE_HYPERVISOR_MAGIC;\r\n}\r\nstatic unsigned long vmware_get_tsc_khz(void)\r\n{\r\nreturn vmware_tsc_khz;\r\n}\r\nstatic __init int setup_vmw_sched_clock(char *s)\r\n{\r\nvmw_sched_clock = 0;\r\nreturn 0;\r\n}\r\nstatic unsigned long long vmware_sched_clock(void)\r\n{\r\nunsigned long long ns;\r\nns = mul_u64_u32_shr(rdtsc(), vmware_cyc2ns.cyc2ns_mul,\r\nvmware_cyc2ns.cyc2ns_shift);\r\nns -= vmware_cyc2ns.cyc2ns_offset;\r\nreturn ns;\r\n}\r\nstatic void __init vmware_sched_clock_setup(void)\r\n{\r\nstruct cyc2ns_data *d = &vmware_cyc2ns;\r\nunsigned long long tsc_now = rdtsc();\r\nclocks_calc_mult_shift(&d->cyc2ns_mul, &d->cyc2ns_shift,\r\nvmware_tsc_khz, NSEC_PER_MSEC, 0);\r\nd->cyc2ns_offset = mul_u64_u32_shr(tsc_now, d->cyc2ns_mul,\r\nd->cyc2ns_shift);\r\npv_time_ops.sched_clock = vmware_sched_clock;\r\npr_info("using sched offset of %llu ns\n", d->cyc2ns_offset);\r\n}\r\nstatic void __init vmware_paravirt_ops_setup(void)\r\n{\r\npv_info.name = "VMware hypervisor";\r\npv_cpu_ops.io_delay = paravirt_nop;\r\nif (vmware_tsc_khz && vmw_sched_clock)\r\nvmware_sched_clock_setup();\r\n}\r\nstatic void __init vmware_set_capabilities(void)\r\n{\r\nsetup_force_cpu_cap(X86_FEATURE_CONSTANT_TSC);\r\nsetup_force_cpu_cap(X86_FEATURE_TSC_RELIABLE);\r\n}\r\nstatic void __init vmware_platform_setup(void)\r\n{\r\nuint32_t eax, ebx, ecx, edx;\r\nuint64_t lpj, tsc_khz;\r\nVMWARE_PORT(GETHZ, eax, ebx, ecx, edx);\r\nif (ebx != UINT_MAX) {\r\nlpj = tsc_khz = eax | (((uint64_t)ebx) << 32);\r\ndo_div(tsc_khz, 1000);\r\nWARN_ON(tsc_khz >> 32);\r\npr_info("TSC freq read from hypervisor : %lu.%03lu MHz\n",\r\n(unsigned long) tsc_khz / 1000,\r\n(unsigned long) tsc_khz % 1000);\r\nif (!preset_lpj) {\r\ndo_div(lpj, HZ);\r\npreset_lpj = lpj;\r\n}\r\nvmware_tsc_khz = tsc_khz;\r\nx86_platform.calibrate_tsc = vmware_get_tsc_khz;\r\nx86_platform.calibrate_cpu = vmware_get_tsc_khz;\r\n#ifdef CONFIG_X86_LOCAL_APIC\r\nlapic_timer_frequency = ecx / HZ;\r\npr_info("Host bus clock speed read from hypervisor : %u Hz\n",\r\necx);\r\n#endif\r\n} else {\r\npr_warn("Failed to get TSC freq from the hypervisor\n");\r\n}\r\nvmware_paravirt_ops_setup();\r\n#ifdef CONFIG_X86_IO_APIC\r\nno_timer_check = 1;\r\n#endif\r\nvmware_set_capabilities();\r\n}\r\nstatic uint32_t __init vmware_platform(void)\r\n{\r\nif (boot_cpu_has(X86_FEATURE_HYPERVISOR)) {\r\nunsigned int eax;\r\nunsigned int hyper_vendor_id[3];\r\ncpuid(CPUID_VMWARE_INFO_LEAF, &eax, &hyper_vendor_id[0],\r\n&hyper_vendor_id[1], &hyper_vendor_id[2]);\r\nif (!memcmp(hyper_vendor_id, "VMwareVMware", 12))\r\nreturn CPUID_VMWARE_INFO_LEAF;\r\n} else if (dmi_available && dmi_name_in_serial("VMware") &&\r\n__vmware_platform())\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic bool __init vmware_legacy_x2apic_available(void)\r\n{\r\nuint32_t eax, ebx, ecx, edx;\r\nVMWARE_PORT(GETVCPU_INFO, eax, ebx, ecx, edx);\r\nreturn (eax & (1 << VMWARE_PORT_CMD_VCPU_RESERVED)) == 0 &&\r\n(eax & (1 << VMWARE_PORT_CMD_LEGACY_X2APIC)) != 0;\r\n}
