int __init efi_memattr_init(void)\r\n{\r\nefi_memory_attributes_table_t *tbl;\r\nif (efi.mem_attr_table == EFI_INVALID_TABLE_ADDR)\r\nreturn 0;\r\ntbl = early_memremap(efi.mem_attr_table, sizeof(*tbl));\r\nif (!tbl) {\r\npr_err("Failed to map EFI Memory Attributes table @ 0x%lx\n",\r\nefi.mem_attr_table);\r\nreturn -ENOMEM;\r\n}\r\nif (tbl->version > 1) {\r\npr_warn("Unexpected EFI Memory Attributes table version %d\n",\r\ntbl->version);\r\ngoto unmap;\r\n}\r\ntbl_size = sizeof(*tbl) + tbl->num_entries * tbl->desc_size;\r\nmemblock_reserve(efi.mem_attr_table, tbl_size);\r\nset_bit(EFI_MEM_ATTR, &efi.flags);\r\nunmap:\r\nearly_memunmap(tbl, sizeof(*tbl));\r\nreturn 0;\r\n}\r\nstatic bool entry_is_valid(const efi_memory_desc_t *in, efi_memory_desc_t *out)\r\n{\r\nu64 in_paddr = in->phys_addr;\r\nu64 in_size = in->num_pages << EFI_PAGE_SHIFT;\r\nefi_memory_desc_t *md;\r\n*out = *in;\r\nif (in->type != EFI_RUNTIME_SERVICES_CODE &&\r\nin->type != EFI_RUNTIME_SERVICES_DATA) {\r\npr_warn("Entry type should be RuntimeServiceCode/Data\n");\r\nreturn false;\r\n}\r\nif (!(in->attribute & (EFI_MEMORY_RO | EFI_MEMORY_XP))) {\r\npr_warn("Entry attributes invalid: RO and XP bits both cleared\n");\r\nreturn false;\r\n}\r\nif (PAGE_SIZE > EFI_PAGE_SIZE &&\r\n(!PAGE_ALIGNED(in->phys_addr) ||\r\n!PAGE_ALIGNED(in->num_pages << EFI_PAGE_SHIFT))) {\r\npr_warn("Entry address region misaligned\n");\r\nreturn false;\r\n}\r\nfor_each_efi_memory_desc(md) {\r\nu64 md_paddr = md->phys_addr;\r\nu64 md_size = md->num_pages << EFI_PAGE_SHIFT;\r\nif (!(md->attribute & EFI_MEMORY_RUNTIME))\r\ncontinue;\r\nif (md->virt_addr == 0) {\r\nbreak;\r\n}\r\nif (md_paddr > in_paddr || (in_paddr - md_paddr) >= md_size)\r\ncontinue;\r\nif (md_paddr + md_size < in_paddr + in_size) {\r\npr_warn("Entry covers multiple EFI memory map regions\n");\r\nreturn false;\r\n}\r\nif (md->type != in->type) {\r\npr_warn("Entry type deviates from EFI memory map region type\n");\r\nreturn false;\r\n}\r\nout->virt_addr = in_paddr + (md->virt_addr - md_paddr);\r\nreturn true;\r\n}\r\npr_warn("No matching entry found in the EFI memory map\n");\r\nreturn false;\r\n}\r\nint __init efi_memattr_apply_permissions(struct mm_struct *mm,\r\nefi_memattr_perm_setter fn)\r\n{\r\nefi_memory_attributes_table_t *tbl;\r\nint i, ret;\r\nif (tbl_size <= sizeof(*tbl))\r\nreturn 0;\r\nif (WARN_ON(!efi_enabled(EFI_MEMMAP)))\r\nreturn 0;\r\ntbl = memremap(efi.mem_attr_table, tbl_size, MEMREMAP_WB);\r\nif (!tbl) {\r\npr_err("Failed to map EFI Memory Attributes table @ 0x%lx\n",\r\nefi.mem_attr_table);\r\nreturn -ENOMEM;\r\n}\r\nif (efi_enabled(EFI_DBG))\r\npr_info("Processing EFI Memory Attributes table:\n");\r\nfor (i = ret = 0; ret == 0 && i < tbl->num_entries; i++) {\r\nefi_memory_desc_t md;\r\nunsigned long size;\r\nbool valid;\r\nchar buf[64];\r\nvalid = entry_is_valid((void *)tbl->entry + i * tbl->desc_size,\r\n&md);\r\nsize = md.num_pages << EFI_PAGE_SHIFT;\r\nif (efi_enabled(EFI_DBG) || !valid)\r\npr_info("%s 0x%012llx-0x%012llx %s\n",\r\nvalid ? "" : "!", md.phys_addr,\r\nmd.phys_addr + size - 1,\r\nefi_md_typeattr_format(buf, sizeof(buf), &md));\r\nif (valid) {\r\nret = fn(mm, &md);\r\nif (ret)\r\npr_err("Error updating mappings, skipping subsequent md's\n");\r\n}\r\n}\r\nmemunmap(tbl);\r\nreturn ret;\r\n}
