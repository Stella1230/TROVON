static netdev_tx_t vxcan_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct vxcan_priv *priv = netdev_priv(dev);\r\nstruct net_device *peer;\r\nstruct canfd_frame *cfd = (struct canfd_frame *)skb->data;\r\nstruct net_device_stats *peerstats, *srcstats = &dev->stats;\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nrcu_read_lock();\r\npeer = rcu_dereference(priv->peer);\r\nif (unlikely(!peer)) {\r\nkfree_skb(skb);\r\ndev->stats.tx_dropped++;\r\ngoto out_unlock;\r\n}\r\nskb = can_create_echo_skb(skb);\r\nif (!skb)\r\ngoto out_unlock;\r\nskb->csum_start = 0;\r\nskb->pkt_type = PACKET_BROADCAST;\r\nskb->dev = peer;\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nif (netif_rx_ni(skb) == NET_RX_SUCCESS) {\r\nsrcstats->tx_packets++;\r\nsrcstats->tx_bytes += cfd->len;\r\npeerstats = &peer->stats;\r\npeerstats->rx_packets++;\r\npeerstats->rx_bytes += cfd->len;\r\n}\r\nout_unlock:\r\nrcu_read_unlock();\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int vxcan_open(struct net_device *dev)\r\n{\r\nstruct vxcan_priv *priv = netdev_priv(dev);\r\nstruct net_device *peer = rtnl_dereference(priv->peer);\r\nif (!peer)\r\nreturn -ENOTCONN;\r\nif (peer->flags & IFF_UP) {\r\nnetif_carrier_on(dev);\r\nnetif_carrier_on(peer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vxcan_close(struct net_device *dev)\r\n{\r\nstruct vxcan_priv *priv = netdev_priv(dev);\r\nstruct net_device *peer = rtnl_dereference(priv->peer);\r\nnetif_carrier_off(dev);\r\nif (peer)\r\nnetif_carrier_off(peer);\r\nreturn 0;\r\n}\r\nstatic int vxcan_get_iflink(const struct net_device *dev)\r\n{\r\nstruct vxcan_priv *priv = netdev_priv(dev);\r\nstruct net_device *peer;\r\nint iflink;\r\nrcu_read_lock();\r\npeer = rcu_dereference(priv->peer);\r\niflink = peer ? peer->ifindex : 0;\r\nrcu_read_unlock();\r\nreturn iflink;\r\n}\r\nstatic int vxcan_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (dev->flags & IFF_UP)\r\nreturn -EBUSY;\r\nif (new_mtu != CAN_MTU && new_mtu != CANFD_MTU)\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void vxcan_setup(struct net_device *dev)\r\n{\r\ndev->type = ARPHRD_CAN;\r\ndev->mtu = CANFD_MTU;\r\ndev->hard_header_len = 0;\r\ndev->addr_len = 0;\r\ndev->tx_queue_len = 0;\r\ndev->flags = (IFF_NOARP|IFF_ECHO);\r\ndev->netdev_ops = &vxcan_netdev_ops;\r\ndev->needs_free_netdev = true;\r\n}\r\nstatic int vxcan_newlink(struct net *net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[],\r\nstruct netlink_ext_ack *extack)\r\n{\r\nstruct vxcan_priv *priv;\r\nstruct net_device *peer;\r\nstruct net *peer_net;\r\nstruct nlattr *peer_tb[IFLA_MAX + 1], **tbp = tb;\r\nchar ifname[IFNAMSIZ];\r\nunsigned char name_assign_type;\r\nstruct ifinfomsg *ifmp = NULL;\r\nint err;\r\nif (data && data[VXCAN_INFO_PEER]) {\r\nstruct nlattr *nla_peer;\r\nnla_peer = data[VXCAN_INFO_PEER];\r\nifmp = nla_data(nla_peer);\r\nerr = rtnl_nla_parse_ifla(peer_tb,\r\nnla_data(nla_peer) +\r\nsizeof(struct ifinfomsg),\r\nnla_len(nla_peer) -\r\nsizeof(struct ifinfomsg),\r\nNULL);\r\nif (err < 0)\r\nreturn err;\r\ntbp = peer_tb;\r\n}\r\nif (tbp[IFLA_IFNAME]) {\r\nnla_strlcpy(ifname, tbp[IFLA_IFNAME], IFNAMSIZ);\r\nname_assign_type = NET_NAME_USER;\r\n} else {\r\nsnprintf(ifname, IFNAMSIZ, DRV_NAME "%%d");\r\nname_assign_type = NET_NAME_ENUM;\r\n}\r\npeer_net = rtnl_link_get_net(net, tbp);\r\nif (IS_ERR(peer_net))\r\nreturn PTR_ERR(peer_net);\r\npeer = rtnl_create_link(peer_net, ifname, name_assign_type,\r\n&vxcan_link_ops, tbp);\r\nif (IS_ERR(peer)) {\r\nput_net(peer_net);\r\nreturn PTR_ERR(peer);\r\n}\r\nif (ifmp && dev->ifindex)\r\npeer->ifindex = ifmp->ifi_index;\r\nerr = register_netdevice(peer);\r\nput_net(peer_net);\r\npeer_net = NULL;\r\nif (err < 0) {\r\nfree_netdev(peer);\r\nreturn err;\r\n}\r\nnetif_carrier_off(peer);\r\nerr = rtnl_configure_link(peer, ifmp);\r\nif (err < 0) {\r\nunregister_netdevice(peer);\r\nreturn err;\r\n}\r\nif (tb[IFLA_IFNAME])\r\nnla_strlcpy(dev->name, tb[IFLA_IFNAME], IFNAMSIZ);\r\nelse\r\nsnprintf(dev->name, IFNAMSIZ, DRV_NAME "%%d");\r\nerr = register_netdevice(dev);\r\nif (err < 0) {\r\nunregister_netdevice(peer);\r\nreturn err;\r\n}\r\nnetif_carrier_off(dev);\r\npriv = netdev_priv(dev);\r\nrcu_assign_pointer(priv->peer, peer);\r\npriv = netdev_priv(peer);\r\nrcu_assign_pointer(priv->peer, dev);\r\nreturn 0;\r\n}\r\nstatic void vxcan_dellink(struct net_device *dev, struct list_head *head)\r\n{\r\nstruct vxcan_priv *priv;\r\nstruct net_device *peer;\r\npriv = netdev_priv(dev);\r\npeer = rtnl_dereference(priv->peer);\r\nRCU_INIT_POINTER(priv->peer, NULL);\r\nunregister_netdevice_queue(dev, head);\r\nif (peer) {\r\npriv = netdev_priv(peer);\r\nRCU_INIT_POINTER(priv->peer, NULL);\r\nunregister_netdevice_queue(peer, head);\r\n}\r\n}\r\nstatic struct net *vxcan_get_link_net(const struct net_device *dev)\r\n{\r\nstruct vxcan_priv *priv = netdev_priv(dev);\r\nstruct net_device *peer = rtnl_dereference(priv->peer);\r\nreturn peer ? dev_net(peer) : dev_net(dev);\r\n}\r\nstatic __init int vxcan_init(void)\r\n{\r\npr_info("vxcan: Virtual CAN Tunnel driver\n");\r\nreturn rtnl_link_register(&vxcan_link_ops);\r\n}\r\nstatic __exit void vxcan_exit(void)\r\n{\r\nrtnl_link_unregister(&vxcan_link_ops);\r\n}
