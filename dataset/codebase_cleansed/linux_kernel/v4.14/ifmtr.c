unsigned int ia_css_ifmtr_lines_needed_for_bayer_order(\r\nconst struct ia_css_stream_config *config)\r\n{\r\nassert(config != NULL);\r\nif ((IA_CSS_BAYER_ORDER_BGGR == config->input_config.bayer_order)\r\n|| (IA_CSS_BAYER_ORDER_GBRG == config->input_config.bayer_order))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nunsigned int ia_css_ifmtr_columns_needed_for_bayer_order(\r\nconst struct ia_css_stream_config *config)\r\n{\r\nassert(config != NULL);\r\nif ((IA_CSS_BAYER_ORDER_RGGB == config->input_config.bayer_order)\r\n|| (IA_CSS_BAYER_ORDER_GBRG == config->input_config.bayer_order))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nenum ia_css_err ia_css_ifmtr_configure(struct ia_css_stream_config *config,\r\nstruct ia_css_binary *binary)\r\n{\r\nunsigned int start_line, start_column = 0,\r\ncropped_height,\r\ncropped_width,\r\nnum_vectors,\r\nbuffer_height = 2,\r\nbuffer_width,\r\ntwo_ppc,\r\nvmem_increment = 0,\r\ndeinterleaving = 0,\r\ndeinterleaving_b = 0,\r\nwidth_a = 0,\r\nwidth_b = 0,\r\nbits_per_pixel,\r\nvectors_per_buffer,\r\nvectors_per_line = 0,\r\nbuffers_per_line = 0,\r\nbuf_offset_a = 0,\r\nbuf_offset_b = 0,\r\nline_width = 0,\r\nwidth_b_factor = 1, start_column_b,\r\nleft_padding = 0;\r\ninput_formatter_cfg_t if_a_config, if_b_config;\r\nenum ia_css_stream_format input_format;\r\nenum ia_css_err err = IA_CSS_SUCCESS;\r\nuint8_t if_config_index;\r\nenum ia_css_csi2_port port;\r\nif (binary) {\r\ncropped_height = binary->in_frame_info.res.height;\r\ncropped_width = binary->in_frame_info.res.width;\r\nif (binary->info->sp.enable.continuous && binary->info->sp.pipeline.mode != IA_CSS_BINARY_MODE_COPY)\r\nbuffer_width = MAX_VECTORS_PER_INPUT_LINE_CONT * ISP_VEC_NELEMS;\r\nelse\r\nbuffer_width = binary->info->sp.input.max_width;\r\ninput_format = binary->input_format;\r\n} else {\r\ncropped_height = config->input_config.input_res.height;\r\ncropped_width = config->input_config.input_res.width;\r\nbuffer_width = MAX_VECTORS_PER_INPUT_LINE_CONT * ISP_VEC_NELEMS;\r\ninput_format = config->input_config.format;\r\n}\r\ntwo_ppc = config->pixels_per_clock == 2;\r\nif (config->mode == IA_CSS_INPUT_MODE_SENSOR\r\n|| config->mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {\r\nport = config->source.port.port;\r\nif_config_index = (uint8_t) (port - IA_CSS_CSI2_PORT0);\r\n} else if (config->mode == IA_CSS_INPUT_MODE_MEMORY) {\r\nif_config_index = SH_CSS_IF_CONFIG_NOT_NEEDED;\r\n} else {\r\nif_config_index = 0;\r\n}\r\nassert(if_config_index <= SH_CSS_MAX_IF_CONFIGS\r\n|| if_config_index == SH_CSS_IF_CONFIG_NOT_NEEDED);\r\nerr = ifmtr_input_start_line(config, cropped_height, &start_line);\r\nif (err != IA_CSS_SUCCESS)\r\nreturn err;\r\nerr = ifmtr_start_column(config, cropped_width, &start_column);\r\nif (err != IA_CSS_SUCCESS)\r\nreturn err;\r\nif (config->left_padding == -1)\r\nif (!binary)\r\nleft_padding = 0;\r\nelse\r\nleft_padding = binary->left_padding;\r\nelse\r\nleft_padding = 2*ISP_VEC_NELEMS - config->left_padding;\r\nif (left_padding) {\r\nnum_vectors = CEIL_DIV(cropped_width + left_padding,\r\nISP_VEC_NELEMS);\r\n} else {\r\nnum_vectors = CEIL_DIV(cropped_width, ISP_VEC_NELEMS);\r\nnum_vectors *= buffer_height;\r\n}\r\nstart_column_b = start_column;\r\nbits_per_pixel = input_formatter_get_alignment(INPUT_FORMATTER0_ID)\r\n* 8 / ISP_VEC_NELEMS;\r\nswitch (input_format) {\r\ncase IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY:\r\nif (two_ppc) {\r\nvmem_increment = 1;\r\ndeinterleaving = 1;\r\ndeinterleaving_b = 1;\r\nwidth_a = cropped_width * deinterleaving / 2;\r\nwidth_b_factor = 2;\r\nwidth_b = width_a * width_b_factor;\r\nbuffer_width *= deinterleaving * 2;\r\nnum_vectors *= deinterleaving;\r\nbuf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;\r\nvectors_per_line = num_vectors / buffer_height;\r\nline_width = vectors_per_line *\r\ninput_formatter_get_alignment(INPUT_FORMATTER0_ID) /\r\n2;\r\nstart_column /= 2;\r\n} else {\r\nvmem_increment = 1;\r\ndeinterleaving = 3;\r\nwidth_a = cropped_width * deinterleaving / 2;\r\nbuffer_width = buffer_width * deinterleaving / 2;\r\nnum_vectors = num_vectors / 2 * deinterleaving;\r\nstart_column = start_column * deinterleaving / 2;\r\n}\r\nbreak;\r\ncase IA_CSS_STREAM_FORMAT_YUV420_8:\r\ncase IA_CSS_STREAM_FORMAT_YUV420_10:\r\ncase IA_CSS_STREAM_FORMAT_YUV420_16:\r\nif (two_ppc) {\r\nvmem_increment = 1;\r\ndeinterleaving = 1;\r\nwidth_a = width_b = cropped_width * deinterleaving / 2;\r\nbuffer_width *= deinterleaving * 2;\r\nnum_vectors *= deinterleaving;\r\nbuf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;\r\nvectors_per_line = num_vectors / buffer_height;\r\nline_width = vectors_per_line *\r\ninput_formatter_get_alignment(INPUT_FORMATTER0_ID) /\r\n2;\r\nstart_column *= deinterleaving;\r\nstart_column /= 2;\r\nstart_column_b = start_column;\r\n} else {\r\nvmem_increment = 1;\r\ndeinterleaving = 1;\r\nwidth_a = cropped_width * deinterleaving;\r\nbuffer_width *= deinterleaving * 2;\r\nnum_vectors *= deinterleaving;\r\nstart_column *= deinterleaving;\r\n}\r\nbreak;\r\ncase IA_CSS_STREAM_FORMAT_YUV422_8:\r\ncase IA_CSS_STREAM_FORMAT_YUV422_10:\r\ncase IA_CSS_STREAM_FORMAT_YUV422_16:\r\nif (two_ppc) {\r\nvmem_increment = 1;\r\ndeinterleaving = 1;\r\nwidth_a = width_b = cropped_width * deinterleaving;\r\nbuffer_width *= deinterleaving * 2;\r\nnum_vectors *= deinterleaving;\r\nstart_column *= deinterleaving;\r\nbuf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;\r\nstart_column_b = start_column;\r\n} else {\r\nvmem_increment = 1;\r\ndeinterleaving = 2;\r\nwidth_a = cropped_width * deinterleaving;\r\nbuffer_width *= deinterleaving;\r\nnum_vectors *= deinterleaving;\r\nstart_column *= deinterleaving;\r\n}\r\nbreak;\r\ncase IA_CSS_STREAM_FORMAT_RGB_444:\r\ncase IA_CSS_STREAM_FORMAT_RGB_555:\r\ncase IA_CSS_STREAM_FORMAT_RGB_565:\r\ncase IA_CSS_STREAM_FORMAT_RGB_666:\r\ncase IA_CSS_STREAM_FORMAT_RGB_888:\r\nnum_vectors *= 2;\r\nif (two_ppc) {\r\ndeinterleaving = 2;\r\ndeinterleaving_b = 1;\r\nbuffers_per_line = 4;\r\nstart_column_b = start_column;\r\nstart_column *= deinterleaving;\r\nstart_column_b *= deinterleaving_b;\r\n} else {\r\ndeinterleaving = 3;\r\nbuffers_per_line = 3;\r\nstart_column *= deinterleaving;\r\n}\r\nvmem_increment = 1;\r\nwidth_a = cropped_width * deinterleaving;\r\nwidth_b = cropped_width * deinterleaving_b;\r\nbuffer_width *= buffers_per_line;\r\nnum_vectors = num_vectors / 2 * deinterleaving;\r\nbuf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;\r\nbreak;\r\ncase IA_CSS_STREAM_FORMAT_RAW_6:\r\ncase IA_CSS_STREAM_FORMAT_RAW_7:\r\ncase IA_CSS_STREAM_FORMAT_RAW_8:\r\ncase IA_CSS_STREAM_FORMAT_RAW_10:\r\ncase IA_CSS_STREAM_FORMAT_RAW_12:\r\nif (two_ppc) {\r\nint crop_col = (start_column % 2) == 1;\r\nvmem_increment = 2;\r\ndeinterleaving = 1;\r\nwidth_a = width_b = cropped_width / 2;\r\nbuf_offset_a = crop_col ? 1 : 0;\r\nbuf_offset_b = crop_col ? 0 : 1;\r\nstart_column_b = start_column / 2;\r\nstart_column = start_column / 2 + crop_col;\r\n} else {\r\nvmem_increment = 1;\r\ndeinterleaving = 2;\r\nif ((!binary) || (config->continuous && binary\r\n&& binary->info->sp.pipeline.mode == IA_CSS_BINARY_MODE_COPY)) {\r\ndeinterleaving = 1;\r\n}\r\nwidth_a = cropped_width;\r\nnum_vectors = CEIL_MUL(num_vectors, deinterleaving);\r\n}\r\nbuffer_height *= 2;\r\nif ((!binary) || config->continuous)\r\nbuffer_height *= 2;\r\nvectors_per_line = CEIL_DIV(cropped_width, ISP_VEC_NELEMS);\r\nvectors_per_line = CEIL_MUL(vectors_per_line, deinterleaving);\r\nbreak;\r\ncase IA_CSS_STREAM_FORMAT_RAW_14:\r\ncase IA_CSS_STREAM_FORMAT_RAW_16:\r\nif (two_ppc) {\r\nnum_vectors *= 2;\r\nvmem_increment = 1;\r\ndeinterleaving = 2;\r\nwidth_a = width_b = cropped_width;\r\nbuf_offset_b = buffer_width / ISP_VEC_NELEMS;\r\nbits_per_pixel *= 2;\r\n} else {\r\nvmem_increment = 1;\r\ndeinterleaving = 2;\r\nwidth_a = cropped_width;\r\nstart_column /= deinterleaving;\r\n}\r\nbuffer_height *= 2;\r\nbreak;\r\ncase IA_CSS_STREAM_FORMAT_BINARY_8:\r\ncase IA_CSS_STREAM_FORMAT_GENERIC_SHORT1:\r\ncase IA_CSS_STREAM_FORMAT_GENERIC_SHORT2:\r\ncase IA_CSS_STREAM_FORMAT_GENERIC_SHORT3:\r\ncase IA_CSS_STREAM_FORMAT_GENERIC_SHORT4:\r\ncase IA_CSS_STREAM_FORMAT_GENERIC_SHORT5:\r\ncase IA_CSS_STREAM_FORMAT_GENERIC_SHORT6:\r\ncase IA_CSS_STREAM_FORMAT_GENERIC_SHORT7:\r\ncase IA_CSS_STREAM_FORMAT_GENERIC_SHORT8:\r\ncase IA_CSS_STREAM_FORMAT_YUV420_8_SHIFT:\r\ncase IA_CSS_STREAM_FORMAT_YUV420_10_SHIFT:\r\ncase IA_CSS_STREAM_FORMAT_EMBEDDED:\r\ncase IA_CSS_STREAM_FORMAT_USER_DEF1:\r\ncase IA_CSS_STREAM_FORMAT_USER_DEF2:\r\ncase IA_CSS_STREAM_FORMAT_USER_DEF3:\r\ncase IA_CSS_STREAM_FORMAT_USER_DEF4:\r\ncase IA_CSS_STREAM_FORMAT_USER_DEF5:\r\ncase IA_CSS_STREAM_FORMAT_USER_DEF6:\r\ncase IA_CSS_STREAM_FORMAT_USER_DEF7:\r\ncase IA_CSS_STREAM_FORMAT_USER_DEF8:\r\nbreak;\r\n}\r\nif (width_a == 0)\r\nreturn IA_CSS_ERR_INVALID_ARGUMENTS;\r\nif (two_ppc)\r\nleft_padding /= 2;\r\nif (left_padding)\r\nvectors_per_line = num_vectors;\r\nif (!vectors_per_line) {\r\nvectors_per_line = CEIL_MUL(num_vectors / buffer_height,\r\ndeinterleaving);\r\nline_width = 0;\r\n}\r\nif (!line_width)\r\nline_width = vectors_per_line *\r\ninput_formatter_get_alignment(INPUT_FORMATTER0_ID);\r\nif (!buffers_per_line)\r\nbuffers_per_line = deinterleaving;\r\nline_width = CEIL_MUL(line_width,\r\ninput_formatter_get_alignment(INPUT_FORMATTER0_ID)\r\n* vmem_increment);\r\nvectors_per_buffer = buffer_height * buffer_width / ISP_VEC_NELEMS;\r\nif (config->mode == IA_CSS_INPUT_MODE_TPG &&\r\n((binary && binary->info->sp.pipeline.mode == IA_CSS_BINARY_MODE_VIDEO) ||\r\n(!binary))) {\r\nstart_line = 0;\r\nstart_column = 0;\r\ncropped_height -= start_line;\r\nwidth_a -= start_column;\r\n}\r\nif_a_config.start_line = start_line;\r\nif_a_config.start_column = start_column;\r\nif_a_config.left_padding = left_padding / deinterleaving;\r\nif_a_config.cropped_height = cropped_height;\r\nif_a_config.cropped_width = width_a;\r\nif_a_config.deinterleaving = deinterleaving;\r\nif_a_config.buf_vecs = vectors_per_buffer;\r\nif_a_config.buf_start_index = buf_offset_a;\r\nif_a_config.buf_increment = vmem_increment;\r\nif_a_config.buf_eol_offset =\r\nbuffer_width * bits_per_pixel / 8 - line_width;\r\nif_a_config.is_yuv420_format =\r\n(input_format == IA_CSS_STREAM_FORMAT_YUV420_8)\r\n|| (input_format == IA_CSS_STREAM_FORMAT_YUV420_10)\r\n|| (input_format == IA_CSS_STREAM_FORMAT_YUV420_16);\r\nif_a_config.block_no_reqs = (config->mode != IA_CSS_INPUT_MODE_SENSOR);\r\nif (two_ppc) {\r\nif (deinterleaving_b) {\r\ndeinterleaving = deinterleaving_b;\r\nwidth_b = cropped_width * deinterleaving;\r\nbuffer_width *= deinterleaving;\r\nnum_vectors = num_vectors / 2 *\r\ndeinterleaving * width_b_factor;\r\nvectors_per_line = num_vectors / buffer_height;\r\nline_width = vectors_per_line *\r\ninput_formatter_get_alignment(INPUT_FORMATTER0_ID);\r\n}\r\nif_b_config.start_line = start_line;\r\nif_b_config.start_column = start_column_b;\r\nif_b_config.left_padding = left_padding / deinterleaving;\r\nif_b_config.cropped_height = cropped_height;\r\nif_b_config.cropped_width = width_b;\r\nif_b_config.deinterleaving = deinterleaving;\r\nif_b_config.buf_vecs = vectors_per_buffer;\r\nif_b_config.buf_start_index = buf_offset_b;\r\nif_b_config.buf_increment = vmem_increment;\r\nif_b_config.buf_eol_offset =\r\nbuffer_width * bits_per_pixel / 8 - line_width;\r\nif_b_config.is_yuv420_format =\r\ninput_format == IA_CSS_STREAM_FORMAT_YUV420_8\r\n|| input_format == IA_CSS_STREAM_FORMAT_YUV420_10\r\n|| input_format == IA_CSS_STREAM_FORMAT_YUV420_16;\r\nif_b_config.block_no_reqs =\r\n(config->mode != IA_CSS_INPUT_MODE_SENSOR);\r\nif (SH_CSS_IF_CONFIG_NOT_NEEDED != if_config_index) {\r\nassert(if_config_index <= SH_CSS_MAX_IF_CONFIGS);\r\nifmtr_set_if_blocking_mode(&if_a_config, &if_b_config);\r\nsh_css_sp_set_if_configs(&if_a_config, &if_b_config,\r\nif_config_index);\r\n}\r\n} else {\r\nif (SH_CSS_IF_CONFIG_NOT_NEEDED != if_config_index) {\r\nassert(if_config_index <= SH_CSS_MAX_IF_CONFIGS);\r\nifmtr_set_if_blocking_mode(&if_a_config, NULL);\r\nsh_css_sp_set_if_configs(&if_a_config, NULL,\r\nif_config_index);\r\n}\r\n}\r\nreturn IA_CSS_SUCCESS;\r\n}\r\nstatic void ifmtr_set_if_blocking_mode(\r\nconst input_formatter_cfg_t * const config_a,\r\nconst input_formatter_cfg_t * const config_b)\r\n{\r\nint i;\r\nbool block[] = { false, false, false, false };\r\nassert(N_INPUT_FORMATTER_ID <= (sizeof(block) / sizeof(block[0])));\r\n#if !defined(IS_ISP_2400_SYSTEM)\r\n#error "ifmtr_set_if_blocking_mode: ISP_SYSTEM must be one of {IS_ISP_2400_SYSTEM}"\r\n#endif\r\nblock[INPUT_FORMATTER0_ID] = (bool)config_a->block_no_reqs;\r\nif (NULL != config_b)\r\nblock[INPUT_FORMATTER1_ID] = (bool)config_b->block_no_reqs;\r\nif (ifmtr_set_if_blocking_mode_reset) {\r\nifmtr_set_if_blocking_mode_reset = false;\r\nfor (i = 0; i < N_INPUT_FORMATTER_ID; i++) {\r\ninput_formatter_ID_t id = (input_formatter_ID_t) i;\r\ninput_formatter_rst(id);\r\ninput_formatter_set_fifo_blocking_mode(id, block[id]);\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic enum ia_css_err ifmtr_start_column(\r\nconst struct ia_css_stream_config *config,\r\nunsigned int bin_in,\r\nunsigned int *start_column)\r\n{\r\nunsigned int in = config->input_config.input_res.width, start,\r\nfor_bayer = ia_css_ifmtr_columns_needed_for_bayer_order(config);\r\nif (bin_in + 2 * for_bayer > in)\r\nreturn IA_CSS_ERR_INVALID_ARGUMENTS;\r\nstart = (in - bin_in) / 2;\r\nstart &= ~0x1;\r\nstart += for_bayer;\r\n*start_column = start;\r\nreturn IA_CSS_SUCCESS;\r\n}\r\nstatic enum ia_css_err ifmtr_input_start_line(\r\nconst struct ia_css_stream_config *config,\r\nunsigned int bin_in,\r\nunsigned int *start_line)\r\n{\r\nunsigned int in = config->input_config.input_res.height, start,\r\nfor_bayer = ia_css_ifmtr_lines_needed_for_bayer_order(config);\r\nif (bin_in + 2 * for_bayer > in)\r\nreturn IA_CSS_ERR_INVALID_ARGUMENTS;\r\nstart = (in - bin_in) / 2;\r\nstart &= ~0x1;\r\nstart += for_bayer;\r\n*start_line = start;\r\nreturn IA_CSS_SUCCESS;\r\n}
