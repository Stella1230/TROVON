static int help(struct sk_buff *skb,\r\nunsigned int protoff,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo)\r\n{\r\nunsigned int dataoff, datalen;\r\nconst struct tcphdr *th;\r\nstruct tcphdr _tcph;\r\nvoid *sb_ptr;\r\nint ret = NF_ACCEPT;\r\nint dir = CTINFO2DIR(ctinfo);\r\nstruct nf_ct_sane_master *ct_sane_info = nfct_help_data(ct);\r\nstruct nf_conntrack_expect *exp;\r\nstruct nf_conntrack_tuple *tuple;\r\nstruct sane_request *req;\r\nstruct sane_reply_net_start *reply;\r\nif (ctinfo != IP_CT_ESTABLISHED &&\r\nctinfo != IP_CT_ESTABLISHED_REPLY)\r\nreturn NF_ACCEPT;\r\nth = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);\r\nif (th == NULL)\r\nreturn NF_ACCEPT;\r\ndataoff = protoff + th->doff * 4;\r\nif (dataoff >= skb->len)\r\nreturn NF_ACCEPT;\r\ndatalen = skb->len - dataoff;\r\nspin_lock_bh(&nf_sane_lock);\r\nsb_ptr = skb_header_pointer(skb, dataoff, datalen, sane_buffer);\r\nBUG_ON(sb_ptr == NULL);\r\nif (dir == IP_CT_DIR_ORIGINAL) {\r\nif (datalen != sizeof(struct sane_request))\r\ngoto out;\r\nreq = sb_ptr;\r\nif (req->RPC_code != htonl(SANE_NET_START)) {\r\nct_sane_info->state = SANE_STATE_NORMAL;\r\ngoto out;\r\n}\r\nct_sane_info->state = SANE_STATE_START_REQUESTED;\r\ngoto out;\r\n}\r\nif (ct_sane_info->state != SANE_STATE_START_REQUESTED)\r\ngoto out;\r\nct_sane_info->state = SANE_STATE_NORMAL;\r\nif (datalen < sizeof(struct sane_reply_net_start)) {\r\npr_debug("NET_START reply too short\n");\r\ngoto out;\r\n}\r\nreply = sb_ptr;\r\nif (reply->status != htonl(SANE_STATUS_SUCCESS)) {\r\npr_debug("unsuccessful SANE_STATUS = %u\n",\r\nntohl(reply->status));\r\ngoto out;\r\n}\r\nif (reply->zero != 0)\r\ngoto out;\r\nexp = nf_ct_expect_alloc(ct);\r\nif (exp == NULL) {\r\nnf_ct_helper_log(skb, ct, "cannot alloc expectation");\r\nret = NF_DROP;\r\ngoto out;\r\n}\r\ntuple = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\r\nnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\r\n&tuple->src.u3, &tuple->dst.u3,\r\nIPPROTO_TCP, NULL, &reply->port);\r\npr_debug("expect: ");\r\nnf_ct_dump_tuple(&exp->tuple);\r\nif (nf_ct_expect_related(exp) != 0) {\r\nnf_ct_helper_log(skb, ct, "cannot add expectation");\r\nret = NF_DROP;\r\n}\r\nnf_ct_expect_put(exp);\r\nout:\r\nspin_unlock_bh(&nf_sane_lock);\r\nreturn ret;\r\n}\r\nstatic void nf_conntrack_sane_fini(void)\r\n{\r\nnf_conntrack_helpers_unregister(sane, ports_c * 2);\r\nkfree(sane_buffer);\r\n}\r\nstatic int __init nf_conntrack_sane_init(void)\r\n{\r\nint i, ret = 0;\r\nNF_CT_HELPER_BUILD_BUG_ON(sizeof(struct nf_ct_sane_master));\r\nsane_buffer = kmalloc(65536, GFP_KERNEL);\r\nif (!sane_buffer)\r\nreturn -ENOMEM;\r\nif (ports_c == 0)\r\nports[ports_c++] = SANE_PORT;\r\nfor (i = 0; i < ports_c; i++) {\r\nnf_ct_helper_init(&sane[2 * i], AF_INET, IPPROTO_TCP, "sane",\r\nSANE_PORT, ports[i], ports[i],\r\n&sane_exp_policy, 0, help, NULL,\r\nTHIS_MODULE);\r\nnf_ct_helper_init(&sane[2 * i + 1], AF_INET6, IPPROTO_TCP, "sane",\r\nSANE_PORT, ports[i], ports[i],\r\n&sane_exp_policy, 0, help, NULL,\r\nTHIS_MODULE);\r\n}\r\nret = nf_conntrack_helpers_register(sane, ports_c * 2);\r\nif (ret < 0) {\r\npr_err("failed to register helpers\n");\r\nkfree(sane_buffer);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
