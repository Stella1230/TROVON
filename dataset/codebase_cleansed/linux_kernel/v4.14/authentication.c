static void cap_kref_release(struct kref *kref)\r\n{\r\nstruct gb_cap *cap = container_of(kref, struct gb_cap, kref);\r\nkfree(cap);\r\n}\r\nstatic void put_cap(struct gb_cap *cap)\r\n{\r\nkref_put(&cap->kref, cap_kref_release);\r\n}\r\nstatic struct gb_cap *get_cap(struct cdev *cdev)\r\n{\r\nstruct gb_cap *cap;\r\nmutex_lock(&list_mutex);\r\nlist_for_each_entry(cap, &cap_list, node) {\r\nif (&cap->cdev == cdev) {\r\nkref_get(&cap->kref);\r\ngoto unlock;\r\n}\r\n}\r\ncap = NULL;\r\nunlock:\r\nmutex_unlock(&list_mutex);\r\nreturn cap;\r\n}\r\nstatic int cap_get_endpoint_uid(struct gb_cap *cap, u8 *euid)\r\n{\r\nstruct gb_connection *connection = cap->connection;\r\nstruct gb_cap_get_endpoint_uid_response response;\r\nint ret;\r\nret = gb_operation_sync(connection, GB_CAP_TYPE_GET_ENDPOINT_UID, NULL,\r\n0, &response, sizeof(response));\r\nif (ret) {\r\ndev_err(cap->parent, "failed to get endpoint uid (%d)\n", ret);\r\nreturn ret;\r\n}\r\nmemcpy(euid, response.uid, sizeof(response.uid));\r\nreturn 0;\r\n}\r\nstatic int cap_get_ims_certificate(struct gb_cap *cap, u32 class, u32 id,\r\nu8 *certificate, u32 *size, u8 *result)\r\n{\r\nstruct gb_connection *connection = cap->connection;\r\nstruct gb_cap_get_ims_certificate_request *request;\r\nstruct gb_cap_get_ims_certificate_response *response;\r\nsize_t max_size = gb_operation_get_payload_size_max(connection);\r\nstruct gb_operation *op;\r\nint ret;\r\nop = gb_operation_create_flags(connection,\r\nGB_CAP_TYPE_GET_IMS_CERTIFICATE,\r\nsizeof(*request), max_size,\r\nGB_OPERATION_FLAG_SHORT_RESPONSE,\r\nGFP_KERNEL);\r\nif (!op)\r\nreturn -ENOMEM;\r\nrequest = op->request->payload;\r\nrequest->certificate_class = cpu_to_le32(class);\r\nrequest->certificate_id = cpu_to_le32(id);\r\nret = gb_operation_request_send_sync(op);\r\nif (ret) {\r\ndev_err(cap->parent, "failed to get certificate (%d)\n", ret);\r\ngoto done;\r\n}\r\nresponse = op->response->payload;\r\n*result = response->result_code;\r\n*size = op->response->payload_size - sizeof(*response);\r\nmemcpy(certificate, response->certificate, *size);\r\ndone:\r\ngb_operation_put(op);\r\nreturn ret;\r\n}\r\nstatic int cap_authenticate(struct gb_cap *cap, u32 auth_type, u8 *uid,\r\nu8 *challenge, u8 *result, u8 *auth_response,\r\nu32 *signature_size, u8 *signature)\r\n{\r\nstruct gb_connection *connection = cap->connection;\r\nstruct gb_cap_authenticate_request *request;\r\nstruct gb_cap_authenticate_response *response;\r\nsize_t max_size = gb_operation_get_payload_size_max(connection);\r\nstruct gb_operation *op;\r\nint ret;\r\nop = gb_operation_create_flags(connection, GB_CAP_TYPE_AUTHENTICATE,\r\nsizeof(*request), max_size,\r\nGB_OPERATION_FLAG_SHORT_RESPONSE,\r\nGFP_KERNEL);\r\nif (!op)\r\nreturn -ENOMEM;\r\nrequest = op->request->payload;\r\nrequest->auth_type = cpu_to_le32(auth_type);\r\nmemcpy(request->uid, uid, sizeof(request->uid));\r\nmemcpy(request->challenge, challenge, sizeof(request->challenge));\r\nret = gb_operation_request_send_sync(op);\r\nif (ret) {\r\ndev_err(cap->parent, "failed to authenticate (%d)\n", ret);\r\ngoto done;\r\n}\r\nresponse = op->response->payload;\r\n*result = response->result_code;\r\n*signature_size = op->response->payload_size - sizeof(*response);\r\nmemcpy(auth_response, response->response, sizeof(response->response));\r\nmemcpy(signature, response->signature, *signature_size);\r\ndone:\r\ngb_operation_put(op);\r\nreturn ret;\r\n}\r\nstatic int cap_open(struct inode *inode, struct file *file)\r\n{\r\nstruct gb_cap *cap = get_cap(inode->i_cdev);\r\nif (cap) {\r\nfile->private_data = cap;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int cap_release(struct inode *inode, struct file *file)\r\n{\r\nstruct gb_cap *cap = file->private_data;\r\nput_cap(cap);\r\nreturn 0;\r\n}\r\nstatic int cap_ioctl(struct gb_cap *cap, unsigned int cmd,\r\nvoid __user *buf)\r\n{\r\nstruct cap_ioc_get_endpoint_uid endpoint_uid;\r\nstruct cap_ioc_get_ims_certificate *ims_cert;\r\nstruct cap_ioc_authenticate *authenticate;\r\nsize_t size;\r\nint ret;\r\nswitch (cmd) {\r\ncase CAP_IOC_GET_ENDPOINT_UID:\r\nret = cap_get_endpoint_uid(cap, endpoint_uid.uid);\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user(buf, &endpoint_uid, sizeof(endpoint_uid)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase CAP_IOC_GET_IMS_CERTIFICATE:\r\nsize = sizeof(*ims_cert);\r\nims_cert = memdup_user(buf, size);\r\nif (IS_ERR(ims_cert))\r\nreturn PTR_ERR(ims_cert);\r\nret = cap_get_ims_certificate(cap, ims_cert->certificate_class,\r\nims_cert->certificate_id,\r\nims_cert->certificate,\r\n&ims_cert->cert_size,\r\n&ims_cert->result_code);\r\nif (!ret && copy_to_user(buf, ims_cert, size))\r\nret = -EFAULT;\r\nkfree(ims_cert);\r\nreturn ret;\r\ncase CAP_IOC_AUTHENTICATE:\r\nsize = sizeof(*authenticate);\r\nauthenticate = memdup_user(buf, size);\r\nif (IS_ERR(authenticate))\r\nreturn PTR_ERR(authenticate);\r\nret = cap_authenticate(cap, authenticate->auth_type,\r\nauthenticate->uid,\r\nauthenticate->challenge,\r\n&authenticate->result_code,\r\nauthenticate->response,\r\n&authenticate->signature_size,\r\nauthenticate->signature);\r\nif (!ret && copy_to_user(buf, authenticate, size))\r\nret = -EFAULT;\r\nkfree(authenticate);\r\nreturn ret;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic long cap_ioctl_unlocked(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct gb_cap *cap = file->private_data;\r\nstruct gb_bundle *bundle = cap->connection->bundle;\r\nint ret = -ENODEV;\r\nmutex_lock(&cap->mutex);\r\nif (!cap->disabled) {\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (!ret) {\r\nret = cap_ioctl(cap, cmd, (void __user *)arg);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\n}\r\n}\r\nmutex_unlock(&cap->mutex);\r\nreturn ret;\r\n}\r\nint gb_cap_connection_init(struct gb_connection *connection)\r\n{\r\nstruct gb_cap *cap;\r\nint ret, minor;\r\nif (!connection)\r\nreturn 0;\r\ncap = kzalloc(sizeof(*cap), GFP_KERNEL);\r\nif (!cap)\r\nreturn -ENOMEM;\r\ncap->parent = &connection->bundle->dev;\r\ncap->connection = connection;\r\nmutex_init(&cap->mutex);\r\ngb_connection_set_data(connection, cap);\r\nkref_init(&cap->kref);\r\nmutex_lock(&list_mutex);\r\nlist_add(&cap->node, &cap_list);\r\nmutex_unlock(&list_mutex);\r\nret = gb_connection_enable(connection);\r\nif (ret)\r\ngoto err_list_del;\r\nminor = ida_simple_get(&cap_minors_map, 0, NUM_MINORS, GFP_KERNEL);\r\nif (minor < 0) {\r\nret = minor;\r\ngoto err_connection_disable;\r\n}\r\ncap->dev_num = MKDEV(MAJOR(cap_dev_num), minor);\r\ncdev_init(&cap->cdev, &cap_fops);\r\nret = cdev_add(&cap->cdev, cap->dev_num, 1);\r\nif (ret)\r\ngoto err_remove_ida;\r\ncap->class_device = device_create(cap_class, cap->parent, cap->dev_num,\r\nNULL, "gb-authenticate-%d", minor);\r\nif (IS_ERR(cap->class_device)) {\r\nret = PTR_ERR(cap->class_device);\r\ngoto err_del_cdev;\r\n}\r\nreturn 0;\r\nerr_del_cdev:\r\ncdev_del(&cap->cdev);\r\nerr_remove_ida:\r\nida_simple_remove(&cap_minors_map, minor);\r\nerr_connection_disable:\r\ngb_connection_disable(connection);\r\nerr_list_del:\r\nmutex_lock(&list_mutex);\r\nlist_del(&cap->node);\r\nmutex_unlock(&list_mutex);\r\nput_cap(cap);\r\nreturn ret;\r\n}\r\nvoid gb_cap_connection_exit(struct gb_connection *connection)\r\n{\r\nstruct gb_cap *cap;\r\nif (!connection)\r\nreturn;\r\ncap = gb_connection_get_data(connection);\r\ndevice_destroy(cap_class, cap->dev_num);\r\ncdev_del(&cap->cdev);\r\nida_simple_remove(&cap_minors_map, MINOR(cap->dev_num));\r\nmutex_lock(&cap->mutex);\r\ncap->disabled = true;\r\nmutex_unlock(&cap->mutex);\r\ngb_connection_disable(cap->connection);\r\nmutex_lock(&list_mutex);\r\nlist_del(&cap->node);\r\nmutex_unlock(&list_mutex);\r\nput_cap(cap);\r\n}\r\nint cap_init(void)\r\n{\r\nint ret;\r\ncap_class = class_create(THIS_MODULE, "gb_authenticate");\r\nif (IS_ERR(cap_class))\r\nreturn PTR_ERR(cap_class);\r\nret = alloc_chrdev_region(&cap_dev_num, 0, NUM_MINORS,\r\n"gb_authenticate");\r\nif (ret)\r\ngoto err_remove_class;\r\nreturn 0;\r\nerr_remove_class:\r\nclass_destroy(cap_class);\r\nreturn ret;\r\n}\r\nvoid cap_exit(void)\r\n{\r\nunregister_chrdev_region(cap_dev_num, NUM_MINORS);\r\nclass_destroy(cap_class);\r\nida_destroy(&cap_minors_map);\r\n}
