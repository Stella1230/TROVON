static int\r\nnv10_fifo_dma_new(struct nvkm_fifo *base, const struct nvkm_oclass *oclass,\r\nvoid *data, u32 size, struct nvkm_object **pobject)\r\n{\r\nstruct nvkm_object *parent = oclass->parent;\r\nunion {\r\nstruct nv03_channel_dma_v0 v0;\r\n} *args = data;\r\nstruct nv04_fifo *fifo = nv04_fifo(base);\r\nstruct nv04_fifo_chan *chan = NULL;\r\nstruct nvkm_device *device = fifo->base.engine.subdev.device;\r\nstruct nvkm_instmem *imem = device->imem;\r\nint ret = -ENOSYS;\r\nnvif_ioctl(parent, "create channel dma size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\r\nnvif_ioctl(parent, "create channel dma vers %d pushbuf %llx "\r\n"offset %08x\n", args->v0.version,\r\nargs->v0.pushbuf, args->v0.offset);\r\nif (!args->v0.pushbuf)\r\nreturn -EINVAL;\r\n} else\r\nreturn ret;\r\nif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*pobject = &chan->base.object;\r\nret = nvkm_fifo_chan_ctor(&nv04_fifo_dma_func, &fifo->base,\r\n0x1000, 0x1000, false, 0, args->v0.pushbuf,\r\n(1ULL << NVKM_ENGINE_DMAOBJ) |\r\n(1ULL << NVKM_ENGINE_GR) |\r\n(1ULL << NVKM_ENGINE_SW),\r\n0, 0x800000, 0x10000, oclass, &chan->base);\r\nchan->fifo = fifo;\r\nif (ret)\r\nreturn ret;\r\nargs->v0.chid = chan->base.chid;\r\nchan->ramfc = chan->base.chid * 32;\r\nnvkm_kmap(imem->ramfc);\r\nnvkm_wo32(imem->ramfc, chan->ramfc + 0x00, args->v0.offset);\r\nnvkm_wo32(imem->ramfc, chan->ramfc + 0x04, args->v0.offset);\r\nnvkm_wo32(imem->ramfc, chan->ramfc + 0x0c, chan->base.push->addr >> 4);\r\nnvkm_wo32(imem->ramfc, chan->ramfc + 0x14,\r\nNV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |\r\nNV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |\r\n#ifdef __BIG_ENDIAN\r\nNV_PFIFO_CACHE1_BIG_ENDIAN |\r\n#endif\r\nNV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);\r\nnvkm_done(imem->ramfc);\r\nreturn 0;\r\n}
