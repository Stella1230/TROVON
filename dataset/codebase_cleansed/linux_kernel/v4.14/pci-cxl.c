struct device_node *pnv_pci_get_phb_node(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nreturn of_node_get(hose->dn);\r\n}\r\nint pnv_phb_to_cxl_mode(struct pci_dev *dev, uint64_t mode)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct pnv_ioda_pe *pe;\r\nint rc;\r\npe = pnv_ioda_get_pe(dev);\r\nif (!pe)\r\nreturn -ENODEV;\r\npe_info(pe, "Switching PHB to CXL\n");\r\nrc = opal_pci_set_phb_cxl_mode(phb->opal_id, mode, pe->pe_number);\r\nif (rc == OPAL_UNSUPPORTED)\r\ndev_err(&dev->dev, "Required cxl mode not supported by firmware - update skiboot\n");\r\nelse if (rc)\r\ndev_err(&dev->dev, "opal_pci_set_phb_cxl_mode failed: %i\n", rc);\r\nreturn rc;\r\n}\r\nint pnv_cxl_alloc_hwirqs(struct pci_dev *dev, int num)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nint hwirq = msi_bitmap_alloc_hwirqs(&phb->msi_bmp, num);\r\nif (hwirq < 0) {\r\ndev_warn(&dev->dev, "Failed to find a free MSI\n");\r\nreturn -ENOSPC;\r\n}\r\nreturn phb->msi_base + hwirq;\r\n}\r\nvoid pnv_cxl_release_hwirqs(struct pci_dev *dev, int hwirq, int num)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nmsi_bitmap_free_hwirqs(&phb->msi_bmp, hwirq - phb->msi_base, num);\r\n}\r\nvoid pnv_cxl_release_hwirq_ranges(struct cxl_irq_ranges *irqs,\r\nstruct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nint i, hwirq;\r\nfor (i = 1; i < CXL_IRQ_RANGES; i++) {\r\nif (!irqs->range[i])\r\ncontinue;\r\npr_devel("cxl release irq range 0x%x: offset: 0x%lx limit: %ld\n",\r\ni, irqs->offset[i],\r\nirqs->range[i]);\r\nhwirq = irqs->offset[i] - phb->msi_base;\r\nmsi_bitmap_free_hwirqs(&phb->msi_bmp, hwirq,\r\nirqs->range[i]);\r\n}\r\n}\r\nint pnv_cxl_alloc_hwirq_ranges(struct cxl_irq_ranges *irqs,\r\nstruct pci_dev *dev, int num)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nint i, hwirq, try;\r\nmemset(irqs, 0, sizeof(struct cxl_irq_ranges));\r\nfor (i = 1; i < CXL_IRQ_RANGES && num; i++) {\r\ntry = num;\r\nwhile (try) {\r\nhwirq = msi_bitmap_alloc_hwirqs(&phb->msi_bmp, try);\r\nif (hwirq >= 0)\r\nbreak;\r\ntry /= 2;\r\n}\r\nif (!try)\r\ngoto fail;\r\nirqs->offset[i] = phb->msi_base + hwirq;\r\nirqs->range[i] = try;\r\npr_devel("cxl alloc irq range 0x%x: offset: 0x%lx limit: %li\n",\r\ni, irqs->offset[i], irqs->range[i]);\r\nnum -= try;\r\n}\r\nif (num)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\npnv_cxl_release_hwirq_ranges(irqs, dev);\r\nreturn -ENOSPC;\r\n}\r\nint pnv_cxl_get_irq_count(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nreturn phb->msi_bmp.irq_count;\r\n}\r\nint pnv_cxl_ioda_msi_setup(struct pci_dev *dev, unsigned int hwirq,\r\nunsigned int virq)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nunsigned int xive_num = hwirq - phb->msi_base;\r\nstruct pnv_ioda_pe *pe;\r\nint rc;\r\nif (!(pe = pnv_ioda_get_pe(dev)))\r\nreturn -ENODEV;\r\nrc = opal_pci_set_xive_pe(phb->opal_id, pe->pe_number, xive_num);\r\nif (rc) {\r\npe_warn(pe, "%s: OPAL error %d setting msi_base 0x%x "\r\n"hwirq 0x%x XIVE 0x%x PE\n",\r\npci_name(dev), rc, phb->msi_base, hwirq, xive_num);\r\nreturn -EIO;\r\n}\r\npnv_set_msi_irq_chip(phb, virq);\r\nreturn 0;\r\n}\r\nstatic inline int get_cxl_module(void)\r\n{\r\nstruct module *cxl_module;\r\nmutex_lock(&module_mutex);\r\ncxl_module = find_module("cxl");\r\nif (cxl_module)\r\n__module_get(cxl_module);\r\nmutex_unlock(&module_mutex);\r\nif (!cxl_module)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic inline int get_cxl_module(void) { return 0; }\r\nint pnv_cxl_enable_phb_kernel_api(struct pci_controller *hose, bool enable)\r\n{\r\nstruct pnv_phb *phb = hose->private_data;\r\nint rc;\r\nif (!enable) {\r\nreturn -EPERM;\r\n}\r\nrc = get_cxl_module();\r\nif (rc)\r\nreturn rc;\r\nphb->flags |= PNV_PHB_FLAG_CXL;\r\nhose->controller_ops = pnv_cxl_cx4_ioda_controller_ops;\r\nreturn 0;\r\n}\r\nbool pnv_pci_on_cxl_phb(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nreturn !!(phb->flags & PNV_PHB_FLAG_CXL);\r\n}\r\nstruct cxl_afu *pnv_cxl_phb_to_afu(struct pci_controller *hose)\r\n{\r\nstruct pnv_phb *phb = hose->private_data;\r\nreturn (struct cxl_afu *)phb->cxl_afu;\r\n}\r\nvoid pnv_cxl_phb_set_peer_afu(struct pci_dev *dev, struct cxl_afu *afu)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nphb->cxl_afu = afu;\r\n}\r\nbool pnv_cxl_enable_device_hook(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct cxl_afu *afu = phb->cxl_afu;\r\nif (!pnv_pci_enable_device_hook(dev))\r\nreturn false;\r\nif (PCI_FUNC(dev->devfn) == 0)\r\nreturn true;\r\nif (!afu) {\r\ndev_WARN(&dev->dev, "Attempted to enable function > 0 on CXL PHB without a peer AFU\n");\r\nreturn false;\r\n}\r\ndev_info(&dev->dev, "Enabling function on CXL enabled PHB with peer AFU\n");\r\ncxl_afu_get(afu);\r\nreturn cxl_pci_associate_default_context(dev, afu);\r\n}\r\nvoid pnv_cxl_disable_device(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct cxl_afu *afu = phb->cxl_afu;\r\nif (PCI_FUNC(dev->devfn) == 0)\r\nreturn;\r\ncxl_pci_disable_device(dev);\r\ncxl_afu_put(afu);\r\n}\r\nint pnv_cxl_cx4_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct msi_desc *entry;\r\nstruct cxl_context *ctx = NULL;\r\nunsigned int virq;\r\nint hwirq;\r\nint afu_irq = 0;\r\nint rc;\r\nif (WARN_ON(!phb) || !phb->msi_bmp.bitmap)\r\nreturn -ENODEV;\r\nif (pdev->no_64bit_msi && !phb->msi32_support)\r\nreturn -ENODEV;\r\nrc = cxl_cx4_setup_msi_irqs(pdev, nvec, type);\r\nif (rc)\r\nreturn rc;\r\nfor_each_pci_msi_entry(entry, pdev) {\r\nif (!entry->msi_attrib.is_64 && !phb->msi32_support) {\r\npr_warn("%s: Supports only 64-bit MSIs\n",\r\npci_name(pdev));\r\nreturn -ENXIO;\r\n}\r\nhwirq = cxl_next_msi_hwirq(pdev, &ctx, &afu_irq);\r\nif (WARN_ON(hwirq <= 0))\r\nreturn (hwirq ? hwirq : -ENOMEM);\r\nvirq = irq_create_mapping(NULL, hwirq);\r\nif (!virq) {\r\npr_warn("%s: Failed to map cxl mode MSI to linux irq\n",\r\npci_name(pdev));\r\nreturn -ENOMEM;\r\n}\r\nrc = pnv_cxl_ioda_msi_setup(pdev, hwirq, virq);\r\nif (rc) {\r\npr_warn("%s: Failed to setup cxl mode MSI\n", pci_name(pdev));\r\nirq_dispose_mapping(virq);\r\nreturn rc;\r\n}\r\nirq_set_msi_desc(virq, entry);\r\n}\r\nreturn 0;\r\n}\r\nvoid pnv_cxl_cx4_teardown_msi_irqs(struct pci_dev *pdev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct msi_desc *entry;\r\nirq_hw_number_t hwirq;\r\nif (WARN_ON(!phb))\r\nreturn;\r\nfor_each_pci_msi_entry(entry, pdev) {\r\nif (!entry->irq)\r\ncontinue;\r\nhwirq = virq_to_hw(entry->irq);\r\nirq_set_msi_desc(entry->irq, NULL);\r\nirq_dispose_mapping(entry->irq);\r\n}\r\ncxl_cx4_teardown_msi_irqs(pdev);\r\n}
