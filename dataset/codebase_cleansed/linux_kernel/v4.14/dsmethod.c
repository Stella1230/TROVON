acpi_status\r\nacpi_ds_auto_serialize_method(struct acpi_namespace_node *node,\r\nunion acpi_operand_object *obj_desc)\r\n{\r\nacpi_status status;\r\nunion acpi_parse_object *op = NULL;\r\nstruct acpi_walk_state *walk_state;\r\nACPI_FUNCTION_TRACE_PTR(ds_auto_serialize_method, node);\r\nACPI_DEBUG_PRINT((ACPI_DB_PARSE,\r\n"Method auto-serialization parse [%4.4s] %p\n",\r\nacpi_ut_get_node_name(node), node));\r\nop = acpi_ps_alloc_op(AML_METHOD_OP, obj_desc->method.aml_start);\r\nif (!op) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nacpi_ps_set_name(op, node->name.integer);\r\nop->common.node = node;\r\nwalk_state =\r\nacpi_ds_create_walk_state(node->owner_id, NULL, NULL, NULL);\r\nif (!walk_state) {\r\nacpi_ps_free_op(op);\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nstatus = acpi_ds_init_aml_walk(walk_state, op, node,\r\nobj_desc->method.aml_start,\r\nobj_desc->method.aml_length, NULL, 0);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_ds_delete_walk_state(walk_state);\r\nacpi_ps_free_op(op);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nwalk_state->descending_callback = acpi_ds_detect_named_opcodes;\r\nstatus = acpi_ps_parse_aml(walk_state);\r\nacpi_ps_delete_parse_tree(op);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic acpi_status\r\nacpi_ds_detect_named_opcodes(struct acpi_walk_state *walk_state,\r\nunion acpi_parse_object **out_op)\r\n{\r\nACPI_FUNCTION_NAME(acpi_ds_detect_named_opcodes);\r\nif (!\r\n(walk_state->op_info->\r\nflags & (AML_NAMED | AML_CREATE | AML_FIELD))) {\r\nreturn (AE_OK);\r\n}\r\nwalk_state->method_desc->method.sync_level = 0;\r\nwalk_state->method_desc->method.info_flags |=\r\n(ACPI_METHOD_SERIALIZED | ACPI_METHOD_IGNORE_SYNC_LEVEL);\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Method serialized [%4.4s] %p - [%s] (%4.4X)\n",\r\nwalk_state->method_node->name.ascii,\r\nwalk_state->method_node, walk_state->op_info->name,\r\nwalk_state->opcode));\r\nreturn (AE_CTRL_TERMINATE);\r\n}\r\nacpi_status\r\nacpi_ds_method_error(acpi_status status, struct acpi_walk_state *walk_state)\r\n{\r\nu32 aml_offset;\r\nacpi_name name = 0;\r\nACPI_FUNCTION_ENTRY();\r\nif (ACPI_SUCCESS(status) || (status & AE_CODE_CONTROL)) {\r\nreturn (status);\r\n}\r\nif (acpi_gbl_exception_handler) {\r\nacpi_ex_exit_interpreter();\r\naml_offset = (u32)ACPI_PTR_DIFF(walk_state->aml,\r\nwalk_state->parser_state.\r\naml_start);\r\nif (walk_state->method_node) {\r\nname = walk_state->method_node->name.integer;\r\n} else if (walk_state->deferred_node) {\r\nname = walk_state->deferred_node->name.integer;\r\n}\r\nstatus = acpi_gbl_exception_handler(status, name,\r\nwalk_state->opcode,\r\naml_offset, NULL);\r\nacpi_ex_enter_interpreter();\r\n}\r\nacpi_ds_clear_implicit_return(walk_state);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_ds_dump_method_stack(status, walk_state, walk_state->op);\r\n#ifdef ACPI_DEBUGGER\r\nacpi_db_dump_method_info(status, walk_state);\r\n#endif\r\n}\r\nreturn (status);\r\n}\r\nstatic acpi_status\r\nacpi_ds_create_method_mutex(union acpi_operand_object *method_desc)\r\n{\r\nunion acpi_operand_object *mutex_desc;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ds_create_method_mutex);\r\nmutex_desc = acpi_ut_create_internal_object(ACPI_TYPE_MUTEX);\r\nif (!mutex_desc) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nstatus = acpi_os_create_mutex(&mutex_desc->mutex.os_mutex);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_ut_delete_object_desc(mutex_desc);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nmutex_desc->mutex.sync_level = method_desc->method.sync_level;\r\nmethod_desc->method.mutex = mutex_desc;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,\r\nunion acpi_operand_object *obj_desc,\r\nstruct acpi_walk_state *walk_state)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE_PTR(ds_begin_method_execution, method_node);\r\nif (!method_node) {\r\nreturn_ACPI_STATUS(AE_NULL_ENTRY);\r\n}\r\nacpi_ex_start_trace_method(method_node, obj_desc, walk_state);\r\nif (obj_desc->method.thread_count == ACPI_UINT8_MAX) {\r\nACPI_ERROR((AE_INFO,\r\n"Method reached maximum reentrancy limit (255)"));\r\nreturn_ACPI_STATUS(AE_AML_METHOD_LIMIT);\r\n}\r\nif (obj_desc->method.info_flags & ACPI_METHOD_SERIALIZED) {\r\nif (!obj_desc->method.mutex) {\r\nstatus = acpi_ds_create_method_mutex(obj_desc);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nif (walk_state &&\r\n(!(obj_desc->method.\r\ninfo_flags & ACPI_METHOD_IGNORE_SYNC_LEVEL))\r\n&& (walk_state->thread->current_sync_level >\r\nobj_desc->method.mutex->mutex.sync_level)) {\r\nACPI_ERROR((AE_INFO,\r\n"Cannot acquire Mutex for method [%4.4s]"\r\n", current SyncLevel is too large (%u)",\r\nacpi_ut_get_node_name(method_node),\r\nwalk_state->thread->current_sync_level));\r\nreturn_ACPI_STATUS(AE_AML_MUTEX_ORDER);\r\n}\r\nif (!walk_state ||\r\n!obj_desc->method.mutex->mutex.thread_id ||\r\n(walk_state->thread->thread_id !=\r\nobj_desc->method.mutex->mutex.thread_id)) {\r\nstatus =\r\nacpi_ex_system_wait_mutex(obj_desc->method.mutex->\r\nmutex.os_mutex,\r\nACPI_WAIT_FOREVER);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (walk_state) {\r\nobj_desc->method.mutex->mutex.\r\noriginal_sync_level =\r\nwalk_state->thread->current_sync_level;\r\nobj_desc->method.mutex->mutex.thread_id =\r\nwalk_state->thread->thread_id;\r\nif (!(obj_desc->method.info_flags &\r\nACPI_METHOD_IGNORE_SYNC_LEVEL)) {\r\nwalk_state->thread->current_sync_level =\r\nobj_desc->method.sync_level;\r\n}\r\n} else {\r\nobj_desc->method.mutex->mutex.\r\noriginal_sync_level =\r\nobj_desc->method.mutex->mutex.sync_level;\r\nobj_desc->method.mutex->mutex.thread_id =\r\nacpi_os_get_thread_id();\r\n}\r\n}\r\nobj_desc->method.mutex->mutex.acquisition_depth++;\r\n}\r\nif (!obj_desc->method.owner_id) {\r\nstatus = acpi_ut_allocate_owner_id(&obj_desc->method.owner_id);\r\nif (ACPI_FAILURE(status)) {\r\ngoto cleanup;\r\n}\r\n}\r\nobj_desc->method.thread_count++;\r\nacpi_method_count++;\r\nreturn_ACPI_STATUS(status);\r\ncleanup:\r\nif (obj_desc->method.mutex) {\r\nacpi_os_release_mutex(obj_desc->method.mutex->mutex.os_mutex);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ds_call_control_method(struct acpi_thread_state *thread,\r\nstruct acpi_walk_state *this_walk_state,\r\nunion acpi_parse_object *op)\r\n{\r\nacpi_status status;\r\nstruct acpi_namespace_node *method_node;\r\nstruct acpi_walk_state *next_walk_state = NULL;\r\nunion acpi_operand_object *obj_desc;\r\nstruct acpi_evaluate_info *info;\r\nu32 i;\r\nACPI_FUNCTION_TRACE_PTR(ds_call_control_method, this_walk_state);\r\nACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\r\n"Calling method %p, currentstate=%p\n",\r\nthis_walk_state->prev_op, this_walk_state));\r\nmethod_node = this_walk_state->method_call_node;\r\nif (!method_node) {\r\nreturn_ACPI_STATUS(AE_NULL_ENTRY);\r\n}\r\nobj_desc = acpi_ns_get_attached_object(method_node);\r\nif (!obj_desc) {\r\nreturn_ACPI_STATUS(AE_NULL_OBJECT);\r\n}\r\nstatus =\r\nacpi_ds_begin_method_execution(method_node, obj_desc,\r\nthis_walk_state);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nnext_walk_state =\r\nacpi_ds_create_walk_state(obj_desc->method.owner_id, NULL, obj_desc,\r\nthread);\r\nif (!next_walk_state) {\r\nstatus = AE_NO_MEMORY;\r\ngoto cleanup;\r\n}\r\nthis_walk_state->operands[this_walk_state->num_operands] = NULL;\r\ninfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\r\nif (!info) {\r\nstatus = AE_NO_MEMORY;\r\ngoto cleanup;\r\n}\r\ninfo->parameters = &this_walk_state->operands[0];\r\nstatus = acpi_ds_init_aml_walk(next_walk_state, NULL, method_node,\r\nobj_desc->method.aml_start,\r\nobj_desc->method.aml_length, info,\r\nACPI_IMODE_EXECUTE);\r\nACPI_FREE(info);\r\nif (ACPI_FAILURE(status)) {\r\ngoto cleanup;\r\n}\r\nfor (i = 0; i < obj_desc->method.param_count; i++) {\r\nacpi_ut_remove_reference(this_walk_state->operands[i]);\r\nthis_walk_state->operands[i] = NULL;\r\n}\r\nthis_walk_state->num_operands = 0;\r\nACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\r\n"**** Begin nested execution of [%4.4s] **** WalkState=%p\n",\r\nmethod_node->name.ascii, next_walk_state));\r\nif (obj_desc->method.info_flags & ACPI_METHOD_INTERNAL_ONLY) {\r\nstatus =\r\nobj_desc->method.dispatch.implementation(next_walk_state);\r\nif (status == AE_OK) {\r\nstatus = AE_CTRL_TERMINATE;\r\n}\r\n}\r\nreturn_ACPI_STATUS(status);\r\ncleanup:\r\nacpi_ds_terminate_control_method(obj_desc, next_walk_state);\r\nacpi_ds_delete_walk_state(next_walk_state);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ds_restart_control_method(struct acpi_walk_state *walk_state,\r\nunion acpi_operand_object *return_desc)\r\n{\r\nacpi_status status;\r\nint same_as_implicit_return;\r\nACPI_FUNCTION_TRACE_PTR(ds_restart_control_method, walk_state);\r\nACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\r\n"****Restart [%4.4s] Op %p ReturnValueFromCallee %p\n",\r\nacpi_ut_get_node_name(walk_state->method_node),\r\nwalk_state->method_call_op, return_desc));\r\nACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\r\n" ReturnFromThisMethodUsed?=%X ResStack %p Walk %p\n",\r\nwalk_state->return_used,\r\nwalk_state->results, walk_state));\r\nif (return_desc) {\r\nsame_as_implicit_return =\r\n(walk_state->implicit_return_obj == return_desc);\r\nif (walk_state->return_used) {\r\nstatus = acpi_ds_result_push(return_desc, walk_state);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_ut_remove_reference(return_desc);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nwalk_state->return_desc = return_desc;\r\n}\r\nelse if (!acpi_ds_do_implicit_return\r\n(return_desc, walk_state, FALSE)\r\n|| same_as_implicit_return) {\r\nacpi_ut_remove_reference(return_desc);\r\n}\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nvoid\r\nacpi_ds_terminate_control_method(union acpi_operand_object *method_desc,\r\nstruct acpi_walk_state *walk_state)\r\n{\r\nACPI_FUNCTION_TRACE_PTR(ds_terminate_control_method, walk_state);\r\nif (!method_desc) {\r\nreturn_VOID;\r\n}\r\nif (walk_state) {\r\nacpi_ds_method_data_delete_all(walk_state);\r\nif (!(method_desc->method.info_flags & ACPI_METHOD_MODULE_LEVEL)\r\n&& (method_desc->method.thread_count == 1)) {\r\n(void)acpi_ex_exit_interpreter();\r\nacpi_ns_delete_namespace_subtree(walk_state->\r\nmethod_node);\r\n(void)acpi_ex_enter_interpreter();\r\nif (method_desc->method.\r\ninfo_flags & ACPI_METHOD_MODIFIED_NAMESPACE) {\r\n(void)acpi_ex_exit_interpreter();\r\nacpi_ns_delete_namespace_by_owner(method_desc->\r\nmethod.\r\nowner_id);\r\n(void)acpi_ex_enter_interpreter();\r\nmethod_desc->method.info_flags &=\r\n~ACPI_METHOD_MODIFIED_NAMESPACE;\r\n}\r\n}\r\nif (method_desc->method.mutex) {\r\nmethod_desc->method.mutex->mutex.acquisition_depth--;\r\nif (!method_desc->method.mutex->mutex.acquisition_depth) {\r\nwalk_state->thread->current_sync_level =\r\nmethod_desc->method.mutex->mutex.\r\noriginal_sync_level;\r\nacpi_os_release_mutex(method_desc->method.\r\nmutex->mutex.os_mutex);\r\nmethod_desc->method.mutex->mutex.thread_id = 0;\r\n}\r\n}\r\n}\r\nif (method_desc->method.thread_count) {\r\nmethod_desc->method.thread_count--;\r\n} else {\r\nACPI_ERROR((AE_INFO, "Invalid zero thread count in method"));\r\n}\r\nif (method_desc->method.thread_count) {\r\nACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\r\n"*** Completed execution of one thread, %u threads remaining\n",\r\nmethod_desc->method.thread_count));\r\n} else {\r\nif (method_desc->method.\r\ninfo_flags & ACPI_METHOD_SERIALIZED_PENDING) {\r\nif (walk_state) {\r\nACPI_INFO(("Marking method %4.4s as Serialized "\r\n"because of AE_ALREADY_EXISTS error",\r\nwalk_state->method_node->name.\r\nascii));\r\n}\r\nmethod_desc->method.info_flags &=\r\n~ACPI_METHOD_SERIALIZED_PENDING;\r\nmethod_desc->method.info_flags |=\r\n(ACPI_METHOD_SERIALIZED |\r\nACPI_METHOD_IGNORE_SYNC_LEVEL);\r\nmethod_desc->method.sync_level = 0;\r\n}\r\nif (!\r\n(method_desc->method.\r\ninfo_flags & ACPI_METHOD_MODULE_LEVEL)) {\r\nacpi_ut_release_owner_id(&method_desc->method.owner_id);\r\n}\r\n}\r\nacpi_ex_stop_trace_method((struct acpi_namespace_node *)method_desc->\r\nmethod.node, method_desc, walk_state);\r\nreturn_VOID;\r\n}
