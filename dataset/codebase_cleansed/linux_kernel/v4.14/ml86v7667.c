static inline struct ml86v7667_priv *to_ml86v7667(struct v4l2_subdev *subdev)\r\n{\r\nreturn container_of(subdev, struct ml86v7667_priv, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct ml86v7667_priv, hdl)->sd;\r\n}\r\nstatic int ml86v7667_mask_set(struct i2c_client *client, const u8 reg,\r\nconst u8 mask, const u8 data)\r\n{\r\nint val = i2c_smbus_read_byte_data(client, reg);\r\nif (val < 0)\r\nreturn val;\r\nval = (val & ~mask) | (data & mask);\r\nreturn i2c_smbus_write_byte_data(client, reg, val);\r\n}\r\nstatic int ml86v7667_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret = -EINVAL;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nret = ml86v7667_mask_set(client, SSEPL_REG,\r\nSSEPL_LUMINANCE_MASK, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nret = ml86v7667_mask_set(client, CLC_REG,\r\nCLC_CONTRAST_MASK, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CHROMA_GAIN:\r\nret = ml86v7667_mask_set(client, ACCRC_REG, ACCRC_CHROMA_MASK,\r\nctrl->val << ACCRC_CHROMA_SHIFT);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nret = ml86v7667_mask_set(client, HUE_REG, ~0, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_RED_BALANCE:\r\nret = ml86v7667_mask_set(client, ACCC_REG,\r\nACCC_CHROMA_CR_MASK,\r\nctrl->val << ACCC_CHROMA_CR_SHIFT);\r\nbreak;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nret = ml86v7667_mask_set(client, ACCC_REG,\r\nACCC_CHROMA_CB_MASK,\r\nctrl->val << ACCC_CHROMA_CB_SHIFT);\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nret = ml86v7667_mask_set(client, LUMC_REG,\r\nLUMC_ONOFF_MASK,\r\nctrl->val << LUMC_ONOFF_SHIFT);\r\nbreak;\r\ncase V4L2_CID_COLOR_KILLER:\r\nret = ml86v7667_mask_set(client, CHRCA_REG,\r\nCHRCA_MODE_MASK,\r\nctrl->val << CHRCA_MODE_SHIFT);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ml86v7667_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint status;\r\nstatus = i2c_smbus_read_byte_data(client, STATUS_REG);\r\nif (status < 0)\r\nreturn status;\r\nif (status & STATUS_HLOCK_DETECT)\r\n*std &= status & STATUS_NTSCPAL ? V4L2_STD_625_50 : V4L2_STD_525_60;\r\nelse\r\n*std = V4L2_STD_UNKNOWN;\r\nreturn 0;\r\n}\r\nstatic int ml86v7667_g_input_status(struct v4l2_subdev *sd, u32 *status)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint status_reg;\r\nstatus_reg = i2c_smbus_read_byte_data(client, STATUS_REG);\r\nif (status_reg < 0)\r\nreturn status_reg;\r\n*status = status_reg & STATUS_HLOCK_DETECT ? 0 : V4L2_IN_ST_NO_SIGNAL;\r\nreturn 0;\r\n}\r\nstatic int ml86v7667_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->pad || code->index > 0)\r\nreturn -EINVAL;\r\ncode->code = MEDIA_BUS_FMT_YUYV8_2X8;\r\nreturn 0;\r\n}\r\nstatic int ml86v7667_fill_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct ml86v7667_priv *priv = to_ml86v7667(sd);\r\nstruct v4l2_mbus_framefmt *fmt = &format->format;\r\nif (format->pad)\r\nreturn -EINVAL;\r\nfmt->code = MEDIA_BUS_FMT_YUYV8_2X8;\r\nfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nfmt->field = V4L2_FIELD_INTERLACED_TB;\r\nfmt->width = 720;\r\nfmt->height = priv->std & V4L2_STD_525_60 ? 480 : 576;\r\nreturn 0;\r\n}\r\nstatic int ml86v7667_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\ncfg->flags = V4L2_MBUS_MASTER | V4L2_MBUS_PCLK_SAMPLE_RISING |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH;\r\ncfg->type = V4L2_MBUS_BT656;\r\nreturn 0;\r\n}\r\nstatic int ml86v7667_g_std(struct v4l2_subdev *sd, v4l2_std_id *std)\r\n{\r\nstruct ml86v7667_priv *priv = to_ml86v7667(sd);\r\n*std = priv->std;\r\nreturn 0;\r\n}\r\nstatic int ml86v7667_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct ml86v7667_priv *priv = to_ml86v7667(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(&priv->sd);\r\nint ret;\r\nu8 mode;\r\nmode = std & V4L2_STD_525_60 ? MRA_NTSC_BT601 : MRA_PAL_BT601;\r\nret = ml86v7667_mask_set(client, MRA_REG, MRA_INPUT_MODE_MASK, mode);\r\nif (ret < 0)\r\nreturn ret;\r\npriv->std = std;\r\nreturn 0;\r\n}\r\nstatic int ml86v7667_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, (u8)reg->reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreg->val = ret;\r\nreg->size = sizeof(u8);\r\nreturn 0;\r\n}\r\nstatic int ml86v7667_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_write_byte_data(client, (u8)reg->reg, (u8)reg->val);\r\n}\r\nstatic int ml86v7667_init(struct ml86v7667_priv *priv)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&priv->sd);\r\nint val;\r\nint ret;\r\nret = ml86v7667_mask_set(client, MRA_REG,\r\nMRA_OUTPUT_MODE_MASK | MRA_REGISTER_MODE,\r\nMRA_ITUR_BT656 | MRA_REGISTER_MODE);\r\nret |= ml86v7667_mask_set(client, PLLR1_REG, PLLR1_FIXED_CLOCK,\r\nPLLR1_FIXED_CLOCK);\r\nret |= ml86v7667_mask_set(client, ADC2_REG, ADC2_CLAMP_VOLTAGE_MASK,\r\nADC2_CLAMP_VOLTAGE(7));\r\nret |= ml86v7667_mask_set(client, SSEPL_REG, SSEPL_LUMINANCE_ONOFF,\r\nSSEPL_LUMINANCE_ONOFF);\r\nret |= ml86v7667_mask_set(client, CLC_REG, CLC_CONTRAST_ONOFF, 0);\r\nval = i2c_smbus_read_byte_data(client, STATUS_REG);\r\nif (val < 0)\r\nreturn val;\r\npriv->std = val & STATUS_NTSCPAL ? V4L2_STD_625_50 : V4L2_STD_525_60;\r\nret |= ml86v7667_mask_set(client, MRC_REG, MRC_AUTOSELECT, 0);\r\nval = priv->std & V4L2_STD_525_60 ? MRA_NTSC_BT601 : MRA_PAL_BT601;\r\nret |= ml86v7667_mask_set(client, MRA_REG, MRA_INPUT_MODE_MASK, val);\r\nreturn ret;\r\n}\r\nstatic int ml86v7667_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct ml86v7667_priv *priv;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\npriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nv4l2_i2c_subdev_init(&priv->sd, client, &ml86v7667_subdev_ops);\r\nv4l2_ctrl_handler_init(&priv->hdl, 8);\r\nv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -64, 63, 1, 0);\r\nv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\r\nV4L2_CID_CONTRAST, -8, 7, 1, 0);\r\nv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\r\nV4L2_CID_CHROMA_GAIN, -32, 31, 1, 0);\r\nv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\r\nV4L2_CID_RED_BALANCE, -4, 3, 1, 0);\r\nv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\r\nV4L2_CID_BLUE_BALANCE, -4, 3, 1, 0);\r\nv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\r\nV4L2_CID_SHARPNESS, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\r\nV4L2_CID_COLOR_KILLER, 0, 1, 1, 0);\r\npriv->sd.ctrl_handler = &priv->hdl;\r\nret = priv->hdl.error;\r\nif (ret)\r\ngoto cleanup;\r\nv4l2_ctrl_handler_setup(&priv->hdl);\r\nret = ml86v7667_init(priv);\r\nif (ret)\r\ngoto cleanup;\r\nv4l_info(client, "chip found @ 0x%02x (%s)\n",\r\nclient->addr, client->adapter->name);\r\nreturn 0;\r\ncleanup:\r\nv4l2_ctrl_handler_free(&priv->hdl);\r\nv4l2_device_unregister_subdev(&priv->sd);\r\nv4l_err(client, "failed to probe @ 0x%02x (%s)\n",\r\nclient->addr, client->adapter->name);\r\nreturn ret;\r\n}\r\nstatic int ml86v7667_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct ml86v7667_priv *priv = to_ml86v7667(sd);\r\nv4l2_ctrl_handler_free(&priv->hdl);\r\nv4l2_device_unregister_subdev(&priv->sd);\r\nreturn 0;\r\n}
