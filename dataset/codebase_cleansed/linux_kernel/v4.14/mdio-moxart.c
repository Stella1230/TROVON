static int moxart_mdio_read(struct mii_bus *bus, int mii_id, int regnum)\r\n{\r\nstruct moxart_mdio_data *data = bus->priv;\r\nu32 ctrl = 0;\r\nunsigned int count = 5;\r\ndev_dbg(&bus->dev, "%s\n", __func__);\r\nctrl |= MIIRD | ((mii_id << 16) & PHYAD_MASK) |\r\n((regnum << 21) & REGAD_MASK);\r\nwritel(ctrl, data->base + REG_PHY_CTRL);\r\ndo {\r\nctrl = readl(data->base + REG_PHY_CTRL);\r\nif (!(ctrl & MIIRD))\r\nreturn ctrl & MIIRDATA_MASK;\r\nmdelay(10);\r\ncount--;\r\n} while (count > 0);\r\ndev_dbg(&bus->dev, "%s timed out\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int moxart_mdio_write(struct mii_bus *bus, int mii_id,\r\nint regnum, u16 value)\r\n{\r\nstruct moxart_mdio_data *data = bus->priv;\r\nu32 ctrl = 0;\r\nunsigned int count = 5;\r\ndev_dbg(&bus->dev, "%s\n", __func__);\r\nctrl |= MIIWR | ((mii_id << 16) & PHYAD_MASK) |\r\n((regnum << 21) & REGAD_MASK);\r\nvalue &= MIIWDATA_MASK;\r\nwritel(value, data->base + REG_PHY_WRITE_DATA);\r\nwritel(ctrl, data->base + REG_PHY_CTRL);\r\ndo {\r\nctrl = readl(data->base + REG_PHY_CTRL);\r\nif (!(ctrl & MIIWR))\r\nreturn 0;\r\nmdelay(10);\r\ncount--;\r\n} while (count > 0);\r\ndev_dbg(&bus->dev, "%s timed out\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int moxart_mdio_reset(struct mii_bus *bus)\r\n{\r\nint data, i;\r\nfor (i = 0; i < PHY_MAX_ADDR; i++) {\r\ndata = moxart_mdio_read(bus, i, MII_BMCR);\r\nif (data < 0)\r\ncontinue;\r\ndata |= BMCR_RESET;\r\nif (moxart_mdio_write(bus, i, MII_BMCR, data) < 0)\r\ncontinue;\r\n}\r\nreturn 0;\r\n}\r\nstatic int moxart_mdio_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct mii_bus *bus;\r\nstruct moxart_mdio_data *data;\r\nstruct resource *res;\r\nint ret, i;\r\nbus = mdiobus_alloc_size(sizeof(*data));\r\nif (!bus)\r\nreturn -ENOMEM;\r\nbus->name = "MOXA ART Ethernet MII";\r\nbus->read = &moxart_mdio_read;\r\nbus->write = &moxart_mdio_write;\r\nbus->reset = &moxart_mdio_reset;\r\nsnprintf(bus->id, MII_BUS_ID_SIZE, "%s-%d-mii", pdev->name, pdev->id);\r\nbus->parent = &pdev->dev;\r\nfor (i = 0; i < PHY_MAX_ADDR; i++)\r\nbus->irq[i] = PHY_IGNORE_INTERRUPT;\r\ndata = bus->priv;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndata->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(data->base)) {\r\nret = PTR_ERR(data->base);\r\ngoto err_out_free_mdiobus;\r\n}\r\nret = of_mdiobus_register(bus, np);\r\nif (ret < 0)\r\ngoto err_out_free_mdiobus;\r\nplatform_set_drvdata(pdev, bus);\r\nreturn 0;\r\nerr_out_free_mdiobus:\r\nmdiobus_free(bus);\r\nreturn ret;\r\n}\r\nstatic int moxart_mdio_remove(struct platform_device *pdev)\r\n{\r\nstruct mii_bus *bus = platform_get_drvdata(pdev);\r\nmdiobus_unregister(bus);\r\nmdiobus_free(bus);\r\nreturn 0;\r\n}
