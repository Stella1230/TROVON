static int gdsc_is_enabled(struct gdsc *sc, unsigned int reg)\r\n{\r\nu32 val;\r\nint ret;\r\nret = regmap_read(sc->regmap, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn !!(val & PWR_ON_MASK);\r\n}\r\nstatic int gdsc_hwctrl(struct gdsc *sc, bool en)\r\n{\r\nu32 val = en ? HW_CONTROL_MASK : 0;\r\nreturn regmap_update_bits(sc->regmap, sc->gdscr, HW_CONTROL_MASK, val);\r\n}\r\nstatic int gdsc_poll_status(struct gdsc *sc, unsigned int reg, bool en)\r\n{\r\nktime_t start;\r\nstart = ktime_get();\r\ndo {\r\nif (gdsc_is_enabled(sc, reg) == en)\r\nreturn 0;\r\n} while (ktime_us_delta(ktime_get(), start) < TIMEOUT_US);\r\nif (gdsc_is_enabled(sc, reg) == en)\r\nreturn 0;\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int gdsc_toggle_logic(struct gdsc *sc, bool en)\r\n{\r\nint ret;\r\nu32 val = en ? 0 : SW_COLLAPSE_MASK;\r\nunsigned int status_reg = sc->gdscr;\r\nret = regmap_update_bits(sc->regmap, sc->gdscr, SW_COLLAPSE_MASK, val);\r\nif (ret)\r\nreturn ret;\r\nif ((sc->flags & VOTABLE) && !en) {\r\nudelay(TIMEOUT_US);\r\nreturn 0;\r\n}\r\nif (sc->gds_hw_ctrl) {\r\nstatus_reg = sc->gds_hw_ctrl;\r\nudelay(1);\r\n}\r\nreturn gdsc_poll_status(sc, status_reg, en);\r\n}\r\nstatic inline int gdsc_deassert_reset(struct gdsc *sc)\r\n{\r\nint i;\r\nfor (i = 0; i < sc->reset_count; i++)\r\nsc->rcdev->ops->deassert(sc->rcdev, sc->resets[i]);\r\nreturn 0;\r\n}\r\nstatic inline int gdsc_assert_reset(struct gdsc *sc)\r\n{\r\nint i;\r\nfor (i = 0; i < sc->reset_count; i++)\r\nsc->rcdev->ops->assert(sc->rcdev, sc->resets[i]);\r\nreturn 0;\r\n}\r\nstatic inline void gdsc_force_mem_on(struct gdsc *sc)\r\n{\r\nint i;\r\nu32 mask = RETAIN_MEM | RETAIN_PERIPH;\r\nfor (i = 0; i < sc->cxc_count; i++)\r\nregmap_update_bits(sc->regmap, sc->cxcs[i], mask, mask);\r\n}\r\nstatic inline void gdsc_clear_mem_on(struct gdsc *sc)\r\n{\r\nint i;\r\nu32 mask = RETAIN_MEM | RETAIN_PERIPH;\r\nfor (i = 0; i < sc->cxc_count; i++)\r\nregmap_update_bits(sc->regmap, sc->cxcs[i], mask, 0);\r\n}\r\nstatic inline void gdsc_deassert_clamp_io(struct gdsc *sc)\r\n{\r\nregmap_update_bits(sc->regmap, sc->clamp_io_ctrl,\r\nGMEM_CLAMP_IO_MASK, 0);\r\n}\r\nstatic inline void gdsc_assert_clamp_io(struct gdsc *sc)\r\n{\r\nregmap_update_bits(sc->regmap, sc->clamp_io_ctrl,\r\nGMEM_CLAMP_IO_MASK, 1);\r\n}\r\nstatic int gdsc_enable(struct generic_pm_domain *domain)\r\n{\r\nstruct gdsc *sc = domain_to_gdsc(domain);\r\nint ret;\r\nif (sc->pwrsts == PWRSTS_ON)\r\nreturn gdsc_deassert_reset(sc);\r\nif (sc->flags & CLAMP_IO)\r\ngdsc_deassert_clamp_io(sc);\r\nret = gdsc_toggle_logic(sc, true);\r\nif (ret)\r\nreturn ret;\r\nif (sc->pwrsts & PWRSTS_OFF)\r\ngdsc_force_mem_on(sc);\r\nudelay(1);\r\nif (sc->flags & HW_CTRL) {\r\nret = gdsc_hwctrl(sc, true);\r\nif (ret)\r\nreturn ret;\r\nudelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gdsc_disable(struct generic_pm_domain *domain)\r\n{\r\nstruct gdsc *sc = domain_to_gdsc(domain);\r\nint ret;\r\nif (sc->pwrsts == PWRSTS_ON)\r\nreturn gdsc_assert_reset(sc);\r\nif (sc->flags & HW_CTRL) {\r\nunsigned int reg;\r\nret = gdsc_hwctrl(sc, false);\r\nif (ret < 0)\r\nreturn ret;\r\nudelay(1);\r\nreg = sc->gds_hw_ctrl ? sc->gds_hw_ctrl : sc->gdscr;\r\nret = gdsc_poll_status(sc, reg, true);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (sc->pwrsts & PWRSTS_OFF)\r\ngdsc_clear_mem_on(sc);\r\nret = gdsc_toggle_logic(sc, false);\r\nif (ret)\r\nreturn ret;\r\nif (sc->flags & CLAMP_IO)\r\ngdsc_assert_clamp_io(sc);\r\nreturn 0;\r\n}\r\nstatic int gdsc_init(struct gdsc *sc)\r\n{\r\nu32 mask, val;\r\nint on, ret;\r\nunsigned int reg;\r\nmask = HW_CONTROL_MASK | SW_OVERRIDE_MASK |\r\nEN_REST_WAIT_MASK | EN_FEW_WAIT_MASK | CLK_DIS_WAIT_MASK;\r\nval = EN_REST_WAIT_VAL | EN_FEW_WAIT_VAL | CLK_DIS_WAIT_VAL;\r\nret = regmap_update_bits(sc->regmap, sc->gdscr, mask, val);\r\nif (ret)\r\nreturn ret;\r\nif (sc->pwrsts == PWRSTS_ON) {\r\nret = gdsc_toggle_logic(sc, true);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreg = sc->gds_hw_ctrl ? sc->gds_hw_ctrl : sc->gdscr;\r\non = gdsc_is_enabled(sc, reg);\r\nif (on < 0)\r\nreturn on;\r\nif ((sc->flags & VOTABLE) && on)\r\ngdsc_enable(&sc->pd);\r\nif (on || (sc->pwrsts & PWRSTS_RET))\r\ngdsc_force_mem_on(sc);\r\nelse\r\ngdsc_clear_mem_on(sc);\r\nsc->pd.power_off = gdsc_disable;\r\nsc->pd.power_on = gdsc_enable;\r\npm_genpd_init(&sc->pd, NULL, !on);\r\nreturn 0;\r\n}\r\nint gdsc_register(struct gdsc_desc *desc,\r\nstruct reset_controller_dev *rcdev, struct regmap *regmap)\r\n{\r\nint i, ret;\r\nstruct genpd_onecell_data *data;\r\nstruct device *dev = desc->dev;\r\nstruct gdsc **scs = desc->scs;\r\nsize_t num = desc->num;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->domains = devm_kcalloc(dev, num, sizeof(*data->domains),\r\nGFP_KERNEL);\r\nif (!data->domains)\r\nreturn -ENOMEM;\r\ndata->num_domains = num;\r\nfor (i = 0; i < num; i++) {\r\nif (!scs[i])\r\ncontinue;\r\nscs[i]->regmap = regmap;\r\nscs[i]->rcdev = rcdev;\r\nret = gdsc_init(scs[i]);\r\nif (ret)\r\nreturn ret;\r\ndata->domains[i] = &scs[i]->pd;\r\n}\r\nfor (i = 0; i < num; i++) {\r\nif (!scs[i])\r\ncontinue;\r\nif (scs[i]->parent)\r\npm_genpd_add_subdomain(scs[i]->parent, &scs[i]->pd);\r\n}\r\nreturn of_genpd_add_provider_onecell(dev->of_node, data);\r\n}\r\nvoid gdsc_unregister(struct gdsc_desc *desc)\r\n{\r\nint i;\r\nstruct device *dev = desc->dev;\r\nstruct gdsc **scs = desc->scs;\r\nsize_t num = desc->num;\r\nfor (i = 0; i < num; i++) {\r\nif (!scs[i])\r\ncontinue;\r\nif (scs[i]->parent)\r\npm_genpd_remove_subdomain(scs[i]->parent, &scs[i]->pd);\r\n}\r\nof_genpd_del_provider(dev->of_node);\r\n}
