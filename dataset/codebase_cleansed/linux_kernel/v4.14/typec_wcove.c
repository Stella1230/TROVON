static int wcove_typec_func(struct wcove_typec *wcove,\r\nenum wcove_typec_func func, int param)\r\n{\r\nunion acpi_object *obj;\r\nunion acpi_object tmp;\r\nunion acpi_object argv4 = ACPI_INIT_DSM_ARGV4(1, &tmp);\r\ntmp.type = ACPI_TYPE_INTEGER;\r\ntmp.integer.value = param;\r\nobj = acpi_evaluate_dsm(ACPI_HANDLE(wcove->dev), &guid, 1, func,\r\n&argv4);\r\nif (!obj) {\r\ndev_err(wcove->dev, "%s: failed to evaluate _DSM\n", __func__);\r\nreturn -EIO;\r\n}\r\nACPI_FREE(obj);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t wcove_typec_irq(int irq, void *data)\r\n{\r\nenum typec_role role = TYPEC_SINK;\r\nstruct typec_partner_desc partner;\r\nstruct wcove_typec *wcove = data;\r\nunsigned int cc1_ctrl;\r\nunsigned int cc2_ctrl;\r\nunsigned int cc_irq1;\r\nunsigned int cc_irq2;\r\nunsigned int status1;\r\nunsigned int status2;\r\nint ret;\r\nmutex_lock(&wcove->lock);\r\nret = regmap_read(wcove->regmap, USBC_IRQ1, &cc_irq1);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read(wcove->regmap, USBC_IRQ2, &cc_irq2);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read(wcove->regmap, USBC_STATUS1, &status1);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read(wcove->regmap, USBC_STATUS2, &status2);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read(wcove->regmap, USBC_CC1_CTRL, &cc1_ctrl);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read(wcove->regmap, USBC_CC2_CTRL, &cc2_ctrl);\r\nif (ret)\r\ngoto err;\r\nif (cc_irq1) {\r\nif (cc_irq1 & USBC_IRQ1_OVERTEMP)\r\ndev_err(wcove->dev, "VCONN Switch Over Temperature!\n");\r\nif (cc_irq1 & USBC_IRQ1_SHORT)\r\ndev_err(wcove->dev, "VCONN Switch Short Circuit!\n");\r\nret = regmap_write(wcove->regmap, USBC_IRQ1, cc_irq1);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (cc_irq2) {\r\nret = regmap_write(wcove->regmap, USBC_IRQ2, cc_irq2);\r\nif (ret)\r\ngoto err;\r\nif (cc_irq2 & ~USBC_IRQ2_CC_CHANGE) {\r\ndev_WARN(wcove->dev, "USB PD handling missing\n");\r\ngoto err;\r\n}\r\n}\r\nif (status1 & USBC_STATUS1_DET_ONGOING)\r\ngoto out;\r\nif (USBC_STATUS1_RSLT(status1) == USBC_RSLT_NOTHING) {\r\nif (wcove->partner) {\r\ntypec_unregister_partner(wcove->partner);\r\nwcove->partner = NULL;\r\n}\r\nwcove_typec_func(wcove, WCOVE_FUNC_ORIENTATION,\r\nWCOVE_ORIENTATION_NORMAL);\r\nwcove_typec_func(wcove, WCOVE_FUNC_ROLE, WCOVE_ROLE_HOST);\r\ntypec_set_data_role(wcove->port, TYPEC_DEVICE);\r\ntypec_set_pwr_role(wcove->port, TYPEC_SINK);\r\ntypec_set_pwr_opmode(wcove->port, TYPEC_PWR_MODE_USB);\r\ngoto out;\r\n}\r\nif (wcove->partner)\r\ngoto out;\r\nswitch (USBC_STATUS1_ORIENT(status1)) {\r\ncase USBC_ORIENT_NORMAL:\r\nwcove_typec_func(wcove, WCOVE_FUNC_ORIENTATION,\r\nWCOVE_ORIENTATION_NORMAL);\r\nbreak;\r\ncase USBC_ORIENT_REVERSE:\r\nwcove_typec_func(wcove, WCOVE_FUNC_ORIENTATION,\r\nWCOVE_ORIENTATION_REVERSE);\r\ndefault:\r\nbreak;\r\n}\r\nmemset(&partner, 0, sizeof(partner));\r\nswitch (USBC_STATUS1_RSLT(status1)) {\r\ncase USBC_RSLT_SRC_DEFAULT:\r\ntypec_set_pwr_opmode(wcove->port, TYPEC_PWR_MODE_USB);\r\nbreak;\r\ncase USBC_RSLT_SRC_1_5A:\r\ntypec_set_pwr_opmode(wcove->port, TYPEC_PWR_MODE_1_5A);\r\nbreak;\r\ncase USBC_RSLT_SRC_3_0A:\r\ntypec_set_pwr_opmode(wcove->port, TYPEC_PWR_MODE_3_0A);\r\nbreak;\r\ncase USBC_RSLT_SNK:\r\nrole = TYPEC_SOURCE;\r\nbreak;\r\ncase USBC_RSLT_DEBUG_ACC:\r\npartner.accessory = TYPEC_ACCESSORY_DEBUG;\r\nbreak;\r\ncase USBC_RSLT_AUDIO_ACC:\r\npartner.accessory = TYPEC_ACCESSORY_AUDIO;\r\nbreak;\r\ndefault:\r\ndev_WARN(wcove->dev, "%s Undefined result\n", __func__);\r\ngoto err;\r\n}\r\nif (role == TYPEC_SINK) {\r\nwcove_typec_func(wcove, WCOVE_FUNC_ROLE, WCOVE_ROLE_DEVICE);\r\ntypec_set_data_role(wcove->port, TYPEC_DEVICE);\r\ntypec_set_pwr_role(wcove->port, TYPEC_SINK);\r\n} else {\r\nwcove_typec_func(wcove, WCOVE_FUNC_ROLE, WCOVE_ROLE_HOST);\r\ntypec_set_pwr_role(wcove->port, TYPEC_SOURCE);\r\ntypec_set_data_role(wcove->port, TYPEC_HOST);\r\n}\r\nwcove->partner = typec_register_partner(wcove->port, &partner);\r\nif (!wcove->partner)\r\ndev_err(wcove->dev, "failed register partner\n");\r\nout:\r\nif ((cc1_ctrl & USBC_CC_CTRL_VCONN_EN) ||\r\n(cc2_ctrl & USBC_CC_CTRL_VCONN_EN))\r\nwcove_typec_func(wcove, WCOVE_FUNC_DRIVE_VCONN, true);\r\nelse\r\nwcove_typec_func(wcove, WCOVE_FUNC_DRIVE_VCONN, false);\r\nwcove_typec_func(wcove, WCOVE_FUNC_DRIVE_VBUS,\r\n!!(status2 & USBC_STATUS2_VBUS_REQ));\r\nerr:\r\nregmap_write(wcove->regmap, WCOVE_CHGRIRQ0, BIT(5));\r\nmutex_unlock(&wcove->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wcove_typec_probe(struct platform_device *pdev)\r\n{\r\nstruct intel_soc_pmic *pmic = dev_get_drvdata(pdev->dev.parent);\r\nstruct wcove_typec *wcove;\r\nunsigned int val;\r\nint ret;\r\nwcove = devm_kzalloc(&pdev->dev, sizeof(*wcove), GFP_KERNEL);\r\nif (!wcove)\r\nreturn -ENOMEM;\r\nmutex_init(&wcove->lock);\r\nwcove->dev = &pdev->dev;\r\nwcove->regmap = pmic->regmap;\r\nret = regmap_irq_get_virq(pmic->irq_chip_data_chgr,\r\nplatform_get_irq(pdev, 0));\r\nif (ret < 0)\r\nreturn ret;\r\nret = devm_request_threaded_irq(&pdev->dev, ret, NULL,\r\nwcove_typec_irq, IRQF_ONESHOT,\r\n"wcove_typec", wcove);\r\nif (ret)\r\nreturn ret;\r\nif (!acpi_check_dsm(ACPI_HANDLE(&pdev->dev), &guid, 0, 0x1f)) {\r\ndev_err(&pdev->dev, "Missing _DSM functions\n");\r\nreturn -ENODEV;\r\n}\r\nwcove->cap.type = TYPEC_PORT_DRP;\r\nwcove->cap.revision = USB_TYPEC_REV_1_1;\r\nwcove->cap.prefer_role = TYPEC_NO_PREFERRED_ROLE;\r\nregmap_read(wcove->regmap, USBC_CONTROL3, &val);\r\nregmap_write(wcove->regmap, USBC_CONTROL3, val | USBC_CONTROL3_PD_DIS);\r\nregmap_read(wcove->regmap, USBC_CONTROL1, &val);\r\nregmap_write(wcove->regmap, USBC_CONTROL1, USBC_CONTROL1_MODE_DRP(val));\r\nwcove->port = typec_register_port(&pdev->dev, &wcove->cap);\r\nif (!wcove->port)\r\nreturn -ENODEV;\r\nregmap_read(wcove->regmap, USBC_IRQMASK1, &val);\r\nregmap_write(wcove->regmap, USBC_IRQMASK1, val & ~USBC_IRQMASK1_ALL);\r\nregmap_read(wcove->regmap, USBC_IRQMASK2, &val);\r\nregmap_write(wcove->regmap, USBC_IRQMASK2, val & ~USBC_IRQMASK2_ALL);\r\nplatform_set_drvdata(pdev, wcove);\r\nreturn 0;\r\n}\r\nstatic int wcove_typec_remove(struct platform_device *pdev)\r\n{\r\nstruct wcove_typec *wcove = platform_get_drvdata(pdev);\r\nunsigned int val;\r\nregmap_read(wcove->regmap, USBC_IRQMASK1, &val);\r\nregmap_write(wcove->regmap, USBC_IRQMASK1, val | USBC_IRQMASK1_ALL);\r\nregmap_read(wcove->regmap, USBC_IRQMASK2, &val);\r\nregmap_write(wcove->regmap, USBC_IRQMASK2, val | USBC_IRQMASK2_ALL);\r\ntypec_unregister_partner(wcove->partner);\r\ntypec_unregister_port(wcove->port);\r\nreturn 0;\r\n}
