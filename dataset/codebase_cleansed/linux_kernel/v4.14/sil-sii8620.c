static int sii8620_clear_error(struct sii8620 *ctx)\r\n{\r\nint ret = ctx->error;\r\nctx->error = 0;\r\nreturn ret;\r\n}\r\nstatic void sii8620_read_buf(struct sii8620 *ctx, u16 addr, u8 *buf, int len)\r\n{\r\nstruct device *dev = ctx->dev;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nu8 data = addr;\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = sii8620_i2c_page[addr >> 8],\r\n.flags = client->flags,\r\n.len = 1,\r\n.buf = &data\r\n},\r\n{\r\n.addr = sii8620_i2c_page[addr >> 8],\r\n.flags = client->flags | I2C_M_RD,\r\n.len = len,\r\n.buf = buf\r\n},\r\n};\r\nint ret;\r\nif (ctx->error)\r\nreturn;\r\nret = i2c_transfer(client->adapter, msg, 2);\r\ndev_dbg(dev, "read at %04x: %*ph, %d\n", addr, len, buf, ret);\r\nif (ret != 2) {\r\ndev_err(dev, "Read at %#06x of %d bytes failed with code %d.\n",\r\naddr, len, ret);\r\nctx->error = ret < 0 ? ret : -EIO;\r\n}\r\n}\r\nstatic u8 sii8620_readb(struct sii8620 *ctx, u16 addr)\r\n{\r\nu8 ret;\r\nsii8620_read_buf(ctx, addr, &ret, 1);\r\nreturn ret;\r\n}\r\nstatic void sii8620_write_buf(struct sii8620 *ctx, u16 addr, const u8 *buf,\r\nint len)\r\n{\r\nstruct device *dev = ctx->dev;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nu8 data[2];\r\nstruct i2c_msg msg = {\r\n.addr = sii8620_i2c_page[addr >> 8],\r\n.flags = client->flags,\r\n.len = len + 1,\r\n};\r\nint ret;\r\nif (ctx->error)\r\nreturn;\r\nif (len > 1) {\r\nmsg.buf = kmalloc(len + 1, GFP_KERNEL);\r\nif (!msg.buf) {\r\nctx->error = -ENOMEM;\r\nreturn;\r\n}\r\nmemcpy(msg.buf + 1, buf, len);\r\n} else {\r\nmsg.buf = data;\r\nmsg.buf[1] = *buf;\r\n}\r\nmsg.buf[0] = addr;\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\ndev_dbg(dev, "write at %04x: %*ph, %d\n", addr, len, buf, ret);\r\nif (ret != 1) {\r\ndev_err(dev, "Write at %#06x of %*ph failed with code %d.\n",\r\naddr, len, buf, ret);\r\nctx->error = ret ?: -EIO;\r\n}\r\nif (len > 1)\r\nkfree(msg.buf);\r\n}\r\nstatic void __sii8620_write_seq(struct sii8620 *ctx, const u16 *seq, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i += 2)\r\nsii8620_write(ctx, seq[i], seq[i + 1]);\r\n}\r\nstatic void sii8620_setbits(struct sii8620 *ctx, u16 addr, u8 mask, u8 val)\r\n{\r\nval = (val & mask) | (sii8620_readb(ctx, addr) & ~mask);\r\nsii8620_write(ctx, addr, val);\r\n}\r\nstatic inline bool sii8620_is_mhl3(struct sii8620 *ctx)\r\n{\r\nreturn ctx->mode >= CM_MHL3;\r\n}\r\nstatic void sii8620_mt_cleanup(struct sii8620 *ctx)\r\n{\r\nstruct sii8620_mt_msg *msg, *n;\r\nlist_for_each_entry_safe(msg, n, &ctx->mt_queue, node) {\r\nlist_del(&msg->node);\r\nkfree(msg);\r\n}\r\nctx->mt_state = MT_STATE_READY;\r\n}\r\nstatic void sii8620_mt_work(struct sii8620 *ctx)\r\n{\r\nstruct sii8620_mt_msg *msg;\r\nif (ctx->error)\r\nreturn;\r\nif (ctx->mt_state == MT_STATE_BUSY || list_empty(&ctx->mt_queue))\r\nreturn;\r\nif (ctx->mt_state == MT_STATE_DONE) {\r\nctx->mt_state = MT_STATE_READY;\r\nmsg = list_first_entry(&ctx->mt_queue, struct sii8620_mt_msg,\r\nnode);\r\nlist_del(&msg->node);\r\nif (msg->recv)\r\nmsg->recv(ctx, msg);\r\nif (msg->continuation)\r\nmsg->continuation(ctx, msg->ret);\r\nkfree(msg);\r\n}\r\nif (ctx->mt_state != MT_STATE_READY || list_empty(&ctx->mt_queue))\r\nreturn;\r\nctx->mt_state = MT_STATE_BUSY;\r\nmsg = list_first_entry(&ctx->mt_queue, struct sii8620_mt_msg, node);\r\nif (msg->send)\r\nmsg->send(ctx, msg);\r\n}\r\nstatic void sii8620_enable_gen2_write_burst(struct sii8620 *ctx)\r\n{\r\nu8 ctrl = BIT_MDT_RCV_CTRL_MDT_RCV_EN;\r\nif (ctx->gen2_write_burst)\r\nreturn;\r\nif (ctx->mode >= CM_MHL1)\r\nctrl |= BIT_MDT_RCV_CTRL_MDT_DELAY_RCV_EN;\r\nsii8620_write_seq(ctx,\r\nREG_MDT_RCV_TIMEOUT, 100,\r\nREG_MDT_RCV_CTRL, ctrl\r\n);\r\nctx->gen2_write_burst = 1;\r\n}\r\nstatic void sii8620_disable_gen2_write_burst(struct sii8620 *ctx)\r\n{\r\nif (!ctx->gen2_write_burst)\r\nreturn;\r\nsii8620_write_seq_static(ctx,\r\nREG_MDT_XMIT_CTRL, 0,\r\nREG_MDT_RCV_CTRL, 0\r\n);\r\nctx->gen2_write_burst = 0;\r\n}\r\nstatic void sii8620_start_gen2_write_burst(struct sii8620 *ctx)\r\n{\r\nsii8620_write_seq_static(ctx,\r\nREG_MDT_INT_1_MASK, BIT_MDT_RCV_TIMEOUT\r\n| BIT_MDT_RCV_SM_ABORT_PKT_RCVD | BIT_MDT_RCV_SM_ERROR\r\n| BIT_MDT_XMIT_TIMEOUT | BIT_MDT_XMIT_SM_ABORT_PKT_RCVD\r\n| BIT_MDT_XMIT_SM_ERROR,\r\nREG_MDT_INT_0_MASK, BIT_MDT_XFIFO_EMPTY\r\n| BIT_MDT_IDLE_AFTER_HAWB_DISABLE\r\n| BIT_MDT_RFIFO_DATA_RDY\r\n);\r\nsii8620_enable_gen2_write_burst(ctx);\r\n}\r\nstatic void sii8620_mt_msc_cmd_send(struct sii8620 *ctx,\r\nstruct sii8620_mt_msg *msg)\r\n{\r\nif (msg->reg[0] == MHL_SET_INT &&\r\nmsg->reg[1] == MHL_INT_REG(RCHANGE) &&\r\nmsg->reg[2] == MHL_INT_RC_FEAT_REQ)\r\nsii8620_enable_gen2_write_burst(ctx);\r\nelse\r\nsii8620_disable_gen2_write_burst(ctx);\r\nswitch (msg->reg[0]) {\r\ncase MHL_WRITE_STAT:\r\ncase MHL_SET_INT:\r\nsii8620_write_buf(ctx, REG_MSC_CMD_OR_OFFSET, msg->reg + 1, 2);\r\nsii8620_write(ctx, REG_MSC_COMMAND_START,\r\nBIT_MSC_COMMAND_START_WRITE_STAT);\r\nbreak;\r\ncase MHL_MSC_MSG:\r\nsii8620_write_buf(ctx, REG_MSC_CMD_OR_OFFSET, msg->reg, 3);\r\nsii8620_write(ctx, REG_MSC_COMMAND_START,\r\nBIT_MSC_COMMAND_START_MSC_MSG);\r\nbreak;\r\ncase MHL_READ_DEVCAP_REG:\r\ncase MHL_READ_XDEVCAP_REG:\r\nsii8620_write(ctx, REG_MSC_CMD_OR_OFFSET, msg->reg[1]);\r\nsii8620_write(ctx, REG_MSC_COMMAND_START,\r\nBIT_MSC_COMMAND_START_READ_DEVCAP);\r\nbreak;\r\ndefault:\r\ndev_err(ctx->dev, "%s: command %#x not supported\n", __func__,\r\nmsg->reg[0]);\r\n}\r\n}\r\nstatic struct sii8620_mt_msg *sii8620_mt_msg_new(struct sii8620 *ctx)\r\n{\r\nstruct sii8620_mt_msg *msg = kzalloc(sizeof(*msg), GFP_KERNEL);\r\nif (!msg)\r\nctx->error = -ENOMEM;\r\nelse\r\nlist_add_tail(&msg->node, &ctx->mt_queue);\r\nreturn msg;\r\n}\r\nstatic void sii8620_mt_set_cont(struct sii8620 *ctx, sii8620_cb cont)\r\n{\r\nstruct sii8620_mt_msg *msg;\r\nif (ctx->error)\r\nreturn;\r\nif (list_empty(&ctx->mt_queue)) {\r\nctx->error = -EINVAL;\r\nreturn;\r\n}\r\nmsg = list_last_entry(&ctx->mt_queue, struct sii8620_mt_msg, node);\r\nmsg->continuation = cont;\r\n}\r\nstatic void sii8620_mt_msc_cmd(struct sii8620 *ctx, u8 cmd, u8 arg1, u8 arg2)\r\n{\r\nstruct sii8620_mt_msg *msg = sii8620_mt_msg_new(ctx);\r\nif (!msg)\r\nreturn;\r\nmsg->reg[0] = cmd;\r\nmsg->reg[1] = arg1;\r\nmsg->reg[2] = arg2;\r\nmsg->send = sii8620_mt_msc_cmd_send;\r\n}\r\nstatic void sii8620_mt_write_stat(struct sii8620 *ctx, u8 reg, u8 val)\r\n{\r\nsii8620_mt_msc_cmd(ctx, MHL_WRITE_STAT, reg, val);\r\n}\r\nstatic inline void sii8620_mt_set_int(struct sii8620 *ctx, u8 irq, u8 mask)\r\n{\r\nsii8620_mt_msc_cmd(ctx, MHL_SET_INT, irq, mask);\r\n}\r\nstatic void sii8620_mt_msc_msg(struct sii8620 *ctx, u8 cmd, u8 data)\r\n{\r\nsii8620_mt_msc_cmd(ctx, MHL_MSC_MSG, cmd, data);\r\n}\r\nstatic void sii8620_mt_rap(struct sii8620 *ctx, u8 code)\r\n{\r\nsii8620_mt_msc_msg(ctx, MHL_MSC_MSG_RAP, code);\r\n}\r\nstatic void sii8620_mt_read_devcap_send(struct sii8620 *ctx,\r\nstruct sii8620_mt_msg *msg)\r\n{\r\nu8 ctrl = BIT_EDID_CTRL_DEVCAP_SELECT_DEVCAP\r\n| BIT_EDID_CTRL_EDID_FIFO_ADDR_AUTO\r\n| BIT_EDID_CTRL_EDID_MODE_EN;\r\nif (msg->reg[0] == MHL_READ_XDEVCAP)\r\nctrl |= BIT_EDID_CTRL_XDEVCAP_EN;\r\nsii8620_write_seq(ctx,\r\nREG_INTR9_MASK, BIT_INTR9_DEVCAP_DONE,\r\nREG_EDID_CTRL, ctrl,\r\nREG_TPI_CBUS_START, BIT_TPI_CBUS_START_GET_DEVCAP_START\r\n);\r\n}\r\nstatic void sii8620_update_array(u8 *dst, u8 *src, int count)\r\n{\r\nwhile (--count >= 0) {\r\n*src ^= *dst;\r\n*dst++ ^= *src++;\r\n}\r\n}\r\nstatic void sii8620_sink_detected(struct sii8620 *ctx, int ret)\r\n{\r\nstatic const char * const sink_str[] = {\r\n[SINK_NONE] = "NONE",\r\n[SINK_HDMI] = "HDMI",\r\n[SINK_DVI] = "DVI"\r\n};\r\nchar sink_name[20];\r\nstruct device *dev = ctx->dev;\r\nif (ret < 0)\r\nreturn;\r\nsii8620_fetch_edid(ctx);\r\nif (!ctx->edid) {\r\ndev_err(ctx->dev, "Cannot fetch EDID\n");\r\nsii8620_mhl_disconnected(ctx);\r\nreturn;\r\n}\r\nif (drm_detect_hdmi_monitor(ctx->edid))\r\nctx->sink_type = SINK_HDMI;\r\nelse\r\nctx->sink_type = SINK_DVI;\r\ndrm_edid_get_monitor_name(ctx->edid, sink_name, ARRAY_SIZE(sink_name));\r\ndev_info(dev, "detected sink(type: %s): %s\n",\r\nsink_str[ctx->sink_type], sink_name);\r\n}\r\nstatic void sii8620_hsic_init(struct sii8620 *ctx)\r\n{\r\nif (!sii8620_is_mhl3(ctx))\r\nreturn;\r\nsii8620_write(ctx, REG_FCGC,\r\nBIT_FCGC_HSIC_HOSTMODE | BIT_FCGC_HSIC_ENABLE);\r\nsii8620_setbits(ctx, REG_HRXCTRL3,\r\nBIT_HRXCTRL3_HRX_STAY_RESET | BIT_HRXCTRL3_STATUS_EN, ~0);\r\nsii8620_setbits(ctx, REG_TTXNUMB, MSK_TTXNUMB_TTX_NUMBPS, 4);\r\nsii8620_setbits(ctx, REG_TRXCTRL, BIT_TRXCTRL_TRX_FROM_SE_COC, ~0);\r\nsii8620_setbits(ctx, REG_HTXCTRL, BIT_HTXCTRL_HTX_DRVCONN1, 0);\r\nsii8620_setbits(ctx, REG_KEEPER, MSK_KEEPER_MODE, VAL_KEEPER_MODE_HOST);\r\nsii8620_write_seq_static(ctx,\r\nREG_TDMLLCTL, 0,\r\nREG_UTSRST, BIT_UTSRST_HRX_SRST | BIT_UTSRST_HTX_SRST |\r\nBIT_UTSRST_KEEPER_SRST | BIT_UTSRST_FC_SRST,\r\nREG_UTSRST, BIT_UTSRST_HRX_SRST | BIT_UTSRST_HTX_SRST,\r\nREG_HRXINTL, 0xff,\r\nREG_HRXINTH, 0xff,\r\nREG_TTXINTL, 0xff,\r\nREG_TTXINTH, 0xff,\r\nREG_TRXINTL, 0xff,\r\nREG_TRXINTH, 0xff,\r\nREG_HTXINTL, 0xff,\r\nREG_HTXINTH, 0xff,\r\nREG_FCINTR0, 0xff,\r\nREG_FCINTR1, 0xff,\r\nREG_FCINTR2, 0xff,\r\nREG_FCINTR3, 0xff,\r\nREG_FCINTR4, 0xff,\r\nREG_FCINTR5, 0xff,\r\nREG_FCINTR6, 0xff,\r\nREG_FCINTR7, 0xff\r\n);\r\n}\r\nstatic void sii8620_edid_read(struct sii8620 *ctx, int ret)\r\n{\r\nif (ret < 0)\r\nreturn;\r\nsii8620_set_upstream_edid(ctx);\r\nsii8620_hsic_init(ctx);\r\nsii8620_enable_hpd(ctx);\r\n}\r\nstatic void sii8620_mr_devcap(struct sii8620 *ctx)\r\n{\r\nu8 dcap[MHL_DCAP_SIZE];\r\nstruct device *dev = ctx->dev;\r\nsii8620_read_buf(ctx, REG_EDID_FIFO_RD_DATA, dcap, MHL_DCAP_SIZE);\r\nif (ctx->error < 0)\r\nreturn;\r\ndev_info(dev, "detected dongle MHL %d.%d, ChipID %02x%02x:%02x%02x\n",\r\ndcap[MHL_DCAP_MHL_VERSION] / 16,\r\ndcap[MHL_DCAP_MHL_VERSION] % 16,\r\ndcap[MHL_DCAP_ADOPTER_ID_H], dcap[MHL_DCAP_ADOPTER_ID_L],\r\ndcap[MHL_DCAP_DEVICE_ID_H], dcap[MHL_DCAP_DEVICE_ID_L]);\r\nsii8620_update_array(ctx->devcap, dcap, MHL_DCAP_SIZE);\r\n}\r\nstatic void sii8620_mr_xdevcap(struct sii8620 *ctx)\r\n{\r\nsii8620_read_buf(ctx, REG_EDID_FIFO_RD_DATA, ctx->xdevcap,\r\nMHL_XDC_SIZE);\r\n}\r\nstatic void sii8620_mt_read_devcap_recv(struct sii8620 *ctx,\r\nstruct sii8620_mt_msg *msg)\r\n{\r\nu8 ctrl = BIT_EDID_CTRL_DEVCAP_SELECT_DEVCAP\r\n| BIT_EDID_CTRL_EDID_FIFO_ADDR_AUTO\r\n| BIT_EDID_CTRL_EDID_MODE_EN;\r\nif (msg->reg[0] == MHL_READ_XDEVCAP)\r\nctrl |= BIT_EDID_CTRL_XDEVCAP_EN;\r\nsii8620_write_seq(ctx,\r\nREG_INTR9_MASK, BIT_INTR9_DEVCAP_DONE | BIT_INTR9_EDID_DONE\r\n| BIT_INTR9_EDID_ERROR,\r\nREG_EDID_CTRL, ctrl,\r\nREG_EDID_FIFO_ADDR, 0\r\n);\r\nif (msg->reg[0] == MHL_READ_XDEVCAP)\r\nsii8620_mr_xdevcap(ctx);\r\nelse\r\nsii8620_mr_devcap(ctx);\r\n}\r\nstatic void sii8620_mt_read_devcap(struct sii8620 *ctx, bool xdevcap)\r\n{\r\nstruct sii8620_mt_msg *msg = sii8620_mt_msg_new(ctx);\r\nif (!msg)\r\nreturn;\r\nmsg->reg[0] = xdevcap ? MHL_READ_XDEVCAP : MHL_READ_DEVCAP;\r\nmsg->send = sii8620_mt_read_devcap_send;\r\nmsg->recv = sii8620_mt_read_devcap_recv;\r\n}\r\nstatic void sii8620_mt_read_devcap_reg_recv(struct sii8620 *ctx,\r\nstruct sii8620_mt_msg *msg)\r\n{\r\nu8 reg = msg->reg[1] & 0x7f;\r\nif (msg->reg[1] & 0x80)\r\nctx->xdevcap[reg] = msg->ret;\r\nelse\r\nctx->devcap[reg] = msg->ret;\r\n}\r\nstatic void sii8620_mt_read_devcap_reg(struct sii8620 *ctx, u8 reg)\r\n{\r\nstruct sii8620_mt_msg *msg = sii8620_mt_msg_new(ctx);\r\nif (!msg)\r\nreturn;\r\nmsg->reg[0] = (reg & 0x80) ? MHL_READ_XDEVCAP_REG : MHL_READ_DEVCAP_REG;\r\nmsg->reg[1] = reg;\r\nmsg->send = sii8620_mt_msc_cmd_send;\r\nmsg->recv = sii8620_mt_read_devcap_reg_recv;\r\n}\r\nstatic inline void sii8620_mt_read_xdevcap_reg(struct sii8620 *ctx, u8 reg)\r\n{\r\nsii8620_mt_read_devcap_reg(ctx, reg | 0x80);\r\n}\r\nstatic void *sii8620_burst_get_tx_buf(struct sii8620 *ctx, int len)\r\n{\r\nu8 *buf = &ctx->burst.tx_buf[ctx->burst.tx_count];\r\nint size = len + 2;\r\nif (ctx->burst.tx_count + size > ARRAY_SIZE(ctx->burst.tx_buf)) {\r\ndev_err(ctx->dev, "TX-BLK buffer exhausted\n");\r\nctx->error = -EINVAL;\r\nreturn NULL;\r\n}\r\nctx->burst.tx_count += size;\r\nbuf[1] = len;\r\nreturn buf + 2;\r\n}\r\nstatic u8 *sii8620_burst_get_rx_buf(struct sii8620 *ctx, int len)\r\n{\r\nu8 *buf = &ctx->burst.rx_buf[ctx->burst.rx_count];\r\nint size = len + 1;\r\nif (ctx->burst.tx_count + size > ARRAY_SIZE(ctx->burst.tx_buf)) {\r\ndev_err(ctx->dev, "RX-BLK buffer exhausted\n");\r\nctx->error = -EINVAL;\r\nreturn NULL;\r\n}\r\nctx->burst.rx_count += size;\r\nbuf[0] = len;\r\nreturn buf + 1;\r\n}\r\nstatic void sii8620_burst_send(struct sii8620 *ctx)\r\n{\r\nint tx_left = ctx->burst.tx_count;\r\nu8 *d = ctx->burst.tx_buf;\r\nwhile (tx_left > 0) {\r\nint len = d[1] + 2;\r\nif (ctx->burst.r_count + len > ctx->burst.r_size)\r\nbreak;\r\nd[0] = min(ctx->burst.rx_ack, 255);\r\nctx->burst.rx_ack -= d[0];\r\nsii8620_write_buf(ctx, REG_EMSC_XMIT_WRITE_PORT, d, len);\r\nctx->burst.r_count += len;\r\ntx_left -= len;\r\nd += len;\r\n}\r\nctx->burst.tx_count = tx_left;\r\nwhile (ctx->burst.rx_ack > 0) {\r\nu8 b[2] = { min(ctx->burst.rx_ack, 255), 0 };\r\nif (ctx->burst.r_count + 2 > ctx->burst.r_size)\r\nbreak;\r\nctx->burst.rx_ack -= b[0];\r\nsii8620_write_buf(ctx, REG_EMSC_XMIT_WRITE_PORT, b, 2);\r\nctx->burst.r_count += 2;\r\n}\r\n}\r\nstatic void sii8620_burst_receive(struct sii8620 *ctx)\r\n{\r\nu8 buf[3], *d;\r\nint count;\r\nsii8620_read_buf(ctx, REG_EMSCRFIFOBCNTL, buf, 2);\r\ncount = get_unaligned_le16(buf);\r\nwhile (count > 0) {\r\nint len = min(count, 3);\r\nsii8620_read_buf(ctx, REG_EMSC_RCV_READ_PORT, buf, len);\r\ncount -= len;\r\nctx->burst.rx_ack += len - 1;\r\nctx->burst.r_count -= buf[1];\r\nif (ctx->burst.r_count < 0)\r\nctx->burst.r_count = 0;\r\nif (len < 3 || !buf[2])\r\ncontinue;\r\nlen = buf[2];\r\nd = sii8620_burst_get_rx_buf(ctx, len);\r\nif (!d)\r\ncontinue;\r\nsii8620_read_buf(ctx, REG_EMSC_RCV_READ_PORT, d, len);\r\ncount -= len;\r\nctx->burst.rx_ack += len;\r\n}\r\n}\r\nstatic void sii8620_burst_tx_rbuf_info(struct sii8620 *ctx, int size)\r\n{\r\nstruct mhl_burst_blk_rcv_buffer_info *d =\r\nsii8620_burst_get_tx_buf(ctx, sizeof(*d));\r\nif (!d)\r\nreturn;\r\nd->id = cpu_to_be16(MHL_BURST_ID_BLK_RCV_BUFFER_INFO);\r\nd->size = cpu_to_le16(size);\r\n}\r\nstatic u8 sii8620_checksum(void *ptr, int size)\r\n{\r\nu8 *d = ptr, sum = 0;\r\nwhile (size--)\r\nsum += *d++;\r\nreturn sum;\r\n}\r\nstatic void sii8620_mhl_burst_hdr_set(struct mhl3_burst_header *h,\r\nenum mhl_burst_id id)\r\n{\r\nh->id = cpu_to_be16(id);\r\nh->total_entries = 1;\r\nh->sequence_index = 1;\r\n}\r\nstatic void sii8620_burst_tx_bits_per_pixel_fmt(struct sii8620 *ctx, u8 fmt)\r\n{\r\nstruct mhl_burst_bits_per_pixel_fmt *d;\r\nconst int size = sizeof(*d) + sizeof(d->desc[0]);\r\nd = sii8620_burst_get_tx_buf(ctx, size);\r\nif (!d)\r\nreturn;\r\nsii8620_mhl_burst_hdr_set(&d->hdr, MHL_BURST_ID_BITS_PER_PIXEL_FMT);\r\nd->num_entries = 1;\r\nd->desc[0].stream_id = 0;\r\nd->desc[0].pixel_format = fmt;\r\nd->hdr.checksum -= sii8620_checksum(d, size);\r\n}\r\nstatic void sii8620_burst_rx_all(struct sii8620 *ctx)\r\n{\r\nu8 *d = ctx->burst.rx_buf;\r\nint count = ctx->burst.rx_count;\r\nwhile (count-- > 0) {\r\nint len = *d++;\r\nint id = get_unaligned_be16(&d[0]);\r\nswitch (id) {\r\ncase MHL_BURST_ID_BLK_RCV_BUFFER_INFO:\r\nctx->burst.r_size = get_unaligned_le16(&d[2]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncount -= len;\r\nd += len;\r\n}\r\nctx->burst.rx_count = 0;\r\n}\r\nstatic void sii8620_fetch_edid(struct sii8620 *ctx)\r\n{\r\nu8 lm_ddc, ddc_cmd, int3, cbus;\r\nint fetched, i;\r\nint edid_len = EDID_LENGTH;\r\nu8 *edid;\r\nsii8620_readb(ctx, REG_CBUS_STATUS);\r\nlm_ddc = sii8620_readb(ctx, REG_LM_DDC);\r\nddc_cmd = sii8620_readb(ctx, REG_DDC_CMD);\r\nsii8620_write_seq(ctx,\r\nREG_INTR9_MASK, 0,\r\nREG_EDID_CTRL, BIT_EDID_CTRL_EDID_FIFO_ADDR_AUTO,\r\nREG_HDCP2X_POLL_CS, 0x71,\r\nREG_HDCP2X_CTRL_0, BIT_HDCP2X_CTRL_0_HDCP2X_HDCPTX,\r\nREG_LM_DDC, lm_ddc | BIT_LM_DDC_SW_TPI_EN_DISABLED,\r\n);\r\nfor (i = 0; i < 256; ++i) {\r\nu8 ddc_stat = sii8620_readb(ctx, REG_DDC_STATUS);\r\nif (!(ddc_stat & BIT_DDC_STATUS_DDC_I2C_IN_PROG))\r\nbreak;\r\nsii8620_write(ctx, REG_DDC_STATUS,\r\nBIT_DDC_STATUS_DDC_FIFO_EMPTY);\r\n}\r\nsii8620_write(ctx, REG_DDC_ADDR, 0x50 << 1);\r\nedid = kmalloc(EDID_LENGTH, GFP_KERNEL);\r\nif (!edid) {\r\nctx->error = -ENOMEM;\r\nreturn;\r\n}\r\n#define FETCH_SIZE 16\r\nfor (fetched = 0; fetched < edid_len; fetched += FETCH_SIZE) {\r\nsii8620_readb(ctx, REG_DDC_STATUS);\r\nsii8620_write_seq(ctx,\r\nREG_DDC_CMD, ddc_cmd | VAL_DDC_CMD_DDC_CMD_ABORT,\r\nREG_DDC_CMD, ddc_cmd | VAL_DDC_CMD_DDC_CMD_CLEAR_FIFO,\r\nREG_DDC_STATUS, BIT_DDC_STATUS_DDC_FIFO_EMPTY\r\n);\r\nsii8620_write_seq(ctx,\r\nREG_DDC_SEGM, fetched >> 8,\r\nREG_DDC_OFFSET, fetched & 0xff,\r\nREG_DDC_DIN_CNT1, FETCH_SIZE,\r\nREG_DDC_DIN_CNT2, 0,\r\nREG_DDC_CMD, ddc_cmd | VAL_DDC_CMD_ENH_DDC_READ_NO_ACK\r\n);\r\ndo {\r\nint3 = sii8620_readb(ctx, REG_INTR3);\r\ncbus = sii8620_readb(ctx, REG_CBUS_STATUS);\r\nif (int3 & BIT_DDC_CMD_DONE)\r\nbreak;\r\nif (!(cbus & BIT_CBUS_STATUS_CBUS_CONNECTED)) {\r\nkfree(edid);\r\nedid = NULL;\r\ngoto end;\r\n}\r\n} while (1);\r\nsii8620_readb(ctx, REG_DDC_STATUS);\r\nwhile (sii8620_readb(ctx, REG_DDC_DOUT_CNT) < FETCH_SIZE)\r\nusleep_range(10, 20);\r\nsii8620_read_buf(ctx, REG_DDC_DATA, edid + fetched, FETCH_SIZE);\r\nif (fetched + FETCH_SIZE == EDID_LENGTH) {\r\nu8 ext = ((struct edid *)edid)->extensions;\r\nif (ext) {\r\nu8 *new_edid;\r\nedid_len += ext * EDID_LENGTH;\r\nnew_edid = krealloc(edid, edid_len, GFP_KERNEL);\r\nif (!new_edid) {\r\nkfree(edid);\r\nctx->error = -ENOMEM;\r\nreturn;\r\n}\r\nedid = new_edid;\r\n}\r\n}\r\n}\r\nsii8620_write_seq(ctx,\r\nREG_INTR3_MASK, BIT_DDC_CMD_DONE,\r\nREG_LM_DDC, lm_ddc\r\n);\r\nend:\r\nkfree(ctx->edid);\r\nctx->edid = (struct edid *)edid;\r\n}\r\nstatic void sii8620_set_upstream_edid(struct sii8620 *ctx)\r\n{\r\nsii8620_setbits(ctx, REG_DPD, BIT_DPD_PDNRX12 | BIT_DPD_PDIDCK_N\r\n| BIT_DPD_PD_MHL_CLK_N, 0xff);\r\nsii8620_write_seq_static(ctx,\r\nREG_RX_HDMI_CTRL3, 0x00,\r\nREG_PKT_FILTER_0, 0xFF,\r\nREG_PKT_FILTER_1, 0xFF,\r\nREG_ALICE0_BW_I2C, 0x06\r\n);\r\nsii8620_setbits(ctx, REG_RX_HDMI_CLR_BUFFER,\r\nBIT_RX_HDMI_CLR_BUFFER_VSI_CLR_EN, 0xff);\r\nsii8620_write_seq_static(ctx,\r\nREG_EDID_CTRL, BIT_EDID_CTRL_EDID_FIFO_ADDR_AUTO\r\n| BIT_EDID_CTRL_EDID_MODE_EN,\r\nREG_EDID_FIFO_ADDR, 0,\r\n);\r\nsii8620_write_buf(ctx, REG_EDID_FIFO_WR_DATA, (u8 *)ctx->edid,\r\n(ctx->edid->extensions + 1) * EDID_LENGTH);\r\nsii8620_write_seq_static(ctx,\r\nREG_EDID_CTRL, BIT_EDID_CTRL_EDID_PRIME_VALID\r\n| BIT_EDID_CTRL_EDID_FIFO_ADDR_AUTO\r\n| BIT_EDID_CTRL_EDID_MODE_EN,\r\nREG_INTR5_MASK, BIT_INTR_SCDT_CHANGE,\r\nREG_INTR9_MASK, 0\r\n);\r\n}\r\nstatic void sii8620_xtal_set_rate(struct sii8620 *ctx)\r\n{\r\nstatic const struct {\r\nunsigned int rate;\r\nu8 div;\r\nu8 tp1;\r\n} rates[] = {\r\n{ 19200, 0x04, 0x53 },\r\n{ 20000, 0x04, 0x62 },\r\n{ 24000, 0x05, 0x75 },\r\n{ 30000, 0x06, 0x92 },\r\n{ 38400, 0x0c, 0xbc },\r\n};\r\nunsigned long rate = clk_get_rate(ctx->clk_xtal) / 1000;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(rates) - 1; ++i)\r\nif (rate <= rates[i].rate)\r\nbreak;\r\nif (rate != rates[i].rate)\r\ndev_err(ctx->dev, "xtal clock rate(%lukHz) not supported, setting MHL for %ukHz.\n",\r\nrate, rates[i].rate);\r\nsii8620_write(ctx, REG_DIV_CTL_MAIN, rates[i].div);\r\nsii8620_write(ctx, REG_HDCP2X_TP1, rates[i].tp1);\r\n}\r\nstatic int sii8620_hw_on(struct sii8620 *ctx)\r\n{\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\r\nif (ret)\r\nreturn ret;\r\nusleep_range(10000, 20000);\r\nreturn clk_prepare_enable(ctx->clk_xtal);\r\n}\r\nstatic int sii8620_hw_off(struct sii8620 *ctx)\r\n{\r\nclk_disable_unprepare(ctx->clk_xtal);\r\ngpiod_set_value(ctx->gpio_reset, 1);\r\nreturn regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\r\n}\r\nstatic void sii8620_hw_reset(struct sii8620 *ctx)\r\n{\r\nusleep_range(10000, 20000);\r\ngpiod_set_value(ctx->gpio_reset, 0);\r\nusleep_range(5000, 20000);\r\ngpiod_set_value(ctx->gpio_reset, 1);\r\nusleep_range(10000, 20000);\r\ngpiod_set_value(ctx->gpio_reset, 0);\r\nmsleep(300);\r\n}\r\nstatic void sii8620_cbus_reset(struct sii8620 *ctx)\r\n{\r\nsii8620_write(ctx, REG_PWD_SRST, BIT_PWD_SRST_CBUS_RST\r\n| BIT_PWD_SRST_CBUS_RST_SW_EN);\r\nusleep_range(10000, 20000);\r\nsii8620_write(ctx, REG_PWD_SRST, BIT_PWD_SRST_CBUS_RST_SW_EN);\r\n}\r\nstatic void sii8620_set_auto_zone(struct sii8620 *ctx)\r\n{\r\nif (ctx->mode != CM_MHL1) {\r\nsii8620_write_seq_static(ctx,\r\nREG_TX_ZONE_CTL1, 0x0,\r\nREG_MHL_PLL_CTL0, VAL_MHL_PLL_CTL0_HDMI_CLK_RATIO_1X\r\n| BIT_MHL_PLL_CTL0_CRYSTAL_CLK_SEL\r\n| BIT_MHL_PLL_CTL0_ZONE_MASK_OE\r\n);\r\n} else {\r\nsii8620_write_seq_static(ctx,\r\nREG_TX_ZONE_CTL1, VAL_TX_ZONE_CTL1_TX_ZONE_CTRL_MODE,\r\nREG_MHL_PLL_CTL0, VAL_MHL_PLL_CTL0_HDMI_CLK_RATIO_1X\r\n| BIT_MHL_PLL_CTL0_ZONE_MASK_OE\r\n);\r\n}\r\n}\r\nstatic void sii8620_stop_video(struct sii8620 *ctx)\r\n{\r\nu8 uninitialized_var(val);\r\nsii8620_write_seq_static(ctx,\r\nREG_TPI_INTR_EN, 0,\r\nREG_HDCP2X_INTR0_MASK, 0,\r\nREG_TPI_COPP_DATA2, 0,\r\nREG_TPI_INTR_ST0, ~0,\r\n);\r\nswitch (ctx->sink_type) {\r\ncase SINK_DVI:\r\nval = BIT_TPI_SC_REG_TMDS_OE_POWER_DOWN\r\n| BIT_TPI_SC_TPI_AV_MUTE;\r\nbreak;\r\ncase SINK_HDMI:\r\ndefault:\r\nval = BIT_TPI_SC_REG_TMDS_OE_POWER_DOWN\r\n| BIT_TPI_SC_TPI_AV_MUTE\r\n| BIT_TPI_SC_TPI_OUTPUT_MODE_0_HDMI;\r\nbreak;\r\n}\r\nsii8620_write(ctx, REG_TPI_SC, val);\r\n}\r\nstatic void sii8620_set_format(struct sii8620 *ctx)\r\n{\r\nu8 out_fmt;\r\nif (sii8620_is_mhl3(ctx)) {\r\nsii8620_setbits(ctx, REG_M3_P0CTRL,\r\nBIT_M3_P0CTRL_MHL3_P0_PIXEL_MODE_PACKED,\r\nctx->use_packed_pixel ? ~0 : 0);\r\n} else {\r\nif (ctx->use_packed_pixel)\r\nsii8620_write_seq_static(ctx,\r\nREG_VID_MODE, BIT_VID_MODE_M1080P,\r\nREG_MHL_TOP_CTL, BIT_MHL_TOP_CTL_MHL_PP_SEL | 1,\r\nREG_MHLTX_CTL6, 0x60\r\n);\r\nelse\r\nsii8620_write_seq_static(ctx,\r\nREG_VID_MODE, 0,\r\nREG_MHL_TOP_CTL, 1,\r\nREG_MHLTX_CTL6, 0xa0\r\n);\r\n}\r\nif (ctx->use_packed_pixel)\r\nout_fmt = VAL_TPI_FORMAT(YCBCR422, FULL) |\r\nBIT_TPI_OUTPUT_CSCMODE709;\r\nelse\r\nout_fmt = VAL_TPI_FORMAT(RGB, FULL);\r\nsii8620_write_seq(ctx,\r\nREG_TPI_INPUT, VAL_TPI_FORMAT(RGB, FULL),\r\nREG_TPI_OUTPUT, out_fmt,\r\n);\r\n}\r\nstatic int mhl3_infoframe_init(struct mhl3_infoframe *frame)\r\n{\r\nmemset(frame, 0, sizeof(*frame));\r\nframe->version = 3;\r\nframe->hev_format = -1;\r\nreturn 0;\r\n}\r\nstatic ssize_t mhl3_infoframe_pack(struct mhl3_infoframe *frame,\r\nvoid *buffer, size_t size)\r\n{\r\nconst int frm_len = HDMI_INFOFRAME_HEADER_SIZE + MHL3_INFOFRAME_SIZE;\r\nu8 *ptr = buffer;\r\nif (size < frm_len)\r\nreturn -ENOSPC;\r\nmemset(buffer, 0, size);\r\nptr[0] = HDMI_INFOFRAME_TYPE_VENDOR;\r\nptr[1] = frame->version;\r\nptr[2] = MHL3_INFOFRAME_SIZE;\r\nptr[4] = MHL3_IEEE_OUI & 0xff;\r\nptr[5] = (MHL3_IEEE_OUI >> 8) & 0xff;\r\nptr[6] = (MHL3_IEEE_OUI >> 16) & 0xff;\r\nptr[7] = frame->video_format & 0x3;\r\nptr[7] |= (frame->format_type & 0x7) << 2;\r\nptr[7] |= frame->sep_audio ? BIT(5) : 0;\r\nif (frame->hev_format >= 0) {\r\nptr[9] = 1;\r\nptr[10] = (frame->hev_format >> 8) & 0xff;\r\nptr[11] = frame->hev_format & 0xff;\r\n}\r\nif (frame->av_delay) {\r\nbool sign = frame->av_delay < 0;\r\nint delay = sign ? -frame->av_delay : frame->av_delay;\r\nptr[12] = (delay >> 16) & 0xf;\r\nif (sign)\r\nptr[12] |= BIT(4);\r\nptr[13] = (delay >> 8) & 0xff;\r\nptr[14] = delay & 0xff;\r\n}\r\nptr[3] -= sii8620_checksum(buffer, frm_len);\r\nreturn frm_len;\r\n}\r\nstatic void sii8620_set_infoframes(struct sii8620 *ctx)\r\n{\r\nstruct mhl3_infoframe mhl_frm;\r\nunion hdmi_infoframe frm;\r\nu8 buf[31];\r\nint ret;\r\nif (!sii8620_is_mhl3(ctx) || !ctx->use_packed_pixel) {\r\nsii8620_write(ctx, REG_TPI_SC,\r\nBIT_TPI_SC_TPI_OUTPUT_MODE_0_HDMI);\r\nsii8620_write_buf(ctx, REG_TPI_AVI_CHSUM, ctx->avif + 3,\r\nARRAY_SIZE(ctx->avif) - 3);\r\nsii8620_write(ctx, REG_PKT_FILTER_0,\r\nBIT_PKT_FILTER_0_DROP_CEA_GAMUT_PKT |\r\nBIT_PKT_FILTER_0_DROP_MPEG_PKT |\r\nBIT_PKT_FILTER_0_DROP_GCP_PKT,\r\nBIT_PKT_FILTER_1_DROP_GEN_PKT);\r\nreturn;\r\n}\r\nret = hdmi_avi_infoframe_init(&frm.avi);\r\nfrm.avi.colorspace = HDMI_COLORSPACE_YUV422;\r\nfrm.avi.active_aspect = HDMI_ACTIVE_ASPECT_PICTURE;\r\nfrm.avi.picture_aspect = HDMI_PICTURE_ASPECT_16_9;\r\nfrm.avi.colorimetry = HDMI_COLORIMETRY_ITU_709;\r\nfrm.avi.video_code = ctx->video_code;\r\nif (!ret)\r\nret = hdmi_avi_infoframe_pack(&frm.avi, buf, ARRAY_SIZE(buf));\r\nif (ret > 0)\r\nsii8620_write_buf(ctx, REG_TPI_AVI_CHSUM, buf + 3, ret - 3);\r\nsii8620_write(ctx, REG_PKT_FILTER_0,\r\nBIT_PKT_FILTER_0_DROP_CEA_GAMUT_PKT |\r\nBIT_PKT_FILTER_0_DROP_MPEG_PKT |\r\nBIT_PKT_FILTER_0_DROP_AVI_PKT |\r\nBIT_PKT_FILTER_0_DROP_GCP_PKT,\r\nBIT_PKT_FILTER_1_VSI_OVERRIDE_DIS |\r\nBIT_PKT_FILTER_1_DROP_GEN_PKT |\r\nBIT_PKT_FILTER_1_DROP_VSIF_PKT);\r\nsii8620_write(ctx, REG_TPI_INFO_FSEL, BIT_TPI_INFO_FSEL_EN\r\n| BIT_TPI_INFO_FSEL_RPT | VAL_TPI_INFO_FSEL_VSI);\r\nret = mhl3_infoframe_init(&mhl_frm);\r\nif (!ret)\r\nret = mhl3_infoframe_pack(&mhl_frm, buf, ARRAY_SIZE(buf));\r\nsii8620_write_buf(ctx, REG_TPI_INFO_B0, buf, ret);\r\n}\r\nstatic void sii8620_start_hdmi(struct sii8620 *ctx)\r\n{\r\nsii8620_write_seq_static(ctx,\r\nREG_RX_HDMI_CTRL2, VAL_RX_HDMI_CTRL2_DEFVAL\r\n| BIT_RX_HDMI_CTRL2_USE_AV_MUTE,\r\nREG_VID_OVRRD, BIT_VID_OVRRD_PP_AUTO_DISABLE\r\n| BIT_VID_OVRRD_M1080P_OVRRD);\r\nsii8620_set_format(ctx);\r\nif (!sii8620_is_mhl3(ctx)) {\r\nsii8620_mt_write_stat(ctx, MHL_DST_REG(LINK_MODE),\r\nMHL_DST_LM_CLK_MODE_NORMAL | MHL_DST_LM_PATH_ENABLED);\r\nsii8620_set_auto_zone(ctx);\r\n} else {\r\nstatic const struct {\r\nint max_clk;\r\nu8 zone;\r\nu8 link_rate;\r\nu8 rrp_decode;\r\n} clk_spec[] = {\r\n{ 150000, VAL_TX_ZONE_CTL3_TX_ZONE_1_5GBPS,\r\nMHL_XDS_LINK_RATE_1_5_GBPS, 0x38 },\r\n{ 300000, VAL_TX_ZONE_CTL3_TX_ZONE_3GBPS,\r\nMHL_XDS_LINK_RATE_3_0_GBPS, 0x40 },\r\n{ 600000, VAL_TX_ZONE_CTL3_TX_ZONE_6GBPS,\r\nMHL_XDS_LINK_RATE_6_0_GBPS, 0x40 },\r\n};\r\nu8 p0_ctrl = BIT_M3_P0CTRL_MHL3_P0_PORT_EN;\r\nint clk = ctx->pixel_clock * (ctx->use_packed_pixel ? 2 : 3);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(clk_spec); ++i)\r\nif (clk < clk_spec[i].max_clk)\r\nbreak;\r\nif (100 * clk >= 98 * clk_spec[i].max_clk)\r\np0_ctrl |= BIT_M3_P0CTRL_MHL3_P0_UNLIMIT_EN;\r\nsii8620_burst_tx_bits_per_pixel_fmt(ctx, ctx->use_packed_pixel);\r\nsii8620_burst_send(ctx);\r\nsii8620_write_seq(ctx,\r\nREG_MHL_DP_CTL0, 0xf0,\r\nREG_MHL3_TX_ZONE_CTL, clk_spec[i].zone);\r\nsii8620_setbits(ctx, REG_M3_P0CTRL,\r\nBIT_M3_P0CTRL_MHL3_P0_PORT_EN\r\n| BIT_M3_P0CTRL_MHL3_P0_UNLIMIT_EN, p0_ctrl);\r\nsii8620_setbits(ctx, REG_M3_POSTM, MSK_M3_POSTM_RRP_DECODE,\r\nclk_spec[i].rrp_decode);\r\nsii8620_write_seq_static(ctx,\r\nREG_M3_CTRL, VAL_M3_CTRL_MHL3_VALUE\r\n| BIT_M3_CTRL_H2M_SWRST,\r\nREG_M3_CTRL, VAL_M3_CTRL_MHL3_VALUE\r\n);\r\nsii8620_mt_write_stat(ctx, MHL_XDS_REG(AVLINK_MODE_CONTROL),\r\nclk_spec[i].link_rate);\r\n}\r\nsii8620_set_infoframes(ctx);\r\n}\r\nstatic void sii8620_start_video(struct sii8620 *ctx)\r\n{\r\nif (!sii8620_is_mhl3(ctx))\r\nsii8620_stop_video(ctx);\r\nswitch (ctx->sink_type) {\r\ncase SINK_HDMI:\r\nsii8620_start_hdmi(ctx);\r\nbreak;\r\ncase SINK_DVI:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void sii8620_disable_hpd(struct sii8620 *ctx)\r\n{\r\nsii8620_setbits(ctx, REG_EDID_CTRL, BIT_EDID_CTRL_EDID_PRIME_VALID, 0);\r\nsii8620_write_seq_static(ctx,\r\nREG_HPD_CTRL, BIT_HPD_CTRL_HPD_OUT_OVR_EN,\r\nREG_INTR8_MASK, 0\r\n);\r\n}\r\nstatic void sii8620_enable_hpd(struct sii8620 *ctx)\r\n{\r\nsii8620_setbits(ctx, REG_TMDS_CSTAT_P3,\r\nBIT_TMDS_CSTAT_P3_SCDT_CLR_AVI_DIS\r\n| BIT_TMDS_CSTAT_P3_CLR_AVI, ~0);\r\nsii8620_write_seq_static(ctx,\r\nREG_HPD_CTRL, BIT_HPD_CTRL_HPD_OUT_OVR_EN\r\n| BIT_HPD_CTRL_HPD_HIGH,\r\n);\r\n}\r\nstatic void sii8620_mhl_discover(struct sii8620 *ctx)\r\n{\r\nsii8620_write_seq_static(ctx,\r\nREG_DISC_CTRL9, BIT_DISC_CTRL9_WAKE_DRVFLT\r\n| BIT_DISC_CTRL9_DISC_PULSE_PROCEED,\r\nREG_DISC_CTRL4, VAL_DISC_CTRL4(VAL_PUP_5K, VAL_PUP_20K),\r\nREG_CBUS_DISC_INTR0_MASK, BIT_MHL3_EST_INT\r\n| BIT_MHL_EST_INT\r\n| BIT_NOT_MHL_EST_INT\r\n| BIT_CBUS_MHL3_DISCON_INT\r\n| BIT_CBUS_MHL12_DISCON_INT\r\n| BIT_RGND_READY_INT,\r\nREG_MHL_PLL_CTL0, VAL_MHL_PLL_CTL0_HDMI_CLK_RATIO_1X\r\n| BIT_MHL_PLL_CTL0_CRYSTAL_CLK_SEL\r\n| BIT_MHL_PLL_CTL0_ZONE_MASK_OE,\r\nREG_MHL_DP_CTL0, BIT_MHL_DP_CTL0_DP_OE\r\n| BIT_MHL_DP_CTL0_TX_OE_OVR,\r\nREG_M3_CTRL, VAL_M3_CTRL_MHL3_VALUE,\r\nREG_MHL_DP_CTL1, 0xA2,\r\nREG_MHL_DP_CTL2, 0x03,\r\nREG_MHL_DP_CTL3, 0x35,\r\nREG_MHL_DP_CTL5, 0x02,\r\nREG_MHL_DP_CTL6, 0x02,\r\nREG_MHL_DP_CTL7, 0x03,\r\nREG_COC_CTLC, 0xFF,\r\nREG_DPD, BIT_DPD_PWRON_PLL | BIT_DPD_PDNTX12\r\n| BIT_DPD_OSC_EN | BIT_DPD_PWRON_HSIC,\r\nREG_COC_INTR_MASK, BIT_COC_PLL_LOCK_STATUS_CHANGE\r\n| BIT_COC_CALIBRATION_DONE,\r\nREG_CBUS_INT_1_MASK, BIT_CBUS_MSC_ABORT_RCVD\r\n| BIT_CBUS_CMD_ABORT,\r\nREG_CBUS_INT_0_MASK, BIT_CBUS_MSC_MT_DONE\r\n| BIT_CBUS_HPD_CHG\r\n| BIT_CBUS_MSC_MR_WRITE_STAT\r\n| BIT_CBUS_MSC_MR_MSC_MSG\r\n| BIT_CBUS_MSC_MR_WRITE_BURST\r\n| BIT_CBUS_MSC_MR_SET_INT\r\n| BIT_CBUS_MSC_MT_DONE_NACK\r\n);\r\n}\r\nstatic void sii8620_peer_specific_init(struct sii8620 *ctx)\r\n{\r\nif (sii8620_is_mhl3(ctx))\r\nsii8620_write_seq_static(ctx,\r\nREG_SYS_CTRL1, BIT_SYS_CTRL1_BLOCK_DDC_BY_HPD,\r\nREG_EMSCINTRMASK1,\r\nBIT_EMSCINTR1_EMSC_TRAINING_COMMA_ERR\r\n);\r\nelse\r\nsii8620_write_seq_static(ctx,\r\nREG_HDCP2X_INTR0_MASK, 0x00,\r\nREG_EMSCINTRMASK1, 0x00,\r\nREG_HDCP2X_INTR0, 0xFF,\r\nREG_INTR1, 0xFF,\r\nREG_SYS_CTRL1, BIT_SYS_CTRL1_BLOCK_DDC_BY_HPD\r\n| BIT_SYS_CTRL1_TX_CTRL_HDMI\r\n);\r\n}\r\nstatic void sii8620_set_dev_cap(struct sii8620 *ctx)\r\n{\r\nstatic const u8 devcap[MHL_DCAP_SIZE] = {\r\n[MHL_DCAP_MHL_VERSION] = SII8620_MHL_VERSION,\r\n[MHL_DCAP_CAT] = MHL_DCAP_CAT_SOURCE | MHL_DCAP_CAT_POWER,\r\n[MHL_DCAP_ADOPTER_ID_H] = 0x01,\r\n[MHL_DCAP_ADOPTER_ID_L] = 0x41,\r\n[MHL_DCAP_VID_LINK_MODE] = MHL_DCAP_VID_LINK_RGB444\r\n| MHL_DCAP_VID_LINK_PPIXEL\r\n| MHL_DCAP_VID_LINK_16BPP,\r\n[MHL_DCAP_AUD_LINK_MODE] = MHL_DCAP_AUD_LINK_2CH,\r\n[MHL_DCAP_VIDEO_TYPE] = MHL_DCAP_VT_GRAPHICS,\r\n[MHL_DCAP_LOG_DEV_MAP] = MHL_DCAP_LD_GUI,\r\n[MHL_DCAP_BANDWIDTH] = 0x0f,\r\n[MHL_DCAP_FEATURE_FLAG] = MHL_DCAP_FEATURE_RCP_SUPPORT\r\n| MHL_DCAP_FEATURE_RAP_SUPPORT\r\n| MHL_DCAP_FEATURE_SP_SUPPORT,\r\n[MHL_DCAP_SCRATCHPAD_SIZE] = SII8620_SCRATCHPAD_SIZE,\r\n[MHL_DCAP_INT_STAT_SIZE] = SII8620_INT_STAT_SIZE,\r\n};\r\nstatic const u8 xdcap[MHL_XDC_SIZE] = {\r\n[MHL_XDC_ECBUS_SPEEDS] = MHL_XDC_ECBUS_S_075\r\n| MHL_XDC_ECBUS_S_8BIT,\r\n[MHL_XDC_TMDS_SPEEDS] = MHL_XDC_TMDS_150\r\n| MHL_XDC_TMDS_300 | MHL_XDC_TMDS_600,\r\n[MHL_XDC_ECBUS_ROLES] = MHL_XDC_DEV_HOST,\r\n[MHL_XDC_LOG_DEV_MAPX] = MHL_XDC_LD_PHONE,\r\n};\r\nsii8620_write_buf(ctx, REG_MHL_DEVCAP_0, devcap, ARRAY_SIZE(devcap));\r\nsii8620_write_buf(ctx, REG_MHL_EXTDEVCAP_0, xdcap, ARRAY_SIZE(xdcap));\r\n}\r\nstatic void sii8620_mhl_init(struct sii8620 *ctx)\r\n{\r\nsii8620_write_seq_static(ctx,\r\nREG_DISC_CTRL4, VAL_DISC_CTRL4(VAL_PUP_OFF, VAL_PUP_20K),\r\nREG_CBUS_MSC_COMPAT_CTRL,\r\nBIT_CBUS_MSC_COMPAT_CTRL_XDEVCAP_EN,\r\n);\r\nsii8620_peer_specific_init(ctx);\r\nsii8620_disable_hpd(ctx);\r\nsii8620_write_seq_static(ctx,\r\nREG_EDID_CTRL, BIT_EDID_CTRL_EDID_FIFO_ADDR_AUTO,\r\nREG_DISC_CTRL9, BIT_DISC_CTRL9_WAKE_DRVFLT\r\n| BIT_DISC_CTRL9_WAKE_PULSE_BYPASS,\r\nREG_TMDS0_CCTRL1, 0x90,\r\nREG_TMDS_CLK_EN, 0x01,\r\nREG_TMDS_CH_EN, 0x11,\r\nREG_BGR_BIAS, 0x87,\r\nREG_ALICE0_ZONE_CTRL, 0xE8,\r\nREG_ALICE0_MODE_CTRL, 0x04,\r\n);\r\nsii8620_setbits(ctx, REG_LM_DDC, BIT_LM_DDC_SW_TPI_EN_DISABLED, 0);\r\nsii8620_write_seq_static(ctx,\r\nREG_TPI_HW_OPT3, 0x76,\r\nREG_TMDS_CCTRL, BIT_TMDS_CCTRL_TMDS_OE,\r\nREG_TPI_DTD_B2, 79,\r\n);\r\nsii8620_set_dev_cap(ctx);\r\nsii8620_write_seq_static(ctx,\r\nREG_MDT_XMIT_TIMEOUT, 100,\r\nREG_MDT_XMIT_CTRL, 0x03,\r\nREG_MDT_XFIFO_STAT, 0x00,\r\nREG_MDT_RCV_TIMEOUT, 100,\r\nREG_CBUS_LINK_CTRL_8, 0x1D,\r\n);\r\nsii8620_start_gen2_write_burst(ctx);\r\nsii8620_write_seq_static(ctx,\r\nREG_BIST_CTRL, 0x00,\r\nREG_COC_CTL1, 0x10,\r\nREG_COC_CTL2, 0x18,\r\nREG_COC_CTLF, 0x07,\r\nREG_COC_CTL11, 0xF8,\r\nREG_COC_CTL17, 0x61,\r\nREG_COC_CTL18, 0x46,\r\nREG_COC_CTL19, 0x15,\r\nREG_COC_CTL1A, 0x01,\r\nREG_MHL_COC_CTL3, BIT_MHL_COC_CTL3_COC_AECHO_EN,\r\nREG_MHL_COC_CTL4, 0x2D,\r\nREG_MHL_COC_CTL5, 0xF9,\r\nREG_MSC_HEARTBEAT_CTRL, 0x27,\r\n);\r\nsii8620_disable_gen2_write_burst(ctx);\r\nsii8620_mt_write_stat(ctx, MHL_DST_REG(VERSION), SII8620_MHL_VERSION);\r\nsii8620_mt_write_stat(ctx, MHL_DST_REG(CONNECTED_RDY),\r\nMHL_DST_CONN_DCAP_RDY | MHL_DST_CONN_XDEVCAPP_SUPP\r\n| MHL_DST_CONN_POW_STAT);\r\nsii8620_mt_set_int(ctx, MHL_INT_REG(RCHANGE), MHL_INT_RC_DCAP_CHG);\r\n}\r\nstatic void sii8620_emsc_enable(struct sii8620 *ctx)\r\n{\r\nu8 reg;\r\nsii8620_setbits(ctx, REG_GENCTL, BIT_GENCTL_EMSC_EN\r\n| BIT_GENCTL_CLR_EMSC_RFIFO\r\n| BIT_GENCTL_CLR_EMSC_XFIFO, ~0);\r\nsii8620_setbits(ctx, REG_GENCTL, BIT_GENCTL_CLR_EMSC_RFIFO\r\n| BIT_GENCTL_CLR_EMSC_XFIFO, 0);\r\nsii8620_setbits(ctx, REG_COMMECNT, BIT_COMMECNT_I2C_TO_EMSC_EN, ~0);\r\nreg = sii8620_readb(ctx, REG_EMSCINTR);\r\nsii8620_write(ctx, REG_EMSCINTR, reg);\r\nsii8620_write(ctx, REG_EMSCINTRMASK, BIT_EMSCINTR_SPI_DVLD);\r\n}\r\nstatic int sii8620_wait_for_fsm_state(struct sii8620 *ctx, u8 state)\r\n{\r\nint i;\r\nfor (i = 0; i < 10; ++i) {\r\nu8 s = sii8620_readb(ctx, REG_COC_STAT_0);\r\nif ((s & MSK_COC_STAT_0_FSM_STATE) == state)\r\nreturn 0;\r\nif (!(s & BIT_COC_STAT_0_PLL_LOCKED))\r\nreturn -EBUSY;\r\nusleep_range(4000, 6000);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void sii8620_set_mode(struct sii8620 *ctx, enum sii8620_mode mode)\r\n{\r\nint ret;\r\nif (ctx->mode == mode)\r\nreturn;\r\nswitch (mode) {\r\ncase CM_MHL1:\r\nsii8620_write_seq_static(ctx,\r\nREG_CBUS_MSC_COMPAT_CTRL, 0x02,\r\nREG_M3_CTRL, VAL_M3_CTRL_MHL1_2_VALUE,\r\nREG_DPD, BIT_DPD_PWRON_PLL | BIT_DPD_PDNTX12\r\n| BIT_DPD_OSC_EN,\r\nREG_COC_INTR_MASK, 0\r\n);\r\nctx->mode = mode;\r\nbreak;\r\ncase CM_MHL3:\r\nsii8620_write(ctx, REG_M3_CTRL, VAL_M3_CTRL_MHL3_VALUE);\r\nctx->mode = mode;\r\nreturn;\r\ncase CM_ECBUS_S:\r\nsii8620_emsc_enable(ctx);\r\nsii8620_write_seq_static(ctx,\r\nREG_TTXSPINUMS, 4,\r\nREG_TRXSPINUMS, 4,\r\nREG_TTXHSICNUMS, 0x14,\r\nREG_TRXHSICNUMS, 0x14,\r\nREG_TTXTOTNUMS, 0x18,\r\nREG_TRXTOTNUMS, 0x18,\r\nREG_PWD_SRST, BIT_PWD_SRST_COC_DOC_RST\r\n| BIT_PWD_SRST_CBUS_RST_SW_EN,\r\nREG_MHL_COC_CTL1, 0xbd,\r\nREG_PWD_SRST, BIT_PWD_SRST_CBUS_RST_SW_EN,\r\nREG_COC_CTLB, 0x01,\r\nREG_COC_CTL0, 0x5c,\r\nREG_COC_CTL14, 0x03,\r\nREG_COC_CTL15, 0x80,\r\nREG_MHL_DP_CTL6, BIT_MHL_DP_CTL6_DP_TAP1_SGN\r\n| BIT_MHL_DP_CTL6_DP_TAP1_EN\r\n| BIT_MHL_DP_CTL6_DT_PREDRV_FEEDCAP_EN,\r\nREG_MHL_DP_CTL8, 0x03\r\n);\r\nret = sii8620_wait_for_fsm_state(ctx, 0x03);\r\nsii8620_write_seq_static(ctx,\r\nREG_COC_CTL14, 0x00,\r\nREG_COC_CTL15, 0x80\r\n);\r\nif (!ret)\r\nsii8620_write(ctx, REG_CBUS3_CNVT, 0x85);\r\nelse\r\nsii8620_disconnect(ctx);\r\nreturn;\r\ncase CM_DISCONNECTED:\r\nctx->mode = mode;\r\nbreak;\r\ndefault:\r\ndev_err(ctx->dev, "%s mode %d not supported\n", __func__, mode);\r\nbreak;\r\n}\r\nsii8620_set_auto_zone(ctx);\r\nif (mode != CM_MHL1)\r\nreturn;\r\nsii8620_write_seq_static(ctx,\r\nREG_MHL_DP_CTL0, 0xBC,\r\nREG_MHL_DP_CTL1, 0xBB,\r\nREG_MHL_DP_CTL3, 0x48,\r\nREG_MHL_DP_CTL5, 0x39,\r\nREG_MHL_DP_CTL2, 0x2A,\r\nREG_MHL_DP_CTL6, 0x2A,\r\nREG_MHL_DP_CTL7, 0x08\r\n);\r\n}\r\nstatic void sii8620_disconnect(struct sii8620 *ctx)\r\n{\r\nsii8620_disable_gen2_write_burst(ctx);\r\nsii8620_stop_video(ctx);\r\nmsleep(100);\r\nsii8620_cbus_reset(ctx);\r\nsii8620_set_mode(ctx, CM_DISCONNECTED);\r\nsii8620_write_seq_static(ctx,\r\nREG_TX_ZONE_CTL1, 0,\r\nREG_MHL_PLL_CTL0, 0x07,\r\nREG_COC_CTL0, 0x40,\r\nREG_CBUS3_CNVT, 0x84,\r\nREG_COC_CTL14, 0x00,\r\nREG_COC_CTL0, 0x40,\r\nREG_HRXCTRL3, 0x07,\r\nREG_MHL_PLL_CTL0, VAL_MHL_PLL_CTL0_HDMI_CLK_RATIO_1X\r\n| BIT_MHL_PLL_CTL0_CRYSTAL_CLK_SEL\r\n| BIT_MHL_PLL_CTL0_ZONE_MASK_OE,\r\nREG_MHL_DP_CTL0, BIT_MHL_DP_CTL0_DP_OE\r\n| BIT_MHL_DP_CTL0_TX_OE_OVR,\r\nREG_MHL_DP_CTL1, 0xBB,\r\nREG_MHL_DP_CTL3, 0x48,\r\nREG_MHL_DP_CTL5, 0x3F,\r\nREG_MHL_DP_CTL2, 0x2F,\r\nREG_MHL_DP_CTL6, 0x2A,\r\nREG_MHL_DP_CTL7, 0x03\r\n);\r\nsii8620_disable_hpd(ctx);\r\nsii8620_write_seq_static(ctx,\r\nREG_M3_CTRL, VAL_M3_CTRL_MHL3_VALUE,\r\nREG_MHL_COC_CTL1, 0x07,\r\nREG_DISC_CTRL4, VAL_DISC_CTRL4(VAL_PUP_OFF, VAL_PUP_20K),\r\nREG_DISC_CTRL8, 0x00,\r\nREG_DISC_CTRL9, BIT_DISC_CTRL9_WAKE_DRVFLT\r\n| BIT_DISC_CTRL9_WAKE_PULSE_BYPASS,\r\nREG_INT_CTRL, 0x00,\r\nREG_MSC_HEARTBEAT_CTRL, 0x27,\r\nREG_DISC_CTRL1, 0x25,\r\nREG_CBUS_DISC_INTR0, (u8)~BIT_RGND_READY_INT,\r\nREG_CBUS_DISC_INTR0_MASK, BIT_RGND_READY_INT,\r\nREG_MDT_INT_1, 0xff,\r\nREG_MDT_INT_1_MASK, 0x00,\r\nREG_MDT_INT_0, 0xff,\r\nREG_MDT_INT_0_MASK, 0x00,\r\nREG_COC_INTR, 0xff,\r\nREG_COC_INTR_MASK, 0x00,\r\nREG_TRXINTH, 0xff,\r\nREG_TRXINTMH, 0x00,\r\nREG_CBUS_INT_0, 0xff,\r\nREG_CBUS_INT_0_MASK, 0x00,\r\nREG_CBUS_INT_1, 0xff,\r\nREG_CBUS_INT_1_MASK, 0x00,\r\nREG_EMSCINTR, 0xff,\r\nREG_EMSCINTRMASK, 0x00,\r\nREG_EMSCINTR1, 0xff,\r\nREG_EMSCINTRMASK1, 0x00,\r\nREG_INTR8, 0xff,\r\nREG_INTR8_MASK, 0x00,\r\nREG_TPI_INTR_ST0, 0xff,\r\nREG_TPI_INTR_EN, 0x00,\r\nREG_HDCP2X_INTR0, 0xff,\r\nREG_HDCP2X_INTR0_MASK, 0x00,\r\nREG_INTR9, 0xff,\r\nREG_INTR9_MASK, 0x00,\r\nREG_INTR3, 0xff,\r\nREG_INTR3_MASK, 0x00,\r\nREG_INTR5, 0xff,\r\nREG_INTR5_MASK, 0x00,\r\nREG_INTR2, 0xff,\r\nREG_INTR2_MASK, 0x00,\r\n);\r\nmemset(ctx->stat, 0, sizeof(ctx->stat));\r\nmemset(ctx->xstat, 0, sizeof(ctx->xstat));\r\nmemset(ctx->devcap, 0, sizeof(ctx->devcap));\r\nmemset(ctx->xdevcap, 0, sizeof(ctx->xdevcap));\r\nctx->cbus_status = 0;\r\nctx->sink_type = SINK_NONE;\r\nkfree(ctx->edid);\r\nctx->edid = NULL;\r\nsii8620_mt_cleanup(ctx);\r\n}\r\nstatic void sii8620_mhl_disconnected(struct sii8620 *ctx)\r\n{\r\nsii8620_write_seq_static(ctx,\r\nREG_DISC_CTRL4, VAL_DISC_CTRL4(VAL_PUP_OFF, VAL_PUP_20K),\r\nREG_CBUS_MSC_COMPAT_CTRL,\r\nBIT_CBUS_MSC_COMPAT_CTRL_XDEVCAP_EN\r\n);\r\nsii8620_disconnect(ctx);\r\n}\r\nstatic void sii8620_irq_disc(struct sii8620 *ctx)\r\n{\r\nu8 stat = sii8620_readb(ctx, REG_CBUS_DISC_INTR0);\r\nif (stat & VAL_CBUS_MHL_DISCON)\r\nsii8620_mhl_disconnected(ctx);\r\nif (stat & BIT_RGND_READY_INT) {\r\nu8 stat2 = sii8620_readb(ctx, REG_DISC_STAT2);\r\nif ((stat2 & MSK_DISC_STAT2_RGND) == VAL_RGND_1K) {\r\nsii8620_mhl_discover(ctx);\r\n} else {\r\nsii8620_write_seq_static(ctx,\r\nREG_DISC_CTRL9, BIT_DISC_CTRL9_WAKE_DRVFLT\r\n| BIT_DISC_CTRL9_NOMHL_EST\r\n| BIT_DISC_CTRL9_WAKE_PULSE_BYPASS,\r\nREG_CBUS_DISC_INTR0_MASK, BIT_RGND_READY_INT\r\n| BIT_CBUS_MHL3_DISCON_INT\r\n| BIT_CBUS_MHL12_DISCON_INT\r\n| BIT_NOT_MHL_EST_INT\r\n);\r\n}\r\n}\r\nif (stat & BIT_MHL_EST_INT)\r\nsii8620_mhl_init(ctx);\r\nsii8620_write(ctx, REG_CBUS_DISC_INTR0, stat);\r\n}\r\nstatic void sii8620_read_burst(struct sii8620 *ctx)\r\n{\r\nu8 buf[17];\r\nsii8620_read_buf(ctx, REG_MDT_RCV_READ_PORT, buf, ARRAY_SIZE(buf));\r\nsii8620_write(ctx, REG_MDT_RCV_CTRL, BIT_MDT_RCV_CTRL_MDT_RCV_EN |\r\nBIT_MDT_RCV_CTRL_MDT_DELAY_RCV_EN |\r\nBIT_MDT_RCV_CTRL_MDT_RFIFO_CLR_CUR);\r\nsii8620_readb(ctx, REG_MDT_RFIFO_STAT);\r\n}\r\nstatic void sii8620_irq_g2wb(struct sii8620 *ctx)\r\n{\r\nu8 stat = sii8620_readb(ctx, REG_MDT_INT_0);\r\nif (stat & BIT_MDT_IDLE_AFTER_HAWB_DISABLE)\r\nif (sii8620_is_mhl3(ctx))\r\nsii8620_mt_set_int(ctx, MHL_INT_REG(RCHANGE),\r\nMHL_INT_RC_FEAT_COMPLETE);\r\nif (stat & BIT_MDT_RFIFO_DATA_RDY)\r\nsii8620_read_burst(ctx);\r\nif (stat & BIT_MDT_XFIFO_EMPTY)\r\nsii8620_write(ctx, REG_MDT_XMIT_CTRL, 0);\r\nsii8620_write(ctx, REG_MDT_INT_0, stat);\r\n}\r\nstatic void sii8620_status_dcap_ready(struct sii8620 *ctx)\r\n{\r\nenum sii8620_mode mode;\r\nmode = ctx->stat[MHL_DST_VERSION] >= 0x30 ? CM_MHL3 : CM_MHL1;\r\nif (mode > ctx->mode)\r\nsii8620_set_mode(ctx, mode);\r\nsii8620_peer_specific_init(ctx);\r\nsii8620_write(ctx, REG_INTR9_MASK, BIT_INTR9_DEVCAP_DONE\r\n| BIT_INTR9_EDID_DONE | BIT_INTR9_EDID_ERROR);\r\n}\r\nstatic void sii8620_status_changed_path(struct sii8620 *ctx)\r\n{\r\nif (ctx->stat[MHL_DST_LINK_MODE] & MHL_DST_LM_PATH_ENABLED) {\r\nsii8620_mt_write_stat(ctx, MHL_DST_REG(LINK_MODE),\r\nMHL_DST_LM_CLK_MODE_NORMAL\r\n| MHL_DST_LM_PATH_ENABLED);\r\nif (!sii8620_is_mhl3(ctx))\r\nsii8620_mt_read_devcap(ctx, false);\r\nsii8620_mt_set_cont(ctx, sii8620_sink_detected);\r\n} else {\r\nsii8620_mt_write_stat(ctx, MHL_DST_REG(LINK_MODE),\r\nMHL_DST_LM_CLK_MODE_NORMAL);\r\n}\r\n}\r\nstatic void sii8620_msc_mr_write_stat(struct sii8620 *ctx)\r\n{\r\nu8 st[MHL_DST_SIZE], xst[MHL_XDS_SIZE];\r\nsii8620_read_buf(ctx, REG_MHL_STAT_0, st, MHL_DST_SIZE);\r\nsii8620_read_buf(ctx, REG_MHL_EXTSTAT_0, xst, MHL_XDS_SIZE);\r\nsii8620_update_array(ctx->stat, st, MHL_DST_SIZE);\r\nsii8620_update_array(ctx->xstat, xst, MHL_XDS_SIZE);\r\nif (ctx->stat[MHL_DST_CONNECTED_RDY] & MHL_DST_CONN_DCAP_RDY)\r\nsii8620_status_dcap_ready(ctx);\r\nif (st[MHL_DST_LINK_MODE] & MHL_DST_LM_PATH_ENABLED)\r\nsii8620_status_changed_path(ctx);\r\n}\r\nstatic void sii8620_ecbus_up(struct sii8620 *ctx, int ret)\r\n{\r\nif (ret < 0)\r\nreturn;\r\nsii8620_set_mode(ctx, CM_ECBUS_S);\r\n}\r\nstatic void sii8620_got_ecbus_speed(struct sii8620 *ctx, int ret)\r\n{\r\nif (ret < 0)\r\nreturn;\r\nsii8620_mt_write_stat(ctx, MHL_XDS_REG(CURR_ECBUS_MODE),\r\nMHL_XDS_ECBUS_S | MHL_XDS_SLOT_MODE_8BIT);\r\nsii8620_mt_rap(ctx, MHL_RAP_CBUS_MODE_UP);\r\nsii8620_mt_set_cont(ctx, sii8620_ecbus_up);\r\n}\r\nstatic void sii8620_mhl_burst_emsc_support_set(struct mhl_burst_emsc_support *d,\r\nenum mhl_burst_id id)\r\n{\r\nsii8620_mhl_burst_hdr_set(&d->hdr, MHL_BURST_ID_EMSC_SUPPORT);\r\nd->num_entries = 1;\r\nd->burst_id[0] = cpu_to_be16(id);\r\n}\r\nstatic void sii8620_send_features(struct sii8620 *ctx)\r\n{\r\nu8 buf[16];\r\nsii8620_write(ctx, REG_MDT_XMIT_CTRL, BIT_MDT_XMIT_CTRL_EN\r\n| BIT_MDT_XMIT_CTRL_FIXED_BURST_LEN);\r\nsii8620_mhl_burst_emsc_support_set((void *)buf,\r\nMHL_BURST_ID_HID_PAYLOAD);\r\nsii8620_write_buf(ctx, REG_MDT_XMIT_WRITE_PORT, buf, ARRAY_SIZE(buf));\r\n}\r\nstatic void sii8620_msc_mr_set_int(struct sii8620 *ctx)\r\n{\r\nu8 ints[MHL_INT_SIZE];\r\nsii8620_read_buf(ctx, REG_MHL_INT_0, ints, MHL_INT_SIZE);\r\nsii8620_write_buf(ctx, REG_MHL_INT_0, ints, MHL_INT_SIZE);\r\nif (ints[MHL_INT_RCHANGE] & MHL_INT_RC_DCAP_CHG) {\r\nswitch (ctx->mode) {\r\ncase CM_MHL3:\r\nsii8620_mt_read_xdevcap_reg(ctx, MHL_XDC_ECBUS_SPEEDS);\r\nsii8620_mt_set_cont(ctx, sii8620_got_ecbus_speed);\r\nbreak;\r\ncase CM_ECBUS_S:\r\nsii8620_mt_read_devcap(ctx, true);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (ints[MHL_INT_RCHANGE] & MHL_INT_RC_FEAT_REQ)\r\nsii8620_send_features(ctx);\r\nif (ints[MHL_INT_RCHANGE] & MHL_INT_RC_FEAT_COMPLETE)\r\nsii8620_edid_read(ctx, 0);\r\n}\r\nstatic struct sii8620_mt_msg *sii8620_msc_msg_first(struct sii8620 *ctx)\r\n{\r\nstruct device *dev = ctx->dev;\r\nif (list_empty(&ctx->mt_queue)) {\r\ndev_err(dev, "unexpected MSC MT response\n");\r\nreturn NULL;\r\n}\r\nreturn list_first_entry(&ctx->mt_queue, struct sii8620_mt_msg, node);\r\n}\r\nstatic void sii8620_msc_mt_done(struct sii8620 *ctx)\r\n{\r\nstruct sii8620_mt_msg *msg = sii8620_msc_msg_first(ctx);\r\nif (!msg)\r\nreturn;\r\nmsg->ret = sii8620_readb(ctx, REG_MSC_MT_RCVD_DATA0);\r\nctx->mt_state = MT_STATE_DONE;\r\n}\r\nstatic void sii8620_msc_mr_msc_msg(struct sii8620 *ctx)\r\n{\r\nstruct sii8620_mt_msg *msg = sii8620_msc_msg_first(ctx);\r\nu8 buf[2];\r\nif (!msg)\r\nreturn;\r\nsii8620_read_buf(ctx, REG_MSC_MR_MSC_MSG_RCVD_1ST_DATA, buf, 2);\r\nswitch (buf[0]) {\r\ncase MHL_MSC_MSG_RAPK:\r\nmsg->ret = buf[1];\r\nctx->mt_state = MT_STATE_DONE;\r\nbreak;\r\ndefault:\r\ndev_err(ctx->dev, "%s message type %d,%d not supported",\r\n__func__, buf[0], buf[1]);\r\n}\r\n}\r\nstatic void sii8620_irq_msc(struct sii8620 *ctx)\r\n{\r\nu8 stat = sii8620_readb(ctx, REG_CBUS_INT_0);\r\nif (stat & ~BIT_CBUS_HPD_CHG)\r\nsii8620_write(ctx, REG_CBUS_INT_0, stat & ~BIT_CBUS_HPD_CHG);\r\nif (stat & BIT_CBUS_HPD_CHG) {\r\nu8 cbus_stat = sii8620_readb(ctx, REG_CBUS_STATUS);\r\nif ((cbus_stat ^ ctx->cbus_status) & BIT_CBUS_STATUS_CBUS_HPD) {\r\nsii8620_write(ctx, REG_CBUS_INT_0, BIT_CBUS_HPD_CHG);\r\n} else {\r\nstat ^= BIT_CBUS_STATUS_CBUS_HPD;\r\ncbus_stat ^= BIT_CBUS_STATUS_CBUS_HPD;\r\n}\r\nctx->cbus_status = cbus_stat;\r\n}\r\nif (stat & BIT_CBUS_MSC_MR_WRITE_STAT)\r\nsii8620_msc_mr_write_stat(ctx);\r\nif (stat & BIT_CBUS_MSC_MR_SET_INT)\r\nsii8620_msc_mr_set_int(ctx);\r\nif (stat & BIT_CBUS_MSC_MT_DONE)\r\nsii8620_msc_mt_done(ctx);\r\nif (stat & BIT_CBUS_MSC_MR_MSC_MSG)\r\nsii8620_msc_mr_msc_msg(ctx);\r\n}\r\nstatic void sii8620_irq_coc(struct sii8620 *ctx)\r\n{\r\nu8 stat = sii8620_readb(ctx, REG_COC_INTR);\r\nif (stat & BIT_COC_CALIBRATION_DONE) {\r\nu8 cstat = sii8620_readb(ctx, REG_COC_STAT_0);\r\ncstat &= BIT_COC_STAT_0_PLL_LOCKED | MSK_COC_STAT_0_FSM_STATE;\r\nif (cstat == (BIT_COC_STAT_0_PLL_LOCKED | 0x02)) {\r\nsii8620_write_seq_static(ctx,\r\nREG_COC_CTLB, 0,\r\nREG_TRXINTMH, BIT_TDM_INTR_SYNC_DATA\r\n| BIT_TDM_INTR_SYNC_WAIT\r\n);\r\n}\r\n}\r\nsii8620_write(ctx, REG_COC_INTR, stat);\r\n}\r\nstatic void sii8620_irq_merr(struct sii8620 *ctx)\r\n{\r\nu8 stat = sii8620_readb(ctx, REG_CBUS_INT_1);\r\nsii8620_write(ctx, REG_CBUS_INT_1, stat);\r\n}\r\nstatic void sii8620_irq_edid(struct sii8620 *ctx)\r\n{\r\nu8 stat = sii8620_readb(ctx, REG_INTR9);\r\nsii8620_write(ctx, REG_INTR9, stat);\r\nif (stat & BIT_INTR9_DEVCAP_DONE)\r\nctx->mt_state = MT_STATE_DONE;\r\n}\r\nstatic void sii8620_scdt_high(struct sii8620 *ctx)\r\n{\r\nsii8620_write_seq_static(ctx,\r\nREG_INTR8_MASK, BIT_CEA_NEW_AVI | BIT_CEA_NEW_VSI,\r\nREG_TPI_SC, BIT_TPI_SC_TPI_OUTPUT_MODE_0_HDMI,\r\n);\r\n}\r\nstatic void sii8620_irq_scdt(struct sii8620 *ctx)\r\n{\r\nu8 stat = sii8620_readb(ctx, REG_INTR5);\r\nif (stat & BIT_INTR_SCDT_CHANGE) {\r\nu8 cstat = sii8620_readb(ctx, REG_TMDS_CSTAT_P3);\r\nif (cstat & BIT_TMDS_CSTAT_P3_SCDT)\r\nsii8620_scdt_high(ctx);\r\n}\r\nsii8620_write(ctx, REG_INTR5, stat);\r\n}\r\nstatic void sii8620_new_vsi(struct sii8620 *ctx)\r\n{\r\nu8 vsif[11];\r\nsii8620_write(ctx, REG_RX_HDMI_CTRL2,\r\nVAL_RX_HDMI_CTRL2_DEFVAL |\r\nBIT_RX_HDMI_CTRL2_VSI_MON_SEL_VSI);\r\nsii8620_read_buf(ctx, REG_RX_HDMI_MON_PKT_HEADER1, vsif,\r\nARRAY_SIZE(vsif));\r\n}\r\nstatic void sii8620_new_avi(struct sii8620 *ctx)\r\n{\r\nsii8620_write(ctx, REG_RX_HDMI_CTRL2, VAL_RX_HDMI_CTRL2_DEFVAL);\r\nsii8620_read_buf(ctx, REG_RX_HDMI_MON_PKT_HEADER1, ctx->avif,\r\nARRAY_SIZE(ctx->avif));\r\n}\r\nstatic void sii8620_irq_infr(struct sii8620 *ctx)\r\n{\r\nu8 stat = sii8620_readb(ctx, REG_INTR8)\r\n& (BIT_CEA_NEW_VSI | BIT_CEA_NEW_AVI);\r\nsii8620_write(ctx, REG_INTR8, stat);\r\nif (stat & BIT_CEA_NEW_VSI)\r\nsii8620_new_vsi(ctx);\r\nif (stat & BIT_CEA_NEW_AVI)\r\nsii8620_new_avi(ctx);\r\nif (stat & (BIT_CEA_NEW_VSI | BIT_CEA_NEW_AVI))\r\nsii8620_start_video(ctx);\r\n}\r\nstatic void sii8620_got_xdevcap(struct sii8620 *ctx, int ret)\r\n{\r\nif (ret < 0)\r\nreturn;\r\nsii8620_mt_read_devcap(ctx, false);\r\n}\r\nstatic void sii8620_irq_tdm(struct sii8620 *ctx)\r\n{\r\nu8 stat = sii8620_readb(ctx, REG_TRXINTH);\r\nu8 tdm = sii8620_readb(ctx, REG_TRXSTA2);\r\nif ((tdm & MSK_TDM_SYNCHRONIZED) == VAL_TDM_SYNCHRONIZED) {\r\nctx->mode = CM_ECBUS_S;\r\nctx->burst.rx_ack = 0;\r\nctx->burst.r_size = SII8620_BURST_BUF_LEN;\r\nsii8620_burst_tx_rbuf_info(ctx, SII8620_BURST_BUF_LEN);\r\nsii8620_mt_read_devcap(ctx, true);\r\nsii8620_mt_set_cont(ctx, sii8620_got_xdevcap);\r\n} else {\r\nsii8620_write_seq_static(ctx,\r\nREG_MHL_PLL_CTL2, 0,\r\nREG_MHL_PLL_CTL2, BIT_MHL_PLL_CTL2_CLKDETECT_EN\r\n);\r\n}\r\nsii8620_write(ctx, REG_TRXINTH, stat);\r\n}\r\nstatic void sii8620_irq_block(struct sii8620 *ctx)\r\n{\r\nu8 stat = sii8620_readb(ctx, REG_EMSCINTR);\r\nif (stat & BIT_EMSCINTR_SPI_DVLD) {\r\nu8 bstat = sii8620_readb(ctx, REG_SPIBURSTSTAT);\r\nif (bstat & BIT_SPIBURSTSTAT_EMSC_NORMAL_MODE)\r\nsii8620_burst_receive(ctx);\r\n}\r\nsii8620_write(ctx, REG_EMSCINTR, stat);\r\n}\r\nstatic void sii8620_irq_ddc(struct sii8620 *ctx)\r\n{\r\nu8 stat = sii8620_readb(ctx, REG_INTR3);\r\nif (stat & BIT_DDC_CMD_DONE) {\r\nsii8620_write(ctx, REG_INTR3_MASK, 0);\r\nif (sii8620_is_mhl3(ctx))\r\nsii8620_mt_set_int(ctx, MHL_INT_REG(RCHANGE),\r\nMHL_INT_RC_FEAT_REQ);\r\nelse\r\nsii8620_edid_read(ctx, 0);\r\n}\r\nsii8620_write(ctx, REG_INTR3, stat);\r\n}\r\nstatic bool sii8620_test_bit(unsigned int nr, const u8 *addr)\r\n{\r\nreturn 1 & (addr[nr / BITS_PER_BYTE] >> (nr % BITS_PER_BYTE));\r\n}\r\nstatic irqreturn_t sii8620_irq_thread(int irq, void *data)\r\n{\r\nstatic const struct {\r\nint bit;\r\nvoid (*handler)(struct sii8620 *ctx);\r\n} irq_vec[] = {\r\n{ BIT_FAST_INTR_STAT_DISC, sii8620_irq_disc },\r\n{ BIT_FAST_INTR_STAT_G2WB, sii8620_irq_g2wb },\r\n{ BIT_FAST_INTR_STAT_COC, sii8620_irq_coc },\r\n{ BIT_FAST_INTR_STAT_TDM, sii8620_irq_tdm },\r\n{ BIT_FAST_INTR_STAT_MSC, sii8620_irq_msc },\r\n{ BIT_FAST_INTR_STAT_MERR, sii8620_irq_merr },\r\n{ BIT_FAST_INTR_STAT_BLOCK, sii8620_irq_block },\r\n{ BIT_FAST_INTR_STAT_EDID, sii8620_irq_edid },\r\n{ BIT_FAST_INTR_STAT_DDC, sii8620_irq_ddc },\r\n{ BIT_FAST_INTR_STAT_SCDT, sii8620_irq_scdt },\r\n{ BIT_FAST_INTR_STAT_INFR, sii8620_irq_infr },\r\n};\r\nstruct sii8620 *ctx = data;\r\nu8 stats[LEN_FAST_INTR_STAT];\r\nint i, ret;\r\nmutex_lock(&ctx->lock);\r\nsii8620_read_buf(ctx, REG_FAST_INTR_STAT, stats, ARRAY_SIZE(stats));\r\nfor (i = 0; i < ARRAY_SIZE(irq_vec); ++i)\r\nif (sii8620_test_bit(irq_vec[i].bit, stats))\r\nirq_vec[i].handler(ctx);\r\nsii8620_burst_rx_all(ctx);\r\nsii8620_mt_work(ctx);\r\nsii8620_burst_send(ctx);\r\nret = sii8620_clear_error(ctx);\r\nif (ret) {\r\ndev_err(ctx->dev, "Error during IRQ handling, %d.\n", ret);\r\nsii8620_mhl_disconnected(ctx);\r\n}\r\nmutex_unlock(&ctx->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sii8620_cable_in(struct sii8620 *ctx)\r\n{\r\nstruct device *dev = ctx->dev;\r\nu8 ver[5];\r\nint ret;\r\nret = sii8620_hw_on(ctx);\r\nif (ret) {\r\ndev_err(dev, "Error powering on, %d.\n", ret);\r\nreturn;\r\n}\r\nsii8620_hw_reset(ctx);\r\nsii8620_read_buf(ctx, REG_VND_IDL, ver, ARRAY_SIZE(ver));\r\nret = sii8620_clear_error(ctx);\r\nif (ret) {\r\ndev_err(dev, "Error accessing I2C bus, %d.\n", ret);\r\nreturn;\r\n}\r\ndev_info(dev, "ChipID %02x%02x:%02x%02x rev %02x.\n", ver[1], ver[0],\r\nver[3], ver[2], ver[4]);\r\nsii8620_write(ctx, REG_DPD,\r\nBIT_DPD_PWRON_PLL | BIT_DPD_PDNTX12 | BIT_DPD_OSC_EN);\r\nsii8620_xtal_set_rate(ctx);\r\nsii8620_disconnect(ctx);\r\nsii8620_write_seq_static(ctx,\r\nREG_MHL_CBUS_CTL0, VAL_MHL_CBUS_CTL0_CBUS_DRV_SEL_STRONG\r\n| VAL_MHL_CBUS_CTL0_CBUS_RGND_VBIAS_734,\r\nREG_MHL_CBUS_CTL1, VAL_MHL_CBUS_CTL1_1115_OHM,\r\nREG_DPD, BIT_DPD_PWRON_PLL | BIT_DPD_PDNTX12 | BIT_DPD_OSC_EN,\r\n);\r\nret = sii8620_clear_error(ctx);\r\nif (ret) {\r\ndev_err(dev, "Error accessing I2C bus, %d.\n", ret);\r\nreturn;\r\n}\r\nenable_irq(to_i2c_client(ctx->dev)->irq);\r\n}\r\nstatic inline struct sii8620 *bridge_to_sii8620(struct drm_bridge *bridge)\r\n{\r\nreturn container_of(bridge, struct sii8620, bridge);\r\n}\r\nstatic bool sii8620_mode_fixup(struct drm_bridge *bridge,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct sii8620 *ctx = bridge_to_sii8620(bridge);\r\nint max_lclk;\r\nbool ret = true;\r\nmutex_lock(&ctx->lock);\r\nmax_lclk = sii8620_is_mhl3(ctx) ? MHL3_MAX_LCLK : MHL1_MAX_LCLK;\r\nif (max_lclk > 3 * adjusted_mode->clock) {\r\nctx->use_packed_pixel = 0;\r\ngoto end;\r\n}\r\nif ((ctx->devcap[MHL_DCAP_VID_LINK_MODE] & MHL_DCAP_VID_LINK_PPIXEL) &&\r\nmax_lclk > 2 * adjusted_mode->clock) {\r\nctx->use_packed_pixel = 1;\r\ngoto end;\r\n}\r\nret = false;\r\nend:\r\nif (ret) {\r\nu8 vic = drm_match_cea_mode(adjusted_mode);\r\nif (!vic) {\r\nunion hdmi_infoframe frm;\r\nu8 mhl_vic[] = { 0, 95, 94, 93, 98 };\r\ndrm_hdmi_vendor_infoframe_from_display_mode(\r\n&frm.vendor.hdmi, adjusted_mode);\r\nvic = frm.vendor.hdmi.vic;\r\nif (vic >= ARRAY_SIZE(mhl_vic))\r\nvic = 0;\r\nvic = mhl_vic[vic];\r\n}\r\nctx->video_code = vic;\r\nctx->pixel_clock = adjusted_mode->clock;\r\n}\r\nmutex_unlock(&ctx->lock);\r\nreturn ret;\r\n}\r\nstatic int sii8620_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct sii8620 *ctx;\r\nint ret;\r\nctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->dev = dev;\r\nmutex_init(&ctx->lock);\r\nINIT_LIST_HEAD(&ctx->mt_queue);\r\nctx->clk_xtal = devm_clk_get(dev, "xtal");\r\nif (IS_ERR(ctx->clk_xtal)) {\r\ndev_err(dev, "failed to get xtal clock from DT\n");\r\nreturn PTR_ERR(ctx->clk_xtal);\r\n}\r\nif (!client->irq) {\r\ndev_err(dev, "no irq provided\n");\r\nreturn -EINVAL;\r\n}\r\nirq_set_status_flags(client->irq, IRQ_NOAUTOEN);\r\nret = devm_request_threaded_irq(dev, client->irq, NULL,\r\nsii8620_irq_thread,\r\nIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\r\n"sii8620", ctx);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to install IRQ handler\n");\r\nreturn ret;\r\n}\r\nctx->gpio_reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);\r\nif (IS_ERR(ctx->gpio_reset)) {\r\ndev_err(dev, "failed to get reset gpio from DT\n");\r\nreturn PTR_ERR(ctx->gpio_reset);\r\n}\r\nctx->supplies[0].supply = "cvcc10";\r\nctx->supplies[1].supply = "iovcc18";\r\nret = devm_regulator_bulk_get(dev, 2, ctx->supplies);\r\nif (ret)\r\nreturn ret;\r\ni2c_set_clientdata(client, ctx);\r\nctx->bridge.funcs = &sii8620_bridge_funcs;\r\nctx->bridge.of_node = dev->of_node;\r\ndrm_bridge_add(&ctx->bridge);\r\nsii8620_cable_in(ctx);\r\nreturn 0;\r\n}\r\nstatic int sii8620_remove(struct i2c_client *client)\r\n{\r\nstruct sii8620 *ctx = i2c_get_clientdata(client);\r\ndisable_irq(to_i2c_client(ctx->dev)->irq);\r\ndrm_bridge_remove(&ctx->bridge);\r\nsii8620_hw_off(ctx);\r\nreturn 0;\r\n}
