int amdtp_motu_set_parameters(struct amdtp_stream *s, unsigned int rate,\r\nunsigned int midi_ports,\r\nstruct snd_motu_packet_format *formats)\r\n{\r\nstatic const struct {\r\nunsigned int quotient_ticks_per_event;\r\nunsigned int remainder_ticks_per_event;\r\n} params[] = {\r\n[CIP_SFC_44100] = { 557, 123 },\r\n[CIP_SFC_48000] = { 512, 0 },\r\n[CIP_SFC_88200] = { 278, 282 },\r\n[CIP_SFC_96000] = { 256, 0 },\r\n[CIP_SFC_176400] = { 139, 141 },\r\n[CIP_SFC_192000] = { 128, 0 },\r\n};\r\nstruct amdtp_motu *p = s->protocol;\r\nunsigned int pcm_chunks, data_chunks, data_block_quadlets;\r\nunsigned int delay;\r\nunsigned int mode;\r\nint i, err;\r\nif (amdtp_stream_running(s))\r\nreturn -EBUSY;\r\nfor (i = 0; i < ARRAY_SIZE(snd_motu_clock_rates); ++i) {\r\nif (snd_motu_clock_rates[i] == rate) {\r\nmode = i >> 1;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(snd_motu_clock_rates))\r\nreturn -EINVAL;\r\npcm_chunks = formats->fixed_part_pcm_chunks[mode] +\r\nformats->differed_part_pcm_chunks[mode];\r\ndata_chunks = formats->msg_chunks + pcm_chunks;\r\ndata_block_quadlets = 1 + DIV_ROUND_UP(data_chunks * 3, 4);\r\nerr = amdtp_stream_set_parameters(s, rate, data_block_quadlets);\r\nif (err < 0)\r\nreturn err;\r\np->pcm_chunks = pcm_chunks;\r\np->pcm_byte_offset = formats->pcm_byte_offset;\r\np->midi_ports = midi_ports;\r\np->midi_flag_offset = formats->midi_flag_offset;\r\np->midi_byte_offset = formats->midi_byte_offset;\r\np->midi_db_count = 0;\r\np->midi_db_interval = rate / MIDI_BYTES_PER_SECOND;\r\ndelay = 0x2e00;\r\ndelay += 8000 * 3072 * s->syt_interval / rate;\r\np->next_seconds = 0;\r\np->next_cycles = delay / 3072;\r\np->quotient_ticks_per_event = params[s->sfc].quotient_ticks_per_event;\r\np->remainder_ticks_per_event = params[s->sfc].remainder_ticks_per_event;\r\np->next_ticks = delay % 3072;\r\np->next_accumulated = 0;\r\nreturn 0;\r\n}\r\nstatic void read_pcm_s32(struct amdtp_stream *s,\r\nstruct snd_pcm_runtime *runtime,\r\n__be32 *buffer, unsigned int data_blocks)\r\n{\r\nstruct amdtp_motu *p = s->protocol;\r\nunsigned int channels, remaining_frames, i, c;\r\nu8 *byte;\r\nu32 *dst;\r\nchannels = p->pcm_chunks;\r\ndst = (void *)runtime->dma_area +\r\nframes_to_bytes(runtime, s->pcm_buffer_pointer);\r\nremaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;\r\nfor (i = 0; i < data_blocks; ++i) {\r\nbyte = (u8 *)buffer + p->pcm_byte_offset;\r\nfor (c = 0; c < channels; ++c) {\r\n*dst = (byte[0] << 24) | (byte[1] << 16) | byte[2];\r\nbyte += 3;\r\ndst++;\r\n}\r\nbuffer += s->data_block_quadlets;\r\nif (--remaining_frames == 0)\r\ndst = (void *)runtime->dma_area;\r\n}\r\n}\r\nstatic void write_pcm_s32(struct amdtp_stream *s,\r\nstruct snd_pcm_runtime *runtime,\r\n__be32 *buffer, unsigned int data_blocks)\r\n{\r\nstruct amdtp_motu *p = s->protocol;\r\nunsigned int channels, remaining_frames, i, c;\r\nu8 *byte;\r\nconst u32 *src;\r\nchannels = p->pcm_chunks;\r\nsrc = (void *)runtime->dma_area +\r\nframes_to_bytes(runtime, s->pcm_buffer_pointer);\r\nremaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;\r\nfor (i = 0; i < data_blocks; ++i) {\r\nbyte = (u8 *)buffer + p->pcm_byte_offset;\r\nfor (c = 0; c < channels; ++c) {\r\nbyte[0] = (*src >> 24) & 0xff;\r\nbyte[1] = (*src >> 16) & 0xff;\r\nbyte[2] = (*src >> 8) & 0xff;\r\nbyte += 3;\r\nsrc++;\r\n}\r\nbuffer += s->data_block_quadlets;\r\nif (--remaining_frames == 0)\r\nsrc = (void *)runtime->dma_area;\r\n}\r\n}\r\nstatic void write_pcm_silence(struct amdtp_stream *s, __be32 *buffer,\r\nunsigned int data_blocks)\r\n{\r\nstruct amdtp_motu *p = s->protocol;\r\nunsigned int channels, i, c;\r\nu8 *byte;\r\nchannels = p->pcm_chunks;\r\nfor (i = 0; i < data_blocks; ++i) {\r\nbyte = (u8 *)buffer + p->pcm_byte_offset;\r\nfor (c = 0; c < channels; ++c) {\r\nbyte[0] = 0;\r\nbyte[1] = 0;\r\nbyte[2] = 0;\r\nbyte += 3;\r\n}\r\nbuffer += s->data_block_quadlets;\r\n}\r\n}\r\nint amdtp_motu_add_pcm_hw_constraints(struct amdtp_stream *s,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nint err;\r\nerr = snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nif (err < 0)\r\nreturn err;\r\nreturn amdtp_stream_add_pcm_hw_constraints(s, runtime);\r\n}\r\nvoid amdtp_motu_midi_trigger(struct amdtp_stream *s, unsigned int port,\r\nstruct snd_rawmidi_substream *midi)\r\n{\r\nstruct amdtp_motu *p = s->protocol;\r\nif (port < p->midi_ports)\r\nWRITE_ONCE(p->midi, midi);\r\n}\r\nstatic void write_midi_messages(struct amdtp_stream *s, __be32 *buffer,\r\nunsigned int data_blocks)\r\n{\r\nstruct amdtp_motu *p = s->protocol;\r\nstruct snd_rawmidi_substream *midi = READ_ONCE(p->midi);\r\nu8 *b;\r\nint i;\r\nfor (i = 0; i < data_blocks; i++) {\r\nb = (u8 *)buffer;\r\nif (midi && p->midi_db_count == 0 &&\r\nsnd_rawmidi_transmit(midi, b + p->midi_byte_offset, 1) == 1) {\r\nb[p->midi_flag_offset] = 0x01;\r\n} else {\r\nb[p->midi_byte_offset] = 0x00;\r\nb[p->midi_flag_offset] = 0x00;\r\n}\r\nbuffer += s->data_block_quadlets;\r\nif (--p->midi_db_count < 0)\r\np->midi_db_count = p->midi_db_interval;\r\n}\r\n}\r\nstatic void read_midi_messages(struct amdtp_stream *s, __be32 *buffer,\r\nunsigned int data_blocks)\r\n{\r\nstruct amdtp_motu *p = s->protocol;\r\nstruct snd_rawmidi_substream *midi;\r\nu8 *b;\r\nint i;\r\nfor (i = 0; i < data_blocks; i++) {\r\nb = (u8 *)buffer;\r\nmidi = READ_ONCE(p->midi);\r\nif (midi && (b[p->midi_flag_offset] & 0x01))\r\nsnd_rawmidi_receive(midi, b + p->midi_byte_offset, 1);\r\nbuffer += s->data_block_quadlets;\r\n}\r\n}\r\nstatic void __maybe_unused copy_sph(u32 *frames, __be32 *buffer,\r\nunsigned int data_blocks,\r\nunsigned int data_block_quadlets)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < data_blocks; ++i) {\r\n*frames = be32_to_cpu(*buffer);\r\nbuffer += data_block_quadlets;\r\nframes++;\r\n}\r\n}\r\nstatic void __maybe_unused copy_message(u64 *frames, __be32 *buffer,\r\nunsigned int data_blocks,\r\nunsigned int data_block_quadlets)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < data_blocks; ++i) {\r\n*frames = (be32_to_cpu(buffer[1]) << 16) |\r\n(be32_to_cpu(buffer[2]) >> 16);\r\nbuffer += data_block_quadlets;\r\nframes++;\r\n}\r\n}\r\nstatic unsigned int process_tx_data_blocks(struct amdtp_stream *s,\r\n__be32 *buffer, unsigned int data_blocks,\r\nunsigned int *syt)\r\n{\r\nstruct amdtp_motu *p = s->protocol;\r\nstruct snd_pcm_substream *pcm;\r\ntrace_in_data_block_sph(s, data_blocks, buffer);\r\ntrace_in_data_block_message(s, data_blocks, buffer);\r\nif (p->midi_ports)\r\nread_midi_messages(s, buffer, data_blocks);\r\npcm = ACCESS_ONCE(s->pcm);\r\nif (data_blocks > 0 && pcm)\r\nread_pcm_s32(s, pcm->runtime, buffer, data_blocks);\r\nreturn data_blocks;\r\n}\r\nstatic inline void compute_next_elapse_from_start(struct amdtp_motu *p)\r\n{\r\np->next_accumulated += p->remainder_ticks_per_event;\r\nif (p->next_accumulated >= 441) {\r\np->next_accumulated -= 441;\r\np->next_ticks++;\r\n}\r\np->next_ticks += p->quotient_ticks_per_event;\r\nif (p->next_ticks >= 3072) {\r\np->next_ticks -= 3072;\r\np->next_cycles++;\r\n}\r\nif (p->next_cycles >= 8000) {\r\np->next_cycles -= 8000;\r\np->next_seconds++;\r\n}\r\nif (p->next_seconds >= 128)\r\np->next_seconds -= 128;\r\n}\r\nstatic void write_sph(struct amdtp_stream *s, __be32 *buffer,\r\nunsigned int data_blocks)\r\n{\r\nstruct amdtp_motu *p = s->protocol;\r\nunsigned int next_cycles;\r\nunsigned int i;\r\nu32 sph;\r\nfor (i = 0; i < data_blocks; i++) {\r\nnext_cycles = (s->start_cycle + p->next_cycles) % 8000;\r\nsph = ((next_cycles << 12) | p->next_ticks) & 0x01ffffff;\r\n*buffer = cpu_to_be32(sph);\r\ncompute_next_elapse_from_start(p);\r\nbuffer += s->data_block_quadlets;\r\n}\r\n}\r\nstatic unsigned int process_rx_data_blocks(struct amdtp_stream *s,\r\n__be32 *buffer, unsigned int data_blocks,\r\nunsigned int *syt)\r\n{\r\nstruct amdtp_motu *p = (struct amdtp_motu *)s->protocol;\r\nstruct snd_pcm_substream *pcm;\r\n*syt = 0xffff;\r\nif (p->midi_ports)\r\nwrite_midi_messages(s, buffer, data_blocks);\r\npcm = ACCESS_ONCE(s->pcm);\r\nif (pcm)\r\nwrite_pcm_s32(s, pcm->runtime, buffer, data_blocks);\r\nelse\r\nwrite_pcm_silence(s, buffer, data_blocks);\r\nwrite_sph(s, buffer, data_blocks);\r\ntrace_out_data_block_sph(s, data_blocks, buffer);\r\ntrace_out_data_block_message(s, data_blocks, buffer);\r\nreturn data_blocks;\r\n}\r\nint amdtp_motu_init(struct amdtp_stream *s, struct fw_unit *unit,\r\nenum amdtp_stream_direction dir,\r\nconst struct snd_motu_protocol *const protocol)\r\n{\r\namdtp_stream_process_data_blocks_t process_data_blocks;\r\nint fmt = CIP_FMT_MOTU;\r\nint flags = CIP_BLOCKING;\r\nint err;\r\nif (dir == AMDTP_IN_STREAM) {\r\nprocess_data_blocks = process_tx_data_blocks;\r\nif (protocol == &snd_motu_protocol_v3) {\r\nflags |= CIP_WRONG_DBS |\r\nCIP_SKIP_DBC_ZERO_CHECK |\r\nCIP_HEADER_WITHOUT_EOH;\r\nfmt = CIP_FMT_MOTU_TX_V3;\r\n}\r\n} else {\r\nprocess_data_blocks = process_rx_data_blocks;\r\nflags |= CIP_DBC_IS_END_EVENT;\r\n}\r\nerr = amdtp_stream_init(s, unit, dir, flags, fmt, process_data_blocks,\r\nsizeof(struct amdtp_motu));\r\nif (err < 0)\r\nreturn err;\r\ns->sph = 1;\r\ns->fdf = MOTU_FDF_AM824;\r\nreturn 0;\r\n}
