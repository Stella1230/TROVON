int wait_on_pending_writer(struct sock *sk, long *timeo)\r\n{\r\nint rc = 0;\r\nDEFINE_WAIT_FUNC(wait, woken_wake_function);\r\nadd_wait_queue(sk_sleep(sk), &wait);\r\nwhile (1) {\r\nif (!*timeo) {\r\nrc = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nrc = sock_intr_errno(*timeo);\r\nbreak;\r\n}\r\nif (sk_wait_event(sk, timeo, !sk->sk_write_pending, &wait))\r\nbreak;\r\n}\r\nremove_wait_queue(sk_sleep(sk), &wait);\r\nreturn rc;\r\n}\r\nint tls_push_sg(struct sock *sk,\r\nstruct tls_context *ctx,\r\nstruct scatterlist *sg,\r\nu16 first_offset,\r\nint flags)\r\n{\r\nint sendpage_flags = flags | MSG_SENDPAGE_NOTLAST;\r\nint ret = 0;\r\nstruct page *p;\r\nsize_t size;\r\nint offset = first_offset;\r\nsize = sg->length - offset;\r\noffset += sg->offset;\r\nwhile (1) {\r\nif (sg_is_last(sg))\r\nsendpage_flags = flags;\r\ntcp_rate_check_app_limited(sk);\r\np = sg_page(sg);\r\nretry:\r\nret = do_tcp_sendpages(sk, p, offset, size, sendpage_flags);\r\nif (ret != size) {\r\nif (ret > 0) {\r\noffset += ret;\r\nsize -= ret;\r\ngoto retry;\r\n}\r\noffset -= sg->offset;\r\nctx->partially_sent_offset = offset;\r\nctx->partially_sent_record = (void *)sg;\r\nreturn ret;\r\n}\r\nput_page(p);\r\nsk_mem_uncharge(sk, sg->length);\r\nsg = sg_next(sg);\r\nif (!sg)\r\nbreak;\r\noffset = sg->offset;\r\nsize = sg->length;\r\n}\r\nclear_bit(TLS_PENDING_CLOSED_RECORD, &ctx->flags);\r\nreturn 0;\r\n}\r\nstatic int tls_handle_open_record(struct sock *sk, int flags)\r\n{\r\nstruct tls_context *ctx = tls_get_ctx(sk);\r\nif (tls_is_pending_open_record(ctx))\r\nreturn ctx->push_pending_record(sk, flags);\r\nreturn 0;\r\n}\r\nint tls_proccess_cmsg(struct sock *sk, struct msghdr *msg,\r\nunsigned char *record_type)\r\n{\r\nstruct cmsghdr *cmsg;\r\nint rc = -EINVAL;\r\nfor_each_cmsghdr(cmsg, msg) {\r\nif (!CMSG_OK(msg, cmsg))\r\nreturn -EINVAL;\r\nif (cmsg->cmsg_level != SOL_TLS)\r\ncontinue;\r\nswitch (cmsg->cmsg_type) {\r\ncase TLS_SET_RECORD_TYPE:\r\nif (cmsg->cmsg_len < CMSG_LEN(sizeof(*record_type)))\r\nreturn -EINVAL;\r\nif (msg->msg_flags & MSG_MORE)\r\nreturn -EINVAL;\r\nrc = tls_handle_open_record(sk, msg->msg_flags);\r\nif (rc)\r\nreturn rc;\r\n*record_type = *(unsigned char *)CMSG_DATA(cmsg);\r\nrc = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nint tls_push_pending_closed_record(struct sock *sk, struct tls_context *ctx,\r\nint flags, long *timeo)\r\n{\r\nstruct scatterlist *sg;\r\nu16 offset;\r\nif (!tls_is_partially_sent_record(ctx))\r\nreturn ctx->push_pending_record(sk, flags);\r\nsg = ctx->partially_sent_record;\r\noffset = ctx->partially_sent_offset;\r\nctx->partially_sent_record = NULL;\r\nreturn tls_push_sg(sk, ctx, sg, offset, flags);\r\n}\r\nstatic void tls_write_space(struct sock *sk)\r\n{\r\nstruct tls_context *ctx = tls_get_ctx(sk);\r\nif (!sk->sk_write_pending && tls_is_pending_closed_record(ctx)) {\r\ngfp_t sk_allocation = sk->sk_allocation;\r\nint rc;\r\nlong timeo = 0;\r\nsk->sk_allocation = GFP_ATOMIC;\r\nrc = tls_push_pending_closed_record(sk, ctx,\r\nMSG_DONTWAIT |\r\nMSG_NOSIGNAL,\r\n&timeo);\r\nsk->sk_allocation = sk_allocation;\r\nif (rc < 0)\r\nreturn;\r\n}\r\nctx->sk_write_space(sk);\r\n}\r\nstatic void tls_sk_proto_close(struct sock *sk, long timeout)\r\n{\r\nstruct tls_context *ctx = tls_get_ctx(sk);\r\nlong timeo = sock_sndtimeo(sk, 0);\r\nvoid (*sk_proto_close)(struct sock *sk, long timeout);\r\nlock_sock(sk);\r\nif (!tls_complete_pending_work(sk, ctx, 0, &timeo))\r\ntls_handle_open_record(sk, 0);\r\nif (ctx->partially_sent_record) {\r\nstruct scatterlist *sg = ctx->partially_sent_record;\r\nwhile (1) {\r\nput_page(sg_page(sg));\r\nsk_mem_uncharge(sk, sg->length);\r\nif (sg_is_last(sg))\r\nbreak;\r\nsg++;\r\n}\r\n}\r\nctx->free_resources(sk);\r\nkfree(ctx->rec_seq);\r\nkfree(ctx->iv);\r\nsk_proto_close = ctx->sk_proto_close;\r\nkfree(ctx);\r\nrelease_sock(sk);\r\nsk_proto_close(sk, timeout);\r\n}\r\nstatic int do_tls_getsockopt_tx(struct sock *sk, char __user *optval,\r\nint __user *optlen)\r\n{\r\nint rc = 0;\r\nstruct tls_context *ctx = tls_get_ctx(sk);\r\nstruct tls_crypto_info *crypto_info;\r\nint len;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nif (!optval || (len < sizeof(*crypto_info))) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (!ctx) {\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\ncrypto_info = &ctx->crypto_send;\r\nif (!TLS_CRYPTO_INFO_READY(crypto_info)) {\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nif (len == sizeof(*crypto_info)) {\r\nif (copy_to_user(optval, crypto_info, sizeof(*crypto_info)))\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nswitch (crypto_info->cipher_type) {\r\ncase TLS_CIPHER_AES_GCM_128: {\r\nstruct tls12_crypto_info_aes_gcm_128 *\r\ncrypto_info_aes_gcm_128 =\r\ncontainer_of(crypto_info,\r\nstruct tls12_crypto_info_aes_gcm_128,\r\ninfo);\r\nif (len != sizeof(*crypto_info_aes_gcm_128)) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nlock_sock(sk);\r\nmemcpy(crypto_info_aes_gcm_128->iv, ctx->iv,\r\nTLS_CIPHER_AES_GCM_128_IV_SIZE);\r\nrelease_sock(sk);\r\nif (copy_to_user(optval,\r\ncrypto_info_aes_gcm_128,\r\nsizeof(*crypto_info_aes_gcm_128)))\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\ndefault:\r\nrc = -EINVAL;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int do_tls_getsockopt(struct sock *sk, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nint rc = 0;\r\nswitch (optname) {\r\ncase TLS_TX:\r\nrc = do_tls_getsockopt_tx(sk, optval, optlen);\r\nbreak;\r\ndefault:\r\nrc = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int tls_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct tls_context *ctx = tls_get_ctx(sk);\r\nif (level != SOL_TLS)\r\nreturn ctx->getsockopt(sk, level, optname, optval, optlen);\r\nreturn do_tls_getsockopt(sk, optname, optval, optlen);\r\n}\r\nstatic int do_tls_setsockopt_tx(struct sock *sk, char __user *optval,\r\nunsigned int optlen)\r\n{\r\nstruct tls_crypto_info *crypto_info, tmp_crypto_info;\r\nstruct tls_context *ctx = tls_get_ctx(sk);\r\nstruct proto *prot = NULL;\r\nint rc = 0;\r\nif (!optval || (optlen < sizeof(*crypto_info))) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = copy_from_user(&tmp_crypto_info, optval, sizeof(*crypto_info));\r\nif (rc) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nif (tmp_crypto_info.version != TLS_1_2_VERSION) {\r\nrc = -ENOTSUPP;\r\ngoto out;\r\n}\r\ncrypto_info = &ctx->crypto_send;\r\nif (TLS_CRYPTO_INFO_READY(crypto_info))\r\ngoto out;\r\nswitch (tmp_crypto_info.cipher_type) {\r\ncase TLS_CIPHER_AES_GCM_128: {\r\nif (optlen != sizeof(struct tls12_crypto_info_aes_gcm_128)) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = copy_from_user(\r\ncrypto_info,\r\noptval,\r\nsizeof(struct tls12_crypto_info_aes_gcm_128));\r\nif (rc) {\r\nrc = -EFAULT;\r\ngoto err_crypto_info;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nctx->sk_write_space = sk->sk_write_space;\r\nsk->sk_write_space = tls_write_space;\r\nctx->sk_proto_close = sk->sk_prot->close;\r\nrc = tls_set_sw_offload(sk, ctx);\r\nprot = &tls_sw_prot;\r\nif (rc)\r\ngoto err_crypto_info;\r\nsk->sk_prot = prot;\r\ngoto out;\r\nerr_crypto_info:\r\nmemset(crypto_info, 0, sizeof(*crypto_info));\r\nout:\r\nreturn rc;\r\n}\r\nstatic int do_tls_setsockopt(struct sock *sk, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nint rc = 0;\r\nswitch (optname) {\r\ncase TLS_TX:\r\nlock_sock(sk);\r\nrc = do_tls_setsockopt_tx(sk, optval, optlen);\r\nrelease_sock(sk);\r\nbreak;\r\ndefault:\r\nrc = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int tls_setsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct tls_context *ctx = tls_get_ctx(sk);\r\nif (level != SOL_TLS)\r\nreturn ctx->setsockopt(sk, level, optname, optval, optlen);\r\nreturn do_tls_setsockopt(sk, optname, optval, optlen);\r\n}\r\nstatic int tls_init(struct sock *sk)\r\n{\r\nstruct inet_connection_sock *icsk = inet_csk(sk);\r\nstruct tls_context *ctx;\r\nint rc = 0;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nicsk->icsk_ulp_data = ctx;\r\nctx->setsockopt = sk->sk_prot->setsockopt;\r\nctx->getsockopt = sk->sk_prot->getsockopt;\r\nsk->sk_prot = &tls_base_prot;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int __init tls_register(void)\r\n{\r\ntls_base_prot = tcp_prot;\r\ntls_base_prot.setsockopt = tls_setsockopt;\r\ntls_base_prot.getsockopt = tls_getsockopt;\r\ntls_sw_prot = tls_base_prot;\r\ntls_sw_prot.sendmsg = tls_sw_sendmsg;\r\ntls_sw_prot.sendpage = tls_sw_sendpage;\r\ntls_sw_prot.close = tls_sk_proto_close;\r\ntcp_register_ulp(&tcp_tls_ulp_ops);\r\nreturn 0;\r\n}\r\nstatic void __exit tls_unregister(void)\r\n{\r\ntcp_unregister_ulp(&tcp_tls_ulp_ops);\r\n}
