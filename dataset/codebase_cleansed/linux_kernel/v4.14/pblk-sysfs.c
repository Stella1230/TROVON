static ssize_t pblk_sysfs_luns_show(struct pblk *pblk, char *page)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct pblk_lun *rlun;\r\nssize_t sz = 0;\r\nint i;\r\nfor (i = 0; i < geo->nr_luns; i++) {\r\nint active = 1;\r\nrlun = &pblk->luns[i];\r\nif (!down_trylock(&rlun->wr_sem)) {\r\nactive = 0;\r\nup(&rlun->wr_sem);\r\n}\r\nsz += snprintf(page + sz, PAGE_SIZE - sz,\r\n"pblk: pos:%d, ch:%d, lun:%d - %d\n",\r\ni,\r\nrlun->bppa.g.ch,\r\nrlun->bppa.g.lun,\r\nactive);\r\n}\r\nreturn sz;\r\n}\r\nstatic ssize_t pblk_sysfs_rate_limiter(struct pblk *pblk, char *page)\r\n{\r\nint free_blocks, total_blocks;\r\nint rb_user_max, rb_user_cnt;\r\nint rb_gc_max, rb_gc_cnt, rb_budget, rb_state;\r\nfree_blocks = atomic_read(&pblk->rl.free_blocks);\r\nrb_user_max = pblk->rl.rb_user_max;\r\nrb_user_cnt = atomic_read(&pblk->rl.rb_user_cnt);\r\nrb_gc_max = pblk->rl.rb_gc_max;\r\nrb_gc_cnt = atomic_read(&pblk->rl.rb_gc_cnt);\r\nrb_budget = pblk->rl.rb_budget;\r\nrb_state = pblk->rl.rb_state;\r\ntotal_blocks = pblk->rl.total_blocks;\r\nreturn snprintf(page, PAGE_SIZE,\r\n"u:%u/%u,gc:%u/%u(%u/%u)(stop:<%u,full:>%u,free:%d/%d)-%d\n",\r\nrb_user_cnt,\r\nrb_user_max,\r\nrb_gc_cnt,\r\nrb_gc_max,\r\nrb_state,\r\nrb_budget,\r\npblk->rl.low,\r\npblk->rl.high,\r\nfree_blocks,\r\ntotal_blocks,\r\nREAD_ONCE(pblk->rl.rb_user_active));\r\n}\r\nstatic ssize_t pblk_sysfs_gc_state_show(struct pblk *pblk, char *page)\r\n{\r\nint gc_enabled, gc_active;\r\npblk_gc_sysfs_state_show(pblk, &gc_enabled, &gc_active);\r\nreturn snprintf(page, PAGE_SIZE, "gc_enabled=%d, gc_active=%d\n",\r\ngc_enabled, gc_active);\r\n}\r\nstatic ssize_t pblk_sysfs_stats(struct pblk *pblk, char *page)\r\n{\r\nssize_t sz;\r\nsz = snprintf(page, PAGE_SIZE,\r\n"read_failed=%lu, read_high_ecc=%lu, read_empty=%lu, read_failed_gc=%lu, write_failed=%lu, erase_failed=%lu\n",\r\natomic_long_read(&pblk->read_failed),\r\natomic_long_read(&pblk->read_high_ecc),\r\natomic_long_read(&pblk->read_empty),\r\natomic_long_read(&pblk->read_failed_gc),\r\natomic_long_read(&pblk->write_failed),\r\natomic_long_read(&pblk->erase_failed));\r\nreturn sz;\r\n}\r\nstatic ssize_t pblk_sysfs_write_buffer(struct pblk *pblk, char *page)\r\n{\r\nreturn pblk_rb_sysfs(&pblk->rwb, page);\r\n}\r\nstatic ssize_t pblk_sysfs_ppaf(struct pblk *pblk, char *page)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nssize_t sz = 0;\r\nsz = snprintf(page, PAGE_SIZE - sz,\r\n"g:(b:%d)blk:%d/%d,pg:%d/%d,lun:%d/%d,ch:%d/%d,pl:%d/%d,sec:%d/%d\n",\r\npblk->ppaf_bitsize,\r\npblk->ppaf.blk_offset, geo->ppaf.blk_len,\r\npblk->ppaf.pg_offset, geo->ppaf.pg_len,\r\npblk->ppaf.lun_offset, geo->ppaf.lun_len,\r\npblk->ppaf.ch_offset, geo->ppaf.ch_len,\r\npblk->ppaf.pln_offset, geo->ppaf.pln_len,\r\npblk->ppaf.sec_offset, geo->ppaf.sect_len);\r\nsz += snprintf(page + sz, PAGE_SIZE - sz,\r\n"d:blk:%d/%d,pg:%d/%d,lun:%d/%d,ch:%d/%d,pl:%d/%d,sec:%d/%d\n",\r\ngeo->ppaf.blk_offset, geo->ppaf.blk_len,\r\ngeo->ppaf.pg_offset, geo->ppaf.pg_len,\r\ngeo->ppaf.lun_offset, geo->ppaf.lun_len,\r\ngeo->ppaf.ch_offset, geo->ppaf.ch_len,\r\ngeo->ppaf.pln_offset, geo->ppaf.pln_len,\r\ngeo->ppaf.sect_offset, geo->ppaf.sect_len);\r\nreturn sz;\r\n}\r\nstatic ssize_t pblk_sysfs_lines(struct pblk *pblk, char *page)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct pblk_line_meta *lm = &pblk->lm;\r\nstruct pblk_line_mgmt *l_mg = &pblk->l_mg;\r\nstruct pblk_line *line;\r\nssize_t sz = 0;\r\nint nr_free_lines;\r\nint cur_data, cur_log;\r\nint free_line_cnt = 0, closed_line_cnt = 0, emeta_line_cnt = 0;\r\nint d_line_cnt = 0, l_line_cnt = 0;\r\nint gc_full = 0, gc_high = 0, gc_mid = 0, gc_low = 0, gc_empty = 0;\r\nint bad = 0, cor = 0;\r\nint msecs = 0, cur_sec = 0, vsc = 0, sec_in_line = 0;\r\nint map_weight = 0, meta_weight = 0;\r\nspin_lock(&l_mg->free_lock);\r\ncur_data = (l_mg->data_line) ? l_mg->data_line->id : -1;\r\ncur_log = (l_mg->log_line) ? l_mg->log_line->id : -1;\r\nnr_free_lines = l_mg->nr_free_lines;\r\nlist_for_each_entry(line, &l_mg->free_list, list)\r\nfree_line_cnt++;\r\nspin_unlock(&l_mg->free_lock);\r\nspin_lock(&l_mg->close_lock);\r\nlist_for_each_entry(line, &l_mg->emeta_list, list)\r\nemeta_line_cnt++;\r\nspin_unlock(&l_mg->close_lock);\r\nspin_lock(&l_mg->gc_lock);\r\nlist_for_each_entry(line, &l_mg->gc_full_list, list) {\r\nif (line->type == PBLK_LINETYPE_DATA)\r\nd_line_cnt++;\r\nelse if (line->type == PBLK_LINETYPE_LOG)\r\nl_line_cnt++;\r\nclosed_line_cnt++;\r\ngc_full++;\r\n}\r\nlist_for_each_entry(line, &l_mg->gc_high_list, list) {\r\nif (line->type == PBLK_LINETYPE_DATA)\r\nd_line_cnt++;\r\nelse if (line->type == PBLK_LINETYPE_LOG)\r\nl_line_cnt++;\r\nclosed_line_cnt++;\r\ngc_high++;\r\n}\r\nlist_for_each_entry(line, &l_mg->gc_mid_list, list) {\r\nif (line->type == PBLK_LINETYPE_DATA)\r\nd_line_cnt++;\r\nelse if (line->type == PBLK_LINETYPE_LOG)\r\nl_line_cnt++;\r\nclosed_line_cnt++;\r\ngc_mid++;\r\n}\r\nlist_for_each_entry(line, &l_mg->gc_low_list, list) {\r\nif (line->type == PBLK_LINETYPE_DATA)\r\nd_line_cnt++;\r\nelse if (line->type == PBLK_LINETYPE_LOG)\r\nl_line_cnt++;\r\nclosed_line_cnt++;\r\ngc_low++;\r\n}\r\nlist_for_each_entry(line, &l_mg->gc_empty_list, list) {\r\nif (line->type == PBLK_LINETYPE_DATA)\r\nd_line_cnt++;\r\nelse if (line->type == PBLK_LINETYPE_LOG)\r\nl_line_cnt++;\r\nclosed_line_cnt++;\r\ngc_empty++;\r\n}\r\nlist_for_each_entry(line, &l_mg->bad_list, list)\r\nbad++;\r\nlist_for_each_entry(line, &l_mg->corrupt_list, list)\r\ncor++;\r\nspin_unlock(&l_mg->gc_lock);\r\nspin_lock(&l_mg->free_lock);\r\nif (l_mg->data_line) {\r\ncur_sec = l_mg->data_line->cur_sec;\r\nmsecs = l_mg->data_line->left_msecs;\r\nvsc = le32_to_cpu(*l_mg->data_line->vsc);\r\nsec_in_line = l_mg->data_line->sec_in_line;\r\nmeta_weight = bitmap_weight(&l_mg->meta_bitmap,\r\nPBLK_DATA_LINES);\r\nmap_weight = bitmap_weight(l_mg->data_line->map_bitmap,\r\nlm->sec_per_line);\r\n}\r\nspin_unlock(&l_mg->free_lock);\r\nif (nr_free_lines != free_line_cnt)\r\npr_err("pblk: corrupted free line list:%d/%d\n",\r\nnr_free_lines, free_line_cnt);\r\nsz = snprintf(page, PAGE_SIZE - sz,\r\n"line: nluns:%d, nblks:%d, nsecs:%d\n",\r\ngeo->nr_luns, lm->blk_per_line, lm->sec_per_line);\r\nsz += snprintf(page + sz, PAGE_SIZE - sz,\r\n"lines:d:%d,l:%d-f:%d,m:%d/%d,c:%d,b:%d,co:%d(d:%d,l:%d)t:%d\n",\r\ncur_data, cur_log,\r\nnr_free_lines,\r\nemeta_line_cnt, meta_weight,\r\nclosed_line_cnt,\r\nbad, cor,\r\nd_line_cnt, l_line_cnt,\r\nl_mg->nr_lines);\r\nsz += snprintf(page + sz, PAGE_SIZE - sz,\r\n"GC: full:%d, high:%d, mid:%d, low:%d, empty:%d, queue:%d\n",\r\ngc_full, gc_high, gc_mid, gc_low, gc_empty,\r\natomic_read(&pblk->gc.inflight_gc));\r\nsz += snprintf(page + sz, PAGE_SIZE - sz,\r\n"data (%d) cur:%d, left:%d, vsc:%d, s:%d, map:%d/%d (%d)\n",\r\ncur_data, cur_sec, msecs, vsc, sec_in_line,\r\nmap_weight, lm->sec_per_line,\r\natomic_read(&pblk->inflight_io));\r\nreturn sz;\r\n}\r\nstatic ssize_t pblk_sysfs_lines_info(struct pblk *pblk, char *page)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct pblk_line_meta *lm = &pblk->lm;\r\nssize_t sz = 0;\r\nsz = snprintf(page, PAGE_SIZE - sz,\r\n"smeta - len:%d, secs:%d\n",\r\nlm->smeta_len, lm->smeta_sec);\r\nsz += snprintf(page + sz, PAGE_SIZE - sz,\r\n"emeta - len:%d, sec:%d, bb_start:%d\n",\r\nlm->emeta_len[0], lm->emeta_sec[0],\r\nlm->emeta_bb);\r\nsz += snprintf(page + sz, PAGE_SIZE - sz,\r\n"bitmap lengths: sec:%d, blk:%d, lun:%d\n",\r\nlm->sec_bitmap_len,\r\nlm->blk_bitmap_len,\r\nlm->lun_bitmap_len);\r\nsz += snprintf(page + sz, PAGE_SIZE - sz,\r\n"blk_line:%d, sec_line:%d, sec_blk:%d\n",\r\nlm->blk_per_line,\r\nlm->sec_per_line,\r\ngeo->sec_per_blk);\r\nreturn sz;\r\n}\r\nstatic ssize_t pblk_sysfs_get_sec_per_write(struct pblk *pblk, char *page)\r\n{\r\nreturn snprintf(page, PAGE_SIZE, "%d\n", pblk->sec_per_write);\r\n}\r\nstatic ssize_t pblk_sysfs_stats_debug(struct pblk *pblk, char *page)\r\n{\r\nreturn snprintf(page, PAGE_SIZE,\r\n"%lu\t%lu\t%lu\t%lu\t%lu\t%lu\t%lu\t%lu\t%lu\t%lu\t%lu\t%lu\t%lu\n",\r\natomic_long_read(&pblk->inflight_writes),\r\natomic_long_read(&pblk->inflight_reads),\r\natomic_long_read(&pblk->req_writes),\r\natomic_long_read(&pblk->nr_flush),\r\natomic_long_read(&pblk->padded_writes),\r\natomic_long_read(&pblk->padded_wb),\r\natomic_long_read(&pblk->sub_writes),\r\natomic_long_read(&pblk->sync_writes),\r\natomic_long_read(&pblk->recov_writes),\r\natomic_long_read(&pblk->recov_gc_writes),\r\natomic_long_read(&pblk->recov_gc_reads),\r\natomic_long_read(&pblk->cache_reads),\r\natomic_long_read(&pblk->sync_reads));\r\n}\r\nstatic ssize_t pblk_sysfs_gc_force(struct pblk *pblk, const char *page,\r\nsize_t len)\r\n{\r\nsize_t c_len;\r\nint force;\r\nc_len = strcspn(page, "\n");\r\nif (c_len >= len)\r\nreturn -EINVAL;\r\nif (kstrtouint(page, 0, &force))\r\nreturn -EINVAL;\r\npblk_gc_sysfs_force(pblk, force);\r\nreturn len;\r\n}\r\nstatic ssize_t pblk_sysfs_set_sec_per_write(struct pblk *pblk,\r\nconst char *page, size_t len)\r\n{\r\nsize_t c_len;\r\nint sec_per_write;\r\nc_len = strcspn(page, "\n");\r\nif (c_len >= len)\r\nreturn -EINVAL;\r\nif (kstrtouint(page, 0, &sec_per_write))\r\nreturn -EINVAL;\r\nif (sec_per_write < pblk->min_write_pgs\r\n|| sec_per_write > pblk->max_write_pgs\r\n|| sec_per_write % pblk->min_write_pgs != 0)\r\nreturn -EINVAL;\r\npblk_set_sec_per_write(pblk, sec_per_write);\r\nreturn len;\r\n}\r\nstatic ssize_t pblk_sysfs_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct pblk *pblk = container_of(kobj, struct pblk, kobj);\r\nif (strcmp(attr->name, "rate_limiter") == 0)\r\nreturn pblk_sysfs_rate_limiter(pblk, buf);\r\nelse if (strcmp(attr->name, "write_luns") == 0)\r\nreturn pblk_sysfs_luns_show(pblk, buf);\r\nelse if (strcmp(attr->name, "gc_state") == 0)\r\nreturn pblk_sysfs_gc_state_show(pblk, buf);\r\nelse if (strcmp(attr->name, "errors") == 0)\r\nreturn pblk_sysfs_stats(pblk, buf);\r\nelse if (strcmp(attr->name, "write_buffer") == 0)\r\nreturn pblk_sysfs_write_buffer(pblk, buf);\r\nelse if (strcmp(attr->name, "ppa_format") == 0)\r\nreturn pblk_sysfs_ppaf(pblk, buf);\r\nelse if (strcmp(attr->name, "lines") == 0)\r\nreturn pblk_sysfs_lines(pblk, buf);\r\nelse if (strcmp(attr->name, "lines_info") == 0)\r\nreturn pblk_sysfs_lines_info(pblk, buf);\r\nelse if (strcmp(attr->name, "max_sec_per_write") == 0)\r\nreturn pblk_sysfs_get_sec_per_write(pblk, buf);\r\n#ifdef CONFIG_NVM_DEBUG\r\nelse if (strcmp(attr->name, "stats") == 0)\r\nreturn pblk_sysfs_stats_debug(pblk, buf);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic ssize_t pblk_sysfs_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct pblk *pblk = container_of(kobj, struct pblk, kobj);\r\nif (strcmp(attr->name, "gc_force") == 0)\r\nreturn pblk_sysfs_gc_force(pblk, buf, len);\r\nelse if (strcmp(attr->name, "max_sec_per_write") == 0)\r\nreturn pblk_sysfs_set_sec_per_write(pblk, buf, len);\r\nreturn 0;\r\n}\r\nint pblk_sysfs_init(struct gendisk *tdisk)\r\n{\r\nstruct pblk *pblk = tdisk->private_data;\r\nstruct device *parent_dev = disk_to_dev(pblk->disk);\r\nint ret;\r\nret = kobject_init_and_add(&pblk->kobj, &pblk_ktype,\r\nkobject_get(&parent_dev->kobj),\r\n"%s", "pblk");\r\nif (ret) {\r\npr_err("pblk: could not register %s/pblk\n",\r\ntdisk->disk_name);\r\nreturn ret;\r\n}\r\nkobject_uevent(&pblk->kobj, KOBJ_ADD);\r\nreturn 0;\r\n}\r\nvoid pblk_sysfs_exit(struct gendisk *tdisk)\r\n{\r\nstruct pblk *pblk = tdisk->private_data;\r\nkobject_uevent(&pblk->kobj, KOBJ_REMOVE);\r\nkobject_del(&pblk->kobj);\r\nkobject_put(&pblk->kobj);\r\n}
