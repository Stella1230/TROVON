static void free_if_spi_card(struct if_spi_card *card)\r\n{\r\nstruct list_head *cursor, *next;\r\nstruct if_spi_packet *packet;\r\nlist_for_each_safe(cursor, next, &card->cmd_packet_list) {\r\npacket = container_of(cursor, struct if_spi_packet, list);\r\nlist_del(&packet->list);\r\nkfree(packet);\r\n}\r\nlist_for_each_safe(cursor, next, &card->data_packet_list) {\r\npacket = container_of(cursor, struct if_spi_packet, list);\r\nlist_del(&packet->list);\r\nkfree(packet);\r\n}\r\nkfree(card);\r\n}\r\nstatic void spu_transaction_init(struct if_spi_card *card)\r\n{\r\nif (!time_after(jiffies, card->prev_xfer_time + 1)) {\r\nndelay(400);\r\n}\r\n}\r\nstatic void spu_transaction_finish(struct if_spi_card *card)\r\n{\r\ncard->prev_xfer_time = jiffies;\r\n}\r\nstatic int spu_write(struct if_spi_card *card, u16 reg, const u8 *buf, int len)\r\n{\r\nint err = 0;\r\n__le16 reg_out = cpu_to_le16(reg | IF_SPI_WRITE_OPERATION_MASK);\r\nstruct spi_message m;\r\nstruct spi_transfer reg_trans;\r\nstruct spi_transfer data_trans;\r\nspi_message_init(&m);\r\nmemset(&reg_trans, 0, sizeof(reg_trans));\r\nmemset(&data_trans, 0, sizeof(data_trans));\r\nBUG_ON(len & 0x1);\r\nspu_transaction_init(card);\r\nreg_trans.tx_buf = &reg_out;\r\nreg_trans.len = sizeof(reg_out);\r\ndata_trans.tx_buf = buf;\r\ndata_trans.len = len;\r\nspi_message_add_tail(&reg_trans, &m);\r\nspi_message_add_tail(&data_trans, &m);\r\nerr = spi_sync(card->spi, &m);\r\nspu_transaction_finish(card);\r\nreturn err;\r\n}\r\nstatic inline int spu_write_u16(struct if_spi_card *card, u16 reg, u16 val)\r\n{\r\n__le16 buff;\r\nbuff = cpu_to_le16(val);\r\nreturn spu_write(card, reg, (u8 *)&buff, sizeof(u16));\r\n}\r\nstatic inline int spu_reg_is_port_reg(u16 reg)\r\n{\r\nswitch (reg) {\r\ncase IF_SPI_IO_RDWRPORT_REG:\r\ncase IF_SPI_CMD_RDWRPORT_REG:\r\ncase IF_SPI_DATA_RDWRPORT_REG:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int spu_read(struct if_spi_card *card, u16 reg, u8 *buf, int len)\r\n{\r\nunsigned int delay;\r\nint err = 0;\r\n__le16 reg_out = cpu_to_le16(reg | IF_SPI_READ_OPERATION_MASK);\r\nstruct spi_message m;\r\nstruct spi_transfer reg_trans;\r\nstruct spi_transfer dummy_trans;\r\nstruct spi_transfer data_trans;\r\nBUG_ON(len & 0x1);\r\nspu_transaction_init(card);\r\nspi_message_init(&m);\r\nmemset(&reg_trans, 0, sizeof(reg_trans));\r\nmemset(&dummy_trans, 0, sizeof(dummy_trans));\r\nmemset(&data_trans, 0, sizeof(data_trans));\r\nreg_trans.tx_buf = &reg_out;\r\nreg_trans.len = sizeof(reg_out);\r\nspi_message_add_tail(&reg_trans, &m);\r\ndelay = spu_reg_is_port_reg(reg) ? card->spu_port_delay :\r\ncard->spu_reg_delay;\r\nif (card->use_dummy_writes) {\r\ndummy_trans.len = delay / 8;\r\nspi_message_add_tail(&dummy_trans, &m);\r\n} else {\r\nreg_trans.delay_usecs =\r\nDIV_ROUND_UP((100 + (delay * 10)), 1000);\r\n}\r\ndata_trans.rx_buf = buf;\r\ndata_trans.len = len;\r\nspi_message_add_tail(&data_trans, &m);\r\nerr = spi_sync(card->spi, &m);\r\nspu_transaction_finish(card);\r\nreturn err;\r\n}\r\nstatic inline int spu_read_u16(struct if_spi_card *card, u16 reg, u16 *val)\r\n{\r\n__le16 buf;\r\nint ret;\r\nret = spu_read(card, reg, (u8 *)&buf, sizeof(buf));\r\nif (ret == 0)\r\n*val = le16_to_cpup(&buf);\r\nreturn ret;\r\n}\r\nstatic int spu_read_u32(struct if_spi_card *card, u16 reg, u32 *val)\r\n{\r\n__le32 buf;\r\nint err;\r\nerr = spu_read(card, reg, (u8 *)&buf, sizeof(buf));\r\nif (!err)\r\n*val = le32_to_cpup(&buf);\r\nreturn err;\r\n}\r\nstatic int spu_wait_for_u16(struct if_spi_card *card, u16 reg,\r\nu16 target_mask, u16 target)\r\n{\r\nint err;\r\nunsigned long timeout = jiffies + 5*HZ;\r\nwhile (1) {\r\nu16 val;\r\nerr = spu_read_u16(card, reg, &val);\r\nif (err)\r\nreturn err;\r\nif (target_mask) {\r\nif ((val & target_mask) == target)\r\nreturn 0;\r\n} else {\r\nif (val)\r\nreturn 0;\r\n}\r\nudelay(100);\r\nif (time_after(jiffies, timeout)) {\r\npr_err("%s: timeout with val=%02x, target_mask=%02x, target=%02x\n",\r\n__func__, val, target_mask, target);\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\n}\r\nstatic int spu_wait_for_u32(struct if_spi_card *card, u32 reg, u32 target)\r\n{\r\nint err, try;\r\nfor (try = 0; try < 4; ++try) {\r\nu32 val = 0;\r\nerr = spu_read_u32(card, reg, &val);\r\nif (err)\r\nreturn err;\r\nif (val == target)\r\nreturn 0;\r\nmdelay(100);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int spu_set_interrupt_mode(struct if_spi_card *card,\r\nint suppress_host_int,\r\nint auto_int)\r\n{\r\nint err = 0;\r\nif (suppress_host_int) {\r\nerr = spu_write_u16(card, IF_SPI_HOST_INT_STATUS_MASK_REG, 0);\r\nif (err)\r\nreturn err;\r\n} else {\r\nerr = spu_write_u16(card, IF_SPI_HOST_INT_STATUS_MASK_REG,\r\nIF_SPI_HISM_TX_DOWNLOAD_RDY |\r\nIF_SPI_HISM_RX_UPLOAD_RDY |\r\nIF_SPI_HISM_CMD_DOWNLOAD_RDY |\r\nIF_SPI_HISM_CARDEVENT |\r\nIF_SPI_HISM_CMD_UPLOAD_RDY);\r\nif (err)\r\nreturn err;\r\n}\r\nif (auto_int) {\r\nerr = spu_write_u16(card, IF_SPI_HOST_INT_CTRL_REG,\r\nIF_SPI_HICT_TX_DOWNLOAD_OVER_AUTO |\r\nIF_SPI_HICT_RX_UPLOAD_OVER_AUTO |\r\nIF_SPI_HICT_CMD_DOWNLOAD_OVER_AUTO |\r\nIF_SPI_HICT_CMD_UPLOAD_OVER_AUTO);\r\nif (err)\r\nreturn err;\r\n} else {\r\nerr = spu_write_u16(card, IF_SPI_HOST_INT_STATUS_MASK_REG, 0);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int spu_get_chip_revision(struct if_spi_card *card,\r\nu16 *card_id, u8 *card_rev)\r\n{\r\nint err = 0;\r\nu32 dev_ctrl;\r\nerr = spu_read_u32(card, IF_SPI_DEVICEID_CTRL_REG, &dev_ctrl);\r\nif (err)\r\nreturn err;\r\n*card_id = IF_SPI_DEVICEID_CTRL_REG_TO_CARD_ID(dev_ctrl);\r\n*card_rev = IF_SPI_DEVICEID_CTRL_REG_TO_CARD_REV(dev_ctrl);\r\nreturn err;\r\n}\r\nstatic int spu_set_bus_mode(struct if_spi_card *card, u16 mode)\r\n{\r\nint err = 0;\r\nu16 rval;\r\nerr = spu_write_u16(card, IF_SPI_SPU_BUS_MODE_REG, mode);\r\nif (err)\r\nreturn err;\r\nerr = spu_read_u16(card, IF_SPI_SPU_BUS_MODE_REG, &rval);\r\nif (err)\r\nreturn err;\r\nif ((rval & 0xF) != mode) {\r\npr_err("Can't read bus mode register\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int spu_init(struct if_spi_card *card, int use_dummy_writes)\r\n{\r\nint err = 0;\r\nu32 delay;\r\ncard->use_dummy_writes = 0;\r\nerr = spu_set_bus_mode(card,\r\nIF_SPI_BUS_MODE_SPI_CLOCK_PHASE_RISING |\r\nIF_SPI_BUS_MODE_DELAY_METHOD_TIMED |\r\nIF_SPI_BUS_MODE_16_BIT_ADDRESS_16_BIT_DATA);\r\nif (err)\r\nreturn err;\r\ncard->spu_port_delay = 1000;\r\ncard->spu_reg_delay = 1000;\r\nerr = spu_read_u32(card, IF_SPI_DELAY_READ_REG, &delay);\r\nif (err)\r\nreturn err;\r\ncard->spu_port_delay = delay & 0x0000ffff;\r\ncard->spu_reg_delay = (delay & 0xffff0000) >> 16;\r\nif (use_dummy_writes) {\r\ncard->use_dummy_writes = 1;\r\nerr = spu_set_bus_mode(card,\r\nIF_SPI_BUS_MODE_SPI_CLOCK_PHASE_RISING |\r\nIF_SPI_BUS_MODE_DELAY_METHOD_DUMMY_CLOCK |\r\nIF_SPI_BUS_MODE_16_BIT_ADDRESS_16_BIT_DATA);\r\nif (err)\r\nreturn err;\r\n}\r\nlbs_deb_spi("Initialized SPU unit. "\r\n"spu_port_delay=0x%04lx, spu_reg_delay=0x%04lx\n",\r\ncard->spu_port_delay, card->spu_reg_delay);\r\nreturn err;\r\n}\r\nstatic int if_spi_prog_helper_firmware(struct if_spi_card *card,\r\nconst struct firmware *firmware)\r\n{\r\nint err = 0;\r\nint bytes_remaining;\r\nconst u8 *fw;\r\nu8 temp[HELPER_FW_LOAD_CHUNK_SZ];\r\nerr = spu_set_interrupt_mode(card, 1, 0);\r\nif (err)\r\ngoto out;\r\nbytes_remaining = firmware->size;\r\nfw = firmware->data;\r\nwhile (bytes_remaining > 0) {\r\nerr = spu_write_u16(card, IF_SPI_SCRATCH_1_REG,\r\nHELPER_FW_LOAD_CHUNK_SZ);\r\nif (err)\r\ngoto out;\r\nerr = spu_wait_for_u16(card, IF_SPI_HOST_INT_STATUS_REG,\r\nIF_SPI_HIST_CMD_DOWNLOAD_RDY,\r\nIF_SPI_HIST_CMD_DOWNLOAD_RDY);\r\nif (err)\r\ngoto out;\r\nmemset(temp, 0, sizeof(temp));\r\nmemcpy(temp, fw,\r\nmin(bytes_remaining, HELPER_FW_LOAD_CHUNK_SZ));\r\nmdelay(10);\r\nerr = spu_write(card, IF_SPI_CMD_RDWRPORT_REG,\r\ntemp, HELPER_FW_LOAD_CHUNK_SZ);\r\nif (err)\r\ngoto out;\r\nerr = spu_write_u16(card, IF_SPI_HOST_INT_STATUS_REG, 0);\r\nif (err)\r\ngoto out;\r\nerr = spu_write_u16(card, IF_SPI_CARD_INT_CAUSE_REG,\r\nIF_SPI_CIC_CMD_DOWNLOAD_OVER);\r\nif (err)\r\ngoto out;\r\nbytes_remaining -= HELPER_FW_LOAD_CHUNK_SZ;\r\nfw += HELPER_FW_LOAD_CHUNK_SZ;\r\n}\r\nerr = spu_write_u16(card, IF_SPI_SCRATCH_1_REG, FIRMWARE_DNLD_OK);\r\nif (err)\r\ngoto out;\r\nerr = spu_write_u16(card, IF_SPI_HOST_INT_STATUS_REG, 0);\r\nif (err)\r\ngoto out;\r\nerr = spu_write_u16(card, IF_SPI_CARD_INT_CAUSE_REG,\r\nIF_SPI_CIC_CMD_DOWNLOAD_OVER);\r\nout:\r\nif (err)\r\npr_err("failed to load helper firmware (err=%d)\n", err);\r\nreturn err;\r\n}\r\nstatic int if_spi_prog_main_firmware_check_len(struct if_spi_card *card,\r\nint *crc_err)\r\n{\r\nu16 len;\r\nint err = 0;\r\nerr = spu_wait_for_u16(card, IF_SPI_HOST_INT_STATUS_REG,\r\nIF_SPI_HIST_CMD_DOWNLOAD_RDY,\r\nIF_SPI_HIST_CMD_DOWNLOAD_RDY);\r\nif (err) {\r\npr_err("timed out waiting for host_int_status\n");\r\nreturn err;\r\n}\r\nerr = spu_read_u16(card, IF_SPI_SCRATCH_1_REG, &len);\r\nif (err)\r\nreturn err;\r\nif (len > IF_SPI_CMD_BUF_SIZE) {\r\npr_err("firmware load device requested a larger transfer than we are prepared to handle (len = %d)\n",\r\nlen);\r\nreturn -EIO;\r\n}\r\nif (len & 0x1) {\r\nlbs_deb_spi("%s: crc error\n", __func__);\r\nlen &= ~0x1;\r\n*crc_err = 1;\r\n} else\r\n*crc_err = 0;\r\nreturn len;\r\n}\r\nstatic int if_spi_prog_main_firmware(struct if_spi_card *card,\r\nconst struct firmware *firmware)\r\n{\r\nstruct lbs_private *priv = card->priv;\r\nint len, prev_len;\r\nint bytes, crc_err = 0, err = 0;\r\nconst u8 *fw;\r\nu16 num_crc_errs;\r\nerr = spu_set_interrupt_mode(card, 1, 0);\r\nif (err)\r\ngoto out;\r\nerr = spu_wait_for_u16(card, IF_SPI_SCRATCH_1_REG, 0, 0);\r\nif (err) {\r\nnetdev_err(priv->dev,\r\n"%s: timed out waiting for initial scratch reg = 0\n",\r\n__func__);\r\ngoto out;\r\n}\r\nnum_crc_errs = 0;\r\nprev_len = 0;\r\nbytes = firmware->size;\r\nfw = firmware->data;\r\nwhile ((len = if_spi_prog_main_firmware_check_len(card, &crc_err))) {\r\nif (len < 0) {\r\nerr = len;\r\ngoto out;\r\n}\r\nif (bytes < 0) {\r\nnetdev_err(priv->dev,\r\n"Firmware load wants more bytes than we have to offer.\n");\r\nbreak;\r\n}\r\nif (crc_err) {\r\nif (++num_crc_errs > MAX_MAIN_FW_LOAD_CRC_ERR) {\r\npr_err("Too many CRC errors encountered in firmware load.\n");\r\nerr = -EIO;\r\ngoto out;\r\n}\r\n} else {\r\nbytes -= prev_len;\r\nfw += prev_len;\r\n}\r\nif (bytes < len) {\r\nmemset(card->cmd_buffer, 0, len);\r\nmemcpy(card->cmd_buffer, fw, bytes);\r\n} else\r\nmemcpy(card->cmd_buffer, fw, len);\r\nerr = spu_write_u16(card, IF_SPI_HOST_INT_STATUS_REG, 0);\r\nif (err)\r\ngoto out;\r\nerr = spu_write(card, IF_SPI_CMD_RDWRPORT_REG,\r\ncard->cmd_buffer, len);\r\nif (err)\r\ngoto out;\r\nerr = spu_write_u16(card, IF_SPI_CARD_INT_CAUSE_REG ,\r\nIF_SPI_CIC_CMD_DOWNLOAD_OVER);\r\nif (err)\r\ngoto out;\r\nprev_len = len;\r\n}\r\nif (bytes > prev_len) {\r\npr_err("firmware load wants fewer bytes than we have to offer\n");\r\n}\r\nerr = spu_wait_for_u32(card, IF_SPI_SCRATCH_4_REG,\r\nSUCCESSFUL_FW_DOWNLOAD_MAGIC);\r\nif (err) {\r\npr_err("failed to confirm the firmware download\n");\r\ngoto out;\r\n}\r\nout:\r\nif (err)\r\npr_err("failed to load firmware (err=%d)\n", err);\r\nreturn err;\r\n}\r\nstatic int if_spi_c2h_cmd(struct if_spi_card *card)\r\n{\r\nstruct lbs_private *priv = card->priv;\r\nunsigned long flags;\r\nint err = 0;\r\nu16 len;\r\nu8 i;\r\nBUILD_BUG_ON(IF_SPI_CMD_BUF_SIZE < LBS_CMD_BUFFER_SIZE);\r\nBUILD_BUG_ON(IF_SPI_CMD_BUF_SIZE < LBS_UPLD_SIZE);\r\nBUILD_BUG_ON(IF_SPI_CMD_BUF_SIZE % 4 != 0);\r\nerr = spu_read_u16(card, IF_SPI_SCRATCH_2_REG, &len);\r\nif (err)\r\ngoto out;\r\nif (!len) {\r\nnetdev_err(priv->dev, "%s: error: card has no data for host\n",\r\n__func__);\r\nerr = -EINVAL;\r\ngoto out;\r\n} else if (len > IF_SPI_CMD_BUF_SIZE) {\r\nnetdev_err(priv->dev,\r\n"%s: error: response packet too large: %d bytes, but maximum is %d\n",\r\n__func__, len, IF_SPI_CMD_BUF_SIZE);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nerr = spu_read(card, IF_SPI_CMD_RDWRPORT_REG,\r\ncard->cmd_buffer, ALIGN(len, 4));\r\nif (err)\r\ngoto out;\r\nspin_lock_irqsave(&priv->driver_lock, flags);\r\ni = (priv->resp_idx == 0) ? 1 : 0;\r\nBUG_ON(priv->resp_len[i]);\r\npriv->resp_len[i] = len;\r\nmemcpy(priv->resp_buf[i], card->cmd_buffer, len);\r\nlbs_notify_command_response(priv, i);\r\nspin_unlock_irqrestore(&priv->driver_lock, flags);\r\nout:\r\nif (err)\r\nnetdev_err(priv->dev, "%s: err=%d\n", __func__, err);\r\nreturn err;\r\n}\r\nstatic int if_spi_c2h_data(struct if_spi_card *card)\r\n{\r\nstruct lbs_private *priv = card->priv;\r\nstruct sk_buff *skb;\r\nchar *data;\r\nu16 len;\r\nint err = 0;\r\nerr = spu_read_u16(card, IF_SPI_SCRATCH_1_REG, &len);\r\nif (err)\r\ngoto out;\r\nif (!len) {\r\nnetdev_err(priv->dev, "%s: error: card has no data for host\n",\r\n__func__);\r\nerr = -EINVAL;\r\ngoto out;\r\n} else if (len > MRVDRV_ETH_RX_PACKET_BUFFER_SIZE) {\r\nnetdev_err(priv->dev,\r\n"%s: error: card has %d bytes of data, but our maximum skb size is %zu\n",\r\n__func__, len, MRVDRV_ETH_RX_PACKET_BUFFER_SIZE);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nskb = dev_alloc_skb(MRVDRV_ETH_RX_PACKET_BUFFER_SIZE);\r\nif (!skb) {\r\nerr = -ENOBUFS;\r\ngoto out;\r\n}\r\nskb_reserve(skb, IPFIELD_ALIGN_OFFSET);\r\ndata = skb_put(skb, len);\r\nerr = spu_read(card, IF_SPI_DATA_RDWRPORT_REG, data, ALIGN(len, 4));\r\nif (err)\r\ngoto free_skb;\r\nerr = lbs_process_rxed_packet(card->priv, skb);\r\nif (err)\r\ngoto free_skb;\r\ngoto out;\r\nfree_skb:\r\ndev_kfree_skb(skb);\r\nout:\r\nif (err)\r\nnetdev_err(priv->dev, "%s: err=%d\n", __func__, err);\r\nreturn err;\r\n}\r\nstatic void if_spi_h2c(struct if_spi_card *card,\r\nstruct if_spi_packet *packet, int type)\r\n{\r\nstruct lbs_private *priv = card->priv;\r\nint err = 0;\r\nu16 int_type, port_reg;\r\nswitch (type) {\r\ncase MVMS_DAT:\r\nint_type = IF_SPI_CIC_TX_DOWNLOAD_OVER;\r\nport_reg = IF_SPI_DATA_RDWRPORT_REG;\r\nbreak;\r\ncase MVMS_CMD:\r\nint_type = IF_SPI_CIC_CMD_DOWNLOAD_OVER;\r\nport_reg = IF_SPI_CMD_RDWRPORT_REG;\r\nbreak;\r\ndefault:\r\nnetdev_err(priv->dev, "can't transfer buffer of type %d\n",\r\ntype);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nerr = spu_write(card, port_reg, packet->buffer, packet->blen);\r\nif (err)\r\ngoto out;\r\nout:\r\nkfree(packet);\r\nif (err)\r\nnetdev_err(priv->dev, "%s: error %d\n", __func__, err);\r\n}\r\nstatic void if_spi_e2h(struct if_spi_card *card)\r\n{\r\nint err = 0;\r\nu32 cause;\r\nstruct lbs_private *priv = card->priv;\r\nerr = spu_read_u32(card, IF_SPI_SCRATCH_3_REG, &cause);\r\nif (err)\r\ngoto out;\r\nspu_write_u16(card, IF_SPI_HOST_INT_STATUS_REG,\r\n~IF_SPI_HICU_CARD_EVENT);\r\nspu_write_u16(card, IF_SPI_CARD_INT_CAUSE_REG, IF_SPI_CIC_HOST_EVENT);\r\nlbs_queue_event(priv, cause & 0xff);\r\nout:\r\nif (err)\r\nnetdev_err(priv->dev, "%s: error %d\n", __func__, err);\r\n}\r\nstatic void if_spi_host_to_card_worker(struct work_struct *work)\r\n{\r\nint err;\r\nstruct if_spi_card *card;\r\nu16 hiStatus;\r\nunsigned long flags;\r\nstruct if_spi_packet *packet;\r\nstruct lbs_private *priv;\r\ncard = container_of(work, struct if_spi_card, packet_work);\r\npriv = card->priv;\r\nerr = spu_read_u16(card, IF_SPI_HOST_INT_STATUS_REG,\r\n&hiStatus);\r\nif (err) {\r\nnetdev_err(priv->dev, "I/O error\n");\r\ngoto err;\r\n}\r\nif (hiStatus & IF_SPI_HIST_CMD_UPLOAD_RDY) {\r\nerr = if_spi_c2h_cmd(card);\r\nif (err)\r\ngoto err;\r\n}\r\nif (hiStatus & IF_SPI_HIST_RX_UPLOAD_RDY) {\r\nerr = if_spi_c2h_data(card);\r\nif (err)\r\ngoto err;\r\n}\r\nif (hiStatus & IF_SPI_HIST_CMD_DOWNLOAD_RDY ||\r\n(card->priv->psstate != PS_STATE_FULL_POWER &&\r\n(hiStatus & IF_SPI_HIST_TX_DOWNLOAD_RDY))) {\r\nlbs_host_to_card_done(card->priv);\r\npacket = NULL;\r\nspin_lock_irqsave(&card->buffer_lock, flags);\r\nif (!list_empty(&card->cmd_packet_list)) {\r\npacket = (struct if_spi_packet *)(card->\r\ncmd_packet_list.next);\r\nlist_del(&packet->list);\r\n}\r\nspin_unlock_irqrestore(&card->buffer_lock, flags);\r\nif (packet)\r\nif_spi_h2c(card, packet, MVMS_CMD);\r\n}\r\nif (hiStatus & IF_SPI_HIST_TX_DOWNLOAD_RDY) {\r\npacket = NULL;\r\nspin_lock_irqsave(&card->buffer_lock, flags);\r\nif (!list_empty(&card->data_packet_list)) {\r\npacket = (struct if_spi_packet *)(card->\r\ndata_packet_list.next);\r\nlist_del(&packet->list);\r\n}\r\nspin_unlock_irqrestore(&card->buffer_lock, flags);\r\nif (packet)\r\nif_spi_h2c(card, packet, MVMS_DAT);\r\n}\r\nif (hiStatus & IF_SPI_HIST_CARD_EVENT)\r\nif_spi_e2h(card);\r\nerr:\r\nif (err)\r\nnetdev_err(priv->dev, "%s: got error %d\n", __func__, err);\r\n}\r\nstatic int if_spi_host_to_card(struct lbs_private *priv,\r\nu8 type, u8 *buf, u16 nb)\r\n{\r\nint err = 0;\r\nunsigned long flags;\r\nstruct if_spi_card *card = priv->card;\r\nstruct if_spi_packet *packet;\r\nu16 blen;\r\nif (nb == 0) {\r\nnetdev_err(priv->dev, "%s: invalid size requested: %d\n",\r\n__func__, nb);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nblen = ALIGN(nb, 4);\r\npacket = kzalloc(sizeof(struct if_spi_packet) + blen, GFP_ATOMIC);\r\nif (!packet) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\npacket->blen = blen;\r\nmemcpy(packet->buffer, buf, nb);\r\nmemset(packet->buffer + nb, 0, blen - nb);\r\nswitch (type) {\r\ncase MVMS_CMD:\r\npriv->dnld_sent = DNLD_CMD_SENT;\r\nspin_lock_irqsave(&card->buffer_lock, flags);\r\nlist_add_tail(&packet->list, &card->cmd_packet_list);\r\nspin_unlock_irqrestore(&card->buffer_lock, flags);\r\nbreak;\r\ncase MVMS_DAT:\r\npriv->dnld_sent = DNLD_DATA_SENT;\r\nspin_lock_irqsave(&card->buffer_lock, flags);\r\nlist_add_tail(&packet->list, &card->data_packet_list);\r\nspin_unlock_irqrestore(&card->buffer_lock, flags);\r\nbreak;\r\ndefault:\r\nkfree(packet);\r\nnetdev_err(priv->dev, "can't transfer buffer of type %d\n",\r\ntype);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nqueue_work(card->workqueue, &card->packet_work);\r\nout:\r\nreturn err;\r\n}\r\nstatic irqreturn_t if_spi_host_interrupt(int irq, void *dev_id)\r\n{\r\nstruct if_spi_card *card = dev_id;\r\nqueue_work(card->workqueue, &card->packet_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int if_spi_init_card(struct if_spi_card *card)\r\n{\r\nstruct lbs_private *priv = card->priv;\r\nint err, i;\r\nu32 scratch;\r\nconst struct firmware *helper = NULL;\r\nconst struct firmware *mainfw = NULL;\r\nerr = spu_init(card, card->pdata->use_dummy_writes);\r\nif (err)\r\ngoto out;\r\nerr = spu_get_chip_revision(card, &card->card_id, &card->card_rev);\r\nif (err)\r\ngoto out;\r\nerr = spu_read_u32(card, IF_SPI_SCRATCH_4_REG, &scratch);\r\nif (err)\r\ngoto out;\r\nif (scratch == SUCCESSFUL_FW_DOWNLOAD_MAGIC)\r\nlbs_deb_spi("Firmware is already loaded for "\r\n"Marvell WLAN 802.11 adapter\n");\r\nelse {\r\nfor (i = 0; i < ARRAY_SIZE(fw_table); i++) {\r\nif (card->card_id == fw_table[i].model)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(fw_table)) {\r\nnetdev_err(priv->dev, "Unsupported chip_id: 0x%02x\n",\r\ncard->card_id);\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nerr = lbs_get_firmware(&card->spi->dev, card->card_id,\r\n&fw_table[0], &helper, &mainfw);\r\nif (err) {\r\nnetdev_err(priv->dev, "failed to find firmware (%d)\n",\r\nerr);\r\ngoto out;\r\n}\r\nlbs_deb_spi("Initializing FW for Marvell WLAN 802.11 adapter "\r\n"(chip_id = 0x%04x, chip_rev = 0x%02x) "\r\n"attached to SPI bus_num %d, chip_select %d. "\r\n"spi->max_speed_hz=%d\n",\r\ncard->card_id, card->card_rev,\r\ncard->spi->master->bus_num,\r\ncard->spi->chip_select,\r\ncard->spi->max_speed_hz);\r\nerr = if_spi_prog_helper_firmware(card, helper);\r\nif (err)\r\ngoto out;\r\nerr = if_spi_prog_main_firmware(card, mainfw);\r\nif (err)\r\ngoto out;\r\nlbs_deb_spi("loaded FW for Marvell WLAN 802.11 adapter\n");\r\n}\r\nerr = spu_set_interrupt_mode(card, 0, 1);\r\nif (err)\r\ngoto out;\r\nout:\r\nreturn err;\r\n}\r\nstatic void if_spi_resume_worker(struct work_struct *work)\r\n{\r\nstruct if_spi_card *card;\r\ncard = container_of(work, struct if_spi_card, resume_work);\r\nif (card->suspended) {\r\nif (card->pdata->setup)\r\ncard->pdata->setup(card->spi);\r\nif_spi_init_card(card);\r\nenable_irq(card->spi->irq);\r\nlbs_resume(card->priv);\r\ncard->suspended = 0;\r\n}\r\n}\r\nstatic int if_spi_probe(struct spi_device *spi)\r\n{\r\nstruct if_spi_card *card;\r\nstruct lbs_private *priv = NULL;\r\nstruct libertas_spi_platform_data *pdata = dev_get_platdata(&spi->dev);\r\nint err = 0;\r\nif (!pdata) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (pdata->setup) {\r\nerr = pdata->setup(spi);\r\nif (err)\r\ngoto out;\r\n}\r\ncard = kzalloc(sizeof(struct if_spi_card), GFP_KERNEL);\r\nif (!card) {\r\nerr = -ENOMEM;\r\ngoto teardown;\r\n}\r\nspi_set_drvdata(spi, card);\r\ncard->pdata = pdata;\r\ncard->spi = spi;\r\ncard->prev_xfer_time = jiffies;\r\nINIT_LIST_HEAD(&card->cmd_packet_list);\r\nINIT_LIST_HEAD(&card->data_packet_list);\r\nspin_lock_init(&card->buffer_lock);\r\nerr = if_spi_init_card(card);\r\nif (err)\r\ngoto free_card;\r\npriv = lbs_add_card(card, &spi->dev);\r\nif (!priv) {\r\nerr = -ENOMEM;\r\ngoto free_card;\r\n}\r\ncard->priv = priv;\r\npriv->setup_fw_on_resume = 1;\r\npriv->card = card;\r\npriv->hw_host_to_card = if_spi_host_to_card;\r\npriv->enter_deep_sleep = NULL;\r\npriv->exit_deep_sleep = NULL;\r\npriv->reset_deep_sleep_wakeup = NULL;\r\npriv->fw_ready = 1;\r\ncard->workqueue = alloc_workqueue("libertas_spi", WQ_MEM_RECLAIM, 0);\r\nif (!card->workqueue) {\r\nerr = -ENOMEM;\r\ngoto remove_card;\r\n}\r\nINIT_WORK(&card->packet_work, if_spi_host_to_card_worker);\r\nINIT_WORK(&card->resume_work, if_spi_resume_worker);\r\nerr = request_irq(spi->irq, if_spi_host_interrupt,\r\nIRQF_TRIGGER_FALLING, "libertas_spi", card);\r\nif (err) {\r\npr_err("can't get host irq line-- request_irq failed\n");\r\ngoto terminate_workqueue;\r\n}\r\nerr = lbs_start_card(priv);\r\nif (err)\r\ngoto release_irq;\r\nlbs_deb_spi("Finished initializing WLAN module.\n");\r\ngoto out;\r\nrelease_irq:\r\nfree_irq(spi->irq, card);\r\nterminate_workqueue:\r\ndestroy_workqueue(card->workqueue);\r\nremove_card:\r\nlbs_remove_card(priv);\r\nfree_card:\r\nfree_if_spi_card(card);\r\nteardown:\r\nif (pdata->teardown)\r\npdata->teardown(spi);\r\nout:\r\nreturn err;\r\n}\r\nstatic int libertas_spi_remove(struct spi_device *spi)\r\n{\r\nstruct if_spi_card *card = spi_get_drvdata(spi);\r\nstruct lbs_private *priv = card->priv;\r\nlbs_deb_spi("libertas_spi_remove\n");\r\ncancel_work_sync(&card->resume_work);\r\nlbs_stop_card(priv);\r\nlbs_remove_card(priv);\r\nfree_irq(spi->irq, card);\r\ndestroy_workqueue(card->workqueue);\r\nif (card->pdata->teardown)\r\ncard->pdata->teardown(spi);\r\nfree_if_spi_card(card);\r\nreturn 0;\r\n}\r\nstatic int if_spi_suspend(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct if_spi_card *card = spi_get_drvdata(spi);\r\nif (!card->suspended) {\r\nlbs_suspend(card->priv);\r\nflush_workqueue(card->workqueue);\r\ndisable_irq(spi->irq);\r\nif (card->pdata->teardown)\r\ncard->pdata->teardown(spi);\r\ncard->suspended = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int if_spi_resume(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct if_spi_card *card = spi_get_drvdata(spi);\r\nschedule_work(&card->resume_work);\r\nreturn 0;\r\n}\r\nstatic int __init if_spi_init_module(void)\r\n{\r\nint ret = 0;\r\nprintk(KERN_INFO "libertas_spi: Libertas SPI driver\n");\r\nret = spi_register_driver(&libertas_spi_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit if_spi_exit_module(void)\r\n{\r\nspi_unregister_driver(&libertas_spi_driver);\r\n}
