static int nfp_meid(u8 island_id, u8 menum)\r\n{\r\nreturn (island_id & 0x3F) == island_id && menum < 12 ?\r\n(island_id << 4) | (menum + 4) : -1;\r\n}\r\nstatic void\r\nnfp_rtsym_sw_entry_init(struct nfp_rtsym_table *cache, u32 strtab_size,\r\nstruct nfp_rtsym *sw, struct nfp_rtsym_entry *fw)\r\n{\r\nsw->type = fw->type;\r\nsw->name = cache->strtab + le16_to_cpu(fw->name) % strtab_size;\r\nsw->addr = ((u64)fw->addr_hi << 32) | le32_to_cpu(fw->addr_lo);\r\nsw->size = ((u64)fw->size_hi << 32) | le32_to_cpu(fw->size_lo);\r\nswitch (fw->target) {\r\ncase SYM_TGT_LMEM:\r\nsw->target = NFP_RTSYM_TARGET_LMEM;\r\nbreak;\r\ncase SYM_TGT_EMU_CACHE:\r\nsw->target = NFP_RTSYM_TARGET_EMU_CACHE;\r\nbreak;\r\ndefault:\r\nsw->target = fw->target;\r\nbreak;\r\n}\r\nif (fw->menum != 0xff)\r\nsw->domain = nfp_meid(fw->island, fw->menum);\r\nelse if (fw->island != 0xff)\r\nsw->domain = fw->island;\r\nelse\r\nsw->domain = -1;\r\n}\r\nstruct nfp_rtsym_table *nfp_rtsym_table_read(struct nfp_cpp *cpp)\r\n{\r\nstruct nfp_rtsym_table *rtbl;\r\nconst struct nfp_mip *mip;\r\nmip = nfp_mip_open(cpp);\r\nrtbl = __nfp_rtsym_table_read(cpp, mip);\r\nnfp_mip_close(mip);\r\nreturn rtbl;\r\n}\r\nstruct nfp_rtsym_table *\r\n__nfp_rtsym_table_read(struct nfp_cpp *cpp, const struct nfp_mip *mip)\r\n{\r\nconst u32 dram = NFP_CPP_ID(NFP_CPP_TARGET_MU, NFP_CPP_ACTION_RW, 0) |\r\nNFP_ISL_EMEM0;\r\nu32 strtab_addr, symtab_addr, strtab_size, symtab_size;\r\nstruct nfp_rtsym_entry *rtsymtab;\r\nstruct nfp_rtsym_table *cache;\r\nint err, n, size;\r\nif (!mip)\r\nreturn NULL;\r\nnfp_mip_strtab(mip, &strtab_addr, &strtab_size);\r\nnfp_mip_symtab(mip, &symtab_addr, &symtab_size);\r\nif (!symtab_size || !strtab_size || symtab_size % sizeof(*rtsymtab))\r\nreturn NULL;\r\nsymtab_size = round_up(symtab_size, 8);\r\nstrtab_size = round_up(strtab_size, 8);\r\nrtsymtab = kmalloc(symtab_size, GFP_KERNEL);\r\nif (!rtsymtab)\r\nreturn NULL;\r\nsize = sizeof(*cache);\r\nsize += symtab_size / sizeof(*rtsymtab) * sizeof(struct nfp_rtsym);\r\nsize += strtab_size + 1;\r\ncache = kmalloc(size, GFP_KERNEL);\r\nif (!cache)\r\ngoto exit_free_rtsym_raw;\r\ncache->cpp = cpp;\r\ncache->num = symtab_size / sizeof(*rtsymtab);\r\ncache->strtab = (void *)&cache->symtab[cache->num];\r\nerr = nfp_cpp_read(cpp, dram, symtab_addr, rtsymtab, symtab_size);\r\nif (err != symtab_size)\r\ngoto exit_free_cache;\r\nerr = nfp_cpp_read(cpp, dram, strtab_addr, cache->strtab, strtab_size);\r\nif (err != strtab_size)\r\ngoto exit_free_cache;\r\ncache->strtab[strtab_size] = '\0';\r\nfor (n = 0; n < cache->num; n++)\r\nnfp_rtsym_sw_entry_init(cache, strtab_size,\r\n&cache->symtab[n], &rtsymtab[n]);\r\nkfree(rtsymtab);\r\nreturn cache;\r\nexit_free_cache:\r\nkfree(cache);\r\nexit_free_rtsym_raw:\r\nkfree(rtsymtab);\r\nreturn NULL;\r\n}\r\nint nfp_rtsym_count(struct nfp_rtsym_table *rtbl)\r\n{\r\nif (!rtbl)\r\nreturn -EINVAL;\r\nreturn rtbl->num;\r\n}\r\nconst struct nfp_rtsym *nfp_rtsym_get(struct nfp_rtsym_table *rtbl, int idx)\r\n{\r\nif (!rtbl)\r\nreturn NULL;\r\nif (idx >= rtbl->num)\r\nreturn NULL;\r\nreturn &rtbl->symtab[idx];\r\n}\r\nconst struct nfp_rtsym *\r\nnfp_rtsym_lookup(struct nfp_rtsym_table *rtbl, const char *name)\r\n{\r\nint n;\r\nif (!rtbl)\r\nreturn NULL;\r\nfor (n = 0; n < rtbl->num; n++)\r\nif (strcmp(name, rtbl->symtab[n].name) == 0)\r\nreturn &rtbl->symtab[n];\r\nreturn NULL;\r\n}\r\nu64 nfp_rtsym_read_le(struct nfp_rtsym_table *rtbl, const char *name,\r\nint *error)\r\n{\r\nconst struct nfp_rtsym *sym;\r\nu32 val32, id;\r\nu64 val;\r\nint err;\r\nsym = nfp_rtsym_lookup(rtbl, name);\r\nif (!sym) {\r\nerr = -ENOENT;\r\ngoto exit;\r\n}\r\nid = NFP_CPP_ISLAND_ID(sym->target, NFP_CPP_ACTION_RW, 0, sym->domain);\r\nswitch (sym->size) {\r\ncase 4:\r\nerr = nfp_cpp_readl(rtbl->cpp, id, sym->addr, &val32);\r\nval = val32;\r\nbreak;\r\ncase 8:\r\nerr = nfp_cpp_readq(rtbl->cpp, id, sym->addr, &val);\r\nbreak;\r\ndefault:\r\nnfp_err(rtbl->cpp,\r\n"rtsym '%s' unsupported or non-scalar size: %lld\n",\r\nname, sym->size);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (err == sym->size)\r\nerr = 0;\r\nelse if (err >= 0)\r\nerr = -EIO;\r\nexit:\r\nif (error)\r\n*error = err;\r\nif (err)\r\nreturn ~0ULL;\r\nreturn val;\r\n}\r\nu8 __iomem *\r\nnfp_rtsym_map(struct nfp_rtsym_table *rtbl, const char *name, const char *id,\r\nunsigned int min_size, struct nfp_cpp_area **area)\r\n{\r\nconst struct nfp_rtsym *sym;\r\nu8 __iomem *mem;\r\nsym = nfp_rtsym_lookup(rtbl, name);\r\nif (!sym)\r\nreturn (u8 __iomem *)ERR_PTR(-ENOENT);\r\nif (sym->size < min_size) {\r\nnfp_err(rtbl->cpp, "Symbol %s too small\n", name);\r\nreturn (u8 __iomem *)ERR_PTR(-EINVAL);\r\n}\r\nmem = nfp_cpp_map_area(rtbl->cpp, id, sym->domain, sym->target,\r\nsym->addr, sym->size, area);\r\nif (IS_ERR(mem)) {\r\nnfp_err(rtbl->cpp, "Failed to map symbol %s: %ld\n",\r\nname, PTR_ERR(mem));\r\nreturn mem;\r\n}\r\nreturn mem;\r\n}
