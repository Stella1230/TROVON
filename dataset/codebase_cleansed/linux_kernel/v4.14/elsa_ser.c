static inline unsigned int serial_in(struct IsdnCardState *cs, int offset)\r\n{\r\n#ifdef SERIAL_DEBUG_REG\r\nu_int val = inb(cs->hw.elsa.base + 8 + offset);\r\ndebugl1(cs, "in %s %02x", ModemIn[offset], val);\r\nreturn (val);\r\n#else\r\nreturn inb(cs->hw.elsa.base + 8 + offset);\r\n#endif\r\n}\r\nstatic inline unsigned int serial_inp(struct IsdnCardState *cs, int offset)\r\n{\r\n#ifdef SERIAL_DEBUG_REG\r\n#ifdef ELSA_SERIAL_NOPAUSE_IO\r\nu_int val = inb(cs->hw.elsa.base + 8 + offset);\r\ndebugl1(cs, "inp %s %02x", ModemIn[offset], val);\r\n#else\r\nu_int val = inb_p(cs->hw.elsa.base + 8 + offset);\r\ndebugl1(cs, "inP %s %02x", ModemIn[offset], val);\r\n#endif\r\nreturn (val);\r\n#else\r\n#ifdef ELSA_SERIAL_NOPAUSE_IO\r\nreturn inb(cs->hw.elsa.base + 8 + offset);\r\n#else\r\nreturn inb_p(cs->hw.elsa.base + 8 + offset);\r\n#endif\r\n#endif\r\n}\r\nstatic inline void serial_out(struct IsdnCardState *cs, int offset, int value)\r\n{\r\n#ifdef SERIAL_DEBUG_REG\r\ndebugl1(cs, "out %s %02x", ModemOut[offset], value);\r\n#endif\r\noutb(value, cs->hw.elsa.base + 8 + offset);\r\n}\r\nstatic inline void serial_outp(struct IsdnCardState *cs, int offset,\r\nint value)\r\n{\r\n#ifdef SERIAL_DEBUG_REG\r\n#ifdef ELSA_SERIAL_NOPAUSE_IO\r\ndebugl1(cs, "outp %s %02x", ModemOut[offset], value);\r\n#else\r\ndebugl1(cs, "outP %s %02x", ModemOut[offset], value);\r\n#endif\r\n#endif\r\n#ifdef ELSA_SERIAL_NOPAUSE_IO\r\noutb(value, cs->hw.elsa.base + 8 + offset);\r\n#else\r\noutb_p(value, cs->hw.elsa.base + 8 + offset);\r\n#endif\r\n}\r\nstatic void change_speed(struct IsdnCardState *cs, int baud)\r\n{\r\nint quot = 0, baud_base;\r\nunsigned cval, fcr = 0;\r\ncval = 0x03;\r\nbaud_base = BASE_BAUD;\r\nquot = baud_base / baud;\r\nif (!quot)\r\nquot = baud_base / 9600;\r\nif ((baud_base / quot) < 2400)\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1;\r\nelse\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_8;\r\nserial_outp(cs, UART_FCR, fcr);\r\ncs->hw.elsa.IER &= ~UART_IER_MSI;\r\ncs->hw.elsa.IER |= UART_IER_MSI;\r\nserial_outp(cs, UART_IER, cs->hw.elsa.IER);\r\ndebugl1(cs, "modem quot=0x%x", quot);\r\nserial_outp(cs, UART_LCR, cval | UART_LCR_DLAB);\r\nserial_outp(cs, UART_DLL, quot & 0xff);\r\nserial_outp(cs, UART_DLM, quot >> 8);\r\nserial_outp(cs, UART_LCR, cval);\r\nserial_inp(cs, UART_RX);\r\n}\r\nstatic int mstartup(struct IsdnCardState *cs)\r\n{\r\nint retval = 0;\r\nserial_outp(cs, UART_FCR, (UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT));\r\nif (serial_inp(cs, UART_LSR) == 0xff) {\r\nretval = -ENODEV;\r\ngoto errout;\r\n}\r\n(void) serial_inp(cs, UART_RX);\r\n(void) serial_inp(cs, UART_IIR);\r\n(void) serial_inp(cs, UART_MSR);\r\nserial_outp(cs, UART_LCR, UART_LCR_WLEN8);\r\ncs->hw.elsa.MCR = 0;\r\ncs->hw.elsa.MCR = UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2;\r\nserial_outp(cs, UART_MCR, cs->hw.elsa.MCR);\r\ncs->hw.elsa.IER = UART_IER_MSI | UART_IER_RLSI | UART_IER_RDI;\r\nserial_outp(cs, UART_IER, cs->hw.elsa.IER);\r\n(void)serial_inp(cs, UART_LSR);\r\n(void)serial_inp(cs, UART_RX);\r\n(void)serial_inp(cs, UART_IIR);\r\n(void)serial_inp(cs, UART_MSR);\r\ncs->hw.elsa.transcnt = cs->hw.elsa.transp = 0;\r\ncs->hw.elsa.rcvcnt = cs->hw.elsa.rcvp = 0;\r\nchange_speed(cs, BASE_BAUD);\r\ncs->hw.elsa.MFlag = 1;\r\nerrout:\r\nreturn retval;\r\n}\r\nstatic void mshutdown(struct IsdnCardState *cs)\r\n{\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk(KERN_DEBUG"Shutting down serial ....");\r\n#endif\r\ncs->hw.elsa.IER = 0;\r\nserial_outp(cs, UART_IER, 0x00);\r\ncs->hw.elsa.MCR &= ~UART_MCR_OUT2;\r\nserial_outp(cs, UART_LCR, serial_inp(cs, UART_LCR) & ~UART_LCR_SBC);\r\ncs->hw.elsa.MCR &= ~(UART_MCR_DTR | UART_MCR_RTS);\r\nserial_outp(cs, UART_MCR, cs->hw.elsa.MCR);\r\nserial_outp(cs, UART_FCR, (UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT));\r\nserial_inp(cs, UART_RX);\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk(" done\n");\r\n#endif\r\n}\r\nstatic inline int\r\nwrite_modem(struct BCState *bcs) {\r\nint ret = 0;\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint count, len, fp;\r\nif (!bcs->tx_skb)\r\nreturn 0;\r\nif (bcs->tx_skb->len <= 0)\r\nreturn 0;\r\nlen = bcs->tx_skb->len;\r\nif (len > MAX_MODEM_BUF - cs->hw.elsa.transcnt)\r\nlen = MAX_MODEM_BUF - cs->hw.elsa.transcnt;\r\nfp = cs->hw.elsa.transcnt + cs->hw.elsa.transp;\r\nfp &= (MAX_MODEM_BUF - 1);\r\ncount = len;\r\nif (count > MAX_MODEM_BUF - fp) {\r\ncount = MAX_MODEM_BUF - fp;\r\nskb_copy_from_linear_data(bcs->tx_skb,\r\ncs->hw.elsa.transbuf + fp, count);\r\nskb_pull(bcs->tx_skb, count);\r\ncs->hw.elsa.transcnt += count;\r\nret = count;\r\ncount = len - count;\r\nfp = 0;\r\n}\r\nskb_copy_from_linear_data(bcs->tx_skb,\r\ncs->hw.elsa.transbuf + fp, count);\r\nskb_pull(bcs->tx_skb, count);\r\ncs->hw.elsa.transcnt += count;\r\nret += count;\r\nif (cs->hw.elsa.transcnt &&\r\n!(cs->hw.elsa.IER & UART_IER_THRI)) {\r\ncs->hw.elsa.IER |= UART_IER_THRI;\r\nserial_outp(cs, UART_IER, cs->hw.elsa.IER);\r\n}\r\nreturn (ret);\r\n}\r\nstatic inline void\r\nmodem_fill(struct BCState *bcs) {\r\nif (bcs->tx_skb) {\r\nif (bcs->tx_skb->len) {\r\nwrite_modem(bcs);\r\nreturn;\r\n} else {\r\nif (test_bit(FLG_LLI_L1WAKEUP, &bcs->st->lli.flag) &&\r\n(PACKET_NOACK != bcs->tx_skb->pkt_type)) {\r\nu_long flags;\r\nspin_lock_irqsave(&bcs->aclock, flags);\r\nbcs->ackcnt += bcs->hw.hscx.count;\r\nspin_unlock_irqrestore(&bcs->aclock, flags);\r\nschedule_event(bcs, B_ACKPENDING);\r\n}\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\n}\r\n}\r\nif ((bcs->tx_skb = skb_dequeue(&bcs->squeue))) {\r\nbcs->hw.hscx.count = 0;\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nwrite_modem(bcs);\r\n} else {\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nschedule_event(bcs, B_XMTBUFREADY);\r\n}\r\n}\r\nstatic inline void receive_chars(struct IsdnCardState *cs,\r\nint *status)\r\n{\r\nunsigned char ch;\r\nstruct sk_buff *skb;\r\ndo {\r\nch = serial_in(cs, UART_RX);\r\nif (cs->hw.elsa.rcvcnt >= MAX_MODEM_BUF)\r\nbreak;\r\ncs->hw.elsa.rcvbuf[cs->hw.elsa.rcvcnt++] = ch;\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("DR%02x:%02x...", ch, *status);\r\n#endif\r\nif (*status & (UART_LSR_BI | UART_LSR_PE |\r\nUART_LSR_FE | UART_LSR_OE)) {\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("handling exept....");\r\n#endif\r\n}\r\n*status = serial_inp(cs, UART_LSR);\r\n} while (*status & UART_LSR_DR);\r\nif (cs->hw.elsa.MFlag == 2) {\r\nif (!(skb = dev_alloc_skb(cs->hw.elsa.rcvcnt)))\r\nprintk(KERN_WARNING "ElsaSER: receive out of memory\n");\r\nelse {\r\nskb_put_data(skb, cs->hw.elsa.rcvbuf,\r\ncs->hw.elsa.rcvcnt);\r\nskb_queue_tail(&cs->hw.elsa.bcs->rqueue, skb);\r\n}\r\nschedule_event(cs->hw.elsa.bcs, B_RCVBUFREADY);\r\n} else {\r\nchar tmp[128];\r\nchar *t = tmp;\r\nt += sprintf(t, "modem read cnt %d", cs->hw.elsa.rcvcnt);\r\nQuickHex(t, cs->hw.elsa.rcvbuf, cs->hw.elsa.rcvcnt);\r\ndebugl1(cs, "%s", tmp);\r\n}\r\ncs->hw.elsa.rcvcnt = 0;\r\n}\r\nstatic inline void transmit_chars(struct IsdnCardState *cs, int *intr_done)\r\n{\r\nint count;\r\ndebugl1(cs, "transmit_chars: p(%x) cnt(%x)", cs->hw.elsa.transp,\r\ncs->hw.elsa.transcnt);\r\nif (cs->hw.elsa.transcnt <= 0) {\r\ncs->hw.elsa.IER &= ~UART_IER_THRI;\r\nserial_out(cs, UART_IER, cs->hw.elsa.IER);\r\nreturn;\r\n}\r\ncount = 16;\r\ndo {\r\nserial_outp(cs, UART_TX, cs->hw.elsa.transbuf[cs->hw.elsa.transp++]);\r\nif (cs->hw.elsa.transp >= MAX_MODEM_BUF)\r\ncs->hw.elsa.transp = 0;\r\nif (--cs->hw.elsa.transcnt <= 0)\r\nbreak;\r\n} while (--count > 0);\r\nif ((cs->hw.elsa.transcnt < WAKEUP_CHARS) && (cs->hw.elsa.MFlag == 2))\r\nmodem_fill(cs->hw.elsa.bcs);\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("THRE...");\r\n#endif\r\nif (intr_done)\r\n*intr_done = 0;\r\nif (cs->hw.elsa.transcnt <= 0) {\r\ncs->hw.elsa.IER &= ~UART_IER_THRI;\r\nserial_outp(cs, UART_IER, cs->hw.elsa.IER);\r\n}\r\n}\r\nstatic void rs_interrupt_elsa(struct IsdnCardState *cs)\r\n{\r\nint status, iir, msr;\r\nint pass_counter = 0;\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk(KERN_DEBUG "rs_interrupt_single(%d)...", cs->irq);\r\n#endif\r\ndo {\r\nstatus = serial_inp(cs, UART_LSR);\r\ndebugl1(cs, "rs LSR %02x", status);\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("status = %x...", status);\r\n#endif\r\nif (status & UART_LSR_DR)\r\nreceive_chars(cs, &status);\r\nif (status & UART_LSR_THRE)\r\ntransmit_chars(cs, NULL);\r\nif (pass_counter++ > RS_ISR_PASS_LIMIT) {\r\nprintk("rs_single loop break.\n");\r\nbreak;\r\n}\r\niir = serial_inp(cs, UART_IIR);\r\ndebugl1(cs, "rs IIR %02x", iir);\r\nif ((iir & 0xf) == 0) {\r\nmsr = serial_inp(cs, UART_MSR);\r\ndebugl1(cs, "rs MSR %02x", msr);\r\n}\r\n} while (!(iir & UART_IIR_NO_INT));\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("end.\n");\r\n#endif\r\n}\r\nstatic void\r\nclose_elsastate(struct BCState *bcs)\r\n{\r\nmodehscx(bcs, 0, bcs->channel);\r\nif (test_and_clear_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nif (bcs->hw.hscx.rcvbuf) {\r\nif (bcs->mode != L1_MODE_MODEM)\r\nkfree(bcs->hw.hscx.rcvbuf);\r\nbcs->hw.hscx.rcvbuf = NULL;\r\n}\r\nskb_queue_purge(&bcs->rqueue);\r\nskb_queue_purge(&bcs->squeue);\r\nif (bcs->tx_skb) {\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\n}\r\n}\r\n}\r\nstatic void\r\nmodem_write_cmd(struct IsdnCardState *cs, u_char *buf, int len) {\r\nint count, fp;\r\nu_char *msg = buf;\r\nif (!len)\r\nreturn;\r\nif (len > (MAX_MODEM_BUF - cs->hw.elsa.transcnt)) {\r\nreturn;\r\n}\r\nfp = cs->hw.elsa.transcnt + cs->hw.elsa.transp;\r\nfp &= (MAX_MODEM_BUF - 1);\r\ncount = len;\r\nif (count > MAX_MODEM_BUF - fp) {\r\ncount = MAX_MODEM_BUF - fp;\r\nmemcpy(cs->hw.elsa.transbuf + fp, msg, count);\r\ncs->hw.elsa.transcnt += count;\r\nmsg += count;\r\ncount = len - count;\r\nfp = 0;\r\n}\r\nmemcpy(cs->hw.elsa.transbuf + fp, msg, count);\r\ncs->hw.elsa.transcnt += count;\r\nif (cs->hw.elsa.transcnt &&\r\n!(cs->hw.elsa.IER & UART_IER_THRI)) {\r\ncs->hw.elsa.IER |= UART_IER_THRI;\r\nserial_outp(cs, UART_IER, cs->hw.elsa.IER);\r\n}\r\n}\r\nstatic void\r\nmodem_set_init(struct IsdnCardState *cs) {\r\nint timeout;\r\n#define RCV_DELAY 20\r\nmodem_write_cmd(cs, MInit_1, strlen(MInit_1));\r\ntimeout = 1000;\r\nwhile (timeout-- && cs->hw.elsa.transcnt)\r\nudelay(1000);\r\ndebugl1(cs, "msi tout=%d", timeout);\r\nmdelay(RCV_DELAY);\r\nmodem_write_cmd(cs, MInit_2, strlen(MInit_2));\r\ntimeout = 1000;\r\nwhile (timeout-- && cs->hw.elsa.transcnt)\r\nudelay(1000);\r\ndebugl1(cs, "msi tout=%d", timeout);\r\nmdelay(RCV_DELAY);\r\nmodem_write_cmd(cs, MInit_3, strlen(MInit_3));\r\ntimeout = 1000;\r\nwhile (timeout-- && cs->hw.elsa.transcnt)\r\nudelay(1000);\r\ndebugl1(cs, "msi tout=%d", timeout);\r\nmdelay(RCV_DELAY);\r\nmodem_write_cmd(cs, MInit_4, strlen(MInit_4));\r\ntimeout = 1000;\r\nwhile (timeout-- && cs->hw.elsa.transcnt)\r\nudelay(1000);\r\ndebugl1(cs, "msi tout=%d", timeout);\r\nmdelay(RCV_DELAY);\r\nmodem_write_cmd(cs, MInit_5, strlen(MInit_5));\r\ntimeout = 1000;\r\nwhile (timeout-- && cs->hw.elsa.transcnt)\r\nudelay(1000);\r\ndebugl1(cs, "msi tout=%d", timeout);\r\nmdelay(RCV_DELAY);\r\nmodem_write_cmd(cs, MInit_6, strlen(MInit_6));\r\ntimeout = 1000;\r\nwhile (timeout-- && cs->hw.elsa.transcnt)\r\nudelay(1000);\r\ndebugl1(cs, "msi tout=%d", timeout);\r\nmdelay(RCV_DELAY);\r\nmodem_write_cmd(cs, MInit_7, strlen(MInit_7));\r\ntimeout = 1000;\r\nwhile (timeout-- && cs->hw.elsa.transcnt)\r\nudelay(1000);\r\ndebugl1(cs, "msi tout=%d", timeout);\r\nmdelay(RCV_DELAY);\r\n}\r\nstatic void\r\nmodem_set_dial(struct IsdnCardState *cs, int outgoing) {\r\nint timeout;\r\n#define RCV_DELAY 20\r\nmodem_write_cmd(cs, MInit_speed28800, strlen(MInit_speed28800));\r\ntimeout = 1000;\r\nwhile (timeout-- && cs->hw.elsa.transcnt)\r\nudelay(1000);\r\ndebugl1(cs, "msi tout=%d", timeout);\r\nmdelay(RCV_DELAY);\r\nif (outgoing)\r\nmodem_write_cmd(cs, MInit_dialout, strlen(MInit_dialout));\r\nelse\r\nmodem_write_cmd(cs, MInit_dialin, strlen(MInit_dialin));\r\ntimeout = 1000;\r\nwhile (timeout-- && cs->hw.elsa.transcnt)\r\nudelay(1000);\r\ndebugl1(cs, "msi tout=%d", timeout);\r\nmdelay(RCV_DELAY);\r\n}\r\nstatic void\r\nmodem_l2l1(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct BCState *bcs = st->l1.bcs;\r\nstruct sk_buff *skb = arg;\r\nu_long flags;\r\nif (pr == (PH_DATA | REQUEST)) {\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nskb_queue_tail(&bcs->squeue, skb);\r\n} else {\r\nbcs->tx_skb = skb;\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->hw.hscx.count = 0;\r\nwrite_modem(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\n} else if (pr == (PH_ACTIVATE | REQUEST)) {\r\ntest_and_set_bit(BC_FLG_ACTIV, &bcs->Flag);\r\nst->l1.l1l2(st, PH_ACTIVATE | CONFIRM, NULL);\r\nset_arcofi(bcs->cs, st->l1.bc);\r\nmstartup(bcs->cs);\r\nmodem_set_dial(bcs->cs, test_bit(FLG_ORIG, &st->l2.flag));\r\nbcs->cs->hw.elsa.MFlag = 2;\r\n} else if (pr == (PH_DEACTIVATE | REQUEST)) {\r\ntest_and_clear_bit(BC_FLG_ACTIV, &bcs->Flag);\r\nbcs->cs->dc.isac.arcofi_bc = st->l1.bc;\r\narcofi_fsm(bcs->cs, ARCOFI_START, &ARCOFI_XOP_0);\r\nwait_event_interruptible(bcs->cs->dc.isac.arcofi_wait,\r\nbcs->cs->dc.isac.arcofi_state == ARCOFI_NOP);\r\nbcs->cs->hw.elsa.MFlag = 1;\r\n} else {\r\nprintk(KERN_WARNING "ElsaSer: unknown pr %x\n", pr);\r\n}\r\n}\r\nstatic int\r\nsetstack_elsa(struct PStack *st, struct BCState *bcs)\r\n{\r\nbcs->channel = st->l1.bc;\r\nswitch (st->l1.mode) {\r\ncase L1_MODE_HDLC:\r\ncase L1_MODE_TRANS:\r\nif (open_hscxstate(st->l1.hardware, bcs))\r\nreturn (-1);\r\nst->l2.l2l1 = hscx_l2l1;\r\nbreak;\r\ncase L1_MODE_MODEM:\r\nbcs->mode = L1_MODE_MODEM;\r\nif (!test_and_set_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nbcs->hw.hscx.rcvbuf = bcs->cs->hw.elsa.rcvbuf;\r\nskb_queue_head_init(&bcs->rqueue);\r\nskb_queue_head_init(&bcs->squeue);\r\n}\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->event = 0;\r\nbcs->hw.hscx.rcvidx = 0;\r\nbcs->tx_cnt = 0;\r\nbcs->cs->hw.elsa.bcs = bcs;\r\nst->l2.l2l1 = modem_l2l1;\r\nbreak;\r\n}\r\nst->l1.bcs = bcs;\r\nsetstack_manager(st);\r\nbcs->st = st;\r\nsetstack_l1_B(st);\r\nreturn (0);\r\n}\r\nstatic void\r\ninit_modem(struct IsdnCardState *cs) {\r\ncs->bcs[0].BC_SetStack = setstack_elsa;\r\ncs->bcs[1].BC_SetStack = setstack_elsa;\r\ncs->bcs[0].BC_Close = close_elsastate;\r\ncs->bcs[1].BC_Close = close_elsastate;\r\nif (!(cs->hw.elsa.rcvbuf = kmalloc(MAX_MODEM_BUF,\r\nGFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"Elsa: No modem mem hw.elsa.rcvbuf\n");\r\nreturn;\r\n}\r\nif (!(cs->hw.elsa.transbuf = kmalloc(MAX_MODEM_BUF,\r\nGFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"Elsa: No modem mem hw.elsa.transbuf\n");\r\nkfree(cs->hw.elsa.rcvbuf);\r\ncs->hw.elsa.rcvbuf = NULL;\r\nreturn;\r\n}\r\nif (mstartup(cs)) {\r\nprintk(KERN_WARNING "Elsa: problem startup modem\n");\r\n}\r\nmodem_set_init(cs);\r\n}\r\nstatic void\r\nrelease_modem(struct IsdnCardState *cs) {\r\ncs->hw.elsa.MFlag = 0;\r\nif (cs->hw.elsa.transbuf) {\r\nif (cs->hw.elsa.rcvbuf) {\r\nmshutdown(cs);\r\nkfree(cs->hw.elsa.rcvbuf);\r\ncs->hw.elsa.rcvbuf = NULL;\r\n}\r\nkfree(cs->hw.elsa.transbuf);\r\ncs->hw.elsa.transbuf = NULL;\r\n}\r\n}
