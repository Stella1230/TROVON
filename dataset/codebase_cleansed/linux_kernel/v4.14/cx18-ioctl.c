u16 cx18_service2vbi(int type)\r\n{\r\nswitch (type) {\r\ncase V4L2_SLICED_TELETEXT_B:\r\nreturn CX18_SLICED_TYPE_TELETEXT_B;\r\ncase V4L2_SLICED_CAPTION_525:\r\nreturn CX18_SLICED_TYPE_CAPTION_525;\r\ncase V4L2_SLICED_WSS_625:\r\nreturn CX18_SLICED_TYPE_WSS_625;\r\ncase V4L2_SLICED_VPS:\r\nreturn CX18_SLICED_TYPE_VPS;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int valid_service_line(int field, int line, int is_pal)\r\n{\r\nreturn (is_pal && line >= 6 &&\r\n((field == 0 && line <= 23) || (field == 1 && line <= 22))) ||\r\n(!is_pal && line >= 10 && line < 22);\r\n}\r\nstatic u16 select_service_from_set(int field, int line, u16 set, int is_pal)\r\n{\r\nu16 valid_set = (is_pal ? V4L2_SLICED_VBI_625 : V4L2_SLICED_VBI_525);\r\nint i;\r\nset = set & valid_set;\r\nif (set == 0 || !valid_service_line(field, line, is_pal))\r\nreturn 0;\r\nif (!is_pal) {\r\nif (line == 21 && (set & V4L2_SLICED_CAPTION_525))\r\nreturn V4L2_SLICED_CAPTION_525;\r\n} else {\r\nif (line == 16 && field == 0 && (set & V4L2_SLICED_VPS))\r\nreturn V4L2_SLICED_VPS;\r\nif (line == 23 && field == 0 && (set & V4L2_SLICED_WSS_625))\r\nreturn V4L2_SLICED_WSS_625;\r\nif (line == 23)\r\nreturn 0;\r\n}\r\nfor (i = 0; i < 32; i++) {\r\nif ((1 << i) & set)\r\nreturn 1 << i;\r\n}\r\nreturn 0;\r\n}\r\nvoid cx18_expand_service_set(struct v4l2_sliced_vbi_format *fmt, int is_pal)\r\n{\r\nu16 set = fmt->service_set;\r\nint f, l;\r\nfmt->service_set = 0;\r\nfor (f = 0; f < 2; f++) {\r\nfor (l = 0; l < 24; l++)\r\nfmt->service_lines[f][l] = select_service_from_set(f, l, set, is_pal);\r\n}\r\n}\r\nstatic int check_service_set(struct v4l2_sliced_vbi_format *fmt, int is_pal)\r\n{\r\nint f, l;\r\nu16 set = 0;\r\nfor (f = 0; f < 2; f++) {\r\nfor (l = 0; l < 24; l++) {\r\nfmt->service_lines[f][l] = select_service_from_set(f, l, fmt->service_lines[f][l], is_pal);\r\nset |= fmt->service_lines[f][l];\r\n}\r\n}\r\nreturn set != 0;\r\n}\r\nu16 cx18_get_service_set(struct v4l2_sliced_vbi_format *fmt)\r\n{\r\nint f, l;\r\nu16 set = 0;\r\nfor (f = 0; f < 2; f++) {\r\nfor (l = 0; l < 24; l++)\r\nset |= fmt->service_lines[f][l];\r\n}\r\nreturn set;\r\n}\r\nstatic int cx18_g_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct cx18_open_id *id = fh2id(fh);\r\nstruct cx18 *cx = id->cx;\r\nstruct cx18_stream *s = &cx->streams[id->type];\r\nstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\r\npixfmt->width = cx->cxhdl.width;\r\npixfmt->height = cx->cxhdl.height;\r\npixfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\npixfmt->field = V4L2_FIELD_INTERLACED;\r\nif (id->type == CX18_ENC_STREAM_TYPE_YUV) {\r\npixfmt->pixelformat = s->pixelformat;\r\npixfmt->sizeimage = s->vb_bytes_per_frame;\r\npixfmt->bytesperline = s->vb_bytes_per_line;\r\n} else {\r\npixfmt->pixelformat = V4L2_PIX_FMT_MPEG;\r\npixfmt->sizeimage = 128 * 1024;\r\npixfmt->bytesperline = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx18_g_fmt_vbi_cap(struct file *file, void *fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nstruct v4l2_vbi_format *vbifmt = &fmt->fmt.vbi;\r\nvbifmt->sampling_rate = 27000000;\r\nvbifmt->offset = 248;\r\nvbifmt->samples_per_line = VBI_ACTIVE_SAMPLES - 4;\r\nvbifmt->sample_format = V4L2_PIX_FMT_GREY;\r\nvbifmt->start[0] = cx->vbi.start[0];\r\nvbifmt->start[1] = cx->vbi.start[1];\r\nvbifmt->count[0] = vbifmt->count[1] = cx->vbi.count;\r\nvbifmt->flags = 0;\r\nvbifmt->reserved[0] = 0;\r\nvbifmt->reserved[1] = 0;\r\nreturn 0;\r\n}\r\nstatic int cx18_g_fmt_sliced_vbi_cap(struct file *file, void *fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nstruct v4l2_sliced_vbi_format *vbifmt = &fmt->fmt.sliced;\r\nvbifmt->reserved[0] = 0;\r\nvbifmt->reserved[1] = 0;\r\nvbifmt->io_size = sizeof(struct v4l2_sliced_vbi_data) * 36;\r\nmemset(vbifmt->service_lines, 0, sizeof(vbifmt->service_lines));\r\nvbifmt->service_set = 0;\r\nif (v4l2_subdev_call(cx->sd_av, vbi, g_sliced_fmt, &fmt->fmt.sliced))\r\nreturn -EINVAL;\r\nvbifmt->service_set = cx18_get_service_set(vbifmt);\r\nreturn 0;\r\n}\r\nstatic int cx18_try_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct cx18_open_id *id = fh2id(fh);\r\nstruct cx18 *cx = id->cx;\r\nint w = fmt->fmt.pix.width;\r\nint h = fmt->fmt.pix.height;\r\nint min_h = 2;\r\nw = min(w, 720);\r\nw = max(w, 2);\r\nif (id->type == CX18_ENC_STREAM_TYPE_YUV) {\r\nh &= ~0x1f;\r\nmin_h = 32;\r\n}\r\nh = min(h, cx->is_50hz ? 576 : 480);\r\nh = max(h, min_h);\r\nfmt->fmt.pix.width = w;\r\nfmt->fmt.pix.height = h;\r\nreturn 0;\r\n}\r\nstatic int cx18_try_fmt_vbi_cap(struct file *file, void *fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nreturn cx18_g_fmt_vbi_cap(file, fh, fmt);\r\n}\r\nstatic int cx18_try_fmt_sliced_vbi_cap(struct file *file, void *fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nstruct v4l2_sliced_vbi_format *vbifmt = &fmt->fmt.sliced;\r\nvbifmt->io_size = sizeof(struct v4l2_sliced_vbi_data) * 36;\r\nvbifmt->reserved[0] = 0;\r\nvbifmt->reserved[1] = 0;\r\nif (vbifmt->service_set)\r\ncx18_expand_service_set(vbifmt, cx->is_50hz);\r\nif (check_service_set(vbifmt, cx->is_50hz))\r\nvbifmt->service_set = cx18_get_service_set(vbifmt);\r\nreturn 0;\r\n}\r\nstatic int cx18_s_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct cx18_open_id *id = fh2id(fh);\r\nstruct cx18 *cx = id->cx;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nstruct cx18_stream *s = &cx->streams[id->type];\r\nint ret;\r\nint w, h;\r\nret = cx18_try_fmt_vid_cap(file, fh, fmt);\r\nif (ret)\r\nreturn ret;\r\nw = fmt->fmt.pix.width;\r\nh = fmt->fmt.pix.height;\r\nif (cx->cxhdl.width == w && cx->cxhdl.height == h &&\r\ns->pixelformat == fmt->fmt.pix.pixelformat)\r\nreturn 0;\r\nif (atomic_read(&cx->ana_capturing) > 0)\r\nreturn -EBUSY;\r\ns->pixelformat = fmt->fmt.pix.pixelformat;\r\nif (s->pixelformat == V4L2_PIX_FMT_HM12) {\r\ns->vb_bytes_per_frame = h * 720 * 3 / 2;\r\ns->vb_bytes_per_line = 720;\r\n} else {\r\ns->vb_bytes_per_frame = h * 720 * 2;\r\ns->vb_bytes_per_line = 1440;\r\n}\r\nformat.format.width = cx->cxhdl.width = w;\r\nformat.format.height = cx->cxhdl.height = h;\r\nformat.format.code = MEDIA_BUS_FMT_FIXED;\r\nv4l2_subdev_call(cx->sd_av, pad, set_fmt, NULL, &format);\r\nreturn cx18_g_fmt_vid_cap(file, fh, fmt);\r\n}\r\nstatic int cx18_s_fmt_vbi_cap(struct file *file, void *fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct cx18_open_id *id = fh2id(fh);\r\nstruct cx18 *cx = id->cx;\r\nint ret;\r\nif (!cx18_raw_vbi(cx) && atomic_read(&cx->ana_capturing) > 0)\r\nreturn -EBUSY;\r\nret = v4l2_subdev_call(cx->sd_av, vbi, s_raw_fmt, &fmt->fmt.vbi);\r\nif (ret)\r\nreturn ret;\r\ncx->vbi.sliced_in->service_set = 0;\r\ncx->vbi.in.type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nreturn cx18_g_fmt_vbi_cap(file, fh, fmt);\r\n}\r\nstatic int cx18_s_fmt_sliced_vbi_cap(struct file *file, void *fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct cx18_open_id *id = fh2id(fh);\r\nstruct cx18 *cx = id->cx;\r\nint ret;\r\nstruct v4l2_sliced_vbi_format *vbifmt = &fmt->fmt.sliced;\r\ncx18_try_fmt_sliced_vbi_cap(file, fh, fmt);\r\nif (cx18_raw_vbi(cx) && atomic_read(&cx->ana_capturing) > 0)\r\nreturn -EBUSY;\r\nret = v4l2_subdev_call(cx->sd_av, vbi, s_sliced_fmt, &fmt->fmt.sliced);\r\nif (ret)\r\nreturn ret;\r\ncx->vbi.in.type = V4L2_BUF_TYPE_SLICED_VBI_CAPTURE;\r\nmemcpy(cx->vbi.sliced_in, vbifmt, sizeof(*cx->vbi.sliced_in));\r\nreturn 0;\r\n}\r\nstatic int cx18_g_register(struct file *file, void *fh,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nif (reg->reg & 0x3)\r\nreturn -EINVAL;\r\nif (reg->reg >= CX18_MEM_OFFSET + CX18_MEM_SIZE)\r\nreturn -EINVAL;\r\nreg->size = 4;\r\nreg->val = cx18_read_enc(cx, reg->reg);\r\nreturn 0;\r\n}\r\nstatic int cx18_s_register(struct file *file, void *fh,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nif (reg->reg & 0x3)\r\nreturn -EINVAL;\r\nif (reg->reg >= CX18_MEM_OFFSET + CX18_MEM_SIZE)\r\nreturn -EINVAL;\r\ncx18_write_enc(cx, reg->val, reg->reg);\r\nreturn 0;\r\n}\r\nstatic int cx18_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *vcap)\r\n{\r\nstruct cx18_open_id *id = fh2id(fh);\r\nstruct cx18_stream *s = video_drvdata(file);\r\nstruct cx18 *cx = id->cx;\r\nstrlcpy(vcap->driver, CX18_DRIVER_NAME, sizeof(vcap->driver));\r\nstrlcpy(vcap->card, cx->card_name, sizeof(vcap->card));\r\nsnprintf(vcap->bus_info, sizeof(vcap->bus_info),\r\n"PCI:%s", pci_name(cx->pci_dev));\r\nvcap->capabilities = cx->v4l2_cap;\r\nvcap->device_caps = s->v4l2_dev_caps;\r\nvcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int cx18_enumaudio(struct file *file, void *fh, struct v4l2_audio *vin)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nreturn cx18_get_audio_input(cx, vin->index, vin);\r\n}\r\nstatic int cx18_g_audio(struct file *file, void *fh, struct v4l2_audio *vin)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nvin->index = cx->audio_input;\r\nreturn cx18_get_audio_input(cx, vin->index, vin);\r\n}\r\nstatic int cx18_s_audio(struct file *file, void *fh, const struct v4l2_audio *vout)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nif (vout->index >= cx->nof_audio_inputs)\r\nreturn -EINVAL;\r\ncx->audio_input = vout->index;\r\ncx18_audio_set_io(cx);\r\nreturn 0;\r\n}\r\nstatic int cx18_enum_input(struct file *file, void *fh, struct v4l2_input *vin)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nreturn cx18_get_input(cx, vin->index, vin);\r\n}\r\nstatic int cx18_cropcap(struct file *file, void *fh,\r\nstruct v4l2_cropcap *cropcap)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nif (cropcap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\ncropcap->pixelaspect.numerator = cx->is_50hz ? 54 : 11;\r\ncropcap->pixelaspect.denominator = cx->is_50hz ? 59 : 10;\r\nreturn 0;\r\n}\r\nstatic int cx18_g_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *sel)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\nsel->r.top = sel->r.left = 0;\r\nsel->r.width = 720;\r\nsel->r.height = cx->is_50hz ? 576 : 480;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx18_enum_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nstatic const struct v4l2_fmtdesc formats[] = {\r\n{ 0, V4L2_BUF_TYPE_VIDEO_CAPTURE, 0,\r\n"HM12 (YUV 4:1:1)", V4L2_PIX_FMT_HM12, { 0, 0, 0, 0 }\r\n},\r\n{ 1, V4L2_BUF_TYPE_VIDEO_CAPTURE, V4L2_FMT_FLAG_COMPRESSED,\r\n"MPEG", V4L2_PIX_FMT_MPEG, { 0, 0, 0, 0 }\r\n},\r\n{ 2, V4L2_BUF_TYPE_VIDEO_CAPTURE, 0,\r\n"UYVY 4:2:2", V4L2_PIX_FMT_UYVY, { 0, 0, 0, 0 }\r\n},\r\n};\r\nif (fmt->index > ARRAY_SIZE(formats) - 1)\r\nreturn -EINVAL;\r\n*fmt = formats[fmt->index];\r\nreturn 0;\r\n}\r\nstatic int cx18_g_input(struct file *file, void *fh, unsigned int *i)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\n*i = cx->active_input;\r\nreturn 0;\r\n}\r\nint cx18_s_input(struct file *file, void *fh, unsigned int inp)\r\n{\r\nstruct cx18_open_id *id = fh2id(fh);\r\nstruct cx18 *cx = id->cx;\r\nv4l2_std_id std = V4L2_STD_ALL;\r\nconst struct cx18_card_video_input *card_input =\r\ncx->card->video_inputs + inp;\r\nif (inp >= cx->nof_inputs)\r\nreturn -EINVAL;\r\nif (inp == cx->active_input) {\r\nCX18_DEBUG_INFO("Input unchanged\n");\r\nreturn 0;\r\n}\r\nCX18_DEBUG_INFO("Changing input from %d to %d\n",\r\ncx->active_input, inp);\r\ncx->active_input = inp;\r\ncx->audio_input = cx->card->video_inputs[inp].audio_index;\r\nif (card_input->video_type == V4L2_INPUT_TYPE_TUNER)\r\nstd = cx->tuner_std;\r\ncx->streams[CX18_ENC_STREAM_TYPE_MPG].video_dev.tvnorms = std;\r\ncx->streams[CX18_ENC_STREAM_TYPE_YUV].video_dev.tvnorms = std;\r\ncx->streams[CX18_ENC_STREAM_TYPE_VBI].video_dev.tvnorms = std;\r\ncx18_mute(cx);\r\ncx18_video_set_io(cx);\r\ncx18_audio_set_io(cx);\r\ncx18_unmute(cx);\r\nreturn 0;\r\n}\r\nstatic int cx18_g_frequency(struct file *file, void *fh,\r\nstruct v4l2_frequency *vf)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nif (vf->tuner != 0)\r\nreturn -EINVAL;\r\ncx18_call_all(cx, tuner, g_frequency, vf);\r\nreturn 0;\r\n}\r\nint cx18_s_frequency(struct file *file, void *fh, const struct v4l2_frequency *vf)\r\n{\r\nstruct cx18_open_id *id = fh2id(fh);\r\nstruct cx18 *cx = id->cx;\r\nif (vf->tuner != 0)\r\nreturn -EINVAL;\r\ncx18_mute(cx);\r\nCX18_DEBUG_INFO("v4l2 ioctl: set frequency %d\n", vf->frequency);\r\ncx18_call_all(cx, tuner, s_frequency, vf);\r\ncx18_unmute(cx);\r\nreturn 0;\r\n}\r\nstatic int cx18_g_std(struct file *file, void *fh, v4l2_std_id *std)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\n*std = cx->std;\r\nreturn 0;\r\n}\r\nint cx18_s_std(struct file *file, void *fh, v4l2_std_id std)\r\n{\r\nstruct cx18_open_id *id = fh2id(fh);\r\nstruct cx18 *cx = id->cx;\r\nif ((std & V4L2_STD_ALL) == 0)\r\nreturn -EINVAL;\r\nif (std == cx->std)\r\nreturn 0;\r\nif (test_bit(CX18_F_I_RADIO_USER, &cx->i_flags) ||\r\natomic_read(&cx->ana_capturing) > 0) {\r\nreturn -EBUSY;\r\n}\r\ncx->std = std;\r\ncx->is_60hz = (std & V4L2_STD_525_60) ? 1 : 0;\r\ncx->is_50hz = !cx->is_60hz;\r\ncx2341x_handler_set_50hz(&cx->cxhdl, cx->is_50hz);\r\ncx->cxhdl.width = 720;\r\ncx->cxhdl.height = cx->is_50hz ? 576 : 480;\r\ncx->vbi.count = cx->is_50hz ? 18 : 12;\r\ncx->vbi.start[0] = cx->is_50hz ? 6 : 10;\r\ncx->vbi.start[1] = cx->is_50hz ? 318 : 273;\r\nCX18_DEBUG_INFO("Switching standard to %llx.\n",\r\n(unsigned long long) cx->std);\r\ncx18_call_all(cx, video, s_std, cx->std);\r\nreturn 0;\r\n}\r\nstatic int cx18_s_tuner(struct file *file, void *fh, const struct v4l2_tuner *vt)\r\n{\r\nstruct cx18_open_id *id = fh2id(fh);\r\nstruct cx18 *cx = id->cx;\r\nif (vt->index != 0)\r\nreturn -EINVAL;\r\ncx18_call_all(cx, tuner, s_tuner, vt);\r\nreturn 0;\r\n}\r\nstatic int cx18_g_tuner(struct file *file, void *fh, struct v4l2_tuner *vt)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nif (vt->index != 0)\r\nreturn -EINVAL;\r\ncx18_call_all(cx, tuner, g_tuner, vt);\r\nif (vt->type == V4L2_TUNER_RADIO)\r\nstrlcpy(vt->name, "cx18 Radio Tuner", sizeof(vt->name));\r\nelse\r\nstrlcpy(vt->name, "cx18 TV Tuner", sizeof(vt->name));\r\nreturn 0;\r\n}\r\nstatic int cx18_g_sliced_vbi_cap(struct file *file, void *fh,\r\nstruct v4l2_sliced_vbi_cap *cap)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nint set = cx->is_50hz ? V4L2_SLICED_VBI_625 : V4L2_SLICED_VBI_525;\r\nint f, l;\r\nif (cap->type != V4L2_BUF_TYPE_SLICED_VBI_CAPTURE)\r\nreturn -EINVAL;\r\ncap->service_set = 0;\r\nfor (f = 0; f < 2; f++) {\r\nfor (l = 0; l < 24; l++) {\r\nif (valid_service_line(f, l, cx->is_50hz)) {\r\ncap->service_lines[f][l] = set;\r\ncap->service_set |= set;\r\n} else\r\ncap->service_lines[f][l] = 0;\r\n}\r\n}\r\nfor (f = 0; f < 3; f++)\r\ncap->reserved[f] = 0;\r\nreturn 0;\r\n}\r\nstatic int _cx18_process_idx_data(struct cx18_buffer *buf,\r\nstruct v4l2_enc_idx *idx)\r\n{\r\nint consumed, remaining;\r\nstruct v4l2_enc_idx_entry *e_idx;\r\nstruct cx18_enc_idx_entry *e_buf;\r\nconst int mapping[8] = {\r\n-1, V4L2_ENC_IDX_FRAME_I, V4L2_ENC_IDX_FRAME_P,\r\n-1, V4L2_ENC_IDX_FRAME_B, -1, -1, -1\r\n};\r\nremaining = buf->bytesused - buf->readpos;\r\nconsumed = 0;\r\ne_idx = &idx->entry[idx->entries];\r\ne_buf = (struct cx18_enc_idx_entry *) &buf->buf[buf->readpos];\r\nwhile (remaining >= sizeof(struct cx18_enc_idx_entry) &&\r\nidx->entries < V4L2_ENC_IDX_ENTRIES) {\r\ne_idx->offset = (((u64) le32_to_cpu(e_buf->offset_high)) << 32)\r\n| le32_to_cpu(e_buf->offset_low);\r\ne_idx->pts = (((u64) (le32_to_cpu(e_buf->pts_high) & 1)) << 32)\r\n| le32_to_cpu(e_buf->pts_low);\r\ne_idx->length = le32_to_cpu(e_buf->length);\r\ne_idx->flags = mapping[le32_to_cpu(e_buf->flags) & 0x7];\r\ne_idx->reserved[0] = 0;\r\ne_idx->reserved[1] = 0;\r\nidx->entries++;\r\ne_idx = &idx->entry[idx->entries];\r\ne_buf++;\r\nremaining -= sizeof(struct cx18_enc_idx_entry);\r\nconsumed += sizeof(struct cx18_enc_idx_entry);\r\n}\r\nif (remaining > 0 && remaining < sizeof(struct cx18_enc_idx_entry))\r\nconsumed += remaining;\r\nbuf->readpos += consumed;\r\nreturn consumed;\r\n}\r\nstatic int cx18_process_idx_data(struct cx18_stream *s, struct cx18_mdl *mdl,\r\nstruct v4l2_enc_idx *idx)\r\n{\r\nif (s->type != CX18_ENC_STREAM_TYPE_IDX)\r\nreturn -EINVAL;\r\nif (mdl->curr_buf == NULL)\r\nmdl->curr_buf = list_first_entry(&mdl->buf_list,\r\nstruct cx18_buffer, list);\r\nif (list_entry_is_past_end(mdl->curr_buf, &mdl->buf_list, list)) {\r\nmdl->readpos = mdl->bytesused;\r\nreturn 0;\r\n}\r\nlist_for_each_entry_from(mdl->curr_buf, &mdl->buf_list, list) {\r\nif (mdl->curr_buf->readpos >= mdl->curr_buf->bytesused)\r\ncontinue;\r\nmdl->readpos += _cx18_process_idx_data(mdl->curr_buf, idx);\r\nif (idx->entries >= V4L2_ENC_IDX_ENTRIES ||\r\nmdl->curr_buf->readpos < mdl->curr_buf->bytesused ||\r\nmdl->readpos >= mdl->bytesused)\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx18_g_enc_index(struct file *file, void *fh,\r\nstruct v4l2_enc_idx *idx)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nstruct cx18_stream *s = &cx->streams[CX18_ENC_STREAM_TYPE_IDX];\r\ns32 tmp;\r\nstruct cx18_mdl *mdl;\r\nif (!cx18_stream_enabled(s))\r\nreturn -EINVAL;\r\ntmp = s->buffers -\r\ns->bufs_per_mdl * CX18_ENC_STREAM_TYPE_IDX_FW_MDL_MIN;\r\nif (tmp <= 0)\r\ntmp = 1;\r\ntmp = tmp * s->buf_size / sizeof(struct cx18_enc_idx_entry);\r\nidx->entries = 0;\r\nidx->entries_cap = tmp;\r\nmemset(idx->reserved, 0, sizeof(idx->reserved));\r\ndo {\r\nmdl = cx18_dequeue(s, &s->q_full);\r\nif (mdl == NULL)\r\nbreak;\r\ncx18_process_idx_data(s, mdl, idx);\r\nif (mdl->readpos < mdl->bytesused) {\r\ncx18_push(s, mdl, &s->q_full);\r\nbreak;\r\n}\r\ncx18_enqueue(s, mdl, &s->q_free);\r\n} while (idx->entries < V4L2_ENC_IDX_ENTRIES);\r\ncx18_stream_load_fw_queue(s);\r\nreturn 0;\r\n}\r\nstatic struct videobuf_queue *cx18_vb_queue(struct cx18_open_id *id)\r\n{\r\nstruct videobuf_queue *q = NULL;\r\nstruct cx18 *cx = id->cx;\r\nstruct cx18_stream *s = &cx->streams[id->type];\r\nswitch (s->vb_type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nq = &s->vbuf_q;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn q;\r\n}\r\nstatic int cx18_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct cx18_open_id *id = file->private_data;\r\nstruct cx18 *cx = id->cx;\r\nstruct cx18_stream *s = &cx->streams[id->type];\r\nif ((s->vb_type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n(s->vb_type != V4L2_BUF_TYPE_VBI_CAPTURE))\r\nreturn -EINVAL;\r\nif (id->type != CX18_ENC_STREAM_TYPE_YUV)\r\nreturn -EINVAL;\r\nmod_timer(&s->vb_timeout, msecs_to_jiffies(2000) + jiffies);\r\nreturn videobuf_streamon(cx18_vb_queue(id));\r\n}\r\nstatic int cx18_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct cx18_open_id *id = file->private_data;\r\nstruct cx18 *cx = id->cx;\r\nstruct cx18_stream *s = &cx->streams[id->type];\r\nif ((s->vb_type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n(s->vb_type != V4L2_BUF_TYPE_VBI_CAPTURE))\r\nreturn -EINVAL;\r\nif (id->type != CX18_ENC_STREAM_TYPE_YUV)\r\nreturn -EINVAL;\r\nreturn videobuf_streamoff(cx18_vb_queue(id));\r\n}\r\nstatic int cx18_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nstruct cx18_open_id *id = file->private_data;\r\nstruct cx18 *cx = id->cx;\r\nstruct cx18_stream *s = &cx->streams[id->type];\r\nif ((s->vb_type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n(s->vb_type != V4L2_BUF_TYPE_VBI_CAPTURE))\r\nreturn -EINVAL;\r\nreturn videobuf_reqbufs(cx18_vb_queue(id), rb);\r\n}\r\nstatic int cx18_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *b)\r\n{\r\nstruct cx18_open_id *id = file->private_data;\r\nstruct cx18 *cx = id->cx;\r\nstruct cx18_stream *s = &cx->streams[id->type];\r\nif ((s->vb_type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n(s->vb_type != V4L2_BUF_TYPE_VBI_CAPTURE))\r\nreturn -EINVAL;\r\nreturn videobuf_querybuf(cx18_vb_queue(id), b);\r\n}\r\nstatic int cx18_qbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct cx18_open_id *id = file->private_data;\r\nstruct cx18 *cx = id->cx;\r\nstruct cx18_stream *s = &cx->streams[id->type];\r\nif ((s->vb_type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n(s->vb_type != V4L2_BUF_TYPE_VBI_CAPTURE))\r\nreturn -EINVAL;\r\nreturn videobuf_qbuf(cx18_vb_queue(id), b);\r\n}\r\nstatic int cx18_dqbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct cx18_open_id *id = file->private_data;\r\nstruct cx18 *cx = id->cx;\r\nstruct cx18_stream *s = &cx->streams[id->type];\r\nif ((s->vb_type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n(s->vb_type != V4L2_BUF_TYPE_VBI_CAPTURE))\r\nreturn -EINVAL;\r\nreturn videobuf_dqbuf(cx18_vb_queue(id), b, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int cx18_encoder_cmd(struct file *file, void *fh,\r\nstruct v4l2_encoder_cmd *enc)\r\n{\r\nstruct cx18_open_id *id = fh2id(fh);\r\nstruct cx18 *cx = id->cx;\r\nu32 h;\r\nswitch (enc->cmd) {\r\ncase V4L2_ENC_CMD_START:\r\nCX18_DEBUG_IOCTL("V4L2_ENC_CMD_START\n");\r\nenc->flags = 0;\r\nreturn cx18_start_capture(id);\r\ncase V4L2_ENC_CMD_STOP:\r\nCX18_DEBUG_IOCTL("V4L2_ENC_CMD_STOP\n");\r\nenc->flags &= V4L2_ENC_CMD_STOP_AT_GOP_END;\r\ncx18_stop_capture(id,\r\nenc->flags & V4L2_ENC_CMD_STOP_AT_GOP_END);\r\nbreak;\r\ncase V4L2_ENC_CMD_PAUSE:\r\nCX18_DEBUG_IOCTL("V4L2_ENC_CMD_PAUSE\n");\r\nenc->flags = 0;\r\nif (!atomic_read(&cx->ana_capturing))\r\nreturn -EPERM;\r\nif (test_and_set_bit(CX18_F_I_ENC_PAUSED, &cx->i_flags))\r\nreturn 0;\r\nh = cx18_find_handle(cx);\r\nif (h == CX18_INVALID_TASK_HANDLE) {\r\nCX18_ERR("Can't find valid task handle for V4L2_ENC_CMD_PAUSE\n");\r\nreturn -EBADFD;\r\n}\r\ncx18_mute(cx);\r\ncx18_vapi(cx, CX18_CPU_CAPTURE_PAUSE, 1, h);\r\nbreak;\r\ncase V4L2_ENC_CMD_RESUME:\r\nCX18_DEBUG_IOCTL("V4L2_ENC_CMD_RESUME\n");\r\nenc->flags = 0;\r\nif (!atomic_read(&cx->ana_capturing))\r\nreturn -EPERM;\r\nif (!test_and_clear_bit(CX18_F_I_ENC_PAUSED, &cx->i_flags))\r\nreturn 0;\r\nh = cx18_find_handle(cx);\r\nif (h == CX18_INVALID_TASK_HANDLE) {\r\nCX18_ERR("Can't find valid task handle for V4L2_ENC_CMD_RESUME\n");\r\nreturn -EBADFD;\r\n}\r\ncx18_vapi(cx, CX18_CPU_CAPTURE_RESUME, 1, h);\r\ncx18_unmute(cx);\r\nbreak;\r\ndefault:\r\nCX18_DEBUG_IOCTL("Unknown cmd %d\n", enc->cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx18_try_encoder_cmd(struct file *file, void *fh,\r\nstruct v4l2_encoder_cmd *enc)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nswitch (enc->cmd) {\r\ncase V4L2_ENC_CMD_START:\r\nCX18_DEBUG_IOCTL("V4L2_ENC_CMD_START\n");\r\nenc->flags = 0;\r\nbreak;\r\ncase V4L2_ENC_CMD_STOP:\r\nCX18_DEBUG_IOCTL("V4L2_ENC_CMD_STOP\n");\r\nenc->flags &= V4L2_ENC_CMD_STOP_AT_GOP_END;\r\nbreak;\r\ncase V4L2_ENC_CMD_PAUSE:\r\nCX18_DEBUG_IOCTL("V4L2_ENC_CMD_PAUSE\n");\r\nenc->flags = 0;\r\nbreak;\r\ncase V4L2_ENC_CMD_RESUME:\r\nCX18_DEBUG_IOCTL("V4L2_ENC_CMD_RESUME\n");\r\nenc->flags = 0;\r\nbreak;\r\ndefault:\r\nCX18_DEBUG_IOCTL("Unknown cmd %d\n", enc->cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx18_log_status(struct file *file, void *fh)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nstruct v4l2_input vidin;\r\nstruct v4l2_audio audin;\r\nint i;\r\nCX18_INFO("Version: %s Card: %s\n", CX18_VERSION, cx->card_name);\r\nif (cx->hw_flags & CX18_HW_TVEEPROM) {\r\nstruct tveeprom tv;\r\ncx18_read_eeprom(cx, &tv);\r\n}\r\ncx18_call_all(cx, core, log_status);\r\ncx18_get_input(cx, cx->active_input, &vidin);\r\ncx18_get_audio_input(cx, cx->audio_input, &audin);\r\nCX18_INFO("Video Input: %s\n", vidin.name);\r\nCX18_INFO("Audio Input: %s\n", audin.name);\r\nmutex_lock(&cx->gpio_lock);\r\nCX18_INFO("GPIO: direction 0x%08x, value 0x%08x\n",\r\ncx->gpio_dir, cx->gpio_val);\r\nmutex_unlock(&cx->gpio_lock);\r\nCX18_INFO("Tuner: %s\n",\r\ntest_bit(CX18_F_I_RADIO_USER, &cx->i_flags) ? "Radio" : "TV");\r\nv4l2_ctrl_handler_log_status(&cx->cxhdl.hdl, cx->v4l2_dev.name);\r\nCX18_INFO("Status flags: 0x%08lx\n", cx->i_flags);\r\nfor (i = 0; i < CX18_MAX_STREAMS; i++) {\r\nstruct cx18_stream *s = &cx->streams[i];\r\nif (s->video_dev.v4l2_dev == NULL || s->buffers == 0)\r\ncontinue;\r\nCX18_INFO("Stream %s: status 0x%04lx, %d%% of %d KiB (%d buffers) in use\n",\r\ns->name, s->s_flags,\r\natomic_read(&s->q_full.depth) * s->bufs_per_mdl * 100\r\n/ s->buffers,\r\n(s->buffers * s->buf_size) / 1024, s->buffers);\r\n}\r\nCX18_INFO("Read MPEG/VBI: %lld/%lld bytes\n",\r\n(long long)cx->mpg_data_received,\r\n(long long)cx->vbi_data_inserted);\r\nreturn 0;\r\n}\r\nstatic long cx18_default(struct file *file, void *fh, bool valid_prio,\r\nunsigned int cmd, void *arg)\r\n{\r\nstruct cx18 *cx = fh2id(fh)->cx;\r\nswitch (cmd) {\r\ncase VIDIOC_INT_RESET: {\r\nu32 val = *(u32 *)arg;\r\nif ((val == 0) || (val & 0x01))\r\ncx18_call_hw(cx, CX18_HW_GPIO_RESET_CTRL, core, reset,\r\n(u32) CX18_GPIO_RESET_Z8F0811);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nvoid cx18_set_funcs(struct video_device *vdev)\r\n{\r\nvdev->ioctl_ops = &cx18_ioctl_ops;\r\n}
