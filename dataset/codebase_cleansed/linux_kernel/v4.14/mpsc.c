static void mpsc_brg_init(struct mpsc_port_info *pi, u32 clk_src)\r\n{\r\nu32 v;\r\nv = (pi->mirror_regs) ? pi->BRG_BCR_m : readl(pi->brg_base + BRG_BCR);\r\nv = (v & ~(0xf << 18)) | ((clk_src & 0xf) << 18);\r\nif (pi->brg_can_tune)\r\nv &= ~(1 << 25);\r\nif (pi->mirror_regs)\r\npi->BRG_BCR_m = v;\r\nwritel(v, pi->brg_base + BRG_BCR);\r\nwritel(readl(pi->brg_base + BRG_BTR) & 0xffff0000,\r\npi->brg_base + BRG_BTR);\r\n}\r\nstatic void mpsc_brg_enable(struct mpsc_port_info *pi)\r\n{\r\nu32 v;\r\nv = (pi->mirror_regs) ? pi->BRG_BCR_m : readl(pi->brg_base + BRG_BCR);\r\nv |= (1 << 16);\r\nif (pi->mirror_regs)\r\npi->BRG_BCR_m = v;\r\nwritel(v, pi->brg_base + BRG_BCR);\r\n}\r\nstatic void mpsc_brg_disable(struct mpsc_port_info *pi)\r\n{\r\nu32 v;\r\nv = (pi->mirror_regs) ? pi->BRG_BCR_m : readl(pi->brg_base + BRG_BCR);\r\nv &= ~(1 << 16);\r\nif (pi->mirror_regs)\r\npi->BRG_BCR_m = v;\r\nwritel(v, pi->brg_base + BRG_BCR);\r\n}\r\nstatic void mpsc_set_baudrate(struct mpsc_port_info *pi, u32 baud)\r\n{\r\nu32 cdv = (pi->port.uartclk / (baud << 5)) - 1;\r\nu32 v;\r\nmpsc_brg_disable(pi);\r\nv = (pi->mirror_regs) ? pi->BRG_BCR_m : readl(pi->brg_base + BRG_BCR);\r\nv = (v & 0xffff0000) | (cdv & 0xffff);\r\nif (pi->mirror_regs)\r\npi->BRG_BCR_m = v;\r\nwritel(v, pi->brg_base + BRG_BCR);\r\nmpsc_brg_enable(pi);\r\n}\r\nstatic void mpsc_sdma_burstsize(struct mpsc_port_info *pi, u32 burst_size)\r\n{\r\nu32 v;\r\npr_debug("mpsc_sdma_burstsize[%d]: burst_size: %d\n",\r\npi->port.line, burst_size);\r\nburst_size >>= 3;\r\nif (burst_size < 2)\r\nv = 0x0;\r\nelse if (burst_size < 4)\r\nv = 0x1;\r\nelse if (burst_size < 8)\r\nv = 0x2;\r\nelse\r\nv = 0x3;\r\nwritel((readl(pi->sdma_base + SDMA_SDC) & (0x3 << 12)) | (v << 12),\r\npi->sdma_base + SDMA_SDC);\r\n}\r\nstatic void mpsc_sdma_init(struct mpsc_port_info *pi, u32 burst_size)\r\n{\r\npr_debug("mpsc_sdma_init[%d]: burst_size: %d\n", pi->port.line,\r\nburst_size);\r\nwritel((readl(pi->sdma_base + SDMA_SDC) & 0x3ff) | 0x03f,\r\npi->sdma_base + SDMA_SDC);\r\nmpsc_sdma_burstsize(pi, burst_size);\r\n}\r\nstatic u32 mpsc_sdma_intr_mask(struct mpsc_port_info *pi, u32 mask)\r\n{\r\nu32 old, v;\r\npr_debug("mpsc_sdma_intr_mask[%d]: mask: 0x%x\n", pi->port.line, mask);\r\nold = v = (pi->mirror_regs) ? pi->shared_regs->SDMA_INTR_MASK_m :\r\nreadl(pi->shared_regs->sdma_intr_base + SDMA_INTR_MASK);\r\nmask &= 0xf;\r\nif (pi->port.line)\r\nmask <<= 8;\r\nv &= ~mask;\r\nif (pi->mirror_regs)\r\npi->shared_regs->SDMA_INTR_MASK_m = v;\r\nwritel(v, pi->shared_regs->sdma_intr_base + SDMA_INTR_MASK);\r\nif (pi->port.line)\r\nold >>= 8;\r\nreturn old & 0xf;\r\n}\r\nstatic void mpsc_sdma_intr_unmask(struct mpsc_port_info *pi, u32 mask)\r\n{\r\nu32 v;\r\npr_debug("mpsc_sdma_intr_unmask[%d]: mask: 0x%x\n", pi->port.line,mask);\r\nv = (pi->mirror_regs) ? pi->shared_regs->SDMA_INTR_MASK_m\r\n: readl(pi->shared_regs->sdma_intr_base + SDMA_INTR_MASK);\r\nmask &= 0xf;\r\nif (pi->port.line)\r\nmask <<= 8;\r\nv |= mask;\r\nif (pi->mirror_regs)\r\npi->shared_regs->SDMA_INTR_MASK_m = v;\r\nwritel(v, pi->shared_regs->sdma_intr_base + SDMA_INTR_MASK);\r\n}\r\nstatic void mpsc_sdma_intr_ack(struct mpsc_port_info *pi)\r\n{\r\npr_debug("mpsc_sdma_intr_ack[%d]: Acknowledging IRQ\n", pi->port.line);\r\nif (pi->mirror_regs)\r\npi->shared_regs->SDMA_INTR_CAUSE_m = 0;\r\nwriteb(0x00, pi->shared_regs->sdma_intr_base + SDMA_INTR_CAUSE\r\n+ pi->port.line);\r\n}\r\nstatic void mpsc_sdma_set_rx_ring(struct mpsc_port_info *pi,\r\nstruct mpsc_rx_desc *rxre_p)\r\n{\r\npr_debug("mpsc_sdma_set_rx_ring[%d]: rxre_p: 0x%x\n",\r\npi->port.line, (u32)rxre_p);\r\nwritel((u32)rxre_p, pi->sdma_base + SDMA_SCRDP);\r\n}\r\nstatic void mpsc_sdma_set_tx_ring(struct mpsc_port_info *pi,\r\nstruct mpsc_tx_desc *txre_p)\r\n{\r\nwritel((u32)txre_p, pi->sdma_base + SDMA_SFTDP);\r\nwritel((u32)txre_p, pi->sdma_base + SDMA_SCTDP);\r\n}\r\nstatic void mpsc_sdma_cmd(struct mpsc_port_info *pi, u32 val)\r\n{\r\nu32 v;\r\nv = readl(pi->sdma_base + SDMA_SDCM);\r\nif (val)\r\nv |= val;\r\nelse\r\nv = 0;\r\nwmb();\r\nwritel(v, pi->sdma_base + SDMA_SDCM);\r\nwmb();\r\n}\r\nstatic uint mpsc_sdma_tx_active(struct mpsc_port_info *pi)\r\n{\r\nreturn readl(pi->sdma_base + SDMA_SDCM) & SDMA_SDCM_TXD;\r\n}\r\nstatic void mpsc_sdma_start_tx(struct mpsc_port_info *pi)\r\n{\r\nstruct mpsc_tx_desc *txre, *txre_p;\r\nif (!mpsc_sdma_tx_active(pi)) {\r\ntxre = (struct mpsc_tx_desc *)(pi->txr\r\n+ (pi->txr_tail * MPSC_TXRE_SIZE));\r\ndma_cache_sync(pi->port.dev, (void *)txre, MPSC_TXRE_SIZE,\r\nDMA_FROM_DEVICE);\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (pi->cache_mgmt)\r\ninvalidate_dcache_range((ulong)txre,\r\n(ulong)txre + MPSC_TXRE_SIZE);\r\n#endif\r\nif (be32_to_cpu(txre->cmdstat) & SDMA_DESC_CMDSTAT_O) {\r\ntxre_p = (struct mpsc_tx_desc *)\r\n(pi->txr_p + (pi->txr_tail * MPSC_TXRE_SIZE));\r\nmpsc_sdma_set_tx_ring(pi, txre_p);\r\nmpsc_sdma_cmd(pi, SDMA_SDCM_STD | SDMA_SDCM_TXD);\r\n}\r\n}\r\n}\r\nstatic void mpsc_sdma_stop(struct mpsc_port_info *pi)\r\n{\r\npr_debug("mpsc_sdma_stop[%d]: Stopping SDMA\n", pi->port.line);\r\nmpsc_sdma_cmd(pi, 0);\r\nmpsc_sdma_cmd(pi, SDMA_SDCM_AR | SDMA_SDCM_AT);\r\nmpsc_sdma_set_tx_ring(pi, NULL);\r\nmpsc_sdma_set_rx_ring(pi, NULL);\r\nmpsc_sdma_intr_mask(pi, 0xf);\r\nmpsc_sdma_intr_ack(pi);\r\n}\r\nstatic void mpsc_hw_init(struct mpsc_port_info *pi)\r\n{\r\nu32 v;\r\npr_debug("mpsc_hw_init[%d]: Initializing hardware\n", pi->port.line);\r\nif (pi->mirror_regs) {\r\nv = pi->shared_regs->MPSC_MRR_m;\r\nv &= ~0x1c7;\r\npi->shared_regs->MPSC_MRR_m = v;\r\nwritel(v, pi->shared_regs->mpsc_routing_base + MPSC_MRR);\r\nv = pi->shared_regs->MPSC_RCRR_m;\r\nv = (v & ~0xf0f) | 0x100;\r\npi->shared_regs->MPSC_RCRR_m = v;\r\nwritel(v, pi->shared_regs->mpsc_routing_base + MPSC_RCRR);\r\nv = pi->shared_regs->MPSC_TCRR_m;\r\nv = (v & ~0xf0f) | 0x100;\r\npi->shared_regs->MPSC_TCRR_m = v;\r\nwritel(v, pi->shared_regs->mpsc_routing_base + MPSC_TCRR);\r\n} else {\r\nv = readl(pi->shared_regs->mpsc_routing_base + MPSC_MRR);\r\nv &= ~0x1c7;\r\nwritel(v, pi->shared_regs->mpsc_routing_base + MPSC_MRR);\r\nv = readl(pi->shared_regs->mpsc_routing_base + MPSC_RCRR);\r\nv = (v & ~0xf0f) | 0x100;\r\nwritel(v, pi->shared_regs->mpsc_routing_base + MPSC_RCRR);\r\nv = readl(pi->shared_regs->mpsc_routing_base + MPSC_TCRR);\r\nv = (v & ~0xf0f) | 0x100;\r\nwritel(v, pi->shared_regs->mpsc_routing_base + MPSC_TCRR);\r\n}\r\nwritel(0x000004c4, pi->mpsc_base + MPSC_MMCRL);\r\nwritel(0x04400400, pi->mpsc_base + MPSC_MMCRH);\r\nmpsc_set_baudrate(pi, pi->default_baud);\r\nif (pi->mirror_regs) {\r\npi->MPSC_CHR_1_m = 0;\r\npi->MPSC_CHR_2_m = 0;\r\n}\r\nwritel(0, pi->mpsc_base + MPSC_CHR_1);\r\nwritel(0, pi->mpsc_base + MPSC_CHR_2);\r\nwritel(pi->mpsc_max_idle, pi->mpsc_base + MPSC_CHR_3);\r\nwritel(0, pi->mpsc_base + MPSC_CHR_4);\r\nwritel(0, pi->mpsc_base + MPSC_CHR_5);\r\nwritel(0, pi->mpsc_base + MPSC_CHR_6);\r\nwritel(0, pi->mpsc_base + MPSC_CHR_7);\r\nwritel(0, pi->mpsc_base + MPSC_CHR_8);\r\nwritel(0, pi->mpsc_base + MPSC_CHR_9);\r\nwritel(0, pi->mpsc_base + MPSC_CHR_10);\r\n}\r\nstatic void mpsc_enter_hunt(struct mpsc_port_info *pi)\r\n{\r\npr_debug("mpsc_enter_hunt[%d]: Hunting...\n", pi->port.line);\r\nif (pi->mirror_regs) {\r\nwritel(pi->MPSC_CHR_2_m | MPSC_CHR_2_EH,\r\npi->mpsc_base + MPSC_CHR_2);\r\nudelay(100);\r\n} else {\r\nwritel(readl(pi->mpsc_base + MPSC_CHR_2) | MPSC_CHR_2_EH,\r\npi->mpsc_base + MPSC_CHR_2);\r\nwhile (readl(pi->mpsc_base + MPSC_CHR_2) & MPSC_CHR_2_EH)\r\nudelay(10);\r\n}\r\n}\r\nstatic void mpsc_freeze(struct mpsc_port_info *pi)\r\n{\r\nu32 v;\r\npr_debug("mpsc_freeze[%d]: Freezing\n", pi->port.line);\r\nv = (pi->mirror_regs) ? pi->MPSC_MPCR_m :\r\nreadl(pi->mpsc_base + MPSC_MPCR);\r\nv |= MPSC_MPCR_FRZ;\r\nif (pi->mirror_regs)\r\npi->MPSC_MPCR_m = v;\r\nwritel(v, pi->mpsc_base + MPSC_MPCR);\r\n}\r\nstatic void mpsc_unfreeze(struct mpsc_port_info *pi)\r\n{\r\nu32 v;\r\nv = (pi->mirror_regs) ? pi->MPSC_MPCR_m :\r\nreadl(pi->mpsc_base + MPSC_MPCR);\r\nv &= ~MPSC_MPCR_FRZ;\r\nif (pi->mirror_regs)\r\npi->MPSC_MPCR_m = v;\r\nwritel(v, pi->mpsc_base + MPSC_MPCR);\r\npr_debug("mpsc_unfreeze[%d]: Unfrozen\n", pi->port.line);\r\n}\r\nstatic void mpsc_set_char_length(struct mpsc_port_info *pi, u32 len)\r\n{\r\nu32 v;\r\npr_debug("mpsc_set_char_length[%d]: char len: %d\n", pi->port.line,len);\r\nv = (pi->mirror_regs) ? pi->MPSC_MPCR_m :\r\nreadl(pi->mpsc_base + MPSC_MPCR);\r\nv = (v & ~(0x3 << 12)) | ((len & 0x3) << 12);\r\nif (pi->mirror_regs)\r\npi->MPSC_MPCR_m = v;\r\nwritel(v, pi->mpsc_base + MPSC_MPCR);\r\n}\r\nstatic void mpsc_set_stop_bit_length(struct mpsc_port_info *pi, u32 len)\r\n{\r\nu32 v;\r\npr_debug("mpsc_set_stop_bit_length[%d]: stop bits: %d\n",\r\npi->port.line, len);\r\nv = (pi->mirror_regs) ? pi->MPSC_MPCR_m :\r\nreadl(pi->mpsc_base + MPSC_MPCR);\r\nv = (v & ~(1 << 14)) | ((len & 0x1) << 14);\r\nif (pi->mirror_regs)\r\npi->MPSC_MPCR_m = v;\r\nwritel(v, pi->mpsc_base + MPSC_MPCR);\r\n}\r\nstatic void mpsc_set_parity(struct mpsc_port_info *pi, u32 p)\r\n{\r\nu32 v;\r\npr_debug("mpsc_set_parity[%d]: parity bits: 0x%x\n", pi->port.line, p);\r\nv = (pi->mirror_regs) ? pi->MPSC_CHR_2_m :\r\nreadl(pi->mpsc_base + MPSC_CHR_2);\r\np &= 0x3;\r\nv = (v & ~0xc000c) | (p << 18) | (p << 2);\r\nif (pi->mirror_regs)\r\npi->MPSC_CHR_2_m = v;\r\nwritel(v, pi->mpsc_base + MPSC_CHR_2);\r\n}\r\nstatic void mpsc_init_hw(struct mpsc_port_info *pi)\r\n{\r\npr_debug("mpsc_init_hw[%d]: Initializing\n", pi->port.line);\r\nmpsc_brg_init(pi, pi->brg_clk_src);\r\nmpsc_brg_enable(pi);\r\nmpsc_sdma_init(pi, dma_get_cache_alignment());\r\nmpsc_sdma_stop(pi);\r\nmpsc_hw_init(pi);\r\n}\r\nstatic int mpsc_alloc_ring_mem(struct mpsc_port_info *pi)\r\n{\r\nint rc = 0;\r\npr_debug("mpsc_alloc_ring_mem[%d]: Allocating ring mem\n",\r\npi->port.line);\r\nif (!pi->dma_region) {\r\nif (!dma_set_mask(pi->port.dev, 0xffffffff)) {\r\nprintk(KERN_ERR "MPSC: Inadequate DMA support\n");\r\nrc = -ENXIO;\r\n} else if ((pi->dma_region = dma_alloc_attrs(pi->port.dev,\r\nMPSC_DMA_ALLOC_SIZE,\r\n&pi->dma_region_p, GFP_KERNEL,\r\nDMA_ATTR_NON_CONSISTENT))\r\n== NULL) {\r\nprintk(KERN_ERR "MPSC: Can't alloc Desc region\n");\r\nrc = -ENOMEM;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic void mpsc_free_ring_mem(struct mpsc_port_info *pi)\r\n{\r\npr_debug("mpsc_free_ring_mem[%d]: Freeing ring mem\n", pi->port.line);\r\nif (pi->dma_region) {\r\ndma_free_attrs(pi->port.dev, MPSC_DMA_ALLOC_SIZE,\r\npi->dma_region, pi->dma_region_p,\r\nDMA_ATTR_NON_CONSISTENT);\r\npi->dma_region = NULL;\r\npi->dma_region_p = (dma_addr_t)NULL;\r\n}\r\n}\r\nstatic void mpsc_init_rings(struct mpsc_port_info *pi)\r\n{\r\nstruct mpsc_rx_desc *rxre;\r\nstruct mpsc_tx_desc *txre;\r\ndma_addr_t dp, dp_p;\r\nu8 *bp, *bp_p;\r\nint i;\r\npr_debug("mpsc_init_rings[%d]: Initializing rings\n", pi->port.line);\r\nBUG_ON(pi->dma_region == NULL);\r\nmemset(pi->dma_region, 0, MPSC_DMA_ALLOC_SIZE);\r\ndp = ALIGN((u32)pi->dma_region, dma_get_cache_alignment());\r\ndp_p = ALIGN((u32)pi->dma_region_p, dma_get_cache_alignment());\r\npi->rxr = dp;\r\npi->rxr_p = dp_p;\r\ndp += MPSC_RXR_SIZE;\r\ndp_p += MPSC_RXR_SIZE;\r\npi->rxb = (u8 *)dp;\r\npi->rxb_p = (u8 *)dp_p;\r\ndp += MPSC_RXB_SIZE;\r\ndp_p += MPSC_RXB_SIZE;\r\npi->rxr_posn = 0;\r\npi->txr = dp;\r\npi->txr_p = dp_p;\r\ndp += MPSC_TXR_SIZE;\r\ndp_p += MPSC_TXR_SIZE;\r\npi->txb = (u8 *)dp;\r\npi->txb_p = (u8 *)dp_p;\r\npi->txr_head = 0;\r\npi->txr_tail = 0;\r\ndp = pi->rxr;\r\ndp_p = pi->rxr_p;\r\nbp = pi->rxb;\r\nbp_p = pi->rxb_p;\r\nfor (i = 0; i < MPSC_RXR_ENTRIES; i++) {\r\nrxre = (struct mpsc_rx_desc *)dp;\r\nrxre->bufsize = cpu_to_be16(MPSC_RXBE_SIZE);\r\nrxre->bytecnt = cpu_to_be16(0);\r\nrxre->cmdstat = cpu_to_be32(SDMA_DESC_CMDSTAT_O\r\n| SDMA_DESC_CMDSTAT_EI | SDMA_DESC_CMDSTAT_F\r\n| SDMA_DESC_CMDSTAT_L);\r\nrxre->link = cpu_to_be32(dp_p + MPSC_RXRE_SIZE);\r\nrxre->buf_ptr = cpu_to_be32(bp_p);\r\ndp += MPSC_RXRE_SIZE;\r\ndp_p += MPSC_RXRE_SIZE;\r\nbp += MPSC_RXBE_SIZE;\r\nbp_p += MPSC_RXBE_SIZE;\r\n}\r\nrxre->link = cpu_to_be32(pi->rxr_p);\r\ndp = pi->txr;\r\ndp_p = pi->txr_p;\r\nbp = pi->txb;\r\nbp_p = pi->txb_p;\r\nfor (i = 0; i < MPSC_TXR_ENTRIES; i++) {\r\ntxre = (struct mpsc_tx_desc *)dp;\r\ntxre->link = cpu_to_be32(dp_p + MPSC_TXRE_SIZE);\r\ntxre->buf_ptr = cpu_to_be32(bp_p);\r\ndp += MPSC_TXRE_SIZE;\r\ndp_p += MPSC_TXRE_SIZE;\r\nbp += MPSC_TXBE_SIZE;\r\nbp_p += MPSC_TXBE_SIZE;\r\n}\r\ntxre->link = cpu_to_be32(pi->txr_p);\r\ndma_cache_sync(pi->port.dev, (void *)pi->dma_region,\r\nMPSC_DMA_ALLOC_SIZE, DMA_BIDIRECTIONAL);\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (pi->cache_mgmt)\r\nflush_dcache_range((ulong)pi->dma_region,\r\n(ulong)pi->dma_region\r\n+ MPSC_DMA_ALLOC_SIZE);\r\n#endif\r\nreturn;\r\n}\r\nstatic void mpsc_uninit_rings(struct mpsc_port_info *pi)\r\n{\r\npr_debug("mpsc_uninit_rings[%d]: Uninitializing rings\n",pi->port.line);\r\nBUG_ON(pi->dma_region == NULL);\r\npi->rxr = 0;\r\npi->rxr_p = 0;\r\npi->rxb = NULL;\r\npi->rxb_p = NULL;\r\npi->rxr_posn = 0;\r\npi->txr = 0;\r\npi->txr_p = 0;\r\npi->txb = NULL;\r\npi->txb_p = NULL;\r\npi->txr_head = 0;\r\npi->txr_tail = 0;\r\n}\r\nstatic int mpsc_make_ready(struct mpsc_port_info *pi)\r\n{\r\nint rc;\r\npr_debug("mpsc_make_ready[%d]: Making cltr ready\n", pi->port.line);\r\nif (!pi->ready) {\r\nmpsc_init_hw(pi);\r\nrc = mpsc_alloc_ring_mem(pi);\r\nif (rc)\r\nreturn rc;\r\nmpsc_init_rings(pi);\r\npi->ready = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpsc_rx_intr(struct mpsc_port_info *pi, unsigned long *flags)\r\n{\r\nstruct mpsc_rx_desc *rxre;\r\nstruct tty_port *port = &pi->port.state->port;\r\nu32 cmdstat, bytes_in, i;\r\nint rc = 0;\r\nu8 *bp;\r\nchar flag = TTY_NORMAL;\r\npr_debug("mpsc_rx_intr[%d]: Handling Rx intr\n", pi->port.line);\r\nrxre = (struct mpsc_rx_desc *)(pi->rxr + (pi->rxr_posn*MPSC_RXRE_SIZE));\r\ndma_cache_sync(pi->port.dev, (void *)rxre, MPSC_RXRE_SIZE,\r\nDMA_FROM_DEVICE);\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (pi->cache_mgmt)\r\ninvalidate_dcache_range((ulong)rxre,\r\n(ulong)rxre + MPSC_RXRE_SIZE);\r\n#endif\r\nwhile (!((cmdstat = be32_to_cpu(rxre->cmdstat))\r\n& SDMA_DESC_CMDSTAT_O)) {\r\nbytes_in = be16_to_cpu(rxre->bytecnt);\r\n#ifdef CONFIG_CONSOLE_POLL\r\nif (unlikely(serial_polled)) {\r\nserial_polled = 0;\r\nreturn 0;\r\n}\r\n#endif\r\nif (tty_buffer_request_room(port, bytes_in) < bytes_in) {\r\nif (port->low_latency) {\r\nspin_unlock_irqrestore(&pi->port.lock, *flags);\r\ntty_flip_buffer_push(port);\r\nspin_lock_irqsave(&pi->port.lock, *flags);\r\n}\r\n}\r\nbp = pi->rxb + (pi->rxr_posn * MPSC_RXBE_SIZE);\r\ndma_cache_sync(pi->port.dev, (void *)bp, MPSC_RXBE_SIZE,\r\nDMA_FROM_DEVICE);\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (pi->cache_mgmt)\r\ninvalidate_dcache_range((ulong)bp,\r\n(ulong)bp + MPSC_RXBE_SIZE);\r\n#endif\r\nif (unlikely(cmdstat & (SDMA_DESC_CMDSTAT_BR\r\n| SDMA_DESC_CMDSTAT_FR\r\n| SDMA_DESC_CMDSTAT_OR))) {\r\npi->port.icount.rx++;\r\nif (cmdstat & SDMA_DESC_CMDSTAT_BR) {\r\npi->port.icount.brk++;\r\nif (uart_handle_break(&pi->port))\r\ngoto next_frame;\r\n} else if (cmdstat & SDMA_DESC_CMDSTAT_FR) {\r\npi->port.icount.frame++;\r\n} else if (cmdstat & SDMA_DESC_CMDSTAT_OR) {\r\npi->port.icount.overrun++;\r\n}\r\ncmdstat &= pi->port.read_status_mask;\r\nif (cmdstat & SDMA_DESC_CMDSTAT_BR)\r\nflag = TTY_BREAK;\r\nelse if (cmdstat & SDMA_DESC_CMDSTAT_FR)\r\nflag = TTY_FRAME;\r\nelse if (cmdstat & SDMA_DESC_CMDSTAT_OR)\r\nflag = TTY_OVERRUN;\r\nelse if (cmdstat & SDMA_DESC_CMDSTAT_PE)\r\nflag = TTY_PARITY;\r\n}\r\nif (uart_handle_sysrq_char(&pi->port, *bp)) {\r\nbp++;\r\nbytes_in--;\r\n#ifdef CONFIG_CONSOLE_POLL\r\nif (unlikely(serial_polled)) {\r\nserial_polled = 0;\r\nreturn 0;\r\n}\r\n#endif\r\ngoto next_frame;\r\n}\r\nif ((unlikely(cmdstat & (SDMA_DESC_CMDSTAT_BR\r\n| SDMA_DESC_CMDSTAT_FR\r\n| SDMA_DESC_CMDSTAT_OR)))\r\n&& !(cmdstat & pi->port.ignore_status_mask)) {\r\ntty_insert_flip_char(port, *bp, flag);\r\n} else {\r\nfor (i=0; i<bytes_in; i++)\r\ntty_insert_flip_char(port, *bp++, TTY_NORMAL);\r\npi->port.icount.rx += bytes_in;\r\n}\r\nnext_frame:\r\nrxre->bytecnt = cpu_to_be16(0);\r\nwmb();\r\nrxre->cmdstat = cpu_to_be32(SDMA_DESC_CMDSTAT_O\r\n| SDMA_DESC_CMDSTAT_EI | SDMA_DESC_CMDSTAT_F\r\n| SDMA_DESC_CMDSTAT_L);\r\nwmb();\r\ndma_cache_sync(pi->port.dev, (void *)rxre, MPSC_RXRE_SIZE,\r\nDMA_BIDIRECTIONAL);\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (pi->cache_mgmt)\r\nflush_dcache_range((ulong)rxre,\r\n(ulong)rxre + MPSC_RXRE_SIZE);\r\n#endif\r\npi->rxr_posn = (pi->rxr_posn + 1) & (MPSC_RXR_ENTRIES - 1);\r\nrxre = (struct mpsc_rx_desc *)\r\n(pi->rxr + (pi->rxr_posn * MPSC_RXRE_SIZE));\r\ndma_cache_sync(pi->port.dev, (void *)rxre, MPSC_RXRE_SIZE,\r\nDMA_FROM_DEVICE);\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (pi->cache_mgmt)\r\ninvalidate_dcache_range((ulong)rxre,\r\n(ulong)rxre + MPSC_RXRE_SIZE);\r\n#endif\r\nrc = 1;\r\n}\r\nif ((readl(pi->sdma_base + SDMA_SDCM) & SDMA_SDCM_ERD) == 0)\r\nmpsc_start_rx(pi);\r\nspin_unlock_irqrestore(&pi->port.lock, *flags);\r\ntty_flip_buffer_push(port);\r\nspin_lock_irqsave(&pi->port.lock, *flags);\r\nreturn rc;\r\n}\r\nstatic void mpsc_setup_tx_desc(struct mpsc_port_info *pi, u32 count, u32 intr)\r\n{\r\nstruct mpsc_tx_desc *txre;\r\ntxre = (struct mpsc_tx_desc *)(pi->txr\r\n+ (pi->txr_head * MPSC_TXRE_SIZE));\r\ntxre->bytecnt = cpu_to_be16(count);\r\ntxre->shadow = txre->bytecnt;\r\nwmb();\r\ntxre->cmdstat = cpu_to_be32(SDMA_DESC_CMDSTAT_O | SDMA_DESC_CMDSTAT_F\r\n| SDMA_DESC_CMDSTAT_L\r\n| ((intr) ? SDMA_DESC_CMDSTAT_EI : 0));\r\nwmb();\r\ndma_cache_sync(pi->port.dev, (void *)txre, MPSC_TXRE_SIZE,\r\nDMA_BIDIRECTIONAL);\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (pi->cache_mgmt)\r\nflush_dcache_range((ulong)txre,\r\n(ulong)txre + MPSC_TXRE_SIZE);\r\n#endif\r\n}\r\nstatic void mpsc_copy_tx_data(struct mpsc_port_info *pi)\r\n{\r\nstruct circ_buf *xmit = &pi->port.state->xmit;\r\nu8 *bp;\r\nu32 i;\r\nwhile (CIRC_CNT(pi->txr_head, pi->txr_tail, MPSC_TXR_ENTRIES)\r\n< (MPSC_TXR_ENTRIES - 1)) {\r\nif (pi->port.x_char) {\r\nbp = pi->txb + (pi->txr_head * MPSC_TXBE_SIZE);\r\n*bp = pi->port.x_char;\r\npi->port.x_char = 0;\r\ni = 1;\r\n} else if (!uart_circ_empty(xmit)\r\n&& !uart_tx_stopped(&pi->port)) {\r\ni = min((u32)MPSC_TXBE_SIZE,\r\n(u32)uart_circ_chars_pending(xmit));\r\ni = min(i, (u32)CIRC_CNT_TO_END(xmit->head, xmit->tail,\r\nUART_XMIT_SIZE));\r\nbp = pi->txb + (pi->txr_head * MPSC_TXBE_SIZE);\r\nmemcpy(bp, &xmit->buf[xmit->tail], i);\r\nxmit->tail = (xmit->tail + i) & (UART_XMIT_SIZE - 1);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&pi->port);\r\n} else {\r\nreturn;\r\n}\r\ndma_cache_sync(pi->port.dev, (void *)bp, MPSC_TXBE_SIZE,\r\nDMA_BIDIRECTIONAL);\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (pi->cache_mgmt)\r\nflush_dcache_range((ulong)bp,\r\n(ulong)bp + MPSC_TXBE_SIZE);\r\n#endif\r\nmpsc_setup_tx_desc(pi, i, 1);\r\npi->txr_head = (pi->txr_head + 1) & (MPSC_TXR_ENTRIES - 1);\r\n}\r\n}\r\nstatic int mpsc_tx_intr(struct mpsc_port_info *pi)\r\n{\r\nstruct mpsc_tx_desc *txre;\r\nint rc = 0;\r\nunsigned long iflags;\r\nspin_lock_irqsave(&pi->tx_lock, iflags);\r\nif (!mpsc_sdma_tx_active(pi)) {\r\ntxre = (struct mpsc_tx_desc *)(pi->txr\r\n+ (pi->txr_tail * MPSC_TXRE_SIZE));\r\ndma_cache_sync(pi->port.dev, (void *)txre, MPSC_TXRE_SIZE,\r\nDMA_FROM_DEVICE);\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (pi->cache_mgmt)\r\ninvalidate_dcache_range((ulong)txre,\r\n(ulong)txre + MPSC_TXRE_SIZE);\r\n#endif\r\nwhile (!(be32_to_cpu(txre->cmdstat) & SDMA_DESC_CMDSTAT_O)) {\r\nrc = 1;\r\npi->port.icount.tx += be16_to_cpu(txre->bytecnt);\r\npi->txr_tail = (pi->txr_tail+1) & (MPSC_TXR_ENTRIES-1);\r\nif (pi->txr_head == pi->txr_tail)\r\nbreak;\r\ntxre = (struct mpsc_tx_desc *)(pi->txr\r\n+ (pi->txr_tail * MPSC_TXRE_SIZE));\r\ndma_cache_sync(pi->port.dev, (void *)txre,\r\nMPSC_TXRE_SIZE, DMA_FROM_DEVICE);\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (pi->cache_mgmt)\r\ninvalidate_dcache_range((ulong)txre,\r\n(ulong)txre + MPSC_TXRE_SIZE);\r\n#endif\r\n}\r\nmpsc_copy_tx_data(pi);\r\nmpsc_sdma_start_tx(pi);\r\n}\r\nspin_unlock_irqrestore(&pi->tx_lock, iflags);\r\nreturn rc;\r\n}\r\nstatic irqreturn_t mpsc_sdma_intr(int irq, void *dev_id)\r\n{\r\nstruct mpsc_port_info *pi = dev_id;\r\nulong iflags;\r\nint rc = IRQ_NONE;\r\npr_debug("mpsc_sdma_intr[%d]: SDMA Interrupt Received\n",pi->port.line);\r\nspin_lock_irqsave(&pi->port.lock, iflags);\r\nmpsc_sdma_intr_ack(pi);\r\nif (mpsc_rx_intr(pi, &iflags))\r\nrc = IRQ_HANDLED;\r\nif (mpsc_tx_intr(pi))\r\nrc = IRQ_HANDLED;\r\nspin_unlock_irqrestore(&pi->port.lock, iflags);\r\npr_debug("mpsc_sdma_intr[%d]: SDMA Interrupt Handled\n", pi->port.line);\r\nreturn rc;\r\n}\r\nstatic uint mpsc_tx_empty(struct uart_port *port)\r\n{\r\nstruct mpsc_port_info *pi =\r\ncontainer_of(port, struct mpsc_port_info, port);\r\nulong iflags;\r\nuint rc;\r\nspin_lock_irqsave(&pi->port.lock, iflags);\r\nrc = mpsc_sdma_tx_active(pi) ? 0 : TIOCSER_TEMT;\r\nspin_unlock_irqrestore(&pi->port.lock, iflags);\r\nreturn rc;\r\n}\r\nstatic void mpsc_set_mctrl(struct uart_port *port, uint mctrl)\r\n{\r\n}\r\nstatic uint mpsc_get_mctrl(struct uart_port *port)\r\n{\r\nstruct mpsc_port_info *pi =\r\ncontainer_of(port, struct mpsc_port_info, port);\r\nu32 mflags, status;\r\nstatus = (pi->mirror_regs) ? pi->MPSC_CHR_10_m\r\n: readl(pi->mpsc_base + MPSC_CHR_10);\r\nmflags = 0;\r\nif (status & 0x1)\r\nmflags |= TIOCM_CTS;\r\nif (status & 0x2)\r\nmflags |= TIOCM_CAR;\r\nreturn mflags | TIOCM_DSR;\r\n}\r\nstatic void mpsc_stop_tx(struct uart_port *port)\r\n{\r\nstruct mpsc_port_info *pi =\r\ncontainer_of(port, struct mpsc_port_info, port);\r\npr_debug("mpsc_stop_tx[%d]\n", port->line);\r\nmpsc_freeze(pi);\r\n}\r\nstatic void mpsc_start_tx(struct uart_port *port)\r\n{\r\nstruct mpsc_port_info *pi =\r\ncontainer_of(port, struct mpsc_port_info, port);\r\nunsigned long iflags;\r\nspin_lock_irqsave(&pi->tx_lock, iflags);\r\nmpsc_unfreeze(pi);\r\nmpsc_copy_tx_data(pi);\r\nmpsc_sdma_start_tx(pi);\r\nspin_unlock_irqrestore(&pi->tx_lock, iflags);\r\npr_debug("mpsc_start_tx[%d]\n", port->line);\r\n}\r\nstatic void mpsc_start_rx(struct mpsc_port_info *pi)\r\n{\r\npr_debug("mpsc_start_rx[%d]: Starting...\n", pi->port.line);\r\nif (pi->rcv_data) {\r\nmpsc_enter_hunt(pi);\r\nmpsc_sdma_cmd(pi, SDMA_SDCM_ERD);\r\n}\r\n}\r\nstatic void mpsc_stop_rx(struct uart_port *port)\r\n{\r\nstruct mpsc_port_info *pi =\r\ncontainer_of(port, struct mpsc_port_info, port);\r\npr_debug("mpsc_stop_rx[%d]: Stopping...\n", port->line);\r\nif (pi->mirror_regs) {\r\nwritel(pi->MPSC_CHR_2_m | MPSC_CHR_2_RA,\r\npi->mpsc_base + MPSC_CHR_2);\r\nudelay(100);\r\n} else {\r\nwritel(readl(pi->mpsc_base + MPSC_CHR_2) | MPSC_CHR_2_RA,\r\npi->mpsc_base + MPSC_CHR_2);\r\nwhile (readl(pi->mpsc_base + MPSC_CHR_2) & MPSC_CHR_2_RA)\r\nudelay(10);\r\n}\r\nmpsc_sdma_cmd(pi, SDMA_SDCM_AR);\r\n}\r\nstatic void mpsc_break_ctl(struct uart_port *port, int ctl)\r\n{\r\nstruct mpsc_port_info *pi =\r\ncontainer_of(port, struct mpsc_port_info, port);\r\nulong flags;\r\nu32 v;\r\nv = ctl ? 0x00ff0000 : 0;\r\nspin_lock_irqsave(&pi->port.lock, flags);\r\nif (pi->mirror_regs)\r\npi->MPSC_CHR_1_m = v;\r\nwritel(v, pi->mpsc_base + MPSC_CHR_1);\r\nspin_unlock_irqrestore(&pi->port.lock, flags);\r\n}\r\nstatic int mpsc_startup(struct uart_port *port)\r\n{\r\nstruct mpsc_port_info *pi =\r\ncontainer_of(port, struct mpsc_port_info, port);\r\nu32 flag = 0;\r\nint rc;\r\npr_debug("mpsc_startup[%d]: Starting up MPSC, irq: %d\n",\r\nport->line, pi->port.irq);\r\nif ((rc = mpsc_make_ready(pi)) == 0) {\r\nmpsc_sdma_intr_ack(pi);\r\nif (mpsc_ports[0].port.irq == mpsc_ports[1].port.irq)\r\nflag = IRQF_SHARED;\r\nif (request_irq(pi->port.irq, mpsc_sdma_intr, flag,\r\n"mpsc-sdma", pi))\r\nprintk(KERN_ERR "MPSC: Can't get SDMA IRQ %d\n",\r\npi->port.irq);\r\nmpsc_sdma_intr_unmask(pi, 0xf);\r\nmpsc_sdma_set_rx_ring(pi, (struct mpsc_rx_desc *)(pi->rxr_p\r\n+ (pi->rxr_posn * MPSC_RXRE_SIZE)));\r\n}\r\nreturn rc;\r\n}\r\nstatic void mpsc_shutdown(struct uart_port *port)\r\n{\r\nstruct mpsc_port_info *pi =\r\ncontainer_of(port, struct mpsc_port_info, port);\r\npr_debug("mpsc_shutdown[%d]: Shutting down MPSC\n", port->line);\r\nmpsc_sdma_stop(pi);\r\nfree_irq(pi->port.irq, pi);\r\n}\r\nstatic void mpsc_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct mpsc_port_info *pi =\r\ncontainer_of(port, struct mpsc_port_info, port);\r\nu32 baud;\r\nulong flags;\r\nu32 chr_bits, stop_bits, par;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nchr_bits = MPSC_MPCR_CL_5;\r\nbreak;\r\ncase CS6:\r\nchr_bits = MPSC_MPCR_CL_6;\r\nbreak;\r\ncase CS7:\r\nchr_bits = MPSC_MPCR_CL_7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nchr_bits = MPSC_MPCR_CL_8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nstop_bits = MPSC_MPCR_SBL_2;\r\nelse\r\nstop_bits = MPSC_MPCR_SBL_1;\r\npar = MPSC_CHR_2_PAR_EVEN;\r\nif (termios->c_cflag & PARENB)\r\nif (termios->c_cflag & PARODD)\r\npar = MPSC_CHR_2_PAR_ODD;\r\n#ifdef CMSPAR\r\nif (termios->c_cflag & CMSPAR) {\r\nif (termios->c_cflag & PARODD)\r\npar = MPSC_CHR_2_PAR_MARK;\r\nelse\r\npar = MPSC_CHR_2_PAR_SPACE;\r\n}\r\n#endif\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk);\r\nspin_lock_irqsave(&pi->port.lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nmpsc_set_char_length(pi, chr_bits);\r\nmpsc_set_stop_bit_length(pi, stop_bits);\r\nmpsc_set_parity(pi, par);\r\nmpsc_set_baudrate(pi, baud);\r\npi->port.read_status_mask = SDMA_DESC_CMDSTAT_OR;\r\nif (termios->c_iflag & INPCK)\r\npi->port.read_status_mask |= SDMA_DESC_CMDSTAT_PE\r\n| SDMA_DESC_CMDSTAT_FR;\r\nif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\npi->port.read_status_mask |= SDMA_DESC_CMDSTAT_BR;\r\npi->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\npi->port.ignore_status_mask |= SDMA_DESC_CMDSTAT_PE\r\n| SDMA_DESC_CMDSTAT_FR;\r\nif (termios->c_iflag & IGNBRK) {\r\npi->port.ignore_status_mask |= SDMA_DESC_CMDSTAT_BR;\r\nif (termios->c_iflag & IGNPAR)\r\npi->port.ignore_status_mask |= SDMA_DESC_CMDSTAT_OR;\r\n}\r\nif ((termios->c_cflag & CREAD)) {\r\nif (!pi->rcv_data) {\r\npi->rcv_data = 1;\r\nmpsc_start_rx(pi);\r\n}\r\n} else if (pi->rcv_data) {\r\nmpsc_stop_rx(port);\r\npi->rcv_data = 0;\r\n}\r\nspin_unlock_irqrestore(&pi->port.lock, flags);\r\n}\r\nstatic const char *mpsc_type(struct uart_port *port)\r\n{\r\npr_debug("mpsc_type[%d]: port type: %s\n", port->line,MPSC_DRIVER_NAME);\r\nreturn MPSC_DRIVER_NAME;\r\n}\r\nstatic int mpsc_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void mpsc_release_port(struct uart_port *port)\r\n{\r\nstruct mpsc_port_info *pi =\r\ncontainer_of(port, struct mpsc_port_info, port);\r\nif (pi->ready) {\r\nmpsc_uninit_rings(pi);\r\nmpsc_free_ring_mem(pi);\r\npi->ready = 0;\r\n}\r\n}\r\nstatic void mpsc_config_port(struct uart_port *port, int flags)\r\n{\r\n}\r\nstatic int mpsc_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nstruct mpsc_port_info *pi =\r\ncontainer_of(port, struct mpsc_port_info, port);\r\nint rc = 0;\r\npr_debug("mpsc_verify_port[%d]: Verifying port data\n", pi->port.line);\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_MPSC)\r\nrc = -EINVAL;\r\nelse if (pi->port.irq != ser->irq)\r\nrc = -EINVAL;\r\nelse if (ser->io_type != SERIAL_IO_MEM)\r\nrc = -EINVAL;\r\nelse if (pi->port.uartclk / 16 != ser->baud_base)\r\nrc = -EINVAL;\r\nelse if ((void *)pi->port.mapbase != ser->iomem_base)\r\nrc = -EINVAL;\r\nelse if (pi->port.iobase != ser->port)\r\nrc = -EINVAL;\r\nelse if (ser->hub6 != 0)\r\nrc = -EINVAL;\r\nreturn rc;\r\n}\r\nstatic int mpsc_get_poll_char(struct uart_port *port)\r\n{\r\nstruct mpsc_port_info *pi =\r\ncontainer_of(port, struct mpsc_port_info, port);\r\nstruct mpsc_rx_desc *rxre;\r\nu32 cmdstat, bytes_in, i;\r\nu8 *bp;\r\nif (!serial_polled)\r\nserial_polled = 1;\r\npr_debug("mpsc_rx_intr[%d]: Handling Rx intr\n", pi->port.line);\r\nif (poll_cnt) {\r\npoll_cnt--;\r\nreturn poll_buf[poll_ptr++];\r\n}\r\npoll_ptr = 0;\r\npoll_cnt = 0;\r\nwhile (poll_cnt == 0) {\r\nrxre = (struct mpsc_rx_desc *)(pi->rxr +\r\n(pi->rxr_posn*MPSC_RXRE_SIZE));\r\ndma_cache_sync(pi->port.dev, (void *)rxre,\r\nMPSC_RXRE_SIZE, DMA_FROM_DEVICE);\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (pi->cache_mgmt)\r\ninvalidate_dcache_range((ulong)rxre,\r\n(ulong)rxre + MPSC_RXRE_SIZE);\r\n#endif\r\nwhile (poll_cnt == 0 &&\r\n!((cmdstat = be32_to_cpu(rxre->cmdstat)) &\r\nSDMA_DESC_CMDSTAT_O)){\r\nbytes_in = be16_to_cpu(rxre->bytecnt);\r\nbp = pi->rxb + (pi->rxr_posn * MPSC_RXBE_SIZE);\r\ndma_cache_sync(pi->port.dev, (void *) bp,\r\nMPSC_RXBE_SIZE, DMA_FROM_DEVICE);\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (pi->cache_mgmt)\r\ninvalidate_dcache_range((ulong)bp,\r\n(ulong)bp + MPSC_RXBE_SIZE);\r\n#endif\r\nif ((unlikely(cmdstat & (SDMA_DESC_CMDSTAT_BR |\r\nSDMA_DESC_CMDSTAT_FR | SDMA_DESC_CMDSTAT_OR))) &&\r\n!(cmdstat & pi->port.ignore_status_mask)) {\r\npoll_buf[poll_cnt] = *bp;\r\npoll_cnt++;\r\n} else {\r\nfor (i = 0; i < bytes_in; i++) {\r\npoll_buf[poll_cnt] = *bp++;\r\npoll_cnt++;\r\n}\r\npi->port.icount.rx += bytes_in;\r\n}\r\nrxre->bytecnt = cpu_to_be16(0);\r\nwmb();\r\nrxre->cmdstat = cpu_to_be32(SDMA_DESC_CMDSTAT_O |\r\nSDMA_DESC_CMDSTAT_EI |\r\nSDMA_DESC_CMDSTAT_F |\r\nSDMA_DESC_CMDSTAT_L);\r\nwmb();\r\ndma_cache_sync(pi->port.dev, (void *)rxre,\r\nMPSC_RXRE_SIZE, DMA_BIDIRECTIONAL);\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (pi->cache_mgmt)\r\nflush_dcache_range((ulong)rxre,\r\n(ulong)rxre + MPSC_RXRE_SIZE);\r\n#endif\r\npi->rxr_posn = (pi->rxr_posn + 1) &\r\n(MPSC_RXR_ENTRIES - 1);\r\nrxre = (struct mpsc_rx_desc *)(pi->rxr +\r\n(pi->rxr_posn * MPSC_RXRE_SIZE));\r\ndma_cache_sync(pi->port.dev, (void *)rxre,\r\nMPSC_RXRE_SIZE, DMA_FROM_DEVICE);\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (pi->cache_mgmt)\r\ninvalidate_dcache_range((ulong)rxre,\r\n(ulong)rxre + MPSC_RXRE_SIZE);\r\n#endif\r\n}\r\nif ((readl(pi->sdma_base + SDMA_SDCM) & SDMA_SDCM_ERD) == 0)\r\nmpsc_start_rx(pi);\r\n}\r\nif (poll_cnt) {\r\npoll_cnt--;\r\nreturn poll_buf[poll_ptr++];\r\n}\r\nreturn 0;\r\n}\r\nstatic void mpsc_put_poll_char(struct uart_port *port,\r\nunsigned char c)\r\n{\r\nstruct mpsc_port_info *pi =\r\ncontainer_of(port, struct mpsc_port_info, port);\r\nu32 data;\r\ndata = readl(pi->mpsc_base + MPSC_MPCR);\r\nwriteb(c, pi->mpsc_base + MPSC_CHR_1);\r\nmb();\r\ndata = readl(pi->mpsc_base + MPSC_CHR_2);\r\ndata |= MPSC_CHR_2_TTCS;\r\nwritel(data, pi->mpsc_base + MPSC_CHR_2);\r\nmb();\r\nwhile (readl(pi->mpsc_base + MPSC_CHR_2) & MPSC_CHR_2_TTCS);\r\n}\r\nstatic void mpsc_console_write(struct console *co, const char *s, uint count)\r\n{\r\nstruct mpsc_port_info *pi = &mpsc_ports[co->index];\r\nu8 *bp, *dp, add_cr = 0;\r\nint i;\r\nunsigned long iflags;\r\nspin_lock_irqsave(&pi->tx_lock, iflags);\r\nwhile (pi->txr_head != pi->txr_tail) {\r\nwhile (mpsc_sdma_tx_active(pi))\r\nudelay(100);\r\nmpsc_sdma_intr_ack(pi);\r\nmpsc_tx_intr(pi);\r\n}\r\nwhile (mpsc_sdma_tx_active(pi))\r\nudelay(100);\r\nwhile (count > 0) {\r\nbp = dp = pi->txb + (pi->txr_head * MPSC_TXBE_SIZE);\r\nfor (i = 0; i < MPSC_TXBE_SIZE; i++) {\r\nif (count == 0)\r\nbreak;\r\nif (add_cr) {\r\n*(dp++) = '\r';\r\nadd_cr = 0;\r\n} else {\r\n*(dp++) = *s;\r\nif (*(s++) == '\n') {\r\nadd_cr = 1;\r\ncount++;\r\n}\r\n}\r\ncount--;\r\n}\r\ndma_cache_sync(pi->port.dev, (void *)bp, MPSC_TXBE_SIZE,\r\nDMA_BIDIRECTIONAL);\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (pi->cache_mgmt)\r\nflush_dcache_range((ulong)bp,\r\n(ulong)bp + MPSC_TXBE_SIZE);\r\n#endif\r\nmpsc_setup_tx_desc(pi, i, 0);\r\npi->txr_head = (pi->txr_head + 1) & (MPSC_TXR_ENTRIES - 1);\r\nmpsc_sdma_start_tx(pi);\r\nwhile (mpsc_sdma_tx_active(pi))\r\nudelay(100);\r\npi->txr_tail = (pi->txr_tail + 1) & (MPSC_TXR_ENTRIES - 1);\r\n}\r\nspin_unlock_irqrestore(&pi->tx_lock, iflags);\r\n}\r\nstatic int __init mpsc_console_setup(struct console *co, char *options)\r\n{\r\nstruct mpsc_port_info *pi;\r\nint baud, bits, parity, flow;\r\npr_debug("mpsc_console_setup[%d]: options: %s\n", co->index, options);\r\nif (co->index >= MPSC_NUM_CTLRS)\r\nco->index = 0;\r\npi = &mpsc_ports[co->index];\r\nbaud = pi->default_baud;\r\nbits = pi->default_bits;\r\nparity = pi->default_parity;\r\nflow = pi->default_flow;\r\nif (!pi->port.ops)\r\nreturn -ENODEV;\r\nspin_lock_init(&pi->port.lock);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(&pi->port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init mpsc_late_console_init(void)\r\n{\r\npr_debug("mpsc_late_console_init: Enter\n");\r\nif (!(mpsc_console.flags & CON_ENABLED))\r\nregister_console(&mpsc_console);\r\nreturn 0;\r\n}\r\nstatic void mpsc_resource_err(char *s)\r\n{\r\nprintk(KERN_WARNING "MPSC: Platform device resource error in %s\n", s);\r\n}\r\nstatic int mpsc_shared_map_regs(struct platform_device *pd)\r\n{\r\nstruct resource *r;\r\nif ((r = platform_get_resource(pd, IORESOURCE_MEM,\r\nMPSC_ROUTING_BASE_ORDER))\r\n&& request_mem_region(r->start,\r\nMPSC_ROUTING_REG_BLOCK_SIZE,\r\n"mpsc_routing_regs")) {\r\nmpsc_shared_regs.mpsc_routing_base = ioremap(r->start,\r\nMPSC_ROUTING_REG_BLOCK_SIZE);\r\nmpsc_shared_regs.mpsc_routing_base_p = r->start;\r\n} else {\r\nmpsc_resource_err("MPSC routing base");\r\nreturn -ENOMEM;\r\n}\r\nif ((r = platform_get_resource(pd, IORESOURCE_MEM,\r\nMPSC_SDMA_INTR_BASE_ORDER))\r\n&& request_mem_region(r->start,\r\nMPSC_SDMA_INTR_REG_BLOCK_SIZE,\r\n"sdma_intr_regs")) {\r\nmpsc_shared_regs.sdma_intr_base = ioremap(r->start,\r\nMPSC_SDMA_INTR_REG_BLOCK_SIZE);\r\nmpsc_shared_regs.sdma_intr_base_p = r->start;\r\n} else {\r\niounmap(mpsc_shared_regs.mpsc_routing_base);\r\nrelease_mem_region(mpsc_shared_regs.mpsc_routing_base_p,\r\nMPSC_ROUTING_REG_BLOCK_SIZE);\r\nmpsc_resource_err("SDMA intr base");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mpsc_shared_unmap_regs(void)\r\n{\r\nif (mpsc_shared_regs.mpsc_routing_base) {\r\niounmap(mpsc_shared_regs.mpsc_routing_base);\r\nrelease_mem_region(mpsc_shared_regs.mpsc_routing_base_p,\r\nMPSC_ROUTING_REG_BLOCK_SIZE);\r\n}\r\nif (mpsc_shared_regs.sdma_intr_base) {\r\niounmap(mpsc_shared_regs.sdma_intr_base);\r\nrelease_mem_region(mpsc_shared_regs.sdma_intr_base_p,\r\nMPSC_SDMA_INTR_REG_BLOCK_SIZE);\r\n}\r\nmpsc_shared_regs.mpsc_routing_base = NULL;\r\nmpsc_shared_regs.sdma_intr_base = NULL;\r\nmpsc_shared_regs.mpsc_routing_base_p = 0;\r\nmpsc_shared_regs.sdma_intr_base_p = 0;\r\n}\r\nstatic int mpsc_shared_drv_probe(struct platform_device *dev)\r\n{\r\nstruct mpsc_shared_pdata *pdata;\r\nint rc;\r\nif (dev->id != 0)\r\nreturn -ENODEV;\r\nrc = mpsc_shared_map_regs(dev);\r\nif (rc)\r\nreturn rc;\r\npdata = dev_get_platdata(&dev->dev);\r\nmpsc_shared_regs.MPSC_MRR_m = pdata->mrr_val;\r\nmpsc_shared_regs.MPSC_RCRR_m= pdata->rcrr_val;\r\nmpsc_shared_regs.MPSC_TCRR_m= pdata->tcrr_val;\r\nmpsc_shared_regs.SDMA_INTR_CAUSE_m = pdata->intr_cause_val;\r\nmpsc_shared_regs.SDMA_INTR_MASK_m = pdata->intr_mask_val;\r\nreturn 0;\r\n}\r\nstatic int mpsc_shared_drv_remove(struct platform_device *dev)\r\n{\r\nif (dev->id != 0)\r\nreturn -ENODEV;\r\nmpsc_shared_unmap_regs();\r\nmpsc_shared_regs.MPSC_MRR_m = 0;\r\nmpsc_shared_regs.MPSC_RCRR_m = 0;\r\nmpsc_shared_regs.MPSC_TCRR_m = 0;\r\nmpsc_shared_regs.SDMA_INTR_CAUSE_m = 0;\r\nmpsc_shared_regs.SDMA_INTR_MASK_m = 0;\r\nreturn 0;\r\n}\r\nstatic int mpsc_drv_map_regs(struct mpsc_port_info *pi,\r\nstruct platform_device *pd)\r\n{\r\nstruct resource *r;\r\nif ((r = platform_get_resource(pd, IORESOURCE_MEM, MPSC_BASE_ORDER))\r\n&& request_mem_region(r->start, MPSC_REG_BLOCK_SIZE,\r\n"mpsc_regs")) {\r\npi->mpsc_base = ioremap(r->start, MPSC_REG_BLOCK_SIZE);\r\npi->mpsc_base_p = r->start;\r\n} else {\r\nmpsc_resource_err("MPSC base");\r\ngoto err;\r\n}\r\nif ((r = platform_get_resource(pd, IORESOURCE_MEM,\r\nMPSC_SDMA_BASE_ORDER))\r\n&& request_mem_region(r->start,\r\nMPSC_SDMA_REG_BLOCK_SIZE, "sdma_regs")) {\r\npi->sdma_base = ioremap(r->start,MPSC_SDMA_REG_BLOCK_SIZE);\r\npi->sdma_base_p = r->start;\r\n} else {\r\nmpsc_resource_err("SDMA base");\r\ngoto err;\r\n}\r\nif ((r = platform_get_resource(pd,IORESOURCE_MEM,MPSC_BRG_BASE_ORDER))\r\n&& request_mem_region(r->start,\r\nMPSC_BRG_REG_BLOCK_SIZE, "brg_regs")) {\r\npi->brg_base = ioremap(r->start, MPSC_BRG_REG_BLOCK_SIZE);\r\npi->brg_base_p = r->start;\r\n} else {\r\nmpsc_resource_err("BRG base");\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nif (pi->sdma_base) {\r\niounmap(pi->sdma_base);\r\npi->sdma_base = NULL;\r\n}\r\nif (pi->mpsc_base) {\r\niounmap(pi->mpsc_base);\r\npi->mpsc_base = NULL;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic void mpsc_drv_unmap_regs(struct mpsc_port_info *pi)\r\n{\r\nif (pi->mpsc_base) {\r\niounmap(pi->mpsc_base);\r\nrelease_mem_region(pi->mpsc_base_p, MPSC_REG_BLOCK_SIZE);\r\n}\r\nif (pi->sdma_base) {\r\niounmap(pi->sdma_base);\r\nrelease_mem_region(pi->sdma_base_p, MPSC_SDMA_REG_BLOCK_SIZE);\r\n}\r\nif (pi->brg_base) {\r\niounmap(pi->brg_base);\r\nrelease_mem_region(pi->brg_base_p, MPSC_BRG_REG_BLOCK_SIZE);\r\n}\r\npi->mpsc_base = NULL;\r\npi->sdma_base = NULL;\r\npi->brg_base = NULL;\r\npi->mpsc_base_p = 0;\r\npi->sdma_base_p = 0;\r\npi->brg_base_p = 0;\r\n}\r\nstatic void mpsc_drv_get_platform_data(struct mpsc_port_info *pi,\r\nstruct platform_device *pd, int num)\r\n{\r\nstruct mpsc_pdata *pdata;\r\npdata = dev_get_platdata(&pd->dev);\r\npi->port.uartclk = pdata->brg_clk_freq;\r\npi->port.iotype = UPIO_MEM;\r\npi->port.line = num;\r\npi->port.type = PORT_MPSC;\r\npi->port.fifosize = MPSC_TXBE_SIZE;\r\npi->port.membase = pi->mpsc_base;\r\npi->port.mapbase = (ulong)pi->mpsc_base;\r\npi->port.ops = &mpsc_pops;\r\npi->mirror_regs = pdata->mirror_regs;\r\npi->cache_mgmt = pdata->cache_mgmt;\r\npi->brg_can_tune = pdata->brg_can_tune;\r\npi->brg_clk_src = pdata->brg_clk_src;\r\npi->mpsc_max_idle = pdata->max_idle;\r\npi->default_baud = pdata->default_baud;\r\npi->default_bits = pdata->default_bits;\r\npi->default_parity = pdata->default_parity;\r\npi->default_flow = pdata->default_flow;\r\npi->MPSC_CHR_1_m = pdata->chr_1_val;\r\npi->MPSC_CHR_2_m = pdata->chr_2_val;\r\npi->MPSC_CHR_10_m = pdata->chr_10_val;\r\npi->MPSC_MPCR_m = pdata->mpcr_val;\r\npi->BRG_BCR_m = pdata->bcr_val;\r\npi->shared_regs = &mpsc_shared_regs;\r\npi->port.irq = platform_get_irq(pd, 0);\r\n}\r\nstatic int mpsc_drv_probe(struct platform_device *dev)\r\n{\r\nstruct mpsc_port_info *pi;\r\nint rc;\r\ndev_dbg(&dev->dev, "mpsc_drv_probe: Adding MPSC %d\n", dev->id);\r\nif (dev->id >= MPSC_NUM_CTLRS)\r\nreturn -ENODEV;\r\npi = &mpsc_ports[dev->id];\r\nrc = mpsc_drv_map_regs(pi, dev);\r\nif (rc)\r\nreturn rc;\r\nmpsc_drv_get_platform_data(pi, dev, dev->id);\r\npi->port.dev = &dev->dev;\r\nrc = mpsc_make_ready(pi);\r\nif (rc)\r\ngoto err_unmap;\r\nspin_lock_init(&pi->tx_lock);\r\nrc = uart_add_one_port(&mpsc_reg, &pi->port);\r\nif (rc)\r\ngoto err_relport;\r\nreturn 0;\r\nerr_relport:\r\nmpsc_release_port(&pi->port);\r\nerr_unmap:\r\nmpsc_drv_unmap_regs(pi);\r\nreturn rc;\r\n}\r\nstatic int __init mpsc_drv_init(void)\r\n{\r\nint rc;\r\nprintk(KERN_INFO "Serial: MPSC driver\n");\r\nmemset(mpsc_ports, 0, sizeof(mpsc_ports));\r\nmemset(&mpsc_shared_regs, 0, sizeof(mpsc_shared_regs));\r\nrc = uart_register_driver(&mpsc_reg);\r\nif (rc)\r\nreturn rc;\r\nrc = platform_driver_register(&mpsc_shared_driver);\r\nif (rc)\r\ngoto err_unreg_uart;\r\nrc = platform_driver_register(&mpsc_driver);\r\nif (rc)\r\ngoto err_unreg_plat;\r\nreturn 0;\r\nerr_unreg_plat:\r\nplatform_driver_unregister(&mpsc_shared_driver);\r\nerr_unreg_uart:\r\nuart_unregister_driver(&mpsc_reg);\r\nreturn rc;\r\n}
