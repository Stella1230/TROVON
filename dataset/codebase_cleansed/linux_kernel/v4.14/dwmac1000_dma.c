static void dwmac1000_dma_axi(void __iomem *ioaddr, struct stmmac_axi *axi)\r\n{\r\nu32 value = readl(ioaddr + DMA_AXI_BUS_MODE);\r\nint i;\r\npr_info("dwmac1000: Master AXI performs %s burst length\n",\r\n!(value & DMA_AXI_UNDEF) ? "fixed" : "any");\r\nif (axi->axi_lpi_en)\r\nvalue |= DMA_AXI_EN_LPI;\r\nif (axi->axi_xit_frm)\r\nvalue |= DMA_AXI_LPI_XIT_FRM;\r\nvalue &= ~DMA_AXI_WR_OSR_LMT;\r\nvalue |= (axi->axi_wr_osr_lmt & DMA_AXI_WR_OSR_LMT_MASK) <<\r\nDMA_AXI_WR_OSR_LMT_SHIFT;\r\nvalue &= ~DMA_AXI_RD_OSR_LMT;\r\nvalue |= (axi->axi_rd_osr_lmt & DMA_AXI_RD_OSR_LMT_MASK) <<\r\nDMA_AXI_RD_OSR_LMT_SHIFT;\r\nfor (i = 0; i < AXI_BLEN; i++) {\r\nswitch (axi->axi_blen[i]) {\r\ncase 256:\r\nvalue |= DMA_AXI_BLEN256;\r\nbreak;\r\ncase 128:\r\nvalue |= DMA_AXI_BLEN128;\r\nbreak;\r\ncase 64:\r\nvalue |= DMA_AXI_BLEN64;\r\nbreak;\r\ncase 32:\r\nvalue |= DMA_AXI_BLEN32;\r\nbreak;\r\ncase 16:\r\nvalue |= DMA_AXI_BLEN16;\r\nbreak;\r\ncase 8:\r\nvalue |= DMA_AXI_BLEN8;\r\nbreak;\r\ncase 4:\r\nvalue |= DMA_AXI_BLEN4;\r\nbreak;\r\n}\r\n}\r\nwritel(value, ioaddr + DMA_AXI_BUS_MODE);\r\n}\r\nstatic void dwmac1000_dma_init(void __iomem *ioaddr,\r\nstruct stmmac_dma_cfg *dma_cfg,\r\nu32 dma_tx, u32 dma_rx, int atds)\r\n{\r\nu32 value = readl(ioaddr + DMA_BUS_MODE);\r\nint txpbl = dma_cfg->txpbl ?: dma_cfg->pbl;\r\nint rxpbl = dma_cfg->rxpbl ?: dma_cfg->pbl;\r\nif (dma_cfg->pblx8)\r\nvalue |= DMA_BUS_MODE_MAXPBL;\r\nvalue |= DMA_BUS_MODE_USP;\r\nvalue &= ~(DMA_BUS_MODE_PBL_MASK | DMA_BUS_MODE_RPBL_MASK);\r\nvalue |= (txpbl << DMA_BUS_MODE_PBL_SHIFT);\r\nvalue |= (rxpbl << DMA_BUS_MODE_RPBL_SHIFT);\r\nif (dma_cfg->fixed_burst)\r\nvalue |= DMA_BUS_MODE_FB;\r\nif (dma_cfg->mixed_burst)\r\nvalue |= DMA_BUS_MODE_MB;\r\nif (atds)\r\nvalue |= DMA_BUS_MODE_ATDS;\r\nif (dma_cfg->aal)\r\nvalue |= DMA_BUS_MODE_AAL;\r\nwritel(value, ioaddr + DMA_BUS_MODE);\r\nwritel(DMA_INTR_DEFAULT_MASK, ioaddr + DMA_INTR_ENA);\r\nwritel(dma_tx, ioaddr + DMA_TX_BASE_ADDR);\r\nwritel(dma_rx, ioaddr + DMA_RCV_BASE_ADDR);\r\n}\r\nstatic u32 dwmac1000_configure_fc(u32 csr6, int rxfifosz)\r\n{\r\ncsr6 &= ~DMA_CONTROL_RFA_MASK;\r\ncsr6 &= ~DMA_CONTROL_RFD_MASK;\r\nif (rxfifosz < 4096) {\r\ncsr6 &= ~DMA_CONTROL_EFC;\r\npr_debug("GMAC: disabling flow control, rxfifo too small(%d)\n",\r\nrxfifosz);\r\n} else {\r\ncsr6 |= DMA_CONTROL_EFC;\r\ncsr6 |= RFA_FULL_MINUS_1K;\r\ncsr6 |= RFD_FULL_MINUS_2K;\r\n}\r\nreturn csr6;\r\n}\r\nstatic void dwmac1000_dma_operation_mode(void __iomem *ioaddr, int txmode,\r\nint rxmode, int rxfifosz)\r\n{\r\nu32 csr6 = readl(ioaddr + DMA_CONTROL);\r\nif (txmode == SF_DMA_MODE) {\r\npr_debug("GMAC: enable TX store and forward mode\n");\r\ncsr6 |= DMA_CONTROL_TSF;\r\ncsr6 |= DMA_CONTROL_OSF;\r\n} else {\r\npr_debug("GMAC: disabling TX SF (threshold %d)\n", txmode);\r\ncsr6 &= ~DMA_CONTROL_TSF;\r\ncsr6 &= DMA_CONTROL_TC_TX_MASK;\r\nif (txmode <= 32)\r\ncsr6 |= DMA_CONTROL_TTC_32;\r\nelse if (txmode <= 64)\r\ncsr6 |= DMA_CONTROL_TTC_64;\r\nelse if (txmode <= 128)\r\ncsr6 |= DMA_CONTROL_TTC_128;\r\nelse if (txmode <= 192)\r\ncsr6 |= DMA_CONTROL_TTC_192;\r\nelse\r\ncsr6 |= DMA_CONTROL_TTC_256;\r\n}\r\nif (rxmode == SF_DMA_MODE) {\r\npr_debug("GMAC: enable RX store and forward mode\n");\r\ncsr6 |= DMA_CONTROL_RSF;\r\n} else {\r\npr_debug("GMAC: disable RX SF mode (threshold %d)\n", rxmode);\r\ncsr6 &= ~DMA_CONTROL_RSF;\r\ncsr6 &= DMA_CONTROL_TC_RX_MASK;\r\nif (rxmode <= 32)\r\ncsr6 |= DMA_CONTROL_RTC_32;\r\nelse if (rxmode <= 64)\r\ncsr6 |= DMA_CONTROL_RTC_64;\r\nelse if (rxmode <= 96)\r\ncsr6 |= DMA_CONTROL_RTC_96;\r\nelse\r\ncsr6 |= DMA_CONTROL_RTC_128;\r\n}\r\ncsr6 = dwmac1000_configure_fc(csr6, rxfifosz);\r\nwritel(csr6, ioaddr + DMA_CONTROL);\r\n}\r\nstatic void dwmac1000_dump_dma_regs(void __iomem *ioaddr, u32 *reg_space)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_DWMAC1000_DMA_REGS; i++)\r\nif ((i < 12) || (i > 17))\r\nreg_space[DMA_BUS_MODE / 4 + i] =\r\nreadl(ioaddr + DMA_BUS_MODE + i * 4);\r\n}\r\nstatic void dwmac1000_get_hw_feature(void __iomem *ioaddr,\r\nstruct dma_features *dma_cap)\r\n{\r\nu32 hw_cap = readl(ioaddr + DMA_HW_FEATURE);\r\ndma_cap->mbps_10_100 = (hw_cap & DMA_HW_FEAT_MIISEL);\r\ndma_cap->mbps_1000 = (hw_cap & DMA_HW_FEAT_GMIISEL) >> 1;\r\ndma_cap->half_duplex = (hw_cap & DMA_HW_FEAT_HDSEL) >> 2;\r\ndma_cap->hash_filter = (hw_cap & DMA_HW_FEAT_HASHSEL) >> 4;\r\ndma_cap->multi_addr = (hw_cap & DMA_HW_FEAT_ADDMAC) >> 5;\r\ndma_cap->pcs = (hw_cap & DMA_HW_FEAT_PCSSEL) >> 6;\r\ndma_cap->sma_mdio = (hw_cap & DMA_HW_FEAT_SMASEL) >> 8;\r\ndma_cap->pmt_remote_wake_up = (hw_cap & DMA_HW_FEAT_RWKSEL) >> 9;\r\ndma_cap->pmt_magic_frame = (hw_cap & DMA_HW_FEAT_MGKSEL) >> 10;\r\ndma_cap->rmon = (hw_cap & DMA_HW_FEAT_MMCSEL) >> 11;\r\ndma_cap->time_stamp =\r\n(hw_cap & DMA_HW_FEAT_TSVER1SEL) >> 12;\r\ndma_cap->atime_stamp = (hw_cap & DMA_HW_FEAT_TSVER2SEL) >> 13;\r\ndma_cap->eee = (hw_cap & DMA_HW_FEAT_EEESEL) >> 14;\r\ndma_cap->av = (hw_cap & DMA_HW_FEAT_AVSEL) >> 15;\r\ndma_cap->tx_coe = (hw_cap & DMA_HW_FEAT_TXCOESEL) >> 16;\r\ndma_cap->rx_coe_type1 = (hw_cap & DMA_HW_FEAT_RXTYP1COE) >> 17;\r\ndma_cap->rx_coe_type2 = (hw_cap & DMA_HW_FEAT_RXTYP2COE) >> 18;\r\ndma_cap->rxfifo_over_2048 = (hw_cap & DMA_HW_FEAT_RXFIFOSIZE) >> 19;\r\ndma_cap->number_rx_channel = (hw_cap & DMA_HW_FEAT_RXCHCNT) >> 20;\r\ndma_cap->number_tx_channel = (hw_cap & DMA_HW_FEAT_TXCHCNT) >> 22;\r\ndma_cap->enh_desc = (hw_cap & DMA_HW_FEAT_ENHDESSEL) >> 24;\r\n}\r\nstatic void dwmac1000_rx_watchdog(void __iomem *ioaddr, u32 riwt,\r\nu32 number_chan)\r\n{\r\nwritel(riwt, ioaddr + DMA_RX_WATCHDOG);\r\n}
