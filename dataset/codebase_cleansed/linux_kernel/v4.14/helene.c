static void helene_i2c_debug(struct helene_priv *priv,\r\nu8 reg, u8 write, const u8 *data, u32 len)\r\n{\r\ndev_dbg(&priv->i2c->dev, "helene: I2C %s reg 0x%02x size %d\n",\r\n(write == 0 ? "read" : "write"), reg, len);\r\nprint_hex_dump_bytes("helene: I2C data: ",\r\nDUMP_PREFIX_OFFSET, data, len);\r\n}\r\nstatic int helene_write_regs(struct helene_priv *priv,\r\nu8 reg, const u8 *data, u32 len)\r\n{\r\nint ret;\r\nu8 buf[MAX_WRITE_REGSIZE + 1];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->i2c_address,\r\n.flags = 0,\r\n.len = len + 1,\r\n.buf = buf,\r\n}\r\n};\r\nif (len + 1 > sizeof(buf)) {\r\ndev_warn(&priv->i2c->dev,\r\n"wr reg=%04x: len=%d vs %zu is too big!\n",\r\nreg, len + 1, sizeof(buf));\r\nreturn -E2BIG;\r\n}\r\nhelene_i2c_debug(priv, reg, 1, data, len);\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], data, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EREMOTEIO;\r\nif (ret < 0) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c wr failed=%d reg=%02x len=%d\n",\r\nKBUILD_MODNAME, ret, reg, len);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int helene_write_reg(struct helene_priv *priv, u8 reg, u8 val)\r\n{\r\nreturn helene_write_regs(priv, reg, &val, 1);\r\n}\r\nstatic int helene_read_regs(struct helene_priv *priv,\r\nu8 reg, u8 *val, u32 len)\r\n{\r\nint ret;\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = priv->i2c_address,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = priv->i2c_address,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = val,\r\n}\r\n};\r\nret = i2c_transfer(priv->i2c, &msg[0], 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EREMOTEIO;\r\nif (ret < 0) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: I2C rw failed=%d addr=%02x reg=%02x\n",\r\nKBUILD_MODNAME, ret, priv->i2c_address, reg);\r\nreturn ret;\r\n}\r\nret = i2c_transfer(priv->i2c, &msg[1], 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EREMOTEIO;\r\nif (ret < 0) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c rd failed=%d addr=%02x reg=%02x\n",\r\nKBUILD_MODNAME, ret, priv->i2c_address, reg);\r\nreturn ret;\r\n}\r\nhelene_i2c_debug(priv, reg, 0, val, len);\r\nreturn 0;\r\n}\r\nstatic int helene_read_reg(struct helene_priv *priv, u8 reg, u8 *val)\r\n{\r\nreturn helene_read_regs(priv, reg, val, 1);\r\n}\r\nstatic int helene_set_reg_bits(struct helene_priv *priv,\r\nu8 reg, u8 data, u8 mask)\r\n{\r\nint res;\r\nu8 rdata;\r\nif (mask != 0xff) {\r\nres = helene_read_reg(priv, reg, &rdata);\r\nif (res != 0)\r\nreturn res;\r\ndata = ((data & mask) | (rdata & (mask ^ 0xFF)));\r\n}\r\nreturn helene_write_reg(priv, reg, data);\r\n}\r\nstatic int helene_enter_power_save(struct helene_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state == STATE_SLEEP)\r\nreturn 0;\r\nhelene_write_reg(priv, 0x88, 0x0);\r\nhelene_write_reg(priv, 0x87, 0xC0);\r\npriv->state = STATE_SLEEP;\r\nreturn 0;\r\n}\r\nstatic int helene_leave_power_save(struct helene_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state == STATE_ACTIVE)\r\nreturn 0;\r\nhelene_write_reg(priv, 0x87, 0xC4);\r\nhelene_write_reg(priv, 0x88, 0x40);\r\npriv->state = STATE_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic int helene_init(struct dvb_frontend *fe)\r\n{\r\nstruct helene_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nreturn helene_leave_power_save(priv);\r\n}\r\nstatic void helene_release(struct dvb_frontend *fe)\r\n{\r\nstruct helene_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\n}\r\nstatic int helene_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct helene_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nhelene_enter_power_save(priv);\r\nreturn 0;\r\n}\r\nstatic enum helene_tv_system_t helene_get_tv_system(struct dvb_frontend *fe)\r\n{\r\nenum helene_tv_system_t system = SONY_HELENE_TV_SYSTEM_UNKNOWN;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct helene_priv *priv = fe->tuner_priv;\r\nif (p->delivery_system == SYS_DVBT) {\r\nif (p->bandwidth_hz <= 5000000)\r\nsystem = SONY_HELENE_DTV_DVBT_5;\r\nelse if (p->bandwidth_hz <= 6000000)\r\nsystem = SONY_HELENE_DTV_DVBT_6;\r\nelse if (p->bandwidth_hz <= 7000000)\r\nsystem = SONY_HELENE_DTV_DVBT_7;\r\nelse if (p->bandwidth_hz <= 8000000)\r\nsystem = SONY_HELENE_DTV_DVBT_8;\r\nelse {\r\nsystem = SONY_HELENE_DTV_DVBT_8;\r\np->bandwidth_hz = 8000000;\r\n}\r\n} else if (p->delivery_system == SYS_DVBT2) {\r\nif (p->bandwidth_hz <= 5000000)\r\nsystem = SONY_HELENE_DTV_DVBT2_5;\r\nelse if (p->bandwidth_hz <= 6000000)\r\nsystem = SONY_HELENE_DTV_DVBT2_6;\r\nelse if (p->bandwidth_hz <= 7000000)\r\nsystem = SONY_HELENE_DTV_DVBT2_7;\r\nelse if (p->bandwidth_hz <= 8000000)\r\nsystem = SONY_HELENE_DTV_DVBT2_8;\r\nelse {\r\nsystem = SONY_HELENE_DTV_DVBT2_8;\r\np->bandwidth_hz = 8000000;\r\n}\r\n} else if (p->delivery_system == SYS_DVBS) {\r\nsystem = SONY_HELENE_STV_DVBS;\r\n} else if (p->delivery_system == SYS_DVBS2) {\r\nsystem = SONY_HELENE_STV_DVBS2;\r\n} else if (p->delivery_system == SYS_ISDBS) {\r\nsystem = SONY_HELENE_STV_ISDBS;\r\n} else if (p->delivery_system == SYS_ISDBT) {\r\nif (p->bandwidth_hz <= 6000000)\r\nsystem = SONY_HELENE_DTV_ISDBT_6;\r\nelse if (p->bandwidth_hz <= 7000000)\r\nsystem = SONY_HELENE_DTV_ISDBT_7;\r\nelse if (p->bandwidth_hz <= 8000000)\r\nsystem = SONY_HELENE_DTV_ISDBT_8;\r\nelse {\r\nsystem = SONY_HELENE_DTV_ISDBT_8;\r\np->bandwidth_hz = 8000000;\r\n}\r\n} else if (p->delivery_system == SYS_DVBC_ANNEX_A) {\r\nif (p->bandwidth_hz <= 6000000)\r\nsystem = SONY_HELENE_DTV_DVBC_6;\r\nelse if (p->bandwidth_hz <= 8000000)\r\nsystem = SONY_HELENE_DTV_DVBC_8;\r\n}\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): HELENE DTV system %d (delsys %d, bandwidth %d)\n",\r\n__func__, (int)system, p->delivery_system,\r\np->bandwidth_hz);\r\nreturn system;\r\n}\r\nstatic int helene_set_params_s(struct dvb_frontend *fe)\r\n{\r\nu8 data[MAX_WRITE_REGSIZE];\r\nu32 frequency;\r\nenum helene_tv_system_t tv_system;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct helene_priv *priv = fe->tuner_priv;\r\nint frequencykHz = p->frequency;\r\nuint32_t frequency4kHz = 0;\r\nu32 symbol_rate = p->symbol_rate/1000;\r\ndev_dbg(&priv->i2c->dev, "%s(): tune frequency %dkHz sr=%uKsps\n",\r\n__func__, frequencykHz, symbol_rate);\r\ntv_system = helene_get_tv_system(fe);\r\nif (tv_system == SONY_HELENE_TV_SYSTEM_UNKNOWN) {\r\ndev_err(&priv->i2c->dev, "%s(): unknown DTV system\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (priv->set_tuner)\r\npriv->set_tuner(priv->set_tuner_data, 0);\r\nfrequency = roundup(p->frequency / 1000, 1);\r\nhelene_write_reg(priv, 0x15, 0x02);\r\nhelene_write_reg(priv, 0x43, 0x06);\r\ndata[0] = 0x00;\r\ndata[1] = 0x00;\r\nhelene_write_regs(priv, 0x6A, data, 2);\r\nhelene_write_reg(priv, 0x75, 0x99);\r\nhelene_write_reg(priv, 0x9D, 0x00);\r\nhelene_write_reg(priv, 0x61, 0x07);\r\nhelene_write_reg(priv, 0x01, 0x01);\r\ndata[0] = 0xC4;\r\ndata[1] = 0x40;\r\nswitch (priv->xtal) {\r\ncase SONY_HELENE_XTAL_16000:\r\ndata[2] = 0x02;\r\nbreak;\r\ncase SONY_HELENE_XTAL_20500:\r\ndata[2] = 0x02;\r\nbreak;\r\ncase SONY_HELENE_XTAL_24000:\r\ndata[2] = 0x03;\r\nbreak;\r\ncase SONY_HELENE_XTAL_41000:\r\ndata[2] = 0x05;\r\nbreak;\r\ndefault:\r\ndev_err(&priv->i2c->dev, "%s(): unknown xtal %d\n",\r\n__func__, priv->xtal);\r\nreturn -EINVAL;\r\n}\r\ndata[3] = 0x80;\r\nif (priv->xtal == SONY_HELENE_XTAL_20500)\r\ndata[4] = 0x58;\r\nelse\r\ndata[4] = 0x70;\r\ndata[5] = 0x1E;\r\ndata[6] = 0x02;\r\ndata[7] = 0x24;\r\ndata[8] = 0x0F;\r\ndata[8] |= 0xE0;\r\ndata[9] = 0x02;\r\ndata[10] = 0x1E;\r\nswitch (tv_system) {\r\ncase SONY_HELENE_STV_ISDBS:\r\ndata[11] = 0x22;\r\nbreak;\r\ncase SONY_HELENE_STV_DVBS:\r\nif (symbol_rate <= 4000)\r\ndata[11] = 0x05;\r\nelse if (symbol_rate <= 10000)\r\ndata[11] = (uint8_t)((symbol_rate * 47\r\n+ (40000-1)) / 40000);\r\nelse\r\ndata[11] = (uint8_t)((symbol_rate * 27\r\n+ (40000-1)) / 40000 + 5);\r\nif (data[11] > 36)\r\ndata[11] = 36;\r\nbreak;\r\ncase SONY_HELENE_STV_DVBS2:\r\nif (symbol_rate <= 4000)\r\ndata[11] = 0x05;\r\nelse if (symbol_rate <= 10000)\r\ndata[11] = (uint8_t)((symbol_rate * 11\r\n+ (10000-1)) / 10000);\r\nelse\r\ndata[11] = (uint8_t)((symbol_rate * 3\r\n+ (5000-1)) / 5000 + 5);\r\nif (data[11] > 36)\r\ndata[11] = 36;\r\nbreak;\r\ndefault:\r\ndev_err(&priv->i2c->dev, "%s(): unknown standard %d\n",\r\n__func__, tv_system);\r\nreturn -EINVAL;\r\n}\r\nfrequency4kHz = (frequencykHz + 2) / 4;\r\ndata[12] = (uint8_t)(frequency4kHz & 0xFF);\r\ndata[13] = (uint8_t)((frequency4kHz >> 8) & 0xFF);\r\ndata[14] = (uint8_t)((frequency4kHz >> 16) & 0x0F);\r\ndata[15] = 0xFF;\r\ndata[16] = 0x00;\r\ndata[17] = 0x01;\r\nhelene_write_regs(priv, 0x04, data, 18);\r\ndev_dbg(&priv->i2c->dev, "%s(): tune done\n",\r\n__func__);\r\npriv->frequency = frequency;\r\nreturn 0;\r\n}\r\nstatic int helene_set_params(struct dvb_frontend *fe)\r\n{\r\nu8 data[MAX_WRITE_REGSIZE];\r\nu32 frequency;\r\nenum helene_tv_system_t tv_system;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct helene_priv *priv = fe->tuner_priv;\r\nint frequencykHz = p->frequency / 1000;\r\ndev_dbg(&priv->i2c->dev, "%s(): tune frequency %dkHz\n",\r\n__func__, frequencykHz);\r\ntv_system = helene_get_tv_system(fe);\r\nif (tv_system == SONY_HELENE_TV_SYSTEM_UNKNOWN) {\r\ndev_dbg(&priv->i2c->dev, "%s(): unknown DTV system\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (priv->set_tuner)\r\npriv->set_tuner(priv->set_tuner_data, 1);\r\nfrequency = roundup(p->frequency / 1000, 25);\r\nhelene_write_reg(priv, 0x01, 0x00);\r\nhelene_write_reg(priv, 0x74, 0x02);\r\nif (priv->state == STATE_SLEEP)\r\nhelene_leave_power_save(priv);\r\nif ((tv_system == SONY_HELENE_DTV_DVBC_6) ||\r\n(tv_system == SONY_HELENE_DTV_DVBC_8)) {\r\ndata[0] = 0x16;\r\ndata[1] = 0x26;\r\n} else {\r\ndata[0] = 0x10;\r\ndata[1] = 0x20;\r\n}\r\nhelene_write_regs(priv, 0x91, data, 2);\r\nif (TERR_INTERNAL_LOOPFILTER_AVAILABLE(tv_system))\r\ndata[0] = 0x90;\r\nelse\r\ndata[0] = 0x00;\r\ndata[1] = (uint8_t)(terr_params[tv_system].IS_LOWERLOCAL & 0x01);\r\nhelene_write_regs(priv, 0x9C, data, 2);\r\ndata[0] = 0xEE;\r\ndata[1] = 0x02;\r\ndata[2] = 0x1E;\r\ndata[3] = 0x67;\r\nif ((tv_system == SONY_HELENE_DTV_DVBC_6) ||\r\n(tv_system == SONY_HELENE_DTV_DVBC_8))\r\ndata[4] = 0x18;\r\nelse\r\ndata[4] = 0x03;\r\nif (TERR_INTERNAL_LOOPFILTER_AVAILABLE(tv_system)) {\r\ndata[5] = 0x38;\r\ndata[6] = 0x1E;\r\ndata[7] = 0x02;\r\ndata[8] = 0x24;\r\n} else if ((tv_system == SONY_HELENE_DTV_DVBC_6) ||\r\n(tv_system == SONY_HELENE_DTV_DVBC_8)) {\r\ndata[5] = 0x1C;\r\ndata[6] = 0x78;\r\ndata[7] = 0x08;\r\ndata[8] = 0x1C;\r\n} else {\r\ndata[5] = 0xB4;\r\ndata[6] = 0x78;\r\ndata[7] = 0x08;\r\ndata[8] = 0x30;\r\n}\r\nhelene_write_regs(priv, 0x5E, data, 9);\r\nhelene_set_reg_bits(priv, 0x67, 0x0, 0x02);\r\ndata[0] = 0x00;\r\nif (terr_params[tv_system].RF_GAIN == HELENE_AUTO)\r\ndata[1] = 0x80;\r\nelse\r\ndata[1] = (uint8_t)((terr_params[tv_system].RF_GAIN\r\n<< 4) & 0x70);\r\ndata[1] |= (uint8_t)(terr_params[tv_system].IF_BPF_GC & 0x0F);\r\ndata[2] = 0x00;\r\nif (frequencykHz <= 172000) {\r\ndata[3] = (uint8_t)(terr_params[tv_system].RFOVLD_DET_LV1_VL\r\n& 0x0F);\r\ndata[4] = (uint8_t)(terr_params[tv_system].IFOVLD_DET_LV_VL\r\n& 0x07);\r\n} else if (frequencykHz <= 464000) {\r\ndata[3] = (uint8_t)(terr_params[tv_system].RFOVLD_DET_LV1_VH\r\n& 0x0F);\r\ndata[4] = (uint8_t)(terr_params[tv_system].IFOVLD_DET_LV_VH\r\n& 0x07);\r\n} else {\r\ndata[3] = (uint8_t)(terr_params[tv_system].RFOVLD_DET_LV1_U\r\n& 0x0F);\r\ndata[4] = (uint8_t)(terr_params[tv_system].IFOVLD_DET_LV_U\r\n& 0x07);\r\n}\r\ndata[4] |= 0x20;\r\ndata[5] = (uint8_t)((terr_params[tv_system].IF_BPF_F0 << 4) & 0x30);\r\ndata[5] |= (uint8_t)(terr_params[tv_system].BW & 0x03);\r\ndata[6] = (uint8_t)(terr_params[tv_system].FIF_OFFSET & 0x1F);\r\ndata[7] = (uint8_t)(terr_params[tv_system].BW_OFFSET & 0x1F);\r\ndata[8] = (uint8_t)(frequencykHz & 0xFF);\r\ndata[9] = (uint8_t)((frequencykHz >> 8) & 0xFF);\r\ndata[10] = (uint8_t)((frequencykHz >> 16)\r\n& 0x0F);\r\ndata[11] = 0xFF;\r\ndata[12] = 0x01;\r\nif ((tv_system == SONY_HELENE_DTV_DVBC_6) ||\r\n(tv_system == SONY_HELENE_DTV_DVBC_8)) {\r\ndata[13] = 0xD9;\r\ndata[14] = 0x0F;\r\ndata[15] = 0x24;\r\ndata[16] = 0x87;\r\n} else {\r\ndata[13] = 0x99;\r\ndata[14] = 0x00;\r\ndata[15] = 0x24;\r\ndata[16] = 0x87;\r\n}\r\nhelene_write_regs(priv, 0x68, data, 17);\r\ndev_dbg(&priv->i2c->dev, "%s(): tune done\n",\r\n__func__);\r\npriv->frequency = frequency;\r\nreturn 0;\r\n}\r\nstatic int helene_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct helene_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency * 1000;\r\nreturn 0;\r\n}\r\nstatic int helene_x_pon(struct helene_priv *priv)\r\n{\r\nu8 dataT[] = { 0x06, 0x00, 0x02, 0x00 };\r\nu8 dataS[] = { 0x05, 0x06 };\r\nu8 cdata[] = {0x7A, 0x01};\r\nu8 data[20];\r\nu8 rdata[2];\r\nhelene_write_reg(priv, 0x01, 0x00);\r\nhelene_write_reg(priv, 0x67, dataT[3]);\r\nhelene_write_reg(priv, 0x43, dataS[1]);\r\nhelene_write_regs(priv, 0x5E, dataT, 3);\r\nhelene_write_reg(priv, 0x0C, dataS[0]);\r\nhelene_write_regs(priv, 0x99, cdata, sizeof(cdata));\r\ndata[0] = 0x18;\r\ndata[1] = (uint8_t)(0x80 | (0x04 & 0x1F));\r\ndata[2] = (uint8_t)(0x80 | (0x26 & 0x7F));\r\ndata[3] = 0x80;\r\ndata[4] = 0x00;\r\ndata[5] = 0x00;\r\ndata[6] = 0xC4;\r\ndata[7] = 0x40;\r\ndata[8] = 0x10;\r\ndata[9] = 0x00;\r\ndata[10] = 0x45;\r\ndata[11] = 0x75;\r\ndata[12] = 0x07;\r\ndata[13] = 0x1C;\r\ndata[14] = 0x3F;\r\ndata[15] = 0x02;\r\ndata[16] = 0x10;\r\ndata[17] = 0x20;\r\ndata[18] = 0x0A;\r\ndata[19] = 0x00;\r\nhelene_write_regs(priv, 0x81, data, sizeof(data));\r\nhelene_write_reg(priv, 0x9B, 0x00);\r\nmsleep(20);\r\nhelene_read_regs(priv, 0x1A, rdata, sizeof(rdata));\r\nif (rdata[0] != 0x00) {\r\ndev_err(&priv->i2c->dev,\r\n"HELENE tuner CPU error 0x%x\n", rdata[0]);\r\nreturn -EIO;\r\n}\r\ncdata[0] = 0x90;\r\ncdata[1] = 0x06;\r\nhelene_write_regs(priv, 0x17, cdata, sizeof(cdata));\r\nmsleep(20);\r\nhelene_read_reg(priv, 0x19, data);\r\nhelene_write_reg(priv, 0x95, (uint8_t)((data[0] >> 4) & 0x0F));\r\nhelene_write_reg(priv, 0x74, 0x02);\r\nhelene_write_reg(priv, 0x88, 0x00);\r\nhelene_write_reg(priv, 0x87, 0xC0);\r\nhelene_write_reg(priv, 0x80, 0x01);\r\ncdata[0] = 0x07;\r\ncdata[1] = 0x00;\r\nhelene_write_regs(priv, 0x41, cdata, sizeof(cdata));\r\ndev_info(&priv->i2c->dev,\r\n"HELENE tuner x_pon done\n");\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *helene_attach_s(struct dvb_frontend *fe,\r\nconst struct helene_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct helene_priv *priv = NULL;\r\npriv = kzalloc(sizeof(struct helene_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->i2c_address = (config->i2c_address >> 1);\r\npriv->i2c = i2c;\r\npriv->set_tuner_data = config->set_tuner_priv;\r\npriv->set_tuner = config->set_tuner_callback;\r\npriv->xtal = config->xtal;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (helene_x_pon(priv) != 0) {\r\nkfree(priv);\r\nreturn NULL;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nmemcpy(&fe->ops.tuner_ops, &helene_tuner_ops_s,\r\nsizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = priv;\r\ndev_info(&priv->i2c->dev,\r\n"Sony HELENE Sat attached on addr=%x at I2C adapter %p\n",\r\npriv->i2c_address, priv->i2c);\r\nreturn fe;\r\n}\r\nstruct dvb_frontend *helene_attach(struct dvb_frontend *fe,\r\nconst struct helene_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct helene_priv *priv = NULL;\r\npriv = kzalloc(sizeof(struct helene_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->i2c_address = (config->i2c_address >> 1);\r\npriv->i2c = i2c;\r\npriv->set_tuner_data = config->set_tuner_priv;\r\npriv->set_tuner = config->set_tuner_callback;\r\npriv->xtal = config->xtal;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (helene_x_pon(priv) != 0) {\r\nkfree(priv);\r\nreturn NULL;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nmemcpy(&fe->ops.tuner_ops, &helene_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = priv;\r\ndev_info(&priv->i2c->dev,\r\n"Sony HELENE Ter attached on addr=%x at I2C adapter %p\n",\r\npriv->i2c_address, priv->i2c);\r\nreturn fe;\r\n}
