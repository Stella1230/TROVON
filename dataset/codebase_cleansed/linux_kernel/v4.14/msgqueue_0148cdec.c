static struct nvkm_msgqueue_queue *\r\nmsgqueue_0148cdec_cmd_queue(struct nvkm_msgqueue *queue,\r\nenum msgqueue_msg_priority priority)\r\n{\r\nstruct msgqueue_0148cdec *priv = msgqueue_0148cdec(queue);\r\nreturn &priv->queue[MSGQUEUE_0148CDEC_COMMAND_QUEUE];\r\n}\r\nstatic void\r\nmsgqueue_0148cdec_process_msgs(struct nvkm_msgqueue *queue)\r\n{\r\nstruct msgqueue_0148cdec *priv = msgqueue_0148cdec(queue);\r\nstruct nvkm_msgqueue_queue *q_queue =\r\n&priv->queue[MSGQUEUE_0148CDEC_MESSAGE_QUEUE];\r\nnvkm_msgqueue_process_msgs(&priv->base, q_queue);\r\n}\r\nstatic void\r\ninit_gen_cmdline(struct nvkm_msgqueue *queue, void *buf)\r\n{\r\nstruct {\r\nu32 freq_hz;\r\nu32 falc_trace_size;\r\nu32 falc_trace_dma_base;\r\nu32 falc_trace_dma_idx;\r\nbool secure_mode;\r\n} *args = buf;\r\nargs->secure_mode = false;\r\n}\r\nstatic int\r\ninit_callback(struct nvkm_msgqueue *_queue, struct nvkm_msgqueue_hdr *hdr)\r\n{\r\nstruct msgqueue_0148cdec *priv = msgqueue_0148cdec(_queue);\r\nstruct {\r\nstruct nvkm_msgqueue_msg base;\r\nu8 num_queues;\r\nu16 os_debug_entry_point;\r\nstruct {\r\nu32 offset;\r\nu16 size;\r\nu8 index;\r\nu8 id;\r\n} queue_info[MSGQUEUE_0148CDEC_NUM_QUEUES];\r\nu16 sw_managed_area_offset;\r\nu16 sw_managed_area_size;\r\n} *init = (void *)hdr;\r\nconst struct nvkm_subdev *subdev = _queue->falcon->owner;\r\nint i;\r\nif (init->base.hdr.unit_id != MSGQUEUE_0148CDEC_UNIT_INIT) {\r\nnvkm_error(subdev, "expected message from init unit\n");\r\nreturn -EINVAL;\r\n}\r\nif (init->base.msg_type != INIT_MSG_INIT) {\r\nnvkm_error(subdev, "expected SEC init msg\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < MSGQUEUE_0148CDEC_NUM_QUEUES; i++) {\r\nu8 id = init->queue_info[i].id;\r\nstruct nvkm_msgqueue_queue *queue = &priv->queue[id];\r\nmutex_init(&queue->mutex);\r\nqueue->index = init->queue_info[i].index;\r\nqueue->offset = init->queue_info[i].offset;\r\nqueue->size = init->queue_info[i].size;\r\nif (id == MSGQUEUE_0148CDEC_MESSAGE_QUEUE) {\r\nqueue->head_reg = 0xa30 + (queue->index * 8);\r\nqueue->tail_reg = 0xa34 + (queue->index * 8);\r\n} else {\r\nqueue->head_reg = 0xa00 + (queue->index * 8);\r\nqueue->tail_reg = 0xa04 + (queue->index * 8);\r\n}\r\nnvkm_debug(subdev,\r\n"queue %d: index %d, offset 0x%08x, size 0x%08x\n",\r\nid, queue->index, queue->offset, queue->size);\r\n}\r\ncomplete_all(&_queue->init_done);\r\nreturn 0;\r\n}\r\nstatic void\r\nacr_boot_falcon_callback(struct nvkm_msgqueue *priv,\r\nstruct nvkm_msgqueue_hdr *hdr)\r\n{\r\nstruct acr_bootstrap_falcon_msg {\r\nstruct nvkm_msgqueue_msg base;\r\nu32 error_code;\r\nu32 falcon_id;\r\n} *msg = (void *)hdr;\r\nconst struct nvkm_subdev *subdev = priv->falcon->owner;\r\nu32 falcon_id = msg->falcon_id;\r\nif (msg->error_code) {\r\nnvkm_error(subdev, "in bootstrap falcon callback:\n");\r\nnvkm_error(subdev, "expected error code 0x%x\n",\r\nmsg->error_code);\r\nreturn;\r\n}\r\nif (falcon_id >= NVKM_SECBOOT_FALCON_END) {\r\nnvkm_error(subdev, "in bootstrap falcon callback:\n");\r\nnvkm_error(subdev, "invalid falcon ID 0x%x\n", falcon_id);\r\nreturn;\r\n}\r\nnvkm_debug(subdev, "%s booted\n", nvkm_secboot_falcon_name[falcon_id]);\r\n}\r\nstatic int\r\nacr_boot_falcon(struct nvkm_msgqueue *priv, enum nvkm_secboot_falcon falcon)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(completed);\r\nstruct {\r\nstruct nvkm_msgqueue_hdr hdr;\r\nu8 cmd_type;\r\nu32 flags;\r\nu32 falcon_id;\r\n} cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.hdr.unit_id = MSGQUEUE_0148CDEC_UNIT_ACR;\r\ncmd.hdr.size = sizeof(cmd);\r\ncmd.cmd_type = ACR_CMD_BOOTSTRAP_FALCON;\r\ncmd.flags = ACR_CMD_BOOTSTRAP_FALCON_FLAGS_RESET_YES;\r\ncmd.falcon_id = falcon;\r\nnvkm_msgqueue_post(priv, MSGQUEUE_MSG_PRIORITY_HIGH, &cmd.hdr,\r\nacr_boot_falcon_callback, &completed, true);\r\nif (!wait_for_completion_timeout(&completed, msecs_to_jiffies(1000)))\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic void\r\nmsgqueue_0148cdec_dtor(struct nvkm_msgqueue *queue)\r\n{\r\nkfree(msgqueue_0148cdec(queue));\r\n}\r\nint\r\nmsgqueue_0148cdec_new(struct nvkm_falcon *falcon, const struct nvkm_secboot *sb,\r\nstruct nvkm_msgqueue **queue)\r\n{\r\nstruct msgqueue_0148cdec *ret;\r\nret = kzalloc(sizeof(*ret), GFP_KERNEL);\r\nif (!ret)\r\nreturn -ENOMEM;\r\n*queue = &ret->base;\r\nnvkm_msgqueue_ctor(&msgqueue_0148cdec_func, falcon, &ret->base);\r\nreturn 0;\r\n}
