static void pic32_rtc_alarm_clk_enable(struct pic32_rtc_dev *pdata,\r\nbool enable)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pdata->alarm_lock, flags);\r\nif (enable) {\r\nif (!pdata->alarm_clk_enabled) {\r\nclk_enable(pdata->clk);\r\npdata->alarm_clk_enabled = true;\r\n}\r\n} else {\r\nif (pdata->alarm_clk_enabled) {\r\nclk_disable(pdata->clk);\r\npdata->alarm_clk_enabled = false;\r\n}\r\n}\r\nspin_unlock_irqrestore(&pdata->alarm_lock, flags);\r\n}\r\nstatic irqreturn_t pic32_rtc_alarmirq(int irq, void *id)\r\n{\r\nstruct pic32_rtc_dev *pdata = (struct pic32_rtc_dev *)id;\r\nclk_enable(pdata->clk);\r\nrtc_update_irq(pdata->rtc, 1, RTC_AF | RTC_IRQF);\r\nclk_disable(pdata->clk);\r\npic32_rtc_alarm_clk_enable(pdata, false);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pic32_rtc_setaie(struct device *dev, unsigned int enabled)\r\n{\r\nstruct pic32_rtc_dev *pdata = dev_get_drvdata(dev);\r\nvoid __iomem *base = pdata->reg_base;\r\nclk_enable(pdata->clk);\r\nwritel(PIC32_RTCALRM_ALRMEN,\r\nbase + (enabled ? PIC32_SET(PIC32_RTCALRM) :\r\nPIC32_CLR(PIC32_RTCALRM)));\r\nclk_disable(pdata->clk);\r\npic32_rtc_alarm_clk_enable(pdata, enabled);\r\nreturn 0;\r\n}\r\nstatic int pic32_rtc_setfreq(struct device *dev, int freq)\r\n{\r\nstruct pic32_rtc_dev *pdata = dev_get_drvdata(dev);\r\nvoid __iomem *base = pdata->reg_base;\r\nclk_enable(pdata->clk);\r\nwritel(PIC32_RTCALRM_AMASK, base + PIC32_CLR(PIC32_RTCALRM));\r\nwritel(freq << 8, base + PIC32_SET(PIC32_RTCALRM));\r\nwritel(PIC32_RTCALRM_CHIME, base + PIC32_SET(PIC32_RTCALRM));\r\nclk_disable(pdata->clk);\r\nreturn 0;\r\n}\r\nstatic int pic32_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)\r\n{\r\nstruct pic32_rtc_dev *pdata = dev_get_drvdata(dev);\r\nvoid __iomem *base = pdata->reg_base;\r\nunsigned int tries = 0;\r\nclk_enable(pdata->clk);\r\ndo {\r\nrtc_tm->tm_hour = readb(base + PIC32_RTCHOUR);\r\nrtc_tm->tm_min = readb(base + PIC32_RTCMIN);\r\nrtc_tm->tm_mon = readb(base + PIC32_RTCMON);\r\nrtc_tm->tm_mday = readb(base + PIC32_RTCDAY);\r\nrtc_tm->tm_year = readb(base + PIC32_RTCYEAR);\r\nrtc_tm->tm_sec = readb(base + PIC32_RTCSEC);\r\ntries += 1;\r\n} while (rtc_tm->tm_sec == 0 && tries < 2);\r\nrtc_tm->tm_sec = bcd2bin(rtc_tm->tm_sec);\r\nrtc_tm->tm_min = bcd2bin(rtc_tm->tm_min);\r\nrtc_tm->tm_hour = bcd2bin(rtc_tm->tm_hour);\r\nrtc_tm->tm_mday = bcd2bin(rtc_tm->tm_mday);\r\nrtc_tm->tm_mon = bcd2bin(rtc_tm->tm_mon) - 1;\r\nrtc_tm->tm_year = bcd2bin(rtc_tm->tm_year);\r\nrtc_tm->tm_year += 100;\r\ndev_dbg(dev, "read time %04d.%02d.%02d %02d:%02d:%02d\n",\r\n1900 + rtc_tm->tm_year, rtc_tm->tm_mon, rtc_tm->tm_mday,\r\nrtc_tm->tm_hour, rtc_tm->tm_min, rtc_tm->tm_sec);\r\nclk_disable(pdata->clk);\r\nreturn rtc_valid_tm(rtc_tm);\r\n}\r\nstatic int pic32_rtc_settime(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct pic32_rtc_dev *pdata = dev_get_drvdata(dev);\r\nvoid __iomem *base = pdata->reg_base;\r\nint year = tm->tm_year - 100;\r\ndev_dbg(dev, "set time %04d.%02d.%02d %02d:%02d:%02d\n",\r\n1900 + tm->tm_year, tm->tm_mon, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec);\r\nif (year < 0 || year >= 100) {\r\ndev_err(dev, "rtc only supports 100 years\n");\r\nreturn -EINVAL;\r\n}\r\nclk_enable(pdata->clk);\r\nwriteb(bin2bcd(tm->tm_sec), base + PIC32_RTCSEC);\r\nwriteb(bin2bcd(tm->tm_min), base + PIC32_RTCMIN);\r\nwriteb(bin2bcd(tm->tm_hour), base + PIC32_RTCHOUR);\r\nwriteb(bin2bcd(tm->tm_mday), base + PIC32_RTCDAY);\r\nwriteb(bin2bcd(tm->tm_mon + 1), base + PIC32_RTCMON);\r\nwriteb(bin2bcd(year), base + PIC32_RTCYEAR);\r\nclk_disable(pdata->clk);\r\nreturn 0;\r\n}\r\nstatic int pic32_rtc_getalarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct pic32_rtc_dev *pdata = dev_get_drvdata(dev);\r\nstruct rtc_time *alm_tm = &alrm->time;\r\nvoid __iomem *base = pdata->reg_base;\r\nunsigned int alm_en;\r\nclk_enable(pdata->clk);\r\nalm_tm->tm_sec = readb(base + PIC32_ALRMSEC);\r\nalm_tm->tm_min = readb(base + PIC32_ALRMMIN);\r\nalm_tm->tm_hour = readb(base + PIC32_ALRMHOUR);\r\nalm_tm->tm_mon = readb(base + PIC32_ALRMMON);\r\nalm_tm->tm_mday = readb(base + PIC32_ALRMDAY);\r\nalm_tm->tm_year = readb(base + PIC32_ALRMYEAR);\r\nalm_en = readb(base + PIC32_RTCALRM);\r\nalrm->enabled = (alm_en & PIC32_RTCALRM_ALRMEN) ? 1 : 0;\r\ndev_dbg(dev, "getalarm: %d, %04d.%02d.%02d %02d:%02d:%02d\n",\r\nalm_en,\r\n1900 + alm_tm->tm_year, alm_tm->tm_mon, alm_tm->tm_mday,\r\nalm_tm->tm_hour, alm_tm->tm_min, alm_tm->tm_sec);\r\nalm_tm->tm_sec = bcd2bin(alm_tm->tm_sec);\r\nalm_tm->tm_min = bcd2bin(alm_tm->tm_min);\r\nalm_tm->tm_hour = bcd2bin(alm_tm->tm_hour);\r\nalm_tm->tm_mday = bcd2bin(alm_tm->tm_mday);\r\nalm_tm->tm_mon = bcd2bin(alm_tm->tm_mon) - 1;\r\nalm_tm->tm_year = bcd2bin(alm_tm->tm_year);\r\nclk_disable(pdata->clk);\r\nreturn 0;\r\n}\r\nstatic int pic32_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct pic32_rtc_dev *pdata = dev_get_drvdata(dev);\r\nstruct rtc_time *tm = &alrm->time;\r\nvoid __iomem *base = pdata->reg_base;\r\nclk_enable(pdata->clk);\r\ndev_dbg(dev, "setalarm: %d, %04d.%02d.%02d %02d:%02d:%02d\n",\r\nalrm->enabled,\r\n1900 + tm->tm_year, tm->tm_mon + 1, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec);\r\nwritel(0x00, base + PIC32_ALRMTIME);\r\nwritel(0x00, base + PIC32_ALRMDATE);\r\npic32_rtc_setaie(dev, alrm->enabled);\r\nclk_disable(pdata->clk);\r\nreturn 0;\r\n}\r\nstatic int pic32_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nstruct pic32_rtc_dev *pdata = dev_get_drvdata(dev);\r\nvoid __iomem *base = pdata->reg_base;\r\nunsigned int repeat;\r\nclk_enable(pdata->clk);\r\nrepeat = readw(base + PIC32_RTCALRM);\r\nrepeat &= PIC32_RTCALRM_ARPT;\r\nseq_printf(seq, "periodic_IRQ\t: %s\n", repeat ? "yes" : "no");\r\nclk_disable(pdata->clk);\r\nreturn 0;\r\n}\r\nstatic void pic32_rtc_enable(struct pic32_rtc_dev *pdata, int en)\r\n{\r\nvoid __iomem *base = pdata->reg_base;\r\nif (!base)\r\nreturn;\r\nclk_enable(pdata->clk);\r\nif (!en) {\r\nwritel(PIC32_RTCCON_ON, base + PIC32_CLR(PIC32_RTCCON));\r\n} else {\r\npic32_syskey_unlock();\r\nwritel(PIC32_RTCCON_RTCWREN, base + PIC32_SET(PIC32_RTCCON));\r\nwritel(3 << 9, base + PIC32_CLR(PIC32_RTCCON));\r\nif (!(readl(base + PIC32_RTCCON) & PIC32_RTCCON_ON))\r\nwritel(PIC32_RTCCON_ON, base + PIC32_SET(PIC32_RTCCON));\r\n}\r\nclk_disable(pdata->clk);\r\n}\r\nstatic int pic32_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct pic32_rtc_dev *pdata = platform_get_drvdata(pdev);\r\npic32_rtc_setaie(&pdev->dev, 0);\r\nclk_unprepare(pdata->clk);\r\npdata->clk = NULL;\r\nreturn 0;\r\n}\r\nstatic int pic32_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct pic32_rtc_dev *pdata;\r\nstruct resource *res;\r\nint ret;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, pdata);\r\npdata->alarm_irq = platform_get_irq(pdev, 0);\r\nif (pdata->alarm_irq < 0) {\r\ndev_err(&pdev->dev, "no irq for alarm\n");\r\nreturn pdata->alarm_irq;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npdata->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pdata->reg_base))\r\nreturn PTR_ERR(pdata->reg_base);\r\npdata->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(pdata->clk)) {\r\ndev_err(&pdev->dev, "failed to find rtc clock source\n");\r\nret = PTR_ERR(pdata->clk);\r\npdata->clk = NULL;\r\nreturn ret;\r\n}\r\nspin_lock_init(&pdata->alarm_lock);\r\nclk_prepare_enable(pdata->clk);\r\npic32_rtc_enable(pdata, 1);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\npdata->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&pic32_rtcops,\r\nTHIS_MODULE);\r\nif (IS_ERR(pdata->rtc)) {\r\nret = PTR_ERR(pdata->rtc);\r\ngoto err_nortc;\r\n}\r\npdata->rtc->max_user_freq = 128;\r\npic32_rtc_setfreq(&pdev->dev, 1);\r\nret = devm_request_irq(&pdev->dev, pdata->alarm_irq,\r\npic32_rtc_alarmirq, 0,\r\ndev_name(&pdev->dev), pdata);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"IRQ %d error %d\n", pdata->alarm_irq, ret);\r\ngoto err_nortc;\r\n}\r\nclk_disable(pdata->clk);\r\nreturn 0;\r\nerr_nortc:\r\npic32_rtc_enable(pdata, 0);\r\nclk_disable_unprepare(pdata->clk);\r\nreturn ret;\r\n}
