static int init_hw(struct echoaudio *chip, u16 device_id, u16 subdevice_id)\r\n{\r\nint err;\r\nif (snd_BUG_ON((subdevice_id & 0xfff0) != MIA))\r\nreturn -ENODEV;\r\nif ((err = init_dsp_comm_page(chip))) {\r\ndev_err(chip->card->dev,\r\n"init_hw - could not initialize DSP comm page\n");\r\nreturn err;\r\n}\r\nchip->device_id = device_id;\r\nchip->subdevice_id = subdevice_id;\r\nchip->bad_board = true;\r\nchip->dsp_code_to_load = FW_MIA_DSP;\r\nchip->asic_loaded = true;\r\nif ((subdevice_id & 0x0000f) == MIA_MIDI_REV)\r\nchip->has_midi = true;\r\nchip->input_clock_types = ECHO_CLOCK_BIT_INTERNAL |\r\nECHO_CLOCK_BIT_SPDIF;\r\nif ((err = load_firmware(chip)) < 0)\r\nreturn err;\r\nchip->bad_board = false;\r\nreturn err;\r\n}\r\nstatic int set_mixer_defaults(struct echoaudio *chip)\r\n{\r\nreturn init_line_levels(chip);\r\n}\r\nstatic u32 detect_input_clocks(const struct echoaudio *chip)\r\n{\r\nu32 clocks_from_dsp, clock_bits;\r\nclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\r\nclock_bits = ECHO_CLOCK_BIT_INTERNAL;\r\nif (clocks_from_dsp & GLDM_CLOCK_DETECT_BIT_SPDIF)\r\nclock_bits |= ECHO_CLOCK_BIT_SPDIF;\r\nreturn clock_bits;\r\n}\r\nstatic int load_asic(struct echoaudio *chip)\r\n{\r\nreturn 0;\r\n}\r\nstatic int set_sample_rate(struct echoaudio *chip, u32 rate)\r\n{\r\nu32 control_reg;\r\nswitch (rate) {\r\ncase 96000:\r\ncontrol_reg = MIA_96000;\r\nbreak;\r\ncase 88200:\r\ncontrol_reg = MIA_88200;\r\nbreak;\r\ncase 48000:\r\ncontrol_reg = MIA_48000;\r\nbreak;\r\ncase 44100:\r\ncontrol_reg = MIA_44100;\r\nbreak;\r\ncase 32000:\r\ncontrol_reg = MIA_32000;\r\nbreak;\r\ndefault:\r\ndev_err(chip->card->dev,\r\n"set_sample_rate: %d invalid!\n", rate);\r\nreturn -EINVAL;\r\n}\r\nif (chip->input_clock == ECHO_CLOCK_SPDIF)\r\ncontrol_reg |= MIA_SPDIF;\r\nif (control_reg != le32_to_cpu(chip->comm_page->control_register)) {\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->comm_page->sample_rate = cpu_to_le32(rate);\r\nchip->comm_page->control_register = cpu_to_le32(control_reg);\r\nchip->sample_rate = rate;\r\nclear_handshake(chip);\r\nreturn send_vector(chip, DSP_VC_UPDATE_CLOCKS);\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_input_clock(struct echoaudio *chip, u16 clock)\r\n{\r\ndev_dbg(chip->card->dev, "set_input_clock(%d)\n", clock);\r\nif (snd_BUG_ON(clock != ECHO_CLOCK_INTERNAL &&\r\nclock != ECHO_CLOCK_SPDIF))\r\nreturn -EINVAL;\r\nchip->input_clock = clock;\r\nreturn set_sample_rate(chip, chip->sample_rate);\r\n}\r\nstatic int set_vmixer_gain(struct echoaudio *chip, u16 output, u16 pipe,\r\nint gain)\r\n{\r\nint index;\r\nif (snd_BUG_ON(pipe >= num_pipes_out(chip) ||\r\noutput >= num_busses_out(chip)))\r\nreturn -EINVAL;\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->vmixer_gain[output][pipe] = gain;\r\nindex = output * num_pipes_out(chip) + pipe;\r\nchip->comm_page->vmixer[index] = gain;\r\ndev_dbg(chip->card->dev,\r\n"set_vmixer_gain: pipe %d, out %d = %d\n", pipe, output, gain);\r\nreturn 0;\r\n}\r\nstatic int update_vmixer_level(struct echoaudio *chip)\r\n{\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nclear_handshake(chip);\r\nreturn send_vector(chip, DSP_VC_SET_VMIXER_GAIN);\r\n}\r\nstatic int update_flags(struct echoaudio *chip)\r\n{\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nclear_handshake(chip);\r\nreturn send_vector(chip, DSP_VC_UPDATE_FLAGS);\r\n}\r\nstatic int set_professional_spdif(struct echoaudio *chip, char prof)\r\n{\r\ndev_dbg(chip->card->dev, "set_professional_spdif %d\n", prof);\r\nif (prof)\r\nchip->comm_page->flags |=\r\ncpu_to_le32(DSP_FLAG_PROFESSIONAL_SPDIF);\r\nelse\r\nchip->comm_page->flags &=\r\n~cpu_to_le32(DSP_FLAG_PROFESSIONAL_SPDIF);\r\nchip->professional_spdif = prof;\r\nreturn update_flags(chip);\r\n}
