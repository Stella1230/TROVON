static kgid_t v9fs_get_fsgid_for_create(struct inode *dir_inode)\r\n{\r\nBUG_ON(dir_inode == NULL);\r\nif (dir_inode->i_mode & S_ISGID) {\r\nreturn dir_inode->i_gid;\r\n}\r\nreturn current_fsgid();\r\n}\r\nstatic int v9fs_test_inode_dotl(struct inode *inode, void *data)\r\n{\r\nstruct v9fs_inode *v9inode = V9FS_I(inode);\r\nstruct p9_stat_dotl *st = (struct p9_stat_dotl *)data;\r\nif ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT))\r\nreturn 0;\r\nif (inode->i_generation != st->st_gen)\r\nreturn 0;\r\nif (memcmp(&v9inode->qid.version,\r\n&st->qid.version, sizeof(v9inode->qid.version)))\r\nreturn 0;\r\nif (v9inode->qid.type != st->qid.type)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int v9fs_test_new_inode_dotl(struct inode *inode, void *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic int v9fs_set_inode_dotl(struct inode *inode, void *data)\r\n{\r\nstruct v9fs_inode *v9inode = V9FS_I(inode);\r\nstruct p9_stat_dotl *st = (struct p9_stat_dotl *)data;\r\nmemcpy(&v9inode->qid, &st->qid, sizeof(st->qid));\r\ninode->i_generation = st->st_gen;\r\nreturn 0;\r\n}\r\nstatic struct inode *v9fs_qid_iget_dotl(struct super_block *sb,\r\nstruct p9_qid *qid,\r\nstruct p9_fid *fid,\r\nstruct p9_stat_dotl *st,\r\nint new)\r\n{\r\nint retval;\r\nunsigned long i_ino;\r\nstruct inode *inode;\r\nstruct v9fs_session_info *v9ses = sb->s_fs_info;\r\nint (*test)(struct inode *, void *);\r\nif (new)\r\ntest = v9fs_test_new_inode_dotl;\r\nelse\r\ntest = v9fs_test_inode_dotl;\r\ni_ino = v9fs_qid2ino(qid);\r\ninode = iget5_locked(sb, i_ino, test, v9fs_set_inode_dotl, st);\r\nif (!inode)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (!(inode->i_state & I_NEW))\r\nreturn inode;\r\ninode->i_ino = i_ino;\r\nretval = v9fs_init_inode(v9ses, inode,\r\nst->st_mode, new_decode_dev(st->st_rdev));\r\nif (retval)\r\ngoto error;\r\nv9fs_stat2inode_dotl(st, inode);\r\nv9fs_cache_inode_get_cookie(inode);\r\nretval = v9fs_get_acl(inode, fid);\r\nif (retval)\r\ngoto error;\r\nunlock_new_inode(inode);\r\nreturn inode;\r\nerror:\r\niget_failed(inode);\r\nreturn ERR_PTR(retval);\r\n}\r\nstruct inode *\r\nv9fs_inode_from_fid_dotl(struct v9fs_session_info *v9ses, struct p9_fid *fid,\r\nstruct super_block *sb, int new)\r\n{\r\nstruct p9_stat_dotl *st;\r\nstruct inode *inode = NULL;\r\nst = p9_client_getattr_dotl(fid, P9_STATS_BASIC | P9_STATS_GEN);\r\nif (IS_ERR(st))\r\nreturn ERR_CAST(st);\r\ninode = v9fs_qid_iget_dotl(sb, &st->qid, fid, st, new);\r\nkfree(st);\r\nreturn inode;\r\n}\r\nstatic int v9fs_mapped_dotl_flags(int flags)\r\n{\r\nint i;\r\nint rflags = 0;\r\nstruct dotl_openflag_map dotl_oflag_map[] = {\r\n{ O_CREAT, P9_DOTL_CREATE },\r\n{ O_EXCL, P9_DOTL_EXCL },\r\n{ O_NOCTTY, P9_DOTL_NOCTTY },\r\n{ O_APPEND, P9_DOTL_APPEND },\r\n{ O_NONBLOCK, P9_DOTL_NONBLOCK },\r\n{ O_DSYNC, P9_DOTL_DSYNC },\r\n{ FASYNC, P9_DOTL_FASYNC },\r\n{ O_DIRECT, P9_DOTL_DIRECT },\r\n{ O_LARGEFILE, P9_DOTL_LARGEFILE },\r\n{ O_DIRECTORY, P9_DOTL_DIRECTORY },\r\n{ O_NOFOLLOW, P9_DOTL_NOFOLLOW },\r\n{ O_NOATIME, P9_DOTL_NOATIME },\r\n{ O_CLOEXEC, P9_DOTL_CLOEXEC },\r\n{ O_SYNC, P9_DOTL_SYNC},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(dotl_oflag_map); i++) {\r\nif (flags & dotl_oflag_map[i].open_flag)\r\nrflags |= dotl_oflag_map[i].dotl_flag;\r\n}\r\nreturn rflags;\r\n}\r\nint v9fs_open_to_dotl_flags(int flags)\r\n{\r\nint rflags = 0;\r\nrflags |= flags & O_ACCMODE;\r\nrflags |= v9fs_mapped_dotl_flags(flags);\r\nreturn rflags;\r\n}\r\nstatic int\r\nv9fs_vfs_create_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,\r\nbool excl)\r\n{\r\nreturn v9fs_vfs_mknod_dotl(dir, dentry, omode, 0);\r\n}\r\nstatic int\r\nv9fs_vfs_atomic_open_dotl(struct inode *dir, struct dentry *dentry,\r\nstruct file *file, unsigned flags, umode_t omode,\r\nint *opened)\r\n{\r\nint err = 0;\r\nkgid_t gid;\r\numode_t mode;\r\nconst unsigned char *name = NULL;\r\nstruct p9_qid qid;\r\nstruct inode *inode;\r\nstruct p9_fid *fid = NULL;\r\nstruct v9fs_inode *v9inode;\r\nstruct p9_fid *dfid, *ofid, *inode_fid;\r\nstruct v9fs_session_info *v9ses;\r\nstruct posix_acl *pacl = NULL, *dacl = NULL;\r\nstruct dentry *res = NULL;\r\nif (d_in_lookup(dentry)) {\r\nres = v9fs_vfs_lookup(dir, dentry, 0);\r\nif (IS_ERR(res))\r\nreturn PTR_ERR(res);\r\nif (res)\r\ndentry = res;\r\n}\r\nif (!(flags & O_CREAT) || d_really_is_positive(dentry))\r\nreturn finish_no_open(file, res);\r\nv9ses = v9fs_inode2v9ses(dir);\r\nname = dentry->d_name.name;\r\np9_debug(P9_DEBUG_VFS, "name:%s flags:0x%x mode:0x%hx\n",\r\nname, flags, omode);\r\ndfid = v9fs_parent_fid(dentry);\r\nif (IS_ERR(dfid)) {\r\nerr = PTR_ERR(dfid);\r\np9_debug(P9_DEBUG_VFS, "fid lookup failed %d\n", err);\r\ngoto out;\r\n}\r\nofid = clone_fid(dfid);\r\nif (IS_ERR(ofid)) {\r\nerr = PTR_ERR(ofid);\r\np9_debug(P9_DEBUG_VFS, "p9_client_walk failed %d\n", err);\r\ngoto out;\r\n}\r\ngid = v9fs_get_fsgid_for_create(dir);\r\nmode = omode;\r\nerr = v9fs_acl_mode(dir, &mode, &dacl, &pacl);\r\nif (err) {\r\np9_debug(P9_DEBUG_VFS, "Failed to get acl values in creat %d\n",\r\nerr);\r\ngoto error;\r\n}\r\nerr = p9_client_create_dotl(ofid, name, v9fs_open_to_dotl_flags(flags),\r\nmode, gid, &qid);\r\nif (err < 0) {\r\np9_debug(P9_DEBUG_VFS, "p9_client_open_dotl failed in creat %d\n",\r\nerr);\r\ngoto error;\r\n}\r\nv9fs_invalidate_inode_attr(dir);\r\nfid = p9_client_walk(dfid, 1, &name, 1);\r\nif (IS_ERR(fid)) {\r\nerr = PTR_ERR(fid);\r\np9_debug(P9_DEBUG_VFS, "p9_client_walk failed %d\n", err);\r\nfid = NULL;\r\ngoto error;\r\n}\r\ninode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\np9_debug(P9_DEBUG_VFS, "inode creation failed %d\n", err);\r\ngoto error;\r\n}\r\nv9fs_set_create_acl(inode, fid, dacl, pacl);\r\nv9fs_fid_add(dentry, fid);\r\nd_instantiate(dentry, inode);\r\nv9inode = V9FS_I(inode);\r\nmutex_lock(&v9inode->v_mutex);\r\nif ((v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) &&\r\n!v9inode->writeback_fid &&\r\n((flags & O_ACCMODE) != O_RDONLY)) {\r\ninode_fid = v9fs_writeback_fid(dentry);\r\nif (IS_ERR(inode_fid)) {\r\nerr = PTR_ERR(inode_fid);\r\nmutex_unlock(&v9inode->v_mutex);\r\ngoto err_clunk_old_fid;\r\n}\r\nv9inode->writeback_fid = (void *) inode_fid;\r\n}\r\nmutex_unlock(&v9inode->v_mutex);\r\nerr = finish_open(file, dentry, generic_file_open, opened);\r\nif (err)\r\ngoto err_clunk_old_fid;\r\nfile->private_data = ofid;\r\nif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\r\nv9fs_cache_inode_set_cookie(inode, file);\r\n*opened |= FILE_CREATED;\r\nout:\r\nv9fs_put_acl(dacl, pacl);\r\ndput(res);\r\nreturn err;\r\nerror:\r\nif (fid)\r\np9_client_clunk(fid);\r\nerr_clunk_old_fid:\r\nif (ofid)\r\np9_client_clunk(ofid);\r\ngoto out;\r\n}\r\nstatic int v9fs_vfs_mkdir_dotl(struct inode *dir,\r\nstruct dentry *dentry, umode_t omode)\r\n{\r\nint err;\r\nstruct v9fs_session_info *v9ses;\r\nstruct p9_fid *fid = NULL, *dfid = NULL;\r\nkgid_t gid;\r\nconst unsigned char *name;\r\numode_t mode;\r\nstruct inode *inode;\r\nstruct p9_qid qid;\r\nstruct posix_acl *dacl = NULL, *pacl = NULL;\r\np9_debug(P9_DEBUG_VFS, "name %pd\n", dentry);\r\nerr = 0;\r\nv9ses = v9fs_inode2v9ses(dir);\r\nomode |= S_IFDIR;\r\nif (dir->i_mode & S_ISGID)\r\nomode |= S_ISGID;\r\ndfid = v9fs_parent_fid(dentry);\r\nif (IS_ERR(dfid)) {\r\nerr = PTR_ERR(dfid);\r\np9_debug(P9_DEBUG_VFS, "fid lookup failed %d\n", err);\r\ndfid = NULL;\r\ngoto error;\r\n}\r\ngid = v9fs_get_fsgid_for_create(dir);\r\nmode = omode;\r\nerr = v9fs_acl_mode(dir, &mode, &dacl, &pacl);\r\nif (err) {\r\np9_debug(P9_DEBUG_VFS, "Failed to get acl values in mkdir %d\n",\r\nerr);\r\ngoto error;\r\n}\r\nname = dentry->d_name.name;\r\nerr = p9_client_mkdir_dotl(dfid, name, mode, gid, &qid);\r\nif (err < 0)\r\ngoto error;\r\nfid = p9_client_walk(dfid, 1, &name, 1);\r\nif (IS_ERR(fid)) {\r\nerr = PTR_ERR(fid);\r\np9_debug(P9_DEBUG_VFS, "p9_client_walk failed %d\n",\r\nerr);\r\nfid = NULL;\r\ngoto error;\r\n}\r\nif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\r\ninode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\np9_debug(P9_DEBUG_VFS, "inode creation failed %d\n",\r\nerr);\r\ngoto error;\r\n}\r\nv9fs_fid_add(dentry, fid);\r\nv9fs_set_create_acl(inode, fid, dacl, pacl);\r\nd_instantiate(dentry, inode);\r\nfid = NULL;\r\nerr = 0;\r\n} else {\r\ninode = v9fs_get_inode(dir->i_sb, mode, 0);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\ngoto error;\r\n}\r\nv9fs_set_create_acl(inode, fid, dacl, pacl);\r\nd_instantiate(dentry, inode);\r\n}\r\ninc_nlink(dir);\r\nv9fs_invalidate_inode_attr(dir);\r\nerror:\r\nif (fid)\r\np9_client_clunk(fid);\r\nv9fs_put_acl(dacl, pacl);\r\nreturn err;\r\n}\r\nstatic int\r\nv9fs_vfs_getattr_dotl(const struct path *path, struct kstat *stat,\r\nu32 request_mask, unsigned int flags)\r\n{\r\nstruct dentry *dentry = path->dentry;\r\nstruct v9fs_session_info *v9ses;\r\nstruct p9_fid *fid;\r\nstruct p9_stat_dotl *st;\r\np9_debug(P9_DEBUG_VFS, "dentry: %p\n", dentry);\r\nv9ses = v9fs_dentry2v9ses(dentry);\r\nif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\r\ngeneric_fillattr(d_inode(dentry), stat);\r\nreturn 0;\r\n}\r\nfid = v9fs_fid_lookup(dentry);\r\nif (IS_ERR(fid))\r\nreturn PTR_ERR(fid);\r\nst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\r\nif (IS_ERR(st))\r\nreturn PTR_ERR(st);\r\nv9fs_stat2inode_dotl(st, d_inode(dentry));\r\ngeneric_fillattr(d_inode(dentry), stat);\r\nstat->blksize = st->st_blksize;\r\nkfree(st);\r\nreturn 0;\r\n}\r\nstatic int v9fs_mapped_iattr_valid(int iattr_valid)\r\n{\r\nint i;\r\nint p9_iattr_valid = 0;\r\nstruct dotl_iattr_map dotl_iattr_map[] = {\r\n{ ATTR_MODE, P9_ATTR_MODE },\r\n{ ATTR_UID, P9_ATTR_UID },\r\n{ ATTR_GID, P9_ATTR_GID },\r\n{ ATTR_SIZE, P9_ATTR_SIZE },\r\n{ ATTR_ATIME, P9_ATTR_ATIME },\r\n{ ATTR_MTIME, P9_ATTR_MTIME },\r\n{ ATTR_CTIME, P9_ATTR_CTIME },\r\n{ ATTR_ATIME_SET, P9_ATTR_ATIME_SET },\r\n{ ATTR_MTIME_SET, P9_ATTR_MTIME_SET },\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(dotl_iattr_map); i++) {\r\nif (iattr_valid & dotl_iattr_map[i].iattr_valid)\r\np9_iattr_valid |= dotl_iattr_map[i].p9_iattr_valid;\r\n}\r\nreturn p9_iattr_valid;\r\n}\r\nint v9fs_vfs_setattr_dotl(struct dentry *dentry, struct iattr *iattr)\r\n{\r\nint retval;\r\nstruct p9_fid *fid;\r\nstruct p9_iattr_dotl p9attr;\r\nstruct inode *inode = d_inode(dentry);\r\np9_debug(P9_DEBUG_VFS, "\n");\r\nretval = setattr_prepare(dentry, iattr);\r\nif (retval)\r\nreturn retval;\r\np9attr.valid = v9fs_mapped_iattr_valid(iattr->ia_valid);\r\np9attr.mode = iattr->ia_mode;\r\np9attr.uid = iattr->ia_uid;\r\np9attr.gid = iattr->ia_gid;\r\np9attr.size = iattr->ia_size;\r\np9attr.atime_sec = iattr->ia_atime.tv_sec;\r\np9attr.atime_nsec = iattr->ia_atime.tv_nsec;\r\np9attr.mtime_sec = iattr->ia_mtime.tv_sec;\r\np9attr.mtime_nsec = iattr->ia_mtime.tv_nsec;\r\nfid = v9fs_fid_lookup(dentry);\r\nif (IS_ERR(fid))\r\nreturn PTR_ERR(fid);\r\nif (S_ISREG(inode->i_mode))\r\nfilemap_write_and_wait(inode->i_mapping);\r\nretval = p9_client_setattr(fid, &p9attr);\r\nif (retval < 0)\r\nreturn retval;\r\nif ((iattr->ia_valid & ATTR_SIZE) &&\r\niattr->ia_size != i_size_read(inode))\r\ntruncate_setsize(inode, iattr->ia_size);\r\nv9fs_invalidate_inode_attr(inode);\r\nsetattr_copy(inode, iattr);\r\nmark_inode_dirty(inode);\r\nif (iattr->ia_valid & ATTR_MODE) {\r\nretval = v9fs_acl_chmod(inode, fid);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nv9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)\r\n{\r\numode_t mode;\r\nstruct v9fs_inode *v9inode = V9FS_I(inode);\r\nif ((stat->st_result_mask & P9_STATS_BASIC) == P9_STATS_BASIC) {\r\ninode->i_atime.tv_sec = stat->st_atime_sec;\r\ninode->i_atime.tv_nsec = stat->st_atime_nsec;\r\ninode->i_mtime.tv_sec = stat->st_mtime_sec;\r\ninode->i_mtime.tv_nsec = stat->st_mtime_nsec;\r\ninode->i_ctime.tv_sec = stat->st_ctime_sec;\r\ninode->i_ctime.tv_nsec = stat->st_ctime_nsec;\r\ninode->i_uid = stat->st_uid;\r\ninode->i_gid = stat->st_gid;\r\nset_nlink(inode, stat->st_nlink);\r\nmode = stat->st_mode & S_IALLUGO;\r\nmode |= inode->i_mode & ~S_IALLUGO;\r\ninode->i_mode = mode;\r\ni_size_write(inode, stat->st_size);\r\ninode->i_blocks = stat->st_blocks;\r\n} else {\r\nif (stat->st_result_mask & P9_STATS_ATIME) {\r\ninode->i_atime.tv_sec = stat->st_atime_sec;\r\ninode->i_atime.tv_nsec = stat->st_atime_nsec;\r\n}\r\nif (stat->st_result_mask & P9_STATS_MTIME) {\r\ninode->i_mtime.tv_sec = stat->st_mtime_sec;\r\ninode->i_mtime.tv_nsec = stat->st_mtime_nsec;\r\n}\r\nif (stat->st_result_mask & P9_STATS_CTIME) {\r\ninode->i_ctime.tv_sec = stat->st_ctime_sec;\r\ninode->i_ctime.tv_nsec = stat->st_ctime_nsec;\r\n}\r\nif (stat->st_result_mask & P9_STATS_UID)\r\ninode->i_uid = stat->st_uid;\r\nif (stat->st_result_mask & P9_STATS_GID)\r\ninode->i_gid = stat->st_gid;\r\nif (stat->st_result_mask & P9_STATS_NLINK)\r\nset_nlink(inode, stat->st_nlink);\r\nif (stat->st_result_mask & P9_STATS_MODE) {\r\ninode->i_mode = stat->st_mode;\r\nif ((S_ISBLK(inode->i_mode)) ||\r\n(S_ISCHR(inode->i_mode)))\r\ninit_special_inode(inode, inode->i_mode,\r\ninode->i_rdev);\r\n}\r\nif (stat->st_result_mask & P9_STATS_RDEV)\r\ninode->i_rdev = new_decode_dev(stat->st_rdev);\r\nif (stat->st_result_mask & P9_STATS_SIZE)\r\ni_size_write(inode, stat->st_size);\r\nif (stat->st_result_mask & P9_STATS_BLOCKS)\r\ninode->i_blocks = stat->st_blocks;\r\n}\r\nif (stat->st_result_mask & P9_STATS_GEN)\r\ninode->i_generation = stat->st_gen;\r\nv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\r\n}\r\nstatic int\r\nv9fs_vfs_symlink_dotl(struct inode *dir, struct dentry *dentry,\r\nconst char *symname)\r\n{\r\nint err;\r\nkgid_t gid;\r\nconst unsigned char *name;\r\nstruct p9_qid qid;\r\nstruct inode *inode;\r\nstruct p9_fid *dfid;\r\nstruct p9_fid *fid = NULL;\r\nstruct v9fs_session_info *v9ses;\r\nname = dentry->d_name.name;\r\np9_debug(P9_DEBUG_VFS, "%lu,%s,%s\n", dir->i_ino, name, symname);\r\nv9ses = v9fs_inode2v9ses(dir);\r\ndfid = v9fs_parent_fid(dentry);\r\nif (IS_ERR(dfid)) {\r\nerr = PTR_ERR(dfid);\r\np9_debug(P9_DEBUG_VFS, "fid lookup failed %d\n", err);\r\nreturn err;\r\n}\r\ngid = v9fs_get_fsgid_for_create(dir);\r\nerr = p9_client_symlink(dfid, name, symname, gid, &qid);\r\nif (err < 0) {\r\np9_debug(P9_DEBUG_VFS, "p9_client_symlink failed %d\n", err);\r\ngoto error;\r\n}\r\nv9fs_invalidate_inode_attr(dir);\r\nif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\r\nfid = p9_client_walk(dfid, 1, &name, 1);\r\nif (IS_ERR(fid)) {\r\nerr = PTR_ERR(fid);\r\np9_debug(P9_DEBUG_VFS, "p9_client_walk failed %d\n",\r\nerr);\r\nfid = NULL;\r\ngoto error;\r\n}\r\ninode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\np9_debug(P9_DEBUG_VFS, "inode creation failed %d\n",\r\nerr);\r\ngoto error;\r\n}\r\nv9fs_fid_add(dentry, fid);\r\nd_instantiate(dentry, inode);\r\nfid = NULL;\r\nerr = 0;\r\n} else {\r\ninode = v9fs_get_inode(dir->i_sb, S_IFLNK, 0);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\ngoto error;\r\n}\r\nd_instantiate(dentry, inode);\r\n}\r\nerror:\r\nif (fid)\r\np9_client_clunk(fid);\r\nreturn err;\r\n}\r\nstatic int\r\nv9fs_vfs_link_dotl(struct dentry *old_dentry, struct inode *dir,\r\nstruct dentry *dentry)\r\n{\r\nint err;\r\nstruct p9_fid *dfid, *oldfid;\r\nstruct v9fs_session_info *v9ses;\r\np9_debug(P9_DEBUG_VFS, "dir ino: %lu, old_name: %pd, new_name: %pd\n",\r\ndir->i_ino, old_dentry, dentry);\r\nv9ses = v9fs_inode2v9ses(dir);\r\ndfid = v9fs_parent_fid(dentry);\r\nif (IS_ERR(dfid))\r\nreturn PTR_ERR(dfid);\r\noldfid = v9fs_fid_lookup(old_dentry);\r\nif (IS_ERR(oldfid))\r\nreturn PTR_ERR(oldfid);\r\nerr = p9_client_link(dfid, oldfid, dentry->d_name.name);\r\nif (err < 0) {\r\np9_debug(P9_DEBUG_VFS, "p9_client_link failed %d\n", err);\r\nreturn err;\r\n}\r\nv9fs_invalidate_inode_attr(dir);\r\nif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\r\nstruct p9_fid *fid;\r\nfid = v9fs_fid_lookup(old_dentry);\r\nif (IS_ERR(fid))\r\nreturn PTR_ERR(fid);\r\nv9fs_refresh_inode_dotl(fid, d_inode(old_dentry));\r\n}\r\nihold(d_inode(old_dentry));\r\nd_instantiate(dentry, d_inode(old_dentry));\r\nreturn err;\r\n}\r\nstatic int\r\nv9fs_vfs_mknod_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,\r\ndev_t rdev)\r\n{\r\nint err;\r\nkgid_t gid;\r\nconst unsigned char *name;\r\numode_t mode;\r\nstruct v9fs_session_info *v9ses;\r\nstruct p9_fid *fid = NULL, *dfid = NULL;\r\nstruct inode *inode;\r\nstruct p9_qid qid;\r\nstruct posix_acl *dacl = NULL, *pacl = NULL;\r\np9_debug(P9_DEBUG_VFS, " %lu,%pd mode: %hx MAJOR: %u MINOR: %u\n",\r\ndir->i_ino, dentry, omode,\r\nMAJOR(rdev), MINOR(rdev));\r\nv9ses = v9fs_inode2v9ses(dir);\r\ndfid = v9fs_parent_fid(dentry);\r\nif (IS_ERR(dfid)) {\r\nerr = PTR_ERR(dfid);\r\np9_debug(P9_DEBUG_VFS, "fid lookup failed %d\n", err);\r\ndfid = NULL;\r\ngoto error;\r\n}\r\ngid = v9fs_get_fsgid_for_create(dir);\r\nmode = omode;\r\nerr = v9fs_acl_mode(dir, &mode, &dacl, &pacl);\r\nif (err) {\r\np9_debug(P9_DEBUG_VFS, "Failed to get acl values in mknod %d\n",\r\nerr);\r\ngoto error;\r\n}\r\nname = dentry->d_name.name;\r\nerr = p9_client_mknod_dotl(dfid, name, mode, rdev, gid, &qid);\r\nif (err < 0)\r\ngoto error;\r\nv9fs_invalidate_inode_attr(dir);\r\nfid = p9_client_walk(dfid, 1, &name, 1);\r\nif (IS_ERR(fid)) {\r\nerr = PTR_ERR(fid);\r\np9_debug(P9_DEBUG_VFS, "p9_client_walk failed %d\n",\r\nerr);\r\nfid = NULL;\r\ngoto error;\r\n}\r\nif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\r\ninode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\np9_debug(P9_DEBUG_VFS, "inode creation failed %d\n",\r\nerr);\r\ngoto error;\r\n}\r\nv9fs_set_create_acl(inode, fid, dacl, pacl);\r\nv9fs_fid_add(dentry, fid);\r\nd_instantiate(dentry, inode);\r\nfid = NULL;\r\nerr = 0;\r\n} else {\r\ninode = v9fs_get_inode(dir->i_sb, mode, rdev);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\ngoto error;\r\n}\r\nv9fs_set_create_acl(inode, fid, dacl, pacl);\r\nd_instantiate(dentry, inode);\r\n}\r\nerror:\r\nif (fid)\r\np9_client_clunk(fid);\r\nv9fs_put_acl(dacl, pacl);\r\nreturn err;\r\n}\r\nstatic const char *\r\nv9fs_vfs_get_link_dotl(struct dentry *dentry,\r\nstruct inode *inode,\r\nstruct delayed_call *done)\r\n{\r\nstruct p9_fid *fid;\r\nchar *target;\r\nint retval;\r\nif (!dentry)\r\nreturn ERR_PTR(-ECHILD);\r\np9_debug(P9_DEBUG_VFS, "%pd\n", dentry);\r\nfid = v9fs_fid_lookup(dentry);\r\nif (IS_ERR(fid))\r\nreturn ERR_CAST(fid);\r\nretval = p9_client_readlink(fid, &target);\r\nif (retval)\r\nreturn ERR_PTR(retval);\r\nset_delayed_call(done, kfree_link, target);\r\nreturn target;\r\n}\r\nint v9fs_refresh_inode_dotl(struct p9_fid *fid, struct inode *inode)\r\n{\r\nloff_t i_size;\r\nstruct p9_stat_dotl *st;\r\nstruct v9fs_session_info *v9ses;\r\nv9ses = v9fs_inode2v9ses(inode);\r\nst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\r\nif (IS_ERR(st))\r\nreturn PTR_ERR(st);\r\nif ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT))\r\ngoto out;\r\nspin_lock(&inode->i_lock);\r\ni_size = inode->i_size;\r\nv9fs_stat2inode_dotl(st, inode);\r\nif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\r\ninode->i_size = i_size;\r\nspin_unlock(&inode->i_lock);\r\nout:\r\nkfree(st);\r\nreturn 0;\r\n}
