static inline u32 le32_to_cpuvp(const void *p)\r\n{\r\nreturn le32_to_cpup(p);\r\n}\r\nstatic void chacha20_docrypt(u32 *state, u8 *dst, const u8 *src,\r\nunsigned int bytes)\r\n{\r\nu8 stream[CHACHA20_BLOCK_SIZE];\r\nif (dst != src)\r\nmemcpy(dst, src, bytes);\r\nwhile (bytes >= CHACHA20_BLOCK_SIZE) {\r\nchacha20_block(state, stream);\r\ncrypto_xor(dst, stream, CHACHA20_BLOCK_SIZE);\r\nbytes -= CHACHA20_BLOCK_SIZE;\r\ndst += CHACHA20_BLOCK_SIZE;\r\n}\r\nif (bytes) {\r\nchacha20_block(state, stream);\r\ncrypto_xor(dst, stream, bytes);\r\n}\r\n}\r\nvoid crypto_chacha20_init(u32 *state, struct chacha20_ctx *ctx, u8 *iv)\r\n{\r\nstatic const char constant[16] = "expand 32-byte k";\r\nstate[0] = le32_to_cpuvp(constant + 0);\r\nstate[1] = le32_to_cpuvp(constant + 4);\r\nstate[2] = le32_to_cpuvp(constant + 8);\r\nstate[3] = le32_to_cpuvp(constant + 12);\r\nstate[4] = ctx->key[0];\r\nstate[5] = ctx->key[1];\r\nstate[6] = ctx->key[2];\r\nstate[7] = ctx->key[3];\r\nstate[8] = ctx->key[4];\r\nstate[9] = ctx->key[5];\r\nstate[10] = ctx->key[6];\r\nstate[11] = ctx->key[7];\r\nstate[12] = le32_to_cpuvp(iv + 0);\r\nstate[13] = le32_to_cpuvp(iv + 4);\r\nstate[14] = le32_to_cpuvp(iv + 8);\r\nstate[15] = le32_to_cpuvp(iv + 12);\r\n}\r\nint crypto_chacha20_setkey(struct crypto_skcipher *tfm, const u8 *key,\r\nunsigned int keysize)\r\n{\r\nstruct chacha20_ctx *ctx = crypto_skcipher_ctx(tfm);\r\nint i;\r\nif (keysize != CHACHA20_KEY_SIZE)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(ctx->key); i++)\r\nctx->key[i] = le32_to_cpuvp(key + i * sizeof(u32));\r\nreturn 0;\r\n}\r\nint crypto_chacha20_crypt(struct skcipher_request *req)\r\n{\r\nstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\r\nstruct chacha20_ctx *ctx = crypto_skcipher_ctx(tfm);\r\nstruct skcipher_walk walk;\r\nu32 state[16];\r\nint err;\r\nerr = skcipher_walk_virt(&walk, req, true);\r\ncrypto_chacha20_init(state, ctx, walk.iv);\r\nwhile (walk.nbytes > 0) {\r\nunsigned int nbytes = walk.nbytes;\r\nif (nbytes < walk.total)\r\nnbytes = round_down(nbytes, walk.stride);\r\nchacha20_docrypt(state, walk.dst.virt.addr, walk.src.virt.addr,\r\nnbytes);\r\nerr = skcipher_walk_done(&walk, walk.nbytes - nbytes);\r\n}\r\nreturn err;\r\n}\r\nstatic int __init chacha20_generic_mod_init(void)\r\n{\r\nreturn crypto_register_skcipher(&alg);\r\n}\r\nstatic void __exit chacha20_generic_mod_fini(void)\r\n{\r\ncrypto_unregister_skcipher(&alg);\r\n}
