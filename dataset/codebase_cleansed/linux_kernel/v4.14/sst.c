static inline bool sst_is_process_reply(u32 msg_id)\r\n{\r\nreturn ((msg_id & PROCESS_MSG) ? true : false);\r\n}\r\nstatic inline bool sst_validate_mailbox_size(unsigned int size)\r\n{\r\nreturn ((size <= SST_MAILBOX_SIZE) ? true : false);\r\n}\r\nstatic irqreturn_t intel_sst_interrupt_mrfld(int irq, void *context)\r\n{\r\nunion interrupt_reg_mrfld isr;\r\nunion ipc_header_mrfld header;\r\nunion sst_imr_reg_mrfld imr;\r\nstruct ipc_post *msg = NULL;\r\nunsigned int size = 0;\r\nstruct intel_sst_drv *drv = (struct intel_sst_drv *) context;\r\nirqreturn_t retval = IRQ_HANDLED;\r\nisr.full = sst_shim_read64(drv->shim, SST_ISRX);\r\nif (isr.part.done_interrupt) {\r\nspin_lock(&drv->ipc_spin_lock);\r\nheader.full = sst_shim_read64(drv->shim,\r\ndrv->ipc_reg.ipcx);\r\nheader.p.header_high.part.done = 0;\r\nsst_shim_write64(drv->shim, drv->ipc_reg.ipcx, header.full);\r\n;\r\nisr.part.done_interrupt = 1;\r\nsst_shim_write64(drv->shim, SST_ISRX, isr.full);\r\nspin_unlock(&drv->ipc_spin_lock);\r\nqueue_work(drv->post_msg_wq, &drv->ipc_post_msg_wq);\r\nretval = IRQ_HANDLED;\r\n}\r\nif (isr.part.busy_interrupt) {\r\nspin_lock(&drv->ipc_spin_lock);\r\nimr.full = sst_shim_read64(drv->shim, SST_IMRX);\r\nimr.part.busy_interrupt = 1;\r\nsst_shim_write64(drv->shim, SST_IMRX, imr.full);\r\nspin_unlock(&drv->ipc_spin_lock);\r\nheader.full = sst_shim_read64(drv->shim, drv->ipc_reg.ipcd);\r\nif (sst_create_ipc_msg(&msg, header.p.header_high.part.large)) {\r\ndrv->ops->clear_interrupt(drv);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (header.p.header_high.part.large) {\r\nsize = header.p.header_low_payload;\r\nif (sst_validate_mailbox_size(size)) {\r\nmemcpy_fromio(msg->mailbox_data,\r\ndrv->mailbox + drv->mailbox_recv_offset, size);\r\n} else {\r\ndev_err(drv->dev,\r\n"Mailbox not copied, payload size is: %u\n", size);\r\nheader.p.header_low_payload = 0;\r\n}\r\n}\r\nmsg->mrfld_header = header;\r\nmsg->is_process_reply =\r\nsst_is_process_reply(header.p.header_high.part.msg_id);\r\nspin_lock(&drv->rx_msg_lock);\r\nlist_add_tail(&msg->node, &drv->rx_list);\r\nspin_unlock(&drv->rx_msg_lock);\r\ndrv->ops->clear_interrupt(drv);\r\nretval = IRQ_WAKE_THREAD;\r\n}\r\nreturn retval;\r\n}\r\nstatic irqreturn_t intel_sst_irq_thread_mrfld(int irq, void *context)\r\n{\r\nstruct intel_sst_drv *drv = (struct intel_sst_drv *) context;\r\nstruct ipc_post *__msg, *msg = NULL;\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&drv->rx_msg_lock, irq_flags);\r\nif (list_empty(&drv->rx_list)) {\r\nspin_unlock_irqrestore(&drv->rx_msg_lock, irq_flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nlist_for_each_entry_safe(msg, __msg, &drv->rx_list, node) {\r\nlist_del(&msg->node);\r\nspin_unlock_irqrestore(&drv->rx_msg_lock, irq_flags);\r\nif (msg->is_process_reply)\r\ndrv->ops->process_message(msg);\r\nelse\r\ndrv->ops->process_reply(drv, msg);\r\nif (msg->is_large)\r\nkfree(msg->mailbox_data);\r\nkfree(msg);\r\nspin_lock_irqsave(&drv->rx_msg_lock, irq_flags);\r\n}\r\nspin_unlock_irqrestore(&drv->rx_msg_lock, irq_flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sst_save_dsp_context_v2(struct intel_sst_drv *sst)\r\n{\r\nint ret = 0;\r\nret = sst_prepare_and_post_msg(sst, SST_TASK_ID_MEDIA, IPC_CMD,\r\nIPC_PREP_D3, PIPE_RSVD, 0, NULL, NULL,\r\ntrue, true, false, true);\r\nif (ret < 0) {\r\ndev_err(sst->dev, "not suspending FW!!, Err: %d\n", ret);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint sst_driver_ops(struct intel_sst_drv *sst)\r\n{\r\nswitch (sst->dev_id) {\r\ncase SST_MRFLD_PCI_ID:\r\ncase SST_BYT_ACPI_ID:\r\ncase SST_CHV_ACPI_ID:\r\nsst->tstamp = SST_TIME_STAMP_MRFLD;\r\nsst->ops = &mrfld_ops;\r\nreturn 0;\r\ndefault:\r\ndev_err(sst->dev,\r\n"SST Driver capabilities missing for dev_id: %x",\r\nsst->dev_id);\r\nreturn -EINVAL;\r\n};\r\n}\r\nvoid sst_process_pending_msg(struct work_struct *work)\r\n{\r\nstruct intel_sst_drv *ctx = container_of(work,\r\nstruct intel_sst_drv, ipc_post_msg_wq);\r\nctx->ops->post_message(ctx, NULL, false);\r\n}\r\nstatic int sst_workqueue_init(struct intel_sst_drv *ctx)\r\n{\r\nINIT_LIST_HEAD(&ctx->memcpy_list);\r\nINIT_LIST_HEAD(&ctx->rx_list);\r\nINIT_LIST_HEAD(&ctx->ipc_dispatch_list);\r\nINIT_LIST_HEAD(&ctx->block_list);\r\nINIT_WORK(&ctx->ipc_post_msg_wq, sst_process_pending_msg);\r\ninit_waitqueue_head(&ctx->wait_queue);\r\nctx->post_msg_wq =\r\ncreate_singlethread_workqueue("sst_post_msg_wq");\r\nif (!ctx->post_msg_wq)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic void sst_init_locks(struct intel_sst_drv *ctx)\r\n{\r\nmutex_init(&ctx->sst_lock);\r\nspin_lock_init(&ctx->rx_msg_lock);\r\nspin_lock_init(&ctx->ipc_spin_lock);\r\nspin_lock_init(&ctx->block_lock);\r\n}\r\nint sst_alloc_drv_context(struct intel_sst_drv **ctx,\r\nstruct device *dev, unsigned int dev_id)\r\n{\r\n*ctx = devm_kzalloc(dev, sizeof(struct intel_sst_drv), GFP_KERNEL);\r\nif (!(*ctx))\r\nreturn -ENOMEM;\r\n(*ctx)->dev = dev;\r\n(*ctx)->dev_id = dev_id;\r\nreturn 0;\r\n}\r\nstatic ssize_t firmware_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nif (ctx->fw_version.type == 0 && ctx->fw_version.major == 0 &&\r\nctx->fw_version.minor == 0 && ctx->fw_version.build == 0)\r\nreturn sprintf(buf, "FW not yet loaded\n");\r\nelse\r\nreturn sprintf(buf, "v%02x.%02x.%02x.%02x\n",\r\nctx->fw_version.type, ctx->fw_version.major,\r\nctx->fw_version.minor, ctx->fw_version.build);\r\n}\r\nint sst_context_init(struct intel_sst_drv *ctx)\r\n{\r\nint ret = 0, i;\r\nif (!ctx->pdata)\r\nreturn -EINVAL;\r\nif (!ctx->pdata->probe_data)\r\nreturn -EINVAL;\r\nmemcpy(&ctx->info, ctx->pdata->probe_data, sizeof(ctx->info));\r\nret = sst_driver_ops(ctx);\r\nif (ret != 0)\r\nreturn -EINVAL;\r\nsst_init_locks(ctx);\r\nsst_set_fw_state_locked(ctx, SST_RESET);\r\nctx->pvt_id = 1;\r\nctx->stream_cnt = 0;\r\nctx->fw_in_mem = NULL;\r\nctx->use_dma = 0;\r\nctx->use_lli = 0;\r\nif (sst_workqueue_init(ctx))\r\nreturn -EINVAL;\r\nctx->mailbox_recv_offset = ctx->pdata->ipc_info->mbox_recv_off;\r\nctx->ipc_reg.ipcx = SST_IPCX + ctx->pdata->ipc_info->ipc_offset;\r\nctx->ipc_reg.ipcd = SST_IPCD + ctx->pdata->ipc_info->ipc_offset;\r\ndev_info(ctx->dev, "Got drv data max stream %d\n",\r\nctx->info.max_streams);\r\nfor (i = 1; i <= ctx->info.max_streams; i++) {\r\nstruct stream_info *stream = &ctx->streams[i];\r\nmemset(stream, 0, sizeof(*stream));\r\nstream->pipe_id = PIPE_RSVD;\r\nmutex_init(&stream->lock);\r\n}\r\nret = devm_request_threaded_irq(ctx->dev, ctx->irq_num, ctx->ops->interrupt,\r\nctx->ops->irq_thread, 0, SST_DRV_NAME,\r\nctx);\r\nif (ret)\r\ngoto do_free_mem;\r\ndev_dbg(ctx->dev, "Registered IRQ %#x\n", ctx->irq_num);\r\nsst_shim_write64(ctx->shim, SST_IMRX, 0xFFFF0038);\r\nctx->qos = devm_kzalloc(ctx->dev,\r\nsizeof(struct pm_qos_request), GFP_KERNEL);\r\nif (!ctx->qos) {\r\nret = -ENOMEM;\r\ngoto do_free_mem;\r\n}\r\npm_qos_add_request(ctx->qos, PM_QOS_CPU_DMA_LATENCY,\r\nPM_QOS_DEFAULT_VALUE);\r\ndev_dbg(ctx->dev, "Requesting FW %s now...\n", ctx->firmware_name);\r\nret = request_firmware_nowait(THIS_MODULE, true, ctx->firmware_name,\r\nctx->dev, GFP_KERNEL, ctx, sst_firmware_load_cb);\r\nif (ret) {\r\ndev_err(ctx->dev, "Firmware download failed:%d\n", ret);\r\ngoto do_free_mem;\r\n}\r\nret = sysfs_create_group(&ctx->dev->kobj,\r\n&sst_fw_version_attr_group);\r\nif (ret) {\r\ndev_err(ctx->dev,\r\n"Unable to create sysfs\n");\r\ngoto err_sysfs;\r\n}\r\nsst_register(ctx->dev);\r\nreturn 0;\r\nerr_sysfs:\r\nsysfs_remove_group(&ctx->dev->kobj, &sst_fw_version_attr_group);\r\ndo_free_mem:\r\ndestroy_workqueue(ctx->post_msg_wq);\r\nreturn ret;\r\n}\r\nvoid sst_context_cleanup(struct intel_sst_drv *ctx)\r\n{\r\npm_runtime_get_noresume(ctx->dev);\r\npm_runtime_disable(ctx->dev);\r\nsst_unregister(ctx->dev);\r\nsst_set_fw_state_locked(ctx, SST_SHUTDOWN);\r\nsysfs_remove_group(&ctx->dev->kobj, &sst_fw_version_attr_group);\r\nflush_scheduled_work();\r\ndestroy_workqueue(ctx->post_msg_wq);\r\npm_qos_remove_request(ctx->qos);\r\nkfree(ctx->fw_sg_list.src);\r\nkfree(ctx->fw_sg_list.dst);\r\nctx->fw_sg_list.list_len = 0;\r\nkfree(ctx->fw_in_mem);\r\nctx->fw_in_mem = NULL;\r\nsst_memcpy_free_resources(ctx);\r\nctx = NULL;\r\n}\r\nvoid sst_configure_runtime_pm(struct intel_sst_drv *ctx)\r\n{\r\npm_runtime_set_autosuspend_delay(ctx->dev, SST_SUSPEND_DELAY);\r\npm_runtime_use_autosuspend(ctx->dev);\r\nif (!acpi_disabled)\r\npm_runtime_set_active(ctx->dev);\r\npm_runtime_enable(ctx->dev);\r\nif (acpi_disabled)\r\npm_runtime_set_active(ctx->dev);\r\nelse\r\npm_runtime_put_noidle(ctx->dev);\r\n}\r\nstatic int intel_sst_runtime_suspend(struct device *dev)\r\n{\r\nint ret = 0;\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nif (ctx->sst_state == SST_RESET) {\r\ndev_dbg(dev, "LPE is already in RESET state, No action\n");\r\nreturn 0;\r\n}\r\nif (ctx->ops->save_dsp_context(ctx))\r\nreturn -EBUSY;\r\nsst_set_fw_state_locked(ctx, SST_RESET);\r\nsynchronize_irq(ctx->irq_num);\r\nflush_workqueue(ctx->post_msg_wq);\r\nctx->ops->reset(ctx);\r\nreturn ret;\r\n}\r\nstatic int intel_sst_suspend(struct device *dev)\r\n{\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nstruct sst_fw_save *fw_save;\r\nint i, ret = 0;\r\nif (ctx->sst_state == SST_RESET)\r\nreturn 0;\r\nfor (i = 1; i <= ctx->info.max_streams; i++) {\r\nstruct stream_info *stream = &ctx->streams[i];\r\nif (stream->status == STREAM_RUNNING) {\r\ndev_err(dev, "stream %d is running, can't suspend, abort\n", i);\r\nreturn -EBUSY;\r\n}\r\n}\r\nsynchronize_irq(ctx->irq_num);\r\nflush_workqueue(ctx->post_msg_wq);\r\nsst_set_fw_state_locked(ctx, SST_RESET);\r\nif (ctx->ops->save_dsp_context(ctx))\r\nreturn -EBUSY;\r\nfw_save = kzalloc(sizeof(*fw_save), GFP_KERNEL);\r\nif (!fw_save)\r\nreturn -ENOMEM;\r\nfw_save->iram = kvzalloc(ctx->iram_end - ctx->iram_base, GFP_KERNEL);\r\nif (!fw_save->iram) {\r\nret = -ENOMEM;\r\ngoto iram;\r\n}\r\nfw_save->dram = kvzalloc(ctx->dram_end - ctx->dram_base, GFP_KERNEL);\r\nif (!fw_save->dram) {\r\nret = -ENOMEM;\r\ngoto dram;\r\n}\r\nfw_save->sram = kvzalloc(SST_MAILBOX_SIZE, GFP_KERNEL);\r\nif (!fw_save->sram) {\r\nret = -ENOMEM;\r\ngoto sram;\r\n}\r\nfw_save->ddr = kvzalloc(ctx->ddr_end - ctx->ddr_base, GFP_KERNEL);\r\nif (!fw_save->ddr) {\r\nret = -ENOMEM;\r\ngoto ddr;\r\n}\r\nmemcpy32_fromio(fw_save->iram, ctx->iram, ctx->iram_end - ctx->iram_base);\r\nmemcpy32_fromio(fw_save->dram, ctx->dram, ctx->dram_end - ctx->dram_base);\r\nmemcpy32_fromio(fw_save->sram, ctx->mailbox, SST_MAILBOX_SIZE);\r\nmemcpy32_fromio(fw_save->ddr, ctx->ddr, ctx->ddr_end - ctx->ddr_base);\r\nctx->fw_save = fw_save;\r\nctx->ops->reset(ctx);\r\nreturn 0;\r\nddr:\r\nkvfree(fw_save->sram);\r\nsram:\r\nkvfree(fw_save->dram);\r\ndram:\r\nkvfree(fw_save->iram);\r\niram:\r\nkfree(fw_save);\r\nreturn ret;\r\n}\r\nstatic int intel_sst_resume(struct device *dev)\r\n{\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nstruct sst_fw_save *fw_save = ctx->fw_save;\r\nint ret = 0;\r\nstruct sst_block *block;\r\nif (!fw_save)\r\nreturn 0;\r\nsst_set_fw_state_locked(ctx, SST_FW_LOADING);\r\nctx->ops->reset(ctx);\r\nctx->fw_save = NULL;\r\nmemcpy32_toio(ctx->iram, fw_save->iram, ctx->iram_end - ctx->iram_base);\r\nmemcpy32_toio(ctx->dram, fw_save->dram, ctx->dram_end - ctx->dram_base);\r\nmemcpy32_toio(ctx->mailbox, fw_save->sram, SST_MAILBOX_SIZE);\r\nmemcpy32_toio(ctx->ddr, fw_save->ddr, ctx->ddr_end - ctx->ddr_base);\r\nkvfree(fw_save->sram);\r\nkvfree(fw_save->dram);\r\nkvfree(fw_save->iram);\r\nkvfree(fw_save->ddr);\r\nkfree(fw_save);\r\nblock = sst_create_block(ctx, 0, FW_DWNL_ID);\r\nif (block == NULL)\r\nreturn -ENOMEM;\r\nctx->ops->start(ctx);\r\nret = sst_wait_timeout(ctx, block);\r\nif (ret) {\r\ndev_err(ctx->dev, "fw download failed %d\n", ret);\r\nret = -EBUSY;\r\n} else {\r\nsst_set_fw_state_locked(ctx, SST_FW_RUNNING);\r\n}\r\nsst_free_block(ctx, block);\r\nreturn ret;\r\n}
