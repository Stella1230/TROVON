static inline bool i40e_fcoe_sof_is_class2(u8 sof)\r\n{\r\nreturn (sof == FC_SOF_I2) || (sof == FC_SOF_N2);\r\n}\r\nstatic inline bool i40e_fcoe_sof_is_class3(u8 sof)\r\n{\r\nreturn (sof == FC_SOF_I3) || (sof == FC_SOF_N3);\r\n}\r\nstatic inline bool i40e_fcoe_sof_is_supported(u8 sof)\r\n{\r\nreturn i40e_fcoe_sof_is_class2(sof) ||\r\ni40e_fcoe_sof_is_class3(sof);\r\n}\r\nstatic inline int i40e_fcoe_fc_sof(struct sk_buff *skb, u8 *sof)\r\n{\r\n*sof = ((struct fcoe_hdr *)skb_network_header(skb))->fcoe_sof;\r\nif (!i40e_fcoe_sof_is_supported(*sof))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline bool i40e_fcoe_eof_is_supported(u8 eof)\r\n{\r\nreturn (eof == FC_EOF_N) || (eof == FC_EOF_T) ||\r\n(eof == FC_EOF_NI) || (eof == FC_EOF_A);\r\n}\r\nstatic inline int i40e_fcoe_fc_eof(struct sk_buff *skb, u8 *eof)\r\n{\r\nskb_copy_bits(skb, skb->len - 4, eof, 1);\r\nif (!i40e_fcoe_eof_is_supported(*eof))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline u32 i40e_fcoe_ctxt_eof(u8 eof)\r\n{\r\nswitch (eof) {\r\ncase FC_EOF_N:\r\nreturn I40E_TX_DESC_CMD_L4T_EOFT_EOF_N;\r\ncase FC_EOF_T:\r\nreturn I40E_TX_DESC_CMD_L4T_EOFT_EOF_T;\r\ncase FC_EOF_NI:\r\nreturn I40E_TX_DESC_CMD_L4T_EOFT_EOF_NI;\r\ncase FC_EOF_A:\r\nreturn I40E_TX_DESC_CMD_L4T_EOFT_EOF_A;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline bool i40e_fcoe_xid_is_valid(u16 xid)\r\n{\r\nreturn (xid != FC_XID_UNKNOWN) && (xid < I40E_FCOE_DDP_MAX);\r\n}\r\nstatic inline void i40e_fcoe_ddp_unmap(struct i40e_pf *pf,\r\nstruct i40e_fcoe_ddp *ddp)\r\n{\r\nif (test_and_set_bit(__I40E_FCOE_DDP_UNMAPPED, &ddp->flags))\r\nreturn;\r\nif (ddp->sgl) {\r\ndma_unmap_sg(&pf->pdev->dev, ddp->sgl, ddp->sgc,\r\nDMA_FROM_DEVICE);\r\nddp->sgl = NULL;\r\nddp->sgc = 0;\r\n}\r\nif (ddp->pool) {\r\ndma_pool_free(ddp->pool, ddp->udl, ddp->udp);\r\nddp->pool = NULL;\r\n}\r\n}\r\nstatic inline void i40e_fcoe_ddp_clear(struct i40e_fcoe_ddp *ddp)\r\n{\r\nmemset(ddp, 0, sizeof(struct i40e_fcoe_ddp));\r\nddp->xid = FC_XID_UNKNOWN;\r\nddp->flags = __I40E_FCOE_DDP_NONE;\r\n}\r\nstatic inline bool i40e_fcoe_progid_is_fcoe(u8 id)\r\n{\r\nreturn (id == I40E_RX_PROG_STATUS_DESC_FCOE_CTXT_PROG_STATUS) ||\r\n(id == I40E_RX_PROG_STATUS_DESC_FCOE_CTXT_INVL_STATUS);\r\n}\r\nstatic inline u16 i40e_fcoe_fc_get_xid(struct fc_frame_header *fh)\r\n{\r\nu32 f_ctl = ntoh24(fh->fh_f_ctl);\r\nreturn (f_ctl & FC_FC_EX_CTX) ?\r\nbe16_to_cpu(fh->fh_ox_id) :\r\nbe16_to_cpu(fh->fh_rx_id);\r\n}\r\nstatic inline struct fc_frame_header *i40e_fcoe_fc_frame_header(\r\nstruct sk_buff *skb)\r\n{\r\nvoid *fh = skb->data + sizeof(struct fcoe_hdr);\r\nif (eth_hdr(skb)->h_proto == htons(ETH_P_8021Q))\r\nfh += sizeof(struct vlan_hdr);\r\nreturn (struct fc_frame_header *)fh;\r\n}\r\nstatic int i40e_fcoe_ddp_put(struct net_device *netdev, u16 xid)\r\n{\r\nstruct i40e_netdev_priv *np = netdev_priv(netdev);\r\nstruct i40e_pf *pf = np->vsi->back;\r\nstruct i40e_fcoe *fcoe = &pf->fcoe;\r\nint len = 0;\r\nstruct i40e_fcoe_ddp *ddp = &fcoe->ddp[xid];\r\nif (!fcoe || !ddp)\r\ngoto out;\r\nif (test_bit(__I40E_FCOE_DDP_DONE, &ddp->flags))\r\nlen = ddp->len;\r\ni40e_fcoe_ddp_unmap(pf, ddp);\r\nout:\r\nreturn len;\r\n}\r\nvoid i40e_init_pf_fcoe(struct i40e_pf *pf)\r\n{\r\nstruct i40e_hw *hw = &pf->hw;\r\nu32 val;\r\npf->flags &= ~I40E_FLAG_FCOE_ENABLED;\r\npf->num_fcoe_qps = 0;\r\npf->fcoe_hmc_cntx_num = 0;\r\npf->fcoe_hmc_filt_num = 0;\r\nif (!pf->hw.func_caps.fcoe) {\r\ndev_dbg(&pf->pdev->dev, "FCoE capability is disabled\n");\r\nreturn;\r\n}\r\nif (!pf->hw.func_caps.dcb) {\r\ndev_warn(&pf->pdev->dev,\r\n"Hardware is not DCB capable not enabling FCoE.\n");\r\nreturn;\r\n}\r\nval = i40e_read_rx_ctl(hw, I40E_PFQF_HENA(1));\r\nval |= BIT(I40E_FILTER_PCTYPE_FCOE_OX - 32);\r\nval |= BIT(I40E_FILTER_PCTYPE_FCOE_RX - 32);\r\nval &= I40E_PFQF_HENA_PTYPE_ENA_MASK;\r\ni40e_write_rx_ctl(hw, I40E_PFQF_HENA(1), val);\r\npf->flags |= I40E_FLAG_FCOE_ENABLED;\r\npf->num_fcoe_qps = I40E_DEFAULT_FCOE;\r\npf->fcoe_hmc_cntx_num = BIT(I40E_DMA_CNTX_SIZE_4K) *\r\nI40E_DMA_CNTX_BASE_SIZE;\r\npf->fcoe_hmc_filt_num = pf->fcoe_hmc_cntx_num +\r\nBIT(I40E_HASH_FILTER_SIZE_16K) *\r\nI40E_HASH_FILTER_BASE_SIZE;\r\npf->filter_settings.fcoe_filt_num = I40E_HASH_FILTER_SIZE_16K;\r\npf->filter_settings.fcoe_cntx_num = I40E_DMA_CNTX_SIZE_4K;\r\nval = i40e_read_rx_ctl(hw, I40E_GLFCOE_RCTL);\r\nval &= ~I40E_GLFCOE_RCTL_MAX_SIZE_MASK;\r\nval |= ((FCOE_MTU + ETH_HLEN + VLAN_HLEN + ETH_FCS_LEN)\r\n<< I40E_GLFCOE_RCTL_MAX_SIZE_SHIFT);\r\ni40e_write_rx_ctl(hw, I40E_GLFCOE_RCTL, val);\r\ndev_info(&pf->pdev->dev, "FCoE is supported.\n");\r\n}\r\nu8 i40e_get_fcoe_tc_map(struct i40e_pf *pf)\r\n{\r\nstruct i40e_dcb_app_priority_table app;\r\nstruct i40e_hw *hw = &pf->hw;\r\nu8 enabled_tc = 0;\r\nu8 tc, i;\r\nstruct i40e_dcbx_config *dcbcfg = &hw->local_dcbx_config;\r\nfor (i = 0; i < dcbcfg->numapps; i++) {\r\napp = dcbcfg->app[i];\r\nif (app.selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&\r\napp.protocolid == ETH_P_FCOE) {\r\ntc = dcbcfg->etscfg.prioritytable[app.priority];\r\nenabled_tc |= BIT(tc);\r\nbreak;\r\n}\r\n}\r\nenabled_tc = enabled_tc ? enabled_tc : 0x1;\r\nreturn enabled_tc;\r\n}\r\nint i40e_fcoe_vsi_init(struct i40e_vsi *vsi, struct i40e_vsi_context *ctxt)\r\n{\r\nstruct i40e_aqc_vsi_properties_data *info = &ctxt->info;\r\nstruct i40e_pf *pf = vsi->back;\r\nstruct i40e_hw *hw = &pf->hw;\r\nu8 enabled_tc = 0;\r\nif (!(pf->flags & I40E_FLAG_FCOE_ENABLED)) {\r\ndev_err(&pf->pdev->dev,\r\n"FCoE is not enabled for this device\n");\r\nreturn -EPERM;\r\n}\r\nctxt->pf_num = hw->pf_id;\r\nctxt->vf_num = 0;\r\nctxt->uplink_seid = vsi->uplink_seid;\r\nctxt->connection_type = I40E_AQ_VSI_CONN_TYPE_NORMAL;\r\nctxt->flags = I40E_AQ_VSI_TYPE_PF;\r\ninfo->valid_sections |= cpu_to_le16(I40E_AQ_VSI_PROP_QUEUE_OPT_VALID);\r\ninfo->valid_sections &= cpu_to_le16(~(I40E_AQ_VSI_PROP_SECURITY_VALID |\r\nI40E_AQ_VSI_PROP_VLAN_VALID |\r\nI40E_AQ_VSI_PROP_CAS_PV_VALID |\r\nI40E_AQ_VSI_PROP_INGRESS_UP_VALID |\r\nI40E_AQ_VSI_PROP_EGRESS_UP_VALID));\r\nif (i40e_is_vsi_uplink_mode_veb(vsi)) {\r\ninfo->valid_sections |=\r\ncpu_to_le16(I40E_AQ_VSI_PROP_SWITCH_VALID);\r\ninfo->switch_id =\r\ncpu_to_le16(I40E_AQ_VSI_SW_ID_FLAG_ALLOW_LB);\r\n}\r\nenabled_tc = i40e_get_fcoe_tc_map(pf);\r\ni40e_vsi_setup_queue_map(vsi, ctxt, enabled_tc, true);\r\ninfo->queueing_opt_flags = I40E_AQ_VSI_QUE_OPT_FCOE_ENA;\r\nreturn 0;\r\n}\r\nint i40e_fcoe_enable(struct net_device *netdev)\r\n{\r\nstruct i40e_netdev_priv *np = netdev_priv(netdev);\r\nstruct i40e_vsi *vsi = np->vsi;\r\nstruct i40e_pf *pf = vsi->back;\r\nstruct i40e_fcoe *fcoe = &pf->fcoe;\r\nif (!(pf->flags & I40E_FLAG_FCOE_ENABLED)) {\r\nnetdev_err(netdev, "HW does not support FCoE.\n");\r\nreturn -ENODEV;\r\n}\r\nif (vsi->type != I40E_VSI_FCOE) {\r\nnetdev_err(netdev, "interface does not support FCoE.\n");\r\nreturn -EBUSY;\r\n}\r\natomic_inc(&fcoe->refcnt);\r\nreturn 0;\r\n}\r\nint i40e_fcoe_disable(struct net_device *netdev)\r\n{\r\nstruct i40e_netdev_priv *np = netdev_priv(netdev);\r\nstruct i40e_vsi *vsi = np->vsi;\r\nstruct i40e_pf *pf = vsi->back;\r\nstruct i40e_fcoe *fcoe = &pf->fcoe;\r\nif (!(pf->flags & I40E_FLAG_FCOE_ENABLED)) {\r\nnetdev_err(netdev, "device does not support FCoE\n");\r\nreturn -ENODEV;\r\n}\r\nif (vsi->type != I40E_VSI_FCOE)\r\nreturn -EBUSY;\r\nif (!atomic_dec_and_test(&fcoe->refcnt))\r\nreturn -EINVAL;\r\nnetdev_info(netdev, "FCoE disabled\n");\r\nreturn 0;\r\n}\r\nstatic void i40e_fcoe_dma_pool_free(struct i40e_fcoe *fcoe,\r\nstruct device *dev,\r\nunsigned int cpu)\r\n{\r\nstruct i40e_fcoe_ddp_pool *ddp_pool;\r\nddp_pool = per_cpu_ptr(fcoe->ddp_pool, cpu);\r\nif (!ddp_pool->pool) {\r\ndev_warn(dev, "DDP pool already freed for cpu %d\n", cpu);\r\nreturn;\r\n}\r\ndma_pool_destroy(ddp_pool->pool);\r\nddp_pool->pool = NULL;\r\n}\r\nstatic int i40e_fcoe_dma_pool_create(struct i40e_fcoe *fcoe,\r\nstruct device *dev,\r\nunsigned int cpu)\r\n{\r\nstruct i40e_fcoe_ddp_pool *ddp_pool;\r\nstruct dma_pool *pool;\r\nchar pool_name[32];\r\nddp_pool = per_cpu_ptr(fcoe->ddp_pool, cpu);\r\nif (ddp_pool && ddp_pool->pool) {\r\ndev_warn(dev, "DDP pool already allocated for cpu %d\n", cpu);\r\nreturn 0;\r\n}\r\nsnprintf(pool_name, sizeof(pool_name), "i40e_fcoe_ddp_%d", cpu);\r\npool = dma_pool_create(pool_name, dev, I40E_FCOE_DDP_PTR_MAX,\r\nI40E_FCOE_DDP_PTR_ALIGN, PAGE_SIZE);\r\nif (!pool) {\r\ndev_err(dev, "dma_pool_create %s failed\n", pool_name);\r\nreturn -ENOMEM;\r\n}\r\nddp_pool->pool = pool;\r\nreturn 0;\r\n}\r\nvoid i40e_fcoe_free_ddp_resources(struct i40e_vsi *vsi)\r\n{\r\nstruct i40e_pf *pf = vsi->back;\r\nstruct i40e_fcoe *fcoe = &pf->fcoe;\r\nint cpu, i;\r\nif (vsi->type != I40E_VSI_FCOE)\r\nreturn;\r\nif (!fcoe->ddp_pool)\r\nreturn;\r\nfor (i = 0; i < I40E_FCOE_DDP_MAX; i++)\r\ni40e_fcoe_ddp_put(vsi->netdev, i);\r\nfor_each_possible_cpu(cpu)\r\ni40e_fcoe_dma_pool_free(fcoe, &pf->pdev->dev, cpu);\r\nfree_percpu(fcoe->ddp_pool);\r\nfcoe->ddp_pool = NULL;\r\nnetdev_info(vsi->netdev, "VSI %d,%d FCoE DDP resources released\n",\r\nvsi->id, vsi->seid);\r\n}\r\nint i40e_fcoe_setup_ddp_resources(struct i40e_vsi *vsi)\r\n{\r\nstruct i40e_pf *pf = vsi->back;\r\nstruct device *dev = &pf->pdev->dev;\r\nstruct i40e_fcoe *fcoe = &pf->fcoe;\r\nunsigned int cpu;\r\nint i;\r\nif (vsi->type != I40E_VSI_FCOE)\r\nreturn -ENODEV;\r\nif (fcoe->ddp_pool)\r\nreturn -EEXIST;\r\nfcoe->ddp_pool = alloc_percpu(struct i40e_fcoe_ddp_pool);\r\nif (!fcoe->ddp_pool) {\r\ndev_err(&pf->pdev->dev, "failed to allocate percpu DDP\n");\r\nreturn -ENOMEM;\r\n}\r\nfor_each_possible_cpu(cpu) {\r\nif (!i40e_fcoe_dma_pool_create(fcoe, dev, cpu))\r\ncontinue;\r\ndev_err(dev, "failed to alloc DDP pool on cpu:%d\n", cpu);\r\ni40e_fcoe_free_ddp_resources(vsi);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < I40E_FCOE_DDP_MAX; i++)\r\ni40e_fcoe_ddp_clear(&fcoe->ddp[i]);\r\nnetdev_info(vsi->netdev, "VSI %d,%d FCoE DDP resources allocated\n",\r\nvsi->id, vsi->seid);\r\nreturn 0;\r\n}\r\nvoid i40e_fcoe_handle_status(struct i40e_ring *rx_ring,\r\nunion i40e_rx_desc *rx_desc, u8 prog_id)\r\n{\r\nstruct i40e_pf *pf = rx_ring->vsi->back;\r\nstruct i40e_fcoe *fcoe = &pf->fcoe;\r\nstruct i40e_fcoe_ddp *ddp;\r\nu32 error;\r\nu16 xid;\r\nu64 qw;\r\nif (!i40e_fcoe_progid_is_fcoe(prog_id))\r\nreturn;\r\nxid = le32_to_cpu(rx_desc->wb.qword0.hi_dword.fcoe_param) &\r\n(I40E_FCOE_DDP_MAX - 1);\r\nif (!i40e_fcoe_xid_is_valid(xid))\r\nreturn;\r\nddp = &fcoe->ddp[xid];\r\nWARN_ON(xid != ddp->xid);\r\nqw = le64_to_cpu(rx_desc->wb.qword1.status_error_len);\r\nerror = (qw & I40E_RX_PROG_STATUS_DESC_QW1_ERROR_MASK) >>\r\nI40E_RX_PROG_STATUS_DESC_QW1_ERROR_SHIFT;\r\nif (prog_id == I40E_RX_PROG_STATUS_DESC_FCOE_CTXT_PROG_STATUS) {\r\nif (I40E_RX_PROG_FCOE_ERROR_TBL_FULL(error)) {\r\ndev_err(&pf->pdev->dev, "xid %x ddp->xid %x TABLE FULL\n",\r\nxid, ddp->xid);\r\nddp->prerr |= I40E_RX_PROG_FCOE_ERROR_TBL_FULL_BIT;\r\n}\r\nif (I40E_RX_PROG_FCOE_ERROR_CONFLICT(error)) {\r\ndev_err(&pf->pdev->dev, "xid %x ddp->xid %x CONFLICT\n",\r\nxid, ddp->xid);\r\nddp->prerr |= I40E_RX_PROG_FCOE_ERROR_CONFLICT_BIT;\r\n}\r\n}\r\nif (prog_id == I40E_RX_PROG_STATUS_DESC_FCOE_CTXT_INVL_STATUS) {\r\nif (I40E_RX_PROG_FCOE_ERROR_INVLFAIL(error)) {\r\ndev_err(&pf->pdev->dev, "xid %x ddp->xid %x INVALIDATION FAILURE\n",\r\nxid, ddp->xid);\r\nddp->prerr |= I40E_RX_PROG_FCOE_ERROR_INVLFAIL_BIT;\r\n}\r\nclear_bit(__I40E_FCOE_DDP_ABORTED, &ddp->flags);\r\n}\r\ni40e_fcoe_ddp_unmap(pf, ddp);\r\ni40e_fcoe_ddp_clear(ddp);\r\n}\r\nint i40e_fcoe_handle_offload(struct i40e_ring *rx_ring,\r\nunion i40e_rx_desc *rx_desc,\r\nstruct sk_buff *skb)\r\n{\r\nstruct i40e_pf *pf = rx_ring->vsi->back;\r\nstruct i40e_fcoe *fcoe = &pf->fcoe;\r\nstruct fc_frame_header *fh = NULL;\r\nstruct i40e_fcoe_ddp *ddp = NULL;\r\nu32 status, fltstat;\r\nu32 error, fcerr;\r\nint rc = -EINVAL;\r\nu16 ptype;\r\nu16 xid;\r\nu64 qw;\r\nqw = le64_to_cpu(rx_desc->wb.qword1.status_error_len);\r\nptype = (qw & I40E_RXD_QW1_PTYPE_MASK) >> I40E_RXD_QW1_PTYPE_SHIFT;\r\nif (!i40e_rx_is_fcoe(ptype))\r\ngoto out_no_ddp;\r\nerror = (qw & I40E_RXD_QW1_ERROR_MASK) >> I40E_RXD_QW1_ERROR_SHIFT;\r\nfcerr = (error >> I40E_RX_DESC_ERROR_L3L4E_SHIFT) &\r\nI40E_RX_DESC_FCOE_ERROR_MASK;\r\nif (unlikely(fcerr == I40E_RX_DESC_ERROR_L3L4E_PROT)) {\r\ndev_err(&pf->pdev->dev, "Protocol Error\n");\r\nskb->ip_summed = CHECKSUM_NONE;\r\n} else {\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n}\r\nstatus = (qw & I40E_RXD_QW1_STATUS_MASK) >> I40E_RXD_QW1_STATUS_SHIFT;\r\nfltstat = (status >> I40E_RX_DESC_STATUS_FLTSTAT_SHIFT) &\r\nI40E_RX_DESC_FLTSTAT_FCMASK;\r\nfh = i40e_fcoe_fc_frame_header(skb);\r\nxid = i40e_fcoe_fc_get_xid(fh);\r\nif (!i40e_fcoe_xid_is_valid(xid))\r\ngoto out_no_ddp;\r\nif (fltstat == I40E_RX_DESC_FLTSTAT_NOMTCH)\r\ngoto out_no_ddp;\r\nddp = &fcoe->ddp[xid];\r\nif (!ddp->sgl)\r\ngoto out_no_ddp;\r\nxid = le16_to_cpu(rx_desc->wb.qword0.lo_dword.mirr_fcoe.fcoe_ctx_id);\r\nif (ddp->xid != xid) {\r\ndev_err(&pf->pdev->dev, "xid 0x%x does not match ctx_xid 0x%x\n",\r\nddp->xid, xid);\r\ngoto out_put_ddp;\r\n}\r\nif (ddp->fcerr) {\r\ndev_err(&pf->pdev->dev, "xid 0x%x fcerr 0x%x reported fcer 0x%x\n",\r\nxid, ddp->fcerr, fcerr);\r\ngoto out_put_ddp;\r\n}\r\nddp->len = le32_to_cpu(rx_desc->wb.qword0.hi_dword.fcoe_param);\r\nddp->fcerr = fcerr;\r\nif (fltstat == I40E_RX_DESC_FLTSTAT_DDP) {\r\nu32 f_ctl = ntoh24(fh->fh_f_ctl);\r\nif ((f_ctl & FC_FC_END_SEQ) &&\r\n(fh->fh_r_ctl == FC_RCTL_DD_SOL_DATA)) {\r\nstruct fcoe_crc_eof *crc = NULL;\r\ncrc = skb_put(skb, sizeof(*crc));\r\ncrc->fcoe_eof = FC_EOF_T;\r\n} else {\r\nrc = 0;\r\ngoto out_no_ddp;\r\n}\r\n}\r\nout_put_ddp:\r\ni40e_fcoe_ddp_unmap(pf, ddp);\r\nif (ddp->len && !ddp->fcerr) {\r\nint pkts;\r\nrc = ddp->len;\r\ni40e_fcoe_ddp_clear(ddp);\r\nddp->len = rc;\r\npkts = DIV_ROUND_UP(rc, 2048);\r\nrx_ring->stats.bytes += rc;\r\nrx_ring->stats.packets += pkts;\r\nrx_ring->q_vector->rx.total_bytes += rc;\r\nrx_ring->q_vector->rx.total_packets += pkts;\r\nset_bit(__I40E_FCOE_DDP_DONE, &ddp->flags);\r\n}\r\nout_no_ddp:\r\nreturn rc;\r\n}\r\nstatic int i40e_fcoe_ddp_setup(struct net_device *netdev, u16 xid,\r\nstruct scatterlist *sgl, unsigned int sgc,\r\nint target_mode)\r\n{\r\nstatic const unsigned int bufflen = I40E_FCOE_DDP_BUF_MIN;\r\nstruct i40e_netdev_priv *np = netdev_priv(netdev);\r\nstruct i40e_fcoe_ddp_pool *ddp_pool;\r\nstruct i40e_pf *pf = np->vsi->back;\r\nstruct i40e_fcoe *fcoe = &pf->fcoe;\r\nunsigned int i, j, dmacount;\r\nstruct i40e_fcoe_ddp *ddp;\r\nunsigned int firstoff = 0;\r\nunsigned int thisoff = 0;\r\nunsigned int thislen = 0;\r\nstruct scatterlist *sg;\r\ndma_addr_t addr = 0;\r\nunsigned int len;\r\nif (xid >= I40E_FCOE_DDP_MAX) {\r\ndev_warn(&pf->pdev->dev, "xid=0x%x out-of-range\n", xid);\r\nreturn 0;\r\n}\r\nif (test_bit(__I40E_DOWN, &pf->state) ||\r\ntest_bit(__I40E_NEEDS_RESTART, &pf->state)) {\r\ndev_info(&pf->pdev->dev, "xid=0x%x device in reset/down\n",\r\nxid);\r\nreturn 0;\r\n}\r\nddp = &fcoe->ddp[xid];\r\nif (ddp->sgl) {\r\ndev_info(&pf->pdev->dev, "xid 0x%x w/ non-null sgl=%p nents=%d\n",\r\nxid, ddp->sgl, ddp->sgc);\r\nreturn 0;\r\n}\r\ni40e_fcoe_ddp_clear(ddp);\r\nif (!fcoe->ddp_pool) {\r\ndev_info(&pf->pdev->dev, "No DDP pool, xid 0x%x\n", xid);\r\nreturn 0;\r\n}\r\nddp_pool = per_cpu_ptr(fcoe->ddp_pool, get_cpu());\r\nif (!ddp_pool->pool) {\r\ndev_info(&pf->pdev->dev, "No percpu ddp pool, xid 0x%x\n", xid);\r\ngoto out_noddp;\r\n}\r\ndmacount = dma_map_sg(&pf->pdev->dev, sgl, sgc, DMA_FROM_DEVICE);\r\nif (dmacount == 0) {\r\ndev_info(&pf->pdev->dev, "dma_map_sg for sgl %p, sgc %d failed\n",\r\nsgl, sgc);\r\ngoto out_noddp_unmap;\r\n}\r\nddp->udl = dma_pool_alloc(ddp_pool->pool, GFP_ATOMIC, &ddp->udp);\r\nif (!ddp->udl) {\r\ndev_info(&pf->pdev->dev,\r\n"Failed allocated ddp context, xid 0x%x\n", xid);\r\ngoto out_noddp_unmap;\r\n}\r\nj = 0;\r\nddp->len = 0;\r\nfor_each_sg(sgl, sg, dmacount, i) {\r\naddr = sg_dma_address(sg);\r\nlen = sg_dma_len(sg);\r\nddp->len += len;\r\nwhile (len) {\r\nif (j >= I40E_FCOE_DDP_BUFFCNT_MAX) {\r\ndev_info(&pf->pdev->dev,\r\n"xid=%x:%d,%d,%d:addr=%llx not enough descriptors\n",\r\nxid, i, j, dmacount, (u64)addr);\r\ngoto out_noddp_free;\r\n}\r\nthisoff = addr & ((dma_addr_t)bufflen - 1);\r\nthislen = min_t(unsigned int, (bufflen - thisoff), len);\r\nif ((j != 0) && (thisoff))\r\ngoto out_noddp_free;\r\nif (((i != (dmacount - 1)) || (thislen != len)) &&\r\n((thislen + thisoff) != bufflen))\r\ngoto out_noddp_free;\r\nddp->udl[j] = (u64)(addr - thisoff);\r\nif (j == 0)\r\nfirstoff = thisoff;\r\nlen -= thislen;\r\naddr += thislen;\r\nj++;\r\n}\r\n}\r\nddp->lastsize = thisoff + thislen;\r\nddp->firstoff = firstoff;\r\nddp->list_len = j;\r\nddp->pool = ddp_pool->pool;\r\nddp->sgl = sgl;\r\nddp->sgc = sgc;\r\nddp->xid = xid;\r\nif (target_mode)\r\nset_bit(__I40E_FCOE_DDP_TARGET, &ddp->flags);\r\nset_bit(__I40E_FCOE_DDP_INITALIZED, &ddp->flags);\r\nput_cpu();\r\nreturn 1;\r\nout_noddp_free:\r\ndma_pool_free(ddp->pool, ddp->udl, ddp->udp);\r\ni40e_fcoe_ddp_clear(ddp);\r\nout_noddp_unmap:\r\ndma_unmap_sg(&pf->pdev->dev, sgl, sgc, DMA_FROM_DEVICE);\r\nout_noddp:\r\nput_cpu();\r\nreturn 0;\r\n}\r\nstatic int i40e_fcoe_ddp_get(struct net_device *netdev, u16 xid,\r\nstruct scatterlist *sgl, unsigned int sgc)\r\n{\r\nreturn i40e_fcoe_ddp_setup(netdev, xid, sgl, sgc, 0);\r\n}\r\nstatic int i40e_fcoe_ddp_target(struct net_device *netdev, u16 xid,\r\nstruct scatterlist *sgl, unsigned int sgc)\r\n{\r\nreturn i40e_fcoe_ddp_setup(netdev, xid, sgl, sgc, 1);\r\n}\r\nstatic void i40e_fcoe_program_ddp(struct i40e_ring *tx_ring,\r\nstruct sk_buff *skb,\r\nstruct i40e_fcoe_ddp *ddp, u8 sof)\r\n{\r\nstruct i40e_fcoe_filter_context_desc *filter_desc = NULL;\r\nstruct i40e_fcoe_queue_context_desc *queue_desc = NULL;\r\nstruct i40e_fcoe_ddp_context_desc *ddp_desc = NULL;\r\nstruct i40e_pf *pf = tx_ring->vsi->back;\r\nu16 i = tx_ring->next_to_use;\r\nstruct fc_frame_header *fh;\r\nu64 flags_rsvd_lanq = 0;\r\nbool target_mode;\r\nif (test_bit(__I40E_FCOE_DDP_ABORTED, &ddp->flags)) {\r\ndev_warn(&pf->pdev->dev,\r\n"DDP abort is still pending xid:%hx and ddp->flags:%lx:\n",\r\nddp->xid, ddp->flags);\r\nreturn;\r\n}\r\nif (test_and_set_bit(__I40E_FCOE_DDP_PROGRAMMED, &ddp->flags)) {\r\ndev_warn(&pf->pdev->dev,\r\n"DDP is already programmed for xid:%hx and ddp->flags:%lx:\n",\r\nddp->xid, ddp->flags);\r\nreturn;\r\n}\r\nddp_desc = I40E_DDP_CONTEXT_DESC(tx_ring, i);\r\ni++;\r\nif (i == tx_ring->count)\r\ni = 0;\r\nddp_desc->type_cmd_foff_lsize =\r\ncpu_to_le64(I40E_TX_DESC_DTYPE_DDP_CTX |\r\n((u64)I40E_FCOE_DDP_CTX_DESC_BSIZE_4K <<\r\nI40E_FCOE_DDP_CTX_QW1_CMD_SHIFT) |\r\n((u64)ddp->firstoff <<\r\nI40E_FCOE_DDP_CTX_QW1_FOFF_SHIFT) |\r\n((u64)ddp->lastsize <<\r\nI40E_FCOE_DDP_CTX_QW1_LSIZE_SHIFT));\r\nddp_desc->rsvd = cpu_to_le64(0);\r\ntarget_mode = test_bit(__I40E_FCOE_DDP_TARGET, &ddp->flags);\r\nif (target_mode)\r\nddp_desc->type_cmd_foff_lsize |=\r\ncpu_to_le64(I40E_FCOE_DDP_CTX_DESC_LASTSEQH);\r\nqueue_desc = I40E_QUEUE_CONTEXT_DESC(tx_ring, i++);\r\nif (i == tx_ring->count)\r\ni = 0;\r\nqueue_desc->dmaindx_fbase = cpu_to_le64(ddp->xid | ((u64)ddp->udp));\r\nqueue_desc->flen_tph = cpu_to_le64(ddp->list_len |\r\n((u64)(I40E_FCOE_QUEUE_CTX_DESC_TPHRDESC |\r\nI40E_FCOE_QUEUE_CTX_DESC_TPHDATA) <<\r\nI40E_FCOE_QUEUE_CTX_QW1_TPH_SHIFT));\r\nfilter_desc = I40E_FILTER_CONTEXT_DESC(tx_ring, i);\r\ni++;\r\nif (i == tx_ring->count)\r\ni = 0;\r\nfh = (struct fc_frame_header *)skb_transport_header(skb);\r\nfilter_desc->param = cpu_to_le32(ntohl(fh->fh_parm_offset));\r\nfilter_desc->seqn = cpu_to_le16(ntohs(fh->fh_seq_cnt));\r\nfilter_desc->rsvd_dmaindx = cpu_to_le16(ddp->xid <<\r\nI40E_FCOE_FILTER_CTX_QW0_DMAINDX_SHIFT);\r\nflags_rsvd_lanq = I40E_FCOE_FILTER_CTX_DESC_CTYP_DDP;\r\nflags_rsvd_lanq |= (u64)(target_mode ?\r\nI40E_FCOE_FILTER_CTX_DESC_ENODE_RSP :\r\nI40E_FCOE_FILTER_CTX_DESC_ENODE_INIT);\r\nflags_rsvd_lanq |= (u64)((sof == FC_SOF_I2 || sof == FC_SOF_N2) ?\r\nI40E_FCOE_FILTER_CTX_DESC_FC_CLASS2 :\r\nI40E_FCOE_FILTER_CTX_DESC_FC_CLASS3);\r\nflags_rsvd_lanq |= ((u64)skb->queue_mapping <<\r\nI40E_FCOE_FILTER_CTX_QW1_LANQINDX_SHIFT);\r\nfilter_desc->flags_rsvd_lanq = cpu_to_le64(flags_rsvd_lanq);\r\ntx_ring->next_to_use = i;\r\n}\r\nstatic void i40e_fcoe_invalidate_ddp(struct i40e_ring *tx_ring,\r\nstruct sk_buff *skb,\r\nstruct i40e_fcoe_ddp *ddp)\r\n{\r\nstruct i40e_tx_context_desc *context_desc;\r\nint i;\r\nif (test_and_set_bit(__I40E_FCOE_DDP_ABORTED, &ddp->flags))\r\nreturn;\r\ni = tx_ring->next_to_use;\r\ncontext_desc = I40E_TX_CTXTDESC(tx_ring, i);\r\ni++;\r\nif (i == tx_ring->count)\r\ni = 0;\r\ncontext_desc->tunneling_params = cpu_to_le32(0);\r\ncontext_desc->l2tag2 = cpu_to_le16(0);\r\ncontext_desc->rsvd = cpu_to_le16(0);\r\ncontext_desc->type_cmd_tso_mss = cpu_to_le64(\r\nI40E_TX_DESC_DTYPE_FCOE_CTX |\r\n(I40E_FCOE_TX_CTX_DESC_OPCODE_DDP_CTX_INVL <<\r\nI40E_TXD_CTX_QW1_CMD_SHIFT) |\r\n(I40E_FCOE_TX_CTX_DESC_OPCODE_SINGLE_SEND <<\r\nI40E_TXD_CTX_QW1_CMD_SHIFT));\r\ntx_ring->next_to_use = i;\r\n}\r\nstatic void i40e_fcoe_handle_ddp(struct i40e_ring *tx_ring,\r\nstruct sk_buff *skb, u8 sof)\r\n{\r\nstruct i40e_pf *pf = tx_ring->vsi->back;\r\nstruct i40e_fcoe *fcoe = &pf->fcoe;\r\nstruct fc_frame_header *fh;\r\nstruct i40e_fcoe_ddp *ddp;\r\nu32 f_ctl;\r\nu8 r_ctl;\r\nu16 xid;\r\nfh = (struct fc_frame_header *)skb_transport_header(skb);\r\nf_ctl = ntoh24(fh->fh_f_ctl);\r\nr_ctl = fh->fh_r_ctl;\r\nddp = NULL;\r\nif ((r_ctl == FC_RCTL_DD_DATA_DESC) && (f_ctl & FC_FC_EX_CTX)) {\r\nxid = ntohs(fh->fh_rx_id);\r\nif (i40e_fcoe_xid_is_valid(xid)) {\r\nddp = &fcoe->ddp[xid];\r\nif ((ddp->xid == xid) &&\r\n(test_bit(__I40E_FCOE_DDP_TARGET, &ddp->flags)))\r\ni40e_fcoe_program_ddp(tx_ring, skb, ddp, sof);\r\n}\r\n} else if (r_ctl == FC_RCTL_DD_UNSOL_CMD) {\r\nxid = ntohs(fh->fh_ox_id);\r\nif (i40e_fcoe_xid_is_valid(xid)) {\r\nddp = &fcoe->ddp[xid];\r\nif ((ddp->xid == xid) &&\r\n(!test_bit(__I40E_FCOE_DDP_TARGET, &ddp->flags)))\r\ni40e_fcoe_program_ddp(tx_ring, skb, ddp, sof);\r\n}\r\n} else if (r_ctl == FC_RCTL_BA_ABTS) {\r\nxid = ntohs(fh->fh_ox_id);\r\nif (i40e_fcoe_xid_is_valid(xid)) {\r\nddp = &fcoe->ddp[xid];\r\nif ((ddp->xid == xid) &&\r\n(!test_bit(__I40E_FCOE_DDP_TARGET, &ddp->flags)))\r\ni40e_fcoe_invalidate_ddp(tx_ring, skb, ddp);\r\n}\r\n}\r\n}\r\nstatic int i40e_fcoe_tso(struct i40e_ring *tx_ring,\r\nstruct sk_buff *skb,\r\nu32 tx_flags, u8 *hdr_len, u8 sof)\r\n{\r\nstruct i40e_tx_context_desc *context_desc;\r\nu32 cd_type, cd_cmd, cd_tso_len, cd_mss;\r\nstruct fc_frame_header *fh;\r\nu64 cd_type_cmd_tso_mss;\r\nif (!skb_is_gso(skb))\r\nreturn 0;\r\nif (skb_shinfo(skb)->gso_type != SKB_GSO_FCOE) {\r\nnetdev_err(skb->dev,\r\n"wrong gso type %d:expecting SKB_GSO_FCOE\n",\r\nskb_shinfo(skb)->gso_type);\r\nreturn -EINVAL;\r\n}\r\n*hdr_len = skb_transport_offset(skb) + sizeof(struct fc_frame_header) +\r\nsizeof(struct fcoe_crc_eof);\r\nif (likely(i40e_fcoe_sof_is_class3(sof)))\r\ncd_cmd = I40E_FCOE_TX_CTX_DESC_OPCODE_TSO_FC_CLASS3;\r\nelse\r\ncd_cmd = I40E_FCOE_TX_CTX_DESC_OPCODE_TSO_FC_CLASS2;\r\nfh = (struct fc_frame_header *)skb_transport_header(skb);\r\nif (fh->fh_f_ctl[2] & FC_FC_REL_OFF)\r\ncd_cmd |= I40E_FCOE_TX_CTX_DESC_RELOFF;\r\ncd_type = I40E_TX_DESC_DTYPE_FCOE_CTX;\r\ncd_tso_len = skb->len - *hdr_len;\r\ncd_mss = skb_shinfo(skb)->gso_size;\r\ncd_type_cmd_tso_mss =\r\n((u64)cd_type << I40E_TXD_CTX_QW1_DTYPE_SHIFT) |\r\n((u64)cd_cmd << I40E_TXD_CTX_QW1_CMD_SHIFT) |\r\n((u64)cd_tso_len << I40E_TXD_CTX_QW1_TSO_LEN_SHIFT) |\r\n((u64)cd_mss << I40E_TXD_CTX_QW1_MSS_SHIFT);\r\ncontext_desc = I40E_TX_CTXTDESC(tx_ring, tx_ring->next_to_use);\r\ntx_ring->next_to_use++;\r\nif (tx_ring->next_to_use == tx_ring->count)\r\ntx_ring->next_to_use = 0;\r\ncontext_desc->tunneling_params = 0;\r\ncontext_desc->l2tag2 = cpu_to_le16((tx_flags & I40E_TX_FLAGS_VLAN_MASK)\r\n>> I40E_TX_FLAGS_VLAN_SHIFT);\r\ncontext_desc->type_cmd_tso_mss = cpu_to_le64(cd_type_cmd_tso_mss);\r\nreturn 1;\r\n}\r\nstatic void i40e_fcoe_tx_map(struct i40e_ring *tx_ring,\r\nstruct sk_buff *skb,\r\nstruct i40e_tx_buffer *first,\r\nu32 tx_flags, u8 hdr_len, u8 eof)\r\n{\r\nu32 td_offset = 0;\r\nu32 td_cmd = 0;\r\nu32 maclen;\r\ntd_cmd = I40E_TX_DESC_CMD_ICRC;\r\nmaclen = skb_network_offset(skb);\r\nif (tx_flags & I40E_TX_FLAGS_SW_VLAN)\r\nmaclen += sizeof(struct vlan_hdr);\r\nif (skb->protocol == htons(ETH_P_FCOE)) {\r\nmaclen -= 2;\r\ntd_cmd |= (I40E_TX_DESC_CMD_FCOET | i40e_fcoe_ctxt_eof(eof));\r\ntd_offset |= ((((sizeof(struct fcoe_hdr) + 2) >> 2) <<\r\nI40E_TX_DESC_LENGTH_IPLEN_SHIFT) |\r\n((sizeof(struct fc_frame_header) >> 2) <<\r\nI40E_TX_DESC_LENGTH_L4_FC_LEN_SHIFT));\r\npskb_trim(skb, skb->len - sizeof(struct fcoe_crc_eof));\r\n}\r\ntd_offset |= (maclen >> 1) << I40E_TX_DESC_LENGTH_MACLEN_SHIFT;\r\ni40e_tx_map(tx_ring, skb, first, tx_flags, hdr_len, td_cmd, td_offset);\r\n}\r\nstatic inline int i40e_fcoe_set_skb_header(struct sk_buff *skb)\r\n{\r\n__be16 protocol = skb->protocol;\r\nskb_reset_mac_header(skb);\r\nskb->mac_len = sizeof(struct ethhdr);\r\nif (protocol == htons(ETH_P_8021Q)) {\r\nstruct vlan_ethhdr *veth = (struct vlan_ethhdr *)eth_hdr(skb);\r\nprotocol = veth->h_vlan_encapsulated_proto;\r\nskb->mac_len += sizeof(struct vlan_hdr);\r\n}\r\nif ((protocol != htons(ETH_P_FIP)) &&\r\n(protocol != htons(ETH_P_FCOE)))\r\nreturn -EINVAL;\r\nskb_set_network_header(skb, skb->mac_len);\r\nif (protocol == htons(ETH_P_FIP))\r\nreturn 0;\r\nskb_set_transport_header(skb, skb->mac_len + sizeof(struct fcoe_hdr));\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t i40e_fcoe_xmit_frame(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct i40e_netdev_priv *np = netdev_priv(skb->dev);\r\nstruct i40e_vsi *vsi = np->vsi;\r\nstruct i40e_ring *tx_ring = vsi->tx_rings[skb->queue_mapping];\r\nstruct i40e_tx_buffer *first;\r\nu32 tx_flags = 0;\r\nint fso, count;\r\nu8 hdr_len = 0;\r\nu8 sof = 0;\r\nu8 eof = 0;\r\nif (i40e_fcoe_set_skb_header(skb))\r\ngoto out_drop;\r\ncount = i40e_xmit_descriptor_count(skb);\r\nif (i40e_chk_linearize(skb, count)) {\r\nif (__skb_linearize(skb))\r\ngoto out_drop;\r\ncount = i40e_txd_use_count(skb->len);\r\ntx_ring->tx_stats.tx_linearize++;\r\n}\r\nif (i40e_maybe_stop_tx(tx_ring, count + 4 + 1)) {\r\ntx_ring->tx_stats.tx_busy++;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (i40e_tx_prepare_vlan_flags(skb, tx_ring, &tx_flags))\r\ngoto out_drop;\r\nfirst = &tx_ring->tx_bi[tx_ring->next_to_use];\r\nif (skb->protocol == htons(ETH_P_FIP))\r\ngoto out_send;\r\nif (i40e_fcoe_fc_sof(skb, &sof) || i40e_fcoe_fc_eof(skb, &eof)) {\r\nnetdev_err(netdev, "SOF/EOF error:%02x - %02x\n", sof, eof);\r\ngoto out_drop;\r\n}\r\ntx_flags |= I40E_TX_FLAGS_FCCRC;\r\nfso = i40e_fcoe_tso(tx_ring, skb, tx_flags, &hdr_len, sof);\r\nif (fso < 0)\r\ngoto out_drop;\r\nelse if (fso)\r\ntx_flags |= I40E_TX_FLAGS_FSO;\r\nelse\r\ni40e_fcoe_handle_ddp(tx_ring, skb, sof);\r\nout_send:\r\ni40e_fcoe_tx_map(tx_ring, skb, first, tx_flags, hdr_len, eof);\r\ni40e_maybe_stop_tx(tx_ring, DESC_NEEDED);\r\nreturn NETDEV_TX_OK;\r\nout_drop:\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int i40e_fcoe_change_mtu(struct net_device *netdev, int new_mtu)\r\n{\r\nnetdev_warn(netdev, "MTU change is not supported on FCoE interfaces\n");\r\nreturn -EPERM;\r\n}\r\nstatic int i40e_fcoe_set_features(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nstruct i40e_netdev_priv *np = netdev_priv(netdev);\r\nstruct i40e_vsi *vsi = np->vsi;\r\nif (features & NETIF_F_HW_VLAN_CTAG_RX)\r\ni40e_vlan_stripping_enable(vsi);\r\nelse\r\ni40e_vlan_stripping_disable(vsi);\r\nreturn 0;\r\n}\r\nvoid i40e_fcoe_config_netdev(struct net_device *netdev, struct i40e_vsi *vsi)\r\n{\r\nstruct i40e_hw *hw = &vsi->back->hw;\r\nstruct i40e_pf *pf = vsi->back;\r\nif (vsi->type != I40E_VSI_FCOE)\r\nreturn;\r\nnetdev->features = (NETIF_F_HW_VLAN_CTAG_TX |\r\nNETIF_F_HW_VLAN_CTAG_RX |\r\nNETIF_F_HW_VLAN_CTAG_FILTER);\r\nnetdev->vlan_features = netdev->features;\r\nnetdev->vlan_features &= ~(NETIF_F_HW_VLAN_CTAG_TX |\r\nNETIF_F_HW_VLAN_CTAG_RX |\r\nNETIF_F_HW_VLAN_CTAG_FILTER);\r\nnetdev->fcoe_ddp_xid = I40E_FCOE_DDP_MAX - 1;\r\nnetdev->features |= NETIF_F_ALL_FCOE;\r\nnetdev->vlan_features |= NETIF_F_ALL_FCOE;\r\nnetdev->hw_features |= netdev->features;\r\nnetdev->priv_flags |= IFF_UNICAST_FLT;\r\nnetdev->priv_flags |= IFF_SUPP_NOFCS;\r\nstrlcpy(netdev->name, "fcoe%d", IFNAMSIZ-1);\r\nnetdev->mtu = FCOE_MTU;\r\nSET_NETDEV_DEV(netdev, &pf->pdev->dev);\r\nSET_NETDEV_DEVTYPE(netdev, &fcoe_netdev_type);\r\nnetdev->dev_port = 1;\r\nspin_lock_bh(&vsi->mac_filter_hash_lock);\r\ni40e_add_filter(vsi, hw->mac.san_addr, 0);\r\ni40e_add_filter(vsi, (u8[6]) FC_FCOE_FLOGI_MAC, 0);\r\ni40e_add_filter(vsi, FIP_ALL_FCOE_MACS, 0);\r\ni40e_add_filter(vsi, FIP_ALL_ENODE_MACS, 0);\r\nspin_unlock_bh(&vsi->mac_filter_hash_lock);\r\nether_addr_copy(netdev->dev_addr, hw->mac.san_addr);\r\nether_addr_copy(netdev->perm_addr, hw->mac.san_addr);\r\nnetdev->netdev_ops = &i40e_fcoe_netdev_ops;\r\n}\r\nvoid i40e_fcoe_vsi_setup(struct i40e_pf *pf)\r\n{\r\nstruct i40e_vsi *vsi;\r\nu16 seid;\r\nint i;\r\nif (!(pf->flags & I40E_FLAG_FCOE_ENABLED))\r\nreturn;\r\nfor (i = 0; i < pf->num_alloc_vsi; i++) {\r\nvsi = pf->vsi[i];\r\nif (vsi && vsi->type == I40E_VSI_FCOE) {\r\ndev_warn(&pf->pdev->dev,\r\n"FCoE VSI already created\n");\r\nreturn;\r\n}\r\n}\r\nseid = pf->vsi[pf->lan_vsi]->seid;\r\nvsi = i40e_vsi_setup(pf, I40E_VSI_FCOE, seid, 0);\r\nif (vsi) {\r\ndev_dbg(&pf->pdev->dev,\r\n"Successfully created FCoE VSI seid %d id %d uplink_seid %d PF seid %d\n",\r\nvsi->seid, vsi->id, vsi->uplink_seid, seid);\r\n} else {\r\ndev_info(&pf->pdev->dev, "Failed to create FCoE VSI\n");\r\n}\r\n}
