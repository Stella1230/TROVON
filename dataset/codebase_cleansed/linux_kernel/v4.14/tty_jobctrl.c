static int is_ignored(int sig)\r\n{\r\nreturn (sigismember(&current->blocked, sig) ||\r\ncurrent->sighand->action[sig-1].sa.sa_handler == SIG_IGN);\r\n}\r\nint __tty_check_change(struct tty_struct *tty, int sig)\r\n{\r\nunsigned long flags;\r\nstruct pid *pgrp, *tty_pgrp;\r\nint ret = 0;\r\nif (current->signal->tty != tty)\r\nreturn 0;\r\nrcu_read_lock();\r\npgrp = task_pgrp(current);\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\ntty_pgrp = tty->pgrp;\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nif (tty_pgrp && pgrp != tty->pgrp) {\r\nif (is_ignored(sig)) {\r\nif (sig == SIGTTIN)\r\nret = -EIO;\r\n} else if (is_current_pgrp_orphaned())\r\nret = -EIO;\r\nelse {\r\nkill_pgrp(pgrp, sig, 1);\r\nset_thread_flag(TIF_SIGPENDING);\r\nret = -ERESTARTSYS;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (!tty_pgrp)\r\ntty_warn(tty, "sig=%d, tty->pgrp == NULL!\n", sig);\r\nreturn ret;\r\n}\r\nint tty_check_change(struct tty_struct *tty)\r\n{\r\nreturn __tty_check_change(tty, SIGTTOU);\r\n}\r\nvoid proc_clear_tty(struct task_struct *p)\r\n{\r\nunsigned long flags;\r\nstruct tty_struct *tty;\r\nspin_lock_irqsave(&p->sighand->siglock, flags);\r\ntty = p->signal->tty;\r\np->signal->tty = NULL;\r\nspin_unlock_irqrestore(&p->sighand->siglock, flags);\r\ntty_kref_put(tty);\r\n}\r\nstatic void __proc_set_tty(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\nput_pid(tty->session);\r\nput_pid(tty->pgrp);\r\ntty->pgrp = get_pid(task_pgrp(current));\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\ntty->session = get_pid(task_session(current));\r\nif (current->signal->tty) {\r\ntty_debug(tty, "current tty %s not NULL!!\n",\r\ncurrent->signal->tty->name);\r\ntty_kref_put(current->signal->tty);\r\n}\r\nput_pid(current->signal->tty_old_pgrp);\r\ncurrent->signal->tty = tty_kref_get(tty);\r\ncurrent->signal->tty_old_pgrp = NULL;\r\n}\r\nstatic void proc_set_tty(struct tty_struct *tty)\r\n{\r\nspin_lock_irq(&current->sighand->siglock);\r\n__proc_set_tty(tty);\r\nspin_unlock_irq(&current->sighand->siglock);\r\n}\r\nvoid tty_open_proc_set_tty(struct file *filp, struct tty_struct *tty)\r\n{\r\nread_lock(&tasklist_lock);\r\nspin_lock_irq(&current->sighand->siglock);\r\nif (current->signal->leader &&\r\n!current->signal->tty &&\r\ntty->session == NULL) {\r\nif (filp->f_mode & FMODE_READ)\r\n__proc_set_tty(tty);\r\n}\r\nspin_unlock_irq(&current->sighand->siglock);\r\nread_unlock(&tasklist_lock);\r\n}\r\nstruct tty_struct *get_current_tty(void)\r\n{\r\nstruct tty_struct *tty;\r\nunsigned long flags;\r\nspin_lock_irqsave(&current->sighand->siglock, flags);\r\ntty = tty_kref_get(current->signal->tty);\r\nspin_unlock_irqrestore(&current->sighand->siglock, flags);\r\nreturn tty;\r\n}\r\nvoid session_clear_tty(struct pid *session)\r\n{\r\nstruct task_struct *p;\r\ndo_each_pid_task(session, PIDTYPE_SID, p) {\r\nproc_clear_tty(p);\r\n} while_each_pid_task(session, PIDTYPE_SID, p);\r\n}\r\nint tty_signal_session_leader(struct tty_struct *tty, int exit_session)\r\n{\r\nstruct task_struct *p;\r\nint refs = 0;\r\nstruct pid *tty_pgrp = NULL;\r\nread_lock(&tasklist_lock);\r\nif (tty->session) {\r\ndo_each_pid_task(tty->session, PIDTYPE_SID, p) {\r\nspin_lock_irq(&p->sighand->siglock);\r\nif (p->signal->tty == tty) {\r\np->signal->tty = NULL;\r\nrefs++;\r\n}\r\nif (!p->signal->leader) {\r\nspin_unlock_irq(&p->sighand->siglock);\r\ncontinue;\r\n}\r\n__group_send_sig_info(SIGHUP, SEND_SIG_PRIV, p);\r\n__group_send_sig_info(SIGCONT, SEND_SIG_PRIV, p);\r\nput_pid(p->signal->tty_old_pgrp);\r\nspin_lock(&tty->ctrl_lock);\r\ntty_pgrp = get_pid(tty->pgrp);\r\nif (tty->pgrp)\r\np->signal->tty_old_pgrp = get_pid(tty->pgrp);\r\nspin_unlock(&tty->ctrl_lock);\r\nspin_unlock_irq(&p->sighand->siglock);\r\n} while_each_pid_task(tty->session, PIDTYPE_SID, p);\r\n}\r\nread_unlock(&tasklist_lock);\r\nif (tty_pgrp) {\r\nif (exit_session)\r\nkill_pgrp(tty_pgrp, SIGHUP, exit_session);\r\nput_pid(tty_pgrp);\r\n}\r\nreturn refs;\r\n}\r\nvoid disassociate_ctty(int on_exit)\r\n{\r\nstruct tty_struct *tty;\r\nif (!current->signal->leader)\r\nreturn;\r\ntty = get_current_tty();\r\nif (tty) {\r\nif (on_exit && tty->driver->type != TTY_DRIVER_TYPE_PTY) {\r\ntty_vhangup_session(tty);\r\n} else {\r\nstruct pid *tty_pgrp = tty_get_pgrp(tty);\r\nif (tty_pgrp) {\r\nkill_pgrp(tty_pgrp, SIGHUP, on_exit);\r\nif (!on_exit)\r\nkill_pgrp(tty_pgrp, SIGCONT, on_exit);\r\nput_pid(tty_pgrp);\r\n}\r\n}\r\ntty_kref_put(tty);\r\n} else if (on_exit) {\r\nstruct pid *old_pgrp;\r\nspin_lock_irq(&current->sighand->siglock);\r\nold_pgrp = current->signal->tty_old_pgrp;\r\ncurrent->signal->tty_old_pgrp = NULL;\r\nspin_unlock_irq(&current->sighand->siglock);\r\nif (old_pgrp) {\r\nkill_pgrp(old_pgrp, SIGHUP, on_exit);\r\nkill_pgrp(old_pgrp, SIGCONT, on_exit);\r\nput_pid(old_pgrp);\r\n}\r\nreturn;\r\n}\r\nspin_lock_irq(&current->sighand->siglock);\r\nput_pid(current->signal->tty_old_pgrp);\r\ncurrent->signal->tty_old_pgrp = NULL;\r\ntty = tty_kref_get(current->signal->tty);\r\nif (tty) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\nput_pid(tty->session);\r\nput_pid(tty->pgrp);\r\ntty->session = NULL;\r\ntty->pgrp = NULL;\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\ntty_kref_put(tty);\r\n}\r\nspin_unlock_irq(&current->sighand->siglock);\r\nread_lock(&tasklist_lock);\r\nsession_clear_tty(task_session(current));\r\nread_unlock(&tasklist_lock);\r\n}\r\nvoid no_tty(void)\r\n{\r\nstruct task_struct *tsk = current;\r\ndisassociate_ctty(0);\r\nproc_clear_tty(tsk);\r\n}\r\nstatic int tiocsctty(struct tty_struct *tty, struct file *file, int arg)\r\n{\r\nint ret = 0;\r\ntty_lock(tty);\r\nread_lock(&tasklist_lock);\r\nif (current->signal->leader && (task_session(current) == tty->session))\r\ngoto unlock;\r\nif (!current->signal->leader || current->signal->tty) {\r\nret = -EPERM;\r\ngoto unlock;\r\n}\r\nif (tty->session) {\r\nif (arg == 1 && capable(CAP_SYS_ADMIN)) {\r\nsession_clear_tty(tty->session);\r\n} else {\r\nret = -EPERM;\r\ngoto unlock;\r\n}\r\n}\r\nif ((file->f_mode & FMODE_READ) == 0 && !capable(CAP_SYS_ADMIN)) {\r\nret = -EPERM;\r\ngoto unlock;\r\n}\r\nproc_set_tty(tty);\r\nunlock:\r\nread_unlock(&tasklist_lock);\r\ntty_unlock(tty);\r\nreturn ret;\r\n}\r\nstruct pid *tty_get_pgrp(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nstruct pid *pgrp;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\npgrp = get_pid(tty->pgrp);\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nreturn pgrp;\r\n}\r\nstatic struct pid *session_of_pgrp(struct pid *pgrp)\r\n{\r\nstruct task_struct *p;\r\nstruct pid *sid = NULL;\r\np = pid_task(pgrp, PIDTYPE_PGID);\r\nif (p == NULL)\r\np = pid_task(pgrp, PIDTYPE_PID);\r\nif (p != NULL)\r\nsid = task_session(p);\r\nreturn sid;\r\n}\r\nstatic int tiocgpgrp(struct tty_struct *tty, struct tty_struct *real_tty, pid_t __user *p)\r\n{\r\nstruct pid *pid;\r\nint ret;\r\nif (tty == real_tty && current->signal->tty != real_tty)\r\nreturn -ENOTTY;\r\npid = tty_get_pgrp(real_tty);\r\nret = put_user(pid_vnr(pid), p);\r\nput_pid(pid);\r\nreturn ret;\r\n}\r\nstatic int tiocspgrp(struct tty_struct *tty, struct tty_struct *real_tty, pid_t __user *p)\r\n{\r\nstruct pid *pgrp;\r\npid_t pgrp_nr;\r\nint retval = tty_check_change(real_tty);\r\nif (retval == -EIO)\r\nreturn -ENOTTY;\r\nif (retval)\r\nreturn retval;\r\nif (!current->signal->tty ||\r\n(current->signal->tty != real_tty) ||\r\n(real_tty->session != task_session(current)))\r\nreturn -ENOTTY;\r\nif (get_user(pgrp_nr, p))\r\nreturn -EFAULT;\r\nif (pgrp_nr < 0)\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\npgrp = find_vpid(pgrp_nr);\r\nretval = -ESRCH;\r\nif (!pgrp)\r\ngoto out_unlock;\r\nretval = -EPERM;\r\nif (session_of_pgrp(pgrp) != task_session(current))\r\ngoto out_unlock;\r\nretval = 0;\r\nspin_lock_irq(&tty->ctrl_lock);\r\nput_pid(real_tty->pgrp);\r\nreal_tty->pgrp = get_pid(pgrp);\r\nspin_unlock_irq(&tty->ctrl_lock);\r\nout_unlock:\r\nrcu_read_unlock();\r\nreturn retval;\r\n}\r\nstatic int tiocgsid(struct tty_struct *tty, struct tty_struct *real_tty, pid_t __user *p)\r\n{\r\nif (tty == real_tty && current->signal->tty != real_tty)\r\nreturn -ENOTTY;\r\nif (!real_tty->session)\r\nreturn -ENOTTY;\r\nreturn put_user(pid_vnr(real_tty->session), p);\r\n}\r\nlong tty_jobctrl_ioctl(struct tty_struct *tty, struct tty_struct *real_tty,\r\nstruct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *p = (void __user *)arg;\r\nswitch (cmd) {\r\ncase TIOCNOTTY:\r\nif (current->signal->tty != tty)\r\nreturn -ENOTTY;\r\nno_tty();\r\nreturn 0;\r\ncase TIOCSCTTY:\r\nreturn tiocsctty(real_tty, file, arg);\r\ncase TIOCGPGRP:\r\nreturn tiocgpgrp(tty, real_tty, p);\r\ncase TIOCSPGRP:\r\nreturn tiocspgrp(tty, real_tty, p);\r\ncase TIOCGSID:\r\nreturn tiocgsid(tty, real_tty, p);\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}
