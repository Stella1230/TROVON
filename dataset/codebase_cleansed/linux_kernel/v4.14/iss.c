static void iss_print_status(struct iss_device *iss)\r\n{\r\ndev_dbg(iss->dev, "-------------ISS HL Register dump-------------\n");\r\nISS_PRINT_REGISTER(iss, HL_REVISION);\r\nISS_PRINT_REGISTER(iss, HL_SYSCONFIG);\r\nISS_PRINT_REGISTER(iss, HL_IRQSTATUS(5));\r\nISS_PRINT_REGISTER(iss, HL_IRQENABLE_SET(5));\r\nISS_PRINT_REGISTER(iss, HL_IRQENABLE_CLR(5));\r\nISS_PRINT_REGISTER(iss, CTRL);\r\nISS_PRINT_REGISTER(iss, CLKCTRL);\r\nISS_PRINT_REGISTER(iss, CLKSTAT);\r\ndev_dbg(iss->dev, "-----------------------------------------------\n");\r\n}\r\nstatic void omap4iss_flush(struct iss_device *iss)\r\n{\r\niss_reg_write(iss, OMAP4_ISS_MEM_TOP, ISS_HL_REVISION, 0);\r\niss_reg_read(iss, OMAP4_ISS_MEM_TOP, ISS_HL_REVISION);\r\n}\r\nstatic void omap4iss_isp_enable_interrupts(struct iss_device *iss)\r\n{\r\nstatic const u32 isp_irq = ISP5_IRQ_OCP_ERR |\r\nISP5_IRQ_RSZ_FIFO_IN_BLK_ERR |\r\nISP5_IRQ_RSZ_FIFO_OVF |\r\nISP5_IRQ_RSZ_INT_DMA |\r\nISP5_IRQ_ISIF_INT(0);\r\niss_reg_write(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_IRQSTATUS(0), isp_irq);\r\niss_reg_write(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_IRQENABLE_SET(0),\r\nisp_irq);\r\n}\r\nstatic void omap4iss_isp_disable_interrupts(struct iss_device *iss)\r\n{\r\niss_reg_write(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_IRQENABLE_CLR(0), ~0);\r\n}\r\nstatic void iss_enable_interrupts(struct iss_device *iss)\r\n{\r\nstatic const u32 hl_irq = ISS_HL_IRQ_CSIA | ISS_HL_IRQ_CSIB\r\n| ISS_HL_IRQ_ISP(0);\r\niss_reg_write(iss, OMAP4_ISS_MEM_TOP, ISS_HL_IRQSTATUS(5), hl_irq);\r\niss_reg_write(iss, OMAP4_ISS_MEM_TOP, ISS_HL_IRQENABLE_SET(5), hl_irq);\r\nif (iss->regs[OMAP4_ISS_MEM_ISP_SYS1])\r\nomap4iss_isp_enable_interrupts(iss);\r\n}\r\nstatic void iss_disable_interrupts(struct iss_device *iss)\r\n{\r\nif (iss->regs[OMAP4_ISS_MEM_ISP_SYS1])\r\nomap4iss_isp_disable_interrupts(iss);\r\niss_reg_write(iss, OMAP4_ISS_MEM_TOP, ISS_HL_IRQENABLE_CLR(5), ~0);\r\n}\r\nint omap4iss_get_external_info(struct iss_pipeline *pipe,\r\nstruct media_link *link)\r\n{\r\nstruct iss_device *iss =\r\ncontainer_of(pipe, struct iss_video, pipe)->iss;\r\nstruct v4l2_subdev_format fmt;\r\nstruct v4l2_ctrl *ctrl;\r\nint ret;\r\nif (!pipe->external)\r\nreturn 0;\r\nif (pipe->external_rate)\r\nreturn 0;\r\nmemset(&fmt, 0, sizeof(fmt));\r\nfmt.pad = link->source->index;\r\nfmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(media_entity_to_v4l2_subdev(link->sink->entity),\r\npad, get_fmt, NULL, &fmt);\r\nif (ret < 0)\r\nreturn -EPIPE;\r\npipe->external_bpp = omap4iss_video_format_info(fmt.format.code)->bpp;\r\nctrl = v4l2_ctrl_find(pipe->external->ctrl_handler,\r\nV4L2_CID_PIXEL_RATE);\r\nif (!ctrl) {\r\ndev_warn(iss->dev, "no pixel rate control in subdev %s\n",\r\npipe->external->name);\r\nreturn -EPIPE;\r\n}\r\npipe->external_rate = v4l2_ctrl_g_ctrl_int64(ctrl);\r\nreturn 0;\r\n}\r\nvoid omap4iss_configure_bridge(struct iss_device *iss,\r\nenum ipipeif_input_entity input)\r\n{\r\nu32 issctrl_val;\r\nu32 isp5ctrl_val;\r\nissctrl_val = iss_reg_read(iss, OMAP4_ISS_MEM_TOP, ISS_CTRL);\r\nissctrl_val &= ~ISS_CTRL_INPUT_SEL_MASK;\r\nissctrl_val &= ~ISS_CTRL_CLK_DIV_MASK;\r\nisp5ctrl_val = iss_reg_read(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_CTRL);\r\nswitch (input) {\r\ncase IPIPEIF_INPUT_CSI2A:\r\nissctrl_val |= ISS_CTRL_INPUT_SEL_CSI2A;\r\nbreak;\r\ncase IPIPEIF_INPUT_CSI2B:\r\nissctrl_val |= ISS_CTRL_INPUT_SEL_CSI2B;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nissctrl_val |= ISS_CTRL_SYNC_DETECT_VS_RAISING;\r\nisp5ctrl_val |= ISP5_CTRL_VD_PULSE_EXT | ISP5_CTRL_PSYNC_CLK_SEL |\r\nISP5_CTRL_SYNC_ENABLE;\r\niss_reg_write(iss, OMAP4_ISS_MEM_TOP, ISS_CTRL, issctrl_val);\r\niss_reg_write(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_CTRL, isp5ctrl_val);\r\n}\r\nstatic void iss_isr_dbg(struct iss_device *iss, u32 irqstatus)\r\n{\r\nstatic const char * const name[] = {\r\n"ISP_0",\r\n"ISP_1",\r\n"ISP_2",\r\n"ISP_3",\r\n"CSIA",\r\n"CSIB",\r\n"CCP2_0",\r\n"CCP2_1",\r\n"CCP2_2",\r\n"CCP2_3",\r\n"CBUFF",\r\n"BTE",\r\n"SIMCOP_0",\r\n"SIMCOP_1",\r\n"SIMCOP_2",\r\n"SIMCOP_3",\r\n"CCP2_8",\r\n"HS_VS",\r\n"18",\r\n"19",\r\n"20",\r\n"21",\r\n"22",\r\n"23",\r\n"24",\r\n"25",\r\n"26",\r\n"27",\r\n"28",\r\n"29",\r\n"30",\r\n"31",\r\n};\r\nunsigned int i;\r\ndev_dbg(iss->dev, "ISS IRQ: ");\r\nfor (i = 0; i < ARRAY_SIZE(name); i++) {\r\nif ((1 << i) & irqstatus)\r\npr_cont("%s ", name[i]);\r\n}\r\npr_cont("\n");\r\n}\r\nstatic void iss_isp_isr_dbg(struct iss_device *iss, u32 irqstatus)\r\n{\r\nstatic const char * const name[] = {\r\n"ISIF_0",\r\n"ISIF_1",\r\n"ISIF_2",\r\n"ISIF_3",\r\n"IPIPEREQ",\r\n"IPIPELAST_PIX",\r\n"IPIPEDMA",\r\n"IPIPEBSC",\r\n"IPIPEHST",\r\n"IPIPEIF",\r\n"AEW",\r\n"AF",\r\n"H3A",\r\n"RSZ_REG",\r\n"RSZ_LAST_PIX",\r\n"RSZ_DMA",\r\n"RSZ_CYC_RZA",\r\n"RSZ_CYC_RZB",\r\n"RSZ_FIFO_OVF",\r\n"RSZ_FIFO_IN_BLK_ERR",\r\n"20",\r\n"21",\r\n"RSZ_EOF0",\r\n"RSZ_EOF1",\r\n"H3A_EOF",\r\n"IPIPE_EOF",\r\n"26",\r\n"IPIPE_DPC_INI",\r\n"IPIPE_DPC_RNEW0",\r\n"IPIPE_DPC_RNEW1",\r\n"30",\r\n"OCP_ERR",\r\n};\r\nunsigned int i;\r\ndev_dbg(iss->dev, "ISP IRQ: ");\r\nfor (i = 0; i < ARRAY_SIZE(name); i++) {\r\nif ((1 << i) & irqstatus)\r\npr_cont("%s ", name[i]);\r\n}\r\npr_cont("\n");\r\n}\r\nstatic irqreturn_t iss_isr(int irq, void *_iss)\r\n{\r\nstatic const u32 ipipeif_events = ISP5_IRQ_IPIPEIF_IRQ |\r\nISP5_IRQ_ISIF_INT(0);\r\nstatic const u32 resizer_events = ISP5_IRQ_RSZ_FIFO_IN_BLK_ERR |\r\nISP5_IRQ_RSZ_FIFO_OVF |\r\nISP5_IRQ_RSZ_INT_DMA;\r\nstruct iss_device *iss = _iss;\r\nu32 irqstatus;\r\nirqstatus = iss_reg_read(iss, OMAP4_ISS_MEM_TOP, ISS_HL_IRQSTATUS(5));\r\niss_reg_write(iss, OMAP4_ISS_MEM_TOP, ISS_HL_IRQSTATUS(5), irqstatus);\r\nif (irqstatus & ISS_HL_IRQ_CSIA)\r\nomap4iss_csi2_isr(&iss->csi2a);\r\nif (irqstatus & ISS_HL_IRQ_CSIB)\r\nomap4iss_csi2_isr(&iss->csi2b);\r\nif (irqstatus & ISS_HL_IRQ_ISP(0)) {\r\nu32 isp_irqstatus = iss_reg_read(iss, OMAP4_ISS_MEM_ISP_SYS1,\r\nISP5_IRQSTATUS(0));\r\niss_reg_write(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_IRQSTATUS(0),\r\nisp_irqstatus);\r\nif (isp_irqstatus & ISP5_IRQ_OCP_ERR)\r\ndev_dbg(iss->dev, "ISP5 OCP Error!\n");\r\nif (isp_irqstatus & ipipeif_events) {\r\nomap4iss_ipipeif_isr(&iss->ipipeif,\r\nisp_irqstatus & ipipeif_events);\r\n}\r\nif (isp_irqstatus & resizer_events)\r\nomap4iss_resizer_isr(&iss->resizer,\r\nisp_irqstatus & resizer_events);\r\n#ifdef ISS_ISR_DEBUG\r\niss_isp_isr_dbg(iss, isp_irqstatus);\r\n#endif\r\n}\r\nomap4iss_flush(iss);\r\n#ifdef ISS_ISR_DEBUG\r\niss_isr_dbg(iss, irqstatus);\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int iss_pipeline_disable(struct iss_pipeline *pipe,\r\nstruct media_entity *until)\r\n{\r\nstruct iss_device *iss = pipe->output->iss;\r\nstruct media_entity *entity;\r\nstruct media_pad *pad;\r\nstruct v4l2_subdev *subdev;\r\nint failure = 0;\r\nint ret;\r\nentity = &pipe->output->video.entity;\r\nwhile (1) {\r\npad = &entity->pads[0];\r\nif (!(pad->flags & MEDIA_PAD_FL_SINK))\r\nbreak;\r\npad = media_entity_remote_pad(pad);\r\nif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\r\nbreak;\r\nentity = pad->entity;\r\nif (entity == until)\r\nbreak;\r\nsubdev = media_entity_to_v4l2_subdev(entity);\r\nret = v4l2_subdev_call(subdev, video, s_stream, 0);\r\nif (ret < 0) {\r\ndev_warn(iss->dev, "%s: module stop timeout.\n",\r\nsubdev->name);\r\nmedia_entity_enum_set(&iss->crashed, &subdev->entity);\r\nfailure = -ETIMEDOUT;\r\n}\r\n}\r\nreturn failure;\r\n}\r\nstatic int iss_pipeline_enable(struct iss_pipeline *pipe,\r\nenum iss_pipeline_stream_state mode)\r\n{\r\nstruct iss_device *iss = pipe->output->iss;\r\nstruct media_entity *entity;\r\nstruct media_pad *pad;\r\nstruct v4l2_subdev *subdev;\r\nunsigned long flags;\r\nint ret;\r\nif (media_entity_enum_intersects(&pipe->ent_enum, &iss->crashed))\r\nreturn -EIO;\r\nspin_lock_irqsave(&pipe->lock, flags);\r\npipe->state &= ~(ISS_PIPELINE_IDLE_INPUT | ISS_PIPELINE_IDLE_OUTPUT);\r\nspin_unlock_irqrestore(&pipe->lock, flags);\r\npipe->do_propagation = false;\r\nentity = &pipe->output->video.entity;\r\nwhile (1) {\r\npad = &entity->pads[0];\r\nif (!(pad->flags & MEDIA_PAD_FL_SINK))\r\nbreak;\r\npad = media_entity_remote_pad(pad);\r\nif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\r\nbreak;\r\nentity = pad->entity;\r\nsubdev = media_entity_to_v4l2_subdev(entity);\r\nret = v4l2_subdev_call(subdev, video, s_stream, mode);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\niss_pipeline_disable(pipe, entity);\r\nreturn ret;\r\n}\r\nif (subdev == &iss->csi2a.subdev ||\r\nsubdev == &iss->csi2b.subdev)\r\npipe->do_propagation = true;\r\n}\r\niss_print_status(pipe->output->iss);\r\nreturn 0;\r\n}\r\nint omap4iss_pipeline_set_stream(struct iss_pipeline *pipe,\r\nenum iss_pipeline_stream_state state)\r\n{\r\nint ret;\r\nif (state == ISS_PIPELINE_STREAM_STOPPED)\r\nret = iss_pipeline_disable(pipe, NULL);\r\nelse\r\nret = iss_pipeline_enable(pipe, state);\r\nif (ret == 0 || state == ISS_PIPELINE_STREAM_STOPPED)\r\npipe->stream_state = state;\r\nreturn ret;\r\n}\r\nvoid omap4iss_pipeline_cancel_stream(struct iss_pipeline *pipe)\r\n{\r\nif (pipe->input)\r\nomap4iss_video_cancel_stream(pipe->input);\r\nif (pipe->output)\r\nomap4iss_video_cancel_stream(pipe->output);\r\n}\r\nstatic int iss_pipeline_is_last(struct media_entity *me)\r\n{\r\nstruct iss_pipeline *pipe;\r\nstruct media_pad *pad;\r\nif (!me->pipe)\r\nreturn 0;\r\npipe = to_iss_pipeline(me);\r\nif (pipe->stream_state == ISS_PIPELINE_STREAM_STOPPED)\r\nreturn 0;\r\npad = media_entity_remote_pad(&pipe->output->pad);\r\nreturn pad->entity == me;\r\n}\r\nstatic int iss_reset(struct iss_device *iss)\r\n{\r\nunsigned int timeout;\r\niss_reg_set(iss, OMAP4_ISS_MEM_TOP, ISS_HL_SYSCONFIG,\r\nISS_HL_SYSCONFIG_SOFTRESET);\r\ntimeout = iss_poll_condition_timeout(\r\n!(iss_reg_read(iss, OMAP4_ISS_MEM_TOP, ISS_HL_SYSCONFIG) &\r\nISS_HL_SYSCONFIG_SOFTRESET), 1000, 10, 100);\r\nif (timeout) {\r\ndev_err(iss->dev, "ISS reset timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmedia_entity_enum_zero(&iss->crashed);\r\nreturn 0;\r\n}\r\nstatic int iss_isp_reset(struct iss_device *iss)\r\n{\r\nunsigned int timeout;\r\niss_reg_update(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_SYSCONFIG,\r\nISP5_SYSCONFIG_STANDBYMODE_MASK,\r\nISP5_SYSCONFIG_STANDBYMODE_SMART);\r\niss_reg_set(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_CTRL, ISP5_CTRL_MSTANDBY);\r\ntimeout = iss_poll_condition_timeout(\r\niss_reg_read(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_CTRL) &\r\nISP5_CTRL_MSTANDBY_WAIT, 1000000, 1000, 1500);\r\nif (timeout) {\r\ndev_err(iss->dev, "ISP5 standby timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\niss_reg_set(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_SYSCONFIG,\r\nISP5_SYSCONFIG_SOFTRESET);\r\ntimeout = iss_poll_condition_timeout(\r\n!(iss_reg_read(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_SYSCONFIG) &\r\nISP5_SYSCONFIG_SOFTRESET), 1000000, 1000, 1500);\r\nif (timeout) {\r\ndev_err(iss->dev, "ISP5 reset timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nint omap4iss_module_sync_idle(struct media_entity *me, wait_queue_head_t *wait,\r\natomic_t *stopping)\r\n{\r\nstruct iss_pipeline *pipe = to_iss_pipeline(me);\r\nstruct iss_video *video = pipe->output;\r\nunsigned long flags;\r\nif (pipe->stream_state == ISS_PIPELINE_STREAM_STOPPED ||\r\n(pipe->stream_state == ISS_PIPELINE_STREAM_SINGLESHOT &&\r\n!iss_pipeline_ready(pipe)))\r\nreturn 0;\r\natomic_set(stopping, 1);\r\nsmp_wmb();\r\nif (!iss_pipeline_is_last(me))\r\nreturn 0;\r\nspin_lock_irqsave(&video->qlock, flags);\r\nif (video->dmaqueue_flags & ISS_VIDEO_DMAQUEUE_UNDERRUN) {\r\nspin_unlock_irqrestore(&video->qlock, flags);\r\natomic_set(stopping, 0);\r\nsmp_wmb();\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&video->qlock, flags);\r\nif (!wait_event_timeout(*wait, !atomic_read(stopping),\r\nmsecs_to_jiffies(1000))) {\r\natomic_set(stopping, 0);\r\nsmp_wmb();\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nint omap4iss_module_sync_is_stopping(wait_queue_head_t *wait,\r\natomic_t *stopping)\r\n{\r\nif (atomic_cmpxchg(stopping, 1, 0)) {\r\nwake_up(wait);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __iss_subclk_update(struct iss_device *iss)\r\n{\r\nu32 clk = 0;\r\nint ret = 0, timeout = 1000;\r\nif (iss->subclk_resources & OMAP4_ISS_SUBCLK_CSI2_A)\r\nclk |= ISS_CLKCTRL_CSI2_A;\r\nif (iss->subclk_resources & OMAP4_ISS_SUBCLK_CSI2_B)\r\nclk |= ISS_CLKCTRL_CSI2_B;\r\nif (iss->subclk_resources & OMAP4_ISS_SUBCLK_ISP)\r\nclk |= ISS_CLKCTRL_ISP;\r\niss_reg_update(iss, OMAP4_ISS_MEM_TOP, ISS_CLKCTRL,\r\nISS_CLKCTRL_MASK, clk);\r\nwhile (--timeout > 0) {\r\nudelay(1);\r\nif ((iss_reg_read(iss, OMAP4_ISS_MEM_TOP, ISS_CLKSTAT) &\r\nISS_CLKCTRL_MASK) == clk)\r\nbreak;\r\n}\r\nif (!timeout)\r\nret = -EBUSY;\r\nreturn ret;\r\n}\r\nint omap4iss_subclk_enable(struct iss_device *iss,\r\nenum iss_subclk_resource res)\r\n{\r\niss->subclk_resources |= res;\r\nreturn __iss_subclk_update(iss);\r\n}\r\nint omap4iss_subclk_disable(struct iss_device *iss,\r\nenum iss_subclk_resource res)\r\n{\r\niss->subclk_resources &= ~res;\r\nreturn __iss_subclk_update(iss);\r\n}\r\nstatic void __iss_isp_subclk_update(struct iss_device *iss)\r\n{\r\nu32 clk = 0;\r\nif (iss->isp_subclk_resources & OMAP4_ISS_ISP_SUBCLK_ISIF)\r\nclk |= ISP5_CTRL_ISIF_CLK_ENABLE;\r\nif (iss->isp_subclk_resources & OMAP4_ISS_ISP_SUBCLK_H3A)\r\nclk |= ISP5_CTRL_H3A_CLK_ENABLE;\r\nif (iss->isp_subclk_resources & OMAP4_ISS_ISP_SUBCLK_RSZ)\r\nclk |= ISP5_CTRL_RSZ_CLK_ENABLE;\r\nif (iss->isp_subclk_resources & OMAP4_ISS_ISP_SUBCLK_IPIPE)\r\nclk |= ISP5_CTRL_IPIPE_CLK_ENABLE;\r\nif (iss->isp_subclk_resources & OMAP4_ISS_ISP_SUBCLK_IPIPEIF)\r\nclk |= ISP5_CTRL_IPIPEIF_CLK_ENABLE;\r\nif (clk)\r\nclk |= ISP5_CTRL_BL_CLK_ENABLE;\r\niss_reg_update(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_CTRL,\r\nISS_ISP5_CLKCTRL_MASK, clk);\r\n}\r\nvoid omap4iss_isp_subclk_enable(struct iss_device *iss,\r\nenum iss_isp_subclk_resource res)\r\n{\r\niss->isp_subclk_resources |= res;\r\n__iss_isp_subclk_update(iss);\r\n}\r\nvoid omap4iss_isp_subclk_disable(struct iss_device *iss,\r\nenum iss_isp_subclk_resource res)\r\n{\r\niss->isp_subclk_resources &= ~res;\r\n__iss_isp_subclk_update(iss);\r\n}\r\nstatic int iss_enable_clocks(struct iss_device *iss)\r\n{\r\nint ret;\r\nret = clk_enable(iss->iss_fck);\r\nif (ret) {\r\ndev_err(iss->dev, "clk_enable iss_fck failed\n");\r\nreturn ret;\r\n}\r\nret = clk_enable(iss->iss_ctrlclk);\r\nif (ret) {\r\ndev_err(iss->dev, "clk_enable iss_ctrlclk failed\n");\r\nclk_disable(iss->iss_fck);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void iss_disable_clocks(struct iss_device *iss)\r\n{\r\nclk_disable(iss->iss_ctrlclk);\r\nclk_disable(iss->iss_fck);\r\n}\r\nstatic int iss_get_clocks(struct iss_device *iss)\r\n{\r\niss->iss_fck = devm_clk_get(iss->dev, "iss_fck");\r\nif (IS_ERR(iss->iss_fck)) {\r\ndev_err(iss->dev, "Unable to get iss_fck clock info\n");\r\nreturn PTR_ERR(iss->iss_fck);\r\n}\r\niss->iss_ctrlclk = devm_clk_get(iss->dev, "iss_ctrlclk");\r\nif (IS_ERR(iss->iss_ctrlclk)) {\r\ndev_err(iss->dev, "Unable to get iss_ctrlclk clock info\n");\r\nreturn PTR_ERR(iss->iss_ctrlclk);\r\n}\r\nreturn 0;\r\n}\r\nstruct iss_device *omap4iss_get(struct iss_device *iss)\r\n{\r\nstruct iss_device *__iss = iss;\r\nif (!iss)\r\nreturn NULL;\r\nmutex_lock(&iss->iss_mutex);\r\nif (iss->ref_count > 0)\r\ngoto out;\r\nif (iss_enable_clocks(iss) < 0) {\r\n__iss = NULL;\r\ngoto out;\r\n}\r\niss_enable_interrupts(iss);\r\nout:\r\nif (__iss)\r\niss->ref_count++;\r\nmutex_unlock(&iss->iss_mutex);\r\nreturn __iss;\r\n}\r\nvoid omap4iss_put(struct iss_device *iss)\r\n{\r\nif (!iss)\r\nreturn;\r\nmutex_lock(&iss->iss_mutex);\r\nBUG_ON(iss->ref_count == 0);\r\nif (--iss->ref_count == 0) {\r\niss_disable_interrupts(iss);\r\nif (!media_entity_enum_empty(&iss->crashed))\r\niss_reset(iss);\r\niss_disable_clocks(iss);\r\n}\r\nmutex_unlock(&iss->iss_mutex);\r\n}\r\nstatic int iss_map_mem_resource(struct platform_device *pdev,\r\nstruct iss_device *iss,\r\nenum iss_mem_resources res)\r\n{\r\nstruct resource *mem;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, res);\r\niss->regs[res] = devm_ioremap_resource(iss->dev, mem);\r\nreturn PTR_ERR_OR_ZERO(iss->regs[res]);\r\n}\r\nstatic void iss_unregister_entities(struct iss_device *iss)\r\n{\r\nomap4iss_resizer_unregister_entities(&iss->resizer);\r\nomap4iss_ipipe_unregister_entities(&iss->ipipe);\r\nomap4iss_ipipeif_unregister_entities(&iss->ipipeif);\r\nomap4iss_csi2_unregister_entities(&iss->csi2a);\r\nomap4iss_csi2_unregister_entities(&iss->csi2b);\r\nv4l2_device_unregister(&iss->v4l2_dev);\r\nmedia_device_unregister(&iss->media_dev);\r\n}\r\nstatic struct v4l2_subdev *\r\niss_register_subdev_group(struct iss_device *iss,\r\nstruct iss_subdev_i2c_board_info *board_info)\r\n{\r\nstruct v4l2_subdev *sensor = NULL;\r\nunsigned int first;\r\nif (!board_info->board_info)\r\nreturn NULL;\r\nfor (first = 1; board_info->board_info; ++board_info, first = 0) {\r\nstruct v4l2_subdev *subdev;\r\nstruct i2c_adapter *adapter;\r\nadapter = i2c_get_adapter(board_info->i2c_adapter_id);\r\nif (!adapter) {\r\ndev_err(iss->dev,\r\n"%s: Unable to get I2C adapter %d for device %s\n",\r\n__func__, board_info->i2c_adapter_id,\r\nboard_info->board_info->type);\r\ncontinue;\r\n}\r\nsubdev = v4l2_i2c_new_subdev_board(&iss->v4l2_dev, adapter,\r\nboard_info->board_info, NULL);\r\nif (!subdev) {\r\ndev_err(iss->dev, "Unable to register subdev %s\n",\r\nboard_info->board_info->type);\r\ncontinue;\r\n}\r\nif (first)\r\nsensor = subdev;\r\n}\r\nreturn sensor;\r\n}\r\nstatic int iss_register_entities(struct iss_device *iss)\r\n{\r\nstruct iss_platform_data *pdata = iss->pdata;\r\nstruct iss_v4l2_subdevs_group *subdevs;\r\nint ret;\r\niss->media_dev.dev = iss->dev;\r\nstrlcpy(iss->media_dev.model, "TI OMAP4 ISS",\r\nsizeof(iss->media_dev.model));\r\niss->media_dev.hw_revision = iss->revision;\r\niss->media_dev.ops = &iss_media_ops;\r\nret = media_device_register(&iss->media_dev);\r\nif (ret < 0) {\r\ndev_err(iss->dev, "Media device registration failed (%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\niss->v4l2_dev.mdev = &iss->media_dev;\r\nret = v4l2_device_register(iss->dev, &iss->v4l2_dev);\r\nif (ret < 0) {\r\ndev_err(iss->dev, "V4L2 device registration failed (%d)\n",\r\nret);\r\ngoto done;\r\n}\r\nret = omap4iss_csi2_register_entities(&iss->csi2a, &iss->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap4iss_csi2_register_entities(&iss->csi2b, &iss->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap4iss_ipipeif_register_entities(&iss->ipipeif, &iss->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap4iss_ipipe_register_entities(&iss->ipipe, &iss->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap4iss_resizer_register_entities(&iss->resizer, &iss->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nfor (subdevs = pdata->subdevs; subdevs && subdevs->subdevs; ++subdevs) {\r\nstruct v4l2_subdev *sensor;\r\nstruct media_entity *input;\r\nunsigned int flags;\r\nunsigned int pad;\r\nsensor = iss_register_subdev_group(iss, subdevs->subdevs);\r\nif (!sensor)\r\ncontinue;\r\nsensor->host_priv = subdevs;\r\nswitch (subdevs->interface) {\r\ncase ISS_INTERFACE_CSI2A_PHY1:\r\ninput = &iss->csi2a.subdev.entity;\r\npad = CSI2_PAD_SINK;\r\nflags = MEDIA_LNK_FL_IMMUTABLE\r\n| MEDIA_LNK_FL_ENABLED;\r\nbreak;\r\ncase ISS_INTERFACE_CSI2B_PHY2:\r\ninput = &iss->csi2b.subdev.entity;\r\npad = CSI2_PAD_SINK;\r\nflags = MEDIA_LNK_FL_IMMUTABLE\r\n| MEDIA_LNK_FL_ENABLED;\r\nbreak;\r\ndefault:\r\ndev_err(iss->dev, "invalid interface type %u\n",\r\nsubdevs->interface);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nret = media_create_pad_link(&sensor->entity, 0, input, pad,\r\nflags);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nret = v4l2_device_register_subdev_nodes(&iss->v4l2_dev);\r\ndone:\r\nif (ret < 0)\r\niss_unregister_entities(iss);\r\nreturn ret;\r\n}\r\nstatic int iss_create_links(struct iss_device *iss)\r\n{\r\nint ret;\r\nret = omap4iss_csi2_create_links(iss);\r\nif (ret < 0) {\r\ndev_err(iss->dev, "CSI2 pads links creation failed\n");\r\nreturn ret;\r\n}\r\nret = omap4iss_ipipeif_create_links(iss);\r\nif (ret < 0) {\r\ndev_err(iss->dev, "ISP IPIPEIF pads links creation failed\n");\r\nreturn ret;\r\n}\r\nret = omap4iss_resizer_create_links(iss);\r\nif (ret < 0) {\r\ndev_err(iss->dev, "ISP RESIZER pads links creation failed\n");\r\nreturn ret;\r\n}\r\nret = media_create_pad_link(\r\n&iss->csi2a.subdev.entity, CSI2_PAD_SOURCE,\r\n&iss->ipipeif.subdev.entity, IPIPEIF_PAD_SINK, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = media_create_pad_link(\r\n&iss->csi2b.subdev.entity, CSI2_PAD_SOURCE,\r\n&iss->ipipeif.subdev.entity, IPIPEIF_PAD_SINK, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = media_create_pad_link(\r\n&iss->ipipeif.subdev.entity, IPIPEIF_PAD_SOURCE_VP,\r\n&iss->resizer.subdev.entity, RESIZER_PAD_SINK, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = media_create_pad_link(\r\n&iss->ipipeif.subdev.entity, IPIPEIF_PAD_SOURCE_VP,\r\n&iss->ipipe.subdev.entity, IPIPE_PAD_SINK, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = media_create_pad_link(\r\n&iss->ipipe.subdev.entity, IPIPE_PAD_SOURCE_VP,\r\n&iss->resizer.subdev.entity, RESIZER_PAD_SINK, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void iss_cleanup_modules(struct iss_device *iss)\r\n{\r\nomap4iss_csi2_cleanup(iss);\r\nomap4iss_ipipeif_cleanup(iss);\r\nomap4iss_ipipe_cleanup(iss);\r\nomap4iss_resizer_cleanup(iss);\r\n}\r\nstatic int iss_initialize_modules(struct iss_device *iss)\r\n{\r\nint ret;\r\nret = omap4iss_csiphy_init(iss);\r\nif (ret < 0) {\r\ndev_err(iss->dev, "CSI PHY initialization failed\n");\r\ngoto error_csiphy;\r\n}\r\nret = omap4iss_csi2_init(iss);\r\nif (ret < 0) {\r\ndev_err(iss->dev, "CSI2 initialization failed\n");\r\ngoto error_csi2;\r\n}\r\nret = omap4iss_ipipeif_init(iss);\r\nif (ret < 0) {\r\ndev_err(iss->dev, "ISP IPIPEIF initialization failed\n");\r\ngoto error_ipipeif;\r\n}\r\nret = omap4iss_ipipe_init(iss);\r\nif (ret < 0) {\r\ndev_err(iss->dev, "ISP IPIPE initialization failed\n");\r\ngoto error_ipipe;\r\n}\r\nret = omap4iss_resizer_init(iss);\r\nif (ret < 0) {\r\ndev_err(iss->dev, "ISP RESIZER initialization failed\n");\r\ngoto error_resizer;\r\n}\r\nreturn 0;\r\nerror_resizer:\r\nomap4iss_ipipe_cleanup(iss);\r\nerror_ipipe:\r\nomap4iss_ipipeif_cleanup(iss);\r\nerror_ipipeif:\r\nomap4iss_csi2_cleanup(iss);\r\nerror_csi2:\r\nerror_csiphy:\r\nreturn ret;\r\n}\r\nstatic int iss_probe(struct platform_device *pdev)\r\n{\r\nstruct iss_platform_data *pdata = pdev->dev.platform_data;\r\nstruct iss_device *iss;\r\nunsigned int i;\r\nint ret;\r\nif (!pdata)\r\nreturn -EINVAL;\r\niss = devm_kzalloc(&pdev->dev, sizeof(*iss), GFP_KERNEL);\r\nif (!iss)\r\nreturn -ENOMEM;\r\nmutex_init(&iss->iss_mutex);\r\niss->dev = &pdev->dev;\r\niss->pdata = pdata;\r\niss->raw_dmamask = DMA_BIT_MASK(32);\r\niss->dev->dma_mask = &iss->raw_dmamask;\r\niss->dev->coherent_dma_mask = DMA_BIT_MASK(32);\r\nplatform_set_drvdata(pdev, iss);\r\niss->syscon = syscon_regmap_lookup_by_compatible("syscon");\r\nif (IS_ERR(iss->syscon)) {\r\nret = PTR_ERR(iss->syscon);\r\ngoto error;\r\n}\r\nret = iss_map_mem_resource(pdev, iss, OMAP4_ISS_MEM_TOP);\r\nif (ret < 0)\r\ngoto error;\r\nret = iss_get_clocks(iss);\r\nif (ret < 0)\r\ngoto error;\r\nif (!omap4iss_get(iss))\r\ngoto error;\r\nret = iss_reset(iss);\r\nif (ret < 0)\r\ngoto error_iss;\r\niss->revision = iss_reg_read(iss, OMAP4_ISS_MEM_TOP, ISS_HL_REVISION);\r\ndev_info(iss->dev, "Revision %08x found\n", iss->revision);\r\nfor (i = 1; i < OMAP4_ISS_MEM_LAST; i++) {\r\nret = iss_map_mem_resource(pdev, iss, i);\r\nif (ret)\r\ngoto error_iss;\r\n}\r\niss_reg_update(iss, OMAP4_ISS_MEM_BTE, BTE_CTRL,\r\nBTE_CTRL_BW_LIMITER_MASK,\r\n18 << BTE_CTRL_BW_LIMITER_SHIFT);\r\nret = omap4iss_subclk_enable(iss, OMAP4_ISS_SUBCLK_ISP);\r\nif (ret < 0)\r\ngoto error_iss;\r\nret = iss_isp_reset(iss);\r\nif (ret < 0)\r\ngoto error_iss;\r\ndev_info(iss->dev, "ISP Revision %08x found\n",\r\niss_reg_read(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_REVISION));\r\nret = platform_get_irq(pdev, 0);\r\nif (ret <= 0) {\r\ndev_err(iss->dev, "No IRQ resource\n");\r\nret = -ENODEV;\r\ngoto error_iss;\r\n}\r\niss->irq_num = ret;\r\nif (devm_request_irq(iss->dev, iss->irq_num, iss_isr, IRQF_SHARED,\r\n"OMAP4 ISS", iss)) {\r\ndev_err(iss->dev, "Unable to request IRQ\n");\r\nret = -EINVAL;\r\ngoto error_iss;\r\n}\r\nret = iss_initialize_modules(iss);\r\nif (ret < 0)\r\ngoto error_iss;\r\nret = iss_register_entities(iss);\r\nif (ret < 0)\r\ngoto error_modules;\r\nret = media_entity_enum_init(&iss->crashed, &iss->media_dev);\r\nif (ret)\r\ngoto error_entities;\r\nret = iss_create_links(iss);\r\nif (ret < 0)\r\ngoto error_entities;\r\nomap4iss_put(iss);\r\nreturn 0;\r\nerror_entities:\r\niss_unregister_entities(iss);\r\nmedia_entity_enum_cleanup(&iss->crashed);\r\nerror_modules:\r\niss_cleanup_modules(iss);\r\nerror_iss:\r\nomap4iss_put(iss);\r\nerror:\r\nmutex_destroy(&iss->iss_mutex);\r\nreturn ret;\r\n}\r\nstatic int iss_remove(struct platform_device *pdev)\r\n{\r\nstruct iss_device *iss = platform_get_drvdata(pdev);\r\niss_unregister_entities(iss);\r\nmedia_entity_enum_cleanup(&iss->crashed);\r\niss_cleanup_modules(iss);\r\nreturn 0;\r\n}
