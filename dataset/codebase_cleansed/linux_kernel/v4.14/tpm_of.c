int tpm_read_log_of(struct tpm_chip *chip)\r\n{\r\nstruct device_node *np;\r\nconst u32 *sizep;\r\nconst u64 *basep;\r\nstruct tpm_bios_log *log;\r\nu32 size;\r\nu64 base;\r\nlog = &chip->log;\r\nif (chip->dev.parent && chip->dev.parent->of_node)\r\nnp = chip->dev.parent->of_node;\r\nelse\r\nreturn -ENODEV;\r\nif (of_property_read_bool(np, "powered-while-suspended"))\r\nchip->flags |= TPM_CHIP_FLAG_ALWAYS_POWERED;\r\nsizep = of_get_property(np, "linux,sml-size", NULL);\r\nbasep = of_get_property(np, "linux,sml-base", NULL);\r\nif (sizep == NULL && basep == NULL)\r\nreturn -ENODEV;\r\nif (sizep == NULL || basep == NULL)\r\nreturn -EIO;\r\nif (of_property_match_string(np, "compatible", "IBM,vtpm") < 0) {\r\nsize = be32_to_cpup(sizep);\r\nbase = be64_to_cpup(basep);\r\n} else {\r\nsize = *sizep;\r\nbase = *basep;\r\n}\r\nif (size == 0) {\r\ndev_warn(&chip->dev, "%s: Event log area empty\n", __func__);\r\nreturn -EIO;\r\n}\r\nlog->bios_event_log = kmalloc(size, GFP_KERNEL);\r\nif (!log->bios_event_log)\r\nreturn -ENOMEM;\r\nlog->bios_event_log_end = log->bios_event_log + size;\r\nmemcpy(log->bios_event_log, __va(base), size);\r\nreturn 0;\r\n}
