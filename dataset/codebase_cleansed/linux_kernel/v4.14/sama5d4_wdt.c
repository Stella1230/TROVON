static void wdt_write(struct sama5d4_wdt *wdt, u32 field, u32 val)\r\n{\r\nwhile (time_before(jiffies, wdt->last_ping + WDT_DELAY))\r\nusleep_range(30, 125);\r\nwritel_relaxed(val, wdt->reg_base + field);\r\nwdt->last_ping = jiffies;\r\n}\r\nstatic void wdt_write_nosleep(struct sama5d4_wdt *wdt, u32 field, u32 val)\r\n{\r\nif (time_before(jiffies, wdt->last_ping + WDT_DELAY))\r\nudelay(123);\r\nwritel_relaxed(val, wdt->reg_base + field);\r\nwdt->last_ping = jiffies;\r\n}\r\nstatic int sama5d4_wdt_start(struct watchdog_device *wdd)\r\n{\r\nstruct sama5d4_wdt *wdt = watchdog_get_drvdata(wdd);\r\nwdt->mr &= ~AT91_WDT_WDDIS;\r\nwdt_write(wdt, AT91_WDT_MR, wdt->mr);\r\nreturn 0;\r\n}\r\nstatic int sama5d4_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nstruct sama5d4_wdt *wdt = watchdog_get_drvdata(wdd);\r\nwdt->mr |= AT91_WDT_WDDIS;\r\nwdt_write(wdt, AT91_WDT_MR, wdt->mr);\r\nreturn 0;\r\n}\r\nstatic int sama5d4_wdt_ping(struct watchdog_device *wdd)\r\n{\r\nstruct sama5d4_wdt *wdt = watchdog_get_drvdata(wdd);\r\nwdt_write(wdt, AT91_WDT_CR, AT91_WDT_KEY | AT91_WDT_WDRSTT);\r\nreturn 0;\r\n}\r\nstatic int sama5d4_wdt_set_timeout(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nstruct sama5d4_wdt *wdt = watchdog_get_drvdata(wdd);\r\nu32 value = WDT_SEC2TICKS(timeout);\r\nwdt->mr &= ~AT91_WDT_WDV;\r\nwdt->mr &= ~AT91_WDT_WDD;\r\nwdt->mr |= AT91_WDT_SET_WDV(value);\r\nwdt->mr |= AT91_WDT_SET_WDD(value);\r\nif (wdt_enabled)\r\nwdt_write(wdt, AT91_WDT_MR, wdt->mr & ~AT91_WDT_WDDIS);\r\nwdd->timeout = timeout;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sama5d4_wdt_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct sama5d4_wdt *wdt = platform_get_drvdata(dev_id);\r\nif (wdt_read(wdt, AT91_WDT_SR)) {\r\npr_crit("Atmel Watchdog Software Reset\n");\r\nemergency_restart();\r\npr_crit("Reboot didn't succeed\n");\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int of_sama5d4_wdt_init(struct device_node *np, struct sama5d4_wdt *wdt)\r\n{\r\nconst char *tmp;\r\nwdt->mr = AT91_WDT_WDDIS;\r\nif (!of_property_read_string(np, "atmel,watchdog-type", &tmp) &&\r\n!strcmp(tmp, "software"))\r\nwdt->mr |= AT91_WDT_WDFIEN;\r\nelse\r\nwdt->mr |= AT91_WDT_WDRSTEN;\r\nif (of_property_read_bool(np, "atmel,idle-halt"))\r\nwdt->mr |= AT91_WDT_WDIDLEHLT;\r\nif (of_property_read_bool(np, "atmel,dbg-halt"))\r\nwdt->mr |= AT91_WDT_WDDBGHLT;\r\nreturn 0;\r\n}\r\nstatic int sama5d4_wdt_init(struct sama5d4_wdt *wdt)\r\n{\r\nu32 reg;\r\nif (wdt_enabled) {\r\nwdt_write_nosleep(wdt, AT91_WDT_MR, wdt->mr);\r\n} else {\r\nreg = wdt_read(wdt, AT91_WDT_MR);\r\nif (!(reg & AT91_WDT_WDDIS))\r\nwdt_write_nosleep(wdt, AT91_WDT_MR,\r\nreg | AT91_WDT_WDDIS);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sama5d4_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct watchdog_device *wdd;\r\nstruct sama5d4_wdt *wdt;\r\nstruct resource *res;\r\nvoid __iomem *regs;\r\nu32 irq = 0;\r\nu32 timeout;\r\nint ret;\r\nwdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\nwdd = &wdt->wdd;\r\nwdd->timeout = wdt_timeout;\r\nwdd->info = &sama5d4_wdt_info;\r\nwdd->ops = &sama5d4_wdt_ops;\r\nwdd->min_timeout = MIN_WDT_TIMEOUT;\r\nwdd->max_timeout = MAX_WDT_TIMEOUT;\r\nwdt->last_ping = jiffies;\r\nwatchdog_set_drvdata(wdd, wdt);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\nwdt->reg_base = regs;\r\nirq = irq_of_parse_and_map(pdev->dev.of_node, 0);\r\nif (!irq)\r\ndev_warn(&pdev->dev, "failed to get IRQ from DT\n");\r\nret = of_sama5d4_wdt_init(pdev->dev.of_node, wdt);\r\nif (ret)\r\nreturn ret;\r\nif ((wdt->mr & AT91_WDT_WDFIEN) && irq) {\r\nret = devm_request_irq(&pdev->dev, irq, sama5d4_wdt_irq_handler,\r\nIRQF_SHARED | IRQF_IRQPOLL |\r\nIRQF_NO_SUSPEND, pdev->name, pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"cannot register interrupt handler\n");\r\nreturn ret;\r\n}\r\n}\r\nret = watchdog_init_timeout(wdd, wdt_timeout, &pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to set timeout value\n");\r\nreturn ret;\r\n}\r\ntimeout = WDT_SEC2TICKS(wdd->timeout);\r\nwdt->mr |= AT91_WDT_SET_WDD(timeout);\r\nwdt->mr |= AT91_WDT_SET_WDV(timeout);\r\nret = sama5d4_wdt_init(wdt);\r\nif (ret)\r\nreturn ret;\r\nwatchdog_set_nowayout(wdd, nowayout);\r\nret = watchdog_register_device(wdd);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register watchdog device\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, wdt);\r\ndev_info(&pdev->dev, "initialized (timeout = %d sec, nowayout = %d)\n",\r\nwdt_timeout, nowayout);\r\nreturn 0;\r\n}\r\nstatic int sama5d4_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct sama5d4_wdt *wdt = platform_get_drvdata(pdev);\r\nsama5d4_wdt_stop(&wdt->wdd);\r\nwatchdog_unregister_device(&wdt->wdd);\r\nreturn 0;\r\n}\r\nstatic int sama5d4_wdt_resume(struct device *dev)\r\n{\r\nstruct sama5d4_wdt *wdt = dev_get_drvdata(dev);\r\nsama5d4_wdt_init(wdt);\r\nreturn 0;\r\n}
