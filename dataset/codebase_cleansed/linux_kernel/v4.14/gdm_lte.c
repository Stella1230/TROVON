static int gdm_lte_open(struct net_device *dev)\r\n{\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int gdm_lte_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int gdm_lte_set_config(struct net_device *dev, struct ifmap *map)\r\n{\r\nif (dev->flags & IFF_UP)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic void tx_complete(void *arg)\r\n{\r\nstruct nic *nic = arg;\r\nif (netif_queue_stopped(nic->netdev))\r\nnetif_wake_queue(nic->netdev);\r\n}\r\nstatic int gdm_lte_rx(struct sk_buff *skb, struct nic *nic, int nic_type)\r\n{\r\nint ret;\r\nret = netif_rx_ni(skb);\r\nif (ret == NET_RX_DROP) {\r\nnic->stats.rx_dropped++;\r\n} else {\r\nnic->stats.rx_packets++;\r\nnic->stats.rx_bytes += skb->len + ETH_HLEN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gdm_lte_emulate_arp(struct sk_buff *skb_in, u32 nic_type)\r\n{\r\nstruct nic *nic = netdev_priv(skb_in->dev);\r\nstruct sk_buff *skb_out;\r\nstruct ethhdr eth;\r\nstruct vlan_ethhdr vlan_eth;\r\nstruct arphdr *arp_in;\r\nstruct arphdr *arp_out;\r\nstruct arpdata {\r\nu8 ar_sha[ETH_ALEN];\r\nu8 ar_sip[4];\r\nu8 ar_tha[ETH_ALEN];\r\nu8 ar_tip[4];\r\n};\r\nstruct arpdata *arp_data_in;\r\nstruct arpdata *arp_data_out;\r\nu8 arp_temp[60];\r\nvoid *mac_header_data;\r\nu32 mac_header_len;\r\nif (ntohs(((struct ethhdr *)skb_in->data)->h_proto) == ETH_P_8021Q) {\r\nmemcpy(&vlan_eth, skb_in->data, sizeof(struct vlan_ethhdr));\r\nmac_header_data = &vlan_eth;\r\nmac_header_len = VLAN_ETH_HLEN;\r\n} else {\r\nmemcpy(&eth, skb_in->data, sizeof(struct ethhdr));\r\nmac_header_data = &eth;\r\nmac_header_len = ETH_HLEN;\r\n}\r\narp_in = (struct arphdr *)(skb_in->data + mac_header_len);\r\narp_data_in = (struct arpdata *)(skb_in->data + mac_header_len +\r\nsizeof(struct arphdr));\r\narp_out = (struct arphdr *)arp_temp;\r\narp_data_out = (struct arpdata *)(arp_temp + sizeof(struct arphdr));\r\nmemcpy(arp_out, arp_in, sizeof(struct arphdr));\r\narp_out->ar_op = htons(ARPOP_REPLY);\r\narp_data_out->ar_sha[0] = arp_data_in->ar_sha[0];\r\narp_data_out->ar_sha[1] = arp_data_in->ar_sha[1];\r\nmemcpy(&arp_data_out->ar_sha[2], &arp_data_in->ar_tip[0], 4);\r\nmemcpy(&arp_data_out->ar_sip[0], &arp_data_in->ar_tip[0], 4);\r\nmemcpy(&arp_data_out->ar_tha[0], &arp_data_in->ar_sha[0], 6);\r\nmemcpy(&arp_data_out->ar_tip[0], &arp_data_in->ar_sip[0], 4);\r\nmemcpy(mac_header_data, mac_header_data + ETH_ALEN, ETH_ALEN);\r\nmemcpy(mac_header_data + ETH_ALEN, nic->src_mac_addr, ETH_ALEN);\r\nskb_out = dev_alloc_skb(skb_in->len);\r\nif (!skb_out)\r\nreturn -ENOMEM;\r\nskb_reserve(skb_out, NET_IP_ALIGN);\r\nskb_put_data(skb_out, mac_header_data, mac_header_len);\r\nskb_put_data(skb_out, arp_out, sizeof(struct arphdr));\r\nskb_put_data(skb_out, arp_data_out, sizeof(struct arpdata));\r\nskb_out->protocol = ((struct ethhdr *)mac_header_data)->h_proto;\r\nskb_out->dev = skb_in->dev;\r\nskb_reset_mac_header(skb_out);\r\nskb_pull(skb_out, ETH_HLEN);\r\ngdm_lte_rx(skb_out, nic, nic_type);\r\nreturn 0;\r\n}\r\nstatic __sum16 icmp6_checksum(struct ipv6hdr *ipv6, u16 *ptr, int len)\r\n{\r\nunsigned short *w = ptr;\r\n__wsum sum = 0;\r\nint i;\r\nunion {\r\nstruct {\r\nu8 ph_src[16];\r\nu8 ph_dst[16];\r\nu32 ph_len;\r\nu8 ph_zero[3];\r\nu8 ph_nxt;\r\n} ph __packed;\r\nu16 pa[20];\r\n} pseudo_header;\r\nmemset(&pseudo_header, 0, sizeof(pseudo_header));\r\nmemcpy(&pseudo_header.ph.ph_src, &ipv6->saddr.in6_u.u6_addr8, 16);\r\nmemcpy(&pseudo_header.ph.ph_dst, &ipv6->daddr.in6_u.u6_addr8, 16);\r\npseudo_header.ph.ph_len = be16_to_cpu(ipv6->payload_len);\r\npseudo_header.ph.ph_nxt = ipv6->nexthdr;\r\nw = (u16 *)&pseudo_header;\r\nfor (i = 0; i < ARRAY_SIZE(pseudo_header.pa); i++)\r\nsum = csum_add(sum, csum_unfold(\r\n(__force __sum16)pseudo_header.pa[i]));\r\nw = ptr;\r\nwhile (len > 1) {\r\nsum = csum_add(sum, csum_unfold((__force __sum16)*w++));\r\nlen -= 2;\r\n}\r\nreturn csum_fold(sum);\r\n}\r\nstatic int gdm_lte_emulate_ndp(struct sk_buff *skb_in, u32 nic_type)\r\n{\r\nstruct nic *nic = netdev_priv(skb_in->dev);\r\nstruct sk_buff *skb_out;\r\nstruct ethhdr eth;\r\nstruct vlan_ethhdr vlan_eth;\r\nstruct neighbour_advertisement {\r\nu8 target_address[16];\r\nu8 type;\r\nu8 length;\r\nu8 link_layer_address[6];\r\n};\r\nstruct neighbour_advertisement na;\r\nstruct neighbour_solicitation {\r\nu8 target_address[16];\r\n};\r\nstruct neighbour_solicitation *ns;\r\nstruct ipv6hdr *ipv6_in;\r\nstruct ipv6hdr ipv6_out;\r\nstruct icmp6hdr *icmp6_in;\r\nstruct icmp6hdr icmp6_out;\r\nvoid *mac_header_data;\r\nu32 mac_header_len;\r\nif (ntohs(((struct ethhdr *)skb_in->data)->h_proto) == ETH_P_8021Q) {\r\nmemcpy(&vlan_eth, skb_in->data, sizeof(struct vlan_ethhdr));\r\nif (ntohs(vlan_eth.h_vlan_encapsulated_proto) != ETH_P_IPV6)\r\nreturn -1;\r\nmac_header_data = &vlan_eth;\r\nmac_header_len = VLAN_ETH_HLEN;\r\n} else {\r\nmemcpy(&eth, skb_in->data, sizeof(struct ethhdr));\r\nif (ntohs(eth.h_proto) != ETH_P_IPV6)\r\nreturn -1;\r\nmac_header_data = &eth;\r\nmac_header_len = ETH_HLEN;\r\n}\r\nipv6_in = (struct ipv6hdr *)(skb_in->data + mac_header_len);\r\nif (ipv6_in->version != 6 || ipv6_in->nexthdr != IPPROTO_ICMPV6)\r\nreturn -1;\r\nicmp6_in = (struct icmp6hdr *)(skb_in->data + mac_header_len +\r\nsizeof(struct ipv6hdr));\r\nif (icmp6_in->icmp6_type == NDISC_ROUTER_SOLICITATION) {\r\nreturn -1;\r\n} else if (icmp6_in->icmp6_type == NDISC_NEIGHBOUR_SOLICITATION) {\r\nu8 icmp_na[sizeof(struct icmp6hdr) +\r\nsizeof(struct neighbour_advertisement)];\r\nu8 zero_addr8[16] = {0,};\r\nif (memcmp(ipv6_in->saddr.in6_u.u6_addr8, zero_addr8, 16) == 0)\r\nreturn 0;\r\nicmp6_out.icmp6_type = NDISC_NEIGHBOUR_ADVERTISEMENT;\r\nicmp6_out.icmp6_code = 0;\r\nicmp6_out.icmp6_cksum = 0;\r\nicmp6_out.icmp6_dataun.un_data32[0] = htonl(0x60000000);\r\nns = (struct neighbour_solicitation *)\r\n(skb_in->data + mac_header_len +\r\nsizeof(struct ipv6hdr) + sizeof(struct icmp6hdr));\r\nmemcpy(&na.target_address, ns->target_address, 16);\r\nna.type = 0x02;\r\nna.length = 1;\r\nna.link_layer_address[0] = 0x00;\r\nna.link_layer_address[1] = 0x0a;\r\nna.link_layer_address[2] = 0x3b;\r\nna.link_layer_address[3] = 0xaf;\r\nna.link_layer_address[4] = 0x63;\r\nna.link_layer_address[5] = 0xc7;\r\nmemcpy(&ipv6_out, ipv6_in, sizeof(struct ipv6hdr));\r\nmemcpy(ipv6_out.saddr.in6_u.u6_addr8, &na.target_address, 16);\r\nmemcpy(ipv6_out.daddr.in6_u.u6_addr8,\r\nipv6_in->saddr.in6_u.u6_addr8, 16);\r\nipv6_out.payload_len = htons(sizeof(struct icmp6hdr) +\r\nsizeof(struct neighbour_advertisement));\r\nmemcpy(icmp_na, &icmp6_out, sizeof(struct icmp6hdr));\r\nmemcpy(icmp_na + sizeof(struct icmp6hdr), &na,\r\nsizeof(struct neighbour_advertisement));\r\nicmp6_out.icmp6_cksum = icmp6_checksum(&ipv6_out,\r\n(u16 *)icmp_na, sizeof(icmp_na));\r\n} else {\r\nreturn -1;\r\n}\r\nmemcpy(mac_header_data, mac_header_data + ETH_ALEN, ETH_ALEN);\r\nmemcpy(mac_header_data + ETH_ALEN, nic->src_mac_addr, ETH_ALEN);\r\nskb_out = dev_alloc_skb(skb_in->len);\r\nif (!skb_out)\r\nreturn -ENOMEM;\r\nskb_reserve(skb_out, NET_IP_ALIGN);\r\nskb_put_data(skb_out, mac_header_data, mac_header_len);\r\nskb_put_data(skb_out, &ipv6_out, sizeof(struct ipv6hdr));\r\nskb_put_data(skb_out, &icmp6_out, sizeof(struct icmp6hdr));\r\nskb_put_data(skb_out, &na, sizeof(struct neighbour_advertisement));\r\nskb_out->protocol = ((struct ethhdr *)mac_header_data)->h_proto;\r\nskb_out->dev = skb_in->dev;\r\nskb_reset_mac_header(skb_out);\r\nskb_pull(skb_out, ETH_HLEN);\r\ngdm_lte_rx(skb_out, nic, nic_type);\r\nreturn 0;\r\n}\r\nstatic s32 gdm_lte_tx_nic_type(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct nic *nic = netdev_priv(dev);\r\nstruct ethhdr *eth;\r\nstruct vlan_ethhdr *vlan_eth;\r\nstruct iphdr *ip;\r\nstruct ipv6hdr *ipv6;\r\nint mac_proto;\r\nvoid *network_data;\r\nu32 nic_type;\r\nnic_type = 0x00000010 | nic->nic_id;\r\neth = (struct ethhdr *)skb->data;\r\nif (ntohs(eth->h_proto) == ETH_P_8021Q) {\r\nvlan_eth = (struct vlan_ethhdr *)skb->data;\r\nmac_proto = ntohs(vlan_eth->h_vlan_encapsulated_proto);\r\nnetwork_data = skb->data + VLAN_ETH_HLEN;\r\nnic_type |= NIC_TYPE_F_VLAN;\r\n} else {\r\nmac_proto = ntohs(eth->h_proto);\r\nnetwork_data = skb->data + ETH_HLEN;\r\n}\r\nswitch (mac_proto) {\r\ncase ETH_P_ARP:\r\nnic_type |= NIC_TYPE_ARP;\r\nbreak;\r\ncase ETH_P_IP:\r\nnic_type |= NIC_TYPE_F_IPV4;\r\nip = network_data;\r\nif (ip->protocol == IPPROTO_UDP) {\r\nstruct udphdr *udp =\r\nnetwork_data + sizeof(struct iphdr);\r\nif (ntohs(udp->dest) == 67 || ntohs(udp->dest) == 68)\r\nnic_type |= NIC_TYPE_F_DHCP;\r\n}\r\nbreak;\r\ncase ETH_P_IPV6:\r\nnic_type |= NIC_TYPE_F_IPV6;\r\nipv6 = network_data;\r\nif (ipv6->nexthdr == IPPROTO_ICMPV6) {\r\nstruct icmp6hdr *icmp6 =\r\nnetwork_data + sizeof(struct ipv6hdr);\r\nif (icmp6->icmp6_type == NDISC_NEIGHBOUR_SOLICITATION)\r\nnic_type |= NIC_TYPE_ICMPV6;\r\n} else if (ipv6->nexthdr == IPPROTO_UDP) {\r\nstruct udphdr *udp =\r\nnetwork_data + sizeof(struct ipv6hdr);\r\nif (ntohs(udp->dest) == 546 || ntohs(udp->dest) == 547)\r\nnic_type |= NIC_TYPE_F_DHCP;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn nic_type;\r\n}\r\nstatic int gdm_lte_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct nic *nic = netdev_priv(dev);\r\nu32 nic_type;\r\nvoid *data_buf;\r\nint data_len;\r\nint idx;\r\nint ret = 0;\r\nnic_type = gdm_lte_tx_nic_type(dev, skb);\r\nif (nic_type == 0) {\r\nnetdev_err(dev, "tx - invalid nic_type\n");\r\nreturn -1;\r\n}\r\nif (nic_type & NIC_TYPE_ARP) {\r\nif (gdm_lte_emulate_arp(skb, nic_type) == 0) {\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\n}\r\nif (nic_type & NIC_TYPE_ICMPV6) {\r\nif (gdm_lte_emulate_ndp(skb, nic_type) == 0) {\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\n}\r\nif (nic_type & NIC_TYPE_F_VLAN) {\r\nstruct vlan_ethhdr *vlan_eth = (struct vlan_ethhdr *)skb->data;\r\nnic->vlan_id = ntohs(vlan_eth->h_vlan_TCI) & VLAN_VID_MASK;\r\ndata_buf = skb->data + (VLAN_ETH_HLEN - ETH_HLEN);\r\ndata_len = skb->len - (VLAN_ETH_HLEN - ETH_HLEN);\r\n} else {\r\nnic->vlan_id = 0;\r\ndata_buf = skb->data;\r\ndata_len = skb->len;\r\n}\r\nif (nic_type & NIC_TYPE_ICMPV6)\r\nnic_type = NIC_TYPE_ICMPV6;\r\nif (!(nic_type & NIC_TYPE_F_DHCP))\r\nnic_type &= NIC_TYPE_MASK;\r\nret = sscanf(dev->name, "lte%d", &idx);\r\nif (ret != 1) {\r\ndev_kfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nret = nic->phy_dev->send_sdu_func(nic->phy_dev->priv_dev,\r\ndata_buf, data_len,\r\nnic->pdn_table.dft_eps_id, 0,\r\ntx_complete, nic, idx,\r\nnic_type);\r\nif (ret == TX_NO_BUFFER || ret == TX_NO_SPC) {\r\nnetif_stop_queue(dev);\r\nif (ret == TX_NO_BUFFER)\r\nret = 0;\r\nelse\r\nret = -ENOSPC;\r\n} else if (ret == TX_NO_DEV) {\r\nret = -ENODEV;\r\n}\r\nif (ret) {\r\nnic->stats.tx_dropped++;\r\n} else {\r\nnic->stats.tx_packets++;\r\nnic->stats.tx_bytes += data_len;\r\n}\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *gdm_lte_stats(struct net_device *dev)\r\n{\r\nstruct nic *nic = netdev_priv(dev);\r\nreturn &nic->stats;\r\n}\r\nstatic int gdm_lte_event_send(struct net_device *dev, char *buf, int len)\r\n{\r\nstruct nic *nic = netdev_priv(dev);\r\nstruct hci_packet *hci = (struct hci_packet *)buf;\r\nint idx;\r\nint ret;\r\nret = sscanf(dev->name, "lte%d", &idx);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\nreturn netlink_send(lte_event.sock, idx, 0, buf,\r\ngdm_dev16_to_cpu(\r\nnic->phy_dev->get_endian(\r\nnic->phy_dev->priv_dev), hci->len)\r\n+ HCI_HEADER_SIZE);\r\n}\r\nstatic void gdm_lte_event_rcv(struct net_device *dev, u16 type,\r\nvoid *msg, int len)\r\n{\r\nstruct nic *nic = netdev_priv(dev);\r\nnic->phy_dev->send_hci_func(nic->phy_dev->priv_dev, msg, len, NULL,\r\nNULL);\r\n}\r\nint gdm_lte_event_init(void)\r\n{\r\nif (lte_event.ref_cnt == 0)\r\nlte_event.sock = netlink_init(NETLINK_LTE, gdm_lte_event_rcv);\r\nif (lte_event.sock) {\r\nlte_event.ref_cnt++;\r\nreturn 0;\r\n}\r\npr_err("event init failed\n");\r\nreturn -1;\r\n}\r\nvoid gdm_lte_event_exit(void)\r\n{\r\nif (lte_event.sock && --lte_event.ref_cnt == 0) {\r\nsock_release(lte_event.sock->sk_socket);\r\nlte_event.sock = NULL;\r\n}\r\n}\r\nstatic int find_dev_index(u32 nic_type)\r\n{\r\nu8 index;\r\nindex = (u8)(nic_type & 0x0000000f);\r\nif (index >= MAX_NIC_TYPE)\r\nreturn -EINVAL;\r\nreturn index;\r\n}\r\nstatic void gdm_lte_netif_rx(struct net_device *dev, char *buf,\r\nint len, int flagged_nic_type)\r\n{\r\nu32 nic_type;\r\nstruct nic *nic;\r\nstruct sk_buff *skb;\r\nstruct ethhdr eth;\r\nstruct vlan_ethhdr vlan_eth;\r\nvoid *mac_header_data;\r\nu32 mac_header_len;\r\nchar ip_version = 0;\r\nnic_type = flagged_nic_type & NIC_TYPE_MASK;\r\nnic = netdev_priv(dev);\r\nif (flagged_nic_type & NIC_TYPE_F_DHCP) {\r\nif (flagged_nic_type & NIC_TYPE_F_IPV4) {\r\nstruct dhcp_packet {\r\nu8 op;\r\nu8 htype;\r\nu8 hlen;\r\nu8 hops;\r\nu32 xid;\r\nu16 secs;\r\nu16 flags;\r\n#define BROADCAST_FLAG 0x8000\r\nu32 ciaddr;\r\nu32 yiaddr;\r\nu32 siaddr_nip;\r\nu32 gateway_nip;\r\nu8 chaddr[16];\r\nu8 sname[64];\r\nu8 file[128];\r\nu32 cookie;\r\n} __packed;\r\nvoid *addr = buf + sizeof(struct iphdr) +\r\nsizeof(struct udphdr) +\r\noffsetof(struct dhcp_packet, chaddr);\r\nether_addr_copy(nic->dest_mac_addr, addr);\r\n}\r\n}\r\nif (nic->vlan_id > 0) {\r\nmac_header_data = (void *)&vlan_eth;\r\nmac_header_len = VLAN_ETH_HLEN;\r\n} else {\r\nmac_header_data = (void *)&eth;\r\nmac_header_len = ETH_HLEN;\r\n}\r\nether_addr_copy(mac_header_data, nic->dest_mac_addr);\r\nmemcpy(mac_header_data + ETH_ALEN, nic->src_mac_addr, ETH_ALEN);\r\nvlan_eth.h_vlan_TCI = htons(nic->vlan_id);\r\nvlan_eth.h_vlan_proto = htons(ETH_P_8021Q);\r\nif (nic_type == NIC_TYPE_ARP) {\r\neth.h_proto = htons(ETH_P_ARP);\r\nvlan_eth.h_vlan_encapsulated_proto = htons(ETH_P_ARP);\r\n} else {\r\nip_version = buf[0] >> 4;\r\nif (ip_version == IP_VERSION_4) {\r\neth.h_proto = htons(ETH_P_IP);\r\nvlan_eth.h_vlan_encapsulated_proto = htons(ETH_P_IP);\r\n} else if (ip_version == IP_VERSION_6) {\r\neth.h_proto = htons(ETH_P_IPV6);\r\nvlan_eth.h_vlan_encapsulated_proto = htons(ETH_P_IPV6);\r\n} else {\r\nnetdev_err(dev, "Unknown IP version %d\n", ip_version);\r\nreturn;\r\n}\r\n}\r\nskb = dev_alloc_skb(len + mac_header_len + NET_IP_ALIGN);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, NET_IP_ALIGN);\r\nskb_put_data(skb, mac_header_data, mac_header_len);\r\nskb_put_data(skb, buf, len);\r\nskb->protocol = ((struct ethhdr *)mac_header_data)->h_proto;\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb, ETH_HLEN);\r\ngdm_lte_rx(skb, nic, nic_type);\r\n}\r\nstatic void gdm_lte_multi_sdu_pkt(struct phy_dev *phy_dev, char *buf, int len)\r\n{\r\nstruct net_device *dev;\r\nstruct multi_sdu *multi_sdu = (struct multi_sdu *)buf;\r\nstruct sdu *sdu = NULL;\r\nstruct gdm_endian *endian = phy_dev->get_endian(phy_dev->priv_dev);\r\nu8 *data = (u8 *)multi_sdu->data;\r\nu16 i = 0;\r\nu16 num_packet;\r\nu16 hci_len;\r\nu16 cmd_evt;\r\nu32 nic_type;\r\nint index;\r\nhci_len = gdm_dev16_to_cpu(endian, multi_sdu->len);\r\nnum_packet = gdm_dev16_to_cpu(endian, multi_sdu->num_packet);\r\nfor (i = 0; i < num_packet; i++) {\r\nsdu = (struct sdu *)data;\r\ncmd_evt = gdm_dev16_to_cpu(endian, sdu->cmd_evt);\r\nhci_len = gdm_dev16_to_cpu(endian, sdu->len);\r\nnic_type = gdm_dev32_to_cpu(endian, sdu->nic_type);\r\nif (cmd_evt != LTE_RX_SDU) {\r\npr_err("rx sdu wrong hci %04x\n", cmd_evt);\r\nreturn;\r\n}\r\nif (hci_len < 12) {\r\npr_err("rx sdu invalid len %d\n", hci_len);\r\nreturn;\r\n}\r\nindex = find_dev_index(nic_type);\r\nif (index < 0) {\r\npr_err("rx sdu invalid nic_type :%x\n", nic_type);\r\nreturn;\r\n}\r\ndev = phy_dev->dev[index];\r\ngdm_lte_netif_rx(dev, (char *)sdu->data,\r\n(int)(hci_len - 12), nic_type);\r\ndata += ((hci_len + 3) & 0xfffc) + HCI_HEADER_SIZE;\r\n}\r\n}\r\nstatic void gdm_lte_pdn_table(struct net_device *dev, char *buf, int len)\r\n{\r\nstruct nic *nic = netdev_priv(dev);\r\nstruct hci_pdn_table_ind *pdn_table = (struct hci_pdn_table_ind *)buf;\r\nif (pdn_table->activate) {\r\nnic->pdn_table.activate = pdn_table->activate;\r\nnic->pdn_table.dft_eps_id = gdm_dev32_to_cpu(\r\nnic->phy_dev->get_endian(\r\nnic->phy_dev->priv_dev),\r\npdn_table->dft_eps_id);\r\nnic->pdn_table.nic_type = gdm_dev32_to_cpu(\r\nnic->phy_dev->get_endian(\r\nnic->phy_dev->priv_dev),\r\npdn_table->nic_type);\r\nnetdev_info(dev, "pdn activated, nic_type=0x%x\n",\r\nnic->pdn_table.nic_type);\r\n} else {\r\nmemset(&nic->pdn_table, 0x00, sizeof(struct pdn_table));\r\nnetdev_info(dev, "pdn deactivated\n");\r\n}\r\n}\r\nstatic int gdm_lte_receive_pkt(struct phy_dev *phy_dev, char *buf, int len)\r\n{\r\nstruct hci_packet *hci = (struct hci_packet *)buf;\r\nstruct hci_pdn_table_ind *pdn_table = (struct hci_pdn_table_ind *)buf;\r\nstruct gdm_endian *endian = phy_dev->get_endian(phy_dev->priv_dev);\r\nstruct sdu *sdu;\r\nstruct net_device *dev;\r\nint ret = 0;\r\nu16 cmd_evt;\r\nu32 nic_type;\r\nint index;\r\nif (!len)\r\nreturn ret;\r\ncmd_evt = gdm_dev16_to_cpu(endian, hci->cmd_evt);\r\ndev = phy_dev->dev[0];\r\nif (!dev)\r\nreturn 0;\r\nswitch (cmd_evt) {\r\ncase LTE_RX_SDU:\r\nsdu = (struct sdu *)hci->data;\r\nnic_type = gdm_dev32_to_cpu(endian, sdu->nic_type);\r\nindex = find_dev_index(nic_type);\r\nif (index < 0)\r\nreturn index;\r\ndev = phy_dev->dev[index];\r\ngdm_lte_netif_rx(dev, hci->data, len, nic_type);\r\nbreak;\r\ncase LTE_RX_MULTI_SDU:\r\ngdm_lte_multi_sdu_pkt(phy_dev, buf, len);\r\nbreak;\r\ncase LTE_LINK_ON_OFF_INDICATION:\r\nnetdev_info(dev, "link %s\n",\r\n((struct hci_connect_ind *)buf)->connect\r\n? "on" : "off");\r\nbreak;\r\ncase LTE_PDN_TABLE_IND:\r\npdn_table = (struct hci_pdn_table_ind *)buf;\r\nnic_type = gdm_dev32_to_cpu(endian, pdn_table->nic_type);\r\nindex = find_dev_index(nic_type);\r\nif (index < 0)\r\nreturn index;\r\ndev = phy_dev->dev[index];\r\ngdm_lte_pdn_table(dev, buf, len);\r\ndefault:\r\nret = gdm_lte_event_send(dev, buf, len);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rx_complete(void *arg, void *data, int len, int context)\r\n{\r\nstruct phy_dev *phy_dev = arg;\r\nreturn gdm_lte_receive_pkt(phy_dev, data, len);\r\n}\r\nvoid start_rx_proc(struct phy_dev *phy_dev)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_RX_SUBMIT_COUNT; i++)\r\nphy_dev->rcv_func(phy_dev->priv_dev,\r\nrx_complete, phy_dev, USB_COMPLETE);\r\n}\r\nstatic void form_mac_address(u8 *dev_addr, u8 *nic_src, u8 *nic_dest,\r\nu8 *mac_address, u8 index)\r\n{\r\nif (!mac_address)\r\nether_addr_copy(dev_addr, gdm_lte_macaddr);\r\nelse\r\nether_addr_copy(dev_addr, mac_address);\r\ndev_addr[ETH_ALEN - 1] += index;\r\neth_random_addr(nic_src);\r\nmemcpy(nic_src, dev_addr, 3);\r\nether_addr_copy(nic_dest, dev_addr);\r\n}\r\nstatic void validate_mac_address(u8 *mac_address)\r\n{\r\nif (is_zero_ether_addr(mac_address) || (mac_address[0] & 0x01)) {\r\npr_err("MAC invalid, restoring default\n");\r\nmemcpy(mac_address, gdm_lte_macaddr, 6);\r\n}\r\n}\r\nint register_lte_device(struct phy_dev *phy_dev,\r\nstruct device *dev, u8 *mac_address)\r\n{\r\nstruct nic *nic;\r\nstruct net_device *net;\r\nchar pdn_dev_name[16];\r\nint ret = 0;\r\nu8 index;\r\nvalidate_mac_address(mac_address);\r\nfor (index = 0; index < MAX_NIC_TYPE; index++) {\r\nsprintf(pdn_dev_name, "lte%%dpdn%d", index);\r\nnet = alloc_netdev(sizeof(struct nic), pdn_dev_name,\r\nNET_NAME_UNKNOWN, ether_setup);\r\nif (!net) {\r\npr_err("alloc_netdev failed\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nnet->netdev_ops = &gdm_netdev_ops;\r\nnet->flags &= ~IFF_MULTICAST;\r\nnet->mtu = DEFAULT_MTU_SIZE;\r\nnic = netdev_priv(net);\r\nmemset(nic, 0, sizeof(struct nic));\r\nnic->netdev = net;\r\nnic->phy_dev = phy_dev;\r\nnic->nic_id = index;\r\nform_mac_address(\r\nnet->dev_addr,\r\nnic->src_mac_addr,\r\nnic->dest_mac_addr,\r\nmac_address,\r\nindex);\r\nSET_NETDEV_DEV(net, dev);\r\nSET_NETDEV_DEVTYPE(net, &wwan_type);\r\nret = register_netdev(net);\r\nif (ret)\r\ngoto err;\r\nnetif_carrier_on(net);\r\nphy_dev->dev[index] = net;\r\n}\r\nreturn 0;\r\nerr:\r\nunregister_lte_device(phy_dev);\r\nreturn ret;\r\n}\r\nvoid unregister_lte_device(struct phy_dev *phy_dev)\r\n{\r\nstruct net_device *net;\r\nint index;\r\nfor (index = 0; index < MAX_NIC_TYPE; index++) {\r\nnet = phy_dev->dev[index];\r\nif (!net)\r\ncontinue;\r\nunregister_netdev(net);\r\nfree_netdev(net);\r\n}\r\n}
