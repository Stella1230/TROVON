static void eeti_ts_report_event(struct eeti_ts *eeti, u8 *buf)\r\n{\r\nunsigned int res;\r\nu16 x, y;\r\nres = REPORT_RES_BITS(buf[0] & (REPORT_BIT_AD0 | REPORT_BIT_AD1));\r\nx = get_unaligned_be16(&buf[1]);\r\ny = get_unaligned_be16(&buf[3]);\r\nx >>= res - EETI_TS_BITDEPTH;\r\ny >>= res - EETI_TS_BITDEPTH;\r\nif (flip_x)\r\nx = EETI_MAXVAL - x;\r\nif (flip_y)\r\ny = EETI_MAXVAL - y;\r\nif (buf[0] & REPORT_BIT_HAS_PRESSURE)\r\ninput_report_abs(eeti->input, ABS_PRESSURE, buf[5]);\r\ninput_report_abs(eeti->input, ABS_X, x);\r\ninput_report_abs(eeti->input, ABS_Y, y);\r\ninput_report_key(eeti->input, BTN_TOUCH, buf[0] & REPORT_BIT_PRESSED);\r\ninput_sync(eeti->input);\r\n}\r\nstatic irqreturn_t eeti_ts_isr(int irq, void *dev_id)\r\n{\r\nstruct eeti_ts *eeti = dev_id;\r\nint len;\r\nint error;\r\nchar buf[6];\r\ndo {\r\nlen = i2c_master_recv(eeti->client, buf, sizeof(buf));\r\nif (len != sizeof(buf)) {\r\nerror = len < 0 ? len : -EIO;\r\ndev_err(&eeti->client->dev,\r\n"failed to read touchscreen data: %d\n",\r\nerror);\r\nbreak;\r\n}\r\nif (buf[0] & 0x80) {\r\neeti_ts_report_event(eeti, buf);\r\n}\r\n} while (eeti->running &&\r\neeti->attn_gpio && gpiod_get_value_cansleep(eeti->attn_gpio));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void eeti_ts_start(struct eeti_ts *eeti)\r\n{\r\neeti->running = true;\r\nwmb();\r\nenable_irq(eeti->client->irq);\r\n}\r\nstatic void eeti_ts_stop(struct eeti_ts *eeti)\r\n{\r\neeti->running = false;\r\nwmb();\r\ndisable_irq(eeti->client->irq);\r\n}\r\nstatic int eeti_ts_open(struct input_dev *dev)\r\n{\r\nstruct eeti_ts *eeti = input_get_drvdata(dev);\r\neeti_ts_start(eeti);\r\nreturn 0;\r\n}\r\nstatic void eeti_ts_close(struct input_dev *dev)\r\n{\r\nstruct eeti_ts *eeti = input_get_drvdata(dev);\r\neeti_ts_stop(eeti);\r\n}\r\nstatic int eeti_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *idp)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct eeti_ts *eeti;\r\nstruct input_dev *input;\r\nint error;\r\neeti = devm_kzalloc(dev, sizeof(*eeti), GFP_KERNEL);\r\nif (!eeti) {\r\ndev_err(dev, "failed to allocate driver data\n");\r\nreturn -ENOMEM;\r\n}\r\ninput = devm_input_allocate_device(dev);\r\nif (!input) {\r\ndev_err(dev, "Failed to allocate input device.\n");\r\nreturn -ENOMEM;\r\n}\r\ninput_set_capability(input, EV_KEY, BTN_TOUCH);\r\ninput_set_abs_params(input, ABS_X, 0, EETI_MAXVAL, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, 0, EETI_MAXVAL, 0, 0);\r\ninput_set_abs_params(input, ABS_PRESSURE, 0, 0xff, 0, 0);\r\ninput->name = client->name;\r\ninput->id.bustype = BUS_I2C;\r\ninput->open = eeti_ts_open;\r\ninput->close = eeti_ts_close;\r\neeti->client = client;\r\neeti->input = input;\r\neeti->attn_gpio = devm_gpiod_get_optional(dev, "attn", GPIOD_IN);\r\nif (IS_ERR(eeti->attn_gpio))\r\nreturn PTR_ERR(eeti->attn_gpio);\r\ni2c_set_clientdata(client, eeti);\r\ninput_set_drvdata(input, eeti);\r\nerror = devm_request_threaded_irq(dev, client->irq,\r\nNULL, eeti_ts_isr,\r\nIRQF_ONESHOT,\r\nclient->name, eeti);\r\nif (error) {\r\ndev_err(dev, "Unable to request touchscreen IRQ: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\neeti_ts_stop(eeti);\r\nerror = input_register_device(input);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused eeti_ts_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct eeti_ts *eeti = i2c_get_clientdata(client);\r\nstruct input_dev *input_dev = eeti->input;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\neeti_ts_stop(eeti);\r\nmutex_unlock(&input_dev->mutex);\r\nif (device_may_wakeup(&client->dev))\r\nenable_irq_wake(client->irq);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused eeti_ts_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct eeti_ts *eeti = i2c_get_clientdata(client);\r\nstruct input_dev *input_dev = eeti->input;\r\nif (device_may_wakeup(&client->dev))\r\ndisable_irq_wake(client->irq);\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\neeti_ts_start(eeti);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}
