static int sx150x_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn 0;\r\n}\r\nstatic const char *sx150x_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned int group)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int sx150x_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned int group,\r\nconst unsigned int **pins,\r\nunsigned int *num_pins)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic bool sx150x_pin_is_oscio(struct sx150x_pinctrl *pctl, unsigned int pin)\r\n{\r\nif (pin >= pctl->data->npins)\r\nreturn false;\r\nif (pctl->data->model != SX150X_789)\r\nreturn false;\r\nreturn !strcmp(pctl->data->pins[pin].name, "oscio");\r\n}\r\nstatic int sx150x_gpio_get_direction(struct gpio_chip *chip,\r\nunsigned int offset)\r\n{\r\nstruct sx150x_pinctrl *pctl = gpiochip_get_data(chip);\r\nunsigned int value;\r\nint ret;\r\nif (sx150x_pin_is_oscio(pctl, offset))\r\nreturn false;\r\nret = regmap_read(pctl->regmap, pctl->data->reg_dir, &value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !!(value & BIT(offset));\r\n}\r\nstatic int sx150x_gpio_get(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nstruct sx150x_pinctrl *pctl = gpiochip_get_data(chip);\r\nunsigned int value;\r\nint ret;\r\nif (sx150x_pin_is_oscio(pctl, offset))\r\nreturn -EINVAL;\r\nret = regmap_read(pctl->regmap, pctl->data->reg_data, &value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !!(value & BIT(offset));\r\n}\r\nstatic int __sx150x_gpio_set(struct sx150x_pinctrl *pctl, unsigned int offset,\r\nint value)\r\n{\r\nreturn regmap_write_bits(pctl->regmap, pctl->data->reg_data,\r\nBIT(offset), value ? BIT(offset) : 0);\r\n}\r\nstatic int sx150x_gpio_oscio_set(struct sx150x_pinctrl *pctl,\r\nint value)\r\n{\r\nreturn regmap_write(pctl->regmap,\r\npctl->data->pri.x789.reg_clock,\r\n(value ? 0x1f : 0x10));\r\n}\r\nstatic void sx150x_gpio_set(struct gpio_chip *chip, unsigned int offset,\r\nint value)\r\n{\r\nstruct sx150x_pinctrl *pctl = gpiochip_get_data(chip);\r\nif (sx150x_pin_is_oscio(pctl, offset))\r\nsx150x_gpio_oscio_set(pctl, value);\r\nelse\r\n__sx150x_gpio_set(pctl, offset, value);\r\n}\r\nstatic void sx150x_gpio_set_multiple(struct gpio_chip *chip,\r\nunsigned long *mask,\r\nunsigned long *bits)\r\n{\r\nstruct sx150x_pinctrl *pctl = gpiochip_get_data(chip);\r\nregmap_write_bits(pctl->regmap, pctl->data->reg_data, *mask, *bits);\r\n}\r\nstatic int sx150x_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned int offset)\r\n{\r\nstruct sx150x_pinctrl *pctl = gpiochip_get_data(chip);\r\nif (sx150x_pin_is_oscio(pctl, offset))\r\nreturn -EINVAL;\r\nreturn regmap_write_bits(pctl->regmap,\r\npctl->data->reg_dir,\r\nBIT(offset), BIT(offset));\r\n}\r\nstatic int sx150x_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned int offset, int value)\r\n{\r\nstruct sx150x_pinctrl *pctl = gpiochip_get_data(chip);\r\nint ret;\r\nif (sx150x_pin_is_oscio(pctl, offset))\r\nreturn sx150x_gpio_oscio_set(pctl, value);\r\nret = __sx150x_gpio_set(pctl, offset, value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn regmap_write_bits(pctl->regmap,\r\npctl->data->reg_dir,\r\nBIT(offset), 0);\r\n}\r\nstatic void sx150x_irq_mask(struct irq_data *d)\r\n{\r\nstruct sx150x_pinctrl *pctl =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nunsigned int n = d->hwirq;\r\npctl->irq.masked |= BIT(n);\r\n}\r\nstatic void sx150x_irq_unmask(struct irq_data *d)\r\n{\r\nstruct sx150x_pinctrl *pctl =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nunsigned int n = d->hwirq;\r\npctl->irq.masked &= ~BIT(n);\r\n}\r\nstatic void sx150x_irq_set_sense(struct sx150x_pinctrl *pctl,\r\nunsigned int line, unsigned int sense)\r\n{\r\nconst unsigned int n = line * 2;\r\nconst unsigned int mask = ~((SX150X_IRQ_TYPE_EDGE_RISING |\r\nSX150X_IRQ_TYPE_EDGE_FALLING) << n);\r\npctl->irq.sense &= mask;\r\npctl->irq.sense |= sense << n;\r\n}\r\nstatic int sx150x_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nstruct sx150x_pinctrl *pctl =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nunsigned int n, val = 0;\r\nif (flow_type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW))\r\nreturn -EINVAL;\r\nn = d->hwirq;\r\nif (flow_type & IRQ_TYPE_EDGE_RISING)\r\nval |= SX150X_IRQ_TYPE_EDGE_RISING;\r\nif (flow_type & IRQ_TYPE_EDGE_FALLING)\r\nval |= SX150X_IRQ_TYPE_EDGE_FALLING;\r\nsx150x_irq_set_sense(pctl, n, val);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sx150x_irq_thread_fn(int irq, void *dev_id)\r\n{\r\nstruct sx150x_pinctrl *pctl = (struct sx150x_pinctrl *)dev_id;\r\nunsigned long n, status;\r\nunsigned int val;\r\nint err;\r\nerr = regmap_read(pctl->regmap, pctl->data->reg_irq_src, &val);\r\nif (err < 0)\r\nreturn IRQ_NONE;\r\nerr = regmap_write(pctl->regmap, pctl->data->reg_irq_src, val);\r\nif (err < 0)\r\nreturn IRQ_NONE;\r\nstatus = val;\r\nfor_each_set_bit(n, &status, pctl->data->ngpios)\r\nhandle_nested_irq(irq_find_mapping(pctl->gpio.irqdomain, n));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sx150x_irq_bus_lock(struct irq_data *d)\r\n{\r\nstruct sx150x_pinctrl *pctl =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nmutex_lock(&pctl->lock);\r\n}\r\nstatic void sx150x_irq_bus_sync_unlock(struct irq_data *d)\r\n{\r\nstruct sx150x_pinctrl *pctl =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nregmap_write(pctl->regmap, pctl->data->reg_irq_mask, pctl->irq.masked);\r\nregmap_write(pctl->regmap, pctl->data->reg_sense, pctl->irq.sense);\r\nmutex_unlock(&pctl->lock);\r\n}\r\nstatic int sx150x_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *config)\r\n{\r\nstruct sx150x_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned int param = pinconf_to_config_param(*config);\r\nint ret;\r\nu32 arg;\r\nunsigned int data;\r\nif (sx150x_pin_is_oscio(pctl, pin)) {\r\nswitch (param) {\r\ncase PIN_CONFIG_DRIVE_PUSH_PULL:\r\ncase PIN_CONFIG_OUTPUT:\r\nret = regmap_read(pctl->regmap,\r\npctl->data->pri.x789.reg_clock,\r\n&data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (param == PIN_CONFIG_DRIVE_PUSH_PULL)\r\narg = (data & 0x1f) ? 1 : 0;\r\nelse {\r\nif ((data & 0x1f) == 0x1f)\r\narg = 1;\r\nelse if ((data & 0x1f) == 0x10)\r\narg = 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\ngoto out;\r\n}\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nret = regmap_read(pctl->regmap,\r\npctl->data->reg_pulldn,\r\n&data);\r\ndata &= BIT(pin);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!ret)\r\nreturn -EINVAL;\r\narg = 1;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nret = regmap_read(pctl->regmap,\r\npctl->data->reg_pullup,\r\n&data);\r\ndata &= BIT(pin);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!ret)\r\nreturn -EINVAL;\r\narg = 1;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\nif (pctl->data->model != SX150X_789)\r\nreturn -ENOTSUPP;\r\nret = regmap_read(pctl->regmap,\r\npctl->data->pri.x789.reg_drain,\r\n&data);\r\ndata &= BIT(pin);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!data)\r\nreturn -EINVAL;\r\narg = 1;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_PUSH_PULL:\r\nif (pctl->data->model != SX150X_789)\r\narg = true;\r\nelse {\r\nret = regmap_read(pctl->regmap,\r\npctl->data->pri.x789.reg_drain,\r\n&data);\r\ndata &= BIT(pin);\r\nif (ret < 0)\r\nreturn ret;\r\nif (data)\r\nreturn -EINVAL;\r\narg = 1;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\nret = sx150x_gpio_get_direction(&pctl->gpio, pin);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret)\r\nreturn -EINVAL;\r\nret = sx150x_gpio_get(&pctl->gpio, pin);\r\nif (ret < 0)\r\nreturn ret;\r\narg = ret;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nout:\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int sx150x_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *configs, unsigned int num_configs)\r\n{\r\nstruct sx150x_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param;\r\nu32 arg;\r\nint i;\r\nint ret;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nif (sx150x_pin_is_oscio(pctl, pin)) {\r\nif (param == PIN_CONFIG_OUTPUT) {\r\nret = sx150x_gpio_direction_output(&pctl->gpio,\r\npin, arg);\r\nif (ret < 0)\r\nreturn ret;\r\ncontinue;\r\n} else\r\nreturn -ENOTSUPP;\r\n}\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nret = regmap_write_bits(pctl->regmap,\r\npctl->data->reg_pulldn,\r\nBIT(pin), 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_write_bits(pctl->regmap,\r\npctl->data->reg_pullup,\r\nBIT(pin), 0);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nret = regmap_write_bits(pctl->regmap,\r\npctl->data->reg_pullup,\r\nBIT(pin), BIT(pin));\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nret = regmap_write_bits(pctl->regmap,\r\npctl->data->reg_pulldn,\r\nBIT(pin), BIT(pin));\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\nif (pctl->data->model != SX150X_789 ||\r\nsx150x_pin_is_oscio(pctl, pin))\r\nreturn -ENOTSUPP;\r\nret = regmap_write_bits(pctl->regmap,\r\npctl->data->pri.x789.reg_drain,\r\nBIT(pin), BIT(pin));\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_PUSH_PULL:\r\nif (pctl->data->model != SX150X_789 ||\r\nsx150x_pin_is_oscio(pctl, pin))\r\nreturn 0;\r\nret = regmap_write_bits(pctl->regmap,\r\npctl->data->pri.x789.reg_drain,\r\nBIT(pin), 0);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\nret = sx150x_gpio_direction_output(&pctl->gpio,\r\npin, arg);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sx150x_reset(struct sx150x_pinctrl *pctl)\r\n{\r\nint err;\r\nerr = i2c_smbus_write_byte_data(pctl->client,\r\npctl->data->pri.x789.reg_reset,\r\nSX150X_789_RESET_KEY1);\r\nif (err < 0)\r\nreturn err;\r\nerr = i2c_smbus_write_byte_data(pctl->client,\r\npctl->data->pri.x789.reg_reset,\r\nSX150X_789_RESET_KEY2);\r\nreturn err;\r\n}\r\nstatic int sx150x_init_misc(struct sx150x_pinctrl *pctl)\r\n{\r\nu8 reg, value;\r\nswitch (pctl->data->model) {\r\ncase SX150X_789:\r\nreg = pctl->data->pri.x789.reg_misc;\r\nvalue = SX150X_789_REG_MISC_AUTOCLEAR_OFF;\r\nbreak;\r\ncase SX150X_456:\r\nreg = pctl->data->pri.x456.reg_advanced;\r\nvalue = 0x00;\r\nif (!reg)\r\nreturn 0;\r\nbreak;\r\ncase SX150X_123:\r\nreg = pctl->data->pri.x123.reg_advanced;\r\nvalue = 0x00;\r\nbreak;\r\ndefault:\r\nWARN(1, "Unknown chip model %d\n", pctl->data->model);\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_write(pctl->regmap, reg, value);\r\n}\r\nstatic int sx150x_init_hw(struct sx150x_pinctrl *pctl)\r\n{\r\nconst u8 reg[] = {\r\n[SX150X_789] = pctl->data->pri.x789.reg_polarity,\r\n[SX150X_456] = pctl->data->pri.x456.reg_pld_mode,\r\n[SX150X_123] = pctl->data->pri.x123.reg_pld_mode,\r\n};\r\nint err;\r\nif (pctl->data->model == SX150X_789 &&\r\nof_property_read_bool(pctl->dev->of_node, "semtech,probe-reset")) {\r\nerr = sx150x_reset(pctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = sx150x_init_misc(pctl);\r\nif (err < 0)\r\nreturn err;\r\nreturn regmap_write(pctl->regmap, reg[pctl->data->model], 0);\r\n}\r\nstatic int sx150x_regmap_reg_width(struct sx150x_pinctrl *pctl,\r\nunsigned int reg)\r\n{\r\nconst struct sx150x_device_data *data = pctl->data;\r\nif (reg == data->reg_sense) {\r\nreturn 2 * data->ngpios;\r\n} else if ((data->model == SX150X_789 &&\r\n(reg == data->pri.x789.reg_misc ||\r\nreg == data->pri.x789.reg_clock ||\r\nreg == data->pri.x789.reg_reset))\r\n||\r\n(data->model == SX150X_123 &&\r\nreg == data->pri.x123.reg_advanced)\r\n||\r\n(data->model == SX150X_456 &&\r\ndata->pri.x456.reg_advanced &&\r\nreg == data->pri.x456.reg_advanced)) {\r\nreturn 8;\r\n} else {\r\nreturn data->ngpios;\r\n}\r\n}\r\nstatic unsigned int sx150x_maybe_swizzle(struct sx150x_pinctrl *pctl,\r\nunsigned int reg, unsigned int val)\r\n{\r\nunsigned int a, b;\r\nconst struct sx150x_device_data *data = pctl->data;\r\nif (reg == data->reg_sense &&\r\ndata->ngpios == 16 &&\r\n(data->model == SX150X_123 ||\r\ndata->model == SX150X_456)) {\r\na = val & 0x00ff0000;\r\nb = val & 0x0000ff00;\r\nval &= 0xff0000ff;\r\nval |= b << 8;\r\nval |= a >> 8;\r\n}\r\nreturn val;\r\n}\r\nstatic int sx150x_regmap_reg_read(void *context, unsigned int reg,\r\nunsigned int *result)\r\n{\r\nint ret, n;\r\nstruct sx150x_pinctrl *pctl = context;\r\nstruct i2c_client *i2c = pctl->client;\r\nconst int width = sx150x_regmap_reg_width(pctl, reg);\r\nunsigned int idx, val;\r\nfor (n = width, val = 0, idx = reg; n > 0; n -= 8, idx++) {\r\nval <<= 8;\r\nret = i2c_smbus_read_byte_data(i2c, idx);\r\nif (ret < 0)\r\nreturn ret;\r\nval |= ret;\r\n}\r\n*result = sx150x_maybe_swizzle(pctl, reg, val);\r\nreturn 0;\r\n}\r\nstatic int sx150x_regmap_reg_write(void *context, unsigned int reg,\r\nunsigned int val)\r\n{\r\nint ret, n;\r\nstruct sx150x_pinctrl *pctl = context;\r\nstruct i2c_client *i2c = pctl->client;\r\nconst int width = sx150x_regmap_reg_width(pctl, reg);\r\nval = sx150x_maybe_swizzle(pctl, reg, val);\r\nn = (width - 1) & ~7;\r\ndo {\r\nconst u8 byte = (val >> n) & 0xff;\r\nret = i2c_smbus_write_byte_data(i2c, reg, byte);\r\nif (ret < 0)\r\nreturn ret;\r\nreg++;\r\nn -= 8;\r\n} while (n >= 0);\r\nreturn 0;\r\n}\r\nstatic bool sx150x_reg_volatile(struct device *dev, unsigned int reg)\r\n{\r\nstruct sx150x_pinctrl *pctl = i2c_get_clientdata(to_i2c_client(dev));\r\nreturn reg == pctl->data->reg_irq_src || reg == pctl->data->reg_data;\r\n}\r\nstatic int sx150x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstatic const u32 i2c_funcs = I2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WRITE_WORD_DATA;\r\nstruct device *dev = &client->dev;\r\nstruct sx150x_pinctrl *pctl;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter, i2c_funcs))\r\nreturn -ENOSYS;\r\npctl = devm_kzalloc(dev, sizeof(*pctl), GFP_KERNEL);\r\nif (!pctl)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, pctl);\r\npctl->dev = dev;\r\npctl->client = client;\r\nif (dev->of_node)\r\npctl->data = of_device_get_match_data(dev);\r\nelse\r\npctl->data = (struct sx150x_device_data *)id->driver_data;\r\nif (!pctl->data)\r\nreturn -EINVAL;\r\npctl->regmap = devm_regmap_init(dev, NULL, pctl,\r\n&sx150x_regmap_config);\r\nif (IS_ERR(pctl->regmap)) {\r\nret = PTR_ERR(pctl->regmap);\r\ndev_err(dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nmutex_init(&pctl->lock);\r\nret = sx150x_init_hw(pctl);\r\nif (ret)\r\nreturn ret;\r\npctl->gpio.label = devm_kstrdup(dev, client->name, GFP_KERNEL);\r\npctl->gpio.base = -1;\r\npctl->gpio.ngpio = pctl->data->npins;\r\npctl->gpio.get_direction = sx150x_gpio_get_direction;\r\npctl->gpio.direction_input = sx150x_gpio_direction_input;\r\npctl->gpio.direction_output = sx150x_gpio_direction_output;\r\npctl->gpio.get = sx150x_gpio_get;\r\npctl->gpio.set = sx150x_gpio_set;\r\npctl->gpio.set_config = gpiochip_generic_config;\r\npctl->gpio.parent = dev;\r\n#ifdef CONFIG_OF_GPIO\r\npctl->gpio.of_node = dev->of_node;\r\n#endif\r\npctl->gpio.can_sleep = true;\r\nif (pctl->data->model != SX150X_789)\r\npctl->gpio.set_multiple = sx150x_gpio_set_multiple;\r\nret = devm_gpiochip_add_data(dev, &pctl->gpio, pctl);\r\nif (ret)\r\nreturn ret;\r\nif (client->irq > 0) {\r\npctl->irq_chip.name = devm_kstrdup(dev, client->name,\r\nGFP_KERNEL);\r\npctl->irq_chip.irq_mask = sx150x_irq_mask;\r\npctl->irq_chip.irq_unmask = sx150x_irq_unmask;\r\npctl->irq_chip.irq_set_type = sx150x_irq_set_type;\r\npctl->irq_chip.irq_bus_lock = sx150x_irq_bus_lock;\r\npctl->irq_chip.irq_bus_sync_unlock = sx150x_irq_bus_sync_unlock;\r\npctl->irq.masked = ~0;\r\npctl->irq.sense = 0;\r\nret = gpiochip_irqchip_add_nested(&pctl->gpio,\r\n&pctl->irq_chip, 0,\r\nhandle_bad_irq, IRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(dev, "could not connect irqchip to gpiochip\n");\r\nreturn ret;\r\n}\r\nret = devm_request_threaded_irq(dev, client->irq, NULL,\r\nsx150x_irq_thread_fn,\r\nIRQF_ONESHOT | IRQF_SHARED |\r\nIRQF_TRIGGER_FALLING,\r\npctl->irq_chip.name, pctl);\r\nif (ret < 0)\r\nreturn ret;\r\ngpiochip_set_nested_irqchip(&pctl->gpio,\r\n&pctl->irq_chip,\r\nclient->irq);\r\n}\r\npctl->pinctrl_desc.name = "sx150x-pinctrl";\r\npctl->pinctrl_desc.pctlops = &sx150x_pinctrl_ops;\r\npctl->pinctrl_desc.confops = &sx150x_pinconf_ops;\r\npctl->pinctrl_desc.pins = pctl->data->pins;\r\npctl->pinctrl_desc.npins = pctl->data->npins;\r\npctl->pinctrl_desc.owner = THIS_MODULE;\r\npctl->pctldev = pinctrl_register(&pctl->pinctrl_desc, dev, pctl);\r\nif (IS_ERR(pctl->pctldev)) {\r\ndev_err(dev, "Failed to register pinctrl device\n");\r\nreturn PTR_ERR(pctl->pctldev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init sx150x_init(void)\r\n{\r\nreturn i2c_add_driver(&sx150x_driver);\r\n}
