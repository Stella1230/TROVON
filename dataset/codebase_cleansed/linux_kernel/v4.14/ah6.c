static void *ah_alloc_tmp(struct crypto_ahash *ahash, int nfrags,\r\nunsigned int size)\r\n{\r\nunsigned int len;\r\nlen = size + crypto_ahash_digestsize(ahash) +\r\n(crypto_ahash_alignmask(ahash) &\r\n~(crypto_tfm_ctx_alignment() - 1));\r\nlen = ALIGN(len, crypto_tfm_ctx_alignment());\r\nlen += sizeof(struct ahash_request) + crypto_ahash_reqsize(ahash);\r\nlen = ALIGN(len, __alignof__(struct scatterlist));\r\nlen += sizeof(struct scatterlist) * nfrags;\r\nreturn kmalloc(len, GFP_ATOMIC);\r\n}\r\nstatic inline struct tmp_ext *ah_tmp_ext(void *base)\r\n{\r\nreturn base + IPV6HDR_BASELEN;\r\n}\r\nstatic inline u8 *ah_tmp_auth(u8 *tmp, unsigned int offset)\r\n{\r\nreturn tmp + offset;\r\n}\r\nstatic inline u8 *ah_tmp_icv(struct crypto_ahash *ahash, void *tmp,\r\nunsigned int offset)\r\n{\r\nreturn PTR_ALIGN((u8 *)tmp + offset, crypto_ahash_alignmask(ahash) + 1);\r\n}\r\nstatic inline struct ahash_request *ah_tmp_req(struct crypto_ahash *ahash,\r\nu8 *icv)\r\n{\r\nstruct ahash_request *req;\r\nreq = (void *)PTR_ALIGN(icv + crypto_ahash_digestsize(ahash),\r\ncrypto_tfm_ctx_alignment());\r\nahash_request_set_tfm(req, ahash);\r\nreturn req;\r\n}\r\nstatic inline struct scatterlist *ah_req_sg(struct crypto_ahash *ahash,\r\nstruct ahash_request *req)\r\n{\r\nreturn (void *)ALIGN((unsigned long)(req + 1) +\r\ncrypto_ahash_reqsize(ahash),\r\n__alignof__(struct scatterlist));\r\n}\r\nstatic bool zero_out_mutable_opts(struct ipv6_opt_hdr *opthdr)\r\n{\r\nu8 *opt = (u8 *)opthdr;\r\nint len = ipv6_optlen(opthdr);\r\nint off = 0;\r\nint optlen = 0;\r\noff += 2;\r\nlen -= 2;\r\nwhile (len > 0) {\r\nswitch (opt[off]) {\r\ncase IPV6_TLV_PAD1:\r\noptlen = 1;\r\nbreak;\r\ndefault:\r\nif (len < 2)\r\ngoto bad;\r\noptlen = opt[off+1]+2;\r\nif (len < optlen)\r\ngoto bad;\r\nif (opt[off] & 0x20)\r\nmemset(&opt[off+2], 0, opt[off+1]);\r\nbreak;\r\n}\r\noff += optlen;\r\nlen -= optlen;\r\n}\r\nif (len == 0)\r\nreturn true;\r\nbad:\r\nreturn false;\r\n}\r\nstatic void ipv6_rearrange_destopt(struct ipv6hdr *iph, struct ipv6_opt_hdr *destopt)\r\n{\r\nu8 *opt = (u8 *)destopt;\r\nint len = ipv6_optlen(destopt);\r\nint off = 0;\r\nint optlen = 0;\r\noff += 2;\r\nlen -= 2;\r\nwhile (len > 0) {\r\nswitch (opt[off]) {\r\ncase IPV6_TLV_PAD1:\r\noptlen = 1;\r\nbreak;\r\ndefault:\r\nif (len < 2)\r\ngoto bad;\r\noptlen = opt[off+1]+2;\r\nif (len < optlen)\r\ngoto bad;\r\nif (opt[off] == IPV6_TLV_HAO) {\r\nstruct in6_addr final_addr;\r\nstruct ipv6_destopt_hao *hao;\r\nhao = (struct ipv6_destopt_hao *)&opt[off];\r\nif (hao->length != sizeof(hao->addr)) {\r\nnet_warn_ratelimited("destopt hao: invalid header length: %u\n",\r\nhao->length);\r\ngoto bad;\r\n}\r\nfinal_addr = hao->addr;\r\nhao->addr = iph->saddr;\r\niph->saddr = final_addr;\r\n}\r\nbreak;\r\n}\r\noff += optlen;\r\nlen -= optlen;\r\n}\r\nbad:\r\nreturn;\r\n}\r\nstatic void ipv6_rearrange_destopt(struct ipv6hdr *iph, struct ipv6_opt_hdr *destopt) {}\r\nstatic void ipv6_rearrange_rthdr(struct ipv6hdr *iph, struct ipv6_rt_hdr *rthdr)\r\n{\r\nint segments, segments_left;\r\nstruct in6_addr *addrs;\r\nstruct in6_addr final_addr;\r\nsegments_left = rthdr->segments_left;\r\nif (segments_left == 0)\r\nreturn;\r\nrthdr->segments_left = 0;\r\nsegments = rthdr->hdrlen >> 1;\r\naddrs = ((struct rt0_hdr *)rthdr)->addr;\r\nfinal_addr = addrs[segments - 1];\r\naddrs += segments - segments_left;\r\nmemmove(addrs + 1, addrs, (segments_left - 1) * sizeof(*addrs));\r\naddrs[0] = iph->daddr;\r\niph->daddr = final_addr;\r\n}\r\nstatic int ipv6_clear_mutable_options(struct ipv6hdr *iph, int len, int dir)\r\n{\r\nunion {\r\nstruct ipv6hdr *iph;\r\nstruct ipv6_opt_hdr *opth;\r\nstruct ipv6_rt_hdr *rth;\r\nchar *raw;\r\n} exthdr = { .iph = iph };\r\nchar *end = exthdr.raw + len;\r\nint nexthdr = iph->nexthdr;\r\nexthdr.iph++;\r\nwhile (exthdr.raw < end) {\r\nswitch (nexthdr) {\r\ncase NEXTHDR_DEST:\r\nif (dir == XFRM_POLICY_OUT)\r\nipv6_rearrange_destopt(iph, exthdr.opth);\r\ncase NEXTHDR_HOP:\r\nif (!zero_out_mutable_opts(exthdr.opth)) {\r\nnet_dbg_ratelimited("overrun %sopts\n",\r\nnexthdr == NEXTHDR_HOP ?\r\n"hop" : "dest");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase NEXTHDR_ROUTING:\r\nipv6_rearrange_rthdr(iph, exthdr.rth);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nnexthdr = exthdr.opth->nexthdr;\r\nexthdr.raw += ipv6_optlen(exthdr.opth);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ah6_output_done(struct crypto_async_request *base, int err)\r\n{\r\nint extlen;\r\nu8 *iph_base;\r\nu8 *icv;\r\nstruct sk_buff *skb = base->data;\r\nstruct xfrm_state *x = skb_dst(skb)->xfrm;\r\nstruct ah_data *ahp = x->data;\r\nstruct ipv6hdr *top_iph = ipv6_hdr(skb);\r\nstruct ip_auth_hdr *ah = ip_auth_hdr(skb);\r\nstruct tmp_ext *iph_ext;\r\nextlen = skb_network_header_len(skb) - sizeof(struct ipv6hdr);\r\nif (extlen)\r\nextlen += sizeof(*iph_ext);\r\niph_base = AH_SKB_CB(skb)->tmp;\r\niph_ext = ah_tmp_ext(iph_base);\r\nicv = ah_tmp_icv(ahp->ahash, iph_ext, extlen);\r\nmemcpy(ah->auth_data, icv, ahp->icv_trunc_len);\r\nmemcpy(top_iph, iph_base, IPV6HDR_BASELEN);\r\nif (extlen) {\r\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\r\nmemcpy(&top_iph->saddr, iph_ext, extlen);\r\n#else\r\nmemcpy(&top_iph->daddr, iph_ext, extlen);\r\n#endif\r\n}\r\nkfree(AH_SKB_CB(skb)->tmp);\r\nxfrm_output_resume(skb, err);\r\n}\r\nstatic int ah6_output(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nint err;\r\nint nfrags;\r\nint extlen;\r\nu8 *iph_base;\r\nu8 *icv;\r\nu8 nexthdr;\r\nstruct sk_buff *trailer;\r\nstruct crypto_ahash *ahash;\r\nstruct ahash_request *req;\r\nstruct scatterlist *sg;\r\nstruct ipv6hdr *top_iph;\r\nstruct ip_auth_hdr *ah;\r\nstruct ah_data *ahp;\r\nstruct tmp_ext *iph_ext;\r\nint seqhi_len = 0;\r\n__be32 *seqhi;\r\nint sglists = 0;\r\nstruct scatterlist *seqhisg;\r\nahp = x->data;\r\nahash = ahp->ahash;\r\nerr = skb_cow_data(skb, 0, &trailer);\r\nif (err < 0)\r\ngoto out;\r\nnfrags = err;\r\nskb_push(skb, -skb_network_offset(skb));\r\nextlen = skb_network_header_len(skb) - sizeof(struct ipv6hdr);\r\nif (extlen)\r\nextlen += sizeof(*iph_ext);\r\nif (x->props.flags & XFRM_STATE_ESN) {\r\nsglists = 1;\r\nseqhi_len = sizeof(*seqhi);\r\n}\r\nerr = -ENOMEM;\r\niph_base = ah_alloc_tmp(ahash, nfrags + sglists, IPV6HDR_BASELEN +\r\nextlen + seqhi_len);\r\nif (!iph_base)\r\ngoto out;\r\niph_ext = ah_tmp_ext(iph_base);\r\nseqhi = (__be32 *)((char *)iph_ext + extlen);\r\nicv = ah_tmp_icv(ahash, seqhi, seqhi_len);\r\nreq = ah_tmp_req(ahash, icv);\r\nsg = ah_req_sg(ahash, req);\r\nseqhisg = sg + nfrags;\r\nah = ip_auth_hdr(skb);\r\nmemset(ah->auth_data, 0, ahp->icv_trunc_len);\r\ntop_iph = ipv6_hdr(skb);\r\ntop_iph->payload_len = htons(skb->len - sizeof(*top_iph));\r\nnexthdr = *skb_mac_header(skb);\r\n*skb_mac_header(skb) = IPPROTO_AH;\r\nmemcpy(iph_base, top_iph, IPV6HDR_BASELEN);\r\nif (extlen) {\r\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\r\nmemcpy(iph_ext, &top_iph->saddr, extlen);\r\n#else\r\nmemcpy(iph_ext, &top_iph->daddr, extlen);\r\n#endif\r\nerr = ipv6_clear_mutable_options(top_iph,\r\nextlen - sizeof(*iph_ext) +\r\nsizeof(*top_iph),\r\nXFRM_POLICY_OUT);\r\nif (err)\r\ngoto out_free;\r\n}\r\nah->nexthdr = nexthdr;\r\ntop_iph->priority = 0;\r\ntop_iph->flow_lbl[0] = 0;\r\ntop_iph->flow_lbl[1] = 0;\r\ntop_iph->flow_lbl[2] = 0;\r\ntop_iph->hop_limit = 0;\r\nah->hdrlen = (XFRM_ALIGN8(sizeof(*ah) + ahp->icv_trunc_len) >> 2) - 2;\r\nah->reserved = 0;\r\nah->spi = x->id.spi;\r\nah->seq_no = htonl(XFRM_SKB_CB(skb)->seq.output.low);\r\nsg_init_table(sg, nfrags + sglists);\r\nerr = skb_to_sgvec_nomark(skb, sg, 0, skb->len);\r\nif (unlikely(err < 0))\r\ngoto out_free;\r\nif (x->props.flags & XFRM_STATE_ESN) {\r\n*seqhi = htonl(XFRM_SKB_CB(skb)->seq.output.hi);\r\nsg_set_buf(seqhisg, seqhi, seqhi_len);\r\n}\r\nahash_request_set_crypt(req, sg, icv, skb->len + seqhi_len);\r\nahash_request_set_callback(req, 0, ah6_output_done, skb);\r\nAH_SKB_CB(skb)->tmp = iph_base;\r\nerr = crypto_ahash_digest(req);\r\nif (err) {\r\nif (err == -EINPROGRESS)\r\ngoto out;\r\nif (err == -EBUSY)\r\nerr = NET_XMIT_DROP;\r\ngoto out_free;\r\n}\r\nmemcpy(ah->auth_data, icv, ahp->icv_trunc_len);\r\nmemcpy(top_iph, iph_base, IPV6HDR_BASELEN);\r\nif (extlen) {\r\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\r\nmemcpy(&top_iph->saddr, iph_ext, extlen);\r\n#else\r\nmemcpy(&top_iph->daddr, iph_ext, extlen);\r\n#endif\r\n}\r\nout_free:\r\nkfree(iph_base);\r\nout:\r\nreturn err;\r\n}\r\nstatic void ah6_input_done(struct crypto_async_request *base, int err)\r\n{\r\nu8 *auth_data;\r\nu8 *icv;\r\nu8 *work_iph;\r\nstruct sk_buff *skb = base->data;\r\nstruct xfrm_state *x = xfrm_input_state(skb);\r\nstruct ah_data *ahp = x->data;\r\nstruct ip_auth_hdr *ah = ip_auth_hdr(skb);\r\nint hdr_len = skb_network_header_len(skb);\r\nint ah_hlen = (ah->hdrlen + 2) << 2;\r\nif (err)\r\ngoto out;\r\nwork_iph = AH_SKB_CB(skb)->tmp;\r\nauth_data = ah_tmp_auth(work_iph, hdr_len);\r\nicv = ah_tmp_icv(ahp->ahash, auth_data, ahp->icv_trunc_len);\r\nerr = crypto_memneq(icv, auth_data, ahp->icv_trunc_len) ? -EBADMSG : 0;\r\nif (err)\r\ngoto out;\r\nerr = ah->nexthdr;\r\nskb->network_header += ah_hlen;\r\nmemcpy(skb_network_header(skb), work_iph, hdr_len);\r\n__skb_pull(skb, ah_hlen + hdr_len);\r\nif (x->props.mode == XFRM_MODE_TUNNEL)\r\nskb_reset_transport_header(skb);\r\nelse\r\nskb_set_transport_header(skb, -hdr_len);\r\nout:\r\nkfree(AH_SKB_CB(skb)->tmp);\r\nxfrm_input_resume(skb, err);\r\n}\r\nstatic int ah6_input(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nu8 *auth_data;\r\nu8 *icv;\r\nu8 *work_iph;\r\nstruct sk_buff *trailer;\r\nstruct crypto_ahash *ahash;\r\nstruct ahash_request *req;\r\nstruct scatterlist *sg;\r\nstruct ip_auth_hdr *ah;\r\nstruct ipv6hdr *ip6h;\r\nstruct ah_data *ahp;\r\nu16 hdr_len;\r\nu16 ah_hlen;\r\nint nexthdr;\r\nint nfrags;\r\nint err = -ENOMEM;\r\nint seqhi_len = 0;\r\n__be32 *seqhi;\r\nint sglists = 0;\r\nstruct scatterlist *seqhisg;\r\nif (!pskb_may_pull(skb, sizeof(struct ip_auth_hdr)))\r\ngoto out;\r\nif (skb_unclone(skb, GFP_ATOMIC))\r\ngoto out;\r\nskb->ip_summed = CHECKSUM_NONE;\r\nhdr_len = skb_network_header_len(skb);\r\nah = (struct ip_auth_hdr *)skb->data;\r\nahp = x->data;\r\nahash = ahp->ahash;\r\nnexthdr = ah->nexthdr;\r\nah_hlen = (ah->hdrlen + 2) << 2;\r\nif (ah_hlen != XFRM_ALIGN8(sizeof(*ah) + ahp->icv_full_len) &&\r\nah_hlen != XFRM_ALIGN8(sizeof(*ah) + ahp->icv_trunc_len))\r\ngoto out;\r\nif (!pskb_may_pull(skb, ah_hlen))\r\ngoto out;\r\nerr = skb_cow_data(skb, 0, &trailer);\r\nif (err < 0)\r\ngoto out;\r\nnfrags = err;\r\nah = (struct ip_auth_hdr *)skb->data;\r\nip6h = ipv6_hdr(skb);\r\nskb_push(skb, hdr_len);\r\nif (x->props.flags & XFRM_STATE_ESN) {\r\nsglists = 1;\r\nseqhi_len = sizeof(*seqhi);\r\n}\r\nwork_iph = ah_alloc_tmp(ahash, nfrags + sglists, hdr_len +\r\nahp->icv_trunc_len + seqhi_len);\r\nif (!work_iph) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nauth_data = ah_tmp_auth((u8 *)work_iph, hdr_len);\r\nseqhi = (__be32 *)(auth_data + ahp->icv_trunc_len);\r\nicv = ah_tmp_icv(ahash, seqhi, seqhi_len);\r\nreq = ah_tmp_req(ahash, icv);\r\nsg = ah_req_sg(ahash, req);\r\nseqhisg = sg + nfrags;\r\nmemcpy(work_iph, ip6h, hdr_len);\r\nmemcpy(auth_data, ah->auth_data, ahp->icv_trunc_len);\r\nmemset(ah->auth_data, 0, ahp->icv_trunc_len);\r\nif (ipv6_clear_mutable_options(ip6h, hdr_len, XFRM_POLICY_IN))\r\ngoto out_free;\r\nip6h->priority = 0;\r\nip6h->flow_lbl[0] = 0;\r\nip6h->flow_lbl[1] = 0;\r\nip6h->flow_lbl[2] = 0;\r\nip6h->hop_limit = 0;\r\nsg_init_table(sg, nfrags + sglists);\r\nerr = skb_to_sgvec_nomark(skb, sg, 0, skb->len);\r\nif (unlikely(err < 0))\r\ngoto out_free;\r\nif (x->props.flags & XFRM_STATE_ESN) {\r\n*seqhi = XFRM_SKB_CB(skb)->seq.input.hi;\r\nsg_set_buf(seqhisg, seqhi, seqhi_len);\r\n}\r\nahash_request_set_crypt(req, sg, icv, skb->len + seqhi_len);\r\nahash_request_set_callback(req, 0, ah6_input_done, skb);\r\nAH_SKB_CB(skb)->tmp = work_iph;\r\nerr = crypto_ahash_digest(req);\r\nif (err) {\r\nif (err == -EINPROGRESS)\r\ngoto out;\r\ngoto out_free;\r\n}\r\nerr = crypto_memneq(icv, auth_data, ahp->icv_trunc_len) ? -EBADMSG : 0;\r\nif (err)\r\ngoto out_free;\r\nskb->network_header += ah_hlen;\r\nmemcpy(skb_network_header(skb), work_iph, hdr_len);\r\n__skb_pull(skb, ah_hlen + hdr_len);\r\nif (x->props.mode == XFRM_MODE_TUNNEL)\r\nskb_reset_transport_header(skb);\r\nelse\r\nskb_set_transport_header(skb, -hdr_len);\r\nerr = nexthdr;\r\nout_free:\r\nkfree(work_iph);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ah6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\r\nu8 type, u8 code, int offset, __be32 info)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nstruct ipv6hdr *iph = (struct ipv6hdr *)skb->data;\r\nstruct ip_auth_hdr *ah = (struct ip_auth_hdr *)(skb->data+offset);\r\nstruct xfrm_state *x;\r\nif (type != ICMPV6_PKT_TOOBIG &&\r\ntype != NDISC_REDIRECT)\r\nreturn 0;\r\nx = xfrm_state_lookup(net, skb->mark, (xfrm_address_t *)&iph->daddr, ah->spi, IPPROTO_AH, AF_INET6);\r\nif (!x)\r\nreturn 0;\r\nif (type == NDISC_REDIRECT)\r\nip6_redirect(skb, net, skb->dev->ifindex, 0,\r\nsock_net_uid(net, NULL));\r\nelse\r\nip6_update_pmtu(skb, net, info, 0, 0, sock_net_uid(net, NULL));\r\nxfrm_state_put(x);\r\nreturn 0;\r\n}\r\nstatic int ah6_init_state(struct xfrm_state *x)\r\n{\r\nstruct ah_data *ahp = NULL;\r\nstruct xfrm_algo_desc *aalg_desc;\r\nstruct crypto_ahash *ahash;\r\nif (!x->aalg)\r\ngoto error;\r\nif (x->encap)\r\ngoto error;\r\nahp = kzalloc(sizeof(*ahp), GFP_KERNEL);\r\nif (!ahp)\r\nreturn -ENOMEM;\r\nahash = crypto_alloc_ahash(x->aalg->alg_name, 0, 0);\r\nif (IS_ERR(ahash))\r\ngoto error;\r\nahp->ahash = ahash;\r\nif (crypto_ahash_setkey(ahash, x->aalg->alg_key,\r\n(x->aalg->alg_key_len + 7) / 8))\r\ngoto error;\r\naalg_desc = xfrm_aalg_get_byname(x->aalg->alg_name, 0);\r\nBUG_ON(!aalg_desc);\r\nif (aalg_desc->uinfo.auth.icv_fullbits/8 !=\r\ncrypto_ahash_digestsize(ahash)) {\r\npr_info("AH: %s digestsize %u != %hu\n",\r\nx->aalg->alg_name, crypto_ahash_digestsize(ahash),\r\naalg_desc->uinfo.auth.icv_fullbits/8);\r\ngoto error;\r\n}\r\nahp->icv_full_len = aalg_desc->uinfo.auth.icv_fullbits/8;\r\nahp->icv_trunc_len = x->aalg->alg_trunc_len/8;\r\nx->props.header_len = XFRM_ALIGN8(sizeof(struct ip_auth_hdr) +\r\nahp->icv_trunc_len);\r\nswitch (x->props.mode) {\r\ncase XFRM_MODE_BEET:\r\ncase XFRM_MODE_TRANSPORT:\r\nbreak;\r\ncase XFRM_MODE_TUNNEL:\r\nx->props.header_len += sizeof(struct ipv6hdr);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nx->data = ahp;\r\nreturn 0;\r\nerror:\r\nif (ahp) {\r\ncrypto_free_ahash(ahp->ahash);\r\nkfree(ahp);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void ah6_destroy(struct xfrm_state *x)\r\n{\r\nstruct ah_data *ahp = x->data;\r\nif (!ahp)\r\nreturn;\r\ncrypto_free_ahash(ahp->ahash);\r\nkfree(ahp);\r\n}\r\nstatic int ah6_rcv_cb(struct sk_buff *skb, int err)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init ah6_init(void)\r\n{\r\nif (xfrm_register_type(&ah6_type, AF_INET6) < 0) {\r\npr_info("%s: can't add xfrm type\n", __func__);\r\nreturn -EAGAIN;\r\n}\r\nif (xfrm6_protocol_register(&ah6_protocol, IPPROTO_AH) < 0) {\r\npr_info("%s: can't add protocol\n", __func__);\r\nxfrm_unregister_type(&ah6_type, AF_INET6);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit ah6_fini(void)\r\n{\r\nif (xfrm6_protocol_deregister(&ah6_protocol, IPPROTO_AH) < 0)\r\npr_info("%s: can't remove protocol\n", __func__);\r\nif (xfrm_unregister_type(&ah6_type, AF_INET6) < 0)\r\npr_info("%s: can't remove xfrm type\n", __func__);\r\n}
