static enum smi_action __smi_handle_dr_smp_send(bool is_switch, int port_num,\r\nu8 *hop_ptr, u8 hop_cnt,\r\nconst u8 *initial_path,\r\nconst u8 *return_path,\r\nu8 direction,\r\nbool dr_dlid_is_permissive,\r\nbool dr_slid_is_permissive)\r\n{\r\nif (hop_cnt >= IB_SMP_MAX_PATH_HOPS)\r\nreturn IB_SMI_DISCARD;\r\nif (!direction) {\r\nif (hop_cnt && *hop_ptr == 0) {\r\n(*hop_ptr)++;\r\nreturn (initial_path[*hop_ptr] ==\r\nport_num ? IB_SMI_HANDLE : IB_SMI_DISCARD);\r\n}\r\nif (*hop_ptr && *hop_ptr < hop_cnt) {\r\nif (!is_switch)\r\nreturn IB_SMI_DISCARD;\r\n(*hop_ptr)++;\r\nreturn (initial_path[*hop_ptr] ==\r\nport_num ? IB_SMI_HANDLE : IB_SMI_DISCARD);\r\n}\r\nif (*hop_ptr == hop_cnt) {\r\n(*hop_ptr)++;\r\nreturn (is_switch ||\r\ndr_dlid_is_permissive ?\r\nIB_SMI_HANDLE : IB_SMI_DISCARD);\r\n}\r\nreturn (*hop_ptr == hop_cnt + 1 ? IB_SMI_HANDLE : IB_SMI_DISCARD);\r\n} else {\r\nif (hop_cnt && *hop_ptr == hop_cnt + 1) {\r\n(*hop_ptr)--;\r\nreturn (return_path[*hop_ptr] ==\r\nport_num ? IB_SMI_HANDLE : IB_SMI_DISCARD);\r\n}\r\nif (2 <= *hop_ptr && *hop_ptr <= hop_cnt) {\r\nif (!is_switch)\r\nreturn IB_SMI_DISCARD;\r\n(*hop_ptr)--;\r\nreturn (return_path[*hop_ptr] ==\r\nport_num ? IB_SMI_HANDLE : IB_SMI_DISCARD);\r\n}\r\nif (*hop_ptr == 1) {\r\n(*hop_ptr)--;\r\nreturn (is_switch ||\r\ndr_slid_is_permissive ?\r\nIB_SMI_HANDLE : IB_SMI_DISCARD);\r\n}\r\nif (*hop_ptr == 0)\r\nreturn IB_SMI_HANDLE;\r\nreturn IB_SMI_DISCARD;\r\n}\r\n}\r\nenum smi_action smi_handle_dr_smp_send(struct ib_smp *smp,\r\nbool is_switch, int port_num)\r\n{\r\nreturn __smi_handle_dr_smp_send(is_switch, port_num,\r\n&smp->hop_ptr, smp->hop_cnt,\r\nsmp->initial_path,\r\nsmp->return_path,\r\nib_get_smp_direction(smp),\r\nsmp->dr_dlid == IB_LID_PERMISSIVE,\r\nsmp->dr_slid == IB_LID_PERMISSIVE);\r\n}\r\nenum smi_action opa_smi_handle_dr_smp_send(struct opa_smp *smp,\r\nbool is_switch, int port_num)\r\n{\r\nreturn __smi_handle_dr_smp_send(is_switch, port_num,\r\n&smp->hop_ptr, smp->hop_cnt,\r\nsmp->route.dr.initial_path,\r\nsmp->route.dr.return_path,\r\nopa_get_smp_direction(smp),\r\nsmp->route.dr.dr_dlid ==\r\nOPA_LID_PERMISSIVE,\r\nsmp->route.dr.dr_slid ==\r\nOPA_LID_PERMISSIVE);\r\n}\r\nstatic enum smi_action __smi_handle_dr_smp_recv(bool is_switch, int port_num,\r\nint phys_port_cnt,\r\nu8 *hop_ptr, u8 hop_cnt,\r\nconst u8 *initial_path,\r\nu8 *return_path,\r\nu8 direction,\r\nbool dr_dlid_is_permissive,\r\nbool dr_slid_is_permissive)\r\n{\r\nif (hop_cnt >= IB_SMP_MAX_PATH_HOPS)\r\nreturn IB_SMI_DISCARD;\r\nif (!direction) {\r\nif (hop_cnt && *hop_ptr == 0)\r\nreturn IB_SMI_DISCARD;\r\nif (*hop_ptr && *hop_ptr < hop_cnt) {\r\nif (!is_switch)\r\nreturn IB_SMI_DISCARD;\r\nreturn_path[*hop_ptr] = port_num;\r\nreturn (initial_path[*hop_ptr+1] <= phys_port_cnt ?\r\nIB_SMI_HANDLE : IB_SMI_DISCARD);\r\n}\r\nif (*hop_ptr == hop_cnt) {\r\nif (hop_cnt)\r\nreturn_path[*hop_ptr] = port_num;\r\nreturn (is_switch ||\r\ndr_dlid_is_permissive ?\r\nIB_SMI_HANDLE : IB_SMI_DISCARD);\r\n}\r\nreturn (*hop_ptr == hop_cnt + 1 ? IB_SMI_HANDLE : IB_SMI_DISCARD);\r\n} else {\r\nif (hop_cnt && *hop_ptr == hop_cnt + 1) {\r\n(*hop_ptr)--;\r\nreturn (return_path[*hop_ptr] ==\r\nport_num ? IB_SMI_HANDLE : IB_SMI_DISCARD);\r\n}\r\nif (2 <= *hop_ptr && *hop_ptr <= hop_cnt) {\r\nif (!is_switch)\r\nreturn IB_SMI_DISCARD;\r\nreturn (return_path[*hop_ptr-1] <= phys_port_cnt ?\r\nIB_SMI_HANDLE : IB_SMI_DISCARD);\r\n}\r\nif (*hop_ptr == 1) {\r\nif (dr_slid_is_permissive) {\r\n(*hop_ptr)--;\r\nreturn IB_SMI_HANDLE;\r\n}\r\nreturn (is_switch ? IB_SMI_HANDLE : IB_SMI_DISCARD);\r\n}\r\nreturn (*hop_ptr == 0 ? IB_SMI_HANDLE : IB_SMI_DISCARD);\r\n}\r\n}\r\nenum smi_action smi_handle_dr_smp_recv(struct ib_smp *smp, bool is_switch,\r\nint port_num, int phys_port_cnt)\r\n{\r\nreturn __smi_handle_dr_smp_recv(is_switch, port_num, phys_port_cnt,\r\n&smp->hop_ptr, smp->hop_cnt,\r\nsmp->initial_path,\r\nsmp->return_path,\r\nib_get_smp_direction(smp),\r\nsmp->dr_dlid == IB_LID_PERMISSIVE,\r\nsmp->dr_slid == IB_LID_PERMISSIVE);\r\n}\r\nenum smi_action opa_smi_handle_dr_smp_recv(struct opa_smp *smp, bool is_switch,\r\nint port_num, int phys_port_cnt)\r\n{\r\nreturn __smi_handle_dr_smp_recv(is_switch, port_num, phys_port_cnt,\r\n&smp->hop_ptr, smp->hop_cnt,\r\nsmp->route.dr.initial_path,\r\nsmp->route.dr.return_path,\r\nopa_get_smp_direction(smp),\r\nsmp->route.dr.dr_dlid ==\r\nOPA_LID_PERMISSIVE,\r\nsmp->route.dr.dr_slid ==\r\nOPA_LID_PERMISSIVE);\r\n}\r\nstatic enum smi_forward_action __smi_check_forward_dr_smp(u8 hop_ptr, u8 hop_cnt,\r\nu8 direction,\r\nbool dr_dlid_is_permissive,\r\nbool dr_slid_is_permissive)\r\n{\r\nif (!direction) {\r\nif (hop_ptr && hop_ptr < hop_cnt)\r\nreturn IB_SMI_FORWARD;\r\nif (hop_ptr == hop_cnt)\r\nreturn (dr_dlid_is_permissive ?\r\nIB_SMI_SEND : IB_SMI_LOCAL);\r\nif (hop_ptr == hop_cnt + 1)\r\nreturn IB_SMI_SEND;\r\n} else {\r\nif (2 <= hop_ptr && hop_ptr <= hop_cnt)\r\nreturn IB_SMI_FORWARD;\r\nif (hop_ptr == 1)\r\nreturn (!dr_slid_is_permissive ?\r\nIB_SMI_SEND : IB_SMI_LOCAL);\r\n}\r\nreturn IB_SMI_LOCAL;\r\n}\r\nenum smi_forward_action smi_check_forward_dr_smp(struct ib_smp *smp)\r\n{\r\nreturn __smi_check_forward_dr_smp(smp->hop_ptr, smp->hop_cnt,\r\nib_get_smp_direction(smp),\r\nsmp->dr_dlid == IB_LID_PERMISSIVE,\r\nsmp->dr_slid == IB_LID_PERMISSIVE);\r\n}\r\nenum smi_forward_action opa_smi_check_forward_dr_smp(struct opa_smp *smp)\r\n{\r\nreturn __smi_check_forward_dr_smp(smp->hop_ptr, smp->hop_cnt,\r\nopa_get_smp_direction(smp),\r\nsmp->route.dr.dr_dlid ==\r\nOPA_LID_PERMISSIVE,\r\nsmp->route.dr.dr_slid ==\r\nOPA_LID_PERMISSIVE);\r\n}\r\nint smi_get_fwd_port(struct ib_smp *smp)\r\n{\r\nreturn (!ib_get_smp_direction(smp) ? smp->initial_path[smp->hop_ptr+1] :\r\nsmp->return_path[smp->hop_ptr-1]);\r\n}\r\nint opa_smi_get_fwd_port(struct opa_smp *smp)\r\n{\r\nreturn !opa_get_smp_direction(smp) ? smp->route.dr.initial_path[smp->hop_ptr+1] :\r\nsmp->route.dr.return_path[smp->hop_ptr-1];\r\n}
