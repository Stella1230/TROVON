static int i915_pipe_crc_open(struct inode *inode, struct file *filep)\r\n{\r\nstruct pipe_crc_info *info = inode->i_private;\r\nstruct drm_i915_private *dev_priv = info->dev_priv;\r\nstruct intel_pipe_crc *pipe_crc = &dev_priv->pipe_crc[info->pipe];\r\nif (info->pipe >= INTEL_INFO(dev_priv)->num_pipes)\r\nreturn -ENODEV;\r\nspin_lock_irq(&pipe_crc->lock);\r\nif (pipe_crc->opened) {\r\nspin_unlock_irq(&pipe_crc->lock);\r\nreturn -EBUSY;\r\n}\r\npipe_crc->opened = true;\r\nfilep->private_data = inode->i_private;\r\nspin_unlock_irq(&pipe_crc->lock);\r\nreturn 0;\r\n}\r\nstatic int i915_pipe_crc_release(struct inode *inode, struct file *filep)\r\n{\r\nstruct pipe_crc_info *info = inode->i_private;\r\nstruct drm_i915_private *dev_priv = info->dev_priv;\r\nstruct intel_pipe_crc *pipe_crc = &dev_priv->pipe_crc[info->pipe];\r\nspin_lock_irq(&pipe_crc->lock);\r\npipe_crc->opened = false;\r\nspin_unlock_irq(&pipe_crc->lock);\r\nreturn 0;\r\n}\r\nstatic int pipe_crc_data_count(struct intel_pipe_crc *pipe_crc)\r\n{\r\nlockdep_assert_held(&pipe_crc->lock);\r\nreturn CIRC_CNT(pipe_crc->head, pipe_crc->tail,\r\nINTEL_PIPE_CRC_ENTRIES_NR);\r\n}\r\nstatic ssize_t\r\ni915_pipe_crc_read(struct file *filep, char __user *user_buf, size_t count,\r\nloff_t *pos)\r\n{\r\nstruct pipe_crc_info *info = filep->private_data;\r\nstruct drm_i915_private *dev_priv = info->dev_priv;\r\nstruct intel_pipe_crc *pipe_crc = &dev_priv->pipe_crc[info->pipe];\r\nchar buf[PIPE_CRC_BUFFER_LEN];\r\nint n_entries;\r\nssize_t bytes_read;\r\nif (count < PIPE_CRC_LINE_LEN)\r\nreturn -EINVAL;\r\nif (pipe_crc->source == INTEL_PIPE_CRC_SOURCE_NONE)\r\nreturn 0;\r\nspin_lock_irq(&pipe_crc->lock);\r\nwhile (pipe_crc_data_count(pipe_crc) == 0) {\r\nint ret;\r\nif (filep->f_flags & O_NONBLOCK) {\r\nspin_unlock_irq(&pipe_crc->lock);\r\nreturn -EAGAIN;\r\n}\r\nret = wait_event_interruptible_lock_irq(pipe_crc->wq,\r\npipe_crc_data_count(pipe_crc), pipe_crc->lock);\r\nif (ret) {\r\nspin_unlock_irq(&pipe_crc->lock);\r\nreturn ret;\r\n}\r\n}\r\nn_entries = count / PIPE_CRC_LINE_LEN;\r\nbytes_read = 0;\r\nwhile (n_entries > 0) {\r\nstruct intel_pipe_crc_entry *entry =\r\n&pipe_crc->entries[pipe_crc->tail];\r\nif (CIRC_CNT(pipe_crc->head, pipe_crc->tail,\r\nINTEL_PIPE_CRC_ENTRIES_NR) < 1)\r\nbreak;\r\nBUILD_BUG_ON_NOT_POWER_OF_2(INTEL_PIPE_CRC_ENTRIES_NR);\r\npipe_crc->tail = (pipe_crc->tail + 1) &\r\n(INTEL_PIPE_CRC_ENTRIES_NR - 1);\r\nbytes_read += snprintf(buf, PIPE_CRC_BUFFER_LEN,\r\n"%8u %8x %8x %8x %8x %8x\n",\r\nentry->frame, entry->crc[0],\r\nentry->crc[1], entry->crc[2],\r\nentry->crc[3], entry->crc[4]);\r\nspin_unlock_irq(&pipe_crc->lock);\r\nif (copy_to_user(user_buf, buf, PIPE_CRC_LINE_LEN))\r\nreturn -EFAULT;\r\nuser_buf += PIPE_CRC_LINE_LEN;\r\nn_entries--;\r\nspin_lock_irq(&pipe_crc->lock);\r\n}\r\nspin_unlock_irq(&pipe_crc->lock);\r\nreturn bytes_read;\r\n}\r\nstatic const char *pipe_crc_source_name(enum intel_pipe_crc_source source)\r\n{\r\nBUILD_BUG_ON(ARRAY_SIZE(pipe_crc_sources) != INTEL_PIPE_CRC_SOURCE_MAX);\r\nreturn pipe_crc_sources[source];\r\n}\r\nstatic int display_crc_ctl_show(struct seq_file *m, void *data)\r\n{\r\nstruct drm_i915_private *dev_priv = m->private;\r\nint i;\r\nfor (i = 0; i < I915_MAX_PIPES; i++)\r\nseq_printf(m, "%c %s\n", pipe_name(i),\r\npipe_crc_source_name(dev_priv->pipe_crc[i].source));\r\nreturn 0;\r\n}\r\nstatic int display_crc_ctl_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, display_crc_ctl_show, inode->i_private);\r\n}\r\nstatic int i8xx_pipe_crc_ctl_reg(enum intel_pipe_crc_source *source,\r\nuint32_t *val)\r\n{\r\nif (*source == INTEL_PIPE_CRC_SOURCE_AUTO)\r\n*source = INTEL_PIPE_CRC_SOURCE_PIPE;\r\nswitch (*source) {\r\ncase INTEL_PIPE_CRC_SOURCE_PIPE:\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_INCLUDE_BORDER_I8XX;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_NONE:\r\n*val = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i9xx_pipe_crc_auto_source(struct drm_i915_private *dev_priv,\r\nenum pipe pipe,\r\nenum intel_pipe_crc_source *source)\r\n{\r\nstruct drm_device *dev = &dev_priv->drm;\r\nstruct intel_encoder *encoder;\r\nstruct intel_crtc *crtc;\r\nstruct intel_digital_port *dig_port;\r\nint ret = 0;\r\n*source = INTEL_PIPE_CRC_SOURCE_PIPE;\r\ndrm_modeset_lock_all(dev);\r\nfor_each_intel_encoder(dev, encoder) {\r\nif (!encoder->base.crtc)\r\ncontinue;\r\ncrtc = to_intel_crtc(encoder->base.crtc);\r\nif (crtc->pipe != pipe)\r\ncontinue;\r\nswitch (encoder->type) {\r\ncase INTEL_OUTPUT_TVOUT:\r\n*source = INTEL_PIPE_CRC_SOURCE_TV;\r\nbreak;\r\ncase INTEL_OUTPUT_DP:\r\ncase INTEL_OUTPUT_EDP:\r\ndig_port = enc_to_dig_port(&encoder->base);\r\nswitch (dig_port->port) {\r\ncase PORT_B:\r\n*source = INTEL_PIPE_CRC_SOURCE_DP_B;\r\nbreak;\r\ncase PORT_C:\r\n*source = INTEL_PIPE_CRC_SOURCE_DP_C;\r\nbreak;\r\ncase PORT_D:\r\n*source = INTEL_PIPE_CRC_SOURCE_DP_D;\r\nbreak;\r\ndefault:\r\nWARN(1, "nonexisting DP port %c\n",\r\nport_name(dig_port->port));\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ndrm_modeset_unlock_all(dev);\r\nreturn ret;\r\n}\r\nstatic int vlv_pipe_crc_ctl_reg(struct drm_i915_private *dev_priv,\r\nenum pipe pipe,\r\nenum intel_pipe_crc_source *source,\r\nuint32_t *val)\r\n{\r\nbool need_stable_symbols = false;\r\nif (*source == INTEL_PIPE_CRC_SOURCE_AUTO) {\r\nint ret = i9xx_pipe_crc_auto_source(dev_priv, pipe, source);\r\nif (ret)\r\nreturn ret;\r\n}\r\nswitch (*source) {\r\ncase INTEL_PIPE_CRC_SOURCE_PIPE:\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_PIPE_VLV;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_DP_B:\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_DP_B_VLV;\r\nneed_stable_symbols = true;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_DP_C:\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_DP_C_VLV;\r\nneed_stable_symbols = true;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_DP_D:\r\nif (!IS_CHERRYVIEW(dev_priv))\r\nreturn -EINVAL;\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_DP_D_VLV;\r\nneed_stable_symbols = true;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_NONE:\r\n*val = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (need_stable_symbols) {\r\nuint32_t tmp = I915_READ(PORT_DFT2_G4X);\r\ntmp |= DC_BALANCE_RESET_VLV;\r\nswitch (pipe) {\r\ncase PIPE_A:\r\ntmp |= PIPE_A_SCRAMBLE_RESET;\r\nbreak;\r\ncase PIPE_B:\r\ntmp |= PIPE_B_SCRAMBLE_RESET;\r\nbreak;\r\ncase PIPE_C:\r\ntmp |= PIPE_C_SCRAMBLE_RESET;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nI915_WRITE(PORT_DFT2_G4X, tmp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int i9xx_pipe_crc_ctl_reg(struct drm_i915_private *dev_priv,\r\nenum pipe pipe,\r\nenum intel_pipe_crc_source *source,\r\nuint32_t *val)\r\n{\r\nbool need_stable_symbols = false;\r\nif (*source == INTEL_PIPE_CRC_SOURCE_AUTO) {\r\nint ret = i9xx_pipe_crc_auto_source(dev_priv, pipe, source);\r\nif (ret)\r\nreturn ret;\r\n}\r\nswitch (*source) {\r\ncase INTEL_PIPE_CRC_SOURCE_PIPE:\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_PIPE_I9XX;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_TV:\r\nif (!SUPPORTS_TV(dev_priv))\r\nreturn -EINVAL;\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_TV_PRE;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_DP_B:\r\nif (!IS_G4X(dev_priv))\r\nreturn -EINVAL;\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_DP_B_G4X;\r\nneed_stable_symbols = true;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_DP_C:\r\nif (!IS_G4X(dev_priv))\r\nreturn -EINVAL;\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_DP_C_G4X;\r\nneed_stable_symbols = true;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_DP_D:\r\nif (!IS_G4X(dev_priv))\r\nreturn -EINVAL;\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_DP_D_G4X;\r\nneed_stable_symbols = true;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_NONE:\r\n*val = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (need_stable_symbols) {\r\nuint32_t tmp = I915_READ(PORT_DFT2_G4X);\r\nWARN_ON(!IS_G4X(dev_priv));\r\nI915_WRITE(PORT_DFT_I9XX,\r\nI915_READ(PORT_DFT_I9XX) | DC_BALANCE_RESET);\r\nif (pipe == PIPE_A)\r\ntmp |= PIPE_A_SCRAMBLE_RESET;\r\nelse\r\ntmp |= PIPE_B_SCRAMBLE_RESET;\r\nI915_WRITE(PORT_DFT2_G4X, tmp);\r\n}\r\nreturn 0;\r\n}\r\nstatic void vlv_undo_pipe_scramble_reset(struct drm_i915_private *dev_priv,\r\nenum pipe pipe)\r\n{\r\nuint32_t tmp = I915_READ(PORT_DFT2_G4X);\r\nswitch (pipe) {\r\ncase PIPE_A:\r\ntmp &= ~PIPE_A_SCRAMBLE_RESET;\r\nbreak;\r\ncase PIPE_B:\r\ntmp &= ~PIPE_B_SCRAMBLE_RESET;\r\nbreak;\r\ncase PIPE_C:\r\ntmp &= ~PIPE_C_SCRAMBLE_RESET;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (!(tmp & PIPE_SCRAMBLE_RESET_MASK))\r\ntmp &= ~DC_BALANCE_RESET_VLV;\r\nI915_WRITE(PORT_DFT2_G4X, tmp);\r\n}\r\nstatic void g4x_undo_pipe_scramble_reset(struct drm_i915_private *dev_priv,\r\nenum pipe pipe)\r\n{\r\nuint32_t tmp = I915_READ(PORT_DFT2_G4X);\r\nif (pipe == PIPE_A)\r\ntmp &= ~PIPE_A_SCRAMBLE_RESET;\r\nelse\r\ntmp &= ~PIPE_B_SCRAMBLE_RESET;\r\nI915_WRITE(PORT_DFT2_G4X, tmp);\r\nif (!(tmp & PIPE_SCRAMBLE_RESET_MASK)) {\r\nI915_WRITE(PORT_DFT_I9XX,\r\nI915_READ(PORT_DFT_I9XX) & ~DC_BALANCE_RESET);\r\n}\r\n}\r\nstatic int ilk_pipe_crc_ctl_reg(enum intel_pipe_crc_source *source,\r\nuint32_t *val)\r\n{\r\nif (*source == INTEL_PIPE_CRC_SOURCE_AUTO)\r\n*source = INTEL_PIPE_CRC_SOURCE_PIPE;\r\nswitch (*source) {\r\ncase INTEL_PIPE_CRC_SOURCE_PLANE1:\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_PRIMARY_ILK;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_PLANE2:\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_SPRITE_ILK;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_PIPE:\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_PIPE_ILK;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_NONE:\r\n*val = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hsw_trans_edp_pipe_A_crc_wa(struct drm_i915_private *dev_priv,\r\nbool enable)\r\n{\r\nstruct drm_device *dev = &dev_priv->drm;\r\nstruct intel_crtc *crtc = intel_get_crtc_for_pipe(dev_priv, PIPE_A);\r\nstruct intel_crtc_state *pipe_config;\r\nstruct drm_atomic_state *state;\r\nstruct drm_modeset_acquire_ctx ctx;\r\nint ret = 0;\r\ndrm_modeset_acquire_init(&ctx, 0);\r\nstate = drm_atomic_state_alloc(dev);\r\nif (!state) {\r\nret = -ENOMEM;\r\ngoto unlock;\r\n}\r\nstate->acquire_ctx = &ctx;\r\nretry:\r\npipe_config = intel_atomic_get_crtc_state(state, crtc);\r\nif (IS_ERR(pipe_config)) {\r\nret = PTR_ERR(pipe_config);\r\ngoto put_state;\r\n}\r\npipe_config->pch_pfit.force_thru = enable;\r\nif (pipe_config->cpu_transcoder == TRANSCODER_EDP &&\r\npipe_config->pch_pfit.enabled != enable)\r\npipe_config->base.connectors_changed = true;\r\nret = drm_atomic_commit(state);\r\nput_state:\r\nif (ret == -EDEADLK) {\r\ndrm_atomic_state_clear(state);\r\ndrm_modeset_backoff(&ctx);\r\ngoto retry;\r\n}\r\ndrm_atomic_state_put(state);\r\nunlock:\r\nWARN(ret, "Toggling workaround to %i returns %i\n", enable, ret);\r\ndrm_modeset_drop_locks(&ctx);\r\ndrm_modeset_acquire_fini(&ctx);\r\n}\r\nstatic int ivb_pipe_crc_ctl_reg(struct drm_i915_private *dev_priv,\r\nenum pipe pipe,\r\nenum intel_pipe_crc_source *source,\r\nuint32_t *val)\r\n{\r\nif (*source == INTEL_PIPE_CRC_SOURCE_AUTO)\r\n*source = INTEL_PIPE_CRC_SOURCE_PF;\r\nswitch (*source) {\r\ncase INTEL_PIPE_CRC_SOURCE_PLANE1:\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_PRIMARY_IVB;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_PLANE2:\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_SPRITE_IVB;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_PF:\r\nif (IS_HASWELL(dev_priv) && pipe == PIPE_A)\r\nhsw_trans_edp_pipe_A_crc_wa(dev_priv, true);\r\n*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_PF_IVB;\r\nbreak;\r\ncase INTEL_PIPE_CRC_SOURCE_NONE:\r\n*val = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_new_crc_ctl_reg(struct drm_i915_private *dev_priv,\r\nenum pipe pipe,\r\nenum intel_pipe_crc_source *source, u32 *val)\r\n{\r\nif (IS_GEN2(dev_priv))\r\nreturn i8xx_pipe_crc_ctl_reg(source, val);\r\nelse if (INTEL_GEN(dev_priv) < 5)\r\nreturn i9xx_pipe_crc_ctl_reg(dev_priv, pipe, source, val);\r\nelse if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\r\nreturn vlv_pipe_crc_ctl_reg(dev_priv, pipe, source, val);\r\nelse if (IS_GEN5(dev_priv) || IS_GEN6(dev_priv))\r\nreturn ilk_pipe_crc_ctl_reg(source, val);\r\nelse\r\nreturn ivb_pipe_crc_ctl_reg(dev_priv, pipe, source, val);\r\n}\r\nstatic int pipe_crc_set_source(struct drm_i915_private *dev_priv,\r\nenum pipe pipe,\r\nenum intel_pipe_crc_source source)\r\n{\r\nstruct intel_pipe_crc *pipe_crc = &dev_priv->pipe_crc[pipe];\r\nstruct intel_crtc *crtc = intel_get_crtc_for_pipe(dev_priv, pipe);\r\nenum intel_display_power_domain power_domain;\r\nu32 val = 0;\r\nint ret;\r\nif (pipe_crc->source == source)\r\nreturn 0;\r\nif (pipe_crc->source && source)\r\nreturn -EINVAL;\r\npower_domain = POWER_DOMAIN_PIPE(pipe);\r\nif (!intel_display_power_get_if_enabled(dev_priv, power_domain)) {\r\nDRM_DEBUG_KMS("Trying to capture CRC while pipe is off\n");\r\nreturn -EIO;\r\n}\r\nret = get_new_crc_ctl_reg(dev_priv, pipe, &source, &val);\r\nif (ret != 0)\r\ngoto out;\r\nif (source) {\r\nstruct intel_pipe_crc_entry *entries;\r\nDRM_DEBUG_DRIVER("collecting CRCs for pipe %c, %s\n",\r\npipe_name(pipe), pipe_crc_source_name(source));\r\nentries = kcalloc(INTEL_PIPE_CRC_ENTRIES_NR,\r\nsizeof(pipe_crc->entries[0]),\r\nGFP_KERNEL);\r\nif (!entries) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nhsw_disable_ips(crtc);\r\nspin_lock_irq(&pipe_crc->lock);\r\nkfree(pipe_crc->entries);\r\npipe_crc->entries = entries;\r\npipe_crc->head = 0;\r\npipe_crc->tail = 0;\r\nspin_unlock_irq(&pipe_crc->lock);\r\n}\r\npipe_crc->source = source;\r\nI915_WRITE(PIPE_CRC_CTL(pipe), val);\r\nPOSTING_READ(PIPE_CRC_CTL(pipe));\r\nif (!source) {\r\nstruct intel_pipe_crc_entry *entries;\r\nstruct intel_crtc *crtc = intel_get_crtc_for_pipe(dev_priv,\r\npipe);\r\nDRM_DEBUG_DRIVER("stopping CRCs for pipe %c\n",\r\npipe_name(pipe));\r\ndrm_modeset_lock(&crtc->base.mutex, NULL);\r\nif (crtc->base.state->active)\r\nintel_wait_for_vblank(dev_priv, pipe);\r\ndrm_modeset_unlock(&crtc->base.mutex);\r\nspin_lock_irq(&pipe_crc->lock);\r\nentries = pipe_crc->entries;\r\npipe_crc->entries = NULL;\r\npipe_crc->head = 0;\r\npipe_crc->tail = 0;\r\nspin_unlock_irq(&pipe_crc->lock);\r\nkfree(entries);\r\nif (IS_G4X(dev_priv))\r\ng4x_undo_pipe_scramble_reset(dev_priv, pipe);\r\nelse if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\r\nvlv_undo_pipe_scramble_reset(dev_priv, pipe);\r\nelse if (IS_HASWELL(dev_priv) && pipe == PIPE_A)\r\nhsw_trans_edp_pipe_A_crc_wa(dev_priv, false);\r\nhsw_enable_ips(crtc);\r\n}\r\nret = 0;\r\nout:\r\nintel_display_power_put(dev_priv, power_domain);\r\nreturn ret;\r\n}\r\nstatic int display_crc_ctl_tokenize(char *buf, char *words[], int max_words)\r\n{\r\nint n_words = 0;\r\nwhile (*buf) {\r\nchar *end;\r\nbuf = skip_spaces(buf);\r\nif (!*buf)\r\nbreak;\r\nfor (end = buf; *end && !isspace(*end); end++)\r\n;\r\nif (n_words == max_words) {\r\nDRM_DEBUG_DRIVER("too many words, allowed <= %d\n",\r\nmax_words);\r\nreturn -EINVAL;\r\n}\r\nif (*end)\r\n*end++ = '\0';\r\nwords[n_words++] = buf;\r\nbuf = end;\r\n}\r\nreturn n_words;\r\n}\r\nstatic int\r\ndisplay_crc_ctl_parse_object(const char *buf, enum intel_pipe_crc_object *o)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pipe_crc_objects); i++)\r\nif (!strcmp(buf, pipe_crc_objects[i])) {\r\n*o = i;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int display_crc_ctl_parse_pipe(const char *buf, enum pipe *pipe)\r\n{\r\nconst char name = buf[0];\r\nif (name < 'A' || name >= pipe_name(I915_MAX_PIPES))\r\nreturn -EINVAL;\r\n*pipe = name - 'A';\r\nreturn 0;\r\n}\r\nstatic int\r\ndisplay_crc_ctl_parse_source(const char *buf, enum intel_pipe_crc_source *s)\r\n{\r\nint i;\r\nif (!buf) {\r\n*s = INTEL_PIPE_CRC_SOURCE_NONE;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(pipe_crc_sources); i++)\r\nif (!strcmp(buf, pipe_crc_sources[i])) {\r\n*s = i;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int display_crc_ctl_parse(struct drm_i915_private *dev_priv,\r\nchar *buf, size_t len)\r\n{\r\n#define N_WORDS 3\r\nint n_words;\r\nchar *words[N_WORDS];\r\nenum pipe pipe;\r\nenum intel_pipe_crc_object object;\r\nenum intel_pipe_crc_source source;\r\nn_words = display_crc_ctl_tokenize(buf, words, N_WORDS);\r\nif (n_words != N_WORDS) {\r\nDRM_DEBUG_DRIVER("tokenize failed, a command is %d words\n",\r\nN_WORDS);\r\nreturn -EINVAL;\r\n}\r\nif (display_crc_ctl_parse_object(words[0], &object) < 0) {\r\nDRM_DEBUG_DRIVER("unknown object %s\n", words[0]);\r\nreturn -EINVAL;\r\n}\r\nif (display_crc_ctl_parse_pipe(words[1], &pipe) < 0) {\r\nDRM_DEBUG_DRIVER("unknown pipe %s\n", words[1]);\r\nreturn -EINVAL;\r\n}\r\nif (display_crc_ctl_parse_source(words[2], &source) < 0) {\r\nDRM_DEBUG_DRIVER("unknown source %s\n", words[2]);\r\nreturn -EINVAL;\r\n}\r\nreturn pipe_crc_set_source(dev_priv, pipe, source);\r\n}\r\nstatic ssize_t display_crc_ctl_write(struct file *file, const char __user *ubuf,\r\nsize_t len, loff_t *offp)\r\n{\r\nstruct seq_file *m = file->private_data;\r\nstruct drm_i915_private *dev_priv = m->private;\r\nchar *tmpbuf;\r\nint ret;\r\nif (len == 0)\r\nreturn 0;\r\nif (len > PAGE_SIZE - 1) {\r\nDRM_DEBUG_DRIVER("expected <%lu bytes into pipe crc control\n",\r\nPAGE_SIZE);\r\nreturn -E2BIG;\r\n}\r\ntmpbuf = memdup_user_nul(ubuf, len);\r\nif (IS_ERR(tmpbuf))\r\nreturn PTR_ERR(tmpbuf);\r\nret = display_crc_ctl_parse(dev_priv, tmpbuf, len);\r\nkfree(tmpbuf);\r\nif (ret < 0)\r\nreturn ret;\r\n*offp += len;\r\nreturn len;\r\n}\r\nvoid intel_display_crc_init(struct drm_i915_private *dev_priv)\r\n{\r\nenum pipe pipe;\r\nfor_each_pipe(dev_priv, pipe) {\r\nstruct intel_pipe_crc *pipe_crc = &dev_priv->pipe_crc[pipe];\r\npipe_crc->opened = false;\r\nspin_lock_init(&pipe_crc->lock);\r\ninit_waitqueue_head(&pipe_crc->wq);\r\n}\r\n}\r\nint intel_pipe_crc_create(struct drm_minor *minor)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(minor->dev);\r\nstruct dentry *ent;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(i915_pipe_crc_data); i++) {\r\nstruct pipe_crc_info *info = &i915_pipe_crc_data[i];\r\ninfo->dev_priv = dev_priv;\r\nent = debugfs_create_file(info->name, S_IRUGO,\r\nminor->debugfs_root, info,\r\n&i915_pipe_crc_fops);\r\nif (!ent)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nint intel_crtc_set_crc_source(struct drm_crtc *crtc, const char *source_name,\r\nsize_t *values_cnt)\r\n{\r\nstruct drm_i915_private *dev_priv = crtc->dev->dev_private;\r\nstruct intel_pipe_crc *pipe_crc = &dev_priv->pipe_crc[crtc->index];\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(crtc);\r\nenum intel_display_power_domain power_domain;\r\nenum intel_pipe_crc_source source;\r\nu32 val = 0;\r\nint ret = 0;\r\nif (display_crc_ctl_parse_source(source_name, &source) < 0) {\r\nDRM_DEBUG_DRIVER("unknown source %s\n", source_name);\r\nreturn -EINVAL;\r\n}\r\npower_domain = POWER_DOMAIN_PIPE(crtc->index);\r\nif (!intel_display_power_get_if_enabled(dev_priv, power_domain)) {\r\nDRM_DEBUG_KMS("Trying to capture CRC while pipe is off\n");\r\nreturn -EIO;\r\n}\r\nret = get_new_crc_ctl_reg(dev_priv, crtc->index, &source, &val);\r\nif (ret != 0)\r\ngoto out;\r\nif (source) {\r\nhsw_disable_ips(intel_crtc);\r\n}\r\nI915_WRITE(PIPE_CRC_CTL(crtc->index), val);\r\nPOSTING_READ(PIPE_CRC_CTL(crtc->index));\r\nif (!source) {\r\nif (IS_G4X(dev_priv))\r\ng4x_undo_pipe_scramble_reset(dev_priv, crtc->index);\r\nelse if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\r\nvlv_undo_pipe_scramble_reset(dev_priv, crtc->index);\r\nelse if (IS_HASWELL(dev_priv) && crtc->index == PIPE_A)\r\nhsw_trans_edp_pipe_A_crc_wa(dev_priv, false);\r\nhsw_enable_ips(intel_crtc);\r\n}\r\npipe_crc->skipped = 0;\r\n*values_cnt = 5;\r\nout:\r\nintel_display_power_put(dev_priv, power_domain);\r\nreturn ret;\r\n}
