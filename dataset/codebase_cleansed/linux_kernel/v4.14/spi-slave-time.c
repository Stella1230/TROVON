static void spi_slave_time_complete(void *arg)\r\n{\r\nstruct spi_slave_time_priv *priv = arg;\r\nint ret;\r\nret = priv->msg.status;\r\nif (ret)\r\ngoto terminate;\r\nret = spi_slave_time_submit(priv);\r\nif (ret)\r\ngoto terminate;\r\nreturn;\r\nterminate:\r\ndev_info(&priv->spi->dev, "Terminating\n");\r\ncomplete(&priv->finished);\r\n}\r\nstatic int spi_slave_time_submit(struct spi_slave_time_priv *priv)\r\n{\r\nu32 rem_us;\r\nint ret;\r\nu64 ts;\r\nts = local_clock();\r\nrem_us = do_div(ts, 1000000000) / 1000;\r\npriv->buf[0] = cpu_to_be32(ts);\r\npriv->buf[1] = cpu_to_be32(rem_us);\r\nspi_message_init_with_transfers(&priv->msg, &priv->xfer, 1);\r\npriv->msg.complete = spi_slave_time_complete;\r\npriv->msg.context = priv;\r\nret = spi_async(priv->spi, &priv->msg);\r\nif (ret)\r\ndev_err(&priv->spi->dev, "spi_async() failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int spi_slave_time_probe(struct spi_device *spi)\r\n{\r\nstruct spi_slave_time_priv *priv;\r\nint ret;\r\npriv = devm_kzalloc(&spi->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->spi = spi;\r\ninit_completion(&priv->finished);\r\npriv->xfer.tx_buf = priv->buf;\r\npriv->xfer.len = sizeof(priv->buf);\r\nret = spi_slave_time_submit(priv);\r\nif (ret)\r\nreturn ret;\r\nspi_set_drvdata(spi, priv);\r\nreturn 0;\r\n}\r\nstatic int spi_slave_time_remove(struct spi_device *spi)\r\n{\r\nstruct spi_slave_time_priv *priv = spi_get_drvdata(spi);\r\nspi_slave_abort(spi);\r\nwait_for_completion(&priv->finished);\r\nreturn 0;\r\n}
