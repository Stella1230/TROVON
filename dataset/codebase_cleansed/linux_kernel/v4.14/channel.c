int host1x_channel_list_init(struct host1x_channel_list *chlist,\r\nunsigned int num_channels)\r\n{\r\nchlist->channels = kcalloc(num_channels, sizeof(struct host1x_channel),\r\nGFP_KERNEL);\r\nif (!chlist->channels)\r\nreturn -ENOMEM;\r\nchlist->allocated_channels =\r\nkcalloc(BITS_TO_LONGS(num_channels), sizeof(unsigned long),\r\nGFP_KERNEL);\r\nif (!chlist->allocated_channels) {\r\nkfree(chlist->channels);\r\nreturn -ENOMEM;\r\n}\r\nbitmap_zero(chlist->allocated_channels, num_channels);\r\nreturn 0;\r\n}\r\nvoid host1x_channel_list_free(struct host1x_channel_list *chlist)\r\n{\r\nkfree(chlist->allocated_channels);\r\nkfree(chlist->channels);\r\n}\r\nint host1x_job_submit(struct host1x_job *job)\r\n{\r\nstruct host1x *host = dev_get_drvdata(job->channel->dev->parent);\r\nreturn host1x_hw_channel_submit(host, job);\r\n}\r\nstruct host1x_channel *host1x_channel_get(struct host1x_channel *channel)\r\n{\r\nkref_get(&channel->refcount);\r\nreturn channel;\r\n}\r\nstruct host1x_channel *host1x_channel_get_index(struct host1x *host,\r\nunsigned int index)\r\n{\r\nstruct host1x_channel *ch = &host->channel_list.channels[index];\r\nif (!kref_get_unless_zero(&ch->refcount))\r\nreturn NULL;\r\nreturn ch;\r\n}\r\nstatic void release_channel(struct kref *kref)\r\n{\r\nstruct host1x_channel *channel =\r\ncontainer_of(kref, struct host1x_channel, refcount);\r\nstruct host1x *host = dev_get_drvdata(channel->dev->parent);\r\nstruct host1x_channel_list *chlist = &host->channel_list;\r\nhost1x_hw_cdma_stop(host, &channel->cdma);\r\nhost1x_cdma_deinit(&channel->cdma);\r\nclear_bit(channel->id, chlist->allocated_channels);\r\n}\r\nvoid host1x_channel_put(struct host1x_channel *channel)\r\n{\r\nkref_put(&channel->refcount, release_channel);\r\n}\r\nstatic struct host1x_channel *acquire_unused_channel(struct host1x *host)\r\n{\r\nstruct host1x_channel_list *chlist = &host->channel_list;\r\nunsigned int max_channels = host->info->nb_channels;\r\nunsigned int index;\r\nindex = find_first_zero_bit(chlist->allocated_channels, max_channels);\r\nif (index >= max_channels) {\r\ndev_err(host->dev, "failed to find free channel\n");\r\nreturn NULL;\r\n}\r\nchlist->channels[index].id = index;\r\nset_bit(index, chlist->allocated_channels);\r\nreturn &chlist->channels[index];\r\n}\r\nstruct host1x_channel *host1x_channel_request(struct device *dev)\r\n{\r\nstruct host1x *host = dev_get_drvdata(dev->parent);\r\nstruct host1x_channel_list *chlist = &host->channel_list;\r\nstruct host1x_channel *channel;\r\nint err;\r\nchannel = acquire_unused_channel(host);\r\nif (!channel)\r\nreturn NULL;\r\nkref_init(&channel->refcount);\r\nmutex_init(&channel->submitlock);\r\nchannel->dev = dev;\r\nerr = host1x_hw_channel_init(host, channel, channel->id);\r\nif (err < 0)\r\ngoto fail;\r\nerr = host1x_cdma_init(&channel->cdma);\r\nif (err < 0)\r\ngoto fail;\r\nreturn channel;\r\nfail:\r\nclear_bit(channel->id, chlist->allocated_channels);\r\ndev_err(dev, "failed to initialize channel\n");\r\nreturn NULL;\r\n}
