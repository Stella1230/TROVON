static int\r\nnc_vendor_read(struct usbnet *dev, u8 req, u8 regnum, u16 *retval_ptr)\r\n{\r\nint status = usbnet_read_cmd(dev, req,\r\nUSB_DIR_IN | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE,\r\n0, regnum, retval_ptr,\r\nsizeof *retval_ptr);\r\nif (status > 0)\r\nstatus = 0;\r\nif (!status)\r\nle16_to_cpus(retval_ptr);\r\nreturn status;\r\n}\r\nstatic inline int\r\nnc_register_read(struct usbnet *dev, u8 regnum, u16 *retval_ptr)\r\n{\r\nreturn nc_vendor_read(dev, REQUEST_REGISTER, regnum, retval_ptr);\r\n}\r\nstatic void\r\nnc_vendor_write(struct usbnet *dev, u8 req, u8 regnum, u16 value)\r\n{\r\nusbnet_write_cmd(dev, req,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, regnum, NULL, 0);\r\n}\r\nstatic inline void\r\nnc_register_write(struct usbnet *dev, u8 regnum, u16 value)\r\n{\r\nnc_vendor_write(dev, REQUEST_REGISTER, regnum, value);\r\n}\r\nstatic inline void nc_dump_usbctl(struct usbnet *dev, u16 usbctl)\r\n{\r\nnetif_dbg(dev, link, dev->net,\r\n"net1080 %s-%s usbctl 0x%x:%s%s%s%s%s; this%s%s; other%s%s; r/o 0x%x\n",\r\ndev->udev->bus->bus_name, dev->udev->devpath,\r\nusbctl,\r\n(usbctl & USBCTL_ENABLE_LANG) ? " lang" : "",\r\n(usbctl & USBCTL_ENABLE_MFGR) ? " mfgr" : "",\r\n(usbctl & USBCTL_ENABLE_PROD) ? " prod" : "",\r\n(usbctl & USBCTL_ENABLE_SERIAL) ? " serial" : "",\r\n(usbctl & USBCTL_ENABLE_DEFAULTS) ? " defaults" : "",\r\n(usbctl & USBCTL_FLUSH_THIS) ? " FLUSH" : "",\r\n(usbctl & USBCTL_DISCONN_THIS) ? " DIS" : "",\r\n(usbctl & USBCTL_FLUSH_OTHER) ? " FLUSH" : "",\r\n(usbctl & USBCTL_DISCONN_OTHER) ? " DIS" : "",\r\nusbctl & ~USBCTL_WRITABLE_MASK);\r\n}\r\nstatic inline void nc_dump_status(struct usbnet *dev, u16 status)\r\n{\r\nnetif_dbg(dev, link, dev->net,\r\n"net1080 %s-%s status 0x%x: this (%c) PKT=%d%s%s%s; other PKT=%d%s%s%s; unspec 0x%x\n",\r\ndev->udev->bus->bus_name, dev->udev->devpath,\r\nstatus,\r\n(status & STATUS_PORT_A) ? 'A' : 'B',\r\nSTATUS_PACKETS_THIS(status),\r\n(status & STATUS_CONN_THIS) ? " CON" : "",\r\n(status & STATUS_SUSPEND_THIS) ? " SUS" : "",\r\n(status & STATUS_MAILBOX_THIS) ? " MBOX" : "",\r\nSTATUS_PACKETS_OTHER(status),\r\n(status & STATUS_CONN_OTHER) ? " CON" : "",\r\n(status & STATUS_SUSPEND_OTHER) ? " SUS" : "",\r\n(status & STATUS_MAILBOX_OTHER) ? " MBOX" : "",\r\nstatus & STATUS_UNSPEC_MASK);\r\n}\r\nstatic int net1080_reset(struct usbnet *dev)\r\n{\r\nu16 usbctl, status, ttl;\r\nu16 vp;\r\nint retval;\r\nif ((retval = nc_register_read(dev, REG_STATUS, &vp)) < 0) {\r\nnetdev_dbg(dev->net, "can't read %s-%s status: %d\n",\r\ndev->udev->bus->bus_name, dev->udev->devpath, retval);\r\ngoto done;\r\n}\r\nstatus = vp;\r\nnc_dump_status(dev, status);\r\nif ((retval = nc_register_read(dev, REG_USBCTL, &vp)) < 0) {\r\nnetdev_dbg(dev->net, "can't read USBCTL, %d\n", retval);\r\ngoto done;\r\n}\r\nusbctl = vp;\r\nnc_dump_usbctl(dev, usbctl);\r\nnc_register_write(dev, REG_USBCTL,\r\nUSBCTL_FLUSH_THIS | USBCTL_FLUSH_OTHER);\r\nif ((retval = nc_register_read(dev, REG_TTL, &vp)) < 0) {\r\nnetdev_dbg(dev->net, "can't read TTL, %d\n", retval);\r\ngoto done;\r\n}\r\nttl = vp;\r\nnc_register_write(dev, REG_TTL,\r\nMK_TTL(NC_READ_TTL_MS, TTL_OTHER(ttl)) );\r\nnetdev_dbg(dev->net, "assigned TTL, %d ms\n", NC_READ_TTL_MS);\r\nnetif_info(dev, link, dev->net, "port %c, peer %sconnected\n",\r\n(status & STATUS_PORT_A) ? 'A' : 'B',\r\n(status & STATUS_CONN_OTHER) ? "" : "dis");\r\nretval = 0;\r\ndone:\r\nreturn retval;\r\n}\r\nstatic int net1080_check_connect(struct usbnet *dev)\r\n{\r\nint retval;\r\nu16 status;\r\nu16 vp;\r\nretval = nc_register_read(dev, REG_STATUS, &vp);\r\nstatus = vp;\r\nif (retval != 0) {\r\nnetdev_dbg(dev->net, "net1080_check_conn read - %d\n", retval);\r\nreturn retval;\r\n}\r\nif ((status & STATUS_CONN_OTHER) != STATUS_CONN_OTHER)\r\nreturn -ENOLINK;\r\nreturn 0;\r\n}\r\nstatic void nc_ensure_sync(struct usbnet *dev)\r\n{\r\nif (++dev->frame_errors <= 5)\r\nreturn;\r\nif (usbnet_write_cmd_async(dev, REQUEST_REGISTER,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE,\r\nUSBCTL_FLUSH_THIS |\r\nUSBCTL_FLUSH_OTHER,\r\nREG_USBCTL, NULL, 0))\r\nreturn;\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"flush net1080; too many framing errors\n");\r\ndev->frame_errors = 0;\r\n}\r\nstatic int net1080_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nstruct nc_header *header;\r\nstruct nc_trailer *trailer;\r\nu16 hdr_len, packet_len;\r\nif (skb->len < dev->net->hard_header_len)\r\nreturn 0;\r\nif (!(skb->len & 0x01)) {\r\nnetdev_dbg(dev->net, "rx framesize %d range %d..%d mtu %d\n",\r\nskb->len, dev->net->hard_header_len, dev->hard_mtu,\r\ndev->net->mtu);\r\ndev->net->stats.rx_frame_errors++;\r\nnc_ensure_sync(dev);\r\nreturn 0;\r\n}\r\nheader = (struct nc_header *) skb->data;\r\nhdr_len = le16_to_cpup(&header->hdr_len);\r\npacket_len = le16_to_cpup(&header->packet_len);\r\nif (FRAMED_SIZE(packet_len) > NC_MAX_PACKET) {\r\ndev->net->stats.rx_frame_errors++;\r\nnetdev_dbg(dev->net, "packet too big, %d\n", packet_len);\r\nnc_ensure_sync(dev);\r\nreturn 0;\r\n} else if (hdr_len < MIN_HEADER) {\r\ndev->net->stats.rx_frame_errors++;\r\nnetdev_dbg(dev->net, "header too short, %d\n", hdr_len);\r\nnc_ensure_sync(dev);\r\nreturn 0;\r\n} else if (hdr_len > MIN_HEADER) {\r\nnetdev_dbg(dev->net, "header OOB, %d bytes\n", hdr_len - MIN_HEADER);\r\nnc_ensure_sync(dev);\r\n}\r\nskb_pull(skb, hdr_len);\r\ntrailer = (struct nc_trailer *)\r\n(skb->data + skb->len - sizeof *trailer);\r\nskb_trim(skb, skb->len - sizeof *trailer);\r\nif ((packet_len & 0x01) == 0) {\r\nif (skb->data [packet_len] != PAD_BYTE) {\r\ndev->net->stats.rx_frame_errors++;\r\nnetdev_dbg(dev->net, "bad pad\n");\r\nreturn 0;\r\n}\r\nskb_trim(skb, skb->len - 1);\r\n}\r\nif (skb->len != packet_len) {\r\ndev->net->stats.rx_frame_errors++;\r\nnetdev_dbg(dev->net, "bad packet len %d (expected %d)\n",\r\nskb->len, packet_len);\r\nnc_ensure_sync(dev);\r\nreturn 0;\r\n}\r\nif (header->packet_id != get_unaligned(&trailer->packet_id)) {\r\ndev->net->stats.rx_fifo_errors++;\r\nnetdev_dbg(dev->net, "(2+ dropped) rx packet_id mismatch 0x%x 0x%x\n",\r\nle16_to_cpu(header->packet_id),\r\nle16_to_cpu(trailer->packet_id));\r\nreturn 0;\r\n}\r\n#if 0\r\nnetdev_dbg(dev->net, "frame <rx h %d p %d id %d\n", header->hdr_len,\r\nheader->packet_len, header->packet_id);\r\n#endif\r\ndev->frame_errors = 0;\r\nreturn 1;\r\n}\r\nstatic struct sk_buff *\r\nnet1080_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\r\n{\r\nstruct sk_buff *skb2;\r\nstruct nc_header *header = NULL;\r\nstruct nc_trailer *trailer = NULL;\r\nint padlen = sizeof (struct nc_trailer);\r\nint len = skb->len;\r\nif (!((len + padlen + sizeof (struct nc_header)) & 0x01))\r\npadlen++;\r\nif (!skb_cloned(skb)) {\r\nint headroom = skb_headroom(skb);\r\nint tailroom = skb_tailroom(skb);\r\nif (padlen <= tailroom &&\r\nsizeof(struct nc_header) <= headroom)\r\ngoto encapsulate;\r\nif ((sizeof (struct nc_header) + padlen) <\r\n(headroom + tailroom)) {\r\nskb->data = memmove(skb->head\r\n+ sizeof (struct nc_header),\r\nskb->data, skb->len);\r\nskb_set_tail_pointer(skb, len);\r\ngoto encapsulate;\r\n}\r\n}\r\nskb2 = skb_copy_expand(skb,\r\nsizeof (struct nc_header),\r\npadlen,\r\nflags);\r\ndev_kfree_skb_any(skb);\r\nif (!skb2)\r\nreturn skb2;\r\nskb = skb2;\r\nencapsulate:\r\nheader = skb_push(skb, sizeof *header);\r\nheader->hdr_len = cpu_to_le16(sizeof (*header));\r\nheader->packet_len = cpu_to_le16(len);\r\nheader->packet_id = cpu_to_le16((u16)dev->xid++);\r\nif (!((skb->len + sizeof *trailer) & 0x01))\r\nskb_put_u8(skb, PAD_BYTE);\r\ntrailer = skb_put(skb, sizeof *trailer);\r\nput_unaligned(header->packet_id, &trailer->packet_id);\r\n#if 0\r\nnetdev_dbg(dev->net, "frame >tx h %d p %d id %d\n",\r\nheader->hdr_len, header->packet_len,\r\nheader->packet_id);\r\n#endif\r\nreturn skb;\r\n}\r\nstatic int net1080_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nunsigned extra = sizeof (struct nc_header)\r\n+ 1\r\n+ sizeof (struct nc_trailer);\r\ndev->net->hard_header_len += extra;\r\ndev->rx_urb_size = dev->net->hard_header_len + dev->net->mtu;\r\ndev->hard_mtu = NC_MAX_PACKET;\r\nreturn usbnet_get_endpoints (dev, intf);\r\n}
