static void nft_ng_inc_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_ng_inc *priv = nft_expr_priv(expr);\r\nu32 nval, oval;\r\ndo {\r\noval = atomic_read(&priv->counter);\r\nnval = (oval + 1 < priv->modulus) ? oval + 1 : 0;\r\n} while (atomic_cmpxchg(&priv->counter, oval, nval) != oval);\r\nregs->data[priv->dreg] = nval + priv->offset;\r\n}\r\nstatic int nft_ng_inc_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_ng_inc *priv = nft_expr_priv(expr);\r\nif (tb[NFTA_NG_OFFSET])\r\npriv->offset = ntohl(nla_get_be32(tb[NFTA_NG_OFFSET]));\r\npriv->modulus = ntohl(nla_get_be32(tb[NFTA_NG_MODULUS]));\r\nif (priv->modulus == 0)\r\nreturn -ERANGE;\r\nif (priv->offset + priv->modulus - 1 < priv->offset)\r\nreturn -EOVERFLOW;\r\npriv->dreg = nft_parse_register(tb[NFTA_NG_DREG]);\r\natomic_set(&priv->counter, priv->modulus - 1);\r\nreturn nft_validate_register_store(ctx, priv->dreg, NULL,\r\nNFT_DATA_VALUE, sizeof(u32));\r\n}\r\nstatic int nft_ng_dump(struct sk_buff *skb, enum nft_registers dreg,\r\nu32 modulus, enum nft_ng_types type, u32 offset)\r\n{\r\nif (nft_dump_register(skb, NFTA_NG_DREG, dreg))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_NG_MODULUS, htonl(modulus)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_NG_TYPE, htonl(type)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_NG_OFFSET, htonl(offset)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int nft_ng_inc_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_ng_inc *priv = nft_expr_priv(expr);\r\nreturn nft_ng_dump(skb, priv->dreg, priv->modulus, NFT_NG_INCREMENTAL,\r\npriv->offset);\r\n}\r\nstatic void nft_ng_random_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_ng_random *priv = nft_expr_priv(expr);\r\nstruct rnd_state *state = this_cpu_ptr(&nft_numgen_prandom_state);\r\nu32 val;\r\nval = reciprocal_scale(prandom_u32_state(state), priv->modulus);\r\nregs->data[priv->dreg] = val + priv->offset;\r\n}\r\nstatic int nft_ng_random_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_ng_random *priv = nft_expr_priv(expr);\r\nif (tb[NFTA_NG_OFFSET])\r\npriv->offset = ntohl(nla_get_be32(tb[NFTA_NG_OFFSET]));\r\npriv->modulus = ntohl(nla_get_be32(tb[NFTA_NG_MODULUS]));\r\nif (priv->modulus == 0)\r\nreturn -ERANGE;\r\nif (priv->offset + priv->modulus - 1 < priv->offset)\r\nreturn -EOVERFLOW;\r\nprandom_init_once(&nft_numgen_prandom_state);\r\npriv->dreg = nft_parse_register(tb[NFTA_NG_DREG]);\r\nreturn nft_validate_register_store(ctx, priv->dreg, NULL,\r\nNFT_DATA_VALUE, sizeof(u32));\r\n}\r\nstatic int nft_ng_random_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_ng_random *priv = nft_expr_priv(expr);\r\nreturn nft_ng_dump(skb, priv->dreg, priv->modulus, NFT_NG_RANDOM,\r\npriv->offset);\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_ng_select_ops(const struct nft_ctx *ctx, const struct nlattr * const tb[])\r\n{\r\nu32 type;\r\nif (!tb[NFTA_NG_DREG] ||\r\n!tb[NFTA_NG_MODULUS] ||\r\n!tb[NFTA_NG_TYPE])\r\nreturn ERR_PTR(-EINVAL);\r\ntype = ntohl(nla_get_be32(tb[NFTA_NG_TYPE]));\r\nswitch (type) {\r\ncase NFT_NG_INCREMENTAL:\r\nreturn &nft_ng_inc_ops;\r\ncase NFT_NG_RANDOM:\r\nreturn &nft_ng_random_ops;\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int __init nft_ng_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_ng_type);\r\n}\r\nstatic void __exit nft_ng_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_ng_type);\r\n}
