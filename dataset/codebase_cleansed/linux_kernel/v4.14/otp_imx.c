static int\r\nimx_read_otp_data(struct i2c_client *client, u16 len, u16 reg, void *val)\r\n{\r\nstruct i2c_msg msg[2];\r\nu16 data[IMX_SHORT_MAX] = { 0 };\r\nint err;\r\nif (len > IMX_BYTE_MAX) {\r\ndev_err(&client->dev, "%s error, invalid data length\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nmemset(msg, 0 , sizeof(msg));\r\nmemset(data, 0 , sizeof(data));\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = 0;\r\nmsg[0].len = I2C_MSG_LENGTH;\r\nmsg[0].buf = (u8 *)data;\r\ndata[0] = cpu_to_be16(reg);\r\nmsg[1].addr = client->addr;\r\nmsg[1].len = len;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].buf = (u8 *)data;\r\nerr = i2c_transfer(client->adapter, msg, 2);\r\nif (err != 2) {\r\nif (err >= 0)\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nmemcpy(val, data, len);\r\nreturn 0;\r\nerror:\r\ndev_err(&client->dev, "read from offset 0x%x error %d", reg, err);\r\nreturn err;\r\n}\r\nstatic int imx_read_otp_reg_array(struct i2c_client *client, u16 size, u16 addr,\r\nu8 *buf)\r\n{\r\nu16 index;\r\nint ret;\r\nfor (index = 0; index + IMX_OTP_READ_ONETIME <= size;\r\nindex += IMX_OTP_READ_ONETIME) {\r\nret = imx_read_otp_data(client, IMX_OTP_READ_ONETIME,\r\naddr + index, &buf[index]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid *imx_otp_read(struct v4l2_subdev *sd, u8 dev_addr,\r\nu32 start_addr, u32 size)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 *buf;\r\nint ret;\r\nint i;\r\nbuf = devm_kzalloc(&client->dev, size, GFP_KERNEL);\r\nif (!buf)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < IMX_OTP_PAGE_MAX; i++) {\r\nret = imx_write_reg(client, IMX_8BIT,\r\nIMX_OTP_PAGE_REG, i & 0xff);\r\nif (ret)\r\ngoto fail;\r\nret = imx_write_reg(client, IMX_8BIT,\r\nIMX_OTP_MODE_REG, IMX_OTP_MODE_READ);\r\nif (ret)\r\ngoto fail;\r\nret = imx_read_otp_reg_array(client, IMX_OTP_PAGE_SIZE,\r\nIMX_OTP_START_ADDR, buf + i * IMX_OTP_PAGE_SIZE);\r\nif (ret)\r\ngoto fail;\r\n}\r\nreturn buf;\r\nfail:\r\ndev_err(&client->dev, "sensor found no valid OTP data\n");\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid *imx227_otp_read(struct v4l2_subdev *sd, u8 dev_addr,\r\nu32 start_addr, u32 size)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 *buf;\r\nint ret;\r\nint i;\r\nbuf = devm_kzalloc(&client->dev, size, GFP_KERNEL);\r\nif (!buf)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < IMX_OTP_PAGE_MAX; i++) {\r\nret = imx_write_reg(client, IMX_8BIT,\r\nIMX227_OTP_PAGE_REG, i & 0xff);\r\nif (ret)\r\ngoto fail;\r\nret = imx_write_reg(client, IMX_8BIT,\r\nIMX227_OTP_ENABLE_REG, IMX227_OTP_MODE_READ);\r\nif (ret)\r\ngoto fail;\r\nret = imx_read_otp_reg_array(client, IMX_OTP_PAGE_SIZE,\r\nIMX227_OTP_START_ADDR, buf + i * IMX_OTP_PAGE_SIZE);\r\nif (ret)\r\ngoto fail;\r\n}\r\nreturn buf;\r\nfail:\r\ndev_err(&client->dev, "sensor found no valid OTP data\n");\r\nreturn ERR_PTR(ret);\r\n}
