static int ep_fifo_alloc(struct mtu3_ep *mep, u32 seg_size)\r\n{\r\nstruct mtu3_fifo_info *fifo = mep->fifo;\r\nu32 num_bits = DIV_ROUND_UP(seg_size, MTU3_EP_FIFO_UNIT);\r\nu32 start_bit;\r\nnum_bits = roundup_pow_of_two(num_bits);\r\nif (num_bits > fifo->limit)\r\nreturn -EINVAL;\r\nmep->fifo_seg_size = num_bits * MTU3_EP_FIFO_UNIT;\r\nnum_bits = num_bits * (mep->slot + 1);\r\nstart_bit = bitmap_find_next_zero_area(fifo->bitmap,\r\nfifo->limit, 0, num_bits, 0);\r\nif (start_bit >= fifo->limit)\r\nreturn -EOVERFLOW;\r\nbitmap_set(fifo->bitmap, start_bit, num_bits);\r\nmep->fifo_size = num_bits * MTU3_EP_FIFO_UNIT;\r\nmep->fifo_addr = fifo->base + MTU3_EP_FIFO_UNIT * start_bit;\r\ndev_dbg(mep->mtu->dev, "%s fifo:%#x/%#x, start_bit: %d\n",\r\n__func__, mep->fifo_seg_size, mep->fifo_size, start_bit);\r\nreturn mep->fifo_addr;\r\n}\r\nstatic void ep_fifo_free(struct mtu3_ep *mep)\r\n{\r\nstruct mtu3_fifo_info *fifo = mep->fifo;\r\nu32 addr = mep->fifo_addr;\r\nu32 bits = mep->fifo_size / MTU3_EP_FIFO_UNIT;\r\nu32 start_bit;\r\nif (unlikely(addr < fifo->base || bits > fifo->limit))\r\nreturn;\r\nstart_bit = (addr - fifo->base) / MTU3_EP_FIFO_UNIT;\r\nbitmap_clear(fifo->bitmap, start_bit, bits);\r\nmep->fifo_size = 0;\r\nmep->fifo_seg_size = 0;\r\ndev_dbg(mep->mtu->dev, "%s size:%#x/%#x, start_bit: %d\n",\r\n__func__, mep->fifo_seg_size, mep->fifo_size, start_bit);\r\n}\r\nstatic inline void mtu3_ss_func_set(struct mtu3 *mtu, bool enable)\r\n{\r\nif (enable)\r\nmtu3_setbits(mtu->mac_base, U3D_USB3_CONFIG, USB3_EN);\r\nelse\r\nmtu3_clrbits(mtu->mac_base, U3D_USB3_CONFIG, USB3_EN);\r\ndev_dbg(mtu->dev, "USB3_EN = %d\n", !!enable);\r\n}\r\nstatic inline void mtu3_hs_softconn_set(struct mtu3 *mtu, bool enable)\r\n{\r\nif (enable) {\r\nmtu3_setbits(mtu->mac_base, U3D_POWER_MANAGEMENT,\r\nSOFT_CONN | SUSPENDM_ENABLE);\r\n} else {\r\nmtu3_clrbits(mtu->mac_base, U3D_POWER_MANAGEMENT,\r\nSOFT_CONN | SUSPENDM_ENABLE);\r\n}\r\ndev_dbg(mtu->dev, "SOFTCONN = %d\n", !!enable);\r\n}\r\nstatic int mtu3_device_enable(struct mtu3 *mtu)\r\n{\r\nvoid __iomem *ibase = mtu->ippc_base;\r\nu32 check_clk = 0;\r\nmtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);\r\nif (mtu->is_u3_ip) {\r\ncheck_clk = SSUSB_U3_MAC_RST_B_STS;\r\nmtu3_clrbits(ibase, SSUSB_U3_CTRL(0),\r\n(SSUSB_U3_PORT_DIS | SSUSB_U3_PORT_PDN |\r\nSSUSB_U3_PORT_HOST_SEL));\r\n}\r\nmtu3_clrbits(ibase, SSUSB_U2_CTRL(0),\r\n(SSUSB_U2_PORT_DIS | SSUSB_U2_PORT_PDN |\r\nSSUSB_U2_PORT_HOST_SEL));\r\nmtu3_setbits(ibase, SSUSB_U2_CTRL(0), SSUSB_U2_PORT_OTG_SEL);\r\nreturn ssusb_check_clocks(mtu->ssusb, check_clk);\r\n}\r\nstatic void mtu3_device_disable(struct mtu3 *mtu)\r\n{\r\nvoid __iomem *ibase = mtu->ippc_base;\r\nif (mtu->is_u3_ip)\r\nmtu3_setbits(ibase, SSUSB_U3_CTRL(0),\r\n(SSUSB_U3_PORT_DIS | SSUSB_U3_PORT_PDN));\r\nmtu3_setbits(ibase, SSUSB_U2_CTRL(0),\r\nSSUSB_U2_PORT_DIS | SSUSB_U2_PORT_PDN);\r\nmtu3_clrbits(ibase, SSUSB_U2_CTRL(0), SSUSB_U2_PORT_OTG_SEL);\r\nmtu3_setbits(ibase, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);\r\n}\r\nstatic void mtu3_device_reset(struct mtu3 *mtu)\r\n{\r\nvoid __iomem *ibase = mtu->ippc_base;\r\nmtu3_setbits(ibase, U3D_SSUSB_DEV_RST_CTRL, SSUSB_DEV_SW_RST);\r\nudelay(1);\r\nmtu3_clrbits(ibase, U3D_SSUSB_DEV_RST_CTRL, SSUSB_DEV_SW_RST);\r\n}\r\nstatic void mtu3_intr_disable(struct mtu3 *mtu)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nmtu3_writel(mbase, U3D_LV1IECR, ~0x0);\r\nmtu3_writel(mbase, U3D_EPIECR, ~0x0);\r\n}\r\nstatic void mtu3_intr_status_clear(struct mtu3 *mtu)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nmtu3_writel(mbase, U3D_EPISR, ~0x0);\r\nmtu3_writel(mbase, U3D_COMMON_USB_INTR, ~0x0);\r\nmtu3_writel(mbase, U3D_LTSSM_INTR, ~0x0);\r\nmtu3_writel(mbase, U3D_DEV_LINK_INTR, ~0x0);\r\n}\r\nstatic void mtu3_intr_enable(struct mtu3 *mtu)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nu32 value;\r\nvalue = BMU_INTR | QMU_INTR | MAC3_INTR | MAC2_INTR | EP_CTRL_INTR;\r\nmtu3_writel(mbase, U3D_LV1IESR, value);\r\nvalue = SUSPEND_INTR | RESUME_INTR | RESET_INTR;\r\nmtu3_writel(mbase, U3D_COMMON_USB_INTR_ENABLE, value);\r\nif (mtu->is_u3_ip) {\r\nvalue = HOT_RST_INTR | WARM_RST_INTR | VBUS_RISE_INTR |\r\nVBUS_FALL_INTR | ENTER_U3_INTR | EXIT_U3_INTR;\r\nmtu3_writel(mbase, U3D_LTSSM_INTR_ENABLE, value);\r\n}\r\nvalue = TXQ_CSERR_INT | TXQ_LENERR_INT | RXQ_CSERR_INT |\r\nRXQ_LENERR_INT | RXQ_ZLPERR_INT;\r\nmtu3_writel(mbase, U3D_QIESR1, value);\r\nmtu3_writel(mbase, U3D_DEV_LINK_INTR_ENABLE, SSUSB_DEV_SPEED_CHG_INTR);\r\n}\r\nvoid mtu3_ep_stall_set(struct mtu3_ep *mep, bool set)\r\n{\r\nstruct mtu3 *mtu = mep->mtu;\r\nvoid __iomem *mbase = mtu->mac_base;\r\nu8 epnum = mep->epnum;\r\nu32 csr;\r\nif (mep->is_in) {\r\ncsr = mtu3_readl(mbase, MU3D_EP_TXCR0(epnum)) & TX_W1C_BITS;\r\nif (set)\r\ncsr |= TX_SENDSTALL;\r\nelse\r\ncsr = (csr & (~TX_SENDSTALL)) | TX_SENTSTALL;\r\nmtu3_writel(mbase, MU3D_EP_TXCR0(epnum), csr);\r\n} else {\r\ncsr = mtu3_readl(mbase, MU3D_EP_RXCR0(epnum)) & RX_W1C_BITS;\r\nif (set)\r\ncsr |= RX_SENDSTALL;\r\nelse\r\ncsr = (csr & (~RX_SENDSTALL)) | RX_SENTSTALL;\r\nmtu3_writel(mbase, MU3D_EP_RXCR0(epnum), csr);\r\n}\r\nif (!set) {\r\nmtu3_setbits(mbase, U3D_EP_RST, EP_RST(mep->is_in, epnum));\r\nmtu3_clrbits(mbase, U3D_EP_RST, EP_RST(mep->is_in, epnum));\r\nmep->flags &= ~MTU3_EP_STALL;\r\n} else {\r\nmep->flags |= MTU3_EP_STALL;\r\n}\r\ndev_dbg(mtu->dev, "%s: %s\n", mep->name,\r\nset ? "SEND STALL" : "CLEAR STALL, with EP RESET");\r\n}\r\nvoid mtu3_dev_on_off(struct mtu3 *mtu, int is_on)\r\n{\r\nif (mtu->is_u3_ip && (mtu->max_speed == USB_SPEED_SUPER))\r\nmtu3_ss_func_set(mtu, is_on);\r\nelse\r\nmtu3_hs_softconn_set(mtu, is_on);\r\ndev_info(mtu->dev, "gadget (%s) pullup D%s\n",\r\nusb_speed_string(mtu->max_speed), is_on ? "+" : "-");\r\n}\r\nvoid mtu3_start(struct mtu3 *mtu)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\ndev_dbg(mtu->dev, "%s devctl 0x%x\n", __func__,\r\nmtu3_readl(mbase, U3D_DEVICE_CONTROL));\r\nmtu3_clrbits(mtu->ippc_base, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);\r\nif (mtu->max_speed == USB_SPEED_FULL)\r\nmtu3_clrbits(mbase, U3D_POWER_MANAGEMENT, HS_ENABLE);\r\nmtu3_intr_enable(mtu);\r\nmtu->is_active = 1;\r\nif (mtu->softconnect)\r\nmtu3_dev_on_off(mtu, 1);\r\n}\r\nvoid mtu3_stop(struct mtu3 *mtu)\r\n{\r\ndev_dbg(mtu->dev, "%s\n", __func__);\r\nmtu3_intr_disable(mtu);\r\nmtu3_intr_status_clear(mtu);\r\nif (mtu->softconnect)\r\nmtu3_dev_on_off(mtu, 0);\r\nmtu->is_active = 0;\r\nmtu3_setbits(mtu->ippc_base, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);\r\n}\r\nint mtu3_config_ep(struct mtu3 *mtu, struct mtu3_ep *mep,\r\nint interval, int burst, int mult)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nint epnum = mep->epnum;\r\nu32 csr0, csr1, csr2;\r\nint fifo_sgsz, fifo_addr;\r\nint num_pkts;\r\nfifo_addr = ep_fifo_alloc(mep, mep->maxp);\r\nif (fifo_addr < 0) {\r\ndev_err(mtu->dev, "alloc ep fifo failed(%d)\n", mep->maxp);\r\nreturn -ENOMEM;\r\n}\r\nfifo_sgsz = ilog2(mep->fifo_seg_size);\r\ndev_dbg(mtu->dev, "%s fifosz: %x(%x/%x)\n", __func__, fifo_sgsz,\r\nmep->fifo_seg_size, mep->fifo_size);\r\nif (mep->is_in) {\r\ncsr0 = TX_TXMAXPKTSZ(mep->maxp);\r\ncsr0 |= TX_DMAREQEN;\r\nnum_pkts = (burst + 1) * (mult + 1) - 1;\r\ncsr1 = TX_SS_BURST(burst) | TX_SLOT(mep->slot);\r\ncsr1 |= TX_MAX_PKT(num_pkts) | TX_MULT(mult);\r\ncsr2 = TX_FIFOADDR(fifo_addr >> 4);\r\ncsr2 |= TX_FIFOSEGSIZE(fifo_sgsz);\r\nswitch (mep->type) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\ncsr1 |= TX_TYPE(TYPE_BULK);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ncsr1 |= TX_TYPE(TYPE_ISO);\r\ncsr2 |= TX_BINTERVAL(interval);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\ncsr1 |= TX_TYPE(TYPE_INT);\r\ncsr2 |= TX_BINTERVAL(interval);\r\nbreak;\r\n}\r\nmtu3_setbits(mbase, U3D_QIESR0, QMU_TX_DONE_INT(epnum));\r\nmtu3_writel(mbase, MU3D_EP_TXCR0(epnum), csr0);\r\nmtu3_writel(mbase, MU3D_EP_TXCR1(epnum), csr1);\r\nmtu3_writel(mbase, MU3D_EP_TXCR2(epnum), csr2);\r\ndev_dbg(mtu->dev, "U3D_TX%d CSR0:%#x, CSR1:%#x, CSR2:%#x\n",\r\nepnum, mtu3_readl(mbase, MU3D_EP_TXCR0(epnum)),\r\nmtu3_readl(mbase, MU3D_EP_TXCR1(epnum)),\r\nmtu3_readl(mbase, MU3D_EP_TXCR2(epnum)));\r\n} else {\r\ncsr0 = RX_RXMAXPKTSZ(mep->maxp);\r\ncsr0 |= RX_DMAREQEN;\r\nnum_pkts = (burst + 1) * (mult + 1) - 1;\r\ncsr1 = RX_SS_BURST(burst) | RX_SLOT(mep->slot);\r\ncsr1 |= RX_MAX_PKT(num_pkts) | RX_MULT(mult);\r\ncsr2 = RX_FIFOADDR(fifo_addr >> 4);\r\ncsr2 |= RX_FIFOSEGSIZE(fifo_sgsz);\r\nswitch (mep->type) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\ncsr1 |= RX_TYPE(TYPE_BULK);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ncsr1 |= RX_TYPE(TYPE_ISO);\r\ncsr2 |= RX_BINTERVAL(interval);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\ncsr1 |= RX_TYPE(TYPE_INT);\r\ncsr2 |= RX_BINTERVAL(interval);\r\nbreak;\r\n}\r\nmtu3_setbits(mbase, U3D_QIESR0, QMU_RX_DONE_INT(epnum));\r\nmtu3_writel(mbase, MU3D_EP_RXCR0(epnum), csr0);\r\nmtu3_writel(mbase, MU3D_EP_RXCR1(epnum), csr1);\r\nmtu3_writel(mbase, MU3D_EP_RXCR2(epnum), csr2);\r\ndev_dbg(mtu->dev, "U3D_RX%d CSR0:%#x, CSR1:%#x, CSR2:%#x\n",\r\nepnum, mtu3_readl(mbase, MU3D_EP_RXCR0(epnum)),\r\nmtu3_readl(mbase, MU3D_EP_RXCR1(epnum)),\r\nmtu3_readl(mbase, MU3D_EP_RXCR2(epnum)));\r\n}\r\ndev_dbg(mtu->dev, "csr0:%#x, csr1:%#x, csr2:%#x\n", csr0, csr1, csr2);\r\ndev_dbg(mtu->dev, "%s: %s, fifo-addr:%#x, fifo-size:%#x(%#x/%#x)\n",\r\n__func__, mep->name, mep->fifo_addr, mep->fifo_size,\r\nfifo_sgsz, mep->fifo_seg_size);\r\nreturn 0;\r\n}\r\nvoid mtu3_deconfig_ep(struct mtu3 *mtu, struct mtu3_ep *mep)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nint epnum = mep->epnum;\r\nif (mep->is_in) {\r\nmtu3_writel(mbase, MU3D_EP_TXCR0(epnum), 0);\r\nmtu3_writel(mbase, MU3D_EP_TXCR1(epnum), 0);\r\nmtu3_writel(mbase, MU3D_EP_TXCR2(epnum), 0);\r\nmtu3_setbits(mbase, U3D_QIECR0, QMU_TX_DONE_INT(epnum));\r\n} else {\r\nmtu3_writel(mbase, MU3D_EP_RXCR0(epnum), 0);\r\nmtu3_writel(mbase, MU3D_EP_RXCR1(epnum), 0);\r\nmtu3_writel(mbase, MU3D_EP_RXCR2(epnum), 0);\r\nmtu3_setbits(mbase, U3D_QIECR0, QMU_RX_DONE_INT(epnum));\r\n}\r\nep_fifo_free(mep);\r\ndev_dbg(mtu->dev, "%s: %s\n", __func__, mep->name);\r\n}\r\nstatic void get_ep_fifo_config(struct mtu3 *mtu)\r\n{\r\nstruct mtu3_fifo_info *tx_fifo;\r\nstruct mtu3_fifo_info *rx_fifo;\r\nu32 fifosize;\r\nif (mtu->is_u3_ip) {\r\nfifosize = mtu3_readl(mtu->mac_base, U3D_CAP_EPNTXFFSZ);\r\ntx_fifo = &mtu->tx_fifo;\r\ntx_fifo->base = 0;\r\ntx_fifo->limit = fifosize / MTU3_EP_FIFO_UNIT;\r\nbitmap_zero(tx_fifo->bitmap, MTU3_FIFO_BIT_SIZE);\r\nfifosize = mtu3_readl(mtu->mac_base, U3D_CAP_EPNRXFFSZ);\r\nrx_fifo = &mtu->rx_fifo;\r\nrx_fifo->base = 0;\r\nrx_fifo->limit = fifosize / MTU3_EP_FIFO_UNIT;\r\nbitmap_zero(rx_fifo->bitmap, MTU3_FIFO_BIT_SIZE);\r\nmtu->slot = MTU3_U3_IP_SLOT_DEFAULT;\r\n} else {\r\nfifosize = mtu3_readl(mtu->mac_base, U3D_CAP_EPNTXFFSZ);\r\ntx_fifo = &mtu->tx_fifo;\r\ntx_fifo->base = MTU3_U2_IP_EP0_FIFO_SIZE;\r\ntx_fifo->limit = (fifosize / MTU3_EP_FIFO_UNIT) >> 1;\r\nbitmap_zero(tx_fifo->bitmap, MTU3_FIFO_BIT_SIZE);\r\nrx_fifo = &mtu->rx_fifo;\r\nrx_fifo->base =\r\ntx_fifo->base + tx_fifo->limit * MTU3_EP_FIFO_UNIT;\r\nrx_fifo->limit = tx_fifo->limit;\r\nbitmap_zero(rx_fifo->bitmap, MTU3_FIFO_BIT_SIZE);\r\nmtu->slot = MTU3_U2_IP_SLOT_DEFAULT;\r\n}\r\ndev_dbg(mtu->dev, "%s, TX: base-%d, limit-%d; RX: base-%d, limit-%d\n",\r\n__func__, tx_fifo->base, tx_fifo->limit,\r\nrx_fifo->base, rx_fifo->limit);\r\n}\r\nvoid mtu3_ep0_setup(struct mtu3 *mtu)\r\n{\r\nu32 maxpacket = mtu->g.ep0->maxpacket;\r\nu32 csr;\r\ndev_dbg(mtu->dev, "%s maxpacket: %d\n", __func__, maxpacket);\r\ncsr = mtu3_readl(mtu->mac_base, U3D_EP0CSR);\r\ncsr &= ~EP0_MAXPKTSZ_MSK;\r\ncsr |= EP0_MAXPKTSZ(maxpacket);\r\ncsr &= EP0_W1C_BITS;\r\nmtu3_writel(mtu->mac_base, U3D_EP0CSR, csr);\r\nmtu3_writel(mtu->mac_base, U3D_EPIESR, EP0ISR);\r\n}\r\nstatic int mtu3_mem_alloc(struct mtu3 *mtu)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nstruct mtu3_ep *ep_array;\r\nint in_ep_num, out_ep_num;\r\nu32 cap_epinfo;\r\nint ret;\r\nint i;\r\ncap_epinfo = mtu3_readl(mbase, U3D_CAP_EPINFO);\r\nin_ep_num = CAP_TX_EP_NUM(cap_epinfo);\r\nout_ep_num = CAP_RX_EP_NUM(cap_epinfo);\r\ndev_info(mtu->dev, "fifosz/epnum: Tx=%#x/%d, Rx=%#x/%d\n",\r\nmtu3_readl(mbase, U3D_CAP_EPNTXFFSZ), in_ep_num,\r\nmtu3_readl(mbase, U3D_CAP_EPNRXFFSZ), out_ep_num);\r\nmtu->num_eps = min(in_ep_num, out_ep_num) + 1;\r\nep_array = kcalloc(mtu->num_eps * 2, sizeof(*ep_array), GFP_KERNEL);\r\nif (ep_array == NULL)\r\nreturn -ENOMEM;\r\nmtu->ep_array = ep_array;\r\nmtu->in_eps = ep_array;\r\nmtu->out_eps = &ep_array[mtu->num_eps];\r\nmtu->ep0 = mtu->in_eps;\r\nmtu->ep0->mtu = mtu;\r\nmtu->ep0->epnum = 0;\r\nfor (i = 1; i < mtu->num_eps; i++) {\r\nstruct mtu3_ep *mep = mtu->in_eps + i;\r\nmep->fifo = &mtu->tx_fifo;\r\nmep = mtu->out_eps + i;\r\nmep->fifo = &mtu->rx_fifo;\r\n}\r\nget_ep_fifo_config(mtu);\r\nret = mtu3_qmu_init(mtu);\r\nif (ret)\r\nkfree(mtu->ep_array);\r\nreturn ret;\r\n}\r\nstatic void mtu3_mem_free(struct mtu3 *mtu)\r\n{\r\nmtu3_qmu_exit(mtu);\r\nkfree(mtu->ep_array);\r\n}\r\nstatic void mtu3_set_speed(struct mtu3 *mtu)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nif (!mtu->is_u3_ip && (mtu->max_speed > USB_SPEED_HIGH))\r\nmtu->max_speed = USB_SPEED_HIGH;\r\nif (mtu->max_speed == USB_SPEED_FULL) {\r\nmtu3_clrbits(mbase, U3D_USB3_CONFIG, USB3_EN);\r\nmtu3_clrbits(mbase, U3D_POWER_MANAGEMENT, HS_ENABLE);\r\n} else if (mtu->max_speed == USB_SPEED_HIGH) {\r\nmtu3_clrbits(mbase, U3D_USB3_CONFIG, USB3_EN);\r\nmtu3_setbits(mbase, U3D_POWER_MANAGEMENT, HS_ENABLE);\r\n}\r\ndev_info(mtu->dev, "max_speed: %s\n",\r\nusb_speed_string(mtu->max_speed));\r\n}\r\nstatic void mtu3_regs_init(struct mtu3 *mtu)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nmtu3_intr_disable(mtu);\r\nmtu3_intr_status_clear(mtu);\r\nif (mtu->is_u3_ip) {\r\nmtu3_clrbits(mbase, U3D_LINK_POWER_CONTROL,\r\nSW_U1_ACCEPT_ENABLE | SW_U2_ACCEPT_ENABLE |\r\nSW_U1_REQUEST_ENABLE | SW_U2_REQUEST_ENABLE);\r\nmtu3_clrbits(mbase, U3D_LTSSM_CTRL, SOFT_U3_EXIT_EN);\r\nmtu3_setbits(mbase, U3D_USB2_TEST_MODE, U2U3_AUTO_SWITCH);\r\n}\r\nmtu3_set_speed(mtu);\r\nmtu3_clrbits(mbase, U3D_LINK_RESET_INFO, WTCHRP_MSK);\r\nmtu3_writel(mbase, U3D_DEVICE_CONF, 0);\r\nmtu3_setbits(mbase, U3D_QCR0, QMU_CS16B_EN);\r\nmtu3_clrbits(mbase, U3D_MISC_CTRL, VBUS_FRC_EN | VBUS_ON);\r\n}\r\nstatic irqreturn_t mtu3_link_isr(struct mtu3 *mtu)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nenum usb_device_speed udev_speed;\r\nu32 maxpkt = 64;\r\nu32 link;\r\nu32 speed;\r\nlink = mtu3_readl(mbase, U3D_DEV_LINK_INTR);\r\nlink &= mtu3_readl(mbase, U3D_DEV_LINK_INTR_ENABLE);\r\nmtu3_writel(mbase, U3D_DEV_LINK_INTR, link);\r\ndev_dbg(mtu->dev, "=== LINK[%x] ===\n", link);\r\nif (!(link & SSUSB_DEV_SPEED_CHG_INTR))\r\nreturn IRQ_NONE;\r\nspeed = SSUSB_DEV_SPEED(mtu3_readl(mbase, U3D_DEVICE_CONF));\r\nswitch (speed) {\r\ncase MTU3_SPEED_FULL:\r\nudev_speed = USB_SPEED_FULL;\r\nmtu3_writel(mbase, U3D_USB20_LPM_PARAMETER, LPM_BESLDCK(0xf)\r\n| LPM_BESLCK(4) | LPM_BESLCK_U3(0xa));\r\nmtu3_setbits(mbase, U3D_POWER_MANAGEMENT,\r\nLPM_BESL_STALL | LPM_BESLD_STALL);\r\nbreak;\r\ncase MTU3_SPEED_HIGH:\r\nudev_speed = USB_SPEED_HIGH;\r\nmtu3_writel(mbase, U3D_USB20_LPM_PARAMETER, LPM_BESLDCK(0xf)\r\n| LPM_BESLCK(4) | LPM_BESLCK_U3(0xa));\r\nmtu3_setbits(mbase, U3D_POWER_MANAGEMENT,\r\nLPM_BESL_STALL | LPM_BESLD_STALL);\r\nbreak;\r\ncase MTU3_SPEED_SUPER:\r\nudev_speed = USB_SPEED_SUPER;\r\nmaxpkt = 512;\r\nbreak;\r\ndefault:\r\nudev_speed = USB_SPEED_UNKNOWN;\r\nbreak;\r\n}\r\ndev_dbg(mtu->dev, "%s: %s\n", __func__, usb_speed_string(udev_speed));\r\nmtu->g.speed = udev_speed;\r\nmtu->g.ep0->maxpacket = maxpkt;\r\nmtu->ep0_state = MU3D_EP0_STATE_SETUP;\r\nif (udev_speed == USB_SPEED_UNKNOWN)\r\nmtu3_gadget_disconnect(mtu);\r\nelse\r\nmtu3_ep0_setup(mtu);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mtu3_u3_ltssm_isr(struct mtu3 *mtu)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nu32 ltssm;\r\nltssm = mtu3_readl(mbase, U3D_LTSSM_INTR);\r\nltssm &= mtu3_readl(mbase, U3D_LTSSM_INTR_ENABLE);\r\nmtu3_writel(mbase, U3D_LTSSM_INTR, ltssm);\r\ndev_dbg(mtu->dev, "=== LTSSM[%x] ===\n", ltssm);\r\nif (ltssm & (HOT_RST_INTR | WARM_RST_INTR))\r\nmtu3_gadget_reset(mtu);\r\nif (ltssm & VBUS_FALL_INTR)\r\nmtu3_ss_func_set(mtu, false);\r\nif (ltssm & VBUS_RISE_INTR)\r\nmtu3_ss_func_set(mtu, true);\r\nif (ltssm & EXIT_U3_INTR)\r\nmtu3_gadget_resume(mtu);\r\nif (ltssm & ENTER_U3_INTR)\r\nmtu3_gadget_suspend(mtu);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mtu3_u2_common_isr(struct mtu3 *mtu)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nu32 u2comm;\r\nu2comm = mtu3_readl(mbase, U3D_COMMON_USB_INTR);\r\nu2comm &= mtu3_readl(mbase, U3D_COMMON_USB_INTR_ENABLE);\r\nmtu3_writel(mbase, U3D_COMMON_USB_INTR, u2comm);\r\ndev_dbg(mtu->dev, "=== U2COMM[%x] ===\n", u2comm);\r\nif (u2comm & SUSPEND_INTR)\r\nmtu3_gadget_suspend(mtu);\r\nif (u2comm & RESUME_INTR)\r\nmtu3_gadget_resume(mtu);\r\nif (u2comm & RESET_INTR)\r\nmtu3_gadget_reset(mtu);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mtu3_irq(int irq, void *data)\r\n{\r\nstruct mtu3 *mtu = (struct mtu3 *)data;\r\nunsigned long flags;\r\nu32 level1;\r\nspin_lock_irqsave(&mtu->lock, flags);\r\nlevel1 = mtu3_readl(mtu->mac_base, U3D_LV1ISR);\r\nlevel1 &= mtu3_readl(mtu->mac_base, U3D_LV1IER);\r\nif (level1 & EP_CTRL_INTR)\r\nmtu3_link_isr(mtu);\r\nif (level1 & MAC2_INTR)\r\nmtu3_u2_common_isr(mtu);\r\nif (level1 & MAC3_INTR)\r\nmtu3_u3_ltssm_isr(mtu);\r\nif (level1 & BMU_INTR)\r\nmtu3_ep0_isr(mtu);\r\nif (level1 & QMU_INTR)\r\nmtu3_qmu_isr(mtu);\r\nspin_unlock_irqrestore(&mtu->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mtu3_hw_init(struct mtu3 *mtu)\r\n{\r\nu32 cap_dev;\r\nint ret;\r\nmtu->hw_version = mtu3_readl(mtu->ippc_base, U3D_SSUSB_HW_ID);\r\ncap_dev = mtu3_readl(mtu->ippc_base, U3D_SSUSB_IP_DEV_CAP);\r\nmtu->is_u3_ip = !!SSUSB_IP_DEV_U3_PORT_NUM(cap_dev);\r\ndev_info(mtu->dev, "IP version 0x%x(%s IP)\n", mtu->hw_version,\r\nmtu->is_u3_ip ? "U3" : "U2");\r\nmtu3_device_reset(mtu);\r\nret = mtu3_device_enable(mtu);\r\nif (ret) {\r\ndev_err(mtu->dev, "device enable failed %d\n", ret);\r\nreturn ret;\r\n}\r\nret = mtu3_mem_alloc(mtu);\r\nif (ret)\r\nreturn -ENOMEM;\r\nmtu3_regs_init(mtu);\r\nreturn 0;\r\n}\r\nstatic void mtu3_hw_exit(struct mtu3 *mtu)\r\n{\r\nmtu3_device_disable(mtu);\r\nmtu3_mem_free(mtu);\r\n}\r\nint ssusb_gadget_init(struct ssusb_mtk *ssusb)\r\n{\r\nstruct device *dev = ssusb->dev;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct mtu3 *mtu = NULL;\r\nstruct resource *res;\r\nint ret = -ENOMEM;\r\nmtu = devm_kzalloc(dev, sizeof(struct mtu3), GFP_KERNEL);\r\nif (mtu == NULL)\r\nreturn -ENOMEM;\r\nmtu->irq = platform_get_irq(pdev, 0);\r\nif (mtu->irq <= 0) {\r\ndev_err(dev, "fail to get irq number\n");\r\nreturn -ENODEV;\r\n}\r\ndev_info(dev, "irq %d\n", mtu->irq);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mac");\r\nmtu->mac_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(mtu->mac_base)) {\r\ndev_err(dev, "error mapping memory for dev mac\n");\r\nreturn PTR_ERR(mtu->mac_base);\r\n}\r\nspin_lock_init(&mtu->lock);\r\nmtu->dev = dev;\r\nmtu->ippc_base = ssusb->ippc_base;\r\nssusb->mac_base = mtu->mac_base;\r\nssusb->u3d = mtu;\r\nmtu->ssusb = ssusb;\r\nmtu->max_speed = usb_get_maximum_speed(dev);\r\nswitch (mtu->max_speed) {\r\ncase USB_SPEED_FULL:\r\ncase USB_SPEED_HIGH:\r\ncase USB_SPEED_SUPER:\r\nbreak;\r\ndefault:\r\ndev_err(dev, "invalid max_speed: %s\n",\r\nusb_speed_string(mtu->max_speed));\r\ncase USB_SPEED_UNKNOWN:\r\nmtu->max_speed = USB_SPEED_SUPER;\r\nbreak;\r\n}\r\ndev_dbg(dev, "mac_base=0x%p, ippc_base=0x%p\n",\r\nmtu->mac_base, mtu->ippc_base);\r\nret = mtu3_hw_init(mtu);\r\nif (ret) {\r\ndev_err(dev, "mtu3 hw init failed:%d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_request_irq(dev, mtu->irq, mtu3_irq, 0, dev_name(dev), mtu);\r\nif (ret) {\r\ndev_err(dev, "request irq %d failed!\n", mtu->irq);\r\ngoto irq_err;\r\n}\r\ndevice_init_wakeup(dev, true);\r\nret = mtu3_gadget_setup(mtu);\r\nif (ret) {\r\ndev_err(dev, "mtu3 gadget init failed:%d\n", ret);\r\ngoto gadget_err;\r\n}\r\nif (mtu->ssusb->dr_mode == USB_DR_MODE_OTG)\r\nmtu3_stop(mtu);\r\ndev_dbg(dev, " %s() done...\n", __func__);\r\nreturn 0;\r\ngadget_err:\r\ndevice_init_wakeup(dev, false);\r\nirq_err:\r\nmtu3_hw_exit(mtu);\r\nssusb->u3d = NULL;\r\ndev_err(dev, " %s() fail...\n", __func__);\r\nreturn ret;\r\n}\r\nvoid ssusb_gadget_exit(struct ssusb_mtk *ssusb)\r\n{\r\nstruct mtu3 *mtu = ssusb->u3d;\r\nmtu3_gadget_cleanup(mtu);\r\ndevice_init_wakeup(ssusb->dev, false);\r\nmtu3_hw_exit(mtu);\r\n}
