static int atmel_hlcdc_attach_endpoint(struct drm_device *dev, int endpoint)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct drm_panel *panel;\r\nstruct drm_bridge *bridge;\r\nint ret;\r\nret = drm_of_find_panel_or_bridge(dev->dev->of_node, 0, endpoint,\r\n&panel, &bridge);\r\nif (ret)\r\nreturn ret;\r\nencoder = devm_kzalloc(dev->dev, sizeof(*encoder), GFP_KERNEL);\r\nif (!encoder)\r\nreturn -EINVAL;\r\nret = drm_encoder_init(dev, encoder,\r\n&atmel_hlcdc_panel_encoder_funcs,\r\nDRM_MODE_ENCODER_NONE, NULL);\r\nif (ret)\r\nreturn ret;\r\nencoder->possible_crtcs = 0x1;\r\nif (panel) {\r\nbridge = drm_panel_bridge_add(panel, DRM_MODE_CONNECTOR_Unknown);\r\nif (IS_ERR(bridge))\r\nreturn PTR_ERR(bridge);\r\n}\r\nif (bridge) {\r\nret = drm_bridge_attach(encoder, bridge, NULL);\r\nif (!ret)\r\nreturn 0;\r\nif (panel)\r\ndrm_panel_bridge_remove(bridge);\r\n}\r\ndrm_encoder_cleanup(encoder);\r\nreturn ret;\r\n}\r\nint atmel_hlcdc_create_outputs(struct drm_device *dev)\r\n{\r\nint endpoint, ret = 0;\r\nfor (endpoint = 0; !ret; endpoint++)\r\nret = atmel_hlcdc_attach_endpoint(dev, endpoint);\r\nif (ret == -ENODEV && endpoint)\r\nreturn 0;\r\nreturn ret;\r\n}
