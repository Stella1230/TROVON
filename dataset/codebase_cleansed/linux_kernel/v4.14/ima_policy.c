static int __init default_measure_policy_setup(char *str)\r\n{\r\nif (ima_policy)\r\nreturn 1;\r\nima_policy = ORIGINAL_TCB;\r\nreturn 1;\r\n}\r\nstatic int __init policy_setup(char *str)\r\n{\r\nchar *p;\r\nwhile ((p = strsep(&str, " |\n")) != NULL) {\r\nif (*p == ' ')\r\ncontinue;\r\nif ((strcmp(p, "tcb") == 0) && !ima_policy)\r\nima_policy = DEFAULT_TCB;\r\nelse if (strcmp(p, "appraise_tcb") == 0)\r\nima_use_appraise_tcb = 1;\r\nelse if (strcmp(p, "secure_boot") == 0)\r\nima_use_secure_boot = 1;\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init default_appraise_policy_setup(char *str)\r\n{\r\nima_use_appraise_tcb = 1;\r\nreturn 1;\r\n}\r\nstatic void ima_lsm_update_rules(void)\r\n{\r\nstruct ima_rule_entry *entry;\r\nint result;\r\nint i;\r\nlist_for_each_entry(entry, &ima_policy_rules, list) {\r\nfor (i = 0; i < MAX_LSM_RULES; i++) {\r\nif (!entry->lsm[i].rule)\r\ncontinue;\r\nresult = security_filter_rule_init(entry->lsm[i].type,\r\nAudit_equal,\r\nentry->lsm[i].args_p,\r\n&entry->lsm[i].rule);\r\nBUG_ON(!entry->lsm[i].rule);\r\n}\r\n}\r\n}\r\nstatic bool ima_match_rules(struct ima_rule_entry *rule, struct inode *inode,\r\nenum ima_hooks func, int mask)\r\n{\r\nstruct task_struct *tsk = current;\r\nconst struct cred *cred = current_cred();\r\nint i;\r\nif ((rule->flags & IMA_FUNC) &&\r\n(rule->func != func && func != POST_SETATTR))\r\nreturn false;\r\nif ((rule->flags & IMA_MASK) &&\r\n(rule->mask != mask && func != POST_SETATTR))\r\nreturn false;\r\nif ((rule->flags & IMA_INMASK) &&\r\n(!(rule->mask & mask) && func != POST_SETATTR))\r\nreturn false;\r\nif ((rule->flags & IMA_FSMAGIC)\r\n&& rule->fsmagic != inode->i_sb->s_magic)\r\nreturn false;\r\nif ((rule->flags & IMA_FSUUID) &&\r\n!uuid_equal(&rule->fsuuid, &inode->i_sb->s_uuid))\r\nreturn false;\r\nif ((rule->flags & IMA_UID) && !rule->uid_op(cred->uid, rule->uid))\r\nreturn false;\r\nif (rule->flags & IMA_EUID) {\r\nif (has_capability_noaudit(current, CAP_SETUID)) {\r\nif (!rule->uid_op(cred->euid, rule->uid)\r\n&& !rule->uid_op(cred->suid, rule->uid)\r\n&& !rule->uid_op(cred->uid, rule->uid))\r\nreturn false;\r\n} else if (!rule->uid_op(cred->euid, rule->uid))\r\nreturn false;\r\n}\r\nif ((rule->flags & IMA_FOWNER) &&\r\n!rule->fowner_op(inode->i_uid, rule->fowner))\r\nreturn false;\r\nfor (i = 0; i < MAX_LSM_RULES; i++) {\r\nint rc = 0;\r\nu32 osid, sid;\r\nint retried = 0;\r\nif (!rule->lsm[i].rule)\r\ncontinue;\r\nretry:\r\nswitch (i) {\r\ncase LSM_OBJ_USER:\r\ncase LSM_OBJ_ROLE:\r\ncase LSM_OBJ_TYPE:\r\nsecurity_inode_getsecid(inode, &osid);\r\nrc = security_filter_rule_match(osid,\r\nrule->lsm[i].type,\r\nAudit_equal,\r\nrule->lsm[i].rule,\r\nNULL);\r\nbreak;\r\ncase LSM_SUBJ_USER:\r\ncase LSM_SUBJ_ROLE:\r\ncase LSM_SUBJ_TYPE:\r\nsecurity_task_getsecid(tsk, &sid);\r\nrc = security_filter_rule_match(sid,\r\nrule->lsm[i].type,\r\nAudit_equal,\r\nrule->lsm[i].rule,\r\nNULL);\r\ndefault:\r\nbreak;\r\n}\r\nif ((rc < 0) && (!retried)) {\r\nretried = 1;\r\nima_lsm_update_rules();\r\ngoto retry;\r\n}\r\nif (!rc)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int get_subaction(struct ima_rule_entry *rule, enum ima_hooks func)\r\n{\r\nif (!(rule->flags & IMA_FUNC))\r\nreturn IMA_FILE_APPRAISE;\r\nswitch (func) {\r\ncase MMAP_CHECK:\r\nreturn IMA_MMAP_APPRAISE;\r\ncase BPRM_CHECK:\r\nreturn IMA_BPRM_APPRAISE;\r\ncase FILE_CHECK:\r\ncase POST_SETATTR:\r\nreturn IMA_FILE_APPRAISE;\r\ncase MODULE_CHECK ... MAX_CHECK - 1:\r\ndefault:\r\nreturn IMA_READ_APPRAISE;\r\n}\r\n}\r\nint ima_match_policy(struct inode *inode, enum ima_hooks func, int mask,\r\nint flags, int *pcr)\r\n{\r\nstruct ima_rule_entry *entry;\r\nint action = 0, actmask = flags | (flags << 1);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(entry, ima_rules, list) {\r\nif (!(entry->action & actmask))\r\ncontinue;\r\nif (!ima_match_rules(entry, inode, func, mask))\r\ncontinue;\r\naction |= entry->flags & IMA_ACTION_FLAGS;\r\naction |= entry->action & IMA_DO_MASK;\r\nif (entry->action & IMA_APPRAISE)\r\naction |= get_subaction(entry, func);\r\nif (entry->action & IMA_DO_MASK)\r\nactmask &= ~(entry->action | entry->action << 1);\r\nelse\r\nactmask &= ~(entry->action | entry->action >> 1);\r\nif ((pcr) && (entry->flags & IMA_PCR))\r\n*pcr = entry->pcr;\r\nif (!actmask)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn action;\r\n}\r\nvoid ima_update_policy_flag(void)\r\n{\r\nstruct ima_rule_entry *entry;\r\nlist_for_each_entry(entry, ima_rules, list) {\r\nif (entry->action & IMA_DO_MASK)\r\nima_policy_flag |= entry->action;\r\n}\r\nima_appraise |= temp_ima_appraise;\r\nif (!ima_appraise)\r\nima_policy_flag &= ~IMA_APPRAISE;\r\n}\r\nvoid __init ima_init_policy(void)\r\n{\r\nint i, measure_entries, appraise_entries, secure_boot_entries;\r\nmeasure_entries = ima_policy ? ARRAY_SIZE(dont_measure_rules) : 0;\r\nappraise_entries = ima_use_appraise_tcb ?\r\nARRAY_SIZE(default_appraise_rules) : 0;\r\nsecure_boot_entries = ima_use_secure_boot ?\r\nARRAY_SIZE(secure_boot_rules) : 0;\r\nfor (i = 0; i < measure_entries; i++)\r\nlist_add_tail(&dont_measure_rules[i].list, &ima_default_rules);\r\nswitch (ima_policy) {\r\ncase ORIGINAL_TCB:\r\nfor (i = 0; i < ARRAY_SIZE(original_measurement_rules); i++)\r\nlist_add_tail(&original_measurement_rules[i].list,\r\n&ima_default_rules);\r\nbreak;\r\ncase DEFAULT_TCB:\r\nfor (i = 0; i < ARRAY_SIZE(default_measurement_rules); i++)\r\nlist_add_tail(&default_measurement_rules[i].list,\r\n&ima_default_rules);\r\ndefault:\r\nbreak;\r\n}\r\nfor (i = 0; i < secure_boot_entries; i++)\r\nlist_add_tail(&secure_boot_rules[i].list,\r\n&ima_default_rules);\r\nfor (i = 0; i < appraise_entries; i++) {\r\nlist_add_tail(&default_appraise_rules[i].list,\r\n&ima_default_rules);\r\nif (default_appraise_rules[i].func == POLICY_CHECK)\r\ntemp_ima_appraise |= IMA_APPRAISE_POLICY;\r\n}\r\nima_rules = &ima_default_rules;\r\nima_update_policy_flag();\r\n}\r\nint ima_check_policy(void)\r\n{\r\nif (list_empty(&ima_temp_rules))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nvoid ima_update_policy(void)\r\n{\r\nstruct list_head *first, *last, *policy;\r\nfirst = (&ima_temp_rules)->next;\r\nlast = (&ima_temp_rules)->prev;\r\npolicy = &ima_policy_rules;\r\nsynchronize_rcu();\r\nlast->next = policy;\r\nrcu_assign_pointer(list_next_rcu(policy->prev), first);\r\nfirst->prev = policy->prev;\r\npolicy->prev = last;\r\nINIT_LIST_HEAD(&ima_temp_rules);\r\nif (ima_rules != policy) {\r\nima_policy_flag = 0;\r\nima_rules = policy;\r\n}\r\nima_update_policy_flag();\r\n}\r\nstatic int ima_lsm_rule_init(struct ima_rule_entry *entry,\r\nsubstring_t *args, int lsm_rule, int audit_type)\r\n{\r\nint result;\r\nif (entry->lsm[lsm_rule].rule)\r\nreturn -EINVAL;\r\nentry->lsm[lsm_rule].args_p = match_strdup(args);\r\nif (!entry->lsm[lsm_rule].args_p)\r\nreturn -ENOMEM;\r\nentry->lsm[lsm_rule].type = audit_type;\r\nresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\r\nAudit_equal,\r\nentry->lsm[lsm_rule].args_p,\r\n&entry->lsm[lsm_rule].rule);\r\nif (!entry->lsm[lsm_rule].rule) {\r\nkfree(entry->lsm[lsm_rule].args_p);\r\nreturn -EINVAL;\r\n}\r\nreturn result;\r\n}\r\nstatic void ima_log_string_op(struct audit_buffer *ab, char *key, char *value,\r\nbool (*rule_operator)(kuid_t, kuid_t))\r\n{\r\nif (rule_operator == &uid_gt)\r\naudit_log_format(ab, "%s>", key);\r\nelse if (rule_operator == &uid_lt)\r\naudit_log_format(ab, "%s<", key);\r\nelse\r\naudit_log_format(ab, "%s=", key);\r\naudit_log_untrustedstring(ab, value);\r\naudit_log_format(ab, " ");\r\n}\r\nstatic void ima_log_string(struct audit_buffer *ab, char *key, char *value)\r\n{\r\nima_log_string_op(ab, key, value, NULL);\r\n}\r\nstatic int ima_parse_rule(char *rule, struct ima_rule_entry *entry)\r\n{\r\nstruct audit_buffer *ab;\r\nchar *from;\r\nchar *p;\r\nbool uid_token;\r\nint result = 0;\r\nab = audit_log_start(NULL, GFP_KERNEL, AUDIT_INTEGRITY_RULE);\r\nentry->uid = INVALID_UID;\r\nentry->fowner = INVALID_UID;\r\nentry->uid_op = &uid_eq;\r\nentry->fowner_op = &uid_eq;\r\nentry->action = UNKNOWN;\r\nwhile ((p = strsep(&rule, " \t")) != NULL) {\r\nsubstring_t args[MAX_OPT_ARGS];\r\nint token;\r\nunsigned long lnum;\r\nif (result < 0)\r\nbreak;\r\nif ((*p == '\0') || (*p == ' ') || (*p == '\t'))\r\ncontinue;\r\ntoken = match_token(p, policy_tokens, args);\r\nswitch (token) {\r\ncase Opt_measure:\r\nima_log_string(ab, "action", "measure");\r\nif (entry->action != UNKNOWN)\r\nresult = -EINVAL;\r\nentry->action = MEASURE;\r\nbreak;\r\ncase Opt_dont_measure:\r\nima_log_string(ab, "action", "dont_measure");\r\nif (entry->action != UNKNOWN)\r\nresult = -EINVAL;\r\nentry->action = DONT_MEASURE;\r\nbreak;\r\ncase Opt_appraise:\r\nima_log_string(ab, "action", "appraise");\r\nif (entry->action != UNKNOWN)\r\nresult = -EINVAL;\r\nentry->action = APPRAISE;\r\nbreak;\r\ncase Opt_dont_appraise:\r\nima_log_string(ab, "action", "dont_appraise");\r\nif (entry->action != UNKNOWN)\r\nresult = -EINVAL;\r\nentry->action = DONT_APPRAISE;\r\nbreak;\r\ncase Opt_audit:\r\nima_log_string(ab, "action", "audit");\r\nif (entry->action != UNKNOWN)\r\nresult = -EINVAL;\r\nentry->action = AUDIT;\r\nbreak;\r\ncase Opt_func:\r\nima_log_string(ab, "func", args[0].from);\r\nif (entry->func)\r\nresult = -EINVAL;\r\nif (strcmp(args[0].from, "FILE_CHECK") == 0)\r\nentry->func = FILE_CHECK;\r\nelse if (strcmp(args[0].from, "PATH_CHECK") == 0)\r\nentry->func = FILE_CHECK;\r\nelse if (strcmp(args[0].from, "MODULE_CHECK") == 0)\r\nentry->func = MODULE_CHECK;\r\nelse if (strcmp(args[0].from, "FIRMWARE_CHECK") == 0)\r\nentry->func = FIRMWARE_CHECK;\r\nelse if ((strcmp(args[0].from, "FILE_MMAP") == 0)\r\n|| (strcmp(args[0].from, "MMAP_CHECK") == 0))\r\nentry->func = MMAP_CHECK;\r\nelse if (strcmp(args[0].from, "BPRM_CHECK") == 0)\r\nentry->func = BPRM_CHECK;\r\nelse if (strcmp(args[0].from, "KEXEC_KERNEL_CHECK") ==\r\n0)\r\nentry->func = KEXEC_KERNEL_CHECK;\r\nelse if (strcmp(args[0].from, "KEXEC_INITRAMFS_CHECK")\r\n== 0)\r\nentry->func = KEXEC_INITRAMFS_CHECK;\r\nelse if (strcmp(args[0].from, "POLICY_CHECK") == 0)\r\nentry->func = POLICY_CHECK;\r\nelse\r\nresult = -EINVAL;\r\nif (!result)\r\nentry->flags |= IMA_FUNC;\r\nbreak;\r\ncase Opt_mask:\r\nima_log_string(ab, "mask", args[0].from);\r\nif (entry->mask)\r\nresult = -EINVAL;\r\nfrom = args[0].from;\r\nif (*from == '^')\r\nfrom++;\r\nif ((strcmp(from, "MAY_EXEC")) == 0)\r\nentry->mask = MAY_EXEC;\r\nelse if (strcmp(from, "MAY_WRITE") == 0)\r\nentry->mask = MAY_WRITE;\r\nelse if (strcmp(from, "MAY_READ") == 0)\r\nentry->mask = MAY_READ;\r\nelse if (strcmp(from, "MAY_APPEND") == 0)\r\nentry->mask = MAY_APPEND;\r\nelse\r\nresult = -EINVAL;\r\nif (!result)\r\nentry->flags |= (*args[0].from == '^')\r\n? IMA_INMASK : IMA_MASK;\r\nbreak;\r\ncase Opt_fsmagic:\r\nima_log_string(ab, "fsmagic", args[0].from);\r\nif (entry->fsmagic) {\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nresult = kstrtoul(args[0].from, 16, &entry->fsmagic);\r\nif (!result)\r\nentry->flags |= IMA_FSMAGIC;\r\nbreak;\r\ncase Opt_fsuuid:\r\nima_log_string(ab, "fsuuid", args[0].from);\r\nif (uuid_is_null(&entry->fsuuid)) {\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nresult = uuid_parse(args[0].from, &entry->fsuuid);\r\nif (!result)\r\nentry->flags |= IMA_FSUUID;\r\nbreak;\r\ncase Opt_uid_gt:\r\ncase Opt_euid_gt:\r\nentry->uid_op = &uid_gt;\r\ncase Opt_uid_lt:\r\ncase Opt_euid_lt:\r\nif ((token == Opt_uid_lt) || (token == Opt_euid_lt))\r\nentry->uid_op = &uid_lt;\r\ncase Opt_uid_eq:\r\ncase Opt_euid_eq:\r\nuid_token = (token == Opt_uid_eq) ||\r\n(token == Opt_uid_gt) ||\r\n(token == Opt_uid_lt);\r\nima_log_string_op(ab, uid_token ? "uid" : "euid",\r\nargs[0].from, entry->uid_op);\r\nif (uid_valid(entry->uid)) {\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nresult = kstrtoul(args[0].from, 10, &lnum);\r\nif (!result) {\r\nentry->uid = make_kuid(current_user_ns(),\r\n(uid_t) lnum);\r\nif (!uid_valid(entry->uid) ||\r\n(uid_t)lnum != lnum)\r\nresult = -EINVAL;\r\nelse\r\nentry->flags |= uid_token\r\n? IMA_UID : IMA_EUID;\r\n}\r\nbreak;\r\ncase Opt_fowner_gt:\r\nentry->fowner_op = &uid_gt;\r\ncase Opt_fowner_lt:\r\nif (token == Opt_fowner_lt)\r\nentry->fowner_op = &uid_lt;\r\ncase Opt_fowner_eq:\r\nima_log_string_op(ab, "fowner", args[0].from,\r\nentry->fowner_op);\r\nif (uid_valid(entry->fowner)) {\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nresult = kstrtoul(args[0].from, 10, &lnum);\r\nif (!result) {\r\nentry->fowner = make_kuid(current_user_ns(), (uid_t)lnum);\r\nif (!uid_valid(entry->fowner) || (((uid_t)lnum) != lnum))\r\nresult = -EINVAL;\r\nelse\r\nentry->flags |= IMA_FOWNER;\r\n}\r\nbreak;\r\ncase Opt_obj_user:\r\nima_log_string(ab, "obj_user", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args,\r\nLSM_OBJ_USER,\r\nAUDIT_OBJ_USER);\r\nbreak;\r\ncase Opt_obj_role:\r\nima_log_string(ab, "obj_role", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args,\r\nLSM_OBJ_ROLE,\r\nAUDIT_OBJ_ROLE);\r\nbreak;\r\ncase Opt_obj_type:\r\nima_log_string(ab, "obj_type", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args,\r\nLSM_OBJ_TYPE,\r\nAUDIT_OBJ_TYPE);\r\nbreak;\r\ncase Opt_subj_user:\r\nima_log_string(ab, "subj_user", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args,\r\nLSM_SUBJ_USER,\r\nAUDIT_SUBJ_USER);\r\nbreak;\r\ncase Opt_subj_role:\r\nima_log_string(ab, "subj_role", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args,\r\nLSM_SUBJ_ROLE,\r\nAUDIT_SUBJ_ROLE);\r\nbreak;\r\ncase Opt_subj_type:\r\nima_log_string(ab, "subj_type", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args,\r\nLSM_SUBJ_TYPE,\r\nAUDIT_SUBJ_TYPE);\r\nbreak;\r\ncase Opt_appraise_type:\r\nif (entry->action != APPRAISE) {\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nima_log_string(ab, "appraise_type", args[0].from);\r\nif ((strcmp(args[0].from, "imasig")) == 0)\r\nentry->flags |= IMA_DIGSIG_REQUIRED;\r\nelse\r\nresult = -EINVAL;\r\nbreak;\r\ncase Opt_permit_directio:\r\nentry->flags |= IMA_PERMIT_DIRECTIO;\r\nbreak;\r\ncase Opt_pcr:\r\nif (entry->action != MEASURE) {\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nima_log_string(ab, "pcr", args[0].from);\r\nresult = kstrtoint(args[0].from, 10, &entry->pcr);\r\nif (result || INVALID_PCR(entry->pcr))\r\nresult = -EINVAL;\r\nelse\r\nentry->flags |= IMA_PCR;\r\nbreak;\r\ncase Opt_err:\r\nima_log_string(ab, "UNKNOWN", p);\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nif (!result && (entry->action == UNKNOWN))\r\nresult = -EINVAL;\r\nelse if (entry->func == MODULE_CHECK)\r\ntemp_ima_appraise |= IMA_APPRAISE_MODULES;\r\nelse if (entry->func == FIRMWARE_CHECK)\r\ntemp_ima_appraise |= IMA_APPRAISE_FIRMWARE;\r\nelse if (entry->func == POLICY_CHECK)\r\ntemp_ima_appraise |= IMA_APPRAISE_POLICY;\r\naudit_log_format(ab, "res=%d", !result);\r\naudit_log_end(ab);\r\nreturn result;\r\n}\r\nssize_t ima_parse_add_rule(char *rule)\r\n{\r\nstatic const char op[] = "update_policy";\r\nchar *p;\r\nstruct ima_rule_entry *entry;\r\nssize_t result, len;\r\nint audit_info = 0;\r\np = strsep(&rule, "\n");\r\nlen = strlen(p) + 1;\r\np += strspn(p, " \t");\r\nif (*p == '#' || *p == '\0')\r\nreturn len;\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry) {\r\nintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\r\nNULL, op, "-ENOMEM", -ENOMEM, audit_info);\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&entry->list);\r\nresult = ima_parse_rule(p, entry);\r\nif (result) {\r\nkfree(entry);\r\nintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\r\nNULL, op, "invalid-policy", result,\r\naudit_info);\r\nreturn result;\r\n}\r\nlist_add_tail(&entry->list, &ima_temp_rules);\r\nreturn len;\r\n}\r\nvoid ima_delete_rules(void)\r\n{\r\nstruct ima_rule_entry *entry, *tmp;\r\nint i;\r\ntemp_ima_appraise = 0;\r\nlist_for_each_entry_safe(entry, tmp, &ima_temp_rules, list) {\r\nfor (i = 0; i < MAX_LSM_RULES; i++)\r\nkfree(entry->lsm[i].args_p);\r\nlist_del(&entry->list);\r\nkfree(entry);\r\n}\r\n}\r\nvoid *ima_policy_start(struct seq_file *m, loff_t *pos)\r\n{\r\nloff_t l = *pos;\r\nstruct ima_rule_entry *entry;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(entry, ima_rules, list) {\r\nif (!l--) {\r\nrcu_read_unlock();\r\nreturn entry;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nvoid *ima_policy_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nstruct ima_rule_entry *entry = v;\r\nrcu_read_lock();\r\nentry = list_entry_rcu(entry->list.next, struct ima_rule_entry, list);\r\nrcu_read_unlock();\r\n(*pos)++;\r\nreturn (&entry->list == ima_rules) ? NULL : entry;\r\n}\r\nvoid ima_policy_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nstatic void policy_func_show(struct seq_file *m, enum ima_hooks func)\r\n{\r\nif (func > 0 && func < MAX_CHECK)\r\nseq_printf(m, "func=%s ", func_tokens[func]);\r\nelse\r\nseq_printf(m, "func=%d ", func);\r\n}\r\nint ima_policy_show(struct seq_file *m, void *v)\r\n{\r\nstruct ima_rule_entry *entry = v;\r\nint i;\r\nchar tbuf[64] = {0,};\r\nrcu_read_lock();\r\nif (entry->action & MEASURE)\r\nseq_puts(m, pt(Opt_measure));\r\nif (entry->action & DONT_MEASURE)\r\nseq_puts(m, pt(Opt_dont_measure));\r\nif (entry->action & APPRAISE)\r\nseq_puts(m, pt(Opt_appraise));\r\nif (entry->action & DONT_APPRAISE)\r\nseq_puts(m, pt(Opt_dont_appraise));\r\nif (entry->action & AUDIT)\r\nseq_puts(m, pt(Opt_audit));\r\nseq_puts(m, " ");\r\nif (entry->flags & IMA_FUNC)\r\npolicy_func_show(m, entry->func);\r\nif (entry->flags & IMA_MASK) {\r\nif (entry->mask & MAY_EXEC)\r\nseq_printf(m, pt(Opt_mask), mt(mask_exec));\r\nif (entry->mask & MAY_WRITE)\r\nseq_printf(m, pt(Opt_mask), mt(mask_write));\r\nif (entry->mask & MAY_READ)\r\nseq_printf(m, pt(Opt_mask), mt(mask_read));\r\nif (entry->mask & MAY_APPEND)\r\nseq_printf(m, pt(Opt_mask), mt(mask_append));\r\nseq_puts(m, " ");\r\n}\r\nif (entry->flags & IMA_FSMAGIC) {\r\nsnprintf(tbuf, sizeof(tbuf), "0x%lx", entry->fsmagic);\r\nseq_printf(m, pt(Opt_fsmagic), tbuf);\r\nseq_puts(m, " ");\r\n}\r\nif (entry->flags & IMA_PCR) {\r\nsnprintf(tbuf, sizeof(tbuf), "%d", entry->pcr);\r\nseq_printf(m, pt(Opt_pcr), tbuf);\r\nseq_puts(m, " ");\r\n}\r\nif (entry->flags & IMA_FSUUID) {\r\nseq_printf(m, "fsuuid=%pU", &entry->fsuuid);\r\nseq_puts(m, " ");\r\n}\r\nif (entry->flags & IMA_UID) {\r\nsnprintf(tbuf, sizeof(tbuf), "%d", __kuid_val(entry->uid));\r\nif (entry->uid_op == &uid_gt)\r\nseq_printf(m, pt(Opt_uid_gt), tbuf);\r\nelse if (entry->uid_op == &uid_lt)\r\nseq_printf(m, pt(Opt_uid_lt), tbuf);\r\nelse\r\nseq_printf(m, pt(Opt_uid_eq), tbuf);\r\nseq_puts(m, " ");\r\n}\r\nif (entry->flags & IMA_EUID) {\r\nsnprintf(tbuf, sizeof(tbuf), "%d", __kuid_val(entry->uid));\r\nif (entry->uid_op == &uid_gt)\r\nseq_printf(m, pt(Opt_euid_gt), tbuf);\r\nelse if (entry->uid_op == &uid_lt)\r\nseq_printf(m, pt(Opt_euid_lt), tbuf);\r\nelse\r\nseq_printf(m, pt(Opt_euid_eq), tbuf);\r\nseq_puts(m, " ");\r\n}\r\nif (entry->flags & IMA_FOWNER) {\r\nsnprintf(tbuf, sizeof(tbuf), "%d", __kuid_val(entry->fowner));\r\nif (entry->fowner_op == &uid_gt)\r\nseq_printf(m, pt(Opt_fowner_gt), tbuf);\r\nelse if (entry->fowner_op == &uid_lt)\r\nseq_printf(m, pt(Opt_fowner_lt), tbuf);\r\nelse\r\nseq_printf(m, pt(Opt_fowner_eq), tbuf);\r\nseq_puts(m, " ");\r\n}\r\nfor (i = 0; i < MAX_LSM_RULES; i++) {\r\nif (entry->lsm[i].rule) {\r\nswitch (i) {\r\ncase LSM_OBJ_USER:\r\nseq_printf(m, pt(Opt_obj_user),\r\n(char *)entry->lsm[i].args_p);\r\nbreak;\r\ncase LSM_OBJ_ROLE:\r\nseq_printf(m, pt(Opt_obj_role),\r\n(char *)entry->lsm[i].args_p);\r\nbreak;\r\ncase LSM_OBJ_TYPE:\r\nseq_printf(m, pt(Opt_obj_type),\r\n(char *)entry->lsm[i].args_p);\r\nbreak;\r\ncase LSM_SUBJ_USER:\r\nseq_printf(m, pt(Opt_subj_user),\r\n(char *)entry->lsm[i].args_p);\r\nbreak;\r\ncase LSM_SUBJ_ROLE:\r\nseq_printf(m, pt(Opt_subj_role),\r\n(char *)entry->lsm[i].args_p);\r\nbreak;\r\ncase LSM_SUBJ_TYPE:\r\nseq_printf(m, pt(Opt_subj_type),\r\n(char *)entry->lsm[i].args_p);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (entry->flags & IMA_DIGSIG_REQUIRED)\r\nseq_puts(m, "appraise_type=imasig ");\r\nif (entry->flags & IMA_PERMIT_DIRECTIO)\r\nseq_puts(m, "permit_directio ");\r\nrcu_read_unlock();\r\nseq_puts(m, "\n");\r\nreturn 0;\r\n}
