static inline struct imx_hdmi *enc_to_imx_hdmi(struct drm_encoder *e)\r\n{\r\nreturn container_of(e, struct imx_hdmi, encoder);\r\n}\r\nstatic int dw_hdmi_imx_parse_dt(struct imx_hdmi *hdmi)\r\n{\r\nstruct device_node *np = hdmi->dev->of_node;\r\nhdmi->regmap = syscon_regmap_lookup_by_phandle(np, "gpr");\r\nif (IS_ERR(hdmi->regmap)) {\r\ndev_err(hdmi->dev, "Unable to get gpr\n");\r\nreturn PTR_ERR(hdmi->regmap);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dw_hdmi_imx_encoder_disable(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void dw_hdmi_imx_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct imx_hdmi *hdmi = enc_to_imx_hdmi(encoder);\r\nint mux = drm_of_encoder_active_port_id(hdmi->dev->of_node, encoder);\r\nregmap_update_bits(hdmi->regmap, IOMUXC_GPR3,\r\nIMX6Q_GPR3_HDMI_MUX_CTL_MASK,\r\nmux << IMX6Q_GPR3_HDMI_MUX_CTL_SHIFT);\r\n}\r\nstatic int dw_hdmi_imx_atomic_check(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nstruct imx_crtc_state *imx_crtc_state = to_imx_crtc_state(crtc_state);\r\nimx_crtc_state->bus_format = MEDIA_BUS_FMT_RGB888_1X24;\r\nimx_crtc_state->di_hsync_pin = 2;\r\nimx_crtc_state->di_vsync_pin = 3;\r\nreturn 0;\r\n}\r\nstatic enum drm_mode_status\r\nimx6q_hdmi_mode_valid(struct drm_connector *con,\r\nconst struct drm_display_mode *mode)\r\n{\r\nif (mode->clock < 13500)\r\nreturn MODE_CLOCK_LOW;\r\nif (mode->clock > 216000)\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic enum drm_mode_status\r\nimx6dl_hdmi_mode_valid(struct drm_connector *con,\r\nconst struct drm_display_mode *mode)\r\n{\r\nif (mode->clock < 13500)\r\nreturn MODE_CLOCK_LOW;\r\nif (mode->clock > 216000)\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic int dw_hdmi_imx_bind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nconst struct dw_hdmi_plat_data *plat_data;\r\nconst struct of_device_id *match;\r\nstruct drm_device *drm = data;\r\nstruct drm_encoder *encoder;\r\nstruct imx_hdmi *hdmi;\r\nint ret;\r\nif (!pdev->dev.of_node)\r\nreturn -ENODEV;\r\nhdmi = devm_kzalloc(&pdev->dev, sizeof(*hdmi), GFP_KERNEL);\r\nif (!hdmi)\r\nreturn -ENOMEM;\r\nmatch = of_match_node(dw_hdmi_imx_dt_ids, pdev->dev.of_node);\r\nplat_data = match->data;\r\nhdmi->dev = &pdev->dev;\r\nencoder = &hdmi->encoder;\r\nencoder->possible_crtcs = drm_of_find_possible_crtcs(drm, dev->of_node);\r\nif (encoder->possible_crtcs == 0)\r\nreturn -EPROBE_DEFER;\r\nret = dw_hdmi_imx_parse_dt(hdmi);\r\nif (ret < 0)\r\nreturn ret;\r\ndrm_encoder_helper_add(encoder, &dw_hdmi_imx_encoder_helper_funcs);\r\ndrm_encoder_init(drm, encoder, &dw_hdmi_imx_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS, NULL);\r\nret = dw_hdmi_bind(pdev, encoder, plat_data);\r\nif (ret)\r\ndrm_encoder_cleanup(encoder);\r\nreturn ret;\r\n}\r\nstatic void dw_hdmi_imx_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nreturn dw_hdmi_unbind(dev);\r\n}\r\nstatic int dw_hdmi_imx_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &dw_hdmi_imx_ops);\r\n}\r\nstatic int dw_hdmi_imx_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &dw_hdmi_imx_ops);\r\nreturn 0;\r\n}
