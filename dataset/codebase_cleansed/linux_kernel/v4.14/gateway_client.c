static void batadv_gw_node_release(struct kref *ref)\r\n{\r\nstruct batadv_gw_node *gw_node;\r\ngw_node = container_of(ref, struct batadv_gw_node, refcount);\r\nbatadv_orig_node_put(gw_node->orig_node);\r\nkfree_rcu(gw_node, rcu);\r\n}\r\nvoid batadv_gw_node_put(struct batadv_gw_node *gw_node)\r\n{\r\nkref_put(&gw_node->refcount, batadv_gw_node_release);\r\n}\r\nstruct batadv_gw_node *\r\nbatadv_gw_get_selected_gw_node(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_gw_node *gw_node;\r\nrcu_read_lock();\r\ngw_node = rcu_dereference(bat_priv->gw.curr_gw);\r\nif (!gw_node)\r\ngoto out;\r\nif (!kref_get_unless_zero(&gw_node->refcount))\r\ngw_node = NULL;\r\nout:\r\nrcu_read_unlock();\r\nreturn gw_node;\r\n}\r\nstruct batadv_orig_node *\r\nbatadv_gw_get_selected_orig(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_gw_node *gw_node;\r\nstruct batadv_orig_node *orig_node = NULL;\r\ngw_node = batadv_gw_get_selected_gw_node(bat_priv);\r\nif (!gw_node)\r\ngoto out;\r\nrcu_read_lock();\r\norig_node = gw_node->orig_node;\r\nif (!orig_node)\r\ngoto unlock;\r\nif (!kref_get_unless_zero(&orig_node->refcount))\r\norig_node = NULL;\r\nunlock:\r\nrcu_read_unlock();\r\nout:\r\nif (gw_node)\r\nbatadv_gw_node_put(gw_node);\r\nreturn orig_node;\r\n}\r\nstatic void batadv_gw_select(struct batadv_priv *bat_priv,\r\nstruct batadv_gw_node *new_gw_node)\r\n{\r\nstruct batadv_gw_node *curr_gw_node;\r\nspin_lock_bh(&bat_priv->gw.list_lock);\r\nif (new_gw_node)\r\nkref_get(&new_gw_node->refcount);\r\ncurr_gw_node = rcu_dereference_protected(bat_priv->gw.curr_gw, 1);\r\nrcu_assign_pointer(bat_priv->gw.curr_gw, new_gw_node);\r\nif (curr_gw_node)\r\nbatadv_gw_node_put(curr_gw_node);\r\nspin_unlock_bh(&bat_priv->gw.list_lock);\r\n}\r\nvoid batadv_gw_reselect(struct batadv_priv *bat_priv)\r\n{\r\natomic_set(&bat_priv->gw.reselect, 1);\r\n}\r\nvoid batadv_gw_check_client_stop(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_gw_node *curr_gw;\r\nif (atomic_read(&bat_priv->gw.mode) != BATADV_GW_MODE_CLIENT)\r\nreturn;\r\ncurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\r\nif (!curr_gw)\r\nreturn;\r\nbatadv_gw_select(bat_priv, NULL);\r\nbatadv_throw_uevent(bat_priv, BATADV_UEV_GW, BATADV_UEV_DEL, NULL);\r\nbatadv_gw_node_put(curr_gw);\r\n}\r\nvoid batadv_gw_election(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_gw_node *curr_gw = NULL;\r\nstruct batadv_gw_node *next_gw = NULL;\r\nstruct batadv_neigh_node *router = NULL;\r\nstruct batadv_neigh_ifinfo *router_ifinfo = NULL;\r\nchar gw_addr[18] = { '\0' };\r\nif (atomic_read(&bat_priv->gw.mode) != BATADV_GW_MODE_CLIENT)\r\ngoto out;\r\nif (!bat_priv->algo_ops->gw.get_best_gw_node)\r\ngoto out;\r\ncurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\r\nif (!batadv_atomic_dec_not_zero(&bat_priv->gw.reselect) && curr_gw)\r\ngoto out;\r\nnext_gw = bat_priv->algo_ops->gw.get_best_gw_node(bat_priv);\r\nif (curr_gw == next_gw)\r\ngoto out;\r\nif (next_gw) {\r\nsprintf(gw_addr, "%pM", next_gw->orig_node->orig);\r\nrouter = batadv_orig_router_get(next_gw->orig_node,\r\nBATADV_IF_DEFAULT);\r\nif (!router) {\r\nbatadv_gw_reselect(bat_priv);\r\ngoto out;\r\n}\r\nrouter_ifinfo = batadv_neigh_ifinfo_get(router,\r\nBATADV_IF_DEFAULT);\r\nif (!router_ifinfo) {\r\nbatadv_gw_reselect(bat_priv);\r\ngoto out;\r\n}\r\n}\r\nif ((curr_gw) && (!next_gw)) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Removing selected gateway - no gateway in range\n");\r\nbatadv_throw_uevent(bat_priv, BATADV_UEV_GW, BATADV_UEV_DEL,\r\nNULL);\r\n} else if ((!curr_gw) && (next_gw)) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Adding route to gateway %pM (bandwidth: %u.%u/%u.%u MBit, tq: %i)\n",\r\nnext_gw->orig_node->orig,\r\nnext_gw->bandwidth_down / 10,\r\nnext_gw->bandwidth_down % 10,\r\nnext_gw->bandwidth_up / 10,\r\nnext_gw->bandwidth_up % 10,\r\nrouter_ifinfo->bat_iv.tq_avg);\r\nbatadv_throw_uevent(bat_priv, BATADV_UEV_GW, BATADV_UEV_ADD,\r\ngw_addr);\r\n} else {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Changing route to gateway %pM (bandwidth: %u.%u/%u.%u MBit, tq: %i)\n",\r\nnext_gw->orig_node->orig,\r\nnext_gw->bandwidth_down / 10,\r\nnext_gw->bandwidth_down % 10,\r\nnext_gw->bandwidth_up / 10,\r\nnext_gw->bandwidth_up % 10,\r\nrouter_ifinfo->bat_iv.tq_avg);\r\nbatadv_throw_uevent(bat_priv, BATADV_UEV_GW, BATADV_UEV_CHANGE,\r\ngw_addr);\r\n}\r\nbatadv_gw_select(bat_priv, next_gw);\r\nout:\r\nif (curr_gw)\r\nbatadv_gw_node_put(curr_gw);\r\nif (next_gw)\r\nbatadv_gw_node_put(next_gw);\r\nif (router)\r\nbatadv_neigh_node_put(router);\r\nif (router_ifinfo)\r\nbatadv_neigh_ifinfo_put(router_ifinfo);\r\n}\r\nvoid batadv_gw_check_election(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_orig_node *curr_gw_orig;\r\nif (!bat_priv->algo_ops->gw.is_eligible)\r\nreturn;\r\ncurr_gw_orig = batadv_gw_get_selected_orig(bat_priv);\r\nif (!curr_gw_orig)\r\ngoto reselect;\r\nif (curr_gw_orig == orig_node)\r\ngoto out;\r\nif (!bat_priv->algo_ops->gw.is_eligible(bat_priv, curr_gw_orig,\r\norig_node))\r\ngoto out;\r\nreselect:\r\nbatadv_gw_reselect(bat_priv);\r\nout:\r\nif (curr_gw_orig)\r\nbatadv_orig_node_put(curr_gw_orig);\r\n}\r\nstatic void batadv_gw_node_add(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_tvlv_gateway_data *gateway)\r\n{\r\nstruct batadv_gw_node *gw_node;\r\nif (gateway->bandwidth_down == 0)\r\nreturn;\r\ngw_node = kzalloc(sizeof(*gw_node), GFP_ATOMIC);\r\nif (!gw_node)\r\nreturn;\r\nkref_init(&gw_node->refcount);\r\nINIT_HLIST_NODE(&gw_node->list);\r\nkref_get(&orig_node->refcount);\r\ngw_node->orig_node = orig_node;\r\ngw_node->bandwidth_down = ntohl(gateway->bandwidth_down);\r\ngw_node->bandwidth_up = ntohl(gateway->bandwidth_up);\r\nspin_lock_bh(&bat_priv->gw.list_lock);\r\nkref_get(&gw_node->refcount);\r\nhlist_add_head_rcu(&gw_node->list, &bat_priv->gw.gateway_list);\r\nspin_unlock_bh(&bat_priv->gw.list_lock);\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Found new gateway %pM -> gw bandwidth: %u.%u/%u.%u MBit\n",\r\norig_node->orig,\r\nntohl(gateway->bandwidth_down) / 10,\r\nntohl(gateway->bandwidth_down) % 10,\r\nntohl(gateway->bandwidth_up) / 10,\r\nntohl(gateway->bandwidth_up) % 10);\r\nbatadv_gw_node_put(gw_node);\r\n}\r\nstruct batadv_gw_node *batadv_gw_node_get(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_gw_node *gw_node_tmp, *gw_node = NULL;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(gw_node_tmp, &bat_priv->gw.gateway_list,\r\nlist) {\r\nif (gw_node_tmp->orig_node != orig_node)\r\ncontinue;\r\nif (!kref_get_unless_zero(&gw_node_tmp->refcount))\r\ncontinue;\r\ngw_node = gw_node_tmp;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn gw_node;\r\n}\r\nvoid batadv_gw_node_update(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_tvlv_gateway_data *gateway)\r\n{\r\nstruct batadv_gw_node *gw_node, *curr_gw = NULL;\r\ngw_node = batadv_gw_node_get(bat_priv, orig_node);\r\nif (!gw_node) {\r\nbatadv_gw_node_add(bat_priv, orig_node, gateway);\r\ngoto out;\r\n}\r\nif ((gw_node->bandwidth_down == ntohl(gateway->bandwidth_down)) &&\r\n(gw_node->bandwidth_up == ntohl(gateway->bandwidth_up)))\r\ngoto out;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Gateway bandwidth of originator %pM changed from %u.%u/%u.%u MBit to %u.%u/%u.%u MBit\n",\r\norig_node->orig,\r\ngw_node->bandwidth_down / 10,\r\ngw_node->bandwidth_down % 10,\r\ngw_node->bandwidth_up / 10,\r\ngw_node->bandwidth_up % 10,\r\nntohl(gateway->bandwidth_down) / 10,\r\nntohl(gateway->bandwidth_down) % 10,\r\nntohl(gateway->bandwidth_up) / 10,\r\nntohl(gateway->bandwidth_up) % 10);\r\ngw_node->bandwidth_down = ntohl(gateway->bandwidth_down);\r\ngw_node->bandwidth_up = ntohl(gateway->bandwidth_up);\r\nif (ntohl(gateway->bandwidth_down) == 0) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Gateway %pM removed from gateway list\n",\r\norig_node->orig);\r\nspin_lock_bh(&bat_priv->gw.list_lock);\r\nif (!hlist_unhashed(&gw_node->list)) {\r\nhlist_del_init_rcu(&gw_node->list);\r\nbatadv_gw_node_put(gw_node);\r\n}\r\nspin_unlock_bh(&bat_priv->gw.list_lock);\r\ncurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\r\nif (gw_node == curr_gw)\r\nbatadv_gw_reselect(bat_priv);\r\nif (curr_gw)\r\nbatadv_gw_node_put(curr_gw);\r\n}\r\nout:\r\nif (gw_node)\r\nbatadv_gw_node_put(gw_node);\r\n}\r\nvoid batadv_gw_node_delete(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_tvlv_gateway_data gateway;\r\ngateway.bandwidth_down = 0;\r\ngateway.bandwidth_up = 0;\r\nbatadv_gw_node_update(bat_priv, orig_node, &gateway);\r\n}\r\nvoid batadv_gw_node_free(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_gw_node *gw_node;\r\nstruct hlist_node *node_tmp;\r\nspin_lock_bh(&bat_priv->gw.list_lock);\r\nhlist_for_each_entry_safe(gw_node, node_tmp,\r\n&bat_priv->gw.gateway_list, list) {\r\nhlist_del_init_rcu(&gw_node->list);\r\nbatadv_gw_node_put(gw_node);\r\n}\r\nspin_unlock_bh(&bat_priv->gw.list_lock);\r\n}\r\nint batadv_gw_client_seq_print_text(struct seq_file *seq, void *offset)\r\n{\r\nstruct net_device *net_dev = (struct net_device *)seq->private;\r\nstruct batadv_priv *bat_priv = netdev_priv(net_dev);\r\nstruct batadv_hard_iface *primary_if;\r\nprimary_if = batadv_seq_print_text_primary_if_get(seq);\r\nif (!primary_if)\r\nreturn 0;\r\nseq_printf(seq, "[B.A.T.M.A.N. adv %s, MainIF/MAC: %s/%pM (%s %s)]\n",\r\nBATADV_SOURCE_VERSION, primary_if->net_dev->name,\r\nprimary_if->net_dev->dev_addr, net_dev->name,\r\nbat_priv->algo_ops->name);\r\nbatadv_hardif_put(primary_if);\r\nif (!bat_priv->algo_ops->gw.print) {\r\nseq_puts(seq,\r\n"No printing function for this routing protocol\n");\r\nreturn 0;\r\n}\r\nbat_priv->algo_ops->gw.print(bat_priv, seq);\r\nreturn 0;\r\n}\r\nint batadv_gw_dump(struct sk_buff *msg, struct netlink_callback *cb)\r\n{\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nstruct net *net = sock_net(cb->skb->sk);\r\nstruct net_device *soft_iface;\r\nstruct batadv_priv *bat_priv;\r\nint ifindex;\r\nint ret;\r\nifindex = batadv_netlink_get_ifindex(cb->nlh,\r\nBATADV_ATTR_MESH_IFINDEX);\r\nif (!ifindex)\r\nreturn -EINVAL;\r\nsoft_iface = dev_get_by_index(net, ifindex);\r\nif (!soft_iface || !batadv_softif_is_valid(soft_iface)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nbat_priv = netdev_priv(soft_iface);\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nif (!bat_priv->algo_ops->gw.dump) {\r\nret = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nbat_priv->algo_ops->gw.dump(msg, cb, bat_priv);\r\nret = msg->len;\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\nif (soft_iface)\r\ndev_put(soft_iface);\r\nreturn ret;\r\n}\r\nenum batadv_dhcp_recipient\r\nbatadv_gw_dhcp_recipient_get(struct sk_buff *skb, unsigned int *header_len,\r\nu8 *chaddr)\r\n{\r\nenum batadv_dhcp_recipient ret = BATADV_DHCP_NO;\r\nstruct ethhdr *ethhdr;\r\nstruct iphdr *iphdr;\r\nstruct ipv6hdr *ipv6hdr;\r\nstruct udphdr *udphdr;\r\nstruct vlan_ethhdr *vhdr;\r\nint chaddr_offset;\r\n__be16 proto;\r\nu8 *p;\r\nif (!pskb_may_pull(skb, *header_len + ETH_HLEN))\r\nreturn BATADV_DHCP_NO;\r\nethhdr = eth_hdr(skb);\r\nproto = ethhdr->h_proto;\r\n*header_len += ETH_HLEN;\r\nif (proto == htons(ETH_P_8021Q)) {\r\nif (!pskb_may_pull(skb, *header_len + VLAN_HLEN))\r\nreturn BATADV_DHCP_NO;\r\nvhdr = vlan_eth_hdr(skb);\r\nproto = vhdr->h_vlan_encapsulated_proto;\r\n*header_len += VLAN_HLEN;\r\n}\r\nswitch (proto) {\r\ncase htons(ETH_P_IP):\r\nif (!pskb_may_pull(skb, *header_len + sizeof(*iphdr)))\r\nreturn BATADV_DHCP_NO;\r\niphdr = (struct iphdr *)(skb->data + *header_len);\r\n*header_len += iphdr->ihl * 4;\r\nif (iphdr->protocol != IPPROTO_UDP)\r\nreturn BATADV_DHCP_NO;\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nif (!pskb_may_pull(skb, *header_len + sizeof(*ipv6hdr)))\r\nreturn BATADV_DHCP_NO;\r\nipv6hdr = (struct ipv6hdr *)(skb->data + *header_len);\r\n*header_len += sizeof(*ipv6hdr);\r\nif (ipv6hdr->nexthdr != IPPROTO_UDP)\r\nreturn BATADV_DHCP_NO;\r\nbreak;\r\ndefault:\r\nreturn BATADV_DHCP_NO;\r\n}\r\nif (!pskb_may_pull(skb, *header_len + sizeof(*udphdr)))\r\nreturn BATADV_DHCP_NO;\r\nudphdr = (struct udphdr *)(skb->data + *header_len);\r\n*header_len += sizeof(*udphdr);\r\nswitch (proto) {\r\ncase htons(ETH_P_IP):\r\nif (udphdr->dest == htons(67))\r\nret = BATADV_DHCP_TO_SERVER;\r\nelse if (udphdr->source == htons(67))\r\nret = BATADV_DHCP_TO_CLIENT;\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nif (udphdr->dest == htons(547))\r\nret = BATADV_DHCP_TO_SERVER;\r\nelse if (udphdr->source == htons(547))\r\nret = BATADV_DHCP_TO_CLIENT;\r\nbreak;\r\n}\r\nchaddr_offset = *header_len + BATADV_DHCP_CHADDR_OFFSET;\r\nif (ret == BATADV_DHCP_TO_CLIENT &&\r\npskb_may_pull(skb, chaddr_offset + ETH_ALEN)) {\r\np = skb->data + *header_len + BATADV_DHCP_HTYPE_OFFSET;\r\nif (*p != BATADV_DHCP_HTYPE_ETHERNET)\r\nreturn BATADV_DHCP_NO;\r\np = skb->data + *header_len + BATADV_DHCP_HLEN_OFFSET;\r\nif (*p != ETH_ALEN)\r\nreturn BATADV_DHCP_NO;\r\nether_addr_copy(chaddr, skb->data + chaddr_offset);\r\n}\r\nreturn ret;\r\n}\r\nbool batadv_gw_out_of_range(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct batadv_neigh_node *neigh_curr = NULL;\r\nstruct batadv_neigh_node *neigh_old = NULL;\r\nstruct batadv_orig_node *orig_dst_node;\r\nstruct batadv_gw_node *gw_node = NULL;\r\nstruct batadv_gw_node *curr_gw = NULL;\r\nstruct batadv_neigh_ifinfo *curr_ifinfo, *old_ifinfo;\r\nstruct ethhdr *ethhdr = (struct ethhdr *)skb->data;\r\nbool out_of_range = false;\r\nu8 curr_tq_avg;\r\nunsigned short vid;\r\nvid = batadv_get_vid(skb, 0);\r\norig_dst_node = batadv_transtable_search(bat_priv, ethhdr->h_source,\r\nethhdr->h_dest, vid);\r\nif (!orig_dst_node)\r\ngoto out;\r\ngw_node = batadv_gw_node_get(bat_priv, orig_dst_node);\r\nif (!gw_node)\r\ngoto out;\r\nswitch (atomic_read(&bat_priv->gw.mode)) {\r\ncase BATADV_GW_MODE_SERVER:\r\ncurr_tq_avg = BATADV_TQ_MAX_VALUE;\r\nbreak;\r\ncase BATADV_GW_MODE_CLIENT:\r\ncurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\r\nif (!curr_gw)\r\ngoto out;\r\nif (curr_gw->orig_node == orig_dst_node)\r\ngoto out;\r\nneigh_curr = batadv_find_router(bat_priv, curr_gw->orig_node,\r\nNULL);\r\nif (!neigh_curr)\r\ngoto out;\r\ncurr_ifinfo = batadv_neigh_ifinfo_get(neigh_curr,\r\nBATADV_IF_DEFAULT);\r\nif (!curr_ifinfo)\r\ngoto out;\r\ncurr_tq_avg = curr_ifinfo->bat_iv.tq_avg;\r\nbatadv_neigh_ifinfo_put(curr_ifinfo);\r\nbreak;\r\ncase BATADV_GW_MODE_OFF:\r\ndefault:\r\ngoto out;\r\n}\r\nneigh_old = batadv_find_router(bat_priv, orig_dst_node, NULL);\r\nif (!neigh_old)\r\ngoto out;\r\nold_ifinfo = batadv_neigh_ifinfo_get(neigh_old, BATADV_IF_DEFAULT);\r\nif (!old_ifinfo)\r\ngoto out;\r\nif ((curr_tq_avg - old_ifinfo->bat_iv.tq_avg) > BATADV_GW_THRESHOLD)\r\nout_of_range = true;\r\nbatadv_neigh_ifinfo_put(old_ifinfo);\r\nout:\r\nif (orig_dst_node)\r\nbatadv_orig_node_put(orig_dst_node);\r\nif (curr_gw)\r\nbatadv_gw_node_put(curr_gw);\r\nif (gw_node)\r\nbatadv_gw_node_put(gw_node);\r\nif (neigh_old)\r\nbatadv_neigh_node_put(neigh_old);\r\nif (neigh_curr)\r\nbatadv_neigh_node_put(neigh_curr);\r\nreturn out_of_range;\r\n}
