static void efibc_str_to_str16(const char *str, efi_char16_t *str16)\r\n{\r\nsize_t i;\r\nfor (i = 0; i < strlen(str); i++)\r\nstr16[i] = str[i];\r\nstr16[i] = '\0';\r\n}\r\nstatic int efibc_set_variable(const char *name, const char *value)\r\n{\r\nint ret;\r\nefi_guid_t guid = LINUX_EFI_LOADER_ENTRY_GUID;\r\nstruct efivar_entry *entry;\r\nsize_t size = (strlen(value) + 1) * sizeof(efi_char16_t);\r\nif (size > sizeof(entry->var.Data)) {\r\npr_err("value is too large (%zu bytes) for '%s' EFI variable\n", size, name);\r\nreturn -EINVAL;\r\n}\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry) {\r\npr_err("failed to allocate efivar entry for '%s' EFI variable\n", name);\r\nreturn -ENOMEM;\r\n}\r\nefibc_str_to_str16(name, entry->var.VariableName);\r\nefibc_str_to_str16(value, (efi_char16_t *)entry->var.Data);\r\nmemcpy(&entry->var.VendorGuid, &guid, sizeof(guid));\r\nret = efivar_entry_set(entry,\r\nEFI_VARIABLE_NON_VOLATILE\r\n| EFI_VARIABLE_BOOTSERVICE_ACCESS\r\n| EFI_VARIABLE_RUNTIME_ACCESS,\r\nsize, entry->var.Data, NULL);\r\nif (ret)\r\npr_err("failed to set %s EFI variable: 0x%x\n",\r\nname, ret);\r\nkfree(entry);\r\nreturn ret;\r\n}\r\nstatic int efibc_reboot_notifier_call(struct notifier_block *notifier,\r\nunsigned long event, void *data)\r\n{\r\nconst char *reason = "shutdown";\r\nint ret;\r\nif (event == SYS_RESTART)\r\nreason = "reboot";\r\nret = efibc_set_variable("LoaderEntryRebootReason", reason);\r\nif (ret || !data)\r\nreturn NOTIFY_DONE;\r\nefibc_set_variable("LoaderEntryOneShot", (char *)data);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init efibc_init(void)\r\n{\r\nint ret;\r\nif (!efi_enabled(EFI_RUNTIME_SERVICES))\r\nreturn -ENODEV;\r\nret = register_reboot_notifier(&efibc_reboot_notifier);\r\nif (ret)\r\npr_err("unable to register reboot notifier\n");\r\nreturn ret;\r\n}\r\nstatic void __exit efibc_exit(void)\r\n{\r\nunregister_reboot_notifier(&efibc_reboot_notifier);\r\n}
