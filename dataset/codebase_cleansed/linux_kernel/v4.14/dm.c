static void rtl92d_dm_false_alarm_counter_statistics(struct ieee80211_hw *hw)\r\n{\r\nu32 ret_value;\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct false_alarm_statistics *falsealm_cnt = &(rtlpriv->falsealm_cnt);\r\nunsigned long flag = 0;\r\nrtl_set_bbreg(hw, ROFDM0_LSTF, BIT(31), 1);\r\nrtl_set_bbreg(hw, ROFDM1_LSTF, BIT(31), 1);\r\nret_value = rtl_get_bbreg(hw, ROFDM0_FRAMESYNC, MASKDWORD);\r\nfalsealm_cnt->cnt_fast_fsync_fail = (ret_value & 0xffff);\r\nfalsealm_cnt->cnt_sb_search_fail = ((ret_value & 0xffff0000) >> 16);\r\nret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER1, MASKDWORD);\r\nfalsealm_cnt->cnt_parity_fail = ((ret_value & 0xffff0000) >> 16);\r\nret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER2, MASKDWORD);\r\nfalsealm_cnt->cnt_rate_illegal = (ret_value & 0xffff);\r\nfalsealm_cnt->cnt_crc8_fail = ((ret_value & 0xffff0000) >> 16);\r\nret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER3, MASKDWORD);\r\nfalsealm_cnt->cnt_mcs_fail = (ret_value & 0xffff);\r\nfalsealm_cnt->cnt_ofdm_fail = falsealm_cnt->cnt_parity_fail +\r\nfalsealm_cnt->cnt_rate_illegal +\r\nfalsealm_cnt->cnt_crc8_fail +\r\nfalsealm_cnt->cnt_mcs_fail +\r\nfalsealm_cnt->cnt_fast_fsync_fail +\r\nfalsealm_cnt->cnt_sb_search_fail;\r\nif (rtlpriv->rtlhal.current_bandtype != BAND_ON_5G) {\r\nrtl92d_acquire_cckandrw_pagea_ctl(hw, &flag);\r\nret_value = rtl_get_bbreg(hw, RCCK0_FACOUNTERLOWER, MASKBYTE0);\r\nfalsealm_cnt->cnt_cck_fail = ret_value;\r\nret_value = rtl_get_bbreg(hw, RCCK0_FACOUNTERUPPER, MASKBYTE3);\r\nfalsealm_cnt->cnt_cck_fail += (ret_value & 0xff) << 8;\r\nrtl92d_release_cckandrw_pagea_ctl(hw, &flag);\r\n} else {\r\nfalsealm_cnt->cnt_cck_fail = 0;\r\n}\r\nfalsealm_cnt->cnt_all = falsealm_cnt->cnt_fast_fsync_fail +\r\nfalsealm_cnt->cnt_sb_search_fail +\r\nfalsealm_cnt->cnt_parity_fail +\r\nfalsealm_cnt->cnt_rate_illegal +\r\nfalsealm_cnt->cnt_crc8_fail +\r\nfalsealm_cnt->cnt_mcs_fail +\r\nfalsealm_cnt->cnt_cck_fail;\r\nrtl_set_bbreg(hw, ROFDM1_LSTF, 0x08000000, 1);\r\nrtl_set_bbreg(hw, ROFDM1_LSTF, 0x08000000, 0);\r\nrtl_set_bbreg(hw, ROFDM0_LSTF, BIT(31), 0);\r\nrtl_set_bbreg(hw, ROFDM1_LSTF, BIT(31), 0);\r\nif (rtlpriv->rtlhal.current_bandtype != BAND_ON_5G) {\r\nrtl92d_acquire_cckandrw_pagea_ctl(hw, &flag);\r\nrtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, 0x0000c000, 0);\r\nrtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, 0x0000c000, 2);\r\nrtl92d_release_cckandrw_pagea_ctl(hw, &flag);\r\n}\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD,\r\n"Cnt_Fast_Fsync_fail = %x, Cnt_SB_Search_fail = %x\n",\r\nfalsealm_cnt->cnt_fast_fsync_fail,\r\nfalsealm_cnt->cnt_sb_search_fail);\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD,\r\n"Cnt_Parity_Fail = %x, Cnt_Rate_Illegal = %x, Cnt_Crc8_fail = %x, Cnt_Mcs_fail = %x\n",\r\nfalsealm_cnt->cnt_parity_fail,\r\nfalsealm_cnt->cnt_rate_illegal,\r\nfalsealm_cnt->cnt_crc8_fail,\r\nfalsealm_cnt->cnt_mcs_fail);\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD,\r\n"Cnt_Ofdm_fail = %x, Cnt_Cck_fail = %x, Cnt_all = %x\n",\r\nfalsealm_cnt->cnt_ofdm_fail,\r\nfalsealm_cnt->cnt_cck_fail,\r\nfalsealm_cnt->cnt_all);\r\n}\r\nstatic void rtl92d_dm_find_minimum_rssi(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct dig_t *de_digtable = &rtlpriv->dm_digtable;\r\nstruct rtl_mac *mac = rtl_mac(rtlpriv);\r\nif ((mac->link_state < MAC80211_LINKED) &&\r\n(rtlpriv->dm.UNDEC_SM_PWDB == 0)) {\r\nde_digtable->min_undec_pwdb_for_dm = 0;\r\nRT_TRACE(rtlpriv, COMP_BB_POWERSAVING, DBG_LOUD,\r\n"Not connected to any\n");\r\n}\r\nif (mac->link_state >= MAC80211_LINKED) {\r\nif (mac->opmode == NL80211_IFTYPE_AP ||\r\nmac->opmode == NL80211_IFTYPE_ADHOC) {\r\nde_digtable->min_undec_pwdb_for_dm =\r\nrtlpriv->dm.UNDEC_SM_PWDB;\r\nRT_TRACE(rtlpriv, COMP_BB_POWERSAVING, DBG_LOUD,\r\n"AP Client PWDB = 0x%lx\n",\r\nrtlpriv->dm.UNDEC_SM_PWDB);\r\n} else {\r\nde_digtable->min_undec_pwdb_for_dm =\r\nrtlpriv->dm.undec_sm_pwdb;\r\nRT_TRACE(rtlpriv, COMP_BB_POWERSAVING, DBG_LOUD,\r\n"STA Default Port PWDB = 0x%x\n",\r\nde_digtable->min_undec_pwdb_for_dm);\r\n}\r\n} else {\r\nde_digtable->min_undec_pwdb_for_dm = rtlpriv->dm.UNDEC_SM_PWDB;\r\nRT_TRACE(rtlpriv, COMP_BB_POWERSAVING, DBG_LOUD,\r\n"AP Ext Port or disconnect PWDB = 0x%x\n",\r\nde_digtable->min_undec_pwdb_for_dm);\r\n}\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "MinUndecoratedPWDBForDM =%d\n",\r\nde_digtable->min_undec_pwdb_for_dm);\r\n}\r\nstatic void rtl92d_dm_cck_packet_detection_thresh(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct dig_t *de_digtable = &rtlpriv->dm_digtable;\r\nunsigned long flag = 0;\r\nif (de_digtable->cursta_cstate == DIG_STA_CONNECT) {\r\nif (de_digtable->pre_cck_pd_state == CCK_PD_STAGE_LOWRSSI) {\r\nif (de_digtable->min_undec_pwdb_for_dm <= 25)\r\nde_digtable->cur_cck_pd_state =\r\nCCK_PD_STAGE_LOWRSSI;\r\nelse\r\nde_digtable->cur_cck_pd_state =\r\nCCK_PD_STAGE_HIGHRSSI;\r\n} else {\r\nif (de_digtable->min_undec_pwdb_for_dm <= 20)\r\nde_digtable->cur_cck_pd_state =\r\nCCK_PD_STAGE_LOWRSSI;\r\nelse\r\nde_digtable->cur_cck_pd_state =\r\nCCK_PD_STAGE_HIGHRSSI;\r\n}\r\n} else {\r\nde_digtable->cur_cck_pd_state = CCK_PD_STAGE_LOWRSSI;\r\n}\r\nif (de_digtable->pre_cck_pd_state != de_digtable->cur_cck_pd_state) {\r\nif (de_digtable->cur_cck_pd_state == CCK_PD_STAGE_LOWRSSI) {\r\nrtl92d_acquire_cckandrw_pagea_ctl(hw, &flag);\r\nrtl_set_bbreg(hw, RCCK0_CCA, MASKBYTE2, 0x83);\r\nrtl92d_release_cckandrw_pagea_ctl(hw, &flag);\r\n} else {\r\nrtl92d_acquire_cckandrw_pagea_ctl(hw, &flag);\r\nrtl_set_bbreg(hw, RCCK0_CCA, MASKBYTE2, 0xcd);\r\nrtl92d_release_cckandrw_pagea_ctl(hw, &flag);\r\n}\r\nde_digtable->pre_cck_pd_state = de_digtable->cur_cck_pd_state;\r\n}\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "CurSTAConnectState=%s\n",\r\nde_digtable->cursta_cstate == DIG_STA_CONNECT ?\r\n"DIG_STA_CONNECT " : "DIG_STA_DISCONNECT");\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "CCKPDStage=%s\n",\r\nde_digtable->cur_cck_pd_state == CCK_PD_STAGE_LOWRSSI ?\r\n"Low RSSI " : "High RSSI ");\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "is92d single phy =%x\n",\r\nIS_92D_SINGLEPHY(rtlpriv->rtlhal.version));\r\n}\r\nvoid rtl92d_dm_write_dig(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct dig_t *de_digtable = &rtlpriv->dm_digtable;\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD,\r\n"cur_igvalue = 0x%x, pre_igvalue = 0x%x, back_val = %d\n",\r\nde_digtable->cur_igvalue, de_digtable->pre_igvalue,\r\nde_digtable->back_val);\r\nif (de_digtable->dig_enable_flag == false) {\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "DIG is disabled\n");\r\nde_digtable->pre_igvalue = 0x17;\r\nreturn;\r\n}\r\nif (de_digtable->pre_igvalue != de_digtable->cur_igvalue) {\r\nrtl_set_bbreg(hw, ROFDM0_XAAGCCORE1, 0x7f,\r\nde_digtable->cur_igvalue);\r\nrtl_set_bbreg(hw, ROFDM0_XBAGCCORE1, 0x7f,\r\nde_digtable->cur_igvalue);\r\nde_digtable->pre_igvalue = de_digtable->cur_igvalue;\r\n}\r\n}\r\nstatic void rtl92d_early_mode_enabled(struct rtl_priv *rtlpriv)\r\n{\r\nstruct dig_t *de_digtable = &rtlpriv->dm_digtable;\r\nif ((rtlpriv->mac80211.link_state >= MAC80211_LINKED) &&\r\n(rtlpriv->mac80211.vendor == PEER_CISCO)) {\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "IOT_PEER = CISCO\n");\r\nif (de_digtable->last_min_undec_pwdb_for_dm >= 50\r\n&& de_digtable->min_undec_pwdb_for_dm < 50) {\r\nrtl_write_byte(rtlpriv, REG_EARLY_MODE_CONTROL, 0x00);\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD,\r\n"Early Mode Off\n");\r\n} else if (de_digtable->last_min_undec_pwdb_for_dm <= 55 &&\r\nde_digtable->min_undec_pwdb_for_dm > 55) {\r\nrtl_write_byte(rtlpriv, REG_EARLY_MODE_CONTROL, 0x0f);\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD,\r\n"Early Mode On\n");\r\n}\r\n} else if (!(rtl_read_byte(rtlpriv, REG_EARLY_MODE_CONTROL) & 0xf)) {\r\nrtl_write_byte(rtlpriv, REG_EARLY_MODE_CONTROL, 0x0f);\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "Early Mode On\n");\r\n}\r\n}\r\nstatic void rtl92d_dm_dig(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct dig_t *de_digtable = &rtlpriv->dm_digtable;\r\nu8 value_igi = de_digtable->cur_igvalue;\r\nstruct false_alarm_statistics *falsealm_cnt = &(rtlpriv->falsealm_cnt);\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "==>\n");\r\nif (rtlpriv->rtlhal.earlymode_enable) {\r\nrtl92d_early_mode_enabled(rtlpriv);\r\nde_digtable->last_min_undec_pwdb_for_dm =\r\nde_digtable->min_undec_pwdb_for_dm;\r\n}\r\nif (!rtlpriv->dm.dm_initialgain_enable)\r\nreturn;\r\nif (rtlpriv->mac80211.opmode != NL80211_IFTYPE_STATION)\r\nreturn;\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "progress\n");\r\nif (rtlpriv->mac80211.link_state >= MAC80211_LINKED)\r\nde_digtable->cursta_cstate = DIG_STA_CONNECT;\r\nelse\r\nde_digtable->cursta_cstate = DIG_STA_DISCONNECT;\r\nif (falsealm_cnt->cnt_all < DM_DIG_FA_TH0)\r\nvalue_igi--;\r\nelse if (falsealm_cnt->cnt_all < DM_DIG_FA_TH1)\r\nvalue_igi += 0;\r\nelse if (falsealm_cnt->cnt_all < DM_DIG_FA_TH2)\r\nvalue_igi++;\r\nelse if (falsealm_cnt->cnt_all >= DM_DIG_FA_TH2)\r\nvalue_igi += 2;\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD,\r\n"dm_DIG() Before: large_fa_hit=%d, forbidden_igi=%x\n",\r\nde_digtable->large_fa_hit, de_digtable->forbidden_igi);\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD,\r\n"dm_DIG() Before: Recover_cnt=%d, rx_gain_min=%x\n",\r\nde_digtable->recover_cnt, de_digtable->rx_gain_min);\r\nif (falsealm_cnt->cnt_all > 10000) {\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD,\r\n"dm_DIG(): Abnormally false alarm case\n");\r\nde_digtable->large_fa_hit++;\r\nif (de_digtable->forbidden_igi < de_digtable->cur_igvalue) {\r\nde_digtable->forbidden_igi = de_digtable->cur_igvalue;\r\nde_digtable->large_fa_hit = 1;\r\n}\r\nif (de_digtable->large_fa_hit >= 3) {\r\nif ((de_digtable->forbidden_igi + 1) > DM_DIG_MAX)\r\nde_digtable->rx_gain_min = DM_DIG_MAX;\r\nelse\r\nde_digtable->rx_gain_min =\r\n(de_digtable->forbidden_igi + 1);\r\nde_digtable->recover_cnt = 3600;\r\n}\r\n} else {\r\nif (de_digtable->recover_cnt != 0) {\r\nde_digtable->recover_cnt--;\r\n} else {\r\nif (de_digtable->large_fa_hit == 0) {\r\nif ((de_digtable->forbidden_igi - 1) <\r\nDM_DIG_FA_LOWER) {\r\nde_digtable->forbidden_igi =\r\nDM_DIG_FA_LOWER;\r\nde_digtable->rx_gain_min =\r\nDM_DIG_FA_LOWER;\r\n} else {\r\nde_digtable->forbidden_igi--;\r\nde_digtable->rx_gain_min =\r\n(de_digtable->forbidden_igi + 1);\r\n}\r\n} else if (de_digtable->large_fa_hit == 3) {\r\nde_digtable->large_fa_hit = 0;\r\n}\r\n}\r\n}\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD,\r\n"dm_DIG() After: large_fa_hit=%d, forbidden_igi=%x\n",\r\nde_digtable->large_fa_hit, de_digtable->forbidden_igi);\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD,\r\n"dm_DIG() After: recover_cnt=%d, rx_gain_min=%x\n",\r\nde_digtable->recover_cnt, de_digtable->rx_gain_min);\r\nif (value_igi > DM_DIG_MAX)\r\nvalue_igi = DM_DIG_MAX;\r\nelse if (value_igi < de_digtable->rx_gain_min)\r\nvalue_igi = de_digtable->rx_gain_min;\r\nde_digtable->cur_igvalue = value_igi;\r\nrtl92d_dm_write_dig(hw);\r\nif (rtlpriv->rtlhal.current_bandtype != BAND_ON_5G)\r\nrtl92d_dm_cck_packet_detection_thresh(hw);\r\nRT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "<<==\n");\r\n}\r\nstatic void rtl92d_dm_init_dynamic_txpower(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nrtlpriv->dm.dynamic_txpower_enable = true;\r\nrtlpriv->dm.last_dtp_lvl = TXHIGHPWRLEVEL_NORMAL;\r\nrtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\r\n}\r\nstatic void rtl92d_dm_dynamic_txpower(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nlong undec_sm_pwdb;\r\nif ((!rtlpriv->dm.dynamic_txpower_enable)\r\n|| rtlpriv->dm.dm_flag & HAL_DM_HIPWR_DISABLE) {\r\nrtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\r\nreturn;\r\n}\r\nif ((mac->link_state < MAC80211_LINKED) &&\r\n(rtlpriv->dm.UNDEC_SM_PWDB == 0)) {\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_TRACE,\r\n"Not connected to any\n");\r\nrtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\r\nrtlpriv->dm.last_dtp_lvl = TXHIGHPWRLEVEL_NORMAL;\r\nreturn;\r\n}\r\nif (mac->link_state >= MAC80211_LINKED) {\r\nif (mac->opmode == NL80211_IFTYPE_ADHOC) {\r\nundec_sm_pwdb =\r\nrtlpriv->dm.UNDEC_SM_PWDB;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"IBSS Client PWDB = 0x%lx\n",\r\nundec_sm_pwdb);\r\n} else {\r\nundec_sm_pwdb =\r\nrtlpriv->dm.undec_sm_pwdb;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"STA Default Port PWDB = 0x%lx\n",\r\nundec_sm_pwdb);\r\n}\r\n} else {\r\nundec_sm_pwdb =\r\nrtlpriv->dm.UNDEC_SM_PWDB;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"AP Ext Port PWDB = 0x%lx\n",\r\nundec_sm_pwdb);\r\n}\r\nif (rtlhal->current_bandtype == BAND_ON_5G) {\r\nif (undec_sm_pwdb >= 0x33) {\r\nrtlpriv->dm.dynamic_txhighpower_lvl =\r\nTXHIGHPWRLEVEL_LEVEL2;\r\nRT_TRACE(rtlpriv, COMP_HIPWR, DBG_LOUD,\r\n"5G:TxHighPwrLevel_Level2 (TxPwr=0x0)\n");\r\n} else if ((undec_sm_pwdb < 0x33)\r\n&& (undec_sm_pwdb >= 0x2b)) {\r\nrtlpriv->dm.dynamic_txhighpower_lvl =\r\nTXHIGHPWRLEVEL_LEVEL1;\r\nRT_TRACE(rtlpriv, COMP_HIPWR, DBG_LOUD,\r\n"5G:TxHighPwrLevel_Level1 (TxPwr=0x10)\n");\r\n} else if (undec_sm_pwdb < 0x2b) {\r\nrtlpriv->dm.dynamic_txhighpower_lvl =\r\nTXHIGHPWRLEVEL_NORMAL;\r\nRT_TRACE(rtlpriv, COMP_HIPWR, DBG_LOUD,\r\n"5G:TxHighPwrLevel_Normal\n");\r\n}\r\n} else {\r\nif (undec_sm_pwdb >=\r\nTX_POWER_NEAR_FIELD_THRESH_LVL2) {\r\nrtlpriv->dm.dynamic_txhighpower_lvl =\r\nTXHIGHPWRLEVEL_LEVEL2;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"TXHIGHPWRLEVEL_LEVEL1 (TxPwr=0x0)\n");\r\n} else\r\nif ((undec_sm_pwdb <\r\n(TX_POWER_NEAR_FIELD_THRESH_LVL2 - 3))\r\n&& (undec_sm_pwdb >=\r\nTX_POWER_NEAR_FIELD_THRESH_LVL1)) {\r\nrtlpriv->dm.dynamic_txhighpower_lvl =\r\nTXHIGHPWRLEVEL_LEVEL1;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"TXHIGHPWRLEVEL_LEVEL1 (TxPwr=0x10)\n");\r\n} else if (undec_sm_pwdb <\r\n(TX_POWER_NEAR_FIELD_THRESH_LVL1 - 5)) {\r\nrtlpriv->dm.dynamic_txhighpower_lvl =\r\nTXHIGHPWRLEVEL_NORMAL;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"TXHIGHPWRLEVEL_NORMAL\n");\r\n}\r\n}\r\nif ((rtlpriv->dm.dynamic_txhighpower_lvl != rtlpriv->dm.last_dtp_lvl)) {\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"PHY_SetTxPowerLevel8192S() Channel = %d\n",\r\nrtlphy->current_channel);\r\nrtl92d_phy_set_txpower_level(hw, rtlphy->current_channel);\r\n}\r\nrtlpriv->dm.last_dtp_lvl = rtlpriv->dm.dynamic_txhighpower_lvl;\r\n}\r\nstatic void rtl92d_dm_pwdb_monitor(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nif (rtlpriv->mac80211.opmode != NL80211_IFTYPE_STATION)\r\nreturn;\r\nif (rtlpriv->dm.useramask) {\r\nu32 temp = rtlpriv->dm.undec_sm_pwdb;\r\ntemp <<= 16;\r\ntemp |= 0x100;\r\nrtl92d_fill_h2c_cmd(hw, H2C_RSSI_REPORT, 3, (u8 *) (&temp));\r\n} else {\r\nrtl_write_byte(rtlpriv, 0x4fe,\r\n(u8) rtlpriv->dm.undec_sm_pwdb);\r\n}\r\n}\r\nvoid rtl92d_dm_init_edca_turbo(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nrtlpriv->dm.current_turbo_edca = false;\r\nrtlpriv->dm.is_any_nonbepkts = false;\r\nrtlpriv->dm.is_cur_rdlstate = false;\r\n}\r\nstatic void rtl92d_dm_check_edca_turbo(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstatic u64 last_txok_cnt;\r\nstatic u64 last_rxok_cnt;\r\nu64 cur_txok_cnt;\r\nu64 cur_rxok_cnt;\r\nu32 edca_be_ul = 0x5ea42b;\r\nu32 edca_be_dl = 0x5ea42b;\r\nif (mac->link_state != MAC80211_LINKED) {\r\nrtlpriv->dm.current_turbo_edca = false;\r\ngoto exit;\r\n}\r\nif ((!rtlpriv->dm.disable_framebursting) &&\r\n(rtlpriv->sec.pairwise_enc_algorithm == WEP40_ENCRYPTION ||\r\nrtlpriv->sec.pairwise_enc_algorithm == WEP104_ENCRYPTION ||\r\nrtlpriv->sec.pairwise_enc_algorithm == TKIP_ENCRYPTION)) {\r\nif (!(edca_be_ul & 0xffff0000))\r\nedca_be_ul |= 0x005e0000;\r\nif (!(edca_be_dl & 0xffff0000))\r\nedca_be_dl |= 0x005e0000;\r\n}\r\nif ((!rtlpriv->dm.is_any_nonbepkts) &&\r\n(!rtlpriv->dm.disable_framebursting)) {\r\ncur_txok_cnt = rtlpriv->stats.txbytesunicast - last_txok_cnt;\r\ncur_rxok_cnt = rtlpriv->stats.rxbytesunicast - last_rxok_cnt;\r\nif (cur_rxok_cnt > 4 * cur_txok_cnt) {\r\nif (!rtlpriv->dm.is_cur_rdlstate ||\r\n!rtlpriv->dm.current_turbo_edca) {\r\nrtl_write_dword(rtlpriv, REG_EDCA_BE_PARAM,\r\nedca_be_dl);\r\nrtlpriv->dm.is_cur_rdlstate = true;\r\n}\r\n} else {\r\nif (rtlpriv->dm.is_cur_rdlstate ||\r\n!rtlpriv->dm.current_turbo_edca) {\r\nrtl_write_dword(rtlpriv, REG_EDCA_BE_PARAM,\r\nedca_be_ul);\r\nrtlpriv->dm.is_cur_rdlstate = false;\r\n}\r\n}\r\nrtlpriv->dm.current_turbo_edca = true;\r\n} else {\r\nif (rtlpriv->dm.current_turbo_edca) {\r\nu8 tmp = AC0_BE;\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AC_PARAM,\r\n&tmp);\r\nrtlpriv->dm.current_turbo_edca = false;\r\n}\r\n}\r\nexit:\r\nrtlpriv->dm.is_any_nonbepkts = false;\r\nlast_txok_cnt = rtlpriv->stats.txbytesunicast;\r\nlast_rxok_cnt = rtlpriv->stats.rxbytesunicast;\r\n}\r\nstatic void rtl92d_dm_rxgain_tracking_thermalmeter(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 index_mapping[RX_INDEX_MAPPING_NUM] = {\r\n0x0f, 0x0f, 0x0d, 0x0c, 0x0b,\r\n0x0a, 0x09, 0x08, 0x07, 0x06,\r\n0x05, 0x04, 0x04, 0x03, 0x02\r\n};\r\nint i;\r\nu32 u4tmp;\r\nu4tmp = (index_mapping[(rtlpriv->efuse.eeprom_thermalmeter -\r\nrtlpriv->dm.thermalvalue_rxgain)]) << 12;\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"===> Rx Gain %x\n", u4tmp);\r\nfor (i = RF90_PATH_A; i < rtlpriv->phy.num_total_rfpath; i++)\r\nrtl_set_rfreg(hw, i, 0x3C, RFREG_OFFSET_MASK,\r\n(rtlpriv->phy.reg_rf3c[i] & (~(0xF000))) | u4tmp);\r\n}\r\nstatic void rtl92d_bandtype_2_4G(struct ieee80211_hw *hw, long *temp_cckg,\r\nu8 *cck_index_old)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nint i;\r\nunsigned long flag = 0;\r\nlong temp_cck;\r\nrtl92d_acquire_cckandrw_pagea_ctl(hw, &flag);\r\ntemp_cck = rtl_get_bbreg(hw, RCCK0_TXFILTER2,\r\nMASKDWORD) & MASKCCK;\r\nrtl92d_release_cckandrw_pagea_ctl(hw, &flag);\r\nfor (i = 0; i < CCK_TABLE_LENGTH; i++) {\r\nif (rtlpriv->dm.cck_inch14) {\r\nif (!memcmp((void *)&temp_cck,\r\n(void *)&cckswing_table_ch14[i][2], 4)) {\r\n*cck_index_old = (u8) i;\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"Initial reg0x%x = 0x%lx, cck_index=0x%x, ch 14 %d\n",\r\nRCCK0_TXFILTER2, temp_cck,\r\n*cck_index_old,\r\nrtlpriv->dm.cck_inch14);\r\nbreak;\r\n}\r\n} else {\r\nif (!memcmp((void *) &temp_cck,\r\n&cckswing_table_ch1ch13[i][2], 4)) {\r\n*cck_index_old = (u8) i;\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"Initial reg0x%x = 0x%lx, cck_index = 0x%x, ch14 %d\n",\r\nRCCK0_TXFILTER2, temp_cck,\r\n*cck_index_old,\r\nrtlpriv->dm.cck_inch14);\r\nbreak;\r\n}\r\n}\r\n}\r\n*temp_cckg = temp_cck;\r\n}\r\nstatic void rtl92d_bandtype_5G(struct rtl_hal *rtlhal, u8 *ofdm_index,\r\nbool *internal_pa, u8 thermalvalue, u8 delta,\r\nu8 rf, struct rtl_efuse *rtlefuse,\r\nstruct rtl_priv *rtlpriv, struct rtl_phy *rtlphy,\r\nu8 index_mapping[5][INDEX_MAPPING_NUM],\r\nu8 index_mapping_pa[8][INDEX_MAPPING_NUM])\r\n{\r\nint i;\r\nu8 index;\r\nu8 offset = 0;\r\nfor (i = 0; i < rf; i++) {\r\nif (rtlhal->macphymode == DUALMAC_DUALPHY &&\r\nrtlhal->interfaceindex == 1)\r\n*internal_pa = rtlefuse->internal_pa_5g[1];\r\nelse\r\n*internal_pa = rtlefuse->internal_pa_5g[i];\r\nif (*internal_pa) {\r\nif (rtlhal->interfaceindex == 1 || i == rf)\r\noffset = 4;\r\nelse\r\noffset = 0;\r\nif (rtlphy->current_channel >= 100 &&\r\nrtlphy->current_channel <= 165)\r\noffset += 2;\r\n} else {\r\nif (rtlhal->interfaceindex == 1 || i == rf)\r\noffset = 2;\r\nelse\r\noffset = 0;\r\n}\r\nif (thermalvalue > rtlefuse->eeprom_thermalmeter)\r\noffset++;\r\nif (*internal_pa) {\r\nif (delta > INDEX_MAPPING_NUM - 1)\r\nindex = index_mapping_pa[offset]\r\n[INDEX_MAPPING_NUM - 1];\r\nelse\r\nindex =\r\nindex_mapping_pa[offset][delta];\r\n} else {\r\nif (delta > INDEX_MAPPING_NUM - 1)\r\nindex =\r\nindex_mapping[offset][INDEX_MAPPING_NUM - 1];\r\nelse\r\nindex = index_mapping[offset][delta];\r\n}\r\nif (thermalvalue > rtlefuse->eeprom_thermalmeter) {\r\nif (*internal_pa && thermalvalue > 0x12) {\r\nofdm_index[i] = rtlpriv->dm.ofdm_index[i] -\r\n((delta / 2) * 3 + (delta % 2));\r\n} else {\r\nofdm_index[i] -= index;\r\n}\r\n} else {\r\nofdm_index[i] += index;\r\n}\r\n}\r\n}\r\nstatic void rtl92d_dm_txpower_tracking_callback_thermalmeter(\r\nstruct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nu8 thermalvalue, delta, delta_lck, delta_iqk, delta_rxgain;\r\nu8 offset, thermalvalue_avg_count = 0;\r\nu32 thermalvalue_avg = 0;\r\nbool internal_pa = false;\r\nlong ele_a = 0, ele_d, temp_cck, val_x, value32;\r\nlong val_y, ele_c = 0;\r\nu8 ofdm_index[3];\r\ns8 cck_index = 0;\r\nu8 ofdm_index_old[3] = {0, 0, 0};\r\ns8 cck_index_old = 0;\r\nu8 index;\r\nint i;\r\nbool is2t = IS_92D_SINGLEPHY(rtlhal->version);\r\nu8 ofdm_min_index = 6, ofdm_min_index_internal_pa = 3, rf;\r\nu8 indexforchannel =\r\nrtl92d_get_rightchnlplace_for_iqk(rtlphy->current_channel);\r\nu8 index_mapping[5][INDEX_MAPPING_NUM] = {\r\n{0, 1, 3, 6, 8, 9, 11, 13, 14, 16, 17, 18, 18},\r\n{0, 2, 4, 5, 7, 10, 12, 14, 16, 18, 18, 18, 18},\r\n{0, 2, 3, 6, 8, 9, 11, 13, 14, 16, 17, 18, 18},\r\n{0, 2, 4, 5, 7, 10, 13, 16, 16, 18, 18, 18, 18},\r\n{0, 1, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10, 10},\r\n};\r\nu8 index_mapping_internal_pa[8][INDEX_MAPPING_NUM] = {\r\n{0, 1, 2, 4, 6, 7, 9, 11, 12, 14, 15, 16, 16},\r\n{0, 2, 4, 5, 7, 10, 12, 14, 16, 18, 18, 18, 18},\r\n{0, 1, 2, 3, 5, 6, 8, 10, 11, 13, 14, 15, 15},\r\n{0, 2, 4, 5, 7, 10, 12, 14, 16, 18, 18, 18, 18},\r\n{0, 1, 2, 4, 6, 7, 9, 11, 12, 14, 15, 16, 16},\r\n{0, 2, 4, 5, 7, 10, 13, 16, 16, 18, 18, 18, 18},\r\n{0, 1, 2, 3, 5, 6, 8, 9, 10, 12, 13, 14, 14},\r\n{0, 2, 4, 5, 7, 10, 13, 16, 16, 18, 18, 18, 18},\r\n};\r\nrtlpriv->dm.txpower_trackinginit = true;\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "\n");\r\nthermalvalue = (u8) rtl_get_rfreg(hw, RF90_PATH_A, RF_T_METER, 0xf800);\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"Readback Thermal Meter = 0x%x pre thermal meter 0x%x eeprom_thermalmeter 0x%x\n",\r\nthermalvalue,\r\nrtlpriv->dm.thermalvalue, rtlefuse->eeprom_thermalmeter);\r\nrtl92d_phy_ap_calibrate(hw, (thermalvalue -\r\nrtlefuse->eeprom_thermalmeter));\r\nif (is2t)\r\nrf = 2;\r\nelse\r\nrf = 1;\r\nif (thermalvalue) {\r\nele_d = rtl_get_bbreg(hw, ROFDM0_XATxIQIMBALANCE,\r\nMASKDWORD) & MASKOFDM_D;\r\nfor (i = 0; i < OFDM_TABLE_SIZE_92D; i++) {\r\nif (ele_d == (ofdmswing_table[i] & MASKOFDM_D)) {\r\nofdm_index_old[0] = (u8) i;\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"Initial pathA ele_d reg0x%x = 0x%lx, ofdm_index=0x%x\n",\r\nROFDM0_XATxIQIMBALANCE,\r\nele_d, ofdm_index_old[0]);\r\nbreak;\r\n}\r\n}\r\nif (is2t) {\r\nele_d = rtl_get_bbreg(hw, ROFDM0_XBTxIQIMBALANCE,\r\nMASKDWORD) & MASKOFDM_D;\r\nfor (i = 0; i < OFDM_TABLE_SIZE_92D; i++) {\r\nif (ele_d ==\r\n(ofdmswing_table[i] & MASKOFDM_D)) {\r\nofdm_index_old[1] = (u8) i;\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING,\r\nDBG_LOUD,\r\n"Initial pathB ele_d reg 0x%x = 0x%lx, ofdm_index = 0x%x\n",\r\nROFDM0_XBTxIQIMBALANCE, ele_d,\r\nofdm_index_old[1]);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\nrtl92d_bandtype_2_4G(hw, &temp_cck, &cck_index_old);\r\n} else {\r\ntemp_cck = 0x090e1317;\r\ncck_index_old = 12;\r\n}\r\nif (!rtlpriv->dm.thermalvalue) {\r\nrtlpriv->dm.thermalvalue =\r\nrtlefuse->eeprom_thermalmeter;\r\nrtlpriv->dm.thermalvalue_lck = thermalvalue;\r\nrtlpriv->dm.thermalvalue_iqk = thermalvalue;\r\nrtlpriv->dm.thermalvalue_rxgain =\r\nrtlefuse->eeprom_thermalmeter;\r\nfor (i = 0; i < rf; i++)\r\nrtlpriv->dm.ofdm_index[i] = ofdm_index_old[i];\r\nrtlpriv->dm.cck_index = cck_index_old;\r\n}\r\nif (rtlhal->reloadtxpowerindex) {\r\nfor (i = 0; i < rf; i++)\r\nrtlpriv->dm.ofdm_index[i] = ofdm_index_old[i];\r\nrtlpriv->dm.cck_index = cck_index_old;\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"reload ofdm index for band switch\n");\r\n}\r\nrtlpriv->dm.thermalvalue_avg\r\n[rtlpriv->dm.thermalvalue_avg_index] = thermalvalue;\r\nrtlpriv->dm.thermalvalue_avg_index++;\r\nif (rtlpriv->dm.thermalvalue_avg_index == AVG_THERMAL_NUM)\r\nrtlpriv->dm.thermalvalue_avg_index = 0;\r\nfor (i = 0; i < AVG_THERMAL_NUM; i++) {\r\nif (rtlpriv->dm.thermalvalue_avg[i]) {\r\nthermalvalue_avg +=\r\nrtlpriv->dm.thermalvalue_avg[i];\r\nthermalvalue_avg_count++;\r\n}\r\n}\r\nif (thermalvalue_avg_count)\r\nthermalvalue = (u8) (thermalvalue_avg /\r\nthermalvalue_avg_count);\r\nif (rtlhal->reloadtxpowerindex) {\r\ndelta = (thermalvalue > rtlefuse->eeprom_thermalmeter) ?\r\n(thermalvalue - rtlefuse->eeprom_thermalmeter) :\r\n(rtlefuse->eeprom_thermalmeter - thermalvalue);\r\nrtlhal->reloadtxpowerindex = false;\r\nrtlpriv->dm.done_txpower = false;\r\n} else if (rtlpriv->dm.done_txpower) {\r\ndelta = (thermalvalue > rtlpriv->dm.thermalvalue) ?\r\n(thermalvalue - rtlpriv->dm.thermalvalue) :\r\n(rtlpriv->dm.thermalvalue - thermalvalue);\r\n} else {\r\ndelta = (thermalvalue > rtlefuse->eeprom_thermalmeter) ?\r\n(thermalvalue - rtlefuse->eeprom_thermalmeter) :\r\n(rtlefuse->eeprom_thermalmeter - thermalvalue);\r\n}\r\ndelta_lck = (thermalvalue > rtlpriv->dm.thermalvalue_lck) ?\r\n(thermalvalue - rtlpriv->dm.thermalvalue_lck) :\r\n(rtlpriv->dm.thermalvalue_lck - thermalvalue);\r\ndelta_iqk = (thermalvalue > rtlpriv->dm.thermalvalue_iqk) ?\r\n(thermalvalue - rtlpriv->dm.thermalvalue_iqk) :\r\n(rtlpriv->dm.thermalvalue_iqk - thermalvalue);\r\ndelta_rxgain =\r\n(thermalvalue > rtlpriv->dm.thermalvalue_rxgain) ?\r\n(thermalvalue - rtlpriv->dm.thermalvalue_rxgain) :\r\n(rtlpriv->dm.thermalvalue_rxgain - thermalvalue);\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"Readback Thermal Meter = 0x%x pre thermal meter 0x%x eeprom_thermalmeter 0x%x delta 0x%x delta_lck 0x%x delta_iqk 0x%x\n",\r\nthermalvalue, rtlpriv->dm.thermalvalue,\r\nrtlefuse->eeprom_thermalmeter, delta, delta_lck,\r\ndelta_iqk);\r\nif ((delta_lck > rtlefuse->delta_lck) &&\r\n(rtlefuse->delta_lck != 0)) {\r\nrtlpriv->dm.thermalvalue_lck = thermalvalue;\r\nrtl92d_phy_lc_calibrate(hw);\r\n}\r\nif (delta > 0 && rtlpriv->dm.txpower_track_control) {\r\nrtlpriv->dm.done_txpower = true;\r\ndelta = (thermalvalue > rtlefuse->eeprom_thermalmeter) ?\r\n(thermalvalue - rtlefuse->eeprom_thermalmeter) :\r\n(rtlefuse->eeprom_thermalmeter - thermalvalue);\r\nif (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\noffset = 4;\r\nif (delta > INDEX_MAPPING_NUM - 1)\r\nindex = index_mapping[offset]\r\n[INDEX_MAPPING_NUM - 1];\r\nelse\r\nindex = index_mapping[offset][delta];\r\nif (thermalvalue > rtlpriv->dm.thermalvalue) {\r\nfor (i = 0; i < rf; i++)\r\nofdm_index[i] -= delta;\r\ncck_index -= delta;\r\n} else {\r\nfor (i = 0; i < rf; i++)\r\nofdm_index[i] += index;\r\ncck_index += index;\r\n}\r\n} else if (rtlhal->current_bandtype == BAND_ON_5G) {\r\nrtl92d_bandtype_5G(rtlhal, ofdm_index,\r\n&internal_pa, thermalvalue,\r\ndelta, rf, rtlefuse, rtlpriv,\r\nrtlphy, index_mapping,\r\nindex_mapping_internal_pa);\r\n}\r\nif (is2t) {\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"temp OFDM_A_index=0x%x, OFDM_B_index = 0x%x,cck_index=0x%x\n",\r\nrtlpriv->dm.ofdm_index[0],\r\nrtlpriv->dm.ofdm_index[1],\r\nrtlpriv->dm.cck_index);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"temp OFDM_A_index=0x%x,cck_index = 0x%x\n",\r\nrtlpriv->dm.ofdm_index[0],\r\nrtlpriv->dm.cck_index);\r\n}\r\nfor (i = 0; i < rf; i++) {\r\nif (ofdm_index[i] > OFDM_TABLE_SIZE_92D - 1)\r\nofdm_index[i] = OFDM_TABLE_SIZE_92D - 1;\r\nelse if (ofdm_index[i] < ofdm_min_index)\r\nofdm_index[i] = ofdm_min_index;\r\n}\r\nif (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\nif (cck_index > CCK_TABLE_SIZE - 1) {\r\ncck_index = CCK_TABLE_SIZE - 1;\r\n} else if (internal_pa ||\r\nrtlhal->current_bandtype ==\r\nBAND_ON_2_4G) {\r\nif (ofdm_index[i] <\r\nofdm_min_index_internal_pa)\r\nofdm_index[i] =\r\nofdm_min_index_internal_pa;\r\n} else if (cck_index < 0) {\r\ncck_index = 0;\r\n}\r\n}\r\nif (is2t) {\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"new OFDM_A_index=0x%x, OFDM_B_index = 0x%x, cck_index=0x%x\n",\r\nofdm_index[0], ofdm_index[1],\r\ncck_index);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"new OFDM_A_index=0x%x,cck_index = 0x%x\n",\r\nofdm_index[0], cck_index);\r\n}\r\nele_d = (ofdmswing_table[(u8) ofdm_index[0]] &\r\n0xFFC00000) >> 22;\r\nval_x = rtlphy->iqk_matrix\r\n[indexforchannel].value[0][0];\r\nval_y = rtlphy->iqk_matrix\r\n[indexforchannel].value[0][1];\r\nif (val_x != 0) {\r\nif ((val_x & 0x00000200) != 0)\r\nval_x = val_x | 0xFFFFFC00;\r\nele_a =\r\n((val_x * ele_d) >> 8) & 0x000003FF;\r\nif ((val_y & 0x00000200) != 0)\r\nval_y = val_y | 0xFFFFFC00;\r\nele_c = ((val_y * ele_d) >> 8) & 0x000003FF;\r\nvalue32 = (ele_d << 22) | ((ele_c & 0x3F) <<\r\n16) | ele_a;\r\nrtl_set_bbreg(hw, ROFDM0_XATxIQIMBALANCE,\r\nMASKDWORD, value32);\r\nvalue32 = (ele_c & 0x000003C0) >> 6;\r\nrtl_set_bbreg(hw, ROFDM0_XCTxAFE, MASKH4BITS,\r\nvalue32);\r\nvalue32 = ((val_x * ele_d) >> 7) & 0x01;\r\nrtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(24),\r\nvalue32);\r\n} else {\r\nrtl_set_bbreg(hw, ROFDM0_XATxIQIMBALANCE,\r\nMASKDWORD,\r\nofdmswing_table\r\n[(u8)ofdm_index[0]]);\r\nrtl_set_bbreg(hw, ROFDM0_XCTxAFE, MASKH4BITS,\r\n0x00);\r\nrtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\r\nBIT(24), 0x00);\r\n}\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"TxPwrTracking for interface %d path A: X = 0x%lx, Y = 0x%lx ele_A = 0x%lx ele_C = 0x%lx ele_D = 0x%lx 0xe94 = 0x%lx 0xe9c = 0x%lx\n",\r\nrtlhal->interfaceindex,\r\nval_x, val_y, ele_a, ele_c, ele_d,\r\nval_x, val_y);\r\nif (cck_index >= CCK_TABLE_SIZE)\r\ncck_index = CCK_TABLE_SIZE - 1;\r\nif (cck_index < 0)\r\ncck_index = 0;\r\nif (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\nif (!rtlpriv->dm.cck_inch14) {\r\nrtl_write_byte(rtlpriv, 0xa22,\r\ncckswing_table_ch1ch13\r\n[(u8)cck_index][0]);\r\nrtl_write_byte(rtlpriv, 0xa23,\r\ncckswing_table_ch1ch13\r\n[(u8)cck_index][1]);\r\nrtl_write_byte(rtlpriv, 0xa24,\r\ncckswing_table_ch1ch13\r\n[(u8)cck_index][2]);\r\nrtl_write_byte(rtlpriv, 0xa25,\r\ncckswing_table_ch1ch13\r\n[(u8)cck_index][3]);\r\nrtl_write_byte(rtlpriv, 0xa26,\r\ncckswing_table_ch1ch13\r\n[(u8)cck_index][4]);\r\nrtl_write_byte(rtlpriv, 0xa27,\r\ncckswing_table_ch1ch13\r\n[(u8)cck_index][5]);\r\nrtl_write_byte(rtlpriv, 0xa28,\r\ncckswing_table_ch1ch13\r\n[(u8)cck_index][6]);\r\nrtl_write_byte(rtlpriv, 0xa29,\r\ncckswing_table_ch1ch13\r\n[(u8)cck_index][7]);\r\n} else {\r\nrtl_write_byte(rtlpriv, 0xa22,\r\ncckswing_table_ch14\r\n[(u8)cck_index][0]);\r\nrtl_write_byte(rtlpriv, 0xa23,\r\ncckswing_table_ch14\r\n[(u8)cck_index][1]);\r\nrtl_write_byte(rtlpriv, 0xa24,\r\ncckswing_table_ch14\r\n[(u8)cck_index][2]);\r\nrtl_write_byte(rtlpriv, 0xa25,\r\ncckswing_table_ch14\r\n[(u8)cck_index][3]);\r\nrtl_write_byte(rtlpriv, 0xa26,\r\ncckswing_table_ch14\r\n[(u8)cck_index][4]);\r\nrtl_write_byte(rtlpriv, 0xa27,\r\ncckswing_table_ch14\r\n[(u8)cck_index][5]);\r\nrtl_write_byte(rtlpriv, 0xa28,\r\ncckswing_table_ch14\r\n[(u8)cck_index][6]);\r\nrtl_write_byte(rtlpriv, 0xa29,\r\ncckswing_table_ch14\r\n[(u8)cck_index][7]);\r\n}\r\n}\r\nif (is2t) {\r\nele_d = (ofdmswing_table[(u8) ofdm_index[1]] &\r\n0xFFC00000) >> 22;\r\nval_x = rtlphy->iqk_matrix\r\n[indexforchannel].value[0][4];\r\nval_y = rtlphy->iqk_matrix\r\n[indexforchannel].value[0][5];\r\nif (val_x != 0) {\r\nif ((val_x & 0x00000200) != 0)\r\nval_x = val_x | 0xFFFFFC00;\r\nele_a = ((val_x * ele_d) >> 8) &\r\n0x000003FF;\r\nif ((val_y & 0x00000200) != 0)\r\nval_y =\r\nval_y | 0xFFFFFC00;\r\nele_c =\r\n((val_y *\r\nele_d) >> 8) & 0x00003FF;\r\nvalue32 = (ele_d << 22) |\r\n((ele_c & 0x3F) << 16) |\r\nele_a;\r\nrtl_set_bbreg(hw,\r\nROFDM0_XBTxIQIMBALANCE,\r\nMASKDWORD, value32);\r\nvalue32 = (ele_c & 0x000003C0) >> 6;\r\nrtl_set_bbreg(hw, ROFDM0_XDTxAFE,\r\nMASKH4BITS, value32);\r\nvalue32 = ((val_x * ele_d) >> 7) & 0x01;\r\nrtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\r\nBIT(28), value32);\r\n} else {\r\nrtl_set_bbreg(hw,\r\nROFDM0_XBTxIQIMBALANCE,\r\nMASKDWORD,\r\nofdmswing_table\r\n[(u8) ofdm_index[1]]);\r\nrtl_set_bbreg(hw, ROFDM0_XDTxAFE,\r\nMASKH4BITS, 0x00);\r\nrtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\r\nBIT(28), 0x00);\r\n}\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"TxPwrTracking path B: X = 0x%lx, Y = 0x%lx ele_A = 0x%lx ele_C = 0x%lx ele_D = 0x%lx 0xeb4 = 0x%lx 0xebc = 0x%lx\n",\r\nval_x, val_y, ele_a, ele_c,\r\nele_d, val_x, val_y);\r\n}\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"TxPwrTracking 0xc80 = 0x%x, 0xc94 = 0x%x RF 0x24 = 0x%x\n",\r\nrtl_get_bbreg(hw, 0xc80, MASKDWORD),\r\nrtl_get_bbreg(hw, 0xc94, MASKDWORD),\r\nrtl_get_rfreg(hw, RF90_PATH_A, 0x24,\r\nRFREG_OFFSET_MASK));\r\n}\r\nif ((delta_iqk > rtlefuse->delta_iqk) &&\r\n(rtlefuse->delta_iqk != 0)) {\r\nrtl92d_phy_reset_iqk_result(hw);\r\nrtlpriv->dm.thermalvalue_iqk = thermalvalue;\r\nrtl92d_phy_iq_calibrate(hw);\r\n}\r\nif (delta_rxgain > 0 && rtlhal->current_bandtype == BAND_ON_5G\r\n&& thermalvalue <= rtlefuse->eeprom_thermalmeter) {\r\nrtlpriv->dm.thermalvalue_rxgain = thermalvalue;\r\nrtl92d_dm_rxgain_tracking_thermalmeter(hw);\r\n}\r\nif (rtlpriv->dm.txpower_track_control)\r\nrtlpriv->dm.thermalvalue = thermalvalue;\r\n}\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "<===\n");\r\n}\r\nstatic void rtl92d_dm_initialize_txpower_tracking(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nrtlpriv->dm.txpower_tracking = true;\r\nrtlpriv->dm.txpower_trackinginit = false;\r\nrtlpriv->dm.txpower_track_control = true;\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"pMgntInfo->txpower_tracking = %d\n",\r\nrtlpriv->dm.txpower_tracking);\r\n}\r\nvoid rtl92d_dm_check_txpower_tracking_thermal_meter(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nif (!rtlpriv->dm.txpower_tracking)\r\nreturn;\r\nif (!rtlpriv->dm.tm_trigger) {\r\nrtl_set_rfreg(hw, RF90_PATH_A, RF_T_METER, BIT(17) |\r\nBIT(16), 0x03);\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"Trigger 92S Thermal Meter!!\n");\r\nrtlpriv->dm.tm_trigger = 1;\r\nreturn;\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\r\n"Schedule TxPowerTracking direct call!!\n");\r\nrtl92d_dm_txpower_tracking_callback_thermalmeter(hw);\r\nrtlpriv->dm.tm_trigger = 0;\r\n}\r\n}\r\nvoid rtl92d_dm_init_rate_adaptive_mask(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rate_adaptive *ra = &(rtlpriv->ra);\r\nra->ratr_state = DM_RATR_STA_INIT;\r\nra->pre_ratr_state = DM_RATR_STA_INIT;\r\nif (rtlpriv->dm.dm_type == DM_TYPE_BYDRIVER)\r\nrtlpriv->dm.useramask = true;\r\nelse\r\nrtlpriv->dm.useramask = false;\r\n}\r\nvoid rtl92d_dm_init(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nrtlpriv->dm.dm_type = DM_TYPE_BYDRIVER;\r\nrtl_dm_diginit(hw, 0x20);\r\nrtlpriv->dm_digtable.rx_gain_max = DM_DIG_FA_UPPER;\r\nrtlpriv->dm_digtable.rx_gain_min = DM_DIG_FA_LOWER;\r\nrtl92d_dm_init_dynamic_txpower(hw);\r\nrtl92d_dm_init_edca_turbo(hw);\r\nrtl92d_dm_init_rate_adaptive_mask(hw);\r\nrtl92d_dm_initialize_txpower_tracking(hw);\r\n}\r\nvoid rtl92d_dm_watchdog(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nbool fw_current_inpsmode = false;\r\nbool fwps_awake = true;\r\nif ((ppsc->rfpwr_state == ERFON) && ((!fw_current_inpsmode) &&\r\nfwps_awake) && (!ppsc->rfchange_inprogress)) {\r\nrtl92d_dm_pwdb_monitor(hw);\r\nrtl92d_dm_false_alarm_counter_statistics(hw);\r\nrtl92d_dm_find_minimum_rssi(hw);\r\nrtl92d_dm_dig(hw);\r\nrtl92d_dm_dynamic_txpower(hw);\r\nrtl92d_dm_check_edca_turbo(hw);\r\n}\r\n}
