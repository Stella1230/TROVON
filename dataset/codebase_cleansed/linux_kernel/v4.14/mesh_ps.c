static struct sk_buff *mps_qos_null_get(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_hdr *nullfunc;\r\nstruct sk_buff *skb;\r\nint size = sizeof(*nullfunc);\r\n__le16 fc;\r\nskb = dev_alloc_skb(local->hw.extra_tx_headroom + size + 2);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, local->hw.extra_tx_headroom);\r\nnullfunc = skb_put(skb, size);\r\nfc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_QOS_NULLFUNC);\r\nieee80211_fill_mesh_addresses(nullfunc, &fc, sta->sta.addr,\r\nsdata->vif.addr);\r\nnullfunc->frame_control = fc;\r\nnullfunc->duration_id = 0;\r\nnullfunc->seq_ctrl = 0;\r\nmemcpy(nullfunc->addr1, sta->sta.addr, ETH_ALEN);\r\nskb_put_zero(skb, 2);\r\nieee80211_mps_set_frame_flags(sdata, sta, nullfunc);\r\nreturn skb;\r\n}\r\nstatic void mps_qos_null_tx(struct sta_info *sta)\r\n{\r\nstruct sk_buff *skb;\r\nskb = mps_qos_null_get(sta);\r\nif (!skb)\r\nreturn;\r\nmps_dbg(sta->sdata, "announcing peer-specific power mode to %pM\n",\r\nsta->sta.addr);\r\nif (!test_sta_flag(sta, WLAN_STA_PS_STA)) {\r\nu8 *qc = ieee80211_get_qos_ctl((void *) skb->data);\r\nqc[0] |= IEEE80211_QOS_CTL_EOSP;\r\n}\r\nieee80211_tx_skb(sta->sdata, skb);\r\n}\r\nu32 ieee80211_mps_local_status_update(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct sta_info *sta;\r\nbool peering = false;\r\nint light_sleep_cnt = 0;\r\nint deep_sleep_cnt = 0;\r\nu32 changed = 0;\r\nenum nl80211_mesh_power_mode nonpeer_pm;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(sta, &sdata->local->sta_list, list) {\r\nif (sdata != sta->sdata)\r\ncontinue;\r\nswitch (sta->mesh->plink_state) {\r\ncase NL80211_PLINK_OPN_SNT:\r\ncase NL80211_PLINK_OPN_RCVD:\r\ncase NL80211_PLINK_CNF_RCVD:\r\npeering = true;\r\nbreak;\r\ncase NL80211_PLINK_ESTAB:\r\nif (sta->mesh->local_pm == NL80211_MESH_POWER_LIGHT_SLEEP)\r\nlight_sleep_cnt++;\r\nelse if (sta->mesh->local_pm == NL80211_MESH_POWER_DEEP_SLEEP)\r\ndeep_sleep_cnt++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (peering) {\r\nmps_dbg(sdata, "setting non-peer PM to active for peering\n");\r\nnonpeer_pm = NL80211_MESH_POWER_ACTIVE;\r\n} else if (light_sleep_cnt || deep_sleep_cnt) {\r\nmps_dbg(sdata, "setting non-peer PM to deep sleep\n");\r\nnonpeer_pm = NL80211_MESH_POWER_DEEP_SLEEP;\r\n} else {\r\nmps_dbg(sdata, "setting non-peer PM to user value\n");\r\nnonpeer_pm = ifmsh->mshcfg.power_mode;\r\n}\r\nif (ifmsh->nonpeer_pm != nonpeer_pm ||\r\n!ifmsh->ps_peers_light_sleep != !light_sleep_cnt ||\r\n!ifmsh->ps_peers_deep_sleep != !deep_sleep_cnt)\r\nchanged = BSS_CHANGED_BEACON;\r\nifmsh->nonpeer_pm = nonpeer_pm;\r\nifmsh->ps_peers_light_sleep = light_sleep_cnt;\r\nifmsh->ps_peers_deep_sleep = deep_sleep_cnt;\r\nreturn changed;\r\n}\r\nu32 ieee80211_mps_set_sta_local_pm(struct sta_info *sta,\r\nenum nl80211_mesh_power_mode pm)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nif (sta->mesh->local_pm == pm)\r\nreturn 0;\r\nmps_dbg(sdata, "local STA operates in mode %d with %pM\n",\r\npm, sta->sta.addr);\r\nsta->mesh->local_pm = pm;\r\nif (sta->mesh->plink_state == NL80211_PLINK_ESTAB)\r\nmps_qos_null_tx(sta);\r\nreturn ieee80211_mps_local_status_update(sdata);\r\n}\r\nvoid ieee80211_mps_set_frame_flags(struct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta,\r\nstruct ieee80211_hdr *hdr)\r\n{\r\nenum nl80211_mesh_power_mode pm;\r\nu8 *qc;\r\nif (WARN_ON(is_unicast_ether_addr(hdr->addr1) &&\r\nieee80211_is_data_qos(hdr->frame_control) &&\r\n!sta))\r\nreturn;\r\nif (is_unicast_ether_addr(hdr->addr1) &&\r\nieee80211_is_data_qos(hdr->frame_control) &&\r\nsta->mesh->plink_state == NL80211_PLINK_ESTAB)\r\npm = sta->mesh->local_pm;\r\nelse\r\npm = sdata->u.mesh.nonpeer_pm;\r\nif (pm == NL80211_MESH_POWER_ACTIVE)\r\nhdr->frame_control &= cpu_to_le16(~IEEE80211_FCTL_PM);\r\nelse\r\nhdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\r\nif (!ieee80211_is_data_qos(hdr->frame_control))\r\nreturn;\r\nqc = ieee80211_get_qos_ctl(hdr);\r\nif ((is_unicast_ether_addr(hdr->addr1) &&\r\npm == NL80211_MESH_POWER_DEEP_SLEEP) ||\r\n(is_multicast_ether_addr(hdr->addr1) &&\r\nsdata->u.mesh.ps_peers_deep_sleep > 0))\r\nqc[1] |= (IEEE80211_QOS_CTL_MESH_PS_LEVEL >> 8);\r\nelse\r\nqc[1] &= ~(IEEE80211_QOS_CTL_MESH_PS_LEVEL >> 8);\r\n}\r\nvoid ieee80211_mps_sta_status_update(struct sta_info *sta)\r\n{\r\nenum nl80211_mesh_power_mode pm;\r\nbool do_buffer;\r\nif (sta->sta_state < IEEE80211_STA_ASSOC)\r\nreturn;\r\nif (sta->mesh->plink_state == NL80211_PLINK_ESTAB &&\r\nsta->mesh->peer_pm != NL80211_MESH_POWER_UNKNOWN)\r\npm = sta->mesh->peer_pm;\r\nelse\r\npm = sta->mesh->nonpeer_pm;\r\ndo_buffer = (pm != NL80211_MESH_POWER_ACTIVE);\r\nif (sta->mesh->plink_state != NL80211_PLINK_ESTAB) {\r\nclear_sta_flag(sta, WLAN_STA_MPSP_OWNER);\r\nclear_sta_flag(sta, WLAN_STA_MPSP_RECIPIENT);\r\n} else if (!do_buffer) {\r\nclear_sta_flag(sta, WLAN_STA_MPSP_OWNER);\r\n}\r\nif (test_sta_flag(sta, WLAN_STA_PS_STA) == do_buffer)\r\nreturn;\r\nif (do_buffer) {\r\nset_sta_flag(sta, WLAN_STA_PS_STA);\r\natomic_inc(&sta->sdata->u.mesh.ps.num_sta_ps);\r\nmps_dbg(sta->sdata, "start PS buffering frames towards %pM\n",\r\nsta->sta.addr);\r\n} else {\r\nieee80211_sta_ps_deliver_wakeup(sta);\r\n}\r\n}\r\nstatic void mps_set_sta_peer_pm(struct sta_info *sta,\r\nstruct ieee80211_hdr *hdr)\r\n{\r\nenum nl80211_mesh_power_mode pm;\r\nu8 *qc = ieee80211_get_qos_ctl(hdr);\r\nif (ieee80211_has_pm(hdr->frame_control)) {\r\nif (qc[1] & (IEEE80211_QOS_CTL_MESH_PS_LEVEL >> 8))\r\npm = NL80211_MESH_POWER_DEEP_SLEEP;\r\nelse\r\npm = NL80211_MESH_POWER_LIGHT_SLEEP;\r\n} else {\r\npm = NL80211_MESH_POWER_ACTIVE;\r\n}\r\nif (sta->mesh->peer_pm == pm)\r\nreturn;\r\nmps_dbg(sta->sdata, "STA %pM enters mode %d\n",\r\nsta->sta.addr, pm);\r\nsta->mesh->peer_pm = pm;\r\nieee80211_mps_sta_status_update(sta);\r\n}\r\nstatic void mps_set_sta_nonpeer_pm(struct sta_info *sta,\r\nstruct ieee80211_hdr *hdr)\r\n{\r\nenum nl80211_mesh_power_mode pm;\r\nif (ieee80211_has_pm(hdr->frame_control))\r\npm = NL80211_MESH_POWER_DEEP_SLEEP;\r\nelse\r\npm = NL80211_MESH_POWER_ACTIVE;\r\nif (sta->mesh->nonpeer_pm == pm)\r\nreturn;\r\nmps_dbg(sta->sdata, "STA %pM sets non-peer mode to %d\n",\r\nsta->sta.addr, pm);\r\nsta->mesh->nonpeer_pm = pm;\r\nieee80211_mps_sta_status_update(sta);\r\n}\r\nvoid ieee80211_mps_rx_h_sta_process(struct sta_info *sta,\r\nstruct ieee80211_hdr *hdr)\r\n{\r\nif (is_unicast_ether_addr(hdr->addr1) &&\r\nieee80211_is_data_qos(hdr->frame_control)) {\r\nmps_set_sta_peer_pm(sta, hdr);\r\nieee80211_mpsp_trigger_process(ieee80211_get_qos_ctl(hdr),\r\nsta, false, false);\r\n} else {\r\nmps_set_sta_nonpeer_pm(sta, hdr);\r\n}\r\n}\r\nstatic void mpsp_trigger_send(struct sta_info *sta, bool rspi, bool eosp)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr *nullfunc;\r\nstruct ieee80211_tx_info *info;\r\nu8 *qc;\r\nskb = mps_qos_null_get(sta);\r\nif (!skb)\r\nreturn;\r\nnullfunc = (struct ieee80211_hdr *) skb->data;\r\nif (!eosp)\r\nnullfunc->frame_control |=\r\ncpu_to_le16(IEEE80211_FCTL_MOREDATA);\r\nqc = ieee80211_get_qos_ctl(nullfunc);\r\nif (rspi)\r\nqc[1] |= (IEEE80211_QOS_CTL_RSPI >> 8);\r\nif (eosp)\r\nqc[0] |= IEEE80211_QOS_CTL_EOSP;\r\ninfo = IEEE80211_SKB_CB(skb);\r\ninfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER |\r\nIEEE80211_TX_CTL_REQ_TX_STATUS;\r\nmps_dbg(sdata, "sending MPSP trigger%s%s to %pM\n",\r\nrspi ? " RSPI" : "", eosp ? " EOSP" : "", sta->sta.addr);\r\nieee80211_tx_skb(sdata, skb);\r\n}\r\nstatic void mpsp_qos_null_append(struct sta_info *sta,\r\nstruct sk_buff_head *frames)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct sk_buff *new_skb, *skb = skb_peek_tail(frames);\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct ieee80211_tx_info *info;\r\nif (ieee80211_is_data_qos(hdr->frame_control))\r\nreturn;\r\nnew_skb = mps_qos_null_get(sta);\r\nif (!new_skb)\r\nreturn;\r\nmps_dbg(sdata, "appending QoS Null in MPSP towards %pM\n",\r\nsta->sta.addr);\r\nnew_skb->priority = 1;\r\nskb_set_queue_mapping(new_skb, IEEE80211_AC_BK);\r\nieee80211_set_qos_hdr(sdata, new_skb);\r\ninfo = IEEE80211_SKB_CB(new_skb);\r\ninfo->control.vif = &sdata->vif;\r\ninfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;\r\n__skb_queue_tail(frames, new_skb);\r\n}\r\nstatic void mps_frame_deliver(struct sta_info *sta, int n_frames)\r\n{\r\nstruct ieee80211_local *local = sta->sdata->local;\r\nint ac;\r\nstruct sk_buff_head frames;\r\nstruct sk_buff *skb;\r\nbool more_data = false;\r\nskb_queue_head_init(&frames);\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\r\nwhile (n_frames != 0) {\r\nskb = skb_dequeue(&sta->tx_filtered[ac]);\r\nif (!skb) {\r\nskb = skb_dequeue(\r\n&sta->ps_tx_buf[ac]);\r\nif (skb)\r\nlocal->total_ps_buffered--;\r\n}\r\nif (!skb)\r\nbreak;\r\nn_frames--;\r\n__skb_queue_tail(&frames, skb);\r\n}\r\nif (!skb_queue_empty(&sta->tx_filtered[ac]) ||\r\n!skb_queue_empty(&sta->ps_tx_buf[ac]))\r\nmore_data = true;\r\n}\r\nif (skb_queue_empty(&frames)) {\r\nmpsp_trigger_send(sta, false, true);\r\nreturn;\r\n}\r\nif (test_sta_flag(sta, WLAN_STA_MPSP_OWNER))\r\nmpsp_qos_null_append(sta, &frames);\r\nmps_dbg(sta->sdata, "sending %d frames to PS STA %pM\n",\r\nskb_queue_len(&frames), sta->sta.addr);\r\nskb_queue_walk(&frames, skb) {\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr = (void *) skb->data;\r\ninfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER;\r\nif (more_data || !skb_queue_is_last(&frames, skb))\r\nhdr->frame_control |=\r\ncpu_to_le16(IEEE80211_FCTL_MOREDATA);\r\nelse\r\nhdr->frame_control &=\r\ncpu_to_le16(~IEEE80211_FCTL_MOREDATA);\r\nif (skb_queue_is_last(&frames, skb) &&\r\nieee80211_is_data_qos(hdr->frame_control)) {\r\nu8 *qoshdr = ieee80211_get_qos_ctl(hdr);\r\n*qoshdr |= IEEE80211_QOS_CTL_EOSP;\r\ninfo->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\r\n}\r\n}\r\nieee80211_add_pending_skbs(local, &frames);\r\nsta_info_recalc_tim(sta);\r\n}\r\nvoid ieee80211_mpsp_trigger_process(u8 *qc, struct sta_info *sta,\r\nbool tx, bool acked)\r\n{\r\nu8 rspi = qc[1] & (IEEE80211_QOS_CTL_RSPI >> 8);\r\nu8 eosp = qc[0] & IEEE80211_QOS_CTL_EOSP;\r\nif (tx) {\r\nif (rspi && acked)\r\nset_sta_flag(sta, WLAN_STA_MPSP_RECIPIENT);\r\nif (eosp)\r\nclear_sta_flag(sta, WLAN_STA_MPSP_OWNER);\r\nelse if (acked &&\r\ntest_sta_flag(sta, WLAN_STA_PS_STA) &&\r\n!test_and_set_sta_flag(sta, WLAN_STA_MPSP_OWNER))\r\nmps_frame_deliver(sta, -1);\r\n} else {\r\nif (eosp)\r\nclear_sta_flag(sta, WLAN_STA_MPSP_RECIPIENT);\r\nelse if (sta->mesh->local_pm != NL80211_MESH_POWER_ACTIVE)\r\nset_sta_flag(sta, WLAN_STA_MPSP_RECIPIENT);\r\nif (rspi && !test_and_set_sta_flag(sta, WLAN_STA_MPSP_OWNER))\r\nmps_frame_deliver(sta, -1);\r\n}\r\n}\r\nvoid ieee80211_mps_frame_release(struct sta_info *sta,\r\nstruct ieee802_11_elems *elems)\r\n{\r\nint ac, buffer_local = 0;\r\nbool has_buffered = false;\r\nif (sta->mesh->plink_state == NL80211_PLINK_ESTAB)\r\nhas_buffered = ieee80211_check_tim(elems->tim, elems->tim_len,\r\nsta->mesh->aid);\r\nif (has_buffered)\r\nmps_dbg(sta->sdata, "%pM indicates buffered frames\n",\r\nsta->sta.addr);\r\nif (test_sta_flag(sta, WLAN_STA_PS_STA) &&\r\n(!elems->awake_window || !le16_to_cpu(*elems->awake_window)))\r\nreturn;\r\nif (!test_sta_flag(sta, WLAN_STA_MPSP_OWNER))\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\r\nbuffer_local += skb_queue_len(&sta->ps_tx_buf[ac]) +\r\nskb_queue_len(&sta->tx_filtered[ac]);\r\nif (!has_buffered && !buffer_local)\r\nreturn;\r\nif (sta->mesh->plink_state == NL80211_PLINK_ESTAB)\r\nmpsp_trigger_send(sta, has_buffered, !buffer_local);\r\nelse\r\nmps_frame_deliver(sta, 1);\r\n}
