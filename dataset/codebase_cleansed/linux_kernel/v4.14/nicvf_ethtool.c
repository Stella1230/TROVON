static int nicvf_get_link_ksettings(struct net_device *netdev,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nstruct nicvf *nic = netdev_priv(netdev);\r\nu32 supported, advertising;\r\nsupported = 0;\r\nadvertising = 0;\r\nif (!nic->link_up) {\r\ncmd->base.duplex = DUPLEX_UNKNOWN;\r\ncmd->base.speed = SPEED_UNKNOWN;\r\nreturn 0;\r\n}\r\nswitch (nic->speed) {\r\ncase SPEED_1000:\r\ncmd->base.port = PORT_MII | PORT_TP;\r\ncmd->base.autoneg = AUTONEG_ENABLE;\r\nsupported |= SUPPORTED_MII | SUPPORTED_TP;\r\nsupported |= SUPPORTED_1000baseT_Full |\r\nSUPPORTED_1000baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_10baseT_Half;\r\nsupported |= SUPPORTED_Autoneg;\r\nadvertising |= ADVERTISED_1000baseT_Full |\r\nADVERTISED_1000baseT_Half |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_10baseT_Full |\r\nADVERTISED_10baseT_Half;\r\nbreak;\r\ncase SPEED_10000:\r\nif (nic->mac_type == BGX_MODE_RXAUI) {\r\ncmd->base.port = PORT_TP;\r\nsupported |= SUPPORTED_TP;\r\n} else {\r\ncmd->base.port = PORT_FIBRE;\r\nsupported |= SUPPORTED_FIBRE;\r\n}\r\ncmd->base.autoneg = AUTONEG_DISABLE;\r\nsupported |= SUPPORTED_10000baseT_Full;\r\nbreak;\r\ncase SPEED_40000:\r\ncmd->base.port = PORT_FIBRE;\r\ncmd->base.autoneg = AUTONEG_DISABLE;\r\nsupported |= SUPPORTED_FIBRE;\r\nsupported |= SUPPORTED_40000baseCR4_Full;\r\nbreak;\r\n}\r\ncmd->base.duplex = nic->duplex;\r\ncmd->base.speed = nic->speed;\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\r\nsupported);\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\r\nadvertising);\r\nreturn 0;\r\n}\r\nstatic u32 nicvf_get_link(struct net_device *netdev)\r\n{\r\nstruct nicvf *nic = netdev_priv(netdev);\r\nreturn nic->link_up;\r\n}\r\nstatic void nicvf_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct nicvf *nic = netdev_priv(netdev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(nic->pdev), sizeof(info->bus_info));\r\n}\r\nstatic u32 nicvf_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct nicvf *nic = netdev_priv(netdev);\r\nreturn nic->msg_enable;\r\n}\r\nstatic void nicvf_set_msglevel(struct net_device *netdev, u32 lvl)\r\n{\r\nstruct nicvf *nic = netdev_priv(netdev);\r\nnic->msg_enable = lvl;\r\n}\r\nstatic void nicvf_get_qset_strings(struct nicvf *nic, u8 **data, int qset)\r\n{\r\nint stats, qidx;\r\nint start_qidx = qset * MAX_RCV_QUEUES_PER_QS;\r\nfor (qidx = 0; qidx < nic->qs->rq_cnt; qidx++) {\r\nfor (stats = 0; stats < nicvf_n_queue_stats; stats++) {\r\nsprintf(*data, "rxq%d: %s", qidx + start_qidx,\r\nnicvf_queue_stats[stats].name);\r\n*data += ETH_GSTRING_LEN;\r\n}\r\n}\r\nfor (qidx = 0; qidx < nic->qs->sq_cnt; qidx++) {\r\nfor (stats = 0; stats < nicvf_n_queue_stats; stats++) {\r\nsprintf(*data, "txq%d: %s", qidx + start_qidx,\r\nnicvf_queue_stats[stats].name);\r\n*data += ETH_GSTRING_LEN;\r\n}\r\n}\r\n}\r\nstatic void nicvf_get_strings(struct net_device *netdev, u32 sset, u8 *data)\r\n{\r\nstruct nicvf *nic = netdev_priv(netdev);\r\nint stats;\r\nint sqs;\r\nif (sset != ETH_SS_STATS)\r\nreturn;\r\nfor (stats = 0; stats < nicvf_n_hw_stats; stats++) {\r\nmemcpy(data, nicvf_hw_stats[stats].name, ETH_GSTRING_LEN);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\nfor (stats = 0; stats < nicvf_n_drv_stats; stats++) {\r\nmemcpy(data, nicvf_drv_stats[stats].name, ETH_GSTRING_LEN);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\nnicvf_get_qset_strings(nic, &data, 0);\r\nfor (sqs = 0; sqs < nic->sqs_count; sqs++) {\r\nif (!nic->snicvf[sqs])\r\ncontinue;\r\nnicvf_get_qset_strings(nic->snicvf[sqs], &data, sqs + 1);\r\n}\r\nfor (stats = 0; stats < BGX_RX_STATS_COUNT; stats++) {\r\nsprintf(data, "bgx_rxstat%d: ", stats);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\nfor (stats = 0; stats < BGX_TX_STATS_COUNT; stats++) {\r\nsprintf(data, "bgx_txstat%d: ", stats);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\n}\r\nstatic int nicvf_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nstruct nicvf *nic = netdev_priv(netdev);\r\nint qstats_count;\r\nint sqs;\r\nif (sset != ETH_SS_STATS)\r\nreturn -EINVAL;\r\nqstats_count = nicvf_n_queue_stats *\r\n(nic->qs->rq_cnt + nic->qs->sq_cnt);\r\nfor (sqs = 0; sqs < nic->sqs_count; sqs++) {\r\nstruct nicvf *snic;\r\nsnic = nic->snicvf[sqs];\r\nif (!snic)\r\ncontinue;\r\nqstats_count += nicvf_n_queue_stats *\r\n(snic->qs->rq_cnt + snic->qs->sq_cnt);\r\n}\r\nreturn nicvf_n_hw_stats + nicvf_n_drv_stats +\r\nqstats_count +\r\nBGX_RX_STATS_COUNT + BGX_TX_STATS_COUNT;\r\n}\r\nstatic void nicvf_get_qset_stats(struct nicvf *nic,\r\nstruct ethtool_stats *stats, u64 **data)\r\n{\r\nint stat, qidx;\r\nif (!nic)\r\nreturn;\r\nfor (qidx = 0; qidx < nic->qs->rq_cnt; qidx++) {\r\nnicvf_update_rq_stats(nic, qidx);\r\nfor (stat = 0; stat < nicvf_n_queue_stats; stat++)\r\n*((*data)++) = ((u64 *)&nic->qs->rq[qidx].stats)\r\n[nicvf_queue_stats[stat].index];\r\n}\r\nfor (qidx = 0; qidx < nic->qs->sq_cnt; qidx++) {\r\nnicvf_update_sq_stats(nic, qidx);\r\nfor (stat = 0; stat < nicvf_n_queue_stats; stat++)\r\n*((*data)++) = ((u64 *)&nic->qs->sq[qidx].stats)\r\n[nicvf_queue_stats[stat].index];\r\n}\r\n}\r\nstatic void nicvf_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct nicvf *nic = netdev_priv(netdev);\r\nint stat, tmp_stats;\r\nint sqs, cpu;\r\nnicvf_update_stats(nic);\r\nnicvf_update_lmac_stats(nic);\r\nfor (stat = 0; stat < nicvf_n_hw_stats; stat++)\r\n*(data++) = ((u64 *)&nic->hw_stats)\r\n[nicvf_hw_stats[stat].index];\r\nfor (stat = 0; stat < nicvf_n_drv_stats; stat++) {\r\ntmp_stats = 0;\r\nfor_each_possible_cpu(cpu)\r\ntmp_stats += ((u64 *)per_cpu_ptr(nic->drv_stats, cpu))\r\n[nicvf_drv_stats[stat].index];\r\n*(data++) = tmp_stats;\r\n}\r\nnicvf_get_qset_stats(nic, stats, &data);\r\nfor (sqs = 0; sqs < nic->sqs_count; sqs++) {\r\nif (!nic->snicvf[sqs])\r\ncontinue;\r\nnicvf_get_qset_stats(nic->snicvf[sqs], stats, &data);\r\n}\r\nfor (stat = 0; stat < BGX_RX_STATS_COUNT; stat++)\r\n*(data++) = nic->bgx_stats.rx_stats[stat];\r\nfor (stat = 0; stat < BGX_TX_STATS_COUNT; stat++)\r\n*(data++) = nic->bgx_stats.tx_stats[stat];\r\n}\r\nstatic int nicvf_get_regs_len(struct net_device *dev)\r\n{\r\nreturn sizeof(u64) * NIC_VF_REG_COUNT;\r\n}\r\nstatic void nicvf_get_regs(struct net_device *dev,\r\nstruct ethtool_regs *regs, void *reg)\r\n{\r\nstruct nicvf *nic = netdev_priv(dev);\r\nu64 *p = (u64 *)reg;\r\nu64 reg_offset;\r\nint mbox, key, stat, q;\r\nint i = 0;\r\nregs->version = 0;\r\nmemset(p, 0, NIC_VF_REG_COUNT);\r\np[i++] = nicvf_reg_read(nic, NIC_VNIC_CFG);\r\nfor (mbox = 0; mbox < NIC_PF_VF_MAILBOX_SIZE; mbox++)\r\np[i++] = nicvf_reg_read(nic,\r\nNIC_VF_PF_MAILBOX_0_1 | (mbox << 3));\r\np[i++] = nicvf_reg_read(nic, NIC_VF_INT);\r\np[i++] = nicvf_reg_read(nic, NIC_VF_INT_W1S);\r\np[i++] = nicvf_reg_read(nic, NIC_VF_ENA_W1C);\r\np[i++] = nicvf_reg_read(nic, NIC_VF_ENA_W1S);\r\np[i++] = nicvf_reg_read(nic, NIC_VNIC_RSS_CFG);\r\nfor (key = 0; key < RSS_HASH_KEY_SIZE; key++)\r\np[i++] = nicvf_reg_read(nic, NIC_VNIC_RSS_KEY_0_4 | (key << 3));\r\nfor (stat = 0; stat < TX_STATS_ENUM_LAST; stat++)\r\np[i++] = nicvf_reg_read(nic,\r\nNIC_VNIC_TX_STAT_0_4 | (stat << 3));\r\nfor (i = 0; i < RX_STATS_ENUM_LAST; i++)\r\np[i++] = nicvf_reg_read(nic,\r\nNIC_VNIC_RX_STAT_0_13 | (stat << 3));\r\np[i++] = nicvf_reg_read(nic, NIC_QSET_RQ_GEN_CFG);\r\nfor (q = 0; q < MAX_CMP_QUEUES_PER_QS; q++) {\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_CFG, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_CFG2, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_THRESH, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_BASE, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_HEAD, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_TAIL, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_DOOR, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_STATUS, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_STATUS2, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_DEBUG, q);\r\n}\r\nfor (q = 0; q < MAX_RCV_QUEUES_PER_QS; q++) {\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_RQ_0_7_CFG, q);\r\np[i++] = nicvf_queue_reg_read(nic,\r\nNIC_QSET_RQ_0_7_STAT_0_1, q);\r\nreg_offset = NIC_QSET_RQ_0_7_STAT_0_1 | (1 << 3);\r\np[i++] = nicvf_queue_reg_read(nic, reg_offset, q);\r\n}\r\nfor (q = 0; q < MAX_SND_QUEUES_PER_QS; q++) {\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_CFG, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_THRESH, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_BASE, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_HEAD, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_TAIL, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_DOOR, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_STATUS, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_DEBUG, q);\r\np[i++] = 0;\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_STAT_0_1, q);\r\nreg_offset = NIC_QSET_SQ_0_7_STAT_0_1 | (1 << 3);\r\np[i++] = nicvf_queue_reg_read(nic, reg_offset, q);\r\n}\r\nfor (q = 0; q < MAX_RCV_BUF_DESC_RINGS_PER_QS; q++) {\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_CFG, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_THRESH, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_BASE, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_HEAD, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_TAIL, q);\r\np[i++] = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_DOOR, q);\r\np[i++] = nicvf_queue_reg_read(nic,\r\nNIC_QSET_RBDR_0_1_STATUS0, q);\r\np[i++] = nicvf_queue_reg_read(nic,\r\nNIC_QSET_RBDR_0_1_STATUS1, q);\r\nreg_offset = NIC_QSET_RBDR_0_1_PREFETCH_STATUS;\r\np[i++] = nicvf_queue_reg_read(nic, reg_offset, q);\r\n}\r\n}\r\nstatic int nicvf_get_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *cmd)\r\n{\r\nstruct nicvf *nic = netdev_priv(netdev);\r\ncmd->rx_coalesce_usecs = nic->cq_coalesce_usecs;\r\nreturn 0;\r\n}\r\nstatic void nicvf_get_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct nicvf *nic = netdev_priv(netdev);\r\nstruct queue_set *qs = nic->qs;\r\nring->rx_max_pending = MAX_CMP_QUEUE_LEN;\r\nring->rx_pending = qs->cq_len;\r\nring->tx_max_pending = MAX_SND_QUEUE_LEN;\r\nring->tx_pending = qs->sq_len;\r\n}\r\nstatic int nicvf_set_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct nicvf *nic = netdev_priv(netdev);\r\nstruct queue_set *qs = nic->qs;\r\nu32 rx_count, tx_count;\r\nif (pass1_silicon(nic->pdev))\r\nreturn -EINVAL;\r\nif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\r\nreturn -EINVAL;\r\ntx_count = clamp_t(u32, ring->tx_pending,\r\nMIN_SND_QUEUE_LEN, MAX_SND_QUEUE_LEN);\r\nrx_count = clamp_t(u32, ring->rx_pending,\r\nMIN_CMP_QUEUE_LEN, MAX_CMP_QUEUE_LEN);\r\nif ((tx_count == qs->sq_len) && (rx_count == qs->cq_len))\r\nreturn 0;\r\nqs->sq_len = rounddown_pow_of_two(tx_count);\r\nqs->cq_len = rounddown_pow_of_two(rx_count);\r\nif (netif_running(netdev)) {\r\nnicvf_stop(netdev);\r\nnicvf_open(netdev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int nicvf_get_rss_hash_opts(struct nicvf *nic,\r\nstruct ethtool_rxnfc *info)\r\n{\r\ninfo->data = 0;\r\nswitch (info->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncase TCP_V6_FLOW:\r\ncase UDP_V4_FLOW:\r\ncase UDP_V6_FLOW:\r\ncase SCTP_V4_FLOW:\r\ncase SCTP_V6_FLOW:\r\ninfo->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\ncase IPV4_FLOW:\r\ncase IPV6_FLOW:\r\ninfo->data |= RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nicvf_get_rxnfc(struct net_device *dev,\r\nstruct ethtool_rxnfc *info, u32 *rules)\r\n{\r\nstruct nicvf *nic = netdev_priv(dev);\r\nint ret = -EOPNOTSUPP;\r\nswitch (info->cmd) {\r\ncase ETHTOOL_GRXRINGS:\r\ninfo->data = nic->rx_queues;\r\nret = 0;\r\nbreak;\r\ncase ETHTOOL_GRXFH:\r\nreturn nicvf_get_rss_hash_opts(nic, info);\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int nicvf_set_rss_hash_opts(struct nicvf *nic,\r\nstruct ethtool_rxnfc *info)\r\n{\r\nstruct nicvf_rss_info *rss = &nic->rss_info;\r\nu64 rss_cfg = nicvf_reg_read(nic, NIC_VNIC_RSS_CFG);\r\nif (!rss->enable)\r\nnetdev_err(nic->netdev,\r\n"RSS is disabled, hash cannot be set\n");\r\nnetdev_info(nic->netdev, "Set RSS flow type = %d, data = %lld\n",\r\ninfo->flow_type, info->data);\r\nif (!(info->data & RXH_IP_SRC) || !(info->data & RXH_IP_DST))\r\nreturn -EINVAL;\r\nswitch (info->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncase TCP_V6_FLOW:\r\nswitch (info->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\r\ncase 0:\r\nrss_cfg &= ~(1ULL << RSS_HASH_TCP);\r\nbreak;\r\ncase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\r\nrss_cfg |= (1ULL << RSS_HASH_TCP);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase UDP_V4_FLOW:\r\ncase UDP_V6_FLOW:\r\nswitch (info->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\r\ncase 0:\r\nrss_cfg &= ~(1ULL << RSS_HASH_UDP);\r\nbreak;\r\ncase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\r\nrss_cfg |= (1ULL << RSS_HASH_UDP);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SCTP_V4_FLOW:\r\ncase SCTP_V6_FLOW:\r\nswitch (info->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\r\ncase 0:\r\nrss_cfg &= ~(1ULL << RSS_HASH_L4ETC);\r\nbreak;\r\ncase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\r\nrss_cfg |= (1ULL << RSS_HASH_L4ETC);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase IPV4_FLOW:\r\ncase IPV6_FLOW:\r\nrss_cfg = RSS_HASH_IP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nnicvf_reg_write(nic, NIC_VNIC_RSS_CFG, rss_cfg);\r\nreturn 0;\r\n}\r\nstatic int nicvf_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info)\r\n{\r\nstruct nicvf *nic = netdev_priv(dev);\r\nswitch (info->cmd) {\r\ncase ETHTOOL_SRXFH:\r\nreturn nicvf_set_rss_hash_opts(nic, info);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic u32 nicvf_get_rxfh_key_size(struct net_device *netdev)\r\n{\r\nreturn RSS_HASH_KEY_SIZE * sizeof(u64);\r\n}\r\nstatic u32 nicvf_get_rxfh_indir_size(struct net_device *dev)\r\n{\r\nstruct nicvf *nic = netdev_priv(dev);\r\nreturn nic->rss_info.rss_size;\r\n}\r\nstatic int nicvf_get_rxfh(struct net_device *dev, u32 *indir, u8 *hkey,\r\nu8 *hfunc)\r\n{\r\nstruct nicvf *nic = netdev_priv(dev);\r\nstruct nicvf_rss_info *rss = &nic->rss_info;\r\nint idx;\r\nif (indir) {\r\nfor (idx = 0; idx < rss->rss_size; idx++)\r\nindir[idx] = rss->ind_tbl[idx];\r\n}\r\nif (hkey)\r\nmemcpy(hkey, rss->key, RSS_HASH_KEY_SIZE * sizeof(u64));\r\nif (hfunc)\r\n*hfunc = ETH_RSS_HASH_TOP;\r\nreturn 0;\r\n}\r\nstatic int nicvf_set_rxfh(struct net_device *dev, const u32 *indir,\r\nconst u8 *hkey, const u8 hfunc)\r\n{\r\nstruct nicvf *nic = netdev_priv(dev);\r\nstruct nicvf_rss_info *rss = &nic->rss_info;\r\nint idx;\r\nif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\r\nreturn -EOPNOTSUPP;\r\nif (!rss->enable) {\r\nnetdev_err(nic->netdev,\r\n"RSS is disabled, cannot change settings\n");\r\nreturn -EIO;\r\n}\r\nif (indir) {\r\nfor (idx = 0; idx < rss->rss_size; idx++)\r\nrss->ind_tbl[idx] = indir[idx];\r\n}\r\nif (hkey) {\r\nmemcpy(rss->key, hkey, RSS_HASH_KEY_SIZE * sizeof(u64));\r\nnicvf_set_rss_key(nic);\r\n}\r\nnicvf_config_rss(nic);\r\nreturn 0;\r\n}\r\nstatic void nicvf_get_channels(struct net_device *dev,\r\nstruct ethtool_channels *channel)\r\n{\r\nstruct nicvf *nic = netdev_priv(dev);\r\nmemset(channel, 0, sizeof(*channel));\r\nchannel->max_rx = nic->max_queues;\r\nchannel->max_tx = nic->max_queues;\r\nchannel->rx_count = nic->rx_queues;\r\nchannel->tx_count = nic->tx_queues;\r\n}\r\nstatic int nicvf_set_channels(struct net_device *dev,\r\nstruct ethtool_channels *channel)\r\n{\r\nstruct nicvf *nic = netdev_priv(dev);\r\nint err = 0;\r\nbool if_up = netif_running(dev);\r\nu8 cqcount, txq_count;\r\nif (!channel->rx_count || !channel->tx_count)\r\nreturn -EINVAL;\r\nif (channel->rx_count > nic->max_queues)\r\nreturn -EINVAL;\r\nif (channel->tx_count > nic->max_queues)\r\nreturn -EINVAL;\r\nif (nic->xdp_prog &&\r\n((channel->tx_count + channel->rx_count) > nic->max_queues)) {\r\nnetdev_err(nic->netdev,\r\n"XDP mode, RXQs + TXQs > Max %d\n",\r\nnic->max_queues);\r\nreturn -EINVAL;\r\n}\r\nif (if_up)\r\nnicvf_stop(dev);\r\nnic->rx_queues = channel->rx_count;\r\nnic->tx_queues = channel->tx_count;\r\nif (!nic->xdp_prog)\r\nnic->xdp_tx_queues = 0;\r\nelse\r\nnic->xdp_tx_queues = channel->rx_count;\r\ntxq_count = nic->xdp_tx_queues + nic->tx_queues;\r\ncqcount = max(nic->rx_queues, txq_count);\r\nif (cqcount > MAX_CMP_QUEUES_PER_QS) {\r\nnic->sqs_count = roundup(cqcount, MAX_CMP_QUEUES_PER_QS);\r\nnic->sqs_count = (nic->sqs_count / MAX_CMP_QUEUES_PER_QS) - 1;\r\n} else {\r\nnic->sqs_count = 0;\r\n}\r\nnic->qs->rq_cnt = min_t(u8, nic->rx_queues, MAX_RCV_QUEUES_PER_QS);\r\nnic->qs->sq_cnt = min_t(u8, txq_count, MAX_SND_QUEUES_PER_QS);\r\nnic->qs->cq_cnt = max(nic->qs->rq_cnt, nic->qs->sq_cnt);\r\nerr = nicvf_set_real_num_queues(dev, nic->tx_queues, nic->rx_queues);\r\nif (err)\r\nreturn err;\r\nif (if_up)\r\nnicvf_open(dev);\r\nnetdev_info(dev, "Setting num Tx rings to %d, Rx rings to %d success\n",\r\nnic->tx_queues, nic->rx_queues);\r\nreturn err;\r\n}\r\nstatic void nicvf_get_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct nicvf *nic = netdev_priv(dev);\r\nunion nic_mbx mbx = {};\r\nif ((nic->mac_type == BGX_MODE_SGMII) ||\r\n(nic->mac_type == BGX_MODE_QSGMII) ||\r\n(nic->mac_type == BGX_MODE_RGMII))\r\nreturn;\r\nmbx.pfc.msg = NIC_MBOX_MSG_PFC;\r\nmbx.pfc.get = 1;\r\nif (!nicvf_send_msg_to_pf(nic, &mbx)) {\r\npause->autoneg = nic->pfc.autoneg;\r\npause->rx_pause = nic->pfc.fc_rx;\r\npause->tx_pause = nic->pfc.fc_tx;\r\n}\r\n}\r\nstatic int nicvf_set_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct nicvf *nic = netdev_priv(dev);\r\nunion nic_mbx mbx = {};\r\nif ((nic->mac_type == BGX_MODE_SGMII) ||\r\n(nic->mac_type == BGX_MODE_QSGMII) ||\r\n(nic->mac_type == BGX_MODE_RGMII))\r\nreturn -EOPNOTSUPP;\r\nif (pause->autoneg)\r\nreturn -EOPNOTSUPP;\r\nmbx.pfc.msg = NIC_MBOX_MSG_PFC;\r\nmbx.pfc.get = 0;\r\nmbx.pfc.fc_rx = pause->rx_pause;\r\nmbx.pfc.fc_tx = pause->tx_pause;\r\nif (nicvf_send_msg_to_pf(nic, &mbx))\r\nreturn -EAGAIN;\r\nnic->pfc.fc_rx = pause->rx_pause;\r\nnic->pfc.fc_tx = pause->tx_pause;\r\nreturn 0;\r\n}\r\nvoid nicvf_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nnetdev->ethtool_ops = &nicvf_ethtool_ops;\r\n}
