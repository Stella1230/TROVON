void ulist_init(struct ulist *ulist)\r\n{\r\nINIT_LIST_HEAD(&ulist->nodes);\r\nulist->root = RB_ROOT;\r\nulist->nnodes = 0;\r\n}\r\nvoid ulist_release(struct ulist *ulist)\r\n{\r\nstruct ulist_node *node;\r\nstruct ulist_node *next;\r\nlist_for_each_entry_safe(node, next, &ulist->nodes, list) {\r\nkfree(node);\r\n}\r\nulist->root = RB_ROOT;\r\nINIT_LIST_HEAD(&ulist->nodes);\r\n}\r\nvoid ulist_reinit(struct ulist *ulist)\r\n{\r\nulist_release(ulist);\r\nulist_init(ulist);\r\n}\r\nstruct ulist *ulist_alloc(gfp_t gfp_mask)\r\n{\r\nstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\r\nif (!ulist)\r\nreturn NULL;\r\nulist_init(ulist);\r\nreturn ulist;\r\n}\r\nvoid ulist_free(struct ulist *ulist)\r\n{\r\nif (!ulist)\r\nreturn;\r\nulist_release(ulist);\r\nkfree(ulist);\r\n}\r\nstatic struct ulist_node *ulist_rbtree_search(struct ulist *ulist, u64 val)\r\n{\r\nstruct rb_node *n = ulist->root.rb_node;\r\nstruct ulist_node *u = NULL;\r\nwhile (n) {\r\nu = rb_entry(n, struct ulist_node, rb_node);\r\nif (u->val < val)\r\nn = n->rb_right;\r\nelse if (u->val > val)\r\nn = n->rb_left;\r\nelse\r\nreturn u;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ulist_rbtree_erase(struct ulist *ulist, struct ulist_node *node)\r\n{\r\nrb_erase(&node->rb_node, &ulist->root);\r\nlist_del(&node->list);\r\nkfree(node);\r\nBUG_ON(ulist->nnodes == 0);\r\nulist->nnodes--;\r\n}\r\nstatic int ulist_rbtree_insert(struct ulist *ulist, struct ulist_node *ins)\r\n{\r\nstruct rb_node **p = &ulist->root.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct ulist_node *cur = NULL;\r\nwhile (*p) {\r\nparent = *p;\r\ncur = rb_entry(parent, struct ulist_node, rb_node);\r\nif (cur->val < ins->val)\r\np = &(*p)->rb_right;\r\nelse if (cur->val > ins->val)\r\np = &(*p)->rb_left;\r\nelse\r\nreturn -EEXIST;\r\n}\r\nrb_link_node(&ins->rb_node, parent, p);\r\nrb_insert_color(&ins->rb_node, &ulist->root);\r\nreturn 0;\r\n}\r\nint ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\r\n{\r\nreturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\r\n}\r\nint ulist_add_merge(struct ulist *ulist, u64 val, u64 aux,\r\nu64 *old_aux, gfp_t gfp_mask)\r\n{\r\nint ret;\r\nstruct ulist_node *node;\r\nnode = ulist_rbtree_search(ulist, val);\r\nif (node) {\r\nif (old_aux)\r\n*old_aux = node->aux;\r\nreturn 0;\r\n}\r\nnode = kmalloc(sizeof(*node), gfp_mask);\r\nif (!node)\r\nreturn -ENOMEM;\r\nnode->val = val;\r\nnode->aux = aux;\r\nret = ulist_rbtree_insert(ulist, node);\r\nASSERT(!ret);\r\nlist_add_tail(&node->list, &ulist->nodes);\r\nulist->nnodes++;\r\nreturn 1;\r\n}\r\nint ulist_del(struct ulist *ulist, u64 val, u64 aux)\r\n{\r\nstruct ulist_node *node;\r\nnode = ulist_rbtree_search(ulist, val);\r\nif (!node)\r\nreturn 1;\r\nif (node->aux != aux)\r\nreturn 1;\r\nulist_rbtree_erase(ulist, node);\r\nreturn 0;\r\n}\r\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\r\n{\r\nstruct ulist_node *node;\r\nif (list_empty(&ulist->nodes))\r\nreturn NULL;\r\nif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\r\nreturn NULL;\r\nif (uiter->cur_list) {\r\nuiter->cur_list = uiter->cur_list->next;\r\n} else {\r\nuiter->cur_list = ulist->nodes.next;\r\n}\r\nnode = list_entry(uiter->cur_list, struct ulist_node, list);\r\nreturn node;\r\n}
