static void iproc_adc_reg_dump(struct iio_dev *indio_dev)\r\n{\r\nstruct device *dev = &indio_dev->dev;\r\nstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\r\niproc_adc_dbg_reg(dev, adc_priv, IPROC_REGCTL1);\r\niproc_adc_dbg_reg(dev, adc_priv, IPROC_REGCTL2);\r\niproc_adc_dbg_reg(dev, adc_priv, IPROC_INTERRUPT_THRES);\r\niproc_adc_dbg_reg(dev, adc_priv, IPROC_INTERRUPT_MASK);\r\niproc_adc_dbg_reg(dev, adc_priv, IPROC_INTERRUPT_STATUS);\r\niproc_adc_dbg_reg(dev, adc_priv, IPROC_CONTROLLER_STATUS);\r\niproc_adc_dbg_reg(dev, adc_priv, IPROC_ANALOG_CONTROL);\r\niproc_adc_dbg_reg(dev, adc_priv, IPROC_AUX_DATA);\r\niproc_adc_dbg_reg(dev, adc_priv, IPROC_SOFT_BYPASS_CONTROL);\r\niproc_adc_dbg_reg(dev, adc_priv, IPROC_SOFT_BYPASS_DATA);\r\n}\r\nstatic irqreturn_t iproc_adc_interrupt_thread(int irq, void *data)\r\n{\r\nu32 channel_intr_status;\r\nu32 intr_status;\r\nu32 intr_mask;\r\nstruct iio_dev *indio_dev = data;\r\nstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\r\nregmap_read(adc_priv->regmap, IPROC_INTERRUPT_STATUS, &intr_status);\r\nregmap_read(adc_priv->regmap, IPROC_INTERRUPT_MASK, &intr_mask);\r\nintr_status = intr_status & intr_mask;\r\nchannel_intr_status = (intr_status & IPROC_ADC_INTR_MASK) >>\r\nIPROC_ADC_INTR;\r\nif (channel_intr_status)\r\nreturn IRQ_WAKE_THREAD;\r\nreturn IRQ_NONE;\r\n}\r\nstatic irqreturn_t iproc_adc_interrupt_handler(int irq, void *data)\r\n{\r\nirqreturn_t retval = IRQ_NONE;\r\nstruct iproc_adc_priv *adc_priv;\r\nstruct iio_dev *indio_dev = data;\r\nunsigned int valid_entries;\r\nu32 intr_status;\r\nu32 intr_channels;\r\nu32 channel_status;\r\nu32 ch_intr_status;\r\nadc_priv = iio_priv(indio_dev);\r\nregmap_read(adc_priv->regmap, IPROC_INTERRUPT_STATUS, &intr_status);\r\ndev_dbg(&indio_dev->dev, "iproc_adc_interrupt_handler(),INTRPT_STS:%x\n",\r\nintr_status);\r\nintr_channels = (intr_status & IPROC_ADC_INTR_MASK) >> IPROC_ADC_INTR;\r\nif (intr_channels) {\r\nregmap_read(adc_priv->regmap,\r\nIPROC_ADC_CHANNEL_INTERRUPT_STATUS +\r\nIPROC_ADC_CHANNEL_OFFSET * adc_priv->chan_id,\r\n&ch_intr_status);\r\nif (ch_intr_status & IPROC_ADC_CHANNEL_WTRMRK_INTR_MASK) {\r\nregmap_read(adc_priv->regmap,\r\nIPROC_ADC_CHANNEL_STATUS +\r\nIPROC_ADC_CHANNEL_OFFSET *\r\nadc_priv->chan_id,\r\n&channel_status);\r\nvalid_entries = ((channel_status &\r\nIPROC_ADC_CHANNEL_VALID_ENTERIES_MASK) >>\r\nIPROC_ADC_CHANNEL_VALID_ENTERIES);\r\nif (valid_entries >= 1) {\r\nregmap_read(adc_priv->regmap,\r\nIPROC_ADC_CHANNEL_DATA +\r\nIPROC_ADC_CHANNEL_OFFSET *\r\nadc_priv->chan_id,\r\n&adc_priv->chan_val);\r\ncomplete(&adc_priv->completion);\r\n} else {\r\ndev_err(&indio_dev->dev,\r\n"No data rcvd on channel %d\n",\r\nadc_priv->chan_id);\r\n}\r\nregmap_write(adc_priv->regmap,\r\nIPROC_ADC_CHANNEL_INTERRUPT_MASK +\r\nIPROC_ADC_CHANNEL_OFFSET *\r\nadc_priv->chan_id,\r\n(ch_intr_status &\r\n~(IPROC_ADC_CHANNEL_WTRMRK_INTR_MASK)));\r\n}\r\nregmap_write(adc_priv->regmap,\r\nIPROC_ADC_CHANNEL_INTERRUPT_STATUS +\r\nIPROC_ADC_CHANNEL_OFFSET * adc_priv->chan_id,\r\nch_intr_status);\r\nregmap_write(adc_priv->regmap, IPROC_INTERRUPT_STATUS,\r\nintr_channels);\r\nretval = IRQ_HANDLED;\r\n}\r\nreturn retval;\r\n}\r\nstatic int iproc_adc_do_read(struct iio_dev *indio_dev,\r\nint channel,\r\nu16 *p_adc_data)\r\n{\r\nint read_len = 0;\r\nu32 val;\r\nu32 mask;\r\nu32 val_check;\r\nint failed_cnt = 0;\r\nstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\r\nmutex_lock(&adc_priv->mutex);\r\nadc_priv->chan_val = -1;\r\nadc_priv->chan_id = channel;\r\nreinit_completion(&adc_priv->completion);\r\nregmap_update_bits(adc_priv->regmap, IPROC_INTERRUPT_STATUS,\r\nIPROC_ADC_INTR_MASK | IPROC_ADC_AUXDATA_RDY_INTR,\r\n((0x0 << channel) << IPROC_ADC_INTR) |\r\nIPROC_ADC_AUXDATA_RDY_INTR);\r\nval = (BIT(IPROC_ADC_CHANNEL_ROUNDS) |\r\n(IPROC_ADC_CHANNEL_MODE_SNAPSHOT << IPROC_ADC_CHANNEL_MODE) |\r\n(0x1 << IPROC_ADC_CHANNEL_ENABLE));\r\nmask = IPROC_ADC_CHANNEL_ROUNDS_MASK | IPROC_ADC_CHANNEL_MODE_MASK |\r\nIPROC_ADC_CHANNEL_ENABLE_MASK;\r\nregmap_update_bits(adc_priv->regmap, (IPROC_ADC_CHANNEL_REGCTL1 +\r\nIPROC_ADC_CHANNEL_OFFSET * channel),\r\nmask, val);\r\nregmap_update_bits(adc_priv->regmap, (IPROC_ADC_CHANNEL_REGCTL2 +\r\nIPROC_ADC_CHANNEL_OFFSET * channel),\r\nIPROC_ADC_CHANNEL_WATERMARK_MASK,\r\n0x1);\r\nregmap_update_bits(adc_priv->regmap, (IPROC_ADC_CHANNEL_INTERRUPT_MASK +\r\nIPROC_ADC_CHANNEL_OFFSET *\r\nchannel),\r\nIPROC_ADC_CHANNEL_WTRMRK_INTR_MASK,\r\nIPROC_ADC_WATER_MARK_INTR_ENABLE);\r\nregmap_read(adc_priv->regmap, IPROC_INTERRUPT_MASK, &val);\r\nval |= (BIT(channel) << IPROC_ADC_INTR);\r\nregmap_write(adc_priv->regmap, IPROC_INTERRUPT_MASK, val);\r\nregmap_read(adc_priv->regmap, IPROC_INTERRUPT_MASK, &val_check);\r\nwhile (val_check != val) {\r\nfailed_cnt++;\r\nif (failed_cnt > IPROC_ADC_INTMASK_RETRY_ATTEMPTS)\r\nbreak;\r\nudelay(10);\r\nregmap_update_bits(adc_priv->regmap, IPROC_INTERRUPT_MASK,\r\nIPROC_ADC_INTR_MASK,\r\n((0x1 << channel) <<\r\nIPROC_ADC_INTR));\r\nregmap_read(adc_priv->regmap, IPROC_INTERRUPT_MASK, &val_check);\r\n}\r\nif (failed_cnt) {\r\ndev_dbg(&indio_dev->dev,\r\n"IntMask failed (%d times)", failed_cnt);\r\nif (failed_cnt > IPROC_ADC_INTMASK_RETRY_ATTEMPTS) {\r\ndev_err(&indio_dev->dev,\r\n"IntMask set failed. Read will likely fail.");\r\nread_len = -EIO;\r\ngoto adc_err;\r\n};\r\n}\r\nregmap_read(adc_priv->regmap, IPROC_INTERRUPT_MASK, &val_check);\r\nif (wait_for_completion_timeout(&adc_priv->completion,\r\nIPROC_ADC_READ_TIMEOUT) > 0) {\r\n*p_adc_data = adc_priv->chan_val & 0xFFFF;\r\nread_len = sizeof(*p_adc_data);\r\n} else {\r\nread_len = -ETIMEDOUT;\r\ngoto adc_err;\r\n}\r\nmutex_unlock(&adc_priv->mutex);\r\nreturn read_len;\r\nadc_err:\r\nregmap_update_bits(adc_priv->regmap, IPROC_INTERRUPT_MASK,\r\nIPROC_ADC_INTR_MASK,\r\n((0x0 << channel) << IPROC_ADC_INTR));\r\nregmap_update_bits(adc_priv->regmap, IPROC_INTERRUPT_STATUS,\r\nIPROC_ADC_INTR_MASK,\r\n((0x0 << channel) << IPROC_ADC_INTR));\r\ndev_err(&indio_dev->dev, "Timed out waiting for ADC data!\n");\r\niproc_adc_reg_dump(indio_dev);\r\nmutex_unlock(&adc_priv->mutex);\r\nreturn read_len;\r\n}\r\nstatic int iproc_adc_enable(struct iio_dev *indio_dev)\r\n{\r\nu32 val;\r\nu32 channel_id;\r\nstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\r\nint ret;\r\nret = regmap_update_bits(adc_priv->regmap, IPROC_ANALOG_CONTROL,\r\nIPROC_ADC_CHANNEL_SEL_MASK, 0);\r\nif (ret) {\r\ndev_err(&indio_dev->dev,\r\n"failed to write IPROC_ANALOG_CONTROL %d\n", ret);\r\nreturn ret;\r\n}\r\nadc_priv->chan_val = -1;\r\nret = regmap_read(adc_priv->regmap, IPROC_REGCTL2, &val);\r\nif (ret) {\r\ndev_err(&indio_dev->dev,\r\n"failed to read IPROC_REGCTL2 %d\n", ret);\r\nreturn ret;\r\n}\r\nval &= ~(IPROC_ADC_PWR_LDO | IPROC_ADC_PWR_ADC | IPROC_ADC_PWR_BG);\r\nret = regmap_write(adc_priv->regmap, IPROC_REGCTL2, val);\r\nif (ret) {\r\ndev_err(&indio_dev->dev,\r\n"failed to write IPROC_REGCTL2 %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(adc_priv->regmap, IPROC_REGCTL2, &val);\r\nif (ret) {\r\ndev_err(&indio_dev->dev,\r\n"failed to read IPROC_REGCTL2 %d\n", ret);\r\nreturn ret;\r\n}\r\nval |= IPROC_ADC_CONTROLLER_EN;\r\nret = regmap_write(adc_priv->regmap, IPROC_REGCTL2, val);\r\nif (ret) {\r\ndev_err(&indio_dev->dev,\r\n"failed to write IPROC_REGCTL2 %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (channel_id = 0; channel_id < indio_dev->num_channels;\r\nchannel_id++) {\r\nret = regmap_write(adc_priv->regmap,\r\nIPROC_ADC_CHANNEL_INTERRUPT_MASK +\r\nIPROC_ADC_CHANNEL_OFFSET * channel_id, 0);\r\nif (ret) {\r\ndev_err(&indio_dev->dev,\r\n"failed to write ADC_CHANNEL_INTERRUPT_MASK %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = regmap_write(adc_priv->regmap,\r\nIPROC_ADC_CHANNEL_INTERRUPT_STATUS +\r\nIPROC_ADC_CHANNEL_OFFSET * channel_id, 0);\r\nif (ret) {\r\ndev_err(&indio_dev->dev,\r\n"failed to write ADC_CHANNEL_INTERRUPT_STATUS %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void iproc_adc_disable(struct iio_dev *indio_dev)\r\n{\r\nu32 val;\r\nint ret;\r\nstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\r\nret = regmap_read(adc_priv->regmap, IPROC_REGCTL2, &val);\r\nif (ret) {\r\ndev_err(&indio_dev->dev,\r\n"failed to read IPROC_REGCTL2 %d\n", ret);\r\nreturn;\r\n}\r\nval &= ~IPROC_ADC_CONTROLLER_EN;\r\nret = regmap_write(adc_priv->regmap, IPROC_REGCTL2, val);\r\nif (ret) {\r\ndev_err(&indio_dev->dev,\r\n"failed to write IPROC_REGCTL2 %d\n", ret);\r\nreturn;\r\n}\r\n}\r\nstatic int iproc_adc_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong mask)\r\n{\r\nu16 adc_data;\r\nint err;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nerr = iproc_adc_do_read(indio_dev, chan->channel, &adc_data);\r\nif (err < 0)\r\nreturn err;\r\n*val = adc_data;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_VOLTAGE:\r\n*val = 1800;\r\n*val2 = 10;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int iproc_adc_probe(struct platform_device *pdev)\r\n{\r\nstruct iproc_adc_priv *adc_priv;\r\nstruct iio_dev *indio_dev = NULL;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev,\r\nsizeof(*adc_priv));\r\nif (!indio_dev) {\r\ndev_err(&pdev->dev, "failed to allocate iio device\n");\r\nreturn -ENOMEM;\r\n}\r\nadc_priv = iio_priv(indio_dev);\r\nplatform_set_drvdata(pdev, indio_dev);\r\nmutex_init(&adc_priv->mutex);\r\ninit_completion(&adc_priv->completion);\r\nadc_priv->regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"adc-syscon");\r\nif (IS_ERR(adc_priv->regmap)) {\r\ndev_err(&pdev->dev, "failed to get handle for tsc syscon\n");\r\nret = PTR_ERR(adc_priv->regmap);\r\nreturn ret;\r\n}\r\nadc_priv->adc_clk = devm_clk_get(&pdev->dev, "tsc_clk");\r\nif (IS_ERR(adc_priv->adc_clk)) {\r\ndev_err(&pdev->dev,\r\n"failed getting clock tsc_clk\n");\r\nret = PTR_ERR(adc_priv->adc_clk);\r\nreturn ret;\r\n}\r\nadc_priv->irqno = platform_get_irq(pdev, 0);\r\nif (adc_priv->irqno <= 0) {\r\ndev_err(&pdev->dev, "platform_get_irq failed\n");\r\nret = -ENODEV;\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(adc_priv->regmap, IPROC_REGCTL2,\r\nIPROC_ADC_AUXIN_SCAN_ENA, 0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to write IPROC_REGCTL2 %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, adc_priv->irqno,\r\niproc_adc_interrupt_handler,\r\niproc_adc_interrupt_thread,\r\nIRQF_SHARED, "iproc-adc", indio_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "request_irq error %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(adc_priv->adc_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"clk_prepare_enable failed %d\n", ret);\r\nreturn ret;\r\n}\r\nret = iproc_adc_enable(indio_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable adc %d\n", ret);\r\ngoto err_adc_enable;\r\n}\r\nindio_dev->name = "iproc-static-adc";\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->dev.of_node = pdev->dev.of_node;\r\nindio_dev->info = &iproc_adc_iio_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = iproc_adc_iio_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(iproc_adc_iio_channels);\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "iio_device_register failed:err %d\n", ret);\r\ngoto err_clk;\r\n}\r\nreturn 0;\r\nerr_clk:\r\niproc_adc_disable(indio_dev);\r\nerr_adc_enable:\r\nclk_disable_unprepare(adc_priv->adc_clk);\r\nreturn ret;\r\n}\r\nstatic int iproc_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct iproc_adc_priv *adc_priv = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\niproc_adc_disable(indio_dev);\r\nclk_disable_unprepare(adc_priv->adc_clk);\r\nreturn 0;\r\n}
