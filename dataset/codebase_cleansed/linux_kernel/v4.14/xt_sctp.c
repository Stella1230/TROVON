static bool\r\nmatch_flags(const struct xt_sctp_flag_info *flag_info,\r\nconst int flag_count,\r\nu_int8_t chunktype,\r\nu_int8_t chunkflags)\r\n{\r\nint i;\r\nfor (i = 0; i < flag_count; i++)\r\nif (flag_info[i].chunktype == chunktype)\r\nreturn (chunkflags & flag_info[i].flag_mask) == flag_info[i].flag;\r\nreturn true;\r\n}\r\nstatic inline bool\r\nmatch_packet(const struct sk_buff *skb,\r\nunsigned int offset,\r\nconst struct xt_sctp_info *info,\r\nbool *hotdrop)\r\n{\r\nu_int32_t chunkmapcopy[256 / sizeof (u_int32_t)];\r\nconst struct sctp_chunkhdr *sch;\r\nstruct sctp_chunkhdr _sch;\r\nint chunk_match_type = info->chunk_match_type;\r\nconst struct xt_sctp_flag_info *flag_info = info->flag_info;\r\nint flag_count = info->flag_count;\r\n#ifdef DEBUG\r\nint i = 0;\r\n#endif\r\nif (chunk_match_type == SCTP_CHUNK_MATCH_ALL)\r\nSCTP_CHUNKMAP_COPY(chunkmapcopy, info->chunkmap);\r\ndo {\r\nsch = skb_header_pointer(skb, offset, sizeof(_sch), &_sch);\r\nif (sch == NULL || sch->length == 0) {\r\npr_debug("Dropping invalid SCTP packet.\n");\r\n*hotdrop = true;\r\nreturn false;\r\n}\r\n#ifdef DEBUG\r\npr_debug("Chunk num: %d\toffset: %d\ttype: %d\tlength: %d"\r\n"\tflags: %x\n",\r\n++i, offset, sch->type, htons(sch->length),\r\nsch->flags);\r\n#endif\r\noffset += SCTP_PAD4(ntohs(sch->length));\r\npr_debug("skb->len: %d\toffset: %d\n", skb->len, offset);\r\nif (SCTP_CHUNKMAP_IS_SET(info->chunkmap, sch->type)) {\r\nswitch (chunk_match_type) {\r\ncase SCTP_CHUNK_MATCH_ANY:\r\nif (match_flags(flag_info, flag_count,\r\nsch->type, sch->flags)) {\r\nreturn true;\r\n}\r\nbreak;\r\ncase SCTP_CHUNK_MATCH_ALL:\r\nif (match_flags(flag_info, flag_count,\r\nsch->type, sch->flags))\r\nSCTP_CHUNKMAP_CLEAR(chunkmapcopy, sch->type);\r\nbreak;\r\ncase SCTP_CHUNK_MATCH_ONLY:\r\nif (!match_flags(flag_info, flag_count,\r\nsch->type, sch->flags))\r\nreturn false;\r\nbreak;\r\n}\r\n} else {\r\nswitch (chunk_match_type) {\r\ncase SCTP_CHUNK_MATCH_ONLY:\r\nreturn false;\r\n}\r\n}\r\n} while (offset < skb->len);\r\nswitch (chunk_match_type) {\r\ncase SCTP_CHUNK_MATCH_ALL:\r\nreturn SCTP_CHUNKMAP_IS_CLEAR(chunkmapcopy);\r\ncase SCTP_CHUNK_MATCH_ANY:\r\nreturn false;\r\ncase SCTP_CHUNK_MATCH_ONLY:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool\r\nsctp_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_sctp_info *info = par->matchinfo;\r\nconst struct sctphdr *sh;\r\nstruct sctphdr _sh;\r\nif (par->fragoff != 0) {\r\npr_debug("Dropping non-first fragment.. FIXME\n");\r\nreturn false;\r\n}\r\nsh = skb_header_pointer(skb, par->thoff, sizeof(_sh), &_sh);\r\nif (sh == NULL) {\r\npr_debug("Dropping evil TCP offset=0 tinygram.\n");\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\npr_debug("spt: %d\tdpt: %d\n", ntohs(sh->source), ntohs(sh->dest));\r\nreturn SCCHECK(ntohs(sh->source) >= info->spts[0]\r\n&& ntohs(sh->source) <= info->spts[1],\r\nXT_SCTP_SRC_PORTS, info->flags, info->invflags) &&\r\nSCCHECK(ntohs(sh->dest) >= info->dpts[0]\r\n&& ntohs(sh->dest) <= info->dpts[1],\r\nXT_SCTP_DEST_PORTS, info->flags, info->invflags) &&\r\nSCCHECK(match_packet(skb, par->thoff + sizeof(_sh),\r\ninfo, &par->hotdrop),\r\nXT_SCTP_CHUNK_TYPES, info->flags, info->invflags);\r\n}\r\nstatic int sctp_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_sctp_info *info = par->matchinfo;\r\nif (info->flags & ~XT_SCTP_VALID_FLAGS)\r\nreturn -EINVAL;\r\nif (info->invflags & ~XT_SCTP_VALID_FLAGS)\r\nreturn -EINVAL;\r\nif (info->invflags & ~info->flags)\r\nreturn -EINVAL;\r\nif (!(info->flags & XT_SCTP_CHUNK_TYPES))\r\nreturn 0;\r\nif (info->chunk_match_type & (SCTP_CHUNK_MATCH_ALL |\r\nSCTP_CHUNK_MATCH_ANY | SCTP_CHUNK_MATCH_ONLY))\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int __init sctp_mt_init(void)\r\n{\r\nreturn xt_register_matches(sctp_mt_reg, ARRAY_SIZE(sctp_mt_reg));\r\n}\r\nstatic void __exit sctp_mt_exit(void)\r\n{\r\nxt_unregister_matches(sctp_mt_reg, ARRAY_SIZE(sctp_mt_reg));\r\n}
