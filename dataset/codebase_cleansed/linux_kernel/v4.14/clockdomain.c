static struct clockdomain *_clkdm_lookup(const char *name)\r\n{\r\nstruct clockdomain *clkdm, *temp_clkdm;\r\nif (!name)\r\nreturn NULL;\r\nclkdm = NULL;\r\nlist_for_each_entry(temp_clkdm, &clkdm_list, node) {\r\nif (!strcmp(name, temp_clkdm->name)) {\r\nclkdm = temp_clkdm;\r\nbreak;\r\n}\r\n}\r\nreturn clkdm;\r\n}\r\nstatic int _clkdm_register(struct clockdomain *clkdm)\r\n{\r\nstruct powerdomain *pwrdm;\r\nif (!clkdm || !clkdm->name)\r\nreturn -EINVAL;\r\npwrdm = pwrdm_lookup(clkdm->pwrdm.name);\r\nif (!pwrdm) {\r\npr_err("clockdomain: %s: powerdomain %s does not exist\n",\r\nclkdm->name, clkdm->pwrdm.name);\r\nreturn -EINVAL;\r\n}\r\nclkdm->pwrdm.ptr = pwrdm;\r\nif (_clkdm_lookup(clkdm->name))\r\nreturn -EEXIST;\r\nlist_add(&clkdm->node, &clkdm_list);\r\npwrdm_add_clkdm(pwrdm, clkdm);\r\npr_debug("clockdomain: registered %s\n", clkdm->name);\r\nreturn 0;\r\n}\r\nstatic struct clkdm_dep *_clkdm_deps_lookup(struct clockdomain *clkdm,\r\nstruct clkdm_dep *deps)\r\n{\r\nstruct clkdm_dep *cd;\r\nif (!clkdm || !deps)\r\nreturn ERR_PTR(-EINVAL);\r\nfor (cd = deps; cd->clkdm_name; cd++) {\r\nif (!cd->clkdm && cd->clkdm_name)\r\ncd->clkdm = _clkdm_lookup(cd->clkdm_name);\r\nif (cd->clkdm == clkdm)\r\nbreak;\r\n}\r\nif (!cd->clkdm_name)\r\nreturn ERR_PTR(-ENOENT);\r\nreturn cd;\r\n}\r\nstatic void _autodep_lookup(struct clkdm_autodep *autodep)\r\n{\r\nstruct clockdomain *clkdm;\r\nif (!autodep)\r\nreturn;\r\nclkdm = clkdm_lookup(autodep->clkdm.name);\r\nif (!clkdm) {\r\npr_err("clockdomain: autodeps: clockdomain %s does not exist\n",\r\nautodep->clkdm.name);\r\nclkdm = ERR_PTR(-ENOENT);\r\n}\r\nautodep->clkdm.ptr = clkdm;\r\n}\r\nstatic void _resolve_clkdm_deps(struct clockdomain *clkdm,\r\nstruct clkdm_dep *clkdm_deps)\r\n{\r\nstruct clkdm_dep *cd;\r\nfor (cd = clkdm_deps; cd && cd->clkdm_name; cd++) {\r\nif (cd->clkdm)\r\ncontinue;\r\ncd->clkdm = _clkdm_lookup(cd->clkdm_name);\r\nWARN(!cd->clkdm, "clockdomain: %s: could not find clkdm %s while resolving dependencies - should never happen",\r\nclkdm->name, cd->clkdm_name);\r\n}\r\n}\r\nstatic int _clkdm_add_wkdep(struct clockdomain *clkdm1,\r\nstruct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret = 0;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->wkdep_srcs);\r\nif (IS_ERR(cd))\r\nret = PTR_ERR(cd);\r\nif (!arch_clkdm || !arch_clkdm->clkdm_add_wkdep)\r\nret = -EINVAL;\r\nif (ret) {\r\npr_debug("clockdomain: hardware cannot set/clear wake up of %s when %s wakes up\n",\r\nclkdm1->name, clkdm2->name);\r\nreturn ret;\r\n}\r\ncd->wkdep_usecount++;\r\nif (cd->wkdep_usecount == 1) {\r\npr_debug("clockdomain: hardware will wake up %s when %s wakes up\n",\r\nclkdm1->name, clkdm2->name);\r\nret = arch_clkdm->clkdm_add_wkdep(clkdm1, clkdm2);\r\n}\r\nreturn ret;\r\n}\r\nstatic int _clkdm_del_wkdep(struct clockdomain *clkdm1,\r\nstruct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret = 0;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->wkdep_srcs);\r\nif (IS_ERR(cd))\r\nret = PTR_ERR(cd);\r\nif (!arch_clkdm || !arch_clkdm->clkdm_del_wkdep)\r\nret = -EINVAL;\r\nif (ret) {\r\npr_debug("clockdomain: hardware cannot set/clear wake up of %s when %s wakes up\n",\r\nclkdm1->name, clkdm2->name);\r\nreturn ret;\r\n}\r\ncd->wkdep_usecount--;\r\nif (cd->wkdep_usecount == 0) {\r\npr_debug("clockdomain: hardware will no longer wake up %s after %s wakes up\n",\r\nclkdm1->name, clkdm2->name);\r\nret = arch_clkdm->clkdm_del_wkdep(clkdm1, clkdm2);\r\n}\r\nreturn ret;\r\n}\r\nstatic int _clkdm_add_sleepdep(struct clockdomain *clkdm1,\r\nstruct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret = 0;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->sleepdep_srcs);\r\nif (IS_ERR(cd))\r\nret = PTR_ERR(cd);\r\nif (!arch_clkdm || !arch_clkdm->clkdm_add_sleepdep)\r\nret = -EINVAL;\r\nif (ret) {\r\npr_debug("clockdomain: hardware cannot set/clear sleep dependency affecting %s from %s\n",\r\nclkdm1->name, clkdm2->name);\r\nreturn ret;\r\n}\r\ncd->sleepdep_usecount++;\r\nif (cd->sleepdep_usecount == 1) {\r\npr_debug("clockdomain: will prevent %s from sleeping if %s is active\n",\r\nclkdm1->name, clkdm2->name);\r\nret = arch_clkdm->clkdm_add_sleepdep(clkdm1, clkdm2);\r\n}\r\nreturn ret;\r\n}\r\nstatic int _clkdm_del_sleepdep(struct clockdomain *clkdm1,\r\nstruct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret = 0;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->sleepdep_srcs);\r\nif (IS_ERR(cd))\r\nret = PTR_ERR(cd);\r\nif (!arch_clkdm || !arch_clkdm->clkdm_del_sleepdep)\r\nret = -EINVAL;\r\nif (ret) {\r\npr_debug("clockdomain: hardware cannot set/clear sleep dependency affecting %s from %s\n",\r\nclkdm1->name, clkdm2->name);\r\nreturn ret;\r\n}\r\ncd->sleepdep_usecount--;\r\nif (cd->sleepdep_usecount == 0) {\r\npr_debug("clockdomain: will no longer prevent %s from sleeping if %s is active\n",\r\nclkdm1->name, clkdm2->name);\r\nret = arch_clkdm->clkdm_del_sleepdep(clkdm1, clkdm2);\r\n}\r\nreturn ret;\r\n}\r\nint clkdm_register_platform_funcs(struct clkdm_ops *co)\r\n{\r\nif (!co)\r\nreturn -EINVAL;\r\nif (arch_clkdm)\r\nreturn -EEXIST;\r\narch_clkdm = co;\r\nreturn 0;\r\n}\r\nint clkdm_register_clkdms(struct clockdomain **cs)\r\n{\r\nstruct clockdomain **c = NULL;\r\nif (!arch_clkdm)\r\nreturn -EACCES;\r\nif (!cs)\r\nreturn -EINVAL;\r\nfor (c = cs; *c; c++)\r\n_clkdm_register(*c);\r\nreturn 0;\r\n}\r\nint clkdm_register_autodeps(struct clkdm_autodep *ia)\r\n{\r\nstruct clkdm_autodep *a = NULL;\r\nif (list_empty(&clkdm_list))\r\nreturn -EACCES;\r\nif (!ia)\r\nreturn -EINVAL;\r\nif (autodeps)\r\nreturn -EEXIST;\r\nautodeps = ia;\r\nfor (a = autodeps; a->clkdm.ptr; a++)\r\n_autodep_lookup(a);\r\nreturn 0;\r\n}\r\nint clkdm_complete_init(void)\r\n{\r\nstruct clockdomain *clkdm;\r\nif (list_empty(&clkdm_list))\r\nreturn -EACCES;\r\nlist_for_each_entry(clkdm, &clkdm_list, node) {\r\nclkdm_deny_idle(clkdm);\r\n_resolve_clkdm_deps(clkdm, clkdm->wkdep_srcs);\r\nclkdm_clear_all_wkdeps(clkdm);\r\n_resolve_clkdm_deps(clkdm, clkdm->sleepdep_srcs);\r\nclkdm_clear_all_sleepdeps(clkdm);\r\n}\r\nreturn 0;\r\n}\r\nstruct clockdomain *clkdm_lookup(const char *name)\r\n{\r\nstruct clockdomain *clkdm, *temp_clkdm;\r\nif (!name)\r\nreturn NULL;\r\nclkdm = NULL;\r\nlist_for_each_entry(temp_clkdm, &clkdm_list, node) {\r\nif (!strcmp(name, temp_clkdm->name)) {\r\nclkdm = temp_clkdm;\r\nbreak;\r\n}\r\n}\r\nreturn clkdm;\r\n}\r\nint clkdm_for_each(int (*fn)(struct clockdomain *clkdm, void *user),\r\nvoid *user)\r\n{\r\nstruct clockdomain *clkdm;\r\nint ret = 0;\r\nif (!fn)\r\nreturn -EINVAL;\r\nlist_for_each_entry(clkdm, &clkdm_list, node) {\r\nret = (*fn)(clkdm, user);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstruct powerdomain *clkdm_get_pwrdm(struct clockdomain *clkdm)\r\n{\r\nif (!clkdm)\r\nreturn NULL;\r\nreturn clkdm->pwrdm.ptr;\r\n}\r\nint clkdm_add_wkdep(struct clockdomain *clkdm1, struct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->wkdep_srcs);\r\nif (IS_ERR(cd))\r\nreturn PTR_ERR(cd);\r\npwrdm_lock(cd->clkdm->pwrdm.ptr);\r\nret = _clkdm_add_wkdep(clkdm1, clkdm2);\r\npwrdm_unlock(cd->clkdm->pwrdm.ptr);\r\nreturn ret;\r\n}\r\nint clkdm_del_wkdep(struct clockdomain *clkdm1, struct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->wkdep_srcs);\r\nif (IS_ERR(cd))\r\nreturn PTR_ERR(cd);\r\npwrdm_lock(cd->clkdm->pwrdm.ptr);\r\nret = _clkdm_del_wkdep(clkdm1, clkdm2);\r\npwrdm_unlock(cd->clkdm->pwrdm.ptr);\r\nreturn ret;\r\n}\r\nint clkdm_read_wkdep(struct clockdomain *clkdm1, struct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret = 0;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->wkdep_srcs);\r\nif (IS_ERR(cd))\r\nret = PTR_ERR(cd);\r\nif (!arch_clkdm || !arch_clkdm->clkdm_read_wkdep)\r\nret = -EINVAL;\r\nif (ret) {\r\npr_debug("clockdomain: hardware cannot set/clear wake up of %s when %s wakes up\n",\r\nclkdm1->name, clkdm2->name);\r\nreturn ret;\r\n}\r\nreturn arch_clkdm->clkdm_read_wkdep(clkdm1, clkdm2);\r\n}\r\nint clkdm_clear_all_wkdeps(struct clockdomain *clkdm)\r\n{\r\nif (!clkdm)\r\nreturn -EINVAL;\r\nif (!arch_clkdm || !arch_clkdm->clkdm_clear_all_wkdeps)\r\nreturn -EINVAL;\r\nreturn arch_clkdm->clkdm_clear_all_wkdeps(clkdm);\r\n}\r\nint clkdm_add_sleepdep(struct clockdomain *clkdm1, struct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->wkdep_srcs);\r\nif (IS_ERR(cd))\r\nreturn PTR_ERR(cd);\r\npwrdm_lock(cd->clkdm->pwrdm.ptr);\r\nret = _clkdm_add_sleepdep(clkdm1, clkdm2);\r\npwrdm_unlock(cd->clkdm->pwrdm.ptr);\r\nreturn ret;\r\n}\r\nint clkdm_del_sleepdep(struct clockdomain *clkdm1, struct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->wkdep_srcs);\r\nif (IS_ERR(cd))\r\nreturn PTR_ERR(cd);\r\npwrdm_lock(cd->clkdm->pwrdm.ptr);\r\nret = _clkdm_del_sleepdep(clkdm1, clkdm2);\r\npwrdm_unlock(cd->clkdm->pwrdm.ptr);\r\nreturn ret;\r\n}\r\nint clkdm_read_sleepdep(struct clockdomain *clkdm1, struct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret = 0;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->sleepdep_srcs);\r\nif (IS_ERR(cd))\r\nret = PTR_ERR(cd);\r\nif (!arch_clkdm || !arch_clkdm->clkdm_read_sleepdep)\r\nret = -EINVAL;\r\nif (ret) {\r\npr_debug("clockdomain: hardware cannot set/clear sleep dependency affecting %s from %s\n",\r\nclkdm1->name, clkdm2->name);\r\nreturn ret;\r\n}\r\nreturn arch_clkdm->clkdm_read_sleepdep(clkdm1, clkdm2);\r\n}\r\nint clkdm_clear_all_sleepdeps(struct clockdomain *clkdm)\r\n{\r\nif (!clkdm)\r\nreturn -EINVAL;\r\nif (!arch_clkdm || !arch_clkdm->clkdm_clear_all_sleepdeps)\r\nreturn -EINVAL;\r\nreturn arch_clkdm->clkdm_clear_all_sleepdeps(clkdm);\r\n}\r\nint clkdm_sleep_nolock(struct clockdomain *clkdm)\r\n{\r\nint ret;\r\nif (!clkdm)\r\nreturn -EINVAL;\r\nif (!(clkdm->flags & CLKDM_CAN_FORCE_SLEEP)) {\r\npr_debug("clockdomain: %s does not support forcing sleep via software\n",\r\nclkdm->name);\r\nreturn -EINVAL;\r\n}\r\nif (!arch_clkdm || !arch_clkdm->clkdm_sleep)\r\nreturn -EINVAL;\r\npr_debug("clockdomain: forcing sleep on %s\n", clkdm->name);\r\nclkdm->_flags &= ~_CLKDM_FLAG_HWSUP_ENABLED;\r\nret = arch_clkdm->clkdm_sleep(clkdm);\r\nret |= pwrdm_state_switch_nolock(clkdm->pwrdm.ptr);\r\nreturn ret;\r\n}\r\nint clkdm_sleep(struct clockdomain *clkdm)\r\n{\r\nint ret;\r\npwrdm_lock(clkdm->pwrdm.ptr);\r\nret = clkdm_sleep_nolock(clkdm);\r\npwrdm_unlock(clkdm->pwrdm.ptr);\r\nreturn ret;\r\n}\r\nint clkdm_wakeup_nolock(struct clockdomain *clkdm)\r\n{\r\nint ret;\r\nif (!clkdm)\r\nreturn -EINVAL;\r\nif (!(clkdm->flags & CLKDM_CAN_FORCE_WAKEUP)) {\r\npr_debug("clockdomain: %s does not support forcing wakeup via software\n",\r\nclkdm->name);\r\nreturn -EINVAL;\r\n}\r\nif (!arch_clkdm || !arch_clkdm->clkdm_wakeup)\r\nreturn -EINVAL;\r\npr_debug("clockdomain: forcing wakeup on %s\n", clkdm->name);\r\nclkdm->_flags &= ~_CLKDM_FLAG_HWSUP_ENABLED;\r\nret = arch_clkdm->clkdm_wakeup(clkdm);\r\nret |= pwrdm_state_switch_nolock(clkdm->pwrdm.ptr);\r\nreturn ret;\r\n}\r\nint clkdm_wakeup(struct clockdomain *clkdm)\r\n{\r\nint ret;\r\npwrdm_lock(clkdm->pwrdm.ptr);\r\nret = clkdm_wakeup_nolock(clkdm);\r\npwrdm_unlock(clkdm->pwrdm.ptr);\r\nreturn ret;\r\n}\r\nvoid clkdm_allow_idle_nolock(struct clockdomain *clkdm)\r\n{\r\nif (!clkdm)\r\nreturn;\r\nif (!WARN_ON(!clkdm->forcewake_count))\r\nclkdm->forcewake_count--;\r\nif (clkdm->forcewake_count)\r\nreturn;\r\nif (!clkdm->usecount && (clkdm->flags & CLKDM_CAN_FORCE_SLEEP))\r\nclkdm_sleep_nolock(clkdm);\r\nif (!(clkdm->flags & CLKDM_CAN_ENABLE_AUTO))\r\nreturn;\r\nif (clkdm->flags & CLKDM_MISSING_IDLE_REPORTING)\r\nreturn;\r\nif (!arch_clkdm || !arch_clkdm->clkdm_allow_idle)\r\nreturn;\r\npr_debug("clockdomain: enabling automatic idle transitions for %s\n",\r\nclkdm->name);\r\nclkdm->_flags |= _CLKDM_FLAG_HWSUP_ENABLED;\r\narch_clkdm->clkdm_allow_idle(clkdm);\r\npwrdm_state_switch_nolock(clkdm->pwrdm.ptr);\r\n}\r\nvoid clkdm_allow_idle(struct clockdomain *clkdm)\r\n{\r\npwrdm_lock(clkdm->pwrdm.ptr);\r\nclkdm_allow_idle_nolock(clkdm);\r\npwrdm_unlock(clkdm->pwrdm.ptr);\r\n}\r\nvoid clkdm_deny_idle_nolock(struct clockdomain *clkdm)\r\n{\r\nif (!clkdm)\r\nreturn;\r\nif (clkdm->forcewake_count++)\r\nreturn;\r\nif (clkdm->flags & CLKDM_CAN_FORCE_WAKEUP)\r\nclkdm_wakeup_nolock(clkdm);\r\nif (!(clkdm->flags & CLKDM_CAN_DISABLE_AUTO))\r\nreturn;\r\nif (clkdm->flags & CLKDM_MISSING_IDLE_REPORTING)\r\nreturn;\r\nif (!arch_clkdm || !arch_clkdm->clkdm_deny_idle)\r\nreturn;\r\npr_debug("clockdomain: disabling automatic idle transitions for %s\n",\r\nclkdm->name);\r\nclkdm->_flags &= ~_CLKDM_FLAG_HWSUP_ENABLED;\r\narch_clkdm->clkdm_deny_idle(clkdm);\r\npwrdm_state_switch_nolock(clkdm->pwrdm.ptr);\r\n}\r\nvoid clkdm_deny_idle(struct clockdomain *clkdm)\r\n{\r\npwrdm_lock(clkdm->pwrdm.ptr);\r\nclkdm_deny_idle_nolock(clkdm);\r\npwrdm_unlock(clkdm->pwrdm.ptr);\r\n}\r\nbool clkdm_in_hwsup(struct clockdomain *clkdm)\r\n{\r\nbool ret;\r\nif (!clkdm)\r\nreturn false;\r\nret = (clkdm->_flags & _CLKDM_FLAG_HWSUP_ENABLED) ? true : false;\r\nreturn ret;\r\n}\r\nbool clkdm_missing_idle_reporting(struct clockdomain *clkdm)\r\n{\r\nif (!clkdm)\r\nreturn false;\r\nreturn (clkdm->flags & CLKDM_MISSING_IDLE_REPORTING) ? true : false;\r\n}\r\nvoid clkdm_add_autodeps(struct clockdomain *clkdm)\r\n{\r\nstruct clkdm_autodep *autodep;\r\nif (!autodeps || clkdm->flags & CLKDM_NO_AUTODEPS)\r\nreturn;\r\nfor (autodep = autodeps; autodep->clkdm.ptr; autodep++) {\r\nif (IS_ERR(autodep->clkdm.ptr))\r\ncontinue;\r\npr_debug("clockdomain: %s: adding %s sleepdep/wkdep\n",\r\nclkdm->name, autodep->clkdm.ptr->name);\r\n_clkdm_add_sleepdep(clkdm, autodep->clkdm.ptr);\r\n_clkdm_add_wkdep(clkdm, autodep->clkdm.ptr);\r\n}\r\n}\r\nvoid clkdm_del_autodeps(struct clockdomain *clkdm)\r\n{\r\nstruct clkdm_autodep *autodep;\r\nif (!autodeps || clkdm->flags & CLKDM_NO_AUTODEPS)\r\nreturn;\r\nfor (autodep = autodeps; autodep->clkdm.ptr; autodep++) {\r\nif (IS_ERR(autodep->clkdm.ptr))\r\ncontinue;\r\npr_debug("clockdomain: %s: removing %s sleepdep/wkdep\n",\r\nclkdm->name, autodep->clkdm.ptr->name);\r\n_clkdm_del_sleepdep(clkdm, autodep->clkdm.ptr);\r\n_clkdm_del_wkdep(clkdm, autodep->clkdm.ptr);\r\n}\r\n}\r\nstatic int _clkdm_clk_hwmod_enable(struct clockdomain *clkdm)\r\n{\r\nif (!clkdm || !arch_clkdm || !arch_clkdm->clkdm_clk_enable)\r\nreturn -EINVAL;\r\npwrdm_lock(clkdm->pwrdm.ptr);\r\nclkdm->usecount++;\r\nif (clkdm->usecount > 1 && autodeps) {\r\npwrdm_unlock(clkdm->pwrdm.ptr);\r\nreturn 0;\r\n}\r\narch_clkdm->clkdm_clk_enable(clkdm);\r\npwrdm_state_switch_nolock(clkdm->pwrdm.ptr);\r\npwrdm_unlock(clkdm->pwrdm.ptr);\r\npr_debug("clockdomain: %s: enabled\n", clkdm->name);\r\nreturn 0;\r\n}\r\nint clkdm_clk_enable(struct clockdomain *clkdm, struct clk *clk)\r\n{\r\nif (!clk)\r\nreturn -EINVAL;\r\nreturn _clkdm_clk_hwmod_enable(clkdm);\r\n}\r\nint clkdm_clk_disable(struct clockdomain *clkdm, struct clk *clk)\r\n{\r\nif (!clkdm || !clk || !arch_clkdm || !arch_clkdm->clkdm_clk_disable)\r\nreturn -EINVAL;\r\npwrdm_lock(clkdm->pwrdm.ptr);\r\nif ((__clk_get_enable_count(clk) == 0) && clkdm->usecount == 0)\r\ngoto ccd_exit;\r\nif (clkdm->usecount == 0) {\r\npwrdm_unlock(clkdm->pwrdm.ptr);\r\nWARN_ON(1);\r\nreturn -ERANGE;\r\n}\r\nclkdm->usecount--;\r\nif (clkdm->usecount > 0) {\r\npwrdm_unlock(clkdm->pwrdm.ptr);\r\nreturn 0;\r\n}\r\narch_clkdm->clkdm_clk_disable(clkdm);\r\npwrdm_state_switch_nolock(clkdm->pwrdm.ptr);\r\npr_debug("clockdomain: %s: disabled\n", clkdm->name);\r\nccd_exit:\r\npwrdm_unlock(clkdm->pwrdm.ptr);\r\nreturn 0;\r\n}\r\nu32 clkdm_xlate_address(struct clockdomain *clkdm)\r\n{\r\nif (arch_clkdm->clkdm_xlate_address)\r\nreturn arch_clkdm->clkdm_xlate_address(clkdm);\r\nreturn 0;\r\n}\r\nint clkdm_hwmod_enable(struct clockdomain *clkdm, struct omap_hwmod *oh)\r\n{\r\nif (cpu_is_omap24xx() || cpu_is_omap34xx())\r\nreturn 0;\r\nif (!oh)\r\nreturn -EINVAL;\r\nreturn _clkdm_clk_hwmod_enable(clkdm);\r\n}\r\nint clkdm_hwmod_disable(struct clockdomain *clkdm, struct omap_hwmod *oh)\r\n{\r\nif (cpu_is_omap24xx() || cpu_is_omap34xx())\r\nreturn 0;\r\nif (!clkdm || !oh || !arch_clkdm || !arch_clkdm->clkdm_clk_disable)\r\nreturn -EINVAL;\r\npwrdm_lock(clkdm->pwrdm.ptr);\r\nif (clkdm->usecount == 0) {\r\npwrdm_unlock(clkdm->pwrdm.ptr);\r\nWARN_ON(1);\r\nreturn -ERANGE;\r\n}\r\nclkdm->usecount--;\r\nif (clkdm->usecount > 0) {\r\npwrdm_unlock(clkdm->pwrdm.ptr);\r\nreturn 0;\r\n}\r\narch_clkdm->clkdm_clk_disable(clkdm);\r\npwrdm_state_switch_nolock(clkdm->pwrdm.ptr);\r\npwrdm_unlock(clkdm->pwrdm.ptr);\r\npr_debug("clockdomain: %s: disabled\n", clkdm->name);\r\nreturn 0;\r\n}
