static int fec_ptp_enable_pps(struct fec_enet_private *fep, uint enable)\r\n{\r\nunsigned long flags;\r\nu32 val, tempval;\r\nint inc;\r\nstruct timespec64 ts;\r\nu64 ns;\r\nval = 0;\r\nif (!(fep->hwts_tx_en || fep->hwts_rx_en)) {\r\ndev_err(&fep->pdev->dev, "No ptp stack is running\n");\r\nreturn -EINVAL;\r\n}\r\nif (fep->pps_enable == enable)\r\nreturn 0;\r\nfep->pps_channel = DEFAULT_PPS_CHANNEL;\r\nfep->reload_period = PPS_OUPUT_RELOAD_PERIOD;\r\ninc = fep->ptp_inc;\r\nspin_lock_irqsave(&fep->tmreg_lock, flags);\r\nif (enable) {\r\nwritel(FEC_T_TF_MASK, fep->hwp + FEC_TCSR(fep->pps_channel));\r\nval = readl(fep->hwp + FEC_TCSR(fep->pps_channel));\r\ndo {\r\nval &= ~(FEC_T_TMODE_MASK);\r\nwritel(val, fep->hwp + FEC_TCSR(fep->pps_channel));\r\nval = readl(fep->hwp + FEC_TCSR(fep->pps_channel));\r\n} while (val & FEC_T_TMODE_MASK);\r\ntimecounter_read(&fep->tc);\r\ntempval = readl(fep->hwp + FEC_ATIME_CTRL);\r\ntempval |= FEC_T_CTRL_CAPTURE;\r\nwritel(tempval, fep->hwp + FEC_ATIME_CTRL);\r\ntempval = readl(fep->hwp + FEC_ATIME);\r\nns = timecounter_cyc2time(&fep->tc, tempval);\r\nts = ns_to_timespec64(ns);\r\nval = NSEC_PER_SEC - (u32)ts.tv_nsec + tempval;\r\nval += NSEC_PER_SEC;\r\nval &= fep->cc.mask;\r\nwritel(val, fep->hwp + FEC_TCCR(fep->pps_channel));\r\nfep->next_counter = (val + fep->reload_period) & fep->cc.mask;\r\nval = readl(fep->hwp + FEC_ATIME_CTRL);\r\nval |= FEC_T_CTRL_PINPER;\r\nwritel(val, fep->hwp + FEC_ATIME_CTRL);\r\nval = readl(fep->hwp + FEC_TCSR(fep->pps_channel));\r\nval |= (1 << FEC_T_TF_OFFSET | 1 << FEC_T_TIE_OFFSET);\r\nval &= ~(1 << FEC_T_TDRE_OFFSET);\r\nval &= ~(FEC_T_TMODE_MASK);\r\nval |= (FEC_HIGH_PULSE << FEC_T_TMODE_OFFSET);\r\nwritel(val, fep->hwp + FEC_TCSR(fep->pps_channel));\r\nwritel(fep->next_counter, fep->hwp + FEC_TCCR(fep->pps_channel));\r\nfep->next_counter = (fep->next_counter + fep->reload_period) & fep->cc.mask;\r\n} else {\r\nwritel(0, fep->hwp + FEC_TCSR(fep->pps_channel));\r\n}\r\nfep->pps_enable = enable;\r\nspin_unlock_irqrestore(&fep->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic u64 fec_ptp_read(const struct cyclecounter *cc)\r\n{\r\nstruct fec_enet_private *fep =\r\ncontainer_of(cc, struct fec_enet_private, cc);\r\nconst struct platform_device_id *id_entry =\r\nplatform_get_device_id(fep->pdev);\r\nu32 tempval;\r\ntempval = readl(fep->hwp + FEC_ATIME_CTRL);\r\ntempval |= FEC_T_CTRL_CAPTURE;\r\nwritel(tempval, fep->hwp + FEC_ATIME_CTRL);\r\nif (id_entry->driver_data & FEC_QUIRK_BUG_CAPTURE)\r\nudelay(1);\r\nreturn readl(fep->hwp + FEC_ATIME);\r\n}\r\nvoid fec_ptp_start_cyclecounter(struct net_device *ndev)\r\n{\r\nstruct fec_enet_private *fep = netdev_priv(ndev);\r\nunsigned long flags;\r\nint inc;\r\ninc = 1000000000 / fep->cycle_speed;\r\nspin_lock_irqsave(&fep->tmreg_lock, flags);\r\nwritel(inc << FEC_T_INC_OFFSET, fep->hwp + FEC_ATIME_INC);\r\nwritel(FEC_COUNTER_PERIOD, fep->hwp + FEC_ATIME_EVT_PERIOD);\r\nwritel(FEC_T_CTRL_ENABLE | FEC_T_CTRL_PERIOD_RST,\r\nfep->hwp + FEC_ATIME_CTRL);\r\nmemset(&fep->cc, 0, sizeof(fep->cc));\r\nfep->cc.read = fec_ptp_read;\r\nfep->cc.mask = CLOCKSOURCE_MASK(31);\r\nfep->cc.shift = 31;\r\nfep->cc.mult = FEC_CC_MULT;\r\ntimecounter_init(&fep->tc, &fep->cc, ktime_to_ns(ktime_get_real()));\r\nspin_unlock_irqrestore(&fep->tmreg_lock, flags);\r\n}\r\nstatic int fec_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nunsigned long flags;\r\nint neg_adj = 0;\r\nu32 i, tmp;\r\nu32 corr_inc, corr_period;\r\nu32 corr_ns;\r\nu64 lhs, rhs;\r\nstruct fec_enet_private *fep =\r\ncontainer_of(ptp, struct fec_enet_private, ptp_caps);\r\nif (ppb == 0)\r\nreturn 0;\r\nif (ppb < 0) {\r\nppb = -ppb;\r\nneg_adj = 1;\r\n}\r\nlhs = NSEC_PER_SEC;\r\nrhs = (u64)ppb * (u64)fep->ptp_inc;\r\nfor (i = 1; i <= fep->ptp_inc; i++) {\r\nif (lhs >= rhs) {\r\ncorr_inc = i;\r\ncorr_period = div_u64(lhs, rhs);\r\nbreak;\r\n}\r\nlhs += NSEC_PER_SEC;\r\n}\r\nif (i > fep->ptp_inc) {\r\ncorr_inc = fep->ptp_inc;\r\ncorr_period = 1;\r\n}\r\nif (neg_adj)\r\ncorr_ns = fep->ptp_inc - corr_inc;\r\nelse\r\ncorr_ns = fep->ptp_inc + corr_inc;\r\nspin_lock_irqsave(&fep->tmreg_lock, flags);\r\ntmp = readl(fep->hwp + FEC_ATIME_INC) & FEC_T_INC_MASK;\r\ntmp |= corr_ns << FEC_T_INC_CORR_OFFSET;\r\nwritel(tmp, fep->hwp + FEC_ATIME_INC);\r\ncorr_period = corr_period > 1 ? corr_period - 1 : corr_period;\r\nwritel(corr_period, fep->hwp + FEC_ATIME_CORR);\r\ntimecounter_read(&fep->tc);\r\nspin_unlock_irqrestore(&fep->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int fec_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct fec_enet_private *fep =\r\ncontainer_of(ptp, struct fec_enet_private, ptp_caps);\r\nunsigned long flags;\r\nspin_lock_irqsave(&fep->tmreg_lock, flags);\r\ntimecounter_adjtime(&fep->tc, delta);\r\nspin_unlock_irqrestore(&fep->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int fec_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\r\n{\r\nstruct fec_enet_private *adapter =\r\ncontainer_of(ptp, struct fec_enet_private, ptp_caps);\r\nu64 ns;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\nns = timecounter_read(&adapter->tc);\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\n*ts = ns_to_timespec64(ns);\r\nreturn 0;\r\n}\r\nstatic int fec_ptp_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct fec_enet_private *fep =\r\ncontainer_of(ptp, struct fec_enet_private, ptp_caps);\r\nu64 ns;\r\nunsigned long flags;\r\nu32 counter;\r\nmutex_lock(&fep->ptp_clk_mutex);\r\nif (!fep->ptp_clk_on) {\r\nmutex_unlock(&fep->ptp_clk_mutex);\r\nreturn -EINVAL;\r\n}\r\nns = timespec64_to_ns(ts);\r\ncounter = ns & fep->cc.mask;\r\nspin_lock_irqsave(&fep->tmreg_lock, flags);\r\nwritel(counter, fep->hwp + FEC_ATIME);\r\ntimecounter_init(&fep->tc, &fep->cc, ns);\r\nspin_unlock_irqrestore(&fep->tmreg_lock, flags);\r\nmutex_unlock(&fep->ptp_clk_mutex);\r\nreturn 0;\r\n}\r\nstatic int fec_ptp_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nstruct fec_enet_private *fep =\r\ncontainer_of(ptp, struct fec_enet_private, ptp_caps);\r\nint ret = 0;\r\nif (rq->type == PTP_CLK_REQ_PPS) {\r\nret = fec_ptp_enable_pps(fep, on);\r\nreturn ret;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nint fec_ptp_set(struct net_device *ndev, struct ifreq *ifr)\r\n{\r\nstruct fec_enet_private *fep = netdev_priv(ndev);\r\nstruct hwtstamp_config config;\r\nif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\r\nreturn -EFAULT;\r\nif (config.flags)\r\nreturn -EINVAL;\r\nswitch (config.tx_type) {\r\ncase HWTSTAMP_TX_OFF:\r\nfep->hwts_tx_en = 0;\r\nbreak;\r\ncase HWTSTAMP_TX_ON:\r\nfep->hwts_tx_en = 1;\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nswitch (config.rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\nif (fep->hwts_rx_en)\r\nfep->hwts_rx_en = 0;\r\nconfig.rx_filter = HWTSTAMP_FILTER_NONE;\r\nbreak;\r\ndefault:\r\nfep->hwts_rx_en = 1;\r\nconfig.rx_filter = HWTSTAMP_FILTER_ALL;\r\nbreak;\r\n}\r\nreturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\r\n-EFAULT : 0;\r\n}\r\nint fec_ptp_get(struct net_device *ndev, struct ifreq *ifr)\r\n{\r\nstruct fec_enet_private *fep = netdev_priv(ndev);\r\nstruct hwtstamp_config config;\r\nconfig.flags = 0;\r\nconfig.tx_type = fep->hwts_tx_en ? HWTSTAMP_TX_ON : HWTSTAMP_TX_OFF;\r\nconfig.rx_filter = (fep->hwts_rx_en ?\r\nHWTSTAMP_FILTER_ALL : HWTSTAMP_FILTER_NONE);\r\nreturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\r\n-EFAULT : 0;\r\n}\r\nstatic void fec_time_keep(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct fec_enet_private *fep = container_of(dwork, struct fec_enet_private, time_keep);\r\nu64 ns;\r\nunsigned long flags;\r\nmutex_lock(&fep->ptp_clk_mutex);\r\nif (fep->ptp_clk_on) {\r\nspin_lock_irqsave(&fep->tmreg_lock, flags);\r\nns = timecounter_read(&fep->tc);\r\nspin_unlock_irqrestore(&fep->tmreg_lock, flags);\r\n}\r\nmutex_unlock(&fep->ptp_clk_mutex);\r\nschedule_delayed_work(&fep->time_keep, HZ);\r\n}\r\nvoid fec_ptp_init(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct fec_enet_private *fep = netdev_priv(ndev);\r\nfep->ptp_caps.owner = THIS_MODULE;\r\nsnprintf(fep->ptp_caps.name, 16, "fec ptp");\r\nfep->ptp_caps.max_adj = 250000000;\r\nfep->ptp_caps.n_alarm = 0;\r\nfep->ptp_caps.n_ext_ts = 0;\r\nfep->ptp_caps.n_per_out = 0;\r\nfep->ptp_caps.n_pins = 0;\r\nfep->ptp_caps.pps = 1;\r\nfep->ptp_caps.adjfreq = fec_ptp_adjfreq;\r\nfep->ptp_caps.adjtime = fec_ptp_adjtime;\r\nfep->ptp_caps.gettime64 = fec_ptp_gettime;\r\nfep->ptp_caps.settime64 = fec_ptp_settime;\r\nfep->ptp_caps.enable = fec_ptp_enable;\r\nfep->cycle_speed = clk_get_rate(fep->clk_ptp);\r\nfep->ptp_inc = NSEC_PER_SEC / fep->cycle_speed;\r\nspin_lock_init(&fep->tmreg_lock);\r\nfec_ptp_start_cyclecounter(ndev);\r\nINIT_DELAYED_WORK(&fep->time_keep, fec_time_keep);\r\nfep->ptp_clock = ptp_clock_register(&fep->ptp_caps, &pdev->dev);\r\nif (IS_ERR(fep->ptp_clock)) {\r\nfep->ptp_clock = NULL;\r\npr_err("ptp_clock_register failed\n");\r\n}\r\nschedule_delayed_work(&fep->time_keep, HZ);\r\n}\r\nvoid fec_ptp_stop(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct fec_enet_private *fep = netdev_priv(ndev);\r\ncancel_delayed_work_sync(&fep->time_keep);\r\nif (fep->ptp_clock)\r\nptp_clock_unregister(fep->ptp_clock);\r\n}\r\nuint fec_ptp_check_pps_event(struct fec_enet_private *fep)\r\n{\r\nu32 val;\r\nu8 channel = fep->pps_channel;\r\nstruct ptp_clock_event event;\r\nval = readl(fep->hwp + FEC_TCSR(channel));\r\nif (val & FEC_T_TF_MASK) {\r\nwritel(fep->next_counter, fep->hwp + FEC_TCCR(channel));\r\ndo {\r\nwritel(val, fep->hwp + FEC_TCSR(channel));\r\n} while (readl(fep->hwp + FEC_TCSR(channel)) & FEC_T_TF_MASK);\r\nfep->next_counter = (fep->next_counter + fep->reload_period) & fep->cc.mask;\r\nevent.type = PTP_CLOCK_PPS;\r\nptp_clock_event(fep->ptp_clock, &event);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}
