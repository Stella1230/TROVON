static int thunder_pem_bridge_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nu64 read_val, tmp_val;\r\nstruct pci_config_window *cfg = bus->sysdata;\r\nstruct thunder_pem_pci *pem_pci = (struct thunder_pem_pci *)cfg->priv;\r\nif (devfn != 0 || where >= 2048) {\r\n*val = ~0;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nread_val = where & ~3ull;\r\nwriteq(read_val, pem_pci->pem_reg_base + PEM_CFG_RD);\r\nread_val = readq(pem_pci->pem_reg_base + PEM_CFG_RD);\r\nread_val >>= 32;\r\nswitch (where & ~3) {\r\ncase 0x40:\r\nread_val &= 0xffff00ff;\r\nread_val |= 0x00007000;\r\nbreak;\r\ncase 0x70:\r\nif (!(read_val & (0x1f << 25)))\r\nread_val |= (2u << 25);\r\nbreak;\r\ncase 0xb0:\r\nread_val &= 0xc00000ff;\r\nwriteq(0x70, pem_pci->pem_reg_base + PEM_CFG_RD);\r\ntmp_val = readq(pem_pci->pem_reg_base + PEM_CFG_RD);\r\ntmp_val >>= 32;\r\nif (!(tmp_val & (0x1f << 25)))\r\nread_val |= 0x0003bc00;\r\nelse\r\nread_val |= 0x0001bc00;\r\nbreak;\r\ncase 0xb4:\r\nread_val = 0x00000000;\r\nbreak;\r\ncase 0xb8:\r\nread_val = 0x000f0000;\r\nbreak;\r\ncase 0xbc:\r\nread_val = 0x00010014;\r\nbreak;\r\ncase 0xc0:\r\nread_val = 0x00000000;\r\nbreak;\r\ncase 0xc4:\r\nread_val = 0x80ff0003;\r\nbreak;\r\ncase 0xc8:\r\nread_val = pem_pci->ea_entry[0];\r\nbreak;\r\ncase 0xcc:\r\nread_val = pem_pci->ea_entry[1];\r\nbreak;\r\ncase 0xd0:\r\nread_val = pem_pci->ea_entry[2];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nread_val >>= (8 * (where & 3));\r\nswitch (size) {\r\ncase 1:\r\nread_val &= 0xff;\r\nbreak;\r\ncase 2:\r\nread_val &= 0xffff;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n*val = read_val;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int thunder_pem_config_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nstruct pci_config_window *cfg = bus->sysdata;\r\nif (bus->number < cfg->busr.start ||\r\nbus->number > cfg->busr.end)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (bus->number == cfg->busr.start)\r\nreturn thunder_pem_bridge_read(bus, devfn, where, size, val);\r\nreturn pci_generic_config_read(bus, devfn, where, size, val);\r\n}\r\nstatic u32 thunder_pem_bridge_w1c_bits(u64 where_aligned)\r\n{\r\nu32 w1c_bits = 0;\r\nswitch (where_aligned) {\r\ncase 0x04:\r\ncase 0x1c:\r\nw1c_bits = 0xff000000;\r\nbreak;\r\ncase 0x44:\r\nw1c_bits = 0xfffffe00;\r\nbreak;\r\ncase 0x78:\r\ncase 0x80:\r\ncase 0x88:\r\ncase 0x90:\r\ncase 0xa0:\r\nw1c_bits = 0xffff0000;\r\nbreak;\r\ncase 0x104:\r\ncase 0x110:\r\ncase 0x130:\r\ncase 0x160:\r\nw1c_bits = 0xffffffff;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn w1c_bits;\r\n}\r\nstatic u32 thunder_pem_bridge_w1_bits(u64 where_aligned)\r\n{\r\nu32 w1_bits;\r\nswitch (where_aligned) {\r\ncase 0x1c:\r\nw1_bits = 0x0101;\r\nbreak;\r\ncase 0x24:\r\nw1_bits = 0x00010001;\r\nbreak;\r\ndefault:\r\nw1_bits = 0;\r\nbreak;\r\n}\r\nreturn w1_bits;\r\n}\r\nstatic int thunder_pem_bridge_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nstruct pci_config_window *cfg = bus->sysdata;\r\nstruct thunder_pem_pci *pem_pci = (struct thunder_pem_pci *)cfg->priv;\r\nu64 write_val, read_val;\r\nu64 where_aligned = where & ~3ull;\r\nu32 mask = 0;\r\nif (devfn != 0 || where >= 2048)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nswitch (size) {\r\ncase 1:\r\nwriteq(where_aligned, pem_pci->pem_reg_base + PEM_CFG_RD);\r\nread_val = readq(pem_pci->pem_reg_base + PEM_CFG_RD);\r\nread_val >>= 32;\r\nmask = ~(0xff << (8 * (where & 3)));\r\nread_val &= mask;\r\nval = (val & 0xff) << (8 * (where & 3));\r\nval |= (u32)read_val;\r\nbreak;\r\ncase 2:\r\nwriteq(where_aligned, pem_pci->pem_reg_base + PEM_CFG_RD);\r\nread_val = readq(pem_pci->pem_reg_base + PEM_CFG_RD);\r\nread_val >>= 32;\r\nmask = ~(0xffff << (8 * (where & 3)));\r\nread_val &= mask;\r\nval = (val & 0xffff) << (8 * (where & 3));\r\nval |= (u32)read_val;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (mask) {\r\nu32 w1c_bits = thunder_pem_bridge_w1c_bits(where);\r\nif (w1c_bits) {\r\nmask &= w1c_bits;\r\nval &= ~mask;\r\n}\r\n}\r\nval |= thunder_pem_bridge_w1_bits(where_aligned);\r\nwrite_val = (((u64)val) << 32) | where_aligned;\r\nwriteq(write_val, pem_pci->pem_reg_base + PEM_CFG_WR);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int thunder_pem_config_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nstruct pci_config_window *cfg = bus->sysdata;\r\nif (bus->number < cfg->busr.start ||\r\nbus->number > cfg->busr.end)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (bus->number == cfg->busr.start)\r\nreturn thunder_pem_bridge_write(bus, devfn, where, size, val);\r\nreturn pci_generic_config_write(bus, devfn, where, size, val);\r\n}\r\nstatic int thunder_pem_init(struct device *dev, struct pci_config_window *cfg,\r\nstruct resource *res_pem)\r\n{\r\nstruct thunder_pem_pci *pem_pci;\r\nresource_size_t bar4_start;\r\npem_pci = devm_kzalloc(dev, sizeof(*pem_pci), GFP_KERNEL);\r\nif (!pem_pci)\r\nreturn -ENOMEM;\r\npem_pci->pem_reg_base = devm_ioremap(dev, res_pem->start, 0x10000);\r\nif (!pem_pci->pem_reg_base)\r\nreturn -ENOMEM;\r\nbar4_start = res_pem->start + 0xf00000;\r\npem_pci->ea_entry[0] = (u32)bar4_start | 2;\r\npem_pci->ea_entry[1] = (u32)(res_pem->end - bar4_start) & ~3u;\r\npem_pci->ea_entry[2] = (u32)(bar4_start >> 32);\r\ncfg->priv = pem_pci;\r\nreturn 0;\r\n}\r\nstatic void thunder_pem_reserve_range(struct device *dev, int seg,\r\nstruct resource *r)\r\n{\r\nresource_size_t start = r->start, end = r->end;\r\nstruct resource *res;\r\nconst char *regionid;\r\nregionid = kasprintf(GFP_KERNEL, "PEM RC:%d", seg);\r\nif (!regionid)\r\nreturn;\r\nres = request_mem_region(start, end - start + 1, regionid);\r\nif (res)\r\nres->flags &= ~IORESOURCE_BUSY;\r\nelse\r\nkfree(regionid);\r\ndev_info(dev, "%pR %s reserved\n", r,\r\nres ? "has been" : "could not be");\r\n}\r\nstatic void thunder_pem_legacy_fw(struct acpi_pci_root *root,\r\nstruct resource *res_pem)\r\n{\r\nint node = acpi_get_node(root->device->handle);\r\nint index;\r\nif (node == NUMA_NO_NODE)\r\nnode = 0;\r\nindex = root->segment - PEM_MIN_DOM_IN_NODE;\r\nindex -= node * PEM_MAX_DOM_IN_NODE;\r\nres_pem->start = PEM_RES_BASE | FIELD_PREP(PEM_NODE_MASK, node) |\r\nFIELD_PREP(PEM_INDX_MASK, index);\r\nres_pem->flags = IORESOURCE_MEM;\r\n}\r\nstatic int thunder_pem_acpi_init(struct pci_config_window *cfg)\r\n{\r\nstruct device *dev = cfg->parent;\r\nstruct acpi_device *adev = to_acpi_device(dev);\r\nstruct acpi_pci_root *root = acpi_driver_data(adev);\r\nstruct resource *res_pem;\r\nint ret;\r\nres_pem = devm_kzalloc(&adev->dev, sizeof(*res_pem), GFP_KERNEL);\r\nif (!res_pem)\r\nreturn -ENOMEM;\r\nret = acpi_get_rc_resources(dev, "CAVA02B", root->segment, res_pem);\r\nif (ret) {\r\nthunder_pem_legacy_fw(root, res_pem);\r\nres_pem->end = res_pem->start + SZ_64K - 1;\r\nthunder_pem_reserve_range(dev, root->segment, res_pem);\r\nres_pem->end = res_pem->start + SZ_16M - 1;\r\nthunder_pem_reserve_range(dev, root->segment, &cfg->res);\r\n}\r\nreturn thunder_pem_init(dev, cfg, res_pem);\r\n}\r\nstatic int thunder_pem_platform_init(struct pci_config_window *cfg)\r\n{\r\nstruct device *dev = cfg->parent;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct resource *res_pem;\r\nif (!dev->of_node)\r\nreturn -EINVAL;\r\nres_pem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res_pem) {\r\ndev_err(dev, "missing \"reg[1]\"property\n");\r\nreturn -EINVAL;\r\n}\r\nreturn thunder_pem_init(dev, cfg, res_pem);\r\n}\r\nstatic int thunder_pem_probe(struct platform_device *pdev)\r\n{\r\nreturn pci_host_common_probe(pdev, &pci_thunder_pem_ops);\r\n}
