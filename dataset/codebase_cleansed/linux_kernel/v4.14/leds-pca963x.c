static int pca963x_brightness(struct pca963x_led *pca963x,\r\nenum led_brightness brightness)\r\n{\r\nu8 ledout_addr = pca963x->chip->chipdef->ledout_base\r\n+ (pca963x->led_num / 4);\r\nu8 ledout;\r\nint shift = 2 * (pca963x->led_num % 4);\r\nu8 mask = 0x3 << shift;\r\nint ret;\r\nledout = i2c_smbus_read_byte_data(pca963x->chip->client, ledout_addr);\r\nswitch (brightness) {\r\ncase LED_FULL:\r\nret = i2c_smbus_write_byte_data(pca963x->chip->client,\r\nledout_addr,\r\n(ledout & ~mask) | (PCA963X_LED_ON << shift));\r\nbreak;\r\ncase LED_OFF:\r\nret = i2c_smbus_write_byte_data(pca963x->chip->client,\r\nledout_addr, ledout & ~mask);\r\nbreak;\r\ndefault:\r\nret = i2c_smbus_write_byte_data(pca963x->chip->client,\r\nPCA963X_PWM_BASE + pca963x->led_num,\r\nbrightness);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(pca963x->chip->client,\r\nledout_addr,\r\n(ledout & ~mask) | (PCA963X_LED_PWM << shift));\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void pca963x_blink(struct pca963x_led *pca963x)\r\n{\r\nu8 ledout_addr = pca963x->chip->chipdef->ledout_base +\r\n(pca963x->led_num / 4);\r\nu8 ledout;\r\nu8 mode2 = i2c_smbus_read_byte_data(pca963x->chip->client,\r\nPCA963X_MODE2);\r\nint shift = 2 * (pca963x->led_num % 4);\r\nu8 mask = 0x3 << shift;\r\ni2c_smbus_write_byte_data(pca963x->chip->client,\r\npca963x->chip->chipdef->grppwm, pca963x->gdc);\r\ni2c_smbus_write_byte_data(pca963x->chip->client,\r\npca963x->chip->chipdef->grpfreq, pca963x->gfrq);\r\nif (!(mode2 & PCA963X_MODE2_DMBLNK))\r\ni2c_smbus_write_byte_data(pca963x->chip->client, PCA963X_MODE2,\r\nmode2 | PCA963X_MODE2_DMBLNK);\r\nmutex_lock(&pca963x->chip->mutex);\r\nledout = i2c_smbus_read_byte_data(pca963x->chip->client, ledout_addr);\r\nif ((ledout & mask) != (PCA963X_LED_GRP_PWM << shift))\r\ni2c_smbus_write_byte_data(pca963x->chip->client, ledout_addr,\r\n(ledout & ~mask) | (PCA963X_LED_GRP_PWM << shift));\r\nmutex_unlock(&pca963x->chip->mutex);\r\n}\r\nstatic int pca963x_power_state(struct pca963x_led *pca963x)\r\n{\r\nunsigned long *leds_on = &pca963x->chip->leds_on;\r\nunsigned long cached_leds = pca963x->chip->leds_on;\r\nif (pca963x->led_cdev.brightness)\r\nset_bit(pca963x->led_num, leds_on);\r\nelse\r\nclear_bit(pca963x->led_num, leds_on);\r\nif (!(*leds_on) != !cached_leds)\r\nreturn i2c_smbus_write_byte_data(pca963x->chip->client,\r\nPCA963X_MODE1, *leds_on ? 0 : BIT(4));\r\nreturn 0;\r\n}\r\nstatic int pca963x_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct pca963x_led *pca963x;\r\nint ret;\r\npca963x = container_of(led_cdev, struct pca963x_led, led_cdev);\r\nmutex_lock(&pca963x->chip->mutex);\r\nret = pca963x_brightness(pca963x, value);\r\nif (ret < 0)\r\ngoto unlock;\r\nret = pca963x_power_state(pca963x);\r\nunlock:\r\nmutex_unlock(&pca963x->chip->mutex);\r\nreturn ret;\r\n}\r\nstatic unsigned int pca963x_period_scale(struct pca963x_led *pca963x,\r\nunsigned int val)\r\n{\r\nunsigned int scaling = pca963x->chip->chipdef->scaling;\r\nreturn scaling ? DIV_ROUND_CLOSEST(val * scaling, 1000) : val;\r\n}\r\nstatic int pca963x_blink_set(struct led_classdev *led_cdev,\r\nunsigned long *delay_on, unsigned long *delay_off)\r\n{\r\nstruct pca963x_led *pca963x;\r\nunsigned long time_on, time_off, period;\r\nu8 gdc, gfrq;\r\npca963x = container_of(led_cdev, struct pca963x_led, led_cdev);\r\ntime_on = *delay_on;\r\ntime_off = *delay_off;\r\nif (!time_on && !time_off) {\r\ntime_on = 500;\r\ntime_off = 500;\r\n}\r\nperiod = pca963x_period_scale(pca963x, time_on + time_off);\r\nif ((period < PCA963X_BLINK_PERIOD_MIN) ||\r\n(period > PCA963X_BLINK_PERIOD_MAX)) {\r\ntime_on = 500;\r\ntime_off = 500;\r\nperiod = pca963x_period_scale(pca963x, 1000);\r\n}\r\ngdc = (pca963x_period_scale(pca963x, time_on) * 256) / period;\r\ngfrq = (period * 24 / 1000) - 1;\r\npca963x->gdc = gdc;\r\npca963x->gfrq = gfrq;\r\npca963x_blink(pca963x);\r\n*delay_on = time_on;\r\n*delay_off = time_off;\r\nreturn 0;\r\n}\r\nstatic struct pca963x_platform_data *\r\npca963x_dt_init(struct i2c_client *client, struct pca963x_chipdef *chip)\r\n{\r\nstruct device_node *np = client->dev.of_node, *child;\r\nstruct pca963x_platform_data *pdata;\r\nstruct led_info *pca963x_leds;\r\nint count;\r\ncount = of_get_child_count(np);\r\nif (!count || count > chip->n_leds)\r\nreturn ERR_PTR(-ENODEV);\r\npca963x_leds = devm_kzalloc(&client->dev,\r\nsizeof(struct led_info) * chip->n_leds, GFP_KERNEL);\r\nif (!pca963x_leds)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor_each_child_of_node(np, child) {\r\nstruct led_info led = {};\r\nu32 reg;\r\nint res;\r\nres = of_property_read_u32(child, "reg", &reg);\r\nif ((res != 0) || (reg >= chip->n_leds))\r\ncontinue;\r\nled.name =\r\nof_get_property(child, "label", NULL) ? : child->name;\r\nled.default_trigger =\r\nof_get_property(child, "linux,default-trigger", NULL);\r\npca963x_leds[reg] = led;\r\n}\r\npdata = devm_kzalloc(&client->dev,\r\nsizeof(struct pca963x_platform_data), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\npdata->leds.leds = pca963x_leds;\r\npdata->leds.num_leds = chip->n_leds;\r\nif (of_property_read_bool(np, "nxp,totem-pole"))\r\npdata->outdrv = PCA963X_TOTEM_POLE;\r\nelse\r\npdata->outdrv = PCA963X_OPEN_DRAIN;\r\nif (of_property_read_bool(np, "nxp,hw-blink"))\r\npdata->blink_type = PCA963X_HW_BLINK;\r\nelse\r\npdata->blink_type = PCA963X_SW_BLINK;\r\nif (of_property_read_u32(np, "nxp,period-scale", &chip->scaling))\r\nchip->scaling = 1000;\r\nif (of_property_read_bool(np, "nxp,inverted-out"))\r\npdata->dir = PCA963X_INVERTED;\r\nelse\r\npdata->dir = PCA963X_NORMAL;\r\nreturn pdata;\r\n}\r\nstatic struct pca963x_platform_data *\r\npca963x_dt_init(struct i2c_client *client, struct pca963x_chipdef *chip)\r\n{\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic int pca963x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pca963x *pca963x_chip;\r\nstruct pca963x_led *pca963x;\r\nstruct pca963x_platform_data *pdata;\r\nstruct pca963x_chipdef *chip;\r\nint i, err;\r\nif (id) {\r\nchip = &pca963x_chipdefs[id->driver_data];\r\n} else {\r\nconst struct acpi_device_id *acpi_id;\r\nacpi_id = acpi_match_device(pca963x_acpi_ids, &client->dev);\r\nif (!acpi_id)\r\nreturn -ENODEV;\r\nchip = &pca963x_chipdefs[acpi_id->driver_data];\r\n}\r\npdata = dev_get_platdata(&client->dev);\r\nif (!pdata) {\r\npdata = pca963x_dt_init(client, chip);\r\nif (IS_ERR(pdata)) {\r\ndev_warn(&client->dev, "could not parse configuration\n");\r\npdata = NULL;\r\n}\r\n}\r\nif (pdata && (pdata->leds.num_leds < 1 ||\r\npdata->leds.num_leds > chip->n_leds)) {\r\ndev_err(&client->dev, "board info must claim 1-%d LEDs",\r\nchip->n_leds);\r\nreturn -EINVAL;\r\n}\r\npca963x_chip = devm_kzalloc(&client->dev, sizeof(*pca963x_chip),\r\nGFP_KERNEL);\r\nif (!pca963x_chip)\r\nreturn -ENOMEM;\r\npca963x = devm_kzalloc(&client->dev, chip->n_leds * sizeof(*pca963x),\r\nGFP_KERNEL);\r\nif (!pca963x)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, pca963x_chip);\r\nmutex_init(&pca963x_chip->mutex);\r\npca963x_chip->chipdef = chip;\r\npca963x_chip->client = client;\r\npca963x_chip->leds = pca963x;\r\nfor (i = 0; i < chip->n_leds / 4; i++)\r\ni2c_smbus_write_byte_data(client, chip->ledout_base + i, 0x00);\r\nfor (i = 0; i < chip->n_leds; i++) {\r\npca963x[i].led_num = i;\r\npca963x[i].chip = pca963x_chip;\r\nif (pdata && i < pdata->leds.num_leds) {\r\nif (pdata->leds.leds[i].name)\r\nsnprintf(pca963x[i].name,\r\nsizeof(pca963x[i].name), "pca963x:%s",\r\npdata->leds.leds[i].name);\r\nif (pdata->leds.leds[i].default_trigger)\r\npca963x[i].led_cdev.default_trigger =\r\npdata->leds.leds[i].default_trigger;\r\n}\r\nif (!pdata || i >= pdata->leds.num_leds ||\r\n!pdata->leds.leds[i].name)\r\nsnprintf(pca963x[i].name, sizeof(pca963x[i].name),\r\n"pca963x:%d:%.2x:%d", client->adapter->nr,\r\nclient->addr, i);\r\npca963x[i].led_cdev.name = pca963x[i].name;\r\npca963x[i].led_cdev.brightness_set_blocking = pca963x_led_set;\r\nif (pdata && pdata->blink_type == PCA963X_HW_BLINK)\r\npca963x[i].led_cdev.blink_set = pca963x_blink_set;\r\nerr = led_classdev_register(&client->dev, &pca963x[i].led_cdev);\r\nif (err < 0)\r\ngoto exit;\r\n}\r\ni2c_smbus_write_byte_data(client, PCA963X_MODE1, BIT(4));\r\nif (pdata) {\r\nu8 mode2 = i2c_smbus_read_byte_data(pca963x->chip->client,\r\nPCA963X_MODE2);\r\nif (pdata->outdrv == PCA963X_OPEN_DRAIN)\r\nmode2 |= 0x01;\r\nelse\r\nmode2 |= 0x05;\r\nif (pdata->dir == PCA963X_INVERTED)\r\nmode2 |= 0x10;\r\ni2c_smbus_write_byte_data(pca963x->chip->client, PCA963X_MODE2,\r\nmode2);\r\n}\r\nreturn 0;\r\nexit:\r\nwhile (i--)\r\nled_classdev_unregister(&pca963x[i].led_cdev);\r\nreturn err;\r\n}\r\nstatic int pca963x_remove(struct i2c_client *client)\r\n{\r\nstruct pca963x *pca963x = i2c_get_clientdata(client);\r\nint i;\r\nfor (i = 0; i < pca963x->chipdef->n_leds; i++)\r\nled_classdev_unregister(&pca963x->leds[i].led_cdev);\r\nreturn 0;\r\n}
