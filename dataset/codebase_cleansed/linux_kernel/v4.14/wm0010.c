static const char *wm0010_state_to_str(enum wm0010_state state)\r\n{\r\nstatic const char * const state_to_str[] = {\r\n"Power off",\r\n"Out of reset",\r\n"Boot ROM",\r\n"Stage2",\r\n"Firmware"\r\n};\r\nif (state < 0 || state >= ARRAY_SIZE(state_to_str))\r\nreturn "null";\r\nreturn state_to_str[state];\r\n}\r\nstatic void wm0010_halt(struct snd_soc_codec *codec)\r\n{\r\nstruct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);\r\nunsigned long flags;\r\nenum wm0010_state state;\r\nspin_lock_irqsave(&wm0010->irq_lock, flags);\r\nstate = wm0010->state;\r\nspin_unlock_irqrestore(&wm0010->irq_lock, flags);\r\nswitch (state) {\r\ncase WM0010_POWER_OFF:\r\nreturn;\r\ncase WM0010_OUT_OF_RESET:\r\ncase WM0010_BOOTROM:\r\ncase WM0010_STAGE2:\r\ncase WM0010_FIRMWARE:\r\ngpio_set_value_cansleep(wm0010->gpio_reset,\r\nwm0010->gpio_reset_value);\r\nregulator_disable(wm0010->dbvdd);\r\nregulator_bulk_disable(ARRAY_SIZE(wm0010->core_supplies),\r\nwm0010->core_supplies);\r\nbreak;\r\n}\r\nspin_lock_irqsave(&wm0010->irq_lock, flags);\r\nwm0010->state = WM0010_POWER_OFF;\r\nspin_unlock_irqrestore(&wm0010->irq_lock, flags);\r\n}\r\nstatic void wm0010_mark_boot_failure(struct wm0010_priv *wm0010)\r\n{\r\nenum wm0010_state state;\r\nunsigned long flags;\r\nspin_lock_irqsave(&wm0010->irq_lock, flags);\r\nstate = wm0010->state;\r\nspin_unlock_irqrestore(&wm0010->irq_lock, flags);\r\ndev_err(wm0010->dev, "Failed to transition from `%s' state to `%s' state\n",\r\nwm0010_state_to_str(state), wm0010_state_to_str(state + 1));\r\nwm0010->boot_failed = true;\r\n}\r\nstatic void wm0010_boot_xfer_complete(void *data)\r\n{\r\nstruct wm0010_boot_xfer *xfer = data;\r\nstruct snd_soc_codec *codec = xfer->codec;\r\nstruct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);\r\nu32 *out32 = xfer->t.rx_buf;\r\nint i;\r\nif (xfer->m.status != 0) {\r\ndev_err(codec->dev, "SPI transfer failed: %d\n",\r\nxfer->m.status);\r\nwm0010_mark_boot_failure(wm0010);\r\nif (xfer->done)\r\ncomplete(xfer->done);\r\nreturn;\r\n}\r\nfor (i = 0; i < xfer->t.len / 4; i++) {\r\ndev_dbg(codec->dev, "%d: %04x\n", i, out32[i]);\r\nswitch (be32_to_cpu(out32[i])) {\r\ncase 0xe0e0e0e0:\r\ndev_err(codec->dev,\r\n"%d: ROM error reported in stage 2\n", i);\r\nwm0010_mark_boot_failure(wm0010);\r\nbreak;\r\ncase 0x55555555:\r\nif (wm0010->state < WM0010_STAGE2)\r\nbreak;\r\ndev_err(codec->dev,\r\n"%d: ROM bootloader running in stage 2\n", i);\r\nwm0010_mark_boot_failure(wm0010);\r\nbreak;\r\ncase 0x0fed0000:\r\ndev_dbg(codec->dev, "Stage2 loader running\n");\r\nbreak;\r\ncase 0x0fed0007:\r\ndev_dbg(codec->dev, "CODE_HDR packet received\n");\r\nbreak;\r\ncase 0x0fed0008:\r\ndev_dbg(codec->dev, "CODE_DATA packet received\n");\r\nbreak;\r\ncase 0x0fed0009:\r\ndev_dbg(codec->dev, "Download complete\n");\r\nbreak;\r\ncase 0x0fed000c:\r\ndev_dbg(codec->dev, "Application start\n");\r\nbreak;\r\ncase 0x0fed000e:\r\ndev_dbg(codec->dev, "PLL packet received\n");\r\nwm0010->pll_running = true;\r\nbreak;\r\ncase 0x0fed0025:\r\ndev_err(codec->dev, "Device reports image too long\n");\r\nwm0010_mark_boot_failure(wm0010);\r\nbreak;\r\ncase 0x0fed002c:\r\ndev_err(codec->dev, "Device reports bad SPI packet\n");\r\nwm0010_mark_boot_failure(wm0010);\r\nbreak;\r\ncase 0x0fed0031:\r\ndev_err(codec->dev, "Device reports SPI read overflow\n");\r\nwm0010_mark_boot_failure(wm0010);\r\nbreak;\r\ncase 0x0fed0032:\r\ndev_err(codec->dev, "Device reports SPI underclock\n");\r\nwm0010_mark_boot_failure(wm0010);\r\nbreak;\r\ncase 0x0fed0033:\r\ndev_err(codec->dev, "Device reports bad header packet\n");\r\nwm0010_mark_boot_failure(wm0010);\r\nbreak;\r\ncase 0x0fed0034:\r\ndev_err(codec->dev, "Device reports invalid packet type\n");\r\nwm0010_mark_boot_failure(wm0010);\r\nbreak;\r\ncase 0x0fed0035:\r\ndev_err(codec->dev, "Device reports data before header error\n");\r\nwm0010_mark_boot_failure(wm0010);\r\nbreak;\r\ncase 0x0fed0038:\r\ndev_err(codec->dev, "Device reports invalid PLL packet\n");\r\nbreak;\r\ncase 0x0fed003a:\r\ndev_err(codec->dev, "Device reports packet alignment error\n");\r\nwm0010_mark_boot_failure(wm0010);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unrecognised return 0x%x\n",\r\nbe32_to_cpu(out32[i]));\r\nwm0010_mark_boot_failure(wm0010);\r\nbreak;\r\n}\r\nif (wm0010->boot_failed)\r\nbreak;\r\n}\r\nif (xfer->done)\r\ncomplete(xfer->done);\r\n}\r\nstatic void byte_swap_64(u64 *data_in, u64 *data_out, u32 len)\r\n{\r\nint i;\r\nfor (i = 0; i < len / 8; i++)\r\ndata_out[i] = cpu_to_be64(le64_to_cpu(data_in[i]));\r\n}\r\nstatic int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)\r\n{\r\nstruct spi_device *spi = to_spi_device(codec->dev);\r\nstruct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);\r\nstruct list_head xfer_list;\r\nstruct wm0010_boot_xfer *xfer;\r\nint ret;\r\nstruct completion done;\r\nconst struct firmware *fw;\r\nconst struct dfw_binrec *rec;\r\nconst struct dfw_inforec *inforec;\r\nu64 *img;\r\nu8 *out, dsp;\r\nu32 len, offset;\r\nINIT_LIST_HEAD(&xfer_list);\r\nret = request_firmware(&fw, name, codec->dev);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to request application(%s): %d\n",\r\nname, ret);\r\nreturn ret;\r\n}\r\nrec = (const struct dfw_binrec *)fw->data;\r\ninforec = (const struct dfw_inforec *)rec->data;\r\noffset = 0;\r\ndsp = inforec->dsp_target;\r\nwm0010->boot_failed = false;\r\nif (WARN_ON(!list_empty(&xfer_list)))\r\nreturn -EINVAL;\r\ninit_completion(&done);\r\nif (rec->command != DFW_CMD_INFO) {\r\ndev_err(codec->dev, "First record not INFO\r\n");\r\nret = -EINVAL;\r\ngoto abort;\r\n}\r\nif (inforec->info_version != INFO_VERSION) {\r\ndev_err(codec->dev,\r\n"Unsupported version (%02d) of INFO record\r\n",\r\ninforec->info_version);\r\nret = -EINVAL;\r\ngoto abort;\r\n}\r\ndev_dbg(codec->dev, "Version v%02d INFO record found\r\n",\r\ninforec->info_version);\r\nif (dsp != DEVICE_ID_WM0010) {\r\ndev_err(codec->dev, "Not a WM0010 firmware file.\r\n");\r\nret = -EINVAL;\r\ngoto abort;\r\n}\r\noffset += ((rec->length) + 8);\r\nrec = (void *)&rec->data[rec->length];\r\nwhile (offset < fw->size) {\r\ndev_dbg(codec->dev,\r\n"Packet: command %d, data length = 0x%x\r\n",\r\nrec->command, rec->length);\r\nlen = rec->length + 8;\r\nxfer = kzalloc(sizeof(*xfer), GFP_KERNEL);\r\nif (!xfer) {\r\nret = -ENOMEM;\r\ngoto abort;\r\n}\r\nxfer->codec = codec;\r\nlist_add_tail(&xfer->list, &xfer_list);\r\nout = kzalloc(len, GFP_KERNEL | GFP_DMA);\r\nif (!out) {\r\nret = -ENOMEM;\r\ngoto abort1;\r\n}\r\nxfer->t.rx_buf = out;\r\nimg = kzalloc(len, GFP_KERNEL | GFP_DMA);\r\nif (!img) {\r\nret = -ENOMEM;\r\ngoto abort1;\r\n}\r\nxfer->t.tx_buf = img;\r\nbyte_swap_64((u64 *)&rec->command, img, len);\r\nspi_message_init(&xfer->m);\r\nxfer->m.complete = wm0010_boot_xfer_complete;\r\nxfer->m.context = xfer;\r\nxfer->t.len = len;\r\nxfer->t.bits_per_word = 8;\r\nif (!wm0010->pll_running) {\r\nxfer->t.speed_hz = wm0010->sysclk / 6;\r\n} else {\r\nxfer->t.speed_hz = wm0010->max_spi_freq;\r\nif (wm0010->board_max_spi_speed &&\r\n(wm0010->board_max_spi_speed < wm0010->max_spi_freq))\r\nxfer->t.speed_hz = wm0010->board_max_spi_speed;\r\n}\r\nwm0010->max_spi_freq = xfer->t.speed_hz;\r\nspi_message_add_tail(&xfer->t, &xfer->m);\r\noffset += ((rec->length) + 8);\r\nrec = (void *)&rec->data[rec->length];\r\nif (offset >= fw->size) {\r\ndev_dbg(codec->dev, "All transfers scheduled\n");\r\nxfer->done = &done;\r\n}\r\nret = spi_async(spi, &xfer->m);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Write failed: %d\n", ret);\r\ngoto abort1;\r\n}\r\nif (wm0010->boot_failed) {\r\ndev_dbg(codec->dev, "Boot fail!\n");\r\nret = -EINVAL;\r\ngoto abort1;\r\n}\r\n}\r\nwait_for_completion(&done);\r\nret = 0;\r\nabort1:\r\nwhile (!list_empty(&xfer_list)) {\r\nxfer = list_first_entry(&xfer_list, struct wm0010_boot_xfer,\r\nlist);\r\nkfree(xfer->t.rx_buf);\r\nkfree(xfer->t.tx_buf);\r\nlist_del(&xfer->list);\r\nkfree(xfer);\r\n}\r\nabort:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int wm0010_stage2_load(struct snd_soc_codec *codec)\r\n{\r\nstruct spi_device *spi = to_spi_device(codec->dev);\r\nstruct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);\r\nconst struct firmware *fw;\r\nstruct spi_message m;\r\nstruct spi_transfer t;\r\nu32 *img;\r\nu8 *out;\r\nint i;\r\nint ret = 0;\r\nret = request_firmware(&fw, "wm0010_stage2.bin", codec->dev);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to request stage2 loader: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ndev_dbg(codec->dev, "Downloading %zu byte stage 2 loader\n", fw->size);\r\nimg = kzalloc(fw->size, GFP_KERNEL | GFP_DMA);\r\nif (!img) {\r\nret = -ENOMEM;\r\ngoto abort2;\r\n}\r\nout = kzalloc(fw->size, GFP_KERNEL | GFP_DMA);\r\nif (!out) {\r\nret = -ENOMEM;\r\ngoto abort1;\r\n}\r\nmemcpy(img, &fw->data[0], fw->size);\r\nspi_message_init(&m);\r\nmemset(&t, 0, sizeof(t));\r\nt.rx_buf = out;\r\nt.tx_buf = img;\r\nt.len = fw->size;\r\nt.bits_per_word = 8;\r\nt.speed_hz = wm0010->sysclk / 10;\r\nspi_message_add_tail(&t, &m);\r\ndev_dbg(codec->dev, "Starting initial download at %dHz\n",\r\nt.speed_hz);\r\nret = spi_sync(spi, &m);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Initial download failed: %d\n", ret);\r\ngoto abort;\r\n}\r\nfor (i = 0; i < fw->size; i++) {\r\nif (out[i] != 0x55) {\r\ndev_err(codec->dev, "Boot ROM error: %x in %d\n",\r\nout[i], i);\r\nwm0010_mark_boot_failure(wm0010);\r\nret = -EBUSY;\r\ngoto abort;\r\n}\r\n}\r\nabort:\r\nkfree(out);\r\nabort1:\r\nkfree(img);\r\nabort2:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int wm0010_boot(struct snd_soc_codec *codec)\r\n{\r\nstruct spi_device *spi = to_spi_device(codec->dev);\r\nstruct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);\r\nunsigned long flags;\r\nint ret;\r\nstruct spi_message m;\r\nstruct spi_transfer t;\r\nstruct dfw_pllrec pll_rec;\r\nu32 *p, len;\r\nu64 *img_swap;\r\nu8 *out;\r\nint i;\r\nspin_lock_irqsave(&wm0010->irq_lock, flags);\r\nif (wm0010->state != WM0010_POWER_OFF)\r\ndev_warn(wm0010->dev, "DSP already powered up!\n");\r\nspin_unlock_irqrestore(&wm0010->irq_lock, flags);\r\nif (wm0010->sysclk > 26000000) {\r\ndev_err(codec->dev, "Max DSP clock frequency is 26MHz\n");\r\nret = -ECANCELED;\r\ngoto err;\r\n}\r\nmutex_lock(&wm0010->lock);\r\nwm0010->pll_running = false;\r\ndev_dbg(codec->dev, "max_spi_freq: %d\n", wm0010->max_spi_freq);\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm0010->core_supplies),\r\nwm0010->core_supplies);\r\nif (ret != 0) {\r\ndev_err(&spi->dev, "Failed to enable core supplies: %d\n",\r\nret);\r\nmutex_unlock(&wm0010->lock);\r\ngoto err;\r\n}\r\nret = regulator_enable(wm0010->dbvdd);\r\nif (ret != 0) {\r\ndev_err(&spi->dev, "Failed to enable DBVDD: %d\n", ret);\r\ngoto err_core;\r\n}\r\ngpio_set_value_cansleep(wm0010->gpio_reset, !wm0010->gpio_reset_value);\r\nspin_lock_irqsave(&wm0010->irq_lock, flags);\r\nwm0010->state = WM0010_OUT_OF_RESET;\r\nspin_unlock_irqrestore(&wm0010->irq_lock, flags);\r\nif (!wait_for_completion_timeout(&wm0010->boot_completion,\r\nmsecs_to_jiffies(20)))\r\ndev_err(codec->dev, "Failed to get interrupt from DSP\n");\r\nspin_lock_irqsave(&wm0010->irq_lock, flags);\r\nwm0010->state = WM0010_BOOTROM;\r\nspin_unlock_irqrestore(&wm0010->irq_lock, flags);\r\nret = wm0010_stage2_load(codec);\r\nif (ret)\r\ngoto abort;\r\nif (!wait_for_completion_timeout(&wm0010->boot_completion,\r\nmsecs_to_jiffies(20)))\r\ndev_err(codec->dev, "Failed to get interrupt from DSP loader.\n");\r\nspin_lock_irqsave(&wm0010->irq_lock, flags);\r\nwm0010->state = WM0010_STAGE2;\r\nspin_unlock_irqrestore(&wm0010->irq_lock, flags);\r\nif (wm0010->max_spi_freq) {\r\nmemset(&pll_rec, 0, sizeof(pll_rec));\r\npll_rec.command = DFW_CMD_PLL;\r\npll_rec.length = (sizeof(pll_rec) - 8);\r\npll_rec.clkctrl1 = wm0010->pll_clkctrl1;\r\nret = -ENOMEM;\r\nlen = pll_rec.length + 8;\r\nout = kzalloc(len, GFP_KERNEL | GFP_DMA);\r\nif (!out) {\r\ndev_err(codec->dev,\r\n"Failed to allocate RX buffer\n");\r\ngoto abort;\r\n}\r\nimg_swap = kzalloc(len, GFP_KERNEL | GFP_DMA);\r\nif (!img_swap)\r\ngoto abort_out;\r\nbyte_swap_64((u64 *)&pll_rec, img_swap, len);\r\nspi_message_init(&m);\r\nmemset(&t, 0, sizeof(t));\r\nt.rx_buf = out;\r\nt.tx_buf = img_swap;\r\nt.len = len;\r\nt.bits_per_word = 8;\r\nt.speed_hz = wm0010->sysclk / 6;\r\nspi_message_add_tail(&t, &m);\r\nret = spi_sync(spi, &m);\r\nif (ret) {\r\ndev_err(codec->dev, "First PLL write failed: %d\n", ret);\r\ngoto abort_swap;\r\n}\r\nret = spi_sync(spi, &m);\r\nif (ret) {\r\ndev_err(codec->dev, "Second PLL write failed: %d\n", ret);\r\ngoto abort_swap;\r\n}\r\np = (u32 *)out;\r\nfor (i = 0; i < len / 4; i++) {\r\nif (*p == 0x0e00ed0f) {\r\ndev_dbg(codec->dev, "PLL packet received\n");\r\nwm0010->pll_running = true;\r\nbreak;\r\n}\r\np++;\r\n}\r\nkfree(img_swap);\r\nkfree(out);\r\n} else\r\ndev_dbg(codec->dev, "Not enabling DSP PLL.");\r\nret = wm0010_firmware_load("wm0010.dfw", codec);\r\nif (ret != 0)\r\ngoto abort;\r\nspin_lock_irqsave(&wm0010->irq_lock, flags);\r\nwm0010->state = WM0010_FIRMWARE;\r\nspin_unlock_irqrestore(&wm0010->irq_lock, flags);\r\nmutex_unlock(&wm0010->lock);\r\nreturn 0;\r\nabort_swap:\r\nkfree(img_swap);\r\nabort_out:\r\nkfree(out);\r\nabort:\r\nwm0010_halt(codec);\r\nmutex_unlock(&wm0010->lock);\r\nreturn ret;\r\nerr_core:\r\nmutex_unlock(&wm0010->lock);\r\nregulator_bulk_disable(ARRAY_SIZE(wm0010->core_supplies),\r\nwm0010->core_supplies);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int wm0010_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_PREPARE)\r\nwm0010_boot(codec);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_PREPARE) {\r\nmutex_lock(&wm0010->lock);\r\nwm0010_halt(codec);\r\nmutex_unlock(&wm0010->lock);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm0010_set_sysclk(struct snd_soc_codec *codec, int source,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int i;\r\nwm0010->sysclk = freq;\r\nif (freq < pll_clock_map[ARRAY_SIZE(pll_clock_map)-1].max_sysclk) {\r\nwm0010->max_spi_freq = 0;\r\n} else {\r\nfor (i = 0; i < ARRAY_SIZE(pll_clock_map); i++)\r\nif (freq >= pll_clock_map[i].max_sysclk) {\r\nwm0010->max_spi_freq = pll_clock_map[i].max_pll_spi_speed;\r\nwm0010->pll_clkctrl1 = pll_clock_map[i].pll_clkctrl1;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t wm0010_irq(int irq, void *data)\r\n{\r\nstruct wm0010_priv *wm0010 = data;\r\nswitch (wm0010->state) {\r\ncase WM0010_OUT_OF_RESET:\r\ncase WM0010_BOOTROM:\r\ncase WM0010_STAGE2:\r\nspin_lock(&wm0010->irq_lock);\r\ncomplete(&wm0010->boot_completion);\r\nspin_unlock(&wm0010->irq_lock);\r\nreturn IRQ_HANDLED;\r\ndefault:\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int wm0010_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);\r\nwm0010->codec = codec;\r\nreturn 0;\r\n}\r\nstatic int wm0010_spi_probe(struct spi_device *spi)\r\n{\r\nunsigned long gpio_flags;\r\nint ret;\r\nint trigger;\r\nint irq;\r\nstruct wm0010_priv *wm0010;\r\nwm0010 = devm_kzalloc(&spi->dev, sizeof(*wm0010),\r\nGFP_KERNEL);\r\nif (!wm0010)\r\nreturn -ENOMEM;\r\nmutex_init(&wm0010->lock);\r\nspin_lock_init(&wm0010->irq_lock);\r\nspi_set_drvdata(spi, wm0010);\r\nwm0010->dev = &spi->dev;\r\nif (dev_get_platdata(&spi->dev))\r\nmemcpy(&wm0010->pdata, dev_get_platdata(&spi->dev),\r\nsizeof(wm0010->pdata));\r\ninit_completion(&wm0010->boot_completion);\r\nwm0010->core_supplies[0].supply = "AVDD";\r\nwm0010->core_supplies[1].supply = "DCVDD";\r\nret = devm_regulator_bulk_get(wm0010->dev, ARRAY_SIZE(wm0010->core_supplies),\r\nwm0010->core_supplies);\r\nif (ret != 0) {\r\ndev_err(wm0010->dev, "Failed to obtain core supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nwm0010->dbvdd = devm_regulator_get(wm0010->dev, "DBVDD");\r\nif (IS_ERR(wm0010->dbvdd)) {\r\nret = PTR_ERR(wm0010->dbvdd);\r\ndev_err(wm0010->dev, "Failed to obtain DBVDD: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (wm0010->pdata.gpio_reset) {\r\nwm0010->gpio_reset = wm0010->pdata.gpio_reset;\r\nif (wm0010->pdata.reset_active_high)\r\nwm0010->gpio_reset_value = 1;\r\nelse\r\nwm0010->gpio_reset_value = 0;\r\nif (wm0010->gpio_reset_value)\r\ngpio_flags = GPIOF_OUT_INIT_HIGH;\r\nelse\r\ngpio_flags = GPIOF_OUT_INIT_LOW;\r\nret = devm_gpio_request_one(wm0010->dev, wm0010->gpio_reset,\r\ngpio_flags, "wm0010 reset");\r\nif (ret < 0) {\r\ndev_err(wm0010->dev,\r\n"Failed to request GPIO for DSP reset: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n} else {\r\ndev_err(wm0010->dev, "No reset GPIO configured\n");\r\nreturn -EINVAL;\r\n}\r\nwm0010->state = WM0010_POWER_OFF;\r\nirq = spi->irq;\r\nif (wm0010->pdata.irq_flags)\r\ntrigger = wm0010->pdata.irq_flags;\r\nelse\r\ntrigger = IRQF_TRIGGER_FALLING;\r\ntrigger |= IRQF_ONESHOT;\r\nret = request_threaded_irq(irq, NULL, wm0010_irq, trigger,\r\n"wm0010", wm0010);\r\nif (ret) {\r\ndev_err(wm0010->dev, "Failed to request IRQ %d: %d\n",\r\nirq, ret);\r\nreturn ret;\r\n}\r\nwm0010->irq = irq;\r\nret = irq_set_irq_wake(irq, 1);\r\nif (ret) {\r\ndev_err(wm0010->dev, "Failed to set IRQ %d as wake source: %d\n",\r\nirq, ret);\r\nreturn ret;\r\n}\r\nif (spi->max_speed_hz)\r\nwm0010->board_max_spi_speed = spi->max_speed_hz;\r\nelse\r\nwm0010->board_max_spi_speed = 0;\r\nret = snd_soc_register_codec(&spi->dev,\r\n&soc_codec_dev_wm0010, wm0010_dai,\r\nARRAY_SIZE(wm0010_dai));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int wm0010_spi_remove(struct spi_device *spi)\r\n{\r\nstruct wm0010_priv *wm0010 = spi_get_drvdata(spi);\r\nsnd_soc_unregister_codec(&spi->dev);\r\ngpio_set_value_cansleep(wm0010->gpio_reset,\r\nwm0010->gpio_reset_value);\r\nirq_set_irq_wake(wm0010->irq, 0);\r\nif (wm0010->irq)\r\nfree_irq(wm0010->irq, wm0010);\r\nreturn 0;\r\n}
