static char *drm_devnode(struct device *dev, umode_t *mode)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "dri/%s", dev_name(dev));\r\n}\r\nint drm_sysfs_init(void)\r\n{\r\nint err;\r\ndrm_class = class_create(THIS_MODULE, "drm");\r\nif (IS_ERR(drm_class))\r\nreturn PTR_ERR(drm_class);\r\nerr = class_create_file(drm_class, &class_attr_version.attr);\r\nif (err) {\r\nclass_destroy(drm_class);\r\ndrm_class = NULL;\r\nreturn err;\r\n}\r\ndrm_class->devnode = drm_devnode;\r\nreturn 0;\r\n}\r\nvoid drm_sysfs_destroy(void)\r\n{\r\nif (IS_ERR_OR_NULL(drm_class))\r\nreturn;\r\nclass_remove_file(drm_class, &class_attr_version.attr);\r\nclass_destroy(drm_class);\r\ndrm_class = NULL;\r\n}\r\nstatic ssize_t status_store(struct device *device,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_connector *connector = to_drm_connector(device);\r\nstruct drm_device *dev = connector->dev;\r\nenum drm_connector_force old_force;\r\nint ret;\r\nret = mutex_lock_interruptible(&dev->mode_config.mutex);\r\nif (ret)\r\nreturn ret;\r\nold_force = connector->force;\r\nif (sysfs_streq(buf, "detect"))\r\nconnector->force = 0;\r\nelse if (sysfs_streq(buf, "on"))\r\nconnector->force = DRM_FORCE_ON;\r\nelse if (sysfs_streq(buf, "on-digital"))\r\nconnector->force = DRM_FORCE_ON_DIGITAL;\r\nelse if (sysfs_streq(buf, "off"))\r\nconnector->force = DRM_FORCE_OFF;\r\nelse\r\nret = -EINVAL;\r\nif (old_force != connector->force || !connector->force) {\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] force updated from %d to %d or reprobing\n",\r\nconnector->base.id,\r\nconnector->name,\r\nold_force, connector->force);\r\nconnector->funcs->fill_modes(connector,\r\ndev->mode_config.max_width,\r\ndev->mode_config.max_height);\r\n}\r\nmutex_unlock(&dev->mode_config.mutex);\r\nreturn ret ? ret : count;\r\n}\r\nstatic ssize_t status_show(struct device *device,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_connector *connector = to_drm_connector(device);\r\nenum drm_connector_status status;\r\nstatus = READ_ONCE(connector->status);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\ndrm_get_connector_status_name(status));\r\n}\r\nstatic ssize_t dpms_show(struct device *device,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_connector *connector = to_drm_connector(device);\r\nint dpms;\r\ndpms = READ_ONCE(connector->dpms);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\ndrm_get_dpms_name(dpms));\r\n}\r\nstatic ssize_t enabled_show(struct device *device,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_connector *connector = to_drm_connector(device);\r\nbool enabled;\r\nenabled = READ_ONCE(connector->encoder);\r\nreturn snprintf(buf, PAGE_SIZE, enabled ? "enabled\n" : "disabled\n");\r\n}\r\nstatic ssize_t edid_show(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf, loff_t off,\r\nsize_t count)\r\n{\r\nstruct device *connector_dev = kobj_to_dev(kobj);\r\nstruct drm_connector *connector = to_drm_connector(connector_dev);\r\nunsigned char *edid;\r\nsize_t size;\r\nssize_t ret = 0;\r\nmutex_lock(&connector->dev->mode_config.mutex);\r\nif (!connector->edid_blob_ptr)\r\ngoto unlock;\r\nedid = connector->edid_blob_ptr->data;\r\nsize = connector->edid_blob_ptr->length;\r\nif (!edid)\r\ngoto unlock;\r\nif (off >= size)\r\ngoto unlock;\r\nif (off + count > size)\r\ncount = size - off;\r\nmemcpy(buf, edid + off, count);\r\nret = count;\r\nunlock:\r\nmutex_unlock(&connector->dev->mode_config.mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t modes_show(struct device *device,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_connector *connector = to_drm_connector(device);\r\nstruct drm_display_mode *mode;\r\nint written = 0;\r\nmutex_lock(&connector->dev->mode_config.mutex);\r\nlist_for_each_entry(mode, &connector->modes, head) {\r\nwritten += snprintf(buf + written, PAGE_SIZE - written, "%s\n",\r\nmode->name);\r\n}\r\nmutex_unlock(&connector->dev->mode_config.mutex);\r\nreturn written;\r\n}\r\nint drm_sysfs_connector_add(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nif (connector->kdev)\r\nreturn 0;\r\nconnector->kdev =\r\ndevice_create_with_groups(drm_class, dev->primary->kdev, 0,\r\nconnector, connector_dev_groups,\r\n"card%d-%s", dev->primary->index,\r\nconnector->name);\r\nDRM_DEBUG("adding \"%s\" to sysfs\n",\r\nconnector->name);\r\nif (IS_ERR(connector->kdev)) {\r\nDRM_ERROR("failed to register connector device: %ld\n", PTR_ERR(connector->kdev));\r\nreturn PTR_ERR(connector->kdev);\r\n}\r\ndrm_sysfs_hotplug_event(dev);\r\nreturn 0;\r\n}\r\nvoid drm_sysfs_connector_remove(struct drm_connector *connector)\r\n{\r\nif (!connector->kdev)\r\nreturn;\r\nDRM_DEBUG("removing \"%s\" from sysfs\n",\r\nconnector->name);\r\ndevice_unregister(connector->kdev);\r\nconnector->kdev = NULL;\r\n}\r\nvoid drm_sysfs_hotplug_event(struct drm_device *dev)\r\n{\r\nchar *event_string = "HOTPLUG=1";\r\nchar *envp[] = { event_string, NULL };\r\nDRM_DEBUG("generating hotplug event\n");\r\nkobject_uevent_env(&dev->primary->kdev->kobj, KOBJ_CHANGE, envp);\r\n}\r\nstatic void drm_sysfs_release(struct device *dev)\r\n{\r\nkfree(dev);\r\n}\r\nstruct device *drm_sysfs_minor_alloc(struct drm_minor *minor)\r\n{\r\nconst char *minor_str;\r\nstruct device *kdev;\r\nint r;\r\nif (minor->type == DRM_MINOR_CONTROL)\r\nminor_str = "controlD%d";\r\nelse if (minor->type == DRM_MINOR_RENDER)\r\nminor_str = "renderD%d";\r\nelse\r\nminor_str = "card%d";\r\nkdev = kzalloc(sizeof(*kdev), GFP_KERNEL);\r\nif (!kdev)\r\nreturn ERR_PTR(-ENOMEM);\r\ndevice_initialize(kdev);\r\nkdev->devt = MKDEV(DRM_MAJOR, minor->index);\r\nkdev->class = drm_class;\r\nkdev->type = &drm_sysfs_device_minor;\r\nkdev->parent = minor->dev->dev;\r\nkdev->release = drm_sysfs_release;\r\ndev_set_drvdata(kdev, minor);\r\nr = dev_set_name(kdev, minor_str, minor->index);\r\nif (r < 0)\r\ngoto err_free;\r\nreturn kdev;\r\nerr_free:\r\nput_device(kdev);\r\nreturn ERR_PTR(r);\r\n}\r\nint drm_class_device_register(struct device *dev)\r\n{\r\nif (!drm_class || IS_ERR(drm_class))\r\nreturn -ENOENT;\r\ndev->class = drm_class;\r\nreturn device_register(dev);\r\n}\r\nvoid drm_class_device_unregister(struct device *dev)\r\n{\r\nreturn device_unregister(dev);\r\n}
