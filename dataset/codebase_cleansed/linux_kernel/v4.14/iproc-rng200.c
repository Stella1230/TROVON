static void iproc_rng200_restart(void __iomem *rng_base)\r\n{\r\nuint32_t val;\r\nval = ioread32(rng_base + RNG_CTRL_OFFSET);\r\nval &= ~RNG_CTRL_RNG_RBGEN_MASK;\r\nval |= RNG_CTRL_RNG_RBGEN_DISABLE;\r\niowrite32(val, rng_base + RNG_CTRL_OFFSET);\r\niowrite32(0xFFFFFFFFUL, rng_base + RNG_INT_STATUS_OFFSET);\r\nval = ioread32(rng_base + RBG_SOFT_RESET_OFFSET);\r\nval |= RBG_SOFT_RESET;\r\niowrite32(val, rng_base + RBG_SOFT_RESET_OFFSET);\r\nval = ioread32(rng_base + RNG_SOFT_RESET_OFFSET);\r\nval |= RNG_SOFT_RESET;\r\niowrite32(val, rng_base + RNG_SOFT_RESET_OFFSET);\r\nval = ioread32(rng_base + RNG_SOFT_RESET_OFFSET);\r\nval &= ~RNG_SOFT_RESET;\r\niowrite32(val, rng_base + RNG_SOFT_RESET_OFFSET);\r\nval = ioread32(rng_base + RBG_SOFT_RESET_OFFSET);\r\nval &= ~RBG_SOFT_RESET;\r\niowrite32(val, rng_base + RBG_SOFT_RESET_OFFSET);\r\nval = ioread32(rng_base + RNG_CTRL_OFFSET);\r\nval &= ~RNG_CTRL_RNG_RBGEN_MASK;\r\nval |= RNG_CTRL_RNG_RBGEN_ENABLE;\r\niowrite32(val, rng_base + RNG_CTRL_OFFSET);\r\n}\r\nstatic int iproc_rng200_read(struct hwrng *rng, void *buf, size_t max,\r\nbool wait)\r\n{\r\nstruct iproc_rng200_dev *priv = to_rng_priv(rng);\r\nuint32_t num_remaining = max;\r\nuint32_t status;\r\n#define MAX_RESETS_PER_READ 1\r\nuint32_t num_resets = 0;\r\n#define MAX_IDLE_TIME (1 * HZ)\r\nunsigned long idle_endtime = jiffies + MAX_IDLE_TIME;\r\nwhile ((num_remaining > 0) && time_before(jiffies, idle_endtime)) {\r\nstatus = ioread32(priv->base + RNG_INT_STATUS_OFFSET);\r\nif ((status & (RNG_INT_STATUS_MASTER_FAIL_LOCKOUT_IRQ_MASK |\r\nRNG_INT_STATUS_NIST_FAIL_IRQ_MASK)) != 0) {\r\nif (num_resets >= MAX_RESETS_PER_READ)\r\nreturn max - num_remaining;\r\niproc_rng200_restart(priv->base);\r\nnum_resets++;\r\n}\r\nif ((ioread32(priv->base + RNG_FIFO_COUNT_OFFSET) &\r\nRNG_FIFO_COUNT_RNG_FIFO_COUNT_MASK) > 0) {\r\nif (num_remaining >= sizeof(uint32_t)) {\r\n*(uint32_t *)buf = ioread32(priv->base +\r\nRNG_FIFO_DATA_OFFSET);\r\nbuf += sizeof(uint32_t);\r\nnum_remaining -= sizeof(uint32_t);\r\n} else {\r\nuint32_t rnd_number = ioread32(priv->base +\r\nRNG_FIFO_DATA_OFFSET);\r\nmemcpy(buf, &rnd_number, num_remaining);\r\nbuf += num_remaining;\r\nnum_remaining = 0;\r\n}\r\nidle_endtime = jiffies + MAX_IDLE_TIME;\r\n} else {\r\nif (!wait)\r\nreturn max - num_remaining;\r\nusleep_range(min(num_remaining * 10, 500U), 500);\r\n}\r\n}\r\nreturn max - num_remaining;\r\n}\r\nstatic int iproc_rng200_init(struct hwrng *rng)\r\n{\r\nstruct iproc_rng200_dev *priv = to_rng_priv(rng);\r\nuint32_t val;\r\nval = ioread32(priv->base + RNG_CTRL_OFFSET);\r\nval &= ~RNG_CTRL_RNG_RBGEN_MASK;\r\nval |= RNG_CTRL_RNG_RBGEN_ENABLE;\r\niowrite32(val, priv->base + RNG_CTRL_OFFSET);\r\nreturn 0;\r\n}\r\nstatic void iproc_rng200_cleanup(struct hwrng *rng)\r\n{\r\nstruct iproc_rng200_dev *priv = to_rng_priv(rng);\r\nuint32_t val;\r\nval = ioread32(priv->base + RNG_CTRL_OFFSET);\r\nval &= ~RNG_CTRL_RNG_RBGEN_MASK;\r\nval |= RNG_CTRL_RNG_RBGEN_DISABLE;\r\niowrite32(val, priv->base + RNG_CTRL_OFFSET);\r\n}\r\nstatic int iproc_rng200_probe(struct platform_device *pdev)\r\n{\r\nstruct iproc_rng200_dev *priv;\r\nstruct resource *res;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "failed to get rng resources\n");\r\nreturn -EINVAL;\r\n}\r\npriv->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->base)) {\r\ndev_err(dev, "failed to remap rng regs\n");\r\nreturn PTR_ERR(priv->base);\r\n}\r\npriv->rng.name = "iproc-rng200",\r\npriv->rng.read = iproc_rng200_read,\r\npriv->rng.init = iproc_rng200_init,\r\npriv->rng.cleanup = iproc_rng200_cleanup,\r\nret = devm_hwrng_register(dev, &priv->rng);\r\nif (ret) {\r\ndev_err(dev, "hwrng registration failed\n");\r\nreturn ret;\r\n}\r\ndev_info(dev, "hwrng registered\n");\r\nreturn 0;\r\n}
