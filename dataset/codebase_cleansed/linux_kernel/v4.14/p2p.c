static void ath10k_p2p_noa_ie_fill(u8 *data, size_t len,\r\nconst struct wmi_p2p_noa_info *noa)\r\n{\r\nstruct ieee80211_p2p_noa_attr *noa_attr;\r\nu8 ctwindow_oppps = noa->ctwindow_oppps;\r\nu8 ctwindow = ctwindow_oppps >> WMI_P2P_OPPPS_CTWINDOW_OFFSET;\r\nbool oppps = !!(ctwindow_oppps & WMI_P2P_OPPPS_ENABLE_BIT);\r\n__le16 *noa_attr_len;\r\nu16 attr_len;\r\nu8 noa_descriptors = noa->num_descriptors;\r\nint i;\r\ndata[0] = WLAN_EID_VENDOR_SPECIFIC;\r\ndata[1] = len - 2;\r\ndata[2] = (WLAN_OUI_WFA >> 16) & 0xff;\r\ndata[3] = (WLAN_OUI_WFA >> 8) & 0xff;\r\ndata[4] = (WLAN_OUI_WFA >> 0) & 0xff;\r\ndata[5] = WLAN_OUI_TYPE_WFA_P2P;\r\ndata[6] = IEEE80211_P2P_ATTR_ABSENCE_NOTICE;\r\nnoa_attr_len = (__le16 *)&data[7];\r\nnoa_attr = (struct ieee80211_p2p_noa_attr *)&data[9];\r\nnoa_attr->index = noa->index;\r\nnoa_attr->oppps_ctwindow = ctwindow;\r\nif (oppps)\r\nnoa_attr->oppps_ctwindow |= IEEE80211_P2P_OPPPS_ENABLE_BIT;\r\nfor (i = 0; i < noa_descriptors; i++) {\r\nnoa_attr->desc[i].count =\r\n__le32_to_cpu(noa->descriptors[i].type_count);\r\nnoa_attr->desc[i].duration = noa->descriptors[i].duration;\r\nnoa_attr->desc[i].interval = noa->descriptors[i].interval;\r\nnoa_attr->desc[i].start_time = noa->descriptors[i].start_time;\r\n}\r\nattr_len = 2;\r\nattr_len += noa_descriptors * sizeof(struct ieee80211_p2p_noa_desc);\r\n*noa_attr_len = __cpu_to_le16(attr_len);\r\n}\r\nstatic size_t ath10k_p2p_noa_ie_len_compute(const struct wmi_p2p_noa_info *noa)\r\n{\r\nsize_t len = 0;\r\nif (!noa->num_descriptors &&\r\n!(noa->ctwindow_oppps & WMI_P2P_OPPPS_ENABLE_BIT))\r\nreturn 0;\r\nlen += 1 + 1 + 4;\r\nlen += 1 + 2;\r\nlen += 1 + 1;\r\nlen += noa->num_descriptors * sizeof(struct ieee80211_p2p_noa_desc);\r\nreturn len;\r\n}\r\nstatic void ath10k_p2p_noa_ie_assign(struct ath10k_vif *arvif, void *ie,\r\nsize_t len)\r\n{\r\nstruct ath10k *ar = arvif->ar;\r\nlockdep_assert_held(&ar->data_lock);\r\nkfree(arvif->u.ap.noa_data);\r\narvif->u.ap.noa_data = ie;\r\narvif->u.ap.noa_len = len;\r\n}\r\nstatic void __ath10k_p2p_noa_update(struct ath10k_vif *arvif,\r\nconst struct wmi_p2p_noa_info *noa)\r\n{\r\nstruct ath10k *ar = arvif->ar;\r\nvoid *ie;\r\nsize_t len;\r\nlockdep_assert_held(&ar->data_lock);\r\nath10k_p2p_noa_ie_assign(arvif, NULL, 0);\r\nlen = ath10k_p2p_noa_ie_len_compute(noa);\r\nif (!len)\r\nreturn;\r\nie = kmalloc(len, GFP_ATOMIC);\r\nif (!ie)\r\nreturn;\r\nath10k_p2p_noa_ie_fill(ie, len, noa);\r\nath10k_p2p_noa_ie_assign(arvif, ie, len);\r\n}\r\nvoid ath10k_p2p_noa_update(struct ath10k_vif *arvif,\r\nconst struct wmi_p2p_noa_info *noa)\r\n{\r\nstruct ath10k *ar = arvif->ar;\r\nspin_lock_bh(&ar->data_lock);\r\n__ath10k_p2p_noa_update(arvif, noa);\r\nspin_unlock_bh(&ar->data_lock);\r\n}\r\nstatic void ath10k_p2p_noa_update_vdev_iter(void *data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath10k_vif *arvif = (void *)vif->drv_priv;\r\nstruct ath10k_p2p_noa_arg *arg = data;\r\nif (arvif->vdev_id != arg->vdev_id)\r\nreturn;\r\nath10k_p2p_noa_update(arvif, arg->noa);\r\n}\r\nvoid ath10k_p2p_noa_update_by_vdev_id(struct ath10k *ar, u32 vdev_id,\r\nconst struct wmi_p2p_noa_info *noa)\r\n{\r\nstruct ath10k_p2p_noa_arg arg = {\r\n.vdev_id = vdev_id,\r\n.noa = noa,\r\n};\r\nieee80211_iterate_active_interfaces_atomic(ar->hw,\r\nIEEE80211_IFACE_ITER_NORMAL,\r\nath10k_p2p_noa_update_vdev_iter,\r\n&arg);\r\n}
