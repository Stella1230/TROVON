unsigned char __nvram_read_byte(int i)\r\n{\r\nreturn CMOS_READ(NVRAM_FIRST_BYTE + i);\r\n}\r\nunsigned char nvram_read_byte(int i)\r\n{\r\nunsigned long flags;\r\nunsigned char c;\r\nspin_lock_irqsave(&rtc_lock, flags);\r\nc = __nvram_read_byte(i);\r\nspin_unlock_irqrestore(&rtc_lock, flags);\r\nreturn c;\r\n}\r\nvoid __nvram_write_byte(unsigned char c, int i)\r\n{\r\nCMOS_WRITE(c, NVRAM_FIRST_BYTE + i);\r\n}\r\nvoid nvram_write_byte(unsigned char c, int i)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&rtc_lock, flags);\r\n__nvram_write_byte(c, i);\r\nspin_unlock_irqrestore(&rtc_lock, flags);\r\n}\r\nint __nvram_check_checksum(void)\r\n{\r\nreturn mach_check_checksum();\r\n}\r\nint nvram_check_checksum(void)\r\n{\r\nunsigned long flags;\r\nint rv;\r\nspin_lock_irqsave(&rtc_lock, flags);\r\nrv = __nvram_check_checksum();\r\nspin_unlock_irqrestore(&rtc_lock, flags);\r\nreturn rv;\r\n}\r\nstatic void __nvram_set_checksum(void)\r\n{\r\nmach_set_checksum();\r\n}\r\nstatic loff_t nvram_llseek(struct file *file, loff_t offset, int origin)\r\n{\r\nreturn generic_file_llseek_size(file, offset, origin, MAX_LFS_FILESIZE,\r\nNVRAM_BYTES);\r\n}\r\nstatic ssize_t nvram_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned char contents[NVRAM_BYTES];\r\nunsigned i = *ppos;\r\nunsigned char *tmp;\r\nspin_lock_irq(&rtc_lock);\r\nif (!__nvram_check_checksum())\r\ngoto checksum_err;\r\nfor (tmp = contents; count-- > 0 && i < NVRAM_BYTES; ++i, ++tmp)\r\n*tmp = __nvram_read_byte(i);\r\nspin_unlock_irq(&rtc_lock);\r\nif (copy_to_user(buf, contents, tmp - contents))\r\nreturn -EFAULT;\r\n*ppos = i;\r\nreturn tmp - contents;\r\nchecksum_err:\r\nspin_unlock_irq(&rtc_lock);\r\nreturn -EIO;\r\n}\r\nstatic ssize_t nvram_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned char contents[NVRAM_BYTES];\r\nunsigned i = *ppos;\r\nunsigned char *tmp;\r\nif (i >= NVRAM_BYTES)\r\nreturn 0;\r\nif (count > NVRAM_BYTES - i)\r\ncount = NVRAM_BYTES - i;\r\nif (count > NVRAM_BYTES)\r\nreturn -EFAULT;\r\nif (copy_from_user(contents, buf, count))\r\nreturn -EFAULT;\r\nspin_lock_irq(&rtc_lock);\r\nif (!__nvram_check_checksum())\r\ngoto checksum_err;\r\nfor (tmp = contents; count--; ++i, ++tmp)\r\n__nvram_write_byte(*tmp, i);\r\n__nvram_set_checksum();\r\nspin_unlock_irq(&rtc_lock);\r\n*ppos = i;\r\nreturn tmp - contents;\r\nchecksum_err:\r\nspin_unlock_irq(&rtc_lock);\r\nreturn -EIO;\r\n}\r\nstatic long nvram_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint i;\r\nswitch (cmd) {\r\ncase NVRAM_INIT:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nmutex_lock(&nvram_mutex);\r\nspin_lock_irq(&rtc_lock);\r\nfor (i = 0; i < NVRAM_BYTES; ++i)\r\n__nvram_write_byte(0, i);\r\n__nvram_set_checksum();\r\nspin_unlock_irq(&rtc_lock);\r\nmutex_unlock(&nvram_mutex);\r\nreturn 0;\r\ncase NVRAM_SETCKS:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nmutex_lock(&nvram_mutex);\r\nspin_lock_irq(&rtc_lock);\r\n__nvram_set_checksum();\r\nspin_unlock_irq(&rtc_lock);\r\nmutex_unlock(&nvram_mutex);\r\nreturn 0;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int nvram_open(struct inode *inode, struct file *file)\r\n{\r\nspin_lock(&nvram_state_lock);\r\nif ((nvram_open_cnt && (file->f_flags & O_EXCL)) ||\r\n(nvram_open_mode & NVRAM_EXCL) ||\r\n((file->f_mode & FMODE_WRITE) && (nvram_open_mode & NVRAM_WRITE))) {\r\nspin_unlock(&nvram_state_lock);\r\nreturn -EBUSY;\r\n}\r\nif (file->f_flags & O_EXCL)\r\nnvram_open_mode |= NVRAM_EXCL;\r\nif (file->f_mode & FMODE_WRITE)\r\nnvram_open_mode |= NVRAM_WRITE;\r\nnvram_open_cnt++;\r\nspin_unlock(&nvram_state_lock);\r\nreturn 0;\r\n}\r\nstatic int nvram_release(struct inode *inode, struct file *file)\r\n{\r\nspin_lock(&nvram_state_lock);\r\nnvram_open_cnt--;\r\nif (nvram_open_mode & NVRAM_EXCL)\r\nnvram_open_mode &= ~NVRAM_EXCL;\r\nif (file->f_mode & FMODE_WRITE)\r\nnvram_open_mode &= ~NVRAM_WRITE;\r\nspin_unlock(&nvram_state_lock);\r\nreturn 0;\r\n}\r\nstatic int nvram_add_proc_fs(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int nvram_proc_read(struct seq_file *seq, void *offset)\r\n{\r\nunsigned char contents[NVRAM_BYTES];\r\nint i = 0;\r\nspin_lock_irq(&rtc_lock);\r\nfor (i = 0; i < NVRAM_BYTES; ++i)\r\ncontents[i] = __nvram_read_byte(i);\r\nspin_unlock_irq(&rtc_lock);\r\nmach_proc_infos(contents, seq, offset);\r\nreturn 0;\r\n}\r\nstatic int nvram_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, nvram_proc_read, NULL);\r\n}\r\nstatic int nvram_add_proc_fs(void)\r\n{\r\nif (!proc_create("driver/nvram", 0, NULL, &nvram_proc_fops))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int __init nvram_init(void)\r\n{\r\nint ret;\r\nif (!CHECK_DRIVER_INIT())\r\nreturn -ENODEV;\r\nret = misc_register(&nvram_dev);\r\nif (ret) {\r\nprintk(KERN_ERR "nvram: can't misc_register on minor=%d\n",\r\nNVRAM_MINOR);\r\ngoto out;\r\n}\r\nret = nvram_add_proc_fs();\r\nif (ret) {\r\nprintk(KERN_ERR "nvram: can't create /proc/driver/nvram\n");\r\ngoto outmisc;\r\n}\r\nret = 0;\r\nprintk(KERN_INFO "Non-volatile memory driver v" NVRAM_VERSION "\n");\r\nout:\r\nreturn ret;\r\noutmisc:\r\nmisc_deregister(&nvram_dev);\r\ngoto out;\r\n}\r\nstatic void __exit nvram_cleanup_module(void)\r\n{\r\nremove_proc_entry("driver/nvram", NULL);\r\nmisc_deregister(&nvram_dev);\r\n}\r\nstatic int pc_check_checksum(void)\r\n{\r\nint i;\r\nunsigned short sum = 0;\r\nunsigned short expect;\r\nfor (i = PC_CKS_RANGE_START; i <= PC_CKS_RANGE_END; ++i)\r\nsum += __nvram_read_byte(i);\r\nexpect = __nvram_read_byte(PC_CKS_LOC)<<8 |\r\n__nvram_read_byte(PC_CKS_LOC+1);\r\nreturn (sum & 0xffff) == expect;\r\n}\r\nstatic void pc_set_checksum(void)\r\n{\r\nint i;\r\nunsigned short sum = 0;\r\nfor (i = PC_CKS_RANGE_START; i <= PC_CKS_RANGE_END; ++i)\r\nsum += __nvram_read_byte(i);\r\n__nvram_write_byte(sum >> 8, PC_CKS_LOC);\r\n__nvram_write_byte(sum & 0xff, PC_CKS_LOC + 1);\r\n}\r\nstatic void pc_proc_infos(unsigned char *nvram, struct seq_file *seq,\r\nvoid *offset)\r\n{\r\nint checksum;\r\nint type;\r\nspin_lock_irq(&rtc_lock);\r\nchecksum = __nvram_check_checksum();\r\nspin_unlock_irq(&rtc_lock);\r\nseq_printf(seq, "Checksum status: %svalid\n", checksum ? "" : "not ");\r\nseq_printf(seq, "# floppies : %d\n",\r\n(nvram[6] & 1) ? (nvram[6] >> 6) + 1 : 0);\r\nseq_printf(seq, "Floppy 0 type : ");\r\ntype = nvram[2] >> 4;\r\nif (type < ARRAY_SIZE(floppy_types))\r\nseq_printf(seq, "%s\n", floppy_types[type]);\r\nelse\r\nseq_printf(seq, "%d (unknown)\n", type);\r\nseq_printf(seq, "Floppy 1 type : ");\r\ntype = nvram[2] & 0x0f;\r\nif (type < ARRAY_SIZE(floppy_types))\r\nseq_printf(seq, "%s\n", floppy_types[type]);\r\nelse\r\nseq_printf(seq, "%d (unknown)\n", type);\r\nseq_printf(seq, "HD 0 type : ");\r\ntype = nvram[4] >> 4;\r\nif (type)\r\nseq_printf(seq, "%02x\n", type == 0x0f ? nvram[11] : type);\r\nelse\r\nseq_printf(seq, "none\n");\r\nseq_printf(seq, "HD 1 type : ");\r\ntype = nvram[4] & 0x0f;\r\nif (type)\r\nseq_printf(seq, "%02x\n", type == 0x0f ? nvram[12] : type);\r\nelse\r\nseq_printf(seq, "none\n");\r\nseq_printf(seq, "HD type 48 data: %d/%d/%d C/H/S, precomp %d, lz %d\n",\r\nnvram[18] | (nvram[19] << 8),\r\nnvram[20], nvram[25],\r\nnvram[21] | (nvram[22] << 8), nvram[23] | (nvram[24] << 8));\r\nseq_printf(seq, "HD type 49 data: %d/%d/%d C/H/S, precomp %d, lz %d\n",\r\nnvram[39] | (nvram[40] << 8),\r\nnvram[41], nvram[46],\r\nnvram[42] | (nvram[43] << 8), nvram[44] | (nvram[45] << 8));\r\nseq_printf(seq, "DOS base memory: %d kB\n", nvram[7] | (nvram[8] << 8));\r\nseq_printf(seq, "Extended memory: %d kB (configured), %d kB (tested)\n",\r\nnvram[9] | (nvram[10] << 8), nvram[34] | (nvram[35] << 8));\r\nseq_printf(seq, "Gfx adapter : %s\n",\r\ngfx_types[(nvram[6] >> 4) & 3]);\r\nseq_printf(seq, "FPU : %sinstalled\n",\r\n(nvram[6] & 2) ? "" : "not ");\r\nreturn;\r\n}\r\nstatic int atari_check_checksum(void)\r\n{\r\nint i;\r\nunsigned char sum = 0;\r\nfor (i = ATARI_CKS_RANGE_START; i <= ATARI_CKS_RANGE_END; ++i)\r\nsum += __nvram_read_byte(i);\r\nreturn (__nvram_read_byte(ATARI_CKS_LOC) == (~sum & 0xff)) &&\r\n(__nvram_read_byte(ATARI_CKS_LOC + 1) == (sum & 0xff));\r\n}\r\nstatic void atari_set_checksum(void)\r\n{\r\nint i;\r\nunsigned char sum = 0;\r\nfor (i = ATARI_CKS_RANGE_START; i <= ATARI_CKS_RANGE_END; ++i)\r\nsum += __nvram_read_byte(i);\r\n__nvram_write_byte(~sum, ATARI_CKS_LOC);\r\n__nvram_write_byte(sum, ATARI_CKS_LOC + 1);\r\n}\r\nstatic void atari_proc_infos(unsigned char *nvram, struct seq_file *seq,\r\nvoid *offset)\r\n{\r\nint checksum = nvram_check_checksum();\r\nint i;\r\nunsigned vmode;\r\nseq_printf(seq, "Checksum status : %svalid\n", checksum ? "" : "not ");\r\nseq_printf(seq, "Boot preference : ");\r\nfor (i = ARRAY_SIZE(boot_prefs) - 1; i >= 0; --i) {\r\nif (nvram[1] == boot_prefs[i].val) {\r\nseq_printf(seq, "%s\n", boot_prefs[i].name);\r\nbreak;\r\n}\r\n}\r\nif (i < 0)\r\nseq_printf(seq, "0x%02x (undefined)\n", nvram[1]);\r\nseq_printf(seq, "SCSI arbitration : %s\n",\r\n(nvram[16] & 0x80) ? "on" : "off");\r\nseq_printf(seq, "SCSI host ID : ");\r\nif (nvram[16] & 0x80)\r\nseq_printf(seq, "%d\n", nvram[16] & 7);\r\nelse\r\nseq_printf(seq, "n/a\n");\r\nif ((atari_mch_cookie >> 16) != ATARI_MCH_FALCON)\r\nreturn;\r\nseq_printf(seq, "OS language : ");\r\nif (nvram[6] < ARRAY_SIZE(languages))\r\nseq_printf(seq, "%s\n", languages[nvram[6]]);\r\nelse\r\nseq_printf(seq, "%u (undefined)\n", nvram[6]);\r\nseq_printf(seq, "Keyboard language: ");\r\nif (nvram[7] < ARRAY_SIZE(languages))\r\nseq_printf(seq, "%s\n", languages[nvram[7]]);\r\nelse\r\nseq_printf(seq, "%u (undefined)\n", nvram[7]);\r\nseq_printf(seq, "Date format : ");\r\nseq_printf(seq, dateformat[nvram[8] & 7],\r\nnvram[9] ? nvram[9] : '/', nvram[9] ? nvram[9] : '/');\r\nseq_printf(seq, ", %dh clock\n", nvram[8] & 16 ? 24 : 12);\r\nseq_printf(seq, "Boot delay : ");\r\nif (nvram[10] == 0)\r\nseq_printf(seq, "default");\r\nelse\r\nseq_printf(seq, "%ds%s\n", nvram[10],\r\nnvram[10] < 8 ? ", no memory test" : "");\r\nvmode = (nvram[14] << 8) | nvram[15];\r\nseq_printf(seq,\r\n"Video mode : %s colors, %d columns, %s %s monitor\n",\r\ncolors[vmode & 7],\r\nvmode & 8 ? 80 : 40,\r\nvmode & 16 ? "VGA" : "TV", vmode & 32 ? "PAL" : "NTSC");\r\nseq_printf(seq, " %soverscan, compat. mode %s%s\n",\r\nvmode & 64 ? "" : "no ",\r\nvmode & 128 ? "on" : "off",\r\nvmode & 256 ?\r\n(vmode & 16 ? ", line doubling" : ", half screen") : "");\r\nreturn;\r\n}
