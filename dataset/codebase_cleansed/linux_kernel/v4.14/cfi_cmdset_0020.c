static void cfi_tell_features(struct cfi_pri_intelext *extp)\r\n{\r\nint i;\r\nprintk(" Feature/Command Support: %4.4X\n", extp->FeatureSupport);\r\nprintk(" - Chip Erase: %s\n", extp->FeatureSupport&1?"supported":"unsupported");\r\nprintk(" - Suspend Erase: %s\n", extp->FeatureSupport&2?"supported":"unsupported");\r\nprintk(" - Suspend Program: %s\n", extp->FeatureSupport&4?"supported":"unsupported");\r\nprintk(" - Legacy Lock/Unlock: %s\n", extp->FeatureSupport&8?"supported":"unsupported");\r\nprintk(" - Queued Erase: %s\n", extp->FeatureSupport&16?"supported":"unsupported");\r\nprintk(" - Instant block lock: %s\n", extp->FeatureSupport&32?"supported":"unsupported");\r\nprintk(" - Protection Bits: %s\n", extp->FeatureSupport&64?"supported":"unsupported");\r\nprintk(" - Page-mode read: %s\n", extp->FeatureSupport&128?"supported":"unsupported");\r\nprintk(" - Synchronous read: %s\n", extp->FeatureSupport&256?"supported":"unsupported");\r\nfor (i=9; i<32; i++) {\r\nif (extp->FeatureSupport & (1<<i))\r\nprintk(" - Unknown Bit %X: supported\n", i);\r\n}\r\nprintk(" Supported functions after Suspend: %2.2X\n", extp->SuspendCmdSupport);\r\nprintk(" - Program after Erase Suspend: %s\n", extp->SuspendCmdSupport&1?"supported":"unsupported");\r\nfor (i=1; i<8; i++) {\r\nif (extp->SuspendCmdSupport & (1<<i))\r\nprintk(" - Unknown Bit %X: supported\n", i);\r\n}\r\nprintk(" Block Status Register Mask: %4.4X\n", extp->BlkStatusRegMask);\r\nprintk(" - Lock Bit Active: %s\n", extp->BlkStatusRegMask&1?"yes":"no");\r\nprintk(" - Valid Bit Active: %s\n", extp->BlkStatusRegMask&2?"yes":"no");\r\nfor (i=2; i<16; i++) {\r\nif (extp->BlkStatusRegMask & (1<<i))\r\nprintk(" - Unknown Bit %X Active: yes\n",i);\r\n}\r\nprintk(" Vcc Logic Supply Optimum Program/Erase Voltage: %d.%d V\n",\r\nextp->VccOptimal >> 8, extp->VccOptimal & 0xf);\r\nif (extp->VppOptimal)\r\nprintk(" Vpp Programming Supply Optimum Program/Erase Voltage: %d.%d V\n",\r\nextp->VppOptimal >> 8, extp->VppOptimal & 0xf);\r\n}\r\nstruct mtd_info *cfi_cmdset_0020(struct map_info *map, int primary)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint i;\r\nif (cfi->cfi_mode) {\r\n__u16 adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;\r\nstruct cfi_pri_intelext *extp;\r\nextp = (struct cfi_pri_intelext*)cfi_read_pri(map, adr, sizeof(*extp), "ST Microelectronics");\r\nif (!extp)\r\nreturn NULL;\r\nif (extp->MajorVersion != '1' ||\r\n(extp->MinorVersion < '0' || extp->MinorVersion > '3')) {\r\nprintk(KERN_ERR " Unknown ST Microelectronics"\r\n" Extended Query version %c.%c.\n",\r\nextp->MajorVersion, extp->MinorVersion);\r\nkfree(extp);\r\nreturn NULL;\r\n}\r\nextp->FeatureSupport = cfi32_to_cpu(map, extp->FeatureSupport);\r\nextp->BlkStatusRegMask = cfi32_to_cpu(map,\r\nextp->BlkStatusRegMask);\r\n#ifdef DEBUG_CFI_FEATURES\r\ncfi_tell_features(extp);\r\n#endif\r\ncfi->cmdset_priv = extp;\r\n}\r\nfor (i=0; i< cfi->numchips; i++) {\r\ncfi->chips[i].word_write_time = 128;\r\ncfi->chips[i].buffer_write_time = 128;\r\ncfi->chips[i].erase_time = 1024;\r\ncfi->chips[i].ref_point_counter = 0;\r\ninit_waitqueue_head(&(cfi->chips[i].wq));\r\n}\r\nreturn cfi_staa_setup(map);\r\n}\r\nstatic struct mtd_info *cfi_staa_setup(struct map_info *map)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct mtd_info *mtd;\r\nunsigned long offset = 0;\r\nint i,j;\r\nunsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;\r\nmtd = kzalloc(sizeof(*mtd), GFP_KERNEL);\r\nif (!mtd) {\r\nkfree(cfi->cmdset_priv);\r\nreturn NULL;\r\n}\r\nmtd->priv = map;\r\nmtd->type = MTD_NORFLASH;\r\nmtd->size = devsize * cfi->numchips;\r\nmtd->numeraseregions = cfi->cfiq->NumEraseRegions * cfi->numchips;\r\nmtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info)\r\n* mtd->numeraseregions, GFP_KERNEL);\r\nif (!mtd->eraseregions) {\r\nkfree(cfi->cmdset_priv);\r\nkfree(mtd);\r\nreturn NULL;\r\n}\r\nfor (i=0; i<cfi->cfiq->NumEraseRegions; i++) {\r\nunsigned long ernum, ersize;\r\nersize = ((cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff) * cfi->interleave;\r\nernum = (cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1;\r\nif (mtd->erasesize < ersize) {\r\nmtd->erasesize = ersize;\r\n}\r\nfor (j=0; j<cfi->numchips; j++) {\r\nmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].offset = (j*devsize)+offset;\r\nmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].erasesize = ersize;\r\nmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].numblocks = ernum;\r\n}\r\noffset += (ersize * ernum);\r\n}\r\nif (offset != devsize) {\r\nprintk(KERN_WARNING "Sum of regions (%lx) != total size of set of interleaved chips (%lx)\n", offset, devsize);\r\nkfree(mtd->eraseregions);\r\nkfree(cfi->cmdset_priv);\r\nkfree(mtd);\r\nreturn NULL;\r\n}\r\nfor (i=0; i<mtd->numeraseregions;i++){\r\nprintk(KERN_DEBUG "%d: offset=0x%llx,size=0x%x,blocks=%d\n",\r\ni, (unsigned long long)mtd->eraseregions[i].offset,\r\nmtd->eraseregions[i].erasesize,\r\nmtd->eraseregions[i].numblocks);\r\n}\r\nmtd->_erase = cfi_staa_erase_varsize;\r\nmtd->_read = cfi_staa_read;\r\nmtd->_write = cfi_staa_write_buffers;\r\nmtd->_writev = cfi_staa_writev;\r\nmtd->_sync = cfi_staa_sync;\r\nmtd->_lock = cfi_staa_lock;\r\nmtd->_unlock = cfi_staa_unlock;\r\nmtd->_suspend = cfi_staa_suspend;\r\nmtd->_resume = cfi_staa_resume;\r\nmtd->flags = MTD_CAP_NORFLASH & ~MTD_BIT_WRITEABLE;\r\nmtd->writesize = 8;\r\nmtd->writebufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\r\nmap->fldrv = &cfi_staa_chipdrv;\r\n__module_get(THIS_MODULE);\r\nmtd->name = map->name;\r\nreturn mtd;\r\n}\r\nstatic inline int do_read_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)\r\n{\r\nmap_word status, status_OK;\r\nunsigned long timeo;\r\nDECLARE_WAITQUEUE(wait, current);\r\nint suspended = 0;\r\nunsigned long cmd_addr;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nadr += chip->start;\r\ncmd_addr = adr & ~(map_bankwidth(map)-1);\r\nstatus_OK = CMD(0x80);\r\ntimeo = jiffies + HZ;\r\nretry:\r\nmutex_lock(&chip->mutex);\r\nswitch (chip->state) {\r\ncase FL_ERASING:\r\nif (!(((struct cfi_pri_intelext *)cfi->cmdset_priv)->FeatureSupport & 2))\r\ngoto sleep;\r\nmap_write (map, CMD(0xb0), cmd_addr);\r\nmap_write(map, CMD(0x70), cmd_addr);\r\nchip->oldstate = FL_ERASING;\r\nchip->state = FL_ERASE_SUSPENDING;\r\nfor (;;) {\r\nstatus = map_read(map, cmd_addr);\r\nif (map_word_andequal(map, status, status_OK, status_OK))\r\nbreak;\r\nif (time_after(jiffies, timeo)) {\r\nmap_write(map, CMD(0xd0), cmd_addr);\r\nmap_write(map, CMD(0x70), cmd_addr);\r\nchip->state = FL_ERASING;\r\nwake_up(&chip->wq);\r\nmutex_unlock(&chip->mutex);\r\nprintk(KERN_ERR "Chip not ready after erase "\r\n"suspended: status = 0x%lx\n", status.x[0]);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(1);\r\nmutex_lock(&chip->mutex);\r\n}\r\nsuspended = 1;\r\nmap_write(map, CMD(0xff), cmd_addr);\r\nchip->state = FL_READY;\r\nbreak;\r\n#if 0\r\ncase FL_WRITING:\r\n#endif\r\ncase FL_READY:\r\nbreak;\r\ncase FL_CFI_QUERY:\r\ncase FL_JEDEC_QUERY:\r\nmap_write(map, CMD(0x70), cmd_addr);\r\nchip->state = FL_STATUS;\r\ncase FL_STATUS:\r\nstatus = map_read(map, cmd_addr);\r\nif (map_word_andequal(map, status, status_OK, status_OK)) {\r\nmap_write(map, CMD(0xff), cmd_addr);\r\nchip->state = FL_READY;\r\nbreak;\r\n}\r\nif (time_after(jiffies, timeo)) {\r\nmutex_unlock(&chip->mutex);\r\nprintk(KERN_ERR "waiting for chip to be ready timed out in read. WSM status = %lx\n", status.x[0]);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(1);\r\ngoto retry;\r\ndefault:\r\nsleep:\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\ntimeo = jiffies + HZ;\r\ngoto retry;\r\n}\r\nmap_copy_from(map, buf, adr, len);\r\nif (suspended) {\r\nchip->state = chip->oldstate;\r\nmap_write(map, CMD(0xd0), cmd_addr);\r\nmap_write(map, CMD(0x70), cmd_addr);\r\n}\r\nwake_up(&chip->wq);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int cfi_staa_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long ofs;\r\nint chipnum;\r\nint ret = 0;\r\nchipnum = (from >> cfi->chipshift);\r\nofs = from - (chipnum << cfi->chipshift);\r\nwhile (len) {\r\nunsigned long thislen;\r\nif (chipnum >= cfi->numchips)\r\nbreak;\r\nif ((len + ofs -1) >> cfi->chipshift)\r\nthislen = (1<<cfi->chipshift) - ofs;\r\nelse\r\nthislen = len;\r\nret = do_read_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);\r\nif (ret)\r\nbreak;\r\n*retlen += thislen;\r\nlen -= thislen;\r\nbuf += thislen;\r\nofs = 0;\r\nchipnum++;\r\n}\r\nreturn ret;\r\n}\r\nstatic int do_write_buffer(struct map_info *map, struct flchip *chip,\r\nunsigned long adr, const u_char *buf, int len)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nmap_word status, status_OK;\r\nunsigned long cmd_adr, timeo;\r\nDECLARE_WAITQUEUE(wait, current);\r\nint wbufsize, z;\r\nif (adr & (map_bankwidth(map)-1))\r\nreturn -EINVAL;\r\nwbufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\r\nadr += chip->start;\r\ncmd_adr = adr & ~(wbufsize-1);\r\nstatus_OK = CMD(0x80);\r\ntimeo = jiffies + HZ;\r\nretry:\r\n#ifdef DEBUG_CFI_FEATURES\r\nprintk("%s: chip->state[%d]\n", __func__, chip->state);\r\n#endif\r\nmutex_lock(&chip->mutex);\r\nswitch (chip->state) {\r\ncase FL_READY:\r\nbreak;\r\ncase FL_CFI_QUERY:\r\ncase FL_JEDEC_QUERY:\r\nmap_write(map, CMD(0x70), cmd_adr);\r\nchip->state = FL_STATUS;\r\n#ifdef DEBUG_CFI_FEATURES\r\nprintk("%s: 1 status[%x]\n", __func__, map_read(map, cmd_adr));\r\n#endif\r\ncase FL_STATUS:\r\nstatus = map_read(map, cmd_adr);\r\nif (map_word_andequal(map, status, status_OK, status_OK))\r\nbreak;\r\nif (time_after(jiffies, timeo)) {\r\nmutex_unlock(&chip->mutex);\r\nprintk(KERN_ERR "waiting for chip to be ready timed out in buffer write Xstatus = %lx, status = %lx\n",\r\nstatus.x[0], map_read(map, cmd_adr).x[0]);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(1);\r\ngoto retry;\r\ndefault:\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\ntimeo = jiffies + HZ;\r\ngoto retry;\r\n}\r\nENABLE_VPP(map);\r\nmap_write(map, CMD(0xe8), cmd_adr);\r\nchip->state = FL_WRITING_TO_BUFFER;\r\nz = 0;\r\nfor (;;) {\r\nstatus = map_read(map, cmd_adr);\r\nif (map_word_andequal(map, status, status_OK, status_OK))\r\nbreak;\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(1);\r\nmutex_lock(&chip->mutex);\r\nif (++z > 100) {\r\nDISABLE_VPP(map);\r\nmap_write(map, CMD(0x70), cmd_adr);\r\nchip->state = FL_STATUS;\r\nmutex_unlock(&chip->mutex);\r\nprintk(KERN_ERR "Chip not ready for buffer write. Xstatus = %lx\n", status.x[0]);\r\nreturn -EIO;\r\n}\r\n}\r\nmap_write(map, CMD(len/map_bankwidth(map)-1), cmd_adr );\r\nfor (z = 0; z < len;\r\nz += map_bankwidth(map), buf += map_bankwidth(map)) {\r\nmap_word d;\r\nd = map_word_load(map, buf);\r\nmap_write(map, d, adr+z);\r\n}\r\nmap_write(map, CMD(0xd0), cmd_adr);\r\nchip->state = FL_WRITING;\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(chip->buffer_write_time);\r\nmutex_lock(&chip->mutex);\r\ntimeo = jiffies + (HZ/2);\r\nz = 0;\r\nfor (;;) {\r\nif (chip->state != FL_WRITING) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\ntimeo = jiffies + (HZ / 2);\r\nmutex_lock(&chip->mutex);\r\ncontinue;\r\n}\r\nstatus = map_read(map, cmd_adr);\r\nif (map_word_andequal(map, status, status_OK, status_OK))\r\nbreak;\r\nif (time_after(jiffies, timeo)) {\r\nmap_write(map, CMD(0x50), cmd_adr);\r\nmap_write(map, CMD(0x70), adr);\r\nchip->state = FL_STATUS;\r\nDISABLE_VPP(map);\r\nmutex_unlock(&chip->mutex);\r\nprintk(KERN_ERR "waiting for chip to be ready timed out in bufwrite\n");\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(1);\r\nz++;\r\nmutex_lock(&chip->mutex);\r\n}\r\nif (!z) {\r\nchip->buffer_write_time--;\r\nif (!chip->buffer_write_time)\r\nchip->buffer_write_time++;\r\n}\r\nif (z > 1)\r\nchip->buffer_write_time++;\r\nDISABLE_VPP(map);\r\nchip->state = FL_STATUS;\r\nif (map_word_bitsset(map, status, CMD(0x3a))) {\r\n#ifdef DEBUG_CFI_FEATURES\r\nprintk("%s: 2 status[%lx]\n", __func__, status.x[0]);\r\n#endif\r\nmap_write(map, CMD(0x50), cmd_adr);\r\nmap_write(map, CMD(0x70), adr);\r\nwake_up(&chip->wq);\r\nmutex_unlock(&chip->mutex);\r\nreturn map_word_bitsset(map, status, CMD(0x02)) ? -EROFS : -EIO;\r\n}\r\nwake_up(&chip->wq);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int cfi_staa_write_buffers (struct mtd_info *mtd, loff_t to,\r\nsize_t len, size_t *retlen, const u_char *buf)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint wbufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\r\nint ret = 0;\r\nint chipnum;\r\nunsigned long ofs;\r\nchipnum = to >> cfi->chipshift;\r\nofs = to - (chipnum << cfi->chipshift);\r\n#ifdef DEBUG_CFI_FEATURES\r\nprintk("%s: map_bankwidth(map)[%x]\n", __func__, map_bankwidth(map));\r\nprintk("%s: chipnum[%x] wbufsize[%x]\n", __func__, chipnum, wbufsize);\r\nprintk("%s: ofs[%x] len[%x]\n", __func__, ofs, len);\r\n#endif\r\nwhile (len > 0) {\r\nint size = wbufsize - (ofs & (wbufsize-1));\r\nif (size > len)\r\nsize = len;\r\nret = do_write_buffer(map, &cfi->chips[chipnum],\r\nofs, buf, size);\r\nif (ret)\r\nreturn ret;\r\nofs += size;\r\nbuf += size;\r\n(*retlen) += size;\r\nlen -= size;\r\nif (ofs >> cfi->chipshift) {\r\nchipnum ++;\r\nofs = 0;\r\nif (chipnum == cfi->numchips)\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ncfi_staa_writev(struct mtd_info *mtd, const struct kvec *vecs,\r\nunsigned long count, loff_t to, size_t *retlen)\r\n{\r\nunsigned long i;\r\nsize_t totlen = 0, thislen;\r\nint ret = 0;\r\nsize_t buflen = 0;\r\nchar *buffer;\r\nif (!ECCBUF_SIZE) {\r\nreturn -EIO;\r\n}\r\nbuffer = kmalloc(ECCBUF_SIZE, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nfor (i=0; i<count; i++) {\r\nsize_t elem_len = vecs[i].iov_len;\r\nvoid *elem_base = vecs[i].iov_base;\r\nif (!elem_len)\r\ncontinue;\r\nif (buflen) {\r\nif (buflen + elem_len < ECCBUF_SIZE) {\r\nmemcpy(buffer+buflen, elem_base, elem_len);\r\nbuflen += elem_len;\r\ncontinue;\r\n}\r\nmemcpy(buffer+buflen, elem_base, ECCBUF_SIZE-buflen);\r\nret = mtd_write(mtd, to, ECCBUF_SIZE, &thislen,\r\nbuffer);\r\ntotlen += thislen;\r\nif (ret || thislen != ECCBUF_SIZE)\r\ngoto write_error;\r\nelem_len -= thislen-buflen;\r\nelem_base += thislen-buflen;\r\nto += ECCBUF_SIZE;\r\n}\r\nif (ECCBUF_DIV(elem_len)) {\r\nret = mtd_write(mtd, to, ECCBUF_DIV(elem_len),\r\n&thislen, elem_base);\r\ntotlen += thislen;\r\nif (ret || thislen != ECCBUF_DIV(elem_len))\r\ngoto write_error;\r\nto += thislen;\r\n}\r\nbuflen = ECCBUF_MOD(elem_len);\r\nif (buflen) {\r\nmemset(buffer, 0xff, ECCBUF_SIZE);\r\nmemcpy(buffer, elem_base + thislen, buflen);\r\n}\r\n}\r\nif (buflen) {\r\nret = mtd_write(mtd, to, buflen, &thislen, buffer);\r\ntotlen += thislen;\r\nif (ret || thislen != ECCBUF_SIZE)\r\ngoto write_error;\r\n}\r\nwrite_error:\r\nif (retlen)\r\n*retlen = totlen;\r\nkfree(buffer);\r\nreturn ret;\r\n}\r\nstatic inline int do_erase_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nmap_word status, status_OK;\r\nunsigned long timeo;\r\nint retries = 3;\r\nDECLARE_WAITQUEUE(wait, current);\r\nint ret = 0;\r\nadr += chip->start;\r\nstatus_OK = CMD(0x80);\r\ntimeo = jiffies + HZ;\r\nretry:\r\nmutex_lock(&chip->mutex);\r\nswitch (chip->state) {\r\ncase FL_CFI_QUERY:\r\ncase FL_JEDEC_QUERY:\r\ncase FL_READY:\r\nmap_write(map, CMD(0x70), adr);\r\nchip->state = FL_STATUS;\r\ncase FL_STATUS:\r\nstatus = map_read(map, adr);\r\nif (map_word_andequal(map, status, status_OK, status_OK))\r\nbreak;\r\nif (time_after(jiffies, timeo)) {\r\nmutex_unlock(&chip->mutex);\r\nprintk(KERN_ERR "waiting for chip to be ready timed out in erase\n");\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(1);\r\ngoto retry;\r\ndefault:\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\ntimeo = jiffies + HZ;\r\ngoto retry;\r\n}\r\nENABLE_VPP(map);\r\nmap_write(map, CMD(0x50), adr);\r\nmap_write(map, CMD(0x20), adr);\r\nmap_write(map, CMD(0xD0), adr);\r\nchip->state = FL_ERASING;\r\nmutex_unlock(&chip->mutex);\r\nmsleep(1000);\r\nmutex_lock(&chip->mutex);\r\ntimeo = jiffies + (HZ*20);\r\nfor (;;) {\r\nif (chip->state != FL_ERASING) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\ntimeo = jiffies + (HZ*20);\r\nmutex_lock(&chip->mutex);\r\ncontinue;\r\n}\r\nstatus = map_read(map, adr);\r\nif (map_word_andequal(map, status, status_OK, status_OK))\r\nbreak;\r\nif (time_after(jiffies, timeo)) {\r\nmap_write(map, CMD(0x70), adr);\r\nchip->state = FL_STATUS;\r\nprintk(KERN_ERR "waiting for erase to complete timed out. Xstatus = %lx, status = %lx.\n", status.x[0], map_read(map, adr).x[0]);\r\nDISABLE_VPP(map);\r\nmutex_unlock(&chip->mutex);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(1);\r\nmutex_lock(&chip->mutex);\r\n}\r\nDISABLE_VPP(map);\r\nret = 0;\r\nmap_write(map, CMD(0x70), adr);\r\nchip->state = FL_STATUS;\r\nstatus = map_read(map, adr);\r\nif (map_word_bitsset(map, status, CMD(0x3a))) {\r\nunsigned char chipstatus = status.x[0];\r\nif (!map_word_equal(map, status, CMD(chipstatus))) {\r\nint i, w;\r\nfor (w=0; w<map_words(map); w++) {\r\nfor (i = 0; i<cfi_interleave(cfi); i++) {\r\nchipstatus |= status.x[w] >> (cfi->device_type * 8);\r\n}\r\n}\r\nprintk(KERN_WARNING "Status is not identical for all chips: 0x%lx. Merging to give 0x%02x\n",\r\nstatus.x[0], chipstatus);\r\n}\r\nmap_write(map, CMD(0x50), adr);\r\nmap_write(map, CMD(0x70), adr);\r\nif ((chipstatus & 0x30) == 0x30) {\r\nprintk(KERN_NOTICE "Chip reports improper command sequence: status 0x%x\n", chipstatus);\r\nret = -EIO;\r\n} else if (chipstatus & 0x02) {\r\nret = -EROFS;\r\n} else if (chipstatus & 0x8) {\r\nprintk(KERN_WARNING "Chip reports voltage low on erase: status 0x%x\n", chipstatus);\r\nret = -EIO;\r\n} else if (chipstatus & 0x20) {\r\nif (retries--) {\r\nprintk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%x. Retrying...\n", adr, chipstatus);\r\ntimeo = jiffies + HZ;\r\nchip->state = FL_STATUS;\r\nmutex_unlock(&chip->mutex);\r\ngoto retry;\r\n}\r\nprintk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%x\n", adr, chipstatus);\r\nret = -EIO;\r\n}\r\n}\r\nwake_up(&chip->wq);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic int cfi_staa_erase_varsize(struct mtd_info *mtd,\r\nstruct erase_info *instr)\r\n{ struct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long adr, len;\r\nint chipnum, ret = 0;\r\nint i, first;\r\nstruct mtd_erase_region_info *regions = mtd->eraseregions;\r\ni = 0;\r\nwhile (i < mtd->numeraseregions && instr->addr >= regions[i].offset)\r\ni++;\r\ni--;\r\nif (instr->addr & (regions[i].erasesize-1))\r\nreturn -EINVAL;\r\nfirst = i;\r\nwhile (i<mtd->numeraseregions && (instr->addr + instr->len) >= regions[i].offset)\r\ni++;\r\ni--;\r\nif ((instr->addr + instr->len) & (regions[i].erasesize-1))\r\nreturn -EINVAL;\r\nchipnum = instr->addr >> cfi->chipshift;\r\nadr = instr->addr - (chipnum << cfi->chipshift);\r\nlen = instr->len;\r\ni=first;\r\nwhile(len) {\r\nret = do_erase_oneblock(map, &cfi->chips[chipnum], adr);\r\nif (ret)\r\nreturn ret;\r\nadr += regions[i].erasesize;\r\nlen -= regions[i].erasesize;\r\nif (adr % (1<< cfi->chipshift) == (((unsigned long)regions[i].offset + (regions[i].erasesize * regions[i].numblocks)) %( 1<< cfi->chipshift)))\r\ni++;\r\nif (adr >> cfi->chipshift) {\r\nadr = 0;\r\nchipnum++;\r\nif (chipnum >= cfi->numchips)\r\nbreak;\r\n}\r\n}\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\n}\r\nstatic void cfi_staa_sync (struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint i;\r\nstruct flchip *chip;\r\nint ret = 0;\r\nDECLARE_WAITQUEUE(wait, current);\r\nfor (i=0; !ret && i<cfi->numchips; i++) {\r\nchip = &cfi->chips[i];\r\nretry:\r\nmutex_lock(&chip->mutex);\r\nswitch(chip->state) {\r\ncase FL_READY:\r\ncase FL_STATUS:\r\ncase FL_CFI_QUERY:\r\ncase FL_JEDEC_QUERY:\r\nchip->oldstate = chip->state;\r\nchip->state = FL_SYNCING;\r\ncase FL_SYNCING:\r\nmutex_unlock(&chip->mutex);\r\nbreak;\r\ndefault:\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\ngoto retry;\r\n}\r\n}\r\nfor (i--; i >=0; i--) {\r\nchip = &cfi->chips[i];\r\nmutex_lock(&chip->mutex);\r\nif (chip->state == FL_SYNCING) {\r\nchip->state = chip->oldstate;\r\nwake_up(&chip->wq);\r\n}\r\nmutex_unlock(&chip->mutex);\r\n}\r\n}\r\nstatic inline int do_lock_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nmap_word status, status_OK;\r\nunsigned long timeo = jiffies + HZ;\r\nDECLARE_WAITQUEUE(wait, current);\r\nadr += chip->start;\r\nstatus_OK = CMD(0x80);\r\ntimeo = jiffies + HZ;\r\nretry:\r\nmutex_lock(&chip->mutex);\r\nswitch (chip->state) {\r\ncase FL_CFI_QUERY:\r\ncase FL_JEDEC_QUERY:\r\ncase FL_READY:\r\nmap_write(map, CMD(0x70), adr);\r\nchip->state = FL_STATUS;\r\ncase FL_STATUS:\r\nstatus = map_read(map, adr);\r\nif (map_word_andequal(map, status, status_OK, status_OK))\r\nbreak;\r\nif (time_after(jiffies, timeo)) {\r\nmutex_unlock(&chip->mutex);\r\nprintk(KERN_ERR "waiting for chip to be ready timed out in lock\n");\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(1);\r\ngoto retry;\r\ndefault:\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\ntimeo = jiffies + HZ;\r\ngoto retry;\r\n}\r\nENABLE_VPP(map);\r\nmap_write(map, CMD(0x60), adr);\r\nmap_write(map, CMD(0x01), adr);\r\nchip->state = FL_LOCKING;\r\nmutex_unlock(&chip->mutex);\r\nmsleep(1000);\r\nmutex_lock(&chip->mutex);\r\ntimeo = jiffies + (HZ*2);\r\nfor (;;) {\r\nstatus = map_read(map, adr);\r\nif (map_word_andequal(map, status, status_OK, status_OK))\r\nbreak;\r\nif (time_after(jiffies, timeo)) {\r\nmap_write(map, CMD(0x70), adr);\r\nchip->state = FL_STATUS;\r\nprintk(KERN_ERR "waiting for lock to complete timed out. Xstatus = %lx, status = %lx.\n", status.x[0], map_read(map, adr).x[0]);\r\nDISABLE_VPP(map);\r\nmutex_unlock(&chip->mutex);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(1);\r\nmutex_lock(&chip->mutex);\r\n}\r\nchip->state = FL_STATUS;\r\nDISABLE_VPP(map);\r\nwake_up(&chip->wq);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int cfi_staa_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long adr;\r\nint chipnum, ret = 0;\r\n#ifdef DEBUG_LOCK_BITS\r\nint ofs_factor = cfi->interleave * cfi->device_type;\r\n#endif\r\nif (ofs & (mtd->erasesize - 1))\r\nreturn -EINVAL;\r\nif (len & (mtd->erasesize -1))\r\nreturn -EINVAL;\r\nchipnum = ofs >> cfi->chipshift;\r\nadr = ofs - (chipnum << cfi->chipshift);\r\nwhile(len) {\r\n#ifdef DEBUG_LOCK_BITS\r\ncfi_send_gen_cmd(0x90, 0x55, 0, map, cfi, cfi->device_type, NULL);\r\nprintk("before lock: block status register is %x\n",cfi_read_query(map, adr+(2*ofs_factor)));\r\ncfi_send_gen_cmd(0xff, 0x55, 0, map, cfi, cfi->device_type, NULL);\r\n#endif\r\nret = do_lock_oneblock(map, &cfi->chips[chipnum], adr);\r\n#ifdef DEBUG_LOCK_BITS\r\ncfi_send_gen_cmd(0x90, 0x55, 0, map, cfi, cfi->device_type, NULL);\r\nprintk("after lock: block status register is %x\n",cfi_read_query(map, adr+(2*ofs_factor)));\r\ncfi_send_gen_cmd(0xff, 0x55, 0, map, cfi, cfi->device_type, NULL);\r\n#endif\r\nif (ret)\r\nreturn ret;\r\nadr += mtd->erasesize;\r\nlen -= mtd->erasesize;\r\nif (adr >> cfi->chipshift) {\r\nadr = 0;\r\nchipnum++;\r\nif (chipnum >= cfi->numchips)\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int do_unlock_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nmap_word status, status_OK;\r\nunsigned long timeo = jiffies + HZ;\r\nDECLARE_WAITQUEUE(wait, current);\r\nadr += chip->start;\r\nstatus_OK = CMD(0x80);\r\ntimeo = jiffies + HZ;\r\nretry:\r\nmutex_lock(&chip->mutex);\r\nswitch (chip->state) {\r\ncase FL_CFI_QUERY:\r\ncase FL_JEDEC_QUERY:\r\ncase FL_READY:\r\nmap_write(map, CMD(0x70), adr);\r\nchip->state = FL_STATUS;\r\ncase FL_STATUS:\r\nstatus = map_read(map, adr);\r\nif (map_word_andequal(map, status, status_OK, status_OK))\r\nbreak;\r\nif (time_after(jiffies, timeo)) {\r\nmutex_unlock(&chip->mutex);\r\nprintk(KERN_ERR "waiting for chip to be ready timed out in unlock\n");\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(1);\r\ngoto retry;\r\ndefault:\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\ntimeo = jiffies + HZ;\r\ngoto retry;\r\n}\r\nENABLE_VPP(map);\r\nmap_write(map, CMD(0x60), adr);\r\nmap_write(map, CMD(0xD0), adr);\r\nchip->state = FL_UNLOCKING;\r\nmutex_unlock(&chip->mutex);\r\nmsleep(1000);\r\nmutex_lock(&chip->mutex);\r\ntimeo = jiffies + (HZ*2);\r\nfor (;;) {\r\nstatus = map_read(map, adr);\r\nif (map_word_andequal(map, status, status_OK, status_OK))\r\nbreak;\r\nif (time_after(jiffies, timeo)) {\r\nmap_write(map, CMD(0x70), adr);\r\nchip->state = FL_STATUS;\r\nprintk(KERN_ERR "waiting for unlock to complete timed out. Xstatus = %lx, status = %lx.\n", status.x[0], map_read(map, adr).x[0]);\r\nDISABLE_VPP(map);\r\nmutex_unlock(&chip->mutex);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(1);\r\nmutex_lock(&chip->mutex);\r\n}\r\nchip->state = FL_STATUS;\r\nDISABLE_VPP(map);\r\nwake_up(&chip->wq);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int cfi_staa_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long adr;\r\nint chipnum, ret = 0;\r\n#ifdef DEBUG_LOCK_BITS\r\nint ofs_factor = cfi->interleave * cfi->device_type;\r\n#endif\r\nchipnum = ofs >> cfi->chipshift;\r\nadr = ofs - (chipnum << cfi->chipshift);\r\n#ifdef DEBUG_LOCK_BITS\r\n{\r\nunsigned long temp_adr = adr;\r\nunsigned long temp_len = len;\r\ncfi_send_gen_cmd(0x90, 0x55, 0, map, cfi, cfi->device_type, NULL);\r\nwhile (temp_len) {\r\nprintk("before unlock %x: block status register is %x\n",temp_adr,cfi_read_query(map, temp_adr+(2*ofs_factor)));\r\ntemp_adr += mtd->erasesize;\r\ntemp_len -= mtd->erasesize;\r\n}\r\ncfi_send_gen_cmd(0xff, 0x55, 0, map, cfi, cfi->device_type, NULL);\r\n}\r\n#endif\r\nret = do_unlock_oneblock(map, &cfi->chips[chipnum], adr);\r\n#ifdef DEBUG_LOCK_BITS\r\ncfi_send_gen_cmd(0x90, 0x55, 0, map, cfi, cfi->device_type, NULL);\r\nprintk("after unlock: block status register is %x\n",cfi_read_query(map, adr+(2*ofs_factor)));\r\ncfi_send_gen_cmd(0xff, 0x55, 0, map, cfi, cfi->device_type, NULL);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int cfi_staa_suspend(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint i;\r\nstruct flchip *chip;\r\nint ret = 0;\r\nfor (i=0; !ret && i<cfi->numchips; i++) {\r\nchip = &cfi->chips[i];\r\nmutex_lock(&chip->mutex);\r\nswitch(chip->state) {\r\ncase FL_READY:\r\ncase FL_STATUS:\r\ncase FL_CFI_QUERY:\r\ncase FL_JEDEC_QUERY:\r\nchip->oldstate = chip->state;\r\nchip->state = FL_PM_SUSPENDED;\r\ncase FL_PM_SUSPENDED:\r\nbreak;\r\ndefault:\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nmutex_unlock(&chip->mutex);\r\n}\r\nif (ret) {\r\nfor (i--; i >=0; i--) {\r\nchip = &cfi->chips[i];\r\nmutex_lock(&chip->mutex);\r\nif (chip->state == FL_PM_SUSPENDED) {\r\nchip->state = chip->oldstate;\r\nwake_up(&chip->wq);\r\n}\r\nmutex_unlock(&chip->mutex);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void cfi_staa_resume(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint i;\r\nstruct flchip *chip;\r\nfor (i=0; i<cfi->numchips; i++) {\r\nchip = &cfi->chips[i];\r\nmutex_lock(&chip->mutex);\r\nif (chip->state == FL_PM_SUSPENDED) {\r\nmap_write(map, CMD(0xFF), 0);\r\nchip->state = FL_READY;\r\nwake_up(&chip->wq);\r\n}\r\nmutex_unlock(&chip->mutex);\r\n}\r\n}\r\nstatic void cfi_staa_destroy(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nkfree(cfi->cmdset_priv);\r\nkfree(cfi);\r\n}
