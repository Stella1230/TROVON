static struct i2c_client *at24_translate_offset(struct at24_data *at24,\r\nunsigned int *offset)\r\n{\r\nunsigned i;\r\nif (at24->chip.flags & AT24_FLAG_ADDR16) {\r\ni = *offset >> 16;\r\n*offset &= 0xffff;\r\n} else {\r\ni = *offset >> 8;\r\n*offset &= 0xff;\r\n}\r\nreturn at24->client[i];\r\n}\r\nstatic ssize_t at24_eeprom_read_smbus(struct at24_data *at24, char *buf,\r\nunsigned int offset, size_t count)\r\n{\r\nunsigned long timeout, read_time;\r\nstruct i2c_client *client;\r\nint status;\r\nclient = at24_translate_offset(at24, &offset);\r\nif (count > io_limit)\r\ncount = io_limit;\r\nif (count > I2C_SMBUS_BLOCK_MAX)\r\ncount = I2C_SMBUS_BLOCK_MAX;\r\nloop_until_timeout(timeout, read_time) {\r\nstatus = i2c_smbus_read_i2c_block_data_or_emulated(client,\r\noffset,\r\ncount, buf);\r\ndev_dbg(&client->dev, "read %zu@%d --> %d (%ld)\n",\r\ncount, offset, status, jiffies);\r\nif (status == count)\r\nreturn count;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic ssize_t at24_eeprom_read_i2c(struct at24_data *at24, char *buf,\r\nunsigned int offset, size_t count)\r\n{\r\nunsigned long timeout, read_time;\r\nstruct i2c_client *client;\r\nstruct i2c_msg msg[2];\r\nint status, i;\r\nu8 msgbuf[2];\r\nmemset(msg, 0, sizeof(msg));\r\nclient = at24_translate_offset(at24, &offset);\r\nif (count > io_limit)\r\ncount = io_limit;\r\ni = 0;\r\nif (at24->chip.flags & AT24_FLAG_ADDR16)\r\nmsgbuf[i++] = offset >> 8;\r\nmsgbuf[i++] = offset;\r\nmsg[0].addr = client->addr;\r\nmsg[0].buf = msgbuf;\r\nmsg[0].len = i;\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].buf = buf;\r\nmsg[1].len = count;\r\nloop_until_timeout(timeout, read_time) {\r\nstatus = i2c_transfer(client->adapter, msg, 2);\r\nif (status == 2)\r\nstatus = count;\r\ndev_dbg(&client->dev, "read %zu@%d --> %d (%ld)\n",\r\ncount, offset, status, jiffies);\r\nif (status == count)\r\nreturn count;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic ssize_t at24_eeprom_read_serial(struct at24_data *at24, char *buf,\r\nunsigned int offset, size_t count)\r\n{\r\nunsigned long timeout, read_time;\r\nstruct i2c_client *client;\r\nstruct i2c_msg msg[2];\r\nu8 addrbuf[2];\r\nint status;\r\nclient = at24_translate_offset(at24, &offset);\r\nmemset(msg, 0, sizeof(msg));\r\nmsg[0].addr = client->addr;\r\nmsg[0].buf = addrbuf;\r\nif (at24->chip.flags & AT24_FLAG_ADDR16) {\r\naddrbuf[0] = 0x08;\r\naddrbuf[1] = offset;\r\nmsg[0].len = 2;\r\n} else {\r\naddrbuf[0] = 0x80 + offset;\r\nmsg[0].len = 1;\r\n}\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].buf = buf;\r\nmsg[1].len = count;\r\nloop_until_timeout(timeout, read_time) {\r\nstatus = i2c_transfer(client->adapter, msg, 2);\r\nif (status == 2)\r\nreturn count;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic ssize_t at24_eeprom_read_mac(struct at24_data *at24, char *buf,\r\nunsigned int offset, size_t count)\r\n{\r\nunsigned long timeout, read_time;\r\nstruct i2c_client *client;\r\nstruct i2c_msg msg[2];\r\nu8 addrbuf[2];\r\nint status;\r\nclient = at24_translate_offset(at24, &offset);\r\nmemset(msg, 0, sizeof(msg));\r\nmsg[0].addr = client->addr;\r\nmsg[0].buf = addrbuf;\r\naddrbuf[0] = 0x90 + offset;\r\nmsg[0].len = 1;\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].buf = buf;\r\nmsg[1].len = count;\r\nloop_until_timeout(timeout, read_time) {\r\nstatus = i2c_transfer(client->adapter, msg, 2);\r\nif (status == 2)\r\nreturn count;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic size_t at24_adjust_write_count(struct at24_data *at24,\r\nunsigned int offset, size_t count)\r\n{\r\nunsigned next_page;\r\nif (count > at24->write_max)\r\ncount = at24->write_max;\r\nnext_page = roundup(offset + 1, at24->chip.page_size);\r\nif (offset + count > next_page)\r\ncount = next_page - offset;\r\nreturn count;\r\n}\r\nstatic ssize_t at24_eeprom_write_smbus_block(struct at24_data *at24,\r\nconst char *buf,\r\nunsigned int offset, size_t count)\r\n{\r\nunsigned long timeout, write_time;\r\nstruct i2c_client *client;\r\nssize_t status = 0;\r\nclient = at24_translate_offset(at24, &offset);\r\ncount = at24_adjust_write_count(at24, offset, count);\r\nloop_until_timeout(timeout, write_time) {\r\nstatus = i2c_smbus_write_i2c_block_data(client,\r\noffset, count, buf);\r\nif (status == 0)\r\nstatus = count;\r\ndev_dbg(&client->dev, "write %zu@%d --> %zd (%ld)\n",\r\ncount, offset, status, jiffies);\r\nif (status == count)\r\nreturn count;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic ssize_t at24_eeprom_write_smbus_byte(struct at24_data *at24,\r\nconst char *buf,\r\nunsigned int offset, size_t count)\r\n{\r\nunsigned long timeout, write_time;\r\nstruct i2c_client *client;\r\nssize_t status = 0;\r\nclient = at24_translate_offset(at24, &offset);\r\nloop_until_timeout(timeout, write_time) {\r\nstatus = i2c_smbus_write_byte_data(client, offset, buf[0]);\r\nif (status == 0)\r\nstatus = count;\r\ndev_dbg(&client->dev, "write %zu@%d --> %zd (%ld)\n",\r\ncount, offset, status, jiffies);\r\nif (status == count)\r\nreturn count;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic ssize_t at24_eeprom_write_i2c(struct at24_data *at24, const char *buf,\r\nunsigned int offset, size_t count)\r\n{\r\nunsigned long timeout, write_time;\r\nstruct i2c_client *client;\r\nstruct i2c_msg msg;\r\nssize_t status = 0;\r\nint i = 0;\r\nclient = at24_translate_offset(at24, &offset);\r\ncount = at24_adjust_write_count(at24, offset, count);\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.buf = at24->writebuf;\r\nif (at24->chip.flags & AT24_FLAG_ADDR16)\r\nmsg.buf[i++] = offset >> 8;\r\nmsg.buf[i++] = offset;\r\nmemcpy(&msg.buf[i], buf, count);\r\nmsg.len = i + count;\r\nloop_until_timeout(timeout, write_time) {\r\nstatus = i2c_transfer(client->adapter, &msg, 1);\r\nif (status == 1)\r\nstatus = count;\r\ndev_dbg(&client->dev, "write %zu@%d --> %zd (%ld)\n",\r\ncount, offset, status, jiffies);\r\nif (status == count)\r\nreturn count;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int at24_read(void *priv, unsigned int off, void *val, size_t count)\r\n{\r\nstruct at24_data *at24 = priv;\r\nchar *buf = val;\r\nif (unlikely(!count))\r\nreturn count;\r\nmutex_lock(&at24->lock);\r\nwhile (count) {\r\nint status;\r\nstatus = at24->read_func(at24, buf, off, count);\r\nif (status < 0) {\r\nmutex_unlock(&at24->lock);\r\nreturn status;\r\n}\r\nbuf += status;\r\noff += status;\r\ncount -= status;\r\n}\r\nmutex_unlock(&at24->lock);\r\nreturn 0;\r\n}\r\nstatic int at24_write(void *priv, unsigned int off, void *val, size_t count)\r\n{\r\nstruct at24_data *at24 = priv;\r\nchar *buf = val;\r\nif (unlikely(!count))\r\nreturn -EINVAL;\r\nmutex_lock(&at24->lock);\r\nwhile (count) {\r\nint status;\r\nstatus = at24->write_func(at24, buf, off, count);\r\nif (status < 0) {\r\nmutex_unlock(&at24->lock);\r\nreturn status;\r\n}\r\nbuf += status;\r\noff += status;\r\ncount -= status;\r\n}\r\nmutex_unlock(&at24->lock);\r\nreturn 0;\r\n}\r\nstatic void at24_get_pdata(struct device *dev, struct at24_platform_data *chip)\r\n{\r\nint err;\r\nu32 val;\r\nif (device_property_present(dev, "read-only"))\r\nchip->flags |= AT24_FLAG_READONLY;\r\nerr = device_property_read_u32(dev, "pagesize", &val);\r\nif (!err) {\r\nchip->page_size = val;\r\n} else {\r\nchip->page_size = 1;\r\n}\r\n}\r\nstatic int at24_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct at24_platform_data chip;\r\nkernel_ulong_t magic = 0;\r\nbool writable;\r\nint use_smbus = 0;\r\nint use_smbus_write = 0;\r\nstruct at24_data *at24;\r\nint err;\r\nunsigned i, num_addresses;\r\nu8 test_byte;\r\nif (client->dev.platform_data) {\r\nchip = *(struct at24_platform_data *)client->dev.platform_data;\r\n} else {\r\nif (id) {\r\nmagic = id->driver_data;\r\n} else {\r\nconst struct acpi_device_id *aid;\r\naid = acpi_match_device(at24_acpi_ids, &client->dev);\r\nif (aid)\r\nmagic = aid->driver_data;\r\n}\r\nif (!magic)\r\nreturn -ENODEV;\r\nchip.byte_len = BIT(magic & AT24_BITMASK(AT24_SIZE_BYTELEN));\r\nmagic >>= AT24_SIZE_BYTELEN;\r\nchip.flags = magic & AT24_BITMASK(AT24_SIZE_FLAGS);\r\nat24_get_pdata(&client->dev, &chip);\r\nchip.setup = NULL;\r\nchip.context = NULL;\r\n}\r\nif (!is_power_of_2(chip.byte_len))\r\ndev_warn(&client->dev,\r\n"byte_len looks suspicious (no power of 2)!\n");\r\nif (!chip.page_size) {\r\ndev_err(&client->dev, "page_size must not be 0!\n");\r\nreturn -EINVAL;\r\n}\r\nif (!is_power_of_2(chip.page_size))\r\ndev_warn(&client->dev,\r\n"page_size looks suspicious (no power of 2)!\n");\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\nif (chip.flags & AT24_FLAG_ADDR16)\r\nreturn -EPFNOSUPPORT;\r\nif (i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_I2C_BLOCK)) {\r\nuse_smbus = I2C_SMBUS_I2C_BLOCK_DATA;\r\n} else if (i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_WORD_DATA)) {\r\nuse_smbus = I2C_SMBUS_WORD_DATA;\r\n} else if (i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_BYTE_DATA)) {\r\nuse_smbus = I2C_SMBUS_BYTE_DATA;\r\n} else {\r\nreturn -EPFNOSUPPORT;\r\n}\r\nif (i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_WRITE_I2C_BLOCK)) {\r\nuse_smbus_write = I2C_SMBUS_I2C_BLOCK_DATA;\r\n} else if (i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_WRITE_BYTE_DATA)) {\r\nuse_smbus_write = I2C_SMBUS_BYTE_DATA;\r\nchip.page_size = 1;\r\n}\r\n}\r\nif (chip.flags & AT24_FLAG_TAKE8ADDR)\r\nnum_addresses = 8;\r\nelse\r\nnum_addresses = DIV_ROUND_UP(chip.byte_len,\r\n(chip.flags & AT24_FLAG_ADDR16) ? 65536 : 256);\r\nat24 = devm_kzalloc(&client->dev, sizeof(struct at24_data) +\r\nnum_addresses * sizeof(struct i2c_client *), GFP_KERNEL);\r\nif (!at24)\r\nreturn -ENOMEM;\r\nmutex_init(&at24->lock);\r\nat24->use_smbus = use_smbus;\r\nat24->use_smbus_write = use_smbus_write;\r\nat24->chip = chip;\r\nat24->num_addresses = num_addresses;\r\nif ((chip.flags & AT24_FLAG_SERIAL) && (chip.flags & AT24_FLAG_MAC)) {\r\ndev_err(&client->dev,\r\n"invalid device data - cannot have both AT24_FLAG_SERIAL & AT24_FLAG_MAC.");\r\nreturn -EINVAL;\r\n}\r\nif (chip.flags & AT24_FLAG_SERIAL) {\r\nat24->read_func = at24_eeprom_read_serial;\r\n} else if (chip.flags & AT24_FLAG_MAC) {\r\nat24->read_func = at24_eeprom_read_mac;\r\n} else {\r\nat24->read_func = at24->use_smbus ? at24_eeprom_read_smbus\r\n: at24_eeprom_read_i2c;\r\n}\r\nif (at24->use_smbus) {\r\nif (at24->use_smbus_write == I2C_SMBUS_I2C_BLOCK_DATA)\r\nat24->write_func = at24_eeprom_write_smbus_block;\r\nelse\r\nat24->write_func = at24_eeprom_write_smbus_byte;\r\n} else {\r\nat24->write_func = at24_eeprom_write_i2c;\r\n}\r\nwritable = !(chip.flags & AT24_FLAG_READONLY);\r\nif (writable) {\r\nif (!use_smbus || use_smbus_write) {\r\nunsigned write_max = chip.page_size;\r\nif (write_max > io_limit)\r\nwrite_max = io_limit;\r\nif (use_smbus && write_max > I2C_SMBUS_BLOCK_MAX)\r\nwrite_max = I2C_SMBUS_BLOCK_MAX;\r\nat24->write_max = write_max;\r\nat24->writebuf = devm_kzalloc(&client->dev,\r\nwrite_max + 2, GFP_KERNEL);\r\nif (!at24->writebuf)\r\nreturn -ENOMEM;\r\n} else {\r\ndev_warn(&client->dev,\r\n"cannot write due to controller restrictions.");\r\n}\r\n}\r\nat24->client[0] = client;\r\nfor (i = 1; i < num_addresses; i++) {\r\nat24->client[i] = i2c_new_dummy(client->adapter,\r\nclient->addr + i);\r\nif (!at24->client[i]) {\r\ndev_err(&client->dev, "address 0x%02x unavailable\n",\r\nclient->addr + i);\r\nerr = -EADDRINUSE;\r\ngoto err_clients;\r\n}\r\n}\r\ni2c_set_clientdata(client, at24);\r\nerr = at24_read(at24, 0, &test_byte, 1);\r\nif (err) {\r\nerr = -ENODEV;\r\ngoto err_clients;\r\n}\r\nat24->nvmem_config.name = dev_name(&client->dev);\r\nat24->nvmem_config.dev = &client->dev;\r\nat24->nvmem_config.read_only = !writable;\r\nat24->nvmem_config.root_only = true;\r\nat24->nvmem_config.owner = THIS_MODULE;\r\nat24->nvmem_config.compat = true;\r\nat24->nvmem_config.base_dev = &client->dev;\r\nat24->nvmem_config.reg_read = at24_read;\r\nat24->nvmem_config.reg_write = at24_write;\r\nat24->nvmem_config.priv = at24;\r\nat24->nvmem_config.stride = 4;\r\nat24->nvmem_config.word_size = 1;\r\nat24->nvmem_config.size = chip.byte_len;\r\nat24->nvmem = nvmem_register(&at24->nvmem_config);\r\nif (IS_ERR(at24->nvmem)) {\r\nerr = PTR_ERR(at24->nvmem);\r\ngoto err_clients;\r\n}\r\ndev_info(&client->dev, "%u byte %s EEPROM, %s, %u bytes/write\n",\r\nchip.byte_len, client->name,\r\nwritable ? "writable" : "read-only", at24->write_max);\r\nif (use_smbus == I2C_SMBUS_WORD_DATA ||\r\nuse_smbus == I2C_SMBUS_BYTE_DATA) {\r\ndev_notice(&client->dev, "Falling back to %s reads, "\r\n"performance will suffer\n", use_smbus ==\r\nI2C_SMBUS_WORD_DATA ? "word" : "byte");\r\n}\r\nif (chip.setup)\r\nchip.setup(at24->nvmem, chip.context);\r\nreturn 0;\r\nerr_clients:\r\nfor (i = 1; i < num_addresses; i++)\r\nif (at24->client[i])\r\ni2c_unregister_device(at24->client[i]);\r\nreturn err;\r\n}\r\nstatic int at24_remove(struct i2c_client *client)\r\n{\r\nstruct at24_data *at24;\r\nint i;\r\nat24 = i2c_get_clientdata(client);\r\nnvmem_unregister(at24->nvmem);\r\nfor (i = 1; i < at24->num_addresses; i++)\r\ni2c_unregister_device(at24->client[i]);\r\nreturn 0;\r\n}\r\nstatic int __init at24_init(void)\r\n{\r\nif (!io_limit) {\r\npr_err("at24: io_limit must not be 0!\n");\r\nreturn -EINVAL;\r\n}\r\nio_limit = rounddown_pow_of_two(io_limit);\r\nreturn i2c_add_driver(&at24_driver);\r\n}\r\nstatic void __exit at24_exit(void)\r\n{\r\ni2c_del_driver(&at24_driver);\r\n}
