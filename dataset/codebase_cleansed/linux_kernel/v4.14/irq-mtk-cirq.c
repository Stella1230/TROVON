static void mtk_cirq_write_mask(struct irq_data *data, unsigned int offset)\r\n{\r\nstruct mtk_cirq_chip_data *chip_data = data->chip_data;\r\nunsigned int cirq_num = data->hwirq;\r\nu32 mask = 1 << (cirq_num % 32);\r\nwritel_relaxed(mask, chip_data->base + offset + (cirq_num / 32) * 4);\r\n}\r\nstatic void mtk_cirq_mask(struct irq_data *data)\r\n{\r\nmtk_cirq_write_mask(data, CIRQ_MASK_SET);\r\nirq_chip_mask_parent(data);\r\n}\r\nstatic void mtk_cirq_unmask(struct irq_data *data)\r\n{\r\nmtk_cirq_write_mask(data, CIRQ_MASK_CLR);\r\nirq_chip_unmask_parent(data);\r\n}\r\nstatic int mtk_cirq_set_type(struct irq_data *data, unsigned int type)\r\n{\r\nint ret;\r\nswitch (type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nmtk_cirq_write_mask(data, CIRQ_POL_CLR);\r\nmtk_cirq_write_mask(data, CIRQ_SENS_CLR);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nmtk_cirq_write_mask(data, CIRQ_POL_SET);\r\nmtk_cirq_write_mask(data, CIRQ_SENS_CLR);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nmtk_cirq_write_mask(data, CIRQ_POL_CLR);\r\nmtk_cirq_write_mask(data, CIRQ_SENS_SET);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nmtk_cirq_write_mask(data, CIRQ_POL_SET);\r\nmtk_cirq_write_mask(data, CIRQ_SENS_SET);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndata = data->parent_data;\r\nret = data->chip->irq_set_type(data, type);\r\nreturn ret;\r\n}\r\nstatic int mtk_cirq_domain_translate(struct irq_domain *d,\r\nstruct irq_fwspec *fwspec,\r\nunsigned long *hwirq,\r\nunsigned int *type)\r\n{\r\nif (is_of_node(fwspec->fwnode)) {\r\nif (fwspec->param_count != 3)\r\nreturn -EINVAL;\r\nif (fwspec->param[0] != 0)\r\nreturn -EINVAL;\r\nif (fwspec->param[1] < cirq_data->ext_irq_start ||\r\nfwspec->param[1] > cirq_data->ext_irq_end)\r\nreturn -EINVAL;\r\n*hwirq = fwspec->param[1] - cirq_data->ext_irq_start;\r\n*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mtk_cirq_domain_alloc(struct irq_domain *domain, unsigned int virq,\r\nunsigned int nr_irqs, void *arg)\r\n{\r\nint ret;\r\nirq_hw_number_t hwirq;\r\nunsigned int type;\r\nstruct irq_fwspec *fwspec = arg;\r\nstruct irq_fwspec parent_fwspec = *fwspec;\r\nret = mtk_cirq_domain_translate(domain, fwspec, &hwirq, &type);\r\nif (ret)\r\nreturn ret;\r\nif (WARN_ON(nr_irqs != 1))\r\nreturn -EINVAL;\r\nirq_domain_set_hwirq_and_chip(domain, virq, hwirq,\r\n&mtk_cirq_chip,\r\ndomain->host_data);\r\nparent_fwspec.fwnode = domain->parent->fwnode;\r\nreturn irq_domain_alloc_irqs_parent(domain, virq, nr_irqs,\r\n&parent_fwspec);\r\n}\r\nstatic int mtk_cirq_suspend(void)\r\n{\r\nu32 value, mask;\r\nunsigned int irq, hwirq_num;\r\nbool pending, masked;\r\nint i, pendret, maskret;\r\nhwirq_num = cirq_data->ext_irq_end - cirq_data->ext_irq_start + 1;\r\nfor (i = 0; i < hwirq_num; i++) {\r\nirq = irq_find_mapping(cirq_data->domain, i);\r\nif (irq) {\r\npendret = irq_get_irqchip_state(irq,\r\nIRQCHIP_STATE_PENDING,\r\n&pending);\r\nmaskret = irq_get_irqchip_state(irq,\r\nIRQCHIP_STATE_MASKED,\r\n&masked);\r\nif (pendret == 0 && maskret == 0 &&\r\n(pending && !masked))\r\ncontinue;\r\n}\r\nmask = 1 << (i % 32);\r\nwritel_relaxed(mask, cirq_data->base + CIRQ_ACK + (i / 32) * 4);\r\n}\r\nvalue = readl_relaxed(cirq_data->base + CIRQ_CONTROL);\r\nvalue |= (CIRQ_EDGE | CIRQ_EN);\r\nwritel_relaxed(value, cirq_data->base + CIRQ_CONTROL);\r\nreturn 0;\r\n}\r\nstatic void mtk_cirq_resume(void)\r\n{\r\nu32 value;\r\nvalue = readl_relaxed(cirq_data->base + CIRQ_CONTROL);\r\nwritel_relaxed(value | CIRQ_FLUSH, cirq_data->base + CIRQ_CONTROL);\r\nvalue = readl_relaxed(cirq_data->base + CIRQ_CONTROL);\r\nvalue &= ~(CIRQ_EDGE | CIRQ_EN);\r\nwritel_relaxed(value, cirq_data->base + CIRQ_CONTROL);\r\n}\r\nstatic void mtk_cirq_syscore_init(void)\r\n{\r\nregister_syscore_ops(&mtk_cirq_syscore_ops);\r\n}\r\nstatic inline void mtk_cirq_syscore_init(void) {}\r\nstatic int __init mtk_cirq_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct irq_domain *domain, *domain_parent;\r\nunsigned int irq_num;\r\nint ret;\r\ndomain_parent = irq_find_host(parent);\r\nif (!domain_parent) {\r\npr_err("mtk_cirq: interrupt-parent not found\n");\r\nreturn -EINVAL;\r\n}\r\ncirq_data = kzalloc(sizeof(*cirq_data), GFP_KERNEL);\r\nif (!cirq_data)\r\nreturn -ENOMEM;\r\ncirq_data->base = of_iomap(node, 0);\r\nif (!cirq_data->base) {\r\npr_err("mtk_cirq: unable to map cirq register\n");\r\nret = -ENXIO;\r\ngoto out_free;\r\n}\r\nret = of_property_read_u32_index(node, "mediatek,ext-irq-range", 0,\r\n&cirq_data->ext_irq_start);\r\nif (ret)\r\ngoto out_unmap;\r\nret = of_property_read_u32_index(node, "mediatek,ext-irq-range", 1,\r\n&cirq_data->ext_irq_end);\r\nif (ret)\r\ngoto out_unmap;\r\nirq_num = cirq_data->ext_irq_end - cirq_data->ext_irq_start + 1;\r\ndomain = irq_domain_add_hierarchy(domain_parent, 0,\r\nirq_num, node,\r\n&cirq_domain_ops, cirq_data);\r\nif (!domain) {\r\nret = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\ncirq_data->domain = domain;\r\nmtk_cirq_syscore_init();\r\nreturn 0;\r\nout_unmap:\r\niounmap(cirq_data->base);\r\nout_free:\r\nkfree(cirq_data);\r\nreturn ret;\r\n}
