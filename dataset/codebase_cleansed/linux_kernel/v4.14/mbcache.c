static inline struct hlist_bl_head *mb_cache_entry_head(struct mb_cache *cache,\r\nu32 key)\r\n{\r\nreturn &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\r\n}\r\nint mb_cache_entry_create(struct mb_cache *cache, gfp_t mask, u32 key,\r\nu64 value, bool reusable)\r\n{\r\nstruct mb_cache_entry *entry, *dup;\r\nstruct hlist_bl_node *dup_node;\r\nstruct hlist_bl_head *head;\r\nif (cache->c_entry_count >= cache->c_max_entries)\r\nschedule_work(&cache->c_shrink_work);\r\nif (cache->c_entry_count >= 2*cache->c_max_entries)\r\nmb_cache_shrink(cache, SYNC_SHRINK_BATCH);\r\nentry = kmem_cache_alloc(mb_entry_cache, mask);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&entry->e_list);\r\natomic_set(&entry->e_refcnt, 1);\r\nentry->e_key = key;\r\nentry->e_value = value;\r\nentry->e_reusable = reusable;\r\nhead = mb_cache_entry_head(cache, key);\r\nhlist_bl_lock(head);\r\nhlist_bl_for_each_entry(dup, dup_node, head, e_hash_list) {\r\nif (dup->e_key == key && dup->e_value == value) {\r\nhlist_bl_unlock(head);\r\nkmem_cache_free(mb_entry_cache, entry);\r\nreturn -EBUSY;\r\n}\r\n}\r\nhlist_bl_add_head(&entry->e_hash_list, head);\r\nhlist_bl_unlock(head);\r\nspin_lock(&cache->c_list_lock);\r\nlist_add_tail(&entry->e_list, &cache->c_list);\r\natomic_inc(&entry->e_refcnt);\r\ncache->c_entry_count++;\r\nspin_unlock(&cache->c_list_lock);\r\nreturn 0;\r\n}\r\nvoid __mb_cache_entry_free(struct mb_cache_entry *entry)\r\n{\r\nkmem_cache_free(mb_entry_cache, entry);\r\n}\r\nstatic struct mb_cache_entry *__entry_find(struct mb_cache *cache,\r\nstruct mb_cache_entry *entry,\r\nu32 key)\r\n{\r\nstruct mb_cache_entry *old_entry = entry;\r\nstruct hlist_bl_node *node;\r\nstruct hlist_bl_head *head;\r\nhead = mb_cache_entry_head(cache, key);\r\nhlist_bl_lock(head);\r\nif (entry && !hlist_bl_unhashed(&entry->e_hash_list))\r\nnode = entry->e_hash_list.next;\r\nelse\r\nnode = hlist_bl_first(head);\r\nwhile (node) {\r\nentry = hlist_bl_entry(node, struct mb_cache_entry,\r\ne_hash_list);\r\nif (entry->e_key == key && entry->e_reusable) {\r\natomic_inc(&entry->e_refcnt);\r\ngoto out;\r\n}\r\nnode = node->next;\r\n}\r\nentry = NULL;\r\nout:\r\nhlist_bl_unlock(head);\r\nif (old_entry)\r\nmb_cache_entry_put(cache, old_entry);\r\nreturn entry;\r\n}\r\nstruct mb_cache_entry *mb_cache_entry_find_first(struct mb_cache *cache,\r\nu32 key)\r\n{\r\nreturn __entry_find(cache, NULL, key);\r\n}\r\nstruct mb_cache_entry *mb_cache_entry_find_next(struct mb_cache *cache,\r\nstruct mb_cache_entry *entry)\r\n{\r\nreturn __entry_find(cache, entry, entry->e_key);\r\n}\r\nstruct mb_cache_entry *mb_cache_entry_get(struct mb_cache *cache, u32 key,\r\nu64 value)\r\n{\r\nstruct hlist_bl_node *node;\r\nstruct hlist_bl_head *head;\r\nstruct mb_cache_entry *entry;\r\nhead = mb_cache_entry_head(cache, key);\r\nhlist_bl_lock(head);\r\nhlist_bl_for_each_entry(entry, node, head, e_hash_list) {\r\nif (entry->e_key == key && entry->e_value == value) {\r\natomic_inc(&entry->e_refcnt);\r\ngoto out;\r\n}\r\n}\r\nentry = NULL;\r\nout:\r\nhlist_bl_unlock(head);\r\nreturn entry;\r\n}\r\nvoid mb_cache_entry_delete(struct mb_cache *cache, u32 key, u64 value)\r\n{\r\nstruct hlist_bl_node *node;\r\nstruct hlist_bl_head *head;\r\nstruct mb_cache_entry *entry;\r\nhead = mb_cache_entry_head(cache, key);\r\nhlist_bl_lock(head);\r\nhlist_bl_for_each_entry(entry, node, head, e_hash_list) {\r\nif (entry->e_key == key && entry->e_value == value) {\r\nhlist_bl_del_init(&entry->e_hash_list);\r\nhlist_bl_unlock(head);\r\nspin_lock(&cache->c_list_lock);\r\nif (!list_empty(&entry->e_list)) {\r\nlist_del_init(&entry->e_list);\r\ncache->c_entry_count--;\r\natomic_dec(&entry->e_refcnt);\r\n}\r\nspin_unlock(&cache->c_list_lock);\r\nmb_cache_entry_put(cache, entry);\r\nreturn;\r\n}\r\n}\r\nhlist_bl_unlock(head);\r\n}\r\nvoid mb_cache_entry_touch(struct mb_cache *cache,\r\nstruct mb_cache_entry *entry)\r\n{\r\nentry->e_referenced = 1;\r\n}\r\nstatic unsigned long mb_cache_count(struct shrinker *shrink,\r\nstruct shrink_control *sc)\r\n{\r\nstruct mb_cache *cache = container_of(shrink, struct mb_cache,\r\nc_shrink);\r\nreturn cache->c_entry_count;\r\n}\r\nstatic unsigned long mb_cache_shrink(struct mb_cache *cache,\r\nunsigned long nr_to_scan)\r\n{\r\nstruct mb_cache_entry *entry;\r\nstruct hlist_bl_head *head;\r\nunsigned long shrunk = 0;\r\nspin_lock(&cache->c_list_lock);\r\nwhile (nr_to_scan-- && !list_empty(&cache->c_list)) {\r\nentry = list_first_entry(&cache->c_list,\r\nstruct mb_cache_entry, e_list);\r\nif (entry->e_referenced) {\r\nentry->e_referenced = 0;\r\nlist_move_tail(&entry->e_list, &cache->c_list);\r\ncontinue;\r\n}\r\nlist_del_init(&entry->e_list);\r\ncache->c_entry_count--;\r\nspin_unlock(&cache->c_list_lock);\r\nhead = mb_cache_entry_head(cache, entry->e_key);\r\nhlist_bl_lock(head);\r\nif (!hlist_bl_unhashed(&entry->e_hash_list)) {\r\nhlist_bl_del_init(&entry->e_hash_list);\r\natomic_dec(&entry->e_refcnt);\r\n}\r\nhlist_bl_unlock(head);\r\nif (mb_cache_entry_put(cache, entry))\r\nshrunk++;\r\ncond_resched();\r\nspin_lock(&cache->c_list_lock);\r\n}\r\nspin_unlock(&cache->c_list_lock);\r\nreturn shrunk;\r\n}\r\nstatic unsigned long mb_cache_scan(struct shrinker *shrink,\r\nstruct shrink_control *sc)\r\n{\r\nstruct mb_cache *cache = container_of(shrink, struct mb_cache,\r\nc_shrink);\r\nreturn mb_cache_shrink(cache, sc->nr_to_scan);\r\n}\r\nstatic void mb_cache_shrink_worker(struct work_struct *work)\r\n{\r\nstruct mb_cache *cache = container_of(work, struct mb_cache,\r\nc_shrink_work);\r\nmb_cache_shrink(cache, cache->c_max_entries / SHRINK_DIVISOR);\r\n}\r\nstruct mb_cache *mb_cache_create(int bucket_bits)\r\n{\r\nstruct mb_cache *cache;\r\nunsigned long bucket_count = 1UL << bucket_bits;\r\nunsigned long i;\r\ncache = kzalloc(sizeof(struct mb_cache), GFP_KERNEL);\r\nif (!cache)\r\ngoto err_out;\r\ncache->c_bucket_bits = bucket_bits;\r\ncache->c_max_entries = bucket_count << 4;\r\nINIT_LIST_HEAD(&cache->c_list);\r\nspin_lock_init(&cache->c_list_lock);\r\ncache->c_hash = kmalloc(bucket_count * sizeof(struct hlist_bl_head),\r\nGFP_KERNEL);\r\nif (!cache->c_hash) {\r\nkfree(cache);\r\ngoto err_out;\r\n}\r\nfor (i = 0; i < bucket_count; i++)\r\nINIT_HLIST_BL_HEAD(&cache->c_hash[i]);\r\ncache->c_shrink.count_objects = mb_cache_count;\r\ncache->c_shrink.scan_objects = mb_cache_scan;\r\ncache->c_shrink.seeks = DEFAULT_SEEKS;\r\nif (register_shrinker(&cache->c_shrink)) {\r\nkfree(cache->c_hash);\r\nkfree(cache);\r\ngoto err_out;\r\n}\r\nINIT_WORK(&cache->c_shrink_work, mb_cache_shrink_worker);\r\nreturn cache;\r\nerr_out:\r\nreturn NULL;\r\n}\r\nvoid mb_cache_destroy(struct mb_cache *cache)\r\n{\r\nstruct mb_cache_entry *entry, *next;\r\nunregister_shrinker(&cache->c_shrink);\r\nlist_for_each_entry_safe(entry, next, &cache->c_list, e_list) {\r\nif (!hlist_bl_unhashed(&entry->e_hash_list)) {\r\nhlist_bl_del_init(&entry->e_hash_list);\r\natomic_dec(&entry->e_refcnt);\r\n} else\r\nWARN_ON(1);\r\nlist_del(&entry->e_list);\r\nWARN_ON(atomic_read(&entry->e_refcnt) != 1);\r\nmb_cache_entry_put(cache, entry);\r\n}\r\nkfree(cache->c_hash);\r\nkfree(cache);\r\n}\r\nstatic int __init mbcache_init(void)\r\n{\r\nmb_entry_cache = kmem_cache_create("mbcache",\r\nsizeof(struct mb_cache_entry), 0,\r\nSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\r\nif (!mb_entry_cache)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __exit mbcache_exit(void)\r\n{\r\nkmem_cache_destroy(mb_entry_cache);\r\n}
