static inline void\r\nsisusbcon_memsetw(u16 *s, u16 c, unsigned int count)\r\n{\r\ncount /= 2;\r\nwhile (count--)\r\nsisusbcon_writew(c, s++);\r\n}\r\nstatic inline void\r\nsisusb_initialize(struct sisusb_usb_data *sisusb)\r\n{\r\nif (sisusb_setidxreg(sisusb, SISCR, 0x0c, 0x00))\r\nreturn;\r\nif (sisusb_setidxreg(sisusb, SISCR, 0x0d, 0x00))\r\nreturn;\r\nif (sisusb_setidxreg(sisusb, SISCR, 0x0e, 0x00))\r\nreturn;\r\nsisusb_setidxreg(sisusb, SISCR, 0x0f, 0x00);\r\n}\r\nstatic inline void\r\nsisusbcon_set_start_address(struct sisusb_usb_data *sisusb, struct vc_data *c)\r\n{\r\nsisusb->cur_start_addr = (c->vc_visible_origin - sisusb->scrbuf) / 2;\r\nsisusb_setidxreg(sisusb, SISCR, 0x0c, (sisusb->cur_start_addr >> 8));\r\nsisusb_setidxreg(sisusb, SISCR, 0x0d, (sisusb->cur_start_addr & 0xff));\r\n}\r\nvoid\r\nsisusb_set_cursor(struct sisusb_usb_data *sisusb, unsigned int location)\r\n{\r\nif (sisusb->sisusb_cursor_loc == location)\r\nreturn;\r\nsisusb->sisusb_cursor_loc = location;\r\nif ((location & 0x0007) == 0x0007) {\r\nsisusb->bad_cursor_pos = 1;\r\nlocation--;\r\nif (sisusb_setidxregandor(sisusb, SISCR, 0x0b, 0x1f, 0x20))\r\nreturn;\r\n} else if (sisusb->bad_cursor_pos) {\r\nif (sisusb_setidxregand(sisusb, SISCR, 0x0b, 0x1f))\r\nreturn;\r\nsisusb->bad_cursor_pos = 0;\r\n}\r\nif (sisusb_setidxreg(sisusb, SISCR, 0x0e, (location >> 8)))\r\nreturn;\r\nsisusb_setidxreg(sisusb, SISCR, 0x0f, (location & 0xff));\r\n}\r\nstatic inline struct sisusb_usb_data *\r\nsisusb_get_sisusb(unsigned short console)\r\n{\r\nreturn mysisusbs[console];\r\n}\r\nstatic inline int\r\nsisusb_sisusb_valid(struct sisusb_usb_data *sisusb)\r\n{\r\nif (!sisusb->present || !sisusb->ready || !sisusb->sisusb_dev)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic struct sisusb_usb_data *\r\nsisusb_get_sisusb_lock_and_check(unsigned short console)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nif (in_atomic())\r\nreturn NULL;\r\nsisusb = sisusb_get_sisusb(console);\r\nif (!sisusb)\r\nreturn NULL;\r\nmutex_lock(&sisusb->lock);\r\nif (!sisusb_sisusb_valid(sisusb) ||\r\n!sisusb->havethisconsole[console]) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn NULL;\r\n}\r\nreturn sisusb;\r\n}\r\nstatic int\r\nsisusb_is_inactive(struct vc_data *c, struct sisusb_usb_data *sisusb)\r\n{\r\nif (sisusb->is_gfx ||\r\nsisusb->textmodedestroyed ||\r\nc->vc_mode != KD_TEXT)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic const char *\r\nsisusbcon_startup(void)\r\n{\r\nreturn "SISUSBCON";\r\n}\r\nstatic void\r\nsisusbcon_init(struct vc_data *c, int init)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nint cols, rows;\r\nsisusb = sisusb_get_sisusb(c->vc_num);\r\nif (!sisusb)\r\nreturn;\r\nmutex_lock(&sisusb->lock);\r\nif (!sisusb_sisusb_valid(sisusb)) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn;\r\n}\r\nc->vc_can_do_color = 1;\r\nc->vc_complement_mask = 0x7700;\r\nc->vc_hi_font_mask = sisusb->current_font_512 ? 0x0800 : 0;\r\nsisusb->haveconsole = 1;\r\nsisusb->havethisconsole[c->vc_num] = 1;\r\nc->vc_scan_lines = 400;\r\nc->vc_font.height = sisusb->current_font_height;\r\ncols = 80;\r\nrows = c->vc_scan_lines / c->vc_font.height;\r\nkref_get(&sisusb->kref);\r\nif (!*c->vc_uni_pagedir_loc)\r\ncon_set_default_unimap(c);\r\nmutex_unlock(&sisusb->lock);\r\nif (init) {\r\nc->vc_cols = cols;\r\nc->vc_rows = rows;\r\n} else\r\nvc_resize(c, cols, rows);\r\n}\r\nstatic void\r\nsisusbcon_deinit(struct vc_data *c)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nint i;\r\nsisusb = sisusb_get_sisusb(c->vc_num);\r\nif (!sisusb)\r\nreturn;\r\nmutex_lock(&sisusb->lock);\r\nmysisusbs[c->vc_num] = NULL;\r\nsisusb->havethisconsole[c->vc_num] = 0;\r\nif (sisusb->font_backup) {\r\nfor(i = 0; i < MAX_NR_CONSOLES; i++) {\r\nif (sisusb->havethisconsole[c->vc_num])\r\nbreak;\r\n}\r\nif (i == MAX_NR_CONSOLES) {\r\nvfree(sisusb->font_backup);\r\nsisusb->font_backup = NULL;\r\n}\r\n}\r\nmutex_unlock(&sisusb->lock);\r\nkref_put(&sisusb->kref, sisusb_delete);\r\n}\r\nstatic u8\r\nsisusbcon_build_attr(struct vc_data *c, u8 color, u8 intensity,\r\nu8 blink, u8 underline, u8 reverse, u8 unused)\r\n{\r\nu8 attr = color;\r\nif (underline)\r\nattr = (attr & 0xf0) | c->vc_ulcolor;\r\nelse if (intensity == 0)\r\nattr = (attr & 0xf0) | c->vc_halfcolor;\r\nif (reverse)\r\nattr = ((attr) & 0x88) |\r\n((((attr) >> 4) |\r\n((attr) << 4)) & 0x77);\r\nif (blink)\r\nattr ^= 0x80;\r\nif (intensity == 2)\r\nattr ^= 0x08;\r\nreturn attr;\r\n}\r\nstatic void\r\nsisusbcon_invert_region(struct vc_data *vc, u16 *p, int count)\r\n{\r\nwhile (count--) {\r\nu16 a = sisusbcon_readw(p);\r\na = ((a) & 0x88ff) |\r\n(((a) & 0x7000) >> 4) |\r\n(((a) & 0x0700) << 4);\r\nsisusbcon_writew(a, p++);\r\n}\r\n}\r\nstatic void\r\nsisusbcon_putc(struct vc_data *c, int ch, int y, int x)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nsisusb = sisusb_get_sisusb_lock_and_check(c->vc_num);\r\nif (!sisusb)\r\nreturn;\r\nif (sisusb_is_inactive(c, sisusb)) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn;\r\n}\r\nsisusb_copy_memory(sisusb, (char *)SISUSB_VADDR(x, y),\r\n(long)SISUSB_HADDR(x, y), 2);\r\nmutex_unlock(&sisusb->lock);\r\n}\r\nstatic void\r\nsisusbcon_putcs(struct vc_data *c, const unsigned short *s,\r\nint count, int y, int x)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nu16 *dest;\r\nint i;\r\nsisusb = sisusb_get_sisusb_lock_and_check(c->vc_num);\r\nif (!sisusb)\r\nreturn;\r\ndest = SISUSB_VADDR(x, y);\r\nfor (i = count; i > 0; i--)\r\nsisusbcon_writew(sisusbcon_readw(s++), dest++);\r\nif (sisusb_is_inactive(c, sisusb)) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn;\r\n}\r\nsisusb_copy_memory(sisusb, (char *)SISUSB_VADDR(x, y),\r\n(long)SISUSB_HADDR(x, y), count * 2);\r\nmutex_unlock(&sisusb->lock);\r\n}\r\nstatic void\r\nsisusbcon_clear(struct vc_data *c, int y, int x, int height, int width)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nu16 eattr = c->vc_video_erase_char;\r\nint i, length, cols;\r\nu16 *dest;\r\nif (width <= 0 || height <= 0)\r\nreturn;\r\nsisusb = sisusb_get_sisusb_lock_and_check(c->vc_num);\r\nif (!sisusb)\r\nreturn;\r\ndest = SISUSB_VADDR(x, y);\r\ncols = sisusb->sisusb_num_columns;\r\nif (width > cols)\r\nwidth = cols;\r\nif (x == 0 && width >= c->vc_cols) {\r\nsisusbcon_memsetw(dest, eattr, height * cols * 2);\r\n} else {\r\nfor (i = height; i > 0; i--, dest += cols)\r\nsisusbcon_memsetw(dest, eattr, width * 2);\r\n}\r\nif (sisusb_is_inactive(c, sisusb)) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn;\r\n}\r\nlength = ((height * cols) - x - (cols - width - x)) * 2;\r\nsisusb_copy_memory(sisusb, (unsigned char *)SISUSB_VADDR(x, y),\r\n(long)SISUSB_HADDR(x, y), length);\r\nmutex_unlock(&sisusb->lock);\r\n}\r\nstatic int\r\nsisusbcon_switch(struct vc_data *c)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nint length;\r\nsisusb = sisusb_get_sisusb_lock_and_check(c->vc_num);\r\nif (!sisusb)\r\nreturn 0;\r\nif (sisusb_is_inactive(c, sisusb)) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn 0;\r\n}\r\nif (c->vc_origin == (unsigned long)c->vc_screenbuf) {\r\nmutex_unlock(&sisusb->lock);\r\ndev_dbg(&sisusb->sisusb_dev->dev, "ASSERT ORIGIN != SCREENBUF!\n");\r\nreturn 0;\r\n}\r\nlength = min((int)c->vc_screenbuf_size,\r\n(int)(sisusb->scrbuf + sisusb->scrbuf_size - c->vc_origin));\r\nsisusbcon_memcpyw((u16 *)c->vc_origin, (u16 *)c->vc_screenbuf,\r\nlength);\r\nsisusb_copy_memory(sisusb, (unsigned char *)c->vc_origin,\r\n(long)SISUSB_HADDR(0, 0),\r\nlength);\r\nmutex_unlock(&sisusb->lock);\r\nreturn 0;\r\n}\r\nstatic void\r\nsisusbcon_save_screen(struct vc_data *c)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nint length;\r\nsisusb = sisusb_get_sisusb_lock_and_check(c->vc_num);\r\nif (!sisusb)\r\nreturn;\r\nif (sisusb_is_inactive(c, sisusb)) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn;\r\n}\r\nlength = min((int)c->vc_screenbuf_size,\r\n(int)(sisusb->scrbuf + sisusb->scrbuf_size - c->vc_origin));\r\nsisusbcon_memcpyw((u16 *)c->vc_screenbuf, (u16 *)c->vc_origin,\r\nlength);\r\nmutex_unlock(&sisusb->lock);\r\n}\r\nstatic void\r\nsisusbcon_set_palette(struct vc_data *c, const unsigned char *table)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nint i, j;\r\nif (!con_is_visible(c))\r\nreturn;\r\nsisusb = sisusb_get_sisusb_lock_and_check(c->vc_num);\r\nif (!sisusb)\r\nreturn;\r\nif (sisusb_is_inactive(c, sisusb)) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn;\r\n}\r\nfor (i = j = 0; i < 16; i++) {\r\nif (sisusb_setreg(sisusb, SISCOLIDX, table[i]))\r\nbreak;\r\nif (sisusb_setreg(sisusb, SISCOLDATA, c->vc_palette[j++] >> 2))\r\nbreak;\r\nif (sisusb_setreg(sisusb, SISCOLDATA, c->vc_palette[j++] >> 2))\r\nbreak;\r\nif (sisusb_setreg(sisusb, SISCOLDATA, c->vc_palette[j++] >> 2))\r\nbreak;\r\n}\r\nmutex_unlock(&sisusb->lock);\r\n}\r\nstatic int\r\nsisusbcon_blank(struct vc_data *c, int blank, int mode_switch)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nu8 sr1, cr17, pmreg, cr63;\r\nint ret = 0;\r\nsisusb = sisusb_get_sisusb_lock_and_check(c->vc_num);\r\nif (!sisusb)\r\nreturn 0;\r\nif (mode_switch)\r\nsisusb->is_gfx = blank ? 1 : 0;\r\nif (sisusb_is_inactive(c, sisusb)) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn 0;\r\n}\r\nswitch (blank) {\r\ncase 1:\r\ncase -1:\r\nsisusbcon_memsetw((u16 *)c->vc_origin,\r\nc->vc_video_erase_char,\r\nc->vc_screenbuf_size);\r\nsisusb_copy_memory(sisusb,\r\n(unsigned char *)c->vc_origin,\r\n(u32)(sisusb->vrambase +\r\n(c->vc_origin - sisusb->scrbuf)),\r\nc->vc_screenbuf_size);\r\nsisusb->con_blanked = 1;\r\nret = 1;\r\nbreak;\r\ndefault:\r\nswitch (blank) {\r\ncase 0:\r\nsr1 = 0x00;\r\ncr17 = 0x80;\r\npmreg = 0x00;\r\ncr63 = 0x00;\r\nret = 1;\r\nsisusb->con_blanked = 0;\r\nbreak;\r\ncase VESA_VSYNC_SUSPEND + 1:\r\nsr1 = 0x20;\r\ncr17 = 0x80;\r\npmreg = 0x80;\r\ncr63 = 0x40;\r\nbreak;\r\ncase VESA_HSYNC_SUSPEND + 1:\r\nsr1 = 0x20;\r\ncr17 = 0x80;\r\npmreg = 0x40;\r\ncr63 = 0x40;\r\nbreak;\r\ncase VESA_POWERDOWN + 1:\r\nsr1 = 0x20;\r\ncr17 = 0x00;\r\npmreg = 0xc0;\r\ncr63 = 0x40;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&sisusb->lock);\r\nreturn -EINVAL;\r\n}\r\nsisusb_setidxregandor(sisusb, SISSR, 0x01, ~0x20, sr1);\r\nsisusb_setidxregandor(sisusb, SISCR, 0x17, 0x7f, cr17);\r\nsisusb_setidxregandor(sisusb, SISSR, 0x1f, 0x3f, pmreg);\r\nsisusb_setidxregandor(sisusb, SISCR, 0x63, 0xbf, cr63);\r\n}\r\nmutex_unlock(&sisusb->lock);\r\nreturn ret;\r\n}\r\nstatic void\r\nsisusbcon_scrolldelta(struct vc_data *c, int lines)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nsisusb = sisusb_get_sisusb_lock_and_check(c->vc_num);\r\nif (!sisusb)\r\nreturn;\r\nif (sisusb_is_inactive(c, sisusb)) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn;\r\n}\r\nvc_scrolldelta_helper(c, lines, sisusb->con_rolled_over,\r\n(void *)sisusb->scrbuf, sisusb->scrbuf_size);\r\nsisusbcon_set_start_address(sisusb, c);\r\nmutex_unlock(&sisusb->lock);\r\n}\r\nstatic void\r\nsisusbcon_cursor(struct vc_data *c, int mode)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nint from, to, baseline;\r\nsisusb = sisusb_get_sisusb_lock_and_check(c->vc_num);\r\nif (!sisusb)\r\nreturn;\r\nif (sisusb_is_inactive(c, sisusb)) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn;\r\n}\r\nif (c->vc_origin != c->vc_visible_origin) {\r\nc->vc_visible_origin = c->vc_origin;\r\nsisusbcon_set_start_address(sisusb, c);\r\n}\r\nif (mode == CM_ERASE) {\r\nsisusb_setidxregor(sisusb, SISCR, 0x0a, 0x20);\r\nsisusb->sisusb_cursor_size_to = -1;\r\nmutex_unlock(&sisusb->lock);\r\nreturn;\r\n}\r\nsisusb_set_cursor(sisusb, (c->vc_pos - sisusb->scrbuf) / 2);\r\nbaseline = c->vc_font.height - (c->vc_font.height < 10 ? 1 : 2);\r\nswitch (c->vc_cursor_type & 0x0f) {\r\ncase CUR_BLOCK: from = 1;\r\nto = c->vc_font.height;\r\nbreak;\r\ncase CUR_TWO_THIRDS: from = c->vc_font.height / 3;\r\nto = baseline;\r\nbreak;\r\ncase CUR_LOWER_HALF: from = c->vc_font.height / 2;\r\nto = baseline;\r\nbreak;\r\ncase CUR_LOWER_THIRD: from = (c->vc_font.height * 2) / 3;\r\nto = baseline;\r\nbreak;\r\ncase CUR_NONE: from = 31;\r\nto = 30;\r\nbreak;\r\ndefault:\r\ncase CUR_UNDERLINE: from = baseline - 1;\r\nto = baseline;\r\nbreak;\r\n}\r\nif (sisusb->sisusb_cursor_size_from != from ||\r\nsisusb->sisusb_cursor_size_to != to) {\r\nsisusb_setidxreg(sisusb, SISCR, 0x0a, from);\r\nsisusb_setidxregandor(sisusb, SISCR, 0x0b, 0xe0, to);\r\nsisusb->sisusb_cursor_size_from = from;\r\nsisusb->sisusb_cursor_size_to = to;\r\n}\r\nmutex_unlock(&sisusb->lock);\r\n}\r\nstatic bool\r\nsisusbcon_scroll_area(struct vc_data *c, struct sisusb_usb_data *sisusb,\r\nunsigned int t, unsigned int b, enum con_scroll dir,\r\nunsigned int lines)\r\n{\r\nint cols = sisusb->sisusb_num_columns;\r\nint length = ((b - t) * cols) * 2;\r\nu16 eattr = c->vc_video_erase_char;\r\nswitch (dir) {\r\ncase SM_UP:\r\nsisusbcon_memmovew(SISUSB_VADDR(0, t),\r\nSISUSB_VADDR(0, t + lines),\r\n(b - t - lines) * cols * 2);\r\nsisusbcon_memsetw(SISUSB_VADDR(0, b - lines), eattr,\r\nlines * cols * 2);\r\nbreak;\r\ncase SM_DOWN:\r\nsisusbcon_memmovew(SISUSB_VADDR(0, t + lines),\r\nSISUSB_VADDR(0, t),\r\n(b - t - lines) * cols * 2);\r\nsisusbcon_memsetw(SISUSB_VADDR(0, t), eattr,\r\nlines * cols * 2);\r\nbreak;\r\n}\r\nsisusb_copy_memory(sisusb, (char *)SISUSB_VADDR(0, t),\r\n(long)SISUSB_HADDR(0, t), length);\r\nmutex_unlock(&sisusb->lock);\r\nreturn true;\r\n}\r\nstatic bool\r\nsisusbcon_scroll(struct vc_data *c, unsigned int t, unsigned int b,\r\nenum con_scroll dir, unsigned int lines)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nu16 eattr = c->vc_video_erase_char;\r\nint copyall = 0;\r\nunsigned long oldorigin;\r\nunsigned int delta = lines * c->vc_size_row;\r\nu32 originoffset;\r\nif (!lines)\r\nreturn true;\r\nsisusb = sisusb_get_sisusb_lock_and_check(c->vc_num);\r\nif (!sisusb)\r\nreturn false;\r\nif (sisusb_is_inactive(c, sisusb)) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn false;\r\n}\r\nif (t || b != c->vc_rows)\r\nreturn sisusbcon_scroll_area(c, sisusb, t, b, dir, lines);\r\nif (c->vc_origin != c->vc_visible_origin) {\r\nc->vc_visible_origin = c->vc_origin;\r\nsisusbcon_set_start_address(sisusb, c);\r\n}\r\nif (lines > c->vc_rows)\r\nlines = c->vc_rows;\r\noldorigin = c->vc_origin;\r\nswitch (dir) {\r\ncase SM_UP:\r\nif (c->vc_scr_end + delta >=\r\nsisusb->scrbuf + sisusb->scrbuf_size) {\r\nsisusbcon_memcpyw((u16 *)sisusb->scrbuf,\r\n(u16 *)(oldorigin + delta),\r\nc->vc_screenbuf_size - delta);\r\nc->vc_origin = sisusb->scrbuf;\r\nsisusb->con_rolled_over = oldorigin - sisusb->scrbuf;\r\ncopyall = 1;\r\n} else\r\nc->vc_origin += delta;\r\nsisusbcon_memsetw(\r\n(u16 *)(c->vc_origin + c->vc_screenbuf_size - delta),\r\neattr, delta);\r\nbreak;\r\ncase SM_DOWN:\r\nif (oldorigin - delta < sisusb->scrbuf) {\r\nsisusbcon_memmovew((u16 *)(sisusb->scrbuf +\r\nsisusb->scrbuf_size -\r\nc->vc_screenbuf_size +\r\ndelta),\r\n(u16 *)oldorigin,\r\nc->vc_screenbuf_size - delta);\r\nc->vc_origin = sisusb->scrbuf +\r\nsisusb->scrbuf_size -\r\nc->vc_screenbuf_size;\r\nsisusb->con_rolled_over = 0;\r\ncopyall = 1;\r\n} else\r\nc->vc_origin -= delta;\r\nc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\r\nscr_memsetw((u16 *)(c->vc_origin), eattr, delta);\r\nbreak;\r\n}\r\noriginoffset = (u32)(c->vc_origin - sisusb->scrbuf);\r\nif (copyall)\r\nsisusb_copy_memory(sisusb,\r\n(char *)c->vc_origin,\r\n(u32)(sisusb->vrambase + originoffset),\r\nc->vc_screenbuf_size);\r\nelse if (dir == SM_UP)\r\nsisusb_copy_memory(sisusb,\r\n(char *)c->vc_origin + c->vc_screenbuf_size - delta,\r\n(u32)sisusb->vrambase + originoffset +\r\nc->vc_screenbuf_size - delta,\r\ndelta);\r\nelse\r\nsisusb_copy_memory(sisusb,\r\n(char *)c->vc_origin,\r\n(u32)(sisusb->vrambase + originoffset),\r\ndelta);\r\nc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\r\nc->vc_visible_origin = c->vc_origin;\r\nsisusbcon_set_start_address(sisusb, c);\r\nc->vc_pos = c->vc_pos - oldorigin + c->vc_origin;\r\nmutex_unlock(&sisusb->lock);\r\nreturn true;\r\n}\r\nstatic int\r\nsisusbcon_set_origin(struct vc_data *c)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nsisusb = sisusb_get_sisusb_lock_and_check(c->vc_num);\r\nif (!sisusb)\r\nreturn 0;\r\nif (sisusb_is_inactive(c, sisusb) || sisusb->con_blanked) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn 0;\r\n}\r\nc->vc_origin = c->vc_visible_origin = sisusb->scrbuf;\r\nsisusbcon_set_start_address(sisusb, c);\r\nsisusb->con_rolled_over = 0;\r\nmutex_unlock(&sisusb->lock);\r\nreturn true;\r\n}\r\nstatic int\r\nsisusbcon_resize(struct vc_data *c, unsigned int newcols, unsigned int newrows,\r\nunsigned int user)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nint fh;\r\nsisusb = sisusb_get_sisusb_lock_and_check(c->vc_num);\r\nif (!sisusb)\r\nreturn -ENODEV;\r\nfh = sisusb->current_font_height;\r\nmutex_unlock(&sisusb->lock);\r\nif (newcols != 80 || c->vc_scan_lines / fh != newrows)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint\r\nsisusbcon_do_font_op(struct sisusb_usb_data *sisusb, int set, int slot,\r\nu8 *arg, int cmapsz, int ch512, int dorecalc,\r\nstruct vc_data *c, int fh, int uplock)\r\n{\r\nint font_select = 0x00, i, err = 0;\r\nu32 offset = 0;\r\nu8 dummy;\r\nif ((slot != 0 && slot != 2) || !fh) {\r\nif (uplock)\r\nmutex_unlock(&sisusb->lock);\r\nreturn -EINVAL;\r\n}\r\nif (set)\r\nsisusb->font_slot = slot;\r\nif (slot == 0)\r\nch512 = 0;\r\nelse\r\noffset = 4 * cmapsz;\r\nfont_select = (slot == 0) ? 0x00 : (ch512 ? 0x0e : 0x0a);\r\nerr |= sisusb_setidxreg(sisusb, SISSR, 0x00, 0x01);\r\nerr |= sisusb_setidxreg(sisusb, SISSR, 0x02, 0x04);\r\nerr |= sisusb_setidxreg(sisusb, SISSR, 0x04, 0x07);\r\nerr |= sisusb_setidxreg(sisusb, SISSR, 0x00, 0x03);\r\nif (err)\r\ngoto font_op_error;\r\nerr |= sisusb_setidxreg(sisusb, SISGR, 0x04, 0x03);\r\nerr |= sisusb_setidxreg(sisusb, SISGR, 0x05, 0x00);\r\nerr |= sisusb_setidxreg(sisusb, SISGR, 0x06, 0x00);\r\nif (err)\r\ngoto font_op_error;\r\nif (arg) {\r\nif (set)\r\nfor (i = 0; i < cmapsz; i++) {\r\nerr |= sisusb_writeb(sisusb,\r\nsisusb->vrambase + offset + i,\r\narg[i]);\r\nif (err)\r\nbreak;\r\n}\r\nelse\r\nfor (i = 0; i < cmapsz; i++) {\r\nerr |= sisusb_readb(sisusb,\r\nsisusb->vrambase + offset + i,\r\n&arg[i]);\r\nif (err)\r\nbreak;\r\n}\r\nif (ch512) {\r\nif (set)\r\nfor (i = 0; i < cmapsz; i++) {\r\nerr |= sisusb_writeb(sisusb,\r\nsisusb->vrambase + offset +\r\n(2 * cmapsz) + i,\r\narg[cmapsz + i]);\r\nif (err)\r\nbreak;\r\n}\r\nelse\r\nfor (i = 0; i < cmapsz; i++) {\r\nerr |= sisusb_readb(sisusb,\r\nsisusb->vrambase + offset +\r\n(2 * cmapsz) + i,\r\n&arg[cmapsz + i]);\r\nif (err)\r\nbreak;\r\n}\r\n}\r\n}\r\nif (err)\r\ngoto font_op_error;\r\nerr |= sisusb_setidxreg(sisusb, SISSR, 0x00, 0x01);\r\nerr |= sisusb_setidxreg(sisusb, SISSR, 0x02, 0x03);\r\nerr |= sisusb_setidxreg(sisusb, SISSR, 0x04, 0x03);\r\nif (set)\r\nsisusb_setidxreg(sisusb, SISSR, 0x03, font_select);\r\nerr |= sisusb_setidxreg(sisusb, SISSR, 0x00, 0x03);\r\nif (err)\r\ngoto font_op_error;\r\nerr |= sisusb_setidxreg(sisusb, SISGR, 0x04, 0x00);\r\nerr |= sisusb_setidxreg(sisusb, SISGR, 0x05, 0x10);\r\nerr |= sisusb_setidxreg(sisusb, SISGR, 0x06, 0x06);\r\nif (err)\r\ngoto font_op_error;\r\nif ((set) && (ch512 != sisusb->current_font_512)) {\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++) {\r\nstruct vc_data *d = vc_cons[i].d;\r\nif (d && d->vc_sw == &sisusb_con)\r\nd->vc_hi_font_mask = ch512 ? 0x0800 : 0;\r\n}\r\nsisusb->current_font_512 = ch512;\r\nsisusb_getreg(sisusb, SISINPSTAT, &dummy);\r\nsisusb_setreg(sisusb, SISAR, 0x12);\r\nsisusb_setreg(sisusb, SISAR, ch512 ? 0x07 : 0x0f);\r\nsisusb_getreg(sisusb, SISINPSTAT, &dummy);\r\nsisusb_setreg(sisusb, SISAR, 0x20);\r\nsisusb_getreg(sisusb, SISINPSTAT, &dummy);\r\n}\r\nif (dorecalc) {\r\nunsigned char ovr, vde, fsr;\r\nint rows = 0, maxscan = 0;\r\nif (c) {\r\nrows = c->vc_scan_lines / fh;\r\nmaxscan = rows * fh - 1;\r\nsisusb_getidxreg(sisusb, SISCR, 0x07, &ovr);\r\nvde = maxscan & 0xff;\r\novr = (ovr & 0xbd) |\r\n((maxscan & 0x100) >> 7) |\r\n((maxscan & 0x200) >> 3);\r\nsisusb_setidxreg(sisusb, SISCR, 0x07, ovr);\r\nsisusb_setidxreg(sisusb, SISCR, 0x12, vde);\r\n}\r\nsisusb_getidxreg(sisusb, SISCR, 0x09, &fsr);\r\nfsr = (fsr & 0xe0) | (fh - 1);\r\nsisusb_setidxreg(sisusb, SISCR, 0x09, fsr);\r\nsisusb->current_font_height = fh;\r\nsisusb->sisusb_cursor_size_from = -1;\r\nsisusb->sisusb_cursor_size_to = -1;\r\n}\r\nif (uplock)\r\nmutex_unlock(&sisusb->lock);\r\nif (dorecalc && c) {\r\nint rows = c->vc_scan_lines / fh;\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++) {\r\nstruct vc_data *vc = vc_cons[i].d;\r\nif (vc && vc->vc_sw == &sisusb_con) {\r\nif (con_is_visible(vc)) {\r\nvc->vc_sw->con_cursor(vc, CM_DRAW);\r\n}\r\nvc->vc_font.height = fh;\r\nvc_resize(vc, 0, rows);\r\n}\r\n}\r\n}\r\nreturn 0;\r\nfont_op_error:\r\nif (uplock)\r\nmutex_unlock(&sisusb->lock);\r\nreturn -EIO;\r\n}\r\nstatic int\r\nsisusbcon_font_set(struct vc_data *c, struct console_font *font,\r\nunsigned flags)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nunsigned charcount = font->charcount;\r\nif (font->width != 8 || (charcount != 256 && charcount != 512))\r\nreturn -EINVAL;\r\nsisusb = sisusb_get_sisusb_lock_and_check(c->vc_num);\r\nif (!sisusb)\r\nreturn -ENODEV;\r\nif (sisusb->font_backup) {\r\nif (sisusb->font_backup_size < charcount) {\r\nvfree(sisusb->font_backup);\r\nsisusb->font_backup = NULL;\r\n}\r\n}\r\nif (!sisusb->font_backup)\r\nsisusb->font_backup = vmalloc(charcount * 32);\r\nif (sisusb->font_backup) {\r\nmemcpy(sisusb->font_backup, font->data, charcount * 32);\r\nsisusb->font_backup_size = charcount;\r\nsisusb->font_backup_height = font->height;\r\nsisusb->font_backup_512 = (charcount == 512) ? 1 : 0;\r\n}\r\nreturn sisusbcon_do_font_op(sisusb, 1, 2, font->data,\r\n8192, (charcount == 512),\r\n(!(flags & KD_FONT_FLAG_DONT_RECALC)) ? 1 : 0,\r\nc, font->height, 1);\r\n}\r\nstatic int\r\nsisusbcon_font_get(struct vc_data *c, struct console_font *font)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nsisusb = sisusb_get_sisusb_lock_and_check(c->vc_num);\r\nif (!sisusb)\r\nreturn -ENODEV;\r\nfont->width = 8;\r\nfont->height = c->vc_font.height;\r\nfont->charcount = 256;\r\nif (!font->data) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn 0;\r\n}\r\nif (!sisusb->font_backup) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn -ENODEV;\r\n}\r\nmemcpy(font->data, sisusb->font_backup, 256 * 32);\r\nmutex_unlock(&sisusb->lock);\r\nreturn 0;\r\n}\r\nstatic const char *sisusbdummycon_startup(void)\r\n{\r\nreturn "SISUSBVGADUMMY";\r\n}\r\nstatic void sisusbdummycon_init(struct vc_data *vc, int init)\r\n{\r\nvc->vc_can_do_color = 1;\r\nif (init) {\r\nvc->vc_cols = 80;\r\nvc->vc_rows = 25;\r\n} else\r\nvc_resize(vc, 80, 25);\r\n}\r\nstatic int sisusbdummycon_dummy(void)\r\n{\r\nreturn 0;\r\n}\r\nint\r\nsisusb_console_init(struct sisusb_usb_data *sisusb, int first, int last)\r\n{\r\nint i, ret;\r\nmutex_lock(&sisusb->lock);\r\nif (sisusb->haveconsole || !sisusb->SiS_Pr) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn 1;\r\n}\r\nsisusb->con_first = first;\r\nsisusb->con_last = last;\r\nif (first > last ||\r\nfirst > MAX_NR_CONSOLES ||\r\nlast > MAX_NR_CONSOLES) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn 1;\r\n}\r\nif (!sisusb->gfxinit || first < 1 || last < 1) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn 0;\r\n}\r\nsisusb->sisusb_cursor_loc = -1;\r\nsisusb->sisusb_cursor_size_from = -1;\r\nsisusb->sisusb_cursor_size_to = -1;\r\nif (sisusb_reset_text_mode(sisusb, 1)) {\r\nmutex_unlock(&sisusb->lock);\r\ndev_err(&sisusb->sisusb_dev->dev, "Failed to set up text mode\n");\r\nreturn 1;\r\n}\r\nsisusb_initialize(sisusb);\r\nfor (i = first - 1; i <= last - 1; i++) {\r\nmysisusbs[i] = sisusb;\r\n}\r\nsisusb->sisusb_num_columns = 80;\r\nsisusb->scrbuf_size = 32 * 1024;\r\nif (!(sisusb->scrbuf = (unsigned long)vmalloc(sisusb->scrbuf_size))) {\r\nmutex_unlock(&sisusb->lock);\r\ndev_err(&sisusb->sisusb_dev->dev, "Failed to allocate screen buffer\n");\r\nreturn 1;\r\n}\r\nmutex_unlock(&sisusb->lock);\r\nconsole_lock();\r\nret = do_take_over_console(&sisusb_con, first - 1, last - 1, 0);\r\nconsole_unlock();\r\nif (!ret)\r\nsisusb->haveconsole = 1;\r\nelse {\r\nfor (i = first - 1; i <= last - 1; i++)\r\nmysisusbs[i] = NULL;\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nsisusb_console_exit(struct sisusb_usb_data *sisusb)\r\n{\r\nint i;\r\nif (sisusb->haveconsole) {\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++)\r\nif (sisusb->havethisconsole[i]) {\r\nconsole_lock();\r\ndo_take_over_console(&sisusb_dummy_con, i, i, 0);\r\nconsole_unlock();\r\n}\r\nsisusb->haveconsole = 0;\r\n}\r\nvfree((void *)sisusb->scrbuf);\r\nsisusb->scrbuf = 0;\r\nvfree(sisusb->font_backup);\r\nsisusb->font_backup = NULL;\r\n}\r\nvoid __init sisusb_init_concode(void)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++)\r\nmysisusbs[i] = NULL;\r\n}
