static int pm8xxx_vib_set(struct pm8xxx_vib *vib, bool on)\r\n{\r\nint rc;\r\nunsigned int val = vib->reg_vib_drv;\r\nconst struct pm8xxx_regs *regs = vib->regs;\r\nif (on)\r\nval |= (vib->level << regs->drv_shift) & regs->drv_mask;\r\nelse\r\nval &= ~regs->drv_mask;\r\nrc = regmap_write(vib->regmap, regs->drv_addr, val);\r\nif (rc < 0)\r\nreturn rc;\r\nvib->reg_vib_drv = val;\r\nif (regs->enable_mask)\r\nrc = regmap_update_bits(vib->regmap, regs->enable_addr,\r\non ? regs->enable_mask : 0, val);\r\nreturn rc;\r\n}\r\nstatic void pm8xxx_work_handler(struct work_struct *work)\r\n{\r\nstruct pm8xxx_vib *vib = container_of(work, struct pm8xxx_vib, work);\r\nconst struct pm8xxx_regs *regs = vib->regs;\r\nint rc;\r\nunsigned int val;\r\nrc = regmap_read(vib->regmap, regs->drv_addr, &val);\r\nif (rc < 0)\r\nreturn;\r\nif (vib->speed) {\r\nvib->active = true;\r\nvib->level = ((VIB_MAX_LEVELS * vib->speed) / MAX_FF_SPEED) +\r\nVIB_MIN_LEVEL_mV;\r\nvib->level /= 100;\r\n} else {\r\nvib->active = false;\r\nvib->level = VIB_MIN_LEVEL_mV / 100;\r\n}\r\npm8xxx_vib_set(vib, vib->active);\r\n}\r\nstatic void pm8xxx_vib_close(struct input_dev *dev)\r\n{\r\nstruct pm8xxx_vib *vib = input_get_drvdata(dev);\r\ncancel_work_sync(&vib->work);\r\nif (vib->active)\r\npm8xxx_vib_set(vib, false);\r\n}\r\nstatic int pm8xxx_vib_play_effect(struct input_dev *dev, void *data,\r\nstruct ff_effect *effect)\r\n{\r\nstruct pm8xxx_vib *vib = input_get_drvdata(dev);\r\nvib->speed = effect->u.rumble.strong_magnitude >> 8;\r\nif (!vib->speed)\r\nvib->speed = effect->u.rumble.weak_magnitude >> 9;\r\nschedule_work(&vib->work);\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_vib_probe(struct platform_device *pdev)\r\n{\r\nstruct pm8xxx_vib *vib;\r\nstruct input_dev *input_dev;\r\nint error;\r\nunsigned int val;\r\nconst struct pm8xxx_regs *regs;\r\nvib = devm_kzalloc(&pdev->dev, sizeof(*vib), GFP_KERNEL);\r\nif (!vib)\r\nreturn -ENOMEM;\r\nvib->regmap = dev_get_regmap(pdev->dev.parent, NULL);\r\nif (!vib->regmap)\r\nreturn -ENODEV;\r\ninput_dev = devm_input_allocate_device(&pdev->dev);\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\nINIT_WORK(&vib->work, pm8xxx_work_handler);\r\nvib->vib_input_dev = input_dev;\r\nregs = of_device_get_match_data(&pdev->dev);\r\nerror = regmap_read(vib->regmap, regs->drv_addr, &val);\r\nif (error < 0)\r\nreturn error;\r\nval &= regs->drv_en_manual_mask;\r\nerror = regmap_write(vib->regmap, regs->drv_addr, val);\r\nif (error < 0)\r\nreturn error;\r\nvib->regs = regs;\r\nvib->reg_vib_drv = val;\r\ninput_dev->name = "pm8xxx_vib_ffmemless";\r\ninput_dev->id.version = 1;\r\ninput_dev->close = pm8xxx_vib_close;\r\ninput_set_drvdata(input_dev, vib);\r\ninput_set_capability(vib->vib_input_dev, EV_FF, FF_RUMBLE);\r\nerror = input_ff_create_memless(input_dev, NULL,\r\npm8xxx_vib_play_effect);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"couldn't register vibrator as FF device\n");\r\nreturn error;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "couldn't register input device\n");\r\nreturn error;\r\n}\r\nplatform_set_drvdata(pdev, vib);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused pm8xxx_vib_suspend(struct device *dev)\r\n{\r\nstruct pm8xxx_vib *vib = dev_get_drvdata(dev);\r\npm8xxx_vib_set(vib, false);\r\nreturn 0;\r\n}
