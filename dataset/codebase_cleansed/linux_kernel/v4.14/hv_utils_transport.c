static void hvt_reset(struct hvutil_transport *hvt)\r\n{\r\nkfree(hvt->outmsg);\r\nhvt->outmsg = NULL;\r\nhvt->outmsg_len = 0;\r\nif (hvt->on_reset)\r\nhvt->on_reset();\r\n}\r\nstatic ssize_t hvt_op_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hvutil_transport *hvt;\r\nint ret;\r\nhvt = container_of(file->f_op, struct hvutil_transport, fops);\r\nif (wait_event_interruptible(hvt->outmsg_q, hvt->outmsg_len > 0 ||\r\nhvt->mode != HVUTIL_TRANSPORT_CHARDEV))\r\nreturn -EINTR;\r\nmutex_lock(&hvt->lock);\r\nif (hvt->mode == HVUTIL_TRANSPORT_DESTROY) {\r\nret = -EBADF;\r\ngoto out_unlock;\r\n}\r\nif (!hvt->outmsg) {\r\nret = -EAGAIN;\r\ngoto out_unlock;\r\n}\r\nif (count < hvt->outmsg_len) {\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nif (!copy_to_user(buf, hvt->outmsg, hvt->outmsg_len))\r\nret = hvt->outmsg_len;\r\nelse\r\nret = -EFAULT;\r\nkfree(hvt->outmsg);\r\nhvt->outmsg = NULL;\r\nhvt->outmsg_len = 0;\r\nif (hvt->on_read)\r\nhvt->on_read();\r\nhvt->on_read = NULL;\r\nout_unlock:\r\nmutex_unlock(&hvt->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t hvt_op_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hvutil_transport *hvt;\r\nu8 *inmsg;\r\nint ret;\r\nhvt = container_of(file->f_op, struct hvutil_transport, fops);\r\ninmsg = memdup_user(buf, count);\r\nif (IS_ERR(inmsg))\r\nreturn PTR_ERR(inmsg);\r\nif (hvt->mode == HVUTIL_TRANSPORT_DESTROY)\r\nret = -EBADF;\r\nelse\r\nret = hvt->on_msg(inmsg, count);\r\nkfree(inmsg);\r\nreturn ret ? ret : count;\r\n}\r\nstatic unsigned int hvt_op_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct hvutil_transport *hvt;\r\nhvt = container_of(file->f_op, struct hvutil_transport, fops);\r\npoll_wait(file, &hvt->outmsg_q, wait);\r\nif (hvt->mode == HVUTIL_TRANSPORT_DESTROY)\r\nreturn POLLERR | POLLHUP;\r\nif (hvt->outmsg_len > 0)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int hvt_op_open(struct inode *inode, struct file *file)\r\n{\r\nstruct hvutil_transport *hvt;\r\nint ret = 0;\r\nbool issue_reset = false;\r\nhvt = container_of(file->f_op, struct hvutil_transport, fops);\r\nmutex_lock(&hvt->lock);\r\nif (hvt->mode == HVUTIL_TRANSPORT_DESTROY) {\r\nret = -EBADF;\r\n} else if (hvt->mode == HVUTIL_TRANSPORT_INIT) {\r\nhvt->mode = HVUTIL_TRANSPORT_CHARDEV;\r\n}\r\nelse if (hvt->mode == HVUTIL_TRANSPORT_NETLINK) {\r\nissue_reset = true;\r\nhvt->mode = HVUTIL_TRANSPORT_CHARDEV;\r\n} else {\r\nret = -EBUSY;\r\n}\r\nif (issue_reset)\r\nhvt_reset(hvt);\r\nmutex_unlock(&hvt->lock);\r\nreturn ret;\r\n}\r\nstatic void hvt_transport_free(struct hvutil_transport *hvt)\r\n{\r\nmisc_deregister(&hvt->mdev);\r\nkfree(hvt->outmsg);\r\nkfree(hvt);\r\n}\r\nstatic int hvt_op_release(struct inode *inode, struct file *file)\r\n{\r\nstruct hvutil_transport *hvt;\r\nint mode_old;\r\nhvt = container_of(file->f_op, struct hvutil_transport, fops);\r\nmutex_lock(&hvt->lock);\r\nmode_old = hvt->mode;\r\nif (hvt->mode != HVUTIL_TRANSPORT_DESTROY)\r\nhvt->mode = HVUTIL_TRANSPORT_INIT;\r\nhvt_reset(hvt);\r\nif (mode_old == HVUTIL_TRANSPORT_DESTROY)\r\ncomplete(&hvt->release);\r\nmutex_unlock(&hvt->lock);\r\nreturn 0;\r\n}\r\nstatic void hvt_cn_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)\r\n{\r\nstruct hvutil_transport *hvt, *hvt_found = NULL;\r\nspin_lock(&hvt_list_lock);\r\nlist_for_each_entry(hvt, &hvt_list, list) {\r\nif (hvt->cn_id.idx == msg->id.idx &&\r\nhvt->cn_id.val == msg->id.val) {\r\nhvt_found = hvt;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&hvt_list_lock);\r\nif (!hvt_found) {\r\npr_warn("hvt_cn_callback: spurious message received!\n");\r\nreturn;\r\n}\r\nmutex_lock(&hvt->lock);\r\nif (hvt->mode == HVUTIL_TRANSPORT_INIT)\r\nhvt->mode = HVUTIL_TRANSPORT_NETLINK;\r\nif (hvt->mode == HVUTIL_TRANSPORT_NETLINK)\r\nhvt_found->on_msg(msg->data, msg->len);\r\nelse\r\npr_warn("hvt_cn_callback: unexpected netlink message!\n");\r\nmutex_unlock(&hvt->lock);\r\n}\r\nint hvutil_transport_send(struct hvutil_transport *hvt, void *msg, int len,\r\nvoid (*on_read_cb)(void))\r\n{\r\nstruct cn_msg *cn_msg;\r\nint ret = 0;\r\nif (hvt->mode == HVUTIL_TRANSPORT_INIT ||\r\nhvt->mode == HVUTIL_TRANSPORT_DESTROY) {\r\nreturn -EINVAL;\r\n} else if (hvt->mode == HVUTIL_TRANSPORT_NETLINK) {\r\ncn_msg = kzalloc(sizeof(*cn_msg) + len, GFP_ATOMIC);\r\nif (!cn_msg)\r\nreturn -ENOMEM;\r\ncn_msg->id.idx = hvt->cn_id.idx;\r\ncn_msg->id.val = hvt->cn_id.val;\r\ncn_msg->len = len;\r\nmemcpy(cn_msg->data, msg, len);\r\nret = cn_netlink_send(cn_msg, 0, 0, GFP_ATOMIC);\r\nkfree(cn_msg);\r\nif (on_read_cb)\r\non_read_cb();\r\nreturn ret;\r\n}\r\nmutex_lock(&hvt->lock);\r\nif (hvt->mode != HVUTIL_TRANSPORT_CHARDEV) {\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nif (hvt->outmsg) {\r\nret = -EFAULT;\r\ngoto out_unlock;\r\n}\r\nhvt->outmsg = kzalloc(len, GFP_KERNEL);\r\nif (hvt->outmsg) {\r\nmemcpy(hvt->outmsg, msg, len);\r\nhvt->outmsg_len = len;\r\nhvt->on_read = on_read_cb;\r\nwake_up_interruptible(&hvt->outmsg_q);\r\n} else\r\nret = -ENOMEM;\r\nout_unlock:\r\nmutex_unlock(&hvt->lock);\r\nreturn ret;\r\n}\r\nstruct hvutil_transport *hvutil_transport_init(const char *name,\r\nu32 cn_idx, u32 cn_val,\r\nint (*on_msg)(void *, int),\r\nvoid (*on_reset)(void))\r\n{\r\nstruct hvutil_transport *hvt;\r\nhvt = kzalloc(sizeof(*hvt), GFP_KERNEL);\r\nif (!hvt)\r\nreturn NULL;\r\nhvt->cn_id.idx = cn_idx;\r\nhvt->cn_id.val = cn_val;\r\nhvt->mdev.minor = MISC_DYNAMIC_MINOR;\r\nhvt->mdev.name = name;\r\nhvt->fops.owner = THIS_MODULE;\r\nhvt->fops.read = hvt_op_read;\r\nhvt->fops.write = hvt_op_write;\r\nhvt->fops.poll = hvt_op_poll;\r\nhvt->fops.open = hvt_op_open;\r\nhvt->fops.release = hvt_op_release;\r\nhvt->mdev.fops = &hvt->fops;\r\ninit_waitqueue_head(&hvt->outmsg_q);\r\nmutex_init(&hvt->lock);\r\ninit_completion(&hvt->release);\r\nspin_lock(&hvt_list_lock);\r\nlist_add(&hvt->list, &hvt_list);\r\nspin_unlock(&hvt_list_lock);\r\nhvt->on_msg = on_msg;\r\nhvt->on_reset = on_reset;\r\nif (misc_register(&hvt->mdev))\r\ngoto err_free_hvt;\r\nif (hvt->cn_id.idx > 0 && hvt->cn_id.val > 0 &&\r\ncn_add_callback(&hvt->cn_id, name, hvt_cn_callback))\r\ngoto err_free_hvt;\r\nreturn hvt;\r\nerr_free_hvt:\r\nspin_lock(&hvt_list_lock);\r\nlist_del(&hvt->list);\r\nspin_unlock(&hvt_list_lock);\r\nkfree(hvt);\r\nreturn NULL;\r\n}\r\nvoid hvutil_transport_destroy(struct hvutil_transport *hvt)\r\n{\r\nint mode_old;\r\nmutex_lock(&hvt->lock);\r\nmode_old = hvt->mode;\r\nhvt->mode = HVUTIL_TRANSPORT_DESTROY;\r\nwake_up_interruptible(&hvt->outmsg_q);\r\nmutex_unlock(&hvt->lock);\r\nspin_lock(&hvt_list_lock);\r\nlist_del(&hvt->list);\r\nspin_unlock(&hvt_list_lock);\r\nif (hvt->cn_id.idx > 0 && hvt->cn_id.val > 0)\r\ncn_del_callback(&hvt->cn_id);\r\nif (mode_old == HVUTIL_TRANSPORT_CHARDEV)\r\nwait_for_completion(&hvt->release);\r\nhvt_transport_free(hvt);\r\n}
