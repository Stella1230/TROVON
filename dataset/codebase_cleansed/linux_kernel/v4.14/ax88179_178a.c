static int __ax88179_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\r\nu16 size, void *data, int in_pm)\r\n{\r\nint ret;\r\nint (*fn)(struct usbnet *, u8, u8, u16, u16, void *, u16);\r\nBUG_ON(!dev);\r\nif (!in_pm)\r\nfn = usbnet_read_cmd;\r\nelse\r\nfn = usbnet_read_cmd_nopm;\r\nret = fn(dev, cmd, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, data, size);\r\nif (unlikely(ret < 0))\r\nnetdev_warn(dev->net, "Failed to read reg index 0x%04x: %d\n",\r\nindex, ret);\r\nreturn ret;\r\n}\r\nstatic int __ax88179_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\r\nu16 size, void *data, int in_pm)\r\n{\r\nint ret;\r\nint (*fn)(struct usbnet *, u8, u8, u16, u16, const void *, u16);\r\nBUG_ON(!dev);\r\nif (!in_pm)\r\nfn = usbnet_write_cmd;\r\nelse\r\nfn = usbnet_write_cmd_nopm;\r\nret = fn(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, data, size);\r\nif (unlikely(ret < 0))\r\nnetdev_warn(dev->net, "Failed to write reg index 0x%04x: %d\n",\r\nindex, ret);\r\nreturn ret;\r\n}\r\nstatic void ax88179_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value,\r\nu16 index, u16 size, void *data)\r\n{\r\nu16 buf;\r\nif (2 == size) {\r\nbuf = *((u16 *)data);\r\ncpu_to_le16s(&buf);\r\nusbnet_write_cmd_async(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, value, index, &buf,\r\nsize);\r\n} else {\r\nusbnet_write_cmd_async(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, value, index, data,\r\nsize);\r\n}\r\n}\r\nstatic int ax88179_read_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,\r\nu16 index, u16 size, void *data)\r\n{\r\nint ret;\r\nif (2 == size) {\r\nu16 buf;\r\nret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 1);\r\nle16_to_cpus(&buf);\r\n*((u16 *)data) = buf;\r\n} else if (4 == size) {\r\nu32 buf;\r\nret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 1);\r\nle32_to_cpus(&buf);\r\n*((u32 *)data) = buf;\r\n} else {\r\nret = __ax88179_read_cmd(dev, cmd, value, index, size, data, 1);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ax88179_write_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,\r\nu16 index, u16 size, void *data)\r\n{\r\nint ret;\r\nif (2 == size) {\r\nu16 buf;\r\nbuf = *((u16 *)data);\r\ncpu_to_le16s(&buf);\r\nret = __ax88179_write_cmd(dev, cmd, value, index,\r\nsize, &buf, 1);\r\n} else {\r\nret = __ax88179_write_cmd(dev, cmd, value, index,\r\nsize, data, 1);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ax88179_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\r\nu16 size, void *data)\r\n{\r\nint ret;\r\nif (2 == size) {\r\nu16 buf;\r\nret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 0);\r\nle16_to_cpus(&buf);\r\n*((u16 *)data) = buf;\r\n} else if (4 == size) {\r\nu32 buf;\r\nret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 0);\r\nle32_to_cpus(&buf);\r\n*((u32 *)data) = buf;\r\n} else {\r\nret = __ax88179_read_cmd(dev, cmd, value, index, size, data, 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ax88179_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\r\nu16 size, void *data)\r\n{\r\nint ret;\r\nif (2 == size) {\r\nu16 buf;\r\nbuf = *((u16 *)data);\r\ncpu_to_le16s(&buf);\r\nret = __ax88179_write_cmd(dev, cmd, value, index,\r\nsize, &buf, 0);\r\n} else {\r\nret = __ax88179_write_cmd(dev, cmd, value, index,\r\nsize, data, 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic void ax88179_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nstruct ax88179_int_data *event;\r\nu32 link;\r\nif (urb->actual_length < 8)\r\nreturn;\r\nevent = urb->transfer_buffer;\r\nle32_to_cpus((void *)&event->intdata1);\r\nlink = (((__force u32)event->intdata1) & AX_INT_PPLS_LINK) >> 16;\r\nif (netif_carrier_ok(dev->net) != link) {\r\nusbnet_link_change(dev, link, 1);\r\nnetdev_info(dev->net, "ax88179 - Link status is: %d\n", link);\r\n}\r\n}\r\nstatic int ax88179_mdio_read(struct net_device *netdev, int phy_id, int loc)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nu16 res;\r\nax88179_read_cmd(dev, AX_ACCESS_PHY, phy_id, (__u16)loc, 2, &res);\r\nreturn res;\r\n}\r\nstatic void ax88179_mdio_write(struct net_device *netdev, int phy_id, int loc,\r\nint val)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nu16 res = (u16) val;\r\nax88179_write_cmd(dev, AX_ACCESS_PHY, phy_id, (__u16)loc, 2, &res);\r\n}\r\nstatic inline int ax88179_phy_mmd_indirect(struct usbnet *dev, u16 prtad,\r\nu16 devad)\r\n{\r\nu16 tmp16;\r\nint ret;\r\ntmp16 = devad;\r\nret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nMII_MMD_CTRL, 2, &tmp16);\r\ntmp16 = prtad;\r\nret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nMII_MMD_DATA, 2, &tmp16);\r\ntmp16 = devad | MII_MMD_CTRL_NOINCR;\r\nret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nMII_MMD_CTRL, 2, &tmp16);\r\nreturn ret;\r\n}\r\nstatic int\r\nax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)\r\n{\r\nint ret;\r\nu16 tmp16;\r\nax88179_phy_mmd_indirect(dev, prtad, devad);\r\nret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nMII_MMD_DATA, 2, &tmp16);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn tmp16;\r\n}\r\nstatic int\r\nax88179_phy_write_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad,\r\nu16 data)\r\n{\r\nint ret;\r\nax88179_phy_mmd_indirect(dev, prtad, devad);\r\nret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nMII_MMD_DATA, 2, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ax88179_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nu16 tmp16;\r\nu8 tmp8;\r\nusbnet_suspend(intf, message);\r\nax88179_read_cmd_nopm(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\r\n2, 2, &tmp16);\r\ntmp16 &= ~AX_MEDIUM_RECEIVE_EN;\r\nax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\r\n2, 2, &tmp16);\r\nax88179_read_cmd_nopm(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,\r\n2, 2, &tmp16);\r\ntmp16 |= AX_PHYPWR_RSTCTL_BZ | AX_PHYPWR_RSTCTL_IPRL;\r\nax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,\r\n2, 2, &tmp16);\r\ntmp8 = 0;\r\nax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);\r\ntmp16 = AX_RX_CTL_STOP;\r\nax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &tmp16);\r\nreturn 0;\r\n}\r\nstatic int ax88179_auto_detach(struct usbnet *dev, int in_pm)\r\n{\r\nu16 tmp16;\r\nu8 tmp8;\r\nint (*fnr)(struct usbnet *, u8, u16, u16, u16, void *);\r\nint (*fnw)(struct usbnet *, u8, u16, u16, u16, void *);\r\nif (!in_pm) {\r\nfnr = ax88179_read_cmd;\r\nfnw = ax88179_write_cmd;\r\n} else {\r\nfnr = ax88179_read_cmd_nopm;\r\nfnw = ax88179_write_cmd_nopm;\r\n}\r\nif (fnr(dev, AX_ACCESS_EEPROM, 0x43, 1, 2, &tmp16) < 0)\r\nreturn 0;\r\nif ((tmp16 == 0xFFFF) || (!(tmp16 & 0x0100)))\r\nreturn 0;\r\ntmp8 = 0;\r\nfnr(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);\r\ntmp8 |= AX_CLK_SELECT_ULR;\r\nfnw(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);\r\nfnr(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &tmp16);\r\ntmp16 |= AX_PHYPWR_RSTCTL_AT;\r\nfnw(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &tmp16);\r\nreturn 0;\r\n}\r\nstatic int ax88179_resume(struct usb_interface *intf)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nu16 tmp16;\r\nu8 tmp8;\r\nusbnet_link_change(dev, 0, 0);\r\ntmp16 = 0;\r\nax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,\r\n2, 2, &tmp16);\r\nudelay(1000);\r\ntmp16 = AX_PHYPWR_RSTCTL_IPRL;\r\nax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,\r\n2, 2, &tmp16);\r\nmsleep(200);\r\nax88179_auto_detach(dev, 1);\r\nax88179_read_cmd_nopm(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);\r\ntmp8 |= AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;\r\nax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);\r\nmsleep(100);\r\ntmp16 = AX_RX_CTL_DROPCRCERR | AX_RX_CTL_IPE | AX_RX_CTL_START |\r\nAX_RX_CTL_AP | AX_RX_CTL_AMALL | AX_RX_CTL_AB;\r\nax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &tmp16);\r\nreturn usbnet_resume(intf);\r\n}\r\nstatic void\r\nax88179_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nu8 opt;\r\nif (ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD,\r\n1, 1, &opt) < 0) {\r\nwolinfo->supported = 0;\r\nwolinfo->wolopts = 0;\r\nreturn;\r\n}\r\nwolinfo->supported = WAKE_PHY | WAKE_MAGIC;\r\nwolinfo->wolopts = 0;\r\nif (opt & AX_MONITOR_MODE_RWLC)\r\nwolinfo->wolopts |= WAKE_PHY;\r\nif (opt & AX_MONITOR_MODE_RWMP)\r\nwolinfo->wolopts |= WAKE_MAGIC;\r\n}\r\nstatic int\r\nax88179_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nu8 opt = 0;\r\nif (wolinfo->wolopts & WAKE_PHY)\r\nopt |= AX_MONITOR_MODE_RWLC;\r\nif (wolinfo->wolopts & WAKE_MAGIC)\r\nopt |= AX_MONITOR_MODE_RWMP;\r\nif (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD,\r\n1, 1, &opt) < 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ax88179_get_eeprom_len(struct net_device *net)\r\n{\r\nreturn AX_EEPROM_LEN;\r\n}\r\nstatic int\r\nax88179_get_eeprom(struct net_device *net, struct ethtool_eeprom *eeprom,\r\nu8 *data)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nu16 *eeprom_buff;\r\nint first_word, last_word;\r\nint i, ret;\r\nif (eeprom->len == 0)\r\nreturn -EINVAL;\r\neeprom->magic = AX88179_EEPROM_MAGIC;\r\nfirst_word = eeprom->offset >> 1;\r\nlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\r\neeprom_buff = kmalloc(sizeof(u16) * (last_word - first_word + 1),\r\nGFP_KERNEL);\r\nif (!eeprom_buff)\r\nreturn -ENOMEM;\r\nfor (i = first_word; i <= last_word; i++) {\r\nret = __ax88179_read_cmd(dev, AX_ACCESS_EEPROM, i, 1, 2,\r\n&eeprom_buff[i - first_word],\r\n0);\r\nif (ret < 0) {\r\nkfree(eeprom_buff);\r\nreturn -EIO;\r\n}\r\n}\r\nmemcpy(data, (u8 *)eeprom_buff + (eeprom->offset & 1), eeprom->len);\r\nkfree(eeprom_buff);\r\nreturn 0;\r\n}\r\nstatic int ax88179_get_link_ksettings(struct net_device *net,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nmii_ethtool_get_link_ksettings(&dev->mii, cmd);\r\nreturn 0;\r\n}\r\nstatic int ax88179_set_link_ksettings(struct net_device *net,\r\nconst struct ethtool_link_ksettings *cmd)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nreturn mii_ethtool_set_link_ksettings(&dev->mii, cmd);\r\n}\r\nstatic int\r\nax88179_ethtool_get_eee(struct usbnet *dev, struct ethtool_eee *data)\r\n{\r\nint val;\r\nval = ax88179_phy_read_mmd_indirect(dev, MDIO_PCS_EEE_ABLE,\r\nMDIO_MMD_PCS);\r\nif (val < 0)\r\nreturn val;\r\ndata->supported = mmd_eee_cap_to_ethtool_sup_t(val);\r\nval = ax88179_phy_read_mmd_indirect(dev, MDIO_AN_EEE_ADV,\r\nMDIO_MMD_AN);\r\nif (val < 0)\r\nreturn val;\r\ndata->advertised = mmd_eee_adv_to_ethtool_adv_t(val);\r\nval = ax88179_phy_read_mmd_indirect(dev, MDIO_AN_EEE_LPABLE,\r\nMDIO_MMD_AN);\r\nif (val < 0)\r\nreturn val;\r\ndata->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(val);\r\nreturn 0;\r\n}\r\nstatic int\r\nax88179_ethtool_set_eee(struct usbnet *dev, struct ethtool_eee *data)\r\n{\r\nu16 tmp16 = ethtool_adv_to_mmd_eee_adv_t(data->advertised);\r\nreturn ax88179_phy_write_mmd_indirect(dev, MDIO_AN_EEE_ADV,\r\nMDIO_MMD_AN, tmp16);\r\n}\r\nstatic int ax88179_chk_eee(struct usbnet *dev)\r\n{\r\nstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\r\nstruct ax88179_data *priv = (struct ax88179_data *)dev->data;\r\nmii_ethtool_gset(&dev->mii, &ecmd);\r\nif (ecmd.duplex & DUPLEX_FULL) {\r\nint eee_lp, eee_cap, eee_adv;\r\nu32 lp, cap, adv, supported = 0;\r\neee_cap = ax88179_phy_read_mmd_indirect(dev,\r\nMDIO_PCS_EEE_ABLE,\r\nMDIO_MMD_PCS);\r\nif (eee_cap < 0) {\r\npriv->eee_active = 0;\r\nreturn false;\r\n}\r\ncap = mmd_eee_cap_to_ethtool_sup_t(eee_cap);\r\nif (!cap) {\r\npriv->eee_active = 0;\r\nreturn false;\r\n}\r\neee_lp = ax88179_phy_read_mmd_indirect(dev,\r\nMDIO_AN_EEE_LPABLE,\r\nMDIO_MMD_AN);\r\nif (eee_lp < 0) {\r\npriv->eee_active = 0;\r\nreturn false;\r\n}\r\neee_adv = ax88179_phy_read_mmd_indirect(dev,\r\nMDIO_AN_EEE_ADV,\r\nMDIO_MMD_AN);\r\nif (eee_adv < 0) {\r\npriv->eee_active = 0;\r\nreturn false;\r\n}\r\nadv = mmd_eee_adv_to_ethtool_adv_t(eee_adv);\r\nlp = mmd_eee_adv_to_ethtool_adv_t(eee_lp);\r\nsupported = (ecmd.speed == SPEED_1000) ?\r\nSUPPORTED_1000baseT_Full :\r\nSUPPORTED_100baseT_Full;\r\nif (!(lp & adv & supported)) {\r\npriv->eee_active = 0;\r\nreturn false;\r\n}\r\npriv->eee_active = 1;\r\nreturn true;\r\n}\r\npriv->eee_active = 0;\r\nreturn false;\r\n}\r\nstatic void ax88179_disable_eee(struct usbnet *dev)\r\n{\r\nu16 tmp16;\r\ntmp16 = GMII_PHY_PGSEL_PAGE3;\r\nax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nGMII_PHY_PAGE_SELECT, 2, &tmp16);\r\ntmp16 = 0x3246;\r\nax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nMII_PHYADDR, 2, &tmp16);\r\ntmp16 = GMII_PHY_PGSEL_PAGE0;\r\nax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nGMII_PHY_PAGE_SELECT, 2, &tmp16);\r\n}\r\nstatic void ax88179_enable_eee(struct usbnet *dev)\r\n{\r\nu16 tmp16;\r\ntmp16 = GMII_PHY_PGSEL_PAGE3;\r\nax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nGMII_PHY_PAGE_SELECT, 2, &tmp16);\r\ntmp16 = 0x3247;\r\nax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nMII_PHYADDR, 2, &tmp16);\r\ntmp16 = GMII_PHY_PGSEL_PAGE5;\r\nax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nGMII_PHY_PAGE_SELECT, 2, &tmp16);\r\ntmp16 = 0x0680;\r\nax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nMII_BMSR, 2, &tmp16);\r\ntmp16 = GMII_PHY_PGSEL_PAGE0;\r\nax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nGMII_PHY_PAGE_SELECT, 2, &tmp16);\r\n}\r\nstatic int ax88179_get_eee(struct net_device *net, struct ethtool_eee *edata)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct ax88179_data *priv = (struct ax88179_data *)dev->data;\r\nedata->eee_enabled = priv->eee_enabled;\r\nedata->eee_active = priv->eee_active;\r\nreturn ax88179_ethtool_get_eee(dev, edata);\r\n}\r\nstatic int ax88179_set_eee(struct net_device *net, struct ethtool_eee *edata)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct ax88179_data *priv = (struct ax88179_data *)dev->data;\r\nint ret = -EOPNOTSUPP;\r\npriv->eee_enabled = edata->eee_enabled;\r\nif (!priv->eee_enabled) {\r\nax88179_disable_eee(dev);\r\n} else {\r\npriv->eee_enabled = ax88179_chk_eee(dev);\r\nif (!priv->eee_enabled)\r\nreturn -EOPNOTSUPP;\r\nax88179_enable_eee(dev);\r\n}\r\nret = ax88179_ethtool_set_eee(dev, edata);\r\nif (ret)\r\nreturn ret;\r\nmii_nway_restart(&dev->mii);\r\nusbnet_link_change(dev, 0, 0);\r\nreturn ret;\r\n}\r\nstatic int ax88179_ioctl(struct net_device *net, struct ifreq *rq, int cmd)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nreturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\r\n}\r\nstatic void ax88179_set_multicast(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct ax88179_data *data = (struct ax88179_data *)dev->data;\r\nu8 *m_filter = ((u8 *)dev->data) + 12;\r\ndata->rxctl = (AX_RX_CTL_START | AX_RX_CTL_AB | AX_RX_CTL_IPE);\r\nif (net->flags & IFF_PROMISC) {\r\ndata->rxctl |= AX_RX_CTL_PRO;\r\n} else if (net->flags & IFF_ALLMULTI ||\r\nnetdev_mc_count(net) > AX_MAX_MCAST) {\r\ndata->rxctl |= AX_RX_CTL_AMALL;\r\n} else if (netdev_mc_empty(net)) {\r\n} else {\r\nu32 crc_bits;\r\nstruct netdev_hw_addr *ha;\r\nmemset(m_filter, 0, AX_MCAST_FLTSIZE);\r\nnetdev_for_each_mc_addr(ha, net) {\r\ncrc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\n*(m_filter + (crc_bits >> 3)) |= (1 << (crc_bits & 7));\r\n}\r\nax88179_write_cmd_async(dev, AX_ACCESS_MAC, AX_MULFLTARY,\r\nAX_MCAST_FLTSIZE, AX_MCAST_FLTSIZE,\r\nm_filter);\r\ndata->rxctl |= AX_RX_CTL_AM;\r\n}\r\nax88179_write_cmd_async(dev, AX_ACCESS_MAC, AX_RX_CTL,\r\n2, 2, &data->rxctl);\r\n}\r\nstatic int\r\nax88179_set_features(struct net_device *net, netdev_features_t features)\r\n{\r\nu8 tmp;\r\nstruct usbnet *dev = netdev_priv(net);\r\nnetdev_features_t changed = net->features ^ features;\r\nif (changed & NETIF_F_IP_CSUM) {\r\nax88179_read_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);\r\ntmp ^= AX_TXCOE_TCP | AX_TXCOE_UDP;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);\r\n}\r\nif (changed & NETIF_F_IPV6_CSUM) {\r\nax88179_read_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);\r\ntmp ^= AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);\r\n}\r\nif (changed & NETIF_F_RXCSUM) {\r\nax88179_read_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &tmp);\r\ntmp ^= AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |\r\nAX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &tmp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ax88179_change_mtu(struct net_device *net, int new_mtu)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nu16 tmp16;\r\nnet->mtu = new_mtu;\r\ndev->hard_mtu = net->mtu + net->hard_header_len;\r\nif (net->mtu > 1500) {\r\nax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\r\n2, 2, &tmp16);\r\ntmp16 |= AX_MEDIUM_JUMBO_EN;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\r\n2, 2, &tmp16);\r\n} else {\r\nax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\r\n2, 2, &tmp16);\r\ntmp16 &= ~AX_MEDIUM_JUMBO_EN;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\r\n2, 2, &tmp16);\r\n}\r\nusbnet_update_max_qlen(dev);\r\nreturn 0;\r\n}\r\nstatic int ax88179_set_mac_addr(struct net_device *net, void *p)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct sockaddr *addr = p;\r\nint ret;\r\nif (netif_running(net))\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(net->dev_addr, addr->sa_data, ETH_ALEN);\r\nret = ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,\r\nETH_ALEN, net->dev_addr);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ax88179_check_eeprom(struct usbnet *dev)\r\n{\r\nu8 i, buf, eeprom[20];\r\nu16 csum, delay = HZ / 10;\r\nunsigned long jtimeout;\r\nfor (i = 0; i < 6; i++) {\r\nbuf = i;\r\nif (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_ADDR,\r\n1, 1, &buf) < 0)\r\nreturn -EINVAL;\r\nbuf = EEP_RD;\r\nif (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,\r\n1, 1, &buf) < 0)\r\nreturn -EINVAL;\r\njtimeout = jiffies + delay;\r\ndo {\r\nax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,\r\n1, 1, &buf);\r\nif (time_after(jiffies, jtimeout))\r\nreturn -EINVAL;\r\n} while (buf & EEP_BUSY);\r\n__ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_DATA_LOW,\r\n2, 2, &eeprom[i * 2], 0);\r\nif ((i == 0) && (eeprom[0] == 0xFF))\r\nreturn -EINVAL;\r\n}\r\ncsum = eeprom[6] + eeprom[7] + eeprom[8] + eeprom[9];\r\ncsum = (csum >> 8) + (csum & 0xff);\r\nif ((csum + eeprom[10]) != 0xff)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ax88179_check_efuse(struct usbnet *dev, u16 *ledmode)\r\n{\r\nu8 i;\r\nu8 efuse[64];\r\nu16 csum = 0;\r\nif (ax88179_read_cmd(dev, AX_ACCESS_EFUS, 0, 64, 64, efuse) < 0)\r\nreturn -EINVAL;\r\nif (*efuse == 0xFF)\r\nreturn -EINVAL;\r\nfor (i = 0; i < 64; i++)\r\ncsum = csum + efuse[i];\r\nwhile (csum > 255)\r\ncsum = (csum & 0x00FF) + ((csum >> 8) & 0x00FF);\r\nif (csum != 0xFF)\r\nreturn -EINVAL;\r\n*ledmode = (efuse[51] << 8) | efuse[52];\r\nreturn 0;\r\n}\r\nstatic int ax88179_convert_old_led(struct usbnet *dev, u16 *ledvalue)\r\n{\r\nu16 led;\r\nif (ax88179_read_cmd(dev, AX_ACCESS_EEPROM, 0x3C, 1, 2, &led) < 0)\r\nreturn -EINVAL;\r\nled >>= 8;\r\nswitch (led) {\r\ncase 0xFF:\r\nled = LED0_ACTIVE | LED1_LINK_10 | LED1_LINK_100 |\r\nLED1_LINK_1000 | LED2_ACTIVE | LED2_LINK_10 |\r\nLED2_LINK_100 | LED2_LINK_1000 | LED_VALID;\r\nbreak;\r\ncase 0xFE:\r\nled = LED0_ACTIVE | LED1_LINK_1000 | LED2_LINK_100 | LED_VALID;\r\nbreak;\r\ncase 0xFD:\r\nled = LED0_ACTIVE | LED1_LINK_1000 | LED2_LINK_100 |\r\nLED2_LINK_10 | LED_VALID;\r\nbreak;\r\ncase 0xFC:\r\nled = LED0_ACTIVE | LED1_ACTIVE | LED1_LINK_1000 | LED2_ACTIVE |\r\nLED2_LINK_100 | LED2_LINK_10 | LED_VALID;\r\nbreak;\r\ndefault:\r\nled = LED0_ACTIVE | LED1_LINK_10 | LED1_LINK_100 |\r\nLED1_LINK_1000 | LED2_ACTIVE | LED2_LINK_10 |\r\nLED2_LINK_100 | LED2_LINK_1000 | LED_VALID;\r\nbreak;\r\n}\r\n*ledvalue = led;\r\nreturn 0;\r\n}\r\nstatic int ax88179_led_setting(struct usbnet *dev)\r\n{\r\nu8 ledfd, value = 0;\r\nu16 tmp, ledact, ledlink, ledvalue = 0, delay = HZ / 10;\r\nunsigned long jtimeout;\r\nax88179_read_cmd(dev, AX_ACCESS_MAC, GENERAL_STATUS, 1, 1, &value);\r\nif (!(value & AX_SECLD)) {\r\nvalue = AX_GPIO_CTRL_GPIO3EN | AX_GPIO_CTRL_GPIO2EN |\r\nAX_GPIO_CTRL_GPIO1EN;\r\nif (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_GPIO_CTRL,\r\n1, 1, &value) < 0)\r\nreturn -EINVAL;\r\n}\r\nif (!ax88179_check_eeprom(dev)) {\r\nvalue = 0x42;\r\nif (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_ADDR,\r\n1, 1, &value) < 0)\r\nreturn -EINVAL;\r\nvalue = EEP_RD;\r\nif (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,\r\n1, 1, &value) < 0)\r\nreturn -EINVAL;\r\njtimeout = jiffies + delay;\r\ndo {\r\nax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,\r\n1, 1, &value);\r\nif (time_after(jiffies, jtimeout))\r\nreturn -EINVAL;\r\n} while (value & EEP_BUSY);\r\nax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_DATA_HIGH,\r\n1, 1, &value);\r\nledvalue = (value << 8);\r\nax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_DATA_LOW,\r\n1, 1, &value);\r\nledvalue |= value;\r\nif ((ledvalue == 0xFFFF) || ((ledvalue & LED_VALID) == 0))\r\nax88179_convert_old_led(dev, &ledvalue);\r\n} else if (!ax88179_check_efuse(dev, &ledvalue)) {\r\nif ((ledvalue == 0xFFFF) || ((ledvalue & LED_VALID) == 0))\r\nax88179_convert_old_led(dev, &ledvalue);\r\n} else {\r\nax88179_convert_old_led(dev, &ledvalue);\r\n}\r\ntmp = GMII_PHY_PGSEL_EXT;\r\nax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nGMII_PHY_PAGE_SELECT, 2, &tmp);\r\ntmp = 0x2c;\r\nax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nGMII_PHYPAGE, 2, &tmp);\r\nax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nGMII_LED_ACT, 2, &ledact);\r\nax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nGMII_LED_LINK, 2, &ledlink);\r\nledact &= GMII_LED_ACTIVE_MASK;\r\nledlink &= GMII_LED_LINK_MASK;\r\nif (ledvalue & LED0_ACTIVE)\r\nledact |= GMII_LED0_ACTIVE;\r\nif (ledvalue & LED1_ACTIVE)\r\nledact |= GMII_LED1_ACTIVE;\r\nif (ledvalue & LED2_ACTIVE)\r\nledact |= GMII_LED2_ACTIVE;\r\nif (ledvalue & LED0_LINK_10)\r\nledlink |= GMII_LED0_LINK_10;\r\nif (ledvalue & LED1_LINK_10)\r\nledlink |= GMII_LED1_LINK_10;\r\nif (ledvalue & LED2_LINK_10)\r\nledlink |= GMII_LED2_LINK_10;\r\nif (ledvalue & LED0_LINK_100)\r\nledlink |= GMII_LED0_LINK_100;\r\nif (ledvalue & LED1_LINK_100)\r\nledlink |= GMII_LED1_LINK_100;\r\nif (ledvalue & LED2_LINK_100)\r\nledlink |= GMII_LED2_LINK_100;\r\nif (ledvalue & LED0_LINK_1000)\r\nledlink |= GMII_LED0_LINK_1000;\r\nif (ledvalue & LED1_LINK_1000)\r\nledlink |= GMII_LED1_LINK_1000;\r\nif (ledvalue & LED2_LINK_1000)\r\nledlink |= GMII_LED2_LINK_1000;\r\ntmp = ledact;\r\nax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nGMII_LED_ACT, 2, &tmp);\r\ntmp = ledlink;\r\nax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nGMII_LED_LINK, 2, &tmp);\r\ntmp = GMII_PHY_PGSEL_PAGE0;\r\nax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nGMII_PHY_PAGE_SELECT, 2, &tmp);\r\nledfd = 0;\r\nif (ledvalue & LED0_FD)\r\nledfd |= 0x01;\r\nelse if ((ledvalue & LED0_USB3_MASK) == 0)\r\nledfd |= 0x02;\r\nif (ledvalue & LED1_FD)\r\nledfd |= 0x04;\r\nelse if ((ledvalue & LED1_USB3_MASK) == 0)\r\nledfd |= 0x08;\r\nif (ledvalue & LED2_FD)\r\nledfd |= 0x10;\r\nelse if ((ledvalue & LED2_USB3_MASK) == 0)\r\nledfd |= 0x20;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_LEDCTRL, 1, 1, &ledfd);\r\nreturn 0;\r\n}\r\nstatic int ax88179_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nu8 buf[5];\r\nu16 *tmp16;\r\nu8 *tmp;\r\nstruct ax88179_data *ax179_data = (struct ax88179_data *)dev->data;\r\nstruct ethtool_eee eee_data;\r\nusbnet_get_endpoints(dev, intf);\r\ntmp16 = (u16 *)buf;\r\ntmp = (u8 *)buf;\r\nmemset(ax179_data, 0, sizeof(*ax179_data));\r\n*tmp16 = 0;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, tmp16);\r\n*tmp16 = AX_PHYPWR_RSTCTL_IPRL;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, tmp16);\r\nmsleep(200);\r\n*tmp = AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, tmp);\r\nmsleep(100);\r\nax88179_read_cmd(dev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,\r\nETH_ALEN, dev->net->dev_addr);\r\nmemcpy(dev->net->perm_addr, dev->net->dev_addr, ETH_ALEN);\r\nmemcpy(tmp, &AX88179_BULKIN_SIZE[0], 5);\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, tmp);\r\ndev->rx_urb_size = 1024 * 20;\r\n*tmp = 0x34;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_LOW, 1, 1, tmp);\r\n*tmp = 0x52;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_HIGH,\r\n1, 1, tmp);\r\ndev->net->netdev_ops = &ax88179_netdev_ops;\r\ndev->net->ethtool_ops = &ax88179_ethtool_ops;\r\ndev->net->needed_headroom = 8;\r\ndev->net->max_mtu = 4088;\r\ndev->mii.dev = dev->net;\r\ndev->mii.mdio_read = ax88179_mdio_read;\r\ndev->mii.mdio_write = ax88179_mdio_write;\r\ndev->mii.phy_id_mask = 0xff;\r\ndev->mii.reg_num_mask = 0xff;\r\ndev->mii.phy_id = 0x03;\r\ndev->mii.supports_gmii = 1;\r\ndev->net->features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\r\nNETIF_F_RXCSUM;\r\ndev->net->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\r\nNETIF_F_RXCSUM;\r\n*tmp = AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |\r\nAX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, tmp);\r\n*tmp = AX_TXCOE_IP | AX_TXCOE_TCP | AX_TXCOE_UDP |\r\nAX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, tmp);\r\n*tmp16 = AX_RX_CTL_DROPCRCERR | AX_RX_CTL_IPE | AX_RX_CTL_START |\r\nAX_RX_CTL_AP | AX_RX_CTL_AMALL | AX_RX_CTL_AB;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, tmp16);\r\n*tmp = AX_MONITOR_MODE_PMETYPE | AX_MONITOR_MODE_PMEPOL |\r\nAX_MONITOR_MODE_RWMP;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD, 1, 1, tmp);\r\n*tmp16 = AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_TXFLOW_CTRLEN |\r\nAX_MEDIUM_RXFLOW_CTRLEN | AX_MEDIUM_FULL_DUPLEX |\r\nAX_MEDIUM_GIGAMODE;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\r\n2, 2, tmp16);\r\nax88179_led_setting(dev);\r\nax179_data->eee_enabled = 0;\r\nax179_data->eee_active = 0;\r\nax88179_disable_eee(dev);\r\nax88179_ethtool_get_eee(dev, &eee_data);\r\neee_data.advertised = 0;\r\nax88179_ethtool_set_eee(dev, &eee_data);\r\nmii_nway_restart(&dev->mii);\r\nusbnet_link_change(dev, 0, 0);\r\nreturn 0;\r\n}\r\nstatic void ax88179_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nu16 tmp16;\r\ntmp16 = AX_RX_CTL_STOP;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &tmp16);\r\ntmp16 = 0;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp16);\r\ntmp16 = 0;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &tmp16);\r\n}\r\nstatic void\r\nax88179_rx_checksum(struct sk_buff *skb, u32 *pkt_hdr)\r\n{\r\nskb->ip_summed = CHECKSUM_NONE;\r\nif ((*pkt_hdr & AX_RXHDR_L3CSUM_ERR) ||\r\n(*pkt_hdr & AX_RXHDR_L4CSUM_ERR))\r\nreturn;\r\nif (((*pkt_hdr & AX_RXHDR_L4_TYPE_MASK) == AX_RXHDR_L4_TYPE_TCP) ||\r\n((*pkt_hdr & AX_RXHDR_L4_TYPE_MASK) == AX_RXHDR_L4_TYPE_UDP))\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n}\r\nstatic int ax88179_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *ax_skb;\r\nint pkt_cnt;\r\nu32 rx_hdr;\r\nu16 hdr_off;\r\nu32 *pkt_hdr;\r\nif (skb->len < dev->net->hard_header_len)\r\nreturn 0;\r\nskb_trim(skb, skb->len - 4);\r\nmemcpy(&rx_hdr, skb_tail_pointer(skb), 4);\r\nle32_to_cpus(&rx_hdr);\r\npkt_cnt = (u16)rx_hdr;\r\nhdr_off = (u16)(rx_hdr >> 16);\r\npkt_hdr = (u32 *)(skb->data + hdr_off);\r\nwhile (pkt_cnt--) {\r\nu16 pkt_len;\r\nle32_to_cpus(pkt_hdr);\r\npkt_len = (*pkt_hdr >> 16) & 0x1fff;\r\nif ((*pkt_hdr & AX_RXHDR_CRC_ERR) ||\r\n(*pkt_hdr & AX_RXHDR_DROP_ERR)) {\r\nskb_pull(skb, (pkt_len + 7) & 0xFFF8);\r\npkt_hdr++;\r\ncontinue;\r\n}\r\nif (pkt_cnt == 0) {\r\nskb_pull(skb, 2);\r\nskb->len = pkt_len;\r\nskb_set_tail_pointer(skb, pkt_len);\r\nskb->truesize = pkt_len + sizeof(struct sk_buff);\r\nax88179_rx_checksum(skb, pkt_hdr);\r\nreturn 1;\r\n}\r\nax_skb = skb_clone(skb, GFP_ATOMIC);\r\nif (ax_skb) {\r\nax_skb->len = pkt_len;\r\nax_skb->data = skb->data + 2;\r\nskb_set_tail_pointer(ax_skb, pkt_len);\r\nax_skb->truesize = pkt_len + sizeof(struct sk_buff);\r\nax88179_rx_checksum(ax_skb, pkt_hdr);\r\nusbnet_skb_return(dev, ax_skb);\r\n} else {\r\nreturn 0;\r\n}\r\nskb_pull(skb, (pkt_len + 7) & 0xFFF8);\r\npkt_hdr++;\r\n}\r\nreturn 1;\r\n}\r\nstatic struct sk_buff *\r\nax88179_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\r\n{\r\nu32 tx_hdr1, tx_hdr2;\r\nint frame_size = dev->maxpacket;\r\nint mss = skb_shinfo(skb)->gso_size;\r\nint headroom;\r\ntx_hdr1 = skb->len;\r\ntx_hdr2 = mss;\r\nif (((skb->len + 8) % frame_size) == 0)\r\ntx_hdr2 |= 0x80008000;\r\nheadroom = skb_headroom(skb) - 8;\r\nif ((skb_header_cloned(skb) || headroom < 0) &&\r\npskb_expand_head(skb, headroom < 0 ? 8 : 0, 0, GFP_ATOMIC)) {\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n}\r\nskb_push(skb, 4);\r\ncpu_to_le32s(&tx_hdr2);\r\nskb_copy_to_linear_data(skb, &tx_hdr2, 4);\r\nskb_push(skb, 4);\r\ncpu_to_le32s(&tx_hdr1);\r\nskb_copy_to_linear_data(skb, &tx_hdr1, 4);\r\nreturn skb;\r\n}\r\nstatic int ax88179_link_reset(struct usbnet *dev)\r\n{\r\nstruct ax88179_data *ax179_data = (struct ax88179_data *)dev->data;\r\nu8 tmp[5], link_sts;\r\nu16 mode, tmp16, delay = HZ / 10;\r\nu32 tmp32 = 0x40000000;\r\nunsigned long jtimeout;\r\njtimeout = jiffies + delay;\r\nwhile (tmp32 & 0x40000000) {\r\nmode = 0;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &mode);\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2,\r\n&ax179_data->rxctl);\r\nax88179_read_cmd(dev, 0x81, 0x8c, 0, 4, &tmp32);\r\nif (time_after(jiffies, jtimeout))\r\nreturn 0;\r\n}\r\nmode = AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_TXFLOW_CTRLEN |\r\nAX_MEDIUM_RXFLOW_CTRLEN;\r\nax88179_read_cmd(dev, AX_ACCESS_MAC, PHYSICAL_LINK_STATUS,\r\n1, 1, &link_sts);\r\nax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\r\nGMII_PHY_PHYSR, 2, &tmp16);\r\nif (!(tmp16 & GMII_PHY_PHYSR_LINK)) {\r\nreturn 0;\r\n} else if (GMII_PHY_PHYSR_GIGA == (tmp16 & GMII_PHY_PHYSR_SMASK)) {\r\nmode |= AX_MEDIUM_GIGAMODE | AX_MEDIUM_EN_125MHZ;\r\nif (dev->net->mtu > 1500)\r\nmode |= AX_MEDIUM_JUMBO_EN;\r\nif (link_sts & AX_USB_SS)\r\nmemcpy(tmp, &AX88179_BULKIN_SIZE[0], 5);\r\nelse if (link_sts & AX_USB_HS)\r\nmemcpy(tmp, &AX88179_BULKIN_SIZE[1], 5);\r\nelse\r\nmemcpy(tmp, &AX88179_BULKIN_SIZE[3], 5);\r\n} else if (GMII_PHY_PHYSR_100 == (tmp16 & GMII_PHY_PHYSR_SMASK)) {\r\nmode |= AX_MEDIUM_PS;\r\nif (link_sts & (AX_USB_SS | AX_USB_HS))\r\nmemcpy(tmp, &AX88179_BULKIN_SIZE[2], 5);\r\nelse\r\nmemcpy(tmp, &AX88179_BULKIN_SIZE[3], 5);\r\n} else {\r\nmemcpy(tmp, &AX88179_BULKIN_SIZE[3], 5);\r\n}\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, tmp);\r\ndev->rx_urb_size = (1024 * (tmp[3] + 2));\r\nif (tmp16 & GMII_PHY_PHYSR_FULL)\r\nmode |= AX_MEDIUM_FULL_DUPLEX;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\r\n2, 2, &mode);\r\nax179_data->eee_enabled = ax88179_chk_eee(dev);\r\nnetif_carrier_on(dev->net);\r\nreturn 0;\r\n}\r\nstatic int ax88179_reset(struct usbnet *dev)\r\n{\r\nu8 buf[5];\r\nu16 *tmp16;\r\nu8 *tmp;\r\nstruct ax88179_data *ax179_data = (struct ax88179_data *)dev->data;\r\nstruct ethtool_eee eee_data;\r\ntmp16 = (u16 *)buf;\r\ntmp = (u8 *)buf;\r\n*tmp16 = 0;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, tmp16);\r\n*tmp16 = AX_PHYPWR_RSTCTL_IPRL;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, tmp16);\r\nmsleep(200);\r\n*tmp = AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, tmp);\r\nmsleep(100);\r\nax88179_auto_detach(dev, 0);\r\nax88179_read_cmd(dev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN, ETH_ALEN,\r\ndev->net->dev_addr);\r\nmemcpy(dev->net->perm_addr, dev->net->dev_addr, ETH_ALEN);\r\nmemcpy(tmp, &AX88179_BULKIN_SIZE[0], 5);\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, tmp);\r\ndev->rx_urb_size = 1024 * 20;\r\n*tmp = 0x34;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_LOW, 1, 1, tmp);\r\n*tmp = 0x52;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_HIGH,\r\n1, 1, tmp);\r\ndev->net->features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\r\nNETIF_F_RXCSUM;\r\ndev->net->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\r\nNETIF_F_RXCSUM;\r\n*tmp = AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |\r\nAX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, tmp);\r\n*tmp = AX_TXCOE_IP | AX_TXCOE_TCP | AX_TXCOE_UDP |\r\nAX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, tmp);\r\n*tmp16 = AX_RX_CTL_DROPCRCERR | AX_RX_CTL_IPE | AX_RX_CTL_START |\r\nAX_RX_CTL_AP | AX_RX_CTL_AMALL | AX_RX_CTL_AB;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, tmp16);\r\n*tmp = AX_MONITOR_MODE_PMETYPE | AX_MONITOR_MODE_PMEPOL |\r\nAX_MONITOR_MODE_RWMP;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD, 1, 1, tmp);\r\n*tmp16 = AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_TXFLOW_CTRLEN |\r\nAX_MEDIUM_RXFLOW_CTRLEN | AX_MEDIUM_FULL_DUPLEX |\r\nAX_MEDIUM_GIGAMODE;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\r\n2, 2, tmp16);\r\nax88179_led_setting(dev);\r\nax179_data->eee_enabled = 0;\r\nax179_data->eee_active = 0;\r\nax88179_disable_eee(dev);\r\nax88179_ethtool_get_eee(dev, &eee_data);\r\neee_data.advertised = 0;\r\nax88179_ethtool_set_eee(dev, &eee_data);\r\nmii_nway_restart(&dev->mii);\r\nusbnet_link_change(dev, 0, 0);\r\nreturn 0;\r\n}\r\nstatic int ax88179_stop(struct usbnet *dev)\r\n{\r\nu16 tmp16;\r\nax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\r\n2, 2, &tmp16);\r\ntmp16 &= ~AX_MEDIUM_RECEIVE_EN;\r\nax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\r\n2, 2, &tmp16);\r\nreturn 0;\r\n}
