static bool hip04_cluster_is_down(unsigned int cluster)\r\n{\r\nint i;\r\nfor (i = 0; i < HIP04_MAX_CPUS_PER_CLUSTER; i++)\r\nif (hip04_cpu_table[cluster][i])\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void hip04_set_snoop_filter(unsigned int cluster, unsigned int on)\r\n{\r\nunsigned long data;\r\nif (!fabric)\r\nBUG();\r\ndata = readl_relaxed(fabric + FAB_SF_MODE);\r\nif (on)\r\ndata |= 1 << cluster;\r\nelse\r\ndata &= ~(1 << cluster);\r\nwritel_relaxed(data, fabric + FAB_SF_MODE);\r\ndo {\r\ncpu_relax();\r\n} while (data != readl_relaxed(fabric + FAB_SF_MODE));\r\n}\r\nstatic int hip04_boot_secondary(unsigned int l_cpu, struct task_struct *idle)\r\n{\r\nunsigned int mpidr, cpu, cluster;\r\nunsigned long data;\r\nvoid __iomem *sys_dreq, *sys_status;\r\nmpidr = cpu_logical_map(l_cpu);\r\ncpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);\r\ncluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\nif (!sysctrl)\r\nreturn -ENODEV;\r\nif (cluster >= HIP04_MAX_CLUSTERS || cpu >= HIP04_MAX_CPUS_PER_CLUSTER)\r\nreturn -EINVAL;\r\nspin_lock_irq(&boot_lock);\r\nif (hip04_cpu_table[cluster][cpu])\r\ngoto out;\r\nsys_dreq = sysctrl + SC_CPU_RESET_DREQ(cluster);\r\nsys_status = sysctrl + SC_CPU_RESET_STATUS(cluster);\r\nif (hip04_cluster_is_down(cluster)) {\r\ndata = CLUSTER_DEBUG_RESET_BIT;\r\nwritel_relaxed(data, sys_dreq);\r\ndo {\r\ncpu_relax();\r\ndata = readl_relaxed(sys_status);\r\n} while (data & CLUSTER_DEBUG_RESET_STATUS);\r\nhip04_set_snoop_filter(cluster, 1);\r\n}\r\ndata = CORE_RESET_BIT(cpu) | NEON_RESET_BIT(cpu) | \\r\nCORE_DEBUG_RESET_BIT(cpu);\r\nwritel_relaxed(data, sys_dreq);\r\ndo {\r\ncpu_relax();\r\n} while (data == readl_relaxed(sys_status));\r\nudelay(20);\r\narch_send_wakeup_ipi_mask(cpumask_of(l_cpu));\r\nout:\r\nhip04_cpu_table[cluster][cpu]++;\r\nspin_unlock_irq(&boot_lock);\r\nreturn 0;\r\n}\r\nstatic void hip04_cpu_die(unsigned int l_cpu)\r\n{\r\nunsigned int mpidr, cpu, cluster;\r\nbool last_man;\r\nmpidr = cpu_logical_map(l_cpu);\r\ncpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);\r\ncluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\nspin_lock(&boot_lock);\r\nhip04_cpu_table[cluster][cpu]--;\r\nif (hip04_cpu_table[cluster][cpu] == 1) {\r\nspin_unlock(&boot_lock);\r\nreturn;\r\n} else if (hip04_cpu_table[cluster][cpu] > 1) {\r\npr_err("Cluster %d CPU%d boots multiple times\n", cluster, cpu);\r\nBUG();\r\n}\r\nlast_man = hip04_cluster_is_down(cluster);\r\nspin_unlock(&boot_lock);\r\nif (last_man) {\r\nasm volatile(\r\n"mcr p15, 1, %0, c15, c0, 3 \n\t"\r\n"isb \n\t"\r\n"dsb "\r\n: : "r" (0x400) );\r\nv7_exit_coherency_flush(all);\r\n} else {\r\nv7_exit_coherency_flush(louis);\r\n}\r\nfor (;;)\r\nwfi();\r\n}\r\nstatic int hip04_cpu_kill(unsigned int l_cpu)\r\n{\r\nunsigned int mpidr, cpu, cluster;\r\nunsigned int data, tries, count;\r\nmpidr = cpu_logical_map(l_cpu);\r\ncpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);\r\ncluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\nBUG_ON(cluster >= HIP04_MAX_CLUSTERS ||\r\ncpu >= HIP04_MAX_CPUS_PER_CLUSTER);\r\ncount = TIMEOUT_MSEC / POLL_MSEC;\r\nspin_lock_irq(&boot_lock);\r\nfor (tries = 0; tries < count; tries++) {\r\nif (hip04_cpu_table[cluster][cpu])\r\ngoto err;\r\ncpu_relax();\r\ndata = readl_relaxed(sysctrl + SC_CPU_RESET_STATUS(cluster));\r\nif (data & CORE_WFI_STATUS(cpu))\r\nbreak;\r\nspin_unlock_irq(&boot_lock);\r\nmsleep(POLL_MSEC);\r\nspin_lock_irq(&boot_lock);\r\n}\r\nif (tries >= count)\r\ngoto err;\r\ndata = CORE_RESET_BIT(cpu) | NEON_RESET_BIT(cpu) | \\r\nCORE_DEBUG_RESET_BIT(cpu);\r\nwritel_relaxed(data, sysctrl + SC_CPU_RESET_REQ(cluster));\r\nfor (tries = 0; tries < count; tries++) {\r\ncpu_relax();\r\ndata = readl_relaxed(sysctrl + SC_CPU_RESET_STATUS(cluster));\r\nif (data & CORE_RESET_STATUS(cpu))\r\nbreak;\r\n}\r\nif (tries >= count)\r\ngoto err;\r\nif (hip04_cluster_is_down(cluster))\r\nhip04_set_snoop_filter(cluster, 0);\r\nspin_unlock_irq(&boot_lock);\r\nreturn 1;\r\nerr:\r\nspin_unlock_irq(&boot_lock);\r\nreturn 0;\r\n}\r\nstatic bool __init hip04_cpu_table_init(void)\r\n{\r\nunsigned int mpidr, cpu, cluster;\r\nmpidr = read_cpuid_mpidr();\r\ncpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);\r\ncluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\nif (cluster >= HIP04_MAX_CLUSTERS ||\r\ncpu >= HIP04_MAX_CPUS_PER_CLUSTER) {\r\npr_err("%s: boot CPU is out of bound!\n", __func__);\r\nreturn false;\r\n}\r\nhip04_set_snoop_filter(cluster, 1);\r\nhip04_cpu_table[cluster][cpu] = 1;\r\nreturn true;\r\n}\r\nstatic int __init hip04_smp_init(void)\r\n{\r\nstruct device_node *np, *np_sctl, *np_fab;\r\nstruct resource fab_res;\r\nvoid __iomem *relocation;\r\nint ret = -ENODEV;\r\nnp = of_find_compatible_node(NULL, NULL, "hisilicon,hip04-bootwrapper");\r\nif (!np)\r\ngoto err;\r\nret = of_property_read_u32_array(np, "boot-method",\r\n&hip04_boot_method[0], 4);\r\nif (ret)\r\ngoto err;\r\nret = -ENODEV;\r\nnp_sctl = of_find_compatible_node(NULL, NULL, "hisilicon,sysctrl");\r\nif (!np_sctl)\r\ngoto err;\r\nnp_fab = of_find_compatible_node(NULL, NULL, "hisilicon,hip04-fabric");\r\nif (!np_fab)\r\ngoto err;\r\nret = memblock_reserve(hip04_boot_method[0], hip04_boot_method[1]);\r\nif (ret)\r\ngoto err;\r\nrelocation = ioremap(hip04_boot_method[2], hip04_boot_method[3]);\r\nif (!relocation) {\r\npr_err("failed to map relocation space\n");\r\nret = -ENOMEM;\r\ngoto err_reloc;\r\n}\r\nsysctrl = of_iomap(np_sctl, 0);\r\nif (!sysctrl) {\r\npr_err("failed to get sysctrl base\n");\r\nret = -ENOMEM;\r\ngoto err_sysctrl;\r\n}\r\nret = of_address_to_resource(np_fab, 0, &fab_res);\r\nif (ret) {\r\npr_err("failed to get fabric base phys\n");\r\ngoto err_fabric;\r\n}\r\nfabric_phys_addr = fab_res.start;\r\nsync_cache_w(&fabric_phys_addr);\r\nfabric = of_iomap(np_fab, 0);\r\nif (!fabric) {\r\npr_err("failed to get fabric base\n");\r\nret = -ENOMEM;\r\ngoto err_fabric;\r\n}\r\nif (!hip04_cpu_table_init()) {\r\nret = -EINVAL;\r\ngoto err_table;\r\n}\r\nwritel_relaxed(hip04_boot_method[0], relocation);\r\nwritel_relaxed(0xa5a5a5a5, relocation + 4);\r\nwritel_relaxed(__pa_symbol(secondary_startup), relocation + 8);\r\nwritel_relaxed(0, relocation + 12);\r\niounmap(relocation);\r\nsmp_set_ops(&hip04_smp_ops);\r\nreturn ret;\r\nerr_table:\r\niounmap(fabric);\r\nerr_fabric:\r\niounmap(sysctrl);\r\nerr_sysctrl:\r\niounmap(relocation);\r\nerr_reloc:\r\nmemblock_free(hip04_boot_method[0], hip04_boot_method[1]);\r\nerr:\r\nreturn ret;\r\n}
