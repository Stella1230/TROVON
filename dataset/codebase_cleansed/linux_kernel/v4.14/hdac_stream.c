void snd_hdac_stream_init(struct hdac_bus *bus, struct hdac_stream *azx_dev,\r\nint idx, int direction, int tag)\r\n{\r\nazx_dev->bus = bus;\r\nazx_dev->sd_addr = bus->remap_addr + (0x20 * idx + 0x80);\r\nazx_dev->sd_int_sta_mask = 1 << idx;\r\nazx_dev->index = idx;\r\nazx_dev->direction = direction;\r\nazx_dev->stream_tag = tag;\r\nsnd_hdac_dsp_lock_init(azx_dev);\r\nlist_add_tail(&azx_dev->list, &bus->stream_list);\r\n}\r\nvoid snd_hdac_stream_start(struct hdac_stream *azx_dev, bool fresh_start)\r\n{\r\nstruct hdac_bus *bus = azx_dev->bus;\r\ntrace_snd_hdac_stream_start(bus, azx_dev);\r\nazx_dev->start_wallclk = snd_hdac_chip_readl(bus, WALLCLK);\r\nif (!fresh_start)\r\nazx_dev->start_wallclk -= azx_dev->period_wallclk;\r\nsnd_hdac_chip_updatel(bus, INTCTL, 0, 1 << azx_dev->index);\r\nsnd_hdac_stream_updateb(azx_dev, SD_CTL,\r\n0, SD_CTL_DMA_START | SD_INT_MASK);\r\nazx_dev->running = true;\r\n}\r\nvoid snd_hdac_stream_clear(struct hdac_stream *azx_dev)\r\n{\r\nsnd_hdac_stream_updateb(azx_dev, SD_CTL,\r\nSD_CTL_DMA_START | SD_INT_MASK, 0);\r\nsnd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);\r\nazx_dev->running = false;\r\n}\r\nvoid snd_hdac_stream_stop(struct hdac_stream *azx_dev)\r\n{\r\ntrace_snd_hdac_stream_stop(azx_dev->bus, azx_dev);\r\nsnd_hdac_stream_clear(azx_dev);\r\nsnd_hdac_chip_updatel(azx_dev->bus, INTCTL, 1 << azx_dev->index, 0);\r\n}\r\nvoid snd_hdac_stream_reset(struct hdac_stream *azx_dev)\r\n{\r\nunsigned char val;\r\nint timeout;\r\nsnd_hdac_stream_clear(azx_dev);\r\nsnd_hdac_stream_updateb(azx_dev, SD_CTL, 0, SD_CTL_STREAM_RESET);\r\nudelay(3);\r\ntimeout = 300;\r\ndo {\r\nval = snd_hdac_stream_readb(azx_dev, SD_CTL) &\r\nSD_CTL_STREAM_RESET;\r\nif (val)\r\nbreak;\r\n} while (--timeout);\r\nval &= ~SD_CTL_STREAM_RESET;\r\nsnd_hdac_stream_writeb(azx_dev, SD_CTL, val);\r\nudelay(3);\r\ntimeout = 300;\r\ndo {\r\nval = snd_hdac_stream_readb(azx_dev, SD_CTL) &\r\nSD_CTL_STREAM_RESET;\r\nif (!val)\r\nbreak;\r\n} while (--timeout);\r\nif (azx_dev->posbuf)\r\n*azx_dev->posbuf = 0;\r\n}\r\nint snd_hdac_stream_setup(struct hdac_stream *azx_dev)\r\n{\r\nstruct hdac_bus *bus = azx_dev->bus;\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned int val;\r\nif (azx_dev->substream)\r\nruntime = azx_dev->substream->runtime;\r\nelse\r\nruntime = NULL;\r\nsnd_hdac_stream_clear(azx_dev);\r\nval = snd_hdac_stream_readl(azx_dev, SD_CTL);\r\nval = (val & ~SD_CTL_STREAM_TAG_MASK) |\r\n(azx_dev->stream_tag << SD_CTL_STREAM_TAG_SHIFT);\r\nif (!bus->snoop)\r\nval |= SD_CTL_TRAFFIC_PRIO;\r\nsnd_hdac_stream_writel(azx_dev, SD_CTL, val);\r\nsnd_hdac_stream_writel(azx_dev, SD_CBL, azx_dev->bufsize);\r\nsnd_hdac_stream_writew(azx_dev, SD_FORMAT, azx_dev->format_val);\r\nsnd_hdac_stream_writew(azx_dev, SD_LVI, azx_dev->frags - 1);\r\nsnd_hdac_stream_writel(azx_dev, SD_BDLPL, (u32)azx_dev->bdl.addr);\r\nsnd_hdac_stream_writel(azx_dev, SD_BDLPU,\r\nupper_32_bits(azx_dev->bdl.addr));\r\nif (bus->use_posbuf && bus->posbuf.addr) {\r\nif (!(snd_hdac_chip_readl(bus, DPLBASE) & AZX_DPLBASE_ENABLE))\r\nsnd_hdac_chip_writel(bus, DPLBASE,\r\n(u32)bus->posbuf.addr | AZX_DPLBASE_ENABLE);\r\n}\r\nsnd_hdac_stream_updatel(azx_dev, SD_CTL, 0, SD_INT_MASK);\r\nif (azx_dev->direction == SNDRV_PCM_STREAM_PLAYBACK)\r\nazx_dev->fifo_size =\r\nsnd_hdac_stream_readw(azx_dev, SD_FIFOSIZE) + 1;\r\nelse\r\nazx_dev->fifo_size = 0;\r\nif (runtime && runtime->period_size > 64)\r\nazx_dev->delay_negative_threshold =\r\n-frames_to_bytes(runtime, 64);\r\nelse\r\nazx_dev->delay_negative_threshold = 0;\r\nif (runtime)\r\nazx_dev->period_wallclk = (((runtime->period_size * 24000) /\r\nruntime->rate) * 1000);\r\nreturn 0;\r\n}\r\nvoid snd_hdac_stream_cleanup(struct hdac_stream *azx_dev)\r\n{\r\nsnd_hdac_stream_writel(azx_dev, SD_BDLPL, 0);\r\nsnd_hdac_stream_writel(azx_dev, SD_BDLPU, 0);\r\nsnd_hdac_stream_writel(azx_dev, SD_CTL, 0);\r\nazx_dev->bufsize = 0;\r\nazx_dev->period_bytes = 0;\r\nazx_dev->format_val = 0;\r\n}\r\nstruct hdac_stream *snd_hdac_stream_assign(struct hdac_bus *bus,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hdac_stream *azx_dev;\r\nstruct hdac_stream *res = NULL;\r\nint key = (substream->pcm->device << 16) | (substream->number << 2) |\r\n(substream->stream + 1);\r\nlist_for_each_entry(azx_dev, &bus->stream_list, list) {\r\nif (azx_dev->direction != substream->stream)\r\ncontinue;\r\nif (azx_dev->opened)\r\ncontinue;\r\nif (azx_dev->assigned_key == key) {\r\nres = azx_dev;\r\nbreak;\r\n}\r\nif (!res || bus->reverse_assign)\r\nres = azx_dev;\r\n}\r\nif (res) {\r\nspin_lock_irq(&bus->reg_lock);\r\nres->opened = 1;\r\nres->running = 0;\r\nres->assigned_key = key;\r\nres->substream = substream;\r\nspin_unlock_irq(&bus->reg_lock);\r\n}\r\nreturn res;\r\n}\r\nvoid snd_hdac_stream_release(struct hdac_stream *azx_dev)\r\n{\r\nstruct hdac_bus *bus = azx_dev->bus;\r\nspin_lock_irq(&bus->reg_lock);\r\nazx_dev->opened = 0;\r\nazx_dev->running = 0;\r\nazx_dev->substream = NULL;\r\nspin_unlock_irq(&bus->reg_lock);\r\n}\r\nstruct hdac_stream *snd_hdac_get_stream(struct hdac_bus *bus,\r\nint dir, int stream_tag)\r\n{\r\nstruct hdac_stream *s;\r\nlist_for_each_entry(s, &bus->stream_list, list) {\r\nif (s->direction == dir && s->stream_tag == stream_tag)\r\nreturn s;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int setup_bdle(struct hdac_bus *bus,\r\nstruct snd_dma_buffer *dmab,\r\nstruct hdac_stream *azx_dev, __le32 **bdlp,\r\nint ofs, int size, int with_ioc)\r\n{\r\n__le32 *bdl = *bdlp;\r\nwhile (size > 0) {\r\ndma_addr_t addr;\r\nint chunk;\r\nif (azx_dev->frags >= AZX_MAX_BDL_ENTRIES)\r\nreturn -EINVAL;\r\naddr = snd_sgbuf_get_addr(dmab, ofs);\r\nbdl[0] = cpu_to_le32((u32)addr);\r\nbdl[1] = cpu_to_le32(upper_32_bits(addr));\r\nchunk = snd_sgbuf_get_chunk_size(dmab, ofs, size);\r\nif (bus->align_bdle_4k) {\r\nu32 remain = 0x1000 - (ofs & 0xfff);\r\nif (chunk > remain)\r\nchunk = remain;\r\n}\r\nbdl[2] = cpu_to_le32(chunk);\r\nsize -= chunk;\r\nbdl[3] = (size || !with_ioc) ? 0 : cpu_to_le32(0x01);\r\nbdl += 4;\r\nazx_dev->frags++;\r\nofs += chunk;\r\n}\r\n*bdlp = bdl;\r\nreturn ofs;\r\n}\r\nint snd_hdac_stream_setup_periods(struct hdac_stream *azx_dev)\r\n{\r\nstruct hdac_bus *bus = azx_dev->bus;\r\nstruct snd_pcm_substream *substream = azx_dev->substream;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\n__le32 *bdl;\r\nint i, ofs, periods, period_bytes;\r\nint pos_adj, pos_align;\r\nsnd_hdac_stream_writel(azx_dev, SD_BDLPL, 0);\r\nsnd_hdac_stream_writel(azx_dev, SD_BDLPU, 0);\r\nperiod_bytes = azx_dev->period_bytes;\r\nperiods = azx_dev->bufsize / period_bytes;\r\nbdl = (__le32 *)azx_dev->bdl.area;\r\nofs = 0;\r\nazx_dev->frags = 0;\r\npos_adj = bus->bdl_pos_adj;\r\nif (!azx_dev->no_period_wakeup && pos_adj > 0) {\r\npos_align = pos_adj;\r\npos_adj = (pos_adj * runtime->rate + 47999) / 48000;\r\nif (!pos_adj)\r\npos_adj = pos_align;\r\nelse\r\npos_adj = ((pos_adj + pos_align - 1) / pos_align) *\r\npos_align;\r\npos_adj = frames_to_bytes(runtime, pos_adj);\r\nif (pos_adj >= period_bytes) {\r\ndev_warn(bus->dev, "Too big adjustment %d\n",\r\npos_adj);\r\npos_adj = 0;\r\n} else {\r\nofs = setup_bdle(bus, snd_pcm_get_dma_buf(substream),\r\nazx_dev,\r\n&bdl, ofs, pos_adj, true);\r\nif (ofs < 0)\r\ngoto error;\r\n}\r\n} else\r\npos_adj = 0;\r\nfor (i = 0; i < periods; i++) {\r\nif (i == periods - 1 && pos_adj)\r\nofs = setup_bdle(bus, snd_pcm_get_dma_buf(substream),\r\nazx_dev, &bdl, ofs,\r\nperiod_bytes - pos_adj, 0);\r\nelse\r\nofs = setup_bdle(bus, snd_pcm_get_dma_buf(substream),\r\nazx_dev, &bdl, ofs,\r\nperiod_bytes,\r\n!azx_dev->no_period_wakeup);\r\nif (ofs < 0)\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\ndev_err(bus->dev, "Too many BDL entries: buffer=%d, period=%d\n",\r\nazx_dev->bufsize, period_bytes);\r\nreturn -EINVAL;\r\n}\r\nint snd_hdac_stream_set_params(struct hdac_stream *azx_dev,\r\nunsigned int format_val)\r\n{\r\nunsigned int bufsize, period_bytes;\r\nstruct snd_pcm_substream *substream = azx_dev->substream;\r\nstruct snd_pcm_runtime *runtime;\r\nint err;\r\nif (!substream)\r\nreturn -EINVAL;\r\nruntime = substream->runtime;\r\nbufsize = snd_pcm_lib_buffer_bytes(substream);\r\nperiod_bytes = snd_pcm_lib_period_bytes(substream);\r\nif (bufsize != azx_dev->bufsize ||\r\nperiod_bytes != azx_dev->period_bytes ||\r\nformat_val != azx_dev->format_val ||\r\nruntime->no_period_wakeup != azx_dev->no_period_wakeup) {\r\nazx_dev->bufsize = bufsize;\r\nazx_dev->period_bytes = period_bytes;\r\nazx_dev->format_val = format_val;\r\nazx_dev->no_period_wakeup = runtime->no_period_wakeup;\r\nerr = snd_hdac_stream_setup_periods(azx_dev);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic u64 azx_cc_read(const struct cyclecounter *cc)\r\n{\r\nstruct hdac_stream *azx_dev = container_of(cc, struct hdac_stream, cc);\r\nreturn snd_hdac_chip_readl(azx_dev->bus, WALLCLK);\r\n}\r\nstatic void azx_timecounter_init(struct hdac_stream *azx_dev,\r\nbool force, u64 last)\r\n{\r\nstruct timecounter *tc = &azx_dev->tc;\r\nstruct cyclecounter *cc = &azx_dev->cc;\r\nu64 nsec;\r\ncc->read = azx_cc_read;\r\ncc->mask = CLOCKSOURCE_MASK(32);\r\ncc->mult = 125;\r\ncc->shift = 0;\r\nnsec = 0;\r\ntimecounter_init(tc, cc, nsec);\r\nif (force) {\r\ntc->cycle_last = last;\r\n}\r\n}\r\nvoid snd_hdac_stream_timecounter_init(struct hdac_stream *azx_dev,\r\nunsigned int streams)\r\n{\r\nstruct hdac_bus *bus = azx_dev->bus;\r\nstruct snd_pcm_runtime *runtime = azx_dev->substream->runtime;\r\nstruct hdac_stream *s;\r\nbool inited = false;\r\nu64 cycle_last = 0;\r\nint i = 0;\r\nlist_for_each_entry(s, &bus->stream_list, list) {\r\nif (streams & (1 << i)) {\r\nazx_timecounter_init(s, inited, cycle_last);\r\nif (!inited) {\r\ninited = true;\r\ncycle_last = s->tc.cycle_last;\r\n}\r\n}\r\ni++;\r\n}\r\nsnd_pcm_gettime(runtime, &runtime->trigger_tstamp);\r\nruntime->trigger_tstamp_latched = true;\r\n}\r\nvoid snd_hdac_stream_sync_trigger(struct hdac_stream *azx_dev, bool set,\r\nunsigned int streams, unsigned int reg)\r\n{\r\nstruct hdac_bus *bus = azx_dev->bus;\r\nunsigned int val;\r\nif (!reg)\r\nreg = AZX_REG_SSYNC;\r\nval = _snd_hdac_chip_readl(bus, reg);\r\nif (set)\r\nval |= streams;\r\nelse\r\nval &= ~streams;\r\n_snd_hdac_chip_writel(bus, reg, val);\r\n}\r\nvoid snd_hdac_stream_sync(struct hdac_stream *azx_dev, bool start,\r\nunsigned int streams)\r\n{\r\nstruct hdac_bus *bus = azx_dev->bus;\r\nint i, nwait, timeout;\r\nstruct hdac_stream *s;\r\nfor (timeout = 5000; timeout; timeout--) {\r\nnwait = 0;\r\ni = 0;\r\nlist_for_each_entry(s, &bus->stream_list, list) {\r\nif (streams & (1 << i)) {\r\nif (start) {\r\nif (!(snd_hdac_stream_readb(s, SD_STS) &\r\nSD_STS_FIFO_READY))\r\nnwait++;\r\n} else {\r\nif (snd_hdac_stream_readb(s, SD_CTL) &\r\nSD_CTL_DMA_START)\r\nnwait++;\r\n}\r\n}\r\ni++;\r\n}\r\nif (!nwait)\r\nbreak;\r\ncpu_relax();\r\n}\r\n}\r\nint snd_hdac_dsp_prepare(struct hdac_stream *azx_dev, unsigned int format,\r\nunsigned int byte_size, struct snd_dma_buffer *bufp)\r\n{\r\nstruct hdac_bus *bus = azx_dev->bus;\r\nu32 *bdl;\r\nint err;\r\nsnd_hdac_dsp_lock(azx_dev);\r\nspin_lock_irq(&bus->reg_lock);\r\nif (azx_dev->running || azx_dev->locked) {\r\nspin_unlock_irq(&bus->reg_lock);\r\nerr = -EBUSY;\r\ngoto unlock;\r\n}\r\nazx_dev->locked = true;\r\nspin_unlock_irq(&bus->reg_lock);\r\nerr = bus->io_ops->dma_alloc_pages(bus, SNDRV_DMA_TYPE_DEV_SG,\r\nbyte_size, bufp);\r\nif (err < 0)\r\ngoto err_alloc;\r\nazx_dev->substream = NULL;\r\nazx_dev->bufsize = byte_size;\r\nazx_dev->period_bytes = byte_size;\r\nazx_dev->format_val = format;\r\nsnd_hdac_stream_reset(azx_dev);\r\nsnd_hdac_stream_writel(azx_dev, SD_BDLPL, 0);\r\nsnd_hdac_stream_writel(azx_dev, SD_BDLPU, 0);\r\nazx_dev->frags = 0;\r\nbdl = (u32 *)azx_dev->bdl.area;\r\nerr = setup_bdle(bus, bufp, azx_dev, &bdl, 0, byte_size, 0);\r\nif (err < 0)\r\ngoto error;\r\nsnd_hdac_stream_setup(azx_dev);\r\nsnd_hdac_dsp_unlock(azx_dev);\r\nreturn azx_dev->stream_tag;\r\nerror:\r\nbus->io_ops->dma_free_pages(bus, bufp);\r\nerr_alloc:\r\nspin_lock_irq(&bus->reg_lock);\r\nazx_dev->locked = false;\r\nspin_unlock_irq(&bus->reg_lock);\r\nunlock:\r\nsnd_hdac_dsp_unlock(azx_dev);\r\nreturn err;\r\n}\r\nvoid snd_hdac_dsp_trigger(struct hdac_stream *azx_dev, bool start)\r\n{\r\nif (start)\r\nsnd_hdac_stream_start(azx_dev, true);\r\nelse\r\nsnd_hdac_stream_stop(azx_dev);\r\n}\r\nvoid snd_hdac_dsp_cleanup(struct hdac_stream *azx_dev,\r\nstruct snd_dma_buffer *dmab)\r\n{\r\nstruct hdac_bus *bus = azx_dev->bus;\r\nif (!dmab->area || !azx_dev->locked)\r\nreturn;\r\nsnd_hdac_dsp_lock(azx_dev);\r\nsnd_hdac_stream_writel(azx_dev, SD_BDLPL, 0);\r\nsnd_hdac_stream_writel(azx_dev, SD_BDLPU, 0);\r\nsnd_hdac_stream_writel(azx_dev, SD_CTL, 0);\r\nazx_dev->bufsize = 0;\r\nazx_dev->period_bytes = 0;\r\nazx_dev->format_val = 0;\r\nbus->io_ops->dma_free_pages(bus, dmab);\r\ndmab->area = NULL;\r\nspin_lock_irq(&bus->reg_lock);\r\nazx_dev->locked = false;\r\nspin_unlock_irq(&bus->reg_lock);\r\nsnd_hdac_dsp_unlock(azx_dev);\r\n}
