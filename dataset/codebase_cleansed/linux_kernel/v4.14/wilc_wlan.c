static inline void acquire_bus(struct wilc *wilc, BUS_ACQUIRE_T acquire)\r\n{\r\nmutex_lock(&wilc->hif_cs);\r\nif (acquire == ACQUIRE_AND_WAKEUP)\r\nchip_wakeup(wilc);\r\n}\r\nstatic inline void release_bus(struct wilc *wilc, BUS_RELEASE_T release)\r\n{\r\nif (release == RELEASE_ALLOW_SLEEP)\r\nchip_allow_sleep(wilc);\r\nmutex_unlock(&wilc->hif_cs);\r\n}\r\nstatic void wilc_wlan_txq_remove(struct wilc *wilc, struct txq_entry_t *tqe)\r\n{\r\nif (tqe == wilc->txq_head) {\r\nwilc->txq_head = tqe->next;\r\nif (wilc->txq_head)\r\nwilc->txq_head->prev = NULL;\r\n} else if (tqe == wilc->txq_tail) {\r\nwilc->txq_tail = (tqe->prev);\r\nif (wilc->txq_tail)\r\nwilc->txq_tail->next = NULL;\r\n} else {\r\ntqe->prev->next = tqe->next;\r\ntqe->next->prev = tqe->prev;\r\n}\r\nwilc->txq_entries -= 1;\r\n}\r\nstatic struct txq_entry_t *\r\nwilc_wlan_txq_remove_from_head(struct net_device *dev)\r\n{\r\nstruct txq_entry_t *tqe;\r\nunsigned long flags;\r\nstruct wilc_vif *vif;\r\nstruct wilc *wilc;\r\nvif = netdev_priv(dev);\r\nwilc = vif->wilc;\r\nspin_lock_irqsave(&wilc->txq_spinlock, flags);\r\nif (wilc->txq_head) {\r\ntqe = wilc->txq_head;\r\nwilc->txq_head = tqe->next;\r\nif (wilc->txq_head)\r\nwilc->txq_head->prev = NULL;\r\nwilc->txq_entries -= 1;\r\n} else {\r\ntqe = NULL;\r\n}\r\nspin_unlock_irqrestore(&wilc->txq_spinlock, flags);\r\nreturn tqe;\r\n}\r\nstatic void wilc_wlan_txq_add_to_tail(struct net_device *dev,\r\nstruct txq_entry_t *tqe)\r\n{\r\nunsigned long flags;\r\nstruct wilc_vif *vif;\r\nstruct wilc *wilc;\r\nvif = netdev_priv(dev);\r\nwilc = vif->wilc;\r\nspin_lock_irqsave(&wilc->txq_spinlock, flags);\r\nif (!wilc->txq_head) {\r\ntqe->next = NULL;\r\ntqe->prev = NULL;\r\nwilc->txq_head = tqe;\r\nwilc->txq_tail = tqe;\r\n} else {\r\ntqe->next = NULL;\r\ntqe->prev = wilc->txq_tail;\r\nwilc->txq_tail->next = tqe;\r\nwilc->txq_tail = tqe;\r\n}\r\nwilc->txq_entries += 1;\r\nspin_unlock_irqrestore(&wilc->txq_spinlock, flags);\r\ncomplete(&wilc->txq_event);\r\n}\r\nstatic int wilc_wlan_txq_add_to_head(struct wilc_vif *vif,\r\nstruct txq_entry_t *tqe)\r\n{\r\nunsigned long flags;\r\nstruct wilc *wilc = vif->wilc;\r\nmutex_lock(&wilc->txq_add_to_head_cs);\r\nspin_lock_irqsave(&wilc->txq_spinlock, flags);\r\nif (!wilc->txq_head) {\r\ntqe->next = NULL;\r\ntqe->prev = NULL;\r\nwilc->txq_head = tqe;\r\nwilc->txq_tail = tqe;\r\n} else {\r\ntqe->next = wilc->txq_head;\r\ntqe->prev = NULL;\r\nwilc->txq_head->prev = tqe;\r\nwilc->txq_head = tqe;\r\n}\r\nwilc->txq_entries += 1;\r\nspin_unlock_irqrestore(&wilc->txq_spinlock, flags);\r\nmutex_unlock(&wilc->txq_add_to_head_cs);\r\ncomplete(&wilc->txq_event);\r\nreturn 0;\r\n}\r\nstatic inline int add_tcp_session(u32 src_prt, u32 dst_prt, u32 seq)\r\n{\r\nif (tcp_session < 2 * MAX_TCP_SESSION) {\r\nack_session_info[tcp_session].seq_num = seq;\r\nack_session_info[tcp_session].bigger_ack_num = 0;\r\nack_session_info[tcp_session].src_port = src_prt;\r\nack_session_info[tcp_session].dst_port = dst_prt;\r\ntcp_session++;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int update_tcp_session(u32 index, u32 ack)\r\n{\r\nif (index < 2 * MAX_TCP_SESSION &&\r\nack > ack_session_info[index].bigger_ack_num)\r\nack_session_info[index].bigger_ack_num = ack;\r\nreturn 0;\r\n}\r\nstatic inline int add_tcp_pending_ack(u32 ack, u32 session_index,\r\nstruct txq_entry_t *txqe)\r\n{\r\nif (pending_base + pending_acks < MAX_PENDING_ACKS) {\r\npending_acks_info[pending_base + pending_acks].ack_num = ack;\r\npending_acks_info[pending_base + pending_acks].txqe = txqe;\r\npending_acks_info[pending_base + pending_acks].session_index = session_index;\r\ntxqe->tcp_pending_ack_idx = pending_base + pending_acks;\r\npending_acks++;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void tcp_process(struct net_device *dev, struct txq_entry_t *tqe)\r\n{\r\nu8 *eth_hdr_ptr;\r\nu8 *buffer = tqe->buffer;\r\nunsigned short h_proto;\r\nint i;\r\nunsigned long flags;\r\nstruct wilc_vif *vif;\r\nstruct wilc *wilc;\r\nvif = netdev_priv(dev);\r\nwilc = vif->wilc;\r\nspin_lock_irqsave(&wilc->txq_spinlock, flags);\r\neth_hdr_ptr = &buffer[0];\r\nh_proto = ntohs(*((unsigned short *)&eth_hdr_ptr[12]));\r\nif (h_proto == ETH_P_IP) {\r\nu8 *ip_hdr_ptr;\r\nu8 protocol;\r\nip_hdr_ptr = &buffer[ETHERNET_HDR_LEN];\r\nprotocol = ip_hdr_ptr[9];\r\nif (protocol == 0x06) {\r\nu8 *tcp_hdr_ptr;\r\nu32 IHL, total_length, data_offset;\r\ntcp_hdr_ptr = &ip_hdr_ptr[IP_HDR_LEN];\r\nIHL = (ip_hdr_ptr[0] & 0xf) << 2;\r\ntotal_length = ((u32)ip_hdr_ptr[2] << 8) +\r\n(u32)ip_hdr_ptr[3];\r\ndata_offset = ((u32)tcp_hdr_ptr[12] & 0xf0) >> 2;\r\nif (total_length == (IHL + data_offset)) {\r\nu32 seq_no, ack_no;\r\nseq_no = ((u32)tcp_hdr_ptr[4] << 24) +\r\n((u32)tcp_hdr_ptr[5] << 16) +\r\n((u32)tcp_hdr_ptr[6] << 8) +\r\n(u32)tcp_hdr_ptr[7];\r\nack_no = ((u32)tcp_hdr_ptr[8] << 24) +\r\n((u32)tcp_hdr_ptr[9] << 16) +\r\n((u32)tcp_hdr_ptr[10] << 8) +\r\n(u32)tcp_hdr_ptr[11];\r\nfor (i = 0; i < tcp_session; i++) {\r\nif (i < 2 * MAX_TCP_SESSION &&\r\nack_session_info[i].seq_num == seq_no) {\r\nupdate_tcp_session(i, ack_no);\r\nbreak;\r\n}\r\n}\r\nif (i == tcp_session)\r\nadd_tcp_session(0, 0, seq_no);\r\nadd_tcp_pending_ack(ack_no, i, tqe);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&wilc->txq_spinlock, flags);\r\n}\r\nstatic int wilc_wlan_txq_filter_dup_tcp_ack(struct net_device *dev)\r\n{\r\nstruct wilc_vif *vif;\r\nstruct wilc *wilc;\r\nu32 i = 0;\r\nu32 dropped = 0;\r\nvif = netdev_priv(dev);\r\nwilc = vif->wilc;\r\nspin_lock_irqsave(&wilc->txq_spinlock, wilc->txq_spinlock_flags);\r\nfor (i = pending_base; i < (pending_base + pending_acks); i++) {\r\nif (i >= MAX_PENDING_ACKS ||\r\npending_acks_info[i].session_index >= 2 * MAX_TCP_SESSION)\r\nbreak;\r\nif (pending_acks_info[i].ack_num < ack_session_info[pending_acks_info[i].session_index].bigger_ack_num) {\r\nstruct txq_entry_t *tqe;\r\ntqe = pending_acks_info[i].txqe;\r\nif (tqe) {\r\nwilc_wlan_txq_remove(wilc, tqe);\r\ntqe->status = 1;\r\nif (tqe->tx_complete_func)\r\ntqe->tx_complete_func(tqe->priv,\r\ntqe->status);\r\nkfree(tqe);\r\ndropped++;\r\n}\r\n}\r\n}\r\npending_acks = 0;\r\ntcp_session = 0;\r\nif (pending_base == 0)\r\npending_base = MAX_TCP_SESSION;\r\nelse\r\npending_base = 0;\r\nspin_unlock_irqrestore(&wilc->txq_spinlock, wilc->txq_spinlock_flags);\r\nwhile (dropped > 0) {\r\nwait_for_completion_timeout(&wilc->txq_event,\r\nmsecs_to_jiffies(1));\r\ndropped--;\r\n}\r\nreturn 1;\r\n}\r\nvoid wilc_enable_tcp_ack_filter(bool value)\r\n{\r\nenabled = value;\r\n}\r\nstatic int wilc_wlan_txq_add_cfg_pkt(struct wilc_vif *vif, u8 *buffer,\r\nu32 buffer_size)\r\n{\r\nstruct txq_entry_t *tqe;\r\nstruct wilc *wilc = vif->wilc;\r\nnetdev_dbg(vif->ndev, "Adding config packet ...\n");\r\nif (wilc->quit) {\r\nnetdev_dbg(vif->ndev, "Return due to clear function\n");\r\ncomplete(&wilc->cfg_event);\r\nreturn 0;\r\n}\r\ntqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);\r\nif (!tqe)\r\nreturn 0;\r\ntqe->type = WILC_CFG_PKT;\r\ntqe->buffer = buffer;\r\ntqe->buffer_size = buffer_size;\r\ntqe->tx_complete_func = NULL;\r\ntqe->priv = NULL;\r\ntqe->tcp_pending_ack_idx = NOT_TCP_ACK;\r\nif (wilc_wlan_txq_add_to_head(vif, tqe)) {\r\nkfree(tqe);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint wilc_wlan_txq_add_net_pkt(struct net_device *dev, void *priv, u8 *buffer,\r\nu32 buffer_size, wilc_tx_complete_func_t func)\r\n{\r\nstruct txq_entry_t *tqe;\r\nstruct wilc_vif *vif = netdev_priv(dev);\r\nstruct wilc *wilc;\r\nwilc = vif->wilc;\r\nif (wilc->quit)\r\nreturn 0;\r\ntqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);\r\nif (!tqe)\r\nreturn 0;\r\ntqe->type = WILC_NET_PKT;\r\ntqe->buffer = buffer;\r\ntqe->buffer_size = buffer_size;\r\ntqe->tx_complete_func = func;\r\ntqe->priv = priv;\r\ntqe->tcp_pending_ack_idx = NOT_TCP_ACK;\r\nif (enabled)\r\ntcp_process(dev, tqe);\r\nwilc_wlan_txq_add_to_tail(dev, tqe);\r\nreturn wilc->txq_entries;\r\n}\r\nint wilc_wlan_txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,\r\nu32 buffer_size, wilc_tx_complete_func_t func)\r\n{\r\nstruct txq_entry_t *tqe;\r\nstruct wilc_vif *vif = netdev_priv(dev);\r\nstruct wilc *wilc;\r\nwilc = vif->wilc;\r\nif (wilc->quit)\r\nreturn 0;\r\ntqe = kmalloc(sizeof(*tqe), GFP_KERNEL);\r\nif (!tqe)\r\nreturn 0;\r\ntqe->type = WILC_MGMT_PKT;\r\ntqe->buffer = buffer;\r\ntqe->buffer_size = buffer_size;\r\ntqe->tx_complete_func = func;\r\ntqe->priv = priv;\r\ntqe->tcp_pending_ack_idx = NOT_TCP_ACK;\r\nwilc_wlan_txq_add_to_tail(dev, tqe);\r\nreturn 1;\r\n}\r\nstatic struct txq_entry_t *wilc_wlan_txq_get_first(struct wilc *wilc)\r\n{\r\nstruct txq_entry_t *tqe;\r\nunsigned long flags;\r\nspin_lock_irqsave(&wilc->txq_spinlock, flags);\r\ntqe = wilc->txq_head;\r\nspin_unlock_irqrestore(&wilc->txq_spinlock, flags);\r\nreturn tqe;\r\n}\r\nstatic struct txq_entry_t *wilc_wlan_txq_get_next(struct wilc *wilc,\r\nstruct txq_entry_t *tqe)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wilc->txq_spinlock, flags);\r\ntqe = tqe->next;\r\nspin_unlock_irqrestore(&wilc->txq_spinlock, flags);\r\nreturn tqe;\r\n}\r\nstatic int wilc_wlan_rxq_add(struct wilc *wilc, struct rxq_entry_t *rqe)\r\n{\r\nif (wilc->quit)\r\nreturn 0;\r\nmutex_lock(&wilc->rxq_cs);\r\nif (!wilc->rxq_head) {\r\nrqe->next = NULL;\r\nwilc->rxq_head = rqe;\r\nwilc->rxq_tail = rqe;\r\n} else {\r\nwilc->rxq_tail->next = rqe;\r\nrqe->next = NULL;\r\nwilc->rxq_tail = rqe;\r\n}\r\nwilc->rxq_entries += 1;\r\nmutex_unlock(&wilc->rxq_cs);\r\nreturn wilc->rxq_entries;\r\n}\r\nstatic struct rxq_entry_t *wilc_wlan_rxq_remove(struct wilc *wilc)\r\n{\r\nif (wilc->rxq_head) {\r\nstruct rxq_entry_t *rqe;\r\nmutex_lock(&wilc->rxq_cs);\r\nrqe = wilc->rxq_head;\r\nwilc->rxq_head = wilc->rxq_head->next;\r\nwilc->rxq_entries -= 1;\r\nmutex_unlock(&wilc->rxq_cs);\r\nreturn rqe;\r\n}\r\nreturn NULL;\r\n}\r\nvoid chip_allow_sleep(struct wilc *wilc)\r\n{\r\nu32 reg = 0;\r\nwilc->hif_func->hif_read_reg(wilc, 0xf0, &reg);\r\nwilc->hif_func->hif_write_reg(wilc, 0xf0, reg & ~BIT(0));\r\nwilc->hif_func->hif_write_reg(wilc, 0xfa, 0);\r\n}\r\nvoid chip_wakeup(struct wilc *wilc)\r\n{\r\nu32 reg, clk_status_reg;\r\nif ((wilc->io_type & 0x1) == HIF_SPI) {\r\ndo {\r\nwilc->hif_func->hif_read_reg(wilc, 1, &reg);\r\nwilc->hif_func->hif_write_reg(wilc, 1, reg | BIT(1));\r\nwilc->hif_func->hif_write_reg(wilc, 1, reg & ~BIT(1));\r\ndo {\r\nusleep_range(2 * 1000, 2 * 1000);\r\nwilc_get_chipid(wilc, true);\r\n} while (wilc_get_chipid(wilc, true) == 0);\r\n} while (wilc_get_chipid(wilc, true) == 0);\r\n} else if ((wilc->io_type & 0x1) == HIF_SDIO) {\r\nwilc->hif_func->hif_write_reg(wilc, 0xfa, 1);\r\nudelay(200);\r\nwilc->hif_func->hif_read_reg(wilc, 0xf0, &reg);\r\ndo {\r\nwilc->hif_func->hif_write_reg(wilc, 0xf0,\r\nreg | BIT(0));\r\nwilc->hif_func->hif_read_reg(wilc, 0xf1,\r\n&clk_status_reg);\r\nwhile ((clk_status_reg & 0x1) == 0) {\r\nusleep_range(2 * 1000, 2 * 1000);\r\nwilc->hif_func->hif_read_reg(wilc, 0xf1,\r\n&clk_status_reg);\r\n}\r\nif ((clk_status_reg & 0x1) == 0) {\r\nwilc->hif_func->hif_write_reg(wilc, 0xf0,\r\nreg & (~BIT(0)));\r\n}\r\n} while ((clk_status_reg & 0x1) == 0);\r\n}\r\nif (chip_ps_state == CHIP_SLEEPING_MANUAL) {\r\nif (wilc_get_chipid(wilc, false) < 0x1002b0) {\r\nu32 val32;\r\nwilc->hif_func->hif_read_reg(wilc, 0x1e1c, &val32);\r\nval32 |= BIT(6);\r\nwilc->hif_func->hif_write_reg(wilc, 0x1e1c, val32);\r\nwilc->hif_func->hif_read_reg(wilc, 0x1e9c, &val32);\r\nval32 |= BIT(6);\r\nwilc->hif_func->hif_write_reg(wilc, 0x1e9c, val32);\r\n}\r\n}\r\nchip_ps_state = CHIP_WAKEDUP;\r\n}\r\nvoid wilc_chip_sleep_manually(struct wilc *wilc)\r\n{\r\nif (chip_ps_state != CHIP_WAKEDUP)\r\nreturn;\r\nacquire_bus(wilc, ACQUIRE_ONLY);\r\nchip_allow_sleep(wilc);\r\nwilc->hif_func->hif_write_reg(wilc, 0x10a8, 1);\r\nchip_ps_state = CHIP_SLEEPING_MANUAL;\r\nrelease_bus(wilc, RELEASE_ONLY);\r\n}\r\nvoid host_wakeup_notify(struct wilc *wilc)\r\n{\r\nacquire_bus(wilc, ACQUIRE_ONLY);\r\nwilc->hif_func->hif_write_reg(wilc, 0x10b0, 1);\r\nrelease_bus(wilc, RELEASE_ONLY);\r\n}\r\nvoid host_sleep_notify(struct wilc *wilc)\r\n{\r\nacquire_bus(wilc, ACQUIRE_ONLY);\r\nwilc->hif_func->hif_write_reg(wilc, 0x10ac, 1);\r\nrelease_bus(wilc, RELEASE_ONLY);\r\n}\r\nint wilc_wlan_handle_txq(struct net_device *dev, u32 *txq_count)\r\n{\r\nint i, entries = 0;\r\nu32 sum;\r\nu32 reg;\r\nu8 *txb;\r\nu32 offset = 0;\r\nint vmm_sz = 0;\r\nstruct txq_entry_t *tqe;\r\nint ret = 0;\r\nint counter;\r\nint timeout;\r\nu32 vmm_table[WILC_VMM_TBL_SIZE];\r\nstruct wilc_vif *vif;\r\nstruct wilc *wilc;\r\nvif = netdev_priv(dev);\r\nwilc = vif->wilc;\r\ntxb = wilc->tx_buffer;\r\nwilc->txq_exit = 0;\r\ndo {\r\nif (wilc->quit)\r\nbreak;\r\nmutex_lock(&wilc->txq_add_to_head_cs);\r\nwilc_wlan_txq_filter_dup_tcp_ack(dev);\r\ntqe = wilc_wlan_txq_get_first(wilc);\r\ni = 0;\r\nsum = 0;\r\ndo {\r\nif (tqe && (i < (WILC_VMM_TBL_SIZE - 1))) {\r\nif (tqe->type == WILC_CFG_PKT)\r\nvmm_sz = ETH_CONFIG_PKT_HDR_OFFSET;\r\nelse if (tqe->type == WILC_NET_PKT)\r\nvmm_sz = ETH_ETHERNET_HDR_OFFSET;\r\nelse\r\nvmm_sz = HOST_HDR_OFFSET;\r\nvmm_sz += tqe->buffer_size;\r\nif (vmm_sz & 0x3)\r\nvmm_sz = (vmm_sz + 4) & ~0x3;\r\nif ((sum + vmm_sz) > LINUX_TX_SIZE)\r\nbreak;\r\nvmm_table[i] = vmm_sz / 4;\r\nif (tqe->type == WILC_CFG_PKT)\r\nvmm_table[i] |= BIT(10);\r\nvmm_table[i] = cpu_to_le32(vmm_table[i]);\r\ni++;\r\nsum += vmm_sz;\r\ntqe = wilc_wlan_txq_get_next(wilc, tqe);\r\n} else {\r\nbreak;\r\n}\r\n} while (1);\r\nif (i == 0)\r\nbreak;\r\nvmm_table[i] = 0x0;\r\nacquire_bus(wilc, ACQUIRE_AND_WAKEUP);\r\ncounter = 0;\r\ndo {\r\nret = wilc->hif_func->hif_read_reg(wilc,\r\nWILC_HOST_TX_CTRL,\r\n&reg);\r\nif (!ret)\r\nbreak;\r\nif ((reg & 0x1) == 0)\r\nbreak;\r\ncounter++;\r\nif (counter > 200) {\r\ncounter = 0;\r\nret = wilc->hif_func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, 0);\r\nbreak;\r\n}\r\n} while (!wilc->quit);\r\nif (!ret)\r\ngoto _end_;\r\ntimeout = 200;\r\ndo {\r\nret = wilc->hif_func->hif_block_tx(wilc, WILC_VMM_TBL_RX_SHADOW_BASE, (u8 *)vmm_table, ((i + 1) * 4));\r\nif (!ret)\r\nbreak;\r\nret = wilc->hif_func->hif_write_reg(wilc,\r\nWILC_HOST_VMM_CTL,\r\n0x2);\r\nif (!ret)\r\nbreak;\r\ndo {\r\nret = wilc->hif_func->hif_read_reg(wilc, WILC_HOST_VMM_CTL, &reg);\r\nif (!ret)\r\nbreak;\r\nif ((reg >> 2) & 0x1) {\r\nentries = ((reg >> 3) & 0x3f);\r\nbreak;\r\n}\r\nrelease_bus(wilc, RELEASE_ALLOW_SLEEP);\r\n} while (--timeout);\r\nif (timeout <= 0) {\r\nret = wilc->hif_func->hif_write_reg(wilc, WILC_HOST_VMM_CTL, 0x0);\r\nbreak;\r\n}\r\nif (!ret)\r\nbreak;\r\nif (entries == 0) {\r\nret = wilc->hif_func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);\r\nif (!ret)\r\nbreak;\r\nreg &= ~BIT(0);\r\nret = wilc->hif_func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, reg);\r\nif (!ret)\r\nbreak;\r\nbreak;\r\n}\r\nbreak;\r\n} while (1);\r\nif (!ret)\r\ngoto _end_;\r\nif (entries == 0) {\r\nret = WILC_TX_ERR_NO_BUF;\r\ngoto _end_;\r\n}\r\nrelease_bus(wilc, RELEASE_ALLOW_SLEEP);\r\noffset = 0;\r\ni = 0;\r\ndo {\r\ntqe = wilc_wlan_txq_remove_from_head(dev);\r\nif (tqe && (vmm_table[i] != 0)) {\r\nu32 header, buffer_offset;\r\nvmm_table[i] = cpu_to_le32(vmm_table[i]);\r\nvmm_sz = (vmm_table[i] & 0x3ff);\r\nvmm_sz *= 4;\r\nheader = (tqe->type << 31) |\r\n(tqe->buffer_size << 15) |\r\nvmm_sz;\r\nif (tqe->type == WILC_MGMT_PKT)\r\nheader |= BIT(30);\r\nelse\r\nheader &= ~BIT(30);\r\nheader = cpu_to_le32(header);\r\nmemcpy(&txb[offset], &header, 4);\r\nif (tqe->type == WILC_CFG_PKT) {\r\nbuffer_offset = ETH_CONFIG_PKT_HDR_OFFSET;\r\n} else if (tqe->type == WILC_NET_PKT) {\r\nchar *bssid = ((struct tx_complete_data *)(tqe->priv))->bssid;\r\nbuffer_offset = ETH_ETHERNET_HDR_OFFSET;\r\nmemcpy(&txb[offset + 4], bssid, 6);\r\n} else {\r\nbuffer_offset = HOST_HDR_OFFSET;\r\n}\r\nmemcpy(&txb[offset + buffer_offset],\r\ntqe->buffer, tqe->buffer_size);\r\noffset += vmm_sz;\r\ni++;\r\ntqe->status = 1;\r\nif (tqe->tx_complete_func)\r\ntqe->tx_complete_func(tqe->priv,\r\ntqe->status);\r\nif (tqe->tcp_pending_ack_idx != NOT_TCP_ACK &&\r\ntqe->tcp_pending_ack_idx < MAX_PENDING_ACKS)\r\npending_acks_info[tqe->tcp_pending_ack_idx].txqe = NULL;\r\nkfree(tqe);\r\n} else {\r\nbreak;\r\n}\r\n} while (--entries);\r\nacquire_bus(wilc, ACQUIRE_AND_WAKEUP);\r\nret = wilc->hif_func->hif_clear_int_ext(wilc, ENABLE_TX_VMM);\r\nif (!ret)\r\ngoto _end_;\r\nret = wilc->hif_func->hif_block_tx_ext(wilc, 0, txb, offset);\r\nif (!ret)\r\ngoto _end_;\r\n_end_:\r\nrelease_bus(wilc, RELEASE_ALLOW_SLEEP);\r\nif (ret != 1)\r\nbreak;\r\n} while (0);\r\nmutex_unlock(&wilc->txq_add_to_head_cs);\r\nwilc->txq_exit = 1;\r\n*txq_count = wilc->txq_entries;\r\nreturn ret;\r\n}\r\nstatic void wilc_wlan_handle_rxq(struct wilc *wilc)\r\n{\r\nint offset = 0, size;\r\nu8 *buffer;\r\nstruct rxq_entry_t *rqe;\r\nwilc->rxq_exit = 0;\r\ndo {\r\nif (wilc->quit) {\r\ncomplete(&wilc->cfg_event);\r\nbreak;\r\n}\r\nrqe = wilc_wlan_rxq_remove(wilc);\r\nif (!rqe)\r\nbreak;\r\nbuffer = rqe->buffer;\r\nsize = rqe->buffer_size;\r\noffset = 0;\r\ndo {\r\nu32 header;\r\nu32 pkt_len, pkt_offset, tp_len;\r\nint is_cfg_packet;\r\nmemcpy(&header, &buffer[offset], 4);\r\nheader = cpu_to_le32(header);\r\nis_cfg_packet = (header >> 31) & 0x1;\r\npkt_offset = (header >> 22) & 0x1ff;\r\ntp_len = (header >> 11) & 0x7ff;\r\npkt_len = header & 0x7ff;\r\nif (pkt_len == 0 || tp_len == 0)\r\nbreak;\r\n#define IS_MANAGMEMENT 0x100\r\n#define IS_MANAGMEMENT_CALLBACK 0x080\r\n#define IS_MGMT_STATUS_SUCCES 0x040\r\nif (pkt_offset & IS_MANAGMEMENT) {\r\npkt_offset &= ~(IS_MANAGMEMENT |\r\nIS_MANAGMEMENT_CALLBACK |\r\nIS_MGMT_STATUS_SUCCES);\r\nWILC_WFI_mgmt_rx(wilc, &buffer[offset + HOST_HDR_OFFSET], pkt_len);\r\n} else {\r\nif (!is_cfg_packet) {\r\nif (pkt_len > 0) {\r\nwilc_frmw_to_linux(wilc,\r\n&buffer[offset],\r\npkt_len,\r\npkt_offset);\r\n}\r\n} else {\r\nstruct wilc_cfg_rsp rsp;\r\nwilc_wlan_cfg_indicate_rx(wilc, &buffer[pkt_offset + offset], pkt_len, &rsp);\r\nif (rsp.type == WILC_CFG_RSP) {\r\nif (wilc->cfg_seq_no == rsp.seq_no)\r\ncomplete(&wilc->cfg_event);\r\n} else if (rsp.type == WILC_CFG_RSP_STATUS) {\r\nwilc_mac_indicate(wilc, WILC_MAC_INDICATE_STATUS);\r\n} else if (rsp.type == WILC_CFG_RSP_SCAN) {\r\nwilc_mac_indicate(wilc, WILC_MAC_INDICATE_SCAN);\r\n}\r\n}\r\n}\r\noffset += tp_len;\r\nif (offset >= size)\r\nbreak;\r\n} while (1);\r\nkfree(rqe);\r\n} while (1);\r\nwilc->rxq_exit = 1;\r\n}\r\nstatic void wilc_unknown_isr_ext(struct wilc *wilc)\r\n{\r\nwilc->hif_func->hif_clear_int_ext(wilc, 0);\r\n}\r\nstatic void wilc_pllupdate_isr_ext(struct wilc *wilc, u32 int_stats)\r\n{\r\nint trials = 10;\r\nwilc->hif_func->hif_clear_int_ext(wilc, PLL_INT_CLR);\r\nif (wilc->io_type == HIF_SDIO)\r\nmdelay(WILC_PLL_TO_SDIO);\r\nelse\r\nmdelay(WILC_PLL_TO_SPI);\r\nwhile (!(ISWILC1000(wilc_get_chipid(wilc, true)) && --trials))\r\nmdelay(1);\r\n}\r\nstatic void wilc_sleeptimer_isr_ext(struct wilc *wilc, u32 int_stats1)\r\n{\r\nwilc->hif_func->hif_clear_int_ext(wilc, SLEEP_INT_CLR);\r\n}\r\nstatic void wilc_wlan_handle_isr_ext(struct wilc *wilc, u32 int_status)\r\n{\r\nu32 offset = wilc->rx_buffer_offset;\r\nu8 *buffer = NULL;\r\nu32 size;\r\nu32 retries = 0;\r\nint ret = 0;\r\nstruct rxq_entry_t *rqe;\r\nsize = (int_status & 0x7fff) << 2;\r\nwhile (!size && retries < 10) {\r\nwilc->hif_func->hif_read_size(wilc, &size);\r\nsize = (size & 0x7fff) << 2;\r\nretries++;\r\n}\r\nif (size > 0) {\r\nif (LINUX_RX_SIZE - offset < size)\r\noffset = 0;\r\nif (wilc->rx_buffer)\r\nbuffer = &wilc->rx_buffer[offset];\r\nelse\r\ngoto _end_;\r\nwilc->hif_func->hif_clear_int_ext(wilc,\r\nDATA_INT_CLR | ENABLE_RX_VMM);\r\nret = wilc->hif_func->hif_block_rx_ext(wilc, 0, buffer, size);\r\n_end_:\r\nif (ret) {\r\noffset += size;\r\nwilc->rx_buffer_offset = offset;\r\nrqe = kmalloc(sizeof(*rqe), GFP_KERNEL);\r\nif (rqe) {\r\nrqe->buffer = buffer;\r\nrqe->buffer_size = size;\r\nwilc_wlan_rxq_add(wilc, rqe);\r\n}\r\n}\r\n}\r\nwilc_wlan_handle_rxq(wilc);\r\n}\r\nvoid wilc_handle_isr(struct wilc *wilc)\r\n{\r\nu32 int_status;\r\nacquire_bus(wilc, ACQUIRE_AND_WAKEUP);\r\nwilc->hif_func->hif_read_int(wilc, &int_status);\r\nif (int_status & PLL_INT_EXT)\r\nwilc_pllupdate_isr_ext(wilc, int_status);\r\nif (int_status & DATA_INT_EXT)\r\nwilc_wlan_handle_isr_ext(wilc, int_status);\r\nif (int_status & SLEEP_INT_EXT)\r\nwilc_sleeptimer_isr_ext(wilc, int_status);\r\nif (!(int_status & (ALL_INT_EXT)))\r\nwilc_unknown_isr_ext(wilc);\r\nrelease_bus(wilc, RELEASE_ALLOW_SLEEP);\r\n}\r\nint wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,\r\nu32 buffer_size)\r\n{\r\nu32 offset;\r\nu32 addr, size, size2, blksz;\r\nu8 *dma_buffer;\r\nint ret = 0;\r\nblksz = BIT(12);\r\ndma_buffer = kmalloc(blksz, GFP_KERNEL);\r\nif (!dma_buffer)\r\nreturn -EIO;\r\noffset = 0;\r\ndo {\r\nmemcpy(&addr, &buffer[offset], 4);\r\nmemcpy(&size, &buffer[offset + 4], 4);\r\naddr = cpu_to_le32(addr);\r\nsize = cpu_to_le32(size);\r\nacquire_bus(wilc, ACQUIRE_ONLY);\r\noffset += 8;\r\nwhile (((int)size) && (offset < buffer_size)) {\r\nif (size <= blksz)\r\nsize2 = size;\r\nelse\r\nsize2 = blksz;\r\nmemcpy(dma_buffer, &buffer[offset], size2);\r\nret = wilc->hif_func->hif_block_tx(wilc, addr,\r\ndma_buffer, size2);\r\nif (!ret)\r\nbreak;\r\naddr += size2;\r\noffset += size2;\r\nsize -= size2;\r\n}\r\nrelease_bus(wilc, RELEASE_ONLY);\r\nif (!ret) {\r\nret = -EIO;\r\ngoto _fail_;\r\n}\r\n} while (offset < buffer_size);\r\n_fail_:\r\nkfree(dma_buffer);\r\nreturn (ret < 0) ? ret : 0;\r\n}\r\nint wilc_wlan_start(struct wilc *wilc)\r\n{\r\nu32 reg = 0;\r\nint ret;\r\nu32 chipid;\r\nif (wilc->io_type == HIF_SDIO) {\r\nreg = 0;\r\nreg |= BIT(3);\r\n} else if (wilc->io_type == HIF_SPI) {\r\nreg = 1;\r\n}\r\nacquire_bus(wilc, ACQUIRE_ONLY);\r\nret = wilc->hif_func->hif_write_reg(wilc, WILC_VMM_CORE_CFG, reg);\r\nif (!ret) {\r\nrelease_bus(wilc, RELEASE_ONLY);\r\nreturn -EIO;\r\n}\r\nreg = 0;\r\nif (wilc->io_type == HIF_SDIO && wilc->dev_irq_num)\r\nreg |= WILC_HAVE_SDIO_IRQ_GPIO;\r\n#ifdef WILC_DISABLE_PMU\r\n#else\r\nreg |= WILC_HAVE_USE_PMU;\r\n#endif\r\n#ifdef WILC_SLEEP_CLK_SRC_XO\r\nreg |= WILC_HAVE_SLEEP_CLK_SRC_XO;\r\n#elif defined WILC_SLEEP_CLK_SRC_RTC\r\nreg |= WILC_HAVE_SLEEP_CLK_SRC_RTC;\r\n#endif\r\n#ifdef WILC_EXT_PA_INV_TX_RX\r\nreg |= WILC_HAVE_EXT_PA_INV_TX_RX;\r\n#endif\r\nreg |= WILC_HAVE_USE_IRQ_AS_HOST_WAKE;\r\nreg |= WILC_HAVE_LEGACY_RF_SETTINGS;\r\n#ifdef XTAL_24\r\nreg |= WILC_HAVE_XTAL_24;\r\n#endif\r\n#ifdef DISABLE_WILC_UART\r\nreg |= WILC_HAVE_DISABLE_WILC_UART;\r\n#endif\r\nret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_1, reg);\r\nif (!ret) {\r\nrelease_bus(wilc, RELEASE_ONLY);\r\nreturn -EIO;\r\n}\r\nwilc->hif_func->hif_sync_ext(wilc, NUM_INT_EXT);\r\nret = wilc->hif_func->hif_read_reg(wilc, 0x1000, &chipid);\r\nif (!ret) {\r\nrelease_bus(wilc, RELEASE_ONLY);\r\nreturn -EIO;\r\n}\r\nwilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);\r\nif ((reg & BIT(10)) == BIT(10)) {\r\nreg &= ~BIT(10);\r\nwilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);\r\nwilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);\r\n}\r\nreg |= BIT(10);\r\nret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);\r\nwilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);\r\nrelease_bus(wilc, RELEASE_ONLY);\r\nreturn (ret < 0) ? ret : 0;\r\n}\r\nint wilc_wlan_stop(struct wilc *wilc)\r\n{\r\nu32 reg = 0;\r\nint ret;\r\nu8 timeout = 10;\r\nacquire_bus(wilc, ACQUIRE_AND_WAKEUP);\r\nret = wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);\r\nif (!ret) {\r\nrelease_bus(wilc, RELEASE_ALLOW_SLEEP);\r\nreturn ret;\r\n}\r\nreg &= ~BIT(10);\r\nret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);\r\nif (!ret) {\r\nrelease_bus(wilc, RELEASE_ALLOW_SLEEP);\r\nreturn ret;\r\n}\r\ndo {\r\nret = wilc->hif_func->hif_read_reg(wilc,\r\nWILC_GLB_RESET_0, &reg);\r\nif (!ret) {\r\nrelease_bus(wilc, RELEASE_ALLOW_SLEEP);\r\nreturn ret;\r\n}\r\nif ((reg & BIT(10))) {\r\nreg &= ~BIT(10);\r\nret = wilc->hif_func->hif_write_reg(wilc,\r\nWILC_GLB_RESET_0,\r\nreg);\r\ntimeout--;\r\n} else {\r\nret = wilc->hif_func->hif_read_reg(wilc,\r\nWILC_GLB_RESET_0,\r\n&reg);\r\nif (!ret) {\r\nrelease_bus(wilc, RELEASE_ALLOW_SLEEP);\r\nreturn ret;\r\n}\r\nbreak;\r\n}\r\n} while (timeout);\r\nreg = (BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(8) | BIT(9) | BIT(26) |\r\nBIT(29) | BIT(30) | BIT(31));\r\nwilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);\r\nreg = (u32)~BIT(10);\r\nret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);\r\nrelease_bus(wilc, RELEASE_ALLOW_SLEEP);\r\nreturn ret;\r\n}\r\nvoid wilc_wlan_cleanup(struct net_device *dev)\r\n{\r\nstruct txq_entry_t *tqe;\r\nstruct rxq_entry_t *rqe;\r\nu32 reg = 0;\r\nint ret;\r\nstruct wilc_vif *vif;\r\nstruct wilc *wilc;\r\nvif = netdev_priv(dev);\r\nwilc = vif->wilc;\r\nwilc->quit = 1;\r\ndo {\r\ntqe = wilc_wlan_txq_remove_from_head(dev);\r\nif (!tqe)\r\nbreak;\r\nif (tqe->tx_complete_func)\r\ntqe->tx_complete_func(tqe->priv, 0);\r\nkfree(tqe);\r\n} while (1);\r\ndo {\r\nrqe = wilc_wlan_rxq_remove(wilc);\r\nif (!rqe)\r\nbreak;\r\nkfree(rqe);\r\n} while (1);\r\nkfree(wilc->rx_buffer);\r\nwilc->rx_buffer = NULL;\r\nkfree(wilc->tx_buffer);\r\nwilc->tx_buffer = NULL;\r\nacquire_bus(wilc, ACQUIRE_AND_WAKEUP);\r\nret = wilc->hif_func->hif_read_reg(wilc, WILC_GP_REG_0, &reg);\r\nif (!ret)\r\nrelease_bus(wilc, RELEASE_ALLOW_SLEEP);\r\nret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_0,\r\n(reg | ABORT_INT));\r\nif (!ret)\r\nrelease_bus(wilc, RELEASE_ALLOW_SLEEP);\r\nrelease_bus(wilc, RELEASE_ALLOW_SLEEP);\r\nwilc->hif_func->hif_deinit(NULL);\r\n}\r\nstatic int wilc_wlan_cfg_commit(struct wilc_vif *vif, int type,\r\nu32 drv_handler)\r\n{\r\nstruct wilc *wilc = vif->wilc;\r\nstruct wilc_cfg_frame *cfg = &wilc->cfg_frame;\r\nint total_len = wilc->cfg_frame_offset + 4 + DRIVER_HANDLER_SIZE;\r\nint seq_no = wilc->cfg_seq_no % 256;\r\nint driver_handler = (u32)drv_handler;\r\nif (type == WILC_CFG_SET)\r\ncfg->wid_header[0] = 'W';\r\nelse\r\ncfg->wid_header[0] = 'Q';\r\ncfg->wid_header[1] = seq_no;\r\ncfg->wid_header[2] = (u8)total_len;\r\ncfg->wid_header[3] = (u8)(total_len >> 8);\r\ncfg->wid_header[4] = (u8)driver_handler;\r\ncfg->wid_header[5] = (u8)(driver_handler >> 8);\r\ncfg->wid_header[6] = (u8)(driver_handler >> 16);\r\ncfg->wid_header[7] = (u8)(driver_handler >> 24);\r\nwilc->cfg_seq_no = seq_no;\r\nif (!wilc_wlan_txq_add_cfg_pkt(vif, &cfg->wid_header[0], total_len))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint wilc_wlan_cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,\r\nu32 buffer_size, int commit, u32 drv_handler)\r\n{\r\nu32 offset;\r\nint ret_size;\r\nstruct wilc *wilc = vif->wilc;\r\nif (wilc->cfg_frame_in_use)\r\nreturn 0;\r\nif (start)\r\nwilc->cfg_frame_offset = 0;\r\noffset = wilc->cfg_frame_offset;\r\nret_size = wilc_wlan_cfg_set_wid(wilc->cfg_frame.frame, offset,\r\nwid, buffer, buffer_size);\r\noffset += ret_size;\r\nwilc->cfg_frame_offset = offset;\r\nif (commit) {\r\nnetdev_dbg(vif->ndev,\r\n"[WILC]PACKET Commit with sequence number %d\n",\r\nwilc->cfg_seq_no);\r\nnetdev_dbg(vif->ndev, "Processing cfg_set()\n");\r\nwilc->cfg_frame_in_use = 1;\r\nif (wilc_wlan_cfg_commit(vif, WILC_CFG_SET, drv_handler))\r\nret_size = 0;\r\nif (!wait_for_completion_timeout(&wilc->cfg_event,\r\nmsecs_to_jiffies(CFG_PKTS_TIMEOUT))) {\r\nnetdev_dbg(vif->ndev, "Set Timed Out\n");\r\nret_size = 0;\r\n}\r\nwilc->cfg_frame_in_use = 0;\r\nwilc->cfg_frame_offset = 0;\r\nwilc->cfg_seq_no += 1;\r\n}\r\nreturn ret_size;\r\n}\r\nint wilc_wlan_cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,\r\nu32 drv_handler)\r\n{\r\nu32 offset;\r\nint ret_size;\r\nstruct wilc *wilc = vif->wilc;\r\nif (wilc->cfg_frame_in_use)\r\nreturn 0;\r\nif (start)\r\nwilc->cfg_frame_offset = 0;\r\noffset = wilc->cfg_frame_offset;\r\nret_size = wilc_wlan_cfg_get_wid(wilc->cfg_frame.frame, offset, wid);\r\noffset += ret_size;\r\nwilc->cfg_frame_offset = offset;\r\nif (commit) {\r\nwilc->cfg_frame_in_use = 1;\r\nif (wilc_wlan_cfg_commit(vif, WILC_CFG_QUERY, drv_handler))\r\nret_size = 0;\r\nif (!wait_for_completion_timeout(&wilc->cfg_event,\r\nmsecs_to_jiffies(CFG_PKTS_TIMEOUT))) {\r\nnetdev_dbg(vif->ndev, "Get Timed Out\n");\r\nret_size = 0;\r\n}\r\nwilc->cfg_frame_in_use = 0;\r\nwilc->cfg_frame_offset = 0;\r\nwilc->cfg_seq_no += 1;\r\n}\r\nreturn ret_size;\r\n}\r\nint wilc_wlan_cfg_get_val(u16 wid, u8 *buffer, u32 buffer_size)\r\n{\r\nreturn wilc_wlan_cfg_get_wid_value(wid, buffer, buffer_size);\r\n}\r\nint wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,\r\nu32 count, u32 drv)\r\n{\r\nint i;\r\nint ret = 0;\r\nif (mode == GET_CFG) {\r\nfor (i = 0; i < count; i++) {\r\nif (!wilc_wlan_cfg_get(vif, !i,\r\nwids[i].id,\r\n(i == count - 1),\r\ndrv)) {\r\nret = -ETIMEDOUT;\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < count; i++) {\r\nwids[i].size = wilc_wlan_cfg_get_val(wids[i].id,\r\nwids[i].val,\r\nwids[i].size);\r\n}\r\n} else if (mode == SET_CFG) {\r\nfor (i = 0; i < count; i++) {\r\nif (!wilc_wlan_cfg_set(vif, !i,\r\nwids[i].id,\r\nwids[i].val,\r\nwids[i].size,\r\n(i == count - 1),\r\ndrv)) {\r\nret = -ETIMEDOUT;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic u32 init_chip(struct net_device *dev)\r\n{\r\nu32 chipid;\r\nu32 reg, ret = 0;\r\nstruct wilc_vif *vif;\r\nstruct wilc *wilc;\r\nvif = netdev_priv(dev);\r\nwilc = vif->wilc;\r\nacquire_bus(wilc, ACQUIRE_ONLY);\r\nchipid = wilc_get_chipid(wilc, true);\r\nif ((chipid & 0xfff) != 0xa0) {\r\nret = wilc->hif_func->hif_read_reg(wilc, 0x1118, &reg);\r\nif (!ret) {\r\nnetdev_err(dev, "fail read reg 0x1118\n");\r\nreturn ret;\r\n}\r\nreg |= BIT(0);\r\nret = wilc->hif_func->hif_write_reg(wilc, 0x1118, reg);\r\nif (!ret) {\r\nnetdev_err(dev, "fail write reg 0x1118\n");\r\nreturn ret;\r\n}\r\nret = wilc->hif_func->hif_write_reg(wilc, 0xc0000, 0x71);\r\nif (!ret) {\r\nnetdev_err(dev, "fail write reg 0xc0000\n");\r\nreturn ret;\r\n}\r\n}\r\nrelease_bus(wilc, RELEASE_ONLY);\r\nreturn ret;\r\n}\r\nu32 wilc_get_chipid(struct wilc *wilc, bool update)\r\n{\r\nstatic u32 chipid;\r\nu32 tempchipid = 0;\r\nu32 rfrevid = 0;\r\nif (chipid == 0 || update) {\r\nwilc->hif_func->hif_read_reg(wilc, 0x1000, &tempchipid);\r\nwilc->hif_func->hif_read_reg(wilc, 0x13f4, &rfrevid);\r\nif (!ISWILC1000(tempchipid)) {\r\nchipid = 0;\r\nreturn chipid;\r\n}\r\nif (tempchipid == 0x1002a0) {\r\nif (rfrevid != 0x1)\r\ntempchipid = 0x1002a1;\r\n} else if (tempchipid == 0x1002b0) {\r\nif (rfrevid == 0x4)\r\ntempchipid = 0x1002b1;\r\nelse if (rfrevid != 0x3)\r\ntempchipid = 0x1002b2;\r\n}\r\nchipid = tempchipid;\r\n}\r\nreturn chipid;\r\n}\r\nint wilc_wlan_init(struct net_device *dev)\r\n{\r\nint ret = 0;\r\nstruct wilc_vif *vif = netdev_priv(dev);\r\nstruct wilc *wilc;\r\nwilc = vif->wilc;\r\nwilc->quit = 0;\r\nif (!wilc->hif_func->hif_init(wilc, false)) {\r\nret = -EIO;\r\ngoto _fail_;\r\n}\r\nif (!wilc_wlan_cfg_init()) {\r\nret = -ENOBUFS;\r\ngoto _fail_;\r\n}\r\nif (!wilc->tx_buffer)\r\nwilc->tx_buffer = kmalloc(LINUX_TX_SIZE, GFP_KERNEL);\r\nif (!wilc->tx_buffer) {\r\nret = -ENOBUFS;\r\ngoto _fail_;\r\n}\r\nif (!wilc->rx_buffer)\r\nwilc->rx_buffer = kmalloc(LINUX_RX_SIZE, GFP_KERNEL);\r\nif (!wilc->rx_buffer) {\r\nret = -ENOBUFS;\r\ngoto _fail_;\r\n}\r\nif (!init_chip(dev)) {\r\nret = -EIO;\r\ngoto _fail_;\r\n}\r\nreturn 1;\r\n_fail_:\r\nkfree(wilc->rx_buffer);\r\nwilc->rx_buffer = NULL;\r\nkfree(wilc->tx_buffer);\r\nwilc->tx_buffer = NULL;\r\nreturn ret;\r\n}
