void ext4_fsmap_from_internal(struct super_block *sb, struct fsmap *dest,\r\nstruct ext4_fsmap *src)\r\n{\r\ndest->fmr_device = src->fmr_device;\r\ndest->fmr_flags = src->fmr_flags;\r\ndest->fmr_physical = src->fmr_physical << sb->s_blocksize_bits;\r\ndest->fmr_owner = src->fmr_owner;\r\ndest->fmr_offset = 0;\r\ndest->fmr_length = src->fmr_length << sb->s_blocksize_bits;\r\ndest->fmr_reserved[0] = 0;\r\ndest->fmr_reserved[1] = 0;\r\ndest->fmr_reserved[2] = 0;\r\n}\r\nvoid ext4_fsmap_to_internal(struct super_block *sb, struct ext4_fsmap *dest,\r\nstruct fsmap *src)\r\n{\r\ndest->fmr_device = src->fmr_device;\r\ndest->fmr_flags = src->fmr_flags;\r\ndest->fmr_physical = src->fmr_physical >> sb->s_blocksize_bits;\r\ndest->fmr_owner = src->fmr_owner;\r\ndest->fmr_length = src->fmr_length >> sb->s_blocksize_bits;\r\n}\r\nstatic int ext4_getfsmap_dev_compare(const void *p1, const void *p2)\r\n{\r\nconst struct ext4_getfsmap_dev *d1 = p1;\r\nconst struct ext4_getfsmap_dev *d2 = p2;\r\nreturn d1->gfd_dev - d2->gfd_dev;\r\n}\r\nstatic bool ext4_getfsmap_rec_before_low_key(struct ext4_getfsmap_info *info,\r\nstruct ext4_fsmap *rec)\r\n{\r\nreturn rec->fmr_physical < info->gfi_low.fmr_physical;\r\n}\r\nstatic int ext4_getfsmap_helper(struct super_block *sb,\r\nstruct ext4_getfsmap_info *info,\r\nstruct ext4_fsmap *rec)\r\n{\r\nstruct ext4_fsmap fmr;\r\nstruct ext4_sb_info *sbi = EXT4_SB(sb);\r\next4_fsblk_t rec_fsblk = rec->fmr_physical;\r\next4_group_t agno;\r\next4_grpblk_t cno;\r\nint error;\r\nif (fatal_signal_pending(current))\r\nreturn -EINTR;\r\nif (ext4_getfsmap_rec_before_low_key(info, rec)) {\r\nrec_fsblk += rec->fmr_length;\r\nif (info->gfi_next_fsblk < rec_fsblk)\r\ninfo->gfi_next_fsblk = rec_fsblk;\r\nreturn EXT4_QUERY_RANGE_CONTINUE;\r\n}\r\nif (info->gfi_head->fmh_count == 0) {\r\nif (rec_fsblk > info->gfi_next_fsblk)\r\ninfo->gfi_head->fmh_entries++;\r\nif (info->gfi_last)\r\nreturn EXT4_QUERY_RANGE_CONTINUE;\r\ninfo->gfi_head->fmh_entries++;\r\nrec_fsblk += rec->fmr_length;\r\nif (info->gfi_next_fsblk < rec_fsblk)\r\ninfo->gfi_next_fsblk = rec_fsblk;\r\nreturn EXT4_QUERY_RANGE_CONTINUE;\r\n}\r\nif (rec_fsblk > info->gfi_next_fsblk) {\r\nif (info->gfi_head->fmh_entries >= info->gfi_head->fmh_count)\r\nreturn EXT4_QUERY_RANGE_ABORT;\r\next4_get_group_no_and_offset(sb, info->gfi_next_fsblk,\r\n&agno, &cno);\r\ntrace_ext4_fsmap_mapping(sb, info->gfi_dev, agno,\r\nEXT4_C2B(sbi, cno),\r\nrec_fsblk - info->gfi_next_fsblk,\r\nEXT4_FMR_OWN_UNKNOWN);\r\nfmr.fmr_device = info->gfi_dev;\r\nfmr.fmr_physical = info->gfi_next_fsblk;\r\nfmr.fmr_owner = EXT4_FMR_OWN_UNKNOWN;\r\nfmr.fmr_length = rec_fsblk - info->gfi_next_fsblk;\r\nfmr.fmr_flags = FMR_OF_SPECIAL_OWNER;\r\nerror = info->gfi_formatter(&fmr, info->gfi_format_arg);\r\nif (error)\r\nreturn error;\r\ninfo->gfi_head->fmh_entries++;\r\n}\r\nif (info->gfi_last)\r\ngoto out;\r\nif (info->gfi_head->fmh_entries >= info->gfi_head->fmh_count)\r\nreturn EXT4_QUERY_RANGE_ABORT;\r\next4_get_group_no_and_offset(sb, rec_fsblk, &agno, &cno);\r\ntrace_ext4_fsmap_mapping(sb, info->gfi_dev, agno, EXT4_C2B(sbi, cno),\r\nrec->fmr_length, rec->fmr_owner);\r\nfmr.fmr_device = info->gfi_dev;\r\nfmr.fmr_physical = rec_fsblk;\r\nfmr.fmr_owner = rec->fmr_owner;\r\nfmr.fmr_flags = FMR_OF_SPECIAL_OWNER;\r\nfmr.fmr_length = rec->fmr_length;\r\nerror = info->gfi_formatter(&fmr, info->gfi_format_arg);\r\nif (error)\r\nreturn error;\r\ninfo->gfi_head->fmh_entries++;\r\nout:\r\nrec_fsblk += rec->fmr_length;\r\nif (info->gfi_next_fsblk < rec_fsblk)\r\ninfo->gfi_next_fsblk = rec_fsblk;\r\nreturn EXT4_QUERY_RANGE_CONTINUE;\r\n}\r\nstatic inline ext4_fsblk_t ext4_fsmap_next_pblk(struct ext4_fsmap *fmr)\r\n{\r\nreturn fmr->fmr_physical + fmr->fmr_length;\r\n}\r\nstatic int ext4_getfsmap_datadev_helper(struct super_block *sb,\r\next4_group_t agno, ext4_grpblk_t start,\r\next4_grpblk_t len, void *priv)\r\n{\r\nstruct ext4_fsmap irec;\r\nstruct ext4_getfsmap_info *info = priv;\r\nstruct ext4_fsmap *p;\r\nstruct ext4_fsmap *tmp;\r\nstruct ext4_sb_info *sbi = EXT4_SB(sb);\r\next4_fsblk_t fsb;\r\next4_fsblk_t fslen;\r\nint error;\r\nfsb = (EXT4_C2B(sbi, start) + ext4_group_first_block_no(sb, agno));\r\nfslen = EXT4_C2B(sbi, len);\r\nif (info->gfi_lastfree.fmr_owner) {\r\nif (ext4_fsmap_next_pblk(&info->gfi_lastfree) == fsb) {\r\ninfo->gfi_lastfree.fmr_length += fslen;\r\nreturn 0;\r\n}\r\nerror = ext4_getfsmap_helper(sb, info, &info->gfi_lastfree);\r\nif (error)\r\nreturn error;\r\ninfo->gfi_lastfree.fmr_owner = 0;\r\n}\r\nlist_for_each_entry_safe(p, tmp, &info->gfi_meta_list, fmr_list) {\r\nif (p->fmr_physical + p->fmr_length <= info->gfi_next_fsblk) {\r\nlist_del(&p->fmr_list);\r\nkfree(p);\r\n} else if (p->fmr_physical < fsb) {\r\nerror = ext4_getfsmap_helper(sb, info, p);\r\nif (error)\r\nreturn error;\r\nlist_del(&p->fmr_list);\r\nkfree(p);\r\n}\r\n}\r\nirec.fmr_device = 0;\r\nirec.fmr_physical = fsb;\r\nirec.fmr_length = fslen;\r\nirec.fmr_owner = EXT4_FMR_OWN_FREE;\r\nirec.fmr_flags = 0;\r\nif (ext4_fsmap_next_pblk(&irec) ==\r\next4_group_first_block_no(sb, agno + 1)) {\r\ninfo->gfi_lastfree = irec;\r\nreturn 0;\r\n}\r\nreturn ext4_getfsmap_helper(sb, info, &irec);\r\n}\r\nstatic int ext4_getfsmap_logdev(struct super_block *sb, struct ext4_fsmap *keys,\r\nstruct ext4_getfsmap_info *info)\r\n{\r\njournal_t *journal = EXT4_SB(sb)->s_journal;\r\nstruct ext4_fsmap irec;\r\ninfo->gfi_low = keys[0];\r\ninfo->gfi_low.fmr_length = 0;\r\nmemset(&info->gfi_high, 0xFF, sizeof(info->gfi_high));\r\ntrace_ext4_fsmap_low_key(sb, info->gfi_dev, 0,\r\ninfo->gfi_low.fmr_physical,\r\ninfo->gfi_low.fmr_length,\r\ninfo->gfi_low.fmr_owner);\r\ntrace_ext4_fsmap_high_key(sb, info->gfi_dev, 0,\r\ninfo->gfi_high.fmr_physical,\r\ninfo->gfi_high.fmr_length,\r\ninfo->gfi_high.fmr_owner);\r\nif (keys[0].fmr_physical > 0)\r\nreturn 0;\r\nirec.fmr_physical = journal->j_blk_offset;\r\nirec.fmr_length = journal->j_maxlen;\r\nirec.fmr_owner = EXT4_FMR_OWN_LOG;\r\nirec.fmr_flags = 0;\r\nreturn ext4_getfsmap_helper(sb, info, &irec);\r\n}\r\nstatic inline int ext4_getfsmap_fill(struct list_head *meta_list,\r\next4_fsblk_t fsb, ext4_fsblk_t len,\r\nuint64_t owner)\r\n{\r\nstruct ext4_fsmap *fsm;\r\nfsm = kmalloc(sizeof(*fsm), GFP_NOFS);\r\nif (!fsm)\r\nreturn -ENOMEM;\r\nfsm->fmr_device = 0;\r\nfsm->fmr_flags = 0;\r\nfsm->fmr_physical = fsb;\r\nfsm->fmr_owner = owner;\r\nfsm->fmr_length = len;\r\nlist_add_tail(&fsm->fmr_list, meta_list);\r\nreturn 0;\r\n}\r\nstatic unsigned int ext4_getfsmap_find_sb(struct super_block *sb,\r\next4_group_t agno,\r\nstruct list_head *meta_list)\r\n{\r\nstruct ext4_sb_info *sbi = EXT4_SB(sb);\r\next4_fsblk_t fsb = ext4_group_first_block_no(sb, agno);\r\next4_fsblk_t len;\r\nunsigned long first_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\r\nunsigned long metagroup = agno / EXT4_DESC_PER_BLOCK(sb);\r\nint error;\r\nif (ext4_bg_has_super(sb, agno)) {\r\nerror = ext4_getfsmap_fill(meta_list, fsb, 1, EXT4_FMR_OWN_FS);\r\nif (error)\r\nreturn error;\r\nfsb++;\r\n}\r\nlen = ext4_bg_num_gdb(sb, agno);\r\nif (!len)\r\nreturn 0;\r\nerror = ext4_getfsmap_fill(meta_list, fsb, len,\r\nEXT4_FMR_OWN_GDT);\r\nif (error)\r\nreturn error;\r\nfsb += len;\r\nif (!ext4_has_feature_meta_bg(sb) || metagroup < first_meta_bg) {\r\nlen = le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks);\r\nerror = ext4_getfsmap_fill(meta_list, fsb, len,\r\nEXT4_FMR_OWN_RESV_GDT);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ext4_getfsmap_compare(void *priv,\r\nstruct list_head *a,\r\nstruct list_head *b)\r\n{\r\nstruct ext4_fsmap *fa;\r\nstruct ext4_fsmap *fb;\r\nfa = container_of(a, struct ext4_fsmap, fmr_list);\r\nfb = container_of(b, struct ext4_fsmap, fmr_list);\r\nif (fa->fmr_physical < fb->fmr_physical)\r\nreturn -1;\r\nelse if (fa->fmr_physical > fb->fmr_physical)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void ext4_getfsmap_merge_fixed_metadata(struct list_head *meta_list)\r\n{\r\nstruct ext4_fsmap *p;\r\nstruct ext4_fsmap *prev = NULL;\r\nstruct ext4_fsmap *tmp;\r\nlist_for_each_entry_safe(p, tmp, meta_list, fmr_list) {\r\nif (!prev) {\r\nprev = p;\r\ncontinue;\r\n}\r\nif (prev->fmr_owner == p->fmr_owner &&\r\nprev->fmr_physical + prev->fmr_length == p->fmr_physical) {\r\nprev->fmr_length += p->fmr_length;\r\nlist_del(&p->fmr_list);\r\nkfree(p);\r\n} else\r\nprev = p;\r\n}\r\n}\r\nstatic void ext4_getfsmap_free_fixed_metadata(struct list_head *meta_list)\r\n{\r\nstruct ext4_fsmap *p;\r\nstruct ext4_fsmap *tmp;\r\nlist_for_each_entry_safe(p, tmp, meta_list, fmr_list) {\r\nlist_del(&p->fmr_list);\r\nkfree(p);\r\n}\r\n}\r\nint ext4_getfsmap_find_fixed_metadata(struct super_block *sb,\r\nstruct list_head *meta_list)\r\n{\r\nstruct ext4_group_desc *gdp;\r\next4_group_t agno;\r\nint error;\r\nINIT_LIST_HEAD(meta_list);\r\nfor (agno = 0; agno < EXT4_SB(sb)->s_groups_count; agno++) {\r\ngdp = ext4_get_group_desc(sb, agno, NULL);\r\nif (!gdp) {\r\nerror = -EFSCORRUPTED;\r\ngoto err;\r\n}\r\nerror = ext4_getfsmap_find_sb(sb, agno, meta_list);\r\nif (error)\r\ngoto err;\r\nerror = ext4_getfsmap_fill(meta_list,\r\next4_block_bitmap(sb, gdp), 1,\r\nEXT4_FMR_OWN_BLKBM);\r\nif (error)\r\ngoto err;\r\nerror = ext4_getfsmap_fill(meta_list,\r\next4_inode_bitmap(sb, gdp), 1,\r\nEXT4_FMR_OWN_INOBM);\r\nif (error)\r\ngoto err;\r\nerror = ext4_getfsmap_fill(meta_list,\r\next4_inode_table(sb, gdp),\r\nEXT4_SB(sb)->s_itb_per_group,\r\nEXT4_FMR_OWN_INODES);\r\nif (error)\r\ngoto err;\r\n}\r\nlist_sort(NULL, meta_list, ext4_getfsmap_compare);\r\next4_getfsmap_merge_fixed_metadata(meta_list);\r\nreturn 0;\r\nerr:\r\next4_getfsmap_free_fixed_metadata(meta_list);\r\nreturn error;\r\n}\r\nstatic int ext4_getfsmap_datadev(struct super_block *sb,\r\nstruct ext4_fsmap *keys,\r\nstruct ext4_getfsmap_info *info)\r\n{\r\nstruct ext4_sb_info *sbi = EXT4_SB(sb);\r\next4_fsblk_t start_fsb;\r\next4_fsblk_t end_fsb;\r\next4_fsblk_t bofs;\r\next4_fsblk_t eofs;\r\next4_group_t start_ag;\r\next4_group_t end_ag;\r\next4_grpblk_t first_cluster;\r\next4_grpblk_t last_cluster;\r\nint error = 0;\r\nbofs = le32_to_cpu(sbi->s_es->s_first_data_block);\r\neofs = ext4_blocks_count(sbi->s_es);\r\nif (keys[0].fmr_physical >= eofs)\r\nreturn 0;\r\nelse if (keys[0].fmr_physical < bofs)\r\nkeys[0].fmr_physical = bofs;\r\nif (keys[1].fmr_physical >= eofs)\r\nkeys[1].fmr_physical = eofs - 1;\r\nstart_fsb = keys[0].fmr_physical;\r\nend_fsb = keys[1].fmr_physical;\r\next4_get_group_no_and_offset(sb, start_fsb, &start_ag, &first_cluster);\r\next4_get_group_no_and_offset(sb, end_fsb, &end_ag, &last_cluster);\r\ninfo->gfi_low = keys[0];\r\ninfo->gfi_low.fmr_physical = EXT4_C2B(sbi, first_cluster);\r\ninfo->gfi_low.fmr_length = 0;\r\nmemset(&info->gfi_high, 0xFF, sizeof(info->gfi_high));\r\nerror = ext4_getfsmap_find_fixed_metadata(sb, &info->gfi_meta_list);\r\nif (error)\r\ngoto err;\r\nfor (info->gfi_agno = start_ag;\r\ninfo->gfi_agno <= end_ag;\r\ninfo->gfi_agno++) {\r\nif (info->gfi_agno == end_ag) {\r\ninfo->gfi_high = keys[1];\r\ninfo->gfi_high.fmr_physical = EXT4_C2B(sbi,\r\nlast_cluster);\r\ninfo->gfi_high.fmr_length = 0;\r\n}\r\ntrace_ext4_fsmap_low_key(sb, info->gfi_dev, info->gfi_agno,\r\ninfo->gfi_low.fmr_physical,\r\ninfo->gfi_low.fmr_length,\r\ninfo->gfi_low.fmr_owner);\r\ntrace_ext4_fsmap_high_key(sb, info->gfi_dev, info->gfi_agno,\r\ninfo->gfi_high.fmr_physical,\r\ninfo->gfi_high.fmr_length,\r\ninfo->gfi_high.fmr_owner);\r\nerror = ext4_mballoc_query_range(sb, info->gfi_agno,\r\nEXT4_B2C(sbi, info->gfi_low.fmr_physical),\r\nEXT4_B2C(sbi, info->gfi_high.fmr_physical),\r\next4_getfsmap_datadev_helper, info);\r\nif (error)\r\ngoto err;\r\nif (info->gfi_agno == start_ag)\r\nmemset(&info->gfi_low, 0, sizeof(info->gfi_low));\r\n}\r\nif (info->gfi_lastfree.fmr_owner) {\r\nerror = ext4_getfsmap_helper(sb, info, &info->gfi_lastfree);\r\nif (error)\r\ngoto err;\r\n}\r\ninfo->gfi_last = true;\r\nerror = ext4_getfsmap_datadev_helper(sb, end_ag, last_cluster, 0, info);\r\nif (error)\r\ngoto err;\r\nerr:\r\next4_getfsmap_free_fixed_metadata(&info->gfi_meta_list);\r\nreturn error;\r\n}\r\nstatic bool ext4_getfsmap_is_valid_device(struct super_block *sb,\r\nstruct ext4_fsmap *fm)\r\n{\r\nif (fm->fmr_device == 0 || fm->fmr_device == UINT_MAX ||\r\nfm->fmr_device == new_encode_dev(sb->s_bdev->bd_dev))\r\nreturn true;\r\nif (EXT4_SB(sb)->journal_bdev &&\r\nfm->fmr_device == new_encode_dev(EXT4_SB(sb)->journal_bdev->bd_dev))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool ext4_getfsmap_check_keys(struct ext4_fsmap *low_key,\r\nstruct ext4_fsmap *high_key)\r\n{\r\nif (low_key->fmr_device > high_key->fmr_device)\r\nreturn false;\r\nif (low_key->fmr_device < high_key->fmr_device)\r\nreturn true;\r\nif (low_key->fmr_physical > high_key->fmr_physical)\r\nreturn false;\r\nif (low_key->fmr_physical < high_key->fmr_physical)\r\nreturn true;\r\nif (low_key->fmr_owner > high_key->fmr_owner)\r\nreturn false;\r\nif (low_key->fmr_owner < high_key->fmr_owner)\r\nreturn true;\r\nreturn false;\r\n}\r\nint ext4_getfsmap(struct super_block *sb, struct ext4_fsmap_head *head,\r\next4_fsmap_format_t formatter, void *arg)\r\n{\r\nstruct ext4_fsmap dkeys[2];\r\nstruct ext4_getfsmap_dev handlers[EXT4_GETFSMAP_DEVS];\r\nstruct ext4_getfsmap_info info = {0};\r\nint i;\r\nint error = 0;\r\nif (head->fmh_iflags & ~FMH_IF_VALID)\r\nreturn -EINVAL;\r\nif (!ext4_getfsmap_is_valid_device(sb, &head->fmh_keys[0]) ||\r\n!ext4_getfsmap_is_valid_device(sb, &head->fmh_keys[1]))\r\nreturn -EINVAL;\r\nhead->fmh_entries = 0;\r\nmemset(handlers, 0, sizeof(handlers));\r\nhandlers[0].gfd_dev = new_encode_dev(sb->s_bdev->bd_dev);\r\nhandlers[0].gfd_fn = ext4_getfsmap_datadev;\r\nif (EXT4_SB(sb)->journal_bdev) {\r\nhandlers[1].gfd_dev = new_encode_dev(\r\nEXT4_SB(sb)->journal_bdev->bd_dev);\r\nhandlers[1].gfd_fn = ext4_getfsmap_logdev;\r\n}\r\nsort(handlers, EXT4_GETFSMAP_DEVS, sizeof(struct ext4_getfsmap_dev),\r\next4_getfsmap_dev_compare, NULL);\r\ndkeys[0] = head->fmh_keys[0];\r\ndkeys[0].fmr_physical += dkeys[0].fmr_length;\r\ndkeys[0].fmr_owner = 0;\r\ndkeys[0].fmr_length = 0;\r\nmemset(&dkeys[1], 0xFF, sizeof(struct ext4_fsmap));\r\nif (!ext4_getfsmap_check_keys(dkeys, &head->fmh_keys[1]))\r\nreturn -EINVAL;\r\ninfo.gfi_next_fsblk = head->fmh_keys[0].fmr_physical +\r\nhead->fmh_keys[0].fmr_length;\r\ninfo.gfi_formatter = formatter;\r\ninfo.gfi_format_arg = arg;\r\ninfo.gfi_head = head;\r\nfor (i = 0; i < EXT4_GETFSMAP_DEVS; i++) {\r\nif (!handlers[i].gfd_fn)\r\ncontinue;\r\nif (head->fmh_keys[0].fmr_device > handlers[i].gfd_dev)\r\ncontinue;\r\nif (head->fmh_keys[1].fmr_device < handlers[i].gfd_dev)\r\nbreak;\r\nif (handlers[i].gfd_dev == head->fmh_keys[1].fmr_device)\r\ndkeys[1] = head->fmh_keys[1];\r\nif (handlers[i].gfd_dev > head->fmh_keys[0].fmr_device)\r\nmemset(&dkeys[0], 0, sizeof(struct ext4_fsmap));\r\ninfo.gfi_dev = handlers[i].gfd_dev;\r\ninfo.gfi_last = false;\r\ninfo.gfi_agno = -1;\r\nerror = handlers[i].gfd_fn(sb, dkeys, &info);\r\nif (error)\r\nbreak;\r\ninfo.gfi_next_fsblk = 0;\r\n}\r\nhead->fmh_oflags = FMH_OF_DEV_T;\r\nreturn error;\r\n}
