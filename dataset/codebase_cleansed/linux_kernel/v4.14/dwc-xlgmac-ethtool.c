static void xlgmac_ethtool_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct xlgmac_pdata *pdata = netdev_priv(netdev);\r\nu32 ver = pdata->hw_feat.version;\r\nu32 snpsver, devid, userver;\r\nstrlcpy(drvinfo->driver, pdata->drv_name, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, pdata->drv_ver, sizeof(drvinfo->version));\r\nstrlcpy(drvinfo->bus_info, dev_name(pdata->dev),\r\nsizeof(drvinfo->bus_info));\r\nsnpsver = XLGMAC_GET_REG_BITS(ver, MAC_VR_SNPSVER_POS,\r\nMAC_VR_SNPSVER_LEN);\r\ndevid = XLGMAC_GET_REG_BITS(ver, MAC_VR_DEVID_POS,\r\nMAC_VR_DEVID_LEN);\r\nuserver = XLGMAC_GET_REG_BITS(ver, MAC_VR_USERVER_POS,\r\nMAC_VR_USERVER_LEN);\r\nsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\r\n"S.D.U: %x.%x.%x", snpsver, devid, userver);\r\n}\r\nstatic u32 xlgmac_ethtool_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct xlgmac_pdata *pdata = netdev_priv(netdev);\r\nreturn pdata->msg_enable;\r\n}\r\nstatic void xlgmac_ethtool_set_msglevel(struct net_device *netdev,\r\nu32 msglevel)\r\n{\r\nstruct xlgmac_pdata *pdata = netdev_priv(netdev);\r\npdata->msg_enable = msglevel;\r\n}\r\nstatic void xlgmac_ethtool_get_channels(struct net_device *netdev,\r\nstruct ethtool_channels *channel)\r\n{\r\nstruct xlgmac_pdata *pdata = netdev_priv(netdev);\r\nchannel->max_rx = XLGMAC_MAX_DMA_CHANNELS;\r\nchannel->max_tx = XLGMAC_MAX_DMA_CHANNELS;\r\nchannel->rx_count = pdata->rx_q_count;\r\nchannel->tx_count = pdata->tx_q_count;\r\n}\r\nstatic int xlgmac_ethtool_get_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct xlgmac_pdata *pdata = netdev_priv(netdev);\r\nmemset(ec, 0, sizeof(struct ethtool_coalesce));\r\nec->rx_coalesce_usecs = pdata->rx_usecs;\r\nec->rx_max_coalesced_frames = pdata->rx_frames;\r\nec->tx_max_coalesced_frames = pdata->tx_frames;\r\nreturn 0;\r\n}\r\nstatic int xlgmac_ethtool_set_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct xlgmac_pdata *pdata = netdev_priv(netdev);\r\nstruct xlgmac_hw_ops *hw_ops = &pdata->hw_ops;\r\nunsigned int rx_frames, rx_riwt, rx_usecs;\r\nunsigned int tx_frames;\r\nif ((ec->rx_coalesce_usecs_irq) || (ec->rx_max_coalesced_frames_irq) ||\r\n(ec->tx_coalesce_usecs) || (ec->tx_coalesce_usecs_high) ||\r\n(ec->tx_max_coalesced_frames_irq) || (ec->tx_coalesce_usecs_irq) ||\r\n(ec->stats_block_coalesce_usecs) || (ec->pkt_rate_low) ||\r\n(ec->use_adaptive_rx_coalesce) || (ec->use_adaptive_tx_coalesce) ||\r\n(ec->rx_max_coalesced_frames_low) || (ec->rx_coalesce_usecs_low) ||\r\n(ec->tx_coalesce_usecs_low) || (ec->tx_max_coalesced_frames_low) ||\r\n(ec->pkt_rate_high) || (ec->rx_coalesce_usecs_high) ||\r\n(ec->rx_max_coalesced_frames_high) ||\r\n(ec->tx_max_coalesced_frames_high) ||\r\n(ec->rate_sample_interval))\r\nreturn -EOPNOTSUPP;\r\nrx_usecs = ec->rx_coalesce_usecs;\r\nrx_riwt = hw_ops->usec_to_riwt(pdata, rx_usecs);\r\nrx_frames = ec->rx_max_coalesced_frames;\r\ntx_frames = ec->tx_max_coalesced_frames;\r\nif ((rx_riwt > XLGMAC_MAX_DMA_RIWT) ||\r\n(rx_riwt < XLGMAC_MIN_DMA_RIWT) ||\r\n(rx_frames > pdata->rx_desc_count))\r\nreturn -EINVAL;\r\nif (tx_frames > pdata->tx_desc_count)\r\nreturn -EINVAL;\r\npdata->rx_riwt = rx_riwt;\r\npdata->rx_usecs = rx_usecs;\r\npdata->rx_frames = rx_frames;\r\nhw_ops->config_rx_coalesce(pdata);\r\npdata->tx_frames = tx_frames;\r\nhw_ops->config_tx_coalesce(pdata);\r\nreturn 0;\r\n}\r\nstatic void xlgmac_ethtool_get_strings(struct net_device *netdev,\r\nu32 stringset, u8 *data)\r\n{\r\nint i;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < XLGMAC_STATS_COUNT; i++) {\r\nmemcpy(data, xlgmac_gstring_stats[i].stat_string,\r\nETH_GSTRING_LEN);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\nstatic int xlgmac_ethtool_get_sset_count(struct net_device *netdev,\r\nint stringset)\r\n{\r\nint ret;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nret = XLGMAC_STATS_COUNT;\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic void xlgmac_ethtool_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats,\r\nu64 *data)\r\n{\r\nstruct xlgmac_pdata *pdata = netdev_priv(netdev);\r\nu8 *stat;\r\nint i;\r\npdata->hw_ops.read_mmc_stats(pdata);\r\nfor (i = 0; i < XLGMAC_STATS_COUNT; i++) {\r\nstat = (u8 *)pdata + xlgmac_gstring_stats[i].stat_offset;\r\n*data++ = *(u64 *)stat;\r\n}\r\n}\r\nconst struct ethtool_ops *xlgmac_get_ethtool_ops(void)\r\n{\r\nreturn &xlgmac_ethtool_ops;\r\n}
