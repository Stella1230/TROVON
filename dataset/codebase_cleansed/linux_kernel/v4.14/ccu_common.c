void ccu_helper_wait_for_lock(struct ccu_common *common, u32 lock)\r\n{\r\nvoid __iomem *addr;\r\nu32 reg;\r\nif (!lock)\r\nreturn;\r\nif (common->features & CCU_FEATURE_LOCK_REG)\r\naddr = common->base + common->lock_reg;\r\nelse\r\naddr = common->base + common->reg;\r\nWARN_ON(readl_relaxed_poll_timeout(addr, reg, reg & lock, 100, 70000));\r\n}\r\nstatic int ccu_pll_notifier_cb(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct ccu_pll_nb *pll = to_ccu_pll_nb(nb);\r\nint ret = 0;\r\nif (event != POST_RATE_CHANGE)\r\ngoto out;\r\nccu_gate_helper_disable(pll->common, pll->enable);\r\nret = ccu_gate_helper_enable(pll->common, pll->enable);\r\nif (ret)\r\ngoto out;\r\nccu_helper_wait_for_lock(pll->common, pll->lock);\r\nout:\r\nreturn notifier_from_errno(ret);\r\n}\r\nint ccu_pll_notifier_register(struct ccu_pll_nb *pll_nb)\r\n{\r\npll_nb->clk_nb.notifier_call = ccu_pll_notifier_cb;\r\nreturn clk_notifier_register(pll_nb->common->hw.clk,\r\n&pll_nb->clk_nb);\r\n}\r\nint sunxi_ccu_probe(struct device_node *node, void __iomem *reg,\r\nconst struct sunxi_ccu_desc *desc)\r\n{\r\nstruct ccu_reset *reset;\r\nint i, ret;\r\nfor (i = 0; i < desc->num_ccu_clks; i++) {\r\nstruct ccu_common *cclk = desc->ccu_clks[i];\r\nif (!cclk)\r\ncontinue;\r\ncclk->base = reg;\r\ncclk->lock = &ccu_lock;\r\n}\r\nfor (i = 0; i < desc->hw_clks->num ; i++) {\r\nstruct clk_hw *hw = desc->hw_clks->hws[i];\r\nif (!hw)\r\ncontinue;\r\nret = clk_hw_register(NULL, hw);\r\nif (ret) {\r\npr_err("Couldn't register clock %d - %s\n",\r\ni, clk_hw_get_name(hw));\r\ngoto err_clk_unreg;\r\n}\r\n}\r\nret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get,\r\ndesc->hw_clks);\r\nif (ret)\r\ngoto err_clk_unreg;\r\nreset = kzalloc(sizeof(*reset), GFP_KERNEL);\r\nif (!reset) {\r\nret = -ENOMEM;\r\ngoto err_alloc_reset;\r\n}\r\nreset->rcdev.of_node = node;\r\nreset->rcdev.ops = &ccu_reset_ops;\r\nreset->rcdev.owner = THIS_MODULE;\r\nreset->rcdev.nr_resets = desc->num_resets;\r\nreset->base = reg;\r\nreset->lock = &ccu_lock;\r\nreset->reset_map = desc->resets;\r\nret = reset_controller_register(&reset->rcdev);\r\nif (ret)\r\ngoto err_of_clk_unreg;\r\nreturn 0;\r\nerr_of_clk_unreg:\r\nkfree(reset);\r\nerr_alloc_reset:\r\nof_clk_del_provider(node);\r\nerr_clk_unreg:\r\nwhile (--i >= 0) {\r\nstruct clk_hw *hw = desc->hw_clks->hws[i];\r\nif (!hw)\r\ncontinue;\r\nclk_hw_unregister(hw);\r\n}\r\nreturn ret;\r\n}
