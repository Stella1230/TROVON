bool cxgb4_ptp_is_ptp_tx(struct sk_buff *skb)\r\n{\r\nstruct udphdr *uh;\r\nuh = udp_hdr(skb);\r\nreturn skb->len >= PTP_MIN_LENGTH &&\r\nskb->len <= PTP_IN_TRANSMIT_PACKET_MAXNUM &&\r\nlikely(skb->protocol == htons(ETH_P_IP)) &&\r\nip_hdr(skb)->protocol == IPPROTO_UDP &&\r\nuh->dest == htons(PTP_EVENT_PORT);\r\n}\r\nbool is_ptp_enabled(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct port_info *pi;\r\npi = netdev_priv(dev);\r\nreturn (pi->ptp_enable && cxgb4_xmit_with_hwtstamp(skb) &&\r\ncxgb4_ptp_is_ptp_tx(skb));\r\n}\r\nbool cxgb4_ptp_is_ptp_rx(struct sk_buff *skb)\r\n{\r\nstruct udphdr *uh = (struct udphdr *)(skb->data + ETH_HLEN +\r\nIPV4_HLEN(skb->data));\r\nreturn uh->dest == htons(PTP_EVENT_PORT) &&\r\nuh->source == htons(PTP_EVENT_PORT);\r\n}\r\nvoid cxgb4_ptp_read_hwstamp(struct adapter *adapter, struct port_info *pi)\r\n{\r\nstruct skb_shared_hwtstamps *skb_ts = NULL;\r\nu64 tx_ts;\r\nskb_ts = skb_hwtstamps(adapter->ptp_tx_skb);\r\ntx_ts = t4_read_reg(adapter,\r\nT5_PORT_REG(pi->port_id, MAC_PORT_TX_TS_VAL_LO));\r\ntx_ts |= (u64)t4_read_reg(adapter,\r\nT5_PORT_REG(pi->port_id,\r\nMAC_PORT_TX_TS_VAL_HI)) << 32;\r\nskb_ts->hwtstamp = ns_to_ktime(tx_ts);\r\nskb_tstamp_tx(adapter->ptp_tx_skb, skb_ts);\r\ndev_kfree_skb_any(adapter->ptp_tx_skb);\r\nspin_lock(&adapter->ptp_lock);\r\nadapter->ptp_tx_skb = NULL;\r\nspin_unlock(&adapter->ptp_lock);\r\n}\r\nint cxgb4_ptprx_timestamping(struct port_info *pi, u8 port, u16 mode)\r\n{\r\nstruct adapter *adapter = pi->adapter;\r\nstruct fw_ptp_cmd c;\r\nint err;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F |\r\nFW_PTP_CMD_PORTID_V(port));\r\nc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\r\nc.u.init.sc = FW_PTP_SC_RXTIME_STAMP;\r\nc.u.init.mode = cpu_to_be16(mode);\r\nerr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\r\nif (err < 0)\r\ndev_err(adapter->pdev_dev,\r\n"PTP: %s error %d\n", __func__, -err);\r\nreturn err;\r\n}\r\nint cxgb4_ptp_txtype(struct adapter *adapter, u8 port)\r\n{\r\nstruct fw_ptp_cmd c;\r\nint err;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F |\r\nFW_PTP_CMD_PORTID_V(port));\r\nc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\r\nc.u.init.sc = FW_PTP_SC_TX_TYPE;\r\nc.u.init.mode = cpu_to_be16(PTP_TS_NONE);\r\nerr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\r\nif (err < 0)\r\ndev_err(adapter->pdev_dev,\r\n"PTP: %s error %d\n", __func__, -err);\r\nreturn err;\r\n}\r\nint cxgb4_ptp_redirect_rx_packet(struct adapter *adapter, struct port_info *pi)\r\n{\r\nstruct sge *s = &adapter->sge;\r\nstruct sge_eth_rxq *receive_q = &s->ethrxq[pi->first_qset];\r\nstruct fw_ptp_cmd c;\r\nint err;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F |\r\nFW_PTP_CMD_PORTID_V(pi->port_id));\r\nc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\r\nc.u.init.sc = FW_PTP_SC_RDRX_TYPE;\r\nc.u.init.txchan = pi->tx_chan;\r\nc.u.init.absid = cpu_to_be16(receive_q->rspq.abs_id);\r\nerr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\r\nif (err < 0)\r\ndev_err(adapter->pdev_dev,\r\n"PTP: %s error %d\n", __func__, -err);\r\nreturn err;\r\n}\r\nstatic int cxgb4_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nstruct adapter *adapter = (struct adapter *)container_of(ptp,\r\nstruct adapter, ptp_clock_info);\r\nstruct fw_ptp_cmd c;\r\nint err;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F |\r\nFW_PTP_CMD_PORTID_V(0));\r\nc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\r\nc.u.ts.sc = FW_PTP_SC_ADJ_FREQ;\r\nc.u.ts.sign = (ppb < 0) ? 1 : 0;\r\nif (ppb < 0)\r\nppb = -ppb;\r\nc.u.ts.ppb = cpu_to_be32(ppb);\r\nerr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\r\nif (err < 0)\r\ndev_err(adapter->pdev_dev,\r\n"PTP: %s error %d\n", __func__, -err);\r\nreturn err;\r\n}\r\nstatic int cxgb4_ptp_fineadjtime(struct adapter *adapter, s64 delta)\r\n{\r\nstruct fw_ptp_cmd c;\r\nint err;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F |\r\nFW_PTP_CMD_PORTID_V(0));\r\nc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\r\nc.u.ts.sc = FW_PTP_SC_ADJ_FTIME;\r\nc.u.ts.tm = cpu_to_be64(delta);\r\nerr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\r\nif (err < 0)\r\ndev_err(adapter->pdev_dev,\r\n"PTP: %s error %d\n", __func__, -err);\r\nreturn err;\r\n}\r\nstatic int cxgb4_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct adapter *adapter =\r\n(struct adapter *)container_of(ptp, struct adapter,\r\nptp_clock_info);\r\nstruct fw_ptp_cmd c;\r\ns64 sign = 1;\r\nint err;\r\nif (delta < 0)\r\nsign = -1;\r\nif (delta * sign > PTP_CLOCK_MAX_ADJTIME) {\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F |\r\nFW_PTP_CMD_PORTID_V(0));\r\nc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\r\nc.u.ts.sc = FW_PTP_SC_ADJ_TIME;\r\nc.u.ts.sign = (delta < 0) ? 1 : 0;\r\nif (delta < 0)\r\ndelta = -delta;\r\nc.u.ts.tm = cpu_to_be64(delta);\r\nerr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\r\nif (err < 0)\r\ndev_err(adapter->pdev_dev,\r\n"PTP: %s error %d\n", __func__, -err);\r\n} else {\r\nerr = cxgb4_ptp_fineadjtime(adapter, delta);\r\n}\r\nreturn err;\r\n}\r\nstatic int cxgb4_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\r\n{\r\nstruct adapter *adapter = (struct adapter *)container_of(ptp,\r\nstruct adapter, ptp_clock_info);\r\nstruct fw_ptp_cmd c;\r\nu64 ns;\r\nint err;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_READ_F |\r\nFW_PTP_CMD_PORTID_V(0));\r\nc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\r\nc.u.ts.sc = FW_PTP_SC_GET_TIME;\r\nerr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), &c);\r\nif (err < 0) {\r\ndev_err(adapter->pdev_dev,\r\n"PTP: %s error %d\n", __func__, -err);\r\nreturn err;\r\n}\r\nns = be64_to_cpu(c.u.ts.tm);\r\n*ts = ns_to_timespec64(ns);\r\nreturn err;\r\n}\r\nstatic int cxgb4_ptp_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct adapter *adapter = (struct adapter *)container_of(ptp,\r\nstruct adapter, ptp_clock_info);\r\nstruct fw_ptp_cmd c;\r\nu64 ns;\r\nint err;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F |\r\nFW_PTP_CMD_PORTID_V(0));\r\nc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\r\nc.u.ts.sc = FW_PTP_SC_SET_TIME;\r\nns = timespec64_to_ns(ts);\r\nc.u.ts.tm = cpu_to_be64(ns);\r\nerr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\r\nif (err < 0)\r\ndev_err(adapter->pdev_dev,\r\n"PTP: %s error %d\n", __func__, -err);\r\nreturn err;\r\n}\r\nstatic void cxgb4_init_ptp_timer(struct adapter *adapter)\r\n{\r\nstruct fw_ptp_cmd c;\r\nint err;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\r\nFW_CMD_REQUEST_F |\r\nFW_CMD_WRITE_F |\r\nFW_PTP_CMD_PORTID_V(0));\r\nc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\r\nc.u.scmd.sc = FW_PTP_SC_INIT_TIMER;\r\nerr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\r\nif (err < 0)\r\ndev_err(adapter->pdev_dev,\r\n"PTP: %s error %d\n", __func__, -err);\r\n}\r\nstatic int cxgb4_ptp_enable(struct ptp_clock_info __always_unused *ptp,\r\nstruct ptp_clock_request __always_unused *request,\r\nint __always_unused on)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nvoid cxgb4_ptp_init(struct adapter *adapter)\r\n{\r\nstruct timespec64 now;\r\nif (!IS_ERR_OR_NULL(adapter->ptp_clock))\r\nreturn;\r\nadapter->ptp_tx_skb = NULL;\r\nadapter->ptp_clock_info = cxgb4_ptp_clock_info;\r\nspin_lock_init(&adapter->ptp_lock);\r\nadapter->ptp_clock = ptp_clock_register(&adapter->ptp_clock_info,\r\n&adapter->pdev->dev);\r\nif (IS_ERR_OR_NULL(adapter->ptp_clock)) {\r\nadapter->ptp_clock = NULL;\r\ndev_err(adapter->pdev_dev,\r\n"PTP %s Clock registration has failed\n", __func__);\r\nreturn;\r\n}\r\nnow = ktime_to_timespec64(ktime_get_real());\r\ncxgb4_init_ptp_timer(adapter);\r\nif (cxgb4_ptp_settime(&adapter->ptp_clock_info, &now) < 0) {\r\nptp_clock_unregister(adapter->ptp_clock);\r\nadapter->ptp_clock = NULL;\r\n}\r\n}\r\nvoid cxgb4_ptp_stop(struct adapter *adapter)\r\n{\r\nif (adapter->ptp_tx_skb) {\r\ndev_kfree_skb_any(adapter->ptp_tx_skb);\r\nadapter->ptp_tx_skb = NULL;\r\n}\r\nif (adapter->ptp_clock) {\r\nptp_clock_unregister(adapter->ptp_clock);\r\nadapter->ptp_clock = NULL;\r\n}\r\n}
