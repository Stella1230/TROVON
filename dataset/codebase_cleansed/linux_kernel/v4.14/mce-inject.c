static void setup_inj_struct(struct mce *m)\r\n{\r\nmemset(m, 0, sizeof(struct mce));\r\nm->cpuvendor = boot_cpu_data.x86_vendor;\r\n}\r\nstatic void inject_mce(struct mce *m)\r\n{\r\nstruct mce *i = &per_cpu(injectm, m->extcpu);\r\ni->finished = 0;\r\nmb();\r\nm->finished = 0;\r\ni->extcpu = m->extcpu;\r\nmb();\r\nmemcpy(i, m, sizeof(struct mce));\r\nmb();\r\ni->finished = 1;\r\n}\r\nstatic void raise_poll(struct mce *m)\r\n{\r\nunsigned long flags;\r\nmce_banks_t b;\r\nmemset(&b, 0xff, sizeof(mce_banks_t));\r\nlocal_irq_save(flags);\r\nmachine_check_poll(0, &b);\r\nlocal_irq_restore(flags);\r\nm->finished = 0;\r\n}\r\nstatic void raise_exception(struct mce *m, struct pt_regs *pregs)\r\n{\r\nstruct pt_regs regs;\r\nunsigned long flags;\r\nif (!pregs) {\r\nmemset(&regs, 0, sizeof(struct pt_regs));\r\nregs.ip = m->ip;\r\nregs.cs = m->cs;\r\npregs = &regs;\r\n}\r\nlocal_irq_save(flags);\r\ndo_machine_check(pregs, 0);\r\nlocal_irq_restore(flags);\r\nm->finished = 0;\r\n}\r\nstatic int mce_raise_notify(unsigned int cmd, struct pt_regs *regs)\r\n{\r\nint cpu = smp_processor_id();\r\nstruct mce *m = this_cpu_ptr(&injectm);\r\nif (!cpumask_test_cpu(cpu, mce_inject_cpumask))\r\nreturn NMI_DONE;\r\ncpumask_clear_cpu(cpu, mce_inject_cpumask);\r\nif (m->inject_flags & MCJ_EXCEPTION)\r\nraise_exception(m, regs);\r\nelse if (m->status)\r\nraise_poll(m);\r\nreturn NMI_HANDLED;\r\n}\r\nstatic void mce_irq_ipi(void *info)\r\n{\r\nint cpu = smp_processor_id();\r\nstruct mce *m = this_cpu_ptr(&injectm);\r\nif (cpumask_test_cpu(cpu, mce_inject_cpumask) &&\r\nm->inject_flags & MCJ_EXCEPTION) {\r\ncpumask_clear_cpu(cpu, mce_inject_cpumask);\r\nraise_exception(m, NULL);\r\n}\r\n}\r\nstatic int raise_local(void)\r\n{\r\nstruct mce *m = this_cpu_ptr(&injectm);\r\nint context = MCJ_CTX(m->inject_flags);\r\nint ret = 0;\r\nint cpu = m->extcpu;\r\nif (m->inject_flags & MCJ_EXCEPTION) {\r\npr_info("Triggering MCE exception on CPU %d\n", cpu);\r\nswitch (context) {\r\ncase MCJ_CTX_IRQ:\r\ncase MCJ_CTX_PROCESS:\r\nraise_exception(m, NULL);\r\nbreak;\r\ndefault:\r\npr_info("Invalid MCE context\n");\r\nret = -EINVAL;\r\n}\r\npr_info("MCE exception done on CPU %d\n", cpu);\r\n} else if (m->status) {\r\npr_info("Starting machine check poll CPU %d\n", cpu);\r\nraise_poll(m);\r\nmce_notify_irq();\r\npr_info("Machine check poll done on CPU %d\n", cpu);\r\n} else\r\nm->finished = 0;\r\nreturn ret;\r\n}\r\nstatic void __maybe_unused raise_mce(struct mce *m)\r\n{\r\nint context = MCJ_CTX(m->inject_flags);\r\ninject_mce(m);\r\nif (context == MCJ_CTX_RANDOM)\r\nreturn;\r\nif (m->inject_flags & (MCJ_IRQ_BROADCAST | MCJ_NMI_BROADCAST)) {\r\nunsigned long start;\r\nint cpu;\r\nget_online_cpus();\r\ncpumask_copy(mce_inject_cpumask, cpu_online_mask);\r\ncpumask_clear_cpu(get_cpu(), mce_inject_cpumask);\r\nfor_each_online_cpu(cpu) {\r\nstruct mce *mcpu = &per_cpu(injectm, cpu);\r\nif (!mcpu->finished ||\r\nMCJ_CTX(mcpu->inject_flags) != MCJ_CTX_RANDOM)\r\ncpumask_clear_cpu(cpu, mce_inject_cpumask);\r\n}\r\nif (!cpumask_empty(mce_inject_cpumask)) {\r\nif (m->inject_flags & MCJ_IRQ_BROADCAST) {\r\npreempt_disable();\r\nsmp_call_function_many(mce_inject_cpumask,\r\nmce_irq_ipi, NULL, 0);\r\npreempt_enable();\r\n} else if (m->inject_flags & MCJ_NMI_BROADCAST)\r\napic->send_IPI_mask(mce_inject_cpumask,\r\nNMI_VECTOR);\r\n}\r\nstart = jiffies;\r\nwhile (!cpumask_empty(mce_inject_cpumask)) {\r\nif (!time_before(jiffies, start + 2*HZ)) {\r\npr_err("Timeout waiting for mce inject %lx\n",\r\n*cpumask_bits(mce_inject_cpumask));\r\nbreak;\r\n}\r\ncpu_relax();\r\n}\r\nraise_local();\r\nput_cpu();\r\nput_online_cpus();\r\n} else {\r\npreempt_disable();\r\nraise_local();\r\npreempt_enable();\r\n}\r\n}\r\nstatic int mce_inject_raise(struct notifier_block *nb, unsigned long val,\r\nvoid *data)\r\n{\r\nstruct mce *m = (struct mce *)data;\r\nif (!m)\r\nreturn NOTIFY_DONE;\r\nmutex_lock(&mce_inject_mutex);\r\nraise_mce(m);\r\nmutex_unlock(&mce_inject_mutex);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int toggle_hw_mce_inject(unsigned int cpu, bool enable)\r\n{\r\nu32 l, h;\r\nint err;\r\nerr = rdmsr_on_cpu(cpu, MSR_K7_HWCR, &l, &h);\r\nif (err) {\r\npr_err("%s: error reading HWCR\n", __func__);\r\nreturn err;\r\n}\r\nenable ? (l |= BIT(18)) : (l &= ~BIT(18));\r\nerr = wrmsr_on_cpu(cpu, MSR_K7_HWCR, l, h);\r\nif (err)\r\npr_err("%s: error writing HWCR\n", __func__);\r\nreturn err;\r\n}\r\nstatic int __set_inj(const char *buf)\r\n{\r\nint i;\r\nfor (i = 0; i < N_INJ_TYPES; i++) {\r\nif (!strncmp(flags_options[i], buf, strlen(flags_options[i]))) {\r\ninj_type = i;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t flags_read(struct file *filp, char __user *ubuf,\r\nsize_t cnt, loff_t *ppos)\r\n{\r\nchar buf[MAX_FLAG_OPT_SIZE];\r\nint n;\r\nn = sprintf(buf, "%s\n", flags_options[inj_type]);\r\nreturn simple_read_from_buffer(ubuf, cnt, ppos, buf, n);\r\n}\r\nstatic ssize_t flags_write(struct file *filp, const char __user *ubuf,\r\nsize_t cnt, loff_t *ppos)\r\n{\r\nchar buf[MAX_FLAG_OPT_SIZE], *__buf;\r\nint err;\r\nif (cnt > MAX_FLAG_OPT_SIZE)\r\nreturn -EINVAL;\r\nif (copy_from_user(&buf, ubuf, cnt))\r\nreturn -EFAULT;\r\nbuf[cnt - 1] = 0;\r\n__buf = strstrip(buf);\r\nerr = __set_inj(__buf);\r\nif (err) {\r\npr_err("%s: Invalid flags value: %s\n", __func__, __buf);\r\nreturn err;\r\n}\r\n*ppos += cnt;\r\nreturn cnt;\r\n}\r\nstatic int inj_extcpu_set(void *data, u64 val)\r\n{\r\nstruct mce *m = (struct mce *)data;\r\nif (val >= nr_cpu_ids || !cpu_online(val)) {\r\npr_err("%s: Invalid CPU: %llu\n", __func__, val);\r\nreturn -EINVAL;\r\n}\r\nm->extcpu = val;\r\nreturn 0;\r\n}\r\nstatic void trigger_mce(void *info)\r\n{\r\nasm volatile("int $18");\r\n}\r\nstatic void trigger_dfr_int(void *info)\r\n{\r\nasm volatile("int %0" :: "i" (DEFERRED_ERROR_VECTOR));\r\n}\r\nstatic void trigger_thr_int(void *info)\r\n{\r\nasm volatile("int %0" :: "i" (THRESHOLD_APIC_VECTOR));\r\n}\r\nstatic u32 get_nbc_for_node(int node_id)\r\n{\r\nstruct cpuinfo_x86 *c = &boot_cpu_data;\r\nu32 cores_per_node;\r\ncores_per_node = (c->x86_max_cores * smp_num_siblings) / amd_get_nodes_per_socket();\r\nreturn cores_per_node * node_id;\r\n}\r\nstatic void toggle_nb_mca_mst_cpu(u16 nid)\r\n{\r\nstruct amd_northbridge *nb;\r\nstruct pci_dev *F3;\r\nu32 val;\r\nint err;\r\nnb = node_to_amd_nb(nid);\r\nif (!nb)\r\nreturn;\r\nF3 = nb->misc;\r\nif (!F3)\r\nreturn;\r\nerr = pci_read_config_dword(F3, NBCFG, &val);\r\nif (err) {\r\npr_err("%s: Error reading F%dx%03x.\n",\r\n__func__, PCI_FUNC(F3->devfn), NBCFG);\r\nreturn;\r\n}\r\nif (val & BIT(27))\r\nreturn;\r\npr_err("%s: Set D18F3x44[NbMcaToMstCpuEn] which BIOS hasn't done.\n",\r\n__func__);\r\nval |= BIT(27);\r\nerr = pci_write_config_dword(F3, NBCFG, val);\r\nif (err)\r\npr_err("%s: Error writing F%dx%03x.\n",\r\n__func__, PCI_FUNC(F3->devfn), NBCFG);\r\n}\r\nstatic void prepare_msrs(void *info)\r\n{\r\nstruct mce m = *(struct mce *)info;\r\nu8 b = m.bank;\r\nwrmsrl(MSR_IA32_MCG_STATUS, m.mcgstatus);\r\nif (boot_cpu_has(X86_FEATURE_SMCA)) {\r\nif (m.inject_flags == DFR_INT_INJ) {\r\nwrmsrl(MSR_AMD64_SMCA_MCx_DESTAT(b), m.status);\r\nwrmsrl(MSR_AMD64_SMCA_MCx_DEADDR(b), m.addr);\r\n} else {\r\nwrmsrl(MSR_AMD64_SMCA_MCx_STATUS(b), m.status);\r\nwrmsrl(MSR_AMD64_SMCA_MCx_ADDR(b), m.addr);\r\n}\r\nwrmsrl(MSR_AMD64_SMCA_MCx_MISC(b), m.misc);\r\nwrmsrl(MSR_AMD64_SMCA_MCx_SYND(b), m.synd);\r\n} else {\r\nwrmsrl(MSR_IA32_MCx_STATUS(b), m.status);\r\nwrmsrl(MSR_IA32_MCx_ADDR(b), m.addr);\r\nwrmsrl(MSR_IA32_MCx_MISC(b), m.misc);\r\n}\r\n}\r\nstatic void do_inject(void)\r\n{\r\nu64 mcg_status = 0;\r\nunsigned int cpu = i_mce.extcpu;\r\nu8 b = i_mce.bank;\r\nrdtscll(i_mce.tsc);\r\nif (i_mce.misc)\r\ni_mce.status |= MCI_STATUS_MISCV;\r\nif (i_mce.synd)\r\ni_mce.status |= MCI_STATUS_SYNDV;\r\nif (inj_type == SW_INJ) {\r\nmce_inject_log(&i_mce);\r\nreturn;\r\n}\r\nmcg_status = MCG_STATUS_MCIP | MCG_STATUS_EIPV;\r\nif (!(i_mce.status & MCI_STATUS_PCC))\r\nmcg_status |= MCG_STATUS_RIPV;\r\nif (inj_type == DFR_INT_INJ) {\r\ni_mce.status |= MCI_STATUS_DEFERRED;\r\ni_mce.status |= (i_mce.status & ~MCI_STATUS_UC);\r\n}\r\nif (static_cpu_has(X86_FEATURE_AMD_DCM) &&\r\nb == 4 &&\r\nboot_cpu_data.x86 < 0x17) {\r\ntoggle_nb_mca_mst_cpu(amd_get_nb_id(cpu));\r\ncpu = get_nbc_for_node(amd_get_nb_id(cpu));\r\n}\r\nget_online_cpus();\r\nif (!cpu_online(cpu))\r\ngoto err;\r\ntoggle_hw_mce_inject(cpu, true);\r\ni_mce.mcgstatus = mcg_status;\r\ni_mce.inject_flags = inj_type;\r\nsmp_call_function_single(cpu, prepare_msrs, &i_mce, 0);\r\ntoggle_hw_mce_inject(cpu, false);\r\nswitch (inj_type) {\r\ncase DFR_INT_INJ:\r\nsmp_call_function_single(cpu, trigger_dfr_int, NULL, 0);\r\nbreak;\r\ncase THR_INT_INJ:\r\nsmp_call_function_single(cpu, trigger_thr_int, NULL, 0);\r\nbreak;\r\ndefault:\r\nsmp_call_function_single(cpu, trigger_mce, NULL, 0);\r\n}\r\nerr:\r\nput_online_cpus();\r\n}\r\nstatic int inj_bank_set(void *data, u64 val)\r\n{\r\nstruct mce *m = (struct mce *)data;\r\nif (val >= n_banks) {\r\npr_err("Non-existent MCE bank: %llu\n", val);\r\nreturn -EINVAL;\r\n}\r\nm->bank = val;\r\ndo_inject();\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\ninj_readme_read(struct file *filp, char __user *ubuf,\r\nsize_t cnt, loff_t *ppos)\r\n{\r\nreturn simple_read_from_buffer(ubuf, cnt, ppos,\r\nreadme_msg, strlen(readme_msg));\r\n}\r\nstatic int __init debugfs_init(void)\r\n{\r\nunsigned int i;\r\nu64 cap;\r\nrdmsrl(MSR_IA32_MCG_CAP, cap);\r\nn_banks = cap & MCG_BANKCNT_MASK;\r\ndfs_inj = debugfs_create_dir("mce-inject", NULL);\r\nif (!dfs_inj)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(dfs_fls); i++) {\r\ndfs_fls[i].d = debugfs_create_file(dfs_fls[i].name,\r\ndfs_fls[i].perm,\r\ndfs_inj,\r\n&i_mce,\r\ndfs_fls[i].fops);\r\nif (!dfs_fls[i].d)\r\ngoto err_dfs_add;\r\n}\r\nreturn 0;\r\nerr_dfs_add:\r\nwhile (i-- > 0)\r\ndebugfs_remove(dfs_fls[i].d);\r\ndebugfs_remove(dfs_inj);\r\ndfs_inj = NULL;\r\nreturn -ENODEV;\r\n}\r\nstatic int __init inject_init(void)\r\n{\r\nint err;\r\nif (!alloc_cpumask_var(&mce_inject_cpumask, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nerr = debugfs_init();\r\nif (err) {\r\nfree_cpumask_var(mce_inject_cpumask);\r\nreturn err;\r\n}\r\nregister_nmi_handler(NMI_LOCAL, mce_raise_notify, 0, "mce_notify");\r\nmce_register_injector_chain(&inject_nb);\r\nsetup_inj_struct(&i_mce);\r\npr_info("Machine check injector initialized\n");\r\nreturn 0;\r\n}\r\nstatic void __exit inject_exit(void)\r\n{\r\nmce_unregister_injector_chain(&inject_nb);\r\nunregister_nmi_handler(NMI_LOCAL, "mce_notify");\r\ndebugfs_remove_recursive(dfs_inj);\r\ndfs_inj = NULL;\r\nmemset(&dfs_fls, 0, sizeof(dfs_fls));\r\nfree_cpumask_var(mce_inject_cpumask);\r\n}
