static int usbmisc_imx25_init(struct imx_usbmisc_data *data)\r\n{\r\nstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\r\nunsigned long flags;\r\nu32 val = 0;\r\nif (data->index > 1)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&usbmisc->lock, flags);\r\nswitch (data->index) {\r\ncase 0:\r\nval = readl(usbmisc->base);\r\nval &= ~(MX25_OTG_SIC_MASK | MX25_OTG_PP_BIT);\r\nval |= (MX25_EHCI_INTERFACE_DIFF_UNI & MX25_EHCI_INTERFACE_MASK) << MX25_OTG_SIC_SHIFT;\r\nval |= (MX25_OTG_PM_BIT | MX25_OTG_OCPOL_BIT);\r\nwritel(val, usbmisc->base);\r\nbreak;\r\ncase 1:\r\nval = readl(usbmisc->base);\r\nval &= ~(MX25_H1_SIC_MASK | MX25_H1_PP_BIT | MX25_H1_IPPUE_UP_BIT);\r\nval |= (MX25_EHCI_INTERFACE_SINGLE_UNI & MX25_EHCI_INTERFACE_MASK) << MX25_H1_SIC_SHIFT;\r\nval |= (MX25_H1_PM_BIT | MX25_H1_OCPOL_BIT | MX25_H1_TLL_BIT |\r\nMX25_H1_USBTE_BIT | MX25_H1_IPPUE_DOWN_BIT);\r\nwritel(val, usbmisc->base);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&usbmisc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int usbmisc_imx25_post(struct imx_usbmisc_data *data)\r\n{\r\nstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\r\nvoid __iomem *reg;\r\nunsigned long flags;\r\nu32 val;\r\nif (data->index > 2)\r\nreturn -EINVAL;\r\nif (data->evdo) {\r\nspin_lock_irqsave(&usbmisc->lock, flags);\r\nreg = usbmisc->base + MX25_USB_PHY_CTRL_OFFSET;\r\nval = readl(reg);\r\nwritel(val | MX25_BM_EXTERNAL_VBUS_DIVIDER, reg);\r\nspin_unlock_irqrestore(&usbmisc->lock, flags);\r\nusleep_range(5000, 10000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbmisc_imx27_init(struct imx_usbmisc_data *data)\r\n{\r\nstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\r\nunsigned long flags;\r\nu32 val;\r\nswitch (data->index) {\r\ncase 0:\r\nval = MX27_OTG_PM_BIT;\r\nbreak;\r\ncase 1:\r\nval = MX27_H1_PM_BIT;\r\nbreak;\r\ncase 2:\r\nval = MX27_H2_PM_BIT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&usbmisc->lock, flags);\r\nif (data->disable_oc)\r\nval = readl(usbmisc->base) | val;\r\nelse\r\nval = readl(usbmisc->base) & ~val;\r\nwritel(val, usbmisc->base);\r\nspin_unlock_irqrestore(&usbmisc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int usbmisc_imx53_init(struct imx_usbmisc_data *data)\r\n{\r\nstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\r\nvoid __iomem *reg = NULL;\r\nunsigned long flags;\r\nu32 val = 0;\r\nif (data->index > 3)\r\nreturn -EINVAL;\r\nval = readl(usbmisc->base + MX53_USB_OTG_PHY_CTRL_1_OFFSET);\r\nval &= ~MX53_USB_PHYCTRL1_PLLDIV_MASK;\r\nval |= MX53_USB_PLL_DIV_24_MHZ;\r\nwritel(val, usbmisc->base + MX53_USB_OTG_PHY_CTRL_1_OFFSET);\r\nspin_lock_irqsave(&usbmisc->lock, flags);\r\nswitch (data->index) {\r\ncase 0:\r\nif (data->disable_oc) {\r\nreg = usbmisc->base + MX53_USB_OTG_PHY_CTRL_0_OFFSET;\r\nval = readl(reg) | MX53_BM_OVER_CUR_DIS_OTG;\r\nwritel(val, reg);\r\n}\r\nbreak;\r\ncase 1:\r\nif (data->disable_oc) {\r\nreg = usbmisc->base + MX53_USB_OTG_PHY_CTRL_0_OFFSET;\r\nval = readl(reg) | MX53_BM_OVER_CUR_DIS_H1;\r\nwritel(val, reg);\r\n}\r\nbreak;\r\ncase 2:\r\nif (data->ulpi) {\r\nreg = usbmisc->base + MX53_USB_CTRL_1_OFFSET;\r\nval = readl(reg) | MX53_USB_CTRL_1_UH2_ULPI_EN;\r\nval &= ~MX53_USB_CTRL_1_H2_XCVR_CLK_SEL_MASK;\r\nval |= MX53_USB_CTRL_1_H2_XCVR_CLK_SEL_ULPI;\r\nwritel(val, reg);\r\nreg = usbmisc->base + MX53_USB_UH2_CTRL_OFFSET;\r\nval = readl(reg) | MX53_USB_UHx_CTRL_WAKE_UP_EN\r\n| MX53_USB_UHx_CTRL_ULPI_INT_EN;\r\nwritel(val, reg);\r\nif (is_imx53_usbmisc(data)) {\r\nreg = usbmisc->base +\r\nMX53_USB_CLKONOFF_CTRL_OFFSET;\r\nval = readl(reg) |\r\nMX53_USB_CLKONOFF_CTRL_H2_INT60CKOFF;\r\nwritel(val, reg);\r\n}\r\n}\r\nif (data->disable_oc) {\r\nreg = usbmisc->base + MX53_USB_UH2_CTRL_OFFSET;\r\nval = readl(reg) | MX53_BM_OVER_CUR_DIS_UHx;\r\nwritel(val, reg);\r\n}\r\nbreak;\r\ncase 3:\r\nif (data->ulpi) {\r\nreg = usbmisc->base + MX53_USB_CTRL_1_OFFSET;\r\nval = readl(reg) | MX53_USB_CTRL_1_UH3_ULPI_EN;\r\nval &= ~MX53_USB_CTRL_1_H3_XCVR_CLK_SEL_MASK;\r\nval |= MX53_USB_CTRL_1_H3_XCVR_CLK_SEL_ULPI;\r\nwritel(val, reg);\r\nreg = usbmisc->base + MX53_USB_UH3_CTRL_OFFSET;\r\nval = readl(reg) | MX53_USB_UHx_CTRL_WAKE_UP_EN\r\n| MX53_USB_UHx_CTRL_ULPI_INT_EN;\r\nwritel(val, reg);\r\nif (is_imx53_usbmisc(data)) {\r\nreg = usbmisc->base +\r\nMX53_USB_CLKONOFF_CTRL_OFFSET;\r\nval = readl(reg) |\r\nMX53_USB_CLKONOFF_CTRL_H3_INT60CKOFF;\r\nwritel(val, reg);\r\n}\r\n}\r\nif (data->disable_oc) {\r\nreg = usbmisc->base + MX53_USB_UH3_CTRL_OFFSET;\r\nval = readl(reg) | MX53_BM_OVER_CUR_DIS_UHx;\r\nwritel(val, reg);\r\n}\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&usbmisc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int usbmisc_imx6q_set_wakeup\r\n(struct imx_usbmisc_data *data, bool enabled)\r\n{\r\nstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\r\nunsigned long flags;\r\nu32 val;\r\nu32 wakeup_setting = (MX6_BM_WAKEUP_ENABLE |\r\nMX6_BM_VBUS_WAKEUP | MX6_BM_ID_WAKEUP);\r\nint ret = 0;\r\nif (data->index > 3)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&usbmisc->lock, flags);\r\nval = readl(usbmisc->base + data->index * 4);\r\nif (enabled) {\r\nval |= wakeup_setting;\r\nwritel(val, usbmisc->base + data->index * 4);\r\n} else {\r\nif (val & MX6_BM_WAKEUP_INTR)\r\npr_debug("wakeup int at ci_hdrc.%d\n", data->index);\r\nval &= ~wakeup_setting;\r\nwritel(val, usbmisc->base + data->index * 4);\r\n}\r\nspin_unlock_irqrestore(&usbmisc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int usbmisc_imx6q_init(struct imx_usbmisc_data *data)\r\n{\r\nstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\r\nunsigned long flags;\r\nu32 reg;\r\nif (data->index > 3)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&usbmisc->lock, flags);\r\nreg = readl(usbmisc->base + data->index * 4);\r\nif (data->disable_oc) {\r\nreg |= MX6_BM_OVER_CUR_DIS;\r\n} else if (data->oc_polarity == 1) {\r\nreg &= ~(MX6_BM_OVER_CUR_DIS | MX6_BM_OVER_CUR_POLARITY);\r\n}\r\nwritel(reg, usbmisc->base + data->index * 4);\r\nreg = readl(usbmisc->base + data->index * 4);\r\nwritel(reg | MX6_BM_NON_BURST_SETTING,\r\nusbmisc->base + data->index * 4);\r\nspin_unlock_irqrestore(&usbmisc->lock, flags);\r\nusbmisc_imx6q_set_wakeup(data, false);\r\nreturn 0;\r\n}\r\nstatic int usbmisc_imx6sx_init(struct imx_usbmisc_data *data)\r\n{\r\nvoid __iomem *reg = NULL;\r\nunsigned long flags;\r\nstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\r\nu32 val;\r\nusbmisc_imx6q_init(data);\r\nif (data->index == 0 || data->index == 1) {\r\nreg = usbmisc->base + MX6_USB_OTG1_PHY_CTRL + data->index * 4;\r\nspin_lock_irqsave(&usbmisc->lock, flags);\r\nval = readl(reg);\r\nwritel(val | MX6SX_USB_VBUS_WAKEUP_SOURCE_BVALID, reg);\r\nval = readl(usbmisc->base + data->index * 4);\r\nwritel(val & ~MX6SX_BM_DPDM_WAKEUP_EN,\r\nusbmisc->base + data->index * 4);\r\nspin_unlock_irqrestore(&usbmisc->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbmisc_vf610_init(struct imx_usbmisc_data *data)\r\n{\r\nstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\r\nu32 reg;\r\nif (data->index >= 1)\r\nreturn -EINVAL;\r\nif (data->disable_oc) {\r\nreg = readl(usbmisc->base);\r\nwritel(reg | VF610_OVER_CUR_DIS, usbmisc->base);\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbmisc_imx7d_set_wakeup\r\n(struct imx_usbmisc_data *data, bool enabled)\r\n{\r\nstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\r\nunsigned long flags;\r\nu32 val;\r\nu32 wakeup_setting = (MX6_BM_WAKEUP_ENABLE |\r\nMX6_BM_VBUS_WAKEUP | MX6_BM_ID_WAKEUP);\r\nspin_lock_irqsave(&usbmisc->lock, flags);\r\nval = readl(usbmisc->base);\r\nif (enabled) {\r\nwritel(val | wakeup_setting, usbmisc->base);\r\n} else {\r\nif (val & MX6_BM_WAKEUP_INTR)\r\ndev_dbg(data->dev, "wakeup int\n");\r\nwritel(val & ~wakeup_setting, usbmisc->base);\r\n}\r\nspin_unlock_irqrestore(&usbmisc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int usbmisc_imx7d_init(struct imx_usbmisc_data *data)\r\n{\r\nstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\r\nunsigned long flags;\r\nu32 reg;\r\nif (data->index >= 1)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&usbmisc->lock, flags);\r\nreg = readl(usbmisc->base);\r\nif (data->disable_oc) {\r\nreg |= MX6_BM_OVER_CUR_DIS;\r\n} else if (data->oc_polarity == 1) {\r\nreg &= ~(MX6_BM_OVER_CUR_DIS | MX6_BM_OVER_CUR_POLARITY);\r\n}\r\nwritel(reg, usbmisc->base);\r\nreg = readl(usbmisc->base + MX7D_USBNC_USB_CTRL2);\r\nreg &= ~MX7D_USB_VBUS_WAKEUP_SOURCE_MASK;\r\nwritel(reg | MX7D_USB_VBUS_WAKEUP_SOURCE_BVALID,\r\nusbmisc->base + MX7D_USBNC_USB_CTRL2);\r\nspin_unlock_irqrestore(&usbmisc->lock, flags);\r\nusbmisc_imx7d_set_wakeup(data, false);\r\nreturn 0;\r\n}\r\nstatic inline bool is_imx53_usbmisc(struct imx_usbmisc_data *data)\r\n{\r\nstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\r\nreturn usbmisc->ops == &imx53_usbmisc_ops;\r\n}\r\nint imx_usbmisc_init(struct imx_usbmisc_data *data)\r\n{\r\nstruct imx_usbmisc *usbmisc;\r\nif (!data)\r\nreturn 0;\r\nusbmisc = dev_get_drvdata(data->dev);\r\nif (!usbmisc->ops->init)\r\nreturn 0;\r\nreturn usbmisc->ops->init(data);\r\n}\r\nint imx_usbmisc_init_post(struct imx_usbmisc_data *data)\r\n{\r\nstruct imx_usbmisc *usbmisc;\r\nif (!data)\r\nreturn 0;\r\nusbmisc = dev_get_drvdata(data->dev);\r\nif (!usbmisc->ops->post)\r\nreturn 0;\r\nreturn usbmisc->ops->post(data);\r\n}\r\nint imx_usbmisc_set_wakeup(struct imx_usbmisc_data *data, bool enabled)\r\n{\r\nstruct imx_usbmisc *usbmisc;\r\nif (!data)\r\nreturn 0;\r\nusbmisc = dev_get_drvdata(data->dev);\r\nif (!usbmisc->ops->set_wakeup)\r\nreturn 0;\r\nreturn usbmisc->ops->set_wakeup(data, enabled);\r\n}\r\nstatic int usbmisc_imx_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct imx_usbmisc *data;\r\nconst struct of_device_id *of_id;\r\nof_id = of_match_device(usbmisc_imx_dt_ids, &pdev->dev);\r\nif (!of_id)\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nspin_lock_init(&data->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndata->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(data->base))\r\nreturn PTR_ERR(data->base);\r\ndata->ops = (const struct usbmisc_ops *)of_id->data;\r\nplatform_set_drvdata(pdev, data);\r\nreturn 0;\r\n}\r\nstatic int usbmisc_imx_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}
