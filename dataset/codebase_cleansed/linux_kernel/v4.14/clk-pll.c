static const struct rockchip_pll_rate_table *rockchip_get_pll_settings(\r\nstruct rockchip_clk_pll *pll, unsigned long rate)\r\n{\r\nconst struct rockchip_pll_rate_table *rate_table = pll->rate_table;\r\nint i;\r\nfor (i = 0; i < pll->rate_count; i++) {\r\nif (rate == rate_table[i].rate)\r\nreturn &rate_table[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic long rockchip_pll_round_rate(struct clk_hw *hw,\r\nunsigned long drate, unsigned long *prate)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nconst struct rockchip_pll_rate_table *rate_table = pll->rate_table;\r\nint i;\r\nfor (i = 0; i < pll->rate_count; i++) {\r\nif (drate >= rate_table[i].rate)\r\nreturn rate_table[i].rate;\r\n}\r\nreturn rate_table[i - 1].rate;\r\n}\r\nstatic int rockchip_pll_wait_lock(struct rockchip_clk_pll *pll)\r\n{\r\nstruct regmap *grf = pll->ctx->grf;\r\nunsigned int val;\r\nint delay = 24000000, ret;\r\nwhile (delay > 0) {\r\nret = regmap_read(grf, pll->lock_offset, &val);\r\nif (ret) {\r\npr_err("%s: failed to read pll lock status: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nif (val & BIT(pll->lock_shift))\r\nreturn 0;\r\ndelay--;\r\n}\r\npr_err("%s: timeout waiting for pll to lock\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void rockchip_rk3036_pll_get_params(struct rockchip_clk_pll *pll,\r\nstruct rockchip_pll_rate_table *rate)\r\n{\r\nu32 pllcon;\r\npllcon = readl_relaxed(pll->reg_base + RK3036_PLLCON(0));\r\nrate->fbdiv = ((pllcon >> RK3036_PLLCON0_FBDIV_SHIFT)\r\n& RK3036_PLLCON0_FBDIV_MASK);\r\nrate->postdiv1 = ((pllcon >> RK3036_PLLCON0_POSTDIV1_SHIFT)\r\n& RK3036_PLLCON0_POSTDIV1_MASK);\r\npllcon = readl_relaxed(pll->reg_base + RK3036_PLLCON(1));\r\nrate->refdiv = ((pllcon >> RK3036_PLLCON1_REFDIV_SHIFT)\r\n& RK3036_PLLCON1_REFDIV_MASK);\r\nrate->postdiv2 = ((pllcon >> RK3036_PLLCON1_POSTDIV2_SHIFT)\r\n& RK3036_PLLCON1_POSTDIV2_MASK);\r\nrate->dsmpd = ((pllcon >> RK3036_PLLCON1_DSMPD_SHIFT)\r\n& RK3036_PLLCON1_DSMPD_MASK);\r\npllcon = readl_relaxed(pll->reg_base + RK3036_PLLCON(2));\r\nrate->frac = ((pllcon >> RK3036_PLLCON2_FRAC_SHIFT)\r\n& RK3036_PLLCON2_FRAC_MASK);\r\n}\r\nstatic unsigned long rockchip_rk3036_pll_recalc_rate(struct clk_hw *hw,\r\nunsigned long prate)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nstruct rockchip_pll_rate_table cur;\r\nu64 rate64 = prate;\r\nrockchip_rk3036_pll_get_params(pll, &cur);\r\nrate64 *= cur.fbdiv;\r\ndo_div(rate64, cur.refdiv);\r\nif (cur.dsmpd == 0) {\r\nu64 frac_rate64 = prate * cur.frac;\r\ndo_div(frac_rate64, cur.refdiv);\r\nrate64 += frac_rate64 >> 24;\r\n}\r\ndo_div(rate64, cur.postdiv1);\r\ndo_div(rate64, cur.postdiv2);\r\nreturn (unsigned long)rate64;\r\n}\r\nstatic int rockchip_rk3036_pll_set_params(struct rockchip_clk_pll *pll,\r\nconst struct rockchip_pll_rate_table *rate)\r\n{\r\nconst struct clk_ops *pll_mux_ops = pll->pll_mux_ops;\r\nstruct clk_mux *pll_mux = &pll->pll_mux;\r\nstruct rockchip_pll_rate_table cur;\r\nu32 pllcon;\r\nint rate_change_remuxed = 0;\r\nint cur_parent;\r\nint ret;\r\npr_debug("%s: rate settings for %lu fbdiv: %d, postdiv1: %d, refdiv: %d, postdiv2: %d, dsmpd: %d, frac: %d\n",\r\n__func__, rate->rate, rate->fbdiv, rate->postdiv1, rate->refdiv,\r\nrate->postdiv2, rate->dsmpd, rate->frac);\r\nrockchip_rk3036_pll_get_params(pll, &cur);\r\ncur.rate = 0;\r\ncur_parent = pll_mux_ops->get_parent(&pll_mux->hw);\r\nif (cur_parent == PLL_MODE_NORM) {\r\npll_mux_ops->set_parent(&pll_mux->hw, PLL_MODE_SLOW);\r\nrate_change_remuxed = 1;\r\n}\r\nwritel_relaxed(HIWORD_UPDATE(rate->fbdiv, RK3036_PLLCON0_FBDIV_MASK,\r\nRK3036_PLLCON0_FBDIV_SHIFT) |\r\nHIWORD_UPDATE(rate->postdiv1, RK3036_PLLCON0_POSTDIV1_MASK,\r\nRK3036_PLLCON0_POSTDIV1_SHIFT),\r\npll->reg_base + RK3036_PLLCON(0));\r\nwritel_relaxed(HIWORD_UPDATE(rate->refdiv, RK3036_PLLCON1_REFDIV_MASK,\r\nRK3036_PLLCON1_REFDIV_SHIFT) |\r\nHIWORD_UPDATE(rate->postdiv2, RK3036_PLLCON1_POSTDIV2_MASK,\r\nRK3036_PLLCON1_POSTDIV2_SHIFT) |\r\nHIWORD_UPDATE(rate->dsmpd, RK3036_PLLCON1_DSMPD_MASK,\r\nRK3036_PLLCON1_DSMPD_SHIFT),\r\npll->reg_base + RK3036_PLLCON(1));\r\npllcon = readl_relaxed(pll->reg_base + RK3036_PLLCON(2));\r\npllcon &= ~(RK3036_PLLCON2_FRAC_MASK << RK3036_PLLCON2_FRAC_SHIFT);\r\npllcon |= rate->frac << RK3036_PLLCON2_FRAC_SHIFT;\r\nwritel_relaxed(pllcon, pll->reg_base + RK3036_PLLCON(2));\r\nret = rockchip_pll_wait_lock(pll);\r\nif (ret) {\r\npr_warn("%s: pll update unsuccessful, trying to restore old params\n",\r\n__func__);\r\nrockchip_rk3036_pll_set_params(pll, &cur);\r\n}\r\nif (rate_change_remuxed)\r\npll_mux_ops->set_parent(&pll_mux->hw, PLL_MODE_NORM);\r\nreturn ret;\r\n}\r\nstatic int rockchip_rk3036_pll_set_rate(struct clk_hw *hw, unsigned long drate,\r\nunsigned long prate)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nconst struct rockchip_pll_rate_table *rate;\r\npr_debug("%s: changing %s to %lu with a parent rate of %lu\n",\r\n__func__, __clk_get_name(hw->clk), drate, prate);\r\nrate = rockchip_get_pll_settings(pll, drate);\r\nif (!rate) {\r\npr_err("%s: Invalid rate : %lu for pll clk %s\n", __func__,\r\ndrate, __clk_get_name(hw->clk));\r\nreturn -EINVAL;\r\n}\r\nreturn rockchip_rk3036_pll_set_params(pll, rate);\r\n}\r\nstatic int rockchip_rk3036_pll_enable(struct clk_hw *hw)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nwritel(HIWORD_UPDATE(0, RK3036_PLLCON1_PWRDOWN, 0),\r\npll->reg_base + RK3036_PLLCON(1));\r\nrockchip_pll_wait_lock(pll);\r\nreturn 0;\r\n}\r\nstatic void rockchip_rk3036_pll_disable(struct clk_hw *hw)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nwritel(HIWORD_UPDATE(RK3036_PLLCON1_PWRDOWN,\r\nRK3036_PLLCON1_PWRDOWN, 0),\r\npll->reg_base + RK3036_PLLCON(1));\r\n}\r\nstatic int rockchip_rk3036_pll_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nu32 pllcon = readl(pll->reg_base + RK3036_PLLCON(1));\r\nreturn !(pllcon & RK3036_PLLCON1_PWRDOWN);\r\n}\r\nstatic void rockchip_rk3036_pll_init(struct clk_hw *hw)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nconst struct rockchip_pll_rate_table *rate;\r\nstruct rockchip_pll_rate_table cur;\r\nunsigned long drate;\r\nif (!(pll->flags & ROCKCHIP_PLL_SYNC_RATE))\r\nreturn;\r\ndrate = clk_hw_get_rate(hw);\r\nrate = rockchip_get_pll_settings(pll, drate);\r\nif (!rate)\r\nreturn;\r\nrockchip_rk3036_pll_get_params(pll, &cur);\r\npr_debug("%s: pll %s@%lu: Hz\n", __func__, __clk_get_name(hw->clk),\r\ndrate);\r\npr_debug("old - fbdiv: %d, postdiv1: %d, refdiv: %d, postdiv2: %d, dsmpd: %d, frac: %d\n",\r\ncur.fbdiv, cur.postdiv1, cur.refdiv, cur.postdiv2,\r\ncur.dsmpd, cur.frac);\r\npr_debug("new - fbdiv: %d, postdiv1: %d, refdiv: %d, postdiv2: %d, dsmpd: %d, frac: %d\n",\r\nrate->fbdiv, rate->postdiv1, rate->refdiv, rate->postdiv2,\r\nrate->dsmpd, rate->frac);\r\nif (rate->fbdiv != cur.fbdiv || rate->postdiv1 != cur.postdiv1 ||\r\nrate->refdiv != cur.refdiv || rate->postdiv2 != cur.postdiv2 ||\r\nrate->dsmpd != cur.dsmpd ||\r\n(!cur.dsmpd && (rate->frac != cur.frac))) {\r\nstruct clk *parent = clk_get_parent(hw->clk);\r\nif (!parent) {\r\npr_warn("%s: parent of %s not available\n",\r\n__func__, __clk_get_name(hw->clk));\r\nreturn;\r\n}\r\npr_debug("%s: pll %s: rate params do not match rate table, adjusting\n",\r\n__func__, __clk_get_name(hw->clk));\r\nrockchip_rk3036_pll_set_params(pll, rate);\r\n}\r\n}\r\nstatic void rockchip_rk3066_pll_get_params(struct rockchip_clk_pll *pll,\r\nstruct rockchip_pll_rate_table *rate)\r\n{\r\nu32 pllcon;\r\npllcon = readl_relaxed(pll->reg_base + RK3066_PLLCON(0));\r\nrate->nr = ((pllcon >> RK3066_PLLCON0_NR_SHIFT)\r\n& RK3066_PLLCON0_NR_MASK) + 1;\r\nrate->no = ((pllcon >> RK3066_PLLCON0_OD_SHIFT)\r\n& RK3066_PLLCON0_OD_MASK) + 1;\r\npllcon = readl_relaxed(pll->reg_base + RK3066_PLLCON(1));\r\nrate->nf = ((pllcon >> RK3066_PLLCON1_NF_SHIFT)\r\n& RK3066_PLLCON1_NF_MASK) + 1;\r\npllcon = readl_relaxed(pll->reg_base + RK3066_PLLCON(2));\r\nrate->nb = ((pllcon >> RK3066_PLLCON2_NB_SHIFT)\r\n& RK3066_PLLCON2_NB_MASK) + 1;\r\n}\r\nstatic unsigned long rockchip_rk3066_pll_recalc_rate(struct clk_hw *hw,\r\nunsigned long prate)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nstruct rockchip_pll_rate_table cur;\r\nu64 rate64 = prate;\r\nu32 pllcon;\r\npllcon = readl_relaxed(pll->reg_base + RK3066_PLLCON(3));\r\nif (pllcon & RK3066_PLLCON3_BYPASS) {\r\npr_debug("%s: pll %s is bypassed\n", __func__,\r\nclk_hw_get_name(hw));\r\nreturn prate;\r\n}\r\nrockchip_rk3066_pll_get_params(pll, &cur);\r\nrate64 *= cur.nf;\r\ndo_div(rate64, cur.nr);\r\ndo_div(rate64, cur.no);\r\nreturn (unsigned long)rate64;\r\n}\r\nstatic int rockchip_rk3066_pll_set_params(struct rockchip_clk_pll *pll,\r\nconst struct rockchip_pll_rate_table *rate)\r\n{\r\nconst struct clk_ops *pll_mux_ops = pll->pll_mux_ops;\r\nstruct clk_mux *pll_mux = &pll->pll_mux;\r\nstruct rockchip_pll_rate_table cur;\r\nint rate_change_remuxed = 0;\r\nint cur_parent;\r\nint ret;\r\npr_debug("%s: rate settings for %lu (nr, no, nf): (%d, %d, %d)\n",\r\n__func__, rate->rate, rate->nr, rate->no, rate->nf);\r\nrockchip_rk3066_pll_get_params(pll, &cur);\r\ncur.rate = 0;\r\ncur_parent = pll_mux_ops->get_parent(&pll_mux->hw);\r\nif (cur_parent == PLL_MODE_NORM) {\r\npll_mux_ops->set_parent(&pll_mux->hw, PLL_MODE_SLOW);\r\nrate_change_remuxed = 1;\r\n}\r\nwritel(HIWORD_UPDATE(RK3066_PLLCON3_RESET, RK3066_PLLCON3_RESET, 0),\r\npll->reg_base + RK3066_PLLCON(3));\r\nwritel(HIWORD_UPDATE(rate->nr - 1, RK3066_PLLCON0_NR_MASK,\r\nRK3066_PLLCON0_NR_SHIFT) |\r\nHIWORD_UPDATE(rate->no - 1, RK3066_PLLCON0_OD_MASK,\r\nRK3066_PLLCON0_OD_SHIFT),\r\npll->reg_base + RK3066_PLLCON(0));\r\nwritel_relaxed(HIWORD_UPDATE(rate->nf - 1, RK3066_PLLCON1_NF_MASK,\r\nRK3066_PLLCON1_NF_SHIFT),\r\npll->reg_base + RK3066_PLLCON(1));\r\nwritel_relaxed(HIWORD_UPDATE(rate->nb - 1, RK3066_PLLCON2_NB_MASK,\r\nRK3066_PLLCON2_NB_SHIFT),\r\npll->reg_base + RK3066_PLLCON(2));\r\nwritel(HIWORD_UPDATE(0, RK3066_PLLCON3_RESET, 0),\r\npll->reg_base + RK3066_PLLCON(3));\r\nudelay(RK3066_PLL_RESET_DELAY(rate->nr));\r\nret = rockchip_pll_wait_lock(pll);\r\nif (ret) {\r\npr_warn("%s: pll update unsuccessful, trying to restore old params\n",\r\n__func__);\r\nrockchip_rk3066_pll_set_params(pll, &cur);\r\n}\r\nif (rate_change_remuxed)\r\npll_mux_ops->set_parent(&pll_mux->hw, PLL_MODE_NORM);\r\nreturn ret;\r\n}\r\nstatic int rockchip_rk3066_pll_set_rate(struct clk_hw *hw, unsigned long drate,\r\nunsigned long prate)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nconst struct rockchip_pll_rate_table *rate;\r\npr_debug("%s: changing %s to %lu with a parent rate of %lu\n",\r\n__func__, clk_hw_get_name(hw), drate, prate);\r\nrate = rockchip_get_pll_settings(pll, drate);\r\nif (!rate) {\r\npr_err("%s: Invalid rate : %lu for pll clk %s\n", __func__,\r\ndrate, clk_hw_get_name(hw));\r\nreturn -EINVAL;\r\n}\r\nreturn rockchip_rk3066_pll_set_params(pll, rate);\r\n}\r\nstatic int rockchip_rk3066_pll_enable(struct clk_hw *hw)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nwritel(HIWORD_UPDATE(0, RK3066_PLLCON3_PWRDOWN, 0),\r\npll->reg_base + RK3066_PLLCON(3));\r\nrockchip_pll_wait_lock(pll);\r\nreturn 0;\r\n}\r\nstatic void rockchip_rk3066_pll_disable(struct clk_hw *hw)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nwritel(HIWORD_UPDATE(RK3066_PLLCON3_PWRDOWN,\r\nRK3066_PLLCON3_PWRDOWN, 0),\r\npll->reg_base + RK3066_PLLCON(3));\r\n}\r\nstatic int rockchip_rk3066_pll_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nu32 pllcon = readl(pll->reg_base + RK3066_PLLCON(3));\r\nreturn !(pllcon & RK3066_PLLCON3_PWRDOWN);\r\n}\r\nstatic void rockchip_rk3066_pll_init(struct clk_hw *hw)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nconst struct rockchip_pll_rate_table *rate;\r\nstruct rockchip_pll_rate_table cur;\r\nunsigned long drate;\r\nif (!(pll->flags & ROCKCHIP_PLL_SYNC_RATE))\r\nreturn;\r\ndrate = clk_hw_get_rate(hw);\r\nrate = rockchip_get_pll_settings(pll, drate);\r\nif (!rate)\r\nreturn;\r\nrockchip_rk3066_pll_get_params(pll, &cur);\r\npr_debug("%s: pll %s@%lu: nr (%d:%d); no (%d:%d); nf(%d:%d), nb(%d:%d)\n",\r\n__func__, clk_hw_get_name(hw), drate, rate->nr, cur.nr,\r\nrate->no, cur.no, rate->nf, cur.nf, rate->nb, cur.nb);\r\nif (rate->nr != cur.nr || rate->no != cur.no || rate->nf != cur.nf\r\n|| rate->nb != cur.nb) {\r\npr_debug("%s: pll %s: rate params do not match rate table, adjusting\n",\r\n__func__, clk_hw_get_name(hw));\r\nrockchip_rk3066_pll_set_params(pll, rate);\r\n}\r\n}\r\nstatic int rockchip_rk3399_pll_wait_lock(struct rockchip_clk_pll *pll)\r\n{\r\nu32 pllcon;\r\nint delay = 24000000;\r\nwhile (delay > 0) {\r\npllcon = readl_relaxed(pll->reg_base + RK3399_PLLCON(2));\r\nif (pllcon & RK3399_PLLCON2_LOCK_STATUS)\r\nreturn 0;\r\ndelay--;\r\n}\r\npr_err("%s: timeout waiting for pll to lock\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void rockchip_rk3399_pll_get_params(struct rockchip_clk_pll *pll,\r\nstruct rockchip_pll_rate_table *rate)\r\n{\r\nu32 pllcon;\r\npllcon = readl_relaxed(pll->reg_base + RK3399_PLLCON(0));\r\nrate->fbdiv = ((pllcon >> RK3399_PLLCON0_FBDIV_SHIFT)\r\n& RK3399_PLLCON0_FBDIV_MASK);\r\npllcon = readl_relaxed(pll->reg_base + RK3399_PLLCON(1));\r\nrate->refdiv = ((pllcon >> RK3399_PLLCON1_REFDIV_SHIFT)\r\n& RK3399_PLLCON1_REFDIV_MASK);\r\nrate->postdiv1 = ((pllcon >> RK3399_PLLCON1_POSTDIV1_SHIFT)\r\n& RK3399_PLLCON1_POSTDIV1_MASK);\r\nrate->postdiv2 = ((pllcon >> RK3399_PLLCON1_POSTDIV2_SHIFT)\r\n& RK3399_PLLCON1_POSTDIV2_MASK);\r\npllcon = readl_relaxed(pll->reg_base + RK3399_PLLCON(2));\r\nrate->frac = ((pllcon >> RK3399_PLLCON2_FRAC_SHIFT)\r\n& RK3399_PLLCON2_FRAC_MASK);\r\npllcon = readl_relaxed(pll->reg_base + RK3399_PLLCON(3));\r\nrate->dsmpd = ((pllcon >> RK3399_PLLCON3_DSMPD_SHIFT)\r\n& RK3399_PLLCON3_DSMPD_MASK);\r\n}\r\nstatic unsigned long rockchip_rk3399_pll_recalc_rate(struct clk_hw *hw,\r\nunsigned long prate)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nstruct rockchip_pll_rate_table cur;\r\nu64 rate64 = prate;\r\nrockchip_rk3399_pll_get_params(pll, &cur);\r\nrate64 *= cur.fbdiv;\r\ndo_div(rate64, cur.refdiv);\r\nif (cur.dsmpd == 0) {\r\nu64 frac_rate64 = prate * cur.frac;\r\ndo_div(frac_rate64, cur.refdiv);\r\nrate64 += frac_rate64 >> 24;\r\n}\r\ndo_div(rate64, cur.postdiv1);\r\ndo_div(rate64, cur.postdiv2);\r\nreturn (unsigned long)rate64;\r\n}\r\nstatic int rockchip_rk3399_pll_set_params(struct rockchip_clk_pll *pll,\r\nconst struct rockchip_pll_rate_table *rate)\r\n{\r\nconst struct clk_ops *pll_mux_ops = pll->pll_mux_ops;\r\nstruct clk_mux *pll_mux = &pll->pll_mux;\r\nstruct rockchip_pll_rate_table cur;\r\nu32 pllcon;\r\nint rate_change_remuxed = 0;\r\nint cur_parent;\r\nint ret;\r\npr_debug("%s: rate settings for %lu fbdiv: %d, postdiv1: %d, refdiv: %d, postdiv2: %d, dsmpd: %d, frac: %d\n",\r\n__func__, rate->rate, rate->fbdiv, rate->postdiv1, rate->refdiv,\r\nrate->postdiv2, rate->dsmpd, rate->frac);\r\nrockchip_rk3399_pll_get_params(pll, &cur);\r\ncur.rate = 0;\r\ncur_parent = pll_mux_ops->get_parent(&pll_mux->hw);\r\nif (cur_parent == PLL_MODE_NORM) {\r\npll_mux_ops->set_parent(&pll_mux->hw, PLL_MODE_SLOW);\r\nrate_change_remuxed = 1;\r\n}\r\nwritel_relaxed(HIWORD_UPDATE(rate->fbdiv, RK3399_PLLCON0_FBDIV_MASK,\r\nRK3399_PLLCON0_FBDIV_SHIFT),\r\npll->reg_base + RK3399_PLLCON(0));\r\nwritel_relaxed(HIWORD_UPDATE(rate->refdiv, RK3399_PLLCON1_REFDIV_MASK,\r\nRK3399_PLLCON1_REFDIV_SHIFT) |\r\nHIWORD_UPDATE(rate->postdiv1, RK3399_PLLCON1_POSTDIV1_MASK,\r\nRK3399_PLLCON1_POSTDIV1_SHIFT) |\r\nHIWORD_UPDATE(rate->postdiv2, RK3399_PLLCON1_POSTDIV2_MASK,\r\nRK3399_PLLCON1_POSTDIV2_SHIFT),\r\npll->reg_base + RK3399_PLLCON(1));\r\npllcon = readl_relaxed(pll->reg_base + RK3399_PLLCON(2));\r\npllcon &= ~(RK3399_PLLCON2_FRAC_MASK << RK3399_PLLCON2_FRAC_SHIFT);\r\npllcon |= rate->frac << RK3399_PLLCON2_FRAC_SHIFT;\r\nwritel_relaxed(pllcon, pll->reg_base + RK3399_PLLCON(2));\r\nwritel_relaxed(HIWORD_UPDATE(rate->dsmpd, RK3399_PLLCON3_DSMPD_MASK,\r\nRK3399_PLLCON3_DSMPD_SHIFT),\r\npll->reg_base + RK3399_PLLCON(3));\r\nret = rockchip_rk3399_pll_wait_lock(pll);\r\nif (ret) {\r\npr_warn("%s: pll update unsuccessful, trying to restore old params\n",\r\n__func__);\r\nrockchip_rk3399_pll_set_params(pll, &cur);\r\n}\r\nif (rate_change_remuxed)\r\npll_mux_ops->set_parent(&pll_mux->hw, PLL_MODE_NORM);\r\nreturn ret;\r\n}\r\nstatic int rockchip_rk3399_pll_set_rate(struct clk_hw *hw, unsigned long drate,\r\nunsigned long prate)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nconst struct rockchip_pll_rate_table *rate;\r\npr_debug("%s: changing %s to %lu with a parent rate of %lu\n",\r\n__func__, __clk_get_name(hw->clk), drate, prate);\r\nrate = rockchip_get_pll_settings(pll, drate);\r\nif (!rate) {\r\npr_err("%s: Invalid rate : %lu for pll clk %s\n", __func__,\r\ndrate, __clk_get_name(hw->clk));\r\nreturn -EINVAL;\r\n}\r\nreturn rockchip_rk3399_pll_set_params(pll, rate);\r\n}\r\nstatic int rockchip_rk3399_pll_enable(struct clk_hw *hw)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nwritel(HIWORD_UPDATE(0, RK3399_PLLCON3_PWRDOWN, 0),\r\npll->reg_base + RK3399_PLLCON(3));\r\nrockchip_rk3399_pll_wait_lock(pll);\r\nreturn 0;\r\n}\r\nstatic void rockchip_rk3399_pll_disable(struct clk_hw *hw)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nwritel(HIWORD_UPDATE(RK3399_PLLCON3_PWRDOWN,\r\nRK3399_PLLCON3_PWRDOWN, 0),\r\npll->reg_base + RK3399_PLLCON(3));\r\n}\r\nstatic int rockchip_rk3399_pll_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nu32 pllcon = readl(pll->reg_base + RK3399_PLLCON(3));\r\nreturn !(pllcon & RK3399_PLLCON3_PWRDOWN);\r\n}\r\nstatic void rockchip_rk3399_pll_init(struct clk_hw *hw)\r\n{\r\nstruct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);\r\nconst struct rockchip_pll_rate_table *rate;\r\nstruct rockchip_pll_rate_table cur;\r\nunsigned long drate;\r\nif (!(pll->flags & ROCKCHIP_PLL_SYNC_RATE))\r\nreturn;\r\ndrate = clk_hw_get_rate(hw);\r\nrate = rockchip_get_pll_settings(pll, drate);\r\nif (!rate)\r\nreturn;\r\nrockchip_rk3399_pll_get_params(pll, &cur);\r\npr_debug("%s: pll %s@%lu: Hz\n", __func__, __clk_get_name(hw->clk),\r\ndrate);\r\npr_debug("old - fbdiv: %d, postdiv1: %d, refdiv: %d, postdiv2: %d, dsmpd: %d, frac: %d\n",\r\ncur.fbdiv, cur.postdiv1, cur.refdiv, cur.postdiv2,\r\ncur.dsmpd, cur.frac);\r\npr_debug("new - fbdiv: %d, postdiv1: %d, refdiv: %d, postdiv2: %d, dsmpd: %d, frac: %d\n",\r\nrate->fbdiv, rate->postdiv1, rate->refdiv, rate->postdiv2,\r\nrate->dsmpd, rate->frac);\r\nif (rate->fbdiv != cur.fbdiv || rate->postdiv1 != cur.postdiv1 ||\r\nrate->refdiv != cur.refdiv || rate->postdiv2 != cur.postdiv2 ||\r\nrate->dsmpd != cur.dsmpd ||\r\n(!cur.dsmpd && (rate->frac != cur.frac))) {\r\nstruct clk *parent = clk_get_parent(hw->clk);\r\nif (!parent) {\r\npr_warn("%s: parent of %s not available\n",\r\n__func__, __clk_get_name(hw->clk));\r\nreturn;\r\n}\r\npr_debug("%s: pll %s: rate params do not match rate table, adjusting\n",\r\n__func__, __clk_get_name(hw->clk));\r\nrockchip_rk3399_pll_set_params(pll, rate);\r\n}\r\n}\r\nstruct clk *rockchip_clk_register_pll(struct rockchip_clk_provider *ctx,\r\nenum rockchip_pll_type pll_type,\r\nconst char *name, const char *const *parent_names,\r\nu8 num_parents, int con_offset, int grf_lock_offset,\r\nint lock_shift, int mode_offset, int mode_shift,\r\nstruct rockchip_pll_rate_table *rate_table,\r\nunsigned long flags, u8 clk_pll_flags)\r\n{\r\nconst char *pll_parents[3];\r\nstruct clk_init_data init;\r\nstruct rockchip_clk_pll *pll;\r\nstruct clk_mux *pll_mux;\r\nstruct clk *pll_clk, *mux_clk;\r\nchar pll_name[20];\r\nif ((pll_type != pll_rk3328 && num_parents != 2) ||\r\n(pll_type == pll_rk3328 && num_parents != 1)) {\r\npr_err("%s: needs two parent clocks\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nsnprintf(pll_name, sizeof(pll_name), "pll_%s", name);\r\npll = kzalloc(sizeof(*pll), GFP_KERNEL);\r\nif (!pll)\r\nreturn ERR_PTR(-ENOMEM);\r\npll->pll_mux_ops = &clk_mux_ops;\r\npll_mux = &pll->pll_mux;\r\npll_mux->reg = ctx->reg_base + mode_offset;\r\npll_mux->shift = mode_shift;\r\nif (pll_type == pll_rk3328)\r\npll_mux->mask = PLL_RK3328_MODE_MASK;\r\nelse\r\npll_mux->mask = PLL_MODE_MASK;\r\npll_mux->flags = 0;\r\npll_mux->lock = &ctx->lock;\r\npll_mux->hw.init = &init;\r\nif (pll_type == pll_rk3036 ||\r\npll_type == pll_rk3066 ||\r\npll_type == pll_rk3328 ||\r\npll_type == pll_rk3399)\r\npll_mux->flags |= CLK_MUX_HIWORD_MASK;\r\npll_parents[0] = parent_names[0];\r\npll_parents[1] = pll_name;\r\npll_parents[2] = parent_names[1];\r\ninit.name = name;\r\ninit.flags = CLK_SET_RATE_PARENT;\r\ninit.ops = pll->pll_mux_ops;\r\ninit.parent_names = pll_parents;\r\nif (pll_type == pll_rk3328)\r\ninit.num_parents = 2;\r\nelse\r\ninit.num_parents = ARRAY_SIZE(pll_parents);\r\nmux_clk = clk_register(NULL, &pll_mux->hw);\r\nif (IS_ERR(mux_clk))\r\ngoto err_mux;\r\ninit.name = pll_name;\r\ninit.flags = flags | CLK_IGNORE_UNUSED;\r\ninit.parent_names = &parent_names[0];\r\ninit.num_parents = 1;\r\nif (rate_table) {\r\nint len;\r\nfor (len = 0; rate_table[len].rate != 0; )\r\nlen++;\r\npll->rate_count = len;\r\npll->rate_table = kmemdup(rate_table,\r\npll->rate_count *\r\nsizeof(struct rockchip_pll_rate_table),\r\nGFP_KERNEL);\r\nWARN(!pll->rate_table,\r\n"%s: could not allocate rate table for %s\n",\r\n__func__, name);\r\n}\r\nswitch (pll_type) {\r\ncase pll_rk3036:\r\ncase pll_rk3328:\r\nif (!pll->rate_table || IS_ERR(ctx->grf))\r\ninit.ops = &rockchip_rk3036_pll_clk_norate_ops;\r\nelse\r\ninit.ops = &rockchip_rk3036_pll_clk_ops;\r\nbreak;\r\ncase pll_rk3066:\r\nif (!pll->rate_table || IS_ERR(ctx->grf))\r\ninit.ops = &rockchip_rk3066_pll_clk_norate_ops;\r\nelse\r\ninit.ops = &rockchip_rk3066_pll_clk_ops;\r\nbreak;\r\ncase pll_rk3399:\r\nif (!pll->rate_table)\r\ninit.ops = &rockchip_rk3399_pll_clk_norate_ops;\r\nelse\r\ninit.ops = &rockchip_rk3399_pll_clk_ops;\r\nbreak;\r\ndefault:\r\npr_warn("%s: Unknown pll type for pll clk %s\n",\r\n__func__, name);\r\n}\r\npll->hw.init = &init;\r\npll->type = pll_type;\r\npll->reg_base = ctx->reg_base + con_offset;\r\npll->lock_offset = grf_lock_offset;\r\npll->lock_shift = lock_shift;\r\npll->flags = clk_pll_flags;\r\npll->lock = &ctx->lock;\r\npll->ctx = ctx;\r\npll_clk = clk_register(NULL, &pll->hw);\r\nif (IS_ERR(pll_clk)) {\r\npr_err("%s: failed to register pll clock %s : %ld\n",\r\n__func__, name, PTR_ERR(pll_clk));\r\ngoto err_pll;\r\n}\r\nreturn mux_clk;\r\nerr_pll:\r\nclk_unregister(mux_clk);\r\nmux_clk = pll_clk;\r\nerr_mux:\r\nkfree(pll);\r\nreturn mux_clk;\r\n}
