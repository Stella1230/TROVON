void ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nint tmp;\r\nskb->pkt_type = IEEE80211_TX_STATUS_MSG;\r\nskb_queue_tail(info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS ?\r\n&local->skb_queue : &local->skb_queue_unreliable, skb);\r\ntmp = skb_queue_len(&local->skb_queue) +\r\nskb_queue_len(&local->skb_queue_unreliable);\r\nwhile (tmp > IEEE80211_IRQSAFE_QUEUE_LIMIT &&\r\n(skb = skb_dequeue(&local->skb_queue_unreliable))) {\r\nieee80211_free_txskb(hw, skb);\r\ntmp--;\r\nI802_DEBUG_INC(local->tx_status_drop);\r\n}\r\ntasklet_schedule(&local->tasklet);\r\n}\r\nstatic void ieee80211_handle_filtered_frame(struct ieee80211_local *local,\r\nstruct sta_info *sta,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr = (void *)skb->data;\r\nint ac;\r\nif (info->flags & (IEEE80211_TX_CTL_NO_PS_BUFFER |\r\nIEEE80211_TX_CTL_AMPDU)) {\r\nieee80211_free_txskb(&local->hw, skb);\r\nreturn;\r\n}\r\nmemset(&info->control, 0, sizeof(info->control));\r\ninfo->control.jiffies = jiffies;\r\ninfo->control.vif = &sta->sdata->vif;\r\ninfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING |\r\nIEEE80211_TX_INTFL_RETRANSMISSION;\r\ninfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\r\nsta->status_stats.filtered++;\r\nif (hdr->frame_control & cpu_to_le16(IEEE80211_FCTL_MOREDATA))\r\nhdr->frame_control &= ~cpu_to_le16(IEEE80211_FCTL_MOREDATA);\r\nif (ieee80211_is_data_qos(hdr->frame_control)) {\r\nu8 *p = ieee80211_get_qos_ctl(hdr);\r\nint tid = *p & IEEE80211_QOS_CTL_TID_MASK;\r\nif (*p & IEEE80211_QOS_CTL_EOSP)\r\n*p &= ~IEEE80211_QOS_CTL_EOSP;\r\nac = ieee80211_ac_from_tid(tid);\r\n} else {\r\nac = IEEE80211_AC_BE;\r\n}\r\nset_sta_flag(sta, WLAN_STA_CLEAR_PS_FILT);\r\nieee80211_clear_fast_xmit(sta);\r\nif (test_sta_flag(sta, WLAN_STA_PS_STA) &&\r\nskb_queue_len(&sta->tx_filtered[ac]) < STA_MAX_TX_BUFFER) {\r\nskb_queue_tail(&sta->tx_filtered[ac], skb);\r\nsta_info_recalc_tim(sta);\r\nif (!timer_pending(&local->sta_cleanup))\r\nmod_timer(&local->sta_cleanup,\r\nround_jiffies(jiffies +\r\nSTA_INFO_CLEANUP_INTERVAL));\r\nreturn;\r\n}\r\nif (!test_sta_flag(sta, WLAN_STA_PS_STA) &&\r\n!(info->flags & IEEE80211_TX_INTFL_RETRIED)) {\r\ninfo->flags |= IEEE80211_TX_INTFL_RETRIED;\r\nieee80211_add_pending_skb(local, skb);\r\nreturn;\r\n}\r\nps_dbg_ratelimited(sta->sdata,\r\n"dropped TX filtered frame, queue_len=%d PS=%d @%lu\n",\r\nskb_queue_len(&sta->tx_filtered[ac]),\r\n!!test_sta_flag(sta, WLAN_STA_PS_STA), jiffies);\r\nieee80211_free_txskb(&local->hw, skb);\r\n}\r\nstatic void ieee80211_check_pending_bar(struct sta_info *sta, u8 *addr, u8 tid)\r\n{\r\nstruct tid_ampdu_tx *tid_tx;\r\ntid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\r\nif (!tid_tx || !tid_tx->bar_pending)\r\nreturn;\r\ntid_tx->bar_pending = false;\r\nieee80211_send_bar(&sta->sdata->vif, addr, tid, tid_tx->failed_bar_ssn);\r\n}\r\nstatic void ieee80211_frame_acked(struct sta_info *sta, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_mgmt *mgmt = (void *) skb->data;\r\nstruct ieee80211_local *local = sta->local;\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nif (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))\r\nsta->status_stats.last_ack = jiffies;\r\nif (ieee80211_is_data_qos(mgmt->frame_control)) {\r\nstruct ieee80211_hdr *hdr = (void *) skb->data;\r\nu8 *qc = ieee80211_get_qos_ctl(hdr);\r\nu16 tid = qc[0] & 0xf;\r\nieee80211_check_pending_bar(sta, hdr->addr1, tid);\r\n}\r\nif (ieee80211_is_action(mgmt->frame_control) &&\r\n!ieee80211_has_protected(mgmt->frame_control) &&\r\nmgmt->u.action.category == WLAN_CATEGORY_HT &&\r\nmgmt->u.action.u.ht_smps.action == WLAN_HT_ACTION_SMPS &&\r\nieee80211_sdata_running(sdata)) {\r\nenum ieee80211_smps_mode smps_mode;\r\nswitch (mgmt->u.action.u.ht_smps.smps_control) {\r\ncase WLAN_HT_SMPS_CONTROL_DYNAMIC:\r\nsmps_mode = IEEE80211_SMPS_DYNAMIC;\r\nbreak;\r\ncase WLAN_HT_SMPS_CONTROL_STATIC:\r\nsmps_mode = IEEE80211_SMPS_STATIC;\r\nbreak;\r\ncase WLAN_HT_SMPS_CONTROL_DISABLED:\r\ndefault:\r\nsmps_mode = IEEE80211_SMPS_OFF;\r\nbreak;\r\n}\r\nif (sdata->vif.type == NL80211_IFTYPE_STATION) {\r\nsdata->smps_mode = smps_mode;\r\nieee80211_queue_work(&local->hw, &sdata->recalc_smps);\r\n} else if (sdata->vif.type == NL80211_IFTYPE_AP ||\r\nsdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\r\nsta->known_smps_mode = smps_mode;\r\n}\r\n}\r\n}\r\nstatic void ieee80211_set_bar_pending(struct sta_info *sta, u8 tid, u16 ssn)\r\n{\r\nstruct tid_ampdu_tx *tid_tx;\r\ntid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\r\nif (!tid_tx)\r\nreturn;\r\ntid_tx->failed_bar_ssn = ssn;\r\ntid_tx->bar_pending = true;\r\n}\r\nstatic int ieee80211_tx_radiotap_len(struct ieee80211_tx_info *info)\r\n{\r\nint len = sizeof(struct ieee80211_radiotap_header);\r\nif (info->status.rates[0].idx >= 0 &&\r\n!(info->status.rates[0].flags & (IEEE80211_TX_RC_MCS |\r\nIEEE80211_TX_RC_VHT_MCS)))\r\nlen += 2;\r\nlen += 2;\r\nlen += 1;\r\nif (info->status.rates[0].idx >= 0) {\r\nif (info->status.rates[0].flags & IEEE80211_TX_RC_MCS)\r\nlen += 3;\r\nelse if (info->status.rates[0].flags & IEEE80211_TX_RC_VHT_MCS)\r\nlen = ALIGN(len, 2) + 12;\r\n}\r\nreturn len;\r\n}\r\nstatic void\r\nieee80211_add_tx_radiotap_header(struct ieee80211_local *local,\r\nstruct ieee80211_supported_band *sband,\r\nstruct sk_buff *skb, int retry_count,\r\nint rtap_len, int shift)\r\n{\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct ieee80211_radiotap_header *rthdr;\r\nunsigned char *pos;\r\nu16 txflags;\r\nrthdr = skb_push(skb, rtap_len);\r\nmemset(rthdr, 0, rtap_len);\r\nrthdr->it_len = cpu_to_le16(rtap_len);\r\nrthdr->it_present =\r\ncpu_to_le32((1 << IEEE80211_RADIOTAP_TX_FLAGS) |\r\n(1 << IEEE80211_RADIOTAP_DATA_RETRIES));\r\npos = (unsigned char *)(rthdr + 1);\r\nif (info->status.rates[0].idx >= 0 &&\r\n!(info->status.rates[0].flags & (IEEE80211_TX_RC_MCS |\r\nIEEE80211_TX_RC_VHT_MCS))) {\r\nu16 rate;\r\nrthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_RATE);\r\nrate = sband->bitrates[info->status.rates[0].idx].bitrate;\r\n*pos = DIV_ROUND_UP(rate, 5 * (1 << shift));\r\npos += 2;\r\n}\r\ntxflags = 0;\r\nif (!(info->flags & IEEE80211_TX_STAT_ACK) &&\r\n!is_multicast_ether_addr(hdr->addr1))\r\ntxflags |= IEEE80211_RADIOTAP_F_TX_FAIL;\r\nif (info->status.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT)\r\ntxflags |= IEEE80211_RADIOTAP_F_TX_CTS;\r\nif (info->status.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS)\r\ntxflags |= IEEE80211_RADIOTAP_F_TX_RTS;\r\nput_unaligned_le16(txflags, pos);\r\npos += 2;\r\n*pos = retry_count;\r\npos++;\r\nif (info->status.rates[0].idx < 0)\r\nreturn;\r\nif (info->status.rates[0].flags & IEEE80211_TX_RC_MCS) {\r\nrthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_MCS);\r\npos[0] = IEEE80211_RADIOTAP_MCS_HAVE_MCS |\r\nIEEE80211_RADIOTAP_MCS_HAVE_GI |\r\nIEEE80211_RADIOTAP_MCS_HAVE_BW;\r\nif (info->status.rates[0].flags & IEEE80211_TX_RC_SHORT_GI)\r\npos[1] |= IEEE80211_RADIOTAP_MCS_SGI;\r\nif (info->status.rates[0].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\r\npos[1] |= IEEE80211_RADIOTAP_MCS_BW_40;\r\nif (info->status.rates[0].flags & IEEE80211_TX_RC_GREEN_FIELD)\r\npos[1] |= IEEE80211_RADIOTAP_MCS_FMT_GF;\r\npos[2] = info->status.rates[0].idx;\r\npos += 3;\r\n} else if (info->status.rates[0].flags & IEEE80211_TX_RC_VHT_MCS) {\r\nu16 known = local->hw.radiotap_vht_details &\r\n(IEEE80211_RADIOTAP_VHT_KNOWN_GI |\r\nIEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH);\r\nrthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_VHT);\r\npos = (u8 *)rthdr + ALIGN(pos - (u8 *)rthdr, 2);\r\nput_unaligned_le16(known, pos);\r\npos += 2;\r\nif (info->status.rates[0].flags & IEEE80211_TX_RC_SHORT_GI)\r\n*pos |= IEEE80211_RADIOTAP_VHT_FLAG_SGI;\r\npos++;\r\nif (info->status.rates[0].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\r\n*pos = 1;\r\nelse if (info->status.rates[0].flags & IEEE80211_TX_RC_80_MHZ_WIDTH)\r\n*pos = 4;\r\nelse if (info->status.rates[0].flags & IEEE80211_TX_RC_160_MHZ_WIDTH)\r\n*pos = 11;\r\nelse\r\n*pos = 0;\r\npos++;\r\n*pos = (ieee80211_rate_get_vht_mcs(&info->status.rates[0]) << 4) |\r\nieee80211_rate_get_vht_nss(&info->status.rates[0]);\r\npos += 4;\r\npos++;\r\npos++;\r\npos += 2;\r\n}\r\n}\r\nstatic void ieee80211_tdls_td_tx_handle(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb, u32 flags)\r\n{\r\nstruct sk_buff *teardown_skb;\r\nstruct sk_buff *orig_teardown_skb;\r\nbool is_teardown = false;\r\nspin_lock(&sdata->u.mgd.teardown_lock);\r\nteardown_skb = sdata->u.mgd.teardown_skb;\r\norig_teardown_skb = sdata->u.mgd.orig_teardown_skb;\r\nif ((skb == orig_teardown_skb) && teardown_skb) {\r\nsdata->u.mgd.teardown_skb = NULL;\r\nsdata->u.mgd.orig_teardown_skb = NULL;\r\nis_teardown = true;\r\n}\r\nspin_unlock(&sdata->u.mgd.teardown_lock);\r\nif (is_teardown) {\r\nWARN_ON(!ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS));\r\nif (flags & IEEE80211_TX_STAT_ACK) {\r\ndev_kfree_skb_any(teardown_skb);\r\n} else {\r\ntdls_dbg(sdata,\r\n"TDLS Resending teardown through AP\n");\r\nieee80211_subif_start_xmit(teardown_skb, skb->dev);\r\n}\r\n}\r\n}\r\nstatic struct ieee80211_sub_if_data *\r\nieee80211_sdata_from_skb(struct ieee80211_local *local, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_sub_if_data *sdata;\r\nif (skb->dev) {\r\nlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\r\nif (!sdata->dev)\r\ncontinue;\r\nif (skb->dev == sdata->dev)\r\nreturn sdata;\r\n}\r\nreturn NULL;\r\n}\r\nreturn rcu_dereference(local->p2p_sdata);\r\n}\r\nstatic void ieee80211_report_ack_skb(struct ieee80211_local *local,\r\nstruct ieee80211_tx_info *info,\r\nbool acked, bool dropped)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&local->ack_status_lock, flags);\r\nskb = idr_remove(&local->ack_status_frames, info->ack_frame_id);\r\nspin_unlock_irqrestore(&local->ack_status_lock, flags);\r\nif (!skb)\r\nreturn;\r\nif (dropped) {\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nif (info->flags & IEEE80211_TX_INTFL_NL80211_FRAME_TX) {\r\nu64 cookie = IEEE80211_SKB_CB(skb)->ack.cookie;\r\nstruct ieee80211_sub_if_data *sdata;\r\nstruct ieee80211_hdr *hdr = (void *)skb->data;\r\nrcu_read_lock();\r\nsdata = ieee80211_sdata_from_skb(local, skb);\r\nif (sdata) {\r\nif (ieee80211_is_nullfunc(hdr->frame_control) ||\r\nieee80211_is_qos_nullfunc(hdr->frame_control))\r\ncfg80211_probe_status(sdata->dev, hdr->addr1,\r\ncookie, acked,\r\nGFP_ATOMIC);\r\nelse\r\ncfg80211_mgmt_tx_status(&sdata->wdev, cookie,\r\nskb->data, skb->len,\r\nacked, GFP_ATOMIC);\r\n}\r\nrcu_read_unlock();\r\ndev_kfree_skb_any(skb);\r\n} else {\r\nskb_complete_wifi_ack(skb, acked);\r\n}\r\n}\r\nstatic void ieee80211_report_used_skb(struct ieee80211_local *local,\r\nstruct sk_buff *skb, bool dropped)\r\n{\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr = (void *)skb->data;\r\nbool acked = info->flags & IEEE80211_TX_STAT_ACK;\r\nif (dropped)\r\nacked = false;\r\nif (info->flags & IEEE80211_TX_INTFL_MLME_CONN_TX) {\r\nstruct ieee80211_sub_if_data *sdata;\r\nrcu_read_lock();\r\nsdata = ieee80211_sdata_from_skb(local, skb);\r\nif (!sdata) {\r\nskb->dev = NULL;\r\n} else {\r\nunsigned int hdr_size =\r\nieee80211_hdrlen(hdr->frame_control);\r\nif (ieee80211_is_data(hdr->frame_control) &&\r\n(ieee80211_get_tdls_action(skb, hdr_size) ==\r\nWLAN_TDLS_TEARDOWN))\r\nieee80211_tdls_td_tx_handle(local, sdata, skb,\r\ninfo->flags);\r\nelse\r\nieee80211_mgd_conn_tx_status(sdata,\r\nhdr->frame_control,\r\nacked);\r\n}\r\nrcu_read_unlock();\r\n} else if (info->ack_frame_id) {\r\nieee80211_report_ack_skb(local, info, acked, dropped);\r\n}\r\nif (!dropped && skb->destructor) {\r\nskb->wifi_acked_valid = 1;\r\nskb->wifi_acked = acked;\r\n}\r\nieee80211_led_tx(local);\r\n}\r\nstatic void ieee80211_lost_packet(struct sta_info *sta,\r\nstruct ieee80211_tx_info *info)\r\n{\r\nif (ieee80211_hw_check(&sta->local->hw, REPORTS_LOW_ACK))\r\nreturn;\r\nif ((info->flags & IEEE80211_TX_CTL_AMPDU) &&\r\n!(info->flags & IEEE80211_TX_STAT_AMPDU))\r\nreturn;\r\nsta->status_stats.lost_packets++;\r\nif (!sta->sta.tdls &&\r\nsta->status_stats.lost_packets < STA_LOST_PKT_THRESHOLD)\r\nreturn;\r\nif (sta->sta.tdls &&\r\n(sta->status_stats.lost_packets < STA_LOST_TDLS_PKT_THRESHOLD ||\r\ntime_before(jiffies,\r\nsta->status_stats.last_tdls_pkt_time +\r\nSTA_LOST_TDLS_PKT_TIME)))\r\nreturn;\r\ncfg80211_cqm_pktloss_notify(sta->sdata->dev, sta->sta.addr,\r\nsta->status_stats.lost_packets, GFP_ATOMIC);\r\nsta->status_stats.lost_packets = 0;\r\n}\r\nstatic int ieee80211_tx_get_rates(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_info *info,\r\nint *retry_count)\r\n{\r\nint rates_idx = -1;\r\nint count = -1;\r\nint i;\r\nfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\r\nif ((info->flags & IEEE80211_TX_CTL_AMPDU) &&\r\n!(info->flags & IEEE80211_TX_STAT_AMPDU)) {\r\ninfo->status.rates[i].idx = -1;\r\ninfo->status.rates[i].count = 0;\r\nbreak;\r\n} else if (info->status.rates[i].idx < 0) {\r\nbreak;\r\n} else if (i >= hw->max_report_rates) {\r\ninfo->status.rates[i].idx = -1;\r\ninfo->status.rates[i].count = 0;\r\nbreak;\r\n}\r\ncount += info->status.rates[i].count;\r\n}\r\nrates_idx = i - 1;\r\nif (count < 0)\r\ncount = 0;\r\n*retry_count = count;\r\nreturn rates_idx;\r\n}\r\nvoid ieee80211_tx_monitor(struct ieee80211_local *local, struct sk_buff *skb,\r\nstruct ieee80211_supported_band *sband,\r\nint retry_count, int shift, bool send_to_cooked)\r\n{\r\nstruct sk_buff *skb2;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_sub_if_data *sdata;\r\nstruct net_device *prev_dev = NULL;\r\nint rtap_len;\r\nrtap_len = ieee80211_tx_radiotap_len(info);\r\nif (WARN_ON_ONCE(skb_headroom(skb) < rtap_len)) {\r\npr_err("ieee80211_tx_status: headroom too small\n");\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nieee80211_add_tx_radiotap_header(local, sband, skb, retry_count,\r\nrtap_len, shift);\r\nskb_reset_mac_header(skb);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = htons(ETH_P_802_2);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\r\nif (sdata->vif.type == NL80211_IFTYPE_MONITOR) {\r\nif (!ieee80211_sdata_running(sdata))\r\ncontinue;\r\nif ((sdata->u.mntr.flags & MONITOR_FLAG_COOK_FRAMES) &&\r\n!send_to_cooked)\r\ncontinue;\r\nif (prev_dev) {\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (skb2) {\r\nskb2->dev = prev_dev;\r\nnetif_rx(skb2);\r\n}\r\n}\r\nprev_dev = sdata->dev;\r\n}\r\n}\r\nif (prev_dev) {\r\nskb->dev = prev_dev;\r\nnetif_rx(skb);\r\nskb = NULL;\r\n}\r\nrcu_read_unlock();\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void __ieee80211_tx_status(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_status *status)\r\n{\r\nstruct sk_buff *skb = status->skb;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\nstruct ieee80211_tx_info *info = status->info;\r\nstruct sta_info *sta;\r\n__le16 fc;\r\nstruct ieee80211_supported_band *sband;\r\nint retry_count;\r\nint rates_idx;\r\nbool send_to_cooked;\r\nbool acked;\r\nstruct ieee80211_bar *bar;\r\nint shift = 0;\r\nint tid = IEEE80211_NUM_TIDS;\r\nrates_idx = ieee80211_tx_get_rates(hw, info, &retry_count);\r\nsband = local->hw.wiphy->bands[info->band];\r\nfc = hdr->frame_control;\r\nif (status->sta) {\r\nsta = container_of(status->sta, struct sta_info, sta);\r\nshift = ieee80211_vif_get_shift(&sta->sdata->vif);\r\nif (info->flags & IEEE80211_TX_STATUS_EOSP)\r\nclear_sta_flag(sta, WLAN_STA_SP);\r\nacked = !!(info->flags & IEEE80211_TX_STAT_ACK);\r\nif (ieee80211_vif_is_mesh(&sta->sdata->vif) &&\r\nieee80211_is_data_qos(fc))\r\nieee80211_mpsp_trigger_process(\r\nieee80211_get_qos_ctl(hdr), sta, true, acked);\r\nif (!acked && test_sta_flag(sta, WLAN_STA_PS_STA)) {\r\nieee80211_handle_filtered_frame(local, sta, skb);\r\nreturn;\r\n}\r\nif (ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL) &&\r\n(ieee80211_is_data(hdr->frame_control)) &&\r\n(rates_idx != -1))\r\nsta->tx_stats.last_rate =\r\ninfo->status.rates[rates_idx];\r\nif ((info->flags & IEEE80211_TX_STAT_AMPDU_NO_BACK) &&\r\n(ieee80211_is_data_qos(fc))) {\r\nu16 ssn;\r\nu8 *qc;\r\nqc = ieee80211_get_qos_ctl(hdr);\r\ntid = qc[0] & 0xf;\r\nssn = ((le16_to_cpu(hdr->seq_ctrl) + 0x10)\r\n& IEEE80211_SCTL_SEQ);\r\nieee80211_send_bar(&sta->sdata->vif, hdr->addr1,\r\ntid, ssn);\r\n} else if (ieee80211_is_data_qos(fc)) {\r\nu8 *qc = ieee80211_get_qos_ctl(hdr);\r\ntid = qc[0] & 0xf;\r\n}\r\nif (!acked && ieee80211_is_back_req(fc)) {\r\nu16 control;\r\nbar = (struct ieee80211_bar *) skb->data;\r\ncontrol = le16_to_cpu(bar->control);\r\nif (!(control & IEEE80211_BAR_CTRL_MULTI_TID)) {\r\nu16 ssn = le16_to_cpu(bar->start_seq_num);\r\ntid = (control &\r\nIEEE80211_BAR_CTRL_TID_INFO_MASK) >>\r\nIEEE80211_BAR_CTRL_TID_INFO_SHIFT;\r\nieee80211_set_bar_pending(sta, tid, ssn);\r\n}\r\n}\r\nif (info->flags & IEEE80211_TX_STAT_TX_FILTERED) {\r\nieee80211_handle_filtered_frame(local, sta, skb);\r\nreturn;\r\n} else {\r\nif (!acked)\r\nsta->status_stats.retry_failed++;\r\nsta->status_stats.retry_count += retry_count;\r\nif (ieee80211_is_data_present(fc)) {\r\nif (!acked)\r\nsta->status_stats.msdu_failed[tid]++;\r\nsta->status_stats.msdu_retries[tid] +=\r\nretry_count;\r\n}\r\n}\r\nrate_control_tx_status(local, sband, status);\r\nif (ieee80211_vif_is_mesh(&sta->sdata->vif))\r\nieee80211s_update_metric(local, sta, skb);\r\nif (!(info->flags & IEEE80211_TX_CTL_INJECTED) && acked)\r\nieee80211_frame_acked(sta, skb);\r\nif ((sta->sdata->vif.type == NL80211_IFTYPE_STATION) &&\r\nieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))\r\nieee80211_sta_tx_notify(sta->sdata, (void *) skb->data,\r\nacked, info->status.tx_time);\r\nif (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {\r\nif (info->flags & IEEE80211_TX_STAT_ACK) {\r\nif (sta->status_stats.lost_packets)\r\nsta->status_stats.lost_packets = 0;\r\nif (test_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH))\r\nsta->status_stats.last_tdls_pkt_time =\r\njiffies;\r\n} else {\r\nieee80211_lost_packet(sta, info);\r\n}\r\n}\r\n}\r\nif ((info->flags & IEEE80211_TX_STAT_ACK) ||\r\n(info->flags & IEEE80211_TX_STAT_NOACK_TRANSMITTED)) {\r\nif (ieee80211_is_first_frag(hdr->seq_ctrl)) {\r\nI802_DEBUG_INC(local->dot11TransmittedFrameCount);\r\nif (is_multicast_ether_addr(ieee80211_get_DA(hdr)))\r\nI802_DEBUG_INC(local->dot11MulticastTransmittedFrameCount);\r\nif (retry_count > 0)\r\nI802_DEBUG_INC(local->dot11RetryCount);\r\nif (retry_count > 1)\r\nI802_DEBUG_INC(local->dot11MultipleRetryCount);\r\n}\r\nif (!is_multicast_ether_addr(hdr->addr1) ||\r\nieee80211_is_data(fc) ||\r\nieee80211_is_mgmt(fc))\r\nI802_DEBUG_INC(local->dot11TransmittedFragmentCount);\r\n} else {\r\nif (ieee80211_is_first_frag(hdr->seq_ctrl))\r\nI802_DEBUG_INC(local->dot11FailedCount);\r\n}\r\nif (ieee80211_is_nullfunc(fc) && ieee80211_has_pm(fc) &&\r\nieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS) &&\r\n!(info->flags & IEEE80211_TX_CTL_INJECTED) &&\r\nlocal->ps_sdata && !(local->scanning)) {\r\nif (info->flags & IEEE80211_TX_STAT_ACK) {\r\nlocal->ps_sdata->u.mgd.flags |=\r\nIEEE80211_STA_NULLFUNC_ACKED;\r\n} else\r\nmod_timer(&local->dynamic_ps_timer, jiffies +\r\nmsecs_to_jiffies(10));\r\n}\r\nieee80211_report_used_skb(local, skb, false);\r\nskb_orphan(skb);\r\nsend_to_cooked = !!(info->flags & IEEE80211_TX_CTL_INJECTED) ||\r\n!(ieee80211_is_data(fc));\r\nif (!local->monitors && (!send_to_cooked || !local->cooked_mntrs)) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nieee80211_tx_monitor(local, skb, sband, retry_count, shift, send_to_cooked);\r\n}\r\nvoid ieee80211_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\nstruct ieee80211_tx_status status = {\r\n.skb = skb,\r\n.info = IEEE80211_SKB_CB(skb),\r\n};\r\nstruct rhlist_head *tmp;\r\nstruct sta_info *sta;\r\nrcu_read_lock();\r\nfor_each_sta_info(local, hdr->addr1, sta, tmp) {\r\nif (!ether_addr_equal(hdr->addr2, sta->sdata->vif.addr))\r\ncontinue;\r\nstatus.sta = &sta->sta;\r\nbreak;\r\n}\r\n__ieee80211_tx_status(hw, &status);\r\nrcu_read_unlock();\r\n}\r\nvoid ieee80211_tx_status_ext(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_status *status)\r\n{\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\nstruct ieee80211_tx_info *info = status->info;\r\nstruct ieee80211_sta *pubsta = status->sta;\r\nstruct ieee80211_supported_band *sband;\r\nint retry_count;\r\nbool acked, noack_success;\r\nif (status->skb)\r\nreturn __ieee80211_tx_status(hw, status);\r\nif (!status->sta)\r\nreturn;\r\nieee80211_tx_get_rates(hw, info, &retry_count);\r\nsband = hw->wiphy->bands[info->band];\r\nacked = !!(info->flags & IEEE80211_TX_STAT_ACK);\r\nnoack_success = !!(info->flags & IEEE80211_TX_STAT_NOACK_TRANSMITTED);\r\nif (pubsta) {\r\nstruct sta_info *sta;\r\nsta = container_of(pubsta, struct sta_info, sta);\r\nif (!acked)\r\nsta->status_stats.retry_failed++;\r\nsta->status_stats.retry_count += retry_count;\r\nif (acked) {\r\nsta->status_stats.last_ack = jiffies;\r\nif (sta->status_stats.lost_packets)\r\nsta->status_stats.lost_packets = 0;\r\nif (test_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH))\r\nsta->status_stats.last_tdls_pkt_time = jiffies;\r\n} else {\r\nieee80211_lost_packet(sta, info);\r\n}\r\nrate_control_tx_status(local, sband, status);\r\n}\r\nif (acked || noack_success) {\r\nI802_DEBUG_INC(local->dot11TransmittedFrameCount);\r\nif (!pubsta)\r\nI802_DEBUG_INC(local->dot11MulticastTransmittedFrameCount);\r\nif (retry_count > 0)\r\nI802_DEBUG_INC(local->dot11RetryCount);\r\nif (retry_count > 1)\r\nI802_DEBUG_INC(local->dot11MultipleRetryCount);\r\n} else {\r\nI802_DEBUG_INC(local->dot11FailedCount);\r\n}\r\n}\r\nvoid ieee80211_report_low_ack(struct ieee80211_sta *pubsta, u32 num_packets)\r\n{\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\ncfg80211_cqm_pktloss_notify(sta->sdata->dev, sta->sta.addr,\r\nnum_packets, GFP_ATOMIC);\r\n}\r\nvoid ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\nieee80211_report_used_skb(local, skb, true);\r\ndev_kfree_skb_any(skb);\r\n}\r\nvoid ieee80211_purge_tx_queue(struct ieee80211_hw *hw,\r\nstruct sk_buff_head *skbs)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = __skb_dequeue(skbs)))\r\nieee80211_free_txskb(hw, skb);\r\n}
