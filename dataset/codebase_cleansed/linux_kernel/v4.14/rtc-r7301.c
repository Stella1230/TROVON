static u8 rtc7301_read(struct rtc7301_priv *priv, unsigned int reg)\r\n{\r\nint reg_stride = regmap_get_reg_stride(priv->regmap);\r\nunsigned int val;\r\nregmap_read(priv->regmap, reg_stride * reg, &val);\r\nreturn val & 0xf;\r\n}\r\nstatic void rtc7301_write(struct rtc7301_priv *priv, u8 val, unsigned int reg)\r\n{\r\nint reg_stride = regmap_get_reg_stride(priv->regmap);\r\nregmap_write(priv->regmap, reg_stride * reg, val);\r\n}\r\nstatic void rtc7301_update_bits(struct rtc7301_priv *priv, unsigned int reg,\r\nu8 mask, u8 val)\r\n{\r\nint reg_stride = regmap_get_reg_stride(priv->regmap);\r\nregmap_update_bits(priv->regmap, reg_stride * reg, mask, val);\r\n}\r\nstatic int rtc7301_wait_while_busy(struct rtc7301_priv *priv)\r\n{\r\nint retries = 100;\r\nwhile (retries-- > 0) {\r\nu8 val;\r\nval = rtc7301_read(priv, RTC7301_CONTROL);\r\nif (!(val & RTC7301_CONTROL_BUSY))\r\nreturn 0;\r\nusleep_range(200, 300);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void rtc7301_stop(struct rtc7301_priv *priv)\r\n{\r\nrtc7301_update_bits(priv, RTC7301_CONTROL, RTC7301_CONTROL_STOP,\r\nRTC7301_CONTROL_STOP);\r\n}\r\nstatic void rtc7301_start(struct rtc7301_priv *priv)\r\n{\r\nrtc7301_update_bits(priv, RTC7301_CONTROL, RTC7301_CONTROL_STOP, 0);\r\n}\r\nstatic void rtc7301_select_bank(struct rtc7301_priv *priv, u8 bank)\r\n{\r\nu8 val = 0;\r\nif (bank == priv->bank)\r\nreturn;\r\nif (bank & BIT(0))\r\nval |= RTC7301_CONTROL_BANK_SEL_0;\r\nif (bank & BIT(1))\r\nval |= RTC7301_CONTROL_BANK_SEL_1;\r\nrtc7301_update_bits(priv, RTC7301_CONTROL,\r\nRTC7301_CONTROL_BANK_SEL_0 |\r\nRTC7301_CONTROL_BANK_SEL_1, val);\r\npriv->bank = bank;\r\n}\r\nstatic void rtc7301_get_time(struct rtc7301_priv *priv, struct rtc_time *tm,\r\nbool alarm)\r\n{\r\nint year;\r\ntm->tm_sec = rtc7301_read(priv, RTC7301_1_SEC);\r\ntm->tm_sec += (rtc7301_read(priv, RTC7301_10_SEC) & ~RTC7301_AE) * 10;\r\ntm->tm_min = rtc7301_read(priv, RTC7301_1_MIN);\r\ntm->tm_min += (rtc7301_read(priv, RTC7301_10_MIN) & ~RTC7301_AE) * 10;\r\ntm->tm_hour = rtc7301_read(priv, RTC7301_1_HOUR);\r\ntm->tm_hour += (rtc7301_read(priv, RTC7301_10_HOUR) & ~RTC7301_AE) * 10;\r\ntm->tm_mday = rtc7301_read(priv, RTC7301_1_DAY);\r\ntm->tm_mday += (rtc7301_read(priv, RTC7301_10_DAY) & ~RTC7301_AE) * 10;\r\nif (alarm) {\r\ntm->tm_wday = -1;\r\ntm->tm_mon = -1;\r\ntm->tm_year = -1;\r\ntm->tm_yday = -1;\r\ntm->tm_isdst = -1;\r\nreturn;\r\n}\r\ntm->tm_wday = (rtc7301_read(priv, RTC7301_DAY_OF_WEEK) & ~RTC7301_AE);\r\ntm->tm_mon = rtc7301_read(priv, RTC7301_10_MONTH) * 10 +\r\nrtc7301_read(priv, RTC7301_1_MONTH) - 1;\r\nyear = rtc7301_read(priv, RTC7301_1000_YEAR) * 1000 +\r\nrtc7301_read(priv, RTC7301_100_YEAR) * 100 +\r\nrtc7301_read(priv, RTC7301_10_YEAR) * 10 +\r\nrtc7301_read(priv, RTC7301_1_YEAR);\r\ntm->tm_year = year - 1900;\r\n}\r\nstatic void rtc7301_write_time(struct rtc7301_priv *priv, struct rtc_time *tm,\r\nbool alarm)\r\n{\r\nint year;\r\nrtc7301_write(priv, tm->tm_sec % 10, RTC7301_1_SEC);\r\nrtc7301_write(priv, tm->tm_sec / 10, RTC7301_10_SEC);\r\nrtc7301_write(priv, tm->tm_min % 10, RTC7301_1_MIN);\r\nrtc7301_write(priv, tm->tm_min / 10, RTC7301_10_MIN);\r\nrtc7301_write(priv, tm->tm_hour % 10, RTC7301_1_HOUR);\r\nrtc7301_write(priv, tm->tm_hour / 10, RTC7301_10_HOUR);\r\nrtc7301_write(priv, tm->tm_mday % 10, RTC7301_1_DAY);\r\nrtc7301_write(priv, tm->tm_mday / 10, RTC7301_10_DAY);\r\nrtc7301_write(priv, alarm ? RTC7301_AE : tm->tm_wday,\r\nRTC7301_DAY_OF_WEEK);\r\nif (alarm)\r\nreturn;\r\nrtc7301_write(priv, (tm->tm_mon + 1) % 10, RTC7301_1_MONTH);\r\nrtc7301_write(priv, (tm->tm_mon + 1) / 10, RTC7301_10_MONTH);\r\nyear = tm->tm_year + 1900;\r\nrtc7301_write(priv, year % 10, RTC7301_1_YEAR);\r\nrtc7301_write(priv, (year / 10) % 10, RTC7301_10_YEAR);\r\nrtc7301_write(priv, (year / 100) % 10, RTC7301_100_YEAR);\r\nrtc7301_write(priv, year / 1000, RTC7301_1000_YEAR);\r\n}\r\nstatic void rtc7301_alarm_irq(struct rtc7301_priv *priv, unsigned int enabled)\r\n{\r\nrtc7301_update_bits(priv, RTC7301_ALARM_CONTROL,\r\nRTC7301_ALARM_CONTROL_AF |\r\nRTC7301_ALARM_CONTROL_AIE,\r\nenabled ? RTC7301_ALARM_CONTROL_AIE : 0);\r\n}\r\nstatic int rtc7301_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct rtc7301_priv *priv = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nrtc7301_select_bank(priv, 0);\r\nerr = rtc7301_wait_while_busy(priv);\r\nif (!err)\r\nrtc7301_get_time(priv, tm, false);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn err ? err : rtc_valid_tm(tm);\r\n}\r\nstatic int rtc7301_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct rtc7301_priv *priv = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nrtc7301_stop(priv);\r\nusleep_range(200, 300);\r\nrtc7301_select_bank(priv, 0);\r\nrtc7301_write_time(priv, tm, false);\r\nrtc7301_start(priv);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int rtc7301_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct rtc7301_priv *priv = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nu8 alrm_ctrl;\r\nif (priv->irq <= 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nrtc7301_select_bank(priv, 1);\r\nrtc7301_get_time(priv, &alarm->time, true);\r\nalrm_ctrl = rtc7301_read(priv, RTC7301_ALARM_CONTROL);\r\nalarm->enabled = !!(alrm_ctrl & RTC7301_ALARM_CONTROL_AIE);\r\nalarm->pending = !!(alrm_ctrl & RTC7301_ALARM_CONTROL_AF);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int rtc7301_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct rtc7301_priv *priv = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nif (priv->irq <= 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nrtc7301_select_bank(priv, 1);\r\nrtc7301_write_time(priv, &alarm->time, true);\r\nrtc7301_alarm_irq(priv, alarm->enabled);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int rtc7301_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct rtc7301_priv *priv = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nif (priv->irq <= 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nrtc7301_select_bank(priv, 1);\r\nrtc7301_alarm_irq(priv, enabled);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t rtc7301_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct rtc_device *rtc = dev_id;\r\nstruct rtc7301_priv *priv = dev_get_drvdata(rtc->dev.parent);\r\nunsigned long flags;\r\nirqreturn_t ret = IRQ_NONE;\r\nu8 alrm_ctrl;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nrtc7301_select_bank(priv, 1);\r\nalrm_ctrl = rtc7301_read(priv, RTC7301_ALARM_CONTROL);\r\nif (alrm_ctrl & RTC7301_ALARM_CONTROL_AF) {\r\nret = IRQ_HANDLED;\r\nrtc7301_alarm_irq(priv, false);\r\nrtc_update_irq(rtc, 1, RTC_IRQF | RTC_AF);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void rtc7301_init(struct rtc7301_priv *priv)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nrtc7301_select_bank(priv, 2);\r\nrtc7301_write(priv, 0, RTC7301_TIMER_CONTROL);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic int __init rtc7301_rtc_probe(struct platform_device *dev)\r\n{\r\nstruct resource *res;\r\nvoid __iomem *regs;\r\nstruct rtc7301_priv *priv;\r\nstruct rtc_device *rtc;\r\nint ret;\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\npriv = devm_kzalloc(&dev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nregs = devm_ioremap_resource(&dev->dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\npriv->regmap = devm_regmap_init_mmio(&dev->dev, regs,\r\n&rtc7301_regmap_config);\r\nif (IS_ERR(priv->regmap))\r\nreturn PTR_ERR(priv->regmap);\r\npriv->irq = platform_get_irq(dev, 0);\r\nspin_lock_init(&priv->lock);\r\npriv->bank = -1;\r\nrtc7301_init(priv);\r\nplatform_set_drvdata(dev, priv);\r\nrtc = devm_rtc_device_register(&dev->dev, DRV_NAME, &rtc7301_rtc_ops,\r\nTHIS_MODULE);\r\nif (IS_ERR(rtc))\r\nreturn PTR_ERR(rtc);\r\nif (priv->irq > 0) {\r\nret = devm_request_irq(&dev->dev, priv->irq,\r\nrtc7301_irq_handler, IRQF_SHARED,\r\ndev_name(&dev->dev), rtc);\r\nif (ret) {\r\npriv->irq = 0;\r\ndev_err(&dev->dev, "unable to request IRQ\n");\r\n} else {\r\ndevice_set_wakeup_capable(&dev->dev, true);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtc7301_suspend(struct device *dev)\r\n{\r\nstruct rtc7301_priv *priv = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(priv->irq);\r\nreturn 0;\r\n}\r\nstatic int rtc7301_resume(struct device *dev)\r\n{\r\nstruct rtc7301_priv *priv = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(priv->irq);\r\nreturn 0;\r\n}
