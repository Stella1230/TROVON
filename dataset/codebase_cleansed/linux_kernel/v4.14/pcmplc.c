static void start_pcm_timer0(struct s_smc *smc, u_long value, int event,\r\nstruct s_phy *phy)\r\n{\r\nphy->timer0_exp = FALSE ;\r\nsmt_timer_start(smc,&phy->pcm_timer0,value,\r\nEV_TOKEN(EVENT_PCM+phy->np,event)) ;\r\n}\r\nstatic void stop_pcm_timer0(struct s_smc *smc, struct s_phy *phy)\r\n{\r\nif (phy->pcm_timer0.tm_active)\r\nsmt_timer_stop(smc,&phy->pcm_timer0) ;\r\n}\r\nvoid pcm_init(struct s_smc *smc)\r\n{\r\nint i ;\r\nint np ;\r\nstruct s_phy *phy ;\r\nstruct fddi_mib_p *mib ;\r\nfor (np = 0,phy = smc->y ; np < NUMPHYS ; np++,phy++) {\r\nmib = phy->mib ;\r\nmib->fddiPORTPCMState = ACTIONS(PC0_OFF) ;\r\nphy->np = np ;\r\nswitch (smc->s.sas) {\r\n#ifdef CONCENTRATOR\r\ncase SMT_SAS :\r\nmib->fddiPORTMy_Type = (np == PS) ? TS : TM ;\r\nbreak ;\r\ncase SMT_DAS :\r\nmib->fddiPORTMy_Type = (np == PA) ? TA :\r\n(np == PB) ? TB : TM ;\r\nbreak ;\r\ncase SMT_NAC :\r\nmib->fddiPORTMy_Type = TM ;\r\nbreak;\r\n#else\r\ncase SMT_SAS :\r\nmib->fddiPORTMy_Type = (np == PS) ? TS : TNONE ;\r\nmib->fddiPORTHardwarePresent = (np == PS) ? TRUE :\r\nFALSE ;\r\n#ifndef SUPERNET_3\r\nsmc->y[PA].mib->fddiPORTPCMState = PC0_OFF ;\r\n#else\r\nsmc->y[PB].mib->fddiPORTPCMState = PC0_OFF ;\r\n#endif\r\nbreak ;\r\ncase SMT_DAS :\r\nmib->fddiPORTMy_Type = (np == PB) ? TB : TA ;\r\nbreak ;\r\n#endif\r\n}\r\nphy->pmd_scramble = 0 ;\r\nswitch (phy->pmd_type[PMD_SK_PMD]) {\r\ncase 'P' :\r\nmib->fddiPORTPMDClass = MIB_PMDCLASS_MULTI ;\r\nbreak ;\r\ncase 'L' :\r\nmib->fddiPORTPMDClass = MIB_PMDCLASS_LCF ;\r\nbreak ;\r\ncase 'D' :\r\nmib->fddiPORTPMDClass = MIB_PMDCLASS_TP ;\r\nbreak ;\r\ncase 'S' :\r\nmib->fddiPORTPMDClass = MIB_PMDCLASS_TP ;\r\nphy->pmd_scramble = TRUE ;\r\nbreak ;\r\ncase 'U' :\r\nmib->fddiPORTPMDClass = MIB_PMDCLASS_TP ;\r\nphy->pmd_scramble = TRUE ;\r\nbreak ;\r\ncase '1' :\r\nmib->fddiPORTPMDClass = MIB_PMDCLASS_SINGLE1 ;\r\nbreak ;\r\ncase '2' :\r\nmib->fddiPORTPMDClass = MIB_PMDCLASS_SINGLE2 ;\r\nbreak ;\r\ncase '3' :\r\nmib->fddiPORTPMDClass = MIB_PMDCLASS_SINGLE2 ;\r\nbreak ;\r\ncase '4' :\r\nmib->fddiPORTPMDClass = MIB_PMDCLASS_SINGLE1 ;\r\nbreak ;\r\ncase 'H' :\r\nmib->fddiPORTPMDClass = MIB_PMDCLASS_UNKNOWN ;\r\nbreak ;\r\ncase 'I' :\r\nmib->fddiPORTPMDClass = MIB_PMDCLASS_TP ;\r\nbreak ;\r\ncase 'G' :\r\nmib->fddiPORTPMDClass = MIB_PMDCLASS_TP ;\r\nbreak ;\r\ndefault:\r\nmib->fddiPORTPMDClass = MIB_PMDCLASS_UNKNOWN ;\r\nbreak ;\r\n}\r\nswitch (mib->fddiPORTMy_Type) {\r\ncase TA :\r\nmib->fddiPORTAvailablePaths |= MIB_PATH_S ;\r\nmib->fddiPORTRequestedPaths[1] = MIB_P_PATH_LOCAL ;\r\nmib->fddiPORTRequestedPaths[2] =\r\nMIB_P_PATH_LOCAL |\r\nMIB_P_PATH_CON_ALTER |\r\nMIB_P_PATH_SEC_PREFER ;\r\nmib->fddiPORTRequestedPaths[3] =\r\nMIB_P_PATH_LOCAL |\r\nMIB_P_PATH_CON_ALTER |\r\nMIB_P_PATH_SEC_PREFER |\r\nMIB_P_PATH_THRU ;\r\nbreak ;\r\ncase TB :\r\nmib->fddiPORTAvailablePaths |= MIB_PATH_S ;\r\nmib->fddiPORTRequestedPaths[1] = MIB_P_PATH_LOCAL ;\r\nmib->fddiPORTRequestedPaths[2] =\r\nMIB_P_PATH_LOCAL |\r\nMIB_P_PATH_PRIM_PREFER ;\r\nmib->fddiPORTRequestedPaths[3] =\r\nMIB_P_PATH_LOCAL |\r\nMIB_P_PATH_PRIM_PREFER |\r\nMIB_P_PATH_CON_PREFER |\r\nMIB_P_PATH_THRU ;\r\nbreak ;\r\ncase TS :\r\nmib->fddiPORTAvailablePaths |= MIB_PATH_S ;\r\nmib->fddiPORTRequestedPaths[1] = MIB_P_PATH_LOCAL ;\r\nmib->fddiPORTRequestedPaths[2] =\r\nMIB_P_PATH_LOCAL |\r\nMIB_P_PATH_CON_ALTER |\r\nMIB_P_PATH_PRIM_PREFER ;\r\nmib->fddiPORTRequestedPaths[3] =\r\nMIB_P_PATH_LOCAL |\r\nMIB_P_PATH_CON_ALTER |\r\nMIB_P_PATH_PRIM_PREFER ;\r\nbreak ;\r\ncase TM :\r\nmib->fddiPORTRequestedPaths[1] = MIB_P_PATH_LOCAL ;\r\nmib->fddiPORTRequestedPaths[2] =\r\nMIB_P_PATH_LOCAL |\r\nMIB_P_PATH_SEC_ALTER |\r\nMIB_P_PATH_PRIM_ALTER ;\r\nmib->fddiPORTRequestedPaths[3] = 0 ;\r\nbreak ;\r\n}\r\nphy->pc_lem_fail = FALSE ;\r\nmib->fddiPORTPCMStateX = mib->fddiPORTPCMState ;\r\nmib->fddiPORTLCTFail_Ct = 0 ;\r\nmib->fddiPORTBS_Flag = 0 ;\r\nmib->fddiPORTCurrentPath = MIB_PATH_ISOLATED ;\r\nmib->fddiPORTNeighborType = TNONE ;\r\nphy->ls_flag = 0 ;\r\nphy->rc_flag = 0 ;\r\nphy->tc_flag = 0 ;\r\nphy->td_flag = 0 ;\r\nif (np >= PM)\r\nphy->phy_name = '0' + np - PM ;\r\nelse\r\nphy->phy_name = 'A' + np ;\r\nphy->wc_flag = FALSE ;\r\nmemset((char *)&phy->lem,0,sizeof(struct lem_counter)) ;\r\nreset_lem_struct(phy) ;\r\nmemset((char *)&phy->plc,0,sizeof(struct s_plc)) ;\r\nphy->plc.p_state = PS_OFF ;\r\nfor (i = 0 ; i < NUMBITS ; i++) {\r\nphy->t_next[i] = 0 ;\r\n}\r\n}\r\nreal_init_plc(smc) ;\r\n}\r\nvoid init_plc(struct s_smc *smc)\r\n{\r\nSK_UNUSED(smc) ;\r\n}\r\nstatic void real_init_plc(struct s_smc *smc)\r\n{\r\nint p ;\r\nfor (p = 0 ; p < NUMPHYS ; p++)\r\nplc_init(smc,p) ;\r\n}\r\nstatic void plc_init(struct s_smc *smc, int p)\r\n{\r\nint i ;\r\n#ifndef MOT_ELM\r\nint rev ;\r\n#endif\r\noutpw(PLC(p,PL_CNTRL_B),0) ;\r\noutpw(PLC(p,PL_CNTRL_B),PL_PCM_STOP) ;\r\noutpw(PLC(p,PL_CNTRL_A),0) ;\r\n#ifndef MOT_ELM\r\nrev = inpw(PLC(p,PL_STATUS_A)) & PLC_REV_MASK ;\r\nif (rev != PLC_REVISION_A)\r\n#endif\r\n{\r\nif (smc->y[p].pmd_scramble) {\r\noutpw(PLC(p,PL_CNTRL_C),PLCS_CONTROL_C_S) ;\r\n#ifdef MOT_ELM\r\noutpw(PLC(p,PL_T_FOT_ASS),PLCS_FASSERT_S) ;\r\noutpw(PLC(p,PL_T_FOT_DEASS),PLCS_FDEASSERT_S) ;\r\n#endif\r\n}\r\nelse {\r\noutpw(PLC(p,PL_CNTRL_C),PLCS_CONTROL_C_U) ;\r\n#ifdef MOT_ELM\r\noutpw(PLC(p,PL_T_FOT_ASS),PLCS_FASSERT_U) ;\r\noutpw(PLC(p,PL_T_FOT_DEASS),PLCS_FDEASSERT_U) ;\r\n#endif\r\n}\r\n}\r\nfor ( i = 0 ; pltm[i].timer; i++)\r\noutpw(PLC(p,pltm[i].timer),pltm[i].para) ;\r\n(void)inpw(PLC(p,PL_INTR_EVENT)) ;\r\nplc_clear_irq(smc,p) ;\r\noutpw(PLC(p,PL_INTR_MASK),plc_imsk_na);\r\n#ifndef CONCENTRATOR\r\nif ((smc->s.sas == SMT_SAS) && (p == PS)) {\r\noutpw(PLC(p,PL_CNTRL_B),PL_CLASS_S) ;\r\n}\r\n#endif\r\n}\r\nstatic void plc_go_state(struct s_smc *smc, int p, int state)\r\n{\r\nHW_PTR port ;\r\nint val ;\r\nSK_UNUSED(smc) ;\r\nport = (HW_PTR) (PLC(p,PL_CNTRL_B)) ;\r\nval = inpw(port) & ~(PL_PCM_CNTRL | PL_MAINT) ;\r\noutpw(port,val) ;\r\noutpw(port,val | state) ;\r\n}\r\nint sm_pm_get_ls(struct s_smc *smc, int phy)\r\n{\r\nint state ;\r\n#ifdef CONCENTRATOR\r\nif (!plc_is_installed(smc,phy))\r\nreturn PC_QLS;\r\n#endif\r\nstate = inpw(PLC(phy,PL_STATUS_A)) & PL_LINE_ST ;\r\nswitch(state) {\r\ncase PL_L_QLS:\r\nstate = PC_QLS ;\r\nbreak ;\r\ncase PL_L_MLS:\r\nstate = PC_MLS ;\r\nbreak ;\r\ncase PL_L_HLS:\r\nstate = PC_HLS ;\r\nbreak ;\r\ncase PL_L_ILS4:\r\ncase PL_L_ILS16:\r\nstate = PC_ILS ;\r\nbreak ;\r\ncase PL_L_ALS:\r\nstate = PC_LS_PDR ;\r\nbreak ;\r\ndefault :\r\nstate = PC_LS_NONE ;\r\n}\r\nreturn state;\r\n}\r\nstatic int plc_send_bits(struct s_smc *smc, struct s_phy *phy, int len)\r\n{\r\nint np = phy->np ;\r\nint n ;\r\nint i ;\r\nSK_UNUSED(smc) ;\r\nfor (i = len-1,n = 0 ; i >= 0 ; i--) {\r\nn = (n<<1) | phy->t_val[phy->bitn+i] ;\r\n}\r\nif (inpw(PLC(np,PL_STATUS_B)) & PL_PCM_SIGNAL) {\r\n#if 0\r\nprintf("PL_PCM_SIGNAL is set\n") ;\r\n#endif\r\nreturn 1;\r\n}\r\noutpw(PLC(np,PL_VECTOR_LEN),len-1) ;\r\noutpw(PLC(np,PL_XMIT_VECTOR),n) ;\r\n#ifdef DEBUG\r\n#if 1\r\n#ifdef DEBUG_BRD\r\nif (smc->debug.d_plc & 0x80)\r\n#else\r\nif (debug.d_plc & 0x80)\r\n#endif\r\nprintf("SIGNALING bit %d .. %d\n",phy->bitn,phy->bitn+len-1) ;\r\n#endif\r\n#endif\r\nreturn 0;\r\n}\r\nvoid plc_config_mux(struct s_smc *smc, int mux)\r\n{\r\nif (smc->s.sas != SMT_DAS)\r\nreturn ;\r\nif (mux == MUX_WRAPB) {\r\nSETMASK(PLC(PA,PL_CNTRL_B),PL_CONFIG_CNTRL,PL_CONFIG_CNTRL) ;\r\nSETMASK(PLC(PA,PL_CNTRL_A),PL_SC_REM_LOOP,PL_SC_REM_LOOP) ;\r\n}\r\nelse {\r\nCLEAR(PLC(PA,PL_CNTRL_B),PL_CONFIG_CNTRL) ;\r\nCLEAR(PLC(PA,PL_CNTRL_A),PL_SC_REM_LOOP) ;\r\n}\r\nCLEAR(PLC(PB,PL_CNTRL_B),PL_CONFIG_CNTRL) ;\r\nCLEAR(PLC(PB,PL_CNTRL_A),PL_SC_REM_LOOP) ;\r\n}\r\nvoid pcm(struct s_smc *smc, const int np, int event)\r\n{\r\nint state ;\r\nint oldstate ;\r\nstruct s_phy *phy ;\r\nstruct fddi_mib_p *mib ;\r\n#ifndef CONCENTRATOR\r\nif ((np != PS) && (smc->s.sas == SMT_SAS))\r\nreturn ;\r\n#endif\r\nphy = &smc->y[np] ;\r\nmib = phy->mib ;\r\noldstate = mib->fddiPORTPCMState ;\r\ndo {\r\nDB_PCM("PCM %c: state %s%s, event %s",\r\nphy->phy_name,\r\nmib->fddiPORTPCMState & AFLAG ? "ACTIONS " : "",\r\npcm_states[mib->fddiPORTPCMState & ~AFLAG],\r\npcm_events[event]);\r\nstate = mib->fddiPORTPCMState ;\r\npcm_fsm(smc,phy,event) ;\r\nevent = 0 ;\r\n} while (state != mib->fddiPORTPCMState) ;\r\nif (state == PC5_SIGNAL)\r\nmib->fddiPORTPCMStateX = PC3_CONNECT ;\r\nelse\r\nmib->fddiPORTPCMStateX = state ;\r\n#ifndef SLIM_SMT\r\nif ( mib->fddiPORTPCMState != oldstate &&\r\n((oldstate == PC8_ACTIVE) || (mib->fddiPORTPCMState == PC8_ACTIVE))) {\r\nsmt_srf_event(smc,SMT_EVENT_PORT_PATH_CHANGE,\r\n(int) (INDEX_PORT+ phy->np),0) ;\r\n}\r\n#endif\r\n#ifdef FDDI_MIB\r\nif ( mib->fddiPORTPCMState != oldstate ) {\r\nDB_SNMP ("PCM from %d to %d\n", oldstate, mib->fddiPORTPCMState);\r\nif ( mib->fddiPORTPCMState == PC0_OFF ) {\r\nsnmp_fddi_trap (smc, 1, (int) mib->fddiPORTIndex );\r\n} else if ( oldstate == PC0_OFF ) {\r\nsnmp_fddi_trap (smc, 2, (int) mib->fddiPORTIndex );\r\n} else if ( mib->fddiPORTPCMState != PC2_TRACE &&\r\noldstate == PC8_ACTIVE ) {\r\nsnmp_fddi_trap (smc, 3, (int) mib->fddiPORTIndex );\r\n} else if ( mib->fddiPORTPCMState == PC8_ACTIVE ) {\r\nsnmp_fddi_trap (smc, 4, (int) mib->fddiPORTIndex );\r\n}\r\n}\r\n#endif\r\npcm_state_change(smc,np,state) ;\r\n}\r\nstatic void pcm_fsm(struct s_smc *smc, struct s_phy *phy, int cmd)\r\n{\r\nint i ;\r\nint np = phy->np ;\r\nstruct s_plc *plc ;\r\nstruct fddi_mib_p *mib ;\r\n#ifndef MOT_ELM\r\nu_short plc_rev ;\r\n#endif\r\nplc = &phy->plc ;\r\nmib = phy->mib ;\r\nswitch (cmd) {\r\ncase PC_STOP :\r\nif (mib->fddiPORTPCMState != PC9_MAINT) {\r\nGO_STATE(PC0_OFF) ;\r\nAIX_EVENT(smc, (u_long) FDDI_RING_STATUS, (u_long)\r\nFDDI_PORT_EVENT, (u_long) FDDI_PORT_STOP,\r\nsmt_get_port_event_word(smc));\r\n}\r\nreturn ;\r\ncase PC_START :\r\nif (mib->fddiPORTPCMState != PC9_MAINT)\r\nGO_STATE(PC1_BREAK) ;\r\nreturn ;\r\ncase PC_DISABLE :\r\nGO_STATE(PC9_MAINT) ;\r\nAIX_EVENT(smc, (u_long) FDDI_RING_STATUS, (u_long)\r\nFDDI_PORT_EVENT, (u_long) FDDI_PORT_DISABLED,\r\nsmt_get_port_event_word(smc));\r\nreturn ;\r\ncase PC_TIMEOUT_LCT :\r\nstop_pcm_timer0(smc,phy) ;\r\nCLEAR(PLC(np,PL_CNTRL_B),PL_LONG) ;\r\nreturn ;\r\n}\r\nswitch(mib->fddiPORTPCMState) {\r\ncase ACTIONS(PC0_OFF) :\r\nstop_pcm_timer0(smc,phy) ;\r\noutpw(PLC(np,PL_CNTRL_A),0) ;\r\nCLEAR(PLC(np,PL_CNTRL_B),PL_PC_JOIN) ;\r\nCLEAR(PLC(np,PL_CNTRL_B),PL_LONG) ;\r\nsm_ph_lem_stop(smc,np) ;\r\nphy->cf_loop = FALSE ;\r\nphy->cf_join = FALSE ;\r\nqueue_event(smc,EVENT_CFM,CF_JOIN+np) ;\r\nplc_go_state(smc,np,PL_PCM_STOP) ;\r\nmib->fddiPORTConnectState = PCM_DISABLED ;\r\nACTIONS_DONE() ;\r\nbreak ;\r\ncase PC0_OFF:\r\nif (cmd == PC_MAINT) {\r\nGO_STATE(PC9_MAINT) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase ACTIONS(PC1_BREAK) :\r\nstop_pcm_timer0(smc,phy) ;\r\nACTIONS_DONE() ;\r\nplc_go_state(smc,np,0) ;\r\nCLEAR(PLC(np,PL_CNTRL_B),PL_PC_JOIN) ;\r\nCLEAR(PLC(np,PL_CNTRL_B),PL_LONG) ;\r\nsm_ph_lem_stop(smc,np) ;\r\n#if 0\r\nif (inpw(PLC(np,PL_STATUS_B)) & PL_PCM_SIGNAL) {\r\nplc_go_state(smc,np,PL_PCM_STOP) ;\r\n}\r\n#endif\r\nplc_go_state(smc,np,PL_PCM_STOP) ;\r\nif (mib->fddiPORTPC_Withhold == PC_WH_NONE)\r\nmib->fddiPORTConnectState = PCM_CONNECTING ;\r\nphy->cf_loop = FALSE ;\r\nphy->cf_join = FALSE ;\r\nqueue_event(smc,EVENT_CFM,CF_JOIN+np) ;\r\nphy->ls_flag = FALSE ;\r\nphy->pc_mode = PM_NONE ;\r\nphy->bitn = 0 ;\r\nfor (i = 0 ; i < 3 ; i++)\r\npc_tcode_actions(smc,i,phy) ;\r\noutpw(PLC(np,PL_INTR_MASK),plc_imsk_na) ;\r\n(void)inpw(PLC(np,PL_INTR_EVENT)) ;\r\n#ifndef MOT_ELM\r\nplc_rev = inpw(PLC(np,PL_STATUS_A)) & PLC_REV_MASK ;\r\nif (plc_rev != PLC_REV_SN3)\r\n#endif\r\n{\r\nif (plc_send_bits(smc,phy,3)) {\r\nreturn ;\r\n}\r\n}\r\nplc_go_state(smc,np,PL_PCM_START) ;\r\n#ifdef MOT_ELM\r\nif (!(inpw(PLC(np,PL_STATUS_B)) & PL_PCM_SIGNAL))\r\n#else\r\nif (((inpw(PLC(np,PL_STATUS_A)) & PLC_REV_MASK) !=\r\nPLC_REVISION_A) &&\r\n!(inpw(PLC(np,PL_STATUS_B)) & PL_PCM_SIGNAL))\r\n#endif\r\n{\r\n(void) plc_send_bits(smc,phy,3) ;\r\n}\r\nGO_STATE(PC5_SIGNAL) ;\r\nplc->p_state = PS_BIT3 ;\r\nplc->p_bits = 3 ;\r\nplc->p_start = 0 ;\r\nbreak ;\r\ncase PC1_BREAK :\r\nbreak ;\r\ncase ACTIONS(PC2_TRACE) :\r\nplc_go_state(smc,np,PL_PCM_TRACE) ;\r\nACTIONS_DONE() ;\r\nbreak ;\r\ncase PC2_TRACE :\r\nbreak ;\r\ncase PC3_CONNECT :\r\ncase PC4_NEXT :\r\nbreak ;\r\ncase ACTIONS(PC5_SIGNAL) :\r\nACTIONS_DONE() ;\r\ncase PC5_SIGNAL :\r\nif ((cmd != PC_SIGNAL) && (cmd != PC_TIMEOUT_LCT))\r\nbreak ;\r\nswitch (plc->p_state) {\r\ncase PS_BIT3 :\r\nfor (i = 0 ; i <= 2 ; i++)\r\npc_rcode_actions(smc,i,phy) ;\r\npc_tcode_actions(smc,3,phy) ;\r\nplc->p_state = PS_BIT4 ;\r\nplc->p_bits = 1 ;\r\nplc->p_start = 3 ;\r\nphy->bitn = 3 ;\r\nif (plc_send_bits(smc,phy,1)) {\r\nreturn ;\r\n}\r\nbreak ;\r\ncase PS_BIT4 :\r\npc_rcode_actions(smc,3,phy) ;\r\nfor (i = 4 ; i <= 6 ; i++)\r\npc_tcode_actions(smc,i,phy) ;\r\nplc->p_state = PS_BIT7 ;\r\nplc->p_bits = 3 ;\r\nplc->p_start = 4 ;\r\nphy->bitn = 4 ;\r\nif (plc_send_bits(smc,phy,3)) {\r\nreturn ;\r\n}\r\nbreak ;\r\ncase PS_BIT7 :\r\nfor (i = 3 ; i <= 6 ; i++)\r\npc_rcode_actions(smc,i,phy) ;\r\nplc->p_state = PS_LCT ;\r\nplc->p_bits = 0 ;\r\nplc->p_start = 7 ;\r\nphy->bitn = 7 ;\r\nsm_ph_lem_start(smc,np,(int)smc->s.lct_short) ;\r\ni = inpw(PLC(np,PL_CNTRL_B)) & ~PL_PC_LOOP ;\r\noutpw(PLC(np,PL_CNTRL_B),i) ;\r\noutpw(PLC(np,PL_CNTRL_B),i | PL_RLBP) ;\r\nbreak ;\r\ncase PS_LCT :\r\npc_tcode_actions(smc,7,phy) ;\r\nplc->p_state = PS_BIT8 ;\r\nplc->p_bits = 1 ;\r\nplc->p_start = 7 ;\r\nphy->bitn = 7 ;\r\nif (plc_send_bits(smc,phy,1)) {\r\nreturn ;\r\n}\r\nbreak ;\r\ncase PS_BIT8 :\r\npc_rcode_actions(smc,7,phy) ;\r\nif (phy->t_val[7] || phy->r_val[7]) {\r\nplc_go_state(smc,np,PL_PCM_STOP) ;\r\nGO_STATE(PC1_BREAK) ;\r\nbreak ;\r\n}\r\nfor (i = 8 ; i <= 9 ; i++)\r\npc_tcode_actions(smc,i,phy) ;\r\nplc->p_state = PS_JOIN ;\r\nplc->p_bits = 2 ;\r\nplc->p_start = 8 ;\r\nphy->bitn = 8 ;\r\nif (plc_send_bits(smc,phy,2)) {\r\nreturn ;\r\n}\r\nbreak ;\r\ncase PS_JOIN :\r\nfor (i = 8 ; i <= 9 ; i++)\r\npc_rcode_actions(smc,i,phy) ;\r\nplc->p_state = PS_ACTIVE ;\r\nGO_STATE(PC6_JOIN) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase ACTIONS(PC6_JOIN) :\r\nif (smc->s.sas == SMT_DAS && np == PB &&\r\n(smc->y[PA].pc_mode == PM_TREE ||\r\nsmc->y[PB].pc_mode == PM_TREE)) {\r\nSETMASK(PLC(np,PL_CNTRL_A),\r\nPL_SC_REM_LOOP,PL_SC_REM_LOOP) ;\r\nSETMASK(PLC(np,PL_CNTRL_B),\r\nPL_CONFIG_CNTRL,PL_CONFIG_CNTRL) ;\r\n}\r\nSETMASK(PLC(np,PL_CNTRL_B),PL_PC_JOIN,PL_PC_JOIN) ;\r\nSETMASK(PLC(np,PL_CNTRL_B),PL_PC_JOIN,PL_PC_JOIN) ;\r\nACTIONS_DONE() ;\r\ncmd = 0 ;\r\ncase PC6_JOIN :\r\nswitch (plc->p_state) {\r\ncase PS_ACTIVE:\r\nif (!phy->cf_join) {\r\nphy->cf_join = TRUE ;\r\nqueue_event(smc,EVENT_CFM,CF_JOIN+np) ;\r\n}\r\nif (cmd == PC_JOIN)\r\nGO_STATE(PC8_ACTIVE) ;\r\nif (cmd == PC_TRACE) {\r\nGO_STATE(PC2_TRACE) ;\r\nbreak ;\r\n}\r\nbreak ;\r\n}\r\nbreak ;\r\ncase PC7_VERIFY :\r\nbreak ;\r\ncase ACTIONS(PC8_ACTIVE) :\r\nsm_ph_lem_start(smc,(int)phy->np,LCT_LEM_MAX) ;\r\nphy->tr_flag = FALSE ;\r\nmib->fddiPORTConnectState = PCM_ACTIVE ;\r\noutpw(PLC(np,PL_INTR_MASK),plc_imsk_act) ;\r\nACTIONS_DONE() ;\r\nbreak ;\r\ncase PC8_ACTIVE :\r\nif (cmd == PC_TRACE) {\r\nGO_STATE(PC2_TRACE) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase ACTIONS(PC9_MAINT) :\r\nstop_pcm_timer0(smc,phy) ;\r\nCLEAR(PLC(np,PL_CNTRL_B),PL_PC_JOIN) ;\r\nCLEAR(PLC(np,PL_CNTRL_B),PL_LONG) ;\r\nCLEAR(PLC(np,PL_INTR_MASK),PL_LE_CTR) ;\r\nsm_ph_lem_stop(smc,np) ;\r\nphy->cf_loop = FALSE ;\r\nphy->cf_join = FALSE ;\r\nqueue_event(smc,EVENT_CFM,CF_JOIN+np) ;\r\nplc_go_state(smc,np,PL_PCM_STOP) ;\r\nmib->fddiPORTConnectState = PCM_DISABLED ;\r\nSETMASK(PLC(np,PL_CNTRL_B),PL_MAINT,PL_MAINT) ;\r\nsm_ph_linestate(smc,np,(int) MIB2LS(mib->fddiPORTMaint_LS)) ;\r\noutpw(PLC(np,PL_CNTRL_A),PL_SC_BYPASS) ;\r\nACTIONS_DONE() ;\r\nbreak ;\r\ncase PC9_MAINT :\r\nDB_PCMN(1, "PCM %c : MAINT", phy->phy_name);\r\nif (cmd == PC_ENABLE) {\r\nGO_STATE(PC0_OFF) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ndefault:\r\nSMT_PANIC(smc,SMT_E0118, SMT_E0118_MSG) ;\r\nbreak ;\r\n}\r\n}\r\nstatic void sm_ph_linestate(struct s_smc *smc, int phy, int ls)\r\n{\r\nint cntrl ;\r\nSK_UNUSED(smc) ;\r\ncntrl = (inpw(PLC(phy,PL_CNTRL_B)) & ~PL_MAINT_LS) |\r\nPL_PCM_STOP | PL_MAINT ;\r\nswitch(ls) {\r\ncase PC_QLS:\r\ncntrl |= PL_M_QUI0 ;\r\nbreak ;\r\ncase PC_MLS:\r\ncntrl |= PL_M_MASTR ;\r\nbreak ;\r\ncase PC_HLS:\r\ncntrl |= PL_M_HALT ;\r\nbreak ;\r\ndefault :\r\ncase PC_ILS:\r\ncntrl |= PL_M_IDLE ;\r\nbreak ;\r\ncase PC_LS_PDR:\r\ncntrl |= PL_M_TPDR ;\r\nbreak ;\r\n}\r\noutpw(PLC(phy,PL_CNTRL_B),cntrl) ;\r\n}\r\nstatic void reset_lem_struct(struct s_phy *phy)\r\n{\r\nstruct lem_counter *lem = &phy->lem ;\r\nphy->mib->fddiPORTLer_Estimate = 15 ;\r\nlem->lem_float_ber = 15 * 100 ;\r\n}\r\nstatic void lem_evaluate(struct s_smc *smc, struct s_phy *phy)\r\n{\r\nint ber ;\r\nu_long errors ;\r\nstruct lem_counter *lem = &phy->lem ;\r\nstruct fddi_mib_p *mib ;\r\nint cond ;\r\nmib = phy->mib ;\r\nif (!lem->lem_on)\r\nreturn ;\r\nerrors = inpw(PLC(((int) phy->np),PL_LINK_ERR_CTR)) ;\r\nlem->lem_errors += errors ;\r\nmib->fddiPORTLem_Ct += errors ;\r\nerrors = lem->lem_errors ;\r\nif (!errors) ber = 15 ;\r\nelse if (errors <= 9) ber = 9 ;\r\nelse if (errors <= 99) ber = 8 ;\r\nelse if (errors <= 999) ber = 7 ;\r\nelse if (errors <= 9999) ber = 6 ;\r\nelse if (errors <= 99999) ber = 5 ;\r\nelse if (errors <= 999999) ber = 4 ;\r\nelse if (errors <= 9999999) ber = 3 ;\r\nelse if (errors <= 99999999) ber = 2 ;\r\nelse if (errors <= 999999999) ber = 1 ;\r\nelse ber = 0 ;\r\nber *= 100 ;\r\nlem->lem_float_ber = lem->lem_float_ber * 7 + ber * 3 ;\r\nlem->lem_float_ber /= 10 ;\r\nmib->fddiPORTLer_Estimate = lem->lem_float_ber / 100 ;\r\nif (mib->fddiPORTLer_Estimate < 4) {\r\nmib->fddiPORTLer_Estimate = 4 ;\r\n}\r\nif (lem->lem_errors) {\r\nDB_PCMN(1, "LEM %c :", phy->np == PB ? 'B' : 'A');\r\nDB_PCMN(1, "errors : %ld", lem->lem_errors);\r\nDB_PCMN(1, "sum_errors : %ld", mib->fddiPORTLem_Ct);\r\nDB_PCMN(1, "current BER : 10E-%d", ber / 100);\r\nDB_PCMN(1, "float BER : 10E-(%d/100)", lem->lem_float_ber);\r\nDB_PCMN(1, "avg. BER : 10E-%d", mib->fddiPORTLer_Estimate);\r\n}\r\nlem->lem_errors = 0L ;\r\n#ifndef SLIM_SMT\r\ncond = (mib->fddiPORTLer_Estimate <= mib->fddiPORTLer_Alarm) ?\r\nTRUE : FALSE ;\r\n#ifdef SMT_EXT_CUTOFF\r\nsmt_ler_alarm_check(smc,phy,cond) ;\r\n#endif\r\nif (cond != mib->fddiPORTLerFlag) {\r\nsmt_srf_event(smc,SMT_COND_PORT_LER,\r\n(int) (INDEX_PORT+ phy->np) ,cond) ;\r\n}\r\n#endif\r\nif ( mib->fddiPORTLer_Estimate <= mib->fddiPORTLer_Cutoff) {\r\nphy->pc_lem_fail = TRUE ;\r\nmib->fddiPORTLem_Reject_Ct++ ;\r\nlem->lem_float_ber += 2*100 ;\r\n#ifdef CONCENTRATOR\r\nDB_PCMN(1, "PCM: LER cutoff on port %d cutoff %d",\r\nphy->np, mib->fddiPORTLer_Cutoff);\r\n#endif\r\n#ifdef SMT_EXT_CUTOFF\r\nsmt_port_off_event(smc,phy->np);\r\n#else\r\nqueue_event(smc,(int)(EVENT_PCM+phy->np),PC_START) ;\r\n#endif\r\n}\r\n}\r\nvoid sm_lem_evaluate(struct s_smc *smc)\r\n{\r\nint np ;\r\nfor (np = 0 ; np < NUMPHYS ; np++)\r\nlem_evaluate(smc,&smc->y[np]) ;\r\n}\r\nstatic void lem_check_lct(struct s_smc *smc, struct s_phy *phy)\r\n{\r\nstruct lem_counter *lem = &phy->lem ;\r\nstruct fddi_mib_p *mib ;\r\nint errors ;\r\nmib = phy->mib ;\r\nphy->pc_lem_fail = FALSE ;\r\nerrors = inpw(PLC(((int)phy->np),PL_LINK_ERR_CTR)) ;\r\nlem->lem_errors += errors ;\r\nmib->fddiPORTLem_Ct += errors ;\r\nif (lem->lem_errors) {\r\nswitch(phy->lc_test) {\r\ncase LC_SHORT:\r\nif (lem->lem_errors >= smc->s.lct_short)\r\nphy->pc_lem_fail = TRUE ;\r\nbreak ;\r\ncase LC_MEDIUM:\r\nif (lem->lem_errors >= smc->s.lct_medium)\r\nphy->pc_lem_fail = TRUE ;\r\nbreak ;\r\ncase LC_LONG:\r\nif (lem->lem_errors >= smc->s.lct_long)\r\nphy->pc_lem_fail = TRUE ;\r\nbreak ;\r\ncase LC_EXTENDED:\r\nif (lem->lem_errors >= smc->s.lct_extended)\r\nphy->pc_lem_fail = TRUE ;\r\nbreak ;\r\n}\r\nDB_PCMN(1, " >>errors : %lu", lem->lem_errors);\r\n}\r\nif (phy->pc_lem_fail) {\r\nmib->fddiPORTLCTFail_Ct++ ;\r\nmib->fddiPORTLem_Reject_Ct++ ;\r\n}\r\nelse\r\nmib->fddiPORTLCTFail_Ct = 0 ;\r\n}\r\nstatic void sm_ph_lem_start(struct s_smc *smc, int np, int threshold)\r\n{\r\nstruct lem_counter *lem = &smc->y[np].lem ;\r\nlem->lem_on = 1 ;\r\nlem->lem_errors = 0L ;\r\noutpw(PLC(np,PL_LE_THRESHOLD),threshold) ;\r\n(void)inpw(PLC(np,PL_LINK_ERR_CTR)) ;\r\nSETMASK(PLC(np,PL_INTR_MASK),PL_LE_CTR,PL_LE_CTR) ;\r\n}\r\nstatic void sm_ph_lem_stop(struct s_smc *smc, int np)\r\n{\r\nstruct lem_counter *lem = &smc->y[np].lem ;\r\nlem->lem_on = 0 ;\r\nCLEAR(PLC(np,PL_INTR_MASK),PL_LE_CTR) ;\r\n}\r\nvoid sm_pm_ls_latch(struct s_smc *smc, int phy, int on_off)\r\n{\r\nSK_UNUSED(smc) ;\r\nphy = phy ; on_off = on_off ;\r\n}\r\nstatic void pc_rcode_actions(struct s_smc *smc, int bit, struct s_phy *phy)\r\n{\r\nstruct fddi_mib_p *mib ;\r\nmib = phy->mib ;\r\nDB_PCMN(1, "SIG rec %x %x:", bit, phy->r_val[bit]);\r\nbit++ ;\r\nswitch(bit) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\nbreak ;\r\ncase 3 :\r\nif (phy->r_val[1] == 0 && phy->r_val[2] == 0)\r\nmib->fddiPORTNeighborType = TA ;\r\nelse if (phy->r_val[1] == 0 && phy->r_val[2] == 1)\r\nmib->fddiPORTNeighborType = TB ;\r\nelse if (phy->r_val[1] == 1 && phy->r_val[2] == 0)\r\nmib->fddiPORTNeighborType = TS ;\r\nelse if (phy->r_val[1] == 1 && phy->r_val[2] == 1)\r\nmib->fddiPORTNeighborType = TM ;\r\nbreak ;\r\ncase 4:\r\nif (mib->fddiPORTMy_Type == TM &&\r\nmib->fddiPORTNeighborType == TM) {\r\nDB_PCMN(1, "PCM %c : E100 withhold M-M",\r\nphy->phy_name);\r\nmib->fddiPORTPC_Withhold = PC_WH_M_M ;\r\nRS_SET(smc,RS_EVENT) ;\r\n}\r\nelse if (phy->t_val[3] || phy->r_val[3]) {\r\nmib->fddiPORTPC_Withhold = PC_WH_NONE ;\r\nif (mib->fddiPORTMy_Type == TM ||\r\nmib->fddiPORTNeighborType == TM)\r\nphy->pc_mode = PM_TREE ;\r\nelse\r\nphy->pc_mode = PM_PEER ;\r\nall_selection_criteria (smc);\r\nif (phy->wc_flag) {\r\nmib->fddiPORTPC_Withhold = PC_WH_PATH ;\r\n}\r\n}\r\nelse {\r\nmib->fddiPORTPC_Withhold = PC_WH_OTHER ;\r\nRS_SET(smc,RS_EVENT) ;\r\nDB_PCMN(1, "PCM %c : E101 withhold other",\r\nphy->phy_name);\r\n}\r\nphy->twisted = ((mib->fddiPORTMy_Type != TS) &&\r\n(mib->fddiPORTMy_Type != TM) &&\r\n(mib->fddiPORTNeighborType ==\r\nmib->fddiPORTMy_Type)) ;\r\nif (phy->twisted) {\r\nDB_PCMN(1, "PCM %c : E102 !!! TWISTED !!!",\r\nphy->phy_name);\r\n}\r\nbreak ;\r\ncase 5 :\r\nbreak ;\r\ncase 6:\r\nif (phy->t_val[4] || phy->r_val[4]) {\r\nif ((phy->t_val[4] && phy->t_val[5]) ||\r\n(phy->r_val[4] && phy->r_val[5]) )\r\nphy->lc_test = LC_EXTENDED ;\r\nelse\r\nphy->lc_test = LC_LONG ;\r\n}\r\nelse if (phy->t_val[5] || phy->r_val[5])\r\nphy->lc_test = LC_MEDIUM ;\r\nelse\r\nphy->lc_test = LC_SHORT ;\r\nswitch (phy->lc_test) {\r\ncase LC_SHORT :\r\noutpw(PLC((int)phy->np,PL_LC_LENGTH), TP_LC_LENGTH ) ;\r\nphy->t_next[7] = smc->s.pcm_lc_short ;\r\nbreak ;\r\ncase LC_MEDIUM :\r\noutpw(PLC((int)phy->np,PL_LC_LENGTH), TP_LC_LONGLN ) ;\r\nphy->t_next[7] = smc->s.pcm_lc_medium ;\r\nbreak ;\r\ncase LC_LONG :\r\nSETMASK(PLC((int)phy->np,PL_CNTRL_B),PL_LONG,PL_LONG) ;\r\nphy->t_next[7] = smc->s.pcm_lc_long ;\r\nbreak ;\r\ncase LC_EXTENDED :\r\nSETMASK(PLC((int)phy->np,PL_CNTRL_B),PL_LONG,PL_LONG) ;\r\nphy->t_next[7] = smc->s.pcm_lc_extended ;\r\nbreak ;\r\n}\r\nif (phy->t_next[7] > smc->s.pcm_lc_medium) {\r\nstart_pcm_timer0(smc,phy->t_next[7],PC_TIMEOUT_LCT,phy);\r\n}\r\nDB_PCMN(1, "LCT timer = %ld us", phy->t_next[7]);\r\nphy->t_next[9] = smc->s.pcm_t_next_9 ;\r\nbreak ;\r\ncase 7:\r\nif (phy->t_val[6]) {\r\nphy->cf_loop = TRUE ;\r\n}\r\nphy->td_flag = TRUE ;\r\nbreak ;\r\ncase 8:\r\nif (phy->t_val[7] || phy->r_val[7]) {\r\nDB_PCMN(1, "PCM %c : E103 LCT fail %s",\r\nphy->phy_name,\r\nphy->t_val[7] ? "local" : "remote");\r\nqueue_event(smc,(int)(EVENT_PCM+phy->np),PC_START) ;\r\n}\r\nbreak ;\r\ncase 9:\r\nif (phy->t_val[8] || phy->r_val[8]) {\r\nif (phy->t_val[8])\r\nphy->cf_loop = TRUE ;\r\nphy->td_flag = TRUE ;\r\n}\r\nbreak ;\r\ncase 10:\r\nif (phy->r_val[9]) {\r\n;\r\nmib->fddiPORTMacIndicated.R_val = TRUE ;\r\n}\r\nelse {\r\n;\r\nmib->fddiPORTMacIndicated.R_val = FALSE ;\r\n}\r\nbreak ;\r\n}\r\n}\r\nstatic void pc_tcode_actions(struct s_smc *smc, const int bit, struct s_phy *phy)\r\n{\r\nint np = phy->np ;\r\nstruct fddi_mib_p *mib ;\r\nmib = phy->mib ;\r\nswitch(bit) {\r\ncase 0:\r\nphy->t_val[0] = 0 ;\r\nbreak ;\r\ncase 1:\r\nif (mib->fddiPORTMy_Type == TS || mib->fddiPORTMy_Type == TM)\r\nphy->t_val[1] = 1 ;\r\nelse\r\nphy->t_val[1] = 0 ;\r\nbreak ;\r\ncase 2 :\r\nif (mib->fddiPORTMy_Type == TB || mib->fddiPORTMy_Type == TM)\r\nphy->t_val[2] = 1 ;\r\nelse\r\nphy->t_val[2] = 0 ;\r\nbreak ;\r\ncase 3:\r\n{\r\nint type,ne ;\r\nint policy ;\r\ntype = mib->fddiPORTMy_Type ;\r\nne = mib->fddiPORTNeighborType ;\r\npolicy = smc->mib.fddiSMTConnectionPolicy ;\r\nphy->t_val[3] = 1 ;\r\nswitch (type) {\r\ncase TA :\r\nif (\r\n((policy & POLICY_AA) && ne == TA) ||\r\n((policy & POLICY_AB) && ne == TB) ||\r\n((policy & POLICY_AS) && ne == TS) ||\r\n((policy & POLICY_AM) && ne == TM) )\r\nphy->t_val[3] = 0 ;\r\nbreak ;\r\ncase TB :\r\nif (\r\n((policy & POLICY_BA) && ne == TA) ||\r\n((policy & POLICY_BB) && ne == TB) ||\r\n((policy & POLICY_BS) && ne == TS) ||\r\n((policy & POLICY_BM) && ne == TM) )\r\nphy->t_val[3] = 0 ;\r\nbreak ;\r\ncase TS :\r\nif (\r\n((policy & POLICY_SA) && ne == TA) ||\r\n((policy & POLICY_SB) && ne == TB) ||\r\n((policy & POLICY_SS) && ne == TS) ||\r\n((policy & POLICY_SM) && ne == TM) )\r\nphy->t_val[3] = 0 ;\r\nbreak ;\r\ncase TM :\r\nif ( ne == TM ||\r\n((policy & POLICY_MA) && ne == TA) ||\r\n((policy & POLICY_MB) && ne == TB) ||\r\n((policy & POLICY_MS) && ne == TS) ||\r\n((policy & POLICY_MM) && ne == TM) )\r\nphy->t_val[3] = 0 ;\r\nbreak ;\r\n}\r\n#ifndef SLIM_SMT\r\nif ( (type == TA && ne == TA ) ||\r\n(type == TA && ne == TS ) ||\r\n(type == TB && ne == TB ) ||\r\n(type == TB && ne == TS ) ||\r\n(type == TS && ne == TA ) ||\r\n(type == TS && ne == TB ) ) {\r\nsmt_srf_event(smc,SMT_EVENT_PORT_CONNECTION,\r\n(int) (INDEX_PORT+ phy->np) ,0) ;\r\n}\r\n#endif\r\n}\r\nbreak ;\r\ncase 4:\r\nif (mib->fddiPORTPC_Withhold == PC_WH_NONE) {\r\nif (phy->pc_lem_fail) {\r\nphy->t_val[4] = 1 ;\r\nphy->t_val[5] = 0 ;\r\n}\r\nelse {\r\nphy->t_val[4] = 0 ;\r\nif (mib->fddiPORTLCTFail_Ct > 0)\r\nphy->t_val[5] = 1 ;\r\nelse\r\nphy->t_val[5] = 0 ;\r\nif (phy->wc_flag)\r\nphy->t_val[5] = 1 ;\r\n}\r\nmib->fddiPORTConnectState = PCM_CONNECTING ;\r\n}\r\nelse {\r\nmib->fddiPORTConnectState = PCM_STANDBY ;\r\nphy->t_val[4] = 1 ;\r\nphy->t_val[5] = 1 ;\r\n}\r\nbreak ;\r\ncase 5:\r\nbreak ;\r\ncase 6:\r\nphy->t_val[6] = 0 ;\r\nbreak ;\r\ncase 7:\r\nphy->cf_loop = FALSE ;\r\nlem_check_lct(smc,phy) ;\r\nif (phy->pc_lem_fail) {\r\nDB_PCMN(1, "PCM %c : E104 LCT failed", phy->phy_name);\r\nphy->t_val[7] = 1 ;\r\n}\r\nelse\r\nphy->t_val[7] = 0 ;\r\nbreak ;\r\ncase 8:\r\nphy->t_val[8] = 0 ;\r\nbreak ;\r\ncase 9:\r\nphy->cf_loop = 0 ;\r\nif ((mib->fddiPORTPC_Withhold != PC_WH_NONE) ||\r\n((smc->s.sas == SMT_DAS) && (phy->wc_flag))) {\r\nqueue_event(smc,EVENT_PCM+np,PC_START) ;\r\nbreak ;\r\n}\r\nphy->t_val[9] = FALSE ;\r\nswitch (smc->s.sas) {\r\ncase SMT_DAS :\r\nif (phy->pc_mode == PM_TREE) {\r\nif ((np == PB) || ((np == PA) &&\r\n(smc->y[PB].mib->fddiPORTConnectState !=\r\nPCM_ACTIVE)))\r\nphy->t_val[9] = TRUE ;\r\n}\r\nelse {\r\nif (np == PB)\r\nphy->t_val[9] = TRUE ;\r\n}\r\nbreak ;\r\ncase SMT_SAS :\r\nif (np == PS)\r\nphy->t_val[9] = TRUE ;\r\nbreak ;\r\n#ifdef CONCENTRATOR\r\ncase SMT_NAC :\r\nif (np == PB)\r\nphy->t_val[9] = TRUE ;\r\nbreak ;\r\n#endif\r\n}\r\nmib->fddiPORTMacIndicated.T_val = phy->t_val[9] ;\r\nbreak ;\r\n}\r\nDB_PCMN(1, "SIG snd %x %x:", bit, phy->t_val[bit]);\r\n}\r\nint pcm_status_twisted(struct s_smc *smc)\r\n{\r\nint twist = 0 ;\r\nif (smc->s.sas != SMT_DAS)\r\nreturn 0;\r\nif (smc->y[PA].twisted && (smc->y[PA].mib->fddiPORTPCMState == PC8_ACTIVE))\r\ntwist |= 1 ;\r\nif (smc->y[PB].twisted && (smc->y[PB].mib->fddiPORTPCMState == PC8_ACTIVE))\r\ntwist |= 2 ;\r\nreturn twist;\r\n}\r\nvoid pcm_status_state(struct s_smc *smc, int np, int *type, int *state,\r\nint *remote, int *mac)\r\n{\r\nstruct s_phy *phy = &smc->y[np] ;\r\nstruct fddi_mib_p *mib ;\r\nmib = phy->mib ;\r\n*mac = 0 ;\r\n*type = mib->fddiPORTMy_Type ;\r\n*state = mib->fddiPORTConnectState ;\r\n*remote = mib->fddiPORTNeighborType ;\r\nswitch(mib->fddiPORTPCMState) {\r\ncase PC8_ACTIVE :\r\n*mac = mib->fddiPORTMacIndicated.R_val ;\r\nbreak ;\r\n}\r\n}\r\nint pcm_rooted_station(struct s_smc *smc)\r\n{\r\nint n ;\r\nfor (n = 0 ; n < NUMPHYS ; n++) {\r\nif (smc->y[n].mib->fddiPORTPCMState == PC8_ACTIVE &&\r\nsmc->y[n].mib->fddiPORTNeighborType == TM)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nvoid plc_irq(struct s_smc *smc, int np, unsigned int cmd)\r\n{\r\nstruct s_phy *phy = &smc->y[np] ;\r\nstruct s_plc *plc = &phy->plc ;\r\nint n ;\r\n#ifdef SUPERNET_3\r\nint corr_mask ;\r\n#endif\r\nint i ;\r\nif (np >= smc->s.numphys) {\r\nplc->soft_err++ ;\r\nreturn ;\r\n}\r\nif (cmd & PL_EBUF_ERR) {\r\nif (!plc->ebuf_cont && phy->mib->fddiPORTPCMState == PC8_ACTIVE){\r\nphy->mib->fddiPORTEBError_Ct ++ ;\r\n}\r\nplc->ebuf_err++ ;\r\nif (plc->ebuf_cont <= 1000) {\r\nplc->ebuf_cont++ ;\r\n}\r\n#ifdef SUPERNET_3\r\nif (plc->ebuf_cont == 1000 &&\r\n((inpw(PLC(np,PL_STATUS_A)) & PLC_REV_MASK) ==\r\nPLC_REV_SN3)) {\r\ncorr_mask = (plc_imsk_na & ~PL_EBUF_ERR) ;\r\noutpw(PLC(np,PL_INTR_MASK),corr_mask);\r\nqueue_event(smc,EVENT_ECM,EC_DISCONNECT) ;\r\nSMT_ERR_LOG(smc,SMT_E0136, SMT_E0136_MSG) ;\r\ndrv_reset_indication(smc) ;\r\n}\r\n#endif\r\n} else {\r\nplc->ebuf_cont = 0 ;\r\n}\r\nif (cmd & PL_PHYINV) {\r\nplc->phyinv++ ;\r\n}\r\nif (cmd & PL_VSYM_CTR) {\r\nplc->vsym_ctr++ ;\r\n}\r\nif (cmd & PL_MINI_CTR) {\r\nplc->mini_ctr++ ;\r\n}\r\nif (cmd & PL_LE_CTR) {\r\nint j ;\r\nj = inpw(PLC(np,PL_LE_THRESHOLD)) ;\r\ni = inpw(PLC(np,PL_LINK_ERR_CTR)) ;\r\nif (i < j) {\r\ni += 256 ;\r\n}\r\nif (phy->lem.lem_on) {\r\nphy->lem.lem_errors += i ;\r\nphy->mib->fddiPORTLem_Ct += i ;\r\n}\r\n}\r\nif (cmd & PL_TPC_EXPIRED) {\r\nif (plc->p_state == PS_LCT) {\r\n;\r\n}\r\nplc->tpc_exp++ ;\r\n}\r\nif (cmd & PL_LS_MATCH) {\r\nswitch (inpw(PLC(np,PL_CNTRL_B)) & PL_MATCH_LS) {\r\ncase PL_I_IDLE : phy->curr_ls = PC_ILS ; break ;\r\ncase PL_I_HALT : phy->curr_ls = PC_HLS ; break ;\r\ncase PL_I_MASTR : phy->curr_ls = PC_MLS ; break ;\r\ncase PL_I_QUIET : phy->curr_ls = PC_QLS ; break ;\r\n}\r\n}\r\nif (cmd & PL_PCM_BREAK) {\r\nint reason;\r\nreason = inpw(PLC(np,PL_STATUS_B)) & PL_BREAK_REASON ;\r\nswitch (reason) {\r\ncase PL_B_PCS : plc->b_pcs++ ; break ;\r\ncase PL_B_TPC : plc->b_tpc++ ; break ;\r\ncase PL_B_TNE : plc->b_tne++ ; break ;\r\ncase PL_B_QLS : plc->b_qls++ ; break ;\r\ncase PL_B_ILS : plc->b_ils++ ; break ;\r\ncase PL_B_HLS : plc->b_hls++ ; break ;\r\n}\r\nDB_PCMN(1, "PLC %d: MDcF = %x", np, smc->e.DisconnectFlag);\r\nif (smc->e.DisconnectFlag == FALSE) {\r\nDB_PCMN(1, "PLC %d: restart (reason %x)", np, reason);\r\nqueue_event(smc,EVENT_PCM+np,PC_START) ;\r\n}\r\nelse {\r\nDB_PCMN(1, "PLC %d: NO!! restart (reason %x)",\r\nnp, reason);\r\n}\r\nreturn ;\r\n}\r\nif (cmd & PL_PCM_CODE) {\r\nqueue_event(smc,EVENT_PCM+np,PC_SIGNAL) ;\r\nn = inpw(PLC(np,PL_RCV_VECTOR)) ;\r\nfor (i = 0 ; i < plc->p_bits ; i++) {\r\nphy->r_val[plc->p_start+i] = n & 1 ;\r\nn >>= 1 ;\r\n}\r\n}\r\nelse if (cmd & PL_PCM_ENABLED) {\r\nqueue_event(smc,EVENT_PCM+np,PC_JOIN) ;\r\n}\r\nif (cmd & PL_TRACE_PROP) {\r\nif (!phy->tr_flag) {\r\nDB_PCMN(1, "PCM : irq TRACE_PROP %d %d",\r\nnp, smc->mib.fddiSMTECMState);\r\nphy->tr_flag = TRUE ;\r\nsmc->e.trace_prop |= ENTITY_BIT(ENTITY_PHY(np)) ;\r\nqueue_event(smc,EVENT_ECM,EC_TRACE_PROP) ;\r\n}\r\n}\r\nif ((cmd & PL_SELF_TEST) && (phy->mib->fddiPORTPCMState == PC2_TRACE)) {\r\nif (smc->e.path_test == PT_PASSED) {\r\nDB_PCMN(1, "PCM : state = %s %d",\r\nget_pcmstate(smc, np),\r\nphy->mib->fddiPORTPCMState);\r\nsmc->e.path_test = PT_PENDING ;\r\nqueue_event(smc,EVENT_ECM,EC_PATH_TEST) ;\r\n}\r\n}\r\nif (cmd & PL_TNE_EXPIRED) {\r\nif (phy->mib->fddiPORTPCMState == PC8_ACTIVE) {\r\nif (!phy->tr_flag) {\r\nDB_PCMN(1, "PCM %c : PC81 %s",\r\nphy->phy_name, "NSE");\r\nqueue_event(smc, EVENT_PCM + np, PC_START);\r\nreturn;\r\n}\r\n}\r\n}\r\n#if 0\r\nif (cmd & PL_NP_ERR) {\r\nplc->np_err++ ;\r\n}\r\nif (cmd & PL_PARITY_ERR) {\r\nplc->parity_err++ ;\r\n}\r\nif (cmd & PL_LSDO) {\r\n;\r\n}\r\n#endif\r\n}\r\nvoid pcm_get_state(struct s_smc *smc, struct smt_state *state)\r\n{\r\nstruct s_phy *phy ;\r\nstruct pcm_state *pcs ;\r\nint i ;\r\nint ii ;\r\nshort rbits ;\r\nshort tbits ;\r\nstruct fddi_mib_p *mib ;\r\nfor (i = 0, phy = smc->y, pcs = state->pcm_state ; i < NUMPHYS ;\r\ni++ , phy++, pcs++ ) {\r\nmib = phy->mib ;\r\npcs->pcm_type = (u_char) mib->fddiPORTMy_Type ;\r\npcs->pcm_state = (u_char) mib->fddiPORTPCMState ;\r\npcs->pcm_mode = phy->pc_mode ;\r\npcs->pcm_neighbor = (u_char) mib->fddiPORTNeighborType ;\r\npcs->pcm_bsf = mib->fddiPORTBS_Flag ;\r\npcs->pcm_lsf = phy->ls_flag ;\r\npcs->pcm_lct_fail = (u_char) mib->fddiPORTLCTFail_Ct ;\r\npcs->pcm_ls_rx = LS2MIB(sm_pm_get_ls(smc,i)) ;\r\nfor (ii = 0, rbits = tbits = 0 ; ii < NUMBITS ; ii++) {\r\nrbits <<= 1 ;\r\ntbits <<= 1 ;\r\nif (phy->r_val[NUMBITS-1-ii])\r\nrbits |= 1 ;\r\nif (phy->t_val[NUMBITS-1-ii])\r\ntbits |= 1 ;\r\n}\r\npcs->pcm_r_val = rbits ;\r\npcs->pcm_t_val = tbits ;\r\n}\r\n}\r\nint get_pcm_state(struct s_smc *smc, int np)\r\n{\r\nint pcs ;\r\nSK_UNUSED(smc) ;\r\nswitch (inpw(PLC(np,PL_STATUS_B)) & PL_PCM_STATE) {\r\ncase PL_PC0 : pcs = PC_STOP ; break ;\r\ncase PL_PC1 : pcs = PC_START ; break ;\r\ncase PL_PC2 : pcs = PC_TRACE ; break ;\r\ncase PL_PC3 : pcs = PC_SIGNAL ; break ;\r\ncase PL_PC4 : pcs = PC_SIGNAL ; break ;\r\ncase PL_PC5 : pcs = PC_SIGNAL ; break ;\r\ncase PL_PC6 : pcs = PC_JOIN ; break ;\r\ncase PL_PC7 : pcs = PC_JOIN ; break ;\r\ncase PL_PC8 : pcs = PC_ENABLE ; break ;\r\ncase PL_PC9 : pcs = PC_MAINT ; break ;\r\ndefault : pcs = PC_DISABLE ; break ;\r\n}\r\nreturn pcs;\r\n}\r\nchar *get_linestate(struct s_smc *smc, int np)\r\n{\r\nchar *ls = "" ;\r\nSK_UNUSED(smc) ;\r\nswitch (inpw(PLC(np,PL_STATUS_A)) & PL_LINE_ST) {\r\ncase PL_L_NLS : ls = "NOISE" ; break ;\r\ncase PL_L_ALS : ls = "ACTIV" ; break ;\r\ncase PL_L_UND : ls = "UNDEF" ; break ;\r\ncase PL_L_ILS4: ls = "ILS 4" ; break ;\r\ncase PL_L_QLS : ls = "QLS" ; break ;\r\ncase PL_L_MLS : ls = "MLS" ; break ;\r\ncase PL_L_HLS : ls = "HLS" ; break ;\r\ncase PL_L_ILS16:ls = "ILS16" ; break ;\r\n#ifdef lint\r\ndefault: ls = "unknown" ; break ;\r\n#endif\r\n}\r\nreturn ls;\r\n}\r\nchar *get_pcmstate(struct s_smc *smc, int np)\r\n{\r\nchar *pcs ;\r\nSK_UNUSED(smc) ;\r\nswitch (inpw(PLC(np,PL_STATUS_B)) & PL_PCM_STATE) {\r\ncase PL_PC0 : pcs = "OFF" ; break ;\r\ncase PL_PC1 : pcs = "BREAK" ; break ;\r\ncase PL_PC2 : pcs = "TRACE" ; break ;\r\ncase PL_PC3 : pcs = "CONNECT"; break ;\r\ncase PL_PC4 : pcs = "NEXT" ; break ;\r\ncase PL_PC5 : pcs = "SIGNAL" ; break ;\r\ncase PL_PC6 : pcs = "JOIN" ; break ;\r\ncase PL_PC7 : pcs = "VERIFY" ; break ;\r\ncase PL_PC8 : pcs = "ACTIV" ; break ;\r\ncase PL_PC9 : pcs = "MAINT" ; break ;\r\ndefault : pcs = "UNKNOWN" ; break ;\r\n}\r\nreturn pcs;\r\n}\r\nvoid list_phy(struct s_smc *smc)\r\n{\r\nstruct s_plc *plc ;\r\nint np ;\r\nfor (np = 0 ; np < NUMPHYS ; np++) {\r\nplc = &smc->y[np].plc ;\r\nprintf("PHY %d:\tERRORS\t\t\tBREAK_REASONS\t\tSTATES:\n",np) ;\r\nprintf("\tsoft_error: %ld \t\tPC_Start : %ld\n",\r\nplc->soft_err,plc->b_pcs);\r\nprintf("\tparity_err: %ld \t\tTPC exp. : %ld\t\tLine: %s\n",\r\nplc->parity_err,plc->b_tpc,get_linestate(smc,np)) ;\r\nprintf("\tebuf_error: %ld \t\tTNE exp. : %ld\n",\r\nplc->ebuf_err,plc->b_tne) ;\r\nprintf("\tphyinvalid: %ld \t\tQLS det. : %ld\t\tPCM : %s\n",\r\nplc->phyinv,plc->b_qls,get_pcmstate(smc,np)) ;\r\nprintf("\tviosym_ctr: %ld \t\tILS det. : %ld\n",\r\nplc->vsym_ctr,plc->b_ils) ;\r\nprintf("\tmingap_ctr: %ld \t\tHLS det. : %ld\n",\r\nplc->mini_ctr,plc->b_hls) ;\r\nprintf("\tnodepr_err: %ld\n",plc->np_err) ;\r\nprintf("\tTPC_exp : %ld\n",plc->tpc_exp) ;\r\nprintf("\tLEM_err : %ld\n",smc->y[np].lem.lem_errors) ;\r\n}\r\n}\r\nvoid pcm_lem_dump(struct s_smc *smc)\r\n{\r\nint i ;\r\nstruct s_phy *phy ;\r\nstruct fddi_mib_p *mib ;\r\nchar *entostring() ;\r\nprintf("PHY errors BER\n") ;\r\nprintf("----------------------\n") ;\r\nfor (i = 0,phy = smc->y ; i < NUMPHYS ; i++,phy++) {\r\nif (!plc_is_installed(smc,i))\r\ncontinue ;\r\nmib = phy->mib ;\r\nprintf("%s\t%ld\t10E-%d\n",\r\nentostring(smc,ENTITY_PHY(i)),\r\nmib->fddiPORTLem_Ct,\r\nmib->fddiPORTLer_Estimate) ;\r\n}\r\n}
