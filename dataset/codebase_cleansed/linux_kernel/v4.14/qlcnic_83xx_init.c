static int\r\nqlcnic_83xx_idc_check_driver_presence_reg(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val;\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE);\r\nif ((val & 0xFFFF))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void qlcnic_83xx_idc_log_state_history(struct qlcnic_adapter *adapter)\r\n{\r\nu32 cur, prev;\r\ncur = adapter->ahw->idc.curr_state;\r\nprev = adapter->ahw->idc.prev_state;\r\ndev_info(&adapter->pdev->dev,\r\n"current state = %s, prev state = %s\n",\r\nadapter->ahw->idc.name[cur],\r\nadapter->ahw->idc.name[prev]);\r\n}\r\nstatic int qlcnic_83xx_idc_update_audit_reg(struct qlcnic_adapter *adapter,\r\nu8 mode, int lock)\r\n{\r\nu32 val;\r\nint seconds;\r\nif (lock) {\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EBUSY;\r\n}\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_AUDIT);\r\nval |= (adapter->portnum & 0xf);\r\nval |= mode << 7;\r\nif (mode)\r\nseconds = jiffies / HZ - adapter->ahw->idc.sec_counter;\r\nelse\r\nseconds = jiffies / HZ;\r\nval |= seconds << 8;\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_DRV_AUDIT, val);\r\nadapter->ahw->idc.sec_counter = jiffies / HZ;\r\nif (lock)\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn 0;\r\n}\r\nstatic void qlcnic_83xx_idc_update_minor_version(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val;\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_MIN_VERSION);\r\nval = val & ~(0x3 << (adapter->portnum * 2));\r\nval = val | (QLC_83XX_IDC_MINOR_VERSION << (adapter->portnum * 2));\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_MIN_VERSION, val);\r\n}\r\nstatic int qlcnic_83xx_idc_update_major_version(struct qlcnic_adapter *adapter,\r\nint lock)\r\n{\r\nu32 val;\r\nif (lock) {\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EBUSY;\r\n}\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_MAJ_VERSION);\r\nval = val & ~0xFF;\r\nval = val | QLC_83XX_IDC_MAJOR_VERSION;\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_MAJ_VERSION, val);\r\nif (lock)\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_83xx_idc_update_drv_presence_reg(struct qlcnic_adapter *adapter,\r\nint status, int lock)\r\n{\r\nu32 val;\r\nif (lock) {\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EBUSY;\r\n}\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE);\r\nif (status)\r\nval = val | (1 << adapter->portnum);\r\nelse\r\nval = val & ~(1 << adapter->portnum);\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE, val);\r\nqlcnic_83xx_idc_update_minor_version(adapter);\r\nif (lock)\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_idc_check_major_version(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val;\r\nu8 version;\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_MAJ_VERSION);\r\nversion = val & 0xFF;\r\nif (version != QLC_83XX_IDC_MAJOR_VERSION) {\r\ndev_info(&adapter->pdev->dev,\r\n"%s:mismatch. version 0x%x, expected version 0x%x\n",\r\n__func__, version, QLC_83XX_IDC_MAJOR_VERSION);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_idc_clear_registers(struct qlcnic_adapter *adapter,\r\nint lock)\r\n{\r\nu32 val;\r\nif (lock) {\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EBUSY;\r\n}\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_DRV_ACK, 0);\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\r\nval &= ~QLC_83XX_IDC_GRACEFULL_RESET;\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_CTRL, val);\r\nif (lock)\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_idc_update_drv_ack_reg(struct qlcnic_adapter *adapter,\r\nint flag, int lock)\r\n{\r\nu32 val;\r\nif (lock) {\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EBUSY;\r\n}\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_ACK);\r\nif (flag)\r\nval = val | (1 << adapter->portnum);\r\nelse\r\nval = val & ~(1 << adapter->portnum);\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_DRV_ACK, val);\r\nif (lock)\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_idc_check_timeout(struct qlcnic_adapter *adapter,\r\nint time_limit)\r\n{\r\nu64 seconds;\r\nseconds = jiffies / HZ - adapter->ahw->idc.sec_counter;\r\nif (seconds <= time_limit)\r\nreturn 0;\r\nelse\r\nreturn -EBUSY;\r\n}\r\nstatic int qlcnic_83xx_idc_check_reset_ack_reg(struct qlcnic_adapter *adapter)\r\n{\r\nint timeout;\r\nu32 ack, presence, val;\r\ntimeout = QLC_83XX_IDC_RESET_TIMEOUT_SECS;\r\nack = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_ACK);\r\npresence = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE);\r\ndev_info(&adapter->pdev->dev,\r\n"%s: ack = 0x%x, presence = 0x%x\n", __func__, ack, presence);\r\nif (!((ack & presence) == presence)) {\r\nif (qlcnic_83xx_idc_check_timeout(adapter, timeout)) {\r\ndev_info(&adapter->pdev->dev,\r\n"%s: ACK wait exceeds time limit\n", __func__);\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE);\r\nval = val & ~(ack ^ presence);\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EBUSY;\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE, val);\r\ndev_info(&adapter->pdev->dev,\r\n"%s: updated drv presence reg = 0x%x\n",\r\n__func__, val);\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn 0;\r\n} else {\r\nreturn 1;\r\n}\r\n} else {\r\ndev_info(&adapter->pdev->dev,\r\n"%s: Reset ACK received from all functions\n",\r\n__func__);\r\nreturn 0;\r\n}\r\n}\r\nstatic int qlcnic_83xx_idc_tx_soft_reset(struct qlcnic_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nif (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\r\nreturn -EBUSY;\r\nnetif_device_detach(netdev);\r\nqlcnic_down(adapter, netdev);\r\nqlcnic_up(adapter, netdev);\r\nnetif_device_attach(netdev);\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nnetdev_info(adapter->netdev, "%s: soft reset complete.\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void qlcnic_83xx_idc_detach_driver(struct qlcnic_adapter *adapter)\r\n{\r\nint i;\r\nstruct net_device *netdev = adapter->netdev;\r\nnetif_device_detach(netdev);\r\nqlcnic_83xx_detach_mailbox_work(adapter);\r\nqlcnic_83xx_disable_mbx_intr(adapter);\r\nqlcnic_down(adapter, netdev);\r\nfor (i = 0; i < adapter->ahw->num_msix; i++) {\r\nadapter->ahw->intr_tbl[i].id = i;\r\nadapter->ahw->intr_tbl[i].enabled = 0;\r\nadapter->ahw->intr_tbl[i].src = 0;\r\n}\r\nif (qlcnic_sriov_pf_check(adapter))\r\nqlcnic_sriov_pf_reset(adapter);\r\n}\r\nstatic void qlcnic_83xx_idc_attach_driver(struct qlcnic_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nif (netif_running(netdev)) {\r\nif (qlcnic_up(adapter, netdev))\r\ngoto done;\r\nqlcnic_restore_indev_addr(netdev, NETDEV_UP);\r\n}\r\ndone:\r\nnetif_device_attach(netdev);\r\n}\r\nstatic int qlcnic_83xx_idc_enter_failed_state(struct qlcnic_adapter *adapter,\r\nint lock)\r\n{\r\nif (lock) {\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EBUSY;\r\n}\r\nqlcnic_83xx_idc_clear_registers(adapter, 0);\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_DEV_STATE, QLC_83XX_IDC_DEV_FAILED);\r\nif (lock)\r\nqlcnic_83xx_unlock_driver(adapter);\r\nqlcnic_83xx_idc_log_state_history(adapter);\r\ndev_info(&adapter->pdev->dev, "Device will enter failed state\n");\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_idc_enter_init_state(struct qlcnic_adapter *adapter,\r\nint lock)\r\n{\r\nif (lock) {\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EBUSY;\r\n}\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_DEV_STATE, QLC_83XX_IDC_DEV_INIT);\r\nif (lock)\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_idc_enter_need_quiesce(struct qlcnic_adapter *adapter,\r\nint lock)\r\n{\r\nif (lock) {\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EBUSY;\r\n}\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_DEV_STATE,\r\nQLC_83XX_IDC_DEV_NEED_QUISCENT);\r\nif (lock)\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_83xx_idc_enter_need_reset_state(struct qlcnic_adapter *adapter, int lock)\r\n{\r\nif (lock) {\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EBUSY;\r\n}\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_DEV_STATE,\r\nQLC_83XX_IDC_DEV_NEED_RESET);\r\nif (lock)\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_idc_enter_ready_state(struct qlcnic_adapter *adapter,\r\nint lock)\r\n{\r\nif (lock) {\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EBUSY;\r\n}\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_DEV_STATE, QLC_83XX_IDC_DEV_READY);\r\nif (lock)\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_idc_find_reset_owner_id(struct qlcnic_adapter *adapter)\r\n{\r\nu32 reg, reg1, reg2, i, j, owner, class;\r\nreg1 = QLCRDX(adapter->ahw, QLC_83XX_IDC_DEV_PARTITION_INFO_1);\r\nreg2 = QLCRDX(adapter->ahw, QLC_83XX_IDC_DEV_PARTITION_INFO_2);\r\nowner = QLCNIC_TYPE_NIC;\r\ni = 0;\r\nj = 0;\r\nreg = reg1;\r\ndo {\r\nclass = (((reg & (0xF << j * 4)) >> j * 4) & 0x3);\r\nif (class == owner)\r\nbreak;\r\nif (i == (QLC_83XX_IDC_MAX_FUNC_PER_PARTITION_INFO - 1)) {\r\nreg = reg2;\r\nj = 0;\r\n} else {\r\nj++;\r\n}\r\nif (i == (QLC_83XX_IDC_MAX_CNA_FUNCTIONS - 1)) {\r\nif (owner == QLCNIC_TYPE_NIC)\r\nowner = QLCNIC_TYPE_ISCSI;\r\nelse if (owner == QLCNIC_TYPE_ISCSI)\r\nowner = QLCNIC_TYPE_FCOE;\r\nelse if (owner == QLCNIC_TYPE_FCOE)\r\nreturn -EIO;\r\nreg = reg1;\r\nj = 0;\r\ni = 0;\r\n}\r\n} while (i++ < QLC_83XX_IDC_MAX_CNA_FUNCTIONS);\r\nreturn i;\r\n}\r\nstatic int qlcnic_83xx_idc_restart_hw(struct qlcnic_adapter *adapter, int lock)\r\n{\r\nint ret = 0;\r\nret = qlcnic_83xx_restart_hw(adapter);\r\nif (ret) {\r\nqlcnic_83xx_idc_enter_failed_state(adapter, lock);\r\n} else {\r\nqlcnic_83xx_idc_clear_registers(adapter, lock);\r\nret = qlcnic_83xx_idc_enter_ready_state(adapter, lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic int qlcnic_83xx_idc_check_fan_failure(struct qlcnic_adapter *adapter)\r\n{\r\nu32 status;\r\nstatus = QLC_SHARED_REG_RD32(adapter, QLCNIC_PEG_HALT_STATUS1);\r\nif (status & QLCNIC_RCODE_FATAL_ERROR) {\r\ndev_err(&adapter->pdev->dev,\r\n"peg halt status1=0x%x\n", status);\r\nif (QLCNIC_FWERROR_CODE(status) == QLCNIC_FWERROR_FAN_FAILURE) {\r\ndev_err(&adapter->pdev->dev,\r\n"On board active cooling fan failed. "\r\n"Device has been halted.\n");\r\ndev_err(&adapter->pdev->dev,\r\n"Replace the adapter.\n");\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_idc_reattach_driver(struct qlcnic_adapter *adapter)\r\n{\r\nint err;\r\nqlcnic_83xx_reinit_mbx_work(adapter->ahw->mailbox);\r\nqlcnic_83xx_enable_mbx_interrupt(adapter);\r\nqlcnic_83xx_initialize_nic(adapter, 1);\r\nerr = qlcnic_sriov_pf_reinit(adapter);\r\nif (err)\r\nreturn err;\r\nqlcnic_83xx_enable_mbx_interrupt(adapter);\r\nif (qlcnic_83xx_configure_opmode(adapter)) {\r\nqlcnic_83xx_idc_enter_failed_state(adapter, 1);\r\nreturn -EIO;\r\n}\r\nif (adapter->nic_ops->init_driver(adapter)) {\r\nqlcnic_83xx_idc_enter_failed_state(adapter, 1);\r\nreturn -EIO;\r\n}\r\nif (adapter->portnum == 0)\r\nqlcnic_set_drv_version(adapter);\r\nqlcnic_dcb_get_info(adapter->dcb);\r\nqlcnic_83xx_idc_attach_driver(adapter);\r\nreturn 0;\r\n}\r\nstatic void qlcnic_83xx_idc_update_idc_params(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nqlcnic_83xx_idc_update_drv_presence_reg(adapter, 1, 1);\r\nqlcnic_83xx_idc_update_audit_reg(adapter, 0, 1);\r\nset_bit(QLC_83XX_MODULE_LOADED, &adapter->ahw->idc.status);\r\nahw->idc.quiesce_req = 0;\r\nahw->idc.delay = QLC_83XX_IDC_FW_POLL_DELAY;\r\nahw->idc.err_code = 0;\r\nahw->idc.collect_dump = 0;\r\nahw->reset_context = 0;\r\nadapter->tx_timeo_cnt = 0;\r\nahw->idc.delay_reset = 0;\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\n}\r\nint qlcnic_83xx_idc_ready_state_entry(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nif (ahw->idc.prev_state != QLC_83XX_IDC_DEV_READY) {\r\nqlcnic_83xx_idc_update_idc_params(adapter);\r\nif ((ahw->idc.prev_state == QLC_83XX_IDC_DEV_NEED_RESET) ||\r\n(ahw->idc.prev_state == QLC_83XX_IDC_DEV_INIT)) {\r\nif (qlcnic_83xx_idc_reattach_driver(adapter))\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_idc_vnic_pf_entry(struct qlcnic_adapter *adapter)\r\n{\r\nu32 state;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstate = QLCRDX(adapter->ahw, QLC_83XX_VNIC_STATE);\r\nif (state != QLCNIC_DEV_NPAR_OPER) {\r\nif (!ahw->idc.vnic_wait_limit--) {\r\nqlcnic_83xx_idc_enter_failed_state(adapter, 1);\r\nreturn -EIO;\r\n}\r\ndev_info(&adapter->pdev->dev, "vNIC mode disabled\n");\r\nreturn -EIO;\r\n} else {\r\nif (ahw->idc.vnic_state != QLCNIC_DEV_NPAR_OPER) {\r\nqlcnic_83xx_idc_update_idc_params(adapter);\r\nif (ahw->idc.prev_state != QLC_83XX_IDC_DEV_UNKNOWN) {\r\nif (qlcnic_83xx_idc_reattach_driver(adapter))\r\nreturn -EIO;\r\n}\r\nadapter->ahw->idc.vnic_state = QLCNIC_DEV_NPAR_OPER;\r\ndev_info(&adapter->pdev->dev, "vNIC mode enabled\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_idc_unknown_state(struct qlcnic_adapter *adapter)\r\n{\r\nadapter->ahw->idc.err_code = -EIO;\r\ndev_err(&adapter->pdev->dev,\r\n"%s: Device in unknown state\n", __func__);\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_idc_cold_state_handler(struct qlcnic_adapter *adapter)\r\n{\r\nqlcnic_83xx_idc_update_drv_presence_reg(adapter, 1, 0);\r\nqlcnic_83xx_idc_update_audit_reg(adapter, 1, 0);\r\nif (qlcnic_load_fw_file) {\r\nqlcnic_83xx_idc_restart_hw(adapter, 0);\r\n} else {\r\nif (qlcnic_83xx_check_hw_status(adapter)) {\r\nqlcnic_83xx_idc_enter_failed_state(adapter, 0);\r\nreturn -EIO;\r\n} else {\r\nqlcnic_83xx_idc_enter_ready_state(adapter, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_idc_init_state(struct qlcnic_adapter *adapter)\r\n{\r\nint timeout, ret = 0;\r\nu32 owner;\r\ntimeout = QLC_83XX_IDC_INIT_TIMEOUT_SECS;\r\nif (adapter->ahw->idc.prev_state == QLC_83XX_IDC_DEV_NEED_RESET) {\r\nowner = qlcnic_83xx_idc_find_reset_owner_id(adapter);\r\nif (adapter->ahw->pci_func == owner)\r\nret = qlcnic_83xx_idc_restart_hw(adapter, 1);\r\n} else {\r\nret = qlcnic_83xx_idc_check_timeout(adapter, timeout);\r\n}\r\nreturn ret;\r\n}\r\nstatic int qlcnic_83xx_idc_ready_state(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_mailbox *mbx = ahw->mailbox;\r\nint ret = 0;\r\nu32 val;\r\nif (ahw->idc.state_entry(adapter))\r\nreturn -EIO;\r\nif (qlcnic_check_temp(adapter)) {\r\nif (ahw->temp == QLCNIC_TEMP_PANIC) {\r\nqlcnic_83xx_idc_check_fan_failure(adapter);\r\ndev_err(&adapter->pdev->dev,\r\n"Error: device temperature %d above limits\n",\r\nadapter->ahw->temp);\r\nclear_bit(QLC_83XX_MBX_READY, &mbx->status);\r\nset_bit(__QLCNIC_RESETTING, &adapter->state);\r\nqlcnic_83xx_idc_detach_driver(adapter);\r\nqlcnic_83xx_idc_enter_failed_state(adapter, 1);\r\nreturn -EIO;\r\n}\r\n}\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\r\nret = qlcnic_83xx_check_heartbeat(adapter);\r\nif (ret) {\r\nadapter->flags |= QLCNIC_FW_HANG;\r\nif (!(val & QLC_83XX_IDC_DISABLE_FW_RESET_RECOVERY)) {\r\nclear_bit(QLC_83XX_MBX_READY, &mbx->status);\r\nset_bit(__QLCNIC_RESETTING, &adapter->state);\r\nqlcnic_83xx_idc_enter_need_reset_state(adapter, 1);\r\n} else {\r\nnetdev_info(adapter->netdev, "%s: Auto firmware recovery is disabled\n",\r\n__func__);\r\nqlcnic_83xx_idc_enter_failed_state(adapter, 1);\r\n}\r\nreturn -EIO;\r\n}\r\nif ((val & QLC_83XX_IDC_GRACEFULL_RESET) || ahw->idc.collect_dump) {\r\nclear_bit(QLC_83XX_MBX_READY, &mbx->status);\r\nqlcnic_83xx_idc_enter_need_reset_state(adapter, 1);\r\nreturn ret;\r\n}\r\nif (ahw->reset_context &&\r\n!(val & QLC_83XX_IDC_DISABLE_FW_RESET_RECOVERY)) {\r\nadapter->ahw->reset_context = 0;\r\nqlcnic_83xx_idc_tx_soft_reset(adapter);\r\nreturn ret;\r\n}\r\nif (adapter->ahw->idc.quiesce_req) {\r\nqlcnic_83xx_idc_enter_need_quiesce(adapter, 1);\r\nqlcnic_83xx_idc_update_audit_reg(adapter, 0, 1);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int qlcnic_83xx_idc_need_reset_state(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\r\nint ret = 0;\r\nif (adapter->ahw->idc.prev_state != QLC_83XX_IDC_DEV_NEED_RESET) {\r\nqlcnic_83xx_idc_update_audit_reg(adapter, 0, 1);\r\nset_bit(__QLCNIC_RESETTING, &adapter->state);\r\nclear_bit(QLC_83XX_MBX_READY, &mbx->status);\r\nif (adapter->ahw->nic_mode == QLCNIC_VNIC_MODE)\r\nqlcnic_83xx_disable_vnic_mode(adapter, 1);\r\nif (qlcnic_check_diag_status(adapter)) {\r\ndev_info(&adapter->pdev->dev,\r\n"%s: Wait for diag completion\n", __func__);\r\nadapter->ahw->idc.delay_reset = 1;\r\nreturn 0;\r\n} else {\r\nqlcnic_83xx_idc_update_drv_ack_reg(adapter, 1, 1);\r\nqlcnic_83xx_idc_detach_driver(adapter);\r\n}\r\n}\r\nif (qlcnic_check_diag_status(adapter)) {\r\ndev_info(&adapter->pdev->dev,\r\n"%s: Wait for diag completion\n", __func__);\r\nreturn -1;\r\n} else {\r\nif (adapter->ahw->idc.delay_reset) {\r\nqlcnic_83xx_idc_update_drv_ack_reg(adapter, 1, 1);\r\nqlcnic_83xx_idc_detach_driver(adapter);\r\nadapter->ahw->idc.delay_reset = 0;\r\n}\r\nret = qlcnic_83xx_idc_check_reset_ack_reg(adapter);\r\nif (ret) {\r\ndev_info(&adapter->pdev->dev,\r\n"%s: Waiting for reset ACK\n", __func__);\r\nreturn -1;\r\n}\r\n}\r\nqlcnic_83xx_idc_enter_init_state(adapter, 1);\r\nreturn ret;\r\n}\r\nstatic int qlcnic_83xx_idc_need_quiesce_state(struct qlcnic_adapter *adapter)\r\n{\r\ndev_err(&adapter->pdev->dev, "%s: TBD\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void qlcnic_83xx_idc_failed_state(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nu32 val, owner;\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\r\nif (val & QLC_83XX_IDC_DISABLE_FW_RESET_RECOVERY) {\r\nowner = qlcnic_83xx_idc_find_reset_owner_id(adapter);\r\nif (ahw->pci_func == owner) {\r\nqlcnic_83xx_stop_hw(adapter);\r\nqlcnic_dump_fw(adapter);\r\n}\r\n}\r\nnetdev_warn(adapter->netdev, "%s: Reboot will be required to recover the adapter!!\n",\r\n__func__);\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nahw->idc.err_code = -EIO;\r\nreturn;\r\n}\r\nstatic int qlcnic_83xx_idc_quiesce_state(struct qlcnic_adapter *adapter)\r\n{\r\ndev_info(&adapter->pdev->dev, "%s: TBD\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_idc_check_state_validity(struct qlcnic_adapter *adapter,\r\nu32 state)\r\n{\r\nu32 cur, prev, next;\r\ncur = adapter->ahw->idc.curr_state;\r\nprev = adapter->ahw->idc.prev_state;\r\nnext = state;\r\nif ((next < QLC_83XX_IDC_DEV_COLD) ||\r\n(next > QLC_83XX_IDC_DEV_QUISCENT)) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: curr %d, prev %d, next state %d is invalid\n",\r\n__func__, cur, prev, state);\r\nreturn 1;\r\n}\r\nif ((cur == QLC_83XX_IDC_DEV_UNKNOWN) &&\r\n(prev == QLC_83XX_IDC_DEV_UNKNOWN)) {\r\nif ((next != QLC_83XX_IDC_DEV_COLD) &&\r\n(next != QLC_83XX_IDC_DEV_READY)) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: failed, cur %d prev %d next %d\n",\r\n__func__, cur, prev, next);\r\nreturn 1;\r\n}\r\n}\r\nif (next == QLC_83XX_IDC_DEV_INIT) {\r\nif ((prev != QLC_83XX_IDC_DEV_INIT) &&\r\n(prev != QLC_83XX_IDC_DEV_COLD) &&\r\n(prev != QLC_83XX_IDC_DEV_NEED_RESET)) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: failed, cur %d prev %d next %d\n",\r\n__func__, cur, prev, next);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_set_vxlan_port(struct qlcnic_adapter *adapter)\r\n{\r\nu16 port = adapter->ahw->vxlan_port;\r\nstruct qlcnic_cmd_args cmd;\r\nint ret = 0;\r\nmemset(&cmd, 0, sizeof(cmd));\r\nret = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_INIT_NIC_FUNC);\r\nif (ret)\r\nreturn ret;\r\ncmd.req.arg[1] = QLC_83XX_MULTI_TENANCY_INFO;\r\ncmd.req.arg[2] = QLC_83XX_ENCAP_TYPE_VXLAN |\r\nQLC_83XX_SET_VXLAN_UDP_DPORT |\r\nQLC_83XX_VXLAN_UDP_DPORT(port);\r\nret = qlcnic_issue_cmd(adapter, &cmd);\r\nif (ret)\r\nnetdev_err(adapter->netdev,\r\n"Failed to set VXLAN port %d in adapter\n",\r\nport);\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn ret;\r\n}\r\nstatic int qlcnic_set_vxlan_parsing(struct qlcnic_adapter *adapter,\r\nbool state)\r\n{\r\nu16 vxlan_port = adapter->ahw->vxlan_port;\r\nstruct qlcnic_cmd_args cmd;\r\nint ret = 0;\r\nmemset(&cmd, 0, sizeof(cmd));\r\nret = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_SET_INGRESS_ENCAP);\r\nif (ret)\r\nreturn ret;\r\ncmd.req.arg[1] = state ? QLCNIC_ENABLE_INGRESS_ENCAP_PARSING :\r\nQLCNIC_DISABLE_INGRESS_ENCAP_PARSING;\r\nret = qlcnic_issue_cmd(adapter, &cmd);\r\nif (ret)\r\nnetdev_err(adapter->netdev,\r\n"Failed to %s VXLAN parsing for port %d\n",\r\nstate ? "enable" : "disable", vxlan_port);\r\nelse\r\nnetdev_info(adapter->netdev,\r\n"%s VXLAN parsing for port %d\n",\r\nstate ? "Enabled" : "Disabled", vxlan_port);\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn ret;\r\n}\r\nstatic void qlcnic_83xx_periodic_tasks(struct qlcnic_adapter *adapter)\r\n{\r\nif (adapter->fhash.fnum)\r\nqlcnic_prune_lb_filters(adapter);\r\nif (adapter->flags & QLCNIC_ADD_VXLAN_PORT) {\r\nif (qlcnic_set_vxlan_port(adapter))\r\nreturn;\r\nif (qlcnic_set_vxlan_parsing(adapter, true))\r\nreturn;\r\nadapter->flags &= ~QLCNIC_ADD_VXLAN_PORT;\r\n} else if (adapter->flags & QLCNIC_DEL_VXLAN_PORT) {\r\nif (qlcnic_set_vxlan_parsing(adapter, false))\r\nreturn;\r\nadapter->ahw->vxlan_port = 0;\r\nadapter->flags &= ~QLCNIC_DEL_VXLAN_PORT;\r\n}\r\n}\r\nvoid qlcnic_83xx_idc_poll_dev_state(struct work_struct *work)\r\n{\r\nstruct qlcnic_adapter *adapter;\r\nu32 state;\r\nadapter = container_of(work, struct qlcnic_adapter, fw_work.work);\r\nstate = QLCRDX(adapter->ahw, QLC_83XX_IDC_DEV_STATE);\r\nif (qlcnic_83xx_idc_check_state_validity(adapter, state)) {\r\nqlcnic_83xx_idc_log_state_history(adapter);\r\nadapter->ahw->idc.curr_state = QLC_83XX_IDC_DEV_UNKNOWN;\r\n} else {\r\nadapter->ahw->idc.curr_state = state;\r\n}\r\nswitch (adapter->ahw->idc.curr_state) {\r\ncase QLC_83XX_IDC_DEV_READY:\r\nqlcnic_83xx_idc_ready_state(adapter);\r\nbreak;\r\ncase QLC_83XX_IDC_DEV_NEED_RESET:\r\nqlcnic_83xx_idc_need_reset_state(adapter);\r\nbreak;\r\ncase QLC_83XX_IDC_DEV_NEED_QUISCENT:\r\nqlcnic_83xx_idc_need_quiesce_state(adapter);\r\nbreak;\r\ncase QLC_83XX_IDC_DEV_FAILED:\r\nqlcnic_83xx_idc_failed_state(adapter);\r\nreturn;\r\ncase QLC_83XX_IDC_DEV_INIT:\r\nqlcnic_83xx_idc_init_state(adapter);\r\nbreak;\r\ncase QLC_83XX_IDC_DEV_QUISCENT:\r\nqlcnic_83xx_idc_quiesce_state(adapter);\r\nbreak;\r\ndefault:\r\nqlcnic_83xx_idc_unknown_state(adapter);\r\nreturn;\r\n}\r\nadapter->ahw->idc.prev_state = adapter->ahw->idc.curr_state;\r\nqlcnic_83xx_periodic_tasks(adapter);\r\nif (test_bit(QLC_83XX_MODULE_LOADED, &adapter->ahw->idc.status))\r\nqlcnic_schedule_work(adapter, qlcnic_83xx_idc_poll_dev_state,\r\nadapter->ahw->idc.delay);\r\n}\r\nstatic void qlcnic_83xx_setup_idc_parameters(struct qlcnic_adapter *adapter)\r\n{\r\nu32 idc_params, val;\r\nif (qlcnic_83xx_flash_read32(adapter, QLC_83XX_IDC_FLASH_PARAM_ADDR,\r\n(u8 *)&idc_params, 1)) {\r\ndev_info(&adapter->pdev->dev,\r\n"%s:failed to get IDC params from flash\n", __func__);\r\nadapter->dev_init_timeo = QLC_83XX_IDC_INIT_TIMEOUT_SECS;\r\nadapter->reset_ack_timeo = QLC_83XX_IDC_RESET_TIMEOUT_SECS;\r\n} else {\r\nadapter->dev_init_timeo = idc_params & 0xFFFF;\r\nadapter->reset_ack_timeo = ((idc_params >> 16) & 0xFFFF);\r\n}\r\nadapter->ahw->idc.curr_state = QLC_83XX_IDC_DEV_UNKNOWN;\r\nadapter->ahw->idc.prev_state = QLC_83XX_IDC_DEV_UNKNOWN;\r\nadapter->ahw->idc.delay = QLC_83XX_IDC_FW_POLL_DELAY;\r\nadapter->ahw->idc.err_code = 0;\r\nadapter->ahw->idc.collect_dump = 0;\r\nadapter->ahw->idc.name = (char **)qlc_83xx_idc_states;\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nset_bit(QLC_83XX_MODULE_LOADED, &adapter->ahw->idc.status);\r\nif (!qlcnic_auto_fw_reset) {\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\r\nval = val | QLC_83XX_IDC_DISABLE_FW_RESET_RECOVERY;\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_CTRL, val);\r\n}\r\n}\r\nstatic int\r\nqlcnic_83xx_idc_first_to_load_function_handler(struct qlcnic_adapter *adapter)\r\n{\r\nu32 state, val;\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EIO;\r\nQLCWRX(adapter->ahw, QLC_83XX_RECOVER_DRV_LOCK, 0);\r\nif (qlcnic_83xx_idc_update_major_version(adapter, 0)) {\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn -EIO;\r\n}\r\nstate = QLCRDX(adapter->ahw, QLC_83XX_IDC_DEV_STATE);\r\nif (qlcnic_83xx_idc_check_state_validity(adapter, state)) {\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn -EIO;\r\n}\r\nif (state != QLC_83XX_IDC_DEV_COLD && qlcnic_load_fw_file) {\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_DEV_STATE,\r\nQLC_83XX_IDC_DEV_COLD);\r\nstate = QLC_83XX_IDC_DEV_COLD;\r\n}\r\nadapter->ahw->idc.curr_state = state;\r\nif (state == QLC_83XX_IDC_DEV_COLD)\r\nqlcnic_83xx_idc_cold_state_handler(adapter);\r\nif (qlcnic_auto_fw_reset) {\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\r\nval = val & ~QLC_83XX_IDC_DISABLE_FW_RESET_RECOVERY;\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_CTRL, val);\r\n}\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_idc_init(struct qlcnic_adapter *adapter)\r\n{\r\nint ret = -EIO;\r\nqlcnic_83xx_setup_idc_parameters(adapter);\r\nif (qlcnic_83xx_get_reset_instruction_template(adapter))\r\nreturn ret;\r\nif (!qlcnic_83xx_idc_check_driver_presence_reg(adapter)) {\r\nif (qlcnic_83xx_idc_first_to_load_function_handler(adapter))\r\nreturn -EIO;\r\n} else {\r\nif (qlcnic_83xx_idc_check_major_version(adapter))\r\nreturn -EIO;\r\n}\r\nqlcnic_83xx_idc_update_audit_reg(adapter, 0, 1);\r\nreturn 0;\r\n}\r\nvoid qlcnic_83xx_idc_exit(struct qlcnic_adapter *adapter)\r\n{\r\nint id;\r\nu32 val;\r\nwhile (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\r\nusleep_range(10000, 11000);\r\nid = QLCRDX(adapter->ahw, QLC_83XX_DRV_LOCK_ID);\r\nid = id & 0xFF;\r\nif (id == adapter->portnum) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: wait for lock recovery.. %d\n", __func__, id);\r\nmsleep(20);\r\nid = QLCRDX(adapter->ahw, QLC_83XX_DRV_LOCK_ID);\r\nid = id & 0xFF;\r\n}\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE);\r\nval = val & ~(1 << adapter->portnum);\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE, val);\r\nclear_bit(QLC_83XX_MODULE_LOADED, &adapter->ahw->idc.status);\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\ncancel_delayed_work_sync(&adapter->fw_work);\r\n}\r\nvoid qlcnic_83xx_idc_request_reset(struct qlcnic_adapter *adapter, u32 key)\r\n{\r\nu32 val;\r\nif (qlcnic_sriov_vf_check(adapter))\r\nreturn;\r\nif (qlcnic_83xx_lock_driver(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s:failed, please retry\n", __func__);\r\nreturn;\r\n}\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\r\nif (val & QLC_83XX_IDC_DISABLE_FW_RESET_RECOVERY) {\r\nnetdev_info(adapter->netdev, "%s: Auto firmware recovery is disabled\n",\r\n__func__);\r\nqlcnic_83xx_idc_enter_failed_state(adapter, 0);\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn;\r\n}\r\nif (key == QLCNIC_FORCE_FW_RESET) {\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\r\nval = val | QLC_83XX_IDC_GRACEFULL_RESET;\r\nQLCWRX(adapter->ahw, QLC_83XX_IDC_CTRL, val);\r\n} else if (key == QLCNIC_FORCE_FW_DUMP_KEY) {\r\nadapter->ahw->idc.collect_dump = 1;\r\n}\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn;\r\n}\r\nstatic int qlcnic_83xx_copy_bootloader(struct qlcnic_adapter *adapter)\r\n{\r\nu8 *p_cache;\r\nu32 src, size;\r\nu64 dest;\r\nint ret = -EIO;\r\nsrc = QLC_83XX_BOOTLOADER_FLASH_ADDR;\r\ndest = QLCRDX(adapter->ahw, QLCNIC_BOOTLOADER_ADDR);\r\nsize = QLCRDX(adapter->ahw, QLCNIC_BOOTLOADER_SIZE);\r\nif (size & 0xF)\r\nsize = (size + 16) & ~0xF;\r\np_cache = vzalloc(size);\r\nif (p_cache == NULL)\r\nreturn -ENOMEM;\r\nret = qlcnic_83xx_lockless_flash_read32(adapter, src, p_cache,\r\nsize / sizeof(u32));\r\nif (ret) {\r\nvfree(p_cache);\r\nreturn ret;\r\n}\r\nret = qlcnic_ms_mem_write128(adapter, dest, (u32 *)p_cache,\r\nsize / 16);\r\nif (ret) {\r\nvfree(p_cache);\r\nreturn ret;\r\n}\r\nvfree(p_cache);\r\nreturn ret;\r\n}\r\nstatic int qlcnic_83xx_copy_fw_file(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlc_83xx_fw_info *fw_info = adapter->ahw->fw_info;\r\nconst struct firmware *fw = fw_info->fw;\r\nu32 dest, *p_cache, *temp;\r\nint i, ret = -EIO;\r\n__le32 *temp_le;\r\nu8 data[16];\r\nsize_t size;\r\nu64 addr;\r\ntemp = vzalloc(fw->size);\r\nif (!temp) {\r\nrelease_firmware(fw);\r\nfw_info->fw = NULL;\r\nreturn -ENOMEM;\r\n}\r\ntemp_le = (__le32 *)fw->data;\r\nfor (i = 0; i < fw->size / sizeof(u32); i++)\r\ntemp[i] = __le32_to_cpu(temp_le[i]);\r\ndest = QLCRDX(adapter->ahw, QLCNIC_FW_IMAGE_ADDR);\r\nsize = (fw->size & ~0xF);\r\np_cache = temp;\r\naddr = (u64)dest;\r\nret = qlcnic_ms_mem_write128(adapter, addr,\r\np_cache, size / 16);\r\nif (ret) {\r\ndev_err(&adapter->pdev->dev, "MS memory write failed\n");\r\ngoto exit;\r\n}\r\nif (fw->size & 0xF) {\r\naddr = dest + size;\r\nfor (i = 0; i < (fw->size & 0xF); i++)\r\ndata[i] = ((u8 *)temp)[size + i];\r\nfor (; i < 16; i++)\r\ndata[i] = 0;\r\nret = qlcnic_ms_mem_write128(adapter, addr,\r\n(u32 *)data, 1);\r\nif (ret) {\r\ndev_err(&adapter->pdev->dev,\r\n"MS memory write failed\n");\r\ngoto exit;\r\n}\r\n}\r\nexit:\r\nrelease_firmware(fw);\r\nfw_info->fw = NULL;\r\nvfree(temp);\r\nreturn ret;\r\n}\r\nstatic void qlcnic_83xx_dump_pause_control_regs(struct qlcnic_adapter *adapter)\r\n{\r\nint i, j;\r\nu32 val = 0, val1 = 0, reg = 0;\r\nint err = 0;\r\nval = QLCRD32(adapter, QLC_83XX_SRE_SHIM_REG, &err);\r\nif (err == -EIO)\r\nreturn;\r\ndev_info(&adapter->pdev->dev, "SRE-Shim Ctrl:0x%x\n", val);\r\nfor (j = 0; j < 2; j++) {\r\nif (j == 0) {\r\ndev_info(&adapter->pdev->dev,\r\n"Port 0 RxB Pause Threshold Regs[TC7..TC0]:");\r\nreg = QLC_83XX_PORT0_THRESHOLD;\r\n} else if (j == 1) {\r\ndev_info(&adapter->pdev->dev,\r\n"Port 1 RxB Pause Threshold Regs[TC7..TC0]:");\r\nreg = QLC_83XX_PORT1_THRESHOLD;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nval = QLCRD32(adapter, reg + (i * 0x4), &err);\r\nif (err == -EIO)\r\nreturn;\r\ndev_info(&adapter->pdev->dev, "0x%x ", val);\r\n}\r\ndev_info(&adapter->pdev->dev, "\n");\r\n}\r\nfor (j = 0; j < 2; j++) {\r\nif (j == 0) {\r\ndev_info(&adapter->pdev->dev,\r\n"Port 0 RxB TC Max Cell Registers[4..1]:");\r\nreg = QLC_83XX_PORT0_TC_MC_REG;\r\n} else if (j == 1) {\r\ndev_info(&adapter->pdev->dev,\r\n"Port 1 RxB TC Max Cell Registers[4..1]:");\r\nreg = QLC_83XX_PORT1_TC_MC_REG;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nval = QLCRD32(adapter, reg + (i * 0x4), &err);\r\nif (err == -EIO)\r\nreturn;\r\ndev_info(&adapter->pdev->dev, "0x%x ", val);\r\n}\r\ndev_info(&adapter->pdev->dev, "\n");\r\n}\r\nfor (j = 0; j < 2; j++) {\r\nif (j == 0) {\r\ndev_info(&adapter->pdev->dev,\r\n"Port 0 RxB Rx TC Stats[TC7..TC0]:");\r\nreg = QLC_83XX_PORT0_TC_STATS;\r\n} else if (j == 1) {\r\ndev_info(&adapter->pdev->dev,\r\n"Port 1 RxB Rx TC Stats[TC7..TC0]:");\r\nreg = QLC_83XX_PORT1_TC_STATS;\r\n}\r\nfor (i = 7; i >= 0; i--) {\r\nval = QLCRD32(adapter, reg, &err);\r\nif (err == -EIO)\r\nreturn;\r\nval &= ~(0x7 << 29);\r\nQLCWR32(adapter, reg, (val | (i << 29)));\r\nval = QLCRD32(adapter, reg, &err);\r\nif (err == -EIO)\r\nreturn;\r\ndev_info(&adapter->pdev->dev, "0x%x ", val);\r\n}\r\ndev_info(&adapter->pdev->dev, "\n");\r\n}\r\nval = QLCRD32(adapter, QLC_83XX_PORT2_IFB_THRESHOLD, &err);\r\nif (err == -EIO)\r\nreturn;\r\nval1 = QLCRD32(adapter, QLC_83XX_PORT3_IFB_THRESHOLD, &err);\r\nif (err == -EIO)\r\nreturn;\r\ndev_info(&adapter->pdev->dev,\r\n"IFB-Pause Thresholds: Port 2:0x%x, Port 3:0x%x\n",\r\nval, val1);\r\n}\r\nstatic void qlcnic_83xx_disable_pause_frames(struct qlcnic_adapter *adapter)\r\n{\r\nu32 reg = 0, i, j;\r\nif (qlcnic_83xx_lock_driver(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s:failed to acquire driver lock\n", __func__);\r\nreturn;\r\n}\r\nqlcnic_83xx_dump_pause_control_regs(adapter);\r\nQLCWR32(adapter, QLC_83XX_SRE_SHIM_REG, 0x0);\r\nfor (j = 0; j < 2; j++) {\r\nif (j == 0)\r\nreg = QLC_83XX_PORT0_THRESHOLD;\r\nelse if (j == 1)\r\nreg = QLC_83XX_PORT1_THRESHOLD;\r\nfor (i = 0; i < 8; i++)\r\nQLCWR32(adapter, reg + (i * 0x4), 0x0);\r\n}\r\nfor (j = 0; j < 2; j++) {\r\nif (j == 0)\r\nreg = QLC_83XX_PORT0_TC_MC_REG;\r\nelse if (j == 1)\r\nreg = QLC_83XX_PORT1_TC_MC_REG;\r\nfor (i = 0; i < 4; i++)\r\nQLCWR32(adapter, reg + (i * 0x4), 0x03FF03FF);\r\n}\r\nQLCWR32(adapter, QLC_83XX_PORT2_IFB_THRESHOLD, 0);\r\nQLCWR32(adapter, QLC_83XX_PORT3_IFB_THRESHOLD, 0);\r\ndev_info(&adapter->pdev->dev,\r\n"Disabled pause frames successfully on all ports\n");\r\nqlcnic_83xx_unlock_driver(adapter);\r\n}\r\nstatic void qlcnic_83xx_take_eport_out_of_reset(struct qlcnic_adapter *adapter)\r\n{\r\nQLCWR32(adapter, QLC_83XX_RESET_REG, 0);\r\nQLCWR32(adapter, QLC_83XX_RESET_PORT0, 0);\r\nQLCWR32(adapter, QLC_83XX_RESET_PORT1, 0);\r\nQLCWR32(adapter, QLC_83XX_RESET_PORT2, 0);\r\nQLCWR32(adapter, QLC_83XX_RESET_PORT3, 0);\r\nQLCWR32(adapter, QLC_83XX_RESET_SRESHIM, 0);\r\nQLCWR32(adapter, QLC_83XX_RESET_EPGSHIM, 0);\r\nQLCWR32(adapter, QLC_83XX_RESET_ETHERPCS, 0);\r\nQLCWR32(adapter, QLC_83XX_RESET_CONTROL, 1);\r\n}\r\nstatic int qlcnic_83xx_check_heartbeat(struct qlcnic_adapter *p_dev)\r\n{\r\nu32 heartbeat, peg_status;\r\nint retries, ret = -EIO, err = 0;\r\nretries = QLCNIC_HEARTBEAT_CHECK_RETRY_COUNT;\r\np_dev->heartbeat = QLC_SHARED_REG_RD32(p_dev,\r\nQLCNIC_PEG_ALIVE_COUNTER);\r\ndo {\r\nmsleep(QLCNIC_HEARTBEAT_PERIOD_MSECS);\r\nheartbeat = QLC_SHARED_REG_RD32(p_dev,\r\nQLCNIC_PEG_ALIVE_COUNTER);\r\nif (heartbeat != p_dev->heartbeat) {\r\nret = QLCNIC_RCODE_SUCCESS;\r\nbreak;\r\n}\r\n} while (--retries);\r\nif (ret) {\r\ndev_err(&p_dev->pdev->dev, "firmware hang detected\n");\r\nqlcnic_83xx_take_eport_out_of_reset(p_dev);\r\nqlcnic_83xx_disable_pause_frames(p_dev);\r\npeg_status = QLC_SHARED_REG_RD32(p_dev,\r\nQLCNIC_PEG_HALT_STATUS1);\r\ndev_info(&p_dev->pdev->dev, "Dumping HW/FW registers\n"\r\n"PEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,\n"\r\n"PEG_NET_0_PC: 0x%x, PEG_NET_1_PC: 0x%x,\n"\r\n"PEG_NET_2_PC: 0x%x, PEG_NET_3_PC: 0x%x,\n"\r\n"PEG_NET_4_PC: 0x%x\n", peg_status,\r\nQLC_SHARED_REG_RD32(p_dev, QLCNIC_PEG_HALT_STATUS2),\r\nQLCRD32(p_dev, QLC_83XX_CRB_PEG_NET_0, &err),\r\nQLCRD32(p_dev, QLC_83XX_CRB_PEG_NET_1, &err),\r\nQLCRD32(p_dev, QLC_83XX_CRB_PEG_NET_2, &err),\r\nQLCRD32(p_dev, QLC_83XX_CRB_PEG_NET_3, &err),\r\nQLCRD32(p_dev, QLC_83XX_CRB_PEG_NET_4, &err));\r\nif (QLCNIC_FWERROR_CODE(peg_status) == 0x67)\r\ndev_err(&p_dev->pdev->dev,\r\n"Device is being reset err code 0x00006700.\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int qlcnic_83xx_check_cmd_peg_status(struct qlcnic_adapter *p_dev)\r\n{\r\nint retries = QLCNIC_CMDPEG_CHECK_RETRY_COUNT;\r\nu32 val;\r\ndo {\r\nval = QLC_SHARED_REG_RD32(p_dev, QLCNIC_CMDPEG_STATE);\r\nif (val == QLC_83XX_CMDPEG_COMPLETE)\r\nreturn 0;\r\nmsleep(QLCNIC_CMDPEG_CHECK_DELAY);\r\n} while (--retries);\r\ndev_err(&p_dev->pdev->dev, "%s: failed, state = 0x%x\n", __func__, val);\r\nreturn -EIO;\r\n}\r\nstatic int qlcnic_83xx_check_hw_status(struct qlcnic_adapter *p_dev)\r\n{\r\nint err;\r\nerr = qlcnic_83xx_check_cmd_peg_status(p_dev);\r\nif (err)\r\nreturn err;\r\nerr = qlcnic_83xx_check_heartbeat(p_dev);\r\nif (err)\r\nreturn err;\r\nreturn err;\r\n}\r\nstatic int qlcnic_83xx_poll_reg(struct qlcnic_adapter *p_dev, u32 addr,\r\nint duration, u32 mask, u32 status)\r\n{\r\nint timeout_error, err = 0;\r\nu32 value;\r\nu8 retries;\r\nvalue = QLCRD32(p_dev, addr, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nretries = duration / 10;\r\ndo {\r\nif ((value & mask) != status) {\r\ntimeout_error = 1;\r\nmsleep(duration / 10);\r\nvalue = QLCRD32(p_dev, addr, &err);\r\nif (err == -EIO)\r\nreturn err;\r\n} else {\r\ntimeout_error = 0;\r\nbreak;\r\n}\r\n} while (retries--);\r\nif (timeout_error) {\r\np_dev->ahw->reset.seq_error++;\r\ndev_err(&p_dev->pdev->dev,\r\n"%s: Timeout Err, entry_num = %d\n",\r\n__func__, p_dev->ahw->reset.seq_index);\r\ndev_err(&p_dev->pdev->dev,\r\n"0x%08x 0x%08x 0x%08x\n",\r\nvalue, mask, status);\r\n}\r\nreturn timeout_error;\r\n}\r\nstatic int qlcnic_83xx_reset_template_checksum(struct qlcnic_adapter *p_dev)\r\n{\r\nu32 sum = 0;\r\nu16 *buff = (u16 *)p_dev->ahw->reset.buff;\r\nint count = p_dev->ahw->reset.hdr->size / sizeof(u16);\r\nwhile (count-- > 0)\r\nsum += *buff++;\r\nwhile (sum >> 16)\r\nsum = (sum & 0xFFFF) + (sum >> 16);\r\nif (~sum) {\r\nreturn 0;\r\n} else {\r\ndev_err(&p_dev->pdev->dev, "%s: failed\n", __func__);\r\nreturn -1;\r\n}\r\n}\r\nstatic int qlcnic_83xx_get_reset_instruction_template(struct qlcnic_adapter *p_dev)\r\n{\r\nstruct qlcnic_hardware_context *ahw = p_dev->ahw;\r\nu32 addr, count, prev_ver, curr_ver;\r\nu8 *p_buff;\r\nif (ahw->reset.buff != NULL) {\r\nprev_ver = p_dev->fw_version;\r\ncurr_ver = qlcnic_83xx_get_fw_version(p_dev);\r\nif (curr_ver > prev_ver)\r\nkfree(ahw->reset.buff);\r\nelse\r\nreturn 0;\r\n}\r\nahw->reset.seq_error = 0;\r\nahw->reset.buff = kzalloc(QLC_83XX_RESTART_TEMPLATE_SIZE, GFP_KERNEL);\r\nif (p_dev->ahw->reset.buff == NULL)\r\nreturn -ENOMEM;\r\np_buff = p_dev->ahw->reset.buff;\r\naddr = QLC_83XX_RESET_TEMPLATE_ADDR;\r\ncount = sizeof(struct qlc_83xx_reset_hdr) / sizeof(u32);\r\nif (qlcnic_83xx_flash_read32(p_dev, addr, p_buff, count)) {\r\ndev_err(&p_dev->pdev->dev, "%s: flash read failed\n", __func__);\r\nreturn -EIO;\r\n}\r\nahw->reset.hdr = (struct qlc_83xx_reset_hdr *)ahw->reset.buff;\r\naddr = QLC_83XX_RESET_TEMPLATE_ADDR + ahw->reset.hdr->hdr_size;\r\np_buff = ahw->reset.buff + ahw->reset.hdr->hdr_size;\r\ncount = (ahw->reset.hdr->size - ahw->reset.hdr->hdr_size) / sizeof(u32);\r\nif (qlcnic_83xx_flash_read32(p_dev, addr, p_buff, count)) {\r\ndev_err(&p_dev->pdev->dev, "%s: flash read failed\n", __func__);\r\nreturn -EIO;\r\n}\r\nif (qlcnic_83xx_reset_template_checksum(p_dev))\r\nreturn -EIO;\r\nahw->reset.init_offset = ahw->reset.buff + ahw->reset.hdr->init_offset;\r\nahw->reset.start_offset = ahw->reset.buff +\r\nahw->reset.hdr->start_offset;\r\nahw->reset.stop_offset = ahw->reset.buff + ahw->reset.hdr->hdr_size;\r\nreturn 0;\r\n}\r\nstatic void qlcnic_83xx_read_write_crb_reg(struct qlcnic_adapter *p_dev,\r\nu32 raddr, u32 waddr)\r\n{\r\nint err = 0;\r\nu32 value;\r\nvalue = QLCRD32(p_dev, raddr, &err);\r\nif (err == -EIO)\r\nreturn;\r\nqlcnic_83xx_wrt_reg_indirect(p_dev, waddr, value);\r\n}\r\nstatic void qlcnic_83xx_rmw_crb_reg(struct qlcnic_adapter *p_dev,\r\nu32 raddr, u32 waddr,\r\nstruct qlc_83xx_rmw *p_rmw_hdr)\r\n{\r\nint err = 0;\r\nu32 value;\r\nif (p_rmw_hdr->index_a) {\r\nvalue = p_dev->ahw->reset.array[p_rmw_hdr->index_a];\r\n} else {\r\nvalue = QLCRD32(p_dev, raddr, &err);\r\nif (err == -EIO)\r\nreturn;\r\n}\r\nvalue &= p_rmw_hdr->mask;\r\nvalue <<= p_rmw_hdr->shl;\r\nvalue >>= p_rmw_hdr->shr;\r\nvalue |= p_rmw_hdr->or_value;\r\nvalue ^= p_rmw_hdr->xor_value;\r\nqlcnic_83xx_wrt_reg_indirect(p_dev, waddr, value);\r\n}\r\nstatic void qlcnic_83xx_write_list(struct qlcnic_adapter *p_dev,\r\nstruct qlc_83xx_entry_hdr *p_hdr)\r\n{\r\nint i;\r\nstruct qlc_83xx_entry *entry;\r\nentry = (struct qlc_83xx_entry *)((char *)p_hdr +\r\nsizeof(struct qlc_83xx_entry_hdr));\r\nfor (i = 0; i < p_hdr->count; i++, entry++) {\r\nqlcnic_83xx_wrt_reg_indirect(p_dev, entry->arg1,\r\nentry->arg2);\r\nif (p_hdr->delay)\r\nudelay((u32)(p_hdr->delay));\r\n}\r\n}\r\nstatic void qlcnic_83xx_read_write_list(struct qlcnic_adapter *p_dev,\r\nstruct qlc_83xx_entry_hdr *p_hdr)\r\n{\r\nint i;\r\nstruct qlc_83xx_entry *entry;\r\nentry = (struct qlc_83xx_entry *)((char *)p_hdr +\r\nsizeof(struct qlc_83xx_entry_hdr));\r\nfor (i = 0; i < p_hdr->count; i++, entry++) {\r\nqlcnic_83xx_read_write_crb_reg(p_dev, entry->arg1,\r\nentry->arg2);\r\nif (p_hdr->delay)\r\nudelay((u32)(p_hdr->delay));\r\n}\r\n}\r\nstatic void qlcnic_83xx_poll_list(struct qlcnic_adapter *p_dev,\r\nstruct qlc_83xx_entry_hdr *p_hdr)\r\n{\r\nlong delay;\r\nstruct qlc_83xx_entry *entry;\r\nstruct qlc_83xx_poll *poll;\r\nint i, err = 0;\r\nunsigned long arg1, arg2;\r\npoll = (struct qlc_83xx_poll *)((char *)p_hdr +\r\nsizeof(struct qlc_83xx_entry_hdr));\r\nentry = (struct qlc_83xx_entry *)((char *)poll +\r\nsizeof(struct qlc_83xx_poll));\r\ndelay = (long)p_hdr->delay;\r\nif (!delay) {\r\nfor (i = 0; i < p_hdr->count; i++, entry++)\r\nqlcnic_83xx_poll_reg(p_dev, entry->arg1,\r\ndelay, poll->mask,\r\npoll->status);\r\n} else {\r\nfor (i = 0; i < p_hdr->count; i++, entry++) {\r\narg1 = entry->arg1;\r\narg2 = entry->arg2;\r\nif (delay) {\r\nif (qlcnic_83xx_poll_reg(p_dev,\r\narg1, delay,\r\npoll->mask,\r\npoll->status)){\r\nQLCRD32(p_dev, arg1, &err);\r\nif (err == -EIO)\r\nreturn;\r\nQLCRD32(p_dev, arg2, &err);\r\nif (err == -EIO)\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void qlcnic_83xx_poll_write_list(struct qlcnic_adapter *p_dev,\r\nstruct qlc_83xx_entry_hdr *p_hdr)\r\n{\r\nint i;\r\nlong delay;\r\nstruct qlc_83xx_quad_entry *entry;\r\nstruct qlc_83xx_poll *poll;\r\npoll = (struct qlc_83xx_poll *)((char *)p_hdr +\r\nsizeof(struct qlc_83xx_entry_hdr));\r\nentry = (struct qlc_83xx_quad_entry *)((char *)poll +\r\nsizeof(struct qlc_83xx_poll));\r\ndelay = (long)p_hdr->delay;\r\nfor (i = 0; i < p_hdr->count; i++, entry++) {\r\nqlcnic_83xx_wrt_reg_indirect(p_dev, entry->dr_addr,\r\nentry->dr_value);\r\nqlcnic_83xx_wrt_reg_indirect(p_dev, entry->ar_addr,\r\nentry->ar_value);\r\nif (delay)\r\nqlcnic_83xx_poll_reg(p_dev, entry->ar_addr, delay,\r\npoll->mask, poll->status);\r\n}\r\n}\r\nstatic void qlcnic_83xx_read_modify_write(struct qlcnic_adapter *p_dev,\r\nstruct qlc_83xx_entry_hdr *p_hdr)\r\n{\r\nint i;\r\nstruct qlc_83xx_entry *entry;\r\nstruct qlc_83xx_rmw *rmw_hdr;\r\nrmw_hdr = (struct qlc_83xx_rmw *)((char *)p_hdr +\r\nsizeof(struct qlc_83xx_entry_hdr));\r\nentry = (struct qlc_83xx_entry *)((char *)rmw_hdr +\r\nsizeof(struct qlc_83xx_rmw));\r\nfor (i = 0; i < p_hdr->count; i++, entry++) {\r\nqlcnic_83xx_rmw_crb_reg(p_dev, entry->arg1,\r\nentry->arg2, rmw_hdr);\r\nif (p_hdr->delay)\r\nudelay((u32)(p_hdr->delay));\r\n}\r\n}\r\nstatic void qlcnic_83xx_pause(struct qlc_83xx_entry_hdr *p_hdr)\r\n{\r\nif (p_hdr->delay)\r\nmdelay((u32)((long)p_hdr->delay));\r\n}\r\nstatic void qlcnic_83xx_poll_read_list(struct qlcnic_adapter *p_dev,\r\nstruct qlc_83xx_entry_hdr *p_hdr)\r\n{\r\nlong delay;\r\nint index, i, j, err;\r\nstruct qlc_83xx_quad_entry *entry;\r\nstruct qlc_83xx_poll *poll;\r\nunsigned long addr;\r\npoll = (struct qlc_83xx_poll *)((char *)p_hdr +\r\nsizeof(struct qlc_83xx_entry_hdr));\r\nentry = (struct qlc_83xx_quad_entry *)((char *)poll +\r\nsizeof(struct qlc_83xx_poll));\r\ndelay = (long)p_hdr->delay;\r\nfor (i = 0; i < p_hdr->count; i++, entry++) {\r\nqlcnic_83xx_wrt_reg_indirect(p_dev, entry->ar_addr,\r\nentry->ar_value);\r\nif (delay) {\r\nif (!qlcnic_83xx_poll_reg(p_dev, entry->ar_addr, delay,\r\npoll->mask, poll->status)){\r\nindex = p_dev->ahw->reset.array_index;\r\naddr = entry->dr_addr;\r\nj = QLCRD32(p_dev, addr, &err);\r\nif (err == -EIO)\r\nreturn;\r\np_dev->ahw->reset.array[index++] = j;\r\nif (index == QLC_83XX_MAX_RESET_SEQ_ENTRIES)\r\np_dev->ahw->reset.array_index = 1;\r\n}\r\n}\r\n}\r\n}\r\nstatic inline void qlcnic_83xx_seq_end(struct qlcnic_adapter *p_dev)\r\n{\r\np_dev->ahw->reset.seq_end = 1;\r\n}\r\nstatic void qlcnic_83xx_template_end(struct qlcnic_adapter *p_dev)\r\n{\r\np_dev->ahw->reset.template_end = 1;\r\nif (p_dev->ahw->reset.seq_error == 0)\r\ndev_err(&p_dev->pdev->dev,\r\n"HW restart process completed successfully.\n");\r\nelse\r\ndev_err(&p_dev->pdev->dev,\r\n"HW restart completed with timeout errors.\n");\r\n}\r\nstatic void qlcnic_83xx_exec_template_cmd(struct qlcnic_adapter *p_dev,\r\nchar *p_buff)\r\n{\r\nint index, entries;\r\nstruct qlc_83xx_entry_hdr *p_hdr;\r\nchar *entry = p_buff;\r\np_dev->ahw->reset.seq_end = 0;\r\np_dev->ahw->reset.template_end = 0;\r\nentries = p_dev->ahw->reset.hdr->entries;\r\nindex = p_dev->ahw->reset.seq_index;\r\nfor (; (!p_dev->ahw->reset.seq_end) && (index < entries); index++) {\r\np_hdr = (struct qlc_83xx_entry_hdr *)entry;\r\nswitch (p_hdr->cmd) {\r\ncase QLC_83XX_OPCODE_NOP:\r\nbreak;\r\ncase QLC_83XX_OPCODE_WRITE_LIST:\r\nqlcnic_83xx_write_list(p_dev, p_hdr);\r\nbreak;\r\ncase QLC_83XX_OPCODE_READ_WRITE_LIST:\r\nqlcnic_83xx_read_write_list(p_dev, p_hdr);\r\nbreak;\r\ncase QLC_83XX_OPCODE_POLL_LIST:\r\nqlcnic_83xx_poll_list(p_dev, p_hdr);\r\nbreak;\r\ncase QLC_83XX_OPCODE_POLL_WRITE_LIST:\r\nqlcnic_83xx_poll_write_list(p_dev, p_hdr);\r\nbreak;\r\ncase QLC_83XX_OPCODE_READ_MODIFY_WRITE:\r\nqlcnic_83xx_read_modify_write(p_dev, p_hdr);\r\nbreak;\r\ncase QLC_83XX_OPCODE_SEQ_PAUSE:\r\nqlcnic_83xx_pause(p_hdr);\r\nbreak;\r\ncase QLC_83XX_OPCODE_SEQ_END:\r\nqlcnic_83xx_seq_end(p_dev);\r\nbreak;\r\ncase QLC_83XX_OPCODE_TMPL_END:\r\nqlcnic_83xx_template_end(p_dev);\r\nbreak;\r\ncase QLC_83XX_OPCODE_POLL_READ_LIST:\r\nqlcnic_83xx_poll_read_list(p_dev, p_hdr);\r\nbreak;\r\ndefault:\r\ndev_err(&p_dev->pdev->dev,\r\n"%s: Unknown opcode 0x%04x in template %d\n",\r\n__func__, p_hdr->cmd, index);\r\nbreak;\r\n}\r\nentry += p_hdr->size;\r\n}\r\np_dev->ahw->reset.seq_index = index;\r\n}\r\nstatic void qlcnic_83xx_stop_hw(struct qlcnic_adapter *p_dev)\r\n{\r\np_dev->ahw->reset.seq_index = 0;\r\nqlcnic_83xx_exec_template_cmd(p_dev, p_dev->ahw->reset.stop_offset);\r\nif (p_dev->ahw->reset.seq_end != 1)\r\ndev_err(&p_dev->pdev->dev, "%s: failed\n", __func__);\r\n}\r\nstatic void qlcnic_83xx_start_hw(struct qlcnic_adapter *p_dev)\r\n{\r\nqlcnic_83xx_exec_template_cmd(p_dev, p_dev->ahw->reset.start_offset);\r\nif (p_dev->ahw->reset.template_end != 1)\r\ndev_err(&p_dev->pdev->dev, "%s: failed\n", __func__);\r\n}\r\nstatic void qlcnic_83xx_init_hw(struct qlcnic_adapter *p_dev)\r\n{\r\nqlcnic_83xx_exec_template_cmd(p_dev, p_dev->ahw->reset.init_offset);\r\nif (p_dev->ahw->reset.seq_end != 1)\r\ndev_err(&p_dev->pdev->dev, "%s: failed\n", __func__);\r\n}\r\nstatic int qlcnic_83xx_run_post(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlc_83xx_fw_info *fw_info = adapter->ahw->fw_info;\r\nstruct device *dev = &adapter->pdev->dev;\r\nint timeout, count, ret = 0;\r\nu32 signature;\r\nswitch (adapter->ahw->post_mode) {\r\ncase QLC_83XX_POST_FAST_MODE:\r\ntimeout = QLC_83XX_POST_FAST_MODE_TIMEOUT + 2000;\r\nbreak;\r\ncase QLC_83XX_POST_MEDIUM_MODE:\r\ntimeout = QLC_83XX_POST_MED_MODE_TIMEOUT + 2000;\r\nbreak;\r\ncase QLC_83XX_POST_SLOW_MODE:\r\ntimeout = QLC_83XX_POST_SLOW_MODE_TIMEOUT + 2000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstrncpy(fw_info->fw_file_name, QLC_83XX_POST_FW_FILE_NAME,\r\nQLC_FW_FILE_NAME_LEN);\r\nret = request_firmware(&fw_info->fw, fw_info->fw_file_name, dev);\r\nif (ret) {\r\ndev_err(dev, "POST firmware can not be loaded, skipping POST\n");\r\nreturn 0;\r\n}\r\nret = qlcnic_83xx_copy_fw_file(adapter);\r\nif (ret)\r\nreturn ret;\r\nqlcnic_ind_wr(adapter, QLC_83XX_POST_SIGNATURE_REG, 0);\r\nqlcnic_ind_wr(adapter, QLC_83XX_POST_MODE_REG,\r\nadapter->ahw->post_mode);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_FW_IMG_VALID,\r\nQLC_83XX_BOOT_FROM_FILE);\r\nqlcnic_83xx_start_hw(adapter);\r\ncount = 0;\r\ndo {\r\nmsleep(100);\r\ncount += 100;\r\nsignature = qlcnic_ind_rd(adapter, QLC_83XX_POST_SIGNATURE_REG);\r\nif (signature == QLC_83XX_POST_PASS)\r\nbreak;\r\n} while (timeout > count);\r\nif (timeout <= count) {\r\ndev_err(dev, "POST timed out, signature = 0x%08x\n", signature);\r\nreturn -EIO;\r\n}\r\nswitch (signature) {\r\ncase QLC_83XX_POST_PASS:\r\ndev_info(dev, "POST passed, Signature = 0x%08x\n", signature);\r\nbreak;\r\ncase QLC_83XX_POST_ASIC_STRESS_TEST_FAIL:\r\ndev_err(dev, "POST failed, Test case : ASIC STRESS TEST, Signature = 0x%08x\n",\r\nsignature);\r\nret = -EIO;\r\nbreak;\r\ncase QLC_83XX_POST_DDR_TEST_FAIL:\r\ndev_err(dev, "POST failed, Test case : DDT TEST, Signature = 0x%08x\n",\r\nsignature);\r\nret = -EIO;\r\nbreak;\r\ncase QLC_83XX_POST_ASIC_MEMORY_TEST_FAIL:\r\ndev_err(dev, "POST failed, Test case : ASIC MEMORY TEST, Signature = 0x%08x\n",\r\nsignature);\r\nret = -EIO;\r\nbreak;\r\ncase QLC_83XX_POST_FLASH_TEST_FAIL:\r\ndev_err(dev, "POST failed, Test case : FLASH TEST, Signature = 0x%08x\n",\r\nsignature);\r\nret = -EIO;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "POST failed, Test case : INVALID, Signature = 0x%08x\n",\r\nsignature);\r\nret = -EIO;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int qlcnic_83xx_load_fw_image_from_host(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlc_83xx_fw_info *fw_info = adapter->ahw->fw_info;\r\nint err = -EIO;\r\nif (request_firmware(&fw_info->fw, fw_info->fw_file_name,\r\n&(adapter->pdev->dev))) {\r\ndev_err(&adapter->pdev->dev,\r\n"No file FW image, loading flash FW image.\n");\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_FW_IMG_VALID,\r\nQLC_83XX_BOOT_FROM_FLASH);\r\n} else {\r\nif (qlcnic_83xx_copy_fw_file(adapter))\r\nreturn err;\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_FW_IMG_VALID,\r\nQLC_83XX_BOOT_FROM_FILE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_restart_hw(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val;\r\nint err = -EIO;\r\nqlcnic_83xx_stop_hw(adapter);\r\nval = QLCRDX(adapter->ahw, QLC_83XX_IDC_CTRL);\r\nif (!(val & QLC_83XX_IDC_GRACEFULL_RESET))\r\nqlcnic_dump_fw(adapter);\r\nif (val & QLC_83XX_IDC_DISABLE_FW_RESET_RECOVERY) {\r\nnetdev_info(adapter->netdev, "%s: Auto firmware recovery is disabled\n",\r\n__func__);\r\nqlcnic_83xx_idc_enter_failed_state(adapter, 1);\r\nreturn err;\r\n}\r\nqlcnic_83xx_init_hw(adapter);\r\nif (qlcnic_83xx_copy_bootloader(adapter))\r\nreturn err;\r\nif (adapter->ahw->run_post) {\r\nerr = qlcnic_83xx_run_post(adapter);\r\nif (err)\r\nreturn err;\r\nadapter->ahw->run_post = false;\r\nqlcnic_83xx_stop_hw(adapter);\r\nqlcnic_83xx_init_hw(adapter);\r\nerr = qlcnic_83xx_copy_bootloader(adapter);\r\nif (err)\r\nreturn err;\r\n}\r\nif (qlcnic_load_fw_file == 1) {\r\nif (qlcnic_83xx_load_fw_image_from_host(adapter))\r\nreturn err;\r\n} else {\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_FW_IMG_VALID,\r\nQLC_83XX_BOOT_FROM_FLASH);\r\n}\r\nqlcnic_83xx_start_hw(adapter);\r\nif (qlcnic_83xx_check_hw_status(adapter))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_get_nic_configuration(struct qlcnic_adapter *adapter)\r\n{\r\nint err;\r\nstruct qlcnic_info nic_info;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nmemset(&nic_info, 0, sizeof(struct qlcnic_info));\r\nerr = qlcnic_get_nic_info(adapter, &nic_info, ahw->pci_func);\r\nif (err)\r\nreturn -EIO;\r\nahw->physical_port = (u8) nic_info.phys_port;\r\nahw->switch_mode = nic_info.switch_mode;\r\nahw->max_tx_ques = nic_info.max_tx_ques;\r\nahw->max_rx_ques = nic_info.max_rx_ques;\r\nahw->capabilities = nic_info.capabilities;\r\nahw->max_mac_filters = nic_info.max_mac_filters;\r\nahw->max_mtu = nic_info.max_mtu;\r\nif (test_bit(__QLCNIC_SRIOV_CAPABLE, &adapter->state))\r\nreturn QLC_83XX_DEFAULT_OPMODE;\r\nif (ahw->capabilities & QLC_83XX_ESWITCH_CAPABILITY)\r\nreturn QLCNIC_VNIC_MODE;\r\nreturn QLC_83XX_DEFAULT_OPMODE;\r\n}\r\nint qlcnic_83xx_configure_opmode(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nu16 max_sds_rings, max_tx_rings;\r\nint ret;\r\nret = qlcnic_83xx_get_nic_configuration(adapter);\r\nif (ret == -EIO)\r\nreturn -EIO;\r\nif (ret == QLCNIC_VNIC_MODE) {\r\nahw->nic_mode = QLCNIC_VNIC_MODE;\r\nif (qlcnic_83xx_config_vnic_opmode(adapter))\r\nreturn -EIO;\r\nmax_sds_rings = QLCNIC_MAX_VNIC_SDS_RINGS;\r\nmax_tx_rings = QLCNIC_MAX_VNIC_TX_RINGS;\r\n} else if (ret == QLC_83XX_DEFAULT_OPMODE) {\r\nahw->nic_mode = QLCNIC_DEFAULT_MODE;\r\nadapter->nic_ops->init_driver = qlcnic_83xx_init_default_driver;\r\nahw->idc.state_entry = qlcnic_83xx_idc_ready_state_entry;\r\nmax_sds_rings = QLCNIC_MAX_SDS_RINGS;\r\nmax_tx_rings = QLCNIC_MAX_TX_RINGS;\r\n} else {\r\ndev_err(&adapter->pdev->dev, "%s: Invalid opmode %d\n",\r\n__func__, ret);\r\nreturn -EIO;\r\n}\r\nadapter->max_sds_rings = min(ahw->max_rx_ques, max_sds_rings);\r\nadapter->max_tx_rings = min(ahw->max_tx_ques, max_tx_rings);\r\nreturn 0;\r\n}\r\nstatic void qlcnic_83xx_config_buff_descriptors(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nif (ahw->port_type == QLCNIC_XGBE) {\r\nadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_10G;\r\nadapter->max_rxd = MAX_RCV_DESCRIPTORS_10G;\r\nadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_10G;\r\nadapter->max_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_10G;\r\n} else if (ahw->port_type == QLCNIC_GBE) {\r\nadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_1G;\r\nadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_1G;\r\nadapter->max_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_1G;\r\nadapter->max_rxd = MAX_RCV_DESCRIPTORS_1G;\r\n}\r\nadapter->num_txd = MAX_CMD_DESCRIPTORS;\r\nadapter->max_rds_rings = MAX_RDS_RINGS;\r\n}\r\nstatic int qlcnic_83xx_init_default_driver(struct qlcnic_adapter *adapter)\r\n{\r\nint err = -EIO;\r\nqlcnic_83xx_get_minidump_template(adapter);\r\nif (qlcnic_83xx_get_port_info(adapter))\r\nreturn err;\r\nqlcnic_83xx_config_buff_descriptors(adapter);\r\nadapter->ahw->msix_supported = !!qlcnic_use_msi_x;\r\nadapter->flags |= QLCNIC_ADAPTER_INITIALIZED;\r\ndev_info(&adapter->pdev->dev, "HAL Version: %d\n",\r\nadapter->ahw->fw_hal_version);\r\nreturn 0;\r\n}\r\nstatic void qlcnic_83xx_clear_function_resources(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nu32 presence_mask, audit_mask;\r\nint status;\r\npresence_mask = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_PRESENCE);\r\naudit_mask = QLCRDX(adapter->ahw, QLC_83XX_IDC_DRV_AUDIT);\r\nif (IS_QLC_83XX_USED(adapter, presence_mask, audit_mask)) {\r\nstatus = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_STOP_NIC_FUNC);\r\nif (status)\r\nreturn;\r\ncmd.req.arg[1] = BIT_31;\r\nstatus = qlcnic_issue_cmd(adapter, &cmd);\r\nif (status)\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to clean up the function resources\n");\r\nqlcnic_free_mbx_args(&cmd);\r\n}\r\n}\r\nstatic int qlcnic_83xx_get_fw_info(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct qlc_83xx_fw_info *fw_info;\r\nint err = 0;\r\nahw->fw_info = kzalloc(sizeof(*fw_info), GFP_KERNEL);\r\nif (!ahw->fw_info) {\r\nerr = -ENOMEM;\r\n} else {\r\nfw_info = ahw->fw_info;\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_QLOGIC_QLE834X:\r\ncase PCI_DEVICE_ID_QLOGIC_QLE8830:\r\nstrncpy(fw_info->fw_file_name, QLC_83XX_FW_FILE_NAME,\r\nQLC_FW_FILE_NAME_LEN);\r\nbreak;\r\ncase PCI_DEVICE_ID_QLOGIC_QLE844X:\r\nstrncpy(fw_info->fw_file_name, QLC_84XX_FW_FILE_NAME,\r\nQLC_FW_FILE_NAME_LEN);\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "%s: Invalid device id\n",\r\n__func__);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void qlcnic_83xx_init_rings(struct qlcnic_adapter *adapter)\r\n{\r\nu8 rx_cnt = QLCNIC_DEF_SDS_RINGS;\r\nu8 tx_cnt = QLCNIC_DEF_TX_RINGS;\r\nadapter->max_tx_rings = QLCNIC_MAX_TX_RINGS;\r\nadapter->max_sds_rings = QLCNIC_MAX_SDS_RINGS;\r\nif (!adapter->ahw->msix_supported) {\r\nrx_cnt = QLCNIC_SINGLE_RING;\r\ntx_cnt = QLCNIC_SINGLE_RING;\r\n}\r\nqlcnic_set_tx_ring_count(adapter, tx_cnt);\r\nqlcnic_set_sds_ring_count(adapter, rx_cnt);\r\n}\r\nint qlcnic_83xx_init(struct qlcnic_adapter *adapter, int pci_using_dac)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint err = 0;\r\nadapter->rx_mac_learn = false;\r\nahw->msix_supported = !!qlcnic_use_msi_x;\r\nswitch (qlcnic_load_fw_file) {\r\ncase 2:\r\nahw->post_mode = QLC_83XX_POST_FAST_MODE;\r\nahw->run_post = true;\r\nbreak;\r\ncase 3:\r\nahw->post_mode = QLC_83XX_POST_MEDIUM_MODE;\r\nahw->run_post = true;\r\nbreak;\r\ncase 4:\r\nahw->post_mode = QLC_83XX_POST_SLOW_MODE;\r\nahw->run_post = true;\r\nbreak;\r\ndefault:\r\nahw->run_post = false;\r\nbreak;\r\n}\r\nqlcnic_83xx_init_rings(adapter);\r\nerr = qlcnic_83xx_init_mailbox_work(adapter);\r\nif (err)\r\ngoto exit;\r\nif (qlcnic_sriov_vf_check(adapter)) {\r\nerr = qlcnic_sriov_vf_init(adapter, pci_using_dac);\r\nif (err)\r\ngoto detach_mbx;\r\nelse\r\nreturn err;\r\n}\r\nif (qlcnic_83xx_read_flash_descriptor_table(adapter) ||\r\nqlcnic_83xx_read_flash_mfg_id(adapter)) {\r\ndev_err(&adapter->pdev->dev, "Failed reading flash mfg id\n");\r\nerr = -ENOTRECOVERABLE;\r\ngoto detach_mbx;\r\n}\r\nerr = qlcnic_83xx_check_hw_status(adapter);\r\nif (err)\r\ngoto detach_mbx;\r\nerr = qlcnic_83xx_get_fw_info(adapter);\r\nif (err)\r\ngoto detach_mbx;\r\nerr = qlcnic_83xx_idc_init(adapter);\r\nif (err)\r\ngoto detach_mbx;\r\nerr = qlcnic_setup_intr(adapter);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev, "Failed to setup interrupt\n");\r\ngoto disable_intr;\r\n}\r\nINIT_DELAYED_WORK(&adapter->idc_aen_work, qlcnic_83xx_idc_aen_work);\r\nerr = qlcnic_83xx_setup_mbx_intr(adapter);\r\nif (err)\r\ngoto disable_mbx_intr;\r\nqlcnic_83xx_clear_function_resources(adapter);\r\nqlcnic_dcb_enable(adapter->dcb);\r\nqlcnic_83xx_initialize_nic(adapter, 1);\r\nqlcnic_dcb_get_info(adapter->dcb);\r\nerr = qlcnic_83xx_configure_opmode(adapter);\r\nif (err)\r\ngoto disable_mbx_intr;\r\nerr = adapter->nic_ops->init_driver(adapter);\r\nif (err)\r\ngoto disable_mbx_intr;\r\nqlcnic_83xx_idc_poll_dev_state(&adapter->fw_work.work);\r\nreturn 0;\r\ndisable_mbx_intr:\r\nqlcnic_83xx_free_mbx_intr(adapter);\r\ndisable_intr:\r\nqlcnic_teardown_intr(adapter);\r\ndetach_mbx:\r\nqlcnic_83xx_detach_mailbox_work(adapter);\r\nqlcnic_83xx_free_mailbox(ahw->mailbox);\r\nahw->mailbox = NULL;\r\nexit:\r\nreturn err;\r\n}\r\nvoid qlcnic_83xx_aer_stop_poll_work(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlc_83xx_idc *idc = &ahw->idc;\r\nclear_bit(QLC_83XX_MBX_READY, &idc->status);\r\ncancel_delayed_work_sync(&adapter->fw_work);\r\nif (ahw->nic_mode == QLCNIC_VNIC_MODE)\r\nqlcnic_83xx_disable_vnic_mode(adapter, 1);\r\nqlcnic_83xx_idc_detach_driver(adapter);\r\nqlcnic_83xx_initialize_nic(adapter, 0);\r\ncancel_delayed_work_sync(&adapter->idc_aen_work);\r\n}\r\nint qlcnic_83xx_aer_reset(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlc_83xx_idc *idc = &ahw->idc;\r\nint ret = 0;\r\nu32 owner;\r\nidc->prev_state = QLC_83XX_IDC_DEV_NEED_RESET;\r\nowner = qlcnic_83xx_idc_find_reset_owner_id(adapter);\r\nif (ahw->pci_func == owner) {\r\nret = qlcnic_83xx_restart_hw(adapter);\r\nif (ret < 0)\r\nreturn ret;\r\nqlcnic_83xx_idc_clear_registers(adapter, 0);\r\n}\r\nret = idc->state_entry(adapter);\r\nreturn ret;\r\n}\r\nvoid qlcnic_83xx_aer_start_poll_work(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlc_83xx_idc *idc = &ahw->idc;\r\nu32 owner;\r\nidc->prev_state = QLC_83XX_IDC_DEV_READY;\r\nowner = qlcnic_83xx_idc_find_reset_owner_id(adapter);\r\nif (ahw->pci_func == owner)\r\nqlcnic_83xx_idc_enter_ready_state(adapter, 0);\r\nqlcnic_schedule_work(adapter, qlcnic_83xx_idc_poll_dev_state, 0);\r\n}
