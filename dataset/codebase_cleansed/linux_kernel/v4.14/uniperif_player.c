static irqreturn_t uni_player_irq_handler(int irq, void *dev_id)\r\n{\r\nirqreturn_t ret = IRQ_NONE;\r\nstruct uniperif *player = dev_id;\r\nunsigned int status;\r\nunsigned int tmp;\r\nspin_lock(&player->irq_lock);\r\nif (!player->substream)\r\ngoto irq_spin_unlock;\r\nsnd_pcm_stream_lock(player->substream);\r\nif (player->state == UNIPERIF_STATE_STOPPED)\r\ngoto stream_unlock;\r\nstatus = GET_UNIPERIF_ITS(player);\r\nSET_UNIPERIF_ITS_BCLR(player, status);\r\nif (unlikely(status & UNIPERIF_ITS_FIFO_ERROR_MASK(player))) {\r\ndev_err(player->dev, "FIFO underflow error detected\n");\r\nif (player->underflow_enabled) {\r\nplayer->state = UNIPERIF_STATE_UNDERFLOW;\r\n} else {\r\nSET_UNIPERIF_ITM_BCLR_FIFO_ERROR(player);\r\nsnd_pcm_stop(player->substream, SNDRV_PCM_STATE_XRUN);\r\n}\r\nret = IRQ_HANDLED;\r\n}\r\nif (unlikely(status & UNIPERIF_ITS_DMA_ERROR_MASK(player))) {\r\ndev_err(player->dev, "DMA error detected\n");\r\nSET_UNIPERIF_ITM_BCLR_DMA_ERROR(player);\r\nsnd_pcm_stop(player->substream, SNDRV_PCM_STATE_XRUN);\r\nret = IRQ_HANDLED;\r\n}\r\nif (unlikely(status & UNIPERIF_ITM_UNDERFLOW_REC_DONE_MASK(player))) {\r\nif (!player->underflow_enabled) {\r\ndev_err(player->dev,\r\n"unexpected Underflow recovering\n");\r\nret = -EPERM;\r\ngoto stream_unlock;\r\n}\r\ntmp = GET_UNIPERIF_STATUS_1_UNDERFLOW_DURATION(player);\r\ndev_dbg(player->dev, "Underflow recovered (%d LR clocks max)\n",\r\ntmp);\r\nSET_UNIPERIF_BIT_CONTROL_CLR_UNDERFLOW_DURATION(player);\r\nplayer->state = UNIPERIF_STATE_STARTED;\r\nret = IRQ_HANDLED;\r\n}\r\nif (unlikely(status &\r\nUNIPERIF_ITM_UNDERFLOW_REC_FAILED_MASK(player))) {\r\ndev_err(player->dev, "Underflow recovery failed\n");\r\nsnd_pcm_stop(player->substream, SNDRV_PCM_STATE_XRUN);\r\nret = IRQ_HANDLED;\r\n}\r\nstream_unlock:\r\nsnd_pcm_stream_unlock(player->substream);\r\nirq_spin_unlock:\r\nspin_unlock(&player->irq_lock);\r\nreturn ret;\r\n}\r\nstatic int uni_player_clk_set_rate(struct uniperif *player, unsigned long rate)\r\n{\r\nint rate_adjusted, rate_achieved, delta, ret;\r\nint adjustment = player->clk_adj;\r\nif (adjustment < 0) {\r\ndelta = -1;\r\nadjustment = -adjustment;\r\n} else {\r\ndelta = 1;\r\n}\r\ndelta *= (int)div64_u64((uint64_t)rate *\r\n(uint64_t)adjustment + 500000, 1000000);\r\nrate_adjusted = rate + delta;\r\nif (!rate_adjusted)\r\nreturn -EINVAL;\r\nret = clk_set_rate(player->clk, rate_adjusted);\r\nif (ret < 0)\r\nreturn ret;\r\nrate_achieved = clk_get_rate(player->clk);\r\nif (!rate_achieved)\r\nreturn -EINVAL;\r\ndelta = rate_achieved - rate;\r\nif (delta < 0) {\r\ndelta = -delta;\r\nadjustment = -1;\r\n} else {\r\nadjustment = 1;\r\n}\r\nadjustment *= (int)div64_u64((uint64_t)delta * 1000000 + rate / 2,\r\nrate);\r\nplayer->clk_adj = adjustment;\r\nreturn 0;\r\n}\r\nstatic void uni_player_set_channel_status(struct uniperif *player,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nint n;\r\nunsigned int status;\r\nmutex_lock(&player->ctrl_lock);\r\nif (runtime) {\r\nswitch (runtime->rate) {\r\ncase 22050:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_22050;\r\nbreak;\r\ncase 44100:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_44100;\r\nbreak;\r\ncase 88200:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_88200;\r\nbreak;\r\ncase 176400:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_176400;\r\nbreak;\r\ncase 24000:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_24000;\r\nbreak;\r\ncase 48000:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_48000;\r\nbreak;\r\ncase 96000:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_96000;\r\nbreak;\r\ncase 192000:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_192000;\r\nbreak;\r\ncase 32000:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_32000;\r\nbreak;\r\ndefault:\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_NOTID;\r\nbreak;\r\n}\r\n}\r\nif (player->stream_settings.iec958.status[0] & IEC958_AES0_NONAUDIO)\r\nplayer->stream_settings.encoding_mode =\r\nUNIPERIF_IEC958_ENCODING_MODE_ENCODED;\r\nelse\r\nplayer->stream_settings.encoding_mode =\r\nUNIPERIF_IEC958_ENCODING_MODE_PCM;\r\nif (player->stream_settings.encoding_mode ==\r\nUNIPERIF_IEC958_ENCODING_MODE_PCM)\r\nSET_UNIPERIF_USER_VALIDITY_VALIDITY_LR(player, 0);\r\nelse\r\nSET_UNIPERIF_USER_VALIDITY_VALIDITY_LR(player, 1);\r\nfor (n = 0; n < 6; ++n) {\r\nstatus =\r\nplayer->stream_settings.iec958.status[0 + (n * 4)] & 0xf;\r\nstatus |=\r\nplayer->stream_settings.iec958.status[1 + (n * 4)] << 8;\r\nstatus |=\r\nplayer->stream_settings.iec958.status[2 + (n * 4)] << 16;\r\nstatus |=\r\nplayer->stream_settings.iec958.status[3 + (n * 4)] << 24;\r\nSET_UNIPERIF_CHANNEL_STA_REGN(player, n, status);\r\n}\r\nmutex_unlock(&player->ctrl_lock);\r\nif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\r\nSET_UNIPERIF_CONFIG_CHL_STS_UPDATE(player);\r\nelse\r\nSET_UNIPERIF_BIT_CONTROL_CHL_STS_UPDATE(player);\r\n}\r\nstatic int uni_player_prepare_iec958(struct uniperif *player,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nint clk_div;\r\nclk_div = player->mclk / runtime->rate;\r\nif ((clk_div % 128) || (clk_div <= 0)) {\r\ndev_err(player->dev, "%s: invalid clk_div %d\n",\r\n__func__, clk_div);\r\nreturn -EINVAL;\r\n}\r\nswitch (runtime->format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nSET_UNIPERIF_CONFIG_MEM_FMT_16_16(player);\r\nSET_UNIPERIF_I2S_FMT_NBIT_32(player);\r\nSET_UNIPERIF_I2S_FMT_DATA_SIZE_16(player);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nSET_UNIPERIF_CONFIG_MEM_FMT_16_0(player);\r\nSET_UNIPERIF_I2S_FMT_NBIT_32(player);\r\nSET_UNIPERIF_I2S_FMT_DATA_SIZE_24(player);\r\nbreak;\r\ndefault:\r\ndev_err(player->dev, "format not supported\n");\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_CONFIG_PARITY_CNTR_BY_HW(player);\r\nSET_UNIPERIF_CONFIG_CHANNEL_STA_CNTR_BY_HW(player);\r\nSET_UNIPERIF_CONFIG_USER_DAT_CNTR_BY_HW(player);\r\nSET_UNIPERIF_CONFIG_VALIDITY_DAT_CNTR_BY_HW(player);\r\nSET_UNIPERIF_CONFIG_SPDIF_SW_CTRL_DISABLE(player);\r\nSET_UNIPERIF_CTRL_ZERO_STUFF_HW(player);\r\nuni_player_set_channel_status(player, runtime);\r\nSET_UNIPERIF_USER_VALIDITY_VALIDITY_LR(player, 0);\r\nSET_UNIPERIF_CONFIG_ONE_BIT_AUD_DISABLE(player);\r\nSET_UNIPERIF_CONFIG_REPEAT_CHL_STS_ENABLE(player);\r\nSET_UNIPERIF_CONFIG_SUBFRAME_SEL_SUBF1_SUBF0(player);\r\nSET_UNIPERIF_I2S_FMT_ORDER_MSB(player);\r\nif (player->stream_settings.encoding_mode ==\r\nUNIPERIF_IEC958_ENCODING_MODE_ENCODED)\r\nSET_UNIPERIF_CTRL_EXIT_STBY_ON_EOBLOCK_ON(player);\r\nelse\r\nSET_UNIPERIF_CTRL_EXIT_STBY_ON_EOBLOCK_OFF(player);\r\nSET_UNIPERIF_I2S_FMT_NUM_CH(player, runtime->channels / 2);\r\nSET_UNIPERIF_CTRL_ROUNDING_OFF(player);\r\nSET_UNIPERIF_CTRL_DIVIDER(player, clk_div / 128);\r\nSET_UNIPERIF_CTRL_SPDIF_LAT_OFF(player);\r\nif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\r\nSET_UNIPERIF_CTRL_SPDIF_FMT_OFF(player);\r\nelse\r\nSET_UNIPERIF_CTRL_SPDIF_FMT_ON(player);\r\nreturn 0;\r\n}\r\nstatic int uni_player_prepare_pcm(struct uniperif *player,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nint output_frame_size, slot_width, clk_div;\r\nif ((player->daifmt & SND_SOC_DAIFMT_FORMAT_MASK) ==\r\nSND_SOC_DAIFMT_I2S)\r\nslot_width = 32;\r\nelse\r\nslot_width = snd_pcm_format_width(runtime->format);\r\noutput_frame_size = slot_width * runtime->channels;\r\nclk_div = player->mclk / runtime->rate;\r\nif ((slot_width == 32) && (clk_div % 128)) {\r\ndev_err(player->dev, "%s: invalid clk_div\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif ((slot_width == 16) && (clk_div % 64)) {\r\ndev_err(player->dev, "%s: invalid clk_div\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nswitch (slot_width) {\r\ncase 32:\r\nSET_UNIPERIF_I2S_FMT_NBIT_32(player);\r\nSET_UNIPERIF_I2S_FMT_DATA_SIZE_32(player);\r\nbreak;\r\ncase 16:\r\nSET_UNIPERIF_I2S_FMT_NBIT_16(player);\r\nSET_UNIPERIF_I2S_FMT_DATA_SIZE_16(player);\r\nbreak;\r\ndefault:\r\ndev_err(player->dev, "subframe format not supported\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (runtime->format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nSET_UNIPERIF_CONFIG_MEM_FMT_16_16(player);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nSET_UNIPERIF_CONFIG_MEM_FMT_16_0(player);\r\nbreak;\r\ndefault:\r\ndev_err(player->dev, "format not supported\n");\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_CTRL_ROUNDING_OFF(player);\r\nSET_UNIPERIF_CTRL_DIVIDER(player, clk_div / (2 * output_frame_size));\r\nif ((runtime->channels % 2) || (runtime->channels < 2) ||\r\n(runtime->channels > 10)) {\r\ndev_err(player->dev, "%s: invalid nb of channels\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_I2S_FMT_NUM_CH(player, runtime->channels / 2);\r\nSET_UNIPERIF_CONFIG_ONE_BIT_AUD_DISABLE(player);\r\nSET_UNIPERIF_I2S_FMT_ORDER_MSB(player);\r\nSET_UNIPERIF_CTRL_SPDIF_FMT_OFF(player);\r\nreturn 0;\r\n}\r\nstatic int uni_player_prepare_tdm(struct uniperif *player,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nint tdm_frame_size;\r\nint user_frame_size;\r\nunsigned int word_pos[4] = {\r\n0x04060002, 0x0C0E080A, 0x14161012, 0x1C1E181A};\r\nint freq, ret;\r\ntdm_frame_size =\r\nsti_uniperiph_get_unip_tdm_frame_size(player);\r\nuser_frame_size =\r\nsti_uniperiph_get_user_frame_size(runtime);\r\nSET_UNIPERIF_CONFIG_MEM_FMT_16_0(player);\r\nSET_UNIPERIF_I2S_FMT_DATA_SIZE_32(player);\r\nSET_UNIPERIF_I2S_FMT_NUM_CH(player, user_frame_size / 4 / 2);\r\nSET_UNIPERIF_I2S_FMT_ORDER_MSB(player);\r\nSET_UNIPERIF_I2S_FMT_ALIGN_LEFT(player);\r\nSET_UNIPERIF_TDM_ENABLE_TDM_ENABLE(player);\r\nSET_UNIPERIF_TDM_FS_REF_DIV_NUM_TIMESLOT(player, tdm_frame_size);\r\nsti_uniperiph_get_tdm_word_pos(player, word_pos);\r\nSET_UNIPERIF_TDM_WORD_POS(player, 1_2, word_pos[WORD_1_2]);\r\nSET_UNIPERIF_TDM_WORD_POS(player, 3_4, word_pos[WORD_3_4]);\r\nSET_UNIPERIF_TDM_WORD_POS(player, 5_6, word_pos[WORD_5_6]);\r\nSET_UNIPERIF_TDM_WORD_POS(player, 7_8, word_pos[WORD_7_8]);\r\nfreq = runtime->rate * tdm_frame_size * 8;\r\nmutex_lock(&player->ctrl_lock);\r\nret = uni_player_clk_set_rate(player, freq);\r\nif (!ret)\r\nplayer->mclk = freq;\r\nmutex_unlock(&player->ctrl_lock);\r\nreturn 0;\r\n}\r\nstatic int uni_player_ctl_iec958_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int uni_player_ctl_iec958_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nstruct snd_aes_iec958 *iec958 = &player->stream_settings.iec958;\r\nmutex_lock(&player->ctrl_lock);\r\nucontrol->value.iec958.status[0] = iec958->status[0];\r\nucontrol->value.iec958.status[1] = iec958->status[1];\r\nucontrol->value.iec958.status[2] = iec958->status[2];\r\nucontrol->value.iec958.status[3] = iec958->status[3];\r\nmutex_unlock(&player->ctrl_lock);\r\nreturn 0;\r\n}\r\nstatic int uni_player_ctl_iec958_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nstruct snd_aes_iec958 *iec958 = &player->stream_settings.iec958;\r\nunsigned long flags;\r\nmutex_lock(&player->ctrl_lock);\r\niec958->status[0] = ucontrol->value.iec958.status[0];\r\niec958->status[1] = ucontrol->value.iec958.status[1];\r\niec958->status[2] = ucontrol->value.iec958.status[2];\r\niec958->status[3] = ucontrol->value.iec958.status[3];\r\nmutex_unlock(&player->ctrl_lock);\r\nspin_lock_irqsave(&player->irq_lock, flags);\r\nif (player->substream && player->substream->runtime)\r\nuni_player_set_channel_status(player,\r\nplayer->substream->runtime);\r\nelse\r\nuni_player_set_channel_status(player, NULL);\r\nspin_unlock_irqrestore(&player->irq_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_sti_clk_adjustment_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = UNIPERIF_PLAYER_CLK_ADJ_MIN;\r\nuinfo->value.integer.max = UNIPERIF_PLAYER_CLK_ADJ_MAX;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_sti_clk_adjustment_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nmutex_lock(&player->ctrl_lock);\r\nucontrol->value.integer.value[0] = player->clk_adj;\r\nmutex_unlock(&player->ctrl_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_sti_clk_adjustment_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nint ret = 0;\r\nif ((ucontrol->value.integer.value[0] < UNIPERIF_PLAYER_CLK_ADJ_MIN) ||\r\n(ucontrol->value.integer.value[0] > UNIPERIF_PLAYER_CLK_ADJ_MAX))\r\nreturn -EINVAL;\r\nmutex_lock(&player->ctrl_lock);\r\nplayer->clk_adj = ucontrol->value.integer.value[0];\r\nif (player->mclk)\r\nret = uni_player_clk_set_rate(player, player->mclk);\r\nmutex_unlock(&player->ctrl_lock);\r\nreturn ret;\r\n}\r\nstatic int uni_player_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&player->irq_lock, flags);\r\nplayer->substream = substream;\r\nspin_unlock_irqrestore(&player->irq_lock, flags);\r\nplayer->clk_adj = 0;\r\nif (!UNIPERIF_TYPE_IS_TDM(player))\r\nreturn 0;\r\nret = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\nsti_uniperiph_fix_tdm_chan,\r\nplayer, SNDRV_PCM_HW_PARAM_CHANNELS,\r\n-1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_FORMAT,\r\nsti_uniperiph_fix_tdm_format,\r\nplayer, SNDRV_PCM_HW_PARAM_FORMAT,\r\n-1);\r\n}\r\nstatic int uni_player_set_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nint ret;\r\nif (UNIPERIF_TYPE_IS_TDM(player) || (dir == SND_SOC_CLOCK_IN))\r\nreturn 0;\r\nif (clk_id != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&player->ctrl_lock);\r\nret = uni_player_clk_set_rate(player, freq);\r\nif (!ret)\r\nplayer->mclk = freq;\r\nmutex_unlock(&player->ctrl_lock);\r\nreturn ret;\r\n}\r\nstatic int uni_player_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint transfer_size, trigger_limit;\r\nint ret;\r\nif (player->state != UNIPERIF_STATE_STOPPED) {\r\ndev_err(player->dev, "%s: invalid player state %d\n", __func__,\r\nplayer->state);\r\nreturn -EINVAL;\r\n}\r\nif (player->type == SND_ST_UNIPERIF_TYPE_TDM) {\r\ntransfer_size =\r\nsti_uniperiph_get_user_frame_size(runtime) / 4;\r\n} else {\r\ntransfer_size = runtime->channels * UNIPERIF_FIFO_FRAMES;\r\n}\r\nif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0) {\r\ntrigger_limit = UNIPERIF_FIFO_SIZE - transfer_size;\r\n} else {\r\ntrigger_limit = transfer_size;\r\n}\r\nif ((!trigger_limit % 2) || (trigger_limit != 1 && transfer_size % 2) ||\r\n(trigger_limit > UNIPERIF_CONFIG_DMA_TRIG_LIMIT_MASK(player))) {\r\ndev_err(player->dev, "invalid trigger limit %d\n",\r\ntrigger_limit);\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_CONFIG_DMA_TRIG_LIMIT(player, trigger_limit);\r\nswitch (player->type) {\r\ncase SND_ST_UNIPERIF_TYPE_HDMI:\r\nret = uni_player_prepare_iec958(player, runtime);\r\nbreak;\r\ncase SND_ST_UNIPERIF_TYPE_PCM:\r\nret = uni_player_prepare_pcm(player, runtime);\r\nbreak;\r\ncase SND_ST_UNIPERIF_TYPE_SPDIF:\r\nret = uni_player_prepare_iec958(player, runtime);\r\nbreak;\r\ncase SND_ST_UNIPERIF_TYPE_TDM:\r\nret = uni_player_prepare_tdm(player, runtime);\r\nbreak;\r\ndefault:\r\ndev_err(player->dev, "invalid player type\n");\r\nreturn -EINVAL;\r\n}\r\nif (ret)\r\nreturn ret;\r\nswitch (player->daifmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nSET_UNIPERIF_I2S_FMT_LR_POL_LOW(player);\r\nSET_UNIPERIF_I2S_FMT_SCLK_EDGE_RISING(player);\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nSET_UNIPERIF_I2S_FMT_LR_POL_HIG(player);\r\nSET_UNIPERIF_I2S_FMT_SCLK_EDGE_RISING(player);\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nSET_UNIPERIF_I2S_FMT_LR_POL_LOW(player);\r\nSET_UNIPERIF_I2S_FMT_SCLK_EDGE_FALLING(player);\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nSET_UNIPERIF_I2S_FMT_LR_POL_HIG(player);\r\nSET_UNIPERIF_I2S_FMT_SCLK_EDGE_FALLING(player);\r\nbreak;\r\n}\r\nswitch (player->daifmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nSET_UNIPERIF_I2S_FMT_ALIGN_LEFT(player);\r\nSET_UNIPERIF_I2S_FMT_PADDING_I2S_MODE(player);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nSET_UNIPERIF_I2S_FMT_ALIGN_LEFT(player);\r\nSET_UNIPERIF_I2S_FMT_PADDING_SONY_MODE(player);\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nSET_UNIPERIF_I2S_FMT_ALIGN_RIGHT(player);\r\nSET_UNIPERIF_I2S_FMT_PADDING_SONY_MODE(player);\r\nbreak;\r\ndefault:\r\ndev_err(player->dev, "format not supported\n");\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_I2S_FMT_NO_OF_SAMPLES_TO_READ(player, 0);\r\nreturn sti_uniperiph_reset(player);\r\n}\r\nstatic int uni_player_start(struct uniperif *player)\r\n{\r\nint ret;\r\nif (player->state != UNIPERIF_STATE_STOPPED) {\r\ndev_err(player->dev, "%s: invalid player state\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nret = clk_prepare_enable(player->clk);\r\nif (ret) {\r\ndev_err(player->dev, "%s: Failed to enable clock\n", __func__);\r\nreturn ret;\r\n}\r\nSET_UNIPERIF_ITS_BCLR(player, GET_UNIPERIF_ITS(player));\r\nSET_UNIPERIF_ITM_BSET_DMA_ERROR(player);\r\nSET_UNIPERIF_ITM_BSET_FIFO_ERROR(player);\r\nif (player->underflow_enabled) {\r\nSET_UNIPERIF_ITM_BSET_UNDERFLOW_REC_DONE(player);\r\nSET_UNIPERIF_ITM_BSET_UNDERFLOW_REC_FAILED(player);\r\n}\r\nret = sti_uniperiph_reset(player);\r\nif (ret < 0) {\r\nclk_disable_unprepare(player->clk);\r\nreturn ret;\r\n}\r\nSET_UNIPERIF_CTRL_OPERATION_PCM_DATA(player);\r\nif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\r\nif (UNIPERIF_TYPE_IS_IEC958(player))\r\nSET_UNIPERIF_CTRL_SPDIF_FMT_ON(player);\r\nif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\r\nSET_UNIPERIF_CONFIG_CHL_STS_UPDATE(player);\r\nelse\r\nSET_UNIPERIF_BIT_CONTROL_CHL_STS_UPDATE(player);\r\nplayer->state = UNIPERIF_STATE_STARTED;\r\nreturn 0;\r\n}\r\nstatic int uni_player_stop(struct uniperif *player)\r\n{\r\nint ret;\r\nif (player->state == UNIPERIF_STATE_STOPPED) {\r\ndev_err(player->dev, "%s: invalid player state\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nSET_UNIPERIF_CTRL_OPERATION_OFF(player);\r\nret = sti_uniperiph_reset(player);\r\nif (ret < 0)\r\nreturn ret;\r\nSET_UNIPERIF_ITM_BCLR(player, GET_UNIPERIF_ITM(player));\r\nclk_disable_unprepare(player->clk);\r\nplayer->state = UNIPERIF_STATE_STOPPED;\r\nreturn 0;\r\n}\r\nint uni_player_resume(struct uniperif *player)\r\n{\r\nint ret;\r\nif (player->clk_sel) {\r\nret = regmap_field_write(player->clk_sel, 1);\r\nif (ret) {\r\ndev_err(player->dev,\r\n"%s: Failed to select freq synth clock\n",\r\n__func__);\r\nreturn ret;\r\n}\r\n}\r\nSET_UNIPERIF_CONFIG_BACK_STALL_REQ_DISABLE(player);\r\nSET_UNIPERIF_CTRL_ROUNDING_OFF(player);\r\nSET_UNIPERIF_CTRL_SPDIF_LAT_OFF(player);\r\nSET_UNIPERIF_CONFIG_IDLE_MOD_DISABLE(player);\r\nreturn 0;\r\n}\r\nstatic int uni_player_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nreturn uni_player_start(player);\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nreturn uni_player_stop(player);\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nreturn uni_player_resume(player);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void uni_player_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct uniperif *player = priv->dai_data.uni;\r\nunsigned long flags;\r\nspin_lock_irqsave(&player->irq_lock, flags);\r\nif (player->state != UNIPERIF_STATE_STOPPED)\r\nuni_player_stop(player);\r\nplayer->substream = NULL;\r\nspin_unlock_irqrestore(&player->irq_lock, flags);\r\n}\r\nstatic int uni_player_parse_dt_audio_glue(struct platform_device *pdev,\r\nstruct uniperif *player)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct regmap *regmap;\r\nstruct reg_field regfield[2] = {\r\nREG_FIELD(SYS_CFG_AUDIO_GLUE,\r\n8 + player->id,\r\n8 + player->id),\r\nREG_FIELD(SYS_CFG_AUDIO_GLUE, 0, 1)\r\n};\r\nregmap = syscon_regmap_lookup_by_phandle(node, "st,syscfg");\r\nif (IS_ERR(regmap)) {\r\ndev_err(&pdev->dev, "sti-audio-clk-glue syscf not found\n");\r\nreturn PTR_ERR(regmap);\r\n}\r\nplayer->clk_sel = regmap_field_alloc(regmap, regfield[0]);\r\nplayer->valid_sel = regmap_field_alloc(regmap, regfield[1]);\r\nreturn 0;\r\n}\r\nint uni_player_init(struct platform_device *pdev,\r\nstruct uniperif *player)\r\n{\r\nint ret = 0;\r\nplayer->dev = &pdev->dev;\r\nplayer->state = UNIPERIF_STATE_STOPPED;\r\nplayer->dai_ops = &uni_player_dai_ops;\r\nret = uni_player_parse_dt_audio_glue(pdev, player);\r\nif (ret < 0) {\r\ndev_err(player->dev, "Failed to parse DeviceTree\n");\r\nreturn ret;\r\n}\r\nif (player->ver >= SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\r\nplayer->underflow_enabled = 1;\r\nif (UNIPERIF_TYPE_IS_TDM(player))\r\nplayer->hw = &uni_tdm_hw;\r\nelse\r\nplayer->hw = &uni_player_pcm_hw;\r\nplayer->clk = of_clk_get(pdev->dev.of_node, 0);\r\nif (IS_ERR(player->clk)) {\r\ndev_err(player->dev, "Failed to get clock\n");\r\nreturn PTR_ERR(player->clk);\r\n}\r\nif (player->clk_sel) {\r\nret = regmap_field_write(player->clk_sel, 1);\r\nif (ret) {\r\ndev_err(player->dev,\r\n"%s: Failed to select freq synth clock\n",\r\n__func__);\r\nreturn ret;\r\n}\r\n}\r\nif (player->valid_sel &&\r\n(player->id == UNIPERIF_PLAYER_I2S_OUT)) {\r\nret = regmap_field_write(player->valid_sel, player->id);\r\nif (ret) {\r\ndev_err(player->dev,\r\n"%s: unable to connect to tdm bus\n", __func__);\r\nreturn ret;\r\n}\r\n}\r\nret = devm_request_irq(&pdev->dev, player->irq,\r\nuni_player_irq_handler, IRQF_SHARED,\r\ndev_name(&pdev->dev), player);\r\nif (ret < 0) {\r\ndev_err(player->dev, "unable to request IRQ %d\n", player->irq);\r\nreturn ret;\r\n}\r\nmutex_init(&player->ctrl_lock);\r\nspin_lock_init(&player->irq_lock);\r\nSET_UNIPERIF_CONFIG_BACK_STALL_REQ_DISABLE(player);\r\nSET_UNIPERIF_CTRL_ROUNDING_OFF(player);\r\nSET_UNIPERIF_CTRL_SPDIF_LAT_OFF(player);\r\nSET_UNIPERIF_CONFIG_IDLE_MOD_DISABLE(player);\r\nif (UNIPERIF_TYPE_IS_IEC958(player)) {\r\nplayer->stream_settings.iec958.status[0] = 0x00;\r\nplayer->stream_settings.iec958.status[1] =\r\nIEC958_AES1_CON_GENERAL;\r\nplayer->stream_settings.iec958.status[2] =\r\nIEC958_AES2_CON_SOURCE_UNSPEC;\r\nplayer->stream_settings.iec958.status[3] =\r\nIEC958_AES3_CON_FS_NOTID;\r\nplayer->stream_settings.iec958.status[4] =\r\nIEC958_AES4_CON_MAX_WORDLEN_24 |\r\nIEC958_AES4_CON_WORDLEN_24_20;\r\nplayer->num_ctrls = ARRAY_SIZE(snd_sti_iec_ctl);\r\nplayer->snd_ctrls = snd_sti_iec_ctl[0];\r\n} else {\r\nplayer->num_ctrls = ARRAY_SIZE(snd_sti_pcm_ctl);\r\nplayer->snd_ctrls = snd_sti_pcm_ctl[0];\r\n}\r\nreturn 0;\r\n}
