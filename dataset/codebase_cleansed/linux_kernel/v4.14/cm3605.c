static irqreturn_t cm3605_prox_irq(int irq, void *d)\r\n{\r\nstruct iio_dev *indio_dev = d;\r\nstruct cm3605 *cm3605 = iio_priv(indio_dev);\r\nu64 ev;\r\nev = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, CM3605_PROX_CHANNEL,\r\nIIO_EV_TYPE_THRESH, cm3605->dir);\r\niio_push_event(indio_dev, ev, iio_get_time_ns(indio_dev));\r\nif (cm3605->dir == IIO_EV_DIR_RISING)\r\ncm3605->dir = IIO_EV_DIR_FALLING;\r\nelse\r\ncm3605->dir = IIO_EV_DIR_RISING;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cm3605_get_lux(struct cm3605 *cm3605)\r\n{\r\nint ret, res;\r\ns64 lux;\r\nret = iio_read_channel_processed(cm3605->aout, &res);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(cm3605->dev, "read %d mV from ADC\n", res);\r\nif (res < 30)\r\nreturn 0;\r\nif (res > CM3605_AOUT_MAX_MV)\r\ndev_err(cm3605->dev, "device out of range\n");\r\nlux = res - 30;\r\nlux *= cm3605->als_max;\r\nlux = div64_s64(lux, CM3605_AOUT_TYP_MAX_MV);\r\nreturn lux;\r\n}\r\nstatic int cm3605_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct cm3605 *cm3605 = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nswitch (chan->type) {\r\ncase IIO_LIGHT:\r\nret = cm3605_get_lux(cm3605);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int cm3605_probe(struct platform_device *pdev)\r\n{\r\nstruct cm3605 *cm3605;\r\nstruct iio_dev *indio_dev;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nenum iio_chan_type ch_type;\r\nu32 rset;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(*cm3605));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, indio_dev);\r\ncm3605 = iio_priv(indio_dev);\r\ncm3605->dev = dev;\r\ncm3605->dir = IIO_EV_DIR_FALLING;\r\nret = of_property_read_u32(np, "capella,aset-resistance-ohms", &rset);\r\nif (ret) {\r\ndev_info(dev, "no RSET specified, assuming 100K\n");\r\nrset = 100000;\r\n}\r\nswitch (rset) {\r\ncase 50000:\r\ncm3605->als_max = 650;\r\nbreak;\r\ncase 100000:\r\ncm3605->als_max = 300;\r\nbreak;\r\ncase 300000:\r\ncm3605->als_max = 100;\r\nbreak;\r\ncase 600000:\r\ncm3605->als_max = 50;\r\nbreak;\r\ndefault:\r\ndev_info(dev, "non-standard resistance\n");\r\nreturn -EINVAL;\r\n}\r\ncm3605->aout = devm_iio_channel_get(dev, "aout");\r\nif (IS_ERR(cm3605->aout)) {\r\nif (PTR_ERR(cm3605->aout) == -ENODEV) {\r\ndev_err(dev, "no ADC, deferring...\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\ndev_err(dev, "failed to get AOUT ADC channel\n");\r\nreturn PTR_ERR(cm3605->aout);\r\n}\r\nret = iio_get_channel_type(cm3605->aout, &ch_type);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ch_type != IIO_VOLTAGE) {\r\ndev_err(dev, "wrong type of IIO channel specified for AOUT\n");\r\nreturn -EINVAL;\r\n}\r\ncm3605->vdd = devm_regulator_get(dev, "vdd");\r\nif (IS_ERR(cm3605->vdd)) {\r\ndev_err(dev, "failed to get VDD regulator\n");\r\nreturn PTR_ERR(cm3605->vdd);\r\n}\r\nret = regulator_enable(cm3605->vdd);\r\nif (ret) {\r\ndev_err(dev, "failed to enable VDD regulator\n");\r\nreturn ret;\r\n}\r\ncm3605->aset = devm_gpiod_get(dev, "aset", GPIOD_OUT_HIGH);\r\nif (IS_ERR(cm3605->aset)) {\r\ndev_err(dev, "no ASET GPIO\n");\r\nret = PTR_ERR(cm3605->aset);\r\ngoto out_disable_vdd;\r\n}\r\nret = devm_request_threaded_irq(dev, platform_get_irq(pdev, 0),\r\ncm3605_prox_irq, NULL, 0, "cm3605", indio_dev);\r\nif (ret) {\r\ndev_err(dev, "unable to request IRQ\n");\r\ngoto out_disable_aset;\r\n}\r\nled_trigger_register_simple("cm3605", &cm3605->led);\r\nled_trigger_event(cm3605->led, LED_FULL);\r\nindio_dev->dev.parent = dev;\r\nindio_dev->info = &cm3605_info;\r\nindio_dev->name = "cm3605";\r\nindio_dev->channels = cm3605_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(cm3605_channels);\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto out_remove_trigger;\r\ndev_info(dev, "Capella Microsystems CM3605 enabled range 0..%d LUX\n",\r\ncm3605->als_max);\r\nreturn 0;\r\nout_remove_trigger:\r\nled_trigger_event(cm3605->led, LED_OFF);\r\nled_trigger_unregister_simple(cm3605->led);\r\nout_disable_aset:\r\ngpiod_set_value_cansleep(cm3605->aset, 0);\r\nout_disable_vdd:\r\nregulator_disable(cm3605->vdd);\r\nreturn ret;\r\n}\r\nstatic int cm3605_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct cm3605 *cm3605 = iio_priv(indio_dev);\r\nled_trigger_event(cm3605->led, LED_OFF);\r\nled_trigger_unregister_simple(cm3605->led);\r\ngpiod_set_value_cansleep(cm3605->aset, 0);\r\niio_device_unregister(indio_dev);\r\nregulator_disable(cm3605->vdd);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused cm3605_pm_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct cm3605 *cm3605 = iio_priv(indio_dev);\r\nled_trigger_event(cm3605->led, LED_OFF);\r\nregulator_disable(cm3605->vdd);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused cm3605_pm_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct cm3605 *cm3605 = iio_priv(indio_dev);\r\nint ret;\r\nret = regulator_enable(cm3605->vdd);\r\nif (ret)\r\ndev_err(dev, "failed to enable regulator in resume path\n");\r\nled_trigger_event(cm3605->led, LED_FULL);\r\nreturn 0;\r\n}
