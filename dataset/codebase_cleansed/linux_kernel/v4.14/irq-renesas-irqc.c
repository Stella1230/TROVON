static struct irqc_priv *irq_data_to_priv(struct irq_data *data)\r\n{\r\nreturn data->domain->host_data;\r\n}\r\nstatic void irqc_dbg(struct irqc_irq *i, char *str)\r\n{\r\ndev_dbg(&i->p->pdev->dev, "%s (%d:%d)\n",\r\nstr, i->requested_irq, i->hw_irq);\r\n}\r\nstatic int irqc_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct irqc_priv *p = irq_data_to_priv(d);\r\nint hw_irq = irqd_to_hwirq(d);\r\nunsigned char value = irqc_sense[type & IRQ_TYPE_SENSE_MASK];\r\nu32 tmp;\r\nirqc_dbg(&p->irq[hw_irq], "sense");\r\nif (!value)\r\nreturn -EINVAL;\r\ntmp = ioread32(p->iomem + IRQC_CONFIG(hw_irq));\r\ntmp &= ~0x3f;\r\ntmp |= value;\r\niowrite32(tmp, p->iomem + IRQC_CONFIG(hw_irq));\r\nreturn 0;\r\n}\r\nstatic int irqc_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct irqc_priv *p = irq_data_to_priv(d);\r\nint hw_irq = irqd_to_hwirq(d);\r\nirq_set_irq_wake(p->irq[hw_irq].requested_irq, on);\r\nif (!p->clk)\r\nreturn 0;\r\nif (on)\r\nclk_enable(p->clk);\r\nelse\r\nclk_disable(p->clk);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t irqc_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct irqc_irq *i = dev_id;\r\nstruct irqc_priv *p = i->p;\r\nu32 bit = BIT(i->hw_irq);\r\nirqc_dbg(i, "demux1");\r\nif (ioread32(p->iomem + DETECT_STATUS) & bit) {\r\niowrite32(bit, p->iomem + DETECT_STATUS);\r\nirqc_dbg(i, "demux2");\r\ngeneric_handle_irq(irq_find_mapping(p->irq_domain, i->hw_irq));\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int irqc_probe(struct platform_device *pdev)\r\n{\r\nstruct irqc_priv *p;\r\nstruct resource *io;\r\nstruct resource *irq;\r\nconst char *name = dev_name(&pdev->dev);\r\nint ret;\r\nint k;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p) {\r\ndev_err(&pdev->dev, "failed to allocate driver data\n");\r\nret = -ENOMEM;\r\ngoto err0;\r\n}\r\np->pdev = pdev;\r\nplatform_set_drvdata(pdev, p);\r\np->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(p->clk)) {\r\ndev_warn(&pdev->dev, "unable to get clock\n");\r\np->clk = NULL;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\nio = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!io) {\r\ndev_err(&pdev->dev, "not enough IOMEM resources\n");\r\nret = -EINVAL;\r\ngoto err1;\r\n}\r\nfor (k = 0; k < IRQC_IRQ_MAX; k++) {\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, k);\r\nif (!irq)\r\nbreak;\r\np->irq[k].p = p;\r\np->irq[k].hw_irq = k;\r\np->irq[k].requested_irq = irq->start;\r\n}\r\np->number_of_irqs = k;\r\nif (p->number_of_irqs < 1) {\r\ndev_err(&pdev->dev, "not enough IRQ resources\n");\r\nret = -EINVAL;\r\ngoto err1;\r\n}\r\np->iomem = ioremap_nocache(io->start, resource_size(io));\r\nif (!p->iomem) {\r\ndev_err(&pdev->dev, "failed to remap IOMEM\n");\r\nret = -ENXIO;\r\ngoto err2;\r\n}\r\np->cpu_int_base = p->iomem + IRQC_INT_CPU_BASE(0);\r\np->irq_domain = irq_domain_add_linear(pdev->dev.of_node,\r\np->number_of_irqs,\r\n&irq_generic_chip_ops, p);\r\nif (!p->irq_domain) {\r\nret = -ENXIO;\r\ndev_err(&pdev->dev, "cannot initialize irq domain\n");\r\ngoto err2;\r\n}\r\nret = irq_alloc_domain_generic_chips(p->irq_domain, p->number_of_irqs,\r\n1, name, handle_level_irq,\r\n0, 0, IRQ_GC_INIT_NESTED_LOCK);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot allocate generic chip\n");\r\ngoto err3;\r\n}\r\np->gc = irq_get_domain_generic_chip(p->irq_domain, 0);\r\np->gc->reg_base = p->cpu_int_base;\r\np->gc->chip_types[0].regs.enable = IRQC_EN_SET;\r\np->gc->chip_types[0].regs.disable = IRQC_EN_STS;\r\np->gc->chip_types[0].chip.irq_mask = irq_gc_mask_disable_reg;\r\np->gc->chip_types[0].chip.irq_unmask = irq_gc_unmask_enable_reg;\r\np->gc->chip_types[0].chip.irq_set_type = irqc_irq_set_type;\r\np->gc->chip_types[0].chip.irq_set_wake = irqc_irq_set_wake;\r\np->gc->chip_types[0].chip.flags = IRQCHIP_MASK_ON_SUSPEND;\r\nfor (k = 0; k < p->number_of_irqs; k++) {\r\nif (request_irq(p->irq[k].requested_irq, irqc_irq_handler,\r\n0, name, &p->irq[k])) {\r\ndev_err(&pdev->dev, "failed to request IRQ\n");\r\nret = -ENOENT;\r\ngoto err4;\r\n}\r\n}\r\ndev_info(&pdev->dev, "driving %d irqs\n", p->number_of_irqs);\r\nreturn 0;\r\nerr4:\r\nwhile (--k >= 0)\r\nfree_irq(p->irq[k].requested_irq, &p->irq[k]);\r\nerr3:\r\nirq_domain_remove(p->irq_domain);\r\nerr2:\r\niounmap(p->iomem);\r\nerr1:\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nkfree(p);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int irqc_remove(struct platform_device *pdev)\r\n{\r\nstruct irqc_priv *p = platform_get_drvdata(pdev);\r\nint k;\r\nfor (k = 0; k < p->number_of_irqs; k++)\r\nfree_irq(p->irq[k].requested_irq, &p->irq[k]);\r\nirq_domain_remove(p->irq_domain);\r\niounmap(p->iomem);\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nkfree(p);\r\nreturn 0;\r\n}\r\nstatic int __init irqc_init(void)\r\n{\r\nreturn platform_driver_register(&irqc_device_driver);\r\n}\r\nstatic void __exit irqc_exit(void)\r\n{\r\nplatform_driver_unregister(&irqc_device_driver);\r\n}
