void wireless_nlevent_flush(void)\r\n{\r\nstruct sk_buff *skb;\r\nstruct net *net;\r\nASSERT_RTNL();\r\nfor_each_net(net) {\r\nwhile ((skb = skb_dequeue(&net->wext_nlevents)))\r\nrtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL,\r\nGFP_KERNEL);\r\n}\r\n}\r\nstatic int wext_netdev_notifier_call(struct notifier_block *nb,\r\nunsigned long state, void *ptr)\r\n{\r\nwireless_nlevent_flush();\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __net_init wext_pernet_init(struct net *net)\r\n{\r\nskb_queue_head_init(&net->wext_nlevents);\r\nreturn 0;\r\n}\r\nstatic void __net_exit wext_pernet_exit(struct net *net)\r\n{\r\nskb_queue_purge(&net->wext_nlevents);\r\n}\r\nstatic int __init wireless_nlevent_init(void)\r\n{\r\nint err = register_pernet_subsys(&wext_pernet_ops);\r\nif (err)\r\nreturn err;\r\nerr = register_netdevice_notifier(&wext_netdev_notifier);\r\nif (err)\r\nunregister_pernet_subsys(&wext_pernet_ops);\r\nreturn err;\r\n}\r\nstatic void wireless_nlevent_process(struct work_struct *work)\r\n{\r\nrtnl_lock();\r\nwireless_nlevent_flush();\r\nrtnl_unlock();\r\n}\r\nstatic struct nlmsghdr *rtnetlink_ifinfo_prep(struct net_device *dev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ifinfomsg *r;\r\nstruct nlmsghdr *nlh;\r\nnlh = nlmsg_put(skb, 0, 0, RTM_NEWLINK, sizeof(*r), 0);\r\nif (!nlh)\r\nreturn NULL;\r\nr = nlmsg_data(nlh);\r\nr->ifi_family = AF_UNSPEC;\r\nr->__ifi_pad = 0;\r\nr->ifi_type = dev->type;\r\nr->ifi_index = dev->ifindex;\r\nr->ifi_flags = dev_get_flags(dev);\r\nr->ifi_change = 0;\r\nif (nla_put_string(skb, IFLA_IFNAME, dev->name))\r\ngoto nla_put_failure;\r\nreturn nlh;\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn NULL;\r\n}\r\nvoid wireless_send_event(struct net_device * dev,\r\nunsigned int cmd,\r\nunion iwreq_data * wrqu,\r\nconst char * extra)\r\n{\r\nconst struct iw_ioctl_description * descr = NULL;\r\nint extra_len = 0;\r\nstruct iw_event *event;\r\nint event_len;\r\nint hdr_len;\r\nint wrqu_off = 0;\r\nunsigned int cmd_index;\r\nstruct sk_buff *skb;\r\nstruct nlmsghdr *nlh;\r\nstruct nlattr *nla;\r\n#ifdef CONFIG_COMPAT\r\nstruct __compat_iw_event *compat_event;\r\nstruct compat_iw_point compat_wrqu;\r\nstruct sk_buff *compskb;\r\n#endif\r\nif (WARN_ON(cmd == SIOCGIWSCAN && extra))\r\nextra = NULL;\r\nif (cmd <= SIOCIWLAST) {\r\ncmd_index = IW_IOCTL_IDX(cmd);\r\nif (cmd_index < standard_ioctl_num)\r\ndescr = &(standard_ioctl[cmd_index]);\r\n} else {\r\ncmd_index = IW_EVENT_IDX(cmd);\r\nif (cmd_index < standard_event_num)\r\ndescr = &(standard_event[cmd_index]);\r\n}\r\nif (descr == NULL) {\r\nnetdev_err(dev, "(WE) : Invalid/Unknown Wireless Event (0x%04X)\n",\r\ncmd);\r\nreturn;\r\n}\r\nif (descr->header_type == IW_HEADER_TYPE_POINT) {\r\nif (wrqu->data.length > descr->max_tokens) {\r\nnetdev_err(dev, "(WE) : Wireless Event (cmd=0x%04X) too big (%d)\n",\r\ncmd, wrqu->data.length);\r\nreturn;\r\n}\r\nif (wrqu->data.length < descr->min_tokens) {\r\nnetdev_err(dev, "(WE) : Wireless Event (cmd=0x%04X) too small (%d)\n",\r\ncmd, wrqu->data.length);\r\nreturn;\r\n}\r\nif (extra != NULL)\r\nextra_len = wrqu->data.length * descr->token_size;\r\nwrqu_off = IW_EV_POINT_OFF;\r\n}\r\nhdr_len = event_type_size[descr->header_type];\r\nevent_len = hdr_len + extra_len;\r\nskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nnlh = rtnetlink_ifinfo_prep(dev, skb);\r\nif (WARN_ON(!nlh)) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nnla = nla_reserve(skb, IFLA_WIRELESS, event_len);\r\nif (!nla) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nevent = nla_data(nla);\r\nmemset(event, 0, hdr_len);\r\nevent->len = event_len;\r\nevent->cmd = cmd;\r\nmemcpy(&event->u, ((char *) wrqu) + wrqu_off, hdr_len - IW_EV_LCP_LEN);\r\nif (extra_len)\r\nmemcpy(((char *) event) + hdr_len, extra, extra_len);\r\nnlmsg_end(skb, nlh);\r\n#ifdef CONFIG_COMPAT\r\nhdr_len = compat_event_type_size[descr->header_type];\r\nevent_len = hdr_len + extra_len;\r\ncompskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\r\nif (!compskb) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nnlh = rtnetlink_ifinfo_prep(dev, compskb);\r\nif (WARN_ON(!nlh)) {\r\nkfree_skb(skb);\r\nkfree_skb(compskb);\r\nreturn;\r\n}\r\nnla = nla_reserve(compskb, IFLA_WIRELESS, event_len);\r\nif (!nla) {\r\nkfree_skb(skb);\r\nkfree_skb(compskb);\r\nreturn;\r\n}\r\ncompat_event = nla_data(nla);\r\ncompat_event->len = event_len;\r\ncompat_event->cmd = cmd;\r\nif (descr->header_type == IW_HEADER_TYPE_POINT) {\r\ncompat_wrqu.length = wrqu->data.length;\r\ncompat_wrqu.flags = wrqu->data.flags;\r\nmemcpy(&compat_event->pointer,\r\n((char *) &compat_wrqu) + IW_EV_COMPAT_POINT_OFF,\r\nhdr_len - IW_EV_COMPAT_LCP_LEN);\r\nif (extra_len)\r\nmemcpy(((char *) compat_event) + hdr_len,\r\nextra, extra_len);\r\n} else {\r\nmemcpy(&compat_event->pointer, wrqu,\r\nhdr_len - IW_EV_COMPAT_LCP_LEN);\r\n}\r\nnlmsg_end(compskb, nlh);\r\nskb_shinfo(skb)->frag_list = compskb;\r\n#endif\r\nskb_queue_tail(&dev_net(dev)->wext_nlevents, skb);\r\nschedule_work(&wireless_nlevent_work);\r\n}\r\nstruct iw_statistics *get_wireless_stats(struct net_device *dev)\r\n{\r\n#ifdef CONFIG_WIRELESS_EXT\r\nif ((dev->wireless_handlers != NULL) &&\r\n(dev->wireless_handlers->get_wireless_stats != NULL))\r\nreturn dev->wireless_handlers->get_wireless_stats(dev);\r\n#endif\r\n#ifdef CONFIG_CFG80211_WEXT\r\nif (dev->ieee80211_ptr &&\r\ndev->ieee80211_ptr->wiphy &&\r\ndev->ieee80211_ptr->wiphy->wext &&\r\ndev->ieee80211_ptr->wiphy->wext->get_wireless_stats)\r\nreturn dev->ieee80211_ptr->wiphy->wext->get_wireless_stats(dev);\r\n#endif\r\nreturn NULL;\r\n}\r\nstatic int iw_handler_get_iwstats(struct net_device * dev,\r\nstruct iw_request_info * info,\r\nunion iwreq_data * wrqu,\r\nchar * extra)\r\n{\r\nstruct iw_statistics *stats;\r\nstats = get_wireless_stats(dev);\r\nif (stats) {\r\nmemcpy(extra, stats, sizeof(struct iw_statistics));\r\nwrqu->data.length = sizeof(struct iw_statistics);\r\nif (wrqu->data.flags != 0)\r\nstats->qual.updated &= ~IW_QUAL_ALL_UPDATED;\r\nreturn 0;\r\n} else\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic iw_handler get_handler(struct net_device *dev, unsigned int cmd)\r\n{\r\nunsigned int index;\r\nconst struct iw_handler_def *handlers = NULL;\r\n#ifdef CONFIG_CFG80211_WEXT\r\nif (dev->ieee80211_ptr && dev->ieee80211_ptr->wiphy)\r\nhandlers = dev->ieee80211_ptr->wiphy->wext;\r\n#endif\r\n#ifdef CONFIG_WIRELESS_EXT\r\nif (dev->wireless_handlers)\r\nhandlers = dev->wireless_handlers;\r\n#endif\r\nif (!handlers)\r\nreturn NULL;\r\nindex = IW_IOCTL_IDX(cmd);\r\nif (index < handlers->num_standard)\r\nreturn handlers->standard[index];\r\n#ifdef CONFIG_WEXT_PRIV\r\nindex = cmd - SIOCIWFIRSTPRIV;\r\nif (index < handlers->num_private)\r\nreturn handlers->private[index];\r\n#endif\r\nreturn NULL;\r\n}\r\nstatic int ioctl_standard_iw_point(struct iw_point *iwp, unsigned int cmd,\r\nconst struct iw_ioctl_description *descr,\r\niw_handler handler, struct net_device *dev,\r\nstruct iw_request_info *info)\r\n{\r\nint err, extra_size, user_length = 0, essid_compat = 0;\r\nchar *extra;\r\nextra_size = descr->max_tokens * descr->token_size;\r\nswitch (cmd) {\r\ncase SIOCSIWESSID:\r\ncase SIOCGIWESSID:\r\ncase SIOCSIWNICKN:\r\ncase SIOCGIWNICKN:\r\nif (iwp->length == descr->max_tokens + 1)\r\nessid_compat = 1;\r\nelse if (IW_IS_SET(cmd) && (iwp->length != 0)) {\r\nchar essid[IW_ESSID_MAX_SIZE + 1];\r\nunsigned int len;\r\nlen = iwp->length * descr->token_size;\r\nif (len > IW_ESSID_MAX_SIZE)\r\nreturn -EFAULT;\r\nerr = copy_from_user(essid, iwp->pointer, len);\r\nif (err)\r\nreturn -EFAULT;\r\nif (essid[iwp->length - 1] == '\0')\r\nessid_compat = 1;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\niwp->length -= essid_compat;\r\nif (IW_IS_SET(cmd)) {\r\nif (!iwp->pointer && iwp->length != 0)\r\nreturn -EFAULT;\r\nif (iwp->length > descr->max_tokens)\r\nreturn -E2BIG;\r\nif (iwp->length < descr->min_tokens)\r\nreturn -EINVAL;\r\n} else {\r\nif (!iwp->pointer)\r\nreturn -EFAULT;\r\nuser_length = iwp->length;\r\nif ((descr->flags & IW_DESCR_FLAG_NOMAX) &&\r\n(user_length > descr->max_tokens)) {\r\nextra_size = user_length * descr->token_size;\r\n}\r\n}\r\nextra = kzalloc(extra_size, GFP_KERNEL);\r\nif (!extra)\r\nreturn -ENOMEM;\r\nif (IW_IS_SET(cmd) && (iwp->length != 0)) {\r\nif (copy_from_user(extra, iwp->pointer,\r\niwp->length *\r\ndescr->token_size)) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif (cmd == SIOCSIWENCODEEXT) {\r\nstruct iw_encode_ext *ee = (void *) extra;\r\nif (iwp->length < sizeof(*ee) + ee->key_len) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\n}\r\nif (IW_IS_GET(cmd) && !(descr->flags & IW_DESCR_FLAG_NOMAX)) {\r\niwp->length = descr->max_tokens;\r\n}\r\nerr = handler(dev, info, (union iwreq_data *) iwp, extra);\r\niwp->length += essid_compat;\r\nif (!err && IW_IS_GET(cmd)) {\r\nif (user_length < iwp->length) {\r\nerr = -E2BIG;\r\ngoto out;\r\n}\r\nif (copy_to_user(iwp->pointer, extra,\r\niwp->length *\r\ndescr->token_size)) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\nif ((descr->flags & IW_DESCR_FLAG_EVENT) &&\r\n((err == 0) || (err == -EIWCOMMIT))) {\r\nunion iwreq_data *data = (union iwreq_data *) iwp;\r\nif (descr->flags & IW_DESCR_FLAG_RESTRICT)\r\nwireless_send_event(dev, cmd, data, NULL);\r\nelse\r\nwireless_send_event(dev, cmd, data, extra);\r\n}\r\nout:\r\nkfree(extra);\r\nreturn err;\r\n}\r\nint call_commit_handler(struct net_device *dev)\r\n{\r\n#ifdef CONFIG_WIRELESS_EXT\r\nif ((netif_running(dev)) &&\r\n(dev->wireless_handlers->standard[0] != NULL))\r\nreturn dev->wireless_handlers->standard[0](dev, NULL,\r\nNULL, NULL);\r\nelse\r\nreturn 0;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int wireless_process_ioctl(struct net *net, struct iwreq *iwr,\r\nunsigned int cmd,\r\nstruct iw_request_info *info,\r\nwext_ioctl_func standard,\r\nwext_ioctl_func private)\r\n{\r\nstruct net_device *dev;\r\niw_handler handler;\r\nif ((dev = __dev_get_by_name(net, iwr->ifr_name)) == NULL)\r\nreturn -ENODEV;\r\nif (cmd == SIOCGIWSTATS)\r\nreturn standard(dev, iwr, cmd, info,\r\n&iw_handler_get_iwstats);\r\n#ifdef CONFIG_WEXT_PRIV\r\nif (cmd == SIOCGIWPRIV && dev->wireless_handlers)\r\nreturn standard(dev, iwr, cmd, info,\r\niw_handler_get_private);\r\n#endif\r\nif (!netif_device_present(dev))\r\nreturn -ENODEV;\r\nhandler = get_handler(dev, cmd);\r\nif (handler) {\r\nif (cmd < SIOCIWFIRSTPRIV)\r\nreturn standard(dev, iwr, cmd, info, handler);\r\nelse if (private)\r\nreturn private(dev, iwr, cmd, info, handler);\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int wext_permission_check(unsigned int cmd)\r\n{\r\nif ((IW_IS_SET(cmd) || cmd == SIOCGIWENCODE ||\r\ncmd == SIOCGIWENCODEEXT) &&\r\n!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nstatic int wext_ioctl_dispatch(struct net *net, struct iwreq *iwr,\r\nunsigned int cmd, struct iw_request_info *info,\r\nwext_ioctl_func standard,\r\nwext_ioctl_func private)\r\n{\r\nint ret = wext_permission_check(cmd);\r\nif (ret)\r\nreturn ret;\r\ndev_load(net, iwr->ifr_name);\r\nrtnl_lock();\r\nret = wireless_process_ioctl(net, iwr, cmd, info, standard, private);\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\nstatic int ioctl_standard_call(struct net_device * dev,\r\nstruct iwreq *iwr,\r\nunsigned int cmd,\r\nstruct iw_request_info *info,\r\niw_handler handler)\r\n{\r\nconst struct iw_ioctl_description * descr;\r\nint ret = -EINVAL;\r\nif (IW_IOCTL_IDX(cmd) >= standard_ioctl_num)\r\nreturn -EOPNOTSUPP;\r\ndescr = &(standard_ioctl[IW_IOCTL_IDX(cmd)]);\r\nif (descr->header_type != IW_HEADER_TYPE_POINT) {\r\nret = handler(dev, info, &(iwr->u), NULL);\r\nif ((descr->flags & IW_DESCR_FLAG_EVENT) &&\r\n((ret == 0) || (ret == -EIWCOMMIT)))\r\nwireless_send_event(dev, cmd, &(iwr->u), NULL);\r\n} else {\r\nret = ioctl_standard_iw_point(&iwr->u.data, cmd, descr,\r\nhandler, dev, info);\r\n}\r\nif (ret == -EIWCOMMIT)\r\nret = call_commit_handler(dev);\r\nreturn ret;\r\n}\r\nint wext_handle_ioctl(struct net *net, struct iwreq *iwr, unsigned int cmd,\r\nvoid __user *arg)\r\n{\r\nstruct iw_request_info info = { .cmd = cmd, .flags = 0 };\r\nint ret;\r\nret = wext_ioctl_dispatch(net, iwr, cmd, &info,\r\nioctl_standard_call,\r\nioctl_private_call);\r\nif (ret >= 0 &&\r\nIW_IS_GET(cmd) &&\r\ncopy_to_user(arg, iwr, sizeof(struct iwreq)))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nstatic int compat_standard_call(struct net_device *dev,\r\nstruct iwreq *iwr,\r\nunsigned int cmd,\r\nstruct iw_request_info *info,\r\niw_handler handler)\r\n{\r\nconst struct iw_ioctl_description *descr;\r\nstruct compat_iw_point *iwp_compat;\r\nstruct iw_point iwp;\r\nint err;\r\ndescr = standard_ioctl + IW_IOCTL_IDX(cmd);\r\nif (descr->header_type != IW_HEADER_TYPE_POINT)\r\nreturn ioctl_standard_call(dev, iwr, cmd, info, handler);\r\niwp_compat = (struct compat_iw_point *) &iwr->u.data;\r\niwp.pointer = compat_ptr(iwp_compat->pointer);\r\niwp.length = iwp_compat->length;\r\niwp.flags = iwp_compat->flags;\r\nerr = ioctl_standard_iw_point(&iwp, cmd, descr, handler, dev, info);\r\niwp_compat->pointer = ptr_to_compat(iwp.pointer);\r\niwp_compat->length = iwp.length;\r\niwp_compat->flags = iwp.flags;\r\nreturn err;\r\n}\r\nint compat_wext_handle_ioctl(struct net *net, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nstruct iw_request_info info;\r\nstruct iwreq iwr;\r\nchar *colon;\r\nint ret;\r\nif (copy_from_user(&iwr, argp, sizeof(struct iwreq)))\r\nreturn -EFAULT;\r\niwr.ifr_name[IFNAMSIZ-1] = 0;\r\ncolon = strchr(iwr.ifr_name, ':');\r\nif (colon)\r\n*colon = 0;\r\ninfo.cmd = cmd;\r\ninfo.flags = IW_REQUEST_FLAG_COMPAT;\r\nret = wext_ioctl_dispatch(net, &iwr, cmd, &info,\r\ncompat_standard_call,\r\ncompat_private_call);\r\nif (ret >= 0 &&\r\nIW_IS_GET(cmd) &&\r\ncopy_to_user(argp, &iwr, sizeof(struct iwreq)))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nchar *iwe_stream_add_event(struct iw_request_info *info, char *stream,\r\nchar *ends, struct iw_event *iwe, int event_len)\r\n{\r\nint lcp_len = iwe_stream_lcp_len(info);\r\nevent_len = iwe_stream_event_len_adjust(info, event_len);\r\nif (likely((stream + event_len) < ends)) {\r\niwe->len = event_len;\r\nmemcpy(stream, (char *) iwe, IW_EV_LCP_PK_LEN);\r\nmemcpy(stream + lcp_len, &iwe->u,\r\nevent_len - lcp_len);\r\nstream += event_len;\r\n}\r\nreturn stream;\r\n}\r\nchar *iwe_stream_add_point(struct iw_request_info *info, char *stream,\r\nchar *ends, struct iw_event *iwe, char *extra)\r\n{\r\nint event_len = iwe_stream_point_len(info) + iwe->u.data.length;\r\nint point_len = iwe_stream_point_len(info);\r\nint lcp_len = iwe_stream_lcp_len(info);\r\nif (likely((stream + event_len) < ends)) {\r\niwe->len = event_len;\r\nmemcpy(stream, (char *) iwe, IW_EV_LCP_PK_LEN);\r\nmemcpy(stream + lcp_len,\r\n((char *) &iwe->u) + IW_EV_POINT_OFF,\r\nIW_EV_POINT_PK_LEN - IW_EV_LCP_PK_LEN);\r\nif (iwe->u.data.length && extra)\r\nmemcpy(stream + point_len, extra, iwe->u.data.length);\r\nstream += event_len;\r\n}\r\nreturn stream;\r\n}\r\nchar *iwe_stream_add_value(struct iw_request_info *info, char *event,\r\nchar *value, char *ends, struct iw_event *iwe,\r\nint event_len)\r\n{\r\nint lcp_len = iwe_stream_lcp_len(info);\r\nevent_len -= IW_EV_LCP_LEN;\r\nif (likely((value + event_len) < ends)) {\r\nmemcpy(value, &iwe->u, event_len);\r\nvalue += event_len;\r\niwe->len = value - event;\r\nmemcpy(event, (char *) iwe, lcp_len);\r\n}\r\nreturn value;\r\n}
