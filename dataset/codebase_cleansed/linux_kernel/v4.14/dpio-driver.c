static irqreturn_t dpio_irq_handler(int irq_num, void *arg)\r\n{\r\nstruct device *dev = (struct device *)arg;\r\nstruct dpio_priv *priv = dev_get_drvdata(dev);\r\nreturn dpaa2_io_irq(priv->io);\r\n}\r\nstatic void unregister_dpio_irq_handlers(struct fsl_mc_device *dpio_dev)\r\n{\r\nstruct fsl_mc_device_irq *irq;\r\nirq = dpio_dev->irqs[0];\r\nirq_set_affinity_hint(irq->msi_desc->irq, NULL);\r\n}\r\nstatic int register_dpio_irq_handlers(struct fsl_mc_device *dpio_dev, int cpu)\r\n{\r\nstruct dpio_priv *priv;\r\nint error;\r\nstruct fsl_mc_device_irq *irq;\r\ncpumask_t mask;\r\npriv = dev_get_drvdata(&dpio_dev->dev);\r\nirq = dpio_dev->irqs[0];\r\nerror = devm_request_irq(&dpio_dev->dev,\r\nirq->msi_desc->irq,\r\ndpio_irq_handler,\r\n0,\r\ndev_name(&dpio_dev->dev),\r\n&dpio_dev->dev);\r\nif (error < 0) {\r\ndev_err(&dpio_dev->dev,\r\n"devm_request_irq() failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\ncpumask_clear(&mask);\r\ncpumask_set_cpu(cpu, &mask);\r\nif (irq_set_affinity_hint(irq->msi_desc->irq, &mask))\r\ndev_err(&dpio_dev->dev,\r\n"irq_set_affinity failed irq %d cpu %d\n",\r\nirq->msi_desc->irq, cpu);\r\nreturn 0;\r\n}\r\nstatic int dpaa2_dpio_probe(struct fsl_mc_device *dpio_dev)\r\n{\r\nstruct dpio_attr dpio_attrs;\r\nstruct dpaa2_io_desc desc;\r\nstruct dpio_priv *priv;\r\nint err = -ENOMEM;\r\nstruct device *dev = &dpio_dev->dev;\r\nstatic int next_cpu = -1;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\ngoto err_priv_alloc;\r\ndev_set_drvdata(dev, priv);\r\nerr = fsl_mc_portal_allocate(dpio_dev, 0, &dpio_dev->mc_io);\r\nif (err) {\r\ndev_dbg(dev, "MC portal allocation failed\n");\r\nerr = -EPROBE_DEFER;\r\ngoto err_mcportal;\r\n}\r\nerr = dpio_open(dpio_dev->mc_io, 0, dpio_dev->obj_desc.id,\r\n&dpio_dev->mc_handle);\r\nif (err) {\r\ndev_err(dev, "dpio_open() failed\n");\r\ngoto err_open;\r\n}\r\nerr = dpio_get_attributes(dpio_dev->mc_io, 0, dpio_dev->mc_handle,\r\n&dpio_attrs);\r\nif (err) {\r\ndev_err(dev, "dpio_get_attributes() failed %d\n", err);\r\ngoto err_get_attr;\r\n}\r\ndesc.qman_version = dpio_attrs.qbman_version;\r\nerr = dpio_enable(dpio_dev->mc_io, 0, dpio_dev->mc_handle);\r\nif (err) {\r\ndev_err(dev, "dpio_enable() failed %d\n", err);\r\ngoto err_get_attr;\r\n}\r\ndesc.receives_notifications = dpio_attrs.num_priorities ? 1 : 0;\r\ndesc.has_8prio = dpio_attrs.num_priorities == 8 ? 1 : 0;\r\ndesc.dpio_id = dpio_dev->obj_desc.id;\r\nif (next_cpu == -1)\r\nnext_cpu = cpumask_first(cpu_online_mask);\r\nelse\r\nnext_cpu = cpumask_next(next_cpu, cpu_online_mask);\r\nif (!cpu_possible(next_cpu)) {\r\ndev_err(dev, "probe failed. Number of DPIOs exceeds NR_CPUS.\n");\r\nerr = -ERANGE;\r\ngoto err_allocate_irqs;\r\n}\r\ndesc.cpu = next_cpu;\r\ndesc.regs_cena = ioremap_wc(dpio_dev->regions[1].start,\r\nresource_size(&dpio_dev->regions[1]));\r\ndesc.regs_cinh = ioremap(dpio_dev->regions[1].start,\r\nresource_size(&dpio_dev->regions[1]));\r\nerr = fsl_mc_allocate_irqs(dpio_dev);\r\nif (err) {\r\ndev_err(dev, "fsl_mc_allocate_irqs failed. err=%d\n", err);\r\ngoto err_allocate_irqs;\r\n}\r\nerr = register_dpio_irq_handlers(dpio_dev, desc.cpu);\r\nif (err)\r\ngoto err_register_dpio_irq;\r\npriv->io = dpaa2_io_create(&desc);\r\nif (!priv->io) {\r\ndev_err(dev, "dpaa2_io_create failed\n");\r\ngoto err_dpaa2_io_create;\r\n}\r\ndev_info(dev, "probed\n");\r\ndev_dbg(dev, " receives_notifications = %d\n",\r\ndesc.receives_notifications);\r\ndpio_close(dpio_dev->mc_io, 0, dpio_dev->mc_handle);\r\nfsl_mc_portal_free(dpio_dev->mc_io);\r\nreturn 0;\r\nerr_dpaa2_io_create:\r\nunregister_dpio_irq_handlers(dpio_dev);\r\nerr_register_dpio_irq:\r\nfsl_mc_free_irqs(dpio_dev);\r\nerr_allocate_irqs:\r\ndpio_disable(dpio_dev->mc_io, 0, dpio_dev->mc_handle);\r\nerr_get_attr:\r\ndpio_close(dpio_dev->mc_io, 0, dpio_dev->mc_handle);\r\nerr_open:\r\nfsl_mc_portal_free(dpio_dev->mc_io);\r\nerr_mcportal:\r\ndev_set_drvdata(dev, NULL);\r\nerr_priv_alloc:\r\nreturn err;\r\n}\r\nstatic void dpio_teardown_irqs(struct fsl_mc_device *dpio_dev)\r\n{\r\nunregister_dpio_irq_handlers(dpio_dev);\r\nfsl_mc_free_irqs(dpio_dev);\r\n}\r\nstatic int dpaa2_dpio_remove(struct fsl_mc_device *dpio_dev)\r\n{\r\nstruct device *dev;\r\nstruct dpio_priv *priv;\r\nint err;\r\ndev = &dpio_dev->dev;\r\npriv = dev_get_drvdata(dev);\r\ndpaa2_io_down(priv->io);\r\ndpio_teardown_irqs(dpio_dev);\r\nerr = fsl_mc_portal_allocate(dpio_dev, 0, &dpio_dev->mc_io);\r\nif (err) {\r\ndev_err(dev, "MC portal allocation failed\n");\r\ngoto err_mcportal;\r\n}\r\nerr = dpio_open(dpio_dev->mc_io, 0, dpio_dev->obj_desc.id,\r\n&dpio_dev->mc_handle);\r\nif (err) {\r\ndev_err(dev, "dpio_open() failed\n");\r\ngoto err_open;\r\n}\r\ndpio_disable(dpio_dev->mc_io, 0, dpio_dev->mc_handle);\r\ndpio_close(dpio_dev->mc_io, 0, dpio_dev->mc_handle);\r\nfsl_mc_portal_free(dpio_dev->mc_io);\r\ndev_set_drvdata(dev, NULL);\r\nreturn 0;\r\nerr_open:\r\nfsl_mc_portal_free(dpio_dev->mc_io);\r\nerr_mcportal:\r\nreturn err;\r\n}\r\nstatic int dpio_driver_init(void)\r\n{\r\nreturn fsl_mc_driver_register(&dpaa2_dpio_driver);\r\n}\r\nstatic void dpio_driver_exit(void)\r\n{\r\nfsl_mc_driver_unregister(&dpaa2_dpio_driver);\r\n}
