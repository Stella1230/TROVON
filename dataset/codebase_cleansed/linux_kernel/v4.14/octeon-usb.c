static int dwc3_octeon_config_power(struct device *dev, u64 base)\r\n{\r\n#define UCTL_HOST_CFG 0xe0\r\nunion cvm_usbdrd_uctl_host_cfg uctl_host_cfg;\r\nunion cvmx_gpio_bit_cfgx gpio_bit;\r\nuint32_t gpio_pwr[3];\r\nint gpio, len, power_active_low;\r\nstruct device_node *node = dev->of_node;\r\nint index = (base >> 24) & 1;\r\nif (of_find_property(node, "power", &len) != NULL) {\r\nif (len == 12) {\r\nof_property_read_u32_array(node, "power", gpio_pwr, 3);\r\npower_active_low = gpio_pwr[2] & 0x01;\r\ngpio = gpio_pwr[1];\r\n} else if (len == 8) {\r\nof_property_read_u32_array(node, "power", gpio_pwr, 2);\r\npower_active_low = 0;\r\ngpio = gpio_pwr[1];\r\n} else {\r\ndev_err(dev, "dwc3 controller clock init failure.\n");\r\nreturn -EINVAL;\r\n}\r\nif ((OCTEON_IS_MODEL(OCTEON_CN73XX) ||\r\nOCTEON_IS_MODEL(OCTEON_CNF75XX))\r\n&& gpio <= 31) {\r\ngpio_bit.u64 = cvmx_read_csr(CVMX_GPIO_BIT_CFGX(gpio));\r\ngpio_bit.s.tx_oe = 1;\r\ngpio_bit.cn73xx.output_sel = (index == 0 ? 0x14 : 0x15);\r\ncvmx_write_csr(CVMX_GPIO_BIT_CFGX(gpio), gpio_bit.u64);\r\n} else if (gpio <= 15) {\r\ngpio_bit.u64 = cvmx_read_csr(CVMX_GPIO_BIT_CFGX(gpio));\r\ngpio_bit.s.tx_oe = 1;\r\ngpio_bit.cn70xx.output_sel = (index == 0 ? 0x14 : 0x19);\r\ncvmx_write_csr(CVMX_GPIO_BIT_CFGX(gpio), gpio_bit.u64);\r\n} else {\r\ngpio_bit.u64 = cvmx_read_csr(CVMX_GPIO_XBIT_CFGX(gpio));\r\ngpio_bit.s.tx_oe = 1;\r\ngpio_bit.cn70xx.output_sel = (index == 0 ? 0x14 : 0x19);\r\ncvmx_write_csr(CVMX_GPIO_XBIT_CFGX(gpio), gpio_bit.u64);\r\n}\r\nuctl_host_cfg.u64 = cvmx_read_csr(base + UCTL_HOST_CFG);\r\nuctl_host_cfg.s.ppc_en = 1;\r\nuctl_host_cfg.s.ppc_active_high_en = !power_active_low;\r\ncvmx_write_csr(base + UCTL_HOST_CFG, uctl_host_cfg.u64);\r\n} else {\r\nuctl_host_cfg.u64 = cvmx_read_csr(base + UCTL_HOST_CFG);\r\nuctl_host_cfg.s.ppc_en = 0;\r\nuctl_host_cfg.s.ppc_active_high_en = 0;\r\ncvmx_write_csr(base + UCTL_HOST_CFG, uctl_host_cfg.u64);\r\ndev_warn(dev, "dwc3 controller clock init failure.\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int dwc3_octeon_clocks_start(struct device *dev, u64 base)\r\n{\r\nunion cvm_usbdrd_uctl_ctl uctl_ctl;\r\nint ref_clk_sel = 2;\r\nu64 div;\r\nu32 clock_rate;\r\nint mpll_mul;\r\nint i;\r\nu64 h_clk_rate;\r\nu64 uctl_ctl_reg = base;\r\nif (dev->of_node) {\r\nconst char *ss_clock_type;\r\nconst char *hs_clock_type;\r\ni = of_property_read_u32(dev->of_node,\r\n"refclk-frequency", &clock_rate);\r\nif (i) {\r\npr_err("No UCTL \"refclk-frequency\"\n");\r\nreturn -EINVAL;\r\n}\r\ni = of_property_read_string(dev->of_node,\r\n"refclk-type-ss", &ss_clock_type);\r\nif (i) {\r\npr_err("No UCTL \"refclk-type-ss\"\n");\r\nreturn -EINVAL;\r\n}\r\ni = of_property_read_string(dev->of_node,\r\n"refclk-type-hs", &hs_clock_type);\r\nif (i) {\r\npr_err("No UCTL \"refclk-type-hs\"\n");\r\nreturn -EINVAL;\r\n}\r\nif (strcmp("dlmc_ref_clk0", ss_clock_type) == 0) {\r\nif (strcmp(hs_clock_type, "dlmc_ref_clk0") == 0)\r\nref_clk_sel = 0;\r\nelse if (strcmp(hs_clock_type, "pll_ref_clk") == 0)\r\nref_clk_sel = 2;\r\nelse\r\npr_err("Invalid HS clock type %s, using pll_ref_clk instead\n",\r\nhs_clock_type);\r\n} else if (strcmp(ss_clock_type, "dlmc_ref_clk1") == 0) {\r\nif (strcmp(hs_clock_type, "dlmc_ref_clk1") == 0)\r\nref_clk_sel = 1;\r\nelse if (strcmp(hs_clock_type, "pll_ref_clk") == 0)\r\nref_clk_sel = 3;\r\nelse {\r\npr_err("Invalid HS clock type %s, using pll_ref_clk instead\n",\r\nhs_clock_type);\r\nref_clk_sel = 3;\r\n}\r\n} else\r\npr_err("Invalid SS clock type %s, using dlmc_ref_clk0 instead\n",\r\nss_clock_type);\r\nif ((ref_clk_sel == 0 || ref_clk_sel == 1) &&\r\n(clock_rate != 100000000))\r\npr_err("Invalid UCTL clock rate of %u, using 100000000 instead\n",\r\nclock_rate);\r\n} else {\r\npr_err("No USB UCTL device node\n");\r\nreturn -EINVAL;\r\n}\r\nuctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);\r\nuctl_ctl.s.uphy_rst = 1;\r\nuctl_ctl.s.uahc_rst = 1;\r\nuctl_ctl.s.uctl_rst = 1;\r\ncvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);\r\nuctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);\r\nuctl_ctl.s.h_clkdiv_rst = 1;\r\ncvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);\r\nfor (div = 0; div < OCTEON_H_CLKDIV_SEL; div++) {\r\nh_clk_rate = octeon_get_io_clock_rate() / clk_div[div];\r\nif (h_clk_rate <= OCTEON_MAX_H_CLK_RATE &&\r\nh_clk_rate >= OCTEON_MIN_H_CLK_RATE)\r\nbreak;\r\n}\r\nuctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);\r\nuctl_ctl.s.h_clkdiv_sel = div;\r\nuctl_ctl.s.h_clk_en = 1;\r\ncvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);\r\nuctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);\r\nif ((div != uctl_ctl.s.h_clkdiv_sel) || (!uctl_ctl.s.h_clk_en)) {\r\ndev_err(dev, "dwc3 controller clock init failure.\n");\r\nreturn -EINVAL;\r\n}\r\nuctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);\r\nuctl_ctl.s.h_clkdiv_rst = 0;\r\ncvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);\r\nuctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);\r\nuctl_ctl.s.ref_clk_sel = ref_clk_sel;\r\nuctl_ctl.s.ref_clk_fsel = 0x07;\r\nuctl_ctl.s.ref_clk_div2 = 0;\r\nswitch (clock_rate) {\r\ndefault:\r\ndev_err(dev, "Invalid ref_clk %u, using 100000000 instead\n",\r\nclock_rate);\r\ncase 100000000:\r\nmpll_mul = 0x19;\r\nif (ref_clk_sel < 2)\r\nuctl_ctl.s.ref_clk_fsel = 0x27;\r\nbreak;\r\ncase 50000000:\r\nmpll_mul = 0x32;\r\nbreak;\r\ncase 125000000:\r\nmpll_mul = 0x28;\r\nbreak;\r\n}\r\nuctl_ctl.s.mpll_multiplier = mpll_mul;\r\nuctl_ctl.s.ssc_en = 1;\r\nuctl_ctl.s.ref_ssp_en = 1;\r\nuctl_ctl.s.hs_power_en = 1;\r\nuctl_ctl.s.ss_power_en = 1;\r\ncvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);\r\nudelay(10);\r\nuctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);\r\nuctl_ctl.s.uctl_rst = 0;\r\ncvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);\r\nudelay(10);\r\nif (dwc3_octeon_config_power(dev, base)) {\r\ndev_err(dev, "Error configuring power.\n");\r\nreturn -EINVAL;\r\n}\r\nuctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);\r\nuctl_ctl.s.uahc_rst = 0;\r\ncvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);\r\nudelay(10);\r\nuctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);\r\nuctl_ctl.s.csclk_en = 1;\r\ncvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);\r\nuctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);\r\nuctl_ctl.s.drd_mode = 0;\r\ncvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);\r\nreturn 0;\r\n}\r\nstatic void __init dwc3_octeon_set_endian_mode(u64 base)\r\n{\r\n#define UCTL_SHIM_CFG 0xe8\r\nunion cvm_usbdrd_uctl_shim_cfg shim_cfg;\r\nshim_cfg.u64 = cvmx_read_csr(base + UCTL_SHIM_CFG);\r\n#ifdef __BIG_ENDIAN\r\nshim_cfg.s.dma_endian_mode = 1;\r\nshim_cfg.s.csr_endian_mode = 1;\r\n#else\r\nshim_cfg.s.dma_endian_mode = 0;\r\nshim_cfg.s.csr_endian_mode = 0;\r\n#endif\r\ncvmx_write_csr(base + UCTL_SHIM_CFG, shim_cfg.u64);\r\n}\r\nstatic void __init dwc3_octeon_phy_reset(u64 base)\r\n{\r\nunion cvm_usbdrd_uctl_ctl uctl_ctl;\r\nint index = (base >> 24) & 1;\r\nuctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));\r\nuctl_ctl.s.uphy_rst = 0;\r\ncvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);\r\n}\r\nstatic int __init dwc3_octeon_device_init(void)\r\n{\r\nconst char compat_node_name[] = "cavium,octeon-7130-usb-uctl";\r\nstruct platform_device *pdev;\r\nstruct device_node *node;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nnode = NULL;\r\ndo {\r\nnode = of_find_node_by_name(node, "uctl");\r\nif (!node)\r\nreturn -ENODEV;\r\nif (of_device_is_compatible(node, compat_node_name)) {\r\npdev = of_find_device_by_node(node);\r\nif (!pdev)\r\nreturn -ENODEV;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "No memory resources\n");\r\nreturn -ENXIO;\r\n}\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nmutex_lock(&dwc3_octeon_clocks_mutex);\r\ndwc3_octeon_clocks_start(&pdev->dev, (u64)base);\r\ndwc3_octeon_set_endian_mode((u64)base);\r\ndwc3_octeon_phy_reset((u64)base);\r\ndev_info(&pdev->dev, "clocks initialized.\n");\r\nmutex_unlock(&dwc3_octeon_clocks_mutex);\r\ndevm_iounmap(&pdev->dev, base);\r\ndevm_release_mem_region(&pdev->dev, res->start,\r\nresource_size(res));\r\n}\r\n} while (node != NULL);\r\nreturn 0;\r\n}
