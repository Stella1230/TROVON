static int build_rdma_send(union t3_wr *wqe, struct ib_send_wr *wr,\r\nu8 * flit_cnt)\r\n{\r\nint i;\r\nu32 plen;\r\nswitch (wr->opcode) {\r\ncase IB_WR_SEND:\r\nif (wr->send_flags & IB_SEND_SOLICITED)\r\nwqe->send.rdmaop = T3_SEND_WITH_SE;\r\nelse\r\nwqe->send.rdmaop = T3_SEND;\r\nwqe->send.rem_stag = 0;\r\nbreak;\r\ncase IB_WR_SEND_WITH_INV:\r\nif (wr->send_flags & IB_SEND_SOLICITED)\r\nwqe->send.rdmaop = T3_SEND_WITH_SE_INV;\r\nelse\r\nwqe->send.rdmaop = T3_SEND_WITH_INV;\r\nwqe->send.rem_stag = cpu_to_be32(wr->ex.invalidate_rkey);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (wr->num_sge > T3_MAX_SGE)\r\nreturn -EINVAL;\r\nwqe->send.reserved[0] = 0;\r\nwqe->send.reserved[1] = 0;\r\nwqe->send.reserved[2] = 0;\r\nplen = 0;\r\nfor (i = 0; i < wr->num_sge; i++) {\r\nif ((plen + wr->sg_list[i].length) < plen)\r\nreturn -EMSGSIZE;\r\nplen += wr->sg_list[i].length;\r\nwqe->send.sgl[i].stag = cpu_to_be32(wr->sg_list[i].lkey);\r\nwqe->send.sgl[i].len = cpu_to_be32(wr->sg_list[i].length);\r\nwqe->send.sgl[i].to = cpu_to_be64(wr->sg_list[i].addr);\r\n}\r\nwqe->send.num_sgle = cpu_to_be32(wr->num_sge);\r\n*flit_cnt = 4 + ((wr->num_sge) << 1);\r\nwqe->send.plen = cpu_to_be32(plen);\r\nreturn 0;\r\n}\r\nstatic int build_rdma_write(union t3_wr *wqe, struct ib_send_wr *wr,\r\nu8 *flit_cnt)\r\n{\r\nint i;\r\nu32 plen;\r\nif (wr->num_sge > T3_MAX_SGE)\r\nreturn -EINVAL;\r\nwqe->write.rdmaop = T3_RDMA_WRITE;\r\nwqe->write.reserved[0] = 0;\r\nwqe->write.reserved[1] = 0;\r\nwqe->write.reserved[2] = 0;\r\nwqe->write.stag_sink = cpu_to_be32(rdma_wr(wr)->rkey);\r\nwqe->write.to_sink = cpu_to_be64(rdma_wr(wr)->remote_addr);\r\nif (wr->opcode == IB_WR_RDMA_WRITE_WITH_IMM) {\r\nplen = 4;\r\nwqe->write.sgl[0].stag = wr->ex.imm_data;\r\nwqe->write.sgl[0].len = cpu_to_be32(0);\r\nwqe->write.num_sgle = cpu_to_be32(0);\r\n*flit_cnt = 6;\r\n} else {\r\nplen = 0;\r\nfor (i = 0; i < wr->num_sge; i++) {\r\nif ((plen + wr->sg_list[i].length) < plen) {\r\nreturn -EMSGSIZE;\r\n}\r\nplen += wr->sg_list[i].length;\r\nwqe->write.sgl[i].stag =\r\ncpu_to_be32(wr->sg_list[i].lkey);\r\nwqe->write.sgl[i].len =\r\ncpu_to_be32(wr->sg_list[i].length);\r\nwqe->write.sgl[i].to =\r\ncpu_to_be64(wr->sg_list[i].addr);\r\n}\r\nwqe->write.num_sgle = cpu_to_be32(wr->num_sge);\r\n*flit_cnt = 5 + ((wr->num_sge) << 1);\r\n}\r\nwqe->write.plen = cpu_to_be32(plen);\r\nreturn 0;\r\n}\r\nstatic int build_rdma_read(union t3_wr *wqe, struct ib_send_wr *wr,\r\nu8 *flit_cnt)\r\n{\r\nif (wr->num_sge > 1)\r\nreturn -EINVAL;\r\nwqe->read.rdmaop = T3_READ_REQ;\r\nif (wr->opcode == IB_WR_RDMA_READ_WITH_INV)\r\nwqe->read.local_inv = 1;\r\nelse\r\nwqe->read.local_inv = 0;\r\nwqe->read.reserved[0] = 0;\r\nwqe->read.reserved[1] = 0;\r\nwqe->read.rem_stag = cpu_to_be32(rdma_wr(wr)->rkey);\r\nwqe->read.rem_to = cpu_to_be64(rdma_wr(wr)->remote_addr);\r\nwqe->read.local_stag = cpu_to_be32(wr->sg_list[0].lkey);\r\nwqe->read.local_len = cpu_to_be32(wr->sg_list[0].length);\r\nwqe->read.local_to = cpu_to_be64(wr->sg_list[0].addr);\r\n*flit_cnt = sizeof(struct t3_rdma_read_wr) >> 3;\r\nreturn 0;\r\n}\r\nstatic int build_memreg(union t3_wr *wqe, struct ib_reg_wr *wr,\r\nu8 *flit_cnt, int *wr_cnt, struct t3_wq *wq)\r\n{\r\nstruct iwch_mr *mhp = to_iwch_mr(wr->mr);\r\nint i;\r\n__be64 *p;\r\nif (mhp->npages > T3_MAX_FASTREG_DEPTH)\r\nreturn -EINVAL;\r\n*wr_cnt = 1;\r\nwqe->fastreg.stag = cpu_to_be32(wr->key);\r\nwqe->fastreg.len = cpu_to_be32(mhp->ibmr.length);\r\nwqe->fastreg.va_base_hi = cpu_to_be32(mhp->ibmr.iova >> 32);\r\nwqe->fastreg.va_base_lo_fbo =\r\ncpu_to_be32(mhp->ibmr.iova & 0xffffffff);\r\nwqe->fastreg.page_type_perms = cpu_to_be32(\r\nV_FR_PAGE_COUNT(mhp->npages) |\r\nV_FR_PAGE_SIZE(ilog2(wr->mr->page_size) - 12) |\r\nV_FR_TYPE(TPT_VATO) |\r\nV_FR_PERMS(iwch_ib_to_tpt_access(wr->access)));\r\np = &wqe->fastreg.pbl_addrs[0];\r\nfor (i = 0; i < mhp->npages; i++, p++) {\r\nif (i == T3_MAX_FASTREG_FRAG) {\r\n*wr_cnt = 2;\r\nwqe = (union t3_wr *)(wq->queue +\r\nQ_PTR2IDX((wq->wptr+1), wq->size_log2));\r\nbuild_fw_riwrh((void *)wqe, T3_WR_FASTREG, 0,\r\nQ_GENBIT(wq->wptr + 1, wq->size_log2),\r\n0, 1 + mhp->npages - T3_MAX_FASTREG_FRAG,\r\nT3_EOP);\r\np = &wqe->pbl_frag.pbl_addrs[0];\r\n}\r\n*p = cpu_to_be64((u64)mhp->pages[i]);\r\n}\r\n*flit_cnt = 5 + mhp->npages;\r\nif (*flit_cnt > 15)\r\n*flit_cnt = 15;\r\nreturn 0;\r\n}\r\nstatic int build_inv_stag(union t3_wr *wqe, struct ib_send_wr *wr,\r\nu8 *flit_cnt)\r\n{\r\nwqe->local_inv.stag = cpu_to_be32(wr->ex.invalidate_rkey);\r\nwqe->local_inv.reserved = 0;\r\n*flit_cnt = sizeof(struct t3_local_inv_wr) >> 3;\r\nreturn 0;\r\n}\r\nstatic int iwch_sgl2pbl_map(struct iwch_dev *rhp, struct ib_sge *sg_list,\r\nu32 num_sgle, u32 * pbl_addr, u8 * page_size)\r\n{\r\nint i;\r\nstruct iwch_mr *mhp;\r\nu64 offset;\r\nfor (i = 0; i < num_sgle; i++) {\r\nmhp = get_mhp(rhp, (sg_list[i].lkey) >> 8);\r\nif (!mhp) {\r\npr_debug("%s %d\n", __func__, __LINE__);\r\nreturn -EIO;\r\n}\r\nif (!mhp->attr.state) {\r\npr_debug("%s %d\n", __func__, __LINE__);\r\nreturn -EIO;\r\n}\r\nif (mhp->attr.zbva) {\r\npr_debug("%s %d\n", __func__, __LINE__);\r\nreturn -EIO;\r\n}\r\nif (sg_list[i].addr < mhp->attr.va_fbo) {\r\npr_debug("%s %d\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nif (sg_list[i].addr + ((u64) sg_list[i].length) <\r\nsg_list[i].addr) {\r\npr_debug("%s %d\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nif (sg_list[i].addr + ((u64) sg_list[i].length) >\r\nmhp->attr.va_fbo + ((u64) mhp->attr.len)) {\r\npr_debug("%s %d\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\noffset = sg_list[i].addr - mhp->attr.va_fbo;\r\noffset += mhp->attr.va_fbo &\r\n((1UL << (12 + mhp->attr.page_size)) - 1);\r\npbl_addr[i] = ((mhp->attr.pbl_addr -\r\nrhp->rdev.rnic_info.pbl_base) >> 3) +\r\n(offset >> (12 + mhp->attr.page_size));\r\npage_size[i] = mhp->attr.page_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int build_rdma_recv(struct iwch_qp *qhp, union t3_wr *wqe,\r\nstruct ib_recv_wr *wr)\r\n{\r\nint i, err = 0;\r\nu32 pbl_addr[T3_MAX_SGE];\r\nu8 page_size[T3_MAX_SGE];\r\nerr = iwch_sgl2pbl_map(qhp->rhp, wr->sg_list, wr->num_sge, pbl_addr,\r\npage_size);\r\nif (err)\r\nreturn err;\r\nwqe->recv.pagesz[0] = page_size[0];\r\nwqe->recv.pagesz[1] = page_size[1];\r\nwqe->recv.pagesz[2] = page_size[2];\r\nwqe->recv.pagesz[3] = page_size[3];\r\nwqe->recv.num_sgle = cpu_to_be32(wr->num_sge);\r\nfor (i = 0; i < wr->num_sge; i++) {\r\nwqe->recv.sgl[i].stag = cpu_to_be32(wr->sg_list[i].lkey);\r\nwqe->recv.sgl[i].len = cpu_to_be32(wr->sg_list[i].length);\r\nwqe->recv.sgl[i].to = cpu_to_be64(((u32)wr->sg_list[i].addr) &\r\n((1UL << (12 + page_size[i])) - 1));\r\nwqe->recv.pbl_addr[i] = cpu_to_be32(pbl_addr[i]);\r\n}\r\nfor (; i < T3_MAX_SGE; i++) {\r\nwqe->recv.sgl[i].stag = 0;\r\nwqe->recv.sgl[i].len = 0;\r\nwqe->recv.sgl[i].to = 0;\r\nwqe->recv.pbl_addr[i] = 0;\r\n}\r\nqhp->wq.rq[Q_PTR2IDX(qhp->wq.rq_wptr,\r\nqhp->wq.rq_size_log2)].wr_id = wr->wr_id;\r\nqhp->wq.rq[Q_PTR2IDX(qhp->wq.rq_wptr,\r\nqhp->wq.rq_size_log2)].pbl_addr = 0;\r\nreturn 0;\r\n}\r\nstatic int build_zero_stag_recv(struct iwch_qp *qhp, union t3_wr *wqe,\r\nstruct ib_recv_wr *wr)\r\n{\r\nint i;\r\nu32 pbl_addr;\r\nu32 pbl_offset;\r\npbl_addr = cxio_hal_pblpool_alloc(&qhp->rhp->rdev, T3_STAG0_PBL_SIZE);\r\nif (!pbl_addr)\r\nreturn -ENOMEM;\r\npbl_offset = (pbl_addr - qhp->rhp->rdev.rnic_info.pbl_base) >> 3;\r\nwqe->recv.num_sgle = cpu_to_be32(wr->num_sge);\r\nfor (i = 0; i < wr->num_sge; i++) {\r\nif (wr->sg_list[i].length > T3_STAG0_MAX_PBE_LEN)\r\nreturn -EINVAL;\r\nwqe->recv.pagesz[i] = T3_STAG0_PAGE_SHIFT;\r\nif (wr->sg_list[i].lkey != 0)\r\nreturn -EINVAL;\r\nwqe->recv.sgl[i].stag = 0;\r\nwqe->recv.sgl[i].len = cpu_to_be32(wr->sg_list[i].length);\r\nwqe->recv.sgl[i].to = cpu_to_be64(wr->sg_list[i].addr);\r\nwqe->recv.pbl_addr[i] = cpu_to_be32(pbl_offset);\r\npbl_offset += 2;\r\n}\r\nfor (; i < T3_MAX_SGE; i++) {\r\nwqe->recv.pagesz[i] = 0;\r\nwqe->recv.sgl[i].stag = 0;\r\nwqe->recv.sgl[i].len = 0;\r\nwqe->recv.sgl[i].to = 0;\r\nwqe->recv.pbl_addr[i] = 0;\r\n}\r\nqhp->wq.rq[Q_PTR2IDX(qhp->wq.rq_wptr,\r\nqhp->wq.rq_size_log2)].wr_id = wr->wr_id;\r\nqhp->wq.rq[Q_PTR2IDX(qhp->wq.rq_wptr,\r\nqhp->wq.rq_size_log2)].pbl_addr = pbl_addr;\r\nreturn 0;\r\n}\r\nint iwch_post_send(struct ib_qp *ibqp, struct ib_send_wr *wr,\r\nstruct ib_send_wr **bad_wr)\r\n{\r\nint err = 0;\r\nu8 uninitialized_var(t3_wr_flit_cnt);\r\nenum t3_wr_opcode t3_wr_opcode = 0;\r\nenum t3_wr_flags t3_wr_flags;\r\nstruct iwch_qp *qhp;\r\nu32 idx;\r\nunion t3_wr *wqe;\r\nu32 num_wrs;\r\nunsigned long flag;\r\nstruct t3_swsq *sqp;\r\nint wr_cnt = 1;\r\nqhp = to_iwch_qp(ibqp);\r\nspin_lock_irqsave(&qhp->lock, flag);\r\nif (qhp->attr.state > IWCH_QP_STATE_RTS) {\r\nspin_unlock_irqrestore(&qhp->lock, flag);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nnum_wrs = Q_FREECNT(qhp->wq.sq_rptr, qhp->wq.sq_wptr,\r\nqhp->wq.sq_size_log2);\r\nif (num_wrs == 0) {\r\nspin_unlock_irqrestore(&qhp->lock, flag);\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nwhile (wr) {\r\nif (num_wrs == 0) {\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nidx = Q_PTR2IDX(qhp->wq.wptr, qhp->wq.size_log2);\r\nwqe = (union t3_wr *) (qhp->wq.queue + idx);\r\nt3_wr_flags = 0;\r\nif (wr->send_flags & IB_SEND_SOLICITED)\r\nt3_wr_flags |= T3_SOLICITED_EVENT_FLAG;\r\nif (wr->send_flags & IB_SEND_SIGNALED)\r\nt3_wr_flags |= T3_COMPLETION_FLAG;\r\nsqp = qhp->wq.sq +\r\nQ_PTR2IDX(qhp->wq.sq_wptr, qhp->wq.sq_size_log2);\r\nswitch (wr->opcode) {\r\ncase IB_WR_SEND:\r\ncase IB_WR_SEND_WITH_INV:\r\nif (wr->send_flags & IB_SEND_FENCE)\r\nt3_wr_flags |= T3_READ_FENCE_FLAG;\r\nt3_wr_opcode = T3_WR_SEND;\r\nerr = build_rdma_send(wqe, wr, &t3_wr_flit_cnt);\r\nbreak;\r\ncase IB_WR_RDMA_WRITE:\r\ncase IB_WR_RDMA_WRITE_WITH_IMM:\r\nt3_wr_opcode = T3_WR_WRITE;\r\nerr = build_rdma_write(wqe, wr, &t3_wr_flit_cnt);\r\nbreak;\r\ncase IB_WR_RDMA_READ:\r\ncase IB_WR_RDMA_READ_WITH_INV:\r\nt3_wr_opcode = T3_WR_READ;\r\nt3_wr_flags = 0;\r\nerr = build_rdma_read(wqe, wr, &t3_wr_flit_cnt);\r\nif (err)\r\nbreak;\r\nsqp->read_len = wqe->read.local_len;\r\nif (!qhp->wq.oldest_read)\r\nqhp->wq.oldest_read = sqp;\r\nbreak;\r\ncase IB_WR_REG_MR:\r\nt3_wr_opcode = T3_WR_FASTREG;\r\nerr = build_memreg(wqe, reg_wr(wr), &t3_wr_flit_cnt,\r\n&wr_cnt, &qhp->wq);\r\nbreak;\r\ncase IB_WR_LOCAL_INV:\r\nif (wr->send_flags & IB_SEND_FENCE)\r\nt3_wr_flags |= T3_LOCAL_FENCE_FLAG;\r\nt3_wr_opcode = T3_WR_INV_STAG;\r\nerr = build_inv_stag(wqe, wr, &t3_wr_flit_cnt);\r\nbreak;\r\ndefault:\r\npr_debug("%s post of type=%d TBD!\n", __func__,\r\nwr->opcode);\r\nerr = -EINVAL;\r\n}\r\nif (err)\r\nbreak;\r\nwqe->send.wrid.id0.hi = qhp->wq.sq_wptr;\r\nsqp->wr_id = wr->wr_id;\r\nsqp->opcode = wr2opcode(t3_wr_opcode);\r\nsqp->sq_wptr = qhp->wq.sq_wptr;\r\nsqp->complete = 0;\r\nsqp->signaled = (wr->send_flags & IB_SEND_SIGNALED);\r\nbuild_fw_riwrh((void *) wqe, t3_wr_opcode, t3_wr_flags,\r\nQ_GENBIT(qhp->wq.wptr, qhp->wq.size_log2),\r\n0, t3_wr_flit_cnt,\r\n(wr_cnt == 1) ? T3_SOPEOP : T3_SOP);\r\npr_debug("%s cookie 0x%llx wq idx 0x%x swsq idx %ld opcode %d\n",\r\n__func__, (unsigned long long)wr->wr_id, idx,\r\nQ_PTR2IDX(qhp->wq.sq_wptr, qhp->wq.sq_size_log2),\r\nsqp->opcode);\r\nwr = wr->next;\r\nnum_wrs--;\r\nqhp->wq.wptr += wr_cnt;\r\n++(qhp->wq.sq_wptr);\r\n}\r\nspin_unlock_irqrestore(&qhp->lock, flag);\r\nif (cxio_wq_db_enabled(&qhp->wq))\r\nring_doorbell(qhp->wq.doorbell, qhp->wq.qpid);\r\nout:\r\nif (err)\r\n*bad_wr = wr;\r\nreturn err;\r\n}\r\nint iwch_post_receive(struct ib_qp *ibqp, struct ib_recv_wr *wr,\r\nstruct ib_recv_wr **bad_wr)\r\n{\r\nint err = 0;\r\nstruct iwch_qp *qhp;\r\nu32 idx;\r\nunion t3_wr *wqe;\r\nu32 num_wrs;\r\nunsigned long flag;\r\nqhp = to_iwch_qp(ibqp);\r\nspin_lock_irqsave(&qhp->lock, flag);\r\nif (qhp->attr.state > IWCH_QP_STATE_RTS) {\r\nspin_unlock_irqrestore(&qhp->lock, flag);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nnum_wrs = Q_FREECNT(qhp->wq.rq_rptr, qhp->wq.rq_wptr,\r\nqhp->wq.rq_size_log2) - 1;\r\nif (!wr) {\r\nspin_unlock_irqrestore(&qhp->lock, flag);\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nwhile (wr) {\r\nif (wr->num_sge > T3_MAX_SGE) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nidx = Q_PTR2IDX(qhp->wq.wptr, qhp->wq.size_log2);\r\nwqe = (union t3_wr *) (qhp->wq.queue + idx);\r\nif (num_wrs)\r\nif (wr->sg_list[0].lkey)\r\nerr = build_rdma_recv(qhp, wqe, wr);\r\nelse\r\nerr = build_zero_stag_recv(qhp, wqe, wr);\r\nelse\r\nerr = -ENOMEM;\r\nif (err)\r\nbreak;\r\nbuild_fw_riwrh((void *) wqe, T3_WR_RCV, T3_COMPLETION_FLAG,\r\nQ_GENBIT(qhp->wq.wptr, qhp->wq.size_log2),\r\n0, sizeof(struct t3_receive_wr) >> 3, T3_SOPEOP);\r\npr_debug("%s cookie 0x%llx idx 0x%x rq_wptr 0x%x rw_rptr 0x%x wqe %p\n",\r\n__func__, (unsigned long long)wr->wr_id,\r\nidx, qhp->wq.rq_wptr, qhp->wq.rq_rptr, wqe);\r\n++(qhp->wq.rq_wptr);\r\n++(qhp->wq.wptr);\r\nwr = wr->next;\r\nnum_wrs--;\r\n}\r\nspin_unlock_irqrestore(&qhp->lock, flag);\r\nif (cxio_wq_db_enabled(&qhp->wq))\r\nring_doorbell(qhp->wq.doorbell, qhp->wq.qpid);\r\nout:\r\nif (err)\r\n*bad_wr = wr;\r\nreturn err;\r\n}\r\nstatic inline void build_term_codes(struct respQ_msg_t *rsp_msg,\r\nu8 *layer_type, u8 *ecode)\r\n{\r\nint status = TPT_ERR_INTERNAL_ERR;\r\nint tagged = 0;\r\nint opcode = -1;\r\nint rqtype = 0;\r\nint send_inv = 0;\r\nif (rsp_msg) {\r\nstatus = CQE_STATUS(rsp_msg->cqe);\r\nopcode = CQE_OPCODE(rsp_msg->cqe);\r\nrqtype = RQ_TYPE(rsp_msg->cqe);\r\nsend_inv = (opcode == T3_SEND_WITH_INV) ||\r\n(opcode == T3_SEND_WITH_SE_INV);\r\ntagged = (opcode == T3_RDMA_WRITE) ||\r\n(rqtype && (opcode == T3_READ_RESP));\r\n}\r\nswitch (status) {\r\ncase TPT_ERR_STAG:\r\nif (send_inv) {\r\n*layer_type = LAYER_RDMAP|RDMAP_REMOTE_OP;\r\n*ecode = RDMAP_CANT_INV_STAG;\r\n} else {\r\n*layer_type = LAYER_RDMAP|RDMAP_REMOTE_PROT;\r\n*ecode = RDMAP_INV_STAG;\r\n}\r\nbreak;\r\ncase TPT_ERR_PDID:\r\n*layer_type = LAYER_RDMAP|RDMAP_REMOTE_PROT;\r\nif ((opcode == T3_SEND_WITH_INV) ||\r\n(opcode == T3_SEND_WITH_SE_INV))\r\n*ecode = RDMAP_CANT_INV_STAG;\r\nelse\r\n*ecode = RDMAP_STAG_NOT_ASSOC;\r\nbreak;\r\ncase TPT_ERR_QPID:\r\n*layer_type = LAYER_RDMAP|RDMAP_REMOTE_PROT;\r\n*ecode = RDMAP_STAG_NOT_ASSOC;\r\nbreak;\r\ncase TPT_ERR_ACCESS:\r\n*layer_type = LAYER_RDMAP|RDMAP_REMOTE_PROT;\r\n*ecode = RDMAP_ACC_VIOL;\r\nbreak;\r\ncase TPT_ERR_WRAP:\r\n*layer_type = LAYER_RDMAP|RDMAP_REMOTE_PROT;\r\n*ecode = RDMAP_TO_WRAP;\r\nbreak;\r\ncase TPT_ERR_BOUND:\r\nif (tagged) {\r\n*layer_type = LAYER_DDP|DDP_TAGGED_ERR;\r\n*ecode = DDPT_BASE_BOUNDS;\r\n} else {\r\n*layer_type = LAYER_RDMAP|RDMAP_REMOTE_PROT;\r\n*ecode = RDMAP_BASE_BOUNDS;\r\n}\r\nbreak;\r\ncase TPT_ERR_INVALIDATE_SHARED_MR:\r\ncase TPT_ERR_INVALIDATE_MR_WITH_MW_BOUND:\r\n*layer_type = LAYER_RDMAP|RDMAP_REMOTE_OP;\r\n*ecode = RDMAP_CANT_INV_STAG;\r\nbreak;\r\ncase TPT_ERR_ECC:\r\ncase TPT_ERR_ECC_PSTAG:\r\ncase TPT_ERR_INTERNAL_ERR:\r\n*layer_type = LAYER_RDMAP|RDMAP_LOCAL_CATA;\r\n*ecode = 0;\r\nbreak;\r\ncase TPT_ERR_OUT_OF_RQE:\r\n*layer_type = LAYER_DDP|DDP_UNTAGGED_ERR;\r\n*ecode = DDPU_INV_MSN_NOBUF;\r\nbreak;\r\ncase TPT_ERR_PBL_ADDR_BOUND:\r\n*layer_type = LAYER_DDP|DDP_TAGGED_ERR;\r\n*ecode = DDPT_BASE_BOUNDS;\r\nbreak;\r\ncase TPT_ERR_CRC:\r\n*layer_type = LAYER_MPA|DDP_LLP;\r\n*ecode = MPA_CRC_ERR;\r\nbreak;\r\ncase TPT_ERR_MARKER:\r\n*layer_type = LAYER_MPA|DDP_LLP;\r\n*ecode = MPA_MARKER_ERR;\r\nbreak;\r\ncase TPT_ERR_PDU_LEN_ERR:\r\n*layer_type = LAYER_DDP|DDP_UNTAGGED_ERR;\r\n*ecode = DDPU_MSG_TOOBIG;\r\nbreak;\r\ncase TPT_ERR_DDP_VERSION:\r\nif (tagged) {\r\n*layer_type = LAYER_DDP|DDP_TAGGED_ERR;\r\n*ecode = DDPT_INV_VERS;\r\n} else {\r\n*layer_type = LAYER_DDP|DDP_UNTAGGED_ERR;\r\n*ecode = DDPU_INV_VERS;\r\n}\r\nbreak;\r\ncase TPT_ERR_RDMA_VERSION:\r\n*layer_type = LAYER_RDMAP|RDMAP_REMOTE_OP;\r\n*ecode = RDMAP_INV_VERS;\r\nbreak;\r\ncase TPT_ERR_OPCODE:\r\n*layer_type = LAYER_RDMAP|RDMAP_REMOTE_OP;\r\n*ecode = RDMAP_INV_OPCODE;\r\nbreak;\r\ncase TPT_ERR_DDP_QUEUE_NUM:\r\n*layer_type = LAYER_DDP|DDP_UNTAGGED_ERR;\r\n*ecode = DDPU_INV_QN;\r\nbreak;\r\ncase TPT_ERR_MSN:\r\ncase TPT_ERR_MSN_GAP:\r\ncase TPT_ERR_MSN_RANGE:\r\ncase TPT_ERR_IRD_OVERFLOW:\r\n*layer_type = LAYER_DDP|DDP_UNTAGGED_ERR;\r\n*ecode = DDPU_INV_MSN_RANGE;\r\nbreak;\r\ncase TPT_ERR_TBIT:\r\n*layer_type = LAYER_DDP|DDP_LOCAL_CATA;\r\n*ecode = 0;\r\nbreak;\r\ncase TPT_ERR_MO:\r\n*layer_type = LAYER_DDP|DDP_UNTAGGED_ERR;\r\n*ecode = DDPU_INV_MO;\r\nbreak;\r\ndefault:\r\n*layer_type = LAYER_RDMAP|DDP_LOCAL_CATA;\r\n*ecode = 0;\r\nbreak;\r\n}\r\n}\r\nint iwch_post_zb_read(struct iwch_ep *ep)\r\n{\r\nunion t3_wr *wqe;\r\nstruct sk_buff *skb;\r\nu8 flit_cnt = sizeof(struct t3_rdma_read_wr) >> 3;\r\npr_debug("%s enter\n", __func__);\r\nskb = alloc_skb(40, GFP_KERNEL);\r\nif (!skb) {\r\npr_err("%s cannot send zb_read!!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nwqe = skb_put_zero(skb, sizeof(struct t3_rdma_read_wr));\r\nwqe->read.rdmaop = T3_READ_REQ;\r\nwqe->read.reserved[0] = 0;\r\nwqe->read.reserved[1] = 0;\r\nwqe->read.rem_stag = cpu_to_be32(1);\r\nwqe->read.rem_to = cpu_to_be64(1);\r\nwqe->read.local_stag = cpu_to_be32(1);\r\nwqe->read.local_len = cpu_to_be32(0);\r\nwqe->read.local_to = cpu_to_be64(1);\r\nwqe->send.wrh.op_seop_flags = cpu_to_be32(V_FW_RIWR_OP(T3_WR_READ));\r\nwqe->send.wrh.gen_tid_len = cpu_to_be32(V_FW_RIWR_TID(ep->hwtid)|\r\nV_FW_RIWR_LEN(flit_cnt));\r\nskb->priority = CPL_PRIORITY_DATA;\r\nreturn iwch_cxgb3_ofld_send(ep->com.qp->rhp->rdev.t3cdev_p, skb);\r\n}\r\nint iwch_post_terminate(struct iwch_qp *qhp, struct respQ_msg_t *rsp_msg)\r\n{\r\nunion t3_wr *wqe;\r\nstruct terminate_message *term;\r\nstruct sk_buff *skb;\r\npr_debug("%s %d\n", __func__, __LINE__);\r\nskb = alloc_skb(40, GFP_ATOMIC);\r\nif (!skb) {\r\npr_err("%s cannot send TERMINATE!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nwqe = skb_put_zero(skb, 40);\r\nwqe->send.rdmaop = T3_TERMINATE;\r\nwqe->send.plen = htonl(4);\r\nterm = (struct terminate_message *)wqe->send.sgl;\r\nbuild_term_codes(rsp_msg, &term->layer_etype, &term->ecode);\r\nwqe->send.wrh.op_seop_flags = cpu_to_be32(V_FW_RIWR_OP(T3_WR_SEND) |\r\nV_FW_RIWR_FLAGS(T3_COMPLETION_FLAG | T3_NOTIFY_FLAG));\r\nwqe->send.wrh.gen_tid_len = cpu_to_be32(V_FW_RIWR_TID(qhp->ep->hwtid));\r\nskb->priority = CPL_PRIORITY_DATA;\r\nreturn iwch_cxgb3_ofld_send(qhp->rhp->rdev.t3cdev_p, skb);\r\n}\r\nstatic void __flush_qp(struct iwch_qp *qhp, struct iwch_cq *rchp,\r\nstruct iwch_cq *schp)\r\n{\r\nint count;\r\nint flushed;\r\npr_debug("%s qhp %p rchp %p schp %p\n", __func__, qhp, rchp, schp);\r\natomic_inc(&qhp->refcnt);\r\nspin_unlock(&qhp->lock);\r\nspin_lock(&rchp->lock);\r\nspin_lock(&qhp->lock);\r\ncxio_flush_hw_cq(&rchp->cq);\r\ncxio_count_rcqes(&rchp->cq, &qhp->wq, &count);\r\nflushed = cxio_flush_rq(&qhp->wq, &rchp->cq, count);\r\nspin_unlock(&qhp->lock);\r\nspin_unlock(&rchp->lock);\r\nif (flushed) {\r\nspin_lock(&rchp->comp_handler_lock);\r\n(*rchp->ibcq.comp_handler)(&rchp->ibcq, rchp->ibcq.cq_context);\r\nspin_unlock(&rchp->comp_handler_lock);\r\n}\r\nspin_lock(&schp->lock);\r\nspin_lock(&qhp->lock);\r\ncxio_flush_hw_cq(&schp->cq);\r\ncxio_count_scqes(&schp->cq, &qhp->wq, &count);\r\nflushed = cxio_flush_sq(&qhp->wq, &schp->cq, count);\r\nspin_unlock(&qhp->lock);\r\nspin_unlock(&schp->lock);\r\nif (flushed) {\r\nspin_lock(&schp->comp_handler_lock);\r\n(*schp->ibcq.comp_handler)(&schp->ibcq, schp->ibcq.cq_context);\r\nspin_unlock(&schp->comp_handler_lock);\r\n}\r\nif (atomic_dec_and_test(&qhp->refcnt))\r\nwake_up(&qhp->wait);\r\nspin_lock(&qhp->lock);\r\n}\r\nstatic void flush_qp(struct iwch_qp *qhp)\r\n{\r\nstruct iwch_cq *rchp, *schp;\r\nrchp = get_chp(qhp->rhp, qhp->attr.rcq);\r\nschp = get_chp(qhp->rhp, qhp->attr.scq);\r\nif (qhp->ibqp.uobject) {\r\ncxio_set_wq_in_error(&qhp->wq);\r\ncxio_set_cq_in_error(&rchp->cq);\r\nspin_lock(&rchp->comp_handler_lock);\r\n(*rchp->ibcq.comp_handler)(&rchp->ibcq, rchp->ibcq.cq_context);\r\nspin_unlock(&rchp->comp_handler_lock);\r\nif (schp != rchp) {\r\ncxio_set_cq_in_error(&schp->cq);\r\nspin_lock(&schp->comp_handler_lock);\r\n(*schp->ibcq.comp_handler)(&schp->ibcq,\r\nschp->ibcq.cq_context);\r\nspin_unlock(&schp->comp_handler_lock);\r\n}\r\nreturn;\r\n}\r\n__flush_qp(qhp, rchp, schp);\r\n}\r\nu16 iwch_rqes_posted(struct iwch_qp *qhp)\r\n{\r\nunion t3_wr *wqe = qhp->wq.queue;\r\nu16 count = 0;\r\nwhile (count < USHRT_MAX && fw_riwrh_opcode((struct fw_riwrh *)wqe) == T3_WR_RCV) {\r\ncount++;\r\nwqe++;\r\n}\r\npr_debug("%s qhp %p count %u\n", __func__, qhp, count);\r\nreturn count;\r\n}\r\nstatic int rdma_init(struct iwch_dev *rhp, struct iwch_qp *qhp,\r\nenum iwch_qp_attr_mask mask,\r\nstruct iwch_qp_attributes *attrs)\r\n{\r\nstruct t3_rdma_init_attr init_attr;\r\nint ret;\r\ninit_attr.tid = qhp->ep->hwtid;\r\ninit_attr.qpid = qhp->wq.qpid;\r\ninit_attr.pdid = qhp->attr.pd;\r\ninit_attr.scqid = qhp->attr.scq;\r\ninit_attr.rcqid = qhp->attr.rcq;\r\ninit_attr.rq_addr = qhp->wq.rq_addr;\r\ninit_attr.rq_size = 1 << qhp->wq.rq_size_log2;\r\ninit_attr.mpaattrs = uP_RI_MPA_IETF_ENABLE |\r\nqhp->attr.mpa_attr.recv_marker_enabled |\r\n(qhp->attr.mpa_attr.xmit_marker_enabled << 1) |\r\n(qhp->attr.mpa_attr.crc_enabled << 2);\r\ninit_attr.qpcaps = uP_RI_QP_RDMA_READ_ENABLE |\r\nuP_RI_QP_RDMA_WRITE_ENABLE |\r\nuP_RI_QP_BIND_ENABLE;\r\nif (!qhp->ibqp.uobject)\r\ninit_attr.qpcaps |= uP_RI_QP_STAG0_ENABLE |\r\nuP_RI_QP_FAST_REGISTER_ENABLE;\r\ninit_attr.tcp_emss = qhp->ep->emss;\r\ninit_attr.ord = qhp->attr.max_ord;\r\ninit_attr.ird = qhp->attr.max_ird;\r\ninit_attr.qp_dma_addr = qhp->wq.dma_addr;\r\ninit_attr.qp_dma_size = (1UL << qhp->wq.size_log2);\r\ninit_attr.rqe_count = iwch_rqes_posted(qhp);\r\ninit_attr.flags = qhp->attr.mpa_attr.initiator ? MPA_INITIATOR : 0;\r\ninit_attr.chan = qhp->ep->l2t->smt_idx;\r\nif (peer2peer) {\r\ninit_attr.rtr_type = RTR_READ;\r\nif (init_attr.ord == 0 && qhp->attr.mpa_attr.initiator)\r\ninit_attr.ord = 1;\r\nif (init_attr.ird == 0 && !qhp->attr.mpa_attr.initiator)\r\ninit_attr.ird = 1;\r\n} else\r\ninit_attr.rtr_type = 0;\r\ninit_attr.irs = qhp->ep->rcv_seq;\r\npr_debug("%s init_attr.rq_addr 0x%x init_attr.rq_size = %d flags 0x%x qpcaps 0x%x\n",\r\n__func__,\r\ninit_attr.rq_addr, init_attr.rq_size,\r\ninit_attr.flags, init_attr.qpcaps);\r\nret = cxio_rdma_init(&rhp->rdev, &init_attr);\r\npr_debug("%s ret %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint iwch_modify_qp(struct iwch_dev *rhp, struct iwch_qp *qhp,\r\nenum iwch_qp_attr_mask mask,\r\nstruct iwch_qp_attributes *attrs,\r\nint internal)\r\n{\r\nint ret = 0;\r\nstruct iwch_qp_attributes newattr = qhp->attr;\r\nunsigned long flag;\r\nint disconnect = 0;\r\nint terminate = 0;\r\nint abort = 0;\r\nint free = 0;\r\nstruct iwch_ep *ep = NULL;\r\npr_debug("%s qhp %p qpid 0x%x ep %p state %d -> %d\n", __func__,\r\nqhp, qhp->wq.qpid, qhp->ep, qhp->attr.state,\r\n(mask & IWCH_QP_ATTR_NEXT_STATE) ? attrs->next_state : -1);\r\nspin_lock_irqsave(&qhp->lock, flag);\r\nif (mask & IWCH_QP_ATTR_VALID_MODIFY) {\r\nif (qhp->attr.state != IWCH_QP_STATE_IDLE) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (mask & IWCH_QP_ATTR_ENABLE_RDMA_READ)\r\nnewattr.enable_rdma_read = attrs->enable_rdma_read;\r\nif (mask & IWCH_QP_ATTR_ENABLE_RDMA_WRITE)\r\nnewattr.enable_rdma_write = attrs->enable_rdma_write;\r\nif (mask & IWCH_QP_ATTR_ENABLE_RDMA_BIND)\r\nnewattr.enable_bind = attrs->enable_bind;\r\nif (mask & IWCH_QP_ATTR_MAX_ORD) {\r\nif (attrs->max_ord >\r\nrhp->attr.max_rdma_read_qp_depth) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nnewattr.max_ord = attrs->max_ord;\r\n}\r\nif (mask & IWCH_QP_ATTR_MAX_IRD) {\r\nif (attrs->max_ird >\r\nrhp->attr.max_rdma_reads_per_qp) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nnewattr.max_ird = attrs->max_ird;\r\n}\r\nqhp->attr = newattr;\r\n}\r\nif (!(mask & IWCH_QP_ATTR_NEXT_STATE))\r\ngoto out;\r\nif (qhp->attr.state == attrs->next_state)\r\ngoto out;\r\nswitch (qhp->attr.state) {\r\ncase IWCH_QP_STATE_IDLE:\r\nswitch (attrs->next_state) {\r\ncase IWCH_QP_STATE_RTS:\r\nif (!(mask & IWCH_QP_ATTR_LLP_STREAM_HANDLE)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (!(mask & IWCH_QP_ATTR_MPA_ATTR)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nqhp->attr.mpa_attr = attrs->mpa_attr;\r\nqhp->attr.llp_stream_handle = attrs->llp_stream_handle;\r\nqhp->ep = qhp->attr.llp_stream_handle;\r\nqhp->attr.state = IWCH_QP_STATE_RTS;\r\nget_ep(&qhp->ep->com);\r\nspin_unlock_irqrestore(&qhp->lock, flag);\r\nret = rdma_init(rhp, qhp, mask, attrs);\r\nspin_lock_irqsave(&qhp->lock, flag);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ncase IWCH_QP_STATE_ERROR:\r\nqhp->attr.state = IWCH_QP_STATE_ERROR;\r\nflush_qp(qhp);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nbreak;\r\ncase IWCH_QP_STATE_RTS:\r\nswitch (attrs->next_state) {\r\ncase IWCH_QP_STATE_CLOSING:\r\nBUG_ON(kref_read(&qhp->ep->com.kref) < 2);\r\nqhp->attr.state = IWCH_QP_STATE_CLOSING;\r\nif (!internal) {\r\nabort=0;\r\ndisconnect = 1;\r\nep = qhp->ep;\r\nget_ep(&ep->com);\r\n}\r\nbreak;\r\ncase IWCH_QP_STATE_TERMINATE:\r\nqhp->attr.state = IWCH_QP_STATE_TERMINATE;\r\nif (qhp->ibqp.uobject)\r\ncxio_set_wq_in_error(&qhp->wq);\r\nif (!internal)\r\nterminate = 1;\r\nbreak;\r\ncase IWCH_QP_STATE_ERROR:\r\nqhp->attr.state = IWCH_QP_STATE_ERROR;\r\nif (!internal) {\r\nabort=1;\r\ndisconnect = 1;\r\nep = qhp->ep;\r\nget_ep(&ep->com);\r\n}\r\ngoto err;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nbreak;\r\ncase IWCH_QP_STATE_CLOSING:\r\nif (!internal) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (attrs->next_state) {\r\ncase IWCH_QP_STATE_IDLE:\r\nflush_qp(qhp);\r\nqhp->attr.state = IWCH_QP_STATE_IDLE;\r\nqhp->attr.llp_stream_handle = NULL;\r\nput_ep(&qhp->ep->com);\r\nqhp->ep = NULL;\r\nwake_up(&qhp->wait);\r\nbreak;\r\ncase IWCH_QP_STATE_ERROR:\r\ngoto err;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nbreak;\r\ncase IWCH_QP_STATE_ERROR:\r\nif (attrs->next_state != IWCH_QP_STATE_IDLE) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (!Q_EMPTY(qhp->wq.sq_rptr, qhp->wq.sq_wptr) ||\r\n!Q_EMPTY(qhp->wq.rq_rptr, qhp->wq.rq_wptr)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nqhp->attr.state = IWCH_QP_STATE_IDLE;\r\nbreak;\r\ncase IWCH_QP_STATE_TERMINATE:\r\nif (!internal) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ngoto err;\r\nbreak;\r\ndefault:\r\npr_err("%s in a bad state %d\n", __func__, qhp->attr.state);\r\nret = -EINVAL;\r\ngoto err;\r\nbreak;\r\n}\r\ngoto out;\r\nerr:\r\npr_debug("%s disassociating ep %p qpid 0x%x\n", __func__, qhp->ep,\r\nqhp->wq.qpid);\r\nqhp->attr.llp_stream_handle = NULL;\r\nep = qhp->ep;\r\nqhp->ep = NULL;\r\nqhp->attr.state = IWCH_QP_STATE_ERROR;\r\nfree=1;\r\nwake_up(&qhp->wait);\r\nBUG_ON(!ep);\r\nflush_qp(qhp);\r\nout:\r\nspin_unlock_irqrestore(&qhp->lock, flag);\r\nif (terminate)\r\niwch_post_terminate(qhp, NULL);\r\nif (disconnect) {\r\niwch_ep_disconnect(ep, abort, GFP_KERNEL);\r\nput_ep(&ep->com);\r\n}\r\nif (free)\r\nput_ep(&ep->com);\r\npr_debug("%s exit state %d\n", __func__, qhp->attr.state);\r\nreturn ret;\r\n}
