static char *__strtolower(char *s)\r\n{\r\nchar *p;\r\nfor (p = s; *p; p++)\r\n*p = tolower(*p);\r\nreturn s;\r\n}\r\nstatic void __iomem *__map_region(const char *name)\r\n{\r\nstruct device_node *np;\r\nvoid __iomem *ptr;\r\nnp = of_find_compatible_node(NULL, NULL, name);\r\nif (!np)\r\nreturn NULL;\r\nptr = of_iomap(np, 0);\r\nof_node_put(np);\r\nreturn ptr;\r\n}\r\nstatic int __issue_avs_command(struct private_data *priv, int cmd, bool is_send,\r\nu32 args[])\r\n{\r\nunsigned long time_left = msecs_to_jiffies(AVS_TIMEOUT);\r\nvoid __iomem *base = priv->base;\r\nunsigned int i;\r\nint ret;\r\nu32 val;\r\nret = down_interruptible(&priv->sem);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0, val = 1; val != 0 && i < AVS_LOOP_LIMIT; i++)\r\nval = readl(base + AVS_MBOX_COMMAND);\r\nif (i == AVS_LOOP_LIMIT) {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nwritel(AVS_STATUS_CLEAR, base + AVS_MBOX_STATUS);\r\nif (args && is_send) {\r\nfor (i = 0; i < AVS_MAX_CMD_ARGS; i++)\r\nwritel(args[i], base + AVS_MBOX_PARAM(i));\r\n}\r\nreinit_completion(&priv->done);\r\nwritel(cmd, base + AVS_MBOX_COMMAND);\r\nwritel(AVS_CPU_L2_INT_MASK, priv->avs_intr_base + AVS_CPU_L2_SET0);\r\ntime_left = wait_for_completion_timeout(&priv->done, time_left);\r\nval = readl(base + AVS_MBOX_STATUS);\r\nif (time_left == 0 || val == 0 || val > AVS_STATUS_MAX) {\r\ndev_err(priv->dev, "AVS command %#x didn't complete in time\n",\r\ncmd);\r\ndev_err(priv->dev, " Time left: %u ms, AVS status: %#x\n",\r\njiffies_to_msecs(time_left), val);\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nif (args && !is_send) {\r\nfor (i = 0; i < AVS_MAX_CMD_ARGS; i++)\r\nargs[i] = readl(base + AVS_MBOX_PARAM(i));\r\n}\r\nwritel(AVS_STATUS_CLEAR, base + AVS_MBOX_STATUS);\r\nswitch (val) {\r\ncase AVS_STATUS_INVALID:\r\nret = -EINVAL;\r\nbreak;\r\ncase AVS_STATUS_NO_SUPP:\r\nret = -ENOTSUPP;\r\nbreak;\r\ncase AVS_STATUS_NO_MAP:\r\nret = -ENOENT;\r\nbreak;\r\ncase AVS_STATUS_MAP_SET:\r\nret = -EEXIST;\r\nbreak;\r\ncase AVS_STATUS_FAILURE:\r\nret = -EIO;\r\nbreak;\r\n}\r\nout:\r\nup(&priv->sem);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t irq_handler(int irq, void *data)\r\n{\r\nstruct private_data *priv = data;\r\ncomplete(&priv->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic char *brcm_avs_mode_to_string(unsigned int mode)\r\n{\r\nswitch (mode) {\r\ncase AVS_MODE_AVS:\r\nreturn "AVS";\r\ncase AVS_MODE_DFS:\r\nreturn "DFS";\r\ncase AVS_MODE_DVS:\r\nreturn "DVS";\r\ncase AVS_MODE_DVFS:\r\nreturn "DVFS";\r\n}\r\nreturn NULL;\r\n}\r\nstatic void brcm_avs_parse_p1(u32 p1, unsigned int *mdiv_p0, unsigned int *pdiv,\r\nunsigned int *ndiv)\r\n{\r\n*mdiv_p0 = (p1 >> MDIV_P0_SHIFT) & MDIV_P0_MASK;\r\n*pdiv = (p1 >> PDIV_SHIFT) & PDIV_MASK;\r\n*ndiv = (p1 >> NDIV_INT_SHIFT) & NDIV_INT_MASK;\r\n}\r\nstatic void brcm_avs_parse_p2(u32 p2, unsigned int *mdiv_p1,\r\nunsigned int *mdiv_p2, unsigned int *mdiv_p3,\r\nunsigned int *mdiv_p4)\r\n{\r\n*mdiv_p4 = (p2 >> MDIV_P4_SHIFT) & MDIV_P4_MASK;\r\n*mdiv_p3 = (p2 >> MDIV_P3_SHIFT) & MDIV_P3_MASK;\r\n*mdiv_p2 = (p2 >> MDIV_P2_SHIFT) & MDIV_P2_MASK;\r\n*mdiv_p1 = (p2 >> MDIV_P1_SHIFT) & MDIV_P1_MASK;\r\n}\r\nstatic int brcm_avs_get_pmap(struct private_data *priv, struct pmap *pmap)\r\n{\r\nu32 args[AVS_MAX_CMD_ARGS];\r\nint ret;\r\nret = __issue_avs_command(priv, AVS_CMD_GET_PMAP, false, args);\r\nif (ret || !pmap)\r\nreturn ret;\r\npmap->mode = args[0];\r\npmap->p1 = args[1];\r\npmap->p2 = args[2];\r\npmap->state = args[3];\r\nreturn 0;\r\n}\r\nstatic int brcm_avs_set_pmap(struct private_data *priv, struct pmap *pmap)\r\n{\r\nu32 args[AVS_MAX_CMD_ARGS];\r\nargs[0] = pmap->mode;\r\nargs[1] = pmap->p1;\r\nargs[2] = pmap->p2;\r\nargs[3] = pmap->state;\r\nreturn __issue_avs_command(priv, AVS_CMD_SET_PMAP, true, args);\r\n}\r\nstatic int brcm_avs_get_pstate(struct private_data *priv, unsigned int *pstate)\r\n{\r\nu32 args[AVS_MAX_CMD_ARGS];\r\nint ret;\r\nret = __issue_avs_command(priv, AVS_CMD_GET_PSTATE, false, args);\r\nif (ret)\r\nreturn ret;\r\n*pstate = args[0];\r\nreturn 0;\r\n}\r\nstatic int brcm_avs_set_pstate(struct private_data *priv, unsigned int pstate)\r\n{\r\nu32 args[AVS_MAX_CMD_ARGS];\r\nargs[0] = pstate;\r\nreturn __issue_avs_command(priv, AVS_CMD_SET_PSTATE, true, args);\r\n}\r\nstatic unsigned long brcm_avs_get_voltage(void __iomem *base)\r\n{\r\nreturn readl(base + AVS_MBOX_VOLTAGE1);\r\n}\r\nstatic unsigned long brcm_avs_get_frequency(void __iomem *base)\r\n{\r\nreturn readl(base + AVS_MBOX_FREQUENCY) * 1000;\r\n}\r\nstatic struct cpufreq_frequency_table *\r\nbrcm_avs_get_freq_table(struct device *dev, struct private_data *priv)\r\n{\r\nstruct cpufreq_frequency_table *table;\r\nunsigned int pstate;\r\nint i, ret;\r\nret = brcm_avs_get_pstate(priv, &pstate);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\ntable = devm_kzalloc(dev, (AVS_PSTATE_MAX + 1) * sizeof(*table),\r\nGFP_KERNEL);\r\nif (!table)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = AVS_PSTATE_P0; i <= AVS_PSTATE_MAX; i++) {\r\nret = brcm_avs_set_pstate(priv, i);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\ntable[i].frequency = brcm_avs_get_frequency(priv->base);\r\ntable[i].driver_data = i;\r\n}\r\ntable[i].frequency = CPUFREQ_TABLE_END;\r\nret = brcm_avs_set_pstate(priv, pstate);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn table;\r\n}\r\nstatic int brcm_avs_debug_show(struct seq_file *s, void *data)\r\n{\r\nstruct debugfs_data *dbgfs = s->private;\r\nvoid __iomem *base;\r\nu32 val, offset;\r\nif (!dbgfs) {\r\nseq_puts(s, "No device pointer\n");\r\nreturn 0;\r\n}\r\nbase = dbgfs->priv->base;\r\noffset = dbgfs->entry->offset;\r\nval = readl(base + offset);\r\nswitch (dbgfs->entry->format) {\r\ncase DEBUGFS_NORMAL:\r\nseq_printf(s, "%u\n", val);\r\nbreak;\r\ncase DEBUGFS_FLOAT:\r\nseq_printf(s, "%d.%03d\n", MANT(val), FRAC(val));\r\nbreak;\r\ncase DEBUGFS_REV:\r\nseq_printf(s, "%c.%c.%c.%c\n", (val >> 24 & 0xff),\r\n(val >> 16 & 0xff), (val >> 8 & 0xff),\r\nval & 0xff);\r\nbreak;\r\n}\r\nseq_printf(s, "0x%08x\n", val);\r\nreturn 0;\r\n}\r\nstatic ssize_t brcm_avs_seq_write(struct file *file, const char __user *buf,\r\nsize_t size, loff_t *ppos)\r\n{\r\nstruct seq_file *s = file->private_data;\r\nstruct debugfs_data *dbgfs = s->private;\r\nstruct private_data *priv = dbgfs->priv;\r\nvoid __iomem *base, *avs_intr_base;\r\nbool use_issue_command = false;\r\nunsigned long val, offset;\r\nchar str[128];\r\nint ret;\r\nchar *str_ptr = str;\r\nif (size >= sizeof(str))\r\nreturn -E2BIG;\r\nmemset(str, 0, sizeof(str));\r\nret = copy_from_user(str, buf, size);\r\nif (ret)\r\nreturn ret;\r\nbase = priv->base;\r\navs_intr_base = priv->avs_intr_base;\r\noffset = dbgfs->entry->offset;\r\nif (str_ptr[0] == 'c' && offset == AVS_MBOX_COMMAND) {\r\nuse_issue_command = true;\r\nstr_ptr++;\r\n}\r\nif (kstrtoul(str_ptr, 0, &val) != 0)\r\nreturn -EINVAL;\r\nif (val == AVS_CMD_SET_PSTATE) {\r\nstruct cpufreq_policy *policy;\r\nunsigned int pstate;\r\npolicy = cpufreq_cpu_get(smp_processor_id());\r\npstate = readl(base + AVS_MBOX_PARAM(0));\r\nif (use_issue_command) {\r\nret = brcm_avs_target_index(policy, pstate);\r\nreturn ret ? ret : size;\r\n}\r\npolicy->cur = policy->freq_table[pstate].frequency;\r\n}\r\nif (use_issue_command) {\r\nret = __issue_avs_command(priv, val, false, NULL);\r\n} else {\r\nret = down_interruptible(&priv->sem);\r\nif (ret)\r\nreturn ret;\r\nwritel(val, base + offset);\r\nif (offset == AVS_MBOX_COMMAND)\r\nwritel(AVS_CPU_L2_INT_MASK,\r\navs_intr_base + AVS_CPU_L2_SET0);\r\nup(&priv->sem);\r\n}\r\nreturn ret ? ret : size;\r\n}\r\nstatic struct debugfs_entry *__find_debugfs_entry(const char *name)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(debugfs_entries); i++)\r\nif (strcasecmp(debugfs_entries[i].name, name) == 0)\r\nreturn &debugfs_entries[i];\r\nreturn NULL;\r\n}\r\nstatic int brcm_avs_debug_open(struct inode *inode, struct file *file)\r\n{\r\nstruct debugfs_data *data;\r\nfmode_t fmode;\r\nint ret;\r\nfmode = file->f_mode;\r\nif ((fmode & FMODE_WRITER) && !(inode->i_mode & S_IWUSR))\r\nreturn -EACCES;\r\ndata = kmalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->entry = __find_debugfs_entry(file->f_path.dentry->d_iname);\r\ndata->priv = inode->i_private;\r\nret = single_open(file, brcm_avs_debug_show, data);\r\nif (ret)\r\nkfree(data);\r\nfile->f_mode = fmode;\r\nreturn ret;\r\n}\r\nstatic int brcm_avs_debug_release(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq_priv = file->private_data;\r\nstruct debugfs_data *data = seq_priv->private;\r\nkfree(data);\r\nreturn single_release(inode, file);\r\n}\r\nstatic void brcm_avs_cpufreq_debug_init(struct platform_device *pdev)\r\n{\r\nstruct private_data *priv = platform_get_drvdata(pdev);\r\nstruct dentry *dir;\r\nint i;\r\nif (!priv)\r\nreturn;\r\ndir = debugfs_create_dir(BRCM_AVS_CPUFREQ_NAME, NULL);\r\nif (IS_ERR_OR_NULL(dir))\r\nreturn;\r\npriv->debugfs = dir;\r\nfor (i = 0; i < ARRAY_SIZE(debugfs_entries); i++) {\r\nchar *entry = __strtolower(debugfs_entries[i].name);\r\nfmode_t mode = debugfs_entries[i].mode;\r\nif (!debugfs_create_file(entry, S_IFREG | S_IRUGO | mode,\r\ndir, priv, &brcm_avs_debug_ops)) {\r\npriv->debugfs = NULL;\r\ndebugfs_remove_recursive(dir);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void brcm_avs_cpufreq_debug_exit(struct platform_device *pdev)\r\n{\r\nstruct private_data *priv = platform_get_drvdata(pdev);\r\nif (priv && priv->debugfs) {\r\ndebugfs_remove_recursive(priv->debugfs);\r\npriv->debugfs = NULL;\r\n}\r\n}\r\nstatic void brcm_avs_cpufreq_debug_init(struct platform_device *pdev) {}\r\nstatic void brcm_avs_cpufreq_debug_exit(struct platform_device *pdev) {}\r\nstatic bool brcm_avs_is_firmware_loaded(struct private_data *priv)\r\n{\r\nu32 magic;\r\nint rc;\r\nrc = brcm_avs_get_pmap(priv, NULL);\r\nmagic = readl(priv->base + AVS_MBOX_MAGIC);\r\nreturn (magic == AVS_FIRMWARE_MAGIC) && (rc != -ENOTSUPP) &&\r\n(rc != -EINVAL);\r\n}\r\nstatic unsigned int brcm_avs_cpufreq_get(unsigned int cpu)\r\n{\r\nstruct cpufreq_policy *policy = cpufreq_cpu_get(cpu);\r\nstruct private_data *priv = policy->driver_data;\r\nreturn brcm_avs_get_frequency(priv->base);\r\n}\r\nstatic int brcm_avs_target_index(struct cpufreq_policy *policy,\r\nunsigned int index)\r\n{\r\nreturn brcm_avs_set_pstate(policy->driver_data,\r\npolicy->freq_table[index].driver_data);\r\n}\r\nstatic int brcm_avs_suspend(struct cpufreq_policy *policy)\r\n{\r\nstruct private_data *priv = policy->driver_data;\r\nint ret;\r\nret = brcm_avs_get_pmap(priv, &priv->pmap);\r\nif (ret)\r\nreturn ret;\r\nreturn brcm_avs_get_pstate(priv, &priv->pmap.state);\r\n}\r\nstatic int brcm_avs_resume(struct cpufreq_policy *policy)\r\n{\r\nstruct private_data *priv = policy->driver_data;\r\nint ret;\r\nret = brcm_avs_set_pmap(priv, &priv->pmap);\r\nif (ret == -EEXIST) {\r\nstruct platform_device *pdev = cpufreq_get_driver_data();\r\nstruct device *dev = &pdev->dev;\r\ndev_warn(dev, "PMAP was already set\n");\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int brcm_avs_prepare_init(struct platform_device *pdev)\r\n{\r\nstruct private_data *priv;\r\nstruct device *dev;\r\nint host_irq, ret;\r\ndev = &pdev->dev;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->dev = dev;\r\nsema_init(&priv->sem, 1);\r\ninit_completion(&priv->done);\r\nplatform_set_drvdata(pdev, priv);\r\npriv->base = __map_region(BRCM_AVS_CPU_DATA);\r\nif (!priv->base) {\r\ndev_err(dev, "Couldn't find property %s in device tree.\n",\r\nBRCM_AVS_CPU_DATA);\r\nreturn -ENOENT;\r\n}\r\npriv->avs_intr_base = __map_region(BRCM_AVS_CPU_INTR);\r\nif (!priv->avs_intr_base) {\r\ndev_err(dev, "Couldn't find property %s in device tree.\n",\r\nBRCM_AVS_CPU_INTR);\r\nret = -ENOENT;\r\ngoto unmap_base;\r\n}\r\nhost_irq = platform_get_irq_byname(pdev, BRCM_AVS_HOST_INTR);\r\nif (host_irq < 0) {\r\ndev_err(dev, "Couldn't find interrupt %s -- %d\n",\r\nBRCM_AVS_HOST_INTR, host_irq);\r\nret = host_irq;\r\ngoto unmap_intr_base;\r\n}\r\nret = devm_request_irq(dev, host_irq, irq_handler, IRQF_TRIGGER_RISING,\r\nBRCM_AVS_HOST_INTR, priv);\r\nif (ret) {\r\ndev_err(dev, "IRQ request failed: %s (%d) -- %d\n",\r\nBRCM_AVS_HOST_INTR, host_irq, ret);\r\ngoto unmap_intr_base;\r\n}\r\nif (brcm_avs_is_firmware_loaded(priv))\r\nreturn 0;\r\ndev_err(dev, "AVS firmware is not loaded or doesn't support DVFS\n");\r\nret = -ENODEV;\r\nunmap_intr_base:\r\niounmap(priv->avs_intr_base);\r\nunmap_base:\r\niounmap(priv->base);\r\nreturn ret;\r\n}\r\nstatic int brcm_avs_cpufreq_init(struct cpufreq_policy *policy)\r\n{\r\nstruct cpufreq_frequency_table *freq_table;\r\nstruct platform_device *pdev;\r\nstruct private_data *priv;\r\nstruct device *dev;\r\nint ret;\r\npdev = cpufreq_get_driver_data();\r\npriv = platform_get_drvdata(pdev);\r\npolicy->driver_data = priv;\r\ndev = &pdev->dev;\r\nfreq_table = brcm_avs_get_freq_table(dev, priv);\r\nif (IS_ERR(freq_table)) {\r\nret = PTR_ERR(freq_table);\r\ndev_err(dev, "Couldn't determine frequency table (%d).\n", ret);\r\nreturn ret;\r\n}\r\nret = cpufreq_table_validate_and_show(policy, freq_table);\r\nif (ret) {\r\ndev_err(dev, "invalid frequency table: %d\n", ret);\r\nreturn ret;\r\n}\r\ncpumask_setall(policy->cpus);\r\nret = __issue_avs_command(priv, AVS_CMD_ENABLE, false, NULL);\r\nif (!ret) {\r\nunsigned int pstate;\r\nret = brcm_avs_get_pstate(priv, &pstate);\r\nif (!ret) {\r\npolicy->cur = freq_table[pstate].frequency;\r\ndev_info(dev, "registered\n");\r\nreturn 0;\r\n}\r\n}\r\ndev_err(dev, "couldn't initialize driver (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_brcm_avs_pstate(struct cpufreq_policy *policy, char *buf)\r\n{\r\nstruct private_data *priv = policy->driver_data;\r\nunsigned int pstate;\r\nif (brcm_avs_get_pstate(priv, &pstate))\r\nreturn sprintf(buf, "<unknown>\n");\r\nreturn sprintf(buf, "%u\n", pstate);\r\n}\r\nstatic ssize_t show_brcm_avs_mode(struct cpufreq_policy *policy, char *buf)\r\n{\r\nstruct private_data *priv = policy->driver_data;\r\nstruct pmap pmap;\r\nif (brcm_avs_get_pmap(priv, &pmap))\r\nreturn sprintf(buf, "<unknown>\n");\r\nreturn sprintf(buf, "%s %u\n", brcm_avs_mode_to_string(pmap.mode),\r\npmap.mode);\r\n}\r\nstatic ssize_t show_brcm_avs_pmap(struct cpufreq_policy *policy, char *buf)\r\n{\r\nunsigned int mdiv_p0, mdiv_p1, mdiv_p2, mdiv_p3, mdiv_p4;\r\nstruct private_data *priv = policy->driver_data;\r\nunsigned int ndiv, pdiv;\r\nstruct pmap pmap;\r\nif (brcm_avs_get_pmap(priv, &pmap))\r\nreturn sprintf(buf, "<unknown>\n");\r\nbrcm_avs_parse_p1(pmap.p1, &mdiv_p0, &pdiv, &ndiv);\r\nbrcm_avs_parse_p2(pmap.p2, &mdiv_p1, &mdiv_p2, &mdiv_p3, &mdiv_p4);\r\nreturn sprintf(buf, "0x%08x 0x%08x %u %u %u %u %u %u %u %u %u\n",\r\npmap.p1, pmap.p2, ndiv, pdiv, mdiv_p0, mdiv_p1, mdiv_p2,\r\nmdiv_p3, mdiv_p4, pmap.mode, pmap.state);\r\n}\r\nstatic ssize_t show_brcm_avs_voltage(struct cpufreq_policy *policy, char *buf)\r\n{\r\nstruct private_data *priv = policy->driver_data;\r\nreturn sprintf(buf, "0x%08lx\n", brcm_avs_get_voltage(priv->base));\r\n}\r\nstatic ssize_t show_brcm_avs_frequency(struct cpufreq_policy *policy, char *buf)\r\n{\r\nstruct private_data *priv = policy->driver_data;\r\nreturn sprintf(buf, "0x%08lx\n", brcm_avs_get_frequency(priv->base));\r\n}\r\nstatic int brcm_avs_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nret = brcm_avs_prepare_init(pdev);\r\nif (ret)\r\nreturn ret;\r\nbrcm_avs_driver.driver_data = pdev;\r\nret = cpufreq_register_driver(&brcm_avs_driver);\r\nif (!ret)\r\nbrcm_avs_cpufreq_debug_init(pdev);\r\nreturn ret;\r\n}\r\nstatic int brcm_avs_cpufreq_remove(struct platform_device *pdev)\r\n{\r\nstruct private_data *priv;\r\nint ret;\r\nret = cpufreq_unregister_driver(&brcm_avs_driver);\r\nif (ret)\r\nreturn ret;\r\nbrcm_avs_cpufreq_debug_exit(pdev);\r\npriv = platform_get_drvdata(pdev);\r\niounmap(priv->base);\r\niounmap(priv->avs_intr_base);\r\nreturn 0;\r\n}
