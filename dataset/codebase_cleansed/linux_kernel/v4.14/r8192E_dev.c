void rtl92e_start_beacon(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nstruct rtllib_network *net = &priv->rtllib->current_network;\r\nu16 BcnTimeCfg = 0;\r\nu16 BcnCW = 6;\r\nu16 BcnIFS = 0xf;\r\nrtl92e_irq_disable(dev);\r\nrtl92e_writew(dev, ATIMWND, 2);\r\nrtl92e_writew(dev, BCN_INTERVAL, net->beacon_interval);\r\nrtl92e_writew(dev, BCN_DRV_EARLY_INT, 10);\r\nrtl92e_writew(dev, BCN_DMATIME, 256);\r\nrtl92e_writeb(dev, BCN_ERR_THRESH, 100);\r\nBcnTimeCfg |= BcnCW<<BCN_TCFG_CW_SHIFT;\r\nBcnTimeCfg |= BcnIFS<<BCN_TCFG_IFS;\r\nrtl92e_writew(dev, BCN_TCFG, BcnTimeCfg);\r\nrtl92e_irq_enable(dev);\r\n}\r\nstatic void _rtl92e_update_msr(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 msr;\r\nenum led_ctl_mode LedAction = LED_CTL_NO_LINK;\r\nmsr = rtl92e_readb(dev, MSR);\r\nmsr &= ~MSR_LINK_MASK;\r\nswitch (priv->rtllib->iw_mode) {\r\ncase IW_MODE_INFRA:\r\nif (priv->rtllib->state == RTLLIB_LINKED)\r\nmsr |= (MSR_LINK_MANAGED << MSR_LINK_SHIFT);\r\nelse\r\nmsr |= (MSR_LINK_NONE << MSR_LINK_SHIFT);\r\nLedAction = LED_CTL_LINK;\r\nbreak;\r\ncase IW_MODE_ADHOC:\r\nif (priv->rtllib->state == RTLLIB_LINKED)\r\nmsr |= (MSR_LINK_ADHOC << MSR_LINK_SHIFT);\r\nelse\r\nmsr |= (MSR_LINK_NONE << MSR_LINK_SHIFT);\r\nbreak;\r\ncase IW_MODE_MASTER:\r\nif (priv->rtllib->state == RTLLIB_LINKED)\r\nmsr |= (MSR_LINK_MASTER << MSR_LINK_SHIFT);\r\nelse\r\nmsr |= (MSR_LINK_NONE << MSR_LINK_SHIFT);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nrtl92e_writeb(dev, MSR, msr);\r\nif (priv->rtllib->LedControlHandler)\r\npriv->rtllib->LedControlHandler(dev, LedAction);\r\n}\r\nvoid rtl92e_set_reg(struct net_device *dev, u8 variable, u8 *val)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nswitch (variable) {\r\ncase HW_VAR_BSSID:\r\nrtl92e_writew(dev, BSSIDR, *(u16 *)val);\r\nrtl92e_writel(dev, BSSIDR + 2, *(u32 *)(val + 2));\r\nbreak;\r\ncase HW_VAR_MEDIA_STATUS:\r\n{\r\nenum rt_op_mode OpMode = *((enum rt_op_mode *)(val));\r\nu8 btMsr = rtl92e_readb(dev, MSR);\r\nbtMsr &= 0xfc;\r\nswitch (OpMode) {\r\ncase RT_OP_MODE_INFRASTRUCTURE:\r\nbtMsr |= MSR_INFRA;\r\nbreak;\r\ncase RT_OP_MODE_IBSS:\r\nbtMsr |= MSR_ADHOC;\r\nbreak;\r\ncase RT_OP_MODE_AP:\r\nbtMsr |= MSR_AP;\r\nbreak;\r\ndefault:\r\nbtMsr |= MSR_NOLINK;\r\nbreak;\r\n}\r\nrtl92e_writeb(dev, MSR, btMsr);\r\n}\r\nbreak;\r\ncase HW_VAR_CECHK_BSSID:\r\n{\r\nu32 RegRCR, Type;\r\nType = val[0];\r\nRegRCR = rtl92e_readl(dev, RCR);\r\npriv->ReceiveConfig = RegRCR;\r\nif (Type == true)\r\nRegRCR |= (RCR_CBSSID);\r\nelse if (Type == false)\r\nRegRCR &= (~RCR_CBSSID);\r\nrtl92e_writel(dev, RCR, RegRCR);\r\npriv->ReceiveConfig = RegRCR;\r\n}\r\nbreak;\r\ncase HW_VAR_SLOT_TIME:\r\npriv->slot_time = val[0];\r\nrtl92e_writeb(dev, SLOT_TIME, val[0]);\r\nbreak;\r\ncase HW_VAR_ACK_PREAMBLE:\r\n{\r\nu32 regTmp;\r\npriv->short_preamble = (bool)*val;\r\nregTmp = priv->basic_rate;\r\nif (priv->short_preamble)\r\nregTmp |= BRSR_AckShortPmb;\r\nrtl92e_writel(dev, RRSR, regTmp);\r\nbreak;\r\n}\r\ncase HW_VAR_CPU_RST:\r\nrtl92e_writel(dev, CPU_GEN, ((u32 *)(val))[0]);\r\nbreak;\r\ncase HW_VAR_AC_PARAM:\r\n{\r\nu8 pAcParam = *val;\r\nu32 eACI = pAcParam;\r\nu8 u1bAIFS;\r\nu32 u4bAcParam;\r\nu8 mode = priv->rtllib->mode;\r\nstruct rtllib_qos_parameters *qop =\r\n&priv->rtllib->current_network.qos_data.parameters;\r\nu1bAIFS = qop->aifs[pAcParam] *\r\n((mode&(IEEE_G|IEEE_N_24G)) ? 9 : 20) + aSifsTime;\r\nrtl92e_dm_init_edca_turbo(dev);\r\nu4bAcParam = (le16_to_cpu(qop->tx_op_limit[pAcParam]) <<\r\nAC_PARAM_TXOP_LIMIT_OFFSET) |\r\n((le16_to_cpu(qop->cw_max[pAcParam])) <<\r\nAC_PARAM_ECW_MAX_OFFSET) |\r\n((le16_to_cpu(qop->cw_min[pAcParam])) <<\r\nAC_PARAM_ECW_MIN_OFFSET) |\r\n(((u32)u1bAIFS) << AC_PARAM_AIFS_OFFSET);\r\nRT_TRACE(COMP_DBG, "%s():HW_VAR_AC_PARAM eACI:%x:%x\n",\r\n__func__, eACI, u4bAcParam);\r\nswitch (eACI) {\r\ncase AC1_BK:\r\nrtl92e_writel(dev, EDCAPARA_BK, u4bAcParam);\r\nbreak;\r\ncase AC0_BE:\r\nrtl92e_writel(dev, EDCAPARA_BE, u4bAcParam);\r\nbreak;\r\ncase AC2_VI:\r\nrtl92e_writel(dev, EDCAPARA_VI, u4bAcParam);\r\nbreak;\r\ncase AC3_VO:\r\nrtl92e_writel(dev, EDCAPARA_VO, u4bAcParam);\r\nbreak;\r\ndefault:\r\nnetdev_info(dev, "SetHwReg8185(): invalid ACI: %d !\n",\r\neACI);\r\nbreak;\r\n}\r\npriv->rtllib->SetHwRegHandler(dev, HW_VAR_ACM_CTRL,\r\n&pAcParam);\r\nbreak;\r\n}\r\ncase HW_VAR_ACM_CTRL:\r\n{\r\nstruct rtllib_qos_parameters *qos_parameters =\r\n&priv->rtllib->current_network.qos_data.parameters;\r\nu8 pAcParam = *val;\r\nu32 eACI = pAcParam;\r\nunion aci_aifsn *pAciAifsn = (union aci_aifsn *) &\r\n(qos_parameters->aifs[0]);\r\nu8 acm = pAciAifsn->f.acm;\r\nu8 AcmCtrl = rtl92e_readb(dev, AcmHwCtrl);\r\nRT_TRACE(COMP_DBG, "===========>%s():HW_VAR_ACM_CTRL:%x\n",\r\n__func__, eACI);\r\nAcmCtrl = AcmCtrl | ((priv->AcmMethod == 2) ? 0x0 : 0x1);\r\nif (acm) {\r\nswitch (eACI) {\r\ncase AC0_BE:\r\nAcmCtrl |= AcmHw_BeqEn;\r\nbreak;\r\ncase AC2_VI:\r\nAcmCtrl |= AcmHw_ViqEn;\r\nbreak;\r\ncase AC3_VO:\r\nAcmCtrl |= AcmHw_VoqEn;\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_QOS,\r\n"SetHwReg8185(): [HW_VAR_ACM_CTRL] acm set failed: eACI is %d\n",\r\neACI);\r\nbreak;\r\n}\r\n} else {\r\nswitch (eACI) {\r\ncase AC0_BE:\r\nAcmCtrl &= (~AcmHw_BeqEn);\r\nbreak;\r\ncase AC2_VI:\r\nAcmCtrl &= (~AcmHw_ViqEn);\r\nbreak;\r\ncase AC3_VO:\r\nAcmCtrl &= (~AcmHw_BeqEn);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nRT_TRACE(COMP_QOS,\r\n"SetHwReg8190pci(): [HW_VAR_ACM_CTRL] Write 0x%X\n",\r\nAcmCtrl);\r\nrtl92e_writeb(dev, AcmHwCtrl, AcmCtrl);\r\nbreak;\r\n}\r\ncase HW_VAR_SIFS:\r\nrtl92e_writeb(dev, SIFS, val[0]);\r\nrtl92e_writeb(dev, SIFS+1, val[0]);\r\nbreak;\r\ncase HW_VAR_RF_TIMING:\r\n{\r\nu8 Rf_Timing = *val;\r\nrtl92e_writeb(dev, rFPGA0_RFTiming1, Rf_Timing);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void _rtl92e_read_eeprom_info(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nconst u8 bMac_Tmp_Addr[ETH_ALEN] = {0x00, 0xe0, 0x4c, 0x00, 0x00, 0x01};\r\nu8 tempval;\r\nu8 ICVer8192, ICVer8256;\r\nu16 i, usValue, IC_Version;\r\nu16 EEPROMId;\r\nRT_TRACE(COMP_INIT, "====> _rtl92e_read_eeprom_info\n");\r\nEEPROMId = rtl92e_eeprom_read(dev, 0);\r\nif (EEPROMId != RTL8190_EEPROM_ID) {\r\nnetdev_err(dev, "%s(): Invalid EEPROM ID: %x\n", __func__,\r\nEEPROMId);\r\npriv->AutoloadFailFlag = true;\r\n} else {\r\npriv->AutoloadFailFlag = false;\r\n}\r\nif (!priv->AutoloadFailFlag) {\r\npriv->eeprom_vid = rtl92e_eeprom_read(dev, EEPROM_VID >> 1);\r\npriv->eeprom_did = rtl92e_eeprom_read(dev, EEPROM_DID >> 1);\r\nusValue = rtl92e_eeprom_read(dev,\r\n(u16)(EEPROM_Customer_ID>>1)) >> 8;\r\npriv->eeprom_CustomerID = (u8)(usValue & 0xff);\r\nusValue = rtl92e_eeprom_read(dev,\r\nEEPROM_ICVersion_ChannelPlan>>1);\r\npriv->eeprom_ChannelPlan = usValue&0xff;\r\nIC_Version = (usValue & 0xff00)>>8;\r\nICVer8192 = (IC_Version&0xf);\r\nICVer8256 = (IC_Version & 0xf0)>>4;\r\nRT_TRACE(COMP_INIT, "\nICVer8192 = 0x%x\n", ICVer8192);\r\nRT_TRACE(COMP_INIT, "\nICVer8256 = 0x%x\n", ICVer8256);\r\nif (ICVer8192 == 0x2) {\r\nif (ICVer8256 == 0x5)\r\npriv->card_8192_version = VERSION_8190_BE;\r\n}\r\nswitch (priv->card_8192_version) {\r\ncase VERSION_8190_BD:\r\ncase VERSION_8190_BE:\r\nbreak;\r\ndefault:\r\npriv->card_8192_version = VERSION_8190_BD;\r\nbreak;\r\n}\r\nRT_TRACE(COMP_INIT, "\nIC Version = 0x%x\n",\r\npriv->card_8192_version);\r\n} else {\r\npriv->card_8192_version = VERSION_8190_BD;\r\npriv->eeprom_vid = 0;\r\npriv->eeprom_did = 0;\r\npriv->eeprom_CustomerID = 0;\r\npriv->eeprom_ChannelPlan = 0;\r\nRT_TRACE(COMP_INIT, "\nIC Version = 0x%x\n", 0xff);\r\n}\r\nRT_TRACE(COMP_INIT, "EEPROM VID = 0x%4x\n", priv->eeprom_vid);\r\nRT_TRACE(COMP_INIT, "EEPROM DID = 0x%4x\n", priv->eeprom_did);\r\nRT_TRACE(COMP_INIT, "EEPROM Customer ID: 0x%2x\n",\r\npriv->eeprom_CustomerID);\r\nif (!priv->AutoloadFailFlag) {\r\nfor (i = 0; i < 6; i += 2) {\r\nusValue = rtl92e_eeprom_read(dev,\r\n(EEPROM_NODE_ADDRESS_BYTE_0 + i) >> 1);\r\n*(u16 *)(&dev->dev_addr[i]) = usValue;\r\n}\r\n} else {\r\nether_addr_copy(dev->dev_addr, bMac_Tmp_Addr);\r\n}\r\nRT_TRACE(COMP_INIT, "Permanent Address = %pM\n",\r\ndev->dev_addr);\r\nif (priv->card_8192_version > VERSION_8190_BD)\r\npriv->bTXPowerDataReadFromEEPORM = true;\r\nelse\r\npriv->bTXPowerDataReadFromEEPORM = false;\r\npriv->rf_type = RTL819X_DEFAULT_RF_TYPE;\r\nif (priv->card_8192_version > VERSION_8190_BD) {\r\nif (!priv->AutoloadFailFlag) {\r\ntempval = (rtl92e_eeprom_read(dev,\r\n(EEPROM_RFInd_PowerDiff >> 1))) & 0xff;\r\npriv->EEPROMLegacyHTTxPowerDiff = tempval & 0xf;\r\nif (tempval&0x80)\r\npriv->rf_type = RF_1T2R;\r\nelse\r\npriv->rf_type = RF_2T4R;\r\n} else {\r\npriv->EEPROMLegacyHTTxPowerDiff = 0x04;\r\n}\r\nRT_TRACE(COMP_INIT, "EEPROMLegacyHTTxPowerDiff = %d\n",\r\npriv->EEPROMLegacyHTTxPowerDiff);\r\nif (!priv->AutoloadFailFlag)\r\npriv->EEPROMThermalMeter = (u8)(((rtl92e_eeprom_read(dev,\r\n(EEPROM_ThermalMeter>>1))) &\r\n0xff00)>>8);\r\nelse\r\npriv->EEPROMThermalMeter = EEPROM_Default_ThermalMeter;\r\nRT_TRACE(COMP_INIT, "ThermalMeter = %d\n",\r\npriv->EEPROMThermalMeter);\r\npriv->TSSI_13dBm = priv->EEPROMThermalMeter * 100;\r\nif (priv->epromtype == EEPROM_93C46) {\r\nif (!priv->AutoloadFailFlag) {\r\nusValue = rtl92e_eeprom_read(dev,\r\nEEPROM_TxPwDiff_CrystalCap >> 1);\r\npriv->EEPROMAntPwDiff = (usValue&0x0fff);\r\npriv->EEPROMCrystalCap = (u8)((usValue & 0xf000)\r\n>> 12);\r\n} else {\r\npriv->EEPROMAntPwDiff =\r\nEEPROM_Default_AntTxPowerDiff;\r\npriv->EEPROMCrystalCap =\r\nEEPROM_Default_TxPwDiff_CrystalCap;\r\n}\r\nRT_TRACE(COMP_INIT, "EEPROMAntPwDiff = %d\n",\r\npriv->EEPROMAntPwDiff);\r\nRT_TRACE(COMP_INIT, "EEPROMCrystalCap = %d\n",\r\npriv->EEPROMCrystalCap);\r\nfor (i = 0; i < 14; i += 2) {\r\nif (!priv->AutoloadFailFlag)\r\nusValue = rtl92e_eeprom_read(dev,\r\n(EEPROM_TxPwIndex_CCK + i) >> 1);\r\nelse\r\nusValue = EEPROM_Default_TxPower;\r\n*((u16 *)(&priv->EEPROMTxPowerLevelCCK[i])) =\r\nusValue;\r\nRT_TRACE(COMP_INIT,\r\n"CCK Tx Power Level, Index %d = 0x%02x\n",\r\ni, priv->EEPROMTxPowerLevelCCK[i]);\r\nRT_TRACE(COMP_INIT,\r\n"CCK Tx Power Level, Index %d = 0x%02x\n",\r\ni+1, priv->EEPROMTxPowerLevelCCK[i+1]);\r\n}\r\nfor (i = 0; i < 14; i += 2) {\r\nif (!priv->AutoloadFailFlag)\r\nusValue = rtl92e_eeprom_read(dev,\r\n(EEPROM_TxPwIndex_OFDM_24G + i) >> 1);\r\nelse\r\nusValue = EEPROM_Default_TxPower;\r\n*((u16 *)(&priv->EEPROMTxPowerLevelOFDM24G[i]))\r\n= usValue;\r\nRT_TRACE(COMP_INIT,\r\n"OFDM 2.4G Tx Power Level, Index %d = 0x%02x\n",\r\ni, priv->EEPROMTxPowerLevelOFDM24G[i]);\r\nRT_TRACE(COMP_INIT,\r\n"OFDM 2.4G Tx Power Level, Index %d = 0x%02x\n",\r\ni + 1,\r\npriv->EEPROMTxPowerLevelOFDM24G[i+1]);\r\n}\r\n}\r\nif (priv->epromtype == EEPROM_93C46) {\r\nfor (i = 0; i < 14; i++) {\r\npriv->TxPowerLevelCCK[i] =\r\npriv->EEPROMTxPowerLevelCCK[i];\r\npriv->TxPowerLevelOFDM24G[i] =\r\npriv->EEPROMTxPowerLevelOFDM24G[i];\r\n}\r\npriv->LegacyHTTxPowerDiff =\r\npriv->EEPROMLegacyHTTxPowerDiff;\r\npriv->AntennaTxPwDiff[0] = (priv->EEPROMAntPwDiff &\r\n0xf);\r\npriv->AntennaTxPwDiff[1] = (priv->EEPROMAntPwDiff &\r\n0xf0) >> 4;\r\npriv->AntennaTxPwDiff[2] = (priv->EEPROMAntPwDiff &\r\n0xf00) >> 8;\r\npriv->CrystalCap = priv->EEPROMCrystalCap;\r\npriv->ThermalMeter[0] = (priv->EEPROMThermalMeter &\r\n0xf);\r\npriv->ThermalMeter[1] = (priv->EEPROMThermalMeter &\r\n0xf0) >> 4;\r\n} else if (priv->epromtype == EEPROM_93C56) {\r\nfor (i = 0; i < 3; i++) {\r\npriv->TxPowerLevelCCK_A[i] =\r\npriv->EEPROMRfACCKChnl1TxPwLevel[0];\r\npriv->TxPowerLevelOFDM24G_A[i] =\r\npriv->EEPROMRfAOfdmChnlTxPwLevel[0];\r\npriv->TxPowerLevelCCK_C[i] =\r\npriv->EEPROMRfCCCKChnl1TxPwLevel[0];\r\npriv->TxPowerLevelOFDM24G_C[i] =\r\npriv->EEPROMRfCOfdmChnlTxPwLevel[0];\r\n}\r\nfor (i = 3; i < 9; i++) {\r\npriv->TxPowerLevelCCK_A[i] =\r\npriv->EEPROMRfACCKChnl1TxPwLevel[1];\r\npriv->TxPowerLevelOFDM24G_A[i] =\r\npriv->EEPROMRfAOfdmChnlTxPwLevel[1];\r\npriv->TxPowerLevelCCK_C[i] =\r\npriv->EEPROMRfCCCKChnl1TxPwLevel[1];\r\npriv->TxPowerLevelOFDM24G_C[i] =\r\npriv->EEPROMRfCOfdmChnlTxPwLevel[1];\r\n}\r\nfor (i = 9; i < 14; i++) {\r\npriv->TxPowerLevelCCK_A[i] =\r\npriv->EEPROMRfACCKChnl1TxPwLevel[2];\r\npriv->TxPowerLevelOFDM24G_A[i] =\r\npriv->EEPROMRfAOfdmChnlTxPwLevel[2];\r\npriv->TxPowerLevelCCK_C[i] =\r\npriv->EEPROMRfCCCKChnl1TxPwLevel[2];\r\npriv->TxPowerLevelOFDM24G_C[i] =\r\npriv->EEPROMRfCOfdmChnlTxPwLevel[2];\r\n}\r\nfor (i = 0; i < 14; i++)\r\nRT_TRACE(COMP_INIT,\r\n"priv->TxPowerLevelCCK_A[%d] = 0x%x\n",\r\ni, priv->TxPowerLevelCCK_A[i]);\r\nfor (i = 0; i < 14; i++)\r\nRT_TRACE(COMP_INIT,\r\n"priv->TxPowerLevelOFDM24G_A[%d] = 0x%x\n",\r\ni, priv->TxPowerLevelOFDM24G_A[i]);\r\nfor (i = 0; i < 14; i++)\r\nRT_TRACE(COMP_INIT,\r\n"priv->TxPowerLevelCCK_C[%d] = 0x%x\n",\r\ni, priv->TxPowerLevelCCK_C[i]);\r\nfor (i = 0; i < 14; i++)\r\nRT_TRACE(COMP_INIT,\r\n"priv->TxPowerLevelOFDM24G_C[%d] = 0x%x\n",\r\ni, priv->TxPowerLevelOFDM24G_C[i]);\r\npriv->LegacyHTTxPowerDiff =\r\npriv->EEPROMLegacyHTTxPowerDiff;\r\npriv->AntennaTxPwDiff[0] = 0;\r\npriv->AntennaTxPwDiff[1] = 0;\r\npriv->AntennaTxPwDiff[2] = 0;\r\npriv->CrystalCap = priv->EEPROMCrystalCap;\r\npriv->ThermalMeter[0] = (priv->EEPROMThermalMeter &\r\n0xf);\r\npriv->ThermalMeter[1] = (priv->EEPROMThermalMeter &\r\n0xf0) >> 4;\r\n}\r\n}\r\nif (priv->rf_type == RF_1T2R) {\r\nRT_TRACE(COMP_INIT, "\n1T2R config\n");\r\n} else if (priv->rf_type == RF_2T4R) {\r\nRT_TRACE(COMP_INIT, "\n2T4R config\n");\r\n}\r\nrtl92e_init_adaptive_rate(dev);\r\npriv->rf_chip = RF_8256;\r\nif (priv->RegChannelPlan == 0xf)\r\npriv->ChannelPlan = priv->eeprom_ChannelPlan;\r\nelse\r\npriv->ChannelPlan = priv->RegChannelPlan;\r\nif (priv->eeprom_vid == 0x1186 && priv->eeprom_did == 0x3304)\r\npriv->CustomerID = RT_CID_DLINK;\r\nswitch (priv->eeprom_CustomerID) {\r\ncase EEPROM_CID_DEFAULT:\r\npriv->CustomerID = RT_CID_DEFAULT;\r\nbreak;\r\ncase EEPROM_CID_CAMEO:\r\npriv->CustomerID = RT_CID_819x_CAMEO;\r\nbreak;\r\ncase EEPROM_CID_RUNTOP:\r\npriv->CustomerID = RT_CID_819x_RUNTOP;\r\nbreak;\r\ncase EEPROM_CID_NetCore:\r\npriv->CustomerID = RT_CID_819x_Netcore;\r\nbreak;\r\ncase EEPROM_CID_TOSHIBA:\r\npriv->CustomerID = RT_CID_TOSHIBA;\r\nif (priv->eeprom_ChannelPlan&0x80)\r\npriv->ChannelPlan = priv->eeprom_ChannelPlan&0x7f;\r\nelse\r\npriv->ChannelPlan = 0x0;\r\nRT_TRACE(COMP_INIT, "Toshiba ChannelPlan = 0x%x\n",\r\npriv->ChannelPlan);\r\nbreak;\r\ncase EEPROM_CID_Nettronix:\r\npriv->ScanDelay = 100;\r\npriv->CustomerID = RT_CID_Nettronix;\r\nbreak;\r\ncase EEPROM_CID_Pronet:\r\npriv->CustomerID = RT_CID_PRONET;\r\nbreak;\r\ncase EEPROM_CID_DLINK:\r\npriv->CustomerID = RT_CID_DLINK;\r\nbreak;\r\ncase EEPROM_CID_WHQL:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (priv->ChannelPlan > CHANNEL_PLAN_LEN - 1)\r\npriv->ChannelPlan = 0;\r\npriv->ChannelPlan = COUNTRY_CODE_WORLD_WIDE_13;\r\nif (priv->eeprom_vid == 0x1186 && priv->eeprom_did == 0x3304)\r\npriv->rtllib->bSupportRemoteWakeUp = true;\r\nelse\r\npriv->rtllib->bSupportRemoteWakeUp = false;\r\nRT_TRACE(COMP_INIT, "RegChannelPlan(%d)\n", priv->RegChannelPlan);\r\nRT_TRACE(COMP_INIT, "ChannelPlan = %d\n", priv->ChannelPlan);\r\nRT_TRACE(COMP_TRACE, "<==== ReadAdapterInfo\n");\r\n}\r\nvoid rtl92e_get_eeprom_size(struct net_device *dev)\r\n{\r\nu16 curCR;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nRT_TRACE(COMP_INIT, "===========>%s()\n", __func__);\r\ncurCR = rtl92e_readw(dev, EPROM_CMD);\r\nRT_TRACE(COMP_INIT, "read from Reg Cmd9346CR(%x):%x\n", EPROM_CMD,\r\ncurCR);\r\npriv->epromtype = (curCR & EPROM_CMD_9356SEL) ? EEPROM_93C56 :\r\nEEPROM_93C46;\r\nRT_TRACE(COMP_INIT, "<===========%s(), epromtype:%d\n", __func__,\r\npriv->epromtype);\r\n_rtl92e_read_eeprom_info(dev);\r\n}\r\nstatic void _rtl92e_hwconfig(struct net_device *dev)\r\n{\r\nu32 regRATR = 0, regRRSR = 0;\r\nu8 regBwOpMode = 0, regTmp = 0;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nswitch (priv->rtllib->mode) {\r\ncase WIRELESS_MODE_B:\r\nregBwOpMode = BW_OPMODE_20MHZ;\r\nregRATR = RATE_ALL_CCK;\r\nregRRSR = RATE_ALL_CCK;\r\nbreak;\r\ncase WIRELESS_MODE_A:\r\nregBwOpMode = BW_OPMODE_5G | BW_OPMODE_20MHZ;\r\nregRATR = RATE_ALL_OFDM_AG;\r\nregRRSR = RATE_ALL_OFDM_AG;\r\nbreak;\r\ncase WIRELESS_MODE_G:\r\nregBwOpMode = BW_OPMODE_20MHZ;\r\nregRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\nregRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\nbreak;\r\ncase WIRELESS_MODE_AUTO:\r\ncase WIRELESS_MODE_N_24G:\r\nregBwOpMode = BW_OPMODE_20MHZ;\r\nregRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG |\r\nRATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;\r\nregRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\nbreak;\r\ncase WIRELESS_MODE_N_5G:\r\nregBwOpMode = BW_OPMODE_5G;\r\nregRATR = RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS |\r\nRATE_ALL_OFDM_2SS;\r\nregRRSR = RATE_ALL_OFDM_AG;\r\nbreak;\r\ndefault:\r\nregBwOpMode = BW_OPMODE_20MHZ;\r\nregRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\nregRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\nbreak;\r\n}\r\nrtl92e_writeb(dev, BW_OPMODE, regBwOpMode);\r\n{\r\nu32 ratr_value;\r\nratr_value = regRATR;\r\nif (priv->rf_type == RF_1T2R)\r\nratr_value &= ~(RATE_ALL_OFDM_2SS);\r\nrtl92e_writel(dev, RATR0, ratr_value);\r\nrtl92e_writeb(dev, UFWP, 1);\r\n}\r\nregTmp = rtl92e_readb(dev, 0x313);\r\nregRRSR = ((regTmp) << 24) | (regRRSR & 0x00ffffff);\r\nrtl92e_writel(dev, RRSR, regRRSR);\r\nrtl92e_writew(dev, RETRY_LIMIT,\r\npriv->ShortRetryLimit << RETRY_LIMIT_SHORT_SHIFT |\r\npriv->LongRetryLimit << RETRY_LIMIT_LONG_SHIFT);\r\n}\r\nbool rtl92e_start_adapter(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 ulRegRead;\r\nbool rtStatus = true;\r\nu8 tmpvalue;\r\nu8 ICVersion, SwitchingRegulatorOutput;\r\nbool bfirmwareok = true;\r\nu32 tmpRegA, tmpRegC, TempCCk;\r\nint i = 0;\r\nu32 retry_times = 0;\r\nRT_TRACE(COMP_INIT, "====>%s()\n", __func__);\r\npriv->being_init_adapter = true;\r\nstart:\r\nrtl92e_reset_desc_ring(dev);\r\npriv->Rf_Mode = RF_OP_By_SW_3wire;\r\nif (priv->ResetProgress == RESET_TYPE_NORESET) {\r\nrtl92e_writeb(dev, ANAPAR, 0x37);\r\nmdelay(500);\r\n}\r\npriv->pFirmware->status = FW_STATUS_0_INIT;\r\nif (priv->RegRfOff)\r\npriv->rtllib->eRFPowerState = eRfOff;\r\nulRegRead = rtl92e_readl(dev, CPU_GEN);\r\nif (priv->pFirmware->status == FW_STATUS_0_INIT)\r\nulRegRead |= CPU_GEN_SYSTEM_RESET;\r\nelse if (priv->pFirmware->status == FW_STATUS_5_READY)\r\nulRegRead |= CPU_GEN_FIRMWARE_RESET;\r\nelse\r\nnetdev_err(dev, "%s(): undefined firmware state: %d.\n",\r\n__func__, priv->pFirmware->status);\r\nrtl92e_writel(dev, CPU_GEN, ulRegRead);\r\nICVersion = rtl92e_readb(dev, IC_VERRSION);\r\nif (ICVersion >= 0x4) {\r\nSwitchingRegulatorOutput = rtl92e_readb(dev, SWREGULATOR);\r\nif (SwitchingRegulatorOutput != 0xb8) {\r\nrtl92e_writeb(dev, SWREGULATOR, 0xa8);\r\nmdelay(1);\r\nrtl92e_writeb(dev, SWREGULATOR, 0xb8);\r\n}\r\n}\r\nRT_TRACE(COMP_INIT, "BB Config Start!\n");\r\nrtStatus = rtl92e_config_bb(dev);\r\nif (!rtStatus) {\r\nnetdev_warn(dev, "%s(): Failed to configure BB\n", __func__);\r\nreturn rtStatus;\r\n}\r\nRT_TRACE(COMP_INIT, "BB Config Finished!\n");\r\npriv->LoopbackMode = RTL819X_NO_LOOPBACK;\r\nif (priv->ResetProgress == RESET_TYPE_NORESET) {\r\nulRegRead = rtl92e_readl(dev, CPU_GEN);\r\nif (priv->LoopbackMode == RTL819X_NO_LOOPBACK)\r\nulRegRead = ((ulRegRead & CPU_GEN_NO_LOOPBACK_MSK) |\r\nCPU_GEN_NO_LOOPBACK_SET);\r\nelse if (priv->LoopbackMode == RTL819X_MAC_LOOPBACK)\r\nulRegRead |= CPU_CCK_LOOPBACK;\r\nelse\r\nnetdev_err(dev, "%s: Invalid loopback mode setting.\n",\r\n__func__);\r\nrtl92e_writel(dev, CPU_GEN, ulRegRead);\r\nudelay(500);\r\n}\r\n_rtl92e_hwconfig(dev);\r\nrtl92e_writeb(dev, CMDR, CR_RE | CR_TE);\r\nrtl92e_writeb(dev, PCIF, ((MXDMA2_NoLimit<<MXDMA2_RX_SHIFT) |\r\n(MXDMA2_NoLimit<<MXDMA2_TX_SHIFT)));\r\nrtl92e_writel(dev, MAC0, ((u32 *)dev->dev_addr)[0]);\r\nrtl92e_writew(dev, MAC4, ((u16 *)(dev->dev_addr + 4))[0]);\r\nrtl92e_writel(dev, RCR, priv->ReceiveConfig);\r\nrtl92e_writel(dev, RQPN1, NUM_OF_PAGE_IN_FW_QUEUE_BK <<\r\nRSVD_FW_QUEUE_PAGE_BK_SHIFT |\r\nNUM_OF_PAGE_IN_FW_QUEUE_BE <<\r\nRSVD_FW_QUEUE_PAGE_BE_SHIFT |\r\nNUM_OF_PAGE_IN_FW_QUEUE_VI <<\r\nRSVD_FW_QUEUE_PAGE_VI_SHIFT |\r\nNUM_OF_PAGE_IN_FW_QUEUE_VO <<\r\nRSVD_FW_QUEUE_PAGE_VO_SHIFT);\r\nrtl92e_writel(dev, RQPN2, NUM_OF_PAGE_IN_FW_QUEUE_MGNT <<\r\nRSVD_FW_QUEUE_PAGE_MGNT_SHIFT);\r\nrtl92e_writel(dev, RQPN3, APPLIED_RESERVED_QUEUE_IN_FW |\r\nNUM_OF_PAGE_IN_FW_QUEUE_BCN <<\r\nRSVD_FW_QUEUE_PAGE_BCN_SHIFT|\r\nNUM_OF_PAGE_IN_FW_QUEUE_PUB <<\r\nRSVD_FW_QUEUE_PAGE_PUB_SHIFT);\r\nrtl92e_tx_enable(dev);\r\nrtl92e_rx_enable(dev);\r\nulRegRead = (0xFFF00000 & rtl92e_readl(dev, RRSR)) |\r\nRATE_ALL_OFDM_AG | RATE_ALL_CCK;\r\nrtl92e_writel(dev, RRSR, ulRegRead);\r\nrtl92e_writel(dev, RATR0+4*7, (RATE_ALL_OFDM_AG | RATE_ALL_CCK));\r\nrtl92e_writeb(dev, ACK_TIMEOUT, 0x30);\r\nif (priv->ResetProgress == RESET_TYPE_NORESET)\r\nrtl92e_set_wireless_mode(dev, priv->rtllib->mode);\r\nrtl92e_cam_reset(dev);\r\n{\r\nu8 SECR_value = 0x0;\r\nSECR_value |= SCR_TxEncEnable;\r\nSECR_value |= SCR_RxDecEnable;\r\nSECR_value |= SCR_NoSKMC;\r\nrtl92e_writeb(dev, SECR, SECR_value);\r\n}\r\nrtl92e_writew(dev, ATIMWND, 2);\r\nrtl92e_writew(dev, BCN_INTERVAL, 100);\r\n{\r\nint i;\r\nfor (i = 0; i < QOS_QUEUE_NUM; i++)\r\nrtl92e_writel(dev, WDCAPARA_ADD[i], 0x005e4332);\r\n}\r\nrtl92e_writeb(dev, 0xbe, 0xc0);\r\nrtl92e_config_mac(dev);\r\nif (priv->card_8192_version > (u8) VERSION_8190_BD) {\r\nrtl92e_get_tx_power(dev);\r\nrtl92e_set_tx_power(dev, priv->chan);\r\n}\r\ntmpvalue = rtl92e_readb(dev, IC_VERRSION);\r\npriv->IC_Cut = tmpvalue;\r\nRT_TRACE(COMP_INIT, "priv->IC_Cut= 0x%x\n", priv->IC_Cut);\r\nif (priv->IC_Cut >= IC_VersionCut_D) {\r\nif (priv->IC_Cut == IC_VersionCut_D) {\r\nRT_TRACE(COMP_INIT, "D-cut\n");\r\n} else if (priv->IC_Cut == IC_VersionCut_E) {\r\nRT_TRACE(COMP_INIT, "E-cut\n");\r\n}\r\n} else {\r\nRT_TRACE(COMP_INIT, "Before C-cut\n");\r\n}\r\nRT_TRACE(COMP_INIT, "Load Firmware!\n");\r\nbfirmwareok = rtl92e_init_fw(dev);\r\nif (!bfirmwareok) {\r\nif (retry_times < 10) {\r\nretry_times++;\r\ngoto start;\r\n} else {\r\nrtStatus = false;\r\ngoto end;\r\n}\r\n}\r\nRT_TRACE(COMP_INIT, "Load Firmware finished!\n");\r\nif (priv->ResetProgress == RESET_TYPE_NORESET) {\r\nRT_TRACE(COMP_INIT, "RF Config Started!\n");\r\nrtStatus = rtl92e_config_phy(dev);\r\nif (!rtStatus) {\r\nnetdev_info(dev, "RF Config failed\n");\r\nreturn rtStatus;\r\n}\r\nRT_TRACE(COMP_INIT, "RF Config Finished!\n");\r\n}\r\nrtl92e_set_bb_reg(dev, rFPGA0_RFMOD, bCCKEn, 0x1);\r\nrtl92e_set_bb_reg(dev, rFPGA0_RFMOD, bOFDMEn, 0x1);\r\nrtl92e_writeb(dev, 0x87, 0x0);\r\nif (priv->RegRfOff) {\r\nRT_TRACE((COMP_INIT | COMP_RF | COMP_POWER),\r\n"%s(): Turn off RF for RegRfOff ----------\n",\r\n__func__);\r\nrtl92e_set_rf_state(dev, eRfOff, RF_CHANGE_BY_SW);\r\n} else if (priv->rtllib->RfOffReason > RF_CHANGE_BY_PS) {\r\nRT_TRACE((COMP_INIT|COMP_RF|COMP_POWER),\r\n"%s(): Turn off RF for RfOffReason(%d) ----------\n",\r\n__func__, priv->rtllib->RfOffReason);\r\nrtl92e_set_rf_state(dev, eRfOff, priv->rtllib->RfOffReason);\r\n} else if (priv->rtllib->RfOffReason >= RF_CHANGE_BY_IPS) {\r\nRT_TRACE((COMP_INIT|COMP_RF|COMP_POWER),\r\n"%s(): Turn off RF for RfOffReason(%d) ----------\n",\r\n__func__, priv->rtllib->RfOffReason);\r\nrtl92e_set_rf_state(dev, eRfOff, priv->rtllib->RfOffReason);\r\n} else {\r\nRT_TRACE((COMP_INIT|COMP_RF|COMP_POWER), "%s(): RF-ON\n",\r\n__func__);\r\npriv->rtllib->eRFPowerState = eRfOn;\r\npriv->rtllib->RfOffReason = 0;\r\n}\r\nif (priv->rtllib->FwRWRF)\r\npriv->Rf_Mode = RF_OP_By_FW;\r\nelse\r\npriv->Rf_Mode = RF_OP_By_SW_3wire;\r\nif (priv->ResetProgress == RESET_TYPE_NORESET) {\r\nrtl92e_dm_init_txpower_tracking(dev);\r\nif (priv->IC_Cut >= IC_VersionCut_D) {\r\ntmpRegA = rtl92e_get_bb_reg(dev, rOFDM0_XATxIQImbalance,\r\nbMaskDWord);\r\ntmpRegC = rtl92e_get_bb_reg(dev, rOFDM0_XCTxIQImbalance,\r\nbMaskDWord);\r\nfor (i = 0; i < TxBBGainTableLength; i++) {\r\nif (tmpRegA == dm_tx_bb_gain[i]) {\r\npriv->rfa_txpowertrackingindex = (u8)i;\r\npriv->rfa_txpowertrackingindex_real =\r\n(u8)i;\r\npriv->rfa_txpowertracking_default =\r\npriv->rfa_txpowertrackingindex;\r\nbreak;\r\n}\r\n}\r\nTempCCk = rtl92e_get_bb_reg(dev, rCCK0_TxFilter1,\r\nbMaskByte2);\r\nfor (i = 0; i < CCKTxBBGainTableLength; i++) {\r\nif (TempCCk == dm_cck_tx_bb_gain[i][0]) {\r\npriv->CCKPresentAttentuation_20Mdefault = (u8)i;\r\nbreak;\r\n}\r\n}\r\npriv->CCKPresentAttentuation_40Mdefault = 0;\r\npriv->CCKPresentAttentuation_difference = 0;\r\npriv->CCKPresentAttentuation =\r\npriv->CCKPresentAttentuation_20Mdefault;\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"priv->rfa_txpowertrackingindex_initial = %d\n",\r\npriv->rfa_txpowertrackingindex);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"priv->rfa_txpowertrackingindex_real__initial = %d\n",\r\npriv->rfa_txpowertrackingindex_real);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"priv->CCKPresentAttentuation_difference_initial = %d\n",\r\npriv->CCKPresentAttentuation_difference);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"priv->CCKPresentAttentuation_initial = %d\n",\r\npriv->CCKPresentAttentuation);\r\npriv->btxpower_tracking = false;\r\n}\r\n}\r\nrtl92e_irq_enable(dev);\r\nend:\r\npriv->being_init_adapter = false;\r\nreturn rtStatus;\r\n}\r\nstatic void _rtl92e_net_update(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_network *net;\r\nu16 BcnTimeCfg = 0, BcnCW = 6, BcnIFS = 0xf;\r\nu16 rate_config = 0;\r\nnet = &priv->rtllib->current_network;\r\nrtl92e_config_rate(dev, &rate_config);\r\npriv->dot11CurrentPreambleMode = PREAMBLE_AUTO;\r\npriv->basic_rate = rate_config &= 0x15f;\r\nrtl92e_writew(dev, BSSIDR, *(u16 *)net->bssid);\r\nrtl92e_writel(dev, BSSIDR + 2, *(u32 *)(net->bssid + 2));\r\nif (priv->rtllib->iw_mode == IW_MODE_ADHOC) {\r\nrtl92e_writew(dev, ATIMWND, 2);\r\nrtl92e_writew(dev, BCN_DMATIME, 256);\r\nrtl92e_writew(dev, BCN_INTERVAL, net->beacon_interval);\r\nrtl92e_writew(dev, BCN_DRV_EARLY_INT, 10);\r\nrtl92e_writeb(dev, BCN_ERR_THRESH, 100);\r\nBcnTimeCfg |= (BcnCW<<BCN_TCFG_CW_SHIFT);\r\nBcnTimeCfg |= BcnIFS<<BCN_TCFG_IFS;\r\nrtl92e_writew(dev, BCN_TCFG, BcnTimeCfg);\r\n}\r\n}\r\nvoid rtl92e_link_change(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nif (!priv->up)\r\nreturn;\r\nif (ieee->state == RTLLIB_LINKED) {\r\n_rtl92e_net_update(dev);\r\npriv->ops->update_ratr_table(dev);\r\nif ((ieee->pairwise_key_type == KEY_TYPE_WEP40) ||\r\n(ieee->pairwise_key_type == KEY_TYPE_WEP104))\r\nrtl92e_enable_hw_security_config(dev);\r\n} else {\r\nrtl92e_writeb(dev, 0x173, 0);\r\n}\r\n_rtl92e_update_msr(dev);\r\nif (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC) {\r\nu32 reg;\r\nreg = rtl92e_readl(dev, RCR);\r\nif (priv->rtllib->state == RTLLIB_LINKED) {\r\nif (ieee->IntelPromiscuousModeInfo.bPromiscuousOn)\r\n;\r\nelse\r\npriv->ReceiveConfig = reg |= RCR_CBSSID;\r\n} else\r\npriv->ReceiveConfig = reg &= ~RCR_CBSSID;\r\nrtl92e_writel(dev, RCR, reg);\r\n}\r\n}\r\nvoid rtl92e_set_monitor_mode(struct net_device *dev, bool bAllowAllDA,\r\nbool WriteIntoReg)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (bAllowAllDA)\r\npriv->ReceiveConfig |= RCR_AAP;\r\nelse\r\npriv->ReceiveConfig &= ~RCR_AAP;\r\nif (WriteIntoReg)\r\nrtl92e_writel(dev, RCR, priv->ReceiveConfig);\r\n}\r\nstatic u8 _rtl92e_rate_mgn_to_hw(u8 rate)\r\n{\r\nu8 ret = DESC90_RATE1M;\r\nswitch (rate) {\r\ncase MGN_1M:\r\nret = DESC90_RATE1M;\r\nbreak;\r\ncase MGN_2M:\r\nret = DESC90_RATE2M;\r\nbreak;\r\ncase MGN_5_5M:\r\nret = DESC90_RATE5_5M;\r\nbreak;\r\ncase MGN_11M:\r\nret = DESC90_RATE11M;\r\nbreak;\r\ncase MGN_6M:\r\nret = DESC90_RATE6M;\r\nbreak;\r\ncase MGN_9M:\r\nret = DESC90_RATE9M;\r\nbreak;\r\ncase MGN_12M:\r\nret = DESC90_RATE12M;\r\nbreak;\r\ncase MGN_18M:\r\nret = DESC90_RATE18M;\r\nbreak;\r\ncase MGN_24M:\r\nret = DESC90_RATE24M;\r\nbreak;\r\ncase MGN_36M:\r\nret = DESC90_RATE36M;\r\nbreak;\r\ncase MGN_48M:\r\nret = DESC90_RATE48M;\r\nbreak;\r\ncase MGN_54M:\r\nret = DESC90_RATE54M;\r\nbreak;\r\ncase MGN_MCS0:\r\nret = DESC90_RATEMCS0;\r\nbreak;\r\ncase MGN_MCS1:\r\nret = DESC90_RATEMCS1;\r\nbreak;\r\ncase MGN_MCS2:\r\nret = DESC90_RATEMCS2;\r\nbreak;\r\ncase MGN_MCS3:\r\nret = DESC90_RATEMCS3;\r\nbreak;\r\ncase MGN_MCS4:\r\nret = DESC90_RATEMCS4;\r\nbreak;\r\ncase MGN_MCS5:\r\nret = DESC90_RATEMCS5;\r\nbreak;\r\ncase MGN_MCS6:\r\nret = DESC90_RATEMCS6;\r\nbreak;\r\ncase MGN_MCS7:\r\nret = DESC90_RATEMCS7;\r\nbreak;\r\ncase MGN_MCS8:\r\nret = DESC90_RATEMCS8;\r\nbreak;\r\ncase MGN_MCS9:\r\nret = DESC90_RATEMCS9;\r\nbreak;\r\ncase MGN_MCS10:\r\nret = DESC90_RATEMCS10;\r\nbreak;\r\ncase MGN_MCS11:\r\nret = DESC90_RATEMCS11;\r\nbreak;\r\ncase MGN_MCS12:\r\nret = DESC90_RATEMCS12;\r\nbreak;\r\ncase MGN_MCS13:\r\nret = DESC90_RATEMCS13;\r\nbreak;\r\ncase MGN_MCS14:\r\nret = DESC90_RATEMCS14;\r\nbreak;\r\ncase MGN_MCS15:\r\nret = DESC90_RATEMCS15;\r\nbreak;\r\ncase (0x80|0x20):\r\nret = DESC90_RATEMCS32;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic u8 _rtl92e_hw_queue_to_fw_queue(struct net_device *dev, u8 QueueID,\r\nu8 priority)\r\n{\r\nu8 QueueSelect = 0x0;\r\nswitch (QueueID) {\r\ncase BE_QUEUE:\r\nQueueSelect = QSLT_BE;\r\nbreak;\r\ncase BK_QUEUE:\r\nQueueSelect = QSLT_BK;\r\nbreak;\r\ncase VO_QUEUE:\r\nQueueSelect = QSLT_VO;\r\nbreak;\r\ncase VI_QUEUE:\r\nQueueSelect = QSLT_VI;\r\nbreak;\r\ncase MGNT_QUEUE:\r\nQueueSelect = QSLT_MGNT;\r\nbreak;\r\ncase BEACON_QUEUE:\r\nQueueSelect = QSLT_BEACON;\r\nbreak;\r\ncase TXCMD_QUEUE:\r\nQueueSelect = QSLT_CMD;\r\nbreak;\r\ncase HIGH_QUEUE:\r\nQueueSelect = QSLT_HIGH;\r\nbreak;\r\ndefault:\r\nnetdev_warn(dev, "%s(): Impossible Queue Selection: %d\n",\r\n__func__, QueueID);\r\nbreak;\r\n}\r\nreturn QueueSelect;\r\n}\r\nstatic u8 _rtl92e_query_is_short(u8 TxHT, u8 TxRate, struct cb_desc *tcb_desc)\r\n{\r\nu8 tmp_Short;\r\ntmp_Short = (TxHT == 1) ? ((tcb_desc->bUseShortGI) ? 1 : 0) :\r\n((tcb_desc->bUseShortPreamble) ? 1 : 0);\r\nif (TxHT == 1 && TxRate != DESC90_RATEMCS15)\r\ntmp_Short = 0;\r\nreturn tmp_Short;\r\n}\r\nvoid rtl92e_fill_tx_desc(struct net_device *dev, struct tx_desc *pdesc,\r\nstruct cb_desc *cb_desc, struct sk_buff *skb)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\ndma_addr_t mapping;\r\nstruct tx_fwinfo_8190pci *pTxFwInfo;\r\npTxFwInfo = (struct tx_fwinfo_8190pci *)skb->data;\r\nmemset(pTxFwInfo, 0, sizeof(struct tx_fwinfo_8190pci));\r\npTxFwInfo->TxHT = (cb_desc->data_rate & 0x80) ? 1 : 0;\r\npTxFwInfo->TxRate = _rtl92e_rate_mgn_to_hw((u8)cb_desc->data_rate);\r\npTxFwInfo->EnableCPUDur = cb_desc->bTxEnableFwCalcDur;\r\npTxFwInfo->Short = _rtl92e_query_is_short(pTxFwInfo->TxHT,\r\npTxFwInfo->TxRate, cb_desc);\r\nif (cb_desc->bAMPDUEnable) {\r\npTxFwInfo->AllowAggregation = 1;\r\npTxFwInfo->RxMF = cb_desc->ampdu_factor;\r\npTxFwInfo->RxAMD = cb_desc->ampdu_density;\r\n} else {\r\npTxFwInfo->AllowAggregation = 0;\r\npTxFwInfo->RxMF = 0;\r\npTxFwInfo->RxAMD = 0;\r\n}\r\npTxFwInfo->RtsEnable = (cb_desc->bRTSEnable) ? 1 : 0;\r\npTxFwInfo->CtsEnable = (cb_desc->bCTSEnable) ? 1 : 0;\r\npTxFwInfo->RtsSTBC = (cb_desc->bRTSSTBC) ? 1 : 0;\r\npTxFwInfo->RtsHT = (cb_desc->rts_rate&0x80) ? 1 : 0;\r\npTxFwInfo->RtsRate = _rtl92e_rate_mgn_to_hw((u8)cb_desc->rts_rate);\r\npTxFwInfo->RtsBandwidth = 0;\r\npTxFwInfo->RtsSubcarrier = cb_desc->RTSSC;\r\npTxFwInfo->RtsShort = (pTxFwInfo->RtsHT == 0) ?\r\n(cb_desc->bRTSUseShortPreamble ? 1 : 0) :\r\n(cb_desc->bRTSUseShortGI ? 1 : 0);\r\nif (priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20_40) {\r\nif (cb_desc->bPacketBW) {\r\npTxFwInfo->TxBandwidth = 1;\r\npTxFwInfo->TxSubCarrier = 0;\r\n} else {\r\npTxFwInfo->TxBandwidth = 0;\r\npTxFwInfo->TxSubCarrier = priv->nCur40MhzPrimeSC;\r\n}\r\n} else {\r\npTxFwInfo->TxBandwidth = 0;\r\npTxFwInfo->TxSubCarrier = 0;\r\n}\r\nmemset((u8 *)pdesc, 0, 12);\r\nmapping = pci_map_single(priv->pdev, skb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(priv->pdev, mapping)) {\r\nnetdev_err(dev, "%s(): DMA Mapping error\n", __func__);\r\nreturn;\r\n}\r\npdesc->LINIP = 0;\r\npdesc->CmdInit = 1;\r\npdesc->Offset = sizeof(struct tx_fwinfo_8190pci) + 8;\r\npdesc->PktSize = (u16)skb->len-sizeof(struct tx_fwinfo_8190pci);\r\npdesc->SecCAMID = 0;\r\npdesc->RATid = cb_desc->RATRIndex;\r\npdesc->NoEnc = 1;\r\npdesc->SecType = 0x0;\r\nif (cb_desc->bHwSec) {\r\nstatic u8 tmp;\r\nif (!tmp) {\r\nRT_TRACE(COMP_DBG, "==>================hw sec\n");\r\ntmp = 1;\r\n}\r\nswitch (priv->rtllib->pairwise_key_type) {\r\ncase KEY_TYPE_WEP40:\r\ncase KEY_TYPE_WEP104:\r\npdesc->SecType = 0x1;\r\npdesc->NoEnc = 0;\r\nbreak;\r\ncase KEY_TYPE_TKIP:\r\npdesc->SecType = 0x2;\r\npdesc->NoEnc = 0;\r\nbreak;\r\ncase KEY_TYPE_CCMP:\r\npdesc->SecType = 0x3;\r\npdesc->NoEnc = 0;\r\nbreak;\r\ncase KEY_TYPE_NA:\r\npdesc->SecType = 0x0;\r\npdesc->NoEnc = 1;\r\nbreak;\r\n}\r\n}\r\npdesc->PktId = 0x0;\r\npdesc->QueueSelect = _rtl92e_hw_queue_to_fw_queue(dev,\r\ncb_desc->queue_index,\r\ncb_desc->priority);\r\npdesc->TxFWInfoSize = sizeof(struct tx_fwinfo_8190pci);\r\npdesc->DISFB = cb_desc->bTxDisableRateFallBack;\r\npdesc->USERATE = cb_desc->bTxUseDriverAssingedRate;\r\npdesc->FirstSeg = 1;\r\npdesc->LastSeg = 1;\r\npdesc->TxBufferSize = skb->len;\r\npdesc->TxBuffAddr = mapping;\r\n}\r\nvoid rtl92e_fill_tx_cmd_desc(struct net_device *dev, struct tx_desc_cmd *entry,\r\nstruct cb_desc *cb_desc, struct sk_buff *skb)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\ndma_addr_t mapping = pci_map_single(priv->pdev, skb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(priv->pdev, mapping))\r\nnetdev_err(dev, "%s(): DMA Mapping error\n", __func__);\r\nmemset(entry, 0, 12);\r\nentry->LINIP = cb_desc->bLastIniPkt;\r\nentry->FirstSeg = 1;\r\nentry->LastSeg = 1;\r\nif (cb_desc->bCmdOrInit == DESC_PACKET_TYPE_INIT) {\r\nentry->CmdInit = DESC_PACKET_TYPE_INIT;\r\n} else {\r\nstruct tx_desc *entry_tmp = (struct tx_desc *)entry;\r\nentry_tmp->CmdInit = DESC_PACKET_TYPE_NORMAL;\r\nentry_tmp->Offset = sizeof(struct tx_fwinfo_8190pci) + 8;\r\nentry_tmp->PktSize = (u16)(cb_desc->pkt_size +\r\nentry_tmp->Offset);\r\nentry_tmp->QueueSelect = QSLT_CMD;\r\nentry_tmp->TxFWInfoSize = 0x08;\r\nentry_tmp->RATid = (u8)DESC_PACKET_TYPE_INIT;\r\n}\r\nentry->TxBufferSize = skb->len;\r\nentry->TxBuffAddr = mapping;\r\nentry->OWN = 1;\r\n}\r\nstatic u8 _rtl92e_rate_hw_to_mgn(bool bIsHT, u8 rate)\r\n{\r\nu8 ret_rate = 0x02;\r\nif (!bIsHT) {\r\nswitch (rate) {\r\ncase DESC90_RATE1M:\r\nret_rate = MGN_1M;\r\nbreak;\r\ncase DESC90_RATE2M:\r\nret_rate = MGN_2M;\r\nbreak;\r\ncase DESC90_RATE5_5M:\r\nret_rate = MGN_5_5M;\r\nbreak;\r\ncase DESC90_RATE11M:\r\nret_rate = MGN_11M;\r\nbreak;\r\ncase DESC90_RATE6M:\r\nret_rate = MGN_6M;\r\nbreak;\r\ncase DESC90_RATE9M:\r\nret_rate = MGN_9M;\r\nbreak;\r\ncase DESC90_RATE12M:\r\nret_rate = MGN_12M;\r\nbreak;\r\ncase DESC90_RATE18M:\r\nret_rate = MGN_18M;\r\nbreak;\r\ncase DESC90_RATE24M:\r\nret_rate = MGN_24M;\r\nbreak;\r\ncase DESC90_RATE36M:\r\nret_rate = MGN_36M;\r\nbreak;\r\ncase DESC90_RATE48M:\r\nret_rate = MGN_48M;\r\nbreak;\r\ncase DESC90_RATE54M:\r\nret_rate = MGN_54M;\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_RECV,\r\n"_rtl92e_rate_hw_to_mgn(): Non supportedRate [%x], bIsHT = %d!!!\n",\r\nrate, bIsHT);\r\nbreak;\r\n}\r\n} else {\r\nswitch (rate) {\r\ncase DESC90_RATEMCS0:\r\nret_rate = MGN_MCS0;\r\nbreak;\r\ncase DESC90_RATEMCS1:\r\nret_rate = MGN_MCS1;\r\nbreak;\r\ncase DESC90_RATEMCS2:\r\nret_rate = MGN_MCS2;\r\nbreak;\r\ncase DESC90_RATEMCS3:\r\nret_rate = MGN_MCS3;\r\nbreak;\r\ncase DESC90_RATEMCS4:\r\nret_rate = MGN_MCS4;\r\nbreak;\r\ncase DESC90_RATEMCS5:\r\nret_rate = MGN_MCS5;\r\nbreak;\r\ncase DESC90_RATEMCS6:\r\nret_rate = MGN_MCS6;\r\nbreak;\r\ncase DESC90_RATEMCS7:\r\nret_rate = MGN_MCS7;\r\nbreak;\r\ncase DESC90_RATEMCS8:\r\nret_rate = MGN_MCS8;\r\nbreak;\r\ncase DESC90_RATEMCS9:\r\nret_rate = MGN_MCS9;\r\nbreak;\r\ncase DESC90_RATEMCS10:\r\nret_rate = MGN_MCS10;\r\nbreak;\r\ncase DESC90_RATEMCS11:\r\nret_rate = MGN_MCS11;\r\nbreak;\r\ncase DESC90_RATEMCS12:\r\nret_rate = MGN_MCS12;\r\nbreak;\r\ncase DESC90_RATEMCS13:\r\nret_rate = MGN_MCS13;\r\nbreak;\r\ncase DESC90_RATEMCS14:\r\nret_rate = MGN_MCS14;\r\nbreak;\r\ncase DESC90_RATEMCS15:\r\nret_rate = MGN_MCS15;\r\nbreak;\r\ncase DESC90_RATEMCS32:\r\nret_rate = (0x80|0x20);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_RECV,\r\n"_rtl92e_rate_hw_to_mgn(): Non supported Rate [%x], bIsHT = %d!!!\n",\r\nrate, bIsHT);\r\nbreak;\r\n}\r\n}\r\nreturn ret_rate;\r\n}\r\nstatic long _rtl92e_signal_scale_mapping(struct r8192_priv *priv, long currsig)\r\n{\r\nlong retsig;\r\nif (currsig >= 61 && currsig <= 100)\r\nretsig = 90 + ((currsig - 60) / 4);\r\nelse if (currsig >= 41 && currsig <= 60)\r\nretsig = 78 + ((currsig - 40) / 2);\r\nelse if (currsig >= 31 && currsig <= 40)\r\nretsig = 66 + (currsig - 30);\r\nelse if (currsig >= 21 && currsig <= 30)\r\nretsig = 54 + (currsig - 20);\r\nelse if (currsig >= 5 && currsig <= 20)\r\nretsig = 42 + (((currsig - 5) * 2) / 3);\r\nelse if (currsig == 4)\r\nretsig = 36;\r\nelse if (currsig == 3)\r\nretsig = 27;\r\nelse if (currsig == 2)\r\nretsig = 18;\r\nelse if (currsig == 1)\r\nretsig = 9;\r\nelse\r\nretsig = currsig;\r\nreturn retsig;\r\n}\r\nstatic void _rtl92e_query_rxphystatus(\r\nstruct r8192_priv *priv,\r\nstruct rtllib_rx_stats *pstats,\r\nstruct rx_desc *pdesc,\r\nstruct rx_fwinfo *pdrvinfo,\r\nstruct rtllib_rx_stats *precord_stats,\r\nbool bpacket_match_bssid,\r\nbool bpacket_toself,\r\nbool bPacketBeacon,\r\nbool bToSelfBA\r\n)\r\n{\r\nstruct phy_sts_ofdm_819xpci *pofdm_buf;\r\nstruct phy_sts_cck_819xpci *pcck_buf;\r\nstruct phy_ofdm_rx_status_rxsc_sgien_exintfflag *prxsc;\r\nu8 *prxpkt;\r\nu8 i, max_spatial_stream, tmp_rxsnr, tmp_rxevm, rxsc_sgien_exflg;\r\ns8 rx_pwr[4], rx_pwr_all = 0;\r\ns8 rx_snrX, rx_evmX;\r\nu8 evm, pwdb_all;\r\nu32 RSSI, total_rssi = 0;\r\nu8 is_cck_rate = 0;\r\nu8 rf_rx_num = 0;\r\nstatic u8 check_reg824;\r\nstatic u32 reg824_bit9;\r\npriv->stats.numqry_phystatus++;\r\nis_cck_rate = rx_hal_is_cck_rate(pdrvinfo);\r\nmemset(precord_stats, 0, sizeof(struct rtllib_rx_stats));\r\npstats->bPacketMatchBSSID = precord_stats->bPacketMatchBSSID =\r\nbpacket_match_bssid;\r\npstats->bPacketToSelf = precord_stats->bPacketToSelf = bpacket_toself;\r\npstats->bIsCCK = precord_stats->bIsCCK = is_cck_rate;\r\npstats->bPacketBeacon = precord_stats->bPacketBeacon = bPacketBeacon;\r\npstats->bToSelfBA = precord_stats->bToSelfBA = bToSelfBA;\r\nif (check_reg824 == 0) {\r\nreg824_bit9 = rtl92e_get_bb_reg(priv->rtllib->dev,\r\nrFPGA0_XA_HSSIParameter2,\r\n0x200);\r\ncheck_reg824 = 1;\r\n}\r\nprxpkt = (u8 *)pdrvinfo;\r\nprxpkt += sizeof(struct rx_fwinfo);\r\npcck_buf = (struct phy_sts_cck_819xpci *)prxpkt;\r\npofdm_buf = (struct phy_sts_ofdm_819xpci *)prxpkt;\r\npstats->RxMIMOSignalQuality[0] = -1;\r\npstats->RxMIMOSignalQuality[1] = -1;\r\nprecord_stats->RxMIMOSignalQuality[0] = -1;\r\nprecord_stats->RxMIMOSignalQuality[1] = -1;\r\nif (is_cck_rate) {\r\nu8 report;\r\npriv->stats.numqry_phystatusCCK++;\r\nif (!reg824_bit9) {\r\nreport = pcck_buf->cck_agc_rpt & 0xc0;\r\nreport >>= 6;\r\nswitch (report) {\r\ncase 0x3:\r\nrx_pwr_all = -35 - (pcck_buf->cck_agc_rpt &\r\n0x3e);\r\nbreak;\r\ncase 0x2:\r\nrx_pwr_all = -23 - (pcck_buf->cck_agc_rpt &\r\n0x3e);\r\nbreak;\r\ncase 0x1:\r\nrx_pwr_all = -11 - (pcck_buf->cck_agc_rpt &\r\n0x3e);\r\nbreak;\r\ncase 0x0:\r\nrx_pwr_all = 8 - (pcck_buf->cck_agc_rpt & 0x3e);\r\nbreak;\r\n}\r\n} else {\r\nreport = pcck_buf->cck_agc_rpt & 0x60;\r\nreport >>= 5;\r\nswitch (report) {\r\ncase 0x3:\r\nrx_pwr_all = -35 -\r\n((pcck_buf->cck_agc_rpt &\r\n0x1f) << 1);\r\nbreak;\r\ncase 0x2:\r\nrx_pwr_all = -23 -\r\n((pcck_buf->cck_agc_rpt &\r\n0x1f) << 1);\r\nbreak;\r\ncase 0x1:\r\nrx_pwr_all = -11 -\r\n((pcck_buf->cck_agc_rpt &\r\n0x1f) << 1);\r\nbreak;\r\ncase 0x0:\r\nrx_pwr_all = -8 -\r\n((pcck_buf->cck_agc_rpt &\r\n0x1f) << 1);\r\nbreak;\r\n}\r\n}\r\npwdb_all = rtl92e_rx_db_to_percent(rx_pwr_all);\r\npstats->RxPWDBAll = precord_stats->RxPWDBAll = pwdb_all;\r\npstats->RecvSignalPower = rx_pwr_all;\r\nif (bpacket_match_bssid) {\r\nu8 sq;\r\nif (pstats->RxPWDBAll > 40) {\r\nsq = 100;\r\n} else {\r\nsq = pcck_buf->sq_rpt;\r\nif (pcck_buf->sq_rpt > 64)\r\nsq = 0;\r\nelse if (pcck_buf->sq_rpt < 20)\r\nsq = 100;\r\nelse\r\nsq = ((64-sq) * 100) / 44;\r\n}\r\npstats->SignalQuality = sq;\r\nprecord_stats->SignalQuality = sq;\r\npstats->RxMIMOSignalQuality[0] = sq;\r\nprecord_stats->RxMIMOSignalQuality[0] = sq;\r\npstats->RxMIMOSignalQuality[1] = -1;\r\nprecord_stats->RxMIMOSignalQuality[1] = -1;\r\n}\r\n} else {\r\npriv->stats.numqry_phystatusHT++;\r\nfor (i = RF90_PATH_A; i < RF90_PATH_MAX; i++) {\r\nif (priv->brfpath_rxenable[i])\r\nrf_rx_num++;\r\nrx_pwr[i] = ((pofdm_buf->trsw_gain_X[i] & 0x3F) *\r\n2) - 110;\r\ntmp_rxsnr = pofdm_buf->rxsnr_X[i];\r\nrx_snrX = (s8)(tmp_rxsnr);\r\nrx_snrX /= 2;\r\npriv->stats.rxSNRdB[i] = (long)rx_snrX;\r\nRSSI = rtl92e_rx_db_to_percent(rx_pwr[i]);\r\nif (priv->brfpath_rxenable[i])\r\ntotal_rssi += RSSI;\r\nif (bpacket_match_bssid) {\r\npstats->RxMIMOSignalStrength[i] = (u8) RSSI;\r\nprecord_stats->RxMIMOSignalStrength[i] =\r\n(u8) RSSI;\r\n}\r\n}\r\nrx_pwr_all = (((pofdm_buf->pwdb_all) >> 1) & 0x7f) - 106;\r\npwdb_all = rtl92e_rx_db_to_percent(rx_pwr_all);\r\npstats->RxPWDBAll = precord_stats->RxPWDBAll = pwdb_all;\r\npstats->RxPower = precord_stats->RxPower = rx_pwr_all;\r\npstats->RecvSignalPower = rx_pwr_all;\r\nif (pdrvinfo->RxHT && pdrvinfo->RxRate >= DESC90_RATEMCS8 &&\r\npdrvinfo->RxRate <= DESC90_RATEMCS15)\r\nmax_spatial_stream = 2;\r\nelse\r\nmax_spatial_stream = 1;\r\nfor (i = 0; i < max_spatial_stream; i++) {\r\ntmp_rxevm = pofdm_buf->rxevm_X[i];\r\nrx_evmX = (s8)(tmp_rxevm);\r\nrx_evmX /= 2;\r\nevm = rtl92e_evm_db_to_percent(rx_evmX);\r\nif (bpacket_match_bssid) {\r\nif (i == 0) {\r\npstats->SignalQuality = evm & 0xff;\r\nprecord_stats->SignalQuality = evm & 0xff;\r\n}\r\npstats->RxMIMOSignalQuality[i] = evm & 0xff;\r\nprecord_stats->RxMIMOSignalQuality[i] = evm & 0xff;\r\n}\r\n}\r\nrxsc_sgien_exflg = pofdm_buf->rxsc_sgien_exflg;\r\nprxsc = (struct phy_ofdm_rx_status_rxsc_sgien_exintfflag *)\r\n&rxsc_sgien_exflg;\r\nif (pdrvinfo->BW)\r\npriv->stats.received_bwtype[1+prxsc->rxsc]++;\r\nelse\r\npriv->stats.received_bwtype[0]++;\r\n}\r\nif (is_cck_rate) {\r\npstats->SignalStrength = precord_stats->SignalStrength =\r\n(u8)(_rtl92e_signal_scale_mapping(priv,\r\n(long)pwdb_all));\r\n} else {\r\nif (rf_rx_num != 0)\r\npstats->SignalStrength = precord_stats->SignalStrength =\r\n(u8)(_rtl92e_signal_scale_mapping(priv,\r\n(long)(total_rssi /= rf_rx_num)));\r\n}\r\n}\r\nstatic void _rtl92e_process_phyinfo(struct r8192_priv *priv, u8 *buffer,\r\nstruct rtllib_rx_stats *prev_st,\r\nstruct rtllib_rx_stats *curr_st)\r\n{\r\nbool bcheck = false;\r\nu8 rfpath;\r\nu32 ij, tmp_val;\r\nstatic u32 slide_rssi_index, slide_rssi_statistics;\r\nstatic u32 slide_evm_index, slide_evm_statistics;\r\nstatic u32 last_rssi, last_evm;\r\nstatic u32 slide_beacon_adc_pwdb_index;\r\nstatic u32 slide_beacon_adc_pwdb_statistics;\r\nstatic u32 last_beacon_adc_pwdb;\r\nstruct rtllib_hdr_3addr *hdr;\r\nu16 sc;\r\nunsigned int frag, seq;\r\nhdr = (struct rtllib_hdr_3addr *)buffer;\r\nsc = le16_to_cpu(hdr->seq_ctl);\r\nfrag = WLAN_GET_SEQ_FRAG(sc);\r\nseq = WLAN_GET_SEQ_SEQ(sc);\r\ncurr_st->Seq_Num = seq;\r\nif (!prev_st->bIsAMPDU)\r\nbcheck = true;\r\nif (slide_rssi_statistics++ >= PHY_RSSI_SLID_WIN_MAX) {\r\nslide_rssi_statistics = PHY_RSSI_SLID_WIN_MAX;\r\nlast_rssi = priv->stats.slide_signal_strength[slide_rssi_index];\r\npriv->stats.slide_rssi_total -= last_rssi;\r\n}\r\npriv->stats.slide_rssi_total += prev_st->SignalStrength;\r\npriv->stats.slide_signal_strength[slide_rssi_index++] =\r\nprev_st->SignalStrength;\r\nif (slide_rssi_index >= PHY_RSSI_SLID_WIN_MAX)\r\nslide_rssi_index = 0;\r\ntmp_val = priv->stats.slide_rssi_total/slide_rssi_statistics;\r\npriv->stats.signal_strength = rtl92e_translate_to_dbm(priv,\r\n(u8)tmp_val);\r\ncurr_st->rssi = priv->stats.signal_strength;\r\nif (!prev_st->bPacketMatchBSSID) {\r\nif (!prev_st->bToSelfBA)\r\nreturn;\r\n}\r\nif (!bcheck)\r\nreturn;\r\npriv->stats.num_process_phyinfo++;\r\nif (!prev_st->bIsCCK && prev_st->bPacketToSelf) {\r\nfor (rfpath = RF90_PATH_A; rfpath < RF90_PATH_C; rfpath++) {\r\nif (!rtl92e_is_legal_rf_path(priv->rtllib->dev, rfpath))\r\ncontinue;\r\nRT_TRACE(COMP_DBG,\r\n"Jacken -> pPreviousstats->RxMIMOSignalStrength[rfpath] = %d\n",\r\nprev_st->RxMIMOSignalStrength[rfpath]);\r\nif (priv->stats.rx_rssi_percentage[rfpath] == 0) {\r\npriv->stats.rx_rssi_percentage[rfpath] =\r\nprev_st->RxMIMOSignalStrength[rfpath];\r\n}\r\nif (prev_st->RxMIMOSignalStrength[rfpath] >\r\npriv->stats.rx_rssi_percentage[rfpath]) {\r\npriv->stats.rx_rssi_percentage[rfpath] =\r\n((priv->stats.rx_rssi_percentage[rfpath]\r\n* (RX_SMOOTH - 1)) +\r\n(prev_st->RxMIMOSignalStrength\r\n[rfpath])) / (RX_SMOOTH);\r\npriv->stats.rx_rssi_percentage[rfpath] =\r\npriv->stats.rx_rssi_percentage[rfpath]\r\n+ 1;\r\n} else {\r\npriv->stats.rx_rssi_percentage[rfpath] =\r\n((priv->stats.rx_rssi_percentage[rfpath] *\r\n(RX_SMOOTH-1)) +\r\n(prev_st->RxMIMOSignalStrength[rfpath])) /\r\n(RX_SMOOTH);\r\n}\r\nRT_TRACE(COMP_DBG,\r\n"Jacken -> priv->RxStats.RxRSSIPercentage[rfPath] = %d\n",\r\npriv->stats.rx_rssi_percentage[rfpath]);\r\n}\r\n}\r\nif (prev_st->bPacketBeacon) {\r\nif (slide_beacon_adc_pwdb_statistics++ >=\r\nPHY_Beacon_RSSI_SLID_WIN_MAX) {\r\nslide_beacon_adc_pwdb_statistics =\r\nPHY_Beacon_RSSI_SLID_WIN_MAX;\r\nlast_beacon_adc_pwdb = priv->stats.Slide_Beacon_pwdb\r\n[slide_beacon_adc_pwdb_index];\r\npriv->stats.Slide_Beacon_Total -= last_beacon_adc_pwdb;\r\n}\r\npriv->stats.Slide_Beacon_Total += prev_st->RxPWDBAll;\r\npriv->stats.Slide_Beacon_pwdb[slide_beacon_adc_pwdb_index] =\r\nprev_st->RxPWDBAll;\r\nslide_beacon_adc_pwdb_index++;\r\nif (slide_beacon_adc_pwdb_index >= PHY_Beacon_RSSI_SLID_WIN_MAX)\r\nslide_beacon_adc_pwdb_index = 0;\r\nprev_st->RxPWDBAll = priv->stats.Slide_Beacon_Total /\r\nslide_beacon_adc_pwdb_statistics;\r\nif (prev_st->RxPWDBAll >= 3)\r\nprev_st->RxPWDBAll -= 3;\r\n}\r\nRT_TRACE(COMP_RXDESC, "Smooth %s PWDB = %d\n",\r\nprev_st->bIsCCK ? "CCK" : "OFDM",\r\nprev_st->RxPWDBAll);\r\nif (prev_st->bPacketToSelf || prev_st->bPacketBeacon ||\r\nprev_st->bToSelfBA) {\r\nif (priv->undecorated_smoothed_pwdb < 0)\r\npriv->undecorated_smoothed_pwdb = prev_st->RxPWDBAll;\r\nif (prev_st->RxPWDBAll > (u32)priv->undecorated_smoothed_pwdb) {\r\npriv->undecorated_smoothed_pwdb =\r\n(((priv->undecorated_smoothed_pwdb) *\r\n(RX_SMOOTH-1)) +\r\n(prev_st->RxPWDBAll)) / (RX_SMOOTH);\r\npriv->undecorated_smoothed_pwdb =\r\npriv->undecorated_smoothed_pwdb + 1;\r\n} else {\r\npriv->undecorated_smoothed_pwdb =\r\n(((priv->undecorated_smoothed_pwdb) *\r\n(RX_SMOOTH-1)) +\r\n(prev_st->RxPWDBAll)) / (RX_SMOOTH);\r\n}\r\nrtl92e_update_rx_statistics(priv, prev_st);\r\n}\r\nif (prev_st->SignalQuality != 0) {\r\nif (prev_st->bPacketToSelf || prev_st->bPacketBeacon ||\r\nprev_st->bToSelfBA) {\r\nif (slide_evm_statistics++ >= PHY_RSSI_SLID_WIN_MAX) {\r\nslide_evm_statistics = PHY_RSSI_SLID_WIN_MAX;\r\nlast_evm =\r\npriv->stats.slide_evm[slide_evm_index];\r\npriv->stats.slide_evm_total -= last_evm;\r\n}\r\npriv->stats.slide_evm_total += prev_st->SignalQuality;\r\npriv->stats.slide_evm[slide_evm_index++] =\r\nprev_st->SignalQuality;\r\nif (slide_evm_index >= PHY_RSSI_SLID_WIN_MAX)\r\nslide_evm_index = 0;\r\ntmp_val = priv->stats.slide_evm_total /\r\nslide_evm_statistics;\r\npriv->stats.signal_quality = tmp_val;\r\npriv->stats.last_signal_strength_inpercent = tmp_val;\r\n}\r\nif (prev_st->bPacketToSelf ||\r\nprev_st->bPacketBeacon ||\r\nprev_st->bToSelfBA) {\r\nfor (ij = 0; ij < 2; ij++) {\r\nif (prev_st->RxMIMOSignalQuality[ij] != -1) {\r\nif (priv->stats.rx_evm_percentage[ij] == 0)\r\npriv->stats.rx_evm_percentage[ij] =\r\nprev_st->RxMIMOSignalQuality[ij];\r\npriv->stats.rx_evm_percentage[ij] =\r\n((priv->stats.rx_evm_percentage[ij] *\r\n(RX_SMOOTH - 1)) +\r\n(prev_st->RxMIMOSignalQuality[ij])) /\r\n(RX_SMOOTH);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void _rtl92e_translate_rx_signal_stats(struct net_device *dev,\r\nstruct sk_buff *skb,\r\nstruct rtllib_rx_stats *pstats,\r\nstruct rx_desc *pdesc,\r\nstruct rx_fwinfo *pdrvinfo)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nbool bpacket_match_bssid, bpacket_toself;\r\nbool bPacketBeacon = false;\r\nstruct rtllib_hdr_3addr *hdr;\r\nbool bToSelfBA = false;\r\nstatic struct rtllib_rx_stats previous_stats;\r\nu16 fc, type;\r\nu8 *tmp_buf;\r\nu8 *praddr;\r\ntmp_buf = skb->data + pstats->RxDrvInfoSize + pstats->RxBufShift;\r\nhdr = (struct rtllib_hdr_3addr *)tmp_buf;\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\ntype = WLAN_FC_GET_TYPE(fc);\r\npraddr = hdr->addr1;\r\nbpacket_match_bssid =\r\n((type != RTLLIB_FTYPE_CTL) &&\r\nether_addr_equal(priv->rtllib->current_network.bssid,\r\n(fc & RTLLIB_FCTL_TODS) ? hdr->addr1 :\r\n(fc & RTLLIB_FCTL_FROMDS) ? hdr->addr2 :\r\nhdr->addr3) &&\r\n(!pstats->bHwError) && (!pstats->bCRC) && (!pstats->bICV));\r\nbpacket_toself = bpacket_match_bssid &&\r\nether_addr_equal(praddr, priv->rtllib->dev->dev_addr);\r\nif (WLAN_FC_GET_FRAMETYPE(fc) == RTLLIB_STYPE_BEACON)\r\nbPacketBeacon = true;\r\nif (bpacket_match_bssid)\r\npriv->stats.numpacket_matchbssid++;\r\nif (bpacket_toself)\r\npriv->stats.numpacket_toself++;\r\n_rtl92e_process_phyinfo(priv, tmp_buf, &previous_stats, pstats);\r\n_rtl92e_query_rxphystatus(priv, pstats, pdesc, pdrvinfo,\r\n&previous_stats, bpacket_match_bssid,\r\nbpacket_toself, bPacketBeacon, bToSelfBA);\r\nrtl92e_copy_mpdu_stats(pstats, &previous_stats);\r\n}\r\nstatic void _rtl92e_update_received_rate_histogram_stats(\r\nstruct net_device *dev,\r\nstruct rtllib_rx_stats *pstats)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nu32 rcvType = 1;\r\nu32 rateIndex;\r\nu32 preamble_guardinterval;\r\nif (pstats->bCRC)\r\nrcvType = 2;\r\nelse if (pstats->bICV)\r\nrcvType = 3;\r\nif (pstats->bShortPreamble)\r\npreamble_guardinterval = 1;\r\nelse\r\npreamble_guardinterval = 0;\r\nswitch (pstats->rate) {\r\ncase MGN_1M:\r\nrateIndex = 0;\r\nbreak;\r\ncase MGN_2M:\r\nrateIndex = 1;\r\nbreak;\r\ncase MGN_5_5M:\r\nrateIndex = 2;\r\nbreak;\r\ncase MGN_11M:\r\nrateIndex = 3;\r\nbreak;\r\ncase MGN_6M:\r\nrateIndex = 4;\r\nbreak;\r\ncase MGN_9M:\r\nrateIndex = 5;\r\nbreak;\r\ncase MGN_12M:\r\nrateIndex = 6;\r\nbreak;\r\ncase MGN_18M:\r\nrateIndex = 7;\r\nbreak;\r\ncase MGN_24M:\r\nrateIndex = 8;\r\nbreak;\r\ncase MGN_36M:\r\nrateIndex = 9;\r\nbreak;\r\ncase MGN_48M:\r\nrateIndex = 10;\r\nbreak;\r\ncase MGN_54M:\r\nrateIndex = 11;\r\nbreak;\r\ncase MGN_MCS0:\r\nrateIndex = 12;\r\nbreak;\r\ncase MGN_MCS1:\r\nrateIndex = 13;\r\nbreak;\r\ncase MGN_MCS2:\r\nrateIndex = 14;\r\nbreak;\r\ncase MGN_MCS3:\r\nrateIndex = 15;\r\nbreak;\r\ncase MGN_MCS4:\r\nrateIndex = 16;\r\nbreak;\r\ncase MGN_MCS5:\r\nrateIndex = 17;\r\nbreak;\r\ncase MGN_MCS6:\r\nrateIndex = 18;\r\nbreak;\r\ncase MGN_MCS7:\r\nrateIndex = 19;\r\nbreak;\r\ncase MGN_MCS8:\r\nrateIndex = 20;\r\nbreak;\r\ncase MGN_MCS9:\r\nrateIndex = 21;\r\nbreak;\r\ncase MGN_MCS10:\r\nrateIndex = 22;\r\nbreak;\r\ncase MGN_MCS11:\r\nrateIndex = 23;\r\nbreak;\r\ncase MGN_MCS12:\r\nrateIndex = 24;\r\nbreak;\r\ncase MGN_MCS13:\r\nrateIndex = 25;\r\nbreak;\r\ncase MGN_MCS14:\r\nrateIndex = 26;\r\nbreak;\r\ncase MGN_MCS15:\r\nrateIndex = 27;\r\nbreak;\r\ndefault:\r\nrateIndex = 28;\r\nbreak;\r\n}\r\npriv->stats.received_preamble_GI[preamble_guardinterval][rateIndex]++;\r\npriv->stats.received_rate_histogram[0][rateIndex]++;\r\npriv->stats.received_rate_histogram[rcvType][rateIndex]++;\r\n}\r\nbool rtl92e_get_rx_stats(struct net_device *dev, struct rtllib_rx_stats *stats,\r\nstruct rx_desc *pdesc, struct sk_buff *skb)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rx_fwinfo *pDrvInfo = NULL;\r\nstats->bICV = pdesc->ICV;\r\nstats->bCRC = pdesc->CRC32;\r\nstats->bHwError = pdesc->CRC32 | pdesc->ICV;\r\nstats->Length = pdesc->Length;\r\nif (stats->Length < 24)\r\nstats->bHwError |= 1;\r\nif (stats->bHwError) {\r\nstats->bShift = false;\r\nif (pdesc->CRC32) {\r\nif (pdesc->Length < 500)\r\npriv->stats.rxcrcerrmin++;\r\nelse if (pdesc->Length > 1000)\r\npriv->stats.rxcrcerrmax++;\r\nelse\r\npriv->stats.rxcrcerrmid++;\r\n}\r\nreturn false;\r\n}\r\nstats->RxDrvInfoSize = pdesc->RxDrvInfoSize;\r\nstats->RxBufShift = ((pdesc->Shift)&0x03);\r\nstats->Decrypted = !pdesc->SWDec;\r\npDrvInfo = (struct rx_fwinfo *)(skb->data + stats->RxBufShift);\r\nstats->rate = _rtl92e_rate_hw_to_mgn((bool)pDrvInfo->RxHT,\r\n(u8)pDrvInfo->RxRate);\r\nstats->bShortPreamble = pDrvInfo->SPLCP;\r\n_rtl92e_update_received_rate_histogram_stats(dev, stats);\r\nstats->bIsAMPDU = (pDrvInfo->PartAggr == 1);\r\nstats->bFirstMPDU = (pDrvInfo->PartAggr == 1) &&\r\n(pDrvInfo->FirstAGGR == 1);\r\nstats->TimeStampLow = pDrvInfo->TSFL;\r\nstats->TimeStampHigh = rtl92e_readl(dev, TSFR+4);\r\nrtl92e_update_rx_pkt_timestamp(dev, stats);\r\nif ((stats->RxBufShift + stats->RxDrvInfoSize) > 0)\r\nstats->bShift = 1;\r\nstats->RxIs40MHzPacket = pDrvInfo->BW;\r\n_rtl92e_translate_rx_signal_stats(dev, skb, stats, pdesc, pDrvInfo);\r\nif (pDrvInfo->FirstAGGR == 1 || pDrvInfo->PartAggr == 1)\r\nRT_TRACE(COMP_RXDESC,\r\n"pDrvInfo->FirstAGGR = %d, pDrvInfo->PartAggr = %d\n",\r\npDrvInfo->FirstAGGR, pDrvInfo->PartAggr);\r\nskb_trim(skb, skb->len - 4);\r\nstats->packetlength = stats->Length-4;\r\nstats->fraglength = stats->packetlength;\r\nstats->fragoffset = 0;\r\nstats->ntotalfrag = 1;\r\nreturn true;\r\n}\r\nvoid rtl92e_stop_adapter(struct net_device *dev, bool reset)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint i;\r\nu8 OpMode;\r\nu8 u1bTmp;\r\nu32 ulRegRead;\r\nOpMode = RT_OP_MODE_NO_LINK;\r\npriv->rtllib->SetHwRegHandler(dev, HW_VAR_MEDIA_STATUS, &OpMode);\r\nif (!priv->rtllib->bSupportRemoteWakeUp) {\r\nu1bTmp = 0x0;\r\nrtl92e_writeb(dev, CMDR, u1bTmp);\r\n}\r\nmdelay(20);\r\nif (!reset) {\r\nmdelay(150);\r\npriv->bHwRfOffAction = 2;\r\nif (!priv->rtllib->bSupportRemoteWakeUp) {\r\nrtl92e_set_rf_off(dev);\r\nulRegRead = rtl92e_readl(dev, CPU_GEN);\r\nulRegRead |= CPU_GEN_SYSTEM_RESET;\r\nrtl92e_writel(dev, CPU_GEN, ulRegRead);\r\n} else {\r\nrtl92e_writel(dev, WFCRC0, 0xffffffff);\r\nrtl92e_writel(dev, WFCRC1, 0xffffffff);\r\nrtl92e_writel(dev, WFCRC2, 0xffffffff);\r\nrtl92e_writeb(dev, PMR, 0x5);\r\nrtl92e_writeb(dev, MacBlkCtrl, 0xa);\r\n}\r\n}\r\nfor (i = 0; i < MAX_QUEUE_SIZE; i++)\r\nskb_queue_purge(&priv->rtllib->skb_waitQ[i]);\r\nfor (i = 0; i < MAX_QUEUE_SIZE; i++)\r\nskb_queue_purge(&priv->rtllib->skb_aggQ[i]);\r\nskb_queue_purge(&priv->skb_queue);\r\n}\r\nvoid rtl92e_update_ratr_table(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nu8 *pMcsRate = ieee->dot11HTOperationalRateSet;\r\nu32 ratr_value = 0;\r\nu16 rate_config = 0;\r\nu8 rate_index = 0;\r\nrtl92e_config_rate(dev, &rate_config);\r\nratr_value = rate_config | *pMcsRate << 12;\r\nswitch (ieee->mode) {\r\ncase IEEE_A:\r\nratr_value &= 0x00000FF0;\r\nbreak;\r\ncase IEEE_B:\r\nratr_value &= 0x0000000F;\r\nbreak;\r\ncase IEEE_G:\r\ncase IEEE_G|IEEE_B:\r\nratr_value &= 0x00000FF7;\r\nbreak;\r\ncase IEEE_N_24G:\r\ncase IEEE_N_5G:\r\nif (ieee->pHTInfo->PeerMimoPs == 0) {\r\nratr_value &= 0x0007F007;\r\n} else {\r\nif (priv->rf_type == RF_1T2R)\r\nratr_value &= 0x000FF007;\r\nelse\r\nratr_value &= 0x0F81F007;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nratr_value &= 0x0FFFFFFF;\r\nif (ieee->pHTInfo->bCurTxBW40MHz &&\r\nieee->pHTInfo->bCurShortGI40MHz)\r\nratr_value |= 0x80000000;\r\nelse if (!ieee->pHTInfo->bCurTxBW40MHz &&\r\nieee->pHTInfo->bCurShortGI20MHz)\r\nratr_value |= 0x80000000;\r\nrtl92e_writel(dev, RATR0+rate_index*4, ratr_value);\r\nrtl92e_writeb(dev, UFWP, 1);\r\n}\r\nvoid\r\nrtl92e_init_variables(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstrcpy(priv->nick, "rtl8192E");\r\npriv->rtllib->softmac_features = IEEE_SOFTMAC_SCAN |\r\nIEEE_SOFTMAC_ASSOCIATE | IEEE_SOFTMAC_PROBERQ |\r\nIEEE_SOFTMAC_PROBERS | IEEE_SOFTMAC_TX_QUEUE;\r\npriv->rtllib->tx_headroom = sizeof(struct tx_fwinfo_8190pci);\r\npriv->ShortRetryLimit = 0x30;\r\npriv->LongRetryLimit = 0x30;\r\npriv->ReceiveConfig = RCR_ADD3 |\r\nRCR_AMF | RCR_ADF |\r\nRCR_AICV |\r\nRCR_AB | RCR_AM | RCR_APM |\r\nRCR_AAP | ((u32)7<<RCR_MXDMA_OFFSET) |\r\n((u32)7 << RCR_FIFO_OFFSET) | RCR_ONLYERLPKT;\r\npriv->irq_mask[0] = (u32)(IMR_ROK | IMR_VODOK | IMR_VIDOK |\r\nIMR_BEDOK | IMR_BKDOK | IMR_HCCADOK |\r\nIMR_MGNTDOK | IMR_COMDOK | IMR_HIGHDOK |\r\nIMR_BDOK | IMR_RXCMDOK | IMR_TIMEOUT0 |\r\nIMR_RDU | IMR_RXFOVW | IMR_TXFOVW |\r\nIMR_BcnInt | IMR_TBDOK | IMR_TBDER);\r\npriv->PwrDomainProtect = false;\r\npriv->bfirst_after_down = false;\r\n}\r\nvoid rtl92e_enable_irq(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\npriv->irq_enabled = 1;\r\nrtl92e_writel(dev, INTA_MASK, priv->irq_mask[0]);\r\n}\r\nvoid rtl92e_disable_irq(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nrtl92e_writel(dev, INTA_MASK, 0);\r\npriv->irq_enabled = 0;\r\n}\r\nvoid rtl92e_clear_irq(struct net_device *dev)\r\n{\r\nu32 tmp;\r\ntmp = rtl92e_readl(dev, ISR);\r\nrtl92e_writel(dev, ISR, tmp);\r\n}\r\nvoid rtl92e_enable_rx(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nrtl92e_writel(dev, RDQDA, priv->rx_ring_dma[RX_MPDU_QUEUE]);\r\n}\r\nvoid rtl92e_enable_tx(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nu32 i;\r\nfor (i = 0; i < MAX_TX_QUEUE_COUNT; i++)\r\nrtl92e_writel(dev, TX_DESC_BASE[i], priv->tx_ring[i].dma);\r\n}\r\nvoid rtl92e_ack_irq(struct net_device *dev, u32 *p_inta, u32 *p_intb)\r\n{\r\n*p_inta = rtl92e_readl(dev, ISR);\r\nrtl92e_writel(dev, ISR, *p_inta);\r\n}\r\nbool rtl92e_is_rx_stuck(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu16 RegRxCounter = rtl92e_readw(dev, 0x130);\r\nbool bStuck = false;\r\nstatic u8 rx_chk_cnt;\r\nu32 SlotIndex = 0, TotalRxStuckCount = 0;\r\nu8 i;\r\nu8 SilentResetRxSoltNum = 4;\r\nRT_TRACE(COMP_RESET, "%s(): RegRxCounter is %d, RxCounter is %d\n",\r\n__func__, RegRxCounter, priv->RxCounter);\r\nrx_chk_cnt++;\r\nif (priv->undecorated_smoothed_pwdb >= (RateAdaptiveTH_High+5)) {\r\nrx_chk_cnt = 0;\r\n} else if ((priv->undecorated_smoothed_pwdb < (RateAdaptiveTH_High + 5))\r\n&& (((priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20) &&\r\n(priv->undecorated_smoothed_pwdb >= RateAdaptiveTH_Low_40M))\r\n|| ((priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20) &&\r\n(priv->undecorated_smoothed_pwdb >= RateAdaptiveTH_Low_20M)))) {\r\nif (rx_chk_cnt < 2)\r\nreturn bStuck;\r\nrx_chk_cnt = 0;\r\n} else if ((((priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20) &&\r\n(priv->undecorated_smoothed_pwdb < RateAdaptiveTH_Low_40M)) ||\r\n((priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20) &&\r\n(priv->undecorated_smoothed_pwdb < RateAdaptiveTH_Low_20M))) &&\r\npriv->undecorated_smoothed_pwdb >= VeryLowRSSI) {\r\nif (rx_chk_cnt < 4)\r\nreturn bStuck;\r\nrx_chk_cnt = 0;\r\n} else {\r\nif (rx_chk_cnt < 8)\r\nreturn bStuck;\r\nrx_chk_cnt = 0;\r\n}\r\nSlotIndex = (priv->SilentResetRxSlotIndex++)%SilentResetRxSoltNum;\r\nif (priv->RxCounter == RegRxCounter) {\r\npriv->SilentResetRxStuckEvent[SlotIndex] = 1;\r\nfor (i = 0; i < SilentResetRxSoltNum; i++)\r\nTotalRxStuckCount += priv->SilentResetRxStuckEvent[i];\r\nif (TotalRxStuckCount == SilentResetRxSoltNum) {\r\nbStuck = true;\r\nfor (i = 0; i < SilentResetRxSoltNum; i++)\r\nTotalRxStuckCount +=\r\npriv->SilentResetRxStuckEvent[i];\r\n}\r\n} else {\r\npriv->SilentResetRxStuckEvent[SlotIndex] = 0;\r\n}\r\npriv->RxCounter = RegRxCounter;\r\nreturn bStuck;\r\n}\r\nbool rtl92e_is_tx_stuck(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nbool bStuck = false;\r\nu16 RegTxCounter = rtl92e_readw(dev, 0x128);\r\nRT_TRACE(COMP_RESET, "%s():RegTxCounter is %d,TxCounter is %d\n",\r\n__func__, RegTxCounter, priv->TxCounter);\r\nif (priv->TxCounter == RegTxCounter)\r\nbStuck = true;\r\npriv->TxCounter = RegTxCounter;\r\nreturn bStuck;\r\n}\r\nbool rtl92e_get_nmode_support_by_sec(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nif (ieee->rtllib_ap_sec_type &&\r\n(ieee->rtllib_ap_sec_type(priv->rtllib)&(SEC_ALG_WEP |\r\nSEC_ALG_TKIP))) {\r\nreturn false;\r\n} else {\r\nreturn true;\r\n}\r\n}\r\nbool rtl92e_is_halfn_supported_by_ap(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nreturn ieee->bHalfWirelessN24GMode;\r\n}
