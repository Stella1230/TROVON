int ms_sensors_reset(void *cli, u8 cmd, unsigned int delay)\r\n{\r\nint ret;\r\nstruct i2c_client *client = cli;\r\nret = i2c_smbus_write_byte(client, cmd);\r\nif (ret) {\r\ndev_err(&client->dev, "Failed to reset device\n");\r\nreturn ret;\r\n}\r\nusleep_range(delay, delay + 1000);\r\nreturn 0;\r\n}\r\nint ms_sensors_read_prom_word(void *cli, int cmd, u16 *word)\r\n{\r\nint ret;\r\nstruct i2c_client *client = cli;\r\nret = i2c_smbus_read_word_swapped(client, cmd);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to read prom word\n");\r\nreturn ret;\r\n}\r\n*word = ret;\r\nreturn 0;\r\n}\r\nint ms_sensors_convert_and_read(void *cli, u8 conv, u8 rd,\r\nunsigned int delay, u32 *adc)\r\n{\r\nint ret;\r\n__be32 buf = 0;\r\nstruct i2c_client *client = cli;\r\nret = i2c_smbus_write_byte(client, conv);\r\nif (ret)\r\ngoto err;\r\nusleep_range(delay, delay + 1000);\r\nif (rd != MS_SENSORS_NO_READ_CMD)\r\nret = i2c_smbus_read_i2c_block_data(client, rd, 3, (u8 *)&buf);\r\nelse\r\nret = i2c_master_recv(client, (u8 *)&buf, 3);\r\nif (ret < 0)\r\ngoto err;\r\ndev_dbg(&client->dev, "ADC raw value : %x\n", be32_to_cpu(buf) >> 8);\r\n*adc = be32_to_cpu(buf) >> 8;\r\nreturn 0;\r\nerr:\r\ndev_err(&client->dev, "Unable to make sensor adc conversion\n");\r\nreturn ret;\r\n}\r\nstatic bool ms_sensors_crc_valid(u32 value)\r\n{\r\nu32 polynom = 0x988000;\r\nu32 msb = 0x800000;\r\nu32 mask = 0xFF8000;\r\nu32 result = value & 0xFFFF00;\r\nu8 crc = value & 0xFF;\r\nwhile (msb != 0x80) {\r\nif (result & msb)\r\nresult = ((result ^ polynom) & mask)\r\n| (result & ~mask);\r\nmsb >>= 1;\r\nmask >>= 1;\r\npolynom >>= 1;\r\n}\r\nreturn result == crc;\r\n}\r\nint ms_sensors_read_serial(struct i2c_client *client, u64 *sn)\r\n{\r\nu8 i;\r\n__be64 rcv_buf = 0;\r\nu64 rcv_val;\r\n__be16 send_buf;\r\nint ret;\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = client->addr,\r\n.flags = client->flags,\r\n.len = 2,\r\n.buf = (__u8 *)&send_buf,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = client->flags | I2C_M_RD,\r\n.buf = (__u8 *)&rcv_buf,\r\n},\r\n};\r\nsend_buf = cpu_to_be16(MS_SENSORS_SERIAL_READ_MSB);\r\nmsg[1].len = 8;\r\nret = i2c_transfer(client->adapter, msg, 2);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Unable to read device serial number");\r\nreturn ret;\r\n}\r\nrcv_val = be64_to_cpu(rcv_buf);\r\ndev_dbg(&client->dev, "Serial MSB raw : %llx\n", rcv_val);\r\nfor (i = 0; i < 64; i += 16) {\r\nif (!ms_sensors_crc_valid((rcv_val >> i) & 0xFFFF))\r\nreturn -ENODEV;\r\n}\r\n*sn = (((rcv_val >> 32) & 0xFF000000) |\r\n((rcv_val >> 24) & 0x00FF0000) |\r\n((rcv_val >> 16) & 0x0000FF00) |\r\n((rcv_val >> 8) & 0x000000FF)) << 16;\r\nsend_buf = cpu_to_be16(MS_SENSORS_SERIAL_READ_LSB);\r\nmsg[1].len = 6;\r\nrcv_buf = 0;\r\nret = i2c_transfer(client->adapter, msg, 2);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Unable to read device serial number");\r\nreturn ret;\r\n}\r\nrcv_val = be64_to_cpu(rcv_buf) >> 16;\r\ndev_dbg(&client->dev, "Serial MSB raw : %llx\n", rcv_val);\r\nfor (i = 0; i < 48; i += 24) {\r\nif (!ms_sensors_crc_valid((rcv_val >> i) & 0xFFFFFF))\r\nreturn -ENODEV;\r\n}\r\n*sn |= (rcv_val & 0xFFFF00) << 40 | (rcv_val >> 32);\r\nreturn 0;\r\n}\r\nstatic int ms_sensors_read_config_reg(struct i2c_client *client,\r\nu8 *config_reg)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte(client, MS_SENSORS_CONFIG_REG_READ);\r\nif (ret) {\r\ndev_err(&client->dev, "Unable to read config register");\r\nreturn ret;\r\n}\r\nret = i2c_master_recv(client, config_reg, 1);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Unable to read config register");\r\nreturn ret;\r\n}\r\ndev_dbg(&client->dev, "Config register :%x\n", *config_reg);\r\nreturn 0;\r\n}\r\nssize_t ms_sensors_write_resolution(struct ms_ht_dev *dev_data,\r\nu8 i)\r\n{\r\nu8 config_reg;\r\nint ret;\r\nret = ms_sensors_read_config_reg(dev_data->client, &config_reg);\r\nif (ret)\r\nreturn ret;\r\nconfig_reg &= 0x7E;\r\nconfig_reg |= ((i & 1) << 7) + ((i & 2) >> 1);\r\nreturn i2c_smbus_write_byte_data(dev_data->client,\r\nMS_SENSORS_CONFIG_REG_WRITE,\r\nconfig_reg);\r\n}\r\nssize_t ms_sensors_show_battery_low(struct ms_ht_dev *dev_data,\r\nchar *buf)\r\n{\r\nint ret;\r\nu8 config_reg;\r\nmutex_lock(&dev_data->lock);\r\nret = ms_sensors_read_config_reg(dev_data->client, &config_reg);\r\nmutex_unlock(&dev_data->lock);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", (config_reg & 0x40) >> 6);\r\n}\r\nssize_t ms_sensors_show_heater(struct ms_ht_dev *dev_data,\r\nchar *buf)\r\n{\r\nu8 config_reg;\r\nint ret;\r\nmutex_lock(&dev_data->lock);\r\nret = ms_sensors_read_config_reg(dev_data->client, &config_reg);\r\nmutex_unlock(&dev_data->lock);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", (config_reg & 0x4) >> 2);\r\n}\r\nssize_t ms_sensors_write_heater(struct ms_ht_dev *dev_data,\r\nconst char *buf, size_t len)\r\n{\r\nu8 val, config_reg;\r\nint ret;\r\nret = kstrtou8(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&dev_data->lock);\r\nret = ms_sensors_read_config_reg(dev_data->client, &config_reg);\r\nif (ret) {\r\nmutex_unlock(&dev_data->lock);\r\nreturn ret;\r\n}\r\nconfig_reg &= 0xFB;\r\nconfig_reg |= val << 2;\r\nret = i2c_smbus_write_byte_data(dev_data->client,\r\nMS_SENSORS_CONFIG_REG_WRITE,\r\nconfig_reg);\r\nmutex_unlock(&dev_data->lock);\r\nif (ret) {\r\ndev_err(&dev_data->client->dev, "Unable to write config register\n");\r\nreturn ret;\r\n}\r\nreturn len;\r\n}\r\nint ms_sensors_ht_read_temperature(struct ms_ht_dev *dev_data,\r\ns32 *temperature)\r\n{\r\nint ret;\r\nu32 adc;\r\nu16 delay;\r\nmutex_lock(&dev_data->lock);\r\ndelay = ms_sensors_ht_t_conversion_time[dev_data->res_index];\r\nret = ms_sensors_convert_and_read(dev_data->client,\r\nMS_SENSORS_HT_T_CONVERSION_START,\r\nMS_SENSORS_NO_READ_CMD,\r\ndelay, &adc);\r\nmutex_unlock(&dev_data->lock);\r\nif (ret)\r\nreturn ret;\r\nif (!ms_sensors_crc_valid(adc)) {\r\ndev_err(&dev_data->client->dev,\r\n"Temperature read crc check error\n");\r\nreturn -ENODEV;\r\n}\r\n*temperature = (((s64)(adc >> 8) * 175720) >> 16) - 46850;\r\nreturn 0;\r\n}\r\nint ms_sensors_ht_read_humidity(struct ms_ht_dev *dev_data,\r\nu32 *humidity)\r\n{\r\nint ret;\r\nu32 adc;\r\nu16 delay;\r\nmutex_lock(&dev_data->lock);\r\ndelay = ms_sensors_ht_h_conversion_time[dev_data->res_index];\r\nret = ms_sensors_convert_and_read(dev_data->client,\r\nMS_SENSORS_HT_H_CONVERSION_START,\r\nMS_SENSORS_NO_READ_CMD,\r\ndelay, &adc);\r\nmutex_unlock(&dev_data->lock);\r\nif (ret)\r\nreturn ret;\r\nif (!ms_sensors_crc_valid(adc)) {\r\ndev_err(&dev_data->client->dev,\r\n"Humidity read crc check error\n");\r\nreturn -ENODEV;\r\n}\r\n*humidity = (((s32)(adc >> 8) * 12500) >> 16) * 10 - 6000;\r\nif (*humidity >= 100000)\r\n*humidity = 100000;\r\nreturn 0;\r\n}\r\nstatic bool ms_sensors_tp_crc_valid(u16 *prom, u8 len)\r\n{\r\nunsigned int cnt, n_bit;\r\nu16 n_rem = 0x0000, crc_read = prom[0], crc = (*prom & 0xF000) >> 12;\r\nprom[len - 1] = 0;\r\nprom[0] &= 0x0FFF;\r\nfor (cnt = 0; cnt < len * 2; cnt++) {\r\nif (cnt % 2 == 1)\r\nn_rem ^= prom[cnt >> 1] & 0x00FF;\r\nelse\r\nn_rem ^= prom[cnt >> 1] >> 8;\r\nfor (n_bit = 8; n_bit > 0; n_bit--) {\r\nif (n_rem & 0x8000)\r\nn_rem = (n_rem << 1) ^ 0x3000;\r\nelse\r\nn_rem <<= 1;\r\n}\r\n}\r\nn_rem >>= 12;\r\nprom[0] = crc_read;\r\nreturn n_rem == crc;\r\n}\r\nint ms_sensors_tp_read_prom(struct ms_tp_dev *dev_data)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < MS_SENSORS_TP_PROM_WORDS_NB; i++) {\r\nret = ms_sensors_read_prom_word(\r\ndev_data->client,\r\nMS_SENSORS_TP_PROM_READ + (i << 1),\r\n&dev_data->prom[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!ms_sensors_tp_crc_valid(dev_data->prom,\r\nMS_SENSORS_TP_PROM_WORDS_NB + 1)) {\r\ndev_err(&dev_data->client->dev,\r\n"Calibration coefficients crc check error\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nint ms_sensors_read_temp_and_pressure(struct ms_tp_dev *dev_data,\r\nint *temperature,\r\nunsigned int *pressure)\r\n{\r\nint ret;\r\nu32 t_adc, p_adc;\r\ns32 dt, temp;\r\ns64 off, sens, t2, off2, sens2;\r\nu16 *prom = dev_data->prom, delay;\r\nmutex_lock(&dev_data->lock);\r\ndelay = ms_sensors_tp_conversion_time[dev_data->res_index];\r\nret = ms_sensors_convert_and_read(\r\ndev_data->client,\r\nMS_SENSORS_TP_T_CONVERSION_START +\r\ndev_data->res_index * 2,\r\nMS_SENSORS_TP_ADC_READ,\r\ndelay, &t_adc);\r\nif (ret) {\r\nmutex_unlock(&dev_data->lock);\r\nreturn ret;\r\n}\r\nret = ms_sensors_convert_and_read(\r\ndev_data->client,\r\nMS_SENSORS_TP_P_CONVERSION_START +\r\ndev_data->res_index * 2,\r\nMS_SENSORS_TP_ADC_READ,\r\ndelay, &p_adc);\r\nmutex_unlock(&dev_data->lock);\r\nif (ret)\r\nreturn ret;\r\ndt = (s32)t_adc - (prom[5] << 8);\r\ntemp = 2000 + (((s64)dt * prom[6]) >> 23);\r\nif (temp < 2000) {\r\ns64 tmp = (s64)temp - 2000;\r\nt2 = (3 * ((s64)dt * (s64)dt)) >> 33;\r\noff2 = (61 * tmp * tmp) >> 4;\r\nsens2 = (29 * tmp * tmp) >> 4;\r\nif (temp < -1500) {\r\ns64 tmp = (s64)temp + 1500;\r\noff2 += 17 * tmp * tmp;\r\nsens2 += 9 * tmp * tmp;\r\n}\r\n} else {\r\nt2 = (5 * ((s64)dt * (s64)dt)) >> 38;\r\noff2 = 0;\r\nsens2 = 0;\r\n}\r\noff = (((s64)prom[2]) << 17) + ((((s64)prom[4]) * (s64)dt) >> 6);\r\noff -= off2;\r\nsens = (((s64)prom[1]) << 16) + (((s64)prom[3] * dt) >> 7);\r\nsens -= sens2;\r\n*temperature = (temp - t2) * 10;\r\n*pressure = (u32)(((((s64)p_adc * sens) >> 21) - off) >> 15);\r\nreturn 0;\r\n}
