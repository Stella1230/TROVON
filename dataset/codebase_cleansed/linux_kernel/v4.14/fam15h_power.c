static bool is_carrizo_or_later(void)\r\n{\r\nreturn boot_cpu_data.x86 == 0x15 && boot_cpu_data.x86_model >= 0x60;\r\n}\r\nstatic ssize_t power1_input_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu32 val, tdp_limit, running_avg_range;\r\ns32 running_avg_capture;\r\nu64 curr_pwr_watts;\r\nstruct fam15h_power_data *data = dev_get_drvdata(dev);\r\nstruct pci_dev *f4 = data->pdev;\r\npci_bus_read_config_dword(f4->bus, PCI_DEVFN(PCI_SLOT(f4->devfn), 5),\r\nREG_TDP_RUNNING_AVERAGE, &val);\r\nif (is_carrizo_or_later()) {\r\nrunning_avg_capture = val >> 4;\r\nrunning_avg_capture = sign_extend32(running_avg_capture, 27);\r\n} else {\r\nrunning_avg_capture = (val >> 4) & 0x3fffff;\r\nrunning_avg_capture = sign_extend32(running_avg_capture, 21);\r\n}\r\nrunning_avg_range = (val & 0xf) + 1;\r\npci_bus_read_config_dword(f4->bus, PCI_DEVFN(PCI_SLOT(f4->devfn), 5),\r\nREG_TDP_LIMIT3, &val);\r\nif (is_carrizo_or_later())\r\ntdp_limit = val >> 16;\r\nelse\r\ntdp_limit = (val >> 16) & 0x1fff;\r\ncurr_pwr_watts = ((u64)(tdp_limit +\r\ndata->base_tdp)) << running_avg_range;\r\ncurr_pwr_watts -= running_avg_capture;\r\ncurr_pwr_watts *= data->tdp_to_watts;\r\ncurr_pwr_watts = (curr_pwr_watts * 15625) >> (10 + running_avg_range);\r\nreturn sprintf(buf, "%u\n", (unsigned int) curr_pwr_watts);\r\n}\r\nstatic ssize_t power1_crit_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fam15h_power_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", data->processor_pwr_watts);\r\n}\r\nstatic void do_read_registers_on_cu(void *_data)\r\n{\r\nstruct fam15h_power_data *data = _data;\r\nint cpu, cu;\r\ncpu = smp_processor_id();\r\ncu = cpu_data(cpu).cpu_core_id;\r\nrdmsrl_safe(MSR_F15H_CU_PWR_ACCUMULATOR, &data->cu_acc_power[cu]);\r\nrdmsrl_safe(MSR_F15H_PTSC, &data->cpu_sw_pwr_ptsc[cu]);\r\ndata->cu_on[cu] = 1;\r\n}\r\nstatic int read_registers(struct fam15h_power_data *data)\r\n{\r\nint core, this_core;\r\ncpumask_var_t mask;\r\nint ret, cpu;\r\nret = zalloc_cpumask_var(&mask, GFP_KERNEL);\r\nif (!ret)\r\nreturn -ENOMEM;\r\nmemset(data->cu_on, 0, sizeof(int) * MAX_CUS);\r\nget_online_cpus();\r\ncore = -1;\r\nfor_each_online_cpu(cpu) {\r\nthis_core = topology_core_id(cpu);\r\nif (this_core == core)\r\ncontinue;\r\ncore = this_core;\r\ncpumask_set_cpu(cpumask_any(topology_sibling_cpumask(cpu)), mask);\r\n}\r\non_each_cpu_mask(mask, do_read_registers_on_cu, data, true);\r\nput_online_cpus();\r\nfree_cpumask_var(mask);\r\nreturn 0;\r\n}\r\nstatic ssize_t power1_average_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fam15h_power_data *data = dev_get_drvdata(dev);\r\nu64 prev_cu_acc_power[MAX_CUS], prev_ptsc[MAX_CUS],\r\njdelta[MAX_CUS];\r\nu64 tdelta, avg_acc;\r\nint cu, cu_num, ret;\r\nsigned long leftover;\r\ncu_num = boot_cpu_data.x86_max_cores;\r\nret = read_registers(data);\r\nif (ret)\r\nreturn 0;\r\nfor (cu = 0; cu < cu_num; cu++) {\r\nprev_cu_acc_power[cu] = data->cu_acc_power[cu];\r\nprev_ptsc[cu] = data->cpu_sw_pwr_ptsc[cu];\r\n}\r\nleftover = schedule_timeout_interruptible(msecs_to_jiffies(data->power_period));\r\nif (leftover)\r\nreturn 0;\r\nret = read_registers(data);\r\nif (ret)\r\nreturn 0;\r\nfor (cu = 0, avg_acc = 0; cu < cu_num; cu++) {\r\nif (data->cu_on[cu] == 0)\r\ncontinue;\r\nif (data->cu_acc_power[cu] < prev_cu_acc_power[cu]) {\r\njdelta[cu] = data->max_cu_acc_power + data->cu_acc_power[cu];\r\njdelta[cu] -= prev_cu_acc_power[cu];\r\n} else {\r\njdelta[cu] = data->cu_acc_power[cu] - prev_cu_acc_power[cu];\r\n}\r\ntdelta = data->cpu_sw_pwr_ptsc[cu] - prev_ptsc[cu];\r\njdelta[cu] *= data->cpu_pwr_sample_ratio * 1000;\r\ndo_div(jdelta[cu], tdelta);\r\navg_acc += jdelta[cu];\r\n}\r\nreturn sprintf(buf, "%llu\n", (unsigned long long)avg_acc);\r\n}\r\nstatic ssize_t power1_average_interval_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fam15h_power_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%lu\n", data->power_period);\r\n}\r\nstatic ssize_t power1_average_interval_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fam15h_power_data *data = dev_get_drvdata(dev);\r\nunsigned long temp;\r\nint ret;\r\nret = kstrtoul(buf, 10, &temp);\r\nif (ret)\r\nreturn ret;\r\nif (temp > MAX_INTERVAL)\r\nreturn -EINVAL;\r\nif (temp <= 0)\r\nreturn -EINVAL;\r\ndata->power_period = temp;\r\nreturn count;\r\n}\r\nstatic int fam15h_power_init_attrs(struct pci_dev *pdev,\r\nstruct fam15h_power_data *data)\r\n{\r\nint n = FAM15H_MIN_NUM_ATTRS;\r\nstruct attribute **fam15h_power_attrs;\r\nstruct cpuinfo_x86 *c = &boot_cpu_data;\r\nif (c->x86 == 0x15 &&\r\n(c->x86_model <= 0xf ||\r\n(c->x86_model >= 0x60 && c->x86_model <= 0x7f)))\r\nn += 1;\r\nif (boot_cpu_has(X86_FEATURE_ACC_POWER))\r\nn += 2;\r\nfam15h_power_attrs = devm_kcalloc(&pdev->dev, n,\r\nsizeof(*fam15h_power_attrs),\r\nGFP_KERNEL);\r\nif (!fam15h_power_attrs)\r\nreturn -ENOMEM;\r\nn = 0;\r\nfam15h_power_attrs[n++] = &dev_attr_power1_crit.attr;\r\nif (c->x86 == 0x15 &&\r\n(c->x86_model <= 0xf ||\r\n(c->x86_model >= 0x60 && c->x86_model <= 0x7f)))\r\nfam15h_power_attrs[n++] = &dev_attr_power1_input.attr;\r\nif (boot_cpu_has(X86_FEATURE_ACC_POWER)) {\r\nfam15h_power_attrs[n++] = &dev_attr_power1_average.attr;\r\nfam15h_power_attrs[n++] = &dev_attr_power1_average_interval.attr;\r\n}\r\ndata->group.attrs = fam15h_power_attrs;\r\nreturn 0;\r\n}\r\nstatic bool should_load_on_this_node(struct pci_dev *f4)\r\n{\r\nu32 val;\r\npci_bus_read_config_dword(f4->bus, PCI_DEVFN(PCI_SLOT(f4->devfn), 3),\r\nREG_NORTHBRIDGE_CAP, &val);\r\nif ((val & BIT(29)) && ((val >> 30) & 3))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void tweak_runavg_range(struct pci_dev *pdev)\r\n{\r\nu32 val;\r\nif (!pci_match_id(affected_device, pdev))\r\nreturn;\r\npci_bus_read_config_dword(pdev->bus,\r\nPCI_DEVFN(PCI_SLOT(pdev->devfn), 5),\r\nREG_TDP_RUNNING_AVERAGE, &val);\r\nif ((val & 0xf) != 0xe)\r\nreturn;\r\nval &= ~0xf;\r\nval |= 0x9;\r\npci_bus_write_config_dword(pdev->bus,\r\nPCI_DEVFN(PCI_SLOT(pdev->devfn), 5),\r\nREG_TDP_RUNNING_AVERAGE, val);\r\n}\r\nstatic int fam15h_power_resume(struct pci_dev *pdev)\r\n{\r\ntweak_runavg_range(pdev);\r\nreturn 0;\r\n}\r\nstatic int fam15h_power_init_data(struct pci_dev *f4,\r\nstruct fam15h_power_data *data)\r\n{\r\nu32 val;\r\nu64 tmp;\r\nint ret;\r\npci_read_config_dword(f4, REG_PROCESSOR_TDP, &val);\r\ndata->base_tdp = val >> 16;\r\ntmp = val & 0xffff;\r\npci_bus_read_config_dword(f4->bus, PCI_DEVFN(PCI_SLOT(f4->devfn), 5),\r\nREG_TDP_LIMIT3, &val);\r\ndata->tdp_to_watts = ((val & 0x3ff) << 6) | ((val >> 10) & 0x3f);\r\ntmp *= data->tdp_to_watts;\r\nif ((tmp >> 16) >= 256)\r\ndev_warn(&f4->dev,\r\n"Bogus value for ProcessorPwrWatts (processor_pwr_watts>=%u)\n",\r\n(unsigned int) (tmp >> 16));\r\ndata->processor_pwr_watts = (tmp * 15625) >> 10;\r\nret = fam15h_power_init_attrs(f4, data);\r\nif (ret)\r\nreturn ret;\r\nif (!boot_cpu_has(X86_FEATURE_ACC_POWER))\r\nreturn 0;\r\ndata->cpu_pwr_sample_ratio = cpuid_ecx(0x80000007);\r\nif (rdmsrl_safe(MSR_F15H_CU_MAX_PWR_ACCUMULATOR, &tmp)) {\r\npr_err("Failed to read max compute unit power accumulator MSR\n");\r\nreturn -ENODEV;\r\n}\r\ndata->max_cu_acc_power = tmp;\r\ndata->power_period = 10;\r\nreturn read_registers(data);\r\n}\r\nstatic int fam15h_power_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct fam15h_power_data *data;\r\nstruct device *dev = &pdev->dev;\r\nstruct device *hwmon_dev;\r\nint ret;\r\ntweak_runavg_range(pdev);\r\nif (!should_load_on_this_node(pdev))\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(dev, sizeof(struct fam15h_power_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nret = fam15h_power_init_data(pdev, data);\r\nif (ret)\r\nreturn ret;\r\ndata->pdev = pdev;\r\ndata->groups[0] = &data->group;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, "fam15h_power",\r\ndata,\r\n&data->groups[0]);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
