void\r\nnvkm_outp_route(struct nvkm_disp *disp)\r\n{\r\nstruct nvkm_outp *outp;\r\nstruct nvkm_ior *ior;\r\nlist_for_each_entry(ior, &disp->ior, head) {\r\nif ((outp = ior->arm.outp) && ior->arm.outp != ior->asy.outp) {\r\nOUTP_DBG(outp, "release %s", ior->name);\r\nif (ior->func->route.set)\r\nior->func->route.set(outp, NULL);\r\nior->arm.outp = NULL;\r\n}\r\n}\r\nlist_for_each_entry(ior, &disp->ior, head) {\r\nif ((outp = ior->asy.outp)) {\r\nOUTP_DBG(outp, "acquire %s", ior->name);\r\nif (ior->asy.outp != ior->arm.outp) {\r\nif (ior->func->route.set)\r\nior->func->route.set(outp, ior);\r\nior->arm.outp = ior->asy.outp;\r\n}\r\n}\r\n}\r\n}\r\nstatic enum nvkm_ior_proto\r\nnvkm_outp_xlat(struct nvkm_outp *outp, enum nvkm_ior_type *type)\r\n{\r\nswitch (outp->info.location) {\r\ncase 0:\r\nswitch (outp->info.type) {\r\ncase DCB_OUTPUT_ANALOG: *type = DAC; return CRT;\r\ncase DCB_OUTPUT_TV : *type = DAC; return TV;\r\ncase DCB_OUTPUT_TMDS : *type = SOR; return TMDS;\r\ncase DCB_OUTPUT_LVDS : *type = SOR; return LVDS;\r\ncase DCB_OUTPUT_DP : *type = SOR; return DP;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase 1:\r\nswitch (outp->info.type) {\r\ncase DCB_OUTPUT_TMDS: *type = PIOR; return TMDS;\r\ncase DCB_OUTPUT_DP : *type = PIOR; return TMDS;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nWARN_ON(1);\r\nreturn UNKNOWN;\r\n}\r\nvoid\r\nnvkm_outp_release(struct nvkm_outp *outp, u8 user)\r\n{\r\nstruct nvkm_ior *ior = outp->ior;\r\nOUTP_TRACE(outp, "release %02x &= %02x %p", outp->acquired, ~user, ior);\r\nif (ior) {\r\noutp->acquired &= ~user;\r\nif (!outp->acquired) {\r\noutp->ior->asy.outp = NULL;\r\noutp->ior = NULL;\r\n}\r\n}\r\n}\r\nstatic inline int\r\nnvkm_outp_acquire_ior(struct nvkm_outp *outp, u8 user, struct nvkm_ior *ior)\r\n{\r\noutp->ior = ior;\r\noutp->ior->asy.outp = outp;\r\noutp->ior->asy.link = outp->info.sorconf.link;\r\noutp->acquired |= user;\r\nreturn 0;\r\n}\r\nint\r\nnvkm_outp_acquire(struct nvkm_outp *outp, u8 user)\r\n{\r\nstruct nvkm_ior *ior = outp->ior;\r\nenum nvkm_ior_proto proto;\r\nenum nvkm_ior_type type;\r\nOUTP_TRACE(outp, "acquire %02x |= %02x %p", outp->acquired, user, ior);\r\nif (ior) {\r\noutp->acquired |= user;\r\nreturn 0;\r\n}\r\nproto = nvkm_outp_xlat(outp, &type);\r\nif (proto == UNKNOWN)\r\nreturn -ENOSYS;\r\nlist_for_each_entry(ior, &outp->disp->ior, head) {\r\nif (!ior->asy.outp && ior->arm.outp == outp)\r\nreturn nvkm_outp_acquire_ior(outp, user, ior);\r\n}\r\nlist_for_each_entry(ior, &outp->disp->ior, head) {\r\nif (!ior->asy.outp && ior->type == type && !ior->arm.outp &&\r\n(ior->func->route.set || ior->id == __ffs(outp->info.or)))\r\nreturn nvkm_outp_acquire_ior(outp, user, ior);\r\n}\r\nlist_for_each_entry(ior, &outp->disp->ior, head) {\r\nif (!ior->asy.outp && ior->type == type &&\r\n(ior->func->route.set || ior->id == __ffs(outp->info.or)))\r\nreturn nvkm_outp_acquire_ior(outp, user, ior);\r\n}\r\nreturn -ENOSPC;\r\n}\r\nvoid\r\nnvkm_outp_fini(struct nvkm_outp *outp)\r\n{\r\nif (outp->func->fini)\r\noutp->func->fini(outp);\r\n}\r\nstatic void\r\nnvkm_outp_init_route(struct nvkm_outp *outp)\r\n{\r\nstruct nvkm_disp *disp = outp->disp;\r\nenum nvkm_ior_proto proto;\r\nenum nvkm_ior_type type;\r\nstruct nvkm_ior *ior;\r\nint id, link;\r\nproto = nvkm_outp_xlat(outp, &type);\r\nif (proto == UNKNOWN)\r\nreturn;\r\nior = nvkm_ior_find(disp, type, -1);\r\nif (!ior) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nif (ior->func->route.get) {\r\nid = ior->func->route.get(outp, &link);\r\nif (id < 0) {\r\nOUTP_DBG(outp, "no route");\r\nreturn;\r\n}\r\n} else {\r\nid = ffs(outp->info.or) - 1;\r\nlink = (ior->type == SOR) ? outp->info.sorconf.link : 0;\r\n}\r\nior = nvkm_ior_find(disp, type, id);\r\nif (!ior) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nior->func->state(ior, &ior->arm);\r\nif (!ior->arm.head || ior->arm.proto != proto) {\r\nOUTP_DBG(outp, "no heads (%x %d %d)", ior->arm.head,\r\nior->arm.proto, proto);\r\nreturn;\r\n}\r\nOUTP_DBG(outp, "on %s link %x", ior->name, ior->arm.link);\r\nior->arm.outp = outp;\r\n}\r\nvoid\r\nnvkm_outp_init(struct nvkm_outp *outp)\r\n{\r\nnvkm_outp_init_route(outp);\r\nif (outp->func->init)\r\noutp->func->init(outp);\r\n}\r\nvoid\r\nnvkm_outp_del(struct nvkm_outp **poutp)\r\n{\r\nstruct nvkm_outp *outp = *poutp;\r\nif (outp && !WARN_ON(!outp->func)) {\r\nif (outp->func->dtor)\r\n*poutp = outp->func->dtor(outp);\r\nkfree(*poutp);\r\n*poutp = NULL;\r\n}\r\n}\r\nint\r\nnvkm_outp_ctor(const struct nvkm_outp_func *func, struct nvkm_disp *disp,\r\nint index, struct dcb_output *dcbE, struct nvkm_outp *outp)\r\n{\r\nstruct nvkm_i2c *i2c = disp->engine.subdev.device->i2c;\r\nenum nvkm_ior_proto proto;\r\nenum nvkm_ior_type type;\r\noutp->func = func;\r\noutp->disp = disp;\r\noutp->index = index;\r\noutp->info = *dcbE;\r\noutp->i2c = nvkm_i2c_bus_find(i2c, dcbE->i2c_index);\r\noutp->or = ffs(outp->info.or) - 1;\r\nOUTP_DBG(outp, "type %02x loc %d or %d link %d con %x "\r\n"edid %x bus %d head %x",\r\noutp->info.type, outp->info.location, outp->info.or,\r\noutp->info.type >= 2 ? outp->info.sorconf.link : 0,\r\noutp->info.connector, outp->info.i2c_index,\r\noutp->info.bus, outp->info.heads);\r\nproto = nvkm_outp_xlat(outp, &type);\r\nif (proto == UNKNOWN)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nint\r\nnvkm_outp_new(struct nvkm_disp *disp, int index, struct dcb_output *dcbE,\r\nstruct nvkm_outp **poutp)\r\n{\r\nif (!(*poutp = kzalloc(sizeof(**poutp), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nreturn nvkm_outp_ctor(&nvkm_outp, disp, index, dcbE, *poutp);\r\n}
