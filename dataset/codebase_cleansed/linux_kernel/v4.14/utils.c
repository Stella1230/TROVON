int net_ratelimit(void)\r\n{\r\nreturn __ratelimit(&net_ratelimit_state);\r\n}\r\n__be32 in_aton(const char *str)\r\n{\r\nunsigned int l;\r\nunsigned int val;\r\nint i;\r\nl = 0;\r\nfor (i = 0; i < 4; i++) {\r\nl <<= 8;\r\nif (*str != '\0') {\r\nval = 0;\r\nwhile (*str != '\0' && *str != '.' && *str != '\n') {\r\nval *= 10;\r\nval += *str - '0';\r\nstr++;\r\n}\r\nl |= val;\r\nif (*str != '\0')\r\nstr++;\r\n}\r\n}\r\nreturn htonl(l);\r\n}\r\nstatic inline int xdigit2bin(char c, int delim)\r\n{\r\nint val;\r\nif (c == delim || c == '\0')\r\nreturn IN6PTON_DELIM;\r\nif (c == ':')\r\nreturn IN6PTON_COLON_MASK;\r\nif (c == '.')\r\nreturn IN6PTON_DOT;\r\nval = hex_to_bin(c);\r\nif (val >= 0)\r\nreturn val | IN6PTON_XDIGIT | (val < 10 ? IN6PTON_DIGIT : 0);\r\nif (delim == -1)\r\nreturn IN6PTON_DELIM;\r\nreturn IN6PTON_UNKNOWN;\r\n}\r\nint in4_pton(const char *src, int srclen,\r\nu8 *dst,\r\nint delim, const char **end)\r\n{\r\nconst char *s;\r\nu8 *d;\r\nu8 dbuf[4];\r\nint ret = 0;\r\nint i;\r\nint w = 0;\r\nif (srclen < 0)\r\nsrclen = strlen(src);\r\ns = src;\r\nd = dbuf;\r\ni = 0;\r\nwhile (1) {\r\nint c;\r\nc = xdigit2bin(srclen > 0 ? *s : '\0', delim);\r\nif (!(c & (IN6PTON_DIGIT | IN6PTON_DOT | IN6PTON_DELIM | IN6PTON_COLON_MASK))) {\r\ngoto out;\r\n}\r\nif (c & (IN6PTON_DOT | IN6PTON_DELIM | IN6PTON_COLON_MASK)) {\r\nif (w == 0)\r\ngoto out;\r\n*d++ = w & 0xff;\r\nw = 0;\r\ni++;\r\nif (c & (IN6PTON_DELIM | IN6PTON_COLON_MASK)) {\r\nif (i != 4)\r\ngoto out;\r\nbreak;\r\n}\r\ngoto cont;\r\n}\r\nw = (w * 10) + c;\r\nif ((w & 0xffff) > 255) {\r\ngoto out;\r\n}\r\ncont:\r\nif (i >= 4)\r\ngoto out;\r\ns++;\r\nsrclen--;\r\n}\r\nret = 1;\r\nmemcpy(dst, dbuf, sizeof(dbuf));\r\nout:\r\nif (end)\r\n*end = s;\r\nreturn ret;\r\n}\r\nint in6_pton(const char *src, int srclen,\r\nu8 *dst,\r\nint delim, const char **end)\r\n{\r\nconst char *s, *tok = NULL;\r\nu8 *d, *dc = NULL;\r\nu8 dbuf[16];\r\nint ret = 0;\r\nint i;\r\nint state = IN6PTON_COLON_1_2 | IN6PTON_XDIGIT | IN6PTON_NULL;\r\nint w = 0;\r\nmemset(dbuf, 0, sizeof(dbuf));\r\ns = src;\r\nd = dbuf;\r\nif (srclen < 0)\r\nsrclen = strlen(src);\r\nwhile (1) {\r\nint c;\r\nc = xdigit2bin(srclen > 0 ? *s : '\0', delim);\r\nif (!(c & state))\r\ngoto out;\r\nif (c & (IN6PTON_DELIM | IN6PTON_COLON_MASK)) {\r\nif (!(state & IN6PTON_NULL)) {\r\n*d++ = (w >> 8) & 0xff;\r\n*d++ = w & 0xff;\r\n}\r\nw = 0;\r\nif (c & IN6PTON_DELIM) {\r\nbreak;\r\n}\r\nswitch (state & IN6PTON_COLON_MASK) {\r\ncase IN6PTON_COLON_2:\r\ndc = d;\r\nstate = IN6PTON_XDIGIT | IN6PTON_DELIM;\r\nif (dc - dbuf >= sizeof(dbuf))\r\nstate |= IN6PTON_NULL;\r\nbreak;\r\ncase IN6PTON_COLON_1|IN6PTON_COLON_1_2:\r\nstate = IN6PTON_XDIGIT | IN6PTON_COLON_2;\r\nbreak;\r\ncase IN6PTON_COLON_1:\r\nstate = IN6PTON_XDIGIT;\r\nbreak;\r\ncase IN6PTON_COLON_1_2:\r\nstate = IN6PTON_COLON_2;\r\nbreak;\r\ndefault:\r\nstate = 0;\r\n}\r\ntok = s + 1;\r\ngoto cont;\r\n}\r\nif (c & IN6PTON_DOT) {\r\nret = in4_pton(tok ? tok : s, srclen + (int)(s - tok), d, delim, &s);\r\nif (ret > 0) {\r\nd += 4;\r\nbreak;\r\n}\r\ngoto out;\r\n}\r\nw = (w << 4) | (0xff & c);\r\nstate = IN6PTON_COLON_1 | IN6PTON_DELIM;\r\nif (!(w & 0xf000)) {\r\nstate |= IN6PTON_XDIGIT;\r\n}\r\nif (!dc && d + 2 < dbuf + sizeof(dbuf)) {\r\nstate |= IN6PTON_COLON_1_2;\r\nstate &= ~IN6PTON_DELIM;\r\n}\r\nif (d + 2 >= dbuf + sizeof(dbuf)) {\r\nstate &= ~(IN6PTON_COLON_1|IN6PTON_COLON_1_2);\r\n}\r\ncont:\r\nif ((dc && d + 4 < dbuf + sizeof(dbuf)) ||\r\nd + 4 == dbuf + sizeof(dbuf)) {\r\nstate |= IN6PTON_DOT;\r\n}\r\nif (d >= dbuf + sizeof(dbuf)) {\r\nstate &= ~(IN6PTON_XDIGIT|IN6PTON_COLON_MASK);\r\n}\r\ns++;\r\nsrclen--;\r\n}\r\ni = 15; d--;\r\nif (dc) {\r\nwhile (d >= dc)\r\ndst[i--] = *d--;\r\nwhile (i >= dc - dbuf)\r\ndst[i--] = 0;\r\nwhile (i >= 0)\r\ndst[i--] = *d--;\r\n} else\r\nmemcpy(dst, dbuf, sizeof(dbuf));\r\nret = 1;\r\nout:\r\nif (end)\r\n*end = s;\r\nreturn ret;\r\n}\r\nstatic int inet4_pton(const char *src, u16 port_num,\r\nstruct sockaddr_storage *addr)\r\n{\r\nstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\r\nint srclen = strlen(src);\r\nif (srclen > INET_ADDRSTRLEN)\r\nreturn -EINVAL;\r\nif (in4_pton(src, srclen, (u8 *)&addr4->sin_addr.s_addr,\r\n'\n', NULL) == 0)\r\nreturn -EINVAL;\r\naddr4->sin_family = AF_INET;\r\naddr4->sin_port = htons(port_num);\r\nreturn 0;\r\n}\r\nstatic int inet6_pton(struct net *net, const char *src, u16 port_num,\r\nstruct sockaddr_storage *addr)\r\n{\r\nstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\r\nconst char *scope_delim;\r\nint srclen = strlen(src);\r\nif (srclen > INET6_ADDRSTRLEN)\r\nreturn -EINVAL;\r\nif (in6_pton(src, srclen, (u8 *)&addr6->sin6_addr.s6_addr,\r\n'%', &scope_delim) == 0)\r\nreturn -EINVAL;\r\nif (ipv6_addr_type(&addr6->sin6_addr) & IPV6_ADDR_LINKLOCAL &&\r\nsrc + srclen != scope_delim && *scope_delim == '%') {\r\nstruct net_device *dev;\r\nchar scope_id[16];\r\nsize_t scope_len = min_t(size_t, sizeof(scope_id) - 1,\r\nsrc + srclen - scope_delim - 1);\r\nmemcpy(scope_id, scope_delim + 1, scope_len);\r\nscope_id[scope_len] = '\0';\r\ndev = dev_get_by_name(net, scope_id);\r\nif (dev) {\r\naddr6->sin6_scope_id = dev->ifindex;\r\ndev_put(dev);\r\n} else if (kstrtouint(scope_id, 0, &addr6->sin6_scope_id)) {\r\nreturn -EINVAL;\r\n}\r\n}\r\naddr6->sin6_family = AF_INET6;\r\naddr6->sin6_port = htons(port_num);\r\nreturn 0;\r\n}\r\nint inet_pton_with_scope(struct net *net, __kernel_sa_family_t af,\r\nconst char *src, const char *port, struct sockaddr_storage *addr)\r\n{\r\nu16 port_num;\r\nint ret = -EINVAL;\r\nif (port) {\r\nif (kstrtou16(port, 0, &port_num))\r\nreturn -EINVAL;\r\n} else {\r\nport_num = 0;\r\n}\r\nswitch (af) {\r\ncase AF_INET:\r\nret = inet4_pton(src, port_num, addr);\r\nbreak;\r\ncase AF_INET6:\r\nret = inet6_pton(net, src, port_num, addr);\r\nbreak;\r\ncase AF_UNSPEC:\r\nret = inet4_pton(src, port_num, addr);\r\nif (ret)\r\nret = inet6_pton(net, src, port_num, addr);\r\nbreak;\r\ndefault:\r\npr_err("unexpected address family %d\n", af);\r\n};\r\nreturn ret;\r\n}\r\nvoid inet_proto_csum_replace4(__sum16 *sum, struct sk_buff *skb,\r\n__be32 from, __be32 to, bool pseudohdr)\r\n{\r\nif (skb->ip_summed != CHECKSUM_PARTIAL) {\r\ncsum_replace4(sum, from, to);\r\nif (skb->ip_summed == CHECKSUM_COMPLETE && pseudohdr)\r\nskb->csum = ~csum_add(csum_sub(~(skb->csum),\r\n(__force __wsum)from),\r\n(__force __wsum)to);\r\n} else if (pseudohdr)\r\n*sum = ~csum_fold(csum_add(csum_sub(csum_unfold(*sum),\r\n(__force __wsum)from),\r\n(__force __wsum)to));\r\n}\r\nvoid inet_proto_csum_replace16(__sum16 *sum, struct sk_buff *skb,\r\nconst __be32 *from, const __be32 *to,\r\nbool pseudohdr)\r\n{\r\n__be32 diff[] = {\r\n~from[0], ~from[1], ~from[2], ~from[3],\r\nto[0], to[1], to[2], to[3],\r\n};\r\nif (skb->ip_summed != CHECKSUM_PARTIAL) {\r\n*sum = csum_fold(csum_partial(diff, sizeof(diff),\r\n~csum_unfold(*sum)));\r\nif (skb->ip_summed == CHECKSUM_COMPLETE && pseudohdr)\r\nskb->csum = ~csum_partial(diff, sizeof(diff),\r\n~skb->csum);\r\n} else if (pseudohdr)\r\n*sum = ~csum_fold(csum_partial(diff, sizeof(diff),\r\ncsum_unfold(*sum)));\r\n}\r\nvoid inet_proto_csum_replace_by_diff(__sum16 *sum, struct sk_buff *skb,\r\n__wsum diff, bool pseudohdr)\r\n{\r\nif (skb->ip_summed != CHECKSUM_PARTIAL) {\r\n*sum = csum_fold(csum_add(diff, ~csum_unfold(*sum)));\r\nif (skb->ip_summed == CHECKSUM_COMPLETE && pseudohdr)\r\nskb->csum = ~csum_add(diff, ~skb->csum);\r\n} else if (pseudohdr) {\r\n*sum = ~csum_fold(csum_add(diff, csum_unfold(*sum)));\r\n}\r\n}
