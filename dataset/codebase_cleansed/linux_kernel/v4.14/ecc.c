static inline const struct ecc_curve *ecc_get_curve(unsigned int curve_id)\r\n{\r\nswitch (curve_id) {\r\ncase ECC_CURVE_NIST_P192:\r\nreturn fips_enabled ? NULL : &nist_p192;\r\ncase ECC_CURVE_NIST_P256:\r\nreturn &nist_p256;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic u64 *ecc_alloc_digits_space(unsigned int ndigits)\r\n{\r\nsize_t len = ndigits * sizeof(u64);\r\nif (!len)\r\nreturn NULL;\r\nreturn kmalloc(len, GFP_KERNEL);\r\n}\r\nstatic void ecc_free_digits_space(u64 *space)\r\n{\r\nkzfree(space);\r\n}\r\nstatic struct ecc_point *ecc_alloc_point(unsigned int ndigits)\r\n{\r\nstruct ecc_point *p = kmalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn NULL;\r\np->x = ecc_alloc_digits_space(ndigits);\r\nif (!p->x)\r\ngoto err_alloc_x;\r\np->y = ecc_alloc_digits_space(ndigits);\r\nif (!p->y)\r\ngoto err_alloc_y;\r\np->ndigits = ndigits;\r\nreturn p;\r\nerr_alloc_y:\r\necc_free_digits_space(p->x);\r\nerr_alloc_x:\r\nkfree(p);\r\nreturn NULL;\r\n}\r\nstatic void ecc_free_point(struct ecc_point *p)\r\n{\r\nif (!p)\r\nreturn;\r\nkzfree(p->x);\r\nkzfree(p->y);\r\nkzfree(p);\r\n}\r\nstatic void vli_clear(u64 *vli, unsigned int ndigits)\r\n{\r\nint i;\r\nfor (i = 0; i < ndigits; i++)\r\nvli[i] = 0;\r\n}\r\nstatic bool vli_is_zero(const u64 *vli, unsigned int ndigits)\r\n{\r\nint i;\r\nfor (i = 0; i < ndigits; i++) {\r\nif (vli[i])\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic u64 vli_test_bit(const u64 *vli, unsigned int bit)\r\n{\r\nreturn (vli[bit / 64] & ((u64)1 << (bit % 64)));\r\n}\r\nstatic unsigned int vli_num_digits(const u64 *vli, unsigned int ndigits)\r\n{\r\nint i;\r\nfor (i = ndigits - 1; i >= 0 && vli[i] == 0; i--);\r\nreturn (i + 1);\r\n}\r\nstatic unsigned int vli_num_bits(const u64 *vli, unsigned int ndigits)\r\n{\r\nunsigned int i, num_digits;\r\nu64 digit;\r\nnum_digits = vli_num_digits(vli, ndigits);\r\nif (num_digits == 0)\r\nreturn 0;\r\ndigit = vli[num_digits - 1];\r\nfor (i = 0; digit; i++)\r\ndigit >>= 1;\r\nreturn ((num_digits - 1) * 64 + i);\r\n}\r\nstatic void vli_set(u64 *dest, const u64 *src, unsigned int ndigits)\r\n{\r\nint i;\r\nfor (i = 0; i < ndigits; i++)\r\ndest[i] = src[i];\r\n}\r\nstatic int vli_cmp(const u64 *left, const u64 *right, unsigned int ndigits)\r\n{\r\nint i;\r\nfor (i = ndigits - 1; i >= 0; i--) {\r\nif (left[i] > right[i])\r\nreturn 1;\r\nelse if (left[i] < right[i])\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic u64 vli_lshift(u64 *result, const u64 *in, unsigned int shift,\r\nunsigned int ndigits)\r\n{\r\nu64 carry = 0;\r\nint i;\r\nfor (i = 0; i < ndigits; i++) {\r\nu64 temp = in[i];\r\nresult[i] = (temp << shift) | carry;\r\ncarry = temp >> (64 - shift);\r\n}\r\nreturn carry;\r\n}\r\nstatic void vli_rshift1(u64 *vli, unsigned int ndigits)\r\n{\r\nu64 *end = vli;\r\nu64 carry = 0;\r\nvli += ndigits;\r\nwhile (vli-- > end) {\r\nu64 temp = *vli;\r\n*vli = (temp >> 1) | carry;\r\ncarry = temp << 63;\r\n}\r\n}\r\nstatic u64 vli_add(u64 *result, const u64 *left, const u64 *right,\r\nunsigned int ndigits)\r\n{\r\nu64 carry = 0;\r\nint i;\r\nfor (i = 0; i < ndigits; i++) {\r\nu64 sum;\r\nsum = left[i] + right[i] + carry;\r\nif (sum != left[i])\r\ncarry = (sum < left[i]);\r\nresult[i] = sum;\r\n}\r\nreturn carry;\r\n}\r\nstatic u64 vli_sub(u64 *result, const u64 *left, const u64 *right,\r\nunsigned int ndigits)\r\n{\r\nu64 borrow = 0;\r\nint i;\r\nfor (i = 0; i < ndigits; i++) {\r\nu64 diff;\r\ndiff = left[i] - right[i] - borrow;\r\nif (diff != left[i])\r\nborrow = (diff > left[i]);\r\nresult[i] = diff;\r\n}\r\nreturn borrow;\r\n}\r\nstatic uint128_t mul_64_64(u64 left, u64 right)\r\n{\r\nu64 a0 = left & 0xffffffffull;\r\nu64 a1 = left >> 32;\r\nu64 b0 = right & 0xffffffffull;\r\nu64 b1 = right >> 32;\r\nu64 m0 = a0 * b0;\r\nu64 m1 = a0 * b1;\r\nu64 m2 = a1 * b0;\r\nu64 m3 = a1 * b1;\r\nuint128_t result;\r\nm2 += (m0 >> 32);\r\nm2 += m1;\r\nif (m2 < m1)\r\nm3 += 0x100000000ull;\r\nresult.m_low = (m0 & 0xffffffffull) | (m2 << 32);\r\nresult.m_high = m3 + (m2 >> 32);\r\nreturn result;\r\n}\r\nstatic uint128_t add_128_128(uint128_t a, uint128_t b)\r\n{\r\nuint128_t result;\r\nresult.m_low = a.m_low + b.m_low;\r\nresult.m_high = a.m_high + b.m_high + (result.m_low < a.m_low);\r\nreturn result;\r\n}\r\nstatic void vli_mult(u64 *result, const u64 *left, const u64 *right,\r\nunsigned int ndigits)\r\n{\r\nuint128_t r01 = { 0, 0 };\r\nu64 r2 = 0;\r\nunsigned int i, k;\r\nfor (k = 0; k < ndigits * 2 - 1; k++) {\r\nunsigned int min;\r\nif (k < ndigits)\r\nmin = 0;\r\nelse\r\nmin = (k + 1) - ndigits;\r\nfor (i = min; i <= k && i < ndigits; i++) {\r\nuint128_t product;\r\nproduct = mul_64_64(left[i], right[k - i]);\r\nr01 = add_128_128(r01, product);\r\nr2 += (r01.m_high < product.m_high);\r\n}\r\nresult[k] = r01.m_low;\r\nr01.m_low = r01.m_high;\r\nr01.m_high = r2;\r\nr2 = 0;\r\n}\r\nresult[ndigits * 2 - 1] = r01.m_low;\r\n}\r\nstatic void vli_square(u64 *result, const u64 *left, unsigned int ndigits)\r\n{\r\nuint128_t r01 = { 0, 0 };\r\nu64 r2 = 0;\r\nint i, k;\r\nfor (k = 0; k < ndigits * 2 - 1; k++) {\r\nunsigned int min;\r\nif (k < ndigits)\r\nmin = 0;\r\nelse\r\nmin = (k + 1) - ndigits;\r\nfor (i = min; i <= k && i <= k - i; i++) {\r\nuint128_t product;\r\nproduct = mul_64_64(left[i], left[k - i]);\r\nif (i < k - i) {\r\nr2 += product.m_high >> 63;\r\nproduct.m_high = (product.m_high << 1) |\r\n(product.m_low >> 63);\r\nproduct.m_low <<= 1;\r\n}\r\nr01 = add_128_128(r01, product);\r\nr2 += (r01.m_high < product.m_high);\r\n}\r\nresult[k] = r01.m_low;\r\nr01.m_low = r01.m_high;\r\nr01.m_high = r2;\r\nr2 = 0;\r\n}\r\nresult[ndigits * 2 - 1] = r01.m_low;\r\n}\r\nstatic void vli_mod_add(u64 *result, const u64 *left, const u64 *right,\r\nconst u64 *mod, unsigned int ndigits)\r\n{\r\nu64 carry;\r\ncarry = vli_add(result, left, right, ndigits);\r\nif (carry || vli_cmp(result, mod, ndigits) >= 0)\r\nvli_sub(result, result, mod, ndigits);\r\n}\r\nstatic void vli_mod_sub(u64 *result, const u64 *left, const u64 *right,\r\nconst u64 *mod, unsigned int ndigits)\r\n{\r\nu64 borrow = vli_sub(result, left, right, ndigits);\r\nif (borrow)\r\nvli_add(result, result, mod, ndigits);\r\n}\r\nstatic void vli_mmod_fast_192(u64 *result, const u64 *product,\r\nconst u64 *curve_prime, u64 *tmp)\r\n{\r\nconst unsigned int ndigits = 3;\r\nint carry;\r\nvli_set(result, product, ndigits);\r\nvli_set(tmp, &product[3], ndigits);\r\ncarry = vli_add(result, result, tmp, ndigits);\r\ntmp[0] = 0;\r\ntmp[1] = product[3];\r\ntmp[2] = product[4];\r\ncarry += vli_add(result, result, tmp, ndigits);\r\ntmp[0] = tmp[1] = product[5];\r\ntmp[2] = 0;\r\ncarry += vli_add(result, result, tmp, ndigits);\r\nwhile (carry || vli_cmp(curve_prime, result, ndigits) != 1)\r\ncarry -= vli_sub(result, result, curve_prime, ndigits);\r\n}\r\nstatic void vli_mmod_fast_256(u64 *result, const u64 *product,\r\nconst u64 *curve_prime, u64 *tmp)\r\n{\r\nint carry;\r\nconst unsigned int ndigits = 4;\r\nvli_set(result, product, ndigits);\r\ntmp[0] = 0;\r\ntmp[1] = product[5] & 0xffffffff00000000ull;\r\ntmp[2] = product[6];\r\ntmp[3] = product[7];\r\ncarry = vli_lshift(tmp, tmp, 1, ndigits);\r\ncarry += vli_add(result, result, tmp, ndigits);\r\ntmp[1] = product[6] << 32;\r\ntmp[2] = (product[6] >> 32) | (product[7] << 32);\r\ntmp[3] = product[7] >> 32;\r\ncarry += vli_lshift(tmp, tmp, 1, ndigits);\r\ncarry += vli_add(result, result, tmp, ndigits);\r\ntmp[0] = product[4];\r\ntmp[1] = product[5] & 0xffffffff;\r\ntmp[2] = 0;\r\ntmp[3] = product[7];\r\ncarry += vli_add(result, result, tmp, ndigits);\r\ntmp[0] = (product[4] >> 32) | (product[5] << 32);\r\ntmp[1] = (product[5] >> 32) | (product[6] & 0xffffffff00000000ull);\r\ntmp[2] = product[7];\r\ntmp[3] = (product[6] >> 32) | (product[4] << 32);\r\ncarry += vli_add(result, result, tmp, ndigits);\r\ntmp[0] = (product[5] >> 32) | (product[6] << 32);\r\ntmp[1] = (product[6] >> 32);\r\ntmp[2] = 0;\r\ntmp[3] = (product[4] & 0xffffffff) | (product[5] << 32);\r\ncarry -= vli_sub(result, result, tmp, ndigits);\r\ntmp[0] = product[6];\r\ntmp[1] = product[7];\r\ntmp[2] = 0;\r\ntmp[3] = (product[4] >> 32) | (product[5] & 0xffffffff00000000ull);\r\ncarry -= vli_sub(result, result, tmp, ndigits);\r\ntmp[0] = (product[6] >> 32) | (product[7] << 32);\r\ntmp[1] = (product[7] >> 32) | (product[4] << 32);\r\ntmp[2] = (product[4] >> 32) | (product[5] << 32);\r\ntmp[3] = (product[6] << 32);\r\ncarry -= vli_sub(result, result, tmp, ndigits);\r\ntmp[0] = product[7];\r\ntmp[1] = product[4] & 0xffffffff00000000ull;\r\ntmp[2] = product[5];\r\ntmp[3] = product[6] & 0xffffffff00000000ull;\r\ncarry -= vli_sub(result, result, tmp, ndigits);\r\nif (carry < 0) {\r\ndo {\r\ncarry += vli_add(result, result, curve_prime, ndigits);\r\n} while (carry < 0);\r\n} else {\r\nwhile (carry || vli_cmp(curve_prime, result, ndigits) != 1)\r\ncarry -= vli_sub(result, result, curve_prime, ndigits);\r\n}\r\n}\r\nstatic bool vli_mmod_fast(u64 *result, u64 *product,\r\nconst u64 *curve_prime, unsigned int ndigits)\r\n{\r\nu64 tmp[2 * ndigits];\r\nswitch (ndigits) {\r\ncase 3:\r\nvli_mmod_fast_192(result, product, curve_prime, tmp);\r\nbreak;\r\ncase 4:\r\nvli_mmod_fast_256(result, product, curve_prime, tmp);\r\nbreak;\r\ndefault:\r\npr_err("unsupports digits size!\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void vli_mod_mult_fast(u64 *result, const u64 *left, const u64 *right,\r\nconst u64 *curve_prime, unsigned int ndigits)\r\n{\r\nu64 product[2 * ndigits];\r\nvli_mult(product, left, right, ndigits);\r\nvli_mmod_fast(result, product, curve_prime, ndigits);\r\n}\r\nstatic void vli_mod_square_fast(u64 *result, const u64 *left,\r\nconst u64 *curve_prime, unsigned int ndigits)\r\n{\r\nu64 product[2 * ndigits];\r\nvli_square(product, left, ndigits);\r\nvli_mmod_fast(result, product, curve_prime, ndigits);\r\n}\r\nstatic void vli_mod_inv(u64 *result, const u64 *input, const u64 *mod,\r\nunsigned int ndigits)\r\n{\r\nu64 a[ndigits], b[ndigits];\r\nu64 u[ndigits], v[ndigits];\r\nu64 carry;\r\nint cmp_result;\r\nif (vli_is_zero(input, ndigits)) {\r\nvli_clear(result, ndigits);\r\nreturn;\r\n}\r\nvli_set(a, input, ndigits);\r\nvli_set(b, mod, ndigits);\r\nvli_clear(u, ndigits);\r\nu[0] = 1;\r\nvli_clear(v, ndigits);\r\nwhile ((cmp_result = vli_cmp(a, b, ndigits)) != 0) {\r\ncarry = 0;\r\nif (EVEN(a)) {\r\nvli_rshift1(a, ndigits);\r\nif (!EVEN(u))\r\ncarry = vli_add(u, u, mod, ndigits);\r\nvli_rshift1(u, ndigits);\r\nif (carry)\r\nu[ndigits - 1] |= 0x8000000000000000ull;\r\n} else if (EVEN(b)) {\r\nvli_rshift1(b, ndigits);\r\nif (!EVEN(v))\r\ncarry = vli_add(v, v, mod, ndigits);\r\nvli_rshift1(v, ndigits);\r\nif (carry)\r\nv[ndigits - 1] |= 0x8000000000000000ull;\r\n} else if (cmp_result > 0) {\r\nvli_sub(a, a, b, ndigits);\r\nvli_rshift1(a, ndigits);\r\nif (vli_cmp(u, v, ndigits) < 0)\r\nvli_add(u, u, mod, ndigits);\r\nvli_sub(u, u, v, ndigits);\r\nif (!EVEN(u))\r\ncarry = vli_add(u, u, mod, ndigits);\r\nvli_rshift1(u, ndigits);\r\nif (carry)\r\nu[ndigits - 1] |= 0x8000000000000000ull;\r\n} else {\r\nvli_sub(b, b, a, ndigits);\r\nvli_rshift1(b, ndigits);\r\nif (vli_cmp(v, u, ndigits) < 0)\r\nvli_add(v, v, mod, ndigits);\r\nvli_sub(v, v, u, ndigits);\r\nif (!EVEN(v))\r\ncarry = vli_add(v, v, mod, ndigits);\r\nvli_rshift1(v, ndigits);\r\nif (carry)\r\nv[ndigits - 1] |= 0x8000000000000000ull;\r\n}\r\n}\r\nvli_set(result, u, ndigits);\r\n}\r\nstatic bool ecc_point_is_zero(const struct ecc_point *point)\r\n{\r\nreturn (vli_is_zero(point->x, point->ndigits) &&\r\nvli_is_zero(point->y, point->ndigits));\r\n}\r\nstatic void ecc_point_double_jacobian(u64 *x1, u64 *y1, u64 *z1,\r\nu64 *curve_prime, unsigned int ndigits)\r\n{\r\nu64 t4[ndigits];\r\nu64 t5[ndigits];\r\nif (vli_is_zero(z1, ndigits))\r\nreturn;\r\nvli_mod_square_fast(t4, y1, curve_prime, ndigits);\r\nvli_mod_mult_fast(t5, x1, t4, curve_prime, ndigits);\r\nvli_mod_square_fast(t4, t4, curve_prime, ndigits);\r\nvli_mod_mult_fast(y1, y1, z1, curve_prime, ndigits);\r\nvli_mod_square_fast(z1, z1, curve_prime, ndigits);\r\nvli_mod_add(x1, x1, z1, curve_prime, ndigits);\r\nvli_mod_add(z1, z1, z1, curve_prime, ndigits);\r\nvli_mod_sub(z1, x1, z1, curve_prime, ndigits);\r\nvli_mod_mult_fast(x1, x1, z1, curve_prime, ndigits);\r\nvli_mod_add(z1, x1, x1, curve_prime, ndigits);\r\nvli_mod_add(x1, x1, z1, curve_prime, ndigits);\r\nif (vli_test_bit(x1, 0)) {\r\nu64 carry = vli_add(x1, x1, curve_prime, ndigits);\r\nvli_rshift1(x1, ndigits);\r\nx1[ndigits - 1] |= carry << 63;\r\n} else {\r\nvli_rshift1(x1, ndigits);\r\n}\r\nvli_mod_square_fast(z1, x1, curve_prime, ndigits);\r\nvli_mod_sub(z1, z1, t5, curve_prime, ndigits);\r\nvli_mod_sub(z1, z1, t5, curve_prime, ndigits);\r\nvli_mod_sub(t5, t5, z1, curve_prime, ndigits);\r\nvli_mod_mult_fast(x1, x1, t5, curve_prime, ndigits);\r\nvli_mod_sub(t4, x1, t4, curve_prime, ndigits);\r\nvli_set(x1, z1, ndigits);\r\nvli_set(z1, y1, ndigits);\r\nvli_set(y1, t4, ndigits);\r\n}\r\nstatic void apply_z(u64 *x1, u64 *y1, u64 *z, u64 *curve_prime,\r\nunsigned int ndigits)\r\n{\r\nu64 t1[ndigits];\r\nvli_mod_square_fast(t1, z, curve_prime, ndigits);\r\nvli_mod_mult_fast(x1, x1, t1, curve_prime, ndigits);\r\nvli_mod_mult_fast(t1, t1, z, curve_prime, ndigits);\r\nvli_mod_mult_fast(y1, y1, t1, curve_prime, ndigits);\r\n}\r\nstatic void xycz_initial_double(u64 *x1, u64 *y1, u64 *x2, u64 *y2,\r\nu64 *p_initial_z, u64 *curve_prime,\r\nunsigned int ndigits)\r\n{\r\nu64 z[ndigits];\r\nvli_set(x2, x1, ndigits);\r\nvli_set(y2, y1, ndigits);\r\nvli_clear(z, ndigits);\r\nz[0] = 1;\r\nif (p_initial_z)\r\nvli_set(z, p_initial_z, ndigits);\r\napply_z(x1, y1, z, curve_prime, ndigits);\r\necc_point_double_jacobian(x1, y1, z, curve_prime, ndigits);\r\napply_z(x2, y2, z, curve_prime, ndigits);\r\n}\r\nstatic void xycz_add(u64 *x1, u64 *y1, u64 *x2, u64 *y2, u64 *curve_prime,\r\nunsigned int ndigits)\r\n{\r\nu64 t5[ndigits];\r\nvli_mod_sub(t5, x2, x1, curve_prime, ndigits);\r\nvli_mod_square_fast(t5, t5, curve_prime, ndigits);\r\nvli_mod_mult_fast(x1, x1, t5, curve_prime, ndigits);\r\nvli_mod_mult_fast(x2, x2, t5, curve_prime, ndigits);\r\nvli_mod_sub(y2, y2, y1, curve_prime, ndigits);\r\nvli_mod_square_fast(t5, y2, curve_prime, ndigits);\r\nvli_mod_sub(t5, t5, x1, curve_prime, ndigits);\r\nvli_mod_sub(t5, t5, x2, curve_prime, ndigits);\r\nvli_mod_sub(x2, x2, x1, curve_prime, ndigits);\r\nvli_mod_mult_fast(y1, y1, x2, curve_prime, ndigits);\r\nvli_mod_sub(x2, x1, t5, curve_prime, ndigits);\r\nvli_mod_mult_fast(y2, y2, x2, curve_prime, ndigits);\r\nvli_mod_sub(y2, y2, y1, curve_prime, ndigits);\r\nvli_set(x2, t5, ndigits);\r\n}\r\nstatic void xycz_add_c(u64 *x1, u64 *y1, u64 *x2, u64 *y2, u64 *curve_prime,\r\nunsigned int ndigits)\r\n{\r\nu64 t5[ndigits];\r\nu64 t6[ndigits];\r\nu64 t7[ndigits];\r\nvli_mod_sub(t5, x2, x1, curve_prime, ndigits);\r\nvli_mod_square_fast(t5, t5, curve_prime, ndigits);\r\nvli_mod_mult_fast(x1, x1, t5, curve_prime, ndigits);\r\nvli_mod_mult_fast(x2, x2, t5, curve_prime, ndigits);\r\nvli_mod_add(t5, y2, y1, curve_prime, ndigits);\r\nvli_mod_sub(y2, y2, y1, curve_prime, ndigits);\r\nvli_mod_sub(t6, x2, x1, curve_prime, ndigits);\r\nvli_mod_mult_fast(y1, y1, t6, curve_prime, ndigits);\r\nvli_mod_add(t6, x1, x2, curve_prime, ndigits);\r\nvli_mod_square_fast(x2, y2, curve_prime, ndigits);\r\nvli_mod_sub(x2, x2, t6, curve_prime, ndigits);\r\nvli_mod_sub(t7, x1, x2, curve_prime, ndigits);\r\nvli_mod_mult_fast(y2, y2, t7, curve_prime, ndigits);\r\nvli_mod_sub(y2, y2, y1, curve_prime, ndigits);\r\nvli_mod_square_fast(t7, t5, curve_prime, ndigits);\r\nvli_mod_sub(t7, t7, t6, curve_prime, ndigits);\r\nvli_mod_sub(t6, t7, x1, curve_prime, ndigits);\r\nvli_mod_mult_fast(t6, t6, t5, curve_prime, ndigits);\r\nvli_mod_sub(y1, t6, y1, curve_prime, ndigits);\r\nvli_set(x1, t7, ndigits);\r\n}\r\nstatic void ecc_point_mult(struct ecc_point *result,\r\nconst struct ecc_point *point, const u64 *scalar,\r\nu64 *initial_z, u64 *curve_prime,\r\nunsigned int ndigits)\r\n{\r\nu64 rx[2][ndigits];\r\nu64 ry[2][ndigits];\r\nu64 z[ndigits];\r\nint i, nb;\r\nint num_bits = vli_num_bits(scalar, ndigits);\r\nvli_set(rx[1], point->x, ndigits);\r\nvli_set(ry[1], point->y, ndigits);\r\nxycz_initial_double(rx[1], ry[1], rx[0], ry[0], initial_z, curve_prime,\r\nndigits);\r\nfor (i = num_bits - 2; i > 0; i--) {\r\nnb = !vli_test_bit(scalar, i);\r\nxycz_add_c(rx[1 - nb], ry[1 - nb], rx[nb], ry[nb], curve_prime,\r\nndigits);\r\nxycz_add(rx[nb], ry[nb], rx[1 - nb], ry[1 - nb], curve_prime,\r\nndigits);\r\n}\r\nnb = !vli_test_bit(scalar, 0);\r\nxycz_add_c(rx[1 - nb], ry[1 - nb], rx[nb], ry[nb], curve_prime,\r\nndigits);\r\nvli_mod_sub(z, rx[1], rx[0], curve_prime, ndigits);\r\nvli_mod_mult_fast(z, z, ry[1 - nb], curve_prime, ndigits);\r\nvli_mod_mult_fast(z, z, point->x, curve_prime, ndigits);\r\nvli_mod_inv(z, z, curve_prime, point->ndigits);\r\nvli_mod_mult_fast(z, z, point->y, curve_prime, ndigits);\r\nvli_mod_mult_fast(z, z, rx[1 - nb], curve_prime, ndigits);\r\nxycz_add(rx[nb], ry[nb], rx[1 - nb], ry[1 - nb], curve_prime, ndigits);\r\napply_z(rx[0], ry[0], z, curve_prime, ndigits);\r\nvli_set(result->x, rx[0], ndigits);\r\nvli_set(result->y, ry[0], ndigits);\r\n}\r\nstatic inline void ecc_swap_digits(const u64 *in, u64 *out,\r\nunsigned int ndigits)\r\n{\r\nint i;\r\nfor (i = 0; i < ndigits; i++)\r\nout[i] = __swab64(in[ndigits - 1 - i]);\r\n}\r\nint ecc_is_key_valid(unsigned int curve_id, unsigned int ndigits,\r\nconst u64 *private_key, unsigned int private_key_len)\r\n{\r\nint nbytes;\r\nconst struct ecc_curve *curve = ecc_get_curve(curve_id);\r\nif (!private_key)\r\nreturn -EINVAL;\r\nnbytes = ndigits << ECC_DIGITS_TO_BYTES_SHIFT;\r\nif (private_key_len != nbytes)\r\nreturn -EINVAL;\r\nif (vli_is_zero(private_key, ndigits))\r\nreturn -EINVAL;\r\nif (vli_cmp(curve->n, private_key, ndigits) != 1)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint ecc_gen_privkey(unsigned int curve_id, unsigned int ndigits, u64 *privkey)\r\n{\r\nconst struct ecc_curve *curve = ecc_get_curve(curve_id);\r\nu64 priv[ndigits];\r\nunsigned int nbytes = ndigits << ECC_DIGITS_TO_BYTES_SHIFT;\r\nunsigned int nbits = vli_num_bits(curve->n, ndigits);\r\nint err;\r\nif (nbits < 160)\r\nreturn -EINVAL;\r\nif (crypto_get_default_rng())\r\nerr = -EFAULT;\r\nerr = crypto_rng_get_bytes(crypto_default_rng, (u8 *)priv, nbytes);\r\ncrypto_put_default_rng();\r\nif (err)\r\nreturn err;\r\nif (vli_is_zero(priv, ndigits))\r\nreturn -EINVAL;\r\nif (vli_cmp(curve->n, priv, ndigits) != 1)\r\nreturn -EINVAL;\r\necc_swap_digits(priv, privkey, ndigits);\r\nreturn 0;\r\n}\r\nint ecc_make_pub_key(unsigned int curve_id, unsigned int ndigits,\r\nconst u64 *private_key, u64 *public_key)\r\n{\r\nint ret = 0;\r\nstruct ecc_point *pk;\r\nu64 priv[ndigits];\r\nconst struct ecc_curve *curve = ecc_get_curve(curve_id);\r\nif (!private_key || !curve) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\necc_swap_digits(private_key, priv, ndigits);\r\npk = ecc_alloc_point(ndigits);\r\nif (!pk) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\necc_point_mult(pk, &curve->g, priv, NULL, curve->p, ndigits);\r\nif (ecc_point_is_zero(pk)) {\r\nret = -EAGAIN;\r\ngoto err_free_point;\r\n}\r\necc_swap_digits(pk->x, public_key, ndigits);\r\necc_swap_digits(pk->y, &public_key[ndigits], ndigits);\r\nerr_free_point:\r\necc_free_point(pk);\r\nout:\r\nreturn ret;\r\n}\r\nint crypto_ecdh_shared_secret(unsigned int curve_id, unsigned int ndigits,\r\nconst u64 *private_key, const u64 *public_key,\r\nu64 *secret)\r\n{\r\nint ret = 0;\r\nstruct ecc_point *product, *pk;\r\nu64 priv[ndigits];\r\nu64 rand_z[ndigits];\r\nunsigned int nbytes;\r\nconst struct ecc_curve *curve = ecc_get_curve(curve_id);\r\nif (!private_key || !public_key || !curve) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nnbytes = ndigits << ECC_DIGITS_TO_BYTES_SHIFT;\r\nget_random_bytes(rand_z, nbytes);\r\npk = ecc_alloc_point(ndigits);\r\nif (!pk) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nproduct = ecc_alloc_point(ndigits);\r\nif (!product) {\r\nret = -ENOMEM;\r\ngoto err_alloc_product;\r\n}\r\necc_swap_digits(public_key, pk->x, ndigits);\r\necc_swap_digits(&public_key[ndigits], pk->y, ndigits);\r\necc_swap_digits(private_key, priv, ndigits);\r\necc_point_mult(product, pk, priv, rand_z, curve->p, ndigits);\r\necc_swap_digits(product->x, secret, ndigits);\r\nif (ecc_point_is_zero(product))\r\nret = -EFAULT;\r\necc_free_point(product);\r\nerr_alloc_product:\r\necc_free_point(pk);\r\nout:\r\nreturn ret;\r\n}
