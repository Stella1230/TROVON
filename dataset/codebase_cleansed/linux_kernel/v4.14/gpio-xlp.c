static int xlp_gpio_get_reg(void __iomem *addr, unsigned gpio)\r\n{\r\nu32 pos, regset;\r\npos = gpio % XLP_GPIO_REGSZ;\r\nregset = (gpio / XLP_GPIO_REGSZ) * 4;\r\nreturn !!(readl(addr + regset) & BIT(pos));\r\n}\r\nstatic void xlp_gpio_set_reg(void __iomem *addr, unsigned gpio, int state)\r\n{\r\nu32 value, pos, regset;\r\npos = gpio % XLP_GPIO_REGSZ;\r\nregset = (gpio / XLP_GPIO_REGSZ) * 4;\r\nvalue = readl(addr + regset);\r\nif (state)\r\nvalue |= BIT(pos);\r\nelse\r\nvalue &= ~BIT(pos);\r\nwritel(value, addr + regset);\r\n}\r\nstatic void xlp_gpio_irq_disable(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nxlp_gpio_set_reg(priv->gpio_intr_en, d->hwirq, 0x0);\r\n__clear_bit(d->hwirq, priv->gpio_enabled_mask);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void xlp_gpio_irq_mask_ack(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nxlp_gpio_set_reg(priv->gpio_intr_en, d->hwirq, 0x0);\r\nxlp_gpio_set_reg(priv->gpio_intr_stat, d->hwirq, 0x1);\r\n__clear_bit(d->hwirq, priv->gpio_enabled_mask);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void xlp_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nxlp_gpio_set_reg(priv->gpio_intr_en, d->hwirq, 0x1);\r\n__set_bit(d->hwirq, priv->gpio_enabled_mask);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic int xlp_gpio_set_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\r\nint pol, irq_type;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nirq_type = XLP_GPIO_IRQ_TYPE_EDGE;\r\npol = XLP_GPIO_IRQ_POL_HIGH;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nirq_type = XLP_GPIO_IRQ_TYPE_EDGE;\r\npol = XLP_GPIO_IRQ_POL_LOW;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nirq_type = XLP_GPIO_IRQ_TYPE_LVL;\r\npol = XLP_GPIO_IRQ_POL_HIGH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nirq_type = XLP_GPIO_IRQ_TYPE_LVL;\r\npol = XLP_GPIO_IRQ_POL_LOW;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nxlp_gpio_set_reg(priv->gpio_intr_type, d->hwirq, irq_type);\r\nxlp_gpio_set_reg(priv->gpio_intr_pol, d->hwirq, pol);\r\nreturn 0;\r\n}\r\nstatic void xlp_gpio_generic_handler(struct irq_desc *desc)\r\n{\r\nstruct xlp_gpio_priv *priv = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *irqchip = irq_desc_get_chip(desc);\r\nint gpio, regoff;\r\nu32 gpio_stat;\r\nregoff = -1;\r\ngpio_stat = 0;\r\nchained_irq_enter(irqchip, desc);\r\nfor_each_set_bit(gpio, priv->gpio_enabled_mask, XLP_MAX_NR_GPIO) {\r\nif (regoff != gpio / XLP_GPIO_REGSZ) {\r\nregoff = gpio / XLP_GPIO_REGSZ;\r\ngpio_stat = readl(priv->gpio_intr_stat + regoff * 4);\r\n}\r\nif (gpio_stat & BIT(gpio % XLP_GPIO_REGSZ))\r\ngeneric_handle_irq(irq_find_mapping(\r\npriv->chip.irqdomain, gpio));\r\n}\r\nchained_irq_exit(irqchip, desc);\r\n}\r\nstatic int xlp_gpio_dir_output(struct gpio_chip *gc, unsigned gpio, int state)\r\n{\r\nstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\r\nBUG_ON(gpio >= gc->ngpio);\r\nxlp_gpio_set_reg(priv->gpio_out_en, gpio, 0x1);\r\nreturn 0;\r\n}\r\nstatic int xlp_gpio_dir_input(struct gpio_chip *gc, unsigned gpio)\r\n{\r\nstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\r\nBUG_ON(gpio >= gc->ngpio);\r\nxlp_gpio_set_reg(priv->gpio_out_en, gpio, 0x0);\r\nreturn 0;\r\n}\r\nstatic int xlp_gpio_get(struct gpio_chip *gc, unsigned gpio)\r\n{\r\nstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\r\nBUG_ON(gpio >= gc->ngpio);\r\nreturn xlp_gpio_get_reg(priv->gpio_paddrv, gpio);\r\n}\r\nstatic void xlp_gpio_set(struct gpio_chip *gc, unsigned gpio, int state)\r\n{\r\nstruct xlp_gpio_priv *priv = gpiochip_get_data(gc);\r\nBUG_ON(gpio >= gc->ngpio);\r\nxlp_gpio_set_reg(priv->gpio_paddrv, gpio, state);\r\n}\r\nstatic int xlp_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_chip *gc;\r\nstruct resource *iores;\r\nstruct xlp_gpio_priv *priv;\r\nvoid __iomem *gpio_base;\r\nint irq_base, irq, err;\r\nint ngpio;\r\nu32 soc_type;\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!iores)\r\nreturn -ENODEV;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ngpio_base = devm_ioremap_resource(&pdev->dev, iores);\r\nif (IS_ERR(gpio_base))\r\nreturn PTR_ERR(gpio_base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nif (pdev->dev.of_node) {\r\nconst struct of_device_id *of_id;\r\nof_id = of_match_device(xlp_gpio_of_ids, &pdev->dev);\r\nif (!of_id) {\r\ndev_err(&pdev->dev, "Unable to match OF ID\n");\r\nreturn -ENODEV;\r\n}\r\nsoc_type = (uintptr_t) of_id->data;\r\n} else {\r\nconst struct acpi_device_id *acpi_id;\r\nacpi_id = acpi_match_device(pdev->dev.driver->acpi_match_table,\r\n&pdev->dev);\r\nif (!acpi_id || !acpi_id->driver_data) {\r\ndev_err(&pdev->dev, "Unable to match ACPI ID\n");\r\nreturn -ENODEV;\r\n}\r\nsoc_type = (uintptr_t) acpi_id->driver_data;\r\n}\r\nswitch (soc_type) {\r\ncase XLP_GPIO_VARIANT_XLP832:\r\npriv->gpio_out_en = gpio_base + GPIO_OUTPUT_EN;\r\npriv->gpio_paddrv = gpio_base + GPIO_PADDRV;\r\npriv->gpio_intr_stat = gpio_base + GPIO_INT_STAT;\r\npriv->gpio_intr_type = gpio_base + GPIO_INT_TYPE;\r\npriv->gpio_intr_pol = gpio_base + GPIO_INT_POL;\r\npriv->gpio_intr_en = gpio_base + GPIO_INT_EN00;\r\nngpio = 41;\r\nbreak;\r\ncase XLP_GPIO_VARIANT_XLP208:\r\ncase XLP_GPIO_VARIANT_XLP316:\r\npriv->gpio_out_en = gpio_base + GPIO_OUTPUT_EN;\r\npriv->gpio_paddrv = gpio_base + GPIO_PADDRV;\r\npriv->gpio_intr_stat = gpio_base + GPIO_3XX_INT_STAT;\r\npriv->gpio_intr_type = gpio_base + GPIO_3XX_INT_TYPE;\r\npriv->gpio_intr_pol = gpio_base + GPIO_3XX_INT_POL;\r\npriv->gpio_intr_en = gpio_base + GPIO_3XX_INT_EN00;\r\nngpio = (soc_type == XLP_GPIO_VARIANT_XLP208) ? 42 : 57;\r\nbreak;\r\ncase XLP_GPIO_VARIANT_XLP980:\r\ncase XLP_GPIO_VARIANT_XLP532:\r\ncase GPIO_VARIANT_VULCAN:\r\npriv->gpio_out_en = gpio_base + GPIO_9XX_OUTPUT_EN;\r\npriv->gpio_paddrv = gpio_base + GPIO_9XX_PADDRV;\r\npriv->gpio_intr_stat = gpio_base + GPIO_9XX_INT_STAT;\r\npriv->gpio_intr_type = gpio_base + GPIO_9XX_INT_TYPE;\r\npriv->gpio_intr_pol = gpio_base + GPIO_9XX_INT_POL;\r\npriv->gpio_intr_en = gpio_base + GPIO_9XX_INT_EN00;\r\nif (soc_type == XLP_GPIO_VARIANT_XLP980)\r\nngpio = 66;\r\nelse if (soc_type == XLP_GPIO_VARIANT_XLP532)\r\nngpio = 67;\r\nelse\r\nngpio = 70;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unknown Processor type!\n");\r\nreturn -ENODEV;\r\n}\r\nbitmap_zero(priv->gpio_enabled_mask, XLP_MAX_NR_GPIO);\r\ngc = &priv->chip;\r\ngc->owner = THIS_MODULE;\r\ngc->label = dev_name(&pdev->dev);\r\ngc->base = 0;\r\ngc->parent = &pdev->dev;\r\ngc->ngpio = ngpio;\r\ngc->of_node = pdev->dev.of_node;\r\ngc->direction_output = xlp_gpio_dir_output;\r\ngc->direction_input = xlp_gpio_dir_input;\r\ngc->set = xlp_gpio_set;\r\ngc->get = xlp_gpio_get;\r\nspin_lock_init(&priv->lock);\r\nif (soc_type != GPIO_VARIANT_VULCAN) {\r\nirq_base = devm_irq_alloc_descs(&pdev->dev, -1,\r\nXLP_GPIO_IRQ_BASE,\r\ngc->ngpio, 0);\r\nif (irq_base < 0) {\r\ndev_err(&pdev->dev, "Failed to allocate IRQ numbers\n");\r\nreturn irq_base;\r\n}\r\n} else {\r\nirq_base = 0;\r\n}\r\nerr = gpiochip_add_data(gc, priv);\r\nif (err < 0)\r\nreturn err;\r\nerr = gpiochip_irqchip_add(gc, &xlp_gpio_irq_chip, irq_base,\r\nhandle_level_irq, IRQ_TYPE_NONE);\r\nif (err) {\r\ndev_err(&pdev->dev, "Could not connect irqchip to gpiochip!\n");\r\ngoto out_gpio_remove;\r\n}\r\ngpiochip_set_chained_irqchip(gc, &xlp_gpio_irq_chip, irq,\r\nxlp_gpio_generic_handler);\r\ndev_info(&pdev->dev, "registered %d GPIOs\n", gc->ngpio);\r\nreturn 0;\r\nout_gpio_remove:\r\ngpiochip_remove(gc);\r\nreturn err;\r\n}
