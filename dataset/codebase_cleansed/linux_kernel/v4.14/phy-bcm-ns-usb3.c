static int bcm_ns_usb3_mdio_phy_write(struct bcm_ns_usb3 *usb3, u16 reg,\r\nu16 value)\r\n{\r\nreturn usb3->phy_write(usb3, reg, value);\r\n}\r\nstatic int bcm_ns_usb3_phy_init_ns_bx(struct bcm_ns_usb3 *usb3)\r\n{\r\nint err;\r\nerr = bcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PHY_BASE_ADDR_REG,\r\nBCM_NS_USB3_PHY_PLL30_BLOCK);\r\nif (err < 0)\r\nreturn err;\r\nbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PLL_CONTROL, 0x1000);\r\nbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PLLA_CONTROL0, 0x6400);\r\nbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PLLA_CONTROL1, 0xc000);\r\nbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PLLA_CONTROL1, 0x8000);\r\nwritel(0, usb3->dmp + BCMA_RESET_CTL);\r\nbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PLL_CONTROL, 0x9000);\r\nbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PHY_BASE_ADDR_REG,\r\nBCM_NS_USB3_PHY_PIPE_BLOCK);\r\nbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_LFPS_CMP, 0xf30d);\r\nbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_LFPS_DEGLITCH, 0x6302);\r\nbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PHY_BASE_ADDR_REG,\r\nBCM_NS_USB3_PHY_TX_PMD_BLOCK);\r\nbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_TX_PMD_CONTROL1, 0x1003);\r\nreturn 0;\r\n}\r\nstatic int bcm_ns_usb3_phy_init_ns_ax(struct bcm_ns_usb3 *usb3)\r\n{\r\nint err;\r\nerr = bcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PHY_BASE_ADDR_REG,\r\nBCM_NS_USB3_PHY_PLL30_BLOCK);\r\nif (err < 0)\r\nreturn err;\r\nbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PLLA_CONTROL0, 0x6400);\r\nbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PHY_BASE_ADDR_REG, 0x80e0);\r\nbcm_ns_usb3_mdio_phy_write(usb3, 0x02, 0x009c);\r\nbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_PHY_BASE_ADDR_REG,\r\nBCM_NS_USB3_PHY_TX_PMD_BLOCK);\r\nbcm_ns_usb3_mdio_phy_write(usb3, 0x02, 0x21d3);\r\nbcm_ns_usb3_mdio_phy_write(usb3, BCM_NS_USB3_TX_PMD_CONTROL1, 0x1003);\r\nwritel(0, usb3->dmp + BCMA_RESET_CTL);\r\nreturn 0;\r\n}\r\nstatic int bcm_ns_usb3_phy_init(struct phy *phy)\r\n{\r\nstruct bcm_ns_usb3 *usb3 = phy_get_drvdata(phy);\r\nint err;\r\nwritel(BCMA_RESET_CTL_RESET, usb3->dmp + BCMA_RESET_CTL);\r\nswitch (usb3->family) {\r\ncase BCM_NS_AX:\r\nerr = bcm_ns_usb3_phy_init_ns_ax(usb3);\r\nbreak;\r\ncase BCM_NS_BX:\r\nerr = bcm_ns_usb3_phy_init_ns_bx(usb3);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nerr = -ENOTSUPP;\r\n}\r\nreturn err;\r\n}\r\nstatic int bcm_ns_usb3_mdiodev_phy_write(struct bcm_ns_usb3 *usb3, u16 reg,\r\nu16 value)\r\n{\r\nstruct mdio_device *mdiodev = usb3->mdiodev;\r\nreturn mdiobus_write(mdiodev->bus, mdiodev->addr, reg, value);\r\n}\r\nstatic int bcm_ns_usb3_mdio_probe(struct mdio_device *mdiodev)\r\n{\r\nstruct device *dev = &mdiodev->dev;\r\nconst struct of_device_id *of_id;\r\nstruct phy_provider *phy_provider;\r\nstruct device_node *syscon_np;\r\nstruct bcm_ns_usb3 *usb3;\r\nstruct resource res;\r\nint err;\r\nusb3 = devm_kzalloc(dev, sizeof(*usb3), GFP_KERNEL);\r\nif (!usb3)\r\nreturn -ENOMEM;\r\nusb3->dev = dev;\r\nusb3->mdiodev = mdiodev;\r\nof_id = of_match_device(bcm_ns_usb3_id_table, dev);\r\nif (!of_id)\r\nreturn -EINVAL;\r\nusb3->family = (enum bcm_ns_family)of_id->data;\r\nsyscon_np = of_parse_phandle(dev->of_node, "usb3-dmp-syscon", 0);\r\nerr = of_address_to_resource(syscon_np, 0, &res);\r\nof_node_put(syscon_np);\r\nif (err)\r\nreturn err;\r\nusb3->dmp = devm_ioremap_resource(dev, &res);\r\nif (IS_ERR(usb3->dmp)) {\r\ndev_err(dev, "Failed to map DMP regs\n");\r\nreturn PTR_ERR(usb3->dmp);\r\n}\r\nusb3->phy_write = bcm_ns_usb3_mdiodev_phy_write;\r\nusb3->phy = devm_phy_create(dev, NULL, &ops);\r\nif (IS_ERR(usb3->phy)) {\r\ndev_err(dev, "Failed to create PHY\n");\r\nreturn PTR_ERR(usb3->phy);\r\n}\r\nphy_set_drvdata(usb3->phy, usb3);\r\nphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\n}\r\nstatic int bcm_ns_usb3_wait_reg(struct bcm_ns_usb3 *usb3, void __iomem *addr,\r\nu32 mask, u32 value, unsigned long timeout)\r\n{\r\nunsigned long deadline = jiffies + timeout;\r\nu32 val;\r\ndo {\r\nval = readl(addr);\r\nif ((val & mask) == value)\r\nreturn 0;\r\ncpu_relax();\r\nudelay(10);\r\n} while (!time_after_eq(jiffies, deadline));\r\ndev_err(usb3->dev, "Timeout waiting for register %p\n", addr);\r\nreturn -EBUSY;\r\n}\r\nstatic inline int bcm_ns_usb3_mii_mng_wait_idle(struct bcm_ns_usb3 *usb3)\r\n{\r\nreturn bcm_ns_usb3_wait_reg(usb3, usb3->ccb_mii + BCMA_CCB_MII_MNG_CTL,\r\n0x0100, 0x0000,\r\nusecs_to_jiffies(BCM_NS_USB3_MII_MNG_TIMEOUT_US));\r\n}\r\nstatic int bcm_ns_usb3_platform_phy_write(struct bcm_ns_usb3 *usb3, u16 reg,\r\nu16 value)\r\n{\r\nu32 tmp = 0;\r\nint err;\r\nerr = bcm_ns_usb3_mii_mng_wait_idle(usb3);\r\nif (err < 0) {\r\ndev_err(usb3->dev, "Couldn't write 0x%08x value\n", value);\r\nreturn err;\r\n}\r\ntmp |= 0x58020000;\r\ntmp |= reg << 18;\r\ntmp |= value;\r\nwritel(tmp, usb3->ccb_mii + BCMA_CCB_MII_MNG_CMD_DATA);\r\nreturn bcm_ns_usb3_mii_mng_wait_idle(usb3);\r\n}\r\nstatic int bcm_ns_usb3_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *of_id;\r\nstruct bcm_ns_usb3 *usb3;\r\nstruct resource *res;\r\nstruct phy_provider *phy_provider;\r\nusb3 = devm_kzalloc(dev, sizeof(*usb3), GFP_KERNEL);\r\nif (!usb3)\r\nreturn -ENOMEM;\r\nusb3->dev = dev;\r\nof_id = of_match_device(bcm_ns_usb3_id_table, dev);\r\nif (!of_id)\r\nreturn -EINVAL;\r\nusb3->family = (enum bcm_ns_family)of_id->data;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dmp");\r\nusb3->dmp = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(usb3->dmp)) {\r\ndev_err(dev, "Failed to map DMP regs\n");\r\nreturn PTR_ERR(usb3->dmp);\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ccb-mii");\r\nusb3->ccb_mii = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(usb3->ccb_mii)) {\r\ndev_err(dev, "Failed to map ChipCommon B MII regs\n");\r\nreturn PTR_ERR(usb3->ccb_mii);\r\n}\r\nwritel(0x0000009a, usb3->ccb_mii + BCMA_CCB_MII_MNG_CTL);\r\nudelay(2);\r\nusb3->phy_write = bcm_ns_usb3_platform_phy_write;\r\nusb3->phy = devm_phy_create(dev, NULL, &ops);\r\nif (IS_ERR(usb3->phy)) {\r\ndev_err(dev, "Failed to create PHY\n");\r\nreturn PTR_ERR(usb3->phy);\r\n}\r\nphy_set_drvdata(usb3->phy, usb3);\r\nplatform_set_drvdata(pdev, usb3);\r\nphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nif (!IS_ERR(phy_provider))\r\ndev_info(dev, "Registered Broadcom Northstar USB 3.0 PHY driver\n");\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\n}\r\nstatic int __init bcm_ns_usb3_module_init(void)\r\n{\r\nint err;\r\nerr = mdio_driver_register(&bcm_ns_usb3_mdio_driver);\r\nif (err)\r\nreturn err;\r\nerr = platform_driver_register(&bcm_ns_usb3_driver);\r\nif (err)\r\nmdio_driver_unregister(&bcm_ns_usb3_mdio_driver);\r\nreturn err;\r\n}\r\nstatic void __exit bcm_ns_usb3_module_exit(void)\r\n{\r\nplatform_driver_unregister(&bcm_ns_usb3_driver);\r\nmdio_driver_unregister(&bcm_ns_usb3_mdio_driver);\r\n}
