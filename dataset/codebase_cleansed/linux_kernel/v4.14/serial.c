static inline void serial_write_reg(struct plat_serial8250_port *p, int offset,\r\nint value)\r\n{\r\noffset <<= p->regshift;\r\nWARN_ONCE(!p->membase, "unmapped write: uart[%d]\n", offset);\r\n__raw_writel(value, p->membase + offset);\r\n}\r\nstatic void __init davinci_serial_reset(struct plat_serial8250_port *p)\r\n{\r\nunsigned int pwremu = 0;\r\nserial_write_reg(p, UART_IER, 0);\r\nserial_write_reg(p, UART_DAVINCI_PWREMU, pwremu);\r\nmdelay(10);\r\npwremu |= (0x3 << 13);\r\npwremu |= 0x1;\r\nserial_write_reg(p, UART_DAVINCI_PWREMU, pwremu);\r\nif (cpu_is_davinci_dm646x())\r\nserial_write_reg(p, UART_DM646X_SCR,\r\nUART_DM646X_SCR_TX_WATERMARK);\r\n}\r\nint __init davinci_serial_init(struct platform_device *serial_dev)\r\n{\r\nint i, ret = 0;\r\nstruct device *dev;\r\nstruct plat_serial8250_port *p;\r\nstruct clk *clk;\r\nfor (i = 0; serial_dev[i].dev.platform_data != NULL; i++) {\r\ndev = &serial_dev[i].dev;\r\np = dev->platform_data;\r\nret = platform_device_register(&serial_dev[i]);\r\nif (ret)\r\ncontinue;\r\nclk = clk_get(dev, NULL);\r\nif (IS_ERR(clk)) {\r\npr_err("%s:%d: failed to get UART%d clock\n",\r\n__func__, __LINE__, i);\r\ncontinue;\r\n}\r\nclk_prepare_enable(clk);\r\np->uartclk = clk_get_rate(clk);\r\nif (!p->membase && p->mapbase) {\r\np->membase = ioremap(p->mapbase, SZ_4K);\r\nif (p->membase)\r\np->flags &= ~UPF_IOREMAP;\r\nelse\r\npr_err("uart regs ioremap failed\n");\r\n}\r\nif (p->membase && p->type != PORT_AR7)\r\ndavinci_serial_reset(p);\r\n}\r\nreturn ret;\r\n}
