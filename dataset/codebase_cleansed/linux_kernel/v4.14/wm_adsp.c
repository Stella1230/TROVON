static struct wm_adsp_buf *wm_adsp_buf_alloc(const void *src, size_t len,\r\nstruct list_head *list)\r\n{\r\nstruct wm_adsp_buf *buf = kzalloc(sizeof(*buf), GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn NULL;\r\nbuf->buf = vmalloc(len);\r\nif (!buf->buf) {\r\nkfree(buf);\r\nreturn NULL;\r\n}\r\nmemcpy(buf->buf, src, len);\r\nif (list)\r\nlist_add_tail(&buf->list, list);\r\nreturn buf;\r\n}\r\nstatic void wm_adsp_buf_free(struct list_head *list)\r\n{\r\nwhile (!list_empty(list)) {\r\nstruct wm_adsp_buf *buf = list_first_entry(list,\r\nstruct wm_adsp_buf,\r\nlist);\r\nlist_del(&buf->list);\r\nvfree(buf->buf);\r\nkfree(buf);\r\n}\r\n}\r\nstatic const char *wm_adsp_mem_region_name(unsigned int type)\r\n{\r\nswitch (type) {\r\ncase WMFW_ADSP1_PM:\r\nreturn "PM";\r\ncase WMFW_ADSP1_DM:\r\nreturn "DM";\r\ncase WMFW_ADSP2_XM:\r\nreturn "XM";\r\ncase WMFW_ADSP2_YM:\r\nreturn "YM";\r\ncase WMFW_ADSP1_ZM:\r\nreturn "ZM";\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic void wm_adsp_debugfs_save_wmfwname(struct wm_adsp *dsp, const char *s)\r\n{\r\nchar *tmp = kasprintf(GFP_KERNEL, "%s\n", s);\r\nkfree(dsp->wmfw_file_name);\r\ndsp->wmfw_file_name = tmp;\r\n}\r\nstatic void wm_adsp_debugfs_save_binname(struct wm_adsp *dsp, const char *s)\r\n{\r\nchar *tmp = kasprintf(GFP_KERNEL, "%s\n", s);\r\nkfree(dsp->bin_file_name);\r\ndsp->bin_file_name = tmp;\r\n}\r\nstatic void wm_adsp_debugfs_clear(struct wm_adsp *dsp)\r\n{\r\nkfree(dsp->wmfw_file_name);\r\nkfree(dsp->bin_file_name);\r\ndsp->wmfw_file_name = NULL;\r\ndsp->bin_file_name = NULL;\r\n}\r\nstatic ssize_t wm_adsp_debugfs_wmfw_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct wm_adsp *dsp = file->private_data;\r\nssize_t ret;\r\nmutex_lock(&dsp->pwr_lock);\r\nif (!dsp->wmfw_file_name || !dsp->booted)\r\nret = 0;\r\nelse\r\nret = simple_read_from_buffer(user_buf, count, ppos,\r\ndsp->wmfw_file_name,\r\nstrlen(dsp->wmfw_file_name));\r\nmutex_unlock(&dsp->pwr_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t wm_adsp_debugfs_bin_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct wm_adsp *dsp = file->private_data;\r\nssize_t ret;\r\nmutex_lock(&dsp->pwr_lock);\r\nif (!dsp->bin_file_name || !dsp->booted)\r\nret = 0;\r\nelse\r\nret = simple_read_from_buffer(user_buf, count, ppos,\r\ndsp->bin_file_name,\r\nstrlen(dsp->bin_file_name));\r\nmutex_unlock(&dsp->pwr_lock);\r\nreturn ret;\r\n}\r\nstatic void wm_adsp2_init_debugfs(struct wm_adsp *dsp,\r\nstruct snd_soc_codec *codec)\r\n{\r\nstruct dentry *root = NULL;\r\nchar *root_name;\r\nint i;\r\nif (!codec->component.debugfs_root) {\r\nadsp_err(dsp, "No codec debugfs root\n");\r\ngoto err;\r\n}\r\nroot_name = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!root_name)\r\ngoto err;\r\nsnprintf(root_name, PAGE_SIZE, "dsp%d", dsp->num);\r\nroot = debugfs_create_dir(root_name, codec->component.debugfs_root);\r\nkfree(root_name);\r\nif (!root)\r\ngoto err;\r\nif (!debugfs_create_bool("booted", S_IRUGO, root, &dsp->booted))\r\ngoto err;\r\nif (!debugfs_create_bool("running", S_IRUGO, root, &dsp->running))\r\ngoto err;\r\nif (!debugfs_create_x32("fw_id", S_IRUGO, root, &dsp->fw_id))\r\ngoto err;\r\nif (!debugfs_create_x32("fw_version", S_IRUGO, root,\r\n&dsp->fw_id_version))\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(wm_adsp_debugfs_fops); ++i) {\r\nif (!debugfs_create_file(wm_adsp_debugfs_fops[i].name,\r\nS_IRUGO, root, dsp,\r\n&wm_adsp_debugfs_fops[i].fops))\r\ngoto err;\r\n}\r\ndsp->debugfs_root = root;\r\nreturn;\r\nerr:\r\ndebugfs_remove_recursive(root);\r\nadsp_err(dsp, "Failed to create debugfs\n");\r\n}\r\nstatic void wm_adsp2_cleanup_debugfs(struct wm_adsp *dsp)\r\n{\r\nwm_adsp_debugfs_clear(dsp);\r\ndebugfs_remove_recursive(dsp->debugfs_root);\r\n}\r\nstatic inline void wm_adsp2_init_debugfs(struct wm_adsp *dsp,\r\nstruct snd_soc_codec *codec)\r\n{\r\n}\r\nstatic inline void wm_adsp2_cleanup_debugfs(struct wm_adsp *dsp)\r\n{\r\n}\r\nstatic inline void wm_adsp_debugfs_save_wmfwname(struct wm_adsp *dsp,\r\nconst char *s)\r\n{\r\n}\r\nstatic inline void wm_adsp_debugfs_save_binname(struct wm_adsp *dsp,\r\nconst char *s)\r\n{\r\n}\r\nstatic inline void wm_adsp_debugfs_clear(struct wm_adsp *dsp)\r\n{\r\n}\r\nstatic int wm_adsp_fw_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nstruct wm_adsp *dsp = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = dsp[e->shift_l].fw;\r\nreturn 0;\r\n}\r\nstatic int wm_adsp_fw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nstruct wm_adsp *dsp = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nif (ucontrol->value.enumerated.item[0] == dsp[e->shift_l].fw)\r\nreturn 0;\r\nif (ucontrol->value.enumerated.item[0] >= WM_ADSP_NUM_FW)\r\nreturn -EINVAL;\r\nmutex_lock(&dsp[e->shift_l].pwr_lock);\r\nif (dsp[e->shift_l].booted || dsp[e->shift_l].compr)\r\nret = -EBUSY;\r\nelse\r\ndsp[e->shift_l].fw = ucontrol->value.enumerated.item[0];\r\nmutex_unlock(&dsp[e->shift_l].pwr_lock);\r\nreturn ret;\r\n}\r\nstatic struct wm_adsp_region const *wm_adsp_find_region(struct wm_adsp *dsp,\r\nint type)\r\n{\r\nint i;\r\nfor (i = 0; i < dsp->num_mems; i++)\r\nif (dsp->mem[i].type == type)\r\nreturn &dsp->mem[i];\r\nreturn NULL;\r\n}\r\nstatic unsigned int wm_adsp_region_to_reg(struct wm_adsp_region const *mem,\r\nunsigned int offset)\r\n{\r\nif (WARN_ON(!mem))\r\nreturn offset;\r\nswitch (mem->type) {\r\ncase WMFW_ADSP1_PM:\r\nreturn mem->base + (offset * 3);\r\ncase WMFW_ADSP1_DM:\r\nreturn mem->base + (offset * 2);\r\ncase WMFW_ADSP2_XM:\r\nreturn mem->base + (offset * 2);\r\ncase WMFW_ADSP2_YM:\r\nreturn mem->base + (offset * 2);\r\ncase WMFW_ADSP1_ZM:\r\nreturn mem->base + (offset * 2);\r\ndefault:\r\nWARN(1, "Unknown memory region type");\r\nreturn offset;\r\n}\r\n}\r\nstatic void wm_adsp2_show_fw_status(struct wm_adsp *dsp)\r\n{\r\nu16 scratch[4];\r\nint ret;\r\nret = regmap_raw_read(dsp->regmap, dsp->base + ADSP2_SCRATCH0,\r\nscratch, sizeof(scratch));\r\nif (ret) {\r\nadsp_err(dsp, "Failed to read SCRATCH regs: %d\n", ret);\r\nreturn;\r\n}\r\nadsp_dbg(dsp, "FW SCRATCH 0:0x%x 1:0x%x 2:0x%x 3:0x%x\n",\r\nbe16_to_cpu(scratch[0]),\r\nbe16_to_cpu(scratch[1]),\r\nbe16_to_cpu(scratch[2]),\r\nbe16_to_cpu(scratch[3]));\r\n}\r\nstatic void wm_adsp2v2_show_fw_status(struct wm_adsp *dsp)\r\n{\r\nu32 scratch[2];\r\nint ret;\r\nret = regmap_raw_read(dsp->regmap, dsp->base + ADSP2V2_SCRATCH0_1,\r\nscratch, sizeof(scratch));\r\nif (ret) {\r\nadsp_err(dsp, "Failed to read SCRATCH regs: %d\n", ret);\r\nreturn;\r\n}\r\nscratch[0] = be32_to_cpu(scratch[0]);\r\nscratch[1] = be32_to_cpu(scratch[1]);\r\nadsp_dbg(dsp, "FW SCRATCH 0:0x%x 1:0x%x 2:0x%x 3:0x%x\n",\r\nscratch[0] & 0xFFFF,\r\nscratch[0] >> 16,\r\nscratch[1] & 0xFFFF,\r\nscratch[1] >> 16);\r\n}\r\nstatic inline struct wm_coeff_ctl *bytes_ext_to_ctl(struct soc_bytes_ext *ext)\r\n{\r\nreturn container_of(ext, struct wm_coeff_ctl, bytes_ext);\r\n}\r\nstatic int wm_coeff_base_reg(struct wm_coeff_ctl *ctl, unsigned int *reg)\r\n{\r\nconst struct wm_adsp_alg_region *alg_region = &ctl->alg_region;\r\nstruct wm_adsp *dsp = ctl->dsp;\r\nconst struct wm_adsp_region *mem;\r\nmem = wm_adsp_find_region(dsp, alg_region->type);\r\nif (!mem) {\r\nadsp_err(dsp, "No base for region %x\n",\r\nalg_region->type);\r\nreturn -EINVAL;\r\n}\r\n*reg = wm_adsp_region_to_reg(mem, ctl->alg_region.base + ctl->offset);\r\nreturn 0;\r\n}\r\nstatic int wm_coeff_info(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct soc_bytes_ext *bytes_ext =\r\n(struct soc_bytes_ext *)kctl->private_value;\r\nstruct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);\r\nswitch (ctl->type) {\r\ncase WMFW_CTL_TYPE_ACKED:\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->value.integer.min = WM_ADSP_ACKED_CTL_MIN_VALUE;\r\nuinfo->value.integer.max = WM_ADSP_ACKED_CTL_MAX_VALUE;\r\nuinfo->value.integer.step = 1;\r\nuinfo->count = 1;\r\nbreak;\r\ndefault:\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nuinfo->count = ctl->len;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm_coeff_write_acked_control(struct wm_coeff_ctl *ctl,\r\nunsigned int event_id)\r\n{\r\nstruct wm_adsp *dsp = ctl->dsp;\r\nu32 val = cpu_to_be32(event_id);\r\nunsigned int reg;\r\nint i, ret;\r\nret = wm_coeff_base_reg(ctl, &reg);\r\nif (ret)\r\nreturn ret;\r\nadsp_dbg(dsp, "Sending 0x%x to acked control alg 0x%x %s:0x%x\n",\r\nevent_id, ctl->alg_region.alg,\r\nwm_adsp_mem_region_name(ctl->alg_region.type), ctl->offset);\r\nret = regmap_raw_write(dsp->regmap, reg, &val, sizeof(val));\r\nif (ret) {\r\nadsp_err(dsp, "Failed to write %x: %d\n", reg, ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < WM_ADSP_ACKED_CTL_TIMEOUT_MS;) {\r\nswitch (i) {\r\ncase 0 ... WM_ADSP_ACKED_CTL_N_QUICKPOLLS - 1:\r\nusleep_range(1000, 2000);\r\ni++;\r\nbreak;\r\ndefault:\r\nusleep_range(10000, 20000);\r\ni += 10;\r\nbreak;\r\n}\r\nret = regmap_raw_read(dsp->regmap, reg, &val, sizeof(val));\r\nif (ret) {\r\nadsp_err(dsp, "Failed to read %x: %d\n", reg, ret);\r\nreturn ret;\r\n}\r\nif (val == 0) {\r\nadsp_dbg(dsp, "Acked control ACKED at poll %u\n", i);\r\nreturn 0;\r\n}\r\n}\r\nadsp_warn(dsp, "Acked control @0x%x alg:0x%x %s:0x%x timed out\n",\r\nreg, ctl->alg_region.alg,\r\nwm_adsp_mem_region_name(ctl->alg_region.type),\r\nctl->offset);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int wm_coeff_write_control(struct wm_coeff_ctl *ctl,\r\nconst void *buf, size_t len)\r\n{\r\nstruct wm_adsp *dsp = ctl->dsp;\r\nvoid *scratch;\r\nint ret;\r\nunsigned int reg;\r\nret = wm_coeff_base_reg(ctl, &reg);\r\nif (ret)\r\nreturn ret;\r\nscratch = kmemdup(buf, len, GFP_KERNEL | GFP_DMA);\r\nif (!scratch)\r\nreturn -ENOMEM;\r\nret = regmap_raw_write(dsp->regmap, reg, scratch,\r\nlen);\r\nif (ret) {\r\nadsp_err(dsp, "Failed to write %zu bytes to %x: %d\n",\r\nlen, reg, ret);\r\nkfree(scratch);\r\nreturn ret;\r\n}\r\nadsp_dbg(dsp, "Wrote %zu bytes to %x\n", len, reg);\r\nkfree(scratch);\r\nreturn 0;\r\n}\r\nstatic int wm_coeff_put(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_bytes_ext *bytes_ext =\r\n(struct soc_bytes_ext *)kctl->private_value;\r\nstruct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);\r\nchar *p = ucontrol->value.bytes.data;\r\nint ret = 0;\r\nmutex_lock(&ctl->dsp->pwr_lock);\r\nif (ctl->flags & WMFW_CTL_FLAG_VOLATILE)\r\nret = -EPERM;\r\nelse\r\nmemcpy(ctl->cache, p, ctl->len);\r\nctl->set = 1;\r\nif (ctl->enabled && ctl->dsp->running)\r\nret = wm_coeff_write_control(ctl, p, ctl->len);\r\nmutex_unlock(&ctl->dsp->pwr_lock);\r\nreturn ret;\r\n}\r\nstatic int wm_coeff_tlv_put(struct snd_kcontrol *kctl,\r\nconst unsigned int __user *bytes, unsigned int size)\r\n{\r\nstruct soc_bytes_ext *bytes_ext =\r\n(struct soc_bytes_ext *)kctl->private_value;\r\nstruct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);\r\nint ret = 0;\r\nmutex_lock(&ctl->dsp->pwr_lock);\r\nif (copy_from_user(ctl->cache, bytes, size)) {\r\nret = -EFAULT;\r\n} else {\r\nctl->set = 1;\r\nif (ctl->enabled && ctl->dsp->running)\r\nret = wm_coeff_write_control(ctl, ctl->cache, size);\r\nelse if (ctl->flags & WMFW_CTL_FLAG_VOLATILE)\r\nret = -EPERM;\r\n}\r\nmutex_unlock(&ctl->dsp->pwr_lock);\r\nreturn ret;\r\n}\r\nstatic int wm_coeff_put_acked(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_bytes_ext *bytes_ext =\r\n(struct soc_bytes_ext *)kctl->private_value;\r\nstruct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);\r\nunsigned int val = ucontrol->value.integer.value[0];\r\nint ret;\r\nif (val == 0)\r\nreturn 0;\r\nmutex_lock(&ctl->dsp->pwr_lock);\r\nif (ctl->enabled && ctl->dsp->running)\r\nret = wm_coeff_write_acked_control(ctl, val);\r\nelse\r\nret = -EPERM;\r\nmutex_unlock(&ctl->dsp->pwr_lock);\r\nreturn ret;\r\n}\r\nstatic int wm_coeff_read_control(struct wm_coeff_ctl *ctl,\r\nvoid *buf, size_t len)\r\n{\r\nstruct wm_adsp *dsp = ctl->dsp;\r\nvoid *scratch;\r\nint ret;\r\nunsigned int reg;\r\nret = wm_coeff_base_reg(ctl, &reg);\r\nif (ret)\r\nreturn ret;\r\nscratch = kmalloc(len, GFP_KERNEL | GFP_DMA);\r\nif (!scratch)\r\nreturn -ENOMEM;\r\nret = regmap_raw_read(dsp->regmap, reg, scratch, len);\r\nif (ret) {\r\nadsp_err(dsp, "Failed to read %zu bytes from %x: %d\n",\r\nlen, reg, ret);\r\nkfree(scratch);\r\nreturn ret;\r\n}\r\nadsp_dbg(dsp, "Read %zu bytes from %x\n", len, reg);\r\nmemcpy(buf, scratch, len);\r\nkfree(scratch);\r\nreturn 0;\r\n}\r\nstatic int wm_coeff_get(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_bytes_ext *bytes_ext =\r\n(struct soc_bytes_ext *)kctl->private_value;\r\nstruct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);\r\nchar *p = ucontrol->value.bytes.data;\r\nint ret = 0;\r\nmutex_lock(&ctl->dsp->pwr_lock);\r\nif (ctl->flags & WMFW_CTL_FLAG_VOLATILE) {\r\nif (ctl->enabled && ctl->dsp->running)\r\nret = wm_coeff_read_control(ctl, p, ctl->len);\r\nelse\r\nret = -EPERM;\r\n} else {\r\nif (!ctl->flags && ctl->enabled && ctl->dsp->running)\r\nret = wm_coeff_read_control(ctl, ctl->cache, ctl->len);\r\nmemcpy(p, ctl->cache, ctl->len);\r\n}\r\nmutex_unlock(&ctl->dsp->pwr_lock);\r\nreturn ret;\r\n}\r\nstatic int wm_coeff_tlv_get(struct snd_kcontrol *kctl,\r\nunsigned int __user *bytes, unsigned int size)\r\n{\r\nstruct soc_bytes_ext *bytes_ext =\r\n(struct soc_bytes_ext *)kctl->private_value;\r\nstruct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);\r\nint ret = 0;\r\nmutex_lock(&ctl->dsp->pwr_lock);\r\nif (ctl->flags & WMFW_CTL_FLAG_VOLATILE) {\r\nif (ctl->enabled && ctl->dsp->running)\r\nret = wm_coeff_read_control(ctl, ctl->cache, size);\r\nelse\r\nret = -EPERM;\r\n} else {\r\nif (!ctl->flags && ctl->enabled && ctl->dsp->running)\r\nret = wm_coeff_read_control(ctl, ctl->cache, size);\r\n}\r\nif (!ret && copy_to_user(bytes, ctl->cache, size))\r\nret = -EFAULT;\r\nmutex_unlock(&ctl->dsp->pwr_lock);\r\nreturn ret;\r\n}\r\nstatic int wm_coeff_get_acked(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.integer.value[0] = 0;\r\nreturn 0;\r\n}\r\nstatic unsigned int wmfw_convert_flags(unsigned int in, unsigned int len)\r\n{\r\nunsigned int out, rd, wr, vol;\r\nif (len > ADSP_MAX_STD_CTRL_SIZE) {\r\nrd = SNDRV_CTL_ELEM_ACCESS_TLV_READ;\r\nwr = SNDRV_CTL_ELEM_ACCESS_TLV_WRITE;\r\nvol = SNDRV_CTL_ELEM_ACCESS_VOLATILE;\r\nout = SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\r\n} else {\r\nrd = SNDRV_CTL_ELEM_ACCESS_READ;\r\nwr = SNDRV_CTL_ELEM_ACCESS_WRITE;\r\nvol = SNDRV_CTL_ELEM_ACCESS_VOLATILE;\r\nout = 0;\r\n}\r\nif (in) {\r\nif (in & WMFW_CTL_FLAG_READABLE)\r\nout |= rd;\r\nif (in & WMFW_CTL_FLAG_WRITEABLE)\r\nout |= wr;\r\nif (in & WMFW_CTL_FLAG_VOLATILE)\r\nout |= vol;\r\n} else {\r\nout |= rd | wr | vol;\r\n}\r\nreturn out;\r\n}\r\nstatic int wmfw_add_ctl(struct wm_adsp *dsp, struct wm_coeff_ctl *ctl)\r\n{\r\nstruct snd_kcontrol_new *kcontrol;\r\nint ret;\r\nif (!ctl || !ctl->name)\r\nreturn -EINVAL;\r\nkcontrol = kzalloc(sizeof(*kcontrol), GFP_KERNEL);\r\nif (!kcontrol)\r\nreturn -ENOMEM;\r\nkcontrol->name = ctl->name;\r\nkcontrol->info = wm_coeff_info;\r\nkcontrol->iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nkcontrol->tlv.c = snd_soc_bytes_tlv_callback;\r\nkcontrol->private_value = (unsigned long)&ctl->bytes_ext;\r\nkcontrol->access = wmfw_convert_flags(ctl->flags, ctl->len);\r\nswitch (ctl->type) {\r\ncase WMFW_CTL_TYPE_ACKED:\r\nkcontrol->get = wm_coeff_get_acked;\r\nkcontrol->put = wm_coeff_put_acked;\r\nbreak;\r\ndefault:\r\nkcontrol->get = wm_coeff_get;\r\nkcontrol->put = wm_coeff_put;\r\nctl->bytes_ext.max = ctl->len;\r\nctl->bytes_ext.get = wm_coeff_tlv_get;\r\nctl->bytes_ext.put = wm_coeff_tlv_put;\r\nbreak;\r\n}\r\nret = snd_soc_add_codec_controls(dsp->codec, kcontrol, 1);\r\nif (ret < 0)\r\ngoto err_kcontrol;\r\nkfree(kcontrol);\r\nreturn 0;\r\nerr_kcontrol:\r\nkfree(kcontrol);\r\nreturn ret;\r\n}\r\nstatic int wm_coeff_init_control_caches(struct wm_adsp *dsp)\r\n{\r\nstruct wm_coeff_ctl *ctl;\r\nint ret;\r\nlist_for_each_entry(ctl, &dsp->ctl_list, list) {\r\nif (!ctl->enabled || ctl->set)\r\ncontinue;\r\nif (ctl->flags & WMFW_CTL_FLAG_VOLATILE)\r\ncontinue;\r\nret = wm_coeff_read_control(ctl, ctl->cache, ctl->len);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm_coeff_sync_controls(struct wm_adsp *dsp)\r\n{\r\nstruct wm_coeff_ctl *ctl;\r\nint ret;\r\nlist_for_each_entry(ctl, &dsp->ctl_list, list) {\r\nif (!ctl->enabled)\r\ncontinue;\r\nif (ctl->set && !(ctl->flags & WMFW_CTL_FLAG_VOLATILE)) {\r\nret = wm_coeff_write_control(ctl, ctl->cache, ctl->len);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void wm_adsp_signal_event_controls(struct wm_adsp *dsp,\r\nunsigned int event)\r\n{\r\nstruct wm_coeff_ctl *ctl;\r\nint ret;\r\nlist_for_each_entry(ctl, &dsp->ctl_list, list) {\r\nif (ctl->type != WMFW_CTL_TYPE_HOSTEVENT)\r\ncontinue;\r\nif (!ctl->enabled)\r\ncontinue;\r\nret = wm_coeff_write_acked_control(ctl, event);\r\nif (ret)\r\nadsp_warn(dsp,\r\n"Failed to send 0x%x event to alg 0x%x (%d)\n",\r\nevent, ctl->alg_region.alg, ret);\r\n}\r\n}\r\nstatic void wm_adsp_ctl_work(struct work_struct *work)\r\n{\r\nstruct wmfw_ctl_work *ctl_work = container_of(work,\r\nstruct wmfw_ctl_work,\r\nwork);\r\nwmfw_add_ctl(ctl_work->dsp, ctl_work->ctl);\r\nkfree(ctl_work);\r\n}\r\nstatic void wm_adsp_free_ctl_blk(struct wm_coeff_ctl *ctl)\r\n{\r\nkfree(ctl->cache);\r\nkfree(ctl->name);\r\nkfree(ctl);\r\n}\r\nstatic int wm_adsp_create_control(struct wm_adsp *dsp,\r\nconst struct wm_adsp_alg_region *alg_region,\r\nunsigned int offset, unsigned int len,\r\nconst char *subname, unsigned int subname_len,\r\nunsigned int flags, unsigned int type)\r\n{\r\nstruct wm_coeff_ctl *ctl;\r\nstruct wmfw_ctl_work *ctl_work;\r\nchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\r\nconst char *region_name;\r\nint ret;\r\nregion_name = wm_adsp_mem_region_name(alg_region->type);\r\nif (!region_name) {\r\nadsp_err(dsp, "Unknown region type: %d\n", alg_region->type);\r\nreturn -EINVAL;\r\n}\r\nswitch (dsp->fw_ver) {\r\ncase 0:\r\ncase 1:\r\nsnprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, "DSP%d %s %x",\r\ndsp->num, region_name, alg_region->alg);\r\nbreak;\r\ndefault:\r\nret = snprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,\r\n"DSP%d%c %.12s %x", dsp->num, *region_name,\r\nwm_adsp_fw_text[dsp->fw], alg_region->alg);\r\nif (subname) {\r\nint avail = SNDRV_CTL_ELEM_ID_NAME_MAXLEN - ret - 2;\r\nint skip = 0;\r\nif (subname_len > avail)\r\nskip = subname_len - avail;\r\nsnprintf(name + ret,\r\nSNDRV_CTL_ELEM_ID_NAME_MAXLEN - ret, " %.*s",\r\nsubname_len - skip, subname + skip);\r\n}\r\nbreak;\r\n}\r\nlist_for_each_entry(ctl, &dsp->ctl_list, list) {\r\nif (!strcmp(ctl->name, name)) {\r\nif (!ctl->enabled)\r\nctl->enabled = 1;\r\nreturn 0;\r\n}\r\n}\r\nctl = kzalloc(sizeof(*ctl), GFP_KERNEL);\r\nif (!ctl)\r\nreturn -ENOMEM;\r\nctl->fw_name = wm_adsp_fw_text[dsp->fw];\r\nctl->alg_region = *alg_region;\r\nctl->name = kmemdup(name, strlen(name) + 1, GFP_KERNEL);\r\nif (!ctl->name) {\r\nret = -ENOMEM;\r\ngoto err_ctl;\r\n}\r\nctl->enabled = 1;\r\nctl->set = 0;\r\nctl->ops.xget = wm_coeff_get;\r\nctl->ops.xput = wm_coeff_put;\r\nctl->dsp = dsp;\r\nctl->flags = flags;\r\nctl->type = type;\r\nctl->offset = offset;\r\nctl->len = len;\r\nctl->cache = kzalloc(ctl->len, GFP_KERNEL);\r\nif (!ctl->cache) {\r\nret = -ENOMEM;\r\ngoto err_ctl_name;\r\n}\r\nlist_add(&ctl->list, &dsp->ctl_list);\r\nif (flags & WMFW_CTL_FLAG_SYS)\r\nreturn 0;\r\nctl_work = kzalloc(sizeof(*ctl_work), GFP_KERNEL);\r\nif (!ctl_work) {\r\nret = -ENOMEM;\r\ngoto err_ctl_cache;\r\n}\r\nctl_work->dsp = dsp;\r\nctl_work->ctl = ctl;\r\nINIT_WORK(&ctl_work->work, wm_adsp_ctl_work);\r\nschedule_work(&ctl_work->work);\r\nreturn 0;\r\nerr_ctl_cache:\r\nkfree(ctl->cache);\r\nerr_ctl_name:\r\nkfree(ctl->name);\r\nerr_ctl:\r\nkfree(ctl);\r\nreturn ret;\r\n}\r\nstatic int wm_coeff_parse_string(int bytes, const u8 **pos, const u8 **str)\r\n{\r\nint length;\r\nswitch (bytes) {\r\ncase 1:\r\nlength = **pos;\r\nbreak;\r\ncase 2:\r\nlength = le16_to_cpu(*((__le16 *)*pos));\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (str)\r\n*str = *pos + bytes;\r\n*pos += ((length + bytes) + 3) & ~0x03;\r\nreturn length;\r\n}\r\nstatic int wm_coeff_parse_int(int bytes, const u8 **pos)\r\n{\r\nint val = 0;\r\nswitch (bytes) {\r\ncase 2:\r\nval = le16_to_cpu(*((__le16 *)*pos));\r\nbreak;\r\ncase 4:\r\nval = le32_to_cpu(*((__le32 *)*pos));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n*pos += bytes;\r\nreturn val;\r\n}\r\nstatic inline void wm_coeff_parse_alg(struct wm_adsp *dsp, const u8 **data,\r\nstruct wm_coeff_parsed_alg *blk)\r\n{\r\nconst struct wmfw_adsp_alg_data *raw;\r\nswitch (dsp->fw_ver) {\r\ncase 0:\r\ncase 1:\r\nraw = (const struct wmfw_adsp_alg_data *)*data;\r\n*data = raw->data;\r\nblk->id = le32_to_cpu(raw->id);\r\nblk->name = raw->name;\r\nblk->name_len = strlen(raw->name);\r\nblk->ncoeff = le32_to_cpu(raw->ncoeff);\r\nbreak;\r\ndefault:\r\nblk->id = wm_coeff_parse_int(sizeof(raw->id), data);\r\nblk->name_len = wm_coeff_parse_string(sizeof(u8), data,\r\n&blk->name);\r\nwm_coeff_parse_string(sizeof(u16), data, NULL);\r\nblk->ncoeff = wm_coeff_parse_int(sizeof(raw->ncoeff), data);\r\nbreak;\r\n}\r\nadsp_dbg(dsp, "Algorithm ID: %#x\n", blk->id);\r\nadsp_dbg(dsp, "Algorithm name: %.*s\n", blk->name_len, blk->name);\r\nadsp_dbg(dsp, "# of coefficient descriptors: %#x\n", blk->ncoeff);\r\n}\r\nstatic inline void wm_coeff_parse_coeff(struct wm_adsp *dsp, const u8 **data,\r\nstruct wm_coeff_parsed_coeff *blk)\r\n{\r\nconst struct wmfw_adsp_coeff_data *raw;\r\nconst u8 *tmp;\r\nint length;\r\nswitch (dsp->fw_ver) {\r\ncase 0:\r\ncase 1:\r\nraw = (const struct wmfw_adsp_coeff_data *)*data;\r\n*data = *data + sizeof(raw->hdr) + le32_to_cpu(raw->hdr.size);\r\nblk->offset = le16_to_cpu(raw->hdr.offset);\r\nblk->mem_type = le16_to_cpu(raw->hdr.type);\r\nblk->name = raw->name;\r\nblk->name_len = strlen(raw->name);\r\nblk->ctl_type = le16_to_cpu(raw->ctl_type);\r\nblk->flags = le16_to_cpu(raw->flags);\r\nblk->len = le32_to_cpu(raw->len);\r\nbreak;\r\ndefault:\r\ntmp = *data;\r\nblk->offset = wm_coeff_parse_int(sizeof(raw->hdr.offset), &tmp);\r\nblk->mem_type = wm_coeff_parse_int(sizeof(raw->hdr.type), &tmp);\r\nlength = wm_coeff_parse_int(sizeof(raw->hdr.size), &tmp);\r\nblk->name_len = wm_coeff_parse_string(sizeof(u8), &tmp,\r\n&blk->name);\r\nwm_coeff_parse_string(sizeof(u8), &tmp, NULL);\r\nwm_coeff_parse_string(sizeof(u16), &tmp, NULL);\r\nblk->ctl_type = wm_coeff_parse_int(sizeof(raw->ctl_type), &tmp);\r\nblk->flags = wm_coeff_parse_int(sizeof(raw->flags), &tmp);\r\nblk->len = wm_coeff_parse_int(sizeof(raw->len), &tmp);\r\n*data = *data + sizeof(raw->hdr) + length;\r\nbreak;\r\n}\r\nadsp_dbg(dsp, "\tCoefficient type: %#x\n", blk->mem_type);\r\nadsp_dbg(dsp, "\tCoefficient offset: %#x\n", blk->offset);\r\nadsp_dbg(dsp, "\tCoefficient name: %.*s\n", blk->name_len, blk->name);\r\nadsp_dbg(dsp, "\tCoefficient flags: %#x\n", blk->flags);\r\nadsp_dbg(dsp, "\tALSA control type: %#x\n", blk->ctl_type);\r\nadsp_dbg(dsp, "\tALSA control len: %#x\n", blk->len);\r\n}\r\nstatic int wm_adsp_check_coeff_flags(struct wm_adsp *dsp,\r\nconst struct wm_coeff_parsed_coeff *coeff_blk,\r\nunsigned int f_required,\r\nunsigned int f_illegal)\r\n{\r\nif ((coeff_blk->flags & f_illegal) ||\r\n((coeff_blk->flags & f_required) != f_required)) {\r\nadsp_err(dsp, "Illegal flags 0x%x for control type 0x%x\n",\r\ncoeff_blk->flags, coeff_blk->ctl_type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm_adsp_parse_coeff(struct wm_adsp *dsp,\r\nconst struct wmfw_region *region)\r\n{\r\nstruct wm_adsp_alg_region alg_region = {};\r\nstruct wm_coeff_parsed_alg alg_blk;\r\nstruct wm_coeff_parsed_coeff coeff_blk;\r\nconst u8 *data = region->data;\r\nint i, ret;\r\nwm_coeff_parse_alg(dsp, &data, &alg_blk);\r\nfor (i = 0; i < alg_blk.ncoeff; i++) {\r\nwm_coeff_parse_coeff(dsp, &data, &coeff_blk);\r\nswitch (coeff_blk.ctl_type) {\r\ncase SNDRV_CTL_ELEM_TYPE_BYTES:\r\nbreak;\r\ncase WMFW_CTL_TYPE_ACKED:\r\nif (coeff_blk.flags & WMFW_CTL_FLAG_SYS)\r\ncontinue;\r\nret = wm_adsp_check_coeff_flags(dsp, &coeff_blk,\r\nWMFW_CTL_FLAG_VOLATILE |\r\nWMFW_CTL_FLAG_WRITEABLE |\r\nWMFW_CTL_FLAG_READABLE,\r\n0);\r\nif (ret)\r\nreturn -EINVAL;\r\nbreak;\r\ncase WMFW_CTL_TYPE_HOSTEVENT:\r\nret = wm_adsp_check_coeff_flags(dsp, &coeff_blk,\r\nWMFW_CTL_FLAG_SYS |\r\nWMFW_CTL_FLAG_VOLATILE |\r\nWMFW_CTL_FLAG_WRITEABLE |\r\nWMFW_CTL_FLAG_READABLE,\r\n0);\r\nif (ret)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nadsp_err(dsp, "Unknown control type: %d\n",\r\ncoeff_blk.ctl_type);\r\nreturn -EINVAL;\r\n}\r\nalg_region.type = coeff_blk.mem_type;\r\nalg_region.alg = alg_blk.id;\r\nret = wm_adsp_create_control(dsp, &alg_region,\r\ncoeff_blk.offset,\r\ncoeff_blk.len,\r\ncoeff_blk.name,\r\ncoeff_blk.name_len,\r\ncoeff_blk.flags,\r\ncoeff_blk.ctl_type);\r\nif (ret < 0)\r\nadsp_err(dsp, "Failed to create control: %.*s, %d\n",\r\ncoeff_blk.name_len, coeff_blk.name, ret);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm_adsp_load(struct wm_adsp *dsp)\r\n{\r\nLIST_HEAD(buf_list);\r\nconst struct firmware *firmware;\r\nstruct regmap *regmap = dsp->regmap;\r\nunsigned int pos = 0;\r\nconst struct wmfw_header *header;\r\nconst struct wmfw_adsp1_sizes *adsp1_sizes;\r\nconst struct wmfw_adsp2_sizes *adsp2_sizes;\r\nconst struct wmfw_footer *footer;\r\nconst struct wmfw_region *region;\r\nconst struct wm_adsp_region *mem;\r\nconst char *region_name;\r\nchar *file, *text = NULL;\r\nstruct wm_adsp_buf *buf;\r\nunsigned int reg;\r\nint regions = 0;\r\nint ret, offset, type, sizes;\r\nfile = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (file == NULL)\r\nreturn -ENOMEM;\r\nsnprintf(file, PAGE_SIZE, "%s-dsp%d-%s.wmfw", dsp->part, dsp->num,\r\nwm_adsp_fw[dsp->fw].file);\r\nfile[PAGE_SIZE - 1] = '\0';\r\nret = request_firmware(&firmware, file, dsp->dev);\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to request '%s'\n", file);\r\ngoto out;\r\n}\r\nret = -EINVAL;\r\npos = sizeof(*header) + sizeof(*adsp1_sizes) + sizeof(*footer);\r\nif (pos >= firmware->size) {\r\nadsp_err(dsp, "%s: file too short, %zu bytes\n",\r\nfile, firmware->size);\r\ngoto out_fw;\r\n}\r\nheader = (void *)&firmware->data[0];\r\nif (memcmp(&header->magic[0], "WMFW", 4) != 0) {\r\nadsp_err(dsp, "%s: invalid magic\n", file);\r\ngoto out_fw;\r\n}\r\nswitch (header->ver) {\r\ncase 0:\r\nadsp_warn(dsp, "%s: Depreciated file format %d\n",\r\nfile, header->ver);\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nbreak;\r\ndefault:\r\nadsp_err(dsp, "%s: unknown file format %d\n",\r\nfile, header->ver);\r\ngoto out_fw;\r\n}\r\nadsp_info(dsp, "Firmware version: %d\n", header->ver);\r\ndsp->fw_ver = header->ver;\r\nif (header->core != dsp->type) {\r\nadsp_err(dsp, "%s: invalid core %d != %d\n",\r\nfile, header->core, dsp->type);\r\ngoto out_fw;\r\n}\r\nswitch (dsp->type) {\r\ncase WMFW_ADSP1:\r\npos = sizeof(*header) + sizeof(*adsp1_sizes) + sizeof(*footer);\r\nadsp1_sizes = (void *)&(header[1]);\r\nfooter = (void *)&(adsp1_sizes[1]);\r\nsizes = sizeof(*adsp1_sizes);\r\nadsp_dbg(dsp, "%s: %d DM, %d PM, %d ZM\n",\r\nfile, le32_to_cpu(adsp1_sizes->dm),\r\nle32_to_cpu(adsp1_sizes->pm),\r\nle32_to_cpu(adsp1_sizes->zm));\r\nbreak;\r\ncase WMFW_ADSP2:\r\npos = sizeof(*header) + sizeof(*adsp2_sizes) + sizeof(*footer);\r\nadsp2_sizes = (void *)&(header[1]);\r\nfooter = (void *)&(adsp2_sizes[1]);\r\nsizes = sizeof(*adsp2_sizes);\r\nadsp_dbg(dsp, "%s: %d XM, %d YM %d PM, %d ZM\n",\r\nfile, le32_to_cpu(adsp2_sizes->xm),\r\nle32_to_cpu(adsp2_sizes->ym),\r\nle32_to_cpu(adsp2_sizes->pm),\r\nle32_to_cpu(adsp2_sizes->zm));\r\nbreak;\r\ndefault:\r\nWARN(1, "Unknown DSP type");\r\ngoto out_fw;\r\n}\r\nif (le32_to_cpu(header->len) != sizeof(*header) +\r\nsizes + sizeof(*footer)) {\r\nadsp_err(dsp, "%s: unexpected header length %d\n",\r\nfile, le32_to_cpu(header->len));\r\ngoto out_fw;\r\n}\r\nadsp_dbg(dsp, "%s: timestamp %llu\n", file,\r\nle64_to_cpu(footer->timestamp));\r\nwhile (pos < firmware->size &&\r\npos - firmware->size > sizeof(*region)) {\r\nregion = (void *)&(firmware->data[pos]);\r\nregion_name = "Unknown";\r\nreg = 0;\r\ntext = NULL;\r\noffset = le32_to_cpu(region->offset) & 0xffffff;\r\ntype = be32_to_cpu(region->type) & 0xff;\r\nmem = wm_adsp_find_region(dsp, type);\r\nswitch (type) {\r\ncase WMFW_NAME_TEXT:\r\nregion_name = "Firmware name";\r\ntext = kzalloc(le32_to_cpu(region->len) + 1,\r\nGFP_KERNEL);\r\nbreak;\r\ncase WMFW_ALGORITHM_DATA:\r\nregion_name = "Algorithm";\r\nret = wm_adsp_parse_coeff(dsp, region);\r\nif (ret != 0)\r\ngoto out_fw;\r\nbreak;\r\ncase WMFW_INFO_TEXT:\r\nregion_name = "Information";\r\ntext = kzalloc(le32_to_cpu(region->len) + 1,\r\nGFP_KERNEL);\r\nbreak;\r\ncase WMFW_ABSOLUTE:\r\nregion_name = "Absolute";\r\nreg = offset;\r\nbreak;\r\ncase WMFW_ADSP1_PM:\r\ncase WMFW_ADSP1_DM:\r\ncase WMFW_ADSP2_XM:\r\ncase WMFW_ADSP2_YM:\r\ncase WMFW_ADSP1_ZM:\r\nregion_name = wm_adsp_mem_region_name(type);\r\nreg = wm_adsp_region_to_reg(mem, offset);\r\nbreak;\r\ndefault:\r\nadsp_warn(dsp,\r\n"%s.%d: Unknown region type %x at %d(%x)\n",\r\nfile, regions, type, pos, pos);\r\nbreak;\r\n}\r\nadsp_dbg(dsp, "%s.%d: %d bytes at %d in %s\n", file,\r\nregions, le32_to_cpu(region->len), offset,\r\nregion_name);\r\nif ((pos + le32_to_cpu(region->len) + sizeof(*region)) >\r\nfirmware->size) {\r\nadsp_err(dsp,\r\n"%s.%d: %s region len %d bytes exceeds file length %zu\n",\r\nfile, regions, region_name,\r\nle32_to_cpu(region->len), firmware->size);\r\nret = -EINVAL;\r\ngoto out_fw;\r\n}\r\nif (text) {\r\nmemcpy(text, region->data, le32_to_cpu(region->len));\r\nadsp_info(dsp, "%s: %s\n", file, text);\r\nkfree(text);\r\ntext = NULL;\r\n}\r\nif (reg) {\r\nbuf = wm_adsp_buf_alloc(region->data,\r\nle32_to_cpu(region->len),\r\n&buf_list);\r\nif (!buf) {\r\nadsp_err(dsp, "Out of memory\n");\r\nret = -ENOMEM;\r\ngoto out_fw;\r\n}\r\nret = regmap_raw_write_async(regmap, reg, buf->buf,\r\nle32_to_cpu(region->len));\r\nif (ret != 0) {\r\nadsp_err(dsp,\r\n"%s.%d: Failed to write %d bytes at %d in %s: %d\n",\r\nfile, regions,\r\nle32_to_cpu(region->len), offset,\r\nregion_name, ret);\r\ngoto out_fw;\r\n}\r\n}\r\npos += le32_to_cpu(region->len) + sizeof(*region);\r\nregions++;\r\n}\r\nret = regmap_async_complete(regmap);\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to complete async write: %d\n", ret);\r\ngoto out_fw;\r\n}\r\nif (pos > firmware->size)\r\nadsp_warn(dsp, "%s.%d: %zu bytes at end of file\n",\r\nfile, regions, pos - firmware->size);\r\nwm_adsp_debugfs_save_wmfwname(dsp, file);\r\nout_fw:\r\nregmap_async_complete(regmap);\r\nwm_adsp_buf_free(&buf_list);\r\nrelease_firmware(firmware);\r\nkfree(text);\r\nout:\r\nkfree(file);\r\nreturn ret;\r\n}\r\nstatic void wm_adsp_ctl_fixup_base(struct wm_adsp *dsp,\r\nconst struct wm_adsp_alg_region *alg_region)\r\n{\r\nstruct wm_coeff_ctl *ctl;\r\nlist_for_each_entry(ctl, &dsp->ctl_list, list) {\r\nif (ctl->fw_name == wm_adsp_fw_text[dsp->fw] &&\r\nalg_region->alg == ctl->alg_region.alg &&\r\nalg_region->type == ctl->alg_region.type) {\r\nctl->alg_region.base = alg_region->base;\r\n}\r\n}\r\n}\r\nstatic void *wm_adsp_read_algs(struct wm_adsp *dsp, size_t n_algs,\r\nunsigned int pos, unsigned int len)\r\n{\r\nvoid *alg;\r\nint ret;\r\n__be32 val;\r\nif (n_algs == 0) {\r\nadsp_err(dsp, "No algorithms\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (n_algs > 1024) {\r\nadsp_err(dsp, "Algorithm count %zx excessive\n", n_algs);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nret = regmap_raw_read(dsp->regmap, pos + len, &val, sizeof(val));\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to read algorithm list end: %d\n",\r\nret);\r\nreturn ERR_PTR(ret);\r\n}\r\nif (be32_to_cpu(val) != 0xbedead)\r\nadsp_warn(dsp, "Algorithm list end %x 0x%x != 0xbedead\n",\r\npos + len, be32_to_cpu(val));\r\nalg = kzalloc(len * 2, GFP_KERNEL | GFP_DMA);\r\nif (!alg)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = regmap_raw_read(dsp->regmap, pos, alg, len * 2);\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to read algorithm list: %d\n", ret);\r\nkfree(alg);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn alg;\r\n}\r\nstatic struct wm_adsp_alg_region *\r\nwm_adsp_find_alg_region(struct wm_adsp *dsp, int type, unsigned int id)\r\n{\r\nstruct wm_adsp_alg_region *alg_region;\r\nlist_for_each_entry(alg_region, &dsp->alg_regions, list) {\r\nif (id == alg_region->alg && type == alg_region->type)\r\nreturn alg_region;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct wm_adsp_alg_region *wm_adsp_create_region(struct wm_adsp *dsp,\r\nint type, __be32 id,\r\n__be32 base)\r\n{\r\nstruct wm_adsp_alg_region *alg_region;\r\nalg_region = kzalloc(sizeof(*alg_region), GFP_KERNEL);\r\nif (!alg_region)\r\nreturn ERR_PTR(-ENOMEM);\r\nalg_region->type = type;\r\nalg_region->alg = be32_to_cpu(id);\r\nalg_region->base = be32_to_cpu(base);\r\nlist_add_tail(&alg_region->list, &dsp->alg_regions);\r\nif (dsp->fw_ver > 0)\r\nwm_adsp_ctl_fixup_base(dsp, alg_region);\r\nreturn alg_region;\r\n}\r\nstatic void wm_adsp_free_alg_regions(struct wm_adsp *dsp)\r\n{\r\nstruct wm_adsp_alg_region *alg_region;\r\nwhile (!list_empty(&dsp->alg_regions)) {\r\nalg_region = list_first_entry(&dsp->alg_regions,\r\nstruct wm_adsp_alg_region,\r\nlist);\r\nlist_del(&alg_region->list);\r\nkfree(alg_region);\r\n}\r\n}\r\nstatic int wm_adsp1_setup_algs(struct wm_adsp *dsp)\r\n{\r\nstruct wmfw_adsp1_id_hdr adsp1_id;\r\nstruct wmfw_adsp1_alg_hdr *adsp1_alg;\r\nstruct wm_adsp_alg_region *alg_region;\r\nconst struct wm_adsp_region *mem;\r\nunsigned int pos, len;\r\nsize_t n_algs;\r\nint i, ret;\r\nmem = wm_adsp_find_region(dsp, WMFW_ADSP1_DM);\r\nif (WARN_ON(!mem))\r\nreturn -EINVAL;\r\nret = regmap_raw_read(dsp->regmap, mem->base, &adsp1_id,\r\nsizeof(adsp1_id));\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to read algorithm info: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nn_algs = be32_to_cpu(adsp1_id.n_algs);\r\ndsp->fw_id = be32_to_cpu(adsp1_id.fw.id);\r\nadsp_info(dsp, "Firmware: %x v%d.%d.%d, %zu algorithms\n",\r\ndsp->fw_id,\r\n(be32_to_cpu(adsp1_id.fw.ver) & 0xff0000) >> 16,\r\n(be32_to_cpu(adsp1_id.fw.ver) & 0xff00) >> 8,\r\nbe32_to_cpu(adsp1_id.fw.ver) & 0xff,\r\nn_algs);\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_ZM,\r\nadsp1_id.fw.id, adsp1_id.zm);\r\nif (IS_ERR(alg_region))\r\nreturn PTR_ERR(alg_region);\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_DM,\r\nadsp1_id.fw.id, adsp1_id.dm);\r\nif (IS_ERR(alg_region))\r\nreturn PTR_ERR(alg_region);\r\npos = sizeof(adsp1_id) / 2;\r\nlen = (sizeof(*adsp1_alg) * n_algs) / 2;\r\nadsp1_alg = wm_adsp_read_algs(dsp, n_algs, mem->base + pos, len);\r\nif (IS_ERR(adsp1_alg))\r\nreturn PTR_ERR(adsp1_alg);\r\nfor (i = 0; i < n_algs; i++) {\r\nadsp_info(dsp, "%d: ID %x v%d.%d.%d DM@%x ZM@%x\n",\r\ni, be32_to_cpu(adsp1_alg[i].alg.id),\r\n(be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff0000) >> 16,\r\n(be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff00) >> 8,\r\nbe32_to_cpu(adsp1_alg[i].alg.ver) & 0xff,\r\nbe32_to_cpu(adsp1_alg[i].dm),\r\nbe32_to_cpu(adsp1_alg[i].zm));\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_DM,\r\nadsp1_alg[i].alg.id,\r\nadsp1_alg[i].dm);\r\nif (IS_ERR(alg_region)) {\r\nret = PTR_ERR(alg_region);\r\ngoto out;\r\n}\r\nif (dsp->fw_ver == 0) {\r\nif (i + 1 < n_algs) {\r\nlen = be32_to_cpu(adsp1_alg[i + 1].dm);\r\nlen -= be32_to_cpu(adsp1_alg[i].dm);\r\nlen *= 4;\r\nwm_adsp_create_control(dsp, alg_region, 0,\r\nlen, NULL, 0, 0,\r\nSNDRV_CTL_ELEM_TYPE_BYTES);\r\n} else {\r\nadsp_warn(dsp, "Missing length info for region DM with ID %x\n",\r\nbe32_to_cpu(adsp1_alg[i].alg.id));\r\n}\r\n}\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_ZM,\r\nadsp1_alg[i].alg.id,\r\nadsp1_alg[i].zm);\r\nif (IS_ERR(alg_region)) {\r\nret = PTR_ERR(alg_region);\r\ngoto out;\r\n}\r\nif (dsp->fw_ver == 0) {\r\nif (i + 1 < n_algs) {\r\nlen = be32_to_cpu(adsp1_alg[i + 1].zm);\r\nlen -= be32_to_cpu(adsp1_alg[i].zm);\r\nlen *= 4;\r\nwm_adsp_create_control(dsp, alg_region, 0,\r\nlen, NULL, 0, 0,\r\nSNDRV_CTL_ELEM_TYPE_BYTES);\r\n} else {\r\nadsp_warn(dsp, "Missing length info for region ZM with ID %x\n",\r\nbe32_to_cpu(adsp1_alg[i].alg.id));\r\n}\r\n}\r\n}\r\nout:\r\nkfree(adsp1_alg);\r\nreturn ret;\r\n}\r\nstatic int wm_adsp2_setup_algs(struct wm_adsp *dsp)\r\n{\r\nstruct wmfw_adsp2_id_hdr adsp2_id;\r\nstruct wmfw_adsp2_alg_hdr *adsp2_alg;\r\nstruct wm_adsp_alg_region *alg_region;\r\nconst struct wm_adsp_region *mem;\r\nunsigned int pos, len;\r\nsize_t n_algs;\r\nint i, ret;\r\nmem = wm_adsp_find_region(dsp, WMFW_ADSP2_XM);\r\nif (WARN_ON(!mem))\r\nreturn -EINVAL;\r\nret = regmap_raw_read(dsp->regmap, mem->base, &adsp2_id,\r\nsizeof(adsp2_id));\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to read algorithm info: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nn_algs = be32_to_cpu(adsp2_id.n_algs);\r\ndsp->fw_id = be32_to_cpu(adsp2_id.fw.id);\r\ndsp->fw_id_version = be32_to_cpu(adsp2_id.fw.ver);\r\nadsp_info(dsp, "Firmware: %x v%d.%d.%d, %zu algorithms\n",\r\ndsp->fw_id,\r\n(dsp->fw_id_version & 0xff0000) >> 16,\r\n(dsp->fw_id_version & 0xff00) >> 8,\r\ndsp->fw_id_version & 0xff,\r\nn_algs);\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_XM,\r\nadsp2_id.fw.id, adsp2_id.xm);\r\nif (IS_ERR(alg_region))\r\nreturn PTR_ERR(alg_region);\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_YM,\r\nadsp2_id.fw.id, adsp2_id.ym);\r\nif (IS_ERR(alg_region))\r\nreturn PTR_ERR(alg_region);\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_ZM,\r\nadsp2_id.fw.id, adsp2_id.zm);\r\nif (IS_ERR(alg_region))\r\nreturn PTR_ERR(alg_region);\r\npos = sizeof(adsp2_id) / 2;\r\nlen = (sizeof(*adsp2_alg) * n_algs) / 2;\r\nadsp2_alg = wm_adsp_read_algs(dsp, n_algs, mem->base + pos, len);\r\nif (IS_ERR(adsp2_alg))\r\nreturn PTR_ERR(adsp2_alg);\r\nfor (i = 0; i < n_algs; i++) {\r\nadsp_info(dsp,\r\n"%d: ID %x v%d.%d.%d XM@%x YM@%x ZM@%x\n",\r\ni, be32_to_cpu(adsp2_alg[i].alg.id),\r\n(be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff0000) >> 16,\r\n(be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff00) >> 8,\r\nbe32_to_cpu(adsp2_alg[i].alg.ver) & 0xff,\r\nbe32_to_cpu(adsp2_alg[i].xm),\r\nbe32_to_cpu(adsp2_alg[i].ym),\r\nbe32_to_cpu(adsp2_alg[i].zm));\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_XM,\r\nadsp2_alg[i].alg.id,\r\nadsp2_alg[i].xm);\r\nif (IS_ERR(alg_region)) {\r\nret = PTR_ERR(alg_region);\r\ngoto out;\r\n}\r\nif (dsp->fw_ver == 0) {\r\nif (i + 1 < n_algs) {\r\nlen = be32_to_cpu(adsp2_alg[i + 1].xm);\r\nlen -= be32_to_cpu(adsp2_alg[i].xm);\r\nlen *= 4;\r\nwm_adsp_create_control(dsp, alg_region, 0,\r\nlen, NULL, 0, 0,\r\nSNDRV_CTL_ELEM_TYPE_BYTES);\r\n} else {\r\nadsp_warn(dsp, "Missing length info for region XM with ID %x\n",\r\nbe32_to_cpu(adsp2_alg[i].alg.id));\r\n}\r\n}\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_YM,\r\nadsp2_alg[i].alg.id,\r\nadsp2_alg[i].ym);\r\nif (IS_ERR(alg_region)) {\r\nret = PTR_ERR(alg_region);\r\ngoto out;\r\n}\r\nif (dsp->fw_ver == 0) {\r\nif (i + 1 < n_algs) {\r\nlen = be32_to_cpu(adsp2_alg[i + 1].ym);\r\nlen -= be32_to_cpu(adsp2_alg[i].ym);\r\nlen *= 4;\r\nwm_adsp_create_control(dsp, alg_region, 0,\r\nlen, NULL, 0, 0,\r\nSNDRV_CTL_ELEM_TYPE_BYTES);\r\n} else {\r\nadsp_warn(dsp, "Missing length info for region YM with ID %x\n",\r\nbe32_to_cpu(adsp2_alg[i].alg.id));\r\n}\r\n}\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_ZM,\r\nadsp2_alg[i].alg.id,\r\nadsp2_alg[i].zm);\r\nif (IS_ERR(alg_region)) {\r\nret = PTR_ERR(alg_region);\r\ngoto out;\r\n}\r\nif (dsp->fw_ver == 0) {\r\nif (i + 1 < n_algs) {\r\nlen = be32_to_cpu(adsp2_alg[i + 1].zm);\r\nlen -= be32_to_cpu(adsp2_alg[i].zm);\r\nlen *= 4;\r\nwm_adsp_create_control(dsp, alg_region, 0,\r\nlen, NULL, 0, 0,\r\nSNDRV_CTL_ELEM_TYPE_BYTES);\r\n} else {\r\nadsp_warn(dsp, "Missing length info for region ZM with ID %x\n",\r\nbe32_to_cpu(adsp2_alg[i].alg.id));\r\n}\r\n}\r\n}\r\nout:\r\nkfree(adsp2_alg);\r\nreturn ret;\r\n}\r\nstatic int wm_adsp_load_coeff(struct wm_adsp *dsp)\r\n{\r\nLIST_HEAD(buf_list);\r\nstruct regmap *regmap = dsp->regmap;\r\nstruct wmfw_coeff_hdr *hdr;\r\nstruct wmfw_coeff_item *blk;\r\nconst struct firmware *firmware;\r\nconst struct wm_adsp_region *mem;\r\nstruct wm_adsp_alg_region *alg_region;\r\nconst char *region_name;\r\nint ret, pos, blocks, type, offset, reg;\r\nchar *file;\r\nstruct wm_adsp_buf *buf;\r\nfile = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (file == NULL)\r\nreturn -ENOMEM;\r\nsnprintf(file, PAGE_SIZE, "%s-dsp%d-%s.bin", dsp->part, dsp->num,\r\nwm_adsp_fw[dsp->fw].file);\r\nfile[PAGE_SIZE - 1] = '\0';\r\nret = request_firmware(&firmware, file, dsp->dev);\r\nif (ret != 0) {\r\nadsp_warn(dsp, "Failed to request '%s'\n", file);\r\nret = 0;\r\ngoto out;\r\n}\r\nret = -EINVAL;\r\nif (sizeof(*hdr) >= firmware->size) {\r\nadsp_err(dsp, "%s: file too short, %zu bytes\n",\r\nfile, firmware->size);\r\ngoto out_fw;\r\n}\r\nhdr = (void *)&firmware->data[0];\r\nif (memcmp(hdr->magic, "WMDR", 4) != 0) {\r\nadsp_err(dsp, "%s: invalid magic\n", file);\r\ngoto out_fw;\r\n}\r\nswitch (be32_to_cpu(hdr->rev) & 0xff) {\r\ncase 1:\r\nbreak;\r\ndefault:\r\nadsp_err(dsp, "%s: Unsupported coefficient file format %d\n",\r\nfile, be32_to_cpu(hdr->rev) & 0xff);\r\nret = -EINVAL;\r\ngoto out_fw;\r\n}\r\nadsp_dbg(dsp, "%s: v%d.%d.%d\n", file,\r\n(le32_to_cpu(hdr->ver) >> 16) & 0xff,\r\n(le32_to_cpu(hdr->ver) >> 8) & 0xff,\r\nle32_to_cpu(hdr->ver) & 0xff);\r\npos = le32_to_cpu(hdr->len);\r\nblocks = 0;\r\nwhile (pos < firmware->size &&\r\npos - firmware->size > sizeof(*blk)) {\r\nblk = (void *)(&firmware->data[pos]);\r\ntype = le16_to_cpu(blk->type);\r\noffset = le16_to_cpu(blk->offset);\r\nadsp_dbg(dsp, "%s.%d: %x v%d.%d.%d\n",\r\nfile, blocks, le32_to_cpu(blk->id),\r\n(le32_to_cpu(blk->ver) >> 16) & 0xff,\r\n(le32_to_cpu(blk->ver) >> 8) & 0xff,\r\nle32_to_cpu(blk->ver) & 0xff);\r\nadsp_dbg(dsp, "%s.%d: %d bytes at 0x%x in %x\n",\r\nfile, blocks, le32_to_cpu(blk->len), offset, type);\r\nreg = 0;\r\nregion_name = "Unknown";\r\nswitch (type) {\r\ncase (WMFW_NAME_TEXT << 8):\r\ncase (WMFW_INFO_TEXT << 8):\r\nbreak;\r\ncase (WMFW_ABSOLUTE << 8):\r\nif (le32_to_cpu(blk->id) == dsp->fw_id &&\r\noffset == 0) {\r\nregion_name = "global coefficients";\r\nmem = wm_adsp_find_region(dsp, type);\r\nif (!mem) {\r\nadsp_err(dsp, "No ZM\n");\r\nbreak;\r\n}\r\nreg = wm_adsp_region_to_reg(mem, 0);\r\n} else {\r\nregion_name = "register";\r\nreg = offset;\r\n}\r\nbreak;\r\ncase WMFW_ADSP1_DM:\r\ncase WMFW_ADSP1_ZM:\r\ncase WMFW_ADSP2_XM:\r\ncase WMFW_ADSP2_YM:\r\nadsp_dbg(dsp, "%s.%d: %d bytes in %x for %x\n",\r\nfile, blocks, le32_to_cpu(blk->len),\r\ntype, le32_to_cpu(blk->id));\r\nmem = wm_adsp_find_region(dsp, type);\r\nif (!mem) {\r\nadsp_err(dsp, "No base for region %x\n", type);\r\nbreak;\r\n}\r\nalg_region = wm_adsp_find_alg_region(dsp, type,\r\nle32_to_cpu(blk->id));\r\nif (alg_region) {\r\nreg = alg_region->base;\r\nreg = wm_adsp_region_to_reg(mem, reg);\r\nreg += offset;\r\n} else {\r\nadsp_err(dsp, "No %x for algorithm %x\n",\r\ntype, le32_to_cpu(blk->id));\r\n}\r\nbreak;\r\ndefault:\r\nadsp_err(dsp, "%s.%d: Unknown region type %x at %d\n",\r\nfile, blocks, type, pos);\r\nbreak;\r\n}\r\nif (reg) {\r\nif ((pos + le32_to_cpu(blk->len) + sizeof(*blk)) >\r\nfirmware->size) {\r\nadsp_err(dsp,\r\n"%s.%d: %s region len %d bytes exceeds file length %zu\n",\r\nfile, blocks, region_name,\r\nle32_to_cpu(blk->len),\r\nfirmware->size);\r\nret = -EINVAL;\r\ngoto out_fw;\r\n}\r\nbuf = wm_adsp_buf_alloc(blk->data,\r\nle32_to_cpu(blk->len),\r\n&buf_list);\r\nif (!buf) {\r\nadsp_err(dsp, "Out of memory\n");\r\nret = -ENOMEM;\r\ngoto out_fw;\r\n}\r\nadsp_dbg(dsp, "%s.%d: Writing %d bytes at %x\n",\r\nfile, blocks, le32_to_cpu(blk->len),\r\nreg);\r\nret = regmap_raw_write_async(regmap, reg, buf->buf,\r\nle32_to_cpu(blk->len));\r\nif (ret != 0) {\r\nadsp_err(dsp,\r\n"%s.%d: Failed to write to %x in %s: %d\n",\r\nfile, blocks, reg, region_name, ret);\r\n}\r\n}\r\npos += (le32_to_cpu(blk->len) + sizeof(*blk) + 3) & ~0x03;\r\nblocks++;\r\n}\r\nret = regmap_async_complete(regmap);\r\nif (ret != 0)\r\nadsp_err(dsp, "Failed to complete async write: %d\n", ret);\r\nif (pos > firmware->size)\r\nadsp_warn(dsp, "%s.%d: %zu bytes at end of file\n",\r\nfile, blocks, pos - firmware->size);\r\nwm_adsp_debugfs_save_binname(dsp, file);\r\nout_fw:\r\nregmap_async_complete(regmap);\r\nrelease_firmware(firmware);\r\nwm_adsp_buf_free(&buf_list);\r\nout:\r\nkfree(file);\r\nreturn ret;\r\n}\r\nint wm_adsp1_init(struct wm_adsp *dsp)\r\n{\r\nINIT_LIST_HEAD(&dsp->alg_regions);\r\nmutex_init(&dsp->pwr_lock);\r\nreturn 0;\r\n}\r\nint wm_adsp1_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct wm_adsp *dsps = snd_soc_codec_get_drvdata(codec);\r\nstruct wm_adsp *dsp = &dsps[w->shift];\r\nstruct wm_coeff_ctl *ctl;\r\nint ret;\r\nunsigned int val;\r\ndsp->codec = codec;\r\nmutex_lock(&dsp->pwr_lock);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,\r\nADSP1_SYS_ENA, ADSP1_SYS_ENA);\r\nif (dsp->sysclk_reg) {\r\nret = regmap_read(dsp->regmap, dsp->sysclk_reg, &val);\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to read SYSCLK state: %d\n",\r\nret);\r\ngoto err_mutex;\r\n}\r\nval = (val & dsp->sysclk_mask) >> dsp->sysclk_shift;\r\nret = regmap_update_bits(dsp->regmap,\r\ndsp->base + ADSP1_CONTROL_31,\r\nADSP1_CLK_SEL_MASK, val);\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to set clock rate: %d\n",\r\nret);\r\ngoto err_mutex;\r\n}\r\n}\r\nret = wm_adsp_load(dsp);\r\nif (ret != 0)\r\ngoto err_ena;\r\nret = wm_adsp1_setup_algs(dsp);\r\nif (ret != 0)\r\ngoto err_ena;\r\nret = wm_adsp_load_coeff(dsp);\r\nif (ret != 0)\r\ngoto err_ena;\r\nret = wm_coeff_init_control_caches(dsp);\r\nif (ret != 0)\r\ngoto err_ena;\r\nret = wm_coeff_sync_controls(dsp);\r\nif (ret != 0)\r\ngoto err_ena;\r\ndsp->booted = true;\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,\r\nADSP1_CORE_ENA | ADSP1_START,\r\nADSP1_CORE_ENA | ADSP1_START);\r\ndsp->running = true;\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\ndsp->running = false;\r\ndsp->booted = false;\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,\r\nADSP1_CORE_ENA | ADSP1_START, 0);\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_19,\r\nADSP1_WDMA_BUFFER_LENGTH_MASK, 0);\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,\r\nADSP1_SYS_ENA, 0);\r\nlist_for_each_entry(ctl, &dsp->ctl_list, list)\r\nctl->enabled = 0;\r\nwm_adsp_free_alg_regions(dsp);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&dsp->pwr_lock);\r\nreturn 0;\r\nerr_ena:\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,\r\nADSP1_SYS_ENA, 0);\r\nerr_mutex:\r\nmutex_unlock(&dsp->pwr_lock);\r\nreturn ret;\r\n}\r\nstatic int wm_adsp2_ena(struct wm_adsp *dsp)\r\n{\r\nunsigned int val;\r\nint ret, count;\r\nswitch (dsp->rev) {\r\ncase 0:\r\nret = regmap_update_bits_async(dsp->regmap,\r\ndsp->base + ADSP2_CONTROL,\r\nADSP2_SYS_ENA, ADSP2_SYS_ENA);\r\nif (ret != 0)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfor (count = 0; count < 10; ++count) {\r\nret = regmap_read(dsp->regmap, dsp->base + ADSP2_STATUS1, &val);\r\nif (ret != 0)\r\nreturn ret;\r\nif (val & ADSP2_RAM_RDY)\r\nbreak;\r\nusleep_range(250, 500);\r\n}\r\nif (!(val & ADSP2_RAM_RDY)) {\r\nadsp_err(dsp, "Failed to start DSP RAM\n");\r\nreturn -EBUSY;\r\n}\r\nadsp_dbg(dsp, "RAM ready after %d polls\n", count);\r\nreturn 0;\r\n}\r\nstatic void wm_adsp2_boot_work(struct work_struct *work)\r\n{\r\nstruct wm_adsp *dsp = container_of(work,\r\nstruct wm_adsp,\r\nboot_work);\r\nint ret;\r\nmutex_lock(&dsp->pwr_lock);\r\nret = regmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\r\nADSP2_MEM_ENA, ADSP2_MEM_ENA);\r\nif (ret != 0)\r\ngoto err_mutex;\r\nret = wm_adsp2_ena(dsp);\r\nif (ret != 0)\r\ngoto err_mem;\r\nret = wm_adsp_load(dsp);\r\nif (ret != 0)\r\ngoto err_ena;\r\nret = wm_adsp2_setup_algs(dsp);\r\nif (ret != 0)\r\ngoto err_ena;\r\nret = wm_adsp_load_coeff(dsp);\r\nif (ret != 0)\r\ngoto err_ena;\r\nret = wm_coeff_init_control_caches(dsp);\r\nif (ret != 0)\r\ngoto err_ena;\r\nswitch (dsp->rev) {\r\ncase 0:\r\nret = regmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\r\nADSP2_SYS_ENA, 0);\r\nif (ret != 0)\r\ngoto err_ena;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndsp->booted = true;\r\nmutex_unlock(&dsp->pwr_lock);\r\nreturn;\r\nerr_ena:\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\r\nADSP2_SYS_ENA | ADSP2_CORE_ENA | ADSP2_START, 0);\r\nerr_mem:\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\r\nADSP2_MEM_ENA, 0);\r\nerr_mutex:\r\nmutex_unlock(&dsp->pwr_lock);\r\n}\r\nstatic void wm_adsp2_set_dspclk(struct wm_adsp *dsp, unsigned int freq)\r\n{\r\nint ret;\r\nswitch (dsp->rev) {\r\ncase 0:\r\nret = regmap_update_bits_async(dsp->regmap,\r\ndsp->base + ADSP2_CLOCKING,\r\nADSP2_CLK_SEL_MASK,\r\nfreq << ADSP2_CLK_SEL_SHIFT);\r\nif (ret) {\r\nadsp_err(dsp, "Failed to set clock rate: %d\n", ret);\r\nreturn;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nint wm_adsp2_preloader_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm_adsp *dsp = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = dsp->preloaded;\r\nreturn 0;\r\n}\r\nint wm_adsp2_preloader_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm_adsp *dsp = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nchar preload[32];\r\nsnprintf(preload, ARRAY_SIZE(preload), "DSP%u Preload", mc->shift);\r\ndsp->preloaded = ucontrol->value.integer.value[0];\r\nif (ucontrol->value.integer.value[0])\r\nsnd_soc_dapm_force_enable_pin(dapm, preload);\r\nelse\r\nsnd_soc_dapm_disable_pin(dapm, preload);\r\nsnd_soc_dapm_sync(dapm);\r\nreturn 0;\r\n}\r\nstatic void wm_adsp_stop_watchdog(struct wm_adsp *dsp)\r\n{\r\nswitch (dsp->rev) {\r\ncase 0:\r\ncase 1:\r\nreturn;\r\ndefault:\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP2_WATCHDOG,\r\nADSP2_WDT_ENA_MASK, 0);\r\n}\r\n}\r\nint wm_adsp2_early_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event,\r\nunsigned int freq)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct wm_adsp *dsps = snd_soc_codec_get_drvdata(codec);\r\nstruct wm_adsp *dsp = &dsps[w->shift];\r\nstruct wm_coeff_ctl *ctl;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nwm_adsp2_set_dspclk(dsp, freq);\r\nqueue_work(system_unbound_wq, &dsp->boot_work);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nmutex_lock(&dsp->pwr_lock);\r\nwm_adsp_debugfs_clear(dsp);\r\ndsp->fw_id = 0;\r\ndsp->fw_id_version = 0;\r\ndsp->booted = false;\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\r\nADSP2_MEM_ENA, 0);\r\nlist_for_each_entry(ctl, &dsp->ctl_list, list)\r\nctl->enabled = 0;\r\nwm_adsp_free_alg_regions(dsp);\r\nmutex_unlock(&dsp->pwr_lock);\r\nadsp_dbg(dsp, "Shutdown complete\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint wm_adsp2_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct wm_adsp *dsps = snd_soc_codec_get_drvdata(codec);\r\nstruct wm_adsp *dsp = &dsps[w->shift];\r\nint ret;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nflush_work(&dsp->boot_work);\r\nmutex_lock(&dsp->pwr_lock);\r\nif (!dsp->booted) {\r\nret = -EIO;\r\ngoto err;\r\n}\r\nret = wm_adsp2_ena(dsp);\r\nif (ret != 0)\r\ngoto err;\r\nret = wm_coeff_sync_controls(dsp);\r\nif (ret != 0)\r\ngoto err;\r\nwm_adsp2_lock(dsp, dsp->lock_regions);\r\nret = regmap_update_bits(dsp->regmap,\r\ndsp->base + ADSP2_CONTROL,\r\nADSP2_CORE_ENA | ADSP2_START,\r\nADSP2_CORE_ENA | ADSP2_START);\r\nif (ret != 0)\r\ngoto err;\r\nif (wm_adsp_fw[dsp->fw].num_caps != 0) {\r\nret = wm_adsp_buffer_init(dsp);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\ndsp->running = true;\r\nmutex_unlock(&dsp->pwr_lock);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nwm_adsp_signal_event_controls(dsp, WM_ADSP_FW_EVENT_SHUTDOWN);\r\nwm_adsp_stop_watchdog(dsp);\r\nswitch (dsp->rev) {\r\ncase 0:\r\nwm_adsp2_show_fw_status(dsp);\r\nbreak;\r\ndefault:\r\nwm_adsp2v2_show_fw_status(dsp);\r\nbreak;\r\n}\r\nmutex_lock(&dsp->pwr_lock);\r\ndsp->running = false;\r\nregmap_update_bits(dsp->regmap,\r\ndsp->base + ADSP2_CONTROL,\r\nADSP2_CORE_ENA | ADSP2_START, 0);\r\nswitch (dsp->rev) {\r\ncase 0:\r\nregmap_write(dsp->regmap,\r\ndsp->base + ADSP2_RDMA_CONFIG_1, 0);\r\nregmap_write(dsp->regmap,\r\ndsp->base + ADSP2_WDMA_CONFIG_1, 0);\r\nregmap_write(dsp->regmap,\r\ndsp->base + ADSP2_WDMA_CONFIG_2, 0);\r\nregmap_update_bits(dsp->regmap,\r\ndsp->base + ADSP2_CONTROL,\r\nADSP2_SYS_ENA, 0);\r\nbreak;\r\ndefault:\r\nregmap_write(dsp->regmap,\r\ndsp->base + ADSP2_RDMA_CONFIG_1, 0);\r\nregmap_write(dsp->regmap,\r\ndsp->base + ADSP2_WDMA_CONFIG_1, 0);\r\nregmap_write(dsp->regmap,\r\ndsp->base + ADSP2V2_WDMA_CONFIG_2, 0);\r\nbreak;\r\n}\r\nif (wm_adsp_fw[dsp->fw].num_caps != 0)\r\nwm_adsp_buffer_free(dsp);\r\nmutex_unlock(&dsp->pwr_lock);\r\nadsp_dbg(dsp, "Execution stopped\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\r\nADSP2_SYS_ENA | ADSP2_CORE_ENA | ADSP2_START, 0);\r\nmutex_unlock(&dsp->pwr_lock);\r\nreturn ret;\r\n}\r\nint wm_adsp2_codec_probe(struct wm_adsp *dsp, struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nchar preload[32];\r\nsnprintf(preload, ARRAY_SIZE(preload), "DSP%d Preload", dsp->num);\r\nsnd_soc_dapm_disable_pin(dapm, preload);\r\nwm_adsp2_init_debugfs(dsp, codec);\r\ndsp->codec = codec;\r\nreturn snd_soc_add_codec_controls(codec,\r\n&wm_adsp_fw_controls[dsp->num - 1],\r\n1);\r\n}\r\nint wm_adsp2_codec_remove(struct wm_adsp *dsp, struct snd_soc_codec *codec)\r\n{\r\nwm_adsp2_cleanup_debugfs(dsp);\r\nreturn 0;\r\n}\r\nint wm_adsp2_init(struct wm_adsp *dsp)\r\n{\r\nint ret;\r\nswitch (dsp->rev) {\r\ncase 0:\r\nret = regmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\r\nADSP2_MEM_ENA, 0);\r\nif (ret) {\r\nadsp_err(dsp,\r\n"Failed to clear memory retention: %d\n", ret);\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nINIT_LIST_HEAD(&dsp->alg_regions);\r\nINIT_LIST_HEAD(&dsp->ctl_list);\r\nINIT_WORK(&dsp->boot_work, wm_adsp2_boot_work);\r\nmutex_init(&dsp->pwr_lock);\r\nreturn 0;\r\n}\r\nvoid wm_adsp2_remove(struct wm_adsp *dsp)\r\n{\r\nstruct wm_coeff_ctl *ctl;\r\nwhile (!list_empty(&dsp->ctl_list)) {\r\nctl = list_first_entry(&dsp->ctl_list, struct wm_coeff_ctl,\r\nlist);\r\nlist_del(&ctl->list);\r\nwm_adsp_free_ctl_blk(ctl);\r\n}\r\n}\r\nstatic inline int wm_adsp_compr_attached(struct wm_adsp_compr *compr)\r\n{\r\nreturn compr->buf != NULL;\r\n}\r\nstatic int wm_adsp_compr_attach(struct wm_adsp_compr *compr)\r\n{\r\nif (!compr->dsp->buffer)\r\nreturn -EINVAL;\r\ncompr->buf = compr->dsp->buffer;\r\ncompr->buf->compr = compr;\r\nreturn 0;\r\n}\r\nstatic void wm_adsp_compr_detach(struct wm_adsp_compr *compr)\r\n{\r\nif (!compr)\r\nreturn;\r\nif (compr->stream)\r\nsnd_compr_fragment_elapsed(compr->stream);\r\nif (wm_adsp_compr_attached(compr)) {\r\ncompr->buf->compr = NULL;\r\ncompr->buf = NULL;\r\n}\r\n}\r\nint wm_adsp_compr_open(struct wm_adsp *dsp, struct snd_compr_stream *stream)\r\n{\r\nstruct wm_adsp_compr *compr;\r\nint ret = 0;\r\nmutex_lock(&dsp->pwr_lock);\r\nif (wm_adsp_fw[dsp->fw].num_caps == 0) {\r\nadsp_err(dsp, "Firmware does not support compressed API\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nif (wm_adsp_fw[dsp->fw].compr_direction != stream->direction) {\r\nadsp_err(dsp, "Firmware does not support stream direction\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (dsp->compr) {\r\nadsp_err(dsp, "Only a single stream supported per DSP\n");\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ncompr = kzalloc(sizeof(*compr), GFP_KERNEL);\r\nif (!compr) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ncompr->dsp = dsp;\r\ncompr->stream = stream;\r\ndsp->compr = compr;\r\nstream->runtime->private_data = compr;\r\nout:\r\nmutex_unlock(&dsp->pwr_lock);\r\nreturn ret;\r\n}\r\nint wm_adsp_compr_free(struct snd_compr_stream *stream)\r\n{\r\nstruct wm_adsp_compr *compr = stream->runtime->private_data;\r\nstruct wm_adsp *dsp = compr->dsp;\r\nmutex_lock(&dsp->pwr_lock);\r\nwm_adsp_compr_detach(compr);\r\ndsp->compr = NULL;\r\nkfree(compr->raw_buf);\r\nkfree(compr);\r\nmutex_unlock(&dsp->pwr_lock);\r\nreturn 0;\r\n}\r\nstatic int wm_adsp_compr_check_params(struct snd_compr_stream *stream,\r\nstruct snd_compr_params *params)\r\n{\r\nstruct wm_adsp_compr *compr = stream->runtime->private_data;\r\nstruct wm_adsp *dsp = compr->dsp;\r\nconst struct wm_adsp_fw_caps *caps;\r\nconst struct snd_codec_desc *desc;\r\nint i, j;\r\nif (params->buffer.fragment_size < WM_ADSP_MIN_FRAGMENT_SIZE ||\r\nparams->buffer.fragment_size > WM_ADSP_MAX_FRAGMENT_SIZE ||\r\nparams->buffer.fragments < WM_ADSP_MIN_FRAGMENTS ||\r\nparams->buffer.fragments > WM_ADSP_MAX_FRAGMENTS ||\r\nparams->buffer.fragment_size % WM_ADSP_DATA_WORD_SIZE) {\r\nadsp_err(dsp, "Invalid buffer fragsize=%d fragments=%d\n",\r\nparams->buffer.fragment_size,\r\nparams->buffer.fragments);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < wm_adsp_fw[dsp->fw].num_caps; i++) {\r\ncaps = &wm_adsp_fw[dsp->fw].caps[i];\r\ndesc = &caps->desc;\r\nif (caps->id != params->codec.id)\r\ncontinue;\r\nif (stream->direction == SND_COMPRESS_PLAYBACK) {\r\nif (desc->max_ch < params->codec.ch_out)\r\ncontinue;\r\n} else {\r\nif (desc->max_ch < params->codec.ch_in)\r\ncontinue;\r\n}\r\nif (!(desc->formats & (1 << params->codec.format)))\r\ncontinue;\r\nfor (j = 0; j < desc->num_sample_rates; ++j)\r\nif (desc->sample_rates[j] == params->codec.sample_rate)\r\nreturn 0;\r\n}\r\nadsp_err(dsp, "Invalid params id=%u ch=%u,%u rate=%u fmt=%u\n",\r\nparams->codec.id, params->codec.ch_in, params->codec.ch_out,\r\nparams->codec.sample_rate, params->codec.format);\r\nreturn -EINVAL;\r\n}\r\nstatic inline unsigned int wm_adsp_compr_frag_words(struct wm_adsp_compr *compr)\r\n{\r\nreturn compr->size.fragment_size / WM_ADSP_DATA_WORD_SIZE;\r\n}\r\nint wm_adsp_compr_set_params(struct snd_compr_stream *stream,\r\nstruct snd_compr_params *params)\r\n{\r\nstruct wm_adsp_compr *compr = stream->runtime->private_data;\r\nunsigned int size;\r\nint ret;\r\nret = wm_adsp_compr_check_params(stream, params);\r\nif (ret)\r\nreturn ret;\r\ncompr->size = params->buffer;\r\nadsp_dbg(compr->dsp, "fragment_size=%d fragments=%d\n",\r\ncompr->size.fragment_size, compr->size.fragments);\r\nsize = wm_adsp_compr_frag_words(compr) * sizeof(*compr->raw_buf);\r\ncompr->raw_buf = kmalloc(size, GFP_DMA | GFP_KERNEL);\r\nif (!compr->raw_buf)\r\nreturn -ENOMEM;\r\ncompr->sample_rate = params->codec.sample_rate;\r\nreturn 0;\r\n}\r\nint wm_adsp_compr_get_caps(struct snd_compr_stream *stream,\r\nstruct snd_compr_caps *caps)\r\n{\r\nstruct wm_adsp_compr *compr = stream->runtime->private_data;\r\nint fw = compr->dsp->fw;\r\nint i;\r\nif (wm_adsp_fw[fw].caps) {\r\nfor (i = 0; i < wm_adsp_fw[fw].num_caps; i++)\r\ncaps->codecs[i] = wm_adsp_fw[fw].caps[i].id;\r\ncaps->num_codecs = i;\r\ncaps->direction = wm_adsp_fw[fw].compr_direction;\r\ncaps->min_fragment_size = WM_ADSP_MIN_FRAGMENT_SIZE;\r\ncaps->max_fragment_size = WM_ADSP_MAX_FRAGMENT_SIZE;\r\ncaps->min_fragments = WM_ADSP_MIN_FRAGMENTS;\r\ncaps->max_fragments = WM_ADSP_MAX_FRAGMENTS;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm_adsp_read_data_block(struct wm_adsp *dsp, int mem_type,\r\nunsigned int mem_addr,\r\nunsigned int num_words, u32 *data)\r\n{\r\nstruct wm_adsp_region const *mem = wm_adsp_find_region(dsp, mem_type);\r\nunsigned int i, reg;\r\nint ret;\r\nif (!mem)\r\nreturn -EINVAL;\r\nreg = wm_adsp_region_to_reg(mem, mem_addr);\r\nret = regmap_raw_read(dsp->regmap, reg, data,\r\nsizeof(*data) * num_words);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < num_words; ++i)\r\ndata[i] = be32_to_cpu(data[i]) & 0x00ffffffu;\r\nreturn 0;\r\n}\r\nstatic inline int wm_adsp_read_data_word(struct wm_adsp *dsp, int mem_type,\r\nunsigned int mem_addr, u32 *data)\r\n{\r\nreturn wm_adsp_read_data_block(dsp, mem_type, mem_addr, 1, data);\r\n}\r\nstatic int wm_adsp_write_data_word(struct wm_adsp *dsp, int mem_type,\r\nunsigned int mem_addr, u32 data)\r\n{\r\nstruct wm_adsp_region const *mem = wm_adsp_find_region(dsp, mem_type);\r\nunsigned int reg;\r\nif (!mem)\r\nreturn -EINVAL;\r\nreg = wm_adsp_region_to_reg(mem, mem_addr);\r\ndata = cpu_to_be32(data & 0x00ffffffu);\r\nreturn regmap_raw_write(dsp->regmap, reg, &data, sizeof(data));\r\n}\r\nstatic inline int wm_adsp_buffer_read(struct wm_adsp_compr_buf *buf,\r\nunsigned int field_offset, u32 *data)\r\n{\r\nreturn wm_adsp_read_data_word(buf->dsp, WMFW_ADSP2_XM,\r\nbuf->host_buf_ptr + field_offset, data);\r\n}\r\nstatic inline int wm_adsp_buffer_write(struct wm_adsp_compr_buf *buf,\r\nunsigned int field_offset, u32 data)\r\n{\r\nreturn wm_adsp_write_data_word(buf->dsp, WMFW_ADSP2_XM,\r\nbuf->host_buf_ptr + field_offset, data);\r\n}\r\nstatic int wm_adsp_buffer_locate(struct wm_adsp_compr_buf *buf)\r\n{\r\nstruct wm_adsp_alg_region *alg_region;\r\nstruct wm_adsp *dsp = buf->dsp;\r\nu32 xmalg, addr, magic;\r\nint i, ret;\r\nalg_region = wm_adsp_find_alg_region(dsp, WMFW_ADSP2_XM, dsp->fw_id);\r\nxmalg = sizeof(struct wm_adsp_system_config_xm_hdr) / sizeof(__be32);\r\naddr = alg_region->base + xmalg + ALG_XM_FIELD(magic);\r\nret = wm_adsp_read_data_word(dsp, WMFW_ADSP2_XM, addr, &magic);\r\nif (ret < 0)\r\nreturn ret;\r\nif (magic != WM_ADSP_ALG_XM_STRUCT_MAGIC)\r\nreturn -EINVAL;\r\naddr = alg_region->base + xmalg + ALG_XM_FIELD(host_buf_ptr);\r\nfor (i = 0; i < 5; ++i) {\r\nret = wm_adsp_read_data_word(dsp, WMFW_ADSP2_XM, addr,\r\n&buf->host_buf_ptr);\r\nif (ret < 0)\r\nreturn ret;\r\nif (buf->host_buf_ptr)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nif (!buf->host_buf_ptr)\r\nreturn -EIO;\r\nadsp_dbg(dsp, "host_buf_ptr=%x\n", buf->host_buf_ptr);\r\nreturn 0;\r\n}\r\nstatic int wm_adsp_buffer_populate(struct wm_adsp_compr_buf *buf)\r\n{\r\nconst struct wm_adsp_fw_caps *caps = wm_adsp_fw[buf->dsp->fw].caps;\r\nstruct wm_adsp_buffer_region *region;\r\nu32 offset = 0;\r\nint i, ret;\r\nfor (i = 0; i < caps->num_regions; ++i) {\r\nregion = &buf->regions[i];\r\nregion->offset = offset;\r\nregion->mem_type = caps->region_defs[i].mem_type;\r\nret = wm_adsp_buffer_read(buf, caps->region_defs[i].base_offset,\r\n&region->base_addr);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wm_adsp_buffer_read(buf, caps->region_defs[i].size_offset,\r\n&offset);\r\nif (ret < 0)\r\nreturn ret;\r\nregion->cumulative_size = offset;\r\nadsp_dbg(buf->dsp,\r\n"region=%d type=%d base=%04x off=%04x size=%04x\n",\r\ni, region->mem_type, region->base_addr,\r\nregion->offset, region->cumulative_size);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm_adsp_buffer_init(struct wm_adsp *dsp)\r\n{\r\nstruct wm_adsp_compr_buf *buf;\r\nint ret;\r\nbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf->dsp = dsp;\r\nbuf->read_index = -1;\r\nbuf->irq_count = 0xFFFFFFFF;\r\nret = wm_adsp_buffer_locate(buf);\r\nif (ret < 0) {\r\nadsp_err(dsp, "Failed to acquire host buffer: %d\n", ret);\r\ngoto err_buffer;\r\n}\r\nbuf->regions = kcalloc(wm_adsp_fw[dsp->fw].caps->num_regions,\r\nsizeof(*buf->regions), GFP_KERNEL);\r\nif (!buf->regions) {\r\nret = -ENOMEM;\r\ngoto err_buffer;\r\n}\r\nret = wm_adsp_buffer_populate(buf);\r\nif (ret < 0) {\r\nadsp_err(dsp, "Failed to populate host buffer: %d\n", ret);\r\ngoto err_regions;\r\n}\r\ndsp->buffer = buf;\r\nreturn 0;\r\nerr_regions:\r\nkfree(buf->regions);\r\nerr_buffer:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int wm_adsp_buffer_free(struct wm_adsp *dsp)\r\n{\r\nif (dsp->buffer) {\r\nwm_adsp_compr_detach(dsp->buffer->compr);\r\nkfree(dsp->buffer->regions);\r\nkfree(dsp->buffer);\r\ndsp->buffer = NULL;\r\n}\r\nreturn 0;\r\n}\r\nint wm_adsp_compr_trigger(struct snd_compr_stream *stream, int cmd)\r\n{\r\nstruct wm_adsp_compr *compr = stream->runtime->private_data;\r\nstruct wm_adsp *dsp = compr->dsp;\r\nint ret = 0;\r\nadsp_dbg(dsp, "Trigger: %d\n", cmd);\r\nmutex_lock(&dsp->pwr_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (wm_adsp_compr_attached(compr))\r\nbreak;\r\nret = wm_adsp_compr_attach(compr);\r\nif (ret < 0) {\r\nadsp_err(dsp, "Failed to link buffer and stream: %d\n",\r\nret);\r\nbreak;\r\n}\r\nret = wm_adsp_buffer_write(compr->buf,\r\nHOST_BUFFER_FIELD(high_water_mark),\r\nwm_adsp_compr_frag_words(compr));\r\nif (ret < 0) {\r\nadsp_err(dsp, "Failed to set high water mark: %d\n",\r\nret);\r\nbreak;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&dsp->pwr_lock);\r\nreturn ret;\r\n}\r\nstatic inline int wm_adsp_buffer_size(struct wm_adsp_compr_buf *buf)\r\n{\r\nint last_region = wm_adsp_fw[buf->dsp->fw].caps->num_regions - 1;\r\nreturn buf->regions[last_region].cumulative_size;\r\n}\r\nstatic int wm_adsp_buffer_update_avail(struct wm_adsp_compr_buf *buf)\r\n{\r\nu32 next_read_index, next_write_index;\r\nint write_index, read_index, avail;\r\nint ret;\r\nif (buf->read_index < 0) {\r\nret = wm_adsp_buffer_read(buf,\r\nHOST_BUFFER_FIELD(next_read_index),\r\n&next_read_index);\r\nif (ret < 0)\r\nreturn ret;\r\nread_index = sign_extend32(next_read_index, 23);\r\nif (read_index < 0) {\r\nadsp_dbg(buf->dsp, "Avail check on unstarted stream\n");\r\nreturn 0;\r\n}\r\nbuf->read_index = read_index;\r\n}\r\nret = wm_adsp_buffer_read(buf, HOST_BUFFER_FIELD(next_write_index),\r\n&next_write_index);\r\nif (ret < 0)\r\nreturn ret;\r\nwrite_index = sign_extend32(next_write_index, 23);\r\navail = write_index - buf->read_index;\r\nif (avail < 0)\r\navail += wm_adsp_buffer_size(buf);\r\nadsp_dbg(buf->dsp, "readindex=0x%x, writeindex=0x%x, avail=%d\n",\r\nbuf->read_index, write_index, avail * WM_ADSP_DATA_WORD_SIZE);\r\nbuf->avail = avail;\r\nreturn 0;\r\n}\r\nstatic int wm_adsp_buffer_get_error(struct wm_adsp_compr_buf *buf)\r\n{\r\nint ret;\r\nret = wm_adsp_buffer_read(buf, HOST_BUFFER_FIELD(error), &buf->error);\r\nif (ret < 0) {\r\nadsp_err(buf->dsp, "Failed to check buffer error: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (buf->error != 0) {\r\nadsp_err(buf->dsp, "Buffer error occurred: %d\n", buf->error);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint wm_adsp_compr_handle_irq(struct wm_adsp *dsp)\r\n{\r\nstruct wm_adsp_compr_buf *buf;\r\nstruct wm_adsp_compr *compr;\r\nint ret = 0;\r\nmutex_lock(&dsp->pwr_lock);\r\nbuf = dsp->buffer;\r\ncompr = dsp->compr;\r\nif (!buf) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nadsp_dbg(dsp, "Handling buffer IRQ\n");\r\nret = wm_adsp_buffer_get_error(buf);\r\nif (ret < 0)\r\ngoto out_notify;\r\nret = wm_adsp_buffer_read(buf, HOST_BUFFER_FIELD(irq_count),\r\n&buf->irq_count);\r\nif (ret < 0) {\r\nadsp_err(dsp, "Failed to get irq_count: %d\n", ret);\r\ngoto out;\r\n}\r\nret = wm_adsp_buffer_update_avail(buf);\r\nif (ret < 0) {\r\nadsp_err(dsp, "Error reading avail: %d\n", ret);\r\ngoto out;\r\n}\r\nif (wm_adsp_fw[dsp->fw].voice_trigger && buf->irq_count == 2)\r\nret = WM_ADSP_COMPR_VOICE_TRIGGER;\r\nout_notify:\r\nif (compr && compr->stream)\r\nsnd_compr_fragment_elapsed(compr->stream);\r\nout:\r\nmutex_unlock(&dsp->pwr_lock);\r\nreturn ret;\r\n}\r\nstatic int wm_adsp_buffer_reenable_irq(struct wm_adsp_compr_buf *buf)\r\n{\r\nif (buf->irq_count & 0x01)\r\nreturn 0;\r\nadsp_dbg(buf->dsp, "Enable IRQ(0x%x) for next fragment\n",\r\nbuf->irq_count);\r\nbuf->irq_count |= 0x01;\r\nreturn wm_adsp_buffer_write(buf, HOST_BUFFER_FIELD(irq_ack),\r\nbuf->irq_count);\r\n}\r\nint wm_adsp_compr_pointer(struct snd_compr_stream *stream,\r\nstruct snd_compr_tstamp *tstamp)\r\n{\r\nstruct wm_adsp_compr *compr = stream->runtime->private_data;\r\nstruct wm_adsp *dsp = compr->dsp;\r\nstruct wm_adsp_compr_buf *buf;\r\nint ret = 0;\r\nadsp_dbg(dsp, "Pointer request\n");\r\nmutex_lock(&dsp->pwr_lock);\r\nbuf = compr->buf;\r\nif (!compr->buf || compr->buf->error) {\r\nsnd_compr_stop_error(stream, SNDRV_PCM_STATE_XRUN);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (buf->avail < wm_adsp_compr_frag_words(compr)) {\r\nret = wm_adsp_buffer_update_avail(buf);\r\nif (ret < 0) {\r\nadsp_err(dsp, "Error reading avail: %d\n", ret);\r\ngoto out;\r\n}\r\nif (buf->avail < wm_adsp_compr_frag_words(compr)) {\r\nret = wm_adsp_buffer_get_error(buf);\r\nif (ret < 0) {\r\nif (compr->buf->error)\r\nsnd_compr_stop_error(stream,\r\nSNDRV_PCM_STATE_XRUN);\r\ngoto out;\r\n}\r\nret = wm_adsp_buffer_reenable_irq(buf);\r\nif (ret < 0) {\r\nadsp_err(dsp,\r\n"Failed to re-enable buffer IRQ: %d\n",\r\nret);\r\ngoto out;\r\n}\r\n}\r\n}\r\ntstamp->copied_total = compr->copied_total;\r\ntstamp->copied_total += buf->avail * WM_ADSP_DATA_WORD_SIZE;\r\ntstamp->sampling_rate = compr->sample_rate;\r\nout:\r\nmutex_unlock(&dsp->pwr_lock);\r\nreturn ret;\r\n}\r\nstatic int wm_adsp_buffer_capture_block(struct wm_adsp_compr *compr, int target)\r\n{\r\nstruct wm_adsp_compr_buf *buf = compr->buf;\r\nu8 *pack_in = (u8 *)compr->raw_buf;\r\nu8 *pack_out = (u8 *)compr->raw_buf;\r\nunsigned int adsp_addr;\r\nint mem_type, nwords, max_read;\r\nint i, j, ret;\r\nfor (i = 0; i < wm_adsp_fw[buf->dsp->fw].caps->num_regions; ++i)\r\nif (buf->read_index < buf->regions[i].cumulative_size)\r\nbreak;\r\nif (i == wm_adsp_fw[buf->dsp->fw].caps->num_regions)\r\nreturn -EINVAL;\r\nmem_type = buf->regions[i].mem_type;\r\nadsp_addr = buf->regions[i].base_addr +\r\n(buf->read_index - buf->regions[i].offset);\r\nmax_read = wm_adsp_compr_frag_words(compr);\r\nnwords = buf->regions[i].cumulative_size - buf->read_index;\r\nif (nwords > target)\r\nnwords = target;\r\nif (nwords > buf->avail)\r\nnwords = buf->avail;\r\nif (nwords > max_read)\r\nnwords = max_read;\r\nif (!nwords)\r\nreturn 0;\r\nret = wm_adsp_read_data_block(buf->dsp, mem_type, adsp_addr,\r\nnwords, compr->raw_buf);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < nwords; i++) {\r\nfor (j = 0; j < WM_ADSP_DATA_WORD_SIZE; j++)\r\n*pack_out++ = *pack_in++;\r\npack_in += sizeof(*(compr->raw_buf)) - WM_ADSP_DATA_WORD_SIZE;\r\n}\r\nbuf->read_index += nwords;\r\nif (buf->read_index == wm_adsp_buffer_size(buf))\r\nbuf->read_index = 0;\r\nret = wm_adsp_buffer_write(buf, HOST_BUFFER_FIELD(next_read_index),\r\nbuf->read_index);\r\nif (ret < 0)\r\nreturn ret;\r\nbuf->avail -= nwords;\r\nreturn nwords;\r\n}\r\nstatic int wm_adsp_compr_read(struct wm_adsp_compr *compr,\r\nchar __user *buf, size_t count)\r\n{\r\nstruct wm_adsp *dsp = compr->dsp;\r\nint ntotal = 0;\r\nint nwords, nbytes;\r\nadsp_dbg(dsp, "Requested read of %zu bytes\n", count);\r\nif (!compr->buf || compr->buf->error) {\r\nsnd_compr_stop_error(compr->stream, SNDRV_PCM_STATE_XRUN);\r\nreturn -EIO;\r\n}\r\ncount /= WM_ADSP_DATA_WORD_SIZE;\r\ndo {\r\nnwords = wm_adsp_buffer_capture_block(compr, count);\r\nif (nwords < 0) {\r\nadsp_err(dsp, "Failed to capture block: %d\n", nwords);\r\nreturn nwords;\r\n}\r\nnbytes = nwords * WM_ADSP_DATA_WORD_SIZE;\r\nadsp_dbg(dsp, "Read %d bytes\n", nbytes);\r\nif (copy_to_user(buf + ntotal, compr->raw_buf, nbytes)) {\r\nadsp_err(dsp, "Failed to copy data to user: %d, %d\n",\r\nntotal, nbytes);\r\nreturn -EFAULT;\r\n}\r\ncount -= nwords;\r\nntotal += nbytes;\r\n} while (nwords > 0 && count > 0);\r\ncompr->copied_total += ntotal;\r\nreturn ntotal;\r\n}\r\nint wm_adsp_compr_copy(struct snd_compr_stream *stream, char __user *buf,\r\nsize_t count)\r\n{\r\nstruct wm_adsp_compr *compr = stream->runtime->private_data;\r\nstruct wm_adsp *dsp = compr->dsp;\r\nint ret;\r\nmutex_lock(&dsp->pwr_lock);\r\nif (stream->direction == SND_COMPRESS_CAPTURE)\r\nret = wm_adsp_compr_read(compr, buf, count);\r\nelse\r\nret = -ENOTSUPP;\r\nmutex_unlock(&dsp->pwr_lock);\r\nreturn ret;\r\n}\r\nint wm_adsp2_lock(struct wm_adsp *dsp, unsigned int lock_regions)\r\n{\r\nstruct regmap *regmap = dsp->regmap;\r\nunsigned int code0, code1, lock_reg;\r\nif (!(lock_regions & WM_ADSP2_REGION_ALL))\r\nreturn 0;\r\nlock_regions &= WM_ADSP2_REGION_ALL;\r\nlock_reg = dsp->base + ADSP2_LOCK_REGION_1_LOCK_REGION_0;\r\nwhile (lock_regions) {\r\ncode0 = code1 = 0;\r\nif (lock_regions & BIT(0)) {\r\ncode0 = ADSP2_LOCK_CODE_0;\r\ncode1 = ADSP2_LOCK_CODE_1;\r\n}\r\nif (lock_regions & BIT(1)) {\r\ncode0 |= ADSP2_LOCK_CODE_0 << ADSP2_LOCK_REGION_SHIFT;\r\ncode1 |= ADSP2_LOCK_CODE_1 << ADSP2_LOCK_REGION_SHIFT;\r\n}\r\nregmap_write(regmap, lock_reg, code0);\r\nregmap_write(regmap, lock_reg, code1);\r\nlock_regions >>= 2;\r\nlock_reg += 2;\r\n}\r\nreturn 0;\r\n}\r\nirqreturn_t wm_adsp2_bus_error(struct wm_adsp *dsp)\r\n{\r\nunsigned int val;\r\nstruct regmap *regmap = dsp->regmap;\r\nint ret = 0;\r\nret = regmap_read(regmap, dsp->base + ADSP2_LOCK_REGION_CTRL, &val);\r\nif (ret) {\r\nadsp_err(dsp,\r\n"Failed to read Region Lock Ctrl register: %d\n", ret);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (val & ADSP2_WDT_TIMEOUT_STS_MASK) {\r\nadsp_err(dsp, "watchdog timeout error\n");\r\nwm_adsp_stop_watchdog(dsp);\r\n}\r\nif (val & (ADSP2_SLAVE_ERR_MASK | ADSP2_REGION_LOCK_ERR_MASK)) {\r\nif (val & ADSP2_SLAVE_ERR_MASK)\r\nadsp_err(dsp, "bus error: slave error\n");\r\nelse\r\nadsp_err(dsp, "bus error: region lock error\n");\r\nret = regmap_read(regmap, dsp->base + ADSP2_BUS_ERR_ADDR, &val);\r\nif (ret) {\r\nadsp_err(dsp,\r\n"Failed to read Bus Err Addr register: %d\n",\r\nret);\r\nreturn IRQ_HANDLED;\r\n}\r\nadsp_err(dsp, "bus error address = 0x%x\n",\r\nval & ADSP2_BUS_ERR_ADDR_MASK);\r\nret = regmap_read(regmap,\r\ndsp->base + ADSP2_PMEM_ERR_ADDR_XMEM_ERR_ADDR,\r\n&val);\r\nif (ret) {\r\nadsp_err(dsp,\r\n"Failed to read Pmem Xmem Err Addr register: %d\n",\r\nret);\r\nreturn IRQ_HANDLED;\r\n}\r\nadsp_err(dsp, "xmem error address = 0x%x\n",\r\nval & ADSP2_XMEM_ERR_ADDR_MASK);\r\nadsp_err(dsp, "pmem error address = 0x%x\n",\r\n(val & ADSP2_PMEM_ERR_ADDR_MASK) >>\r\nADSP2_PMEM_ERR_ADDR_SHIFT);\r\n}\r\nregmap_update_bits(regmap, dsp->base + ADSP2_LOCK_REGION_CTRL,\r\nADSP2_CTRL_ERR_EINT, ADSP2_CTRL_ERR_EINT);\r\nreturn IRQ_HANDLED;\r\n}
