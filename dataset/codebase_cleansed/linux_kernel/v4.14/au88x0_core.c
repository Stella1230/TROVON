static void vortex_mixer_en_sr(vortex_t * vortex, int channel)\r\n{\r\nhwwrite(vortex->mmio, VORTEX_MIXER_SR,\r\nhwread(vortex->mmio, VORTEX_MIXER_SR) | (0x1 << channel));\r\n}\r\nstatic void vortex_mixer_dis_sr(vortex_t * vortex, int channel)\r\n{\r\nhwwrite(vortex->mmio, VORTEX_MIXER_SR,\r\nhwread(vortex->mmio, VORTEX_MIXER_SR) & ~(0x1 << channel));\r\n}\r\nstatic void\r\nvortex_mix_setvolumebyte(vortex_t * vortex, unsigned char mix,\r\nunsigned char vol)\r\n{\r\nint temp;\r\nhwwrite(vortex->mmio, VORTEX_MIX_VOL_A + (mix << 2), vol);\r\nif (1) {\r\ntemp = hwread(vortex->mmio, VORTEX_MIX_VOL_B + (mix << 2));\r\nif ((temp != 0x80) || (vol == 0x80))\r\nreturn;\r\n}\r\nhwwrite(vortex->mmio, VORTEX_MIX_VOL_B + (mix << 2), vol);\r\n}\r\nstatic void\r\nvortex_mix_setinputvolumebyte(vortex_t * vortex, unsigned char mix,\r\nint mixin, unsigned char vol)\r\n{\r\nint temp;\r\nhwwrite(vortex->mmio,\r\nVORTEX_MIX_INVOL_A + (((mix << 5) + mixin) << 2), vol);\r\nif (1) {\r\ntemp =\r\nhwread(vortex->mmio,\r\nVORTEX_MIX_INVOL_B + (((mix << 5) + mixin) << 2));\r\nif ((temp != 0x80) || (vol == 0x80))\r\nreturn;\r\n}\r\nhwwrite(vortex->mmio,\r\nVORTEX_MIX_INVOL_B + (((mix << 5) + mixin) << 2), vol);\r\n}\r\nstatic void\r\nvortex_mix_setenablebit(vortex_t * vortex, unsigned char mix, int mixin, int en)\r\n{\r\nint temp, addr;\r\nif (mixin < 0)\r\naddr = (mixin + 3);\r\nelse\r\naddr = mixin;\r\naddr = ((mix << 3) + (addr >> 2)) << 2;\r\ntemp = hwread(vortex->mmio, VORTEX_MIX_ENIN + addr);\r\nif (en)\r\ntemp |= (1 << (mixin & 3));\r\nelse\r\ntemp &= ~(1 << (mixin & 3));\r\nhwwrite(vortex->mmio,\r\nVORTEX_MIX_INVOL_B + (((mix << 5) + mixin) << 2), 0x80);\r\nhwwrite(vortex->mmio, VORTEX_MIX_SMP + (mixin << 2), 0x0);\r\nhwwrite(vortex->mmio, VORTEX_MIX_SMP + 4 + (mixin << 2), 0x0);\r\nhwwrite(vortex->mmio, VORTEX_MIX_ENIN + addr, temp);\r\n}\r\nstatic void\r\nvortex_mix_killinput(vortex_t * vortex, unsigned char mix, int mixin)\r\n{\r\nrampchs[mix] &= ~(1 << mixin);\r\nvortex_mix_setinputvolumebyte(vortex, mix, mixin, 0x80);\r\nmchannels[mix] &= ~(1 << mixin);\r\nvortex_mix_setenablebit(vortex, mix, mixin, 0);\r\n}\r\nstatic void\r\nvortex_mix_enableinput(vortex_t * vortex, unsigned char mix, int mixin)\r\n{\r\nvortex_mix_killinput(vortex, mix, mixin);\r\nif ((mchannels[mix] & (1 << mixin)) == 0) {\r\nvortex_mix_setinputvolumebyte(vortex, mix, mixin, 0x80);\r\nmchannels[mix] |= (1 << mixin);\r\n}\r\nvortex_mix_setenablebit(vortex, mix, mixin, 1);\r\n}\r\nstatic void\r\nvortex_mix_disableinput(vortex_t * vortex, unsigned char mix, int channel,\r\nint ramp)\r\n{\r\nif (ramp) {\r\nrampchs[mix] |= (1 << channel);\r\nvortex_mix_killinput(vortex, mix, channel);\r\n} else\r\nvortex_mix_killinput(vortex, mix, channel);\r\n}\r\nstatic int\r\nvortex_mixer_addWTD(vortex_t * vortex, unsigned char mix, unsigned char ch)\r\n{\r\nint temp, lifeboat = 0, prev;\r\ntemp = hwread(vortex->mmio, VORTEX_MIXER_SR);\r\nif ((temp & (1 << ch)) == 0) {\r\nhwwrite(vortex->mmio, VORTEX_MIXER_CHNBASE + (ch << 2), mix);\r\nvortex_mixer_en_sr(vortex, ch);\r\nreturn 1;\r\n}\r\nprev = VORTEX_MIXER_CHNBASE + (ch << 2);\r\ntemp = hwread(vortex->mmio, prev);\r\nwhile (temp & 0x10) {\r\nprev = VORTEX_MIXER_RTBASE + ((temp & 0xf) << 2);\r\ntemp = hwread(vortex->mmio, prev);\r\nif ((++lifeboat) > 0xf) {\r\ndev_err(vortex->card->dev,\r\n"vortex_mixer_addWTD: lifeboat overflow\n");\r\nreturn 0;\r\n}\r\n}\r\nhwwrite(vortex->mmio, VORTEX_MIXER_RTBASE + ((temp & 0xf) << 2), mix);\r\nhwwrite(vortex->mmio, prev, (temp & 0xf) | 0x10);\r\nreturn 1;\r\n}\r\nstatic int\r\nvortex_mixer_delWTD(vortex_t * vortex, unsigned char mix, unsigned char ch)\r\n{\r\nint esp14 = -1, esp18, eax, ebx, edx, ebp, esi = 0;\r\neax = hwread(vortex->mmio, VORTEX_MIXER_SR);\r\nif (((1 << ch) & eax) == 0) {\r\ndev_err(vortex->card->dev, "mix ALARM %x\n", eax);\r\nreturn 0;\r\n}\r\nebp = VORTEX_MIXER_CHNBASE + (ch << 2);\r\nesp18 = hwread(vortex->mmio, ebp);\r\nif (esp18 & 0x10) {\r\nebx = (esp18 & 0xf);\r\nif (mix == ebx) {\r\nebx = VORTEX_MIXER_RTBASE + (mix << 2);\r\nedx = hwread(vortex->mmio, ebx);\r\nhwwrite(vortex->mmio, ebp, edx);\r\nhwwrite(vortex->mmio, ebx, 0);\r\n} else {\r\nedx =\r\nhwread(vortex->mmio,\r\nVORTEX_MIXER_RTBASE + (ebx << 2));\r\nwhile ((edx & 0xf) != mix) {\r\nif ((esi) > 0xf) {\r\ndev_err(vortex->card->dev,\r\n"mixdelWTD: error lifeboat overflow\n");\r\nreturn 0;\r\n}\r\nesp14 = ebx;\r\nebx = edx & 0xf;\r\nebp = ebx << 2;\r\nedx =\r\nhwread(vortex->mmio,\r\nVORTEX_MIXER_RTBASE + ebp);\r\nesi++;\r\n}\r\nebp = ebx << 2;\r\nif (edx & 0x10) {\r\nebx = VORTEX_MIXER_RTBASE + ((edx & 0xf) << 2);\r\nedx = hwread(vortex->mmio, ebx);\r\nhwwrite(vortex->mmio,\r\nVORTEX_MIXER_RTBASE + ebp, edx);\r\nhwwrite(vortex->mmio, ebx, 0);\r\n} else {\r\nif (esp14 == -1)\r\nhwwrite(vortex->mmio,\r\nVORTEX_MIXER_CHNBASE +\r\n(ch << 2), esp18 & 0xef);\r\nelse {\r\nebx = (0xffffffe0 & edx) | (0xf & ebx);\r\nhwwrite(vortex->mmio,\r\nVORTEX_MIXER_RTBASE +\r\n(esp14 << 2), ebx);\r\n}\r\nhwwrite(vortex->mmio,\r\nVORTEX_MIXER_RTBASE + ebp, 0);\r\nreturn 1;\r\n}\r\n}\r\n} else {\r\nvortex_mixer_dis_sr(vortex, ch);\r\nhwwrite(vortex->mmio, ebp, 0);\r\n}\r\nreturn 1;\r\n}\r\nstatic void vortex_mixer_init(vortex_t * vortex)\r\n{\r\nu32 addr;\r\nint x;\r\nmemset(mchannels, 0, NR_MIXOUT * sizeof(int));\r\nmemset(rampchs, 0, NR_MIXOUT * sizeof(int));\r\naddr = VORTEX_MIX_SMP + 0x17c;\r\nfor (x = 0x5f; x >= 0; x--) {\r\nhwwrite(vortex->mmio, addr, 0);\r\naddr -= 4;\r\n}\r\naddr = VORTEX_MIX_ENIN + 0x1fc;\r\nfor (x = 0x7f; x >= 0; x--) {\r\nhwwrite(vortex->mmio, addr, 0);\r\naddr -= 4;\r\n}\r\naddr = VORTEX_MIX_SMP + 0x17c;\r\nfor (x = 0x5f; x >= 0; x--) {\r\nhwwrite(vortex->mmio, addr, 0);\r\naddr -= 4;\r\n}\r\naddr = VORTEX_MIX_INVOL_A + 0x7fc;\r\nfor (x = 0x1ff; x >= 0; x--) {\r\nhwwrite(vortex->mmio, addr, 0x80);\r\naddr -= 4;\r\n}\r\naddr = VORTEX_MIX_VOL_A + 0x3c;\r\nfor (x = 0xf; x >= 0; x--) {\r\nhwwrite(vortex->mmio, addr, 0x80);\r\naddr -= 4;\r\n}\r\naddr = VORTEX_MIX_INVOL_B + 0x7fc;\r\nfor (x = 0x1ff; x >= 0; x--) {\r\nhwwrite(vortex->mmio, addr, 0x80);\r\naddr -= 4;\r\n}\r\naddr = VORTEX_MIX_VOL_B + 0x3c;\r\nfor (x = 0xf; x >= 0; x--) {\r\nhwwrite(vortex->mmio, addr, 0x80);\r\naddr -= 4;\r\n}\r\naddr = VORTEX_MIXER_RTBASE + (MIXER_RTBASE_SIZE - 1) * 4;\r\nfor (x = (MIXER_RTBASE_SIZE - 1); x >= 0; x--) {\r\nhwwrite(vortex->mmio, addr, 0x0);\r\naddr -= 4;\r\n}\r\nhwwrite(vortex->mmio, VORTEX_MIXER_SR, 0);\r\n}\r\nstatic void vortex_src_en_sr(vortex_t * vortex, int channel)\r\n{\r\nhwwrite(vortex->mmio, VORTEX_SRCBLOCK_SR,\r\nhwread(vortex->mmio, VORTEX_SRCBLOCK_SR) | (0x1 << channel));\r\n}\r\nstatic void vortex_src_dis_sr(vortex_t * vortex, int channel)\r\n{\r\nhwwrite(vortex->mmio, VORTEX_SRCBLOCK_SR,\r\nhwread(vortex->mmio, VORTEX_SRCBLOCK_SR) & ~(0x1 << channel));\r\n}\r\nstatic void vortex_src_flushbuffers(vortex_t * vortex, unsigned char src)\r\n{\r\nint i;\r\nfor (i = 0x1f; i >= 0; i--)\r\nhwwrite(vortex->mmio,\r\nVORTEX_SRC_DATA0 + (src << 7) + (i << 2), 0);\r\nhwwrite(vortex->mmio, VORTEX_SRC_DATA + (src << 3), 0);\r\nhwwrite(vortex->mmio, VORTEX_SRC_DATA + (src << 3) + 4, 0);\r\n}\r\nstatic void vortex_src_cleardrift(vortex_t * vortex, unsigned char src)\r\n{\r\nhwwrite(vortex->mmio, VORTEX_SRC_DRIFT0 + (src << 2), 0);\r\nhwwrite(vortex->mmio, VORTEX_SRC_DRIFT1 + (src << 2), 0);\r\nhwwrite(vortex->mmio, VORTEX_SRC_DRIFT2 + (src << 2), 1);\r\n}\r\nstatic void\r\nvortex_src_set_throttlesource(vortex_t * vortex, unsigned char src, int en)\r\n{\r\nint temp;\r\ntemp = hwread(vortex->mmio, VORTEX_SRC_SOURCE);\r\nif (en)\r\ntemp |= 1 << src;\r\nelse\r\ntemp &= ~(1 << src);\r\nhwwrite(vortex->mmio, VORTEX_SRC_SOURCE, temp);\r\n}\r\nstatic int\r\nvortex_src_persist_convratio(vortex_t * vortex, unsigned char src, int ratio)\r\n{\r\nint temp, lifeboat = 0;\r\ndo {\r\nhwwrite(vortex->mmio, VORTEX_SRC_CONVRATIO + (src << 2), ratio);\r\ntemp = hwread(vortex->mmio, VORTEX_SRC_CONVRATIO + (src << 2));\r\nif ((++lifeboat) > 0x9) {\r\ndev_err(vortex->card->dev, "Src cvr fail\n");\r\nbreak;\r\n}\r\n}\r\nwhile (temp != ratio);\r\nreturn temp;\r\n}\r\nstatic void vortex_src_setupchannel(vortex_t * card, unsigned char src,\r\nunsigned int cr, unsigned int b, int sweep, int d,\r\nint dirplay, int sl, unsigned int tr, int thsource)\r\n{\r\nint esi, ebp = 0, esp10;\r\nvortex_src_flushbuffers(card, src);\r\nif (sweep) {\r\nif ((tr & 0x10000) && (tr != 0x10000)) {\r\ntr = 0;\r\nesi = 0x7;\r\n} else {\r\nif ((((short)tr) < 0) && (tr != 0x8000)) {\r\ntr = 0;\r\nesi = 0x8;\r\n} else {\r\ntr = 1;\r\nesi = 0xc;\r\n}\r\n}\r\n} else {\r\nif ((cr & 0x10000) && (cr != 0x10000)) {\r\ntr = 0;\r\nesi = 0x11 - ((cr >> 0xe) & 7);\r\nif (cr & 0x3fff)\r\nesi -= 1;\r\nelse\r\nesi -= 2;\r\n} else {\r\ntr = 1;\r\nesi = 0xc;\r\n}\r\n}\r\nvortex_src_cleardrift(card, src);\r\nvortex_src_set_throttlesource(card, src, thsource);\r\nif ((dirplay == 0) && (sweep == 0)) {\r\nif (tr)\r\nesp10 = 0xf;\r\nelse\r\nesp10 = 0xc;\r\nebp = 0;\r\n} else {\r\nif (tr)\r\nebp = 0xf;\r\nelse\r\nebp = 0xc;\r\nesp10 = 0;\r\n}\r\nhwwrite(card->mmio, VORTEX_SRC_U0 + (src << 2),\r\n(sl << 0x9) | (sweep << 0x8) | ((esi & 0xf) << 4) | d);\r\nvortex_src_persist_convratio(card, src, cr);\r\nhwwrite(card->mmio, VORTEX_SRC_U1 + (src << 2), b & 0xffff);\r\nhwwrite(card->mmio, VORTEX_SRC_U2 + (src << 2),\r\n(tr << 0x11) | (dirplay << 0x10) | (ebp << 0x8) | esp10);\r\n}\r\nstatic void vortex_srcblock_init(vortex_t * vortex)\r\n{\r\nu32 addr;\r\nint x;\r\nhwwrite(vortex->mmio, VORTEX_SRC_SOURCESIZE, 0x1ff);\r\naddr = VORTEX_SRC_RTBASE + 0x3c;\r\nfor (x = 0xf; x >= 0; x--) {\r\nhwwrite(vortex->mmio, addr, 0);\r\naddr -= 4;\r\n}\r\naddr = VORTEX_SRC_CHNBASE + 0x54;\r\nfor (x = 0x15; x >= 0; x--) {\r\nhwwrite(vortex->mmio, addr, 0);\r\naddr -= 4;\r\n}\r\n}\r\nstatic int\r\nvortex_src_addWTD(vortex_t * vortex, unsigned char src, unsigned char ch)\r\n{\r\nint temp, lifeboat = 0, prev;\r\ntemp = hwread(vortex->mmio, VORTEX_SRCBLOCK_SR);\r\nif ((temp & (1 << ch)) == 0) {\r\nhwwrite(vortex->mmio, VORTEX_SRC_CHNBASE + (ch << 2), src);\r\nvortex_src_en_sr(vortex, ch);\r\nreturn 1;\r\n}\r\nprev = VORTEX_SRC_CHNBASE + (ch << 2);\r\ntemp = hwread(vortex->mmio, prev);\r\nwhile (temp & 0x10) {\r\nprev = VORTEX_SRC_RTBASE + ((temp & 0xf) << 2);\r\ntemp = hwread(vortex->mmio, prev);\r\nif ((++lifeboat) > 0xf) {\r\ndev_err(vortex->card->dev,\r\n"vortex_src_addWTD: lifeboat overflow\n");\r\nreturn 0;\r\n}\r\n}\r\nhwwrite(vortex->mmio, VORTEX_SRC_RTBASE + ((temp & 0xf) << 2), src);\r\nhwwrite(vortex->mmio, prev, (temp & 0xf) | 0x10);\r\nreturn 1;\r\n}\r\nstatic int\r\nvortex_src_delWTD(vortex_t * vortex, unsigned char src, unsigned char ch)\r\n{\r\nint esp14 = -1, esp18, eax, ebx, edx, ebp, esi = 0;\r\neax = hwread(vortex->mmio, VORTEX_SRCBLOCK_SR);\r\nif (((1 << ch) & eax) == 0) {\r\ndev_err(vortex->card->dev, "src alarm\n");\r\nreturn 0;\r\n}\r\nebp = VORTEX_SRC_CHNBASE + (ch << 2);\r\nesp18 = hwread(vortex->mmio, ebp);\r\nif (esp18 & 0x10) {\r\nebx = (esp18 & 0xf);\r\nif (src == ebx) {\r\nebx = VORTEX_SRC_RTBASE + (src << 2);\r\nedx = hwread(vortex->mmio, ebx);\r\nhwwrite(vortex->mmio, ebp, edx);\r\nhwwrite(vortex->mmio, ebx, 0);\r\n} else {\r\nedx =\r\nhwread(vortex->mmio,\r\nVORTEX_SRC_RTBASE + (ebx << 2));\r\nwhile ((edx & 0xf) != src) {\r\nif ((esi) > 0xf) {\r\ndev_warn(vortex->card->dev,\r\n"srcdelWTD: error, lifeboat overflow\n");\r\nreturn 0;\r\n}\r\nesp14 = ebx;\r\nebx = edx & 0xf;\r\nebp = ebx << 2;\r\nedx =\r\nhwread(vortex->mmio,\r\nVORTEX_SRC_RTBASE + ebp);\r\nesi++;\r\n}\r\nebp = ebx << 2;\r\nif (edx & 0x10) {\r\nebx = VORTEX_SRC_RTBASE + ((edx & 0xf) << 2);\r\nedx = hwread(vortex->mmio, ebx);\r\nhwwrite(vortex->mmio,\r\nVORTEX_SRC_RTBASE + ebp, edx);\r\nhwwrite(vortex->mmio, ebx, 0);\r\n} else {\r\nif (esp14 == -1)\r\nhwwrite(vortex->mmio,\r\nVORTEX_SRC_CHNBASE +\r\n(ch << 2), esp18 & 0xef);\r\nelse {\r\nebx = (0xffffffe0 & edx) | (0xf & ebx);\r\nhwwrite(vortex->mmio,\r\nVORTEX_SRC_RTBASE +\r\n(esp14 << 2), ebx);\r\n}\r\nhwwrite(vortex->mmio,\r\nVORTEX_SRC_RTBASE + ebp, 0);\r\nreturn 1;\r\n}\r\n}\r\n} else {\r\nvortex_src_dis_sr(vortex, ch);\r\nhwwrite(vortex->mmio, ebp, 0);\r\n}\r\nreturn 1;\r\n}\r\nstatic void\r\nvortex_fifo_clearadbdata(vortex_t * vortex, int fifo, int x)\r\n{\r\nfor (x--; x >= 0; x--)\r\nhwwrite(vortex->mmio,\r\nVORTEX_FIFO_ADBDATA +\r\n(((fifo << FIFO_SIZE_BITS) + x) << 2), 0);\r\n}\r\nstatic void vortex_fifo_setadbvalid(vortex_t * vortex, int fifo, int en)\r\n{\r\nhwwrite(vortex->mmio, VORTEX_FIFO_ADBCTRL + (fifo << 2),\r\n(hwread(vortex->mmio, VORTEX_FIFO_ADBCTRL + (fifo << 2)) &\r\n0xffffffef) | ((1 & en) << 4) | FIFO_U1);\r\n}\r\nstatic void\r\nvortex_fifo_setadbctrl(vortex_t * vortex, int fifo, int stereo, int priority,\r\nint empty, int valid, int f)\r\n{\r\nint temp, lifeboat = 0;\r\nint this_4 = 0x2;\r\ndo {\r\ntemp = hwread(vortex->mmio, VORTEX_FIFO_ADBCTRL + (fifo << 2));\r\nif (lifeboat++ > 0xbb8) {\r\ndev_err(vortex->card->dev,\r\n"vortex_fifo_setadbctrl fail\n");\r\nbreak;\r\n}\r\n}\r\nwhile (temp & FIFO_RDONLY);\r\nif (valid) {\r\nif ((temp & FIFO_VALID) == 0) {\r\nvortex_fifo_clearadbdata(vortex, fifo, FIFO_SIZE);\r\n#ifdef CHIP_AU8820\r\ntemp = (this_4 & 0x1f) << 0xb;\r\n#else\r\ntemp = (this_4 & 0x3f) << 0xc;\r\n#endif\r\ntemp = (temp & 0xfffffffd) | ((stereo & 1) << 1);\r\ntemp = (temp & 0xfffffff3) | ((priority & 3) << 2);\r\ntemp = (temp & 0xffffffef) | ((valid & 1) << 4);\r\ntemp |= FIFO_U1;\r\ntemp = (temp & 0xffffffdf) | ((empty & 1) << 5);\r\n#ifdef CHIP_AU8820\r\ntemp = (temp & 0xfffbffff) | ((f & 1) << 0x12);\r\n#endif\r\n#ifdef CHIP_AU8830\r\ntemp = (temp & 0xf7ffffff) | ((f & 1) << 0x1b);\r\ntemp = (temp & 0xefffffff) | ((f & 1) << 0x1c);\r\n#endif\r\n#ifdef CHIP_AU8810\r\ntemp = (temp & 0xfeffffff) | ((f & 1) << 0x18);\r\ntemp = (temp & 0xfdffffff) | ((f & 1) << 0x19);\r\n#endif\r\n}\r\n} else {\r\nif (temp & FIFO_VALID) {\r\n#ifdef CHIP_AU8820\r\ntemp = ((f & 1) << 0x12) | (temp & 0xfffbffef);\r\n#endif\r\n#ifdef CHIP_AU8830\r\ntemp =\r\n((f & 1) << 0x1b) | (temp & 0xe7ffffef) | FIFO_BITS;\r\n#endif\r\n#ifdef CHIP_AU8810\r\ntemp =\r\n((f & 1) << 0x18) | (temp & 0xfcffffef) | FIFO_BITS;\r\n#endif\r\n} else\r\nvortex_fifo_clearadbdata(vortex, fifo, FIFO_SIZE);\r\n}\r\nhwwrite(vortex->mmio, VORTEX_FIFO_ADBCTRL + (fifo << 2), temp);\r\nhwread(vortex->mmio, VORTEX_FIFO_ADBCTRL + (fifo << 2));\r\n}\r\nstatic void vortex_fifo_clearwtdata(vortex_t * vortex, int fifo, int x)\r\n{\r\nif (x < 1)\r\nreturn;\r\nfor (x--; x >= 0; x--)\r\nhwwrite(vortex->mmio,\r\nVORTEX_FIFO_WTDATA +\r\n(((fifo << FIFO_SIZE_BITS) + x) << 2), 0);\r\n}\r\nstatic void vortex_fifo_wtinitialize(vortex_t * vortex, int fifo, int j)\r\n{\r\nvortex_fifo_clearwtdata(vortex, fifo, FIFO_SIZE);\r\n#ifdef CHIP_AU8820\r\nhwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2),\r\n(FIFO_U1 | ((j & FIFO_MASK) << 0xb)));\r\n#else\r\nhwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2),\r\n(FIFO_U1 | ((j & FIFO_MASK) << 0xc)));\r\n#endif\r\n}\r\nstatic void vortex_fifo_setwtvalid(vortex_t * vortex, int fifo, int en)\r\n{\r\nhwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2),\r\n(hwread(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2)) &\r\n0xffffffef) | ((en & 1) << 4) | FIFO_U1);\r\n}\r\nstatic void\r\nvortex_fifo_setwtctrl(vortex_t * vortex, int fifo, int ctrl, int priority,\r\nint empty, int valid, int f)\r\n{\r\nint temp = 0, lifeboat = 0;\r\nint this_4 = 2;\r\ndo {\r\ntemp = hwread(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2));\r\nif (lifeboat++ > 0xbb8) {\r\ndev_err(vortex->card->dev,\r\n"vortex_fifo_setwtctrl fail\n");\r\nbreak;\r\n}\r\n}\r\nwhile (temp & FIFO_RDONLY);\r\nif (valid) {\r\nif ((temp & FIFO_VALID) == 0) {\r\nvortex_fifo_clearwtdata(vortex, fifo, FIFO_SIZE);\r\n#ifdef CHIP_AU8820\r\ntemp = (this_4 & 0x1f) << 0xb;\r\n#else\r\ntemp = (this_4 & 0x3f) << 0xc;\r\n#endif\r\ntemp = (temp & 0xfffffffd) | ((ctrl & 1) << 1);\r\ntemp = (temp & 0xfffffff3) | ((priority & 3) << 2);\r\ntemp = (temp & 0xffffffef) | ((valid & 1) << 4);\r\ntemp |= FIFO_U1;\r\ntemp = (temp & 0xffffffdf) | ((empty & 1) << 5);\r\n#ifdef CHIP_AU8820\r\ntemp = (temp & 0xfffbffff) | ((f & 1) << 0x12);\r\n#endif\r\n#ifdef CHIP_AU8830\r\ntemp = (temp & 0xf7ffffff) | ((f & 1) << 0x1b);\r\ntemp = (temp & 0xefffffff) | ((f & 1) << 0x1c);\r\n#endif\r\n#ifdef CHIP_AU8810\r\ntemp = (temp & 0xfeffffff) | ((f & 1) << 0x18);\r\ntemp = (temp & 0xfdffffff) | ((f & 1) << 0x19);\r\n#endif\r\n}\r\n} else {\r\nif (temp & FIFO_VALID) {\r\n#ifdef CHIP_AU8820\r\ntemp = ((f & 1) << 0x12) | (temp & 0xfffbffef);\r\n#endif\r\n#ifdef CHIP_AU8830\r\ntemp =\r\n((f & 1) << 0x1b) | (temp & 0xe7ffffef) | FIFO_BITS;\r\n#endif\r\n#ifdef CHIP_AU8810\r\ntemp =\r\n((f & 1) << 0x18) | (temp & 0xfcffffef) | FIFO_BITS;\r\n#endif\r\n} else\r\nvortex_fifo_clearwtdata(vortex, fifo, FIFO_SIZE);\r\n}\r\nhwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2), temp);\r\nhwread(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2));\r\n}\r\nstatic void vortex_fifo_init(vortex_t * vortex)\r\n{\r\nint x;\r\nu32 addr;\r\naddr = VORTEX_FIFO_ADBCTRL + ((NR_ADB - 1) * 4);\r\nfor (x = NR_ADB - 1; x >= 0; x--) {\r\nhwwrite(vortex->mmio, addr, (FIFO_U0 | FIFO_U1));\r\nif (hwread(vortex->mmio, addr) != (FIFO_U0 | FIFO_U1))\r\ndev_err(vortex->card->dev, "bad adb fifo reset!\n");\r\nvortex_fifo_clearadbdata(vortex, x, FIFO_SIZE);\r\naddr -= 4;\r\n}\r\n#ifndef CHIP_AU8810\r\naddr = VORTEX_FIFO_WTCTRL + ((NR_WT - 1) * 4);\r\nfor (x = NR_WT - 1; x >= 0; x--) {\r\nhwwrite(vortex->mmio, addr, FIFO_U0);\r\nif (hwread(vortex->mmio, addr) != FIFO_U0)\r\ndev_err(vortex->card->dev,\r\n"bad wt fifo reset (0x%08x, 0x%08x)!\n",\r\naddr, hwread(vortex->mmio, addr));\r\nvortex_fifo_clearwtdata(vortex, x, FIFO_SIZE);\r\naddr -= 4;\r\n}\r\n#endif\r\n#ifdef CHIP_AU8820\r\nhwwrite(vortex->mmio, 0xf8c0, 0xd03);\r\n#else\r\n#ifdef CHIP_AU8830\r\nhwwrite(vortex->mmio, 0x17000, 0x61);\r\nhwwrite(vortex->mmio, 0x17004, 0x61);\r\n#endif\r\nhwwrite(vortex->mmio, 0x17008, 0x61);\r\n#endif\r\n}\r\nstatic void vortex_adbdma_init(vortex_t * vortex)\r\n{\r\n}\r\nstatic void vortex_adbdma_setfirstbuffer(vortex_t * vortex, int adbdma)\r\n{\r\nstream_t *dma = &vortex->dma_adb[adbdma];\r\nhwwrite(vortex->mmio, VORTEX_ADBDMA_CTRL + (adbdma << 2),\r\ndma->dma_ctrl);\r\n}\r\nstatic void vortex_adbdma_setstartbuffer(vortex_t * vortex, int adbdma, int sb)\r\n{\r\nstream_t *dma = &vortex->dma_adb[adbdma];\r\nhwwrite(vortex->mmio, VORTEX_ADBDMA_START + (adbdma << 2),\r\nsb << ((0xf - (adbdma & 0xf)) * 2));\r\ndma->period_real = dma->period_virt = sb;\r\n}\r\nstatic void\r\nvortex_adbdma_setbuffers(vortex_t * vortex, int adbdma,\r\nint psize, int count)\r\n{\r\nstream_t *dma = &vortex->dma_adb[adbdma];\r\ndma->period_bytes = psize;\r\ndma->nr_periods = count;\r\ndma->cfg0 = 0;\r\ndma->cfg1 = 0;\r\nswitch (count) {\r\ndefault:\r\ncase 4:\r\ndma->cfg1 |= 0x88000000 | 0x44000000 | 0x30000000 | (psize - 1);\r\nhwwrite(vortex->mmio,\r\nVORTEX_ADBDMA_BUFBASE + (adbdma << 4) + 0xc,\r\nsnd_pcm_sgbuf_get_addr(dma->substream, psize * 3));\r\ncase 3:\r\ndma->cfg0 |= 0x12000000;\r\ndma->cfg1 |= 0x80000000 | 0x40000000 | ((psize - 1) << 0xc);\r\nhwwrite(vortex->mmio,\r\nVORTEX_ADBDMA_BUFBASE + (adbdma << 4) + 0x8,\r\nsnd_pcm_sgbuf_get_addr(dma->substream, psize * 2));\r\ncase 2:\r\ndma->cfg0 |= 0x88000000 | 0x44000000 | 0x10000000 | (psize - 1);\r\nhwwrite(vortex->mmio,\r\nVORTEX_ADBDMA_BUFBASE + (adbdma << 4) + 0x4,\r\nsnd_pcm_sgbuf_get_addr(dma->substream, psize));\r\ncase 1:\r\ndma->cfg0 |= 0x80000000 | 0x40000000 | ((psize - 1) << 0xc);\r\nhwwrite(vortex->mmio,\r\nVORTEX_ADBDMA_BUFBASE + (adbdma << 4),\r\nsnd_pcm_sgbuf_get_addr(dma->substream, 0));\r\nbreak;\r\n}\r\nhwwrite(vortex->mmio, VORTEX_ADBDMA_BUFCFG0 + (adbdma << 3), dma->cfg0);\r\nhwwrite(vortex->mmio, VORTEX_ADBDMA_BUFCFG1 + (adbdma << 3), dma->cfg1);\r\nvortex_adbdma_setfirstbuffer(vortex, adbdma);\r\nvortex_adbdma_setstartbuffer(vortex, adbdma, 0);\r\n}\r\nstatic void\r\nvortex_adbdma_setmode(vortex_t * vortex, int adbdma, int ie, int dir,\r\nint fmt, int stereo, u32 offset)\r\n{\r\nstream_t *dma = &vortex->dma_adb[adbdma];\r\ndma->dma_unknown = stereo;\r\ndma->dma_ctrl =\r\n((offset & OFFSET_MASK) | (dma->dma_ctrl & ~OFFSET_MASK));\r\ndma->dma_ctrl =\r\n(dma->dma_ctrl & ~IE_MASK) | ((ie << IE_SHIFT) & IE_MASK);\r\ndma->dma_ctrl =\r\n(dma->dma_ctrl & ~DIR_MASK) | ((dir << DIR_SHIFT) & DIR_MASK);\r\ndma->dma_ctrl =\r\n(dma->dma_ctrl & ~FMT_MASK) | ((fmt << FMT_SHIFT) & FMT_MASK);\r\nhwwrite(vortex->mmio, VORTEX_ADBDMA_CTRL + (adbdma << 2),\r\ndma->dma_ctrl);\r\nhwread(vortex->mmio, VORTEX_ADBDMA_CTRL + (adbdma << 2));\r\n}\r\nstatic int vortex_adbdma_bufshift(vortex_t * vortex, int adbdma)\r\n{\r\nstream_t *dma = &vortex->dma_adb[adbdma];\r\nint page, p, pp, delta, i;\r\npage =\r\n(hwread(vortex->mmio, VORTEX_ADBDMA_STAT + (adbdma << 2)) &\r\nADB_SUBBUF_MASK) >> ADB_SUBBUF_SHIFT;\r\nif (dma->nr_periods >= 4)\r\ndelta = (page - dma->period_real) & 3;\r\nelse {\r\ndelta = (page - dma->period_real);\r\nif (delta < 0)\r\ndelta += dma->nr_periods;\r\n}\r\nif (delta == 0)\r\nreturn 0;\r\nif (dma->nr_periods > 4) {\r\nfor (i = 0; i < delta; i++) {\r\np = dma->period_virt + i + 4;\r\nif (p >= dma->nr_periods)\r\np -= dma->nr_periods;\r\npp = dma->period_real + i;\r\nif (pp >= 4)\r\npp -= 4;\r\nhwwrite(vortex->mmio,\r\nVORTEX_ADBDMA_BUFBASE + (((adbdma << 2) + pp) << 2),\r\nsnd_pcm_sgbuf_get_addr(dma->substream,\r\ndma->period_bytes * p));\r\nhwread(vortex->mmio, VORTEX_ADBDMA_BUFBASE +\r\n(((adbdma << 2) + pp) << 2));\r\n}\r\n}\r\ndma->period_virt += delta;\r\ndma->period_real = page;\r\nif (dma->period_virt >= dma->nr_periods)\r\ndma->period_virt -= dma->nr_periods;\r\nif (delta != 1)\r\ndev_info(vortex->card->dev,\r\n"%d virt=%d, real=%d, delta=%d\n",\r\nadbdma, dma->period_virt, dma->period_real, delta);\r\nreturn delta;\r\n}\r\nstatic void vortex_adbdma_resetup(vortex_t *vortex, int adbdma) {\r\nstream_t *dma = &vortex->dma_adb[adbdma];\r\nint p, pp, i;\r\nfor (i=0 ; i < 4 && i < dma->nr_periods; i++) {\r\np = dma->period_virt + i;\r\nif (p >= dma->nr_periods)\r\np -= dma->nr_periods;\r\npp = dma->period_real + i;\r\nif (dma->nr_periods < 4) {\r\nif (pp >= dma->nr_periods)\r\npp -= dma->nr_periods;\r\n}\r\nelse {\r\nif (pp >= 4)\r\npp -= 4;\r\n}\r\nhwwrite(vortex->mmio,\r\nVORTEX_ADBDMA_BUFBASE + (((adbdma << 2) + pp) << 2),\r\nsnd_pcm_sgbuf_get_addr(dma->substream,\r\ndma->period_bytes * p));\r\nhwread(vortex->mmio, VORTEX_ADBDMA_BUFBASE + (((adbdma << 2)+pp) << 2));\r\n}\r\n}\r\nstatic inline int vortex_adbdma_getlinearpos(vortex_t * vortex, int adbdma)\r\n{\r\nstream_t *dma = &vortex->dma_adb[adbdma];\r\nint temp, page, delta;\r\ntemp = hwread(vortex->mmio, VORTEX_ADBDMA_STAT + (adbdma << 2));\r\npage = (temp & ADB_SUBBUF_MASK) >> ADB_SUBBUF_SHIFT;\r\nif (dma->nr_periods >= 4)\r\ndelta = (page - dma->period_real) & 3;\r\nelse {\r\ndelta = (page - dma->period_real);\r\nif (delta < 0)\r\ndelta += dma->nr_periods;\r\n}\r\nreturn (dma->period_virt + delta) * dma->period_bytes\r\n+ (temp & (dma->period_bytes - 1));\r\n}\r\nstatic void vortex_adbdma_startfifo(vortex_t * vortex, int adbdma)\r\n{\r\nint this_8 = 0 , this_4 = 0 ;\r\nstream_t *dma = &vortex->dma_adb[adbdma];\r\nswitch (dma->fifo_status) {\r\ncase FIFO_START:\r\nvortex_fifo_setadbvalid(vortex, adbdma,\r\ndma->fifo_enabled ? 1 : 0);\r\nbreak;\r\ncase FIFO_STOP:\r\nthis_8 = 1;\r\nhwwrite(vortex->mmio, VORTEX_ADBDMA_CTRL + (adbdma << 2),\r\ndma->dma_ctrl);\r\nvortex_fifo_setadbctrl(vortex, adbdma, dma->dma_unknown,\r\nthis_4, this_8,\r\ndma->fifo_enabled ? 1 : 0, 0);\r\nbreak;\r\ncase FIFO_PAUSE:\r\nvortex_fifo_setadbctrl(vortex, adbdma, dma->dma_unknown,\r\nthis_4, this_8,\r\ndma->fifo_enabled ? 1 : 0, 0);\r\nbreak;\r\n}\r\ndma->fifo_status = FIFO_START;\r\n}\r\nstatic void vortex_adbdma_resumefifo(vortex_t * vortex, int adbdma)\r\n{\r\nstream_t *dma = &vortex->dma_adb[adbdma];\r\nint this_8 = 1, this_4 = 0;\r\nswitch (dma->fifo_status) {\r\ncase FIFO_STOP:\r\nhwwrite(vortex->mmio, VORTEX_ADBDMA_CTRL + (adbdma << 2),\r\ndma->dma_ctrl);\r\nvortex_fifo_setadbctrl(vortex, adbdma, dma->dma_unknown,\r\nthis_4, this_8,\r\ndma->fifo_enabled ? 1 : 0, 0);\r\nbreak;\r\ncase FIFO_PAUSE:\r\nvortex_fifo_setadbctrl(vortex, adbdma, dma->dma_unknown,\r\nthis_4, this_8,\r\ndma->fifo_enabled ? 1 : 0, 0);\r\nbreak;\r\n}\r\ndma->fifo_status = FIFO_START;\r\n}\r\nstatic void vortex_adbdma_pausefifo(vortex_t * vortex, int adbdma)\r\n{\r\nstream_t *dma = &vortex->dma_adb[adbdma];\r\nint this_8 = 0, this_4 = 0;\r\nswitch (dma->fifo_status) {\r\ncase FIFO_START:\r\nvortex_fifo_setadbctrl(vortex, adbdma, dma->dma_unknown,\r\nthis_4, this_8, 0, 0);\r\nbreak;\r\ncase FIFO_STOP:\r\nhwwrite(vortex->mmio, VORTEX_ADBDMA_CTRL + (adbdma << 2),\r\ndma->dma_ctrl);\r\nvortex_fifo_setadbctrl(vortex, adbdma, dma->dma_unknown,\r\nthis_4, this_8, 0, 0);\r\nbreak;\r\n}\r\ndma->fifo_status = FIFO_PAUSE;\r\n}\r\nstatic void vortex_adbdma_stopfifo(vortex_t * vortex, int adbdma)\r\n{\r\nstream_t *dma = &vortex->dma_adb[adbdma];\r\nint this_4 = 0, this_8 = 0;\r\nif (dma->fifo_status == FIFO_START)\r\nvortex_fifo_setadbctrl(vortex, adbdma, dma->dma_unknown,\r\nthis_4, this_8, 0, 0);\r\nelse if (dma->fifo_status == FIFO_STOP)\r\nreturn;\r\ndma->fifo_status = FIFO_STOP;\r\ndma->fifo_enabled = 0;\r\n}\r\nstatic void vortex_wtdma_setfirstbuffer(vortex_t * vortex, int wtdma)\r\n{\r\nstream_t *dma = &vortex->dma_wt[wtdma];\r\nhwwrite(vortex->mmio, VORTEX_WTDMA_CTRL + (wtdma << 2), dma->dma_ctrl);\r\n}\r\nstatic void vortex_wtdma_setstartbuffer(vortex_t * vortex, int wtdma, int sb)\r\n{\r\nstream_t *dma = &vortex->dma_wt[wtdma];\r\nhwwrite(vortex->mmio, VORTEX_WTDMA_START + (wtdma << 2),\r\nsb << ((0xf - (wtdma & 0xf)) * 2));\r\ndma->period_real = dma->period_virt = sb;\r\n}\r\nstatic void\r\nvortex_wtdma_setbuffers(vortex_t * vortex, int wtdma,\r\nint psize, int count)\r\n{\r\nstream_t *dma = &vortex->dma_wt[wtdma];\r\ndma->period_bytes = psize;\r\ndma->nr_periods = count;\r\ndma->cfg0 = 0;\r\ndma->cfg1 = 0;\r\nswitch (count) {\r\ndefault:\r\ncase 4:\r\ndma->cfg1 |= 0x88000000 | 0x44000000 | 0x30000000 | (psize-1);\r\nhwwrite(vortex->mmio, VORTEX_WTDMA_BUFBASE + (wtdma << 4) + 0xc,\r\nsnd_pcm_sgbuf_get_addr(dma->substream, psize * 3));\r\ncase 3:\r\ndma->cfg0 |= 0x12000000;\r\ndma->cfg1 |= 0x80000000 | 0x40000000 | ((psize-1) << 0xc);\r\nhwwrite(vortex->mmio, VORTEX_WTDMA_BUFBASE + (wtdma << 4) + 0x8,\r\nsnd_pcm_sgbuf_get_addr(dma->substream, psize * 2));\r\ncase 2:\r\ndma->cfg0 |= 0x88000000 | 0x44000000 | 0x10000000 | (psize-1);\r\nhwwrite(vortex->mmio, VORTEX_WTDMA_BUFBASE + (wtdma << 4) + 0x4,\r\nsnd_pcm_sgbuf_get_addr(dma->substream, psize));\r\ncase 1:\r\ndma->cfg0 |= 0x80000000 | 0x40000000 | ((psize-1) << 0xc);\r\nhwwrite(vortex->mmio, VORTEX_WTDMA_BUFBASE + (wtdma << 4),\r\nsnd_pcm_sgbuf_get_addr(dma->substream, 0));\r\nbreak;\r\n}\r\nhwwrite(vortex->mmio, VORTEX_WTDMA_BUFCFG0 + (wtdma << 3), dma->cfg0);\r\nhwwrite(vortex->mmio, VORTEX_WTDMA_BUFCFG1 + (wtdma << 3), dma->cfg1);\r\nvortex_wtdma_setfirstbuffer(vortex, wtdma);\r\nvortex_wtdma_setstartbuffer(vortex, wtdma, 0);\r\n}\r\nstatic void\r\nvortex_wtdma_setmode(vortex_t * vortex, int wtdma, int ie, int fmt, int d,\r\nu32 offset)\r\n{\r\nstream_t *dma = &vortex->dma_wt[wtdma];\r\ndma->dma_unknown = d;\r\ndma->dma_ctrl = 0;\r\ndma->dma_ctrl =\r\n((offset & OFFSET_MASK) | (dma->dma_ctrl & ~OFFSET_MASK));\r\ndma->dma_ctrl =\r\n(dma->dma_ctrl & ~IE_MASK) | ((ie << IE_SHIFT) & IE_MASK);\r\ndma->dma_ctrl |= (1 << DIR_SHIFT);\r\ndma->dma_ctrl =\r\n(dma->dma_ctrl & FMT_MASK) | ((fmt << FMT_SHIFT) & FMT_MASK);\r\nhwwrite(vortex->mmio, VORTEX_WTDMA_CTRL + (wtdma << 2), dma->dma_ctrl);\r\n}\r\nstatic int vortex_wtdma_bufshift(vortex_t * vortex, int wtdma)\r\n{\r\nstream_t *dma = &vortex->dma_wt[wtdma];\r\nint page, p, pp, delta, i;\r\npage =\r\n(hwread(vortex->mmio, VORTEX_WTDMA_STAT + (wtdma << 2))\r\n>> WT_SUBBUF_SHIFT) & WT_SUBBUF_MASK;\r\nif (dma->nr_periods >= 4)\r\ndelta = (page - dma->period_real) & 3;\r\nelse {\r\ndelta = (page - dma->period_real);\r\nif (delta < 0)\r\ndelta += dma->nr_periods;\r\n}\r\nif (delta == 0)\r\nreturn 0;\r\nif (dma->nr_periods > 4) {\r\nfor (i = 0; i < delta; i++) {\r\np = dma->period_virt + i + 4;\r\nif (p >= dma->nr_periods)\r\np -= dma->nr_periods;\r\npp = dma->period_real + i;\r\nif (pp >= 4)\r\npp -= 4;\r\nhwwrite(vortex->mmio,\r\nVORTEX_WTDMA_BUFBASE +\r\n(((wtdma << 2) + pp) << 2),\r\nsnd_pcm_sgbuf_get_addr(dma->substream,\r\ndma->period_bytes * p));\r\nhwread(vortex->mmio, VORTEX_WTDMA_BUFBASE +\r\n(((wtdma << 2) + pp) << 2));\r\n}\r\n}\r\ndma->period_virt += delta;\r\nif (dma->period_virt >= dma->nr_periods)\r\ndma->period_virt -= dma->nr_periods;\r\ndma->period_real = page;\r\nif (delta != 1)\r\ndev_warn(vortex->card->dev, "wt virt = %d, delta = %d\n",\r\ndma->period_virt, delta);\r\nreturn delta;\r\n}\r\nstatic inline int vortex_wtdma_getlinearpos(vortex_t * vortex, int wtdma)\r\n{\r\nstream_t *dma = &vortex->dma_wt[wtdma];\r\nint temp;\r\ntemp = hwread(vortex->mmio, VORTEX_WTDMA_STAT + (wtdma << 2));\r\ntemp = (dma->period_virt * dma->period_bytes) + (temp & (dma->period_bytes - 1));\r\nreturn temp;\r\n}\r\nstatic void vortex_wtdma_startfifo(vortex_t * vortex, int wtdma)\r\n{\r\nstream_t *dma = &vortex->dma_wt[wtdma];\r\nint this_8 = 0, this_4 = 0;\r\nswitch (dma->fifo_status) {\r\ncase FIFO_START:\r\nvortex_fifo_setwtvalid(vortex, wtdma,\r\ndma->fifo_enabled ? 1 : 0);\r\nbreak;\r\ncase FIFO_STOP:\r\nthis_8 = 1;\r\nhwwrite(vortex->mmio, VORTEX_WTDMA_CTRL + (wtdma << 2),\r\ndma->dma_ctrl);\r\nvortex_fifo_setwtctrl(vortex, wtdma, dma->dma_unknown,\r\nthis_4, this_8,\r\ndma->fifo_enabled ? 1 : 0, 0);\r\nbreak;\r\ncase FIFO_PAUSE:\r\nvortex_fifo_setwtctrl(vortex, wtdma, dma->dma_unknown,\r\nthis_4, this_8,\r\ndma->fifo_enabled ? 1 : 0, 0);\r\nbreak;\r\n}\r\ndma->fifo_status = FIFO_START;\r\n}\r\nstatic void vortex_wtdma_resumefifo(vortex_t * vortex, int wtdma)\r\n{\r\nstream_t *dma = &vortex->dma_wt[wtdma];\r\nint this_8 = 0, this_4 = 0;\r\nswitch (dma->fifo_status) {\r\ncase FIFO_STOP:\r\nhwwrite(vortex->mmio, VORTEX_WTDMA_CTRL + (wtdma << 2),\r\ndma->dma_ctrl);\r\nvortex_fifo_setwtctrl(vortex, wtdma, dma->dma_unknown,\r\nthis_4, this_8,\r\ndma->fifo_enabled ? 1 : 0, 0);\r\nbreak;\r\ncase FIFO_PAUSE:\r\nvortex_fifo_setwtctrl(vortex, wtdma, dma->dma_unknown,\r\nthis_4, this_8,\r\ndma->fifo_enabled ? 1 : 0, 0);\r\nbreak;\r\n}\r\ndma->fifo_status = FIFO_START;\r\n}\r\nstatic void vortex_wtdma_pausefifo(vortex_t * vortex, int wtdma)\r\n{\r\nstream_t *dma = &vortex->dma_wt[wtdma];\r\nint this_8 = 0, this_4 = 0;\r\nswitch (dma->fifo_status) {\r\ncase FIFO_START:\r\nvortex_fifo_setwtctrl(vortex, wtdma, dma->dma_unknown,\r\nthis_4, this_8, 0, 0);\r\nbreak;\r\ncase FIFO_STOP:\r\nhwwrite(vortex->mmio, VORTEX_WTDMA_CTRL + (wtdma << 2),\r\ndma->dma_ctrl);\r\nvortex_fifo_setwtctrl(vortex, wtdma, dma->dma_unknown,\r\nthis_4, this_8, 0, 0);\r\nbreak;\r\n}\r\ndma->fifo_status = FIFO_PAUSE;\r\n}\r\nstatic void vortex_wtdma_stopfifo(vortex_t * vortex, int wtdma)\r\n{\r\nstream_t *dma = &vortex->dma_wt[wtdma];\r\nint this_4 = 0, this_8 = 0;\r\nif (dma->fifo_status == FIFO_START)\r\nvortex_fifo_setwtctrl(vortex, wtdma, dma->dma_unknown,\r\nthis_4, this_8, 0, 0);\r\nelse if (dma->fifo_status == FIFO_STOP)\r\nreturn;\r\ndma->fifo_status = FIFO_STOP;\r\ndma->fifo_enabled = 0;\r\n}\r\nstatic void vortex_adb_init(vortex_t * vortex)\r\n{\r\nint i;\r\nhwwrite(vortex->mmio, VORTEX_ADB_SR, 0);\r\nfor (i = 0; i < VORTEX_ADB_RTBASE_COUNT; i++)\r\nhwwrite(vortex->mmio, VORTEX_ADB_RTBASE + (i << 2),\r\nhwread(vortex->mmio,\r\nVORTEX_ADB_RTBASE + (i << 2)) | ROUTE_MASK);\r\nfor (i = 0; i < VORTEX_ADB_CHNBASE_COUNT; i++) {\r\nhwwrite(vortex->mmio, VORTEX_ADB_CHNBASE + (i << 2),\r\nhwread(vortex->mmio,\r\nVORTEX_ADB_CHNBASE + (i << 2)) | ROUTE_MASK);\r\n}\r\n}\r\nstatic void vortex_adb_en_sr(vortex_t * vortex, int channel)\r\n{\r\nhwwrite(vortex->mmio, VORTEX_ADB_SR,\r\nhwread(vortex->mmio, VORTEX_ADB_SR) | (0x1 << channel));\r\n}\r\nstatic void vortex_adb_dis_sr(vortex_t * vortex, int channel)\r\n{\r\nhwwrite(vortex->mmio, VORTEX_ADB_SR,\r\nhwread(vortex->mmio, VORTEX_ADB_SR) & ~(0x1 << channel));\r\n}\r\nstatic void\r\nvortex_adb_addroutes(vortex_t * vortex, unsigned char channel,\r\nADBRamLink * route, int rnum)\r\n{\r\nint temp, prev, lifeboat = 0;\r\nif ((rnum <= 0) || (route == NULL))\r\nreturn;\r\nrnum--;\r\nhwwrite(vortex->mmio,\r\nVORTEX_ADB_RTBASE + ((route[rnum] & ADB_MASK) << 2),\r\nROUTE_MASK);\r\nwhile (rnum > 0) {\r\nhwwrite(vortex->mmio,\r\nVORTEX_ADB_RTBASE +\r\n((route[rnum - 1] & ADB_MASK) << 2), route[rnum]);\r\nrnum--;\r\n}\r\ntemp =\r\nhwread(vortex->mmio,\r\nVORTEX_ADB_CHNBASE + (channel << 2)) & ADB_MASK;\r\nif (temp == ADB_MASK) {\r\nhwwrite(vortex->mmio, VORTEX_ADB_CHNBASE + (channel << 2),\r\nroute[0]);\r\nvortex_adb_en_sr(vortex, channel);\r\nreturn;\r\n}\r\ndo {\r\nprev = temp;\r\ntemp =\r\nhwread(vortex->mmio,\r\nVORTEX_ADB_RTBASE + (temp << 2)) & ADB_MASK;\r\nif ((lifeboat++) > ADB_MASK) {\r\ndev_err(vortex->card->dev,\r\n"vortex_adb_addroutes: unending route! 0x%x\n",\r\n*route);\r\nreturn;\r\n}\r\n}\r\nwhile (temp != ADB_MASK);\r\nhwwrite(vortex->mmio, VORTEX_ADB_RTBASE + (prev << 2), route[0]);\r\n}\r\nstatic void\r\nvortex_adb_delroutes(vortex_t * vortex, unsigned char channel,\r\nADBRamLink route0, ADBRamLink route1)\r\n{\r\nint temp, lifeboat = 0, prev;\r\ntemp =\r\nhwread(vortex->mmio,\r\nVORTEX_ADB_CHNBASE + (channel << 2)) & ADB_MASK;\r\nif (temp == (route0 & ADB_MASK)) {\r\ntemp =\r\nhwread(vortex->mmio,\r\nVORTEX_ADB_RTBASE + ((route1 & ADB_MASK) << 2));\r\nif ((temp & ADB_MASK) == ADB_MASK)\r\nvortex_adb_dis_sr(vortex, channel);\r\nhwwrite(vortex->mmio, VORTEX_ADB_CHNBASE + (channel << 2),\r\ntemp);\r\nreturn;\r\n}\r\ndo {\r\nprev = temp;\r\ntemp =\r\nhwread(vortex->mmio,\r\nVORTEX_ADB_RTBASE + (prev << 2)) & ADB_MASK;\r\nif (((lifeboat++) > ADB_MASK) || (temp == ADB_MASK)) {\r\ndev_err(vortex->card->dev,\r\n"vortex_adb_delroutes: route not found! 0x%x\n",\r\nroute0);\r\nreturn;\r\n}\r\n}\r\nwhile (temp != (route0 & ADB_MASK));\r\ntemp = hwread(vortex->mmio, VORTEX_ADB_RTBASE + (temp << 2));\r\nif ((temp & ADB_MASK) == route1)\r\ntemp = hwread(vortex->mmio, VORTEX_ADB_RTBASE + (temp << 2));\r\nhwwrite(vortex->mmio, VORTEX_ADB_RTBASE + (prev << 2), temp);\r\n}\r\nstatic void\r\nvortex_route(vortex_t * vortex, int en, unsigned char channel,\r\nunsigned char source, unsigned char dest)\r\n{\r\nADBRamLink route;\r\nroute = ((source & ADB_MASK) << ADB_SHIFT) | (dest & ADB_MASK);\r\nif (en) {\r\nvortex_adb_addroutes(vortex, channel, &route, 1);\r\nif ((source < (OFFSET_SRCOUT + NR_SRC))\r\n&& (source >= OFFSET_SRCOUT))\r\nvortex_src_addWTD(vortex, (source - OFFSET_SRCOUT),\r\nchannel);\r\nelse if ((source < (OFFSET_MIXOUT + NR_MIXOUT))\r\n&& (source >= OFFSET_MIXOUT))\r\nvortex_mixer_addWTD(vortex,\r\n(source - OFFSET_MIXOUT), channel);\r\n} else {\r\nvortex_adb_delroutes(vortex, channel, route, route);\r\nif ((source < (OFFSET_SRCOUT + NR_SRC))\r\n&& (source >= OFFSET_SRCOUT))\r\nvortex_src_delWTD(vortex, (source - OFFSET_SRCOUT),\r\nchannel);\r\nelse if ((source < (OFFSET_MIXOUT + NR_MIXOUT))\r\n&& (source >= OFFSET_MIXOUT))\r\nvortex_mixer_delWTD(vortex,\r\n(source - OFFSET_MIXOUT), channel);\r\n}\r\n}\r\nstatic void\r\nvortex_routeLRT(vortex_t * vortex, int en, unsigned char ch,\r\nunsigned char source0, unsigned char source1,\r\nunsigned char dest)\r\n{\r\nADBRamLink route[2];\r\nroute[0] = ((source0 & ADB_MASK) << ADB_SHIFT) | (dest & ADB_MASK);\r\nroute[1] = ((source1 & ADB_MASK) << ADB_SHIFT) | (dest & ADB_MASK);\r\nif (dest < 0x10)\r\nroute[1] = (route[1] & ~ADB_MASK) | (dest + 0x20);\r\nif (en) {\r\nvortex_adb_addroutes(vortex, ch, route, 2);\r\nif ((source0 < (OFFSET_SRCOUT + NR_SRC))\r\n&& (source0 >= OFFSET_SRCOUT)) {\r\nvortex_src_addWTD(vortex,\r\n(source0 - OFFSET_SRCOUT), ch);\r\nvortex_src_addWTD(vortex,\r\n(source1 - OFFSET_SRCOUT), ch);\r\n} else if ((source0 < (OFFSET_MIXOUT + NR_MIXOUT))\r\n&& (source0 >= OFFSET_MIXOUT)) {\r\nvortex_mixer_addWTD(vortex,\r\n(source0 - OFFSET_MIXOUT), ch);\r\nvortex_mixer_addWTD(vortex,\r\n(source1 - OFFSET_MIXOUT), ch);\r\n}\r\n} else {\r\nvortex_adb_delroutes(vortex, ch, route[0], route[1]);\r\nif ((source0 < (OFFSET_SRCOUT + NR_SRC))\r\n&& (source0 >= OFFSET_SRCOUT)) {\r\nvortex_src_delWTD(vortex,\r\n(source0 - OFFSET_SRCOUT), ch);\r\nvortex_src_delWTD(vortex,\r\n(source1 - OFFSET_SRCOUT), ch);\r\n} else if ((source0 < (OFFSET_MIXOUT + NR_MIXOUT))\r\n&& (source0 >= OFFSET_MIXOUT)) {\r\nvortex_mixer_delWTD(vortex,\r\n(source0 - OFFSET_MIXOUT), ch);\r\nvortex_mixer_delWTD(vortex,\r\n(source1 - OFFSET_MIXOUT), ch);\r\n}\r\n}\r\n}\r\nstatic void\r\nvortex_connection_adbdma_src(vortex_t * vortex, int en, unsigned char ch,\r\nunsigned char adbdma, unsigned char src)\r\n{\r\nvortex_route(vortex, en, ch, ADB_DMA(adbdma), ADB_SRCIN(src));\r\n}\r\nstatic void\r\nvortex_connection_src_mixin(vortex_t * vortex, int en,\r\nunsigned char channel, unsigned char src,\r\nunsigned char mixin)\r\n{\r\nvortex_route(vortex, en, channel, ADB_SRCOUT(src), ADB_MIXIN(mixin));\r\n}\r\nstatic void\r\nvortex_connection_mixin_mix(vortex_t * vortex, int en, unsigned char mixin,\r\nunsigned char mix, int a)\r\n{\r\nif (en) {\r\nvortex_mix_enableinput(vortex, mix, mixin);\r\nvortex_mix_setinputvolumebyte(vortex, mix, mixin, MIX_DEFIGAIN);\r\n} else\r\nvortex_mix_disableinput(vortex, mix, mixin, a);\r\n}\r\nstatic void\r\nvortex_connection_adb_mixin(vortex_t * vortex, int en,\r\nunsigned char channel, unsigned char source,\r\nunsigned char mixin)\r\n{\r\nvortex_route(vortex, en, channel, source, ADB_MIXIN(mixin));\r\n}\r\nstatic void\r\nvortex_connection_src_adbdma(vortex_t * vortex, int en, unsigned char ch,\r\nunsigned char src, unsigned char adbdma)\r\n{\r\nvortex_route(vortex, en, ch, ADB_SRCOUT(src), ADB_DMA(adbdma));\r\n}\r\nstatic void\r\nvortex_connection_src_src_adbdma(vortex_t * vortex, int en,\r\nunsigned char ch, unsigned char src0,\r\nunsigned char src1, unsigned char adbdma)\r\n{\r\nvortex_routeLRT(vortex, en, ch, ADB_SRCOUT(src0), ADB_SRCOUT(src1),\r\nADB_DMA(adbdma));\r\n}\r\nstatic void\r\nvortex_connection_mix_adb(vortex_t * vortex, int en, unsigned char ch,\r\nunsigned char mix, unsigned char dest)\r\n{\r\nvortex_route(vortex, en, ch, ADB_MIXOUT(mix), dest);\r\nvortex_mix_setvolumebyte(vortex, mix, MIX_DEFOGAIN);\r\n}\r\nstatic void\r\nvortex_connection_mix_src(vortex_t * vortex, int en, unsigned char ch,\r\nunsigned char mix, unsigned char src)\r\n{\r\nvortex_route(vortex, en, ch, ADB_MIXOUT(mix), ADB_SRCIN(src));\r\nvortex_mix_setvolumebyte(vortex, mix, MIX_DEFOGAIN);\r\n}\r\nstatic void\r\nvortex_connect_codecplay(vortex_t * vortex, int en, unsigned char mixers[])\r\n{\r\n#ifdef CHIP_AU8820\r\nvortex_connection_mix_adb(vortex, en, 0x11, mixers[0], ADB_CODECOUT(0));\r\nvortex_connection_mix_adb(vortex, en, 0x11, mixers[1], ADB_CODECOUT(1));\r\n#else\r\n#if 1\r\nvortex_connection_mix_adb(vortex, en, 0x11, mixers[0], ADB_EQIN(0));\r\nvortex_connection_mix_adb(vortex, en, 0x11, mixers[1], ADB_EQIN(1));\r\nvortex_mix_setvolumebyte(vortex, mixers[0], 0);\r\nvortex_mix_setvolumebyte(vortex, mixers[1], 0);\r\nvortex_route(vortex, en, 0x11, ADB_EQOUT(0), ADB_CODECOUT(0));\r\nvortex_route(vortex, en, 0x11, ADB_EQOUT(1), ADB_CODECOUT(1));\r\nif (VORTEX_IS_QUAD(vortex)) {\r\nvortex_connection_mix_adb(vortex, en, 0x11, mixers[2],\r\nADB_CODECOUT(0 + 4));\r\nvortex_connection_mix_adb(vortex, en, 0x11, mixers[3],\r\nADB_CODECOUT(1 + 4));\r\n}\r\n#else\r\nvortex_connection_mix_adb(vortex, en, 0x11, mixers[0], ADB_CODECOUT(0));\r\nvortex_connection_mix_adb(vortex, en, 0x11, mixers[1], ADB_CODECOUT(1));\r\n#endif\r\n#endif\r\n}\r\nstatic void\r\nvortex_connect_codecrec(vortex_t * vortex, int en, unsigned char mixin0,\r\nunsigned char mixin1)\r\n{\r\nvortex_connection_adb_mixin(vortex, en, 0x11, ADB_CODECIN(0), mixin0);\r\nvortex_connection_adb_mixin(vortex, en, 0x11, ADB_CODECIN(1), mixin1);\r\n}\r\nstatic char\r\nvortex_adb_checkinout(vortex_t * vortex, int resmap[], int out, int restype)\r\n{\r\nint i, qty = resnum[restype], resinuse = 0;\r\nif (out) {\r\nfor (i = 0; i < NR_ADB; i++) {\r\nresinuse |= vortex->dma_adb[i].resources[restype];\r\n}\r\nresinuse |= vortex->fixed_res[restype];\r\nfor (i = 0; i < qty; i++) {\r\nif ((resinuse & (1 << i)) == 0) {\r\nif (resmap != NULL)\r\nresmap[restype] |= (1 << i);\r\nelse\r\nvortex->dma_adb[i].resources[restype] |= (1 << i);\r\nreturn i;\r\n}\r\n}\r\n} else {\r\nif (resmap == NULL)\r\nreturn -EINVAL;\r\nfor (i = 0; i < qty; i++) {\r\nif (resmap[restype] & (1 << i)) {\r\nresmap[restype] &= ~(1 << i);\r\nreturn i;\r\n}\r\n}\r\n}\r\ndev_err(vortex->card->dev,\r\n"FATAL: ResManager: resource type %d exhausted.\n",\r\nrestype);\r\nreturn -ENOMEM;\r\n}\r\nstatic void vortex_connect_default(vortex_t * vortex, int en)\r\n{\r\nvortex->mixplayb[0] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\r\nVORTEX_RESOURCE_MIXOUT);\r\nvortex->mixplayb[1] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\r\nVORTEX_RESOURCE_MIXOUT);\r\nif (VORTEX_IS_QUAD(vortex)) {\r\nvortex->mixplayb[2] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\r\nVORTEX_RESOURCE_MIXOUT);\r\nvortex->mixplayb[3] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\r\nVORTEX_RESOURCE_MIXOUT);\r\n}\r\nvortex_connect_codecplay(vortex, en, vortex->mixplayb);\r\nvortex->mixcapt[0] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\r\nVORTEX_RESOURCE_MIXIN);\r\nvortex->mixcapt[1] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\r\nVORTEX_RESOURCE_MIXIN);\r\nvortex_connect_codecrec(vortex, en, MIX_CAPT(0), MIX_CAPT(1));\r\n#ifndef CHIP_AU8820\r\nvortex->mixspdif[0] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\r\nVORTEX_RESOURCE_MIXOUT);\r\nvortex->mixspdif[1] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\r\nVORTEX_RESOURCE_MIXOUT);\r\nvortex_connection_mix_adb(vortex, en, 0x14, vortex->mixspdif[0],\r\nADB_SPDIFOUT(0));\r\nvortex_connection_mix_adb(vortex, en, 0x14, vortex->mixspdif[1],\r\nADB_SPDIFOUT(1));\r\n#endif\r\n#ifndef CHIP_AU8810\r\nvortex_wt_connect(vortex, en);\r\n#endif\r\n#ifndef CHIP_AU8820\r\nvortex_Vort3D_connect(vortex, en);\r\n#endif\r\n}\r\nstatic int\r\nvortex_adb_allocroute(vortex_t *vortex, int dma, int nr_ch, int dir,\r\nint type, int subdev)\r\n{\r\nstream_t *stream;\r\nint i, en;\r\nstruct pcm_vol *p;\r\nif (dma >= 0) {\r\nen = 0;\r\nvortex_adb_checkinout(vortex,\r\nvortex->dma_adb[dma].resources, en,\r\nVORTEX_RESOURCE_DMA);\r\n} else {\r\nen = 1;\r\nif ((dma =\r\nvortex_adb_checkinout(vortex, NULL, en,\r\nVORTEX_RESOURCE_DMA)) < 0)\r\nreturn -EBUSY;\r\n}\r\nstream = &vortex->dma_adb[dma];\r\nstream->dma = dma;\r\nstream->dir = dir;\r\nstream->type = type;\r\nif (dir == SNDRV_PCM_STREAM_PLAYBACK) {\r\nint src[4], mix[4], ch_top;\r\n#ifndef CHIP_AU8820\r\nint a3d = 0;\r\n#endif\r\nif (stream->type != VORTEX_PCM_SPDIF) {\r\nfor (i = 0; i < nr_ch; i++) {\r\nif ((src[i] = vortex_adb_checkinout(vortex,\r\nstream->resources, en,\r\nVORTEX_RESOURCE_SRC)) < 0) {\r\nmemset(stream->resources, 0,\r\nsizeof(stream->resources));\r\nreturn -EBUSY;\r\n}\r\nif (stream->type != VORTEX_PCM_A3D) {\r\nif ((mix[i] = vortex_adb_checkinout(vortex,\r\nstream->resources,\r\nen,\r\nVORTEX_RESOURCE_MIXIN)) < 0) {\r\nmemset(stream->resources,\r\n0,\r\nsizeof(stream->resources));\r\nreturn -EBUSY;\r\n}\r\n}\r\n}\r\n}\r\n#ifndef CHIP_AU8820\r\nif (stream->type == VORTEX_PCM_A3D) {\r\nif ((a3d =\r\nvortex_adb_checkinout(vortex,\r\nstream->resources, en,\r\nVORTEX_RESOURCE_A3D)) < 0) {\r\nmemset(stream->resources, 0,\r\nsizeof(stream->resources));\r\ndev_err(vortex->card->dev,\r\n"out of A3D sources. Sorry\n");\r\nreturn -EBUSY;\r\n}\r\nvortex_Vort3D_InitializeSource(&vortex->a3d[a3d], en,\r\nvortex);\r\n}\r\nif ((stream->type == VORTEX_PCM_SPDIF) && (en)) {\r\nvortex_route(vortex, 0, 0x14,\r\nADB_MIXOUT(vortex->mixspdif[0]),\r\nADB_SPDIFOUT(0));\r\nvortex_route(vortex, 0, 0x14,\r\nADB_MIXOUT(vortex->mixspdif[1]),\r\nADB_SPDIFOUT(1));\r\n}\r\n#endif\r\nfor (i = 0; i < nr_ch; i++) {\r\nif (stream->type == VORTEX_PCM_ADB) {\r\nvortex_connection_adbdma_src(vortex, en,\r\nsrc[nr_ch - 1],\r\ndma,\r\nsrc[i]);\r\nvortex_connection_src_mixin(vortex, en,\r\n0x11, src[i],\r\nmix[i]);\r\nvortex_connection_mixin_mix(vortex, en,\r\nmix[i],\r\nMIX_PLAYB(i), 0);\r\n#ifndef CHIP_AU8820\r\nvortex_connection_mixin_mix(vortex, en,\r\nmix[i],\r\nMIX_SPDIF(i % 2), 0);\r\nvortex_mix_setinputvolumebyte(vortex,\r\nMIX_SPDIF(i % 2),\r\nmix[i],\r\nMIX_DEFIGAIN);\r\n#endif\r\n}\r\n#ifndef CHIP_AU8820\r\nif (stream->type == VORTEX_PCM_A3D) {\r\nvortex_connection_adbdma_src(vortex, en,\r\nsrc[nr_ch - 1],\r\ndma,\r\nsrc[i]);\r\nvortex_route(vortex, en, 0x11, ADB_SRCOUT(src[i]), ADB_A3DIN(a3d));\r\n}\r\nif (stream->type == VORTEX_PCM_SPDIF)\r\nvortex_route(vortex, en, 0x14,\r\nADB_DMA(stream->dma),\r\nADB_SPDIFOUT(i));\r\n#endif\r\n}\r\nif (stream->type != VORTEX_PCM_SPDIF && stream->type != VORTEX_PCM_A3D) {\r\nch_top = (VORTEX_IS_QUAD(vortex) ? 4 : 2);\r\nfor (i = nr_ch; i < ch_top; i++) {\r\nvortex_connection_mixin_mix(vortex, en,\r\nmix[i % nr_ch],\r\nMIX_PLAYB(i), 0);\r\n#ifndef CHIP_AU8820\r\nvortex_connection_mixin_mix(vortex, en,\r\nmix[i % nr_ch],\r\nMIX_SPDIF(i % 2),\r\n0);\r\nvortex_mix_setinputvolumebyte(vortex,\r\nMIX_SPDIF(i % 2),\r\nmix[i % nr_ch],\r\nMIX_DEFIGAIN);\r\n#endif\r\n}\r\nif (stream->type == VORTEX_PCM_ADB && en) {\r\np = &vortex->pcm_vol[subdev];\r\np->dma = dma;\r\nfor (i = 0; i < nr_ch; i++)\r\np->mixin[i] = mix[i];\r\nfor (i = 0; i < ch_top; i++)\r\np->vol[i] = 0;\r\n}\r\n}\r\n#ifndef CHIP_AU8820\r\nelse {\r\nif (nr_ch == 1 && stream->type == VORTEX_PCM_SPDIF)\r\nvortex_route(vortex, en, 0x14,\r\nADB_DMA(stream->dma),\r\nADB_SPDIFOUT(1));\r\n}\r\nif ((stream->type == VORTEX_PCM_SPDIF) && (!en)) {\r\nvortex_route(vortex, 1, 0x14,\r\nADB_MIXOUT(vortex->mixspdif[0]),\r\nADB_SPDIFOUT(0));\r\nvortex_route(vortex, 1, 0x14,\r\nADB_MIXOUT(vortex->mixspdif[1]),\r\nADB_SPDIFOUT(1));\r\n}\r\n#endif\r\n} else {\r\nint src[2], mix[2];\r\nif (nr_ch < 1)\r\nreturn -EINVAL;\r\nfor (i = 0; i < nr_ch; i++) {\r\nif ((mix[i] =\r\nvortex_adb_checkinout(vortex,\r\nstream->resources, en,\r\nVORTEX_RESOURCE_MIXOUT))\r\n< 0) {\r\nmemset(stream->resources, 0,\r\nsizeof(stream->resources));\r\nreturn -EBUSY;\r\n}\r\nif ((src[i] =\r\nvortex_adb_checkinout(vortex,\r\nstream->resources, en,\r\nVORTEX_RESOURCE_SRC)) < 0) {\r\nmemset(stream->resources, 0,\r\nsizeof(stream->resources));\r\nreturn -EBUSY;\r\n}\r\n}\r\nvortex_connection_mixin_mix(vortex, en, MIX_CAPT(0), mix[0], 0);\r\nvortex_connection_mix_src(vortex, en, 0x11, mix[0], src[0]);\r\nif (nr_ch == 1) {\r\nvortex_connection_mixin_mix(vortex, en,\r\nMIX_CAPT(1), mix[0], 0);\r\nvortex_connection_src_adbdma(vortex, en,\r\nsrc[0],\r\nsrc[0], dma);\r\n} else {\r\nvortex_connection_mixin_mix(vortex, en,\r\nMIX_CAPT(1), mix[1], 0);\r\nvortex_connection_mix_src(vortex, en, 0x11, mix[1],\r\nsrc[1]);\r\nvortex_connection_src_src_adbdma(vortex, en,\r\nsrc[1], src[0],\r\nsrc[1], dma);\r\n}\r\n}\r\nvortex->dma_adb[dma].nr_ch = nr_ch;\r\n#if 0\r\nif (nr_ch < 4) {\r\nsnd_ac97_write_cache(vortex->codec,\r\nAC97_SIGMATEL_DAC2INVERT,\r\nsnd_ac97_read(vortex->codec,\r\nAC97_SIGMATEL_DAC2INVERT)\r\n| 4);\r\n} else {\r\nsnd_ac97_write_cache(vortex->codec,\r\nAC97_SIGMATEL_DAC2INVERT,\r\nsnd_ac97_read(vortex->codec,\r\nAC97_SIGMATEL_DAC2INVERT)\r\n& ~((u32)\r\n4));\r\n}\r\n#endif\r\nreturn dma;\r\n}\r\nstatic void\r\nvortex_adb_setsrc(vortex_t * vortex, int adbdma, unsigned int rate, int dir)\r\n{\r\nstream_t *stream = &(vortex->dma_adb[adbdma]);\r\nint i, cvrt;\r\nif (dir)\r\ncvrt = SRC_RATIO(rate, 48000);\r\nelse\r\ncvrt = SRC_RATIO(48000, rate);\r\nfor (i = 0; i < NR_SRC; i++) {\r\nif (stream->resources[VORTEX_RESOURCE_SRC] & (1 << i))\r\nvortex_src_setupchannel(vortex, i, cvrt, 0, 0, i, dir, 1, cvrt, dir);\r\n}\r\n}\r\nstatic void vortex_settimer(vortex_t * vortex, int period)\r\n{\r\nhwwrite(vortex->mmio, VORTEX_IRQ_STAT, period);\r\n}\r\nstatic void vortex_enable_int(vortex_t * card)\r\n{\r\nhwwrite(card->mmio, VORTEX_CTRL,\r\nhwread(card->mmio, VORTEX_CTRL) | CTRL_IRQ_ENABLE);\r\nhwwrite(card->mmio, VORTEX_IRQ_CTRL,\r\n(hwread(card->mmio, VORTEX_IRQ_CTRL) & 0xffffefc0) | 0x24);\r\n}\r\nstatic void vortex_disable_int(vortex_t * card)\r\n{\r\nhwwrite(card->mmio, VORTEX_CTRL,\r\nhwread(card->mmio, VORTEX_CTRL) & ~CTRL_IRQ_ENABLE);\r\n}\r\nstatic irqreturn_t vortex_interrupt(int irq, void *dev_id)\r\n{\r\nvortex_t *vortex = dev_id;\r\nint i, handled;\r\nu32 source;\r\nif (!(hwread(vortex->mmio, VORTEX_STAT) & 0x1))\r\nreturn IRQ_NONE;\r\nif (!(hwread(vortex->mmio, VORTEX_CTRL) & CTRL_IRQ_ENABLE))\r\nreturn IRQ_NONE;\r\nsource = hwread(vortex->mmio, VORTEX_IRQ_SOURCE);\r\nhwwrite(vortex->mmio, VORTEX_IRQ_SOURCE, source);\r\nhwread(vortex->mmio, VORTEX_IRQ_SOURCE);\r\nif (source == 0) {\r\ndev_err(vortex->card->dev, "missing irq source\n");\r\nreturn IRQ_NONE;\r\n}\r\nhandled = 0;\r\nif (unlikely(source & IRQ_ERR_MASK)) {\r\nif (source & IRQ_FATAL) {\r\ndev_err(vortex->card->dev, "IRQ fatal error\n");\r\n}\r\nif (source & IRQ_PARITY) {\r\ndev_err(vortex->card->dev, "IRQ parity error\n");\r\n}\r\nif (source & IRQ_REG) {\r\ndev_err(vortex->card->dev, "IRQ reg error\n");\r\n}\r\nif (source & IRQ_FIFO) {\r\ndev_err(vortex->card->dev, "IRQ fifo error\n");\r\n}\r\nif (source & IRQ_DMA) {\r\ndev_err(vortex->card->dev, "IRQ dma error\n");\r\n}\r\nhandled = 1;\r\n}\r\nif (source & IRQ_PCMOUT) {\r\nspin_lock(&vortex->lock);\r\nfor (i = 0; i < NR_ADB; i++) {\r\nif (vortex->dma_adb[i].fifo_status == FIFO_START) {\r\nif (!vortex_adbdma_bufshift(vortex, i))\r\ncontinue;\r\nspin_unlock(&vortex->lock);\r\nsnd_pcm_period_elapsed(vortex->dma_adb[i].\r\nsubstream);\r\nspin_lock(&vortex->lock);\r\n}\r\n}\r\n#ifndef CHIP_AU8810\r\nfor (i = 0; i < NR_WT; i++) {\r\nif (vortex->dma_wt[i].fifo_status == FIFO_START) {\r\nvortex_wtdma_bufshift(vortex, i);\r\nspin_unlock(&vortex->lock);\r\nsnd_pcm_period_elapsed(vortex->dma_wt[i].\r\nsubstream);\r\nspin_lock(&vortex->lock);\r\n}\r\n}\r\n#endif\r\nspin_unlock(&vortex->lock);\r\nhandled = 1;\r\n}\r\nif (source & IRQ_TIMER) {\r\nhwread(vortex->mmio, VORTEX_IRQ_STAT);\r\nhandled = 1;\r\n}\r\nif ((source & IRQ_MIDI) && vortex->rmidi) {\r\nsnd_mpu401_uart_interrupt(vortex->irq,\r\nvortex->rmidi->private_data);\r\nhandled = 1;\r\n}\r\nif (!handled) {\r\ndev_err(vortex->card->dev, "unknown irq source %x\n", source);\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void vortex_codec_init(vortex_t * vortex)\r\n{\r\nint i;\r\nfor (i = 0; i < 32; i++) {\r\nhwwrite(vortex->mmio, (VORTEX_CODEC_CHN + (i << 2)), -i);\r\nmsleep(2);\r\n}\r\nif (0) {\r\nhwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x8068);\r\nmsleep(1);\r\nhwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x00e8);\r\nmsleep(1);\r\n} else {\r\nhwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x00a8);\r\nmsleep(2);\r\nhwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x80a8);\r\nmsleep(2);\r\nhwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x80e8);\r\nmsleep(2);\r\nhwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x80a8);\r\nmsleep(2);\r\nhwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x00a8);\r\nmsleep(2);\r\nhwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x00e8);\r\n}\r\nfor (i = 0; i < 32; i++) {\r\nhwwrite(vortex->mmio, (VORTEX_CODEC_CHN + (i << 2)), -i);\r\nmsleep(5);\r\n}\r\nhwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0xe8);\r\nmsleep(1);\r\nhwwrite(vortex->mmio, VORTEX_CODEC_EN,\r\nhwread(vortex->mmio, VORTEX_CODEC_EN) | EN_CODEC);\r\n}\r\nstatic void\r\nvortex_codec_write(struct snd_ac97 * codec, unsigned short addr, unsigned short data)\r\n{\r\nvortex_t *card = (vortex_t *) codec->private_data;\r\nunsigned int lifeboat = 0;\r\nwhile (!(hwread(card->mmio, VORTEX_CODEC_CTRL) & 0x100)) {\r\nudelay(100);\r\nif (lifeboat++ > POLL_COUNT) {\r\ndev_err(card->card->dev, "ac97 codec stuck busy\n");\r\nreturn;\r\n}\r\n}\r\nhwwrite(card->mmio, VORTEX_CODEC_IO,\r\n((addr << VORTEX_CODEC_ADDSHIFT) & VORTEX_CODEC_ADDMASK) |\r\n((data << VORTEX_CODEC_DATSHIFT) & VORTEX_CODEC_DATMASK) |\r\nVORTEX_CODEC_WRITE |\r\n(codec->num << VORTEX_CODEC_ID_SHIFT) );\r\nhwread(card->mmio, VORTEX_CODEC_IO);\r\n}\r\nstatic unsigned short vortex_codec_read(struct snd_ac97 * codec, unsigned short addr)\r\n{\r\nvortex_t *card = (vortex_t *) codec->private_data;\r\nu32 read_addr, data;\r\nunsigned lifeboat = 0;\r\nwhile (!(hwread(card->mmio, VORTEX_CODEC_CTRL) & 0x100)) {\r\nudelay(100);\r\nif (lifeboat++ > POLL_COUNT) {\r\ndev_err(card->card->dev, "ac97 codec stuck busy\n");\r\nreturn 0xffff;\r\n}\r\n}\r\nread_addr = ((addr << VORTEX_CODEC_ADDSHIFT) & VORTEX_CODEC_ADDMASK) |\r\n(codec->num << VORTEX_CODEC_ID_SHIFT) ;\r\nhwwrite(card->mmio, VORTEX_CODEC_IO, read_addr);\r\ndo {\r\nudelay(100);\r\ndata = hwread(card->mmio, VORTEX_CODEC_IO);\r\nif (lifeboat++ > POLL_COUNT) {\r\ndev_err(card->card->dev,\r\n"ac97 address never arrived\n");\r\nreturn 0xffff;\r\n}\r\n} while ((data & VORTEX_CODEC_ADDMASK) !=\r\n(addr << VORTEX_CODEC_ADDSHIFT));\r\nreturn (u16) (data & VORTEX_CODEC_DATMASK);\r\n}\r\nstatic void vortex_spdif_init(vortex_t * vortex, int spdif_sr, int spdif_mode)\r\n{\r\nint i, this_38 = 0, this_04 = 0, this_08 = 0, this_0c = 0;\r\nhwwrite(vortex->mmio, VORTEX_SPDIF_FLAGS,\r\nhwread(vortex->mmio, VORTEX_SPDIF_FLAGS) & 0xfff3fffd);\r\nfor (i = 0; i < 11; i++)\r\nhwwrite(vortex->mmio, VORTEX_SPDIF_CFG1 + (i << 2), 0);\r\nhwwrite(vortex->mmio, VORTEX_CODEC_EN,\r\nhwread(vortex->mmio, VORTEX_CODEC_EN) | EN_SPDIF);\r\nif (this_04 && this_08) {\r\nint edi;\r\ni = (((0x5DC00000 / spdif_sr) + 1) >> 1);\r\nif (i > 0x800) {\r\nif (i < 0x1ffff)\r\nedi = (i >> 1);\r\nelse\r\nedi = 0x1ffff;\r\n} else {\r\ni = edi = 0x800;\r\n}\r\nvortex_src_setupchannel(vortex, this_04, edi, 0, 1,\r\nthis_0c, 1, 0, edi, 1);\r\nvortex_src_setupchannel(vortex, this_08, edi, 0, 1,\r\nthis_0c, 1, 0, edi, 1);\r\n}\r\ni = spdif_sr;\r\nspdif_sr |= 0x8c;\r\nswitch (i) {\r\ncase 32000:\r\nthis_38 &= 0xFFFFFFFE;\r\nthis_38 &= 0xFFFFFFFD;\r\nthis_38 &= 0xF3FFFFFF;\r\nthis_38 |= 0x03000000;\r\nthis_38 &= 0xFFFFFF3F;\r\nspdif_sr &= 0xFFFFFFFD;\r\nspdif_sr |= 1;\r\nbreak;\r\ncase 44100:\r\nthis_38 &= 0xFFFFFFFE;\r\nthis_38 &= 0xFFFFFFFD;\r\nthis_38 &= 0xF0FFFFFF;\r\nthis_38 |= 0x03000000;\r\nthis_38 &= 0xFFFFFF3F;\r\nspdif_sr &= 0xFFFFFFFC;\r\nbreak;\r\ncase 48000:\r\nif (spdif_mode == 1) {\r\nthis_38 &= 0xFFFFFFFE;\r\nthis_38 &= 0xFFFFFFFD;\r\nthis_38 &= 0xF2FFFFFF;\r\nthis_38 |= 0x02000000;\r\nthis_38 &= 0xFFFFFF3F;\r\n} else {\r\nthis_38 |= 0x00000003;\r\nthis_38 &= 0xFFFFFFBF;\r\nthis_38 |= 0x80;\r\n}\r\nspdif_sr |= 2;\r\nspdif_sr &= 0xFFFFFFFE;\r\nbreak;\r\n}\r\nhwwrite(vortex->mmio, VORTEX_SPDIF_CFG0, this_38 & 0xffff);\r\nhwwrite(vortex->mmio, VORTEX_SPDIF_CFG1, this_38 >> 0x10);\r\nhwwrite(vortex->mmio, VORTEX_SPDIF_SMPRATE, spdif_sr);\r\n}\r\nstatic int vortex_core_init(vortex_t *vortex)\r\n{\r\ndev_info(vortex->card->dev, "init started\n");\r\nhwwrite(vortex->mmio, VORTEX_CTRL, 0xffffffff);\r\nmsleep(5);\r\nhwwrite(vortex->mmio, VORTEX_CTRL,\r\nhwread(vortex->mmio, VORTEX_CTRL) & 0xffdfffff);\r\nmsleep(5);\r\nhwwrite(vortex->mmio, VORTEX_IRQ_SOURCE, 0xffffffff);\r\nhwread(vortex->mmio, VORTEX_IRQ_STAT);\r\nvortex_codec_init(vortex);\r\n#ifdef CHIP_AU8830\r\nhwwrite(vortex->mmio, VORTEX_CTRL,\r\nhwread(vortex->mmio, VORTEX_CTRL) | 0x1000000);\r\n#endif\r\nvortex_adbdma_init(vortex);\r\nhwwrite(vortex->mmio, VORTEX_ENGINE_CTRL, 0x0);\r\nvortex_adb_init(vortex);\r\nvortex_fifo_init(vortex);\r\nvortex_mixer_init(vortex);\r\nvortex_srcblock_init(vortex);\r\n#ifndef CHIP_AU8820\r\nvortex_eq_init(vortex);\r\nvortex_spdif_init(vortex, 48000, 1);\r\nvortex_Vort3D_enable(vortex);\r\n#endif\r\n#ifndef CHIP_AU8810\r\nvortex_wt_init(vortex);\r\n#endif\r\nvortex_settimer(vortex, 0x90);\r\ndev_info(vortex->card->dev, "init.... done.\n");\r\nspin_lock_init(&vortex->lock);\r\nreturn 0;\r\n}\r\nstatic int vortex_core_shutdown(vortex_t * vortex)\r\n{\r\ndev_info(vortex->card->dev, "shutdown started\n");\r\n#ifndef CHIP_AU8820\r\nvortex_eq_free(vortex);\r\nvortex_Vort3D_disable(vortex);\r\n#endif\r\nvortex_disable_int(vortex);\r\nvortex_connect_default(vortex, 0);\r\nvortex_fifo_init(vortex);\r\nvortex_adb_init(vortex);\r\nhwwrite(vortex->mmio, VORTEX_IRQ_CTRL, 0);\r\nhwwrite(vortex->mmio, VORTEX_CTRL, 0);\r\nmsleep(5);\r\nhwwrite(vortex->mmio, VORTEX_IRQ_SOURCE, 0xffff);\r\ndev_info(vortex->card->dev, "shutdown.... done.\n");\r\nreturn 0;\r\n}\r\nstatic int vortex_alsafmt_aspfmt(int alsafmt, vortex_t *v)\r\n{\r\nint fmt;\r\nswitch (alsafmt) {\r\ncase SNDRV_PCM_FORMAT_U8:\r\nfmt = 0x1;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_MU_LAW:\r\nfmt = 0x2;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_A_LAW:\r\nfmt = 0x3;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_SPECIAL:\r\nfmt = 0x4;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:\r\nfmt = 0x5;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nfmt = 0x8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_BE:\r\nfmt = 0x9;\r\nbreak;\r\ndefault:\r\nfmt = 0x8;\r\ndev_err(v->card->dev,\r\n"format unsupported %d\n", alsafmt);\r\nbreak;\r\n}\r\nreturn fmt;\r\n}
