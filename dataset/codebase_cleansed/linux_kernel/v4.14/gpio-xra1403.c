static unsigned int to_reg(unsigned int reg, unsigned int offset)\r\n{\r\nreturn reg + (offset > 7);\r\n}\r\nstatic int xra1403_direction_input(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nstruct xra1403 *xra = gpiochip_get_data(chip);\r\nreturn regmap_update_bits(xra->regmap, to_reg(XRA_GCR, offset),\r\nBIT(offset % 8), BIT(offset % 8));\r\n}\r\nstatic int xra1403_direction_output(struct gpio_chip *chip, unsigned int offset,\r\nint value)\r\n{\r\nint ret;\r\nstruct xra1403 *xra = gpiochip_get_data(chip);\r\nret = regmap_update_bits(xra->regmap, to_reg(XRA_GCR, offset),\r\nBIT(offset % 8), 0);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(xra->regmap, to_reg(XRA_OCR, offset),\r\nBIT(offset % 8), value ? BIT(offset % 8) : 0);\r\nreturn ret;\r\n}\r\nstatic int xra1403_get_direction(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nint ret;\r\nunsigned int val;\r\nstruct xra1403 *xra = gpiochip_get_data(chip);\r\nret = regmap_read(xra->regmap, to_reg(XRA_GCR, offset), &val);\r\nif (ret)\r\nreturn ret;\r\nreturn !!(val & BIT(offset % 8));\r\n}\r\nstatic int xra1403_get(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nint ret;\r\nunsigned int val;\r\nstruct xra1403 *xra = gpiochip_get_data(chip);\r\nret = regmap_read(xra->regmap, to_reg(XRA_GSR, offset), &val);\r\nif (ret)\r\nreturn ret;\r\nreturn !!(val & BIT(offset % 8));\r\n}\r\nstatic void xra1403_set(struct gpio_chip *chip, unsigned int offset, int value)\r\n{\r\nint ret;\r\nstruct xra1403 *xra = gpiochip_get_data(chip);\r\nret = regmap_update_bits(xra->regmap, to_reg(XRA_OCR, offset),\r\nBIT(offset % 8), value ? BIT(offset % 8) : 0);\r\nif (ret)\r\ndev_err(chip->parent, "Failed to set pin: %d, ret: %d\n",\r\noffset, ret);\r\n}\r\nstatic void xra1403_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nint reg;\r\nstruct xra1403 *xra = gpiochip_get_data(chip);\r\nint value[xra1403_regmap_cfg.max_register];\r\nint i;\r\nunsigned int gcr;\r\nunsigned int gsr;\r\nseq_puts(s, "xra reg:");\r\nfor (reg = 0; reg <= xra1403_regmap_cfg.max_register; reg++)\r\nseq_printf(s, " %2.2x", reg);\r\nseq_puts(s, "\n value:");\r\nfor (reg = 0; reg < xra1403_regmap_cfg.max_register; reg++) {\r\nregmap_read(xra->regmap, reg, &value[reg]);\r\nseq_printf(s, " %2.2x", value[reg]);\r\n}\r\nseq_puts(s, "\n");\r\ngcr = value[XRA_GCR + 1] << 8 | value[XRA_GCR];\r\ngsr = value[XRA_GSR + 1] << 8 | value[XRA_GSR];\r\nfor (i = 0; i < chip->ngpio; i++) {\r\nconst char *label = gpiochip_is_requested(chip, i);\r\nif (!label)\r\ncontinue;\r\nseq_printf(s, " gpio-%-3d (%-12s) %s %s\n",\r\nchip->base + i, label,\r\n(gcr & BIT(i)) ? "in" : "out",\r\n(gsr & BIT(i)) ? "hi" : "lo");\r\n}\r\n}\r\nstatic int xra1403_probe(struct spi_device *spi)\r\n{\r\nstruct xra1403 *xra;\r\nstruct gpio_desc *reset_gpio;\r\nint ret;\r\nxra = devm_kzalloc(&spi->dev, sizeof(*xra), GFP_KERNEL);\r\nif (!xra)\r\nreturn -ENOMEM;\r\nreset_gpio = devm_gpiod_get_optional(&spi->dev, "reset", GPIOD_OUT_LOW);\r\nif (IS_ERR(reset_gpio))\r\ndev_warn(&spi->dev, "Could not get reset-gpios\n");\r\nxra->chip.direction_input = xra1403_direction_input;\r\nxra->chip.direction_output = xra1403_direction_output;\r\nxra->chip.get_direction = xra1403_get_direction;\r\nxra->chip.get = xra1403_get;\r\nxra->chip.set = xra1403_set;\r\nxra->chip.dbg_show = xra1403_dbg_show;\r\nxra->chip.ngpio = 16;\r\nxra->chip.label = "xra1403";\r\nxra->chip.base = -1;\r\nxra->chip.can_sleep = true;\r\nxra->chip.parent = &spi->dev;\r\nxra->chip.owner = THIS_MODULE;\r\nxra->regmap = devm_regmap_init_spi(spi, &xra1403_regmap_cfg);\r\nif (IS_ERR(xra->regmap)) {\r\nret = PTR_ERR(xra->regmap);\r\ndev_err(&spi->dev, "Failed to allocate regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_gpiochip_add_data(&spi->dev, &xra->chip, xra);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "Unable to register gpiochip\n");\r\nreturn ret;\r\n}\r\nspi_set_drvdata(spi, xra);\r\nreturn 0;\r\n}
