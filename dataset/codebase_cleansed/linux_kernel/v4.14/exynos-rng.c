static u32 exynos_rng_readl(struct exynos_rng_dev *rng, u32 offset)\r\n{\r\nreturn readl_relaxed(rng->mem + offset);\r\n}\r\nstatic void exynos_rng_writel(struct exynos_rng_dev *rng, u32 val, u32 offset)\r\n{\r\nwritel_relaxed(val, rng->mem + offset);\r\n}\r\nstatic int exynos_rng_set_seed(struct exynos_rng_dev *rng,\r\nconst u8 *seed, unsigned int slen)\r\n{\r\nu32 val;\r\nint i;\r\nslen = ALIGN_DOWN(slen, 4);\r\nif (slen < EXYNOS_RNG_SEED_SIZE)\r\nreturn -EINVAL;\r\nfor (i = 0; i < slen ; i += 4) {\r\nunsigned int seed_reg = (i / 4) % EXYNOS_RNG_SEED_REGS;\r\nval = seed[i] << 24;\r\nval |= seed[i + 1] << 16;\r\nval |= seed[i + 2] << 8;\r\nval |= seed[i + 3] << 0;\r\nexynos_rng_writel(rng, val, EXYNOS_RNG_SEED(seed_reg));\r\n}\r\nval = exynos_rng_readl(rng, EXYNOS_RNG_STATUS);\r\nif (!(val & EXYNOS_RNG_STATUS_SEED_SETTING_DONE)) {\r\ndev_warn(rng->dev, "Seed setting not finished\n");\r\nreturn -EIO;\r\n}\r\nrng->last_seeding = jiffies;\r\nreturn 0;\r\n}\r\nstatic unsigned int exynos_rng_copy_random(struct exynos_rng_dev *rng,\r\nu8 *dst, unsigned int dlen)\r\n{\r\nunsigned int cnt = 0;\r\nint i, j;\r\nu32 val;\r\nfor (j = 0; j < EXYNOS_RNG_SEED_REGS; j++) {\r\nval = exynos_rng_readl(rng, EXYNOS_RNG_OUT(j));\r\nfor (i = 0; i < 4; i++) {\r\ndst[cnt] = val & 0xff;\r\nval >>= 8;\r\nif (++cnt >= dlen)\r\nreturn cnt;\r\n}\r\n}\r\nreturn cnt;\r\n}\r\nstatic int exynos_rng_get_random(struct exynos_rng_dev *rng,\r\nu8 *dst, unsigned int dlen,\r\nunsigned int *read)\r\n{\r\nint retry = EXYNOS_RNG_WAIT_RETRIES;\r\nexynos_rng_writel(rng, EXYNOS_RNG_CONTROL_START,\r\nEXYNOS_RNG_CONTROL);\r\nwhile (!(exynos_rng_readl(rng,\r\nEXYNOS_RNG_STATUS) & EXYNOS_RNG_STATUS_RNG_DONE) && --retry)\r\ncpu_relax();\r\nif (!retry)\r\nreturn -ETIMEDOUT;\r\nexynos_rng_writel(rng, EXYNOS_RNG_STATUS_RNG_DONE,\r\nEXYNOS_RNG_STATUS);\r\n*read = exynos_rng_copy_random(rng, dst, dlen);\r\nreturn 0;\r\n}\r\nstatic void exynos_rng_reseed(struct exynos_rng_dev *rng)\r\n{\r\nunsigned long next_seeding = rng->last_seeding + \\r\nmsecs_to_jiffies(EXYNOS_RNG_RESEED_TIME);\r\nunsigned long now = jiffies;\r\nunsigned int read = 0;\r\nu8 seed[EXYNOS_RNG_SEED_SIZE];\r\nif (time_before(now, next_seeding))\r\nreturn;\r\nif (exynos_rng_get_random(rng, seed, sizeof(seed), &read))\r\nreturn;\r\nexynos_rng_set_seed(rng, seed, read);\r\n}\r\nstatic int exynos_rng_generate(struct crypto_rng *tfm,\r\nconst u8 *src, unsigned int slen,\r\nu8 *dst, unsigned int dlen)\r\n{\r\nstruct exynos_rng_ctx *ctx = crypto_rng_ctx(tfm);\r\nstruct exynos_rng_dev *rng = ctx->rng;\r\nunsigned int read = 0;\r\nint ret;\r\nret = clk_prepare_enable(rng->clk);\r\nif (ret)\r\nreturn ret;\r\ndo {\r\nret = exynos_rng_get_random(rng, dst, dlen, &read);\r\nif (ret)\r\nbreak;\r\ndlen -= read;\r\ndst += read;\r\nexynos_rng_reseed(rng);\r\n} while (dlen > 0);\r\nclk_disable_unprepare(rng->clk);\r\nreturn ret;\r\n}\r\nstatic int exynos_rng_seed(struct crypto_rng *tfm, const u8 *seed,\r\nunsigned int slen)\r\n{\r\nstruct exynos_rng_ctx *ctx = crypto_rng_ctx(tfm);\r\nstruct exynos_rng_dev *rng = ctx->rng;\r\nint ret;\r\nret = clk_prepare_enable(rng->clk);\r\nif (ret)\r\nreturn ret;\r\nret = exynos_rng_set_seed(ctx->rng, seed, slen);\r\nclk_disable_unprepare(rng->clk);\r\nreturn ret;\r\n}\r\nstatic int exynos_rng_kcapi_init(struct crypto_tfm *tfm)\r\n{\r\nstruct exynos_rng_ctx *ctx = crypto_tfm_ctx(tfm);\r\nctx->rng = exynos_rng_dev;\r\nreturn 0;\r\n}\r\nstatic int exynos_rng_probe(struct platform_device *pdev)\r\n{\r\nstruct exynos_rng_dev *rng;\r\nstruct resource *res;\r\nint ret;\r\nif (exynos_rng_dev)\r\nreturn -EEXIST;\r\nrng = devm_kzalloc(&pdev->dev, sizeof(*rng), GFP_KERNEL);\r\nif (!rng)\r\nreturn -ENOMEM;\r\nrng->dev = &pdev->dev;\r\nrng->clk = devm_clk_get(&pdev->dev, "secss");\r\nif (IS_ERR(rng->clk)) {\r\ndev_err(&pdev->dev, "Couldn't get clock.\n");\r\nreturn PTR_ERR(rng->clk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrng->mem = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(rng->mem))\r\nreturn PTR_ERR(rng->mem);\r\nplatform_set_drvdata(pdev, rng);\r\nexynos_rng_dev = rng;\r\nret = crypto_register_rng(&exynos_rng_alg);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Couldn't register rng crypto alg: %d\n", ret);\r\nexynos_rng_dev = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int exynos_rng_remove(struct platform_device *pdev)\r\n{\r\ncrypto_unregister_rng(&exynos_rng_alg);\r\nexynos_rng_dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused exynos_rng_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct exynos_rng_dev *rng = platform_get_drvdata(pdev);\r\nint ret;\r\nif (!rng->last_seeding)\r\nreturn 0;\r\nrng->seed_save_len = 0;\r\nret = clk_prepare_enable(rng->clk);\r\nif (ret)\r\nreturn ret;\r\nexynos_rng_get_random(rng, rng->seed_save, sizeof(rng->seed_save),\r\n&(rng->seed_save_len));\r\ndev_dbg(rng->dev, "Stored %u bytes for seeding on system resume\n",\r\nrng->seed_save_len);\r\nclk_disable_unprepare(rng->clk);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused exynos_rng_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct exynos_rng_dev *rng = platform_get_drvdata(pdev);\r\nint ret;\r\nif (!rng->last_seeding)\r\nreturn 0;\r\nret = clk_prepare_enable(rng->clk);\r\nif (ret)\r\nreturn ret;\r\nret = exynos_rng_set_seed(rng, rng->seed_save, rng->seed_save_len);\r\nclk_disable_unprepare(rng->clk);\r\nreturn ret;\r\n}
