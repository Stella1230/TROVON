static int n2rng_hv_err_trans(unsigned long hv_err)\r\n{\r\nswitch (hv_err) {\r\ncase HV_EOK:\r\nreturn 0;\r\ncase HV_EWOULDBLOCK:\r\nreturn -EAGAIN;\r\ncase HV_ENOACCESS:\r\nreturn -EPERM;\r\ncase HV_EIO:\r\nreturn -EIO;\r\ncase HV_EBUSY:\r\nreturn -EBUSY;\r\ncase HV_EBADALIGN:\r\ncase HV_ENORADDR:\r\nreturn -EFAULT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic unsigned long n2rng_generic_read_control_v2(unsigned long ra,\r\nunsigned long unit)\r\n{\r\nunsigned long hv_err, state, ticks, watchdog_delta, watchdog_status;\r\nint block = 0, busy = 0;\r\nwhile (1) {\r\nhv_err = sun4v_rng_ctl_read_v2(ra, unit, &state,\r\n&ticks,\r\n&watchdog_delta,\r\n&watchdog_status);\r\nif (hv_err == HV_EOK)\r\nbreak;\r\nif (hv_err == HV_EBUSY) {\r\nif (++busy >= N2RNG_BUSY_LIMIT)\r\nbreak;\r\nudelay(1);\r\n} else if (hv_err == HV_EWOULDBLOCK) {\r\nif (++block >= N2RNG_BLOCK_LIMIT)\r\nbreak;\r\n__delay(ticks);\r\n} else\r\nbreak;\r\n}\r\nreturn hv_err;\r\n}\r\nstatic unsigned long n2rng_control_settle_v2(struct n2rng *np, int unit)\r\n{\r\nunsigned long ra = __pa(&np->scratch_control[0]);\r\nreturn n2rng_generic_read_control_v2(ra, unit);\r\n}\r\nstatic unsigned long n2rng_write_ctl_one(struct n2rng *np, int unit,\r\nunsigned long state,\r\nunsigned long control_ra,\r\nunsigned long watchdog_timeout,\r\nunsigned long *ticks)\r\n{\r\nunsigned long hv_err;\r\nif (np->hvapi_major == 1) {\r\nhv_err = sun4v_rng_ctl_write_v1(control_ra, state,\r\nwatchdog_timeout, ticks);\r\n} else {\r\nhv_err = sun4v_rng_ctl_write_v2(control_ra, state,\r\nwatchdog_timeout, unit);\r\nif (hv_err == HV_EOK)\r\nhv_err = n2rng_control_settle_v2(np, unit);\r\n*ticks = N2RNG_ACCUM_CYCLES_DEFAULT;\r\n}\r\nreturn hv_err;\r\n}\r\nstatic int n2rng_generic_read_data(unsigned long data_ra)\r\n{\r\nunsigned long ticks, hv_err;\r\nint block = 0, hcheck = 0;\r\nwhile (1) {\r\nhv_err = sun4v_rng_data_read(data_ra, &ticks);\r\nif (hv_err == HV_EOK)\r\nreturn 0;\r\nif (hv_err == HV_EWOULDBLOCK) {\r\nif (++block >= N2RNG_BLOCK_LIMIT)\r\nreturn -EWOULDBLOCK;\r\n__delay(ticks);\r\n} else if (hv_err == HV_ENOACCESS) {\r\nreturn -EPERM;\r\n} else if (hv_err == HV_EIO) {\r\nif (++hcheck >= N2RNG_HCHECK_LIMIT)\r\nreturn -EIO;\r\nudelay(10000);\r\n} else\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic unsigned long n2rng_read_diag_data_one(struct n2rng *np,\r\nunsigned long unit,\r\nunsigned long data_ra,\r\nunsigned long data_len,\r\nunsigned long *ticks)\r\n{\r\nunsigned long hv_err;\r\nif (np->hvapi_major == 1) {\r\nhv_err = sun4v_rng_data_read_diag_v1(data_ra, data_len, ticks);\r\n} else {\r\nhv_err = sun4v_rng_data_read_diag_v2(data_ra, data_len,\r\nunit, ticks);\r\nif (!*ticks)\r\n*ticks = N2RNG_ACCUM_CYCLES_DEFAULT;\r\n}\r\nreturn hv_err;\r\n}\r\nstatic int n2rng_generic_read_diag_data(struct n2rng *np,\r\nunsigned long unit,\r\nunsigned long data_ra,\r\nunsigned long data_len)\r\n{\r\nunsigned long ticks, hv_err;\r\nint block = 0;\r\nwhile (1) {\r\nhv_err = n2rng_read_diag_data_one(np, unit,\r\ndata_ra, data_len,\r\n&ticks);\r\nif (hv_err == HV_EOK)\r\nreturn 0;\r\nif (hv_err == HV_EWOULDBLOCK) {\r\nif (++block >= N2RNG_BLOCK_LIMIT)\r\nreturn -EWOULDBLOCK;\r\n__delay(ticks);\r\n} else if (hv_err == HV_ENOACCESS) {\r\nreturn -EPERM;\r\n} else if (hv_err == HV_EIO) {\r\nreturn -EIO;\r\n} else\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic int n2rng_generic_write_control(struct n2rng *np,\r\nunsigned long control_ra,\r\nunsigned long unit,\r\nunsigned long state)\r\n{\r\nunsigned long hv_err, ticks;\r\nint block = 0, busy = 0;\r\nwhile (1) {\r\nhv_err = n2rng_write_ctl_one(np, unit, state, control_ra,\r\nnp->wd_timeo, &ticks);\r\nif (hv_err == HV_EOK)\r\nreturn 0;\r\nif (hv_err == HV_EWOULDBLOCK) {\r\nif (++block >= N2RNG_BLOCK_LIMIT)\r\nreturn -EWOULDBLOCK;\r\n__delay(ticks);\r\n} else if (hv_err == HV_EBUSY) {\r\nif (++busy >= N2RNG_BUSY_LIMIT)\r\nreturn -EBUSY;\r\nudelay(1);\r\n} else\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic int n2rng_try_read_ctl(struct n2rng *np)\r\n{\r\nunsigned long hv_err;\r\nunsigned long x;\r\nif (np->hvapi_major == 1) {\r\nhv_err = sun4v_rng_get_diag_ctl();\r\n} else {\r\nhv_err = sun4v_rng_ctl_read_v2(0UL, ~0UL, &x, &x, &x, &x);\r\nswitch (hv_err) {\r\ncase HV_EWOULDBLOCK:\r\ncase HV_ENOACCESS:\r\nbreak;\r\ndefault:\r\nhv_err = HV_EOK;\r\nbreak;\r\n}\r\n}\r\nreturn n2rng_hv_err_trans(hv_err);\r\n}\r\nstatic u64 n2rng_control_default(struct n2rng *np, int ctl)\r\n{\r\nu64 val = 0;\r\nif (np->data->chip_version == 1) {\r\nval = ((2 << RNG_v1_CTL_ASEL_SHIFT) |\r\n(N2RNG_ACCUM_CYCLES_DEFAULT << RNG_v1_CTL_WAIT_SHIFT) |\r\nRNG_CTL_LFSR);\r\nswitch (ctl) {\r\ncase 0:\r\nval |= (1 << RNG_v1_CTL_VCO_SHIFT) | RNG_CTL_ES1;\r\nbreak;\r\ncase 1:\r\nval |= (2 << RNG_v1_CTL_VCO_SHIFT) | RNG_CTL_ES2;\r\nbreak;\r\ncase 2:\r\nval |= (3 << RNG_v1_CTL_VCO_SHIFT) | RNG_CTL_ES3;\r\nbreak;\r\ncase 3:\r\nval |= RNG_CTL_ES1 | RNG_CTL_ES2 | RNG_CTL_ES3;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nval = ((2 << RNG_v2_CTL_ASEL_SHIFT) |\r\n(N2RNG_ACCUM_CYCLES_DEFAULT << RNG_v2_CTL_WAIT_SHIFT) |\r\nRNG_CTL_LFSR);\r\nswitch (ctl) {\r\ncase 0:\r\nval |= (1 << RNG_v2_CTL_VCO_SHIFT) | RNG_CTL_ES1;\r\nbreak;\r\ncase 1:\r\nval |= (2 << RNG_v2_CTL_VCO_SHIFT) | RNG_CTL_ES2;\r\nbreak;\r\ncase 2:\r\nval |= (3 << RNG_v2_CTL_VCO_SHIFT) | RNG_CTL_ES3;\r\nbreak;\r\ncase 3:\r\nval |= RNG_CTL_ES1 | RNG_CTL_ES2 | RNG_CTL_ES3;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn val;\r\n}\r\nstatic void n2rng_control_swstate_init(struct n2rng *np)\r\n{\r\nint i;\r\nnp->flags |= N2RNG_FLAG_CONTROL;\r\nnp->health_check_sec = N2RNG_HEALTH_CHECK_SEC_DEFAULT;\r\nnp->accum_cycles = N2RNG_ACCUM_CYCLES_DEFAULT;\r\nnp->wd_timeo = N2RNG_WD_TIMEO_DEFAULT;\r\nfor (i = 0; i < np->num_units; i++) {\r\nstruct n2rng_unit *up = &np->units[i];\r\nup->control[0] = n2rng_control_default(np, 0);\r\nup->control[1] = n2rng_control_default(np, 1);\r\nup->control[2] = n2rng_control_default(np, 2);\r\nup->control[3] = n2rng_control_default(np, 3);\r\n}\r\nnp->hv_state = HV_RNG_STATE_UNCONFIGURED;\r\n}\r\nstatic int n2rng_grab_diag_control(struct n2rng *np)\r\n{\r\nint i, busy_count, err = -ENODEV;\r\nbusy_count = 0;\r\nfor (i = 0; i < 100; i++) {\r\nerr = n2rng_try_read_ctl(np);\r\nif (err != -EAGAIN)\r\nbreak;\r\nif (++busy_count > 100) {\r\ndev_err(&np->op->dev,\r\n"Grab diag control timeout.\n");\r\nreturn -ENODEV;\r\n}\r\nudelay(1);\r\n}\r\nreturn err;\r\n}\r\nstatic int n2rng_init_control(struct n2rng *np)\r\n{\r\nint err = n2rng_grab_diag_control(np);\r\nif (err == -EPERM)\r\nreturn 0;\r\nif (err)\r\nreturn err;\r\nn2rng_control_swstate_init(np);\r\nreturn 0;\r\n}\r\nstatic int n2rng_data_read(struct hwrng *rng, u32 *data)\r\n{\r\nstruct n2rng *np = (struct n2rng *) rng->priv;\r\nunsigned long ra = __pa(&np->test_data);\r\nint len;\r\nif (!(np->flags & N2RNG_FLAG_READY)) {\r\nlen = 0;\r\n} else if (np->flags & N2RNG_FLAG_BUFFER_VALID) {\r\nnp->flags &= ~N2RNG_FLAG_BUFFER_VALID;\r\n*data = np->buffer;\r\nlen = 4;\r\n} else {\r\nint err = n2rng_generic_read_data(ra);\r\nif (!err) {\r\nnp->flags |= N2RNG_FLAG_BUFFER_VALID;\r\nnp->buffer = np->test_data >> 32;\r\n*data = np->test_data & 0xffffffff;\r\nlen = 4;\r\n} else {\r\ndev_err(&np->op->dev, "RNG error, restesting\n");\r\nnp->flags &= ~N2RNG_FLAG_READY;\r\nif (!(np->flags & N2RNG_FLAG_SHUTDOWN))\r\nschedule_delayed_work(&np->work, 0);\r\nlen = 0;\r\n}\r\n}\r\nreturn len;\r\n}\r\nstatic int n2rng_guest_check(struct n2rng *np)\r\n{\r\nunsigned long ra = __pa(&np->test_data);\r\nreturn n2rng_generic_read_data(ra);\r\n}\r\nstatic int n2rng_entropy_diag_read(struct n2rng *np, unsigned long unit,\r\nu64 *pre_control, u64 pre_state,\r\nu64 *buffer, unsigned long buf_len,\r\nu64 *post_control, u64 post_state)\r\n{\r\nunsigned long post_ctl_ra = __pa(post_control);\r\nunsigned long pre_ctl_ra = __pa(pre_control);\r\nunsigned long buffer_ra = __pa(buffer);\r\nint err;\r\nerr = n2rng_generic_write_control(np, pre_ctl_ra, unit, pre_state);\r\nif (err)\r\nreturn err;\r\nerr = n2rng_generic_read_diag_data(np, unit,\r\nbuffer_ra, buf_len);\r\n(void) n2rng_generic_write_control(np, post_ctl_ra, unit,\r\npost_state);\r\nreturn err;\r\n}\r\nstatic u64 advance_polynomial(u64 poly, u64 val, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nint highbit_set = ((s64)val < 0);\r\nval <<= 1;\r\nif (highbit_set)\r\nval ^= poly;\r\n}\r\nreturn val;\r\n}\r\nstatic int n2rng_test_buffer_find(struct n2rng *np, u64 val)\r\n{\r\nint i, count = 0;\r\nfor (i = 1; i < SELFTEST_BUFFER_WORDS; i++) {\r\nif (np->test_buffer[i] == val)\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic void n2rng_dump_test_buffer(struct n2rng *np)\r\n{\r\nint i;\r\nfor (i = 0; i < SELFTEST_BUFFER_WORDS; i++)\r\ndev_err(&np->op->dev, "Test buffer slot %d [0x%016llx]\n",\r\ni, np->test_buffer[i]);\r\n}\r\nstatic int n2rng_check_selftest_buffer(struct n2rng *np, unsigned long unit)\r\n{\r\nu64 val;\r\nint err, matches, limit;\r\nswitch (np->data->id) {\r\ncase N2_n2_rng:\r\ncase N2_vf_rng:\r\ncase N2_kt_rng:\r\ncase N2_m4_rng:\r\nval = RNG_v1_SELFTEST_VAL;\r\nbreak;\r\ndefault:\r\nval = RNG_v2_SELFTEST_VAL;\r\nbreak;\r\n}\r\nmatches = 0;\r\nfor (limit = 0; limit < SELFTEST_LOOPS_MAX; limit++) {\r\nmatches += n2rng_test_buffer_find(np, val);\r\nif (matches >= SELFTEST_MATCH_GOAL)\r\nbreak;\r\nval = advance_polynomial(SELFTEST_POLY, val, 1);\r\n}\r\nerr = 0;\r\nif (limit >= SELFTEST_LOOPS_MAX) {\r\nerr = -ENODEV;\r\ndev_err(&np->op->dev, "Selftest failed on unit %lu\n", unit);\r\nn2rng_dump_test_buffer(np);\r\n} else\r\ndev_info(&np->op->dev, "Selftest passed on unit %lu\n", unit);\r\nreturn err;\r\n}\r\nstatic int n2rng_control_selftest(struct n2rng *np, unsigned long unit)\r\n{\r\nint err;\r\nu64 base, base3;\r\nswitch (np->data->id) {\r\ncase N2_n2_rng:\r\ncase N2_vf_rng:\r\ncase N2_kt_rng:\r\nbase = RNG_v1_CTL_ASEL_NOOUT << RNG_v1_CTL_ASEL_SHIFT;\r\nbase3 = base | RNG_CTL_LFSR |\r\n((RNG_v1_SELFTEST_TICKS - 2) << RNG_v1_CTL_WAIT_SHIFT);\r\nbreak;\r\ncase N2_m4_rng:\r\nbase = RNG_v2_CTL_ASEL_NOOUT << RNG_v2_CTL_ASEL_SHIFT;\r\nbase3 = base | RNG_CTL_LFSR |\r\n((RNG_v1_SELFTEST_TICKS - 2) << RNG_v2_CTL_WAIT_SHIFT);\r\nbreak;\r\ndefault:\r\nbase = RNG_v2_CTL_ASEL_NOOUT << RNG_v2_CTL_ASEL_SHIFT;\r\nbase3 = base | RNG_CTL_LFSR |\r\n(RNG_v2_SELFTEST_TICKS << RNG_v2_CTL_WAIT_SHIFT);\r\nbreak;\r\n}\r\nnp->test_control[0] = base;\r\nnp->test_control[1] = base;\r\nnp->test_control[2] = base;\r\nnp->test_control[3] = base3;\r\nerr = n2rng_entropy_diag_read(np, unit, np->test_control,\r\nHV_RNG_STATE_HEALTHCHECK,\r\nnp->test_buffer,\r\nsizeof(np->test_buffer),\r\n&np->units[unit].control[0],\r\nnp->hv_state);\r\nif (err)\r\nreturn err;\r\nreturn n2rng_check_selftest_buffer(np, unit);\r\n}\r\nstatic int n2rng_control_check(struct n2rng *np)\r\n{\r\nint i;\r\nfor (i = 0; i < np->num_units; i++) {\r\nint err = n2rng_control_selftest(np, i);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int n2rng_control_configure_units(struct n2rng *np)\r\n{\r\nint unit, err;\r\nerr = 0;\r\nfor (unit = 0; unit < np->num_units; unit++) {\r\nstruct n2rng_unit *up = &np->units[unit];\r\nunsigned long ctl_ra = __pa(&up->control[0]);\r\nint esrc;\r\nu64 base, shift;\r\nif (np->data->chip_version == 1) {\r\nbase = ((np->accum_cycles << RNG_v1_CTL_WAIT_SHIFT) |\r\n(RNG_v1_CTL_ASEL_NOOUT << RNG_v1_CTL_ASEL_SHIFT) |\r\nRNG_CTL_LFSR);\r\nshift = RNG_v1_CTL_VCO_SHIFT;\r\n} else {\r\nbase = ((np->accum_cycles << RNG_v2_CTL_WAIT_SHIFT) |\r\n(RNG_v2_CTL_ASEL_NOOUT << RNG_v2_CTL_ASEL_SHIFT) |\r\nRNG_CTL_LFSR);\r\nshift = RNG_v2_CTL_VCO_SHIFT;\r\n}\r\nfor (esrc = 0; esrc < 3; esrc++)\r\nup->control[esrc] = base |\r\n(esrc << shift) |\r\n(RNG_CTL_ES1 << esrc);\r\nup->control[3] = base |\r\n(RNG_CTL_ES1 | RNG_CTL_ES2 | RNG_CTL_ES3);\r\nerr = n2rng_generic_write_control(np, ctl_ra, unit,\r\nHV_RNG_STATE_CONFIGURED);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic void n2rng_work(struct work_struct *work)\r\n{\r\nstruct n2rng *np = container_of(work, struct n2rng, work.work);\r\nint err = 0;\r\nstatic int retries = 4;\r\nif (!(np->flags & N2RNG_FLAG_CONTROL)) {\r\nerr = n2rng_guest_check(np);\r\n} else {\r\npreempt_disable();\r\nerr = n2rng_control_check(np);\r\npreempt_enable();\r\nif (!err)\r\nerr = n2rng_control_configure_units(np);\r\n}\r\nif (!err) {\r\nnp->flags |= N2RNG_FLAG_READY;\r\ndev_info(&np->op->dev, "RNG ready\n");\r\n}\r\nif (--retries == 0)\r\ndev_err(&np->op->dev, "Self-test retries failed, RNG not ready\n");\r\nelse if (err && !(np->flags & N2RNG_FLAG_SHUTDOWN))\r\nschedule_delayed_work(&np->work, HZ * 2);\r\n}\r\nstatic void n2rng_driver_version(void)\r\n{\r\nstatic int n2rng_version_printed;\r\nif (n2rng_version_printed++ == 0)\r\npr_info("%s", version);\r\n}\r\nstatic int n2rng_probe(struct platform_device *op)\r\n{\r\nconst struct of_device_id *match;\r\nint err = -ENOMEM;\r\nstruct n2rng *np;\r\nmatch = of_match_device(n2rng_match, &op->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nn2rng_driver_version();\r\nnp = devm_kzalloc(&op->dev, sizeof(*np), GFP_KERNEL);\r\nif (!np)\r\ngoto out;\r\nnp->op = op;\r\nnp->data = (struct n2rng_template *)match->data;\r\nINIT_DELAYED_WORK(&np->work, n2rng_work);\r\nif (np->data->multi_capable)\r\nnp->flags |= N2RNG_FLAG_MULTI;\r\nerr = -ENODEV;\r\nnp->hvapi_major = 2;\r\nif (sun4v_hvapi_register(HV_GRP_RNG,\r\nnp->hvapi_major,\r\n&np->hvapi_minor)) {\r\nnp->hvapi_major = 1;\r\nif (sun4v_hvapi_register(HV_GRP_RNG,\r\nnp->hvapi_major,\r\n&np->hvapi_minor)) {\r\ndev_err(&op->dev, "Cannot register suitable "\r\n"HVAPI version.\n");\r\ngoto out;\r\n}\r\n}\r\nif (np->flags & N2RNG_FLAG_MULTI) {\r\nif (np->hvapi_major < 2) {\r\ndev_err(&op->dev, "multi-unit-capable RNG requires "\r\n"HVAPI major version 2 or later, got %lu\n",\r\nnp->hvapi_major);\r\ngoto out_hvapi_unregister;\r\n}\r\nnp->num_units = of_getintprop_default(op->dev.of_node,\r\n"rng-#units", 0);\r\nif (!np->num_units) {\r\ndev_err(&op->dev, "VF RNG lacks rng-#units property\n");\r\ngoto out_hvapi_unregister;\r\n}\r\n} else {\r\nnp->num_units = 1;\r\n}\r\ndev_info(&op->dev, "Registered RNG HVAPI major %lu minor %lu\n",\r\nnp->hvapi_major, np->hvapi_minor);\r\nnp->units = devm_kcalloc(&op->dev, np->num_units, sizeof(*np->units),\r\nGFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!np->units)\r\ngoto out_hvapi_unregister;\r\nerr = n2rng_init_control(np);\r\nif (err)\r\ngoto out_hvapi_unregister;\r\ndev_info(&op->dev, "Found %s RNG, units: %d\n",\r\n((np->flags & N2RNG_FLAG_MULTI) ?\r\n"multi-unit-capable" : "single-unit"),\r\nnp->num_units);\r\nnp->hwrng.name = DRV_MODULE_NAME;\r\nnp->hwrng.data_read = n2rng_data_read;\r\nnp->hwrng.priv = (unsigned long) np;\r\nerr = hwrng_register(&np->hwrng);\r\nif (err)\r\ngoto out_hvapi_unregister;\r\nplatform_set_drvdata(op, np);\r\nschedule_delayed_work(&np->work, 0);\r\nreturn 0;\r\nout_hvapi_unregister:\r\nsun4v_hvapi_unregister(HV_GRP_RNG);\r\nout:\r\nreturn err;\r\n}\r\nstatic int n2rng_remove(struct platform_device *op)\r\n{\r\nstruct n2rng *np = platform_get_drvdata(op);\r\nnp->flags |= N2RNG_FLAG_SHUTDOWN;\r\ncancel_delayed_work_sync(&np->work);\r\nhwrng_unregister(&np->hwrng);\r\nsun4v_hvapi_unregister(HV_GRP_RNG);\r\nreturn 0;\r\n}
