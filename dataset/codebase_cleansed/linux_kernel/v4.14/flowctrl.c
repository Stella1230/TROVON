static void flowctrl_update(u8 offset, u32 value)\r\n{\r\nif (WARN_ONCE(IS_ERR_OR_NULL(tegra_flowctrl_base),\r\n"Tegra flowctrl not initialised!\n"))\r\nreturn;\r\nwritel(value, tegra_flowctrl_base + offset);\r\nwmb();\r\nreadl_relaxed(tegra_flowctrl_base + offset);\r\n}\r\nu32 flowctrl_read_cpu_csr(unsigned int cpuid)\r\n{\r\nu8 offset = flowctrl_offset_cpu_csr[cpuid];\r\nif (WARN_ONCE(IS_ERR_OR_NULL(tegra_flowctrl_base),\r\n"Tegra flowctrl not initialised!\n"))\r\nreturn 0;\r\nreturn readl(tegra_flowctrl_base + offset);\r\n}\r\nvoid flowctrl_write_cpu_csr(unsigned int cpuid, u32 value)\r\n{\r\nreturn flowctrl_update(flowctrl_offset_cpu_csr[cpuid], value);\r\n}\r\nvoid flowctrl_write_cpu_halt(unsigned int cpuid, u32 value)\r\n{\r\nreturn flowctrl_update(flowctrl_offset_halt_cpu[cpuid], value);\r\n}\r\nvoid flowctrl_cpu_suspend_enter(unsigned int cpuid)\r\n{\r\nunsigned int reg;\r\nint i;\r\nreg = flowctrl_read_cpu_csr(cpuid);\r\nswitch (tegra_get_chip_id()) {\r\ncase TEGRA20:\r\nreg &= ~TEGRA20_FLOW_CTRL_CSR_WFE_BITMAP;\r\nreg &= ~TEGRA20_FLOW_CTRL_CSR_WFI_BITMAP;\r\nreg |= TEGRA20_FLOW_CTRL_CSR_WFE_CPU0 << cpuid;\r\nbreak;\r\ncase TEGRA30:\r\ncase TEGRA114:\r\ncase TEGRA124:\r\nreg &= ~TEGRA30_FLOW_CTRL_CSR_WFE_BITMAP;\r\nreg &= ~TEGRA30_FLOW_CTRL_CSR_WFI_BITMAP;\r\nreg |= TEGRA30_FLOW_CTRL_CSR_WFI_CPU0 << cpuid;\r\nbreak;\r\n}\r\nreg |= FLOW_CTRL_CSR_INTR_FLAG;\r\nreg |= FLOW_CTRL_CSR_EVENT_FLAG;\r\nreg |= FLOW_CTRL_CSR_ENABLE;\r\nflowctrl_write_cpu_csr(cpuid, reg);\r\nfor (i = 0; i < num_possible_cpus(); i++) {\r\nif (i == cpuid)\r\ncontinue;\r\nreg = flowctrl_read_cpu_csr(i);\r\nreg |= FLOW_CTRL_CSR_EVENT_FLAG;\r\nreg |= FLOW_CTRL_CSR_INTR_FLAG;\r\nflowctrl_write_cpu_csr(i, reg);\r\n}\r\n}\r\nvoid flowctrl_cpu_suspend_exit(unsigned int cpuid)\r\n{\r\nunsigned int reg;\r\nreg = flowctrl_read_cpu_csr(cpuid);\r\nswitch (tegra_get_chip_id()) {\r\ncase TEGRA20:\r\nreg &= ~TEGRA20_FLOW_CTRL_CSR_WFE_BITMAP;\r\nreg &= ~TEGRA20_FLOW_CTRL_CSR_WFI_BITMAP;\r\nbreak;\r\ncase TEGRA30:\r\ncase TEGRA114:\r\ncase TEGRA124:\r\nreg &= ~TEGRA30_FLOW_CTRL_CSR_WFE_BITMAP;\r\nreg &= ~TEGRA30_FLOW_CTRL_CSR_WFI_BITMAP;\r\nbreak;\r\n}\r\nreg &= ~FLOW_CTRL_CSR_ENABLE;\r\nreg |= FLOW_CTRL_CSR_INTR_FLAG;\r\nreg |= FLOW_CTRL_CSR_EVENT_FLAG;\r\nflowctrl_write_cpu_csr(cpuid, reg);\r\n}\r\nstatic int tegra_flowctrl_probe(struct platform_device *pdev)\r\n{\r\nvoid __iomem *base = tegra_flowctrl_base;\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntegra_flowctrl_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(tegra_flowctrl_base))\r\nreturn PTR_ERR(tegra_flowctrl_base);\r\niounmap(base);\r\nreturn 0;\r\n}\r\nstatic int __init tegra_flowctrl_init(void)\r\n{\r\nstruct resource res;\r\nstruct device_node *np;\r\nif (!soc_is_tegra())\r\nreturn 0;\r\nnp = of_find_matching_node(NULL, tegra_flowctrl_match);\r\nif (np) {\r\nif (of_address_to_resource(np, 0, &res) < 0) {\r\npr_err("failed to get flowctrl register\n");\r\nreturn -ENXIO;\r\n}\r\nof_node_put(np);\r\n} else if (IS_ENABLED(CONFIG_ARM)) {\r\nres.start = 0x60007000;\r\nres.end = 0x60007fff;\r\nres.flags = IORESOURCE_MEM;\r\n} else {\r\nreturn 0;\r\n}\r\ntegra_flowctrl_base = ioremap_nocache(res.start, resource_size(&res));\r\nif (!tegra_flowctrl_base)\r\nreturn -ENXIO;\r\nreturn 0;\r\n}
