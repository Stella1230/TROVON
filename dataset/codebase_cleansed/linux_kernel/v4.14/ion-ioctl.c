static int validate_ioctl_arg(unsigned int cmd, union ion_ioctl_arg *arg)\r\n{\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase ION_IOC_HEAP_QUERY:\r\nret = arg->query.reserved0 != 0;\r\nret |= arg->query.reserved1 != 0;\r\nret |= arg->query.reserved2 != 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret ? -EINVAL : 0;\r\n}\r\nstatic unsigned int ion_ioctl_dir(unsigned int cmd)\r\n{\r\nswitch (cmd) {\r\ndefault:\r\nreturn _IOC_DIR(cmd);\r\n}\r\n}\r\nlong ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nint ret = 0;\r\nunsigned int dir;\r\nunion ion_ioctl_arg data;\r\ndir = ion_ioctl_dir(cmd);\r\nif (_IOC_SIZE(cmd) > sizeof(data))\r\nreturn -EINVAL;\r\nif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\r\nreturn -EFAULT;\r\nret = validate_ioctl_arg(cmd, &data);\r\nif (WARN_ON_ONCE(ret))\r\nreturn ret;\r\nif (!(dir & _IOC_WRITE))\r\nmemset(&data, 0, sizeof(data));\r\nswitch (cmd) {\r\ncase ION_IOC_ALLOC:\r\n{\r\nint fd;\r\nfd = ion_alloc(data.allocation.len,\r\ndata.allocation.heap_id_mask,\r\ndata.allocation.flags);\r\nif (fd < 0)\r\nreturn fd;\r\ndata.allocation.fd = fd;\r\nbreak;\r\n}\r\ncase ION_IOC_HEAP_QUERY:\r\nret = ion_query_heaps(&data.query);\r\nbreak;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nif (dir & _IOC_READ) {\r\nif (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd)))\r\nreturn -EFAULT;\r\n}\r\nreturn ret;\r\n}
