static bool is_f54_report_type_valid(struct f54_data *f54,\r\nenum rmi_f54_report_type reptype)\r\n{\r\nswitch (reptype) {\r\ncase F54_8BIT_IMAGE:\r\nreturn f54->capabilities & F54_CAP_IMAGE8;\r\ncase F54_16BIT_IMAGE:\r\ncase F54_RAW_16BIT_IMAGE:\r\nreturn f54->capabilities & F54_CAP_IMAGE16;\r\ncase F54_TRUE_BASELINE:\r\nreturn f54->capabilities & F54_CAP_IMAGE16;\r\ncase F54_FULL_RAW_CAP:\r\ncase F54_FULL_RAW_CAP_RX_OFFSET_REMOVED:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic enum rmi_f54_report_type rmi_f54_get_reptype(struct f54_data *f54,\r\nunsigned int i)\r\n{\r\nif (i >= F54_MAX_REPORT_TYPE)\r\nreturn F54_REPORT_NONE;\r\nreturn f54->inputs[i];\r\n}\r\nstatic void rmi_f54_create_input_map(struct f54_data *f54)\r\n{\r\nint i = 0;\r\nenum rmi_f54_report_type reptype;\r\nfor (reptype = 1; reptype < F54_MAX_REPORT_TYPE; reptype++) {\r\nif (!is_f54_report_type_valid(f54, reptype))\r\ncontinue;\r\nf54->inputs[i++] = reptype;\r\n}\r\n}\r\nstatic int rmi_f54_request_report(struct rmi_function *fn, u8 report_type)\r\n{\r\nstruct f54_data *f54 = dev_get_drvdata(&fn->dev);\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nint error;\r\nif (f54->report_type != report_type) {\r\nerror = rmi_write(rmi_dev, f54->fn->fd.data_base_addr,\r\nreport_type);\r\nif (error)\r\nreturn error;\r\nf54->report_type = report_type;\r\n}\r\nusleep_range(2000, 3000);\r\nmutex_lock(&f54->data_mutex);\r\nerror = rmi_write(rmi_dev, fn->fd.command_base_addr, F54_GET_REPORT);\r\nif (error < 0)\r\ngoto unlock;\r\ninit_completion(&f54->cmd_done);\r\nf54->is_busy = 1;\r\nf54->timeout = jiffies + msecs_to_jiffies(100);\r\nqueue_delayed_work(f54->workqueue, &f54->work, 0);\r\nunlock:\r\nmutex_unlock(&f54->data_mutex);\r\nreturn error;\r\n}\r\nstatic size_t rmi_f54_get_report_size(struct f54_data *f54)\r\n{\r\nstruct rmi_device *rmi_dev = f54->fn->rmi_dev;\r\nstruct rmi_driver_data *drv_data = dev_get_drvdata(&rmi_dev->dev);\r\nu8 rx = drv_data->num_rx_electrodes ? : f54->num_rx_electrodes;\r\nu8 tx = drv_data->num_tx_electrodes ? : f54->num_tx_electrodes;\r\nsize_t size;\r\nswitch (rmi_f54_get_reptype(f54, f54->input)) {\r\ncase F54_8BIT_IMAGE:\r\nsize = rx * tx;\r\nbreak;\r\ncase F54_16BIT_IMAGE:\r\ncase F54_RAW_16BIT_IMAGE:\r\ncase F54_TRUE_BASELINE:\r\ncase F54_FULL_RAW_CAP:\r\ncase F54_FULL_RAW_CAP_RX_OFFSET_REMOVED:\r\nsize = sizeof(u16) * rx * tx;\r\nbreak;\r\ndefault:\r\nsize = 0;\r\n}\r\nreturn size;\r\n}\r\nstatic int rmi_f54_get_pixel_fmt(enum rmi_f54_report_type reptype, u32 *pixfmt)\r\n{\r\nint ret = 0;\r\nswitch (reptype) {\r\ncase F54_8BIT_IMAGE:\r\n*pixfmt = V4L2_TCH_FMT_DELTA_TD08;\r\nbreak;\r\ncase F54_16BIT_IMAGE:\r\n*pixfmt = V4L2_TCH_FMT_DELTA_TD16;\r\nbreak;\r\ncase F54_RAW_16BIT_IMAGE:\r\ncase F54_TRUE_BASELINE:\r\ncase F54_FULL_RAW_CAP:\r\ncase F54_FULL_RAW_CAP_RX_OFFSET_REMOVED:\r\n*pixfmt = V4L2_TCH_FMT_TU16;\r\nbreak;\r\ncase F54_REPORT_NONE:\r\ncase F54_MAX_REPORT_TYPE:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rmi_f54_queue_setup(struct vb2_queue *q, unsigned int *nbuffers,\r\nunsigned int *nplanes, unsigned int sizes[],\r\nstruct device *alloc_devs[])\r\n{\r\nstruct f54_data *f54 = q->drv_priv;\r\nif (*nplanes)\r\nreturn sizes[0] < rmi_f54_get_report_size(f54) ? -EINVAL : 0;\r\n*nplanes = 1;\r\nsizes[0] = rmi_f54_get_report_size(f54);\r\nreturn 0;\r\n}\r\nstatic void rmi_f54_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct f54_data *f54 = vb2_get_drv_priv(vb->vb2_queue);\r\nu16 *ptr;\r\nenum vb2_buffer_state state;\r\nenum rmi_f54_report_type reptype;\r\nint ret;\r\nmutex_lock(&f54->status_mutex);\r\nreptype = rmi_f54_get_reptype(f54, f54->input);\r\nif (reptype == F54_REPORT_NONE) {\r\nstate = VB2_BUF_STATE_ERROR;\r\ngoto done;\r\n}\r\nif (f54->is_busy) {\r\nstate = VB2_BUF_STATE_ERROR;\r\ngoto done;\r\n}\r\nret = rmi_f54_request_report(f54->fn, reptype);\r\nif (ret) {\r\ndev_err(&f54->fn->dev, "Error requesting F54 report\n");\r\nstate = VB2_BUF_STATE_ERROR;\r\ngoto done;\r\n}\r\nmutex_lock(&f54->data_mutex);\r\nwhile (f54->is_busy) {\r\nmutex_unlock(&f54->data_mutex);\r\nif (!wait_for_completion_timeout(&f54->cmd_done,\r\nmsecs_to_jiffies(1000))) {\r\ndev_err(&f54->fn->dev, "Timed out\n");\r\nstate = VB2_BUF_STATE_ERROR;\r\ngoto done;\r\n}\r\nmutex_lock(&f54->data_mutex);\r\n}\r\nptr = vb2_plane_vaddr(vb, 0);\r\nif (!ptr) {\r\ndev_err(&f54->fn->dev, "Error acquiring frame ptr\n");\r\nstate = VB2_BUF_STATE_ERROR;\r\ngoto data_done;\r\n}\r\nmemcpy(ptr, f54->report_data, f54->report_size);\r\nvb2_set_plane_payload(vb, 0, rmi_f54_get_report_size(f54));\r\nstate = VB2_BUF_STATE_DONE;\r\ndata_done:\r\nmutex_unlock(&f54->data_mutex);\r\ndone:\r\nvb2_buffer_done(vb, state);\r\nmutex_unlock(&f54->status_mutex);\r\n}\r\nstatic int rmi_f54_vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct f54_data *f54 = video_drvdata(file);\r\nstrlcpy(cap->driver, F54_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, SYNAPTICS_INPUT_DEVICE_NAME, sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info),\r\n"rmi4:%s", dev_name(&f54->fn->dev));\r\nreturn 0;\r\n}\r\nstatic int rmi_f54_vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct f54_data *f54 = video_drvdata(file);\r\nenum rmi_f54_report_type reptype;\r\nreptype = rmi_f54_get_reptype(f54, i->index);\r\nif (reptype == F54_REPORT_NONE)\r\nreturn -EINVAL;\r\ni->type = V4L2_INPUT_TYPE_TOUCH;\r\nstrlcpy(i->name, rmi_f54_report_type_names[reptype], sizeof(i->name));\r\nreturn 0;\r\n}\r\nstatic int rmi_f54_set_input(struct f54_data *f54, unsigned int i)\r\n{\r\nstruct rmi_device *rmi_dev = f54->fn->rmi_dev;\r\nstruct rmi_driver_data *drv_data = dev_get_drvdata(&rmi_dev->dev);\r\nu8 rx = drv_data->num_rx_electrodes ? : f54->num_rx_electrodes;\r\nu8 tx = drv_data->num_tx_electrodes ? : f54->num_tx_electrodes;\r\nstruct v4l2_pix_format *f = &f54->format;\r\nenum rmi_f54_report_type reptype;\r\nint ret;\r\nreptype = rmi_f54_get_reptype(f54, i);\r\nif (reptype == F54_REPORT_NONE)\r\nreturn -EINVAL;\r\nret = rmi_f54_get_pixel_fmt(reptype, &f->pixelformat);\r\nif (ret)\r\nreturn ret;\r\nf54->input = i;\r\nf->width = rx;\r\nf->height = tx;\r\nf->field = V4L2_FIELD_NONE;\r\nf->colorspace = V4L2_COLORSPACE_RAW;\r\nf->bytesperline = f->width * sizeof(u16);\r\nf->sizeimage = f->width * f->height * sizeof(u16);\r\nreturn 0;\r\n}\r\nstatic int rmi_f54_vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nreturn rmi_f54_set_input(video_drvdata(file), i);\r\n}\r\nstatic int rmi_f54_vidioc_g_input(struct file *file, void *priv,\r\nunsigned int *i)\r\n{\r\nstruct f54_data *f54 = video_drvdata(file);\r\n*i = f54->input;\r\nreturn 0;\r\n}\r\nstatic int rmi_f54_vidioc_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct f54_data *f54 = video_drvdata(file);\r\nf->fmt.pix = f54->format;\r\nreturn 0;\r\n}\r\nstatic int rmi_f54_vidioc_enum_fmt(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nif (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nswitch (fmt->index) {\r\ncase 0:\r\nfmt->pixelformat = V4L2_TCH_FMT_DELTA_TD16;\r\nbreak;\r\ncase 1:\r\nfmt->pixelformat = V4L2_TCH_FMT_DELTA_TD08;\r\nbreak;\r\ncase 2:\r\nfmt->pixelformat = V4L2_TCH_FMT_TU16;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f54_vidioc_g_parm(struct file *file, void *fh,\r\nstruct v4l2_streamparm *a)\r\n{\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\na->parm.capture.readbuffers = 1;\r\na->parm.capture.timeperframe.numerator = 1;\r\na->parm.capture.timeperframe.denominator = 10;\r\nreturn 0;\r\n}\r\nstatic void rmi_f54_work(struct work_struct *work)\r\n{\r\nstruct f54_data *f54 = container_of(work, struct f54_data, work.work);\r\nstruct rmi_function *fn = f54->fn;\r\nu8 fifo[2];\r\nstruct rmi_f54_reports *report;\r\nint report_size;\r\nu8 command;\r\nu8 *data;\r\nint error;\r\ndata = f54->report_data;\r\nreport_size = rmi_f54_get_report_size(f54);\r\nif (report_size == 0) {\r\ndev_err(&fn->dev, "Bad report size, report type=%d\n",\r\nf54->report_type);\r\nerror = -EINVAL;\r\ngoto error;\r\n}\r\nf54->standard_report[0].size = report_size;\r\nreport = f54->standard_report;\r\nmutex_lock(&f54->data_mutex);\r\nerror = rmi_read(fn->rmi_dev, f54->fn->fd.command_base_addr,\r\n&command);\r\nif (error) {\r\ndev_err(&fn->dev, "Failed to read back command\n");\r\ngoto error;\r\n}\r\nif (command & F54_GET_REPORT) {\r\nif (time_after(jiffies, f54->timeout)) {\r\ndev_err(&fn->dev, "Get report command timed out\n");\r\nerror = -ETIMEDOUT;\r\n}\r\nreport_size = 0;\r\ngoto error;\r\n}\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev, "Get report command completed, reading data\n");\r\nreport_size = 0;\r\nfor (; report->size; report++) {\r\nfifo[0] = report->start & 0xff;\r\nfifo[1] = (report->start >> 8) & 0xff;\r\nerror = rmi_write_block(fn->rmi_dev,\r\nfn->fd.data_base_addr + F54_FIFO_OFFSET,\r\nfifo, sizeof(fifo));\r\nif (error) {\r\ndev_err(&fn->dev, "Failed to set fifo start offset\n");\r\ngoto abort;\r\n}\r\nerror = rmi_read_block(fn->rmi_dev, fn->fd.data_base_addr +\r\nF54_REPORT_DATA_OFFSET, data,\r\nreport->size);\r\nif (error) {\r\ndev_err(&fn->dev, "%s: read [%d bytes] returned %d\n",\r\n__func__, report->size, error);\r\ngoto abort;\r\n}\r\ndata += report->size;\r\nreport_size += report->size;\r\n}\r\nabort:\r\nf54->report_size = error ? 0 : report_size;\r\nerror:\r\nif (error)\r\nreport_size = 0;\r\nif (report_size == 0 && !error) {\r\nqueue_delayed_work(f54->workqueue, &f54->work,\r\nmsecs_to_jiffies(1));\r\n} else {\r\nf54->is_busy = false;\r\ncomplete(&f54->cmd_done);\r\n}\r\nmutex_unlock(&f54->data_mutex);\r\n}\r\nstatic int rmi_f54_attention(struct rmi_function *fn, unsigned long *irqbits)\r\n{\r\nreturn 0;\r\n}\r\nstatic int rmi_f54_config(struct rmi_function *fn)\r\n{\r\nstruct rmi_driver *drv = fn->rmi_dev->driver;\r\ndrv->set_irq_bits(fn->rmi_dev, fn->irq_mask);\r\nreturn 0;\r\n}\r\nstatic int rmi_f54_detect(struct rmi_function *fn)\r\n{\r\nint error;\r\nstruct f54_data *f54;\r\nu8 buf[6];\r\nf54 = dev_get_drvdata(&fn->dev);\r\nerror = rmi_read_block(fn->rmi_dev, fn->fd.query_base_addr,\r\nbuf, sizeof(buf));\r\nif (error) {\r\ndev_err(&fn->dev, "%s: Failed to query F54 properties\n",\r\n__func__);\r\nreturn error;\r\n}\r\nf54->num_rx_electrodes = buf[0];\r\nf54->num_tx_electrodes = buf[1];\r\nf54->capabilities = buf[2];\r\nf54->clock_rate = buf[3] | (buf[4] << 8);\r\nf54->family = buf[5];\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev, "F54 num_rx_electrodes: %d\n",\r\nf54->num_rx_electrodes);\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev, "F54 num_tx_electrodes: %d\n",\r\nf54->num_tx_electrodes);\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev, "F54 capabilities: 0x%x\n",\r\nf54->capabilities);\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev, "F54 clock rate: 0x%x\n",\r\nf54->clock_rate);\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev, "F54 family: 0x%x\n",\r\nf54->family);\r\nf54->is_busy = false;\r\nreturn 0;\r\n}\r\nstatic int rmi_f54_probe(struct rmi_function *fn)\r\n{\r\nstruct f54_data *f54;\r\nint ret;\r\nu8 rx, tx;\r\nf54 = devm_kzalloc(&fn->dev, sizeof(struct f54_data), GFP_KERNEL);\r\nif (!f54)\r\nreturn -ENOMEM;\r\nf54->fn = fn;\r\ndev_set_drvdata(&fn->dev, f54);\r\nret = rmi_f54_detect(fn);\r\nif (ret)\r\nreturn ret;\r\nmutex_init(&f54->data_mutex);\r\nmutex_init(&f54->status_mutex);\r\nrx = f54->num_rx_electrodes;\r\ntx = f54->num_tx_electrodes;\r\nf54->report_data = devm_kzalloc(&fn->dev,\r\nsizeof(u16) * tx * rx,\r\nGFP_KERNEL);\r\nif (f54->report_data == NULL)\r\nreturn -ENOMEM;\r\nINIT_DELAYED_WORK(&f54->work, rmi_f54_work);\r\nf54->workqueue = create_singlethread_workqueue("rmi4-poller");\r\nif (!f54->workqueue)\r\nreturn -ENOMEM;\r\nrmi_f54_create_input_map(f54);\r\nstrlcpy(f54->v4l2.name, F54_NAME, sizeof(f54->v4l2.name));\r\nret = v4l2_device_register(&fn->dev, &f54->v4l2);\r\nif (ret) {\r\ndev_err(&fn->dev, "Unable to register video dev.\n");\r\ngoto remove_wq;\r\n}\r\nmutex_init(&f54->lock);\r\nf54->queue = rmi_f54_queue;\r\nf54->queue.drv_priv = f54;\r\nf54->queue.lock = &f54->lock;\r\nf54->queue.dev = &fn->dev;\r\nret = vb2_queue_init(&f54->queue);\r\nif (ret)\r\ngoto remove_v4l2;\r\nf54->vdev = rmi_f54_video_device;\r\nf54->vdev.v4l2_dev = &f54->v4l2;\r\nf54->vdev.lock = &f54->lock;\r\nf54->vdev.vfl_dir = VFL_DIR_RX;\r\nf54->vdev.queue = &f54->queue;\r\nvideo_set_drvdata(&f54->vdev, f54);\r\nret = video_register_device(&f54->vdev, VFL_TYPE_TOUCH, -1);\r\nif (ret) {\r\ndev_err(&fn->dev, "Unable to register video subdevice.");\r\ngoto remove_v4l2;\r\n}\r\nreturn 0;\r\nremove_v4l2:\r\nv4l2_device_unregister(&f54->v4l2);\r\nremove_wq:\r\ncancel_delayed_work_sync(&f54->work);\r\nflush_workqueue(f54->workqueue);\r\ndestroy_workqueue(f54->workqueue);\r\nreturn ret;\r\n}\r\nstatic void rmi_f54_remove(struct rmi_function *fn)\r\n{\r\nstruct f54_data *f54 = dev_get_drvdata(&fn->dev);\r\nvideo_unregister_device(&f54->vdev);\r\nv4l2_device_unregister(&f54->v4l2);\r\n}
