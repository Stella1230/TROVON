static int prepare_zip_command(struct zip_operation *zip_ops,\r\nstruct zip_state *s, union zip_inst_s *zip_cmd)\r\n{\r\nunion zip_zres_s *result_ptr = &s->result;\r\nmemset(zip_cmd, 0, sizeof(s->zip_cmd));\r\nmemset(result_ptr, 0, sizeof(s->result));\r\nzip_cmd->s.hg = 0;\r\nzip_cmd->s.ce = 1;\r\nzip_cmd->s.sf = 1;\r\nif (zip_ops->flush == ZIP_FLUSH_FINISH) {\r\nzip_cmd->s.ef = 1;\r\nzip_cmd->s.sf = 0;\r\n}\r\nzip_cmd->s.cc = zip_ops->ccode;\r\nzip_cmd->s.ss = zip_ops->speed;\r\nzip_cmd->s.adlercrc32 = zip_ops->csum;\r\nzip_cmd->s.historylength = zip_ops->history_len;\r\nzip_cmd->s.dg = 0;\r\nzip_cmd->s.inp_ptr_addr.s.addr = __pa(zip_ops->input);\r\nzip_cmd->s.inp_ptr_ctl.s.length = (zip_ops->input_len +\r\nzip_ops->history_len);\r\nzip_cmd->s.ds = 0;\r\nzip_cmd->s.out_ptr_addr.s.addr = __pa(zip_ops->output);\r\nzip_cmd->s.out_ptr_ctl.s.length = zip_ops->output_len;\r\nzip_cmd->s.totaloutputlength = zip_ops->output_len;\r\nzip_cmd->s.res_ptr_addr.s.addr = __pa(result_ptr);\r\nresult_ptr->s.compcode = 0;\r\nreturn 0;\r\n}\r\nint zip_deflate(struct zip_operation *zip_ops, struct zip_state *s,\r\nstruct zip_device *zip_dev)\r\n{\r\nunion zip_inst_s *zip_cmd = &s->zip_cmd;\r\nunion zip_zres_s *result_ptr = &s->result;\r\nu32 queue;\r\nprepare_zip_command(zip_ops, s, zip_cmd);\r\natomic64_add(zip_ops->input_len, &zip_dev->stats.comp_in_bytes);\r\nqueue = zip_load_instr(zip_cmd, zip_dev);\r\natomic64_inc(&zip_dev->stats.comp_req_submit);\r\nwhile (!result_ptr->s.compcode)\r\ncontinue;\r\natomic64_inc(&zip_dev->stats.comp_req_complete);\r\nzip_ops->compcode = result_ptr->s.compcode;\r\nswitch (zip_ops->compcode) {\r\ncase ZIP_CMD_NOTDONE:\r\nzip_dbg("Zip instruction not yet completed");\r\nreturn ZIP_ERROR;\r\ncase ZIP_CMD_SUCCESS:\r\nzip_dbg("Zip instruction completed successfully");\r\nzip_update_cmd_bufs(zip_dev, queue);\r\nbreak;\r\ncase ZIP_CMD_DTRUNC:\r\nzip_dbg("Output Truncate error");\r\nreturn ZIP_ERROR;\r\ndefault:\r\nzip_err("Zip instruction failed. Code:%d", zip_ops->compcode);\r\nreturn ZIP_ERROR;\r\n}\r\nswitch (zip_ops->format) {\r\ncase RAW_FORMAT:\r\nzip_dbg("RAW Format: %d ", zip_ops->format);\r\nzip_ops->csum = result_ptr->s.adler32;\r\nbreak;\r\ncase ZLIB_FORMAT:\r\nzip_dbg("ZLIB Format: %d ", zip_ops->format);\r\nzip_ops->csum = result_ptr->s.adler32;\r\nbreak;\r\ncase GZIP_FORMAT:\r\nzip_dbg("GZIP Format: %d ", zip_ops->format);\r\nzip_ops->csum = result_ptr->s.crc32;\r\nbreak;\r\ncase LZS_FORMAT:\r\nzip_dbg("LZS Format: %d ", zip_ops->format);\r\nbreak;\r\ndefault:\r\nzip_err("Unknown Format:%d\n", zip_ops->format);\r\n}\r\natomic64_add(result_ptr->s.totalbyteswritten,\r\n&zip_dev->stats.comp_out_bytes);\r\nif (zip_ops->output_len < result_ptr->s.totalbyteswritten) {\r\nzip_err("output_len (%d) < total bytes written(%d)\n",\r\nzip_ops->output_len, result_ptr->s.totalbyteswritten);\r\nzip_ops->output_len = 0;\r\n} else {\r\nzip_ops->output_len = result_ptr->s.totalbyteswritten;\r\n}\r\nreturn 0;\r\n}
