static inline void vgic_v2_write_lr(int lr, u32 val)\r\n{\r\nvoid __iomem *base = kvm_vgic_global_state.vctrl_base;\r\nwritel_relaxed(val, base + GICH_LR0 + (lr * 4));\r\n}\r\nvoid vgic_v2_init_lrs(void)\r\n{\r\nint i;\r\nfor (i = 0; i < kvm_vgic_global_state.nr_lr; i++)\r\nvgic_v2_write_lr(i, 0);\r\n}\r\nvoid vgic_v2_set_underflow(struct kvm_vcpu *vcpu)\r\n{\r\nstruct vgic_v2_cpu_if *cpuif = &vcpu->arch.vgic_cpu.vgic_v2;\r\ncpuif->vgic_hcr |= GICH_HCR_UIE;\r\n}\r\nstatic bool lr_signals_eoi_mi(u32 lr_val)\r\n{\r\nreturn !(lr_val & GICH_LR_STATE) && (lr_val & GICH_LR_EOI) &&\r\n!(lr_val & GICH_LR_HW);\r\n}\r\nvoid vgic_v2_fold_lr_state(struct kvm_vcpu *vcpu)\r\n{\r\nstruct vgic_cpu *vgic_cpu = &vcpu->arch.vgic_cpu;\r\nstruct vgic_v2_cpu_if *cpuif = &vgic_cpu->vgic_v2;\r\nint lr;\r\ncpuif->vgic_hcr &= ~GICH_HCR_UIE;\r\nfor (lr = 0; lr < vgic_cpu->used_lrs; lr++) {\r\nu32 val = cpuif->vgic_lr[lr];\r\nu32 intid = val & GICH_LR_VIRTUALID;\r\nstruct vgic_irq *irq;\r\nif (lr_signals_eoi_mi(val) && vgic_valid_spi(vcpu->kvm, intid))\r\nkvm_notify_acked_irq(vcpu->kvm, 0,\r\nintid - VGIC_NR_PRIVATE_IRQS);\r\nirq = vgic_get_irq(vcpu->kvm, vcpu, intid);\r\nspin_lock(&irq->irq_lock);\r\nirq->active = !!(val & GICH_LR_ACTIVE_BIT);\r\nif (irq->config == VGIC_CONFIG_EDGE &&\r\n(val & GICH_LR_PENDING_BIT)) {\r\nirq->pending_latch = true;\r\nif (vgic_irq_is_sgi(intid)) {\r\nu32 cpuid = val & GICH_LR_PHYSID_CPUID;\r\ncpuid >>= GICH_LR_PHYSID_CPUID_SHIFT;\r\nirq->source |= (1 << cpuid);\r\n}\r\n}\r\nif (irq->config == VGIC_CONFIG_LEVEL) {\r\nif (!(val & GICH_LR_PENDING_BIT))\r\nirq->pending_latch = false;\r\n}\r\nspin_unlock(&irq->irq_lock);\r\nvgic_put_irq(vcpu->kvm, irq);\r\n}\r\nvgic_cpu->used_lrs = 0;\r\n}\r\nvoid vgic_v2_populate_lr(struct kvm_vcpu *vcpu, struct vgic_irq *irq, int lr)\r\n{\r\nu32 val = irq->intid;\r\nif (irq_is_pending(irq)) {\r\nval |= GICH_LR_PENDING_BIT;\r\nif (irq->config == VGIC_CONFIG_EDGE)\r\nirq->pending_latch = false;\r\nif (vgic_irq_is_sgi(irq->intid)) {\r\nu32 src = ffs(irq->source);\r\nBUG_ON(!src);\r\nval |= (src - 1) << GICH_LR_PHYSID_CPUID_SHIFT;\r\nirq->source &= ~(1 << (src - 1));\r\nif (irq->source)\r\nirq->pending_latch = true;\r\n}\r\n}\r\nif (irq->active)\r\nval |= GICH_LR_ACTIVE_BIT;\r\nif (irq->hw) {\r\nval |= GICH_LR_HW;\r\nval |= irq->hwintid << GICH_LR_PHYSID_CPUID_SHIFT;\r\nif (irq->active && irq_is_pending(irq))\r\nval &= ~GICH_LR_PENDING_BIT;\r\n} else {\r\nif (irq->config == VGIC_CONFIG_LEVEL)\r\nval |= GICH_LR_EOI;\r\n}\r\nval |= (irq->priority >> 3) << GICH_LR_PRIORITY_SHIFT;\r\nvcpu->arch.vgic_cpu.vgic_v2.vgic_lr[lr] = val;\r\n}\r\nvoid vgic_v2_clear_lr(struct kvm_vcpu *vcpu, int lr)\r\n{\r\nvcpu->arch.vgic_cpu.vgic_v2.vgic_lr[lr] = 0;\r\n}\r\nvoid vgic_v2_set_vmcr(struct kvm_vcpu *vcpu, struct vgic_vmcr *vmcrp)\r\n{\r\nstruct vgic_v2_cpu_if *cpu_if = &vcpu->arch.vgic_cpu.vgic_v2;\r\nu32 vmcr;\r\nvmcr = (vmcrp->grpen0 << GICH_VMCR_ENABLE_GRP0_SHIFT) &\r\nGICH_VMCR_ENABLE_GRP0_MASK;\r\nvmcr |= (vmcrp->grpen1 << GICH_VMCR_ENABLE_GRP1_SHIFT) &\r\nGICH_VMCR_ENABLE_GRP1_MASK;\r\nvmcr |= (vmcrp->ackctl << GICH_VMCR_ACK_CTL_SHIFT) &\r\nGICH_VMCR_ACK_CTL_MASK;\r\nvmcr |= (vmcrp->fiqen << GICH_VMCR_FIQ_EN_SHIFT) &\r\nGICH_VMCR_FIQ_EN_MASK;\r\nvmcr |= (vmcrp->cbpr << GICH_VMCR_CBPR_SHIFT) &\r\nGICH_VMCR_CBPR_MASK;\r\nvmcr |= (vmcrp->eoim << GICH_VMCR_EOI_MODE_SHIFT) &\r\nGICH_VMCR_EOI_MODE_MASK;\r\nvmcr |= (vmcrp->abpr << GICH_VMCR_ALIAS_BINPOINT_SHIFT) &\r\nGICH_VMCR_ALIAS_BINPOINT_MASK;\r\nvmcr |= (vmcrp->bpr << GICH_VMCR_BINPOINT_SHIFT) &\r\nGICH_VMCR_BINPOINT_MASK;\r\nvmcr |= ((vmcrp->pmr >> GICV_PMR_PRIORITY_SHIFT) <<\r\nGICH_VMCR_PRIMASK_SHIFT) & GICH_VMCR_PRIMASK_MASK;\r\ncpu_if->vgic_vmcr = vmcr;\r\n}\r\nvoid vgic_v2_get_vmcr(struct kvm_vcpu *vcpu, struct vgic_vmcr *vmcrp)\r\n{\r\nstruct vgic_v2_cpu_if *cpu_if = &vcpu->arch.vgic_cpu.vgic_v2;\r\nu32 vmcr;\r\nvmcr = cpu_if->vgic_vmcr;\r\nvmcrp->grpen0 = (vmcr & GICH_VMCR_ENABLE_GRP0_MASK) >>\r\nGICH_VMCR_ENABLE_GRP0_SHIFT;\r\nvmcrp->grpen1 = (vmcr & GICH_VMCR_ENABLE_GRP1_MASK) >>\r\nGICH_VMCR_ENABLE_GRP1_SHIFT;\r\nvmcrp->ackctl = (vmcr & GICH_VMCR_ACK_CTL_MASK) >>\r\nGICH_VMCR_ACK_CTL_SHIFT;\r\nvmcrp->fiqen = (vmcr & GICH_VMCR_FIQ_EN_MASK) >>\r\nGICH_VMCR_FIQ_EN_SHIFT;\r\nvmcrp->cbpr = (vmcr & GICH_VMCR_CBPR_MASK) >>\r\nGICH_VMCR_CBPR_SHIFT;\r\nvmcrp->eoim = (vmcr & GICH_VMCR_EOI_MODE_MASK) >>\r\nGICH_VMCR_EOI_MODE_SHIFT;\r\nvmcrp->abpr = (vmcr & GICH_VMCR_ALIAS_BINPOINT_MASK) >>\r\nGICH_VMCR_ALIAS_BINPOINT_SHIFT;\r\nvmcrp->bpr = (vmcr & GICH_VMCR_BINPOINT_MASK) >>\r\nGICH_VMCR_BINPOINT_SHIFT;\r\nvmcrp->pmr = ((vmcr & GICH_VMCR_PRIMASK_MASK) >>\r\nGICH_VMCR_PRIMASK_SHIFT) << GICV_PMR_PRIORITY_SHIFT;\r\n}\r\nvoid vgic_v2_enable(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->arch.vgic_cpu.vgic_v2.vgic_vmcr = 0;\r\nvcpu->arch.vgic_cpu.vgic_v2.vgic_elrsr = ~0;\r\nvcpu->arch.vgic_cpu.vgic_v2.vgic_hcr = GICH_HCR_EN;\r\n}\r\nstatic bool vgic_v2_check_base(gpa_t dist_base, gpa_t cpu_base)\r\n{\r\nif (dist_base + KVM_VGIC_V2_DIST_SIZE < dist_base)\r\nreturn false;\r\nif (cpu_base + KVM_VGIC_V2_CPU_SIZE < cpu_base)\r\nreturn false;\r\nif (dist_base + KVM_VGIC_V2_DIST_SIZE <= cpu_base)\r\nreturn true;\r\nif (cpu_base + KVM_VGIC_V2_CPU_SIZE <= dist_base)\r\nreturn true;\r\nreturn false;\r\n}\r\nint vgic_v2_map_resources(struct kvm *kvm)\r\n{\r\nstruct vgic_dist *dist = &kvm->arch.vgic;\r\nint ret = 0;\r\nif (vgic_ready(kvm))\r\ngoto out;\r\nif (IS_VGIC_ADDR_UNDEF(dist->vgic_dist_base) ||\r\nIS_VGIC_ADDR_UNDEF(dist->vgic_cpu_base)) {\r\nkvm_err("Need to set vgic cpu and dist addresses first\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nif (!vgic_v2_check_base(dist->vgic_dist_base, dist->vgic_cpu_base)) {\r\nkvm_err("VGIC CPU and dist frames overlap\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = vgic_init(kvm);\r\nif (ret) {\r\nkvm_err("Unable to initialize VGIC dynamic data structures\n");\r\ngoto out;\r\n}\r\nret = vgic_register_dist_iodev(kvm, dist->vgic_dist_base, VGIC_V2);\r\nif (ret) {\r\nkvm_err("Unable to register VGIC MMIO regions\n");\r\ngoto out;\r\n}\r\nif (!static_branch_unlikely(&vgic_v2_cpuif_trap)) {\r\nret = kvm_phys_addr_ioremap(kvm, dist->vgic_cpu_base,\r\nkvm_vgic_global_state.vcpu_base,\r\nKVM_VGIC_V2_CPU_SIZE, true);\r\nif (ret) {\r\nkvm_err("Unable to remap VGIC CPU to VCPU\n");\r\ngoto out;\r\n}\r\n}\r\ndist->ready = true;\r\nout:\r\nreturn ret;\r\n}\r\nint vgic_v2_probe(const struct gic_kvm_info *info)\r\n{\r\nint ret;\r\nu32 vtr;\r\nif (!info->vctrl.start) {\r\nkvm_err("GICH not present in the firmware table\n");\r\nreturn -ENXIO;\r\n}\r\nif (!PAGE_ALIGNED(info->vcpu.start) ||\r\n!PAGE_ALIGNED(resource_size(&info->vcpu))) {\r\nkvm_info("GICV region size/alignment is unsafe, using trapping (reduced performance)\n");\r\nkvm_vgic_global_state.vcpu_base_va = ioremap(info->vcpu.start,\r\nresource_size(&info->vcpu));\r\nif (!kvm_vgic_global_state.vcpu_base_va) {\r\nkvm_err("Cannot ioremap GICV\n");\r\nreturn -ENOMEM;\r\n}\r\nret = create_hyp_io_mappings(kvm_vgic_global_state.vcpu_base_va,\r\nkvm_vgic_global_state.vcpu_base_va + resource_size(&info->vcpu),\r\ninfo->vcpu.start);\r\nif (ret) {\r\nkvm_err("Cannot map GICV into hyp\n");\r\ngoto out;\r\n}\r\nstatic_branch_enable(&vgic_v2_cpuif_trap);\r\n}\r\nkvm_vgic_global_state.vctrl_base = ioremap(info->vctrl.start,\r\nresource_size(&info->vctrl));\r\nif (!kvm_vgic_global_state.vctrl_base) {\r\nkvm_err("Cannot ioremap GICH\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nvtr = readl_relaxed(kvm_vgic_global_state.vctrl_base + GICH_VTR);\r\nkvm_vgic_global_state.nr_lr = (vtr & 0x3f) + 1;\r\nret = create_hyp_io_mappings(kvm_vgic_global_state.vctrl_base,\r\nkvm_vgic_global_state.vctrl_base +\r\nresource_size(&info->vctrl),\r\ninfo->vctrl.start);\r\nif (ret) {\r\nkvm_err("Cannot map VCTRL into hyp\n");\r\ngoto out;\r\n}\r\nret = kvm_register_vgic_device(KVM_DEV_TYPE_ARM_VGIC_V2);\r\nif (ret) {\r\nkvm_err("Cannot register GICv2 KVM device\n");\r\ngoto out;\r\n}\r\nkvm_vgic_global_state.can_emulate_gicv2 = true;\r\nkvm_vgic_global_state.vcpu_base = info->vcpu.start;\r\nkvm_vgic_global_state.type = VGIC_V2;\r\nkvm_vgic_global_state.max_gic_vcpus = VGIC_V2_MAX_CPUS;\r\nkvm_info("vgic-v2@%llx\n", info->vctrl.start);\r\nreturn 0;\r\nout:\r\nif (kvm_vgic_global_state.vctrl_base)\r\niounmap(kvm_vgic_global_state.vctrl_base);\r\nif (kvm_vgic_global_state.vcpu_base_va)\r\niounmap(kvm_vgic_global_state.vcpu_base_va);\r\nreturn ret;\r\n}\r\nvoid vgic_v2_load(struct kvm_vcpu *vcpu)\r\n{\r\nstruct vgic_v2_cpu_if *cpu_if = &vcpu->arch.vgic_cpu.vgic_v2;\r\nstruct vgic_dist *vgic = &vcpu->kvm->arch.vgic;\r\nwritel_relaxed(cpu_if->vgic_vmcr, vgic->vctrl_base + GICH_VMCR);\r\n}\r\nvoid vgic_v2_put(struct kvm_vcpu *vcpu)\r\n{\r\nstruct vgic_v2_cpu_if *cpu_if = &vcpu->arch.vgic_cpu.vgic_v2;\r\nstruct vgic_dist *vgic = &vcpu->kvm->arch.vgic;\r\ncpu_if->vgic_vmcr = readl_relaxed(vgic->vctrl_base + GICH_VMCR);\r\n}
