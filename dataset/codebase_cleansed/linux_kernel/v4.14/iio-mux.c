static int iio_mux_select(struct mux *mux, int idx)\r\n{\r\nstruct mux_child *child = &mux->child[idx];\r\nstruct iio_chan_spec const *chan = &mux->chan[idx];\r\nint ret;\r\nint i;\r\nret = mux_control_select(mux->control, chan->channel);\r\nif (ret < 0) {\r\nmux->cached_state = -1;\r\nreturn ret;\r\n}\r\nif (mux->cached_state == chan->channel)\r\nreturn 0;\r\nif (chan->ext_info) {\r\nfor (i = 0; chan->ext_info[i].name; ++i) {\r\nconst char *attr = chan->ext_info[i].name;\r\nstruct mux_ext_info_cache *cache;\r\ncache = &child->ext_info_cache[i];\r\nif (cache->size < 0)\r\ncontinue;\r\nret = iio_write_channel_ext_info(mux->parent, attr,\r\ncache->data,\r\ncache->size);\r\nif (ret < 0) {\r\nmux_control_deselect(mux->control);\r\nmux->cached_state = -1;\r\nreturn ret;\r\n}\r\n}\r\n}\r\nmux->cached_state = chan->channel;\r\nreturn 0;\r\n}\r\nstatic void iio_mux_deselect(struct mux *mux)\r\n{\r\nmux_control_deselect(mux->control);\r\n}\r\nstatic int mux_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct mux *mux = iio_priv(indio_dev);\r\nint idx = chan - mux->chan;\r\nint ret;\r\nret = iio_mux_select(mux, idx);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = iio_read_channel_raw(mux->parent, val);\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nret = iio_read_channel_scale(mux->parent, val, val2);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\niio_mux_deselect(mux);\r\nreturn ret;\r\n}\r\nstatic int mux_read_avail(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nconst int **vals, int *type, int *length,\r\nlong mask)\r\n{\r\nstruct mux *mux = iio_priv(indio_dev);\r\nint idx = chan - mux->chan;\r\nint ret;\r\nret = iio_mux_select(mux, idx);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\n*type = IIO_VAL_INT;\r\nret = iio_read_avail_channel_raw(mux->parent, vals, length);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\niio_mux_deselect(mux);\r\nreturn ret;\r\n}\r\nstatic int mux_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct mux *mux = iio_priv(indio_dev);\r\nint idx = chan - mux->chan;\r\nint ret;\r\nret = iio_mux_select(mux, idx);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = iio_write_channel_raw(mux->parent, val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\niio_mux_deselect(mux);\r\nreturn ret;\r\n}\r\nstatic ssize_t mux_read_ext_info(struct iio_dev *indio_dev, uintptr_t private,\r\nstruct iio_chan_spec const *chan, char *buf)\r\n{\r\nstruct mux *mux = iio_priv(indio_dev);\r\nint idx = chan - mux->chan;\r\nssize_t ret;\r\nret = iio_mux_select(mux, idx);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iio_read_channel_ext_info(mux->parent,\r\nmux->ext_info[private].name,\r\nbuf);\r\niio_mux_deselect(mux);\r\nreturn ret;\r\n}\r\nstatic ssize_t mux_write_ext_info(struct iio_dev *indio_dev, uintptr_t private,\r\nstruct iio_chan_spec const *chan,\r\nconst char *buf, size_t len)\r\n{\r\nstruct device *dev = indio_dev->dev.parent;\r\nstruct mux *mux = iio_priv(indio_dev);\r\nint idx = chan - mux->chan;\r\nchar *new;\r\nssize_t ret;\r\nif (len >= PAGE_SIZE)\r\nreturn -EINVAL;\r\nret = iio_mux_select(mux, idx);\r\nif (ret < 0)\r\nreturn ret;\r\nnew = devm_kmemdup(dev, buf, len + 1, GFP_KERNEL);\r\nif (!new) {\r\niio_mux_deselect(mux);\r\nreturn -ENOMEM;\r\n}\r\nnew[len] = 0;\r\nret = iio_write_channel_ext_info(mux->parent,\r\nmux->ext_info[private].name,\r\nbuf, len);\r\nif (ret < 0) {\r\niio_mux_deselect(mux);\r\ndevm_kfree(dev, new);\r\nreturn ret;\r\n}\r\ndevm_kfree(dev, mux->child[idx].ext_info_cache[private].data);\r\nmux->child[idx].ext_info_cache[private].data = new;\r\nmux->child[idx].ext_info_cache[private].size = len;\r\niio_mux_deselect(mux);\r\nreturn ret;\r\n}\r\nstatic int mux_configure_channel(struct device *dev, struct mux *mux,\r\nu32 state, const char *label, int idx)\r\n{\r\nstruct mux_child *child = &mux->child[idx];\r\nstruct iio_chan_spec *chan = &mux->chan[idx];\r\nstruct iio_chan_spec const *pchan = mux->parent->channel;\r\nchar *page = NULL;\r\nint num_ext_info;\r\nint i;\r\nint ret;\r\nchan->indexed = 1;\r\nchan->output = pchan->output;\r\nchan->datasheet_name = label;\r\nchan->ext_info = mux->ext_info;\r\nret = iio_get_channel_type(mux->parent, &chan->type);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to get parent channel type\n");\r\nreturn ret;\r\n}\r\nif (iio_channel_has_info(pchan, IIO_CHAN_INFO_RAW))\r\nchan->info_mask_separate |= BIT(IIO_CHAN_INFO_RAW);\r\nif (iio_channel_has_info(pchan, IIO_CHAN_INFO_SCALE))\r\nchan->info_mask_separate |= BIT(IIO_CHAN_INFO_SCALE);\r\nif (iio_channel_has_available(pchan, IIO_CHAN_INFO_RAW))\r\nchan->info_mask_separate_available |= BIT(IIO_CHAN_INFO_RAW);\r\nif (state >= mux_control_states(mux->control)) {\r\ndev_err(dev, "too many channels\n");\r\nreturn -EINVAL;\r\n}\r\nchan->channel = state;\r\nnum_ext_info = iio_get_channel_ext_info_count(mux->parent);\r\nif (num_ext_info) {\r\npage = devm_kzalloc(dev, PAGE_SIZE, GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\n}\r\nchild->ext_info_cache = devm_kzalloc(dev,\r\nsizeof(*child->ext_info_cache) *\r\nnum_ext_info, GFP_KERNEL);\r\nfor (i = 0; i < num_ext_info; ++i) {\r\nchild->ext_info_cache[i].size = -1;\r\nif (!pchan->ext_info[i].write)\r\ncontinue;\r\nif (!pchan->ext_info[i].read)\r\ncontinue;\r\nret = iio_read_channel_ext_info(mux->parent,\r\nmux->ext_info[i].name,\r\npage);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to get ext_info '%s'\n",\r\npchan->ext_info[i].name);\r\nreturn ret;\r\n}\r\nif (ret >= PAGE_SIZE) {\r\ndev_err(dev, "too large ext_info '%s'\n",\r\npchan->ext_info[i].name);\r\nreturn -EINVAL;\r\n}\r\nchild->ext_info_cache[i].data = devm_kmemdup(dev, page, ret + 1,\r\nGFP_KERNEL);\r\nchild->ext_info_cache[i].data[ret] = 0;\r\nchild->ext_info_cache[i].size = ret;\r\n}\r\nif (page)\r\ndevm_kfree(dev, page);\r\nreturn 0;\r\n}\r\nstatic int mux_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct iio_dev *indio_dev;\r\nstruct iio_channel *parent;\r\nstruct mux *mux;\r\nstruct property *prop;\r\nconst char *label;\r\nu32 state;\r\nint sizeof_ext_info;\r\nint children;\r\nint sizeof_priv;\r\nint i;\r\nint ret;\r\nif (!np)\r\nreturn -ENODEV;\r\nparent = devm_iio_channel_get(dev, "parent");\r\nif (IS_ERR(parent)) {\r\nif (PTR_ERR(parent) != -EPROBE_DEFER)\r\ndev_err(dev, "failed to get parent channel\n");\r\nreturn PTR_ERR(parent);\r\n}\r\nsizeof_ext_info = iio_get_channel_ext_info_count(parent);\r\nif (sizeof_ext_info) {\r\nsizeof_ext_info += 1;\r\nsizeof_ext_info *= sizeof(*mux->ext_info);\r\n}\r\nchildren = 0;\r\nof_property_for_each_string(np, "channels", prop, label) {\r\nif (*label)\r\nchildren++;\r\n}\r\nif (children <= 0) {\r\ndev_err(dev, "not even a single child\n");\r\nreturn -EINVAL;\r\n}\r\nsizeof_priv = sizeof(*mux);\r\nsizeof_priv += sizeof(*mux->child) * children;\r\nsizeof_priv += sizeof(*mux->chan) * children;\r\nsizeof_priv += sizeof_ext_info;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof_priv);\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nmux = iio_priv(indio_dev);\r\nmux->child = (struct mux_child *)(mux + 1);\r\nmux->chan = (struct iio_chan_spec *)(mux->child + children);\r\nplatform_set_drvdata(pdev, indio_dev);\r\nmux->parent = parent;\r\nmux->cached_state = -1;\r\nindio_dev->name = dev_name(dev);\r\nindio_dev->dev.parent = dev;\r\nindio_dev->info = &mux_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = mux->chan;\r\nindio_dev->num_channels = children;\r\nif (sizeof_ext_info) {\r\nmux->ext_info = devm_kmemdup(dev,\r\nparent->channel->ext_info,\r\nsizeof_ext_info, GFP_KERNEL);\r\nif (!mux->ext_info)\r\nreturn -ENOMEM;\r\nfor (i = 0; mux->ext_info[i].name; ++i) {\r\nif (parent->channel->ext_info[i].read)\r\nmux->ext_info[i].read = mux_read_ext_info;\r\nif (parent->channel->ext_info[i].write)\r\nmux->ext_info[i].write = mux_write_ext_info;\r\nmux->ext_info[i].private = i;\r\n}\r\n}\r\nmux->control = devm_mux_control_get(dev, NULL);\r\nif (IS_ERR(mux->control)) {\r\nif (PTR_ERR(mux->control) != -EPROBE_DEFER)\r\ndev_err(dev, "failed to get control-mux\n");\r\nreturn PTR_ERR(mux->control);\r\n}\r\ni = 0;\r\nof_property_for_each_string_index(np, "channels", prop, label, state) {\r\nif (!*label)\r\ncontinue;\r\nret = mux_configure_channel(dev, mux, state, label, i++);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = devm_iio_device_register(dev, indio_dev);\r\nif (ret) {\r\ndev_err(dev, "failed to register iio device\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
