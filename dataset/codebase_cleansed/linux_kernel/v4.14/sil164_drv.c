static void\r\nsil164_write(struct i2c_client *client, uint8_t addr, uint8_t val)\r\n{\r\nuint8_t buf[] = {addr, val};\r\nint ret;\r\nret = i2c_master_send(client, buf, ARRAY_SIZE(buf));\r\nif (ret < 0)\r\nsil164_err(client, "Error %d writing to subaddress 0x%x\n",\r\nret, addr);\r\n}\r\nstatic uint8_t\r\nsil164_read(struct i2c_client *client, uint8_t addr)\r\n{\r\nuint8_t val;\r\nint ret;\r\nret = i2c_master_send(client, &addr, sizeof(addr));\r\nif (ret < 0)\r\ngoto fail;\r\nret = i2c_master_recv(client, &val, sizeof(val));\r\nif (ret < 0)\r\ngoto fail;\r\nreturn val;\r\nfail:\r\nsil164_err(client, "Error %d reading from subaddress 0x%x\n",\r\nret, addr);\r\nreturn 0;\r\n}\r\nstatic void\r\nsil164_save_state(struct i2c_client *client, uint8_t *state)\r\n{\r\nint i;\r\nfor (i = 0x8; i <= 0xe; i++)\r\nstate[i] = sil164_read(client, i);\r\n}\r\nstatic void\r\nsil164_restore_state(struct i2c_client *client, uint8_t *state)\r\n{\r\nint i;\r\nfor (i = 0x8; i <= 0xe; i++)\r\nsil164_write(client, i, state[i]);\r\n}\r\nstatic void\r\nsil164_set_power_state(struct i2c_client *client, bool on)\r\n{\r\nuint8_t control0 = sil164_read(client, SIL164_CONTROL0);\r\nif (on)\r\ncontrol0 |= SIL164_CONTROL0_POWER_ON;\r\nelse\r\ncontrol0 &= ~SIL164_CONTROL0_POWER_ON;\r\nsil164_write(client, SIL164_CONTROL0, control0);\r\n}\r\nstatic void\r\nsil164_init_state(struct i2c_client *client,\r\nstruct sil164_encoder_params *config,\r\nbool duallink)\r\n{\r\nsil164_write(client, SIL164_CONTROL0,\r\nSIL164_CONTROL0_HSYNC_ON |\r\nSIL164_CONTROL0_VSYNC_ON |\r\n(config->input_edge ? SIL164_CONTROL0_EDGE_RISING : 0) |\r\n(config->input_width ? SIL164_CONTROL0_INPUT_24BIT : 0) |\r\n(config->input_dual ? SIL164_CONTROL0_DUAL_EDGE : 0));\r\nsil164_write(client, SIL164_DETECT,\r\nSIL164_DETECT_INTR_STAT |\r\nSIL164_DETECT_OUT_MODE_RECEIVER);\r\nsil164_write(client, SIL164_CONTROL1,\r\n(config->input_skew ? SIL164_CONTROL1_DESKEW_ENABLE : 0) |\r\n(((config->input_skew + 4) & 0x7)\r\n<< SIL164_CONTROL1_DESKEW_INCR_SHIFT));\r\nsil164_write(client, SIL164_CONTROL2,\r\nSIL164_CONTROL2_SYNC_CONT |\r\n(config->pll_filter ? 0 : SIL164_CONTROL2_FILTER_ENABLE) |\r\n(4 << SIL164_CONTROL2_FILTER_SETTING_SHIFT));\r\nsil164_write(client, SIL164_PLLZONE, 0);\r\nif (duallink)\r\nsil164_write(client, SIL164_DUALLINK,\r\nSIL164_DUALLINK_ENABLE |\r\n(((config->duallink_skew + 4) & 0x7)\r\n<< SIL164_DUALLINK_SKEW_SHIFT));\r\nelse\r\nsil164_write(client, SIL164_DUALLINK, 0);\r\n}\r\nstatic void\r\nsil164_encoder_set_config(struct drm_encoder *encoder, void *params)\r\n{\r\nstruct sil164_priv *priv = to_sil164_priv(encoder);\r\npriv->config = *(struct sil164_encoder_params *)params;\r\n}\r\nstatic void\r\nsil164_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct sil164_priv *priv = to_sil164_priv(encoder);\r\nbool on = (mode == DRM_MODE_DPMS_ON);\r\nbool duallink = (on && encoder->crtc->mode.clock > 165000);\r\nsil164_set_power_state(drm_i2c_encoder_get_client(encoder), on);\r\nif (priv->duallink_slave)\r\nsil164_set_power_state(priv->duallink_slave, duallink);\r\n}\r\nstatic void\r\nsil164_encoder_save(struct drm_encoder *encoder)\r\n{\r\nstruct sil164_priv *priv = to_sil164_priv(encoder);\r\nsil164_save_state(drm_i2c_encoder_get_client(encoder),\r\npriv->saved_state);\r\nif (priv->duallink_slave)\r\nsil164_save_state(priv->duallink_slave,\r\npriv->saved_slave_state);\r\n}\r\nstatic void\r\nsil164_encoder_restore(struct drm_encoder *encoder)\r\n{\r\nstruct sil164_priv *priv = to_sil164_priv(encoder);\r\nsil164_restore_state(drm_i2c_encoder_get_client(encoder),\r\npriv->saved_state);\r\nif (priv->duallink_slave)\r\nsil164_restore_state(priv->duallink_slave,\r\npriv->saved_slave_state);\r\n}\r\nstatic int\r\nsil164_encoder_mode_valid(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct sil164_priv *priv = to_sil164_priv(encoder);\r\nif (mode->clock < 32000)\r\nreturn MODE_CLOCK_LOW;\r\nif (mode->clock > 330000 ||\r\n(mode->clock > 165000 && !priv->duallink_slave))\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic void\r\nsil164_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct sil164_priv *priv = to_sil164_priv(encoder);\r\nbool duallink = adjusted_mode->clock > 165000;\r\nsil164_init_state(drm_i2c_encoder_get_client(encoder),\r\n&priv->config, duallink);\r\nif (priv->duallink_slave)\r\nsil164_init_state(priv->duallink_slave,\r\n&priv->config, duallink);\r\nsil164_encoder_dpms(encoder, DRM_MODE_DPMS_ON);\r\n}\r\nstatic enum drm_connector_status\r\nsil164_encoder_detect(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\r\nif (sil164_read(client, SIL164_DETECT) & SIL164_DETECT_HOTPLUG_STAT)\r\nreturn connector_status_connected;\r\nelse\r\nreturn connector_status_disconnected;\r\n}\r\nstatic int\r\nsil164_encoder_get_modes(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\nsil164_encoder_create_resources(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\nsil164_encoder_set_property(struct drm_encoder *encoder,\r\nstruct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nsil164_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct sil164_priv *priv = to_sil164_priv(encoder);\r\nif (priv->duallink_slave)\r\ni2c_unregister_device(priv->duallink_slave);\r\nkfree(priv);\r\ndrm_i2c_encoder_destroy(encoder);\r\n}\r\nstatic int\r\nsil164_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nint vendor = sil164_read(client, SIL164_VENDOR_HI) << 8 |\r\nsil164_read(client, SIL164_VENDOR_LO);\r\nint device = sil164_read(client, SIL164_DEVICE_HI) << 8 |\r\nsil164_read(client, SIL164_DEVICE_LO);\r\nint rev = sil164_read(client, SIL164_REVISION);\r\nif (vendor != 0x1 || device != 0x6) {\r\nsil164_dbg(client, "Unknown device %x:%x.%x\n",\r\nvendor, device, rev);\r\nreturn -ENODEV;\r\n}\r\nsil164_info(client, "Detected device %x:%x.%x\n",\r\nvendor, device, rev);\r\nreturn 0;\r\n}\r\nstatic int\r\nsil164_remove(struct i2c_client *client)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct i2c_client *\r\nsil164_detect_slave(struct i2c_client *client)\r\n{\r\nstruct i2c_adapter *adap = client->adapter;\r\nstruct i2c_msg msg = {\r\n.addr = SIL164_I2C_ADDR_SLAVE,\r\n.len = 0,\r\n};\r\nconst struct i2c_board_info info = {\r\nI2C_BOARD_INFO("sil164", SIL164_I2C_ADDR_SLAVE)\r\n};\r\nif (i2c_transfer(adap, &msg, 1) != 1) {\r\nsil164_dbg(adap, "No dual-link slave found.");\r\nreturn NULL;\r\n}\r\nreturn i2c_new_device(adap, &info);\r\n}\r\nstatic int\r\nsil164_encoder_init(struct i2c_client *client,\r\nstruct drm_device *dev,\r\nstruct drm_encoder_slave *encoder)\r\n{\r\nstruct sil164_priv *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nencoder->slave_priv = priv;\r\nencoder->slave_funcs = &sil164_encoder_funcs;\r\npriv->duallink_slave = sil164_detect_slave(client);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nsil164_init(void)\r\n{\r\nreturn drm_i2c_encoder_register(THIS_MODULE, &sil164_driver);\r\n}\r\nstatic void __exit\r\nsil164_exit(void)\r\n{\r\ndrm_i2c_encoder_unregister(&sil164_driver);\r\n}
