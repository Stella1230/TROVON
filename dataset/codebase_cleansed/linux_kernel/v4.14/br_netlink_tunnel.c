static size_t __get_vlan_tinfo_size(void)\r\n{\r\nreturn nla_total_size(0) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u16)) +\r\nnla_total_size(sizeof(u16));\r\n}\r\nstatic bool vlan_tunid_inrange(struct net_bridge_vlan *v_curr,\r\nstruct net_bridge_vlan *v_last)\r\n{\r\n__be32 tunid_curr = tunnel_id_to_key32(v_curr->tinfo.tunnel_id);\r\n__be32 tunid_last = tunnel_id_to_key32(v_last->tinfo.tunnel_id);\r\nreturn (be32_to_cpu(tunid_curr) - be32_to_cpu(tunid_last)) == 1;\r\n}\r\nstatic int __get_num_vlan_tunnel_infos(struct net_bridge_vlan_group *vg)\r\n{\r\nstruct net_bridge_vlan *v, *vtbegin = NULL, *vtend = NULL;\r\nint num_tinfos = 0;\r\nlist_for_each_entry_rcu(v, &vg->vlan_list, vlist) {\r\nif (!br_vlan_should_use(v) || !v->tinfo.tunnel_id)\r\ncontinue;\r\nif (!vtbegin) {\r\ngoto initvars;\r\n} else if ((v->vid - vtend->vid) == 1 &&\r\nvlan_tunid_inrange(v, vtend)) {\r\nvtend = v;\r\ncontinue;\r\n} else {\r\nif ((vtend->vid - vtbegin->vid) > 0)\r\nnum_tinfos += 2;\r\nelse\r\nnum_tinfos += 1;\r\n}\r\ninitvars:\r\nvtbegin = v;\r\nvtend = v;\r\n}\r\nif (vtbegin && vtend) {\r\nif ((vtend->vid - vtbegin->vid) > 0)\r\nnum_tinfos += 2;\r\nelse\r\nnum_tinfos += 1;\r\n}\r\nreturn num_tinfos;\r\n}\r\nint br_get_vlan_tunnel_info_size(struct net_bridge_vlan_group *vg)\r\n{\r\nint num_tinfos;\r\nif (!vg)\r\nreturn 0;\r\nrcu_read_lock();\r\nnum_tinfos = __get_num_vlan_tunnel_infos(vg);\r\nrcu_read_unlock();\r\nreturn num_tinfos * __get_vlan_tinfo_size();\r\n}\r\nstatic int br_fill_vlan_tinfo(struct sk_buff *skb, u16 vid,\r\n__be64 tunnel_id, u16 flags)\r\n{\r\n__be32 tid = tunnel_id_to_key32(tunnel_id);\r\nstruct nlattr *tmap;\r\ntmap = nla_nest_start(skb, IFLA_BRIDGE_VLAN_TUNNEL_INFO);\r\nif (!tmap)\r\nreturn -EMSGSIZE;\r\nif (nla_put_u32(skb, IFLA_BRIDGE_VLAN_TUNNEL_ID,\r\nbe32_to_cpu(tid)))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(skb, IFLA_BRIDGE_VLAN_TUNNEL_VID,\r\nvid))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(skb, IFLA_BRIDGE_VLAN_TUNNEL_FLAGS,\r\nflags))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, tmap);\r\nreturn 0;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, tmap);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int br_fill_vlan_tinfo_range(struct sk_buff *skb,\r\nstruct net_bridge_vlan *vtbegin,\r\nstruct net_bridge_vlan *vtend)\r\n{\r\nint err;\r\nif (vtend && (vtend->vid - vtbegin->vid) > 0) {\r\nerr = br_fill_vlan_tinfo(skb, vtbegin->vid,\r\nvtbegin->tinfo.tunnel_id,\r\nBRIDGE_VLAN_INFO_RANGE_BEGIN);\r\nif (err)\r\nreturn err;\r\nerr = br_fill_vlan_tinfo(skb, vtend->vid,\r\nvtend->tinfo.tunnel_id,\r\nBRIDGE_VLAN_INFO_RANGE_END);\r\nif (err)\r\nreturn err;\r\n} else {\r\nerr = br_fill_vlan_tinfo(skb, vtbegin->vid,\r\nvtbegin->tinfo.tunnel_id,\r\n0);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint br_fill_vlan_tunnel_info(struct sk_buff *skb,\r\nstruct net_bridge_vlan_group *vg)\r\n{\r\nstruct net_bridge_vlan *vtbegin = NULL;\r\nstruct net_bridge_vlan *vtend = NULL;\r\nstruct net_bridge_vlan *v;\r\nint err;\r\nlist_for_each_entry_rcu(v, &vg->vlan_list, vlist) {\r\nif (!br_vlan_should_use(v))\r\ncontinue;\r\nif (!v->tinfo.tunnel_dst)\r\ncontinue;\r\nif (!vtbegin) {\r\ngoto initvars;\r\n} else if ((v->vid - vtend->vid) == 1 &&\r\nvlan_tunid_inrange(v, vtend)) {\r\nvtend = v;\r\ncontinue;\r\n} else {\r\nerr = br_fill_vlan_tinfo_range(skb, vtbegin, vtend);\r\nif (err)\r\nreturn err;\r\n}\r\ninitvars:\r\nvtbegin = v;\r\nvtend = v;\r\n}\r\nif (vtbegin) {\r\nerr = br_fill_vlan_tinfo_range(skb, vtbegin, vtend);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int br_vlan_tunnel_info(struct net_bridge_port *p, int cmd,\r\nu16 vid, u32 tun_id)\r\n{\r\nint err = 0;\r\nif (!p)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase RTM_SETLINK:\r\nerr = nbp_vlan_tunnel_info_add(p, vid, tun_id);\r\nbreak;\r\ncase RTM_DELLINK:\r\nnbp_vlan_tunnel_info_delete(p, vid);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nint br_parse_vlan_tunnel_info(struct nlattr *attr,\r\nstruct vtunnel_info *tinfo)\r\n{\r\nstruct nlattr *tb[IFLA_BRIDGE_VLAN_TUNNEL_MAX + 1];\r\nu32 tun_id;\r\nu16 vid, flags = 0;\r\nint err;\r\nmemset(tinfo, 0, sizeof(*tinfo));\r\nerr = nla_parse_nested(tb, IFLA_BRIDGE_VLAN_TUNNEL_MAX, attr,\r\nvlan_tunnel_policy, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (!tb[IFLA_BRIDGE_VLAN_TUNNEL_ID] ||\r\n!tb[IFLA_BRIDGE_VLAN_TUNNEL_VID])\r\nreturn -EINVAL;\r\ntun_id = nla_get_u32(tb[IFLA_BRIDGE_VLAN_TUNNEL_ID]);\r\nvid = nla_get_u16(tb[IFLA_BRIDGE_VLAN_TUNNEL_VID]);\r\nif (vid >= VLAN_VID_MASK)\r\nreturn -ERANGE;\r\nif (tb[IFLA_BRIDGE_VLAN_TUNNEL_FLAGS])\r\nflags = nla_get_u16(tb[IFLA_BRIDGE_VLAN_TUNNEL_FLAGS]);\r\ntinfo->tunid = tun_id;\r\ntinfo->vid = vid;\r\ntinfo->flags = flags;\r\nreturn 0;\r\n}\r\nint br_process_vlan_tunnel_info(struct net_bridge *br,\r\nstruct net_bridge_port *p, int cmd,\r\nstruct vtunnel_info *tinfo_curr,\r\nstruct vtunnel_info *tinfo_last)\r\n{\r\nint err;\r\nif (tinfo_curr->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN) {\r\nif (tinfo_last->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN)\r\nreturn -EINVAL;\r\nmemcpy(tinfo_last, tinfo_curr, sizeof(struct vtunnel_info));\r\n} else if (tinfo_curr->flags & BRIDGE_VLAN_INFO_RANGE_END) {\r\nint t, v;\r\nif (!(tinfo_last->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN))\r\nreturn -EINVAL;\r\nif ((tinfo_curr->vid - tinfo_last->vid) !=\r\n(tinfo_curr->tunid - tinfo_last->tunid))\r\nreturn -EINVAL;\r\nt = tinfo_last->tunid;\r\nfor (v = tinfo_last->vid; v <= tinfo_curr->vid; v++) {\r\nerr = br_vlan_tunnel_info(p, cmd, v, t);\r\nif (err)\r\nreturn err;\r\nt++;\r\n}\r\nmemset(tinfo_last, 0, sizeof(struct vtunnel_info));\r\nmemset(tinfo_curr, 0, sizeof(struct vtunnel_info));\r\n} else {\r\nif (tinfo_last->flags)\r\nreturn -EINVAL;\r\nerr = br_vlan_tunnel_info(p, cmd, tinfo_curr->vid,\r\ntinfo_curr->tunid);\r\nif (err)\r\nreturn err;\r\nmemset(tinfo_last, 0, sizeof(struct vtunnel_info));\r\nmemset(tinfo_curr, 0, sizeof(struct vtunnel_info));\r\n}\r\nreturn 0;\r\n}
