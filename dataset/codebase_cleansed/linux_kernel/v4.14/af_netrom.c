static void nr_set_lockdep_one(struct net_device *dev,\r\nstruct netdev_queue *txq,\r\nvoid *_unused)\r\n{\r\nlockdep_set_class(&txq->_xmit_lock, &nr_netdev_xmit_lock_key);\r\n}\r\nstatic void nr_set_lockdep_key(struct net_device *dev)\r\n{\r\nlockdep_set_class(&dev->addr_list_lock, &nr_netdev_addr_lock_key);\r\nnetdev_for_each_tx_queue(dev, nr_set_lockdep_one, NULL);\r\n}\r\nstatic void nr_remove_socket(struct sock *sk)\r\n{\r\nspin_lock_bh(&nr_list_lock);\r\nsk_del_node_init(sk);\r\nspin_unlock_bh(&nr_list_lock);\r\n}\r\nstatic void nr_kill_by_device(struct net_device *dev)\r\n{\r\nstruct sock *s;\r\nspin_lock_bh(&nr_list_lock);\r\nsk_for_each(s, &nr_list)\r\nif (nr_sk(s)->device == dev)\r\nnr_disconnect(s, ENETUNREACH);\r\nspin_unlock_bh(&nr_list_lock);\r\n}\r\nstatic int nr_device_event(struct notifier_block *this, unsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (event != NETDEV_DOWN)\r\nreturn NOTIFY_DONE;\r\nnr_kill_by_device(dev);\r\nnr_rt_device_down(dev);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void nr_insert_socket(struct sock *sk)\r\n{\r\nspin_lock_bh(&nr_list_lock);\r\nsk_add_node(sk, &nr_list);\r\nspin_unlock_bh(&nr_list_lock);\r\n}\r\nstatic struct sock *nr_find_listener(ax25_address *addr)\r\n{\r\nstruct sock *s;\r\nspin_lock_bh(&nr_list_lock);\r\nsk_for_each(s, &nr_list)\r\nif (!ax25cmp(&nr_sk(s)->source_addr, addr) &&\r\ns->sk_state == TCP_LISTEN) {\r\nbh_lock_sock(s);\r\ngoto found;\r\n}\r\ns = NULL;\r\nfound:\r\nspin_unlock_bh(&nr_list_lock);\r\nreturn s;\r\n}\r\nstatic struct sock *nr_find_socket(unsigned char index, unsigned char id)\r\n{\r\nstruct sock *s;\r\nspin_lock_bh(&nr_list_lock);\r\nsk_for_each(s, &nr_list) {\r\nstruct nr_sock *nr = nr_sk(s);\r\nif (nr->my_index == index && nr->my_id == id) {\r\nbh_lock_sock(s);\r\ngoto found;\r\n}\r\n}\r\ns = NULL;\r\nfound:\r\nspin_unlock_bh(&nr_list_lock);\r\nreturn s;\r\n}\r\nstatic struct sock *nr_find_peer(unsigned char index, unsigned char id,\r\nax25_address *dest)\r\n{\r\nstruct sock *s;\r\nspin_lock_bh(&nr_list_lock);\r\nsk_for_each(s, &nr_list) {\r\nstruct nr_sock *nr = nr_sk(s);\r\nif (nr->your_index == index && nr->your_id == id &&\r\n!ax25cmp(&nr->dest_addr, dest)) {\r\nbh_lock_sock(s);\r\ngoto found;\r\n}\r\n}\r\ns = NULL;\r\nfound:\r\nspin_unlock_bh(&nr_list_lock);\r\nreturn s;\r\n}\r\nstatic unsigned short nr_find_next_circuit(void)\r\n{\r\nunsigned short id = circuit;\r\nunsigned char i, j;\r\nstruct sock *sk;\r\nfor (;;) {\r\ni = id / 256;\r\nj = id % 256;\r\nif (i != 0 && j != 0) {\r\nif ((sk=nr_find_socket(i, j)) == NULL)\r\nbreak;\r\nbh_unlock_sock(sk);\r\n}\r\nid++;\r\n}\r\nreturn id;\r\n}\r\nstatic void nr_destroy_timer(unsigned long data)\r\n{\r\nstruct sock *sk=(struct sock *)data;\r\nbh_lock_sock(sk);\r\nsock_hold(sk);\r\nnr_destroy_socket(sk);\r\nbh_unlock_sock(sk);\r\nsock_put(sk);\r\n}\r\nvoid nr_destroy_socket(struct sock *sk)\r\n{\r\nstruct sk_buff *skb;\r\nnr_remove_socket(sk);\r\nnr_stop_heartbeat(sk);\r\nnr_stop_t1timer(sk);\r\nnr_stop_t2timer(sk);\r\nnr_stop_t4timer(sk);\r\nnr_stop_idletimer(sk);\r\nnr_clear_queues(sk);\r\nwhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\r\nif (skb->sk != sk) {\r\nsock_set_flag(skb->sk, SOCK_DEAD);\r\nnr_start_heartbeat(skb->sk);\r\nnr_sk(skb->sk)->state = NR_STATE_0;\r\n}\r\nkfree_skb(skb);\r\n}\r\nif (sk_has_allocations(sk)) {\r\nsk->sk_timer.function = nr_destroy_timer;\r\nsk->sk_timer.expires = jiffies + 2 * HZ;\r\nadd_timer(&sk->sk_timer);\r\n} else\r\nsock_put(sk);\r\n}\r\nstatic int nr_setsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct nr_sock *nr = nr_sk(sk);\r\nunsigned long opt;\r\nif (level != SOL_NETROM)\r\nreturn -ENOPROTOOPT;\r\nif (optlen < sizeof(unsigned int))\r\nreturn -EINVAL;\r\nif (get_user(opt, (unsigned int __user *)optval))\r\nreturn -EFAULT;\r\nswitch (optname) {\r\ncase NETROM_T1:\r\nif (opt < 1 || opt > ULONG_MAX / HZ)\r\nreturn -EINVAL;\r\nnr->t1 = opt * HZ;\r\nreturn 0;\r\ncase NETROM_T2:\r\nif (opt < 1 || opt > ULONG_MAX / HZ)\r\nreturn -EINVAL;\r\nnr->t2 = opt * HZ;\r\nreturn 0;\r\ncase NETROM_N2:\r\nif (opt < 1 || opt > 31)\r\nreturn -EINVAL;\r\nnr->n2 = opt;\r\nreturn 0;\r\ncase NETROM_T4:\r\nif (opt < 1 || opt > ULONG_MAX / HZ)\r\nreturn -EINVAL;\r\nnr->t4 = opt * HZ;\r\nreturn 0;\r\ncase NETROM_IDLE:\r\nif (opt > ULONG_MAX / (60 * HZ))\r\nreturn -EINVAL;\r\nnr->idle = opt * 60 * HZ;\r\nreturn 0;\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\n}\r\nstatic int nr_getsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct nr_sock *nr = nr_sk(sk);\r\nint val = 0;\r\nint len;\r\nif (level != SOL_NETROM)\r\nreturn -ENOPROTOOPT;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nif (len < 0)\r\nreturn -EINVAL;\r\nswitch (optname) {\r\ncase NETROM_T1:\r\nval = nr->t1 / HZ;\r\nbreak;\r\ncase NETROM_T2:\r\nval = nr->t2 / HZ;\r\nbreak;\r\ncase NETROM_N2:\r\nval = nr->n2;\r\nbreak;\r\ncase NETROM_T4:\r\nval = nr->t4 / HZ;\r\nbreak;\r\ncase NETROM_IDLE:\r\nval = nr->idle / (60 * HZ);\r\nbreak;\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\nlen = min_t(unsigned int, len, sizeof(int));\r\nif (put_user(len, optlen))\r\nreturn -EFAULT;\r\nreturn copy_to_user(optval, &val, len) ? -EFAULT : 0;\r\n}\r\nstatic int nr_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nlock_sock(sk);\r\nif (sk->sk_state != TCP_LISTEN) {\r\nmemset(&nr_sk(sk)->user_addr, 0, AX25_ADDR_LEN);\r\nsk->sk_max_ack_backlog = backlog;\r\nsk->sk_state = TCP_LISTEN;\r\nrelease_sock(sk);\r\nreturn 0;\r\n}\r\nrelease_sock(sk);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int nr_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nstruct nr_sock *nr;\r\nif (!net_eq(net, &init_net))\r\nreturn -EAFNOSUPPORT;\r\nif (sock->type != SOCK_SEQPACKET || protocol != 0)\r\nreturn -ESOCKTNOSUPPORT;\r\nsk = sk_alloc(net, PF_NETROM, GFP_ATOMIC, &nr_proto, kern);\r\nif (sk == NULL)\r\nreturn -ENOMEM;\r\nnr = nr_sk(sk);\r\nsock_init_data(sock, sk);\r\nsock->ops = &nr_proto_ops;\r\nsk->sk_protocol = protocol;\r\nskb_queue_head_init(&nr->ack_queue);\r\nskb_queue_head_init(&nr->reseq_queue);\r\nskb_queue_head_init(&nr->frag_queue);\r\nnr_init_timers(sk);\r\nnr->t1 =\r\nmsecs_to_jiffies(sysctl_netrom_transport_timeout);\r\nnr->t2 =\r\nmsecs_to_jiffies(sysctl_netrom_transport_acknowledge_delay);\r\nnr->n2 =\r\nmsecs_to_jiffies(sysctl_netrom_transport_maximum_tries);\r\nnr->t4 =\r\nmsecs_to_jiffies(sysctl_netrom_transport_busy_delay);\r\nnr->idle =\r\nmsecs_to_jiffies(sysctl_netrom_transport_no_activity_timeout);\r\nnr->window = sysctl_netrom_transport_requested_window_size;\r\nnr->bpqext = 1;\r\nnr->state = NR_STATE_0;\r\nreturn 0;\r\n}\r\nstatic struct sock *nr_make_new(struct sock *osk)\r\n{\r\nstruct sock *sk;\r\nstruct nr_sock *nr, *onr;\r\nif (osk->sk_type != SOCK_SEQPACKET)\r\nreturn NULL;\r\nsk = sk_alloc(sock_net(osk), PF_NETROM, GFP_ATOMIC, osk->sk_prot, 0);\r\nif (sk == NULL)\r\nreturn NULL;\r\nnr = nr_sk(sk);\r\nsock_init_data(NULL, sk);\r\nsk->sk_type = osk->sk_type;\r\nsk->sk_priority = osk->sk_priority;\r\nsk->sk_protocol = osk->sk_protocol;\r\nsk->sk_rcvbuf = osk->sk_rcvbuf;\r\nsk->sk_sndbuf = osk->sk_sndbuf;\r\nsk->sk_state = TCP_ESTABLISHED;\r\nsock_copy_flags(sk, osk);\r\nskb_queue_head_init(&nr->ack_queue);\r\nskb_queue_head_init(&nr->reseq_queue);\r\nskb_queue_head_init(&nr->frag_queue);\r\nnr_init_timers(sk);\r\nonr = nr_sk(osk);\r\nnr->t1 = onr->t1;\r\nnr->t2 = onr->t2;\r\nnr->n2 = onr->n2;\r\nnr->t4 = onr->t4;\r\nnr->idle = onr->idle;\r\nnr->window = onr->window;\r\nnr->device = onr->device;\r\nnr->bpqext = onr->bpqext;\r\nreturn sk;\r\n}\r\nstatic int nr_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct nr_sock *nr;\r\nif (sk == NULL) return 0;\r\nsock_hold(sk);\r\nsock_orphan(sk);\r\nlock_sock(sk);\r\nnr = nr_sk(sk);\r\nswitch (nr->state) {\r\ncase NR_STATE_0:\r\ncase NR_STATE_1:\r\ncase NR_STATE_2:\r\nnr_disconnect(sk, 0);\r\nnr_destroy_socket(sk);\r\nbreak;\r\ncase NR_STATE_3:\r\nnr_clear_queues(sk);\r\nnr->n2count = 0;\r\nnr_write_internal(sk, NR_DISCREQ);\r\nnr_start_t1timer(sk);\r\nnr_stop_t2timer(sk);\r\nnr_stop_t4timer(sk);\r\nnr_stop_idletimer(sk);\r\nnr->state = NR_STATE_2;\r\nsk->sk_state = TCP_CLOSE;\r\nsk->sk_shutdown |= SEND_SHUTDOWN;\r\nsk->sk_state_change(sk);\r\nsock_set_flag(sk, SOCK_DESTROY);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsock->sk = NULL;\r\nrelease_sock(sk);\r\nsock_put(sk);\r\nreturn 0;\r\n}\r\nstatic int nr_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct nr_sock *nr = nr_sk(sk);\r\nstruct full_sockaddr_ax25 *addr = (struct full_sockaddr_ax25 *)uaddr;\r\nstruct net_device *dev;\r\nax25_uid_assoc *user;\r\nax25_address *source;\r\nlock_sock(sk);\r\nif (!sock_flag(sk, SOCK_ZAPPED)) {\r\nrelease_sock(sk);\r\nreturn -EINVAL;\r\n}\r\nif (addr_len < sizeof(struct sockaddr_ax25) || addr_len > sizeof(struct full_sockaddr_ax25)) {\r\nrelease_sock(sk);\r\nreturn -EINVAL;\r\n}\r\nif (addr_len < (addr->fsa_ax25.sax25_ndigis * sizeof(ax25_address) + sizeof(struct sockaddr_ax25))) {\r\nrelease_sock(sk);\r\nreturn -EINVAL;\r\n}\r\nif (addr->fsa_ax25.sax25_family != AF_NETROM) {\r\nrelease_sock(sk);\r\nreturn -EINVAL;\r\n}\r\nif ((dev = nr_dev_get(&addr->fsa_ax25.sax25_call)) == NULL) {\r\nrelease_sock(sk);\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nif (addr->fsa_ax25.sax25_ndigis == 1) {\r\nif (!capable(CAP_NET_BIND_SERVICE)) {\r\ndev_put(dev);\r\nrelease_sock(sk);\r\nreturn -EPERM;\r\n}\r\nnr->user_addr = addr->fsa_digipeater[0];\r\nnr->source_addr = addr->fsa_ax25.sax25_call;\r\n} else {\r\nsource = &addr->fsa_ax25.sax25_call;\r\nuser = ax25_findbyuid(current_euid());\r\nif (user) {\r\nnr->user_addr = user->call;\r\nax25_uid_put(user);\r\n} else {\r\nif (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE)) {\r\nrelease_sock(sk);\r\ndev_put(dev);\r\nreturn -EPERM;\r\n}\r\nnr->user_addr = *source;\r\n}\r\nnr->source_addr = *source;\r\n}\r\nnr->device = dev;\r\nnr_insert_socket(sk);\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\ndev_put(dev);\r\nrelease_sock(sk);\r\nreturn 0;\r\n}\r\nstatic int nr_connect(struct socket *sock, struct sockaddr *uaddr,\r\nint addr_len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct nr_sock *nr = nr_sk(sk);\r\nstruct sockaddr_ax25 *addr = (struct sockaddr_ax25 *)uaddr;\r\nax25_address *source = NULL;\r\nax25_uid_assoc *user;\r\nstruct net_device *dev;\r\nint err = 0;\r\nlock_sock(sk);\r\nif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\r\nsock->state = SS_CONNECTED;\r\ngoto out_release;\r\n}\r\nif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\r\nsock->state = SS_UNCONNECTED;\r\nerr = -ECONNREFUSED;\r\ngoto out_release;\r\n}\r\nif (sk->sk_state == TCP_ESTABLISHED) {\r\nerr = -EISCONN;\r\ngoto out_release;\r\n}\r\nsk->sk_state = TCP_CLOSE;\r\nsock->state = SS_UNCONNECTED;\r\nif (addr_len != sizeof(struct sockaddr_ax25) && addr_len != sizeof(struct full_sockaddr_ax25)) {\r\nerr = -EINVAL;\r\ngoto out_release;\r\n}\r\nif (addr->sax25_family != AF_NETROM) {\r\nerr = -EINVAL;\r\ngoto out_release;\r\n}\r\nif (sock_flag(sk, SOCK_ZAPPED)) {\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nif ((dev = nr_dev_first()) == NULL) {\r\nerr = -ENETUNREACH;\r\ngoto out_release;\r\n}\r\nsource = (ax25_address *)dev->dev_addr;\r\nuser = ax25_findbyuid(current_euid());\r\nif (user) {\r\nnr->user_addr = user->call;\r\nax25_uid_put(user);\r\n} else {\r\nif (ax25_uid_policy && !capable(CAP_NET_ADMIN)) {\r\ndev_put(dev);\r\nerr = -EPERM;\r\ngoto out_release;\r\n}\r\nnr->user_addr = *source;\r\n}\r\nnr->source_addr = *source;\r\nnr->device = dev;\r\ndev_put(dev);\r\nnr_insert_socket(sk);\r\n}\r\nnr->dest_addr = addr->sax25_call;\r\nrelease_sock(sk);\r\ncircuit = nr_find_next_circuit();\r\nlock_sock(sk);\r\nnr->my_index = circuit / 256;\r\nnr->my_id = circuit % 256;\r\ncircuit++;\r\nsock->state = SS_CONNECTING;\r\nsk->sk_state = TCP_SYN_SENT;\r\nnr_establish_data_link(sk);\r\nnr->state = NR_STATE_1;\r\nnr_start_heartbeat(sk);\r\nif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {\r\nerr = -EINPROGRESS;\r\ngoto out_release;\r\n}\r\nif (sk->sk_state == TCP_SYN_SENT) {\r\nDEFINE_WAIT(wait);\r\nfor (;;) {\r\nprepare_to_wait(sk_sleep(sk), &wait,\r\nTASK_INTERRUPTIBLE);\r\nif (sk->sk_state != TCP_SYN_SENT)\r\nbreak;\r\nif (!signal_pending(current)) {\r\nrelease_sock(sk);\r\nschedule();\r\nlock_sock(sk);\r\ncontinue;\r\n}\r\nerr = -ERESTARTSYS;\r\nbreak;\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nif (err)\r\ngoto out_release;\r\n}\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nsock->state = SS_UNCONNECTED;\r\nerr = sock_error(sk);\r\ngoto out_release;\r\n}\r\nsock->state = SS_CONNECTED;\r\nout_release:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int nr_accept(struct socket *sock, struct socket *newsock, int flags,\r\nbool kern)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sock *newsk;\r\nDEFINE_WAIT(wait);\r\nstruct sock *sk;\r\nint err = 0;\r\nif ((sk = sock->sk) == NULL)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nif (sk->sk_type != SOCK_SEQPACKET) {\r\nerr = -EOPNOTSUPP;\r\ngoto out_release;\r\n}\r\nif (sk->sk_state != TCP_LISTEN) {\r\nerr = -EINVAL;\r\ngoto out_release;\r\n}\r\nfor (;;) {\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nskb = skb_dequeue(&sk->sk_receive_queue);\r\nif (skb)\r\nbreak;\r\nif (flags & O_NONBLOCK) {\r\nerr = -EWOULDBLOCK;\r\nbreak;\r\n}\r\nif (!signal_pending(current)) {\r\nrelease_sock(sk);\r\nschedule();\r\nlock_sock(sk);\r\ncontinue;\r\n}\r\nerr = -ERESTARTSYS;\r\nbreak;\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nif (err)\r\ngoto out_release;\r\nnewsk = skb->sk;\r\nsock_graft(newsk, newsock);\r\nkfree_skb(skb);\r\nsk_acceptq_removed(sk);\r\nout_release:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int nr_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *uaddr_len, int peer)\r\n{\r\nstruct full_sockaddr_ax25 *sax = (struct full_sockaddr_ax25 *)uaddr;\r\nstruct sock *sk = sock->sk;\r\nstruct nr_sock *nr = nr_sk(sk);\r\nmemset(&sax->fsa_ax25, 0, sizeof(struct sockaddr_ax25));\r\nlock_sock(sk);\r\nif (peer != 0) {\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nrelease_sock(sk);\r\nreturn -ENOTCONN;\r\n}\r\nsax->fsa_ax25.sax25_family = AF_NETROM;\r\nsax->fsa_ax25.sax25_ndigis = 1;\r\nsax->fsa_ax25.sax25_call = nr->user_addr;\r\nmemset(sax->fsa_digipeater, 0, sizeof(sax->fsa_digipeater));\r\nsax->fsa_digipeater[0] = nr->dest_addr;\r\n*uaddr_len = sizeof(struct full_sockaddr_ax25);\r\n} else {\r\nsax->fsa_ax25.sax25_family = AF_NETROM;\r\nsax->fsa_ax25.sax25_ndigis = 0;\r\nsax->fsa_ax25.sax25_call = nr->source_addr;\r\n*uaddr_len = sizeof(struct sockaddr_ax25);\r\n}\r\nrelease_sock(sk);\r\nreturn 0;\r\n}\r\nint nr_rx_frame(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct sock *sk;\r\nstruct sock *make;\r\nstruct nr_sock *nr_make;\r\nax25_address *src, *dest, *user;\r\nunsigned short circuit_index, circuit_id;\r\nunsigned short peer_circuit_index, peer_circuit_id;\r\nunsigned short frametype, flags, window, timeout;\r\nint ret;\r\nskb->sk = NULL;\r\nsrc = (ax25_address *)(skb->data + 0);\r\ndest = (ax25_address *)(skb->data + 7);\r\ncircuit_index = skb->data[15];\r\ncircuit_id = skb->data[16];\r\npeer_circuit_index = skb->data[17];\r\npeer_circuit_id = skb->data[18];\r\nframetype = skb->data[19] & 0x0F;\r\nflags = skb->data[19] & 0xF0;\r\nif (frametype == NR_PROTOEXT &&\r\ncircuit_index == NR_PROTO_IP && circuit_id == NR_PROTO_IP) {\r\nskb_pull(skb, NR_NETWORK_LEN + NR_TRANSPORT_LEN);\r\nskb_reset_transport_header(skb);\r\nreturn nr_rx_ip(skb, dev);\r\n}\r\nsk = NULL;\r\nif (circuit_index == 0 && circuit_id == 0) {\r\nif (frametype == NR_CONNACK && flags == NR_CHOKE_FLAG)\r\nsk = nr_find_peer(peer_circuit_index, peer_circuit_id, src);\r\n} else {\r\nif (frametype == NR_CONNREQ)\r\nsk = nr_find_peer(circuit_index, circuit_id, src);\r\nelse\r\nsk = nr_find_socket(circuit_index, circuit_id);\r\n}\r\nif (sk != NULL) {\r\nskb_reset_transport_header(skb);\r\nif (frametype == NR_CONNACK && skb->len == 22)\r\nnr_sk(sk)->bpqext = 1;\r\nelse\r\nnr_sk(sk)->bpqext = 0;\r\nret = nr_process_rx_frame(sk, skb);\r\nbh_unlock_sock(sk);\r\nreturn ret;\r\n}\r\nif (frametype != NR_CONNREQ) {\r\nif (sysctl_netrom_reset_circuit &&\r\n(frametype != NR_RESET || flags != 0))\r\nnr_transmit_reset(skb, 1);\r\nreturn 0;\r\n}\r\nsk = nr_find_listener(dest);\r\nuser = (ax25_address *)(skb->data + 21);\r\nif (sk == NULL || sk_acceptq_is_full(sk) ||\r\n(make = nr_make_new(sk)) == NULL) {\r\nnr_transmit_refusal(skb, 0);\r\nif (sk)\r\nbh_unlock_sock(sk);\r\nreturn 0;\r\n}\r\nwindow = skb->data[20];\r\nskb->sk = make;\r\nmake->sk_state = TCP_ESTABLISHED;\r\nnr_make = nr_sk(make);\r\nnr_make->source_addr = *dest;\r\nnr_make->dest_addr = *src;\r\nnr_make->user_addr = *user;\r\nnr_make->your_index = circuit_index;\r\nnr_make->your_id = circuit_id;\r\nbh_unlock_sock(sk);\r\ncircuit = nr_find_next_circuit();\r\nbh_lock_sock(sk);\r\nnr_make->my_index = circuit / 256;\r\nnr_make->my_id = circuit % 256;\r\ncircuit++;\r\nif (window < nr_make->window)\r\nnr_make->window = window;\r\nif (skb->len == 37) {\r\ntimeout = skb->data[36] * 256 + skb->data[35];\r\nif (timeout * HZ < nr_make->t1)\r\nnr_make->t1 = timeout * HZ;\r\nnr_make->bpqext = 1;\r\n} else {\r\nnr_make->bpqext = 0;\r\n}\r\nnr_write_internal(make, NR_CONNACK);\r\nnr_make->condition = 0x00;\r\nnr_make->vs = 0;\r\nnr_make->va = 0;\r\nnr_make->vr = 0;\r\nnr_make->vl = 0;\r\nnr_make->state = NR_STATE_3;\r\nsk_acceptq_added(sk);\r\nskb_queue_head(&sk->sk_receive_queue, skb);\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_data_ready(sk);\r\nbh_unlock_sock(sk);\r\nnr_insert_socket(make);\r\nnr_start_heartbeat(make);\r\nnr_start_idletimer(make);\r\nreturn 1;\r\n}\r\nstatic int nr_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct nr_sock *nr = nr_sk(sk);\r\nDECLARE_SOCKADDR(struct sockaddr_ax25 *, usax, msg->msg_name);\r\nint err;\r\nstruct sockaddr_ax25 sax;\r\nstruct sk_buff *skb;\r\nunsigned char *asmptr;\r\nint size;\r\nif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nif (sock_flag(sk, SOCK_ZAPPED)) {\r\nerr = -EADDRNOTAVAIL;\r\ngoto out;\r\n}\r\nif (sk->sk_shutdown & SEND_SHUTDOWN) {\r\nsend_sig(SIGPIPE, current, 0);\r\nerr = -EPIPE;\r\ngoto out;\r\n}\r\nif (nr->device == NULL) {\r\nerr = -ENETUNREACH;\r\ngoto out;\r\n}\r\nif (usax) {\r\nif (msg->msg_namelen < sizeof(sax)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nsax = *usax;\r\nif (ax25cmp(&nr->dest_addr, &sax.sax25_call) != 0) {\r\nerr = -EISCONN;\r\ngoto out;\r\n}\r\nif (sax.sax25_family != AF_NETROM) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n} else {\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nerr = -ENOTCONN;\r\ngoto out;\r\n}\r\nsax.sax25_family = AF_NETROM;\r\nsax.sax25_call = nr->dest_addr;\r\n}\r\nif (len > 65536) {\r\nerr = -EMSGSIZE;\r\ngoto out;\r\n}\r\nsize = len + NR_NETWORK_LEN + NR_TRANSPORT_LEN;\r\nif ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)\r\ngoto out;\r\nskb_reserve(skb, size - len);\r\nskb_reset_transport_header(skb);\r\nasmptr = skb_push(skb, NR_TRANSPORT_LEN);\r\n*asmptr++ = nr->your_index;\r\n*asmptr++ = nr->your_id;\r\n*asmptr++ = 0;\r\n*asmptr++ = 0;\r\n*asmptr++ = NR_INFO;\r\nskb_put(skb, len);\r\nif (memcpy_from_msg(skb_transport_header(skb), msg, len)) {\r\nkfree_skb(skb);\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nkfree_skb(skb);\r\nerr = -ENOTCONN;\r\ngoto out;\r\n}\r\nnr_output(sk, skb);\r\nerr = len;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int nr_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\r\nint flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nDECLARE_SOCKADDR(struct sockaddr_ax25 *, sax, msg->msg_name);\r\nsize_t copied;\r\nstruct sk_buff *skb;\r\nint er;\r\nlock_sock(sk);\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nrelease_sock(sk);\r\nreturn -ENOTCONN;\r\n}\r\nif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\r\nrelease_sock(sk);\r\nreturn er;\r\n}\r\nskb_reset_transport_header(skb);\r\ncopied = skb->len;\r\nif (copied > size) {\r\ncopied = size;\r\nmsg->msg_flags |= MSG_TRUNC;\r\n}\r\ner = skb_copy_datagram_msg(skb, 0, msg, copied);\r\nif (er < 0) {\r\nskb_free_datagram(sk, skb);\r\nrelease_sock(sk);\r\nreturn er;\r\n}\r\nif (sax != NULL) {\r\nmemset(sax, 0, sizeof(*sax));\r\nsax->sax25_family = AF_NETROM;\r\nskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\r\nAX25_ADDR_LEN);\r\nmsg->msg_namelen = sizeof(*sax);\r\n}\r\nskb_free_datagram(sk, skb);\r\nrelease_sock(sk);\r\nreturn copied;\r\n}\r\nstatic int nr_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nvoid __user *argp = (void __user *)arg;\r\nint ret;\r\nswitch (cmd) {\r\ncase TIOCOUTQ: {\r\nlong amount;\r\nlock_sock(sk);\r\namount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\r\nif (amount < 0)\r\namount = 0;\r\nrelease_sock(sk);\r\nreturn put_user(amount, (int __user *)argp);\r\n}\r\ncase TIOCINQ: {\r\nstruct sk_buff *skb;\r\nlong amount = 0L;\r\nlock_sock(sk);\r\nif ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)\r\namount = skb->len;\r\nrelease_sock(sk);\r\nreturn put_user(amount, (int __user *)argp);\r\n}\r\ncase SIOCGSTAMP:\r\nlock_sock(sk);\r\nret = sock_get_timestamp(sk, argp);\r\nrelease_sock(sk);\r\nreturn ret;\r\ncase SIOCGSTAMPNS:\r\nlock_sock(sk);\r\nret = sock_get_timestampns(sk, argp);\r\nrelease_sock(sk);\r\nreturn ret;\r\ncase SIOCGIFADDR:\r\ncase SIOCSIFADDR:\r\ncase SIOCGIFDSTADDR:\r\ncase SIOCSIFDSTADDR:\r\ncase SIOCGIFBRDADDR:\r\ncase SIOCSIFBRDADDR:\r\ncase SIOCGIFNETMASK:\r\ncase SIOCSIFNETMASK:\r\ncase SIOCGIFMETRIC:\r\ncase SIOCSIFMETRIC:\r\nreturn -EINVAL;\r\ncase SIOCADDRT:\r\ncase SIOCDELRT:\r\ncase SIOCNRDECOBS:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nreturn nr_rt_ioctl(cmd, argp);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic void *nr_info_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nspin_lock_bh(&nr_list_lock);\r\nreturn seq_hlist_start_head(&nr_list, *pos);\r\n}\r\nstatic void *nr_info_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nreturn seq_hlist_next(v, &nr_list, pos);\r\n}\r\nstatic void nr_info_stop(struct seq_file *seq, void *v)\r\n{\r\nspin_unlock_bh(&nr_list_lock);\r\n}\r\nstatic int nr_info_show(struct seq_file *seq, void *v)\r\n{\r\nstruct sock *s = sk_entry(v);\r\nstruct net_device *dev;\r\nstruct nr_sock *nr;\r\nconst char *devname;\r\nchar buf[11];\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq,\r\n"user_addr dest_node src_node dev my your st vs vr va t1 t2 t4 idle n2 wnd Snd-Q Rcv-Q inode\n");\r\nelse {\r\nbh_lock_sock(s);\r\nnr = nr_sk(s);\r\nif ((dev = nr->device) == NULL)\r\ndevname = "???";\r\nelse\r\ndevname = dev->name;\r\nseq_printf(seq, "%-9s ", ax2asc(buf, &nr->user_addr));\r\nseq_printf(seq, "%-9s ", ax2asc(buf, &nr->dest_addr));\r\nseq_printf(seq,\r\n"%-9s %-3s %02X/%02X %02X/%02X %2d %3d %3d %3d %3lu/%03lu %2lu/%02lu %3lu/%03lu %3lu/%03lu %2d/%02d %3d %5d %5d %ld\n",\r\nax2asc(buf, &nr->source_addr),\r\ndevname,\r\nnr->my_index,\r\nnr->my_id,\r\nnr->your_index,\r\nnr->your_id,\r\nnr->state,\r\nnr->vs,\r\nnr->vr,\r\nnr->va,\r\nax25_display_timer(&nr->t1timer) / HZ,\r\nnr->t1 / HZ,\r\nax25_display_timer(&nr->t2timer) / HZ,\r\nnr->t2 / HZ,\r\nax25_display_timer(&nr->t4timer) / HZ,\r\nnr->t4 / HZ,\r\nax25_display_timer(&nr->idletimer) / (60 * HZ),\r\nnr->idle / (60 * HZ),\r\nnr->n2count,\r\nnr->n2,\r\nnr->window,\r\nsk_wmem_alloc_get(s),\r\nsk_rmem_alloc_get(s),\r\ns->sk_socket ? SOCK_INODE(s->sk_socket)->i_ino : 0L);\r\nbh_unlock_sock(s);\r\n}\r\nreturn 0;\r\n}\r\nstatic int nr_info_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &nr_info_seqops);\r\n}\r\nstatic int __init nr_proto_init(void)\r\n{\r\nint i;\r\nint rc = proto_register(&nr_proto, 0);\r\nif (rc != 0)\r\ngoto out;\r\nif (nr_ndevs > 0x7fffffff/sizeof(struct net_device *)) {\r\nprintk(KERN_ERR "NET/ROM: nr_proto_init - nr_ndevs parameter to large\n");\r\nreturn -1;\r\n}\r\ndev_nr = kzalloc(nr_ndevs * sizeof(struct net_device *), GFP_KERNEL);\r\nif (dev_nr == NULL) {\r\nprintk(KERN_ERR "NET/ROM: nr_proto_init - unable to allocate device array\n");\r\nreturn -1;\r\n}\r\nfor (i = 0; i < nr_ndevs; i++) {\r\nchar name[IFNAMSIZ];\r\nstruct net_device *dev;\r\nsprintf(name, "nr%d", i);\r\ndev = alloc_netdev(0, name, NET_NAME_UNKNOWN, nr_setup);\r\nif (!dev) {\r\nprintk(KERN_ERR "NET/ROM: nr_proto_init - unable to allocate device structure\n");\r\ngoto fail;\r\n}\r\ndev->base_addr = i;\r\nif (register_netdev(dev)) {\r\nprintk(KERN_ERR "NET/ROM: nr_proto_init - unable to register network device\n");\r\nfree_netdev(dev);\r\ngoto fail;\r\n}\r\nnr_set_lockdep_key(dev);\r\ndev_nr[i] = dev;\r\n}\r\nif (sock_register(&nr_family_ops)) {\r\nprintk(KERN_ERR "NET/ROM: nr_proto_init - unable to register socket family\n");\r\ngoto fail;\r\n}\r\nregister_netdevice_notifier(&nr_dev_notifier);\r\nax25_register_pid(&nr_pid);\r\nax25_linkfail_register(&nr_linkfail_notifier);\r\n#ifdef CONFIG_SYSCTL\r\nnr_register_sysctl();\r\n#endif\r\nnr_loopback_init();\r\nproc_create("nr", S_IRUGO, init_net.proc_net, &nr_info_fops);\r\nproc_create("nr_neigh", S_IRUGO, init_net.proc_net, &nr_neigh_fops);\r\nproc_create("nr_nodes", S_IRUGO, init_net.proc_net, &nr_nodes_fops);\r\nout:\r\nreturn rc;\r\nfail:\r\nwhile (--i >= 0) {\r\nunregister_netdev(dev_nr[i]);\r\nfree_netdev(dev_nr[i]);\r\n}\r\nkfree(dev_nr);\r\nproto_unregister(&nr_proto);\r\nrc = -1;\r\ngoto out;\r\n}\r\nstatic void __exit nr_exit(void)\r\n{\r\nint i;\r\nremove_proc_entry("nr", init_net.proc_net);\r\nremove_proc_entry("nr_neigh", init_net.proc_net);\r\nremove_proc_entry("nr_nodes", init_net.proc_net);\r\nnr_loopback_clear();\r\nnr_rt_free();\r\n#ifdef CONFIG_SYSCTL\r\nnr_unregister_sysctl();\r\n#endif\r\nax25_linkfail_release(&nr_linkfail_notifier);\r\nax25_protocol_release(AX25_P_NETROM);\r\nunregister_netdevice_notifier(&nr_dev_notifier);\r\nsock_unregister(PF_NETROM);\r\nfor (i = 0; i < nr_ndevs; i++) {\r\nstruct net_device *dev = dev_nr[i];\r\nif (dev) {\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\nkfree(dev_nr);\r\nproto_unregister(&nr_proto);\r\n}
