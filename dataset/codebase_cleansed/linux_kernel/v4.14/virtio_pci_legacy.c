static u64 vp_get_features(struct virtio_device *vdev)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nreturn ioread32(vp_dev->ioaddr + VIRTIO_PCI_HOST_FEATURES);\r\n}\r\nstatic int vp_finalize_features(struct virtio_device *vdev)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nvring_transport_features(vdev);\r\nBUG_ON((u32)vdev->features != vdev->features);\r\niowrite32(vdev->features, vp_dev->ioaddr + VIRTIO_PCI_GUEST_FEATURES);\r\nreturn 0;\r\n}\r\nstatic void vp_get(struct virtio_device *vdev, unsigned offset,\r\nvoid *buf, unsigned len)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nvoid __iomem *ioaddr = vp_dev->ioaddr +\r\nVIRTIO_PCI_CONFIG(vp_dev) + offset;\r\nu8 *ptr = buf;\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nptr[i] = ioread8(ioaddr + i);\r\n}\r\nstatic void vp_set(struct virtio_device *vdev, unsigned offset,\r\nconst void *buf, unsigned len)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nvoid __iomem *ioaddr = vp_dev->ioaddr +\r\nVIRTIO_PCI_CONFIG(vp_dev) + offset;\r\nconst u8 *ptr = buf;\r\nint i;\r\nfor (i = 0; i < len; i++)\r\niowrite8(ptr[i], ioaddr + i);\r\n}\r\nstatic u8 vp_get_status(struct virtio_device *vdev)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nreturn ioread8(vp_dev->ioaddr + VIRTIO_PCI_STATUS);\r\n}\r\nstatic void vp_set_status(struct virtio_device *vdev, u8 status)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nBUG_ON(status == 0);\r\niowrite8(status, vp_dev->ioaddr + VIRTIO_PCI_STATUS);\r\n}\r\nstatic void vp_reset(struct virtio_device *vdev)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\niowrite8(0, vp_dev->ioaddr + VIRTIO_PCI_STATUS);\r\nioread8(vp_dev->ioaddr + VIRTIO_PCI_STATUS);\r\nvp_synchronize_vectors(vdev);\r\n}\r\nstatic u16 vp_config_vector(struct virtio_pci_device *vp_dev, u16 vector)\r\n{\r\niowrite16(vector, vp_dev->ioaddr + VIRTIO_MSI_CONFIG_VECTOR);\r\nreturn ioread16(vp_dev->ioaddr + VIRTIO_MSI_CONFIG_VECTOR);\r\n}\r\nstatic struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,\r\nstruct virtio_pci_vq_info *info,\r\nunsigned index,\r\nvoid (*callback)(struct virtqueue *vq),\r\nconst char *name,\r\nbool ctx,\r\nu16 msix_vec)\r\n{\r\nstruct virtqueue *vq;\r\nu16 num;\r\nint err;\r\niowrite16(index, vp_dev->ioaddr + VIRTIO_PCI_QUEUE_SEL);\r\nnum = ioread16(vp_dev->ioaddr + VIRTIO_PCI_QUEUE_NUM);\r\nif (!num || ioread32(vp_dev->ioaddr + VIRTIO_PCI_QUEUE_PFN))\r\nreturn ERR_PTR(-ENOENT);\r\ninfo->msix_vector = msix_vec;\r\nvq = vring_create_virtqueue(index, num,\r\nVIRTIO_PCI_VRING_ALIGN, &vp_dev->vdev,\r\ntrue, false, ctx,\r\nvp_notify, callback, name);\r\nif (!vq)\r\nreturn ERR_PTR(-ENOMEM);\r\niowrite32(virtqueue_get_desc_addr(vq) >> VIRTIO_PCI_QUEUE_ADDR_SHIFT,\r\nvp_dev->ioaddr + VIRTIO_PCI_QUEUE_PFN);\r\nvq->priv = (void __force *)vp_dev->ioaddr + VIRTIO_PCI_QUEUE_NOTIFY;\r\nif (msix_vec != VIRTIO_MSI_NO_VECTOR) {\r\niowrite16(msix_vec, vp_dev->ioaddr + VIRTIO_MSI_QUEUE_VECTOR);\r\nmsix_vec = ioread16(vp_dev->ioaddr + VIRTIO_MSI_QUEUE_VECTOR);\r\nif (msix_vec == VIRTIO_MSI_NO_VECTOR) {\r\nerr = -EBUSY;\r\ngoto out_deactivate;\r\n}\r\n}\r\nreturn vq;\r\nout_deactivate:\r\niowrite32(0, vp_dev->ioaddr + VIRTIO_PCI_QUEUE_PFN);\r\nvring_del_virtqueue(vq);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void del_vq(struct virtio_pci_vq_info *info)\r\n{\r\nstruct virtqueue *vq = info->vq;\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vq->vdev);\r\niowrite16(vq->index, vp_dev->ioaddr + VIRTIO_PCI_QUEUE_SEL);\r\nif (vp_dev->msix_enabled) {\r\niowrite16(VIRTIO_MSI_NO_VECTOR,\r\nvp_dev->ioaddr + VIRTIO_MSI_QUEUE_VECTOR);\r\nioread8(vp_dev->ioaddr + VIRTIO_PCI_ISR);\r\n}\r\niowrite32(0, vp_dev->ioaddr + VIRTIO_PCI_QUEUE_PFN);\r\nvring_del_virtqueue(vq);\r\n}\r\nint virtio_pci_legacy_probe(struct virtio_pci_device *vp_dev)\r\n{\r\nstruct pci_dev *pci_dev = vp_dev->pci_dev;\r\nint rc;\r\nif (pci_dev->device < 0x1000 || pci_dev->device > 0x103f)\r\nreturn -ENODEV;\r\nif (pci_dev->revision != VIRTIO_PCI_ABI_VERSION) {\r\nprintk(KERN_ERR "virtio_pci: expected ABI version %d, got %d\n",\r\nVIRTIO_PCI_ABI_VERSION, pci_dev->revision);\r\nreturn -ENODEV;\r\n}\r\nrc = dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(64));\r\nif (rc) {\r\nrc = dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(32));\r\n} else {\r\ndma_set_coherent_mask(&pci_dev->dev,\r\nDMA_BIT_MASK(32 + VIRTIO_PCI_QUEUE_ADDR_SHIFT));\r\n}\r\nif (rc)\r\ndev_warn(&pci_dev->dev, "Failed to enable 64-bit or 32-bit DMA. Trying to continue, but this might not work.\n");\r\nrc = pci_request_region(pci_dev, 0, "virtio-pci-legacy");\r\nif (rc)\r\nreturn rc;\r\nrc = -ENOMEM;\r\nvp_dev->ioaddr = pci_iomap(pci_dev, 0, 0);\r\nif (!vp_dev->ioaddr)\r\ngoto err_iomap;\r\nvp_dev->isr = vp_dev->ioaddr + VIRTIO_PCI_ISR;\r\nvp_dev->vdev.id.vendor = pci_dev->subsystem_vendor;\r\nvp_dev->vdev.id.device = pci_dev->subsystem_device;\r\nvp_dev->vdev.config = &virtio_pci_config_ops;\r\nvp_dev->config_vector = vp_config_vector;\r\nvp_dev->setup_vq = setup_vq;\r\nvp_dev->del_vq = del_vq;\r\nreturn 0;\r\nerr_iomap:\r\npci_release_region(pci_dev, 0);\r\nreturn rc;\r\n}\r\nvoid virtio_pci_legacy_remove(struct virtio_pci_device *vp_dev)\r\n{\r\nstruct pci_dev *pci_dev = vp_dev->pci_dev;\r\npci_iounmap(pci_dev, vp_dev->ioaddr);\r\npci_release_region(pci_dev, 0);\r\n}
