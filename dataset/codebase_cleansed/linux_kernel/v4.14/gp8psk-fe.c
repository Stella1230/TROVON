static int gp8psk_tuned_to_DCII(struct dvb_frontend *fe)\r\n{\r\nstruct gp8psk_fe_state *st = fe->demodulator_priv;\r\nu8 status;\r\nst->ops->in(st->priv, GET_8PSK_CONFIG, 0, 0, &status, 1);\r\nreturn status & bmDCtuned;\r\n}\r\nstatic int gp8psk_set_tuner_mode(struct dvb_frontend *fe, int mode)\r\n{\r\nstruct gp8psk_fe_state *st = fe->demodulator_priv;\r\nreturn st->ops->out(st->priv, SET_8PSK_CONFIG, mode, 0, NULL, 0);\r\n}\r\nstatic int gp8psk_fe_update_status(struct gp8psk_fe_state *st)\r\n{\r\nu8 buf[6];\r\nif (time_after(jiffies,st->next_status_check)) {\r\nst->ops->in(st->priv, GET_SIGNAL_LOCK, 0, 0, &st->lock, 1);\r\nst->ops->in(st->priv, GET_SIGNAL_STRENGTH, 0, 0, buf, 6);\r\nst->snr = (buf[1]) << 8 | buf[0];\r\nst->next_status_check = jiffies + (st->status_check_interval*HZ)/1000;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gp8psk_fe_read_status(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nstruct gp8psk_fe_state *st = fe->demodulator_priv;\r\ngp8psk_fe_update_status(st);\r\nif (st->lock)\r\n*status = FE_HAS_LOCK | FE_HAS_SYNC | FE_HAS_VITERBI | FE_HAS_SIGNAL | FE_HAS_CARRIER;\r\nelse\r\n*status = 0;\r\nif (*status & FE_HAS_LOCK)\r\nst->status_check_interval = 1000;\r\nelse\r\nst->status_check_interval = 100;\r\nreturn 0;\r\n}\r\nstatic int gp8psk_fe_read_ber(struct dvb_frontend* fe, u32 *ber)\r\n{\r\n(void) fe;\r\n*ber = 0;\r\nreturn 0;\r\n}\r\nstatic int gp8psk_fe_read_unc_blocks(struct dvb_frontend* fe, u32 *unc)\r\n{\r\n(void) fe;\r\n*unc = 0;\r\nreturn 0;\r\n}\r\nstatic int gp8psk_fe_read_snr(struct dvb_frontend* fe, u16 *snr)\r\n{\r\nstruct gp8psk_fe_state *st = fe->demodulator_priv;\r\ngp8psk_fe_update_status(st);\r\n*snr = st->snr;\r\nreturn 0;\r\n}\r\nstatic int gp8psk_fe_read_signal_strength(struct dvb_frontend* fe, u16 *strength)\r\n{\r\nstruct gp8psk_fe_state *st = fe->demodulator_priv;\r\ngp8psk_fe_update_status(st);\r\nif (st->snr > 0xf00)\r\n*strength = 0xffff;\r\nelse\r\n*strength = (st->snr << 4) + st->snr;\r\nreturn 0;\r\n}\r\nstatic int gp8psk_fe_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 800;\r\nreturn 0;\r\n}\r\nstatic int gp8psk_fe_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct gp8psk_fe_state *st = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu8 cmd[10];\r\nu32 freq = c->frequency * 1000;\r\ndprintk("%s()\n", __func__);\r\ncmd[4] = freq & 0xff;\r\ncmd[5] = (freq >> 8) & 0xff;\r\ncmd[6] = (freq >> 16) & 0xff;\r\ncmd[7] = (freq >> 24) & 0xff;\r\nif (c->delivery_system == SYS_DVBS && c->modulation == PSK_8)\r\nc->delivery_system = SYS_TURBO;\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nif (c->modulation != QPSK) {\r\ndprintk("%s: unsupported modulation selected (%d)\n",\r\n__func__, c->modulation);\r\nreturn -EOPNOTSUPP;\r\n}\r\nc->fec_inner = FEC_AUTO;\r\nbreak;\r\ncase SYS_DVBS2:\r\ndprintk("%s: DVB-S2 delivery system selected\n", __func__);\r\nbreak;\r\ncase SYS_TURBO:\r\ndprintk("%s: Turbo-FEC delivery system selected\n", __func__);\r\nbreak;\r\ndefault:\r\ndprintk("%s: unsupported delivery system selected (%d)\n",\r\n__func__, c->delivery_system);\r\nreturn -EOPNOTSUPP;\r\n}\r\ncmd[0] = c->symbol_rate & 0xff;\r\ncmd[1] = (c->symbol_rate >> 8) & 0xff;\r\ncmd[2] = (c->symbol_rate >> 16) & 0xff;\r\ncmd[3] = (c->symbol_rate >> 24) & 0xff;\r\nswitch (c->modulation) {\r\ncase QPSK:\r\nif (st->is_rev1)\r\nif (gp8psk_tuned_to_DCII(fe))\r\nst->ops->reload(st->priv);\r\nswitch (c->fec_inner) {\r\ncase FEC_1_2:\r\ncmd[9] = 0; break;\r\ncase FEC_2_3:\r\ncmd[9] = 1; break;\r\ncase FEC_3_4:\r\ncmd[9] = 2; break;\r\ncase FEC_5_6:\r\ncmd[9] = 3; break;\r\ncase FEC_7_8:\r\ncmd[9] = 4; break;\r\ncase FEC_AUTO:\r\ncmd[9] = 5; break;\r\ndefault:\r\ncmd[9] = 5; break;\r\n}\r\nif (c->delivery_system == SYS_TURBO)\r\ncmd[8] = ADV_MOD_TURBO_QPSK;\r\nelse\r\ncmd[8] = ADV_MOD_DVB_QPSK;\r\nbreak;\r\ncase PSK_8:\r\ncmd[8] = ADV_MOD_TURBO_8PSK;\r\nswitch (c->fec_inner) {\r\ncase FEC_2_3:\r\ncmd[9] = 0; break;\r\ncase FEC_3_4:\r\ncmd[9] = 1; break;\r\ncase FEC_3_5:\r\ncmd[9] = 2; break;\r\ncase FEC_5_6:\r\ncmd[9] = 3; break;\r\ncase FEC_8_9:\r\ncmd[9] = 4; break;\r\ndefault:\r\ncmd[9] = 0; break;\r\n}\r\nbreak;\r\ncase QAM_16:\r\ncmd[8] = ADV_MOD_TURBO_16QAM;\r\ncmd[9] = 0;\r\nbreak;\r\ndefault:\r\ndprintk("%s: unsupported modulation selected (%d)\n",\r\n__func__, c->modulation);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (st->is_rev1)\r\ngp8psk_set_tuner_mode(fe, 0);\r\nst->ops->out(st->priv, TUNE_8PSK, 0, 0, cmd, 10);\r\nst->lock = 0;\r\nst->next_status_check = jiffies;\r\nst->status_check_interval = 200;\r\nreturn 0;\r\n}\r\nstatic int gp8psk_fe_send_diseqc_msg (struct dvb_frontend* fe,\r\nstruct dvb_diseqc_master_cmd *m)\r\n{\r\nstruct gp8psk_fe_state *st = fe->demodulator_priv;\r\ndprintk("%s\n", __func__);\r\nif (st->ops->out(st->priv, SEND_DISEQC_COMMAND, m->msg[0], 0,\r\nm->msg, m->msg_len)) {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gp8psk_fe_send_diseqc_burst(struct dvb_frontend *fe,\r\nenum fe_sec_mini_cmd burst)\r\n{\r\nstruct gp8psk_fe_state *st = fe->demodulator_priv;\r\nu8 cmd;\r\ndprintk("%s\n", __func__);\r\ncmd = (burst == SEC_MINI_A) ? 0x00 : 0x01;\r\nif (st->ops->out(st->priv, SEND_DISEQC_COMMAND, cmd, 0,\r\n&cmd, 0)) {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gp8psk_fe_set_tone(struct dvb_frontend *fe,\r\nenum fe_sec_tone_mode tone)\r\n{\r\nstruct gp8psk_fe_state *st = fe->demodulator_priv;\r\nif (st->ops->out(st->priv, SET_22KHZ_TONE,\r\n(tone == SEC_TONE_ON), 0, NULL, 0)) {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gp8psk_fe_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nstruct gp8psk_fe_state *st = fe->demodulator_priv;\r\nif (st->ops->out(st->priv, SET_LNB_VOLTAGE,\r\nvoltage == SEC_VOLTAGE_18, 0, NULL, 0)) {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gp8psk_fe_enable_high_lnb_voltage(struct dvb_frontend* fe, long onoff)\r\n{\r\nstruct gp8psk_fe_state *st = fe->demodulator_priv;\r\nreturn st->ops->out(st->priv, USE_EXTRA_VOLT, onoff, 0, NULL, 0);\r\n}\r\nstatic int gp8psk_fe_send_legacy_dish_cmd (struct dvb_frontend* fe, unsigned long sw_cmd)\r\n{\r\nstruct gp8psk_fe_state *st = fe->demodulator_priv;\r\nu8 cmd = sw_cmd & 0x7f;\r\nif (st->ops->out(st->priv, SET_DN_SWITCH, cmd, 0, NULL, 0))\r\nreturn -EINVAL;\r\nif (st->ops->out(st->priv, SET_LNB_VOLTAGE, !!(sw_cmd & 0x80),\r\n0, NULL, 0))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void gp8psk_fe_release(struct dvb_frontend* fe)\r\n{\r\nstruct gp8psk_fe_state *st = fe->demodulator_priv;\r\nkfree(st);\r\n}\r\nstruct dvb_frontend *gp8psk_fe_attach(const struct gp8psk_fe_ops *ops,\r\nvoid *priv, bool is_rev1)\r\n{\r\nstruct gp8psk_fe_state *st;\r\nif (!ops || !ops->in || !ops->out || !ops->reload) {\r\npr_err("Error! gp8psk-fe ops not defined.\n");\r\nreturn NULL;\r\n}\r\nst = kzalloc(sizeof(struct gp8psk_fe_state), GFP_KERNEL);\r\nif (!st)\r\nreturn NULL;\r\nmemcpy(&st->fe.ops, &gp8psk_fe_ops, sizeof(struct dvb_frontend_ops));\r\nst->fe.demodulator_priv = st;\r\nst->ops = ops;\r\nst->priv = priv;\r\nst->is_rev1 = is_rev1;\r\npr_info("Frontend %sattached\n", is_rev1 ? "revision 1 " : "");\r\nreturn &st->fe;\r\n}
