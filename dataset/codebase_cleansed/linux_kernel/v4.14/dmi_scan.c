static const char * __init dmi_string_nosave(const struct dmi_header *dm, u8 s)\r\n{\r\nconst u8 *bp = ((u8 *) dm) + dm->length;\r\nif (s) {\r\ns--;\r\nwhile (s > 0 && *bp) {\r\nbp += strlen(bp) + 1;\r\ns--;\r\n}\r\nif (*bp != 0) {\r\nsize_t len = strlen(bp)+1;\r\nsize_t cmp_len = len > 8 ? 8 : len;\r\nif (!memcmp(bp, dmi_empty_string, cmp_len))\r\nreturn dmi_empty_string;\r\nreturn bp;\r\n}\r\n}\r\nreturn "";\r\n}\r\nstatic const char * __init dmi_string(const struct dmi_header *dm, u8 s)\r\n{\r\nconst char *bp = dmi_string_nosave(dm, s);\r\nchar *str;\r\nsize_t len;\r\nif (bp == dmi_empty_string)\r\nreturn dmi_empty_string;\r\nlen = strlen(bp) + 1;\r\nstr = dmi_alloc(len);\r\nif (str != NULL)\r\nstrcpy(str, bp);\r\nreturn str;\r\n}\r\nstatic void dmi_decode_table(u8 *buf,\r\nvoid (*decode)(const struct dmi_header *, void *),\r\nvoid *private_data)\r\n{\r\nu8 *data = buf;\r\nint i = 0;\r\nwhile ((!dmi_num || i < dmi_num) &&\r\n(data - buf + sizeof(struct dmi_header)) <= dmi_len) {\r\nconst struct dmi_header *dm = (const struct dmi_header *)data;\r\ndata += dm->length;\r\nwhile ((data - buf < dmi_len - 1) && (data[0] || data[1]))\r\ndata++;\r\nif (data - buf < dmi_len - 1)\r\ndecode(dm, private_data);\r\ndata += 2;\r\ni++;\r\nif (!dmi_num && dm->type == DMI_ENTRY_END_OF_TABLE)\r\nbreak;\r\n}\r\nif (dmi_len > data - buf)\r\ndmi_len = data - buf;\r\n}\r\nstatic int __init dmi_walk_early(void (*decode)(const struct dmi_header *,\r\nvoid *))\r\n{\r\nu8 *buf;\r\nu32 orig_dmi_len = dmi_len;\r\nbuf = dmi_early_remap(dmi_base, orig_dmi_len);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\ndmi_decode_table(buf, decode, NULL);\r\nadd_device_randomness(buf, dmi_len);\r\ndmi_early_unmap(buf, orig_dmi_len);\r\nreturn 0;\r\n}\r\nstatic int __init dmi_checksum(const u8 *buf, u8 len)\r\n{\r\nu8 sum = 0;\r\nint a;\r\nfor (a = 0; a < len; a++)\r\nsum += buf[a];\r\nreturn sum == 0;\r\n}\r\nstatic void __init dmi_save_ident(const struct dmi_header *dm, int slot,\r\nint string)\r\n{\r\nconst char *d = (const char *) dm;\r\nconst char *p;\r\nif (dmi_ident[slot] || dm->length <= string)\r\nreturn;\r\np = dmi_string(dm, d[string]);\r\nif (p == NULL)\r\nreturn;\r\ndmi_ident[slot] = p;\r\n}\r\nstatic void __init dmi_save_uuid(const struct dmi_header *dm, int slot,\r\nint index)\r\n{\r\nconst u8 *d;\r\nchar *s;\r\nint is_ff = 1, is_00 = 1, i;\r\nif (dmi_ident[slot] || dm->length <= index + 16)\r\nreturn;\r\nd = (u8 *) dm + index;\r\nfor (i = 0; i < 16 && (is_ff || is_00); i++) {\r\nif (d[i] != 0x00)\r\nis_00 = 0;\r\nif (d[i] != 0xFF)\r\nis_ff = 0;\r\n}\r\nif (is_ff || is_00)\r\nreturn;\r\ns = dmi_alloc(16*2+4+1);\r\nif (!s)\r\nreturn;\r\nif (dmi_ver >= 0x020600)\r\nsprintf(s, "%pUL", d);\r\nelse\r\nsprintf(s, "%pUB", d);\r\ndmi_ident[slot] = s;\r\n}\r\nstatic void __init dmi_save_type(const struct dmi_header *dm, int slot,\r\nint index)\r\n{\r\nconst u8 *d;\r\nchar *s;\r\nif (dmi_ident[slot] || dm->length <= index)\r\nreturn;\r\ns = dmi_alloc(4);\r\nif (!s)\r\nreturn;\r\nd = (u8 *) dm + index;\r\nsprintf(s, "%u", *d & 0x7F);\r\ndmi_ident[slot] = s;\r\n}\r\nstatic void __init dmi_save_one_device(int type, const char *name)\r\n{\r\nstruct dmi_device *dev;\r\nif (dmi_find_device(type, name, NULL))\r\nreturn;\r\ndev = dmi_alloc(sizeof(*dev) + strlen(name) + 1);\r\nif (!dev)\r\nreturn;\r\ndev->type = type;\r\nstrcpy((char *)(dev + 1), name);\r\ndev->name = (char *)(dev + 1);\r\ndev->device_data = NULL;\r\nlist_add(&dev->list, &dmi_devices);\r\n}\r\nstatic void __init dmi_save_devices(const struct dmi_header *dm)\r\n{\r\nint i, count = (dm->length - sizeof(struct dmi_header)) / 2;\r\nfor (i = 0; i < count; i++) {\r\nconst char *d = (char *)(dm + 1) + (i * 2);\r\nif ((*d & 0x80) == 0)\r\ncontinue;\r\ndmi_save_one_device(*d & 0x7f, dmi_string_nosave(dm, *(d + 1)));\r\n}\r\n}\r\nstatic void __init dmi_save_oem_strings_devices(const struct dmi_header *dm)\r\n{\r\nint i, count;\r\nstruct dmi_device *dev;\r\nif (dm->length < 0x05)\r\nreturn;\r\ncount = *(u8 *)(dm + 1);\r\nfor (i = 1; i <= count; i++) {\r\nconst char *devname = dmi_string(dm, i);\r\nif (devname == dmi_empty_string)\r\ncontinue;\r\ndev = dmi_alloc(sizeof(*dev));\r\nif (!dev)\r\nbreak;\r\ndev->type = DMI_DEV_TYPE_OEM_STRING;\r\ndev->name = devname;\r\ndev->device_data = NULL;\r\nlist_add(&dev->list, &dmi_devices);\r\n}\r\n}\r\nstatic void __init dmi_save_ipmi_device(const struct dmi_header *dm)\r\n{\r\nstruct dmi_device *dev;\r\nvoid *data;\r\ndata = dmi_alloc(dm->length);\r\nif (data == NULL)\r\nreturn;\r\nmemcpy(data, dm, dm->length);\r\ndev = dmi_alloc(sizeof(*dev));\r\nif (!dev)\r\nreturn;\r\ndev->type = DMI_DEV_TYPE_IPMI;\r\ndev->name = "IPMI controller";\r\ndev->device_data = data;\r\nlist_add_tail(&dev->list, &dmi_devices);\r\n}\r\nstatic void __init dmi_save_dev_pciaddr(int instance, int segment, int bus,\r\nint devfn, const char *name, int type)\r\n{\r\nstruct dmi_dev_onboard *dev;\r\nif (type == DMI_DEV_TYPE_DEV_SLOT &&\r\nsegment == 0xFFFF && bus == 0xFF && devfn == 0xFF)\r\nreturn;\r\ndev = dmi_alloc(sizeof(*dev) + strlen(name) + 1);\r\nif (!dev)\r\nreturn;\r\ndev->instance = instance;\r\ndev->segment = segment;\r\ndev->bus = bus;\r\ndev->devfn = devfn;\r\nstrcpy((char *)&dev[1], name);\r\ndev->dev.type = type;\r\ndev->dev.name = (char *)&dev[1];\r\ndev->dev.device_data = dev;\r\nlist_add(&dev->dev.list, &dmi_devices);\r\n}\r\nstatic void __init dmi_save_extended_devices(const struct dmi_header *dm)\r\n{\r\nconst char *name;\r\nconst u8 *d = (u8 *)dm;\r\nif (dm->length < 0x0B)\r\nreturn;\r\nif ((d[0x5] & 0x80) == 0)\r\nreturn;\r\nname = dmi_string_nosave(dm, d[0x4]);\r\ndmi_save_dev_pciaddr(d[0x6], *(u16 *)(d + 0x7), d[0x9], d[0xA], name,\r\nDMI_DEV_TYPE_DEV_ONBOARD);\r\ndmi_save_one_device(d[0x5] & 0x7f, name);\r\n}\r\nstatic void __init dmi_save_system_slot(const struct dmi_header *dm)\r\n{\r\nconst u8 *d = (u8 *)dm;\r\nif (dm->length < 0x11)\r\nreturn;\r\ndmi_save_dev_pciaddr(*(u16 *)(d + 0x9), *(u16 *)(d + 0xD), d[0xF],\r\nd[0x10], dmi_string_nosave(dm, d[0x4]),\r\nDMI_DEV_TYPE_DEV_SLOT);\r\n}\r\nstatic void __init count_mem_devices(const struct dmi_header *dm, void *v)\r\n{\r\nif (dm->type != DMI_ENTRY_MEM_DEVICE)\r\nreturn;\r\ndmi_memdev_nr++;\r\n}\r\nstatic void __init save_mem_devices(const struct dmi_header *dm, void *v)\r\n{\r\nconst char *d = (const char *)dm;\r\nstatic int nr;\r\nif (dm->type != DMI_ENTRY_MEM_DEVICE || dm->length < 0x12)\r\nreturn;\r\nif (nr >= dmi_memdev_nr) {\r\npr_warn(FW_BUG "Too many DIMM entries in SMBIOS table\n");\r\nreturn;\r\n}\r\ndmi_memdev[nr].handle = get_unaligned(&dm->handle);\r\ndmi_memdev[nr].device = dmi_string(dm, d[0x10]);\r\ndmi_memdev[nr].bank = dmi_string(dm, d[0x11]);\r\nnr++;\r\n}\r\nvoid __init dmi_memdev_walk(void)\r\n{\r\nif (!dmi_available)\r\nreturn;\r\nif (dmi_walk_early(count_mem_devices) == 0 && dmi_memdev_nr) {\r\ndmi_memdev = dmi_alloc(sizeof(*dmi_memdev) * dmi_memdev_nr);\r\nif (dmi_memdev)\r\ndmi_walk_early(save_mem_devices);\r\n}\r\n}\r\nstatic void __init dmi_decode(const struct dmi_header *dm, void *dummy)\r\n{\r\nswitch (dm->type) {\r\ncase 0:\r\ndmi_save_ident(dm, DMI_BIOS_VENDOR, 4);\r\ndmi_save_ident(dm, DMI_BIOS_VERSION, 5);\r\ndmi_save_ident(dm, DMI_BIOS_DATE, 8);\r\nbreak;\r\ncase 1:\r\ndmi_save_ident(dm, DMI_SYS_VENDOR, 4);\r\ndmi_save_ident(dm, DMI_PRODUCT_NAME, 5);\r\ndmi_save_ident(dm, DMI_PRODUCT_VERSION, 6);\r\ndmi_save_ident(dm, DMI_PRODUCT_SERIAL, 7);\r\ndmi_save_uuid(dm, DMI_PRODUCT_UUID, 8);\r\ndmi_save_ident(dm, DMI_PRODUCT_FAMILY, 26);\r\nbreak;\r\ncase 2:\r\ndmi_save_ident(dm, DMI_BOARD_VENDOR, 4);\r\ndmi_save_ident(dm, DMI_BOARD_NAME, 5);\r\ndmi_save_ident(dm, DMI_BOARD_VERSION, 6);\r\ndmi_save_ident(dm, DMI_BOARD_SERIAL, 7);\r\ndmi_save_ident(dm, DMI_BOARD_ASSET_TAG, 8);\r\nbreak;\r\ncase 3:\r\ndmi_save_ident(dm, DMI_CHASSIS_VENDOR, 4);\r\ndmi_save_type(dm, DMI_CHASSIS_TYPE, 5);\r\ndmi_save_ident(dm, DMI_CHASSIS_VERSION, 6);\r\ndmi_save_ident(dm, DMI_CHASSIS_SERIAL, 7);\r\ndmi_save_ident(dm, DMI_CHASSIS_ASSET_TAG, 8);\r\nbreak;\r\ncase 9:\r\ndmi_save_system_slot(dm);\r\nbreak;\r\ncase 10:\r\ndmi_save_devices(dm);\r\nbreak;\r\ncase 11:\r\ndmi_save_oem_strings_devices(dm);\r\nbreak;\r\ncase 38:\r\ndmi_save_ipmi_device(dm);\r\nbreak;\r\ncase 41:\r\ndmi_save_extended_devices(dm);\r\n}\r\n}\r\nstatic int __init print_filtered(char *buf, size_t len, const char *info)\r\n{\r\nint c = 0;\r\nconst char *p;\r\nif (!info)\r\nreturn c;\r\nfor (p = info; *p; p++)\r\nif (isprint(*p))\r\nc += scnprintf(buf + c, len - c, "%c", *p);\r\nelse\r\nc += scnprintf(buf + c, len - c, "\\x%02x", *p & 0xff);\r\nreturn c;\r\n}\r\nstatic void __init dmi_format_ids(char *buf, size_t len)\r\n{\r\nint c = 0;\r\nconst char *board;\r\nc += print_filtered(buf + c, len - c,\r\ndmi_get_system_info(DMI_SYS_VENDOR));\r\nc += scnprintf(buf + c, len - c, " ");\r\nc += print_filtered(buf + c, len - c,\r\ndmi_get_system_info(DMI_PRODUCT_NAME));\r\nboard = dmi_get_system_info(DMI_BOARD_NAME);\r\nif (board) {\r\nc += scnprintf(buf + c, len - c, "/");\r\nc += print_filtered(buf + c, len - c, board);\r\n}\r\nc += scnprintf(buf + c, len - c, ", BIOS ");\r\nc += print_filtered(buf + c, len - c,\r\ndmi_get_system_info(DMI_BIOS_VERSION));\r\nc += scnprintf(buf + c, len - c, " ");\r\nc += print_filtered(buf + c, len - c,\r\ndmi_get_system_info(DMI_BIOS_DATE));\r\n}\r\nstatic int __init dmi_present(const u8 *buf)\r\n{\r\nu32 smbios_ver;\r\nif (memcmp(buf, "_SM_", 4) == 0 &&\r\nbuf[5] < 32 && dmi_checksum(buf, buf[5])) {\r\nsmbios_ver = get_unaligned_be16(buf + 6);\r\nsmbios_entry_point_size = buf[5];\r\nmemcpy(smbios_entry_point, buf, smbios_entry_point_size);\r\nswitch (smbios_ver) {\r\ncase 0x021F:\r\ncase 0x0221:\r\npr_debug("SMBIOS version fixup (2.%d->2.%d)\n",\r\nsmbios_ver & 0xFF, 3);\r\nsmbios_ver = 0x0203;\r\nbreak;\r\ncase 0x0233:\r\npr_debug("SMBIOS version fixup (2.%d->2.%d)\n", 51, 6);\r\nsmbios_ver = 0x0206;\r\nbreak;\r\n}\r\n} else {\r\nsmbios_ver = 0;\r\n}\r\nbuf += 16;\r\nif (memcmp(buf, "_DMI_", 5) == 0 && dmi_checksum(buf, 15)) {\r\nif (smbios_ver)\r\ndmi_ver = smbios_ver;\r\nelse\r\ndmi_ver = (buf[14] & 0xF0) << 4 | (buf[14] & 0x0F);\r\ndmi_ver <<= 8;\r\ndmi_num = get_unaligned_le16(buf + 12);\r\ndmi_len = get_unaligned_le16(buf + 6);\r\ndmi_base = get_unaligned_le32(buf + 8);\r\nif (dmi_walk_early(dmi_decode) == 0) {\r\nif (smbios_ver) {\r\npr_info("SMBIOS %d.%d present.\n",\r\ndmi_ver >> 16, (dmi_ver >> 8) & 0xFF);\r\n} else {\r\nsmbios_entry_point_size = 15;\r\nmemcpy(smbios_entry_point, buf,\r\nsmbios_entry_point_size);\r\npr_info("Legacy DMI %d.%d present.\n",\r\ndmi_ver >> 16, (dmi_ver >> 8) & 0xFF);\r\n}\r\ndmi_format_ids(dmi_ids_string, sizeof(dmi_ids_string));\r\npr_info("DMI: %s\n", dmi_ids_string);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init dmi_smbios3_present(const u8 *buf)\r\n{\r\nif (memcmp(buf, "_SM3_", 5) == 0 &&\r\nbuf[6] < 32 && dmi_checksum(buf, buf[6])) {\r\ndmi_ver = get_unaligned_be32(buf + 6) & 0xFFFFFF;\r\ndmi_num = 0;\r\ndmi_len = get_unaligned_le32(buf + 12);\r\ndmi_base = get_unaligned_le64(buf + 16);\r\nsmbios_entry_point_size = buf[6];\r\nmemcpy(smbios_entry_point, buf, smbios_entry_point_size);\r\nif (dmi_walk_early(dmi_decode) == 0) {\r\npr_info("SMBIOS %d.%d.%d present.\n",\r\ndmi_ver >> 16, (dmi_ver >> 8) & 0xFF,\r\ndmi_ver & 0xFF);\r\ndmi_format_ids(dmi_ids_string, sizeof(dmi_ids_string));\r\npr_info("DMI: %s\n", dmi_ids_string);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nvoid __init dmi_scan_machine(void)\r\n{\r\nchar __iomem *p, *q;\r\nchar buf[32];\r\nif (efi_enabled(EFI_CONFIG_TABLES)) {\r\nif (efi.smbios3 != EFI_INVALID_TABLE_ADDR) {\r\np = dmi_early_remap(efi.smbios3, 32);\r\nif (p == NULL)\r\ngoto error;\r\nmemcpy_fromio(buf, p, 32);\r\ndmi_early_unmap(p, 32);\r\nif (!dmi_smbios3_present(buf)) {\r\ndmi_available = 1;\r\ngoto out;\r\n}\r\n}\r\nif (efi.smbios == EFI_INVALID_TABLE_ADDR)\r\ngoto error;\r\np = dmi_early_remap(efi.smbios, 32);\r\nif (p == NULL)\r\ngoto error;\r\nmemcpy_fromio(buf, p, 32);\r\ndmi_early_unmap(p, 32);\r\nif (!dmi_present(buf)) {\r\ndmi_available = 1;\r\ngoto out;\r\n}\r\n} else if (IS_ENABLED(CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK)) {\r\np = dmi_early_remap(0xF0000, 0x10000);\r\nif (p == NULL)\r\ngoto error;\r\nmemcpy_fromio(buf, p, 16);\r\nfor (q = p + 16; q < p + 0x10000; q += 16) {\r\nmemcpy_fromio(buf + 16, q, 16);\r\nif (!dmi_smbios3_present(buf)) {\r\ndmi_available = 1;\r\ndmi_early_unmap(p, 0x10000);\r\ngoto out;\r\n}\r\nmemcpy(buf, buf + 16, 16);\r\n}\r\nmemset(buf, 0, 16);\r\nfor (q = p; q < p + 0x10000; q += 16) {\r\nmemcpy_fromio(buf + 16, q, 16);\r\nif (!dmi_present(buf)) {\r\ndmi_available = 1;\r\ndmi_early_unmap(p, 0x10000);\r\ngoto out;\r\n}\r\nmemcpy(buf, buf + 16, 16);\r\n}\r\ndmi_early_unmap(p, 0x10000);\r\n}\r\nerror:\r\npr_info("DMI not present or invalid.\n");\r\nout:\r\ndmi_initialized = 1;\r\n}\r\nstatic ssize_t raw_table_read(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf,\r\nloff_t pos, size_t count)\r\n{\r\nmemcpy(buf, attr->private + pos, count);\r\nreturn count;\r\n}\r\nstatic int __init dmi_init(void)\r\n{\r\nstruct kobject *tables_kobj;\r\nu8 *dmi_table;\r\nint ret = -ENOMEM;\r\nif (!dmi_available) {\r\nret = -ENODATA;\r\ngoto err;\r\n}\r\ndmi_kobj = kobject_create_and_add("dmi", firmware_kobj);\r\nif (!dmi_kobj)\r\ngoto err;\r\ntables_kobj = kobject_create_and_add("tables", dmi_kobj);\r\nif (!tables_kobj)\r\ngoto err;\r\ndmi_table = dmi_remap(dmi_base, dmi_len);\r\nif (!dmi_table)\r\ngoto err_tables;\r\nbin_attr_smbios_entry_point.size = smbios_entry_point_size;\r\nbin_attr_smbios_entry_point.private = smbios_entry_point;\r\nret = sysfs_create_bin_file(tables_kobj, &bin_attr_smbios_entry_point);\r\nif (ret)\r\ngoto err_unmap;\r\nbin_attr_DMI.size = dmi_len;\r\nbin_attr_DMI.private = dmi_table;\r\nret = sysfs_create_bin_file(tables_kobj, &bin_attr_DMI);\r\nif (!ret)\r\nreturn 0;\r\nsysfs_remove_bin_file(tables_kobj,\r\n&bin_attr_smbios_entry_point);\r\nerr_unmap:\r\ndmi_unmap(dmi_table);\r\nerr_tables:\r\nkobject_del(tables_kobj);\r\nkobject_put(tables_kobj);\r\nerr:\r\npr_err("dmi: Firmware registration failed.\n");\r\nreturn ret;\r\n}\r\nvoid __init dmi_set_dump_stack_arch_desc(void)\r\n{\r\ndump_stack_set_arch_desc("%s", dmi_ids_string);\r\n}\r\nstatic bool dmi_matches(const struct dmi_system_id *dmi)\r\n{\r\nint i;\r\nWARN(!dmi_initialized, KERN_ERR "dmi check: not initialized yet.\n");\r\nfor (i = 0; i < ARRAY_SIZE(dmi->matches); i++) {\r\nint s = dmi->matches[i].slot;\r\nif (s == DMI_NONE)\r\nbreak;\r\nif (dmi_ident[s]) {\r\nif (!dmi->matches[i].exact_match &&\r\nstrstr(dmi_ident[s], dmi->matches[i].substr))\r\ncontinue;\r\nelse if (dmi->matches[i].exact_match &&\r\n!strcmp(dmi_ident[s], dmi->matches[i].substr))\r\ncontinue;\r\n}\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool dmi_is_end_of_table(const struct dmi_system_id *dmi)\r\n{\r\nreturn dmi->matches[0].slot == DMI_NONE;\r\n}\r\nint dmi_check_system(const struct dmi_system_id *list)\r\n{\r\nint count = 0;\r\nconst struct dmi_system_id *d;\r\nfor (d = list; !dmi_is_end_of_table(d); d++)\r\nif (dmi_matches(d)) {\r\ncount++;\r\nif (d->callback && d->callback(d))\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nconst struct dmi_system_id *dmi_first_match(const struct dmi_system_id *list)\r\n{\r\nconst struct dmi_system_id *d;\r\nfor (d = list; !dmi_is_end_of_table(d); d++)\r\nif (dmi_matches(d))\r\nreturn d;\r\nreturn NULL;\r\n}\r\nconst char *dmi_get_system_info(int field)\r\n{\r\nreturn dmi_ident[field];\r\n}\r\nint dmi_name_in_serial(const char *str)\r\n{\r\nint f = DMI_PRODUCT_SERIAL;\r\nif (dmi_ident[f] && strstr(dmi_ident[f], str))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint dmi_name_in_vendors(const char *str)\r\n{\r\nstatic int fields[] = { DMI_SYS_VENDOR, DMI_BOARD_VENDOR, DMI_NONE };\r\nint i;\r\nfor (i = 0; fields[i] != DMI_NONE; i++) {\r\nint f = fields[i];\r\nif (dmi_ident[f] && strstr(dmi_ident[f], str))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nconst struct dmi_device *dmi_find_device(int type, const char *name,\r\nconst struct dmi_device *from)\r\n{\r\nconst struct list_head *head = from ? &from->list : &dmi_devices;\r\nstruct list_head *d;\r\nfor (d = head->next; d != &dmi_devices; d = d->next) {\r\nconst struct dmi_device *dev =\r\nlist_entry(d, struct dmi_device, list);\r\nif (((type == DMI_DEV_TYPE_ANY) || (dev->type == type)) &&\r\n((name == NULL) || (strcmp(dev->name, name) == 0)))\r\nreturn dev;\r\n}\r\nreturn NULL;\r\n}\r\nbool dmi_get_date(int field, int *yearp, int *monthp, int *dayp)\r\n{\r\nint year = 0, month = 0, day = 0;\r\nbool exists;\r\nconst char *s, *y;\r\nchar *e;\r\ns = dmi_get_system_info(field);\r\nexists = s;\r\nif (!exists)\r\ngoto out;\r\ny = strrchr(s, '/');\r\nif (!y)\r\ngoto out;\r\ny++;\r\nyear = simple_strtoul(y, &e, 10);\r\nif (y != e && year < 100) {\r\nyear += 1900;\r\nif (year < 1996)\r\nyear += 100;\r\n}\r\nif (year > 9999)\r\nyear = 0;\r\nmonth = simple_strtoul(s, &e, 10);\r\nif (s == e || *e != '/' || !month || month > 12) {\r\nmonth = 0;\r\ngoto out;\r\n}\r\ns = e + 1;\r\nday = simple_strtoul(s, &e, 10);\r\nif (s == y || s == e || *e != '/' || day > 31)\r\nday = 0;\r\nout:\r\nif (yearp)\r\n*yearp = year;\r\nif (monthp)\r\n*monthp = month;\r\nif (dayp)\r\n*dayp = day;\r\nreturn exists;\r\n}\r\nint dmi_walk(void (*decode)(const struct dmi_header *, void *),\r\nvoid *private_data)\r\n{\r\nu8 *buf;\r\nif (!dmi_available)\r\nreturn -ENXIO;\r\nbuf = dmi_remap(dmi_base, dmi_len);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\ndmi_decode_table(buf, decode, private_data);\r\ndmi_unmap(buf);\r\nreturn 0;\r\n}\r\nbool dmi_match(enum dmi_field f, const char *str)\r\n{\r\nconst char *info = dmi_get_system_info(f);\r\nif (info == NULL || str == NULL)\r\nreturn info == str;\r\nreturn !strcmp(info, str);\r\n}\r\nvoid dmi_memdev_name(u16 handle, const char **bank, const char **device)\r\n{\r\nint n;\r\nif (dmi_memdev == NULL)\r\nreturn;\r\nfor (n = 0; n < dmi_memdev_nr; n++) {\r\nif (handle == dmi_memdev[n].handle) {\r\n*bank = dmi_memdev[n].bank;\r\n*device = dmi_memdev[n].device;\r\nbreak;\r\n}\r\n}\r\n}
