static irqreturn_t atmel_ssc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct atmel_ssc_info *ssc_p = dev_id;\r\nstruct atmel_pcm_dma_params *dma_params;\r\nu32 ssc_sr;\r\nu32 ssc_substream_mask;\r\nint i;\r\nssc_sr = (unsigned long)ssc_readl(ssc_p->ssc->regs, SR)\r\n& (unsigned long)ssc_readl(ssc_p->ssc->regs, IMR);\r\nfor (i = 0; i < ARRAY_SIZE(ssc_p->dma_params); i++) {\r\ndma_params = ssc_p->dma_params[i];\r\nif ((dma_params != NULL) &&\r\n(dma_params->dma_intr_handler != NULL)) {\r\nssc_substream_mask = (dma_params->mask->ssc_endx |\r\ndma_params->mask->ssc_endbuf);\r\nif (ssc_sr & ssc_substream_mask) {\r\ndma_params->dma_intr_handler(ssc_sr,\r\ndma_params->\r\nsubstream);\r\n}\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int atmel_ssc_hw_rule_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct atmel_ssc_info *ssc_p = rule->private;\r\nstruct ssc_device *ssc = ssc_p->ssc;\r\nstruct snd_interval *i = hw_param_interval(params, rule->var);\r\nstruct snd_interval t;\r\nstruct snd_ratnum r = {\r\n.den_min = 1,\r\n.den_max = 4095,\r\n.den_step = 1,\r\n};\r\nunsigned int num = 0, den = 0;\r\nint frame_size;\r\nint mck_div = 2;\r\nint ret;\r\nframe_size = snd_soc_params_to_frame_size(params);\r\nif (frame_size < 0)\r\nreturn frame_size;\r\nswitch (ssc_p->daifmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nif ((ssc_p->dir_mask & SSC_DIR_MASK_CAPTURE)\r\n&& ssc->clk_from_rk_pin)\r\nmck_div = 3;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nif ((ssc_p->dir_mask & SSC_DIR_MASK_PLAYBACK)\r\n&& !ssc->clk_from_rk_pin)\r\nmck_div = 6;\r\nbreak;\r\n}\r\nswitch (ssc_p->daifmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nr.num = ssc_p->mck_rate / mck_div / frame_size;\r\nret = snd_interval_ratnum(i, 1, &r, &num, &den);\r\nif (ret >= 0 && den && rule->var == SNDRV_PCM_HW_PARAM_RATE) {\r\nparams->rate_num = num;\r\nparams->rate_den = den;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nt.min = 8000;\r\nt.max = ssc_p->mck_rate / mck_div / frame_size;\r\nt.openmin = t.openmax = 0;\r\nt.integer = 0;\r\nret = snd_interval_refine(i, &t);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int atmel_ssc_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dai->dev);\r\nstruct atmel_ssc_info *ssc_p = &ssc_info[pdev->id];\r\nstruct atmel_pcm_dma_params *dma_params;\r\nint dir, dir_mask;\r\nint ret;\r\npr_debug("atmel_ssc_startup: SSC_SR=0x%x\n",\r\nssc_readl(ssc_p->ssc->regs, SR));\r\npr_debug("atmel_ssc_dai: Starting clock\n");\r\nclk_enable(ssc_p->ssc->clk);\r\nssc_p->mck_rate = clk_get_rate(ssc_p->ssc->clk);\r\nif (!ssc_p->initialized)\r\nssc_writel(ssc_p->ssc->regs, CR, SSC_BIT(CR_SWRST));\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ndir = 0;\r\ndir_mask = SSC_DIR_MASK_PLAYBACK;\r\n} else {\r\ndir = 1;\r\ndir_mask = SSC_DIR_MASK_CAPTURE;\r\n}\r\nret = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\natmel_ssc_hw_rule_rate,\r\nssc_p,\r\nSNDRV_PCM_HW_PARAM_FRAME_BITS,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nif (ret < 0) {\r\ndev_err(dai->dev, "Failed to specify rate rule: %d\n", ret);\r\nreturn ret;\r\n}\r\ndma_params = &ssc_dma_params[pdev->id][dir];\r\ndma_params->ssc = ssc_p->ssc;\r\ndma_params->substream = substream;\r\nssc_p->dma_params[dir] = dma_params;\r\nsnd_soc_dai_set_dma_data(dai, substream, dma_params);\r\nspin_lock_irq(&ssc_p->lock);\r\nif (ssc_p->dir_mask & dir_mask) {\r\nspin_unlock_irq(&ssc_p->lock);\r\nreturn -EBUSY;\r\n}\r\nssc_p->dir_mask |= dir_mask;\r\nspin_unlock_irq(&ssc_p->lock);\r\nreturn 0;\r\n}\r\nstatic void atmel_ssc_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dai->dev);\r\nstruct atmel_ssc_info *ssc_p = &ssc_info[pdev->id];\r\nstruct atmel_pcm_dma_params *dma_params;\r\nint dir, dir_mask;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndir = 0;\r\nelse\r\ndir = 1;\r\ndma_params = ssc_p->dma_params[dir];\r\nif (dma_params != NULL) {\r\ndma_params->ssc = NULL;\r\ndma_params->substream = NULL;\r\nssc_p->dma_params[dir] = NULL;\r\n}\r\ndir_mask = 1 << dir;\r\nspin_lock_irq(&ssc_p->lock);\r\nssc_p->dir_mask &= ~dir_mask;\r\nif (!ssc_p->dir_mask) {\r\nif (ssc_p->initialized) {\r\nfree_irq(ssc_p->ssc->irq, ssc_p);\r\nssc_p->initialized = 0;\r\n}\r\nssc_writel(ssc_p->ssc->regs, CR, SSC_BIT(CR_SWRST));\r\nssc_p->cmr_div = ssc_p->tcmr_period = ssc_p->rcmr_period = 0;\r\nssc_p->forced_divider = 0;\r\n}\r\nspin_unlock_irq(&ssc_p->lock);\r\npr_debug("atmel_ssc_dai: Stopping clock\n");\r\nclk_disable(ssc_p->ssc->clk);\r\n}\r\nstatic int atmel_ssc_set_dai_fmt(struct snd_soc_dai *cpu_dai,\r\nunsigned int fmt)\r\n{\r\nstruct platform_device *pdev = to_platform_device(cpu_dai->dev);\r\nstruct atmel_ssc_info *ssc_p = &ssc_info[pdev->id];\r\nssc_p->daifmt = fmt;\r\nreturn 0;\r\n}\r\nstatic int atmel_ssc_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,\r\nint div_id, int div)\r\n{\r\nstruct platform_device *pdev = to_platform_device(cpu_dai->dev);\r\nstruct atmel_ssc_info *ssc_p = &ssc_info[pdev->id];\r\nswitch (div_id) {\r\ncase ATMEL_SSC_CMR_DIV:\r\nif (ssc_p->dir_mask !=\r\n(SSC_DIR_MASK_PLAYBACK | SSC_DIR_MASK_CAPTURE))\r\nssc_p->cmr_div = div;\r\nelse if (ssc_p->cmr_div == 0)\r\nssc_p->cmr_div = div;\r\nelse\r\nif (div != ssc_p->cmr_div)\r\nreturn -EBUSY;\r\nssc_p->forced_divider |= BIT(ATMEL_SSC_CMR_DIV);\r\nbreak;\r\ncase ATMEL_SSC_TCMR_PERIOD:\r\nssc_p->tcmr_period = div;\r\nssc_p->forced_divider |= BIT(ATMEL_SSC_TCMR_PERIOD);\r\nbreak;\r\ncase ATMEL_SSC_RCMR_PERIOD:\r\nssc_p->rcmr_period = div;\r\nssc_p->forced_divider |= BIT(ATMEL_SSC_RCMR_PERIOD);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_ssc_cfs(struct atmel_ssc_info *ssc_p)\r\n{\r\nswitch (ssc_p->daifmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_ssc_cbs(struct atmel_ssc_info *ssc_p)\r\n{\r\nswitch (ssc_p->daifmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_ssc_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dai->dev);\r\nint id = pdev->id;\r\nstruct atmel_ssc_info *ssc_p = &ssc_info[id];\r\nstruct ssc_device *ssc = ssc_p->ssc;\r\nstruct atmel_pcm_dma_params *dma_params;\r\nint dir, channels, bits;\r\nu32 tfmr, rfmr, tcmr, rcmr;\r\nint ret;\r\nint fslen, fslen_ext;\r\nu32 cmr_div;\r\nu32 tcmr_period;\r\nu32 rcmr_period;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndir = 0;\r\nelse\r\ndir = 1;\r\ncmr_div = ssc_p->cmr_div;\r\nif (!(ssc_p->forced_divider & BIT(ATMEL_SSC_CMR_DIV)) &&\r\natmel_ssc_cbs(ssc_p)) {\r\nint bclk_rate = snd_soc_params_to_bclk(params);\r\nif (bclk_rate < 0) {\r\ndev_err(dai->dev, "unable to calculate cmr_div: %d\n",\r\nbclk_rate);\r\nreturn bclk_rate;\r\n}\r\ncmr_div = DIV_ROUND_CLOSEST(ssc_p->mck_rate, 2 * bclk_rate);\r\n}\r\ntcmr_period = ssc_p->tcmr_period;\r\nrcmr_period = ssc_p->rcmr_period;\r\nif (atmel_ssc_cfs(ssc_p)) {\r\nint frame_size = snd_soc_params_to_frame_size(params);\r\nif (frame_size < 0) {\r\ndev_err(dai->dev,\r\n"unable to calculate tx/rx cmr_period: %d\n",\r\nframe_size);\r\nreturn frame_size;\r\n}\r\nif (!(ssc_p->forced_divider & BIT(ATMEL_SSC_TCMR_PERIOD)))\r\ntcmr_period = frame_size / 2 - 1;\r\nif (!(ssc_p->forced_divider & BIT(ATMEL_SSC_RCMR_PERIOD)))\r\nrcmr_period = frame_size / 2 - 1;\r\n}\r\ndma_params = ssc_p->dma_params[dir];\r\nchannels = params_channels(params);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S8:\r\nbits = 8;\r\ndma_params->pdc_xfer_size = 1;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbits = 16;\r\ndma_params->pdc_xfer_size = 2;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nbits = 24;\r\ndma_params->pdc_xfer_size = 4;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nbits = 32;\r\ndma_params->pdc_xfer_size = 4;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "atmel_ssc_dai: unsupported PCM format");\r\nreturn -EINVAL;\r\n}\r\nswitch (ssc_p->daifmt\r\n& (SND_SOC_DAIFMT_FORMAT_MASK | SND_SOC_DAIFMT_MASTER_MASK)) {\r\ncase SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBS_CFS:\r\nif (bits > 16 && !ssc->pdata->has_fslen_ext) {\r\ndev_err(dai->dev,\r\n"sample size %d is too large for SSC device\n",\r\nbits);\r\nreturn -EINVAL;\r\n}\r\nfslen_ext = (bits - 1) / 16;\r\nfslen = (bits - 1) % 16;\r\nrcmr = SSC_BF(RCMR_PERIOD, rcmr_period)\r\n| SSC_BF(RCMR_STTDLY, START_DELAY)\r\n| SSC_BF(RCMR_START, SSC_START_FALLING_RF)\r\n| SSC_BF(RCMR_CKI, SSC_CKI_RISING)\r\n| SSC_BF(RCMR_CKO, SSC_CKO_NONE)\r\n| SSC_BF(RCMR_CKS, SSC_CKS_DIV);\r\nrfmr = SSC_BF(RFMR_FSLEN_EXT, fslen_ext)\r\n| SSC_BF(RFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(RFMR_FSOS, SSC_FSOS_NEGATIVE)\r\n| SSC_BF(RFMR_FSLEN, fslen)\r\n| SSC_BF(RFMR_DATNB, (channels - 1))\r\n| SSC_BIT(RFMR_MSBF)\r\n| SSC_BF(RFMR_LOOP, 0)\r\n| SSC_BF(RFMR_DATLEN, (bits - 1));\r\ntcmr = SSC_BF(TCMR_PERIOD, tcmr_period)\r\n| SSC_BF(TCMR_STTDLY, START_DELAY)\r\n| SSC_BF(TCMR_START, SSC_START_FALLING_RF)\r\n| SSC_BF(TCMR_CKI, SSC_CKI_FALLING)\r\n| SSC_BF(TCMR_CKO, SSC_CKO_CONTINUOUS)\r\n| SSC_BF(TCMR_CKS, SSC_CKS_DIV);\r\ntfmr = SSC_BF(TFMR_FSLEN_EXT, fslen_ext)\r\n| SSC_BF(TFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(TFMR_FSDEN, 0)\r\n| SSC_BF(TFMR_FSOS, SSC_FSOS_NEGATIVE)\r\n| SSC_BF(TFMR_FSLEN, fslen)\r\n| SSC_BF(TFMR_DATNB, (channels - 1))\r\n| SSC_BIT(TFMR_MSBF)\r\n| SSC_BF(TFMR_DATDEF, 0)\r\n| SSC_BF(TFMR_DATLEN, (bits - 1));\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM:\r\nrcmr = SSC_BF(RCMR_PERIOD, 0)\r\n| SSC_BF(RCMR_STTDLY, START_DELAY)\r\n| SSC_BF(RCMR_START, SSC_START_FALLING_RF)\r\n| SSC_BF(RCMR_CKI, SSC_CKI_RISING)\r\n| SSC_BF(RCMR_CKO, SSC_CKO_NONE)\r\n| SSC_BF(RCMR_CKS, ssc->clk_from_rk_pin ?\r\nSSC_CKS_PIN : SSC_CKS_CLOCK);\r\nrfmr = SSC_BF(RFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(RFMR_FSOS, SSC_FSOS_NONE)\r\n| SSC_BF(RFMR_FSLEN, 0)\r\n| SSC_BF(RFMR_DATNB, (channels - 1))\r\n| SSC_BIT(RFMR_MSBF)\r\n| SSC_BF(RFMR_LOOP, 0)\r\n| SSC_BF(RFMR_DATLEN, (bits - 1));\r\ntcmr = SSC_BF(TCMR_PERIOD, 0)\r\n| SSC_BF(TCMR_STTDLY, START_DELAY)\r\n| SSC_BF(TCMR_START, SSC_START_FALLING_RF)\r\n| SSC_BF(TCMR_CKI, SSC_CKI_FALLING)\r\n| SSC_BF(TCMR_CKO, SSC_CKO_NONE)\r\n| SSC_BF(TCMR_CKS, ssc->clk_from_rk_pin ?\r\nSSC_CKS_CLOCK : SSC_CKS_PIN);\r\ntfmr = SSC_BF(TFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(TFMR_FSDEN, 0)\r\n| SSC_BF(TFMR_FSOS, SSC_FSOS_NONE)\r\n| SSC_BF(TFMR_FSLEN, 0)\r\n| SSC_BF(TFMR_DATNB, (channels - 1))\r\n| SSC_BIT(TFMR_MSBF)\r\n| SSC_BF(TFMR_DATDEF, 0)\r\n| SSC_BF(TFMR_DATLEN, (bits - 1));\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFS:\r\nif (bits > 16 && !ssc->pdata->has_fslen_ext) {\r\ndev_err(dai->dev,\r\n"sample size %d is too large for SSC device\n",\r\nbits);\r\nreturn -EINVAL;\r\n}\r\nfslen_ext = (bits - 1) / 16;\r\nfslen = (bits - 1) % 16;\r\nrcmr = SSC_BF(RCMR_PERIOD, rcmr_period)\r\n| SSC_BF(RCMR_STTDLY, START_DELAY)\r\n| SSC_BF(RCMR_START, SSC_START_FALLING_RF)\r\n| SSC_BF(RCMR_CKI, SSC_CKI_RISING)\r\n| SSC_BF(RCMR_CKO, SSC_CKO_NONE)\r\n| SSC_BF(RCMR_CKS, ssc->clk_from_rk_pin ?\r\nSSC_CKS_PIN : SSC_CKS_CLOCK);\r\nrfmr = SSC_BF(RFMR_FSLEN_EXT, fslen_ext)\r\n| SSC_BF(RFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(RFMR_FSOS, SSC_FSOS_NEGATIVE)\r\n| SSC_BF(RFMR_FSLEN, fslen)\r\n| SSC_BF(RFMR_DATNB, (channels - 1))\r\n| SSC_BIT(RFMR_MSBF)\r\n| SSC_BF(RFMR_LOOP, 0)\r\n| SSC_BF(RFMR_DATLEN, (bits - 1));\r\ntcmr = SSC_BF(TCMR_PERIOD, tcmr_period)\r\n| SSC_BF(TCMR_STTDLY, START_DELAY)\r\n| SSC_BF(TCMR_START, SSC_START_FALLING_RF)\r\n| SSC_BF(TCMR_CKI, SSC_CKI_FALLING)\r\n| SSC_BF(TCMR_CKO, SSC_CKO_NONE)\r\n| SSC_BF(TCMR_CKS, ssc->clk_from_rk_pin ?\r\nSSC_CKS_CLOCK : SSC_CKS_PIN);\r\ntfmr = SSC_BF(TFMR_FSLEN_EXT, fslen_ext)\r\n| SSC_BF(TFMR_FSEDGE, SSC_FSEDGE_NEGATIVE)\r\n| SSC_BF(TFMR_FSDEN, 0)\r\n| SSC_BF(TFMR_FSOS, SSC_FSOS_NEGATIVE)\r\n| SSC_BF(TFMR_FSLEN, fslen)\r\n| SSC_BF(TFMR_DATNB, (channels - 1))\r\n| SSC_BIT(TFMR_MSBF)\r\n| SSC_BF(TFMR_DATDEF, 0)\r\n| SSC_BF(TFMR_DATLEN, (bits - 1));\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_CBS_CFS:\r\nrcmr = SSC_BF(RCMR_PERIOD, rcmr_period)\r\n| SSC_BF(RCMR_STTDLY, 1)\r\n| SSC_BF(RCMR_START, SSC_START_RISING_RF)\r\n| SSC_BF(RCMR_CKI, SSC_CKI_RISING)\r\n| SSC_BF(RCMR_CKO, SSC_CKO_NONE)\r\n| SSC_BF(RCMR_CKS, SSC_CKS_DIV);\r\nrfmr = SSC_BF(RFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(RFMR_FSOS, SSC_FSOS_POSITIVE)\r\n| SSC_BF(RFMR_FSLEN, 0)\r\n| SSC_BF(RFMR_DATNB, (channels - 1))\r\n| SSC_BIT(RFMR_MSBF)\r\n| SSC_BF(RFMR_LOOP, 0)\r\n| SSC_BF(RFMR_DATLEN, (bits - 1));\r\ntcmr = SSC_BF(TCMR_PERIOD, tcmr_period)\r\n| SSC_BF(TCMR_STTDLY, 1)\r\n| SSC_BF(TCMR_START, SSC_START_RISING_RF)\r\n| SSC_BF(TCMR_CKI, SSC_CKI_FALLING)\r\n| SSC_BF(TCMR_CKO, SSC_CKO_CONTINUOUS)\r\n| SSC_BF(TCMR_CKS, SSC_CKS_DIV);\r\ntfmr = SSC_BF(TFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(TFMR_FSDEN, 0)\r\n| SSC_BF(TFMR_FSOS, SSC_FSOS_POSITIVE)\r\n| SSC_BF(TFMR_FSLEN, 0)\r\n| SSC_BF(TFMR_DATNB, (channels - 1))\r\n| SSC_BIT(TFMR_MSBF)\r\n| SSC_BF(TFMR_DATDEF, 0)\r\n| SSC_BF(TFMR_DATLEN, (bits - 1));\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_CBM_CFM:\r\nrcmr = SSC_BF(RCMR_PERIOD, 0)\r\n| SSC_BF(RCMR_STTDLY, START_DELAY)\r\n| SSC_BF(RCMR_START, SSC_START_RISING_RF)\r\n| SSC_BF(RCMR_CKI, SSC_CKI_RISING)\r\n| SSC_BF(RCMR_CKO, SSC_CKO_NONE)\r\n| SSC_BF(RCMR_CKS, ssc->clk_from_rk_pin ?\r\nSSC_CKS_PIN : SSC_CKS_CLOCK);\r\nrfmr = SSC_BF(RFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(RFMR_FSOS, SSC_FSOS_NONE)\r\n| SSC_BF(RFMR_FSLEN, 0)\r\n| SSC_BF(RFMR_DATNB, (channels - 1))\r\n| SSC_BIT(RFMR_MSBF)\r\n| SSC_BF(RFMR_LOOP, 0)\r\n| SSC_BF(RFMR_DATLEN, (bits - 1));\r\ntcmr = SSC_BF(TCMR_PERIOD, 0)\r\n| SSC_BF(TCMR_STTDLY, START_DELAY)\r\n| SSC_BF(TCMR_START, SSC_START_RISING_RF)\r\n| SSC_BF(TCMR_CKI, SSC_CKI_FALLING)\r\n| SSC_BF(TCMR_CKO, SSC_CKO_NONE)\r\n| SSC_BF(RCMR_CKS, ssc->clk_from_rk_pin ?\r\nSSC_CKS_CLOCK : SSC_CKS_PIN);\r\ntfmr = SSC_BF(TFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(TFMR_FSDEN, 0)\r\n| SSC_BF(TFMR_FSOS, SSC_FSOS_NONE)\r\n| SSC_BF(TFMR_FSLEN, 0)\r\n| SSC_BF(TFMR_DATNB, (channels - 1))\r\n| SSC_BIT(TFMR_MSBF)\r\n| SSC_BF(TFMR_DATDEF, 0)\r\n| SSC_BF(TFMR_DATLEN, (bits - 1));\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "atmel_ssc_dai: unsupported DAI format 0x%x\n",\r\nssc_p->daifmt);\r\nreturn -EINVAL;\r\n}\r\npr_debug("atmel_ssc_hw_params: "\r\n"RCMR=%08x RFMR=%08x TCMR=%08x TFMR=%08x\n",\r\nrcmr, rfmr, tcmr, tfmr);\r\nif (!ssc_p->initialized) {\r\nif (!ssc_p->ssc->pdata->use_dma) {\r\nssc_writel(ssc_p->ssc->regs, PDC_RPR, 0);\r\nssc_writel(ssc_p->ssc->regs, PDC_RCR, 0);\r\nssc_writel(ssc_p->ssc->regs, PDC_RNPR, 0);\r\nssc_writel(ssc_p->ssc->regs, PDC_RNCR, 0);\r\nssc_writel(ssc_p->ssc->regs, PDC_TPR, 0);\r\nssc_writel(ssc_p->ssc->regs, PDC_TCR, 0);\r\nssc_writel(ssc_p->ssc->regs, PDC_TNPR, 0);\r\nssc_writel(ssc_p->ssc->regs, PDC_TNCR, 0);\r\n}\r\nret = request_irq(ssc_p->ssc->irq, atmel_ssc_interrupt, 0,\r\nssc_p->name, ssc_p);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING\r\n"atmel_ssc_dai: request_irq failure\n");\r\npr_debug("Atmel_ssc_dai: Stoping clock\n");\r\nclk_disable(ssc_p->ssc->clk);\r\nreturn ret;\r\n}\r\nssc_p->initialized = 1;\r\n}\r\nssc_writel(ssc_p->ssc->regs, CMR, cmr_div);\r\nssc_writel(ssc_p->ssc->regs, RCMR, rcmr);\r\nssc_writel(ssc_p->ssc->regs, RFMR, rfmr);\r\nssc_writel(ssc_p->ssc->regs, TCMR, tcmr);\r\nssc_writel(ssc_p->ssc->regs, TFMR, tfmr);\r\npr_debug("atmel_ssc_dai,hw_params: SSC initialized\n");\r\nreturn 0;\r\n}\r\nstatic int atmel_ssc_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dai->dev);\r\nstruct atmel_ssc_info *ssc_p = &ssc_info[pdev->id];\r\nstruct atmel_pcm_dma_params *dma_params;\r\nint dir;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndir = 0;\r\nelse\r\ndir = 1;\r\ndma_params = ssc_p->dma_params[dir];\r\nssc_writel(ssc_p->ssc->regs, CR, dma_params->mask->ssc_disable);\r\nssc_writel(ssc_p->ssc->regs, IDR, dma_params->mask->ssc_error);\r\npr_debug("%s enabled SSC_SR=0x%08x\n",\r\ndir ? "receive" : "transmit",\r\nssc_readl(ssc_p->ssc->regs, SR));\r\nreturn 0;\r\n}\r\nstatic int atmel_ssc_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dai->dev);\r\nstruct atmel_ssc_info *ssc_p = &ssc_info[pdev->id];\r\nstruct atmel_pcm_dma_params *dma_params;\r\nint dir;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndir = 0;\r\nelse\r\ndir = 1;\r\ndma_params = ssc_p->dma_params[dir];\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nssc_writel(ssc_p->ssc->regs, CR, dma_params->mask->ssc_enable);\r\nbreak;\r\ndefault:\r\nssc_writel(ssc_p->ssc->regs, CR, dma_params->mask->ssc_disable);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_ssc_suspend(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct atmel_ssc_info *ssc_p;\r\nstruct platform_device *pdev = to_platform_device(cpu_dai->dev);\r\nif (!cpu_dai->active)\r\nreturn 0;\r\nssc_p = &ssc_info[pdev->id];\r\nssc_p->ssc_state.ssc_sr = ssc_readl(ssc_p->ssc->regs, SR);\r\nssc_writel(ssc_p->ssc->regs, CR, SSC_BIT(CR_TXDIS) | SSC_BIT(CR_RXDIS));\r\nssc_p->ssc_state.ssc_imr = ssc_readl(ssc_p->ssc->regs, IMR);\r\nssc_writel(ssc_p->ssc->regs, IDR, ssc_p->ssc_state.ssc_imr);\r\nssc_p->ssc_state.ssc_cmr = ssc_readl(ssc_p->ssc->regs, CMR);\r\nssc_p->ssc_state.ssc_rcmr = ssc_readl(ssc_p->ssc->regs, RCMR);\r\nssc_p->ssc_state.ssc_rfmr = ssc_readl(ssc_p->ssc->regs, RFMR);\r\nssc_p->ssc_state.ssc_tcmr = ssc_readl(ssc_p->ssc->regs, TCMR);\r\nssc_p->ssc_state.ssc_tfmr = ssc_readl(ssc_p->ssc->regs, TFMR);\r\nreturn 0;\r\n}\r\nstatic int atmel_ssc_resume(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct atmel_ssc_info *ssc_p;\r\nstruct platform_device *pdev = to_platform_device(cpu_dai->dev);\r\nu32 cr;\r\nif (!cpu_dai->active)\r\nreturn 0;\r\nssc_p = &ssc_info[pdev->id];\r\nssc_writel(ssc_p->ssc->regs, TFMR, ssc_p->ssc_state.ssc_tfmr);\r\nssc_writel(ssc_p->ssc->regs, TCMR, ssc_p->ssc_state.ssc_tcmr);\r\nssc_writel(ssc_p->ssc->regs, RFMR, ssc_p->ssc_state.ssc_rfmr);\r\nssc_writel(ssc_p->ssc->regs, RCMR, ssc_p->ssc_state.ssc_rcmr);\r\nssc_writel(ssc_p->ssc->regs, CMR, ssc_p->ssc_state.ssc_cmr);\r\nssc_writel(ssc_p->ssc->regs, IER, ssc_p->ssc_state.ssc_imr);\r\ncr = 0;\r\ncr |=\r\n(ssc_p->ssc_state.ssc_sr & SSC_BIT(SR_RXEN)) ? SSC_BIT(CR_RXEN) : 0;\r\ncr |=\r\n(ssc_p->ssc_state.ssc_sr & SSC_BIT(SR_TXEN)) ? SSC_BIT(CR_TXEN) : 0;\r\nssc_writel(ssc_p->ssc->regs, CR, cr);\r\nreturn 0;\r\n}\r\nstatic int asoc_ssc_init(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ssc_device *ssc = platform_get_drvdata(pdev);\r\nint ret;\r\nret = snd_soc_register_component(dev, &atmel_ssc_component,\r\n&atmel_ssc_dai, 1);\r\nif (ret) {\r\ndev_err(dev, "Could not register DAI: %d\n", ret);\r\ngoto err;\r\n}\r\nif (ssc->pdata->use_dma)\r\nret = atmel_pcm_dma_platform_register(dev);\r\nelse\r\nret = atmel_pcm_pdc_platform_register(dev);\r\nif (ret) {\r\ndev_err(dev, "Could not register PCM: %d\n", ret);\r\ngoto err_unregister_dai;\r\n}\r\nreturn 0;\r\nerr_unregister_dai:\r\nsnd_soc_unregister_component(dev);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void asoc_ssc_exit(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ssc_device *ssc = platform_get_drvdata(pdev);\r\nif (ssc->pdata->use_dma)\r\natmel_pcm_dma_platform_unregister(dev);\r\nelse\r\natmel_pcm_pdc_platform_unregister(dev);\r\nsnd_soc_unregister_component(dev);\r\n}\r\nint atmel_ssc_set_audio(int ssc_id)\r\n{\r\nstruct ssc_device *ssc;\r\nint ret;\r\nssc = ssc_request(ssc_id);\r\nif (IS_ERR(ssc)) {\r\npr_err("Unable to parent ASoC SSC DAI on SSC: %ld\n",\r\nPTR_ERR(ssc));\r\nreturn PTR_ERR(ssc);\r\n} else {\r\nssc_info[ssc_id].ssc = ssc;\r\n}\r\nret = asoc_ssc_init(&ssc->pdev->dev);\r\nreturn ret;\r\n}\r\nvoid atmel_ssc_put_audio(int ssc_id)\r\n{\r\nstruct ssc_device *ssc = ssc_info[ssc_id].ssc;\r\nasoc_ssc_exit(&ssc->pdev->dev);\r\nssc_free(ssc);\r\n}
