static inline unsigned int to_reg(int gpio, enum ctrl_register reg_type)\r\n{\r\nunsigned int reg;\r\nif (gpio >= WCOVE_GPIO_NUM)\r\nreturn -EOPNOTSUPP;\r\nif (reg_type == CTRL_IN)\r\nreg = GPIO_IN_CTRL_BASE + gpio;\r\nelse\r\nreg = GPIO_OUT_CTRL_BASE + gpio;\r\nreturn reg;\r\n}\r\nstatic void wcove_update_irq_mask(struct wcove_gpio *wg, int gpio)\r\n{\r\nunsigned int reg, mask;\r\nif (gpio < GROUP0_NR_IRQS) {\r\nreg = IRQ_MASK_BASE;\r\nmask = BIT(gpio % GROUP0_NR_IRQS);\r\n} else {\r\nreg = IRQ_MASK_BASE + 1;\r\nmask = BIT((gpio - GROUP0_NR_IRQS) % GROUP1_NR_IRQS);\r\n}\r\nif (wg->set_irq_mask)\r\nregmap_update_bits(wg->regmap, reg, mask, mask);\r\nelse\r\nregmap_update_bits(wg->regmap, reg, mask, 0);\r\n}\r\nstatic void wcove_update_irq_ctrl(struct wcove_gpio *wg, int gpio)\r\n{\r\nint reg = to_reg(gpio, CTRL_IN);\r\nif (reg < 0)\r\nreturn;\r\nregmap_update_bits(wg->regmap, reg, CTLI_INTCNT_BE, wg->intcnt);\r\n}\r\nstatic int wcove_gpio_dir_in(struct gpio_chip *chip, unsigned int gpio)\r\n{\r\nstruct wcove_gpio *wg = gpiochip_get_data(chip);\r\nint reg = to_reg(gpio, CTRL_OUT);\r\nif (reg < 0)\r\nreturn 0;\r\nreturn regmap_write(wg->regmap, reg, CTLO_INPUT_SET);\r\n}\r\nstatic int wcove_gpio_dir_out(struct gpio_chip *chip, unsigned int gpio,\r\nint value)\r\n{\r\nstruct wcove_gpio *wg = gpiochip_get_data(chip);\r\nint reg = to_reg(gpio, CTRL_OUT);\r\nif (reg < 0)\r\nreturn 0;\r\nreturn regmap_write(wg->regmap, reg, CTLO_OUTPUT_SET | value);\r\n}\r\nstatic int wcove_gpio_get_direction(struct gpio_chip *chip, unsigned int gpio)\r\n{\r\nstruct wcove_gpio *wg = gpiochip_get_data(chip);\r\nunsigned int val;\r\nint ret, reg = to_reg(gpio, CTRL_OUT);\r\nif (reg < 0)\r\nreturn 0;\r\nret = regmap_read(wg->regmap, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn !(val & CTLO_DIR_OUT);\r\n}\r\nstatic int wcove_gpio_get(struct gpio_chip *chip, unsigned int gpio)\r\n{\r\nstruct wcove_gpio *wg = gpiochip_get_data(chip);\r\nunsigned int val;\r\nint ret, reg = to_reg(gpio, CTRL_IN);\r\nif (reg < 0)\r\nreturn 0;\r\nret = regmap_read(wg->regmap, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn val & 0x1;\r\n}\r\nstatic void wcove_gpio_set(struct gpio_chip *chip,\r\nunsigned int gpio, int value)\r\n{\r\nstruct wcove_gpio *wg = gpiochip_get_data(chip);\r\nint reg = to_reg(gpio, CTRL_OUT);\r\nif (reg < 0)\r\nreturn;\r\nif (value)\r\nregmap_update_bits(wg->regmap, reg, 1, 1);\r\nelse\r\nregmap_update_bits(wg->regmap, reg, 1, 0);\r\n}\r\nstatic int wcove_gpio_set_config(struct gpio_chip *chip, unsigned int gpio,\r\nunsigned long config)\r\n{\r\nstruct wcove_gpio *wg = gpiochip_get_data(chip);\r\nint reg = to_reg(gpio, CTRL_OUT);\r\nif (reg < 0)\r\nreturn 0;\r\nswitch (pinconf_to_config_param(config)) {\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\nreturn regmap_update_bits(wg->regmap, reg, CTLO_DRV_MASK,\r\nCTLO_DRV_OD);\r\ncase PIN_CONFIG_DRIVE_PUSH_PULL:\r\nreturn regmap_update_bits(wg->regmap, reg, CTLO_DRV_MASK,\r\nCTLO_DRV_CMOS);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int wcove_irq_type(struct irq_data *data, unsigned int type)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct wcove_gpio *wg = gpiochip_get_data(chip);\r\nif (data->hwirq >= WCOVE_GPIO_NUM)\r\nreturn 0;\r\nswitch (type) {\r\ncase IRQ_TYPE_NONE:\r\nwg->intcnt = CTLI_INTCNT_DIS;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nwg->intcnt = CTLI_INTCNT_BE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nwg->intcnt = CTLI_INTCNT_PE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nwg->intcnt = CTLI_INTCNT_NE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwg->update |= UPDATE_IRQ_TYPE;\r\nreturn 0;\r\n}\r\nstatic void wcove_bus_lock(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct wcove_gpio *wg = gpiochip_get_data(chip);\r\nmutex_lock(&wg->buslock);\r\n}\r\nstatic void wcove_bus_sync_unlock(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct wcove_gpio *wg = gpiochip_get_data(chip);\r\nint gpio = data->hwirq;\r\nif (wg->update & UPDATE_IRQ_TYPE)\r\nwcove_update_irq_ctrl(wg, gpio);\r\nif (wg->update & UPDATE_IRQ_MASK)\r\nwcove_update_irq_mask(wg, gpio);\r\nwg->update = 0;\r\nmutex_unlock(&wg->buslock);\r\n}\r\nstatic void wcove_irq_unmask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct wcove_gpio *wg = gpiochip_get_data(chip);\r\nif (data->hwirq >= WCOVE_GPIO_NUM)\r\nreturn;\r\nwg->set_irq_mask = false;\r\nwg->update |= UPDATE_IRQ_MASK;\r\n}\r\nstatic void wcove_irq_mask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct wcove_gpio *wg = gpiochip_get_data(chip);\r\nif (data->hwirq >= WCOVE_GPIO_NUM)\r\nreturn;\r\nwg->set_irq_mask = true;\r\nwg->update |= UPDATE_IRQ_MASK;\r\n}\r\nstatic irqreturn_t wcove_gpio_irq_handler(int irq, void *data)\r\n{\r\nstruct wcove_gpio *wg = (struct wcove_gpio *)data;\r\nunsigned int pending, virq, gpio, mask, offset;\r\nu8 p[2];\r\nif (regmap_bulk_read(wg->regmap, IRQ_STATUS_BASE, p, 2)) {\r\ndev_err(wg->dev, "Failed to read irq status register\n");\r\nreturn IRQ_NONE;\r\n}\r\npending = (p[0] & GPIO_IRQ0_MASK) | ((p[1] & GPIO_IRQ1_MASK) << 7);\r\nif (!pending)\r\nreturn IRQ_NONE;\r\nwhile (pending) {\r\nfor_each_set_bit(gpio, (const unsigned long *)&pending,\r\nWCOVE_GPIO_NUM) {\r\noffset = (gpio > GROUP0_NR_IRQS) ? 1 : 0;\r\nmask = (offset == 1) ? BIT(gpio - GROUP0_NR_IRQS) :\r\nBIT(gpio);\r\nvirq = irq_find_mapping(wg->chip.irqdomain, gpio);\r\nhandle_nested_irq(virq);\r\nregmap_update_bits(wg->regmap, IRQ_STATUS_BASE + offset,\r\nmask, mask);\r\n}\r\nif (regmap_bulk_read(wg->regmap, IRQ_STATUS_BASE, p, 2)) {\r\ndev_err(wg->dev, "Failed to read irq status\n");\r\nbreak;\r\n}\r\npending = (p[0] & GPIO_IRQ0_MASK) | ((p[1] & GPIO_IRQ1_MASK) << 7);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void wcove_gpio_dbg_show(struct seq_file *s,\r\nstruct gpio_chip *chip)\r\n{\r\nunsigned int ctlo, ctli, irq_mask, irq_status;\r\nstruct wcove_gpio *wg = gpiochip_get_data(chip);\r\nint gpio, offset, group, ret = 0;\r\nfor (gpio = 0; gpio < WCOVE_GPIO_NUM; gpio++) {\r\ngroup = gpio < GROUP0_NR_IRQS ? 0 : 1;\r\nret += regmap_read(wg->regmap, to_reg(gpio, CTRL_OUT), &ctlo);\r\nret += regmap_read(wg->regmap, to_reg(gpio, CTRL_IN), &ctli);\r\nret += regmap_read(wg->regmap, IRQ_MASK_BASE + group,\r\n&irq_mask);\r\nret += regmap_read(wg->regmap, IRQ_STATUS_BASE + group,\r\n&irq_status);\r\nif (ret) {\r\npr_err("Failed to read registers: ctrl out/in or irq status/mask\n");\r\nbreak;\r\n}\r\noffset = gpio % 8;\r\nseq_printf(s, " gpio-%-2d %s %s %s %s ctlo=%2x,%s %s\n",\r\ngpio, ctlo & CTLO_DIR_OUT ? "out" : "in ",\r\nctli & 0x1 ? "hi" : "lo",\r\nctli & CTLI_INTCNT_NE ? "fall" : " ",\r\nctli & CTLI_INTCNT_PE ? "rise" : " ",\r\nctlo,\r\nirq_mask & BIT(offset) ? "mask " : "unmask",\r\nirq_status & BIT(offset) ? "pending" : " ");\r\n}\r\n}\r\nstatic int wcove_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct intel_soc_pmic *pmic;\r\nstruct wcove_gpio *wg;\r\nint virq, ret, irq;\r\nstruct device *dev;\r\npmic = dev_get_drvdata(pdev->dev.parent);\r\nif (!pmic)\r\nreturn -ENODEV;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\ndev = &pdev->dev;\r\nwg = devm_kzalloc(dev, sizeof(*wg), GFP_KERNEL);\r\nif (!wg)\r\nreturn -ENOMEM;\r\nwg->regmap_irq_chip = pmic->irq_chip_data;\r\nplatform_set_drvdata(pdev, wg);\r\nmutex_init(&wg->buslock);\r\nwg->chip.label = KBUILD_MODNAME;\r\nwg->chip.direction_input = wcove_gpio_dir_in;\r\nwg->chip.direction_output = wcove_gpio_dir_out;\r\nwg->chip.get_direction = wcove_gpio_get_direction;\r\nwg->chip.get = wcove_gpio_get;\r\nwg->chip.set = wcove_gpio_set;\r\nwg->chip.set_config = wcove_gpio_set_config,\r\nwg->chip.base = -1;\r\nwg->chip.ngpio = WCOVE_VGPIO_NUM;\r\nwg->chip.can_sleep = true;\r\nwg->chip.parent = pdev->dev.parent;\r\nwg->chip.dbg_show = wcove_gpio_dbg_show;\r\nwg->dev = dev;\r\nwg->regmap = pmic->regmap;\r\nret = devm_gpiochip_add_data(dev, &wg->chip, wg);\r\nif (ret) {\r\ndev_err(dev, "Failed to add gpiochip: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = gpiochip_irqchip_add_nested(&wg->chip, &wcove_irqchip, 0,\r\nhandle_simple_irq, IRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(dev, "Failed to add irqchip: %d\n", ret);\r\nreturn ret;\r\n}\r\nvirq = regmap_irq_get_virq(wg->regmap_irq_chip, irq);\r\nif (virq < 0) {\r\ndev_err(dev, "Failed to get virq by irq %d\n", irq);\r\nreturn virq;\r\n}\r\nret = devm_request_threaded_irq(dev, virq, NULL,\r\nwcove_gpio_irq_handler, IRQF_ONESHOT, pdev->name, wg);\r\nif (ret) {\r\ndev_err(dev, "Failed to request irq %d\n", virq);\r\nreturn ret;\r\n}\r\ngpiochip_set_nested_irqchip(&wg->chip, &wcove_irqchip, virq);\r\nret = regmap_update_bits(wg->regmap, IRQ_MASK_BASE, GPIO_IRQ0_MASK,\r\n0x00);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(wg->regmap, IRQ_MASK_BASE + 1, GPIO_IRQ1_MASK,\r\n0x00);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}
