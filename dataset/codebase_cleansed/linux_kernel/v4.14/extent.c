static void hfs_ext_build_key(hfs_btree_key *key, u32 cnid, u16 block, u8 type)\r\n{\r\nkey->key_len = 7;\r\nkey->ext.FkType = type;\r\nkey->ext.FNum = cpu_to_be32(cnid);\r\nkey->ext.FABN = cpu_to_be16(block);\r\n}\r\nint hfs_ext_keycmp(const btree_key *key1, const btree_key *key2)\r\n{\r\n__be32 fnum1, fnum2;\r\n__be16 block1, block2;\r\nfnum1 = key1->ext.FNum;\r\nfnum2 = key2->ext.FNum;\r\nif (fnum1 != fnum2)\r\nreturn be32_to_cpu(fnum1) < be32_to_cpu(fnum2) ? -1 : 1;\r\nif (key1->ext.FkType != key2->ext.FkType)\r\nreturn key1->ext.FkType < key2->ext.FkType ? -1 : 1;\r\nblock1 = key1->ext.FABN;\r\nblock2 = key2->ext.FABN;\r\nif (block1 == block2)\r\nreturn 0;\r\nreturn be16_to_cpu(block1) < be16_to_cpu(block2) ? -1 : 1;\r\n}\r\nstatic u16 hfs_ext_find_block(struct hfs_extent *ext, u16 off)\r\n{\r\nint i;\r\nu16 count;\r\nfor (i = 0; i < 3; ext++, i++) {\r\ncount = be16_to_cpu(ext->count);\r\nif (off < count)\r\nreturn be16_to_cpu(ext->block) + off;\r\noff -= count;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hfs_ext_block_count(struct hfs_extent *ext)\r\n{\r\nint i;\r\nu16 count = 0;\r\nfor (i = 0; i < 3; ext++, i++)\r\ncount += be16_to_cpu(ext->count);\r\nreturn count;\r\n}\r\nstatic u16 hfs_ext_lastblock(struct hfs_extent *ext)\r\n{\r\nint i;\r\next += 2;\r\nfor (i = 0; i < 2; ext--, i++)\r\nif (ext->count)\r\nbreak;\r\nreturn be16_to_cpu(ext->block) + be16_to_cpu(ext->count);\r\n}\r\nstatic int __hfs_ext_write_extent(struct inode *inode, struct hfs_find_data *fd)\r\n{\r\nint res;\r\nhfs_ext_build_key(fd->search_key, inode->i_ino, HFS_I(inode)->cached_start,\r\nHFS_IS_RSRC(inode) ? HFS_FK_RSRC : HFS_FK_DATA);\r\nres = hfs_brec_find(fd);\r\nif (HFS_I(inode)->flags & HFS_FLG_EXT_NEW) {\r\nif (res != -ENOENT)\r\nreturn res;\r\nhfs_brec_insert(fd, HFS_I(inode)->cached_extents, sizeof(hfs_extent_rec));\r\nHFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);\r\n} else {\r\nif (res)\r\nreturn res;\r\nhfs_bnode_write(fd->bnode, HFS_I(inode)->cached_extents, fd->entryoffset, fd->entrylength);\r\nHFS_I(inode)->flags &= ~HFS_FLG_EXT_DIRTY;\r\n}\r\nreturn 0;\r\n}\r\nint hfs_ext_write_extent(struct inode *inode)\r\n{\r\nstruct hfs_find_data fd;\r\nint res = 0;\r\nif (HFS_I(inode)->flags & HFS_FLG_EXT_DIRTY) {\r\nres = hfs_find_init(HFS_SB(inode->i_sb)->ext_tree, &fd);\r\nif (res)\r\nreturn res;\r\nres = __hfs_ext_write_extent(inode, &fd);\r\nhfs_find_exit(&fd);\r\n}\r\nreturn res;\r\n}\r\nstatic inline int __hfs_ext_read_extent(struct hfs_find_data *fd, struct hfs_extent *extent,\r\nu32 cnid, u32 block, u8 type)\r\n{\r\nint res;\r\nhfs_ext_build_key(fd->search_key, cnid, block, type);\r\nfd->key->ext.FNum = 0;\r\nres = hfs_brec_find(fd);\r\nif (res && res != -ENOENT)\r\nreturn res;\r\nif (fd->key->ext.FNum != fd->search_key->ext.FNum ||\r\nfd->key->ext.FkType != fd->search_key->ext.FkType)\r\nreturn -ENOENT;\r\nif (fd->entrylength != sizeof(hfs_extent_rec))\r\nreturn -EIO;\r\nhfs_bnode_read(fd->bnode, extent, fd->entryoffset, sizeof(hfs_extent_rec));\r\nreturn 0;\r\n}\r\nstatic inline int __hfs_ext_cache_extent(struct hfs_find_data *fd, struct inode *inode, u32 block)\r\n{\r\nint res;\r\nif (HFS_I(inode)->flags & HFS_FLG_EXT_DIRTY) {\r\nres = __hfs_ext_write_extent(inode, fd);\r\nif (res)\r\nreturn res;\r\n}\r\nres = __hfs_ext_read_extent(fd, HFS_I(inode)->cached_extents, inode->i_ino,\r\nblock, HFS_IS_RSRC(inode) ? HFS_FK_RSRC : HFS_FK_DATA);\r\nif (!res) {\r\nHFS_I(inode)->cached_start = be16_to_cpu(fd->key->ext.FABN);\r\nHFS_I(inode)->cached_blocks = hfs_ext_block_count(HFS_I(inode)->cached_extents);\r\n} else {\r\nHFS_I(inode)->cached_start = HFS_I(inode)->cached_blocks = 0;\r\nHFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);\r\n}\r\nreturn res;\r\n}\r\nstatic int hfs_ext_read_extent(struct inode *inode, u16 block)\r\n{\r\nstruct hfs_find_data fd;\r\nint res;\r\nif (block >= HFS_I(inode)->cached_start &&\r\nblock < HFS_I(inode)->cached_start + HFS_I(inode)->cached_blocks)\r\nreturn 0;\r\nres = hfs_find_init(HFS_SB(inode->i_sb)->ext_tree, &fd);\r\nif (!res) {\r\nres = __hfs_ext_cache_extent(&fd, inode, block);\r\nhfs_find_exit(&fd);\r\n}\r\nreturn res;\r\n}\r\nstatic void hfs_dump_extent(struct hfs_extent *extent)\r\n{\r\nint i;\r\nhfs_dbg(EXTENT, " ");\r\nfor (i = 0; i < 3; i++)\r\nhfs_dbg_cont(EXTENT, " %u:%u",\r\nbe16_to_cpu(extent[i].block),\r\nbe16_to_cpu(extent[i].count));\r\nhfs_dbg_cont(EXTENT, "\n");\r\n}\r\nstatic int hfs_add_extent(struct hfs_extent *extent, u16 offset,\r\nu16 alloc_block, u16 block_count)\r\n{\r\nu16 count, start;\r\nint i;\r\nhfs_dump_extent(extent);\r\nfor (i = 0; i < 3; extent++, i++) {\r\ncount = be16_to_cpu(extent->count);\r\nif (offset == count) {\r\nstart = be16_to_cpu(extent->block);\r\nif (alloc_block != start + count) {\r\nif (++i >= 3)\r\nreturn -ENOSPC;\r\nextent++;\r\nextent->block = cpu_to_be16(alloc_block);\r\n} else\r\nblock_count += count;\r\nextent->count = cpu_to_be16(block_count);\r\nreturn 0;\r\n} else if (offset < count)\r\nbreak;\r\noffset -= count;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int hfs_free_extents(struct super_block *sb, struct hfs_extent *extent,\r\nu16 offset, u16 block_nr)\r\n{\r\nu16 count, start;\r\nint i;\r\nhfs_dump_extent(extent);\r\nfor (i = 0; i < 3; extent++, i++) {\r\ncount = be16_to_cpu(extent->count);\r\nif (offset == count)\r\ngoto found;\r\nelse if (offset < count)\r\nbreak;\r\noffset -= count;\r\n}\r\nreturn -EIO;\r\nfound:\r\nfor (;;) {\r\nstart = be16_to_cpu(extent->block);\r\nif (count <= block_nr) {\r\nhfs_clear_vbm_bits(sb, start, count);\r\nextent->block = 0;\r\nextent->count = 0;\r\nblock_nr -= count;\r\n} else {\r\ncount -= block_nr;\r\nhfs_clear_vbm_bits(sb, start + count, block_nr);\r\nextent->count = cpu_to_be16(count);\r\nblock_nr = 0;\r\n}\r\nif (!block_nr || !i)\r\nreturn 0;\r\ni--;\r\nextent--;\r\ncount = be16_to_cpu(extent->count);\r\n}\r\n}\r\nint hfs_free_fork(struct super_block *sb, struct hfs_cat_file *file, int type)\r\n{\r\nstruct hfs_find_data fd;\r\nu32 total_blocks, blocks, start;\r\nu32 cnid = be32_to_cpu(file->FlNum);\r\nstruct hfs_extent *extent;\r\nint res, i;\r\nif (type == HFS_FK_DATA) {\r\ntotal_blocks = be32_to_cpu(file->PyLen);\r\nextent = file->ExtRec;\r\n} else {\r\ntotal_blocks = be32_to_cpu(file->RPyLen);\r\nextent = file->RExtRec;\r\n}\r\ntotal_blocks /= HFS_SB(sb)->alloc_blksz;\r\nif (!total_blocks)\r\nreturn 0;\r\nblocks = 0;\r\nfor (i = 0; i < 3; extent++, i++)\r\nblocks += be16_to_cpu(extent[i].count);\r\nres = hfs_free_extents(sb, extent, blocks, blocks);\r\nif (res)\r\nreturn res;\r\nif (total_blocks == blocks)\r\nreturn 0;\r\nres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\r\nif (res)\r\nreturn res;\r\ndo {\r\nres = __hfs_ext_read_extent(&fd, extent, cnid, total_blocks, type);\r\nif (res)\r\nbreak;\r\nstart = be16_to_cpu(fd.key->ext.FABN);\r\nhfs_free_extents(sb, extent, total_blocks - start, total_blocks);\r\nhfs_brec_remove(&fd);\r\ntotal_blocks = start;\r\n} while (total_blocks > blocks);\r\nhfs_find_exit(&fd);\r\nreturn res;\r\n}\r\nint hfs_get_block(struct inode *inode, sector_t block,\r\nstruct buffer_head *bh_result, int create)\r\n{\r\nstruct super_block *sb;\r\nu16 dblock, ablock;\r\nint res;\r\nsb = inode->i_sb;\r\nablock = (u32)block / HFS_SB(sb)->fs_div;\r\nif (block >= HFS_I(inode)->fs_blocks) {\r\nif (block > HFS_I(inode)->fs_blocks || !create)\r\nreturn -EIO;\r\nif (ablock >= HFS_I(inode)->alloc_blocks) {\r\nres = hfs_extend_file(inode);\r\nif (res)\r\nreturn res;\r\n}\r\n} else\r\ncreate = 0;\r\nif (ablock < HFS_I(inode)->first_blocks) {\r\ndblock = hfs_ext_find_block(HFS_I(inode)->first_extents, ablock);\r\ngoto done;\r\n}\r\nmutex_lock(&HFS_I(inode)->extents_lock);\r\nres = hfs_ext_read_extent(inode, ablock);\r\nif (!res)\r\ndblock = hfs_ext_find_block(HFS_I(inode)->cached_extents,\r\nablock - HFS_I(inode)->cached_start);\r\nelse {\r\nmutex_unlock(&HFS_I(inode)->extents_lock);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&HFS_I(inode)->extents_lock);\r\ndone:\r\nmap_bh(bh_result, sb, HFS_SB(sb)->fs_start +\r\ndblock * HFS_SB(sb)->fs_div +\r\n(u32)block % HFS_SB(sb)->fs_div);\r\nif (create) {\r\nset_buffer_new(bh_result);\r\nHFS_I(inode)->phys_size += sb->s_blocksize;\r\nHFS_I(inode)->fs_blocks++;\r\ninode_add_bytes(inode, sb->s_blocksize);\r\nmark_inode_dirty(inode);\r\n}\r\nreturn 0;\r\n}\r\nint hfs_extend_file(struct inode *inode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nu32 start, len, goal;\r\nint res;\r\nmutex_lock(&HFS_I(inode)->extents_lock);\r\nif (HFS_I(inode)->alloc_blocks == HFS_I(inode)->first_blocks)\r\ngoal = hfs_ext_lastblock(HFS_I(inode)->first_extents);\r\nelse {\r\nres = hfs_ext_read_extent(inode, HFS_I(inode)->alloc_blocks);\r\nif (res)\r\ngoto out;\r\ngoal = hfs_ext_lastblock(HFS_I(inode)->cached_extents);\r\n}\r\nlen = HFS_I(inode)->clump_blocks;\r\nstart = hfs_vbm_search_free(sb, goal, &len);\r\nif (!len) {\r\nres = -ENOSPC;\r\ngoto out;\r\n}\r\nhfs_dbg(EXTENT, "extend %lu: %u,%u\n", inode->i_ino, start, len);\r\nif (HFS_I(inode)->alloc_blocks == HFS_I(inode)->first_blocks) {\r\nif (!HFS_I(inode)->first_blocks) {\r\nhfs_dbg(EXTENT, "first extents\n");\r\nHFS_I(inode)->first_extents[0].block = cpu_to_be16(start);\r\nHFS_I(inode)->first_extents[0].count = cpu_to_be16(len);\r\nres = 0;\r\n} else {\r\nres = hfs_add_extent(HFS_I(inode)->first_extents,\r\nHFS_I(inode)->alloc_blocks,\r\nstart, len);\r\nif (res == -ENOSPC)\r\ngoto insert_extent;\r\n}\r\nif (!res) {\r\nhfs_dump_extent(HFS_I(inode)->first_extents);\r\nHFS_I(inode)->first_blocks += len;\r\n}\r\n} else {\r\nres = hfs_add_extent(HFS_I(inode)->cached_extents,\r\nHFS_I(inode)->alloc_blocks -\r\nHFS_I(inode)->cached_start,\r\nstart, len);\r\nif (!res) {\r\nhfs_dump_extent(HFS_I(inode)->cached_extents);\r\nHFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY;\r\nHFS_I(inode)->cached_blocks += len;\r\n} else if (res == -ENOSPC)\r\ngoto insert_extent;\r\n}\r\nout:\r\nmutex_unlock(&HFS_I(inode)->extents_lock);\r\nif (!res) {\r\nHFS_I(inode)->alloc_blocks += len;\r\nmark_inode_dirty(inode);\r\nif (inode->i_ino < HFS_FIRSTUSER_CNID)\r\nset_bit(HFS_FLG_ALT_MDB_DIRTY, &HFS_SB(sb)->flags);\r\nset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\r\nhfs_mark_mdb_dirty(sb);\r\n}\r\nreturn res;\r\ninsert_extent:\r\nhfs_dbg(EXTENT, "insert new extent\n");\r\nres = hfs_ext_write_extent(inode);\r\nif (res)\r\ngoto out;\r\nmemset(HFS_I(inode)->cached_extents, 0, sizeof(hfs_extent_rec));\r\nHFS_I(inode)->cached_extents[0].block = cpu_to_be16(start);\r\nHFS_I(inode)->cached_extents[0].count = cpu_to_be16(len);\r\nhfs_dump_extent(HFS_I(inode)->cached_extents);\r\nHFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW;\r\nHFS_I(inode)->cached_start = HFS_I(inode)->alloc_blocks;\r\nHFS_I(inode)->cached_blocks = len;\r\nres = 0;\r\ngoto out;\r\n}\r\nvoid hfs_file_truncate(struct inode *inode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct hfs_find_data fd;\r\nu16 blk_cnt, alloc_cnt, start;\r\nu32 size;\r\nint res;\r\nhfs_dbg(INODE, "truncate: %lu, %Lu -> %Lu\n",\r\ninode->i_ino, (long long)HFS_I(inode)->phys_size,\r\ninode->i_size);\r\nif (inode->i_size > HFS_I(inode)->phys_size) {\r\nstruct address_space *mapping = inode->i_mapping;\r\nvoid *fsdata;\r\nstruct page *page;\r\nsize = inode->i_size - 1;\r\nres = pagecache_write_begin(NULL, mapping, size+1, 0, 0,\r\n&page, &fsdata);\r\nif (!res) {\r\nres = pagecache_write_end(NULL, mapping, size+1, 0, 0,\r\npage, fsdata);\r\n}\r\nif (res)\r\ninode->i_size = HFS_I(inode)->phys_size;\r\nreturn;\r\n} else if (inode->i_size == HFS_I(inode)->phys_size)\r\nreturn;\r\nsize = inode->i_size + HFS_SB(sb)->alloc_blksz - 1;\r\nblk_cnt = size / HFS_SB(sb)->alloc_blksz;\r\nalloc_cnt = HFS_I(inode)->alloc_blocks;\r\nif (blk_cnt == alloc_cnt)\r\ngoto out;\r\nmutex_lock(&HFS_I(inode)->extents_lock);\r\nres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\r\nif (res) {\r\nmutex_unlock(&HFS_I(inode)->extents_lock);\r\nreturn;\r\n}\r\nwhile (1) {\r\nif (alloc_cnt == HFS_I(inode)->first_blocks) {\r\nhfs_free_extents(sb, HFS_I(inode)->first_extents,\r\nalloc_cnt, alloc_cnt - blk_cnt);\r\nhfs_dump_extent(HFS_I(inode)->first_extents);\r\nHFS_I(inode)->first_blocks = blk_cnt;\r\nbreak;\r\n}\r\nres = __hfs_ext_cache_extent(&fd, inode, alloc_cnt);\r\nif (res)\r\nbreak;\r\nstart = HFS_I(inode)->cached_start;\r\nhfs_free_extents(sb, HFS_I(inode)->cached_extents,\r\nalloc_cnt - start, alloc_cnt - blk_cnt);\r\nhfs_dump_extent(HFS_I(inode)->cached_extents);\r\nif (blk_cnt > start) {\r\nHFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY;\r\nbreak;\r\n}\r\nalloc_cnt = start;\r\nHFS_I(inode)->cached_start = HFS_I(inode)->cached_blocks = 0;\r\nHFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);\r\nhfs_brec_remove(&fd);\r\n}\r\nhfs_find_exit(&fd);\r\nmutex_unlock(&HFS_I(inode)->extents_lock);\r\nHFS_I(inode)->alloc_blocks = blk_cnt;\r\nout:\r\nHFS_I(inode)->phys_size = inode->i_size;\r\nHFS_I(inode)->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\r\ninode_set_bytes(inode, HFS_I(inode)->fs_blocks << sb->s_blocksize_bits);\r\nmark_inode_dirty(inode);\r\n}
