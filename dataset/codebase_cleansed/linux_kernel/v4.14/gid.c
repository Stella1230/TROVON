void mlx5_init_reserved_gids(struct mlx5_core_dev *dev)\r\n{\r\nunsigned int tblsz = MLX5_CAP_ROCE(dev, roce_address_table_size);\r\nida_init(&dev->roce.reserved_gids.ida);\r\ndev->roce.reserved_gids.start = tblsz;\r\ndev->roce.reserved_gids.count = 0;\r\n}\r\nvoid mlx5_cleanup_reserved_gids(struct mlx5_core_dev *dev)\r\n{\r\nWARN_ON(!ida_is_empty(&dev->roce.reserved_gids.ida));\r\ndev->roce.reserved_gids.start = 0;\r\ndev->roce.reserved_gids.count = 0;\r\nida_destroy(&dev->roce.reserved_gids.ida);\r\n}\r\nint mlx5_core_reserve_gids(struct mlx5_core_dev *dev, unsigned int count)\r\n{\r\nif (test_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state)) {\r\nmlx5_core_err(dev, "Cannot reserve GIDs when interfaces are up\n");\r\nreturn -EPERM;\r\n}\r\nif (dev->roce.reserved_gids.start < count) {\r\nmlx5_core_warn(dev, "GID table exhausted attempting to reserve %d more GIDs\n",\r\ncount);\r\nreturn -ENOMEM;\r\n}\r\nif (dev->roce.reserved_gids.count + count > MLX5_MAX_RESERVED_GIDS) {\r\nmlx5_core_warn(dev, "Unable to reserve %d more GIDs\n", count);\r\nreturn -ENOMEM;\r\n}\r\ndev->roce.reserved_gids.start -= count;\r\ndev->roce.reserved_gids.count += count;\r\nmlx5_core_dbg(dev, "Reserved %u GIDs starting at %u\n",\r\ndev->roce.reserved_gids.count,\r\ndev->roce.reserved_gids.start);\r\nreturn 0;\r\n}\r\nvoid mlx5_core_unreserve_gids(struct mlx5_core_dev *dev, unsigned int count)\r\n{\r\nWARN(test_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state), "Unreserving GIDs when interfaces are up");\r\nWARN(count > dev->roce.reserved_gids.count, "Unreserving %u GIDs when only %u reserved",\r\ncount, dev->roce.reserved_gids.count);\r\ndev->roce.reserved_gids.start += count;\r\ndev->roce.reserved_gids.count -= count;\r\nmlx5_core_dbg(dev, "%u GIDs starting at %u left reserved\n",\r\ndev->roce.reserved_gids.count,\r\ndev->roce.reserved_gids.start);\r\n}\r\nint mlx5_core_reserved_gid_alloc(struct mlx5_core_dev *dev, int *gid_index)\r\n{\r\nint end = dev->roce.reserved_gids.start +\r\ndev->roce.reserved_gids.count;\r\nint index = 0;\r\nindex = ida_simple_get(&dev->roce.reserved_gids.ida,\r\ndev->roce.reserved_gids.start, end,\r\nGFP_KERNEL);\r\nif (index < 0)\r\nreturn index;\r\nmlx5_core_dbg(dev, "Allocating reserved GID %u\n", index);\r\n*gid_index = index;\r\nreturn 0;\r\n}\r\nvoid mlx5_core_reserved_gid_free(struct mlx5_core_dev *dev, int gid_index)\r\n{\r\nmlx5_core_dbg(dev, "Freeing reserved GID %u\n", gid_index);\r\nida_simple_remove(&dev->roce.reserved_gids.ida, gid_index);\r\n}\r\nunsigned int mlx5_core_reserved_gids_count(struct mlx5_core_dev *dev)\r\n{\r\nreturn dev->roce.reserved_gids.count;\r\n}\r\nint mlx5_core_roce_gid_set(struct mlx5_core_dev *dev, unsigned int index,\r\nu8 roce_version, u8 roce_l3_type, const u8 *gid,\r\nconst u8 *mac, bool vlan, u16 vlan_id)\r\n{\r\n#define MLX5_SET_RA(p, f, v) MLX5_SET(roce_addr_layout, p, f, v)\r\nu32 in[MLX5_ST_SZ_DW(set_roce_address_in)] = {0};\r\nu32 out[MLX5_ST_SZ_DW(set_roce_address_out)] = {0};\r\nvoid *in_addr = MLX5_ADDR_OF(set_roce_address_in, in, roce_address);\r\nchar *addr_l3_addr = MLX5_ADDR_OF(roce_addr_layout, in_addr,\r\nsource_l3_address);\r\nvoid *addr_mac = MLX5_ADDR_OF(roce_addr_layout, in_addr,\r\nsource_mac_47_32);\r\nint gidsz = MLX5_FLD_SZ_BYTES(roce_addr_layout, source_l3_address);\r\nif (MLX5_CAP_GEN(dev, port_type) != MLX5_CAP_PORT_TYPE_ETH)\r\nreturn -EINVAL;\r\nif (gid) {\r\nif (vlan) {\r\nMLX5_SET_RA(in_addr, vlan_valid, 1);\r\nMLX5_SET_RA(in_addr, vlan_id, vlan_id);\r\n}\r\nether_addr_copy(addr_mac, mac);\r\nMLX5_SET_RA(in_addr, roce_version, roce_version);\r\nMLX5_SET_RA(in_addr, roce_l3_type, roce_l3_type);\r\nmemcpy(addr_l3_addr, gid, gidsz);\r\n}\r\nMLX5_SET(set_roce_address_in, in, roce_address_index, index);\r\nMLX5_SET(set_roce_address_in, in, opcode, MLX5_CMD_OP_SET_ROCE_ADDRESS);\r\nreturn mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));\r\n}
