struct cec_notifier *cec_notifier_get(struct device *dev)\r\n{\r\nstruct cec_notifier *n;\r\nmutex_lock(&cec_notifiers_lock);\r\nlist_for_each_entry(n, &cec_notifiers, head) {\r\nif (n->dev == dev) {\r\nkref_get(&n->kref);\r\nmutex_unlock(&cec_notifiers_lock);\r\nreturn n;\r\n}\r\n}\r\nn = kzalloc(sizeof(*n), GFP_KERNEL);\r\nif (!n)\r\ngoto unlock;\r\nn->dev = dev;\r\nn->phys_addr = CEC_PHYS_ADDR_INVALID;\r\nmutex_init(&n->lock);\r\nkref_init(&n->kref);\r\nlist_add_tail(&n->head, &cec_notifiers);\r\nunlock:\r\nmutex_unlock(&cec_notifiers_lock);\r\nreturn n;\r\n}\r\nstatic void cec_notifier_release(struct kref *kref)\r\n{\r\nstruct cec_notifier *n =\r\ncontainer_of(kref, struct cec_notifier, kref);\r\nlist_del(&n->head);\r\nkfree(n);\r\n}\r\nvoid cec_notifier_put(struct cec_notifier *n)\r\n{\r\nmutex_lock(&cec_notifiers_lock);\r\nkref_put(&n->kref, cec_notifier_release);\r\nmutex_unlock(&cec_notifiers_lock);\r\n}\r\nvoid cec_notifier_set_phys_addr(struct cec_notifier *n, u16 pa)\r\n{\r\nif (n == NULL)\r\nreturn;\r\nmutex_lock(&n->lock);\r\nn->phys_addr = pa;\r\nif (n->callback)\r\nn->callback(n->cec_adap, n->phys_addr);\r\nmutex_unlock(&n->lock);\r\n}\r\nvoid cec_notifier_set_phys_addr_from_edid(struct cec_notifier *n,\r\nconst struct edid *edid)\r\n{\r\nu16 pa = CEC_PHYS_ADDR_INVALID;\r\nif (n == NULL)\r\nreturn;\r\nif (edid && edid->extensions)\r\npa = cec_get_edid_phys_addr((const u8 *)edid,\r\nEDID_LENGTH * (edid->extensions + 1), NULL);\r\ncec_notifier_set_phys_addr(n, pa);\r\n}\r\nvoid cec_notifier_register(struct cec_notifier *n,\r\nstruct cec_adapter *adap,\r\nvoid (*callback)(struct cec_adapter *adap, u16 pa))\r\n{\r\nkref_get(&n->kref);\r\nmutex_lock(&n->lock);\r\nn->cec_adap = adap;\r\nn->callback = callback;\r\nn->callback(adap, n->phys_addr);\r\nmutex_unlock(&n->lock);\r\n}\r\nvoid cec_notifier_unregister(struct cec_notifier *n)\r\n{\r\nmutex_lock(&n->lock);\r\nn->callback = NULL;\r\nmutex_unlock(&n->lock);\r\ncec_notifier_put(n);\r\n}
