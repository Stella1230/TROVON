static void pata_s3c_set_endian(void __iomem *s3c_ide_regbase, u8 mode)\r\n{\r\nu32 reg = readl(s3c_ide_regbase + S3C_ATA_CFG);\r\nreg = mode ? (reg & ~S3C_ATA_CFG_SWAP) : (reg | S3C_ATA_CFG_SWAP);\r\nwritel(reg, s3c_ide_regbase + S3C_ATA_CFG);\r\n}\r\nstatic void pata_s3c_cfg_mode(void __iomem *s3c_ide_sfrbase)\r\n{\r\nwritel(readl(s3c_ide_sfrbase + S3C_CFATA_MUX) | S3C_CFATA_MUX_TRUEIDE,\r\ns3c_ide_sfrbase + S3C_CFATA_MUX);\r\n}\r\nstatic unsigned long\r\npata_s3c_setup_timing(struct s3c_ide_info *info, const struct ata_timing *ata)\r\n{\r\nint t1 = ata->setup;\r\nint t2 = ata->act8b;\r\nint t2i = ata->rec8b;\r\nulong piotime;\r\npiotime = ((t2i & 0xff) << 12) | ((t2 & 0xff) << 4) | (t1 & 0xf);\r\nreturn piotime;\r\n}\r\nstatic void pata_s3c_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct s3c_ide_info *info = ap->host->private_data;\r\nstruct ata_timing timing;\r\nint cycle_time;\r\nulong ata_cfg = readl(info->ide_addr + S3C_ATA_CFG);\r\nulong piotime;\r\nif (ata_pio_need_iordy(adev))\r\nata_cfg |= S3C_ATA_CFG_IORDYEN;\r\nelse\r\nata_cfg &= ~S3C_ATA_CFG_IORDYEN;\r\ncycle_time = (int)(1000000000UL / clk_get_rate(info->clk));\r\nata_timing_compute(adev, adev->pio_mode, &timing,\r\ncycle_time * 1000, 0);\r\npiotime = pata_s3c_setup_timing(info, &timing);\r\nwritel(ata_cfg, info->ide_addr + S3C_ATA_CFG);\r\nwritel(piotime, info->ide_addr + S3C_ATA_PIO_TIME);\r\n}\r\nstatic int wait_for_host_ready(struct s3c_ide_info *info)\r\n{\r\nulong timeout;\r\nvoid __iomem *fifo_reg = info->ide_addr + info->fifo_status_reg;\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\nwhile (time_before(jiffies, timeout)) {\r\nif ((readl(fifo_reg) >> 28) == 0)\r\nreturn 0;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic void ata_outb(struct ata_host *host, u8 addr, void __iomem *reg)\r\n{\r\nstruct s3c_ide_info *info = host->private_data;\r\nwait_for_host_ready(info);\r\nwriteb(addr, reg);\r\n}\r\nstatic u8 ata_inb(struct ata_host *host, void __iomem *reg)\r\n{\r\nstruct s3c_ide_info *info = host->private_data;\r\nu8 temp;\r\nwait_for_host_ready(info);\r\n(void) readb(reg);\r\nwait_for_host_ready(info);\r\ntemp = readb(info->ide_addr + S3C_ATA_PIO_RDATA);\r\nreturn temp;\r\n}\r\nstatic void pata_s3c_tf_load(struct ata_port *ap,\r\nconst struct ata_taskfile *tf)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nunsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;\r\nif (tf->ctl != ap->last_ctl) {\r\nata_outb(ap->host, tf->ctl, ioaddr->ctl_addr);\r\nap->last_ctl = tf->ctl;\r\nata_wait_idle(ap);\r\n}\r\nif (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {\r\nata_outb(ap->host, tf->hob_feature, ioaddr->feature_addr);\r\nata_outb(ap->host, tf->hob_nsect, ioaddr->nsect_addr);\r\nata_outb(ap->host, tf->hob_lbal, ioaddr->lbal_addr);\r\nata_outb(ap->host, tf->hob_lbam, ioaddr->lbam_addr);\r\nata_outb(ap->host, tf->hob_lbah, ioaddr->lbah_addr);\r\n}\r\nif (is_addr) {\r\nata_outb(ap->host, tf->feature, ioaddr->feature_addr);\r\nata_outb(ap->host, tf->nsect, ioaddr->nsect_addr);\r\nata_outb(ap->host, tf->lbal, ioaddr->lbal_addr);\r\nata_outb(ap->host, tf->lbam, ioaddr->lbam_addr);\r\nata_outb(ap->host, tf->lbah, ioaddr->lbah_addr);\r\n}\r\nif (tf->flags & ATA_TFLAG_DEVICE)\r\nata_outb(ap->host, tf->device, ioaddr->device_addr);\r\nata_wait_idle(ap);\r\n}\r\nstatic void pata_s3c_tf_read(struct ata_port *ap, struct ata_taskfile *tf)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\ntf->feature = ata_inb(ap->host, ioaddr->error_addr);\r\ntf->nsect = ata_inb(ap->host, ioaddr->nsect_addr);\r\ntf->lbal = ata_inb(ap->host, ioaddr->lbal_addr);\r\ntf->lbam = ata_inb(ap->host, ioaddr->lbam_addr);\r\ntf->lbah = ata_inb(ap->host, ioaddr->lbah_addr);\r\ntf->device = ata_inb(ap->host, ioaddr->device_addr);\r\nif (tf->flags & ATA_TFLAG_LBA48) {\r\nata_outb(ap->host, tf->ctl | ATA_HOB, ioaddr->ctl_addr);\r\ntf->hob_feature = ata_inb(ap->host, ioaddr->error_addr);\r\ntf->hob_nsect = ata_inb(ap->host, ioaddr->nsect_addr);\r\ntf->hob_lbal = ata_inb(ap->host, ioaddr->lbal_addr);\r\ntf->hob_lbam = ata_inb(ap->host, ioaddr->lbam_addr);\r\ntf->hob_lbah = ata_inb(ap->host, ioaddr->lbah_addr);\r\nata_outb(ap->host, tf->ctl, ioaddr->ctl_addr);\r\nap->last_ctl = tf->ctl;\r\n}\r\n}\r\nstatic void pata_s3c_exec_command(struct ata_port *ap,\r\nconst struct ata_taskfile *tf)\r\n{\r\nata_outb(ap->host, tf->command, ap->ioaddr.command_addr);\r\nata_sff_pause(ap);\r\n}\r\nstatic u8 pata_s3c_check_status(struct ata_port *ap)\r\n{\r\nreturn ata_inb(ap->host, ap->ioaddr.status_addr);\r\n}\r\nstatic u8 pata_s3c_check_altstatus(struct ata_port *ap)\r\n{\r\nreturn ata_inb(ap->host, ap->ioaddr.altstatus_addr);\r\n}\r\nstatic unsigned int pata_s3c_data_xfer(struct ata_queued_cmd *qc,\r\nunsigned char *buf, unsigned int buflen, int rw)\r\n{\r\nstruct ata_port *ap = qc->dev->link->ap;\r\nstruct s3c_ide_info *info = ap->host->private_data;\r\nvoid __iomem *data_addr = ap->ioaddr.data_addr;\r\nunsigned int words = buflen >> 1, i;\r\nu16 *data_ptr = (u16 *)buf;\r\nif (rw == READ)\r\nfor (i = 0; i < words; i++, data_ptr++) {\r\nwait_for_host_ready(info);\r\n(void) readw(data_addr);\r\nwait_for_host_ready(info);\r\n*data_ptr = readw(info->ide_addr\r\n+ S3C_ATA_PIO_RDATA);\r\n}\r\nelse\r\nfor (i = 0; i < words; i++, data_ptr++) {\r\nwait_for_host_ready(info);\r\nwritew(*data_ptr, data_addr);\r\n}\r\nif (buflen & 0x01)\r\ndev_err(ap->dev, "unexpected trailing data\n");\r\nreturn words << 1;\r\n}\r\nstatic void pata_s3c_dev_select(struct ata_port *ap, unsigned int device)\r\n{\r\nu8 tmp = ATA_DEVICE_OBS;\r\nif (device != 0)\r\ntmp |= ATA_DEV1;\r\nata_outb(ap->host, tmp, ap->ioaddr.device_addr);\r\nata_sff_pause(ap);\r\n}\r\nstatic unsigned int pata_s3c_devchk(struct ata_port *ap,\r\nunsigned int device)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nu8 nsect, lbal;\r\npata_s3c_dev_select(ap, device);\r\nata_outb(ap->host, 0x55, ioaddr->nsect_addr);\r\nata_outb(ap->host, 0xaa, ioaddr->lbal_addr);\r\nata_outb(ap->host, 0xaa, ioaddr->nsect_addr);\r\nata_outb(ap->host, 0x55, ioaddr->lbal_addr);\r\nata_outb(ap->host, 0x55, ioaddr->nsect_addr);\r\nata_outb(ap->host, 0xaa, ioaddr->lbal_addr);\r\nnsect = ata_inb(ap->host, ioaddr->nsect_addr);\r\nlbal = ata_inb(ap->host, ioaddr->lbal_addr);\r\nif ((nsect == 0x55) && (lbal == 0xaa))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int pata_s3c_wait_after_reset(struct ata_link *link,\r\nunsigned long deadline)\r\n{\r\nint rc;\r\nata_msleep(link->ap, ATA_WAIT_AFTER_RESET);\r\nrc = ata_sff_wait_ready(link, deadline);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int pata_s3c_bus_softreset(struct ata_port *ap,\r\nunsigned long deadline)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nata_outb(ap->host, ap->ctl, ioaddr->ctl_addr);\r\nudelay(20);\r\nata_outb(ap->host, ap->ctl | ATA_SRST, ioaddr->ctl_addr);\r\nudelay(20);\r\nata_outb(ap->host, ap->ctl, ioaddr->ctl_addr);\r\nap->last_ctl = ap->ctl;\r\nreturn pata_s3c_wait_after_reset(&ap->link, deadline);\r\n}\r\nstatic int pata_s3c_softreset(struct ata_link *link, unsigned int *classes,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nunsigned int devmask = 0;\r\nint rc;\r\nu8 err;\r\nif (pata_s3c_devchk(ap, 0))\r\ndevmask |= (1 << 0);\r\npata_s3c_dev_select(ap, 0);\r\nrc = pata_s3c_bus_softreset(ap, deadline);\r\nif (rc && rc != -ENODEV) {\r\nata_link_err(link, "SRST failed (errno=%d)\n", rc);\r\nreturn rc;\r\n}\r\nclasses[0] = ata_sff_dev_classify(&ap->link.device[0],\r\ndevmask & (1 << 0), &err);\r\nreturn 0;\r\n}\r\nstatic void pata_s3c_set_devctl(struct ata_port *ap, u8 ctl)\r\n{\r\nata_outb(ap->host, ctl, ap->ioaddr.ctl_addr);\r\n}\r\nstatic void pata_s3c_enable(void __iomem *s3c_ide_regbase, bool state)\r\n{\r\nu32 temp = readl(s3c_ide_regbase + S3C_ATA_CTRL);\r\ntemp = state ? (temp | 1) : (temp & ~1);\r\nwritel(temp, s3c_ide_regbase + S3C_ATA_CTRL);\r\n}\r\nstatic irqreturn_t pata_s3c_irq(int irq, void *dev_instance)\r\n{\r\nstruct ata_host *host = dev_instance;\r\nstruct s3c_ide_info *info = host->private_data;\r\nu32 reg;\r\nreg = readl(info->ide_addr + S3C_ATA_IRQ);\r\nwritel(reg, info->ide_addr + S3C_ATA_IRQ);\r\nreturn ata_sff_interrupt(irq, dev_instance);\r\n}\r\nstatic void pata_s3c_hwinit(struct s3c_ide_info *info,\r\nstruct s3c_ide_platdata *pdata)\r\n{\r\nswitch (info->cpu_type) {\r\ncase TYPE_S3C64XX:\r\npata_s3c_cfg_mode(info->sfr_addr);\r\npata_s3c_set_endian(info->ide_addr, 1);\r\npata_s3c_enable(info->ide_addr, true);\r\nmsleep(100);\r\nwritel(0x1f, info->ide_addr + S3C_ATA_IRQ);\r\nwritel(0x1b, info->ide_addr + S3C_ATA_IRQ_MSK);\r\nbreak;\r\ncase TYPE_S5PV210:\r\npata_s3c_set_endian(info->ide_addr, 0);\r\npata_s3c_enable(info->ide_addr, true);\r\nmsleep(100);\r\nwritel(0x3f, info->ide_addr + S3C_ATA_IRQ);\r\nwritel(0x3f, info->ide_addr + S3C_ATA_IRQ_MSK);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic int __init pata_s3c_probe(struct platform_device *pdev)\r\n{\r\nstruct s3c_ide_platdata *pdata = dev_get_platdata(&pdev->dev);\r\nstruct device *dev = &pdev->dev;\r\nstruct s3c_ide_info *info;\r\nstruct resource *res;\r\nstruct ata_port *ap;\r\nstruct ata_host *host;\r\nenum s3c_cpu_type cpu_type;\r\nint ret;\r\ncpu_type = platform_get_device_id(pdev)->driver_data;\r\ninfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\ndev_err(dev, "failed to allocate memory for device data\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo->irq = platform_get_irq(pdev, 0);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ninfo->ide_addr = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(info->ide_addr))\r\nreturn PTR_ERR(info->ide_addr);\r\ninfo->clk = devm_clk_get(&pdev->dev, "cfcon");\r\nif (IS_ERR(info->clk)) {\r\ndev_err(dev, "failed to get access to cf controller clock\n");\r\nret = PTR_ERR(info->clk);\r\ninfo->clk = NULL;\r\nreturn ret;\r\n}\r\nclk_enable(info->clk);\r\nhost = ata_host_alloc(dev, 1);\r\nif (!host) {\r\ndev_err(dev, "failed to allocate ide host\n");\r\nret = -ENOMEM;\r\ngoto stop_clk;\r\n}\r\nap = host->ports[0];\r\nap->pio_mask = ATA_PIO4;\r\nif (cpu_type == TYPE_S3C64XX) {\r\nap->ops = &pata_s3c_port_ops;\r\ninfo->sfr_addr = info->ide_addr + 0x1800;\r\ninfo->ide_addr += 0x1900;\r\ninfo->fifo_status_reg = 0x94;\r\n} else {\r\nap->ops = &pata_s5p_port_ops;\r\ninfo->fifo_status_reg = 0x84;\r\n}\r\ninfo->cpu_type = cpu_type;\r\nif (info->irq <= 0) {\r\nap->flags |= ATA_FLAG_PIO_POLLING;\r\ninfo->irq = 0;\r\nata_port_desc(ap, "no IRQ, using PIO polling\n");\r\n}\r\nap->ioaddr.cmd_addr = info->ide_addr + S3C_ATA_CMD;\r\nap->ioaddr.data_addr = info->ide_addr + S3C_ATA_PIO_DTR;\r\nap->ioaddr.error_addr = info->ide_addr + S3C_ATA_PIO_FED;\r\nap->ioaddr.feature_addr = info->ide_addr + S3C_ATA_PIO_FED;\r\nap->ioaddr.nsect_addr = info->ide_addr + S3C_ATA_PIO_SCR;\r\nap->ioaddr.lbal_addr = info->ide_addr + S3C_ATA_PIO_LLR;\r\nap->ioaddr.lbam_addr = info->ide_addr + S3C_ATA_PIO_LMR;\r\nap->ioaddr.lbah_addr = info->ide_addr + S3C_ATA_PIO_LHR;\r\nap->ioaddr.device_addr = info->ide_addr + S3C_ATA_PIO_DVR;\r\nap->ioaddr.status_addr = info->ide_addr + S3C_ATA_PIO_CSD;\r\nap->ioaddr.command_addr = info->ide_addr + S3C_ATA_PIO_CSD;\r\nap->ioaddr.altstatus_addr = info->ide_addr + S3C_ATA_PIO_DAD;\r\nap->ioaddr.ctl_addr = info->ide_addr + S3C_ATA_PIO_DAD;\r\nata_port_desc(ap, "mmio cmd 0x%llx ",\r\n(unsigned long long)res->start);\r\nhost->private_data = info;\r\nif (pdata && pdata->setup_gpio)\r\npdata->setup_gpio();\r\npata_s3c_hwinit(info, pdata);\r\nret = ata_host_activate(host, info->irq,\r\ninfo->irq ? pata_s3c_irq : NULL,\r\n0, &pata_s3c_sht);\r\nif (ret)\r\ngoto stop_clk;\r\nreturn 0;\r\nstop_clk:\r\nclk_disable(info->clk);\r\nreturn ret;\r\n}\r\nstatic int __exit pata_s3c_remove(struct platform_device *pdev)\r\n{\r\nstruct ata_host *host = platform_get_drvdata(pdev);\r\nstruct s3c_ide_info *info = host->private_data;\r\nata_host_detach(host);\r\nclk_disable(info->clk);\r\nreturn 0;\r\n}\r\nstatic int pata_s3c_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ata_host *host = platform_get_drvdata(pdev);\r\nreturn ata_host_suspend(host, PMSG_SUSPEND);\r\n}\r\nstatic int pata_s3c_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ata_host *host = platform_get_drvdata(pdev);\r\nstruct s3c_ide_platdata *pdata = dev_get_platdata(&pdev->dev);\r\nstruct s3c_ide_info *info = host->private_data;\r\npata_s3c_hwinit(info, pdata);\r\nata_host_resume(host);\r\nreturn 0;\r\n}
