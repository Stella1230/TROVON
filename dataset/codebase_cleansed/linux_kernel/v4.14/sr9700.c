static int sr_read(struct usbnet *dev, u8 reg, u16 length, void *data)\r\n{\r\nint err;\r\nerr = usbnet_read_cmd(dev, SR_RD_REGS, SR_REQ_RD_REG, 0, reg, data,\r\nlength);\r\nif ((err != length) && (err >= 0))\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nstatic int sr_write(struct usbnet *dev, u8 reg, u16 length, void *data)\r\n{\r\nint err;\r\nerr = usbnet_write_cmd(dev, SR_WR_REGS, SR_REQ_WR_REG, 0, reg, data,\r\nlength);\r\nif ((err >= 0) && (err < length))\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nstatic int sr_read_reg(struct usbnet *dev, u8 reg, u8 *value)\r\n{\r\nreturn sr_read(dev, reg, 1, value);\r\n}\r\nstatic int sr_write_reg(struct usbnet *dev, u8 reg, u8 value)\r\n{\r\nreturn usbnet_write_cmd(dev, SR_WR_REGS, SR_REQ_WR_REG,\r\nvalue, reg, NULL, 0);\r\n}\r\nstatic void sr_write_async(struct usbnet *dev, u8 reg, u16 length, void *data)\r\n{\r\nusbnet_write_cmd_async(dev, SR_WR_REGS, SR_REQ_WR_REG,\r\n0, reg, data, length);\r\n}\r\nstatic void sr_write_reg_async(struct usbnet *dev, u8 reg, u8 value)\r\n{\r\nusbnet_write_cmd_async(dev, SR_WR_REGS, SR_REQ_WR_REG,\r\nvalue, reg, NULL, 0);\r\n}\r\nstatic int wait_phy_eeprom_ready(struct usbnet *dev, int phy)\r\n{\r\nint i;\r\nfor (i = 0; i < SR_SHARE_TIMEOUT; i++) {\r\nu8 tmp = 0;\r\nint ret;\r\nudelay(1);\r\nret = sr_read_reg(dev, SR_EPCR, &tmp);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(tmp & EPCR_ERRE))\r\nreturn 0;\r\n}\r\nnetdev_err(dev->net, "%s write timed out!\n", phy ? "phy" : "eeprom");\r\nreturn -EIO;\r\n}\r\nstatic int sr_share_read_word(struct usbnet *dev, int phy, u8 reg,\r\n__le16 *value)\r\n{\r\nint ret;\r\nmutex_lock(&dev->phy_mutex);\r\nsr_write_reg(dev, SR_EPAR, phy ? (reg | EPAR_PHY_ADR) : reg);\r\nsr_write_reg(dev, SR_EPCR, phy ? (EPCR_EPOS | EPCR_ERPRR) : EPCR_ERPRR);\r\nret = wait_phy_eeprom_ready(dev, phy);\r\nif (ret < 0)\r\ngoto out_unlock;\r\nsr_write_reg(dev, SR_EPCR, 0x0);\r\nret = sr_read(dev, SR_EPDR, 2, value);\r\nnetdev_dbg(dev->net, "read shared %d 0x%02x returned 0x%04x, %d\n",\r\nphy, reg, *value, ret);\r\nout_unlock:\r\nmutex_unlock(&dev->phy_mutex);\r\nreturn ret;\r\n}\r\nstatic int sr_share_write_word(struct usbnet *dev, int phy, u8 reg,\r\n__le16 value)\r\n{\r\nint ret;\r\nmutex_lock(&dev->phy_mutex);\r\nret = sr_write(dev, SR_EPDR, 2, &value);\r\nif (ret < 0)\r\ngoto out_unlock;\r\nsr_write_reg(dev, SR_EPAR, phy ? (reg | EPAR_PHY_ADR) : reg);\r\nsr_write_reg(dev, SR_EPCR, phy ? (EPCR_WEP | EPCR_EPOS | EPCR_ERPRW) :\r\n(EPCR_WEP | EPCR_ERPRW));\r\nret = wait_phy_eeprom_ready(dev, phy);\r\nif (ret < 0)\r\ngoto out_unlock;\r\nsr_write_reg(dev, SR_EPCR, 0x0);\r\nout_unlock:\r\nmutex_unlock(&dev->phy_mutex);\r\nreturn ret;\r\n}\r\nstatic int sr_read_eeprom_word(struct usbnet *dev, u8 offset, void *value)\r\n{\r\nreturn sr_share_read_word(dev, 0, offset, value);\r\n}\r\nstatic int sr9700_get_eeprom_len(struct net_device *netdev)\r\n{\r\nreturn SR_EEPROM_LEN;\r\n}\r\nstatic int sr9700_get_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\n__le16 *buf = (__le16 *)data;\r\nint ret = 0;\r\nint i;\r\nif ((eeprom->offset & 0x01) || (eeprom->len & 0x01))\r\nreturn -EINVAL;\r\nfor (i = 0; i < eeprom->len / 2; i++) {\r\nret = sr_read_eeprom_word(dev, eeprom->offset / 2 + i, buf + i);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sr_mdio_read(struct net_device *netdev, int phy_id, int loc)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\n__le16 res;\r\nint rc = 0;\r\nif (phy_id) {\r\nnetdev_dbg(netdev, "Only internal phy supported\n");\r\nreturn 0;\r\n}\r\nif (loc == MII_BMSR) {\r\nu8 value;\r\nsr_read_reg(dev, SR_NSR, &value);\r\nif (value & NSR_LINKST)\r\nrc = 1;\r\n}\r\nsr_share_read_word(dev, 1, loc, &res);\r\nif (rc == 1)\r\nres = le16_to_cpu(res) | BMSR_LSTATUS;\r\nelse\r\nres = le16_to_cpu(res) & ~BMSR_LSTATUS;\r\nnetdev_dbg(netdev, "sr_mdio_read() phy_id=0x%02x, loc=0x%02x, returns=0x%04x\n",\r\nphy_id, loc, res);\r\nreturn res;\r\n}\r\nstatic void sr_mdio_write(struct net_device *netdev, int phy_id, int loc,\r\nint val)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\n__le16 res = cpu_to_le16(val);\r\nif (phy_id) {\r\nnetdev_dbg(netdev, "Only internal phy supported\n");\r\nreturn;\r\n}\r\nnetdev_dbg(netdev, "sr_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x\n",\r\nphy_id, loc, val);\r\nsr_share_write_word(dev, 1, loc, res);\r\n}\r\nstatic u32 sr9700_get_link(struct net_device *netdev)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nu8 value = 0;\r\nint rc = 0;\r\nsr_read_reg(dev, SR_NSR, &value);\r\nif (value & NSR_LINKST)\r\nrc = 1;\r\nreturn rc;\r\n}\r\nstatic int sr9700_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nreturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\r\n}\r\nstatic void sr9700_set_multicast(struct net_device *netdev)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nu8 *hashes = (u8 *)&dev->data;\r\nu8 rx_ctl = RCR_RXEN | RCR_DIS_CRC | RCR_DIS_LONG;\r\nmemset(hashes, 0x00, SR_MCAST_SIZE);\r\nhashes[SR_MCAST_SIZE - 1] |= SR_MCAST_ADDR_FLAG;\r\nif (netdev->flags & IFF_PROMISC) {\r\nrx_ctl |= RCR_PRMSC;\r\n} else if (netdev->flags & IFF_ALLMULTI ||\r\nnetdev_mc_count(netdev) > SR_MCAST_MAX) {\r\nrx_ctl |= RCR_RUNT;\r\n} else if (!netdev_mc_empty(netdev)) {\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nu32 crc = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nhashes[crc >> 3] |= 1 << (crc & 0x7);\r\n}\r\n}\r\nsr_write_async(dev, SR_MAR, SR_MCAST_SIZE, hashes);\r\nsr_write_reg_async(dev, SR_RCR, rx_ctl);\r\n}\r\nstatic int sr9700_set_mac_address(struct net_device *netdev, void *p)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data)) {\r\nnetdev_err(netdev, "not setting invalid mac address %pM\n",\r\naddr->sa_data);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\r\nsr_write_async(dev, SR_PAR, 6, netdev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic int sr9700_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct net_device *netdev;\r\nstruct mii_if_info *mii;\r\nint ret;\r\nret = usbnet_get_endpoints(dev, intf);\r\nif (ret)\r\ngoto out;\r\nnetdev = dev->net;\r\nnetdev->netdev_ops = &sr9700_netdev_ops;\r\nnetdev->ethtool_ops = &sr9700_ethtool_ops;\r\nnetdev->hard_header_len += SR_TX_OVERHEAD;\r\ndev->hard_mtu = netdev->mtu + netdev->hard_header_len;\r\ndev->rx_urb_size = 3072;\r\nmii = &dev->mii;\r\nmii->dev = netdev;\r\nmii->mdio_read = sr_mdio_read;\r\nmii->mdio_write = sr_mdio_write;\r\nmii->phy_id_mask = 0x1f;\r\nmii->reg_num_mask = 0x1f;\r\nsr_write_reg(dev, SR_NCR, NCR_RST);\r\nudelay(20);\r\nif (sr_read(dev, SR_PAR, ETH_ALEN, netdev->dev_addr) < 0) {\r\nnetdev_err(netdev, "Error reading MAC address\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nsr_write_reg(dev, SR_PRR, PRR_PHY_RST);\r\nmdelay(20);\r\nsr_write_reg(dev, SR_PRR, 0);\r\nudelay(2 * 1000);\r\nsr9700_set_multicast(netdev);\r\nsr_mdio_write(netdev, mii->phy_id, MII_BMCR, BMCR_RESET);\r\nsr_mdio_write(netdev, mii->phy_id, MII_ADVERTISE, ADVERTISE_ALL |\r\nADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);\r\nmii_nway_restart(mii);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int sr9700_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *sr_skb;\r\nint len;\r\nif (unlikely(skb->len < SR_RX_OVERHEAD)) {\r\nnetdev_err(dev->net, "unexpected tiny rx frame\n");\r\nreturn 0;\r\n}\r\nwhile (skb->len > SR_RX_OVERHEAD) {\r\nif (skb->data[0] != 0x40)\r\nreturn 0;\r\nlen = (skb->data[1] | (skb->data[2] << 8)) - 4;\r\nif (len > ETH_FRAME_LEN)\r\nreturn 0;\r\nif (skb->len == (len + SR_RX_OVERHEAD)) {\r\nskb_pull(skb, 3);\r\nskb->len = len;\r\nskb_set_tail_pointer(skb, len);\r\nskb->truesize = len + sizeof(struct sk_buff);\r\nreturn 2;\r\n}\r\nsr_skb = skb_clone(skb, GFP_ATOMIC);\r\nif (!sr_skb)\r\nreturn 0;\r\nsr_skb->len = len;\r\nsr_skb->data = skb->data + 3;\r\nskb_set_tail_pointer(sr_skb, len);\r\nsr_skb->truesize = len + sizeof(struct sk_buff);\r\nusbnet_skb_return(dev, sr_skb);\r\nskb_pull(skb, len + SR_RX_OVERHEAD);\r\n};\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *sr9700_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\r\ngfp_t flags)\r\n{\r\nint len;\r\nlen = skb->len;\r\nif (skb_cow_head(skb, SR_TX_OVERHEAD)) {\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n}\r\n__skb_push(skb, SR_TX_OVERHEAD);\r\nif ((skb->len % dev->maxpacket) == 0)\r\nlen++;\r\nskb->data[0] = len;\r\nskb->data[1] = len >> 8;\r\nreturn skb;\r\n}\r\nstatic void sr9700_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nint link;\r\nu8 *buf;\r\nif (urb->actual_length < 8)\r\nreturn;\r\nbuf = urb->transfer_buffer;\r\nlink = !!(buf[0] & 0x40);\r\nif (netif_carrier_ok(dev->net) != link) {\r\nusbnet_link_change(dev, link, 1);\r\nnetdev_dbg(dev->net, "Link Status is: %d\n", link);\r\n}\r\n}\r\nstatic int sr9700_link_reset(struct usbnet *dev)\r\n{\r\nstruct ethtool_cmd ecmd;\r\nmii_check_media(&dev->mii, 1, 1);\r\nmii_ethtool_gset(&dev->mii, &ecmd);\r\nnetdev_dbg(dev->net, "link_reset() speed: %d duplex: %d\n",\r\necmd.speed, ecmd.duplex);\r\nreturn 0;\r\n}
