static int rockchip_rk3288_efuse_read(void *context, unsigned int offset,\r\nvoid *val, size_t bytes)\r\n{\r\nstruct rockchip_efuse_chip *efuse = context;\r\nu8 *buf = val;\r\nint ret;\r\nret = clk_prepare_enable(efuse->clk);\r\nif (ret < 0) {\r\ndev_err(efuse->dev, "failed to prepare/enable efuse clk\n");\r\nreturn ret;\r\n}\r\nwritel(RK3288_LOAD | RK3288_PGENB, efuse->base + REG_EFUSE_CTRL);\r\nudelay(1);\r\nwhile (bytes--) {\r\nwritel(readl(efuse->base + REG_EFUSE_CTRL) &\r\n(~(RK3288_A_MASK << RK3288_A_SHIFT)),\r\nefuse->base + REG_EFUSE_CTRL);\r\nwritel(readl(efuse->base + REG_EFUSE_CTRL) |\r\n((offset++ & RK3288_A_MASK) << RK3288_A_SHIFT),\r\nefuse->base + REG_EFUSE_CTRL);\r\nudelay(1);\r\nwritel(readl(efuse->base + REG_EFUSE_CTRL) |\r\nRK3288_STROBE, efuse->base + REG_EFUSE_CTRL);\r\nudelay(1);\r\n*buf++ = readb(efuse->base + REG_EFUSE_DOUT);\r\nwritel(readl(efuse->base + REG_EFUSE_CTRL) &\r\n(~RK3288_STROBE), efuse->base + REG_EFUSE_CTRL);\r\nudelay(1);\r\n}\r\nwritel(RK3288_PGENB | RK3288_CSB, efuse->base + REG_EFUSE_CTRL);\r\nclk_disable_unprepare(efuse->clk);\r\nreturn 0;\r\n}\r\nstatic int rockchip_rk3399_efuse_read(void *context, unsigned int offset,\r\nvoid *val, size_t bytes)\r\n{\r\nstruct rockchip_efuse_chip *efuse = context;\r\nunsigned int addr_start, addr_end, addr_offset, addr_len;\r\nu32 out_value;\r\nu8 *buf;\r\nint ret, i = 0;\r\nret = clk_prepare_enable(efuse->clk);\r\nif (ret < 0) {\r\ndev_err(efuse->dev, "failed to prepare/enable efuse clk\n");\r\nreturn ret;\r\n}\r\naddr_start = rounddown(offset, RK3399_NBYTES) / RK3399_NBYTES;\r\naddr_end = roundup(offset + bytes, RK3399_NBYTES) / RK3399_NBYTES;\r\naddr_offset = offset % RK3399_NBYTES;\r\naddr_len = addr_end - addr_start;\r\nbuf = kzalloc(sizeof(*buf) * addr_len * RK3399_NBYTES, GFP_KERNEL);\r\nif (!buf) {\r\nclk_disable_unprepare(efuse->clk);\r\nreturn -ENOMEM;\r\n}\r\nwritel(RK3399_LOAD | RK3399_PGENB | RK3399_STROBSFTSEL | RK3399_RSB,\r\nefuse->base + REG_EFUSE_CTRL);\r\nudelay(1);\r\nwhile (addr_len--) {\r\nwritel(readl(efuse->base + REG_EFUSE_CTRL) | RK3399_STROBE |\r\n((addr_start++ & RK3399_A_MASK) << RK3399_A_SHIFT),\r\nefuse->base + REG_EFUSE_CTRL);\r\nudelay(1);\r\nout_value = readl(efuse->base + REG_EFUSE_DOUT);\r\nwritel(readl(efuse->base + REG_EFUSE_CTRL) & (~RK3399_STROBE),\r\nefuse->base + REG_EFUSE_CTRL);\r\nudelay(1);\r\nmemcpy(&buf[i], &out_value, RK3399_NBYTES);\r\ni += RK3399_NBYTES;\r\n}\r\nwritel(RK3399_PD | RK3399_CSB, efuse->base + REG_EFUSE_CTRL);\r\nmemcpy(val, buf + addr_offset, bytes);\r\nkfree(buf);\r\nclk_disable_unprepare(efuse->clk);\r\nreturn 0;\r\n}\r\nstatic int rockchip_efuse_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct nvmem_device *nvmem;\r\nstruct rockchip_efuse_chip *efuse;\r\nconst struct of_device_id *match;\r\nstruct device *dev = &pdev->dev;\r\nmatch = of_match_device(dev->driver->of_match_table, dev);\r\nif (!match || !match->data) {\r\ndev_err(dev, "failed to get match data\n");\r\nreturn -EINVAL;\r\n}\r\nefuse = devm_kzalloc(&pdev->dev, sizeof(struct rockchip_efuse_chip),\r\nGFP_KERNEL);\r\nif (!efuse)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nefuse->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(efuse->base))\r\nreturn PTR_ERR(efuse->base);\r\nefuse->clk = devm_clk_get(&pdev->dev, "pclk_efuse");\r\nif (IS_ERR(efuse->clk))\r\nreturn PTR_ERR(efuse->clk);\r\nefuse->dev = &pdev->dev;\r\neconfig.size = resource_size(res);\r\neconfig.reg_read = match->data;\r\neconfig.priv = efuse;\r\neconfig.dev = efuse->dev;\r\nnvmem = nvmem_register(&econfig);\r\nif (IS_ERR(nvmem))\r\nreturn PTR_ERR(nvmem);\r\nplatform_set_drvdata(pdev, nvmem);\r\nreturn 0;\r\n}\r\nstatic int rockchip_efuse_remove(struct platform_device *pdev)\r\n{\r\nstruct nvmem_device *nvmem = platform_get_drvdata(pdev);\r\nreturn nvmem_unregister(nvmem);\r\n}
