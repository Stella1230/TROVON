static int stm32_dwmac_init(struct plat_stmmacenet_data *plat_dat)\r\n{\r\nstruct stm32_dwmac *dwmac = plat_dat->bsp_priv;\r\nu32 reg = dwmac->mode_reg;\r\nu32 val;\r\nint ret;\r\nval = (plat_dat->interface == PHY_INTERFACE_MODE_MII) ? 0 : 1;\r\nret = regmap_update_bits(dwmac->regmap, reg, MII_PHY_SEL_MASK, val);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(dwmac->clk_tx);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(dwmac->clk_rx);\r\nif (ret)\r\nclk_disable_unprepare(dwmac->clk_tx);\r\nreturn ret;\r\n}\r\nstatic void stm32_dwmac_clk_disable(struct stm32_dwmac *dwmac)\r\n{\r\nclk_disable_unprepare(dwmac->clk_tx);\r\nclk_disable_unprepare(dwmac->clk_rx);\r\n}\r\nstatic int stm32_dwmac_parse_data(struct stm32_dwmac *dwmac,\r\nstruct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nint err;\r\ndwmac->clk_tx = devm_clk_get(dev, "mac-clk-tx");\r\nif (IS_ERR(dwmac->clk_tx)) {\r\ndev_err(dev, "No tx clock provided...\n");\r\nreturn PTR_ERR(dwmac->clk_tx);\r\n}\r\ndwmac->clk_rx = devm_clk_get(dev, "mac-clk-rx");\r\nif (IS_ERR(dwmac->clk_rx)) {\r\ndev_err(dev, "No rx clock provided...\n");\r\nreturn PTR_ERR(dwmac->clk_rx);\r\n}\r\ndwmac->regmap = syscon_regmap_lookup_by_phandle(np, "st,syscon");\r\nif (IS_ERR(dwmac->regmap))\r\nreturn PTR_ERR(dwmac->regmap);\r\nerr = of_property_read_u32_index(np, "st,syscon", 1, &dwmac->mode_reg);\r\nif (err)\r\ndev_err(dev, "Can't get sysconfig mode offset (%d)\n", err);\r\nreturn err;\r\n}\r\nstatic int stm32_dwmac_probe(struct platform_device *pdev)\r\n{\r\nstruct plat_stmmacenet_data *plat_dat;\r\nstruct stmmac_resources stmmac_res;\r\nstruct stm32_dwmac *dwmac;\r\nint ret;\r\nret = stmmac_get_platform_resources(pdev, &stmmac_res);\r\nif (ret)\r\nreturn ret;\r\nplat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);\r\nif (IS_ERR(plat_dat))\r\nreturn PTR_ERR(plat_dat);\r\ndwmac = devm_kzalloc(&pdev->dev, sizeof(*dwmac), GFP_KERNEL);\r\nif (!dwmac) {\r\nret = -ENOMEM;\r\ngoto err_remove_config_dt;\r\n}\r\nret = stm32_dwmac_parse_data(dwmac, &pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to parse OF data\n");\r\ngoto err_remove_config_dt;\r\n}\r\nplat_dat->bsp_priv = dwmac;\r\nret = stm32_dwmac_init(plat_dat);\r\nif (ret)\r\ngoto err_remove_config_dt;\r\nret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\r\nif (ret)\r\ngoto err_clk_disable;\r\nreturn 0;\r\nerr_clk_disable:\r\nstm32_dwmac_clk_disable(dwmac);\r\nerr_remove_config_dt:\r\nstmmac_remove_config_dt(pdev, plat_dat);\r\nreturn ret;\r\n}\r\nstatic int stm32_dwmac_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nint ret = stmmac_dvr_remove(&pdev->dev);\r\nstm32_dwmac_clk_disable(priv->plat->bsp_priv);\r\nreturn ret;\r\n}\r\nstatic int stm32_dwmac_suspend(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nint ret;\r\nret = stmmac_suspend(dev);\r\nstm32_dwmac_clk_disable(priv->plat->bsp_priv);\r\nreturn ret;\r\n}\r\nstatic int stm32_dwmac_resume(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nint ret;\r\nret = stm32_dwmac_init(priv->plat);\r\nif (ret)\r\nreturn ret;\r\nret = stmmac_resume(dev);\r\nreturn ret;\r\n}
