static bool nf_dup_ipv6_route(struct net *net, struct sk_buff *skb,\r\nconst struct in6_addr *gw, int oif)\r\n{\r\nconst struct ipv6hdr *iph = ipv6_hdr(skb);\r\nstruct dst_entry *dst;\r\nstruct flowi6 fl6;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nif (oif != -1)\r\nfl6.flowi6_oif = oif;\r\nfl6.daddr = *gw;\r\nfl6.flowlabel = (__force __be32)(((iph->flow_lbl[0] & 0xF) << 16) |\r\n(iph->flow_lbl[1] << 8) | iph->flow_lbl[2]);\r\nfl6.flowi6_flags = FLOWI_FLAG_KNOWN_NH;\r\ndst = ip6_route_output(net, NULL, &fl6);\r\nif (dst->error) {\r\ndst_release(dst);\r\nreturn false;\r\n}\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, dst);\r\nskb->dev = dst->dev;\r\nskb->protocol = htons(ETH_P_IPV6);\r\nreturn true;\r\n}\r\nvoid nf_dup_ipv6(struct net *net, struct sk_buff *skb, unsigned int hooknum,\r\nconst struct in6_addr *gw, int oif)\r\n{\r\nif (this_cpu_read(nf_skb_duplicated))\r\nreturn;\r\nskb = pskb_copy(skb, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn;\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\r\nnf_reset(skb);\r\nnf_ct_set(skb, NULL, IP_CT_UNTRACKED);\r\n#endif\r\nif (hooknum == NF_INET_PRE_ROUTING ||\r\nhooknum == NF_INET_LOCAL_IN) {\r\nstruct ipv6hdr *iph = ipv6_hdr(skb);\r\n--iph->hop_limit;\r\n}\r\nif (nf_dup_ipv6_route(net, skb, gw, oif)) {\r\n__this_cpu_write(nf_skb_duplicated, true);\r\nip6_local_out(net, skb->sk, skb);\r\n__this_cpu_write(nf_skb_duplicated, false);\r\n} else {\r\nkfree_skb(skb);\r\n}\r\n}
