static uint64_t uvd_v4_2_ring_get_rptr(struct amdgpu_ring *ring)\r\n{\r\nstruct amdgpu_device *adev = ring->adev;\r\nreturn RREG32(mmUVD_RBC_RB_RPTR);\r\n}\r\nstatic uint64_t uvd_v4_2_ring_get_wptr(struct amdgpu_ring *ring)\r\n{\r\nstruct amdgpu_device *adev = ring->adev;\r\nreturn RREG32(mmUVD_RBC_RB_WPTR);\r\n}\r\nstatic void uvd_v4_2_ring_set_wptr(struct amdgpu_ring *ring)\r\n{\r\nstruct amdgpu_device *adev = ring->adev;\r\nWREG32(mmUVD_RBC_RB_WPTR, lower_32_bits(ring->wptr));\r\n}\r\nstatic int uvd_v4_2_early_init(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nuvd_v4_2_set_ring_funcs(adev);\r\nuvd_v4_2_set_irq_funcs(adev);\r\nreturn 0;\r\n}\r\nstatic int uvd_v4_2_sw_init(void *handle)\r\n{\r\nstruct amdgpu_ring *ring;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nint r;\r\nr = amdgpu_irq_add_id(adev, AMDGPU_IH_CLIENTID_LEGACY, 124, &adev->uvd.irq);\r\nif (r)\r\nreturn r;\r\nr = amdgpu_uvd_sw_init(adev);\r\nif (r)\r\nreturn r;\r\nr = amdgpu_uvd_resume(adev);\r\nif (r)\r\nreturn r;\r\nring = &adev->uvd.ring;\r\nsprintf(ring->name, "uvd");\r\nr = amdgpu_ring_init(adev, ring, 512, &adev->uvd.irq, 0);\r\nreturn r;\r\n}\r\nstatic int uvd_v4_2_sw_fini(void *handle)\r\n{\r\nint r;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nr = amdgpu_uvd_suspend(adev);\r\nif (r)\r\nreturn r;\r\nreturn amdgpu_uvd_sw_fini(adev);\r\n}\r\nstatic int uvd_v4_2_hw_init(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nstruct amdgpu_ring *ring = &adev->uvd.ring;\r\nuint32_t tmp;\r\nint r;\r\nuvd_v4_2_enable_mgcg(adev, true);\r\namdgpu_asic_set_uvd_clocks(adev, 10000, 10000);\r\nring->ready = true;\r\nr = amdgpu_ring_test_ring(ring);\r\nif (r) {\r\nring->ready = false;\r\ngoto done;\r\n}\r\nr = amdgpu_ring_alloc(ring, 10);\r\nif (r) {\r\nDRM_ERROR("amdgpu: ring failed to lock UVD ring (%d).\n", r);\r\ngoto done;\r\n}\r\ntmp = PACKET0(mmUVD_SEMA_WAIT_FAULT_TIMEOUT_CNTL, 0);\r\namdgpu_ring_write(ring, tmp);\r\namdgpu_ring_write(ring, 0xFFFFF);\r\ntmp = PACKET0(mmUVD_SEMA_WAIT_INCOMPLETE_TIMEOUT_CNTL, 0);\r\namdgpu_ring_write(ring, tmp);\r\namdgpu_ring_write(ring, 0xFFFFF);\r\ntmp = PACKET0(mmUVD_SEMA_SIGNAL_INCOMPLETE_TIMEOUT_CNTL, 0);\r\namdgpu_ring_write(ring, tmp);\r\namdgpu_ring_write(ring, 0xFFFFF);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_SEMA_TIMEOUT_STATUS, 0));\r\namdgpu_ring_write(ring, 0x8);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_SEMA_CNTL, 0));\r\namdgpu_ring_write(ring, 3);\r\namdgpu_ring_commit(ring);\r\ndone:\r\nif (!r)\r\nDRM_INFO("UVD initialized successfully.\n");\r\nreturn r;\r\n}\r\nstatic int uvd_v4_2_hw_fini(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nstruct amdgpu_ring *ring = &adev->uvd.ring;\r\nif (RREG32(mmUVD_STATUS) != 0)\r\nuvd_v4_2_stop(adev);\r\nring->ready = false;\r\nreturn 0;\r\n}\r\nstatic int uvd_v4_2_suspend(void *handle)\r\n{\r\nint r;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nr = uvd_v4_2_hw_fini(adev);\r\nif (r)\r\nreturn r;\r\nreturn amdgpu_uvd_suspend(adev);\r\n}\r\nstatic int uvd_v4_2_resume(void *handle)\r\n{\r\nint r;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nr = amdgpu_uvd_resume(adev);\r\nif (r)\r\nreturn r;\r\nreturn uvd_v4_2_hw_init(adev);\r\n}\r\nstatic int uvd_v4_2_start(struct amdgpu_device *adev)\r\n{\r\nstruct amdgpu_ring *ring = &adev->uvd.ring;\r\nuint32_t rb_bufsz;\r\nint i, j, r;\r\nu32 tmp;\r\nu32 lmi_swap_cntl = 0;\r\nu32 mp_swap_cntl = 0;\r\nWREG32_P(mmUVD_STATUS, 1<<2, ~(1<<2));\r\nuvd_v4_2_set_dcm(adev, true);\r\nWREG32(mmUVD_CGC_GATE, 0);\r\nWREG32_P(mmSRBM_SOFT_RESET, 0, ~SRBM_SOFT_RESET__SOFT_RESET_UVD_MASK);\r\nmdelay(5);\r\nWREG32(mmUVD_VCPU_CNTL, 1 << 9);\r\nWREG32_P(mmUVD_MASTINT_EN, 0, ~(1 << 1));\r\n#ifdef __BIG_ENDIAN\r\nlmi_swap_cntl = 0xa;\r\nmp_swap_cntl = 0;\r\n#endif\r\nWREG32(mmUVD_LMI_SWAP_CNTL, lmi_swap_cntl);\r\nWREG32(mmUVD_MP_SWAP_CNTL, mp_swap_cntl);\r\nWREG32(mmUVD_LMI_CTRL, 0x203108);\r\ntmp = RREG32(mmUVD_MPC_CNTL);\r\nWREG32(mmUVD_MPC_CNTL, tmp | 0x10);\r\nWREG32(mmUVD_MPC_SET_MUXA0, 0x40c2040);\r\nWREG32(mmUVD_MPC_SET_MUXA1, 0x0);\r\nWREG32(mmUVD_MPC_SET_MUXB0, 0x40c2040);\r\nWREG32(mmUVD_MPC_SET_MUXB1, 0x0);\r\nWREG32(mmUVD_MPC_SET_ALU, 0);\r\nWREG32(mmUVD_MPC_SET_MUX, 0x88);\r\nuvd_v4_2_mc_resume(adev);\r\ntmp = RREG32_UVD_CTX(ixUVD_LMI_CACHE_CTRL);\r\nWREG32_UVD_CTX(ixUVD_LMI_CACHE_CTRL, tmp & (~0x10));\r\nWREG32_P(mmUVD_LMI_CTRL2, 0, ~(1 << 8));\r\nWREG32_P(mmUVD_SOFT_RESET, 0, ~UVD_SOFT_RESET__LMI_SOFT_RESET_MASK);\r\nWREG32_P(mmUVD_SOFT_RESET, 0, ~UVD_SOFT_RESET__LMI_UMC_SOFT_RESET_MASK);\r\nWREG32_P(mmUVD_SOFT_RESET, 0, ~UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\r\nmdelay(10);\r\nfor (i = 0; i < 10; ++i) {\r\nuint32_t status;\r\nfor (j = 0; j < 100; ++j) {\r\nstatus = RREG32(mmUVD_STATUS);\r\nif (status & 2)\r\nbreak;\r\nmdelay(10);\r\n}\r\nr = 0;\r\nif (status & 2)\r\nbreak;\r\nDRM_ERROR("UVD not responding, trying to reset the VCPU!!!\n");\r\nWREG32_P(mmUVD_SOFT_RESET, UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK,\r\n~UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\r\nmdelay(10);\r\nWREG32_P(mmUVD_SOFT_RESET, 0, ~UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\r\nmdelay(10);\r\nr = -1;\r\n}\r\nif (r) {\r\nDRM_ERROR("UVD not responding, giving up!!!\n");\r\nreturn r;\r\n}\r\nWREG32_P(mmUVD_MASTINT_EN, 3<<1, ~(3 << 1));\r\nWREG32_P(mmUVD_STATUS, 0, ~(1<<2));\r\nWREG32(mmUVD_RBC_RB_CNTL, 0x11010101);\r\nWREG32(mmUVD_RBC_RB_WPTR_CNTL, 0);\r\nWREG32(mmUVD_LMI_EXT40_ADDR, upper_32_bits(ring->gpu_addr) |\r\n(0x7 << 16) | (0x1 << 31));\r\nWREG32(mmUVD_RBC_RB_RPTR, 0x0);\r\nring->wptr = RREG32(mmUVD_RBC_RB_RPTR);\r\nWREG32(mmUVD_RBC_RB_WPTR, lower_32_bits(ring->wptr));\r\nWREG32(mmUVD_RBC_RB_BASE, ring->gpu_addr);\r\nrb_bufsz = order_base_2(ring->ring_size);\r\nrb_bufsz = (0x1 << 8) | rb_bufsz;\r\nWREG32_P(mmUVD_RBC_RB_CNTL, rb_bufsz, ~0x11f1f);\r\nreturn 0;\r\n}\r\nstatic void uvd_v4_2_stop(struct amdgpu_device *adev)\r\n{\r\nuint32_t i, j;\r\nuint32_t status;\r\nWREG32(mmUVD_RBC_RB_CNTL, 0x11010101);\r\nfor (i = 0; i < 10; ++i) {\r\nfor (j = 0; j < 100; ++j) {\r\nstatus = RREG32(mmUVD_STATUS);\r\nif (status & 2)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (status & 2)\r\nbreak;\r\n}\r\nfor (i = 0; i < 10; ++i) {\r\nfor (j = 0; j < 100; ++j) {\r\nstatus = RREG32(mmUVD_LMI_STATUS);\r\nif (status & 0xf)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (status & 0xf)\r\nbreak;\r\n}\r\nWREG32_P(mmUVD_LMI_CTRL2, 1 << 8, ~(1 << 8));\r\nfor (i = 0; i < 10; ++i) {\r\nfor (j = 0; j < 100; ++j) {\r\nstatus = RREG32(mmUVD_LMI_STATUS);\r\nif (status & 0x240)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (status & 0x240)\r\nbreak;\r\n}\r\nWREG32_P(0x3D49, 0, ~(1 << 2));\r\nWREG32_P(mmUVD_VCPU_CNTL, 0, ~(1 << 9));\r\nWREG32(mmUVD_SOFT_RESET, UVD_SOFT_RESET__LMI_SOFT_RESET_MASK |\r\nUVD_SOFT_RESET__VCPU_SOFT_RESET_MASK |\r\nUVD_SOFT_RESET__LMI_UMC_SOFT_RESET_MASK);\r\nWREG32(mmUVD_STATUS, 0);\r\nuvd_v4_2_set_dcm(adev, false);\r\n}\r\nstatic void uvd_v4_2_ring_emit_fence(struct amdgpu_ring *ring, u64 addr, u64 seq,\r\nunsigned flags)\r\n{\r\nWARN_ON(flags & AMDGPU_FENCE_FLAG_64BIT);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_CONTEXT_ID, 0));\r\namdgpu_ring_write(ring, seq);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA0, 0));\r\namdgpu_ring_write(ring, addr & 0xffffffff);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA1, 0));\r\namdgpu_ring_write(ring, upper_32_bits(addr) & 0xff);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_CMD, 0));\r\namdgpu_ring_write(ring, 0);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA0, 0));\r\namdgpu_ring_write(ring, 0);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA1, 0));\r\namdgpu_ring_write(ring, 0);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_CMD, 0));\r\namdgpu_ring_write(ring, 2);\r\n}\r\nstatic void uvd_v4_2_ring_emit_hdp_flush(struct amdgpu_ring *ring)\r\n{\r\namdgpu_ring_write(ring, PACKET0(mmHDP_MEM_COHERENCY_FLUSH_CNTL, 0));\r\namdgpu_ring_write(ring, 0);\r\n}\r\nstatic void uvd_v4_2_ring_emit_hdp_invalidate(struct amdgpu_ring *ring)\r\n{\r\namdgpu_ring_write(ring, PACKET0(mmHDP_DEBUG0, 0));\r\namdgpu_ring_write(ring, 1);\r\n}\r\nstatic int uvd_v4_2_ring_test_ring(struct amdgpu_ring *ring)\r\n{\r\nstruct amdgpu_device *adev = ring->adev;\r\nuint32_t tmp = 0;\r\nunsigned i;\r\nint r;\r\nWREG32(mmUVD_CONTEXT_ID, 0xCAFEDEAD);\r\nr = amdgpu_ring_alloc(ring, 3);\r\nif (r) {\r\nDRM_ERROR("amdgpu: cp failed to lock ring %d (%d).\n",\r\nring->idx, r);\r\nreturn r;\r\n}\r\namdgpu_ring_write(ring, PACKET0(mmUVD_CONTEXT_ID, 0));\r\namdgpu_ring_write(ring, 0xDEADBEEF);\r\namdgpu_ring_commit(ring);\r\nfor (i = 0; i < adev->usec_timeout; i++) {\r\ntmp = RREG32(mmUVD_CONTEXT_ID);\r\nif (tmp == 0xDEADBEEF)\r\nbreak;\r\nDRM_UDELAY(1);\r\n}\r\nif (i < adev->usec_timeout) {\r\nDRM_INFO("ring test on %d succeeded in %d usecs\n",\r\nring->idx, i);\r\n} else {\r\nDRM_ERROR("amdgpu: ring %d test failed (0x%08X)\n",\r\nring->idx, tmp);\r\nr = -EINVAL;\r\n}\r\nreturn r;\r\n}\r\nstatic void uvd_v4_2_ring_emit_ib(struct amdgpu_ring *ring,\r\nstruct amdgpu_ib *ib,\r\nunsigned vm_id, bool ctx_switch)\r\n{\r\namdgpu_ring_write(ring, PACKET0(mmUVD_RBC_IB_BASE, 0));\r\namdgpu_ring_write(ring, ib->gpu_addr);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_RBC_IB_SIZE, 0));\r\namdgpu_ring_write(ring, ib->length_dw);\r\n}\r\nstatic void uvd_v4_2_mc_resume(struct amdgpu_device *adev)\r\n{\r\nuint64_t addr;\r\nuint32_t size;\r\naddr = (adev->uvd.gpu_addr + AMDGPU_UVD_FIRMWARE_OFFSET) >> 3;\r\nsize = AMDGPU_GPU_PAGE_ALIGN(adev->uvd.fw->size + 4) >> 3;\r\nWREG32(mmUVD_VCPU_CACHE_OFFSET0, addr);\r\nWREG32(mmUVD_VCPU_CACHE_SIZE0, size);\r\naddr += size;\r\nsize = AMDGPU_UVD_HEAP_SIZE >> 3;\r\nWREG32(mmUVD_VCPU_CACHE_OFFSET1, addr);\r\nWREG32(mmUVD_VCPU_CACHE_SIZE1, size);\r\naddr += size;\r\nsize = (AMDGPU_UVD_STACK_SIZE +\r\n(AMDGPU_UVD_SESSION_SIZE * adev->uvd.max_handles)) >> 3;\r\nWREG32(mmUVD_VCPU_CACHE_OFFSET2, addr);\r\nWREG32(mmUVD_VCPU_CACHE_SIZE2, size);\r\naddr = (adev->uvd.gpu_addr >> 28) & 0xF;\r\nWREG32(mmUVD_LMI_ADDR_EXT, (addr << 12) | (addr << 0));\r\naddr = (adev->uvd.gpu_addr >> 32) & 0xFF;\r\nWREG32(mmUVD_LMI_EXT40_ADDR, addr | (0x9 << 16) | (0x1 << 31));\r\nWREG32(mmUVD_UDEC_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\r\nWREG32(mmUVD_UDEC_DB_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\r\nWREG32(mmUVD_UDEC_DBW_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\r\n}\r\nstatic void uvd_v4_2_enable_mgcg(struct amdgpu_device *adev,\r\nbool enable)\r\n{\r\nu32 orig, data;\r\nif (enable && (adev->cg_flags & AMD_CG_SUPPORT_UVD_MGCG)) {\r\ndata = RREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL);\r\ndata |= 0xfff;\r\nWREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL, data);\r\norig = data = RREG32(mmUVD_CGC_CTRL);\r\ndata |= UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK;\r\nif (orig != data)\r\nWREG32(mmUVD_CGC_CTRL, data);\r\n} else {\r\ndata = RREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL);\r\ndata &= ~0xfff;\r\nWREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL, data);\r\norig = data = RREG32(mmUVD_CGC_CTRL);\r\ndata &= ~UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK;\r\nif (orig != data)\r\nWREG32(mmUVD_CGC_CTRL, data);\r\n}\r\n}\r\nstatic void uvd_v4_2_set_dcm(struct amdgpu_device *adev,\r\nbool sw_mode)\r\n{\r\nu32 tmp, tmp2;\r\nWREG32_FIELD(UVD_CGC_GATE, REGS, 0);\r\ntmp = RREG32(mmUVD_CGC_CTRL);\r\ntmp &= ~(UVD_CGC_CTRL__CLK_OFF_DELAY_MASK | UVD_CGC_CTRL__CLK_GATE_DLY_TIMER_MASK);\r\ntmp |= UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK |\r\n(1 << UVD_CGC_CTRL__CLK_GATE_DLY_TIMER__SHIFT) |\r\n(4 << UVD_CGC_CTRL__CLK_OFF_DELAY__SHIFT);\r\nif (sw_mode) {\r\ntmp &= ~0x7ffff800;\r\ntmp2 = UVD_CGC_CTRL2__DYN_OCLK_RAMP_EN_MASK |\r\nUVD_CGC_CTRL2__DYN_RCLK_RAMP_EN_MASK |\r\n(7 << UVD_CGC_CTRL2__GATER_DIV_ID__SHIFT);\r\n} else {\r\ntmp |= 0x7ffff800;\r\ntmp2 = 0;\r\n}\r\nWREG32(mmUVD_CGC_CTRL, tmp);\r\nWREG32_UVD_CTX(ixUVD_CGC_CTRL2, tmp2);\r\n}\r\nstatic bool uvd_v4_2_is_idle(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nreturn !(RREG32(mmSRBM_STATUS) & SRBM_STATUS__UVD_BUSY_MASK);\r\n}\r\nstatic int uvd_v4_2_wait_for_idle(void *handle)\r\n{\r\nunsigned i;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nfor (i = 0; i < adev->usec_timeout; i++) {\r\nif (!(RREG32(mmSRBM_STATUS) & SRBM_STATUS__UVD_BUSY_MASK))\r\nreturn 0;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int uvd_v4_2_soft_reset(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nuvd_v4_2_stop(adev);\r\nWREG32_P(mmSRBM_SOFT_RESET, SRBM_SOFT_RESET__SOFT_RESET_UVD_MASK,\r\n~SRBM_SOFT_RESET__SOFT_RESET_UVD_MASK);\r\nmdelay(5);\r\nreturn uvd_v4_2_start(adev);\r\n}\r\nstatic int uvd_v4_2_set_interrupt_state(struct amdgpu_device *adev,\r\nstruct amdgpu_irq_src *source,\r\nunsigned type,\r\nenum amdgpu_interrupt_state state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int uvd_v4_2_process_interrupt(struct amdgpu_device *adev,\r\nstruct amdgpu_irq_src *source,\r\nstruct amdgpu_iv_entry *entry)\r\n{\r\nDRM_DEBUG("IH: UVD TRAP\n");\r\namdgpu_fence_process(&adev->uvd.ring);\r\nreturn 0;\r\n}\r\nstatic int uvd_v4_2_set_clockgating_state(void *handle,\r\nenum amd_clockgating_state state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int uvd_v4_2_set_powergating_state(void *handle,\r\nenum amd_powergating_state state)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nif (state == AMD_PG_STATE_GATE) {\r\nuvd_v4_2_stop(adev);\r\nif (adev->pg_flags & AMD_PG_SUPPORT_UVD && amdgpu_dpm == 0) {\r\nif (!(RREG32_SMC(ixCURRENT_PG_STATUS) &\r\nCURRENT_PG_STATUS__UVD_PG_STATUS_MASK)) {\r\nWREG32(mmUVD_PGFSM_CONFIG, (UVD_PGFSM_CONFIG__UVD_PGFSM_FSM_ADDR_MASK |\r\nUVD_PGFSM_CONFIG__UVD_PGFSM_POWER_DOWN_MASK |\r\nUVD_PGFSM_CONFIG__UVD_PGFSM_P1_SELECT_MASK));\r\nmdelay(20);\r\n}\r\n}\r\nreturn 0;\r\n} else {\r\nif (adev->pg_flags & AMD_PG_SUPPORT_UVD && amdgpu_dpm == 0) {\r\nif (RREG32_SMC(ixCURRENT_PG_STATUS) &\r\nCURRENT_PG_STATUS__UVD_PG_STATUS_MASK) {\r\nWREG32(mmUVD_PGFSM_CONFIG, (UVD_PGFSM_CONFIG__UVD_PGFSM_FSM_ADDR_MASK |\r\nUVD_PGFSM_CONFIG__UVD_PGFSM_POWER_UP_MASK |\r\nUVD_PGFSM_CONFIG__UVD_PGFSM_P1_SELECT_MASK));\r\nmdelay(30);\r\n}\r\n}\r\nreturn uvd_v4_2_start(adev);\r\n}\r\n}\r\nstatic void uvd_v4_2_set_ring_funcs(struct amdgpu_device *adev)\r\n{\r\nadev->uvd.ring.funcs = &uvd_v4_2_ring_funcs;\r\n}\r\nstatic void uvd_v4_2_set_irq_funcs(struct amdgpu_device *adev)\r\n{\r\nadev->uvd.irq.num_types = 1;\r\nadev->uvd.irq.funcs = &uvd_v4_2_irq_funcs;\r\n}
