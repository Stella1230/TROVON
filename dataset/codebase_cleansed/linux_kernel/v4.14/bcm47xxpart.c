static void bcm47xxpart_add_part(struct mtd_partition *part, const char *name,\r\nu64 offset, uint32_t mask_flags)\r\n{\r\npart->name = name;\r\npart->offset = offset;\r\npart->mask_flags = mask_flags;\r\n}\r\nstatic int bcm47xxpart_bootpartition(void)\r\n{\r\nchar buf[4];\r\nint bootpartition;\r\nif (bcm47xx_nvram_getenv("bootpartition", buf, sizeof(buf)) > 0) {\r\nif (!kstrtoint(buf, 0, &bootpartition))\r\nreturn bootpartition;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm47xxpart_parse(struct mtd_info *master,\r\nconst struct mtd_partition **pparts,\r\nstruct mtd_part_parser_data *data)\r\n{\r\nstruct mtd_partition *parts;\r\nuint8_t i, curr_part = 0;\r\nuint32_t *buf;\r\nsize_t bytes_read;\r\nuint32_t offset;\r\nuint32_t blocksize = master->erasesize;\r\nint trx_parts[2];\r\nint trx_num = 0;\r\nint possible_nvram_sizes[] = { 0x8000, 0xF000, 0x10000, };\r\nint err;\r\nif (blocksize < 0x1000)\r\nblocksize = 0x1000;\r\nparts = kzalloc(sizeof(struct mtd_partition) * BCM47XXPART_MAX_PARTS,\r\nGFP_KERNEL);\r\nif (!parts)\r\nreturn -ENOMEM;\r\nbuf = kzalloc(BCM47XXPART_BYTES_TO_READ, GFP_KERNEL);\r\nif (!buf) {\r\nkfree(parts);\r\nreturn -ENOMEM;\r\n}\r\nfor (offset = 0; offset <= master->size - blocksize;\r\noffset += blocksize) {\r\nif (IS_ENABLED(CONFIG_BCM47XX) && offset >= 0x2000000)\r\nbreak;\r\nif (curr_part >= BCM47XXPART_MAX_PARTS) {\r\npr_warn("Reached maximum number of partitions, scanning stopped!\n");\r\nbreak;\r\n}\r\nerr = mtd_read(master, offset, BCM47XXPART_BYTES_TO_READ,\r\n&bytes_read, (uint8_t *)buf);\r\nif (err && !mtd_is_bitflip(err)) {\r\npr_err("mtd_read error while parsing (offset: 0x%X): %d\n",\r\noffset, err);\r\ncontinue;\r\n}\r\nif ((buf[0x4e0 / 4] == CFE_MAGIC && buf[0x4e4 / 4] == CFE_MAGIC) ||\r\n(buf[0x400 / 4] == NVRAM_HEADER)) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "boot",\r\noffset, MTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x100 / 4] == BOARD_DATA_MAGIC) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "board_data",\r\noffset, MTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == FACTORY_MAGIC) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "factory",\r\noffset, MTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == POT_MAGIC1 &&\r\n(buf[0x004 / 4] & 0xFFFF) == POT_MAGIC2) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "POT", offset,\r\nMTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x010 / 4] == ML_MAGIC1 &&\r\nbuf[0x014 / 4] == ML_MAGIC2) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "ML", offset,\r\nMTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == TRX_MAGIC) {\r\nstruct trx_header *trx;\r\nif (trx_num >= ARRAY_SIZE(trx_parts))\r\npr_warn("No enough space to store another TRX found at 0x%X\n",\r\noffset);\r\nelse\r\ntrx_parts[trx_num++] = curr_part;\r\nbcm47xxpart_add_part(&parts[curr_part++], "firmware",\r\noffset, 0);\r\ntrx = (struct trx_header *)buf;\r\noffset = roundup(offset + trx->length, blocksize);\r\noffset -= blocksize;\r\ncontinue;\r\n}\r\nif (le32_to_cpu(buf[0x000 / 4]) == SQUASHFS_MAGIC ||\r\nbuf[0x000 / 4] == SHSQ_MAGIC) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "rootfs",\r\noffset, 0);\r\ncontinue;\r\n}\r\nif (offset != master->size - blocksize &&\r\nbuf[0x000 / 4] == NVRAM_HEADER) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "nvram",\r\noffset, 0);\r\ncontinue;\r\n}\r\nerr = mtd_read(master, offset + 0x8000, 0x4, &bytes_read,\r\n(uint8_t *)buf);\r\nif (err && !mtd_is_bitflip(err)) {\r\npr_err("mtd_read error while parsing (offset: 0x%X): %d\n",\r\noffset, err);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == BOARD_DATA_MAGIC2) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "board_data",\r\noffset, MTD_WRITEABLE);\r\ncontinue;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(possible_nvram_sizes); i++) {\r\nif (curr_part >= BCM47XXPART_MAX_PARTS) {\r\npr_warn("Reached maximum number of partitions, scanning stopped!\n");\r\nbreak;\r\n}\r\noffset = master->size - possible_nvram_sizes[i];\r\nerr = mtd_read(master, offset, 0x4, &bytes_read,\r\n(uint8_t *)buf);\r\nif (err && !mtd_is_bitflip(err)) {\r\npr_err("mtd_read error while reading (offset 0x%X): %d\n",\r\noffset, err);\r\ncontinue;\r\n}\r\nif (buf[0] == NVRAM_HEADER) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "nvram",\r\nmaster->size - blocksize, 0);\r\nbreak;\r\n}\r\n}\r\nkfree(buf);\r\nfor (i = 0; i < curr_part; i++) {\r\nu64 next_part_offset = (i < curr_part - 1) ?\r\nparts[i + 1].offset : master->size;\r\nparts[i].size = next_part_offset - parts[i].offset;\r\n}\r\nfor (i = 0; i < trx_num; i++) {\r\nstruct mtd_partition *trx = &parts[trx_parts[i]];\r\nif (i == bcm47xxpart_bootpartition())\r\ntrx->types = trx_types;\r\nelse\r\ntrx->name = "failsafe";\r\n}\r\n*pparts = parts;\r\nreturn curr_part;\r\n}
