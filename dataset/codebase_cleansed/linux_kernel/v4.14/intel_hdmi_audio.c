static struct snd_pcm_substream *\r\nhad_substream_get(struct snd_intelhad *intelhaddata)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nunsigned long flags;\r\nspin_lock_irqsave(&intelhaddata->had_spinlock, flags);\r\nsubstream = intelhaddata->stream_info.substream;\r\nif (substream)\r\nintelhaddata->stream_info.substream_refcount++;\r\nspin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);\r\nreturn substream;\r\n}\r\nstatic void had_substream_put(struct snd_intelhad *intelhaddata)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&intelhaddata->had_spinlock, flags);\r\nintelhaddata->stream_info.substream_refcount--;\r\nspin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);\r\n}\r\nstatic u32 had_config_offset(int pipe)\r\n{\r\nswitch (pipe) {\r\ndefault:\r\ncase 0:\r\nreturn AUDIO_HDMI_CONFIG_A;\r\ncase 1:\r\nreturn AUDIO_HDMI_CONFIG_B;\r\ncase 2:\r\nreturn AUDIO_HDMI_CONFIG_C;\r\n}\r\n}\r\nstatic u32 had_read_register_raw(struct snd_intelhad_card *card_ctx,\r\nint pipe, u32 reg)\r\n{\r\nreturn ioread32(card_ctx->mmio_start + had_config_offset(pipe) + reg);\r\n}\r\nstatic void had_write_register_raw(struct snd_intelhad_card *card_ctx,\r\nint pipe, u32 reg, u32 val)\r\n{\r\niowrite32(val, card_ctx->mmio_start + had_config_offset(pipe) + reg);\r\n}\r\nstatic void had_read_register(struct snd_intelhad *ctx, u32 reg, u32 *val)\r\n{\r\nif (!ctx->connected)\r\n*val = 0;\r\nelse\r\n*val = had_read_register_raw(ctx->card_ctx, ctx->pipe, reg);\r\n}\r\nstatic void had_write_register(struct snd_intelhad *ctx, u32 reg, u32 val)\r\n{\r\nif (ctx->connected)\r\nhad_write_register_raw(ctx->card_ctx, ctx->pipe, reg, val);\r\n}\r\nstatic void had_enable_audio(struct snd_intelhad *intelhaddata,\r\nbool enable)\r\n{\r\nintelhaddata->aud_config.regx.aud_en = enable;\r\nhad_write_register(intelhaddata, AUD_CONFIG,\r\nintelhaddata->aud_config.regval);\r\n}\r\nstatic void had_ack_irqs(struct snd_intelhad *ctx)\r\n{\r\nu32 status_reg;\r\nif (!ctx->connected)\r\nreturn;\r\nhad_read_register(ctx, AUD_HDMI_STATUS, &status_reg);\r\nstatus_reg |= HDMI_AUDIO_BUFFER_DONE | HDMI_AUDIO_UNDERRUN;\r\nhad_write_register(ctx, AUD_HDMI_STATUS, status_reg);\r\nhad_read_register(ctx, AUD_HDMI_STATUS, &status_reg);\r\n}\r\nstatic void had_reset_audio(struct snd_intelhad *intelhaddata)\r\n{\r\nhad_write_register(intelhaddata, AUD_HDMI_STATUS,\r\nAUD_HDMI_STATUSG_MASK_FUNCRST);\r\nhad_write_register(intelhaddata, AUD_HDMI_STATUS, 0);\r\n}\r\nstatic int had_prog_status_reg(struct snd_pcm_substream *substream,\r\nstruct snd_intelhad *intelhaddata)\r\n{\r\nunion aud_cfg cfg_val = {.regval = 0};\r\nunion aud_ch_status_0 ch_stat0 = {.regval = 0};\r\nunion aud_ch_status_1 ch_stat1 = {.regval = 0};\r\nch_stat0.regx.lpcm_id = (intelhaddata->aes_bits &\r\nIEC958_AES0_NONAUDIO) >> 1;\r\nch_stat0.regx.clk_acc = (intelhaddata->aes_bits &\r\nIEC958_AES3_CON_CLOCK) >> 4;\r\ncfg_val.regx.val_bit = ch_stat0.regx.lpcm_id;\r\nswitch (substream->runtime->rate) {\r\ncase AUD_SAMPLE_RATE_32:\r\nch_stat0.regx.samp_freq = CH_STATUS_MAP_32KHZ;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_44_1:\r\nch_stat0.regx.samp_freq = CH_STATUS_MAP_44KHZ;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_48:\r\nch_stat0.regx.samp_freq = CH_STATUS_MAP_48KHZ;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_88_2:\r\nch_stat0.regx.samp_freq = CH_STATUS_MAP_88KHZ;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_96:\r\nch_stat0.regx.samp_freq = CH_STATUS_MAP_96KHZ;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_176_4:\r\nch_stat0.regx.samp_freq = CH_STATUS_MAP_176KHZ;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_192:\r\nch_stat0.regx.samp_freq = CH_STATUS_MAP_192KHZ;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nhad_write_register(intelhaddata,\r\nAUD_CH_STATUS_0, ch_stat0.regval);\r\nswitch (substream->runtime->format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nch_stat1.regx.max_wrd_len = MAX_SMPL_WIDTH_20;\r\nch_stat1.regx.wrd_len = SMPL_WIDTH_16BITS;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nch_stat1.regx.max_wrd_len = MAX_SMPL_WIDTH_24;\r\nch_stat1.regx.wrd_len = SMPL_WIDTH_24BITS;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nhad_write_register(intelhaddata,\r\nAUD_CH_STATUS_1, ch_stat1.regval);\r\nreturn 0;\r\n}\r\nstatic int had_init_audio_ctrl(struct snd_pcm_substream *substream,\r\nstruct snd_intelhad *intelhaddata)\r\n{\r\nunion aud_cfg cfg_val = {.regval = 0};\r\nunion aud_buf_config buf_cfg = {.regval = 0};\r\nu8 channels;\r\nhad_prog_status_reg(substream, intelhaddata);\r\nbuf_cfg.regx.audio_fifo_watermark = FIFO_THRESHOLD;\r\nbuf_cfg.regx.dma_fifo_watermark = DMA_FIFO_THRESHOLD;\r\nbuf_cfg.regx.aud_delay = 0;\r\nhad_write_register(intelhaddata, AUD_BUF_CONFIG, buf_cfg.regval);\r\nchannels = substream->runtime->channels;\r\ncfg_val.regx.num_ch = channels - 2;\r\nif (channels <= 2)\r\ncfg_val.regx.layout = LAYOUT0;\r\nelse\r\ncfg_val.regx.layout = LAYOUT1;\r\nif (substream->runtime->format == SNDRV_PCM_FORMAT_S16_LE)\r\ncfg_val.regx.packet_mode = 1;\r\nif (substream->runtime->format == SNDRV_PCM_FORMAT_S32_LE)\r\ncfg_val.regx.left_align = 1;\r\ncfg_val.regx.val_bit = 1;\r\nif (intelhaddata->dp_output) {\r\ncfg_val.regx.dp_modei = 1;\r\ncfg_val.regx.set = 1;\r\n}\r\nhad_write_register(intelhaddata, AUD_CONFIG, cfg_val.regval);\r\nintelhaddata->aud_config = cfg_val;\r\nreturn 0;\r\n}\r\nstatic void init_channel_allocations(void)\r\n{\r\nint i, j;\r\nstruct cea_channel_speaker_allocation *p;\r\nfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\r\np = channel_allocations + i;\r\np->channels = 0;\r\np->spk_mask = 0;\r\nfor (j = 0; j < ARRAY_SIZE(p->speakers); j++)\r\nif (p->speakers[j]) {\r\np->channels++;\r\np->spk_mask |= p->speakers[j];\r\n}\r\n}\r\n}\r\nstatic int had_channel_allocation(struct snd_intelhad *intelhaddata,\r\nint channels)\r\n{\r\nint i;\r\nint ca = 0;\r\nint spk_mask = 0;\r\nif (channels <= 2)\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(eld_speaker_allocation_bits); i++) {\r\nif (intelhaddata->eld[DRM_ELD_SPEAKER] & (1 << i))\r\nspk_mask |= eld_speaker_allocation_bits[i];\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\r\nif (channels == channel_allocations[i].channels &&\r\n(spk_mask & channel_allocations[i].spk_mask) ==\r\nchannel_allocations[i].spk_mask) {\r\nca = channel_allocations[i].ca_index;\r\nbreak;\r\n}\r\n}\r\ndev_dbg(intelhaddata->dev, "select CA 0x%x for %d\n", ca, channels);\r\nreturn ca;\r\n}\r\nstatic int spk_to_chmap(int spk)\r\n{\r\nconst struct channel_map_table *t = map_tables;\r\nfor (; t->map; t++) {\r\nif (t->spk_mask == spk)\r\nreturn t->map;\r\n}\r\nreturn 0;\r\n}\r\nstatic void had_build_channel_allocation_map(struct snd_intelhad *intelhaddata)\r\n{\r\nint i, c;\r\nint spk_mask = 0;\r\nstruct snd_pcm_chmap_elem *chmap;\r\nu8 eld_high, eld_high_mask = 0xF0;\r\nu8 high_msb;\r\nkfree(intelhaddata->chmap->chmap);\r\nintelhaddata->chmap->chmap = NULL;\r\nchmap = kzalloc(sizeof(*chmap), GFP_KERNEL);\r\nif (!chmap)\r\nreturn;\r\ndev_dbg(intelhaddata->dev, "eld speaker = %x\n",\r\nintelhaddata->eld[DRM_ELD_SPEAKER]);\r\neld_high = intelhaddata->eld[DRM_ELD_SPEAKER] & eld_high_mask;\r\nif ((eld_high & (eld_high-1)) && (eld_high > 0x1F)) {\r\nfor (i = 1; i < 4; i++) {\r\nhigh_msb = eld_high & (0x80 >> i);\r\nif (high_msb) {\r\nintelhaddata->eld[DRM_ELD_SPEAKER] &=\r\nhigh_msb | 0xF;\r\nbreak;\r\n}\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(eld_speaker_allocation_bits); i++) {\r\nif (intelhaddata->eld[DRM_ELD_SPEAKER] & (1 << i))\r\nspk_mask |= eld_speaker_allocation_bits[i];\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\r\nif (spk_mask == channel_allocations[i].spk_mask) {\r\nfor (c = 0; c < channel_allocations[i].channels; c++) {\r\nchmap->map[c] = spk_to_chmap(\r\nchannel_allocations[i].speakers[\r\n(MAX_SPEAKERS - 1) - c]);\r\n}\r\nchmap->channels = channel_allocations[i].channels;\r\nintelhaddata->chmap->chmap = chmap;\r\nbreak;\r\n}\r\n}\r\nif (i >= ARRAY_SIZE(channel_allocations))\r\nkfree(chmap);\r\n}\r\nstatic int had_chmap_ctl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = HAD_MAX_CHANNEL;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = SNDRV_CHMAP_LAST;\r\nreturn 0;\r\n}\r\nstatic int had_chmap_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\r\nstruct snd_intelhad *intelhaddata = info->private_data;\r\nint i;\r\nconst struct snd_pcm_chmap_elem *chmap;\r\nmemset(ucontrol->value.integer.value, 0,\r\nsizeof(long) * HAD_MAX_CHANNEL);\r\nmutex_lock(&intelhaddata->mutex);\r\nif (!intelhaddata->chmap->chmap) {\r\nmutex_unlock(&intelhaddata->mutex);\r\nreturn 0;\r\n}\r\nchmap = intelhaddata->chmap->chmap;\r\nfor (i = 0; i < chmap->channels; i++)\r\nucontrol->value.integer.value[i] = chmap->map[i];\r\nmutex_unlock(&intelhaddata->mutex);\r\nreturn 0;\r\n}\r\nstatic int had_register_chmap_ctls(struct snd_intelhad *intelhaddata,\r\nstruct snd_pcm *pcm)\r\n{\r\nint err;\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nNULL, 0, (unsigned long)intelhaddata,\r\n&intelhaddata->chmap);\r\nif (err < 0)\r\nreturn err;\r\nintelhaddata->chmap->private_data = intelhaddata;\r\nintelhaddata->chmap->kctl->info = had_chmap_ctl_info;\r\nintelhaddata->chmap->kctl->get = had_chmap_ctl_get;\r\nintelhaddata->chmap->chmap = NULL;\r\nreturn 0;\r\n}\r\nstatic void had_prog_dip(struct snd_pcm_substream *substream,\r\nstruct snd_intelhad *intelhaddata)\r\n{\r\nint i;\r\nunion aud_ctrl_st ctrl_state = {.regval = 0};\r\nunion aud_info_frame2 frame2 = {.regval = 0};\r\nunion aud_info_frame3 frame3 = {.regval = 0};\r\nu8 checksum = 0;\r\nu32 info_frame;\r\nint channels;\r\nint ca;\r\nchannels = substream->runtime->channels;\r\nhad_write_register(intelhaddata, AUD_CNTL_ST, ctrl_state.regval);\r\nca = had_channel_allocation(intelhaddata, channels);\r\nif (intelhaddata->dp_output) {\r\ninfo_frame = DP_INFO_FRAME_WORD1;\r\nframe2.regval = (substream->runtime->channels - 1) | (ca << 24);\r\n} else {\r\ninfo_frame = HDMI_INFO_FRAME_WORD1;\r\nframe2.regx.chnl_cnt = substream->runtime->channels - 1;\r\nframe3.regx.chnl_alloc = ca;\r\nfor (i = 0; i < BYTES_PER_WORD; i++)\r\nchecksum += (info_frame >> (i * 8)) & 0xff;\r\nfor (i = 0; i < BYTES_PER_WORD; i++)\r\nchecksum += (frame2.regval >> (i * 8)) & 0xff;\r\nfor (i = 0; i < BYTES_PER_WORD; i++)\r\nchecksum += (frame3.regval >> (i * 8)) & 0xff;\r\nframe2.regx.chksum = -(checksum);\r\n}\r\nhad_write_register(intelhaddata, AUD_HDMIW_INFOFR, info_frame);\r\nhad_write_register(intelhaddata, AUD_HDMIW_INFOFR, frame2.regval);\r\nhad_write_register(intelhaddata, AUD_HDMIW_INFOFR, frame3.regval);\r\nfor (i = 0; i < HAD_MAX_DIP_WORDS-VALID_DIP_WORDS; i++)\r\nhad_write_register(intelhaddata, AUD_HDMIW_INFOFR, 0x0);\r\nctrl_state.regx.dip_freq = 1;\r\nctrl_state.regx.dip_en_sta = 1;\r\nhad_write_register(intelhaddata, AUD_CNTL_ST, ctrl_state.regval);\r\n}\r\nstatic int had_calculate_maud_value(u32 aud_samp_freq, u32 link_rate)\r\n{\r\nu32 maud_val;\r\nif (link_rate == DP_2_7_GHZ) {\r\nswitch (aud_samp_freq) {\r\ncase AUD_SAMPLE_RATE_32:\r\nmaud_val = AUD_SAMPLE_RATE_32_DP_2_7_MAUD_VAL;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_44_1:\r\nmaud_val = AUD_SAMPLE_RATE_44_1_DP_2_7_MAUD_VAL;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_48:\r\nmaud_val = AUD_SAMPLE_RATE_48_DP_2_7_MAUD_VAL;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_88_2:\r\nmaud_val = AUD_SAMPLE_RATE_88_2_DP_2_7_MAUD_VAL;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_96:\r\nmaud_val = AUD_SAMPLE_RATE_96_DP_2_7_MAUD_VAL;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_176_4:\r\nmaud_val = AUD_SAMPLE_RATE_176_4_DP_2_7_MAUD_VAL;\r\nbreak;\r\ncase HAD_MAX_RATE:\r\nmaud_val = HAD_MAX_RATE_DP_2_7_MAUD_VAL;\r\nbreak;\r\ndefault:\r\nmaud_val = -EINVAL;\r\nbreak;\r\n}\r\n} else if (link_rate == DP_1_62_GHZ) {\r\nswitch (aud_samp_freq) {\r\ncase AUD_SAMPLE_RATE_32:\r\nmaud_val = AUD_SAMPLE_RATE_32_DP_1_62_MAUD_VAL;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_44_1:\r\nmaud_val = AUD_SAMPLE_RATE_44_1_DP_1_62_MAUD_VAL;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_48:\r\nmaud_val = AUD_SAMPLE_RATE_48_DP_1_62_MAUD_VAL;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_88_2:\r\nmaud_val = AUD_SAMPLE_RATE_88_2_DP_1_62_MAUD_VAL;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_96:\r\nmaud_val = AUD_SAMPLE_RATE_96_DP_1_62_MAUD_VAL;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_176_4:\r\nmaud_val = AUD_SAMPLE_RATE_176_4_DP_1_62_MAUD_VAL;\r\nbreak;\r\ncase HAD_MAX_RATE:\r\nmaud_val = HAD_MAX_RATE_DP_1_62_MAUD_VAL;\r\nbreak;\r\ndefault:\r\nmaud_val = -EINVAL;\r\nbreak;\r\n}\r\n} else\r\nmaud_val = -EINVAL;\r\nreturn maud_val;\r\n}\r\nstatic void had_prog_cts(u32 aud_samp_freq, u32 tmds, u32 link_rate,\r\nu32 n_param, struct snd_intelhad *intelhaddata)\r\n{\r\nu32 cts_val;\r\nu64 dividend, divisor;\r\nif (intelhaddata->dp_output) {\r\ncts_val = had_calculate_maud_value(aud_samp_freq, link_rate);\r\n} else {\r\ndividend = (u64)tmds * n_param*1000;\r\ndivisor = 128 * aud_samp_freq;\r\ncts_val = div64_u64(dividend, divisor);\r\n}\r\ndev_dbg(intelhaddata->dev, "TMDS value=%d, N value=%d, CTS Value=%d\n",\r\ntmds, n_param, cts_val);\r\nhad_write_register(intelhaddata, AUD_HDMI_CTS, (BIT(24) | cts_val));\r\n}\r\nstatic int had_calculate_n_value(u32 aud_samp_freq)\r\n{\r\nint n_val;\r\nswitch (aud_samp_freq) {\r\ncase AUD_SAMPLE_RATE_32:\r\nn_val = 4096;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_44_1:\r\nn_val = 6272;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_48:\r\nn_val = 6144;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_88_2:\r\nn_val = 12544;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_96:\r\nn_val = 12288;\r\nbreak;\r\ncase AUD_SAMPLE_RATE_176_4:\r\nn_val = 25088;\r\nbreak;\r\ncase HAD_MAX_RATE:\r\nn_val = 24576;\r\nbreak;\r\ndefault:\r\nn_val = -EINVAL;\r\nbreak;\r\n}\r\nreturn n_val;\r\n}\r\nstatic int had_prog_n(u32 aud_samp_freq, u32 *n_param,\r\nstruct snd_intelhad *intelhaddata)\r\n{\r\nint n_val;\r\nif (intelhaddata->dp_output) {\r\nn_val = DP_NAUD_VAL;\r\n} else\r\nn_val = had_calculate_n_value(aud_samp_freq);\r\nif (n_val < 0)\r\nreturn n_val;\r\nhad_write_register(intelhaddata, AUD_N_ENABLE, (BIT(24) | n_val));\r\n*n_param = n_val;\r\nreturn 0;\r\n}\r\nstatic void had_prog_bd(struct snd_pcm_substream *substream,\r\nstruct snd_intelhad *intelhaddata)\r\n{\r\nint idx = intelhaddata->bd_head;\r\nint ofs = intelhaddata->pcmbuf_filled * intelhaddata->period_bytes;\r\nu32 addr = substream->runtime->dma_addr + ofs;\r\naddr |= AUD_BUF_VALID;\r\nif (!substream->runtime->no_period_wakeup)\r\naddr |= AUD_BUF_INTR_EN;\r\nhad_write_register(intelhaddata, AUD_BUF_ADDR(idx), addr);\r\nhad_write_register(intelhaddata, AUD_BUF_LEN(idx),\r\nintelhaddata->period_bytes);\r\nintelhaddata->bd_head++;\r\nintelhaddata->bd_head %= intelhaddata->num_bds;\r\nintelhaddata->pcmbuf_filled++;\r\nintelhaddata->pcmbuf_filled %= substream->runtime->periods;\r\n}\r\nstatic void had_invalidate_bd(struct snd_intelhad *intelhaddata,\r\nint idx)\r\n{\r\nhad_write_register(intelhaddata, AUD_BUF_ADDR(idx), 0);\r\nhad_write_register(intelhaddata, AUD_BUF_LEN(idx), 0);\r\n}\r\nstatic void had_init_ringbuf(struct snd_pcm_substream *substream,\r\nstruct snd_intelhad *intelhaddata)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint i, num_periods;\r\nnum_periods = runtime->periods;\r\nintelhaddata->num_bds = min(num_periods, HAD_NUM_OF_RING_BUFS);\r\nintelhaddata->num_bds = max(intelhaddata->num_bds, 2U);\r\nintelhaddata->period_bytes =\r\nframes_to_bytes(runtime, runtime->period_size);\r\nWARN_ON(intelhaddata->period_bytes & 0x3f);\r\nintelhaddata->bd_head = 0;\r\nintelhaddata->pcmbuf_head = 0;\r\nintelhaddata->pcmbuf_filled = 0;\r\nfor (i = 0; i < HAD_NUM_OF_RING_BUFS; i++) {\r\nif (i < intelhaddata->num_bds)\r\nhad_prog_bd(substream, intelhaddata);\r\nelse\r\nhad_invalidate_bd(intelhaddata, i);\r\n}\r\nintelhaddata->bd_head = 0;\r\n}\r\nstatic void had_advance_ringbuf(struct snd_pcm_substream *substream,\r\nstruct snd_intelhad *intelhaddata)\r\n{\r\nint num_periods = substream->runtime->periods;\r\nhad_prog_bd(substream, intelhaddata);\r\nintelhaddata->pcmbuf_head++;\r\nintelhaddata->pcmbuf_head %= num_periods;\r\n}\r\nstatic int had_process_ringbuf(struct snd_pcm_substream *substream,\r\nstruct snd_intelhad *intelhaddata)\r\n{\r\nint len, processed;\r\nunsigned long flags;\r\nprocessed = 0;\r\nspin_lock_irqsave(&intelhaddata->had_spinlock, flags);\r\nfor (;;) {\r\nhad_read_register(intelhaddata,\r\nAUD_BUF_LEN(intelhaddata->bd_head),\r\n&len);\r\nif (len < 0 || len > intelhaddata->period_bytes) {\r\ndev_dbg(intelhaddata->dev, "Invalid buf length %d\n",\r\nlen);\r\nlen = -EPIPE;\r\ngoto out;\r\n}\r\nif (len > 0)\r\nbreak;\r\nif (++processed >= intelhaddata->num_bds) {\r\nlen = -EPIPE;\r\ngoto out;\r\n}\r\nhad_advance_ringbuf(substream, intelhaddata);\r\n}\r\nlen = intelhaddata->period_bytes - len;\r\nlen += intelhaddata->period_bytes * intelhaddata->pcmbuf_head;\r\nout:\r\nspin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);\r\nreturn len;\r\n}\r\nstatic void had_process_buffer_done(struct snd_intelhad *intelhaddata)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nsubstream = had_substream_get(intelhaddata);\r\nif (!substream)\r\nreturn;\r\nif (!intelhaddata->connected) {\r\nsnd_pcm_stop_xrun(substream);\r\ngoto out;\r\n}\r\nif (had_process_ringbuf(substream, intelhaddata) < 0)\r\nsnd_pcm_stop_xrun(substream);\r\nelse\r\nsnd_pcm_period_elapsed(substream);\r\nout:\r\nhad_substream_put(intelhaddata);\r\n}\r\nstatic void wait_clear_underrun_bit(struct snd_intelhad *intelhaddata)\r\n{\r\nint i;\r\nu32 val;\r\nfor (i = 0; i < 100; i++) {\r\nhad_read_register(intelhaddata, AUD_HDMI_STATUS, &val);\r\nif (!(val & AUD_HDMI_STATUS_MASK_UNDERRUN))\r\nreturn;\r\nudelay(100);\r\ncond_resched();\r\nhad_write_register(intelhaddata, AUD_HDMI_STATUS, val);\r\n}\r\ndev_err(intelhaddata->dev, "Unable to clear UNDERRUN bits\n");\r\n}\r\nstatic void had_do_reset(struct snd_intelhad *intelhaddata)\r\n{\r\nif (!intelhaddata->need_reset || !intelhaddata->connected)\r\nreturn;\r\nhad_reset_audio(intelhaddata);\r\nwait_clear_underrun_bit(intelhaddata);\r\nintelhaddata->need_reset = false;\r\n}\r\nstatic void had_process_buffer_underrun(struct snd_intelhad *intelhaddata)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nsubstream = had_substream_get(intelhaddata);\r\nif (substream) {\r\nsnd_pcm_stop_xrun(substream);\r\nhad_substream_put(intelhaddata);\r\n}\r\nintelhaddata->need_reset = true;\r\n}\r\nstatic int had_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_intelhad *intelhaddata;\r\nstruct snd_pcm_runtime *runtime;\r\nint retval;\r\nintelhaddata = snd_pcm_substream_chip(substream);\r\nruntime = substream->runtime;\r\npm_runtime_get_sync(intelhaddata->dev);\r\nruntime->hw = had_pcm_hardware;\r\nretval = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (retval < 0)\r\ngoto error;\r\nretval = snd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64);\r\nif (retval < 0)\r\ngoto error;\r\nretval = snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nif (retval < 0)\r\ngoto error;\r\nspin_lock_irq(&intelhaddata->had_spinlock);\r\nintelhaddata->stream_info.substream = substream;\r\nintelhaddata->stream_info.substream_refcount++;\r\nspin_unlock_irq(&intelhaddata->had_spinlock);\r\nreturn retval;\r\nerror:\r\npm_runtime_mark_last_busy(intelhaddata->dev);\r\npm_runtime_put_autosuspend(intelhaddata->dev);\r\nreturn retval;\r\n}\r\nstatic int had_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_intelhad *intelhaddata;\r\nintelhaddata = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&intelhaddata->had_spinlock);\r\nintelhaddata->stream_info.substream = NULL;\r\nintelhaddata->stream_info.substream_refcount--;\r\nwhile (intelhaddata->stream_info.substream_refcount > 0) {\r\nspin_unlock_irq(&intelhaddata->had_spinlock);\r\ncpu_relax();\r\nspin_lock_irq(&intelhaddata->had_spinlock);\r\n}\r\nspin_unlock_irq(&intelhaddata->had_spinlock);\r\npm_runtime_mark_last_busy(intelhaddata->dev);\r\npm_runtime_put_autosuspend(intelhaddata->dev);\r\nreturn 0;\r\n}\r\nstatic int had_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_intelhad *intelhaddata;\r\nunsigned long addr;\r\nint pages, buf_size, retval;\r\nintelhaddata = snd_pcm_substream_chip(substream);\r\nbuf_size = params_buffer_bytes(hw_params);\r\nretval = snd_pcm_lib_malloc_pages(substream, buf_size);\r\nif (retval < 0)\r\nreturn retval;\r\ndev_dbg(intelhaddata->dev, "%s:allocated memory = %d\n",\r\n__func__, buf_size);\r\naddr = (unsigned long) substream->runtime->dma_area;\r\npages = (substream->runtime->dma_bytes + PAGE_SIZE - 1) / PAGE_SIZE;\r\nretval = set_memory_uc(addr, pages);\r\nif (retval) {\r\ndev_err(intelhaddata->dev, "set_memory_uc failed.Error:%d\n",\r\nretval);\r\nreturn retval;\r\n}\r\nmemset(substream->runtime->dma_area, 0, buf_size);\r\nreturn retval;\r\n}\r\nstatic int had_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_intelhad *intelhaddata;\r\nunsigned long addr;\r\nu32 pages;\r\nintelhaddata = snd_pcm_substream_chip(substream);\r\nhad_do_reset(intelhaddata);\r\nif (substream->runtime->dma_area != NULL) {\r\naddr = (unsigned long) substream->runtime->dma_area;\r\npages = (substream->runtime->dma_bytes + PAGE_SIZE - 1) /\r\nPAGE_SIZE;\r\nset_memory_wb(addr, pages);\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nreturn 0;\r\n}\r\nstatic int had_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nint retval = 0;\r\nstruct snd_intelhad *intelhaddata;\r\nintelhaddata = snd_pcm_substream_chip(substream);\r\nspin_lock(&intelhaddata->had_spinlock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nhad_ack_irqs(intelhaddata);\r\nhad_enable_audio(intelhaddata, true);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nhad_enable_audio(intelhaddata, false);\r\nintelhaddata->need_reset = true;\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\n}\r\nspin_unlock(&intelhaddata->had_spinlock);\r\nreturn retval;\r\n}\r\nstatic int had_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nint retval;\r\nu32 disp_samp_freq, n_param;\r\nu32 link_rate = 0;\r\nstruct snd_intelhad *intelhaddata;\r\nstruct snd_pcm_runtime *runtime;\r\nintelhaddata = snd_pcm_substream_chip(substream);\r\nruntime = substream->runtime;\r\ndev_dbg(intelhaddata->dev, "period_size=%d\n",\r\n(int)frames_to_bytes(runtime, runtime->period_size));\r\ndev_dbg(intelhaddata->dev, "periods=%d\n", runtime->periods);\r\ndev_dbg(intelhaddata->dev, "buffer_size=%d\n",\r\n(int)snd_pcm_lib_buffer_bytes(substream));\r\ndev_dbg(intelhaddata->dev, "rate=%d\n", runtime->rate);\r\ndev_dbg(intelhaddata->dev, "channels=%d\n", runtime->channels);\r\nhad_do_reset(intelhaddata);\r\ndisp_samp_freq = intelhaddata->tmds_clock_speed;\r\nretval = had_prog_n(substream->runtime->rate, &n_param, intelhaddata);\r\nif (retval) {\r\ndev_err(intelhaddata->dev,\r\n"programming N value failed %#x\n", retval);\r\ngoto prep_end;\r\n}\r\nif (intelhaddata->dp_output)\r\nlink_rate = intelhaddata->link_rate;\r\nhad_prog_cts(substream->runtime->rate, disp_samp_freq, link_rate,\r\nn_param, intelhaddata);\r\nhad_prog_dip(substream, intelhaddata);\r\nretval = had_init_audio_ctrl(substream, intelhaddata);\r\nhad_init_ringbuf(substream, intelhaddata);\r\nhad_write_register(intelhaddata, AUD_BUF_CH_SWAP, SWAP_LFE_CENTER);\r\nprep_end:\r\nreturn retval;\r\n}\r\nstatic snd_pcm_uframes_t had_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_intelhad *intelhaddata;\r\nint len;\r\nintelhaddata = snd_pcm_substream_chip(substream);\r\nif (!intelhaddata->connected)\r\nreturn SNDRV_PCM_POS_XRUN;\r\nlen = had_process_ringbuf(substream, intelhaddata);\r\nif (len < 0)\r\nreturn SNDRV_PCM_POS_XRUN;\r\nlen = bytes_to_frames(substream->runtime, len);\r\nlen %= substream->runtime->buffer_size;\r\nreturn len;\r\n}\r\nstatic int had_pcm_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *vma)\r\n{\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nreturn remap_pfn_range(vma, vma->vm_start,\r\nsubstream->dma_buffer.addr >> PAGE_SHIFT,\r\nvma->vm_end - vma->vm_start, vma->vm_page_prot);\r\n}\r\nstatic int had_process_mode_change(struct snd_intelhad *intelhaddata)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nint retval = 0;\r\nu32 disp_samp_freq, n_param;\r\nu32 link_rate = 0;\r\nsubstream = had_substream_get(intelhaddata);\r\nif (!substream)\r\nreturn 0;\r\nhad_enable_audio(intelhaddata, false);\r\ndisp_samp_freq = intelhaddata->tmds_clock_speed;\r\nretval = had_prog_n(substream->runtime->rate, &n_param, intelhaddata);\r\nif (retval) {\r\ndev_err(intelhaddata->dev,\r\n"programming N value failed %#x\n", retval);\r\ngoto out;\r\n}\r\nif (intelhaddata->dp_output)\r\nlink_rate = intelhaddata->link_rate;\r\nhad_prog_cts(substream->runtime->rate, disp_samp_freq, link_rate,\r\nn_param, intelhaddata);\r\nhad_enable_audio(intelhaddata, true);\r\nout:\r\nhad_substream_put(intelhaddata);\r\nreturn retval;\r\n}\r\nstatic void had_process_hot_plug(struct snd_intelhad *intelhaddata)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nspin_lock_irq(&intelhaddata->had_spinlock);\r\nif (intelhaddata->connected) {\r\ndev_dbg(intelhaddata->dev, "Device already connected\n");\r\nspin_unlock_irq(&intelhaddata->had_spinlock);\r\nreturn;\r\n}\r\nhad_enable_audio(intelhaddata, false);\r\nintelhaddata->connected = true;\r\ndev_dbg(intelhaddata->dev,\r\n"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_CONNECTED\n",\r\n__func__, __LINE__);\r\nspin_unlock_irq(&intelhaddata->had_spinlock);\r\nhad_build_channel_allocation_map(intelhaddata);\r\nsubstream = had_substream_get(intelhaddata);\r\nif (substream) {\r\nsnd_pcm_stop_xrun(substream);\r\nhad_substream_put(intelhaddata);\r\n}\r\nsnd_jack_report(intelhaddata->jack, SND_JACK_AVOUT);\r\n}\r\nstatic void had_process_hot_unplug(struct snd_intelhad *intelhaddata)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nspin_lock_irq(&intelhaddata->had_spinlock);\r\nif (!intelhaddata->connected) {\r\ndev_dbg(intelhaddata->dev, "Device already disconnected\n");\r\nspin_unlock_irq(&intelhaddata->had_spinlock);\r\nreturn;\r\n}\r\nhad_enable_audio(intelhaddata, false);\r\nintelhaddata->connected = false;\r\ndev_dbg(intelhaddata->dev,\r\n"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\n",\r\n__func__, __LINE__);\r\nspin_unlock_irq(&intelhaddata->had_spinlock);\r\nkfree(intelhaddata->chmap->chmap);\r\nintelhaddata->chmap->chmap = NULL;\r\nsubstream = had_substream_get(intelhaddata);\r\nif (substream) {\r\nsnd_pcm_stop_xrun(substream);\r\nhad_substream_put(intelhaddata);\r\n}\r\nsnd_jack_report(intelhaddata->jack, 0);\r\n}\r\nstatic int had_iec958_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int had_iec958_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_intelhad *intelhaddata = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&intelhaddata->mutex);\r\nucontrol->value.iec958.status[0] = (intelhaddata->aes_bits >> 0) & 0xff;\r\nucontrol->value.iec958.status[1] = (intelhaddata->aes_bits >> 8) & 0xff;\r\nucontrol->value.iec958.status[2] =\r\n(intelhaddata->aes_bits >> 16) & 0xff;\r\nucontrol->value.iec958.status[3] =\r\n(intelhaddata->aes_bits >> 24) & 0xff;\r\nmutex_unlock(&intelhaddata->mutex);\r\nreturn 0;\r\n}\r\nstatic int had_iec958_mask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = 0xff;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[2] = 0xff;\r\nucontrol->value.iec958.status[3] = 0xff;\r\nreturn 0;\r\n}\r\nstatic int had_iec958_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned int val;\r\nstruct snd_intelhad *intelhaddata = snd_kcontrol_chip(kcontrol);\r\nint changed = 0;\r\nval = (ucontrol->value.iec958.status[0] << 0) |\r\n(ucontrol->value.iec958.status[1] << 8) |\r\n(ucontrol->value.iec958.status[2] << 16) |\r\n(ucontrol->value.iec958.status[3] << 24);\r\nmutex_lock(&intelhaddata->mutex);\r\nif (intelhaddata->aes_bits != val) {\r\nintelhaddata->aes_bits = val;\r\nchanged = 1;\r\n}\r\nmutex_unlock(&intelhaddata->mutex);\r\nreturn changed;\r\n}\r\nstatic int had_ctl_eld_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nuinfo->count = HDMI_MAX_ELD_BYTES;\r\nreturn 0;\r\n}\r\nstatic int had_ctl_eld_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_intelhad *intelhaddata = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&intelhaddata->mutex);\r\nmemcpy(ucontrol->value.bytes.data, intelhaddata->eld,\r\nHDMI_MAX_ELD_BYTES);\r\nmutex_unlock(&intelhaddata->mutex);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t display_pipe_interrupt_handler(int irq, void *dev_id)\r\n{\r\nstruct snd_intelhad_card *card_ctx = dev_id;\r\nu32 audio_stat[3] = {};\r\nint pipe, port;\r\nfor_each_pipe(card_ctx, pipe) {\r\naudio_stat[pipe] = had_read_register_raw(card_ctx, pipe,\r\nAUD_HDMI_STATUS) &\r\n(HDMI_AUDIO_UNDERRUN | HDMI_AUDIO_BUFFER_DONE);\r\nif (audio_stat[pipe])\r\nhad_write_register_raw(card_ctx, pipe,\r\nAUD_HDMI_STATUS, audio_stat[pipe]);\r\n}\r\nfor_each_port(card_ctx, port) {\r\nstruct snd_intelhad *ctx = &card_ctx->pcm_ctx[port];\r\nint pipe = ctx->pipe;\r\nif (pipe < 0)\r\ncontinue;\r\nif (audio_stat[pipe] & HDMI_AUDIO_BUFFER_DONE)\r\nhad_process_buffer_done(ctx);\r\nif (audio_stat[pipe] & HDMI_AUDIO_UNDERRUN)\r\nhad_process_buffer_underrun(ctx);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void notify_audio_lpe(struct platform_device *pdev, int port)\r\n{\r\nstruct snd_intelhad_card *card_ctx = platform_get_drvdata(pdev);\r\nstruct snd_intelhad *ctx = &card_ctx->pcm_ctx[port];\r\nschedule_work(&ctx->hdmi_audio_wq);\r\n}\r\nstatic void had_audio_wq(struct work_struct *work)\r\n{\r\nstruct snd_intelhad *ctx =\r\ncontainer_of(work, struct snd_intelhad, hdmi_audio_wq);\r\nstruct intel_hdmi_lpe_audio_pdata *pdata = ctx->dev->platform_data;\r\nstruct intel_hdmi_lpe_audio_port_pdata *ppdata = &pdata->port[ctx->port];\r\npm_runtime_get_sync(ctx->dev);\r\nmutex_lock(&ctx->mutex);\r\nif (ppdata->pipe < 0) {\r\ndev_dbg(ctx->dev, "%s: Event: HAD_NOTIFY_HOT_UNPLUG : port = %d\n",\r\n__func__, ctx->port);\r\nmemset(ctx->eld, 0, sizeof(ctx->eld));\r\nctx->dp_output = false;\r\nctx->tmds_clock_speed = 0;\r\nctx->link_rate = 0;\r\nhad_process_hot_unplug(ctx);\r\nctx->pipe = -1;\r\n} else {\r\ndev_dbg(ctx->dev, "%s: HAD_NOTIFY_ELD : port = %d, tmds = %d\n",\r\n__func__, ctx->port, ppdata->ls_clock);\r\nmemcpy(ctx->eld, ppdata->eld, sizeof(ctx->eld));\r\nctx->dp_output = ppdata->dp_output;\r\nif (ctx->dp_output) {\r\nctx->tmds_clock_speed = 0;\r\nctx->link_rate = ppdata->ls_clock;\r\n} else {\r\nctx->tmds_clock_speed = ppdata->ls_clock;\r\nctx->link_rate = 0;\r\n}\r\nhad_process_hot_plug(ctx);\r\nctx->pipe = ppdata->pipe;\r\nhad_process_mode_change(ctx);\r\n}\r\nmutex_unlock(&ctx->mutex);\r\npm_runtime_mark_last_busy(ctx->dev);\r\npm_runtime_put_autosuspend(ctx->dev);\r\n}\r\nstatic int had_create_jack(struct snd_intelhad *ctx,\r\nstruct snd_pcm *pcm)\r\n{\r\nchar hdmi_str[32];\r\nint err;\r\nsnprintf(hdmi_str, sizeof(hdmi_str),\r\n"HDMI/DP,pcm=%d", pcm->device);\r\nerr = snd_jack_new(ctx->card_ctx->card, hdmi_str,\r\nSND_JACK_AVOUT, &ctx->jack,\r\ntrue, false);\r\nif (err < 0)\r\nreturn err;\r\nctx->jack->private_data = ctx;\r\nreturn 0;\r\n}\r\nstatic int hdmi_lpe_audio_runtime_suspend(struct device *dev)\r\n{\r\nstruct snd_intelhad_card *card_ctx = dev_get_drvdata(dev);\r\nint port;\r\nfor_each_port(card_ctx, port) {\r\nstruct snd_intelhad *ctx = &card_ctx->pcm_ctx[port];\r\nstruct snd_pcm_substream *substream;\r\nsubstream = had_substream_get(ctx);\r\nif (substream) {\r\nsnd_pcm_suspend(substream);\r\nhad_substream_put(ctx);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused hdmi_lpe_audio_suspend(struct device *dev)\r\n{\r\nstruct snd_intelhad_card *card_ctx = dev_get_drvdata(dev);\r\nint err;\r\nerr = hdmi_lpe_audio_runtime_suspend(dev);\r\nif (!err)\r\nsnd_power_change_state(card_ctx->card, SNDRV_CTL_POWER_D3hot);\r\nreturn err;\r\n}\r\nstatic int hdmi_lpe_audio_runtime_resume(struct device *dev)\r\n{\r\npm_runtime_mark_last_busy(dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused hdmi_lpe_audio_resume(struct device *dev)\r\n{\r\nstruct snd_intelhad_card *card_ctx = dev_get_drvdata(dev);\r\nhdmi_lpe_audio_runtime_resume(dev);\r\nsnd_power_change_state(card_ctx->card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic void hdmi_lpe_audio_free(struct snd_card *card)\r\n{\r\nstruct snd_intelhad_card *card_ctx = card->private_data;\r\nstruct intel_hdmi_lpe_audio_pdata *pdata = card_ctx->dev->platform_data;\r\nint port;\r\nspin_lock_irq(&pdata->lpe_audio_slock);\r\npdata->notify_audio_lpe = NULL;\r\nspin_unlock_irq(&pdata->lpe_audio_slock);\r\nfor_each_port(card_ctx, port) {\r\nstruct snd_intelhad *ctx = &card_ctx->pcm_ctx[port];\r\ncancel_work_sync(&ctx->hdmi_audio_wq);\r\n}\r\nif (card_ctx->mmio_start)\r\niounmap(card_ctx->mmio_start);\r\nif (card_ctx->irq >= 0)\r\nfree_irq(card_ctx->irq, card_ctx);\r\n}\r\nstatic int hdmi_lpe_audio_probe(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_intelhad_card *card_ctx;\r\nstruct snd_pcm *pcm;\r\nstruct intel_hdmi_lpe_audio_pdata *pdata;\r\nint irq;\r\nstruct resource *res_mmio;\r\nint port, ret;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "%s: quit: pdata not allocated by i915!!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "Could not get irq resource: %d\n", irq);\r\nreturn irq;\r\n}\r\nres_mmio = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res_mmio) {\r\ndev_err(&pdev->dev, "Could not get IO_MEM resources\n");\r\nreturn -ENXIO;\r\n}\r\nret = snd_card_new(&pdev->dev, hdmi_card_index, hdmi_card_id,\r\nTHIS_MODULE, sizeof(*card_ctx), &card);\r\nif (ret)\r\nreturn ret;\r\ncard_ctx = card->private_data;\r\ncard_ctx->dev = &pdev->dev;\r\ncard_ctx->card = card;\r\nstrcpy(card->driver, INTEL_HAD);\r\nstrcpy(card->shortname, "Intel HDMI/DP LPE Audio");\r\nstrcpy(card->longname, "Intel HDMI/DP LPE Audio");\r\ncard_ctx->irq = -1;\r\ncard->private_free = hdmi_lpe_audio_free;\r\nplatform_set_drvdata(pdev, card_ctx);\r\ndev_dbg(&pdev->dev, "%s: mmio_start = 0x%x, mmio_end = 0x%x\n",\r\n__func__, (unsigned int)res_mmio->start,\r\n(unsigned int)res_mmio->end);\r\ncard_ctx->mmio_start = ioremap_nocache(res_mmio->start,\r\n(size_t)(resource_size(res_mmio)));\r\nif (!card_ctx->mmio_start) {\r\ndev_err(&pdev->dev, "Could not get ioremap\n");\r\nret = -EACCES;\r\ngoto err;\r\n}\r\nret = request_irq(irq, display_pipe_interrupt_handler, 0,\r\npdev->name, card_ctx);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "request_irq failed\n");\r\ngoto err;\r\n}\r\ncard_ctx->irq = irq;\r\ndma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\r\ndma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\r\ninit_channel_allocations();\r\ncard_ctx->num_pipes = pdata->num_pipes;\r\ncard_ctx->num_ports = pdata->num_ports;\r\nfor_each_port(card_ctx, port) {\r\nstruct snd_intelhad *ctx = &card_ctx->pcm_ctx[port];\r\nint i;\r\nctx->card_ctx = card_ctx;\r\nctx->dev = card_ctx->dev;\r\nctx->port = port;\r\nctx->pipe = -1;\r\nINIT_WORK(&ctx->hdmi_audio_wq, had_audio_wq);\r\nret = snd_pcm_new(card, INTEL_HAD, port, MAX_PB_STREAMS,\r\nMAX_CAP_STREAMS, &pcm);\r\nif (ret)\r\ngoto err;\r\npcm->private_data = ctx;\r\npcm->info_flags = 0;\r\nstrncpy(pcm->name, card->shortname, strlen(card->shortname));\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &had_pcm_ops);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm,\r\nSNDRV_DMA_TYPE_DEV, NULL,\r\nHAD_DEFAULT_BUFFER, HAD_MAX_BUFFER);\r\nfor (i = 0; i < ARRAY_SIZE(had_controls); i++) {\r\nstruct snd_kcontrol *kctl;\r\nkctl = snd_ctl_new1(&had_controls[i], ctx);\r\nif (!kctl) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nkctl->id.device = pcm->device;\r\nret = snd_ctl_add(card, kctl);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nret = had_register_chmap_ctls(ctx, pcm);\r\nif (ret < 0)\r\ngoto err;\r\nret = had_create_jack(ctx, pcm);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nret = snd_card_register(card);\r\nif (ret)\r\ngoto err;\r\nspin_lock_irq(&pdata->lpe_audio_slock);\r\npdata->notify_audio_lpe = notify_audio_lpe;\r\nspin_unlock_irq(&pdata->lpe_audio_slock);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_mark_last_busy(&pdev->dev);\r\npm_runtime_set_active(&pdev->dev);\r\ndev_dbg(&pdev->dev, "%s: handle pending notification\n", __func__);\r\nfor_each_port(card_ctx, port) {\r\nstruct snd_intelhad *ctx = &card_ctx->pcm_ctx[port];\r\nschedule_work(&ctx->hdmi_audio_wq);\r\n}\r\nreturn 0;\r\nerr:\r\nsnd_card_free(card);\r\nreturn ret;\r\n}\r\nstatic int hdmi_lpe_audio_remove(struct platform_device *pdev)\r\n{\r\nstruct snd_intelhad_card *card_ctx = platform_get_drvdata(pdev);\r\nsnd_card_free(card_ctx->card);\r\nreturn 0;\r\n}
