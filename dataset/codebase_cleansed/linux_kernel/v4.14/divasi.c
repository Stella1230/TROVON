static char *getrev(const char *revision)\r\n{\r\nchar *rev;\r\nchar *p;\r\nif ((p = strchr(revision, ':'))) {\r\nrev = p + 2;\r\np = strchr(rev, '$');\r\n*--p = 0;\r\n} else\r\nrev = "1.0";\r\nreturn rev;\r\n}\r\nstatic int um_idi_proc_show(struct seq_file *m, void *v)\r\n{\r\nchar tmprev[32];\r\nseq_printf(m, "%s\n", DRIVERNAME);\r\nseq_printf(m, "name : %s\n", DRIVERLNAME);\r\nseq_printf(m, "release : %s\n", DRIVERRELEASE_IDI);\r\nstrcpy(tmprev, main_revision);\r\nseq_printf(m, "revision : %s\n", getrev(tmprev));\r\nseq_printf(m, "build : %s\n", DIVA_BUILD);\r\nseq_printf(m, "major : %d\n", major);\r\nreturn 0;\r\n}\r\nstatic int um_idi_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, um_idi_proc_show, NULL);\r\n}\r\nstatic int __init create_um_idi_proc(void)\r\n{\r\num_idi_proc_entry = proc_create(DRIVERLNAME, S_IRUGO, proc_net_eicon,\r\n&um_idi_proc_fops);\r\nif (!um_idi_proc_entry)\r\nreturn (0);\r\nreturn (1);\r\n}\r\nstatic void remove_um_idi_proc(void)\r\n{\r\nif (um_idi_proc_entry) {\r\nremove_proc_entry(DRIVERLNAME, proc_net_eicon);\r\num_idi_proc_entry = NULL;\r\n}\r\n}\r\nstatic void divas_idi_unregister_chrdev(void)\r\n{\r\nunregister_chrdev(major, DEVNAME);\r\n}\r\nstatic int __init divas_idi_register_chrdev(void)\r\n{\r\nif ((major = register_chrdev(0, DEVNAME, &divas_idi_fops)) < 0)\r\n{\r\nprintk(KERN_ERR "%s: failed to create /dev entry.\n",\r\nDRIVERLNAME);\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}\r\nstatic int __init divasi_init(void)\r\n{\r\nchar tmprev[50];\r\nint ret = 0;\r\nprintk(KERN_INFO "%s\n", DRIVERNAME);\r\nprintk(KERN_INFO "%s: Rel:%s Rev:", DRIVERLNAME, DRIVERRELEASE_IDI);\r\nstrcpy(tmprev, main_revision);\r\nprintk("%s Build: %s\n", getrev(tmprev), DIVA_BUILD);\r\nif (!divas_idi_register_chrdev()) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (!create_um_idi_proc()) {\r\ndivas_idi_unregister_chrdev();\r\nprintk(KERN_ERR "%s: failed to create proc entry.\n",\r\nDRIVERLNAME);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (!(idifunc_init())) {\r\nremove_um_idi_proc();\r\ndivas_idi_unregister_chrdev();\r\nprintk(KERN_ERR "%s: failed to connect to DIDD.\n",\r\nDRIVERLNAME);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nprintk(KERN_INFO "%s: started with major %d\n", DRIVERLNAME, major);\r\nout:\r\nreturn (ret);\r\n}\r\nstatic void __exit divasi_exit(void)\r\n{\r\nidifunc_finit();\r\nremove_um_idi_proc();\r\ndivas_idi_unregister_chrdev();\r\nprintk(KERN_INFO "%s: module unloaded.\n", DRIVERLNAME);\r\n}\r\nstatic int\r\ndivas_um_idi_copy_to_user(void *os_handle, void *dst, const void *src,\r\nint length)\r\n{\r\nmemcpy(dst, src, length);\r\nreturn (length);\r\n}\r\nstatic ssize_t\r\num_idi_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\r\n{\r\ndiva_um_idi_os_context_t *p_os;\r\nint ret = -EINVAL;\r\nvoid *data;\r\nif (!file->private_data) {\r\nreturn (-ENODEV);\r\n}\r\nif (!\r\n(p_os =\r\n(diva_um_idi_os_context_t *) diva_um_id_get_os_context(file->\r\nprivate_data)))\r\n{\r\nreturn (-ENODEV);\r\n}\r\nif (p_os->aborted) {\r\nreturn (-ENODEV);\r\n}\r\nif (!(data = diva_os_malloc(0, count))) {\r\nreturn (-ENOMEM);\r\n}\r\nret = diva_um_idi_read(file->private_data,\r\nfile, data, count,\r\ndivas_um_idi_copy_to_user);\r\nswitch (ret) {\r\ncase 0:\r\nret = (-EAGAIN);\r\nbreak;\r\ncase (-1):\r\nret = (-ENODEV);\r\nbreak;\r\ncase (-2):\r\nret = (-EFAULT);\r\nbreak;\r\n}\r\nif (ret > 0) {\r\nif (copy_to_user(buf, data, ret)) {\r\nret = (-EFAULT);\r\n}\r\n}\r\ndiva_os_free(0, data);\r\nDBG_TRC(("read: ret %d", ret));\r\nreturn (ret);\r\n}\r\nstatic int\r\ndivas_um_idi_copy_from_user(void *os_handle, void *dst, const void *src,\r\nint length)\r\n{\r\nmemcpy(dst, src, length);\r\nreturn (length);\r\n}\r\nstatic int um_idi_open_adapter(struct file *file, int adapter_nr)\r\n{\r\ndiva_um_idi_os_context_t *p_os;\r\nvoid *e =\r\ndivas_um_idi_create_entity((dword) adapter_nr, (void *) file);\r\nif (!(file->private_data = e)) {\r\nreturn (0);\r\n}\r\np_os = (diva_um_idi_os_context_t *) diva_um_id_get_os_context(e);\r\ninit_waitqueue_head(&p_os->read_wait);\r\ninit_waitqueue_head(&p_os->close_wait);\r\nsetup_timer(&p_os->diva_timer_id, (void *)diva_um_timer_function,\r\n(unsigned long)p_os);\r\np_os->aborted = 0;\r\np_os->adapter_nr = adapter_nr;\r\nreturn (1);\r\n}\r\nstatic ssize_t\r\num_idi_write(struct file *file, const char __user *buf, size_t count,\r\nloff_t *offset)\r\n{\r\ndiva_um_idi_os_context_t *p_os;\r\nint ret = -EINVAL;\r\nvoid *data;\r\nint adapter_nr = 0;\r\nif (!file->private_data) {\r\nif (count == sizeof(int)) {\r\nif (copy_from_user\r\n((void *) &adapter_nr, buf,\r\ncount)) return (-EFAULT);\r\nif (!(um_idi_open_adapter(file, adapter_nr)))\r\nreturn (-ENODEV);\r\nreturn (count);\r\n} else\r\nreturn (-ENODEV);\r\n}\r\nif (!(p_os =\r\n(diva_um_idi_os_context_t *) diva_um_id_get_os_context(file->\r\nprivate_data)))\r\n{\r\nreturn (-ENODEV);\r\n}\r\nif (p_os->aborted) {\r\nreturn (-ENODEV);\r\n}\r\nif (!(data = diva_os_malloc(0, count))) {\r\nreturn (-ENOMEM);\r\n}\r\nif (copy_from_user(data, buf, count)) {\r\nret = -EFAULT;\r\n} else {\r\nret = diva_um_idi_write(file->private_data,\r\nfile, data, count,\r\ndivas_um_idi_copy_from_user);\r\nswitch (ret) {\r\ncase 0:\r\nret = (-EAGAIN);\r\nbreak;\r\ncase (-1):\r\nret = (-ENODEV);\r\nbreak;\r\ncase (-2):\r\nret = (-EFAULT);\r\nbreak;\r\n}\r\n}\r\ndiva_os_free(0, data);\r\nDBG_TRC(("write: ret %d", ret));\r\nreturn (ret);\r\n}\r\nstatic unsigned int um_idi_poll(struct file *file, poll_table *wait)\r\n{\r\ndiva_um_idi_os_context_t *p_os;\r\nif (!file->private_data) {\r\nreturn (POLLERR);\r\n}\r\nif ((!(p_os =\r\n(diva_um_idi_os_context_t *)\r\ndiva_um_id_get_os_context(file->private_data)))\r\n|| p_os->aborted) {\r\nreturn (POLLERR);\r\n}\r\npoll_wait(file, &p_os->read_wait, wait);\r\nif (p_os->aborted) {\r\nreturn (POLLERR);\r\n}\r\nswitch (diva_user_mode_idi_ind_ready(file->private_data, file)) {\r\ncase (-1):\r\nreturn (POLLERR);\r\ncase 0:\r\nreturn (0);\r\n}\r\nreturn (POLLIN | POLLRDNORM);\r\n}\r\nstatic int um_idi_open(struct inode *inode, struct file *file)\r\n{\r\nreturn (0);\r\n}\r\nstatic int um_idi_release(struct inode *inode, struct file *file)\r\n{\r\ndiva_um_idi_os_context_t *p_os;\r\nunsigned int adapter_nr;\r\nint ret = 0;\r\nif (!(file->private_data)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (!(p_os =\r\n(diva_um_idi_os_context_t *) diva_um_id_get_os_context(file->private_data))) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nadapter_nr = p_os->adapter_nr;\r\nif ((ret = remove_entity(file->private_data))) {\r\ngoto out;\r\n}\r\nif (divas_um_idi_delete_entity\r\n((int) adapter_nr, file->private_data)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nout:\r\nreturn (ret);\r\n}\r\nint diva_os_get_context_size(void)\r\n{\r\nreturn (sizeof(diva_um_idi_os_context_t));\r\n}\r\nvoid diva_os_wakeup_read(void *os_context)\r\n{\r\ndiva_um_idi_os_context_t *p_os =\r\n(diva_um_idi_os_context_t *) os_context;\r\nwake_up_interruptible(&p_os->read_wait);\r\n}\r\nvoid diva_os_wakeup_close(void *os_context)\r\n{\r\ndiva_um_idi_os_context_t *p_os =\r\n(diva_um_idi_os_context_t *) os_context;\r\nwake_up_interruptible(&p_os->close_wait);\r\n}\r\nstatic\r\nvoid diva_um_timer_function(unsigned long data)\r\n{\r\ndiva_um_idi_os_context_t *p_os = (diva_um_idi_os_context_t *) data;\r\np_os->aborted = 1;\r\nwake_up_interruptible(&p_os->read_wait);\r\nwake_up_interruptible(&p_os->close_wait);\r\nDBG_ERR(("entity removal watchdog"))\r\n}\r\nstatic int remove_entity(void *entity)\r\n{\r\nstruct task_struct *curtask = current;\r\ndiva_um_idi_os_context_t *p_os;\r\ndiva_um_idi_stop_wdog(entity);\r\nif (!entity) {\r\nDBG_FTL(("Zero entity on remove"))\r\nreturn (0);\r\n}\r\nif (!(p_os =\r\n(diva_um_idi_os_context_t *)\r\ndiva_um_id_get_os_context(entity))) {\r\nDBG_FTL(("Zero entity os context on remove"))\r\nreturn (0);\r\n}\r\nif (!divas_um_idi_entity_assigned(entity) || p_os->aborted) {\r\nreturn (0);\r\n}\r\nDBG_TRC(("E(%08x) check remove", entity))\r\ndiva_um_idi_start_wdog(entity);\r\n{\r\nDECLARE_WAITQUEUE(wait, curtask);\r\nadd_wait_queue(&p_os->close_wait, &wait);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (!divas_um_idi_entity_start_remove(entity)\r\n|| p_os->aborted) {\r\nbreak;\r\n}\r\nschedule();\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&p_os->close_wait, &wait);\r\n}\r\nDBG_TRC(("E(%08x) start remove", entity))\r\n{\r\nDECLARE_WAITQUEUE(wait, curtask);\r\nadd_wait_queue(&p_os->close_wait, &wait);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (!divas_um_idi_entity_assigned(entity)\r\n|| p_os->aborted) {\r\nbreak;\r\n}\r\nschedule();\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&p_os->close_wait, &wait);\r\n}\r\nDBG_TRC(("E(%08x) remove complete, aborted:%d", entity,\r\np_os->aborted))\r\ndiva_um_idi_stop_wdog(entity);\r\np_os->aborted = 0;\r\nreturn (0);\r\n}\r\nvoid diva_um_idi_start_wdog(void *entity)\r\n{\r\ndiva_um_idi_os_context_t *p_os;\r\nif (entity &&\r\n((p_os =\r\n(diva_um_idi_os_context_t *)\r\ndiva_um_id_get_os_context(entity)))) {\r\nmod_timer(&p_os->diva_timer_id, jiffies + 10 * HZ);\r\n}\r\n}\r\nvoid diva_um_idi_stop_wdog(void *entity)\r\n{\r\ndiva_um_idi_os_context_t *p_os;\r\nif (entity &&\r\n((p_os =\r\n(diva_um_idi_os_context_t *)\r\ndiva_um_id_get_os_context(entity)))) {\r\ndel_timer(&p_os->diva_timer_id);\r\n}\r\n}
