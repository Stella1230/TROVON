void acpi_ex_enter_interpreter(void)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ex_enter_interpreter);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR((AE_INFO,\r\n"Could not acquire AML Interpreter mutex"));\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR((AE_INFO, "Could not acquire AML Namespace mutex"));\r\n}\r\nreturn_VOID;\r\n}\r\nvoid acpi_ex_exit_interpreter(void)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ex_exit_interpreter);\r\nstatus = acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR((AE_INFO, "Could not release AML Namespace mutex"));\r\n}\r\nstatus = acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR((AE_INFO,\r\n"Could not release AML Interpreter mutex"));\r\n}\r\nreturn_VOID;\r\n}\r\nu8 acpi_ex_truncate_for32bit_table(union acpi_operand_object *obj_desc)\r\n{\r\nACPI_FUNCTION_ENTRY();\r\nif ((!obj_desc) ||\r\n(ACPI_GET_DESCRIPTOR_TYPE(obj_desc) != ACPI_DESC_TYPE_OPERAND) ||\r\n(obj_desc->common.type != ACPI_TYPE_INTEGER)) {\r\nreturn (FALSE);\r\n}\r\nif ((acpi_gbl_integer_byte_width == 4) &&\r\n(obj_desc->integer.value > (u64)ACPI_UINT32_MAX)) {\r\nobj_desc->integer.value &= (u64)ACPI_UINT32_MAX;\r\nreturn (TRUE);\r\n}\r\nreturn (FALSE);\r\n}\r\nvoid acpi_ex_acquire_global_lock(u32 field_flags)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ex_acquire_global_lock);\r\nif (!(field_flags & AML_FIELD_LOCK_RULE_MASK)) {\r\nreturn_VOID;\r\n}\r\nstatus = acpi_ex_acquire_mutex_object(ACPI_WAIT_FOREVER,\r\nacpi_gbl_global_lock_mutex,\r\nacpi_os_get_thread_id());\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Could not acquire Global Lock"));\r\n}\r\nreturn_VOID;\r\n}\r\nvoid acpi_ex_release_global_lock(u32 field_flags)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ex_release_global_lock);\r\nif (!(field_flags & AML_FIELD_LOCK_RULE_MASK)) {\r\nreturn_VOID;\r\n}\r\nstatus = acpi_ex_release_mutex_object(acpi_gbl_global_lock_mutex);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Could not release Global Lock"));\r\n}\r\nreturn_VOID;\r\n}\r\nstatic u32 acpi_ex_digits_needed(u64 value, u32 base)\r\n{\r\nu32 num_digits;\r\nu64 current_value;\r\nACPI_FUNCTION_TRACE(ex_digits_needed);\r\nif (value == 0) {\r\nreturn_UINT32(1);\r\n}\r\ncurrent_value = value;\r\nnum_digits = 0;\r\nwhile (current_value) {\r\n(void)acpi_ut_short_divide(current_value, base, &current_value,\r\nNULL);\r\nnum_digits++;\r\n}\r\nreturn_UINT32(num_digits);\r\n}\r\nvoid acpi_ex_eisa_id_to_string(char *out_string, u64 compressed_id)\r\n{\r\nu32 swapped_id;\r\nACPI_FUNCTION_ENTRY();\r\nif (compressed_id > ACPI_UINT32_MAX) {\r\nACPI_WARNING((AE_INFO,\r\n"Expected EISAID is larger than 32 bits: "\r\n"0x%8.8X%8.8X, truncating",\r\nACPI_FORMAT_UINT64(compressed_id)));\r\n}\r\nswapped_id = acpi_ut_dword_byte_swap((u32)compressed_id);\r\nout_string[0] =\r\n(char)(0x40 + (((unsigned long)swapped_id >> 26) & 0x1F));\r\nout_string[1] = (char)(0x40 + ((swapped_id >> 21) & 0x1F));\r\nout_string[2] = (char)(0x40 + ((swapped_id >> 16) & 0x1F));\r\nout_string[3] = acpi_ut_hex_to_ascii_char((u64) swapped_id, 12);\r\nout_string[4] = acpi_ut_hex_to_ascii_char((u64) swapped_id, 8);\r\nout_string[5] = acpi_ut_hex_to_ascii_char((u64) swapped_id, 4);\r\nout_string[6] = acpi_ut_hex_to_ascii_char((u64) swapped_id, 0);\r\nout_string[7] = 0;\r\n}\r\nvoid acpi_ex_integer_to_string(char *out_string, u64 value)\r\n{\r\nu32 count;\r\nu32 digits_needed;\r\nu32 remainder;\r\nACPI_FUNCTION_ENTRY();\r\ndigits_needed = acpi_ex_digits_needed(value, 10);\r\nout_string[digits_needed] = 0;\r\nfor (count = digits_needed; count > 0; count--) {\r\n(void)acpi_ut_short_divide(value, 10, &value, &remainder);\r\nout_string[count - 1] = (char)('0' + remainder);\r\n}\r\n}\r\nvoid acpi_ex_pci_cls_to_string(char *out_string, u8 class_code[3])\r\n{\r\nACPI_FUNCTION_ENTRY();\r\nout_string[0] = acpi_ut_hex_to_ascii_char((u64)class_code[0], 4);\r\nout_string[1] = acpi_ut_hex_to_ascii_char((u64)class_code[0], 0);\r\nout_string[2] = acpi_ut_hex_to_ascii_char((u64)class_code[1], 4);\r\nout_string[3] = acpi_ut_hex_to_ascii_char((u64)class_code[1], 0);\r\nout_string[4] = acpi_ut_hex_to_ascii_char((u64)class_code[2], 4);\r\nout_string[5] = acpi_ut_hex_to_ascii_char((u64)class_code[2], 0);\r\nout_string[6] = 0;\r\n}\r\nu8 acpi_is_valid_space_id(u8 space_id)\r\n{\r\nif ((space_id >= ACPI_NUM_PREDEFINED_REGIONS) &&\r\n(space_id < ACPI_USER_REGION_BEGIN) &&\r\n(space_id != ACPI_ADR_SPACE_DATA_TABLE) &&\r\n(space_id != ACPI_ADR_SPACE_FIXED_HARDWARE)) {\r\nreturn (FALSE);\r\n}\r\nreturn (TRUE);\r\n}
