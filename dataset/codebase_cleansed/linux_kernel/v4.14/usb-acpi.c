bool usb_acpi_power_manageable(struct usb_device *hdev, int index)\r\n{\r\nacpi_handle port_handle;\r\nint port1 = index + 1;\r\nport_handle = usb_get_hub_port_acpi_handle(hdev,\r\nport1);\r\nif (port_handle)\r\nreturn acpi_bus_power_manageable(port_handle);\r\nelse\r\nreturn false;\r\n}\r\nint usb_acpi_set_power_state(struct usb_device *hdev, int index, bool enable)\r\n{\r\nstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\r\nstruct usb_port *port_dev;\r\nacpi_handle port_handle;\r\nunsigned char state;\r\nint port1 = index + 1;\r\nint error = -EINVAL;\r\nif (!hub)\r\nreturn -ENODEV;\r\nport_dev = hub->ports[port1 - 1];\r\nport_handle = (acpi_handle) usb_get_hub_port_acpi_handle(hdev, port1);\r\nif (!port_handle)\r\nreturn error;\r\nif (enable)\r\nstate = ACPI_STATE_D0;\r\nelse\r\nstate = ACPI_STATE_D3_COLD;\r\nerror = acpi_bus_set_power(port_handle, state);\r\nif (!error)\r\ndev_dbg(&port_dev->dev, "acpi: power was set to %d\n", enable);\r\nelse\r\ndev_dbg(&port_dev->dev, "acpi: power failed to be set\n");\r\nreturn error;\r\n}\r\nstatic enum usb_port_connect_type usb_acpi_get_connect_type(acpi_handle handle,\r\nstruct acpi_pld_info *pld)\r\n{\r\nenum usb_port_connect_type connect_type = USB_PORT_CONNECT_TYPE_UNKNOWN;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *upc;\r\nacpi_status status;\r\nstatus = acpi_evaluate_object(handle, "_UPC", NULL, &buffer);\r\nupc = buffer.pointer;\r\nif (!upc || (upc->type != ACPI_TYPE_PACKAGE)\r\n|| upc->package.count != 4) {\r\ngoto out;\r\n}\r\nif (upc->package.elements[0].integer.value)\r\nif (pld->user_visible)\r\nconnect_type = USB_PORT_CONNECT_TYPE_HOT_PLUG;\r\nelse\r\nconnect_type = USB_PORT_CONNECT_TYPE_HARD_WIRED;\r\nelse if (!pld->user_visible)\r\nconnect_type = USB_PORT_NOT_USED;\r\nout:\r\nkfree(upc);\r\nreturn connect_type;\r\n}\r\nstatic struct acpi_device *usb_acpi_find_port(struct acpi_device *parent,\r\nint raw)\r\n{\r\nstruct acpi_device *adev;\r\nif (!parent)\r\nreturn NULL;\r\nlist_for_each_entry(adev, &parent->children, node) {\r\nif (acpi_device_adr(adev) == raw)\r\nreturn adev;\r\n}\r\nreturn acpi_find_child_device(parent, raw, false);\r\n}\r\nstatic struct acpi_device *usb_acpi_find_companion(struct device *dev)\r\n{\r\nstruct usb_device *udev;\r\nstruct acpi_device *adev;\r\nacpi_handle *parent_handle;\r\nif (is_usb_device(dev)) {\r\nudev = to_usb_device(dev);\r\nif (udev->parent)\r\nreturn NULL;\r\nadev = ACPI_COMPANION(dev->parent);\r\nreturn acpi_find_child_device(adev, 0, false);\r\n} else if (is_usb_port(dev)) {\r\nstruct usb_port *port_dev = to_usb_port(dev);\r\nint port1 = port_dev->portnum;\r\nstruct acpi_pld_info *pld;\r\nacpi_handle *handle;\r\nacpi_status status;\r\nudev = to_usb_device(dev->parent->parent);\r\nif (!udev->parent) {\r\nstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\r\nint raw;\r\nraw = usb_hcd_find_raw_port_number(hcd, port1);\r\nadev = usb_acpi_find_port(ACPI_COMPANION(&udev->dev),\r\nraw);\r\nif (!adev)\r\nreturn NULL;\r\n} else {\r\nparent_handle =\r\nusb_get_hub_port_acpi_handle(udev->parent,\r\nudev->portnum);\r\nif (!parent_handle)\r\nreturn NULL;\r\nacpi_bus_get_device(parent_handle, &adev);\r\nadev = usb_acpi_find_port(adev, port1);\r\nif (!adev)\r\nreturn NULL;\r\n}\r\nhandle = adev->handle;\r\nstatus = acpi_get_physical_device_location(handle, &pld);\r\nif (ACPI_FAILURE(status) || !pld)\r\nreturn adev;\r\nport_dev->location = USB_ACPI_LOCATION_VALID\r\n| pld->group_token << 8 | pld->group_position;\r\nport_dev->connect_type = usb_acpi_get_connect_type(handle, pld);\r\nACPI_FREE(pld);\r\nreturn adev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool usb_acpi_bus_match(struct device *dev)\r\n{\r\nreturn is_usb_device(dev) || is_usb_port(dev);\r\n}\r\nint usb_acpi_register(void)\r\n{\r\nreturn register_acpi_bus_type(&usb_acpi_bus);\r\n}\r\nvoid usb_acpi_unregister(void)\r\n{\r\nunregister_acpi_bus_type(&usb_acpi_bus);\r\n}
