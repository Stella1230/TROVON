static void hi3110_clean(struct net_device *net)\r\n{\r\nstruct hi3110_priv *priv = netdev_priv(net);\r\nif (priv->tx_skb || priv->tx_len)\r\nnet->stats.tx_errors++;\r\nif (priv->tx_skb)\r\ndev_kfree_skb(priv->tx_skb);\r\nif (priv->tx_len)\r\ncan_free_echo_skb(priv->net, 0);\r\npriv->tx_skb = NULL;\r\npriv->tx_len = 0;\r\n}\r\nstatic int hi3110_spi_trans(struct spi_device *spi, int len)\r\n{\r\nstruct hi3110_priv *priv = spi_get_drvdata(spi);\r\nstruct spi_transfer t = {\r\n.tx_buf = priv->spi_tx_buf,\r\n.rx_buf = priv->spi_rx_buf,\r\n.len = len,\r\n.cs_change = 0,\r\n};\r\nstruct spi_message m;\r\nint ret;\r\nspi_message_init(&m);\r\nif (hi3110_enable_dma) {\r\nt.tx_dma = priv->spi_tx_dma;\r\nt.rx_dma = priv->spi_rx_dma;\r\nm.is_dma_mapped = 1;\r\n}\r\nspi_message_add_tail(&t, &m);\r\nret = spi_sync(spi, &m);\r\nif (ret)\r\ndev_err(&spi->dev, "spi transfer failed: ret = %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic u8 hi3110_cmd(struct spi_device *spi, u8 command)\r\n{\r\nstruct hi3110_priv *priv = spi_get_drvdata(spi);\r\npriv->spi_tx_buf[0] = command;\r\ndev_dbg(&spi->dev, "hi3110_cmd: %02X\n", command);\r\nreturn hi3110_spi_trans(spi, 1);\r\n}\r\nstatic u8 hi3110_read(struct spi_device *spi, u8 command)\r\n{\r\nstruct hi3110_priv *priv = spi_get_drvdata(spi);\r\nu8 val = 0;\r\npriv->spi_tx_buf[0] = command;\r\nhi3110_spi_trans(spi, 2);\r\nval = priv->spi_rx_buf[1];\r\nreturn val;\r\n}\r\nstatic void hi3110_write(struct spi_device *spi, u8 reg, u8 val)\r\n{\r\nstruct hi3110_priv *priv = spi_get_drvdata(spi);\r\npriv->spi_tx_buf[0] = reg;\r\npriv->spi_tx_buf[1] = val;\r\nhi3110_spi_trans(spi, 2);\r\n}\r\nstatic void hi3110_hw_tx_frame(struct spi_device *spi, u8 *buf, int len)\r\n{\r\nstruct hi3110_priv *priv = spi_get_drvdata(spi);\r\npriv->spi_tx_buf[0] = HI3110_WRITE_FIFO;\r\nmemcpy(priv->spi_tx_buf + 1, buf, len);\r\nhi3110_spi_trans(spi, len + 1);\r\n}\r\nstatic void hi3110_hw_tx(struct spi_device *spi, struct can_frame *frame)\r\n{\r\nu8 buf[HI3110_TX_EXT_BUF_LEN];\r\nbuf[HI3110_FIFO_TAG_OFF] = 0;\r\nif (frame->can_id & CAN_EFF_FLAG) {\r\nbuf[HI3110_FIFO_ID_OFF] = (frame->can_id & CAN_EFF_MASK) >> 21;\r\nbuf[HI3110_FIFO_ID_OFF + 1] =\r\n(((frame->can_id & CAN_EFF_MASK) >> 13) & 0xe0) |\r\nHI3110_EFF_FLAGS |\r\n(((frame->can_id & CAN_EFF_MASK) >> 15) & 0x07);\r\nbuf[HI3110_FIFO_ID_OFF + 2] =\r\n(frame->can_id & CAN_EFF_MASK) >> 7;\r\nbuf[HI3110_FIFO_ID_OFF + 3] =\r\n((frame->can_id & CAN_EFF_MASK) << 1) |\r\n((frame->can_id & CAN_RTR_FLAG) ? 1 : 0);\r\nbuf[HI3110_FIFO_EXT_DLC_OFF] = frame->can_dlc;\r\nmemcpy(buf + HI3110_FIFO_EXT_DATA_OFF,\r\nframe->data, frame->can_dlc);\r\nhi3110_hw_tx_frame(spi, buf, HI3110_TX_EXT_BUF_LEN -\r\n(HI3110_CAN_MAX_DATA_LEN - frame->can_dlc));\r\n} else {\r\nbuf[HI3110_FIFO_ID_OFF] = (frame->can_id & CAN_SFF_MASK) >> 3;\r\nbuf[HI3110_FIFO_ID_OFF + 1] =\r\n((frame->can_id & CAN_SFF_MASK) << 5) |\r\n((frame->can_id & CAN_RTR_FLAG) ? (1 << 4) : 0);\r\nbuf[HI3110_FIFO_STD_DLC_OFF] = frame->can_dlc;\r\nmemcpy(buf + HI3110_FIFO_STD_DATA_OFF,\r\nframe->data, frame->can_dlc);\r\nhi3110_hw_tx_frame(spi, buf, HI3110_TX_STD_BUF_LEN -\r\n(HI3110_CAN_MAX_DATA_LEN - frame->can_dlc));\r\n}\r\n}\r\nstatic void hi3110_hw_rx_frame(struct spi_device *spi, u8 *buf)\r\n{\r\nstruct hi3110_priv *priv = spi_get_drvdata(spi);\r\npriv->spi_tx_buf[0] = HI3110_READ_FIFO_WOTIME;\r\nhi3110_spi_trans(spi, HI3110_RX_BUF_LEN);\r\nmemcpy(buf, priv->spi_rx_buf + 1, HI3110_RX_BUF_LEN - 1);\r\n}\r\nstatic void hi3110_hw_rx(struct spi_device *spi)\r\n{\r\nstruct hi3110_priv *priv = spi_get_drvdata(spi);\r\nstruct sk_buff *skb;\r\nstruct can_frame *frame;\r\nu8 buf[HI3110_RX_BUF_LEN - 1];\r\nskb = alloc_can_skb(priv->net, &frame);\r\nif (!skb) {\r\npriv->net->stats.rx_dropped++;\r\nreturn;\r\n}\r\nhi3110_hw_rx_frame(spi, buf);\r\nif (buf[HI3110_FIFO_WOTIME_TAG_OFF] & HI3110_FIFO_WOTIME_TAG_IDE) {\r\nframe->can_id = CAN_EFF_FLAG;\r\nframe->can_id |=\r\n(buf[HI3110_FIFO_WOTIME_ID_OFF] << 21) |\r\n(((buf[HI3110_FIFO_WOTIME_ID_OFF + 1] & 0xE0) >> 5) << 18) |\r\n((buf[HI3110_FIFO_WOTIME_ID_OFF + 1] & 0x07) << 15) |\r\n(buf[HI3110_FIFO_WOTIME_ID_OFF + 2] << 7) |\r\n(buf[HI3110_FIFO_WOTIME_ID_OFF + 3] >> 1);\r\n} else {\r\nframe->can_id =\r\n(buf[HI3110_FIFO_WOTIME_ID_OFF] << 3) |\r\n((buf[HI3110_FIFO_WOTIME_ID_OFF + 1] & 0xE0) >> 5);\r\n}\r\nframe->can_dlc = get_can_dlc(buf[HI3110_FIFO_WOTIME_DLC_OFF] & 0x0F);\r\nif (buf[HI3110_FIFO_WOTIME_ID_OFF + 3] & HI3110_FIFO_WOTIME_ID_RTR)\r\nframe->can_id |= CAN_RTR_FLAG;\r\nelse\r\nmemcpy(frame->data, buf + HI3110_FIFO_WOTIME_DAT_OFF,\r\nframe->can_dlc);\r\npriv->net->stats.rx_packets++;\r\npriv->net->stats.rx_bytes += frame->can_dlc;\r\ncan_led_event(priv->net, CAN_LED_EVENT_RX);\r\nnetif_rx_ni(skb);\r\n}\r\nstatic void hi3110_hw_sleep(struct spi_device *spi)\r\n{\r\nhi3110_write(spi, HI3110_WRITE_CTRL0, HI3110_CTRL0_SLEEP_MODE);\r\n}\r\nstatic netdev_tx_t hi3110_hard_start_xmit(struct sk_buff *skb,\r\nstruct net_device *net)\r\n{\r\nstruct hi3110_priv *priv = netdev_priv(net);\r\nstruct spi_device *spi = priv->spi;\r\nif (priv->tx_skb || priv->tx_len) {\r\ndev_err(&spi->dev, "hard_xmit called while tx busy\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (can_dropped_invalid_skb(net, skb))\r\nreturn NETDEV_TX_OK;\r\nnetif_stop_queue(net);\r\npriv->tx_skb = skb;\r\nqueue_work(priv->wq, &priv->tx_work);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int hi3110_do_set_mode(struct net_device *net, enum can_mode mode)\r\n{\r\nstruct hi3110_priv *priv = netdev_priv(net);\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nhi3110_clean(net);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\npriv->restart_tx = 1;\r\nif (priv->can.restart_ms == 0)\r\npriv->after_suspend = HI3110_AFTER_SUSPEND_RESTART;\r\nqueue_work(priv->wq, &priv->restart_work);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hi3110_get_berr_counter(const struct net_device *net,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct hi3110_priv *priv = netdev_priv(net);\r\nstruct spi_device *spi = priv->spi;\r\nbec->txerr = hi3110_read(spi, HI3110_READ_TEC);\r\nbec->rxerr = hi3110_read(spi, HI3110_READ_REC);\r\nreturn 0;\r\n}\r\nstatic int hi3110_set_normal_mode(struct spi_device *spi)\r\n{\r\nstruct hi3110_priv *priv = spi_get_drvdata(spi);\r\nu8 reg = 0;\r\nhi3110_write(spi, HI3110_WRITE_INTE, HI3110_INT_BUSERR |\r\nHI3110_INT_RXFIFO | HI3110_INT_TXCPLT);\r\nhi3110_write(spi, HI3110_WRITE_CTRL1, HI3110_CTRL1_TXEN);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\r\nreg = HI3110_CTRL0_LOOPBACK_MODE;\r\nelse if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\r\nreg = HI3110_CTRL0_MONITOR_MODE;\r\nelse\r\nreg = HI3110_CTRL0_NORMAL_MODE;\r\nhi3110_write(spi, HI3110_WRITE_CTRL0, reg);\r\nmdelay(HI3110_OST_DELAY_MS);\r\nreg = hi3110_read(spi, HI3110_READ_CTRL0);\r\nif ((reg & HI3110_CTRL0_MODE_MASK) != reg)\r\nreturn -EBUSY;\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic int hi3110_do_set_bittiming(struct net_device *net)\r\n{\r\nstruct hi3110_priv *priv = netdev_priv(net);\r\nstruct can_bittiming *bt = &priv->can.bittiming;\r\nstruct spi_device *spi = priv->spi;\r\nhi3110_write(spi, HI3110_WRITE_BTR0,\r\n((bt->sjw - 1) << HI3110_BTR0_SJW_SHIFT) |\r\n((bt->brp - 1) << HI3110_BTR0_BRP_SHIFT));\r\nhi3110_write(spi, HI3110_WRITE_BTR1,\r\n(priv->can.ctrlmode &\r\nCAN_CTRLMODE_3_SAMPLES ?\r\nHI3110_BTR1_SAMP_3PERBIT : HI3110_BTR1_SAMP_1PERBIT) |\r\n((bt->phase_seg1 + bt->prop_seg - 1)\r\n<< HI3110_BTR1_TSEG1_SHIFT) |\r\n((bt->phase_seg2 - 1) << HI3110_BTR1_TSEG2_SHIFT));\r\ndev_dbg(&spi->dev, "BT: 0x%02x 0x%02x\n",\r\nhi3110_read(spi, HI3110_READ_BTR0),\r\nhi3110_read(spi, HI3110_READ_BTR1));\r\nreturn 0;\r\n}\r\nstatic int hi3110_setup(struct net_device *net)\r\n{\r\nhi3110_do_set_bittiming(net);\r\nreturn 0;\r\n}\r\nstatic int hi3110_hw_reset(struct spi_device *spi)\r\n{\r\nu8 reg;\r\nint ret;\r\nmdelay(HI3110_OST_DELAY_MS);\r\nret = hi3110_cmd(spi, HI3110_MASTER_RESET);\r\nif (ret)\r\nreturn ret;\r\nmdelay(HI3110_OST_DELAY_MS);\r\nreg = hi3110_read(spi, HI3110_READ_CTRL0);\r\nif ((reg & HI3110_CTRL0_MODE_MASK) != HI3110_CTRL0_INIT_MODE)\r\nreturn -ENODEV;\r\nhi3110_read(spi, HI3110_READ_ERR);\r\nreturn 0;\r\n}\r\nstatic int hi3110_hw_probe(struct spi_device *spi)\r\n{\r\nu8 statf;\r\nhi3110_hw_reset(spi);\r\nstatf = hi3110_read(spi, HI3110_READ_STATF);\r\ndev_dbg(&spi->dev, "statf: %02X\n", statf);\r\nif (statf != 0x82)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int hi3110_power_enable(struct regulator *reg, int enable)\r\n{\r\nif (IS_ERR_OR_NULL(reg))\r\nreturn 0;\r\nif (enable)\r\nreturn regulator_enable(reg);\r\nelse\r\nreturn regulator_disable(reg);\r\n}\r\nstatic int hi3110_stop(struct net_device *net)\r\n{\r\nstruct hi3110_priv *priv = netdev_priv(net);\r\nstruct spi_device *spi = priv->spi;\r\nclose_candev(net);\r\npriv->force_quit = 1;\r\nfree_irq(spi->irq, priv);\r\ndestroy_workqueue(priv->wq);\r\npriv->wq = NULL;\r\nmutex_lock(&priv->hi3110_lock);\r\nhi3110_write(spi, HI3110_WRITE_CTRL1, 0x0);\r\nhi3110_write(spi, HI3110_WRITE_INTE, 0x0);\r\nhi3110_read(spi, HI3110_READ_INTF);\r\nhi3110_clean(net);\r\nhi3110_hw_sleep(spi);\r\nhi3110_power_enable(priv->transceiver, 0);\r\npriv->can.state = CAN_STATE_STOPPED;\r\nmutex_unlock(&priv->hi3110_lock);\r\ncan_led_event(net, CAN_LED_EVENT_STOP);\r\nreturn 0;\r\n}\r\nstatic void hi3110_tx_work_handler(struct work_struct *ws)\r\n{\r\nstruct hi3110_priv *priv = container_of(ws, struct hi3110_priv,\r\ntx_work);\r\nstruct spi_device *spi = priv->spi;\r\nstruct net_device *net = priv->net;\r\nstruct can_frame *frame;\r\nmutex_lock(&priv->hi3110_lock);\r\nif (priv->tx_skb) {\r\nif (priv->can.state == CAN_STATE_BUS_OFF) {\r\nhi3110_clean(net);\r\n} else {\r\nframe = (struct can_frame *)priv->tx_skb->data;\r\nhi3110_hw_tx(spi, frame);\r\npriv->tx_len = 1 + frame->can_dlc;\r\ncan_put_echo_skb(priv->tx_skb, net, 0);\r\npriv->tx_skb = NULL;\r\n}\r\n}\r\nmutex_unlock(&priv->hi3110_lock);\r\n}\r\nstatic void hi3110_restart_work_handler(struct work_struct *ws)\r\n{\r\nstruct hi3110_priv *priv = container_of(ws, struct hi3110_priv,\r\nrestart_work);\r\nstruct spi_device *spi = priv->spi;\r\nstruct net_device *net = priv->net;\r\nmutex_lock(&priv->hi3110_lock);\r\nif (priv->after_suspend) {\r\nhi3110_hw_reset(spi);\r\nhi3110_setup(net);\r\nif (priv->after_suspend & HI3110_AFTER_SUSPEND_RESTART) {\r\nhi3110_set_normal_mode(spi);\r\n} else if (priv->after_suspend & HI3110_AFTER_SUSPEND_UP) {\r\nnetif_device_attach(net);\r\nhi3110_clean(net);\r\nhi3110_set_normal_mode(spi);\r\nnetif_wake_queue(net);\r\n} else {\r\nhi3110_hw_sleep(spi);\r\n}\r\npriv->after_suspend = 0;\r\npriv->force_quit = 0;\r\n}\r\nif (priv->restart_tx) {\r\npriv->restart_tx = 0;\r\nhi3110_hw_reset(spi);\r\nhi3110_setup(net);\r\nhi3110_clean(net);\r\nhi3110_set_normal_mode(spi);\r\nnetif_wake_queue(net);\r\n}\r\nmutex_unlock(&priv->hi3110_lock);\r\n}\r\nstatic irqreturn_t hi3110_can_ist(int irq, void *dev_id)\r\n{\r\nstruct hi3110_priv *priv = dev_id;\r\nstruct spi_device *spi = priv->spi;\r\nstruct net_device *net = priv->net;\r\nmutex_lock(&priv->hi3110_lock);\r\nwhile (!priv->force_quit) {\r\nenum can_state new_state;\r\nu8 intf, eflag, statf;\r\nwhile (!(HI3110_STAT_RXFMTY &\r\n(statf = hi3110_read(spi, HI3110_READ_STATF)))) {\r\nhi3110_hw_rx(spi);\r\n}\r\nintf = hi3110_read(spi, HI3110_READ_INTF);\r\neflag = hi3110_read(spi, HI3110_READ_ERR);\r\nif (eflag & HI3110_ERR_BUSOFF)\r\nnew_state = CAN_STATE_BUS_OFF;\r\nelse if (eflag & HI3110_ERR_PASSIVE_MASK)\r\nnew_state = CAN_STATE_ERROR_PASSIVE;\r\nelse if (statf & HI3110_STAT_ERRW)\r\nnew_state = CAN_STATE_ERROR_WARNING;\r\nelse\r\nnew_state = CAN_STATE_ERROR_ACTIVE;\r\nif (new_state != priv->can.state) {\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nenum can_state rx_state, tx_state;\r\nu8 rxerr, txerr;\r\nskb = alloc_can_err_skb(net, &cf);\r\nif (!skb)\r\nbreak;\r\ntxerr = hi3110_read(spi, HI3110_READ_TEC);\r\nrxerr = hi3110_read(spi, HI3110_READ_REC);\r\ncf->data[6] = txerr;\r\ncf->data[7] = rxerr;\r\ntx_state = txerr >= rxerr ? new_state : 0;\r\nrx_state = txerr <= rxerr ? new_state : 0;\r\ncan_change_state(net, cf, tx_state, rx_state);\r\nnetif_rx_ni(skb);\r\nif (new_state == CAN_STATE_BUS_OFF) {\r\ncan_bus_off(net);\r\nif (priv->can.restart_ms == 0) {\r\npriv->force_quit = 1;\r\nhi3110_hw_sleep(spi);\r\nbreak;\r\n}\r\n}\r\n}\r\nif ((intf & HI3110_INT_BUSERR) &&\r\n(priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)) {\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nif (eflag & HI3110_ERR_PROTOCOL_MASK) {\r\nskb = alloc_can_err_skb(net, &cf);\r\nif (!skb)\r\nbreak;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\npriv->can.can_stats.bus_error++;\r\npriv->net->stats.rx_errors++;\r\nif (eflag & HI3110_ERR_BITERR)\r\ncf->data[2] |= CAN_ERR_PROT_BIT;\r\nelse if (eflag & HI3110_ERR_FRMERR)\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nelse if (eflag & HI3110_ERR_STUFERR)\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nelse if (eflag & HI3110_ERR_CRCERR)\r\ncf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;\r\nelse if (eflag & HI3110_ERR_ACKERR)\r\ncf->data[3] |= CAN_ERR_PROT_LOC_ACK;\r\ncf->data[6] = hi3110_read(spi, HI3110_READ_TEC);\r\ncf->data[7] = hi3110_read(spi, HI3110_READ_REC);\r\nnetdev_dbg(priv->net, "Bus Error\n");\r\nnetif_rx_ni(skb);\r\n}\r\n}\r\nif (intf == 0)\r\nbreak;\r\nif (intf & HI3110_INT_TXCPLT) {\r\nnet->stats.tx_packets++;\r\nnet->stats.tx_bytes += priv->tx_len - 1;\r\ncan_led_event(net, CAN_LED_EVENT_TX);\r\nif (priv->tx_len) {\r\ncan_get_echo_skb(net, 0);\r\npriv->tx_len = 0;\r\n}\r\nnetif_wake_queue(net);\r\n}\r\n}\r\nmutex_unlock(&priv->hi3110_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int hi3110_open(struct net_device *net)\r\n{\r\nstruct hi3110_priv *priv = netdev_priv(net);\r\nstruct spi_device *spi = priv->spi;\r\nunsigned long flags = IRQF_ONESHOT | IRQF_TRIGGER_RISING;\r\nint ret;\r\nret = open_candev(net);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&priv->hi3110_lock);\r\nhi3110_power_enable(priv->transceiver, 1);\r\npriv->force_quit = 0;\r\npriv->tx_skb = NULL;\r\npriv->tx_len = 0;\r\nret = request_threaded_irq(spi->irq, NULL, hi3110_can_ist,\r\nflags, DEVICE_NAME, priv);\r\nif (ret) {\r\ndev_err(&spi->dev, "failed to acquire irq %d\n", spi->irq);\r\ngoto out_close;\r\n}\r\npriv->wq = alloc_workqueue("hi3110_wq", WQ_FREEZABLE | WQ_MEM_RECLAIM,\r\n0);\r\nif (!priv->wq) {\r\nret = -ENOMEM;\r\ngoto out_free_irq;\r\n}\r\nINIT_WORK(&priv->tx_work, hi3110_tx_work_handler);\r\nINIT_WORK(&priv->restart_work, hi3110_restart_work_handler);\r\nret = hi3110_hw_reset(spi);\r\nif (ret)\r\ngoto out_free_wq;\r\nret = hi3110_setup(net);\r\nif (ret)\r\ngoto out_free_wq;\r\nret = hi3110_set_normal_mode(spi);\r\nif (ret)\r\ngoto out_free_wq;\r\ncan_led_event(net, CAN_LED_EVENT_OPEN);\r\nnetif_wake_queue(net);\r\nmutex_unlock(&priv->hi3110_lock);\r\nreturn 0;\r\nout_free_wq:\r\ndestroy_workqueue(priv->wq);\r\nout_free_irq:\r\nfree_irq(spi->irq, priv);\r\nhi3110_hw_sleep(spi);\r\nout_close:\r\nhi3110_power_enable(priv->transceiver, 0);\r\nclose_candev(net);\r\nmutex_unlock(&priv->hi3110_lock);\r\nreturn ret;\r\n}\r\nstatic int hi3110_can_probe(struct spi_device *spi)\r\n{\r\nconst struct of_device_id *of_id = of_match_device(hi3110_of_match,\r\n&spi->dev);\r\nstruct net_device *net;\r\nstruct hi3110_priv *priv;\r\nstruct clk *clk;\r\nint freq, ret;\r\nclk = devm_clk_get(&spi->dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(&spi->dev, "no CAN clock source defined\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nfreq = clk_get_rate(clk);\r\nif (freq > 40000000)\r\nreturn -ERANGE;\r\nnet = alloc_candev(sizeof(struct hi3110_priv), HI3110_TX_ECHO_SKB_MAX);\r\nif (!net)\r\nreturn -ENOMEM;\r\nif (!IS_ERR(clk)) {\r\nret = clk_prepare_enable(clk);\r\nif (ret)\r\ngoto out_free;\r\n}\r\nnet->netdev_ops = &hi3110_netdev_ops;\r\nnet->flags |= IFF_ECHO;\r\npriv = netdev_priv(net);\r\npriv->can.bittiming_const = &hi3110_bittiming_const;\r\npriv->can.do_set_mode = hi3110_do_set_mode;\r\npriv->can.do_get_berr_counter = hi3110_get_berr_counter;\r\npriv->can.clock.freq = freq / 2;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES |\r\nCAN_CTRLMODE_LOOPBACK |\r\nCAN_CTRLMODE_LISTENONLY |\r\nCAN_CTRLMODE_BERR_REPORTING;\r\nif (of_id)\r\npriv->model = (enum hi3110_model)of_id->data;\r\nelse\r\npriv->model = spi_get_device_id(spi)->driver_data;\r\npriv->net = net;\r\npriv->clk = clk;\r\nspi_set_drvdata(spi, priv);\r\nspi->bits_per_word = 8;\r\nret = spi_setup(spi);\r\nif (ret)\r\ngoto out_clk;\r\npriv->power = devm_regulator_get_optional(&spi->dev, "vdd");\r\npriv->transceiver = devm_regulator_get_optional(&spi->dev, "xceiver");\r\nif ((PTR_ERR(priv->power) == -EPROBE_DEFER) ||\r\n(PTR_ERR(priv->transceiver) == -EPROBE_DEFER)) {\r\nret = -EPROBE_DEFER;\r\ngoto out_clk;\r\n}\r\nret = hi3110_power_enable(priv->power, 1);\r\nif (ret)\r\ngoto out_clk;\r\npriv->spi = spi;\r\nmutex_init(&priv->hi3110_lock);\r\nif (hi3110_enable_dma) {\r\nspi->dev.coherent_dma_mask = ~0;\r\npriv->spi_tx_buf = dmam_alloc_coherent(&spi->dev,\r\nPAGE_SIZE,\r\n&priv->spi_tx_dma,\r\nGFP_DMA);\r\nif (priv->spi_tx_buf) {\r\npriv->spi_rx_buf = (priv->spi_tx_buf + (PAGE_SIZE / 2));\r\npriv->spi_rx_dma = (dma_addr_t)(priv->spi_tx_dma +\r\n(PAGE_SIZE / 2));\r\n} else {\r\nhi3110_enable_dma = 0;\r\n}\r\n}\r\nif (!hi3110_enable_dma) {\r\npriv->spi_tx_buf = devm_kzalloc(&spi->dev, HI3110_RX_BUF_LEN,\r\nGFP_KERNEL);\r\nif (!priv->spi_tx_buf) {\r\nret = -ENOMEM;\r\ngoto error_probe;\r\n}\r\npriv->spi_rx_buf = devm_kzalloc(&spi->dev, HI3110_RX_BUF_LEN,\r\nGFP_KERNEL);\r\nif (!priv->spi_rx_buf) {\r\nret = -ENOMEM;\r\ngoto error_probe;\r\n}\r\n}\r\nSET_NETDEV_DEV(net, &spi->dev);\r\nret = hi3110_hw_probe(spi);\r\nif (ret) {\r\nif (ret == -ENODEV)\r\ndev_err(&spi->dev, "Cannot initialize %x. Wrong wiring?\n",\r\npriv->model);\r\ngoto error_probe;\r\n}\r\nhi3110_hw_sleep(spi);\r\nret = register_candev(net);\r\nif (ret)\r\ngoto error_probe;\r\ndevm_can_led_init(net);\r\nnetdev_info(net, "%x successfully initialized.\n", priv->model);\r\nreturn 0;\r\nerror_probe:\r\nhi3110_power_enable(priv->power, 0);\r\nout_clk:\r\nif (!IS_ERR(clk))\r\nclk_disable_unprepare(clk);\r\nout_free:\r\nfree_candev(net);\r\ndev_err(&spi->dev, "Probe failed, err=%d\n", -ret);\r\nreturn ret;\r\n}\r\nstatic int hi3110_can_remove(struct spi_device *spi)\r\n{\r\nstruct hi3110_priv *priv = spi_get_drvdata(spi);\r\nstruct net_device *net = priv->net;\r\nunregister_candev(net);\r\nhi3110_power_enable(priv->power, 0);\r\nif (!IS_ERR(priv->clk))\r\nclk_disable_unprepare(priv->clk);\r\nfree_candev(net);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused hi3110_can_suspend(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct hi3110_priv *priv = spi_get_drvdata(spi);\r\nstruct net_device *net = priv->net;\r\npriv->force_quit = 1;\r\ndisable_irq(spi->irq);\r\nif (netif_running(net)) {\r\nnetif_device_detach(net);\r\nhi3110_hw_sleep(spi);\r\nhi3110_power_enable(priv->transceiver, 0);\r\npriv->after_suspend = HI3110_AFTER_SUSPEND_UP;\r\n} else {\r\npriv->after_suspend = HI3110_AFTER_SUSPEND_DOWN;\r\n}\r\nif (!IS_ERR_OR_NULL(priv->power)) {\r\nregulator_disable(priv->power);\r\npriv->after_suspend |= HI3110_AFTER_SUSPEND_POWER;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused hi3110_can_resume(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct hi3110_priv *priv = spi_get_drvdata(spi);\r\nif (priv->after_suspend & HI3110_AFTER_SUSPEND_POWER)\r\nhi3110_power_enable(priv->power, 1);\r\nif (priv->after_suspend & HI3110_AFTER_SUSPEND_UP) {\r\nhi3110_power_enable(priv->transceiver, 1);\r\nqueue_work(priv->wq, &priv->restart_work);\r\n} else {\r\npriv->after_suspend = 0;\r\n}\r\npriv->force_quit = 0;\r\nenable_irq(spi->irq);\r\nreturn 0;\r\n}
