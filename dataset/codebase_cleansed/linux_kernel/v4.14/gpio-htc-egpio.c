static inline void egpio_writew(u16 value, struct egpio_info *ei, int reg)\r\n{\r\nwritew(value, ei->base_addr + (reg << ei->bus_shift));\r\n}\r\nstatic inline u16 egpio_readw(struct egpio_info *ei, int reg)\r\n{\r\nreturn readw(ei->base_addr + (reg << ei->bus_shift));\r\n}\r\nstatic inline void ack_irqs(struct egpio_info *ei)\r\n{\r\negpio_writew(ei->ack_write, ei, ei->ack_register);\r\npr_debug("EGPIO ack - write %x to base+%x\n",\r\nei->ack_write, ei->ack_register << ei->bus_shift);\r\n}\r\nstatic void egpio_ack(struct irq_data *data)\r\n{\r\n}\r\nstatic void egpio_mask(struct irq_data *data)\r\n{\r\nstruct egpio_info *ei = irq_data_get_irq_chip_data(data);\r\nei->irqs_enabled &= ~(1 << (data->irq - ei->irq_start));\r\npr_debug("EGPIO mask %d %04x\n", data->irq, ei->irqs_enabled);\r\n}\r\nstatic void egpio_unmask(struct irq_data *data)\r\n{\r\nstruct egpio_info *ei = irq_data_get_irq_chip_data(data);\r\nei->irqs_enabled |= 1 << (data->irq - ei->irq_start);\r\npr_debug("EGPIO unmask %d %04x\n", data->irq, ei->irqs_enabled);\r\n}\r\nstatic void egpio_handler(struct irq_desc *desc)\r\n{\r\nstruct egpio_info *ei = irq_desc_get_handler_data(desc);\r\nint irqpin;\r\nunsigned long readval = egpio_readw(ei, ei->ack_register);\r\npr_debug("IRQ reg: %x\n", (unsigned int)readval);\r\nack_irqs(ei);\r\nreadval &= ei->irqs_enabled;\r\nfor_each_set_bit(irqpin, &readval, ei->nirqs) {\r\npr_debug("got IRQ %d\n", irqpin);\r\ngeneric_handle_irq(ei->irq_start + irqpin);\r\n}\r\n}\r\nint htc_egpio_get_wakeup_irq(struct device *dev)\r\n{\r\nstruct egpio_info *ei = dev_get_drvdata(dev);\r\nu16 readval = egpio_readw(ei, ei->ack_register);\r\nack_irqs(ei);\r\nreadval &= ei->irqs_enabled;\r\nreturn ei->irq_start + ffs(readval) - 1;\r\n}\r\nstatic inline int egpio_pos(struct egpio_info *ei, int bit)\r\n{\r\nreturn bit >> ei->reg_shift;\r\n}\r\nstatic inline int egpio_bit(struct egpio_info *ei, int bit)\r\n{\r\nreturn 1 << (bit & ((1 << ei->reg_shift)-1));\r\n}\r\nstatic int egpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct egpio_chip *egpio;\r\nstruct egpio_info *ei;\r\nunsigned bit;\r\nint reg;\r\nint value;\r\npr_debug("egpio_get_value(%d)\n", chip->base + offset);\r\negpio = gpiochip_get_data(chip);\r\nei = dev_get_drvdata(egpio->dev);\r\nbit = egpio_bit(ei, offset);\r\nreg = egpio->reg_start + egpio_pos(ei, offset);\r\nif (test_bit(offset, &egpio->is_out)) {\r\nreturn !!(egpio->cached_values & (1 << offset));\r\n} else {\r\nvalue = egpio_readw(ei, reg);\r\npr_debug("readw(%p + %x) = %x\n",\r\nei->base_addr, reg << ei->bus_shift, value);\r\nreturn !!(value & bit);\r\n}\r\n}\r\nstatic int egpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct egpio_chip *egpio;\r\negpio = gpiochip_get_data(chip);\r\nreturn test_bit(offset, &egpio->is_out) ? -EINVAL : 0;\r\n}\r\nstatic void egpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nunsigned long flag;\r\nstruct egpio_chip *egpio;\r\nstruct egpio_info *ei;\r\nunsigned bit;\r\nint pos;\r\nint reg;\r\nint shift;\r\npr_debug("egpio_set(%s, %d(%d), %d)\n",\r\nchip->label, offset, offset+chip->base, value);\r\negpio = gpiochip_get_data(chip);\r\nei = dev_get_drvdata(egpio->dev);\r\nbit = egpio_bit(ei, offset);\r\npos = egpio_pos(ei, offset);\r\nreg = egpio->reg_start + pos;\r\nshift = pos << ei->reg_shift;\r\npr_debug("egpio %s: reg %d = 0x%04x\n", value ? "set" : "clear",\r\nreg, (egpio->cached_values >> shift) & ei->reg_mask);\r\nspin_lock_irqsave(&ei->lock, flag);\r\nif (value)\r\negpio->cached_values |= (1 << offset);\r\nelse\r\negpio->cached_values &= ~(1 << offset);\r\negpio_writew((egpio->cached_values >> shift) & ei->reg_mask, ei, reg);\r\nspin_unlock_irqrestore(&ei->lock, flag);\r\n}\r\nstatic int egpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct egpio_chip *egpio;\r\negpio = gpiochip_get_data(chip);\r\nif (test_bit(offset, &egpio->is_out)) {\r\negpio_set(chip, offset, value);\r\nreturn 0;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int egpio_get_direction(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct egpio_chip *egpio;\r\negpio = gpiochip_get_data(chip);\r\nreturn !test_bit(offset, &egpio->is_out);\r\n}\r\nstatic void egpio_write_cache(struct egpio_info *ei)\r\n{\r\nint i;\r\nstruct egpio_chip *egpio;\r\nint shift;\r\nfor (i = 0; i < ei->nchips; i++) {\r\negpio = &(ei->chip[i]);\r\nif (!egpio->is_out)\r\ncontinue;\r\nfor (shift = 0; shift < egpio->chip.ngpio;\r\nshift += (1<<ei->reg_shift)) {\r\nint reg = egpio->reg_start + egpio_pos(ei, shift);\r\nif (!((egpio->is_out >> shift) & ei->reg_mask))\r\ncontinue;\r\npr_debug("EGPIO: setting %x to %x, was %x\n", reg,\r\n(egpio->cached_values >> shift) & ei->reg_mask,\r\negpio_readw(ei, reg));\r\negpio_writew((egpio->cached_values >> shift)\r\n& ei->reg_mask, ei, reg);\r\n}\r\n}\r\n}\r\nstatic int __init egpio_probe(struct platform_device *pdev)\r\n{\r\nstruct htc_egpio_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct resource *res;\r\nstruct egpio_info *ei;\r\nstruct gpio_chip *chip;\r\nunsigned int irq, irq_end;\r\nint i;\r\nint ret;\r\nei = devm_kzalloc(&pdev->dev, sizeof(*ei), GFP_KERNEL);\r\nif (!ei)\r\nreturn -ENOMEM;\r\nspin_lock_init(&ei->lock);\r\nret = -EINVAL;\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res)\r\nei->chained_irq = res->start;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\ngoto fail;\r\nei->base_addr = devm_ioremap_nocache(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!ei->base_addr)\r\ngoto fail;\r\npr_debug("EGPIO phys=%08x virt=%p\n", (u32)res->start, ei->base_addr);\r\nif ((pdata->bus_width != 16) && (pdata->bus_width != 32))\r\ngoto fail;\r\nei->bus_shift = fls(pdata->bus_width - 1) - 3;\r\npr_debug("bus_shift = %d\n", ei->bus_shift);\r\nif ((pdata->reg_width != 8) && (pdata->reg_width != 16))\r\ngoto fail;\r\nei->reg_shift = fls(pdata->reg_width - 1);\r\npr_debug("reg_shift = %d\n", ei->reg_shift);\r\nei->reg_mask = (1 << pdata->reg_width) - 1;\r\nplatform_set_drvdata(pdev, ei);\r\nei->nchips = pdata->num_chips;\r\nei->chip = devm_kzalloc(&pdev->dev,\r\nsizeof(struct egpio_chip) * ei->nchips,\r\nGFP_KERNEL);\r\nif (!ei->chip) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nfor (i = 0; i < ei->nchips; i++) {\r\nei->chip[i].reg_start = pdata->chip[i].reg_start;\r\nei->chip[i].cached_values = pdata->chip[i].initial_values;\r\nei->chip[i].is_out = pdata->chip[i].direction;\r\nei->chip[i].dev = &(pdev->dev);\r\nchip = &(ei->chip[i].chip);\r\nchip->label = "htc-egpio";\r\nchip->parent = &pdev->dev;\r\nchip->owner = THIS_MODULE;\r\nchip->get = egpio_get;\r\nchip->set = egpio_set;\r\nchip->direction_input = egpio_direction_input;\r\nchip->direction_output = egpio_direction_output;\r\nchip->get_direction = egpio_get_direction;\r\nchip->base = pdata->chip[i].gpio_base;\r\nchip->ngpio = pdata->chip[i].num_gpios;\r\ngpiochip_add_data(chip, &ei->chip[i]);\r\n}\r\negpio_write_cache(ei);\r\nei->irq_start = pdata->irq_base;\r\nei->nirqs = pdata->num_irqs;\r\nei->ack_register = pdata->ack_register;\r\nif (ei->chained_irq) {\r\nei->ack_write = 0xFFFF;\r\nif (pdata->invert_acks)\r\nei->ack_write = 0;\r\nirq_end = ei->irq_start + ei->nirqs;\r\nfor (irq = ei->irq_start; irq < irq_end; irq++) {\r\nirq_set_chip_and_handler(irq, &egpio_muxed_chip,\r\nhandle_simple_irq);\r\nirq_set_chip_data(irq, ei);\r\nirq_clear_status_flags(irq, IRQ_NOREQUEST | IRQ_NOPROBE);\r\n}\r\nirq_set_irq_type(ei->chained_irq, IRQ_TYPE_EDGE_RISING);\r\nirq_set_chained_handler_and_data(ei->chained_irq,\r\negpio_handler, ei);\r\nack_irqs(ei);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\n}\r\nreturn 0;\r\nfail:\r\nprintk(KERN_ERR "EGPIO failed to setup\n");\r\nreturn ret;\r\n}\r\nstatic int egpio_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct egpio_info *ei = platform_get_drvdata(pdev);\r\nif (ei->chained_irq && device_may_wakeup(&pdev->dev))\r\nenable_irq_wake(ei->chained_irq);\r\nreturn 0;\r\n}\r\nstatic int egpio_resume(struct platform_device *pdev)\r\n{\r\nstruct egpio_info *ei = platform_get_drvdata(pdev);\r\nif (ei->chained_irq && device_may_wakeup(&pdev->dev))\r\ndisable_irq_wake(ei->chained_irq);\r\negpio_write_cache(ei);\r\nreturn 0;\r\n}\r\nstatic int __init egpio_init(void)\r\n{\r\nreturn platform_driver_probe(&egpio_driver, egpio_probe);\r\n}
