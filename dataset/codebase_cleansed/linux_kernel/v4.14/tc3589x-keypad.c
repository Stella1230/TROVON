static int tc3589x_keypad_init_key_hardware(struct tc_keypad *keypad)\r\n{\r\nint ret;\r\nstruct tc3589x *tc3589x = keypad->tc3589x;\r\nconst struct tc3589x_keypad_platform_data *board = keypad->board;\r\nif (board->kcol > TC3589x_MAX_KPCOL || board->krow > TC3589x_MAX_KPROW)\r\nreturn -EINVAL;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_KBDSIZE,\r\n(board->krow << KP_ROW_SHIFT) | board->kcol);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_KBCFG_LSB, DEDICATED_KEY_VAL);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_KBCFG_MSB, DEDICATED_KEY_VAL);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_KBDSETTLE_REG,\r\nboard->settle_time);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_KBDBOUNCE,\r\nboard->debounce_period);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_IOCFG, 0x0, IOCFG_IG);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_IOPULLCFG0_LSB,\r\nTC3589x_PULLUP_ALL_MASK);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_IOPULLCFG0_MSB,\r\nTC3589x_PULLUP_ALL_MASK);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_IOPULLCFG1_LSB,\r\nTC3589x_PULLUP_ALL_MASK);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_IOPULLCFG1_MSB,\r\nTC3589x_PULLUP_ALL_MASK);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_IOPULLCFG2_LSB,\r\nTC3589x_PULLUP_ALL_MASK);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t tc3589x_keypad_irq(int irq, void *dev)\r\n{\r\nstruct tc_keypad *keypad = dev;\r\nstruct tc3589x *tc3589x = keypad->tc3589x;\r\nu8 i, row_index, col_index, kbd_code, up;\r\nu8 code;\r\nfor (i = 0; i < TC35893_DATA_REGS * 2; i++) {\r\nkbd_code = tc3589x_reg_read(tc3589x, TC3589x_EVTCODE_FIFO);\r\nif (kbd_code == TC35893_KEYCODE_FIFO_EMPTY ||\r\nkbd_code == TC35893_KEYCODE_FIFO_CLEAR)\r\ncontinue;\r\ncol_index = kbd_code & KP_EVCODE_COL_MASK;\r\nrow_index = (kbd_code & KP_EVCODE_ROW_MASK) >> KP_ROW_SHIFT;\r\ncode = MATRIX_SCAN_CODE(row_index, col_index,\r\nTC35893_KEYPAD_ROW_SHIFT);\r\nup = kbd_code & KP_RELEASE_EVT_MASK;\r\ninput_event(keypad->input, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(keypad->input, keypad->keymap[code], !up);\r\ninput_sync(keypad->input);\r\n}\r\ntc3589x_set_bits(tc3589x, TC3589x_KBDIC,\r\n0x0, TC3589x_EVT_INT_CLR | TC3589x_KBD_INT_CLR);\r\ntc3589x_set_bits(tc3589x, TC3589x_KBDMSK,\r\n0x0, TC3589x_EVT_LOSS_INT | TC3589x_EVT_INT);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tc3589x_keypad_enable(struct tc_keypad *keypad)\r\n{\r\nstruct tc3589x *tc3589x = keypad->tc3589x;\r\nint ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_RSTCTRL, TC3589x_KBDRST, 0x0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_KBDMFS, 0x0, TC3589x_KBDMFS_EN);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_CLKEN, 0x0, KPD_CLK_EN);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_RSTINTCLR, 0x0, 0x1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_KBDMSK, 0x0,\r\nTC3589x_EVT_LOSS_INT | TC3589x_EVT_INT);\r\nif (ret < 0)\r\nreturn ret;\r\nkeypad->keypad_stopped = false;\r\nreturn ret;\r\n}\r\nstatic int tc3589x_keypad_disable(struct tc_keypad *keypad)\r\n{\r\nstruct tc3589x *tc3589x = keypad->tc3589x;\r\nint ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_KBDIC,\r\n0x0, TC3589x_EVT_INT_CLR | TC3589x_KBD_INT_CLR);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_KBDMSK,\r\n~(TC3589x_EVT_LOSS_INT | TC3589x_EVT_INT), 0x0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_CLKEN, 0x1, 0x0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_RSTCTRL, TC3589x_KBDRST, 0x1);\r\nkeypad->keypad_stopped = true;\r\nreturn ret;\r\n}\r\nstatic int tc3589x_keypad_open(struct input_dev *input)\r\n{\r\nint error;\r\nstruct tc_keypad *keypad = input_get_drvdata(input);\r\nerror = tc3589x_keypad_enable(keypad);\r\nif (error < 0) {\r\ndev_err(&input->dev, "failed to enable keypad module\n");\r\nreturn error;\r\n}\r\nerror = tc3589x_keypad_init_key_hardware(keypad);\r\nif (error < 0) {\r\ndev_err(&input->dev, "failed to configure keypad module\n");\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tc3589x_keypad_close(struct input_dev *input)\r\n{\r\nstruct tc_keypad *keypad = input_get_drvdata(input);\r\ntc3589x_keypad_disable(keypad);\r\n}\r\nstatic const struct tc3589x_keypad_platform_data *\r\ntc3589x_keypad_of_probe(struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct tc3589x_keypad_platform_data *plat;\r\nu32 cols, rows;\r\nu32 debounce_ms;\r\nint proplen;\r\nif (!np)\r\nreturn ERR_PTR(-ENODEV);\r\nplat = devm_kzalloc(dev, sizeof(*plat), GFP_KERNEL);\r\nif (!plat)\r\nreturn ERR_PTR(-ENOMEM);\r\nof_property_read_u32(np, "keypad,num-columns", &cols);\r\nof_property_read_u32(np, "keypad,num-rows", &rows);\r\nplat->kcol = (u8) cols;\r\nplat->krow = (u8) rows;\r\nif (!plat->krow || !plat->kcol ||\r\nplat->krow > TC_KPD_ROWS || plat->kcol > TC_KPD_COLUMNS) {\r\ndev_err(dev,\r\n"keypad columns/rows not properly specified (%ux%u)\n",\r\nplat->kcol, plat->krow);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!of_get_property(np, "linux,keymap", &proplen)) {\r\ndev_err(dev, "property linux,keymap not found\n");\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nplat->no_autorepeat = of_property_read_bool(np, "linux,no-autorepeat");\r\nplat->enable_wakeup = of_property_read_bool(np, "wakeup-source") ||\r\nof_property_read_bool(np, "linux,wakeup");\r\nof_property_read_u32(np, "debounce-delay-ms", &debounce_ms);\r\nif (debounce_ms)\r\nplat->debounce_period = debounce_ms * 16;\r\nelse\r\nplat->debounce_period = TC_KPD_DEBOUNCE_PERIOD;\r\nplat->settle_time = TC_KPD_SETTLE_TIME;\r\nplat->irqtype = IRQF_TRIGGER_FALLING;\r\nreturn plat;\r\n}\r\nstatic int tc3589x_keypad_probe(struct platform_device *pdev)\r\n{\r\nstruct tc3589x *tc3589x = dev_get_drvdata(pdev->dev.parent);\r\nstruct tc_keypad *keypad;\r\nstruct input_dev *input;\r\nconst struct tc3589x_keypad_platform_data *plat;\r\nint error, irq;\r\nplat = tc3589x_keypad_of_probe(&pdev->dev);\r\nif (IS_ERR(plat)) {\r\ndev_err(&pdev->dev, "invalid keypad platform data\n");\r\nreturn PTR_ERR(plat);\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nkeypad = devm_kzalloc(&pdev->dev, sizeof(struct tc_keypad),\r\nGFP_KERNEL);\r\nif (!keypad)\r\nreturn -ENOMEM;\r\ninput = devm_input_allocate_device(&pdev->dev);\r\nif (!input) {\r\ndev_err(&pdev->dev, "failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nkeypad->board = plat;\r\nkeypad->input = input;\r\nkeypad->tc3589x = tc3589x;\r\ninput->id.bustype = BUS_I2C;\r\ninput->name = pdev->name;\r\ninput->dev.parent = &pdev->dev;\r\ninput->open = tc3589x_keypad_open;\r\ninput->close = tc3589x_keypad_close;\r\nerror = matrix_keypad_build_keymap(plat->keymap_data, NULL,\r\nTC3589x_MAX_KPROW, TC3589x_MAX_KPCOL,\r\nNULL, input);\r\nif (error) {\r\ndev_err(&pdev->dev, "Failed to build keymap\n");\r\nreturn error;\r\n}\r\nkeypad->keymap = input->keycode;\r\ninput_set_capability(input, EV_MSC, MSC_SCAN);\r\nif (!plat->no_autorepeat)\r\n__set_bit(EV_REP, input->evbit);\r\ninput_set_drvdata(input, keypad);\r\ntc3589x_keypad_disable(keypad);\r\nerror = devm_request_threaded_irq(&pdev->dev, irq,\r\nNULL, tc3589x_keypad_irq,\r\nplat->irqtype | IRQF_ONESHOT,\r\n"tc3589x-keypad", keypad);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"Could not allocate irq %d,error %d\n",\r\nirq, error);\r\nreturn error;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(&pdev->dev, "Could not register input device\n");\r\nreturn error;\r\n}\r\ndevice_init_wakeup(&pdev->dev, plat->enable_wakeup);\r\ndevice_set_wakeup_capable(&pdev->dev, plat->enable_wakeup);\r\nplatform_set_drvdata(pdev, keypad);\r\nreturn 0;\r\n}\r\nstatic int tc3589x_keypad_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct tc_keypad *keypad = platform_get_drvdata(pdev);\r\nint irq = platform_get_irq(pdev, 0);\r\nif (keypad->keypad_stopped)\r\nreturn 0;\r\nif (!device_may_wakeup(&pdev->dev))\r\ntc3589x_keypad_disable(keypad);\r\nelse\r\nenable_irq_wake(irq);\r\nreturn 0;\r\n}\r\nstatic int tc3589x_keypad_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct tc_keypad *keypad = platform_get_drvdata(pdev);\r\nint irq = platform_get_irq(pdev, 0);\r\nif (!keypad->keypad_stopped)\r\nreturn 0;\r\nif (!device_may_wakeup(&pdev->dev))\r\ntc3589x_keypad_enable(keypad);\r\nelse\r\ndisable_irq_wake(irq);\r\nreturn 0;\r\n}
