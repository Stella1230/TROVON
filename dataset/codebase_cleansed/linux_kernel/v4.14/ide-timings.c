struct ide_timing *ide_timing_find_mode(u8 speed)\r\n{\r\nstruct ide_timing *t;\r\nfor (t = ide_timing; t->mode != speed; t++)\r\nif (t->mode == 0xff)\r\nreturn NULL;\r\nreturn t;\r\n}\r\nu16 ide_pio_cycle_time(ide_drive_t *drive, u8 pio)\r\n{\r\nu16 *id = drive->id;\r\nstruct ide_timing *t = ide_timing_find_mode(XFER_PIO_0 + pio);\r\nu16 cycle = 0;\r\nif (id[ATA_ID_FIELD_VALID] & 2) {\r\nif (ata_id_has_iordy(drive->id))\r\ncycle = id[ATA_ID_EIDE_PIO_IORDY];\r\nelse\r\ncycle = id[ATA_ID_EIDE_PIO];\r\nif (pio < 3 && cycle < t->cycle)\r\ncycle = 0;\r\nif (pio > 4 && ata_id_is_cfa(id))\r\ncycle = 0;\r\n}\r\nreturn cycle ? cycle : t->cycle;\r\n}\r\nstatic void ide_timing_quantize(struct ide_timing *t, struct ide_timing *q,\r\nint T, int UT)\r\n{\r\nq->setup = EZ(t->setup, T);\r\nq->act8b = EZ(t->act8b, T);\r\nq->rec8b = EZ(t->rec8b, T);\r\nq->cyc8b = EZ(t->cyc8b, T);\r\nq->active = EZ(t->active, T);\r\nq->recover = EZ(t->recover, T);\r\nq->cycle = EZ(t->cycle, T);\r\nq->udma = EZ(t->udma, UT);\r\n}\r\nvoid ide_timing_merge(struct ide_timing *a, struct ide_timing *b,\r\nstruct ide_timing *m, unsigned int what)\r\n{\r\nif (what & IDE_TIMING_SETUP)\r\nm->setup = max(a->setup, b->setup);\r\nif (what & IDE_TIMING_ACT8B)\r\nm->act8b = max(a->act8b, b->act8b);\r\nif (what & IDE_TIMING_REC8B)\r\nm->rec8b = max(a->rec8b, b->rec8b);\r\nif (what & IDE_TIMING_CYC8B)\r\nm->cyc8b = max(a->cyc8b, b->cyc8b);\r\nif (what & IDE_TIMING_ACTIVE)\r\nm->active = max(a->active, b->active);\r\nif (what & IDE_TIMING_RECOVER)\r\nm->recover = max(a->recover, b->recover);\r\nif (what & IDE_TIMING_CYCLE)\r\nm->cycle = max(a->cycle, b->cycle);\r\nif (what & IDE_TIMING_UDMA)\r\nm->udma = max(a->udma, b->udma);\r\n}\r\nint ide_timing_compute(ide_drive_t *drive, u8 speed,\r\nstruct ide_timing *t, int T, int UT)\r\n{\r\nu16 *id = drive->id;\r\nstruct ide_timing *s, p;\r\ns = ide_timing_find_mode(speed);\r\nif (s == NULL)\r\nreturn -EINVAL;\r\n*t = *s;\r\nif (id[ATA_ID_FIELD_VALID] & 2) {\r\nmemset(&p, 0, sizeof(p));\r\nif (speed >= XFER_PIO_0 && speed < XFER_SW_DMA_0) {\r\nif (speed <= XFER_PIO_2)\r\np.cycle = p.cyc8b = id[ATA_ID_EIDE_PIO];\r\nelse if ((speed <= XFER_PIO_4) ||\r\n(speed == XFER_PIO_5 && !ata_id_is_cfa(id)))\r\np.cycle = p.cyc8b = id[ATA_ID_EIDE_PIO_IORDY];\r\n} else if (speed >= XFER_MW_DMA_0 && speed <= XFER_MW_DMA_2)\r\np.cycle = id[ATA_ID_EIDE_DMA_MIN];\r\nide_timing_merge(&p, t, t, IDE_TIMING_CYCLE | IDE_TIMING_CYC8B);\r\n}\r\nide_timing_quantize(t, t, T, UT);\r\nif (speed >= XFER_SW_DMA_0) {\r\nide_timing_compute(drive, drive->pio_mode, &p, T, UT);\r\nide_timing_merge(&p, t, t, IDE_TIMING_ALL);\r\n}\r\nif (t->act8b + t->rec8b < t->cyc8b) {\r\nt->act8b += (t->cyc8b - (t->act8b + t->rec8b)) / 2;\r\nt->rec8b = t->cyc8b - t->act8b;\r\n}\r\nif (t->active + t->recover < t->cycle) {\r\nt->active += (t->cycle - (t->active + t->recover)) / 2;\r\nt->recover = t->cycle - t->active;\r\n}\r\nreturn 0;\r\n}
