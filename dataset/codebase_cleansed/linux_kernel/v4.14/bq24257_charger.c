static bool bq24257_is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase BQ24257_REG_2:\r\ncase BQ24257_REG_4:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic int bq24257_field_read(struct bq24257_device *bq,\r\nenum bq24257_fields field_id)\r\n{\r\nint ret;\r\nint val;\r\nret = regmap_field_read(bq->rmap_fields[field_id], &val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn val;\r\n}\r\nstatic int bq24257_field_write(struct bq24257_device *bq,\r\nenum bq24257_fields field_id, u8 val)\r\n{\r\nreturn regmap_field_write(bq->rmap_fields[field_id], val);\r\n}\r\nstatic u8 bq24257_find_idx(u32 value, const u32 *map, u8 map_size)\r\n{\r\nu8 idx;\r\nfor (idx = 1; idx < map_size; idx++)\r\nif (value < map[idx])\r\nbreak;\r\nreturn idx - 1;\r\n}\r\nstatic int bq24257_get_input_current_limit(struct bq24257_device *bq,\r\nunion power_supply_propval *val)\r\n{\r\nint ret;\r\nret = bq24257_field_read(bq, F_IILIMIT);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret >= BQ24257_IILIMIT_MAP_SIZE)\r\nreturn -ENODATA;\r\nval->intval = bq24257_iilimit_map[ret];\r\nreturn 0;\r\n}\r\nstatic int bq24257_set_input_current_limit(struct bq24257_device *bq,\r\nconst union power_supply_propval *val)\r\n{\r\nif (bq->iilimit_autoset_enable)\r\ncancel_delayed_work_sync(&bq->iilimit_setup_work);\r\nreturn bq24257_field_write(bq, F_IILIMIT,\r\nbq24257_find_idx(val->intval,\r\nbq24257_iilimit_map,\r\nBQ24257_IILIMIT_MAP_SIZE));\r\n}\r\nstatic int bq24257_power_supply_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct bq24257_device *bq = power_supply_get_drvdata(psy);\r\nstruct bq24257_state state;\r\nmutex_lock(&bq->lock);\r\nstate = bq->state;\r\nmutex_unlock(&bq->lock);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (!state.power_good)\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse if (state.status == STATUS_READY)\r\nval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse if (state.status == STATUS_CHARGE_IN_PROGRESS)\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nelse if (state.status == STATUS_CHARGE_DONE)\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MANUFACTURER:\r\nval->strval = BQ24257_MANUFACTURER;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nval->strval = bq2425x_chip_name[bq->chip];\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = state.power_good;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nswitch (state.fault) {\r\ncase FAULT_NORMAL:\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\nbreak;\r\ncase FAULT_INPUT_OVP:\r\ncase FAULT_BAT_OVP:\r\nval->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\r\nbreak;\r\ncase FAULT_TS:\r\ncase FAULT_BAT_TS:\r\nval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nbreak;\r\ncase FAULT_TIMER:\r\nval->intval = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;\r\nbreak;\r\ndefault:\r\nval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\r\nbreak;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\r\nval->intval = bq24257_ichg_map[bq->init_data.ichg];\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\r\nval->intval = bq24257_ichg_map[BQ24257_ICHG_MAP_SIZE - 1];\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\r\nval->intval = bq24257_vbat_map[bq->init_data.vbat];\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\r\nval->intval = bq24257_vbat_map[BQ24257_VBAT_MAP_SIZE - 1];\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\r\nval->intval = bq24257_iterm_map[bq->init_data.iterm];\r\nbreak;\r\ncase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\r\nreturn bq24257_get_input_current_limit(bq, val);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bq24257_power_supply_set_property(struct power_supply *psy,\r\nenum power_supply_property prop,\r\nconst union power_supply_propval *val)\r\n{\r\nstruct bq24257_device *bq = power_supply_get_drvdata(psy);\r\nswitch (prop) {\r\ncase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\r\nreturn bq24257_set_input_current_limit(bq, val);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int bq24257_power_supply_property_is_writeable(struct power_supply *psy,\r\nenum power_supply_property psp)\r\n{\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int bq24257_get_chip_state(struct bq24257_device *bq,\r\nstruct bq24257_state *state)\r\n{\r\nint ret;\r\nret = bq24257_field_read(bq, F_STAT);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->status = ret;\r\nret = bq24257_field_read(bq, F_FAULT);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->fault = ret;\r\nif (bq->pg)\r\nstate->power_good = !gpiod_get_value_cansleep(bq->pg);\r\nelse\r\nswitch (state->fault) {\r\ncase FAULT_INPUT_OVP:\r\ncase FAULT_INPUT_UVLO:\r\ncase FAULT_INPUT_LDO_LOW:\r\nstate->power_good = false;\r\nbreak;\r\ndefault:\r\nstate->power_good = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool bq24257_state_changed(struct bq24257_device *bq,\r\nstruct bq24257_state *new_state)\r\n{\r\nint ret;\r\nmutex_lock(&bq->lock);\r\nret = (bq->state.status != new_state->status ||\r\nbq->state.fault != new_state->fault ||\r\nbq->state.power_good != new_state->power_good);\r\nmutex_unlock(&bq->lock);\r\nreturn ret;\r\n}\r\nstatic int bq24257_iilimit_autoset(struct bq24257_device *bq)\r\n{\r\nint loop_status;\r\nint iilimit;\r\nint port_type;\r\nint ret;\r\nconst u8 new_iilimit[] = {\r\n[PORT_TYPE_DCP] = IILIMIT_2000,\r\n[PORT_TYPE_CDP] = IILIMIT_2000,\r\n[PORT_TYPE_SDP] = IILIMIT_500,\r\n[PORT_TYPE_NON_STANDARD] = IILIMIT_500\r\n};\r\nret = bq24257_field_read(bq, F_LOOP_STATUS);\r\nif (ret < 0)\r\ngoto error;\r\nloop_status = ret;\r\nret = bq24257_field_read(bq, F_IILIMIT);\r\nif (ret < 0)\r\ngoto error;\r\niilimit = ret;\r\nif (loop_status == LOOP_STATUS_IN_DPM && iilimit == IILIMIT_500)\r\nreturn 0;\r\nret = bq24257_field_read(bq, F_USB_DET);\r\nif (ret < 0)\r\ngoto error;\r\nport_type = ret;\r\nret = bq24257_field_write(bq, F_IILIMIT, new_iilimit[port_type]);\r\nif (ret < 0)\r\ngoto error;\r\nret = bq24257_field_write(bq, F_TMR, SAFETY_TIMER_360);\r\nif (ret < 0)\r\ngoto error;\r\nret = bq24257_field_write(bq, F_CLR_VDP, 1);\r\nif (ret < 0)\r\ngoto error;\r\ndev_dbg(bq->dev, "port/loop = %d/%d -> iilimit = %d\n",\r\nport_type, loop_status, new_iilimit[port_type]);\r\nreturn 0;\r\nerror:\r\ndev_err(bq->dev, "%s: Error communicating with the chip.\n", __func__);\r\nreturn ret;\r\n}\r\nstatic void bq24257_iilimit_setup_work(struct work_struct *work)\r\n{\r\nstruct bq24257_device *bq = container_of(work, struct bq24257_device,\r\niilimit_setup_work.work);\r\nbq24257_iilimit_autoset(bq);\r\n}\r\nstatic void bq24257_handle_state_change(struct bq24257_device *bq,\r\nstruct bq24257_state *new_state)\r\n{\r\nint ret;\r\nstruct bq24257_state old_state;\r\nmutex_lock(&bq->lock);\r\nold_state = bq->state;\r\nmutex_unlock(&bq->lock);\r\nif (!new_state->power_good) {\r\ndev_dbg(bq->dev, "Power removed\n");\r\nif (bq->iilimit_autoset_enable) {\r\ncancel_delayed_work_sync(&bq->iilimit_setup_work);\r\nret = bq24257_field_write(bq, F_DPDM_EN, 1);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nret = bq24257_field_write(bq, F_IILIMIT, bq->init_data.iilimit);\r\nif (ret < 0)\r\ngoto error;\r\n} else if (!old_state.power_good) {\r\ndev_dbg(bq->dev, "Power inserted\n");\r\nif (bq->iilimit_autoset_enable)\r\nschedule_delayed_work(&bq->iilimit_setup_work,\r\nmsecs_to_jiffies(BQ24257_ILIM_SET_DELAY));\r\n} else if (new_state->fault == FAULT_NO_BAT) {\r\ndev_warn(bq->dev, "Battery removed\n");\r\n} else if (new_state->fault == FAULT_TIMER) {\r\ndev_err(bq->dev, "Safety timer expired! Battery dead?\n");\r\n}\r\nreturn;\r\nerror:\r\ndev_err(bq->dev, "%s: Error communicating with the chip.\n", __func__);\r\n}\r\nstatic irqreturn_t bq24257_irq_handler_thread(int irq, void *private)\r\n{\r\nint ret;\r\nstruct bq24257_device *bq = private;\r\nstruct bq24257_state state;\r\nret = bq24257_get_chip_state(bq, &state);\r\nif (ret < 0)\r\nreturn IRQ_HANDLED;\r\nif (!bq24257_state_changed(bq, &state))\r\nreturn IRQ_HANDLED;\r\ndev_dbg(bq->dev, "irq(state changed): status/fault/pg = %d/%d/%d\n",\r\nstate.status, state.fault, state.power_good);\r\nbq24257_handle_state_change(bq, &state);\r\nmutex_lock(&bq->lock);\r\nbq->state = state;\r\nmutex_unlock(&bq->lock);\r\npower_supply_changed(bq->charger);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bq24257_hw_init(struct bq24257_device *bq)\r\n{\r\nint ret;\r\nint i;\r\nstruct bq24257_state state;\r\nconst struct {\r\nint field;\r\nu32 value;\r\n} init_data[] = {\r\n{F_ICHG, bq->init_data.ichg},\r\n{F_VBAT, bq->init_data.vbat},\r\n{F_ITERM, bq->init_data.iterm},\r\n{F_VOVP, bq->init_data.vovp},\r\n{F_VINDPM, bq->init_data.vindpm},\r\n};\r\nret = bq24257_field_write(bq, F_WD_EN, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(init_data); i++) {\r\nret = bq24257_field_write(bq, init_data[i].field,\r\ninit_data[i].value);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = bq24257_get_chip_state(bq, &state);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&bq->lock);\r\nbq->state = state;\r\nmutex_unlock(&bq->lock);\r\nif (!bq->iilimit_autoset_enable) {\r\ndev_dbg(bq->dev, "manually setting iilimit = %u\n",\r\nbq->init_data.iilimit);\r\nret = bq24257_field_write(bq, F_IILIMIT,\r\nbq->init_data.iilimit);\r\nif (ret < 0)\r\nreturn ret;\r\n} else if (!state.power_good)\r\nret = bq24257_field_write(bq, F_DPDM_EN, 1);\r\nelse if (state.fault != FAULT_NO_BAT)\r\nret = bq24257_iilimit_autoset(bq);\r\nreturn ret;\r\n}\r\nstatic ssize_t bq24257_show_ovp_voltage(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq24257_device *bq = power_supply_get_drvdata(psy);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n",\r\nbq24257_vovp_map[bq->init_data.vovp]);\r\n}\r\nstatic ssize_t bq24257_show_in_dpm_voltage(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq24257_device *bq = power_supply_get_drvdata(psy);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n",\r\nbq24257_vindpm_map[bq->init_data.vindpm]);\r\n}\r\nstatic ssize_t bq24257_sysfs_show_enable(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq24257_device *bq = power_supply_get_drvdata(psy);\r\nint ret;\r\nif (strcmp(attr->attr.name, "high_impedance_enable") == 0)\r\nret = bq24257_field_read(bq, F_HZ_MODE);\r\nelse if (strcmp(attr->attr.name, "sysoff_enable") == 0)\r\nret = bq24257_field_read(bq, F_SYSOFF);\r\nelse\r\nreturn -EINVAL;\r\nif (ret < 0)\r\nreturn ret;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", ret);\r\n}\r\nstatic ssize_t bq24257_sysfs_set_enable(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq24257_device *bq = power_supply_get_drvdata(psy);\r\nlong val;\r\nint ret;\r\nif (kstrtol(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nif (strcmp(attr->attr.name, "high_impedance_enable") == 0)\r\nret = bq24257_field_write(bq, F_HZ_MODE, (bool)val);\r\nelse if (strcmp(attr->attr.name, "sysoff_enable") == 0)\r\nret = bq24257_field_write(bq, F_SYSOFF, (bool)val);\r\nelse\r\nreturn -EINVAL;\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic int bq24257_power_supply_init(struct bq24257_device *bq)\r\n{\r\nstruct power_supply_config psy_cfg = { .drv_data = bq, };\r\npsy_cfg.supplied_to = bq24257_charger_supplied_to;\r\npsy_cfg.num_supplicants = ARRAY_SIZE(bq24257_charger_supplied_to);\r\nbq->charger = devm_power_supply_register(bq->dev,\r\n&bq24257_power_supply_desc,\r\n&psy_cfg);\r\nreturn PTR_ERR_OR_ZERO(bq->charger);\r\n}\r\nstatic void bq24257_pg_gpio_probe(struct bq24257_device *bq)\r\n{\r\nbq->pg = devm_gpiod_get_optional(bq->dev, BQ24257_PG_GPIO, GPIOD_IN);\r\nif (PTR_ERR(bq->pg) == -EPROBE_DEFER) {\r\ndev_info(bq->dev, "probe retry requested for PG pin\n");\r\nreturn;\r\n} else if (IS_ERR(bq->pg)) {\r\ndev_err(bq->dev, "error probing PG pin\n");\r\nbq->pg = NULL;\r\nreturn;\r\n}\r\nif (bq->pg)\r\ndev_dbg(bq->dev, "probed PG pin = %d\n", desc_to_gpio(bq->pg));\r\n}\r\nstatic int bq24257_fw_probe(struct bq24257_device *bq)\r\n{\r\nint ret;\r\nu32 property;\r\nret = device_property_read_u32(bq->dev, "ti,charge-current", &property);\r\nif (ret < 0)\r\nreturn ret;\r\nbq->init_data.ichg = bq24257_find_idx(property, bq24257_ichg_map,\r\nBQ24257_ICHG_MAP_SIZE);\r\nret = device_property_read_u32(bq->dev, "ti,battery-regulation-voltage",\r\n&property);\r\nif (ret < 0)\r\nreturn ret;\r\nbq->init_data.vbat = bq24257_find_idx(property, bq24257_vbat_map,\r\nBQ24257_VBAT_MAP_SIZE);\r\nret = device_property_read_u32(bq->dev, "ti,termination-current",\r\n&property);\r\nif (ret < 0)\r\nreturn ret;\r\nbq->init_data.iterm = bq24257_find_idx(property, bq24257_iterm_map,\r\nBQ24257_ITERM_MAP_SIZE);\r\nret = device_property_read_u32(bq->dev, "ti,current-limit",\r\n&property);\r\nif (ret < 0) {\r\nbq->iilimit_autoset_enable = true;\r\nbq->init_data.iilimit = IILIMIT_500;\r\n} else\r\nbq->init_data.iilimit =\r\nbq24257_find_idx(property,\r\nbq24257_iilimit_map,\r\nBQ24257_IILIMIT_MAP_SIZE);\r\nret = device_property_read_u32(bq->dev, "ti,ovp-voltage",\r\n&property);\r\nif (ret < 0)\r\nbq->init_data.vovp = VOVP_6500;\r\nelse\r\nbq->init_data.vovp = bq24257_find_idx(property,\r\nbq24257_vovp_map,\r\nBQ24257_VOVP_MAP_SIZE);\r\nret = device_property_read_u32(bq->dev, "ti,in-dpm-voltage",\r\n&property);\r\nif (ret < 0)\r\nbq->init_data.vindpm = VINDPM_4360;\r\nelse\r\nbq->init_data.vindpm =\r\nbq24257_find_idx(property,\r\nbq24257_vindpm_map,\r\nBQ24257_VINDPM_MAP_SIZE);\r\nreturn 0;\r\n}\r\nstatic int bq24257_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct device *dev = &client->dev;\r\nconst struct acpi_device_id *acpi_id;\r\nstruct bq24257_device *bq;\r\nint ret;\r\nint i;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(dev, "No support for SMBUS_BYTE_DATA\n");\r\nreturn -ENODEV;\r\n}\r\nbq = devm_kzalloc(dev, sizeof(*bq), GFP_KERNEL);\r\nif (!bq)\r\nreturn -ENOMEM;\r\nbq->client = client;\r\nbq->dev = dev;\r\nif (ACPI_HANDLE(dev)) {\r\nacpi_id = acpi_match_device(dev->driver->acpi_match_table,\r\n&client->dev);\r\nif (!acpi_id) {\r\ndev_err(dev, "Failed to match ACPI device\n");\r\nreturn -ENODEV;\r\n}\r\nbq->chip = (enum bq2425x_chip)acpi_id->driver_data;\r\n} else {\r\nbq->chip = (enum bq2425x_chip)id->driver_data;\r\n}\r\nmutex_init(&bq->lock);\r\nbq->rmap = devm_regmap_init_i2c(client, &bq24257_regmap_config);\r\nif (IS_ERR(bq->rmap)) {\r\ndev_err(dev, "failed to allocate register map\n");\r\nreturn PTR_ERR(bq->rmap);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(bq24257_reg_fields); i++) {\r\nconst struct reg_field *reg_fields = bq24257_reg_fields;\r\nbq->rmap_fields[i] = devm_regmap_field_alloc(dev, bq->rmap,\r\nreg_fields[i]);\r\nif (IS_ERR(bq->rmap_fields[i])) {\r\ndev_err(dev, "cannot allocate regmap field\n");\r\nreturn PTR_ERR(bq->rmap_fields[i]);\r\n}\r\n}\r\ni2c_set_clientdata(client, bq);\r\nif (!dev->platform_data) {\r\nret = bq24257_fw_probe(bq);\r\nif (ret < 0) {\r\ndev_err(dev, "Cannot read device properties.\n");\r\nreturn ret;\r\n}\r\n} else {\r\nreturn -ENODEV;\r\n}\r\nif (bq->chip == BQ24250)\r\nbq->iilimit_autoset_enable = false;\r\nif (bq->iilimit_autoset_enable)\r\nINIT_DELAYED_WORK(&bq->iilimit_setup_work,\r\nbq24257_iilimit_setup_work);\r\nif (bq->chip != BQ24250)\r\nbq24257_pg_gpio_probe(bq);\r\nif (PTR_ERR(bq->pg) == -EPROBE_DEFER)\r\nreturn PTR_ERR(bq->pg);\r\nelse if (!bq->pg)\r\ndev_info(bq->dev, "using SW-based power-good detection\n");\r\nret = bq24257_field_write(bq, F_RESET, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = bq24257_field_write(bq, F_RESET, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = bq24257_hw_init(bq);\r\nif (ret < 0) {\r\ndev_err(dev, "Cannot initialize the chip.\n");\r\nreturn ret;\r\n}\r\nret = bq24257_power_supply_init(bq);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to register power supply\n");\r\nreturn ret;\r\n}\r\nret = devm_request_threaded_irq(dev, client->irq, NULL,\r\nbq24257_irq_handler_thread,\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\nbq2425x_chip_name[bq->chip], bq);\r\nif (ret) {\r\ndev_err(dev, "Failed to request IRQ #%d\n", client->irq);\r\nreturn ret;\r\n}\r\nret = sysfs_create_group(&bq->charger->dev.kobj, &bq24257_attr_group);\r\nif (ret < 0) {\r\ndev_err(dev, "Can't create sysfs entries\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bq24257_remove(struct i2c_client *client)\r\n{\r\nstruct bq24257_device *bq = i2c_get_clientdata(client);\r\nif (bq->iilimit_autoset_enable)\r\ncancel_delayed_work_sync(&bq->iilimit_setup_work);\r\nsysfs_remove_group(&bq->charger->dev.kobj, &bq24257_attr_group);\r\nbq24257_field_write(bq, F_RESET, 1);\r\nreturn 0;\r\n}\r\nstatic int bq24257_suspend(struct device *dev)\r\n{\r\nstruct bq24257_device *bq = dev_get_drvdata(dev);\r\nint ret = 0;\r\nif (bq->iilimit_autoset_enable)\r\ncancel_delayed_work_sync(&bq->iilimit_setup_work);\r\nret = bq24257_field_write(bq, F_RESET, 1);\r\nif (ret < 0)\r\ndev_err(bq->dev, "Cannot reset chip to standalone mode.\n");\r\nreturn ret;\r\n}\r\nstatic int bq24257_resume(struct device *dev)\r\n{\r\nint ret;\r\nstruct bq24257_device *bq = dev_get_drvdata(dev);\r\nret = regcache_drop_region(bq->rmap, BQ24257_REG_1, BQ24257_REG_7);\r\nif (ret < 0)\r\nreturn ret;\r\nret = bq24257_field_write(bq, F_RESET, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = bq24257_hw_init(bq);\r\nif (ret < 0) {\r\ndev_err(bq->dev, "Cannot init chip after resume.\n");\r\nreturn ret;\r\n}\r\npower_supply_changed(bq->charger);\r\nreturn 0;\r\n}
