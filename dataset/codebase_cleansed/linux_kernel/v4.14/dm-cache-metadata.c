static void sb_prepare_for_write(struct dm_block_validator *v,\r\nstruct dm_block *b,\r\nsize_t sb_block_size)\r\n{\r\nstruct cache_disk_superblock *disk_super = dm_block_data(b);\r\ndisk_super->blocknr = cpu_to_le64(dm_block_location(b));\r\ndisk_super->csum = cpu_to_le32(dm_bm_checksum(&disk_super->flags,\r\nsb_block_size - sizeof(__le32),\r\nSUPERBLOCK_CSUM_XOR));\r\n}\r\nstatic int check_metadata_version(struct cache_disk_superblock *disk_super)\r\n{\r\nuint32_t metadata_version = le32_to_cpu(disk_super->version);\r\nif (metadata_version < MIN_CACHE_VERSION || metadata_version > MAX_CACHE_VERSION) {\r\nDMERR("Cache metadata version %u found, but only versions between %u and %u supported.",\r\nmetadata_version, MIN_CACHE_VERSION, MAX_CACHE_VERSION);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sb_check(struct dm_block_validator *v,\r\nstruct dm_block *b,\r\nsize_t sb_block_size)\r\n{\r\nstruct cache_disk_superblock *disk_super = dm_block_data(b);\r\n__le32 csum_le;\r\nif (dm_block_location(b) != le64_to_cpu(disk_super->blocknr)) {\r\nDMERR("sb_check failed: blocknr %llu: wanted %llu",\r\nle64_to_cpu(disk_super->blocknr),\r\n(unsigned long long)dm_block_location(b));\r\nreturn -ENOTBLK;\r\n}\r\nif (le64_to_cpu(disk_super->magic) != CACHE_SUPERBLOCK_MAGIC) {\r\nDMERR("sb_check failed: magic %llu: wanted %llu",\r\nle64_to_cpu(disk_super->magic),\r\n(unsigned long long)CACHE_SUPERBLOCK_MAGIC);\r\nreturn -EILSEQ;\r\n}\r\ncsum_le = cpu_to_le32(dm_bm_checksum(&disk_super->flags,\r\nsb_block_size - sizeof(__le32),\r\nSUPERBLOCK_CSUM_XOR));\r\nif (csum_le != disk_super->csum) {\r\nDMERR("sb_check failed: csum %u: wanted %u",\r\nle32_to_cpu(csum_le), le32_to_cpu(disk_super->csum));\r\nreturn -EILSEQ;\r\n}\r\nreturn check_metadata_version(disk_super);\r\n}\r\nstatic int superblock_read_lock(struct dm_cache_metadata *cmd,\r\nstruct dm_block **sblock)\r\n{\r\nreturn dm_bm_read_lock(cmd->bm, CACHE_SUPERBLOCK_LOCATION,\r\n&sb_validator, sblock);\r\n}\r\nstatic int superblock_lock_zero(struct dm_cache_metadata *cmd,\r\nstruct dm_block **sblock)\r\n{\r\nreturn dm_bm_write_lock_zero(cmd->bm, CACHE_SUPERBLOCK_LOCATION,\r\n&sb_validator, sblock);\r\n}\r\nstatic int superblock_lock(struct dm_cache_metadata *cmd,\r\nstruct dm_block **sblock)\r\n{\r\nreturn dm_bm_write_lock(cmd->bm, CACHE_SUPERBLOCK_LOCATION,\r\n&sb_validator, sblock);\r\n}\r\nstatic int __superblock_all_zeroes(struct dm_block_manager *bm, bool *result)\r\n{\r\nint r;\r\nunsigned i;\r\nstruct dm_block *b;\r\n__le64 *data_le, zero = cpu_to_le64(0);\r\nunsigned sb_block_size = dm_bm_block_size(bm) / sizeof(__le64);\r\nr = dm_bm_read_lock(bm, CACHE_SUPERBLOCK_LOCATION, NULL, &b);\r\nif (r)\r\nreturn r;\r\ndata_le = dm_block_data(b);\r\n*result = true;\r\nfor (i = 0; i < sb_block_size; i++) {\r\nif (data_le[i] != zero) {\r\n*result = false;\r\nbreak;\r\n}\r\n}\r\ndm_bm_unlock(b);\r\nreturn 0;\r\n}\r\nstatic void __setup_mapping_info(struct dm_cache_metadata *cmd)\r\n{\r\nstruct dm_btree_value_type vt;\r\nvt.context = NULL;\r\nvt.size = sizeof(__le64);\r\nvt.inc = NULL;\r\nvt.dec = NULL;\r\nvt.equal = NULL;\r\ndm_array_info_init(&cmd->info, cmd->tm, &vt);\r\nif (cmd->policy_hint_size) {\r\nvt.size = sizeof(__le32);\r\ndm_array_info_init(&cmd->hint_info, cmd->tm, &vt);\r\n}\r\n}\r\nstatic int __save_sm_root(struct dm_cache_metadata *cmd)\r\n{\r\nint r;\r\nsize_t metadata_len;\r\nr = dm_sm_root_size(cmd->metadata_sm, &metadata_len);\r\nif (r < 0)\r\nreturn r;\r\nreturn dm_sm_copy_root(cmd->metadata_sm, &cmd->metadata_space_map_root,\r\nmetadata_len);\r\n}\r\nstatic void __copy_sm_root(struct dm_cache_metadata *cmd,\r\nstruct cache_disk_superblock *disk_super)\r\n{\r\nmemcpy(&disk_super->metadata_space_map_root,\r\n&cmd->metadata_space_map_root,\r\nsizeof(cmd->metadata_space_map_root));\r\n}\r\nstatic bool separate_dirty_bits(struct dm_cache_metadata *cmd)\r\n{\r\nreturn cmd->version >= 2;\r\n}\r\nstatic int __write_initial_superblock(struct dm_cache_metadata *cmd)\r\n{\r\nint r;\r\nstruct dm_block *sblock;\r\nstruct cache_disk_superblock *disk_super;\r\nsector_t bdev_size = i_size_read(cmd->bdev->bd_inode) >> SECTOR_SHIFT;\r\nif (bdev_size > DM_CACHE_METADATA_MAX_SECTORS)\r\nbdev_size = DM_CACHE_METADATA_MAX_SECTORS;\r\nr = dm_tm_pre_commit(cmd->tm);\r\nif (r < 0)\r\nreturn r;\r\nr = __save_sm_root(cmd);\r\nif (r)\r\nreturn r;\r\nr = superblock_lock_zero(cmd, &sblock);\r\nif (r)\r\nreturn r;\r\ndisk_super = dm_block_data(sblock);\r\ndisk_super->flags = 0;\r\nmemset(disk_super->uuid, 0, sizeof(disk_super->uuid));\r\ndisk_super->magic = cpu_to_le64(CACHE_SUPERBLOCK_MAGIC);\r\ndisk_super->version = cpu_to_le32(cmd->version);\r\nmemset(disk_super->policy_name, 0, sizeof(disk_super->policy_name));\r\nmemset(disk_super->policy_version, 0, sizeof(disk_super->policy_version));\r\ndisk_super->policy_hint_size = 0;\r\n__copy_sm_root(cmd, disk_super);\r\ndisk_super->mapping_root = cpu_to_le64(cmd->root);\r\ndisk_super->hint_root = cpu_to_le64(cmd->hint_root);\r\ndisk_super->discard_root = cpu_to_le64(cmd->discard_root);\r\ndisk_super->discard_block_size = cpu_to_le64(cmd->discard_block_size);\r\ndisk_super->discard_nr_blocks = cpu_to_le64(from_dblock(cmd->discard_nr_blocks));\r\ndisk_super->metadata_block_size = cpu_to_le32(DM_CACHE_METADATA_BLOCK_SIZE);\r\ndisk_super->data_block_size = cpu_to_le32(cmd->data_block_size);\r\ndisk_super->cache_blocks = cpu_to_le32(0);\r\ndisk_super->read_hits = cpu_to_le32(0);\r\ndisk_super->read_misses = cpu_to_le32(0);\r\ndisk_super->write_hits = cpu_to_le32(0);\r\ndisk_super->write_misses = cpu_to_le32(0);\r\nif (separate_dirty_bits(cmd))\r\ndisk_super->dirty_root = cpu_to_le64(cmd->dirty_root);\r\nreturn dm_tm_commit(cmd->tm, sblock);\r\n}\r\nstatic int __format_metadata(struct dm_cache_metadata *cmd)\r\n{\r\nint r;\r\nr = dm_tm_create_with_sm(cmd->bm, CACHE_SUPERBLOCK_LOCATION,\r\n&cmd->tm, &cmd->metadata_sm);\r\nif (r < 0) {\r\nDMERR("tm_create_with_sm failed");\r\nreturn r;\r\n}\r\n__setup_mapping_info(cmd);\r\nr = dm_array_empty(&cmd->info, &cmd->root);\r\nif (r < 0)\r\ngoto bad;\r\nif (separate_dirty_bits(cmd)) {\r\ndm_disk_bitset_init(cmd->tm, &cmd->dirty_info);\r\nr = dm_bitset_empty(&cmd->dirty_info, &cmd->dirty_root);\r\nif (r < 0)\r\ngoto bad;\r\n}\r\ndm_disk_bitset_init(cmd->tm, &cmd->discard_info);\r\nr = dm_bitset_empty(&cmd->discard_info, &cmd->discard_root);\r\nif (r < 0)\r\ngoto bad;\r\ncmd->discard_block_size = 0;\r\ncmd->discard_nr_blocks = 0;\r\nr = __write_initial_superblock(cmd);\r\nif (r)\r\ngoto bad;\r\ncmd->clean_when_opened = true;\r\nreturn 0;\r\nbad:\r\ndm_tm_destroy(cmd->tm);\r\ndm_sm_destroy(cmd->metadata_sm);\r\nreturn r;\r\n}\r\nstatic int __check_incompat_features(struct cache_disk_superblock *disk_super,\r\nstruct dm_cache_metadata *cmd)\r\n{\r\nuint32_t incompat_flags, features;\r\nincompat_flags = le32_to_cpu(disk_super->incompat_flags);\r\nfeatures = incompat_flags & ~DM_CACHE_FEATURE_INCOMPAT_SUPP;\r\nif (features) {\r\nDMERR("could not access metadata due to unsupported optional features (%lx).",\r\n(unsigned long)features);\r\nreturn -EINVAL;\r\n}\r\nif (get_disk_ro(cmd->bdev->bd_disk))\r\nreturn 0;\r\nfeatures = le32_to_cpu(disk_super->compat_ro_flags) & ~DM_CACHE_FEATURE_COMPAT_RO_SUPP;\r\nif (features) {\r\nDMERR("could not access metadata RDWR due to unsupported optional features (%lx).",\r\n(unsigned long)features);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __open_metadata(struct dm_cache_metadata *cmd)\r\n{\r\nint r;\r\nstruct dm_block *sblock;\r\nstruct cache_disk_superblock *disk_super;\r\nunsigned long sb_flags;\r\nr = superblock_read_lock(cmd, &sblock);\r\nif (r < 0) {\r\nDMERR("couldn't read lock superblock");\r\nreturn r;\r\n}\r\ndisk_super = dm_block_data(sblock);\r\nif (le32_to_cpu(disk_super->data_block_size) != cmd->data_block_size) {\r\nDMERR("changing the data block size (from %u to %llu) is not supported",\r\nle32_to_cpu(disk_super->data_block_size),\r\n(unsigned long long)cmd->data_block_size);\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nr = __check_incompat_features(disk_super, cmd);\r\nif (r < 0)\r\ngoto bad;\r\nr = dm_tm_open_with_sm(cmd->bm, CACHE_SUPERBLOCK_LOCATION,\r\ndisk_super->metadata_space_map_root,\r\nsizeof(disk_super->metadata_space_map_root),\r\n&cmd->tm, &cmd->metadata_sm);\r\nif (r < 0) {\r\nDMERR("tm_open_with_sm failed");\r\ngoto bad;\r\n}\r\n__setup_mapping_info(cmd);\r\ndm_disk_bitset_init(cmd->tm, &cmd->dirty_info);\r\ndm_disk_bitset_init(cmd->tm, &cmd->discard_info);\r\nsb_flags = le32_to_cpu(disk_super->flags);\r\ncmd->clean_when_opened = test_bit(CLEAN_SHUTDOWN, &sb_flags);\r\ndm_bm_unlock(sblock);\r\nreturn 0;\r\nbad:\r\ndm_bm_unlock(sblock);\r\nreturn r;\r\n}\r\nstatic int __open_or_format_metadata(struct dm_cache_metadata *cmd,\r\nbool format_device)\r\n{\r\nint r;\r\nbool unformatted = false;\r\nr = __superblock_all_zeroes(cmd->bm, &unformatted);\r\nif (r)\r\nreturn r;\r\nif (unformatted)\r\nreturn format_device ? __format_metadata(cmd) : -EPERM;\r\nreturn __open_metadata(cmd);\r\n}\r\nstatic int __create_persistent_data_objects(struct dm_cache_metadata *cmd,\r\nbool may_format_device)\r\n{\r\nint r;\r\ncmd->bm = dm_block_manager_create(cmd->bdev, DM_CACHE_METADATA_BLOCK_SIZE << SECTOR_SHIFT,\r\nCACHE_MAX_CONCURRENT_LOCKS);\r\nif (IS_ERR(cmd->bm)) {\r\nDMERR("could not create block manager");\r\nreturn PTR_ERR(cmd->bm);\r\n}\r\nr = __open_or_format_metadata(cmd, may_format_device);\r\nif (r)\r\ndm_block_manager_destroy(cmd->bm);\r\nreturn r;\r\n}\r\nstatic void __destroy_persistent_data_objects(struct dm_cache_metadata *cmd)\r\n{\r\ndm_sm_destroy(cmd->metadata_sm);\r\ndm_tm_destroy(cmd->tm);\r\ndm_block_manager_destroy(cmd->bm);\r\n}\r\nstatic void update_flags(struct cache_disk_superblock *disk_super,\r\nflags_mutator mutator)\r\n{\r\nuint32_t sb_flags = mutator(le32_to_cpu(disk_super->flags));\r\ndisk_super->flags = cpu_to_le32(sb_flags);\r\n}\r\nstatic unsigned long set_clean_shutdown(unsigned long flags)\r\n{\r\nset_bit(CLEAN_SHUTDOWN, &flags);\r\nreturn flags;\r\n}\r\nstatic unsigned long clear_clean_shutdown(unsigned long flags)\r\n{\r\nclear_bit(CLEAN_SHUTDOWN, &flags);\r\nreturn flags;\r\n}\r\nstatic void read_superblock_fields(struct dm_cache_metadata *cmd,\r\nstruct cache_disk_superblock *disk_super)\r\n{\r\ncmd->version = le32_to_cpu(disk_super->version);\r\ncmd->flags = le32_to_cpu(disk_super->flags);\r\ncmd->root = le64_to_cpu(disk_super->mapping_root);\r\ncmd->hint_root = le64_to_cpu(disk_super->hint_root);\r\ncmd->discard_root = le64_to_cpu(disk_super->discard_root);\r\ncmd->discard_block_size = le64_to_cpu(disk_super->discard_block_size);\r\ncmd->discard_nr_blocks = to_dblock(le64_to_cpu(disk_super->discard_nr_blocks));\r\ncmd->data_block_size = le32_to_cpu(disk_super->data_block_size);\r\ncmd->cache_blocks = to_cblock(le32_to_cpu(disk_super->cache_blocks));\r\nstrncpy(cmd->policy_name, disk_super->policy_name, sizeof(cmd->policy_name));\r\ncmd->policy_version[0] = le32_to_cpu(disk_super->policy_version[0]);\r\ncmd->policy_version[1] = le32_to_cpu(disk_super->policy_version[1]);\r\ncmd->policy_version[2] = le32_to_cpu(disk_super->policy_version[2]);\r\ncmd->policy_hint_size = le32_to_cpu(disk_super->policy_hint_size);\r\ncmd->stats.read_hits = le32_to_cpu(disk_super->read_hits);\r\ncmd->stats.read_misses = le32_to_cpu(disk_super->read_misses);\r\ncmd->stats.write_hits = le32_to_cpu(disk_super->write_hits);\r\ncmd->stats.write_misses = le32_to_cpu(disk_super->write_misses);\r\nif (separate_dirty_bits(cmd))\r\ncmd->dirty_root = le64_to_cpu(disk_super->dirty_root);\r\ncmd->changed = false;\r\n}\r\nstatic int __begin_transaction_flags(struct dm_cache_metadata *cmd,\r\nflags_mutator mutator)\r\n{\r\nint r;\r\nstruct cache_disk_superblock *disk_super;\r\nstruct dm_block *sblock;\r\nr = superblock_lock(cmd, &sblock);\r\nif (r)\r\nreturn r;\r\ndisk_super = dm_block_data(sblock);\r\nupdate_flags(disk_super, mutator);\r\nread_superblock_fields(cmd, disk_super);\r\ndm_bm_unlock(sblock);\r\nreturn dm_bm_flush(cmd->bm);\r\n}\r\nstatic int __begin_transaction(struct dm_cache_metadata *cmd)\r\n{\r\nint r;\r\nstruct cache_disk_superblock *disk_super;\r\nstruct dm_block *sblock;\r\nr = superblock_read_lock(cmd, &sblock);\r\nif (r)\r\nreturn r;\r\ndisk_super = dm_block_data(sblock);\r\nread_superblock_fields(cmd, disk_super);\r\ndm_bm_unlock(sblock);\r\nreturn 0;\r\n}\r\nstatic int __commit_transaction(struct dm_cache_metadata *cmd,\r\nflags_mutator mutator)\r\n{\r\nint r;\r\nstruct cache_disk_superblock *disk_super;\r\nstruct dm_block *sblock;\r\nBUILD_BUG_ON(sizeof(struct cache_disk_superblock) > 512);\r\nif (separate_dirty_bits(cmd)) {\r\nr = dm_bitset_flush(&cmd->dirty_info, cmd->dirty_root,\r\n&cmd->dirty_root);\r\nif (r)\r\nreturn r;\r\n}\r\nr = dm_bitset_flush(&cmd->discard_info, cmd->discard_root,\r\n&cmd->discard_root);\r\nif (r)\r\nreturn r;\r\nr = dm_tm_pre_commit(cmd->tm);\r\nif (r < 0)\r\nreturn r;\r\nr = __save_sm_root(cmd);\r\nif (r)\r\nreturn r;\r\nr = superblock_lock(cmd, &sblock);\r\nif (r)\r\nreturn r;\r\ndisk_super = dm_block_data(sblock);\r\ndisk_super->flags = cpu_to_le32(cmd->flags);\r\nif (mutator)\r\nupdate_flags(disk_super, mutator);\r\ndisk_super->mapping_root = cpu_to_le64(cmd->root);\r\nif (separate_dirty_bits(cmd))\r\ndisk_super->dirty_root = cpu_to_le64(cmd->dirty_root);\r\ndisk_super->hint_root = cpu_to_le64(cmd->hint_root);\r\ndisk_super->discard_root = cpu_to_le64(cmd->discard_root);\r\ndisk_super->discard_block_size = cpu_to_le64(cmd->discard_block_size);\r\ndisk_super->discard_nr_blocks = cpu_to_le64(from_dblock(cmd->discard_nr_blocks));\r\ndisk_super->cache_blocks = cpu_to_le32(from_cblock(cmd->cache_blocks));\r\nstrncpy(disk_super->policy_name, cmd->policy_name, sizeof(disk_super->policy_name));\r\ndisk_super->policy_version[0] = cpu_to_le32(cmd->policy_version[0]);\r\ndisk_super->policy_version[1] = cpu_to_le32(cmd->policy_version[1]);\r\ndisk_super->policy_version[2] = cpu_to_le32(cmd->policy_version[2]);\r\ndisk_super->read_hits = cpu_to_le32(cmd->stats.read_hits);\r\ndisk_super->read_misses = cpu_to_le32(cmd->stats.read_misses);\r\ndisk_super->write_hits = cpu_to_le32(cmd->stats.write_hits);\r\ndisk_super->write_misses = cpu_to_le32(cmd->stats.write_misses);\r\n__copy_sm_root(cmd, disk_super);\r\nreturn dm_tm_commit(cmd->tm, sblock);\r\n}\r\nstatic __le64 pack_value(dm_oblock_t block, unsigned flags)\r\n{\r\nuint64_t value = from_oblock(block);\r\nvalue <<= 16;\r\nvalue = value | (flags & FLAGS_MASK);\r\nreturn cpu_to_le64(value);\r\n}\r\nstatic void unpack_value(__le64 value_le, dm_oblock_t *block, unsigned *flags)\r\n{\r\nuint64_t value = le64_to_cpu(value_le);\r\nuint64_t b = value >> 16;\r\n*block = to_oblock(b);\r\n*flags = value & FLAGS_MASK;\r\n}\r\nstatic struct dm_cache_metadata *metadata_open(struct block_device *bdev,\r\nsector_t data_block_size,\r\nbool may_format_device,\r\nsize_t policy_hint_size,\r\nunsigned metadata_version)\r\n{\r\nint r;\r\nstruct dm_cache_metadata *cmd;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (!cmd) {\r\nDMERR("could not allocate metadata struct");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ncmd->version = metadata_version;\r\natomic_set(&cmd->ref_count, 1);\r\ninit_rwsem(&cmd->root_lock);\r\ncmd->bdev = bdev;\r\ncmd->data_block_size = data_block_size;\r\ncmd->cache_blocks = 0;\r\ncmd->policy_hint_size = policy_hint_size;\r\ncmd->changed = true;\r\ncmd->fail_io = false;\r\nr = __create_persistent_data_objects(cmd, may_format_device);\r\nif (r) {\r\nkfree(cmd);\r\nreturn ERR_PTR(r);\r\n}\r\nr = __begin_transaction_flags(cmd, clear_clean_shutdown);\r\nif (r < 0) {\r\ndm_cache_metadata_close(cmd);\r\nreturn ERR_PTR(r);\r\n}\r\nreturn cmd;\r\n}\r\nstatic struct dm_cache_metadata *lookup(struct block_device *bdev)\r\n{\r\nstruct dm_cache_metadata *cmd;\r\nlist_for_each_entry(cmd, &table, list)\r\nif (cmd->bdev == bdev) {\r\natomic_inc(&cmd->ref_count);\r\nreturn cmd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct dm_cache_metadata *lookup_or_open(struct block_device *bdev,\r\nsector_t data_block_size,\r\nbool may_format_device,\r\nsize_t policy_hint_size,\r\nunsigned metadata_version)\r\n{\r\nstruct dm_cache_metadata *cmd, *cmd2;\r\nmutex_lock(&table_lock);\r\ncmd = lookup(bdev);\r\nmutex_unlock(&table_lock);\r\nif (cmd)\r\nreturn cmd;\r\ncmd = metadata_open(bdev, data_block_size, may_format_device,\r\npolicy_hint_size, metadata_version);\r\nif (!IS_ERR(cmd)) {\r\nmutex_lock(&table_lock);\r\ncmd2 = lookup(bdev);\r\nif (cmd2) {\r\nmutex_unlock(&table_lock);\r\n__destroy_persistent_data_objects(cmd);\r\nkfree(cmd);\r\nreturn cmd2;\r\n}\r\nlist_add(&cmd->list, &table);\r\nmutex_unlock(&table_lock);\r\n}\r\nreturn cmd;\r\n}\r\nstatic bool same_params(struct dm_cache_metadata *cmd, sector_t data_block_size)\r\n{\r\nif (cmd->data_block_size != data_block_size) {\r\nDMERR("data_block_size (%llu) different from that in metadata (%llu)",\r\n(unsigned long long) data_block_size,\r\n(unsigned long long) cmd->data_block_size);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstruct dm_cache_metadata *dm_cache_metadata_open(struct block_device *bdev,\r\nsector_t data_block_size,\r\nbool may_format_device,\r\nsize_t policy_hint_size,\r\nunsigned metadata_version)\r\n{\r\nstruct dm_cache_metadata *cmd = lookup_or_open(bdev, data_block_size, may_format_device,\r\npolicy_hint_size, metadata_version);\r\nif (!IS_ERR(cmd) && !same_params(cmd, data_block_size)) {\r\ndm_cache_metadata_close(cmd);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn cmd;\r\n}\r\nvoid dm_cache_metadata_close(struct dm_cache_metadata *cmd)\r\n{\r\nif (atomic_dec_and_test(&cmd->ref_count)) {\r\nmutex_lock(&table_lock);\r\nlist_del(&cmd->list);\r\nmutex_unlock(&table_lock);\r\nif (!cmd->fail_io)\r\n__destroy_persistent_data_objects(cmd);\r\nkfree(cmd);\r\n}\r\n}\r\nstatic int block_clean_combined_dirty(struct dm_cache_metadata *cmd, dm_cblock_t b,\r\nbool *result)\r\n{\r\nint r;\r\n__le64 value;\r\ndm_oblock_t ob;\r\nunsigned flags;\r\nr = dm_array_get_value(&cmd->info, cmd->root, from_cblock(b), &value);\r\nif (r)\r\nreturn r;\r\nunpack_value(value, &ob, &flags);\r\n*result = !((flags & M_VALID) && (flags & M_DIRTY));\r\nreturn 0;\r\n}\r\nstatic int blocks_are_clean_combined_dirty(struct dm_cache_metadata *cmd,\r\ndm_cblock_t begin, dm_cblock_t end,\r\nbool *result)\r\n{\r\nint r;\r\n*result = true;\r\nwhile (begin != end) {\r\nr = block_clean_combined_dirty(cmd, begin, result);\r\nif (r) {\r\nDMERR("block_clean_combined_dirty failed");\r\nreturn r;\r\n}\r\nif (!*result) {\r\nDMERR("cache block %llu is dirty",\r\n(unsigned long long) from_cblock(begin));\r\nreturn 0;\r\n}\r\nbegin = to_cblock(from_cblock(begin) + 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int blocks_are_clean_separate_dirty(struct dm_cache_metadata *cmd,\r\ndm_cblock_t begin, dm_cblock_t end,\r\nbool *result)\r\n{\r\nint r;\r\nbool dirty_flag;\r\n*result = true;\r\nr = dm_bitset_cursor_begin(&cmd->dirty_info, cmd->dirty_root,\r\nfrom_cblock(cmd->cache_blocks), &cmd->dirty_cursor);\r\nif (r) {\r\nDMERR("%s: dm_bitset_cursor_begin for dirty failed", __func__);\r\nreturn r;\r\n}\r\nr = dm_bitset_cursor_skip(&cmd->dirty_cursor, from_cblock(begin));\r\nif (r) {\r\nDMERR("%s: dm_bitset_cursor_skip for dirty failed", __func__);\r\ndm_bitset_cursor_end(&cmd->dirty_cursor);\r\nreturn r;\r\n}\r\nwhile (begin != end) {\r\ndirty_flag = dm_bitset_cursor_get_value(&cmd->dirty_cursor);\r\nif (dirty_flag) {\r\nDMERR("%s: cache block %llu is dirty", __func__,\r\n(unsigned long long) from_cblock(begin));\r\ndm_bitset_cursor_end(&cmd->dirty_cursor);\r\n*result = false;\r\nreturn 0;\r\n}\r\nbegin = to_cblock(from_cblock(begin) + 1);\r\nif (begin == end)\r\nbreak;\r\nr = dm_bitset_cursor_next(&cmd->dirty_cursor);\r\nif (r) {\r\nDMERR("%s: dm_bitset_cursor_next for dirty failed", __func__);\r\ndm_bitset_cursor_end(&cmd->dirty_cursor);\r\nreturn r;\r\n}\r\n}\r\ndm_bitset_cursor_end(&cmd->dirty_cursor);\r\nreturn 0;\r\n}\r\nstatic int blocks_are_unmapped_or_clean(struct dm_cache_metadata *cmd,\r\ndm_cblock_t begin, dm_cblock_t end,\r\nbool *result)\r\n{\r\nif (separate_dirty_bits(cmd))\r\nreturn blocks_are_clean_separate_dirty(cmd, begin, end, result);\r\nelse\r\nreturn blocks_are_clean_combined_dirty(cmd, begin, end, result);\r\n}\r\nstatic bool cmd_write_lock(struct dm_cache_metadata *cmd)\r\n{\r\ndown_write(&cmd->root_lock);\r\nif (cmd->fail_io || dm_bm_is_read_only(cmd->bm)) {\r\nup_write(&cmd->root_lock);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool cmd_read_lock(struct dm_cache_metadata *cmd)\r\n{\r\ndown_read(&cmd->root_lock);\r\nif (cmd->fail_io) {\r\nup_read(&cmd->root_lock);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nint dm_cache_resize(struct dm_cache_metadata *cmd, dm_cblock_t new_cache_size)\r\n{\r\nint r;\r\nbool clean;\r\n__le64 null_mapping = pack_value(0, 0);\r\nWRITE_LOCK(cmd);\r\n__dm_bless_for_disk(&null_mapping);\r\nif (from_cblock(new_cache_size) < from_cblock(cmd->cache_blocks)) {\r\nr = blocks_are_unmapped_or_clean(cmd, new_cache_size, cmd->cache_blocks, &clean);\r\nif (r) {\r\n__dm_unbless_for_disk(&null_mapping);\r\ngoto out;\r\n}\r\nif (!clean) {\r\nDMERR("unable to shrink cache due to dirty blocks");\r\nr = -EINVAL;\r\n__dm_unbless_for_disk(&null_mapping);\r\ngoto out;\r\n}\r\n}\r\nr = dm_array_resize(&cmd->info, cmd->root, from_cblock(cmd->cache_blocks),\r\nfrom_cblock(new_cache_size),\r\n&null_mapping, &cmd->root);\r\nif (r)\r\ngoto out;\r\nif (separate_dirty_bits(cmd)) {\r\nr = dm_bitset_resize(&cmd->dirty_info, cmd->dirty_root,\r\nfrom_cblock(cmd->cache_blocks), from_cblock(new_cache_size),\r\nfalse, &cmd->dirty_root);\r\nif (r)\r\ngoto out;\r\n}\r\ncmd->cache_blocks = new_cache_size;\r\ncmd->changed = true;\r\nout:\r\nWRITE_UNLOCK(cmd);\r\nreturn r;\r\n}\r\nint dm_cache_discard_bitset_resize(struct dm_cache_metadata *cmd,\r\nsector_t discard_block_size,\r\ndm_dblock_t new_nr_entries)\r\n{\r\nint r;\r\nWRITE_LOCK(cmd);\r\nr = dm_bitset_resize(&cmd->discard_info,\r\ncmd->discard_root,\r\nfrom_dblock(cmd->discard_nr_blocks),\r\nfrom_dblock(new_nr_entries),\r\nfalse, &cmd->discard_root);\r\nif (!r) {\r\ncmd->discard_block_size = discard_block_size;\r\ncmd->discard_nr_blocks = new_nr_entries;\r\n}\r\ncmd->changed = true;\r\nWRITE_UNLOCK(cmd);\r\nreturn r;\r\n}\r\nstatic int __set_discard(struct dm_cache_metadata *cmd, dm_dblock_t b)\r\n{\r\nreturn dm_bitset_set_bit(&cmd->discard_info, cmd->discard_root,\r\nfrom_dblock(b), &cmd->discard_root);\r\n}\r\nstatic int __clear_discard(struct dm_cache_metadata *cmd, dm_dblock_t b)\r\n{\r\nreturn dm_bitset_clear_bit(&cmd->discard_info, cmd->discard_root,\r\nfrom_dblock(b), &cmd->discard_root);\r\n}\r\nstatic int __discard(struct dm_cache_metadata *cmd,\r\ndm_dblock_t dblock, bool discard)\r\n{\r\nint r;\r\nr = (discard ? __set_discard : __clear_discard)(cmd, dblock);\r\nif (r)\r\nreturn r;\r\ncmd->changed = true;\r\nreturn 0;\r\n}\r\nint dm_cache_set_discard(struct dm_cache_metadata *cmd,\r\ndm_dblock_t dblock, bool discard)\r\n{\r\nint r;\r\nWRITE_LOCK(cmd);\r\nr = __discard(cmd, dblock, discard);\r\nWRITE_UNLOCK(cmd);\r\nreturn r;\r\n}\r\nstatic int __load_discards(struct dm_cache_metadata *cmd,\r\nload_discard_fn fn, void *context)\r\n{\r\nint r = 0;\r\nuint32_t b;\r\nstruct dm_bitset_cursor c;\r\nif (from_dblock(cmd->discard_nr_blocks) == 0)\r\nreturn 0;\r\nif (cmd->clean_when_opened) {\r\nr = dm_bitset_flush(&cmd->discard_info, cmd->discard_root, &cmd->discard_root);\r\nif (r)\r\nreturn r;\r\nr = dm_bitset_cursor_begin(&cmd->discard_info, cmd->discard_root,\r\nfrom_dblock(cmd->discard_nr_blocks), &c);\r\nif (r)\r\nreturn r;\r\nfor (b = 0; b < from_dblock(cmd->discard_nr_blocks); b++) {\r\nr = fn(context, cmd->discard_block_size, to_dblock(b),\r\ndm_bitset_cursor_get_value(&c));\r\nif (r)\r\nbreak;\r\n}\r\ndm_bitset_cursor_end(&c);\r\n} else {\r\nfor (b = 0; b < from_dblock(cmd->discard_nr_blocks); b++) {\r\nr = fn(context, cmd->discard_block_size, to_dblock(b), false);\r\nif (r)\r\nreturn r;\r\n}\r\n}\r\nreturn r;\r\n}\r\nint dm_cache_load_discards(struct dm_cache_metadata *cmd,\r\nload_discard_fn fn, void *context)\r\n{\r\nint r;\r\nREAD_LOCK(cmd);\r\nr = __load_discards(cmd, fn, context);\r\nREAD_UNLOCK(cmd);\r\nreturn r;\r\n}\r\nint dm_cache_size(struct dm_cache_metadata *cmd, dm_cblock_t *result)\r\n{\r\nREAD_LOCK(cmd);\r\n*result = cmd->cache_blocks;\r\nREAD_UNLOCK(cmd);\r\nreturn 0;\r\n}\r\nstatic int __remove(struct dm_cache_metadata *cmd, dm_cblock_t cblock)\r\n{\r\nint r;\r\n__le64 value = pack_value(0, 0);\r\n__dm_bless_for_disk(&value);\r\nr = dm_array_set_value(&cmd->info, cmd->root, from_cblock(cblock),\r\n&value, &cmd->root);\r\nif (r)\r\nreturn r;\r\ncmd->changed = true;\r\nreturn 0;\r\n}\r\nint dm_cache_remove_mapping(struct dm_cache_metadata *cmd, dm_cblock_t cblock)\r\n{\r\nint r;\r\nWRITE_LOCK(cmd);\r\nr = __remove(cmd, cblock);\r\nWRITE_UNLOCK(cmd);\r\nreturn r;\r\n}\r\nstatic int __insert(struct dm_cache_metadata *cmd,\r\ndm_cblock_t cblock, dm_oblock_t oblock)\r\n{\r\nint r;\r\n__le64 value = pack_value(oblock, M_VALID);\r\n__dm_bless_for_disk(&value);\r\nr = dm_array_set_value(&cmd->info, cmd->root, from_cblock(cblock),\r\n&value, &cmd->root);\r\nif (r)\r\nreturn r;\r\ncmd->changed = true;\r\nreturn 0;\r\n}\r\nint dm_cache_insert_mapping(struct dm_cache_metadata *cmd,\r\ndm_cblock_t cblock, dm_oblock_t oblock)\r\n{\r\nint r;\r\nWRITE_LOCK(cmd);\r\nr = __insert(cmd, cblock, oblock);\r\nWRITE_UNLOCK(cmd);\r\nreturn r;\r\n}\r\nstatic bool policy_unchanged(struct dm_cache_metadata *cmd,\r\nstruct dm_cache_policy *policy)\r\n{\r\nconst char *policy_name = dm_cache_policy_get_name(policy);\r\nconst unsigned *policy_version = dm_cache_policy_get_version(policy);\r\nsize_t policy_hint_size = dm_cache_policy_get_hint_size(policy);\r\nif (strncmp(cmd->policy_name, policy_name, sizeof(cmd->policy_name)))\r\nreturn false;\r\nif (cmd->policy_version[0] != policy_version[0])\r\nreturn false;\r\nif (cmd->policy_hint_size != policy_hint_size)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool hints_array_initialized(struct dm_cache_metadata *cmd)\r\n{\r\nreturn cmd->hint_root && cmd->policy_hint_size;\r\n}\r\nstatic bool hints_array_available(struct dm_cache_metadata *cmd,\r\nstruct dm_cache_policy *policy)\r\n{\r\nreturn cmd->clean_when_opened && policy_unchanged(cmd, policy) &&\r\nhints_array_initialized(cmd);\r\n}\r\nstatic int __load_mapping_v1(struct dm_cache_metadata *cmd,\r\nuint64_t cb, bool hints_valid,\r\nstruct dm_array_cursor *mapping_cursor,\r\nstruct dm_array_cursor *hint_cursor,\r\nload_mapping_fn fn, void *context)\r\n{\r\nint r = 0;\r\n__le64 mapping;\r\n__le32 hint = 0;\r\n__le64 *mapping_value_le;\r\n__le32 *hint_value_le;\r\ndm_oblock_t oblock;\r\nunsigned flags;\r\ndm_array_cursor_get_value(mapping_cursor, (void **) &mapping_value_le);\r\nmemcpy(&mapping, mapping_value_le, sizeof(mapping));\r\nunpack_value(mapping, &oblock, &flags);\r\nif (flags & M_VALID) {\r\nif (hints_valid) {\r\ndm_array_cursor_get_value(hint_cursor, (void **) &hint_value_le);\r\nmemcpy(&hint, hint_value_le, sizeof(hint));\r\n}\r\nr = fn(context, oblock, to_cblock(cb), flags & M_DIRTY,\r\nle32_to_cpu(hint), hints_valid);\r\nif (r) {\r\nDMERR("policy couldn't load cache block %llu",\r\n(unsigned long long) from_cblock(to_cblock(cb)));\r\n}\r\n}\r\nreturn r;\r\n}\r\nstatic int __load_mapping_v2(struct dm_cache_metadata *cmd,\r\nuint64_t cb, bool hints_valid,\r\nstruct dm_array_cursor *mapping_cursor,\r\nstruct dm_array_cursor *hint_cursor,\r\nstruct dm_bitset_cursor *dirty_cursor,\r\nload_mapping_fn fn, void *context)\r\n{\r\nint r = 0;\r\n__le64 mapping;\r\n__le32 hint = 0;\r\n__le64 *mapping_value_le;\r\n__le32 *hint_value_le;\r\ndm_oblock_t oblock;\r\nunsigned flags;\r\nbool dirty;\r\ndm_array_cursor_get_value(mapping_cursor, (void **) &mapping_value_le);\r\nmemcpy(&mapping, mapping_value_le, sizeof(mapping));\r\nunpack_value(mapping, &oblock, &flags);\r\nif (flags & M_VALID) {\r\nif (hints_valid) {\r\ndm_array_cursor_get_value(hint_cursor, (void **) &hint_value_le);\r\nmemcpy(&hint, hint_value_le, sizeof(hint));\r\n}\r\ndirty = dm_bitset_cursor_get_value(dirty_cursor);\r\nr = fn(context, oblock, to_cblock(cb), dirty,\r\nle32_to_cpu(hint), hints_valid);\r\nif (r) {\r\nDMERR("policy couldn't load cache block %llu",\r\n(unsigned long long) from_cblock(to_cblock(cb)));\r\n}\r\n}\r\nreturn r;\r\n}\r\nstatic int __load_mappings(struct dm_cache_metadata *cmd,\r\nstruct dm_cache_policy *policy,\r\nload_mapping_fn fn, void *context)\r\n{\r\nint r;\r\nuint64_t cb;\r\nbool hints_valid = hints_array_available(cmd, policy);\r\nif (from_cblock(cmd->cache_blocks) == 0)\r\nreturn 0;\r\nr = dm_array_cursor_begin(&cmd->info, cmd->root, &cmd->mapping_cursor);\r\nif (r)\r\nreturn r;\r\nif (hints_valid) {\r\nr = dm_array_cursor_begin(&cmd->hint_info, cmd->hint_root, &cmd->hint_cursor);\r\nif (r) {\r\ndm_array_cursor_end(&cmd->mapping_cursor);\r\nreturn r;\r\n}\r\n}\r\nif (separate_dirty_bits(cmd)) {\r\nr = dm_bitset_cursor_begin(&cmd->dirty_info, cmd->dirty_root,\r\nfrom_cblock(cmd->cache_blocks),\r\n&cmd->dirty_cursor);\r\nif (r) {\r\ndm_array_cursor_end(&cmd->hint_cursor);\r\ndm_array_cursor_end(&cmd->mapping_cursor);\r\nreturn r;\r\n}\r\n}\r\nfor (cb = 0; ; cb++) {\r\nif (separate_dirty_bits(cmd))\r\nr = __load_mapping_v2(cmd, cb, hints_valid,\r\n&cmd->mapping_cursor,\r\n&cmd->hint_cursor,\r\n&cmd->dirty_cursor,\r\nfn, context);\r\nelse\r\nr = __load_mapping_v1(cmd, cb, hints_valid,\r\n&cmd->mapping_cursor, &cmd->hint_cursor,\r\nfn, context);\r\nif (r)\r\ngoto out;\r\nif (cb >= (from_cblock(cmd->cache_blocks) - 1))\r\nbreak;\r\nr = dm_array_cursor_next(&cmd->mapping_cursor);\r\nif (r) {\r\nDMERR("dm_array_cursor_next for mapping failed");\r\ngoto out;\r\n}\r\nif (hints_valid) {\r\nr = dm_array_cursor_next(&cmd->hint_cursor);\r\nif (r) {\r\nDMERR("dm_array_cursor_next for hint failed");\r\ngoto out;\r\n}\r\n}\r\nif (separate_dirty_bits(cmd)) {\r\nr = dm_bitset_cursor_next(&cmd->dirty_cursor);\r\nif (r) {\r\nDMERR("dm_bitset_cursor_next for dirty failed");\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\ndm_array_cursor_end(&cmd->mapping_cursor);\r\nif (hints_valid)\r\ndm_array_cursor_end(&cmd->hint_cursor);\r\nif (separate_dirty_bits(cmd))\r\ndm_bitset_cursor_end(&cmd->dirty_cursor);\r\nreturn r;\r\n}\r\nint dm_cache_load_mappings(struct dm_cache_metadata *cmd,\r\nstruct dm_cache_policy *policy,\r\nload_mapping_fn fn, void *context)\r\n{\r\nint r;\r\nREAD_LOCK(cmd);\r\nr = __load_mappings(cmd, policy, fn, context);\r\nREAD_UNLOCK(cmd);\r\nreturn r;\r\n}\r\nstatic int __dump_mapping(void *context, uint64_t cblock, void *leaf)\r\n{\r\nint r = 0;\r\n__le64 value;\r\ndm_oblock_t oblock;\r\nunsigned flags;\r\nmemcpy(&value, leaf, sizeof(value));\r\nunpack_value(value, &oblock, &flags);\r\nreturn r;\r\n}\r\nstatic int __dump_mappings(struct dm_cache_metadata *cmd)\r\n{\r\nreturn dm_array_walk(&cmd->info, cmd->root, __dump_mapping, NULL);\r\n}\r\nvoid dm_cache_dump(struct dm_cache_metadata *cmd)\r\n{\r\nREAD_LOCK_VOID(cmd);\r\n__dump_mappings(cmd);\r\nREAD_UNLOCK(cmd);\r\n}\r\nint dm_cache_changed_this_transaction(struct dm_cache_metadata *cmd)\r\n{\r\nint r;\r\nREAD_LOCK(cmd);\r\nr = cmd->changed;\r\nREAD_UNLOCK(cmd);\r\nreturn r;\r\n}\r\nstatic int __dirty(struct dm_cache_metadata *cmd, dm_cblock_t cblock, bool dirty)\r\n{\r\nint r;\r\nunsigned flags;\r\ndm_oblock_t oblock;\r\n__le64 value;\r\nr = dm_array_get_value(&cmd->info, cmd->root, from_cblock(cblock), &value);\r\nif (r)\r\nreturn r;\r\nunpack_value(value, &oblock, &flags);\r\nif (((flags & M_DIRTY) && dirty) || (!(flags & M_DIRTY) && !dirty))\r\nreturn 0;\r\nvalue = pack_value(oblock, (flags & ~M_DIRTY) | (dirty ? M_DIRTY : 0));\r\n__dm_bless_for_disk(&value);\r\nr = dm_array_set_value(&cmd->info, cmd->root, from_cblock(cblock),\r\n&value, &cmd->root);\r\nif (r)\r\nreturn r;\r\ncmd->changed = true;\r\nreturn 0;\r\n}\r\nstatic int __set_dirty_bits_v1(struct dm_cache_metadata *cmd, unsigned nr_bits, unsigned long *bits)\r\n{\r\nint r;\r\nunsigned i;\r\nfor (i = 0; i < nr_bits; i++) {\r\nr = __dirty(cmd, to_cblock(i), test_bit(i, bits));\r\nif (r)\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int is_dirty_callback(uint32_t index, bool *value, void *context)\r\n{\r\nunsigned long *bits = context;\r\n*value = test_bit(index, bits);\r\nreturn 0;\r\n}\r\nstatic int __set_dirty_bits_v2(struct dm_cache_metadata *cmd, unsigned nr_bits, unsigned long *bits)\r\n{\r\nint r = 0;\r\nif (nr_bits != from_cblock(cmd->cache_blocks)) {\r\nDMERR("dirty bitset is wrong size");\r\nreturn -EINVAL;\r\n}\r\nr = dm_bitset_del(&cmd->dirty_info, cmd->dirty_root);\r\nif (r)\r\nreturn r;\r\ncmd->changed = true;\r\nreturn dm_bitset_new(&cmd->dirty_info, &cmd->dirty_root, nr_bits, is_dirty_callback, bits);\r\n}\r\nint dm_cache_set_dirty_bits(struct dm_cache_metadata *cmd,\r\nunsigned nr_bits,\r\nunsigned long *bits)\r\n{\r\nint r;\r\nWRITE_LOCK(cmd);\r\nif (separate_dirty_bits(cmd))\r\nr = __set_dirty_bits_v2(cmd, nr_bits, bits);\r\nelse\r\nr = __set_dirty_bits_v1(cmd, nr_bits, bits);\r\nWRITE_UNLOCK(cmd);\r\nreturn r;\r\n}\r\nvoid dm_cache_metadata_get_stats(struct dm_cache_metadata *cmd,\r\nstruct dm_cache_statistics *stats)\r\n{\r\nREAD_LOCK_VOID(cmd);\r\n*stats = cmd->stats;\r\nREAD_UNLOCK(cmd);\r\n}\r\nvoid dm_cache_metadata_set_stats(struct dm_cache_metadata *cmd,\r\nstruct dm_cache_statistics *stats)\r\n{\r\nWRITE_LOCK_VOID(cmd);\r\ncmd->stats = *stats;\r\nWRITE_UNLOCK(cmd);\r\n}\r\nint dm_cache_commit(struct dm_cache_metadata *cmd, bool clean_shutdown)\r\n{\r\nint r = -EINVAL;\r\nflags_mutator mutator = (clean_shutdown ? set_clean_shutdown :\r\nclear_clean_shutdown);\r\nWRITE_LOCK(cmd);\r\nif (cmd->fail_io)\r\ngoto out;\r\nr = __commit_transaction(cmd, mutator);\r\nif (r)\r\ngoto out;\r\nr = __begin_transaction(cmd);\r\nout:\r\nWRITE_UNLOCK(cmd);\r\nreturn r;\r\n}\r\nint dm_cache_get_free_metadata_block_count(struct dm_cache_metadata *cmd,\r\ndm_block_t *result)\r\n{\r\nint r = -EINVAL;\r\nREAD_LOCK(cmd);\r\nif (!cmd->fail_io)\r\nr = dm_sm_get_nr_free(cmd->metadata_sm, result);\r\nREAD_UNLOCK(cmd);\r\nreturn r;\r\n}\r\nint dm_cache_get_metadata_dev_size(struct dm_cache_metadata *cmd,\r\ndm_block_t *result)\r\n{\r\nint r = -EINVAL;\r\nREAD_LOCK(cmd);\r\nif (!cmd->fail_io)\r\nr = dm_sm_get_nr_blocks(cmd->metadata_sm, result);\r\nREAD_UNLOCK(cmd);\r\nreturn r;\r\n}\r\nstatic int get_hint(uint32_t index, void *value_le, void *context)\r\n{\r\nuint32_t value;\r\nstruct dm_cache_policy *policy = context;\r\nvalue = policy_get_hint(policy, to_cblock(index));\r\n*((__le32 *) value_le) = cpu_to_le32(value);\r\nreturn 0;\r\n}\r\nstatic int write_hints(struct dm_cache_metadata *cmd, struct dm_cache_policy *policy)\r\n{\r\nint r;\r\nsize_t hint_size;\r\nconst char *policy_name = dm_cache_policy_get_name(policy);\r\nconst unsigned *policy_version = dm_cache_policy_get_version(policy);\r\nif (!policy_name[0] ||\r\n(strlen(policy_name) > sizeof(cmd->policy_name) - 1))\r\nreturn -EINVAL;\r\nstrncpy(cmd->policy_name, policy_name, sizeof(cmd->policy_name));\r\nmemcpy(cmd->policy_version, policy_version, sizeof(cmd->policy_version));\r\nhint_size = dm_cache_policy_get_hint_size(policy);\r\nif (!hint_size)\r\nreturn 0;\r\ncmd->policy_hint_size = hint_size;\r\nif (cmd->hint_root) {\r\nr = dm_array_del(&cmd->hint_info, cmd->hint_root);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn dm_array_new(&cmd->hint_info, &cmd->hint_root,\r\nfrom_cblock(cmd->cache_blocks),\r\nget_hint, policy);\r\n}\r\nint dm_cache_write_hints(struct dm_cache_metadata *cmd, struct dm_cache_policy *policy)\r\n{\r\nint r;\r\nWRITE_LOCK(cmd);\r\nr = write_hints(cmd, policy);\r\nWRITE_UNLOCK(cmd);\r\nreturn r;\r\n}\r\nint dm_cache_metadata_all_clean(struct dm_cache_metadata *cmd, bool *result)\r\n{\r\nint r;\r\nREAD_LOCK(cmd);\r\nr = blocks_are_unmapped_or_clean(cmd, 0, cmd->cache_blocks, result);\r\nREAD_UNLOCK(cmd);\r\nreturn r;\r\n}\r\nvoid dm_cache_metadata_set_read_only(struct dm_cache_metadata *cmd)\r\n{\r\nWRITE_LOCK_VOID(cmd);\r\ndm_bm_set_read_only(cmd->bm);\r\nWRITE_UNLOCK(cmd);\r\n}\r\nvoid dm_cache_metadata_set_read_write(struct dm_cache_metadata *cmd)\r\n{\r\nWRITE_LOCK_VOID(cmd);\r\ndm_bm_set_read_write(cmd->bm);\r\nWRITE_UNLOCK(cmd);\r\n}\r\nint dm_cache_metadata_set_needs_check(struct dm_cache_metadata *cmd)\r\n{\r\nint r;\r\nstruct dm_block *sblock;\r\nstruct cache_disk_superblock *disk_super;\r\nWRITE_LOCK(cmd);\r\nset_bit(NEEDS_CHECK, &cmd->flags);\r\nr = superblock_lock(cmd, &sblock);\r\nif (r) {\r\nDMERR("couldn't read superblock");\r\ngoto out;\r\n}\r\ndisk_super = dm_block_data(sblock);\r\ndisk_super->flags = cpu_to_le32(cmd->flags);\r\ndm_bm_unlock(sblock);\r\nout:\r\nWRITE_UNLOCK(cmd);\r\nreturn r;\r\n}\r\nint dm_cache_metadata_needs_check(struct dm_cache_metadata *cmd, bool *result)\r\n{\r\nREAD_LOCK(cmd);\r\n*result = !!test_bit(NEEDS_CHECK, &cmd->flags);\r\nREAD_UNLOCK(cmd);\r\nreturn 0;\r\n}\r\nint dm_cache_metadata_abort(struct dm_cache_metadata *cmd)\r\n{\r\nint r;\r\nWRITE_LOCK(cmd);\r\n__destroy_persistent_data_objects(cmd);\r\nr = __create_persistent_data_objects(cmd, false);\r\nif (r)\r\ncmd->fail_io = true;\r\nWRITE_UNLOCK(cmd);\r\nreturn r;\r\n}
