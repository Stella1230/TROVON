static inline struct tcpci *tcpc_to_tcpci(struct tcpc_dev *tcpc)\r\n{\r\nreturn container_of(tcpc, struct tcpci, tcpc);\r\n}\r\nstatic int tcpci_read16(struct tcpci *tcpci, unsigned int reg,\r\nunsigned int *val)\r\n{\r\nreturn regmap_raw_read(tcpci->regmap, reg, val, sizeof(u16));\r\n}\r\nstatic int tcpci_write16(struct tcpci *tcpci, unsigned int reg, u16 val)\r\n{\r\nreturn regmap_raw_write(tcpci->regmap, reg, &val, sizeof(u16));\r\n}\r\nstatic int tcpci_set_cc(struct tcpc_dev *tcpc, enum typec_cc_status cc)\r\n{\r\nstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\r\nunsigned int reg;\r\nint ret;\r\nswitch (cc) {\r\ncase TYPEC_CC_RA:\r\nreg = (TCPC_ROLE_CTRL_CC_RA << TCPC_ROLE_CTRL_CC1_SHIFT) |\r\n(TCPC_ROLE_CTRL_CC_RA << TCPC_ROLE_CTRL_CC2_SHIFT);\r\nbreak;\r\ncase TYPEC_CC_RD:\r\nreg = (TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC1_SHIFT) |\r\n(TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC2_SHIFT);\r\nbreak;\r\ncase TYPEC_CC_RP_DEF:\r\nreg = (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC1_SHIFT) |\r\n(TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC2_SHIFT) |\r\n(TCPC_ROLE_CTRL_RP_VAL_DEF <<\r\nTCPC_ROLE_CTRL_RP_VAL_SHIFT);\r\nbreak;\r\ncase TYPEC_CC_RP_1_5:\r\nreg = (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC1_SHIFT) |\r\n(TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC2_SHIFT) |\r\n(TCPC_ROLE_CTRL_RP_VAL_1_5 <<\r\nTCPC_ROLE_CTRL_RP_VAL_SHIFT);\r\nbreak;\r\ncase TYPEC_CC_RP_3_0:\r\nreg = (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC1_SHIFT) |\r\n(TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC2_SHIFT) |\r\n(TCPC_ROLE_CTRL_RP_VAL_3_0 <<\r\nTCPC_ROLE_CTRL_RP_VAL_SHIFT);\r\nbreak;\r\ncase TYPEC_CC_OPEN:\r\ndefault:\r\nreg = (TCPC_ROLE_CTRL_CC_OPEN << TCPC_ROLE_CTRL_CC1_SHIFT) |\r\n(TCPC_ROLE_CTRL_CC_OPEN << TCPC_ROLE_CTRL_CC2_SHIFT);\r\nbreak;\r\n}\r\nret = regmap_write(tcpci->regmap, TCPC_ROLE_CTRL, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int tcpci_start_drp_toggling(struct tcpc_dev *tcpc,\r\nenum typec_cc_status cc)\r\n{\r\nstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\r\nunsigned int reg = TCPC_ROLE_CTRL_DRP;\r\nswitch (cc) {\r\ndefault:\r\ncase TYPEC_CC_RP_DEF:\r\nreg |= (TCPC_ROLE_CTRL_RP_VAL_DEF <<\r\nTCPC_ROLE_CTRL_RP_VAL_SHIFT);\r\nbreak;\r\ncase TYPEC_CC_RP_1_5:\r\nreg |= (TCPC_ROLE_CTRL_RP_VAL_1_5 <<\r\nTCPC_ROLE_CTRL_RP_VAL_SHIFT);\r\nbreak;\r\ncase TYPEC_CC_RP_3_0:\r\nreg |= (TCPC_ROLE_CTRL_RP_VAL_3_0 <<\r\nTCPC_ROLE_CTRL_RP_VAL_SHIFT);\r\nbreak;\r\n}\r\nreturn regmap_write(tcpci->regmap, TCPC_ROLE_CTRL, reg);\r\n}\r\nstatic enum typec_cc_status tcpci_to_typec_cc(unsigned int cc, bool sink)\r\n{\r\nswitch (cc) {\r\ncase 0x1:\r\nreturn sink ? TYPEC_CC_RP_DEF : TYPEC_CC_RA;\r\ncase 0x2:\r\nreturn sink ? TYPEC_CC_RP_1_5 : TYPEC_CC_RD;\r\ncase 0x3:\r\nif (sink)\r\nreturn TYPEC_CC_RP_3_0;\r\ncase 0x0:\r\ndefault:\r\nreturn TYPEC_CC_OPEN;\r\n}\r\n}\r\nstatic int tcpci_get_cc(struct tcpc_dev *tcpc,\r\nenum typec_cc_status *cc1, enum typec_cc_status *cc2)\r\n{\r\nstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\r\nunsigned int reg;\r\nint ret;\r\nret = regmap_read(tcpci->regmap, TCPC_CC_STATUS, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\n*cc1 = tcpci_to_typec_cc((reg >> TCPC_CC_STATUS_CC1_SHIFT) &\r\nTCPC_CC_STATUS_CC1_MASK,\r\nreg & TCPC_CC_STATUS_TERM);\r\n*cc2 = tcpci_to_typec_cc((reg >> TCPC_CC_STATUS_CC2_SHIFT) &\r\nTCPC_CC_STATUS_CC2_MASK,\r\nreg & TCPC_CC_STATUS_TERM);\r\nreturn 0;\r\n}\r\nstatic int tcpci_set_polarity(struct tcpc_dev *tcpc,\r\nenum typec_cc_polarity polarity)\r\n{\r\nstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\r\nint ret;\r\nret = regmap_write(tcpci->regmap, TCPC_TCPC_CTRL,\r\n(polarity == TYPEC_POLARITY_CC2) ?\r\nTCPC_TCPC_CTRL_ORIENTATION : 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int tcpci_set_vconn(struct tcpc_dev *tcpc, bool enable)\r\n{\r\nstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\r\nint ret;\r\nret = regmap_write(tcpci->regmap, TCPC_POWER_CTRL,\r\nenable ? TCPC_POWER_CTRL_VCONN_ENABLE : 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int tcpci_set_roles(struct tcpc_dev *tcpc, bool attached,\r\nenum typec_role role, enum typec_data_role data)\r\n{\r\nstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\r\nunsigned int reg;\r\nint ret;\r\nreg = PD_REV20 << TCPC_MSG_HDR_INFO_REV_SHIFT;\r\nif (role == TYPEC_SOURCE)\r\nreg |= TCPC_MSG_HDR_INFO_PWR_ROLE;\r\nif (data == TYPEC_HOST)\r\nreg |= TCPC_MSG_HDR_INFO_DATA_ROLE;\r\nret = regmap_write(tcpci->regmap, TCPC_MSG_HDR_INFO, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int tcpci_set_pd_rx(struct tcpc_dev *tcpc, bool enable)\r\n{\r\nstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\r\nunsigned int reg = 0;\r\nint ret;\r\nif (enable)\r\nreg = TCPC_RX_DETECT_SOP | TCPC_RX_DETECT_HARD_RESET;\r\nret = regmap_write(tcpci->regmap, TCPC_RX_DETECT, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int tcpci_get_vbus(struct tcpc_dev *tcpc)\r\n{\r\nstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\r\nunsigned int reg;\r\nint ret;\r\nret = regmap_read(tcpci->regmap, TCPC_POWER_STATUS, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !!(reg & TCPC_POWER_STATUS_VBUS_PRES);\r\n}\r\nstatic int tcpci_set_vbus(struct tcpc_dev *tcpc, bool source, bool sink)\r\n{\r\nstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\r\nint ret;\r\nif (!source) {\r\nret = regmap_write(tcpci->regmap, TCPC_COMMAND,\r\nTCPC_CMD_DISABLE_SRC_VBUS);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (!sink) {\r\nret = regmap_write(tcpci->regmap, TCPC_COMMAND,\r\nTCPC_CMD_DISABLE_SINK_VBUS);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (source) {\r\nret = regmap_write(tcpci->regmap, TCPC_COMMAND,\r\nTCPC_CMD_SRC_VBUS_DEFAULT);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (sink) {\r\nret = regmap_write(tcpci->regmap, TCPC_COMMAND,\r\nTCPC_CMD_SINK_VBUS);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tcpci_pd_transmit(struct tcpc_dev *tcpc,\r\nenum tcpm_transmit_type type,\r\nconst struct pd_message *msg)\r\n{\r\nstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\r\nunsigned int reg, cnt, header;\r\nint ret;\r\ncnt = msg ? pd_header_cnt(msg->header) * 4 : 0;\r\nret = regmap_write(tcpci->regmap, TCPC_TX_BYTE_CNT, cnt + 2);\r\nif (ret < 0)\r\nreturn ret;\r\nheader = msg ? msg->header : 0;\r\nret = tcpci_write16(tcpci, TCPC_TX_HDR, header);\r\nif (ret < 0)\r\nreturn ret;\r\nif (cnt > 0) {\r\nret = regmap_raw_write(tcpci->regmap, TCPC_TX_DATA,\r\n&msg->payload, cnt);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreg = (PD_RETRY_COUNT << TCPC_TRANSMIT_RETRY_SHIFT) |\r\n(type << TCPC_TRANSMIT_TYPE_SHIFT);\r\nret = regmap_write(tcpci->regmap, TCPC_TRANSMIT, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int tcpci_init(struct tcpc_dev *tcpc)\r\n{\r\nstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\r\nunsigned long timeout = jiffies + msecs_to_jiffies(2000);\r\nunsigned int reg;\r\nint ret;\r\nwhile (time_before_eq(jiffies, timeout)) {\r\nret = regmap_read(tcpci->regmap, TCPC_POWER_STATUS, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(reg & TCPC_POWER_STATUS_UNINIT))\r\nbreak;\r\nusleep_range(10000, 20000);\r\n}\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\nret = tcpci_write16(tcpci, TCPC_ALERT, 0xffff);\r\nif (ret < 0)\r\nreturn ret;\r\nif (tcpci->controls_vbus)\r\nreg = TCPC_POWER_STATUS_VBUS_PRES;\r\nelse\r\nreg = 0;\r\nret = regmap_write(tcpci->regmap, TCPC_POWER_STATUS_MASK, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreg = TCPC_ALERT_TX_SUCCESS | TCPC_ALERT_TX_FAILED |\r\nTCPC_ALERT_TX_DISCARDED | TCPC_ALERT_RX_STATUS |\r\nTCPC_ALERT_RX_HARD_RST | TCPC_ALERT_CC_STATUS;\r\nif (tcpci->controls_vbus)\r\nreg |= TCPC_ALERT_POWER_STATUS;\r\nreturn tcpci_write16(tcpci, TCPC_ALERT_MASK, reg);\r\n}\r\nstatic irqreturn_t tcpci_irq(int irq, void *dev_id)\r\n{\r\nstruct tcpci *tcpci = dev_id;\r\nunsigned int status, reg;\r\ntcpci_read16(tcpci, TCPC_ALERT, &status);\r\nif (status & ~TCPC_ALERT_RX_STATUS)\r\ntcpci_write16(tcpci, TCPC_ALERT,\r\nstatus & ~TCPC_ALERT_RX_STATUS);\r\nif (status & TCPC_ALERT_CC_STATUS)\r\ntcpm_cc_change(tcpci->port);\r\nif (status & TCPC_ALERT_POWER_STATUS) {\r\nregmap_read(tcpci->regmap, TCPC_POWER_STATUS_MASK, &reg);\r\nif (reg == 0xff)\r\ntcpm_tcpc_reset(tcpci->port);\r\nelse\r\ntcpm_vbus_change(tcpci->port);\r\n}\r\nif (status & TCPC_ALERT_RX_STATUS) {\r\nstruct pd_message msg;\r\nunsigned int cnt;\r\nregmap_read(tcpci->regmap, TCPC_RX_BYTE_CNT, &cnt);\r\ntcpci_read16(tcpci, TCPC_RX_HDR, &reg);\r\nmsg.header = reg;\r\nif (WARN_ON(cnt > sizeof(msg.payload)))\r\ncnt = sizeof(msg.payload);\r\nif (cnt > 0)\r\nregmap_raw_read(tcpci->regmap, TCPC_RX_DATA,\r\n&msg.payload, cnt);\r\ntcpci_write16(tcpci, TCPC_ALERT, TCPC_ALERT_RX_STATUS);\r\ntcpm_pd_receive(tcpci->port, &msg);\r\n}\r\nif (status & TCPC_ALERT_RX_HARD_RST)\r\ntcpm_pd_hard_reset(tcpci->port);\r\nif (status & TCPC_ALERT_TX_SUCCESS)\r\ntcpm_pd_transmit_complete(tcpci->port, TCPC_TX_SUCCESS);\r\nelse if (status & TCPC_ALERT_TX_DISCARDED)\r\ntcpm_pd_transmit_complete(tcpci->port, TCPC_TX_DISCARDED);\r\nelse if (status & TCPC_ALERT_TX_FAILED)\r\ntcpm_pd_transmit_complete(tcpci->port, TCPC_TX_FAILED);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tcpci_parse_config(struct tcpci *tcpci)\r\n{\r\ntcpci->controls_vbus = true;\r\ntcpci->tcpc.config = &tcpci_tcpc_config;\r\nreturn 0;\r\n}\r\nstatic int tcpci_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *i2c_id)\r\n{\r\nstruct tcpci *tcpci;\r\nint err;\r\ntcpci = devm_kzalloc(&client->dev, sizeof(*tcpci), GFP_KERNEL);\r\nif (!tcpci)\r\nreturn -ENOMEM;\r\ntcpci->client = client;\r\ntcpci->dev = &client->dev;\r\ni2c_set_clientdata(client, tcpci);\r\ntcpci->regmap = devm_regmap_init_i2c(client, &tcpci_regmap_config);\r\nif (IS_ERR(tcpci->regmap))\r\nreturn PTR_ERR(tcpci->regmap);\r\ntcpci->tcpc.init = tcpci_init;\r\ntcpci->tcpc.get_vbus = tcpci_get_vbus;\r\ntcpci->tcpc.set_vbus = tcpci_set_vbus;\r\ntcpci->tcpc.set_cc = tcpci_set_cc;\r\ntcpci->tcpc.get_cc = tcpci_get_cc;\r\ntcpci->tcpc.set_polarity = tcpci_set_polarity;\r\ntcpci->tcpc.set_vconn = tcpci_set_vconn;\r\ntcpci->tcpc.start_drp_toggling = tcpci_start_drp_toggling;\r\ntcpci->tcpc.set_pd_rx = tcpci_set_pd_rx;\r\ntcpci->tcpc.set_roles = tcpci_set_roles;\r\ntcpci->tcpc.pd_transmit = tcpci_pd_transmit;\r\nerr = tcpci_parse_config(tcpci);\r\nif (err < 0)\r\nreturn err;\r\ntcpci_write16(tcpci, TCPC_ALERT_MASK, 0);\r\nerr = devm_request_threaded_irq(tcpci->dev, client->irq, NULL,\r\ntcpci_irq,\r\nIRQF_ONESHOT | IRQF_TRIGGER_LOW,\r\ndev_name(tcpci->dev), tcpci);\r\nif (err < 0)\r\nreturn err;\r\ntcpci->port = tcpm_register_port(tcpci->dev, &tcpci->tcpc);\r\nreturn PTR_ERR_OR_ZERO(tcpci->port);\r\n}\r\nstatic int tcpci_remove(struct i2c_client *client)\r\n{\r\nstruct tcpci *tcpci = i2c_get_clientdata(client);\r\ntcpm_unregister_port(tcpci->port);\r\nreturn 0;\r\n}
