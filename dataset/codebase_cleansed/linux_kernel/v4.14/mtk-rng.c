static int mtk_rng_init(struct hwrng *rng)\r\n{\r\nstruct mtk_rng *priv = to_mtk_rng(rng);\r\nu32 val;\r\nint err;\r\nerr = clk_prepare_enable(priv->clk);\r\nif (err)\r\nreturn err;\r\nval = readl(priv->base + RNG_CTRL);\r\nval |= RNG_EN;\r\nwritel(val, priv->base + RNG_CTRL);\r\nreturn 0;\r\n}\r\nstatic void mtk_rng_cleanup(struct hwrng *rng)\r\n{\r\nstruct mtk_rng *priv = to_mtk_rng(rng);\r\nu32 val;\r\nval = readl(priv->base + RNG_CTRL);\r\nval &= ~RNG_EN;\r\nwritel(val, priv->base + RNG_CTRL);\r\nclk_disable_unprepare(priv->clk);\r\n}\r\nstatic bool mtk_rng_wait_ready(struct hwrng *rng, bool wait)\r\n{\r\nstruct mtk_rng *priv = to_mtk_rng(rng);\r\nint ready;\r\nready = readl(priv->base + RNG_CTRL) & RNG_READY;\r\nif (!ready && wait)\r\nreadl_poll_timeout_atomic(priv->base + RNG_CTRL, ready,\r\nready & RNG_READY, USEC_POLL,\r\nTIMEOUT_POLL);\r\nreturn !!ready;\r\n}\r\nstatic int mtk_rng_read(struct hwrng *rng, void *buf, size_t max, bool wait)\r\n{\r\nstruct mtk_rng *priv = to_mtk_rng(rng);\r\nint retval = 0;\r\npm_runtime_get_sync((struct device *)priv->rng.priv);\r\nwhile (max >= sizeof(u32)) {\r\nif (!mtk_rng_wait_ready(rng, wait))\r\nbreak;\r\n*(u32 *)buf = readl(priv->base + RNG_DATA);\r\nretval += sizeof(u32);\r\nbuf += sizeof(u32);\r\nmax -= sizeof(u32);\r\n}\r\npm_runtime_mark_last_busy((struct device *)priv->rng.priv);\r\npm_runtime_put_sync_autosuspend((struct device *)priv->rng.priv);\r\nreturn retval || !wait ? retval : -EIO;\r\n}\r\nstatic int mtk_rng_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint ret;\r\nstruct mtk_rng *priv;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no iomem resource\n");\r\nreturn -ENXIO;\r\n}\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->rng.name = pdev->name;\r\n#ifndef CONFIG_PM\r\npriv->rng.init = mtk_rng_init;\r\npriv->rng.cleanup = mtk_rng_cleanup;\r\n#endif\r\npriv->rng.read = mtk_rng_read;\r\npriv->rng.priv = (unsigned long)&pdev->dev;\r\npriv->clk = devm_clk_get(&pdev->dev, "rng");\r\nif (IS_ERR(priv->clk)) {\r\nret = PTR_ERR(priv->clk);\r\ndev_err(&pdev->dev, "no clock for device: %d\n", ret);\r\nreturn ret;\r\n}\r\npriv->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(priv->base))\r\nreturn PTR_ERR(priv->base);\r\nret = devm_hwrng_register(&pdev->dev, &priv->rng);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register rng device: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ndev_set_drvdata(&pdev->dev, priv);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, RNG_AUTOSUSPEND_TIMEOUT);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\ndev_info(&pdev->dev, "registered RNG driver\n");\r\nreturn 0;\r\n}\r\nstatic int mtk_rng_runtime_suspend(struct device *dev)\r\n{\r\nstruct mtk_rng *priv = dev_get_drvdata(dev);\r\nmtk_rng_cleanup(&priv->rng);\r\nreturn 0;\r\n}\r\nstatic int mtk_rng_runtime_resume(struct device *dev)\r\n{\r\nstruct mtk_rng *priv = dev_get_drvdata(dev);\r\nreturn mtk_rng_init(&priv->rng);\r\n}
