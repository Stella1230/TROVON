static bool dma_port_match(const struct tb_cfg_request *req,\r\nconst struct ctl_pkg *pkg)\r\n{\r\nu64 route = tb_cfg_get_route(pkg->buffer) & ~BIT_ULL(63);\r\nif (pkg->frame.eof == TB_CFG_PKG_ERROR)\r\nreturn true;\r\nif (pkg->frame.eof != req->response_type)\r\nreturn false;\r\nif (route != tb_cfg_get_route(req->request))\r\nreturn false;\r\nif (pkg->frame.size != req->response_size)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool dma_port_copy(struct tb_cfg_request *req, const struct ctl_pkg *pkg)\r\n{\r\nmemcpy(req->response, pkg->buffer, req->response_size);\r\nreturn true;\r\n}\r\nstatic int dma_port_read(struct tb_ctl *ctl, void *buffer, u64 route,\r\nu32 port, u32 offset, u32 length, int timeout_msec)\r\n{\r\nstruct cfg_read_pkg request = {\r\n.header = tb_cfg_make_header(route),\r\n.addr = {\r\n.seq = 1,\r\n.port = port,\r\n.space = TB_CFG_PORT,\r\n.offset = offset,\r\n.length = length,\r\n},\r\n};\r\nstruct tb_cfg_request *req;\r\nstruct cfg_write_pkg reply;\r\nstruct tb_cfg_result res;\r\nreq = tb_cfg_request_alloc();\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq->match = dma_port_match;\r\nreq->copy = dma_port_copy;\r\nreq->request = &request;\r\nreq->request_size = sizeof(request);\r\nreq->request_type = TB_CFG_PKG_READ;\r\nreq->response = &reply;\r\nreq->response_size = 12 + 4 * length;\r\nreq->response_type = TB_CFG_PKG_READ;\r\nres = tb_cfg_request_sync(ctl, req, timeout_msec);\r\ntb_cfg_request_put(req);\r\nif (res.err)\r\nreturn res.err;\r\nmemcpy(buffer, &reply.data, 4 * length);\r\nreturn 0;\r\n}\r\nstatic int dma_port_write(struct tb_ctl *ctl, const void *buffer, u64 route,\r\nu32 port, u32 offset, u32 length, int timeout_msec)\r\n{\r\nstruct cfg_write_pkg request = {\r\n.header = tb_cfg_make_header(route),\r\n.addr = {\r\n.seq = 1,\r\n.port = port,\r\n.space = TB_CFG_PORT,\r\n.offset = offset,\r\n.length = length,\r\n},\r\n};\r\nstruct tb_cfg_request *req;\r\nstruct cfg_read_pkg reply;\r\nstruct tb_cfg_result res;\r\nmemcpy(&request.data, buffer, length * 4);\r\nreq = tb_cfg_request_alloc();\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq->match = dma_port_match;\r\nreq->copy = dma_port_copy;\r\nreq->request = &request;\r\nreq->request_size = 12 + 4 * length;\r\nreq->request_type = TB_CFG_PKG_WRITE;\r\nreq->response = &reply;\r\nreq->response_size = sizeof(reply);\r\nreq->response_type = TB_CFG_PKG_WRITE;\r\nres = tb_cfg_request_sync(ctl, req, timeout_msec);\r\ntb_cfg_request_put(req);\r\nreturn res.err;\r\n}\r\nstatic int dma_find_port(struct tb_switch *sw)\r\n{\r\nint port, ret;\r\nu32 type;\r\nport = 5;\r\nret = dma_port_read(sw->tb->ctl, &type, tb_route(sw), port, 2, 1,\r\nDMA_PORT_TIMEOUT);\r\nif (!ret && (type & 0xffffff) == TB_TYPE_NHI)\r\nreturn port;\r\nport = 3;\r\nret = dma_port_read(sw->tb->ctl, &type, tb_route(sw), port, 2, 1,\r\nDMA_PORT_TIMEOUT);\r\nif (!ret && (type & 0xffffff) == TB_TYPE_NHI)\r\nreturn port;\r\nreturn -ENODEV;\r\n}\r\nstruct tb_dma_port *dma_port_alloc(struct tb_switch *sw)\r\n{\r\nstruct tb_dma_port *dma;\r\nint port;\r\nport = dma_find_port(sw);\r\nif (port < 0)\r\nreturn NULL;\r\ndma = kzalloc(sizeof(*dma), GFP_KERNEL);\r\nif (!dma)\r\nreturn NULL;\r\ndma->buf = kmalloc_array(MAIL_DATA_DWORDS, sizeof(u32), GFP_KERNEL);\r\nif (!dma->buf) {\r\nkfree(dma);\r\nreturn NULL;\r\n}\r\ndma->sw = sw;\r\ndma->port = port;\r\ndma->base = DMA_PORT_CAP;\r\nreturn dma;\r\n}\r\nvoid dma_port_free(struct tb_dma_port *dma)\r\n{\r\nif (dma) {\r\nkfree(dma->buf);\r\nkfree(dma);\r\n}\r\n}\r\nstatic int dma_port_wait_for_completion(struct tb_dma_port *dma,\r\nunsigned int timeout)\r\n{\r\nunsigned long end = jiffies + msecs_to_jiffies(timeout);\r\nstruct tb_switch *sw = dma->sw;\r\ndo {\r\nint ret;\r\nu32 in;\r\nret = dma_port_read(sw->tb->ctl, &in, tb_route(sw), dma->port,\r\ndma->base + MAIL_IN, 1, 50);\r\nif (ret) {\r\nif (ret != -ETIMEDOUT)\r\nreturn ret;\r\n} else if (!(in & MAIL_IN_OP_REQUEST)) {\r\nreturn 0;\r\n}\r\nusleep_range(50, 100);\r\n} while (time_before(jiffies, end));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int status_to_errno(u32 status)\r\n{\r\nswitch (status & MAIL_OUT_STATUS_MASK) {\r\ncase MAIL_OUT_STATUS_COMPLETED:\r\nreturn 0;\r\ncase MAIL_OUT_STATUS_ERR_AUTH:\r\nreturn -EINVAL;\r\ncase MAIL_OUT_STATUS_ERR_ACCESS:\r\nreturn -EACCES;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int dma_port_request(struct tb_dma_port *dma, u32 in,\r\nunsigned int timeout)\r\n{\r\nstruct tb_switch *sw = dma->sw;\r\nu32 out;\r\nint ret;\r\nret = dma_port_write(sw->tb->ctl, &in, tb_route(sw), dma->port,\r\ndma->base + MAIL_IN, 1, DMA_PORT_TIMEOUT);\r\nif (ret)\r\nreturn ret;\r\nret = dma_port_wait_for_completion(dma, timeout);\r\nif (ret)\r\nreturn ret;\r\nret = dma_port_read(sw->tb->ctl, &out, tb_route(sw), dma->port,\r\ndma->base + MAIL_OUT, 1, DMA_PORT_TIMEOUT);\r\nif (ret)\r\nreturn ret;\r\nreturn status_to_errno(out);\r\n}\r\nstatic int dma_port_flash_read_block(struct tb_dma_port *dma, u32 address,\r\nvoid *buf, u32 size)\r\n{\r\nstruct tb_switch *sw = dma->sw;\r\nu32 in, dwaddress, dwords;\r\nint ret;\r\ndwaddress = address / 4;\r\ndwords = size / 4;\r\nin = MAIL_IN_CMD_FLASH_READ << MAIL_IN_CMD_SHIFT;\r\nif (dwords < MAIL_DATA_DWORDS)\r\nin |= (dwords << MAIL_IN_DWORDS_SHIFT) & MAIL_IN_DWORDS_MASK;\r\nin |= (dwaddress << MAIL_IN_ADDRESS_SHIFT) & MAIL_IN_ADDRESS_MASK;\r\nin |= MAIL_IN_OP_REQUEST;\r\nret = dma_port_request(dma, in, DMA_PORT_TIMEOUT);\r\nif (ret)\r\nreturn ret;\r\nreturn dma_port_read(sw->tb->ctl, buf, tb_route(sw), dma->port,\r\ndma->base + MAIL_DATA, dwords, DMA_PORT_TIMEOUT);\r\n}\r\nstatic int dma_port_flash_write_block(struct tb_dma_port *dma, u32 address,\r\nconst void *buf, u32 size)\r\n{\r\nstruct tb_switch *sw = dma->sw;\r\nu32 in, dwaddress, dwords;\r\nint ret;\r\ndwords = size / 4;\r\nret = dma_port_write(sw->tb->ctl, buf, tb_route(sw), dma->port,\r\ndma->base + MAIL_DATA, dwords, DMA_PORT_TIMEOUT);\r\nin = MAIL_IN_CMD_FLASH_WRITE << MAIL_IN_CMD_SHIFT;\r\nif (address >= DMA_PORT_CSS_ADDRESS) {\r\ndwaddress = DMA_PORT_CSS_ADDRESS;\r\nin |= MAIL_IN_CSS;\r\n} else {\r\ndwaddress = address / 4;\r\n}\r\nin |= ((dwords - 1) << MAIL_IN_DWORDS_SHIFT) & MAIL_IN_DWORDS_MASK;\r\nin |= (dwaddress << MAIL_IN_ADDRESS_SHIFT) & MAIL_IN_ADDRESS_MASK;\r\nin |= MAIL_IN_OP_REQUEST;\r\nreturn dma_port_request(dma, in, DMA_PORT_TIMEOUT);\r\n}\r\nint dma_port_flash_read(struct tb_dma_port *dma, unsigned int address,\r\nvoid *buf, size_t size)\r\n{\r\nunsigned int retries = DMA_PORT_RETRIES;\r\nunsigned int offset;\r\noffset = address & 3;\r\naddress = address & ~3;\r\ndo {\r\nu32 nbytes = min_t(u32, size, MAIL_DATA_DWORDS * 4);\r\nint ret;\r\nret = dma_port_flash_read_block(dma, address, dma->buf,\r\nALIGN(nbytes, 4));\r\nif (ret) {\r\nif (ret == -ETIMEDOUT) {\r\nif (retries--)\r\ncontinue;\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nmemcpy(buf, dma->buf + offset, nbytes);\r\nsize -= nbytes;\r\naddress += nbytes;\r\nbuf += nbytes;\r\n} while (size > 0);\r\nreturn 0;\r\n}\r\nint dma_port_flash_write(struct tb_dma_port *dma, unsigned int address,\r\nconst void *buf, size_t size)\r\n{\r\nunsigned int retries = DMA_PORT_RETRIES;\r\nunsigned int offset;\r\nif (address >= DMA_PORT_CSS_ADDRESS) {\r\noffset = 0;\r\nif (size > DMA_PORT_CSS_MAX_SIZE)\r\nreturn -E2BIG;\r\n} else {\r\noffset = address & 3;\r\naddress = address & ~3;\r\n}\r\ndo {\r\nu32 nbytes = min_t(u32, size, MAIL_DATA_DWORDS * 4);\r\nint ret;\r\nmemcpy(dma->buf + offset, buf, nbytes);\r\nret = dma_port_flash_write_block(dma, address, buf, nbytes);\r\nif (ret) {\r\nif (ret == -ETIMEDOUT) {\r\nif (retries--)\r\ncontinue;\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nsize -= nbytes;\r\naddress += nbytes;\r\nbuf += nbytes;\r\n} while (size > 0);\r\nreturn 0;\r\n}\r\nint dma_port_flash_update_auth(struct tb_dma_port *dma)\r\n{\r\nu32 in;\r\nin = MAIL_IN_CMD_FLASH_UPDATE_AUTH << MAIL_IN_CMD_SHIFT;\r\nin |= MAIL_IN_OP_REQUEST;\r\nreturn dma_port_request(dma, in, 150);\r\n}\r\nint dma_port_flash_update_auth_status(struct tb_dma_port *dma, u32 *status)\r\n{\r\nstruct tb_switch *sw = dma->sw;\r\nu32 out, cmd;\r\nint ret;\r\nret = dma_port_read(sw->tb->ctl, &out, tb_route(sw), dma->port,\r\ndma->base + MAIL_OUT, 1, DMA_PORT_TIMEOUT);\r\nif (ret)\r\nreturn ret;\r\ncmd = (out & MAIL_OUT_STATUS_CMD_MASK) >> MAIL_OUT_STATUS_CMD_SHIFT;\r\nif (cmd == MAIL_IN_CMD_FLASH_UPDATE_AUTH) {\r\nif (status)\r\n*status = out & MAIL_OUT_STATUS_MASK;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint dma_port_power_cycle(struct tb_dma_port *dma)\r\n{\r\nu32 in;\r\nin = MAIL_IN_CMD_POWER_CYCLE << MAIL_IN_CMD_SHIFT;\r\nin |= MAIL_IN_OP_REQUEST;\r\nreturn dma_port_request(dma, in, 150);\r\n}
