void *e2prom_otp_read(struct v4l2_subdev *sd, u8 dev_addr,\r\nu32 start_addr, u32 size)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nunsigned int e2prom_i2c_addr = dev_addr >> 1;\r\nstatic const unsigned int max_read_size = 30;\r\nint addr;\r\nu32 s_addr = start_addr & E2PROM_ADDR_MASK;\r\nbool two_addr = (start_addr & E2PROM_2ADDR) >> 31;\r\nchar *buffer;\r\nbuffer = devm_kzalloc(&client->dev, size, GFP_KERNEL);\r\nif (!buffer)\r\nreturn NULL;\r\nfor (addr = s_addr; addr < size; addr += max_read_size) {\r\nstruct i2c_msg msg[2];\r\nunsigned int i2c_addr = e2prom_i2c_addr;\r\nu16 addr_buf;\r\nint r;\r\nmsg[0].flags = 0;\r\nif (two_addr) {\r\nmsg[0].addr = i2c_addr;\r\naddr_buf = cpu_to_be16(addr & 0xFFFF);\r\nmsg[0].len = 2;\r\nmsg[0].buf = (u8 *)&addr_buf;\r\n} else {\r\ni2c_addr |= (addr >> 8) & 0x7;\r\nmsg[0].addr = i2c_addr;\r\naddr_buf = addr & 0xFF;\r\nmsg[0].len = 1;\r\nmsg[0].buf = (u8 *)&addr_buf;\r\n}\r\nmsg[1].addr = i2c_addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].len = min(max_read_size, size - addr);\r\nmsg[1].buf = &buffer[addr];\r\nr = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\r\nif (r != ARRAY_SIZE(msg)) {\r\ndev_err(&client->dev, "read failed at 0x%03x\n", addr);\r\nreturn NULL;\r\n}\r\n}\r\nreturn buffer;\r\n}
