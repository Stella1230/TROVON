static int axp20x_adc_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val)\r\n{\r\nstruct axp20x_adc_iio *info = iio_priv(indio_dev);\r\nint size = 12;\r\nif (chan->type == IIO_CURRENT && chan->channel == AXP20X_BATT_DISCHRG_I)\r\nsize = 13;\r\nelse\r\nsize = 12;\r\n*val = axp20x_read_variable_width(info->regmap, chan->address, size);\r\nif (*val < 0)\r\nreturn *val;\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int axp22x_adc_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val)\r\n{\r\nstruct axp20x_adc_iio *info = iio_priv(indio_dev);\r\nint size;\r\nif (chan->type == IIO_CURRENT && chan->channel == AXP22X_BATT_DISCHRG_I)\r\nsize = 13;\r\nelse\r\nsize = 12;\r\n*val = axp20x_read_variable_width(info->regmap, chan->address, size);\r\nif (*val < 0)\r\nreturn *val;\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int axp20x_adc_scale_voltage(int channel, int *val, int *val2)\r\n{\r\nswitch (channel) {\r\ncase AXP20X_ACIN_V:\r\ncase AXP20X_VBUS_V:\r\n*val = 1;\r\n*val2 = 700000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase AXP20X_GPIO0_V:\r\ncase AXP20X_GPIO1_V:\r\n*val = 0;\r\n*val2 = 500000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase AXP20X_BATT_V:\r\n*val = 1;\r\n*val2 = 100000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase AXP20X_IPSOUT_V:\r\n*val = 1;\r\n*val2 = 400000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int axp20x_adc_scale_current(int channel, int *val, int *val2)\r\n{\r\nswitch (channel) {\r\ncase AXP20X_ACIN_I:\r\n*val = 0;\r\n*val2 = 625000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase AXP20X_VBUS_I:\r\n*val = 0;\r\n*val2 = 375000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase AXP20X_BATT_DISCHRG_I:\r\ncase AXP20X_BATT_CHRG_I:\r\n*val = 0;\r\n*val2 = 500000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int axp20x_adc_scale(struct iio_chan_spec const *chan, int *val,\r\nint *val2)\r\n{\r\nswitch (chan->type) {\r\ncase IIO_VOLTAGE:\r\nreturn axp20x_adc_scale_voltage(chan->channel, val, val2);\r\ncase IIO_CURRENT:\r\nreturn axp20x_adc_scale_current(chan->channel, val, val2);\r\ncase IIO_TEMP:\r\n*val = 100;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int axp22x_adc_scale(struct iio_chan_spec const *chan, int *val,\r\nint *val2)\r\n{\r\nswitch (chan->type) {\r\ncase IIO_VOLTAGE:\r\nif (chan->channel != AXP22X_BATT_V)\r\nreturn -EINVAL;\r\n*val = 1;\r\n*val2 = 100000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_CURRENT:\r\n*val = 0;\r\n*val2 = 500000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_TEMP:\r\n*val = 100;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int axp20x_adc_offset_voltage(struct iio_dev *indio_dev, int channel,\r\nint *val)\r\n{\r\nstruct axp20x_adc_iio *info = iio_priv(indio_dev);\r\nint ret;\r\nret = regmap_read(info->regmap, AXP20X_GPIO10_IN_RANGE, val);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (channel) {\r\ncase AXP20X_GPIO0_V:\r\n*val &= AXP20X_GPIO10_IN_RANGE_GPIO0;\r\nbreak;\r\ncase AXP20X_GPIO1_V:\r\n*val &= AXP20X_GPIO10_IN_RANGE_GPIO1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*val = !!(*val) * 700000;\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int axp20x_adc_offset(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val)\r\n{\r\nswitch (chan->type) {\r\ncase IIO_VOLTAGE:\r\nreturn axp20x_adc_offset_voltage(indio_dev, chan->channel, val);\r\ncase IIO_TEMP:\r\n*val = -1447;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int axp20x_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val,\r\nint *val2, long mask)\r\n{\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_OFFSET:\r\nreturn axp20x_adc_offset(indio_dev, chan, val);\r\ncase IIO_CHAN_INFO_SCALE:\r\nreturn axp20x_adc_scale(chan, val, val2);\r\ncase IIO_CHAN_INFO_RAW:\r\nreturn axp20x_adc_raw(indio_dev, chan, val);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int axp22x_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val,\r\nint *val2, long mask)\r\n{\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_OFFSET:\r\n*val = -2677;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nreturn axp22x_adc_scale(chan, val, val2);\r\ncase IIO_CHAN_INFO_RAW:\r\nreturn axp22x_adc_raw(indio_dev, chan, val);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int axp20x_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val, int val2,\r\nlong mask)\r\n{\r\nstruct axp20x_adc_iio *info = iio_priv(indio_dev);\r\nunsigned int reg, regval;\r\nif (mask != IIO_CHAN_INFO_OFFSET)\r\nreturn -EINVAL;\r\nif (val != 0 && val != 700000)\r\nreturn -EINVAL;\r\nswitch (chan->channel) {\r\ncase AXP20X_GPIO0_V:\r\nreg = AXP20X_GPIO10_IN_RANGE_GPIO0;\r\nregval = AXP20X_GPIO10_IN_RANGE_GPIO0_VAL(!!val);\r\nbreak;\r\ncase AXP20X_GPIO1_V:\r\nreg = AXP20X_GPIO10_IN_RANGE_GPIO1;\r\nregval = AXP20X_GPIO10_IN_RANGE_GPIO1_VAL(!!val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_update_bits(info->regmap, AXP20X_GPIO10_IN_RANGE, reg,\r\nregval);\r\n}\r\nstatic int axp20x_adc_rate(int rate)\r\n{\r\nreturn AXP20X_ADC_RATE_HZ(rate);\r\n}\r\nstatic int axp22x_adc_rate(int rate)\r\n{\r\nreturn AXP22X_ADC_RATE_HZ(rate);\r\n}\r\nstatic int axp20x_probe(struct platform_device *pdev)\r\n{\r\nstruct axp20x_adc_iio *info;\r\nstruct iio_dev *indio_dev;\r\nstruct axp20x_dev *axp20x_dev;\r\nint ret;\r\naxp20x_dev = dev_get_drvdata(pdev->dev.parent);\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*info));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ninfo = iio_priv(indio_dev);\r\nplatform_set_drvdata(pdev, indio_dev);\r\ninfo->regmap = axp20x_dev->regmap;\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->dev.of_node = pdev->dev.of_node;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\ninfo->data = (struct axp_data *)platform_get_device_id(pdev)->driver_data;\r\nindio_dev->name = platform_get_device_id(pdev)->name;\r\nindio_dev->info = info->data->iio_info;\r\nindio_dev->num_channels = info->data->num_channels;\r\nindio_dev->channels = info->data->channels;\r\nregmap_write(info->regmap, AXP20X_ADC_EN1, info->data->adc_en1_mask);\r\nif (info->data->adc_en2)\r\nregmap_update_bits(info->regmap, AXP20X_ADC_EN2,\r\nAXP20X_ADC_EN2_MASK, AXP20X_ADC_EN2_MASK);\r\nregmap_update_bits(info->regmap, AXP20X_ADC_RATE, AXP20X_ADC_RATE_MASK,\r\ninfo->data->adc_rate(100));\r\nret = iio_map_array_register(indio_dev, info->data->maps);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to register IIO maps: %d\n", ret);\r\ngoto fail_map;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "could not register the device\n");\r\ngoto fail_register;\r\n}\r\nreturn 0;\r\nfail_register:\r\niio_map_array_unregister(indio_dev);\r\nfail_map:\r\nregmap_write(info->regmap, AXP20X_ADC_EN1, 0);\r\nif (info->data->adc_en2)\r\nregmap_write(info->regmap, AXP20X_ADC_EN2, 0);\r\nreturn ret;\r\n}\r\nstatic int axp20x_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct axp20x_adc_iio *info = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\niio_map_array_unregister(indio_dev);\r\nregmap_write(info->regmap, AXP20X_ADC_EN1, 0);\r\nif (info->data->adc_en2)\r\nregmap_write(info->regmap, AXP20X_ADC_EN2, 0);\r\nreturn 0;\r\n}
