static int bdc_issue_cmd(struct bdc *bdc, u32 cmd_sc, u32 param0,\r\nu32 param1, u32 param2)\r\n{\r\nu32 timeout = BDC_CMD_TIMEOUT;\r\nu32 cmd_status;\r\nu32 temp;\r\nbdc_writel(bdc->regs, BDC_CMDPAR0, param0);\r\nbdc_writel(bdc->regs, BDC_CMDPAR1, param1);\r\nbdc_writel(bdc->regs, BDC_CMDPAR2, param2);\r\nwmb();\r\nbdc_writel(bdc->regs, BDC_CMDSC, cmd_sc | BDC_CMD_CWS | BDC_CMD_SRD);\r\ndo {\r\ntemp = bdc_readl(bdc->regs, BDC_CMDSC);\r\ndev_dbg_ratelimited(bdc->dev, "cmdsc=%x", temp);\r\ncmd_status = BDC_CMD_CST(temp);\r\nif (cmd_status != BDC_CMDS_BUSY) {\r\ndev_dbg(bdc->dev,\r\n"command completed cmd_sts:%x\n", cmd_status);\r\nreturn cmd_status;\r\n}\r\nudelay(1);\r\n} while (timeout--);\r\ndev_err(bdc->dev,\r\n"command operation timedout cmd_status=%d\n", cmd_status);\r\nreturn cmd_status;\r\n}\r\nstatic int bdc_submit_cmd(struct bdc *bdc, u32 cmd_sc,\r\nu32 param0, u32 param1, u32 param2)\r\n{\r\nu32 temp, cmd_status;\r\nint ret;\r\ntemp = bdc_readl(bdc->regs, BDC_CMDSC);\r\ndev_dbg(bdc->dev,\r\n"%s:CMDSC:%08x cmdsc:%08x param0=%08x param1=%08x param2=%08x\n",\r\n__func__, temp, cmd_sc, param0, param1, param2);\r\ncmd_status = BDC_CMD_CST(temp);\r\nif (cmd_status == BDC_CMDS_BUSY) {\r\ndev_err(bdc->dev, "command processor busy: %x\n", cmd_status);\r\nreturn -EBUSY;\r\n}\r\nret = bdc_issue_cmd(bdc, cmd_sc, param0, param1, param2);\r\nswitch (ret) {\r\ncase BDC_CMDS_SUCC:\r\ndev_dbg(bdc->dev, "command completed successfully\n");\r\nret = 0;\r\nbreak;\r\ncase BDC_CMDS_PARA:\r\ndev_err(bdc->dev, "command parameter error\n");\r\nret = -EINVAL;\r\nbreak;\r\ncase BDC_CMDS_STAT:\r\ndev_err(bdc->dev, "Invalid device/ep state\n");\r\nret = -EINVAL;\r\nbreak;\r\ncase BDC_CMDS_FAIL:\r\ndev_err(bdc->dev, "Command failed?\n");\r\nret = -EAGAIN;\r\nbreak;\r\ncase BDC_CMDS_INTL:\r\ndev_err(bdc->dev, "BDC Internal error\n");\r\nret = -ECONNRESET;\r\nbreak;\r\ncase BDC_CMDS_BUSY:\r\ndev_err(bdc->dev,\r\n"command timedout waited for %dusec\n",\r\nBDC_CMD_TIMEOUT);\r\nret = -ECONNRESET;\r\nbreak;\r\ndefault:\r\ndev_dbg(bdc->dev, "Unknown command completion code:%x\n", ret);\r\n}\r\nreturn ret;\r\n}\r\nint bdc_dconfig_ep(struct bdc *bdc, struct bdc_ep *ep)\r\n{\r\nu32 cmd_sc;\r\ncmd_sc = BDC_SUB_CMD_DRP_EP|BDC_CMD_EPN(ep->ep_num)|BDC_CMD_EPC;\r\ndev_dbg(bdc->dev, "%s ep->ep_num =%d cmd_sc=%x\n", __func__,\r\nep->ep_num, cmd_sc);\r\nreturn bdc_submit_cmd(bdc, cmd_sc, 0, 0, 0);\r\n}\r\nstatic void ep_bd_list_reinit(struct bdc_ep *ep)\r\n{\r\nstruct bdc *bdc = ep->bdc;\r\nstruct bdc_bd *bd;\r\nep->bd_list.eqp_bdi = 0;\r\nep->bd_list.hwd_bdi = 0;\r\nbd = ep->bd_list.bd_table_array[0]->start_bd;\r\ndev_dbg(bdc->dev, "%s ep:%p bd:%p\n", __func__, ep, bd);\r\nmemset(bd, 0, sizeof(struct bdc_bd));\r\nbd->offset[3] |= cpu_to_le32(BD_SBF);\r\n}\r\nint bdc_config_ep(struct bdc *bdc, struct bdc_ep *ep)\r\n{\r\nconst struct usb_ss_ep_comp_descriptor *comp_desc;\r\nconst struct usb_endpoint_descriptor *desc;\r\nu32 param0, param1, param2, cmd_sc;\r\nu32 mps, mbs, mul, si;\r\nint ret;\r\ndesc = ep->desc;\r\ncomp_desc = ep->comp_desc;\r\ncmd_sc = mul = mbs = param2 = 0;\r\nparam0 = lower_32_bits(ep->bd_list.bd_table_array[0]->dma);\r\nparam1 = upper_32_bits(ep->bd_list.bd_table_array[0]->dma);\r\ncpu_to_le32s(&param0);\r\ncpu_to_le32s(&param1);\r\ndev_dbg(bdc->dev, "%s: param0=%08x param1=%08x",\r\n__func__, param0, param1);\r\nsi = desc->bInterval;\r\nsi = clamp_val(si, 1, 16) - 1;\r\nmps = usb_endpoint_maxp(desc);\r\nmps &= 0x7ff;\r\nparam2 |= mps << MP_SHIFT;\r\nparam2 |= usb_endpoint_type(desc) << EPT_SHIFT;\r\nswitch (bdc->gadget.speed) {\r\ncase USB_SPEED_SUPER:\r\nif (usb_endpoint_xfer_int(desc) ||\r\nusb_endpoint_xfer_isoc(desc)) {\r\nparam2 |= si;\r\nif (usb_endpoint_xfer_isoc(desc) && comp_desc)\r\nmul = comp_desc->bmAttributes;\r\n}\r\nparam2 |= mul << EPM_SHIFT;\r\nif (comp_desc)\r\nmbs = comp_desc->bMaxBurst;\r\nparam2 |= mbs << MB_SHIFT;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nif (usb_endpoint_xfer_isoc(desc) ||\r\nusb_endpoint_xfer_int(desc)) {\r\nparam2 |= si;\r\nmbs = usb_endpoint_maxp_mult(desc);\r\nparam2 |= mbs << MB_SHIFT;\r\n}\r\nbreak;\r\ncase USB_SPEED_FULL:\r\ncase USB_SPEED_LOW:\r\nif (usb_endpoint_xfer_isoc(desc))\r\nsi += 3;\r\nif (usb_endpoint_xfer_int(desc))\r\nsi = fls(desc->bInterval * 8) - 1;\r\nparam2 |= si;\r\nbreak;\r\ndefault:\r\ndev_err(bdc->dev, "UNKNOWN speed ERR\n");\r\nreturn -EINVAL;\r\n}\r\ncmd_sc |= BDC_CMD_EPC|BDC_CMD_EPN(ep->ep_num)|BDC_SUB_CMD_ADD_EP;\r\ndev_dbg(bdc->dev, "cmd_sc=%x param2=%08x\n", cmd_sc, param2);\r\nret = bdc_submit_cmd(bdc, cmd_sc, param0, param1, param2);\r\nif (ret) {\r\ndev_err(bdc->dev, "command failed :%x\n", ret);\r\nreturn ret;\r\n}\r\nep_bd_list_reinit(ep);\r\nreturn ret;\r\n}\r\nint bdc_ep_bla(struct bdc *bdc, struct bdc_ep *ep, dma_addr_t dma_addr)\r\n{\r\nu32 param0, param1;\r\nu32 cmd_sc = 0;\r\ndev_dbg(bdc->dev, "%s: add=%08llx\n", __func__,\r\n(unsigned long long)(dma_addr));\r\nparam0 = lower_32_bits(dma_addr);\r\nparam1 = upper_32_bits(dma_addr);\r\ncpu_to_le32s(&param0);\r\ncpu_to_le32s(&param1);\r\ncmd_sc |= BDC_CMD_EPN(ep->ep_num)|BDC_CMD_BLA;\r\ndev_dbg(bdc->dev, "cmd_sc=%x\n", cmd_sc);\r\nreturn bdc_submit_cmd(bdc, cmd_sc, param0, param1, 0);\r\n}\r\nint bdc_address_device(struct bdc *bdc, u32 add)\r\n{\r\nu32 cmd_sc = 0;\r\nu32 param2;\r\ndev_dbg(bdc->dev, "%s: add=%d\n", __func__, add);\r\ncmd_sc |= BDC_SUB_CMD_ADD|BDC_CMD_DVC;\r\nparam2 = add & 0x7f;\r\nreturn bdc_submit_cmd(bdc, cmd_sc, 0, 0, param2);\r\n}\r\nint bdc_function_wake_fh(struct bdc *bdc, u8 intf)\r\n{\r\nu32 param0, param1;\r\nu32 cmd_sc = 0;\r\nparam0 = param1 = 0;\r\ndev_dbg(bdc->dev, "%s intf=%d\n", __func__, intf);\r\ncmd_sc |= BDC_CMD_FH;\r\nparam0 |= TRA_PACKET;\r\nparam0 |= (bdc->dev_addr << 25);\r\nparam1 |= DEV_NOTF_TYPE;\r\nparam1 |= (FWK_SUBTYPE<<4);\r\ndev_dbg(bdc->dev, "param0=%08x param1=%08x\n", param0, param1);\r\nreturn bdc_submit_cmd(bdc, cmd_sc, param0, param1, 0);\r\n}\r\nint bdc_function_wake(struct bdc *bdc, u8 intf)\r\n{\r\nu32 cmd_sc = 0;\r\nu32 param2 = 0;\r\ndev_dbg(bdc->dev, "%s intf=%d", __func__, intf);\r\nparam2 |= intf;\r\ncmd_sc |= BDC_SUB_CMD_FWK|BDC_CMD_DNC;\r\nreturn bdc_submit_cmd(bdc, cmd_sc, 0, 0, param2);\r\n}\r\nint bdc_ep_set_stall(struct bdc *bdc, int epnum)\r\n{\r\nu32 cmd_sc = 0;\r\ndev_dbg(bdc->dev, "%s epnum=%d\n", __func__, epnum);\r\ncmd_sc |= BDC_SUB_CMD_EP_STL | BDC_CMD_EPN(epnum) | BDC_CMD_EPO;\r\nreturn bdc_submit_cmd(bdc, cmd_sc, 0, 0, 0);\r\n}\r\nint bdc_ep_clear_stall(struct bdc *bdc, int epnum)\r\n{\r\nstruct bdc_ep *ep;\r\nu32 cmd_sc = 0;\r\nint ret;\r\ndev_dbg(bdc->dev, "%s: epnum=%d\n", __func__, epnum);\r\nep = bdc->bdc_ep_array[epnum];\r\nif (epnum != 1) {\r\nif (!(ep->flags & BDC_EP_STALL)) {\r\nret = bdc_ep_set_stall(bdc, epnum);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nif (epnum != 1)\r\ncmd_sc |= BDC_CMD_EPO_RST_SN;\r\ncmd_sc |= BDC_SUB_CMD_EP_RST | BDC_CMD_EPN(epnum) | BDC_CMD_EPO;\r\nret = bdc_submit_cmd(bdc, cmd_sc, 0, 0, 0);\r\nif (ret) {\r\ndev_err(bdc->dev, "command failed:%x\n", ret);\r\nreturn ret;\r\n}\r\nbdc_notify_xfr(bdc, epnum);\r\nreturn ret;\r\n}\r\nint bdc_stop_ep(struct bdc *bdc, int epnum)\r\n{\r\nstruct bdc_ep *ep;\r\nu32 cmd_sc = 0;\r\nint ret;\r\nep = bdc->bdc_ep_array[epnum];\r\ndev_dbg(bdc->dev, "%s: ep:%s ep->flags:%08x\n", __func__,\r\nep->name, ep->flags);\r\nif (!(ep->flags & BDC_EP_ENABLED)) {\r\ndev_err(bdc->dev, "stop endpoint called for disabled ep\n");\r\nreturn -EINVAL;\r\n}\r\nif ((ep->flags & BDC_EP_STALL) || (ep->flags & BDC_EP_STOP))\r\nreturn 0;\r\ncmd_sc |= BDC_CMD_EP0_XSD | BDC_SUB_CMD_EP_STP\r\n| BDC_CMD_EPN(epnum) | BDC_CMD_EPO;\r\nret = bdc_submit_cmd(bdc, cmd_sc, 0, 0, 0);\r\nif (ret) {\r\ndev_err(bdc->dev,\r\n"stop endpoint command didn't complete:%d ep:%s\n",\r\nret, ep->name);\r\nreturn ret;\r\n}\r\nep->flags |= BDC_EP_STOP;\r\nbdc_dump_epsts(bdc);\r\nreturn ret;\r\n}
