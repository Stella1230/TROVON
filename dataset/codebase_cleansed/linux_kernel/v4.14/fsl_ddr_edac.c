static inline u32 ddr_in32(void __iomem *addr)\r\n{\r\nreturn little_endian ? ioread32(addr) : ioread32be(addr);\r\n}\r\nstatic inline void ddr_out32(void __iomem *addr, u32 value)\r\n{\r\nif (little_endian)\r\niowrite32(value, addr);\r\nelse\r\niowrite32be(value, addr);\r\n}\r\nstatic ssize_t fsl_mc_inject_data_hi_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nstruct fsl_mc_pdata *pdata = mci->pvt_info;\r\nreturn sprintf(data, "0x%08x",\r\nddr_in32(pdata->mc_vbase + FSL_MC_DATA_ERR_INJECT_HI));\r\n}\r\nstatic ssize_t fsl_mc_inject_data_lo_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nstruct fsl_mc_pdata *pdata = mci->pvt_info;\r\nreturn sprintf(data, "0x%08x",\r\nddr_in32(pdata->mc_vbase + FSL_MC_DATA_ERR_INJECT_LO));\r\n}\r\nstatic ssize_t fsl_mc_inject_ctrl_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nstruct fsl_mc_pdata *pdata = mci->pvt_info;\r\nreturn sprintf(data, "0x%08x",\r\nddr_in32(pdata->mc_vbase + FSL_MC_ECC_ERR_INJECT));\r\n}\r\nstatic ssize_t fsl_mc_inject_data_hi_store(struct device *dev,\r\nstruct device_attribute *mattr,\r\nconst char *data, size_t count)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nstruct fsl_mc_pdata *pdata = mci->pvt_info;\r\nunsigned long val;\r\nint rc;\r\nif (isdigit(*data)) {\r\nrc = kstrtoul(data, 0, &val);\r\nif (rc)\r\nreturn rc;\r\nddr_out32(pdata->mc_vbase + FSL_MC_DATA_ERR_INJECT_HI, val);\r\nreturn count;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t fsl_mc_inject_data_lo_store(struct device *dev,\r\nstruct device_attribute *mattr,\r\nconst char *data, size_t count)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nstruct fsl_mc_pdata *pdata = mci->pvt_info;\r\nunsigned long val;\r\nint rc;\r\nif (isdigit(*data)) {\r\nrc = kstrtoul(data, 0, &val);\r\nif (rc)\r\nreturn rc;\r\nddr_out32(pdata->mc_vbase + FSL_MC_DATA_ERR_INJECT_LO, val);\r\nreturn count;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t fsl_mc_inject_ctrl_store(struct device *dev,\r\nstruct device_attribute *mattr,\r\nconst char *data, size_t count)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nstruct fsl_mc_pdata *pdata = mci->pvt_info;\r\nunsigned long val;\r\nint rc;\r\nif (isdigit(*data)) {\r\nrc = kstrtoul(data, 0, &val);\r\nif (rc)\r\nreturn rc;\r\nddr_out32(pdata->mc_vbase + FSL_MC_ECC_ERR_INJECT, val);\r\nreturn count;\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 calculate_ecc(u32 high, u32 low)\r\n{\r\nu32 mask_low;\r\nu32 mask_high;\r\nint bit_cnt;\r\nu8 ecc = 0;\r\nint i;\r\nint j;\r\nfor (i = 0; i < 8; i++) {\r\nmask_high = ecc_table[i * 2];\r\nmask_low = ecc_table[i * 2 + 1];\r\nbit_cnt = 0;\r\nfor (j = 0; j < 32; j++) {\r\nif ((mask_high >> j) & 1)\r\nbit_cnt ^= (high >> j) & 1;\r\nif ((mask_low >> j) & 1)\r\nbit_cnt ^= (low >> j) & 1;\r\n}\r\necc |= bit_cnt << i;\r\n}\r\nreturn ecc;\r\n}\r\nstatic u8 syndrome_from_bit(unsigned int bit) {\r\nint i;\r\nu8 syndrome = 0;\r\nfor (i = bit < 32; i < 16; i += 2)\r\nsyndrome |= ((ecc_table[i] >> (bit % 32)) & 1) << (i / 2);\r\nreturn syndrome;\r\n}\r\nstatic void sbe_ecc_decode(u32 cap_high, u32 cap_low, u32 cap_ecc,\r\nint *bad_data_bit, int *bad_ecc_bit)\r\n{\r\nint i;\r\nu8 syndrome;\r\n*bad_data_bit = -1;\r\n*bad_ecc_bit = -1;\r\nsyndrome = calculate_ecc(cap_high, cap_low) ^ cap_ecc;\r\nfor (i = 0; i < 64; i++) {\r\nif (syndrome == syndrome_from_bit(i)) {\r\n*bad_data_bit = i;\r\nreturn;\r\n}\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nif ((syndrome >> i) & 0x1) {\r\n*bad_ecc_bit = i;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void fsl_mc_check(struct mem_ctl_info *mci)\r\n{\r\nstruct fsl_mc_pdata *pdata = mci->pvt_info;\r\nstruct csrow_info *csrow;\r\nu32 bus_width;\r\nu32 err_detect;\r\nu32 syndrome;\r\nu64 err_addr;\r\nu32 pfn;\r\nint row_index;\r\nu32 cap_high;\r\nu32 cap_low;\r\nint bad_data_bit;\r\nint bad_ecc_bit;\r\nerr_detect = ddr_in32(pdata->mc_vbase + FSL_MC_ERR_DETECT);\r\nif (!err_detect)\r\nreturn;\r\nfsl_mc_printk(mci, KERN_ERR, "Err Detect Register: %#8.8x\n",\r\nerr_detect);\r\nif (!(err_detect & (DDR_EDE_SBE | DDR_EDE_MBE))) {\r\nddr_out32(pdata->mc_vbase + FSL_MC_ERR_DETECT, err_detect);\r\nreturn;\r\n}\r\nsyndrome = ddr_in32(pdata->mc_vbase + FSL_MC_CAPTURE_ECC);\r\nbus_width = (ddr_in32(pdata->mc_vbase + FSL_MC_DDR_SDRAM_CFG) &\r\nDSC_DBW_MASK) ? 32 : 64;\r\nif (bus_width == 64)\r\nsyndrome &= 0xff;\r\nelse\r\nsyndrome &= 0xffff;\r\nerr_addr = make64(\r\nddr_in32(pdata->mc_vbase + FSL_MC_CAPTURE_EXT_ADDRESS),\r\nddr_in32(pdata->mc_vbase + FSL_MC_CAPTURE_ADDRESS));\r\npfn = err_addr >> PAGE_SHIFT;\r\nfor (row_index = 0; row_index < mci->nr_csrows; row_index++) {\r\ncsrow = mci->csrows[row_index];\r\nif ((pfn >= csrow->first_page) && (pfn <= csrow->last_page))\r\nbreak;\r\n}\r\ncap_high = ddr_in32(pdata->mc_vbase + FSL_MC_CAPTURE_DATA_HI);\r\ncap_low = ddr_in32(pdata->mc_vbase + FSL_MC_CAPTURE_DATA_LO);\r\nif ((err_detect & DDR_EDE_SBE) && (bus_width == 64)) {\r\nsbe_ecc_decode(cap_high, cap_low, syndrome,\r\n&bad_data_bit, &bad_ecc_bit);\r\nif (bad_data_bit != -1)\r\nfsl_mc_printk(mci, KERN_ERR,\r\n"Faulty Data bit: %d\n", bad_data_bit);\r\nif (bad_ecc_bit != -1)\r\nfsl_mc_printk(mci, KERN_ERR,\r\n"Faulty ECC bit: %d\n", bad_ecc_bit);\r\nfsl_mc_printk(mci, KERN_ERR,\r\n"Expected Data / ECC:\t%#8.8x_%08x / %#2.2x\n",\r\ncap_high ^ (1 << (bad_data_bit - 32)),\r\ncap_low ^ (1 << bad_data_bit),\r\nsyndrome ^ (1 << bad_ecc_bit));\r\n}\r\nfsl_mc_printk(mci, KERN_ERR,\r\n"Captured Data / ECC:\t%#8.8x_%08x / %#2.2x\n",\r\ncap_high, cap_low, syndrome);\r\nfsl_mc_printk(mci, KERN_ERR, "Err addr: %#8.8llx\n", err_addr);\r\nfsl_mc_printk(mci, KERN_ERR, "PFN: %#8.8x\n", pfn);\r\nif (row_index == mci->nr_csrows)\r\nfsl_mc_printk(mci, KERN_ERR, "PFN out of range!\n");\r\nif (err_detect & DDR_EDE_SBE)\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\npfn, err_addr & ~PAGE_MASK, syndrome,\r\nrow_index, 0, -1,\r\nmci->ctl_name, "");\r\nif (err_detect & DDR_EDE_MBE)\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\npfn, err_addr & ~PAGE_MASK, syndrome,\r\nrow_index, 0, -1,\r\nmci->ctl_name, "");\r\nddr_out32(pdata->mc_vbase + FSL_MC_ERR_DETECT, err_detect);\r\n}\r\nstatic irqreturn_t fsl_mc_isr(int irq, void *dev_id)\r\n{\r\nstruct mem_ctl_info *mci = dev_id;\r\nstruct fsl_mc_pdata *pdata = mci->pvt_info;\r\nu32 err_detect;\r\nerr_detect = ddr_in32(pdata->mc_vbase + FSL_MC_ERR_DETECT);\r\nif (!err_detect)\r\nreturn IRQ_NONE;\r\nfsl_mc_check(mci);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void fsl_ddr_init_csrows(struct mem_ctl_info *mci)\r\n{\r\nstruct fsl_mc_pdata *pdata = mci->pvt_info;\r\nstruct csrow_info *csrow;\r\nstruct dimm_info *dimm;\r\nu32 sdram_ctl;\r\nu32 sdtype;\r\nenum mem_type mtype;\r\nu32 cs_bnds;\r\nint index;\r\nsdram_ctl = ddr_in32(pdata->mc_vbase + FSL_MC_DDR_SDRAM_CFG);\r\nsdtype = sdram_ctl & DSC_SDTYPE_MASK;\r\nif (sdram_ctl & DSC_RD_EN) {\r\nswitch (sdtype) {\r\ncase 0x02000000:\r\nmtype = MEM_RDDR;\r\nbreak;\r\ncase 0x03000000:\r\nmtype = MEM_RDDR2;\r\nbreak;\r\ncase 0x07000000:\r\nmtype = MEM_RDDR3;\r\nbreak;\r\ncase 0x05000000:\r\nmtype = MEM_RDDR4;\r\nbreak;\r\ndefault:\r\nmtype = MEM_UNKNOWN;\r\nbreak;\r\n}\r\n} else {\r\nswitch (sdtype) {\r\ncase 0x02000000:\r\nmtype = MEM_DDR;\r\nbreak;\r\ncase 0x03000000:\r\nmtype = MEM_DDR2;\r\nbreak;\r\ncase 0x07000000:\r\nmtype = MEM_DDR3;\r\nbreak;\r\ncase 0x05000000:\r\nmtype = MEM_DDR4;\r\nbreak;\r\ndefault:\r\nmtype = MEM_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nfor (index = 0; index < mci->nr_csrows; index++) {\r\nu32 start;\r\nu32 end;\r\ncsrow = mci->csrows[index];\r\ndimm = csrow->channels[0]->dimm;\r\ncs_bnds = ddr_in32(pdata->mc_vbase + FSL_MC_CS_BNDS_0 +\r\n(index * FSL_MC_CS_BNDS_OFS));\r\nstart = (cs_bnds & 0xffff0000) >> 16;\r\nend = (cs_bnds & 0x0000ffff);\r\nif (start == end)\r\ncontinue;\r\nstart <<= (24 - PAGE_SHIFT);\r\nend <<= (24 - PAGE_SHIFT);\r\nend |= (1 << (24 - PAGE_SHIFT)) - 1;\r\ncsrow->first_page = start;\r\ncsrow->last_page = end;\r\ndimm->nr_pages = end + 1 - start;\r\ndimm->grain = 8;\r\ndimm->mtype = mtype;\r\ndimm->dtype = DEV_UNKNOWN;\r\nif (sdram_ctl & DSC_X32_EN)\r\ndimm->dtype = DEV_X32;\r\ndimm->edac_mode = EDAC_SECDED;\r\n}\r\n}\r\nint fsl_mc_err_probe(struct platform_device *op)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nstruct fsl_mc_pdata *pdata;\r\nstruct resource r;\r\nu32 sdram_ctl;\r\nint res;\r\nif (!devres_open_group(&op->dev, fsl_mc_err_probe, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = 4;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = 1;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(edac_mc_idx, ARRAY_SIZE(layers), layers,\r\nsizeof(*pdata));\r\nif (!mci) {\r\ndevres_release_group(&op->dev, fsl_mc_err_probe);\r\nreturn -ENOMEM;\r\n}\r\npdata = mci->pvt_info;\r\npdata->name = "fsl_mc_err";\r\nmci->pdev = &op->dev;\r\npdata->edac_idx = edac_mc_idx++;\r\ndev_set_drvdata(mci->pdev, mci);\r\nmci->ctl_name = pdata->name;\r\nmci->dev_name = pdata->name;\r\nlittle_endian = of_property_read_bool(op->dev.of_node, "little-endian");\r\nres = of_address_to_resource(op->dev.of_node, 0, &r);\r\nif (res) {\r\npr_err("%s: Unable to get resource for MC err regs\n",\r\n__func__);\r\ngoto err;\r\n}\r\nif (!devm_request_mem_region(&op->dev, r.start, resource_size(&r),\r\npdata->name)) {\r\npr_err("%s: Error while requesting mem region\n",\r\n__func__);\r\nres = -EBUSY;\r\ngoto err;\r\n}\r\npdata->mc_vbase = devm_ioremap(&op->dev, r.start, resource_size(&r));\r\nif (!pdata->mc_vbase) {\r\npr_err("%s: Unable to setup MC err regs\n", __func__);\r\nres = -ENOMEM;\r\ngoto err;\r\n}\r\nsdram_ctl = ddr_in32(pdata->mc_vbase + FSL_MC_DDR_SDRAM_CFG);\r\nif (!(sdram_ctl & DSC_ECC_EN)) {\r\npr_warn("%s: No ECC DIMMs discovered\n", __func__);\r\nres = -ENODEV;\r\ngoto err;\r\n}\r\nedac_dbg(3, "init mci\n");\r\nmci->mtype_cap = MEM_FLAG_DDR | MEM_FLAG_RDDR |\r\nMEM_FLAG_DDR2 | MEM_FLAG_RDDR2 |\r\nMEM_FLAG_DDR3 | MEM_FLAG_RDDR3 |\r\nMEM_FLAG_DDR4 | MEM_FLAG_RDDR4;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = EDAC_MOD_STR;\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\nmci->edac_check = fsl_mc_check;\r\nmci->ctl_page_to_phys = NULL;\r\nmci->scrub_mode = SCRUB_SW_SRC;\r\nfsl_ddr_init_csrows(mci);\r\norig_ddr_err_disable = ddr_in32(pdata->mc_vbase + FSL_MC_ERR_DISABLE);\r\nddr_out32(pdata->mc_vbase + FSL_MC_ERR_DISABLE, 0);\r\nddr_out32(pdata->mc_vbase + FSL_MC_ERR_DETECT, ~0);\r\nres = edac_mc_add_mc_with_groups(mci, fsl_ddr_dev_groups);\r\nif (res) {\r\nedac_dbg(3, "failed edac_mc_add_mc()\n");\r\ngoto err;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\nddr_out32(pdata->mc_vbase + FSL_MC_ERR_INT_EN,\r\nDDR_EIE_MBEE | DDR_EIE_SBEE);\r\norig_ddr_err_sbe = ddr_in32(pdata->mc_vbase +\r\nFSL_MC_ERR_SBE) & 0xff0000;\r\nddr_out32(pdata->mc_vbase + FSL_MC_ERR_SBE, 0x10000);\r\npdata->irq = platform_get_irq(op, 0);\r\nres = devm_request_irq(&op->dev, pdata->irq,\r\nfsl_mc_isr,\r\nIRQF_SHARED,\r\n"[EDAC] MC err", mci);\r\nif (res < 0) {\r\npr_err("%s: Unable to request irq %d for FSL DDR DRAM ERR\n",\r\n__func__, pdata->irq);\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\npr_info(EDAC_MOD_STR " acquired irq %d for MC\n",\r\npdata->irq);\r\n}\r\ndevres_remove_group(&op->dev, fsl_mc_err_probe);\r\nedac_dbg(3, "success\n");\r\npr_info(EDAC_MOD_STR " MC err registered\n");\r\nreturn 0;\r\nerr2:\r\nedac_mc_del_mc(&op->dev);\r\nerr:\r\ndevres_release_group(&op->dev, fsl_mc_err_probe);\r\nedac_mc_free(mci);\r\nreturn res;\r\n}\r\nint fsl_mc_err_remove(struct platform_device *op)\r\n{\r\nstruct mem_ctl_info *mci = dev_get_drvdata(&op->dev);\r\nstruct fsl_mc_pdata *pdata = mci->pvt_info;\r\nedac_dbg(0, "\n");\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\nddr_out32(pdata->mc_vbase + FSL_MC_ERR_INT_EN, 0);\r\n}\r\nddr_out32(pdata->mc_vbase + FSL_MC_ERR_DISABLE,\r\norig_ddr_err_disable);\r\nddr_out32(pdata->mc_vbase + FSL_MC_ERR_SBE, orig_ddr_err_sbe);\r\nedac_mc_del_mc(&op->dev);\r\nedac_mc_free(mci);\r\nreturn 0;\r\n}
