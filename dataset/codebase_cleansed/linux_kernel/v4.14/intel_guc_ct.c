void intel_guc_ct_init_early(struct intel_guc_ct *ct)\r\n{\r\nct->host_channel.owner = CTB_OWNER_HOST;\r\n}\r\nstatic inline const char *guc_ct_buffer_type_to_str(u32 type)\r\n{\r\nswitch (type) {\r\ncase INTEL_GUC_CT_BUFFER_TYPE_SEND:\r\nreturn "SEND";\r\ncase INTEL_GUC_CT_BUFFER_TYPE_RECV:\r\nreturn "RECV";\r\ndefault:\r\nreturn "<invalid>";\r\n}\r\n}\r\nstatic void guc_ct_buffer_desc_init(struct guc_ct_buffer_desc *desc,\r\nu32 cmds_addr, u32 size, u32 owner)\r\n{\r\nDRM_DEBUG_DRIVER("CT: desc %p init addr=%#x size=%u owner=%u\n",\r\ndesc, cmds_addr, size, owner);\r\nmemset(desc, 0, sizeof(*desc));\r\ndesc->addr = cmds_addr;\r\ndesc->size = size;\r\ndesc->owner = owner;\r\n}\r\nstatic void guc_ct_buffer_desc_reset(struct guc_ct_buffer_desc *desc)\r\n{\r\nDRM_DEBUG_DRIVER("CT: desc %p reset head=%u tail=%u\n",\r\ndesc, desc->head, desc->tail);\r\ndesc->head = 0;\r\ndesc->tail = 0;\r\ndesc->is_in_error = 0;\r\n}\r\nstatic int guc_action_register_ct_buffer(struct intel_guc *guc,\r\nu32 desc_addr,\r\nu32 type)\r\n{\r\nu32 action[] = {\r\nINTEL_GUC_ACTION_REGISTER_COMMAND_TRANSPORT_BUFFER,\r\ndesc_addr,\r\nsizeof(struct guc_ct_buffer_desc),\r\ntype\r\n};\r\nint err;\r\nerr = intel_guc_send_mmio(guc, action, ARRAY_SIZE(action));\r\nif (err)\r\nDRM_ERROR("CT: register %s buffer failed; err=%d\n",\r\nguc_ct_buffer_type_to_str(type), err);\r\nreturn err;\r\n}\r\nstatic int guc_action_deregister_ct_buffer(struct intel_guc *guc,\r\nu32 owner,\r\nu32 type)\r\n{\r\nu32 action[] = {\r\nINTEL_GUC_ACTION_DEREGISTER_COMMAND_TRANSPORT_BUFFER,\r\nowner,\r\ntype\r\n};\r\nint err;\r\nerr = intel_guc_send_mmio(guc, action, ARRAY_SIZE(action));\r\nif (err)\r\nDRM_ERROR("CT: deregister %s buffer failed; owner=%d err=%d\n",\r\nguc_ct_buffer_type_to_str(type), owner, err);\r\nreturn err;\r\n}\r\nstatic bool ctch_is_open(struct intel_guc_ct_channel *ctch)\r\n{\r\nreturn ctch->vma != NULL;\r\n}\r\nstatic int ctch_init(struct intel_guc *guc,\r\nstruct intel_guc_ct_channel *ctch)\r\n{\r\nstruct i915_vma *vma;\r\nvoid *blob;\r\nint err;\r\nint i;\r\nGEM_BUG_ON(ctch->vma);\r\nvma = intel_guc_allocate_vma(guc, PAGE_SIZE);\r\nif (IS_ERR(vma)) {\r\nerr = PTR_ERR(vma);\r\ngoto err_out;\r\n}\r\nctch->vma = vma;\r\nblob = i915_gem_object_pin_map(vma->obj, I915_MAP_WB);\r\nif (IS_ERR(blob)) {\r\nerr = PTR_ERR(blob);\r\ngoto err_vma;\r\n}\r\nDRM_DEBUG_DRIVER("CT: vma base=%#x\n", guc_ggtt_offset(ctch->vma));\r\nfor (i = 0; i < ARRAY_SIZE(ctch->ctbs); i++) {\r\nGEM_BUG_ON((i != CTB_SEND) && (i != CTB_RECV));\r\nctch->ctbs[i].desc = blob + PAGE_SIZE/4 * i;\r\nctch->ctbs[i].cmds = blob + PAGE_SIZE/4 * i + PAGE_SIZE/2;\r\n}\r\nreturn 0;\r\nerr_vma:\r\ni915_vma_unpin_and_release(&ctch->vma);\r\nerr_out:\r\nDRM_DEBUG_DRIVER("CT: channel %d initialization failed; err=%d\n",\r\nctch->owner, err);\r\nreturn err;\r\n}\r\nstatic void ctch_fini(struct intel_guc *guc,\r\nstruct intel_guc_ct_channel *ctch)\r\n{\r\nGEM_BUG_ON(!ctch->vma);\r\ni915_gem_object_unpin_map(ctch->vma->obj);\r\ni915_vma_unpin_and_release(&ctch->vma);\r\n}\r\nstatic int ctch_open(struct intel_guc *guc,\r\nstruct intel_guc_ct_channel *ctch)\r\n{\r\nu32 base;\r\nint err;\r\nint i;\r\nDRM_DEBUG_DRIVER("CT: channel %d reopen=%s\n",\r\nctch->owner, yesno(ctch_is_open(ctch)));\r\nif (!ctch->vma) {\r\nerr = ctch_init(guc, ctch);\r\nif (unlikely(err))\r\ngoto err_out;\r\n}\r\nbase = guc_ggtt_offset(ctch->vma);\r\nfor (i = 0; i < ARRAY_SIZE(ctch->ctbs); i++) {\r\nGEM_BUG_ON((i != CTB_SEND) && (i != CTB_RECV));\r\nguc_ct_buffer_desc_init(ctch->ctbs[i].desc,\r\nbase + PAGE_SIZE/4 * i + PAGE_SIZE/2,\r\nPAGE_SIZE/4,\r\nctch->owner);\r\n}\r\nerr = guc_action_register_ct_buffer(guc,\r\nbase + PAGE_SIZE/4 * CTB_RECV,\r\nINTEL_GUC_CT_BUFFER_TYPE_RECV);\r\nif (unlikely(err))\r\ngoto err_fini;\r\nerr = guc_action_register_ct_buffer(guc,\r\nbase + PAGE_SIZE/4 * CTB_SEND,\r\nINTEL_GUC_CT_BUFFER_TYPE_SEND);\r\nif (unlikely(err))\r\ngoto err_deregister;\r\nreturn 0;\r\nerr_deregister:\r\nguc_action_deregister_ct_buffer(guc,\r\nctch->owner,\r\nINTEL_GUC_CT_BUFFER_TYPE_RECV);\r\nerr_fini:\r\nctch_fini(guc, ctch);\r\nerr_out:\r\nDRM_ERROR("CT: can't open channel %d; err=%d\n", ctch->owner, err);\r\nreturn err;\r\n}\r\nstatic void ctch_close(struct intel_guc *guc,\r\nstruct intel_guc_ct_channel *ctch)\r\n{\r\nGEM_BUG_ON(!ctch_is_open(ctch));\r\nguc_action_deregister_ct_buffer(guc,\r\nctch->owner,\r\nINTEL_GUC_CT_BUFFER_TYPE_SEND);\r\nguc_action_deregister_ct_buffer(guc,\r\nctch->owner,\r\nINTEL_GUC_CT_BUFFER_TYPE_RECV);\r\nctch_fini(guc, ctch);\r\n}\r\nstatic u32 ctch_get_next_fence(struct intel_guc_ct_channel *ctch)\r\n{\r\nreturn ++ctch->next_fence;\r\n}\r\nstatic int ctb_write(struct intel_guc_ct_buffer *ctb,\r\nconst u32 *action,\r\nu32 len ,\r\nu32 fence)\r\n{\r\nstruct guc_ct_buffer_desc *desc = ctb->desc;\r\nu32 head = desc->head / 4;\r\nu32 tail = desc->tail / 4;\r\nu32 size = desc->size / 4;\r\nu32 used;\r\nu32 header;\r\nu32 *cmds = ctb->cmds;\r\nunsigned int i;\r\nGEM_BUG_ON(desc->size % 4);\r\nGEM_BUG_ON(desc->head % 4);\r\nGEM_BUG_ON(desc->tail % 4);\r\nGEM_BUG_ON(tail >= size);\r\nif (tail < head)\r\nused = (size - head) + tail;\r\nelse\r\nused = tail - head;\r\nif (unlikely(used + len + 1 >= size))\r\nreturn -ENOSPC;\r\nheader = (len << GUC_CT_MSG_LEN_SHIFT) |\r\n(GUC_CT_MSG_WRITE_FENCE_TO_DESC) |\r\n(action[0] << GUC_CT_MSG_ACTION_SHIFT);\r\ncmds[tail] = header;\r\ntail = (tail + 1) % size;\r\ncmds[tail] = fence;\r\ntail = (tail + 1) % size;\r\nfor (i = 1; i < len; i++) {\r\ncmds[tail] = action[i];\r\ntail = (tail + 1) % size;\r\n}\r\ndesc->tail = tail * 4;\r\nGEM_BUG_ON(desc->tail > desc->size);\r\nreturn 0;\r\n}\r\nstatic int wait_for_response(struct guc_ct_buffer_desc *desc,\r\nu32 fence,\r\nu32 *status)\r\n{\r\nint err;\r\n#define done (READ_ONCE(desc->fence) == fence)\r\nerr = wait_for_us(done, 10);\r\nif (err)\r\nerr = wait_for(done, 10);\r\n#undef done\r\nif (unlikely(err)) {\r\nDRM_ERROR("CT: fence %u failed; reported fence=%u\n",\r\nfence, desc->fence);\r\nif (WARN_ON(desc->is_in_error)) {\r\nguc_ct_buffer_desc_reset(desc);\r\nerr = -EPROTO;\r\n}\r\n}\r\n*status = desc->status;\r\nreturn err;\r\n}\r\nstatic int ctch_send(struct intel_guc *guc,\r\nstruct intel_guc_ct_channel *ctch,\r\nconst u32 *action,\r\nu32 len,\r\nu32 *status)\r\n{\r\nstruct intel_guc_ct_buffer *ctb = &ctch->ctbs[CTB_SEND];\r\nstruct guc_ct_buffer_desc *desc = ctb->desc;\r\nu32 fence;\r\nint err;\r\nGEM_BUG_ON(!ctch_is_open(ctch));\r\nGEM_BUG_ON(!len);\r\nGEM_BUG_ON(len & ~GUC_CT_MSG_LEN_MASK);\r\nfence = ctch_get_next_fence(ctch);\r\nerr = ctb_write(ctb, action, len, fence);\r\nif (unlikely(err))\r\nreturn err;\r\nintel_guc_notify(guc);\r\nerr = wait_for_response(desc, fence, status);\r\nif (unlikely(err))\r\nreturn err;\r\nif (*status != INTEL_GUC_STATUS_SUCCESS)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int intel_guc_send_ct(struct intel_guc *guc, const u32 *action, u32 len)\r\n{\r\nstruct intel_guc_ct_channel *ctch = &guc->ct.host_channel;\r\nu32 status = ~0;\r\nint err;\r\nmutex_lock(&guc->send_mutex);\r\nerr = ctch_send(guc, ctch, action, len, &status);\r\nif (unlikely(err)) {\r\nDRM_ERROR("CT: send action %#X failed; err=%d status=%#X\n",\r\naction[0], err, status);\r\n}\r\nmutex_unlock(&guc->send_mutex);\r\nreturn err;\r\n}\r\nint intel_guc_enable_ct(struct intel_guc *guc)\r\n{\r\nstruct drm_i915_private *dev_priv = guc_to_i915(guc);\r\nstruct intel_guc_ct_channel *ctch = &guc->ct.host_channel;\r\nint err;\r\nGEM_BUG_ON(!HAS_GUC_CT(dev_priv));\r\nerr = ctch_open(guc, ctch);\r\nif (unlikely(err))\r\nreturn err;\r\nguc->send = intel_guc_send_ct;\r\nDRM_INFO("CT: %s\n", enableddisabled(true));\r\nreturn 0;\r\n}\r\nvoid intel_guc_disable_ct(struct intel_guc *guc)\r\n{\r\nstruct drm_i915_private *dev_priv = guc_to_i915(guc);\r\nstruct intel_guc_ct_channel *ctch = &guc->ct.host_channel;\r\nGEM_BUG_ON(!HAS_GUC_CT(dev_priv));\r\nif (!ctch_is_open(ctch))\r\nreturn;\r\nctch_close(guc, ctch);\r\nguc->send = intel_guc_send_nop;\r\nDRM_INFO("CT: %s\n", enableddisabled(false));\r\n}
