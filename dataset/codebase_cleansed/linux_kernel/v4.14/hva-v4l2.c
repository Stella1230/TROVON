static inline int frame_size(u32 w, u32 h, u32 fmt)\r\n{\r\nswitch (fmt) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\nreturn (w * h * 3) / 2;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline int frame_stride(u32 w, u32 fmt)\r\n{\r\nswitch (fmt) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\nreturn w;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline int frame_alignment(u32 fmt)\r\n{\r\nswitch (fmt) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\nreturn 2;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic inline int estimated_stream_size(u32 w, u32 h)\r\n{\r\nreturn (w * h * 3) / 4;\r\n}\r\nstatic void set_default_params(struct hva_ctx *ctx)\r\n{\r\nstruct hva_frameinfo *frameinfo = &ctx->frameinfo;\r\nstruct hva_streaminfo *streaminfo = &ctx->streaminfo;\r\nframeinfo->pixelformat = V4L2_PIX_FMT_NV12;\r\nframeinfo->width = HVA_DEFAULT_WIDTH;\r\nframeinfo->height = HVA_DEFAULT_HEIGHT;\r\nframeinfo->aligned_width = ALIGN(frameinfo->width,\r\nHVA_WIDTH_ALIGNMENT);\r\nframeinfo->aligned_height = ALIGN(frameinfo->height,\r\nHVA_HEIGHT_ALIGNMENT);\r\nframeinfo->size = frame_size(frameinfo->aligned_width,\r\nframeinfo->aligned_height,\r\nframeinfo->pixelformat);\r\nstreaminfo->streamformat = V4L2_PIX_FMT_H264;\r\nstreaminfo->width = HVA_DEFAULT_WIDTH;\r\nstreaminfo->height = HVA_DEFAULT_HEIGHT;\r\nctx->colorspace = V4L2_COLORSPACE_REC709;\r\nctx->xfer_func = V4L2_XFER_FUNC_DEFAULT;\r\nctx->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\r\nctx->quantization = V4L2_QUANTIZATION_DEFAULT;\r\nctx->max_stream_size = estimated_stream_size(streaminfo->width,\r\nstreaminfo->height);\r\n}\r\nstatic const struct hva_enc *hva_find_encoder(struct hva_ctx *ctx,\r\nu32 pixelformat,\r\nu32 streamformat)\r\n{\r\nstruct hva_dev *hva = ctx_to_hdev(ctx);\r\nconst struct hva_enc *enc;\r\nunsigned int i;\r\nfor (i = 0; i < hva->nb_of_encoders; i++) {\r\nenc = hva->encoders[i];\r\nif ((enc->pixelformat == pixelformat) &&\r\n(enc->streamformat == streamformat))\r\nreturn enc;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void register_format(u32 format, u32 formats[], u32 *nb_of_formats)\r\n{\r\nu32 i;\r\nbool found = false;\r\nfor (i = 0; i < *nb_of_formats; i++) {\r\nif (format == formats[i]) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nformats[(*nb_of_formats)++] = format;\r\n}\r\nstatic void register_formats(struct hva_dev *hva)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < hva->nb_of_encoders; i++) {\r\nregister_format(hva->encoders[i]->pixelformat,\r\nhva->pixelformats,\r\n&hva->nb_of_pixelformats);\r\nregister_format(hva->encoders[i]->streamformat,\r\nhva->streamformats,\r\n&hva->nb_of_streamformats);\r\n}\r\n}\r\nstatic void register_encoders(struct hva_dev *hva)\r\n{\r\nstruct device *dev = hva_to_dev(hva);\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(hva_encoders); i++) {\r\nif (hva->nb_of_encoders >= HVA_MAX_ENCODERS) {\r\ndev_dbg(dev,\r\n"%s failed to register %s encoder (%d maximum reached)\n",\r\nHVA_PREFIX, hva_encoders[i]->name,\r\nHVA_MAX_ENCODERS);\r\nreturn;\r\n}\r\nhva->encoders[hva->nb_of_encoders++] = hva_encoders[i];\r\ndev_info(dev, "%s %s encoder registered\n", HVA_PREFIX,\r\nhva_encoders[i]->name);\r\n}\r\n}\r\nstatic int hva_open_encoder(struct hva_ctx *ctx, u32 streamformat,\r\nu32 pixelformat, struct hva_enc **penc)\r\n{\r\nstruct hva_dev *hva = ctx_to_hdev(ctx);\r\nstruct device *dev = ctx_to_dev(ctx);\r\nstruct hva_enc *enc;\r\nint ret;\r\nenc = (struct hva_enc *)hva_find_encoder(ctx, pixelformat,\r\nstreamformat);\r\nif (!enc) {\r\ndev_err(dev, "%s no encoder found matching %4.4s => %4.4s\n",\r\nctx->name, (char *)&pixelformat, (char *)&streamformat);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dev, "%s one encoder matching %4.4s => %4.4s\n",\r\nctx->name, (char *)&pixelformat, (char *)&streamformat);\r\nsnprintf(ctx->name, sizeof(ctx->name), "[%3d:%4.4s]",\r\nhva->instance_id, (char *)&streamformat);\r\nret = enc->open(ctx);\r\nif (ret) {\r\ndev_err(dev, "%s failed to open encoder instance (%d)\n",\r\nctx->name, ret);\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "%s %s encoder opened\n", ctx->name, enc->name);\r\n*penc = enc;\r\nreturn ret;\r\n}\r\nstatic void hva_dbg_summary(struct hva_ctx *ctx)\r\n{\r\nstruct device *dev = ctx_to_dev(ctx);\r\nstruct hva_streaminfo *stream = &ctx->streaminfo;\r\nstruct hva_frameinfo *frame = &ctx->frameinfo;\r\nif (!(ctx->flags & HVA_FLAG_STREAMINFO))\r\nreturn;\r\ndev_dbg(dev, "%s %4.4s %dx%d > %4.4s %dx%d %s %s: %d frames encoded, %d system errors, %d encoding errors, %d frame errors\n",\r\nctx->name,\r\n(char *)&frame->pixelformat,\r\nframe->aligned_width, frame->aligned_height,\r\n(char *)&stream->streamformat,\r\nstream->width, stream->height,\r\nstream->profile, stream->level,\r\nctx->encoded_frames,\r\nctx->sys_errors,\r\nctx->encode_errors,\r\nctx->frame_errors);\r\n}\r\nstatic int hva_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct hva_dev *hva = ctx_to_hdev(ctx);\r\nstrlcpy(cap->driver, HVA_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, hva->vdev->name, sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",\r\nhva->pdev->name);\r\nreturn 0;\r\n}\r\nstatic int hva_enum_fmt_stream(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct hva_dev *hva = ctx_to_hdev(ctx);\r\nif (unlikely(f->index >= hva->nb_of_streamformats))\r\nreturn -EINVAL;\r\nf->pixelformat = hva->streamformats[f->index];\r\nreturn 0;\r\n}\r\nstatic int hva_enum_fmt_frame(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct hva_dev *hva = ctx_to_hdev(ctx);\r\nif (unlikely(f->index >= hva->nb_of_pixelformats))\r\nreturn -EINVAL;\r\nf->pixelformat = hva->pixelformats[f->index];\r\nreturn 0;\r\n}\r\nstatic int hva_g_fmt_stream(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct hva_streaminfo *streaminfo = &ctx->streaminfo;\r\nf->fmt.pix.width = streaminfo->width;\r\nf->fmt.pix.height = streaminfo->height;\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nf->fmt.pix.colorspace = ctx->colorspace;\r\nf->fmt.pix.xfer_func = ctx->xfer_func;\r\nf->fmt.pix.ycbcr_enc = ctx->ycbcr_enc;\r\nf->fmt.pix.quantization = ctx->quantization;\r\nf->fmt.pix.pixelformat = streaminfo->streamformat;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage = ctx->max_stream_size;\r\nreturn 0;\r\n}\r\nstatic int hva_g_fmt_frame(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct hva_frameinfo *frameinfo = &ctx->frameinfo;\r\nf->fmt.pix.width = frameinfo->width;\r\nf->fmt.pix.height = frameinfo->height;\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nf->fmt.pix.colorspace = ctx->colorspace;\r\nf->fmt.pix.xfer_func = ctx->xfer_func;\r\nf->fmt.pix.ycbcr_enc = ctx->ycbcr_enc;\r\nf->fmt.pix.quantization = ctx->quantization;\r\nf->fmt.pix.pixelformat = frameinfo->pixelformat;\r\nf->fmt.pix.bytesperline = frame_stride(frameinfo->aligned_width,\r\nframeinfo->pixelformat);\r\nf->fmt.pix.sizeimage = frameinfo->size;\r\nreturn 0;\r\n}\r\nstatic int hva_try_fmt_stream(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct device *dev = ctx_to_dev(ctx);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nu32 streamformat = pix->pixelformat;\r\nconst struct hva_enc *enc;\r\nu32 width, height;\r\nu32 stream_size;\r\nenc = hva_find_encoder(ctx, ctx->frameinfo.pixelformat, streamformat);\r\nif (!enc) {\r\ndev_dbg(dev,\r\n"%s V4L2 TRY_FMT (CAPTURE): unsupported format %.4s\n",\r\nctx->name, (char *)&pix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\nwidth = pix->width;\r\nheight = pix->height;\r\nif (ctx->flags & HVA_FLAG_FRAMEINFO) {\r\npix->width = ctx->frameinfo.width;\r\npix->height = ctx->frameinfo.height;\r\nif ((pix->width != width) || (pix->height != height))\r\ndev_dbg(dev,\r\n"%s V4L2 TRY_FMT (CAPTURE): resolution updated %dx%d -> %dx%d to fit frame resolution\n",\r\nctx->name, width, height,\r\npix->width, pix->height);\r\n} else {\r\nv4l_bound_align_image(&pix->width,\r\nHVA_MIN_WIDTH, enc->max_width,\r\n0,\r\n&pix->height,\r\nHVA_MIN_HEIGHT, enc->max_height,\r\n0,\r\n0);\r\nif ((pix->width != width) || (pix->height != height))\r\ndev_dbg(dev,\r\n"%s V4L2 TRY_FMT (CAPTURE): resolution updated %dx%d -> %dx%d to fit min/max/alignment\n",\r\nctx->name, width, height,\r\npix->width, pix->height);\r\n}\r\nstream_size = estimated_stream_size(pix->width, pix->height);\r\nif (pix->sizeimage < stream_size)\r\npix->sizeimage = stream_size;\r\npix->bytesperline = 0;\r\npix->colorspace = ctx->colorspace;\r\npix->xfer_func = ctx->xfer_func;\r\npix->ycbcr_enc = ctx->ycbcr_enc;\r\npix->quantization = ctx->quantization;\r\npix->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int hva_try_fmt_frame(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct device *dev = ctx_to_dev(ctx);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nu32 pixelformat = pix->pixelformat;\r\nconst struct hva_enc *enc;\r\nu32 width, height;\r\nenc = hva_find_encoder(ctx, pixelformat, ctx->streaminfo.streamformat);\r\nif (!enc) {\r\ndev_dbg(dev,\r\n"%s V4L2 TRY_FMT (OUTPUT): unsupported format %.4s\n",\r\nctx->name, (char *)&pixelformat);\r\nreturn -EINVAL;\r\n}\r\nwidth = pix->width;\r\nheight = pix->height;\r\nv4l_bound_align_image(&pix->width,\r\nHVA_MIN_WIDTH, HVA_MAX_WIDTH,\r\nframe_alignment(pixelformat) - 1,\r\n&pix->height,\r\nHVA_MIN_HEIGHT, HVA_MAX_HEIGHT,\r\nframe_alignment(pixelformat) - 1,\r\n0);\r\nif ((pix->width != width) || (pix->height != height))\r\ndev_dbg(dev,\r\n"%s V4L2 TRY_FMT (OUTPUT): resolution updated %dx%d -> %dx%d to fit min/max/alignment\n",\r\nctx->name, width, height, pix->width, pix->height);\r\nwidth = ALIGN(pix->width, HVA_WIDTH_ALIGNMENT);\r\nheight = ALIGN(pix->height, HVA_HEIGHT_ALIGNMENT);\r\nif (!pix->colorspace) {\r\npix->colorspace = V4L2_COLORSPACE_REC709;\r\npix->xfer_func = V4L2_XFER_FUNC_DEFAULT;\r\npix->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\r\npix->quantization = V4L2_QUANTIZATION_DEFAULT;\r\n}\r\npix->bytesperline = frame_stride(width, pixelformat);\r\npix->sizeimage = frame_size(width, height, pixelformat);\r\npix->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int hva_s_fmt_stream(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct device *dev = ctx_to_dev(ctx);\r\nstruct vb2_queue *vq;\r\nint ret;\r\nret = hva_try_fmt_stream(file, fh, f);\r\nif (ret) {\r\ndev_dbg(dev, "%s V4L2 S_FMT (CAPTURE): unsupported format %.4s\n",\r\nctx->name, (char *)&f->fmt.pix.pixelformat);\r\nreturn ret;\r\n}\r\nvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\r\nif (vb2_is_streaming(vq)) {\r\ndev_dbg(dev, "%s V4L2 S_FMT (CAPTURE): queue busy\n",\r\nctx->name);\r\nreturn -EBUSY;\r\n}\r\nctx->max_stream_size = f->fmt.pix.sizeimage;\r\nctx->streaminfo.width = f->fmt.pix.width;\r\nctx->streaminfo.height = f->fmt.pix.height;\r\nctx->streaminfo.streamformat = f->fmt.pix.pixelformat;\r\nctx->flags |= HVA_FLAG_STREAMINFO;\r\nreturn 0;\r\n}\r\nstatic int hva_s_fmt_frame(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct device *dev = ctx_to_dev(ctx);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct vb2_queue *vq;\r\nint ret;\r\nret = hva_try_fmt_frame(file, fh, f);\r\nif (ret) {\r\ndev_dbg(dev, "%s V4L2 S_FMT (OUTPUT): unsupported format %.4s\n",\r\nctx->name, (char *)&pix->pixelformat);\r\nreturn ret;\r\n}\r\nvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\r\nif (vb2_is_streaming(vq)) {\r\ndev_dbg(dev, "%s V4L2 S_FMT (OUTPUT): queue busy\n", ctx->name);\r\nreturn -EBUSY;\r\n}\r\nctx->colorspace = pix->colorspace;\r\nctx->xfer_func = pix->xfer_func;\r\nctx->ycbcr_enc = pix->ycbcr_enc;\r\nctx->quantization = pix->quantization;\r\nctx->frameinfo.aligned_width = ALIGN(pix->width, HVA_WIDTH_ALIGNMENT);\r\nctx->frameinfo.aligned_height = ALIGN(pix->height,\r\nHVA_HEIGHT_ALIGNMENT);\r\nctx->frameinfo.size = pix->sizeimage;\r\nctx->frameinfo.pixelformat = pix->pixelformat;\r\nctx->frameinfo.width = pix->width;\r\nctx->frameinfo.height = pix->height;\r\nctx->flags |= HVA_FLAG_FRAMEINFO;\r\nreturn 0;\r\n}\r\nstatic int hva_g_parm(struct file *file, void *fh, struct v4l2_streamparm *sp)\r\n{\r\nstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct v4l2_fract *time_per_frame = &ctx->ctrls.time_per_frame;\r\nif (sp->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\nsp->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\r\nsp->parm.output.timeperframe.numerator = time_per_frame->numerator;\r\nsp->parm.output.timeperframe.denominator =\r\ntime_per_frame->denominator;\r\nreturn 0;\r\n}\r\nstatic int hva_s_parm(struct file *file, void *fh, struct v4l2_streamparm *sp)\r\n{\r\nstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct v4l2_fract *time_per_frame = &ctx->ctrls.time_per_frame;\r\nif (sp->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\nif (!sp->parm.output.timeperframe.numerator ||\r\n!sp->parm.output.timeperframe.denominator)\r\nreturn hva_g_parm(file, fh, sp);\r\nsp->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\r\ntime_per_frame->numerator = sp->parm.output.timeperframe.numerator;\r\ntime_per_frame->denominator =\r\nsp->parm.output.timeperframe.denominator;\r\nreturn 0;\r\n}\r\nstatic int hva_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct device *dev = ctx_to_dev(ctx);\r\nif (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nstruct vb2_queue *vq;\r\nstruct hva_stream *stream;\r\nvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, buf->type);\r\nif (buf->index >= vq->num_buffers) {\r\ndev_dbg(dev, "%s buffer index %d out of range (%d)\n",\r\nctx->name, buf->index, vq->num_buffers);\r\nreturn -EINVAL;\r\n}\r\nstream = (struct hva_stream *)vq->bufs[buf->index];\r\nstream->bytesused = buf->bytesused;\r\n}\r\nreturn v4l2_m2m_qbuf(file, ctx->fh.m2m_ctx, buf);\r\n}\r\nstatic int hva_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct hva_ctx *ctx = container_of(ctrl->handler, struct hva_ctx,\r\nctrl_handler);\r\nstruct device *dev = ctx_to_dev(ctx);\r\ndev_dbg(dev, "%s S_CTRL: id = %d, val = %d\n", ctx->name,\r\nctrl->id, ctrl->val);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\nctx->ctrls.bitrate_mode = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\nctx->ctrls.gop_size = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE:\r\nctx->ctrls.bitrate = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\nctx->ctrls.aspect = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_PROFILE:\r\nctx->ctrls.profile = ctrl->val;\r\nsnprintf(ctx->streaminfo.profile,\r\nsizeof(ctx->streaminfo.profile),\r\n"%s profile",\r\nv4l2_ctrl_get_menu(ctrl->id)[ctrl->val]);\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_LEVEL:\r\nctx->ctrls.level = ctrl->val;\r\nsnprintf(ctx->streaminfo.level,\r\nsizeof(ctx->streaminfo.level),\r\n"level %s",\r\nv4l2_ctrl_get_menu(ctrl->id)[ctrl->val]);\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE:\r\nctx->ctrls.entropy_mode = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE:\r\nctx->ctrls.cpb_size = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM:\r\nctx->ctrls.dct8x8 = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_MIN_QP:\r\nctx->ctrls.qpmin = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_MAX_QP:\r\nctx->ctrls.qpmax = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE:\r\nctx->ctrls.vui_sar = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC:\r\nctx->ctrls.vui_sar_idc = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING:\r\nctx->ctrls.sei_fp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE:\r\nctx->ctrls.sei_fp_type = ctrl->val;\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "%s S_CTRL: invalid control (id = %d)\n",\r\nctx->name, ctrl->id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hva_ctrls_setup(struct hva_ctx *ctx)\r\n{\r\nstruct device *dev = ctx_to_dev(ctx);\r\nu64 mask;\r\nenum v4l2_mpeg_video_h264_sei_fp_arrangement_type sei_fp_type =\r\nV4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TOP_BOTTOM;\r\nv4l2_ctrl_handler_init(&ctx->ctrl_handler, 15);\r\nv4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_BITRATE_MODE,\r\nV4L2_MPEG_VIDEO_BITRATE_MODE_CBR,\r\n0,\r\nV4L2_MPEG_VIDEO_BITRATE_MODE_CBR);\r\nv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_GOP_SIZE,\r\n1, 60, 1, 16);\r\nv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_BITRATE,\r\n1000, 60000000, 1000, 20000000);\r\nmask = ~(1 << V4L2_MPEG_VIDEO_ASPECT_1x1);\r\nv4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_ASPECT,\r\nV4L2_MPEG_VIDEO_ASPECT_1x1,\r\nmask,\r\nV4L2_MPEG_VIDEO_ASPECT_1x1);\r\nmask = ~((1 << V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE) |\r\n(1 << V4L2_MPEG_VIDEO_H264_PROFILE_MAIN) |\r\n(1 << V4L2_MPEG_VIDEO_H264_PROFILE_HIGH) |\r\n(1 << V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH));\r\nv4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_PROFILE,\r\nV4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH,\r\nmask,\r\nV4L2_MPEG_VIDEO_H264_PROFILE_HIGH);\r\nv4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_LEVEL,\r\nV4L2_MPEG_VIDEO_H264_LEVEL_4_2,\r\n0,\r\nV4L2_MPEG_VIDEO_H264_LEVEL_4_0);\r\nv4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE,\r\nV4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC,\r\n0,\r\nV4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC);\r\nv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_CPB_SIZE,\r\n1, 10000, 1, 3000);\r\nv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM,\r\n0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_MIN_QP,\r\n0, 51, 1, 5);\r\nv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_MAX_QP,\r\n0, 51, 1, 51);\r\nv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE,\r\n0, 1, 1, 1);\r\nmask = ~(1 << V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1);\r\nv4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC,\r\nV4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1,\r\nmask,\r\nV4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1);\r\nv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING,\r\n0, 1, 1, 0);\r\nmask = ~(1 << sei_fp_type);\r\nv4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE,\r\nsei_fp_type,\r\nmask,\r\nsei_fp_type);\r\nif (ctx->ctrl_handler.error) {\r\nint err = ctx->ctrl_handler.error;\r\ndev_dbg(dev, "%s controls setup failed (%d)\n",\r\nctx->name, err);\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nreturn err;\r\n}\r\nv4l2_ctrl_handler_setup(&ctx->ctrl_handler);\r\nctx->ctrls.time_per_frame.numerator = HVA_DEFAULT_FRAME_NUM;\r\nctx->ctrls.time_per_frame.denominator = HVA_DEFAULT_FRAME_DEN;\r\nreturn 0;\r\n}\r\nstatic void hva_run_work(struct work_struct *work)\r\n{\r\nstruct hva_ctx *ctx = container_of(work, struct hva_ctx, run_work);\r\nstruct vb2_v4l2_buffer *src_buf, *dst_buf;\r\nconst struct hva_enc *enc = ctx->enc;\r\nstruct hva_frame *frame;\r\nstruct hva_stream *stream;\r\nint ret;\r\nmutex_lock(&ctx->lock);\r\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\r\nhva_dbg_perf_begin(ctx);\r\n#endif\r\nsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\r\ndst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\r\nframe = to_hva_frame(src_buf);\r\nstream = to_hva_stream(dst_buf);\r\nframe->vbuf.sequence = ctx->frame_num++;\r\nret = enc->encode(ctx, frame, stream);\r\nvb2_set_plane_payload(&dst_buf->vb2_buf, 0, stream->bytesused);\r\nif (ret) {\r\nv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);\r\nv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);\r\n} else {\r\ndst_buf->vb2_buf.timestamp = src_buf->vb2_buf.timestamp;\r\ndst_buf->field = V4L2_FIELD_NONE;\r\ndst_buf->sequence = ctx->stream_num - 1;\r\nctx->encoded_frames++;\r\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\r\nhva_dbg_perf_end(ctx, stream);\r\n#endif\r\nv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\r\nv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);\r\n}\r\nmutex_unlock(&ctx->lock);\r\nv4l2_m2m_job_finish(ctx->hva_dev->m2m_dev, ctx->fh.m2m_ctx);\r\n}\r\nstatic void hva_device_run(void *priv)\r\n{\r\nstruct hva_ctx *ctx = priv;\r\nstruct hva_dev *hva = ctx_to_hdev(ctx);\r\nqueue_work(hva->work_queue, &ctx->run_work);\r\n}\r\nstatic void hva_job_abort(void *priv)\r\n{\r\nstruct hva_ctx *ctx = priv;\r\nstruct device *dev = ctx_to_dev(ctx);\r\ndev_dbg(dev, "%s aborting job\n", ctx->name);\r\nctx->aborting = true;\r\n}\r\nstatic int hva_job_ready(void *priv)\r\n{\r\nstruct hva_ctx *ctx = priv;\r\nstruct device *dev = ctx_to_dev(ctx);\r\nif (!v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx)) {\r\ndev_dbg(dev, "%s job not ready: no frame buffers\n",\r\nctx->name);\r\nreturn 0;\r\n}\r\nif (!v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx)) {\r\ndev_dbg(dev, "%s job not ready: no stream buffers\n",\r\nctx->name);\r\nreturn 0;\r\n}\r\nif (ctx->aborting) {\r\ndev_dbg(dev, "%s job not ready: aborting\n", ctx->name);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int hva_queue_setup(struct vb2_queue *vq,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct hva_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct device *dev = ctx_to_dev(ctx);\r\nunsigned int size;\r\ndev_dbg(dev, "%s %s queue setup: num_buffers %d\n", ctx->name,\r\nto_type_str(vq->type), *num_buffers);\r\nsize = vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT ?\r\nctx->frameinfo.size : ctx->max_stream_size;\r\nif (*num_planes)\r\nreturn sizes[0] < size ? -EINVAL : 0;\r\n*num_planes = 1;\r\nsizes[0] = size;\r\nreturn 0;\r\n}\r\nstatic int hva_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct hva_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct device *dev = ctx_to_dev(ctx);\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nif (vb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nstruct hva_frame *frame = to_hva_frame(vbuf);\r\nif (vbuf->field == V4L2_FIELD_ANY)\r\nvbuf->field = V4L2_FIELD_NONE;\r\nif (vbuf->field != V4L2_FIELD_NONE) {\r\ndev_dbg(dev,\r\n"%s frame[%d] prepare: %d field not supported\n",\r\nctx->name, vb->index, vbuf->field);\r\nreturn -EINVAL;\r\n}\r\nif (!frame->prepared) {\r\nframe->vaddr = vb2_plane_vaddr(&vbuf->vb2_buf, 0);\r\nframe->paddr = vb2_dma_contig_plane_dma_addr(\r\n&vbuf->vb2_buf, 0);\r\nframe->info = ctx->frameinfo;\r\nframe->prepared = true;\r\ndev_dbg(dev,\r\n"%s frame[%d] prepared; virt=%p, phy=%pad\n",\r\nctx->name, vb->index,\r\nframe->vaddr, &frame->paddr);\r\n}\r\n} else {\r\nstruct hva_stream *stream = to_hva_stream(vbuf);\r\nif (!stream->prepared) {\r\nstream->vaddr = vb2_plane_vaddr(&vbuf->vb2_buf, 0);\r\nstream->paddr = vb2_dma_contig_plane_dma_addr(\r\n&vbuf->vb2_buf, 0);\r\nstream->size = vb2_plane_size(&vbuf->vb2_buf, 0);\r\nstream->prepared = true;\r\ndev_dbg(dev,\r\n"%s stream[%d] prepared; virt=%p, phy=%pad\n",\r\nctx->name, vb->index,\r\nstream->vaddr, &stream->paddr);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void hva_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct hva_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nif (ctx->fh.m2m_ctx)\r\nv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\r\n}\r\nstatic int hva_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct hva_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct hva_dev *hva = ctx_to_hdev(ctx);\r\nstruct device *dev = ctx_to_dev(ctx);\r\nstruct vb2_v4l2_buffer *vbuf;\r\nint ret;\r\nunsigned int i;\r\nbool found = false;\r\ndev_dbg(dev, "%s %s start streaming\n", ctx->name,\r\nto_type_str(vq->type));\r\nif (V4L2_TYPE_IS_OUTPUT(vq->type)) {\r\nif (!vb2_start_streaming_called(&ctx->fh.m2m_ctx->cap_q_ctx.q))\r\nreturn 0;\r\n} else {\r\nif (!vb2_start_streaming_called(&ctx->fh.m2m_ctx->out_q_ctx.q))\r\nreturn 0;\r\n}\r\nfor (i = 0; i < HVA_MAX_INSTANCES; i++) {\r\nif (!hva->instances[i]) {\r\nhva->instances[i] = ctx;\r\nctx->id = i;\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\ndev_err(dev, "%s maximum instances reached\n", ctx->name);\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nhva->nb_of_instances++;\r\nif (!ctx->enc) {\r\nret = hva_open_encoder(ctx,\r\nctx->streaminfo.streamformat,\r\nctx->frameinfo.pixelformat,\r\n&ctx->enc);\r\nif (ret < 0)\r\ngoto err_ctx;\r\n}\r\nreturn 0;\r\nerr_ctx:\r\nhva->instances[ctx->id] = NULL;\r\nhva->nb_of_instances--;\r\nerr:\r\nif (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nwhile ((vbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\r\nv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_QUEUED);\r\n} else {\r\nwhile ((vbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))\r\nv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_QUEUED);\r\n}\r\nctx->sys_errors++;\r\nreturn ret;\r\n}\r\nstatic void hva_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct hva_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct hva_dev *hva = ctx_to_hdev(ctx);\r\nstruct device *dev = ctx_to_dev(ctx);\r\nconst struct hva_enc *enc = ctx->enc;\r\nstruct vb2_v4l2_buffer *vbuf;\r\ndev_dbg(dev, "%s %s stop streaming\n", ctx->name,\r\nto_type_str(vq->type));\r\nif (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nctx->frame_num = 0;\r\nwhile ((vbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\r\nv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\r\n} else {\r\nctx->stream_num = 0;\r\nwhile ((vbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))\r\nv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\r\n}\r\nif ((V4L2_TYPE_IS_OUTPUT(vq->type) &&\r\nvb2_is_streaming(&ctx->fh.m2m_ctx->cap_q_ctx.q)) ||\r\n(!V4L2_TYPE_IS_OUTPUT(vq->type) &&\r\nvb2_is_streaming(&ctx->fh.m2m_ctx->out_q_ctx.q))) {\r\ndev_dbg(dev, "%s %s out=%d cap=%d\n",\r\nctx->name, to_type_str(vq->type),\r\nvb2_is_streaming(&ctx->fh.m2m_ctx->out_q_ctx.q),\r\nvb2_is_streaming(&ctx->fh.m2m_ctx->cap_q_ctx.q));\r\nreturn;\r\n}\r\nif (enc) {\r\ndev_dbg(dev, "%s %s encoder closed\n", ctx->name, enc->name);\r\nenc->close(ctx);\r\nctx->enc = NULL;\r\nhva->instances[ctx->id] = NULL;\r\nhva->nb_of_instances--;\r\n}\r\nctx->aborting = false;\r\n}\r\nstatic int queue_init(struct hva_ctx *ctx, struct vb2_queue *vq)\r\n{\r\nvq->io_modes = VB2_MMAP | VB2_DMABUF;\r\nvq->drv_priv = ctx;\r\nvq->ops = &hva_qops;\r\nvq->mem_ops = &vb2_dma_contig_memops;\r\nvq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nvq->lock = &ctx->hva_dev->lock;\r\nreturn vb2_queue_init(vq);\r\n}\r\nstatic int hva_queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nstruct hva_ctx *ctx = priv;\r\nint ret;\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nsrc_vq->buf_struct_size = sizeof(struct hva_frame);\r\nsrc_vq->min_buffers_needed = MIN_FRAMES;\r\nsrc_vq->dev = ctx->hva_dev->dev;\r\nret = queue_init(ctx, src_vq);\r\nif (ret)\r\nreturn ret;\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ndst_vq->buf_struct_size = sizeof(struct hva_stream);\r\ndst_vq->min_buffers_needed = MIN_STREAMS;\r\ndst_vq->dev = ctx->hva_dev->dev;\r\nreturn queue_init(ctx, dst_vq);\r\n}\r\nstatic int hva_open(struct file *file)\r\n{\r\nstruct hva_dev *hva = video_drvdata(file);\r\nstruct device *dev = hva_to_dev(hva);\r\nstruct hva_ctx *ctx;\r\nint ret;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nctx->hva_dev = hva;\r\nINIT_WORK(&ctx->run_work, hva_run_work);\r\nv4l2_fh_init(&ctx->fh, video_devdata(file));\r\nfile->private_data = &ctx->fh;\r\nv4l2_fh_add(&ctx->fh);\r\nret = hva_ctrls_setup(ctx);\r\nif (ret) {\r\ndev_err(dev, "%s [x:x] failed to setup controls\n",\r\nHVA_PREFIX);\r\nctx->sys_errors++;\r\ngoto err_fh;\r\n}\r\nctx->fh.ctrl_handler = &ctx->ctrl_handler;\r\nmutex_init(&ctx->lock);\r\nctx->fh.m2m_ctx = v4l2_m2m_ctx_init(hva->m2m_dev, ctx,\r\n&hva_queue_init);\r\nif (IS_ERR(ctx->fh.m2m_ctx)) {\r\nret = PTR_ERR(ctx->fh.m2m_ctx);\r\ndev_err(dev, "%s failed to initialize m2m context (%d)\n",\r\nHVA_PREFIX, ret);\r\nctx->sys_errors++;\r\ngoto err_ctrls;\r\n}\r\nmutex_lock(&hva->lock);\r\nhva->instance_id++;\r\nsnprintf(ctx->name, sizeof(ctx->name), "[%3d:----]",\r\nhva->instance_id);\r\nmutex_unlock(&hva->lock);\r\nset_default_params(ctx);\r\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\r\nhva_dbg_ctx_create(ctx);\r\n#endif\r\ndev_info(dev, "%s encoder instance created\n", ctx->name);\r\nreturn 0;\r\nerr_ctrls:\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nerr_fh:\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int hva_release(struct file *file)\r\n{\r\nstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct hva_dev *hva = ctx_to_hdev(ctx);\r\nstruct device *dev = ctx_to_dev(ctx);\r\nconst struct hva_enc *enc = ctx->enc;\r\nif (enc) {\r\ndev_dbg(dev, "%s %s encoder closed\n", ctx->name, enc->name);\r\nenc->close(ctx);\r\nctx->enc = NULL;\r\nhva->instances[ctx->id] = NULL;\r\nhva->nb_of_instances--;\r\n}\r\nhva_dbg_summary(ctx);\r\nv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\r\nhva_dbg_ctx_remove(ctx);\r\n#endif\r\ndev_info(dev, "%s encoder instance released\n", ctx->name);\r\nkfree(ctx);\r\nreturn 0;\r\n}\r\nstatic int hva_register_device(struct hva_dev *hva)\r\n{\r\nint ret;\r\nstruct video_device *vdev;\r\nstruct device *dev;\r\nif (!hva)\r\nreturn -ENODEV;\r\ndev = hva_to_dev(hva);\r\nhva->m2m_dev = v4l2_m2m_init(&hva_m2m_ops);\r\nif (IS_ERR(hva->m2m_dev)) {\r\ndev_err(dev, "%s failed to initialize v4l2-m2m device\n",\r\nHVA_PREFIX);\r\nret = PTR_ERR(hva->m2m_dev);\r\ngoto err;\r\n}\r\nvdev = video_device_alloc();\r\nif (!vdev) {\r\ndev_err(dev, "%s failed to allocate video device\n",\r\nHVA_PREFIX);\r\nret = -ENOMEM;\r\ngoto err_m2m_release;\r\n}\r\nvdev->fops = &hva_fops;\r\nvdev->ioctl_ops = &hva_ioctl_ops;\r\nvdev->release = video_device_release;\r\nvdev->lock = &hva->lock;\r\nvdev->vfl_dir = VFL_DIR_M2M;\r\nvdev->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M;\r\nvdev->v4l2_dev = &hva->v4l2_dev;\r\nsnprintf(vdev->name, sizeof(vdev->name), "%s%lx", HVA_NAME,\r\nhva->ip_version);\r\nret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret) {\r\ndev_err(dev, "%s failed to register video device\n",\r\nHVA_PREFIX);\r\ngoto err_vdev_release;\r\n}\r\nhva->vdev = vdev;\r\nvideo_set_drvdata(vdev, hva);\r\nreturn 0;\r\nerr_vdev_release:\r\nvideo_device_release(vdev);\r\nerr_m2m_release:\r\nv4l2_m2m_release(hva->m2m_dev);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void hva_unregister_device(struct hva_dev *hva)\r\n{\r\nif (!hva)\r\nreturn;\r\nif (hva->m2m_dev)\r\nv4l2_m2m_release(hva->m2m_dev);\r\nvideo_unregister_device(hva->vdev);\r\n}\r\nstatic int hva_probe(struct platform_device *pdev)\r\n{\r\nstruct hva_dev *hva;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nhva = devm_kzalloc(dev, sizeof(*hva), GFP_KERNEL);\r\nif (!hva) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nhva->dev = dev;\r\nhva->pdev = pdev;\r\nplatform_set_drvdata(pdev, hva);\r\nmutex_init(&hva->lock);\r\nret = hva_hw_probe(pdev, hva);\r\nif (ret)\r\ngoto err;\r\nregister_encoders(hva);\r\nregister_formats(hva);\r\nret = v4l2_device_register(dev, &hva->v4l2_dev);\r\nif (ret) {\r\ndev_err(dev, "%s %s failed to register V4L2 device\n",\r\nHVA_PREFIX, HVA_NAME);\r\ngoto err_hw;\r\n}\r\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\r\nhva_debugfs_create(hva);\r\n#endif\r\nhva->work_queue = create_workqueue(HVA_NAME);\r\nif (!hva->work_queue) {\r\ndev_err(dev, "%s %s failed to allocate work queue\n",\r\nHVA_PREFIX, HVA_NAME);\r\nret = -ENOMEM;\r\ngoto err_v4l2;\r\n}\r\nret = hva_register_device(hva);\r\nif (ret)\r\ngoto err_work_queue;\r\ndev_info(dev, "%s %s registered as /dev/video%d\n", HVA_PREFIX,\r\nHVA_NAME, hva->vdev->num);\r\nreturn 0;\r\nerr_work_queue:\r\ndestroy_workqueue(hva->work_queue);\r\nerr_v4l2:\r\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\r\nhva_debugfs_remove(hva);\r\n#endif\r\nv4l2_device_unregister(&hva->v4l2_dev);\r\nerr_hw:\r\nhva_hw_remove(hva);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int hva_remove(struct platform_device *pdev)\r\n{\r\nstruct hva_dev *hva = platform_get_drvdata(pdev);\r\nstruct device *dev = hva_to_dev(hva);\r\nhva_unregister_device(hva);\r\ndestroy_workqueue(hva->work_queue);\r\nhva_hw_remove(hva);\r\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\r\nhva_debugfs_remove(hva);\r\n#endif\r\nv4l2_device_unregister(&hva->v4l2_dev);\r\ndev_info(dev, "%s %s removed\n", HVA_PREFIX, pdev->name);\r\nreturn 0;\r\n}
