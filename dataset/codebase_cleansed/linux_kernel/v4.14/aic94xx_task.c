static void asd_can_dequeue(struct asd_ha_struct *asd_ha, int num)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&asd_ha->seq.pend_q_lock, flags);\r\nasd_ha->seq.can_queue += num;\r\nspin_unlock_irqrestore(&asd_ha->seq.pend_q_lock, flags);\r\n}\r\nstatic int asd_map_scatterlist(struct sas_task *task,\r\nstruct sg_el *sg_arr,\r\ngfp_t gfp_flags)\r\n{\r\nstruct asd_ascb *ascb = task->lldd_task;\r\nstruct asd_ha_struct *asd_ha = ascb->ha;\r\nstruct scatterlist *sc;\r\nint num_sg, res;\r\nif (task->data_dir == PCI_DMA_NONE)\r\nreturn 0;\r\nif (task->num_scatter == 0) {\r\nvoid *p = task->scatter;\r\ndma_addr_t dma = pci_map_single(asd_ha->pcidev, p,\r\ntask->total_xfer_len,\r\ntask->data_dir);\r\nsg_arr[0].bus_addr = cpu_to_le64((u64)dma);\r\nsg_arr[0].size = cpu_to_le32(task->total_xfer_len);\r\nsg_arr[0].flags |= ASD_SG_EL_LIST_EOL;\r\nreturn 0;\r\n}\r\nif (sas_protocol_ata(task->task_proto))\r\nnum_sg = task->num_scatter;\r\nelse\r\nnum_sg = pci_map_sg(asd_ha->pcidev, task->scatter,\r\ntask->num_scatter, task->data_dir);\r\nif (num_sg == 0)\r\nreturn -ENOMEM;\r\nif (num_sg > 3) {\r\nint i;\r\nascb->sg_arr = asd_alloc_coherent(asd_ha,\r\nnum_sg*sizeof(struct sg_el),\r\ngfp_flags);\r\nif (!ascb->sg_arr) {\r\nres = -ENOMEM;\r\ngoto err_unmap;\r\n}\r\nfor_each_sg(task->scatter, sc, num_sg, i) {\r\nstruct sg_el *sg =\r\n&((struct sg_el *)ascb->sg_arr->vaddr)[i];\r\nsg->bus_addr = cpu_to_le64((u64)sg_dma_address(sc));\r\nsg->size = cpu_to_le32((u32)sg_dma_len(sc));\r\nif (i == num_sg-1)\r\nsg->flags |= ASD_SG_EL_LIST_EOL;\r\n}\r\nfor_each_sg(task->scatter, sc, 2, i) {\r\nsg_arr[i].bus_addr =\r\ncpu_to_le64((u64)sg_dma_address(sc));\r\nsg_arr[i].size = cpu_to_le32((u32)sg_dma_len(sc));\r\n}\r\nsg_arr[1].next_sg_offs = 2 * sizeof(*sg_arr);\r\nsg_arr[1].flags |= ASD_SG_EL_LIST_EOS;\r\nmemset(&sg_arr[2], 0, sizeof(*sg_arr));\r\nsg_arr[2].bus_addr=cpu_to_le64((u64)ascb->sg_arr->dma_handle);\r\n} else {\r\nint i;\r\nfor_each_sg(task->scatter, sc, num_sg, i) {\r\nsg_arr[i].bus_addr =\r\ncpu_to_le64((u64)sg_dma_address(sc));\r\nsg_arr[i].size = cpu_to_le32((u32)sg_dma_len(sc));\r\n}\r\nsg_arr[i-1].flags |= ASD_SG_EL_LIST_EOL;\r\n}\r\nreturn 0;\r\nerr_unmap:\r\nif (sas_protocol_ata(task->task_proto))\r\npci_unmap_sg(asd_ha->pcidev, task->scatter, task->num_scatter,\r\ntask->data_dir);\r\nreturn res;\r\n}\r\nstatic void asd_unmap_scatterlist(struct asd_ascb *ascb)\r\n{\r\nstruct asd_ha_struct *asd_ha = ascb->ha;\r\nstruct sas_task *task = ascb->uldd_task;\r\nif (task->data_dir == PCI_DMA_NONE)\r\nreturn;\r\nif (task->num_scatter == 0) {\r\ndma_addr_t dma = (dma_addr_t)\r\nle64_to_cpu(ascb->scb->ssp_task.sg_element[0].bus_addr);\r\npci_unmap_single(ascb->ha->pcidev, dma, task->total_xfer_len,\r\ntask->data_dir);\r\nreturn;\r\n}\r\nasd_free_coherent(asd_ha, ascb->sg_arr);\r\nif (task->task_proto != SAS_PROTOCOL_STP)\r\npci_unmap_sg(asd_ha->pcidev, task->scatter, task->num_scatter,\r\ntask->data_dir);\r\n}\r\nstatic void asd_get_response_tasklet(struct asd_ascb *ascb,\r\nstruct done_list_struct *dl)\r\n{\r\nstruct asd_ha_struct *asd_ha = ascb->ha;\r\nstruct sas_task *task = ascb->uldd_task;\r\nstruct task_status_struct *ts = &task->task_status;\r\nunsigned long flags;\r\nstruct tc_resp_sb_struct {\r\n__le16 index_escb;\r\nu8 len_lsb;\r\nu8 flags;\r\n} __attribute__ ((packed)) *resp_sb = (void *) dl->status_block;\r\nint edb_id = ((resp_sb->flags & 0x70) >> 4)-1;\r\nstruct asd_ascb *escb;\r\nstruct asd_dma_tok *edb;\r\nvoid *r;\r\nspin_lock_irqsave(&asd_ha->seq.tc_index_lock, flags);\r\nescb = asd_tc_index_find(&asd_ha->seq,\r\n(int)le16_to_cpu(resp_sb->index_escb));\r\nspin_unlock_irqrestore(&asd_ha->seq.tc_index_lock, flags);\r\nif (!escb) {\r\nASD_DPRINTK("Uh-oh! No escb for this dl?!\n");\r\nreturn;\r\n}\r\nts->buf_valid_size = 0;\r\nedb = asd_ha->seq.edb_arr[edb_id + escb->edb_index];\r\nr = edb->vaddr;\r\nif (task->task_proto == SAS_PROTOCOL_SSP) {\r\nstruct ssp_response_iu *iu =\r\nr + 16 + sizeof(struct ssp_frame_hdr);\r\nts->residual = le32_to_cpu(*(__le32 *)r);\r\nsas_ssp_task_response(&asd_ha->pcidev->dev, task, iu);\r\n} else {\r\nstruct ata_task_resp *resp = (void *) &ts->buf[0];\r\nts->residual = le32_to_cpu(*(__le32 *)r);\r\nif (SAS_STATUS_BUF_SIZE >= sizeof(*resp)) {\r\nresp->frame_len = le16_to_cpu(*(__le16 *)(r+6));\r\nmemcpy(&resp->ending_fis[0], r+16, ATA_RESP_FIS_SIZE);\r\nts->buf_valid_size = sizeof(*resp);\r\n}\r\n}\r\nasd_invalidate_edb(escb, edb_id);\r\n}\r\nstatic void asd_task_tasklet_complete(struct asd_ascb *ascb,\r\nstruct done_list_struct *dl)\r\n{\r\nstruct sas_task *task = ascb->uldd_task;\r\nstruct task_status_struct *ts = &task->task_status;\r\nunsigned long flags;\r\nu8 opcode = dl->opcode;\r\nasd_can_dequeue(ascb->ha, 1);\r\nAgain:\r\nswitch (opcode) {\r\ncase TC_NO_ERROR:\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAM_STAT_GOOD;\r\nbreak;\r\ncase TC_UNDERRUN:\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_UNDERRUN;\r\nts->residual = le32_to_cpu(*(__le32 *)dl->status_block);\r\nbreak;\r\ncase TC_OVERRUN:\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_DATA_OVERRUN;\r\nts->residual = 0;\r\nbreak;\r\ncase TC_SSP_RESP:\r\ncase TC_ATA_RESP:\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_PROTO_RESPONSE;\r\nasd_get_response_tasklet(ascb, dl);\r\nbreak;\r\ncase TF_OPEN_REJECT:\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_OPEN_REJECT;\r\nif (dl->status_block[1] & 2)\r\nts->open_rej_reason = 1 + dl->status_block[2];\r\nelse if (dl->status_block[1] & 1)\r\nts->open_rej_reason = (dl->status_block[2] >> 4)+10;\r\nelse\r\nts->open_rej_reason = SAS_OREJ_UNKNOWN;\r\nbreak;\r\ncase TF_OPEN_TO:\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_OPEN_TO;\r\nbreak;\r\ncase TF_PHY_DOWN:\r\ncase TU_PHY_DOWN:\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_PHY_DOWN;\r\nbreak;\r\ncase TI_PHY_DOWN:\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_PHY_DOWN;\r\nbreak;\r\ncase TI_BREAK:\r\ncase TI_PROTO_ERR:\r\ncase TI_NAK:\r\ncase TI_ACK_NAK_TO:\r\ncase TF_SMP_XMIT_RCV_ERR:\r\ncase TC_ATA_R_ERR_RECV:\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_INTERRUPTED;\r\nbreak;\r\ncase TF_BREAK:\r\ncase TU_BREAK:\r\ncase TU_ACK_NAK_TO:\r\ncase TF_SMPRSP_TO:\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\ncase TF_NAK_RECV:\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_NAK_R_ERR;\r\nbreak;\r\ncase TA_I_T_NEXUS_LOSS:\r\nopcode = dl->status_block[0];\r\ngoto Again;\r\nbreak;\r\ncase TF_INV_CONN_HANDLE:\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_DEVICE_UNKNOWN;\r\nbreak;\r\ncase TF_REQUESTED_N_PENDING:\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_PENDING;\r\nbreak;\r\ncase TC_TASK_CLEARED:\r\ncase TA_ON_REQ:\r\nts->resp = SAS_TASK_COMPLETE;\r\nts->stat = SAS_ABORTED_TASK;\r\nbreak;\r\ncase TF_NO_SMP_CONN:\r\ncase TF_TMF_NO_CTX:\r\ncase TF_TMF_NO_TAG:\r\ncase TF_TMF_TAG_FREE:\r\ncase TF_TMF_TASK_DONE:\r\ncase TF_TMF_NO_CONN_HANDLE:\r\ncase TF_IRTT_TO:\r\ncase TF_IU_SHORT:\r\ncase TF_DATA_OFFS_ERR:\r\nts->resp = SAS_TASK_UNDELIVERED;\r\nts->stat = SAS_DEV_NO_RESPONSE;\r\nbreak;\r\ncase TC_LINK_ADM_RESP:\r\ncase TC_CONTROL_PHY:\r\ncase TC_RESUME:\r\ncase TC_PARTIAL_SG_LIST:\r\ndefault:\r\nASD_DPRINTK("%s: dl opcode: 0x%x?\n", __func__, opcode);\r\nbreak;\r\n}\r\nswitch (task->task_proto) {\r\ncase SAS_PROTOCOL_SATA:\r\ncase SAS_PROTOCOL_STP:\r\nasd_unbuild_ata_ascb(ascb);\r\nbreak;\r\ncase SAS_PROTOCOL_SMP:\r\nasd_unbuild_smp_ascb(ascb);\r\nbreak;\r\ncase SAS_PROTOCOL_SSP:\r\nasd_unbuild_ssp_ascb(ascb);\r\ndefault:\r\nbreak;\r\n}\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\ntask->task_state_flags &= ~SAS_TASK_STATE_PENDING;\r\ntask->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\ntask->task_state_flags |= SAS_TASK_STATE_DONE;\r\nif (unlikely((task->task_state_flags & SAS_TASK_STATE_ABORTED))) {\r\nstruct completion *completion = ascb->completion;\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nASD_DPRINTK("task 0x%p done with opcode 0x%x resp 0x%x "\r\n"stat 0x%x but aborted by upper layer!\n",\r\ntask, opcode, ts->resp, ts->stat);\r\nif (completion)\r\ncomplete(completion);\r\n} else {\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\ntask->lldd_task = NULL;\r\nasd_ascb_free(ascb);\r\nmb();\r\ntask->task_done(task);\r\n}\r\n}\r\nstatic int asd_build_ata_ascb(struct asd_ascb *ascb, struct sas_task *task,\r\ngfp_t gfp_flags)\r\n{\r\nstruct domain_device *dev = task->dev;\r\nstruct scb *scb;\r\nu8 flags;\r\nint res = 0;\r\nscb = ascb->scb;\r\nif (unlikely(task->ata_task.device_control_reg_update))\r\nscb->header.opcode = CONTROL_ATA_DEV;\r\nelse if (dev->sata_dev.class == ATA_DEV_ATAPI)\r\nscb->header.opcode = INITIATE_ATAPI_TASK;\r\nelse\r\nscb->header.opcode = INITIATE_ATA_TASK;\r\nscb->ata_task.proto_conn_rate = (1 << 5);\r\nif (dev->port->oob_mode == SAS_OOB_MODE)\r\nscb->ata_task.proto_conn_rate |= dev->linkrate;\r\nscb->ata_task.total_xfer_len = cpu_to_le32(task->total_xfer_len);\r\nscb->ata_task.fis = task->ata_task.fis;\r\nif (likely(!task->ata_task.device_control_reg_update))\r\nscb->ata_task.fis.flags |= 0x80;\r\nscb->ata_task.fis.flags &= 0xF0;\r\nif (dev->sata_dev.class == ATA_DEV_ATAPI)\r\nmemcpy(scb->ata_task.atapi_packet, task->ata_task.atapi_packet,\r\n16);\r\nscb->ata_task.sister_scb = cpu_to_le16(0xFFFF);\r\nscb->ata_task.conn_handle = cpu_to_le16(\r\n(u16)(unsigned long)dev->lldd_dev);\r\nif (likely(!task->ata_task.device_control_reg_update)) {\r\nflags = 0;\r\nif (task->ata_task.dma_xfer)\r\nflags |= DATA_XFER_MODE_DMA;\r\nif (task->ata_task.use_ncq &&\r\ndev->sata_dev.class != ATA_DEV_ATAPI)\r\nflags |= ATA_Q_TYPE_NCQ;\r\nflags |= data_dir_flags[task->data_dir];\r\nscb->ata_task.ata_flags = flags;\r\nscb->ata_task.retry_count = task->ata_task.retry_count;\r\nflags = 0;\r\nif (task->ata_task.set_affil_pol)\r\nflags |= SET_AFFIL_POLICY;\r\nif (task->ata_task.stp_affil_pol)\r\nflags |= STP_AFFIL_POLICY;\r\nscb->ata_task.flags = flags;\r\n}\r\nascb->tasklet_complete = asd_task_tasklet_complete;\r\nif (likely(!task->ata_task.device_control_reg_update))\r\nres = asd_map_scatterlist(task, scb->ata_task.sg_element,\r\ngfp_flags);\r\nreturn res;\r\n}\r\nstatic void asd_unbuild_ata_ascb(struct asd_ascb *a)\r\n{\r\nasd_unmap_scatterlist(a);\r\n}\r\nstatic int asd_build_smp_ascb(struct asd_ascb *ascb, struct sas_task *task,\r\ngfp_t gfp_flags)\r\n{\r\nstruct asd_ha_struct *asd_ha = ascb->ha;\r\nstruct domain_device *dev = task->dev;\r\nstruct scb *scb;\r\npci_map_sg(asd_ha->pcidev, &task->smp_task.smp_req, 1,\r\nPCI_DMA_TODEVICE);\r\npci_map_sg(asd_ha->pcidev, &task->smp_task.smp_resp, 1,\r\nPCI_DMA_FROMDEVICE);\r\nscb = ascb->scb;\r\nscb->header.opcode = INITIATE_SMP_TASK;\r\nscb->smp_task.proto_conn_rate = dev->linkrate;\r\nscb->smp_task.smp_req.bus_addr =\r\ncpu_to_le64((u64)sg_dma_address(&task->smp_task.smp_req));\r\nscb->smp_task.smp_req.size =\r\ncpu_to_le32((u32)sg_dma_len(&task->smp_task.smp_req)-4);\r\nscb->smp_task.smp_resp.bus_addr =\r\ncpu_to_le64((u64)sg_dma_address(&task->smp_task.smp_resp));\r\nscb->smp_task.smp_resp.size =\r\ncpu_to_le32((u32)sg_dma_len(&task->smp_task.smp_resp)-4);\r\nscb->smp_task.sister_scb = cpu_to_le16(0xFFFF);\r\nscb->smp_task.conn_handle = cpu_to_le16((u16)\r\n(unsigned long)dev->lldd_dev);\r\nascb->tasklet_complete = asd_task_tasklet_complete;\r\nreturn 0;\r\n}\r\nstatic void asd_unbuild_smp_ascb(struct asd_ascb *a)\r\n{\r\nstruct sas_task *task = a->uldd_task;\r\nBUG_ON(!task);\r\npci_unmap_sg(a->ha->pcidev, &task->smp_task.smp_req, 1,\r\nPCI_DMA_TODEVICE);\r\npci_unmap_sg(a->ha->pcidev, &task->smp_task.smp_resp, 1,\r\nPCI_DMA_FROMDEVICE);\r\n}\r\nstatic int asd_build_ssp_ascb(struct asd_ascb *ascb, struct sas_task *task,\r\ngfp_t gfp_flags)\r\n{\r\nstruct domain_device *dev = task->dev;\r\nstruct scb *scb;\r\nint res = 0;\r\nscb = ascb->scb;\r\nscb->header.opcode = INITIATE_SSP_TASK;\r\nscb->ssp_task.proto_conn_rate = (1 << 4);\r\nscb->ssp_task.proto_conn_rate |= dev->linkrate;\r\nscb->ssp_task.total_xfer_len = cpu_to_le32(task->total_xfer_len);\r\nscb->ssp_task.ssp_frame.frame_type = SSP_DATA;\r\nmemcpy(scb->ssp_task.ssp_frame.hashed_dest_addr, dev->hashed_sas_addr,\r\nHASHED_SAS_ADDR_SIZE);\r\nmemcpy(scb->ssp_task.ssp_frame.hashed_src_addr,\r\ndev->port->ha->hashed_sas_addr, HASHED_SAS_ADDR_SIZE);\r\nscb->ssp_task.ssp_frame.tptt = cpu_to_be16(0xFFFF);\r\nmemcpy(scb->ssp_task.ssp_cmd.lun, task->ssp_task.LUN, 8);\r\nif (task->ssp_task.enable_first_burst)\r\nscb->ssp_task.ssp_cmd.efb_prio_attr |= EFB_MASK;\r\nscb->ssp_task.ssp_cmd.efb_prio_attr |= (task->ssp_task.task_prio << 3);\r\nscb->ssp_task.ssp_cmd.efb_prio_attr |= (task->ssp_task.task_attr & 7);\r\nmemcpy(scb->ssp_task.ssp_cmd.cdb, task->ssp_task.cmd->cmnd,\r\ntask->ssp_task.cmd->cmd_len);\r\nscb->ssp_task.sister_scb = cpu_to_le16(0xFFFF);\r\nscb->ssp_task.conn_handle = cpu_to_le16(\r\n(u16)(unsigned long)dev->lldd_dev);\r\nscb->ssp_task.data_dir = data_dir_flags[task->data_dir];\r\nscb->ssp_task.retry_count = scb->ssp_task.retry_count;\r\nascb->tasklet_complete = asd_task_tasklet_complete;\r\nres = asd_map_scatterlist(task, scb->ssp_task.sg_element, gfp_flags);\r\nreturn res;\r\n}\r\nstatic void asd_unbuild_ssp_ascb(struct asd_ascb *a)\r\n{\r\nasd_unmap_scatterlist(a);\r\n}\r\nstatic int asd_can_queue(struct asd_ha_struct *asd_ha, int num)\r\n{\r\nint res = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&asd_ha->seq.pend_q_lock, flags);\r\nif ((asd_ha->seq.can_queue - num) < 0)\r\nres = -SAS_QUEUE_FULL;\r\nelse\r\nasd_ha->seq.can_queue -= num;\r\nspin_unlock_irqrestore(&asd_ha->seq.pend_q_lock, flags);\r\nreturn res;\r\n}\r\nint asd_execute_task(struct sas_task *task, gfp_t gfp_flags)\r\n{\r\nint res = 0;\r\nLIST_HEAD(alist);\r\nstruct sas_task *t = task;\r\nstruct asd_ascb *ascb = NULL, *a;\r\nstruct asd_ha_struct *asd_ha = task->dev->port->ha->lldd_ha;\r\nunsigned long flags;\r\nres = asd_can_queue(asd_ha, 1);\r\nif (res)\r\nreturn res;\r\nres = 1;\r\nascb = asd_ascb_alloc_list(asd_ha, &res, gfp_flags);\r\nif (res) {\r\nres = -ENOMEM;\r\ngoto out_err;\r\n}\r\n__list_add(&alist, ascb->list.prev, &ascb->list);\r\nlist_for_each_entry(a, &alist, list) {\r\na->uldd_task = t;\r\nt->lldd_task = a;\r\nbreak;\r\n}\r\nlist_for_each_entry(a, &alist, list) {\r\nt = a->uldd_task;\r\na->uldd_timer = 1;\r\nif (t->task_proto & SAS_PROTOCOL_STP)\r\nt->task_proto = SAS_PROTOCOL_STP;\r\nswitch (t->task_proto) {\r\ncase SAS_PROTOCOL_SATA:\r\ncase SAS_PROTOCOL_STP:\r\nres = asd_build_ata_ascb(a, t, gfp_flags);\r\nbreak;\r\ncase SAS_PROTOCOL_SMP:\r\nres = asd_build_smp_ascb(a, t, gfp_flags);\r\nbreak;\r\ncase SAS_PROTOCOL_SSP:\r\nres = asd_build_ssp_ascb(a, t, gfp_flags);\r\nbreak;\r\ndefault:\r\nasd_printk("unknown sas_task proto: 0x%x\n",\r\nt->task_proto);\r\nres = -ENOMEM;\r\nbreak;\r\n}\r\nif (res)\r\ngoto out_err_unmap;\r\nspin_lock_irqsave(&t->task_state_lock, flags);\r\nt->task_state_flags |= SAS_TASK_AT_INITIATOR;\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\n}\r\nlist_del_init(&alist);\r\nres = asd_post_ascb_list(asd_ha, ascb, 1);\r\nif (unlikely(res)) {\r\na = NULL;\r\n__list_add(&alist, ascb->list.prev, &ascb->list);\r\ngoto out_err_unmap;\r\n}\r\nreturn 0;\r\nout_err_unmap:\r\n{\r\nstruct asd_ascb *b = a;\r\nlist_for_each_entry(a, &alist, list) {\r\nif (a == b)\r\nbreak;\r\nt = a->uldd_task;\r\nspin_lock_irqsave(&t->task_state_lock, flags);\r\nt->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\nspin_unlock_irqrestore(&t->task_state_lock, flags);\r\nswitch (t->task_proto) {\r\ncase SAS_PROTOCOL_SATA:\r\ncase SAS_PROTOCOL_STP:\r\nasd_unbuild_ata_ascb(a);\r\nbreak;\r\ncase SAS_PROTOCOL_SMP:\r\nasd_unbuild_smp_ascb(a);\r\nbreak;\r\ncase SAS_PROTOCOL_SSP:\r\nasd_unbuild_ssp_ascb(a);\r\ndefault:\r\nbreak;\r\n}\r\nt->lldd_task = NULL;\r\n}\r\n}\r\nlist_del_init(&alist);\r\nout_err:\r\nif (ascb)\r\nasd_ascb_free_list(ascb);\r\nasd_can_dequeue(asd_ha, 1);\r\nreturn res;\r\n}
