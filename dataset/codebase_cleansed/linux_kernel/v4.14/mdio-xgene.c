u32 xgene_mdio_rd_mac(struct xgene_mdio_pdata *pdata, u32 rd_addr)\r\n{\r\nvoid __iomem *addr, *rd, *cmd, *cmd_done;\r\nu32 done, rd_data = BUSY_MASK;\r\nu8 wait = 10;\r\naddr = pdata->mac_csr_addr + MAC_ADDR_REG_OFFSET;\r\nrd = pdata->mac_csr_addr + MAC_READ_REG_OFFSET;\r\ncmd = pdata->mac_csr_addr + MAC_COMMAND_REG_OFFSET;\r\ncmd_done = pdata->mac_csr_addr + MAC_COMMAND_DONE_REG_OFFSET;\r\nspin_lock(&pdata->mac_lock);\r\niowrite32(rd_addr, addr);\r\niowrite32(XGENE_ENET_RD_CMD, cmd);\r\nwhile (!(done = ioread32(cmd_done)) && wait--)\r\nudelay(1);\r\nif (done)\r\nrd_data = ioread32(rd);\r\niowrite32(0, cmd);\r\nspin_unlock(&pdata->mac_lock);\r\nreturn rd_data;\r\n}\r\nvoid xgene_mdio_wr_mac(struct xgene_mdio_pdata *pdata, u32 wr_addr, u32 data)\r\n{\r\nvoid __iomem *addr, *wr, *cmd, *cmd_done;\r\nu8 wait = 10;\r\nu32 done;\r\naddr = pdata->mac_csr_addr + MAC_ADDR_REG_OFFSET;\r\nwr = pdata->mac_csr_addr + MAC_WRITE_REG_OFFSET;\r\ncmd = pdata->mac_csr_addr + MAC_COMMAND_REG_OFFSET;\r\ncmd_done = pdata->mac_csr_addr + MAC_COMMAND_DONE_REG_OFFSET;\r\nspin_lock(&pdata->mac_lock);\r\niowrite32(wr_addr, addr);\r\niowrite32(data, wr);\r\niowrite32(XGENE_ENET_WR_CMD, cmd);\r\nwhile (!(done = ioread32(cmd_done)) && wait--)\r\nudelay(1);\r\nif (!done)\r\npr_err("MCX mac write failed, addr: 0x%04x\n", wr_addr);\r\niowrite32(0, cmd);\r\nspin_unlock(&pdata->mac_lock);\r\n}\r\nint xgene_mdio_rgmii_read(struct mii_bus *bus, int phy_id, int reg)\r\n{\r\nstruct xgene_mdio_pdata *pdata = (struct xgene_mdio_pdata *)bus->priv;\r\nu32 data, done;\r\nu8 wait = 10;\r\ndata = SET_VAL(PHY_ADDR, phy_id) | SET_VAL(REG_ADDR, reg);\r\nxgene_mdio_wr_mac(pdata, MII_MGMT_ADDRESS_ADDR, data);\r\nxgene_mdio_wr_mac(pdata, MII_MGMT_COMMAND_ADDR, READ_CYCLE_MASK);\r\ndo {\r\nusleep_range(5, 10);\r\ndone = xgene_mdio_rd_mac(pdata, MII_MGMT_INDICATORS_ADDR);\r\n} while ((done & BUSY_MASK) && wait--);\r\nif (done & BUSY_MASK) {\r\ndev_err(&bus->dev, "MII_MGMT read failed\n");\r\nreturn -EBUSY;\r\n}\r\ndata = xgene_mdio_rd_mac(pdata, MII_MGMT_STATUS_ADDR);\r\nxgene_mdio_wr_mac(pdata, MII_MGMT_COMMAND_ADDR, 0);\r\nreturn data;\r\n}\r\nint xgene_mdio_rgmii_write(struct mii_bus *bus, int phy_id, int reg, u16 data)\r\n{\r\nstruct xgene_mdio_pdata *pdata = (struct xgene_mdio_pdata *)bus->priv;\r\nu32 val, done;\r\nu8 wait = 10;\r\nval = SET_VAL(PHY_ADDR, phy_id) | SET_VAL(REG_ADDR, reg);\r\nxgene_mdio_wr_mac(pdata, MII_MGMT_ADDRESS_ADDR, val);\r\nxgene_mdio_wr_mac(pdata, MII_MGMT_CONTROL_ADDR, data);\r\ndo {\r\nusleep_range(5, 10);\r\ndone = xgene_mdio_rd_mac(pdata, MII_MGMT_INDICATORS_ADDR);\r\n} while ((done & BUSY_MASK) && wait--);\r\nif (done & BUSY_MASK) {\r\ndev_err(&bus->dev, "MII_MGMT write failed\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 xgene_menet_rd_diag_csr(struct xgene_mdio_pdata *pdata, u32 offset)\r\n{\r\nreturn ioread32(pdata->diag_csr_addr + offset);\r\n}\r\nstatic void xgene_menet_wr_diag_csr(struct xgene_mdio_pdata *pdata,\r\nu32 offset, u32 val)\r\n{\r\niowrite32(val, pdata->diag_csr_addr + offset);\r\n}\r\nstatic int xgene_enet_ecc_init(struct xgene_mdio_pdata *pdata)\r\n{\r\nu32 data;\r\nu8 wait = 10;\r\nxgene_menet_wr_diag_csr(pdata, MENET_CFG_MEM_RAM_SHUTDOWN_ADDR, 0x0);\r\ndo {\r\nusleep_range(100, 110);\r\ndata = xgene_menet_rd_diag_csr(pdata, MENET_BLOCK_MEM_RDY_ADDR);\r\n} while ((data != 0xffffffff) && wait--);\r\nif (data != 0xffffffff) {\r\ndev_err(pdata->dev, "Failed to release memory from shutdown\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xgene_gmac_reset(struct xgene_mdio_pdata *pdata)\r\n{\r\nxgene_mdio_wr_mac(pdata, MAC_CONFIG_1_ADDR, SOFT_RESET);\r\nxgene_mdio_wr_mac(pdata, MAC_CONFIG_1_ADDR, 0);\r\n}\r\nstatic int xgene_mdio_reset(struct xgene_mdio_pdata *pdata)\r\n{\r\nint ret;\r\nif (pdata->dev->of_node) {\r\nclk_prepare_enable(pdata->clk);\r\nudelay(5);\r\nclk_disable_unprepare(pdata->clk);\r\nudelay(5);\r\nclk_prepare_enable(pdata->clk);\r\nudelay(5);\r\n} else {\r\n#ifdef CONFIG_ACPI\r\nacpi_evaluate_object(ACPI_HANDLE(pdata->dev),\r\n"_RST", NULL, NULL);\r\n#endif\r\n}\r\nret = xgene_enet_ecc_init(pdata);\r\nif (ret)\r\nreturn ret;\r\nxgene_gmac_reset(pdata);\r\nreturn 0;\r\n}\r\nstatic void xgene_enet_rd_mdio_csr(void __iomem *base_addr,\r\nu32 offset, u32 *val)\r\n{\r\nvoid __iomem *addr = base_addr + offset;\r\n*val = ioread32(addr);\r\n}\r\nstatic void xgene_enet_wr_mdio_csr(void __iomem *base_addr,\r\nu32 offset, u32 val)\r\n{\r\nvoid __iomem *addr = base_addr + offset;\r\niowrite32(val, addr);\r\n}\r\nstatic int xgene_xfi_mdio_write(struct mii_bus *bus, int phy_id,\r\nint reg, u16 data)\r\n{\r\nvoid __iomem *addr = (void __iomem *)bus->priv;\r\nint timeout = 100;\r\nu32 status, val;\r\nval = SET_VAL(HSTPHYADX, phy_id) | SET_VAL(HSTREGADX, reg) |\r\nSET_VAL(HSTMIIMWRDAT, data);\r\nxgene_enet_wr_mdio_csr(addr, MIIM_FIELD_ADDR, val);\r\nval = HSTLDCMD | SET_VAL(HSTMIIMCMD, MIIM_CMD_LEGACY_WRITE);\r\nxgene_enet_wr_mdio_csr(addr, MIIM_COMMAND_ADDR, val);\r\ndo {\r\nusleep_range(5, 10);\r\nxgene_enet_rd_mdio_csr(addr, MIIM_INDICATOR_ADDR, &status);\r\n} while ((status & BUSY_MASK) && timeout--);\r\nxgene_enet_wr_mdio_csr(addr, MIIM_COMMAND_ADDR, 0);\r\nreturn 0;\r\n}\r\nstatic int xgene_xfi_mdio_read(struct mii_bus *bus, int phy_id, int reg)\r\n{\r\nvoid __iomem *addr = (void __iomem *)bus->priv;\r\nu32 data, status, val;\r\nint timeout = 100;\r\nval = SET_VAL(HSTPHYADX, phy_id) | SET_VAL(HSTREGADX, reg);\r\nxgene_enet_wr_mdio_csr(addr, MIIM_FIELD_ADDR, val);\r\nval = HSTLDCMD | SET_VAL(HSTMIIMCMD, MIIM_CMD_LEGACY_READ);\r\nxgene_enet_wr_mdio_csr(addr, MIIM_COMMAND_ADDR, val);\r\ndo {\r\nusleep_range(5, 10);\r\nxgene_enet_rd_mdio_csr(addr, MIIM_INDICATOR_ADDR, &status);\r\n} while ((status & BUSY_MASK) && timeout--);\r\nif (status & BUSY_MASK) {\r\npr_err("XGENET_MII_MGMT write failed\n");\r\nreturn -EBUSY;\r\n}\r\nxgene_enet_rd_mdio_csr(addr, MIIMRD_FIELD_ADDR, &data);\r\nxgene_enet_wr_mdio_csr(addr, MIIM_COMMAND_ADDR, 0);\r\nreturn data;\r\n}\r\nstruct phy_device *xgene_enet_phy_register(struct mii_bus *bus, int phy_addr)\r\n{\r\nstruct phy_device *phy_dev;\r\nphy_dev = get_phy_device(bus, phy_addr, false);\r\nif (!phy_dev || IS_ERR(phy_dev))\r\nreturn NULL;\r\nif (phy_device_register(phy_dev))\r\nphy_device_free(phy_dev);\r\nreturn phy_dev;\r\n}\r\nstatic acpi_status acpi_register_phy(acpi_handle handle, u32 lvl,\r\nvoid *context, void **ret)\r\n{\r\nstruct mii_bus *mdio = context;\r\nstruct acpi_device *adev;\r\nstruct phy_device *phy_dev;\r\nconst union acpi_object *obj;\r\nu32 phy_addr;\r\nif (acpi_bus_get_device(handle, &adev))\r\nreturn AE_OK;\r\nif (acpi_dev_get_property(adev, "phy-channel", ACPI_TYPE_INTEGER, &obj))\r\nreturn AE_OK;\r\nphy_addr = obj->integer.value;\r\nphy_dev = xgene_enet_phy_register(mdio, phy_addr);\r\nadev->driver_data = phy_dev;\r\nreturn AE_OK;\r\n}\r\nstatic int xgene_mdio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mii_bus *mdio_bus;\r\nconst struct of_device_id *of_id;\r\nstruct resource *res;\r\nstruct xgene_mdio_pdata *pdata;\r\nvoid __iomem *csr_base;\r\nint mdio_id = 0, ret = 0;\r\nof_id = of_match_device(xgene_mdio_of_match, &pdev->dev);\r\nif (of_id) {\r\nmdio_id = (enum xgene_mdio_id)of_id->data;\r\n} else {\r\n#ifdef CONFIG_ACPI\r\nconst struct acpi_device_id *acpi_id;\r\nacpi_id = acpi_match_device(xgene_mdio_acpi_match, &pdev->dev);\r\nif (acpi_id)\r\nmdio_id = (enum xgene_mdio_id)acpi_id->driver_data;\r\n#endif\r\n}\r\nif (!mdio_id)\r\nreturn -ENODEV;\r\npdata = devm_kzalloc(dev, sizeof(struct xgene_mdio_pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\npdata->mdio_id = mdio_id;\r\npdata->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ncsr_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(csr_base))\r\nreturn PTR_ERR(csr_base);\r\npdata->mac_csr_addr = csr_base;\r\npdata->mdio_csr_addr = csr_base + BLOCK_XG_MDIO_CSR_OFFSET;\r\npdata->diag_csr_addr = csr_base + BLOCK_DIAG_CSR_OFFSET;\r\nif (mdio_id == XGENE_MDIO_RGMII)\r\nspin_lock_init(&pdata->mac_lock);\r\nif (dev->of_node) {\r\npdata->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(pdata->clk)) {\r\ndev_err(dev, "Unable to retrieve clk\n");\r\nreturn PTR_ERR(pdata->clk);\r\n}\r\n}\r\nret = xgene_mdio_reset(pdata);\r\nif (ret)\r\nreturn ret;\r\nmdio_bus = mdiobus_alloc();\r\nif (!mdio_bus)\r\nreturn -ENOMEM;\r\nmdio_bus->name = "APM X-Gene MDIO bus";\r\nif (mdio_id == XGENE_MDIO_RGMII) {\r\nmdio_bus->read = xgene_mdio_rgmii_read;\r\nmdio_bus->write = xgene_mdio_rgmii_write;\r\nmdio_bus->priv = (void __force *)pdata;\r\nsnprintf(mdio_bus->id, MII_BUS_ID_SIZE, "%s",\r\n"xgene-mii-rgmii");\r\n} else {\r\nmdio_bus->read = xgene_xfi_mdio_read;\r\nmdio_bus->write = xgene_xfi_mdio_write;\r\nmdio_bus->priv = (void __force *)pdata->mdio_csr_addr;\r\nsnprintf(mdio_bus->id, MII_BUS_ID_SIZE, "%s",\r\n"xgene-mii-xfi");\r\n}\r\nmdio_bus->parent = dev;\r\nplatform_set_drvdata(pdev, pdata);\r\nif (dev->of_node) {\r\nret = of_mdiobus_register(mdio_bus, dev->of_node);\r\n} else {\r\n#ifdef CONFIG_ACPI\r\nmdio_bus->phy_mask = ~0;\r\nret = mdiobus_register(mdio_bus);\r\nif (ret)\r\ngoto out;\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_HANDLE(dev), 1,\r\nacpi_register_phy, NULL, mdio_bus, NULL);\r\n#endif\r\n}\r\nif (ret)\r\ngoto out;\r\npdata->mdio_bus = mdio_bus;\r\nxgene_mdio_status = true;\r\nreturn 0;\r\nout:\r\nmdiobus_free(mdio_bus);\r\nreturn ret;\r\n}\r\nstatic int xgene_mdio_remove(struct platform_device *pdev)\r\n{\r\nstruct xgene_mdio_pdata *pdata = platform_get_drvdata(pdev);\r\nstruct mii_bus *mdio_bus = pdata->mdio_bus;\r\nstruct device *dev = &pdev->dev;\r\nmdiobus_unregister(mdio_bus);\r\nmdiobus_free(mdio_bus);\r\nif (dev->of_node)\r\nclk_disable_unprepare(pdata->clk);\r\nreturn 0;\r\n}
