static struct ima_queue_entry *ima_lookup_digest_entry(u8 *digest_value,\r\nint pcr)\r\n{\r\nstruct ima_queue_entry *qe, *ret = NULL;\r\nunsigned int key;\r\nint rc;\r\nkey = ima_hash_key(digest_value);\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(qe, &ima_htable.queue[key], hnext) {\r\nrc = memcmp(qe->entry->digest, digest_value, TPM_DIGEST_SIZE);\r\nif ((rc == 0) && (qe->entry->pcr == pcr)) {\r\nret = qe;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic int get_binary_runtime_size(struct ima_template_entry *entry)\r\n{\r\nint size = 0;\r\nsize += sizeof(u32);\r\nsize += sizeof(entry->digest);\r\nsize += sizeof(int);\r\nsize += strlen(entry->template_desc->name);\r\nsize += sizeof(entry->template_data_len);\r\nsize += entry->template_data_len;\r\nreturn size;\r\n}\r\nstatic int ima_add_digest_entry(struct ima_template_entry *entry,\r\nbool update_htable)\r\n{\r\nstruct ima_queue_entry *qe;\r\nunsigned int key;\r\nqe = kmalloc(sizeof(*qe), GFP_KERNEL);\r\nif (qe == NULL) {\r\npr_err("OUT OF MEMORY ERROR creating queue entry\n");\r\nreturn -ENOMEM;\r\n}\r\nqe->entry = entry;\r\nINIT_LIST_HEAD(&qe->later);\r\nlist_add_tail_rcu(&qe->later, &ima_measurements);\r\natomic_long_inc(&ima_htable.len);\r\nif (update_htable) {\r\nkey = ima_hash_key(entry->digest);\r\nhlist_add_head_rcu(&qe->hnext, &ima_htable.queue[key]);\r\n}\r\nif (binary_runtime_size != ULONG_MAX) {\r\nint size;\r\nsize = get_binary_runtime_size(entry);\r\nbinary_runtime_size = (binary_runtime_size < ULONG_MAX - size) ?\r\nbinary_runtime_size + size : ULONG_MAX;\r\n}\r\nreturn 0;\r\n}\r\nunsigned long ima_get_binary_runtime_size(void)\r\n{\r\nif (binary_runtime_size >= (ULONG_MAX - sizeof(struct ima_kexec_hdr)))\r\nreturn ULONG_MAX;\r\nelse\r\nreturn binary_runtime_size + sizeof(struct ima_kexec_hdr);\r\n}\r\nstatic int ima_pcr_extend(const u8 *hash, int pcr)\r\n{\r\nint result = 0;\r\nif (!ima_used_chip)\r\nreturn result;\r\nresult = tpm_pcr_extend(TPM_ANY_NUM, pcr, hash);\r\nif (result != 0)\r\npr_err("Error Communicating to TPM chip, result: %d\n", result);\r\nreturn result;\r\n}\r\nint ima_add_template_entry(struct ima_template_entry *entry, int violation,\r\nconst char *op, struct inode *inode,\r\nconst unsigned char *filename)\r\n{\r\nu8 digest[TPM_DIGEST_SIZE];\r\nconst char *audit_cause = "hash_added";\r\nchar tpm_audit_cause[AUDIT_CAUSE_LEN_MAX];\r\nint audit_info = 1;\r\nint result = 0, tpmresult = 0;\r\nmutex_lock(&ima_extend_list_mutex);\r\nif (!violation) {\r\nmemcpy(digest, entry->digest, sizeof(digest));\r\nif (ima_lookup_digest_entry(digest, entry->pcr)) {\r\naudit_cause = "hash_exists";\r\nresult = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nresult = ima_add_digest_entry(entry, 1);\r\nif (result < 0) {\r\naudit_cause = "ENOMEM";\r\naudit_info = 0;\r\ngoto out;\r\n}\r\nif (violation)\r\nmemset(digest, 0xff, sizeof(digest));\r\ntpmresult = ima_pcr_extend(digest, entry->pcr);\r\nif (tpmresult != 0) {\r\nsnprintf(tpm_audit_cause, AUDIT_CAUSE_LEN_MAX, "TPM_error(%d)",\r\ntpmresult);\r\naudit_cause = tpm_audit_cause;\r\naudit_info = 0;\r\n}\r\nout:\r\nmutex_unlock(&ima_extend_list_mutex);\r\nintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\r\nop, audit_cause, result, audit_info);\r\nreturn result;\r\n}\r\nint ima_restore_measurement_entry(struct ima_template_entry *entry)\r\n{\r\nint result = 0;\r\nmutex_lock(&ima_extend_list_mutex);\r\nresult = ima_add_digest_entry(entry, 0);\r\nmutex_unlock(&ima_extend_list_mutex);\r\nreturn result;\r\n}
