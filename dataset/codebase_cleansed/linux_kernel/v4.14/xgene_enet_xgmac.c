static void xgene_enet_wr_csr(struct xgene_enet_pdata *pdata,\r\nu32 offset, u32 val)\r\n{\r\nvoid __iomem *addr = pdata->eth_csr_addr + offset;\r\niowrite32(val, addr);\r\n}\r\nstatic void xgene_enet_wr_ring_if(struct xgene_enet_pdata *pdata,\r\nu32 offset, u32 val)\r\n{\r\nvoid __iomem *addr = pdata->eth_ring_if_addr + offset;\r\niowrite32(val, addr);\r\n}\r\nstatic void xgene_enet_wr_diag_csr(struct xgene_enet_pdata *pdata,\r\nu32 offset, u32 val)\r\n{\r\nvoid __iomem *addr = pdata->eth_diag_csr_addr + offset;\r\niowrite32(val, addr);\r\n}\r\nstatic bool xgene_enet_wr_indirect(void __iomem *addr, void __iomem *wr,\r\nvoid __iomem *cmd, void __iomem *cmd_done,\r\nu32 wr_addr, u32 wr_data)\r\n{\r\nu32 done;\r\nu8 wait = 10;\r\niowrite32(wr_addr, addr);\r\niowrite32(wr_data, wr);\r\niowrite32(XGENE_ENET_WR_CMD, cmd);\r\nwhile (!(done = ioread32(cmd_done)) && wait--)\r\nudelay(1);\r\nif (!done)\r\nreturn false;\r\niowrite32(0, cmd);\r\nreturn true;\r\n}\r\nstatic void xgene_enet_wr_pcs(struct xgene_enet_pdata *pdata,\r\nu32 wr_addr, u32 wr_data)\r\n{\r\nvoid __iomem *addr, *wr, *cmd, *cmd_done;\r\naddr = pdata->pcs_addr + PCS_ADDR_REG_OFFSET;\r\nwr = pdata->pcs_addr + PCS_WRITE_REG_OFFSET;\r\ncmd = pdata->pcs_addr + PCS_COMMAND_REG_OFFSET;\r\ncmd_done = pdata->pcs_addr + PCS_COMMAND_DONE_REG_OFFSET;\r\nif (!xgene_enet_wr_indirect(addr, wr, cmd, cmd_done, wr_addr, wr_data))\r\nnetdev_err(pdata->ndev, "PCS write failed, addr: %04x\n",\r\nwr_addr);\r\n}\r\nstatic void xgene_enet_wr_axg_csr(struct xgene_enet_pdata *pdata,\r\nu32 offset, u32 val)\r\n{\r\nvoid __iomem *addr = pdata->mcx_mac_csr_addr + offset;\r\niowrite32(val, addr);\r\n}\r\nstatic void xgene_enet_rd_csr(struct xgene_enet_pdata *pdata,\r\nu32 offset, u32 *val)\r\n{\r\nvoid __iomem *addr = pdata->eth_csr_addr + offset;\r\n*val = ioread32(addr);\r\n}\r\nstatic void xgene_enet_rd_diag_csr(struct xgene_enet_pdata *pdata,\r\nu32 offset, u32 *val)\r\n{\r\nvoid __iomem *addr = pdata->eth_diag_csr_addr + offset;\r\n*val = ioread32(addr);\r\n}\r\nstatic bool xgene_enet_rd_indirect(void __iomem *addr, void __iomem *rd,\r\nvoid __iomem *cmd, void __iomem *cmd_done,\r\nu32 rd_addr, u32 *rd_data)\r\n{\r\nu32 done;\r\nu8 wait = 10;\r\niowrite32(rd_addr, addr);\r\niowrite32(XGENE_ENET_RD_CMD, cmd);\r\nwhile (!(done = ioread32(cmd_done)) && wait--)\r\nudelay(1);\r\nif (!done)\r\nreturn false;\r\n*rd_data = ioread32(rd);\r\niowrite32(0, cmd);\r\nreturn true;\r\n}\r\nstatic bool xgene_enet_rd_pcs(struct xgene_enet_pdata *pdata,\r\nu32 rd_addr, u32 *rd_data)\r\n{\r\nvoid __iomem *addr, *rd, *cmd, *cmd_done;\r\nbool success;\r\naddr = pdata->pcs_addr + PCS_ADDR_REG_OFFSET;\r\nrd = pdata->pcs_addr + PCS_READ_REG_OFFSET;\r\ncmd = pdata->pcs_addr + PCS_COMMAND_REG_OFFSET;\r\ncmd_done = pdata->pcs_addr + PCS_COMMAND_DONE_REG_OFFSET;\r\nsuccess = xgene_enet_rd_indirect(addr, rd, cmd, cmd_done, rd_addr, rd_data);\r\nif (!success)\r\nnetdev_err(pdata->ndev, "PCS read failed, addr: %04x\n",\r\nrd_addr);\r\nreturn success;\r\n}\r\nstatic void xgene_enet_rd_axg_csr(struct xgene_enet_pdata *pdata,\r\nu32 offset, u32 *val)\r\n{\r\nvoid __iomem *addr = pdata->mcx_mac_csr_addr + offset;\r\n*val = ioread32(addr);\r\n}\r\nstatic int xgene_enet_ecc_init(struct xgene_enet_pdata *pdata)\r\n{\r\nstruct net_device *ndev = pdata->ndev;\r\nu32 data;\r\nu8 wait = 10;\r\nxgene_enet_wr_diag_csr(pdata, ENET_CFG_MEM_RAM_SHUTDOWN_ADDR, 0x0);\r\ndo {\r\nusleep_range(100, 110);\r\nxgene_enet_rd_diag_csr(pdata, ENET_BLOCK_MEM_RDY_ADDR, &data);\r\n} while ((data != 0xffffffff) && wait--);\r\nif (data != 0xffffffff) {\r\nnetdev_err(ndev, "Failed to release memory from shutdown\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xgene_xgmac_get_drop_cnt(struct xgene_enet_pdata *pdata,\r\nu32 *rx, u32 *tx)\r\n{\r\nu32 count;\r\nxgene_enet_rd_axg_csr(pdata, XGENET_ICM_ECM_DROP_COUNT_REG0, &count);\r\n*rx = ICM_DROP_COUNT(count);\r\n*tx = ECM_DROP_COUNT(count);\r\nxgene_enet_rd_axg_csr(pdata, XGENET_ECM_CONFIG0_REG_0, &count);\r\n}\r\nstatic void xgene_enet_config_ring_if_assoc(struct xgene_enet_pdata *pdata)\r\n{\r\nxgene_enet_wr_ring_if(pdata, ENET_CFGSSQMIWQASSOC_ADDR, 0);\r\nxgene_enet_wr_ring_if(pdata, ENET_CFGSSQMIFPQASSOC_ADDR, 0);\r\nxgene_enet_wr_ring_if(pdata, ENET_CFGSSQMIQMLITEWQASSOC_ADDR, 0);\r\nxgene_enet_wr_ring_if(pdata, ENET_CFGSSQMIQMLITEFPQASSOC_ADDR, 0);\r\n}\r\nstatic void xgene_xgmac_reset(struct xgene_enet_pdata *pdata)\r\n{\r\nxgene_enet_wr_mac(pdata, AXGMAC_CONFIG_0, HSTMACRST);\r\nxgene_enet_wr_mac(pdata, AXGMAC_CONFIG_0, 0);\r\n}\r\nstatic void xgene_pcs_reset(struct xgene_enet_pdata *pdata)\r\n{\r\nu32 data;\r\nif (!xgene_enet_rd_pcs(pdata, PCS_CONTROL_1, &data))\r\nreturn;\r\nxgene_enet_wr_pcs(pdata, PCS_CONTROL_1, data | PCS_CTRL_PCS_RST);\r\nxgene_enet_wr_pcs(pdata, PCS_CONTROL_1, data & ~PCS_CTRL_PCS_RST);\r\n}\r\nstatic void xgene_xgmac_set_mac_addr(struct xgene_enet_pdata *pdata)\r\n{\r\nu32 addr0, addr1;\r\nu8 *dev_addr = pdata->ndev->dev_addr;\r\naddr0 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |\r\n(dev_addr[1] << 8) | dev_addr[0];\r\naddr1 = (dev_addr[5] << 24) | (dev_addr[4] << 16);\r\nxgene_enet_wr_mac(pdata, HSTMACADR_LSW_ADDR, addr0);\r\nxgene_enet_wr_mac(pdata, HSTMACADR_MSW_ADDR, addr1);\r\n}\r\nstatic void xgene_xgmac_set_mss(struct xgene_enet_pdata *pdata,\r\nu16 mss, u8 index)\r\n{\r\nu8 offset;\r\nu32 data;\r\noffset = (index < 2) ? 0 : 4;\r\nxgene_enet_rd_csr(pdata, XG_TSIF_MSS_REG0_ADDR + offset, &data);\r\nif (!(index & 0x1))\r\ndata = SET_VAL(TSO_MSS1, data >> TSO_MSS1_POS) |\r\nSET_VAL(TSO_MSS0, mss);\r\nelse\r\ndata = SET_VAL(TSO_MSS1, mss) | SET_VAL(TSO_MSS0, data);\r\nxgene_enet_wr_csr(pdata, XG_TSIF_MSS_REG0_ADDR + offset, data);\r\n}\r\nstatic void xgene_xgmac_set_frame_size(struct xgene_enet_pdata *pdata, int size)\r\n{\r\nxgene_enet_wr_mac(pdata, HSTMAXFRAME_LENGTH_ADDR,\r\n((((size + 2) >> 2) << 16) | size));\r\n}\r\nstatic u32 xgene_enet_link_status(struct xgene_enet_pdata *pdata)\r\n{\r\nu32 data;\r\nxgene_enet_rd_csr(pdata, XG_LINK_STATUS_ADDR, &data);\r\nreturn data;\r\n}\r\nstatic void xgene_xgmac_enable_tx_pause(struct xgene_enet_pdata *pdata,\r\nbool enable)\r\n{\r\nu32 data;\r\nxgene_enet_rd_axg_csr(pdata, XGENET_CSR_ECM_CFG_0_ADDR, &data);\r\nif (enable)\r\ndata |= MULTI_DPF_AUTOCTRL | PAUSE_XON_EN;\r\nelse\r\ndata &= ~(MULTI_DPF_AUTOCTRL | PAUSE_XON_EN);\r\nxgene_enet_wr_axg_csr(pdata, XGENET_CSR_ECM_CFG_0_ADDR, data);\r\n}\r\nstatic void xgene_xgmac_flowctl_tx(struct xgene_enet_pdata *pdata, bool enable)\r\n{\r\nu32 data;\r\ndata = xgene_enet_rd_mac(pdata, AXGMAC_CONFIG_1);\r\nif (enable)\r\ndata |= HSTTCTLEN;\r\nelse\r\ndata &= ~HSTTCTLEN;\r\nxgene_enet_wr_mac(pdata, AXGMAC_CONFIG_1, data);\r\npdata->mac_ops->enable_tx_pause(pdata, enable);\r\n}\r\nstatic void xgene_xgmac_flowctl_rx(struct xgene_enet_pdata *pdata, bool enable)\r\n{\r\nu32 data;\r\ndata = xgene_enet_rd_mac(pdata, AXGMAC_CONFIG_1);\r\nif (enable)\r\ndata |= HSTRCTLEN;\r\nelse\r\ndata &= ~HSTRCTLEN;\r\nxgene_enet_wr_mac(pdata, AXGMAC_CONFIG_1, data);\r\n}\r\nstatic void xgene_xgmac_init(struct xgene_enet_pdata *pdata)\r\n{\r\nu32 data;\r\nxgene_xgmac_reset(pdata);\r\ndata = xgene_enet_rd_mac(pdata, AXGMAC_CONFIG_1);\r\ndata |= HSTPPEN;\r\ndata &= ~HSTLENCHK;\r\nxgene_enet_wr_mac(pdata, AXGMAC_CONFIG_1, data);\r\nxgene_xgmac_set_mac_addr(pdata);\r\nxgene_enet_rd_csr(pdata, XG_RSIF_CONFIG_REG_ADDR, &data);\r\ndata |= CFG_RSIF_FPBUFF_TIMEOUT_EN;\r\nRSIF_CLE_BUFF_THRESH_SET(&data, XG_RSIF_CLE_BUFF_THRESH);\r\nxgene_enet_wr_csr(pdata, XG_RSIF_CONFIG_REG_ADDR, data);\r\nxgene_enet_rd_csr(pdata, XG_RSIF_CONFIG1_REG_ADDR, &data);\r\nRSIF_PLC_CLE_BUFF_THRESH_SET(&data, XG_RSIF_PLC_CLE_BUFF_THRESH);\r\nxgene_enet_wr_csr(pdata, XG_RSIF_CONFIG1_REG_ADDR, data);\r\nxgene_enet_rd_csr(pdata, XG_ENET_SPARE_CFG_REG_ADDR, &data);\r\ndata |= BIT(12);\r\nxgene_enet_wr_csr(pdata, XG_ENET_SPARE_CFG_REG_ADDR, data);\r\nxgene_enet_wr_csr(pdata, XG_ENET_SPARE_CFG_REG_1_ADDR, 0x82);\r\nxgene_enet_wr_csr(pdata, XGENET_RX_DV_GATE_REG_0_ADDR, 0);\r\nxgene_enet_wr_csr(pdata, XG_CFG_BYPASS_ADDR, RESUME_TX);\r\nxgene_enet_rd_axg_csr(pdata, XGENET_CSR_MULTI_DPF0_ADDR, &data);\r\ndata = (DEF_QUANTA << 16) | (data & 0xFFFF);\r\nxgene_enet_wr_axg_csr(pdata, XGENET_CSR_MULTI_DPF0_ADDR, data);\r\nif (pdata->enet_id != XGENE_ENET1) {\r\nxgene_enet_rd_axg_csr(pdata, XGENET_CSR_MULTI_DPF1_ADDR, &data);\r\ndata = (NORM_PAUSE_OPCODE << 16) | (data & 0xFFFF);\r\nxgene_enet_wr_axg_csr(pdata, XGENET_CSR_MULTI_DPF1_ADDR, data);\r\n}\r\ndata = (XG_DEF_PAUSE_OFF_THRES << 16) | XG_DEF_PAUSE_THRES;\r\nxgene_enet_wr_csr(pdata, XG_RXBUF_PAUSE_THRESH, data);\r\nxgene_xgmac_flowctl_tx(pdata, pdata->tx_pause);\r\nxgene_xgmac_flowctl_rx(pdata, pdata->rx_pause);\r\n}\r\nstatic void xgene_xgmac_rx_enable(struct xgene_enet_pdata *pdata)\r\n{\r\nu32 data;\r\ndata = xgene_enet_rd_mac(pdata, AXGMAC_CONFIG_1);\r\nxgene_enet_wr_mac(pdata, AXGMAC_CONFIG_1, data | HSTRFEN);\r\n}\r\nstatic void xgene_xgmac_tx_enable(struct xgene_enet_pdata *pdata)\r\n{\r\nu32 data;\r\ndata = xgene_enet_rd_mac(pdata, AXGMAC_CONFIG_1);\r\nxgene_enet_wr_mac(pdata, AXGMAC_CONFIG_1, data | HSTTFEN);\r\n}\r\nstatic void xgene_xgmac_rx_disable(struct xgene_enet_pdata *pdata)\r\n{\r\nu32 data;\r\ndata = xgene_enet_rd_mac(pdata, AXGMAC_CONFIG_1);\r\nxgene_enet_wr_mac(pdata, AXGMAC_CONFIG_1, data & ~HSTRFEN);\r\n}\r\nstatic void xgene_xgmac_tx_disable(struct xgene_enet_pdata *pdata)\r\n{\r\nu32 data;\r\ndata = xgene_enet_rd_mac(pdata, AXGMAC_CONFIG_1);\r\nxgene_enet_wr_mac(pdata, AXGMAC_CONFIG_1, data & ~HSTTFEN);\r\n}\r\nstatic int xgene_enet_reset(struct xgene_enet_pdata *pdata)\r\n{\r\nstruct device *dev = &pdata->pdev->dev;\r\nif (!xgene_ring_mgr_init(pdata))\r\nreturn -ENODEV;\r\nif (dev->of_node) {\r\nclk_prepare_enable(pdata->clk);\r\nudelay(5);\r\nclk_disable_unprepare(pdata->clk);\r\nudelay(5);\r\nclk_prepare_enable(pdata->clk);\r\nudelay(5);\r\n} else {\r\n#ifdef CONFIG_ACPI\r\nif (acpi_has_method(ACPI_HANDLE(&pdata->pdev->dev), "_RST")) {\r\nacpi_evaluate_object(ACPI_HANDLE(&pdata->pdev->dev),\r\n"_RST", NULL, NULL);\r\n} else if (acpi_has_method(ACPI_HANDLE(&pdata->pdev->dev),\r\n"_INI")) {\r\nacpi_evaluate_object(ACPI_HANDLE(&pdata->pdev->dev),\r\n"_INI", NULL, NULL);\r\n}\r\n#endif\r\n}\r\nxgene_enet_ecc_init(pdata);\r\nxgene_enet_config_ring_if_assoc(pdata);\r\nreturn 0;\r\n}\r\nstatic void xgene_enet_xgcle_bypass(struct xgene_enet_pdata *pdata,\r\nu32 dst_ring_num, u16 bufpool_id,\r\nu16 nxtbufpool_id)\r\n{\r\nu32 cb, fpsel, nxtfpsel;\r\nxgene_enet_rd_csr(pdata, XCLE_BYPASS_REG0_ADDR, &cb);\r\ncb |= CFG_CLE_BYPASS_EN0;\r\nCFG_CLE_IP_PROTOCOL0_SET(&cb, 3);\r\nxgene_enet_wr_csr(pdata, XCLE_BYPASS_REG0_ADDR, cb);\r\nfpsel = xgene_enet_get_fpsel(bufpool_id);\r\nnxtfpsel = xgene_enet_get_fpsel(nxtbufpool_id);\r\nxgene_enet_rd_csr(pdata, XCLE_BYPASS_REG1_ADDR, &cb);\r\nCFG_CLE_DSTQID0_SET(&cb, dst_ring_num);\r\nCFG_CLE_FPSEL0_SET(&cb, fpsel);\r\nCFG_CLE_NXTFPSEL0_SET(&cb, nxtfpsel);\r\nxgene_enet_wr_csr(pdata, XCLE_BYPASS_REG1_ADDR, cb);\r\npr_info("+ cle_bypass: fpsel: %d nxtfpsel: %d\n", fpsel, nxtfpsel);\r\n}\r\nstatic void xgene_enet_shutdown(struct xgene_enet_pdata *pdata)\r\n{\r\nstruct device *dev = &pdata->pdev->dev;\r\nif (dev->of_node) {\r\nif (!IS_ERR(pdata->clk))\r\nclk_disable_unprepare(pdata->clk);\r\n}\r\n}\r\nstatic void xgene_enet_clear(struct xgene_enet_pdata *pdata,\r\nstruct xgene_enet_desc_ring *ring)\r\n{\r\nu32 addr, data;\r\nif (xgene_enet_is_bufpool(ring->id)) {\r\naddr = ENET_CFGSSQMIFPRESET_ADDR;\r\ndata = BIT(xgene_enet_get_fpsel(ring->id));\r\n} else {\r\naddr = ENET_CFGSSQMIWQRESET_ADDR;\r\ndata = BIT(xgene_enet_ring_bufnum(ring->id));\r\n}\r\nxgene_enet_wr_ring_if(pdata, addr, data);\r\n}\r\nstatic int xgene_enet_gpio_lookup(struct xgene_enet_pdata *pdata)\r\n{\r\nstruct device *dev = &pdata->pdev->dev;\r\npdata->sfp_rdy = gpiod_get(dev, "rxlos", GPIOD_IN);\r\nif (IS_ERR(pdata->sfp_rdy))\r\npdata->sfp_rdy = gpiod_get(dev, "sfp", GPIOD_IN);\r\nif (IS_ERR(pdata->sfp_rdy))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void xgene_enet_link_state(struct work_struct *work)\r\n{\r\nstruct xgene_enet_pdata *pdata = container_of(to_delayed_work(work),\r\nstruct xgene_enet_pdata, link_work);\r\nstruct net_device *ndev = pdata->ndev;\r\nu32 link_status, poll_interval;\r\nlink_status = xgene_enet_link_status(pdata);\r\nif (pdata->sfp_gpio_en && link_status &&\r\n(!IS_ERR(pdata->sfp_rdy) || !xgene_enet_gpio_lookup(pdata)) &&\r\n!gpiod_get_value(pdata->sfp_rdy))\r\nlink_status = 0;\r\nif (link_status) {\r\nif (!netif_carrier_ok(ndev)) {\r\nnetif_carrier_on(ndev);\r\nxgene_xgmac_rx_enable(pdata);\r\nxgene_xgmac_tx_enable(pdata);\r\nnetdev_info(ndev, "Link is Up - 10Gbps\n");\r\n}\r\npoll_interval = PHY_POLL_LINK_ON;\r\n} else {\r\nif (netif_carrier_ok(ndev)) {\r\nxgene_xgmac_rx_disable(pdata);\r\nxgene_xgmac_tx_disable(pdata);\r\nnetif_carrier_off(ndev);\r\nnetdev_info(ndev, "Link is Down\n");\r\n}\r\npoll_interval = PHY_POLL_LINK_OFF;\r\nxgene_pcs_reset(pdata);\r\n}\r\nschedule_delayed_work(&pdata->link_work, poll_interval);\r\n}
