static int cros_ec_sensors_read(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct cros_ec_sensors_state *st = iio_priv(indio_dev);\r\ns16 data = 0;\r\ns64 val64;\r\nint i;\r\nint ret;\r\nint idx = chan->scan_index;\r\nmutex_lock(&st->core.cmd_lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = st->core.read_ec_sensors_data(indio_dev, 1 << idx, &data);\r\nif (ret < 0)\r\nbreak;\r\nret = IIO_VAL_INT;\r\n*val = data;\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nst->core.param.cmd = MOTIONSENSE_CMD_SENSOR_OFFSET;\r\nst->core.param.sensor_offset.flags = 0;\r\nret = cros_ec_motion_send_host_cmd(&st->core, 0);\r\nif (ret < 0)\r\nbreak;\r\nfor (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)\r\nst->core.calib[i] =\r\nst->core.resp->sensor_offset.offset[i];\r\nret = IIO_VAL_INT;\r\n*val = st->core.calib[idx];\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nst->core.param.cmd = MOTIONSENSE_CMD_SENSOR_RANGE;\r\nst->core.param.sensor_range.data = EC_MOTION_SENSE_NO_VALUE;\r\nret = cros_ec_motion_send_host_cmd(&st->core, 0);\r\nif (ret < 0)\r\nbreak;\r\nval64 = st->core.resp->sensor_range.ret;\r\nswitch (st->core.type) {\r\ncase MOTIONSENSE_TYPE_ACCEL:\r\n*val = div_s64(val64 * 980665, 10);\r\n*val2 = 10000 << (CROS_EC_SENSOR_BITS - 1);\r\nret = IIO_VAL_FRACTIONAL;\r\nbreak;\r\ncase MOTIONSENSE_TYPE_GYRO:\r\n*val = div_s64(val64 * 314159 + 9000000ULL, 1000);\r\n*val2 = 18000 << (CROS_EC_SENSOR_BITS - 1);\r\nret = IIO_VAL_FRACTIONAL;\r\nbreak;\r\ncase MOTIONSENSE_TYPE_MAG:\r\n*val = val64;\r\n*val2 = 100 << (CROS_EC_SENSOR_BITS - 1);\r\nret = IIO_VAL_FRACTIONAL;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nret = cros_ec_sensors_core_read(&st->core, chan, val, val2,\r\nmask);\r\nbreak;\r\n}\r\nmutex_unlock(&st->core.cmd_lock);\r\nreturn ret;\r\n}\r\nstatic int cros_ec_sensors_write(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct cros_ec_sensors_state *st = iio_priv(indio_dev);\r\nint i;\r\nint ret;\r\nint idx = chan->scan_index;\r\nmutex_lock(&st->core.cmd_lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nst->core.calib[idx] = val;\r\nst->core.param.cmd = MOTIONSENSE_CMD_SENSOR_OFFSET;\r\nst->core.param.sensor_offset.flags =\r\nMOTION_SENSE_SET_OFFSET;\r\nfor (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)\r\nst->core.param.sensor_offset.offset[i] =\r\nst->core.calib[i];\r\nst->core.param.sensor_offset.temp =\r\nEC_MOTION_SENSE_INVALID_CALIB_TEMP;\r\nret = cros_ec_motion_send_host_cmd(&st->core, 0);\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (st->core.type == MOTIONSENSE_TYPE_MAG) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nst->core.param.cmd = MOTIONSENSE_CMD_SENSOR_RANGE;\r\nst->core.param.sensor_range.data = val;\r\nst->core.param.sensor_range.roundup = 1;\r\nret = cros_ec_motion_send_host_cmd(&st->core, 0);\r\nbreak;\r\ndefault:\r\nret = cros_ec_sensors_core_write(\r\n&st->core, chan, val, val2, mask);\r\nbreak;\r\n}\r\nmutex_unlock(&st->core.cmd_lock);\r\nreturn ret;\r\n}\r\nstatic int cros_ec_sensors_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct cros_ec_dev *ec_dev = dev_get_drvdata(dev->parent);\r\nstruct cros_ec_device *ec_device;\r\nstruct iio_dev *indio_dev;\r\nstruct cros_ec_sensors_state *state;\r\nstruct iio_chan_spec *channel;\r\nint ret, i;\r\nif (!ec_dev || !ec_dev->ec_dev) {\r\ndev_warn(&pdev->dev, "No CROS EC device found.\n");\r\nreturn -EINVAL;\r\n}\r\nec_device = ec_dev->ec_dev;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*state));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nret = cros_ec_sensors_core_init(pdev, indio_dev, true);\r\nif (ret)\r\nreturn ret;\r\nindio_dev->info = &ec_sensors_info;\r\nstate = iio_priv(indio_dev);\r\nfor (channel = state->channels, i = CROS_EC_SENSOR_X;\r\ni < CROS_EC_SENSOR_MAX_AXIS; i++, channel++) {\r\nchannel->info_mask_separate =\r\nBIT(IIO_CHAN_INFO_RAW) |\r\nBIT(IIO_CHAN_INFO_CALIBBIAS);\r\nchannel->info_mask_shared_by_all =\r\nBIT(IIO_CHAN_INFO_SCALE) |\r\nBIT(IIO_CHAN_INFO_FREQUENCY) |\r\nBIT(IIO_CHAN_INFO_SAMP_FREQ);\r\nchannel->scan_type.realbits = CROS_EC_SENSOR_BITS;\r\nchannel->scan_type.storagebits = CROS_EC_SENSOR_BITS;\r\nchannel->scan_index = i;\r\nchannel->ext_info = cros_ec_sensors_ext_info;\r\nchannel->modified = 1;\r\nchannel->channel2 = IIO_MOD_X + i;\r\nchannel->scan_type.sign = 's';\r\nswitch (state->core.type) {\r\ncase MOTIONSENSE_TYPE_ACCEL:\r\nchannel->type = IIO_ACCEL;\r\nbreak;\r\ncase MOTIONSENSE_TYPE_GYRO:\r\nchannel->type = IIO_ANGL_VEL;\r\nbreak;\r\ncase MOTIONSENSE_TYPE_MAG:\r\nchannel->type = IIO_MAGN;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unknown motion sensor\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nchannel->type = IIO_TIMESTAMP;\r\nchannel->channel = -1;\r\nchannel->scan_index = CROS_EC_SENSOR_MAX_AXIS;\r\nchannel->scan_type.sign = 's';\r\nchannel->scan_type.realbits = 64;\r\nchannel->scan_type.storagebits = 64;\r\nindio_dev->channels = state->channels;\r\nindio_dev->num_channels = CROS_EC_SENSORS_MAX_CHANNELS;\r\nif ((state->core.ec->cmd_readmem != NULL) &&\r\n(state->core.type != MOTIONSENSE_TYPE_MAG))\r\nstate->core.read_ec_sensors_data = cros_ec_sensors_read_lpc;\r\nelse\r\nstate->core.read_ec_sensors_data = cros_ec_sensors_read_cmd;\r\nret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,\r\ncros_ec_sensors_capture, NULL);\r\nif (ret)\r\nreturn ret;\r\nreturn devm_iio_device_register(dev, indio_dev);\r\n}
