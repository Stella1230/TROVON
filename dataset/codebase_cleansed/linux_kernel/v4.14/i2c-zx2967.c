static void zx2967_i2c_writel(struct zx2967_i2c *i2c,\r\nu32 val, unsigned long reg)\r\n{\r\nwritel_relaxed(val, i2c->reg_base + reg);\r\n}\r\nstatic u32 zx2967_i2c_readl(struct zx2967_i2c *i2c, unsigned long reg)\r\n{\r\nreturn readl_relaxed(i2c->reg_base + reg);\r\n}\r\nstatic void zx2967_i2c_writesb(struct zx2967_i2c *i2c,\r\nvoid *data, unsigned long reg, int len)\r\n{\r\nwritesb(i2c->reg_base + reg, data, len);\r\n}\r\nstatic void zx2967_i2c_readsb(struct zx2967_i2c *i2c,\r\nvoid *data, unsigned long reg, int len)\r\n{\r\nreadsb(i2c->reg_base + reg, data, len);\r\n}\r\nstatic void zx2967_i2c_start_ctrl(struct zx2967_i2c *i2c)\r\n{\r\nu32 status;\r\nu32 ctl;\r\nstatus = zx2967_i2c_readl(i2c, REG_STAT);\r\nstatus |= I2C_IRQ_ACK_CLEAR;\r\nzx2967_i2c_writel(i2c, status, REG_STAT);\r\nctl = zx2967_i2c_readl(i2c, REG_CMD);\r\nif (i2c->msg_rd)\r\nctl |= I2C_RW_READ;\r\nelse\r\nctl &= ~I2C_RW_READ;\r\nctl &= ~I2C_CMB_RW_EN;\r\nctl |= I2C_START;\r\nzx2967_i2c_writel(i2c, ctl, REG_CMD);\r\n}\r\nstatic void zx2967_i2c_flush_fifos(struct zx2967_i2c *i2c)\r\n{\r\nu32 offset;\r\nu32 val;\r\nif (i2c->msg_rd) {\r\noffset = REG_RDCONF;\r\nval = I2C_RFIFO_RESET;\r\n} else {\r\noffset = REG_WRCONF;\r\nval = I2C_WFIFO_RESET;\r\n}\r\nval |= zx2967_i2c_readl(i2c, offset);\r\nzx2967_i2c_writel(i2c, val, offset);\r\n}\r\nstatic int zx2967_i2c_empty_rx_fifo(struct zx2967_i2c *i2c, u32 size)\r\n{\r\nu8 val[I2C_FIFO_MAX] = {0};\r\nint i;\r\nif (size > I2C_FIFO_MAX) {\r\ndev_err(DEV(i2c), "fifo size %d over the max value %d\n",\r\nsize, I2C_FIFO_MAX);\r\nreturn -EINVAL;\r\n}\r\nzx2967_i2c_readsb(i2c, val, REG_DATA, size);\r\nfor (i = 0; i < size; i++) {\r\n*i2c->cur_trans++ = val[i];\r\ni2c->residue--;\r\n}\r\nbarrier();\r\nreturn 0;\r\n}\r\nstatic int zx2967_i2c_fill_tx_fifo(struct zx2967_i2c *i2c)\r\n{\r\nsize_t residue = i2c->residue;\r\nu8 *buf = i2c->cur_trans;\r\nif (residue == 0) {\r\ndev_err(DEV(i2c), "residue is %d\n", (int)residue);\r\nreturn -EINVAL;\r\n}\r\nif (residue <= I2C_FIFO_MAX) {\r\nzx2967_i2c_writesb(i2c, buf, REG_DATA, residue);\r\ni2c->residue = 0;\r\ni2c->cur_trans = NULL;\r\n} else {\r\nzx2967_i2c_writesb(i2c, buf, REG_DATA, I2C_FIFO_MAX);\r\ni2c->residue -= I2C_FIFO_MAX;\r\ni2c->cur_trans += I2C_FIFO_MAX;\r\n}\r\nbarrier();\r\nreturn 0;\r\n}\r\nstatic int zx2967_i2c_reset_hardware(struct zx2967_i2c *i2c)\r\n{\r\nu32 val;\r\nu32 clk_div;\r\nval = I2C_MASTER | I2C_IRQ_MSK_ENABLE;\r\nzx2967_i2c_writel(i2c, val, REG_CMD);\r\nclk_div = clk_get_rate(i2c->clk) / i2c->clk_freq - 1;\r\nzx2967_i2c_writel(i2c, clk_div, REG_CLK_DIV_FS);\r\nzx2967_i2c_writel(i2c, clk_div, REG_CLK_DIV_HS);\r\nzx2967_i2c_writel(i2c, I2C_FIFO_MAX - 1, REG_WRCONF);\r\nzx2967_i2c_writel(i2c, I2C_FIFO_MAX - 1, REG_RDCONF);\r\nzx2967_i2c_writel(i2c, 1, REG_RDCONF);\r\nzx2967_i2c_flush_fifos(i2c);\r\nreturn 0;\r\n}\r\nstatic void zx2967_i2c_isr_clr(struct zx2967_i2c *i2c)\r\n{\r\nu32 status;\r\nstatus = zx2967_i2c_readl(i2c, REG_STAT);\r\nstatus |= I2C_IRQ_ACK_CLEAR;\r\nzx2967_i2c_writel(i2c, status, REG_STAT);\r\n}\r\nstatic irqreturn_t zx2967_i2c_isr(int irq, void *dev_id)\r\n{\r\nu32 status;\r\nstruct zx2967_i2c *i2c = (struct zx2967_i2c *)dev_id;\r\nstatus = zx2967_i2c_readl(i2c, REG_STAT) & I2C_INT_MASK;\r\nzx2967_i2c_isr_clr(i2c);\r\nif (status & I2C_SR_EDEVICE)\r\ni2c->error = -ENXIO;\r\nelse if (status & I2C_SR_EDATA)\r\ni2c->error = -EIO;\r\nelse if (status & I2C_TRANS_DONE)\r\ni2c->error = 0;\r\nelse\r\ngoto done;\r\ncomplete(&i2c->complete);\r\ndone:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void zx2967_set_addr(struct zx2967_i2c *i2c, u16 addr)\r\n{\r\nu16 val;\r\nval = (addr >> I2C_ADDR_LOW_SHIFT) & I2C_ADDR_LOW_MASK;\r\nzx2967_i2c_writel(i2c, val, REG_DEVADDR_L);\r\nval = (addr >> I2C_ADDR_HI_SHIFT) & I2C_ADDR_HI_MASK;\r\nzx2967_i2c_writel(i2c, val, REG_DEVADDR_H);\r\nif (val)\r\nval = zx2967_i2c_readl(i2c, REG_CMD) | I2C_ADDR_MODE_TEN;\r\nelse\r\nval = zx2967_i2c_readl(i2c, REG_CMD) & ~I2C_ADDR_MODE_TEN;\r\nzx2967_i2c_writel(i2c, val, REG_CMD);\r\n}\r\nstatic int zx2967_i2c_xfer_bytes(struct zx2967_i2c *i2c, u32 bytes)\r\n{\r\nunsigned long time_left;\r\nint rd = i2c->msg_rd;\r\nint ret;\r\nreinit_completion(&i2c->complete);\r\nif (rd) {\r\nzx2967_i2c_writel(i2c, bytes - 1, REG_RDCONF);\r\n} else {\r\nret = zx2967_i2c_fill_tx_fifo(i2c);\r\nif (ret)\r\nreturn ret;\r\n}\r\nzx2967_i2c_start_ctrl(i2c);\r\ntime_left = wait_for_completion_timeout(&i2c->complete,\r\nI2C_TIMEOUT);\r\nif (time_left == 0)\r\nreturn -ETIMEDOUT;\r\nif (i2c->error)\r\nreturn i2c->error;\r\nreturn rd ? zx2967_i2c_empty_rx_fifo(i2c, bytes) : 0;\r\n}\r\nstatic int zx2967_i2c_xfer_msg(struct zx2967_i2c *i2c,\r\nstruct i2c_msg *msg)\r\n{\r\nint ret;\r\nint i;\r\nif (msg->len == 0)\r\nreturn -EINVAL;\r\nzx2967_i2c_flush_fifos(i2c);\r\ni2c->cur_trans = msg->buf;\r\ni2c->residue = msg->len;\r\ni2c->access_cnt = msg->len / I2C_FIFO_MAX;\r\ni2c->msg_rd = msg->flags & I2C_M_RD;\r\nfor (i = 0; i < i2c->access_cnt; i++) {\r\nret = zx2967_i2c_xfer_bytes(i2c, I2C_FIFO_MAX);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (i2c->residue > 0) {\r\nret = zx2967_i2c_xfer_bytes(i2c, i2c->residue);\r\nif (ret)\r\nreturn ret;\r\n}\r\ni2c->residue = 0;\r\ni2c->access_cnt = 0;\r\nreturn 0;\r\n}\r\nstatic int zx2967_i2c_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct zx2967_i2c *i2c = i2c_get_adapdata(adap);\r\nint ret;\r\nint i;\r\nif (i2c->is_suspended)\r\nreturn -EBUSY;\r\nzx2967_set_addr(i2c, msgs->addr);\r\nfor (i = 0; i < num; i++) {\r\nret = zx2967_i2c_xfer_msg(i2c, &msgs[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn num;\r\n}\r\nstatic void\r\nzx2967_smbus_xfer_prepare(struct zx2967_i2c *i2c, u16 addr,\r\nchar read_write, u8 command, int size,\r\nunion i2c_smbus_data *data)\r\n{\r\nu32 val;\r\nval = zx2967_i2c_readl(i2c, REG_RDCONF);\r\nval |= I2C_RFIFO_RESET;\r\nzx2967_i2c_writel(i2c, val, REG_RDCONF);\r\nzx2967_set_addr(i2c, addr);\r\nval = zx2967_i2c_readl(i2c, REG_CMD);\r\nval &= ~I2C_RW_READ;\r\nzx2967_i2c_writel(i2c, val, REG_CMD);\r\nswitch (size) {\r\ncase I2C_SMBUS_BYTE:\r\nzx2967_i2c_writel(i2c, command, REG_DATA);\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nzx2967_i2c_writel(i2c, command, REG_DATA);\r\nif (read_write == I2C_SMBUS_WRITE)\r\nzx2967_i2c_writel(i2c, data->byte, REG_DATA);\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\nzx2967_i2c_writel(i2c, command, REG_DATA);\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nzx2967_i2c_writel(i2c, (data->word >> 8), REG_DATA);\r\nzx2967_i2c_writel(i2c, (data->word & 0xff),\r\nREG_DATA);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int zx2967_smbus_xfer_read(struct zx2967_i2c *i2c, int size,\r\nunion i2c_smbus_data *data)\r\n{\r\nunsigned long time_left;\r\nu8 buf[2];\r\nu32 val;\r\nreinit_completion(&i2c->complete);\r\nval = zx2967_i2c_readl(i2c, REG_CMD);\r\nval |= I2C_CMB_RW_EN;\r\nzx2967_i2c_writel(i2c, val, REG_CMD);\r\nval = zx2967_i2c_readl(i2c, REG_CMD);\r\nval |= I2C_START;\r\nzx2967_i2c_writel(i2c, val, REG_CMD);\r\ntime_left = wait_for_completion_timeout(&i2c->complete,\r\nI2C_TIMEOUT);\r\nif (time_left == 0)\r\nreturn -ETIMEDOUT;\r\nif (i2c->error)\r\nreturn i2c->error;\r\nswitch (size) {\r\ncase I2C_SMBUS_BYTE:\r\ncase I2C_SMBUS_BYTE_DATA:\r\nval = zx2967_i2c_readl(i2c, REG_DATA);\r\ndata->byte = val;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\ncase I2C_SMBUS_PROC_CALL:\r\nbuf[0] = zx2967_i2c_readl(i2c, REG_DATA);\r\nbuf[1] = zx2967_i2c_readl(i2c, REG_DATA);\r\ndata->word = (buf[0] << 8) | buf[1];\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zx2967_smbus_xfer_write(struct zx2967_i2c *i2c)\r\n{\r\nunsigned long time_left;\r\nu32 val;\r\nreinit_completion(&i2c->complete);\r\nval = zx2967_i2c_readl(i2c, REG_CMD);\r\nval |= I2C_START;\r\nzx2967_i2c_writel(i2c, val, REG_CMD);\r\ntime_left = wait_for_completion_timeout(&i2c->complete,\r\nI2C_TIMEOUT);\r\nif (time_left == 0)\r\nreturn -ETIMEDOUT;\r\nif (i2c->error)\r\nreturn i2c->error;\r\nreturn 0;\r\n}\r\nstatic int zx2967_smbus_xfer(struct i2c_adapter *adap, u16 addr,\r\nunsigned short flags, char read_write,\r\nu8 command, int size, union i2c_smbus_data *data)\r\n{\r\nstruct zx2967_i2c *i2c = i2c_get_adapdata(adap);\r\nif (size == I2C_SMBUS_QUICK)\r\nread_write = I2C_SMBUS_WRITE;\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\ncase I2C_SMBUS_BYTE:\r\ncase I2C_SMBUS_BYTE_DATA:\r\ncase I2C_SMBUS_WORD_DATA:\r\nzx2967_smbus_xfer_prepare(i2c, addr, read_write,\r\ncommand, size, data);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (read_write == I2C_SMBUS_READ)\r\nreturn zx2967_smbus_xfer_read(i2c, size, data);\r\nreturn zx2967_smbus_xfer_write(i2c);\r\n}\r\nstatic u32 zx2967_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C |\r\nI2C_FUNC_SMBUS_QUICK |\r\nI2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_DATA |\r\nI2C_FUNC_SMBUS_PROC_CALL |\r\nI2C_FUNC_SMBUS_I2C_BLOCK;\r\n}\r\nstatic int __maybe_unused zx2967_i2c_suspend(struct device *dev)\r\n{\r\nstruct zx2967_i2c *i2c = dev_get_drvdata(dev);\r\ni2c->is_suspended = true;\r\nclk_disable_unprepare(i2c->clk);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused zx2967_i2c_resume(struct device *dev)\r\n{\r\nstruct zx2967_i2c *i2c = dev_get_drvdata(dev);\r\ni2c->is_suspended = false;\r\nclk_prepare_enable(i2c->clk);\r\nreturn 0;\r\n}\r\nstatic int zx2967_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct zx2967_i2c *i2c;\r\nvoid __iomem *reg_base;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nint ret;\r\ni2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nreg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(reg_base))\r\nreturn PTR_ERR(reg_base);\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "missing controller clock");\r\nreturn PTR_ERR(clk);\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable i2c_clk\n");\r\nreturn ret;\r\n}\r\nret = device_property_read_u32(&pdev->dev, "clock-frequency",\r\n&i2c->clk_freq);\r\nif (ret) {\r\ndev_err(&pdev->dev, "missing clock-frequency");\r\nreturn ret;\r\n}\r\nret = platform_get_irq(pdev, 0);\r\nif (ret < 0)\r\nreturn ret;\r\ni2c->irq = ret;\r\ni2c->reg_base = reg_base;\r\ni2c->clk = clk;\r\ninit_completion(&i2c->complete);\r\nplatform_set_drvdata(pdev, i2c);\r\nret = zx2967_i2c_reset_hardware(i2c);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to initialize i2c controller\n");\r\ngoto err_clk_unprepare;\r\n}\r\nret = devm_request_irq(&pdev->dev, i2c->irq,\r\nzx2967_i2c_isr, 0, dev_name(&pdev->dev), i2c);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request irq %i\n", i2c->irq);\r\ngoto err_clk_unprepare;\r\n}\r\ni2c_set_adapdata(&i2c->adap, i2c);\r\nstrlcpy(i2c->adap.name, "zx2967 i2c adapter",\r\nsizeof(i2c->adap.name));\r\ni2c->adap.algo = &zx2967_i2c_algo;\r\ni2c->adap.nr = pdev->id;\r\ni2c->adap.dev.parent = &pdev->dev;\r\ni2c->adap.dev.of_node = pdev->dev.of_node;\r\nret = i2c_add_numbered_adapter(&i2c->adap);\r\nif (ret)\r\ngoto err_clk_unprepare;\r\nreturn 0;\r\nerr_clk_unprepare:\r\nclk_disable_unprepare(i2c->clk);\r\nreturn ret;\r\n}\r\nstatic int zx2967_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct zx2967_i2c *i2c = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&i2c->adap);\r\nclk_disable_unprepare(i2c->clk);\r\nreturn 0;\r\n}
