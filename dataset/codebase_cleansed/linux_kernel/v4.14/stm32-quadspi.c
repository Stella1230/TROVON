static int stm32_qspi_wait_cmd(struct stm32_qspi *qspi)\r\n{\r\nu32 cr;\r\nint err = 0;\r\nif (readl_relaxed(qspi->io_base + QUADSPI_SR) & SR_TCF)\r\nreturn 0;\r\nreinit_completion(&qspi->cmd_completion);\r\ncr = readl_relaxed(qspi->io_base + QUADSPI_CR);\r\nwritel_relaxed(cr | CR_TCIE, qspi->io_base + QUADSPI_CR);\r\nif (!wait_for_completion_interruptible_timeout(&qspi->cmd_completion,\r\nmsecs_to_jiffies(1000)))\r\nerr = -ETIMEDOUT;\r\nwritel_relaxed(cr, qspi->io_base + QUADSPI_CR);\r\nreturn err;\r\n}\r\nstatic int stm32_qspi_wait_nobusy(struct stm32_qspi *qspi)\r\n{\r\nu32 sr;\r\nreturn readl_relaxed_poll_timeout(qspi->io_base + QUADSPI_SR, sr,\r\n!(sr & SR_BUSY), 10,\r\nSTM32_QSPI_BUSY_TIMEOUT_US);\r\n}\r\nstatic void stm32_qspi_set_framemode(struct spi_nor *nor,\r\nstruct stm32_qspi_cmd *cmd, bool read)\r\n{\r\nu32 dmode = CCR_DMODE_1;\r\ncmd->framemode = CCR_IMODE_1;\r\nif (read) {\r\nswitch (nor->read_proto) {\r\ndefault:\r\ncase SNOR_PROTO_1_1_1:\r\ndmode = CCR_DMODE_1;\r\nbreak;\r\ncase SNOR_PROTO_1_1_2:\r\ndmode = CCR_DMODE_2;\r\nbreak;\r\ncase SNOR_PROTO_1_1_4:\r\ndmode = CCR_DMODE_4;\r\nbreak;\r\n}\r\n}\r\ncmd->framemode |= cmd->tx_data ? dmode : 0;\r\ncmd->framemode |= cmd->addr_width ? CCR_ADMODE_1 : 0;\r\n}\r\nstatic void stm32_qspi_read_fifo(u8 *val, void __iomem *addr)\r\n{\r\n*val = readb_relaxed(addr);\r\n}\r\nstatic void stm32_qspi_write_fifo(u8 *val, void __iomem *addr)\r\n{\r\nwriteb_relaxed(*val, addr);\r\n}\r\nstatic int stm32_qspi_tx_poll(struct stm32_qspi *qspi,\r\nconst struct stm32_qspi_cmd *cmd)\r\n{\r\nvoid (*tx_fifo)(u8 *, void __iomem *);\r\nu32 len = cmd->len, sr;\r\nu8 *buf = cmd->buf;\r\nint ret;\r\nif (cmd->qspimode == CCR_FMODE_INDW)\r\ntx_fifo = stm32_qspi_write_fifo;\r\nelse\r\ntx_fifo = stm32_qspi_read_fifo;\r\nwhile (len--) {\r\nret = readl_relaxed_poll_timeout(qspi->io_base + QUADSPI_SR,\r\nsr, (sr & SR_FTF), 10,\r\nSTM32_QSPI_FIFO_TIMEOUT_US);\r\nif (ret) {\r\ndev_err(qspi->dev, "fifo timeout (stat:%#x)\n", sr);\r\nbreak;\r\n}\r\ntx_fifo(buf++, qspi->io_base + QUADSPI_DR);\r\n}\r\nreturn ret;\r\n}\r\nstatic int stm32_qspi_tx_mm(struct stm32_qspi *qspi,\r\nconst struct stm32_qspi_cmd *cmd)\r\n{\r\nmemcpy_fromio(cmd->buf, qspi->mm_base + cmd->addr, cmd->len);\r\nreturn 0;\r\n}\r\nstatic int stm32_qspi_tx(struct stm32_qspi *qspi,\r\nconst struct stm32_qspi_cmd *cmd)\r\n{\r\nif (!cmd->tx_data)\r\nreturn 0;\r\nif (cmd->qspimode == CCR_FMODE_MM)\r\nreturn stm32_qspi_tx_mm(qspi, cmd);\r\nreturn stm32_qspi_tx_poll(qspi, cmd);\r\n}\r\nstatic int stm32_qspi_send(struct stm32_qspi_flash *flash,\r\nconst struct stm32_qspi_cmd *cmd)\r\n{\r\nstruct stm32_qspi *qspi = flash->qspi;\r\nu32 ccr, dcr, cr;\r\nint err;\r\nerr = stm32_qspi_wait_nobusy(qspi);\r\nif (err)\r\ngoto abort;\r\ndcr = readl_relaxed(qspi->io_base + QUADSPI_DCR) & ~DCR_FSIZE_MASK;\r\ndcr |= DCR_FSIZE(flash->fsize);\r\nwritel_relaxed(dcr, qspi->io_base + QUADSPI_DCR);\r\ncr = readl_relaxed(qspi->io_base + QUADSPI_CR);\r\ncr &= ~CR_PRESC_MASK & ~CR_FSEL;\r\ncr |= CR_PRESC(flash->presc);\r\ncr |= flash->cs ? CR_FSEL : 0;\r\nwritel_relaxed(cr, qspi->io_base + QUADSPI_CR);\r\nif (cmd->tx_data)\r\nwritel_relaxed(cmd->len - 1, qspi->io_base + QUADSPI_DLR);\r\nccr = cmd->framemode | cmd->qspimode;\r\nif (cmd->dummy)\r\nccr |= CCR_DCYC(cmd->dummy);\r\nif (cmd->addr_width)\r\nccr |= CCR_ADSIZE(cmd->addr_width - 1);\r\nccr |= CCR_INST(cmd->opcode);\r\nwritel_relaxed(ccr, qspi->io_base + QUADSPI_CCR);\r\nif (cmd->addr_width && cmd->qspimode != CCR_FMODE_MM)\r\nwritel_relaxed(cmd->addr, qspi->io_base + QUADSPI_AR);\r\nerr = stm32_qspi_tx(qspi, cmd);\r\nif (err)\r\ngoto abort;\r\nif (cmd->qspimode != CCR_FMODE_MM) {\r\nerr = stm32_qspi_wait_cmd(qspi);\r\nif (err)\r\ngoto abort;\r\nwritel_relaxed(FCR_CTCF, qspi->io_base + QUADSPI_FCR);\r\n}\r\nreturn err;\r\nabort:\r\ncr = readl_relaxed(qspi->io_base + QUADSPI_CR) | CR_ABORT;\r\nwritel_relaxed(cr, qspi->io_base + QUADSPI_CR);\r\ndev_err(qspi->dev, "%s abort err:%d\n", __func__, err);\r\nreturn err;\r\n}\r\nstatic int stm32_qspi_read_reg(struct spi_nor *nor,\r\nu8 opcode, u8 *buf, int len)\r\n{\r\nstruct stm32_qspi_flash *flash = nor->priv;\r\nstruct device *dev = flash->qspi->dev;\r\nstruct stm32_qspi_cmd cmd;\r\ndev_dbg(dev, "read_reg: cmd:%#.2x buf:%p len:%#x\n", opcode, buf, len);\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.opcode = opcode;\r\ncmd.tx_data = true;\r\ncmd.len = len;\r\ncmd.buf = buf;\r\ncmd.qspimode = CCR_FMODE_INDR;\r\nstm32_qspi_set_framemode(nor, &cmd, false);\r\nreturn stm32_qspi_send(flash, &cmd);\r\n}\r\nstatic int stm32_qspi_write_reg(struct spi_nor *nor, u8 opcode,\r\nu8 *buf, int len)\r\n{\r\nstruct stm32_qspi_flash *flash = nor->priv;\r\nstruct device *dev = flash->qspi->dev;\r\nstruct stm32_qspi_cmd cmd;\r\ndev_dbg(dev, "write_reg: cmd:%#.2x buf:%p len:%#x\n", opcode, buf, len);\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.opcode = opcode;\r\ncmd.tx_data = !!(buf && len > 0);\r\ncmd.len = len;\r\ncmd.buf = buf;\r\ncmd.qspimode = CCR_FMODE_INDW;\r\nstm32_qspi_set_framemode(nor, &cmd, false);\r\nreturn stm32_qspi_send(flash, &cmd);\r\n}\r\nstatic ssize_t stm32_qspi_read(struct spi_nor *nor, loff_t from, size_t len,\r\nu_char *buf)\r\n{\r\nstruct stm32_qspi_flash *flash = nor->priv;\r\nstruct stm32_qspi *qspi = flash->qspi;\r\nstruct stm32_qspi_cmd cmd;\r\nint err;\r\ndev_dbg(qspi->dev, "read(%#.2x): buf:%p from:%#.8x len:%#zx\n",\r\nnor->read_opcode, buf, (u32)from, len);\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.opcode = nor->read_opcode;\r\ncmd.addr_width = nor->addr_width;\r\ncmd.addr = (u32)from;\r\ncmd.tx_data = true;\r\ncmd.dummy = nor->read_dummy;\r\ncmd.len = len;\r\ncmd.buf = buf;\r\ncmd.qspimode = flash->read_mode;\r\nstm32_qspi_set_framemode(nor, &cmd, true);\r\nerr = stm32_qspi_send(flash, &cmd);\r\nreturn err ? err : len;\r\n}\r\nstatic ssize_t stm32_qspi_write(struct spi_nor *nor, loff_t to, size_t len,\r\nconst u_char *buf)\r\n{\r\nstruct stm32_qspi_flash *flash = nor->priv;\r\nstruct device *dev = flash->qspi->dev;\r\nstruct stm32_qspi_cmd cmd;\r\nint err;\r\ndev_dbg(dev, "write(%#.2x): buf:%p to:%#.8x len:%#zx\n",\r\nnor->program_opcode, buf, (u32)to, len);\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.opcode = nor->program_opcode;\r\ncmd.addr_width = nor->addr_width;\r\ncmd.addr = (u32)to;\r\ncmd.tx_data = true;\r\ncmd.len = len;\r\ncmd.buf = (void *)buf;\r\ncmd.qspimode = CCR_FMODE_INDW;\r\nstm32_qspi_set_framemode(nor, &cmd, false);\r\nerr = stm32_qspi_send(flash, &cmd);\r\nreturn err ? err : len;\r\n}\r\nstatic int stm32_qspi_erase(struct spi_nor *nor, loff_t offs)\r\n{\r\nstruct stm32_qspi_flash *flash = nor->priv;\r\nstruct device *dev = flash->qspi->dev;\r\nstruct stm32_qspi_cmd cmd;\r\ndev_dbg(dev, "erase(%#.2x):offs:%#x\n", nor->erase_opcode, (u32)offs);\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.opcode = nor->erase_opcode;\r\ncmd.addr_width = nor->addr_width;\r\ncmd.addr = (u32)offs;\r\ncmd.qspimode = CCR_FMODE_INDW;\r\nstm32_qspi_set_framemode(nor, &cmd, false);\r\nreturn stm32_qspi_send(flash, &cmd);\r\n}\r\nstatic irqreturn_t stm32_qspi_irq(int irq, void *dev_id)\r\n{\r\nstruct stm32_qspi *qspi = (struct stm32_qspi *)dev_id;\r\nu32 cr, sr, fcr = 0;\r\ncr = readl_relaxed(qspi->io_base + QUADSPI_CR);\r\nsr = readl_relaxed(qspi->io_base + QUADSPI_SR);\r\nif ((cr & CR_TCIE) && (sr & SR_TCF)) {\r\nfcr |= FCR_CTCF;\r\ncomplete(&qspi->cmd_completion);\r\n} else {\r\ndev_info_ratelimited(qspi->dev, "spurious interrupt\n");\r\n}\r\nwritel_relaxed(fcr, qspi->io_base + QUADSPI_FCR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int stm32_qspi_prep(struct spi_nor *nor, enum spi_nor_ops ops)\r\n{\r\nstruct stm32_qspi_flash *flash = nor->priv;\r\nstruct stm32_qspi *qspi = flash->qspi;\r\nmutex_lock(&qspi->lock);\r\nreturn 0;\r\n}\r\nstatic void stm32_qspi_unprep(struct spi_nor *nor, enum spi_nor_ops ops)\r\n{\r\nstruct stm32_qspi_flash *flash = nor->priv;\r\nstruct stm32_qspi *qspi = flash->qspi;\r\nmutex_unlock(&qspi->lock);\r\n}\r\nstatic int stm32_qspi_flash_setup(struct stm32_qspi *qspi,\r\nstruct device_node *np)\r\n{\r\nstruct spi_nor_hwcaps hwcaps = {\r\n.mask = SNOR_HWCAPS_READ |\r\nSNOR_HWCAPS_READ_FAST |\r\nSNOR_HWCAPS_PP,\r\n};\r\nu32 width, presc, cs_num, max_rate = 0;\r\nstruct stm32_qspi_flash *flash;\r\nstruct mtd_info *mtd;\r\nint ret;\r\nof_property_read_u32(np, "reg", &cs_num);\r\nif (cs_num >= STM32_MAX_NORCHIP)\r\nreturn -EINVAL;\r\nof_property_read_u32(np, "spi-max-frequency", &max_rate);\r\nif (!max_rate)\r\nreturn -EINVAL;\r\npresc = DIV_ROUND_UP(qspi->clk_rate, max_rate) - 1;\r\nif (of_property_read_u32(np, "spi-rx-bus-width", &width))\r\nwidth = 1;\r\nif (width == 4)\r\nhwcaps.mask |= SNOR_HWCAPS_READ_1_1_4;\r\nelse if (width == 2)\r\nhwcaps.mask |= SNOR_HWCAPS_READ_1_1_2;\r\nelse if (width != 1)\r\nreturn -EINVAL;\r\nflash = &qspi->flash[cs_num];\r\nflash->qspi = qspi;\r\nflash->cs = cs_num;\r\nflash->presc = presc;\r\nflash->nor.dev = qspi->dev;\r\nspi_nor_set_flash_node(&flash->nor, np);\r\nflash->nor.priv = flash;\r\nmtd = &flash->nor.mtd;\r\nflash->nor.read = stm32_qspi_read;\r\nflash->nor.write = stm32_qspi_write;\r\nflash->nor.erase = stm32_qspi_erase;\r\nflash->nor.read_reg = stm32_qspi_read_reg;\r\nflash->nor.write_reg = stm32_qspi_write_reg;\r\nflash->nor.prepare = stm32_qspi_prep;\r\nflash->nor.unprepare = stm32_qspi_unprep;\r\nwritel_relaxed(LPTR_DFT_TIMEOUT, qspi->io_base + QUADSPI_LPTR);\r\nwritel_relaxed(CR_PRESC(presc) | CR_FTHRES(3) | CR_TCEN | CR_SSHIFT\r\n| CR_EN, qspi->io_base + QUADSPI_CR);\r\nflash->fsize = FSIZE_VAL(SZ_1K);\r\nret = spi_nor_scan(&flash->nor, NULL, &hwcaps);\r\nif (ret) {\r\ndev_err(qspi->dev, "device scan failed\n");\r\nreturn ret;\r\n}\r\nflash->fsize = FSIZE_VAL(mtd->size);\r\nflash->read_mode = CCR_FMODE_MM;\r\nif (mtd->size > qspi->mm_size)\r\nflash->read_mode = CCR_FMODE_INDR;\r\nwritel_relaxed(DCR_CSHT(1), qspi->io_base + QUADSPI_DCR);\r\nret = mtd_device_register(mtd, NULL, 0);\r\nif (ret) {\r\ndev_err(qspi->dev, "mtd device parse failed\n");\r\nreturn ret;\r\n}\r\nflash->registered = true;\r\ndev_dbg(qspi->dev, "read mm:%s cs:%d bus:%d\n",\r\nflash->read_mode == CCR_FMODE_MM ? "yes" : "no", cs_num, width);\r\nreturn 0;\r\n}\r\nstatic void stm32_qspi_mtd_free(struct stm32_qspi *qspi)\r\n{\r\nint i;\r\nfor (i = 0; i < STM32_MAX_NORCHIP; i++)\r\nif (qspi->flash[i].registered)\r\nmtd_device_unregister(&qspi->flash[i].nor.mtd);\r\n}\r\nstatic int stm32_qspi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *flash_np;\r\nstruct reset_control *rstc;\r\nstruct stm32_qspi *qspi;\r\nstruct resource *res;\r\nint ret, irq;\r\nqspi = devm_kzalloc(dev, sizeof(*qspi), GFP_KERNEL);\r\nif (!qspi)\r\nreturn -ENOMEM;\r\nqspi->nor_num = of_get_child_count(dev->of_node);\r\nif (!qspi->nor_num || qspi->nor_num > STM32_MAX_NORCHIP)\r\nreturn -ENODEV;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "qspi");\r\nqspi->io_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(qspi->io_base))\r\nreturn PTR_ERR(qspi->io_base);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "qspi_mm");\r\nqspi->mm_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(qspi->mm_base))\r\nreturn PTR_ERR(qspi->mm_base);\r\nqspi->mm_size = resource_size(res);\r\nirq = platform_get_irq(pdev, 0);\r\nret = devm_request_irq(dev, irq, stm32_qspi_irq, 0,\r\ndev_name(dev), qspi);\r\nif (ret) {\r\ndev_err(dev, "failed to request irq\n");\r\nreturn ret;\r\n}\r\ninit_completion(&qspi->cmd_completion);\r\nqspi->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(qspi->clk))\r\nreturn PTR_ERR(qspi->clk);\r\nqspi->clk_rate = clk_get_rate(qspi->clk);\r\nif (!qspi->clk_rate)\r\nreturn -EINVAL;\r\nret = clk_prepare_enable(qspi->clk);\r\nif (ret) {\r\ndev_err(dev, "can not enable the clock\n");\r\nreturn ret;\r\n}\r\nrstc = devm_reset_control_get(dev, NULL);\r\nif (!IS_ERR(rstc)) {\r\nreset_control_assert(rstc);\r\nudelay(2);\r\nreset_control_deassert(rstc);\r\n}\r\nqspi->dev = dev;\r\nplatform_set_drvdata(pdev, qspi);\r\nmutex_init(&qspi->lock);\r\nfor_each_available_child_of_node(dev->of_node, flash_np) {\r\nret = stm32_qspi_flash_setup(qspi, flash_np);\r\nif (ret) {\r\ndev_err(dev, "unable to setup flash chip\n");\r\ngoto err_flash;\r\n}\r\n}\r\nreturn 0;\r\nerr_flash:\r\nmutex_destroy(&qspi->lock);\r\nstm32_qspi_mtd_free(qspi);\r\nclk_disable_unprepare(qspi->clk);\r\nreturn ret;\r\n}\r\nstatic int stm32_qspi_remove(struct platform_device *pdev)\r\n{\r\nstruct stm32_qspi *qspi = platform_get_drvdata(pdev);\r\nwritel_relaxed(0, qspi->io_base + QUADSPI_CR);\r\nstm32_qspi_mtd_free(qspi);\r\nmutex_destroy(&qspi->lock);\r\nclk_disable_unprepare(qspi->clk);\r\nreturn 0;\r\n}
