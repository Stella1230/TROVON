static int dummy_ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len,\r\nint *addr_len)\r\n{\r\nreturn -EAFNOSUPPORT;\r\n}\r\nstatic void dummy_ip6_datagram_recv_ctl(struct sock *sk, struct msghdr *msg,\r\nstruct sk_buff *skb)\r\n{\r\n}\r\nstatic int dummy_icmpv6_err_convert(u8 type, u8 code, int *err)\r\n{\r\nreturn -EAFNOSUPPORT;\r\n}\r\nstatic void dummy_ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err,\r\n__be16 port, u32 info, u8 *payload) {}\r\nstatic int dummy_ipv6_chk_addr(struct net *net, const struct in6_addr *addr,\r\nconst struct net_device *dev, int strict)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ping_v6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct icmp6hdr user_icmph;\r\nint addr_type;\r\nstruct in6_addr *daddr;\r\nint oif = 0;\r\nstruct flowi6 fl6;\r\nint err;\r\nstruct dst_entry *dst;\r\nstruct rt6_info *rt;\r\nstruct pingfakehdr pfh;\r\nstruct sockcm_cookie junk = {0};\r\nstruct ipcm6_cookie ipc6;\r\npr_debug("ping_v6_sendmsg(sk=%p,sk->num=%u)\n", inet, inet->inet_num);\r\nerr = ping_common_sendmsg(AF_INET6, msg, len, &user_icmph,\r\nsizeof(user_icmph));\r\nif (err)\r\nreturn err;\r\nif (msg->msg_name) {\r\nDECLARE_SOCKADDR(struct sockaddr_in6 *, u, msg->msg_name);\r\nif (msg->msg_namelen < sizeof(*u))\r\nreturn -EINVAL;\r\nif (u->sin6_family != AF_INET6) {\r\nreturn -EAFNOSUPPORT;\r\n}\r\ndaddr = &(u->sin6_addr);\r\nif (__ipv6_addr_needs_scope_id(ipv6_addr_type(daddr)))\r\noif = u->sin6_scope_id;\r\n} else {\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\nreturn -EDESTADDRREQ;\r\ndaddr = &sk->sk_v6_daddr;\r\n}\r\nif (!oif)\r\noif = sk->sk_bound_dev_if;\r\nif (!oif)\r\noif = np->sticky_pktinfo.ipi6_ifindex;\r\nif (!oif && ipv6_addr_is_multicast(daddr))\r\noif = np->mcast_oif;\r\nelse if (!oif)\r\noif = np->ucast_oif;\r\naddr_type = ipv6_addr_type(daddr);\r\nif ((__ipv6_addr_needs_scope_id(addr_type) && !oif) ||\r\n(addr_type & IPV6_ADDR_MAPPED) ||\r\n(oif && sk->sk_bound_dev_if && oif != sk->sk_bound_dev_if))\r\nreturn -EINVAL;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nfl6.flowi6_proto = IPPROTO_ICMPV6;\r\nfl6.saddr = np->saddr;\r\nfl6.daddr = *daddr;\r\nfl6.flowi6_oif = oif;\r\nfl6.flowi6_mark = sk->sk_mark;\r\nfl6.flowi6_uid = sk->sk_uid;\r\nfl6.fl6_icmp_type = user_icmph.icmp6_type;\r\nfl6.fl6_icmp_code = user_icmph.icmp6_code;\r\nsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\r\nipc6.tclass = np->tclass;\r\nfl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel);\r\ndst = ip6_sk_dst_lookup_flow(sk, &fl6, daddr);\r\nif (IS_ERR(dst))\r\nreturn PTR_ERR(dst);\r\nrt = (struct rt6_info *) dst;\r\nif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\r\nfl6.flowi6_oif = np->mcast_oif;\r\nelse if (!fl6.flowi6_oif)\r\nfl6.flowi6_oif = np->ucast_oif;\r\npfh.icmph.type = user_icmph.icmp6_type;\r\npfh.icmph.code = user_icmph.icmp6_code;\r\npfh.icmph.checksum = 0;\r\npfh.icmph.un.echo.id = inet->inet_sport;\r\npfh.icmph.un.echo.sequence = user_icmph.icmp6_sequence;\r\npfh.msg = msg;\r\npfh.wcheck = 0;\r\npfh.family = AF_INET6;\r\nipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\r\nipc6.dontfrag = np->dontfrag;\r\nipc6.opt = NULL;\r\nlock_sock(sk);\r\nerr = ip6_append_data(sk, ping_getfrag, &pfh, len,\r\n0, &ipc6, &fl6, rt,\r\nMSG_DONTWAIT, &junk);\r\nif (err) {\r\nICMP6_INC_STATS(sock_net(sk), rt->rt6i_idev,\r\nICMP6_MIB_OUTERRORS);\r\nip6_flush_pending_frames(sk);\r\n} else {\r\nerr = icmpv6_push_pending_frames(sk, &fl6,\r\n(struct icmp6hdr *) &pfh.icmph,\r\nlen);\r\n}\r\nrelease_sock(sk);\r\ndst_release(dst);\r\nif (err)\r\nreturn err;\r\nreturn len;\r\n}\r\nstatic void *ping_v6_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nreturn ping_seq_start(seq, pos, AF_INET6);\r\n}\r\nstatic int ping_v6_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, IPV6_SEQ_DGRAM_HEADER);\r\n} else {\r\nint bucket = ((struct ping_iter_state *) seq->private)->bucket;\r\nstruct inet_sock *inet = inet_sk(v);\r\n__u16 srcp = ntohs(inet->inet_sport);\r\n__u16 destp = ntohs(inet->inet_dport);\r\nip6_dgram_sock_seq_show(seq, v, srcp, destp, bucket);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __net_init ping_v6_proc_init_net(struct net *net)\r\n{\r\nreturn ping_proc_register(net, &ping_v6_seq_afinfo);\r\n}\r\nstatic void __net_init ping_v6_proc_exit_net(struct net *net)\r\n{\r\nreturn ping_proc_unregister(net, &ping_v6_seq_afinfo);\r\n}\r\nint __init pingv6_init(void)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nint ret = register_pernet_subsys(&ping_v6_net_ops);\r\nif (ret)\r\nreturn ret;\r\n#endif\r\npingv6_ops.ipv6_recv_error = ipv6_recv_error;\r\npingv6_ops.ip6_datagram_recv_common_ctl = ip6_datagram_recv_common_ctl;\r\npingv6_ops.ip6_datagram_recv_specific_ctl =\r\nip6_datagram_recv_specific_ctl;\r\npingv6_ops.icmpv6_err_convert = icmpv6_err_convert;\r\npingv6_ops.ipv6_icmp_error = ipv6_icmp_error;\r\npingv6_ops.ipv6_chk_addr = ipv6_chk_addr;\r\nreturn inet6_register_protosw(&pingv6_protosw);\r\n}\r\nvoid pingv6_exit(void)\r\n{\r\npingv6_ops.ipv6_recv_error = dummy_ipv6_recv_error;\r\npingv6_ops.ip6_datagram_recv_common_ctl = dummy_ip6_datagram_recv_ctl;\r\npingv6_ops.ip6_datagram_recv_specific_ctl = dummy_ip6_datagram_recv_ctl;\r\npingv6_ops.icmpv6_err_convert = dummy_icmpv6_err_convert;\r\npingv6_ops.ipv6_icmp_error = dummy_ipv6_icmp_error;\r\npingv6_ops.ipv6_chk_addr = dummy_ipv6_chk_addr;\r\n#ifdef CONFIG_PROC_FS\r\nunregister_pernet_subsys(&ping_v6_net_ops);\r\n#endif\r\ninet6_unregister_protosw(&pingv6_protosw);\r\n}
