static int\r\nnv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)\r\n{\r\nunion {\r\nstruct nv50_disp_mthd_v0 v0;\r\nstruct nv50_disp_mthd_v1 v1;\r\n} *args = data;\r\nstruct nv50_disp_root *root = nv50_disp_root(object);\r\nstruct nv50_disp *disp = root->disp;\r\nstruct nvkm_outp *temp, *outp = NULL;\r\nstruct nvkm_head *head;\r\nu16 type, mask = 0;\r\nint hidx, ret = -ENOSYS;\r\nif (mthd != NV50_DISP_MTHD)\r\nreturn -EINVAL;\r\nnvif_ioctl(object, "disp mthd size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\r\nnvif_ioctl(object, "disp mthd vers %d mthd %02x head %d\n",\r\nargs->v0.version, args->v0.method, args->v0.head);\r\nmthd = args->v0.method;\r\nhidx = args->v0.head;\r\n} else\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v1, 1, 1, true))) {\r\nnvif_ioctl(object, "disp mthd vers %d mthd %02x "\r\n"type %04x mask %04x\n",\r\nargs->v1.version, args->v1.method,\r\nargs->v1.hasht, args->v1.hashm);\r\nmthd = args->v1.method;\r\ntype = args->v1.hasht;\r\nmask = args->v1.hashm;\r\nhidx = ffs((mask >> 8) & 0x0f) - 1;\r\n} else\r\nreturn ret;\r\nif (!(head = nvkm_head_find(&disp->base, hidx)))\r\nreturn -ENXIO;\r\nif (mask) {\r\nlist_for_each_entry(temp, &disp->base.outp, head) {\r\nif ((temp->info.hasht == type) &&\r\n(temp->info.hashm & mask) == mask) {\r\noutp = temp;\r\nbreak;\r\n}\r\n}\r\nif (outp == NULL)\r\nreturn -ENXIO;\r\n}\r\nswitch (mthd) {\r\ncase NV50_DISP_SCANOUTPOS: {\r\nreturn nvkm_head_mthd_scanoutpos(object, head, data, size);\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nswitch (mthd * !!outp) {\r\ncase NV50_DISP_MTHD_V1_ACQUIRE: {\r\nunion {\r\nstruct nv50_disp_acquire_v0 v0;\r\n} *args = data;\r\nint ret = -ENOSYS;\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\r\nret = nvkm_outp_acquire(outp, NVKM_OUTP_USER);\r\nif (ret == 0) {\r\nargs->v0.or = outp->ior->id;\r\nargs->v0.link = outp->ior->asy.link;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nbreak;\r\ncase NV50_DISP_MTHD_V1_RELEASE:\r\nnvkm_outp_release(outp, NVKM_OUTP_USER);\r\nreturn 0;\r\ncase NV50_DISP_MTHD_V1_DAC_LOAD: {\r\nunion {\r\nstruct nv50_disp_dac_load_v0 v0;\r\n} *args = data;\r\nint ret = -ENOSYS;\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\r\nif (args->v0.data & 0xfff00000)\r\nreturn -EINVAL;\r\nret = nvkm_outp_acquire(outp, NVKM_OUTP_PRIV);\r\nif (ret)\r\nreturn ret;\r\nret = outp->ior->func->sense(outp->ior, args->v0.data);\r\nnvkm_outp_release(outp, NVKM_OUTP_PRIV);\r\nif (ret < 0)\r\nreturn ret;\r\nargs->v0.load = ret;\r\nreturn 0;\r\n} else\r\nreturn ret;\r\n}\r\nbreak;\r\ncase NV50_DISP_MTHD_V1_SOR_HDA_ELD: {\r\nunion {\r\nstruct nv50_disp_sor_hda_eld_v0 v0;\r\n} *args = data;\r\nstruct nvkm_ior *ior = outp->ior;\r\nint ret = -ENOSYS;\r\nnvif_ioctl(object, "disp sor hda eld size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\r\nnvif_ioctl(object, "disp sor hda eld vers %d\n",\r\nargs->v0.version);\r\nif (size > 0x60)\r\nreturn -E2BIG;\r\n} else\r\nreturn ret;\r\nif (!ior->func->hda.hpd)\r\nreturn -ENODEV;\r\nif (size && args->v0.data[0]) {\r\nif (outp->info.type == DCB_OUTPUT_DP)\r\nior->func->dp.audio(ior, hidx, true);\r\nior->func->hda.hpd(ior, hidx, true);\r\nior->func->hda.eld(ior, data, size);\r\n} else {\r\nif (outp->info.type == DCB_OUTPUT_DP)\r\nior->func->dp.audio(ior, hidx, false);\r\nior->func->hda.hpd(ior, hidx, false);\r\n}\r\nreturn 0;\r\n}\r\nbreak;\r\ncase NV50_DISP_MTHD_V1_SOR_HDMI_PWR: {\r\nunion {\r\nstruct nv50_disp_sor_hdmi_pwr_v0 v0;\r\n} *args = data;\r\nu8 *vendor, vendor_size;\r\nu8 *avi, avi_size;\r\nint ret = -ENOSYS;\r\nnvif_ioctl(object, "disp sor hdmi ctrl size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\r\nnvif_ioctl(object, "disp sor hdmi ctrl vers %d state %d "\r\n"max_ac_packet %d rekey %d\n",\r\nargs->v0.version, args->v0.state,\r\nargs->v0.max_ac_packet, args->v0.rekey);\r\nif (args->v0.max_ac_packet > 0x1f || args->v0.rekey > 0x7f)\r\nreturn -EINVAL;\r\nif ((args->v0.avi_infoframe_length\r\n+ args->v0.vendor_infoframe_length) > size)\r\nreturn -EINVAL;\r\nelse\r\nif ((args->v0.avi_infoframe_length\r\n+ args->v0.vendor_infoframe_length) < size)\r\nreturn -E2BIG;\r\navi = data;\r\navi_size = args->v0.avi_infoframe_length;\r\nvendor = avi + avi_size;\r\nvendor_size = args->v0.vendor_infoframe_length;\r\n} else\r\nreturn ret;\r\nif (!outp->ior->func->hdmi.ctrl)\r\nreturn -ENODEV;\r\noutp->ior->func->hdmi.ctrl(outp->ior, hidx, args->v0.state,\r\nargs->v0.max_ac_packet,\r\nargs->v0.rekey, avi, avi_size,\r\nvendor, vendor_size);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase NV50_DISP_MTHD_V1_SOR_LVDS_SCRIPT: {\r\nunion {\r\nstruct nv50_disp_sor_lvds_script_v0 v0;\r\n} *args = data;\r\nint ret = -ENOSYS;\r\nnvif_ioctl(object, "disp sor lvds script size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\r\nnvif_ioctl(object, "disp sor lvds script "\r\n"vers %d name %04x\n",\r\nargs->v0.version, args->v0.script);\r\ndisp->sor.lvdsconf = args->v0.script;\r\nreturn 0;\r\n} else\r\nreturn ret;\r\n}\r\nbreak;\r\ncase NV50_DISP_MTHD_V1_SOR_DP_MST_LINK: {\r\nstruct nvkm_dp *dp = nvkm_dp(outp);\r\nunion {\r\nstruct nv50_disp_sor_dp_mst_link_v0 v0;\r\n} *args = data;\r\nint ret = -ENOSYS;\r\nnvif_ioctl(object, "disp sor dp mst link size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\r\nnvif_ioctl(object, "disp sor dp mst link vers %d state %d\n",\r\nargs->v0.version, args->v0.state);\r\ndp->lt.mst = !!args->v0.state;\r\nreturn 0;\r\n} else\r\nreturn ret;\r\n}\r\nbreak;\r\ncase NV50_DISP_MTHD_V1_SOR_DP_MST_VCPI: {\r\nunion {\r\nstruct nv50_disp_sor_dp_mst_vcpi_v0 v0;\r\n} *args = data;\r\nint ret = -ENOSYS;\r\nnvif_ioctl(object, "disp sor dp mst vcpi size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\r\nnvif_ioctl(object, "disp sor dp mst vcpi vers %d "\r\n"slot %02x/%02x pbn %04x/%04x\n",\r\nargs->v0.version, args->v0.start_slot,\r\nargs->v0.num_slots, args->v0.pbn,\r\nargs->v0.aligned_pbn);\r\nif (!outp->ior->func->dp.vcpi)\r\nreturn -ENODEV;\r\noutp->ior->func->dp.vcpi(outp->ior, hidx,\r\nargs->v0.start_slot,\r\nargs->v0.num_slots,\r\nargs->v0.pbn,\r\nargs->v0.aligned_pbn);\r\nreturn 0;\r\n} else\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nnv50_disp_root_dmac_new_(const struct nvkm_oclass *oclass,\r\nvoid *data, u32 size, struct nvkm_object **pobject)\r\n{\r\nconst struct nv50_disp_dmac_oclass *sclass = oclass->priv;\r\nstruct nv50_disp_root *root = nv50_disp_root(oclass->parent);\r\nreturn sclass->ctor(sclass->func, sclass->mthd, root, sclass->chid,\r\noclass, data, size, pobject);\r\n}\r\nstatic int\r\nnv50_disp_root_pioc_new_(const struct nvkm_oclass *oclass,\r\nvoid *data, u32 size, struct nvkm_object **pobject)\r\n{\r\nconst struct nv50_disp_pioc_oclass *sclass = oclass->priv;\r\nstruct nv50_disp_root *root = nv50_disp_root(oclass->parent);\r\nreturn sclass->ctor(sclass->func, sclass->mthd, root, sclass->chid.ctrl,\r\nsclass->chid.user, oclass, data, size, pobject);\r\n}\r\nstatic int\r\nnv50_disp_root_child_get_(struct nvkm_object *object, int index,\r\nstruct nvkm_oclass *sclass)\r\n{\r\nstruct nv50_disp_root *root = nv50_disp_root(object);\r\nif (index < ARRAY_SIZE(root->func->dmac)) {\r\nsclass->base = root->func->dmac[index]->base;\r\nsclass->priv = root->func->dmac[index];\r\nsclass->ctor = nv50_disp_root_dmac_new_;\r\nreturn 0;\r\n}\r\nindex -= ARRAY_SIZE(root->func->dmac);\r\nif (index < ARRAY_SIZE(root->func->pioc)) {\r\nsclass->base = root->func->pioc[index]->base;\r\nsclass->priv = root->func->pioc[index];\r\nsclass->ctor = nv50_disp_root_pioc_new_;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nnv50_disp_root_fini_(struct nvkm_object *object, bool suspend)\r\n{\r\nstruct nv50_disp_root *root = nv50_disp_root(object);\r\nroot->func->fini(root);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_disp_root_init_(struct nvkm_object *object)\r\n{\r\nstruct nv50_disp_root *root = nv50_disp_root(object);\r\nstruct nvkm_ior *ior;\r\nint ret;\r\nret = root->func->init(root);\r\nif (ret)\r\nreturn ret;\r\nlist_for_each_entry(ior, &root->disp->base.ior, head) {\r\nior->func->power(ior, true, true, true, true, true);\r\n}\r\nreturn 0;\r\n}\r\nstatic void *\r\nnv50_disp_root_dtor_(struct nvkm_object *object)\r\n{\r\nstruct nv50_disp_root *root = nv50_disp_root(object);\r\nnvkm_ramht_del(&root->ramht);\r\nnvkm_gpuobj_del(&root->instmem);\r\nreturn root;\r\n}\r\nint\r\nnv50_disp_root_new_(const struct nv50_disp_root_func *func,\r\nstruct nvkm_disp *base, const struct nvkm_oclass *oclass,\r\nvoid *data, u32 size, struct nvkm_object **pobject)\r\n{\r\nstruct nv50_disp *disp = nv50_disp(base);\r\nstruct nv50_disp_root *root;\r\nstruct nvkm_device *device = disp->base.engine.subdev.device;\r\nint ret;\r\nif (!(root = kzalloc(sizeof(*root), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*pobject = &root->object;\r\nnvkm_object_ctor(&nv50_disp_root_, oclass, &root->object);\r\nroot->func = func;\r\nroot->disp = disp;\r\nret = nvkm_gpuobj_new(disp->base.engine.subdev.device, 0x10000, 0x10000,\r\nfalse, NULL, &root->instmem);\r\nif (ret)\r\nreturn ret;\r\nreturn nvkm_ramht_new(device, 0x1000, 0, root->instmem, &root->ramht);\r\n}\r\nvoid\r\nnv50_disp_root_fini(struct nv50_disp_root *root)\r\n{\r\nstruct nvkm_device *device = root->disp->base.engine.subdev.device;\r\nnvkm_wr32(device, 0x610024, 0x00000000);\r\nnvkm_wr32(device, 0x610020, 0x00000000);\r\n}\r\nint\r\nnv50_disp_root_init(struct nv50_disp_root *root)\r\n{\r\nstruct nv50_disp *disp = root->disp;\r\nstruct nvkm_head *head;\r\nstruct nvkm_device *device = disp->base.engine.subdev.device;\r\nu32 tmp;\r\nint i;\r\ntmp = nvkm_rd32(device, 0x614004);\r\nnvkm_wr32(device, 0x610184, tmp);\r\nlist_for_each_entry(head, &disp->base.head, head) {\r\ntmp = nvkm_rd32(device, 0x616100 + (head->id * 0x800));\r\nnvkm_wr32(device, 0x610190 + (head->id * 0x10), tmp);\r\ntmp = nvkm_rd32(device, 0x616104 + (head->id * 0x800));\r\nnvkm_wr32(device, 0x610194 + (head->id * 0x10), tmp);\r\ntmp = nvkm_rd32(device, 0x616108 + (head->id * 0x800));\r\nnvkm_wr32(device, 0x610198 + (head->id * 0x10), tmp);\r\ntmp = nvkm_rd32(device, 0x61610c + (head->id * 0x800));\r\nnvkm_wr32(device, 0x61019c + (head->id * 0x10), tmp);\r\n}\r\nfor (i = 0; i < disp->func->dac.nr; i++) {\r\ntmp = nvkm_rd32(device, 0x61a000 + (i * 0x800));\r\nnvkm_wr32(device, 0x6101d0 + (i * 0x04), tmp);\r\n}\r\nfor (i = 0; i < disp->func->sor.nr; i++) {\r\ntmp = nvkm_rd32(device, 0x61c000 + (i * 0x800));\r\nnvkm_wr32(device, 0x6101e0 + (i * 0x04), tmp);\r\n}\r\nfor (i = 0; i < disp->func->pior.nr; i++) {\r\ntmp = nvkm_rd32(device, 0x61e000 + (i * 0x800));\r\nnvkm_wr32(device, 0x6101f0 + (i * 0x04), tmp);\r\n}\r\nif (nvkm_rd32(device, 0x610024) & 0x00000100) {\r\nnvkm_wr32(device, 0x610024, 0x00000100);\r\nnvkm_mask(device, 0x6194e8, 0x00000001, 0x00000000);\r\nif (nvkm_msec(device, 2000,\r\nif (!(nvkm_rd32(device, 0x6194e8) & 0x00000002))\r\nbreak;\r\n) < 0)\r\nreturn -EBUSY;\r\n}\r\nnvkm_wr32(device, 0x610010, (root->instmem->addr >> 8) | 9);\r\nnvkm_wr32(device, 0x61002c, 0x00000370);\r\nnvkm_wr32(device, 0x610028, 0x00000000);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_disp_root_new(struct nvkm_disp *disp, const struct nvkm_oclass *oclass,\r\nvoid *data, u32 size, struct nvkm_object **pobject)\r\n{\r\nreturn nv50_disp_root_new_(&nv50_disp_root, disp, oclass,\r\ndata, size, pobject);\r\n}
