static int lynxfb_ops_cursor(struct fb_info *info, struct fb_cursor *fbcursor)\r\n{\r\nstruct lynxfb_par *par;\r\nstruct lynxfb_crtc *crtc;\r\nstruct lynx_cursor *cursor;\r\npar = info->par;\r\ncrtc = &par->crtc;\r\ncursor = &crtc->cursor;\r\nif (fbcursor->image.width > cursor->maxW ||\r\nfbcursor->image.height > cursor->maxH ||\r\nfbcursor->image.depth > 1) {\r\nreturn -ENXIO;\r\n}\r\nsm750_hw_cursor_disable(cursor);\r\nif (fbcursor->set & FB_CUR_SETSIZE)\r\nsm750_hw_cursor_setSize(cursor,\r\nfbcursor->image.width,\r\nfbcursor->image.height);\r\nif (fbcursor->set & FB_CUR_SETPOS)\r\nsm750_hw_cursor_setPos(cursor,\r\nfbcursor->image.dx - info->var.xoffset,\r\nfbcursor->image.dy - info->var.yoffset);\r\nif (fbcursor->set & FB_CUR_SETCMAP) {\r\nu16 fg, bg;\r\nfg = ((info->cmap.red[fbcursor->image.fg_color] & 0xf800)) |\r\n((info->cmap.green[fbcursor->image.fg_color] & 0xfc00) >> 5) |\r\n((info->cmap.blue[fbcursor->image.fg_color] & 0xf800) >> 11);\r\nbg = ((info->cmap.red[fbcursor->image.bg_color] & 0xf800)) |\r\n((info->cmap.green[fbcursor->image.bg_color] & 0xfc00) >> 5) |\r\n((info->cmap.blue[fbcursor->image.bg_color] & 0xf800) >> 11);\r\nsm750_hw_cursor_setColor(cursor, fg, bg);\r\n}\r\nif (fbcursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETIMAGE)) {\r\nsm750_hw_cursor_setData(cursor,\r\nfbcursor->rop,\r\nfbcursor->image.data,\r\nfbcursor->mask);\r\n}\r\nif (fbcursor->enable)\r\nsm750_hw_cursor_enable(cursor);\r\nreturn 0;\r\n}\r\nstatic void lynxfb_ops_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *region)\r\n{\r\nstruct lynxfb_par *par;\r\nstruct sm750_dev *sm750_dev;\r\nunsigned int base, pitch, Bpp, rop;\r\nu32 color;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\npar = info->par;\r\nsm750_dev = par->dev;\r\nbase = par->crtc.oScreen;\r\npitch = info->fix.line_length;\r\nBpp = info->var.bits_per_pixel >> 3;\r\ncolor = (Bpp == 1) ? region->color :\r\n((u32 *)info->pseudo_palette)[region->color];\r\nrop = (region->rop != ROP_COPY) ? HW_ROP2_XOR : HW_ROP2_COPY;\r\nspin_lock(&sm750_dev->slock);\r\nsm750_dev->accel.de_fillrect(&sm750_dev->accel,\r\nbase, pitch, Bpp,\r\nregion->dx, region->dy,\r\nregion->width, region->height,\r\ncolor, rop);\r\nspin_unlock(&sm750_dev->slock);\r\n}\r\nstatic void lynxfb_ops_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *region)\r\n{\r\nstruct lynxfb_par *par;\r\nstruct sm750_dev *sm750_dev;\r\nunsigned int base, pitch, Bpp;\r\npar = info->par;\r\nsm750_dev = par->dev;\r\nbase = par->crtc.oScreen;\r\npitch = info->fix.line_length;\r\nBpp = info->var.bits_per_pixel >> 3;\r\nspin_lock(&sm750_dev->slock);\r\nsm750_dev->accel.de_copyarea(&sm750_dev->accel,\r\nbase, pitch, region->sx, region->sy,\r\nbase, pitch, Bpp, region->dx, region->dy,\r\nregion->width, region->height,\r\nHW_ROP2_COPY);\r\nspin_unlock(&sm750_dev->slock);\r\n}\r\nstatic void lynxfb_ops_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nunsigned int base, pitch, Bpp;\r\nunsigned int fgcol, bgcol;\r\nstruct lynxfb_par *par;\r\nstruct sm750_dev *sm750_dev;\r\npar = info->par;\r\nsm750_dev = par->dev;\r\nbase = par->crtc.oScreen;\r\npitch = info->fix.line_length;\r\nBpp = info->var.bits_per_pixel >> 3;\r\nif (image->depth != 1) {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\r\ninfo->fix.visual == FB_VISUAL_DIRECTCOLOR) {\r\nfgcol = ((u32 *)info->pseudo_palette)[image->fg_color];\r\nbgcol = ((u32 *)info->pseudo_palette)[image->bg_color];\r\n} else {\r\nfgcol = image->fg_color;\r\nbgcol = image->bg_color;\r\n}\r\nspin_lock(&sm750_dev->slock);\r\nsm750_dev->accel.de_imageblit(&sm750_dev->accel,\r\nimage->data, image->width >> 3, 0,\r\nbase, pitch, Bpp,\r\nimage->dx, image->dy,\r\nimage->width, image->height,\r\nfgcol, bgcol, HW_ROP2_COPY);\r\nspin_unlock(&sm750_dev->slock);\r\n}\r\nstatic int lynxfb_ops_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct lynxfb_par *par;\r\nstruct lynxfb_crtc *crtc;\r\nif (!info)\r\nreturn -EINVAL;\r\npar = info->par;\r\ncrtc = &par->crtc;\r\nreturn hw_sm750_pan_display(crtc, var, info);\r\n}\r\nstatic int lynxfb_ops_set_par(struct fb_info *info)\r\n{\r\nstruct lynxfb_par *par;\r\nstruct lynxfb_crtc *crtc;\r\nstruct lynxfb_output *output;\r\nstruct fb_var_screeninfo *var;\r\nstruct fb_fix_screeninfo *fix;\r\nint ret;\r\nunsigned int line_length;\r\nif (!info)\r\nreturn -EINVAL;\r\nret = 0;\r\npar = info->par;\r\ncrtc = &par->crtc;\r\noutput = &par->output;\r\nvar = &info->var;\r\nfix = &info->fix;\r\nline_length = var->xres_virtual * var->bits_per_pixel / 8;\r\nline_length = ALIGN(line_length, crtc->line_pad);\r\nfix->line_length = line_length;\r\npr_info("fix->line_length = %d\n", fix->line_length);\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nvar->height = var->width = -1;\r\nvar->accel_flags = 0;\r\nif (ret) {\r\npr_err("pixel bpp format not satisfied\n.");\r\nreturn ret;\r\n}\r\nret = hw_sm750_crtc_setMode(crtc, var, fix);\r\nif (!ret)\r\nret = hw_sm750_output_setMode(output, var, fix);\r\nreturn ret;\r\n}\r\nstatic inline unsigned int chan_to_field(unsigned int chan,\r\nstruct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int lynxfb_suspend(struct pci_dev *pdev, pm_message_t mesg)\r\n{\r\nstruct fb_info *info;\r\nstruct sm750_dev *sm750_dev;\r\nint ret;\r\nif (mesg.event == pdev->dev.power.power_state.event)\r\nreturn 0;\r\nret = 0;\r\nsm750_dev = pci_get_drvdata(pdev);\r\nswitch (mesg.event) {\r\ncase PM_EVENT_FREEZE:\r\ncase PM_EVENT_PRETHAW:\r\npdev->dev.power.power_state = mesg;\r\nreturn 0;\r\n}\r\nconsole_lock();\r\nif (mesg.event & PM_EVENT_SLEEP) {\r\ninfo = sm750_dev->fbinfo[0];\r\nif (info)\r\nfb_set_suspend(info, 1);\r\ninfo = sm750_dev->fbinfo[1];\r\nif (info)\r\nfb_set_suspend(info, 1);\r\nret = pci_save_state(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"error:%d occurred in pci_save_state\n", ret);\r\ngoto lynxfb_suspend_err;\r\n}\r\nret = pci_set_power_state(pdev, pci_choose_state(pdev, mesg));\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"error:%d occurred in pci_set_power_state\n",\r\nret);\r\ngoto lynxfb_suspend_err;\r\n}\r\n}\r\npdev->dev.power.power_state = mesg;\r\nlynxfb_suspend_err:\r\nconsole_unlock();\r\nreturn ret;\r\n}\r\nstatic int lynxfb_resume(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *info;\r\nstruct sm750_dev *sm750_dev;\r\nstruct lynxfb_par *par;\r\nstruct lynxfb_crtc *crtc;\r\nstruct lynx_cursor *cursor;\r\nint ret;\r\nret = 0;\r\nsm750_dev = pci_get_drvdata(pdev);\r\nconsole_lock();\r\nret = pci_set_power_state(pdev, PCI_D0);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"error:%d occurred in pci_set_power_state\n", ret);\r\ngoto lynxfb_resume_err;\r\n}\r\nif (pdev->dev.power.power_state.event != PM_EVENT_FREEZE) {\r\npci_restore_state(pdev);\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"error:%d occurred in pci_enable_device\n",\r\nret);\r\ngoto lynxfb_resume_err;\r\n}\r\npci_set_master(pdev);\r\n}\r\nhw_sm750_inithw(sm750_dev, pdev);\r\ninfo = sm750_dev->fbinfo[0];\r\nif (info) {\r\npar = info->par;\r\ncrtc = &par->crtc;\r\ncursor = &crtc->cursor;\r\nmemset_io(cursor->vstart, 0x0, cursor->size);\r\nmemset_io(crtc->vScreen, 0x0, crtc->vidmem_size);\r\nlynxfb_ops_set_par(info);\r\nfb_set_suspend(info, 0);\r\n}\r\ninfo = sm750_dev->fbinfo[1];\r\nif (info) {\r\npar = info->par;\r\ncrtc = &par->crtc;\r\ncursor = &crtc->cursor;\r\nmemset_io(cursor->vstart, 0x0, cursor->size);\r\nmemset_io(crtc->vScreen, 0x0, crtc->vidmem_size);\r\nlynxfb_ops_set_par(info);\r\nfb_set_suspend(info, 0);\r\n}\r\npdev->dev.power.power_state.event = PM_EVENT_RESUME;\r\nlynxfb_resume_err:\r\nconsole_unlock();\r\nreturn ret;\r\n}\r\nstatic int lynxfb_ops_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct lynxfb_par *par;\r\nstruct lynxfb_crtc *crtc;\r\nstruct lynxfb_output *output;\r\nresource_size_t request;\r\npar = info->par;\r\ncrtc = &par->crtc;\r\noutput = &par->output;\r\npr_debug("check var:%dx%d-%d\n",\r\nvar->xres,\r\nvar->yres,\r\nvar->bits_per_pixel);\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\ndefault:\r\npr_err("bpp %d not supported\n", var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nvar->height = var->width = -1;\r\nvar->accel_flags = 0;\r\nrequest = var->xres_virtual * (var->bits_per_pixel >> 3);\r\nrequest = ALIGN(request, crtc->line_pad);\r\nrequest = request * var->yres_virtual;\r\nif (crtc->vidmem_size < request) {\r\npr_err("not enough video memory for mode\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn hw_sm750_crtc_checkMode(crtc, var);\r\n}\r\nstatic int lynxfb_ops_setcolreg(unsigned int regno,\r\nunsigned int red,\r\nunsigned int green,\r\nunsigned int blue,\r\nunsigned int transp,\r\nstruct fb_info *info)\r\n{\r\nstruct lynxfb_par *par;\r\nstruct lynxfb_crtc *crtc;\r\nstruct fb_var_screeninfo *var;\r\nint ret;\r\npar = info->par;\r\ncrtc = &par->crtc;\r\nvar = &info->var;\r\nret = 0;\r\nif (regno > 256) {\r\npr_err("regno = %d\n", regno);\r\nreturn -EINVAL;\r\n}\r\nif (info->var.grayscale)\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\nif (var->bits_per_pixel == 8 &&\r\ninfo->fix.visual == FB_VISUAL_PSEUDOCOLOR) {\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nret = hw_sm750_setColReg(crtc, regno, red, green, blue);\r\ngoto exit;\r\n}\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < 256) {\r\nu32 val;\r\nif (var->bits_per_pixel == 16 ||\r\nvar->bits_per_pixel == 32 ||\r\nvar->bits_per_pixel == 24) {\r\nval = chan_to_field(red, &var->red);\r\nval |= chan_to_field(green, &var->green);\r\nval |= chan_to_field(blue, &var->blue);\r\npar->pseudo_palette[regno] = val;\r\ngoto exit;\r\n}\r\n}\r\nret = -EINVAL;\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int lynxfb_ops_blank(int blank, struct fb_info *info)\r\n{\r\nstruct lynxfb_par *par;\r\nstruct lynxfb_output *output;\r\npr_debug("blank = %d.\n", blank);\r\npar = info->par;\r\noutput = &par->output;\r\nreturn output->proc_setBLANK(output, blank);\r\n}\r\nstatic int sm750fb_set_drv(struct lynxfb_par *par)\r\n{\r\nint ret;\r\nstruct sm750_dev *sm750_dev;\r\nstruct lynxfb_output *output;\r\nstruct lynxfb_crtc *crtc;\r\nret = 0;\r\nsm750_dev = par->dev;\r\noutput = &par->output;\r\ncrtc = &par->crtc;\r\ncrtc->vidmem_size = sm750_dev->vidmem_size;\r\nif (sm750_dev->fb_count > 1)\r\ncrtc->vidmem_size >>= 1;\r\nsm750_dev->hwCursor = g_hwcursor;\r\ncrtc->line_pad = 16;\r\ncrtc->xpanstep = 8;\r\ncrtc->ypanstep = 1;\r\ncrtc->ywrapstep = 0;\r\noutput->proc_setBLANK = (sm750_dev->revid == SM750LE_REVISION_ID) ?\r\nhw_sm750le_setBLANK : hw_sm750_setBLANK;\r\nsm750_dev->accel.de_wait = (sm750_dev->revid == SM750LE_REVISION_ID) ?\r\nhw_sm750le_deWait : hw_sm750_deWait;\r\nswitch (sm750_dev->dataflow) {\r\ncase sm750_simul_pri:\r\noutput->paths = sm750_pnc;\r\ncrtc->channel = sm750_primary;\r\ncrtc->oScreen = 0;\r\ncrtc->vScreen = sm750_dev->pvMem;\r\npr_info("use simul primary mode\n");\r\nbreak;\r\ncase sm750_simul_sec:\r\noutput->paths = sm750_pnc;\r\ncrtc->channel = sm750_secondary;\r\ncrtc->oScreen = 0;\r\ncrtc->vScreen = sm750_dev->pvMem;\r\nbreak;\r\ncase sm750_dual_normal:\r\nif (par->index == 0) {\r\noutput->paths = sm750_panel;\r\ncrtc->channel = sm750_primary;\r\ncrtc->oScreen = 0;\r\ncrtc->vScreen = sm750_dev->pvMem;\r\n} else {\r\noutput->paths = sm750_crt;\r\ncrtc->channel = sm750_secondary;\r\ncrtc->oScreen = (sm750_dev->vidmem_size >> 1);\r\ncrtc->vScreen = sm750_dev->pvMem + crtc->oScreen;\r\n}\r\nbreak;\r\ncase sm750_dual_swap:\r\nif (par->index == 0) {\r\noutput->paths = sm750_panel;\r\ncrtc->channel = sm750_secondary;\r\ncrtc->oScreen = 0;\r\ncrtc->vScreen = sm750_dev->pvMem;\r\n} else {\r\noutput->paths = sm750_crt;\r\ncrtc->channel = sm750_primary;\r\ncrtc->oScreen = (sm750_dev->vidmem_size >> 1);\r\ncrtc->vScreen = sm750_dev->pvMem + crtc->oScreen;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int lynxfb_set_fbinfo(struct fb_info *info, int index)\r\n{\r\nint i;\r\nstruct lynxfb_par *par;\r\nstruct sm750_dev *sm750_dev;\r\nstruct lynxfb_crtc *crtc;\r\nstruct lynxfb_output *output;\r\nstruct fb_var_screeninfo *var;\r\nstruct fb_fix_screeninfo *fix;\r\nconst struct fb_videomode *pdb[] = {\r\nlynx750_ext, NULL, vesa_modes,\r\n};\r\nint cdb[] = {ARRAY_SIZE(lynx750_ext), 0, VESA_MODEDB_SIZE};\r\nstatic const char *mdb_desc[] = {\r\n"driver prepared modes",\r\n"kernel prepared default modedb",\r\n"kernel HELPERS prepared vesa_modes",\r\n};\r\nstatic const char *fixId[2] = {\r\n"sm750_fb1", "sm750_fb2",\r\n};\r\nint ret, line_length;\r\nret = 0;\r\npar = (struct lynxfb_par *)info->par;\r\nsm750_dev = par->dev;\r\ncrtc = &par->crtc;\r\noutput = &par->output;\r\nvar = &info->var;\r\nfix = &info->fix;\r\npar->index = index;\r\noutput->channel = &crtc->channel;\r\nsm750fb_set_drv(par);\r\nlynxfb_ops.fb_pan_display = lynxfb_ops_pan_display;\r\ncrtc->cursor.offset = crtc->oScreen + crtc->vidmem_size - 1024;\r\ncrtc->cursor.mmio = sm750_dev->pvReg +\r\n0x800f0 + (int)crtc->channel * 0x140;\r\npr_info("crtc->cursor.mmio = %p\n", crtc->cursor.mmio);\r\ncrtc->cursor.maxH = crtc->cursor.maxW = 64;\r\ncrtc->cursor.size = crtc->cursor.maxH * crtc->cursor.maxW * 2 / 8;\r\ncrtc->cursor.vstart = sm750_dev->pvMem + crtc->cursor.offset;\r\nmemset_io(crtc->cursor.vstart, 0, crtc->cursor.size);\r\nif (!g_hwcursor) {\r\nlynxfb_ops.fb_cursor = NULL;\r\nsm750_hw_cursor_disable(&crtc->cursor);\r\n}\r\nif (!sm750_dev->accel_off) {\r\nlynxfb_ops.fb_fillrect = lynxfb_ops_fillrect;\r\nlynxfb_ops.fb_copyarea = lynxfb_ops_copyarea;\r\nlynxfb_ops.fb_imageblit = lynxfb_ops_imageblit;\r\n}\r\ninfo->fbops = &lynxfb_ops;\r\nif (!g_fbmode[index]) {\r\ng_fbmode[index] = g_def_fbmode;\r\nif (index)\r\ng_fbmode[index] = g_fbmode[0];\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nret = fb_find_mode(var, info, g_fbmode[index],\r\npdb[i], cdb[i], NULL, 8);\r\nif (ret == 1) {\r\npr_info("success! use specified mode:%s in %s\n",\r\ng_fbmode[index],\r\nmdb_desc[i]);\r\nbreak;\r\n} else if (ret == 2) {\r\npr_warn("use specified mode:%s in %s,with an ignored refresh rate\n",\r\ng_fbmode[index],\r\nmdb_desc[i]);\r\nbreak;\r\n} else if (ret == 3) {\r\npr_warn("wanna use default mode\n");\r\n} else if (ret == 4) {\r\npr_warn("fall back to any valid mode\n");\r\n} else {\r\npr_warn("ret = %d,fb_find_mode failed,with %s\n",\r\nret,\r\nmdb_desc[i]);\r\n}\r\n}\r\npr_info("Member of info->var is :\n"\r\n"xres=%d\n"\r\n"yres=%d\n"\r\n"xres_virtual=%d\n"\r\n"yres_virtual=%d\n"\r\n"xoffset=%d\n"\r\n"yoffset=%d\n"\r\n"bits_per_pixel=%d\n"\r\n" ...\n",\r\nvar->xres,\r\nvar->yres,\r\nvar->xres_virtual,\r\nvar->yres_virtual,\r\nvar->xoffset,\r\nvar->yoffset,\r\nvar->bits_per_pixel);\r\npar->info = info;\r\nline_length = ALIGN((var->xres_virtual * var->bits_per_pixel / 8),\r\ncrtc->line_pad);\r\ninfo->pseudo_palette = &par->pseudo_palette[0];\r\ninfo->screen_base = crtc->vScreen;\r\npr_debug("screen_base vaddr = %p\n", info->screen_base);\r\ninfo->screen_size = line_length * var->yres_virtual;\r\ninfo->flags = FBINFO_FLAG_DEFAULT | 0;\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->type_aux = 0;\r\nfix->xpanstep = crtc->xpanstep;\r\nfix->ypanstep = crtc->ypanstep;\r\nfix->ywrapstep = crtc->ywrapstep;\r\nfix->accel = FB_ACCEL_SMI;\r\nstrlcpy(fix->id, fixId[index], sizeof(fix->id));\r\nfix->smem_start = crtc->oScreen + sm750_dev->vidmem_start;\r\npr_info("fix->smem_start = %lx\n", fix->smem_start);\r\nfix->smem_len = crtc->vidmem_size;\r\npr_info("fix->smem_len = %x\n", fix->smem_len);\r\ninfo->screen_size = fix->smem_len;\r\nfix->line_length = line_length;\r\nfix->mmio_start = sm750_dev->vidreg_start;\r\npr_info("fix->mmio_start = %lx\n", fix->mmio_start);\r\nfix->mmio_len = sm750_dev->vidreg_size;\r\npr_info("fix->mmio_len = %x\n", fix->mmio_len);\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nbreak;\r\ncase 16:\r\ncase 32:\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\n}\r\nvar->activate = FB_ACTIVATE_NOW;\r\nvar->accel_flags = 0;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\npr_debug("#1 show info->cmap :\nstart=%d,len=%d,red=%p,green=%p,blue=%p,transp=%p\n",\r\ninfo->cmap.start, info->cmap.len,\r\ninfo->cmap.red, info->cmap.green, info->cmap.blue,\r\ninfo->cmap.transp);\r\nret = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (ret < 0) {\r\npr_err("Could not allocate memory for cmap.\n");\r\ngoto exit;\r\n}\r\npr_debug("#2 show info->cmap :\nstart=%d,len=%d,red=%p,green=%p,blue=%p,transp=%p\n",\r\ninfo->cmap.start, info->cmap.len,\r\ninfo->cmap.red, info->cmap.green, info->cmap.blue,\r\ninfo->cmap.transp);\r\nexit:\r\nlynxfb_ops_check_var(var, info);\r\nreturn ret;\r\n}\r\nstatic void sm750fb_setup(struct sm750_dev *sm750_dev, char *src)\r\n{\r\nchar *opt;\r\nint swap;\r\nswap = 0;\r\nsm750_dev->initParm.chip_clk = 0;\r\nsm750_dev->initParm.mem_clk = 0;\r\nsm750_dev->initParm.master_clk = 0;\r\nsm750_dev->initParm.powerMode = 0;\r\nsm750_dev->initParm.setAllEngOff = 0;\r\nsm750_dev->initParm.resetMemory = 1;\r\ng_hwcursor = 3;\r\nif (!src || !*src) {\r\ndev_warn(&sm750_dev->pdev->dev, "no specific g_option.\n");\r\ngoto NO_PARAM;\r\n}\r\nwhile ((opt = strsep(&src, ":")) != NULL && *opt != 0) {\r\ndev_info(&sm750_dev->pdev->dev, "opt=%s\n", opt);\r\ndev_info(&sm750_dev->pdev->dev, "src=%s\n", src);\r\nif (!strncmp(opt, "swap", strlen("swap"))) {\r\nswap = 1;\r\n} else if (!strncmp(opt, "nocrt", strlen("nocrt"))) {\r\nsm750_dev->nocrt = 1;\r\n} else if (!strncmp(opt, "36bit", strlen("36bit"))) {\r\nsm750_dev->pnltype = sm750_doubleTFT;\r\n} else if (!strncmp(opt, "18bit", strlen("18bit"))) {\r\nsm750_dev->pnltype = sm750_dualTFT;\r\n} else if (!strncmp(opt, "24bit", strlen("24bit"))) {\r\nsm750_dev->pnltype = sm750_24TFT;\r\n} else if (!strncmp(opt, "nohwc0", strlen("nohwc0"))) {\r\ng_hwcursor &= ~0x1;\r\n} else if (!strncmp(opt, "nohwc1", strlen("nohwc1"))) {\r\ng_hwcursor &= ~0x2;\r\n} else if (!strncmp(opt, "nohwc", strlen("nohwc"))) {\r\ng_hwcursor = 0;\r\n} else {\r\nif (!g_fbmode[0]) {\r\ng_fbmode[0] = opt;\r\ndev_info(&sm750_dev->pdev->dev,\r\n"find fbmode0 : %s\n", g_fbmode[0]);\r\n} else if (!g_fbmode[1]) {\r\ng_fbmode[1] = opt;\r\ndev_info(&sm750_dev->pdev->dev,\r\n"find fbmode1 : %s\n", g_fbmode[1]);\r\n} else {\r\ndev_warn(&sm750_dev->pdev->dev, "How many view you wann set?\n");\r\n}\r\n}\r\n}\r\nNO_PARAM:\r\nif (sm750_dev->revid != SM750LE_REVISION_ID) {\r\nif (sm750_dev->fb_count > 1) {\r\nif (swap)\r\nsm750_dev->dataflow = sm750_dual_swap;\r\nelse\r\nsm750_dev->dataflow = sm750_dual_normal;\r\n} else {\r\nif (swap)\r\nsm750_dev->dataflow = sm750_simul_sec;\r\nelse\r\nsm750_dev->dataflow = sm750_simul_pri;\r\n}\r\n} else {\r\nsm750_dev->dataflow = sm750_simul_sec;\r\nsm750_dev->nocrt = 0;\r\n}\r\n}\r\nstatic void sm750fb_frambuffer_release(struct sm750_dev *sm750_dev)\r\n{\r\nstruct fb_info *fb_info;\r\nwhile (sm750_dev->fb_count) {\r\nfb_info = sm750_dev->fbinfo[sm750_dev->fb_count - 1];\r\nunregister_framebuffer(fb_info);\r\nframebuffer_release(fb_info);\r\nsm750_dev->fb_count--;\r\n}\r\n}\r\nstatic int sm750fb_frambuffer_alloc(struct sm750_dev *sm750_dev, int fbidx)\r\n{\r\nstruct fb_info *fb_info;\r\nstruct lynxfb_par *par;\r\nint err;\r\nfb_info = framebuffer_alloc(sizeof(struct lynxfb_par),\r\n&sm750_dev->pdev->dev);\r\nif (!fb_info)\r\nreturn -ENOMEM;\r\nsm750_dev->fbinfo[fbidx] = fb_info;\r\npar = fb_info->par;\r\npar->dev = sm750_dev;\r\nerr = lynxfb_set_fbinfo(fb_info, fbidx);\r\nif (err)\r\ngoto release_fb;\r\nerr = register_framebuffer(fb_info);\r\nif (err < 0)\r\ngoto release_fb;\r\nsm750_dev->fb_count++;\r\nreturn 0;\r\nrelease_fb:\r\nframebuffer_release(fb_info);\r\nreturn err;\r\n}\r\nstatic int lynxfb_kick_out_firmware_fb(struct pci_dev *pdev)\r\n{\r\nstruct apertures_struct *ap;\r\nbool primary = false;\r\nap = alloc_apertures(1);\r\nif (!ap)\r\nreturn -ENOMEM;\r\nap->ranges[0].base = pci_resource_start(pdev, 0);\r\nap->ranges[0].size = pci_resource_len(pdev, 0);\r\n#ifdef CONFIG_X86\r\nprimary = pdev->resource[PCI_ROM_RESOURCE].flags &\r\nIORESOURCE_ROM_SHADOW;\r\n#endif\r\nremove_conflicting_framebuffers(ap, "sm750_fb1", primary);\r\nkfree(ap);\r\nreturn 0;\r\n}\r\nstatic int lynxfb_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct sm750_dev *sm750_dev = NULL;\r\nint max_fb;\r\nint fbidx;\r\nint err;\r\nerr = lynxfb_kick_out_firmware_fb(pdev);\r\nif (err)\r\nreturn err;\r\nerr = pcim_enable_device(pdev);\r\nif (err)\r\nreturn err;\r\nerr = -ENOMEM;\r\nsm750_dev = devm_kzalloc(&pdev->dev, sizeof(*sm750_dev), GFP_KERNEL);\r\nif (!sm750_dev)\r\nreturn err;\r\nsm750_dev->fbinfo[0] = sm750_dev->fbinfo[1] = NULL;\r\nsm750_dev->devid = pdev->device;\r\nsm750_dev->revid = pdev->revision;\r\nsm750_dev->pdev = pdev;\r\nsm750_dev->mtrr_off = g_nomtrr;\r\nsm750_dev->mtrr.vram = 0;\r\nsm750_dev->accel_off = g_noaccel;\r\nspin_lock_init(&sm750_dev->slock);\r\nif (!sm750_dev->accel_off) {\r\nsm750_dev->accel.de_init = sm750_hw_de_init;\r\nsm750_dev->accel.de_fillrect = sm750_hw_fillrect;\r\nsm750_dev->accel.de_copyarea = sm750_hw_copyarea;\r\nsm750_dev->accel.de_imageblit = sm750_hw_imageblit;\r\n}\r\nsm750fb_setup(sm750_dev, g_settings);\r\nerr = hw_sm750_map(sm750_dev, pdev);\r\nif (err)\r\nreturn err;\r\nif (!sm750_dev->mtrr_off)\r\nsm750_dev->mtrr.vram = arch_phys_wc_add(sm750_dev->vidmem_start,\r\nsm750_dev->vidmem_size);\r\nmemset_io(sm750_dev->pvMem, 0, sm750_dev->vidmem_size);\r\npci_set_drvdata(pdev, sm750_dev);\r\nhw_sm750_inithw(sm750_dev, pdev);\r\nmax_fb = g_dualview ? 2 : 1;\r\nfor (fbidx = 0; fbidx < max_fb; fbidx++) {\r\nerr = sm750fb_frambuffer_alloc(sm750_dev, fbidx);\r\nif (err)\r\ngoto release_fb;\r\n}\r\nreturn 0;\r\nrelease_fb:\r\nsm750fb_frambuffer_release(sm750_dev);\r\nreturn err;\r\n}\r\nstatic void lynxfb_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct sm750_dev *sm750_dev;\r\nsm750_dev = pci_get_drvdata(pdev);\r\nsm750fb_frambuffer_release(sm750_dev);\r\narch_phys_wc_del(sm750_dev->mtrr.vram);\r\niounmap(sm750_dev->pvReg);\r\niounmap(sm750_dev->pvMem);\r\nkfree(g_settings);\r\n}\r\nstatic int __init lynxfb_setup(char *options)\r\n{\r\nint len;\r\nchar *opt, *tmp;\r\nif (!options || !*options) {\r\npr_warn("no options.\n");\r\nreturn 0;\r\n}\r\npr_info("options:%s\n", options);\r\nlen = strlen(options) + 1;\r\ng_settings = kzalloc(len, GFP_KERNEL);\r\nif (!g_settings)\r\nreturn -ENOMEM;\r\ntmp = g_settings;\r\nwhile ((opt = strsep(&options, ":")) != NULL) {\r\nif (!strncmp(opt, "noaccel", strlen("noaccel"))) {\r\ng_noaccel = 1;\r\n} else if (!strncmp(opt, "nomtrr", strlen("nomtrr"))) {\r\ng_nomtrr = 1;\r\n} else if (!strncmp(opt, "dual", strlen("dual"))) {\r\ng_dualview = 1;\r\n} else {\r\nstrcat(tmp, opt);\r\ntmp += strlen(opt);\r\nif (options)\r\n*tmp++ = ':';\r\nelse\r\n*tmp++ = 0;\r\n}\r\n}\r\npr_info("parameter left for chip specific analysis:%s\n", g_settings);\r\nreturn 0;\r\n}\r\nstatic int __init lynxfb_init(void)\r\n{\r\nchar *option;\r\n#ifdef MODULE\r\noption = g_option;\r\n#else\r\nif (fb_get_options("sm750fb", &option))\r\nreturn -ENODEV;\r\n#endif\r\nlynxfb_setup(option);\r\nreturn pci_register_driver(&lynxfb_driver);\r\n}\r\nstatic void __exit lynxfb_exit(void)\r\n{\r\npci_unregister_driver(&lynxfb_driver);\r\n}
