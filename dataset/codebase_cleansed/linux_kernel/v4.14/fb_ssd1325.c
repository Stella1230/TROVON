static int init_display(struct fbtft_par *par)\r\n{\r\npar->fbtftops.reset(par);\r\ngpio_set_value(par->gpio.cs, 0);\r\nwrite_reg(par, 0xb3);\r\nwrite_reg(par, 0xf0);\r\nwrite_reg(par, 0xae);\r\nwrite_reg(par, 0xa1);\r\nwrite_reg(par, 0x00);\r\nwrite_reg(par, 0xa8);\r\nwrite_reg(par, 0x3f);\r\nwrite_reg(par, 0xa0);\r\nwrite_reg(par, 0x45);\r\nwrite_reg(par, 0xa2);\r\nwrite_reg(par, 0x40);\r\nwrite_reg(par, 0x75);\r\nwrite_reg(par, 0x00);\r\nwrite_reg(par, 0x3f);\r\nwrite_reg(par, 0x15);\r\nwrite_reg(par, 0x00);\r\nwrite_reg(par, 0x7f);\r\nwrite_reg(par, 0xa4);\r\nwrite_reg(par, 0xaf);\r\nreturn 0;\r\n}\r\nstatic uint8_t rgb565_to_g16(u16 pixel)\r\n{\r\nu16 b = pixel & 0x1f;\r\nu16 g = (pixel & (0x3f << 5)) >> 5;\r\nu16 r = (pixel & (0x1f << (5 + 6))) >> (5 + 6);\r\npixel = (299 * r + 587 * g + 114 * b) / 195;\r\nif (pixel > 255)\r\npixel = 255;\r\nreturn (uint8_t)pixel / 16;\r\n}\r\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\r\n{\r\nfbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,\r\n"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe,\r\nye);\r\nwrite_reg(par, 0x75);\r\nwrite_reg(par, 0x00);\r\nwrite_reg(par, 0x3f);\r\nwrite_reg(par, 0x15);\r\nwrite_reg(par, 0x00);\r\nwrite_reg(par, 0x7f);\r\n}\r\nstatic int blank(struct fbtft_par *par, bool on)\r\n{\r\nfbtft_par_dbg(DEBUG_BLANK, par, "%s(blank=%s)\n",\r\n__func__, on ? "true" : "false");\r\nif (on)\r\nwrite_reg(par, 0xAE);\r\nelse\r\nwrite_reg(par, 0xAF);\r\nreturn 0;\r\n}\r\nstatic int set_gamma(struct fbtft_par *par, u32 *curves)\r\n{\r\nint i;\r\nfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);\r\nfor (i = 0; i < GAMMA_LEN; i++) {\r\nif (i > 0 && curves[i] < 1) {\r\ndev_err(par->info->device,\r\n"Illegal value in Grayscale Lookup Table at index %d.\n"\r\n"Must be greater than 0\n", i);\r\nreturn -EINVAL;\r\n}\r\nif (curves[i] > 7) {\r\ndev_err(par->info->device,\r\n"Illegal value(s) in Grayscale Lookup Table.\n"\r\n"At index=%d, the accumulated value has exceeded 7\n",\r\ni);\r\nreturn -EINVAL;\r\n}\r\n}\r\nwrite_reg(par, 0xB8);\r\nfor (i = 0; i < 8; i++)\r\nwrite_reg(par, (curves[i] & 0xFF));\r\nreturn 0;\r\n}\r\nstatic int write_vmem(struct fbtft_par *par, size_t offset, size_t len)\r\n{\r\nu16 *vmem16 = (u16 *)par->info->screen_buffer;\r\nu8 *buf = par->txbuf.buf;\r\nu8 n1;\r\nu8 n2;\r\nint y, x;\r\nint ret;\r\nfor (x = 0; x < par->info->var.xres; x++) {\r\nif (x % 2)\r\ncontinue;\r\nfor (y = 0; y < par->info->var.yres; y++) {\r\nn1 = rgb565_to_g16(vmem16[y * par->info->var.xres + x]);\r\nn2 = rgb565_to_g16(vmem16\r\n[y * par->info->var.xres + x + 1]);\r\n*buf = (n1 << 4) | n2;\r\nbuf++;\r\n}\r\n}\r\ngpio_set_value(par->gpio.dc, 1);\r\nret = par->fbtftops.write(par, par->txbuf.buf,\r\npar->info->var.xres * par->info->var.yres / 2);\r\nif (ret < 0)\r\ndev_err(par->info->device,\r\n"%s: write failed and returned: %d\n", __func__, ret);\r\nreturn ret;\r\n}
