static inline void mcba_init_ctx(struct mcba_priv *priv)\r\n{\r\nint i = 0;\r\nfor (i = 0; i < MCBA_MAX_TX_URBS; i++) {\r\npriv->tx_context[i].ndx = MCBA_CTX_FREE;\r\npriv->tx_context[i].priv = priv;\r\n}\r\natomic_set(&priv->free_ctx_cnt, ARRAY_SIZE(priv->tx_context));\r\n}\r\nstatic inline struct mcba_usb_ctx *mcba_usb_get_free_ctx(struct mcba_priv *priv,\r\nstruct can_frame *cf)\r\n{\r\nint i = 0;\r\nstruct mcba_usb_ctx *ctx = NULL;\r\nfor (i = 0; i < MCBA_MAX_TX_URBS; i++) {\r\nif (priv->tx_context[i].ndx == MCBA_CTX_FREE) {\r\nctx = &priv->tx_context[i];\r\nctx->ndx = i;\r\nif (cf) {\r\nctx->can = true;\r\nctx->dlc = cf->can_dlc;\r\n} else {\r\nctx->can = false;\r\nctx->dlc = 0;\r\n}\r\natomic_dec(&priv->free_ctx_cnt);\r\nbreak;\r\n}\r\n}\r\nif (!atomic_read(&priv->free_ctx_cnt))\r\nnetif_stop_queue(priv->netdev);\r\nreturn ctx;\r\n}\r\nstatic inline void mcba_usb_free_ctx(struct mcba_usb_ctx *ctx)\r\n{\r\natomic_inc(&ctx->priv->free_ctx_cnt);\r\nctx->ndx = MCBA_CTX_FREE;\r\nnetif_wake_queue(ctx->priv->netdev);\r\n}\r\nstatic void mcba_usb_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct mcba_usb_ctx *ctx = urb->context;\r\nstruct net_device *netdev;\r\nWARN_ON(!ctx);\r\nnetdev = ctx->priv->netdev;\r\nusb_free_coherent(urb->dev, urb->transfer_buffer_length,\r\nurb->transfer_buffer, urb->transfer_dma);\r\nif (ctx->can) {\r\nif (!netif_device_present(netdev))\r\nreturn;\r\nnetdev->stats.tx_packets++;\r\nnetdev->stats.tx_bytes += ctx->dlc;\r\ncan_led_event(netdev, CAN_LED_EVENT_TX);\r\ncan_get_echo_skb(netdev, ctx->ndx);\r\n}\r\nif (urb->status)\r\nnetdev_info(netdev, "Tx URB aborted (%d)\n", urb->status);\r\nmcba_usb_free_ctx(ctx);\r\n}\r\nstatic netdev_tx_t mcba_usb_xmit(struct mcba_priv *priv,\r\nstruct mcba_usb_msg *usb_msg,\r\nstruct mcba_usb_ctx *ctx)\r\n{\r\nstruct urb *urb;\r\nu8 *buf;\r\nint err;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nbuf = usb_alloc_coherent(priv->udev, MCBA_USB_TX_BUFF_SIZE, GFP_ATOMIC,\r\n&urb->transfer_dma);\r\nif (!buf) {\r\nerr = -ENOMEM;\r\ngoto nomembuf;\r\n}\r\nmemcpy(buf, usb_msg, MCBA_USB_TX_BUFF_SIZE);\r\nusb_fill_bulk_urb(urb, priv->udev,\r\nusb_sndbulkpipe(priv->udev, MCBA_USB_EP_OUT), buf,\r\nMCBA_USB_TX_BUFF_SIZE, mcba_usb_write_bulk_callback,\r\nctx);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(urb, &priv->tx_submitted);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (unlikely(err))\r\ngoto failed;\r\nusb_free_urb(urb);\r\nreturn 0;\r\nfailed:\r\nusb_unanchor_urb(urb);\r\nusb_free_coherent(priv->udev, MCBA_USB_TX_BUFF_SIZE, buf,\r\nurb->transfer_dma);\r\nif (err == -ENODEV)\r\nnetif_device_detach(priv->netdev);\r\nelse\r\nnetdev_warn(priv->netdev, "failed tx_urb %d\n", err);\r\nnomembuf:\r\nusb_free_urb(urb);\r\nreturn err;\r\n}\r\nstatic netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct mcba_priv *priv = netdev_priv(netdev);\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nstruct mcba_usb_ctx *ctx = NULL;\r\nstruct net_device_stats *stats = &priv->netdev->stats;\r\nu16 sid;\r\nint err;\r\nstruct mcba_usb_msg_can usb_msg = {\r\n.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\r\n};\r\nif (can_dropped_invalid_skb(netdev, skb))\r\nreturn NETDEV_TX_OK;\r\nctx = mcba_usb_get_free_ctx(priv, cf);\r\nif (!ctx)\r\nreturn NETDEV_TX_BUSY;\r\ncan_put_echo_skb(skb, priv->netdev, ctx->ndx);\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\nsid = MCBA_SIDL_EXID_MASK;\r\nsid |= (cf->can_id & 0x1ffc0000) >> 13;\r\nsid |= (cf->can_id & 0x30000) >> 16;\r\nput_unaligned_be16(sid, &usb_msg.sid);\r\nput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\r\n} else {\r\nput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\r\n&usb_msg.sid);\r\nusb_msg.eid = 0;\r\n}\r\nusb_msg.dlc = cf->can_dlc;\r\nmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\r\nif (cf->can_id & CAN_RTR_FLAG)\r\nusb_msg.dlc |= MCBA_DLC_RTR_MASK;\r\nerr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\r\nif (err)\r\ngoto xmit_failed;\r\nreturn NETDEV_TX_OK;\r\nxmit_failed:\r\ncan_free_echo_skb(priv->netdev, ctx->ndx);\r\nmcba_usb_free_ctx(ctx);\r\ndev_kfree_skb(skb);\r\nstats->tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void mcba_usb_xmit_cmd(struct mcba_priv *priv,\r\nstruct mcba_usb_msg *usb_msg)\r\n{\r\nstruct mcba_usb_ctx *ctx = NULL;\r\nint err;\r\nctx = mcba_usb_get_free_ctx(priv, NULL);\r\nif (!ctx) {\r\nnetdev_err(priv->netdev,\r\n"Lack of free ctx. Sending (%d) cmd aborted",\r\nusb_msg->cmd_id);\r\nreturn;\r\n}\r\nerr = mcba_usb_xmit(priv, usb_msg, ctx);\r\nif (err)\r\nnetdev_err(priv->netdev, "Failed to send cmd (%d)",\r\nusb_msg->cmd_id);\r\n}\r\nstatic void mcba_usb_xmit_change_bitrate(struct mcba_priv *priv, u16 bitrate)\r\n{\r\nstruct mcba_usb_msg_change_bitrate usb_msg = {\r\n.cmd_id = MBCA_CMD_CHANGE_BIT_RATE\r\n};\r\nput_unaligned_be16(bitrate, &usb_msg.bitrate);\r\nmcba_usb_xmit_cmd(priv, (struct mcba_usb_msg *)&usb_msg);\r\n}\r\nstatic void mcba_usb_xmit_read_fw_ver(struct mcba_priv *priv, u8 pic)\r\n{\r\nstruct mcba_usb_msg_fw_ver usb_msg = {\r\n.cmd_id = MBCA_CMD_READ_FW_VERSION,\r\n.pic = pic\r\n};\r\nmcba_usb_xmit_cmd(priv, (struct mcba_usb_msg *)&usb_msg);\r\n}\r\nstatic void mcba_usb_process_can(struct mcba_priv *priv,\r\nstruct mcba_usb_msg_can *msg)\r\n{\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nstruct net_device_stats *stats = &priv->netdev->stats;\r\nu16 sid;\r\nskb = alloc_can_skb(priv->netdev, &cf);\r\nif (!skb)\r\nreturn;\r\nsid = get_unaligned_be16(&msg->sid);\r\nif (sid & MCBA_SIDL_EXID_MASK) {\r\ncf->can_id = CAN_EFF_FLAG;\r\ncf->can_id |= (sid & 0xffe0) << 13;\r\ncf->can_id |= (sid & 3) << 16;\r\ncf->can_id |= get_unaligned_be16(&msg->eid);\r\n} else {\r\ncf->can_id = (sid & 0xffe0) >> 5;\r\n}\r\nif (msg->dlc & MCBA_DLC_RTR_MASK)\r\ncf->can_id |= CAN_RTR_FLAG;\r\ncf->can_dlc = get_can_dlc(msg->dlc & MCBA_DLC_MASK);\r\nmemcpy(cf->data, msg->data, cf->can_dlc);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\ncan_led_event(priv->netdev, CAN_LED_EVENT_RX);\r\nnetif_rx(skb);\r\n}\r\nstatic void mcba_usb_process_ka_usb(struct mcba_priv *priv,\r\nstruct mcba_usb_msg_ka_usb *msg)\r\n{\r\nif (unlikely(priv->usb_ka_first_pass)) {\r\nnetdev_info(priv->netdev, "PIC USB version %hhu.%hhu\n",\r\nmsg->soft_ver_major, msg->soft_ver_minor);\r\npriv->usb_ka_first_pass = false;\r\n}\r\nif (msg->termination_state)\r\npriv->can.termination = MCBA_TERMINATION_ENABLED;\r\nelse\r\npriv->can.termination = MCBA_TERMINATION_DISABLED;\r\n}\r\nstatic u32 convert_can2host_bitrate(struct mcba_usb_msg_ka_can *msg)\r\n{\r\nconst u32 bitrate = get_unaligned_be16(&msg->can_bitrate);\r\nif ((bitrate == 33) || (bitrate == 83))\r\nreturn bitrate * 1000 + 333;\r\nelse\r\nreturn bitrate * 1000;\r\n}\r\nstatic void mcba_usb_process_ka_can(struct mcba_priv *priv,\r\nstruct mcba_usb_msg_ka_can *msg)\r\n{\r\nif (unlikely(priv->can_ka_first_pass)) {\r\nnetdev_info(priv->netdev, "PIC CAN version %hhu.%hhu\n",\r\nmsg->soft_ver_major, msg->soft_ver_minor);\r\npriv->can_ka_first_pass = false;\r\n}\r\nif (unlikely(priv->can_speed_check)) {\r\nconst u32 bitrate = convert_can2host_bitrate(msg);\r\npriv->can_speed_check = false;\r\nif (bitrate != priv->can.bittiming.bitrate)\r\nnetdev_err(\r\npriv->netdev,\r\n"Wrong bitrate reported by the device (%u). Expected %u",\r\nbitrate, priv->can.bittiming.bitrate);\r\n}\r\npriv->bec.txerr = msg->tx_err_cnt;\r\npriv->bec.rxerr = msg->rx_err_cnt;\r\nif (msg->tx_bus_off)\r\npriv->can.state = CAN_STATE_BUS_OFF;\r\nelse if ((priv->bec.txerr > MCBA_CAN_STATE_ERR_PSV_TH) ||\r\n(priv->bec.rxerr > MCBA_CAN_STATE_ERR_PSV_TH))\r\npriv->can.state = CAN_STATE_ERROR_PASSIVE;\r\nelse if ((priv->bec.txerr > MCBA_CAN_STATE_WRN_TH) ||\r\n(priv->bec.rxerr > MCBA_CAN_STATE_WRN_TH))\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\n}\r\nstatic void mcba_usb_process_rx(struct mcba_priv *priv,\r\nstruct mcba_usb_msg *msg)\r\n{\r\nswitch (msg->cmd_id) {\r\ncase MBCA_CMD_I_AM_ALIVE_FROM_CAN:\r\nmcba_usb_process_ka_can(priv,\r\n(struct mcba_usb_msg_ka_can *)msg);\r\nbreak;\r\ncase MBCA_CMD_I_AM_ALIVE_FROM_USB:\r\nmcba_usb_process_ka_usb(priv,\r\n(struct mcba_usb_msg_ka_usb *)msg);\r\nbreak;\r\ncase MBCA_CMD_RECEIVE_MESSAGE:\r\nmcba_usb_process_can(priv, (struct mcba_usb_msg_can *)msg);\r\nbreak;\r\ncase MBCA_CMD_NOTHING_TO_SEND:\r\nbreak;\r\ncase MBCA_CMD_TRANSMIT_MESSAGE_RSP:\r\nbreak;\r\ndefault:\r\nnetdev_warn(priv->netdev, "Unsupported msg (0x%hhX)",\r\nmsg->cmd_id);\r\nbreak;\r\n}\r\n}\r\nstatic void mcba_usb_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct mcba_priv *priv = urb->context;\r\nstruct net_device *netdev;\r\nint retval;\r\nint pos = 0;\r\nnetdev = priv->netdev;\r\nif (!netif_device_present(netdev))\r\nreturn;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\nnetdev_info(netdev, "Rx URB aborted (%d)\n", urb->status);\r\ngoto resubmit_urb;\r\n}\r\nwhile (pos < urb->actual_length) {\r\nstruct mcba_usb_msg *msg;\r\nif (pos + sizeof(struct mcba_usb_msg) > urb->actual_length) {\r\nnetdev_err(priv->netdev, "format error\n");\r\nbreak;\r\n}\r\nmsg = (struct mcba_usb_msg *)(urb->transfer_buffer + pos);\r\nmcba_usb_process_rx(priv, msg);\r\npos += sizeof(struct mcba_usb_msg);\r\n}\r\nresubmit_urb:\r\nusb_fill_bulk_urb(urb, priv->udev,\r\nusb_rcvbulkpipe(priv->udev, MCBA_USB_EP_OUT),\r\nurb->transfer_buffer, MCBA_USB_RX_BUFF_SIZE,\r\nmcba_usb_read_bulk_callback, priv);\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval == -ENODEV)\r\nnetif_device_detach(netdev);\r\nelse if (retval)\r\nnetdev_err(netdev, "failed resubmitting read bulk urb: %d\n",\r\nretval);\r\n}\r\nstatic int mcba_usb_start(struct mcba_priv *priv)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nint err, i;\r\nmcba_init_ctx(priv);\r\nfor (i = 0; i < MCBA_MAX_RX_URBS; i++) {\r\nstruct urb *urb = NULL;\r\nu8 *buf;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nbuf = usb_alloc_coherent(priv->udev, MCBA_USB_RX_BUFF_SIZE,\r\nGFP_KERNEL, &urb->transfer_dma);\r\nif (!buf) {\r\nnetdev_err(netdev, "No memory left for USB buffer\n");\r\nusb_free_urb(urb);\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nusb_fill_bulk_urb(urb, priv->udev,\r\nusb_rcvbulkpipe(priv->udev, MCBA_USB_EP_IN),\r\nbuf, MCBA_USB_RX_BUFF_SIZE,\r\nmcba_usb_read_bulk_callback, priv);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(urb, &priv->rx_submitted);\r\nerr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (err) {\r\nusb_unanchor_urb(urb);\r\nusb_free_coherent(priv->udev, MCBA_USB_RX_BUFF_SIZE,\r\nbuf, urb->transfer_dma);\r\nusb_free_urb(urb);\r\nbreak;\r\n}\r\nusb_free_urb(urb);\r\n}\r\nif (i == 0) {\r\nnetdev_warn(netdev, "couldn't setup read URBs\n");\r\nreturn err;\r\n}\r\nif (i < MCBA_MAX_RX_URBS)\r\nnetdev_warn(netdev, "rx performance may be slow\n");\r\nmcba_usb_xmit_read_fw_ver(priv, MCBA_VER_REQ_USB);\r\nmcba_usb_xmit_read_fw_ver(priv, MCBA_VER_REQ_CAN);\r\nreturn err;\r\n}\r\nstatic int mcba_usb_open(struct net_device *netdev)\r\n{\r\nstruct mcba_priv *priv = netdev_priv(netdev);\r\nint err;\r\nerr = open_candev(netdev);\r\nif (err)\r\nreturn err;\r\npriv->can_speed_check = true;\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\ncan_led_event(netdev, CAN_LED_EVENT_OPEN);\r\nnetif_start_queue(netdev);\r\nreturn 0;\r\n}\r\nstatic void mcba_urb_unlink(struct mcba_priv *priv)\r\n{\r\nusb_kill_anchored_urbs(&priv->rx_submitted);\r\nusb_kill_anchored_urbs(&priv->tx_submitted);\r\n}\r\nstatic int mcba_usb_close(struct net_device *netdev)\r\n{\r\nstruct mcba_priv *priv = netdev_priv(netdev);\r\npriv->can.state = CAN_STATE_STOPPED;\r\nnetif_stop_queue(netdev);\r\nmcba_urb_unlink(priv);\r\nclose_candev(netdev);\r\ncan_led_event(netdev, CAN_LED_EVENT_STOP);\r\nreturn 0;\r\n}\r\nstatic int mcba_net_set_mode(struct net_device *netdev, enum can_mode mode)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mcba_net_get_berr_counter(const struct net_device *netdev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct mcba_priv *priv = netdev_priv(netdev);\r\nbec->txerr = priv->bec.txerr;\r\nbec->rxerr = priv->bec.rxerr;\r\nreturn 0;\r\n}\r\nstatic int mcba_net_set_bittiming(struct net_device *netdev)\r\n{\r\nstruct mcba_priv *priv = netdev_priv(netdev);\r\nconst u16 bitrate_kbps = priv->can.bittiming.bitrate / 1000;\r\nmcba_usb_xmit_change_bitrate(priv, bitrate_kbps);\r\nreturn 0;\r\n}\r\nstatic int mcba_set_termination(struct net_device *netdev, u16 term)\r\n{\r\nstruct mcba_priv *priv = netdev_priv(netdev);\r\nstruct mcba_usb_msg_termination usb_msg = {\r\n.cmd_id = MBCA_CMD_SETUP_TERMINATION_RESISTANCE\r\n};\r\nif (term == MCBA_TERMINATION_ENABLED)\r\nusb_msg.termination = 1;\r\nelse\r\nusb_msg.termination = 0;\r\nmcba_usb_xmit_cmd(priv, (struct mcba_usb_msg *)&usb_msg);\r\nreturn 0;\r\n}\r\nstatic int mcba_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct net_device *netdev;\r\nstruct mcba_priv *priv;\r\nint err = -ENOMEM;\r\nstruct usb_device *usbdev = interface_to_usbdev(intf);\r\nnetdev = alloc_candev(sizeof(struct mcba_priv), MCBA_MAX_TX_URBS);\r\nif (!netdev) {\r\ndev_err(&intf->dev, "Couldn't alloc candev\n");\r\nreturn -ENOMEM;\r\n}\r\npriv = netdev_priv(netdev);\r\npriv->udev = usbdev;\r\npriv->netdev = netdev;\r\npriv->usb_ka_first_pass = true;\r\npriv->can_ka_first_pass = true;\r\npriv->can_speed_check = false;\r\ninit_usb_anchor(&priv->rx_submitted);\r\ninit_usb_anchor(&priv->tx_submitted);\r\nusb_set_intfdata(intf, priv);\r\npriv->can.state = CAN_STATE_STOPPED;\r\npriv->can.termination_const = mcba_termination;\r\npriv->can.termination_const_cnt = ARRAY_SIZE(mcba_termination);\r\npriv->can.bitrate_const = mcba_bitrate;\r\npriv->can.bitrate_const_cnt = ARRAY_SIZE(mcba_bitrate);\r\npriv->can.do_set_termination = mcba_set_termination;\r\npriv->can.do_set_mode = mcba_net_set_mode;\r\npriv->can.do_get_berr_counter = mcba_net_get_berr_counter;\r\npriv->can.do_set_bittiming = mcba_net_set_bittiming;\r\nnetdev->netdev_ops = &mcba_netdev_ops;\r\nnetdev->flags |= IFF_ECHO;\r\nSET_NETDEV_DEV(netdev, &intf->dev);\r\nerr = register_candev(netdev);\r\nif (err) {\r\nnetdev_err(netdev, "couldn't register CAN device: %d\n", err);\r\ngoto cleanup_free_candev;\r\n}\r\ndevm_can_led_init(netdev);\r\nerr = mcba_usb_start(priv);\r\nif (err) {\r\nif (err == -ENODEV)\r\nnetif_device_detach(priv->netdev);\r\nnetdev_warn(netdev, "couldn't start device: %d\n", err);\r\ngoto cleanup_unregister_candev;\r\n}\r\ndev_info(&intf->dev, "Microchip CAN BUS analizer connected\n");\r\nreturn 0;\r\ncleanup_unregister_candev:\r\nunregister_candev(priv->netdev);\r\ncleanup_free_candev:\r\nfree_candev(netdev);\r\nreturn err;\r\n}\r\nstatic void mcba_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct mcba_priv *priv = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nnetdev_info(priv->netdev, "device disconnected\n");\r\nunregister_candev(priv->netdev);\r\nfree_candev(priv->netdev);\r\nmcba_urb_unlink(priv);\r\n}
