static void omap_irq_update(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct omap_irq_wait *wait;\r\nuint32_t irqmask = priv->irq_mask;\r\nassert_spin_locked(&priv->wait_lock);\r\nlist_for_each_entry(wait, &priv->wait_list, node)\r\nirqmask |= wait->irqmask;\r\nDBG("irqmask=%08x", irqmask);\r\npriv->dispc_ops->write_irqenable(irqmask);\r\n}\r\nstatic void omap_irq_wait_handler(struct omap_irq_wait *wait)\r\n{\r\nwait->count--;\r\nwake_up(&wait->wq);\r\n}\r\nstruct omap_irq_wait * omap_irq_wait_init(struct drm_device *dev,\r\nuint32_t irqmask, int count)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct omap_irq_wait *wait = kzalloc(sizeof(*wait), GFP_KERNEL);\r\nunsigned long flags;\r\ninit_waitqueue_head(&wait->wq);\r\nwait->irqmask = irqmask;\r\nwait->count = count;\r\nspin_lock_irqsave(&priv->wait_lock, flags);\r\nlist_add(&wait->node, &priv->wait_list);\r\nomap_irq_update(dev);\r\nspin_unlock_irqrestore(&priv->wait_lock, flags);\r\nreturn wait;\r\n}\r\nint omap_irq_wait(struct drm_device *dev, struct omap_irq_wait *wait,\r\nunsigned long timeout)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nunsigned long flags;\r\nint ret;\r\nret = wait_event_timeout(wait->wq, (wait->count <= 0), timeout);\r\nspin_lock_irqsave(&priv->wait_lock, flags);\r\nlist_del(&wait->node);\r\nomap_irq_update(dev);\r\nspin_unlock_irqrestore(&priv->wait_lock, flags);\r\nkfree(wait);\r\nreturn ret == 0 ? -1 : 0;\r\n}\r\nint omap_irq_enable_vblank(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nunsigned long flags;\r\nenum omap_channel channel = omap_crtc_channel(crtc);\r\nDBG("dev=%p, crtc=%u", dev, channel);\r\nspin_lock_irqsave(&priv->wait_lock, flags);\r\npriv->irq_mask |= priv->dispc_ops->mgr_get_vsync_irq(channel);\r\nomap_irq_update(dev);\r\nspin_unlock_irqrestore(&priv->wait_lock, flags);\r\nreturn 0;\r\n}\r\nvoid omap_irq_disable_vblank(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nunsigned long flags;\r\nenum omap_channel channel = omap_crtc_channel(crtc);\r\nDBG("dev=%p, crtc=%u", dev, channel);\r\nspin_lock_irqsave(&priv->wait_lock, flags);\r\npriv->irq_mask &= ~priv->dispc_ops->mgr_get_vsync_irq(channel);\r\nomap_irq_update(dev);\r\nspin_unlock_irqrestore(&priv->wait_lock, flags);\r\n}\r\nstatic void omap_irq_fifo_underflow(struct omap_drm_private *priv,\r\nu32 irqstatus)\r\n{\r\nstatic DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,\r\nDEFAULT_RATELIMIT_BURST);\r\nstatic const struct {\r\nconst char *name;\r\nu32 mask;\r\n} sources[] = {\r\n{ "gfx", DISPC_IRQ_GFX_FIFO_UNDERFLOW },\r\n{ "vid1", DISPC_IRQ_VID1_FIFO_UNDERFLOW },\r\n{ "vid2", DISPC_IRQ_VID2_FIFO_UNDERFLOW },\r\n{ "vid3", DISPC_IRQ_VID3_FIFO_UNDERFLOW },\r\n};\r\nconst u32 mask = DISPC_IRQ_GFX_FIFO_UNDERFLOW\r\n| DISPC_IRQ_VID1_FIFO_UNDERFLOW\r\n| DISPC_IRQ_VID2_FIFO_UNDERFLOW\r\n| DISPC_IRQ_VID3_FIFO_UNDERFLOW;\r\nunsigned int i;\r\nspin_lock(&priv->wait_lock);\r\nirqstatus &= priv->irq_mask & mask;\r\nspin_unlock(&priv->wait_lock);\r\nif (!irqstatus)\r\nreturn;\r\nif (!__ratelimit(&_rs))\r\nreturn;\r\nDRM_ERROR("FIFO underflow on ");\r\nfor (i = 0; i < ARRAY_SIZE(sources); ++i) {\r\nif (sources[i].mask & irqstatus)\r\npr_cont("%s ", sources[i].name);\r\n}\r\npr_cont("(0x%08x)\n", irqstatus);\r\n}\r\nstatic void omap_irq_ocp_error_handler(struct drm_device *dev,\r\nu32 irqstatus)\r\n{\r\nif (!(irqstatus & DISPC_IRQ_OCP_ERR))\r\nreturn;\r\ndev_err_ratelimited(dev->dev, "OCP error\n");\r\n}\r\nstatic irqreturn_t omap_irq_handler(int irq, void *arg)\r\n{\r\nstruct drm_device *dev = (struct drm_device *) arg;\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct omap_irq_wait *wait, *n;\r\nunsigned long flags;\r\nunsigned int id;\r\nu32 irqstatus;\r\nirqstatus = priv->dispc_ops->read_irqstatus();\r\npriv->dispc_ops->clear_irqstatus(irqstatus);\r\npriv->dispc_ops->read_irqstatus();\r\nVERB("irqs: %08x", irqstatus);\r\nfor (id = 0; id < priv->num_crtcs; id++) {\r\nstruct drm_crtc *crtc = priv->crtcs[id];\r\nenum omap_channel channel = omap_crtc_channel(crtc);\r\nif (irqstatus & priv->dispc_ops->mgr_get_vsync_irq(channel)) {\r\ndrm_handle_vblank(dev, id);\r\nomap_crtc_vblank_irq(crtc);\r\n}\r\nif (irqstatus & priv->dispc_ops->mgr_get_sync_lost_irq(channel))\r\nomap_crtc_error_irq(crtc, irqstatus);\r\n}\r\nomap_irq_ocp_error_handler(dev, irqstatus);\r\nomap_irq_fifo_underflow(priv, irqstatus);\r\nspin_lock_irqsave(&priv->wait_lock, flags);\r\nlist_for_each_entry_safe(wait, n, &priv->wait_list, node) {\r\nif (wait->irqmask & irqstatus)\r\nomap_irq_wait_handler(wait);\r\n}\r\nspin_unlock_irqrestore(&priv->wait_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nint omap_drm_irq_install(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nunsigned int num_mgrs = priv->dispc_ops->get_num_mgrs();\r\nunsigned int max_planes;\r\nunsigned int i;\r\nint ret;\r\nspin_lock_init(&priv->wait_lock);\r\nINIT_LIST_HEAD(&priv->wait_list);\r\npriv->irq_mask = DISPC_IRQ_OCP_ERR;\r\nmax_planes = min(ARRAY_SIZE(priv->planes),\r\nARRAY_SIZE(omap_underflow_irqs));\r\nfor (i = 0; i < max_planes; ++i) {\r\nif (priv->planes[i])\r\npriv->irq_mask |= omap_underflow_irqs[i];\r\n}\r\nfor (i = 0; i < num_mgrs; ++i)\r\npriv->irq_mask |= priv->dispc_ops->mgr_get_sync_lost_irq(i);\r\npriv->dispc_ops->runtime_get();\r\npriv->dispc_ops->clear_irqstatus(0xffffffff);\r\npriv->dispc_ops->runtime_put();\r\nret = priv->dispc_ops->request_irq(omap_irq_handler, dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndev->irq_enabled = true;\r\nreturn 0;\r\n}\r\nvoid omap_drm_irq_uninstall(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nif (!dev->irq_enabled)\r\nreturn;\r\ndev->irq_enabled = false;\r\npriv->dispc_ops->free_irq(dev);\r\n}
