static struct usb_pd_identity *get_pd_identity(struct device *dev)\r\n{\r\nif (is_typec_partner(dev)) {\r\nstruct typec_partner *partner = to_typec_partner(dev);\r\nreturn partner->identity;\r\n} else if (is_typec_cable(dev)) {\r\nstruct typec_cable *cable = to_typec_cable(dev);\r\nreturn cable->identity;\r\n}\r\nreturn NULL;\r\n}\r\nstatic ssize_t id_header_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_pd_identity *id = get_pd_identity(dev);\r\nreturn sprintf(buf, "0x%08x\n", id->id_header);\r\n}\r\nstatic ssize_t cert_stat_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_pd_identity *id = get_pd_identity(dev);\r\nreturn sprintf(buf, "0x%08x\n", id->cert_stat);\r\n}\r\nstatic ssize_t product_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_pd_identity *id = get_pd_identity(dev);\r\nreturn sprintf(buf, "0x%08x\n", id->product);\r\n}\r\nstatic void typec_report_identity(struct device *dev)\r\n{\r\nsysfs_notify(&dev->kobj, "identity", "id_header");\r\nsysfs_notify(&dev->kobj, "identity", "cert_stat");\r\nsysfs_notify(&dev->kobj, "identity", "product");\r\n}\r\nvoid typec_altmode_update_active(struct typec_altmode *alt, int mode,\r\nbool active)\r\n{\r\nstruct typec_mode *m = &alt->modes[mode];\r\nchar dir[6];\r\nif (m->active == active)\r\nreturn;\r\nm->active = active;\r\nsnprintf(dir, sizeof(dir), "mode%d", mode);\r\nsysfs_notify(&alt->dev.kobj, dir, "active");\r\nkobject_uevent(&alt->dev.kobj, KOBJ_CHANGE);\r\n}\r\nstruct typec_port *typec_altmode2port(struct typec_altmode *alt)\r\n{\r\nif (is_typec_plug(alt->dev.parent))\r\nreturn to_typec_port(alt->dev.parent->parent->parent);\r\nif (is_typec_partner(alt->dev.parent))\r\nreturn to_typec_port(alt->dev.parent->parent);\r\nif (is_typec_port(alt->dev.parent))\r\nreturn to_typec_port(alt->dev.parent);\r\nreturn NULL;\r\n}\r\nstatic ssize_t\r\ntypec_altmode_vdo_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct typec_mode *mode = container_of(attr, struct typec_mode,\r\nvdo_attr);\r\nreturn sprintf(buf, "0x%08x\n", mode->vdo);\r\n}\r\nstatic ssize_t\r\ntypec_altmode_desc_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct typec_mode *mode = container_of(attr, struct typec_mode,\r\ndesc_attr);\r\nreturn sprintf(buf, "%s\n", mode->desc ? mode->desc : "");\r\n}\r\nstatic ssize_t\r\ntypec_altmode_active_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct typec_mode *mode = container_of(attr, struct typec_mode,\r\nactive_attr);\r\nreturn sprintf(buf, "%s\n", mode->active ? "yes" : "no");\r\n}\r\nstatic ssize_t\r\ntypec_altmode_active_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct typec_mode *mode = container_of(attr, struct typec_mode,\r\nactive_attr);\r\nstruct typec_port *port = typec_altmode2port(mode->alt_mode);\r\nbool activate;\r\nint ret;\r\nif (!port->cap->activate_mode)\r\nreturn -EOPNOTSUPP;\r\nret = kstrtobool(buf, &activate);\r\nif (ret)\r\nreturn ret;\r\nret = port->cap->activate_mode(port->cap, mode->index, activate);\r\nif (ret)\r\nreturn ret;\r\nreturn size;\r\n}\r\nstatic ssize_t\r\ntypec_altmode_roles_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct typec_mode *mode = container_of(attr, struct typec_mode,\r\nroles_attr);\r\nssize_t ret;\r\nswitch (mode->roles) {\r\ncase TYPEC_PORT_DFP:\r\nret = sprintf(buf, "source\n");\r\nbreak;\r\ncase TYPEC_PORT_UFP:\r\nret = sprintf(buf, "sink\n");\r\nbreak;\r\ncase TYPEC_PORT_DRP:\r\ndefault:\r\nret = sprintf(buf, "source sink\n");\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void typec_init_modes(struct typec_altmode *alt,\r\nconst struct typec_mode_desc *desc, bool is_port)\r\n{\r\nint i;\r\nfor (i = 0; i < alt->n_modes; i++, desc++) {\r\nstruct typec_mode *mode = &alt->modes[i];\r\nmode->desc = kstrdup(desc->desc, GFP_KERNEL);\r\nif (desc->desc && !mode->desc)\r\ndev_err(&alt->dev, "failed to copy mode%d desc\n", i);\r\nmode->alt_mode = alt;\r\nmode->vdo = desc->vdo;\r\nmode->roles = desc->roles;\r\nmode->index = desc->index;\r\nsprintf(mode->group_name, "mode%d", desc->index);\r\nsysfs_attr_init(&mode->vdo_attr.attr);\r\nmode->vdo_attr.attr.name = "vdo";\r\nmode->vdo_attr.attr.mode = 0444;\r\nmode->vdo_attr.show = typec_altmode_vdo_show;\r\nsysfs_attr_init(&mode->desc_attr.attr);\r\nmode->desc_attr.attr.name = "description";\r\nmode->desc_attr.attr.mode = 0444;\r\nmode->desc_attr.show = typec_altmode_desc_show;\r\nsysfs_attr_init(&mode->active_attr.attr);\r\nmode->active_attr.attr.name = "active";\r\nmode->active_attr.attr.mode = 0644;\r\nmode->active_attr.show = typec_altmode_active_show;\r\nmode->active_attr.store = typec_altmode_active_store;\r\nmode->attrs[0] = &mode->vdo_attr.attr;\r\nmode->attrs[1] = &mode->desc_attr.attr;\r\nmode->attrs[2] = &mode->active_attr.attr;\r\nif (is_port) {\r\nsysfs_attr_init(&mode->roles_attr.attr);\r\nmode->roles_attr.attr.name = "supported_roles";\r\nmode->roles_attr.attr.mode = 0444;\r\nmode->roles_attr.show = typec_altmode_roles_show;\r\nmode->attrs[3] = &mode->roles_attr.attr;\r\n}\r\nmode->group.attrs = mode->attrs;\r\nmode->group.name = mode->group_name;\r\nalt->mode_groups[i] = &mode->group;\r\n}\r\n}\r\nstatic ssize_t svid_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct typec_altmode *alt = to_altmode(dev);\r\nreturn sprintf(buf, "%04x\n", alt->svid);\r\n}\r\nstatic void typec_altmode_release(struct device *dev)\r\n{\r\nstruct typec_altmode *alt = to_altmode(dev);\r\nint i;\r\nfor (i = 0; i < alt->n_modes; i++)\r\nkfree(alt->modes[i].desc);\r\nkfree(alt);\r\n}\r\nstatic struct typec_altmode *\r\ntypec_register_altmode(struct device *parent,\r\nconst struct typec_altmode_desc *desc)\r\n{\r\nstruct typec_altmode *alt;\r\nint ret;\r\nalt = kzalloc(sizeof(*alt), GFP_KERNEL);\r\nif (!alt)\r\nreturn NULL;\r\nalt->svid = desc->svid;\r\nalt->n_modes = desc->n_modes;\r\ntypec_init_modes(alt, desc->modes, is_typec_port(parent));\r\nalt->dev.parent = parent;\r\nalt->dev.groups = alt->mode_groups;\r\nalt->dev.type = &typec_altmode_dev_type;\r\ndev_set_name(&alt->dev, "svid-%04x", alt->svid);\r\nret = device_register(&alt->dev);\r\nif (ret) {\r\ndev_err(parent, "failed to register alternate mode (%d)\n",\r\nret);\r\nput_device(&alt->dev);\r\nreturn NULL;\r\n}\r\nreturn alt;\r\n}\r\nvoid typec_unregister_altmode(struct typec_altmode *alt)\r\n{\r\nif (alt)\r\ndevice_unregister(&alt->dev);\r\n}\r\nstatic ssize_t accessory_mode_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct typec_partner *p = to_typec_partner(dev);\r\nreturn sprintf(buf, "%s\n", typec_accessory_modes[p->accessory]);\r\n}\r\nstatic ssize_t supports_usb_power_delivery_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct typec_partner *p = to_typec_partner(dev);\r\nreturn sprintf(buf, "%s\n", p->usb_pd ? "yes" : "no");\r\n}\r\nstatic void typec_partner_release(struct device *dev)\r\n{\r\nstruct typec_partner *partner = to_typec_partner(dev);\r\nkfree(partner);\r\n}\r\nint typec_partner_set_identity(struct typec_partner *partner)\r\n{\r\nif (!partner->identity)\r\nreturn -EINVAL;\r\ntypec_report_identity(&partner->dev);\r\nreturn 0;\r\n}\r\nstruct typec_altmode *\r\ntypec_partner_register_altmode(struct typec_partner *partner,\r\nconst struct typec_altmode_desc *desc)\r\n{\r\nreturn typec_register_altmode(&partner->dev, desc);\r\n}\r\nstruct typec_partner *typec_register_partner(struct typec_port *port,\r\nstruct typec_partner_desc *desc)\r\n{\r\nstruct typec_partner *partner;\r\nint ret;\r\npartner = kzalloc(sizeof(*partner), GFP_KERNEL);\r\nif (!partner)\r\nreturn NULL;\r\npartner->usb_pd = desc->usb_pd;\r\npartner->accessory = desc->accessory;\r\nif (desc->identity) {\r\npartner->dev.groups = usb_pd_id_groups;\r\npartner->identity = desc->identity;\r\n}\r\npartner->dev.class = typec_class;\r\npartner->dev.parent = &port->dev;\r\npartner->dev.type = &typec_partner_dev_type;\r\ndev_set_name(&partner->dev, "%s-partner", dev_name(&port->dev));\r\nret = device_register(&partner->dev);\r\nif (ret) {\r\ndev_err(&port->dev, "failed to register partner (%d)\n", ret);\r\nput_device(&partner->dev);\r\nreturn NULL;\r\n}\r\nreturn partner;\r\n}\r\nvoid typec_unregister_partner(struct typec_partner *partner)\r\n{\r\nif (partner)\r\ndevice_unregister(&partner->dev);\r\n}\r\nstatic void typec_plug_release(struct device *dev)\r\n{\r\nstruct typec_plug *plug = to_typec_plug(dev);\r\nkfree(plug);\r\n}\r\nstruct typec_altmode *\r\ntypec_plug_register_altmode(struct typec_plug *plug,\r\nconst struct typec_altmode_desc *desc)\r\n{\r\nreturn typec_register_altmode(&plug->dev, desc);\r\n}\r\nstruct typec_plug *typec_register_plug(struct typec_cable *cable,\r\nstruct typec_plug_desc *desc)\r\n{\r\nstruct typec_plug *plug;\r\nchar name[8];\r\nint ret;\r\nplug = kzalloc(sizeof(*plug), GFP_KERNEL);\r\nif (!plug)\r\nreturn NULL;\r\nsprintf(name, "plug%d", desc->index);\r\nplug->index = desc->index;\r\nplug->dev.class = typec_class;\r\nplug->dev.parent = &cable->dev;\r\nplug->dev.type = &typec_plug_dev_type;\r\ndev_set_name(&plug->dev, "%s-%s", dev_name(cable->dev.parent), name);\r\nret = device_register(&plug->dev);\r\nif (ret) {\r\ndev_err(&cable->dev, "failed to register plug (%d)\n", ret);\r\nput_device(&plug->dev);\r\nreturn NULL;\r\n}\r\nreturn plug;\r\n}\r\nvoid typec_unregister_plug(struct typec_plug *plug)\r\n{\r\nif (plug)\r\ndevice_unregister(&plug->dev);\r\n}\r\nstatic ssize_t\r\ntype_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct typec_cable *cable = to_typec_cable(dev);\r\nreturn sprintf(buf, "%s\n", cable->active ? "active" : "passive");\r\n}\r\nstatic ssize_t plug_type_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct typec_cable *cable = to_typec_cable(dev);\r\nreturn sprintf(buf, "%s\n", typec_plug_types[cable->type]);\r\n}\r\nstatic void typec_cable_release(struct device *dev)\r\n{\r\nstruct typec_cable *cable = to_typec_cable(dev);\r\nkfree(cable);\r\n}\r\nint typec_cable_set_identity(struct typec_cable *cable)\r\n{\r\nif (!cable->identity)\r\nreturn -EINVAL;\r\ntypec_report_identity(&cable->dev);\r\nreturn 0;\r\n}\r\nstruct typec_cable *typec_register_cable(struct typec_port *port,\r\nstruct typec_cable_desc *desc)\r\n{\r\nstruct typec_cable *cable;\r\nint ret;\r\ncable = kzalloc(sizeof(*cable), GFP_KERNEL);\r\nif (!cable)\r\nreturn NULL;\r\ncable->type = desc->type;\r\ncable->active = desc->active;\r\nif (desc->identity) {\r\ncable->dev.groups = usb_pd_id_groups;\r\ncable->identity = desc->identity;\r\n}\r\ncable->dev.class = typec_class;\r\ncable->dev.parent = &port->dev;\r\ncable->dev.type = &typec_cable_dev_type;\r\ndev_set_name(&cable->dev, "%s-cable", dev_name(&port->dev));\r\nret = device_register(&cable->dev);\r\nif (ret) {\r\ndev_err(&port->dev, "failed to register cable (%d)\n", ret);\r\nput_device(&cable->dev);\r\nreturn NULL;\r\n}\r\nreturn cable;\r\n}\r\nvoid typec_unregister_cable(struct typec_cable *cable)\r\n{\r\nif (cable)\r\ndevice_unregister(&cable->dev);\r\n}\r\nstatic ssize_t\r\npreferred_role_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct typec_port *port = to_typec_port(dev);\r\nint role;\r\nint ret;\r\nif (port->cap->type != TYPEC_PORT_DRP) {\r\ndev_dbg(dev, "Preferred role only supported with DRP ports\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (!port->cap->try_role) {\r\ndev_dbg(dev, "Setting preferred role not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nrole = sysfs_match_string(typec_roles, buf);\r\nif (role < 0) {\r\nif (sysfs_streq(buf, "none"))\r\nrole = TYPEC_NO_PREFERRED_ROLE;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nret = port->cap->try_role(port->cap, role);\r\nif (ret)\r\nreturn ret;\r\nport->prefer_role = role;\r\nreturn size;\r\n}\r\nstatic ssize_t\r\npreferred_role_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct typec_port *port = to_typec_port(dev);\r\nif (port->cap->type != TYPEC_PORT_DRP)\r\nreturn 0;\r\nif (port->prefer_role < 0)\r\nreturn 0;\r\nreturn sprintf(buf, "%s\n", typec_roles[port->prefer_role]);\r\n}\r\nstatic ssize_t data_role_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct typec_port *port = to_typec_port(dev);\r\nint ret;\r\nif (!port->cap->dr_set) {\r\ndev_dbg(dev, "data role swapping not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nret = sysfs_match_string(typec_data_roles, buf);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&port->port_type_lock);\r\nif (port->port_type != TYPEC_PORT_DRP) {\r\ndev_dbg(dev, "port type fixed at \"%s\"",\r\ntypec_port_types[port->port_type]);\r\nret = -EOPNOTSUPP;\r\ngoto unlock_and_ret;\r\n}\r\nret = port->cap->dr_set(port->cap, ret);\r\nif (ret)\r\ngoto unlock_and_ret;\r\nret = size;\r\nunlock_and_ret:\r\nmutex_unlock(&port->port_type_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t data_role_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct typec_port *port = to_typec_port(dev);\r\nif (port->cap->type == TYPEC_PORT_DRP)\r\nreturn sprintf(buf, "%s\n", port->data_role == TYPEC_HOST ?\r\n"[host] device" : "host [device]");\r\nreturn sprintf(buf, "[%s]\n", typec_data_roles[port->data_role]);\r\n}\r\nstatic ssize_t power_role_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct typec_port *port = to_typec_port(dev);\r\nint ret;\r\nif (!port->cap->pd_revision) {\r\ndev_dbg(dev, "USB Power Delivery not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (!port->cap->pr_set) {\r\ndev_dbg(dev, "power role swapping not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (port->pwr_opmode != TYPEC_PWR_MODE_PD) {\r\ndev_dbg(dev, "partner unable to swap power role\n");\r\nreturn -EIO;\r\n}\r\nret = sysfs_match_string(typec_roles, buf);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&port->port_type_lock);\r\nif (port->port_type != TYPEC_PORT_DRP) {\r\ndev_dbg(dev, "port type fixed at \"%s\"",\r\ntypec_port_types[port->port_type]);\r\nret = -EOPNOTSUPP;\r\ngoto unlock_and_ret;\r\n}\r\nret = port->cap->pr_set(port->cap, ret);\r\nif (ret)\r\ngoto unlock_and_ret;\r\nret = size;\r\nunlock_and_ret:\r\nmutex_unlock(&port->port_type_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t power_role_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct typec_port *port = to_typec_port(dev);\r\nif (port->cap->type == TYPEC_PORT_DRP)\r\nreturn sprintf(buf, "%s\n", port->pwr_role == TYPEC_SOURCE ?\r\n"[source] sink" : "source [sink]");\r\nreturn sprintf(buf, "[%s]\n", typec_roles[port->pwr_role]);\r\n}\r\nstatic ssize_t\r\nport_type_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct typec_port *port = to_typec_port(dev);\r\nint ret;\r\nenum typec_port_type type;\r\nif (!port->cap->port_type_set || port->cap->type != TYPEC_PORT_DRP) {\r\ndev_dbg(dev, "changing port type not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nret = sysfs_match_string(typec_port_types, buf);\r\nif (ret < 0)\r\nreturn ret;\r\ntype = ret;\r\nmutex_lock(&port->port_type_lock);\r\nif (port->port_type == type) {\r\nret = size;\r\ngoto unlock_and_ret;\r\n}\r\nret = port->cap->port_type_set(port->cap, type);\r\nif (ret)\r\ngoto unlock_and_ret;\r\nport->port_type = type;\r\nret = size;\r\nunlock_and_ret:\r\nmutex_unlock(&port->port_type_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nport_type_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct typec_port *port = to_typec_port(dev);\r\nif (port->cap->type == TYPEC_PORT_DRP)\r\nreturn sprintf(buf, "%s\n",\r\ntypec_port_types_drp[port->port_type]);\r\nreturn sprintf(buf, "[%s]\n", typec_port_types[port->cap->type]);\r\n}\r\nstatic ssize_t power_operation_mode_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct typec_port *port = to_typec_port(dev);\r\nreturn sprintf(buf, "%s\n", typec_pwr_opmodes[port->pwr_opmode]);\r\n}\r\nstatic ssize_t vconn_source_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct typec_port *port = to_typec_port(dev);\r\nbool source;\r\nint ret;\r\nif (!port->cap->pd_revision) {\r\ndev_dbg(dev, "VCONN swap depends on USB Power Delivery\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (!port->cap->vconn_set) {\r\ndev_dbg(dev, "VCONN swapping not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nret = kstrtobool(buf, &source);\r\nif (ret)\r\nreturn ret;\r\nret = port->cap->vconn_set(port->cap, (enum typec_role)source);\r\nif (ret)\r\nreturn ret;\r\nreturn size;\r\n}\r\nstatic ssize_t vconn_source_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct typec_port *port = to_typec_port(dev);\r\nreturn sprintf(buf, "%s\n",\r\nport->vconn_role == TYPEC_SOURCE ? "yes" : "no");\r\n}\r\nstatic ssize_t supported_accessory_modes_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct typec_port *port = to_typec_port(dev);\r\nssize_t ret = 0;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(port->cap->accessory); i++) {\r\nif (port->cap->accessory[i])\r\nret += sprintf(buf + ret, "%s ",\r\ntypec_accessory_modes[port->cap->accessory[i]]);\r\n}\r\nif (!ret)\r\nreturn sprintf(buf, "none\n");\r\nbuf[ret - 1] = '\n';\r\nreturn ret;\r\n}\r\nstatic ssize_t usb_typec_revision_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct typec_port *port = to_typec_port(dev);\r\nu16 rev = port->cap->revision;\r\nreturn sprintf(buf, "%d.%d\n", (rev >> 8) & 0xff, (rev >> 4) & 0xf);\r\n}\r\nstatic ssize_t usb_power_delivery_revision_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct typec_port *p = to_typec_port(dev);\r\nreturn sprintf(buf, "%d\n", (p->cap->pd_revision >> 8) & 0xff);\r\n}\r\nstatic int typec_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nint ret;\r\nret = add_uevent_var(env, "TYPEC_PORT=%s", dev_name(dev));\r\nif (ret)\r\ndev_err(dev, "failed to add uevent TYPEC_PORT\n");\r\nreturn ret;\r\n}\r\nstatic void typec_release(struct device *dev)\r\n{\r\nstruct typec_port *port = to_typec_port(dev);\r\nida_simple_remove(&typec_index_ida, port->id);\r\nkfree(port);\r\n}\r\nvoid typec_set_data_role(struct typec_port *port, enum typec_data_role role)\r\n{\r\nif (port->data_role == role)\r\nreturn;\r\nport->data_role = role;\r\nsysfs_notify(&port->dev.kobj, NULL, "data_role");\r\nkobject_uevent(&port->dev.kobj, KOBJ_CHANGE);\r\n}\r\nvoid typec_set_pwr_role(struct typec_port *port, enum typec_role role)\r\n{\r\nif (port->pwr_role == role)\r\nreturn;\r\nport->pwr_role = role;\r\nsysfs_notify(&port->dev.kobj, NULL, "power_role");\r\nkobject_uevent(&port->dev.kobj, KOBJ_CHANGE);\r\n}\r\nvoid typec_set_vconn_role(struct typec_port *port, enum typec_role role)\r\n{\r\nif (port->vconn_role == role)\r\nreturn;\r\nport->vconn_role = role;\r\nsysfs_notify(&port->dev.kobj, NULL, "vconn_source");\r\nkobject_uevent(&port->dev.kobj, KOBJ_CHANGE);\r\n}\r\nstatic int partner_match(struct device *dev, void *data)\r\n{\r\nreturn is_typec_partner(dev);\r\n}\r\nvoid typec_set_pwr_opmode(struct typec_port *port,\r\nenum typec_pwr_opmode opmode)\r\n{\r\nstruct device *partner_dev;\r\nif (port->pwr_opmode == opmode)\r\nreturn;\r\nport->pwr_opmode = opmode;\r\nsysfs_notify(&port->dev.kobj, NULL, "power_operation_mode");\r\nkobject_uevent(&port->dev.kobj, KOBJ_CHANGE);\r\npartner_dev = device_find_child(&port->dev, NULL, partner_match);\r\nif (partner_dev) {\r\nstruct typec_partner *partner = to_typec_partner(partner_dev);\r\nif (opmode == TYPEC_PWR_MODE_PD && !partner->usb_pd) {\r\npartner->usb_pd = 1;\r\nsysfs_notify(&partner_dev->kobj, NULL,\r\n"supports_usb_power_delivery");\r\n}\r\nput_device(partner_dev);\r\n}\r\n}\r\nstruct typec_altmode *\r\ntypec_port_register_altmode(struct typec_port *port,\r\nconst struct typec_altmode_desc *desc)\r\n{\r\nreturn typec_register_altmode(&port->dev, desc);\r\n}\r\nstruct typec_port *typec_register_port(struct device *parent,\r\nconst struct typec_capability *cap)\r\n{\r\nstruct typec_port *port;\r\nint role;\r\nint ret;\r\nint id;\r\nport = kzalloc(sizeof(*port), GFP_KERNEL);\r\nif (!port)\r\nreturn NULL;\r\nid = ida_simple_get(&typec_index_ida, 0, 0, GFP_KERNEL);\r\nif (id < 0) {\r\nkfree(port);\r\nreturn NULL;\r\n}\r\nif (cap->type == TYPEC_PORT_DFP)\r\nrole = TYPEC_SOURCE;\r\nelse if (cap->type == TYPEC_PORT_UFP)\r\nrole = TYPEC_SINK;\r\nelse\r\nrole = cap->prefer_role;\r\nif (role == TYPEC_SOURCE) {\r\nport->data_role = TYPEC_HOST;\r\nport->pwr_role = TYPEC_SOURCE;\r\nport->vconn_role = TYPEC_SOURCE;\r\n} else {\r\nport->data_role = TYPEC_DEVICE;\r\nport->pwr_role = TYPEC_SINK;\r\nport->vconn_role = TYPEC_SINK;\r\n}\r\nport->id = id;\r\nport->cap = cap;\r\nport->port_type = cap->type;\r\nmutex_init(&port->port_type_lock);\r\nport->prefer_role = cap->prefer_role;\r\nport->dev.class = typec_class;\r\nport->dev.parent = parent;\r\nport->dev.fwnode = cap->fwnode;\r\nport->dev.type = &typec_port_dev_type;\r\ndev_set_name(&port->dev, "port%d", id);\r\nret = device_register(&port->dev);\r\nif (ret) {\r\ndev_err(parent, "failed to register port (%d)\n", ret);\r\nput_device(&port->dev);\r\nreturn NULL;\r\n}\r\nreturn port;\r\n}\r\nvoid typec_unregister_port(struct typec_port *port)\r\n{\r\nif (port)\r\ndevice_unregister(&port->dev);\r\n}\r\nstatic int __init typec_init(void)\r\n{\r\ntypec_class = class_create(THIS_MODULE, "typec");\r\nreturn PTR_ERR_OR_ZERO(typec_class);\r\n}\r\nstatic void __exit typec_exit(void)\r\n{\r\nclass_destroy(typec_class);\r\nida_destroy(&typec_index_ida);\r\n}
