static inline struct f_uac1 *func_to_uac1(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_uac1, g_audio.func);\r\n}\r\nstatic int audio_set_endpoint_req(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nint value = -EOPNOTSUPP;\r\nu16 ep = le16_to_cpu(ctrl->wIndex);\r\nu16 len = le16_to_cpu(ctrl->wLength);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nDBG(cdev, "bRequest 0x%x, w_value 0x%04x, len %d, endpoint %d\n",\r\nctrl->bRequest, w_value, len, ep);\r\nswitch (ctrl->bRequest) {\r\ncase UAC_SET_CUR:\r\nvalue = len;\r\nbreak;\r\ncase UAC_SET_MIN:\r\nbreak;\r\ncase UAC_SET_MAX:\r\nbreak;\r\ncase UAC_SET_RES:\r\nbreak;\r\ncase UAC_SET_MEM:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn value;\r\n}\r\nstatic int audio_get_endpoint_req(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nint value = -EOPNOTSUPP;\r\nu8 ep = ((le16_to_cpu(ctrl->wIndex) >> 8) & 0xFF);\r\nu16 len = le16_to_cpu(ctrl->wLength);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nDBG(cdev, "bRequest 0x%x, w_value 0x%04x, len %d, endpoint %d\n",\r\nctrl->bRequest, w_value, len, ep);\r\nswitch (ctrl->bRequest) {\r\ncase UAC_GET_CUR:\r\ncase UAC_GET_MIN:\r\ncase UAC_GET_MAX:\r\ncase UAC_GET_RES:\r\nvalue = len;\r\nbreak;\r\ncase UAC_GET_MEM:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn value;\r\n}\r\nstatic int\r\nf_audio_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_request *req = cdev->req;\r\nint value = -EOPNOTSUPP;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nswitch (ctrl->bRequestType) {\r\ncase USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_ENDPOINT:\r\nvalue = audio_set_endpoint_req(f, ctrl);\r\nbreak;\r\ncase USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT:\r\nvalue = audio_get_endpoint_req(f, ctrl);\r\nbreak;\r\ndefault:\r\nERROR(cdev, "invalid control req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\n}\r\nif (value >= 0) {\r\nDBG(cdev, "audio req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\nreq->zero = 0;\r\nreq->length = value;\r\nvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0)\r\nERROR(cdev, "audio response on err %d\n", value);\r\n}\r\nreturn value;\r\n}\r\nstatic int f_audio_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct device *dev = &gadget->dev;\r\nstruct f_uac1 *uac1 = func_to_uac1(f);\r\nint ret = 0;\r\nif (alt > 1) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nif (intf == uac1->ac_intf) {\r\nif (alt) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nif (intf == uac1->as_out_intf) {\r\nuac1->as_out_alt = alt;\r\nif (alt)\r\nret = u_audio_start_capture(&uac1->g_audio);\r\nelse\r\nu_audio_stop_capture(&uac1->g_audio);\r\n} else if (intf == uac1->as_in_intf) {\r\nuac1->as_in_alt = alt;\r\nif (alt)\r\nret = u_audio_start_playback(&uac1->g_audio);\r\nelse\r\nu_audio_stop_playback(&uac1->g_audio);\r\n} else {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int f_audio_get_alt(struct usb_function *f, unsigned intf)\r\n{\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct device *dev = &gadget->dev;\r\nstruct f_uac1 *uac1 = func_to_uac1(f);\r\nif (intf == uac1->ac_intf)\r\nreturn uac1->ac_alt;\r\nelse if (intf == uac1->as_out_intf)\r\nreturn uac1->as_out_alt;\r\nelse if (intf == uac1->as_in_intf)\r\nreturn uac1->as_in_alt;\r\nelse\r\ndev_err(dev, "%s:%d Invalid Interface %d!\n",\r\n__func__, __LINE__, intf);\r\nreturn -EINVAL;\r\n}\r\nstatic void f_audio_disable(struct usb_function *f)\r\n{\r\nstruct f_uac1 *uac1 = func_to_uac1(f);\r\nuac1->as_out_alt = 0;\r\nuac1->as_in_alt = 0;\r\nu_audio_stop_capture(&uac1->g_audio);\r\n}\r\nstatic int f_audio_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct f_uac1 *uac1 = func_to_uac1(f);\r\nstruct g_audio *audio = func_to_g_audio(f);\r\nstruct f_uac1_opts *audio_opts;\r\nstruct usb_ep *ep = NULL;\r\nstruct usb_string *us;\r\nu8 *sam_freq;\r\nint rate;\r\nint status;\r\naudio_opts = container_of(f->fi, struct f_uac1_opts, func_inst);\r\nus = usb_gstrings_attach(cdev, uac1_strings, ARRAY_SIZE(strings_uac1));\r\nif (IS_ERR(us))\r\nreturn PTR_ERR(us);\r\nac_interface_desc.iInterface = us[STR_AC_IF].id;\r\nusb_out_it_desc.iTerminal = us[STR_USB_OUT_IT].id;\r\nusb_out_it_desc.iChannelNames = us[STR_USB_OUT_IT_CH_NAMES].id;\r\nio_out_ot_desc.iTerminal = us[STR_IO_OUT_OT].id;\r\nas_out_interface_alt_0_desc.iInterface = us[STR_AS_OUT_IF_ALT0].id;\r\nas_out_interface_alt_1_desc.iInterface = us[STR_AS_OUT_IF_ALT1].id;\r\nio_in_it_desc.iTerminal = us[STR_IO_IN_IT].id;\r\nio_in_it_desc.iChannelNames = us[STR_IO_IN_IT_CH_NAMES].id;\r\nusb_in_ot_desc.iTerminal = us[STR_USB_IN_OT].id;\r\nas_in_interface_alt_0_desc.iInterface = us[STR_AS_IN_IF_ALT0].id;\r\nas_in_interface_alt_1_desc.iInterface = us[STR_AS_IN_IF_ALT1].id;\r\nusb_out_it_desc.bNrChannels = num_channels(audio_opts->c_chmask);\r\nusb_out_it_desc.wChannelConfig = cpu_to_le16(audio_opts->c_chmask);\r\nas_out_type_i_desc.bNrChannels = num_channels(audio_opts->c_chmask);\r\nas_out_type_i_desc.bSubframeSize = audio_opts->c_ssize;\r\nas_out_type_i_desc.bBitResolution = audio_opts->c_ssize * 8;\r\nio_in_it_desc.bNrChannels = num_channels(audio_opts->p_chmask);\r\nio_in_it_desc.wChannelConfig = cpu_to_le16(audio_opts->p_chmask);\r\nas_in_type_i_desc.bNrChannels = num_channels(audio_opts->p_chmask);\r\nas_in_type_i_desc.bSubframeSize = audio_opts->p_ssize;\r\nas_in_type_i_desc.bBitResolution = audio_opts->p_ssize * 8;\r\nrate = audio_opts->c_srate;\r\nsam_freq = as_out_type_i_desc.tSamFreq[0];\r\nmemcpy(sam_freq, &rate, 3);\r\nrate = audio_opts->p_srate;\r\nsam_freq = as_in_type_i_desc.tSamFreq[0];\r\nmemcpy(sam_freq, &rate, 3);\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nac_interface_desc.bInterfaceNumber = status;\r\nuac1->ac_intf = status;\r\nuac1->ac_alt = 0;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nas_out_interface_alt_0_desc.bInterfaceNumber = status;\r\nas_out_interface_alt_1_desc.bInterfaceNumber = status;\r\nuac1->as_out_intf = status;\r\nuac1->as_out_alt = 0;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nas_in_interface_alt_0_desc.bInterfaceNumber = status;\r\nas_in_interface_alt_1_desc.bInterfaceNumber = status;\r\nuac1->as_in_intf = status;\r\nuac1->as_in_alt = 0;\r\naudio->gadget = gadget;\r\nstatus = -ENODEV;\r\nep = usb_ep_autoconfig(cdev->gadget, &as_out_ep_desc);\r\nif (!ep)\r\ngoto fail;\r\naudio->out_ep = ep;\r\naudio->out_ep->desc = &as_out_ep_desc;\r\nep = usb_ep_autoconfig(cdev->gadget, &as_in_ep_desc);\r\nif (!ep)\r\ngoto fail;\r\naudio->in_ep = ep;\r\naudio->in_ep->desc = &as_in_ep_desc;\r\nstatus = usb_assign_descriptors(f, f_audio_desc, f_audio_desc, NULL,\r\nNULL);\r\nif (status)\r\ngoto fail;\r\naudio->out_ep_maxpsize = le16_to_cpu(as_out_ep_desc.wMaxPacketSize);\r\naudio->in_ep_maxpsize = le16_to_cpu(as_in_ep_desc.wMaxPacketSize);\r\naudio->params.c_chmask = audio_opts->c_chmask;\r\naudio->params.c_srate = audio_opts->c_srate;\r\naudio->params.c_ssize = audio_opts->c_ssize;\r\naudio->params.p_chmask = audio_opts->p_chmask;\r\naudio->params.p_srate = audio_opts->p_srate;\r\naudio->params.p_ssize = audio_opts->p_ssize;\r\naudio->params.req_number = audio_opts->req_number;\r\nstatus = g_audio_setup(audio, "UAC1_PCM", "UAC1_Gadget");\r\nif (status)\r\ngoto err_card_register;\r\nreturn 0;\r\nerr_card_register:\r\nusb_free_all_descriptors(f);\r\nfail:\r\nreturn status;\r\n}\r\nstatic inline struct f_uac1_opts *to_f_uac1_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_uac1_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void f_uac1_attr_release(struct config_item *item)\r\n{\r\nstruct f_uac1_opts *opts = to_f_uac1_opts(item);\r\nusb_put_function_instance(&opts->func_inst);\r\n}\r\nstatic void f_audio_free_inst(struct usb_function_instance *f)\r\n{\r\nstruct f_uac1_opts *opts;\r\nopts = container_of(f, struct f_uac1_opts, func_inst);\r\nkfree(opts);\r\n}\r\nstatic struct usb_function_instance *f_audio_alloc_inst(void)\r\n{\r\nstruct f_uac1_opts *opts;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&opts->lock);\r\nopts->func_inst.free_func_inst = f_audio_free_inst;\r\nconfig_group_init_type_name(&opts->func_inst.group, "",\r\n&f_uac1_func_type);\r\nopts->c_chmask = UAC1_DEF_CCHMASK;\r\nopts->c_srate = UAC1_DEF_CSRATE;\r\nopts->c_ssize = UAC1_DEF_CSSIZE;\r\nopts->p_chmask = UAC1_DEF_PCHMASK;\r\nopts->p_srate = UAC1_DEF_PSRATE;\r\nopts->p_ssize = UAC1_DEF_PSSIZE;\r\nopts->req_number = UAC1_DEF_REQ_NUM;\r\nreturn &opts->func_inst;\r\n}\r\nstatic void f_audio_free(struct usb_function *f)\r\n{\r\nstruct g_audio *audio;\r\nstruct f_uac1_opts *opts;\r\naudio = func_to_g_audio(f);\r\nopts = container_of(f->fi, struct f_uac1_opts, func_inst);\r\nkfree(audio);\r\nmutex_lock(&opts->lock);\r\n--opts->refcnt;\r\nmutex_unlock(&opts->lock);\r\n}\r\nstatic void f_audio_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct g_audio *audio = func_to_g_audio(f);\r\ng_audio_cleanup(audio);\r\nusb_free_all_descriptors(f);\r\naudio->gadget = NULL;\r\n}\r\nstatic struct usb_function *f_audio_alloc(struct usb_function_instance *fi)\r\n{\r\nstruct f_uac1 *uac1;\r\nstruct f_uac1_opts *opts;\r\nuac1 = kzalloc(sizeof(*uac1), GFP_KERNEL);\r\nif (!uac1)\r\nreturn ERR_PTR(-ENOMEM);\r\nopts = container_of(fi, struct f_uac1_opts, func_inst);\r\nmutex_lock(&opts->lock);\r\n++opts->refcnt;\r\nmutex_unlock(&opts->lock);\r\nuac1->g_audio.func.name = "uac1_func";\r\nuac1->g_audio.func.bind = f_audio_bind;\r\nuac1->g_audio.func.unbind = f_audio_unbind;\r\nuac1->g_audio.func.set_alt = f_audio_set_alt;\r\nuac1->g_audio.func.get_alt = f_audio_get_alt;\r\nuac1->g_audio.func.setup = f_audio_setup;\r\nuac1->g_audio.func.disable = f_audio_disable;\r\nuac1->g_audio.func.free_func = f_audio_free;\r\nreturn &uac1->g_audio.func;\r\n}
