static bool cap11xx_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CAP11XX_REG_MAIN_CONTROL:\r\ncase CAP11XX_REG_SENSOR_INPUT:\r\ncase CAP11XX_REG_SENOR_DELTA(0):\r\ncase CAP11XX_REG_SENOR_DELTA(1):\r\ncase CAP11XX_REG_SENOR_DELTA(2):\r\ncase CAP11XX_REG_SENOR_DELTA(3):\r\ncase CAP11XX_REG_SENOR_DELTA(4):\r\ncase CAP11XX_REG_SENOR_DELTA(5):\r\ncase CAP11XX_REG_PRODUCT_ID:\r\ncase CAP11XX_REG_MANUFACTURER_ID:\r\ncase CAP11XX_REG_REVISION:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic irqreturn_t cap11xx_thread_func(int irq_num, void *data)\r\n{\r\nstruct cap11xx_priv *priv = data;\r\nunsigned int status;\r\nint ret, i;\r\nret = regmap_update_bits(priv->regmap, CAP11XX_REG_MAIN_CONTROL, 1, 0);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_read(priv->regmap, CAP11XX_REG_SENSOR_INPUT, &status);\r\nif (ret < 0)\r\ngoto out;\r\nfor (i = 0; i < priv->idev->keycodemax; i++)\r\ninput_report_key(priv->idev, priv->keycodes[i],\r\nstatus & (1 << i));\r\ninput_sync(priv->idev);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cap11xx_set_sleep(struct cap11xx_priv *priv, bool sleep)\r\n{\r\nif (IS_ENABLED(CONFIG_LEDS_CLASS) && priv->num_leds)\r\nreturn 0;\r\nreturn regmap_update_bits(priv->regmap, CAP11XX_REG_MAIN_CONTROL,\r\nCAP11XX_REG_MAIN_CONTROL_DLSEEP,\r\nsleep ? CAP11XX_REG_MAIN_CONTROL_DLSEEP : 0);\r\n}\r\nstatic int cap11xx_input_open(struct input_dev *idev)\r\n{\r\nstruct cap11xx_priv *priv = input_get_drvdata(idev);\r\nreturn cap11xx_set_sleep(priv, false);\r\n}\r\nstatic void cap11xx_input_close(struct input_dev *idev)\r\n{\r\nstruct cap11xx_priv *priv = input_get_drvdata(idev);\r\ncap11xx_set_sleep(priv, true);\r\n}\r\nstatic void cap11xx_led_work(struct work_struct *work)\r\n{\r\nstruct cap11xx_led *led = container_of(work, struct cap11xx_led, work);\r\nstruct cap11xx_priv *priv = led->priv;\r\nint value = led->new_brightness;\r\nregmap_update_bits(priv->regmap, CAP11XX_REG_LED_OUTPUT_CONTROL,\r\nBIT(led->reg), value ? BIT(led->reg) : 0);\r\n}\r\nstatic void cap11xx_led_set(struct led_classdev *cdev,\r\nenum led_brightness value)\r\n{\r\nstruct cap11xx_led *led = container_of(cdev, struct cap11xx_led, cdev);\r\nif (led->new_brightness == value)\r\nreturn;\r\nled->new_brightness = value;\r\nschedule_work(&led->work);\r\n}\r\nstatic int cap11xx_init_leds(struct device *dev,\r\nstruct cap11xx_priv *priv, int num_leds)\r\n{\r\nstruct device_node *node = dev->of_node, *child;\r\nstruct cap11xx_led *led;\r\nint cnt = of_get_child_count(node);\r\nint error;\r\nif (!num_leds || !cnt)\r\nreturn 0;\r\nif (cnt > num_leds)\r\nreturn -EINVAL;\r\nled = devm_kcalloc(dev, cnt, sizeof(struct cap11xx_led), GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\npriv->leds = led;\r\nerror = regmap_update_bits(priv->regmap,\r\nCAP11XX_REG_LED_OUTPUT_CONTROL, 0xff, 0);\r\nif (error)\r\nreturn error;\r\nerror = regmap_update_bits(priv->regmap, CAP11XX_REG_LED_DUTY_CYCLE_4,\r\nCAP11XX_REG_LED_DUTY_MAX_MASK,\r\nCAP11XX_REG_LED_DUTY_MAX_VALUE <<\r\nCAP11XX_REG_LED_DUTY_MAX_MASK_SHIFT);\r\nif (error)\r\nreturn error;\r\nfor_each_child_of_node(node, child) {\r\nu32 reg;\r\nled->cdev.name =\r\nof_get_property(child, "label", NULL) ? : child->name;\r\nled->cdev.default_trigger =\r\nof_get_property(child, "linux,default-trigger", NULL);\r\nled->cdev.flags = 0;\r\nled->cdev.brightness_set = cap11xx_led_set;\r\nled->cdev.max_brightness = 1;\r\nled->cdev.brightness = LED_OFF;\r\nerror = of_property_read_u32(child, "reg", &reg);\r\nif (error != 0 || reg >= num_leds) {\r\nof_node_put(child);\r\nreturn -EINVAL;\r\n}\r\nled->reg = reg;\r\nled->priv = priv;\r\nINIT_WORK(&led->work, cap11xx_led_work);\r\nerror = devm_led_classdev_register(dev, &led->cdev);\r\nif (error) {\r\nof_node_put(child);\r\nreturn error;\r\n}\r\npriv->num_leds++;\r\nled++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cap11xx_init_leds(struct device *dev,\r\nstruct cap11xx_priv *priv, int num_leds)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cap11xx_i2c_probe(struct i2c_client *i2c_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &i2c_client->dev;\r\nstruct cap11xx_priv *priv;\r\nstruct device_node *node;\r\nconst struct cap11xx_hw_model *cap;\r\nint i, error, irq, gain = 0;\r\nunsigned int val, rev;\r\nu32 gain32;\r\nif (id->driver_data >= ARRAY_SIZE(cap11xx_devices)) {\r\ndev_err(dev, "Invalid device ID %lu\n", id->driver_data);\r\nreturn -EINVAL;\r\n}\r\ncap = &cap11xx_devices[id->driver_data];\r\nif (!cap || !cap->num_channels) {\r\ndev_err(dev, "Invalid device configuration\n");\r\nreturn -EINVAL;\r\n}\r\npriv = devm_kzalloc(dev,\r\nsizeof(*priv) +\r\ncap->num_channels * sizeof(priv->keycodes[0]),\r\nGFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->regmap = devm_regmap_init_i2c(i2c_client, &cap11xx_regmap_config);\r\nif (IS_ERR(priv->regmap))\r\nreturn PTR_ERR(priv->regmap);\r\nerror = regmap_read(priv->regmap, CAP11XX_REG_PRODUCT_ID, &val);\r\nif (error)\r\nreturn error;\r\nif (val != cap->product_id) {\r\ndev_err(dev, "Product ID: Got 0x%02x, expected 0x%02x\n",\r\nval, cap->product_id);\r\nreturn -ENXIO;\r\n}\r\nerror = regmap_read(priv->regmap, CAP11XX_REG_MANUFACTURER_ID, &val);\r\nif (error)\r\nreturn error;\r\nif (val != CAP11XX_MANUFACTURER_ID) {\r\ndev_err(dev, "Manufacturer ID: Got 0x%02x, expected 0x%02x\n",\r\nval, CAP11XX_MANUFACTURER_ID);\r\nreturn -ENXIO;\r\n}\r\nerror = regmap_read(priv->regmap, CAP11XX_REG_REVISION, &rev);\r\nif (error < 0)\r\nreturn error;\r\ndev_info(dev, "CAP11XX detected, revision 0x%02x\n", rev);\r\nnode = dev->of_node;\r\nif (!of_property_read_u32(node, "microchip,sensor-gain", &gain32)) {\r\nif (is_power_of_2(gain32) && gain32 <= 8)\r\ngain = ilog2(gain32);\r\nelse\r\ndev_err(dev, "Invalid sensor-gain value %d\n", gain32);\r\n}\r\nif (of_property_read_bool(node, "microchip,irq-active-high")) {\r\nerror = regmap_update_bits(priv->regmap, CAP11XX_REG_CONFIG2,\r\nCAP11XX_REG_CONFIG2_ALT_POL, 0);\r\nif (error)\r\nreturn error;\r\n}\r\nfor (i = 0; i < cap->num_channels; i++)\r\npriv->keycodes[i] = KEY_A + i;\r\nof_property_read_u32_array(node, "linux,keycodes",\r\npriv->keycodes, cap->num_channels);\r\nerror = regmap_update_bits(priv->regmap, CAP11XX_REG_MAIN_CONTROL,\r\nCAP11XX_REG_MAIN_CONTROL_GAIN_MASK,\r\ngain << CAP11XX_REG_MAIN_CONTROL_GAIN_SHIFT);\r\nif (error)\r\nreturn error;\r\nerror = regmap_write(priv->regmap, CAP11XX_REG_REPEAT_RATE, 0);\r\nif (error)\r\nreturn error;\r\npriv->idev = devm_input_allocate_device(dev);\r\nif (!priv->idev)\r\nreturn -ENOMEM;\r\npriv->idev->name = "CAP11XX capacitive touch sensor";\r\npriv->idev->id.bustype = BUS_I2C;\r\npriv->idev->evbit[0] = BIT_MASK(EV_KEY);\r\nif (of_property_read_bool(node, "autorepeat"))\r\n__set_bit(EV_REP, priv->idev->evbit);\r\nfor (i = 0; i < cap->num_channels; i++)\r\n__set_bit(priv->keycodes[i], priv->idev->keybit);\r\n__clear_bit(KEY_RESERVED, priv->idev->keybit);\r\npriv->idev->keycode = priv->keycodes;\r\npriv->idev->keycodesize = sizeof(priv->keycodes[0]);\r\npriv->idev->keycodemax = cap->num_channels;\r\npriv->idev->id.vendor = CAP11XX_MANUFACTURER_ID;\r\npriv->idev->id.product = cap->product_id;\r\npriv->idev->id.version = rev;\r\npriv->idev->open = cap11xx_input_open;\r\npriv->idev->close = cap11xx_input_close;\r\nerror = cap11xx_init_leds(dev, priv, cap->num_leds);\r\nif (error)\r\nreturn error;\r\ninput_set_drvdata(priv->idev, priv);\r\ncap11xx_set_sleep(priv, true);\r\nerror = input_register_device(priv->idev);\r\nif (error)\r\nreturn error;\r\nirq = irq_of_parse_and_map(node, 0);\r\nif (!irq) {\r\ndev_err(dev, "Unable to parse or map IRQ\n");\r\nreturn -ENXIO;\r\n}\r\nerror = devm_request_threaded_irq(dev, irq, NULL, cap11xx_thread_func,\r\nIRQF_ONESHOT, dev_name(dev), priv);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}
