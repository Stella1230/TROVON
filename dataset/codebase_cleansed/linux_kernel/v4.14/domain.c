static ssize_t security_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tb *tb = container_of(dev, struct tb, dev);\r\nreturn sprintf(buf, "%s\n", tb_security_names[tb->security_level]);\r\n}\r\nstatic void tb_domain_release(struct device *dev)\r\n{\r\nstruct tb *tb = container_of(dev, struct tb, dev);\r\ntb_ctl_free(tb->ctl);\r\ndestroy_workqueue(tb->wq);\r\nida_simple_remove(&tb_domain_ida, tb->index);\r\nmutex_destroy(&tb->lock);\r\nkfree(tb);\r\n}\r\nstruct tb *tb_domain_alloc(struct tb_nhi *nhi, size_t privsize)\r\n{\r\nstruct tb *tb;\r\nBUILD_BUG_ON(sizeof(struct tb_regs_switch_header) != 5 * 4);\r\nBUILD_BUG_ON(sizeof(struct tb_regs_port_header) != 8 * 4);\r\nBUILD_BUG_ON(sizeof(struct tb_regs_hop) != 2 * 4);\r\ntb = kzalloc(sizeof(*tb) + privsize, GFP_KERNEL);\r\nif (!tb)\r\nreturn NULL;\r\ntb->nhi = nhi;\r\nmutex_init(&tb->lock);\r\ntb->index = ida_simple_get(&tb_domain_ida, 0, 0, GFP_KERNEL);\r\nif (tb->index < 0)\r\ngoto err_free;\r\ntb->wq = alloc_ordered_workqueue("thunderbolt%d", 0, tb->index);\r\nif (!tb->wq)\r\ngoto err_remove_ida;\r\ntb->dev.parent = &nhi->pdev->dev;\r\ntb->dev.bus = &tb_bus_type;\r\ntb->dev.type = &tb_domain_type;\r\ntb->dev.groups = domain_attr_groups;\r\ndev_set_name(&tb->dev, "domain%d", tb->index);\r\ndevice_initialize(&tb->dev);\r\nreturn tb;\r\nerr_remove_ida:\r\nida_simple_remove(&tb_domain_ida, tb->index);\r\nerr_free:\r\nkfree(tb);\r\nreturn NULL;\r\n}\r\nstatic void tb_domain_event_cb(void *data, enum tb_cfg_pkg_type type,\r\nconst void *buf, size_t size)\r\n{\r\nstruct tb *tb = data;\r\nif (!tb->cm_ops->handle_event) {\r\ntb_warn(tb, "domain does not have event handler\n");\r\nreturn;\r\n}\r\ntb->cm_ops->handle_event(tb, type, buf, size);\r\n}\r\nint tb_domain_add(struct tb *tb)\r\n{\r\nint ret;\r\nif (WARN_ON(!tb->cm_ops))\r\nreturn -EINVAL;\r\nmutex_lock(&tb->lock);\r\ntb->ctl = tb_ctl_alloc(tb->nhi, tb_domain_event_cb, tb);\r\nif (!tb->ctl) {\r\nret = -ENOMEM;\r\ngoto err_unlock;\r\n}\r\ntb_ctl_start(tb->ctl);\r\nif (tb->cm_ops->driver_ready) {\r\nret = tb->cm_ops->driver_ready(tb);\r\nif (ret)\r\ngoto err_ctl_stop;\r\n}\r\nret = device_add(&tb->dev);\r\nif (ret)\r\ngoto err_ctl_stop;\r\nif (tb->cm_ops->start) {\r\nret = tb->cm_ops->start(tb);\r\nif (ret)\r\ngoto err_domain_del;\r\n}\r\nmutex_unlock(&tb->lock);\r\nreturn 0;\r\nerr_domain_del:\r\ndevice_del(&tb->dev);\r\nerr_ctl_stop:\r\ntb_ctl_stop(tb->ctl);\r\nerr_unlock:\r\nmutex_unlock(&tb->lock);\r\nreturn ret;\r\n}\r\nvoid tb_domain_remove(struct tb *tb)\r\n{\r\nmutex_lock(&tb->lock);\r\nif (tb->cm_ops->stop)\r\ntb->cm_ops->stop(tb);\r\ntb_ctl_stop(tb->ctl);\r\nmutex_unlock(&tb->lock);\r\nflush_workqueue(tb->wq);\r\ndevice_unregister(&tb->dev);\r\n}\r\nint tb_domain_suspend_noirq(struct tb *tb)\r\n{\r\nint ret = 0;\r\nmutex_lock(&tb->lock);\r\nif (tb->cm_ops->suspend_noirq)\r\nret = tb->cm_ops->suspend_noirq(tb);\r\nif (!ret)\r\ntb_ctl_stop(tb->ctl);\r\nmutex_unlock(&tb->lock);\r\nreturn ret;\r\n}\r\nint tb_domain_resume_noirq(struct tb *tb)\r\n{\r\nint ret = 0;\r\nmutex_lock(&tb->lock);\r\ntb_ctl_start(tb->ctl);\r\nif (tb->cm_ops->resume_noirq)\r\nret = tb->cm_ops->resume_noirq(tb);\r\nmutex_unlock(&tb->lock);\r\nreturn ret;\r\n}\r\nint tb_domain_suspend(struct tb *tb)\r\n{\r\nint ret;\r\nmutex_lock(&tb->lock);\r\nif (tb->cm_ops->suspend) {\r\nret = tb->cm_ops->suspend(tb);\r\nif (ret) {\r\nmutex_unlock(&tb->lock);\r\nreturn ret;\r\n}\r\n}\r\nmutex_unlock(&tb->lock);\r\nreturn 0;\r\n}\r\nvoid tb_domain_complete(struct tb *tb)\r\n{\r\nmutex_lock(&tb->lock);\r\nif (tb->cm_ops->complete)\r\ntb->cm_ops->complete(tb);\r\nmutex_unlock(&tb->lock);\r\n}\r\nint tb_domain_approve_switch(struct tb *tb, struct tb_switch *sw)\r\n{\r\nstruct tb_switch *parent_sw;\r\nif (!tb->cm_ops->approve_switch)\r\nreturn -EPERM;\r\nparent_sw = tb_to_switch(sw->dev.parent);\r\nif (!parent_sw || !parent_sw->authorized)\r\nreturn -EINVAL;\r\nreturn tb->cm_ops->approve_switch(tb, sw);\r\n}\r\nint tb_domain_approve_switch_key(struct tb *tb, struct tb_switch *sw)\r\n{\r\nstruct tb_switch *parent_sw;\r\nint ret;\r\nif (!tb->cm_ops->approve_switch || !tb->cm_ops->add_switch_key)\r\nreturn -EPERM;\r\nparent_sw = tb_to_switch(sw->dev.parent);\r\nif (!parent_sw || !parent_sw->authorized)\r\nreturn -EINVAL;\r\nret = tb->cm_ops->add_switch_key(tb, sw);\r\nif (ret)\r\nreturn ret;\r\nreturn tb->cm_ops->approve_switch(tb, sw);\r\n}\r\nint tb_domain_challenge_switch_key(struct tb *tb, struct tb_switch *sw)\r\n{\r\nu8 challenge[TB_SWITCH_KEY_SIZE];\r\nu8 response[TB_SWITCH_KEY_SIZE];\r\nu8 hmac[TB_SWITCH_KEY_SIZE];\r\nstruct tb_switch *parent_sw;\r\nstruct crypto_shash *tfm;\r\nstruct shash_desc *shash;\r\nint ret;\r\nif (!tb->cm_ops->approve_switch || !tb->cm_ops->challenge_switch_key)\r\nreturn -EPERM;\r\nparent_sw = tb_to_switch(sw->dev.parent);\r\nif (!parent_sw || !parent_sw->authorized)\r\nreturn -EINVAL;\r\nget_random_bytes(challenge, sizeof(challenge));\r\nret = tb->cm_ops->challenge_switch_key(tb, sw, challenge, response);\r\nif (ret)\r\nreturn ret;\r\ntfm = crypto_alloc_shash("hmac(sha256)", 0, 0);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\nret = crypto_shash_setkey(tfm, sw->key, TB_SWITCH_KEY_SIZE);\r\nif (ret)\r\ngoto err_free_tfm;\r\nshash = kzalloc(sizeof(*shash) + crypto_shash_descsize(tfm),\r\nGFP_KERNEL);\r\nif (!shash) {\r\nret = -ENOMEM;\r\ngoto err_free_tfm;\r\n}\r\nshash->tfm = tfm;\r\nshash->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nmemset(hmac, 0, sizeof(hmac));\r\nret = crypto_shash_digest(shash, challenge, sizeof(hmac), hmac);\r\nif (ret)\r\ngoto err_free_shash;\r\nif (memcmp(response, hmac, sizeof(hmac))) {\r\nret = -EKEYREJECTED;\r\ngoto err_free_shash;\r\n}\r\ncrypto_free_shash(tfm);\r\nkfree(shash);\r\nreturn tb->cm_ops->approve_switch(tb, sw);\r\nerr_free_shash:\r\nkfree(shash);\r\nerr_free_tfm:\r\ncrypto_free_shash(tfm);\r\nreturn ret;\r\n}\r\nint tb_domain_disconnect_pcie_paths(struct tb *tb)\r\n{\r\nif (!tb->cm_ops->disconnect_pcie_paths)\r\nreturn -EPERM;\r\nreturn tb->cm_ops->disconnect_pcie_paths(tb);\r\n}\r\nint tb_domain_init(void)\r\n{\r\nreturn bus_register(&tb_bus_type);\r\n}\r\nvoid tb_domain_exit(void)\r\n{\r\nbus_unregister(&tb_bus_type);\r\nida_destroy(&tb_domain_ida);\r\ntb_switch_exit();\r\n}
