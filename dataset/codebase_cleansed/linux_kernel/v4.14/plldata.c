static void __init c6455_setup_clocks(struct device_node *node)\r\n{\r\nstruct pll_data *pll = &c6x_soc_pll1;\r\nstruct clk *sysclks = pll->sysclks;\r\npll->flags = PLL_HAS_PRE | PLL_HAS_MUL;\r\nsysclks[2].flags |= FIXED_DIV_PLL;\r\nsysclks[2].div = 3;\r\nsysclks[3].flags |= FIXED_DIV_PLL;\r\nsysclks[3].div = 6;\r\nsysclks[4].div = PLLDIV4;\r\nsysclks[5].div = PLLDIV5;\r\nc6x_core_clk.parent = &sysclks[0];\r\nc6x_i2c_clk.parent = &sysclks[3];\r\nc6x_watchdog_clk.parent = &sysclks[3];\r\nc6x_mdio_clk.parent = &sysclks[3];\r\nc6x_clks_init(c6455_clks);\r\n}\r\nstatic void __init c6457_setup_clocks(struct device_node *node)\r\n{\r\nstruct pll_data *pll = &c6x_soc_pll1;\r\nstruct clk *sysclks = pll->sysclks;\r\npll->flags = PLL_HAS_MUL | PLL_HAS_POST;\r\nsysclks[1].flags |= FIXED_DIV_PLL;\r\nsysclks[1].div = 1;\r\nsysclks[2].flags |= FIXED_DIV_PLL;\r\nsysclks[2].div = 3;\r\nsysclks[3].flags |= FIXED_DIV_PLL;\r\nsysclks[3].div = 6;\r\nsysclks[4].div = PLLDIV4;\r\nsysclks[5].div = PLLDIV5;\r\nc6x_core_clk.parent = &sysclks[1];\r\nc6x_i2c_clk.parent = &sysclks[3];\r\nc6x_watchdog_clk.parent = &sysclks[5];\r\nc6x_mdio_clk.parent = &sysclks[5];\r\nc6x_clks_init(c6457_clks);\r\n}\r\nstatic void __init c6472_setup_clocks(struct device_node *node)\r\n{\r\nstruct pll_data *pll = &c6x_soc_pll1;\r\nstruct clk *sysclks = pll->sysclks;\r\nint i;\r\npll->flags = PLL_HAS_MUL;\r\nfor (i = 1; i <= 6; i++) {\r\nsysclks[i].flags |= FIXED_DIV_PLL;\r\nsysclks[i].div = 1;\r\n}\r\nsysclks[7].flags |= FIXED_DIV_PLL;\r\nsysclks[7].div = 3;\r\nsysclks[8].flags |= FIXED_DIV_PLL;\r\nsysclks[8].div = 6;\r\nsysclks[9].flags |= FIXED_DIV_PLL;\r\nsysclks[9].div = 2;\r\nsysclks[10].div = PLLDIV10;\r\nc6x_core_clk.parent = &sysclks[get_coreid() + 1];\r\nc6x_i2c_clk.parent = &sysclks[8];\r\nc6x_watchdog_clk.parent = &sysclks[8];\r\nc6x_mdio_clk.parent = &sysclks[5];\r\nc6x_clks_init(c6472_clks);\r\n}\r\nstatic void __init c6474_setup_clocks(struct device_node *node)\r\n{\r\nstruct pll_data *pll = &c6x_soc_pll1;\r\nstruct clk *sysclks = pll->sysclks;\r\npll->flags = PLL_HAS_MUL;\r\nsysclks[7].flags |= FIXED_DIV_PLL;\r\nsysclks[7].div = 1;\r\nsysclks[9].flags |= FIXED_DIV_PLL;\r\nsysclks[9].div = 3;\r\nsysclks[10].flags |= FIXED_DIV_PLL;\r\nsysclks[10].div = 6;\r\nsysclks[11].div = PLLDIV11;\r\nsysclks[12].flags |= FIXED_DIV_PLL;\r\nsysclks[12].div = 2;\r\nsysclks[13].div = PLLDIV13;\r\nc6x_core_clk.parent = &sysclks[7];\r\nc6x_i2c_clk.parent = &sysclks[10];\r\nc6x_watchdog_clk.parent = &sysclks[10];\r\nc6x_mcbsp1_clk.parent = &sysclks[10];\r\nc6x_mcbsp2_clk.parent = &sysclks[10];\r\nc6x_clks_init(c6474_clks);\r\n}\r\nstatic void __init c6678_setup_clocks(struct device_node *node)\r\n{\r\nstruct pll_data *pll = &c6x_soc_pll1;\r\nstruct clk *sysclks = pll->sysclks;\r\npll->flags = PLL_HAS_MUL;\r\nsysclks[1].flags |= FIXED_DIV_PLL;\r\nsysclks[1].div = 1;\r\nsysclks[2].div = PLLDIV2;\r\nsysclks[3].flags |= FIXED_DIV_PLL;\r\nsysclks[3].div = 2;\r\nsysclks[4].flags |= FIXED_DIV_PLL;\r\nsysclks[4].div = 3;\r\nsysclks[5].div = PLLDIV5;\r\nsysclks[6].flags |= FIXED_DIV_PLL;\r\nsysclks[6].div = 64;\r\nsysclks[7].flags |= FIXED_DIV_PLL;\r\nsysclks[7].div = 6;\r\nsysclks[8].div = PLLDIV8;\r\nsysclks[9].flags |= FIXED_DIV_PLL;\r\nsysclks[9].div = 12;\r\nsysclks[10].flags |= FIXED_DIV_PLL;\r\nsysclks[10].div = 3;\r\nsysclks[11].flags |= FIXED_DIV_PLL;\r\nsysclks[11].div = 6;\r\nc6x_core_clk.parent = &sysclks[0];\r\nc6x_i2c_clk.parent = &sysclks[7];\r\nc6x_clks_init(c6678_clks);\r\n}\r\nvoid __init c64x_setup_clocks(void)\r\n{\r\nvoid (*__setup_clocks)(struct device_node *np);\r\nstruct pll_data *pll = &c6x_soc_pll1;\r\nstruct device_node *node;\r\nconst struct of_device_id *id;\r\nint err;\r\nu32 val;\r\nnode = of_find_matching_node(NULL, c6x_clkc_match);\r\nif (!node)\r\nreturn;\r\npll->base = of_iomap(node, 0);\r\nif (!pll->base)\r\ngoto out;\r\nerr = of_property_read_u32(node, "clock-frequency", &val);\r\nif (err || val == 0) {\r\npr_err("%pOF: no clock-frequency found! Using %dMHz\n",\r\nnode, (int)val / 1000000);\r\nval = 25000000;\r\n}\r\nclkin1.rate = val;\r\nerr = of_property_read_u32(node, "ti,c64x+pll-bypass-delay", &val);\r\nif (err)\r\nval = 5000;\r\npll->bypass_delay = val;\r\nerr = of_property_read_u32(node, "ti,c64x+pll-reset-delay", &val);\r\nif (err)\r\nval = 30000;\r\npll->reset_delay = val;\r\nerr = of_property_read_u32(node, "ti,c64x+pll-lock-delay", &val);\r\nif (err)\r\nval = 30000;\r\npll->lock_delay = val;\r\nid = of_match_node(c6x_clkc_match, node);\r\nif (id && id->data) {\r\n__setup_clocks = id->data;\r\n__setup_clocks(node);\r\n}\r\nout:\r\nof_node_put(node);\r\n}
