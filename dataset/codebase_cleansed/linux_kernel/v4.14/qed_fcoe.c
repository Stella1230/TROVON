static int\r\nqed_sp_fcoe_func_start(struct qed_hwfn *p_hwfn,\r\nenum spq_mode comp_mode,\r\nstruct qed_spq_comp_cb *p_comp_addr)\r\n{\r\nstruct qed_fcoe_pf_params *fcoe_pf_params = NULL;\r\nstruct fcoe_init_ramrod_params *p_ramrod = NULL;\r\nstruct fcoe_init_func_ramrod_data *p_data;\r\nstruct fcoe_conn_context *p_cxt = NULL;\r\nstruct qed_spq_entry *p_ent = NULL;\r\nstruct qed_sp_init_data init_data;\r\nstruct qed_cxt_info cxt_info;\r\nu32 dummy_cid;\r\nint rc = 0;\r\nu16 tmp;\r\nu8 i;\r\nmemset(&init_data, 0, sizeof(init_data));\r\ninit_data.cid = qed_spq_get_cid(p_hwfn);\r\ninit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\ninit_data.comp_mode = comp_mode;\r\ninit_data.p_comp_data = p_comp_addr;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nFCOE_RAMROD_CMD_ID_INIT_FUNC,\r\nPROTOCOLID_FCOE, &init_data);\r\nif (rc)\r\nreturn rc;\r\np_ramrod = &p_ent->ramrod.fcoe_init;\r\np_data = &p_ramrod->init_ramrod_data;\r\nfcoe_pf_params = &p_hwfn->pf_params.fcoe_pf_params;\r\nif (fcoe_pf_params->num_cqs > p_hwfn->hw_info.feat_num[QED_FCOE_CQ]) {\r\nDP_ERR(p_hwfn,\r\n"Cannot satisfy CQ amount. CQs requested %d, CQs available %d. Aborting function start\n",\r\nfcoe_pf_params->num_cqs,\r\np_hwfn->hw_info.feat_num[QED_FCOE_CQ]);\r\nreturn -EINVAL;\r\n}\r\np_data->mtu = cpu_to_le16(fcoe_pf_params->mtu);\r\ntmp = cpu_to_le16(fcoe_pf_params->sq_num_pbl_pages);\r\np_data->sq_num_pages_in_pbl = tmp;\r\nrc = qed_cxt_acquire_cid(p_hwfn, PROTOCOLID_FCOE, &dummy_cid);\r\nif (rc)\r\nreturn rc;\r\ncxt_info.iid = dummy_cid;\r\nrc = qed_cxt_get_cid_info(p_hwfn, &cxt_info);\r\nif (rc) {\r\nDP_NOTICE(p_hwfn, "Cannot find context info for dummy cid=%d\n",\r\ndummy_cid);\r\nreturn rc;\r\n}\r\np_cxt = cxt_info.p_cxt;\r\nSET_FIELD(p_cxt->tstorm_ag_context.flags3,\r\nTSTORM_FCOE_CONN_AG_CTX_DUMMY_TIMER_CF_EN, 1);\r\nfcoe_pf_params->dummy_icid = (u16)dummy_cid;\r\ntmp = cpu_to_le16(fcoe_pf_params->num_tasks);\r\np_data->func_params.num_tasks = tmp;\r\np_data->func_params.log_page_size = fcoe_pf_params->log_page_size;\r\np_data->func_params.debug_mode = fcoe_pf_params->debug_mode;\r\nDMA_REGPAIR_LE(p_data->q_params.glbl_q_params_addr,\r\nfcoe_pf_params->glbl_q_params_addr);\r\ntmp = cpu_to_le16(fcoe_pf_params->cq_num_entries);\r\np_data->q_params.cq_num_entries = tmp;\r\ntmp = cpu_to_le16(fcoe_pf_params->cmdq_num_entries);\r\np_data->q_params.cmdq_num_entries = tmp;\r\ntmp = fcoe_pf_params->num_cqs;\r\np_data->q_params.num_queues = (u8)tmp;\r\ntmp = (u16)p_hwfn->hw_info.resc_start[QED_CMDQS_CQS];\r\np_data->q_params.queue_relative_offset = (u8)tmp;\r\nfor (i = 0; i < fcoe_pf_params->num_cqs; i++) {\r\nu16 igu_sb_id;\r\nigu_sb_id = qed_get_igu_sb_id(p_hwfn, i);\r\ntmp = cpu_to_le16(igu_sb_id);\r\np_data->q_params.cq_cmdq_sb_num_arr[i] = tmp;\r\n}\r\np_data->q_params.cq_sb_pi = fcoe_pf_params->gl_rq_pi;\r\np_data->q_params.cmdq_sb_pi = fcoe_pf_params->gl_cmd_pi;\r\np_data->q_params.bdq_resource_id = (u8)RESC_START(p_hwfn, QED_BDQ);\r\nDMA_REGPAIR_LE(p_data->q_params.bdq_pbl_base_address[BDQ_ID_RQ],\r\nfcoe_pf_params->bdq_pbl_base_addr[BDQ_ID_RQ]);\r\np_data->q_params.bdq_pbl_num_entries[BDQ_ID_RQ] =\r\nfcoe_pf_params->bdq_pbl_num_entries[BDQ_ID_RQ];\r\ntmp = fcoe_pf_params->bdq_xoff_threshold[BDQ_ID_RQ];\r\np_data->q_params.bdq_xoff_threshold[BDQ_ID_RQ] = cpu_to_le16(tmp);\r\ntmp = fcoe_pf_params->bdq_xon_threshold[BDQ_ID_RQ];\r\np_data->q_params.bdq_xon_threshold[BDQ_ID_RQ] = cpu_to_le16(tmp);\r\nDMA_REGPAIR_LE(p_data->q_params.bdq_pbl_base_address[BDQ_ID_IMM_DATA],\r\nfcoe_pf_params->bdq_pbl_base_addr[BDQ_ID_IMM_DATA]);\r\np_data->q_params.bdq_pbl_num_entries[BDQ_ID_IMM_DATA] =\r\nfcoe_pf_params->bdq_pbl_num_entries[BDQ_ID_IMM_DATA];\r\ntmp = fcoe_pf_params->bdq_xoff_threshold[BDQ_ID_IMM_DATA];\r\np_data->q_params.bdq_xoff_threshold[BDQ_ID_IMM_DATA] = cpu_to_le16(tmp);\r\ntmp = fcoe_pf_params->bdq_xon_threshold[BDQ_ID_IMM_DATA];\r\np_data->q_params.bdq_xon_threshold[BDQ_ID_IMM_DATA] = cpu_to_le16(tmp);\r\ntmp = fcoe_pf_params->rq_buffer_size;\r\np_data->q_params.rq_buffer_size = cpu_to_le16(tmp);\r\nif (fcoe_pf_params->is_target) {\r\nSET_FIELD(p_data->q_params.q_validity,\r\nSCSI_INIT_FUNC_QUEUES_RQ_VALID, 1);\r\nif (p_data->q_params.bdq_pbl_num_entries[BDQ_ID_IMM_DATA])\r\nSET_FIELD(p_data->q_params.q_validity,\r\nSCSI_INIT_FUNC_QUEUES_IMM_DATA_VALID, 1);\r\nSET_FIELD(p_data->q_params.q_validity,\r\nSCSI_INIT_FUNC_QUEUES_CMD_VALID, 1);\r\n} else {\r\nSET_FIELD(p_data->q_params.q_validity,\r\nSCSI_INIT_FUNC_QUEUES_RQ_VALID, 1);\r\n}\r\nrc = qed_spq_post(p_hwfn, p_ent, NULL);\r\nreturn rc;\r\n}\r\nstatic int\r\nqed_sp_fcoe_conn_offload(struct qed_hwfn *p_hwfn,\r\nstruct qed_fcoe_conn *p_conn,\r\nenum spq_mode comp_mode,\r\nstruct qed_spq_comp_cb *p_comp_addr)\r\n{\r\nstruct fcoe_conn_offload_ramrod_params *p_ramrod = NULL;\r\nstruct fcoe_conn_offload_ramrod_data *p_data;\r\nstruct qed_spq_entry *p_ent = NULL;\r\nstruct qed_sp_init_data init_data;\r\nu16 physical_q0, tmp;\r\nint rc;\r\nmemset(&init_data, 0, sizeof(init_data));\r\ninit_data.cid = p_conn->icid;\r\ninit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\ninit_data.comp_mode = comp_mode;\r\ninit_data.p_comp_data = p_comp_addr;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nFCOE_RAMROD_CMD_ID_OFFLOAD_CONN,\r\nPROTOCOLID_FCOE, &init_data);\r\nif (rc)\r\nreturn rc;\r\np_ramrod = &p_ent->ramrod.fcoe_conn_ofld;\r\np_data = &p_ramrod->offload_ramrod_data;\r\nphysical_q0 = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_OFLD);\r\np_conn->physical_q0 = cpu_to_le16(physical_q0);\r\np_data->physical_q0 = cpu_to_le16(physical_q0);\r\np_data->conn_id = cpu_to_le16(p_conn->conn_id);\r\nDMA_REGPAIR_LE(p_data->sq_pbl_addr, p_conn->sq_pbl_addr);\r\nDMA_REGPAIR_LE(p_data->sq_curr_page_addr, p_conn->sq_curr_page_addr);\r\nDMA_REGPAIR_LE(p_data->sq_next_page_addr, p_conn->sq_next_page_addr);\r\nDMA_REGPAIR_LE(p_data->xferq_pbl_addr, p_conn->xferq_pbl_addr);\r\nDMA_REGPAIR_LE(p_data->xferq_curr_page_addr, p_conn->xferq_addr[0]);\r\nDMA_REGPAIR_LE(p_data->xferq_next_page_addr, p_conn->xferq_addr[1]);\r\nDMA_REGPAIR_LE(p_data->respq_pbl_addr, p_conn->confq_pbl_addr);\r\nDMA_REGPAIR_LE(p_data->respq_curr_page_addr, p_conn->confq_addr[0]);\r\nDMA_REGPAIR_LE(p_data->respq_next_page_addr, p_conn->confq_addr[1]);\r\np_data->dst_mac_addr_lo = cpu_to_le16(p_conn->dst_mac_addr_lo);\r\np_data->dst_mac_addr_mid = cpu_to_le16(p_conn->dst_mac_addr_mid);\r\np_data->dst_mac_addr_hi = cpu_to_le16(p_conn->dst_mac_addr_hi);\r\np_data->src_mac_addr_lo = cpu_to_le16(p_conn->src_mac_addr_lo);\r\np_data->src_mac_addr_mid = cpu_to_le16(p_conn->src_mac_addr_mid);\r\np_data->src_mac_addr_hi = cpu_to_le16(p_conn->src_mac_addr_hi);\r\ntmp = cpu_to_le16(p_conn->tx_max_fc_pay_len);\r\np_data->tx_max_fc_pay_len = tmp;\r\ntmp = cpu_to_le16(p_conn->e_d_tov_timer_val);\r\np_data->e_d_tov_timer_val = tmp;\r\ntmp = cpu_to_le16(p_conn->rec_tov_timer_val);\r\np_data->rec_rr_tov_timer_val = tmp;\r\ntmp = cpu_to_le16(p_conn->rx_max_fc_pay_len);\r\np_data->rx_max_fc_pay_len = tmp;\r\np_data->vlan_tag = cpu_to_le16(p_conn->vlan_tag);\r\np_data->s_id.addr_hi = p_conn->s_id.addr_hi;\r\np_data->s_id.addr_mid = p_conn->s_id.addr_mid;\r\np_data->s_id.addr_lo = p_conn->s_id.addr_lo;\r\np_data->max_conc_seqs_c3 = p_conn->max_conc_seqs_c3;\r\np_data->d_id.addr_hi = p_conn->d_id.addr_hi;\r\np_data->d_id.addr_mid = p_conn->d_id.addr_mid;\r\np_data->d_id.addr_lo = p_conn->d_id.addr_lo;\r\np_data->flags = p_conn->flags;\r\np_data->def_q_idx = p_conn->def_q_idx;\r\nreturn qed_spq_post(p_hwfn, p_ent, NULL);\r\n}\r\nstatic int\r\nqed_sp_fcoe_conn_destroy(struct qed_hwfn *p_hwfn,\r\nstruct qed_fcoe_conn *p_conn,\r\nenum spq_mode comp_mode,\r\nstruct qed_spq_comp_cb *p_comp_addr)\r\n{\r\nstruct fcoe_conn_terminate_ramrod_params *p_ramrod = NULL;\r\nstruct qed_spq_entry *p_ent = NULL;\r\nstruct qed_sp_init_data init_data;\r\nint rc = 0;\r\nmemset(&init_data, 0, sizeof(init_data));\r\ninit_data.cid = p_conn->icid;\r\ninit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\ninit_data.comp_mode = comp_mode;\r\ninit_data.p_comp_data = p_comp_addr;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nFCOE_RAMROD_CMD_ID_TERMINATE_CONN,\r\nPROTOCOLID_FCOE, &init_data);\r\nif (rc)\r\nreturn rc;\r\np_ramrod = &p_ent->ramrod.fcoe_conn_terminate;\r\nDMA_REGPAIR_LE(p_ramrod->terminate_ramrod_data.terminate_params_addr,\r\np_conn->terminate_params);\r\nreturn qed_spq_post(p_hwfn, p_ent, NULL);\r\n}\r\nstatic int\r\nqed_sp_fcoe_func_stop(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nenum spq_mode comp_mode,\r\nstruct qed_spq_comp_cb *p_comp_addr)\r\n{\r\nstruct qed_spq_entry *p_ent = NULL;\r\nstruct qed_sp_init_data init_data;\r\nu32 active_segs = 0;\r\nint rc = 0;\r\nmemset(&init_data, 0, sizeof(init_data));\r\ninit_data.cid = p_hwfn->pf_params.fcoe_pf_params.dummy_icid;\r\ninit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\ninit_data.comp_mode = comp_mode;\r\ninit_data.p_comp_data = p_comp_addr;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nFCOE_RAMROD_CMD_ID_DESTROY_FUNC,\r\nPROTOCOLID_FCOE, &init_data);\r\nif (rc)\r\nreturn rc;\r\nactive_segs = qed_rd(p_hwfn, p_ptt, TM_REG_PF_ENABLE_TASK);\r\nactive_segs &= ~BIT(QED_CXT_FCOE_TID_SEG);\r\nqed_wr(p_hwfn, p_ptt, TM_REG_PF_ENABLE_TASK, active_segs);\r\nreturn qed_spq_post(p_hwfn, p_ent, NULL);\r\n}\r\nstatic int\r\nqed_fcoe_allocate_connection(struct qed_hwfn *p_hwfn,\r\nstruct qed_fcoe_conn **p_out_conn)\r\n{\r\nstruct qed_fcoe_conn *p_conn = NULL;\r\nvoid *p_addr;\r\nu32 i;\r\nspin_lock_bh(&p_hwfn->p_fcoe_info->lock);\r\nif (!list_empty(&p_hwfn->p_fcoe_info->free_list))\r\np_conn =\r\nlist_first_entry(&p_hwfn->p_fcoe_info->free_list,\r\nstruct qed_fcoe_conn, list_entry);\r\nif (p_conn) {\r\nlist_del(&p_conn->list_entry);\r\nspin_unlock_bh(&p_hwfn->p_fcoe_info->lock);\r\n*p_out_conn = p_conn;\r\nreturn 0;\r\n}\r\nspin_unlock_bh(&p_hwfn->p_fcoe_info->lock);\r\np_conn = kzalloc(sizeof(*p_conn), GFP_KERNEL);\r\nif (!p_conn)\r\nreturn -ENOMEM;\r\np_addr = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\nQED_CHAIN_PAGE_SIZE,\r\n&p_conn->xferq_pbl_addr, GFP_KERNEL);\r\nif (!p_addr)\r\ngoto nomem_pbl_xferq;\r\np_conn->xferq_pbl_addr_virt_addr = p_addr;\r\nfor (i = 0; i < ARRAY_SIZE(p_conn->xferq_addr); i++) {\r\np_addr = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\nQED_CHAIN_PAGE_SIZE,\r\n&p_conn->xferq_addr[i], GFP_KERNEL);\r\nif (!p_addr)\r\ngoto nomem_xferq;\r\np_conn->xferq_addr_virt_addr[i] = p_addr;\r\np_addr = p_conn->xferq_pbl_addr_virt_addr;\r\n((dma_addr_t *)p_addr)[i] = p_conn->xferq_addr[i];\r\n}\r\np_addr = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\nQED_CHAIN_PAGE_SIZE,\r\n&p_conn->confq_pbl_addr, GFP_KERNEL);\r\nif (!p_addr)\r\ngoto nomem_xferq;\r\np_conn->confq_pbl_addr_virt_addr = p_addr;\r\nfor (i = 0; i < ARRAY_SIZE(p_conn->confq_addr); i++) {\r\np_addr = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\nQED_CHAIN_PAGE_SIZE,\r\n&p_conn->confq_addr[i], GFP_KERNEL);\r\nif (!p_addr)\r\ngoto nomem_confq;\r\np_conn->confq_addr_virt_addr[i] = p_addr;\r\np_addr = p_conn->confq_pbl_addr_virt_addr;\r\n((dma_addr_t *)p_addr)[i] = p_conn->confq_addr[i];\r\n}\r\np_conn->free_on_delete = true;\r\n*p_out_conn = p_conn;\r\nreturn 0;\r\nnomem_confq:\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nQED_CHAIN_PAGE_SIZE,\r\np_conn->confq_pbl_addr_virt_addr,\r\np_conn->confq_pbl_addr);\r\nfor (i = 0; i < ARRAY_SIZE(p_conn->confq_addr); i++)\r\nif (p_conn->confq_addr_virt_addr[i])\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nQED_CHAIN_PAGE_SIZE,\r\np_conn->confq_addr_virt_addr[i],\r\np_conn->confq_addr[i]);\r\nnomem_xferq:\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nQED_CHAIN_PAGE_SIZE,\r\np_conn->xferq_pbl_addr_virt_addr,\r\np_conn->xferq_pbl_addr);\r\nfor (i = 0; i < ARRAY_SIZE(p_conn->xferq_addr); i++)\r\nif (p_conn->xferq_addr_virt_addr[i])\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nQED_CHAIN_PAGE_SIZE,\r\np_conn->xferq_addr_virt_addr[i],\r\np_conn->xferq_addr[i]);\r\nnomem_pbl_xferq:\r\nkfree(p_conn);\r\nreturn -ENOMEM;\r\n}\r\nstatic void qed_fcoe_free_connection(struct qed_hwfn *p_hwfn,\r\nstruct qed_fcoe_conn *p_conn)\r\n{\r\nu32 i;\r\nif (!p_conn)\r\nreturn;\r\nif (p_conn->confq_pbl_addr_virt_addr)\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nQED_CHAIN_PAGE_SIZE,\r\np_conn->confq_pbl_addr_virt_addr,\r\np_conn->confq_pbl_addr);\r\nfor (i = 0; i < ARRAY_SIZE(p_conn->confq_addr); i++) {\r\nif (!p_conn->confq_addr_virt_addr[i])\r\ncontinue;\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nQED_CHAIN_PAGE_SIZE,\r\np_conn->confq_addr_virt_addr[i],\r\np_conn->confq_addr[i]);\r\n}\r\nif (p_conn->xferq_pbl_addr_virt_addr)\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nQED_CHAIN_PAGE_SIZE,\r\np_conn->xferq_pbl_addr_virt_addr,\r\np_conn->xferq_pbl_addr);\r\nfor (i = 0; i < ARRAY_SIZE(p_conn->xferq_addr); i++) {\r\nif (!p_conn->xferq_addr_virt_addr[i])\r\ncontinue;\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nQED_CHAIN_PAGE_SIZE,\r\np_conn->xferq_addr_virt_addr[i],\r\np_conn->xferq_addr[i]);\r\n}\r\nkfree(p_conn);\r\n}\r\nstatic void __iomem *qed_fcoe_get_db_addr(struct qed_hwfn *p_hwfn, u32 cid)\r\n{\r\nreturn (u8 __iomem *)p_hwfn->doorbells +\r\nqed_db_addr(cid, DQ_DEMS_LEGACY);\r\n}\r\nstatic void __iomem *qed_fcoe_get_primary_bdq_prod(struct qed_hwfn *p_hwfn,\r\nu8 bdq_id)\r\n{\r\nif (RESC_NUM(p_hwfn, QED_BDQ)) {\r\nreturn (u8 __iomem *)p_hwfn->regview +\r\nGTT_BAR0_MAP_REG_MSDM_RAM +\r\nMSTORM_SCSI_BDQ_EXT_PROD_OFFSET(RESC_START(p_hwfn,\r\nQED_BDQ),\r\nbdq_id);\r\n} else {\r\nDP_NOTICE(p_hwfn, "BDQ is not allocated!\n");\r\nreturn NULL;\r\n}\r\n}\r\nstatic void __iomem *qed_fcoe_get_secondary_bdq_prod(struct qed_hwfn *p_hwfn,\r\nu8 bdq_id)\r\n{\r\nif (RESC_NUM(p_hwfn, QED_BDQ)) {\r\nreturn (u8 __iomem *)p_hwfn->regview +\r\nGTT_BAR0_MAP_REG_TSDM_RAM +\r\nTSTORM_SCSI_BDQ_EXT_PROD_OFFSET(RESC_START(p_hwfn,\r\nQED_BDQ),\r\nbdq_id);\r\n} else {\r\nDP_NOTICE(p_hwfn, "BDQ is not allocated!\n");\r\nreturn NULL;\r\n}\r\n}\r\nint qed_fcoe_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_fcoe_info *p_fcoe_info;\r\np_fcoe_info = kzalloc(sizeof(*p_fcoe_info), GFP_KERNEL);\r\nif (!p_fcoe_info) {\r\nDP_NOTICE(p_hwfn, "Failed to allocate qed_fcoe_info'\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&p_fcoe_info->free_list);\r\np_hwfn->p_fcoe_info = p_fcoe_info;\r\nreturn 0;\r\n}\r\nvoid qed_fcoe_setup(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct fcoe_task_context *p_task_ctx = NULL;\r\nint rc;\r\nu32 i;\r\nspin_lock_init(&p_hwfn->p_fcoe_info->lock);\r\nfor (i = 0; i < p_hwfn->pf_params.fcoe_pf_params.num_tasks; i++) {\r\nrc = qed_cxt_get_task_ctx(p_hwfn, i,\r\nQED_CTX_WORKING_MEM,\r\n(void **)&p_task_ctx);\r\nif (rc)\r\ncontinue;\r\nmemset(p_task_ctx, 0, sizeof(struct fcoe_task_context));\r\nSET_FIELD(p_task_ctx->timer_context.logical_client_0,\r\nTIMERS_CONTEXT_VALIDLC0, 1);\r\nSET_FIELD(p_task_ctx->timer_context.logical_client_1,\r\nTIMERS_CONTEXT_VALIDLC1, 1);\r\nSET_FIELD(p_task_ctx->tstorm_ag_context.flags0,\r\nTSTORM_FCOE_TASK_AG_CTX_CONNECTION_TYPE, 1);\r\n}\r\n}\r\nvoid qed_fcoe_free(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_fcoe_conn *p_conn = NULL;\r\nif (!p_hwfn->p_fcoe_info)\r\nreturn;\r\nwhile (!list_empty(&p_hwfn->p_fcoe_info->free_list)) {\r\np_conn = list_first_entry(&p_hwfn->p_fcoe_info->free_list,\r\nstruct qed_fcoe_conn, list_entry);\r\nif (!p_conn)\r\nbreak;\r\nlist_del(&p_conn->list_entry);\r\nqed_fcoe_free_connection(p_hwfn, p_conn);\r\n}\r\nkfree(p_hwfn->p_fcoe_info);\r\np_hwfn->p_fcoe_info = NULL;\r\n}\r\nstatic int\r\nqed_fcoe_acquire_connection(struct qed_hwfn *p_hwfn,\r\nstruct qed_fcoe_conn *p_in_conn,\r\nstruct qed_fcoe_conn **p_out_conn)\r\n{\r\nstruct qed_fcoe_conn *p_conn = NULL;\r\nint rc = 0;\r\nu32 icid;\r\nspin_lock_bh(&p_hwfn->p_fcoe_info->lock);\r\nrc = qed_cxt_acquire_cid(p_hwfn, PROTOCOLID_FCOE, &icid);\r\nspin_unlock_bh(&p_hwfn->p_fcoe_info->lock);\r\nif (rc)\r\nreturn rc;\r\nif (p_in_conn) {\r\np_conn = p_in_conn;\r\n} else {\r\nrc = qed_fcoe_allocate_connection(p_hwfn, &p_conn);\r\nif (rc) {\r\nspin_lock_bh(&p_hwfn->p_fcoe_info->lock);\r\nqed_cxt_release_cid(p_hwfn, icid);\r\nspin_unlock_bh(&p_hwfn->p_fcoe_info->lock);\r\nreturn rc;\r\n}\r\n}\r\np_conn->icid = icid;\r\np_conn->fw_cid = (p_hwfn->hw_info.opaque_fid << 16) | icid;\r\n*p_out_conn = p_conn;\r\nreturn rc;\r\n}\r\nstatic void qed_fcoe_release_connection(struct qed_hwfn *p_hwfn,\r\nstruct qed_fcoe_conn *p_conn)\r\n{\r\nspin_lock_bh(&p_hwfn->p_fcoe_info->lock);\r\nlist_add_tail(&p_conn->list_entry, &p_hwfn->p_fcoe_info->free_list);\r\nqed_cxt_release_cid(p_hwfn, p_conn->icid);\r\nspin_unlock_bh(&p_hwfn->p_fcoe_info->lock);\r\n}\r\nstatic void _qed_fcoe_get_tstats(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct qed_fcoe_stats *p_stats)\r\n{\r\nstruct fcoe_rx_stat tstats;\r\nu32 tstats_addr;\r\nmemset(&tstats, 0, sizeof(tstats));\r\ntstats_addr = BAR0_MAP_REG_TSDM_RAM +\r\nTSTORM_FCOE_RX_STATS_OFFSET(p_hwfn->rel_pf_id);\r\nqed_memcpy_from(p_hwfn, p_ptt, &tstats, tstats_addr, sizeof(tstats));\r\np_stats->fcoe_rx_byte_cnt = HILO_64_REGPAIR(tstats.fcoe_rx_byte_cnt);\r\np_stats->fcoe_rx_data_pkt_cnt =\r\nHILO_64_REGPAIR(tstats.fcoe_rx_data_pkt_cnt);\r\np_stats->fcoe_rx_xfer_pkt_cnt =\r\nHILO_64_REGPAIR(tstats.fcoe_rx_xfer_pkt_cnt);\r\np_stats->fcoe_rx_other_pkt_cnt =\r\nHILO_64_REGPAIR(tstats.fcoe_rx_other_pkt_cnt);\r\np_stats->fcoe_silent_drop_pkt_cmdq_full_cnt =\r\nle32_to_cpu(tstats.fcoe_silent_drop_pkt_cmdq_full_cnt);\r\np_stats->fcoe_silent_drop_pkt_rq_full_cnt =\r\nle32_to_cpu(tstats.fcoe_silent_drop_pkt_rq_full_cnt);\r\np_stats->fcoe_silent_drop_pkt_crc_error_cnt =\r\nle32_to_cpu(tstats.fcoe_silent_drop_pkt_crc_error_cnt);\r\np_stats->fcoe_silent_drop_pkt_task_invalid_cnt =\r\nle32_to_cpu(tstats.fcoe_silent_drop_pkt_task_invalid_cnt);\r\np_stats->fcoe_silent_drop_total_pkt_cnt =\r\nle32_to_cpu(tstats.fcoe_silent_drop_total_pkt_cnt);\r\n}\r\nstatic void _qed_fcoe_get_pstats(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct qed_fcoe_stats *p_stats)\r\n{\r\nstruct fcoe_tx_stat pstats;\r\nu32 pstats_addr;\r\nmemset(&pstats, 0, sizeof(pstats));\r\npstats_addr = BAR0_MAP_REG_PSDM_RAM +\r\nPSTORM_FCOE_TX_STATS_OFFSET(p_hwfn->rel_pf_id);\r\nqed_memcpy_from(p_hwfn, p_ptt, &pstats, pstats_addr, sizeof(pstats));\r\np_stats->fcoe_tx_byte_cnt = HILO_64_REGPAIR(pstats.fcoe_tx_byte_cnt);\r\np_stats->fcoe_tx_data_pkt_cnt =\r\nHILO_64_REGPAIR(pstats.fcoe_tx_data_pkt_cnt);\r\np_stats->fcoe_tx_xfer_pkt_cnt =\r\nHILO_64_REGPAIR(pstats.fcoe_tx_xfer_pkt_cnt);\r\np_stats->fcoe_tx_other_pkt_cnt =\r\nHILO_64_REGPAIR(pstats.fcoe_tx_other_pkt_cnt);\r\n}\r\nstatic int qed_fcoe_get_stats(struct qed_hwfn *p_hwfn,\r\nstruct qed_fcoe_stats *p_stats)\r\n{\r\nstruct qed_ptt *p_ptt;\r\nmemset(p_stats, 0, sizeof(*p_stats));\r\np_ptt = qed_ptt_acquire(p_hwfn);\r\nif (!p_ptt) {\r\nDP_ERR(p_hwfn, "Failed to acquire ptt\n");\r\nreturn -EINVAL;\r\n}\r\n_qed_fcoe_get_tstats(p_hwfn, p_ptt, p_stats);\r\n_qed_fcoe_get_pstats(p_hwfn, p_ptt, p_stats);\r\nqed_ptt_release(p_hwfn, p_ptt);\r\nreturn 0;\r\n}\r\nstatic int qed_fill_fcoe_dev_info(struct qed_dev *cdev,\r\nstruct qed_dev_fcoe_info *info)\r\n{\r\nstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\r\nint rc;\r\nmemset(info, 0, sizeof(*info));\r\nrc = qed_fill_dev_info(cdev, &info->common);\r\ninfo->primary_dbq_rq_addr =\r\nqed_fcoe_get_primary_bdq_prod(hwfn, BDQ_ID_RQ);\r\ninfo->secondary_bdq_rq_addr =\r\nqed_fcoe_get_secondary_bdq_prod(hwfn, BDQ_ID_RQ);\r\ninfo->wwpn = hwfn->mcp_info->func_info.wwn_port;\r\ninfo->wwnn = hwfn->mcp_info->func_info.wwn_node;\r\ninfo->num_cqs = FEAT_NUM(hwfn, QED_FCOE_CQ);\r\nreturn rc;\r\n}\r\nstatic void qed_register_fcoe_ops(struct qed_dev *cdev,\r\nstruct qed_fcoe_cb_ops *ops, void *cookie)\r\n{\r\ncdev->protocol_ops.fcoe = ops;\r\ncdev->ops_cookie = cookie;\r\n}\r\nstatic struct qed_hash_fcoe_con *qed_fcoe_get_hash(struct qed_dev *cdev,\r\nu32 handle)\r\n{\r\nstruct qed_hash_fcoe_con *hash_con = NULL;\r\nif (!(cdev->flags & QED_FLAG_STORAGE_STARTED))\r\nreturn NULL;\r\nhash_for_each_possible(cdev->connections, hash_con, node, handle) {\r\nif (hash_con->con->icid == handle)\r\nbreak;\r\n}\r\nif (!hash_con || (hash_con->con->icid != handle))\r\nreturn NULL;\r\nreturn hash_con;\r\n}\r\nstatic int qed_fcoe_stop(struct qed_dev *cdev)\r\n{\r\nstruct qed_ptt *p_ptt;\r\nint rc;\r\nif (!(cdev->flags & QED_FLAG_STORAGE_STARTED)) {\r\nDP_NOTICE(cdev, "fcoe already stopped\n");\r\nreturn 0;\r\n}\r\nif (!hash_empty(cdev->connections)) {\r\nDP_NOTICE(cdev,\r\n"Can't stop fcoe - not all connections were returned\n");\r\nreturn -EINVAL;\r\n}\r\np_ptt = qed_ptt_acquire(QED_LEADING_HWFN(cdev));\r\nif (!p_ptt)\r\nreturn -EAGAIN;\r\nrc = qed_sp_fcoe_func_stop(QED_LEADING_HWFN(cdev), p_ptt,\r\nQED_SPQ_MODE_EBLOCK, NULL);\r\ncdev->flags &= ~QED_FLAG_STORAGE_STARTED;\r\nqed_ptt_release(QED_LEADING_HWFN(cdev), p_ptt);\r\nreturn rc;\r\n}\r\nstatic int qed_fcoe_start(struct qed_dev *cdev, struct qed_fcoe_tid *tasks)\r\n{\r\nint rc;\r\nif (cdev->flags & QED_FLAG_STORAGE_STARTED) {\r\nDP_NOTICE(cdev, "fcoe already started;\n");\r\nreturn 0;\r\n}\r\nrc = qed_sp_fcoe_func_start(QED_LEADING_HWFN(cdev),\r\nQED_SPQ_MODE_EBLOCK, NULL);\r\nif (rc) {\r\nDP_NOTICE(cdev, "Failed to start fcoe\n");\r\nreturn rc;\r\n}\r\ncdev->flags |= QED_FLAG_STORAGE_STARTED;\r\nhash_init(cdev->connections);\r\nif (tasks) {\r\nstruct qed_tid_mem *tid_info = kzalloc(sizeof(*tid_info),\r\nGFP_ATOMIC);\r\nif (!tid_info) {\r\nDP_NOTICE(cdev,\r\n"Failed to allocate tasks information\n");\r\nqed_fcoe_stop(cdev);\r\nreturn -ENOMEM;\r\n}\r\nrc = qed_cxt_get_tid_mem_info(QED_LEADING_HWFN(cdev), tid_info);\r\nif (rc) {\r\nDP_NOTICE(cdev, "Failed to gather task information\n");\r\nqed_fcoe_stop(cdev);\r\nkfree(tid_info);\r\nreturn rc;\r\n}\r\ntasks->size = tid_info->tid_size;\r\ntasks->num_tids_per_block = tid_info->num_tids_per_block;\r\nmemcpy(tasks->blocks, tid_info->blocks,\r\nMAX_TID_BLOCKS_FCOE * sizeof(u8 *));\r\nkfree(tid_info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qed_fcoe_acquire_conn(struct qed_dev *cdev,\r\nu32 *handle,\r\nu32 *fw_cid, void __iomem **p_doorbell)\r\n{\r\nstruct qed_hash_fcoe_con *hash_con;\r\nint rc;\r\nhash_con = kzalloc(sizeof(*hash_con), GFP_KERNEL);\r\nif (!hash_con) {\r\nDP_NOTICE(cdev, "Failed to allocate hashed connection\n");\r\nreturn -ENOMEM;\r\n}\r\nrc = qed_fcoe_acquire_connection(QED_LEADING_HWFN(cdev), NULL,\r\n&hash_con->con);\r\nif (rc) {\r\nDP_NOTICE(cdev, "Failed to acquire Connection\n");\r\nkfree(hash_con);\r\nreturn rc;\r\n}\r\n*handle = hash_con->con->icid;\r\n*fw_cid = hash_con->con->fw_cid;\r\nhash_add(cdev->connections, &hash_con->node, *handle);\r\nif (p_doorbell)\r\n*p_doorbell = qed_fcoe_get_db_addr(QED_LEADING_HWFN(cdev),\r\n*handle);\r\nreturn 0;\r\n}\r\nstatic int qed_fcoe_release_conn(struct qed_dev *cdev, u32 handle)\r\n{\r\nstruct qed_hash_fcoe_con *hash_con;\r\nhash_con = qed_fcoe_get_hash(cdev, handle);\r\nif (!hash_con) {\r\nDP_NOTICE(cdev, "Failed to find connection for handle %d\n",\r\nhandle);\r\nreturn -EINVAL;\r\n}\r\nhlist_del(&hash_con->node);\r\nqed_fcoe_release_connection(QED_LEADING_HWFN(cdev), hash_con->con);\r\nkfree(hash_con);\r\nreturn 0;\r\n}\r\nstatic int qed_fcoe_offload_conn(struct qed_dev *cdev,\r\nu32 handle,\r\nstruct qed_fcoe_params_offload *conn_info)\r\n{\r\nstruct qed_hash_fcoe_con *hash_con;\r\nstruct qed_fcoe_conn *con;\r\nhash_con = qed_fcoe_get_hash(cdev, handle);\r\nif (!hash_con) {\r\nDP_NOTICE(cdev, "Failed to find connection for handle %d\n",\r\nhandle);\r\nreturn -EINVAL;\r\n}\r\ncon = hash_con->con;\r\ncon->sq_pbl_addr = conn_info->sq_pbl_addr;\r\ncon->sq_curr_page_addr = conn_info->sq_curr_page_addr;\r\ncon->sq_next_page_addr = conn_info->sq_next_page_addr;\r\ncon->tx_max_fc_pay_len = conn_info->tx_max_fc_pay_len;\r\ncon->e_d_tov_timer_val = conn_info->e_d_tov_timer_val;\r\ncon->rec_tov_timer_val = conn_info->rec_tov_timer_val;\r\ncon->rx_max_fc_pay_len = conn_info->rx_max_fc_pay_len;\r\ncon->vlan_tag = conn_info->vlan_tag;\r\ncon->max_conc_seqs_c3 = conn_info->max_conc_seqs_c3;\r\ncon->flags = conn_info->flags;\r\ncon->def_q_idx = conn_info->def_q_idx;\r\ncon->src_mac_addr_hi = (conn_info->src_mac[5] << 8) |\r\nconn_info->src_mac[4];\r\ncon->src_mac_addr_mid = (conn_info->src_mac[3] << 8) |\r\nconn_info->src_mac[2];\r\ncon->src_mac_addr_lo = (conn_info->src_mac[1] << 8) |\r\nconn_info->src_mac[0];\r\ncon->dst_mac_addr_hi = (conn_info->dst_mac[5] << 8) |\r\nconn_info->dst_mac[4];\r\ncon->dst_mac_addr_mid = (conn_info->dst_mac[3] << 8) |\r\nconn_info->dst_mac[2];\r\ncon->dst_mac_addr_lo = (conn_info->dst_mac[1] << 8) |\r\nconn_info->dst_mac[0];\r\ncon->s_id.addr_hi = conn_info->s_id.addr_hi;\r\ncon->s_id.addr_mid = conn_info->s_id.addr_mid;\r\ncon->s_id.addr_lo = conn_info->s_id.addr_lo;\r\ncon->d_id.addr_hi = conn_info->d_id.addr_hi;\r\ncon->d_id.addr_mid = conn_info->d_id.addr_mid;\r\ncon->d_id.addr_lo = conn_info->d_id.addr_lo;\r\nreturn qed_sp_fcoe_conn_offload(QED_LEADING_HWFN(cdev), con,\r\nQED_SPQ_MODE_EBLOCK, NULL);\r\n}\r\nstatic int qed_fcoe_destroy_conn(struct qed_dev *cdev,\r\nu32 handle, dma_addr_t terminate_params)\r\n{\r\nstruct qed_hash_fcoe_con *hash_con;\r\nstruct qed_fcoe_conn *con;\r\nhash_con = qed_fcoe_get_hash(cdev, handle);\r\nif (!hash_con) {\r\nDP_NOTICE(cdev, "Failed to find connection for handle %d\n",\r\nhandle);\r\nreturn -EINVAL;\r\n}\r\ncon = hash_con->con;\r\ncon->terminate_params = terminate_params;\r\nreturn qed_sp_fcoe_conn_destroy(QED_LEADING_HWFN(cdev), con,\r\nQED_SPQ_MODE_EBLOCK, NULL);\r\n}\r\nstatic int qed_fcoe_stats(struct qed_dev *cdev, struct qed_fcoe_stats *stats)\r\n{\r\nreturn qed_fcoe_get_stats(QED_LEADING_HWFN(cdev), stats);\r\n}\r\nvoid qed_get_protocol_stats_fcoe(struct qed_dev *cdev,\r\nstruct qed_mcp_fcoe_stats *stats)\r\n{\r\nstruct qed_fcoe_stats proto_stats;\r\nmemset(&proto_stats, 0, sizeof(proto_stats));\r\nif (qed_fcoe_stats(cdev, &proto_stats)) {\r\nDP_VERBOSE(cdev, QED_MSG_STORAGE,\r\n"Failed to collect FCoE statistics\n");\r\nreturn;\r\n}\r\nstats->rx_pkts = proto_stats.fcoe_rx_data_pkt_cnt +\r\nproto_stats.fcoe_rx_xfer_pkt_cnt +\r\nproto_stats.fcoe_rx_other_pkt_cnt;\r\nstats->tx_pkts = proto_stats.fcoe_tx_data_pkt_cnt +\r\nproto_stats.fcoe_tx_xfer_pkt_cnt +\r\nproto_stats.fcoe_tx_other_pkt_cnt;\r\nstats->fcs_err = proto_stats.fcoe_silent_drop_pkt_crc_error_cnt;\r\nif (cdev->protocol_ops.fcoe && cdev->ops_cookie) {\r\nstruct qed_fcoe_cb_ops *ops = cdev->protocol_ops.fcoe;\r\nvoid *cookie = cdev->ops_cookie;\r\nif (ops->get_login_failures)\r\nstats->login_failure = ops->get_login_failures(cookie);\r\n}\r\n}\r\nconst struct qed_fcoe_ops *qed_get_fcoe_ops(void)\r\n{\r\nreturn &qed_fcoe_ops_pass;\r\n}\r\nvoid qed_put_fcoe_ops(void)\r\n{\r\n}
