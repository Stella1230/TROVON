static void ath10k_sta_update_extd_stats_rx_duration(struct ath10k *ar,\r\nstruct ath10k_fw_stats *stats)\r\n{\r\nstruct ath10k_fw_extd_stats_peer *peer;\r\nstruct ieee80211_sta *sta;\r\nstruct ath10k_sta *arsta;\r\nrcu_read_lock();\r\nlist_for_each_entry(peer, &stats->peers_extd, list) {\r\nsta = ieee80211_find_sta_by_ifaddr(ar->hw, peer->peer_macaddr,\r\nNULL);\r\nif (!sta)\r\ncontinue;\r\narsta = (struct ath10k_sta *)sta->drv_priv;\r\narsta->rx_duration += (u64)peer->rx_duration;\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void ath10k_sta_update_stats_rx_duration(struct ath10k *ar,\r\nstruct ath10k_fw_stats *stats)\r\n{\r\nstruct ath10k_fw_stats_peer *peer;\r\nstruct ieee80211_sta *sta;\r\nstruct ath10k_sta *arsta;\r\nrcu_read_lock();\r\nlist_for_each_entry(peer, &stats->peers, list) {\r\nsta = ieee80211_find_sta_by_ifaddr(ar->hw, peer->peer_macaddr,\r\nNULL);\r\nif (!sta)\r\ncontinue;\r\narsta = (struct ath10k_sta *)sta->drv_priv;\r\narsta->rx_duration += (u64)peer->rx_duration;\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid ath10k_sta_update_rx_duration(struct ath10k *ar,\r\nstruct ath10k_fw_stats *stats)\r\n{\r\nif (stats->extended)\r\nath10k_sta_update_extd_stats_rx_duration(ar, stats);\r\nelse\r\nath10k_sta_update_stats_rx_duration(ar, stats);\r\n}\r\nvoid ath10k_sta_statistics(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta,\r\nstruct station_info *sinfo)\r\n{\r\nstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\r\nstruct ath10k *ar = arsta->arvif->ar;\r\nif (!ath10k_peer_stats_enabled(ar))\r\nreturn;\r\nsinfo->rx_duration = arsta->rx_duration;\r\nsinfo->filled |= 1ULL << NL80211_STA_INFO_RX_DURATION;\r\nif (!arsta->txrate.legacy && !arsta->txrate.nss)\r\nreturn;\r\nif (arsta->txrate.legacy) {\r\nsinfo->txrate.legacy = arsta->txrate.legacy;\r\n} else {\r\nsinfo->txrate.mcs = arsta->txrate.mcs;\r\nsinfo->txrate.nss = arsta->txrate.nss;\r\nsinfo->txrate.bw = arsta->txrate.bw;\r\n}\r\nsinfo->txrate.flags = arsta->txrate.flags;\r\nsinfo->filled |= 1ULL << NL80211_STA_INFO_TX_BITRATE;\r\n}\r\nstatic ssize_t ath10k_dbg_sta_read_aggr_mode(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_sta *sta = file->private_data;\r\nstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\r\nstruct ath10k *ar = arsta->arvif->ar;\r\nchar buf[32];\r\nint len = 0;\r\nmutex_lock(&ar->conf_mutex);\r\nlen = scnprintf(buf, sizeof(buf) - len, "aggregation mode: %s\n",\r\n(arsta->aggr_mode == ATH10K_DBG_AGGR_MODE_AUTO) ?\r\n"auto" : "manual");\r\nmutex_unlock(&ar->conf_mutex);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\n}\r\nstatic ssize_t ath10k_dbg_sta_write_aggr_mode(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_sta *sta = file->private_data;\r\nstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\r\nstruct ath10k *ar = arsta->arvif->ar;\r\nu32 aggr_mode;\r\nint ret;\r\nif (kstrtouint_from_user(user_buf, count, 0, &aggr_mode))\r\nreturn -EINVAL;\r\nif (aggr_mode >= ATH10K_DBG_AGGR_MODE_MAX)\r\nreturn -EINVAL;\r\nmutex_lock(&ar->conf_mutex);\r\nif ((ar->state != ATH10K_STATE_ON) ||\r\n(aggr_mode == arsta->aggr_mode)) {\r\nret = count;\r\ngoto out;\r\n}\r\nret = ath10k_wmi_addba_clear_resp(ar, arsta->arvif->vdev_id, sta->addr);\r\nif (ret) {\r\nath10k_warn(ar, "failed to clear addba session ret: %d\n", ret);\r\ngoto out;\r\n}\r\narsta->aggr_mode = aggr_mode;\r\nout:\r\nmutex_unlock(&ar->conf_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t ath10k_dbg_sta_write_addba(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_sta *sta = file->private_data;\r\nstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\r\nstruct ath10k *ar = arsta->arvif->ar;\r\nu32 tid, buf_size;\r\nint ret;\r\nchar buf[64];\r\nsimple_write_to_buffer(buf, sizeof(buf) - 1, ppos, user_buf, count);\r\nbuf[sizeof(buf) - 1] = '\0';\r\nret = sscanf(buf, "%u %u", &tid, &buf_size);\r\nif (ret != 2)\r\nreturn -EINVAL;\r\nif (tid > HTT_DATA_TX_EXT_TID_MGMT - 2)\r\nreturn -EINVAL;\r\nmutex_lock(&ar->conf_mutex);\r\nif ((ar->state != ATH10K_STATE_ON) ||\r\n(arsta->aggr_mode != ATH10K_DBG_AGGR_MODE_MANUAL)) {\r\nret = count;\r\ngoto out;\r\n}\r\nret = ath10k_wmi_addba_send(ar, arsta->arvif->vdev_id, sta->addr,\r\ntid, buf_size);\r\nif (ret) {\r\nath10k_warn(ar, "failed to send addba request: vdev_id %u peer %pM tid %u buf_size %u\n",\r\narsta->arvif->vdev_id, sta->addr, tid, buf_size);\r\n}\r\nret = count;\r\nout:\r\nmutex_unlock(&ar->conf_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t ath10k_dbg_sta_write_addba_resp(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_sta *sta = file->private_data;\r\nstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\r\nstruct ath10k *ar = arsta->arvif->ar;\r\nu32 tid, status;\r\nint ret;\r\nchar buf[64];\r\nsimple_write_to_buffer(buf, sizeof(buf) - 1, ppos, user_buf, count);\r\nbuf[sizeof(buf) - 1] = '\0';\r\nret = sscanf(buf, "%u %u", &tid, &status);\r\nif (ret != 2)\r\nreturn -EINVAL;\r\nif (tid > HTT_DATA_TX_EXT_TID_MGMT - 2)\r\nreturn -EINVAL;\r\nmutex_lock(&ar->conf_mutex);\r\nif ((ar->state != ATH10K_STATE_ON) ||\r\n(arsta->aggr_mode != ATH10K_DBG_AGGR_MODE_MANUAL)) {\r\nret = count;\r\ngoto out;\r\n}\r\nret = ath10k_wmi_addba_set_resp(ar, arsta->arvif->vdev_id, sta->addr,\r\ntid, status);\r\nif (ret) {\r\nath10k_warn(ar, "failed to send addba response: vdev_id %u peer %pM tid %u status%u\n",\r\narsta->arvif->vdev_id, sta->addr, tid, status);\r\n}\r\nret = count;\r\nout:\r\nmutex_unlock(&ar->conf_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t ath10k_dbg_sta_write_delba(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_sta *sta = file->private_data;\r\nstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\r\nstruct ath10k *ar = arsta->arvif->ar;\r\nu32 tid, initiator, reason;\r\nint ret;\r\nchar buf[64];\r\nsimple_write_to_buffer(buf, sizeof(buf) - 1, ppos, user_buf, count);\r\nbuf[sizeof(buf) - 1] = '\0';\r\nret = sscanf(buf, "%u %u %u", &tid, &initiator, &reason);\r\nif (ret != 3)\r\nreturn -EINVAL;\r\nif (tid > HTT_DATA_TX_EXT_TID_MGMT - 2)\r\nreturn -EINVAL;\r\nmutex_lock(&ar->conf_mutex);\r\nif ((ar->state != ATH10K_STATE_ON) ||\r\n(arsta->aggr_mode != ATH10K_DBG_AGGR_MODE_MANUAL)) {\r\nret = count;\r\ngoto out;\r\n}\r\nret = ath10k_wmi_delba_send(ar, arsta->arvif->vdev_id, sta->addr,\r\ntid, initiator, reason);\r\nif (ret) {\r\nath10k_warn(ar, "failed to send delba: vdev_id %u peer %pM tid %u initiator %u reason %u\n",\r\narsta->arvif->vdev_id, sta->addr, tid, initiator,\r\nreason);\r\n}\r\nret = count;\r\nout:\r\nmutex_unlock(&ar->conf_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t ath10k_dbg_sta_read_peer_debug_trigger(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count,\r\nloff_t *ppos)\r\n{\r\nstruct ieee80211_sta *sta = file->private_data;\r\nstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\r\nstruct ath10k *ar = arsta->arvif->ar;\r\nchar buf[8];\r\nint len = 0;\r\nmutex_lock(&ar->conf_mutex);\r\nlen = scnprintf(buf, sizeof(buf) - len,\r\n"Write 1 to once trigger the debug logs\n");\r\nmutex_unlock(&ar->conf_mutex);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\n}\r\nstatic ssize_t\r\nath10k_dbg_sta_write_peer_debug_trigger(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_sta *sta = file->private_data;\r\nstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\r\nstruct ath10k *ar = arsta->arvif->ar;\r\nu8 peer_debug_trigger;\r\nint ret;\r\nif (kstrtou8_from_user(user_buf, count, 0, &peer_debug_trigger))\r\nreturn -EINVAL;\r\nif (peer_debug_trigger != 1)\r\nreturn -EINVAL;\r\nmutex_lock(&ar->conf_mutex);\r\nif (ar->state != ATH10K_STATE_ON) {\r\nret = -ENETDOWN;\r\ngoto out;\r\n}\r\nret = ath10k_wmi_peer_set_param(ar, arsta->arvif->vdev_id, sta->addr,\r\nWMI_PEER_DEBUG, peer_debug_trigger);\r\nif (ret) {\r\nath10k_warn(ar, "failed to set param to trigger peer tid logs for station ret: %d\n",\r\nret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&ar->conf_mutex);\r\nreturn count;\r\n}\r\nvoid ath10k_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta, struct dentry *dir)\r\n{\r\ndebugfs_create_file("aggr_mode", 0644, dir, sta, &fops_aggr_mode);\r\ndebugfs_create_file("addba", 0200, dir, sta, &fops_addba);\r\ndebugfs_create_file("addba_resp", 0200, dir, sta, &fops_addba_resp);\r\ndebugfs_create_file("delba", 0200, dir, sta, &fops_delba);\r\ndebugfs_create_file("peer_debug_trigger", 0600, dir, sta,\r\n&fops_peer_debug_trigger);\r\n}
