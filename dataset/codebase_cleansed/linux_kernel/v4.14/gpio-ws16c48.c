static int ws16c48_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct ws16c48_gpio *const ws16c48gpio = gpiochip_get_data(chip);\r\nconst unsigned port = offset / 8;\r\nconst unsigned mask = BIT(offset % 8);\r\nreturn !!(ws16c48gpio->io_state[port] & mask);\r\n}\r\nstatic int ws16c48_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct ws16c48_gpio *const ws16c48gpio = gpiochip_get_data(chip);\r\nconst unsigned port = offset / 8;\r\nconst unsigned mask = BIT(offset % 8);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&ws16c48gpio->lock, flags);\r\nws16c48gpio->io_state[port] |= mask;\r\nws16c48gpio->out_state[port] &= ~mask;\r\noutb(ws16c48gpio->out_state[port], ws16c48gpio->base + port);\r\nraw_spin_unlock_irqrestore(&ws16c48gpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ws16c48_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct ws16c48_gpio *const ws16c48gpio = gpiochip_get_data(chip);\r\nconst unsigned port = offset / 8;\r\nconst unsigned mask = BIT(offset % 8);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&ws16c48gpio->lock, flags);\r\nws16c48gpio->io_state[port] &= ~mask;\r\nif (value)\r\nws16c48gpio->out_state[port] |= mask;\r\nelse\r\nws16c48gpio->out_state[port] &= ~mask;\r\noutb(ws16c48gpio->out_state[port], ws16c48gpio->base + port);\r\nraw_spin_unlock_irqrestore(&ws16c48gpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ws16c48_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct ws16c48_gpio *const ws16c48gpio = gpiochip_get_data(chip);\r\nconst unsigned port = offset / 8;\r\nconst unsigned mask = BIT(offset % 8);\r\nunsigned long flags;\r\nunsigned port_state;\r\nraw_spin_lock_irqsave(&ws16c48gpio->lock, flags);\r\nif (!(ws16c48gpio->io_state[port] & mask)) {\r\nraw_spin_unlock_irqrestore(&ws16c48gpio->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nport_state = inb(ws16c48gpio->base + port);\r\nraw_spin_unlock_irqrestore(&ws16c48gpio->lock, flags);\r\nreturn !!(port_state & mask);\r\n}\r\nstatic void ws16c48_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct ws16c48_gpio *const ws16c48gpio = gpiochip_get_data(chip);\r\nconst unsigned port = offset / 8;\r\nconst unsigned mask = BIT(offset % 8);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&ws16c48gpio->lock, flags);\r\nif (ws16c48gpio->io_state[port] & mask) {\r\nraw_spin_unlock_irqrestore(&ws16c48gpio->lock, flags);\r\nreturn;\r\n}\r\nif (value)\r\nws16c48gpio->out_state[port] |= mask;\r\nelse\r\nws16c48gpio->out_state[port] &= ~mask;\r\noutb(ws16c48gpio->out_state[port], ws16c48gpio->base + port);\r\nraw_spin_unlock_irqrestore(&ws16c48gpio->lock, flags);\r\n}\r\nstatic void ws16c48_gpio_set_multiple(struct gpio_chip *chip,\r\nunsigned long *mask, unsigned long *bits)\r\n{\r\nstruct ws16c48_gpio *const ws16c48gpio = gpiochip_get_data(chip);\r\nunsigned int i;\r\nconst unsigned int gpio_reg_size = 8;\r\nunsigned int port;\r\nunsigned int iomask;\r\nunsigned int bitmask;\r\nunsigned long flags;\r\nfor (i = 0; i < chip->ngpio; i += gpio_reg_size) {\r\nif (!mask[BIT_WORD(i)]) {\r\ni = (BIT_WORD(i) + 1) * BITS_PER_LONG - gpio_reg_size;\r\ncontinue;\r\n}\r\nport = i / gpio_reg_size;\r\niomask = mask[BIT_WORD(i)] & ~ws16c48gpio->io_state[port];\r\nbitmask = iomask & bits[BIT_WORD(i)];\r\nraw_spin_lock_irqsave(&ws16c48gpio->lock, flags);\r\nws16c48gpio->out_state[port] &= ~iomask;\r\nws16c48gpio->out_state[port] |= bitmask;\r\noutb(ws16c48gpio->out_state[port], ws16c48gpio->base + port);\r\nraw_spin_unlock_irqrestore(&ws16c48gpio->lock, flags);\r\nmask[BIT_WORD(i)] >>= gpio_reg_size;\r\nbits[BIT_WORD(i)] >>= gpio_reg_size;\r\n}\r\n}\r\nstatic void ws16c48_irq_ack(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct ws16c48_gpio *const ws16c48gpio = gpiochip_get_data(chip);\r\nconst unsigned long offset = irqd_to_hwirq(data);\r\nconst unsigned port = offset / 8;\r\nconst unsigned mask = BIT(offset % 8);\r\nunsigned long flags;\r\nunsigned port_state;\r\nif (port > 2)\r\nreturn;\r\nraw_spin_lock_irqsave(&ws16c48gpio->lock, flags);\r\nport_state = ws16c48gpio->irq_mask >> (8*port);\r\noutb(0x80, ws16c48gpio->base + 7);\r\noutb(port_state & ~mask, ws16c48gpio->base + 8 + port);\r\noutb(port_state | mask, ws16c48gpio->base + 8 + port);\r\noutb(0xC0, ws16c48gpio->base + 7);\r\nraw_spin_unlock_irqrestore(&ws16c48gpio->lock, flags);\r\n}\r\nstatic void ws16c48_irq_mask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct ws16c48_gpio *const ws16c48gpio = gpiochip_get_data(chip);\r\nconst unsigned long offset = irqd_to_hwirq(data);\r\nconst unsigned long mask = BIT(offset);\r\nconst unsigned port = offset / 8;\r\nunsigned long flags;\r\nif (port > 2)\r\nreturn;\r\nraw_spin_lock_irqsave(&ws16c48gpio->lock, flags);\r\nws16c48gpio->irq_mask &= ~mask;\r\noutb(0x80, ws16c48gpio->base + 7);\r\noutb(ws16c48gpio->irq_mask >> (8*port), ws16c48gpio->base + 8 + port);\r\noutb(0xC0, ws16c48gpio->base + 7);\r\nraw_spin_unlock_irqrestore(&ws16c48gpio->lock, flags);\r\n}\r\nstatic void ws16c48_irq_unmask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct ws16c48_gpio *const ws16c48gpio = gpiochip_get_data(chip);\r\nconst unsigned long offset = irqd_to_hwirq(data);\r\nconst unsigned long mask = BIT(offset);\r\nconst unsigned port = offset / 8;\r\nunsigned long flags;\r\nif (port > 2)\r\nreturn;\r\nraw_spin_lock_irqsave(&ws16c48gpio->lock, flags);\r\nws16c48gpio->irq_mask |= mask;\r\noutb(0x80, ws16c48gpio->base + 7);\r\noutb(ws16c48gpio->irq_mask >> (8*port), ws16c48gpio->base + 8 + port);\r\noutb(0xC0, ws16c48gpio->base + 7);\r\nraw_spin_unlock_irqrestore(&ws16c48gpio->lock, flags);\r\n}\r\nstatic int ws16c48_irq_set_type(struct irq_data *data, unsigned flow_type)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct ws16c48_gpio *const ws16c48gpio = gpiochip_get_data(chip);\r\nconst unsigned long offset = irqd_to_hwirq(data);\r\nconst unsigned long mask = BIT(offset);\r\nconst unsigned port = offset / 8;\r\nunsigned long flags;\r\nif (port > 2)\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&ws16c48gpio->lock, flags);\r\nswitch (flow_type) {\r\ncase IRQ_TYPE_NONE:\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nws16c48gpio->flow_mask |= mask;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nws16c48gpio->flow_mask &= ~mask;\r\nbreak;\r\ndefault:\r\nraw_spin_unlock_irqrestore(&ws16c48gpio->lock, flags);\r\nreturn -EINVAL;\r\n}\r\noutb(0x40, ws16c48gpio->base + 7);\r\noutb(ws16c48gpio->flow_mask >> (8*port), ws16c48gpio->base + 8 + port);\r\noutb(0xC0, ws16c48gpio->base + 7);\r\nraw_spin_unlock_irqrestore(&ws16c48gpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ws16c48_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct ws16c48_gpio *const ws16c48gpio = dev_id;\r\nstruct gpio_chip *const chip = &ws16c48gpio->chip;\r\nunsigned long int_pending;\r\nunsigned long port;\r\nunsigned long int_id;\r\nunsigned long gpio;\r\nint_pending = inb(ws16c48gpio->base + 6) & 0x7;\r\nif (!int_pending)\r\nreturn IRQ_NONE;\r\ndo {\r\nfor_each_set_bit(port, &int_pending, 3) {\r\nint_id = inb(ws16c48gpio->base + 8 + port);\r\nfor_each_set_bit(gpio, &int_id, 8)\r\ngeneric_handle_irq(irq_find_mapping(\r\nchip->irqdomain, gpio + 8*port));\r\n}\r\nint_pending = inb(ws16c48gpio->base + 6) & 0x7;\r\n} while (int_pending);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ws16c48_probe(struct device *dev, unsigned int id)\r\n{\r\nstruct ws16c48_gpio *ws16c48gpio;\r\nconst char *const name = dev_name(dev);\r\nint err;\r\nws16c48gpio = devm_kzalloc(dev, sizeof(*ws16c48gpio), GFP_KERNEL);\r\nif (!ws16c48gpio)\r\nreturn -ENOMEM;\r\nif (!devm_request_region(dev, base[id], WS16C48_EXTENT, name)) {\r\ndev_err(dev, "Unable to lock port addresses (0x%X-0x%X)\n",\r\nbase[id], base[id] + WS16C48_EXTENT);\r\nreturn -EBUSY;\r\n}\r\nws16c48gpio->chip.label = name;\r\nws16c48gpio->chip.parent = dev;\r\nws16c48gpio->chip.owner = THIS_MODULE;\r\nws16c48gpio->chip.base = -1;\r\nws16c48gpio->chip.ngpio = WS16C48_NGPIO;\r\nws16c48gpio->chip.names = ws16c48_names;\r\nws16c48gpio->chip.get_direction = ws16c48_gpio_get_direction;\r\nws16c48gpio->chip.direction_input = ws16c48_gpio_direction_input;\r\nws16c48gpio->chip.direction_output = ws16c48_gpio_direction_output;\r\nws16c48gpio->chip.get = ws16c48_gpio_get;\r\nws16c48gpio->chip.set = ws16c48_gpio_set;\r\nws16c48gpio->chip.set_multiple = ws16c48_gpio_set_multiple;\r\nws16c48gpio->base = base[id];\r\nraw_spin_lock_init(&ws16c48gpio->lock);\r\nerr = devm_gpiochip_add_data(dev, &ws16c48gpio->chip, ws16c48gpio);\r\nif (err) {\r\ndev_err(dev, "GPIO registering failed (%d)\n", err);\r\nreturn err;\r\n}\r\noutb(0x80, base[id] + 7);\r\noutb(0, base[id] + 8);\r\noutb(0, base[id] + 9);\r\noutb(0, base[id] + 10);\r\noutb(0xC0, base[id] + 7);\r\nerr = gpiochip_irqchip_add(&ws16c48gpio->chip, &ws16c48_irqchip, 0,\r\nhandle_edge_irq, IRQ_TYPE_NONE);\r\nif (err) {\r\ndev_err(dev, "Could not add irqchip (%d)\n", err);\r\nreturn err;\r\n}\r\nerr = devm_request_irq(dev, irq[id], ws16c48_irq_handler, IRQF_SHARED,\r\nname, ws16c48gpio);\r\nif (err) {\r\ndev_err(dev, "IRQ handler registering failed (%d)\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
