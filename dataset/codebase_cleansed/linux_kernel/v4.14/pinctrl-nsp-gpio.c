static inline unsigned nsp_pin_to_gpio(unsigned pin)\r\n{\r\nreturn pin;\r\n}\r\nstatic inline void nsp_set_bit(struct nsp_gpio *chip, enum base_type address,\r\nunsigned int reg, unsigned gpio, bool set)\r\n{\r\nu32 val;\r\nvoid __iomem *base_address;\r\nif (address == IO_CTRL)\r\nbase_address = chip->io_ctrl;\r\nelse\r\nbase_address = chip->base;\r\nval = readl(base_address + reg);\r\nif (set)\r\nval |= BIT(gpio);\r\nelse\r\nval &= ~BIT(gpio);\r\nwritel(val, base_address + reg);\r\n}\r\nstatic inline bool nsp_get_bit(struct nsp_gpio *chip, enum base_type address,\r\nunsigned int reg, unsigned gpio)\r\n{\r\nif (address == IO_CTRL)\r\nreturn !!(readl(chip->io_ctrl + reg) & BIT(gpio));\r\nelse\r\nreturn !!(readl(chip->base + reg) & BIT(gpio));\r\n}\r\nstatic irqreturn_t nsp_gpio_irq_handler(int irq, void *data)\r\n{\r\nstruct nsp_gpio *chip = (struct nsp_gpio *)data;\r\nstruct gpio_chip gc = chip->gc;\r\nint bit;\r\nunsigned long int_bits = 0;\r\nu32 int_status;\r\nint_status = readl(chip->base + NSP_CHIP_A_INT_STATUS);\r\nif (int_status & NSP_CHIP_A_GPIO_INT_BIT) {\r\nunsigned int event, level;\r\nevent = readl(chip->base + NSP_GPIO_EVENT_INT_MASK) &\r\nreadl(chip->base + NSP_GPIO_EVENT);\r\nlevel = readl(chip->base + NSP_GPIO_DATA_IN) ^\r\nreadl(chip->base + NSP_GPIO_INT_POLARITY);\r\nlevel &= readl(chip->base + NSP_GPIO_INT_MASK);\r\nint_bits = level | event;\r\nfor_each_set_bit(bit, &int_bits, gc.ngpio) {\r\nwritel(BIT(bit), chip->base + NSP_GPIO_EVENT);\r\ngeneric_handle_irq(\r\nirq_linear_revmap(chip->irq_domain, bit));\r\n}\r\n}\r\nreturn int_bits ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void nsp_gpio_irq_ack(struct irq_data *d)\r\n{\r\nstruct nsp_gpio *chip = irq_data_get_irq_chip_data(d);\r\nunsigned gpio = d->hwirq;\r\nu32 val = BIT(gpio);\r\nu32 trigger_type;\r\ntrigger_type = irq_get_trigger_type(d->irq);\r\nif (trigger_type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\r\nnsp_set_bit(chip, REG, NSP_GPIO_EVENT, gpio, val);\r\n}\r\nstatic void nsp_gpio_irq_set_mask(struct irq_data *d, bool unmask)\r\n{\r\nstruct nsp_gpio *chip = irq_data_get_irq_chip_data(d);\r\nunsigned gpio = d->hwirq;\r\nu32 trigger_type;\r\ntrigger_type = irq_get_trigger_type(d->irq);\r\nif (trigger_type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\r\nnsp_set_bit(chip, REG, NSP_GPIO_EVENT_INT_MASK, gpio, unmask);\r\nelse\r\nnsp_set_bit(chip, REG, NSP_GPIO_INT_MASK, gpio, unmask);\r\n}\r\nstatic void nsp_gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct nsp_gpio *chip = irq_data_get_irq_chip_data(d);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\nnsp_gpio_irq_set_mask(d, false);\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nstatic void nsp_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct nsp_gpio *chip = irq_data_get_irq_chip_data(d);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\nnsp_gpio_irq_set_mask(d, true);\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nstatic int nsp_gpio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct nsp_gpio *chip = irq_data_get_irq_chip_data(d);\r\nunsigned gpio = d->hwirq;\r\nbool level_low;\r\nbool falling;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\nfalling = nsp_get_bit(chip, REG, NSP_GPIO_EVENT_INT_POLARITY, gpio);\r\nlevel_low = nsp_get_bit(chip, REG, NSP_GPIO_INT_POLARITY, gpio);\r\nswitch (type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nfalling = false;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nfalling = true;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nlevel_low = false;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nlevel_low = true;\r\nbreak;\r\ndefault:\r\ndev_err(chip->dev, "invalid GPIO IRQ type 0x%x\n",\r\ntype);\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nnsp_set_bit(chip, REG, NSP_GPIO_EVENT_INT_POLARITY, gpio, falling);\r\nnsp_set_bit(chip, REG, NSP_GPIO_INT_POLARITY, gpio, level_low);\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\ndev_dbg(chip->dev, "gpio:%u level_low:%s falling:%s\n", gpio,\r\nlevel_low ? "true" : "false", falling ? "true" : "false");\r\nreturn 0;\r\n}\r\nstatic int nsp_gpio_request(struct gpio_chip *gc, unsigned offset)\r\n{\r\nunsigned gpio = gc->base + offset;\r\nreturn pinctrl_request_gpio(gpio);\r\n}\r\nstatic void nsp_gpio_free(struct gpio_chip *gc, unsigned offset)\r\n{\r\nunsigned gpio = gc->base + offset;\r\npinctrl_free_gpio(gpio);\r\n}\r\nstatic int nsp_gpio_direction_input(struct gpio_chip *gc, unsigned gpio)\r\n{\r\nstruct nsp_gpio *chip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\nnsp_set_bit(chip, REG, NSP_GPIO_OUT_EN, gpio, false);\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\ndev_dbg(chip->dev, "gpio:%u set input\n", gpio);\r\nreturn 0;\r\n}\r\nstatic int nsp_gpio_direction_output(struct gpio_chip *gc, unsigned gpio,\r\nint val)\r\n{\r\nstruct nsp_gpio *chip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\nnsp_set_bit(chip, REG, NSP_GPIO_OUT_EN, gpio, true);\r\nnsp_set_bit(chip, REG, NSP_GPIO_DATA_OUT, gpio, !!(val));\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\ndev_dbg(chip->dev, "gpio:%u set output, value:%d\n", gpio, val);\r\nreturn 0;\r\n}\r\nstatic void nsp_gpio_set(struct gpio_chip *gc, unsigned gpio, int val)\r\n{\r\nstruct nsp_gpio *chip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\nnsp_set_bit(chip, REG, NSP_GPIO_DATA_OUT, gpio, !!(val));\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\ndev_dbg(chip->dev, "gpio:%u set, value:%d\n", gpio, val);\r\n}\r\nstatic int nsp_gpio_get(struct gpio_chip *gc, unsigned gpio)\r\n{\r\nstruct nsp_gpio *chip = gpiochip_get_data(gc);\r\nreturn !!(readl(chip->base + NSP_GPIO_DATA_IN) & BIT(gpio));\r\n}\r\nstatic int nsp_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct nsp_gpio *chip = gpiochip_get_data(gc);\r\nreturn irq_linear_revmap(chip->irq_domain, offset);\r\n}\r\nstatic int nsp_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn 1;\r\n}\r\nstatic const char *nsp_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nreturn "gpio_grp";\r\n}\r\nstatic int nsp_gpio_set_slew(struct nsp_gpio *chip, unsigned gpio, u32 slew)\r\n{\r\nif (slew)\r\nnsp_set_bit(chip, IO_CTRL, NSP_GPIO_SLEW_RATE_EN, gpio, true);\r\nelse\r\nnsp_set_bit(chip, IO_CTRL, NSP_GPIO_SLEW_RATE_EN, gpio, false);\r\nreturn 0;\r\n}\r\nstatic int nsp_gpio_set_pull(struct nsp_gpio *chip, unsigned gpio,\r\nbool pull_up, bool pull_down)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\nnsp_set_bit(chip, IO_CTRL, NSP_PULL_DOWN_EN, gpio, pull_down);\r\nnsp_set_bit(chip, IO_CTRL, NSP_PULL_UP_EN, gpio, pull_up);\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\ndev_dbg(chip->dev, "gpio:%u set pullup:%d pulldown: %d\n",\r\ngpio, pull_up, pull_down);\r\nreturn 0;\r\n}\r\nstatic void nsp_gpio_get_pull(struct nsp_gpio *chip, unsigned gpio,\r\nbool *pull_up, bool *pull_down)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\n*pull_up = nsp_get_bit(chip, IO_CTRL, NSP_PULL_UP_EN, gpio);\r\n*pull_down = nsp_get_bit(chip, IO_CTRL, NSP_PULL_DOWN_EN, gpio);\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nstatic int nsp_gpio_set_strength(struct nsp_gpio *chip, unsigned gpio,\r\nu32 strength)\r\n{\r\nu32 offset, shift, i;\r\nu32 val;\r\nunsigned long flags;\r\nif (strength < 2 || strength > 16 || (strength % 2))\r\nreturn -ENOTSUPP;\r\nshift = gpio;\r\noffset = NSP_GPIO_DRV_CTRL;\r\ndev_dbg(chip->dev, "gpio:%u set drive strength:%d mA\n", gpio,\r\nstrength);\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\nstrength = (strength / 2) - 1;\r\nfor (i = GPIO_DRV_STRENGTH_BITS; i > 0; i--) {\r\nval = readl(chip->io_ctrl + offset);\r\nval &= ~BIT(shift);\r\nval |= ((strength >> (i-1)) & 0x1) << shift;\r\nwritel(val, chip->io_ctrl + offset);\r\noffset += 4;\r\n}\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int nsp_gpio_get_strength(struct nsp_gpio *chip, unsigned gpio,\r\nu16 *strength)\r\n{\r\nunsigned int offset, shift;\r\nu32 val;\r\nunsigned long flags;\r\nint i;\r\noffset = NSP_GPIO_DRV_CTRL;\r\nshift = gpio;\r\nraw_spin_lock_irqsave(&chip->lock, flags);\r\n*strength = 0;\r\nfor (i = (GPIO_DRV_STRENGTH_BITS - 1); i >= 0; i--) {\r\nval = readl(chip->io_ctrl + offset) & BIT(shift);\r\nval >>= shift;\r\n*strength += (val << i);\r\noffset += 4;\r\n}\r\n*strength = (*strength + 1) * 2;\r\nraw_spin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int nsp_pin_config_group_get(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nunsigned long *config)\r\n{\r\nreturn 0;\r\n}\r\nstatic int nsp_pin_config_group_set(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nreturn 0;\r\n}\r\nstatic int nsp_pin_config_get(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *config)\r\n{\r\nstruct nsp_gpio *chip = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nunsigned int gpio;\r\nu16 arg = 0;\r\nbool pull_up, pull_down;\r\nint ret;\r\ngpio = nsp_pin_to_gpio(pin);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nnsp_gpio_get_pull(chip, gpio, &pull_up, &pull_down);\r\nif ((pull_up == false) && (pull_down == false))\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nnsp_gpio_get_pull(chip, gpio, &pull_up, &pull_down);\r\nif (pull_up)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nnsp_gpio_get_pull(chip, gpio, &pull_up, &pull_down);\r\nif (pull_down)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nret = nsp_gpio_get_strength(chip, gpio, &arg);\r\nif (ret)\r\nreturn ret;\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nstatic int nsp_pin_config_set(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nstruct nsp_gpio *chip = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param;\r\nu32 arg;\r\nunsigned int i, gpio;\r\nint ret = -ENOTSUPP;\r\ngpio = nsp_pin_to_gpio(pin);\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nret = nsp_gpio_set_pull(chip, gpio, false, false);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nret = nsp_gpio_set_pull(chip, gpio, true, false);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nret = nsp_gpio_set_pull(chip, gpio, false, true);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nret = nsp_gpio_set_strength(chip, gpio, arg);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ncase PIN_CONFIG_SLEW_RATE:\r\nret = nsp_gpio_set_slew(chip, gpio, arg);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ndefault:\r\ndev_err(chip->dev, "invalid configuration\n");\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int nsp_gpio_register_pinconf(struct nsp_gpio *chip)\r\n{\r\nstruct pinctrl_desc *pctldesc = &chip->pctldesc;\r\nstruct pinctrl_pin_desc *pins;\r\nstruct gpio_chip *gc = &chip->gc;\r\nint i;\r\npins = devm_kcalloc(chip->dev, gc->ngpio, sizeof(*pins), GFP_KERNEL);\r\nif (!pins)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < gc->ngpio; i++) {\r\npins[i].number = i;\r\npins[i].name = devm_kasprintf(chip->dev, GFP_KERNEL,\r\n"gpio-%d", i);\r\nif (!pins[i].name)\r\nreturn -ENOMEM;\r\n}\r\npctldesc->name = dev_name(chip->dev);\r\npctldesc->pctlops = &nsp_pctrl_ops;\r\npctldesc->pins = pins;\r\npctldesc->npins = gc->ngpio;\r\npctldesc->confops = &nsp_pconf_ops;\r\nchip->pctl = devm_pinctrl_register(chip->dev, pctldesc, chip);\r\nif (IS_ERR(chip->pctl)) {\r\ndev_err(chip->dev, "unable to register pinctrl device\n");\r\nreturn PTR_ERR(chip->pctl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int nsp_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct nsp_gpio *chip;\r\nstruct gpio_chip *gc;\r\nu32 val, count;\r\nint irq, ret;\r\nif (of_property_read_u32(pdev->dev.of_node, "ngpios", &val)) {\r\ndev_err(&pdev->dev, "Missing ngpios OF property\n");\r\nreturn -ENODEV;\r\n}\r\nchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->dev = dev;\r\nplatform_set_drvdata(pdev, chip);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nchip->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(chip->base)) {\r\ndev_err(dev, "unable to map I/O memory\n");\r\nreturn PTR_ERR(chip->base);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nchip->io_ctrl = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(chip->io_ctrl)) {\r\ndev_err(dev, "unable to map I/O memory\n");\r\nreturn PTR_ERR(chip->io_ctrl);\r\n}\r\nraw_spin_lock_init(&chip->lock);\r\ngc = &chip->gc;\r\ngc->base = -1;\r\ngc->can_sleep = false;\r\ngc->ngpio = val;\r\ngc->label = dev_name(dev);\r\ngc->parent = dev;\r\ngc->of_node = dev->of_node;\r\ngc->request = nsp_gpio_request;\r\ngc->free = nsp_gpio_free;\r\ngc->direction_input = nsp_gpio_direction_input;\r\ngc->direction_output = nsp_gpio_direction_output;\r\ngc->set = nsp_gpio_set;\r\ngc->get = nsp_gpio_get;\r\ngc->to_irq = nsp_gpio_to_irq;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq > 0) {\r\nchip->irq_domain = irq_domain_add_linear(gc->of_node, gc->ngpio,\r\n&irq_domain_simple_ops,\r\nchip);\r\nif (!chip->irq_domain) {\r\ndev_err(&pdev->dev, "Couldn't allocate IRQ domain\n");\r\nreturn -ENXIO;\r\n}\r\nfor (count = 0; count < gc->ngpio; count++) {\r\nint irq = irq_create_mapping(chip->irq_domain, count);\r\nirq_set_chip_and_handler(irq, &nsp_gpio_irq_chip,\r\nhandle_simple_irq);\r\nirq_set_chip_data(irq, chip);\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, nsp_gpio_irq_handler,\r\nIRQF_SHARED, "gpio-a", chip);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to request IRQ%d: %d\n",\r\nirq, ret);\r\ngoto err_rm_gpiochip;\r\n}\r\nval = readl(chip->base + NSP_CHIP_A_INT_MASK);\r\nval = val | NSP_CHIP_A_GPIO_INT_BIT;\r\nwritel(val, (chip->base + NSP_CHIP_A_INT_MASK));\r\n}\r\nret = gpiochip_add_data(gc, chip);\r\nif (ret < 0) {\r\ndev_err(dev, "unable to add GPIO chip\n");\r\nreturn ret;\r\n}\r\nret = nsp_gpio_register_pinconf(chip);\r\nif (ret) {\r\ndev_err(dev, "unable to register pinconf\n");\r\ngoto err_rm_gpiochip;\r\n}\r\nreturn 0;\r\nerr_rm_gpiochip:\r\ngpiochip_remove(gc);\r\nreturn ret;\r\n}\r\nstatic int __init nsp_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&nsp_gpio_driver);\r\n}
