static void\r\n_set_debug(struct sfax_hw *card)\r\n{\r\ncard->isac.dch.debug = debug;\r\ncard->isar.ch[0].bch.debug = debug;\r\ncard->isar.ch[1].bch.debug = debug;\r\n}\r\nstatic int\r\nset_debug(const char *val, struct kernel_param *kp)\r\n{\r\nint ret;\r\nstruct sfax_hw *card;\r\nret = param_set_uint(val, kp);\r\nif (!ret) {\r\nread_lock(&card_lock);\r\nlist_for_each_entry(card, &Cards, list)\r\n_set_debug(card);\r\nread_unlock(&card_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t\r\nspeedfax_irq(int intno, void *dev_id)\r\n{\r\nstruct sfax_hw *sf = dev_id;\r\nu8 val;\r\nint cnt = irqloops;\r\nspin_lock(&sf->lock);\r\nval = inb(sf->cfg + TIGER_AUX_STATUS);\r\nif (val & SFAX_TIGER_IRQ_BIT) {\r\nspin_unlock(&sf->lock);\r\nreturn IRQ_NONE;\r\n}\r\nsf->irqcnt++;\r\nval = ReadISAR_IND(sf, ISAR_IRQBIT);\r\nStart_ISAR:\r\nif (val & ISAR_IRQSTA)\r\nmISDNisar_irq(&sf->isar);\r\nval = ReadISAC_IND(sf, ISAC_ISTA);\r\nif (val)\r\nmISDNisac_irq(&sf->isac, val);\r\nval = ReadISAR_IND(sf, ISAR_IRQBIT);\r\nif ((val & ISAR_IRQSTA) && cnt--)\r\ngoto Start_ISAR;\r\nif (cnt < irqloops)\r\npr_debug("%s: %d irqloops cpu%d\n", sf->name,\r\nirqloops - cnt, smp_processor_id());\r\nif (irqloops && !cnt)\r\npr_notice("%s: %d IRQ LOOP cpu%d\n", sf->name,\r\nirqloops, smp_processor_id());\r\nspin_unlock(&sf->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nenable_hwirq(struct sfax_hw *sf)\r\n{\r\nWriteISAC_IND(sf, ISAC_MASK, 0);\r\nWriteISAR_IND(sf, ISAR_IRQBIT, ISAR_IRQMSK);\r\noutb(SFAX_TIGER_IRQ_BIT, sf->cfg + TIGER_AUX_IRQMASK);\r\n}\r\nstatic void\r\ndisable_hwirq(struct sfax_hw *sf)\r\n{\r\nWriteISAC_IND(sf, ISAC_MASK, 0xFF);\r\nWriteISAR_IND(sf, ISAR_IRQBIT, 0);\r\noutb(0, sf->cfg + TIGER_AUX_IRQMASK);\r\n}\r\nstatic void\r\nreset_speedfax(struct sfax_hw *sf)\r\n{\r\npr_debug("%s: resetting card\n", sf->name);\r\noutb(TIGER_EXTERN_RESET_ON, sf->cfg + TIGER_RESET_ADDR);\r\noutb(SFAX_PCI_RESET_ON, sf->cfg + TIGER_AUX_DATA);\r\nmdelay(1);\r\noutb(TIGER_EXTERN_RESET_OFF, sf->cfg + TIGER_RESET_ADDR);\r\nsf->aux_data = SFAX_PCI_RESET_OFF;\r\noutb(sf->aux_data, sf->cfg + TIGER_AUX_DATA);\r\nmdelay(1);\r\n}\r\nstatic int\r\nsfax_ctrl(struct sfax_hw *sf, u32 cmd, u_long arg)\r\n{\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase HW_RESET_REQ:\r\nreset_speedfax(sf);\r\nbreak;\r\ncase HW_ACTIVATE_IND:\r\nif (arg & 1)\r\nsf->aux_data &= ~SFAX_LED1_BIT;\r\nif (arg & 2)\r\nsf->aux_data &= ~SFAX_LED2_BIT;\r\noutb(sf->aux_data, sf->cfg + TIGER_AUX_DATA);\r\nbreak;\r\ncase HW_DEACT_IND:\r\nif (arg & 1)\r\nsf->aux_data |= SFAX_LED1_BIT;\r\nif (arg & 2)\r\nsf->aux_data |= SFAX_LED2_BIT;\r\noutb(sf->aux_data, sf->cfg + TIGER_AUX_DATA);\r\nbreak;\r\ndefault:\r\npr_info("%s: %s unknown command %x %lx\n",\r\nsf->name, __func__, cmd, arg);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nchannel_ctrl(struct sfax_hw *sf, struct mISDN_ctrl_req *cq)\r\n{\r\nint ret = 0;\r\nswitch (cq->op) {\r\ncase MISDN_CTRL_GETOP:\r\ncq->op = MISDN_CTRL_LOOP | MISDN_CTRL_L1_TIMER3;\r\nbreak;\r\ncase MISDN_CTRL_LOOP:\r\nif (cq->channel < 0 || cq->channel > 3) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = sf->isac.ctrl(&sf->isac, HW_TESTLOOP, cq->channel);\r\nbreak;\r\ncase MISDN_CTRL_L1_TIMER3:\r\nret = sf->isac.ctrl(&sf->isac, HW_TIMER3_VALUE, cq->p1);\r\nbreak;\r\ndefault:\r\npr_info("%s: unknown Op %x\n", sf->name, cq->op);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nsfax_dctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\r\n{\r\nstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\r\nstruct dchannel *dch = container_of(dev, struct dchannel, dev);\r\nstruct sfax_hw *sf = dch->hw;\r\nstruct channel_req *rq;\r\nint err = 0;\r\npr_debug("%s: cmd:%x %p\n", sf->name, cmd, arg);\r\nswitch (cmd) {\r\ncase OPEN_CHANNEL:\r\nrq = arg;\r\nif (rq->protocol == ISDN_P_TE_S0)\r\nerr = sf->isac.open(&sf->isac, rq);\r\nelse\r\nerr = sf->isar.open(&sf->isar, rq);\r\nif (err)\r\nbreak;\r\nif (!try_module_get(THIS_MODULE))\r\npr_info("%s: cannot get module\n", sf->name);\r\nbreak;\r\ncase CLOSE_CHANNEL:\r\npr_debug("%s: dev(%d) close from %p\n", sf->name,\r\ndch->dev.id, __builtin_return_address(0));\r\nmodule_put(THIS_MODULE);\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nerr = channel_ctrl(sf, arg);\r\nbreak;\r\ndefault:\r\npr_debug("%s: unknown command %x\n", sf->name, cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\ninit_card(struct sfax_hw *sf)\r\n{\r\nint ret, cnt = 3;\r\nu_long flags;\r\nret = request_irq(sf->irq, speedfax_irq, IRQF_SHARED, sf->name, sf);\r\nif (ret) {\r\npr_info("%s: couldn't get interrupt %d\n", sf->name, sf->irq);\r\nreturn ret;\r\n}\r\nwhile (cnt--) {\r\nspin_lock_irqsave(&sf->lock, flags);\r\nret = sf->isac.init(&sf->isac);\r\nif (ret) {\r\nspin_unlock_irqrestore(&sf->lock, flags);\r\npr_info("%s: ISAC init failed with %d\n",\r\nsf->name, ret);\r\nbreak;\r\n}\r\nenable_hwirq(sf);\r\nWriteISAC_IND(sf, ISAC_CMDR, 0x41);\r\nspin_unlock_irqrestore(&sf->lock, flags);\r\nmsleep_interruptible(10);\r\nif (debug & DEBUG_HW)\r\npr_notice("%s: IRQ %d count %d\n", sf->name,\r\nsf->irq, sf->irqcnt);\r\nif (!sf->irqcnt) {\r\npr_info("%s: IRQ(%d) got no requests during init %d\n",\r\nsf->name, sf->irq, 3 - cnt);\r\n} else\r\nreturn 0;\r\n}\r\nfree_irq(sf->irq, sf);\r\nreturn -EIO;\r\n}\r\nstatic int\r\nsetup_speedfax(struct sfax_hw *sf)\r\n{\r\nu_long flags;\r\nif (!request_region(sf->cfg, 256, sf->name)) {\r\npr_info("mISDN: %s config port %x-%x already in use\n",\r\nsf->name, sf->cfg, sf->cfg + 255);\r\nreturn -EIO;\r\n}\r\noutb(0xff, sf->cfg);\r\noutb(0, sf->cfg);\r\noutb(0xdd, sf->cfg + TIGER_AUX_CTRL);\r\noutb(0, sf->cfg + TIGER_AUX_IRQMASK);\r\nsf->isac.type = IPAC_TYPE_ISAC;\r\nsf->p_isac.ale = sf->cfg + SFAX_PCI_ADDR;\r\nsf->p_isac.port = sf->cfg + SFAX_PCI_ISAC;\r\nsf->p_isar.ale = sf->cfg + SFAX_PCI_ADDR;\r\nsf->p_isar.port = sf->cfg + SFAX_PCI_ISAR;\r\nASSIGN_FUNC(IND, ISAC, sf->isac);\r\nASSIGN_FUNC(IND, ISAR, sf->isar);\r\nspin_lock_irqsave(&sf->lock, flags);\r\nreset_speedfax(sf);\r\ndisable_hwirq(sf);\r\nspin_unlock_irqrestore(&sf->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nrelease_card(struct sfax_hw *card) {\r\nu_long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\ndisable_hwirq(card);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncard->isac.release(&card->isac);\r\nfree_irq(card->irq, card);\r\ncard->isar.release(&card->isar);\r\nmISDN_unregister_device(&card->isac.dch.dev);\r\nrelease_region(card->cfg, 256);\r\npci_disable_device(card->pdev);\r\npci_set_drvdata(card->pdev, NULL);\r\nwrite_lock_irqsave(&card_lock, flags);\r\nlist_del(&card->list);\r\nwrite_unlock_irqrestore(&card_lock, flags);\r\nkfree(card);\r\nsfax_cnt--;\r\n}\r\nstatic int\r\nsetup_instance(struct sfax_hw *card)\r\n{\r\nconst struct firmware *firmware;\r\nint i, err;\r\nu_long flags;\r\nsnprintf(card->name, MISDN_MAX_IDLEN - 1, "Speedfax.%d", sfax_cnt + 1);\r\nwrite_lock_irqsave(&card_lock, flags);\r\nlist_add_tail(&card->list, &Cards);\r\nwrite_unlock_irqrestore(&card_lock, flags);\r\n_set_debug(card);\r\nspin_lock_init(&card->lock);\r\ncard->isac.hwlock = &card->lock;\r\ncard->isar.hwlock = &card->lock;\r\ncard->isar.ctrl = (void *)&sfax_ctrl;\r\ncard->isac.name = card->name;\r\ncard->isar.name = card->name;\r\ncard->isar.owner = THIS_MODULE;\r\nerr = request_firmware(&firmware, "isdn/ISAR.BIN", &card->pdev->dev);\r\nif (err < 0) {\r\npr_info("%s: firmware request failed %d\n",\r\ncard->name, err);\r\ngoto error_fw;\r\n}\r\nif (debug & DEBUG_HW)\r\npr_notice("%s: got firmware %zu bytes\n",\r\ncard->name, firmware->size);\r\nmISDNisac_init(&card->isac, card);\r\ncard->isac.dch.dev.D.ctrl = sfax_dctrl;\r\ncard->isac.dch.dev.Bprotocols =\r\nmISDNisar_init(&card->isar, card);\r\nfor (i = 0; i < 2; i++) {\r\nset_channelmap(i + 1, card->isac.dch.dev.channelmap);\r\nlist_add(&card->isar.ch[i].bch.ch.list,\r\n&card->isac.dch.dev.bchannels);\r\n}\r\nerr = setup_speedfax(card);\r\nif (err)\r\ngoto error_setup;\r\nerr = card->isar.init(&card->isar);\r\nif (err)\r\ngoto error;\r\nerr = mISDN_register_device(&card->isac.dch.dev,\r\n&card->pdev->dev, card->name);\r\nif (err)\r\ngoto error;\r\nerr = init_card(card);\r\nif (err)\r\ngoto error_init;\r\nerr = card->isar.firmware(&card->isar, firmware->data, firmware->size);\r\nif (!err) {\r\nrelease_firmware(firmware);\r\nsfax_cnt++;\r\npr_notice("SpeedFax %d cards installed\n", sfax_cnt);\r\nreturn 0;\r\n}\r\ndisable_hwirq(card);\r\nfree_irq(card->irq, card);\r\nerror_init:\r\nmISDN_unregister_device(&card->isac.dch.dev);\r\nerror:\r\nrelease_region(card->cfg, 256);\r\nerror_setup:\r\ncard->isac.release(&card->isac);\r\ncard->isar.release(&card->isar);\r\nrelease_firmware(firmware);\r\nerror_fw:\r\npci_disable_device(card->pdev);\r\nwrite_lock_irqsave(&card_lock, flags);\r\nlist_del(&card->list);\r\nwrite_unlock_irqrestore(&card_lock, flags);\r\nkfree(card);\r\nreturn err;\r\n}\r\nstatic int\r\nsfaxpci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint err = -ENOMEM;\r\nstruct sfax_hw *card = kzalloc(sizeof(struct sfax_hw), GFP_KERNEL);\r\nif (!card) {\r\npr_info("No memory for Speedfax+ PCI\n");\r\nreturn err;\r\n}\r\ncard->pdev = pdev;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nkfree(card);\r\nreturn err;\r\n}\r\npr_notice("mISDN: Speedfax found adapter %s at %s\n",\r\n(char *)ent->driver_data, pci_name(pdev));\r\ncard->cfg = pci_resource_start(pdev, 0);\r\ncard->irq = pdev->irq;\r\npci_set_drvdata(pdev, card);\r\nerr = setup_instance(card);\r\nif (err)\r\npci_set_drvdata(pdev, NULL);\r\nreturn err;\r\n}\r\nstatic void\r\nsfax_remove_pci(struct pci_dev *pdev)\r\n{\r\nstruct sfax_hw *card = pci_get_drvdata(pdev);\r\nif (card)\r\nrelease_card(card);\r\nelse\r\npr_debug("%s: drvdata already removed\n", __func__);\r\n}\r\nstatic int __init\r\nSpeedfax_init(void)\r\n{\r\nint err;\r\npr_notice("Sedlbauer Speedfax+ Driver Rev. %s\n",\r\nSPEEDFAX_REV);\r\nerr = pci_register_driver(&sfaxpci_driver);\r\nreturn err;\r\n}\r\nstatic void __exit\r\nSpeedfax_cleanup(void)\r\n{\r\npci_unregister_driver(&sfaxpci_driver);\r\n}
