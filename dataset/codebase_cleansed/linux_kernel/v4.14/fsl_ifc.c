unsigned int convert_ifc_address(phys_addr_t addr_base)\r\n{\r\nreturn addr_base & CSPR_BA;\r\n}\r\nint fsl_ifc_find(phys_addr_t addr_base)\r\n{\r\nint i = 0;\r\nif (!fsl_ifc_ctrl_dev || !fsl_ifc_ctrl_dev->gregs)\r\nreturn -ENODEV;\r\nfor (i = 0; i < fsl_ifc_ctrl_dev->banks; i++) {\r\nu32 cspr = ifc_in32(&fsl_ifc_ctrl_dev->gregs->cspr_cs[i].cspr);\r\nif (cspr & CSPR_V && (cspr & CSPR_BA) ==\r\nconvert_ifc_address(addr_base))\r\nreturn i;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int fsl_ifc_ctrl_init(struct fsl_ifc_ctrl *ctrl)\r\n{\r\nstruct fsl_ifc_global __iomem *ifc = ctrl->gregs;\r\nif (ifc_in32(&ifc->cm_evter_stat) & IFC_CM_EVTER_STAT_CSER)\r\nifc_out32(IFC_CM_EVTER_STAT_CSER, &ifc->cm_evter_stat);\r\nifc_out32(IFC_CM_EVTER_EN_CSEREN, &ifc->cm_evter_en);\r\nifc_out32(IFC_CM_EVTER_INTR_EN_CSERIREN, &ifc->cm_evter_intr_en);\r\nifc_out32(0x0, &ifc->cm_erattr0);\r\nifc_out32(0x0, &ifc->cm_erattr1);\r\nreturn 0;\r\n}\r\nstatic int fsl_ifc_ctrl_remove(struct platform_device *dev)\r\n{\r\nstruct fsl_ifc_ctrl *ctrl = dev_get_drvdata(&dev->dev);\r\nfree_irq(ctrl->nand_irq, ctrl);\r\nfree_irq(ctrl->irq, ctrl);\r\nirq_dispose_mapping(ctrl->nand_irq);\r\nirq_dispose_mapping(ctrl->irq);\r\niounmap(ctrl->gregs);\r\ndev_set_drvdata(&dev->dev, NULL);\r\nkfree(ctrl);\r\nreturn 0;\r\n}\r\nstatic u32 check_nand_stat(struct fsl_ifc_ctrl *ctrl)\r\n{\r\nstruct fsl_ifc_runtime __iomem *ifc = ctrl->rregs;\r\nunsigned long flags;\r\nu32 stat;\r\nspin_lock_irqsave(&nand_irq_lock, flags);\r\nstat = ifc_in32(&ifc->ifc_nand.nand_evter_stat);\r\nif (stat) {\r\nifc_out32(stat, &ifc->ifc_nand.nand_evter_stat);\r\nctrl->nand_stat = stat;\r\nwake_up(&ctrl->nand_wait);\r\n}\r\nspin_unlock_irqrestore(&nand_irq_lock, flags);\r\nreturn stat;\r\n}\r\nstatic irqreturn_t fsl_ifc_nand_irq(int irqno, void *data)\r\n{\r\nstruct fsl_ifc_ctrl *ctrl = data;\r\nif (check_nand_stat(ctrl))\r\nreturn IRQ_HANDLED;\r\nreturn IRQ_NONE;\r\n}\r\nstatic irqreturn_t fsl_ifc_ctrl_irq(int irqno, void *data)\r\n{\r\nstruct fsl_ifc_ctrl *ctrl = data;\r\nstruct fsl_ifc_global __iomem *ifc = ctrl->gregs;\r\nu32 err_axiid, err_srcid, status, cs_err, err_addr;\r\nirqreturn_t ret = IRQ_NONE;\r\ncs_err = ifc_in32(&ifc->cm_evter_stat);\r\nif (cs_err) {\r\ndev_err(ctrl->dev, "transaction sent to IFC is not mapped to"\r\n"any memory bank 0x%08X\n", cs_err);\r\nifc_out32(IFC_CM_EVTER_STAT_CSER, &ifc->cm_evter_stat);\r\nstatus = ifc_in32(&ifc->cm_erattr0);\r\nerr_addr = ifc_in32(&ifc->cm_erattr1);\r\nif (status & IFC_CM_ERATTR0_ERTYP_READ)\r\ndev_err(ctrl->dev, "Read transaction error"\r\n"CM_ERATTR0 0x%08X\n", status);\r\nelse\r\ndev_err(ctrl->dev, "Write transaction error"\r\n"CM_ERATTR0 0x%08X\n", status);\r\nerr_axiid = (status & IFC_CM_ERATTR0_ERAID) >>\r\nIFC_CM_ERATTR0_ERAID_SHIFT;\r\ndev_err(ctrl->dev, "AXI ID of the error"\r\n"transaction 0x%08X\n", err_axiid);\r\nerr_srcid = (status & IFC_CM_ERATTR0_ESRCID) >>\r\nIFC_CM_ERATTR0_ESRCID_SHIFT;\r\ndev_err(ctrl->dev, "SRC ID of the error"\r\n"transaction 0x%08X\n", err_srcid);\r\ndev_err(ctrl->dev, "Transaction Address corresponding to error"\r\n"ERADDR 0x%08X\n", err_addr);\r\nret = IRQ_HANDLED;\r\n}\r\nif (check_nand_stat(ctrl))\r\nret = IRQ_HANDLED;\r\nreturn ret;\r\n}\r\nstatic int fsl_ifc_ctrl_probe(struct platform_device *dev)\r\n{\r\nint ret = 0;\r\nint version, banks;\r\nvoid __iomem *addr;\r\ndev_info(&dev->dev, "Freescale Integrated Flash Controller\n");\r\nfsl_ifc_ctrl_dev = kzalloc(sizeof(*fsl_ifc_ctrl_dev), GFP_KERNEL);\r\nif (!fsl_ifc_ctrl_dev)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&dev->dev, fsl_ifc_ctrl_dev);\r\nfsl_ifc_ctrl_dev->gregs = of_iomap(dev->dev.of_node, 0);\r\nif (!fsl_ifc_ctrl_dev->gregs) {\r\ndev_err(&dev->dev, "failed to get memory region\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nif (of_property_read_bool(dev->dev.of_node, "little-endian")) {\r\nfsl_ifc_ctrl_dev->little_endian = true;\r\ndev_dbg(&dev->dev, "IFC REGISTERS are LITTLE endian\n");\r\n} else {\r\nfsl_ifc_ctrl_dev->little_endian = false;\r\ndev_dbg(&dev->dev, "IFC REGISTERS are BIG endian\n");\r\n}\r\nversion = ifc_in32(&fsl_ifc_ctrl_dev->gregs->ifc_rev) &\r\nFSL_IFC_VERSION_MASK;\r\nbanks = (version == FSL_IFC_VERSION_1_0_0) ? 4 : 8;\r\ndev_info(&dev->dev, "IFC version %d.%d, %d banks\n",\r\nversion >> 24, (version >> 16) & 0xf, banks);\r\nfsl_ifc_ctrl_dev->version = version;\r\nfsl_ifc_ctrl_dev->banks = banks;\r\naddr = fsl_ifc_ctrl_dev->gregs;\r\nif (version >= FSL_IFC_VERSION_2_0_0)\r\naddr += PGOFFSET_64K;\r\nelse\r\naddr += PGOFFSET_4K;\r\nfsl_ifc_ctrl_dev->rregs = addr;\r\nfsl_ifc_ctrl_dev->irq = irq_of_parse_and_map(dev->dev.of_node, 0);\r\nif (fsl_ifc_ctrl_dev->irq == 0) {\r\ndev_err(&dev->dev, "failed to get irq resource "\r\n"for IFC\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nfsl_ifc_ctrl_dev->nand_irq =\r\nirq_of_parse_and_map(dev->dev.of_node, 1);\r\nfsl_ifc_ctrl_dev->dev = &dev->dev;\r\nret = fsl_ifc_ctrl_init(fsl_ifc_ctrl_dev);\r\nif (ret < 0)\r\ngoto err;\r\ninit_waitqueue_head(&fsl_ifc_ctrl_dev->nand_wait);\r\nret = request_irq(fsl_ifc_ctrl_dev->irq, fsl_ifc_ctrl_irq, IRQF_SHARED,\r\n"fsl-ifc", fsl_ifc_ctrl_dev);\r\nif (ret != 0) {\r\ndev_err(&dev->dev, "failed to install irq (%d)\n",\r\nfsl_ifc_ctrl_dev->irq);\r\ngoto err_irq;\r\n}\r\nif (fsl_ifc_ctrl_dev->nand_irq) {\r\nret = request_irq(fsl_ifc_ctrl_dev->nand_irq, fsl_ifc_nand_irq,\r\n0, "fsl-ifc-nand", fsl_ifc_ctrl_dev);\r\nif (ret != 0) {\r\ndev_err(&dev->dev, "failed to install irq (%d)\n",\r\nfsl_ifc_ctrl_dev->nand_irq);\r\ngoto err_nandirq;\r\n}\r\n}\r\nreturn 0;\r\nerr_nandirq:\r\nfree_irq(fsl_ifc_ctrl_dev->nand_irq, fsl_ifc_ctrl_dev);\r\nirq_dispose_mapping(fsl_ifc_ctrl_dev->nand_irq);\r\nerr_irq:\r\nfree_irq(fsl_ifc_ctrl_dev->irq, fsl_ifc_ctrl_dev);\r\nirq_dispose_mapping(fsl_ifc_ctrl_dev->irq);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int __init fsl_ifc_init(void)\r\n{\r\nreturn platform_driver_register(&fsl_ifc_ctrl_driver);\r\n}
