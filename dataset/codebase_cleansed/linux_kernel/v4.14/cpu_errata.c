static bool __maybe_unused\r\nis_affected_midr_range(const struct arm64_cpu_capabilities *entry, int scope)\r\n{\r\nWARN_ON(scope != SCOPE_LOCAL_CPU || preemptible());\r\nreturn MIDR_IS_CPU_MODEL_RANGE(read_cpuid_id(), entry->midr_model,\r\nentry->midr_range_min,\r\nentry->midr_range_max);\r\n}\r\nstatic bool\r\nhas_mismatched_cache_line_size(const struct arm64_cpu_capabilities *entry,\r\nint scope)\r\n{\r\nWARN_ON(scope != SCOPE_LOCAL_CPU || preemptible());\r\nreturn (read_cpuid_cachetype() & arm64_ftr_reg_ctrel0.strict_mask) !=\r\n(arm64_ftr_reg_ctrel0.sys_val & arm64_ftr_reg_ctrel0.strict_mask);\r\n}\r\nstatic int cpu_enable_trap_ctr_access(void *__unused)\r\n{\r\nconfig_sctlr_el1(SCTLR_EL1_UCT, 0);\r\nreturn 0;\r\n}\r\nvoid verify_local_cpu_errata_workarounds(void)\r\n{\r\nconst struct arm64_cpu_capabilities *caps = arm64_errata;\r\nfor (; caps->matches; caps++)\r\nif (!cpus_have_cap(caps->capability) &&\r\ncaps->matches(caps, SCOPE_LOCAL_CPU)) {\r\npr_crit("CPU%d: Requires work around for %s, not detected"\r\n" at boot time\n",\r\nsmp_processor_id(),\r\ncaps->desc ? : "an erratum");\r\ncpu_die_early();\r\n}\r\n}\r\nvoid update_cpu_errata_workarounds(void)\r\n{\r\nupdate_cpu_capabilities(arm64_errata, "enabling workaround for");\r\n}\r\nvoid __init enable_errata_workarounds(void)\r\n{\r\nenable_cpu_capabilities(arm64_errata);\r\n}
