static uint64_t uvd_v5_0_ring_get_rptr(struct amdgpu_ring *ring)\r\n{\r\nstruct amdgpu_device *adev = ring->adev;\r\nreturn RREG32(mmUVD_RBC_RB_RPTR);\r\n}\r\nstatic uint64_t uvd_v5_0_ring_get_wptr(struct amdgpu_ring *ring)\r\n{\r\nstruct amdgpu_device *adev = ring->adev;\r\nreturn RREG32(mmUVD_RBC_RB_WPTR);\r\n}\r\nstatic void uvd_v5_0_ring_set_wptr(struct amdgpu_ring *ring)\r\n{\r\nstruct amdgpu_device *adev = ring->adev;\r\nWREG32(mmUVD_RBC_RB_WPTR, lower_32_bits(ring->wptr));\r\n}\r\nstatic int uvd_v5_0_early_init(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nuvd_v5_0_set_ring_funcs(adev);\r\nuvd_v5_0_set_irq_funcs(adev);\r\nreturn 0;\r\n}\r\nstatic int uvd_v5_0_sw_init(void *handle)\r\n{\r\nstruct amdgpu_ring *ring;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nint r;\r\nr = amdgpu_irq_add_id(adev, AMDGPU_IH_CLIENTID_LEGACY, 124, &adev->uvd.irq);\r\nif (r)\r\nreturn r;\r\nr = amdgpu_uvd_sw_init(adev);\r\nif (r)\r\nreturn r;\r\nr = amdgpu_uvd_resume(adev);\r\nif (r)\r\nreturn r;\r\nring = &adev->uvd.ring;\r\nsprintf(ring->name, "uvd");\r\nr = amdgpu_ring_init(adev, ring, 512, &adev->uvd.irq, 0);\r\nreturn r;\r\n}\r\nstatic int uvd_v5_0_sw_fini(void *handle)\r\n{\r\nint r;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nr = amdgpu_uvd_suspend(adev);\r\nif (r)\r\nreturn r;\r\nreturn amdgpu_uvd_sw_fini(adev);\r\n}\r\nstatic int uvd_v5_0_hw_init(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nstruct amdgpu_ring *ring = &adev->uvd.ring;\r\nuint32_t tmp;\r\nint r;\r\namdgpu_asic_set_uvd_clocks(adev, 10000, 10000);\r\nuvd_v5_0_set_clockgating_state(adev, AMD_CG_STATE_UNGATE);\r\nuvd_v5_0_enable_mgcg(adev, true);\r\nring->ready = true;\r\nr = amdgpu_ring_test_ring(ring);\r\nif (r) {\r\nring->ready = false;\r\ngoto done;\r\n}\r\nr = amdgpu_ring_alloc(ring, 10);\r\nif (r) {\r\nDRM_ERROR("amdgpu: ring failed to lock UVD ring (%d).\n", r);\r\ngoto done;\r\n}\r\ntmp = PACKET0(mmUVD_SEMA_WAIT_FAULT_TIMEOUT_CNTL, 0);\r\namdgpu_ring_write(ring, tmp);\r\namdgpu_ring_write(ring, 0xFFFFF);\r\ntmp = PACKET0(mmUVD_SEMA_WAIT_INCOMPLETE_TIMEOUT_CNTL, 0);\r\namdgpu_ring_write(ring, tmp);\r\namdgpu_ring_write(ring, 0xFFFFF);\r\ntmp = PACKET0(mmUVD_SEMA_SIGNAL_INCOMPLETE_TIMEOUT_CNTL, 0);\r\namdgpu_ring_write(ring, tmp);\r\namdgpu_ring_write(ring, 0xFFFFF);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_SEMA_TIMEOUT_STATUS, 0));\r\namdgpu_ring_write(ring, 0x8);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_SEMA_CNTL, 0));\r\namdgpu_ring_write(ring, 3);\r\namdgpu_ring_commit(ring);\r\ndone:\r\nif (!r)\r\nDRM_INFO("UVD initialized successfully.\n");\r\nreturn r;\r\n}\r\nstatic int uvd_v5_0_hw_fini(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nstruct amdgpu_ring *ring = &adev->uvd.ring;\r\nif (RREG32(mmUVD_STATUS) != 0)\r\nuvd_v5_0_stop(adev);\r\nring->ready = false;\r\nreturn 0;\r\n}\r\nstatic int uvd_v5_0_suspend(void *handle)\r\n{\r\nint r;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nr = uvd_v5_0_hw_fini(adev);\r\nif (r)\r\nreturn r;\r\nuvd_v5_0_set_clockgating_state(adev, AMD_CG_STATE_GATE);\r\nreturn amdgpu_uvd_suspend(adev);\r\n}\r\nstatic int uvd_v5_0_resume(void *handle)\r\n{\r\nint r;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nr = amdgpu_uvd_resume(adev);\r\nif (r)\r\nreturn r;\r\nreturn uvd_v5_0_hw_init(adev);\r\n}\r\nstatic void uvd_v5_0_mc_resume(struct amdgpu_device *adev)\r\n{\r\nuint64_t offset;\r\nuint32_t size;\r\nWREG32(mmUVD_LMI_VCPU_CACHE_64BIT_BAR_LOW,\r\nlower_32_bits(adev->uvd.gpu_addr));\r\nWREG32(mmUVD_LMI_VCPU_CACHE_64BIT_BAR_HIGH,\r\nupper_32_bits(adev->uvd.gpu_addr));\r\noffset = AMDGPU_UVD_FIRMWARE_OFFSET;\r\nsize = AMDGPU_GPU_PAGE_ALIGN(adev->uvd.fw->size + 4);\r\nWREG32(mmUVD_VCPU_CACHE_OFFSET0, offset >> 3);\r\nWREG32(mmUVD_VCPU_CACHE_SIZE0, size);\r\noffset += size;\r\nsize = AMDGPU_UVD_HEAP_SIZE;\r\nWREG32(mmUVD_VCPU_CACHE_OFFSET1, offset >> 3);\r\nWREG32(mmUVD_VCPU_CACHE_SIZE1, size);\r\noffset += size;\r\nsize = AMDGPU_UVD_STACK_SIZE +\r\n(AMDGPU_UVD_SESSION_SIZE * adev->uvd.max_handles);\r\nWREG32(mmUVD_VCPU_CACHE_OFFSET2, offset >> 3);\r\nWREG32(mmUVD_VCPU_CACHE_SIZE2, size);\r\nWREG32(mmUVD_UDEC_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\r\nWREG32(mmUVD_UDEC_DB_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\r\nWREG32(mmUVD_UDEC_DBW_ADDR_CONFIG, adev->gfx.config.gb_addr_config);\r\n}\r\nstatic int uvd_v5_0_start(struct amdgpu_device *adev)\r\n{\r\nstruct amdgpu_ring *ring = &adev->uvd.ring;\r\nuint32_t rb_bufsz, tmp;\r\nuint32_t lmi_swap_cntl;\r\nuint32_t mp_swap_cntl;\r\nint i, j, r;\r\nWREG32_P(mmUVD_POWER_STATUS, 0, ~(1 << 2));\r\nlmi_swap_cntl = 0;\r\nmp_swap_cntl = 0;\r\nuvd_v5_0_mc_resume(adev);\r\nWREG32_P(mmUVD_MASTINT_EN, 0, ~(1 << 1));\r\nWREG32_P(mmUVD_LMI_CTRL2, 1 << 8, ~(1 << 8));\r\nmdelay(1);\r\nWREG32(mmUVD_SOFT_RESET, UVD_SOFT_RESET__LMI_SOFT_RESET_MASK |\r\nUVD_SOFT_RESET__VCPU_SOFT_RESET_MASK | UVD_SOFT_RESET__LBSI_SOFT_RESET_MASK |\r\nUVD_SOFT_RESET__RBC_SOFT_RESET_MASK | UVD_SOFT_RESET__CSM_SOFT_RESET_MASK |\r\nUVD_SOFT_RESET__CXW_SOFT_RESET_MASK | UVD_SOFT_RESET__TAP_SOFT_RESET_MASK |\r\nUVD_SOFT_RESET__LMI_UMC_SOFT_RESET_MASK);\r\nmdelay(5);\r\nWREG32_P(mmSRBM_SOFT_RESET, 0, ~SRBM_SOFT_RESET__SOFT_RESET_UVD_MASK);\r\nmdelay(5);\r\nWREG32(mmUVD_LMI_CTRL, 0x40 | (1 << 8) | (1 << 13) |\r\n(1 << 21) | (1 << 9) | (1 << 20));\r\n#ifdef __BIG_ENDIAN\r\nlmi_swap_cntl = 0xa;\r\nmp_swap_cntl = 0;\r\n#endif\r\nWREG32(mmUVD_LMI_SWAP_CNTL, lmi_swap_cntl);\r\nWREG32(mmUVD_MP_SWAP_CNTL, mp_swap_cntl);\r\nWREG32(mmUVD_MPC_SET_MUXA0, 0x40c2040);\r\nWREG32(mmUVD_MPC_SET_MUXA1, 0x0);\r\nWREG32(mmUVD_MPC_SET_MUXB0, 0x40c2040);\r\nWREG32(mmUVD_MPC_SET_MUXB1, 0x0);\r\nWREG32(mmUVD_MPC_SET_ALU, 0);\r\nWREG32(mmUVD_MPC_SET_MUX, 0x88);\r\nWREG32(mmUVD_SOFT_RESET, UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\r\nmdelay(5);\r\nWREG32(mmUVD_VCPU_CNTL, 1 << 9);\r\nWREG32_P(mmUVD_LMI_CTRL2, 0, ~(1 << 8));\r\nWREG32(mmUVD_SOFT_RESET, 0);\r\nmdelay(10);\r\nfor (i = 0; i < 10; ++i) {\r\nuint32_t status;\r\nfor (j = 0; j < 100; ++j) {\r\nstatus = RREG32(mmUVD_STATUS);\r\nif (status & 2)\r\nbreak;\r\nmdelay(10);\r\n}\r\nr = 0;\r\nif (status & 2)\r\nbreak;\r\nDRM_ERROR("UVD not responding, trying to reset the VCPU!!!\n");\r\nWREG32_P(mmUVD_SOFT_RESET, UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK,\r\n~UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\r\nmdelay(10);\r\nWREG32_P(mmUVD_SOFT_RESET, 0, ~UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\r\nmdelay(10);\r\nr = -1;\r\n}\r\nif (r) {\r\nDRM_ERROR("UVD not responding, giving up!!!\n");\r\nreturn r;\r\n}\r\nWREG32_P(mmUVD_MASTINT_EN, 3 << 1, ~(3 << 1));\r\nWREG32_P(mmUVD_STATUS, 0, ~(2 << 1));\r\nrb_bufsz = order_base_2(ring->ring_size);\r\ntmp = 0;\r\ntmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_BUFSZ, rb_bufsz);\r\ntmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_BLKSZ, 1);\r\ntmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_NO_FETCH, 1);\r\ntmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_WPTR_POLL_EN, 0);\r\ntmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_NO_UPDATE, 1);\r\ntmp = REG_SET_FIELD(tmp, UVD_RBC_RB_CNTL, RB_RPTR_WR_EN, 1);\r\nWREG32(mmUVD_RBC_RB_CNTL, tmp);\r\nWREG32(mmUVD_RBC_RB_WPTR_CNTL, 0);\r\nWREG32(mmUVD_RBC_RB_RPTR_ADDR, (upper_32_bits(ring->gpu_addr) >> 2));\r\nWREG32(mmUVD_LMI_RBC_RB_64BIT_BAR_LOW,\r\nlower_32_bits(ring->gpu_addr));\r\nWREG32(mmUVD_LMI_RBC_RB_64BIT_BAR_HIGH,\r\nupper_32_bits(ring->gpu_addr));\r\nWREG32(mmUVD_RBC_RB_RPTR, 0);\r\nring->wptr = RREG32(mmUVD_RBC_RB_RPTR);\r\nWREG32(mmUVD_RBC_RB_WPTR, lower_32_bits(ring->wptr));\r\nWREG32_P(mmUVD_RBC_RB_CNTL, 0, ~UVD_RBC_RB_CNTL__RB_NO_FETCH_MASK);\r\nreturn 0;\r\n}\r\nstatic void uvd_v5_0_stop(struct amdgpu_device *adev)\r\n{\r\nWREG32(mmUVD_RBC_RB_CNTL, 0x11010101);\r\nWREG32_P(mmUVD_LMI_CTRL2, 1 << 8, ~(1 << 8));\r\nmdelay(1);\r\nWREG32(mmUVD_SOFT_RESET, UVD_SOFT_RESET__VCPU_SOFT_RESET_MASK);\r\nmdelay(5);\r\nWREG32(mmUVD_VCPU_CNTL, 0x0);\r\nWREG32_P(mmUVD_LMI_CTRL2, 0, ~(1 << 8));\r\nWREG32(mmUVD_STATUS, 0);\r\n}\r\nstatic void uvd_v5_0_ring_emit_fence(struct amdgpu_ring *ring, u64 addr, u64 seq,\r\nunsigned flags)\r\n{\r\nWARN_ON(flags & AMDGPU_FENCE_FLAG_64BIT);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_CONTEXT_ID, 0));\r\namdgpu_ring_write(ring, seq);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA0, 0));\r\namdgpu_ring_write(ring, addr & 0xffffffff);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA1, 0));\r\namdgpu_ring_write(ring, upper_32_bits(addr) & 0xff);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_CMD, 0));\r\namdgpu_ring_write(ring, 0);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA0, 0));\r\namdgpu_ring_write(ring, 0);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_DATA1, 0));\r\namdgpu_ring_write(ring, 0);\r\namdgpu_ring_write(ring, PACKET0(mmUVD_GPCOM_VCPU_CMD, 0));\r\namdgpu_ring_write(ring, 2);\r\n}\r\nstatic void uvd_v5_0_ring_emit_hdp_flush(struct amdgpu_ring *ring)\r\n{\r\namdgpu_ring_write(ring, PACKET0(mmHDP_MEM_COHERENCY_FLUSH_CNTL, 0));\r\namdgpu_ring_write(ring, 0);\r\n}\r\nstatic void uvd_v5_0_ring_emit_hdp_invalidate(struct amdgpu_ring *ring)\r\n{\r\namdgpu_ring_write(ring, PACKET0(mmHDP_DEBUG0, 0));\r\namdgpu_ring_write(ring, 1);\r\n}\r\nstatic int uvd_v5_0_ring_test_ring(struct amdgpu_ring *ring)\r\n{\r\nstruct amdgpu_device *adev = ring->adev;\r\nuint32_t tmp = 0;\r\nunsigned i;\r\nint r;\r\nWREG32(mmUVD_CONTEXT_ID, 0xCAFEDEAD);\r\nr = amdgpu_ring_alloc(ring, 3);\r\nif (r) {\r\nDRM_ERROR("amdgpu: cp failed to lock ring %d (%d).\n",\r\nring->idx, r);\r\nreturn r;\r\n}\r\namdgpu_ring_write(ring, PACKET0(mmUVD_CONTEXT_ID, 0));\r\namdgpu_ring_write(ring, 0xDEADBEEF);\r\namdgpu_ring_commit(ring);\r\nfor (i = 0; i < adev->usec_timeout; i++) {\r\ntmp = RREG32(mmUVD_CONTEXT_ID);\r\nif (tmp == 0xDEADBEEF)\r\nbreak;\r\nDRM_UDELAY(1);\r\n}\r\nif (i < adev->usec_timeout) {\r\nDRM_INFO("ring test on %d succeeded in %d usecs\n",\r\nring->idx, i);\r\n} else {\r\nDRM_ERROR("amdgpu: ring %d test failed (0x%08X)\n",\r\nring->idx, tmp);\r\nr = -EINVAL;\r\n}\r\nreturn r;\r\n}\r\nstatic void uvd_v5_0_ring_emit_ib(struct amdgpu_ring *ring,\r\nstruct amdgpu_ib *ib,\r\nunsigned vm_id, bool ctx_switch)\r\n{\r\namdgpu_ring_write(ring, PACKET0(mmUVD_LMI_RBC_IB_64BIT_BAR_LOW, 0));\r\namdgpu_ring_write(ring, lower_32_bits(ib->gpu_addr));\r\namdgpu_ring_write(ring, PACKET0(mmUVD_LMI_RBC_IB_64BIT_BAR_HIGH, 0));\r\namdgpu_ring_write(ring, upper_32_bits(ib->gpu_addr));\r\namdgpu_ring_write(ring, PACKET0(mmUVD_RBC_IB_SIZE, 0));\r\namdgpu_ring_write(ring, ib->length_dw);\r\n}\r\nstatic bool uvd_v5_0_is_idle(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nreturn !(RREG32(mmSRBM_STATUS) & SRBM_STATUS__UVD_BUSY_MASK);\r\n}\r\nstatic int uvd_v5_0_wait_for_idle(void *handle)\r\n{\r\nunsigned i;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nfor (i = 0; i < adev->usec_timeout; i++) {\r\nif (!(RREG32(mmSRBM_STATUS) & SRBM_STATUS__UVD_BUSY_MASK))\r\nreturn 0;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int uvd_v5_0_soft_reset(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nuvd_v5_0_stop(adev);\r\nWREG32_P(mmSRBM_SOFT_RESET, SRBM_SOFT_RESET__SOFT_RESET_UVD_MASK,\r\n~SRBM_SOFT_RESET__SOFT_RESET_UVD_MASK);\r\nmdelay(5);\r\nreturn uvd_v5_0_start(adev);\r\n}\r\nstatic int uvd_v5_0_set_interrupt_state(struct amdgpu_device *adev,\r\nstruct amdgpu_irq_src *source,\r\nunsigned type,\r\nenum amdgpu_interrupt_state state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int uvd_v5_0_process_interrupt(struct amdgpu_device *adev,\r\nstruct amdgpu_irq_src *source,\r\nstruct amdgpu_iv_entry *entry)\r\n{\r\nDRM_DEBUG("IH: UVD TRAP\n");\r\namdgpu_fence_process(&adev->uvd.ring);\r\nreturn 0;\r\n}\r\nstatic void uvd_v5_0_enable_clock_gating(struct amdgpu_device *adev, bool enable)\r\n{\r\nuint32_t data1, data3, suvd_flags;\r\ndata1 = RREG32(mmUVD_SUVD_CGC_GATE);\r\ndata3 = RREG32(mmUVD_CGC_GATE);\r\nsuvd_flags = UVD_SUVD_CGC_GATE__SRE_MASK |\r\nUVD_SUVD_CGC_GATE__SIT_MASK |\r\nUVD_SUVD_CGC_GATE__SMP_MASK |\r\nUVD_SUVD_CGC_GATE__SCM_MASK |\r\nUVD_SUVD_CGC_GATE__SDB_MASK;\r\nif (enable) {\r\ndata3 |= (UVD_CGC_GATE__SYS_MASK |\r\nUVD_CGC_GATE__UDEC_MASK |\r\nUVD_CGC_GATE__MPEG2_MASK |\r\nUVD_CGC_GATE__RBC_MASK |\r\nUVD_CGC_GATE__LMI_MC_MASK |\r\nUVD_CGC_GATE__IDCT_MASK |\r\nUVD_CGC_GATE__MPRD_MASK |\r\nUVD_CGC_GATE__MPC_MASK |\r\nUVD_CGC_GATE__LBSI_MASK |\r\nUVD_CGC_GATE__LRBBM_MASK |\r\nUVD_CGC_GATE__UDEC_RE_MASK |\r\nUVD_CGC_GATE__UDEC_CM_MASK |\r\nUVD_CGC_GATE__UDEC_IT_MASK |\r\nUVD_CGC_GATE__UDEC_DB_MASK |\r\nUVD_CGC_GATE__UDEC_MP_MASK |\r\nUVD_CGC_GATE__WCB_MASK |\r\nUVD_CGC_GATE__JPEG_MASK |\r\nUVD_CGC_GATE__SCPU_MASK);\r\nif (adev->pg_flags & AMD_PG_SUPPORT_UVD)\r\ndata3 |= UVD_CGC_GATE__VCPU_MASK;\r\ndata3 &= ~UVD_CGC_GATE__REGS_MASK;\r\ndata1 |= suvd_flags;\r\n} else {\r\ndata3 = 0;\r\ndata1 = 0;\r\n}\r\nWREG32(mmUVD_SUVD_CGC_GATE, data1);\r\nWREG32(mmUVD_CGC_GATE, data3);\r\n}\r\nstatic void uvd_v5_0_set_sw_clock_gating(struct amdgpu_device *adev)\r\n{\r\nuint32_t data, data2;\r\ndata = RREG32(mmUVD_CGC_CTRL);\r\ndata2 = RREG32(mmUVD_SUVD_CGC_CTRL);\r\ndata &= ~(UVD_CGC_CTRL__CLK_OFF_DELAY_MASK |\r\nUVD_CGC_CTRL__CLK_GATE_DLY_TIMER_MASK);\r\ndata |= UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK |\r\n(1 << REG_FIELD_SHIFT(UVD_CGC_CTRL, CLK_GATE_DLY_TIMER)) |\r\n(4 << REG_FIELD_SHIFT(UVD_CGC_CTRL, CLK_OFF_DELAY));\r\ndata &= ~(UVD_CGC_CTRL__UDEC_RE_MODE_MASK |\r\nUVD_CGC_CTRL__UDEC_CM_MODE_MASK |\r\nUVD_CGC_CTRL__UDEC_IT_MODE_MASK |\r\nUVD_CGC_CTRL__UDEC_DB_MODE_MASK |\r\nUVD_CGC_CTRL__UDEC_MP_MODE_MASK |\r\nUVD_CGC_CTRL__SYS_MODE_MASK |\r\nUVD_CGC_CTRL__UDEC_MODE_MASK |\r\nUVD_CGC_CTRL__MPEG2_MODE_MASK |\r\nUVD_CGC_CTRL__REGS_MODE_MASK |\r\nUVD_CGC_CTRL__RBC_MODE_MASK |\r\nUVD_CGC_CTRL__LMI_MC_MODE_MASK |\r\nUVD_CGC_CTRL__LMI_UMC_MODE_MASK |\r\nUVD_CGC_CTRL__IDCT_MODE_MASK |\r\nUVD_CGC_CTRL__MPRD_MODE_MASK |\r\nUVD_CGC_CTRL__MPC_MODE_MASK |\r\nUVD_CGC_CTRL__LBSI_MODE_MASK |\r\nUVD_CGC_CTRL__LRBBM_MODE_MASK |\r\nUVD_CGC_CTRL__WCB_MODE_MASK |\r\nUVD_CGC_CTRL__VCPU_MODE_MASK |\r\nUVD_CGC_CTRL__JPEG_MODE_MASK |\r\nUVD_CGC_CTRL__SCPU_MODE_MASK);\r\ndata2 &= ~(UVD_SUVD_CGC_CTRL__SRE_MODE_MASK |\r\nUVD_SUVD_CGC_CTRL__SIT_MODE_MASK |\r\nUVD_SUVD_CGC_CTRL__SMP_MODE_MASK |\r\nUVD_SUVD_CGC_CTRL__SCM_MODE_MASK |\r\nUVD_SUVD_CGC_CTRL__SDB_MODE_MASK);\r\nWREG32(mmUVD_CGC_CTRL, data);\r\nWREG32(mmUVD_SUVD_CGC_CTRL, data2);\r\n}\r\nstatic void uvd_v5_0_enable_mgcg(struct amdgpu_device *adev,\r\nbool enable)\r\n{\r\nu32 orig, data;\r\nif (enable && (adev->cg_flags & AMD_CG_SUPPORT_UVD_MGCG)) {\r\ndata = RREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL);\r\ndata |= 0xfff;\r\nWREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL, data);\r\norig = data = RREG32(mmUVD_CGC_CTRL);\r\ndata |= UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK;\r\nif (orig != data)\r\nWREG32(mmUVD_CGC_CTRL, data);\r\n} else {\r\ndata = RREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL);\r\ndata &= ~0xfff;\r\nWREG32_UVD_CTX(ixUVD_CGC_MEM_CTRL, data);\r\norig = data = RREG32(mmUVD_CGC_CTRL);\r\ndata &= ~UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK;\r\nif (orig != data)\r\nWREG32(mmUVD_CGC_CTRL, data);\r\n}\r\n}\r\nstatic int uvd_v5_0_set_clockgating_state(void *handle,\r\nenum amd_clockgating_state state)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nbool enable = (state == AMD_CG_STATE_GATE) ? true : false;\r\nif (enable) {\r\nif (uvd_v5_0_wait_for_idle(handle))\r\nreturn -EBUSY;\r\nuvd_v5_0_enable_clock_gating(adev, true);\r\n} else {\r\nuvd_v5_0_enable_clock_gating(adev, false);\r\n}\r\nuvd_v5_0_set_sw_clock_gating(adev);\r\nreturn 0;\r\n}\r\nstatic int uvd_v5_0_set_powergating_state(void *handle,\r\nenum amd_powergating_state state)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nint ret = 0;\r\nif (state == AMD_PG_STATE_GATE) {\r\nuvd_v5_0_stop(adev);\r\n} else {\r\nret = uvd_v5_0_start(adev);\r\nif (ret)\r\ngoto out;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void uvd_v5_0_get_clockgating_state(void *handle, u32 *flags)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nint data;\r\nmutex_lock(&adev->pm.mutex);\r\nif (RREG32_SMC(ixCURRENT_PG_STATUS) &\r\nCURRENT_PG_STATUS__UVD_PG_STATUS_MASK) {\r\nDRM_INFO("Cannot get clockgating state when UVD is powergated.\n");\r\ngoto out;\r\n}\r\ndata = RREG32(mmUVD_CGC_CTRL);\r\nif (data & UVD_CGC_CTRL__DYN_CLOCK_MODE_MASK)\r\n*flags |= AMD_CG_SUPPORT_UVD_MGCG;\r\nout:\r\nmutex_unlock(&adev->pm.mutex);\r\n}\r\nstatic void uvd_v5_0_set_ring_funcs(struct amdgpu_device *adev)\r\n{\r\nadev->uvd.ring.funcs = &uvd_v5_0_ring_funcs;\r\n}\r\nstatic void uvd_v5_0_set_irq_funcs(struct amdgpu_device *adev)\r\n{\r\nadev->uvd.irq.num_types = 1;\r\nadev->uvd.irq.funcs = &uvd_v5_0_irq_funcs;\r\n}
