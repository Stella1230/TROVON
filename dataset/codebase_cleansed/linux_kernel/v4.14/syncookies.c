static u32 cookie_hash(const struct in6_addr *saddr,\r\nconst struct in6_addr *daddr,\r\n__be16 sport, __be16 dport, u32 count, int c)\r\n{\r\nconst struct {\r\nstruct in6_addr saddr;\r\nstruct in6_addr daddr;\r\nu32 count;\r\n__be16 sport;\r\n__be16 dport;\r\n} __aligned(SIPHASH_ALIGNMENT) combined = {\r\n.saddr = *saddr,\r\n.daddr = *daddr,\r\n.count = count,\r\n.sport = sport,\r\n.dport = dport\r\n};\r\nnet_get_random_once(syncookie6_secret, sizeof(syncookie6_secret));\r\nreturn siphash(&combined, offsetofend(typeof(combined), dport),\r\n&syncookie6_secret[c]);\r\n}\r\nstatic __u32 secure_tcp_syn_cookie(const struct in6_addr *saddr,\r\nconst struct in6_addr *daddr,\r\n__be16 sport, __be16 dport, __u32 sseq,\r\n__u32 data)\r\n{\r\nu32 count = tcp_cookie_time();\r\nreturn (cookie_hash(saddr, daddr, sport, dport, 0, 0) +\r\nsseq + (count << COOKIEBITS) +\r\n((cookie_hash(saddr, daddr, sport, dport, count, 1) + data)\r\n& COOKIEMASK));\r\n}\r\nstatic __u32 check_tcp_syn_cookie(__u32 cookie, const struct in6_addr *saddr,\r\nconst struct in6_addr *daddr, __be16 sport,\r\n__be16 dport, __u32 sseq)\r\n{\r\n__u32 diff, count = tcp_cookie_time();\r\ncookie -= cookie_hash(saddr, daddr, sport, dport, 0, 0) + sseq;\r\ndiff = (count - (cookie >> COOKIEBITS)) & ((__u32) -1 >> COOKIEBITS);\r\nif (diff >= MAX_SYNCOOKIE_AGE)\r\nreturn (__u32)-1;\r\nreturn (cookie -\r\ncookie_hash(saddr, daddr, sport, dport, count - diff, 1))\r\n& COOKIEMASK;\r\n}\r\nu32 __cookie_v6_init_sequence(const struct ipv6hdr *iph,\r\nconst struct tcphdr *th, __u16 *mssp)\r\n{\r\nint mssind;\r\nconst __u16 mss = *mssp;\r\nfor (mssind = ARRAY_SIZE(msstab) - 1; mssind ; mssind--)\r\nif (mss >= msstab[mssind])\r\nbreak;\r\n*mssp = msstab[mssind];\r\nreturn secure_tcp_syn_cookie(&iph->saddr, &iph->daddr, th->source,\r\nth->dest, ntohl(th->seq), mssind);\r\n}\r\n__u32 cookie_v6_init_sequence(const struct sk_buff *skb, __u16 *mssp)\r\n{\r\nconst struct ipv6hdr *iph = ipv6_hdr(skb);\r\nconst struct tcphdr *th = tcp_hdr(skb);\r\nreturn __cookie_v6_init_sequence(iph, th, mssp);\r\n}\r\nint __cookie_v6_check(const struct ipv6hdr *iph, const struct tcphdr *th,\r\n__u32 cookie)\r\n{\r\n__u32 seq = ntohl(th->seq) - 1;\r\n__u32 mssind = check_tcp_syn_cookie(cookie, &iph->saddr, &iph->daddr,\r\nth->source, th->dest, seq);\r\nreturn mssind < ARRAY_SIZE(msstab) ? msstab[mssind] : 0;\r\n}\r\nstruct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct tcp_options_received tcp_opt;\r\nstruct inet_request_sock *ireq;\r\nstruct tcp_request_sock *treq;\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nconst struct tcphdr *th = tcp_hdr(skb);\r\n__u32 cookie = ntohl(th->ack_seq) - 1;\r\nstruct sock *ret = sk;\r\nstruct request_sock *req;\r\nint mss;\r\nstruct dst_entry *dst;\r\n__u8 rcv_wscale;\r\nu32 tsoff = 0;\r\nif (!sock_net(sk)->ipv4.sysctl_tcp_syncookies || !th->ack || th->rst)\r\ngoto out;\r\nif (tcp_synq_no_recent_overflow(sk))\r\ngoto out;\r\nmss = __cookie_v6_check(ipv6_hdr(skb), th, cookie);\r\nif (mss == 0) {\r\n__NET_INC_STATS(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\r\ngoto out;\r\n}\r\n__NET_INC_STATS(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\r\nmemset(&tcp_opt, 0, sizeof(tcp_opt));\r\ntcp_parse_options(sock_net(sk), skb, &tcp_opt, 0, NULL);\r\nif (tcp_opt.saw_tstamp && tcp_opt.rcv_tsecr) {\r\ntsoff = secure_tcpv6_ts_off(sock_net(sk),\r\nipv6_hdr(skb)->daddr.s6_addr32,\r\nipv6_hdr(skb)->saddr.s6_addr32);\r\ntcp_opt.rcv_tsecr -= tsoff;\r\n}\r\nif (!cookie_timestamp_decode(sock_net(sk), &tcp_opt))\r\ngoto out;\r\nret = NULL;\r\nreq = inet_reqsk_alloc(&tcp6_request_sock_ops, sk, false);\r\nif (!req)\r\ngoto out;\r\nireq = inet_rsk(req);\r\ntreq = tcp_rsk(req);\r\ntreq->tfo_listener = false;\r\nif (security_inet_conn_request(sk, skb, req))\r\ngoto out_free;\r\nreq->mss = mss;\r\nireq->ir_rmt_port = th->source;\r\nireq->ir_num = ntohs(th->dest);\r\nireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\r\nireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\r\nif (ipv6_opt_accepted(sk, skb, &TCP_SKB_CB(skb)->header.h6) ||\r\nnp->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||\r\nnp->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {\r\nrefcount_inc(&skb->users);\r\nireq->pktopts = skb;\r\n}\r\nireq->ir_iif = inet_request_bound_dev_if(sk, skb);\r\nif (!sk->sk_bound_dev_if &&\r\nipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\r\nireq->ir_iif = tcp_v6_iif(skb);\r\nireq->ir_mark = inet_request_mark(sk, skb);\r\nreq->num_retrans = 0;\r\nireq->snd_wscale = tcp_opt.snd_wscale;\r\nireq->sack_ok = tcp_opt.sack_ok;\r\nireq->wscale_ok = tcp_opt.wscale_ok;\r\nireq->tstamp_ok = tcp_opt.saw_tstamp;\r\nreq->ts_recent = tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\r\ntreq->snt_synack = 0;\r\ntreq->rcv_isn = ntohl(th->seq) - 1;\r\ntreq->snt_isn = cookie;\r\ntreq->ts_off = 0;\r\ntreq->txhash = net_tx_rndhash();\r\n{\r\nstruct in6_addr *final_p, final;\r\nstruct flowi6 fl6;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nfl6.flowi6_proto = IPPROTO_TCP;\r\nfl6.daddr = ireq->ir_v6_rmt_addr;\r\nfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\r\nfl6.saddr = ireq->ir_v6_loc_addr;\r\nfl6.flowi6_oif = ireq->ir_iif;\r\nfl6.flowi6_mark = ireq->ir_mark;\r\nfl6.fl6_dport = ireq->ir_rmt_port;\r\nfl6.fl6_sport = inet_sk(sk)->inet_sport;\r\nfl6.flowi6_uid = sk->sk_uid;\r\nsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\r\ndst = ip6_dst_lookup_flow(sk, &fl6, final_p);\r\nif (IS_ERR(dst))\r\ngoto out_free;\r\n}\r\nreq->rsk_window_clamp = tp->window_clamp ? :dst_metric(dst, RTAX_WINDOW);\r\ntcp_select_initial_window(tcp_full_space(sk), req->mss,\r\n&req->rsk_rcv_wnd, &req->rsk_window_clamp,\r\nireq->wscale_ok, &rcv_wscale,\r\ndst_metric(dst, RTAX_INITRWND));\r\nireq->rcv_wscale = rcv_wscale;\r\nireq->ecn_ok = cookie_ecn_ok(&tcp_opt, sock_net(sk), dst);\r\nret = tcp_get_cookie_sock(sk, skb, req, dst, tsoff);\r\nout:\r\nreturn ret;\r\nout_free:\r\nreqsk_free(req);\r\nreturn NULL;\r\n}
