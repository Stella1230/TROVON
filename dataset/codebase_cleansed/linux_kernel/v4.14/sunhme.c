static __inline__ void tx_add_log(struct happy_meal *hp, unsigned int a, unsigned int s)\r\n{\r\nstruct hme_tx_logent *tlp;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ntlp = &tx_log[txlog_cur_entry];\r\ntlp->tstamp = (unsigned int)jiffies;\r\ntlp->tx_new = hp->tx_new;\r\ntlp->tx_old = hp->tx_old;\r\ntlp->action = a;\r\ntlp->status = s;\r\ntxlog_cur_entry = (txlog_cur_entry + 1) & (TX_LOG_LEN - 1);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic __inline__ void tx_dump_log(void)\r\n{\r\nint i, this;\r\nthis = txlog_cur_entry;\r\nfor (i = 0; i < TX_LOG_LEN; i++) {\r\nprintk("TXLOG[%d]: j[%08x] tx[N(%d)O(%d)] action[%08x] stat[%08x]\n", i,\r\ntx_log[this].tstamp,\r\ntx_log[this].tx_new, tx_log[this].tx_old,\r\ntx_log[this].action, tx_log[this].status);\r\nthis = (this + 1) & (TX_LOG_LEN - 1);\r\n}\r\n}\r\nstatic __inline__ void tx_dump_ring(struct happy_meal *hp)\r\n{\r\nstruct hmeal_init_block *hb = hp->happy_block;\r\nstruct happy_meal_txd *tp = &hb->happy_meal_txd[0];\r\nint i;\r\nfor (i = 0; i < TX_RING_SIZE; i+=4) {\r\nprintk("TXD[%d..%d]: [%08x:%08x] [%08x:%08x] [%08x:%08x] [%08x:%08x]\n",\r\ni, i + 4,\r\nle32_to_cpu(tp[i].tx_flags), le32_to_cpu(tp[i].tx_addr),\r\nle32_to_cpu(tp[i + 1].tx_flags), le32_to_cpu(tp[i + 1].tx_addr),\r\nle32_to_cpu(tp[i + 2].tx_flags), le32_to_cpu(tp[i + 2].tx_addr),\r\nle32_to_cpu(tp[i + 3].tx_flags), le32_to_cpu(tp[i + 3].tx_addr));\r\n}\r\n}\r\nstatic void sbus_hme_write32(void __iomem *reg, u32 val)\r\n{\r\nsbus_writel(val, reg);\r\n}\r\nstatic u32 sbus_hme_read32(void __iomem *reg)\r\n{\r\nreturn sbus_readl(reg);\r\n}\r\nstatic void sbus_hme_write_rxd(struct happy_meal_rxd *rxd, u32 flags, u32 addr)\r\n{\r\nrxd->rx_addr = (__force hme32)addr;\r\ndma_wmb();\r\nrxd->rx_flags = (__force hme32)flags;\r\n}\r\nstatic void sbus_hme_write_txd(struct happy_meal_txd *txd, u32 flags, u32 addr)\r\n{\r\ntxd->tx_addr = (__force hme32)addr;\r\ndma_wmb();\r\ntxd->tx_flags = (__force hme32)flags;\r\n}\r\nstatic u32 sbus_hme_read_desc32(hme32 *p)\r\n{\r\nreturn (__force u32)*p;\r\n}\r\nstatic void pci_hme_write32(void __iomem *reg, u32 val)\r\n{\r\nwritel(val, reg);\r\n}\r\nstatic u32 pci_hme_read32(void __iomem *reg)\r\n{\r\nreturn readl(reg);\r\n}\r\nstatic void pci_hme_write_rxd(struct happy_meal_rxd *rxd, u32 flags, u32 addr)\r\n{\r\nrxd->rx_addr = (__force hme32)cpu_to_le32(addr);\r\ndma_wmb();\r\nrxd->rx_flags = (__force hme32)cpu_to_le32(flags);\r\n}\r\nstatic void pci_hme_write_txd(struct happy_meal_txd *txd, u32 flags, u32 addr)\r\n{\r\ntxd->tx_addr = (__force hme32)cpu_to_le32(addr);\r\ndma_wmb();\r\ntxd->tx_flags = (__force hme32)cpu_to_le32(flags);\r\n}\r\nstatic u32 pci_hme_read_desc32(hme32 *p)\r\n{\r\nreturn le32_to_cpup((__le32 *)p);\r\n}\r\nstatic inline u32 hme_read_desc32(struct happy_meal *hp, hme32 *p)\r\n{\r\nreturn le32_to_cpup((__le32 *)p);\r\n}\r\nstatic void BB_PUT_BIT(struct happy_meal *hp, void __iomem *tregs, int bit)\r\n{\r\nhme_write32(hp, tregs + TCVR_BBDATA, bit);\r\nhme_write32(hp, tregs + TCVR_BBCLOCK, 0);\r\nhme_write32(hp, tregs + TCVR_BBCLOCK, 1);\r\n}\r\nstatic u32 BB_GET_BIT2(struct happy_meal *hp, void __iomem *tregs, int internal)\r\n{\r\nu32 retval;\r\nhme_write32(hp, tregs + TCVR_BBCLOCK, 0);\r\nudelay(1);\r\nretval = hme_read32(hp, tregs + TCVR_CFG);\r\nif (internal)\r\nretval &= TCV_CFG_MDIO0;\r\nelse\r\nretval &= TCV_CFG_MDIO1;\r\nhme_write32(hp, tregs + TCVR_BBCLOCK, 1);\r\nreturn retval;\r\n}\r\nstatic int happy_meal_bb_read(struct happy_meal *hp,\r\nvoid __iomem *tregs, int reg)\r\n{\r\nu32 tmp;\r\nint retval = 0;\r\nint i;\r\nASD(("happy_meal_bb_read: reg=%d ", reg));\r\nhme_write32(hp, tregs + TCVR_BBOENAB, 1);\r\nfor (i = 0; i < 32; i++)\r\nBB_PUT_BIT(hp, tregs, 1);\r\nBB_PUT_BIT(hp, tregs, 0);\r\nBB_PUT_BIT(hp, tregs, 1);\r\nBB_PUT_BIT(hp, tregs, 1);\r\nBB_PUT_BIT(hp, tregs, 0);\r\ntmp = hp->paddr & 0xff;\r\nfor (i = 4; i >= 0; i--)\r\nBB_PUT_BIT(hp, tregs, ((tmp >> i) & 1));\r\ntmp = (reg & 0xff);\r\nfor (i = 4; i >= 0; i--)\r\nBB_PUT_BIT(hp, tregs, ((tmp >> i) & 1));\r\nhme_write32(hp, tregs + TCVR_BBOENAB, 0);\r\n(void) BB_GET_BIT2(hp, tregs, (hp->tcvr_type == internal));\r\nfor (i = 15; i >= 0; i--)\r\nretval |= BB_GET_BIT2(hp, tregs, (hp->tcvr_type == internal));\r\n(void) BB_GET_BIT2(hp, tregs, (hp->tcvr_type == internal));\r\n(void) BB_GET_BIT2(hp, tregs, (hp->tcvr_type == internal));\r\n(void) BB_GET_BIT2(hp, tregs, (hp->tcvr_type == internal));\r\nASD(("value=%x\n", retval));\r\nreturn retval;\r\n}\r\nstatic void happy_meal_bb_write(struct happy_meal *hp,\r\nvoid __iomem *tregs, int reg,\r\nunsigned short value)\r\n{\r\nu32 tmp;\r\nint i;\r\nASD(("happy_meal_bb_write: reg=%d value=%x\n", reg, value));\r\nhme_write32(hp, tregs + TCVR_BBOENAB, 1);\r\nfor (i = 0; i < 32; i++)\r\nBB_PUT_BIT(hp, tregs, 1);\r\nBB_PUT_BIT(hp, tregs, 0);\r\nBB_PUT_BIT(hp, tregs, 1);\r\nBB_PUT_BIT(hp, tregs, 0);\r\nBB_PUT_BIT(hp, tregs, 1);\r\ntmp = (hp->paddr & 0xff);\r\nfor (i = 4; i >= 0; i--)\r\nBB_PUT_BIT(hp, tregs, ((tmp >> i) & 1));\r\ntmp = (reg & 0xff);\r\nfor (i = 4; i >= 0; i--)\r\nBB_PUT_BIT(hp, tregs, ((tmp >> i) & 1));\r\nBB_PUT_BIT(hp, tregs, 1);\r\nBB_PUT_BIT(hp, tregs, 0);\r\nfor (i = 15; i >= 0; i--)\r\nBB_PUT_BIT(hp, tregs, ((value >> i) & 1));\r\nhme_write32(hp, tregs + TCVR_BBOENAB, 0);\r\n}\r\nstatic int happy_meal_tcvr_read(struct happy_meal *hp,\r\nvoid __iomem *tregs, int reg)\r\n{\r\nint tries = TCVR_READ_TRIES;\r\nint retval;\r\nASD(("happy_meal_tcvr_read: reg=0x%02x ", reg));\r\nif (hp->tcvr_type == none) {\r\nASD(("no transceiver, value=TCVR_FAILURE\n"));\r\nreturn TCVR_FAILURE;\r\n}\r\nif (!(hp->happy_flags & HFLAG_FENABLE)) {\r\nASD(("doing bit bang\n"));\r\nreturn happy_meal_bb_read(hp, tregs, reg);\r\n}\r\nhme_write32(hp, tregs + TCVR_FRAME,\r\n(FRAME_READ | (hp->paddr << 23) | ((reg & 0xff) << 18)));\r\nwhile (!(hme_read32(hp, tregs + TCVR_FRAME) & 0x10000) && --tries)\r\nudelay(20);\r\nif (!tries) {\r\nprintk(KERN_ERR "happy meal: Aieee, transceiver MIF read bolixed\n");\r\nreturn TCVR_FAILURE;\r\n}\r\nretval = hme_read32(hp, tregs + TCVR_FRAME) & 0xffff;\r\nASD(("value=%04x\n", retval));\r\nreturn retval;\r\n}\r\nstatic void happy_meal_tcvr_write(struct happy_meal *hp,\r\nvoid __iomem *tregs, int reg,\r\nunsigned short value)\r\n{\r\nint tries = TCVR_WRITE_TRIES;\r\nASD(("happy_meal_tcvr_write: reg=0x%02x value=%04x\n", reg, value));\r\nif (!(hp->happy_flags & HFLAG_FENABLE)) {\r\nhappy_meal_bb_write(hp, tregs, reg, value);\r\nreturn;\r\n}\r\nhme_write32(hp, tregs + TCVR_FRAME,\r\n(FRAME_WRITE | (hp->paddr << 23) |\r\n((reg & 0xff) << 18) | (value & 0xffff)));\r\nwhile (!(hme_read32(hp, tregs + TCVR_FRAME) & 0x10000) && --tries)\r\nudelay(20);\r\nif (!tries)\r\nprintk(KERN_ERR "happy meal: Aieee, transceiver MIF write bolixed\n");\r\n}\r\nstatic int try_next_permutation(struct happy_meal *hp, void __iomem *tregs)\r\n{\r\nhp->sw_bmcr = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\r\nif (hp->sw_bmcr & BMCR_FULLDPLX) {\r\nhp->sw_bmcr &= ~(BMCR_FULLDPLX);\r\nhappy_meal_tcvr_write(hp, tregs, MII_BMCR, hp->sw_bmcr);\r\nreturn 0;\r\n}\r\nif (hp->sw_bmcr & BMCR_SPEED100) {\r\nhp->sw_bmcr &= ~(BMCR_SPEED100);\r\nhappy_meal_tcvr_write(hp, tregs, MII_BMCR, hp->sw_bmcr);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic void display_link_mode(struct happy_meal *hp, void __iomem *tregs)\r\n{\r\nprintk(KERN_INFO "%s: Link is up using ", hp->dev->name);\r\nif (hp->tcvr_type == external)\r\nprintk("external ");\r\nelse\r\nprintk("internal ");\r\nprintk("transceiver at ");\r\nhp->sw_lpa = happy_meal_tcvr_read(hp, tregs, MII_LPA);\r\nif (hp->sw_lpa & (LPA_100HALF | LPA_100FULL)) {\r\nif (hp->sw_lpa & LPA_100FULL)\r\nprintk("100Mb/s, Full Duplex.\n");\r\nelse\r\nprintk("100Mb/s, Half Duplex.\n");\r\n} else {\r\nif (hp->sw_lpa & LPA_10FULL)\r\nprintk("10Mb/s, Full Duplex.\n");\r\nelse\r\nprintk("10Mb/s, Half Duplex.\n");\r\n}\r\n}\r\nstatic void display_forced_link_mode(struct happy_meal *hp, void __iomem *tregs)\r\n{\r\nprintk(KERN_INFO "%s: Link has been forced up using ", hp->dev->name);\r\nif (hp->tcvr_type == external)\r\nprintk("external ");\r\nelse\r\nprintk("internal ");\r\nprintk("transceiver at ");\r\nhp->sw_bmcr = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\r\nif (hp->sw_bmcr & BMCR_SPEED100)\r\nprintk("100Mb/s, ");\r\nelse\r\nprintk("10Mb/s, ");\r\nif (hp->sw_bmcr & BMCR_FULLDPLX)\r\nprintk("Full Duplex.\n");\r\nelse\r\nprintk("Half Duplex.\n");\r\n}\r\nstatic int set_happy_link_modes(struct happy_meal *hp, void __iomem *tregs)\r\n{\r\nint full;\r\nif (hp->timer_state == arbwait) {\r\nhp->sw_lpa = happy_meal_tcvr_read(hp, tregs, MII_LPA);\r\nif (!(hp->sw_lpa & (LPA_10HALF | LPA_10FULL | LPA_100HALF | LPA_100FULL)))\r\ngoto no_response;\r\nif (hp->sw_lpa & LPA_100FULL)\r\nfull = 1;\r\nelse if (hp->sw_lpa & LPA_100HALF)\r\nfull = 0;\r\nelse if (hp->sw_lpa & LPA_10FULL)\r\nfull = 1;\r\nelse\r\nfull = 0;\r\n} else {\r\nhp->sw_bmcr = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\r\nif (hp->sw_bmcr & BMCR_FULLDPLX)\r\nfull = 1;\r\nelse\r\nfull = 0;\r\n}\r\nhme_write32(hp, hp->bigmacregs + BMAC_TXCFG,\r\nhme_read32(hp, hp->bigmacregs + BMAC_TXCFG) &\r\n~(BIGMAC_TXCFG_ENABLE));\r\nwhile (hme_read32(hp, hp->bigmacregs + BMAC_TXCFG) & BIGMAC_TXCFG_ENABLE)\r\nbarrier();\r\nif (full) {\r\nhp->happy_flags |= HFLAG_FULL;\r\nhme_write32(hp, hp->bigmacregs + BMAC_TXCFG,\r\nhme_read32(hp, hp->bigmacregs + BMAC_TXCFG) |\r\nBIGMAC_TXCFG_FULLDPLX);\r\n} else {\r\nhp->happy_flags &= ~(HFLAG_FULL);\r\nhme_write32(hp, hp->bigmacregs + BMAC_TXCFG,\r\nhme_read32(hp, hp->bigmacregs + BMAC_TXCFG) &\r\n~(BIGMAC_TXCFG_FULLDPLX));\r\n}\r\nhme_write32(hp, hp->bigmacregs + BMAC_TXCFG,\r\nhme_read32(hp, hp->bigmacregs + BMAC_TXCFG) |\r\nBIGMAC_TXCFG_ENABLE);\r\nreturn 0;\r\nno_response:\r\nreturn 1;\r\n}\r\nstatic int is_lucent_phy(struct happy_meal *hp)\r\n{\r\nvoid __iomem *tregs = hp->tcvregs;\r\nunsigned short mr2, mr3;\r\nint ret = 0;\r\nmr2 = happy_meal_tcvr_read(hp, tregs, 2);\r\nmr3 = happy_meal_tcvr_read(hp, tregs, 3);\r\nif ((mr2 & 0xffff) == 0x0180 &&\r\n((mr3 & 0xffff) >> 10) == 0x1d)\r\nret = 1;\r\nreturn ret;\r\n}\r\nstatic void happy_meal_timer(unsigned long data)\r\n{\r\nstruct happy_meal *hp = (struct happy_meal *) data;\r\nvoid __iomem *tregs = hp->tcvregs;\r\nint restart_timer = 0;\r\nspin_lock_irq(&hp->happy_lock);\r\nhp->timer_ticks++;\r\nswitch(hp->timer_state) {\r\ncase arbwait:\r\nif (hp->timer_ticks >= 10) {\r\ndo_force_mode:\r\nhp->sw_bmcr = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\r\nprintk(KERN_NOTICE "%s: Auto-Negotiation unsuccessful, trying force link mode\n",\r\nhp->dev->name);\r\nhp->sw_bmcr = BMCR_SPEED100;\r\nhappy_meal_tcvr_write(hp, tregs, MII_BMCR, hp->sw_bmcr);\r\nif (!is_lucent_phy(hp)) {\r\nhp->sw_csconfig = happy_meal_tcvr_read(hp, tregs, DP83840_CSCONFIG);\r\nhp->sw_csconfig &= ~(CSCONFIG_TCVDISAB);\r\nhappy_meal_tcvr_write(hp, tregs, DP83840_CSCONFIG, hp->sw_csconfig);\r\n}\r\nhp->timer_state = ltrywait;\r\nhp->timer_ticks = 0;\r\nrestart_timer = 1;\r\n} else {\r\nhp->sw_bmsr = happy_meal_tcvr_read(hp, tregs, MII_BMSR);\r\nif (hp->sw_bmsr & BMSR_ANEGCOMPLETE) {\r\nint ret;\r\nret = set_happy_link_modes(hp, tregs);\r\nif (ret) {\r\ngoto do_force_mode;\r\n}\r\nhp->timer_state = lupwait;\r\nrestart_timer = 1;\r\n} else {\r\nrestart_timer = 1;\r\n}\r\n}\r\nbreak;\r\ncase lupwait:\r\nhp->sw_bmsr = happy_meal_tcvr_read(hp, tregs, MII_BMSR);\r\nif (hp->sw_bmsr & BMSR_LSTATUS) {\r\ndisplay_link_mode(hp, tregs);\r\nhp->timer_state = asleep;\r\nrestart_timer = 0;\r\n} else {\r\nif (hp->timer_ticks >= 10) {\r\nprintk(KERN_NOTICE "%s: Auto negotiation successful, link still "\r\n"not completely up.\n", hp->dev->name);\r\nhp->timer_ticks = 0;\r\nrestart_timer = 1;\r\n} else {\r\nrestart_timer = 1;\r\n}\r\n}\r\nbreak;\r\ncase ltrywait:\r\nhp->sw_bmsr = happy_meal_tcvr_read(hp, tregs, MII_BMSR);\r\nhp->sw_csconfig = happy_meal_tcvr_read(hp, tregs, DP83840_CSCONFIG);\r\nif (hp->timer_ticks == 1) {\r\nif (!is_lucent_phy(hp)) {\r\nhp->sw_csconfig |= CSCONFIG_TCVDISAB;\r\nhappy_meal_tcvr_write(hp, tregs,\r\nDP83840_CSCONFIG, hp->sw_csconfig);\r\n}\r\nrestart_timer = 1;\r\nbreak;\r\n}\r\nif (hp->timer_ticks == 2) {\r\nif (!is_lucent_phy(hp)) {\r\nhp->sw_csconfig &= ~(CSCONFIG_TCVDISAB);\r\nhappy_meal_tcvr_write(hp, tregs,\r\nDP83840_CSCONFIG, hp->sw_csconfig);\r\n}\r\nrestart_timer = 1;\r\nbreak;\r\n}\r\nif (hp->sw_bmsr & BMSR_LSTATUS) {\r\ndisplay_forced_link_mode(hp, tregs);\r\nset_happy_link_modes(hp, tregs);\r\nhp->timer_state = asleep;\r\nrestart_timer = 0;\r\n} else {\r\nif (hp->timer_ticks >= 4) {\r\nint ret;\r\nret = try_next_permutation(hp, tregs);\r\nif (ret == -1) {\r\nprintk(KERN_NOTICE "%s: Link down, cable problem?\n",\r\nhp->dev->name);\r\nret = happy_meal_init(hp);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: Error, cannot re-init the "\r\n"Happy Meal.\n", hp->dev->name);\r\n}\r\ngoto out;\r\n}\r\nif (!is_lucent_phy(hp)) {\r\nhp->sw_csconfig = happy_meal_tcvr_read(hp, tregs,\r\nDP83840_CSCONFIG);\r\nhp->sw_csconfig |= CSCONFIG_TCVDISAB;\r\nhappy_meal_tcvr_write(hp, tregs,\r\nDP83840_CSCONFIG, hp->sw_csconfig);\r\n}\r\nhp->timer_ticks = 0;\r\nrestart_timer = 1;\r\n} else {\r\nrestart_timer = 1;\r\n}\r\n}\r\nbreak;\r\ncase asleep:\r\ndefault:\r\nprintk(KERN_ERR "%s: Aieee, link timer is asleep but we got one anyways!\n",\r\nhp->dev->name);\r\nrestart_timer = 0;\r\nhp->timer_ticks = 0;\r\nhp->timer_state = asleep;\r\nbreak;\r\n}\r\nif (restart_timer) {\r\nhp->happy_timer.expires = jiffies + ((12 * HZ)/10);\r\nadd_timer(&hp->happy_timer);\r\n}\r\nout:\r\nspin_unlock_irq(&hp->happy_lock);\r\n}\r\nstatic void happy_meal_tx_reset(struct happy_meal *hp, void __iomem *bregs)\r\n{\r\nint tries = TX_RESET_TRIES;\r\nHMD(("happy_meal_tx_reset: reset, "));\r\nhme_write32(hp, bregs + BMAC_TXSWRESET, 0);\r\nwhile ((hme_read32(hp, bregs + BMAC_TXSWRESET) & 1) && --tries)\r\nudelay(20);\r\nif (!tries)\r\nprintk(KERN_ERR "happy meal: Transceiver BigMac ATTACK!");\r\nHMD(("done\n"));\r\n}\r\nstatic void happy_meal_rx_reset(struct happy_meal *hp, void __iomem *bregs)\r\n{\r\nint tries = RX_RESET_TRIES;\r\nHMD(("happy_meal_rx_reset: reset, "));\r\nhme_write32(hp, bregs + BMAC_RXSWRESET, 0);\r\nwhile ((hme_read32(hp, bregs + BMAC_RXSWRESET) & 1) && --tries)\r\nudelay(20);\r\nif (!tries)\r\nprintk(KERN_ERR "happy meal: Receiver BigMac ATTACK!");\r\nHMD(("done\n"));\r\n}\r\nstatic void happy_meal_stop(struct happy_meal *hp, void __iomem *gregs)\r\n{\r\nint tries = STOP_TRIES;\r\nHMD(("happy_meal_stop: reset, "));\r\nhme_write32(hp, gregs + GREG_SWRESET, GREG_RESET_ALL);\r\nwhile (hme_read32(hp, gregs + GREG_SWRESET) && --tries)\r\nudelay(20);\r\nif (!tries)\r\nprintk(KERN_ERR "happy meal: Fry guys.");\r\nHMD(("done\n"));\r\n}\r\nstatic void happy_meal_get_counters(struct happy_meal *hp, void __iomem *bregs)\r\n{\r\nstruct net_device_stats *stats = &hp->dev->stats;\r\nstats->rx_crc_errors += hme_read32(hp, bregs + BMAC_RCRCECTR);\r\nhme_write32(hp, bregs + BMAC_RCRCECTR, 0);\r\nstats->rx_frame_errors += hme_read32(hp, bregs + BMAC_UNALECTR);\r\nhme_write32(hp, bregs + BMAC_UNALECTR, 0);\r\nstats->rx_length_errors += hme_read32(hp, bregs + BMAC_GLECTR);\r\nhme_write32(hp, bregs + BMAC_GLECTR, 0);\r\nstats->tx_aborted_errors += hme_read32(hp, bregs + BMAC_EXCTR);\r\nstats->collisions +=\r\n(hme_read32(hp, bregs + BMAC_EXCTR) +\r\nhme_read32(hp, bregs + BMAC_LTCTR));\r\nhme_write32(hp, bregs + BMAC_EXCTR, 0);\r\nhme_write32(hp, bregs + BMAC_LTCTR, 0);\r\n}\r\nstatic void happy_meal_poll_stop(struct happy_meal *hp, void __iomem *tregs)\r\n{\r\nASD(("happy_meal_poll_stop: "));\r\nif ((hp->happy_flags & (HFLAG_POLLENABLE | HFLAG_POLL)) !=\r\n(HFLAG_POLLENABLE | HFLAG_POLL)) {\r\nHMD(("not polling, return\n"));\r\nreturn;\r\n}\r\nASD(("were polling, mif ints off, "));\r\nhme_write32(hp, tregs + TCVR_IMASK, 0xffff);\r\nASD(("polling off, "));\r\nhme_write32(hp, tregs + TCVR_CFG,\r\nhme_read32(hp, tregs + TCVR_CFG) & ~(TCV_CFG_PENABLE));\r\nhp->happy_flags &= ~(HFLAG_POLL);\r\nudelay(200);\r\nASD(("done\n"));\r\n}\r\nstatic int happy_meal_tcvr_reset(struct happy_meal *hp, void __iomem *tregs)\r\n{\r\nu32 tconfig;\r\nint result, tries = TCVR_RESET_TRIES;\r\ntconfig = hme_read32(hp, tregs + TCVR_CFG);\r\nASD(("happy_meal_tcvr_reset: tcfg<%08lx> ", tconfig));\r\nif (hp->tcvr_type == external) {\r\nASD(("external<"));\r\nhme_write32(hp, tregs + TCVR_CFG, tconfig & ~(TCV_CFG_PSELECT));\r\nhp->tcvr_type = internal;\r\nhp->paddr = TCV_PADDR_ITX;\r\nASD(("ISOLATE,"));\r\nhappy_meal_tcvr_write(hp, tregs, MII_BMCR,\r\n(BMCR_LOOPBACK|BMCR_PDOWN|BMCR_ISOLATE));\r\nresult = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\r\nif (result == TCVR_FAILURE) {\r\nASD(("phyread_fail>\n"));\r\nreturn -1;\r\n}\r\nASD(("phyread_ok,PSELECT>"));\r\nhme_write32(hp, tregs + TCVR_CFG, tconfig | TCV_CFG_PSELECT);\r\nhp->tcvr_type = external;\r\nhp->paddr = TCV_PADDR_ETX;\r\n} else {\r\nif (tconfig & TCV_CFG_MDIO1) {\r\nASD(("internal<PSELECT,"));\r\nhme_write32(hp, tregs + TCVR_CFG, (tconfig | TCV_CFG_PSELECT));\r\nASD(("ISOLATE,"));\r\nhappy_meal_tcvr_write(hp, tregs, MII_BMCR,\r\n(BMCR_LOOPBACK|BMCR_PDOWN|BMCR_ISOLATE));\r\nresult = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\r\nif (result == TCVR_FAILURE) {\r\nASD(("phyread_fail>\n"));\r\nreturn -1;\r\n}\r\nASD(("phyread_ok,~PSELECT>"));\r\nhme_write32(hp, tregs + TCVR_CFG, (tconfig & ~(TCV_CFG_PSELECT)));\r\nhp->tcvr_type = internal;\r\nhp->paddr = TCV_PADDR_ITX;\r\n}\r\n}\r\nASD(("BMCR_RESET "));\r\nhappy_meal_tcvr_write(hp, tregs, MII_BMCR, BMCR_RESET);\r\nwhile (--tries) {\r\nresult = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\r\nif (result == TCVR_FAILURE)\r\nreturn -1;\r\nhp->sw_bmcr = result;\r\nif (!(result & BMCR_RESET))\r\nbreak;\r\nudelay(20);\r\n}\r\nif (!tries) {\r\nASD(("BMCR RESET FAILED!\n"));\r\nreturn -1;\r\n}\r\nASD(("RESET_OK\n"));\r\nhp->sw_bmsr = happy_meal_tcvr_read(hp, tregs, MII_BMSR);\r\nhp->sw_physid1 = happy_meal_tcvr_read(hp, tregs, MII_PHYSID1);\r\nhp->sw_physid2 = happy_meal_tcvr_read(hp, tregs, MII_PHYSID2);\r\nhp->sw_advertise = happy_meal_tcvr_read(hp, tregs, MII_ADVERTISE);\r\nASD(("UNISOLATE"));\r\nhp->sw_bmcr &= ~(BMCR_ISOLATE);\r\nhappy_meal_tcvr_write(hp, tregs, MII_BMCR, hp->sw_bmcr);\r\ntries = TCVR_UNISOLATE_TRIES;\r\nwhile (--tries) {\r\nresult = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\r\nif (result == TCVR_FAILURE)\r\nreturn -1;\r\nif (!(result & BMCR_ISOLATE))\r\nbreak;\r\nudelay(20);\r\n}\r\nif (!tries) {\r\nASD((" FAILED!\n"));\r\nreturn -1;\r\n}\r\nASD((" SUCCESS and CSCONFIG_DFBYPASS\n"));\r\nif (!is_lucent_phy(hp)) {\r\nresult = happy_meal_tcvr_read(hp, tregs,\r\nDP83840_CSCONFIG);\r\nhappy_meal_tcvr_write(hp, tregs,\r\nDP83840_CSCONFIG, (result | CSCONFIG_DFBYPASS));\r\n}\r\nreturn 0;\r\n}\r\nstatic void happy_meal_transceiver_check(struct happy_meal *hp, void __iomem *tregs)\r\n{\r\nunsigned long tconfig = hme_read32(hp, tregs + TCVR_CFG);\r\nASD(("happy_meal_transceiver_check: tcfg=%08lx ", tconfig));\r\nif (hp->happy_flags & HFLAG_POLL) {\r\nASD(("<polling> "));\r\nif (hp->tcvr_type == internal) {\r\nif (tconfig & TCV_CFG_MDIO1) {\r\nASD(("<internal> <poll stop> "));\r\nhappy_meal_poll_stop(hp, tregs);\r\nhp->paddr = TCV_PADDR_ETX;\r\nhp->tcvr_type = external;\r\nASD(("<external>\n"));\r\ntconfig &= ~(TCV_CFG_PENABLE);\r\ntconfig |= TCV_CFG_PSELECT;\r\nhme_write32(hp, tregs + TCVR_CFG, tconfig);\r\n}\r\n} else {\r\nif (hp->tcvr_type == external) {\r\nASD(("<external> "));\r\nif (!(hme_read32(hp, tregs + TCVR_STATUS) >> 16)) {\r\nASD(("<poll stop> "));\r\nhappy_meal_poll_stop(hp, tregs);\r\nhp->paddr = TCV_PADDR_ITX;\r\nhp->tcvr_type = internal;\r\nASD(("<internal>\n"));\r\nhme_write32(hp, tregs + TCVR_CFG,\r\nhme_read32(hp, tregs + TCVR_CFG) &\r\n~(TCV_CFG_PSELECT));\r\n}\r\nASD(("\n"));\r\n} else {\r\nASD(("<none>\n"));\r\n}\r\n}\r\n} else {\r\nu32 reread = hme_read32(hp, tregs + TCVR_CFG);\r\nASD(("<not polling> "));\r\nif (reread & TCV_CFG_MDIO1) {\r\nhme_write32(hp, tregs + TCVR_CFG, tconfig | TCV_CFG_PSELECT);\r\nhp->paddr = TCV_PADDR_ETX;\r\nhp->tcvr_type = external;\r\nASD(("<external>\n"));\r\n} else {\r\nif (reread & TCV_CFG_MDIO0) {\r\nhme_write32(hp, tregs + TCVR_CFG,\r\ntconfig & ~(TCV_CFG_PSELECT));\r\nhp->paddr = TCV_PADDR_ITX;\r\nhp->tcvr_type = internal;\r\nASD(("<internal>\n"));\r\n} else {\r\nprintk(KERN_ERR "happy meal: Transceiver and a coke please.");\r\nhp->tcvr_type = none;\r\nASD(("<none>\n"));\r\n}\r\n}\r\n}\r\n}\r\nstatic void happy_meal_clean_rings(struct happy_meal *hp)\r\n{\r\nint i;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nif (hp->rx_skbs[i] != NULL) {\r\nstruct sk_buff *skb = hp->rx_skbs[i];\r\nstruct happy_meal_rxd *rxd;\r\nu32 dma_addr;\r\nrxd = &hp->happy_block->happy_meal_rxd[i];\r\ndma_addr = hme_read_desc32(hp, &rxd->rx_addr);\r\ndma_unmap_single(hp->dma_dev, dma_addr,\r\nRX_BUF_ALLOC_SIZE, DMA_FROM_DEVICE);\r\ndev_kfree_skb_any(skb);\r\nhp->rx_skbs[i] = NULL;\r\n}\r\n}\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nif (hp->tx_skbs[i] != NULL) {\r\nstruct sk_buff *skb = hp->tx_skbs[i];\r\nstruct happy_meal_txd *txd;\r\nu32 dma_addr;\r\nint frag;\r\nhp->tx_skbs[i] = NULL;\r\nfor (frag = 0; frag <= skb_shinfo(skb)->nr_frags; frag++) {\r\ntxd = &hp->happy_block->happy_meal_txd[i];\r\ndma_addr = hme_read_desc32(hp, &txd->tx_addr);\r\nif (!frag)\r\ndma_unmap_single(hp->dma_dev, dma_addr,\r\n(hme_read_desc32(hp, &txd->tx_flags)\r\n& TXFLAG_SIZE),\r\nDMA_TO_DEVICE);\r\nelse\r\ndma_unmap_page(hp->dma_dev, dma_addr,\r\n(hme_read_desc32(hp, &txd->tx_flags)\r\n& TXFLAG_SIZE),\r\nDMA_TO_DEVICE);\r\nif (frag != skb_shinfo(skb)->nr_frags)\r\ni++;\r\n}\r\ndev_kfree_skb_any(skb);\r\n}\r\n}\r\n}\r\nstatic void happy_meal_init_rings(struct happy_meal *hp)\r\n{\r\nstruct hmeal_init_block *hb = hp->happy_block;\r\nint i;\r\nHMD(("happy_meal_init_rings: counters to zero, "));\r\nhp->rx_new = hp->rx_old = hp->tx_new = hp->tx_old = 0;\r\nHMD(("clean, "));\r\nhappy_meal_clean_rings(hp);\r\nHMD(("init rxring, "));\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nstruct sk_buff *skb;\r\nu32 mapping;\r\nskb = happy_meal_alloc_skb(RX_BUF_ALLOC_SIZE, GFP_ATOMIC);\r\nif (!skb) {\r\nhme_write_rxd(hp, &hb->happy_meal_rxd[i], 0, 0);\r\ncontinue;\r\n}\r\nhp->rx_skbs[i] = skb;\r\nskb_put(skb, (ETH_FRAME_LEN + RX_OFFSET + 4));\r\nmapping = dma_map_single(hp->dma_dev, skb->data, RX_BUF_ALLOC_SIZE,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(hp->dma_dev, mapping)) {\r\ndev_kfree_skb_any(skb);\r\nhme_write_rxd(hp, &hb->happy_meal_rxd[i], 0, 0);\r\ncontinue;\r\n}\r\nhme_write_rxd(hp, &hb->happy_meal_rxd[i],\r\n(RXFLAG_OWN | ((RX_BUF_ALLOC_SIZE - RX_OFFSET) << 16)),\r\nmapping);\r\nskb_reserve(skb, RX_OFFSET);\r\n}\r\nHMD(("init txring, "));\r\nfor (i = 0; i < TX_RING_SIZE; i++)\r\nhme_write_txd(hp, &hb->happy_meal_txd[i], 0, 0);\r\nHMD(("done\n"));\r\n}\r\nstatic void\r\nhappy_meal_begin_auto_negotiation(struct happy_meal *hp,\r\nvoid __iomem *tregs,\r\nconst struct ethtool_link_ksettings *ep)\r\n{\r\nint timeout;\r\nhp->sw_bmsr = happy_meal_tcvr_read(hp, tregs, MII_BMSR);\r\nhp->sw_bmcr = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\r\nhp->sw_physid1 = happy_meal_tcvr_read(hp, tregs, MII_PHYSID1);\r\nhp->sw_physid2 = happy_meal_tcvr_read(hp, tregs, MII_PHYSID2);\r\nhp->sw_advertise = happy_meal_tcvr_read(hp, tregs, MII_ADVERTISE);\r\nif (!ep || ep->base.autoneg == AUTONEG_ENABLE) {\r\nif (hp->sw_bmsr & BMSR_10HALF)\r\nhp->sw_advertise |= (ADVERTISE_10HALF);\r\nelse\r\nhp->sw_advertise &= ~(ADVERTISE_10HALF);\r\nif (hp->sw_bmsr & BMSR_10FULL)\r\nhp->sw_advertise |= (ADVERTISE_10FULL);\r\nelse\r\nhp->sw_advertise &= ~(ADVERTISE_10FULL);\r\nif (hp->sw_bmsr & BMSR_100HALF)\r\nhp->sw_advertise |= (ADVERTISE_100HALF);\r\nelse\r\nhp->sw_advertise &= ~(ADVERTISE_100HALF);\r\nif (hp->sw_bmsr & BMSR_100FULL)\r\nhp->sw_advertise |= (ADVERTISE_100FULL);\r\nelse\r\nhp->sw_advertise &= ~(ADVERTISE_100FULL);\r\nhappy_meal_tcvr_write(hp, tregs, MII_ADVERTISE, hp->sw_advertise);\r\n#ifdef AUTO_SWITCH_DEBUG\r\nASD(("%s: Advertising [ ", hp->dev->name));\r\nif (hp->sw_advertise & ADVERTISE_10HALF)\r\nASD(("10H "));\r\nif (hp->sw_advertise & ADVERTISE_10FULL)\r\nASD(("10F "));\r\nif (hp->sw_advertise & ADVERTISE_100HALF)\r\nASD(("100H "));\r\nif (hp->sw_advertise & ADVERTISE_100FULL)\r\nASD(("100F "));\r\n#endif\r\nhp->sw_bmcr |= BMCR_ANENABLE;\r\nhappy_meal_tcvr_write(hp, tregs, MII_BMCR, hp->sw_bmcr);\r\nhp->sw_bmcr |= BMCR_ANRESTART;\r\nhappy_meal_tcvr_write(hp, tregs, MII_BMCR, hp->sw_bmcr);\r\ntimeout = 64;\r\nwhile (--timeout) {\r\nhp->sw_bmcr = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\r\nif (!(hp->sw_bmcr & BMCR_ANRESTART))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!timeout) {\r\nprintk(KERN_ERR "%s: Happy Meal would not start auto negotiation "\r\n"BMCR=0x%04x\n", hp->dev->name, hp->sw_bmcr);\r\nprintk(KERN_NOTICE "%s: Performing force link detection.\n",\r\nhp->dev->name);\r\ngoto force_link;\r\n} else {\r\nhp->timer_state = arbwait;\r\n}\r\n} else {\r\nforce_link:\r\nif (!ep || ep->base.autoneg == AUTONEG_ENABLE) {\r\nhp->sw_bmcr = BMCR_SPEED100;\r\n} else {\r\nif (ep->base.speed == SPEED_100)\r\nhp->sw_bmcr = BMCR_SPEED100;\r\nelse\r\nhp->sw_bmcr = 0;\r\nif (ep->base.duplex == DUPLEX_FULL)\r\nhp->sw_bmcr |= BMCR_FULLDPLX;\r\n}\r\nhappy_meal_tcvr_write(hp, tregs, MII_BMCR, hp->sw_bmcr);\r\nif (!is_lucent_phy(hp)) {\r\nhp->sw_csconfig = happy_meal_tcvr_read(hp, tregs,\r\nDP83840_CSCONFIG);\r\nhp->sw_csconfig &= ~(CSCONFIG_TCVDISAB);\r\nhappy_meal_tcvr_write(hp, tregs, DP83840_CSCONFIG,\r\nhp->sw_csconfig);\r\n}\r\nhp->timer_state = ltrywait;\r\n}\r\nhp->timer_ticks = 0;\r\nhp->happy_timer.expires = jiffies + (12 * HZ)/10;\r\nhp->happy_timer.data = (unsigned long) hp;\r\nhp->happy_timer.function = happy_meal_timer;\r\nadd_timer(&hp->happy_timer);\r\n}\r\nstatic int happy_meal_init(struct happy_meal *hp)\r\n{\r\nvoid __iomem *gregs = hp->gregs;\r\nvoid __iomem *etxregs = hp->etxregs;\r\nvoid __iomem *erxregs = hp->erxregs;\r\nvoid __iomem *bregs = hp->bigmacregs;\r\nvoid __iomem *tregs = hp->tcvregs;\r\nu32 regtmp, rxcfg;\r\nunsigned char *e = &hp->dev->dev_addr[0];\r\ndel_timer(&hp->happy_timer);\r\nHMD(("happy_meal_init: happy_flags[%08x] ",\r\nhp->happy_flags));\r\nif (!(hp->happy_flags & HFLAG_INIT)) {\r\nHMD(("set HFLAG_INIT, "));\r\nhp->happy_flags |= HFLAG_INIT;\r\nhappy_meal_get_counters(hp, bregs);\r\n}\r\nHMD(("to happy_meal_poll_stop\n"));\r\nhappy_meal_poll_stop(hp, tregs);\r\nHMD(("happy_meal_init: to happy_meal_stop\n"));\r\nhappy_meal_stop(hp, gregs);\r\nHMD(("happy_meal_init: to happy_meal_init_rings\n"));\r\nhappy_meal_init_rings(hp);\r\nHMD(("happy_meal_init: Disable all MIF irqs (old[%08x]), ",\r\nhme_read32(hp, tregs + TCVR_IMASK)));\r\nhme_write32(hp, tregs + TCVR_IMASK, 0xffff);\r\nif (hp->happy_flags & HFLAG_FENABLE) {\r\nHMD(("use frame old[%08x], ",\r\nhme_read32(hp, tregs + TCVR_CFG)));\r\nhme_write32(hp, tregs + TCVR_CFG,\r\nhme_read32(hp, tregs + TCVR_CFG) & ~(TCV_CFG_BENABLE));\r\n} else {\r\nHMD(("use bitbang old[%08x], ",\r\nhme_read32(hp, tregs + TCVR_CFG)));\r\nhme_write32(hp, tregs + TCVR_CFG,\r\nhme_read32(hp, tregs + TCVR_CFG) | TCV_CFG_BENABLE);\r\n}\r\nHMD(("to happy_meal_transceiver_check\n"));\r\nhappy_meal_transceiver_check(hp, tregs);\r\nHMD(("happy_meal_init: "));\r\nswitch(hp->tcvr_type) {\r\ncase none:\r\nHMD(("AAIEEE no transceiver type, EAGAIN"));\r\nreturn -EAGAIN;\r\ncase internal:\r\nHMD(("internal, using MII, "));\r\nhme_write32(hp, bregs + BMAC_XIFCFG, 0);\r\nbreak;\r\ncase external:\r\nHMD(("external, disable MII, "));\r\nhme_write32(hp, bregs + BMAC_XIFCFG, BIGMAC_XCFG_MIIDISAB);\r\nbreak;\r\n}\r\nif (happy_meal_tcvr_reset(hp, tregs))\r\nreturn -EAGAIN;\r\nHMD(("tx/rx reset, "));\r\nhappy_meal_tx_reset(hp, bregs);\r\nhappy_meal_rx_reset(hp, bregs);\r\nHMD(("jsize/ipg1/ipg2, "));\r\nhme_write32(hp, bregs + BMAC_JSIZE, DEFAULT_JAMSIZE);\r\nhme_write32(hp, bregs + BMAC_IGAP1, DEFAULT_IPG1);\r\nhme_write32(hp, bregs + BMAC_IGAP2, DEFAULT_IPG2);\r\nHMD(("rseed/macaddr, "));\r\nhme_write32(hp, bregs + BMAC_RSEED, ((e[5] | e[4]<<8)&0x3ff));\r\nhme_write32(hp, bregs + BMAC_MACADDR2, ((e[4] << 8) | e[5]));\r\nhme_write32(hp, bregs + BMAC_MACADDR1, ((e[2] << 8) | e[3]));\r\nhme_write32(hp, bregs + BMAC_MACADDR0, ((e[0] << 8) | e[1]));\r\nHMD(("htable, "));\r\nif ((hp->dev->flags & IFF_ALLMULTI) ||\r\n(netdev_mc_count(hp->dev) > 64)) {\r\nhme_write32(hp, bregs + BMAC_HTABLE0, 0xffff);\r\nhme_write32(hp, bregs + BMAC_HTABLE1, 0xffff);\r\nhme_write32(hp, bregs + BMAC_HTABLE2, 0xffff);\r\nhme_write32(hp, bregs + BMAC_HTABLE3, 0xffff);\r\n} else if ((hp->dev->flags & IFF_PROMISC) == 0) {\r\nu16 hash_table[4];\r\nstruct netdev_hw_addr *ha;\r\nu32 crc;\r\nmemset(hash_table, 0, sizeof(hash_table));\r\nnetdev_for_each_mc_addr(ha, hp->dev) {\r\ncrc = ether_crc_le(6, ha->addr);\r\ncrc >>= 26;\r\nhash_table[crc >> 4] |= 1 << (crc & 0xf);\r\n}\r\nhme_write32(hp, bregs + BMAC_HTABLE0, hash_table[0]);\r\nhme_write32(hp, bregs + BMAC_HTABLE1, hash_table[1]);\r\nhme_write32(hp, bregs + BMAC_HTABLE2, hash_table[2]);\r\nhme_write32(hp, bregs + BMAC_HTABLE3, hash_table[3]);\r\n} else {\r\nhme_write32(hp, bregs + BMAC_HTABLE3, 0);\r\nhme_write32(hp, bregs + BMAC_HTABLE2, 0);\r\nhme_write32(hp, bregs + BMAC_HTABLE1, 0);\r\nhme_write32(hp, bregs + BMAC_HTABLE0, 0);\r\n}\r\nHMD(("ring ptrs rxr[%08x] txr[%08x]\n",\r\n((__u32)hp->hblock_dvma + hblock_offset(happy_meal_rxd, 0)),\r\n((__u32)hp->hblock_dvma + hblock_offset(happy_meal_txd, 0))));\r\nhme_write32(hp, erxregs + ERX_RING,\r\n((__u32)hp->hblock_dvma + hblock_offset(happy_meal_rxd, 0)));\r\nhme_write32(hp, etxregs + ETX_RING,\r\n((__u32)hp->hblock_dvma + hblock_offset(happy_meal_txd, 0)));\r\nif (hme_read32(hp, erxregs + ERX_RING) !=\r\n((__u32)hp->hblock_dvma + hblock_offset(happy_meal_rxd, 0)))\r\nhme_write32(hp, erxregs + ERX_RING,\r\n((__u32)hp->hblock_dvma + hblock_offset(happy_meal_rxd, 0))\r\n| 0x4);\r\nHMD(("happy_meal_init: old[%08x] bursts<",\r\nhme_read32(hp, gregs + GREG_CFG)));\r\n#ifndef CONFIG_SPARC\r\nhme_write32(hp, gregs + GREG_CFG, GREG_CFG_BURST64);\r\n#else\r\nif ((hp->happy_bursts & DMA_BURST64) &&\r\n((hp->happy_flags & HFLAG_PCI) != 0\r\n#ifdef CONFIG_SBUS\r\n|| sbus_can_burst64()\r\n#endif\r\n|| 0)) {\r\nu32 gcfg = GREG_CFG_BURST64;\r\n#ifdef CONFIG_SBUS\r\nif ((hp->happy_flags & HFLAG_PCI) == 0) {\r\nstruct platform_device *op = hp->happy_dev;\r\nif (sbus_can_dma_64bit()) {\r\nsbus_set_sbus64(&op->dev,\r\nhp->happy_bursts);\r\ngcfg |= GREG_CFG_64BIT;\r\n}\r\n}\r\n#endif\r\nHMD(("64>"));\r\nhme_write32(hp, gregs + GREG_CFG, gcfg);\r\n} else if (hp->happy_bursts & DMA_BURST32) {\r\nHMD(("32>"));\r\nhme_write32(hp, gregs + GREG_CFG, GREG_CFG_BURST32);\r\n} else if (hp->happy_bursts & DMA_BURST16) {\r\nHMD(("16>"));\r\nhme_write32(hp, gregs + GREG_CFG, GREG_CFG_BURST16);\r\n} else {\r\nHMD(("XXX>"));\r\nhme_write32(hp, gregs + GREG_CFG, 0);\r\n}\r\n#endif\r\nHMD((", enable global interrupts, "));\r\nhme_write32(hp, gregs + GREG_IMASK,\r\n(GREG_IMASK_GOTFRAME | GREG_IMASK_RCNTEXP |\r\nGREG_IMASK_SENTFRAME | GREG_IMASK_TXPERR));\r\nHMD(("tx rsize=%d oreg[%08x], ", (int)TX_RING_SIZE,\r\nhme_read32(hp, etxregs + ETX_RSIZE)));\r\nhme_write32(hp, etxregs + ETX_RSIZE, (TX_RING_SIZE >> ETX_RSIZE_SHIFT) - 1);\r\nHMD(("tx dma enable old[%08x], ",\r\nhme_read32(hp, etxregs + ETX_CFG)));\r\nhme_write32(hp, etxregs + ETX_CFG,\r\nhme_read32(hp, etxregs + ETX_CFG) | ETX_CFG_DMAENABLE);\r\nHMD(("erx regs bug old[%08x]\n",\r\nhme_read32(hp, erxregs + ERX_CFG)));\r\nhme_write32(hp, erxregs + ERX_CFG, ERX_CFG_DEFAULT(RX_OFFSET));\r\nregtmp = hme_read32(hp, erxregs + ERX_CFG);\r\nhme_write32(hp, erxregs + ERX_CFG, ERX_CFG_DEFAULT(RX_OFFSET));\r\nif (hme_read32(hp, erxregs + ERX_CFG) != ERX_CFG_DEFAULT(RX_OFFSET)) {\r\nprintk(KERN_ERR "happy meal: Eieee, rx config register gets greasy fries.\n");\r\nprintk(KERN_ERR "happy meal: Trying to set %08x, reread gives %08x\n",\r\nERX_CFG_DEFAULT(RX_OFFSET), regtmp);\r\n}\r\nHMD(("happy_meal_init: enable hash rx_cfg_old[%08x], ",\r\nhme_read32(hp, bregs + BMAC_RXCFG)));\r\nrxcfg = BIGMAC_RXCFG_HENABLE | BIGMAC_RXCFG_REJME;\r\nif (hp->dev->flags & IFF_PROMISC)\r\nrxcfg |= BIGMAC_RXCFG_PMISC;\r\nhme_write32(hp, bregs + BMAC_RXCFG, rxcfg);\r\nudelay(10);\r\nHMD(("BIGMAC init, "));\r\nregtmp = 0;\r\nif (hp->happy_flags & HFLAG_FULL)\r\nregtmp |= BIGMAC_TXCFG_FULLDPLX;\r\nhme_write32(hp, bregs + BMAC_TXCFG, regtmp );\r\nhme_write32(hp, bregs + BMAC_ALIMIT, 16);\r\nregtmp = BIGMAC_XCFG_ODENABLE;\r\nif (hp->happy_flags & HFLAG_LANCE)\r\nregtmp |= (DEFAULT_IPG0 << 5) | BIGMAC_XCFG_LANCE;\r\nif (hp->tcvr_type == external)\r\nregtmp |= BIGMAC_XCFG_MIIDISAB;\r\nHMD(("XIF config old[%08x], ",\r\nhme_read32(hp, bregs + BMAC_XIFCFG)));\r\nhme_write32(hp, bregs + BMAC_XIFCFG, regtmp);\r\nHMD(("tx old[%08x] and rx [%08x] ON!\n",\r\nhme_read32(hp, bregs + BMAC_TXCFG),\r\nhme_read32(hp, bregs + BMAC_RXCFG)));\r\nhme_write32(hp, bregs + BMAC_TXMAX, ETH_FRAME_LEN + 8);\r\nhme_write32(hp, bregs + BMAC_RXMAX, ETH_FRAME_LEN + 8);\r\nhme_write32(hp, bregs + BMAC_TXCFG,\r\nhme_read32(hp, bregs + BMAC_TXCFG) | BIGMAC_TXCFG_ENABLE);\r\nhme_write32(hp, bregs + BMAC_RXCFG,\r\nhme_read32(hp, bregs + BMAC_RXCFG) | BIGMAC_RXCFG_ENABLE);\r\nhappy_meal_begin_auto_negotiation(hp, tregs, NULL);\r\nreturn 0;\r\n}\r\nstatic void happy_meal_set_initial_advertisement(struct happy_meal *hp)\r\n{\r\nvoid __iomem *tregs = hp->tcvregs;\r\nvoid __iomem *bregs = hp->bigmacregs;\r\nvoid __iomem *gregs = hp->gregs;\r\nhappy_meal_stop(hp, gregs);\r\nhme_write32(hp, tregs + TCVR_IMASK, 0xffff);\r\nif (hp->happy_flags & HFLAG_FENABLE)\r\nhme_write32(hp, tregs + TCVR_CFG,\r\nhme_read32(hp, tregs + TCVR_CFG) & ~(TCV_CFG_BENABLE));\r\nelse\r\nhme_write32(hp, tregs + TCVR_CFG,\r\nhme_read32(hp, tregs + TCVR_CFG) | TCV_CFG_BENABLE);\r\nhappy_meal_transceiver_check(hp, tregs);\r\nswitch(hp->tcvr_type) {\r\ncase none:\r\nreturn;\r\ncase internal:\r\nhme_write32(hp, bregs + BMAC_XIFCFG, 0);\r\nbreak;\r\ncase external:\r\nhme_write32(hp, bregs + BMAC_XIFCFG, BIGMAC_XCFG_MIIDISAB);\r\nbreak;\r\n}\r\nif (happy_meal_tcvr_reset(hp, tregs))\r\nreturn;\r\nhp->sw_bmsr = happy_meal_tcvr_read(hp, tregs, MII_BMSR);\r\nhp->sw_advertise = happy_meal_tcvr_read(hp, tregs, MII_ADVERTISE);\r\nif (hp->sw_bmsr & BMSR_10HALF)\r\nhp->sw_advertise |= (ADVERTISE_10HALF);\r\nelse\r\nhp->sw_advertise &= ~(ADVERTISE_10HALF);\r\nif (hp->sw_bmsr & BMSR_10FULL)\r\nhp->sw_advertise |= (ADVERTISE_10FULL);\r\nelse\r\nhp->sw_advertise &= ~(ADVERTISE_10FULL);\r\nif (hp->sw_bmsr & BMSR_100HALF)\r\nhp->sw_advertise |= (ADVERTISE_100HALF);\r\nelse\r\nhp->sw_advertise &= ~(ADVERTISE_100HALF);\r\nif (hp->sw_bmsr & BMSR_100FULL)\r\nhp->sw_advertise |= (ADVERTISE_100FULL);\r\nelse\r\nhp->sw_advertise &= ~(ADVERTISE_100FULL);\r\nhappy_meal_tcvr_write(hp, tregs, MII_ADVERTISE, hp->sw_advertise);\r\n}\r\nstatic int happy_meal_is_not_so_happy(struct happy_meal *hp, u32 status)\r\n{\r\nint reset = 0;\r\nif (status & (GREG_STAT_STSTERR | GREG_STAT_TFIFO_UND |\r\nGREG_STAT_MAXPKTERR | GREG_STAT_RXERR |\r\nGREG_STAT_RXPERR | GREG_STAT_RXTERR | GREG_STAT_EOPERR |\r\nGREG_STAT_MIFIRQ | GREG_STAT_TXEACK | GREG_STAT_TXLERR |\r\nGREG_STAT_TXPERR | GREG_STAT_TXTERR | GREG_STAT_SLVERR |\r\nGREG_STAT_SLVPERR))\r\nprintk(KERN_ERR "%s: Error interrupt for happy meal, status = %08x\n",\r\nhp->dev->name, status);\r\nif (status & GREG_STAT_RFIFOVF) {\r\nprintk(KERN_DEBUG "%s: Happy Meal receive FIFO overflow.\n", hp->dev->name);\r\n}\r\nif (status & GREG_STAT_STSTERR) {\r\nprintk(KERN_ERR "%s: Happy Meal BigMAC SQE test failed.\n", hp->dev->name);\r\nreset = 1;\r\n}\r\nif (status & GREG_STAT_TFIFO_UND) {\r\nprintk(KERN_ERR "%s: Happy Meal transmitter FIFO underrun, DMA error.\n",\r\nhp->dev->name);\r\nreset = 1;\r\n}\r\nif (status & GREG_STAT_MAXPKTERR) {\r\nprintk(KERN_ERR "%s: Happy Meal MAX Packet size error.\n", hp->dev->name);\r\nreset = 1;\r\n}\r\nif (status & GREG_STAT_NORXD) {\r\nprintk(KERN_INFO "%s: Happy Meal out of receive "\r\n"descriptors, packet dropped.\n",\r\nhp->dev->name);\r\n}\r\nif (status & (GREG_STAT_RXERR|GREG_STAT_RXPERR|GREG_STAT_RXTERR)) {\r\nprintk(KERN_ERR "%s: Happy Meal rx DMA errors [ ", hp->dev->name);\r\nif (status & GREG_STAT_RXERR)\r\nprintk("GenericError ");\r\nif (status & GREG_STAT_RXPERR)\r\nprintk("ParityError ");\r\nif (status & GREG_STAT_RXTERR)\r\nprintk("RxTagBotch ");\r\nprintk("]\n");\r\nreset = 1;\r\n}\r\nif (status & GREG_STAT_EOPERR) {\r\nprintk(KERN_ERR "%s: EOP not set in happy meal transmit descriptor!\n",\r\nhp->dev->name);\r\nreset = 1;\r\n}\r\nif (status & GREG_STAT_MIFIRQ) {\r\nprintk(KERN_ERR "%s: Happy Meal MIF interrupt.\n", hp->dev->name);\r\n}\r\nif (status &\r\n(GREG_STAT_TXEACK|GREG_STAT_TXLERR|GREG_STAT_TXPERR|GREG_STAT_TXTERR)) {\r\nprintk(KERN_ERR "%s: Happy Meal tx DMA errors [ ", hp->dev->name);\r\nif (status & GREG_STAT_TXEACK)\r\nprintk("GenericError ");\r\nif (status & GREG_STAT_TXLERR)\r\nprintk("LateError ");\r\nif (status & GREG_STAT_TXPERR)\r\nprintk("ParityError ");\r\nif (status & GREG_STAT_TXTERR)\r\nprintk("TagBotch ");\r\nprintk("]\n");\r\nreset = 1;\r\n}\r\nif (status & (GREG_STAT_SLVERR|GREG_STAT_SLVPERR)) {\r\nprintk(KERN_ERR "%s: Happy Meal register access SBUS slave (%s) error.\n",\r\nhp->dev->name,\r\n(status & GREG_STAT_SLVPERR) ? "parity" : "generic");\r\nreset = 1;\r\n}\r\nif (reset) {\r\nprintk(KERN_NOTICE "%s: Resetting...\n", hp->dev->name);\r\nhappy_meal_init(hp);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void happy_meal_mif_interrupt(struct happy_meal *hp)\r\n{\r\nvoid __iomem *tregs = hp->tcvregs;\r\nprintk(KERN_INFO "%s: Link status change.\n", hp->dev->name);\r\nhp->sw_bmcr = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\r\nhp->sw_lpa = happy_meal_tcvr_read(hp, tregs, MII_LPA);\r\nif (hp->sw_lpa & LPA_100FULL) {\r\nprintk(KERN_INFO "%s: Switching to 100Mbps at full duplex.", hp->dev->name);\r\nhp->sw_bmcr |= (BMCR_FULLDPLX | BMCR_SPEED100);\r\n} else if (hp->sw_lpa & LPA_100HALF) {\r\nprintk(KERN_INFO "%s: Switching to 100MBps at half duplex.", hp->dev->name);\r\nhp->sw_bmcr |= BMCR_SPEED100;\r\n} else if (hp->sw_lpa & LPA_10FULL) {\r\nprintk(KERN_INFO "%s: Switching to 10MBps at full duplex.", hp->dev->name);\r\nhp->sw_bmcr |= BMCR_FULLDPLX;\r\n} else {\r\nprintk(KERN_INFO "%s: Using 10Mbps at half duplex.", hp->dev->name);\r\n}\r\nhappy_meal_tcvr_write(hp, tregs, MII_BMCR, hp->sw_bmcr);\r\nhappy_meal_poll_stop(hp, tregs);\r\n}\r\nstatic void happy_meal_tx(struct happy_meal *hp)\r\n{\r\nstruct happy_meal_txd *txbase = &hp->happy_block->happy_meal_txd[0];\r\nstruct happy_meal_txd *this;\r\nstruct net_device *dev = hp->dev;\r\nint elem;\r\nelem = hp->tx_old;\r\nTXD(("TX<"));\r\nwhile (elem != hp->tx_new) {\r\nstruct sk_buff *skb;\r\nu32 flags, dma_addr, dma_len;\r\nint frag;\r\nTXD(("[%d]", elem));\r\nthis = &txbase[elem];\r\nflags = hme_read_desc32(hp, &this->tx_flags);\r\nif (flags & TXFLAG_OWN)\r\nbreak;\r\nskb = hp->tx_skbs[elem];\r\nif (skb_shinfo(skb)->nr_frags) {\r\nint last;\r\nlast = elem + skb_shinfo(skb)->nr_frags;\r\nlast &= (TX_RING_SIZE - 1);\r\nflags = hme_read_desc32(hp, &txbase[last].tx_flags);\r\nif (flags & TXFLAG_OWN)\r\nbreak;\r\n}\r\nhp->tx_skbs[elem] = NULL;\r\ndev->stats.tx_bytes += skb->len;\r\nfor (frag = 0; frag <= skb_shinfo(skb)->nr_frags; frag++) {\r\ndma_addr = hme_read_desc32(hp, &this->tx_addr);\r\ndma_len = hme_read_desc32(hp, &this->tx_flags);\r\ndma_len &= TXFLAG_SIZE;\r\nif (!frag)\r\ndma_unmap_single(hp->dma_dev, dma_addr, dma_len, DMA_TO_DEVICE);\r\nelse\r\ndma_unmap_page(hp->dma_dev, dma_addr, dma_len, DMA_TO_DEVICE);\r\nelem = NEXT_TX(elem);\r\nthis = &txbase[elem];\r\n}\r\ndev_kfree_skb_irq(skb);\r\ndev->stats.tx_packets++;\r\n}\r\nhp->tx_old = elem;\r\nTXD((">"));\r\nif (netif_queue_stopped(dev) &&\r\nTX_BUFFS_AVAIL(hp) > (MAX_SKB_FRAGS + 1))\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void happy_meal_rx(struct happy_meal *hp, struct net_device *dev)\r\n{\r\nstruct happy_meal_rxd *rxbase = &hp->happy_block->happy_meal_rxd[0];\r\nstruct happy_meal_rxd *this;\r\nint elem = hp->rx_new, drops = 0;\r\nu32 flags;\r\nRXD(("RX<"));\r\nthis = &rxbase[elem];\r\nwhile (!((flags = hme_read_desc32(hp, &this->rx_flags)) & RXFLAG_OWN)) {\r\nstruct sk_buff *skb;\r\nint len = flags >> 16;\r\nu16 csum = flags & RXFLAG_CSUM;\r\nu32 dma_addr = hme_read_desc32(hp, &this->rx_addr);\r\nRXD(("[%d ", elem));\r\nif ((len < ETH_ZLEN) || (flags & RXFLAG_OVERFLOW)) {\r\nRXD(("ERR(%08x)]", flags));\r\ndev->stats.rx_errors++;\r\nif (len < ETH_ZLEN)\r\ndev->stats.rx_length_errors++;\r\nif (len & (RXFLAG_OVERFLOW >> 16)) {\r\ndev->stats.rx_over_errors++;\r\ndev->stats.rx_fifo_errors++;\r\n}\r\ndrop_it:\r\ndev->stats.rx_dropped++;\r\nhme_write_rxd(hp, this,\r\n(RXFLAG_OWN|((RX_BUF_ALLOC_SIZE-RX_OFFSET)<<16)),\r\ndma_addr);\r\ngoto next;\r\n}\r\nskb = hp->rx_skbs[elem];\r\nif (len > RX_COPY_THRESHOLD) {\r\nstruct sk_buff *new_skb;\r\nu32 mapping;\r\nnew_skb = happy_meal_alloc_skb(RX_BUF_ALLOC_SIZE, GFP_ATOMIC);\r\nif (new_skb == NULL) {\r\ndrops++;\r\ngoto drop_it;\r\n}\r\nskb_put(new_skb, (ETH_FRAME_LEN + RX_OFFSET + 4));\r\nmapping = dma_map_single(hp->dma_dev, new_skb->data,\r\nRX_BUF_ALLOC_SIZE,\r\nDMA_FROM_DEVICE);\r\nif (unlikely(dma_mapping_error(hp->dma_dev, mapping))) {\r\ndev_kfree_skb_any(new_skb);\r\ndrops++;\r\ngoto drop_it;\r\n}\r\ndma_unmap_single(hp->dma_dev, dma_addr, RX_BUF_ALLOC_SIZE, DMA_FROM_DEVICE);\r\nhp->rx_skbs[elem] = new_skb;\r\nhme_write_rxd(hp, this,\r\n(RXFLAG_OWN|((RX_BUF_ALLOC_SIZE-RX_OFFSET)<<16)),\r\nmapping);\r\nskb_reserve(new_skb, RX_OFFSET);\r\nskb_trim(skb, len);\r\n} else {\r\nstruct sk_buff *copy_skb = netdev_alloc_skb(dev, len + 2);\r\nif (copy_skb == NULL) {\r\ndrops++;\r\ngoto drop_it;\r\n}\r\nskb_reserve(copy_skb, 2);\r\nskb_put(copy_skb, len);\r\ndma_sync_single_for_cpu(hp->dma_dev, dma_addr, len, DMA_FROM_DEVICE);\r\nskb_copy_from_linear_data(skb, copy_skb->data, len);\r\ndma_sync_single_for_device(hp->dma_dev, dma_addr, len, DMA_FROM_DEVICE);\r\nhme_write_rxd(hp, this,\r\n(RXFLAG_OWN|((RX_BUF_ALLOC_SIZE-RX_OFFSET)<<16)),\r\ndma_addr);\r\nskb = copy_skb;\r\n}\r\nskb->csum = csum_unfold(~(__force __sum16)htons(csum));\r\nskb->ip_summed = CHECKSUM_COMPLETE;\r\nRXD(("len=%d csum=%4x]", len, csum));\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\nnext:\r\nelem = NEXT_RX(elem);\r\nthis = &rxbase[elem];\r\n}\r\nhp->rx_new = elem;\r\nif (drops)\r\nprintk(KERN_INFO "%s: Memory squeeze, deferring packet.\n", hp->dev->name);\r\nRXD((">"));\r\n}\r\nstatic irqreturn_t happy_meal_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct happy_meal *hp = netdev_priv(dev);\r\nu32 happy_status = hme_read32(hp, hp->gregs + GREG_STAT);\r\nHMD(("happy_meal_interrupt: status=%08x ", happy_status));\r\nspin_lock(&hp->happy_lock);\r\nif (happy_status & GREG_STAT_ERRORS) {\r\nHMD(("ERRORS "));\r\nif (happy_meal_is_not_so_happy(hp, happy_status))\r\ngoto out;\r\n}\r\nif (happy_status & GREG_STAT_MIFIRQ) {\r\nHMD(("MIFIRQ "));\r\nhappy_meal_mif_interrupt(hp);\r\n}\r\nif (happy_status & GREG_STAT_TXALL) {\r\nHMD(("TXALL "));\r\nhappy_meal_tx(hp);\r\n}\r\nif (happy_status & GREG_STAT_RXTOHOST) {\r\nHMD(("RXTOHOST "));\r\nhappy_meal_rx(hp, dev);\r\n}\r\nHMD(("done\n"));\r\nout:\r\nspin_unlock(&hp->happy_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t quattro_sbus_interrupt(int irq, void *cookie)\r\n{\r\nstruct quattro *qp = (struct quattro *) cookie;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nstruct net_device *dev = qp->happy_meals[i];\r\nstruct happy_meal *hp = netdev_priv(dev);\r\nu32 happy_status = hme_read32(hp, hp->gregs + GREG_STAT);\r\nHMD(("quattro_interrupt: status=%08x ", happy_status));\r\nif (!(happy_status & (GREG_STAT_ERRORS |\r\nGREG_STAT_MIFIRQ |\r\nGREG_STAT_TXALL |\r\nGREG_STAT_RXTOHOST)))\r\ncontinue;\r\nspin_lock(&hp->happy_lock);\r\nif (happy_status & GREG_STAT_ERRORS) {\r\nHMD(("ERRORS "));\r\nif (happy_meal_is_not_so_happy(hp, happy_status))\r\ngoto next;\r\n}\r\nif (happy_status & GREG_STAT_MIFIRQ) {\r\nHMD(("MIFIRQ "));\r\nhappy_meal_mif_interrupt(hp);\r\n}\r\nif (happy_status & GREG_STAT_TXALL) {\r\nHMD(("TXALL "));\r\nhappy_meal_tx(hp);\r\n}\r\nif (happy_status & GREG_STAT_RXTOHOST) {\r\nHMD(("RXTOHOST "));\r\nhappy_meal_rx(hp, dev);\r\n}\r\nnext:\r\nspin_unlock(&hp->happy_lock);\r\n}\r\nHMD(("done\n"));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int happy_meal_open(struct net_device *dev)\r\n{\r\nstruct happy_meal *hp = netdev_priv(dev);\r\nint res;\r\nHMD(("happy_meal_open: "));\r\nif ((hp->happy_flags & (HFLAG_QUATTRO|HFLAG_PCI)) != HFLAG_QUATTRO) {\r\nres = request_irq(hp->irq, happy_meal_interrupt, IRQF_SHARED,\r\ndev->name, dev);\r\nif (res) {\r\nHMD(("EAGAIN\n"));\r\nprintk(KERN_ERR "happy_meal(SBUS): Can't order irq %d to go.\n",\r\nhp->irq);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nHMD(("to happy_meal_init\n"));\r\nspin_lock_irq(&hp->happy_lock);\r\nres = happy_meal_init(hp);\r\nspin_unlock_irq(&hp->happy_lock);\r\nif (res && ((hp->happy_flags & (HFLAG_QUATTRO|HFLAG_PCI)) != HFLAG_QUATTRO))\r\nfree_irq(hp->irq, dev);\r\nreturn res;\r\n}\r\nstatic int happy_meal_close(struct net_device *dev)\r\n{\r\nstruct happy_meal *hp = netdev_priv(dev);\r\nspin_lock_irq(&hp->happy_lock);\r\nhappy_meal_stop(hp, hp->gregs);\r\nhappy_meal_clean_rings(hp);\r\ndel_timer(&hp->happy_timer);\r\nspin_unlock_irq(&hp->happy_lock);\r\nif ((hp->happy_flags & (HFLAG_QUATTRO|HFLAG_PCI)) != HFLAG_QUATTRO)\r\nfree_irq(hp->irq, dev);\r\nreturn 0;\r\n}\r\nstatic void happy_meal_tx_timeout(struct net_device *dev)\r\n{\r\nstruct happy_meal *hp = netdev_priv(dev);\r\nprintk (KERN_ERR "%s: transmit timed out, resetting\n", dev->name);\r\ntx_dump_log();\r\nprintk (KERN_ERR "%s: Happy Status %08x TX[%08x:%08x]\n", dev->name,\r\nhme_read32(hp, hp->gregs + GREG_STAT),\r\nhme_read32(hp, hp->etxregs + ETX_CFG),\r\nhme_read32(hp, hp->bigmacregs + BMAC_TXCFG));\r\nspin_lock_irq(&hp->happy_lock);\r\nhappy_meal_init(hp);\r\nspin_unlock_irq(&hp->happy_lock);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void unmap_partial_tx_skb(struct happy_meal *hp, u32 first_mapping,\r\nu32 first_len, u32 first_entry, u32 entry)\r\n{\r\nstruct happy_meal_txd *txbase = &hp->happy_block->happy_meal_txd[0];\r\ndma_unmap_single(hp->dma_dev, first_mapping, first_len, DMA_TO_DEVICE);\r\nfirst_entry = NEXT_TX(first_entry);\r\nwhile (first_entry != entry) {\r\nstruct happy_meal_txd *this = &txbase[first_entry];\r\nu32 addr, len;\r\naddr = hme_read_desc32(hp, &this->tx_addr);\r\nlen = hme_read_desc32(hp, &this->tx_flags);\r\nlen &= TXFLAG_SIZE;\r\ndma_unmap_page(hp->dma_dev, addr, len, DMA_TO_DEVICE);\r\n}\r\n}\r\nstatic netdev_tx_t happy_meal_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct happy_meal *hp = netdev_priv(dev);\r\nint entry;\r\nu32 tx_flags;\r\ntx_flags = TXFLAG_OWN;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nconst u32 csum_start_off = skb_checksum_start_offset(skb);\r\nconst u32 csum_stuff_off = csum_start_off + skb->csum_offset;\r\ntx_flags = (TXFLAG_OWN | TXFLAG_CSENABLE |\r\n((csum_start_off << 14) & TXFLAG_CSBUFBEGIN) |\r\n((csum_stuff_off << 20) & TXFLAG_CSLOCATION));\r\n}\r\nspin_lock_irq(&hp->happy_lock);\r\nif (TX_BUFFS_AVAIL(hp) <= (skb_shinfo(skb)->nr_frags + 1)) {\r\nnetif_stop_queue(dev);\r\nspin_unlock_irq(&hp->happy_lock);\r\nprintk(KERN_ERR "%s: BUG! Tx Ring full when queue awake!\n",\r\ndev->name);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nentry = hp->tx_new;\r\nSXD(("SX<l[%d]e[%d]>", len, entry));\r\nhp->tx_skbs[entry] = skb;\r\nif (skb_shinfo(skb)->nr_frags == 0) {\r\nu32 mapping, len;\r\nlen = skb->len;\r\nmapping = dma_map_single(hp->dma_dev, skb->data, len, DMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(hp->dma_dev, mapping)))\r\ngoto out_dma_error;\r\ntx_flags |= (TXFLAG_SOP | TXFLAG_EOP);\r\nhme_write_txd(hp, &hp->happy_block->happy_meal_txd[entry],\r\n(tx_flags | (len & TXFLAG_SIZE)),\r\nmapping);\r\nentry = NEXT_TX(entry);\r\n} else {\r\nu32 first_len, first_mapping;\r\nint frag, first_entry = entry;\r\nfirst_len = skb_headlen(skb);\r\nfirst_mapping = dma_map_single(hp->dma_dev, skb->data, first_len,\r\nDMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(hp->dma_dev, first_mapping)))\r\ngoto out_dma_error;\r\nentry = NEXT_TX(entry);\r\nfor (frag = 0; frag < skb_shinfo(skb)->nr_frags; frag++) {\r\nconst skb_frag_t *this_frag = &skb_shinfo(skb)->frags[frag];\r\nu32 len, mapping, this_txflags;\r\nlen = skb_frag_size(this_frag);\r\nmapping = skb_frag_dma_map(hp->dma_dev, this_frag,\r\n0, len, DMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(hp->dma_dev, mapping))) {\r\nunmap_partial_tx_skb(hp, first_mapping, first_len,\r\nfirst_entry, entry);\r\ngoto out_dma_error;\r\n}\r\nthis_txflags = tx_flags;\r\nif (frag == skb_shinfo(skb)->nr_frags - 1)\r\nthis_txflags |= TXFLAG_EOP;\r\nhme_write_txd(hp, &hp->happy_block->happy_meal_txd[entry],\r\n(this_txflags | (len & TXFLAG_SIZE)),\r\nmapping);\r\nentry = NEXT_TX(entry);\r\n}\r\nhme_write_txd(hp, &hp->happy_block->happy_meal_txd[first_entry],\r\n(tx_flags | TXFLAG_SOP | (first_len & TXFLAG_SIZE)),\r\nfirst_mapping);\r\n}\r\nhp->tx_new = entry;\r\nif (TX_BUFFS_AVAIL(hp) <= (MAX_SKB_FRAGS + 1))\r\nnetif_stop_queue(dev);\r\nhme_write32(hp, hp->etxregs + ETX_PENDING, ETX_TP_DMAWAKEUP);\r\nspin_unlock_irq(&hp->happy_lock);\r\ntx_add_log(hp, TXLOG_ACTION_TXMIT, 0);\r\nreturn NETDEV_TX_OK;\r\nout_dma_error:\r\nhp->tx_skbs[hp->tx_new] = NULL;\r\nspin_unlock_irq(&hp->happy_lock);\r\ndev_kfree_skb_any(skb);\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct net_device_stats *happy_meal_get_stats(struct net_device *dev)\r\n{\r\nstruct happy_meal *hp = netdev_priv(dev);\r\nspin_lock_irq(&hp->happy_lock);\r\nhappy_meal_get_counters(hp, hp->bigmacregs);\r\nspin_unlock_irq(&hp->happy_lock);\r\nreturn &dev->stats;\r\n}\r\nstatic void happy_meal_set_multicast(struct net_device *dev)\r\n{\r\nstruct happy_meal *hp = netdev_priv(dev);\r\nvoid __iomem *bregs = hp->bigmacregs;\r\nstruct netdev_hw_addr *ha;\r\nu32 crc;\r\nspin_lock_irq(&hp->happy_lock);\r\nif ((dev->flags & IFF_ALLMULTI) || (netdev_mc_count(dev) > 64)) {\r\nhme_write32(hp, bregs + BMAC_HTABLE0, 0xffff);\r\nhme_write32(hp, bregs + BMAC_HTABLE1, 0xffff);\r\nhme_write32(hp, bregs + BMAC_HTABLE2, 0xffff);\r\nhme_write32(hp, bregs + BMAC_HTABLE3, 0xffff);\r\n} else if (dev->flags & IFF_PROMISC) {\r\nhme_write32(hp, bregs + BMAC_RXCFG,\r\nhme_read32(hp, bregs + BMAC_RXCFG) | BIGMAC_RXCFG_PMISC);\r\n} else {\r\nu16 hash_table[4];\r\nmemset(hash_table, 0, sizeof(hash_table));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc_le(6, ha->addr);\r\ncrc >>= 26;\r\nhash_table[crc >> 4] |= 1 << (crc & 0xf);\r\n}\r\nhme_write32(hp, bregs + BMAC_HTABLE0, hash_table[0]);\r\nhme_write32(hp, bregs + BMAC_HTABLE1, hash_table[1]);\r\nhme_write32(hp, bregs + BMAC_HTABLE2, hash_table[2]);\r\nhme_write32(hp, bregs + BMAC_HTABLE3, hash_table[3]);\r\n}\r\nspin_unlock_irq(&hp->happy_lock);\r\n}\r\nstatic int hme_get_link_ksettings(struct net_device *dev,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nstruct happy_meal *hp = netdev_priv(dev);\r\nu32 speed;\r\nu32 supported;\r\nsupported =\r\n(SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |\r\nSUPPORTED_Autoneg | SUPPORTED_TP | SUPPORTED_MII);\r\ncmd->base.port = PORT_TP;\r\ncmd->base.phy_address = 0;\r\nspin_lock_irq(&hp->happy_lock);\r\nhp->sw_bmcr = happy_meal_tcvr_read(hp, hp->tcvregs, MII_BMCR);\r\nhp->sw_lpa = happy_meal_tcvr_read(hp, hp->tcvregs, MII_LPA);\r\nspin_unlock_irq(&hp->happy_lock);\r\nif (hp->sw_bmcr & BMCR_ANENABLE) {\r\ncmd->base.autoneg = AUTONEG_ENABLE;\r\nspeed = ((hp->sw_lpa & (LPA_100HALF | LPA_100FULL)) ?\r\nSPEED_100 : SPEED_10);\r\nif (speed == SPEED_100)\r\ncmd->base.duplex =\r\n(hp->sw_lpa & (LPA_100FULL)) ?\r\nDUPLEX_FULL : DUPLEX_HALF;\r\nelse\r\ncmd->base.duplex =\r\n(hp->sw_lpa & (LPA_10FULL)) ?\r\nDUPLEX_FULL : DUPLEX_HALF;\r\n} else {\r\ncmd->base.autoneg = AUTONEG_DISABLE;\r\nspeed = (hp->sw_bmcr & BMCR_SPEED100) ? SPEED_100 : SPEED_10;\r\ncmd->base.duplex =\r\n(hp->sw_bmcr & BMCR_FULLDPLX) ?\r\nDUPLEX_FULL : DUPLEX_HALF;\r\n}\r\ncmd->base.speed = speed;\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\r\nsupported);\r\nreturn 0;\r\n}\r\nstatic int hme_set_link_ksettings(struct net_device *dev,\r\nconst struct ethtool_link_ksettings *cmd)\r\n{\r\nstruct happy_meal *hp = netdev_priv(dev);\r\nif (cmd->base.autoneg != AUTONEG_ENABLE &&\r\ncmd->base.autoneg != AUTONEG_DISABLE)\r\nreturn -EINVAL;\r\nif (cmd->base.autoneg == AUTONEG_DISABLE &&\r\n((cmd->base.speed != SPEED_100 &&\r\ncmd->base.speed != SPEED_10) ||\r\n(cmd->base.duplex != DUPLEX_HALF &&\r\ncmd->base.duplex != DUPLEX_FULL)))\r\nreturn -EINVAL;\r\nspin_lock_irq(&hp->happy_lock);\r\ndel_timer(&hp->happy_timer);\r\nhappy_meal_begin_auto_negotiation(hp, hp->tcvregs, cmd);\r\nspin_unlock_irq(&hp->happy_lock);\r\nreturn 0;\r\n}\r\nstatic void hme_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct happy_meal *hp = netdev_priv(dev);\r\nstrlcpy(info->driver, "sunhme", sizeof(info->driver));\r\nstrlcpy(info->version, "2.02", sizeof(info->version));\r\nif (hp->happy_flags & HFLAG_PCI) {\r\nstruct pci_dev *pdev = hp->happy_dev;\r\nstrlcpy(info->bus_info, pci_name(pdev), sizeof(info->bus_info));\r\n}\r\n#ifdef CONFIG_SBUS\r\nelse {\r\nconst struct linux_prom_registers *regs;\r\nstruct platform_device *op = hp->happy_dev;\r\nregs = of_get_property(op->dev.of_node, "regs", NULL);\r\nif (regs)\r\nsnprintf(info->bus_info, sizeof(info->bus_info),\r\n"SBUS:%d",\r\nregs->which_io);\r\n}\r\n#endif\r\n}\r\nstatic u32 hme_get_link(struct net_device *dev)\r\n{\r\nstruct happy_meal *hp = netdev_priv(dev);\r\nspin_lock_irq(&hp->happy_lock);\r\nhp->sw_bmcr = happy_meal_tcvr_read(hp, hp->tcvregs, MII_BMCR);\r\nspin_unlock_irq(&hp->happy_lock);\r\nreturn hp->sw_bmsr & BMSR_LSTATUS;\r\n}\r\nstatic struct quattro *quattro_sbus_find(struct platform_device *child)\r\n{\r\nstruct device *parent = child->dev.parent;\r\nstruct platform_device *op;\r\nstruct quattro *qp;\r\nop = to_platform_device(parent);\r\nqp = platform_get_drvdata(op);\r\nif (qp)\r\nreturn qp;\r\nqp = kmalloc(sizeof(struct quattro), GFP_KERNEL);\r\nif (qp != NULL) {\r\nint i;\r\nfor (i = 0; i < 4; i++)\r\nqp->happy_meals[i] = NULL;\r\nqp->quattro_dev = child;\r\nqp->next = qfe_sbus_list;\r\nqfe_sbus_list = qp;\r\nplatform_set_drvdata(op, qp);\r\n}\r\nreturn qp;\r\n}\r\nstatic int __init quattro_sbus_register_irqs(void)\r\n{\r\nstruct quattro *qp;\r\nfor (qp = qfe_sbus_list; qp != NULL; qp = qp->next) {\r\nstruct platform_device *op = qp->quattro_dev;\r\nint err, qfe_slot, skip = 0;\r\nfor (qfe_slot = 0; qfe_slot < 4; qfe_slot++) {\r\nif (!qp->happy_meals[qfe_slot])\r\nskip = 1;\r\n}\r\nif (skip)\r\ncontinue;\r\nerr = request_irq(op->archdata.irqs[0],\r\nquattro_sbus_interrupt,\r\nIRQF_SHARED, "Quattro",\r\nqp);\r\nif (err != 0) {\r\nprintk(KERN_ERR "Quattro HME: IRQ registration "\r\n"error %d.\n", err);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void quattro_sbus_free_irqs(void)\r\n{\r\nstruct quattro *qp;\r\nfor (qp = qfe_sbus_list; qp != NULL; qp = qp->next) {\r\nstruct platform_device *op = qp->quattro_dev;\r\nint qfe_slot, skip = 0;\r\nfor (qfe_slot = 0; qfe_slot < 4; qfe_slot++) {\r\nif (!qp->happy_meals[qfe_slot])\r\nskip = 1;\r\n}\r\nif (skip)\r\ncontinue;\r\nfree_irq(op->archdata.irqs[0], qp);\r\n}\r\n}\r\nstatic struct quattro *quattro_pci_find(struct pci_dev *pdev)\r\n{\r\nstruct pci_dev *bdev = pdev->bus->self;\r\nstruct quattro *qp;\r\nif (!bdev) return NULL;\r\nfor (qp = qfe_pci_list; qp != NULL; qp = qp->next) {\r\nstruct pci_dev *qpdev = qp->quattro_dev;\r\nif (qpdev == bdev)\r\nreturn qp;\r\n}\r\nqp = kmalloc(sizeof(struct quattro), GFP_KERNEL);\r\nif (qp != NULL) {\r\nint i;\r\nfor (i = 0; i < 4; i++)\r\nqp->happy_meals[i] = NULL;\r\nqp->quattro_dev = bdev;\r\nqp->next = qfe_pci_list;\r\nqfe_pci_list = qp;\r\nqp->nranges = 0;\r\n}\r\nreturn qp;\r\n}\r\nstatic int happy_meal_sbus_probe_one(struct platform_device *op, int is_qfe)\r\n{\r\nstruct device_node *dp = op->dev.of_node, *sbus_dp;\r\nstruct quattro *qp = NULL;\r\nstruct happy_meal *hp;\r\nstruct net_device *dev;\r\nint i, qfe_slot = -1;\r\nint err = -ENODEV;\r\nsbus_dp = op->dev.parent->of_node;\r\nif (strcmp(sbus_dp->name, "sbus") && strcmp(sbus_dp->name, "sbi"))\r\nreturn err;\r\nif (is_qfe) {\r\nqp = quattro_sbus_find(op);\r\nif (qp == NULL)\r\ngoto err_out;\r\nfor (qfe_slot = 0; qfe_slot < 4; qfe_slot++)\r\nif (qp->happy_meals[qfe_slot] == NULL)\r\nbreak;\r\nif (qfe_slot == 4)\r\ngoto err_out;\r\n}\r\nerr = -ENOMEM;\r\ndev = alloc_etherdev(sizeof(struct happy_meal));\r\nif (!dev)\r\ngoto err_out;\r\nSET_NETDEV_DEV(dev, &op->dev);\r\nif (hme_version_printed++ == 0)\r\nprintk(KERN_INFO "%s", version);\r\nfor (i = 0; i < 6; i++) {\r\nif (macaddr[i] != 0)\r\nbreak;\r\n}\r\nif (i < 6) {\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = macaddr[i];\r\nmacaddr[5]++;\r\n} else {\r\nconst unsigned char *addr;\r\nint len;\r\naddr = of_get_property(dp, "local-mac-address", &len);\r\nif (qfe_slot != -1 && addr && len == ETH_ALEN)\r\nmemcpy(dev->dev_addr, addr, ETH_ALEN);\r\nelse\r\nmemcpy(dev->dev_addr, idprom->id_ethaddr, ETH_ALEN);\r\n}\r\nhp = netdev_priv(dev);\r\nhp->happy_dev = op;\r\nhp->dma_dev = &op->dev;\r\nspin_lock_init(&hp->happy_lock);\r\nerr = -ENODEV;\r\nif (qp != NULL) {\r\nhp->qfe_parent = qp;\r\nhp->qfe_ent = qfe_slot;\r\nqp->happy_meals[qfe_slot] = dev;\r\n}\r\nhp->gregs = of_ioremap(&op->resource[0], 0,\r\nGREG_REG_SIZE, "HME Global Regs");\r\nif (!hp->gregs) {\r\nprintk(KERN_ERR "happymeal: Cannot map global registers.\n");\r\ngoto err_out_free_netdev;\r\n}\r\nhp->etxregs = of_ioremap(&op->resource[1], 0,\r\nETX_REG_SIZE, "HME TX Regs");\r\nif (!hp->etxregs) {\r\nprintk(KERN_ERR "happymeal: Cannot map MAC TX registers.\n");\r\ngoto err_out_iounmap;\r\n}\r\nhp->erxregs = of_ioremap(&op->resource[2], 0,\r\nERX_REG_SIZE, "HME RX Regs");\r\nif (!hp->erxregs) {\r\nprintk(KERN_ERR "happymeal: Cannot map MAC RX registers.\n");\r\ngoto err_out_iounmap;\r\n}\r\nhp->bigmacregs = of_ioremap(&op->resource[3], 0,\r\nBMAC_REG_SIZE, "HME BIGMAC Regs");\r\nif (!hp->bigmacregs) {\r\nprintk(KERN_ERR "happymeal: Cannot map BIGMAC registers.\n");\r\ngoto err_out_iounmap;\r\n}\r\nhp->tcvregs = of_ioremap(&op->resource[4], 0,\r\nTCVR_REG_SIZE, "HME Tranceiver Regs");\r\nif (!hp->tcvregs) {\r\nprintk(KERN_ERR "happymeal: Cannot map TCVR registers.\n");\r\ngoto err_out_iounmap;\r\n}\r\nhp->hm_revision = of_getintprop_default(dp, "hm-rev", 0xff);\r\nif (hp->hm_revision == 0xff)\r\nhp->hm_revision = 0xa0;\r\nif (hp->hm_revision == 0x20 || hp->hm_revision == 0x21)\r\nhp->happy_flags = HFLAG_20_21;\r\nelse if (hp->hm_revision != 0xa0)\r\nhp->happy_flags = HFLAG_NOT_A0;\r\nif (qp != NULL)\r\nhp->happy_flags |= HFLAG_QUATTRO;\r\nhp->happy_bursts = of_getintprop_default(sbus_dp,\r\n"burst-sizes", 0x00);\r\nhp->happy_block = dma_alloc_coherent(hp->dma_dev,\r\nPAGE_SIZE,\r\n&hp->hblock_dvma,\r\nGFP_ATOMIC);\r\nerr = -ENOMEM;\r\nif (!hp->happy_block)\r\ngoto err_out_iounmap;\r\nhp->linkcheck = 0;\r\nhp->timer_state = asleep;\r\nhp->timer_ticks = 0;\r\ninit_timer(&hp->happy_timer);\r\nhp->dev = dev;\r\ndev->netdev_ops = &hme_netdev_ops;\r\ndev->watchdog_timeo = 5*HZ;\r\ndev->ethtool_ops = &hme_ethtool_ops;\r\ndev->hw_features = NETIF_F_SG | NETIF_F_HW_CSUM;\r\ndev->features |= dev->hw_features | NETIF_F_RXCSUM;\r\nhp->irq = op->archdata.irqs[0];\r\n#if defined(CONFIG_SBUS) && defined(CONFIG_PCI)\r\nhp->read_desc32 = sbus_hme_read_desc32;\r\nhp->write_txd = sbus_hme_write_txd;\r\nhp->write_rxd = sbus_hme_write_rxd;\r\nhp->read32 = sbus_hme_read32;\r\nhp->write32 = sbus_hme_write32;\r\n#endif\r\nspin_lock_irq(&hp->happy_lock);\r\nhappy_meal_set_initial_advertisement(hp);\r\nspin_unlock_irq(&hp->happy_lock);\r\nerr = register_netdev(hp->dev);\r\nif (err) {\r\nprintk(KERN_ERR "happymeal: Cannot register net device, "\r\n"aborting.\n");\r\ngoto err_out_free_coherent;\r\n}\r\nplatform_set_drvdata(op, hp);\r\nif (qfe_slot != -1)\r\nprintk(KERN_INFO "%s: Quattro HME slot %d (SBUS) 10/100baseT Ethernet ",\r\ndev->name, qfe_slot);\r\nelse\r\nprintk(KERN_INFO "%s: HAPPY MEAL (SBUS) 10/100baseT Ethernet ",\r\ndev->name);\r\nprintk("%pM\n", dev->dev_addr);\r\nreturn 0;\r\nerr_out_free_coherent:\r\ndma_free_coherent(hp->dma_dev,\r\nPAGE_SIZE,\r\nhp->happy_block,\r\nhp->hblock_dvma);\r\nerr_out_iounmap:\r\nif (hp->gregs)\r\nof_iounmap(&op->resource[0], hp->gregs, GREG_REG_SIZE);\r\nif (hp->etxregs)\r\nof_iounmap(&op->resource[1], hp->etxregs, ETX_REG_SIZE);\r\nif (hp->erxregs)\r\nof_iounmap(&op->resource[2], hp->erxregs, ERX_REG_SIZE);\r\nif (hp->bigmacregs)\r\nof_iounmap(&op->resource[3], hp->bigmacregs, BMAC_REG_SIZE);\r\nif (hp->tcvregs)\r\nof_iounmap(&op->resource[4], hp->tcvregs, TCVR_REG_SIZE);\r\nif (qp)\r\nqp->happy_meals[qfe_slot] = NULL;\r\nerr_out_free_netdev:\r\nfree_netdev(dev);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic int is_quattro_p(struct pci_dev *pdev)\r\n{\r\nstruct pci_dev *busdev = pdev->bus->self;\r\nstruct pci_dev *this_pdev;\r\nint n_hmes;\r\nif (busdev == NULL ||\r\nbusdev->vendor != PCI_VENDOR_ID_DEC ||\r\nbusdev->device != PCI_DEVICE_ID_DEC_21153)\r\nreturn 0;\r\nn_hmes = 0;\r\nlist_for_each_entry(this_pdev, &pdev->bus->devices, bus_list) {\r\nif (this_pdev->vendor == PCI_VENDOR_ID_SUN &&\r\nthis_pdev->device == PCI_DEVICE_ID_SUN_HAPPYMEAL)\r\nn_hmes++;\r\n}\r\nif (n_hmes != 4)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int find_eth_addr_in_vpd(void __iomem *rom_base, int len, int index, unsigned char *dev_addr)\r\n{\r\nint this_offset;\r\nfor (this_offset = 0x20; this_offset < len; this_offset++) {\r\nvoid __iomem *p = rom_base + this_offset;\r\nif (readb(p + 0) != 0x90 ||\r\nreadb(p + 1) != 0x00 ||\r\nreadb(p + 2) != 0x09 ||\r\nreadb(p + 3) != 0x4e ||\r\nreadb(p + 4) != 0x41 ||\r\nreadb(p + 5) != 0x06)\r\ncontinue;\r\nthis_offset += 6;\r\np += 6;\r\nif (index == 0) {\r\nint i;\r\nfor (i = 0; i < 6; i++)\r\ndev_addr[i] = readb(p + i);\r\nreturn 1;\r\n}\r\nindex--;\r\n}\r\nreturn 0;\r\n}\r\nstatic void get_hme_mac_nonsparc(struct pci_dev *pdev, unsigned char *dev_addr)\r\n{\r\nsize_t size;\r\nvoid __iomem *p = pci_map_rom(pdev, &size);\r\nif (p) {\r\nint index = 0;\r\nint found;\r\nif (is_quattro_p(pdev))\r\nindex = PCI_SLOT(pdev->devfn);\r\nfound = readb(p) == 0x55 &&\r\nreadb(p + 1) == 0xaa &&\r\nfind_eth_addr_in_vpd(p, (64 * 1024), index, dev_addr);\r\npci_unmap_rom(pdev, p);\r\nif (found)\r\nreturn;\r\n}\r\ndev_addr[0] = 0x08;\r\ndev_addr[1] = 0x00;\r\ndev_addr[2] = 0x20;\r\nget_random_bytes(&dev_addr[3], 3);\r\n}\r\nstatic int happy_meal_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct quattro *qp = NULL;\r\n#ifdef CONFIG_SPARC\r\nstruct device_node *dp;\r\n#endif\r\nstruct happy_meal *hp;\r\nstruct net_device *dev;\r\nvoid __iomem *hpreg_base;\r\nunsigned long hpreg_res;\r\nint i, qfe_slot = -1;\r\nchar prom_name[64];\r\nint err;\r\n#ifdef CONFIG_SPARC\r\ndp = pci_device_to_OF_node(pdev);\r\nstrcpy(prom_name, dp->name);\r\n#else\r\nif (is_quattro_p(pdev))\r\nstrcpy(prom_name, "SUNW,qfe");\r\nelse\r\nstrcpy(prom_name, "SUNW,hme");\r\n#endif\r\nerr = -ENODEV;\r\nif (pci_enable_device(pdev))\r\ngoto err_out;\r\npci_set_master(pdev);\r\nif (!strcmp(prom_name, "SUNW,qfe") || !strcmp(prom_name, "qfe")) {\r\nqp = quattro_pci_find(pdev);\r\nif (qp == NULL)\r\ngoto err_out;\r\nfor (qfe_slot = 0; qfe_slot < 4; qfe_slot++)\r\nif (qp->happy_meals[qfe_slot] == NULL)\r\nbreak;\r\nif (qfe_slot == 4)\r\ngoto err_out;\r\n}\r\ndev = alloc_etherdev(sizeof(struct happy_meal));\r\nerr = -ENOMEM;\r\nif (!dev)\r\ngoto err_out;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nif (hme_version_printed++ == 0)\r\nprintk(KERN_INFO "%s", version);\r\nhp = netdev_priv(dev);\r\nhp->happy_dev = pdev;\r\nhp->dma_dev = &pdev->dev;\r\nspin_lock_init(&hp->happy_lock);\r\nif (qp != NULL) {\r\nhp->qfe_parent = qp;\r\nhp->qfe_ent = qfe_slot;\r\nqp->happy_meals[qfe_slot] = dev;\r\n}\r\nhpreg_res = pci_resource_start(pdev, 0);\r\nerr = -ENODEV;\r\nif ((pci_resource_flags(pdev, 0) & IORESOURCE_IO) != 0) {\r\nprintk(KERN_ERR "happymeal(PCI): Cannot find proper PCI device base address.\n");\r\ngoto err_out_clear_quattro;\r\n}\r\nif (pci_request_regions(pdev, DRV_NAME)) {\r\nprintk(KERN_ERR "happymeal(PCI): Cannot obtain PCI resources, "\r\n"aborting.\n");\r\ngoto err_out_clear_quattro;\r\n}\r\nif ((hpreg_base = ioremap(hpreg_res, 0x8000)) == NULL) {\r\nprintk(KERN_ERR "happymeal(PCI): Unable to remap card memory.\n");\r\ngoto err_out_free_res;\r\n}\r\nfor (i = 0; i < 6; i++) {\r\nif (macaddr[i] != 0)\r\nbreak;\r\n}\r\nif (i < 6) {\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = macaddr[i];\r\nmacaddr[5]++;\r\n} else {\r\n#ifdef CONFIG_SPARC\r\nconst unsigned char *addr;\r\nint len;\r\nif (qfe_slot != -1 &&\r\n(addr = of_get_property(dp, "local-mac-address", &len))\r\n!= NULL &&\r\nlen == 6) {\r\nmemcpy(dev->dev_addr, addr, ETH_ALEN);\r\n} else {\r\nmemcpy(dev->dev_addr, idprom->id_ethaddr, ETH_ALEN);\r\n}\r\n#else\r\nget_hme_mac_nonsparc(pdev, &dev->dev_addr[0]);\r\n#endif\r\n}\r\nhp->gregs = (hpreg_base + 0x0000UL);\r\nhp->etxregs = (hpreg_base + 0x2000UL);\r\nhp->erxregs = (hpreg_base + 0x4000UL);\r\nhp->bigmacregs = (hpreg_base + 0x6000UL);\r\nhp->tcvregs = (hpreg_base + 0x7000UL);\r\n#ifdef CONFIG_SPARC\r\nhp->hm_revision = of_getintprop_default(dp, "hm-rev", 0xff);\r\nif (hp->hm_revision == 0xff)\r\nhp->hm_revision = 0xc0 | (pdev->revision & 0x0f);\r\n#else\r\nhp->hm_revision = 0x20;\r\n#endif\r\nif (hp->hm_revision == 0x20 || hp->hm_revision == 0x21)\r\nhp->happy_flags = HFLAG_20_21;\r\nelse if (hp->hm_revision != 0xa0 && hp->hm_revision != 0xc0)\r\nhp->happy_flags = HFLAG_NOT_A0;\r\nif (qp != NULL)\r\nhp->happy_flags |= HFLAG_QUATTRO;\r\nhp->happy_flags |= HFLAG_PCI;\r\n#ifdef CONFIG_SPARC\r\nhp->happy_bursts = DMA_BURSTBITS;\r\n#endif\r\nhp->happy_block = dma_alloc_coherent(&pdev->dev, PAGE_SIZE,\r\n&hp->hblock_dvma, GFP_KERNEL);\r\nerr = -ENODEV;\r\nif (!hp->happy_block)\r\ngoto err_out_iounmap;\r\nhp->linkcheck = 0;\r\nhp->timer_state = asleep;\r\nhp->timer_ticks = 0;\r\ninit_timer(&hp->happy_timer);\r\nhp->irq = pdev->irq;\r\nhp->dev = dev;\r\ndev->netdev_ops = &hme_netdev_ops;\r\ndev->watchdog_timeo = 5*HZ;\r\ndev->ethtool_ops = &hme_ethtool_ops;\r\ndev->hw_features = NETIF_F_SG | NETIF_F_HW_CSUM;\r\ndev->features |= dev->hw_features | NETIF_F_RXCSUM;\r\n#if defined(CONFIG_SBUS) && defined(CONFIG_PCI)\r\nhp->read_desc32 = pci_hme_read_desc32;\r\nhp->write_txd = pci_hme_write_txd;\r\nhp->write_rxd = pci_hme_write_rxd;\r\nhp->read32 = pci_hme_read32;\r\nhp->write32 = pci_hme_write32;\r\n#endif\r\nspin_lock_irq(&hp->happy_lock);\r\nhappy_meal_set_initial_advertisement(hp);\r\nspin_unlock_irq(&hp->happy_lock);\r\nerr = register_netdev(hp->dev);\r\nif (err) {\r\nprintk(KERN_ERR "happymeal(PCI): Cannot register net device, "\r\n"aborting.\n");\r\ngoto err_out_iounmap;\r\n}\r\npci_set_drvdata(pdev, hp);\r\nif (!qfe_slot) {\r\nstruct pci_dev *qpdev = qp->quattro_dev;\r\nprom_name[0] = 0;\r\nif (!strncmp(dev->name, "eth", 3)) {\r\nint i = simple_strtoul(dev->name + 3, NULL, 10);\r\nsprintf(prom_name, "-%d", i + 3);\r\n}\r\nprintk(KERN_INFO "%s%s: Quattro HME (PCI/CheerIO) 10/100baseT Ethernet ", dev->name, prom_name);\r\nif (qpdev->vendor == PCI_VENDOR_ID_DEC &&\r\nqpdev->device == PCI_DEVICE_ID_DEC_21153)\r\nprintk("DEC 21153 PCI Bridge\n");\r\nelse\r\nprintk("unknown bridge %04x.%04x\n",\r\nqpdev->vendor, qpdev->device);\r\n}\r\nif (qfe_slot != -1)\r\nprintk(KERN_INFO "%s: Quattro HME slot %d (PCI/CheerIO) 10/100baseT Ethernet ",\r\ndev->name, qfe_slot);\r\nelse\r\nprintk(KERN_INFO "%s: HAPPY MEAL (PCI/CheerIO) 10/100BaseT Ethernet ",\r\ndev->name);\r\nprintk("%pM\n", dev->dev_addr);\r\nreturn 0;\r\nerr_out_iounmap:\r\niounmap(hp->gregs);\r\nerr_out_free_res:\r\npci_release_regions(pdev);\r\nerr_out_clear_quattro:\r\nif (qp != NULL)\r\nqp->happy_meals[qfe_slot] = NULL;\r\nfree_netdev(dev);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic void happy_meal_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct happy_meal *hp = pci_get_drvdata(pdev);\r\nstruct net_device *net_dev = hp->dev;\r\nunregister_netdev(net_dev);\r\ndma_free_coherent(hp->dma_dev, PAGE_SIZE,\r\nhp->happy_block, hp->hblock_dvma);\r\niounmap(hp->gregs);\r\npci_release_regions(hp->happy_dev);\r\nfree_netdev(net_dev);\r\n}\r\nstatic int __init happy_meal_pci_init(void)\r\n{\r\nreturn pci_register_driver(&hme_pci_driver);\r\n}\r\nstatic void happy_meal_pci_exit(void)\r\n{\r\npci_unregister_driver(&hme_pci_driver);\r\nwhile (qfe_pci_list) {\r\nstruct quattro *qfe = qfe_pci_list;\r\nstruct quattro *next = qfe->next;\r\nkfree(qfe);\r\nqfe_pci_list = next;\r\n}\r\n}\r\nstatic int hme_sbus_probe(struct platform_device *op)\r\n{\r\nconst struct of_device_id *match;\r\nstruct device_node *dp = op->dev.of_node;\r\nconst char *model = of_get_property(dp, "model", NULL);\r\nint is_qfe;\r\nmatch = of_match_device(hme_sbus_match, &op->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nis_qfe = (match->data != NULL);\r\nif (!is_qfe && model && !strcmp(model, "SUNW,sbus-qfe"))\r\nis_qfe = 1;\r\nreturn happy_meal_sbus_probe_one(op, is_qfe);\r\n}\r\nstatic int hme_sbus_remove(struct platform_device *op)\r\n{\r\nstruct happy_meal *hp = platform_get_drvdata(op);\r\nstruct net_device *net_dev = hp->dev;\r\nunregister_netdev(net_dev);\r\nof_iounmap(&op->resource[0], hp->gregs, GREG_REG_SIZE);\r\nof_iounmap(&op->resource[1], hp->etxregs, ETX_REG_SIZE);\r\nof_iounmap(&op->resource[2], hp->erxregs, ERX_REG_SIZE);\r\nof_iounmap(&op->resource[3], hp->bigmacregs, BMAC_REG_SIZE);\r\nof_iounmap(&op->resource[4], hp->tcvregs, TCVR_REG_SIZE);\r\ndma_free_coherent(hp->dma_dev,\r\nPAGE_SIZE,\r\nhp->happy_block,\r\nhp->hblock_dvma);\r\nfree_netdev(net_dev);\r\nreturn 0;\r\n}\r\nstatic int __init happy_meal_sbus_init(void)\r\n{\r\nint err;\r\nerr = platform_driver_register(&hme_sbus_driver);\r\nif (!err)\r\nerr = quattro_sbus_register_irqs();\r\nreturn err;\r\n}\r\nstatic void happy_meal_sbus_exit(void)\r\n{\r\nplatform_driver_unregister(&hme_sbus_driver);\r\nquattro_sbus_free_irqs();\r\nwhile (qfe_sbus_list) {\r\nstruct quattro *qfe = qfe_sbus_list;\r\nstruct quattro *next = qfe->next;\r\nkfree(qfe);\r\nqfe_sbus_list = next;\r\n}\r\n}\r\nstatic int __init happy_meal_probe(void)\r\n{\r\nint err = 0;\r\n#ifdef CONFIG_SBUS\r\nerr = happy_meal_sbus_init();\r\n#endif\r\n#ifdef CONFIG_PCI\r\nif (!err) {\r\nerr = happy_meal_pci_init();\r\n#ifdef CONFIG_SBUS\r\nif (err)\r\nhappy_meal_sbus_exit();\r\n#endif\r\n}\r\n#endif\r\nreturn err;\r\n}\r\nstatic void __exit happy_meal_exit(void)\r\n{\r\n#ifdef CONFIG_SBUS\r\nhappy_meal_sbus_exit();\r\n#endif\r\n#ifdef CONFIG_PCI\r\nhappy_meal_pci_exit();\r\n#endif\r\n}
