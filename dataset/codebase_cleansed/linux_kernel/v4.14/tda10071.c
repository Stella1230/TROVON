static int tda10071_wr_reg_mask(struct tda10071_dev *dev,\r\nu8 reg, u8 val, u8 mask)\r\n{\r\nint ret;\r\nu8 tmp;\r\nif (mask != 0xff) {\r\nret = regmap_bulk_read(dev->regmap, reg, &tmp, 1);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn regmap_bulk_write(dev->regmap, reg, &val, 1);\r\n}\r\nstatic int tda10071_cmd_execute(struct tda10071_dev *dev,\r\nstruct tda10071_cmd *cmd)\r\n{\r\nstruct i2c_client *client = dev->client;\r\nint ret, i;\r\nunsigned int uitmp;\r\nif (!dev->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\nmutex_lock(&dev->cmd_execute_mutex);\r\nret = regmap_bulk_write(dev->regmap, 0x00, cmd->args, cmd->len);\r\nif (ret)\r\ngoto error_mutex_unlock;\r\nret = regmap_write(dev->regmap, 0x1f, 1);\r\nif (ret)\r\ngoto error_mutex_unlock;\r\nfor (i = 1000, uitmp = 1; i && uitmp; i--) {\r\nret = regmap_read(dev->regmap, 0x1f, &uitmp);\r\nif (ret)\r\ngoto error_mutex_unlock;\r\nusleep_range(200, 5000);\r\n}\r\nmutex_unlock(&dev->cmd_execute_mutex);\r\ndev_dbg(&client->dev, "loop=%d\n", i);\r\nif (i == 0) {\r\nret = -ETIMEDOUT;\r\ngoto error;\r\n}\r\nreturn ret;\r\nerror_mutex_unlock:\r\nmutex_unlock(&dev->cmd_execute_mutex);\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_set_tone(struct dvb_frontend *fe,\r\nenum fe_sec_tone_mode fe_sec_tone_mode)\r\n{\r\nstruct tda10071_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct tda10071_cmd cmd;\r\nint ret;\r\nu8 tone;\r\nif (!dev->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\ndev_dbg(&client->dev, "tone_mode=%d\n", fe_sec_tone_mode);\r\nswitch (fe_sec_tone_mode) {\r\ncase SEC_TONE_ON:\r\ntone = 1;\r\nbreak;\r\ncase SEC_TONE_OFF:\r\ntone = 0;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid fe_sec_tone_mode\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ncmd.args[0] = CMD_LNB_PCB_CONFIG;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = 0x00;\r\ncmd.args[3] = 0x00;\r\ncmd.args[4] = tone;\r\ncmd.len = 5;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage fe_sec_voltage)\r\n{\r\nstruct tda10071_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct tda10071_cmd cmd;\r\nint ret;\r\nu8 voltage;\r\nif (!dev->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\ndev_dbg(&client->dev, "voltage=%d\n", fe_sec_voltage);\r\nswitch (fe_sec_voltage) {\r\ncase SEC_VOLTAGE_13:\r\nvoltage = 0;\r\nbreak;\r\ncase SEC_VOLTAGE_18:\r\nvoltage = 1;\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\nvoltage = 0;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid fe_sec_voltage\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ncmd.args[0] = CMD_LNB_SET_DC_LEVEL;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = voltage;\r\ncmd.len = 3;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_diseqc_send_master_cmd(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *diseqc_cmd)\r\n{\r\nstruct tda10071_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct tda10071_cmd cmd;\r\nint ret, i;\r\nunsigned int uitmp;\r\nif (!dev->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\ndev_dbg(&client->dev, "msg_len=%d\n", diseqc_cmd->msg_len);\r\nif (diseqc_cmd->msg_len < 3 || diseqc_cmd->msg_len > 6) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nfor (i = 500, uitmp = 0; i && !uitmp; i--) {\r\nret = regmap_read(dev->regmap, 0x47, &uitmp);\r\nif (ret)\r\ngoto error;\r\nuitmp = (uitmp >> 0) & 1;\r\nusleep_range(10000, 20000);\r\n}\r\ndev_dbg(&client->dev, "loop=%d\n", i);\r\nif (i == 0) {\r\nret = -ETIMEDOUT;\r\ngoto error;\r\n}\r\nret = regmap_update_bits(dev->regmap, 0x47, 0x01, 0x00);\r\nif (ret)\r\ngoto error;\r\ncmd.args[0] = CMD_LNB_SEND_DISEQC;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = 0;\r\ncmd.args[3] = 0;\r\ncmd.args[4] = 2;\r\ncmd.args[5] = 0;\r\ncmd.args[6] = diseqc_cmd->msg_len;\r\nmemcpy(&cmd.args[7], diseqc_cmd->msg, diseqc_cmd->msg_len);\r\ncmd.len = 7 + diseqc_cmd->msg_len;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_diseqc_recv_slave_reply(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_slave_reply *reply)\r\n{\r\nstruct tda10071_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct tda10071_cmd cmd;\r\nint ret, i;\r\nunsigned int uitmp;\r\nif (!dev->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\ndev_dbg(&client->dev, "\n");\r\nfor (i = 500, uitmp = 0; i && !uitmp; i--) {\r\nret = regmap_read(dev->regmap, 0x47, &uitmp);\r\nif (ret)\r\ngoto error;\r\nuitmp = (uitmp >> 1) & 1;\r\nusleep_range(10000, 20000);\r\n}\r\ndev_dbg(&client->dev, "loop=%d\n", i);\r\nif (i == 0) {\r\nret = -ETIMEDOUT;\r\ngoto error;\r\n}\r\nret = regmap_read(dev->regmap, 0x46, &uitmp);\r\nif (ret)\r\ngoto error;\r\nreply->msg_len = uitmp & 0x1f;\r\nif (reply->msg_len > sizeof(reply->msg))\r\nreply->msg_len = sizeof(reply->msg);\r\ncmd.args[0] = CMD_LNB_UPDATE_REPLY;\r\ncmd.args[1] = 0;\r\ncmd.len = 2;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\nret = regmap_bulk_read(dev->regmap, cmd.len, reply->msg,\r\nreply->msg_len);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_diseqc_send_burst(struct dvb_frontend *fe,\r\nenum fe_sec_mini_cmd fe_sec_mini_cmd)\r\n{\r\nstruct tda10071_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct tda10071_cmd cmd;\r\nint ret, i;\r\nunsigned int uitmp;\r\nu8 burst;\r\nif (!dev->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\ndev_dbg(&client->dev, "fe_sec_mini_cmd=%d\n", fe_sec_mini_cmd);\r\nswitch (fe_sec_mini_cmd) {\r\ncase SEC_MINI_A:\r\nburst = 0;\r\nbreak;\r\ncase SEC_MINI_B:\r\nburst = 1;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid fe_sec_mini_cmd\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nfor (i = 500, uitmp = 0; i && !uitmp; i--) {\r\nret = regmap_read(dev->regmap, 0x47, &uitmp);\r\nif (ret)\r\ngoto error;\r\nuitmp = (uitmp >> 0) & 1;\r\nusleep_range(10000, 20000);\r\n}\r\ndev_dbg(&client->dev, "loop=%d\n", i);\r\nif (i == 0) {\r\nret = -ETIMEDOUT;\r\ngoto error;\r\n}\r\nret = regmap_update_bits(dev->regmap, 0x47, 0x01, 0x00);\r\nif (ret)\r\ngoto error;\r\ncmd.args[0] = CMD_LNB_SEND_TONEBURST;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = burst;\r\ncmd.len = 3;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct tda10071_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct tda10071_cmd cmd;\r\nint ret;\r\nunsigned int uitmp;\r\nu8 buf[8];\r\n*status = 0;\r\nif (!dev->warm) {\r\nret = 0;\r\ngoto error;\r\n}\r\nret = regmap_read(dev->regmap, 0x39, &uitmp);\r\nif (ret)\r\ngoto error;\r\nif (uitmp & 0x02)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;\r\nif (uitmp & 0x04)\r\n*status |= FE_HAS_VITERBI;\r\nif (uitmp & 0x08)\r\n*status |= FE_HAS_SYNC | FE_HAS_LOCK;\r\ndev->fe_status = *status;\r\nif (dev->fe_status & FE_HAS_SIGNAL) {\r\ncmd.args[0] = CMD_GET_AGCACC;\r\ncmd.args[1] = 0;\r\ncmd.len = 2;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\nret = regmap_read(dev->regmap, 0x50, &uitmp);\r\nif (ret)\r\ngoto error;\r\nc->strength.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->strength.stat[0].svalue = (int) (uitmp - 256) * 1000;\r\n} else {\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (dev->fe_status & FE_HAS_VITERBI) {\r\nret = regmap_bulk_read(dev->regmap, 0x3a, buf, 2);\r\nif (ret)\r\ngoto error;\r\nc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->cnr.stat[0].svalue = (buf[0] << 8 | buf[1] << 0) * 100;\r\n} else {\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (dev->fe_status & FE_HAS_LOCK) {\r\nu8 delivery_system, reg, len;\r\nswitch (dev->delivery_system) {\r\ncase SYS_DVBS:\r\nreg = 0x4c;\r\nlen = 8;\r\ndelivery_system = 1;\r\nbreak;\r\ncase SYS_DVBS2:\r\nreg = 0x4d;\r\nlen = 4;\r\ndelivery_system = 0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = regmap_read(dev->regmap, reg, &uitmp);\r\nif (ret)\r\ngoto error;\r\nif (dev->meas_count == uitmp) {\r\ndev_dbg(&client->dev, "meas not ready=%02x\n", uitmp);\r\nret = 0;\r\ngoto error;\r\n} else {\r\ndev->meas_count = uitmp;\r\n}\r\ncmd.args[0] = CMD_BER_UPDATE_COUNTERS;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = delivery_system;\r\ncmd.len = 3;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\nret = regmap_bulk_read(dev->regmap, cmd.len, buf, len);\r\nif (ret)\r\ngoto error;\r\nif (dev->delivery_system == SYS_DVBS) {\r\ndev->dvbv3_ber = buf[0] << 24 | buf[1] << 16 |\r\nbuf[2] << 8 | buf[3] << 0;\r\ndev->post_bit_error += buf[0] << 24 | buf[1] << 16 |\r\nbuf[2] << 8 | buf[3] << 0;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue = dev->post_bit_error;\r\ndev->block_error += buf[4] << 8 | buf[5] << 0;\r\nc->block_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_error.stat[0].uvalue = dev->block_error;\r\n} else {\r\ndev->dvbv3_ber = buf[0] << 8 | buf[1] << 0;\r\ndev->post_bit_error += buf[0] << 8 | buf[1] << 0;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue = dev->post_bit_error;\r\nc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\n} else {\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nreturn ret;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nif (c->cnr.stat[0].scale == FE_SCALE_DECIBEL)\r\n*snr = div_s64(c->cnr.stat[0].svalue, 100);\r\nelse\r\n*snr = 0;\r\nreturn 0;\r\n}\r\nstatic int tda10071_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nunsigned int uitmp;\r\nif (c->strength.stat[0].scale == FE_SCALE_DECIBEL) {\r\nuitmp = div_s64(c->strength.stat[0].svalue, 1000) + 256;\r\nuitmp = clamp(uitmp, 181U, 236U);\r\n*strength = (uitmp-181) * 0xffff / (236-181);\r\n} else {\r\n*strength = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda10071_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct tda10071_dev *dev = fe->demodulator_priv;\r\n*ber = dev->dvbv3_ber;\r\nreturn 0;\r\n}\r\nstatic int tda10071_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nif (c->block_error.stat[0].scale == FE_SCALE_COUNTER)\r\n*ucblocks = c->block_error.stat[0].uvalue;\r\nelse\r\n*ucblocks = 0;\r\nreturn 0;\r\n}\r\nstatic int tda10071_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct tda10071_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct tda10071_cmd cmd;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nu8 mode, rolloff, pilot, inversion, div;\r\nenum fe_modulation modulation;\r\ndev_dbg(&client->dev,\r\n"delivery_system=%d modulation=%d frequency=%u symbol_rate=%d inversion=%d pilot=%d rolloff=%d\n",\r\nc->delivery_system, c->modulation, c->frequency, c->symbol_rate,\r\nc->inversion, c->pilot, c->rolloff);\r\ndev->delivery_system = SYS_UNDEFINED;\r\nif (!dev->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\nswitch (c->inversion) {\r\ncase INVERSION_OFF:\r\ninversion = 1;\r\nbreak;\r\ncase INVERSION_ON:\r\ninversion = 0;\r\nbreak;\r\ncase INVERSION_AUTO:\r\ninversion = 3;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid inversion\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nmodulation = QPSK;\r\nrolloff = 0;\r\npilot = 2;\r\nbreak;\r\ncase SYS_DVBS2:\r\nmodulation = c->modulation;\r\nswitch (c->rolloff) {\r\ncase ROLLOFF_20:\r\nrolloff = 2;\r\nbreak;\r\ncase ROLLOFF_25:\r\nrolloff = 1;\r\nbreak;\r\ncase ROLLOFF_35:\r\nrolloff = 0;\r\nbreak;\r\ncase ROLLOFF_AUTO:\r\ndefault:\r\ndev_dbg(&client->dev, "invalid rolloff\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nswitch (c->pilot) {\r\ncase PILOT_OFF:\r\npilot = 0;\r\nbreak;\r\ncase PILOT_ON:\r\npilot = 1;\r\nbreak;\r\ncase PILOT_AUTO:\r\npilot = 2;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid pilot\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid delivery_system\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nfor (i = 0, mode = 0xff; i < ARRAY_SIZE(TDA10071_MODCOD); i++) {\r\nif (c->delivery_system == TDA10071_MODCOD[i].delivery_system &&\r\nmodulation == TDA10071_MODCOD[i].modulation &&\r\nc->fec_inner == TDA10071_MODCOD[i].fec) {\r\nmode = TDA10071_MODCOD[i].val;\r\ndev_dbg(&client->dev, "mode found=%02x\n", mode);\r\nbreak;\r\n}\r\n}\r\nif (mode == 0xff) {\r\ndev_dbg(&client->dev, "invalid parameter combination\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (c->symbol_rate <= 5000000)\r\ndiv = 14;\r\nelse\r\ndiv = 4;\r\nret = regmap_write(dev->regmap, 0x81, div);\r\nif (ret)\r\ngoto error;\r\nret = regmap_write(dev->regmap, 0xe3, div);\r\nif (ret)\r\ngoto error;\r\ncmd.args[0] = CMD_CHANGE_CHANNEL;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = mode;\r\ncmd.args[3] = (c->frequency >> 16) & 0xff;\r\ncmd.args[4] = (c->frequency >> 8) & 0xff;\r\ncmd.args[5] = (c->frequency >> 0) & 0xff;\r\ncmd.args[6] = ((c->symbol_rate / 1000) >> 8) & 0xff;\r\ncmd.args[7] = ((c->symbol_rate / 1000) >> 0) & 0xff;\r\ncmd.args[8] = (tda10071_ops.info.frequency_tolerance >> 8) & 0xff;\r\ncmd.args[9] = (tda10071_ops.info.frequency_tolerance >> 0) & 0xff;\r\ncmd.args[10] = rolloff;\r\ncmd.args[11] = inversion;\r\ncmd.args[12] = pilot;\r\ncmd.args[13] = 0x00;\r\ncmd.args[14] = 0x00;\r\ncmd.len = 15;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\ndev->delivery_system = c->delivery_system;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *c)\r\n{\r\nstruct tda10071_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret, i;\r\nu8 buf[5], tmp;\r\nif (!dev->warm || !(dev->fe_status & FE_HAS_LOCK)) {\r\nret = 0;\r\ngoto error;\r\n}\r\nret = regmap_bulk_read(dev->regmap, 0x30, buf, 5);\r\nif (ret)\r\ngoto error;\r\ntmp = buf[0] & 0x3f;\r\nfor (i = 0; i < ARRAY_SIZE(TDA10071_MODCOD); i++) {\r\nif (tmp == TDA10071_MODCOD[i].val) {\r\nc->modulation = TDA10071_MODCOD[i].modulation;\r\nc->fec_inner = TDA10071_MODCOD[i].fec;\r\nc->delivery_system = TDA10071_MODCOD[i].delivery_system;\r\n}\r\n}\r\nswitch ((buf[1] >> 0) & 0x01) {\r\ncase 0:\r\nc->inversion = INVERSION_ON;\r\nbreak;\r\ncase 1:\r\nc->inversion = INVERSION_OFF;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 7) & 0x01) {\r\ncase 0:\r\nc->pilot = PILOT_OFF;\r\nbreak;\r\ncase 1:\r\nc->pilot = PILOT_ON;\r\nbreak;\r\n}\r\nc->frequency = (buf[2] << 16) | (buf[3] << 8) | (buf[4] << 0);\r\nret = regmap_bulk_read(dev->regmap, 0x52, buf, 3);\r\nif (ret)\r\ngoto error;\r\nc->symbol_rate = ((buf[0] << 16) | (buf[1] << 8) | (buf[2] << 0)) * 1000;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_init(struct dvb_frontend *fe)\r\n{\r\nstruct tda10071_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct tda10071_cmd cmd;\r\nint ret, i, len, remaining, fw_size;\r\nunsigned int uitmp;\r\nconst struct firmware *fw;\r\nu8 *fw_file = TDA10071_FIRMWARE;\r\nu8 tmp, buf[4];\r\nstruct tda10071_reg_val_mask tab[] = {\r\n{ 0xcd, 0x00, 0x07 },\r\n{ 0x80, 0x00, 0x02 },\r\n{ 0xcd, 0x00, 0xc0 },\r\n{ 0xce, 0x00, 0x1b },\r\n{ 0x9d, 0x00, 0x01 },\r\n{ 0x9d, 0x00, 0x02 },\r\n{ 0x9e, 0x00, 0x01 },\r\n{ 0x87, 0x00, 0x80 },\r\n{ 0xce, 0x00, 0x08 },\r\n{ 0xce, 0x00, 0x10 },\r\n};\r\nstruct tda10071_reg_val_mask tab2[] = {\r\n{ 0xf1, 0x70, 0xff },\r\n{ 0x88, dev->pll_multiplier, 0x3f },\r\n{ 0x89, 0x00, 0x10 },\r\n{ 0x89, 0x10, 0x10 },\r\n{ 0xc0, 0x01, 0x01 },\r\n{ 0xc0, 0x00, 0x01 },\r\n{ 0xe0, 0xff, 0xff },\r\n{ 0xe0, 0x00, 0xff },\r\n{ 0x96, 0x1e, 0x7e },\r\n{ 0x8b, 0x08, 0x08 },\r\n{ 0x8b, 0x00, 0x08 },\r\n{ 0x8f, 0x1a, 0x7e },\r\n{ 0x8c, 0x68, 0xff },\r\n{ 0x8d, 0x08, 0xff },\r\n{ 0x8e, 0x4c, 0xff },\r\n{ 0x8f, 0x01, 0x01 },\r\n{ 0x8b, 0x04, 0x04 },\r\n{ 0x8b, 0x00, 0x04 },\r\n{ 0x87, 0x05, 0x07 },\r\n{ 0x80, 0x00, 0x20 },\r\n{ 0xc8, 0x01, 0xff },\r\n{ 0xb4, 0x47, 0xff },\r\n{ 0xb5, 0x9c, 0xff },\r\n{ 0xb6, 0x7d, 0xff },\r\n{ 0xba, 0x00, 0x03 },\r\n{ 0xb7, 0x47, 0xff },\r\n{ 0xb8, 0x9c, 0xff },\r\n{ 0xb9, 0x7d, 0xff },\r\n{ 0xba, 0x00, 0x0c },\r\n{ 0xc8, 0x00, 0xff },\r\n{ 0xcd, 0x00, 0x04 },\r\n{ 0xcd, 0x00, 0x20 },\r\n{ 0xe8, 0x02, 0xff },\r\n{ 0xcf, 0x20, 0xff },\r\n{ 0x9b, 0xd7, 0xff },\r\n{ 0x9a, 0x01, 0x03 },\r\n{ 0xa8, 0x05, 0x0f },\r\n{ 0xa8, 0x65, 0xf0 },\r\n{ 0xa6, 0xa0, 0xf0 },\r\n{ 0x9d, 0x50, 0xfc },\r\n{ 0x9e, 0x20, 0xe0 },\r\n{ 0xa3, 0x1c, 0x7c },\r\n{ 0xd5, 0x03, 0x03 },\r\n};\r\nif (dev->warm) {\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = tda10071_wr_reg_mask(dev, tab[i].reg,\r\ntab[i].val, tab[i].mask);\r\nif (ret)\r\ngoto error;\r\n}\r\ncmd.args[0] = CMD_SET_SLEEP_MODE;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = 0;\r\ncmd.len = 3;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\n} else {\r\nret = request_firmware(&fw, fw_file, &client->dev);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"did not find the firmware file. (%s) Please see linux/Documentation/dvb/ for more details on firmware-problems. (%d)\n",\r\nfw_file, ret);\r\ngoto error;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(tab2); i++) {\r\nret = tda10071_wr_reg_mask(dev, tab2[i].reg,\r\ntab2[i].val, tab2[i].mask);\r\nif (ret)\r\ngoto error_release_firmware;\r\n}\r\nret = regmap_write(dev->regmap, 0xe0, 0x7f);\r\nif (ret)\r\ngoto error_release_firmware;\r\nret = regmap_write(dev->regmap, 0xf7, 0x81);\r\nif (ret)\r\ngoto error_release_firmware;\r\nret = regmap_write(dev->regmap, 0xf8, 0x00);\r\nif (ret)\r\ngoto error_release_firmware;\r\nret = regmap_write(dev->regmap, 0xf9, 0x00);\r\nif (ret)\r\ngoto error_release_firmware;\r\ndev_info(&client->dev,\r\n"found a '%s' in cold state, will try to load a firmware\n",\r\ntda10071_ops.info.name);\r\ndev_info(&client->dev, "downloading firmware from file '%s'\n",\r\nfw_file);\r\nfw_size = fw->size - 1;\r\nfor (remaining = fw_size; remaining > 0;\r\nremaining -= (dev->i2c_wr_max - 1)) {\r\nlen = remaining;\r\nif (len > (dev->i2c_wr_max - 1))\r\nlen = (dev->i2c_wr_max - 1);\r\nret = regmap_bulk_write(dev->regmap, 0xfa,\r\n(u8 *) &fw->data[fw_size - remaining], len);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"firmware download failed=%d\n", ret);\r\ngoto error_release_firmware;\r\n}\r\n}\r\nrelease_firmware(fw);\r\nret = regmap_write(dev->regmap, 0xf7, 0x0c);\r\nif (ret)\r\ngoto error;\r\nret = regmap_write(dev->regmap, 0xe0, 0x00);\r\nif (ret)\r\ngoto error;\r\nmsleep(250);\r\nret = regmap_read(dev->regmap, 0x51, &uitmp);\r\nif (ret)\r\ngoto error;\r\nif (uitmp) {\r\ndev_info(&client->dev, "firmware did not run\n");\r\nret = -EFAULT;\r\ngoto error;\r\n} else {\r\ndev->warm = true;\r\n}\r\ncmd.args[0] = CMD_GET_FW_VERSION;\r\ncmd.len = 1;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\nret = regmap_bulk_read(dev->regmap, cmd.len, buf, 4);\r\nif (ret)\r\ngoto error;\r\ndev_info(&client->dev, "firmware version %d.%d.%d.%d\n",\r\nbuf[0], buf[1], buf[2], buf[3]);\r\ndev_info(&client->dev, "found a '%s' in warm state\n",\r\ntda10071_ops.info.name);\r\nret = regmap_bulk_read(dev->regmap, 0x81, buf, 2);\r\nif (ret)\r\ngoto error;\r\ncmd.args[0] = CMD_DEMOD_INIT;\r\ncmd.args[1] = ((dev->clk / 1000) >> 8) & 0xff;\r\ncmd.args[2] = ((dev->clk / 1000) >> 0) & 0xff;\r\ncmd.args[3] = buf[0];\r\ncmd.args[4] = buf[1];\r\ncmd.args[5] = dev->pll_multiplier;\r\ncmd.args[6] = dev->spec_inv;\r\ncmd.args[7] = 0x00;\r\ncmd.len = 8;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\nif (dev->tuner_i2c_addr)\r\ntmp = dev->tuner_i2c_addr;\r\nelse\r\ntmp = 0x14;\r\ncmd.args[0] = CMD_TUNER_INIT;\r\ncmd.args[1] = 0x00;\r\ncmd.args[2] = 0x00;\r\ncmd.args[3] = 0x00;\r\ncmd.args[4] = 0x00;\r\ncmd.args[5] = tmp;\r\ncmd.args[6] = 0x00;\r\ncmd.args[7] = 0x03;\r\ncmd.args[8] = 0x02;\r\ncmd.args[9] = 0x02;\r\ncmd.args[10] = 0x00;\r\ncmd.args[11] = 0x00;\r\ncmd.args[12] = 0x00;\r\ncmd.args[13] = 0x00;\r\ncmd.args[14] = 0x00;\r\ncmd.len = 15;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\ncmd.args[0] = CMD_MPEG_CONFIG;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = dev->ts_mode;\r\ncmd.args[3] = 0x00;\r\ncmd.args[4] = 0x04;\r\ncmd.args[5] = 0x00;\r\ncmd.len = 6;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\nret = regmap_update_bits(dev->regmap, 0xf0, 0x01, 0x01);\r\nif (ret)\r\ngoto error;\r\ncmd.args[0] = CMD_LNB_CONFIG;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = 150;\r\ncmd.args[3] = 3;\r\ncmd.args[4] = 22;\r\ncmd.args[5] = 1;\r\ncmd.args[6] = 1;\r\ncmd.args[7] = 30;\r\ncmd.args[8] = 30;\r\ncmd.args[9] = 30;\r\ncmd.args[10] = 30;\r\ncmd.len = 11;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\ncmd.args[0] = CMD_BER_CONTROL;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = 14;\r\ncmd.args[3] = 14;\r\ncmd.len = 4;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\n}\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_error.len = 1;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_error.len = 1;\r\nc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nreturn ret;\r\nerror_release_firmware:\r\nrelease_firmware(fw);\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct tda10071_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct tda10071_cmd cmd;\r\nint ret, i;\r\nstruct tda10071_reg_val_mask tab[] = {\r\n{ 0xcd, 0x07, 0x07 },\r\n{ 0x80, 0x02, 0x02 },\r\n{ 0xcd, 0xc0, 0xc0 },\r\n{ 0xce, 0x1b, 0x1b },\r\n{ 0x9d, 0x01, 0x01 },\r\n{ 0x9d, 0x02, 0x02 },\r\n{ 0x9e, 0x01, 0x01 },\r\n{ 0x87, 0x80, 0x80 },\r\n{ 0xce, 0x08, 0x08 },\r\n{ 0xce, 0x10, 0x10 },\r\n};\r\nif (!dev->warm) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\ncmd.args[0] = CMD_SET_SLEEP_MODE;\r\ncmd.args[1] = 0;\r\ncmd.args[2] = 1;\r\ncmd.len = 3;\r\nret = tda10071_cmd_execute(dev, &cmd);\r\nif (ret)\r\ngoto error;\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = tda10071_wr_reg_mask(dev, tab[i].reg, tab[i].val,\r\ntab[i].mask);\r\nif (ret)\r\ngoto error;\r\n}\r\nreturn ret;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\ns->min_delay_ms = 8000;\r\ns->step_size = 0;\r\ns->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic struct dvb_frontend *tda10071_get_dvb_frontend(struct i2c_client *client)\r\n{\r\nstruct tda10071_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nreturn &dev->fe;\r\n}\r\nstatic int tda10071_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tda10071_dev *dev;\r\nstruct tda10071_platform_data *pdata = client->dev.platform_data;\r\nint ret;\r\nunsigned int uitmp;\r\nstatic const struct regmap_config regmap_config = {\r\n.reg_bits = 8,\r\n.val_bits = 8,\r\n};\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev->client = client;\r\nmutex_init(&dev->cmd_execute_mutex);\r\ndev->clk = pdata->clk;\r\ndev->i2c_wr_max = pdata->i2c_wr_max;\r\ndev->ts_mode = pdata->ts_mode;\r\ndev->spec_inv = pdata->spec_inv;\r\ndev->pll_multiplier = pdata->pll_multiplier;\r\ndev->tuner_i2c_addr = pdata->tuner_i2c_addr;\r\ndev->regmap = devm_regmap_init_i2c(client, &regmap_config);\r\nif (IS_ERR(dev->regmap)) {\r\nret = PTR_ERR(dev->regmap);\r\ngoto err_kfree;\r\n}\r\nret = regmap_read(dev->regmap, 0xff, &uitmp);\r\nif (ret)\r\ngoto err_kfree;\r\nif (uitmp != 0x0f) {\r\nret = -ENODEV;\r\ngoto err_kfree;\r\n}\r\nret = regmap_read(dev->regmap, 0xdd, &uitmp);\r\nif (ret)\r\ngoto err_kfree;\r\nif (uitmp != 0x00) {\r\nret = -ENODEV;\r\ngoto err_kfree;\r\n}\r\nret = regmap_read(dev->regmap, 0xfe, &uitmp);\r\nif (ret)\r\ngoto err_kfree;\r\nif (uitmp != 0x01) {\r\nret = -ENODEV;\r\ngoto err_kfree;\r\n}\r\nmemcpy(&dev->fe.ops, &tda10071_ops, sizeof(struct dvb_frontend_ops));\r\ndev->fe.demodulator_priv = dev;\r\ni2c_set_clientdata(client, dev);\r\npdata->get_dvb_frontend = tda10071_get_dvb_frontend;\r\ndev_info(&client->dev, "NXP TDA10071 successfully identified\n");\r\nreturn 0;\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tda10071_remove(struct i2c_client *client)\r\n{\r\nstruct tda10071_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nkfree(dev);\r\nreturn 0;\r\n}
