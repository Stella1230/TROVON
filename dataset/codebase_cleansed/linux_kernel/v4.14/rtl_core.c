u8 rtl92e_readb(struct net_device *dev, int x)\r\n{\r\nreturn 0xff & readb((u8 __iomem *)dev->mem_start + x);\r\n}\r\nu32 rtl92e_readl(struct net_device *dev, int x)\r\n{\r\nreturn readl((u8 __iomem *)dev->mem_start + x);\r\n}\r\nu16 rtl92e_readw(struct net_device *dev, int x)\r\n{\r\nreturn readw((u8 __iomem *)dev->mem_start + x);\r\n}\r\nvoid rtl92e_writeb(struct net_device *dev, int x, u8 y)\r\n{\r\nwriteb(y, (u8 __iomem *)dev->mem_start + x);\r\nudelay(20);\r\n}\r\nvoid rtl92e_writel(struct net_device *dev, int x, u32 y)\r\n{\r\nwritel(y, (u8 __iomem *)dev->mem_start + x);\r\nudelay(20);\r\n}\r\nvoid rtl92e_writew(struct net_device *dev, int x, u16 y)\r\n{\r\nwritew(y, (u8 __iomem *)dev->mem_start + x);\r\nudelay(20);\r\n}\r\nbool rtl92e_set_rf_state(struct net_device *dev,\r\nenum rt_rf_power_state StateToSet,\r\nRT_RF_CHANGE_SOURCE ChangeSource)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nbool bActionAllowed = false;\r\nbool bConnectBySSID = false;\r\nenum rt_rf_power_state rtState;\r\nu16 RFWaitCounter = 0;\r\nunsigned long flag;\r\nRT_TRACE((COMP_PS | COMP_RF),\r\n"===>rtl92e_set_rf_state(): StateToSet(%d)\n", StateToSet);\r\nwhile (true) {\r\nspin_lock_irqsave(&priv->rf_ps_lock, flag);\r\nif (priv->RFChangeInProgress) {\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\r\nRT_TRACE((COMP_PS | COMP_RF),\r\n"rtl92e_set_rf_state(): RF Change in progress! Wait to set..StateToSet(%d).\n",\r\nStateToSet);\r\nwhile (priv->RFChangeInProgress) {\r\nRFWaitCounter++;\r\nRT_TRACE((COMP_PS | COMP_RF),\r\n"rtl92e_set_rf_state(): Wait 1 ms (%d times)...\n",\r\nRFWaitCounter);\r\nmdelay(1);\r\nif (RFWaitCounter > 100) {\r\nnetdev_warn(dev,\r\n"%s(): Timeout waiting for RF change.\n",\r\n__func__);\r\nreturn false;\r\n}\r\n}\r\n} else {\r\npriv->RFChangeInProgress = true;\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\r\nbreak;\r\n}\r\n}\r\nrtState = priv->rtllib->eRFPowerState;\r\nswitch (StateToSet) {\r\ncase eRfOn:\r\npriv->rtllib->RfOffReason &= (~ChangeSource);\r\nif ((ChangeSource == RF_CHANGE_BY_HW) && priv->bHwRadioOff)\r\npriv->bHwRadioOff = false;\r\nif (!priv->rtllib->RfOffReason) {\r\npriv->rtllib->RfOffReason = 0;\r\nbActionAllowed = true;\r\nif (rtState == eRfOff &&\r\nChangeSource >= RF_CHANGE_BY_HW)\r\nbConnectBySSID = true;\r\n} else {\r\nRT_TRACE((COMP_PS | COMP_RF),\r\n"rtl92e_set_rf_state - eRfon reject pMgntInfo->RfOffReason= 0x%x, ChangeSource=0x%X\n",\r\npriv->rtllib->RfOffReason, ChangeSource);\r\n}\r\nbreak;\r\ncase eRfOff:\r\nif ((priv->rtllib->iw_mode == IW_MODE_INFRA) ||\r\n(priv->rtllib->iw_mode == IW_MODE_ADHOC)) {\r\nif ((priv->rtllib->RfOffReason > RF_CHANGE_BY_IPS) ||\r\n(ChangeSource > RF_CHANGE_BY_IPS)) {\r\nif (ieee->state == RTLLIB_LINKED)\r\npriv->blinked_ingpio = true;\r\nelse\r\npriv->blinked_ingpio = false;\r\nrtllib_MgntDisconnect(priv->rtllib,\r\nWLAN_REASON_DISASSOC_STA_HAS_LEFT);\r\n}\r\n}\r\nif ((ChangeSource == RF_CHANGE_BY_HW) && !priv->bHwRadioOff)\r\npriv->bHwRadioOff = true;\r\npriv->rtllib->RfOffReason |= ChangeSource;\r\nbActionAllowed = true;\r\nbreak;\r\ncase eRfSleep:\r\npriv->rtllib->RfOffReason |= ChangeSource;\r\nbActionAllowed = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (bActionAllowed) {\r\nRT_TRACE((COMP_PS | COMP_RF),\r\n"rtl92e_set_rf_state(): Action is allowed.... StateToSet(%d), RfOffReason(%#X)\n",\r\nStateToSet, priv->rtllib->RfOffReason);\r\nPHY_SetRFPowerState(dev, StateToSet);\r\nif (StateToSet == eRfOn) {\r\nif (bConnectBySSID && priv->blinked_ingpio) {\r\nschedule_delayed_work(\r\n&ieee->associate_procedure_wq, 0);\r\npriv->blinked_ingpio = false;\r\n}\r\n}\r\n} else {\r\nRT_TRACE((COMP_PS | COMP_RF),\r\n"rtl92e_set_rf_state(): Action is rejected.... StateToSet(%d), ChangeSource(%#X), RfOffReason(%#X)\n",\r\nStateToSet, ChangeSource, priv->rtllib->RfOffReason);\r\n}\r\nspin_lock_irqsave(&priv->rf_ps_lock, flag);\r\npriv->RFChangeInProgress = false;\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\r\nRT_TRACE((COMP_PS | COMP_RF), "<===rtl92e_set_rf_state()\n");\r\nreturn bActionAllowed;\r\n}\r\nstatic short _rtl92e_check_nic_enough_desc(struct net_device *dev, int prio)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtl8192_tx_ring *ring = &priv->tx_ring[prio];\r\nif (ring->entries - skb_queue_len(&ring->queue) >= 2)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void _rtl92e_tx_timeout(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nschedule_work(&priv->reset_wq);\r\nnetdev_info(dev, "TXTIMEOUT");\r\n}\r\nvoid rtl92e_irq_enable(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->irq_enabled = 1;\r\npriv->ops->irq_enable(dev);\r\n}\r\nvoid rtl92e_irq_disable(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->ops->irq_disable(dev);\r\npriv->irq_enabled = 0;\r\n}\r\nstatic void _rtl92e_set_chan(struct net_device *dev, short ch)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nRT_TRACE(COMP_CH, "=====>%s()====ch:%d\n", __func__, ch);\r\nif (priv->chan_forced)\r\nreturn;\r\npriv->chan = ch;\r\nif (priv->rf_set_chan)\r\npriv->rf_set_chan(dev, priv->chan);\r\n}\r\nstatic void _rtl92e_update_cap(struct net_device *dev, u16 cap)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_network *net = &priv->rtllib->current_network;\r\nbool ShortPreamble;\r\nif (cap & WLAN_CAPABILITY_SHORT_PREAMBLE) {\r\nif (priv->dot11CurrentPreambleMode != PREAMBLE_SHORT) {\r\nShortPreamble = true;\r\npriv->dot11CurrentPreambleMode = PREAMBLE_SHORT;\r\nRT_TRACE(COMP_DBG,\r\n"%s(): WLAN_CAPABILITY_SHORT_PREAMBLE\n",\r\n__func__);\r\npriv->rtllib->SetHwRegHandler(dev, HW_VAR_ACK_PREAMBLE,\r\n(unsigned char *)&ShortPreamble);\r\n}\r\n} else {\r\nif (priv->dot11CurrentPreambleMode != PREAMBLE_LONG) {\r\nShortPreamble = false;\r\npriv->dot11CurrentPreambleMode = PREAMBLE_LONG;\r\nRT_TRACE(COMP_DBG,\r\n"%s(): WLAN_CAPABILITY_LONG_PREAMBLE\n",\r\n__func__);\r\npriv->rtllib->SetHwRegHandler(dev, HW_VAR_ACK_PREAMBLE,\r\n(unsigned char *)&ShortPreamble);\r\n}\r\n}\r\nif (net->mode & (IEEE_G | IEEE_N_24G)) {\r\nu8 slot_time_val;\r\nu8 CurSlotTime = priv->slot_time;\r\nif ((cap & WLAN_CAPABILITY_SHORT_SLOT_TIME) &&\r\n(!priv->rtllib->pHTInfo->bCurrentRT2RTLongSlotTime)) {\r\nif (CurSlotTime != SHORT_SLOT_TIME) {\r\nslot_time_val = SHORT_SLOT_TIME;\r\npriv->rtllib->SetHwRegHandler(dev,\r\nHW_VAR_SLOT_TIME, &slot_time_val);\r\n}\r\n} else {\r\nif (CurSlotTime != NON_SHORT_SLOT_TIME) {\r\nslot_time_val = NON_SHORT_SLOT_TIME;\r\npriv->rtllib->SetHwRegHandler(dev,\r\nHW_VAR_SLOT_TIME, &slot_time_val);\r\n}\r\n}\r\n}\r\n}\r\nstatic void _rtl92e_update_beacon(void *data)\r\n{\r\nstruct r8192_priv *priv = container_of_work_rsl(data, struct r8192_priv,\r\nupdate_beacon_wq.work);\r\nstruct net_device *dev = priv->rtllib->dev;\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nstruct rtllib_network *net = &ieee->current_network;\r\nif (ieee->pHTInfo->bCurrentHTSupport)\r\nHT_update_self_and_peer_setting(ieee, net);\r\nieee->pHTInfo->bCurrentRT2RTLongSlotTime =\r\nnet->bssht.bdRT2RTLongSlotTime;\r\nieee->pHTInfo->RT2RT_HT_Mode = net->bssht.RT2RT_HT_Mode;\r\n_rtl92e_update_cap(dev, net->capability);\r\n}\r\nstatic void _rtl92e_qos_activate(void *data)\r\n{\r\nstruct r8192_priv *priv = container_of_work_rsl(data, struct r8192_priv,\r\nqos_activate);\r\nstruct net_device *dev = priv->rtllib->dev;\r\nint i;\r\nmutex_lock(&priv->mutex);\r\nif (priv->rtllib->state != RTLLIB_LINKED)\r\ngoto success;\r\nRT_TRACE(COMP_QOS,\r\n"qos active process with associate response received\n");\r\nfor (i = 0; i < QOS_QUEUE_NUM; i++)\r\npriv->rtllib->SetHwRegHandler(dev, HW_VAR_AC_PARAM, (u8 *)(&i));\r\nsuccess:\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int _rtl92e_qos_handle_probe_response(struct r8192_priv *priv,\r\nint active_network,\r\nstruct rtllib_network *network)\r\n{\r\nint ret = 0;\r\nu32 size = sizeof(struct rtllib_qos_parameters);\r\nif (priv->rtllib->state != RTLLIB_LINKED)\r\nreturn ret;\r\nif (priv->rtllib->iw_mode != IW_MODE_INFRA)\r\nreturn ret;\r\nif (network->flags & NETWORK_HAS_QOS_MASK) {\r\nif (active_network &&\r\n(network->flags & NETWORK_HAS_QOS_PARAMETERS))\r\nnetwork->qos_data.active = network->qos_data.supported;\r\nif ((network->qos_data.active == 1) && (active_network == 1) &&\r\n(network->flags & NETWORK_HAS_QOS_PARAMETERS) &&\r\n(network->qos_data.old_param_count !=\r\nnetwork->qos_data.param_count)) {\r\nnetwork->qos_data.old_param_count =\r\nnetwork->qos_data.param_count;\r\npriv->rtllib->wmm_acm = network->qos_data.wmm_acm;\r\nschedule_work(&priv->qos_activate);\r\nRT_TRACE(COMP_QOS,\r\n"QoS parameters change call qos_activate\n");\r\n}\r\n} else {\r\nmemcpy(&priv->rtllib->current_network.qos_data.parameters,\r\n&def_qos_parameters, size);\r\nif ((network->qos_data.active == 1) && (active_network == 1)) {\r\nschedule_work(&priv->qos_activate);\r\nRT_TRACE(COMP_QOS,\r\n"QoS was disabled call qos_activate\n");\r\n}\r\nnetwork->qos_data.active = 0;\r\nnetwork->qos_data.supported = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int _rtl92e_handle_beacon(struct net_device *dev,\r\nstruct rtllib_beacon *beacon,\r\nstruct rtllib_network *network)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\n_rtl92e_qos_handle_probe_response(priv, 1, network);\r\nschedule_delayed_work(&priv->update_beacon_wq, 0);\r\nreturn 0;\r\n}\r\nstatic int _rtl92e_qos_assoc_resp(struct r8192_priv *priv,\r\nstruct rtllib_network *network)\r\n{\r\nunsigned long flags;\r\nu32 size = sizeof(struct rtllib_qos_parameters);\r\nint set_qos_param = 0;\r\nif (!priv || !network)\r\nreturn 0;\r\nif (priv->rtllib->state != RTLLIB_LINKED)\r\nreturn 0;\r\nif (priv->rtllib->iw_mode != IW_MODE_INFRA)\r\nreturn 0;\r\nspin_lock_irqsave(&priv->rtllib->lock, flags);\r\nif (network->flags & NETWORK_HAS_QOS_PARAMETERS) {\r\nmemcpy(&priv->rtllib->current_network.qos_data.parameters,\r\n&network->qos_data.parameters,\r\nsizeof(struct rtllib_qos_parameters));\r\npriv->rtllib->current_network.qos_data.active = 1;\r\npriv->rtllib->wmm_acm = network->qos_data.wmm_acm;\r\nset_qos_param = 1;\r\npriv->rtllib->current_network.qos_data.old_param_count =\r\npriv->rtllib->current_network.qos_data.param_count;\r\npriv->rtllib->current_network.qos_data.param_count =\r\nnetwork->qos_data.param_count;\r\n} else {\r\nmemcpy(&priv->rtllib->current_network.qos_data.parameters,\r\n&def_qos_parameters, size);\r\npriv->rtllib->current_network.qos_data.active = 0;\r\npriv->rtllib->current_network.qos_data.supported = 0;\r\nset_qos_param = 1;\r\n}\r\nspin_unlock_irqrestore(&priv->rtllib->lock, flags);\r\nRT_TRACE(COMP_QOS, "%s: network->flags = %d,%d\n", __func__,\r\nnetwork->flags, priv->rtllib->current_network.qos_data.active);\r\nif (set_qos_param == 1) {\r\nrtl92e_dm_init_edca_turbo(priv->rtllib->dev);\r\nschedule_work(&priv->qos_activate);\r\n}\r\nreturn 0;\r\n}\r\nstatic int _rtl92e_handle_assoc_response(struct net_device *dev,\r\nstruct rtllib_assoc_response_frame *resp,\r\nstruct rtllib_network *network)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\n_rtl92e_qos_assoc_resp(priv, network);\r\nreturn 0;\r\n}\r\nstatic void _rtl92e_prepare_beacon(struct r8192_priv *priv)\r\n{\r\nstruct net_device *dev = priv->rtllib->dev;\r\nstruct sk_buff *pskb = NULL, *pnewskb = NULL;\r\nstruct cb_desc *tcb_desc = NULL;\r\nstruct rtl8192_tx_ring *ring = NULL;\r\nstruct tx_desc *pdesc = NULL;\r\nring = &priv->tx_ring[BEACON_QUEUE];\r\npskb = __skb_dequeue(&ring->queue);\r\nkfree_skb(pskb);\r\npnewskb = rtllib_get_beacon(priv->rtllib);\r\nif (!pnewskb)\r\nreturn;\r\ntcb_desc = (struct cb_desc *)(pnewskb->cb + 8);\r\ntcb_desc->queue_index = BEACON_QUEUE;\r\ntcb_desc->data_rate = 2;\r\ntcb_desc->RATRIndex = 7;\r\ntcb_desc->bTxDisableRateFallBack = 1;\r\ntcb_desc->bTxUseDriverAssingedRate = 1;\r\nskb_push(pnewskb, priv->rtllib->tx_headroom);\r\npdesc = &ring->desc[0];\r\npriv->ops->tx_fill_descriptor(dev, pdesc, tcb_desc, pnewskb);\r\n__skb_queue_tail(&ring->queue, pnewskb);\r\npdesc->OWN = 1;\r\n}\r\nstatic void _rtl92e_stop_beacon(struct net_device *dev)\r\n{\r\n}\r\nvoid rtl92e_config_rate(struct net_device *dev, u16 *rate_config)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_network *net;\r\nu8 i = 0, basic_rate = 0;\r\nnet = &priv->rtllib->current_network;\r\nfor (i = 0; i < net->rates_len; i++) {\r\nbasic_rate = net->rates[i] & 0x7f;\r\nswitch (basic_rate) {\r\ncase MGN_1M:\r\n*rate_config |= RRSR_1M;\r\nbreak;\r\ncase MGN_2M:\r\n*rate_config |= RRSR_2M;\r\nbreak;\r\ncase MGN_5_5M:\r\n*rate_config |= RRSR_5_5M;\r\nbreak;\r\ncase MGN_11M:\r\n*rate_config |= RRSR_11M;\r\nbreak;\r\ncase MGN_6M:\r\n*rate_config |= RRSR_6M;\r\nbreak;\r\ncase MGN_9M:\r\n*rate_config |= RRSR_9M;\r\nbreak;\r\ncase MGN_12M:\r\n*rate_config |= RRSR_12M;\r\nbreak;\r\ncase MGN_18M:\r\n*rate_config |= RRSR_18M;\r\nbreak;\r\ncase MGN_24M:\r\n*rate_config |= RRSR_24M;\r\nbreak;\r\ncase MGN_36M:\r\n*rate_config |= RRSR_36M;\r\nbreak;\r\ncase MGN_48M:\r\n*rate_config |= RRSR_48M;\r\nbreak;\r\ncase MGN_54M:\r\n*rate_config |= RRSR_54M;\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < net->rates_ex_len; i++) {\r\nbasic_rate = net->rates_ex[i] & 0x7f;\r\nswitch (basic_rate) {\r\ncase MGN_1M:\r\n*rate_config |= RRSR_1M;\r\nbreak;\r\ncase MGN_2M:\r\n*rate_config |= RRSR_2M;\r\nbreak;\r\ncase MGN_5_5M:\r\n*rate_config |= RRSR_5_5M;\r\nbreak;\r\ncase MGN_11M:\r\n*rate_config |= RRSR_11M;\r\nbreak;\r\ncase MGN_6M:\r\n*rate_config |= RRSR_6M;\r\nbreak;\r\ncase MGN_9M:\r\n*rate_config |= RRSR_9M;\r\nbreak;\r\ncase MGN_12M:\r\n*rate_config |= RRSR_12M;\r\nbreak;\r\ncase MGN_18M:\r\n*rate_config |= RRSR_18M;\r\nbreak;\r\ncase MGN_24M:\r\n*rate_config |= RRSR_24M;\r\nbreak;\r\ncase MGN_36M:\r\n*rate_config |= RRSR_36M;\r\nbreak;\r\ncase MGN_48M:\r\n*rate_config |= RRSR_48M;\r\nbreak;\r\ncase MGN_54M:\r\n*rate_config |= RRSR_54M;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void _rtl92e_refresh_support_rate(struct r8192_priv *priv)\r\n{\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nif (ieee->mode == WIRELESS_MODE_N_24G ||\r\nieee->mode == WIRELESS_MODE_N_5G) {\r\nmemcpy(ieee->Regdot11HTOperationalRateSet,\r\nieee->RegHTSuppRateSet, 16);\r\nmemcpy(ieee->Regdot11TxHTOperationalRateSet,\r\nieee->RegHTSuppRateSet, 16);\r\n} else {\r\nmemset(ieee->Regdot11HTOperationalRateSet, 0, 16);\r\n}\r\n}\r\nstatic u8 _rtl92e_get_supported_wireless_mode(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 ret = 0;\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\ncase RF_8256:\r\ncase RF_6052:\r\ncase RF_PSEUDO_11N:\r\nret = (WIRELESS_MODE_N_24G | WIRELESS_MODE_G | WIRELESS_MODE_B);\r\nbreak;\r\ncase RF_8258:\r\nret = (WIRELESS_MODE_A | WIRELESS_MODE_N_5G);\r\nbreak;\r\ndefault:\r\nret = WIRELESS_MODE_B;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid rtl92e_set_wireless_mode(struct net_device *dev, u8 wireless_mode)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 bSupportMode = _rtl92e_get_supported_wireless_mode(dev);\r\nif ((wireless_mode == WIRELESS_MODE_AUTO) ||\r\n((wireless_mode & bSupportMode) == 0)) {\r\nif (bSupportMode & WIRELESS_MODE_N_24G) {\r\nwireless_mode = WIRELESS_MODE_N_24G;\r\n} else if (bSupportMode & WIRELESS_MODE_N_5G) {\r\nwireless_mode = WIRELESS_MODE_N_5G;\r\n} else if ((bSupportMode & WIRELESS_MODE_A)) {\r\nwireless_mode = WIRELESS_MODE_A;\r\n} else if ((bSupportMode & WIRELESS_MODE_G)) {\r\nwireless_mode = WIRELESS_MODE_G;\r\n} else if ((bSupportMode & WIRELESS_MODE_B)) {\r\nwireless_mode = WIRELESS_MODE_B;\r\n} else {\r\nnetdev_info(dev,\r\n"%s(): Unsupported mode requested. Fallback to 802.11b\n",\r\n__func__);\r\nwireless_mode = WIRELESS_MODE_B;\r\n}\r\n}\r\nif ((wireless_mode & (WIRELESS_MODE_B | WIRELESS_MODE_G)) ==\r\n(WIRELESS_MODE_G | WIRELESS_MODE_B))\r\nwireless_mode = WIRELESS_MODE_G;\r\npriv->rtllib->mode = wireless_mode;\r\nif ((wireless_mode == WIRELESS_MODE_N_24G) ||\r\n(wireless_mode == WIRELESS_MODE_N_5G)) {\r\npriv->rtllib->pHTInfo->bEnableHT = 1;\r\nRT_TRACE(COMP_DBG, "%s(), wireless_mode:%x, bEnableHT = 1\n",\r\n__func__, wireless_mode);\r\n} else {\r\npriv->rtllib->pHTInfo->bEnableHT = 0;\r\nRT_TRACE(COMP_DBG, "%s(), wireless_mode:%x, bEnableHT = 0\n",\r\n__func__, wireless_mode);\r\n}\r\nRT_TRACE(COMP_INIT, "Current Wireless Mode is %x\n", wireless_mode);\r\n_rtl92e_refresh_support_rate(priv);\r\n}\r\nstatic int _rtl92e_sta_up(struct net_device *dev, bool is_silent_reset)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)\r\n(&priv->rtllib->PowerSaveControl);\r\nbool init_status = true;\r\npriv->bDriverIsGoingToUnload = false;\r\npriv->bdisable_nic = false;\r\npriv->up = 1;\r\npriv->rtllib->ieee_up = 1;\r\npriv->up_first_time = 0;\r\nRT_TRACE(COMP_INIT, "Bringing up iface");\r\npriv->bfirst_init = true;\r\ninit_status = priv->ops->initialize_adapter(dev);\r\nif (!init_status) {\r\nnetdev_err(dev, "%s(): Initialization failed!\n", __func__);\r\npriv->bfirst_init = false;\r\nreturn -1;\r\n}\r\nRT_TRACE(COMP_INIT, "start adapter finished\n");\r\nRT_CLEAR_PS_LEVEL(pPSC, RT_RF_OFF_LEVL_HALT_NIC);\r\npriv->bfirst_init = false;\r\nif (priv->polling_timer_on == 0)\r\nrtl92e_check_rfctrl_gpio_timer((unsigned long)dev);\r\nif (priv->rtllib->state != RTLLIB_LINKED)\r\nrtllib_softmac_start_protocol(priv->rtllib, 0);\r\nrtllib_reset_queue(priv->rtllib);\r\n_rtl92e_watchdog_timer_cb((unsigned long)dev);\r\nif (!netif_queue_stopped(dev))\r\nnetif_start_queue(dev);\r\nelse\r\nnetif_wake_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int _rtl92e_sta_down(struct net_device *dev, bool shutdownrf)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nunsigned long flags = 0;\r\nu8 RFInProgressTimeOut = 0;\r\nif (priv->up == 0)\r\nreturn -1;\r\nif (priv->rtllib->rtllib_ips_leave)\r\npriv->rtllib->rtllib_ips_leave(dev);\r\nif (priv->rtllib->state == RTLLIB_LINKED)\r\nrtl92e_leisure_ps_leave(dev);\r\npriv->bDriverIsGoingToUnload = true;\r\npriv->up = 0;\r\npriv->rtllib->ieee_up = 0;\r\npriv->bfirst_after_down = true;\r\nRT_TRACE(COMP_DOWN, "==========>%s()\n", __func__);\r\nif (!netif_queue_stopped(dev))\r\nnetif_stop_queue(dev);\r\npriv->rtllib->wpa_ie_len = 0;\r\nkfree(priv->rtllib->wpa_ie);\r\npriv->rtllib->wpa_ie = NULL;\r\nrtl92e_cam_reset(dev);\r\nmemset(priv->rtllib->swcamtable, 0, sizeof(struct sw_cam_table) * 32);\r\nrtl92e_irq_disable(dev);\r\ndel_timer_sync(&priv->watch_dog_timer);\r\n_rtl92e_cancel_deferred_work(priv);\r\ncancel_delayed_work(&priv->rtllib->hw_wakeup_wq);\r\nrtllib_softmac_stop_protocol(priv->rtllib, 0, true);\r\nspin_lock_irqsave(&priv->rf_ps_lock, flags);\r\nwhile (priv->RFChangeInProgress) {\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\r\nif (RFInProgressTimeOut > 100) {\r\nspin_lock_irqsave(&priv->rf_ps_lock, flags);\r\nbreak;\r\n}\r\nRT_TRACE(COMP_DBG,\r\n"===>%s():RF is in progress, need to wait until rf change is done.\n",\r\n__func__);\r\nmdelay(1);\r\nRFInProgressTimeOut++;\r\nspin_lock_irqsave(&priv->rf_ps_lock, flags);\r\n}\r\npriv->RFChangeInProgress = true;\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\r\npriv->ops->stop_adapter(dev, false);\r\nspin_lock_irqsave(&priv->rf_ps_lock, flags);\r\npriv->RFChangeInProgress = false;\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\r\nudelay(100);\r\nmemset(&priv->rtllib->current_network, 0,\r\noffsetof(struct rtllib_network, list));\r\nRT_TRACE(COMP_DOWN, "<==========%s()\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void _rtl92e_init_priv_handler(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->rtllib->softmac_hard_start_xmit = _rtl92e_hard_start_xmit;\r\npriv->rtllib->set_chan = _rtl92e_set_chan;\r\npriv->rtllib->link_change = priv->ops->link_change;\r\npriv->rtllib->softmac_data_hard_start_xmit = _rtl92e_hard_data_xmit;\r\npriv->rtllib->check_nic_enough_desc = _rtl92e_check_nic_enough_desc;\r\npriv->rtllib->handle_assoc_response = _rtl92e_handle_assoc_response;\r\npriv->rtllib->handle_beacon = _rtl92e_handle_beacon;\r\npriv->rtllib->SetWirelessMode = rtl92e_set_wireless_mode;\r\npriv->rtllib->LeisurePSLeave = rtl92e_leisure_ps_leave;\r\npriv->rtllib->SetBWModeHandler = rtl92e_set_bw_mode;\r\npriv->rf_set_chan = rtl92e_set_channel;\r\npriv->rtllib->start_send_beacons = rtl92e_start_beacon;\r\npriv->rtllib->stop_send_beacons = _rtl92e_stop_beacon;\r\npriv->rtllib->sta_wake_up = rtl92e_hw_wakeup;\r\npriv->rtllib->enter_sleep_state = rtl92e_enter_sleep;\r\npriv->rtllib->ps_is_queue_empty = _rtl92e_is_tx_queue_empty;\r\npriv->rtllib->GetNmodeSupportBySecCfg = rtl92e_get_nmode_support_by_sec;\r\npriv->rtllib->GetHalfNmodeSupportByAPsHandler =\r\nrtl92e_is_halfn_supported_by_ap;\r\npriv->rtllib->SetHwRegHandler = rtl92e_set_reg;\r\npriv->rtllib->AllowAllDestAddrHandler = rtl92e_set_monitor_mode;\r\npriv->rtllib->SetFwCmdHandler = NULL;\r\npriv->rtllib->InitialGainHandler = rtl92e_init_gain;\r\npriv->rtllib->rtllib_ips_leave_wq = rtl92e_rtllib_ips_leave_wq;\r\npriv->rtllib->rtllib_ips_leave = rtl92e_rtllib_ips_leave;\r\npriv->rtllib->LedControlHandler = NULL;\r\npriv->rtllib->UpdateBeaconInterruptHandler = NULL;\r\npriv->rtllib->ScanOperationBackupHandler = rtl92e_scan_op_backup;\r\n}\r\nstatic void _rtl92e_init_priv_constant(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)\r\n&priv->rtllib->PowerSaveControl;\r\npPSC->RegMaxLPSAwakeIntvl = 5;\r\n}\r\nstatic void _rtl92e_init_priv_variable(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 i;\r\npriv->AcmMethod = eAcmWay2_SW;\r\npriv->dot11CurrentPreambleMode = PREAMBLE_AUTO;\r\npriv->rtllib->status = 0;\r\npriv->polling_timer_on = 0;\r\npriv->up_first_time = 1;\r\npriv->blinked_ingpio = false;\r\npriv->bDriverIsGoingToUnload = false;\r\npriv->being_init_adapter = false;\r\npriv->initialized_at_probe = false;\r\npriv->bdisable_nic = false;\r\npriv->bfirst_init = false;\r\npriv->txringcount = 64;\r\npriv->rxbuffersize = 9100;\r\npriv->rxringcount = MAX_RX_COUNT;\r\npriv->irq_enabled = 0;\r\npriv->chan = 1;\r\npriv->RegChannelPlan = 0xf;\r\npriv->rtllib->mode = WIRELESS_MODE_AUTO;\r\npriv->rtllib->iw_mode = IW_MODE_INFRA;\r\npriv->rtllib->bNetPromiscuousMode = false;\r\npriv->rtllib->IntelPromiscuousModeInfo.bPromiscuousOn = false;\r\npriv->rtllib->IntelPromiscuousModeInfo.bFilterSourceStationFrame =\r\nfalse;\r\npriv->rtllib->ieee_up = 0;\r\npriv->retry_rts = DEFAULT_RETRY_RTS;\r\npriv->retry_data = DEFAULT_RETRY_DATA;\r\npriv->rtllib->rts = DEFAULT_RTS_THRESHOLD;\r\npriv->rtllib->rate = 110;\r\npriv->rtllib->short_slot = 1;\r\npriv->promisc = (dev->flags & IFF_PROMISC) ? 1 : 0;\r\npriv->bcck_in_ch14 = false;\r\npriv->bfsync_processing = false;\r\npriv->CCKPresentAttentuation = 0;\r\npriv->rfa_txpowertrackingindex = 0;\r\npriv->rfc_txpowertrackingindex = 0;\r\npriv->CckPwEnl = 6;\r\npriv->ScanDelay = 50;\r\npriv->ResetProgress = RESET_TYPE_NORESET;\r\npriv->bForcedSilentReset = false;\r\npriv->bDisableNormalResetCheck = false;\r\npriv->force_reset = false;\r\nmemset(priv->rtllib->swcamtable, 0, sizeof(struct sw_cam_table) * 32);\r\nmemset(&priv->InterruptLog, 0, sizeof(struct log_int_8190));\r\npriv->RxCounter = 0;\r\npriv->rtllib->wx_set_enc = 0;\r\npriv->bHwRadioOff = false;\r\npriv->RegRfOff = false;\r\npriv->isRFOff = false;\r\npriv->bInPowerSaveMode = false;\r\npriv->rtllib->RfOffReason = 0;\r\npriv->RFChangeInProgress = false;\r\npriv->bHwRfOffAction = 0;\r\npriv->SetRFPowerStateInProgress = false;\r\npriv->rtllib->PowerSaveControl.bInactivePs = true;\r\npriv->rtllib->PowerSaveControl.bIPSModeBackup = false;\r\npriv->rtllib->PowerSaveControl.bLeisurePs = true;\r\npriv->rtllib->PowerSaveControl.bFwCtrlLPS = false;\r\npriv->rtllib->LPSDelayCnt = 0;\r\npriv->rtllib->sta_sleep = LPS_IS_WAKE;\r\npriv->rtllib->eRFPowerState = eRfOn;\r\npriv->rtllib->current_network.beacon_interval = DEFAULT_BEACONINTERVAL;\r\npriv->rtllib->iw_mode = IW_MODE_INFRA;\r\npriv->rtllib->active_scan = 1;\r\npriv->rtllib->be_scan_inprogress = false;\r\npriv->rtllib->modulation = RTLLIB_CCK_MODULATION |\r\nRTLLIB_OFDM_MODULATION;\r\npriv->rtllib->host_encrypt = 1;\r\npriv->rtllib->host_decrypt = 1;\r\npriv->rtllib->fts = DEFAULT_FRAG_THRESHOLD;\r\npriv->card_type = PCI;\r\npriv->pFirmware = vzalloc(sizeof(struct rt_firmware));\r\nif (!priv->pFirmware)\r\nnetdev_err(dev,\r\n"rtl8192e: Unable to allocate space for firmware\n");\r\nskb_queue_head_init(&priv->skb_queue);\r\nfor (i = 0; i < MAX_QUEUE_SIZE; i++)\r\nskb_queue_head_init(&priv->rtllib->skb_waitQ[i]);\r\nfor (i = 0; i < MAX_QUEUE_SIZE; i++)\r\nskb_queue_head_init(&priv->rtllib->skb_aggQ[i]);\r\n}\r\nstatic void _rtl92e_init_priv_lock(struct r8192_priv *priv)\r\n{\r\nspin_lock_init(&priv->tx_lock);\r\nspin_lock_init(&priv->irq_th_lock);\r\nspin_lock_init(&priv->rf_ps_lock);\r\nspin_lock_init(&priv->ps_lock);\r\nmutex_init(&priv->wx_mutex);\r\nmutex_init(&priv->rf_mutex);\r\nmutex_init(&priv->mutex);\r\n}\r\nstatic void _rtl92e_init_priv_task(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nINIT_WORK_RSL(&priv->reset_wq, (void *)_rtl92e_restart, dev);\r\nINIT_WORK_RSL(&priv->rtllib->ips_leave_wq, (void *)rtl92e_ips_leave_wq,\r\ndev);\r\nINIT_DELAYED_WORK_RSL(&priv->watch_dog_wq,\r\n(void *)_rtl92e_watchdog_wq_cb, dev);\r\nINIT_DELAYED_WORK_RSL(&priv->txpower_tracking_wq,\r\n(void *)rtl92e_dm_txpower_tracking_wq, dev);\r\nINIT_DELAYED_WORK_RSL(&priv->rfpath_check_wq,\r\n(void *)rtl92e_dm_rf_pathcheck_wq, dev);\r\nINIT_DELAYED_WORK_RSL(&priv->update_beacon_wq,\r\n(void *)_rtl92e_update_beacon, dev);\r\nINIT_WORK_RSL(&priv->qos_activate, (void *)_rtl92e_qos_activate, dev);\r\nINIT_DELAYED_WORK_RSL(&priv->rtllib->hw_wakeup_wq,\r\n(void *)rtl92e_hw_wakeup_wq, dev);\r\nINIT_DELAYED_WORK_RSL(&priv->rtllib->hw_sleep_wq,\r\n(void *)rtl92e_hw_sleep_wq, dev);\r\ntasklet_init(&priv->irq_rx_tasklet,\r\n(void(*)(unsigned long))_rtl92e_irq_rx_tasklet,\r\n(unsigned long)priv);\r\ntasklet_init(&priv->irq_tx_tasklet,\r\n(void(*)(unsigned long))_rtl92e_irq_tx_tasklet,\r\n(unsigned long)priv);\r\ntasklet_init(&priv->irq_prepare_beacon_tasklet,\r\n(void(*)(unsigned long))_rtl92e_prepare_beacon,\r\n(unsigned long)priv);\r\n}\r\nstatic short _rtl92e_get_channel_map(struct net_device *dev)\r\n{\r\nint i;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif ((priv->rf_chip != RF_8225) && (priv->rf_chip != RF_8256) &&\r\n(priv->rf_chip != RF_6052)) {\r\nnetdev_err(dev, "%s: unknown rf chip, can't set channel map\n",\r\n__func__);\r\nreturn -1;\r\n}\r\nif (priv->ChannelPlan >= COUNTRY_CODE_MAX) {\r\nnetdev_info(dev,\r\n"rtl819x_init:Error channel plan! Set to default.\n");\r\npriv->ChannelPlan = COUNTRY_CODE_FCC;\r\n}\r\nRT_TRACE(COMP_INIT, "Channel plan is %d\n", priv->ChannelPlan);\r\ndot11d_init(priv->rtllib);\r\nDot11d_Channelmap(priv->ChannelPlan, priv->rtllib);\r\nfor (i = 1; i <= 11; i++)\r\n(priv->rtllib->active_channel_map)[i] = 1;\r\n(priv->rtllib->active_channel_map)[12] = 2;\r\n(priv->rtllib->active_channel_map)[13] = 2;\r\nreturn 0;\r\n}\r\nstatic short _rtl92e_init(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nmemset(&priv->stats, 0, sizeof(struct rt_stats));\r\n_rtl92e_init_priv_handler(dev);\r\n_rtl92e_init_priv_constant(dev);\r\n_rtl92e_init_priv_variable(dev);\r\n_rtl92e_init_priv_lock(priv);\r\n_rtl92e_init_priv_task(dev);\r\npriv->ops->get_eeprom_size(dev);\r\npriv->ops->init_adapter_variable(dev);\r\n_rtl92e_get_channel_map(dev);\r\nrtl92e_dm_init(dev);\r\nsetup_timer(&priv->watch_dog_timer,\r\n_rtl92e_watchdog_timer_cb,\r\n(unsigned long)dev);\r\nsetup_timer(&priv->gpio_polling_timer,\r\nrtl92e_check_rfctrl_gpio_timer,\r\n(unsigned long)dev);\r\nrtl92e_irq_disable(dev);\r\nif (request_irq(dev->irq, _rtl92e_irq, IRQF_SHARED, dev->name, dev)) {\r\nnetdev_err(dev, "Error allocating IRQ %d", dev->irq);\r\nreturn -1;\r\n}\r\npriv->irq = dev->irq;\r\nRT_TRACE(COMP_INIT, "IRQ %d\n", dev->irq);\r\nif (_rtl92e_pci_initdescring(dev) != 0) {\r\nnetdev_err(dev, "Endopoints initialization failed");\r\nfree_irq(dev->irq, dev);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic short _rtl92e_is_tx_queue_empty(struct net_device *dev)\r\n{\r\nint i = 0;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nfor (i = 0; i <= MGNT_QUEUE; i++) {\r\nif ((i == TXCMD_QUEUE) || (i == HCCA_QUEUE))\r\ncontinue;\r\nif (skb_queue_len(&(&priv->tx_ring[i])->queue) > 0) {\r\nnetdev_info(dev, "===>tx queue is not empty:%d, %d\n",\r\ni, skb_queue_len(&(&priv->tx_ring[i])->queue));\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic enum reset_type _rtl92e_tx_check_stuck(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 QueueID;\r\nbool bCheckFwTxCnt = false;\r\nstruct rtl8192_tx_ring *ring = NULL;\r\nstruct sk_buff *skb = NULL;\r\nstruct cb_desc *tcb_desc = NULL;\r\nunsigned long flags = 0;\r\nswitch (priv->rtllib->ps) {\r\ncase RTLLIB_PS_DISABLED:\r\nbreak;\r\ncase (RTLLIB_PS_MBCAST | RTLLIB_PS_UNICAST):\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_lock_irqsave(&priv->irq_th_lock, flags);\r\nfor (QueueID = 0; QueueID < MAX_TX_QUEUE; QueueID++) {\r\nif (QueueID == TXCMD_QUEUE)\r\ncontinue;\r\nif (QueueID == BEACON_QUEUE)\r\ncontinue;\r\nring = &priv->tx_ring[QueueID];\r\nif (skb_queue_len(&ring->queue) == 0) {\r\ncontinue;\r\n} else {\r\nskb = (&ring->queue)->next;\r\ntcb_desc = (struct cb_desc *)(skb->cb +\r\nMAX_DEV_ADDR_SIZE);\r\ntcb_desc->nStuckCount++;\r\nbCheckFwTxCnt = true;\r\nif (tcb_desc->nStuckCount > 1)\r\nnetdev_info(dev,\r\n"%s: QueueID=%d tcb_desc->nStuckCount=%d\n",\r\n__func__, QueueID,\r\ntcb_desc->nStuckCount);\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\nif (bCheckFwTxCnt) {\r\nif (priv->ops->TxCheckStuckHandler(dev)) {\r\nRT_TRACE(COMP_RESET,\r\n"TxCheckStuck(): Fw indicates no Tx condition!\n");\r\nreturn RESET_TYPE_SILENT;\r\n}\r\n}\r\nreturn RESET_TYPE_NORESET;\r\n}\r\nstatic enum reset_type _rtl92e_rx_check_stuck(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->ops->RxCheckStuckHandler(dev)) {\r\nRT_TRACE(COMP_RESET, "RxStuck Condition\n");\r\nreturn RESET_TYPE_SILENT;\r\n}\r\nreturn RESET_TYPE_NORESET;\r\n}\r\nstatic enum reset_type _rtl92e_if_check_reset(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nenum reset_type TxResetType = RESET_TYPE_NORESET;\r\nenum reset_type RxResetType = RESET_TYPE_NORESET;\r\nenum rt_rf_power_state rfState;\r\nrfState = priv->rtllib->eRFPowerState;\r\nif (rfState == eRfOn)\r\nTxResetType = _rtl92e_tx_check_stuck(dev);\r\nif (rfState == eRfOn &&\r\n(priv->rtllib->iw_mode == IW_MODE_INFRA) &&\r\n(priv->rtllib->state == RTLLIB_LINKED))\r\nRxResetType = _rtl92e_rx_check_stuck(dev);\r\nif (TxResetType == RESET_TYPE_NORMAL ||\r\nRxResetType == RESET_TYPE_NORMAL) {\r\nnetdev_info(dev, "%s(): TxResetType is %d, RxResetType is %d\n",\r\n__func__, TxResetType, RxResetType);\r\nreturn RESET_TYPE_NORMAL;\r\n} else if (TxResetType == RESET_TYPE_SILENT ||\r\nRxResetType == RESET_TYPE_SILENT) {\r\nnetdev_info(dev, "%s(): TxResetType is %d, RxResetType is %d\n",\r\n__func__, TxResetType, RxResetType);\r\nreturn RESET_TYPE_SILENT;\r\n} else {\r\nreturn RESET_TYPE_NORESET;\r\n}\r\n}\r\nstatic void _rtl92e_if_silent_reset(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 reset_times = 0;\r\nint reset_status = 0;\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nunsigned long flag;\r\nif (priv->ResetProgress == RESET_TYPE_NORESET) {\r\nRT_TRACE(COMP_RESET, "=========>Reset progress!!\n");\r\npriv->ResetProgress = RESET_TYPE_SILENT;\r\nspin_lock_irqsave(&priv->rf_ps_lock, flag);\r\nif (priv->RFChangeInProgress) {\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\r\ngoto END;\r\n}\r\npriv->RFChangeInProgress = true;\r\npriv->bResetInProgress = true;\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\r\nRESET_START:\r\nmutex_lock(&priv->wx_mutex);\r\nif (priv->rtllib->state == RTLLIB_LINKED)\r\nrtl92e_leisure_ps_leave(dev);\r\nif (priv->up) {\r\nnetdev_info(dev, "%s():the driver is not up.\n",\r\n__func__);\r\nmutex_unlock(&priv->wx_mutex);\r\nreturn;\r\n}\r\npriv->up = 0;\r\nRT_TRACE(COMP_RESET, "%s():======>start to down the driver\n",\r\n__func__);\r\nmdelay(1000);\r\nRT_TRACE(COMP_RESET,\r\n"%s():111111111111111111111111======>start to down the driver\n",\r\n__func__);\r\nif (!netif_queue_stopped(dev))\r\nnetif_stop_queue(dev);\r\nrtl92e_irq_disable(dev);\r\ndel_timer_sync(&priv->watch_dog_timer);\r\n_rtl92e_cancel_deferred_work(priv);\r\nrtl92e_dm_deinit(dev);\r\nrtllib_stop_scan_syncro(ieee);\r\nif (ieee->state == RTLLIB_LINKED) {\r\nmutex_lock(&ieee->wx_mutex);\r\nnetdev_info(dev, "ieee->state is RTLLIB_LINKED\n");\r\nrtllib_stop_send_beacons(priv->rtllib);\r\ndel_timer_sync(&ieee->associate_timer);\r\ncancel_delayed_work(&ieee->associate_retry_wq);\r\nrtllib_stop_scan(ieee);\r\nnetif_carrier_off(dev);\r\nmutex_unlock(&ieee->wx_mutex);\r\n} else {\r\nnetdev_info(dev, "ieee->state is NOT LINKED\n");\r\nrtllib_softmac_stop_protocol(priv->rtllib, 0, true);\r\n}\r\nrtl92e_dm_backup_state(dev);\r\nmutex_unlock(&priv->wx_mutex);\r\nRT_TRACE(COMP_RESET,\r\n"%s():<==========down process is finished\n",\r\n__func__);\r\nRT_TRACE(COMP_RESET, "%s():<===========up process start\n",\r\n__func__);\r\nreset_status = _rtl92e_up(dev, true);\r\nRT_TRACE(COMP_RESET,\r\n"%s():<===========up process is finished\n", __func__);\r\nif (reset_status == -1) {\r\nif (reset_times < 3) {\r\nreset_times++;\r\ngoto RESET_START;\r\n} else {\r\nnetdev_warn(dev, "%s(): Reset Failed\n",\r\n__func__);\r\n}\r\n}\r\nieee->is_silent_reset = 1;\r\nspin_lock_irqsave(&priv->rf_ps_lock, flag);\r\npriv->RFChangeInProgress = false;\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\r\nrtl92e_enable_hw_security_config(dev);\r\nif (ieee->state == RTLLIB_LINKED && ieee->iw_mode ==\r\nIW_MODE_INFRA) {\r\nieee->set_chan(ieee->dev,\r\nieee->current_network.channel);\r\nschedule_work(&ieee->associate_complete_wq);\r\n} else if (ieee->state == RTLLIB_LINKED && ieee->iw_mode ==\r\nIW_MODE_ADHOC) {\r\nieee->set_chan(ieee->dev,\r\nieee->current_network.channel);\r\nieee->link_change(ieee->dev);\r\nnotify_wx_assoc_event(ieee);\r\nrtllib_start_send_beacons(ieee);\r\nnetif_carrier_on(ieee->dev);\r\n}\r\nrtl92e_cam_restore(dev);\r\nrtl92e_dm_restore_state(dev);\r\nEND:\r\npriv->ResetProgress = RESET_TYPE_NORESET;\r\npriv->reset_count++;\r\npriv->bForcedSilentReset = false;\r\npriv->bResetInProgress = false;\r\nrtl92e_writeb(dev, UFWP, 1);\r\nRT_TRACE(COMP_RESET, "Reset finished!! ====>[%d]\n",\r\npriv->reset_count);\r\n}\r\n}\r\nstatic void _rtl92e_update_rxcounts(struct r8192_priv *priv, u32 *TotalRxBcnNum,\r\nu32 *TotalRxDataNum)\r\n{\r\nu16 SlotIndex;\r\nu8 i;\r\n*TotalRxBcnNum = 0;\r\n*TotalRxDataNum = 0;\r\nSlotIndex = (priv->rtllib->LinkDetectInfo.SlotIndex++) %\r\n(priv->rtllib->LinkDetectInfo.SlotNum);\r\npriv->rtllib->LinkDetectInfo.RxBcnNum[SlotIndex] =\r\npriv->rtllib->LinkDetectInfo.NumRecvBcnInPeriod;\r\npriv->rtllib->LinkDetectInfo.RxDataNum[SlotIndex] =\r\npriv->rtllib->LinkDetectInfo.NumRecvDataInPeriod;\r\nfor (i = 0; i < priv->rtllib->LinkDetectInfo.SlotNum; i++) {\r\n*TotalRxBcnNum += priv->rtllib->LinkDetectInfo.RxBcnNum[i];\r\n*TotalRxDataNum += priv->rtllib->LinkDetectInfo.RxDataNum[i];\r\n}\r\n}\r\nstatic void _rtl92e_watchdog_wq_cb(void *data)\r\n{\r\nstruct r8192_priv *priv = container_of_dwork_rsl(data,\r\nstruct r8192_priv, watch_dog_wq);\r\nstruct net_device *dev = priv->rtllib->dev;\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nenum reset_type ResetType = RESET_TYPE_NORESET;\r\nstatic u8 check_reset_cnt;\r\nunsigned long flags;\r\nstruct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)\r\n(&priv->rtllib->PowerSaveControl);\r\nbool bBusyTraffic = false;\r\nbool bHigherBusyTraffic = false;\r\nbool bHigherBusyRxTraffic = false;\r\nbool bEnterPS = false;\r\nif (!priv->up || priv->bHwRadioOff)\r\nreturn;\r\nif (priv->rtllib->state >= RTLLIB_LINKED) {\r\nif (priv->rtllib->CntAfterLink < 2)\r\npriv->rtllib->CntAfterLink++;\r\n} else {\r\npriv->rtllib->CntAfterLink = 0;\r\n}\r\nrtl92e_dm_watchdog(dev);\r\nif (rtllib_act_scanning(priv->rtllib, false) == false) {\r\nif ((ieee->iw_mode == IW_MODE_INFRA) && (ieee->state ==\r\nRTLLIB_NOLINK) &&\r\n(ieee->eRFPowerState == eRfOn) && !ieee->is_set_key &&\r\n(!ieee->proto_stoppping) && !ieee->wx_set_enc) {\r\nif ((ieee->PowerSaveControl.ReturnPoint ==\r\nIPS_CALLBACK_NONE) &&\r\n(!ieee->bNetPromiscuousMode)) {\r\nRT_TRACE(COMP_PS,\r\n"====================>haha: rtl92e_ips_enter()\n");\r\nrtl92e_ips_enter(dev);\r\n}\r\n}\r\n}\r\nif ((ieee->state == RTLLIB_LINKED) && (ieee->iw_mode ==\r\nIW_MODE_INFRA) && (!ieee->bNetPromiscuousMode)) {\r\nif (ieee->LinkDetectInfo.NumRxOkInPeriod > 100 ||\r\nieee->LinkDetectInfo.NumTxOkInPeriod > 100)\r\nbBusyTraffic = true;\r\nif (ieee->LinkDetectInfo.NumRxOkInPeriod > 4000 ||\r\nieee->LinkDetectInfo.NumTxOkInPeriod > 4000) {\r\nbHigherBusyTraffic = true;\r\nif (ieee->LinkDetectInfo.NumRxOkInPeriod > 5000)\r\nbHigherBusyRxTraffic = true;\r\nelse\r\nbHigherBusyRxTraffic = false;\r\n}\r\nif (((ieee->LinkDetectInfo.NumRxUnicastOkInPeriod +\r\nieee->LinkDetectInfo.NumTxOkInPeriod) > 8) ||\r\n(ieee->LinkDetectInfo.NumRxUnicastOkInPeriod > 2))\r\nbEnterPS = false;\r\nelse\r\nbEnterPS = true;\r\nif (ieee->current_network.beacon_interval < 95)\r\nbEnterPS = false;\r\nif (bEnterPS)\r\nrtl92e_leisure_ps_enter(dev);\r\nelse\r\nrtl92e_leisure_ps_leave(dev);\r\n} else {\r\nRT_TRACE(COMP_LPS, "====>no link LPS leave\n");\r\nrtl92e_leisure_ps_leave(dev);\r\n}\r\nieee->LinkDetectInfo.NumRxOkInPeriod = 0;\r\nieee->LinkDetectInfo.NumTxOkInPeriod = 0;\r\nieee->LinkDetectInfo.NumRxUnicastOkInPeriod = 0;\r\nieee->LinkDetectInfo.bBusyTraffic = bBusyTraffic;\r\nieee->LinkDetectInfo.bHigherBusyTraffic = bHigherBusyTraffic;\r\nieee->LinkDetectInfo.bHigherBusyRxTraffic = bHigherBusyRxTraffic;\r\nif (ieee->state == RTLLIB_LINKED && ieee->iw_mode == IW_MODE_INFRA) {\r\nu32 TotalRxBcnNum = 0;\r\nu32 TotalRxDataNum = 0;\r\n_rtl92e_update_rxcounts(priv, &TotalRxBcnNum, &TotalRxDataNum);\r\nif ((TotalRxBcnNum + TotalRxDataNum) == 0)\r\npriv->check_roaming_cnt++;\r\nelse\r\npriv->check_roaming_cnt = 0;\r\nif (priv->check_roaming_cnt > 0) {\r\nif (ieee->eRFPowerState == eRfOff)\r\nnetdev_info(dev, "%s(): RF is off\n", __func__);\r\nnetdev_info(dev,\r\n"===>%s(): AP is power off, chan:%d, connect another one\n",\r\n__func__, priv->chan);\r\nieee->state = RTLLIB_ASSOCIATING;\r\nRemovePeerTS(priv->rtllib,\r\npriv->rtllib->current_network.bssid);\r\nieee->is_roaming = true;\r\nieee->is_set_key = false;\r\nieee->link_change(dev);\r\nif (ieee->LedControlHandler)\r\nieee->LedControlHandler(ieee->dev,\r\nLED_CTL_START_TO_LINK);\r\nnotify_wx_assoc_event(ieee);\r\nif (!(ieee->rtllib_ap_sec_type(ieee) &\r\n(SEC_ALG_CCMP | SEC_ALG_TKIP)))\r\nschedule_delayed_work(\r\n&ieee->associate_procedure_wq, 0);\r\npriv->check_roaming_cnt = 0;\r\n}\r\nieee->LinkDetectInfo.NumRecvBcnInPeriod = 0;\r\nieee->LinkDetectInfo.NumRecvDataInPeriod = 0;\r\n}\r\nspin_lock_irqsave(&priv->tx_lock, flags);\r\nif ((check_reset_cnt++ >= 3) && (!ieee->is_roaming) &&\r\n(!priv->RFChangeInProgress) && (!pPSC->bSwRfProcessing)) {\r\nResetType = _rtl92e_if_check_reset(dev);\r\ncheck_reset_cnt = 3;\r\n}\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\nif (!priv->bDisableNormalResetCheck && ResetType == RESET_TYPE_NORMAL) {\r\npriv->ResetProgress = RESET_TYPE_NORMAL;\r\nRT_TRACE(COMP_RESET, "%s(): NOMAL RESET\n", __func__);\r\nreturn;\r\n}\r\nif (((priv->force_reset) || (!priv->bDisableNormalResetCheck &&\r\nResetType == RESET_TYPE_SILENT)))\r\n_rtl92e_if_silent_reset(dev);\r\npriv->force_reset = false;\r\npriv->bForcedSilentReset = false;\r\npriv->bResetInProgress = false;\r\nRT_TRACE(COMP_TRACE, " <==RtUsbCheckForHangWorkItemCallback()\n");\r\n}\r\nstatic void _rtl92e_watchdog_timer_cb(unsigned long data)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv((struct net_device *)data);\r\nschedule_delayed_work(&priv->watch_dog_wq, 0);\r\nmod_timer(&priv->watch_dog_timer, jiffies +\r\nmsecs_to_jiffies(RTLLIB_WATCH_DOG_TIME));\r\n}\r\nvoid rtl92e_rx_enable(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->ops->rx_enable(dev);\r\n}\r\nvoid rtl92e_tx_enable(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->ops->tx_enable(dev);\r\nrtllib_reset_queue(priv->rtllib);\r\n}\r\nstatic void _rtl92e_free_rx_ring(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint i, rx_queue_idx;\r\nfor (rx_queue_idx = 0; rx_queue_idx < MAX_RX_QUEUE;\r\nrx_queue_idx++) {\r\nfor (i = 0; i < priv->rxringcount; i++) {\r\nstruct sk_buff *skb = priv->rx_buf[rx_queue_idx][i];\r\nif (!skb)\r\ncontinue;\r\npci_unmap_single(priv->pdev,\r\n*((dma_addr_t *)skb->cb),\r\npriv->rxbuffersize, PCI_DMA_FROMDEVICE);\r\nkfree_skb(skb);\r\n}\r\npci_free_consistent(priv->pdev,\r\nsizeof(*priv->rx_ring[rx_queue_idx]) *\r\npriv->rxringcount,\r\npriv->rx_ring[rx_queue_idx],\r\npriv->rx_ring_dma[rx_queue_idx]);\r\npriv->rx_ring[rx_queue_idx] = NULL;\r\n}\r\n}\r\nstatic void _rtl92e_free_tx_ring(struct net_device *dev, unsigned int prio)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtl8192_tx_ring *ring = &priv->tx_ring[prio];\r\nwhile (skb_queue_len(&ring->queue)) {\r\nstruct tx_desc *entry = &ring->desc[ring->idx];\r\nstruct sk_buff *skb = __skb_dequeue(&ring->queue);\r\npci_unmap_single(priv->pdev, entry->TxBuffAddr,\r\nskb->len, PCI_DMA_TODEVICE);\r\nkfree_skb(skb);\r\nring->idx = (ring->idx + 1) % ring->entries;\r\n}\r\npci_free_consistent(priv->pdev, sizeof(*ring->desc) * ring->entries,\r\nring->desc, ring->dma);\r\nring->desc = NULL;\r\n}\r\nstatic void _rtl92e_hard_data_xmit(struct sk_buff *skb, struct net_device *dev,\r\nint rate)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint ret;\r\nstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb +\r\nMAX_DEV_ADDR_SIZE);\r\nu8 queue_index = tcb_desc->queue_index;\r\nif ((priv->rtllib->eRFPowerState == eRfOff) || !priv->up ||\r\npriv->bResetInProgress) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (queue_index == TXCMD_QUEUE)\r\nnetdev_warn(dev, "%s(): queue index == TXCMD_QUEUE\n",\r\n__func__);\r\nmemcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));\r\nskb_push(skb, priv->rtllib->tx_headroom);\r\nret = _rtl92e_tx(dev, skb);\r\nif (ret != 0)\r\nkfree_skb(skb);\r\nif (queue_index != MGNT_QUEUE) {\r\npriv->rtllib->stats.tx_bytes += (skb->len -\r\npriv->rtllib->tx_headroom);\r\npriv->rtllib->stats.tx_packets++;\r\n}\r\n}\r\nstatic int _rtl92e_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint ret;\r\nstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb +\r\nMAX_DEV_ADDR_SIZE);\r\nu8 queue_index = tcb_desc->queue_index;\r\nif (queue_index != TXCMD_QUEUE) {\r\nif ((priv->rtllib->eRFPowerState == eRfOff) ||\r\n!priv->up || priv->bResetInProgress) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\n}\r\nmemcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));\r\nif (queue_index == TXCMD_QUEUE) {\r\n_rtl92e_tx_cmd(dev, skb);\r\nreturn 0;\r\n}\r\ntcb_desc->RATRIndex = 7;\r\ntcb_desc->bTxDisableRateFallBack = 1;\r\ntcb_desc->bTxUseDriverAssingedRate = 1;\r\ntcb_desc->bTxEnableFwCalcDur = 1;\r\nskb_push(skb, priv->rtllib->tx_headroom);\r\nret = _rtl92e_tx(dev, skb);\r\nif (ret != 0)\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic void _rtl92e_tx_isr(struct net_device *dev, int prio)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtl8192_tx_ring *ring = &priv->tx_ring[prio];\r\nwhile (skb_queue_len(&ring->queue)) {\r\nstruct tx_desc *entry = &ring->desc[ring->idx];\r\nstruct sk_buff *skb;\r\nif (prio != BEACON_QUEUE) {\r\nif (entry->OWN)\r\nreturn;\r\nring->idx = (ring->idx + 1) % ring->entries;\r\n}\r\nskb = __skb_dequeue(&ring->queue);\r\npci_unmap_single(priv->pdev, entry->TxBuffAddr,\r\nskb->len, PCI_DMA_TODEVICE);\r\nkfree_skb(skb);\r\n}\r\nif (prio != BEACON_QUEUE)\r\ntasklet_schedule(&priv->irq_tx_tasklet);\r\n}\r\nstatic void _rtl92e_tx_cmd(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtl8192_tx_ring *ring;\r\nstruct tx_desc_cmd *entry;\r\nunsigned int idx;\r\nstruct cb_desc *tcb_desc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->irq_th_lock, flags);\r\nring = &priv->tx_ring[TXCMD_QUEUE];\r\nidx = (ring->idx + skb_queue_len(&ring->queue)) % ring->entries;\r\nentry = (struct tx_desc_cmd *)&ring->desc[idx];\r\ntcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\r\npriv->ops->tx_fill_cmd_descriptor(dev, entry, tcb_desc, skb);\r\n__skb_queue_tail(&ring->queue, skb);\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\n}\r\nstatic short _rtl92e_tx(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtl8192_tx_ring *ring;\r\nunsigned long flags;\r\nstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb +\r\nMAX_DEV_ADDR_SIZE);\r\nstruct tx_desc *pdesc = NULL;\r\nstruct rtllib_hdr_1addr *header = NULL;\r\nu16 fc = 0, type = 0, stype = 0;\r\nbool multi_addr = false, broad_addr = false, uni_addr = false;\r\nu8 *pda_addr = NULL;\r\nint idx;\r\nu32 fwinfo_size = 0;\r\nif (priv->bdisable_nic) {\r\nnetdev_warn(dev, "%s: Nic is disabled! Can't tx packet.\n",\r\n__func__);\r\nreturn skb->len;\r\n}\r\npriv->rtllib->bAwakePktSent = true;\r\nfwinfo_size = sizeof(struct tx_fwinfo_8190pci);\r\nheader = (struct rtllib_hdr_1addr *)(((u8 *)skb->data) + fwinfo_size);\r\nfc = le16_to_cpu(header->frame_ctl);\r\ntype = WLAN_FC_GET_TYPE(fc);\r\nstype = WLAN_FC_GET_STYPE(fc);\r\npda_addr = header->addr1;\r\nif (is_broadcast_ether_addr(pda_addr))\r\nbroad_addr = true;\r\nelse if (is_multicast_ether_addr(pda_addr))\r\nmulti_addr = true;\r\nelse\r\nuni_addr = true;\r\nif (uni_addr)\r\npriv->stats.txbytesunicast += skb->len - fwinfo_size;\r\nelse if (multi_addr)\r\npriv->stats.txbytesmulticast += skb->len - fwinfo_size;\r\nelse\r\npriv->stats.txbytesbroadcast += skb->len - fwinfo_size;\r\nspin_lock_irqsave(&priv->irq_th_lock, flags);\r\nring = &priv->tx_ring[tcb_desc->queue_index];\r\nif (tcb_desc->queue_index != BEACON_QUEUE)\r\nidx = (ring->idx + skb_queue_len(&ring->queue)) % ring->entries;\r\nelse\r\nidx = 0;\r\npdesc = &ring->desc[idx];\r\nif ((pdesc->OWN == 1) && (tcb_desc->queue_index != BEACON_QUEUE)) {\r\nnetdev_warn(dev,\r\n"No more TX desc@%d, ring->idx = %d, idx = %d, skblen = 0x%x queuelen=%d",\r\ntcb_desc->queue_index, ring->idx, idx, skb->len,\r\nskb_queue_len(&ring->queue));\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\nreturn skb->len;\r\n}\r\nif (type == RTLLIB_FTYPE_DATA) {\r\nif (priv->rtllib->LedControlHandler)\r\npriv->rtllib->LedControlHandler(dev, LED_CTL_TX);\r\n}\r\npriv->ops->tx_fill_descriptor(dev, pdesc, tcb_desc, skb);\r\n__skb_queue_tail(&ring->queue, skb);\r\npdesc->OWN = 1;\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\nnetif_trans_update(dev);\r\nrtl92e_writew(dev, TPPoll, 0x01 << tcb_desc->queue_index);\r\nreturn 0;\r\n}\r\nstatic short _rtl92e_alloc_rx_ring(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rx_desc *entry = NULL;\r\nint i, rx_queue_idx;\r\nfor (rx_queue_idx = 0; rx_queue_idx < MAX_RX_QUEUE; rx_queue_idx++) {\r\npriv->rx_ring[rx_queue_idx] = pci_zalloc_consistent(priv->pdev,\r\nsizeof(*priv->rx_ring[rx_queue_idx]) * priv->rxringcount,\r\n&priv->rx_ring_dma[rx_queue_idx]);\r\nif (!priv->rx_ring[rx_queue_idx] ||\r\n(unsigned long)priv->rx_ring[rx_queue_idx] & 0xFF) {\r\nnetdev_warn(dev, "Cannot allocate RX ring\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->rx_idx[rx_queue_idx] = 0;\r\nfor (i = 0; i < priv->rxringcount; i++) {\r\nstruct sk_buff *skb = dev_alloc_skb(priv->rxbuffersize);\r\ndma_addr_t *mapping;\r\nentry = &priv->rx_ring[rx_queue_idx][i];\r\nif (!skb)\r\nreturn 0;\r\nskb->dev = dev;\r\npriv->rx_buf[rx_queue_idx][i] = skb;\r\nmapping = (dma_addr_t *)skb->cb;\r\n*mapping = pci_map_single(priv->pdev,\r\nskb_tail_pointer_rsl(skb),\r\npriv->rxbuffersize,\r\nPCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(priv->pdev, *mapping)) {\r\ndev_kfree_skb_any(skb);\r\nreturn -1;\r\n}\r\nentry->BufferAddress = *mapping;\r\nentry->Length = priv->rxbuffersize;\r\nentry->OWN = 1;\r\n}\r\nif (entry)\r\nentry->EOR = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int _rtl92e_alloc_tx_ring(struct net_device *dev, unsigned int prio,\r\nunsigned int entries)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct tx_desc *ring;\r\ndma_addr_t dma;\r\nint i;\r\nring = pci_zalloc_consistent(priv->pdev, sizeof(*ring) * entries, &dma);\r\nif (!ring || (unsigned long)ring & 0xFF) {\r\nnetdev_warn(dev, "Cannot allocate TX ring (prio = %d)\n", prio);\r\nreturn -ENOMEM;\r\n}\r\npriv->tx_ring[prio].desc = ring;\r\npriv->tx_ring[prio].dma = dma;\r\npriv->tx_ring[prio].idx = 0;\r\npriv->tx_ring[prio].entries = entries;\r\nskb_queue_head_init(&priv->tx_ring[prio].queue);\r\nfor (i = 0; i < entries; i++)\r\nring[i].NextDescAddress =\r\n(u32)dma + ((i + 1) % entries) *\r\nsizeof(*ring);\r\nreturn 0;\r\n}\r\nstatic short _rtl92e_pci_initdescring(struct net_device *dev)\r\n{\r\nu32 ret;\r\nint i;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nret = _rtl92e_alloc_rx_ring(dev);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < MAX_TX_QUEUE_COUNT; i++) {\r\nret = _rtl92e_alloc_tx_ring(dev, i, priv->txringcount);\r\nif (ret)\r\ngoto err_free_rings;\r\n}\r\nreturn 0;\r\nerr_free_rings:\r\n_rtl92e_free_rx_ring(dev);\r\nfor (i = 0; i < MAX_TX_QUEUE_COUNT; i++)\r\nif (priv->tx_ring[i].desc)\r\n_rtl92e_free_tx_ring(dev, i);\r\nreturn 1;\r\n}\r\nvoid rtl92e_reset_desc_ring(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint i, rx_queue_idx;\r\nunsigned long flags = 0;\r\nfor (rx_queue_idx = 0; rx_queue_idx < MAX_RX_QUEUE; rx_queue_idx++) {\r\nif (priv->rx_ring[rx_queue_idx]) {\r\nstruct rx_desc *entry = NULL;\r\nfor (i = 0; i < priv->rxringcount; i++) {\r\nentry = &priv->rx_ring[rx_queue_idx][i];\r\nentry->OWN = 1;\r\n}\r\npriv->rx_idx[rx_queue_idx] = 0;\r\n}\r\n}\r\nspin_lock_irqsave(&priv->irq_th_lock, flags);\r\nfor (i = 0; i < MAX_TX_QUEUE_COUNT; i++) {\r\nif (priv->tx_ring[i].desc) {\r\nstruct rtl8192_tx_ring *ring = &priv->tx_ring[i];\r\nwhile (skb_queue_len(&ring->queue)) {\r\nstruct tx_desc *entry = &ring->desc[ring->idx];\r\nstruct sk_buff *skb =\r\n__skb_dequeue(&ring->queue);\r\npci_unmap_single(priv->pdev,\r\nentry->TxBuffAddr,\r\nskb->len, PCI_DMA_TODEVICE);\r\nkfree_skb(skb);\r\nring->idx = (ring->idx + 1) % ring->entries;\r\n}\r\nring->idx = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\n}\r\nvoid rtl92e_update_rx_pkt_timestamp(struct net_device *dev,\r\nstruct rtllib_rx_stats *stats)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (stats->bIsAMPDU && !stats->bFirstMPDU)\r\nstats->mac_time = priv->LastRxDescTSF;\r\nelse\r\npriv->LastRxDescTSF = stats->mac_time;\r\n}\r\nlong rtl92e_translate_to_dbm(struct r8192_priv *priv, u8 signal_strength_index)\r\n{\r\nlong signal_power;\r\nsignal_power = (long)((signal_strength_index + 1) >> 1);\r\nsignal_power -= 95;\r\nreturn signal_power;\r\n}\r\nvoid rtl92e_update_rx_statistics(struct r8192_priv *priv,\r\nstruct rtllib_rx_stats *pprevious_stats)\r\n{\r\nint weighting = 0;\r\nif (priv->stats.recv_signal_power == 0)\r\npriv->stats.recv_signal_power =\r\npprevious_stats->RecvSignalPower;\r\nif (pprevious_stats->RecvSignalPower > priv->stats.recv_signal_power)\r\nweighting = 5;\r\nelse if (pprevious_stats->RecvSignalPower <\r\npriv->stats.recv_signal_power)\r\nweighting = (-5);\r\npriv->stats.recv_signal_power = (priv->stats.recv_signal_power * 5 +\r\npprevious_stats->RecvSignalPower +\r\nweighting) / 6;\r\n}\r\nu8 rtl92e_rx_db_to_percent(s8 antpower)\r\n{\r\nif ((antpower <= -100) || (antpower >= 20))\r\nreturn 0;\r\nelse if (antpower >= 0)\r\nreturn 100;\r\nelse\r\nreturn 100 + antpower;\r\n}\r\nu8 rtl92e_evm_db_to_percent(s8 value)\r\n{\r\ns8 ret_val;\r\nret_val = value;\r\nif (ret_val >= 0)\r\nret_val = 0;\r\nif (ret_val <= -33)\r\nret_val = -33;\r\nret_val = 0 - ret_val;\r\nret_val *= 3;\r\nif (ret_val == 99)\r\nret_val = 100;\r\nreturn ret_val;\r\n}\r\nvoid rtl92e_copy_mpdu_stats(struct rtllib_rx_stats *psrc_stats,\r\nstruct rtllib_rx_stats *ptarget_stats)\r\n{\r\nptarget_stats->bIsAMPDU = psrc_stats->bIsAMPDU;\r\nptarget_stats->bFirstMPDU = psrc_stats->bFirstMPDU;\r\n}\r\nstatic void _rtl92e_rx_normal(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_hdr_1addr *rtllib_hdr = NULL;\r\nbool unicast_packet = false;\r\nbool bLedBlinking = true;\r\nu16 fc = 0, type = 0;\r\nu32 skb_len = 0;\r\nint rx_queue_idx = RX_MPDU_QUEUE;\r\nstruct rtllib_rx_stats stats = {\r\n.signal = 0,\r\n.noise = (u8)-98,\r\n.rate = 0,\r\n.freq = RTLLIB_24GHZ_BAND,\r\n};\r\nunsigned int count = priv->rxringcount;\r\nstats.nic_type = NIC_8192E;\r\nwhile (count--) {\r\nstruct rx_desc *pdesc = &priv->rx_ring[rx_queue_idx]\r\n[priv->rx_idx[rx_queue_idx]];\r\nstruct sk_buff *skb = priv->rx_buf[rx_queue_idx]\r\n[priv->rx_idx[rx_queue_idx]];\r\nstruct sk_buff *new_skb;\r\nif (pdesc->OWN)\r\nreturn;\r\nif (!priv->ops->rx_query_status_descriptor(dev, &stats,\r\npdesc, skb))\r\ngoto done;\r\nnew_skb = dev_alloc_skb(priv->rxbuffersize);\r\nif (unlikely(!new_skb))\r\ngoto done;\r\npci_unmap_single(priv->pdev,\r\n*((dma_addr_t *)skb->cb),\r\npriv->rxbuffersize,\r\nPCI_DMA_FROMDEVICE);\r\nskb_put(skb, pdesc->Length);\r\nskb_reserve(skb, stats.RxDrvInfoSize +\r\nstats.RxBufShift);\r\nskb_trim(skb, skb->len - 4);\r\nrtllib_hdr = (struct rtllib_hdr_1addr *)skb->data;\r\nif (!is_multicast_ether_addr(rtllib_hdr->addr1)) {\r\nunicast_packet = true;\r\n}\r\nfc = le16_to_cpu(rtllib_hdr->frame_ctl);\r\ntype = WLAN_FC_GET_TYPE(fc);\r\nif (type == RTLLIB_FTYPE_MGMT)\r\nbLedBlinking = false;\r\nif (bLedBlinking)\r\nif (priv->rtllib->LedControlHandler)\r\npriv->rtllib->LedControlHandler(dev,\r\nLED_CTL_RX);\r\nif (stats.bCRC) {\r\nif (type != RTLLIB_FTYPE_MGMT)\r\npriv->stats.rxdatacrcerr++;\r\nelse\r\npriv->stats.rxmgmtcrcerr++;\r\n}\r\nskb_len = skb->len;\r\nif (!rtllib_rx(priv->rtllib, skb, &stats)) {\r\ndev_kfree_skb_any(skb);\r\n} else {\r\npriv->stats.rxok++;\r\nif (unicast_packet)\r\npriv->stats.rxbytesunicast += skb_len;\r\n}\r\nskb = new_skb;\r\nskb->dev = dev;\r\npriv->rx_buf[rx_queue_idx][priv->rx_idx[rx_queue_idx]] =\r\nskb;\r\n*((dma_addr_t *)skb->cb) = pci_map_single(priv->pdev,\r\nskb_tail_pointer_rsl(skb),\r\npriv->rxbuffersize,\r\nPCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(priv->pdev,\r\n*((dma_addr_t *)skb->cb))) {\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\ndone:\r\npdesc->BufferAddress = *((dma_addr_t *)skb->cb);\r\npdesc->OWN = 1;\r\npdesc->Length = priv->rxbuffersize;\r\nif (priv->rx_idx[rx_queue_idx] == priv->rxringcount - 1)\r\npdesc->EOR = 1;\r\npriv->rx_idx[rx_queue_idx] = (priv->rx_idx[rx_queue_idx] + 1) %\r\npriv->rxringcount;\r\n}\r\n}\r\nstatic void _rtl92e_tx_resume(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nstruct sk_buff *skb;\r\nint queue_index;\r\nfor (queue_index = BK_QUEUE;\r\nqueue_index < MAX_QUEUE_SIZE; queue_index++) {\r\nwhile ((!skb_queue_empty(&ieee->skb_waitQ[queue_index])) &&\r\n(priv->rtllib->check_nic_enough_desc(dev, queue_index) > 0)) {\r\nskb = skb_dequeue(&ieee->skb_waitQ[queue_index]);\r\nieee->softmac_data_hard_start_xmit(skb, dev, 0);\r\n}\r\n}\r\n}\r\nstatic void _rtl92e_irq_tx_tasklet(struct r8192_priv *priv)\r\n{\r\n_rtl92e_tx_resume(priv->rtllib->dev);\r\n}\r\nstatic void _rtl92e_irq_rx_tasklet(struct r8192_priv *priv)\r\n{\r\n_rtl92e_rx_normal(priv->rtllib->dev);\r\nrtl92e_writel(priv->rtllib->dev, INTA_MASK,\r\nrtl92e_readl(priv->rtllib->dev, INTA_MASK) | IMR_RDU);\r\n}\r\nstatic void _rtl92e_cancel_deferred_work(struct r8192_priv *priv)\r\n{\r\ncancel_delayed_work_sync(&priv->watch_dog_wq);\r\ncancel_delayed_work_sync(&priv->update_beacon_wq);\r\ncancel_delayed_work(&priv->rtllib->hw_sleep_wq);\r\ncancel_work_sync(&priv->reset_wq);\r\ncancel_work_sync(&priv->qos_activate);\r\n}\r\nstatic int _rtl92e_up(struct net_device *dev, bool is_silent_reset)\r\n{\r\nif (_rtl92e_sta_up(dev, is_silent_reset) == -1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int _rtl92e_open(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint ret;\r\nmutex_lock(&priv->wx_mutex);\r\nret = _rtl92e_try_up(dev);\r\nmutex_unlock(&priv->wx_mutex);\r\nreturn ret;\r\n}\r\nstatic int _rtl92e_try_up(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->up == 1)\r\nreturn -1;\r\nreturn _rtl92e_up(dev, false);\r\n}\r\nstatic int _rtl92e_close(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint ret;\r\nif ((rtllib_act_scanning(priv->rtllib, false)) &&\r\n!(priv->rtllib->softmac_features & IEEE_SOFTMAC_SCAN)) {\r\nrtllib_stop_scan(priv->rtllib);\r\n}\r\nmutex_lock(&priv->wx_mutex);\r\nret = _rtl92e_down(dev, true);\r\nmutex_unlock(&priv->wx_mutex);\r\nreturn ret;\r\n}\r\nstatic int _rtl92e_down(struct net_device *dev, bool shutdownrf)\r\n{\r\nif (_rtl92e_sta_down(dev, shutdownrf) == -1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nvoid rtl92e_commit(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->up == 0)\r\nreturn;\r\nrtllib_softmac_stop_protocol(priv->rtllib, 0, true);\r\nrtl92e_irq_disable(dev);\r\npriv->ops->stop_adapter(dev, true);\r\n_rtl92e_up(dev, false);\r\n}\r\nstatic void _rtl92e_restart(void *data)\r\n{\r\nstruct r8192_priv *priv = container_of_work_rsl(data, struct r8192_priv,\r\nreset_wq);\r\nstruct net_device *dev = priv->rtllib->dev;\r\nmutex_lock(&priv->wx_mutex);\r\nrtl92e_commit(dev);\r\nmutex_unlock(&priv->wx_mutex);\r\n}\r\nstatic void _rtl92e_set_multicast(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nshort promisc;\r\npromisc = (dev->flags & IFF_PROMISC) ? 1 : 0;\r\npriv->promisc = promisc;\r\n}\r\nstatic int _rtl92e_set_mac_adr(struct net_device *dev, void *mac)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct sockaddr *addr = mac;\r\nmutex_lock(&priv->wx_mutex);\r\nether_addr_copy(dev->dev_addr, addr->sa_data);\r\nschedule_work(&priv->reset_wq);\r\nmutex_unlock(&priv->wx_mutex);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t _rtl92e_irq(int irq, void *netdev)\r\n{\r\nstruct net_device *dev = netdev;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nunsigned long flags;\r\nu32 inta;\r\nu32 intb;\r\nintb = 0;\r\nif (priv->irq_enabled == 0)\r\ngoto done;\r\nspin_lock_irqsave(&priv->irq_th_lock, flags);\r\npriv->ops->interrupt_recognized(dev, &inta, &intb);\r\npriv->stats.shints++;\r\nif (!inta) {\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\ngoto done;\r\n}\r\nif (inta == 0xffff) {\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\ngoto done;\r\n}\r\npriv->stats.ints++;\r\nif (!netif_running(dev)) {\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\ngoto done;\r\n}\r\nif (inta & IMR_TBDOK) {\r\nRT_TRACE(COMP_INTR, "beacon ok interrupt!\n");\r\npriv->stats.txbeaconokint++;\r\n}\r\nif (inta & IMR_TBDER) {\r\nRT_TRACE(COMP_INTR, "beacon ok interrupt!\n");\r\npriv->stats.txbeaconerr++;\r\n}\r\nif (inta & IMR_BDOK)\r\nRT_TRACE(COMP_INTR, "beacon interrupt!\n");\r\nif (inta & IMR_MGNTDOK) {\r\nRT_TRACE(COMP_INTR, "Manage ok interrupt!\n");\r\npriv->stats.txmanageokint++;\r\n_rtl92e_tx_isr(dev, MGNT_QUEUE);\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\nif (priv->rtllib->ack_tx_to_ieee) {\r\nif (_rtl92e_is_tx_queue_empty(dev)) {\r\npriv->rtllib->ack_tx_to_ieee = 0;\r\nrtllib_ps_tx_ack(priv->rtllib, 1);\r\n}\r\n}\r\nspin_lock_irqsave(&priv->irq_th_lock, flags);\r\n}\r\nif (inta & IMR_COMDOK) {\r\npriv->stats.txcmdpktokint++;\r\n_rtl92e_tx_isr(dev, TXCMD_QUEUE);\r\n}\r\nif (inta & IMR_HIGHDOK)\r\n_rtl92e_tx_isr(dev, HIGH_QUEUE);\r\nif (inta & IMR_ROK) {\r\npriv->stats.rxint++;\r\npriv->InterruptLog.nIMR_ROK++;\r\ntasklet_schedule(&priv->irq_rx_tasklet);\r\n}\r\nif (inta & IMR_BcnInt) {\r\nRT_TRACE(COMP_INTR, "prepare beacon for interrupt!\n");\r\ntasklet_schedule(&priv->irq_prepare_beacon_tasklet);\r\n}\r\nif (inta & IMR_RDU) {\r\nRT_TRACE(COMP_INTR, "rx descriptor unavailable!\n");\r\npriv->stats.rxrdu++;\r\nrtl92e_writel(dev, INTA_MASK,\r\nrtl92e_readl(dev, INTA_MASK) & ~IMR_RDU);\r\ntasklet_schedule(&priv->irq_rx_tasklet);\r\n}\r\nif (inta & IMR_RXFOVW) {\r\nRT_TRACE(COMP_INTR, "rx overflow !\n");\r\npriv->stats.rxoverflow++;\r\ntasklet_schedule(&priv->irq_rx_tasklet);\r\n}\r\nif (inta & IMR_TXFOVW)\r\npriv->stats.txoverflow++;\r\nif (inta & IMR_BKDOK) {\r\nRT_TRACE(COMP_INTR, "BK Tx OK interrupt!\n");\r\npriv->stats.txbkokint++;\r\npriv->rtllib->LinkDetectInfo.NumTxOkInPeriod++;\r\n_rtl92e_tx_isr(dev, BK_QUEUE);\r\n}\r\nif (inta & IMR_BEDOK) {\r\nRT_TRACE(COMP_INTR, "BE TX OK interrupt!\n");\r\npriv->stats.txbeokint++;\r\npriv->rtllib->LinkDetectInfo.NumTxOkInPeriod++;\r\n_rtl92e_tx_isr(dev, BE_QUEUE);\r\n}\r\nif (inta & IMR_VIDOK) {\r\nRT_TRACE(COMP_INTR, "VI TX OK interrupt!\n");\r\npriv->stats.txviokint++;\r\npriv->rtllib->LinkDetectInfo.NumTxOkInPeriod++;\r\n_rtl92e_tx_isr(dev, VI_QUEUE);\r\n}\r\nif (inta & IMR_VODOK) {\r\npriv->stats.txvookint++;\r\nRT_TRACE(COMP_INTR, "Vo TX OK interrupt!\n");\r\npriv->rtllib->LinkDetectInfo.NumTxOkInPeriod++;\r\n_rtl92e_tx_isr(dev, VO_QUEUE);\r\n}\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\ndone:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int _rtl92e_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nunsigned long ioaddr = 0;\r\nstruct net_device *dev = NULL;\r\nstruct r8192_priv *priv = NULL;\r\nstruct rtl819x_ops *ops = (struct rtl819x_ops *)(id->driver_data);\r\nunsigned long pmem_start, pmem_len, pmem_flags;\r\nint err = -ENOMEM;\r\nu8 revision_id;\r\nRT_TRACE(COMP_INIT, "Configuring chip resources");\r\nif (pci_enable_device(pdev)) {\r\ndev_err(&pdev->dev, "Failed to enable PCI device");\r\nreturn -EIO;\r\n}\r\npci_set_master(pdev);\r\nif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nif (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\ndev_info(&pdev->dev,\r\n"Unable to obtain 32bit DMA for consistent allocations\n");\r\ngoto err_pci_disable;\r\n}\r\n}\r\ndev = alloc_rtllib(sizeof(struct r8192_priv));\r\nif (!dev)\r\ngoto err_pci_disable;\r\nerr = -ENODEV;\r\npci_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\npriv = rtllib_priv(dev);\r\npriv->rtllib = (struct rtllib_device *)netdev_priv_rsl(dev);\r\npriv->pdev = pdev;\r\npriv->rtllib->pdev = pdev;\r\nif ((pdev->subsystem_vendor == PCI_VENDOR_ID_DLINK) &&\r\n(pdev->subsystem_device == 0x3304))\r\npriv->rtllib->bSupportRemoteWakeUp = 1;\r\nelse\r\npriv->rtllib->bSupportRemoteWakeUp = 0;\r\npmem_start = pci_resource_start(pdev, 1);\r\npmem_len = pci_resource_len(pdev, 1);\r\npmem_flags = pci_resource_flags(pdev, 1);\r\nif (!(pmem_flags & IORESOURCE_MEM)) {\r\nnetdev_err(dev, "region #1 not a MMIO resource, aborting");\r\ngoto err_rel_rtllib;\r\n}\r\ndev_info(&pdev->dev, "Memory mapped space start: 0x%08lx\n",\r\npmem_start);\r\nif (!request_mem_region(pmem_start, pmem_len, DRV_NAME)) {\r\nnetdev_err(dev, "request_mem_region failed!");\r\ngoto err_rel_rtllib;\r\n}\r\nioaddr = (unsigned long)ioremap_nocache(pmem_start, pmem_len);\r\nif (ioaddr == (unsigned long)NULL) {\r\nnetdev_err(dev, "ioremap failed!");\r\ngoto err_rel_mem;\r\n}\r\ndev->mem_start = ioaddr;\r\ndev->mem_end = ioaddr + pci_resource_len(pdev, 0);\r\npci_read_config_byte(pdev, 0x08, &revision_id);\r\nif (pdev->device == 0x8192 && revision_id == 0x10)\r\ngoto err_unmap;\r\npriv->ops = ops;\r\nif (rtl92e_check_adapter(pdev, dev) == false)\r\ngoto err_unmap;\r\ndev->irq = pdev->irq;\r\npriv->irq = 0;\r\ndev->netdev_ops = &rtl8192_netdev_ops;\r\ndev->wireless_handlers = &r8192_wx_handlers_def;\r\ndev->ethtool_ops = &rtl819x_ethtool_ops;\r\ndev->type = ARPHRD_ETHER;\r\ndev->watchdog_timeo = HZ * 3;\r\nif (dev_alloc_name(dev, ifname) < 0) {\r\nRT_TRACE(COMP_INIT,\r\n"Oops: devname already taken! Trying wlan%%d...\n");\r\ndev_alloc_name(dev, ifname);\r\n}\r\nRT_TRACE(COMP_INIT, "Driver probe completed1\n");\r\nif (_rtl92e_init(dev) != 0) {\r\nnetdev_warn(dev, "Initialization failed");\r\ngoto err_free_irq;\r\n}\r\nnetif_carrier_off(dev);\r\nnetif_stop_queue(dev);\r\nif (register_netdev(dev))\r\ngoto err_free_irq;\r\nRT_TRACE(COMP_INIT, "dev name: %s\n", dev->name);\r\nif (priv->polling_timer_on == 0)\r\nrtl92e_check_rfctrl_gpio_timer((unsigned long)dev);\r\nRT_TRACE(COMP_INIT, "Driver probe completed\n");\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(dev->irq, dev);\r\npriv->irq = 0;\r\nerr_unmap:\r\niounmap((void __iomem *)ioaddr);\r\nerr_rel_mem:\r\nrelease_mem_region(pmem_start, pmem_len);\r\nerr_rel_rtllib:\r\nfree_rtllib(dev);\r\nerr_pci_disable:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void _rtl92e_pci_disconnect(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct r8192_priv *priv;\r\nu32 i;\r\nif (dev) {\r\nunregister_netdev(dev);\r\npriv = rtllib_priv(dev);\r\ndel_timer_sync(&priv->gpio_polling_timer);\r\ncancel_delayed_work_sync(&priv->gpio_change_rf_wq);\r\npriv->polling_timer_on = 0;\r\n_rtl92e_down(dev, true);\r\nrtl92e_dm_deinit(dev);\r\nvfree(priv->pFirmware);\r\npriv->pFirmware = NULL;\r\n_rtl92e_free_rx_ring(dev);\r\nfor (i = 0; i < MAX_TX_QUEUE_COUNT; i++)\r\n_rtl92e_free_tx_ring(dev, i);\r\nif (priv->irq) {\r\ndev_info(&pdev->dev, "Freeing irq %d\n", dev->irq);\r\nfree_irq(dev->irq, dev);\r\npriv->irq = 0;\r\n}\r\nfree_rtllib(dev);\r\nif (dev->mem_start != 0) {\r\niounmap((void __iomem *)dev->mem_start);\r\nrelease_mem_region(pci_resource_start(pdev, 1),\r\npci_resource_len(pdev, 1));\r\n}\r\n} else {\r\npriv = rtllib_priv(dev);\r\n}\r\npci_disable_device(pdev);\r\nRT_TRACE(COMP_DOWN, "wlan driver removed\n");\r\n}\r\nbool rtl92e_enable_nic(struct net_device *dev)\r\n{\r\nbool init_status = true;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)\r\n(&priv->rtllib->PowerSaveControl);\r\nif (!priv->up) {\r\nnetdev_warn(dev, "%s(): Driver is already down!\n", __func__);\r\npriv->bdisable_nic = false;\r\nreturn false;\r\n}\r\nRT_TRACE(COMP_PS, "===========>%s()\n", __func__);\r\npriv->bfirst_init = true;\r\ninit_status = priv->ops->initialize_adapter(dev);\r\nif (!init_status) {\r\nnetdev_warn(dev, "%s(): Initialization failed!\n", __func__);\r\npriv->bdisable_nic = false;\r\nreturn false;\r\n}\r\nRT_TRACE(COMP_INIT, "start adapter finished\n");\r\nRT_CLEAR_PS_LEVEL(pPSC, RT_RF_OFF_LEVL_HALT_NIC);\r\npriv->bfirst_init = false;\r\nrtl92e_irq_enable(dev);\r\npriv->bdisable_nic = false;\r\nRT_TRACE(COMP_PS, "<===========%s()\n", __func__);\r\nreturn init_status;\r\n}\r\nbool rtl92e_disable_nic(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 tmp_state = 0;\r\nRT_TRACE(COMP_PS, "=========>%s()\n", __func__);\r\npriv->bdisable_nic = true;\r\ntmp_state = priv->rtllib->state;\r\nrtllib_softmac_stop_protocol(priv->rtllib, 0, false);\r\npriv->rtllib->state = tmp_state;\r\n_rtl92e_cancel_deferred_work(priv);\r\nrtl92e_irq_disable(dev);\r\npriv->ops->stop_adapter(dev, false);\r\nRT_TRACE(COMP_PS, "<=========%s()\n", __func__);\r\nreturn true;\r\n}\r\nvoid rtl92e_check_rfctrl_gpio_timer(unsigned long data)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv((struct net_device *)data);\r\npriv->polling_timer_on = 1;\r\nschedule_delayed_work(&priv->gpio_change_rf_wq, 0);\r\nmod_timer(&priv->gpio_polling_timer, jiffies +\r\nmsecs_to_jiffies(RTLLIB_WATCH_DOG_TIME));\r\n}
