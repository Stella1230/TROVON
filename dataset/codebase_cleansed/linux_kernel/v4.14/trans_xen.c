static int p9_xen_cancel(struct p9_client *client, struct p9_req_t *req)\r\n{\r\nreturn 1;\r\n}\r\nstatic int p9_xen_create(struct p9_client *client, const char *addr, char *args)\r\n{\r\nstruct xen_9pfs_front_priv *priv;\r\nread_lock(&xen_9pfs_lock);\r\nlist_for_each_entry(priv, &xen_9pfs_devs, list) {\r\nif (!strcmp(priv->tag, addr)) {\r\npriv->client = client;\r\nread_unlock(&xen_9pfs_lock);\r\nreturn 0;\r\n}\r\n}\r\nread_unlock(&xen_9pfs_lock);\r\nreturn -EINVAL;\r\n}\r\nstatic void p9_xen_close(struct p9_client *client)\r\n{\r\nstruct xen_9pfs_front_priv *priv;\r\nread_lock(&xen_9pfs_lock);\r\nlist_for_each_entry(priv, &xen_9pfs_devs, list) {\r\nif (priv->client == client) {\r\npriv->client = NULL;\r\nread_unlock(&xen_9pfs_lock);\r\nreturn;\r\n}\r\n}\r\nread_unlock(&xen_9pfs_lock);\r\n}\r\nstatic bool p9_xen_write_todo(struct xen_9pfs_dataring *ring, RING_IDX size)\r\n{\r\nRING_IDX cons, prod;\r\ncons = ring->intf->out_cons;\r\nprod = ring->intf->out_prod;\r\nvirt_mb();\r\nreturn XEN_9PFS_RING_SIZE -\r\nxen_9pfs_queued(prod, cons, XEN_9PFS_RING_SIZE) >= size;\r\n}\r\nstatic int p9_xen_request(struct p9_client *client, struct p9_req_t *p9_req)\r\n{\r\nstruct xen_9pfs_front_priv *priv = NULL;\r\nRING_IDX cons, prod, masked_cons, masked_prod;\r\nunsigned long flags;\r\nu32 size = p9_req->tc->size;\r\nstruct xen_9pfs_dataring *ring;\r\nint num;\r\nread_lock(&xen_9pfs_lock);\r\nlist_for_each_entry(priv, &xen_9pfs_devs, list) {\r\nif (priv->client == client)\r\nbreak;\r\n}\r\nread_unlock(&xen_9pfs_lock);\r\nif (!priv || priv->client != client)\r\nreturn -EINVAL;\r\nnum = p9_req->tc->tag % priv->num_rings;\r\nring = &priv->rings[num];\r\nagain:\r\nwhile (wait_event_interruptible(ring->wq,\r\np9_xen_write_todo(ring, size)) != 0)\r\n;\r\nspin_lock_irqsave(&ring->lock, flags);\r\ncons = ring->intf->out_cons;\r\nprod = ring->intf->out_prod;\r\nvirt_mb();\r\nif (XEN_9PFS_RING_SIZE - xen_9pfs_queued(prod, cons,\r\nXEN_9PFS_RING_SIZE) < size) {\r\nspin_unlock_irqrestore(&ring->lock, flags);\r\ngoto again;\r\n}\r\nmasked_prod = xen_9pfs_mask(prod, XEN_9PFS_RING_SIZE);\r\nmasked_cons = xen_9pfs_mask(cons, XEN_9PFS_RING_SIZE);\r\nxen_9pfs_write_packet(ring->data.out, p9_req->tc->sdata, size,\r\n&masked_prod, masked_cons, XEN_9PFS_RING_SIZE);\r\np9_req->status = REQ_STATUS_SENT;\r\nvirt_wmb();\r\nprod += size;\r\nring->intf->out_prod = prod;\r\nspin_unlock_irqrestore(&ring->lock, flags);\r\nnotify_remote_via_irq(ring->irq);\r\nreturn 0;\r\n}\r\nstatic void p9_xen_response(struct work_struct *work)\r\n{\r\nstruct xen_9pfs_front_priv *priv;\r\nstruct xen_9pfs_dataring *ring;\r\nRING_IDX cons, prod, masked_cons, masked_prod;\r\nstruct xen_9pfs_header h;\r\nstruct p9_req_t *req;\r\nint status;\r\nring = container_of(work, struct xen_9pfs_dataring, work);\r\npriv = ring->priv;\r\nwhile (1) {\r\ncons = ring->intf->in_cons;\r\nprod = ring->intf->in_prod;\r\nvirt_rmb();\r\nif (xen_9pfs_queued(prod, cons, XEN_9PFS_RING_SIZE) <\r\nsizeof(h)) {\r\nnotify_remote_via_irq(ring->irq);\r\nreturn;\r\n}\r\nmasked_prod = xen_9pfs_mask(prod, XEN_9PFS_RING_SIZE);\r\nmasked_cons = xen_9pfs_mask(cons, XEN_9PFS_RING_SIZE);\r\nxen_9pfs_read_packet(&h, ring->data.in, sizeof(h),\r\nmasked_prod, &masked_cons,\r\nXEN_9PFS_RING_SIZE);\r\nreq = p9_tag_lookup(priv->client, h.tag);\r\nif (!req || req->status != REQ_STATUS_SENT) {\r\ndev_warn(&priv->dev->dev, "Wrong req tag=%x\n", h.tag);\r\ncons += h.size;\r\nvirt_mb();\r\nring->intf->in_cons = cons;\r\ncontinue;\r\n}\r\nmemcpy(req->rc, &h, sizeof(h));\r\nreq->rc->offset = 0;\r\nmasked_cons = xen_9pfs_mask(cons, XEN_9PFS_RING_SIZE);\r\nxen_9pfs_read_packet(req->rc->sdata, ring->data.in, h.size,\r\nmasked_prod, &masked_cons,\r\nXEN_9PFS_RING_SIZE);\r\nvirt_mb();\r\ncons += h.size;\r\nring->intf->in_cons = cons;\r\nstatus = (req->status != REQ_STATUS_ERROR) ?\r\nREQ_STATUS_RCVD : REQ_STATUS_ERROR;\r\np9_client_cb(priv->client, req, status);\r\n}\r\n}\r\nstatic irqreturn_t xen_9pfs_front_event_handler(int irq, void *r)\r\n{\r\nstruct xen_9pfs_dataring *ring = r;\r\nif (!ring || !ring->priv->client) {\r\nreturn IRQ_HANDLED;\r\n}\r\nwake_up_interruptible(&ring->wq);\r\nschedule_work(&ring->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void xen_9pfs_front_free(struct xen_9pfs_front_priv *priv)\r\n{\r\nint i, j;\r\nwrite_lock(&xen_9pfs_lock);\r\nlist_del(&priv->list);\r\nwrite_unlock(&xen_9pfs_lock);\r\nfor (i = 0; i < priv->num_rings; i++) {\r\nif (!priv->rings[i].intf)\r\nbreak;\r\nif (priv->rings[i].irq > 0)\r\nunbind_from_irqhandler(priv->rings[i].irq, priv->dev);\r\nif (priv->rings[i].data.in) {\r\nfor (j = 0; j < (1 << XEN_9PFS_RING_ORDER); j++) {\r\ngrant_ref_t ref;\r\nref = priv->rings[i].intf->ref[j];\r\ngnttab_end_foreign_access(ref, 0, 0);\r\n}\r\nfree_pages((unsigned long)priv->rings[i].data.in,\r\nXEN_9PFS_RING_ORDER -\r\n(PAGE_SHIFT - XEN_PAGE_SHIFT));\r\n}\r\ngnttab_end_foreign_access(priv->rings[i].ref, 0, 0);\r\nfree_page((unsigned long)priv->rings[i].intf);\r\n}\r\nkfree(priv->rings);\r\nkfree(priv->tag);\r\nkfree(priv);\r\n}\r\nstatic int xen_9pfs_front_remove(struct xenbus_device *dev)\r\n{\r\nstruct xen_9pfs_front_priv *priv = dev_get_drvdata(&dev->dev);\r\ndev_set_drvdata(&dev->dev, NULL);\r\nxen_9pfs_front_free(priv);\r\nreturn 0;\r\n}\r\nstatic int xen_9pfs_front_alloc_dataring(struct xenbus_device *dev,\r\nstruct xen_9pfs_dataring *ring)\r\n{\r\nint i = 0;\r\nint ret = -ENOMEM;\r\nvoid *bytes = NULL;\r\ninit_waitqueue_head(&ring->wq);\r\nspin_lock_init(&ring->lock);\r\nINIT_WORK(&ring->work, p9_xen_response);\r\nring->intf = (struct xen_9pfs_data_intf *)get_zeroed_page(GFP_KERNEL);\r\nif (!ring->intf)\r\nreturn ret;\r\nret = gnttab_grant_foreign_access(dev->otherend_id,\r\nvirt_to_gfn(ring->intf), 0);\r\nif (ret < 0)\r\ngoto out;\r\nring->ref = ret;\r\nbytes = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\r\nXEN_9PFS_RING_ORDER - (PAGE_SHIFT - XEN_PAGE_SHIFT));\r\nif (!bytes) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (; i < (1 << XEN_9PFS_RING_ORDER); i++) {\r\nret = gnttab_grant_foreign_access(\r\ndev->otherend_id, virt_to_gfn(bytes) + i, 0);\r\nif (ret < 0)\r\ngoto out;\r\nring->intf->ref[i] = ret;\r\n}\r\nring->intf->ring_order = XEN_9PFS_RING_ORDER;\r\nring->data.in = bytes;\r\nring->data.out = bytes + XEN_9PFS_RING_SIZE;\r\nret = xenbus_alloc_evtchn(dev, &ring->evtchn);\r\nif (ret)\r\ngoto out;\r\nring->irq = bind_evtchn_to_irqhandler(ring->evtchn,\r\nxen_9pfs_front_event_handler,\r\n0, "xen_9pfs-frontend", ring);\r\nif (ring->irq >= 0)\r\nreturn 0;\r\nxenbus_free_evtchn(dev, ring->evtchn);\r\nret = ring->irq;\r\nout:\r\nif (bytes) {\r\nfor (i--; i >= 0; i--)\r\ngnttab_end_foreign_access(ring->intf->ref[i], 0, 0);\r\nfree_pages((unsigned long)bytes,\r\nXEN_9PFS_RING_ORDER -\r\n(PAGE_SHIFT - XEN_PAGE_SHIFT));\r\n}\r\ngnttab_end_foreign_access(ring->ref, 0, 0);\r\nfree_page((unsigned long)ring->intf);\r\nreturn ret;\r\n}\r\nstatic int xen_9pfs_front_probe(struct xenbus_device *dev,\r\nconst struct xenbus_device_id *id)\r\n{\r\nint ret, i;\r\nstruct xenbus_transaction xbt;\r\nstruct xen_9pfs_front_priv *priv = NULL;\r\nchar *versions;\r\nunsigned int max_rings, max_ring_order, len = 0;\r\nversions = xenbus_read(XBT_NIL, dev->otherend, "versions", &len);\r\nif (!len)\r\nreturn -EINVAL;\r\nif (strcmp(versions, "1")) {\r\nkfree(versions);\r\nreturn -EINVAL;\r\n}\r\nkfree(versions);\r\nmax_rings = xenbus_read_unsigned(dev->otherend, "max-rings", 0);\r\nif (max_rings < XEN_9PFS_NUM_RINGS)\r\nreturn -EINVAL;\r\nmax_ring_order = xenbus_read_unsigned(dev->otherend,\r\n"max-ring-page-order", 0);\r\nif (max_ring_order < XEN_9PFS_RING_ORDER)\r\nreturn -EINVAL;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->dev = dev;\r\npriv->num_rings = XEN_9PFS_NUM_RINGS;\r\npriv->rings = kcalloc(priv->num_rings, sizeof(*priv->rings),\r\nGFP_KERNEL);\r\nif (!priv->rings) {\r\nkfree(priv);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < priv->num_rings; i++) {\r\npriv->rings[i].priv = priv;\r\nret = xen_9pfs_front_alloc_dataring(dev, &priv->rings[i]);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nagain:\r\nret = xenbus_transaction_start(&xbt);\r\nif (ret) {\r\nxenbus_dev_fatal(dev, ret, "starting transaction");\r\ngoto error;\r\n}\r\nret = xenbus_printf(xbt, dev->nodename, "version", "%u", 1);\r\nif (ret)\r\ngoto error_xenbus;\r\nret = xenbus_printf(xbt, dev->nodename, "num-rings", "%u",\r\npriv->num_rings);\r\nif (ret)\r\ngoto error_xenbus;\r\nfor (i = 0; i < priv->num_rings; i++) {\r\nchar str[16];\r\nBUILD_BUG_ON(XEN_9PFS_NUM_RINGS > 9);\r\nsprintf(str, "ring-ref%u", i);\r\nret = xenbus_printf(xbt, dev->nodename, str, "%d",\r\npriv->rings[i].ref);\r\nif (ret)\r\ngoto error_xenbus;\r\nsprintf(str, "event-channel-%u", i);\r\nret = xenbus_printf(xbt, dev->nodename, str, "%u",\r\npriv->rings[i].evtchn);\r\nif (ret)\r\ngoto error_xenbus;\r\n}\r\npriv->tag = xenbus_read(xbt, dev->nodename, "tag", NULL);\r\nif (IS_ERR(priv->tag)) {\r\nret = PTR_ERR(priv->tag);\r\ngoto error_xenbus;\r\n}\r\nret = xenbus_transaction_end(xbt, 0);\r\nif (ret) {\r\nif (ret == -EAGAIN)\r\ngoto again;\r\nxenbus_dev_fatal(dev, ret, "completing transaction");\r\ngoto error;\r\n}\r\nwrite_lock(&xen_9pfs_lock);\r\nlist_add_tail(&priv->list, &xen_9pfs_devs);\r\nwrite_unlock(&xen_9pfs_lock);\r\ndev_set_drvdata(&dev->dev, priv);\r\nxenbus_switch_state(dev, XenbusStateInitialised);\r\nreturn 0;\r\nerror_xenbus:\r\nxenbus_transaction_end(xbt, 1);\r\nxenbus_dev_fatal(dev, ret, "writing xenstore");\r\nerror:\r\ndev_set_drvdata(&dev->dev, NULL);\r\nxen_9pfs_front_free(priv);\r\nreturn ret;\r\n}\r\nstatic int xen_9pfs_front_resume(struct xenbus_device *dev)\r\n{\r\ndev_warn(&dev->dev, "suspsend/resume unsupported\n");\r\nreturn 0;\r\n}\r\nstatic void xen_9pfs_front_changed(struct xenbus_device *dev,\r\nenum xenbus_state backend_state)\r\n{\r\nswitch (backend_state) {\r\ncase XenbusStateReconfiguring:\r\ncase XenbusStateReconfigured:\r\ncase XenbusStateInitialising:\r\ncase XenbusStateInitialised:\r\ncase XenbusStateUnknown:\r\nbreak;\r\ncase XenbusStateInitWait:\r\nbreak;\r\ncase XenbusStateConnected:\r\nxenbus_switch_state(dev, XenbusStateConnected);\r\nbreak;\r\ncase XenbusStateClosed:\r\nif (dev->state == XenbusStateClosed)\r\nbreak;\r\ncase XenbusStateClosing:\r\nxenbus_frontend_closed(dev);\r\nbreak;\r\n}\r\n}\r\nstatic int p9_trans_xen_init(void)\r\n{\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\npr_info("Initialising Xen transport for 9pfs\n");\r\nv9fs_register_trans(&p9_xen_trans);\r\nreturn xenbus_register_frontend(&xen_9pfs_front_driver);\r\n}\r\nstatic void p9_trans_xen_exit(void)\r\n{\r\nv9fs_unregister_trans(&p9_xen_trans);\r\nreturn xenbus_unregister_driver(&xen_9pfs_front_driver);\r\n}
