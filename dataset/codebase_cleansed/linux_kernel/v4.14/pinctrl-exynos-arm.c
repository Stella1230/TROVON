static void s5pv210_retention_disable(struct samsung_pinctrl_drv_data *drvdata)\r\n{\r\nvoid __iomem *clk_base = (void __iomem *)drvdata->retention_ctrl->priv;\r\nu32 tmp;\r\ntmp = __raw_readl(clk_base + S5P_OTHERS);\r\ntmp |= (S5P_OTHERS_RET_IO | S5P_OTHERS_RET_CF | S5P_OTHERS_RET_MMC |\r\nS5P_OTHERS_RET_UART);\r\n__raw_writel(tmp, clk_base + S5P_OTHERS);\r\n}\r\nstatic struct samsung_retention_ctrl *\r\ns5pv210_retention_init(struct samsung_pinctrl_drv_data *drvdata,\r\nconst struct samsung_retention_data *data)\r\n{\r\nstruct samsung_retention_ctrl *ctrl;\r\nstruct device_node *np;\r\nvoid __iomem *clk_base;\r\nctrl = devm_kzalloc(drvdata->dev, sizeof(*ctrl), GFP_KERNEL);\r\nif (!ctrl)\r\nreturn ERR_PTR(-ENOMEM);\r\nnp = of_find_compatible_node(NULL, NULL, "samsung,s5pv210-clock");\r\nif (!np) {\r\npr_err("%s: failed to find clock controller DT node\n",\r\n__func__);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nclk_base = of_iomap(np, 0);\r\nif (!clk_base) {\r\npr_err("%s: failed to map clock registers\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nctrl->priv = (void __force *)clk_base;\r\nctrl->disable = s5pv210_retention_disable;\r\nreturn ctrl;\r\n}
