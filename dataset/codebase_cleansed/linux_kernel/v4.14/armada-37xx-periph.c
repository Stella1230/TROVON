static unsigned int get_div(void __iomem *reg, int shift)\r\n{\r\nu32 val;\r\nval = (readl(reg) >> shift) & 0x7;\r\nif (val > 6)\r\nreturn 0;\r\nreturn val;\r\n}\r\nstatic unsigned long clk_double_div_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_double_div *double_div = to_clk_double_div(hw);\r\nunsigned int div;\r\ndiv = get_div(double_div->reg1, double_div->shift1);\r\ndiv *= get_div(double_div->reg2, double_div->shift2);\r\nreturn DIV_ROUND_UP_ULL((u64)parent_rate, div);\r\n}\r\nstatic int armada_3700_add_composite_clk(const struct clk_periph_data *data,\r\nvoid __iomem *reg, spinlock_t *lock,\r\nstruct device *dev, struct clk_hw **hw)\r\n{\r\nconst struct clk_ops *mux_ops = NULL, *gate_ops = NULL,\r\n*rate_ops = NULL;\r\nstruct clk_hw *mux_hw = NULL, *gate_hw = NULL, *rate_hw = NULL;\r\nif (data->mux_hw) {\r\nstruct clk_mux *mux;\r\nmux_hw = data->mux_hw;\r\nmux = to_clk_mux(mux_hw);\r\nmux->lock = lock;\r\nmux_ops = mux_hw->init->ops;\r\nmux->reg = reg + (u64)mux->reg;\r\n}\r\nif (data->gate_hw) {\r\nstruct clk_gate *gate;\r\ngate_hw = data->gate_hw;\r\ngate = to_clk_gate(gate_hw);\r\ngate->lock = lock;\r\ngate_ops = gate_hw->init->ops;\r\ngate->reg = reg + (u64)gate->reg;\r\ngate->flags = CLK_GATE_SET_TO_DISABLE;\r\n}\r\nif (data->rate_hw) {\r\nrate_hw = data->rate_hw;\r\nrate_ops = rate_hw->init->ops;\r\nif (data->is_double_div) {\r\nstruct clk_double_div *rate;\r\nrate = to_clk_double_div(rate_hw);\r\nrate->reg1 = reg + (u64)rate->reg1;\r\nrate->reg2 = reg + (u64)rate->reg2;\r\n} else {\r\nstruct clk_divider *rate = to_clk_divider(rate_hw);\r\nconst struct clk_div_table *clkt;\r\nint table_size = 0;\r\nrate->reg = reg + (u64)rate->reg;\r\nfor (clkt = rate->table; clkt->div; clkt++)\r\ntable_size++;\r\nrate->width = order_base_2(table_size);\r\nrate->lock = lock;\r\n}\r\n}\r\n*hw = clk_hw_register_composite(dev, data->name, data->parent_names,\r\ndata->num_parents, mux_hw,\r\nmux_ops, rate_hw, rate_ops,\r\ngate_hw, gate_ops, CLK_IGNORE_UNUSED);\r\nif (IS_ERR(*hw))\r\nreturn PTR_ERR(*hw);\r\nreturn 0;\r\n}\r\nstatic int armada_3700_periph_clock_probe(struct platform_device *pdev)\r\n{\r\nstruct clk_periph_driver_data *driver_data;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct clk_periph_data *data;\r\nstruct device *dev = &pdev->dev;\r\nint num_periph = 0, i, ret;\r\nstruct resource *res;\r\nvoid __iomem *reg;\r\ndata = of_device_get_match_data(dev);\r\nif (!data)\r\nreturn -ENODEV;\r\nwhile (data[num_periph].name)\r\nnum_periph++;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nreg = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(reg))\r\nreturn PTR_ERR(reg);\r\ndriver_data = devm_kzalloc(dev, sizeof(*driver_data), GFP_KERNEL);\r\nif (!driver_data)\r\nreturn -ENOMEM;\r\ndriver_data->hw_data = devm_kzalloc(dev, sizeof(*driver_data->hw_data) +\r\nsizeof(*driver_data->hw_data->hws) * num_periph,\r\nGFP_KERNEL);\r\nif (!driver_data->hw_data)\r\nreturn -ENOMEM;\r\ndriver_data->hw_data->num = num_periph;\r\nspin_lock_init(&driver_data->lock);\r\nfor (i = 0; i < num_periph; i++) {\r\nstruct clk_hw **hw = &driver_data->hw_data->hws[i];\r\nif (armada_3700_add_composite_clk(&data[i], reg,\r\n&driver_data->lock, dev, hw))\r\ndev_err(dev, "Can't register periph clock %s\n",\r\ndata[i].name);\r\n}\r\nret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get,\r\ndriver_data->hw_data);\r\nif (ret) {\r\nfor (i = 0; i < num_periph; i++)\r\nclk_hw_unregister(driver_data->hw_data->hws[i]);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, driver_data);\r\nreturn 0;\r\n}\r\nstatic int armada_3700_periph_clock_remove(struct platform_device *pdev)\r\n{\r\nstruct clk_periph_driver_data *data = platform_get_drvdata(pdev);\r\nstruct clk_hw_onecell_data *hw_data = data->hw_data;\r\nint i;\r\nof_clk_del_provider(pdev->dev.of_node);\r\nfor (i = 0; i < hw_data->num; i++)\r\nclk_hw_unregister(hw_data->hws[i]);\r\nreturn 0;\r\n}
