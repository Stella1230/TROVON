void\r\nnfs4_fl_free_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\r\n{\r\nstruct nfs4_pnfs_ds *ds;\r\nint i;\r\nnfs4_print_deviceid(&dsaddr->id_node.deviceid);\r\nfor (i = 0; i < dsaddr->ds_num; i++) {\r\nds = dsaddr->ds_list[i];\r\nif (ds != NULL)\r\nnfs4_pnfs_ds_put(ds);\r\n}\r\nkfree(dsaddr->stripe_indices);\r\nkfree_rcu(dsaddr, id_node.rcu);\r\n}\r\nstruct nfs4_file_layout_dsaddr *\r\nnfs4_fl_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\r\ngfp_t gfp_flags)\r\n{\r\nint i;\r\nu32 cnt, num;\r\nu8 *indexp;\r\n__be32 *p;\r\nu8 *stripe_indices;\r\nu8 max_stripe_index;\r\nstruct nfs4_file_layout_dsaddr *dsaddr = NULL;\r\nstruct xdr_stream stream;\r\nstruct xdr_buf buf;\r\nstruct page *scratch;\r\nstruct list_head dsaddrs;\r\nstruct nfs4_pnfs_ds_addr *da;\r\nscratch = alloc_page(gfp_flags);\r\nif (!scratch)\r\ngoto out_err;\r\nxdr_init_decode_pages(&stream, &buf, pdev->pages, pdev->pglen);\r\nxdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\r\np = xdr_inline_decode(&stream, 4);\r\nif (unlikely(!p))\r\ngoto out_err_free_scratch;\r\ncnt = be32_to_cpup(p);\r\ndprintk("%s stripe count %d\n", __func__, cnt);\r\nif (cnt > NFS4_PNFS_MAX_STRIPE_CNT) {\r\nprintk(KERN_WARNING "NFS: %s: stripe count %d greater than "\r\n"supported maximum %d\n", __func__,\r\ncnt, NFS4_PNFS_MAX_STRIPE_CNT);\r\ngoto out_err_free_scratch;\r\n}\r\nstripe_indices = kcalloc(cnt, sizeof(u8), gfp_flags);\r\nif (!stripe_indices)\r\ngoto out_err_free_scratch;\r\np = xdr_inline_decode(&stream, cnt << 2);\r\nif (unlikely(!p))\r\ngoto out_err_free_stripe_indices;\r\nindexp = &stripe_indices[0];\r\nmax_stripe_index = 0;\r\nfor (i = 0; i < cnt; i++) {\r\n*indexp = be32_to_cpup(p++);\r\nmax_stripe_index = max(max_stripe_index, *indexp);\r\nindexp++;\r\n}\r\np = xdr_inline_decode(&stream, 4);\r\nif (unlikely(!p))\r\ngoto out_err_free_stripe_indices;\r\nnum = be32_to_cpup(p);\r\ndprintk("%s ds_num %u\n", __func__, num);\r\nif (num > NFS4_PNFS_MAX_MULTI_CNT) {\r\nprintk(KERN_WARNING "NFS: %s: multipath count %d greater than "\r\n"supported maximum %d\n", __func__,\r\nnum, NFS4_PNFS_MAX_MULTI_CNT);\r\ngoto out_err_free_stripe_indices;\r\n}\r\nif (max_stripe_index >= num) {\r\nprintk(KERN_WARNING "NFS: %s: stripe index %u >= num ds %u\n",\r\n__func__, max_stripe_index, num);\r\ngoto out_err_free_stripe_indices;\r\n}\r\ndsaddr = kzalloc(sizeof(*dsaddr) +\r\n(sizeof(struct nfs4_pnfs_ds *) * (num - 1)),\r\ngfp_flags);\r\nif (!dsaddr)\r\ngoto out_err_free_stripe_indices;\r\ndsaddr->stripe_count = cnt;\r\ndsaddr->stripe_indices = stripe_indices;\r\nstripe_indices = NULL;\r\ndsaddr->ds_num = num;\r\nnfs4_init_deviceid_node(&dsaddr->id_node, server, &pdev->dev_id);\r\nINIT_LIST_HEAD(&dsaddrs);\r\nfor (i = 0; i < dsaddr->ds_num; i++) {\r\nint j;\r\nu32 mp_count;\r\np = xdr_inline_decode(&stream, 4);\r\nif (unlikely(!p))\r\ngoto out_err_free_deviceid;\r\nmp_count = be32_to_cpup(p);\r\nfor (j = 0; j < mp_count; j++) {\r\nda = nfs4_decode_mp_ds_addr(server->nfs_client->cl_net,\r\n&stream, gfp_flags);\r\nif (da)\r\nlist_add_tail(&da->da_node, &dsaddrs);\r\n}\r\nif (list_empty(&dsaddrs)) {\r\ndprintk("%s: no suitable DS addresses found\n",\r\n__func__);\r\ngoto out_err_free_deviceid;\r\n}\r\ndsaddr->ds_list[i] = nfs4_pnfs_ds_add(&dsaddrs, gfp_flags);\r\nif (!dsaddr->ds_list[i])\r\ngoto out_err_drain_dsaddrs;\r\nwhile (!list_empty(&dsaddrs)) {\r\nda = list_first_entry(&dsaddrs,\r\nstruct nfs4_pnfs_ds_addr,\r\nda_node);\r\nlist_del_init(&da->da_node);\r\nkfree(da->da_remotestr);\r\nkfree(da);\r\n}\r\n}\r\n__free_page(scratch);\r\nreturn dsaddr;\r\nout_err_drain_dsaddrs:\r\nwhile (!list_empty(&dsaddrs)) {\r\nda = list_first_entry(&dsaddrs, struct nfs4_pnfs_ds_addr,\r\nda_node);\r\nlist_del_init(&da->da_node);\r\nkfree(da->da_remotestr);\r\nkfree(da);\r\n}\r\nout_err_free_deviceid:\r\nnfs4_fl_free_deviceid(dsaddr);\r\ngoto out_err_free_scratch;\r\nout_err_free_stripe_indices:\r\nkfree(stripe_indices);\r\nout_err_free_scratch:\r\n__free_page(scratch);\r\nout_err:\r\ndprintk("%s ERROR: returning NULL\n", __func__);\r\nreturn NULL;\r\n}\r\nvoid\r\nnfs4_fl_put_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\r\n{\r\nnfs4_put_deviceid_node(&dsaddr->id_node);\r\n}\r\nu32\r\nnfs4_fl_calc_j_index(struct pnfs_layout_segment *lseg, loff_t offset)\r\n{\r\nstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\r\nu64 tmp;\r\ntmp = offset - flseg->pattern_offset;\r\ndo_div(tmp, flseg->stripe_unit);\r\ntmp += flseg->first_stripe_index;\r\nreturn do_div(tmp, flseg->dsaddr->stripe_count);\r\n}\r\nu32\r\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\r\n{\r\nreturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\r\n}\r\nstruct nfs_fh *\r\nnfs4_fl_select_ds_fh(struct pnfs_layout_segment *lseg, u32 j)\r\n{\r\nstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\r\nu32 i;\r\nif (flseg->stripe_type == STRIPE_SPARSE) {\r\nif (flseg->num_fh == 1)\r\ni = 0;\r\nelse if (flseg->num_fh == 0)\r\nreturn NULL;\r\nelse\r\ni = nfs4_fl_calc_ds_index(lseg, j);\r\n} else\r\ni = j;\r\nreturn flseg->fh_array[i];\r\n}\r\nstruct nfs4_pnfs_ds *\r\nnfs4_fl_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx)\r\n{\r\nstruct nfs4_file_layout_dsaddr *dsaddr = FILELAYOUT_LSEG(lseg)->dsaddr;\r\nstruct nfs4_pnfs_ds *ds = dsaddr->ds_list[ds_idx];\r\nstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\r\nstruct nfs4_pnfs_ds *ret = ds;\r\nstruct nfs_server *s = NFS_SERVER(lseg->pls_layout->plh_inode);\r\nint status;\r\nif (ds == NULL) {\r\nprintk(KERN_ERR "NFS: %s: No data server for offset index %d\n",\r\n__func__, ds_idx);\r\npnfs_generic_mark_devid_invalid(devid);\r\ngoto out;\r\n}\r\nsmp_rmb();\r\nif (ds->ds_clp)\r\ngoto out_test_devid;\r\nstatus = nfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\r\ndataserver_retrans, 4,\r\ns->nfs_client->cl_minorversion);\r\nif (status) {\r\nnfs4_mark_deviceid_unavailable(devid);\r\nret = NULL;\r\ngoto out;\r\n}\r\nout_test_devid:\r\nif (ret->ds_clp == NULL ||\r\nfilelayout_test_devid_unavailable(devid))\r\nret = NULL;\r\nout:\r\nreturn ret;\r\n}
