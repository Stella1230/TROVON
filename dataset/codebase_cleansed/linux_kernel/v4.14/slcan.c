static void slc_bump(struct slcan *sl)\r\n{\r\nstruct sk_buff *skb;\r\nstruct can_frame cf;\r\nint i, tmp;\r\nu32 tmpid;\r\nchar *cmd = sl->rbuff;\r\ncf.can_id = 0;\r\nswitch (*cmd) {\r\ncase 'r':\r\ncf.can_id = CAN_RTR_FLAG;\r\ncase 't':\r\ncf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN];\r\nsl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN] = 0;\r\ncmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1;\r\nbreak;\r\ncase 'R':\r\ncf.can_id = CAN_RTR_FLAG;\r\ncase 'T':\r\ncf.can_id |= CAN_EFF_FLAG;\r\ncf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN];\r\nsl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN] = 0;\r\ncmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (kstrtou32(sl->rbuff + SLC_CMD_LEN, 16, &tmpid))\r\nreturn;\r\ncf.can_id |= tmpid;\r\nif (cf.can_dlc >= '0' && cf.can_dlc < '9')\r\ncf.can_dlc -= '0';\r\nelse\r\nreturn;\r\n*(u64 *) (&cf.data) = 0;\r\nif (!(cf.can_id & CAN_RTR_FLAG)) {\r\nfor (i = 0; i < cf.can_dlc; i++) {\r\ntmp = hex_to_bin(*cmd++);\r\nif (tmp < 0)\r\nreturn;\r\ncf.data[i] = (tmp << 4);\r\ntmp = hex_to_bin(*cmd++);\r\nif (tmp < 0)\r\nreturn;\r\ncf.data[i] |= tmp;\r\n}\r\n}\r\nskb = dev_alloc_skb(sizeof(struct can_frame) +\r\nsizeof(struct can_skb_priv));\r\nif (!skb)\r\nreturn;\r\nskb->dev = sl->dev;\r\nskb->protocol = htons(ETH_P_CAN);\r\nskb->pkt_type = PACKET_BROADCAST;\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\ncan_skb_reserve(skb);\r\ncan_skb_prv(skb)->ifindex = sl->dev->ifindex;\r\ncan_skb_prv(skb)->skbcnt = 0;\r\nskb_put_data(skb, &cf, sizeof(struct can_frame));\r\nsl->dev->stats.rx_packets++;\r\nsl->dev->stats.rx_bytes += cf.can_dlc;\r\nnetif_rx_ni(skb);\r\n}\r\nstatic void slcan_unesc(struct slcan *sl, unsigned char s)\r\n{\r\nif ((s == '\r') || (s == '\a')) {\r\nif (!test_and_clear_bit(SLF_ERROR, &sl->flags) &&\r\n(sl->rcount > 4)) {\r\nslc_bump(sl);\r\n}\r\nsl->rcount = 0;\r\n} else {\r\nif (!test_bit(SLF_ERROR, &sl->flags)) {\r\nif (sl->rcount < SLC_MTU) {\r\nsl->rbuff[sl->rcount++] = s;\r\nreturn;\r\n} else {\r\nsl->dev->stats.rx_over_errors++;\r\nset_bit(SLF_ERROR, &sl->flags);\r\n}\r\n}\r\n}\r\n}\r\nstatic void slc_encaps(struct slcan *sl, struct can_frame *cf)\r\n{\r\nint actual, i;\r\nunsigned char *pos;\r\nunsigned char *endpos;\r\ncanid_t id = cf->can_id;\r\npos = sl->xbuff;\r\nif (cf->can_id & CAN_RTR_FLAG)\r\n*pos = 'R';\r\nelse\r\n*pos = 'T';\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\nid &= CAN_EFF_MASK;\r\nendpos = pos + SLC_EFF_ID_LEN;\r\n} else {\r\n*pos |= 0x20;\r\nid &= CAN_SFF_MASK;\r\nendpos = pos + SLC_SFF_ID_LEN;\r\n}\r\npos++;\r\nwhile (endpos >= pos) {\r\n*endpos-- = hex_asc_upper[id & 0xf];\r\nid >>= 4;\r\n}\r\npos += (cf->can_id & CAN_EFF_FLAG) ? SLC_EFF_ID_LEN : SLC_SFF_ID_LEN;\r\n*pos++ = cf->can_dlc + '0';\r\nif (!(cf->can_id & CAN_RTR_FLAG)) {\r\nfor (i = 0; i < cf->can_dlc; i++)\r\npos = hex_byte_pack_upper(pos, cf->data[i]);\r\n}\r\n*pos++ = '\r';\r\nset_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\r\nactual = sl->tty->ops->write(sl->tty, sl->xbuff, pos - sl->xbuff);\r\nsl->xleft = (pos - sl->xbuff) - actual;\r\nsl->xhead = sl->xbuff + actual;\r\nsl->dev->stats.tx_bytes += cf->can_dlc;\r\n}\r\nstatic void slcan_transmit(struct work_struct *work)\r\n{\r\nstruct slcan *sl = container_of(work, struct slcan, tx_work);\r\nint actual;\r\nspin_lock_bh(&sl->lock);\r\nif (!sl->tty || sl->magic != SLCAN_MAGIC || !netif_running(sl->dev)) {\r\nspin_unlock_bh(&sl->lock);\r\nreturn;\r\n}\r\nif (sl->xleft <= 0) {\r\nsl->dev->stats.tx_packets++;\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\r\nspin_unlock_bh(&sl->lock);\r\nnetif_wake_queue(sl->dev);\r\nreturn;\r\n}\r\nactual = sl->tty->ops->write(sl->tty, sl->xhead, sl->xleft);\r\nsl->xleft -= actual;\r\nsl->xhead += actual;\r\nspin_unlock_bh(&sl->lock);\r\n}\r\nstatic void slcan_write_wakeup(struct tty_struct *tty)\r\n{\r\nstruct slcan *sl = tty->disc_data;\r\nschedule_work(&sl->tx_work);\r\n}\r\nstatic netdev_tx_t slc_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct slcan *sl = netdev_priv(dev);\r\nif (skb->len != CAN_MTU)\r\ngoto out;\r\nspin_lock(&sl->lock);\r\nif (!netif_running(dev)) {\r\nspin_unlock(&sl->lock);\r\nprintk(KERN_WARNING "%s: xmit: iface is down\n", dev->name);\r\ngoto out;\r\n}\r\nif (sl->tty == NULL) {\r\nspin_unlock(&sl->lock);\r\ngoto out;\r\n}\r\nnetif_stop_queue(sl->dev);\r\nslc_encaps(sl, (struct can_frame *) skb->data);\r\nspin_unlock(&sl->lock);\r\nout:\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int slc_close(struct net_device *dev)\r\n{\r\nstruct slcan *sl = netdev_priv(dev);\r\nspin_lock_bh(&sl->lock);\r\nif (sl->tty) {\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\r\n}\r\nnetif_stop_queue(dev);\r\nsl->rcount = 0;\r\nsl->xleft = 0;\r\nspin_unlock_bh(&sl->lock);\r\nreturn 0;\r\n}\r\nstatic int slc_open(struct net_device *dev)\r\n{\r\nstruct slcan *sl = netdev_priv(dev);\r\nif (sl->tty == NULL)\r\nreturn -ENODEV;\r\nsl->flags &= (1 << SLF_INUSE);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void slc_free_netdev(struct net_device *dev)\r\n{\r\nint i = dev->base_addr;\r\nslcan_devs[i] = NULL;\r\n}\r\nstatic int slcan_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic void slc_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &slc_netdev_ops;\r\ndev->needs_free_netdev = true;\r\ndev->priv_destructor = slc_free_netdev;\r\ndev->hard_header_len = 0;\r\ndev->addr_len = 0;\r\ndev->tx_queue_len = 10;\r\ndev->mtu = CAN_MTU;\r\ndev->type = ARPHRD_CAN;\r\ndev->flags = IFF_NOARP;\r\ndev->features = NETIF_F_HW_CSUM;\r\n}\r\nstatic void slcan_receive_buf(struct tty_struct *tty,\r\nconst unsigned char *cp, char *fp, int count)\r\n{\r\nstruct slcan *sl = (struct slcan *) tty->disc_data;\r\nif (!sl || sl->magic != SLCAN_MAGIC || !netif_running(sl->dev))\r\nreturn;\r\nwhile (count--) {\r\nif (fp && *fp++) {\r\nif (!test_and_set_bit(SLF_ERROR, &sl->flags))\r\nsl->dev->stats.rx_errors++;\r\ncp++;\r\ncontinue;\r\n}\r\nslcan_unesc(sl, *cp++);\r\n}\r\n}\r\nstatic void slc_sync(void)\r\n{\r\nint i;\r\nstruct net_device *dev;\r\nstruct slcan *sl;\r\nfor (i = 0; i < maxdev; i++) {\r\ndev = slcan_devs[i];\r\nif (dev == NULL)\r\nbreak;\r\nsl = netdev_priv(dev);\r\nif (sl->tty)\r\ncontinue;\r\nif (dev->flags & IFF_UP)\r\ndev_close(dev);\r\n}\r\n}\r\nstatic struct slcan *slc_alloc(dev_t line)\r\n{\r\nint i;\r\nchar name[IFNAMSIZ];\r\nstruct net_device *dev = NULL;\r\nstruct slcan *sl;\r\nfor (i = 0; i < maxdev; i++) {\r\ndev = slcan_devs[i];\r\nif (dev == NULL)\r\nbreak;\r\n}\r\nif (i >= maxdev)\r\nreturn NULL;\r\nsprintf(name, "slcan%d", i);\r\ndev = alloc_netdev(sizeof(*sl), name, NET_NAME_UNKNOWN, slc_setup);\r\nif (!dev)\r\nreturn NULL;\r\ndev->base_addr = i;\r\nsl = netdev_priv(dev);\r\nsl->magic = SLCAN_MAGIC;\r\nsl->dev = dev;\r\nspin_lock_init(&sl->lock);\r\nINIT_WORK(&sl->tx_work, slcan_transmit);\r\nslcan_devs[i] = dev;\r\nreturn sl;\r\n}\r\nstatic int slcan_open(struct tty_struct *tty)\r\n{\r\nstruct slcan *sl;\r\nint err;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (tty->ops->write == NULL)\r\nreturn -EOPNOTSUPP;\r\nrtnl_lock();\r\nslc_sync();\r\nsl = tty->disc_data;\r\nerr = -EEXIST;\r\nif (sl && sl->magic == SLCAN_MAGIC)\r\ngoto err_exit;\r\nerr = -ENFILE;\r\nsl = slc_alloc(tty_devnum(tty));\r\nif (sl == NULL)\r\ngoto err_exit;\r\nsl->tty = tty;\r\ntty->disc_data = sl;\r\nif (!test_bit(SLF_INUSE, &sl->flags)) {\r\nsl->rcount = 0;\r\nsl->xleft = 0;\r\nset_bit(SLF_INUSE, &sl->flags);\r\nerr = register_netdevice(sl->dev);\r\nif (err)\r\ngoto err_free_chan;\r\n}\r\nrtnl_unlock();\r\ntty->receive_room = 65536;\r\nreturn 0;\r\nerr_free_chan:\r\nsl->tty = NULL;\r\ntty->disc_data = NULL;\r\nclear_bit(SLF_INUSE, &sl->flags);\r\nerr_exit:\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic void slcan_close(struct tty_struct *tty)\r\n{\r\nstruct slcan *sl = (struct slcan *) tty->disc_data;\r\nif (!sl || sl->magic != SLCAN_MAGIC || sl->tty != tty)\r\nreturn;\r\nspin_lock_bh(&sl->lock);\r\ntty->disc_data = NULL;\r\nsl->tty = NULL;\r\nspin_unlock_bh(&sl->lock);\r\nflush_work(&sl->tx_work);\r\nunregister_netdev(sl->dev);\r\n}\r\nstatic int slcan_hangup(struct tty_struct *tty)\r\n{\r\nslcan_close(tty);\r\nreturn 0;\r\n}\r\nstatic int slcan_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct slcan *sl = (struct slcan *) tty->disc_data;\r\nunsigned int tmp;\r\nif (!sl || sl->magic != SLCAN_MAGIC)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase SIOCGIFNAME:\r\ntmp = strlen(sl->dev->name) + 1;\r\nif (copy_to_user((void __user *)arg, sl->dev->name, tmp))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase SIOCSIFHWADDR:\r\nreturn -EINVAL;\r\ndefault:\r\nreturn tty_mode_ioctl(tty, file, cmd, arg);\r\n}\r\n}\r\nstatic int __init slcan_init(void)\r\n{\r\nint status;\r\nif (maxdev < 4)\r\nmaxdev = 4;\r\npr_info("slcan: serial line CAN interface driver\n");\r\npr_info("slcan: %d dynamic interface channels.\n", maxdev);\r\nslcan_devs = kzalloc(sizeof(struct net_device *)*maxdev, GFP_KERNEL);\r\nif (!slcan_devs)\r\nreturn -ENOMEM;\r\nstatus = tty_register_ldisc(N_SLCAN, &slc_ldisc);\r\nif (status) {\r\nprintk(KERN_ERR "slcan: can't register line discipline\n");\r\nkfree(slcan_devs);\r\n}\r\nreturn status;\r\n}\r\nstatic void __exit slcan_exit(void)\r\n{\r\nint i;\r\nstruct net_device *dev;\r\nstruct slcan *sl;\r\nunsigned long timeout = jiffies + HZ;\r\nint busy = 0;\r\nif (slcan_devs == NULL)\r\nreturn;\r\ndo {\r\nif (busy)\r\nmsleep_interruptible(100);\r\nbusy = 0;\r\nfor (i = 0; i < maxdev; i++) {\r\ndev = slcan_devs[i];\r\nif (!dev)\r\ncontinue;\r\nsl = netdev_priv(dev);\r\nspin_lock_bh(&sl->lock);\r\nif (sl->tty) {\r\nbusy++;\r\ntty_hangup(sl->tty);\r\n}\r\nspin_unlock_bh(&sl->lock);\r\n}\r\n} while (busy && time_before(jiffies, timeout));\r\nfor (i = 0; i < maxdev; i++) {\r\ndev = slcan_devs[i];\r\nif (!dev)\r\ncontinue;\r\nslcan_devs[i] = NULL;\r\nsl = netdev_priv(dev);\r\nif (sl->tty) {\r\nprintk(KERN_ERR "%s: tty discipline still running\n",\r\ndev->name);\r\n}\r\nunregister_netdev(dev);\r\n}\r\nkfree(slcan_devs);\r\nslcan_devs = NULL;\r\ni = tty_unregister_ldisc(N_SLCAN);\r\nif (i)\r\nprintk(KERN_ERR "slcan: can't unregister ldisc (err %d)\n", i);\r\n}
