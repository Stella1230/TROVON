static int crypt_supported(struct tape_device *device)\r\n{\r\nreturn TAPE390_CRYPT_SUPPORTED(TAPE_3590_CRYPT_INFO(device));\r\n}\r\nstatic int crypt_enabled(struct tape_device *device)\r\n{\r\nreturn TAPE390_CRYPT_ON(TAPE_3590_CRYPT_INFO(device));\r\n}\r\nstatic void ext_to_int_kekl(struct tape390_kekl *in,\r\nstruct tape3592_kekl *out)\r\n{\r\nint i;\r\nmemset(out, 0, sizeof(*out));\r\nif (in->type == TAPE390_KEKL_TYPE_HASH)\r\nout->flags |= 0x40;\r\nif (in->type_on_tape == TAPE390_KEKL_TYPE_HASH)\r\nout->flags |= 0x80;\r\nstrncpy(out->label, in->label, 64);\r\nfor (i = strlen(in->label); i < sizeof(out->label); i++)\r\nout->label[i] = ' ';\r\nASCEBC(out->label, sizeof(out->label));\r\n}\r\nstatic void int_to_ext_kekl(struct tape3592_kekl *in,\r\nstruct tape390_kekl *out)\r\n{\r\nmemset(out, 0, sizeof(*out));\r\nif(in->flags & 0x40)\r\nout->type = TAPE390_KEKL_TYPE_HASH;\r\nelse\r\nout->type = TAPE390_KEKL_TYPE_LABEL;\r\nif(in->flags & 0x80)\r\nout->type_on_tape = TAPE390_KEKL_TYPE_HASH;\r\nelse\r\nout->type_on_tape = TAPE390_KEKL_TYPE_LABEL;\r\nmemcpy(out->label, in->label, sizeof(in->label));\r\nEBCASC(out->label, sizeof(in->label));\r\nstrim(out->label);\r\n}\r\nstatic void int_to_ext_kekl_pair(struct tape3592_kekl_pair *in,\r\nstruct tape390_kekl_pair *out)\r\n{\r\nif (in->count == 0) {\r\nout->kekl[0].type = TAPE390_KEKL_TYPE_NONE;\r\nout->kekl[0].type_on_tape = TAPE390_KEKL_TYPE_NONE;\r\nout->kekl[1].type = TAPE390_KEKL_TYPE_NONE;\r\nout->kekl[1].type_on_tape = TAPE390_KEKL_TYPE_NONE;\r\n} else if (in->count == 1) {\r\nint_to_ext_kekl(&in->kekl[0], &out->kekl[0]);\r\nout->kekl[1].type = TAPE390_KEKL_TYPE_NONE;\r\nout->kekl[1].type_on_tape = TAPE390_KEKL_TYPE_NONE;\r\n} else if (in->count == 2) {\r\nint_to_ext_kekl(&in->kekl[0], &out->kekl[0]);\r\nint_to_ext_kekl(&in->kekl[1], &out->kekl[1]);\r\n} else {\r\nprintk("Invalid KEKL number: %d\n", in->count);\r\nBUG();\r\n}\r\n}\r\nstatic int check_ext_kekl(struct tape390_kekl *kekl)\r\n{\r\nif (kekl->type == TAPE390_KEKL_TYPE_NONE)\r\ngoto invalid;\r\nif (kekl->type > TAPE390_KEKL_TYPE_HASH)\r\ngoto invalid;\r\nif (kekl->type_on_tape == TAPE390_KEKL_TYPE_NONE)\r\ngoto invalid;\r\nif (kekl->type_on_tape > TAPE390_KEKL_TYPE_HASH)\r\ngoto invalid;\r\nif ((kekl->type == TAPE390_KEKL_TYPE_HASH) &&\r\n(kekl->type_on_tape == TAPE390_KEKL_TYPE_LABEL))\r\ngoto invalid;\r\nreturn 0;\r\ninvalid:\r\nreturn -EINVAL;\r\n}\r\nstatic int check_ext_kekl_pair(struct tape390_kekl_pair *kekls)\r\n{\r\nif (check_ext_kekl(&kekls->kekl[0]))\r\ngoto invalid;\r\nif (check_ext_kekl(&kekls->kekl[1]))\r\ngoto invalid;\r\nreturn 0;\r\ninvalid:\r\nreturn -EINVAL;\r\n}\r\nstatic int tape_3592_kekl_query(struct tape_device *device,\r\nstruct tape390_kekl_pair *ext_kekls)\r\n{\r\nstruct tape_request *request;\r\nstruct tape3592_kekl_query_order *order;\r\nstruct tape3592_kekl_query_data *int_kekls;\r\nint rc;\r\nDBF_EVENT(6, "tape3592_kekl_query\n");\r\nint_kekls = kmalloc(sizeof(*int_kekls), GFP_KERNEL|GFP_DMA);\r\nif (!int_kekls)\r\nreturn -ENOMEM;\r\nrequest = tape_alloc_request(2, sizeof(*order));\r\nif (IS_ERR(request)) {\r\nrc = PTR_ERR(request);\r\ngoto fail_malloc;\r\n}\r\norder = request->cpdata;\r\nmemset(order,0,sizeof(*order));\r\norder->code = 0xe2;\r\norder->max_count = 2;\r\nrequest->op = TO_KEKL_QUERY;\r\ntape_ccw_cc(request->cpaddr, PERF_SUBSYS_FUNC, sizeof(*order), order);\r\ntape_ccw_end(request->cpaddr + 1, READ_SS_DATA, sizeof(*int_kekls),\r\nint_kekls);\r\nrc = tape_do_io(device, request);\r\nif (rc)\r\ngoto fail_request;\r\nint_to_ext_kekl_pair(&int_kekls->kekls, ext_kekls);\r\nrc = 0;\r\nfail_request:\r\ntape_free_request(request);\r\nfail_malloc:\r\nkfree(int_kekls);\r\nreturn rc;\r\n}\r\nstatic int tape_3592_ioctl_kekl_query(struct tape_device *device,\r\nunsigned long arg)\r\n{\r\nint rc;\r\nstruct tape390_kekl_pair *ext_kekls;\r\nDBF_EVENT(6, "tape_3592_ioctl_kekl_query\n");\r\nif (!crypt_supported(device))\r\nreturn -ENOSYS;\r\nif (!crypt_enabled(device))\r\nreturn -EUNATCH;\r\next_kekls = kmalloc(sizeof(*ext_kekls), GFP_KERNEL);\r\nif (!ext_kekls)\r\nreturn -ENOMEM;\r\nrc = tape_3592_kekl_query(device, ext_kekls);\r\nif (rc != 0)\r\ngoto fail;\r\nif (copy_to_user((char __user *) arg, ext_kekls, sizeof(*ext_kekls))) {\r\nrc = -EFAULT;\r\ngoto fail;\r\n}\r\nrc = 0;\r\nfail:\r\nkfree(ext_kekls);\r\nreturn rc;\r\n}\r\nstatic int tape_3592_kekl_set(struct tape_device *device,\r\nstruct tape390_kekl_pair *ext_kekls)\r\n{\r\nstruct tape_request *request;\r\nstruct tape3592_kekl_set_order *order;\r\nDBF_EVENT(6, "tape3592_kekl_set\n");\r\nif (check_ext_kekl_pair(ext_kekls)) {\r\nDBF_EVENT(6, "invalid kekls\n");\r\nreturn -EINVAL;\r\n}\r\nif (tape_3590_mttell(device, 0) != 0)\r\nreturn -EBADSLT;\r\nrequest = tape_alloc_request(1, sizeof(*order));\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\norder = request->cpdata;\r\nmemset(order, 0, sizeof(*order));\r\norder->code = 0xe3;\r\norder->kekls.count = 2;\r\next_to_int_kekl(&ext_kekls->kekl[0], &order->kekls.kekl[0]);\r\next_to_int_kekl(&ext_kekls->kekl[1], &order->kekls.kekl[1]);\r\nrequest->op = TO_KEKL_SET;\r\ntape_ccw_end(request->cpaddr, PERF_SUBSYS_FUNC, sizeof(*order), order);\r\nreturn tape_do_io_free(device, request);\r\n}\r\nstatic int tape_3592_ioctl_kekl_set(struct tape_device *device,\r\nunsigned long arg)\r\n{\r\nint rc;\r\nstruct tape390_kekl_pair *ext_kekls;\r\nDBF_EVENT(6, "tape_3592_ioctl_kekl_set\n");\r\nif (!crypt_supported(device))\r\nreturn -ENOSYS;\r\nif (!crypt_enabled(device))\r\nreturn -EUNATCH;\r\next_kekls = memdup_user((char __user *)arg, sizeof(*ext_kekls));\r\nif (IS_ERR(ext_kekls))\r\nreturn PTR_ERR(ext_kekls);\r\nrc = tape_3592_kekl_set(device, ext_kekls);\r\nkfree(ext_kekls);\r\nreturn rc;\r\n}\r\nstatic struct tape_request *__tape_3592_enable_crypt(struct tape_device *device)\r\n{\r\nstruct tape_request *request;\r\nchar *data;\r\nDBF_EVENT(6, "tape_3592_enable_crypt\n");\r\nif (!crypt_supported(device))\r\nreturn ERR_PTR(-ENOSYS);\r\nrequest = tape_alloc_request(2, 72);\r\nif (IS_ERR(request))\r\nreturn request;\r\ndata = request->cpdata;\r\nmemset(data,0,72);\r\ndata[0] = 0x05;\r\ndata[36 + 0] = 0x03;\r\ndata[36 + 1] = 0x03;\r\ndata[36 + 4] = 0x40;\r\ndata[36 + 6] = 0x01;\r\ndata[36 + 14] = 0x2f;\r\ndata[36 + 18] = 0xc3;\r\ndata[36 + 35] = 0x72;\r\nrequest->op = TO_CRYPT_ON;\r\ntape_ccw_cc(request->cpaddr, MODE_SET_CB, 36, data);\r\ntape_ccw_end(request->cpaddr + 1, MODE_SET_CB, 36, data + 36);\r\nreturn request;\r\n}\r\nstatic int tape_3592_enable_crypt(struct tape_device *device)\r\n{\r\nstruct tape_request *request;\r\nrequest = __tape_3592_enable_crypt(device);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nreturn tape_do_io_free(device, request);\r\n}\r\nstatic void tape_3592_enable_crypt_async(struct tape_device *device)\r\n{\r\nstruct tape_request *request;\r\nrequest = __tape_3592_enable_crypt(device);\r\nif (!IS_ERR(request))\r\ntape_do_io_async_free(device, request);\r\n}\r\nstatic struct tape_request *__tape_3592_disable_crypt(struct tape_device *device)\r\n{\r\nstruct tape_request *request;\r\nchar *data;\r\nDBF_EVENT(6, "tape_3592_disable_crypt\n");\r\nif (!crypt_supported(device))\r\nreturn ERR_PTR(-ENOSYS);\r\nrequest = tape_alloc_request(2, 72);\r\nif (IS_ERR(request))\r\nreturn request;\r\ndata = request->cpdata;\r\nmemset(data,0,72);\r\ndata[0] = 0x05;\r\ndata[36 + 0] = 0x03;\r\ndata[36 + 1] = 0x03;\r\ndata[36 + 35] = 0x32;\r\nrequest->op = TO_CRYPT_OFF;\r\ntape_ccw_cc(request->cpaddr, MODE_SET_CB, 36, data);\r\ntape_ccw_end(request->cpaddr + 1, MODE_SET_CB, 36, data + 36);\r\nreturn request;\r\n}\r\nstatic int tape_3592_disable_crypt(struct tape_device *device)\r\n{\r\nstruct tape_request *request;\r\nrequest = __tape_3592_disable_crypt(device);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nreturn tape_do_io_free(device, request);\r\n}\r\nstatic void tape_3592_disable_crypt_async(struct tape_device *device)\r\n{\r\nstruct tape_request *request;\r\nrequest = __tape_3592_disable_crypt(device);\r\nif (!IS_ERR(request))\r\ntape_do_io_async_free(device, request);\r\n}\r\nstatic int tape_3592_ioctl_crypt_set(struct tape_device *device,\r\nunsigned long arg)\r\n{\r\nstruct tape390_crypt_info info;\r\nDBF_EVENT(6, "tape_3592_ioctl_crypt_set\n");\r\nif (!crypt_supported(device))\r\nreturn -ENOSYS;\r\nif (copy_from_user(&info, (char __user *)arg, sizeof(info)))\r\nreturn -EFAULT;\r\nif (info.status & ~TAPE390_CRYPT_ON_MASK)\r\nreturn -EINVAL;\r\nif (info.status & TAPE390_CRYPT_ON_MASK)\r\nreturn tape_3592_enable_crypt(device);\r\nelse\r\nreturn tape_3592_disable_crypt(device);\r\n}\r\nstatic int tape_3592_ioctl_crypt_query(struct tape_device *device,\r\nunsigned long arg)\r\n{\r\nDBF_EVENT(6, "tape_3592_ioctl_crypt_query\n");\r\nif (!crypt_supported(device))\r\nreturn -ENOSYS;\r\ntape_3590_sense_medium(device);\r\nif (copy_to_user((char __user *) arg, &TAPE_3590_CRYPT_INFO(device),\r\nsizeof(TAPE_3590_CRYPT_INFO(device))))\r\nreturn -EFAULT;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int\r\ntape_3590_ioctl(struct tape_device *device, unsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase TAPE390_DISPLAY: {\r\nstruct display_struct disp;\r\nif (copy_from_user(&disp, (char __user *) arg, sizeof(disp)))\r\nreturn -EFAULT;\r\nreturn tape_std_display(device, &disp);\r\n}\r\ncase TAPE390_KEKL_SET:\r\nreturn tape_3592_ioctl_kekl_set(device, arg);\r\ncase TAPE390_KEKL_QUERY:\r\nreturn tape_3592_ioctl_kekl_query(device, arg);\r\ncase TAPE390_CRYPT_SET:\r\nreturn tape_3592_ioctl_crypt_set(device, arg);\r\ncase TAPE390_CRYPT_QUERY:\r\nreturn tape_3592_ioctl_crypt_query(device, arg);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int tape_3590_sense_medium(struct tape_device *device)\r\n{\r\nstruct tape_request *request;\r\nrequest = tape_alloc_request(1, 128);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_MSEN;\r\ntape_ccw_end(request->cpaddr, MEDIUM_SENSE, 128, request->cpdata);\r\nreturn tape_do_io_free(device, request);\r\n}\r\nstatic void tape_3590_sense_medium_async(struct tape_device *device)\r\n{\r\nstruct tape_request *request;\r\nrequest = tape_alloc_request(1, 128);\r\nif (IS_ERR(request))\r\nreturn;\r\nrequest->op = TO_MSEN;\r\ntape_ccw_end(request->cpaddr, MEDIUM_SENSE, 128, request->cpdata);\r\ntape_do_io_async_free(device, request);\r\n}\r\nstatic int\r\ntape_3590_mttell(struct tape_device *device, int mt_count)\r\n{\r\n__u64 block_id;\r\nint rc;\r\nrc = tape_std_read_block_id(device, &block_id);\r\nif (rc)\r\nreturn rc;\r\nreturn block_id >> 32;\r\n}\r\nstatic int\r\ntape_3590_mtseek(struct tape_device *device, int count)\r\n{\r\nstruct tape_request *request;\r\nDBF_EVENT(6, "xsee id: %x\n", count);\r\nrequest = tape_alloc_request(3, 4);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_LBL;\r\ntape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\r\n*(__u32 *) request->cpdata = count;\r\ntape_ccw_cc(request->cpaddr + 1, LOCATE, 4, request->cpdata);\r\ntape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);\r\nreturn tape_do_io_free(device, request);\r\n}\r\nstatic void\r\ntape_3590_read_opposite(struct tape_device *device,\r\nstruct tape_request *request)\r\n{\r\nstruct tape_3590_disc_data *data;\r\nrequest->op = TO_RBA;\r\ntape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\r\ndata = device->discdata;\r\ntape_ccw_cc_idal(request->cpaddr + 1, data->read_back_op,\r\ndevice->char_data.idal_buf);\r\ntape_ccw_cc(request->cpaddr + 2, FORSPACEBLOCK, 0, NULL);\r\ntape_ccw_end(request->cpaddr + 3, NOP, 0, NULL);\r\nDBF_EVENT(6, "xrop ccwg\n");\r\n}\r\nstatic void tape_3590_read_attmsg_async(struct tape_device *device)\r\n{\r\nstruct tape_request *request;\r\nchar *buf;\r\nrequest = tape_alloc_request(3, 4096);\r\nif (IS_ERR(request))\r\nreturn;\r\nrequest->op = TO_READ_ATTMSG;\r\nbuf = request->cpdata;\r\nbuf[0] = PREP_RD_SS_DATA;\r\nbuf[6] = RD_ATTMSG;\r\ntape_ccw_cc(request->cpaddr, PERFORM_SS_FUNC, 12, buf);\r\ntape_ccw_cc(request->cpaddr + 1, READ_SS_DATA, 4096 - 12, buf + 12);\r\ntape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);\r\ntape_do_io_async_free(device, request);\r\n}\r\nstatic void\r\ntape_3590_work_handler(struct work_struct *work)\r\n{\r\nstruct work_handler_data *p =\r\ncontainer_of(work, struct work_handler_data, work);\r\nswitch (p->op) {\r\ncase TO_MSEN:\r\ntape_3590_sense_medium_async(p->device);\r\nbreak;\r\ncase TO_READ_ATTMSG:\r\ntape_3590_read_attmsg_async(p->device);\r\nbreak;\r\ncase TO_CRYPT_ON:\r\ntape_3592_enable_crypt_async(p->device);\r\nbreak;\r\ncase TO_CRYPT_OFF:\r\ntape_3592_disable_crypt_async(p->device);\r\nbreak;\r\ndefault:\r\nDBF_EVENT(3, "T3590: work handler undefined for "\r\n"operation 0x%02x\n", p->op);\r\n}\r\ntape_put_device(p->device);\r\nkfree(p);\r\n}\r\nstatic int\r\ntape_3590_schedule_work(struct tape_device *device, enum tape_op op)\r\n{\r\nstruct work_handler_data *p;\r\nif ((p = kzalloc(sizeof(*p), GFP_ATOMIC)) == NULL)\r\nreturn -ENOMEM;\r\nINIT_WORK(&p->work, tape_3590_work_handler);\r\np->device = tape_get_device(device);\r\np->op = op;\r\nqueue_work(tape_3590_wq, &p->work);\r\nreturn 0;\r\n}\r\nstatic void tape_3590_med_state_set(struct tape_device *device,\r\nstruct tape_3590_med_sense *sense)\r\n{\r\nstruct tape390_crypt_info *c_info;\r\nc_info = &TAPE_3590_CRYPT_INFO(device);\r\nDBF_EVENT(6, "medium state: %x:%x\n", sense->macst, sense->masst);\r\nswitch (sense->macst) {\r\ncase 0x04:\r\ncase 0x05:\r\ncase 0x06:\r\ntape_med_state_set(device, MS_UNLOADED);\r\nTAPE_3590_CRYPT_INFO(device).medium_status = 0;\r\nreturn;\r\ncase 0x08:\r\ncase 0x09:\r\ntape_med_state_set(device, MS_LOADED);\r\nbreak;\r\ndefault:\r\ntape_med_state_set(device, MS_UNKNOWN);\r\nreturn;\r\n}\r\nc_info->medium_status |= TAPE390_MEDIUM_LOADED_MASK;\r\nif (sense->flags & MSENSE_CRYPT_MASK) {\r\nDBF_EVENT(6, "Medium is encrypted (%04x)\n", sense->flags);\r\nc_info->medium_status |= TAPE390_MEDIUM_ENCRYPTED_MASK;\r\n} else {\r\nDBF_EVENT(6, "Medium is not encrypted %04x\n", sense->flags);\r\nc_info->medium_status &= ~TAPE390_MEDIUM_ENCRYPTED_MASK;\r\n}\r\n}\r\nstatic int\r\ntape_3590_done(struct tape_device *device, struct tape_request *request)\r\n{\r\nDBF_EVENT(6, "%s done\n", tape_op_verbose[request->op]);\r\nswitch (request->op) {\r\ncase TO_BSB:\r\ncase TO_BSF:\r\ncase TO_DSE:\r\ncase TO_FSB:\r\ncase TO_FSF:\r\ncase TO_LBL:\r\ncase TO_RFO:\r\ncase TO_RBA:\r\ncase TO_REW:\r\ncase TO_WRI:\r\ncase TO_WTM:\r\ncase TO_BLOCK:\r\ncase TO_LOAD:\r\ntape_med_state_set(device, MS_LOADED);\r\nbreak;\r\ncase TO_RUN:\r\ntape_med_state_set(device, MS_UNLOADED);\r\ntape_3590_schedule_work(device, TO_CRYPT_OFF);\r\nbreak;\r\ncase TO_MSEN:\r\ntape_3590_med_state_set(device, request->cpdata);\r\nbreak;\r\ncase TO_CRYPT_ON:\r\nTAPE_3590_CRYPT_INFO(device).status\r\n|= TAPE390_CRYPT_ON_MASK;\r\n*(device->modeset_byte) |= 0x03;\r\nbreak;\r\ncase TO_CRYPT_OFF:\r\nTAPE_3590_CRYPT_INFO(device).status\r\n&= ~TAPE390_CRYPT_ON_MASK;\r\n*(device->modeset_byte) &= ~0x03;\r\nbreak;\r\ncase TO_RBI:\r\ncase TO_NOP:\r\ncase TO_READ_CONFIG:\r\ncase TO_READ_ATTMSG:\r\ncase TO_DIS:\r\ncase TO_ASSIGN:\r\ncase TO_UNASSIGN:\r\ncase TO_SIZE:\r\ncase TO_KEKL_SET:\r\ncase TO_KEKL_QUERY:\r\ncase TO_RDC:\r\nbreak;\r\n}\r\nreturn TAPE_IO_SUCCESS;\r\n}\r\nstatic inline int\r\ntape_3590_erp_succeded(struct tape_device *device, struct tape_request *request)\r\n{\r\nDBF_EVENT(3, "Error Recovery successful for %s\n",\r\ntape_op_verbose[request->op]);\r\nreturn tape_3590_done(device, request);\r\n}\r\nstatic inline int\r\ntape_3590_erp_failed(struct tape_device *device, struct tape_request *request,\r\nstruct irb *irb, int rc)\r\n{\r\nDBF_EVENT(3, "Error Recovery failed for %s\n",\r\ntape_op_verbose[request->op]);\r\ntape_dump_sense_dbf(device, request, irb);\r\nreturn rc;\r\n}\r\nstatic inline int\r\ntape_3590_erp_retry(struct tape_device *device, struct tape_request *request,\r\nstruct irb *irb)\r\n{\r\nDBF_EVENT(2, "Retry: %s\n", tape_op_verbose[request->op]);\r\ntape_dump_sense_dbf(device, request, irb);\r\nreturn TAPE_IO_RETRY;\r\n}\r\nstatic int\r\ntape_3590_unsolicited_irq(struct tape_device *device, struct irb *irb)\r\n{\r\nif (irb->scsw.cmd.dstat == DEV_STAT_CHN_END)\r\nreturn TAPE_IO_PENDING;\r\nelse if (irb->scsw.cmd.dstat == 0x85)\r\nDBF_EVENT(3, "unsol.irq! tape ready: %08x\n", device->cdev_id);\r\nelse if (irb->scsw.cmd.dstat & DEV_STAT_ATTENTION) {\r\ntape_3590_schedule_work(device, TO_READ_ATTMSG);\r\n} else {\r\nDBF_EVENT(3, "unsol.irq! dev end: %08x\n", device->cdev_id);\r\ntape_dump_sense_dbf(device, NULL, irb);\r\n}\r\ntape_3590_schedule_work(device, TO_MSEN);\r\nreturn TAPE_IO_SUCCESS;\r\n}\r\nstatic int\r\ntape_3590_erp_basic(struct tape_device *device, struct tape_request *request,\r\nstruct irb *irb, int rc)\r\n{\r\nstruct tape_3590_sense *sense;\r\nsense = (struct tape_3590_sense *) irb->ecw;\r\nswitch (sense->bra) {\r\ncase SENSE_BRA_PER:\r\nreturn tape_3590_erp_failed(device, request, irb, rc);\r\ncase SENSE_BRA_CONT:\r\nreturn tape_3590_erp_succeded(device, request);\r\ncase SENSE_BRA_RE:\r\nreturn tape_3590_erp_retry(device, request, irb);\r\ncase SENSE_BRA_DRE:\r\nreturn tape_3590_erp_failed(device, request, irb, rc);\r\ndefault:\r\nBUG();\r\nreturn TAPE_IO_STOP;\r\n}\r\n}\r\nstatic int\r\ntape_3590_erp_read_buf_log(struct tape_device *device,\r\nstruct tape_request *request, struct irb *irb)\r\n{\r\nreturn tape_3590_erp_basic(device, request, irb, -EIO);\r\n}\r\nstatic int\r\ntape_3590_erp_swap(struct tape_device *device, struct tape_request *request,\r\nstruct irb *irb)\r\n{\r\ndev_warn (&device->cdev->dev, "The tape medium must be loaded into a "\r\n"different tape unit\n");\r\nreturn tape_3590_erp_basic(device, request, irb, -EIO);\r\n}\r\nstatic int\r\ntape_3590_erp_long_busy(struct tape_device *device,\r\nstruct tape_request *request, struct irb *irb)\r\n{\r\nDBF_EVENT(6, "Device is busy\n");\r\nreturn TAPE_IO_LONG_BUSY;\r\n}\r\nstatic int\r\ntape_3590_erp_special_interrupt(struct tape_device *device,\r\nstruct tape_request *request, struct irb *irb)\r\n{\r\nreturn tape_3590_erp_basic(device, request, irb, -EIO);\r\n}\r\nstatic int\r\ntape_3590_erp_read_alternate(struct tape_device *device,\r\nstruct tape_request *request, struct irb *irb)\r\n{\r\nstruct tape_3590_disc_data *data;\r\ndata = device->discdata;\r\nif (data->read_back_op == READ_PREVIOUS) {\r\nDBF_EVENT(2, "(%08x): No support for READ_PREVIOUS command\n",\r\ndevice->cdev_id);\r\ndata->read_back_op = READ_BACKWARD;\r\n} else {\r\nDBF_EVENT(2, "(%08x): No support for READ_BACKWARD command\n",\r\ndevice->cdev_id);\r\ndata->read_back_op = READ_PREVIOUS;\r\n}\r\ntape_3590_read_opposite(device, request);\r\nreturn tape_3590_erp_retry(device, request, irb);\r\n}\r\nstatic int\r\ntape_3590_erp_read_opposite(struct tape_device *device,\r\nstruct tape_request *request, struct irb *irb)\r\n{\r\nswitch (request->op) {\r\ncase TO_RFO:\r\ntape_3590_read_opposite(device, request);\r\nreturn tape_3590_erp_retry(device, request, irb);\r\ncase TO_RBA:\r\nreturn tape_3590_erp_failed(device, request, irb, -EIO);\r\nbreak;\r\ndefault:\r\nreturn tape_3590_erp_failed(device, request, irb, -EIO);\r\n}\r\n}\r\nstatic void\r\ntape_3590_print_mim_msg_f0(struct tape_device *device, struct irb *irb)\r\n{\r\nstruct tape_3590_sense *sense;\r\nchar *exception, *service;\r\nexception = kmalloc(BUFSIZE, GFP_ATOMIC);\r\nservice = kmalloc(BUFSIZE, GFP_ATOMIC);\r\nif (!exception || !service)\r\ngoto out_nomem;\r\nsense = (struct tape_3590_sense *) irb->ecw;\r\nswitch (sense->fmt.f70.emc) {\r\ncase 0x02:\r\nsnprintf(exception, BUFSIZE, "Data degraded");\r\nbreak;\r\ncase 0x03:\r\nsnprintf(exception, BUFSIZE, "Data degraded in partion %i",\r\nsense->fmt.f70.mp);\r\nbreak;\r\ncase 0x04:\r\nsnprintf(exception, BUFSIZE, "Medium degraded");\r\nbreak;\r\ncase 0x05:\r\nsnprintf(exception, BUFSIZE, "Medium degraded in partition %i",\r\nsense->fmt.f70.mp);\r\nbreak;\r\ncase 0x06:\r\nsnprintf(exception, BUFSIZE, "Block 0 Error");\r\nbreak;\r\ncase 0x07:\r\nsnprintf(exception, BUFSIZE, "Medium Exception 0x%02x",\r\nsense->fmt.f70.md);\r\nbreak;\r\ndefault:\r\nsnprintf(exception, BUFSIZE, "0x%02x",\r\nsense->fmt.f70.emc);\r\nbreak;\r\n}\r\nswitch (sense->fmt.f70.smc) {\r\ncase 0x02:\r\nsnprintf(service, BUFSIZE, "Reference Media maintenance "\r\n"procedure %i", sense->fmt.f70.md);\r\nbreak;\r\ndefault:\r\nsnprintf(service, BUFSIZE, "0x%02x",\r\nsense->fmt.f70.smc);\r\nbreak;\r\n}\r\ndev_warn (&device->cdev->dev, "Tape media information: exception %s, "\r\n"service %s\n", exception, service);\r\nout_nomem:\r\nkfree(exception);\r\nkfree(service);\r\n}\r\nstatic void\r\ntape_3590_print_io_sim_msg_f1(struct tape_device *device, struct irb *irb)\r\n{\r\nstruct tape_3590_sense *sense;\r\nchar *exception, *service;\r\nexception = kmalloc(BUFSIZE, GFP_ATOMIC);\r\nservice = kmalloc(BUFSIZE, GFP_ATOMIC);\r\nif (!exception || !service)\r\ngoto out_nomem;\r\nsense = (struct tape_3590_sense *) irb->ecw;\r\nswitch (sense->fmt.f71.emc) {\r\ncase 0x01:\r\nsnprintf(exception, BUFSIZE, "Effect of failure is unknown");\r\nbreak;\r\ncase 0x02:\r\nsnprintf(exception, BUFSIZE, "CU Exception - no performance "\r\n"impact");\r\nbreak;\r\ncase 0x03:\r\nsnprintf(exception, BUFSIZE, "CU Exception on channel "\r\n"interface 0x%02x", sense->fmt.f71.md[0]);\r\nbreak;\r\ncase 0x04:\r\nsnprintf(exception, BUFSIZE, "CU Exception on device path "\r\n"0x%02x", sense->fmt.f71.md[0]);\r\nbreak;\r\ncase 0x05:\r\nsnprintf(exception, BUFSIZE, "CU Exception on library path "\r\n"0x%02x", sense->fmt.f71.md[0]);\r\nbreak;\r\ncase 0x06:\r\nsnprintf(exception, BUFSIZE, "CU Exception on node 0x%02x",\r\nsense->fmt.f71.md[0]);\r\nbreak;\r\ncase 0x07:\r\nsnprintf(exception, BUFSIZE, "CU Exception on partition "\r\n"0x%02x", sense->fmt.f71.md[0]);\r\nbreak;\r\ndefault:\r\nsnprintf(exception, BUFSIZE, "0x%02x",\r\nsense->fmt.f71.emc);\r\n}\r\nswitch (sense->fmt.f71.smc) {\r\ncase 0x01:\r\nsnprintf(service, BUFSIZE, "Repair impact is unknown");\r\nbreak;\r\ncase 0x02:\r\nsnprintf(service, BUFSIZE, "Repair will not impact cu "\r\n"performance");\r\nbreak;\r\ncase 0x03:\r\nif (sense->fmt.f71.mdf == 0)\r\nsnprintf(service, BUFSIZE, "Repair will disable node "\r\n"0x%x on CU", sense->fmt.f71.md[1]);\r\nelse\r\nsnprintf(service, BUFSIZE, "Repair will disable "\r\n"nodes (0x%x-0x%x) on CU", sense->fmt.f71.md[1],\r\nsense->fmt.f71.md[2]);\r\nbreak;\r\ncase 0x04:\r\nif (sense->fmt.f71.mdf == 0)\r\nsnprintf(service, BUFSIZE, "Repair will disable "\r\n"channel path 0x%x on CU",\r\nsense->fmt.f71.md[1]);\r\nelse\r\nsnprintf(service, BUFSIZE, "Repair will disable channel"\r\n" paths (0x%x-0x%x) on CU",\r\nsense->fmt.f71.md[1], sense->fmt.f71.md[2]);\r\nbreak;\r\ncase 0x05:\r\nif (sense->fmt.f71.mdf == 0)\r\nsnprintf(service, BUFSIZE, "Repair will disable device"\r\n" path 0x%x on CU", sense->fmt.f71.md[1]);\r\nelse\r\nsnprintf(service, BUFSIZE, "Repair will disable device"\r\n" paths (0x%x-0x%x) on CU",\r\nsense->fmt.f71.md[1], sense->fmt.f71.md[2]);\r\nbreak;\r\ncase 0x06:\r\nif (sense->fmt.f71.mdf == 0)\r\nsnprintf(service, BUFSIZE, "Repair will disable "\r\n"library path 0x%x on CU",\r\nsense->fmt.f71.md[1]);\r\nelse\r\nsnprintf(service, BUFSIZE, "Repair will disable "\r\n"library paths (0x%x-0x%x) on CU",\r\nsense->fmt.f71.md[1], sense->fmt.f71.md[2]);\r\nbreak;\r\ncase 0x07:\r\nsnprintf(service, BUFSIZE, "Repair will disable access to CU");\r\nbreak;\r\ndefault:\r\nsnprintf(service, BUFSIZE, "0x%02x",\r\nsense->fmt.f71.smc);\r\n}\r\ndev_warn (&device->cdev->dev, "I/O subsystem information: exception"\r\n" %s, service %s\n", exception, service);\r\nout_nomem:\r\nkfree(exception);\r\nkfree(service);\r\n}\r\nstatic void\r\ntape_3590_print_dev_sim_msg_f2(struct tape_device *device, struct irb *irb)\r\n{\r\nstruct tape_3590_sense *sense;\r\nchar *exception, *service;\r\nexception = kmalloc(BUFSIZE, GFP_ATOMIC);\r\nservice = kmalloc(BUFSIZE, GFP_ATOMIC);\r\nif (!exception || !service)\r\ngoto out_nomem;\r\nsense = (struct tape_3590_sense *) irb->ecw;\r\nswitch (sense->fmt.f71.emc) {\r\ncase 0x01:\r\nsnprintf(exception, BUFSIZE, "Effect of failure is unknown");\r\nbreak;\r\ncase 0x02:\r\nsnprintf(exception, BUFSIZE, "DV Exception - no performance"\r\n" impact");\r\nbreak;\r\ncase 0x03:\r\nsnprintf(exception, BUFSIZE, "DV Exception on channel "\r\n"interface 0x%02x", sense->fmt.f71.md[0]);\r\nbreak;\r\ncase 0x04:\r\nsnprintf(exception, BUFSIZE, "DV Exception on loader 0x%02x",\r\nsense->fmt.f71.md[0]);\r\nbreak;\r\ncase 0x05:\r\nsnprintf(exception, BUFSIZE, "DV Exception on message display"\r\n" 0x%02x", sense->fmt.f71.md[0]);\r\nbreak;\r\ncase 0x06:\r\nsnprintf(exception, BUFSIZE, "DV Exception in tape path");\r\nbreak;\r\ncase 0x07:\r\nsnprintf(exception, BUFSIZE, "DV Exception in drive");\r\nbreak;\r\ndefault:\r\nsnprintf(exception, BUFSIZE, "0x%02x",\r\nsense->fmt.f71.emc);\r\n}\r\nswitch (sense->fmt.f71.smc) {\r\ncase 0x01:\r\nsnprintf(service, BUFSIZE, "Repair impact is unknown");\r\nbreak;\r\ncase 0x02:\r\nsnprintf(service, BUFSIZE, "Repair will not impact device "\r\n"performance");\r\nbreak;\r\ncase 0x03:\r\nif (sense->fmt.f71.mdf == 0)\r\nsnprintf(service, BUFSIZE, "Repair will disable "\r\n"channel path 0x%x on DV",\r\nsense->fmt.f71.md[1]);\r\nelse\r\nsnprintf(service, BUFSIZE, "Repair will disable "\r\n"channel path (0x%x-0x%x) on DV",\r\nsense->fmt.f71.md[1], sense->fmt.f71.md[2]);\r\nbreak;\r\ncase 0x04:\r\nif (sense->fmt.f71.mdf == 0)\r\nsnprintf(service, BUFSIZE, "Repair will disable "\r\n"interface 0x%x on DV", sense->fmt.f71.md[1]);\r\nelse\r\nsnprintf(service, BUFSIZE, "Repair will disable "\r\n"interfaces (0x%x-0x%x) on DV",\r\nsense->fmt.f71.md[1], sense->fmt.f71.md[2]);\r\nbreak;\r\ncase 0x05:\r\nif (sense->fmt.f71.mdf == 0)\r\nsnprintf(service, BUFSIZE, "Repair will disable loader"\r\n" 0x%x on DV", sense->fmt.f71.md[1]);\r\nelse\r\nsnprintf(service, BUFSIZE, "Repair will disable loader"\r\n" (0x%x-0x%x) on DV",\r\nsense->fmt.f71.md[1], sense->fmt.f71.md[2]);\r\nbreak;\r\ncase 0x07:\r\nsnprintf(service, BUFSIZE, "Repair will disable access to DV");\r\nbreak;\r\ncase 0x08:\r\nif (sense->fmt.f71.mdf == 0)\r\nsnprintf(service, BUFSIZE, "Repair will disable "\r\n"message display 0x%x on DV",\r\nsense->fmt.f71.md[1]);\r\nelse\r\nsnprintf(service, BUFSIZE, "Repair will disable "\r\n"message displays (0x%x-0x%x) on DV",\r\nsense->fmt.f71.md[1], sense->fmt.f71.md[2]);\r\nbreak;\r\ncase 0x09:\r\nsnprintf(service, BUFSIZE, "Clean DV");\r\nbreak;\r\ndefault:\r\nsnprintf(service, BUFSIZE, "0x%02x",\r\nsense->fmt.f71.smc);\r\n}\r\ndev_warn (&device->cdev->dev, "Device subsystem information: exception"\r\n" %s, service %s\n", exception, service);\r\nout_nomem:\r\nkfree(exception);\r\nkfree(service);\r\n}\r\nstatic void\r\ntape_3590_print_era_msg(struct tape_device *device, struct irb *irb)\r\n{\r\nstruct tape_3590_sense *sense;\r\nsense = (struct tape_3590_sense *) irb->ecw;\r\nif (sense->mc == 0)\r\nreturn;\r\nif ((sense->mc > 0) && (sense->mc < TAPE_3590_MAX_MSG)) {\r\nif (tape_3590_msg[sense->mc] != NULL)\r\ndev_warn (&device->cdev->dev, "The tape unit has "\r\n"issued sense message %s\n",\r\ntape_3590_msg[sense->mc]);\r\nelse\r\ndev_warn (&device->cdev->dev, "The tape unit has "\r\n"issued an unknown sense message code 0x%x\n",\r\nsense->mc);\r\nreturn;\r\n}\r\nif (sense->mc == 0xf0) {\r\ndev_warn (&device->cdev->dev, "MIM SEV=%i, MC=%02x, ES=%x/%x, "\r\n"RC=%02x-%04x-%02x\n", sense->fmt.f70.sev, sense->mc,\r\nsense->fmt.f70.emc, sense->fmt.f70.smc,\r\nsense->fmt.f70.refcode, sense->fmt.f70.mid,\r\nsense->fmt.f70.fid);\r\ntape_3590_print_mim_msg_f0(device, irb);\r\nreturn;\r\n}\r\nif (sense->mc == 0xf1) {\r\ndev_warn (&device->cdev->dev, "IOSIM SEV=%i, DEVTYPE=3590/%02x,"\r\n" MC=%02x, ES=%x/%x, REF=0x%04x-0x%04x-0x%04x\n",\r\nsense->fmt.f71.sev, device->cdev->id.dev_model,\r\nsense->mc, sense->fmt.f71.emc, sense->fmt.f71.smc,\r\nsense->fmt.f71.refcode1, sense->fmt.f71.refcode2,\r\nsense->fmt.f71.refcode3);\r\ntape_3590_print_io_sim_msg_f1(device, irb);\r\nreturn;\r\n}\r\nif (sense->mc == 0xf2) {\r\ndev_warn (&device->cdev->dev, "DEVSIM SEV=%i, DEVTYPE=3590/%02x"\r\n", MC=%02x, ES=%x/%x, REF=0x%04x-0x%04x-0x%04x\n",\r\nsense->fmt.f71.sev, device->cdev->id.dev_model,\r\nsense->mc, sense->fmt.f71.emc, sense->fmt.f71.smc,\r\nsense->fmt.f71.refcode1, sense->fmt.f71.refcode2,\r\nsense->fmt.f71.refcode3);\r\ntape_3590_print_dev_sim_msg_f2(device, irb);\r\nreturn;\r\n}\r\nif (sense->mc == 0xf3) {\r\nreturn;\r\n}\r\ndev_warn (&device->cdev->dev, "The tape unit has issued an unknown "\r\n"sense message code %x\n", sense->mc);\r\n}\r\nstatic int tape_3590_crypt_error(struct tape_device *device,\r\nstruct tape_request *request, struct irb *irb)\r\n{\r\nu8 cu_rc;\r\nu16 ekm_rc2;\r\nchar *sense;\r\nsense = ((struct tape_3590_sense *) irb->ecw)->fmt.data;\r\ncu_rc = sense[0];\r\nekm_rc2 = *((u16*) &sense[10]);\r\nif ((cu_rc == 0) && (ekm_rc2 == 0xee31))\r\nreturn tape_3590_erp_basic(device, request, irb, -EKEYREJECTED);\r\nif ((cu_rc == 1) || (cu_rc == 2))\r\nreturn tape_3590_erp_basic(device, request, irb, -ENOTCONN);\r\ndev_err (&device->cdev->dev, "The tape unit failed to obtain the "\r\n"encryption key from EKM\n");\r\nreturn tape_3590_erp_basic(device, request, irb, -ENOKEY);\r\n}\r\nstatic int\r\ntape_3590_unit_check(struct tape_device *device, struct tape_request *request,\r\nstruct irb *irb)\r\n{\r\nstruct tape_3590_sense *sense;\r\nsense = (struct tape_3590_sense *) irb->ecw;\r\nDBF_EVENT(6, "Unit Check: RQC = %x\n", sense->rc_rqc);\r\nswitch (sense->rc_rqc) {\r\ncase 0x1110:\r\ntape_3590_print_era_msg(device, irb);\r\nreturn tape_3590_erp_read_buf_log(device, request, irb);\r\ncase 0x2011:\r\ntape_3590_print_era_msg(device, irb);\r\nreturn tape_3590_erp_read_alternate(device, request, irb);\r\ncase 0x2230:\r\ncase 0x2231:\r\ntape_3590_print_era_msg(device, irb);\r\nreturn tape_3590_erp_special_interrupt(device, request, irb);\r\ncase 0x2240:\r\nreturn tape_3590_crypt_error(device, request, irb);\r\ncase 0x3010:\r\nDBF_EVENT(2, "(%08x): Backward at Beginning of Partition\n",\r\ndevice->cdev_id);\r\nreturn tape_3590_erp_basic(device, request, irb, -ENOSPC);\r\ncase 0x3012:\r\nDBF_EVENT(2, "(%08x): Forward at End of Partition\n",\r\ndevice->cdev_id);\r\nreturn tape_3590_erp_basic(device, request, irb, -ENOSPC);\r\ncase 0x3020:\r\nDBF_EVENT(2, "(%08x): End of Data Mark\n", device->cdev_id);\r\nreturn tape_3590_erp_basic(device, request, irb, -ENOSPC);\r\ncase 0x3122:\r\nDBF_EVENT(2, "(%08x): Rewind Unload initiated\n",\r\ndevice->cdev_id);\r\nreturn tape_3590_erp_basic(device, request, irb, -EIO);\r\ncase 0x3123:\r\nDBF_EVENT(2, "(%08x): Rewind Unload complete\n",\r\ndevice->cdev_id);\r\ntape_med_state_set(device, MS_UNLOADED);\r\ntape_3590_schedule_work(device, TO_CRYPT_OFF);\r\nreturn tape_3590_erp_basic(device, request, irb, 0);\r\ncase 0x4010:\r\ntape_med_state_set(device, MS_UNLOADED);\r\ntape_3590_schedule_work(device, TO_CRYPT_OFF);\r\nreturn tape_3590_erp_basic(device, request, irb, -ENOMEDIUM);\r\ncase 0x4012:\r\nDBF_EVENT(6, "(%08x): LONG BUSY\n", device->cdev_id);\r\ntape_3590_print_era_msg(device, irb);\r\nreturn tape_3590_erp_basic(device, request, irb, -EBUSY);\r\ncase 0x4014:\r\nDBF_EVENT(6, "(%08x): Crypto LONG BUSY\n", device->cdev_id);\r\nreturn tape_3590_erp_long_busy(device, request, irb);\r\ncase 0x5010:\r\nif (sense->rac == 0xd0) {\r\ntape_3590_print_era_msg(device, irb);\r\nreturn tape_3590_erp_swap(device, request, irb);\r\n}\r\nif (sense->rac == 0x26) {\r\ntape_3590_print_era_msg(device, irb);\r\nreturn tape_3590_erp_read_opposite(device, request,\r\nirb);\r\n}\r\nreturn tape_3590_erp_basic(device, request, irb, -EIO);\r\ncase 0x5020:\r\ncase 0x5021:\r\ncase 0x5022:\r\ncase 0x5040:\r\ncase 0x5041:\r\ncase 0x5042:\r\ntape_3590_print_era_msg(device, irb);\r\nreturn tape_3590_erp_swap(device, request, irb);\r\ncase 0x5110:\r\ncase 0x5111:\r\nreturn tape_3590_erp_basic(device, request, irb, -EMEDIUMTYPE);\r\ncase 0x5120:\r\ncase 0x1120:\r\ntape_med_state_set(device, MS_UNLOADED);\r\ntape_3590_schedule_work(device, TO_CRYPT_OFF);\r\nreturn tape_3590_erp_basic(device, request, irb, -ENOMEDIUM);\r\ncase 0x6020:\r\nreturn tape_3590_erp_basic(device, request, irb, -EMEDIUMTYPE);\r\ncase 0x8011:\r\nreturn tape_3590_erp_basic(device, request, irb, -EPERM);\r\ncase 0x8013:\r\ndev_warn (&device->cdev->dev, "A different host has privileged"\r\n" access to the tape unit\n");\r\nreturn tape_3590_erp_basic(device, request, irb, -EPERM);\r\ndefault:\r\nreturn tape_3590_erp_basic(device, request, irb, -EIO);\r\n}\r\n}\r\nstatic int\r\ntape_3590_irq(struct tape_device *device, struct tape_request *request,\r\nstruct irb *irb)\r\n{\r\nif (request == NULL)\r\nreturn tape_3590_unsolicited_irq(device, irb);\r\nif ((irb->scsw.cmd.dstat & DEV_STAT_UNIT_EXCEP) &&\r\n(irb->scsw.cmd.dstat & DEV_STAT_DEV_END) &&\r\n(request->op == TO_WRI)) {\r\nDBF_EVENT(2, "End of volume\n");\r\nreturn tape_3590_erp_failed(device, request, irb, -ENOSPC);\r\n}\r\nif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK)\r\nreturn tape_3590_unit_check(device, request, irb);\r\nif (irb->scsw.cmd.dstat & DEV_STAT_DEV_END) {\r\nif (irb->scsw.cmd.dstat == DEV_STAT_UNIT_EXCEP) {\r\nif (request->op == TO_FSB || request->op == TO_BSB)\r\nrequest->rescnt++;\r\nelse\r\nDBF_EVENT(5, "Unit Exception!\n");\r\n}\r\nreturn tape_3590_done(device, request);\r\n}\r\nif (irb->scsw.cmd.dstat & DEV_STAT_CHN_END) {\r\nDBF_EVENT(2, "channel end\n");\r\nreturn TAPE_IO_PENDING;\r\n}\r\nif (irb->scsw.cmd.dstat & DEV_STAT_ATTENTION) {\r\nDBF_EVENT(2, "Unit Attention when busy..\n");\r\nreturn TAPE_IO_PENDING;\r\n}\r\nDBF_EVENT(6, "xunknownirq\n");\r\ntape_dump_sense_dbf(device, request, irb);\r\nreturn TAPE_IO_STOP;\r\n}\r\nstatic int tape_3590_read_dev_chars(struct tape_device *device,\r\nstruct tape_3590_rdc_data *rdc_data)\r\n{\r\nint rc;\r\nstruct tape_request *request;\r\nrequest = tape_alloc_request(1, sizeof(*rdc_data));\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_RDC;\r\ntape_ccw_end(request->cpaddr, CCW_CMD_RDC, sizeof(*rdc_data),\r\nrequest->cpdata);\r\nrc = tape_do_io(device, request);\r\nif (rc == 0)\r\nmemcpy(rdc_data, request->cpdata, sizeof(*rdc_data));\r\ntape_free_request(request);\r\nreturn rc;\r\n}\r\nstatic int\r\ntape_3590_setup_device(struct tape_device *device)\r\n{\r\nint rc;\r\nstruct tape_3590_disc_data *data;\r\nstruct tape_3590_rdc_data *rdc_data;\r\nDBF_EVENT(6, "3590 device setup\n");\r\ndata = kzalloc(sizeof(struct tape_3590_disc_data), GFP_KERNEL | GFP_DMA);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\ndata->read_back_op = READ_PREVIOUS;\r\ndevice->discdata = data;\r\nrdc_data = kmalloc(sizeof(*rdc_data), GFP_KERNEL | GFP_DMA);\r\nif (!rdc_data) {\r\nrc = -ENOMEM;\r\ngoto fail_kmalloc;\r\n}\r\nrc = tape_3590_read_dev_chars(device, rdc_data);\r\nif (rc) {\r\nDBF_LH(3, "Read device characteristics failed!\n");\r\ngoto fail_rdc_data;\r\n}\r\nrc = tape_std_assign(device);\r\nif (rc)\r\ngoto fail_rdc_data;\r\nif (rdc_data->data[31] == 0x13) {\r\ndata->crypt_info.capability |= TAPE390_CRYPT_SUPPORTED_MASK;\r\ntape_3592_disable_crypt(device);\r\n} else {\r\nDBF_EVENT(6, "Device has NO crypto support\n");\r\n}\r\nrc = tape_3590_sense_medium(device);\r\nif (rc) {\r\nDBF_LH(3, "3590 medium sense returned %d\n", rc);\r\ngoto fail_rdc_data;\r\n}\r\nreturn 0;\r\nfail_rdc_data:\r\nkfree(rdc_data);\r\nfail_kmalloc:\r\nkfree(data);\r\nreturn rc;\r\n}\r\nstatic void\r\ntape_3590_cleanup_device(struct tape_device *device)\r\n{\r\nflush_workqueue(tape_3590_wq);\r\ntape_std_unassign(device);\r\nkfree(device->discdata);\r\ndevice->discdata = NULL;\r\n}\r\nstatic int\r\ntape_3590_online(struct ccw_device *cdev)\r\n{\r\nreturn tape_generic_online(dev_get_drvdata(&cdev->dev),\r\n&tape_discipline_3590);\r\n}\r\nstatic int\r\ntape_3590_init(void)\r\n{\r\nint rc;\r\nTAPE_DBF_AREA = debug_register("tape_3590", 2, 2, 4 * sizeof(long));\r\ndebug_register_view(TAPE_DBF_AREA, &debug_sprintf_view);\r\n#ifdef DBF_LIKE_HELL\r\ndebug_set_level(TAPE_DBF_AREA, 6);\r\n#endif\r\nDBF_EVENT(3, "3590 init\n");\r\ntape_3590_wq = alloc_workqueue("tape_3590", 0, 0);\r\nif (!tape_3590_wq)\r\nreturn -ENOMEM;\r\nrc = ccw_driver_register(&tape_3590_driver);\r\nif (rc) {\r\ndestroy_workqueue(tape_3590_wq);\r\nDBF_EVENT(3, "3590 init failed\n");\r\n} else\r\nDBF_EVENT(3, "3590 registered\n");\r\nreturn rc;\r\n}\r\nstatic void\r\ntape_3590_exit(void)\r\n{\r\nccw_driver_unregister(&tape_3590_driver);\r\ndestroy_workqueue(tape_3590_wq);\r\ndebug_unregister(TAPE_DBF_AREA);\r\n}
