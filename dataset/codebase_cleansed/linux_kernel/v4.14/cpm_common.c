static int __init cpm_init(void)\r\n{\r\nstruct device_node *np;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,cpm1");\r\nif (!np)\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,cpm2");\r\nif (!np)\r\nreturn -ENODEV;\r\ncpm_muram_init();\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nstatic void udbg_putc_cpm(char c)\r\n{\r\nif (c == '\n')\r\nudbg_putc_cpm('\r');\r\nwhile (in_be32(&cpm_udbg_txdesc[0]) & 0x80000000)\r\n;\r\nout_8(cpm_udbg_txbuf, c);\r\nout_be32(&cpm_udbg_txdesc[0], 0xa0000001);\r\n}\r\nvoid __init udbg_init_cpm(void)\r\n{\r\n#ifdef CONFIG_PPC_8xx\r\ncpm_udbg_txdesc = (u32 __iomem __force *)\r\n(CONFIG_PPC_EARLY_DEBUG_CPM_ADDR - PHYS_IMMR_BASE +\r\nVIRT_IMMR_BASE);\r\ncpm_udbg_txbuf = (u8 __iomem __force *)\r\n(in_be32(&cpm_udbg_txdesc[1]) - PHYS_IMMR_BASE +\r\nVIRT_IMMR_BASE);\r\n#else\r\ncpm_udbg_txdesc = (u32 __iomem __force *)\r\nCONFIG_PPC_EARLY_DEBUG_CPM_ADDR;\r\ncpm_udbg_txbuf = (u8 __iomem __force *)in_be32(&cpm_udbg_txdesc[1]);\r\n#endif\r\nif (cpm_udbg_txdesc) {\r\n#ifdef CONFIG_CPM2\r\nsetbat(1, 0xf0000000, 0xf0000000, 1024*1024, PAGE_KERNEL_NCG);\r\n#endif\r\nudbg_putc = udbg_putc_cpm;\r\n}\r\n}\r\nstatic void cpm2_gpio32_save_regs(struct of_mm_gpio_chip *mm_gc)\r\n{\r\nstruct cpm2_gpio32_chip *cpm2_gc =\r\ncontainer_of(mm_gc, struct cpm2_gpio32_chip, mm_gc);\r\nstruct cpm2_ioports __iomem *iop = mm_gc->regs;\r\ncpm2_gc->cpdata = in_be32(&iop->dat);\r\n}\r\nstatic int cpm2_gpio32_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm2_ioports __iomem *iop = mm_gc->regs;\r\nu32 pin_mask;\r\npin_mask = 1 << (31 - gpio);\r\nreturn !!(in_be32(&iop->dat) & pin_mask);\r\n}\r\nstatic void __cpm2_gpio32_set(struct of_mm_gpio_chip *mm_gc, u32 pin_mask,\r\nint value)\r\n{\r\nstruct cpm2_gpio32_chip *cpm2_gc = gpiochip_get_data(&mm_gc->gc);\r\nstruct cpm2_ioports __iomem *iop = mm_gc->regs;\r\nif (value)\r\ncpm2_gc->cpdata |= pin_mask;\r\nelse\r\ncpm2_gc->cpdata &= ~pin_mask;\r\nout_be32(&iop->dat, cpm2_gc->cpdata);\r\n}\r\nstatic void cpm2_gpio32_set(struct gpio_chip *gc, unsigned int gpio, int value)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm2_gpio32_chip *cpm2_gc = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nu32 pin_mask = 1 << (31 - gpio);\r\nspin_lock_irqsave(&cpm2_gc->lock, flags);\r\n__cpm2_gpio32_set(mm_gc, pin_mask, value);\r\nspin_unlock_irqrestore(&cpm2_gc->lock, flags);\r\n}\r\nstatic int cpm2_gpio32_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm2_gpio32_chip *cpm2_gc = gpiochip_get_data(gc);\r\nstruct cpm2_ioports __iomem *iop = mm_gc->regs;\r\nunsigned long flags;\r\nu32 pin_mask = 1 << (31 - gpio);\r\nspin_lock_irqsave(&cpm2_gc->lock, flags);\r\nsetbits32(&iop->dir, pin_mask);\r\n__cpm2_gpio32_set(mm_gc, pin_mask, val);\r\nspin_unlock_irqrestore(&cpm2_gc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cpm2_gpio32_dir_in(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm2_gpio32_chip *cpm2_gc = gpiochip_get_data(gc);\r\nstruct cpm2_ioports __iomem *iop = mm_gc->regs;\r\nunsigned long flags;\r\nu32 pin_mask = 1 << (31 - gpio);\r\nspin_lock_irqsave(&cpm2_gc->lock, flags);\r\nclrbits32(&iop->dir, pin_mask);\r\nspin_unlock_irqrestore(&cpm2_gc->lock, flags);\r\nreturn 0;\r\n}\r\nint cpm2_gpiochip_add32(struct device_node *np)\r\n{\r\nstruct cpm2_gpio32_chip *cpm2_gc;\r\nstruct of_mm_gpio_chip *mm_gc;\r\nstruct gpio_chip *gc;\r\ncpm2_gc = kzalloc(sizeof(*cpm2_gc), GFP_KERNEL);\r\nif (!cpm2_gc)\r\nreturn -ENOMEM;\r\nspin_lock_init(&cpm2_gc->lock);\r\nmm_gc = &cpm2_gc->mm_gc;\r\ngc = &mm_gc->gc;\r\nmm_gc->save_regs = cpm2_gpio32_save_regs;\r\ngc->ngpio = 32;\r\ngc->direction_input = cpm2_gpio32_dir_in;\r\ngc->direction_output = cpm2_gpio32_dir_out;\r\ngc->get = cpm2_gpio32_get;\r\ngc->set = cpm2_gpio32_set;\r\nreturn of_mm_gpiochip_add_data(np, mm_gc, cpm2_gc);\r\n}
