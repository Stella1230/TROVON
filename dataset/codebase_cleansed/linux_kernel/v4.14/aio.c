static long io_setup(int n, aio_context_t *ctxp)\r\n{\r\nreturn syscall(__NR_io_setup, n, ctxp);\r\n}\r\nstatic long io_submit(aio_context_t ctx, long nr, struct iocb **iocbpp)\r\n{\r\nreturn syscall(__NR_io_submit, ctx, nr, iocbpp);\r\n}\r\nstatic long io_getevents(aio_context_t ctx_id, long min_nr, long nr,\r\nstruct io_event *events, struct timespec *timeout)\r\n{\r\nreturn syscall(__NR_io_getevents, ctx_id, min_nr, nr, events, timeout);\r\n}\r\nstatic int do_aio(aio_context_t ctx, enum aio_type type, int fd, char *buf,\r\nint len, unsigned long long offset, struct aio_context *aio)\r\n{\r\nstruct iocb *iocbp = & ((struct iocb) {\r\n.aio_data = (unsigned long) aio,\r\n.aio_fildes = fd,\r\n.aio_buf = (unsigned long) buf,\r\n.aio_nbytes = len,\r\n.aio_offset = offset\r\n});\r\nchar c;\r\nswitch (type) {\r\ncase AIO_READ:\r\niocbp->aio_lio_opcode = IOCB_CMD_PREAD;\r\nbreak;\r\ncase AIO_WRITE:\r\niocbp->aio_lio_opcode = IOCB_CMD_PWRITE;\r\nbreak;\r\ncase AIO_MMAP:\r\niocbp->aio_lio_opcode = IOCB_CMD_PREAD;\r\niocbp->aio_buf = (unsigned long) &c;\r\niocbp->aio_nbytes = sizeof(c);\r\nbreak;\r\ndefault:\r\nprintk(UM_KERN_ERR "Bogus op in do_aio - %d\n", type);\r\nreturn -EINVAL;\r\n}\r\nreturn (io_submit(ctx, 1, &iocbp) > 0) ? 0 : -errno;\r\n}\r\nstatic int aio_thread(void *arg)\r\n{\r\nstruct aio_thread_reply reply;\r\nstruct io_event event;\r\nint err, n, reply_fd;\r\nos_fix_helper_signals();\r\nwhile (1) {\r\nn = io_getevents(ctx, 1, 1, &event, NULL);\r\nif (n < 0) {\r\nif (errno == EINTR)\r\ncontinue;\r\nprintk(UM_KERN_ERR "aio_thread - io_getevents failed, "\r\n"errno = %d\n", errno);\r\n}\r\nelse {\r\nreply = ((struct aio_thread_reply)\r\n{ .data = (void *) (long) event.data,\r\n.err = event.res });\r\nreply_fd = ((struct aio_context *) reply.data)->reply_fd;\r\nerr = write(reply_fd, &reply, sizeof(reply));\r\nif (err != sizeof(reply))\r\nprintk(UM_KERN_ERR "aio_thread - write failed, "\r\n"fd = %d, err = %d\n", reply_fd, errno);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_not_aio(struct aio_thread_req *req)\r\n{\r\nchar c;\r\nunsigned long long actual;\r\nint n;\r\nactual = lseek64(req->io_fd, req->offset, SEEK_SET);\r\nif (actual != req->offset)\r\nreturn -errno;\r\nswitch (req->type) {\r\ncase AIO_READ:\r\nn = read(req->io_fd, req->buf, req->len);\r\nbreak;\r\ncase AIO_WRITE:\r\nn = write(req->io_fd, req->buf, req->len);\r\nbreak;\r\ncase AIO_MMAP:\r\nn = read(req->io_fd, &c, sizeof(c));\r\nbreak;\r\ndefault:\r\nprintk(UM_KERN_ERR "do_not_aio - bad request type : %d\n",\r\nreq->type);\r\nreturn -EINVAL;\r\n}\r\nif (n < 0)\r\nreturn -errno;\r\nreturn 0;\r\n}\r\nstatic int not_aio_thread(void *arg)\r\n{\r\nstruct aio_thread_req req;\r\nstruct aio_thread_reply reply;\r\nint err;\r\nos_fix_helper_signals();\r\nwhile (1) {\r\nerr = read(aio_req_fd_r, &req, sizeof(req));\r\nif (err != sizeof(req)) {\r\nif (err < 0)\r\nprintk(UM_KERN_ERR "not_aio_thread - "\r\n"read failed, fd = %d, err = %d\n",\r\naio_req_fd_r,\r\nerrno);\r\nelse {\r\nprintk(UM_KERN_ERR "not_aio_thread - short "\r\n"read, fd = %d, length = %d\n",\r\naio_req_fd_r, err);\r\n}\r\ncontinue;\r\n}\r\nerr = do_not_aio(&req);\r\nreply = ((struct aio_thread_reply) { .data = req.aio,\r\n.err = err });\r\nerr = write(req.aio->reply_fd, &reply, sizeof(reply));\r\nif (err != sizeof(reply))\r\nprintk(UM_KERN_ERR "not_aio_thread - write failed, "\r\n"fd = %d, err = %d\n", req.aio->reply_fd, errno);\r\n}\r\nreturn 0;\r\n}\r\nstatic int init_aio_24(void)\r\n{\r\nint fds[2], err;\r\nerr = os_pipe(fds, 1, 1);\r\nif (err)\r\ngoto out;\r\naio_req_fd_w = fds[0];\r\naio_req_fd_r = fds[1];\r\nerr = os_set_fd_block(aio_req_fd_w, 0);\r\nif (err)\r\ngoto out_close_pipe;\r\nerr = run_helper_thread(not_aio_thread, NULL,\r\nCLONE_FILES | CLONE_VM, &aio_stack);\r\nif (err < 0)\r\ngoto out_close_pipe;\r\naio_pid = err;\r\ngoto out;\r\nout_close_pipe:\r\nclose(fds[0]);\r\nclose(fds[1]);\r\naio_req_fd_w = -1;\r\naio_req_fd_r = -1;\r\nout:\r\n#ifndef HAVE_AIO_ABI\r\nprintk(UM_KERN_INFO "/usr/include/linux/aio_abi.h not present during "\r\n"build\n");\r\n#endif\r\nprintk(UM_KERN_INFO "2.6 host AIO support not used - falling back to "\r\n"I/O thread\n");\r\nreturn 0;\r\n}\r\nstatic int init_aio_26(void)\r\n{\r\nint err;\r\nif (io_setup(256, &ctx)) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "aio_thread failed to initialize context, "\r\n"err = %d\n", errno);\r\nreturn err;\r\n}\r\nerr = run_helper_thread(aio_thread, NULL,\r\nCLONE_FILES | CLONE_VM, &aio_stack);\r\nif (err < 0)\r\nreturn err;\r\naio_pid = err;\r\nprintk(UM_KERN_INFO "Using 2.6 host AIO\n");\r\nreturn 0;\r\n}\r\nstatic int submit_aio_26(enum aio_type type, int io_fd, char *buf, int len,\r\nunsigned long long offset, struct aio_context *aio)\r\n{\r\nstruct aio_thread_reply reply;\r\nint err;\r\nerr = do_aio(ctx, type, io_fd, buf, len, offset, aio);\r\nif (err) {\r\nreply = ((struct aio_thread_reply) { .data = aio,\r\n.err = err });\r\nerr = write(aio->reply_fd, &reply, sizeof(reply));\r\nif (err != sizeof(reply)) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "submit_aio_26 - write failed, "\r\n"fd = %d, err = %d\n", aio->reply_fd, -err);\r\n}\r\nelse err = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int init_aio_26(void)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int submit_aio_26(enum aio_type type, int io_fd, char *buf, int len,\r\nunsigned long long offset, struct aio_context *aio)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int __init set_aio_24(char *name, int *add)\r\n{\r\naio_24 = 1;\r\nreturn 0;\r\n}\r\nstatic int init_aio(void)\r\n{\r\nint err;\r\nif (!aio_24) {\r\nerr = init_aio_26();\r\nif (err && (errno == ENOSYS)) {\r\nprintk(UM_KERN_INFO "2.6 AIO not supported on the "\r\n"host - reverting to 2.4 AIO\n");\r\naio_24 = 1;\r\n}\r\nelse return err;\r\n}\r\nif (aio_24)\r\nreturn init_aio_24();\r\nreturn 0;\r\n}\r\nstatic void exit_aio(void)\r\n{\r\nif (aio_pid != -1) {\r\nos_kill_process(aio_pid, 1);\r\nfree_stack(aio_stack, 0);\r\n}\r\n}\r\nstatic int submit_aio_24(enum aio_type type, int io_fd, char *buf, int len,\r\nunsigned long long offset, struct aio_context *aio)\r\n{\r\nstruct aio_thread_req req = { .type = type,\r\n.io_fd = io_fd,\r\n.offset = offset,\r\n.buf = buf,\r\n.len = len,\r\n.aio = aio,\r\n};\r\nint err;\r\nerr = write(aio_req_fd_w, &req, sizeof(req));\r\nif (err == sizeof(req))\r\nerr = 0;\r\nelse err = -errno;\r\nreturn err;\r\n}\r\nint submit_aio(enum aio_type type, int io_fd, char *buf, int len,\r\nunsigned long long offset, int reply_fd,\r\nstruct aio_context *aio)\r\n{\r\naio->reply_fd = reply_fd;\r\nif (aio_24)\r\nreturn submit_aio_24(type, io_fd, buf, len, offset, aio);\r\nelse\r\nreturn submit_aio_26(type, io_fd, buf, len, offset, aio);\r\n}
