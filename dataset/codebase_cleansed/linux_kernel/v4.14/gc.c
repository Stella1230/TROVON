static int switch_gc_head(struct ubifs_info *c)\r\n{\r\nint err, gc_lnum = c->gc_lnum;\r\nstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\r\nubifs_assert(gc_lnum != -1);\r\ndbg_gc("switch GC head from LEB %d:%d to LEB %d (waste %d bytes)",\r\nwbuf->lnum, wbuf->offs + wbuf->used, gc_lnum,\r\nc->leb_size - wbuf->offs - wbuf->used);\r\nerr = ubifs_wbuf_sync_nolock(wbuf);\r\nif (err)\r\nreturn err;\r\nerr = ubifs_leb_unmap(c, gc_lnum);\r\nif (err)\r\nreturn err;\r\nerr = ubifs_add_bud_to_log(c, GCHD, gc_lnum, 0);\r\nif (err)\r\nreturn err;\r\nc->gc_lnum = -1;\r\nerr = ubifs_wbuf_seek_nolock(wbuf, gc_lnum, 0);\r\nreturn err;\r\n}\r\nstatic int data_nodes_cmp(void *priv, struct list_head *a, struct list_head *b)\r\n{\r\nino_t inuma, inumb;\r\nstruct ubifs_info *c = priv;\r\nstruct ubifs_scan_node *sa, *sb;\r\ncond_resched();\r\nif (a == b)\r\nreturn 0;\r\nsa = list_entry(a, struct ubifs_scan_node, list);\r\nsb = list_entry(b, struct ubifs_scan_node, list);\r\nubifs_assert(key_type(c, &sa->key) == UBIFS_DATA_KEY);\r\nubifs_assert(key_type(c, &sb->key) == UBIFS_DATA_KEY);\r\nubifs_assert(sa->type == UBIFS_DATA_NODE);\r\nubifs_assert(sb->type == UBIFS_DATA_NODE);\r\ninuma = key_inum(c, &sa->key);\r\ninumb = key_inum(c, &sb->key);\r\nif (inuma == inumb) {\r\nunsigned int blka = key_block(c, &sa->key);\r\nunsigned int blkb = key_block(c, &sb->key);\r\nif (blka <= blkb)\r\nreturn -1;\r\n} else if (inuma <= inumb)\r\nreturn -1;\r\nreturn 1;\r\n}\r\nstatic int nondata_nodes_cmp(void *priv, struct list_head *a,\r\nstruct list_head *b)\r\n{\r\nino_t inuma, inumb;\r\nstruct ubifs_info *c = priv;\r\nstruct ubifs_scan_node *sa, *sb;\r\ncond_resched();\r\nif (a == b)\r\nreturn 0;\r\nsa = list_entry(a, struct ubifs_scan_node, list);\r\nsb = list_entry(b, struct ubifs_scan_node, list);\r\nubifs_assert(key_type(c, &sa->key) != UBIFS_DATA_KEY &&\r\nkey_type(c, &sb->key) != UBIFS_DATA_KEY);\r\nubifs_assert(sa->type != UBIFS_DATA_NODE &&\r\nsb->type != UBIFS_DATA_NODE);\r\nif (sa->type == UBIFS_INO_NODE) {\r\nif (sb->type == UBIFS_INO_NODE)\r\nreturn sb->len - sa->len;\r\nreturn -1;\r\n}\r\nif (sb->type == UBIFS_INO_NODE)\r\nreturn 1;\r\nubifs_assert(key_type(c, &sa->key) == UBIFS_DENT_KEY ||\r\nkey_type(c, &sa->key) == UBIFS_XENT_KEY);\r\nubifs_assert(key_type(c, &sb->key) == UBIFS_DENT_KEY ||\r\nkey_type(c, &sb->key) == UBIFS_XENT_KEY);\r\nubifs_assert(sa->type == UBIFS_DENT_NODE ||\r\nsa->type == UBIFS_XENT_NODE);\r\nubifs_assert(sb->type == UBIFS_DENT_NODE ||\r\nsb->type == UBIFS_XENT_NODE);\r\ninuma = key_inum(c, &sa->key);\r\ninumb = key_inum(c, &sb->key);\r\nif (inuma == inumb) {\r\nuint32_t hasha = key_hash(c, &sa->key);\r\nuint32_t hashb = key_hash(c, &sb->key);\r\nif (hasha <= hashb)\r\nreturn -1;\r\n} else if (inuma <= inumb)\r\nreturn -1;\r\nreturn 1;\r\n}\r\nstatic int sort_nodes(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\r\nstruct list_head *nondata, int *min)\r\n{\r\nint err;\r\nstruct ubifs_scan_node *snod, *tmp;\r\n*min = INT_MAX;\r\nlist_for_each_entry_safe(snod, tmp, &sleb->nodes, list) {\r\nubifs_assert(snod->type == UBIFS_INO_NODE ||\r\nsnod->type == UBIFS_DATA_NODE ||\r\nsnod->type == UBIFS_DENT_NODE ||\r\nsnod->type == UBIFS_XENT_NODE ||\r\nsnod->type == UBIFS_TRUN_NODE);\r\nif (snod->type != UBIFS_INO_NODE &&\r\nsnod->type != UBIFS_DATA_NODE &&\r\nsnod->type != UBIFS_DENT_NODE &&\r\nsnod->type != UBIFS_XENT_NODE) {\r\nlist_del(&snod->list);\r\nkfree(snod);\r\ncontinue;\r\n}\r\nubifs_assert(key_type(c, &snod->key) == UBIFS_DATA_KEY ||\r\nkey_type(c, &snod->key) == UBIFS_INO_KEY ||\r\nkey_type(c, &snod->key) == UBIFS_DENT_KEY ||\r\nkey_type(c, &snod->key) == UBIFS_XENT_KEY);\r\nerr = ubifs_tnc_has_node(c, &snod->key, 0, sleb->lnum,\r\nsnod->offs, 0);\r\nif (err < 0)\r\nreturn err;\r\nif (!err) {\r\nlist_del(&snod->list);\r\nkfree(snod);\r\ncontinue;\r\n}\r\nif (snod->len < *min)\r\n*min = snod->len;\r\nif (key_type(c, &snod->key) != UBIFS_DATA_KEY)\r\nlist_move_tail(&snod->list, nondata);\r\n}\r\nlist_sort(c, &sleb->nodes, &data_nodes_cmp);\r\nlist_sort(c, nondata, &nondata_nodes_cmp);\r\nerr = dbg_check_data_nodes_order(c, &sleb->nodes);\r\nif (err)\r\nreturn err;\r\nerr = dbg_check_nondata_nodes_order(c, nondata);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int move_node(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\r\nstruct ubifs_scan_node *snod, struct ubifs_wbuf *wbuf)\r\n{\r\nint err, new_lnum = wbuf->lnum, new_offs = wbuf->offs + wbuf->used;\r\ncond_resched();\r\nerr = ubifs_wbuf_write_nolock(wbuf, snod->node, snod->len);\r\nif (err)\r\nreturn err;\r\nerr = ubifs_tnc_replace(c, &snod->key, sleb->lnum,\r\nsnod->offs, new_lnum, new_offs,\r\nsnod->len);\r\nlist_del(&snod->list);\r\nkfree(snod);\r\nreturn err;\r\n}\r\nstatic int move_nodes(struct ubifs_info *c, struct ubifs_scan_leb *sleb)\r\n{\r\nint err, min;\r\nLIST_HEAD(nondata);\r\nstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\r\nif (wbuf->lnum == -1) {\r\nerr = switch_gc_head(c);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = sort_nodes(c, sleb, &nondata, &min);\r\nif (err)\r\ngoto out;\r\nwhile (1) {\r\nint avail;\r\nstruct ubifs_scan_node *snod, *tmp;\r\nlist_for_each_entry_safe(snod, tmp, &sleb->nodes, list) {\r\navail = c->leb_size - wbuf->offs - wbuf->used;\r\nif (snod->len > avail)\r\nbreak;\r\nerr = move_node(c, sleb, snod, wbuf);\r\nif (err)\r\ngoto out;\r\n}\r\nlist_for_each_entry_safe(snod, tmp, &nondata, list) {\r\navail = c->leb_size - wbuf->offs - wbuf->used;\r\nif (avail < min)\r\nbreak;\r\nif (snod->len > avail) {\r\nif (key_type(c, &snod->key) == UBIFS_DENT_KEY ||\r\nsnod->len == UBIFS_INO_NODE_SZ)\r\nbreak;\r\ncontinue;\r\n}\r\nerr = move_node(c, sleb, snod, wbuf);\r\nif (err)\r\ngoto out;\r\n}\r\nif (list_empty(&sleb->nodes) && list_empty(&nondata))\r\nbreak;\r\nerr = switch_gc_head(c);\r\nif (err)\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nlist_splice_tail(&nondata, &sleb->nodes);\r\nreturn err;\r\n}\r\nstatic int gc_sync_wbufs(struct ubifs_info *c)\r\n{\r\nint err, i;\r\nfor (i = 0; i < c->jhead_cnt; i++) {\r\nif (i == GCHD)\r\ncontinue;\r\nerr = ubifs_wbuf_sync(&c->jheads[i].wbuf);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint ubifs_garbage_collect_leb(struct ubifs_info *c, struct ubifs_lprops *lp)\r\n{\r\nstruct ubifs_scan_leb *sleb;\r\nstruct ubifs_scan_node *snod;\r\nstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\r\nint err = 0, lnum = lp->lnum;\r\nubifs_assert(c->gc_lnum != -1 || wbuf->offs + wbuf->used == 0 ||\r\nc->need_recovery);\r\nubifs_assert(c->gc_lnum != lnum);\r\nubifs_assert(wbuf->lnum != lnum);\r\nif (lp->free + lp->dirty == c->leb_size) {\r\ndbg_gc("LEB %d is free, return it", lp->lnum);\r\nubifs_assert(!(lp->flags & LPROPS_INDEX));\r\nif (lp->free != c->leb_size) {\r\nerr = gc_sync_wbufs(c);\r\nif (err)\r\nreturn err;\r\nerr = ubifs_change_one_lp(c, lp->lnum, c->leb_size,\r\n0, 0, 0, 0);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = ubifs_leb_unmap(c, lp->lnum);\r\nif (err)\r\nreturn err;\r\nif (c->gc_lnum == -1) {\r\nc->gc_lnum = lnum;\r\nreturn LEB_RETAINED;\r\n}\r\nreturn LEB_FREED;\r\n}\r\nsleb = ubifs_scan(c, lnum, 0, c->sbuf, 0);\r\nif (IS_ERR(sleb))\r\nreturn PTR_ERR(sleb);\r\nubifs_assert(!list_empty(&sleb->nodes));\r\nsnod = list_entry(sleb->nodes.next, struct ubifs_scan_node, list);\r\nif (snod->type == UBIFS_IDX_NODE) {\r\nstruct ubifs_gced_idx_leb *idx_gc;\r\ndbg_gc("indexing LEB %d (free %d, dirty %d)",\r\nlnum, lp->free, lp->dirty);\r\nlist_for_each_entry(snod, &sleb->nodes, list) {\r\nstruct ubifs_idx_node *idx = snod->node;\r\nint level = le16_to_cpu(idx->level);\r\nubifs_assert(snod->type == UBIFS_IDX_NODE);\r\nkey_read(c, ubifs_idx_key(c, idx), &snod->key);\r\nerr = ubifs_dirty_idx_node(c, &snod->key, level, lnum,\r\nsnod->offs);\r\nif (err)\r\ngoto out;\r\n}\r\nidx_gc = kmalloc(sizeof(struct ubifs_gced_idx_leb), GFP_NOFS);\r\nif (!idx_gc) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nidx_gc->lnum = lnum;\r\nidx_gc->unmap = 0;\r\nlist_add(&idx_gc->list, &c->idx_gc);\r\nerr = ubifs_change_one_lp(c, lnum, c->leb_size, 0, 0,\r\nLPROPS_INDEX, 1);\r\nif (err)\r\ngoto out;\r\nerr = LEB_FREED_IDX;\r\n} else {\r\ndbg_gc("data LEB %d (free %d, dirty %d)",\r\nlnum, lp->free, lp->dirty);\r\nerr = move_nodes(c, sleb);\r\nif (err)\r\ngoto out_inc_seq;\r\nerr = gc_sync_wbufs(c);\r\nif (err)\r\ngoto out_inc_seq;\r\nerr = ubifs_change_one_lp(c, lnum, c->leb_size, 0, 0, 0, 0);\r\nif (err)\r\ngoto out_inc_seq;\r\nc->gced_lnum = lnum;\r\nsmp_wmb();\r\nc->gc_seq += 1;\r\nsmp_wmb();\r\nif (c->gc_lnum == -1) {\r\nc->gc_lnum = lnum;\r\nerr = LEB_RETAINED;\r\n} else {\r\nerr = ubifs_wbuf_sync_nolock(wbuf);\r\nif (err)\r\ngoto out;\r\nerr = ubifs_leb_unmap(c, lnum);\r\nif (err)\r\ngoto out;\r\nerr = LEB_FREED;\r\n}\r\n}\r\nout:\r\nubifs_scan_destroy(sleb);\r\nreturn err;\r\nout_inc_seq:\r\nc->gced_lnum = lnum;\r\nsmp_wmb();\r\nc->gc_seq += 1;\r\nsmp_wmb();\r\ngoto out;\r\n}\r\nint ubifs_garbage_collect(struct ubifs_info *c, int anyway)\r\n{\r\nint i, err, ret, min_space = c->dead_wm;\r\nstruct ubifs_lprops lp;\r\nstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\r\nubifs_assert_cmt_locked(c);\r\nubifs_assert(!c->ro_media && !c->ro_mount);\r\nif (ubifs_gc_should_commit(c))\r\nreturn -EAGAIN;\r\nmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\r\nif (c->ro_error) {\r\nret = -EROFS;\r\ngoto out_unlock;\r\n}\r\nubifs_assert(!wbuf->used);\r\nfor (i = 0; ; i++) {\r\nint space_before, space_after;\r\ncond_resched();\r\nif (ubifs_gc_should_commit(c)) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nif (i > SOFT_LEBS_LIMIT && !list_empty(&c->idx_gc)) {\r\ndbg_gc("soft limit, some index LEBs GC'ed, -EAGAIN");\r\nubifs_commit_required(c);\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nif (i > HARD_LEBS_LIMIT) {\r\ndbg_gc("hard limit, -ENOSPC");\r\nret = -ENOSPC;\r\nbreak;\r\n}\r\nret = ubifs_find_dirty_leb(c, &lp, min_space, anyway ? 0 : 1);\r\nif (ret) {\r\nif (ret == -ENOSPC)\r\ndbg_gc("no more dirty LEBs");\r\nbreak;\r\n}\r\ndbg_gc("found LEB %d: free %d, dirty %d, sum %d (min. space %d)",\r\nlp.lnum, lp.free, lp.dirty, lp.free + lp.dirty,\r\nmin_space);\r\nspace_before = c->leb_size - wbuf->offs - wbuf->used;\r\nif (wbuf->lnum == -1)\r\nspace_before = 0;\r\nret = ubifs_garbage_collect_leb(c, &lp);\r\nif (ret < 0) {\r\nif (ret == -EAGAIN) {\r\nerr = ubifs_return_leb(c, lp.lnum);\r\nif (err)\r\nret = err;\r\nbreak;\r\n}\r\ngoto out;\r\n}\r\nif (ret == LEB_FREED) {\r\ndbg_gc("LEB %d freed, return", lp.lnum);\r\nret = lp.lnum;\r\nbreak;\r\n}\r\nif (ret == LEB_FREED_IDX) {\r\ndbg_gc("indexing LEB %d freed, continue", lp.lnum);\r\ncontinue;\r\n}\r\nubifs_assert(ret == LEB_RETAINED);\r\nspace_after = c->leb_size - wbuf->offs - wbuf->used;\r\ndbg_gc("LEB %d retained, freed %d bytes", lp.lnum,\r\nspace_after - space_before);\r\nif (space_after > space_before) {\r\nmin_space >>= 1;\r\nif (min_space < c->dead_wm)\r\nmin_space = c->dead_wm;\r\ncontinue;\r\n}\r\ndbg_gc("did not make progress");\r\nif (i < SOFT_LEBS_LIMIT) {\r\ndbg_gc("try again");\r\ncontinue;\r\n}\r\nmin_space <<= 1;\r\nif (min_space > c->dark_wm)\r\nmin_space = c->dark_wm;\r\ndbg_gc("set min. space to %d", min_space);\r\n}\r\nif (ret == -ENOSPC && !list_empty(&c->idx_gc)) {\r\ndbg_gc("no space, some index LEBs GC'ed, -EAGAIN");\r\nubifs_commit_required(c);\r\nret = -EAGAIN;\r\n}\r\nerr = ubifs_wbuf_sync_nolock(wbuf);\r\nif (!err)\r\nerr = ubifs_leb_unmap(c, c->gc_lnum);\r\nif (err) {\r\nret = err;\r\ngoto out;\r\n}\r\nout_unlock:\r\nmutex_unlock(&wbuf->io_mutex);\r\nreturn ret;\r\nout:\r\nubifs_assert(ret < 0);\r\nubifs_assert(ret != -ENOSPC && ret != -EAGAIN);\r\nubifs_wbuf_sync_nolock(wbuf);\r\nubifs_ro_mode(c, ret);\r\nmutex_unlock(&wbuf->io_mutex);\r\nubifs_return_leb(c, lp.lnum);\r\nreturn ret;\r\n}\r\nint ubifs_gc_start_commit(struct ubifs_info *c)\r\n{\r\nstruct ubifs_gced_idx_leb *idx_gc;\r\nconst struct ubifs_lprops *lp;\r\nint err = 0, flags;\r\nubifs_get_lprops(c);\r\nwhile (1) {\r\nlp = ubifs_fast_find_freeable(c);\r\nif (!lp)\r\nbreak;\r\nubifs_assert(!(lp->flags & LPROPS_TAKEN));\r\nubifs_assert(!(lp->flags & LPROPS_INDEX));\r\nerr = ubifs_leb_unmap(c, lp->lnum);\r\nif (err)\r\ngoto out;\r\nlp = ubifs_change_lp(c, lp, c->leb_size, 0, lp->flags, 0);\r\nif (IS_ERR(lp)) {\r\nerr = PTR_ERR(lp);\r\ngoto out;\r\n}\r\nubifs_assert(!(lp->flags & LPROPS_TAKEN));\r\nubifs_assert(!(lp->flags & LPROPS_INDEX));\r\n}\r\nlist_for_each_entry(idx_gc, &c->idx_gc, list)\r\nidx_gc->unmap = 1;\r\nwhile (1) {\r\nlp = ubifs_fast_find_frdi_idx(c);\r\nif (IS_ERR(lp)) {\r\nerr = PTR_ERR(lp);\r\ngoto out;\r\n}\r\nif (!lp)\r\nbreak;\r\nidx_gc = kmalloc(sizeof(struct ubifs_gced_idx_leb), GFP_NOFS);\r\nif (!idx_gc) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nubifs_assert(!(lp->flags & LPROPS_TAKEN));\r\nubifs_assert(lp->flags & LPROPS_INDEX);\r\nflags = (lp->flags | LPROPS_TAKEN) ^ LPROPS_INDEX;\r\nlp = ubifs_change_lp(c, lp, c->leb_size, 0, flags, 1);\r\nif (IS_ERR(lp)) {\r\nerr = PTR_ERR(lp);\r\nkfree(idx_gc);\r\ngoto out;\r\n}\r\nubifs_assert(lp->flags & LPROPS_TAKEN);\r\nubifs_assert(!(lp->flags & LPROPS_INDEX));\r\nidx_gc->lnum = lp->lnum;\r\nidx_gc->unmap = 1;\r\nlist_add(&idx_gc->list, &c->idx_gc);\r\n}\r\nout:\r\nubifs_release_lprops(c);\r\nreturn err;\r\n}\r\nint ubifs_gc_end_commit(struct ubifs_info *c)\r\n{\r\nstruct ubifs_gced_idx_leb *idx_gc, *tmp;\r\nstruct ubifs_wbuf *wbuf;\r\nint err = 0;\r\nwbuf = &c->jheads[GCHD].wbuf;\r\nmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\r\nlist_for_each_entry_safe(idx_gc, tmp, &c->idx_gc, list)\r\nif (idx_gc->unmap) {\r\ndbg_gc("LEB %d", idx_gc->lnum);\r\nerr = ubifs_leb_unmap(c, idx_gc->lnum);\r\nif (err)\r\ngoto out;\r\nerr = ubifs_change_one_lp(c, idx_gc->lnum, LPROPS_NC,\r\nLPROPS_NC, 0, LPROPS_TAKEN, -1);\r\nif (err)\r\ngoto out;\r\nlist_del(&idx_gc->list);\r\nkfree(idx_gc);\r\n}\r\nout:\r\nmutex_unlock(&wbuf->io_mutex);\r\nreturn err;\r\n}\r\nvoid ubifs_destroy_idx_gc(struct ubifs_info *c)\r\n{\r\nwhile (!list_empty(&c->idx_gc)) {\r\nstruct ubifs_gced_idx_leb *idx_gc;\r\nidx_gc = list_entry(c->idx_gc.next, struct ubifs_gced_idx_leb,\r\nlist);\r\nc->idx_gc_cnt -= 1;\r\nlist_del(&idx_gc->list);\r\nkfree(idx_gc);\r\n}\r\n}\r\nint ubifs_get_idx_gc_leb(struct ubifs_info *c)\r\n{\r\nstruct ubifs_gced_idx_leb *idx_gc;\r\nint lnum;\r\nif (list_empty(&c->idx_gc))\r\nreturn -ENOSPC;\r\nidx_gc = list_entry(c->idx_gc.next, struct ubifs_gced_idx_leb, list);\r\nlnum = idx_gc->lnum;\r\nlist_del(&idx_gc->list);\r\nkfree(idx_gc);\r\nreturn lnum;\r\n}
