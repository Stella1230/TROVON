acpi_status acpi_ev_gpe_initialize(void)\r\n{\r\nu32 register_count0 = 0;\r\nu32 register_count1 = 0;\r\nu32 gpe_number_max = 0;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ev_gpe_initialize);\r\nACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,\r\n"Initializing General Purpose Events (GPEs):\n"));\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (acpi_gbl_FADT.gpe0_block_length &&\r\nacpi_gbl_FADT.xgpe0_block.address) {\r\nregister_count0 = (u16)(acpi_gbl_FADT.gpe0_block_length / 2);\r\ngpe_number_max =\r\n(register_count0 * ACPI_GPE_REGISTER_WIDTH) - 1;\r\nstatus = acpi_ev_create_gpe_block(acpi_gbl_fadt_gpe_device,\r\nacpi_gbl_FADT.xgpe0_block.\r\naddress,\r\nacpi_gbl_FADT.xgpe0_block.\r\nspace_id, register_count0, 0,\r\nacpi_gbl_FADT.sci_interrupt,\r\n&acpi_gbl_gpe_fadt_blocks[0]);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Could not create GPE Block 0"));\r\n}\r\n}\r\nif (acpi_gbl_FADT.gpe1_block_length &&\r\nacpi_gbl_FADT.xgpe1_block.address) {\r\nregister_count1 = (u16)(acpi_gbl_FADT.gpe1_block_length / 2);\r\nif ((register_count0) &&\r\n(gpe_number_max >= acpi_gbl_FADT.gpe1_base)) {\r\nACPI_ERROR((AE_INFO,\r\n"GPE0 block (GPE 0 to %u) overlaps the GPE1 block "\r\n"(GPE %u to %u) - Ignoring GPE1",\r\ngpe_number_max, acpi_gbl_FADT.gpe1_base,\r\nacpi_gbl_FADT.gpe1_base +\r\n((register_count1 *\r\nACPI_GPE_REGISTER_WIDTH) - 1)));\r\nregister_count1 = 0;\r\n} else {\r\nstatus =\r\nacpi_ev_create_gpe_block(acpi_gbl_fadt_gpe_device,\r\nacpi_gbl_FADT.xgpe1_block.\r\naddress,\r\nacpi_gbl_FADT.xgpe1_block.\r\nspace_id, register_count1,\r\nacpi_gbl_FADT.gpe1_base,\r\nacpi_gbl_FADT.\r\nsci_interrupt,\r\n&acpi_gbl_gpe_fadt_blocks\r\n[1]);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Could not create GPE Block 1"));\r\n}\r\ngpe_number_max = acpi_gbl_FADT.gpe1_base +\r\n((register_count1 * ACPI_GPE_REGISTER_WIDTH) - 1);\r\n}\r\n}\r\nif ((register_count0 + register_count1) == 0) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INIT,\r\n"There are no GPE blocks defined in the FADT\n"));\r\nstatus = AE_OK;\r\ngoto cleanup;\r\n}\r\ncleanup:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nvoid acpi_ev_update_gpes(acpi_owner_id table_owner_id)\r\n{\r\nstruct acpi_gpe_xrupt_info *gpe_xrupt_info;\r\nstruct acpi_gpe_block_info *gpe_block;\r\nstruct acpi_gpe_walk_info walk_info;\r\nacpi_status status = AE_OK;\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn;\r\n}\r\nwalk_info.count = 0;\r\nwalk_info.owner_id = table_owner_id;\r\nwalk_info.execute_by_owner_id = TRUE;\r\ngpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;\r\nwhile (gpe_xrupt_info) {\r\ngpe_block = gpe_xrupt_info->gpe_block_list_head;\r\nwhile (gpe_block) {\r\nwalk_info.gpe_block = gpe_block;\r\nwalk_info.gpe_device = gpe_block->node;\r\nstatus = acpi_ns_walk_namespace(ACPI_TYPE_METHOD,\r\nwalk_info.gpe_device,\r\nACPI_UINT32_MAX,\r\nACPI_NS_WALK_NO_UNLOCK,\r\nacpi_ev_match_gpe_method,\r\nNULL, &walk_info, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"While decoding _Lxx/_Exx methods"));\r\n}\r\ngpe_block = gpe_block->next;\r\n}\r\ngpe_xrupt_info = gpe_xrupt_info->next;\r\n}\r\nif (walk_info.count) {\r\nACPI_INFO(("Enabled %u new GPEs", walk_info.count));\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn;\r\n}\r\nacpi_status\r\nacpi_ev_match_gpe_method(acpi_handle obj_handle,\r\nu32 level, void *context, void **return_value)\r\n{\r\nstruct acpi_namespace_node *method_node =\r\nACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);\r\nstruct acpi_gpe_walk_info *walk_info =\r\nACPI_CAST_PTR(struct acpi_gpe_walk_info, context);\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nacpi_status status;\r\nu32 gpe_number;\r\nu8 temp_gpe_number;\r\nchar name[ACPI_NAME_SIZE + 1];\r\nu8 type;\r\nACPI_FUNCTION_TRACE(ev_match_gpe_method);\r\nif ((walk_info->execute_by_owner_id) &&\r\n(method_node->owner_id != walk_info->owner_id)) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nACPI_MOVE_32_TO_32(name, &method_node->name.integer);\r\nname[ACPI_NAME_SIZE] = 0;\r\nif (name[0] != '_') {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nswitch (name[1]) {\r\ncase 'L':\r\ntype = ACPI_GPE_LEVEL_TRIGGERED;\r\nbreak;\r\ncase 'E':\r\ntype = ACPI_GPE_EDGE_TRIGGERED;\r\nbreak;\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_LOAD,\r\n"Ignoring unknown GPE method type: %s "\r\n"(name not of form _Lxx or _Exx)", name));\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nstatus = acpi_ut_ascii_to_hex_byte(&name[2], &temp_gpe_number);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_LOAD,\r\n"Could not extract GPE number from name: %s "\r\n"(name is not of form _Lxx or _Exx)", name));\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\ngpe_number = (u32)temp_gpe_number;\r\ngpe_event_info =\r\nacpi_ev_low_get_gpe_info(gpe_number, walk_info->gpe_block);\r\nif (!gpe_event_info) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nif ((ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\r\nACPI_GPE_DISPATCH_HANDLER) ||\r\n(ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\r\nACPI_GPE_DISPATCH_RAW_HANDLER)) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nif (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags) ==\r\nACPI_GPE_DISPATCH_METHOD) {\r\nif (type != (gpe_event_info->flags & ACPI_GPE_XRUPT_TYPE_MASK)) {\r\nACPI_ERROR((AE_INFO,\r\n"For GPE 0x%.2X, found both _L%2.2X and _E%2.2X methods",\r\ngpe_number, gpe_number, gpe_number));\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\n(void)acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_DISABLE);\r\ngpe_event_info->flags &= ~(ACPI_GPE_DISPATCH_MASK);\r\ngpe_event_info->flags |= (u8)(type | ACPI_GPE_DISPATCH_METHOD);\r\ngpe_event_info->dispatch.method_node = method_node;\r\nACPI_DEBUG_PRINT((ACPI_DB_LOAD,\r\n"Registered GPE method %s as GPE number 0x%.2X\n",\r\nname, gpe_number));\r\nreturn_ACPI_STATUS(AE_OK);\r\n}
