static void fm10k_fifo_init(struct fm10k_mbx_fifo *fifo, u32 *buffer, u16 size)\r\n{\r\nfifo->buffer = buffer;\r\nfifo->size = size;\r\nfifo->head = 0;\r\nfifo->tail = 0;\r\n}\r\nstatic u16 fm10k_fifo_used(struct fm10k_mbx_fifo *fifo)\r\n{\r\nreturn fifo->tail - fifo->head;\r\n}\r\nstatic u16 fm10k_fifo_unused(struct fm10k_mbx_fifo *fifo)\r\n{\r\nreturn fifo->size + fifo->head - fifo->tail;\r\n}\r\nstatic bool fm10k_fifo_empty(struct fm10k_mbx_fifo *fifo)\r\n{\r\nreturn fifo->head == fifo->tail;\r\n}\r\nstatic u16 fm10k_fifo_head_offset(struct fm10k_mbx_fifo *fifo, u16 offset)\r\n{\r\nreturn (fifo->head + offset) & (fifo->size - 1);\r\n}\r\nstatic u16 fm10k_fifo_tail_offset(struct fm10k_mbx_fifo *fifo, u16 offset)\r\n{\r\nreturn (fifo->tail + offset) & (fifo->size - 1);\r\n}\r\nstatic u16 fm10k_fifo_head_len(struct fm10k_mbx_fifo *fifo)\r\n{\r\nu32 *head = fifo->buffer + fm10k_fifo_head_offset(fifo, 0);\r\nif (fm10k_fifo_empty(fifo))\r\nreturn 0;\r\nreturn FM10K_TLV_DWORD_LEN(*head);\r\n}\r\nstatic u16 fm10k_fifo_head_drop(struct fm10k_mbx_fifo *fifo)\r\n{\r\nu16 len = fm10k_fifo_head_len(fifo);\r\nfifo->head += len;\r\nreturn len;\r\n}\r\nstatic void fm10k_fifo_drop_all(struct fm10k_mbx_fifo *fifo)\r\n{\r\nfifo->head = fifo->tail;\r\n}\r\nstatic u16 fm10k_mbx_index_len(struct fm10k_mbx_info *mbx, u16 head, u16 tail)\r\n{\r\nu16 len = tail - head;\r\nif (len > tail)\r\nlen -= 2;\r\nreturn len & ((mbx->mbmem_len << 1) - 1);\r\n}\r\nstatic u16 fm10k_mbx_tail_add(struct fm10k_mbx_info *mbx, u16 offset)\r\n{\r\nu16 tail = (mbx->tail + offset + 1) & ((mbx->mbmem_len << 1) - 1);\r\nreturn (tail > mbx->tail) ? --tail : ++tail;\r\n}\r\nstatic u16 fm10k_mbx_tail_sub(struct fm10k_mbx_info *mbx, u16 offset)\r\n{\r\nu16 tail = (mbx->tail - offset - 1) & ((mbx->mbmem_len << 1) - 1);\r\nreturn (tail < mbx->tail) ? ++tail : --tail;\r\n}\r\nstatic u16 fm10k_mbx_head_add(struct fm10k_mbx_info *mbx, u16 offset)\r\n{\r\nu16 head = (mbx->head + offset + 1) & ((mbx->mbmem_len << 1) - 1);\r\nreturn (head > mbx->head) ? --head : ++head;\r\n}\r\nstatic u16 fm10k_mbx_head_sub(struct fm10k_mbx_info *mbx, u16 offset)\r\n{\r\nu16 head = (mbx->head - offset - 1) & ((mbx->mbmem_len << 1) - 1);\r\nreturn (head < mbx->head) ? ++head : --head;\r\n}\r\nstatic u16 fm10k_mbx_pushed_tail_len(struct fm10k_mbx_info *mbx)\r\n{\r\nu32 *tail = mbx->rx.buffer + fm10k_fifo_tail_offset(&mbx->rx, 0);\r\nif (!mbx->pushed)\r\nreturn 0;\r\nreturn FM10K_TLV_DWORD_LEN(*tail);\r\n}\r\nstatic void fm10k_fifo_write_copy(struct fm10k_mbx_fifo *fifo,\r\nconst u32 *msg, u16 tail_offset, u16 len)\r\n{\r\nu16 end = fm10k_fifo_tail_offset(fifo, tail_offset);\r\nu32 *tail = fifo->buffer + end;\r\nend = fifo->size - end;\r\nif (end < len)\r\nmemcpy(fifo->buffer, msg + end, (len - end) << 2);\r\nelse\r\nend = len;\r\nmemcpy(tail, msg, end << 2);\r\n}\r\nstatic s32 fm10k_fifo_enqueue(struct fm10k_mbx_fifo *fifo, const u32 *msg)\r\n{\r\nu16 len = FM10K_TLV_DWORD_LEN(*msg);\r\nif (len > fifo->size)\r\nreturn FM10K_MBX_ERR_SIZE;\r\nif (len > fm10k_fifo_unused(fifo))\r\nreturn FM10K_MBX_ERR_NO_SPACE;\r\nfm10k_fifo_write_copy(fifo, msg, 0, len);\r\nwmb();\r\nfifo->tail += len;\r\nreturn 0;\r\n}\r\nstatic u16 fm10k_mbx_validate_msg_size(struct fm10k_mbx_info *mbx, u16 len)\r\n{\r\nstruct fm10k_mbx_fifo *fifo = &mbx->rx;\r\nu16 total_len = 0, msg_len;\r\nu32 *msg;\r\nlen += mbx->pushed;\r\ndo {\r\nmsg = fifo->buffer + fm10k_fifo_tail_offset(fifo, total_len);\r\nmsg_len = FM10K_TLV_DWORD_LEN(*msg);\r\ntotal_len += msg_len;\r\n} while (total_len < len);\r\nif ((len < total_len) && (msg_len <= mbx->max_size))\r\nreturn 0;\r\nreturn (len < total_len) ? len : (len - total_len);\r\n}\r\nstatic void fm10k_mbx_write_copy(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nstruct fm10k_mbx_fifo *fifo = &mbx->tx;\r\nu32 mbmem = mbx->mbmem_reg;\r\nu32 *head = fifo->buffer;\r\nu16 end, len, tail, mask;\r\nif (!mbx->tail_len)\r\nreturn;\r\nmask = mbx->mbmem_len - 1;\r\nlen = mbx->tail_len;\r\ntail = fm10k_mbx_tail_sub(mbx, len);\r\nif (tail > mask)\r\ntail++;\r\nend = fm10k_fifo_head_offset(fifo, mbx->pulled);\r\nhead += end;\r\nrmb();\r\nfor (end = fifo->size - end; len; head = fifo->buffer) {\r\ndo {\r\ntail &= mask;\r\nif (!tail)\r\ntail++;\r\nmbx->tx_mbmem_pulled++;\r\nfm10k_write_reg(hw, mbmem + tail++, *(head++));\r\n} while (--len && --end);\r\n}\r\n}\r\nstatic void fm10k_mbx_pull_head(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx, u16 head)\r\n{\r\nu16 mbmem_len, len, ack = fm10k_mbx_index_len(mbx, head, mbx->tail);\r\nstruct fm10k_mbx_fifo *fifo = &mbx->tx;\r\nmbx->pulled += mbx->tail_len - ack;\r\nmbmem_len = mbx->mbmem_len - 1;\r\nlen = fm10k_fifo_used(fifo) - mbx->pulled;\r\nif (len > mbmem_len)\r\nlen = mbmem_len;\r\nmbx->tail = fm10k_mbx_tail_add(mbx, len - ack);\r\nmbx->tail_len = len;\r\nfor (len = fm10k_fifo_head_len(fifo);\r\nlen && (mbx->pulled >= len);\r\nlen = fm10k_fifo_head_len(fifo)) {\r\nmbx->pulled -= fm10k_fifo_head_drop(fifo);\r\nmbx->tx_messages++;\r\nmbx->tx_dwords += len;\r\n}\r\nfm10k_mbx_write_copy(hw, mbx);\r\n}\r\nstatic void fm10k_mbx_read_copy(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nstruct fm10k_mbx_fifo *fifo = &mbx->rx;\r\nu32 mbmem = mbx->mbmem_reg ^ mbx->mbmem_len;\r\nu32 *tail = fifo->buffer;\r\nu16 end, len, head;\r\nlen = mbx->head_len;\r\nhead = fm10k_mbx_head_sub(mbx, len);\r\nif (head >= mbx->mbmem_len)\r\nhead++;\r\nend = fm10k_fifo_tail_offset(fifo, mbx->pushed);\r\ntail += end;\r\nfor (end = fifo->size - end; len; tail = fifo->buffer) {\r\ndo {\r\nhead &= mbx->mbmem_len - 1;\r\nif (!head)\r\nhead++;\r\nmbx->rx_mbmem_pushed++;\r\n*(tail++) = fm10k_read_reg(hw, mbmem + head++);\r\n} while (--len && --end);\r\n}\r\nwmb();\r\n}\r\nstatic s32 fm10k_mbx_push_tail(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx,\r\nu16 tail)\r\n{\r\nstruct fm10k_mbx_fifo *fifo = &mbx->rx;\r\nu16 len, seq = fm10k_mbx_index_len(mbx, mbx->head, tail);\r\nlen = fm10k_fifo_unused(fifo) - mbx->pushed;\r\nif (len > seq)\r\nlen = seq;\r\nmbx->head = fm10k_mbx_head_add(mbx, len);\r\nmbx->head_len = len;\r\nif (!len)\r\nreturn 0;\r\nfm10k_mbx_read_copy(hw, mbx);\r\nif (fm10k_mbx_validate_msg_size(mbx, len))\r\nreturn FM10K_MBX_ERR_SIZE;\r\nmbx->pushed += len;\r\nfor (len = fm10k_mbx_pushed_tail_len(mbx);\r\nlen && (mbx->pushed >= len);\r\nlen = fm10k_mbx_pushed_tail_len(mbx)) {\r\nfifo->tail += len;\r\nmbx->pushed -= len;\r\nmbx->rx_messages++;\r\nmbx->rx_dwords += len;\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 fm10k_crc_16b(const u32 *data, u16 seed, u16 len)\r\n{\r\nu32 result = seed;\r\nwhile (len--) {\r\nresult ^= *(data++);\r\nresult = (result >> 8) ^ fm10k_crc_16b_table[result & 0xFF];\r\nresult = (result >> 8) ^ fm10k_crc_16b_table[result & 0xFF];\r\nif (!(len--))\r\nbreak;\r\nresult = (result >> 8) ^ fm10k_crc_16b_table[result & 0xFF];\r\nresult = (result >> 8) ^ fm10k_crc_16b_table[result & 0xFF];\r\n}\r\nreturn (u16)result;\r\n}\r\nstatic u16 fm10k_fifo_crc(struct fm10k_mbx_fifo *fifo, u16 offset,\r\nu16 len, u16 seed)\r\n{\r\nu32 *data = fifo->buffer + offset;\r\noffset = fifo->size - offset;\r\nif (offset < len) {\r\nseed = fm10k_crc_16b(data, seed, offset * 2);\r\ndata = fifo->buffer;\r\nlen -= offset;\r\n}\r\nreturn fm10k_crc_16b(data, seed, len * 2);\r\n}\r\nstatic void fm10k_mbx_update_local_crc(struct fm10k_mbx_info *mbx, u16 head)\r\n{\r\nu16 len = mbx->tail_len - fm10k_mbx_index_len(mbx, head, mbx->tail);\r\nhead = fm10k_fifo_head_offset(&mbx->tx, mbx->pulled);\r\nmbx->local = fm10k_fifo_crc(&mbx->tx, head, len, mbx->local);\r\n}\r\nstatic s32 fm10k_mbx_verify_remote_crc(struct fm10k_mbx_info *mbx)\r\n{\r\nstruct fm10k_mbx_fifo *fifo = &mbx->rx;\r\nu16 len = mbx->head_len;\r\nu16 offset = fm10k_fifo_tail_offset(fifo, mbx->pushed) - len;\r\nu16 crc;\r\nif (len)\r\nmbx->remote = fm10k_fifo_crc(fifo, offset, len, mbx->remote);\r\ncrc = fm10k_crc_16b(&mbx->mbx_hdr, mbx->remote, 1);\r\nreturn crc ? FM10K_MBX_ERR_CRC : 0;\r\n}\r\nstatic bool fm10k_mbx_rx_ready(struct fm10k_mbx_info *mbx)\r\n{\r\nu16 msg_size = fm10k_fifo_head_len(&mbx->rx);\r\nreturn msg_size && (fm10k_fifo_used(&mbx->rx) >= msg_size);\r\n}\r\nstatic bool fm10k_mbx_tx_ready(struct fm10k_mbx_info *mbx, u16 len)\r\n{\r\nu16 fifo_unused = fm10k_fifo_unused(&mbx->tx);\r\nreturn (mbx->state == FM10K_STATE_OPEN) && (fifo_unused >= len);\r\n}\r\nstatic bool fm10k_mbx_tx_complete(struct fm10k_mbx_info *mbx)\r\n{\r\nreturn fm10k_fifo_empty(&mbx->tx);\r\n}\r\nstatic u16 fm10k_mbx_dequeue_rx(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nstruct fm10k_mbx_fifo *fifo = &mbx->rx;\r\ns32 err;\r\nu16 cnt;\r\nfor (cnt = 0; !fm10k_fifo_empty(fifo); cnt++) {\r\nerr = fm10k_tlv_msg_parse(hw, fifo->buffer + fifo->head,\r\nmbx, mbx->msg_data);\r\nif (err < 0)\r\nmbx->rx_parse_err++;\r\nfm10k_fifo_head_drop(fifo);\r\n}\r\nmemmove(fifo->buffer, fifo->buffer + fifo->tail, mbx->pushed << 2);\r\nfifo->tail -= fifo->head;\r\nfifo->head = 0;\r\nreturn cnt;\r\n}\r\nstatic s32 fm10k_mbx_enqueue_tx(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx, const u32 *msg)\r\n{\r\nu32 countdown = mbx->timeout;\r\ns32 err;\r\nswitch (mbx->state) {\r\ncase FM10K_STATE_CLOSED:\r\ncase FM10K_STATE_DISCONNECT:\r\nreturn FM10K_MBX_ERR_NO_MBX;\r\ndefault:\r\nbreak;\r\n}\r\nerr = fm10k_fifo_enqueue(&mbx->tx, msg);\r\nwhile (err && countdown) {\r\ncountdown--;\r\nudelay(mbx->udelay);\r\nmbx->ops.process(hw, mbx);\r\nerr = fm10k_fifo_enqueue(&mbx->tx, msg);\r\n}\r\nif (err) {\r\nmbx->timeout = 0;\r\nmbx->tx_busy++;\r\n}\r\nif (!mbx->tail_len)\r\nmbx->ops.process(hw, mbx);\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_mbx_read(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)\r\n{\r\nif (mbx->mbx_hdr)\r\nreturn FM10K_MBX_ERR_BUSY;\r\nif (fm10k_read_reg(hw, mbx->mbx_reg) & FM10K_MBX_REQ_INTERRUPT)\r\nmbx->mbx_lock = FM10K_MBX_ACK;\r\nfm10k_write_reg(hw, mbx->mbx_reg,\r\nFM10K_MBX_REQ_INTERRUPT | FM10K_MBX_ACK_INTERRUPT);\r\nmbx->mbx_hdr = fm10k_read_reg(hw, mbx->mbmem_reg ^ mbx->mbmem_len);\r\nreturn 0;\r\n}\r\nstatic void fm10k_mbx_write(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)\r\n{\r\nu32 mbmem = mbx->mbmem_reg;\r\nfm10k_write_reg(hw, mbmem, mbx->mbx_hdr);\r\nif (mbx->mbx_lock)\r\nfm10k_write_reg(hw, mbx->mbx_reg, mbx->mbx_lock);\r\nmbx->mbx_hdr = 0;\r\nmbx->mbx_lock = 0;\r\n}\r\nstatic void fm10k_mbx_create_connect_hdr(struct fm10k_mbx_info *mbx)\r\n{\r\nmbx->mbx_lock |= FM10K_MBX_REQ;\r\nmbx->mbx_hdr = FM10K_MSG_HDR_FIELD_SET(FM10K_MSG_CONNECT, TYPE) |\r\nFM10K_MSG_HDR_FIELD_SET(mbx->head, HEAD) |\r\nFM10K_MSG_HDR_FIELD_SET(mbx->rx.size - 1, CONNECT_SIZE);\r\n}\r\nstatic void fm10k_mbx_create_data_hdr(struct fm10k_mbx_info *mbx)\r\n{\r\nu32 hdr = FM10K_MSG_HDR_FIELD_SET(FM10K_MSG_DATA, TYPE) |\r\nFM10K_MSG_HDR_FIELD_SET(mbx->tail, TAIL) |\r\nFM10K_MSG_HDR_FIELD_SET(mbx->head, HEAD);\r\nstruct fm10k_mbx_fifo *fifo = &mbx->tx;\r\nu16 crc;\r\nif (mbx->tail_len)\r\nmbx->mbx_lock |= FM10K_MBX_REQ;\r\ncrc = fm10k_fifo_crc(fifo, fm10k_fifo_head_offset(fifo, mbx->pulled),\r\nmbx->tail_len, mbx->local);\r\ncrc = fm10k_crc_16b(&hdr, crc, 1);\r\nmbx->mbx_hdr = hdr | FM10K_MSG_HDR_FIELD_SET(crc, CRC);\r\n}\r\nstatic void fm10k_mbx_create_disconnect_hdr(struct fm10k_mbx_info *mbx)\r\n{\r\nu32 hdr = FM10K_MSG_HDR_FIELD_SET(FM10K_MSG_DISCONNECT, TYPE) |\r\nFM10K_MSG_HDR_FIELD_SET(mbx->tail, TAIL) |\r\nFM10K_MSG_HDR_FIELD_SET(mbx->head, HEAD);\r\nu16 crc = fm10k_crc_16b(&hdr, mbx->local, 1);\r\nmbx->mbx_lock |= FM10K_MBX_ACK;\r\nmbx->mbx_hdr = hdr | FM10K_MSG_HDR_FIELD_SET(crc, CRC);\r\n}\r\nstatic void fm10k_mbx_create_fake_disconnect_hdr(struct fm10k_mbx_info *mbx)\r\n{\r\nu32 hdr = FM10K_MSG_HDR_FIELD_SET(FM10K_MSG_DISCONNECT, TYPE) |\r\nFM10K_MSG_HDR_FIELD_SET(mbx->head, TAIL) |\r\nFM10K_MSG_HDR_FIELD_SET(mbx->tail, HEAD);\r\nu16 crc = fm10k_crc_16b(&hdr, mbx->local, 1);\r\nmbx->mbx_lock |= FM10K_MBX_ACK;\r\nmbx->mbx_hdr = hdr | FM10K_MSG_HDR_FIELD_SET(crc, CRC);\r\n}\r\nstatic void fm10k_mbx_create_error_msg(struct fm10k_mbx_info *mbx, s32 err)\r\n{\r\nswitch (err) {\r\ncase FM10K_MBX_ERR_TAIL:\r\ncase FM10K_MBX_ERR_HEAD:\r\ncase FM10K_MBX_ERR_TYPE:\r\ncase FM10K_MBX_ERR_SIZE:\r\ncase FM10K_MBX_ERR_RSVD0:\r\ncase FM10K_MBX_ERR_CRC:\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nmbx->mbx_lock |= FM10K_MBX_REQ;\r\nmbx->mbx_hdr = FM10K_MSG_HDR_FIELD_SET(FM10K_MSG_ERROR, TYPE) |\r\nFM10K_MSG_HDR_FIELD_SET(err, ERR_NO) |\r\nFM10K_MSG_HDR_FIELD_SET(mbx->head, HEAD);\r\n}\r\nstatic s32 fm10k_mbx_validate_msg_hdr(struct fm10k_mbx_info *mbx)\r\n{\r\nu16 type, rsvd0, head, tail, size;\r\nconst u32 *hdr = &mbx->mbx_hdr;\r\ntype = FM10K_MSG_HDR_FIELD_GET(*hdr, TYPE);\r\nrsvd0 = FM10K_MSG_HDR_FIELD_GET(*hdr, RSVD0);\r\ntail = FM10K_MSG_HDR_FIELD_GET(*hdr, TAIL);\r\nhead = FM10K_MSG_HDR_FIELD_GET(*hdr, HEAD);\r\nsize = FM10K_MSG_HDR_FIELD_GET(*hdr, CONNECT_SIZE);\r\nif (rsvd0)\r\nreturn FM10K_MBX_ERR_RSVD0;\r\nswitch (type) {\r\ncase FM10K_MSG_DISCONNECT:\r\nif (tail != mbx->head)\r\nreturn FM10K_MBX_ERR_TAIL;\r\ncase FM10K_MSG_DATA:\r\nif (!head || (head == FM10K_MSG_HDR_MASK(HEAD)))\r\nreturn FM10K_MBX_ERR_HEAD;\r\nif (fm10k_mbx_index_len(mbx, head, mbx->tail) > mbx->tail_len)\r\nreturn FM10K_MBX_ERR_HEAD;\r\nif (!tail || (tail == FM10K_MSG_HDR_MASK(TAIL)))\r\nreturn FM10K_MBX_ERR_TAIL;\r\nif (fm10k_mbx_index_len(mbx, mbx->head, tail) < mbx->mbmem_len)\r\nbreak;\r\nreturn FM10K_MBX_ERR_TAIL;\r\ncase FM10K_MSG_CONNECT:\r\nif ((size < FM10K_VFMBX_MSG_MTU) || (size & (size + 1)))\r\nreturn FM10K_MBX_ERR_SIZE;\r\ncase FM10K_MSG_ERROR:\r\nif (!head || (head == FM10K_MSG_HDR_MASK(HEAD)))\r\nreturn FM10K_MBX_ERR_HEAD;\r\nif (tail)\r\nreturn FM10K_MBX_ERR_TAIL;\r\nbreak;\r\ndefault:\r\nreturn FM10K_MBX_ERR_TYPE;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_mbx_create_reply(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx, u16 head)\r\n{\r\nswitch (mbx->state) {\r\ncase FM10K_STATE_OPEN:\r\ncase FM10K_STATE_DISCONNECT:\r\nfm10k_mbx_update_local_crc(mbx, head);\r\nfm10k_mbx_pull_head(hw, mbx, head);\r\nif (mbx->tail_len || (mbx->state == FM10K_STATE_OPEN))\r\nfm10k_mbx_create_data_hdr(mbx);\r\nelse\r\nfm10k_mbx_create_disconnect_hdr(mbx);\r\nbreak;\r\ncase FM10K_STATE_CONNECT:\r\nfm10k_mbx_create_connect_hdr(mbx);\r\nbreak;\r\ncase FM10K_STATE_CLOSED:\r\nfm10k_mbx_create_disconnect_hdr(mbx);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fm10k_mbx_reset_work(struct fm10k_mbx_info *mbx)\r\n{\r\nu16 len, head, ack;\r\nmbx->max_size = mbx->rx.size - 1;\r\nhead = FM10K_MSG_HDR_FIELD_GET(mbx->mbx_hdr, HEAD);\r\nack = fm10k_mbx_index_len(mbx, head, mbx->tail);\r\nmbx->pulled += mbx->tail_len - ack;\r\nwhile (fm10k_fifo_head_len(&mbx->tx) && mbx->pulled) {\r\nlen = fm10k_fifo_head_drop(&mbx->tx);\r\nmbx->tx_dropped++;\r\nif (mbx->pulled >= len)\r\nmbx->pulled -= len;\r\nelse\r\nmbx->pulled = 0;\r\n}\r\nmbx->pushed = 0;\r\nmbx->pulled = 0;\r\nmbx->tail_len = 0;\r\nmbx->head_len = 0;\r\nmbx->rx.tail = 0;\r\nmbx->rx.head = 0;\r\n}\r\nstatic void fm10k_mbx_update_max_size(struct fm10k_mbx_info *mbx, u16 size)\r\n{\r\nu16 len;\r\nmbx->max_size = size;\r\nfor (len = fm10k_fifo_head_len(&mbx->tx);\r\nlen > size;\r\nlen = fm10k_fifo_head_len(&mbx->tx)) {\r\nfm10k_fifo_head_drop(&mbx->tx);\r\nmbx->tx_dropped++;\r\n}\r\n}\r\nstatic void fm10k_mbx_connect_reset(struct fm10k_mbx_info *mbx)\r\n{\r\nfm10k_mbx_reset_work(mbx);\r\nmbx->local = FM10K_MBX_CRC_SEED;\r\nmbx->remote = FM10K_MBX_CRC_SEED;\r\nif (mbx->state == FM10K_STATE_OPEN)\r\nmbx->state = FM10K_STATE_CONNECT;\r\nelse\r\nmbx->state = FM10K_STATE_CLOSED;\r\n}\r\nstatic s32 fm10k_mbx_process_connect(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nconst enum fm10k_mbx_state state = mbx->state;\r\nconst u32 *hdr = &mbx->mbx_hdr;\r\nu16 size, head;\r\nsize = FM10K_MSG_HDR_FIELD_GET(*hdr, CONNECT_SIZE);\r\nhead = FM10K_MSG_HDR_FIELD_GET(*hdr, HEAD);\r\nswitch (state) {\r\ncase FM10K_STATE_DISCONNECT:\r\ncase FM10K_STATE_OPEN:\r\nfm10k_mbx_connect_reset(mbx);\r\nbreak;\r\ncase FM10K_STATE_CONNECT:\r\nif (size > mbx->rx.size) {\r\nmbx->max_size = mbx->rx.size - 1;\r\n} else {\r\nmbx->state = FM10K_STATE_OPEN;\r\nfm10k_mbx_update_max_size(mbx, size);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmbx->tail = head;\r\nreturn fm10k_mbx_create_reply(hw, mbx, head);\r\n}\r\nstatic s32 fm10k_mbx_process_data(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nconst u32 *hdr = &mbx->mbx_hdr;\r\nu16 head, tail;\r\ns32 err;\r\nhead = FM10K_MSG_HDR_FIELD_GET(*hdr, HEAD);\r\ntail = FM10K_MSG_HDR_FIELD_GET(*hdr, TAIL);\r\nif (mbx->state == FM10K_STATE_CONNECT) {\r\nmbx->tail = head;\r\nmbx->state = FM10K_STATE_OPEN;\r\n}\r\nerr = fm10k_mbx_push_tail(hw, mbx, tail);\r\nif (err < 0)\r\nreturn err;\r\nerr = fm10k_mbx_verify_remote_crc(mbx);\r\nif (err)\r\nreturn err;\r\nfm10k_mbx_dequeue_rx(hw, mbx);\r\nreturn fm10k_mbx_create_reply(hw, mbx, head);\r\n}\r\nstatic s32 fm10k_mbx_process_disconnect(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nconst enum fm10k_mbx_state state = mbx->state;\r\nconst u32 *hdr = &mbx->mbx_hdr;\r\nu16 head;\r\ns32 err;\r\nhead = FM10K_MSG_HDR_FIELD_GET(*hdr, HEAD);\r\nif (mbx->pushed)\r\nreturn FM10K_MBX_ERR_TAIL;\r\nmbx->head_len = 0;\r\nerr = fm10k_mbx_verify_remote_crc(mbx);\r\nif (err)\r\nreturn err;\r\nswitch (state) {\r\ncase FM10K_STATE_DISCONNECT:\r\ncase FM10K_STATE_OPEN:\r\nif (!fm10k_mbx_tx_complete(mbx))\r\nbreak;\r\nif (head != mbx->tail)\r\nreturn FM10K_MBX_ERR_HEAD;\r\nfm10k_mbx_connect_reset(mbx);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn fm10k_mbx_create_reply(hw, mbx, head);\r\n}\r\nstatic s32 fm10k_mbx_process_error(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nconst u32 *hdr = &mbx->mbx_hdr;\r\nu16 head;\r\nhead = FM10K_MSG_HDR_FIELD_GET(*hdr, HEAD);\r\nswitch (mbx->state) {\r\ncase FM10K_STATE_OPEN:\r\ncase FM10K_STATE_DISCONNECT:\r\nfm10k_mbx_reset_work(mbx);\r\nmbx->local = FM10K_MBX_CRC_SEED;\r\nmbx->remote = FM10K_MBX_CRC_SEED;\r\nmbx->tail = head;\r\nif (mbx->state == FM10K_STATE_OPEN) {\r\nmbx->state = FM10K_STATE_CONNECT;\r\nbreak;\r\n}\r\nfm10k_mbx_create_connect_hdr(mbx);\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn fm10k_mbx_create_reply(hw, mbx, mbx->tail);\r\n}\r\nstatic s32 fm10k_mbx_process(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\ns32 err;\r\nif (mbx->state == FM10K_STATE_CLOSED)\r\nreturn 0;\r\nerr = fm10k_mbx_read(hw, mbx);\r\nif (err)\r\nreturn err;\r\nerr = fm10k_mbx_validate_msg_hdr(mbx);\r\nif (err < 0)\r\ngoto msg_err;\r\nswitch (FM10K_MSG_HDR_FIELD_GET(mbx->mbx_hdr, TYPE)) {\r\ncase FM10K_MSG_CONNECT:\r\nerr = fm10k_mbx_process_connect(hw, mbx);\r\nbreak;\r\ncase FM10K_MSG_DATA:\r\nerr = fm10k_mbx_process_data(hw, mbx);\r\nbreak;\r\ncase FM10K_MSG_DISCONNECT:\r\nerr = fm10k_mbx_process_disconnect(hw, mbx);\r\nbreak;\r\ncase FM10K_MSG_ERROR:\r\nerr = fm10k_mbx_process_error(hw, mbx);\r\nbreak;\r\ndefault:\r\nerr = FM10K_MBX_ERR_TYPE;\r\nbreak;\r\n}\r\nmsg_err:\r\nif (err < 0)\r\nfm10k_mbx_create_error_msg(mbx, err);\r\nfm10k_mbx_write(hw, mbx);\r\nreturn err;\r\n}\r\nstatic void fm10k_mbx_disconnect(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nint timeout = mbx->timeout ? FM10K_MBX_DISCONNECT_TIMEOUT : 0;\r\nmbx->state = FM10K_STATE_DISCONNECT;\r\nfm10k_write_reg(hw, mbx->mbx_reg, FM10K_MBX_REQ |\r\nFM10K_MBX_INTERRUPT_DISABLE);\r\ndo {\r\nudelay(FM10K_MBX_POLL_DELAY);\r\nmbx->ops.process(hw, mbx);\r\ntimeout -= FM10K_MBX_POLL_DELAY;\r\n} while ((timeout > 0) && (mbx->state != FM10K_STATE_CLOSED));\r\nfm10k_mbx_connect_reset(mbx);\r\nfm10k_fifo_drop_all(&mbx->tx);\r\nfm10k_write_reg(hw, mbx->mbmem_reg, 0);\r\n}\r\nstatic s32 fm10k_mbx_connect(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)\r\n{\r\nif (!mbx->rx.buffer)\r\nreturn FM10K_MBX_ERR_NO_SPACE;\r\nif (mbx->state != FM10K_STATE_CLOSED)\r\nreturn FM10K_MBX_ERR_BUSY;\r\nmbx->timeout = FM10K_MBX_INIT_TIMEOUT;\r\nmbx->state = FM10K_STATE_CONNECT;\r\nfm10k_mbx_reset_work(mbx);\r\nfm10k_mbx_create_fake_disconnect_hdr(mbx);\r\nfm10k_write_reg(hw, mbx->mbmem_reg ^ mbx->mbmem_len, mbx->mbx_hdr);\r\nmbx->mbx_lock = FM10K_MBX_REQ_INTERRUPT | FM10K_MBX_ACK_INTERRUPT |\r\nFM10K_MBX_INTERRUPT_ENABLE;\r\nfm10k_mbx_create_connect_hdr(mbx);\r\nfm10k_mbx_write(hw, mbx);\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_mbx_validate_handlers(const struct fm10k_msg_data *msg_data)\r\n{\r\nconst struct fm10k_tlv_attr *attr;\r\nunsigned int id;\r\nif (!msg_data)\r\nreturn 0;\r\nwhile (msg_data->id != FM10K_TLV_ERROR) {\r\nif (!msg_data->func)\r\nreturn FM10K_ERR_PARAM;\r\nattr = msg_data->attr;\r\nif (attr) {\r\nwhile (attr->id != FM10K_TLV_ERROR) {\r\nid = attr->id;\r\nattr++;\r\nif (id >= attr->id)\r\nreturn FM10K_ERR_PARAM;\r\nif (id >= FM10K_TLV_RESULTS_MAX)\r\nreturn FM10K_ERR_PARAM;\r\n}\r\nif (attr->id != FM10K_TLV_ERROR)\r\nreturn FM10K_ERR_PARAM;\r\n}\r\nid = msg_data->id;\r\nmsg_data++;\r\nif (id >= msg_data->id)\r\nreturn FM10K_ERR_PARAM;\r\n}\r\nif ((msg_data->id != FM10K_TLV_ERROR) || !msg_data->func)\r\nreturn FM10K_ERR_PARAM;\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_mbx_register_handlers(struct fm10k_mbx_info *mbx,\r\nconst struct fm10k_msg_data *msg_data)\r\n{\r\nif (fm10k_mbx_validate_handlers(msg_data))\r\nreturn FM10K_ERR_PARAM;\r\nmbx->msg_data = msg_data;\r\nreturn 0;\r\n}\r\ns32 fm10k_pfvf_mbx_init(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx,\r\nconst struct fm10k_msg_data *msg_data, u8 id)\r\n{\r\nswitch (hw->mac.type) {\r\ncase fm10k_mac_vf:\r\nmbx->mbx_reg = FM10K_VFMBX;\r\nmbx->mbmem_reg = FM10K_VFMBMEM(FM10K_VFMBMEM_VF_XOR);\r\nbreak;\r\ncase fm10k_mac_pf:\r\nif (id < 64) {\r\nmbx->mbx_reg = FM10K_MBX(id);\r\nmbx->mbmem_reg = FM10K_MBMEM_VF(id, 0);\r\nbreak;\r\n}\r\ndefault:\r\nreturn FM10K_MBX_ERR_NO_MBX;\r\n}\r\nmbx->state = FM10K_STATE_CLOSED;\r\nif (fm10k_mbx_validate_handlers(msg_data))\r\nreturn FM10K_ERR_PARAM;\r\nmbx->msg_data = msg_data;\r\nmbx->timeout = 0;\r\nmbx->udelay = FM10K_MBX_INIT_DELAY;\r\nmbx->tail = 1;\r\nmbx->head = 1;\r\nmbx->local = FM10K_MBX_CRC_SEED;\r\nmbx->remote = FM10K_MBX_CRC_SEED;\r\nmbx->max_size = FM10K_MBX_MSG_MAX_SIZE;\r\nmbx->mbmem_len = FM10K_VFMBMEM_VF_XOR;\r\nfm10k_fifo_init(&mbx->tx, mbx->buffer, FM10K_MBX_TX_BUFFER_SIZE);\r\nfm10k_fifo_init(&mbx->rx, &mbx->buffer[FM10K_MBX_TX_BUFFER_SIZE],\r\nFM10K_MBX_RX_BUFFER_SIZE);\r\nmbx->ops.connect = fm10k_mbx_connect;\r\nmbx->ops.disconnect = fm10k_mbx_disconnect;\r\nmbx->ops.rx_ready = fm10k_mbx_rx_ready;\r\nmbx->ops.tx_ready = fm10k_mbx_tx_ready;\r\nmbx->ops.tx_complete = fm10k_mbx_tx_complete;\r\nmbx->ops.enqueue_tx = fm10k_mbx_enqueue_tx;\r\nmbx->ops.process = fm10k_mbx_process;\r\nmbx->ops.register_handlers = fm10k_mbx_register_handlers;\r\nreturn 0;\r\n}\r\nstatic void fm10k_sm_mbx_create_data_hdr(struct fm10k_mbx_info *mbx)\r\n{\r\nif (mbx->tail_len)\r\nmbx->mbx_lock |= FM10K_MBX_REQ;\r\nmbx->mbx_hdr = FM10K_MSG_HDR_FIELD_SET(mbx->tail, SM_TAIL) |\r\nFM10K_MSG_HDR_FIELD_SET(mbx->remote, SM_VER) |\r\nFM10K_MSG_HDR_FIELD_SET(mbx->head, SM_HEAD);\r\n}\r\nstatic void fm10k_sm_mbx_create_connect_hdr(struct fm10k_mbx_info *mbx, u8 err)\r\n{\r\nif (mbx->local)\r\nmbx->mbx_lock |= FM10K_MBX_REQ;\r\nmbx->mbx_hdr = FM10K_MSG_HDR_FIELD_SET(mbx->tail, SM_TAIL) |\r\nFM10K_MSG_HDR_FIELD_SET(mbx->remote, SM_VER) |\r\nFM10K_MSG_HDR_FIELD_SET(mbx->head, SM_HEAD) |\r\nFM10K_MSG_HDR_FIELD_SET(err, SM_ERR);\r\n}\r\nstatic void fm10k_sm_mbx_connect_reset(struct fm10k_mbx_info *mbx)\r\n{\r\nfm10k_mbx_reset_work(mbx);\r\nmbx->local = FM10K_SM_MBX_VERSION;\r\nmbx->remote = 0;\r\nmbx->tail = 1;\r\nmbx->head = 1;\r\nmbx->state = FM10K_STATE_CONNECT;\r\n}\r\nstatic s32 fm10k_sm_mbx_connect(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)\r\n{\r\nif (!mbx->rx.buffer)\r\nreturn FM10K_MBX_ERR_NO_SPACE;\r\nif (mbx->state != FM10K_STATE_CLOSED)\r\nreturn FM10K_MBX_ERR_BUSY;\r\nmbx->timeout = FM10K_MBX_INIT_TIMEOUT;\r\nmbx->state = FM10K_STATE_CONNECT;\r\nmbx->max_size = FM10K_MBX_MSG_MAX_SIZE;\r\nfm10k_sm_mbx_connect_reset(mbx);\r\nmbx->mbx_lock = FM10K_MBX_REQ_INTERRUPT | FM10K_MBX_ACK_INTERRUPT |\r\nFM10K_MBX_INTERRUPT_ENABLE;\r\nfm10k_sm_mbx_create_connect_hdr(mbx, 0);\r\nfm10k_mbx_write(hw, mbx);\r\nreturn 0;\r\n}\r\nstatic void fm10k_sm_mbx_disconnect(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nint timeout = mbx->timeout ? FM10K_MBX_DISCONNECT_TIMEOUT : 0;\r\nmbx->state = FM10K_STATE_DISCONNECT;\r\nfm10k_write_reg(hw, mbx->mbx_reg, FM10K_MBX_REQ |\r\nFM10K_MBX_INTERRUPT_DISABLE);\r\ndo {\r\nudelay(FM10K_MBX_POLL_DELAY);\r\nmbx->ops.process(hw, mbx);\r\ntimeout -= FM10K_MBX_POLL_DELAY;\r\n} while ((timeout > 0) && (mbx->state != FM10K_STATE_CLOSED));\r\nmbx->state = FM10K_STATE_CLOSED;\r\nmbx->remote = 0;\r\nfm10k_mbx_reset_work(mbx);\r\nfm10k_fifo_drop_all(&mbx->tx);\r\nfm10k_write_reg(hw, mbx->mbmem_reg, 0);\r\n}\r\nstatic s32 fm10k_sm_mbx_validate_fifo_hdr(struct fm10k_mbx_info *mbx)\r\n{\r\nconst u32 *hdr = &mbx->mbx_hdr;\r\nu16 tail, head, ver;\r\ntail = FM10K_MSG_HDR_FIELD_GET(*hdr, SM_TAIL);\r\nver = FM10K_MSG_HDR_FIELD_GET(*hdr, SM_VER);\r\nhead = FM10K_MSG_HDR_FIELD_GET(*hdr, SM_HEAD);\r\nswitch (ver) {\r\ncase 0:\r\nbreak;\r\ncase FM10K_SM_MBX_VERSION:\r\nif (!head || head > FM10K_SM_MBX_FIFO_LEN)\r\nreturn FM10K_MBX_ERR_HEAD;\r\nif (!tail || tail > FM10K_SM_MBX_FIFO_LEN)\r\nreturn FM10K_MBX_ERR_TAIL;\r\nif (mbx->tail < head)\r\nhead += mbx->mbmem_len - 1;\r\nif (tail < mbx->head)\r\ntail += mbx->mbmem_len - 1;\r\nif (fm10k_mbx_index_len(mbx, head, mbx->tail) > mbx->tail_len)\r\nreturn FM10K_MBX_ERR_HEAD;\r\nif (fm10k_mbx_index_len(mbx, mbx->head, tail) < mbx->mbmem_len)\r\nbreak;\r\nreturn FM10K_MBX_ERR_TAIL;\r\ndefault:\r\nreturn FM10K_MBX_ERR_SRC;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fm10k_sm_mbx_process_error(struct fm10k_mbx_info *mbx)\r\n{\r\nconst enum fm10k_mbx_state state = mbx->state;\r\nswitch (state) {\r\ncase FM10K_STATE_DISCONNECT:\r\nmbx->remote = 0;\r\nbreak;\r\ncase FM10K_STATE_OPEN:\r\nfm10k_sm_mbx_connect_reset(mbx);\r\nbreak;\r\ncase FM10K_STATE_CONNECT:\r\nif (mbx->remote) {\r\nwhile (mbx->local > 1)\r\nmbx->local--;\r\nmbx->remote = 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfm10k_sm_mbx_create_connect_hdr(mbx, 0);\r\n}\r\nstatic void fm10k_sm_mbx_create_error_msg(struct fm10k_mbx_info *mbx, s32 err)\r\n{\r\nswitch (err) {\r\ncase FM10K_MBX_ERR_TAIL:\r\ncase FM10K_MBX_ERR_HEAD:\r\ncase FM10K_MBX_ERR_SRC:\r\ncase FM10K_MBX_ERR_SIZE:\r\ncase FM10K_MBX_ERR_RSVD0:\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nfm10k_sm_mbx_process_error(mbx);\r\nfm10k_sm_mbx_create_connect_hdr(mbx, 1);\r\n}\r\nstatic s32 fm10k_sm_mbx_receive(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx,\r\nu16 tail)\r\n{\r\nu16 mbmem_len = mbx->mbmem_len - 1;\r\ns32 err;\r\nif (tail < mbx->head)\r\ntail += mbmem_len;\r\nerr = fm10k_mbx_push_tail(hw, mbx, tail);\r\nif (err < 0)\r\nreturn err;\r\nfm10k_mbx_dequeue_rx(hw, mbx);\r\nmbx->head = fm10k_mbx_head_sub(mbx, mbx->pushed);\r\nmbx->pushed = 0;\r\nif (mbx->head > mbmem_len)\r\nmbx->head -= mbmem_len;\r\nreturn err;\r\n}\r\nstatic void fm10k_sm_mbx_transmit(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx, u16 head)\r\n{\r\nstruct fm10k_mbx_fifo *fifo = &mbx->tx;\r\nu16 mbmem_len = mbx->mbmem_len - 1;\r\nu16 tail_len, len = 0;\r\nu32 *msg;\r\nif (mbx->tail < head)\r\nhead += mbmem_len;\r\nfm10k_mbx_pull_head(hw, mbx, head);\r\ndo {\r\nmsg = fifo->buffer + fm10k_fifo_head_offset(fifo, len);\r\ntail_len = len;\r\nlen += FM10K_TLV_DWORD_LEN(*msg);\r\n} while ((len <= mbx->tail_len) && (len < mbmem_len));\r\nif (mbx->tail_len > tail_len) {\r\nmbx->tail = fm10k_mbx_tail_sub(mbx, mbx->tail_len - tail_len);\r\nmbx->tail_len = tail_len;\r\n}\r\nif (mbx->tail > mbmem_len)\r\nmbx->tail -= mbmem_len;\r\n}\r\nstatic void fm10k_sm_mbx_create_reply(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx, u16 head)\r\n{\r\nswitch (mbx->state) {\r\ncase FM10K_STATE_OPEN:\r\ncase FM10K_STATE_DISCONNECT:\r\nfm10k_sm_mbx_transmit(hw, mbx, head);\r\nif (mbx->tail_len || (mbx->state == FM10K_STATE_OPEN)) {\r\nfm10k_sm_mbx_create_data_hdr(mbx);\r\n} else {\r\nmbx->remote = 0;\r\nfm10k_sm_mbx_create_connect_hdr(mbx, 0);\r\n}\r\nbreak;\r\ncase FM10K_STATE_CONNECT:\r\ncase FM10K_STATE_CLOSED:\r\nfm10k_sm_mbx_create_connect_hdr(mbx, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic s32 fm10k_sm_mbx_process_reset(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\ns32 err = 0;\r\nconst enum fm10k_mbx_state state = mbx->state;\r\nswitch (state) {\r\ncase FM10K_STATE_DISCONNECT:\r\nmbx->state = FM10K_STATE_CLOSED;\r\nmbx->remote = 0;\r\nmbx->local = 0;\r\nbreak;\r\ncase FM10K_STATE_OPEN:\r\nfm10k_sm_mbx_connect_reset(mbx);\r\nerr = FM10K_ERR_RESET_REQUESTED;\r\nbreak;\r\ncase FM10K_STATE_CONNECT:\r\nmbx->remote = mbx->local;\r\ndefault:\r\nbreak;\r\n}\r\nfm10k_sm_mbx_create_reply(hw, mbx, mbx->tail);\r\nreturn err;\r\n}\r\nstatic s32 fm10k_sm_mbx_process_version_1(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nconst u32 *hdr = &mbx->mbx_hdr;\r\nu16 head, tail;\r\ns32 len;\r\ntail = FM10K_MSG_HDR_FIELD_GET(*hdr, SM_TAIL);\r\nhead = FM10K_MSG_HDR_FIELD_GET(*hdr, SM_HEAD);\r\nif (mbx->state == FM10K_STATE_CONNECT) {\r\nif (!mbx->remote)\r\ngoto send_reply;\r\nif (mbx->remote != 1)\r\nreturn FM10K_MBX_ERR_SRC;\r\nmbx->state = FM10K_STATE_OPEN;\r\n}\r\ndo {\r\nlen = fm10k_sm_mbx_receive(hw, mbx, tail);\r\nif (len < 0)\r\nreturn len;\r\n} while (len);\r\nsend_reply:\r\nfm10k_sm_mbx_create_reply(hw, mbx, head);\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_sm_mbx_process(struct fm10k_hw *hw,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\ns32 err;\r\nif (mbx->state == FM10K_STATE_CLOSED)\r\nreturn 0;\r\nerr = fm10k_mbx_read(hw, mbx);\r\nif (err)\r\nreturn err;\r\nerr = fm10k_sm_mbx_validate_fifo_hdr(mbx);\r\nif (err < 0)\r\ngoto fifo_err;\r\nif (FM10K_MSG_HDR_FIELD_GET(mbx->mbx_hdr, SM_ERR)) {\r\nfm10k_sm_mbx_process_error(mbx);\r\ngoto fifo_err;\r\n}\r\nswitch (FM10K_MSG_HDR_FIELD_GET(mbx->mbx_hdr, SM_VER)) {\r\ncase 0:\r\nerr = fm10k_sm_mbx_process_reset(hw, mbx);\r\nbreak;\r\ncase FM10K_SM_MBX_VERSION:\r\nerr = fm10k_sm_mbx_process_version_1(hw, mbx);\r\nbreak;\r\n}\r\nfifo_err:\r\nif (err < 0)\r\nfm10k_sm_mbx_create_error_msg(mbx, err);\r\nfm10k_mbx_write(hw, mbx);\r\nreturn err;\r\n}\r\ns32 fm10k_sm_mbx_init(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx,\r\nconst struct fm10k_msg_data *msg_data)\r\n{\r\nmbx->mbx_reg = FM10K_GMBX;\r\nmbx->mbmem_reg = FM10K_MBMEM_PF(0);\r\nmbx->state = FM10K_STATE_CLOSED;\r\nif (fm10k_mbx_validate_handlers(msg_data))\r\nreturn FM10K_ERR_PARAM;\r\nmbx->msg_data = msg_data;\r\nmbx->timeout = 0;\r\nmbx->udelay = FM10K_MBX_INIT_DELAY;\r\nmbx->max_size = FM10K_MBX_MSG_MAX_SIZE;\r\nmbx->mbmem_len = FM10K_MBMEM_PF_XOR;\r\nfm10k_fifo_init(&mbx->tx, mbx->buffer, FM10K_MBX_TX_BUFFER_SIZE);\r\nfm10k_fifo_init(&mbx->rx, &mbx->buffer[FM10K_MBX_TX_BUFFER_SIZE],\r\nFM10K_MBX_RX_BUFFER_SIZE);\r\nmbx->ops.connect = fm10k_sm_mbx_connect;\r\nmbx->ops.disconnect = fm10k_sm_mbx_disconnect;\r\nmbx->ops.rx_ready = fm10k_mbx_rx_ready;\r\nmbx->ops.tx_ready = fm10k_mbx_tx_ready;\r\nmbx->ops.tx_complete = fm10k_mbx_tx_complete;\r\nmbx->ops.enqueue_tx = fm10k_mbx_enqueue_tx;\r\nmbx->ops.process = fm10k_sm_mbx_process;\r\nmbx->ops.register_handlers = fm10k_mbx_register_handlers;\r\nreturn 0;\r\n}
