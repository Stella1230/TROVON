static inline void opa_vnic_make_header(u8 *hdr, u32 slid, u32 dlid, u16 len,\r\nu16 pkey, u16 entropy, u8 sc, u8 rc,\r\nu8 l4_type, u16 l4_hdr)\r\n{\r\nu32 h[OPA_VNIC_HDR_QW_LEN] = {0, 0xc0000000, 0, 0, 0};\r\nh[2] = l4_type;\r\nh[3] = entropy;\r\nh[4] = l4_hdr << OPA_VNIC_L4_HDR_SHFT;\r\nh[0] |= (slid & OPA_16B_LID_MASK);\r\nh[2] |= ((slid >> (20 - OPA_16B_SLID_HIGH_SHFT)) & OPA_16B_SLID_MASK);\r\nh[1] |= (dlid & OPA_16B_LID_MASK);\r\nh[2] |= ((dlid >> (20 - OPA_16B_DLID_HIGH_SHFT)) & OPA_16B_DLID_MASK);\r\nh[0] |= (len << OPA_16B_LEN_SHFT);\r\nh[1] |= (rc << OPA_16B_RC_SHFT);\r\nh[1] |= (sc << OPA_16B_SC_SHFT);\r\nh[2] |= ((u32)pkey << OPA_16B_PKEY_SHFT);\r\nmemcpy(hdr, h, OPA_VNIC_HDR_LEN);\r\n}\r\nstatic void opa_vnic_free_mac_tbl(struct hlist_head *mactbl)\r\n{\r\nstruct opa_vnic_mac_tbl_node *node;\r\nstruct hlist_node *tmp;\r\nint bkt;\r\nif (!mactbl)\r\nreturn;\r\nvnic_hash_for_each_safe(mactbl, bkt, tmp, node, hlist) {\r\nhash_del(&node->hlist);\r\nkfree(node);\r\n}\r\nkfree(mactbl);\r\n}\r\nstatic struct hlist_head *opa_vnic_alloc_mac_tbl(void)\r\n{\r\nu32 size = sizeof(struct hlist_head) * OPA_VNIC_MAC_TBL_SIZE;\r\nstruct hlist_head *mactbl;\r\nmactbl = kzalloc(size, GFP_KERNEL);\r\nif (!mactbl)\r\nreturn ERR_PTR(-ENOMEM);\r\nvnic_hash_init(mactbl);\r\nreturn mactbl;\r\n}\r\nvoid opa_vnic_release_mac_tbl(struct opa_vnic_adapter *adapter)\r\n{\r\nstruct hlist_head *mactbl;\r\nmutex_lock(&adapter->mactbl_lock);\r\nmactbl = rcu_access_pointer(adapter->mactbl);\r\nrcu_assign_pointer(adapter->mactbl, NULL);\r\nsynchronize_rcu();\r\nopa_vnic_free_mac_tbl(mactbl);\r\nmutex_unlock(&adapter->mactbl_lock);\r\n}\r\nvoid opa_vnic_query_mac_tbl(struct opa_vnic_adapter *adapter,\r\nstruct opa_veswport_mactable *tbl)\r\n{\r\nstruct opa_vnic_mac_tbl_node *node;\r\nstruct hlist_head *mactbl;\r\nint bkt;\r\nu16 loffset, lnum_entries;\r\nrcu_read_lock();\r\nmactbl = rcu_dereference(adapter->mactbl);\r\nif (!mactbl)\r\ngoto get_mac_done;\r\nloffset = be16_to_cpu(tbl->offset);\r\nlnum_entries = be16_to_cpu(tbl->num_entries);\r\nvnic_hash_for_each(mactbl, bkt, node, hlist) {\r\nstruct __opa_vnic_mactable_entry *nentry = &node->entry;\r\nstruct opa_veswport_mactable_entry *entry;\r\nif ((node->index < loffset) ||\r\n(node->index >= (loffset + lnum_entries)))\r\ncontinue;\r\nentry = &tbl->tbl_entries[node->index - loffset];\r\nmemcpy(entry->mac_addr, nentry->mac_addr,\r\nARRAY_SIZE(entry->mac_addr));\r\nmemcpy(entry->mac_addr_mask, nentry->mac_addr_mask,\r\nARRAY_SIZE(entry->mac_addr_mask));\r\nentry->dlid_sd = cpu_to_be32(nentry->dlid_sd);\r\n}\r\ntbl->mac_tbl_digest = cpu_to_be32(adapter->info.vport.mac_tbl_digest);\r\nget_mac_done:\r\nrcu_read_unlock();\r\n}\r\nint opa_vnic_update_mac_tbl(struct opa_vnic_adapter *adapter,\r\nstruct opa_veswport_mactable *tbl)\r\n{\r\nstruct opa_vnic_mac_tbl_node *node, *new_node;\r\nstruct hlist_head *new_mactbl, *old_mactbl;\r\nint i, bkt, rc = 0;\r\nu8 key;\r\nu16 loffset, lnum_entries;\r\nmutex_lock(&adapter->mactbl_lock);\r\nnew_mactbl = opa_vnic_alloc_mac_tbl();\r\nif (IS_ERR(new_mactbl)) {\r\nmutex_unlock(&adapter->mactbl_lock);\r\nreturn PTR_ERR(new_mactbl);\r\n}\r\nloffset = be16_to_cpu(tbl->offset);\r\nlnum_entries = be16_to_cpu(tbl->num_entries);\r\nfor (i = 0; i < lnum_entries; i++) {\r\nstruct __opa_vnic_mactable_entry *nentry;\r\nstruct opa_veswport_mactable_entry *entry =\r\n&tbl->tbl_entries[i];\r\nu8 *mac_addr = entry->mac_addr;\r\nu8 empty_mac[ETH_ALEN] = { 0 };\r\nv_dbg("new mac entry %4d: %02x:%02x:%02x:%02x:%02x:%02x %x\n",\r\nloffset + i, mac_addr[0], mac_addr[1], mac_addr[2],\r\nmac_addr[3], mac_addr[4], mac_addr[5],\r\nentry->dlid_sd);\r\nif (!memcmp(mac_addr, empty_mac, ARRAY_SIZE(empty_mac)))\r\ncontinue;\r\nnode = kzalloc(sizeof(*node), GFP_KERNEL);\r\nif (!node) {\r\nrc = -ENOMEM;\r\ngoto updt_done;\r\n}\r\nnode->index = loffset + i;\r\nnentry = &node->entry;\r\nmemcpy(nentry->mac_addr, entry->mac_addr,\r\nARRAY_SIZE(nentry->mac_addr));\r\nmemcpy(nentry->mac_addr_mask, entry->mac_addr_mask,\r\nARRAY_SIZE(nentry->mac_addr_mask));\r\nnentry->dlid_sd = be32_to_cpu(entry->dlid_sd);\r\nkey = node->entry.mac_addr[OPA_VNIC_MAC_HASH_IDX];\r\nvnic_hash_add(new_mactbl, &node->hlist, key);\r\n}\r\nold_mactbl = rcu_access_pointer(adapter->mactbl);\r\nif (!old_mactbl)\r\ngoto switch_tbl;\r\nvnic_hash_for_each(old_mactbl, bkt, node, hlist) {\r\nif ((node->index >= loffset) &&\r\n(node->index < (loffset + lnum_entries)))\r\ncontinue;\r\nnew_node = kzalloc(sizeof(*new_node), GFP_KERNEL);\r\nif (!new_node) {\r\nrc = -ENOMEM;\r\ngoto updt_done;\r\n}\r\nnew_node->index = node->index;\r\nmemcpy(&new_node->entry, &node->entry, sizeof(node->entry));\r\nkey = new_node->entry.mac_addr[OPA_VNIC_MAC_HASH_IDX];\r\nvnic_hash_add(new_mactbl, &new_node->hlist, key);\r\n}\r\nswitch_tbl:\r\nrcu_assign_pointer(adapter->mactbl, new_mactbl);\r\nsynchronize_rcu();\r\nadapter->info.vport.mac_tbl_digest = be32_to_cpu(tbl->mac_tbl_digest);\r\nupdt_done:\r\nif (rc)\r\nopa_vnic_free_mac_tbl(new_mactbl);\r\nelse\r\nopa_vnic_free_mac_tbl(old_mactbl);\r\nmutex_unlock(&adapter->mactbl_lock);\r\nreturn rc;\r\n}\r\nstatic uint32_t opa_vnic_chk_mac_tbl(struct opa_vnic_adapter *adapter,\r\nstruct ethhdr *mac_hdr)\r\n{\r\nstruct opa_vnic_mac_tbl_node *node;\r\nstruct hlist_head *mactbl;\r\nu32 dlid = 0;\r\nu8 key;\r\nrcu_read_lock();\r\nmactbl = rcu_dereference(adapter->mactbl);\r\nif (unlikely(!mactbl))\r\ngoto chk_done;\r\nkey = mac_hdr->h_dest[OPA_VNIC_MAC_HASH_IDX];\r\nvnic_hash_for_each_possible(mactbl, node, hlist, key) {\r\nstruct __opa_vnic_mactable_entry *entry = &node->entry;\r\nif (unlikely(OPA_VNIC_DLID_SD_IS_SRC_MAC(entry->dlid_sd)))\r\ncontinue;\r\nif (!memcmp(node->entry.mac_addr, mac_hdr->h_dest,\r\nARRAY_SIZE(node->entry.mac_addr))) {\r\ndlid = OPA_VNIC_DLID_SD_GET_DLID(node->entry.dlid_sd);\r\nbreak;\r\n}\r\n}\r\nchk_done:\r\nrcu_read_unlock();\r\nreturn dlid;\r\n}\r\nstatic uint32_t opa_vnic_get_dlid(struct opa_vnic_adapter *adapter,\r\nstruct sk_buff *skb, u8 def_port)\r\n{\r\nstruct __opa_veswport_info *info = &adapter->info;\r\nstruct ethhdr *mac_hdr = (struct ethhdr *)skb_mac_header(skb);\r\nu32 dlid;\r\ndlid = opa_vnic_chk_mac_tbl(adapter, mac_hdr);\r\nif (dlid)\r\nreturn dlid;\r\nif (is_multicast_ether_addr(mac_hdr->h_dest)) {\r\ndlid = info->vesw.u_mcast_dlid;\r\n} else {\r\nif (is_local_ether_addr(mac_hdr->h_dest)) {\r\ndlid = ((uint32_t)mac_hdr->h_dest[5] << 16) |\r\n((uint32_t)mac_hdr->h_dest[4] << 8) |\r\nmac_hdr->h_dest[3];\r\nif (unlikely(!dlid))\r\nv_warn("Null dlid in MAC address\n");\r\n} else if (def_port != OPA_VNIC_INVALID_PORT) {\r\ndlid = info->vesw.u_ucast_dlid[def_port];\r\n}\r\n}\r\nreturn dlid;\r\n}\r\nstatic u8 opa_vnic_get_sc(struct __opa_veswport_info *info,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ethhdr *mac_hdr = (struct ethhdr *)skb_mac_header(skb);\r\nu16 vlan_tci;\r\nu8 sc;\r\nif (!__vlan_get_tag(skb, &vlan_tci)) {\r\nu8 pcp = OPA_VNIC_VLAN_PCP(vlan_tci);\r\nif (is_multicast_ether_addr(mac_hdr->h_dest))\r\nsc = info->vport.pcp_to_sc_mc[pcp];\r\nelse\r\nsc = info->vport.pcp_to_sc_uc[pcp];\r\n} else {\r\nif (is_multicast_ether_addr(mac_hdr->h_dest))\r\nsc = info->vport.non_vlan_sc_mc;\r\nelse\r\nsc = info->vport.non_vlan_sc_uc;\r\n}\r\nreturn sc;\r\n}\r\nu8 opa_vnic_get_vl(struct opa_vnic_adapter *adapter, struct sk_buff *skb)\r\n{\r\nstruct ethhdr *mac_hdr = (struct ethhdr *)skb_mac_header(skb);\r\nstruct __opa_veswport_info *info = &adapter->info;\r\nu8 vl;\r\nif (skb_vlan_tag_present(skb)) {\r\nu8 pcp = skb_vlan_tag_get(skb) >> VLAN_PRIO_SHIFT;\r\nif (is_multicast_ether_addr(mac_hdr->h_dest))\r\nvl = info->vport.pcp_to_vl_mc[pcp];\r\nelse\r\nvl = info->vport.pcp_to_vl_uc[pcp];\r\n} else {\r\nif (is_multicast_ether_addr(mac_hdr->h_dest))\r\nvl = info->vport.non_vlan_vl_mc;\r\nelse\r\nvl = info->vport.non_vlan_vl_uc;\r\n}\r\nreturn vl;\r\n}\r\nu8 opa_vnic_calc_entropy(struct opa_vnic_adapter *adapter, struct sk_buff *skb)\r\n{\r\nu16 hash16;\r\nhash16 = __skb_tx_hash(adapter->netdev, skb, BIT(15));\r\nreturn (u8)((hash16 >> 8) ^ (hash16 & 0xff));\r\n}\r\nstatic inline u8 opa_vnic_get_def_port(struct opa_vnic_adapter *adapter,\r\nu8 entropy)\r\n{\r\nu8 flow_id;\r\nflow_id = ((entropy & 0xf) + (entropy >> 4));\r\nreturn adapter->flow_tbl[flow_id & (OPA_VNIC_FLOW_TBL_SIZE - 1)];\r\n}\r\nstatic inline int opa_vnic_wire_length(struct sk_buff *skb)\r\n{\r\nu32 pad_len;\r\npad_len = -(skb->len + OPA_VNIC_ICRC_TAIL_LEN) & 0x7;\r\npad_len += OPA_VNIC_ICRC_TAIL_LEN;\r\nreturn (skb->len + pad_len) >> 3;\r\n}\r\nvoid opa_vnic_encap_skb(struct opa_vnic_adapter *adapter, struct sk_buff *skb)\r\n{\r\nstruct __opa_veswport_info *info = &adapter->info;\r\nstruct opa_vnic_skb_mdata *mdata;\r\nu8 def_port, sc, entropy, *hdr;\r\nu16 len, l4_hdr;\r\nu32 dlid;\r\nhdr = skb_push(skb, OPA_VNIC_HDR_LEN);\r\nentropy = opa_vnic_calc_entropy(adapter, skb);\r\ndef_port = opa_vnic_get_def_port(adapter, entropy);\r\nlen = opa_vnic_wire_length(skb);\r\ndlid = opa_vnic_get_dlid(adapter, skb, def_port);\r\nsc = opa_vnic_get_sc(info, skb);\r\nl4_hdr = info->vesw.vesw_id;\r\nmdata = skb_push(skb, sizeof(*mdata));\r\nmdata->vl = opa_vnic_get_vl(adapter, skb);\r\nmdata->entropy = entropy;\r\nmdata->flags = 0;\r\nif (unlikely(!dlid)) {\r\nmdata->flags = OPA_VNIC_SKB_MDATA_ENCAP_ERR;\r\nreturn;\r\n}\r\nopa_vnic_make_header(hdr, info->vport.encap_slid, dlid, len,\r\ninfo->vesw.pkey, entropy, sc, 0,\r\nOPA_VNIC_L4_ETHR, l4_hdr);\r\n}
