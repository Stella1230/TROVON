static int ctrl_set_rational(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nstruct mmal_parameter_rational rational_value;\r\nstruct vchiq_mmal_port *control;\r\ncontrol = &dev->component[MMAL_COMPONENT_CAMERA]->control;\r\nrational_value.num = ctrl->val;\r\nrational_value.den = 100;\r\nreturn vchiq_mmal_port_parameter_set(dev->instance, control,\r\nmmal_ctrl->mmal_id,\r\n&rational_value,\r\nsizeof(rational_value));\r\n}\r\nstatic int ctrl_set_value(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nu32 u32_value;\r\nstruct vchiq_mmal_port *control;\r\ncontrol = &dev->component[MMAL_COMPONENT_CAMERA]->control;\r\nu32_value = ctrl->val;\r\nreturn vchiq_mmal_port_parameter_set(dev->instance, control,\r\nmmal_ctrl->mmal_id,\r\n&u32_value, sizeof(u32_value));\r\n}\r\nstatic int ctrl_set_iso(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nu32 u32_value;\r\nstruct vchiq_mmal_port *control;\r\nif (ctrl->val > mmal_ctrl->max || ctrl->val < mmal_ctrl->min)\r\nreturn 1;\r\nif (ctrl->id == V4L2_CID_ISO_SENSITIVITY)\r\ndev->iso = iso_values[ctrl->val];\r\nelse if (ctrl->id == V4L2_CID_ISO_SENSITIVITY_AUTO)\r\ndev->manual_iso_enabled =\r\n(ctrl->val == V4L2_ISO_SENSITIVITY_MANUAL);\r\ncontrol = &dev->component[MMAL_COMPONENT_CAMERA]->control;\r\nif (dev->manual_iso_enabled)\r\nu32_value = dev->iso;\r\nelse\r\nu32_value = 0;\r\nreturn vchiq_mmal_port_parameter_set(dev->instance, control,\r\nMMAL_PARAMETER_ISO,\r\n&u32_value, sizeof(u32_value));\r\n}\r\nstatic int ctrl_set_value_ev(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\ns32 s32_value;\r\nstruct vchiq_mmal_port *control;\r\ncontrol = &dev->component[MMAL_COMPONENT_CAMERA]->control;\r\ns32_value = (ctrl->val - 12) * 2;\r\nreturn vchiq_mmal_port_parameter_set(dev->instance, control,\r\nmmal_ctrl->mmal_id,\r\n&s32_value, sizeof(s32_value));\r\n}\r\nstatic int ctrl_set_rotate(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nint ret;\r\nu32 u32_value;\r\nstruct vchiq_mmal_component *camera;\r\ncamera = dev->component[MMAL_COMPONENT_CAMERA];\r\nu32_value = ((ctrl->val % 360) / 90) * 90;\r\nret = vchiq_mmal_port_parameter_set(dev->instance, &camera->output[0],\r\nmmal_ctrl->mmal_id,\r\n&u32_value, sizeof(u32_value));\r\nif (ret < 0)\r\nreturn ret;\r\nret = vchiq_mmal_port_parameter_set(dev->instance, &camera->output[1],\r\nmmal_ctrl->mmal_id,\r\n&u32_value, sizeof(u32_value));\r\nif (ret < 0)\r\nreturn ret;\r\nret = vchiq_mmal_port_parameter_set(dev->instance, &camera->output[2],\r\nmmal_ctrl->mmal_id,\r\n&u32_value, sizeof(u32_value));\r\nreturn ret;\r\n}\r\nstatic int ctrl_set_flip(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nint ret;\r\nu32 u32_value;\r\nstruct vchiq_mmal_component *camera;\r\nif (ctrl->id == V4L2_CID_HFLIP)\r\ndev->hflip = ctrl->val;\r\nelse\r\ndev->vflip = ctrl->val;\r\ncamera = dev->component[MMAL_COMPONENT_CAMERA];\r\nif (dev->hflip && dev->vflip)\r\nu32_value = MMAL_PARAM_MIRROR_BOTH;\r\nelse if (dev->hflip)\r\nu32_value = MMAL_PARAM_MIRROR_HORIZONTAL;\r\nelse if (dev->vflip)\r\nu32_value = MMAL_PARAM_MIRROR_VERTICAL;\r\nelse\r\nu32_value = MMAL_PARAM_MIRROR_NONE;\r\nret = vchiq_mmal_port_parameter_set(dev->instance, &camera->output[0],\r\nmmal_ctrl->mmal_id,\r\n&u32_value, sizeof(u32_value));\r\nif (ret < 0)\r\nreturn ret;\r\nret = vchiq_mmal_port_parameter_set(dev->instance, &camera->output[1],\r\nmmal_ctrl->mmal_id,\r\n&u32_value, sizeof(u32_value));\r\nif (ret < 0)\r\nreturn ret;\r\nret = vchiq_mmal_port_parameter_set(dev->instance, &camera->output[2],\r\nmmal_ctrl->mmal_id,\r\n&u32_value, sizeof(u32_value));\r\nreturn ret;\r\n}\r\nstatic int ctrl_set_exposure(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nenum mmal_parameter_exposuremode exp_mode = dev->exposure_mode_user;\r\nu32 shutter_speed = 0;\r\nstruct vchiq_mmal_port *control;\r\nint ret = 0;\r\ncontrol = &dev->component[MMAL_COMPONENT_CAMERA]->control;\r\nif (mmal_ctrl->mmal_id == MMAL_PARAMETER_SHUTTER_SPEED) {\r\ndev->manual_shutter_speed = ctrl->val * 100;\r\n} else if (mmal_ctrl->mmal_id == MMAL_PARAMETER_EXPOSURE_MODE) {\r\nswitch (ctrl->val) {\r\ncase V4L2_EXPOSURE_AUTO:\r\nexp_mode = MMAL_PARAM_EXPOSUREMODE_AUTO;\r\nbreak;\r\ncase V4L2_EXPOSURE_MANUAL:\r\nexp_mode = MMAL_PARAM_EXPOSUREMODE_OFF;\r\nbreak;\r\n}\r\ndev->exposure_mode_user = exp_mode;\r\ndev->exposure_mode_v4l2_user = ctrl->val;\r\n} else if (mmal_ctrl->id == V4L2_CID_EXPOSURE_AUTO_PRIORITY) {\r\ndev->exp_auto_priority = ctrl->val;\r\n}\r\nif (dev->scene_mode == V4L2_SCENE_MODE_NONE) {\r\nif (exp_mode == MMAL_PARAM_EXPOSUREMODE_OFF)\r\nshutter_speed = dev->manual_shutter_speed;\r\nret = vchiq_mmal_port_parameter_set(dev->instance,\r\ncontrol,\r\nMMAL_PARAMETER_SHUTTER_SPEED,\r\n&shutter_speed,\r\nsizeof(shutter_speed));\r\nret += vchiq_mmal_port_parameter_set(dev->instance,\r\ncontrol,\r\nMMAL_PARAMETER_EXPOSURE_MODE,\r\n&exp_mode,\r\nsizeof(u32));\r\ndev->exposure_mode_active = exp_mode;\r\n}\r\nret += set_framerate_params(dev);\r\nreturn ret;\r\n}\r\nstatic int ctrl_set_metering_mode(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nswitch (ctrl->val) {\r\ncase V4L2_EXPOSURE_METERING_AVERAGE:\r\ndev->metering_mode = MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE;\r\nbreak;\r\ncase V4L2_EXPOSURE_METERING_CENTER_WEIGHTED:\r\ndev->metering_mode = MMAL_PARAM_EXPOSUREMETERINGMODE_BACKLIT;\r\nbreak;\r\ncase V4L2_EXPOSURE_METERING_SPOT:\r\ndev->metering_mode = MMAL_PARAM_EXPOSUREMETERINGMODE_SPOT;\r\nbreak;\r\n}\r\nif (dev->scene_mode == V4L2_SCENE_MODE_NONE) {\r\nstruct vchiq_mmal_port *control;\r\nu32 u32_value = dev->metering_mode;\r\ncontrol = &dev->component[MMAL_COMPONENT_CAMERA]->control;\r\nreturn vchiq_mmal_port_parameter_set(dev->instance, control,\r\nmmal_ctrl->mmal_id,\r\n&u32_value, sizeof(u32_value));\r\n} else\r\nreturn 0;\r\n}\r\nstatic int ctrl_set_flicker_avoidance(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nu32 u32_value;\r\nstruct vchiq_mmal_port *control;\r\ncontrol = &dev->component[MMAL_COMPONENT_CAMERA]->control;\r\nswitch (ctrl->val) {\r\ncase V4L2_CID_POWER_LINE_FREQUENCY_DISABLED:\r\nu32_value = MMAL_PARAM_FLICKERAVOID_OFF;\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY_50HZ:\r\nu32_value = MMAL_PARAM_FLICKERAVOID_50HZ;\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY_60HZ:\r\nu32_value = MMAL_PARAM_FLICKERAVOID_60HZ;\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY_AUTO:\r\nu32_value = MMAL_PARAM_FLICKERAVOID_AUTO;\r\nbreak;\r\n}\r\nreturn vchiq_mmal_port_parameter_set(dev->instance, control,\r\nmmal_ctrl->mmal_id,\r\n&u32_value, sizeof(u32_value));\r\n}\r\nstatic int ctrl_set_awb_mode(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nu32 u32_value;\r\nstruct vchiq_mmal_port *control;\r\ncontrol = &dev->component[MMAL_COMPONENT_CAMERA]->control;\r\nswitch (ctrl->val) {\r\ncase V4L2_WHITE_BALANCE_MANUAL:\r\nu32_value = MMAL_PARAM_AWBMODE_OFF;\r\nbreak;\r\ncase V4L2_WHITE_BALANCE_AUTO:\r\nu32_value = MMAL_PARAM_AWBMODE_AUTO;\r\nbreak;\r\ncase V4L2_WHITE_BALANCE_INCANDESCENT:\r\nu32_value = MMAL_PARAM_AWBMODE_INCANDESCENT;\r\nbreak;\r\ncase V4L2_WHITE_BALANCE_FLUORESCENT:\r\nu32_value = MMAL_PARAM_AWBMODE_FLUORESCENT;\r\nbreak;\r\ncase V4L2_WHITE_BALANCE_FLUORESCENT_H:\r\nu32_value = MMAL_PARAM_AWBMODE_TUNGSTEN;\r\nbreak;\r\ncase V4L2_WHITE_BALANCE_HORIZON:\r\nu32_value = MMAL_PARAM_AWBMODE_HORIZON;\r\nbreak;\r\ncase V4L2_WHITE_BALANCE_DAYLIGHT:\r\nu32_value = MMAL_PARAM_AWBMODE_SUNLIGHT;\r\nbreak;\r\ncase V4L2_WHITE_BALANCE_FLASH:\r\nu32_value = MMAL_PARAM_AWBMODE_FLASH;\r\nbreak;\r\ncase V4L2_WHITE_BALANCE_CLOUDY:\r\nu32_value = MMAL_PARAM_AWBMODE_CLOUDY;\r\nbreak;\r\ncase V4L2_WHITE_BALANCE_SHADE:\r\nu32_value = MMAL_PARAM_AWBMODE_SHADE;\r\nbreak;\r\n}\r\nreturn vchiq_mmal_port_parameter_set(dev->instance, control,\r\nmmal_ctrl->mmal_id,\r\n&u32_value, sizeof(u32_value));\r\n}\r\nstatic int ctrl_set_awb_gains(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nstruct vchiq_mmal_port *control;\r\nstruct mmal_parameter_awbgains gains;\r\ncontrol = &dev->component[MMAL_COMPONENT_CAMERA]->control;\r\nif (ctrl->id == V4L2_CID_RED_BALANCE)\r\ndev->red_gain = ctrl->val;\r\nelse if (ctrl->id == V4L2_CID_BLUE_BALANCE)\r\ndev->blue_gain = ctrl->val;\r\ngains.r_gain.num = dev->red_gain;\r\ngains.b_gain.num = dev->blue_gain;\r\ngains.r_gain.den = gains.b_gain.den = 1000;\r\nreturn vchiq_mmal_port_parameter_set(dev->instance, control,\r\nmmal_ctrl->mmal_id,\r\n&gains, sizeof(gains));\r\n}\r\nstatic int ctrl_set_image_effect(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nint ret = -EINVAL;\r\nint i, j;\r\nstruct vchiq_mmal_port *control;\r\nstruct mmal_parameter_imagefx_parameters imagefx;\r\nfor (i = 0; i < ARRAY_SIZE(v4l2_to_mmal_effects_values); i++) {\r\nif (ctrl->val == v4l2_to_mmal_effects_values[i].v4l2_effect) {\r\nimagefx.effect =\r\nv4l2_to_mmal_effects_values[i].mmal_effect;\r\nimagefx.num_effect_params =\r\nv4l2_to_mmal_effects_values[i].num_effect_params;\r\nif (imagefx.num_effect_params > MMAL_MAX_IMAGEFX_PARAMETERS)\r\nimagefx.num_effect_params = MMAL_MAX_IMAGEFX_PARAMETERS;\r\nfor (j = 0; j < imagefx.num_effect_params; j++)\r\nimagefx.effect_parameter[j] =\r\nv4l2_to_mmal_effects_values[i].effect_params[j];\r\ndev->colourfx.enable =\r\nv4l2_to_mmal_effects_values[i].col_fx_enable;\r\nif (!v4l2_to_mmal_effects_values[i].col_fx_fixed_cbcr) {\r\ndev->colourfx.u =\r\nv4l2_to_mmal_effects_values[i].u;\r\ndev->colourfx.v =\r\nv4l2_to_mmal_effects_values[i].v;\r\n}\r\ncontrol = &dev->component[MMAL_COMPONENT_CAMERA]->control;\r\nret = vchiq_mmal_port_parameter_set(\r\ndev->instance, control,\r\nMMAL_PARAMETER_IMAGE_EFFECT_PARAMETERS,\r\n&imagefx, sizeof(imagefx));\r\nif (ret)\r\ngoto exit;\r\nret = vchiq_mmal_port_parameter_set(\r\ndev->instance, control,\r\nMMAL_PARAMETER_COLOUR_EFFECT,\r\n&dev->colourfx, sizeof(dev->colourfx));\r\n}\r\n}\r\nexit:\r\nv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\r\n"mmal_ctrl:%p ctrl id:0x%x ctrl val:%d imagefx:0x%x color_effect:%s u:%d v:%d ret %d(%d)\n",\r\nmmal_ctrl, ctrl->id, ctrl->val, imagefx.effect,\r\ndev->colourfx.enable ? "true" : "false",\r\ndev->colourfx.u, dev->colourfx.v,\r\nret, (ret == 0 ? 0 : -EINVAL));\r\nreturn (ret == 0 ? 0 : EINVAL);\r\n}\r\nstatic int ctrl_set_colfx(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nint ret = -EINVAL;\r\nstruct vchiq_mmal_port *control;\r\ncontrol = &dev->component[MMAL_COMPONENT_CAMERA]->control;\r\ndev->colourfx.enable = (ctrl->val & 0xff00) >> 8;\r\ndev->colourfx.enable = ctrl->val & 0xff;\r\nret = vchiq_mmal_port_parameter_set(dev->instance, control,\r\nMMAL_PARAMETER_COLOUR_EFFECT,\r\n&dev->colourfx,\r\nsizeof(dev->colourfx));\r\nv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\r\n"%s: After: mmal_ctrl:%p ctrl id:0x%x ctrl val:%d ret %d(%d)\n",\r\n__func__, mmal_ctrl, ctrl->id, ctrl->val, ret,\r\n(ret == 0 ? 0 : -EINVAL));\r\nreturn (ret == 0 ? 0 : EINVAL);\r\n}\r\nstatic int ctrl_set_bitrate(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nint ret;\r\nstruct vchiq_mmal_port *encoder_out;\r\ndev->capture.encode_bitrate = ctrl->val;\r\nencoder_out = &dev->component[MMAL_COMPONENT_VIDEO_ENCODE]->output[0];\r\nret = vchiq_mmal_port_parameter_set(dev->instance, encoder_out,\r\nmmal_ctrl->mmal_id,\r\n&ctrl->val, sizeof(ctrl->val));\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int ctrl_set_bitrate_mode(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nu32 bitrate_mode;\r\nstruct vchiq_mmal_port *encoder_out;\r\nencoder_out = &dev->component[MMAL_COMPONENT_VIDEO_ENCODE]->output[0];\r\ndev->capture.encode_bitrate_mode = ctrl->val;\r\nswitch (ctrl->val) {\r\ndefault:\r\ncase V4L2_MPEG_VIDEO_BITRATE_MODE_VBR:\r\nbitrate_mode = MMAL_VIDEO_RATECONTROL_VARIABLE;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_BITRATE_MODE_CBR:\r\nbitrate_mode = MMAL_VIDEO_RATECONTROL_CONSTANT;\r\nbreak;\r\n}\r\nvchiq_mmal_port_parameter_set(dev->instance, encoder_out,\r\nmmal_ctrl->mmal_id,\r\n&bitrate_mode,\r\nsizeof(bitrate_mode));\r\nreturn 0;\r\n}\r\nstatic int ctrl_set_image_encode_output(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nu32 u32_value;\r\nstruct vchiq_mmal_port *jpeg_out;\r\njpeg_out = &dev->component[MMAL_COMPONENT_IMAGE_ENCODE]->output[0];\r\nu32_value = ctrl->val;\r\nreturn vchiq_mmal_port_parameter_set(dev->instance, jpeg_out,\r\nmmal_ctrl->mmal_id,\r\n&u32_value, sizeof(u32_value));\r\n}\r\nstatic int ctrl_set_video_encode_param_output(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nu32 u32_value;\r\nstruct vchiq_mmal_port *vid_enc_ctl;\r\nvid_enc_ctl = &dev->component[MMAL_COMPONENT_VIDEO_ENCODE]->output[0];\r\nu32_value = ctrl->val;\r\nreturn vchiq_mmal_port_parameter_set(dev->instance, vid_enc_ctl,\r\nmmal_ctrl->mmal_id,\r\n&u32_value, sizeof(u32_value));\r\n}\r\nstatic int ctrl_set_video_encode_profile_level(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nstruct mmal_parameter_video_profile param;\r\nint ret = 0;\r\nif (ctrl->id == V4L2_CID_MPEG_VIDEO_H264_PROFILE) {\r\nswitch (ctrl->val) {\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE:\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_MAIN:\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_HIGH:\r\ndev->capture.enc_profile = ctrl->val;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n} else if (ctrl->id == V4L2_CID_MPEG_VIDEO_H264_LEVEL) {\r\nswitch (ctrl->val) {\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_1_0:\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_1B:\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_1_1:\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_1_2:\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_1_3:\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_2_0:\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_2_1:\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_2_2:\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_3_0:\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_3_1:\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_3_2:\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_4_0:\r\ndev->capture.enc_level = ctrl->val;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nif (!ret) {\r\nswitch (dev->capture.enc_profile) {\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:\r\nparam.profile = MMAL_VIDEO_PROFILE_H264_BASELINE;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE:\r\nparam.profile =\r\nMMAL_VIDEO_PROFILE_H264_CONSTRAINED_BASELINE;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_MAIN:\r\nparam.profile = MMAL_VIDEO_PROFILE_H264_MAIN;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_HIGH:\r\nparam.profile = MMAL_VIDEO_PROFILE_H264_HIGH;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (dev->capture.enc_level) {\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_1_0:\r\nparam.level = MMAL_VIDEO_LEVEL_H264_1;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_1B:\r\nparam.level = MMAL_VIDEO_LEVEL_H264_1b;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_1_1:\r\nparam.level = MMAL_VIDEO_LEVEL_H264_11;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_1_2:\r\nparam.level = MMAL_VIDEO_LEVEL_H264_12;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_1_3:\r\nparam.level = MMAL_VIDEO_LEVEL_H264_13;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_2_0:\r\nparam.level = MMAL_VIDEO_LEVEL_H264_2;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_2_1:\r\nparam.level = MMAL_VIDEO_LEVEL_H264_21;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_2_2:\r\nparam.level = MMAL_VIDEO_LEVEL_H264_22;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_3_0:\r\nparam.level = MMAL_VIDEO_LEVEL_H264_3;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_3_1:\r\nparam.level = MMAL_VIDEO_LEVEL_H264_31;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_3_2:\r\nparam.level = MMAL_VIDEO_LEVEL_H264_32;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_4_0:\r\nparam.level = MMAL_VIDEO_LEVEL_H264_4;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret = vchiq_mmal_port_parameter_set(dev->instance,\r\n&dev->component[MMAL_COMPONENT_VIDEO_ENCODE]->output[0],\r\nmmal_ctrl->mmal_id,\r\n&param, sizeof(param));\r\n}\r\nreturn ret;\r\n}\r\nstatic int ctrl_set_scene_mode(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl *ctrl,\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl)\r\n{\r\nint ret = 0;\r\nint shutter_speed;\r\nstruct vchiq_mmal_port *control;\r\nv4l2_dbg(0, bcm2835_v4l2_debug, &dev->v4l2_dev,\r\n"scene mode selected %d, was %d\n", ctrl->val,\r\ndev->scene_mode);\r\ncontrol = &dev->component[MMAL_COMPONENT_CAMERA]->control;\r\nif (ctrl->val == dev->scene_mode)\r\nreturn 0;\r\nif (ctrl->val == V4L2_SCENE_MODE_NONE) {\r\ndev->scene_mode = V4L2_SCENE_MODE_NONE;\r\nif (dev->exposure_mode_user == MMAL_PARAM_EXPOSUREMODE_OFF)\r\nshutter_speed = dev->manual_shutter_speed;\r\nelse\r\nshutter_speed = 0;\r\nv4l2_dbg(0, bcm2835_v4l2_debug, &dev->v4l2_dev,\r\n"%s: scene mode none: shut_speed %d, exp_mode %d, metering %d\n",\r\n__func__, shutter_speed, dev->exposure_mode_user,\r\ndev->metering_mode);\r\nret = vchiq_mmal_port_parameter_set(dev->instance,\r\ncontrol,\r\nMMAL_PARAMETER_SHUTTER_SPEED,\r\n&shutter_speed,\r\nsizeof(shutter_speed));\r\nret += vchiq_mmal_port_parameter_set(dev->instance,\r\ncontrol,\r\nMMAL_PARAMETER_EXPOSURE_MODE,\r\n&dev->exposure_mode_user,\r\nsizeof(u32));\r\ndev->exposure_mode_active = dev->exposure_mode_user;\r\nret += vchiq_mmal_port_parameter_set(dev->instance,\r\ncontrol,\r\nMMAL_PARAMETER_EXP_METERING_MODE,\r\n&dev->metering_mode,\r\nsizeof(u32));\r\nret += set_framerate_params(dev);\r\n} else {\r\nint i;\r\nconst struct v4l2_mmal_scene_config *scene = NULL;\r\nint shutter_speed;\r\nenum mmal_parameter_exposuremode exposure_mode;\r\nenum mmal_parameter_exposuremeteringmode metering_mode;\r\nfor (i = 0; i < ARRAY_SIZE(scene_configs); i++) {\r\nif (scene_configs[i].v4l2_scene ==\r\nctrl->val) {\r\nscene = &scene_configs[i];\r\nbreak;\r\n}\r\n}\r\nif (!scene)\r\nreturn -EINVAL;\r\nif (i >= ARRAY_SIZE(scene_configs))\r\nreturn -EINVAL;\r\ndev->scene_mode = ctrl->val;\r\nif (scene->exposure_mode == MMAL_PARAM_EXPOSUREMODE_OFF)\r\nshutter_speed = dev->manual_shutter_speed;\r\nelse\r\nshutter_speed = 0;\r\nexposure_mode = scene->exposure_mode;\r\nmetering_mode = scene->metering_mode;\r\nv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\r\n"%s: scene mode none: shut_speed %d, exp_mode %d, metering %d\n",\r\n__func__, shutter_speed, exposure_mode, metering_mode);\r\nret = vchiq_mmal_port_parameter_set(dev->instance, control,\r\nMMAL_PARAMETER_SHUTTER_SPEED,\r\n&shutter_speed,\r\nsizeof(shutter_speed));\r\nret += vchiq_mmal_port_parameter_set(dev->instance, control,\r\nMMAL_PARAMETER_EXPOSURE_MODE,\r\n&exposure_mode,\r\nsizeof(u32));\r\ndev->exposure_mode_active = exposure_mode;\r\nret += vchiq_mmal_port_parameter_set(dev->instance, control,\r\nMMAL_PARAMETER_EXPOSURE_MODE,\r\n&exposure_mode,\r\nsizeof(u32));\r\nret += vchiq_mmal_port_parameter_set(dev->instance, control,\r\nMMAL_PARAMETER_EXP_METERING_MODE,\r\n&metering_mode,\r\nsizeof(u32));\r\nret += set_framerate_params(dev);\r\n}\r\nif (ret) {\r\nv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\r\n"%s: Setting scene to %d, ret=%d\n",\r\n__func__, ctrl->val, ret);\r\nret = -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bm2835_mmal_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct bm2835_mmal_dev *dev =\r\ncontainer_of(ctrl->handler, struct bm2835_mmal_dev,\r\nctrl_handler);\r\nconst struct bm2835_mmal_v4l2_ctrl *mmal_ctrl = ctrl->priv;\r\nint ret;\r\nif (!mmal_ctrl || mmal_ctrl->id != ctrl->id || !mmal_ctrl->setter) {\r\npr_warn("mmal_ctrl:%p ctrl id:%d\n", mmal_ctrl, ctrl->id);\r\nreturn -EINVAL;\r\n}\r\nret = mmal_ctrl->setter(dev, ctrl, mmal_ctrl);\r\nif (ret)\r\npr_warn("ctrl id:%d/MMAL param %08X- returned ret %d\n",\r\nctrl->id, mmal_ctrl->mmal_id, ret);\r\nif (mmal_ctrl->ignore_errors)\r\nret = 0;\r\nreturn ret;\r\n}\r\nint bm2835_mmal_set_all_camera_controls(struct bm2835_mmal_dev *dev)\r\n{\r\nint c;\r\nint ret = 0;\r\nfor (c = 0; c < V4L2_CTRL_COUNT; c++) {\r\nif ((dev->ctrls[c]) && (v4l2_ctrls[c].setter)) {\r\nret = v4l2_ctrls[c].setter(dev, dev->ctrls[c],\r\n&v4l2_ctrls[c]);\r\nif (!v4l2_ctrls[c].ignore_errors && ret) {\r\nv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\r\n"Failed when setting default values for ctrl %d\n",\r\nc);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint set_framerate_params(struct bm2835_mmal_dev *dev)\r\n{\r\nstruct mmal_parameter_fps_range fps_range;\r\nint ret;\r\nif ((dev->exposure_mode_active != MMAL_PARAM_EXPOSUREMODE_OFF) &&\r\n(dev->exp_auto_priority)) {\r\nfps_range.fps_low.num = 1;\r\nfps_range.fps_low.den = 1;\r\nfps_range.fps_high.num = dev->capture.timeperframe.denominator;\r\nfps_range.fps_high.den = dev->capture.timeperframe.numerator;\r\n} else {\r\nfps_range.fps_low.num = fps_range.fps_high.num =\r\ndev->capture.timeperframe.denominator;\r\nfps_range.fps_low.den = fps_range.fps_high.den =\r\ndev->capture.timeperframe.numerator;\r\n}\r\nv4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,\r\n"Set fps range to %d/%d to %d/%d\n",\r\nfps_range.fps_low.num,\r\nfps_range.fps_low.den,\r\nfps_range.fps_high.num,\r\nfps_range.fps_high.den);\r\nret = vchiq_mmal_port_parameter_set(dev->instance,\r\n&dev->component[MMAL_COMPONENT_CAMERA]->\r\noutput[MMAL_CAMERA_PORT_PREVIEW],\r\nMMAL_PARAMETER_FPS_RANGE,\r\n&fps_range, sizeof(fps_range));\r\nret += vchiq_mmal_port_parameter_set(dev->instance,\r\n&dev->component[MMAL_COMPONENT_CAMERA]->\r\noutput[MMAL_CAMERA_PORT_VIDEO],\r\nMMAL_PARAMETER_FPS_RANGE,\r\n&fps_range, sizeof(fps_range));\r\nret += vchiq_mmal_port_parameter_set(dev->instance,\r\n&dev->component[MMAL_COMPONENT_CAMERA]->\r\noutput[MMAL_CAMERA_PORT_CAPTURE],\r\nMMAL_PARAMETER_FPS_RANGE,\r\n&fps_range, sizeof(fps_range));\r\nif (ret)\r\nv4l2_dbg(0, bcm2835_v4l2_debug, &dev->v4l2_dev,\r\n"Failed to set fps ret %d\n", ret);\r\nreturn ret;\r\n}\r\nint bm2835_mmal_init_controls(struct bm2835_mmal_dev *dev,\r\nstruct v4l2_ctrl_handler *hdl)\r\n{\r\nint c;\r\nconst struct bm2835_mmal_v4l2_ctrl *ctrl;\r\nv4l2_ctrl_handler_init(hdl, V4L2_CTRL_COUNT);\r\nfor (c = 0; c < V4L2_CTRL_COUNT; c++) {\r\nctrl = &v4l2_ctrls[c];\r\nswitch (ctrl->type) {\r\ncase MMAL_CONTROL_TYPE_STD:\r\ndev->ctrls[c] = v4l2_ctrl_new_std(hdl,\r\n&bm2835_mmal_ctrl_ops, ctrl->id,\r\nctrl->min, ctrl->max, ctrl->step, ctrl->def);\r\nbreak;\r\ncase MMAL_CONTROL_TYPE_STD_MENU:\r\n{\r\nint mask = ctrl->min;\r\nif (ctrl->id == V4L2_CID_SCENE_MODE) {\r\nint i;\r\nmask = 1 << V4L2_SCENE_MODE_NONE;\r\nfor (i = 0;\r\ni < ARRAY_SIZE(scene_configs);\r\ni++) {\r\nmask |= 1 << scene_configs[i].v4l2_scene;\r\n}\r\nmask = ~mask;\r\n}\r\ndev->ctrls[c] = v4l2_ctrl_new_std_menu(hdl,\r\n&bm2835_mmal_ctrl_ops, ctrl->id,\r\nctrl->max, mask, ctrl->def);\r\nbreak;\r\n}\r\ncase MMAL_CONTROL_TYPE_INT_MENU:\r\ndev->ctrls[c] = v4l2_ctrl_new_int_menu(hdl,\r\n&bm2835_mmal_ctrl_ops, ctrl->id,\r\nctrl->max, ctrl->def, ctrl->imenu);\r\nbreak;\r\ncase MMAL_CONTROL_TYPE_CLUSTER:\r\ncontinue;\r\n}\r\nif (hdl->error)\r\nbreak;\r\ndev->ctrls[c]->priv = (void *)ctrl;\r\n}\r\nif (hdl->error) {\r\npr_err("error adding control %d/%d id 0x%x\n", c,\r\nV4L2_CTRL_COUNT, ctrl->id);\r\nreturn hdl->error;\r\n}\r\nfor (c = 0; c < V4L2_CTRL_COUNT; c++) {\r\nctrl = &v4l2_ctrls[c];\r\nswitch (ctrl->type) {\r\ncase MMAL_CONTROL_TYPE_CLUSTER:\r\nv4l2_ctrl_auto_cluster(ctrl->min,\r\n&dev->ctrls[c + 1],\r\nctrl->max,\r\nctrl->def);\r\nbreak;\r\ncase MMAL_CONTROL_TYPE_STD:\r\ncase MMAL_CONTROL_TYPE_STD_MENU:\r\ncase MMAL_CONTROL_TYPE_INT_MENU:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}
