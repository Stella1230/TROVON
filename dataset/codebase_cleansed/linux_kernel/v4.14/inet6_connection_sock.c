struct dst_entry *inet6_csk_route_req(const struct sock *sk,\r\nstruct flowi6 *fl6,\r\nconst struct request_sock *req,\r\nu8 proto)\r\n{\r\nstruct inet_request_sock *ireq = inet_rsk(req);\r\nconst struct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct in6_addr *final_p, final;\r\nstruct dst_entry *dst;\r\nmemset(fl6, 0, sizeof(*fl6));\r\nfl6->flowi6_proto = proto;\r\nfl6->daddr = ireq->ir_v6_rmt_addr;\r\nrcu_read_lock();\r\nfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\r\nrcu_read_unlock();\r\nfl6->saddr = ireq->ir_v6_loc_addr;\r\nfl6->flowi6_oif = ireq->ir_iif;\r\nfl6->flowi6_mark = ireq->ir_mark;\r\nfl6->fl6_dport = ireq->ir_rmt_port;\r\nfl6->fl6_sport = htons(ireq->ir_num);\r\nfl6->flowi6_uid = sk->sk_uid;\r\nsecurity_req_classify_flow(req, flowi6_to_flowi(fl6));\r\ndst = ip6_dst_lookup_flow(sk, fl6, final_p);\r\nif (IS_ERR(dst))\r\nreturn NULL;\r\nreturn dst;\r\n}\r\nvoid inet6_csk_addr2sockaddr(struct sock *sk, struct sockaddr *uaddr)\r\n{\r\nstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) uaddr;\r\nsin6->sin6_family = AF_INET6;\r\nsin6->sin6_addr = sk->sk_v6_daddr;\r\nsin6->sin6_port = inet_sk(sk)->inet_dport;\r\nsin6->sin6_flowinfo = 0;\r\nsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\r\nsk->sk_bound_dev_if);\r\n}\r\nstatic inline\r\nstruct dst_entry *__inet6_csk_dst_check(struct sock *sk, u32 cookie)\r\n{\r\nreturn __sk_dst_check(sk, cookie);\r\n}\r\nstatic struct dst_entry *inet6_csk_route_socket(struct sock *sk,\r\nstruct flowi6 *fl6)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct in6_addr *final_p, final;\r\nstruct dst_entry *dst;\r\nmemset(fl6, 0, sizeof(*fl6));\r\nfl6->flowi6_proto = sk->sk_protocol;\r\nfl6->daddr = sk->sk_v6_daddr;\r\nfl6->saddr = np->saddr;\r\nfl6->flowlabel = np->flow_label;\r\nIP6_ECN_flow_xmit(sk, fl6->flowlabel);\r\nfl6->flowi6_oif = sk->sk_bound_dev_if;\r\nfl6->flowi6_mark = sk->sk_mark;\r\nfl6->fl6_sport = inet->inet_sport;\r\nfl6->fl6_dport = inet->inet_dport;\r\nfl6->flowi6_uid = sk->sk_uid;\r\nsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\r\nrcu_read_lock();\r\nfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\r\nrcu_read_unlock();\r\ndst = __inet6_csk_dst_check(sk, np->dst_cookie);\r\nif (!dst) {\r\ndst = ip6_dst_lookup_flow(sk, fl6, final_p);\r\nif (!IS_ERR(dst))\r\nip6_dst_store(sk, dst, NULL, NULL);\r\n}\r\nreturn dst;\r\n}\r\nint inet6_csk_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl_unused)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct flowi6 fl6;\r\nstruct dst_entry *dst;\r\nint res;\r\ndst = inet6_csk_route_socket(sk, &fl6);\r\nif (IS_ERR(dst)) {\r\nsk->sk_err_soft = -PTR_ERR(dst);\r\nsk->sk_route_caps = 0;\r\nkfree_skb(skb);\r\nreturn PTR_ERR(dst);\r\n}\r\nrcu_read_lock();\r\nskb_dst_set_noref(skb, dst);\r\nfl6.daddr = sk->sk_v6_daddr;\r\nres = ip6_xmit(sk, skb, &fl6, sk->sk_mark, rcu_dereference(np->opt),\r\nnp->tclass);\r\nrcu_read_unlock();\r\nreturn res;\r\n}\r\nstruct dst_entry *inet6_csk_update_pmtu(struct sock *sk, u32 mtu)\r\n{\r\nstruct flowi6 fl6;\r\nstruct dst_entry *dst = inet6_csk_route_socket(sk, &fl6);\r\nif (IS_ERR(dst))\r\nreturn NULL;\r\ndst->ops->update_pmtu(dst, sk, NULL, mtu);\r\ndst = inet6_csk_route_socket(sk, &fl6);\r\nreturn IS_ERR(dst) ? NULL : dst;\r\n}
