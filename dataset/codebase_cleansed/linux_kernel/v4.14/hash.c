static inline void\r\nmv_cesa_ahash_req_iter_init(struct mv_cesa_ahash_dma_iter *iter,\r\nstruct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nunsigned int len = req->nbytes + creq->cache_ptr;\r\nif (!creq->last_req)\r\nlen &= ~CESA_HASH_BLOCK_SIZE_MSK;\r\nmv_cesa_req_dma_iter_init(&iter->base, len);\r\nmv_cesa_sg_dma_iter_init(&iter->src, req->src, DMA_TO_DEVICE);\r\niter->src.op_offset = creq->cache_ptr;\r\n}\r\nstatic inline bool\r\nmv_cesa_ahash_req_iter_next_op(struct mv_cesa_ahash_dma_iter *iter)\r\n{\r\niter->src.op_offset = 0;\r\nreturn mv_cesa_req_dma_iter_next_op(&iter->base);\r\n}\r\nstatic inline int\r\nmv_cesa_ahash_dma_alloc_cache(struct mv_cesa_ahash_dma_req *req, gfp_t flags)\r\n{\r\nreq->cache = dma_pool_alloc(cesa_dev->dma->cache_pool, flags,\r\n&req->cache_dma);\r\nif (!req->cache)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic inline void\r\nmv_cesa_ahash_dma_free_cache(struct mv_cesa_ahash_dma_req *req)\r\n{\r\nif (!req->cache)\r\nreturn;\r\ndma_pool_free(cesa_dev->dma->cache_pool, req->cache,\r\nreq->cache_dma);\r\n}\r\nstatic int mv_cesa_ahash_dma_alloc_padding(struct mv_cesa_ahash_dma_req *req,\r\ngfp_t flags)\r\n{\r\nif (req->padding)\r\nreturn 0;\r\nreq->padding = dma_pool_alloc(cesa_dev->dma->padding_pool, flags,\r\n&req->padding_dma);\r\nif (!req->padding)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void mv_cesa_ahash_dma_free_padding(struct mv_cesa_ahash_dma_req *req)\r\n{\r\nif (!req->padding)\r\nreturn;\r\ndma_pool_free(cesa_dev->dma->padding_pool, req->padding,\r\nreq->padding_dma);\r\nreq->padding = NULL;\r\n}\r\nstatic inline void mv_cesa_ahash_dma_last_cleanup(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nmv_cesa_ahash_dma_free_padding(&creq->req.dma);\r\n}\r\nstatic inline void mv_cesa_ahash_dma_cleanup(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\ndma_unmap_sg(cesa_dev->dev, req->src, creq->src_nents, DMA_TO_DEVICE);\r\nmv_cesa_ahash_dma_free_cache(&creq->req.dma);\r\nmv_cesa_dma_cleanup(&creq->base);\r\n}\r\nstatic inline void mv_cesa_ahash_cleanup(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ)\r\nmv_cesa_ahash_dma_cleanup(req);\r\n}\r\nstatic void mv_cesa_ahash_last_cleanup(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ)\r\nmv_cesa_ahash_dma_last_cleanup(req);\r\n}\r\nstatic int mv_cesa_ahash_pad_len(struct mv_cesa_ahash_req *creq)\r\n{\r\nunsigned int index, padlen;\r\nindex = creq->len & CESA_HASH_BLOCK_SIZE_MSK;\r\npadlen = (index < 56) ? (56 - index) : (64 + 56 - index);\r\nreturn padlen;\r\n}\r\nstatic int mv_cesa_ahash_pad_req(struct mv_cesa_ahash_req *creq, u8 *buf)\r\n{\r\nunsigned int index, padlen;\r\nbuf[0] = 0x80;\r\nindex = creq->len & CESA_HASH_BLOCK_SIZE_MSK;\r\npadlen = mv_cesa_ahash_pad_len(creq);\r\nmemset(buf + 1, 0, padlen - 1);\r\nif (creq->algo_le) {\r\n__le64 bits = cpu_to_le64(creq->len << 3);\r\nmemcpy(buf + padlen, &bits, sizeof(bits));\r\n} else {\r\n__be64 bits = cpu_to_be64(creq->len << 3);\r\nmemcpy(buf + padlen, &bits, sizeof(bits));\r\n}\r\nreturn padlen + 8;\r\n}\r\nstatic void mv_cesa_ahash_std_step(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nstruct mv_cesa_ahash_std_req *sreq = &creq->req.std;\r\nstruct mv_cesa_engine *engine = creq->base.engine;\r\nstruct mv_cesa_op_ctx *op;\r\nunsigned int new_cache_ptr = 0;\r\nu32 frag_mode;\r\nsize_t len;\r\nunsigned int digsize;\r\nint i;\r\nmv_cesa_adjust_op(engine, &creq->op_tmpl);\r\nmemcpy_toio(engine->sram, &creq->op_tmpl, sizeof(creq->op_tmpl));\r\nif (!sreq->offset) {\r\ndigsize = crypto_ahash_digestsize(crypto_ahash_reqtfm(req));\r\nfor (i = 0; i < digsize / 4; i++)\r\nwritel_relaxed(creq->state[i], engine->regs + CESA_IVDIG(i));\r\n}\r\nif (creq->cache_ptr)\r\nmemcpy_toio(engine->sram + CESA_SA_DATA_SRAM_OFFSET,\r\ncreq->cache, creq->cache_ptr);\r\nlen = min_t(size_t, req->nbytes + creq->cache_ptr - sreq->offset,\r\nCESA_SA_SRAM_PAYLOAD_SIZE);\r\nif (!creq->last_req) {\r\nnew_cache_ptr = len & CESA_HASH_BLOCK_SIZE_MSK;\r\nlen &= ~CESA_HASH_BLOCK_SIZE_MSK;\r\n}\r\nif (len - creq->cache_ptr)\r\nsreq->offset += sg_pcopy_to_buffer(req->src, creq->src_nents,\r\nengine->sram +\r\nCESA_SA_DATA_SRAM_OFFSET +\r\ncreq->cache_ptr,\r\nlen - creq->cache_ptr,\r\nsreq->offset);\r\nop = &creq->op_tmpl;\r\nfrag_mode = mv_cesa_get_op_cfg(op) & CESA_SA_DESC_CFG_FRAG_MSK;\r\nif (creq->last_req && sreq->offset == req->nbytes &&\r\ncreq->len <= CESA_SA_DESC_MAC_SRC_TOTAL_LEN_MAX) {\r\nif (frag_mode == CESA_SA_DESC_CFG_FIRST_FRAG)\r\nfrag_mode = CESA_SA_DESC_CFG_NOT_FRAG;\r\nelse if (frag_mode == CESA_SA_DESC_CFG_MID_FRAG)\r\nfrag_mode = CESA_SA_DESC_CFG_LAST_FRAG;\r\n}\r\nif (frag_mode == CESA_SA_DESC_CFG_NOT_FRAG ||\r\nfrag_mode == CESA_SA_DESC_CFG_LAST_FRAG) {\r\nif (len &&\r\ncreq->len <= CESA_SA_DESC_MAC_SRC_TOTAL_LEN_MAX) {\r\nmv_cesa_set_mac_op_total_len(op, creq->len);\r\n} else {\r\nint trailerlen = mv_cesa_ahash_pad_len(creq) + 8;\r\nif (len + trailerlen > CESA_SA_SRAM_PAYLOAD_SIZE) {\r\nlen &= CESA_HASH_BLOCK_SIZE_MSK;\r\nnew_cache_ptr = 64 - trailerlen;\r\nmemcpy_fromio(creq->cache,\r\nengine->sram +\r\nCESA_SA_DATA_SRAM_OFFSET + len,\r\nnew_cache_ptr);\r\n} else {\r\nlen += mv_cesa_ahash_pad_req(creq,\r\nengine->sram + len +\r\nCESA_SA_DATA_SRAM_OFFSET);\r\n}\r\nif (frag_mode == CESA_SA_DESC_CFG_LAST_FRAG)\r\nfrag_mode = CESA_SA_DESC_CFG_MID_FRAG;\r\nelse\r\nfrag_mode = CESA_SA_DESC_CFG_FIRST_FRAG;\r\n}\r\n}\r\nmv_cesa_set_mac_op_frag_len(op, len);\r\nmv_cesa_update_op_cfg(op, frag_mode, CESA_SA_DESC_CFG_FRAG_MSK);\r\nmemcpy_toio(engine->sram, op, sizeof(*op));\r\nif (frag_mode == CESA_SA_DESC_CFG_FIRST_FRAG)\r\nmv_cesa_update_op_cfg(op, CESA_SA_DESC_CFG_MID_FRAG,\r\nCESA_SA_DESC_CFG_FRAG_MSK);\r\ncreq->cache_ptr = new_cache_ptr;\r\nmv_cesa_set_int_mask(engine, CESA_SA_INT_ACCEL0_DONE);\r\nwritel_relaxed(CESA_SA_CFG_PARA_DIS, engine->regs + CESA_SA_CFG);\r\nBUG_ON(readl(engine->regs + CESA_SA_CMD) &\r\nCESA_SA_CMD_EN_CESA_SA_ACCL0);\r\nwritel(CESA_SA_CMD_EN_CESA_SA_ACCL0, engine->regs + CESA_SA_CMD);\r\n}\r\nstatic int mv_cesa_ahash_std_process(struct ahash_request *req, u32 status)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nstruct mv_cesa_ahash_std_req *sreq = &creq->req.std;\r\nif (sreq->offset < (req->nbytes - creq->cache_ptr))\r\nreturn -EINPROGRESS;\r\nreturn 0;\r\n}\r\nstatic inline void mv_cesa_ahash_dma_prepare(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nstruct mv_cesa_req *basereq = &creq->base;\r\nmv_cesa_dma_prepare(basereq, basereq->engine);\r\n}\r\nstatic void mv_cesa_ahash_std_prepare(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nstruct mv_cesa_ahash_std_req *sreq = &creq->req.std;\r\nsreq->offset = 0;\r\n}\r\nstatic void mv_cesa_ahash_dma_step(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nstruct mv_cesa_req *base = &creq->base;\r\nif (base->chain.first->flags & CESA_TDMA_SET_STATE) {\r\nstruct mv_cesa_engine *engine = base->engine;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(creq->state); i++)\r\nwritel_relaxed(creq->state[i], engine->regs +\r\nCESA_IVDIG(i));\r\n}\r\nmv_cesa_dma_step(base);\r\n}\r\nstatic void mv_cesa_ahash_step(struct crypto_async_request *req)\r\n{\r\nstruct ahash_request *ahashreq = ahash_request_cast(req);\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(ahashreq);\r\nif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ)\r\nmv_cesa_ahash_dma_step(ahashreq);\r\nelse\r\nmv_cesa_ahash_std_step(ahashreq);\r\n}\r\nstatic int mv_cesa_ahash_process(struct crypto_async_request *req, u32 status)\r\n{\r\nstruct ahash_request *ahashreq = ahash_request_cast(req);\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(ahashreq);\r\nif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ)\r\nreturn mv_cesa_dma_process(&creq->base, status);\r\nreturn mv_cesa_ahash_std_process(ahashreq, status);\r\n}\r\nstatic void mv_cesa_ahash_complete(struct crypto_async_request *req)\r\n{\r\nstruct ahash_request *ahashreq = ahash_request_cast(req);\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(ahashreq);\r\nstruct mv_cesa_engine *engine = creq->base.engine;\r\nunsigned int digsize;\r\nint i;\r\ndigsize = crypto_ahash_digestsize(crypto_ahash_reqtfm(ahashreq));\r\nif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ &&\r\n(creq->base.chain.last->flags & CESA_TDMA_TYPE_MSK) == CESA_TDMA_RESULT) {\r\n__le32 *data = NULL;\r\ndata = creq->base.chain.last->op->ctx.hash.hash;\r\nfor (i = 0; i < digsize / 4; i++)\r\ncreq->state[i] = cpu_to_le32(data[i]);\r\nmemcpy(ahashreq->result, data, digsize);\r\n} else {\r\nfor (i = 0; i < digsize / 4; i++)\r\ncreq->state[i] = readl_relaxed(engine->regs +\r\nCESA_IVDIG(i));\r\nif (creq->last_req) {\r\nif (creq->algo_le) {\r\n__le32 *result = (void *)ahashreq->result;\r\nfor (i = 0; i < digsize / 4; i++)\r\nresult[i] = cpu_to_le32(creq->state[i]);\r\n} else {\r\n__be32 *result = (void *)ahashreq->result;\r\nfor (i = 0; i < digsize / 4; i++)\r\nresult[i] = cpu_to_be32(creq->state[i]);\r\n}\r\n}\r\n}\r\natomic_sub(ahashreq->nbytes, &engine->load);\r\n}\r\nstatic void mv_cesa_ahash_prepare(struct crypto_async_request *req,\r\nstruct mv_cesa_engine *engine)\r\n{\r\nstruct ahash_request *ahashreq = ahash_request_cast(req);\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(ahashreq);\r\ncreq->base.engine = engine;\r\nif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ)\r\nmv_cesa_ahash_dma_prepare(ahashreq);\r\nelse\r\nmv_cesa_ahash_std_prepare(ahashreq);\r\n}\r\nstatic void mv_cesa_ahash_req_cleanup(struct crypto_async_request *req)\r\n{\r\nstruct ahash_request *ahashreq = ahash_request_cast(req);\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(ahashreq);\r\nif (creq->last_req)\r\nmv_cesa_ahash_last_cleanup(ahashreq);\r\nmv_cesa_ahash_cleanup(ahashreq);\r\nif (creq->cache_ptr)\r\nsg_pcopy_to_buffer(ahashreq->src, creq->src_nents,\r\ncreq->cache,\r\ncreq->cache_ptr,\r\nahashreq->nbytes - creq->cache_ptr);\r\n}\r\nstatic void mv_cesa_ahash_init(struct ahash_request *req,\r\nstruct mv_cesa_op_ctx *tmpl, bool algo_le)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nmemset(creq, 0, sizeof(*creq));\r\nmv_cesa_update_op_cfg(tmpl,\r\nCESA_SA_DESC_CFG_OP_MAC_ONLY |\r\nCESA_SA_DESC_CFG_FIRST_FRAG,\r\nCESA_SA_DESC_CFG_OP_MSK |\r\nCESA_SA_DESC_CFG_FRAG_MSK);\r\nmv_cesa_set_mac_op_total_len(tmpl, 0);\r\nmv_cesa_set_mac_op_frag_len(tmpl, 0);\r\ncreq->op_tmpl = *tmpl;\r\ncreq->len = 0;\r\ncreq->algo_le = algo_le;\r\n}\r\nstatic inline int mv_cesa_ahash_cra_init(struct crypto_tfm *tfm)\r\n{\r\nstruct mv_cesa_hash_ctx *ctx = crypto_tfm_ctx(tfm);\r\nctx->base.ops = &mv_cesa_ahash_req_ops;\r\ncrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\r\nsizeof(struct mv_cesa_ahash_req));\r\nreturn 0;\r\n}\r\nstatic bool mv_cesa_ahash_cache_req(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nbool cached = false;\r\nif (creq->cache_ptr + req->nbytes < CESA_MAX_HASH_BLOCK_SIZE && !creq->last_req) {\r\ncached = true;\r\nif (!req->nbytes)\r\nreturn cached;\r\nsg_pcopy_to_buffer(req->src, creq->src_nents,\r\ncreq->cache + creq->cache_ptr,\r\nreq->nbytes, 0);\r\ncreq->cache_ptr += req->nbytes;\r\n}\r\nreturn cached;\r\n}\r\nstatic struct mv_cesa_op_ctx *\r\nmv_cesa_dma_add_frag(struct mv_cesa_tdma_chain *chain,\r\nstruct mv_cesa_op_ctx *tmpl, unsigned int frag_len,\r\ngfp_t flags)\r\n{\r\nstruct mv_cesa_op_ctx *op;\r\nint ret;\r\nop = mv_cesa_dma_add_op(chain, tmpl, false, flags);\r\nif (IS_ERR(op))\r\nreturn op;\r\nmv_cesa_set_mac_op_frag_len(op, frag_len);\r\nret = mv_cesa_dma_add_dummy_launch(chain, flags);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nif (mv_cesa_mac_op_is_first_frag(tmpl))\r\nmv_cesa_update_op_cfg(tmpl,\r\nCESA_SA_DESC_CFG_MID_FRAG,\r\nCESA_SA_DESC_CFG_FRAG_MSK);\r\nreturn op;\r\n}\r\nstatic int\r\nmv_cesa_ahash_dma_add_cache(struct mv_cesa_tdma_chain *chain,\r\nstruct mv_cesa_ahash_req *creq,\r\ngfp_t flags)\r\n{\r\nstruct mv_cesa_ahash_dma_req *ahashdreq = &creq->req.dma;\r\nint ret;\r\nif (!creq->cache_ptr)\r\nreturn 0;\r\nret = mv_cesa_ahash_dma_alloc_cache(ahashdreq, flags);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(ahashdreq->cache, creq->cache, creq->cache_ptr);\r\nreturn mv_cesa_dma_add_data_transfer(chain,\r\nCESA_SA_DATA_SRAM_OFFSET,\r\nahashdreq->cache_dma,\r\ncreq->cache_ptr,\r\nCESA_TDMA_DST_IN_SRAM,\r\nflags);\r\n}\r\nstatic struct mv_cesa_op_ctx *\r\nmv_cesa_ahash_dma_last_req(struct mv_cesa_tdma_chain *chain,\r\nstruct mv_cesa_ahash_dma_iter *dma_iter,\r\nstruct mv_cesa_ahash_req *creq,\r\nunsigned int frag_len, gfp_t flags)\r\n{\r\nstruct mv_cesa_ahash_dma_req *ahashdreq = &creq->req.dma;\r\nunsigned int len, trailerlen, padoff = 0;\r\nstruct mv_cesa_op_ctx *op;\r\nint ret;\r\nif (creq->len <= CESA_SA_DESC_MAC_SRC_TOTAL_LEN_MAX && frag_len) {\r\nop = mv_cesa_dma_add_frag(chain, &creq->op_tmpl, frag_len,\r\nflags);\r\nif (IS_ERR(op))\r\nreturn op;\r\nmv_cesa_set_mac_op_total_len(op, creq->len);\r\nmv_cesa_update_op_cfg(op, mv_cesa_mac_op_is_first_frag(op) ?\r\nCESA_SA_DESC_CFG_NOT_FRAG :\r\nCESA_SA_DESC_CFG_LAST_FRAG,\r\nCESA_SA_DESC_CFG_FRAG_MSK);\r\nret = mv_cesa_dma_add_result_op(chain,\r\nCESA_SA_CFG_SRAM_OFFSET,\r\nCESA_SA_DATA_SRAM_OFFSET,\r\nCESA_TDMA_SRC_IN_SRAM, flags);\r\nif (ret)\r\nreturn ERR_PTR(-ENOMEM);\r\nreturn op;\r\n}\r\nret = mv_cesa_ahash_dma_alloc_padding(ahashdreq, flags);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\ntrailerlen = mv_cesa_ahash_pad_req(creq, ahashdreq->padding);\r\nlen = min(CESA_SA_SRAM_PAYLOAD_SIZE - frag_len, trailerlen);\r\nif (len) {\r\nret = mv_cesa_dma_add_data_transfer(chain,\r\nCESA_SA_DATA_SRAM_OFFSET +\r\nfrag_len,\r\nahashdreq->padding_dma,\r\nlen, CESA_TDMA_DST_IN_SRAM,\r\nflags);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nop = mv_cesa_dma_add_frag(chain, &creq->op_tmpl, frag_len + len,\r\nflags);\r\nif (IS_ERR(op))\r\nreturn op;\r\nif (len == trailerlen)\r\nreturn op;\r\npadoff += len;\r\n}\r\nret = mv_cesa_dma_add_data_transfer(chain,\r\nCESA_SA_DATA_SRAM_OFFSET,\r\nahashdreq->padding_dma +\r\npadoff,\r\ntrailerlen - padoff,\r\nCESA_TDMA_DST_IN_SRAM,\r\nflags);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn mv_cesa_dma_add_frag(chain, &creq->op_tmpl, trailerlen - padoff,\r\nflags);\r\n}\r\nstatic int mv_cesa_ahash_dma_req_init(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\ngfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\r\nGFP_KERNEL : GFP_ATOMIC;\r\nstruct mv_cesa_req *basereq = &creq->base;\r\nstruct mv_cesa_ahash_dma_iter iter;\r\nstruct mv_cesa_op_ctx *op = NULL;\r\nunsigned int frag_len;\r\nbool set_state = false;\r\nint ret;\r\nu32 type;\r\nbasereq->chain.first = NULL;\r\nbasereq->chain.last = NULL;\r\nif (!mv_cesa_mac_op_is_first_frag(&creq->op_tmpl))\r\nset_state = true;\r\nif (creq->src_nents) {\r\nret = dma_map_sg(cesa_dev->dev, req->src, creq->src_nents,\r\nDMA_TO_DEVICE);\r\nif (!ret) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\n}\r\nmv_cesa_tdma_desc_iter_init(&basereq->chain);\r\nmv_cesa_ahash_req_iter_init(&iter, req);\r\nret = mv_cesa_ahash_dma_add_cache(&basereq->chain, creq, flags);\r\nif (ret)\r\ngoto err_free_tdma;\r\nif (iter.src.sg) {\r\nwhile (true) {\r\nret = mv_cesa_dma_add_op_transfers(&basereq->chain,\r\n&iter.base,\r\n&iter.src, flags);\r\nif (ret)\r\ngoto err_free_tdma;\r\nfrag_len = iter.base.op_len;\r\nif (!mv_cesa_ahash_req_iter_next_op(&iter))\r\nbreak;\r\nop = mv_cesa_dma_add_frag(&basereq->chain, &creq->op_tmpl,\r\nfrag_len, flags);\r\nif (IS_ERR(op)) {\r\nret = PTR_ERR(op);\r\ngoto err_free_tdma;\r\n}\r\n}\r\n} else {\r\nfrag_len = iter.base.op_len;\r\n}\r\nif (creq->last_req)\r\nop = mv_cesa_ahash_dma_last_req(&basereq->chain, &iter, creq,\r\nfrag_len, flags);\r\nelse if (frag_len)\r\nop = mv_cesa_dma_add_frag(&basereq->chain, &creq->op_tmpl,\r\nfrag_len, flags);\r\nif (IS_ERR(op)) {\r\nret = PTR_ERR(op);\r\ngoto err_free_tdma;\r\n}\r\ntype = basereq->chain.last->flags & CESA_TDMA_TYPE_MSK;\r\nif (op && type != CESA_TDMA_RESULT) {\r\nret = mv_cesa_dma_add_dummy_end(&basereq->chain, flags);\r\nif (ret)\r\ngoto err_free_tdma;\r\n}\r\nif (!creq->last_req)\r\ncreq->cache_ptr = req->nbytes + creq->cache_ptr -\r\niter.base.len;\r\nelse\r\ncreq->cache_ptr = 0;\r\nbasereq->chain.last->flags |= CESA_TDMA_END_OF_REQ;\r\nif (type != CESA_TDMA_RESULT)\r\nbasereq->chain.last->flags |= CESA_TDMA_BREAK_CHAIN;\r\nif (set_state) {\r\nbasereq->chain.first->flags |= CESA_TDMA_SET_STATE;\r\n}\r\nreturn 0;\r\nerr_free_tdma:\r\nmv_cesa_dma_cleanup(basereq);\r\ndma_unmap_sg(cesa_dev->dev, req->src, creq->src_nents, DMA_TO_DEVICE);\r\nerr:\r\nmv_cesa_ahash_last_cleanup(req);\r\nreturn ret;\r\n}\r\nstatic int mv_cesa_ahash_req_init(struct ahash_request *req, bool *cached)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\ncreq->src_nents = sg_nents_for_len(req->src, req->nbytes);\r\nif (creq->src_nents < 0) {\r\ndev_err(cesa_dev->dev, "Invalid number of src SG");\r\nreturn creq->src_nents;\r\n}\r\n*cached = mv_cesa_ahash_cache_req(req);\r\nif (*cached)\r\nreturn 0;\r\nif (cesa_dev->caps->has_tdma)\r\nreturn mv_cesa_ahash_dma_req_init(req);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_ahash_queue_req(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nstruct mv_cesa_engine *engine;\r\nbool cached = false;\r\nint ret;\r\nret = mv_cesa_ahash_req_init(req, &cached);\r\nif (ret)\r\nreturn ret;\r\nif (cached)\r\nreturn 0;\r\nengine = mv_cesa_select_engine(req->nbytes);\r\nmv_cesa_ahash_prepare(&req->base, engine);\r\nret = mv_cesa_queue_req(&req->base, &creq->base);\r\nif (mv_cesa_req_needs_cleanup(&req->base, ret))\r\nmv_cesa_ahash_cleanup(req);\r\nreturn ret;\r\n}\r\nstatic int mv_cesa_ahash_update(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\ncreq->len += req->nbytes;\r\nreturn mv_cesa_ahash_queue_req(req);\r\n}\r\nstatic int mv_cesa_ahash_final(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nstruct mv_cesa_op_ctx *tmpl = &creq->op_tmpl;\r\nmv_cesa_set_mac_op_total_len(tmpl, creq->len);\r\ncreq->last_req = true;\r\nreq->nbytes = 0;\r\nreturn mv_cesa_ahash_queue_req(req);\r\n}\r\nstatic int mv_cesa_ahash_finup(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nstruct mv_cesa_op_ctx *tmpl = &creq->op_tmpl;\r\ncreq->len += req->nbytes;\r\nmv_cesa_set_mac_op_total_len(tmpl, creq->len);\r\ncreq->last_req = true;\r\nreturn mv_cesa_ahash_queue_req(req);\r\n}\r\nstatic int mv_cesa_ahash_export(struct ahash_request *req, void *hash,\r\nu64 *len, void *cache)\r\n{\r\nstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nunsigned int digsize = crypto_ahash_digestsize(ahash);\r\nunsigned int blocksize;\r\nblocksize = crypto_ahash_blocksize(ahash);\r\n*len = creq->len;\r\nmemcpy(hash, creq->state, digsize);\r\nmemset(cache, 0, blocksize);\r\nmemcpy(cache, creq->cache, creq->cache_ptr);\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_ahash_import(struct ahash_request *req, const void *hash,\r\nu64 len, const void *cache)\r\n{\r\nstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nunsigned int digsize = crypto_ahash_digestsize(ahash);\r\nunsigned int blocksize;\r\nunsigned int cache_ptr;\r\nint ret;\r\nret = crypto_ahash_init(req);\r\nif (ret)\r\nreturn ret;\r\nblocksize = crypto_ahash_blocksize(ahash);\r\nif (len >= blocksize)\r\nmv_cesa_update_op_cfg(&creq->op_tmpl,\r\nCESA_SA_DESC_CFG_MID_FRAG,\r\nCESA_SA_DESC_CFG_FRAG_MSK);\r\ncreq->len = len;\r\nmemcpy(creq->state, hash, digsize);\r\ncreq->cache_ptr = 0;\r\ncache_ptr = do_div(len, blocksize);\r\nif (!cache_ptr)\r\nreturn 0;\r\nmemcpy(creq->cache, cache, cache_ptr);\r\ncreq->cache_ptr = cache_ptr;\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_md5_init(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nstruct mv_cesa_op_ctx tmpl = { };\r\nmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_MACM_MD5);\r\nmv_cesa_ahash_init(req, &tmpl, true);\r\ncreq->state[0] = MD5_H0;\r\ncreq->state[1] = MD5_H1;\r\ncreq->state[2] = MD5_H2;\r\ncreq->state[3] = MD5_H3;\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_md5_export(struct ahash_request *req, void *out)\r\n{\r\nstruct md5_state *out_state = out;\r\nreturn mv_cesa_ahash_export(req, out_state->hash,\r\n&out_state->byte_count, out_state->block);\r\n}\r\nstatic int mv_cesa_md5_import(struct ahash_request *req, const void *in)\r\n{\r\nconst struct md5_state *in_state = in;\r\nreturn mv_cesa_ahash_import(req, in_state->hash, in_state->byte_count,\r\nin_state->block);\r\n}\r\nstatic int mv_cesa_md5_digest(struct ahash_request *req)\r\n{\r\nint ret;\r\nret = mv_cesa_md5_init(req);\r\nif (ret)\r\nreturn ret;\r\nreturn mv_cesa_ahash_finup(req);\r\n}\r\nstatic int mv_cesa_sha1_init(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nstruct mv_cesa_op_ctx tmpl = { };\r\nmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_MACM_SHA1);\r\nmv_cesa_ahash_init(req, &tmpl, false);\r\ncreq->state[0] = SHA1_H0;\r\ncreq->state[1] = SHA1_H1;\r\ncreq->state[2] = SHA1_H2;\r\ncreq->state[3] = SHA1_H3;\r\ncreq->state[4] = SHA1_H4;\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_sha1_export(struct ahash_request *req, void *out)\r\n{\r\nstruct sha1_state *out_state = out;\r\nreturn mv_cesa_ahash_export(req, out_state->state, &out_state->count,\r\nout_state->buffer);\r\n}\r\nstatic int mv_cesa_sha1_import(struct ahash_request *req, const void *in)\r\n{\r\nconst struct sha1_state *in_state = in;\r\nreturn mv_cesa_ahash_import(req, in_state->state, in_state->count,\r\nin_state->buffer);\r\n}\r\nstatic int mv_cesa_sha1_digest(struct ahash_request *req)\r\n{\r\nint ret;\r\nret = mv_cesa_sha1_init(req);\r\nif (ret)\r\nreturn ret;\r\nreturn mv_cesa_ahash_finup(req);\r\n}\r\nstatic int mv_cesa_sha256_init(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\r\nstruct mv_cesa_op_ctx tmpl = { };\r\nmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_MACM_SHA256);\r\nmv_cesa_ahash_init(req, &tmpl, false);\r\ncreq->state[0] = SHA256_H0;\r\ncreq->state[1] = SHA256_H1;\r\ncreq->state[2] = SHA256_H2;\r\ncreq->state[3] = SHA256_H3;\r\ncreq->state[4] = SHA256_H4;\r\ncreq->state[5] = SHA256_H5;\r\ncreq->state[6] = SHA256_H6;\r\ncreq->state[7] = SHA256_H7;\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_sha256_digest(struct ahash_request *req)\r\n{\r\nint ret;\r\nret = mv_cesa_sha256_init(req);\r\nif (ret)\r\nreturn ret;\r\nreturn mv_cesa_ahash_finup(req);\r\n}\r\nstatic int mv_cesa_sha256_export(struct ahash_request *req, void *out)\r\n{\r\nstruct sha256_state *out_state = out;\r\nreturn mv_cesa_ahash_export(req, out_state->state, &out_state->count,\r\nout_state->buf);\r\n}\r\nstatic int mv_cesa_sha256_import(struct ahash_request *req, const void *in)\r\n{\r\nconst struct sha256_state *in_state = in;\r\nreturn mv_cesa_ahash_import(req, in_state->state, in_state->count,\r\nin_state->buf);\r\n}\r\nstatic void mv_cesa_hmac_ahash_complete(struct crypto_async_request *req,\r\nint error)\r\n{\r\nstruct mv_cesa_ahash_result *result = req->data;\r\nif (error == -EINPROGRESS)\r\nreturn;\r\nresult->error = error;\r\ncomplete(&result->completion);\r\n}\r\nstatic int mv_cesa_ahmac_iv_state_init(struct ahash_request *req, u8 *pad,\r\nvoid *state, unsigned int blocksize)\r\n{\r\nstruct mv_cesa_ahash_result result;\r\nstruct scatterlist sg;\r\nint ret;\r\nahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\r\nmv_cesa_hmac_ahash_complete, &result);\r\nsg_init_one(&sg, pad, blocksize);\r\nahash_request_set_crypt(req, &sg, pad, blocksize);\r\ninit_completion(&result.completion);\r\nret = crypto_ahash_init(req);\r\nif (ret)\r\nreturn ret;\r\nret = crypto_ahash_update(req);\r\nif (ret && ret != -EINPROGRESS)\r\nreturn ret;\r\nwait_for_completion_interruptible(&result.completion);\r\nif (result.error)\r\nreturn result.error;\r\nret = crypto_ahash_export(req, state);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_ahmac_pad_init(struct ahash_request *req,\r\nconst u8 *key, unsigned int keylen,\r\nu8 *ipad, u8 *opad,\r\nunsigned int blocksize)\r\n{\r\nstruct mv_cesa_ahash_result result;\r\nstruct scatterlist sg;\r\nint ret;\r\nint i;\r\nif (keylen <= blocksize) {\r\nmemcpy(ipad, key, keylen);\r\n} else {\r\nu8 *keydup = kmemdup(key, keylen, GFP_KERNEL);\r\nif (!keydup)\r\nreturn -ENOMEM;\r\nahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\r\nmv_cesa_hmac_ahash_complete,\r\n&result);\r\nsg_init_one(&sg, keydup, keylen);\r\nahash_request_set_crypt(req, &sg, ipad, keylen);\r\ninit_completion(&result.completion);\r\nret = crypto_ahash_digest(req);\r\nif (ret == -EINPROGRESS) {\r\nwait_for_completion_interruptible(&result.completion);\r\nret = result.error;\r\n}\r\nmemset(keydup, 0, keylen);\r\nkfree(keydup);\r\nif (ret)\r\nreturn ret;\r\nkeylen = crypto_ahash_digestsize(crypto_ahash_reqtfm(req));\r\n}\r\nmemset(ipad + keylen, 0, blocksize - keylen);\r\nmemcpy(opad, ipad, blocksize);\r\nfor (i = 0; i < blocksize; i++) {\r\nipad[i] ^= HMAC_IPAD_VALUE;\r\nopad[i] ^= HMAC_OPAD_VALUE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_ahmac_setkey(const char *hash_alg_name,\r\nconst u8 *key, unsigned int keylen,\r\nvoid *istate, void *ostate)\r\n{\r\nstruct ahash_request *req;\r\nstruct crypto_ahash *tfm;\r\nunsigned int blocksize;\r\nu8 *ipad = NULL;\r\nu8 *opad;\r\nint ret;\r\ntfm = crypto_alloc_ahash(hash_alg_name, CRYPTO_ALG_TYPE_AHASH,\r\nCRYPTO_ALG_TYPE_AHASH_MASK);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\nreq = ahash_request_alloc(tfm, GFP_KERNEL);\r\nif (!req) {\r\nret = -ENOMEM;\r\ngoto free_ahash;\r\n}\r\ncrypto_ahash_clear_flags(tfm, ~0);\r\nblocksize = crypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));\r\nipad = kzalloc(2 * blocksize, GFP_KERNEL);\r\nif (!ipad) {\r\nret = -ENOMEM;\r\ngoto free_req;\r\n}\r\nopad = ipad + blocksize;\r\nret = mv_cesa_ahmac_pad_init(req, key, keylen, ipad, opad, blocksize);\r\nif (ret)\r\ngoto free_ipad;\r\nret = mv_cesa_ahmac_iv_state_init(req, ipad, istate, blocksize);\r\nif (ret)\r\ngoto free_ipad;\r\nret = mv_cesa_ahmac_iv_state_init(req, opad, ostate, blocksize);\r\nfree_ipad:\r\nkfree(ipad);\r\nfree_req:\r\nahash_request_free(req);\r\nfree_ahash:\r\ncrypto_free_ahash(tfm);\r\nreturn ret;\r\n}\r\nstatic int mv_cesa_ahmac_cra_init(struct crypto_tfm *tfm)\r\n{\r\nstruct mv_cesa_hmac_ctx *ctx = crypto_tfm_ctx(tfm);\r\nctx->base.ops = &mv_cesa_ahash_req_ops;\r\ncrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\r\nsizeof(struct mv_cesa_ahash_req));\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_ahmac_md5_init(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_hmac_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct mv_cesa_op_ctx tmpl = { };\r\nmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_MACM_HMAC_MD5);\r\nmemcpy(tmpl.ctx.hash.iv, ctx->iv, sizeof(ctx->iv));\r\nmv_cesa_ahash_init(req, &tmpl, true);\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_ahmac_md5_setkey(struct crypto_ahash *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct mv_cesa_hmac_ctx *ctx = crypto_tfm_ctx(crypto_ahash_tfm(tfm));\r\nstruct md5_state istate, ostate;\r\nint ret, i;\r\nret = mv_cesa_ahmac_setkey("mv-md5", key, keylen, &istate, &ostate);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(istate.hash); i++)\r\nctx->iv[i] = be32_to_cpu(istate.hash[i]);\r\nfor (i = 0; i < ARRAY_SIZE(ostate.hash); i++)\r\nctx->iv[i + 8] = be32_to_cpu(ostate.hash[i]);\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_ahmac_md5_digest(struct ahash_request *req)\r\n{\r\nint ret;\r\nret = mv_cesa_ahmac_md5_init(req);\r\nif (ret)\r\nreturn ret;\r\nreturn mv_cesa_ahash_finup(req);\r\n}\r\nstatic int mv_cesa_ahmac_sha1_init(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_hmac_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct mv_cesa_op_ctx tmpl = { };\r\nmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_MACM_HMAC_SHA1);\r\nmemcpy(tmpl.ctx.hash.iv, ctx->iv, sizeof(ctx->iv));\r\nmv_cesa_ahash_init(req, &tmpl, false);\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_ahmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct mv_cesa_hmac_ctx *ctx = crypto_tfm_ctx(crypto_ahash_tfm(tfm));\r\nstruct sha1_state istate, ostate;\r\nint ret, i;\r\nret = mv_cesa_ahmac_setkey("mv-sha1", key, keylen, &istate, &ostate);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(istate.state); i++)\r\nctx->iv[i] = be32_to_cpu(istate.state[i]);\r\nfor (i = 0; i < ARRAY_SIZE(ostate.state); i++)\r\nctx->iv[i + 8] = be32_to_cpu(ostate.state[i]);\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_ahmac_sha1_digest(struct ahash_request *req)\r\n{\r\nint ret;\r\nret = mv_cesa_ahmac_sha1_init(req);\r\nif (ret)\r\nreturn ret;\r\nreturn mv_cesa_ahash_finup(req);\r\n}\r\nstatic int mv_cesa_ahmac_sha256_setkey(struct crypto_ahash *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct mv_cesa_hmac_ctx *ctx = crypto_tfm_ctx(crypto_ahash_tfm(tfm));\r\nstruct sha256_state istate, ostate;\r\nint ret, i;\r\nret = mv_cesa_ahmac_setkey("mv-sha256", key, keylen, &istate, &ostate);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(istate.state); i++)\r\nctx->iv[i] = be32_to_cpu(istate.state[i]);\r\nfor (i = 0; i < ARRAY_SIZE(ostate.state); i++)\r\nctx->iv[i + 8] = be32_to_cpu(ostate.state[i]);\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_ahmac_sha256_init(struct ahash_request *req)\r\n{\r\nstruct mv_cesa_hmac_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct mv_cesa_op_ctx tmpl = { };\r\nmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_MACM_HMAC_SHA256);\r\nmemcpy(tmpl.ctx.hash.iv, ctx->iv, sizeof(ctx->iv));\r\nmv_cesa_ahash_init(req, &tmpl, false);\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_ahmac_sha256_digest(struct ahash_request *req)\r\n{\r\nint ret;\r\nret = mv_cesa_ahmac_sha256_init(req);\r\nif (ret)\r\nreturn ret;\r\nreturn mv_cesa_ahash_finup(req);\r\n}
