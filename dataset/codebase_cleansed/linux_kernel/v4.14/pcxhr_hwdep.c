static int pcxhr_init_board(struct pcxhr_mgr *mgr)\r\n{\r\nint err;\r\nstruct pcxhr_rmh rmh;\r\nint card_streams;\r\nif (mgr->mono_capture)\r\ncard_streams = mgr->capture_chips * 2;\r\nelse\r\ncard_streams = mgr->capture_chips;\r\ncard_streams += mgr->playback_chips * PCXHR_PLAYBACK_STREAMS;\r\npcxhr_enable_dsp(mgr);\r\npcxhr_init_rmh(&rmh, CMD_SUPPORTED);\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err)\r\nreturn err;\r\nif ((rmh.stat[0] & MASK_FIRST_FIELD) < mgr->playback_chips * 2)\r\nreturn -EINVAL;\r\nif (((rmh.stat[0] >> (2 * FIELD_SIZE)) & MASK_FIRST_FIELD) <\r\nmgr->capture_chips * 2)\r\nreturn -EINVAL;\r\nif ((rmh.stat[1] & 0x5F) < card_streams)\r\nreturn -EINVAL;\r\nif (((rmh.stat[1] >> 7) & 0x5F) < PCXHR_PLAYBACK_STREAMS)\r\nreturn -EINVAL;\r\ndev_dbg(&mgr->pci->dev,\r\n"supported formats : playback=%x capture=%x\n",\r\nrmh.stat[2], rmh.stat[3]);\r\npcxhr_init_rmh(&rmh, CMD_VERSION);\r\nrmh.cmd[0] |= mgr->firmware_num;\r\nrmh.cmd[1] = (1<<23) + mgr->granularity;\r\nrmh.cmd_len = 2;\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err)\r\nreturn err;\r\ndev_dbg(&mgr->pci->dev,\r\n"PCXHR DSP version is %d.%d.%d\n", (rmh.stat[0]>>16)&0xff,\r\n(rmh.stat[0]>>8)&0xff, rmh.stat[0]&0xff);\r\nmgr->dsp_version = rmh.stat[0];\r\nif (mgr->is_hr_stereo)\r\nerr = hr222_sub_init(mgr);\r\nelse\r\nerr = pcxhr_sub_init(mgr);\r\nreturn err;\r\n}\r\nstatic int pcxhr_sub_init(struct pcxhr_mgr *mgr)\r\n{\r\nint err;\r\nstruct pcxhr_rmh rmh;\r\npcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);\r\nrmh.cmd[0] |= IO_NUM_REG_STATUS;\r\nrmh.cmd[1] = REG_STATUS_OPTIONS;\r\nrmh.cmd_len = 2;\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err)\r\nreturn err;\r\nif ((rmh.stat[1] & REG_STATUS_OPT_DAUGHTER_MASK) ==\r\nREG_STATUS_OPT_ANALOG_BOARD)\r\nmgr->board_has_analog = 1;\r\nerr = pcxhr_write_io_num_reg_cont(mgr, REG_CONT_UNMUTE_INPUTS,\r\nREG_CONT_UNMUTE_INPUTS, NULL);\r\nif (err)\r\nreturn err;\r\npcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);\r\nrmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;\r\nif (DSP_EXT_CMD_SET(mgr)) {\r\nrmh.cmd[1] = 1;\r\nrmh.cmd_len = 2;\r\n}\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nreturn err;\r\n}\r\nvoid pcxhr_reset_board(struct pcxhr_mgr *mgr)\r\n{\r\nstruct pcxhr_rmh rmh;\r\nif (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)) {\r\nif (!mgr->is_hr_stereo) {\r\npcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\r\nrmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;\r\npcxhr_send_msg(mgr, &rmh);\r\npcxhr_write_io_num_reg_cont(mgr, REG_CONT_UNMUTE_INPUTS,\r\n0, NULL);\r\n}\r\n}\r\nif (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_EPRM_INDEX))\r\npcxhr_reset_dsp(mgr);\r\nif (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_XLX_COM_INDEX)) {\r\npcxhr_reset_xilinx_com(mgr);\r\nmgr->dsp_loaded = 1;\r\n}\r\nreturn;\r\n}\r\nstatic int pcxhr_dsp_allocate_pipe(struct pcxhr_mgr *mgr,\r\nstruct pcxhr_pipe *pipe,\r\nint is_capture, int pin)\r\n{\r\nint stream_count, audio_count;\r\nint err;\r\nstruct pcxhr_rmh rmh;\r\nif (is_capture) {\r\nstream_count = 1;\r\nif (mgr->mono_capture)\r\naudio_count = 1;\r\nelse\r\naudio_count = 2;\r\n} else {\r\nstream_count = PCXHR_PLAYBACK_STREAMS;\r\naudio_count = 2;\r\n}\r\ndev_dbg(&mgr->pci->dev, "snd_add_ref_pipe pin(%d) pcm%c0\n",\r\npin, is_capture ? 'c' : 'p');\r\npipe->is_capture = is_capture;\r\npipe->first_audio = pin;\r\npcxhr_init_rmh(&rmh, CMD_RES_PIPE);\r\npcxhr_set_pipe_cmd_params(&rmh, is_capture, pin,\r\naudio_count, stream_count);\r\nrmh.cmd[1] |= 0x020000;\r\nif (DSP_EXT_CMD_SET(mgr)) {\r\nrmh.cmd[rmh.cmd_len++] = (audio_count == 1) ? 0x01 : 0x03;\r\n}\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err < 0) {\r\ndev_err(&mgr->pci->dev, "error pipe allocation "\r\n"(CMD_RES_PIPE) err=%x!\n", err);\r\nreturn err;\r\n}\r\npipe->status = PCXHR_PIPE_DEFINED;\r\nreturn 0;\r\n}\r\nstatic int pcxhr_config_pipes(struct pcxhr_mgr *mgr)\r\n{\r\nint err, i, j;\r\nstruct snd_pcxhr *chip;\r\nstruct pcxhr_pipe *pipe;\r\nfor (i = 0; i < mgr->num_cards; i++) {\r\nchip = mgr->chip[i];\r\nif (chip->nb_streams_play) {\r\npipe = &chip->playback_pipe;\r\nerr = pcxhr_dsp_allocate_pipe( mgr, pipe, 0, i*2);\r\nif (err)\r\nreturn err;\r\nfor(j = 0; j < chip->nb_streams_play; j++)\r\nchip->playback_stream[j].pipe = pipe;\r\n}\r\nfor (j = 0; j < chip->nb_streams_capt; j++) {\r\npipe = &chip->capture_pipe[j];\r\nerr = pcxhr_dsp_allocate_pipe(mgr, pipe, 1, i*2 + j);\r\nif (err)\r\nreturn err;\r\nchip->capture_stream[j].pipe = pipe;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcxhr_start_pipes(struct pcxhr_mgr *mgr)\r\n{\r\nint i, j;\r\nstruct snd_pcxhr *chip;\r\nint playback_mask = 0;\r\nint capture_mask = 0;\r\nfor (i = 0; i < mgr->num_cards; i++) {\r\nchip = mgr->chip[i];\r\nif (chip->nb_streams_play)\r\nplayback_mask |= 1 << chip->playback_pipe.first_audio;\r\nfor (j = 0; j < chip->nb_streams_capt; j++)\r\ncapture_mask |= 1 << chip->capture_pipe[j].first_audio;\r\n}\r\nreturn pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 1);\r\n}\r\nstatic int pcxhr_dsp_load(struct pcxhr_mgr *mgr, int index,\r\nconst struct firmware *dsp)\r\n{\r\nint err, card_index;\r\ndev_dbg(&mgr->pci->dev,\r\n"loading dsp [%d] size = %zd\n", index, dsp->size);\r\nswitch (index) {\r\ncase PCXHR_FIRMWARE_XLX_INT_INDEX:\r\npcxhr_reset_xilinx_com(mgr);\r\nreturn pcxhr_load_xilinx_binary(mgr, dsp, 0);\r\ncase PCXHR_FIRMWARE_XLX_COM_INDEX:\r\npcxhr_reset_xilinx_com(mgr);\r\nreturn pcxhr_load_xilinx_binary(mgr, dsp, 1);\r\ncase PCXHR_FIRMWARE_DSP_EPRM_INDEX:\r\npcxhr_reset_dsp(mgr);\r\nreturn pcxhr_load_eeprom_binary(mgr, dsp);\r\ncase PCXHR_FIRMWARE_DSP_BOOT_INDEX:\r\nreturn pcxhr_load_boot_binary(mgr, dsp);\r\ncase PCXHR_FIRMWARE_DSP_MAIN_INDEX:\r\nerr = pcxhr_load_dsp_binary(mgr, dsp);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ndefault:\r\ndev_err(&mgr->pci->dev, "wrong file index\n");\r\nreturn -EFAULT;\r\n}\r\nerr = pcxhr_init_board(mgr);\r\nif (err < 0) {\r\ndev_err(&mgr->pci->dev, "pcxhr could not be set up\n");\r\nreturn err;\r\n}\r\nerr = pcxhr_config_pipes(mgr);\r\nif (err < 0) {\r\ndev_err(&mgr->pci->dev, "pcxhr pipes could not be set up\n");\r\nreturn err;\r\n}\r\nfor (card_index = 0; card_index < mgr->num_cards; card_index++) {\r\nstruct snd_pcxhr *chip = mgr->chip[card_index];\r\nif ((err = pcxhr_create_pcm(chip)) < 0)\r\nreturn err;\r\nif (card_index == 0) {\r\nif ((err = pcxhr_create_mixer(chip->mgr)) < 0)\r\nreturn err;\r\n}\r\nif ((err = snd_card_register(chip->card)) < 0)\r\nreturn err;\r\n}\r\nerr = pcxhr_start_pipes(mgr);\r\nif (err < 0) {\r\ndev_err(&mgr->pci->dev, "pcxhr pipes could not be started\n");\r\nreturn err;\r\n}\r\ndev_dbg(&mgr->pci->dev,\r\n"pcxhr firmware downloaded and successfully set up\n");\r\nreturn 0;\r\n}\r\nint pcxhr_setup_firmware(struct pcxhr_mgr *mgr)\r\n{\r\nstatic char *fw_files[][5] = {\r\n[0] = { "xlxint.dat", "xlxc882hr.dat",\r\n"dspe882.e56", "dspb882hr.b56", "dspd882.d56" },\r\n[1] = { "xlxint.dat", "xlxc882e.dat",\r\n"dspe882.e56", "dspb882e.b56", "dspd882.d56" },\r\n[2] = { "xlxint.dat", "xlxc1222hr.dat",\r\n"dspe882.e56", "dspb1222hr.b56", "dspd1222.d56" },\r\n[3] = { "xlxint.dat", "xlxc1222e.dat",\r\n"dspe882.e56", "dspb1222e.b56", "dspd1222.d56" },\r\n[4] = { NULL, "xlxc222.dat",\r\n"dspe924.e56", "dspb924.b56", "dspd222.d56" },\r\n[5] = { NULL, "xlxc924.dat",\r\n"dspe924.e56", "dspb924.b56", "dspd222.d56" },\r\n};\r\nchar path[32];\r\nconst struct firmware *fw_entry;\r\nint i, err;\r\nint fw_set = mgr->fw_file_set;\r\nfor (i = 0; i < 5; i++) {\r\nif (!fw_files[fw_set][i])\r\ncontinue;\r\nsprintf(path, "pcxhr/%s", fw_files[fw_set][i]);\r\nif (request_firmware(&fw_entry, path, &mgr->pci->dev)) {\r\ndev_err(&mgr->pci->dev,\r\n"pcxhr: can't load firmware %s\n",\r\npath);\r\nreturn -ENOENT;\r\n}\r\nerr = pcxhr_dsp_load(mgr, i, fw_entry);\r\nrelease_firmware(fw_entry);\r\nif (err < 0)\r\nreturn err;\r\nmgr->dsp_loaded |= 1 << i;\r\n}\r\nreturn 0;\r\n}
