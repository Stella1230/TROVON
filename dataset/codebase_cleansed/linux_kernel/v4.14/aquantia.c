static int aquantia_config_aneg(struct phy_device *phydev)\r\n{\r\nphydev->supported = PHY_AQUANTIA_FEATURES;\r\nphydev->advertising = phydev->supported;\r\nreturn 0;\r\n}\r\nstatic int aquantia_aneg_done(struct phy_device *phydev)\r\n{\r\nint reg;\r\nreg = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_STAT1);\r\nreturn (reg < 0) ? reg : (reg & BMSR_ANEGCOMPLETE);\r\n}\r\nstatic int aquantia_config_intr(struct phy_device *phydev)\r\n{\r\nint err;\r\nif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\r\nerr = phy_write_mmd(phydev, MDIO_MMD_AN, 0xd401, 1);\r\nif (err < 0)\r\nreturn err;\r\nerr = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0xff00, 1);\r\nif (err < 0)\r\nreturn err;\r\nerr = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0xff01, 0x1001);\r\n} else {\r\nerr = phy_write_mmd(phydev, MDIO_MMD_AN, 0xd401, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0xff00, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0xff01, 0);\r\n}\r\nreturn err;\r\n}\r\nstatic int aquantia_ack_interrupt(struct phy_device *phydev)\r\n{\r\nint reg;\r\nreg = phy_read_mmd(phydev, MDIO_MMD_AN, 0xcc01);\r\nreturn (reg < 0) ? reg : 0;\r\n}\r\nstatic int aquantia_read_status(struct phy_device *phydev)\r\n{\r\nint reg;\r\nreg = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_STAT1);\r\nreg = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_STAT1);\r\nif (reg & MDIO_STAT1_LSTATUS)\r\nphydev->link = 1;\r\nelse\r\nphydev->link = 0;\r\nreg = phy_read_mmd(phydev, MDIO_MMD_AN, 0xc800);\r\nmdelay(10);\r\nreg = phy_read_mmd(phydev, MDIO_MMD_AN, 0xc800);\r\nswitch (reg) {\r\ncase 0x9:\r\nphydev->speed = SPEED_2500;\r\nbreak;\r\ncase 0x5:\r\nphydev->speed = SPEED_1000;\r\nbreak;\r\ncase 0x3:\r\nphydev->speed = SPEED_100;\r\nbreak;\r\ncase 0x7:\r\ndefault:\r\nphydev->speed = SPEED_10000;\r\nbreak;\r\n}\r\nphydev->duplex = DUPLEX_FULL;\r\nreturn 0;\r\n}
