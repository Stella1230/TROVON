static void uwb_rsv_fill_column_alloc(struct uwb_rsv_alloc_info *ai)\r\n{\r\nint col, mas, safe_mas, unsafe_mas;\r\nunsigned char *bm = ai->bm;\r\nstruct uwb_rsv_col_info *ci = ai->ci;\r\nunsigned char c;\r\nfor (col = ci->csi.start_col; col < UWB_NUM_ZONES; col += ci->csi.interval) {\r\nsafe_mas = ci->csi.safe_mas_per_col;\r\nunsafe_mas = ci->csi.unsafe_mas_per_col;\r\nfor (mas = 0; mas < UWB_MAS_PER_ZONE; mas++ ) {\r\nif (bm[col * UWB_MAS_PER_ZONE + mas] == 0) {\r\nif (safe_mas > 0) {\r\nsafe_mas--;\r\nc = UWB_RSV_MAS_SAFE;\r\n} else if (unsafe_mas > 0) {\r\nunsafe_mas--;\r\nc = UWB_RSV_MAS_UNSAFE;\r\n} else {\r\nbreak;\r\n}\r\nbm[col * UWB_MAS_PER_ZONE + mas] = c;\r\n}\r\n}\r\n}\r\n}\r\nstatic void uwb_rsv_fill_row_alloc(struct uwb_rsv_alloc_info *ai)\r\n{\r\nint mas, col, rows;\r\nunsigned char *bm = ai->bm;\r\nstruct uwb_rsv_row_info *ri = &ai->ri;\r\nunsigned char c;\r\nrows = 1;\r\nc = UWB_RSV_MAS_SAFE;\r\nfor (mas = UWB_MAS_PER_ZONE - 1; mas >= 0; mas--) {\r\nif (ri->avail[mas] == 1) {\r\nif (rows > ri->used_rows) {\r\nbreak;\r\n} else if (rows > 7) {\r\nc = UWB_RSV_MAS_UNSAFE;\r\n}\r\nfor (col = 0; col < UWB_NUM_ZONES; col++) {\r\nif (bm[col * UWB_NUM_ZONES + mas] != UWB_RSV_MAS_NOT_AVAIL) {\r\nbm[col * UWB_NUM_ZONES + mas] = c;\r\nif(c == UWB_RSV_MAS_SAFE)\r\nai->safe_allocated_mases++;\r\nelse\r\nai->unsafe_allocated_mases++;\r\n}\r\n}\r\nrows++;\r\n}\r\n}\r\nai->total_allocated_mases = ai->safe_allocated_mases + ai->unsafe_allocated_mases;\r\n}\r\nstatic int uwb_rsv_find_best_column_set(struct uwb_rsv_alloc_info *ai, int interval,\r\nint num_safe_mas, int num_unsafe_mas)\r\n{\r\nstruct uwb_rsv_col_info *ci = ai->ci;\r\nstruct uwb_rsv_col_set_info *csi = &ci->csi;\r\nstruct uwb_rsv_col_set_info tmp_csi;\r\nint deep, set, col, start_col_deep, col_start_set;\r\nint start_col, max_mas_in_set, lowest_max_mas_in_deep;\r\nint n_mas;\r\nint found = UWB_RSV_ALLOC_NOT_FOUND;\r\ntmp_csi.start_col = 0;\r\nstart_col_deep = interval;\r\nn_mas = num_unsafe_mas + num_safe_mas;\r\nfor (deep = 0; ((interval >> deep) & 0x1) == 0; deep++) {\r\nstart_col_deep /= 2;\r\ncol_start_set = 0;\r\nlowest_max_mas_in_deep = UWB_MAS_PER_ZONE;\r\nfor (set = 1; set <= (1 << deep); set++) {\r\nmax_mas_in_set = 0;\r\nstart_col = start_col_deep + col_start_set;\r\nfor (col = start_col; col < UWB_NUM_ZONES; col += interval) {\r\nif (ci[col].max_avail_safe >= num_safe_mas &&\r\nci[col].max_avail_unsafe >= n_mas) {\r\nif (ci[col].highest_mas[n_mas] > max_mas_in_set)\r\nmax_mas_in_set = ci[col].highest_mas[n_mas];\r\n} else {\r\nmax_mas_in_set = 0;\r\nbreak;\r\n}\r\n}\r\nif ((lowest_max_mas_in_deep > max_mas_in_set) && max_mas_in_set) {\r\nlowest_max_mas_in_deep = max_mas_in_set;\r\ntmp_csi.start_col = start_col;\r\n}\r\ncol_start_set += (interval >> deep);\r\n}\r\nif (lowest_max_mas_in_deep < 8) {\r\ncsi->start_col = tmp_csi.start_col;\r\nfound = UWB_RSV_ALLOC_FOUND;\r\nbreak;\r\n} else if ((lowest_max_mas_in_deep > 8) &&\r\n(lowest_max_mas_in_deep != UWB_MAS_PER_ZONE) &&\r\n(found == UWB_RSV_ALLOC_NOT_FOUND)) {\r\ncsi->start_col = tmp_csi.start_col;\r\nfound = UWB_RSV_ALLOC_FOUND;\r\n}\r\n}\r\nif (found == UWB_RSV_ALLOC_FOUND) {\r\ncsi->interval = interval;\r\ncsi->safe_mas_per_col = num_safe_mas;\r\ncsi->unsafe_mas_per_col = num_unsafe_mas;\r\nai->safe_allocated_mases = (UWB_NUM_ZONES / interval) * num_safe_mas;\r\nai->unsafe_allocated_mases = (UWB_NUM_ZONES / interval) * num_unsafe_mas;\r\nai->total_allocated_mases = ai->safe_allocated_mases + ai->unsafe_allocated_mases;\r\nai->interval = interval;\r\n}\r\nreturn found;\r\n}\r\nstatic void get_row_descriptors(struct uwb_rsv_alloc_info *ai)\r\n{\r\nunsigned char *bm = ai->bm;\r\nstruct uwb_rsv_row_info *ri = &ai->ri;\r\nint col, mas;\r\nri->free_rows = 16;\r\nfor (mas = 0; mas < UWB_MAS_PER_ZONE; mas ++) {\r\nri->avail[mas] = 1;\r\nfor (col = 1; col < UWB_NUM_ZONES; col++) {\r\nif (bm[col * UWB_NUM_ZONES + mas] == UWB_RSV_MAS_NOT_AVAIL) {\r\nri->free_rows--;\r\nri->avail[mas]=0;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void uwb_rsv_fill_column_info(unsigned char *bm, int column, struct uwb_rsv_col_info *rci)\r\n{\r\nint mas;\r\nint block_count = 0, start_block = 0;\r\nint previous_avail = 0;\r\nint available = 0;\r\nint safe_mas_in_row[UWB_MAS_PER_ZONE] = {\r\n8, 7, 6, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 2, 1,\r\n};\r\nrci->max_avail_safe = 0;\r\nfor (mas = 0; mas < UWB_MAS_PER_ZONE; mas ++) {\r\nif (!bm[column * UWB_NUM_ZONES + mas]) {\r\navailable++;\r\nrci->max_avail_unsafe = available;\r\nrci->highest_mas[available] = mas;\r\nif (previous_avail) {\r\nblock_count++;\r\nif ((block_count > safe_mas_in_row[start_block]) &&\r\n(!rci->max_avail_safe))\r\nrci->max_avail_safe = available - 1;\r\n} else {\r\nprevious_avail = 1;\r\nstart_block = mas;\r\nblock_count = 1;\r\n}\r\n} else {\r\nprevious_avail = 0;\r\n}\r\n}\r\nif (!rci->max_avail_safe)\r\nrci->max_avail_safe = rci->max_avail_unsafe;\r\n}\r\nstatic void get_column_descriptors(struct uwb_rsv_alloc_info *ai)\r\n{\r\nunsigned char *bm = ai->bm;\r\nstruct uwb_rsv_col_info *ci = ai->ci;\r\nint col;\r\nfor (col = 1; col < UWB_NUM_ZONES; col++) {\r\nuwb_rsv_fill_column_info(bm, col, &ci[col]);\r\n}\r\n}\r\nstatic int uwb_rsv_find_best_row_alloc(struct uwb_rsv_alloc_info *ai)\r\n{\r\nint n_rows;\r\nint max_rows = ai->max_mas / UWB_USABLE_MAS_PER_ROW;\r\nint min_rows = ai->min_mas / UWB_USABLE_MAS_PER_ROW;\r\nif (ai->min_mas % UWB_USABLE_MAS_PER_ROW)\r\nmin_rows++;\r\nfor (n_rows = max_rows; n_rows >= min_rows; n_rows--) {\r\nif (n_rows <= ai->ri.free_rows) {\r\nai->ri.used_rows = n_rows;\r\nai->interval = 1;\r\nuwb_rsv_fill_row_alloc(ai);\r\nreturn UWB_RSV_ALLOC_FOUND;\r\n}\r\n}\r\nreturn UWB_RSV_ALLOC_NOT_FOUND;\r\n}\r\nstatic int uwb_rsv_find_best_col_alloc(struct uwb_rsv_alloc_info *ai, int interval)\r\n{\r\nint n_safe, n_unsafe, n_mas;\r\nint n_column = UWB_NUM_ZONES / interval;\r\nint max_per_zone = ai->max_mas / n_column;\r\nint min_per_zone = ai->min_mas / n_column;\r\nif (ai->min_mas % n_column)\r\nmin_per_zone++;\r\nif (min_per_zone > UWB_MAS_PER_ZONE) {\r\nreturn UWB_RSV_ALLOC_NOT_FOUND;\r\n}\r\nif (max_per_zone > UWB_MAS_PER_ZONE) {\r\nmax_per_zone = UWB_MAS_PER_ZONE;\r\n}\r\nfor (n_mas = max_per_zone; n_mas >= min_per_zone; n_mas--) {\r\nif (uwb_rsv_find_best_column_set(ai, interval, 0, n_mas) == UWB_RSV_ALLOC_NOT_FOUND)\r\ncontinue;\r\nfor (n_safe = n_mas; n_safe >= 0; n_safe--) {\r\nn_unsafe = n_mas - n_safe;\r\nif (uwb_rsv_find_best_column_set(ai, interval, n_safe, n_unsafe) == UWB_RSV_ALLOC_FOUND) {\r\nuwb_rsv_fill_column_alloc(ai);\r\nreturn UWB_RSV_ALLOC_FOUND;\r\n}\r\n}\r\n}\r\nreturn UWB_RSV_ALLOC_NOT_FOUND;\r\n}\r\nint uwb_rsv_find_best_allocation(struct uwb_rsv *rsv, struct uwb_mas_bm *available,\r\nstruct uwb_mas_bm *result)\r\n{\r\nstruct uwb_rsv_alloc_info *ai;\r\nint interval;\r\nint bit_index;\r\nai = kzalloc(sizeof(struct uwb_rsv_alloc_info), GFP_KERNEL);\r\nif (!ai)\r\nreturn UWB_RSV_ALLOC_NOT_FOUND;\r\nai->min_mas = rsv->min_mas;\r\nai->max_mas = rsv->max_mas;\r\nai->max_interval = rsv->max_interval;\r\nfor_each_clear_bit(bit_index, available->bm, UWB_NUM_MAS)\r\nai->bm[bit_index] = UWB_RSV_MAS_NOT_AVAIL;\r\nif (ai->max_interval == 1) {\r\nget_row_descriptors(ai);\r\nif (uwb_rsv_find_best_row_alloc(ai) == UWB_RSV_ALLOC_FOUND)\r\ngoto alloc_found;\r\nelse\r\ngoto alloc_not_found;\r\n}\r\nget_column_descriptors(ai);\r\nfor (interval = 16; interval >= 2; interval>>=1) {\r\nif (interval > ai->max_interval)\r\ncontinue;\r\nif (uwb_rsv_find_best_col_alloc(ai, interval) == UWB_RSV_ALLOC_FOUND)\r\ngoto alloc_found;\r\n}\r\nget_row_descriptors(ai);\r\nif (uwb_rsv_find_best_row_alloc(ai) == UWB_RSV_ALLOC_FOUND)\r\ngoto alloc_found;\r\nelse\r\ngoto alloc_not_found;\r\nalloc_found:\r\nbitmap_zero(result->bm, UWB_NUM_MAS);\r\nbitmap_zero(result->unsafe_bm, UWB_NUM_MAS);\r\nfor (bit_index = 0; bit_index < UWB_NUM_MAS; bit_index++) {\r\nif (ai->bm[bit_index] == UWB_RSV_MAS_SAFE)\r\nset_bit(bit_index, result->bm);\r\nelse if (ai->bm[bit_index] == UWB_RSV_MAS_UNSAFE)\r\nset_bit(bit_index, result->unsafe_bm);\r\n}\r\nbitmap_or(result->bm, result->bm, result->unsafe_bm, UWB_NUM_MAS);\r\nresult->safe = ai->safe_allocated_mases;\r\nresult->unsafe = ai->unsafe_allocated_mases;\r\nkfree(ai);\r\nreturn UWB_RSV_ALLOC_FOUND;\r\nalloc_not_found:\r\nkfree(ai);\r\nreturn UWB_RSV_ALLOC_NOT_FOUND;\r\n}
