static u32 page_to_balloon_pfn(struct page *page)\r\n{\r\nunsigned long pfn = page_to_pfn(page);\r\nBUILD_BUG_ON(PAGE_SHIFT < VIRTIO_BALLOON_PFN_SHIFT);\r\nreturn pfn * VIRTIO_BALLOON_PAGES_PER_PAGE;\r\n}\r\nstatic void balloon_ack(struct virtqueue *vq)\r\n{\r\nstruct virtio_balloon *vb = vq->vdev->priv;\r\nwake_up(&vb->acked);\r\n}\r\nstatic void tell_host(struct virtio_balloon *vb, struct virtqueue *vq)\r\n{\r\nstruct scatterlist sg;\r\nunsigned int len;\r\nsg_init_one(&sg, vb->pfns, sizeof(vb->pfns[0]) * vb->num_pfns);\r\nvirtqueue_add_outbuf(vq, &sg, 1, vb, GFP_KERNEL);\r\nvirtqueue_kick(vq);\r\nwait_event(vb->acked, virtqueue_get_buf(vq, &len));\r\n}\r\nstatic void set_page_pfns(struct virtio_balloon *vb,\r\n__virtio32 pfns[], struct page *page)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < VIRTIO_BALLOON_PAGES_PER_PAGE; i++)\r\npfns[i] = cpu_to_virtio32(vb->vdev,\r\npage_to_balloon_pfn(page) + i);\r\n}\r\nstatic unsigned fill_balloon(struct virtio_balloon *vb, size_t num)\r\n{\r\nstruct balloon_dev_info *vb_dev_info = &vb->vb_dev_info;\r\nunsigned num_allocated_pages;\r\nnum = min(num, ARRAY_SIZE(vb->pfns));\r\nmutex_lock(&vb->balloon_lock);\r\nfor (vb->num_pfns = 0; vb->num_pfns < num;\r\nvb->num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) {\r\nstruct page *page = balloon_page_enqueue(vb_dev_info);\r\nif (!page) {\r\ndev_info_ratelimited(&vb->vdev->dev,\r\n"Out of puff! Can't get %u pages\n",\r\nVIRTIO_BALLOON_PAGES_PER_PAGE);\r\nmsleep(200);\r\nbreak;\r\n}\r\nset_page_pfns(vb, vb->pfns + vb->num_pfns, page);\r\nvb->num_pages += VIRTIO_BALLOON_PAGES_PER_PAGE;\r\nif (!virtio_has_feature(vb->vdev,\r\nVIRTIO_BALLOON_F_DEFLATE_ON_OOM))\r\nadjust_managed_page_count(page, -1);\r\n}\r\nnum_allocated_pages = vb->num_pfns;\r\nif (vb->num_pfns != 0)\r\ntell_host(vb, vb->inflate_vq);\r\nmutex_unlock(&vb->balloon_lock);\r\nreturn num_allocated_pages;\r\n}\r\nstatic void release_pages_balloon(struct virtio_balloon *vb,\r\nstruct list_head *pages)\r\n{\r\nstruct page *page, *next;\r\nlist_for_each_entry_safe(page, next, pages, lru) {\r\nif (!virtio_has_feature(vb->vdev,\r\nVIRTIO_BALLOON_F_DEFLATE_ON_OOM))\r\nadjust_managed_page_count(page, 1);\r\nlist_del(&page->lru);\r\nput_page(page);\r\n}\r\n}\r\nstatic unsigned leak_balloon(struct virtio_balloon *vb, size_t num)\r\n{\r\nunsigned num_freed_pages;\r\nstruct page *page;\r\nstruct balloon_dev_info *vb_dev_info = &vb->vb_dev_info;\r\nLIST_HEAD(pages);\r\nnum = min(num, ARRAY_SIZE(vb->pfns));\r\nmutex_lock(&vb->balloon_lock);\r\nnum = min(num, (size_t)vb->num_pages);\r\nfor (vb->num_pfns = 0; vb->num_pfns < num;\r\nvb->num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) {\r\npage = balloon_page_dequeue(vb_dev_info);\r\nif (!page)\r\nbreak;\r\nset_page_pfns(vb, vb->pfns + vb->num_pfns, page);\r\nlist_add(&page->lru, &pages);\r\nvb->num_pages -= VIRTIO_BALLOON_PAGES_PER_PAGE;\r\n}\r\nnum_freed_pages = vb->num_pfns;\r\nif (vb->num_pfns != 0)\r\ntell_host(vb, vb->deflate_vq);\r\nrelease_pages_balloon(vb, &pages);\r\nmutex_unlock(&vb->balloon_lock);\r\nreturn num_freed_pages;\r\n}\r\nstatic inline void update_stat(struct virtio_balloon *vb, int idx,\r\nu16 tag, u64 val)\r\n{\r\nBUG_ON(idx >= VIRTIO_BALLOON_S_NR);\r\nvb->stats[idx].tag = cpu_to_virtio16(vb->vdev, tag);\r\nvb->stats[idx].val = cpu_to_virtio64(vb->vdev, val);\r\n}\r\nstatic unsigned int update_balloon_stats(struct virtio_balloon *vb)\r\n{\r\nunsigned long events[NR_VM_EVENT_ITEMS];\r\nstruct sysinfo i;\r\nunsigned int idx = 0;\r\nlong available;\r\nall_vm_events(events);\r\nsi_meminfo(&i);\r\navailable = si_mem_available();\r\n#ifdef CONFIG_VM_EVENT_COUNTERS\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_SWAP_IN,\r\npages_to_bytes(events[PSWPIN]));\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_SWAP_OUT,\r\npages_to_bytes(events[PSWPOUT]));\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MAJFLT, events[PGMAJFAULT]);\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MINFLT, events[PGFAULT]);\r\n#endif\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MEMFREE,\r\npages_to_bytes(i.freeram));\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MEMTOT,\r\npages_to_bytes(i.totalram));\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_AVAIL,\r\npages_to_bytes(available));\r\nreturn idx;\r\n}\r\nstatic void stats_request(struct virtqueue *vq)\r\n{\r\nstruct virtio_balloon *vb = vq->vdev->priv;\r\nspin_lock(&vb->stop_update_lock);\r\nif (!vb->stop_update)\r\nqueue_work(system_freezable_wq, &vb->update_balloon_stats_work);\r\nspin_unlock(&vb->stop_update_lock);\r\n}\r\nstatic void stats_handle_request(struct virtio_balloon *vb)\r\n{\r\nstruct virtqueue *vq;\r\nstruct scatterlist sg;\r\nunsigned int len, num_stats;\r\nnum_stats = update_balloon_stats(vb);\r\nvq = vb->stats_vq;\r\nif (!virtqueue_get_buf(vq, &len))\r\nreturn;\r\nsg_init_one(&sg, vb->stats, sizeof(vb->stats[0]) * num_stats);\r\nvirtqueue_add_outbuf(vq, &sg, 1, vb, GFP_KERNEL);\r\nvirtqueue_kick(vq);\r\n}\r\nstatic void virtballoon_changed(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb = vdev->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vb->stop_update_lock, flags);\r\nif (!vb->stop_update)\r\nqueue_work(system_freezable_wq, &vb->update_balloon_size_work);\r\nspin_unlock_irqrestore(&vb->stop_update_lock, flags);\r\n}\r\nstatic inline s64 towards_target(struct virtio_balloon *vb)\r\n{\r\ns64 target;\r\nu32 num_pages;\r\nvirtio_cread(vb->vdev, struct virtio_balloon_config, num_pages,\r\n&num_pages);\r\nif (!virtio_has_feature(vb->vdev, VIRTIO_F_VERSION_1))\r\nnum_pages = le32_to_cpu((__force __le32)num_pages);\r\ntarget = num_pages;\r\nreturn target - vb->num_pages;\r\n}\r\nstatic void update_balloon_size(struct virtio_balloon *vb)\r\n{\r\nu32 actual = vb->num_pages;\r\nif (!virtio_has_feature(vb->vdev, VIRTIO_F_VERSION_1))\r\nactual = (__force u32)cpu_to_le32(actual);\r\nvirtio_cwrite(vb->vdev, struct virtio_balloon_config, actual,\r\n&actual);\r\n}\r\nstatic int virtballoon_oom_notify(struct notifier_block *self,\r\nunsigned long dummy, void *parm)\r\n{\r\nstruct virtio_balloon *vb;\r\nunsigned long *freed;\r\nunsigned num_freed_pages;\r\nvb = container_of(self, struct virtio_balloon, nb);\r\nif (!virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_DEFLATE_ON_OOM))\r\nreturn NOTIFY_OK;\r\nfreed = parm;\r\nnum_freed_pages = leak_balloon(vb, oom_pages);\r\nupdate_balloon_size(vb);\r\n*freed += num_freed_pages;\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void update_balloon_stats_func(struct work_struct *work)\r\n{\r\nstruct virtio_balloon *vb;\r\nvb = container_of(work, struct virtio_balloon,\r\nupdate_balloon_stats_work);\r\nstats_handle_request(vb);\r\n}\r\nstatic void update_balloon_size_func(struct work_struct *work)\r\n{\r\nstruct virtio_balloon *vb;\r\ns64 diff;\r\nvb = container_of(work, struct virtio_balloon,\r\nupdate_balloon_size_work);\r\ndiff = towards_target(vb);\r\nif (diff > 0)\r\ndiff -= fill_balloon(vb, diff);\r\nelse if (diff < 0)\r\ndiff += leak_balloon(vb, -diff);\r\nupdate_balloon_size(vb);\r\nif (diff)\r\nqueue_work(system_freezable_wq, work);\r\n}\r\nstatic int init_vqs(struct virtio_balloon *vb)\r\n{\r\nstruct virtqueue *vqs[3];\r\nvq_callback_t *callbacks[] = { balloon_ack, balloon_ack, stats_request };\r\nstatic const char * const names[] = { "inflate", "deflate", "stats" };\r\nint err, nvqs;\r\nnvqs = virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_STATS_VQ) ? 3 : 2;\r\nerr = virtio_find_vqs(vb->vdev, nvqs, vqs, callbacks, names, NULL);\r\nif (err)\r\nreturn err;\r\nvb->inflate_vq = vqs[0];\r\nvb->deflate_vq = vqs[1];\r\nif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_STATS_VQ)) {\r\nstruct scatterlist sg;\r\nunsigned int num_stats;\r\nvb->stats_vq = vqs[2];\r\nnum_stats = update_balloon_stats(vb);\r\nsg_init_one(&sg, vb->stats, sizeof(vb->stats[0]) * num_stats);\r\nif (virtqueue_add_outbuf(vb->stats_vq, &sg, 1, vb, GFP_KERNEL)\r\n< 0)\r\nBUG();\r\nvirtqueue_kick(vb->stats_vq);\r\n}\r\nreturn 0;\r\n}\r\nstatic int virtballoon_migratepage(struct balloon_dev_info *vb_dev_info,\r\nstruct page *newpage, struct page *page, enum migrate_mode mode)\r\n{\r\nstruct virtio_balloon *vb = container_of(vb_dev_info,\r\nstruct virtio_balloon, vb_dev_info);\r\nunsigned long flags;\r\nif (!mutex_trylock(&vb->balloon_lock))\r\nreturn -EAGAIN;\r\nget_page(newpage);\r\nspin_lock_irqsave(&vb_dev_info->pages_lock, flags);\r\nballoon_page_insert(vb_dev_info, newpage);\r\nvb_dev_info->isolated_pages--;\r\n__count_vm_event(BALLOON_MIGRATE);\r\nspin_unlock_irqrestore(&vb_dev_info->pages_lock, flags);\r\nvb->num_pfns = VIRTIO_BALLOON_PAGES_PER_PAGE;\r\nset_page_pfns(vb, vb->pfns, newpage);\r\ntell_host(vb, vb->inflate_vq);\r\nballoon_page_delete(page);\r\nvb->num_pfns = VIRTIO_BALLOON_PAGES_PER_PAGE;\r\nset_page_pfns(vb, vb->pfns, page);\r\ntell_host(vb, vb->deflate_vq);\r\nmutex_unlock(&vb->balloon_lock);\r\nput_page(page);\r\nreturn MIGRATEPAGE_SUCCESS;\r\n}\r\nstatic struct dentry *balloon_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nstatic const struct dentry_operations ops = {\r\n.d_dname = simple_dname,\r\n};\r\nreturn mount_pseudo(fs_type, "balloon-kvm:", NULL, &ops,\r\nBALLOON_KVM_MAGIC);\r\n}\r\nstatic int virtballoon_probe(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb;\r\nint err;\r\nif (!vdev->config->get) {\r\ndev_err(&vdev->dev, "%s failure: config access disabled\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nvdev->priv = vb = kmalloc(sizeof(*vb), GFP_KERNEL);\r\nif (!vb) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nINIT_WORK(&vb->update_balloon_stats_work, update_balloon_stats_func);\r\nINIT_WORK(&vb->update_balloon_size_work, update_balloon_size_func);\r\nspin_lock_init(&vb->stop_update_lock);\r\nvb->stop_update = false;\r\nvb->num_pages = 0;\r\nmutex_init(&vb->balloon_lock);\r\ninit_waitqueue_head(&vb->acked);\r\nvb->vdev = vdev;\r\nballoon_devinfo_init(&vb->vb_dev_info);\r\nerr = init_vqs(vb);\r\nif (err)\r\ngoto out_free_vb;\r\nvb->nb.notifier_call = virtballoon_oom_notify;\r\nvb->nb.priority = VIRTBALLOON_OOM_NOTIFY_PRIORITY;\r\nerr = register_oom_notifier(&vb->nb);\r\nif (err < 0)\r\ngoto out_del_vqs;\r\n#ifdef CONFIG_BALLOON_COMPACTION\r\nballoon_mnt = kern_mount(&balloon_fs);\r\nif (IS_ERR(balloon_mnt)) {\r\nerr = PTR_ERR(balloon_mnt);\r\nunregister_oom_notifier(&vb->nb);\r\ngoto out_del_vqs;\r\n}\r\nvb->vb_dev_info.migratepage = virtballoon_migratepage;\r\nvb->vb_dev_info.inode = alloc_anon_inode(balloon_mnt->mnt_sb);\r\nif (IS_ERR(vb->vb_dev_info.inode)) {\r\nerr = PTR_ERR(vb->vb_dev_info.inode);\r\nkern_unmount(balloon_mnt);\r\nunregister_oom_notifier(&vb->nb);\r\nvb->vb_dev_info.inode = NULL;\r\ngoto out_del_vqs;\r\n}\r\nvb->vb_dev_info.inode->i_mapping->a_ops = &balloon_aops;\r\n#endif\r\nvirtio_device_ready(vdev);\r\nif (towards_target(vb))\r\nvirtballoon_changed(vdev);\r\nreturn 0;\r\nout_del_vqs:\r\nvdev->config->del_vqs(vdev);\r\nout_free_vb:\r\nkfree(vb);\r\nout:\r\nreturn err;\r\n}\r\nstatic void remove_common(struct virtio_balloon *vb)\r\n{\r\nwhile (vb->num_pages)\r\nleak_balloon(vb, vb->num_pages);\r\nupdate_balloon_size(vb);\r\nvb->vdev->config->reset(vb->vdev);\r\nvb->vdev->config->del_vqs(vb->vdev);\r\n}\r\nstatic void virtballoon_remove(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb = vdev->priv;\r\nunregister_oom_notifier(&vb->nb);\r\nspin_lock_irq(&vb->stop_update_lock);\r\nvb->stop_update = true;\r\nspin_unlock_irq(&vb->stop_update_lock);\r\ncancel_work_sync(&vb->update_balloon_size_work);\r\ncancel_work_sync(&vb->update_balloon_stats_work);\r\nremove_common(vb);\r\n#ifdef CONFIG_BALLOON_COMPACTION\r\nif (vb->vb_dev_info.inode)\r\niput(vb->vb_dev_info.inode);\r\nkern_unmount(balloon_mnt);\r\n#endif\r\nkfree(vb);\r\n}\r\nstatic int virtballoon_freeze(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb = vdev->priv;\r\nremove_common(vb);\r\nreturn 0;\r\n}\r\nstatic int virtballoon_restore(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb = vdev->priv;\r\nint ret;\r\nret = init_vqs(vdev->priv);\r\nif (ret)\r\nreturn ret;\r\nvirtio_device_ready(vdev);\r\nif (towards_target(vb))\r\nvirtballoon_changed(vdev);\r\nupdate_balloon_size(vb);\r\nreturn 0;\r\n}\r\nstatic int virtballoon_validate(struct virtio_device *vdev)\r\n{\r\n__virtio_clear_bit(vdev, VIRTIO_F_IOMMU_PLATFORM);\r\nreturn 0;\r\n}
