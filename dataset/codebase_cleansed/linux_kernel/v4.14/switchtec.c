static struct switchtec_dev *to_stdev(struct device *dev)\r\n{\r\nreturn container_of(dev, struct switchtec_dev, dev);\r\n}\r\nstatic struct switchtec_user *stuser_create(struct switchtec_dev *stdev)\r\n{\r\nstruct switchtec_user *stuser;\r\nstuser = kzalloc(sizeof(*stuser), GFP_KERNEL);\r\nif (!stuser)\r\nreturn ERR_PTR(-ENOMEM);\r\nget_device(&stdev->dev);\r\nstuser->stdev = stdev;\r\nkref_init(&stuser->kref);\r\nINIT_LIST_HEAD(&stuser->list);\r\ninit_completion(&stuser->comp);\r\nstuser->event_cnt = atomic_read(&stdev->event_cnt);\r\ndev_dbg(&stdev->dev, "%s: %p\n", __func__, stuser);\r\nreturn stuser;\r\n}\r\nstatic void stuser_free(struct kref *kref)\r\n{\r\nstruct switchtec_user *stuser;\r\nstuser = container_of(kref, struct switchtec_user, kref);\r\ndev_dbg(&stuser->stdev->dev, "%s: %p\n", __func__, stuser);\r\nput_device(&stuser->stdev->dev);\r\nkfree(stuser);\r\n}\r\nstatic void stuser_put(struct switchtec_user *stuser)\r\n{\r\nkref_put(&stuser->kref, stuser_free);\r\n}\r\nstatic void stuser_set_state(struct switchtec_user *stuser,\r\nenum mrpc_state state)\r\n{\r\nconst char * const state_names[] = {\r\n[MRPC_IDLE] = "IDLE",\r\n[MRPC_QUEUED] = "QUEUED",\r\n[MRPC_RUNNING] = "RUNNING",\r\n[MRPC_DONE] = "DONE",\r\n};\r\nstuser->state = state;\r\ndev_dbg(&stuser->stdev->dev, "stuser state %p -> %s",\r\nstuser, state_names[state]);\r\n}\r\nstatic void mrpc_cmd_submit(struct switchtec_dev *stdev)\r\n{\r\nstruct switchtec_user *stuser;\r\nif (stdev->mrpc_busy)\r\nreturn;\r\nif (list_empty(&stdev->mrpc_queue))\r\nreturn;\r\nstuser = list_entry(stdev->mrpc_queue.next, struct switchtec_user,\r\nlist);\r\nstuser_set_state(stuser, MRPC_RUNNING);\r\nstdev->mrpc_busy = 1;\r\nmemcpy_toio(&stdev->mmio_mrpc->input_data,\r\nstuser->data, stuser->data_len);\r\niowrite32(stuser->cmd, &stdev->mmio_mrpc->cmd);\r\nstuser->status = ioread32(&stdev->mmio_mrpc->status);\r\nif (stuser->status != SWITCHTEC_MRPC_STATUS_INPROGRESS)\r\nmrpc_complete_cmd(stdev);\r\nschedule_delayed_work(&stdev->mrpc_timeout,\r\nmsecs_to_jiffies(500));\r\n}\r\nstatic int mrpc_queue_cmd(struct switchtec_user *stuser)\r\n{\r\nstruct switchtec_dev *stdev = stuser->stdev;\r\nkref_get(&stuser->kref);\r\nstuser->read_len = sizeof(stuser->data);\r\nstuser_set_state(stuser, MRPC_QUEUED);\r\ninit_completion(&stuser->comp);\r\nlist_add_tail(&stuser->list, &stdev->mrpc_queue);\r\nmrpc_cmd_submit(stdev);\r\nreturn 0;\r\n}\r\nstatic void mrpc_complete_cmd(struct switchtec_dev *stdev)\r\n{\r\nstruct switchtec_user *stuser;\r\nif (list_empty(&stdev->mrpc_queue))\r\nreturn;\r\nstuser = list_entry(stdev->mrpc_queue.next, struct switchtec_user,\r\nlist);\r\nstuser->status = ioread32(&stdev->mmio_mrpc->status);\r\nif (stuser->status == SWITCHTEC_MRPC_STATUS_INPROGRESS)\r\nreturn;\r\nstuser_set_state(stuser, MRPC_DONE);\r\nstuser->return_code = 0;\r\nif (stuser->status != SWITCHTEC_MRPC_STATUS_DONE)\r\ngoto out;\r\nstuser->return_code = ioread32(&stdev->mmio_mrpc->ret_value);\r\nif (stuser->return_code != 0)\r\ngoto out;\r\nmemcpy_fromio(stuser->data, &stdev->mmio_mrpc->output_data,\r\nstuser->read_len);\r\nout:\r\ncomplete_all(&stuser->comp);\r\nlist_del_init(&stuser->list);\r\nstuser_put(stuser);\r\nstdev->mrpc_busy = 0;\r\nmrpc_cmd_submit(stdev);\r\n}\r\nstatic void mrpc_event_work(struct work_struct *work)\r\n{\r\nstruct switchtec_dev *stdev;\r\nstdev = container_of(work, struct switchtec_dev, mrpc_work);\r\ndev_dbg(&stdev->dev, "%s\n", __func__);\r\nmutex_lock(&stdev->mrpc_mutex);\r\ncancel_delayed_work(&stdev->mrpc_timeout);\r\nmrpc_complete_cmd(stdev);\r\nmutex_unlock(&stdev->mrpc_mutex);\r\n}\r\nstatic void mrpc_timeout_work(struct work_struct *work)\r\n{\r\nstruct switchtec_dev *stdev;\r\nu32 status;\r\nstdev = container_of(work, struct switchtec_dev, mrpc_timeout.work);\r\ndev_dbg(&stdev->dev, "%s\n", __func__);\r\nmutex_lock(&stdev->mrpc_mutex);\r\nstatus = ioread32(&stdev->mmio_mrpc->status);\r\nif (status == SWITCHTEC_MRPC_STATUS_INPROGRESS) {\r\nschedule_delayed_work(&stdev->mrpc_timeout,\r\nmsecs_to_jiffies(500));\r\ngoto out;\r\n}\r\nmrpc_complete_cmd(stdev);\r\nout:\r\nmutex_unlock(&stdev->mrpc_mutex);\r\n}\r\nstatic ssize_t device_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct switchtec_dev *stdev = to_stdev(dev);\r\nu32 ver;\r\nver = ioread32(&stdev->mmio_sys_info->device_version);\r\nreturn sprintf(buf, "%x\n", ver);\r\n}\r\nstatic ssize_t fw_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct switchtec_dev *stdev = to_stdev(dev);\r\nu32 ver;\r\nver = ioread32(&stdev->mmio_sys_info->firmware_version);\r\nreturn sprintf(buf, "%08x\n", ver);\r\n}\r\nstatic ssize_t io_string_show(char *buf, void __iomem *attr, size_t len)\r\n{\r\nint i;\r\nmemcpy_fromio(buf, attr, len);\r\nbuf[len] = '\n';\r\nbuf[len + 1] = 0;\r\nfor (i = len - 1; i > 0; i--) {\r\nif (buf[i] != ' ')\r\nbreak;\r\nbuf[i] = '\n';\r\nbuf[i + 1] = 0;\r\n}\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t component_id_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct switchtec_dev *stdev = to_stdev(dev);\r\nint id = ioread16(&stdev->mmio_sys_info->component_id);\r\nreturn sprintf(buf, "PM%04X\n", id);\r\n}\r\nstatic ssize_t component_revision_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct switchtec_dev *stdev = to_stdev(dev);\r\nint rev = ioread8(&stdev->mmio_sys_info->component_revision);\r\nreturn sprintf(buf, "%d\n", rev);\r\n}\r\nstatic ssize_t partition_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct switchtec_dev *stdev = to_stdev(dev);\r\nreturn sprintf(buf, "%d\n", stdev->partition);\r\n}\r\nstatic ssize_t partition_count_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct switchtec_dev *stdev = to_stdev(dev);\r\nreturn sprintf(buf, "%d\n", stdev->partition_count);\r\n}\r\nstatic int switchtec_dev_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct switchtec_dev *stdev;\r\nstruct switchtec_user *stuser;\r\nstdev = container_of(inode->i_cdev, struct switchtec_dev, cdev);\r\nstuser = stuser_create(stdev);\r\nif (IS_ERR(stuser))\r\nreturn PTR_ERR(stuser);\r\nfilp->private_data = stuser;\r\nnonseekable_open(inode, filp);\r\ndev_dbg(&stdev->dev, "%s: %p\n", __func__, stuser);\r\nreturn 0;\r\n}\r\nstatic int switchtec_dev_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct switchtec_user *stuser = filp->private_data;\r\nstuser_put(stuser);\r\nreturn 0;\r\n}\r\nstatic int lock_mutex_and_test_alive(struct switchtec_dev *stdev)\r\n{\r\nif (mutex_lock_interruptible(&stdev->mrpc_mutex))\r\nreturn -EINTR;\r\nif (!stdev->alive) {\r\nmutex_unlock(&stdev->mrpc_mutex);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t switchtec_dev_write(struct file *filp, const char __user *data,\r\nsize_t size, loff_t *off)\r\n{\r\nstruct switchtec_user *stuser = filp->private_data;\r\nstruct switchtec_dev *stdev = stuser->stdev;\r\nint rc;\r\nif (size < sizeof(stuser->cmd) ||\r\nsize > sizeof(stuser->cmd) + sizeof(stuser->data))\r\nreturn -EINVAL;\r\nstuser->data_len = size - sizeof(stuser->cmd);\r\nrc = lock_mutex_and_test_alive(stdev);\r\nif (rc)\r\nreturn rc;\r\nif (stuser->state != MRPC_IDLE) {\r\nrc = -EBADE;\r\ngoto out;\r\n}\r\nrc = copy_from_user(&stuser->cmd, data, sizeof(stuser->cmd));\r\nif (rc) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\ndata += sizeof(stuser->cmd);\r\nrc = copy_from_user(&stuser->data, data, size - sizeof(stuser->cmd));\r\nif (rc) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nrc = mrpc_queue_cmd(stuser);\r\nout:\r\nmutex_unlock(&stdev->mrpc_mutex);\r\nif (rc)\r\nreturn rc;\r\nreturn size;\r\n}\r\nstatic ssize_t switchtec_dev_read(struct file *filp, char __user *data,\r\nsize_t size, loff_t *off)\r\n{\r\nstruct switchtec_user *stuser = filp->private_data;\r\nstruct switchtec_dev *stdev = stuser->stdev;\r\nint rc;\r\nif (size < sizeof(stuser->cmd) ||\r\nsize > sizeof(stuser->cmd) + sizeof(stuser->data))\r\nreturn -EINVAL;\r\nrc = lock_mutex_and_test_alive(stdev);\r\nif (rc)\r\nreturn rc;\r\nif (stuser->state == MRPC_IDLE) {\r\nmutex_unlock(&stdev->mrpc_mutex);\r\nreturn -EBADE;\r\n}\r\nstuser->read_len = size - sizeof(stuser->return_code);\r\nmutex_unlock(&stdev->mrpc_mutex);\r\nif (filp->f_flags & O_NONBLOCK) {\r\nif (!try_wait_for_completion(&stuser->comp))\r\nreturn -EAGAIN;\r\n} else {\r\nrc = wait_for_completion_interruptible(&stuser->comp);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nrc = lock_mutex_and_test_alive(stdev);\r\nif (rc)\r\nreturn rc;\r\nif (stuser->state != MRPC_DONE) {\r\nmutex_unlock(&stdev->mrpc_mutex);\r\nreturn -EBADE;\r\n}\r\nrc = copy_to_user(data, &stuser->return_code,\r\nsizeof(stuser->return_code));\r\nif (rc) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\ndata += sizeof(stuser->return_code);\r\nrc = copy_to_user(data, &stuser->data,\r\nsize - sizeof(stuser->return_code));\r\nif (rc) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nstuser_set_state(stuser, MRPC_IDLE);\r\nout:\r\nmutex_unlock(&stdev->mrpc_mutex);\r\nif (stuser->status == SWITCHTEC_MRPC_STATUS_DONE)\r\nreturn size;\r\nelse if (stuser->status == SWITCHTEC_MRPC_STATUS_INTERRUPTED)\r\nreturn -ENXIO;\r\nelse\r\nreturn -EBADMSG;\r\n}\r\nstatic unsigned int switchtec_dev_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct switchtec_user *stuser = filp->private_data;\r\nstruct switchtec_dev *stdev = stuser->stdev;\r\nint ret = 0;\r\npoll_wait(filp, &stuser->comp.wait, wait);\r\npoll_wait(filp, &stdev->event_wq, wait);\r\nif (lock_mutex_and_test_alive(stdev))\r\nreturn POLLIN | POLLRDHUP | POLLOUT | POLLERR | POLLHUP;\r\nmutex_unlock(&stdev->mrpc_mutex);\r\nif (try_wait_for_completion(&stuser->comp))\r\nret |= POLLIN | POLLRDNORM;\r\nif (stuser->event_cnt != atomic_read(&stdev->event_cnt))\r\nret |= POLLPRI | POLLRDBAND;\r\nreturn ret;\r\n}\r\nstatic int ioctl_flash_info(struct switchtec_dev *stdev,\r\nstruct switchtec_ioctl_flash_info __user *uinfo)\r\n{\r\nstruct switchtec_ioctl_flash_info info = {0};\r\nstruct flash_info_regs __iomem *fi = stdev->mmio_flash_info;\r\ninfo.flash_length = ioread32(&fi->flash_length);\r\ninfo.num_partitions = SWITCHTEC_IOCTL_NUM_PARTITIONS;\r\nif (copy_to_user(uinfo, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void set_fw_info_part(struct switchtec_ioctl_flash_part_info *info,\r\nstruct partition_info __iomem *pi)\r\n{\r\ninfo->address = ioread32(&pi->address);\r\ninfo->length = ioread32(&pi->length);\r\n}\r\nstatic int ioctl_flash_part_info(struct switchtec_dev *stdev,\r\nstruct switchtec_ioctl_flash_part_info __user *uinfo)\r\n{\r\nstruct switchtec_ioctl_flash_part_info info = {0};\r\nstruct flash_info_regs __iomem *fi = stdev->mmio_flash_info;\r\nstruct sys_info_regs __iomem *si = stdev->mmio_sys_info;\r\nu32 active_addr = -1;\r\nif (copy_from_user(&info, uinfo, sizeof(info)))\r\nreturn -EFAULT;\r\nswitch (info.flash_partition) {\r\ncase SWITCHTEC_IOCTL_PART_CFG0:\r\nactive_addr = ioread32(&fi->active_cfg);\r\nset_fw_info_part(&info, &fi->cfg0);\r\nif (ioread16(&si->cfg_running) == SWITCHTEC_CFG0_RUNNING)\r\ninfo.active |= SWITCHTEC_IOCTL_PART_RUNNING;\r\nbreak;\r\ncase SWITCHTEC_IOCTL_PART_CFG1:\r\nactive_addr = ioread32(&fi->active_cfg);\r\nset_fw_info_part(&info, &fi->cfg1);\r\nif (ioread16(&si->cfg_running) == SWITCHTEC_CFG1_RUNNING)\r\ninfo.active |= SWITCHTEC_IOCTL_PART_RUNNING;\r\nbreak;\r\ncase SWITCHTEC_IOCTL_PART_IMG0:\r\nactive_addr = ioread32(&fi->active_img);\r\nset_fw_info_part(&info, &fi->img0);\r\nif (ioread16(&si->img_running) == SWITCHTEC_IMG0_RUNNING)\r\ninfo.active |= SWITCHTEC_IOCTL_PART_RUNNING;\r\nbreak;\r\ncase SWITCHTEC_IOCTL_PART_IMG1:\r\nactive_addr = ioread32(&fi->active_img);\r\nset_fw_info_part(&info, &fi->img1);\r\nif (ioread16(&si->img_running) == SWITCHTEC_IMG1_RUNNING)\r\ninfo.active |= SWITCHTEC_IOCTL_PART_RUNNING;\r\nbreak;\r\ncase SWITCHTEC_IOCTL_PART_NVLOG:\r\nset_fw_info_part(&info, &fi->nvlog);\r\nbreak;\r\ncase SWITCHTEC_IOCTL_PART_VENDOR0:\r\nset_fw_info_part(&info, &fi->vendor[0]);\r\nbreak;\r\ncase SWITCHTEC_IOCTL_PART_VENDOR1:\r\nset_fw_info_part(&info, &fi->vendor[1]);\r\nbreak;\r\ncase SWITCHTEC_IOCTL_PART_VENDOR2:\r\nset_fw_info_part(&info, &fi->vendor[2]);\r\nbreak;\r\ncase SWITCHTEC_IOCTL_PART_VENDOR3:\r\nset_fw_info_part(&info, &fi->vendor[3]);\r\nbreak;\r\ncase SWITCHTEC_IOCTL_PART_VENDOR4:\r\nset_fw_info_part(&info, &fi->vendor[4]);\r\nbreak;\r\ncase SWITCHTEC_IOCTL_PART_VENDOR5:\r\nset_fw_info_part(&info, &fi->vendor[5]);\r\nbreak;\r\ncase SWITCHTEC_IOCTL_PART_VENDOR6:\r\nset_fw_info_part(&info, &fi->vendor[6]);\r\nbreak;\r\ncase SWITCHTEC_IOCTL_PART_VENDOR7:\r\nset_fw_info_part(&info, &fi->vendor[7]);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (info.address == active_addr)\r\ninfo.active |= SWITCHTEC_IOCTL_PART_ACTIVE;\r\nif (copy_to_user(uinfo, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ioctl_event_summary(struct switchtec_dev *stdev,\r\nstruct switchtec_user *stuser,\r\nstruct switchtec_ioctl_event_summary __user *usum)\r\n{\r\nstruct switchtec_ioctl_event_summary s = {0};\r\nint i;\r\nu32 reg;\r\ns.global = ioread32(&stdev->mmio_sw_event->global_summary);\r\ns.part_bitmap = ioread32(&stdev->mmio_sw_event->part_event_bitmap);\r\ns.local_part = ioread32(&stdev->mmio_part_cfg->part_event_summary);\r\nfor (i = 0; i < stdev->partition_count; i++) {\r\nreg = ioread32(&stdev->mmio_part_cfg_all[i].part_event_summary);\r\ns.part[i] = reg;\r\n}\r\nfor (i = 0; i < SWITCHTEC_MAX_PFF_CSR; i++) {\r\nreg = ioread16(&stdev->mmio_pff_csr[i].vendor_id);\r\nif (reg != MICROSEMI_VENDOR_ID)\r\nbreak;\r\nreg = ioread32(&stdev->mmio_pff_csr[i].pff_event_summary);\r\ns.pff[i] = reg;\r\n}\r\nif (copy_to_user(usum, &s, sizeof(s)))\r\nreturn -EFAULT;\r\nstuser->event_cnt = atomic_read(&stdev->event_cnt);\r\nreturn 0;\r\n}\r\nstatic u32 __iomem *global_ev_reg(struct switchtec_dev *stdev,\r\nsize_t offset, int index)\r\n{\r\nreturn (void __iomem *)stdev->mmio_sw_event + offset;\r\n}\r\nstatic u32 __iomem *part_ev_reg(struct switchtec_dev *stdev,\r\nsize_t offset, int index)\r\n{\r\nreturn (void __iomem *)&stdev->mmio_part_cfg_all[index] + offset;\r\n}\r\nstatic u32 __iomem *pff_ev_reg(struct switchtec_dev *stdev,\r\nsize_t offset, int index)\r\n{\r\nreturn (void __iomem *)&stdev->mmio_pff_csr[index] + offset;\r\n}\r\nstatic u32 __iomem *event_hdr_addr(struct switchtec_dev *stdev,\r\nint event_id, int index)\r\n{\r\nsize_t off;\r\nif (event_id < 0 || event_id >= SWITCHTEC_IOCTL_MAX_EVENTS)\r\nreturn ERR_PTR(-EINVAL);\r\noff = event_regs[event_id].offset;\r\nif (event_regs[event_id].map_reg == part_ev_reg) {\r\nif (index == SWITCHTEC_IOCTL_EVENT_LOCAL_PART_IDX)\r\nindex = stdev->partition;\r\nelse if (index < 0 || index >= stdev->partition_count)\r\nreturn ERR_PTR(-EINVAL);\r\n} else if (event_regs[event_id].map_reg == pff_ev_reg) {\r\nif (index < 0 || index >= stdev->pff_csr_count)\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn event_regs[event_id].map_reg(stdev, off, index);\r\n}\r\nstatic int event_ctl(struct switchtec_dev *stdev,\r\nstruct switchtec_ioctl_event_ctl *ctl)\r\n{\r\nint i;\r\nu32 __iomem *reg;\r\nu32 hdr;\r\nreg = event_hdr_addr(stdev, ctl->event_id, ctl->index);\r\nif (IS_ERR(reg))\r\nreturn PTR_ERR(reg);\r\nhdr = ioread32(reg);\r\nfor (i = 0; i < ARRAY_SIZE(ctl->data); i++)\r\nctl->data[i] = ioread32(&reg[i + 1]);\r\nctl->occurred = hdr & SWITCHTEC_EVENT_OCCURRED;\r\nctl->count = (hdr >> 5) & 0xFF;\r\nif (!(ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_CLEAR))\r\nhdr &= ~SWITCHTEC_EVENT_CLEAR;\r\nif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_EN_POLL)\r\nhdr |= SWITCHTEC_EVENT_EN_IRQ;\r\nif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_DIS_POLL)\r\nhdr &= ~SWITCHTEC_EVENT_EN_IRQ;\r\nif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_EN_LOG)\r\nhdr |= SWITCHTEC_EVENT_EN_LOG;\r\nif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_DIS_LOG)\r\nhdr &= ~SWITCHTEC_EVENT_EN_LOG;\r\nif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_EN_CLI)\r\nhdr |= SWITCHTEC_EVENT_EN_CLI;\r\nif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_DIS_CLI)\r\nhdr &= ~SWITCHTEC_EVENT_EN_CLI;\r\nif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_EN_FATAL)\r\nhdr |= SWITCHTEC_EVENT_FATAL;\r\nif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_DIS_FATAL)\r\nhdr &= ~SWITCHTEC_EVENT_FATAL;\r\nif (ctl->flags)\r\niowrite32(hdr, reg);\r\nctl->flags = 0;\r\nif (hdr & SWITCHTEC_EVENT_EN_IRQ)\r\nctl->flags |= SWITCHTEC_IOCTL_EVENT_FLAG_EN_POLL;\r\nif (hdr & SWITCHTEC_EVENT_EN_LOG)\r\nctl->flags |= SWITCHTEC_IOCTL_EVENT_FLAG_EN_LOG;\r\nif (hdr & SWITCHTEC_EVENT_EN_CLI)\r\nctl->flags |= SWITCHTEC_IOCTL_EVENT_FLAG_EN_CLI;\r\nif (hdr & SWITCHTEC_EVENT_FATAL)\r\nctl->flags |= SWITCHTEC_IOCTL_EVENT_FLAG_EN_FATAL;\r\nreturn 0;\r\n}\r\nstatic int ioctl_event_ctl(struct switchtec_dev *stdev,\r\nstruct switchtec_ioctl_event_ctl __user *uctl)\r\n{\r\nint ret;\r\nint nr_idxs;\r\nstruct switchtec_ioctl_event_ctl ctl;\r\nif (copy_from_user(&ctl, uctl, sizeof(ctl)))\r\nreturn -EFAULT;\r\nif (ctl.event_id >= SWITCHTEC_IOCTL_MAX_EVENTS)\r\nreturn -EINVAL;\r\nif (ctl.flags & SWITCHTEC_IOCTL_EVENT_FLAG_UNUSED)\r\nreturn -EINVAL;\r\nif (ctl.index == SWITCHTEC_IOCTL_EVENT_IDX_ALL) {\r\nif (event_regs[ctl.event_id].map_reg == global_ev_reg)\r\nnr_idxs = 1;\r\nelse if (event_regs[ctl.event_id].map_reg == part_ev_reg)\r\nnr_idxs = stdev->partition_count;\r\nelse if (event_regs[ctl.event_id].map_reg == pff_ev_reg)\r\nnr_idxs = stdev->pff_csr_count;\r\nelse\r\nreturn -EINVAL;\r\nfor (ctl.index = 0; ctl.index < nr_idxs; ctl.index++) {\r\nret = event_ctl(stdev, &ctl);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n} else {\r\nret = event_ctl(stdev, &ctl);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (copy_to_user(uctl, &ctl, sizeof(ctl)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ioctl_pff_to_port(struct switchtec_dev *stdev,\r\nstruct switchtec_ioctl_pff_port *up)\r\n{\r\nint i, part;\r\nu32 reg;\r\nstruct part_cfg_regs *pcfg;\r\nstruct switchtec_ioctl_pff_port p;\r\nif (copy_from_user(&p, up, sizeof(p)))\r\nreturn -EFAULT;\r\np.port = -1;\r\nfor (part = 0; part < stdev->partition_count; part++) {\r\npcfg = &stdev->mmio_part_cfg_all[part];\r\np.partition = part;\r\nreg = ioread32(&pcfg->usp_pff_inst_id);\r\nif (reg == p.pff) {\r\np.port = 0;\r\nbreak;\r\n}\r\nreg = ioread32(&pcfg->vep_pff_inst_id);\r\nif (reg == p.pff) {\r\np.port = SWITCHTEC_IOCTL_PFF_VEP;\r\nbreak;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(pcfg->dsp_pff_inst_id); i++) {\r\nreg = ioread32(&pcfg->dsp_pff_inst_id[i]);\r\nif (reg != p.pff)\r\ncontinue;\r\np.port = i + 1;\r\nbreak;\r\n}\r\nif (p.port != -1)\r\nbreak;\r\n}\r\nif (copy_to_user(up, &p, sizeof(p)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ioctl_port_to_pff(struct switchtec_dev *stdev,\r\nstruct switchtec_ioctl_pff_port *up)\r\n{\r\nstruct switchtec_ioctl_pff_port p;\r\nstruct part_cfg_regs *pcfg;\r\nif (copy_from_user(&p, up, sizeof(p)))\r\nreturn -EFAULT;\r\nif (p.partition == SWITCHTEC_IOCTL_EVENT_LOCAL_PART_IDX)\r\npcfg = stdev->mmio_part_cfg;\r\nelse if (p.partition < stdev->partition_count)\r\npcfg = &stdev->mmio_part_cfg_all[p.partition];\r\nelse\r\nreturn -EINVAL;\r\nswitch (p.port) {\r\ncase 0:\r\np.pff = ioread32(&pcfg->usp_pff_inst_id);\r\nbreak;\r\ncase SWITCHTEC_IOCTL_PFF_VEP:\r\np.pff = ioread32(&pcfg->vep_pff_inst_id);\r\nbreak;\r\ndefault:\r\nif (p.port > ARRAY_SIZE(pcfg->dsp_pff_inst_id))\r\nreturn -EINVAL;\r\np.pff = ioread32(&pcfg->dsp_pff_inst_id[p.port - 1]);\r\nbreak;\r\n}\r\nif (copy_to_user(up, &p, sizeof(p)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long switchtec_dev_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct switchtec_user *stuser = filp->private_data;\r\nstruct switchtec_dev *stdev = stuser->stdev;\r\nint rc;\r\nvoid __user *argp = (void __user *)arg;\r\nrc = lock_mutex_and_test_alive(stdev);\r\nif (rc)\r\nreturn rc;\r\nswitch (cmd) {\r\ncase SWITCHTEC_IOCTL_FLASH_INFO:\r\nrc = ioctl_flash_info(stdev, argp);\r\nbreak;\r\ncase SWITCHTEC_IOCTL_FLASH_PART_INFO:\r\nrc = ioctl_flash_part_info(stdev, argp);\r\nbreak;\r\ncase SWITCHTEC_IOCTL_EVENT_SUMMARY:\r\nrc = ioctl_event_summary(stdev, stuser, argp);\r\nbreak;\r\ncase SWITCHTEC_IOCTL_EVENT_CTL:\r\nrc = ioctl_event_ctl(stdev, argp);\r\nbreak;\r\ncase SWITCHTEC_IOCTL_PFF_TO_PORT:\r\nrc = ioctl_pff_to_port(stdev, argp);\r\nbreak;\r\ncase SWITCHTEC_IOCTL_PORT_TO_PFF:\r\nrc = ioctl_port_to_pff(stdev, argp);\r\nbreak;\r\ndefault:\r\nrc = -ENOTTY;\r\nbreak;\r\n}\r\nmutex_unlock(&stdev->mrpc_mutex);\r\nreturn rc;\r\n}\r\nstatic void stdev_release(struct device *dev)\r\n{\r\nstruct switchtec_dev *stdev = to_stdev(dev);\r\nkfree(stdev);\r\n}\r\nstatic void stdev_kill(struct switchtec_dev *stdev)\r\n{\r\nstruct switchtec_user *stuser, *tmpuser;\r\npci_clear_master(stdev->pdev);\r\ncancel_delayed_work_sync(&stdev->mrpc_timeout);\r\nmutex_lock(&stdev->mrpc_mutex);\r\nstdev->alive = false;\r\nlist_for_each_entry_safe(stuser, tmpuser, &stdev->mrpc_queue, list) {\r\ncomplete_all(&stuser->comp);\r\nlist_del_init(&stuser->list);\r\nstuser_put(stuser);\r\n}\r\nmutex_unlock(&stdev->mrpc_mutex);\r\nwake_up_interruptible(&stdev->event_wq);\r\n}\r\nstatic struct switchtec_dev *stdev_create(struct pci_dev *pdev)\r\n{\r\nstruct switchtec_dev *stdev;\r\nint minor;\r\nstruct device *dev;\r\nstruct cdev *cdev;\r\nint rc;\r\nstdev = kzalloc_node(sizeof(*stdev), GFP_KERNEL,\r\ndev_to_node(&pdev->dev));\r\nif (!stdev)\r\nreturn ERR_PTR(-ENOMEM);\r\nstdev->alive = true;\r\nstdev->pdev = pdev;\r\nINIT_LIST_HEAD(&stdev->mrpc_queue);\r\nmutex_init(&stdev->mrpc_mutex);\r\nstdev->mrpc_busy = 0;\r\nINIT_WORK(&stdev->mrpc_work, mrpc_event_work);\r\nINIT_DELAYED_WORK(&stdev->mrpc_timeout, mrpc_timeout_work);\r\ninit_waitqueue_head(&stdev->event_wq);\r\natomic_set(&stdev->event_cnt, 0);\r\ndev = &stdev->dev;\r\ndevice_initialize(dev);\r\ndev->class = switchtec_class;\r\ndev->parent = &pdev->dev;\r\ndev->groups = switchtec_device_groups;\r\ndev->release = stdev_release;\r\nminor = ida_simple_get(&switchtec_minor_ida, 0, 0,\r\nGFP_KERNEL);\r\nif (minor < 0) {\r\nrc = minor;\r\ngoto err_put;\r\n}\r\ndev->devt = MKDEV(MAJOR(switchtec_devt), minor);\r\ndev_set_name(dev, "switchtec%d", minor);\r\ncdev = &stdev->cdev;\r\ncdev_init(cdev, &switchtec_fops);\r\ncdev->owner = THIS_MODULE;\r\nreturn stdev;\r\nerr_put:\r\nput_device(&stdev->dev);\r\nreturn ERR_PTR(rc);\r\n}\r\nstatic int mask_event(struct switchtec_dev *stdev, int eid, int idx)\r\n{\r\nsize_t off = event_regs[eid].offset;\r\nu32 __iomem *hdr_reg;\r\nu32 hdr;\r\nhdr_reg = event_regs[eid].map_reg(stdev, off, idx);\r\nhdr = ioread32(hdr_reg);\r\nif (!(hdr & SWITCHTEC_EVENT_OCCURRED && hdr & SWITCHTEC_EVENT_EN_IRQ))\r\nreturn 0;\r\ndev_dbg(&stdev->dev, "%s: %d %d %x\n", __func__, eid, idx, hdr);\r\nhdr &= ~(SWITCHTEC_EVENT_EN_IRQ | SWITCHTEC_EVENT_OCCURRED);\r\niowrite32(hdr, hdr_reg);\r\nreturn 1;\r\n}\r\nstatic int mask_all_events(struct switchtec_dev *stdev, int eid)\r\n{\r\nint idx;\r\nint count = 0;\r\nif (event_regs[eid].map_reg == part_ev_reg) {\r\nfor (idx = 0; idx < stdev->partition_count; idx++)\r\ncount += mask_event(stdev, eid, idx);\r\n} else if (event_regs[eid].map_reg == pff_ev_reg) {\r\nfor (idx = 0; idx < stdev->pff_csr_count; idx++) {\r\nif (!stdev->pff_local[idx])\r\ncontinue;\r\ncount += mask_event(stdev, eid, idx);\r\n}\r\n} else {\r\ncount += mask_event(stdev, eid, 0);\r\n}\r\nreturn count;\r\n}\r\nstatic irqreturn_t switchtec_event_isr(int irq, void *dev)\r\n{\r\nstruct switchtec_dev *stdev = dev;\r\nu32 reg;\r\nirqreturn_t ret = IRQ_NONE;\r\nint eid, event_count = 0;\r\nreg = ioread32(&stdev->mmio_part_cfg->mrpc_comp_hdr);\r\nif (reg & SWITCHTEC_EVENT_OCCURRED) {\r\ndev_dbg(&stdev->dev, "%s: mrpc comp\n", __func__);\r\nret = IRQ_HANDLED;\r\nschedule_work(&stdev->mrpc_work);\r\niowrite32(reg, &stdev->mmio_part_cfg->mrpc_comp_hdr);\r\n}\r\nfor (eid = 0; eid < SWITCHTEC_IOCTL_MAX_EVENTS; eid++)\r\nevent_count += mask_all_events(stdev, eid);\r\nif (event_count) {\r\natomic_inc(&stdev->event_cnt);\r\nwake_up_interruptible(&stdev->event_wq);\r\ndev_dbg(&stdev->dev, "%s: %d events\n", __func__,\r\nevent_count);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic int switchtec_init_isr(struct switchtec_dev *stdev)\r\n{\r\nint nvecs;\r\nint event_irq;\r\nnvecs = pci_alloc_irq_vectors(stdev->pdev, 1, 4,\r\nPCI_IRQ_MSIX | PCI_IRQ_MSI);\r\nif (nvecs < 0)\r\nreturn nvecs;\r\nevent_irq = ioread32(&stdev->mmio_part_cfg->vep_vector_number);\r\nif (event_irq < 0 || event_irq >= nvecs)\r\nreturn -EFAULT;\r\nevent_irq = pci_irq_vector(stdev->pdev, event_irq);\r\nif (event_irq < 0)\r\nreturn event_irq;\r\nreturn devm_request_irq(&stdev->pdev->dev, event_irq,\r\nswitchtec_event_isr, 0,\r\nKBUILD_MODNAME, stdev);\r\n}\r\nstatic void init_pff(struct switchtec_dev *stdev)\r\n{\r\nint i;\r\nu32 reg;\r\nstruct part_cfg_regs *pcfg = stdev->mmio_part_cfg;\r\nfor (i = 0; i < SWITCHTEC_MAX_PFF_CSR; i++) {\r\nreg = ioread16(&stdev->mmio_pff_csr[i].vendor_id);\r\nif (reg != MICROSEMI_VENDOR_ID)\r\nbreak;\r\n}\r\nstdev->pff_csr_count = i;\r\nreg = ioread32(&pcfg->usp_pff_inst_id);\r\nif (reg < SWITCHTEC_MAX_PFF_CSR)\r\nstdev->pff_local[reg] = 1;\r\nreg = ioread32(&pcfg->vep_pff_inst_id);\r\nif (reg < SWITCHTEC_MAX_PFF_CSR)\r\nstdev->pff_local[reg] = 1;\r\nfor (i = 0; i < ARRAY_SIZE(pcfg->dsp_pff_inst_id); i++) {\r\nreg = ioread32(&pcfg->dsp_pff_inst_id[i]);\r\nif (reg < SWITCHTEC_MAX_PFF_CSR)\r\nstdev->pff_local[reg] = 1;\r\n}\r\n}\r\nstatic int switchtec_init_pci(struct switchtec_dev *stdev,\r\nstruct pci_dev *pdev)\r\n{\r\nint rc;\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nrc = pcim_iomap_regions(pdev, 0x1, KBUILD_MODNAME);\r\nif (rc)\r\nreturn rc;\r\npci_set_master(pdev);\r\nstdev->mmio = pcim_iomap_table(pdev)[0];\r\nstdev->mmio_mrpc = stdev->mmio + SWITCHTEC_GAS_MRPC_OFFSET;\r\nstdev->mmio_sw_event = stdev->mmio + SWITCHTEC_GAS_SW_EVENT_OFFSET;\r\nstdev->mmio_sys_info = stdev->mmio + SWITCHTEC_GAS_SYS_INFO_OFFSET;\r\nstdev->mmio_flash_info = stdev->mmio + SWITCHTEC_GAS_FLASH_INFO_OFFSET;\r\nstdev->mmio_ntb = stdev->mmio + SWITCHTEC_GAS_NTB_OFFSET;\r\nstdev->partition = ioread8(&stdev->mmio_sys_info->partition_id);\r\nstdev->partition_count = ioread8(&stdev->mmio_ntb->partition_count);\r\nstdev->mmio_part_cfg_all = stdev->mmio + SWITCHTEC_GAS_PART_CFG_OFFSET;\r\nstdev->mmio_part_cfg = &stdev->mmio_part_cfg_all[stdev->partition];\r\nstdev->mmio_pff_csr = stdev->mmio + SWITCHTEC_GAS_PFF_CSR_OFFSET;\r\nif (stdev->partition_count < 1)\r\nstdev->partition_count = 1;\r\ninit_pff(stdev);\r\npci_set_drvdata(pdev, stdev);\r\nreturn 0;\r\n}\r\nstatic int switchtec_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct switchtec_dev *stdev;\r\nint rc;\r\nstdev = stdev_create(pdev);\r\nif (IS_ERR(stdev))\r\nreturn PTR_ERR(stdev);\r\nrc = switchtec_init_pci(stdev, pdev);\r\nif (rc)\r\ngoto err_put;\r\nrc = switchtec_init_isr(stdev);\r\nif (rc) {\r\ndev_err(&stdev->dev, "failed to init isr.\n");\r\ngoto err_put;\r\n}\r\niowrite32(SWITCHTEC_EVENT_CLEAR |\r\nSWITCHTEC_EVENT_EN_IRQ,\r\n&stdev->mmio_part_cfg->mrpc_comp_hdr);\r\nrc = cdev_device_add(&stdev->cdev, &stdev->dev);\r\nif (rc)\r\ngoto err_devadd;\r\ndev_info(&stdev->dev, "Management device registered.\n");\r\nreturn 0;\r\nerr_devadd:\r\nstdev_kill(stdev);\r\nerr_put:\r\nida_simple_remove(&switchtec_minor_ida, MINOR(stdev->dev.devt));\r\nput_device(&stdev->dev);\r\nreturn rc;\r\n}\r\nstatic void switchtec_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct switchtec_dev *stdev = pci_get_drvdata(pdev);\r\npci_set_drvdata(pdev, NULL);\r\ncdev_device_del(&stdev->cdev, &stdev->dev);\r\nida_simple_remove(&switchtec_minor_ida, MINOR(stdev->dev.devt));\r\ndev_info(&stdev->dev, "unregistered.\n");\r\nstdev_kill(stdev);\r\nput_device(&stdev->dev);\r\n}\r\nstatic int __init switchtec_init(void)\r\n{\r\nint rc;\r\nrc = alloc_chrdev_region(&switchtec_devt, 0, max_devices,\r\n"switchtec");\r\nif (rc)\r\nreturn rc;\r\nswitchtec_class = class_create(THIS_MODULE, "switchtec");\r\nif (IS_ERR(switchtec_class)) {\r\nrc = PTR_ERR(switchtec_class);\r\ngoto err_create_class;\r\n}\r\nrc = pci_register_driver(&switchtec_pci_driver);\r\nif (rc)\r\ngoto err_pci_register;\r\npr_info(KBUILD_MODNAME ": loaded.\n");\r\nreturn 0;\r\nerr_pci_register:\r\nclass_destroy(switchtec_class);\r\nerr_create_class:\r\nunregister_chrdev_region(switchtec_devt, max_devices);\r\nreturn rc;\r\n}\r\nstatic void __exit switchtec_exit(void)\r\n{\r\npci_unregister_driver(&switchtec_pci_driver);\r\nclass_destroy(switchtec_class);\r\nunregister_chrdev_region(switchtec_devt, max_devices);\r\nida_destroy(&switchtec_minor_ida);\r\npr_info(KBUILD_MODNAME ": unloaded.\n");\r\n}
