static void\r\nbnad_cq_cleanup(struct bnad *bnad, struct bna_ccb *ccb)\r\n{\r\nstruct bna_cq_entry *cmpl;\r\nint i;\r\nfor (i = 0; i < ccb->q_depth; i++) {\r\ncmpl = &((struct bna_cq_entry *)ccb->sw_q)[i];\r\ncmpl->valid = 0;\r\n}\r\n}\r\nstatic u32\r\nbnad_tx_buff_unmap(struct bnad *bnad,\r\nstruct bnad_tx_unmap *unmap_q,\r\nu32 q_depth, u32 index)\r\n{\r\nstruct bnad_tx_unmap *unmap;\r\nstruct sk_buff *skb;\r\nint vector, nvecs;\r\nunmap = &unmap_q[index];\r\nnvecs = unmap->nvecs;\r\nskb = unmap->skb;\r\nunmap->skb = NULL;\r\nunmap->nvecs = 0;\r\ndma_unmap_single(&bnad->pcidev->dev,\r\ndma_unmap_addr(&unmap->vectors[0], dma_addr),\r\nskb_headlen(skb), DMA_TO_DEVICE);\r\ndma_unmap_addr_set(&unmap->vectors[0], dma_addr, 0);\r\nnvecs--;\r\nvector = 0;\r\nwhile (nvecs) {\r\nvector++;\r\nif (vector == BFI_TX_MAX_VECTORS_PER_WI) {\r\nvector = 0;\r\nBNA_QE_INDX_INC(index, q_depth);\r\nunmap = &unmap_q[index];\r\n}\r\ndma_unmap_page(&bnad->pcidev->dev,\r\ndma_unmap_addr(&unmap->vectors[vector], dma_addr),\r\ndma_unmap_len(&unmap->vectors[vector], dma_len),\r\nDMA_TO_DEVICE);\r\ndma_unmap_addr_set(&unmap->vectors[vector], dma_addr, 0);\r\nnvecs--;\r\n}\r\nBNA_QE_INDX_INC(index, q_depth);\r\nreturn index;\r\n}\r\nstatic void\r\nbnad_txq_cleanup(struct bnad *bnad, struct bna_tcb *tcb)\r\n{\r\nstruct bnad_tx_unmap *unmap_q = tcb->unmap_q;\r\nstruct sk_buff *skb;\r\nint i;\r\nfor (i = 0; i < tcb->q_depth; i++) {\r\nskb = unmap_q[i].skb;\r\nif (!skb)\r\ncontinue;\r\nbnad_tx_buff_unmap(bnad, unmap_q, tcb->q_depth, i);\r\ndev_kfree_skb_any(skb);\r\n}\r\n}\r\nstatic u32\r\nbnad_txcmpl_process(struct bnad *bnad, struct bna_tcb *tcb)\r\n{\r\nu32 sent_packets = 0, sent_bytes = 0;\r\nu32 wis, unmap_wis, hw_cons, cons, q_depth;\r\nstruct bnad_tx_unmap *unmap_q = tcb->unmap_q;\r\nstruct bnad_tx_unmap *unmap;\r\nstruct sk_buff *skb;\r\nif (!test_bit(BNAD_TXQ_TX_STARTED, &tcb->flags))\r\nreturn 0;\r\nhw_cons = *(tcb->hw_consumer_index);\r\nrmb();\r\ncons = tcb->consumer_index;\r\nq_depth = tcb->q_depth;\r\nwis = BNA_Q_INDEX_CHANGE(cons, hw_cons, q_depth);\r\nBUG_ON(!(wis <= BNA_QE_IN_USE_CNT(tcb, tcb->q_depth)));\r\nwhile (wis) {\r\nunmap = &unmap_q[cons];\r\nskb = unmap->skb;\r\nsent_packets++;\r\nsent_bytes += skb->len;\r\nunmap_wis = BNA_TXQ_WI_NEEDED(unmap->nvecs);\r\nwis -= unmap_wis;\r\ncons = bnad_tx_buff_unmap(bnad, unmap_q, q_depth, cons);\r\ndev_kfree_skb_any(skb);\r\n}\r\ntcb->consumer_index = hw_cons;\r\ntcb->txq->tx_packets += sent_packets;\r\ntcb->txq->tx_bytes += sent_bytes;\r\nreturn sent_packets;\r\n}\r\nstatic u32\r\nbnad_tx_complete(struct bnad *bnad, struct bna_tcb *tcb)\r\n{\r\nstruct net_device *netdev = bnad->netdev;\r\nu32 sent = 0;\r\nif (test_and_set_bit(BNAD_TXQ_FREE_SENT, &tcb->flags))\r\nreturn 0;\r\nsent = bnad_txcmpl_process(bnad, tcb);\r\nif (sent) {\r\nif (netif_queue_stopped(netdev) &&\r\nnetif_carrier_ok(netdev) &&\r\nBNA_QE_FREE_CNT(tcb, tcb->q_depth) >=\r\nBNAD_NETIF_WAKE_THRESHOLD) {\r\nif (test_bit(BNAD_TXQ_TX_STARTED, &tcb->flags)) {\r\nnetif_wake_queue(netdev);\r\nBNAD_UPDATE_CTR(bnad, netif_queue_wakeup);\r\n}\r\n}\r\n}\r\nif (likely(test_bit(BNAD_TXQ_TX_STARTED, &tcb->flags)))\r\nbna_ib_ack(tcb->i_dbell, sent);\r\nsmp_mb__before_atomic();\r\nclear_bit(BNAD_TXQ_FREE_SENT, &tcb->flags);\r\nreturn sent;\r\n}\r\nstatic irqreturn_t\r\nbnad_msix_tx(int irq, void *data)\r\n{\r\nstruct bna_tcb *tcb = (struct bna_tcb *)data;\r\nstruct bnad *bnad = tcb->bnad;\r\nbnad_tx_complete(bnad, tcb);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void\r\nbnad_rxq_alloc_uninit(struct bnad *bnad, struct bna_rcb *rcb)\r\n{\r\nstruct bnad_rx_unmap_q *unmap_q = rcb->unmap_q;\r\nunmap_q->reuse_pi = -1;\r\nunmap_q->alloc_order = -1;\r\nunmap_q->map_size = 0;\r\nunmap_q->type = BNAD_RXBUF_NONE;\r\n}\r\nstatic int\r\nbnad_rxq_alloc_init(struct bnad *bnad, struct bna_rcb *rcb)\r\n{\r\nstruct bnad_rx_unmap_q *unmap_q = rcb->unmap_q;\r\nint order;\r\nbnad_rxq_alloc_uninit(bnad, rcb);\r\norder = get_order(rcb->rxq->buffer_size);\r\nunmap_q->type = BNAD_RXBUF_PAGE;\r\nif (bna_is_small_rxq(rcb->id)) {\r\nunmap_q->alloc_order = 0;\r\nunmap_q->map_size = rcb->rxq->buffer_size;\r\n} else {\r\nif (rcb->rxq->multi_buffer) {\r\nunmap_q->alloc_order = 0;\r\nunmap_q->map_size = rcb->rxq->buffer_size;\r\nunmap_q->type = BNAD_RXBUF_MULTI_BUFF;\r\n} else {\r\nunmap_q->alloc_order = order;\r\nunmap_q->map_size =\r\n(rcb->rxq->buffer_size > 2048) ?\r\nPAGE_SIZE << order : 2048;\r\n}\r\n}\r\nBUG_ON((PAGE_SIZE << order) % unmap_q->map_size);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nbnad_rxq_cleanup_page(struct bnad *bnad, struct bnad_rx_unmap *unmap)\r\n{\r\nif (!unmap->page)\r\nreturn;\r\ndma_unmap_page(&bnad->pcidev->dev,\r\ndma_unmap_addr(&unmap->vector, dma_addr),\r\nunmap->vector.len, DMA_FROM_DEVICE);\r\nput_page(unmap->page);\r\nunmap->page = NULL;\r\ndma_unmap_addr_set(&unmap->vector, dma_addr, 0);\r\nunmap->vector.len = 0;\r\n}\r\nstatic inline void\r\nbnad_rxq_cleanup_skb(struct bnad *bnad, struct bnad_rx_unmap *unmap)\r\n{\r\nif (!unmap->skb)\r\nreturn;\r\ndma_unmap_single(&bnad->pcidev->dev,\r\ndma_unmap_addr(&unmap->vector, dma_addr),\r\nunmap->vector.len, DMA_FROM_DEVICE);\r\ndev_kfree_skb_any(unmap->skb);\r\nunmap->skb = NULL;\r\ndma_unmap_addr_set(&unmap->vector, dma_addr, 0);\r\nunmap->vector.len = 0;\r\n}\r\nstatic void\r\nbnad_rxq_cleanup(struct bnad *bnad, struct bna_rcb *rcb)\r\n{\r\nstruct bnad_rx_unmap_q *unmap_q = rcb->unmap_q;\r\nint i;\r\nfor (i = 0; i < rcb->q_depth; i++) {\r\nstruct bnad_rx_unmap *unmap = &unmap_q->unmap[i];\r\nif (BNAD_RXBUF_IS_SK_BUFF(unmap_q->type))\r\nbnad_rxq_cleanup_skb(bnad, unmap);\r\nelse\r\nbnad_rxq_cleanup_page(bnad, unmap);\r\n}\r\nbnad_rxq_alloc_uninit(bnad, rcb);\r\n}\r\nstatic u32\r\nbnad_rxq_refill_page(struct bnad *bnad, struct bna_rcb *rcb, u32 nalloc)\r\n{\r\nu32 alloced, prod, q_depth;\r\nstruct bnad_rx_unmap_q *unmap_q = rcb->unmap_q;\r\nstruct bnad_rx_unmap *unmap, *prev;\r\nstruct bna_rxq_entry *rxent;\r\nstruct page *page;\r\nu32 page_offset, alloc_size;\r\ndma_addr_t dma_addr;\r\nprod = rcb->producer_index;\r\nq_depth = rcb->q_depth;\r\nalloc_size = PAGE_SIZE << unmap_q->alloc_order;\r\nalloced = 0;\r\nwhile (nalloc--) {\r\nunmap = &unmap_q->unmap[prod];\r\nif (unmap_q->reuse_pi < 0) {\r\npage = alloc_pages(GFP_ATOMIC | __GFP_COMP,\r\nunmap_q->alloc_order);\r\npage_offset = 0;\r\n} else {\r\nprev = &unmap_q->unmap[unmap_q->reuse_pi];\r\npage = prev->page;\r\npage_offset = prev->page_offset + unmap_q->map_size;\r\nget_page(page);\r\n}\r\nif (unlikely(!page)) {\r\nBNAD_UPDATE_CTR(bnad, rxbuf_alloc_failed);\r\nrcb->rxq->rxbuf_alloc_failed++;\r\ngoto finishing;\r\n}\r\ndma_addr = dma_map_page(&bnad->pcidev->dev, page, page_offset,\r\nunmap_q->map_size, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(&bnad->pcidev->dev, dma_addr)) {\r\nput_page(page);\r\nBNAD_UPDATE_CTR(bnad, rxbuf_map_failed);\r\nrcb->rxq->rxbuf_map_failed++;\r\ngoto finishing;\r\n}\r\nunmap->page = page;\r\nunmap->page_offset = page_offset;\r\ndma_unmap_addr_set(&unmap->vector, dma_addr, dma_addr);\r\nunmap->vector.len = unmap_q->map_size;\r\npage_offset += unmap_q->map_size;\r\nif (page_offset < alloc_size)\r\nunmap_q->reuse_pi = prod;\r\nelse\r\nunmap_q->reuse_pi = -1;\r\nrxent = &((struct bna_rxq_entry *)rcb->sw_q)[prod];\r\nBNA_SET_DMA_ADDR(dma_addr, &rxent->host_addr);\r\nBNA_QE_INDX_INC(prod, q_depth);\r\nalloced++;\r\n}\r\nfinishing:\r\nif (likely(alloced)) {\r\nrcb->producer_index = prod;\r\nsmp_mb();\r\nif (likely(test_bit(BNAD_RXQ_POST_OK, &rcb->flags)))\r\nbna_rxq_prod_indx_doorbell(rcb);\r\n}\r\nreturn alloced;\r\n}\r\nstatic u32\r\nbnad_rxq_refill_skb(struct bnad *bnad, struct bna_rcb *rcb, u32 nalloc)\r\n{\r\nu32 alloced, prod, q_depth, buff_sz;\r\nstruct bnad_rx_unmap_q *unmap_q = rcb->unmap_q;\r\nstruct bnad_rx_unmap *unmap;\r\nstruct bna_rxq_entry *rxent;\r\nstruct sk_buff *skb;\r\ndma_addr_t dma_addr;\r\nbuff_sz = rcb->rxq->buffer_size;\r\nprod = rcb->producer_index;\r\nq_depth = rcb->q_depth;\r\nalloced = 0;\r\nwhile (nalloc--) {\r\nunmap = &unmap_q->unmap[prod];\r\nskb = netdev_alloc_skb_ip_align(bnad->netdev, buff_sz);\r\nif (unlikely(!skb)) {\r\nBNAD_UPDATE_CTR(bnad, rxbuf_alloc_failed);\r\nrcb->rxq->rxbuf_alloc_failed++;\r\ngoto finishing;\r\n}\r\ndma_addr = dma_map_single(&bnad->pcidev->dev, skb->data,\r\nbuff_sz, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(&bnad->pcidev->dev, dma_addr)) {\r\ndev_kfree_skb_any(skb);\r\nBNAD_UPDATE_CTR(bnad, rxbuf_map_failed);\r\nrcb->rxq->rxbuf_map_failed++;\r\ngoto finishing;\r\n}\r\nunmap->skb = skb;\r\ndma_unmap_addr_set(&unmap->vector, dma_addr, dma_addr);\r\nunmap->vector.len = buff_sz;\r\nrxent = &((struct bna_rxq_entry *)rcb->sw_q)[prod];\r\nBNA_SET_DMA_ADDR(dma_addr, &rxent->host_addr);\r\nBNA_QE_INDX_INC(prod, q_depth);\r\nalloced++;\r\n}\r\nfinishing:\r\nif (likely(alloced)) {\r\nrcb->producer_index = prod;\r\nsmp_mb();\r\nif (likely(test_bit(BNAD_RXQ_POST_OK, &rcb->flags)))\r\nbna_rxq_prod_indx_doorbell(rcb);\r\n}\r\nreturn alloced;\r\n}\r\nstatic inline void\r\nbnad_rxq_post(struct bnad *bnad, struct bna_rcb *rcb)\r\n{\r\nstruct bnad_rx_unmap_q *unmap_q = rcb->unmap_q;\r\nu32 to_alloc;\r\nto_alloc = BNA_QE_FREE_CNT(rcb, rcb->q_depth);\r\nif (!(to_alloc >> BNAD_RXQ_REFILL_THRESHOLD_SHIFT))\r\nreturn;\r\nif (BNAD_RXBUF_IS_SK_BUFF(unmap_q->type))\r\nbnad_rxq_refill_skb(bnad, rcb, to_alloc);\r\nelse\r\nbnad_rxq_refill_page(bnad, rcb, to_alloc);\r\n}\r\nstatic void\r\nbnad_cq_drop_packet(struct bnad *bnad, struct bna_rcb *rcb,\r\nu32 sop_ci, u32 nvecs)\r\n{\r\nstruct bnad_rx_unmap_q *unmap_q;\r\nstruct bnad_rx_unmap *unmap;\r\nu32 ci, vec;\r\nunmap_q = rcb->unmap_q;\r\nfor (vec = 0, ci = sop_ci; vec < nvecs; vec++) {\r\nunmap = &unmap_q->unmap[ci];\r\nBNA_QE_INDX_INC(ci, rcb->q_depth);\r\nif (BNAD_RXBUF_IS_SK_BUFF(unmap_q->type))\r\nbnad_rxq_cleanup_skb(bnad, unmap);\r\nelse\r\nbnad_rxq_cleanup_page(bnad, unmap);\r\n}\r\n}\r\nstatic void\r\nbnad_cq_setup_skb_frags(struct bna_ccb *ccb, struct sk_buff *skb, u32 nvecs)\r\n{\r\nstruct bna_rcb *rcb;\r\nstruct bnad *bnad;\r\nstruct bnad_rx_unmap_q *unmap_q;\r\nstruct bna_cq_entry *cq, *cmpl;\r\nu32 ci, pi, totlen = 0;\r\ncq = ccb->sw_q;\r\npi = ccb->producer_index;\r\ncmpl = &cq[pi];\r\nrcb = bna_is_small_rxq(cmpl->rxq_id) ? ccb->rcb[1] : ccb->rcb[0];\r\nunmap_q = rcb->unmap_q;\r\nbnad = rcb->bnad;\r\nci = rcb->consumer_index;\r\nprefetch(page_address(unmap_q->unmap[ci].page) +\r\nunmap_q->unmap[ci].page_offset);\r\nwhile (nvecs--) {\r\nstruct bnad_rx_unmap *unmap;\r\nu32 len;\r\nunmap = &unmap_q->unmap[ci];\r\nBNA_QE_INDX_INC(ci, rcb->q_depth);\r\ndma_unmap_page(&bnad->pcidev->dev,\r\ndma_unmap_addr(&unmap->vector, dma_addr),\r\nunmap->vector.len, DMA_FROM_DEVICE);\r\nlen = ntohs(cmpl->length);\r\nskb->truesize += unmap->vector.len;\r\ntotlen += len;\r\nskb_fill_page_desc(skb, skb_shinfo(skb)->nr_frags,\r\nunmap->page, unmap->page_offset, len);\r\nunmap->page = NULL;\r\nunmap->vector.len = 0;\r\nBNA_QE_INDX_INC(pi, ccb->q_depth);\r\ncmpl = &cq[pi];\r\n}\r\nskb->len += totlen;\r\nskb->data_len += totlen;\r\n}\r\nstatic inline void\r\nbnad_cq_setup_skb(struct bnad *bnad, struct sk_buff *skb,\r\nstruct bnad_rx_unmap *unmap, u32 len)\r\n{\r\nprefetch(skb->data);\r\ndma_unmap_single(&bnad->pcidev->dev,\r\ndma_unmap_addr(&unmap->vector, dma_addr),\r\nunmap->vector.len, DMA_FROM_DEVICE);\r\nskb_put(skb, len);\r\nskb->protocol = eth_type_trans(skb, bnad->netdev);\r\nunmap->skb = NULL;\r\nunmap->vector.len = 0;\r\n}\r\nstatic u32\r\nbnad_cq_process(struct bnad *bnad, struct bna_ccb *ccb, int budget)\r\n{\r\nstruct bna_cq_entry *cq, *cmpl, *next_cmpl;\r\nstruct bna_rcb *rcb = NULL;\r\nstruct bnad_rx_unmap_q *unmap_q;\r\nstruct bnad_rx_unmap *unmap = NULL;\r\nstruct sk_buff *skb = NULL;\r\nstruct bna_pkt_rate *pkt_rt = &ccb->pkt_rate;\r\nstruct bnad_rx_ctrl *rx_ctrl = ccb->ctrl;\r\nu32 packets = 0, len = 0, totlen = 0;\r\nu32 pi, vec, sop_ci = 0, nvecs = 0;\r\nu32 flags, masked_flags;\r\nprefetch(bnad->netdev);\r\ncq = ccb->sw_q;\r\nwhile (packets < budget) {\r\ncmpl = &cq[ccb->producer_index];\r\nif (!cmpl->valid)\r\nbreak;\r\nrmb();\r\nBNA_UPDATE_PKT_CNT(pkt_rt, ntohs(cmpl->length));\r\nif (bna_is_small_rxq(cmpl->rxq_id))\r\nrcb = ccb->rcb[1];\r\nelse\r\nrcb = ccb->rcb[0];\r\nunmap_q = rcb->unmap_q;\r\nsop_ci = rcb->consumer_index;\r\nif (BNAD_RXBUF_IS_SK_BUFF(unmap_q->type)) {\r\nunmap = &unmap_q->unmap[sop_ci];\r\nskb = unmap->skb;\r\n} else {\r\nskb = napi_get_frags(&rx_ctrl->napi);\r\nif (unlikely(!skb))\r\nbreak;\r\n}\r\nprefetch(skb);\r\nflags = ntohl(cmpl->flags);\r\nlen = ntohs(cmpl->length);\r\ntotlen = len;\r\nnvecs = 1;\r\nif (BNAD_RXBUF_IS_MULTI_BUFF(unmap_q->type) &&\r\n(flags & BNA_CQ_EF_EOP) == 0) {\r\npi = ccb->producer_index;\r\ndo {\r\nBNA_QE_INDX_INC(pi, ccb->q_depth);\r\nnext_cmpl = &cq[pi];\r\nif (!next_cmpl->valid)\r\nbreak;\r\nrmb();\r\nlen = ntohs(next_cmpl->length);\r\nflags = ntohl(next_cmpl->flags);\r\nnvecs++;\r\ntotlen += len;\r\n} while ((flags & BNA_CQ_EF_EOP) == 0);\r\nif (!next_cmpl->valid)\r\nbreak;\r\n}\r\npackets++;\r\nif (unlikely(flags & (BNA_CQ_EF_MAC_ERROR |\r\nBNA_CQ_EF_FCS_ERROR |\r\nBNA_CQ_EF_TOO_LONG))) {\r\nbnad_cq_drop_packet(bnad, rcb, sop_ci, nvecs);\r\nrcb->rxq->rx_packets_with_error++;\r\ngoto next;\r\n}\r\nif (BNAD_RXBUF_IS_SK_BUFF(unmap_q->type))\r\nbnad_cq_setup_skb(bnad, skb, unmap, len);\r\nelse\r\nbnad_cq_setup_skb_frags(ccb, skb, nvecs);\r\nrcb->rxq->rx_packets++;\r\nrcb->rxq->rx_bytes += totlen;\r\nccb->bytes_per_intr += totlen;\r\nmasked_flags = flags & flags_cksum_prot_mask;\r\nif (likely\r\n((bnad->netdev->features & NETIF_F_RXCSUM) &&\r\n((masked_flags == flags_tcp4) ||\r\n(masked_flags == flags_udp4) ||\r\n(masked_flags == flags_tcp6) ||\r\n(masked_flags == flags_udp6))))\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nelse\r\nskb_checksum_none_assert(skb);\r\nif ((flags & BNA_CQ_EF_VLAN) &&\r\n(bnad->netdev->features & NETIF_F_HW_VLAN_CTAG_RX))\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), ntohs(cmpl->vlan_tag));\r\nif (BNAD_RXBUF_IS_SK_BUFF(unmap_q->type))\r\nnetif_receive_skb(skb);\r\nelse\r\nnapi_gro_frags(&rx_ctrl->napi);\r\nnext:\r\nBNA_QE_INDX_ADD(rcb->consumer_index, nvecs, rcb->q_depth);\r\nfor (vec = 0; vec < nvecs; vec++) {\r\ncmpl = &cq[ccb->producer_index];\r\ncmpl->valid = 0;\r\nBNA_QE_INDX_INC(ccb->producer_index, ccb->q_depth);\r\n}\r\n}\r\nnapi_gro_flush(&rx_ctrl->napi, false);\r\nif (likely(test_bit(BNAD_RXQ_STARTED, &ccb->rcb[0]->flags)))\r\nbna_ib_ack_disable_irq(ccb->i_dbell, packets);\r\nbnad_rxq_post(bnad, ccb->rcb[0]);\r\nif (ccb->rcb[1])\r\nbnad_rxq_post(bnad, ccb->rcb[1]);\r\nreturn packets;\r\n}\r\nstatic void\r\nbnad_netif_rx_schedule_poll(struct bnad *bnad, struct bna_ccb *ccb)\r\n{\r\nstruct bnad_rx_ctrl *rx_ctrl = (struct bnad_rx_ctrl *)(ccb->ctrl);\r\nstruct napi_struct *napi = &rx_ctrl->napi;\r\nif (likely(napi_schedule_prep(napi))) {\r\n__napi_schedule(napi);\r\nrx_ctrl->rx_schedule++;\r\n}\r\n}\r\nstatic irqreturn_t\r\nbnad_msix_rx(int irq, void *data)\r\n{\r\nstruct bna_ccb *ccb = (struct bna_ccb *)data;\r\nif (ccb) {\r\n((struct bnad_rx_ctrl *)ccb->ctrl)->rx_intr_ctr++;\r\nbnad_netif_rx_schedule_poll(ccb->bnad, ccb);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nbnad_msix_mbox_handler(int irq, void *data)\r\n{\r\nu32 intr_status;\r\nunsigned long flags;\r\nstruct bnad *bnad = (struct bnad *)data;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nif (unlikely(test_bit(BNAD_RF_MBOX_IRQ_DISABLED, &bnad->run_flags))) {\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nbna_intr_status_get(&bnad->bna, intr_status);\r\nif (BNA_IS_MBOX_ERR_INTR(&bnad->bna, intr_status))\r\nbna_mbox_handler(&bnad->bna, intr_status);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nbnad_isr(int irq, void *data)\r\n{\r\nint i, j;\r\nu32 intr_status;\r\nunsigned long flags;\r\nstruct bnad *bnad = (struct bnad *)data;\r\nstruct bnad_rx_info *rx_info;\r\nstruct bnad_rx_ctrl *rx_ctrl;\r\nstruct bna_tcb *tcb = NULL;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nif (unlikely(test_bit(BNAD_RF_MBOX_IRQ_DISABLED, &bnad->run_flags))) {\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nbna_intr_status_get(&bnad->bna, intr_status);\r\nif (unlikely(!intr_status)) {\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nif (BNA_IS_MBOX_ERR_INTR(&bnad->bna, intr_status))\r\nbna_mbox_handler(&bnad->bna, intr_status);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nif (!BNA_IS_INTX_DATA_INTR(intr_status))\r\nreturn IRQ_HANDLED;\r\nfor (i = 0; i < bnad->num_tx; i++) {\r\nfor (j = 0; j < bnad->num_txq_per_tx; j++) {\r\ntcb = bnad->tx_info[i].tcb[j];\r\nif (tcb && test_bit(BNAD_TXQ_TX_STARTED, &tcb->flags))\r\nbnad_tx_complete(bnad, bnad->tx_info[i].tcb[j]);\r\n}\r\n}\r\nfor (i = 0; i < bnad->num_rx; i++) {\r\nrx_info = &bnad->rx_info[i];\r\nif (!rx_info->rx)\r\ncontinue;\r\nfor (j = 0; j < bnad->num_rxp_per_rx; j++) {\r\nrx_ctrl = &rx_info->rx_ctrl[j];\r\nif (rx_ctrl->ccb)\r\nbnad_netif_rx_schedule_poll(bnad,\r\nrx_ctrl->ccb);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nbnad_enable_mbox_irq(struct bnad *bnad)\r\n{\r\nclear_bit(BNAD_RF_MBOX_IRQ_DISABLED, &bnad->run_flags);\r\nBNAD_UPDATE_CTR(bnad, mbox_intr_enabled);\r\n}\r\nstatic void\r\nbnad_disable_mbox_irq(struct bnad *bnad)\r\n{\r\nset_bit(BNAD_RF_MBOX_IRQ_DISABLED, &bnad->run_flags);\r\nBNAD_UPDATE_CTR(bnad, mbox_intr_disabled);\r\n}\r\nstatic void\r\nbnad_set_netdev_perm_addr(struct bnad *bnad)\r\n{\r\nstruct net_device *netdev = bnad->netdev;\r\nether_addr_copy(netdev->perm_addr, bnad->perm_addr);\r\nif (is_zero_ether_addr(netdev->dev_addr))\r\nether_addr_copy(netdev->dev_addr, bnad->perm_addr);\r\n}\r\nvoid\r\nbnad_cb_mbox_intr_enable(struct bnad *bnad)\r\n{\r\nbnad_enable_mbox_irq(bnad);\r\n}\r\nvoid\r\nbnad_cb_mbox_intr_disable(struct bnad *bnad)\r\n{\r\nbnad_disable_mbox_irq(bnad);\r\n}\r\nvoid\r\nbnad_cb_ioceth_ready(struct bnad *bnad)\r\n{\r\nbnad->bnad_completions.ioc_comp_status = BNA_CB_SUCCESS;\r\ncomplete(&bnad->bnad_completions.ioc_comp);\r\n}\r\nvoid\r\nbnad_cb_ioceth_failed(struct bnad *bnad)\r\n{\r\nbnad->bnad_completions.ioc_comp_status = BNA_CB_FAIL;\r\ncomplete(&bnad->bnad_completions.ioc_comp);\r\n}\r\nvoid\r\nbnad_cb_ioceth_disabled(struct bnad *bnad)\r\n{\r\nbnad->bnad_completions.ioc_comp_status = BNA_CB_SUCCESS;\r\ncomplete(&bnad->bnad_completions.ioc_comp);\r\n}\r\nstatic void\r\nbnad_cb_enet_disabled(void *arg)\r\n{\r\nstruct bnad *bnad = (struct bnad *)arg;\r\nnetif_carrier_off(bnad->netdev);\r\ncomplete(&bnad->bnad_completions.enet_comp);\r\n}\r\nvoid\r\nbnad_cb_ethport_link_status(struct bnad *bnad,\r\nenum bna_link_status link_status)\r\n{\r\nbool link_up = false;\r\nlink_up = (link_status == BNA_LINK_UP) || (link_status == BNA_CEE_UP);\r\nif (link_status == BNA_CEE_UP) {\r\nif (!test_bit(BNAD_RF_CEE_RUNNING, &bnad->run_flags))\r\nBNAD_UPDATE_CTR(bnad, cee_toggle);\r\nset_bit(BNAD_RF_CEE_RUNNING, &bnad->run_flags);\r\n} else {\r\nif (test_bit(BNAD_RF_CEE_RUNNING, &bnad->run_flags))\r\nBNAD_UPDATE_CTR(bnad, cee_toggle);\r\nclear_bit(BNAD_RF_CEE_RUNNING, &bnad->run_flags);\r\n}\r\nif (link_up) {\r\nif (!netif_carrier_ok(bnad->netdev)) {\r\nuint tx_id, tcb_id;\r\nnetdev_info(bnad->netdev, "link up\n");\r\nnetif_carrier_on(bnad->netdev);\r\nBNAD_UPDATE_CTR(bnad, link_toggle);\r\nfor (tx_id = 0; tx_id < bnad->num_tx; tx_id++) {\r\nfor (tcb_id = 0; tcb_id < bnad->num_txq_per_tx;\r\ntcb_id++) {\r\nstruct bna_tcb *tcb =\r\nbnad->tx_info[tx_id].tcb[tcb_id];\r\nu32 txq_id;\r\nif (!tcb)\r\ncontinue;\r\ntxq_id = tcb->id;\r\nif (test_bit(BNAD_TXQ_TX_STARTED,\r\n&tcb->flags)) {\r\nnetif_wake_subqueue(\r\nbnad->netdev,\r\ntxq_id);\r\nBNAD_UPDATE_CTR(bnad,\r\nnetif_queue_wakeup);\r\n} else {\r\nnetif_stop_subqueue(\r\nbnad->netdev,\r\ntxq_id);\r\nBNAD_UPDATE_CTR(bnad,\r\nnetif_queue_stop);\r\n}\r\n}\r\n}\r\n}\r\n} else {\r\nif (netif_carrier_ok(bnad->netdev)) {\r\nnetdev_info(bnad->netdev, "link down\n");\r\nnetif_carrier_off(bnad->netdev);\r\nBNAD_UPDATE_CTR(bnad, link_toggle);\r\n}\r\n}\r\n}\r\nstatic void\r\nbnad_cb_tx_disabled(void *arg, struct bna_tx *tx)\r\n{\r\nstruct bnad *bnad = (struct bnad *)arg;\r\ncomplete(&bnad->bnad_completions.tx_comp);\r\n}\r\nstatic void\r\nbnad_cb_tcb_setup(struct bnad *bnad, struct bna_tcb *tcb)\r\n{\r\nstruct bnad_tx_info *tx_info =\r\n(struct bnad_tx_info *)tcb->txq->tx->priv;\r\ntcb->priv = tcb;\r\ntx_info->tcb[tcb->id] = tcb;\r\n}\r\nstatic void\r\nbnad_cb_tcb_destroy(struct bnad *bnad, struct bna_tcb *tcb)\r\n{\r\nstruct bnad_tx_info *tx_info =\r\n(struct bnad_tx_info *)tcb->txq->tx->priv;\r\ntx_info->tcb[tcb->id] = NULL;\r\ntcb->priv = NULL;\r\n}\r\nstatic void\r\nbnad_cb_ccb_setup(struct bnad *bnad, struct bna_ccb *ccb)\r\n{\r\nstruct bnad_rx_info *rx_info =\r\n(struct bnad_rx_info *)ccb->cq->rx->priv;\r\nrx_info->rx_ctrl[ccb->id].ccb = ccb;\r\nccb->ctrl = &rx_info->rx_ctrl[ccb->id];\r\n}\r\nstatic void\r\nbnad_cb_ccb_destroy(struct bnad *bnad, struct bna_ccb *ccb)\r\n{\r\nstruct bnad_rx_info *rx_info =\r\n(struct bnad_rx_info *)ccb->cq->rx->priv;\r\nrx_info->rx_ctrl[ccb->id].ccb = NULL;\r\n}\r\nstatic void\r\nbnad_cb_tx_stall(struct bnad *bnad, struct bna_tx *tx)\r\n{\r\nstruct bnad_tx_info *tx_info =\r\n(struct bnad_tx_info *)tx->priv;\r\nstruct bna_tcb *tcb;\r\nu32 txq_id;\r\nint i;\r\nfor (i = 0; i < BNAD_MAX_TXQ_PER_TX; i++) {\r\ntcb = tx_info->tcb[i];\r\nif (!tcb)\r\ncontinue;\r\ntxq_id = tcb->id;\r\nclear_bit(BNAD_TXQ_TX_STARTED, &tcb->flags);\r\nnetif_stop_subqueue(bnad->netdev, txq_id);\r\n}\r\n}\r\nstatic void\r\nbnad_cb_tx_resume(struct bnad *bnad, struct bna_tx *tx)\r\n{\r\nstruct bnad_tx_info *tx_info = (struct bnad_tx_info *)tx->priv;\r\nstruct bna_tcb *tcb;\r\nu32 txq_id;\r\nint i;\r\nfor (i = 0; i < BNAD_MAX_TXQ_PER_TX; i++) {\r\ntcb = tx_info->tcb[i];\r\nif (!tcb)\r\ncontinue;\r\ntxq_id = tcb->id;\r\nBUG_ON(test_bit(BNAD_TXQ_TX_STARTED, &tcb->flags));\r\nset_bit(BNAD_TXQ_TX_STARTED, &tcb->flags);\r\nBUG_ON(*(tcb->hw_consumer_index) != 0);\r\nif (netif_carrier_ok(bnad->netdev)) {\r\nnetif_wake_subqueue(bnad->netdev, txq_id);\r\nBNAD_UPDATE_CTR(bnad, netif_queue_wakeup);\r\n}\r\n}\r\nif (is_zero_ether_addr(bnad->perm_addr)) {\r\nbna_enet_perm_mac_get(&bnad->bna.enet, bnad->perm_addr);\r\nbnad_set_netdev_perm_addr(bnad);\r\n}\r\n}\r\nstatic void\r\nbnad_tx_cleanup(struct delayed_work *work)\r\n{\r\nstruct bnad_tx_info *tx_info =\r\ncontainer_of(work, struct bnad_tx_info, tx_cleanup_work);\r\nstruct bnad *bnad = NULL;\r\nstruct bna_tcb *tcb;\r\nunsigned long flags;\r\nu32 i, pending = 0;\r\nfor (i = 0; i < BNAD_MAX_TXQ_PER_TX; i++) {\r\ntcb = tx_info->tcb[i];\r\nif (!tcb)\r\ncontinue;\r\nbnad = tcb->bnad;\r\nif (test_and_set_bit(BNAD_TXQ_FREE_SENT, &tcb->flags)) {\r\npending++;\r\ncontinue;\r\n}\r\nbnad_txq_cleanup(bnad, tcb);\r\nsmp_mb__before_atomic();\r\nclear_bit(BNAD_TXQ_FREE_SENT, &tcb->flags);\r\n}\r\nif (pending) {\r\nqueue_delayed_work(bnad->work_q, &tx_info->tx_cleanup_work,\r\nmsecs_to_jiffies(1));\r\nreturn;\r\n}\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_tx_cleanup_complete(tx_info->tx);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\n}\r\nstatic void\r\nbnad_cb_tx_cleanup(struct bnad *bnad, struct bna_tx *tx)\r\n{\r\nstruct bnad_tx_info *tx_info = (struct bnad_tx_info *)tx->priv;\r\nstruct bna_tcb *tcb;\r\nint i;\r\nfor (i = 0; i < BNAD_MAX_TXQ_PER_TX; i++) {\r\ntcb = tx_info->tcb[i];\r\nif (!tcb)\r\ncontinue;\r\n}\r\nqueue_delayed_work(bnad->work_q, &tx_info->tx_cleanup_work, 0);\r\n}\r\nstatic void\r\nbnad_cb_rx_stall(struct bnad *bnad, struct bna_rx *rx)\r\n{\r\nstruct bnad_rx_info *rx_info = (struct bnad_rx_info *)rx->priv;\r\nstruct bna_ccb *ccb;\r\nstruct bnad_rx_ctrl *rx_ctrl;\r\nint i;\r\nfor (i = 0; i < BNAD_MAX_RXP_PER_RX; i++) {\r\nrx_ctrl = &rx_info->rx_ctrl[i];\r\nccb = rx_ctrl->ccb;\r\nif (!ccb)\r\ncontinue;\r\nclear_bit(BNAD_RXQ_POST_OK, &ccb->rcb[0]->flags);\r\nif (ccb->rcb[1])\r\nclear_bit(BNAD_RXQ_POST_OK, &ccb->rcb[1]->flags);\r\n}\r\n}\r\nstatic void\r\nbnad_rx_cleanup(void *work)\r\n{\r\nstruct bnad_rx_info *rx_info =\r\ncontainer_of(work, struct bnad_rx_info, rx_cleanup_work);\r\nstruct bnad_rx_ctrl *rx_ctrl;\r\nstruct bnad *bnad = NULL;\r\nunsigned long flags;\r\nu32 i;\r\nfor (i = 0; i < BNAD_MAX_RXP_PER_RX; i++) {\r\nrx_ctrl = &rx_info->rx_ctrl[i];\r\nif (!rx_ctrl->ccb)\r\ncontinue;\r\nbnad = rx_ctrl->ccb->bnad;\r\nnapi_disable(&rx_ctrl->napi);\r\nbnad_cq_cleanup(bnad, rx_ctrl->ccb);\r\nbnad_rxq_cleanup(bnad, rx_ctrl->ccb->rcb[0]);\r\nif (rx_ctrl->ccb->rcb[1])\r\nbnad_rxq_cleanup(bnad, rx_ctrl->ccb->rcb[1]);\r\n}\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_rx_cleanup_complete(rx_info->rx);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\n}\r\nstatic void\r\nbnad_cb_rx_cleanup(struct bnad *bnad, struct bna_rx *rx)\r\n{\r\nstruct bnad_rx_info *rx_info = (struct bnad_rx_info *)rx->priv;\r\nstruct bna_ccb *ccb;\r\nstruct bnad_rx_ctrl *rx_ctrl;\r\nint i;\r\nfor (i = 0; i < BNAD_MAX_RXP_PER_RX; i++) {\r\nrx_ctrl = &rx_info->rx_ctrl[i];\r\nccb = rx_ctrl->ccb;\r\nif (!ccb)\r\ncontinue;\r\nclear_bit(BNAD_RXQ_STARTED, &ccb->rcb[0]->flags);\r\nif (ccb->rcb[1])\r\nclear_bit(BNAD_RXQ_STARTED, &ccb->rcb[1]->flags);\r\n}\r\nqueue_work(bnad->work_q, &rx_info->rx_cleanup_work);\r\n}\r\nstatic void\r\nbnad_cb_rx_post(struct bnad *bnad, struct bna_rx *rx)\r\n{\r\nstruct bnad_rx_info *rx_info = (struct bnad_rx_info *)rx->priv;\r\nstruct bna_ccb *ccb;\r\nstruct bna_rcb *rcb;\r\nstruct bnad_rx_ctrl *rx_ctrl;\r\nint i, j;\r\nfor (i = 0; i < BNAD_MAX_RXP_PER_RX; i++) {\r\nrx_ctrl = &rx_info->rx_ctrl[i];\r\nccb = rx_ctrl->ccb;\r\nif (!ccb)\r\ncontinue;\r\nnapi_enable(&rx_ctrl->napi);\r\nfor (j = 0; j < BNAD_MAX_RXQ_PER_RXP; j++) {\r\nrcb = ccb->rcb[j];\r\nif (!rcb)\r\ncontinue;\r\nbnad_rxq_alloc_init(bnad, rcb);\r\nset_bit(BNAD_RXQ_STARTED, &rcb->flags);\r\nset_bit(BNAD_RXQ_POST_OK, &rcb->flags);\r\nbnad_rxq_post(bnad, rcb);\r\n}\r\n}\r\n}\r\nstatic void\r\nbnad_cb_rx_disabled(void *arg, struct bna_rx *rx)\r\n{\r\nstruct bnad *bnad = (struct bnad *)arg;\r\ncomplete(&bnad->bnad_completions.rx_comp);\r\n}\r\nstatic void\r\nbnad_cb_rx_mcast_add(struct bnad *bnad, struct bna_rx *rx)\r\n{\r\nbnad->bnad_completions.mcast_comp_status = BNA_CB_SUCCESS;\r\ncomplete(&bnad->bnad_completions.mcast_comp);\r\n}\r\nvoid\r\nbnad_cb_stats_get(struct bnad *bnad, enum bna_cb_status status,\r\nstruct bna_stats *stats)\r\n{\r\nif (status == BNA_CB_SUCCESS)\r\nBNAD_UPDATE_CTR(bnad, hw_stats_updates);\r\nif (!netif_running(bnad->netdev) ||\r\n!test_bit(BNAD_RF_STATS_TIMER_RUNNING, &bnad->run_flags))\r\nreturn;\r\nmod_timer(&bnad->stats_timer,\r\njiffies + msecs_to_jiffies(BNAD_STATS_TIMER_FREQ));\r\n}\r\nstatic void\r\nbnad_cb_enet_mtu_set(struct bnad *bnad)\r\n{\r\nbnad->bnad_completions.mtu_comp_status = BNA_CB_SUCCESS;\r\ncomplete(&bnad->bnad_completions.mtu_comp);\r\n}\r\nvoid\r\nbnad_cb_completion(void *arg, enum bfa_status status)\r\n{\r\nstruct bnad_iocmd_comp *iocmd_comp =\r\n(struct bnad_iocmd_comp *)arg;\r\niocmd_comp->comp_status = (u32) status;\r\ncomplete(&iocmd_comp->comp);\r\n}\r\nstatic void\r\nbnad_mem_free(struct bnad *bnad,\r\nstruct bna_mem_info *mem_info)\r\n{\r\nint i;\r\ndma_addr_t dma_pa;\r\nif (mem_info->mdl == NULL)\r\nreturn;\r\nfor (i = 0; i < mem_info->num; i++) {\r\nif (mem_info->mdl[i].kva != NULL) {\r\nif (mem_info->mem_type == BNA_MEM_T_DMA) {\r\nBNA_GET_DMA_ADDR(&(mem_info->mdl[i].dma),\r\ndma_pa);\r\ndma_free_coherent(&bnad->pcidev->dev,\r\nmem_info->mdl[i].len,\r\nmem_info->mdl[i].kva, dma_pa);\r\n} else\r\nkfree(mem_info->mdl[i].kva);\r\n}\r\n}\r\nkfree(mem_info->mdl);\r\nmem_info->mdl = NULL;\r\n}\r\nstatic int\r\nbnad_mem_alloc(struct bnad *bnad,\r\nstruct bna_mem_info *mem_info)\r\n{\r\nint i;\r\ndma_addr_t dma_pa;\r\nif ((mem_info->num == 0) || (mem_info->len == 0)) {\r\nmem_info->mdl = NULL;\r\nreturn 0;\r\n}\r\nmem_info->mdl = kcalloc(mem_info->num, sizeof(struct bna_mem_descr),\r\nGFP_KERNEL);\r\nif (mem_info->mdl == NULL)\r\nreturn -ENOMEM;\r\nif (mem_info->mem_type == BNA_MEM_T_DMA) {\r\nfor (i = 0; i < mem_info->num; i++) {\r\nmem_info->mdl[i].len = mem_info->len;\r\nmem_info->mdl[i].kva =\r\ndma_alloc_coherent(&bnad->pcidev->dev,\r\nmem_info->len, &dma_pa,\r\nGFP_KERNEL);\r\nif (mem_info->mdl[i].kva == NULL)\r\ngoto err_return;\r\nBNA_SET_DMA_ADDR(dma_pa,\r\n&(mem_info->mdl[i].dma));\r\n}\r\n} else {\r\nfor (i = 0; i < mem_info->num; i++) {\r\nmem_info->mdl[i].len = mem_info->len;\r\nmem_info->mdl[i].kva = kzalloc(mem_info->len,\r\nGFP_KERNEL);\r\nif (mem_info->mdl[i].kva == NULL)\r\ngoto err_return;\r\n}\r\n}\r\nreturn 0;\r\nerr_return:\r\nbnad_mem_free(bnad, mem_info);\r\nreturn -ENOMEM;\r\n}\r\nstatic void\r\nbnad_mbox_irq_free(struct bnad *bnad)\r\n{\r\nint irq;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbnad_disable_mbox_irq(bnad);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nirq = BNAD_GET_MBOX_IRQ(bnad);\r\nfree_irq(irq, bnad);\r\n}\r\nstatic int\r\nbnad_mbox_irq_alloc(struct bnad *bnad)\r\n{\r\nint err = 0;\r\nunsigned long irq_flags, flags;\r\nu32 irq;\r\nirq_handler_t irq_handler;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nif (bnad->cfg_flags & BNAD_CF_MSIX) {\r\nirq_handler = (irq_handler_t)bnad_msix_mbox_handler;\r\nirq = bnad->msix_table[BNAD_MAILBOX_MSIX_INDEX].vector;\r\nirq_flags = 0;\r\n} else {\r\nirq_handler = (irq_handler_t)bnad_isr;\r\nirq = bnad->pcidev->irq;\r\nirq_flags = IRQF_SHARED;\r\n}\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nsprintf(bnad->mbox_irq_name, "%s", BNAD_NAME);\r\nset_bit(BNAD_RF_MBOX_IRQ_DISABLED, &bnad->run_flags);\r\nBNAD_UPDATE_CTR(bnad, mbox_intr_disabled);\r\nerr = request_irq(irq, irq_handler, irq_flags,\r\nbnad->mbox_irq_name, bnad);\r\nreturn err;\r\n}\r\nstatic void\r\nbnad_txrx_irq_free(struct bnad *bnad, struct bna_intr_info *intr_info)\r\n{\r\nkfree(intr_info->idl);\r\nintr_info->idl = NULL;\r\n}\r\nstatic int\r\nbnad_txrx_irq_alloc(struct bnad *bnad, enum bnad_intr_source src,\r\nu32 txrx_id, struct bna_intr_info *intr_info)\r\n{\r\nint i, vector_start = 0;\r\nu32 cfg_flags;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\ncfg_flags = bnad->cfg_flags;\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nif (cfg_flags & BNAD_CF_MSIX) {\r\nintr_info->intr_type = BNA_INTR_T_MSIX;\r\nintr_info->idl = kcalloc(intr_info->num,\r\nsizeof(struct bna_intr_descr),\r\nGFP_KERNEL);\r\nif (!intr_info->idl)\r\nreturn -ENOMEM;\r\nswitch (src) {\r\ncase BNAD_INTR_TX:\r\nvector_start = BNAD_MAILBOX_MSIX_VECTORS + txrx_id;\r\nbreak;\r\ncase BNAD_INTR_RX:\r\nvector_start = BNAD_MAILBOX_MSIX_VECTORS +\r\n(bnad->num_tx * bnad->num_txq_per_tx) +\r\ntxrx_id;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nfor (i = 0; i < intr_info->num; i++)\r\nintr_info->idl[i].vector = vector_start + i;\r\n} else {\r\nintr_info->intr_type = BNA_INTR_T_INTX;\r\nintr_info->num = 1;\r\nintr_info->idl = kcalloc(intr_info->num,\r\nsizeof(struct bna_intr_descr),\r\nGFP_KERNEL);\r\nif (!intr_info->idl)\r\nreturn -ENOMEM;\r\nswitch (src) {\r\ncase BNAD_INTR_TX:\r\nintr_info->idl[0].vector = BNAD_INTX_TX_IB_BITMASK;\r\nbreak;\r\ncase BNAD_INTR_RX:\r\nintr_info->idl[0].vector = BNAD_INTX_RX_IB_BITMASK;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nbnad_tx_msix_unregister(struct bnad *bnad, struct bnad_tx_info *tx_info,\r\nint num_txqs)\r\n{\r\nint i;\r\nint vector_num;\r\nfor (i = 0; i < num_txqs; i++) {\r\nif (tx_info->tcb[i] == NULL)\r\ncontinue;\r\nvector_num = tx_info->tcb[i]->intr_vector;\r\nfree_irq(bnad->msix_table[vector_num].vector, tx_info->tcb[i]);\r\n}\r\n}\r\nstatic int\r\nbnad_tx_msix_register(struct bnad *bnad, struct bnad_tx_info *tx_info,\r\nu32 tx_id, int num_txqs)\r\n{\r\nint i;\r\nint err;\r\nint vector_num;\r\nfor (i = 0; i < num_txqs; i++) {\r\nvector_num = tx_info->tcb[i]->intr_vector;\r\nsprintf(tx_info->tcb[i]->name, "%s TXQ %d", bnad->netdev->name,\r\ntx_id + tx_info->tcb[i]->id);\r\nerr = request_irq(bnad->msix_table[vector_num].vector,\r\n(irq_handler_t)bnad_msix_tx, 0,\r\ntx_info->tcb[i]->name,\r\ntx_info->tcb[i]);\r\nif (err)\r\ngoto err_return;\r\n}\r\nreturn 0;\r\nerr_return:\r\nif (i > 0)\r\nbnad_tx_msix_unregister(bnad, tx_info, (i - 1));\r\nreturn -1;\r\n}\r\nstatic void\r\nbnad_rx_msix_unregister(struct bnad *bnad, struct bnad_rx_info *rx_info,\r\nint num_rxps)\r\n{\r\nint i;\r\nint vector_num;\r\nfor (i = 0; i < num_rxps; i++) {\r\nif (rx_info->rx_ctrl[i].ccb == NULL)\r\ncontinue;\r\nvector_num = rx_info->rx_ctrl[i].ccb->intr_vector;\r\nfree_irq(bnad->msix_table[vector_num].vector,\r\nrx_info->rx_ctrl[i].ccb);\r\n}\r\n}\r\nstatic int\r\nbnad_rx_msix_register(struct bnad *bnad, struct bnad_rx_info *rx_info,\r\nu32 rx_id, int num_rxps)\r\n{\r\nint i;\r\nint err;\r\nint vector_num;\r\nfor (i = 0; i < num_rxps; i++) {\r\nvector_num = rx_info->rx_ctrl[i].ccb->intr_vector;\r\nsprintf(rx_info->rx_ctrl[i].ccb->name, "%s CQ %d",\r\nbnad->netdev->name,\r\nrx_id + rx_info->rx_ctrl[i].ccb->id);\r\nerr = request_irq(bnad->msix_table[vector_num].vector,\r\n(irq_handler_t)bnad_msix_rx, 0,\r\nrx_info->rx_ctrl[i].ccb->name,\r\nrx_info->rx_ctrl[i].ccb);\r\nif (err)\r\ngoto err_return;\r\n}\r\nreturn 0;\r\nerr_return:\r\nif (i > 0)\r\nbnad_rx_msix_unregister(bnad, rx_info, (i - 1));\r\nreturn -1;\r\n}\r\nstatic void\r\nbnad_tx_res_free(struct bnad *bnad, struct bna_res_info *res_info)\r\n{\r\nint i;\r\nfor (i = 0; i < BNA_TX_RES_T_MAX; i++) {\r\nif (res_info[i].res_type == BNA_RES_T_MEM)\r\nbnad_mem_free(bnad, &res_info[i].res_u.mem_info);\r\nelse if (res_info[i].res_type == BNA_RES_T_INTR)\r\nbnad_txrx_irq_free(bnad, &res_info[i].res_u.intr_info);\r\n}\r\n}\r\nstatic int\r\nbnad_tx_res_alloc(struct bnad *bnad, struct bna_res_info *res_info,\r\nu32 tx_id)\r\n{\r\nint i, err = 0;\r\nfor (i = 0; i < BNA_TX_RES_T_MAX; i++) {\r\nif (res_info[i].res_type == BNA_RES_T_MEM)\r\nerr = bnad_mem_alloc(bnad,\r\n&res_info[i].res_u.mem_info);\r\nelse if (res_info[i].res_type == BNA_RES_T_INTR)\r\nerr = bnad_txrx_irq_alloc(bnad, BNAD_INTR_TX, tx_id,\r\n&res_info[i].res_u.intr_info);\r\nif (err)\r\ngoto err_return;\r\n}\r\nreturn 0;\r\nerr_return:\r\nbnad_tx_res_free(bnad, res_info);\r\nreturn err;\r\n}\r\nstatic void\r\nbnad_rx_res_free(struct bnad *bnad, struct bna_res_info *res_info)\r\n{\r\nint i;\r\nfor (i = 0; i < BNA_RX_RES_T_MAX; i++) {\r\nif (res_info[i].res_type == BNA_RES_T_MEM)\r\nbnad_mem_free(bnad, &res_info[i].res_u.mem_info);\r\nelse if (res_info[i].res_type == BNA_RES_T_INTR)\r\nbnad_txrx_irq_free(bnad, &res_info[i].res_u.intr_info);\r\n}\r\n}\r\nstatic int\r\nbnad_rx_res_alloc(struct bnad *bnad, struct bna_res_info *res_info,\r\nuint rx_id)\r\n{\r\nint i, err = 0;\r\nfor (i = 0; i < BNA_RX_RES_T_MAX; i++) {\r\nif (res_info[i].res_type == BNA_RES_T_MEM)\r\nerr = bnad_mem_alloc(bnad,\r\n&res_info[i].res_u.mem_info);\r\nelse if (res_info[i].res_type == BNA_RES_T_INTR)\r\nerr = bnad_txrx_irq_alloc(bnad, BNAD_INTR_RX, rx_id,\r\n&res_info[i].res_u.intr_info);\r\nif (err)\r\ngoto err_return;\r\n}\r\nreturn 0;\r\nerr_return:\r\nbnad_rx_res_free(bnad, res_info);\r\nreturn err;\r\n}\r\nstatic void\r\nbnad_ioc_timeout(unsigned long data)\r\n{\r\nstruct bnad *bnad = (struct bnad *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbfa_nw_ioc_timeout(&bnad->bna.ioceth.ioc);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\n}\r\nstatic void\r\nbnad_ioc_hb_check(unsigned long data)\r\n{\r\nstruct bnad *bnad = (struct bnad *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbfa_nw_ioc_hb_check(&bnad->bna.ioceth.ioc);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\n}\r\nstatic void\r\nbnad_iocpf_timeout(unsigned long data)\r\n{\r\nstruct bnad *bnad = (struct bnad *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbfa_nw_iocpf_timeout(&bnad->bna.ioceth.ioc);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\n}\r\nstatic void\r\nbnad_iocpf_sem_timeout(unsigned long data)\r\n{\r\nstruct bnad *bnad = (struct bnad *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbfa_nw_iocpf_sem_timeout(&bnad->bna.ioceth.ioc);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\n}\r\nstatic void\r\nbnad_dim_timeout(unsigned long data)\r\n{\r\nstruct bnad *bnad = (struct bnad *)data;\r\nstruct bnad_rx_info *rx_info;\r\nstruct bnad_rx_ctrl *rx_ctrl;\r\nint i, j;\r\nunsigned long flags;\r\nif (!netif_carrier_ok(bnad->netdev))\r\nreturn;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nfor (i = 0; i < bnad->num_rx; i++) {\r\nrx_info = &bnad->rx_info[i];\r\nif (!rx_info->rx)\r\ncontinue;\r\nfor (j = 0; j < bnad->num_rxp_per_rx; j++) {\r\nrx_ctrl = &rx_info->rx_ctrl[j];\r\nif (!rx_ctrl->ccb)\r\ncontinue;\r\nbna_rx_dim_update(rx_ctrl->ccb);\r\n}\r\n}\r\nif (test_bit(BNAD_RF_DIM_TIMER_RUNNING, &bnad->run_flags))\r\nmod_timer(&bnad->dim_timer,\r\njiffies + msecs_to_jiffies(BNAD_DIM_TIMER_FREQ));\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\n}\r\nstatic void\r\nbnad_stats_timeout(unsigned long data)\r\n{\r\nstruct bnad *bnad = (struct bnad *)data;\r\nunsigned long flags;\r\nif (!netif_running(bnad->netdev) ||\r\n!test_bit(BNAD_RF_STATS_TIMER_RUNNING, &bnad->run_flags))\r\nreturn;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_hw_stats_get(&bnad->bna);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\n}\r\nvoid\r\nbnad_dim_timer_start(struct bnad *bnad)\r\n{\r\nif (bnad->cfg_flags & BNAD_CF_DIM_ENABLED &&\r\n!test_bit(BNAD_RF_DIM_TIMER_RUNNING, &bnad->run_flags)) {\r\nsetup_timer(&bnad->dim_timer, bnad_dim_timeout,\r\n(unsigned long)bnad);\r\nset_bit(BNAD_RF_DIM_TIMER_RUNNING, &bnad->run_flags);\r\nmod_timer(&bnad->dim_timer,\r\njiffies + msecs_to_jiffies(BNAD_DIM_TIMER_FREQ));\r\n}\r\n}\r\nstatic void\r\nbnad_stats_timer_start(struct bnad *bnad)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nif (!test_and_set_bit(BNAD_RF_STATS_TIMER_RUNNING, &bnad->run_flags)) {\r\nsetup_timer(&bnad->stats_timer, bnad_stats_timeout,\r\n(unsigned long)bnad);\r\nmod_timer(&bnad->stats_timer,\r\njiffies + msecs_to_jiffies(BNAD_STATS_TIMER_FREQ));\r\n}\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\n}\r\nstatic void\r\nbnad_stats_timer_stop(struct bnad *bnad)\r\n{\r\nint to_del = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nif (test_and_clear_bit(BNAD_RF_STATS_TIMER_RUNNING, &bnad->run_flags))\r\nto_del = 1;\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nif (to_del)\r\ndel_timer_sync(&bnad->stats_timer);\r\n}\r\nstatic void\r\nbnad_netdev_mc_list_get(struct net_device *netdev, u8 *mc_list)\r\n{\r\nint i = 1;\r\nstruct netdev_hw_addr *mc_addr;\r\nnetdev_for_each_mc_addr(mc_addr, netdev) {\r\nether_addr_copy(&mc_list[i * ETH_ALEN], &mc_addr->addr[0]);\r\ni++;\r\n}\r\n}\r\nstatic int\r\nbnad_napi_poll_rx(struct napi_struct *napi, int budget)\r\n{\r\nstruct bnad_rx_ctrl *rx_ctrl =\r\ncontainer_of(napi, struct bnad_rx_ctrl, napi);\r\nstruct bnad *bnad = rx_ctrl->bnad;\r\nint rcvd = 0;\r\nrx_ctrl->rx_poll_ctr++;\r\nif (!netif_carrier_ok(bnad->netdev))\r\ngoto poll_exit;\r\nrcvd = bnad_cq_process(bnad, rx_ctrl->ccb, budget);\r\nif (rcvd >= budget)\r\nreturn rcvd;\r\npoll_exit:\r\nnapi_complete_done(napi, rcvd);\r\nrx_ctrl->rx_complete++;\r\nif (rx_ctrl->ccb)\r\nbnad_enable_rx_irq_unsafe(rx_ctrl->ccb);\r\nreturn rcvd;\r\n}\r\nstatic void\r\nbnad_napi_add(struct bnad *bnad, u32 rx_id)\r\n{\r\nstruct bnad_rx_ctrl *rx_ctrl;\r\nint i;\r\nfor (i = 0; i < bnad->num_rxp_per_rx; i++) {\r\nrx_ctrl = &bnad->rx_info[rx_id].rx_ctrl[i];\r\nnetif_napi_add(bnad->netdev, &rx_ctrl->napi,\r\nbnad_napi_poll_rx, BNAD_NAPI_POLL_QUOTA);\r\n}\r\n}\r\nstatic void\r\nbnad_napi_delete(struct bnad *bnad, u32 rx_id)\r\n{\r\nint i;\r\nfor (i = 0; i < bnad->num_rxp_per_rx; i++)\r\nnetif_napi_del(&bnad->rx_info[rx_id].rx_ctrl[i].napi);\r\n}\r\nvoid\r\nbnad_destroy_tx(struct bnad *bnad, u32 tx_id)\r\n{\r\nstruct bnad_tx_info *tx_info = &bnad->tx_info[tx_id];\r\nstruct bna_res_info *res_info = &bnad->tx_res_info[tx_id].res_info[0];\r\nunsigned long flags;\r\nif (!tx_info->tx)\r\nreturn;\r\ninit_completion(&bnad->bnad_completions.tx_comp);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_tx_disable(tx_info->tx, BNA_HARD_CLEANUP, bnad_cb_tx_disabled);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nwait_for_completion(&bnad->bnad_completions.tx_comp);\r\nif (tx_info->tcb[0]->intr_type == BNA_INTR_T_MSIX)\r\nbnad_tx_msix_unregister(bnad, tx_info,\r\nbnad->num_txq_per_tx);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_tx_destroy(tx_info->tx);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\ntx_info->tx = NULL;\r\ntx_info->tx_id = 0;\r\nbnad_tx_res_free(bnad, res_info);\r\n}\r\nint\r\nbnad_setup_tx(struct bnad *bnad, u32 tx_id)\r\n{\r\nint err;\r\nstruct bnad_tx_info *tx_info = &bnad->tx_info[tx_id];\r\nstruct bna_res_info *res_info = &bnad->tx_res_info[tx_id].res_info[0];\r\nstruct bna_intr_info *intr_info =\r\n&res_info[BNA_TX_RES_INTR_T_TXCMPL].res_u.intr_info;\r\nstruct bna_tx_config *tx_config = &bnad->tx_config[tx_id];\r\nstatic const struct bna_tx_event_cbfn tx_cbfn = {\r\n.tcb_setup_cbfn = bnad_cb_tcb_setup,\r\n.tcb_destroy_cbfn = bnad_cb_tcb_destroy,\r\n.tx_stall_cbfn = bnad_cb_tx_stall,\r\n.tx_resume_cbfn = bnad_cb_tx_resume,\r\n.tx_cleanup_cbfn = bnad_cb_tx_cleanup,\r\n};\r\nstruct bna_tx *tx;\r\nunsigned long flags;\r\ntx_info->tx_id = tx_id;\r\ntx_config->num_txq = bnad->num_txq_per_tx;\r\ntx_config->txq_depth = bnad->txq_depth;\r\ntx_config->tx_type = BNA_TX_T_REGULAR;\r\ntx_config->coalescing_timeo = bnad->tx_coalescing_timeo;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_tx_res_req(bnad->num_txq_per_tx,\r\nbnad->txq_depth, res_info);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nBNAD_FILL_UNMAPQ_MEM_REQ(&res_info[BNA_TX_RES_MEM_T_UNMAPQ],\r\nbnad->num_txq_per_tx, (sizeof(struct bnad_tx_unmap) *\r\nbnad->txq_depth));\r\nerr = bnad_tx_res_alloc(bnad, res_info, tx_id);\r\nif (err)\r\nreturn err;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\ntx = bna_tx_create(&bnad->bna, bnad, tx_config, &tx_cbfn, res_info,\r\ntx_info);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nif (!tx) {\r\nerr = -ENOMEM;\r\ngoto err_return;\r\n}\r\ntx_info->tx = tx;\r\nINIT_DELAYED_WORK(&tx_info->tx_cleanup_work,\r\n(work_func_t)bnad_tx_cleanup);\r\nif (intr_info->intr_type == BNA_INTR_T_MSIX) {\r\nerr = bnad_tx_msix_register(bnad, tx_info,\r\ntx_id, bnad->num_txq_per_tx);\r\nif (err)\r\ngoto cleanup_tx;\r\n}\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_tx_enable(tx);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nreturn 0;\r\ncleanup_tx:\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_tx_destroy(tx_info->tx);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\ntx_info->tx = NULL;\r\ntx_info->tx_id = 0;\r\nerr_return:\r\nbnad_tx_res_free(bnad, res_info);\r\nreturn err;\r\n}\r\nstatic void\r\nbnad_init_rx_config(struct bnad *bnad, struct bna_rx_config *rx_config)\r\n{\r\nmemset(rx_config, 0, sizeof(*rx_config));\r\nrx_config->rx_type = BNA_RX_T_REGULAR;\r\nrx_config->num_paths = bnad->num_rxp_per_rx;\r\nrx_config->coalescing_timeo = bnad->rx_coalescing_timeo;\r\nif (bnad->num_rxp_per_rx > 1) {\r\nrx_config->rss_status = BNA_STATUS_T_ENABLED;\r\nrx_config->rss_config.hash_type =\r\n(BFI_ENET_RSS_IPV6 |\r\nBFI_ENET_RSS_IPV6_TCP |\r\nBFI_ENET_RSS_IPV4 |\r\nBFI_ENET_RSS_IPV4_TCP);\r\nrx_config->rss_config.hash_mask =\r\nbnad->num_rxp_per_rx - 1;\r\nnetdev_rss_key_fill(rx_config->rss_config.toeplitz_hash_key,\r\nsizeof(rx_config->rss_config.toeplitz_hash_key));\r\n} else {\r\nrx_config->rss_status = BNA_STATUS_T_DISABLED;\r\nmemset(&rx_config->rss_config, 0,\r\nsizeof(rx_config->rss_config));\r\n}\r\nrx_config->frame_size = BNAD_FRAME_SIZE(bnad->netdev->mtu);\r\nrx_config->q0_multi_buf = BNA_STATUS_T_DISABLED;\r\nrx_config->rxp_type = BNA_RXP_SLR;\r\nif (BNAD_PCI_DEV_IS_CAT2(bnad) &&\r\nrx_config->frame_size > 4096) {\r\nrx_config->q0_buf_size = 2048;\r\nrx_config->q0_num_vecs = 4;\r\nrx_config->q0_depth = bnad->rxq_depth * rx_config->q0_num_vecs;\r\nrx_config->q0_multi_buf = BNA_STATUS_T_ENABLED;\r\n} else {\r\nrx_config->q0_buf_size = rx_config->frame_size;\r\nrx_config->q0_num_vecs = 1;\r\nrx_config->q0_depth = bnad->rxq_depth;\r\n}\r\nif (rx_config->rxp_type == BNA_RXP_SLR) {\r\nrx_config->q1_depth = bnad->rxq_depth;\r\nrx_config->q1_buf_size = BFI_SMALL_RXBUF_SIZE;\r\n}\r\nrx_config->vlan_strip_status =\r\n(bnad->netdev->features & NETIF_F_HW_VLAN_CTAG_RX) ?\r\nBNA_STATUS_T_ENABLED : BNA_STATUS_T_DISABLED;\r\n}\r\nstatic void\r\nbnad_rx_ctrl_init(struct bnad *bnad, u32 rx_id)\r\n{\r\nstruct bnad_rx_info *rx_info = &bnad->rx_info[rx_id];\r\nint i;\r\nfor (i = 0; i < bnad->num_rxp_per_rx; i++)\r\nrx_info->rx_ctrl[i].bnad = bnad;\r\n}\r\nstatic u32\r\nbnad_reinit_rx(struct bnad *bnad)\r\n{\r\nstruct net_device *netdev = bnad->netdev;\r\nu32 err = 0, current_err = 0;\r\nu32 rx_id = 0, count = 0;\r\nunsigned long flags;\r\nfor (rx_id = 0; rx_id < bnad->num_rx; rx_id++) {\r\nif (!bnad->rx_info[rx_id].rx)\r\ncontinue;\r\nbnad_destroy_rx(bnad, rx_id);\r\n}\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_enet_mtu_set(&bnad->bna.enet,\r\nBNAD_FRAME_SIZE(bnad->netdev->mtu), NULL);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nfor (rx_id = 0; rx_id < bnad->num_rx; rx_id++) {\r\ncount++;\r\ncurrent_err = bnad_setup_rx(bnad, rx_id);\r\nif (current_err && !err) {\r\nerr = current_err;\r\nnetdev_err(netdev, "RXQ:%u setup failed\n", rx_id);\r\n}\r\n}\r\nif (bnad->rx_info[0].rx && !err) {\r\nbnad_restore_vlans(bnad, 0);\r\nbnad_enable_default_bcast(bnad);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbnad_mac_addr_set_locked(bnad, netdev->dev_addr);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nbnad_set_rx_mode(netdev);\r\n}\r\nreturn count;\r\n}\r\nvoid\r\nbnad_destroy_rx(struct bnad *bnad, u32 rx_id)\r\n{\r\nstruct bnad_rx_info *rx_info = &bnad->rx_info[rx_id];\r\nstruct bna_rx_config *rx_config = &bnad->rx_config[rx_id];\r\nstruct bna_res_info *res_info = &bnad->rx_res_info[rx_id].res_info[0];\r\nunsigned long flags;\r\nint to_del = 0;\r\nif (!rx_info->rx)\r\nreturn;\r\nif (0 == rx_id) {\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nif (bnad->cfg_flags & BNAD_CF_DIM_ENABLED &&\r\ntest_bit(BNAD_RF_DIM_TIMER_RUNNING, &bnad->run_flags)) {\r\nclear_bit(BNAD_RF_DIM_TIMER_RUNNING, &bnad->run_flags);\r\nto_del = 1;\r\n}\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nif (to_del)\r\ndel_timer_sync(&bnad->dim_timer);\r\n}\r\ninit_completion(&bnad->bnad_completions.rx_comp);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_rx_disable(rx_info->rx, BNA_HARD_CLEANUP, bnad_cb_rx_disabled);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nwait_for_completion(&bnad->bnad_completions.rx_comp);\r\nif (rx_info->rx_ctrl[0].ccb->intr_type == BNA_INTR_T_MSIX)\r\nbnad_rx_msix_unregister(bnad, rx_info, rx_config->num_paths);\r\nbnad_napi_delete(bnad, rx_id);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_rx_destroy(rx_info->rx);\r\nrx_info->rx = NULL;\r\nrx_info->rx_id = 0;\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nbnad_rx_res_free(bnad, res_info);\r\n}\r\nint\r\nbnad_setup_rx(struct bnad *bnad, u32 rx_id)\r\n{\r\nint err;\r\nstruct bnad_rx_info *rx_info = &bnad->rx_info[rx_id];\r\nstruct bna_res_info *res_info = &bnad->rx_res_info[rx_id].res_info[0];\r\nstruct bna_intr_info *intr_info =\r\n&res_info[BNA_RX_RES_T_INTR].res_u.intr_info;\r\nstruct bna_rx_config *rx_config = &bnad->rx_config[rx_id];\r\nstatic const struct bna_rx_event_cbfn rx_cbfn = {\r\n.rcb_setup_cbfn = NULL,\r\n.rcb_destroy_cbfn = NULL,\r\n.ccb_setup_cbfn = bnad_cb_ccb_setup,\r\n.ccb_destroy_cbfn = bnad_cb_ccb_destroy,\r\n.rx_stall_cbfn = bnad_cb_rx_stall,\r\n.rx_cleanup_cbfn = bnad_cb_rx_cleanup,\r\n.rx_post_cbfn = bnad_cb_rx_post,\r\n};\r\nstruct bna_rx *rx;\r\nunsigned long flags;\r\nrx_info->rx_id = rx_id;\r\nbnad_init_rx_config(bnad, rx_config);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_rx_res_req(rx_config, res_info);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nBNAD_FILL_UNMAPQ_MEM_REQ(&res_info[BNA_RX_RES_MEM_T_UNMAPDQ],\r\nrx_config->num_paths,\r\n(rx_config->q0_depth *\r\nsizeof(struct bnad_rx_unmap)) +\r\nsizeof(struct bnad_rx_unmap_q));\r\nif (rx_config->rxp_type != BNA_RXP_SINGLE) {\r\nBNAD_FILL_UNMAPQ_MEM_REQ(&res_info[BNA_RX_RES_MEM_T_UNMAPHQ],\r\nrx_config->num_paths,\r\n(rx_config->q1_depth *\r\nsizeof(struct bnad_rx_unmap) +\r\nsizeof(struct bnad_rx_unmap_q)));\r\n}\r\nerr = bnad_rx_res_alloc(bnad, res_info, rx_id);\r\nif (err)\r\nreturn err;\r\nbnad_rx_ctrl_init(bnad, rx_id);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nrx = bna_rx_create(&bnad->bna, bnad, rx_config, &rx_cbfn, res_info,\r\nrx_info);\r\nif (!rx) {\r\nerr = -ENOMEM;\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\ngoto err_return;\r\n}\r\nrx_info->rx = rx;\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nINIT_WORK(&rx_info->rx_cleanup_work,\r\n(work_func_t)(bnad_rx_cleanup));\r\nbnad_napi_add(bnad, rx_id);\r\nif (intr_info->intr_type == BNA_INTR_T_MSIX) {\r\nerr = bnad_rx_msix_register(bnad, rx_info, rx_id,\r\nrx_config->num_paths);\r\nif (err)\r\ngoto err_return;\r\n}\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nif (0 == rx_id) {\r\nif (bnad->cfg_flags & BNAD_CF_DIM_ENABLED)\r\nbna_rx_dim_reconfig(&bnad->bna, bna_napi_dim_vector);\r\nbna_rx_vlanfilter_enable(rx);\r\nbnad_dim_timer_start(bnad);\r\n}\r\nbna_rx_enable(rx);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nreturn 0;\r\nerr_return:\r\nbnad_destroy_rx(bnad, rx_id);\r\nreturn err;\r\n}\r\nvoid\r\nbnad_tx_coalescing_timeo_set(struct bnad *bnad)\r\n{\r\nstruct bnad_tx_info *tx_info;\r\ntx_info = &bnad->tx_info[0];\r\nif (!tx_info->tx)\r\nreturn;\r\nbna_tx_coalescing_timeo_set(tx_info->tx, bnad->tx_coalescing_timeo);\r\n}\r\nvoid\r\nbnad_rx_coalescing_timeo_set(struct bnad *bnad)\r\n{\r\nstruct bnad_rx_info *rx_info;\r\nint i;\r\nfor (i = 0; i < bnad->num_rx; i++) {\r\nrx_info = &bnad->rx_info[i];\r\nif (!rx_info->rx)\r\ncontinue;\r\nbna_rx_coalescing_timeo_set(rx_info->rx,\r\nbnad->rx_coalescing_timeo);\r\n}\r\n}\r\nint\r\nbnad_mac_addr_set_locked(struct bnad *bnad, const u8 *mac_addr)\r\n{\r\nint ret;\r\nif (!is_valid_ether_addr(mac_addr))\r\nreturn -EADDRNOTAVAIL;\r\nif (!bnad->rx_info[0].rx)\r\nreturn 0;\r\nret = bna_rx_ucast_set(bnad->rx_info[0].rx, mac_addr);\r\nif (ret != BNA_CB_SUCCESS)\r\nreturn -EADDRNOTAVAIL;\r\nreturn 0;\r\n}\r\nint\r\nbnad_enable_default_bcast(struct bnad *bnad)\r\n{\r\nstruct bnad_rx_info *rx_info = &bnad->rx_info[0];\r\nint ret;\r\nunsigned long flags;\r\ninit_completion(&bnad->bnad_completions.mcast_comp);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nret = bna_rx_mcast_add(rx_info->rx, bnad_bcast_addr,\r\nbnad_cb_rx_mcast_add);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nif (ret == BNA_CB_SUCCESS)\r\nwait_for_completion(&bnad->bnad_completions.mcast_comp);\r\nelse\r\nreturn -ENODEV;\r\nif (bnad->bnad_completions.mcast_comp_status != BNA_CB_SUCCESS)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nvoid\r\nbnad_restore_vlans(struct bnad *bnad, u32 rx_id)\r\n{\r\nu16 vid;\r\nunsigned long flags;\r\nfor_each_set_bit(vid, bnad->active_vlans, VLAN_N_VID) {\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_rx_vlan_add(bnad->rx_info[rx_id].rx, vid);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\n}\r\n}\r\nvoid\r\nbnad_netdev_qstats_fill(struct bnad *bnad, struct rtnl_link_stats64 *stats)\r\n{\r\nint i, j;\r\nfor (i = 0; i < bnad->num_rx; i++) {\r\nfor (j = 0; j < bnad->num_rxp_per_rx; j++) {\r\nif (bnad->rx_info[i].rx_ctrl[j].ccb) {\r\nstats->rx_packets += bnad->rx_info[i].\r\nrx_ctrl[j].ccb->rcb[0]->rxq->rx_packets;\r\nstats->rx_bytes += bnad->rx_info[i].\r\nrx_ctrl[j].ccb->rcb[0]->rxq->rx_bytes;\r\nif (bnad->rx_info[i].rx_ctrl[j].ccb->rcb[1] &&\r\nbnad->rx_info[i].rx_ctrl[j].ccb->\r\nrcb[1]->rxq) {\r\nstats->rx_packets +=\r\nbnad->rx_info[i].rx_ctrl[j].\r\nccb->rcb[1]->rxq->rx_packets;\r\nstats->rx_bytes +=\r\nbnad->rx_info[i].rx_ctrl[j].\r\nccb->rcb[1]->rxq->rx_bytes;\r\n}\r\n}\r\n}\r\n}\r\nfor (i = 0; i < bnad->num_tx; i++) {\r\nfor (j = 0; j < bnad->num_txq_per_tx; j++) {\r\nif (bnad->tx_info[i].tcb[j]) {\r\nstats->tx_packets +=\r\nbnad->tx_info[i].tcb[j]->txq->tx_packets;\r\nstats->tx_bytes +=\r\nbnad->tx_info[i].tcb[j]->txq->tx_bytes;\r\n}\r\n}\r\n}\r\n}\r\nvoid\r\nbnad_netdev_hwstats_fill(struct bnad *bnad, struct rtnl_link_stats64 *stats)\r\n{\r\nstruct bfi_enet_stats_mac *mac_stats;\r\nu32 bmap;\r\nint i;\r\nmac_stats = &bnad->stats.bna_stats->hw_stats.mac_stats;\r\nstats->rx_errors =\r\nmac_stats->rx_fcs_error + mac_stats->rx_alignment_error +\r\nmac_stats->rx_frame_length_error + mac_stats->rx_code_error +\r\nmac_stats->rx_undersize;\r\nstats->tx_errors = mac_stats->tx_fcs_error +\r\nmac_stats->tx_undersize;\r\nstats->rx_dropped = mac_stats->rx_drop;\r\nstats->tx_dropped = mac_stats->tx_drop;\r\nstats->multicast = mac_stats->rx_multicast;\r\nstats->collisions = mac_stats->tx_total_collision;\r\nstats->rx_length_errors = mac_stats->rx_frame_length_error;\r\nstats->rx_crc_errors = mac_stats->rx_fcs_error;\r\nstats->rx_frame_errors = mac_stats->rx_alignment_error;\r\nbmap = bna_rx_rid_mask(&bnad->bna);\r\nfor (i = 0; bmap; i++) {\r\nif (bmap & 1) {\r\nstats->rx_fifo_errors +=\r\nbnad->stats.bna_stats->\r\nhw_stats.rxf_stats[i].frame_drops;\r\nbreak;\r\n}\r\nbmap >>= 1;\r\n}\r\n}\r\nstatic void\r\nbnad_mbox_irq_sync(struct bnad *bnad)\r\n{\r\nu32 irq;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nif (bnad->cfg_flags & BNAD_CF_MSIX)\r\nirq = bnad->msix_table[BNAD_MAILBOX_MSIX_INDEX].vector;\r\nelse\r\nirq = bnad->pcidev->irq;\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nsynchronize_irq(irq);\r\n}\r\nstatic int\r\nbnad_tso_prepare(struct bnad *bnad, struct sk_buff *skb)\r\n{\r\nint err;\r\nerr = skb_cow_head(skb, 0);\r\nif (err < 0) {\r\nBNAD_UPDATE_CTR(bnad, tso_err);\r\nreturn err;\r\n}\r\nif (vlan_get_protocol(skb) == htons(ETH_P_IP)) {\r\nstruct iphdr *iph = ip_hdr(skb);\r\niph->tot_len = 0;\r\niph->check = 0;\r\ntcp_hdr(skb)->check =\r\n~csum_tcpudp_magic(iph->saddr, iph->daddr, 0,\r\nIPPROTO_TCP, 0);\r\nBNAD_UPDATE_CTR(bnad, tso4);\r\n} else {\r\nstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\r\nipv6h->payload_len = 0;\r\ntcp_hdr(skb)->check =\r\n~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr, 0,\r\nIPPROTO_TCP, 0);\r\nBNAD_UPDATE_CTR(bnad, tso6);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nbnad_q_num_init(struct bnad *bnad)\r\n{\r\nint rxps;\r\nrxps = min((uint)num_online_cpus(),\r\n(uint)(BNAD_MAX_RX * BNAD_MAX_RXP_PER_RX));\r\nif (!(bnad->cfg_flags & BNAD_CF_MSIX))\r\nrxps = 1;\r\nbnad->num_rx = 1;\r\nbnad->num_tx = 1;\r\nbnad->num_rxp_per_rx = rxps;\r\nbnad->num_txq_per_tx = BNAD_TXQ_NUM;\r\n}\r\nstatic void\r\nbnad_q_num_adjust(struct bnad *bnad, int msix_vectors, int temp)\r\n{\r\nbnad->num_txq_per_tx = 1;\r\nif ((msix_vectors >= (bnad->num_tx * bnad->num_txq_per_tx) +\r\nbnad_rxqs_per_cq + BNAD_MAILBOX_MSIX_VECTORS) &&\r\n(bnad->cfg_flags & BNAD_CF_MSIX)) {\r\nbnad->num_rxp_per_rx = msix_vectors -\r\n(bnad->num_tx * bnad->num_txq_per_tx) -\r\nBNAD_MAILBOX_MSIX_VECTORS;\r\n} else\r\nbnad->num_rxp_per_rx = 1;\r\n}\r\nstatic int\r\nbnad_ioceth_disable(struct bnad *bnad)\r\n{\r\nunsigned long flags;\r\nint err = 0;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\ninit_completion(&bnad->bnad_completions.ioc_comp);\r\nbna_ioceth_disable(&bnad->bna.ioceth, BNA_HARD_CLEANUP);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nwait_for_completion_timeout(&bnad->bnad_completions.ioc_comp,\r\nmsecs_to_jiffies(BNAD_IOCETH_TIMEOUT));\r\nerr = bnad->bnad_completions.ioc_comp_status;\r\nreturn err;\r\n}\r\nstatic int\r\nbnad_ioceth_enable(struct bnad *bnad)\r\n{\r\nint err = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\ninit_completion(&bnad->bnad_completions.ioc_comp);\r\nbnad->bnad_completions.ioc_comp_status = BNA_CB_WAITING;\r\nbna_ioceth_enable(&bnad->bna.ioceth);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nwait_for_completion_timeout(&bnad->bnad_completions.ioc_comp,\r\nmsecs_to_jiffies(BNAD_IOCETH_TIMEOUT));\r\nerr = bnad->bnad_completions.ioc_comp_status;\r\nreturn err;\r\n}\r\nstatic void\r\nbnad_res_free(struct bnad *bnad, struct bna_res_info *res_info,\r\nu32 res_val_max)\r\n{\r\nint i;\r\nfor (i = 0; i < res_val_max; i++)\r\nbnad_mem_free(bnad, &res_info[i].res_u.mem_info);\r\n}\r\nstatic int\r\nbnad_res_alloc(struct bnad *bnad, struct bna_res_info *res_info,\r\nu32 res_val_max)\r\n{\r\nint i, err;\r\nfor (i = 0; i < res_val_max; i++) {\r\nerr = bnad_mem_alloc(bnad, &res_info[i].res_u.mem_info);\r\nif (err)\r\ngoto err_return;\r\n}\r\nreturn 0;\r\nerr_return:\r\nbnad_res_free(bnad, res_info, res_val_max);\r\nreturn err;\r\n}\r\nstatic void\r\nbnad_enable_msix(struct bnad *bnad)\r\n{\r\nint i, ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nif (!(bnad->cfg_flags & BNAD_CF_MSIX)) {\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nif (bnad->msix_table)\r\nreturn;\r\nbnad->msix_table =\r\nkcalloc(bnad->msix_num, sizeof(struct msix_entry), GFP_KERNEL);\r\nif (!bnad->msix_table)\r\ngoto intx_mode;\r\nfor (i = 0; i < bnad->msix_num; i++)\r\nbnad->msix_table[i].entry = i;\r\nret = pci_enable_msix_range(bnad->pcidev, bnad->msix_table,\r\n1, bnad->msix_num);\r\nif (ret < 0) {\r\ngoto intx_mode;\r\n} else if (ret < bnad->msix_num) {\r\ndev_warn(&bnad->pcidev->dev,\r\n"%d MSI-X vectors allocated < %d requested\n",\r\nret, bnad->msix_num);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbnad_q_num_adjust(bnad, (ret - BNAD_MAILBOX_MSIX_VECTORS) / 2,\r\n(ret - BNAD_MAILBOX_MSIX_VECTORS) / 2);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nbnad->msix_num = BNAD_NUM_TXQ + BNAD_NUM_RXP +\r\nBNAD_MAILBOX_MSIX_VECTORS;\r\nif (bnad->msix_num > ret) {\r\npci_disable_msix(bnad->pcidev);\r\ngoto intx_mode;\r\n}\r\n}\r\npci_intx(bnad->pcidev, 0);\r\nreturn;\r\nintx_mode:\r\ndev_warn(&bnad->pcidev->dev,\r\n"MSI-X enable failed - operating in INTx mode\n");\r\nkfree(bnad->msix_table);\r\nbnad->msix_table = NULL;\r\nbnad->msix_num = 0;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbnad->cfg_flags &= ~BNAD_CF_MSIX;\r\nbnad_q_num_init(bnad);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\n}\r\nstatic void\r\nbnad_disable_msix(struct bnad *bnad)\r\n{\r\nu32 cfg_flags;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\ncfg_flags = bnad->cfg_flags;\r\nif (bnad->cfg_flags & BNAD_CF_MSIX)\r\nbnad->cfg_flags &= ~BNAD_CF_MSIX;\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nif (cfg_flags & BNAD_CF_MSIX) {\r\npci_disable_msix(bnad->pcidev);\r\nkfree(bnad->msix_table);\r\nbnad->msix_table = NULL;\r\n}\r\n}\r\nstatic int\r\nbnad_open(struct net_device *netdev)\r\n{\r\nint err;\r\nstruct bnad *bnad = netdev_priv(netdev);\r\nstruct bna_pause_config pause_config;\r\nunsigned long flags;\r\nmutex_lock(&bnad->conf_mutex);\r\nerr = bnad_setup_tx(bnad, 0);\r\nif (err)\r\ngoto err_return;\r\nerr = bnad_setup_rx(bnad, 0);\r\nif (err)\r\ngoto cleanup_tx;\r\npause_config.tx_pause = 0;\r\npause_config.rx_pause = 0;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_enet_mtu_set(&bnad->bna.enet,\r\nBNAD_FRAME_SIZE(bnad->netdev->mtu), NULL);\r\nbna_enet_pause_config(&bnad->bna.enet, &pause_config);\r\nbna_enet_enable(&bnad->bna.enet);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nbnad_enable_default_bcast(bnad);\r\nbnad_restore_vlans(bnad, 0);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbnad_mac_addr_set_locked(bnad, netdev->dev_addr);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nbnad_stats_timer_start(bnad);\r\nmutex_unlock(&bnad->conf_mutex);\r\nreturn 0;\r\ncleanup_tx:\r\nbnad_destroy_tx(bnad, 0);\r\nerr_return:\r\nmutex_unlock(&bnad->conf_mutex);\r\nreturn err;\r\n}\r\nstatic int\r\nbnad_stop(struct net_device *netdev)\r\n{\r\nstruct bnad *bnad = netdev_priv(netdev);\r\nunsigned long flags;\r\nmutex_lock(&bnad->conf_mutex);\r\nbnad_stats_timer_stop(bnad);\r\ninit_completion(&bnad->bnad_completions.enet_comp);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_enet_disable(&bnad->bna.enet, BNA_HARD_CLEANUP,\r\nbnad_cb_enet_disabled);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nwait_for_completion(&bnad->bnad_completions.enet_comp);\r\nbnad_destroy_tx(bnad, 0);\r\nbnad_destroy_rx(bnad, 0);\r\nbnad_mbox_irq_sync(bnad);\r\nmutex_unlock(&bnad->conf_mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\nbnad_txq_wi_prepare(struct bnad *bnad, struct bna_tcb *tcb,\r\nstruct sk_buff *skb, struct bna_txq_entry *txqent)\r\n{\r\nu16 flags = 0;\r\nu32 gso_size;\r\nu16 vlan_tag = 0;\r\nif (skb_vlan_tag_present(skb)) {\r\nvlan_tag = (u16)skb_vlan_tag_get(skb);\r\nflags |= (BNA_TXQ_WI_CF_INS_PRIO | BNA_TXQ_WI_CF_INS_VLAN);\r\n}\r\nif (test_bit(BNAD_RF_CEE_RUNNING, &bnad->run_flags)) {\r\nvlan_tag = ((tcb->priority & 0x7) << VLAN_PRIO_SHIFT)\r\n| (vlan_tag & 0x1fff);\r\nflags |= (BNA_TXQ_WI_CF_INS_PRIO | BNA_TXQ_WI_CF_INS_VLAN);\r\n}\r\ntxqent->hdr.wi.vlan_tag = htons(vlan_tag);\r\nif (skb_is_gso(skb)) {\r\ngso_size = skb_shinfo(skb)->gso_size;\r\nif (unlikely(gso_size > bnad->netdev->mtu)) {\r\nBNAD_UPDATE_CTR(bnad, tx_skb_mss_too_long);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely((gso_size + skb_transport_offset(skb) +\r\ntcp_hdrlen(skb)) >= skb->len)) {\r\ntxqent->hdr.wi.opcode = htons(BNA_TXQ_WI_SEND);\r\ntxqent->hdr.wi.lso_mss = 0;\r\nBNAD_UPDATE_CTR(bnad, tx_skb_tso_too_short);\r\n} else {\r\ntxqent->hdr.wi.opcode = htons(BNA_TXQ_WI_SEND_LSO);\r\ntxqent->hdr.wi.lso_mss = htons(gso_size);\r\n}\r\nif (bnad_tso_prepare(bnad, skb)) {\r\nBNAD_UPDATE_CTR(bnad, tx_skb_tso_prepare);\r\nreturn -EINVAL;\r\n}\r\nflags |= (BNA_TXQ_WI_CF_IP_CKSUM | BNA_TXQ_WI_CF_TCP_CKSUM);\r\ntxqent->hdr.wi.l4_hdr_size_n_offset =\r\nhtons(BNA_TXQ_WI_L4_HDR_N_OFFSET(\r\ntcp_hdrlen(skb) >> 2, skb_transport_offset(skb)));\r\n} else {\r\ntxqent->hdr.wi.opcode = htons(BNA_TXQ_WI_SEND);\r\ntxqent->hdr.wi.lso_mss = 0;\r\nif (unlikely(skb->len > (bnad->netdev->mtu + VLAN_ETH_HLEN))) {\r\nBNAD_UPDATE_CTR(bnad, tx_skb_non_tso_too_long);\r\nreturn -EINVAL;\r\n}\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\n__be16 net_proto = vlan_get_protocol(skb);\r\nu8 proto = 0;\r\nif (net_proto == htons(ETH_P_IP))\r\nproto = ip_hdr(skb)->protocol;\r\n#ifdef NETIF_F_IPV6_CSUM\r\nelse if (net_proto == htons(ETH_P_IPV6)) {\r\nproto = ipv6_hdr(skb)->nexthdr;\r\n}\r\n#endif\r\nif (proto == IPPROTO_TCP) {\r\nflags |= BNA_TXQ_WI_CF_TCP_CKSUM;\r\ntxqent->hdr.wi.l4_hdr_size_n_offset =\r\nhtons(BNA_TXQ_WI_L4_HDR_N_OFFSET\r\n(0, skb_transport_offset(skb)));\r\nBNAD_UPDATE_CTR(bnad, tcpcsum_offload);\r\nif (unlikely(skb_headlen(skb) <\r\nskb_transport_offset(skb) +\r\ntcp_hdrlen(skb))) {\r\nBNAD_UPDATE_CTR(bnad, tx_skb_tcp_hdr);\r\nreturn -EINVAL;\r\n}\r\n} else if (proto == IPPROTO_UDP) {\r\nflags |= BNA_TXQ_WI_CF_UDP_CKSUM;\r\ntxqent->hdr.wi.l4_hdr_size_n_offset =\r\nhtons(BNA_TXQ_WI_L4_HDR_N_OFFSET\r\n(0, skb_transport_offset(skb)));\r\nBNAD_UPDATE_CTR(bnad, udpcsum_offload);\r\nif (unlikely(skb_headlen(skb) <\r\nskb_transport_offset(skb) +\r\nsizeof(struct udphdr))) {\r\nBNAD_UPDATE_CTR(bnad, tx_skb_udp_hdr);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nBNAD_UPDATE_CTR(bnad, tx_skb_csum_err);\r\nreturn -EINVAL;\r\n}\r\n} else\r\ntxqent->hdr.wi.l4_hdr_size_n_offset = 0;\r\n}\r\ntxqent->hdr.wi.flags = htons(flags);\r\ntxqent->hdr.wi.frame_length = htonl(skb->len);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t\r\nbnad_start_xmit(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct bnad *bnad = netdev_priv(netdev);\r\nu32 txq_id = 0;\r\nstruct bna_tcb *tcb = NULL;\r\nstruct bnad_tx_unmap *unmap_q, *unmap, *head_unmap;\r\nu32 prod, q_depth, vect_id;\r\nu32 wis, vectors, len;\r\nint i;\r\ndma_addr_t dma_addr;\r\nstruct bna_txq_entry *txqent;\r\nlen = skb_headlen(skb);\r\nif (unlikely(skb->len <= ETH_HLEN)) {\r\ndev_kfree_skb_any(skb);\r\nBNAD_UPDATE_CTR(bnad, tx_skb_too_short);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (unlikely(len > BFI_TX_MAX_DATA_PER_VECTOR)) {\r\ndev_kfree_skb_any(skb);\r\nBNAD_UPDATE_CTR(bnad, tx_skb_headlen_zero);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (unlikely(len == 0)) {\r\ndev_kfree_skb_any(skb);\r\nBNAD_UPDATE_CTR(bnad, tx_skb_headlen_zero);\r\nreturn NETDEV_TX_OK;\r\n}\r\ntcb = bnad->tx_info[0].tcb[txq_id];\r\nif (unlikely(!tcb || !test_bit(BNAD_TXQ_TX_STARTED, &tcb->flags))) {\r\ndev_kfree_skb_any(skb);\r\nBNAD_UPDATE_CTR(bnad, tx_skb_stopping);\r\nreturn NETDEV_TX_OK;\r\n}\r\nq_depth = tcb->q_depth;\r\nprod = tcb->producer_index;\r\nunmap_q = tcb->unmap_q;\r\nvectors = 1 + skb_shinfo(skb)->nr_frags;\r\nwis = BNA_TXQ_WI_NEEDED(vectors);\r\nif (unlikely(vectors > BFI_TX_MAX_VECTORS_PER_PKT)) {\r\ndev_kfree_skb_any(skb);\r\nBNAD_UPDATE_CTR(bnad, tx_skb_max_vectors);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (unlikely(wis > BNA_QE_FREE_CNT(tcb, q_depth))) {\r\nif ((*tcb->hw_consumer_index != tcb->consumer_index) &&\r\n!test_and_set_bit(BNAD_TXQ_FREE_SENT, &tcb->flags)) {\r\nu32 sent;\r\nsent = bnad_txcmpl_process(bnad, tcb);\r\nif (likely(test_bit(BNAD_TXQ_TX_STARTED, &tcb->flags)))\r\nbna_ib_ack(tcb->i_dbell, sent);\r\nsmp_mb__before_atomic();\r\nclear_bit(BNAD_TXQ_FREE_SENT, &tcb->flags);\r\n} else {\r\nnetif_stop_queue(netdev);\r\nBNAD_UPDATE_CTR(bnad, netif_queue_stop);\r\n}\r\nsmp_mb();\r\nif (likely(wis > BNA_QE_FREE_CNT(tcb, q_depth))) {\r\nBNAD_UPDATE_CTR(bnad, netif_queue_stop);\r\nreturn NETDEV_TX_BUSY;\r\n} else {\r\nnetif_wake_queue(netdev);\r\nBNAD_UPDATE_CTR(bnad, netif_queue_wakeup);\r\n}\r\n}\r\ntxqent = &((struct bna_txq_entry *)tcb->sw_q)[prod];\r\nhead_unmap = &unmap_q[prod];\r\nif (bnad_txq_wi_prepare(bnad, tcb, skb, txqent)) {\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\ntxqent->hdr.wi.reserved = 0;\r\ntxqent->hdr.wi.num_vectors = vectors;\r\nhead_unmap->skb = skb;\r\nhead_unmap->nvecs = 0;\r\nunmap = head_unmap;\r\ndma_addr = dma_map_single(&bnad->pcidev->dev, skb->data,\r\nlen, DMA_TO_DEVICE);\r\nif (dma_mapping_error(&bnad->pcidev->dev, dma_addr)) {\r\ndev_kfree_skb_any(skb);\r\nBNAD_UPDATE_CTR(bnad, tx_skb_map_failed);\r\nreturn NETDEV_TX_OK;\r\n}\r\nBNA_SET_DMA_ADDR(dma_addr, &txqent->vector[0].host_addr);\r\ntxqent->vector[0].length = htons(len);\r\ndma_unmap_addr_set(&unmap->vectors[0], dma_addr, dma_addr);\r\nhead_unmap->nvecs++;\r\nfor (i = 0, vect_id = 0; i < vectors - 1; i++) {\r\nconst struct skb_frag_struct *frag = &skb_shinfo(skb)->frags[i];\r\nu32 size = skb_frag_size(frag);\r\nif (unlikely(size == 0)) {\r\nbnad_tx_buff_unmap(bnad, unmap_q, q_depth,\r\ntcb->producer_index);\r\ndev_kfree_skb_any(skb);\r\nBNAD_UPDATE_CTR(bnad, tx_skb_frag_zero);\r\nreturn NETDEV_TX_OK;\r\n}\r\nlen += size;\r\nvect_id++;\r\nif (vect_id == BFI_TX_MAX_VECTORS_PER_WI) {\r\nvect_id = 0;\r\nBNA_QE_INDX_INC(prod, q_depth);\r\ntxqent = &((struct bna_txq_entry *)tcb->sw_q)[prod];\r\ntxqent->hdr.wi_ext.opcode = htons(BNA_TXQ_WI_EXTENSION);\r\nunmap = &unmap_q[prod];\r\n}\r\ndma_addr = skb_frag_dma_map(&bnad->pcidev->dev, frag,\r\n0, size, DMA_TO_DEVICE);\r\nif (dma_mapping_error(&bnad->pcidev->dev, dma_addr)) {\r\nbnad_tx_buff_unmap(bnad, unmap_q, q_depth,\r\ntcb->producer_index);\r\ndev_kfree_skb_any(skb);\r\nBNAD_UPDATE_CTR(bnad, tx_skb_map_failed);\r\nreturn NETDEV_TX_OK;\r\n}\r\ndma_unmap_len_set(&unmap->vectors[vect_id], dma_len, size);\r\nBNA_SET_DMA_ADDR(dma_addr, &txqent->vector[vect_id].host_addr);\r\ntxqent->vector[vect_id].length = htons(size);\r\ndma_unmap_addr_set(&unmap->vectors[vect_id], dma_addr,\r\ndma_addr);\r\nhead_unmap->nvecs++;\r\n}\r\nif (unlikely(len != skb->len)) {\r\nbnad_tx_buff_unmap(bnad, unmap_q, q_depth, tcb->producer_index);\r\ndev_kfree_skb_any(skb);\r\nBNAD_UPDATE_CTR(bnad, tx_skb_len_mismatch);\r\nreturn NETDEV_TX_OK;\r\n}\r\nBNA_QE_INDX_INC(prod, q_depth);\r\ntcb->producer_index = prod;\r\nwmb();\r\nif (unlikely(!test_bit(BNAD_TXQ_TX_STARTED, &tcb->flags)))\r\nreturn NETDEV_TX_OK;\r\nskb_tx_timestamp(skb);\r\nbna_txq_prod_indx_doorbell(tcb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void\r\nbnad_get_stats64(struct net_device *netdev, struct rtnl_link_stats64 *stats)\r\n{\r\nstruct bnad *bnad = netdev_priv(netdev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbnad_netdev_qstats_fill(bnad, stats);\r\nbnad_netdev_hwstats_fill(bnad, stats);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\n}\r\nstatic void\r\nbnad_set_rx_ucast_fltr(struct bnad *bnad)\r\n{\r\nstruct net_device *netdev = bnad->netdev;\r\nint uc_count = netdev_uc_count(netdev);\r\nenum bna_cb_status ret;\r\nu8 *mac_list;\r\nstruct netdev_hw_addr *ha;\r\nint entry;\r\nif (netdev_uc_empty(bnad->netdev)) {\r\nbna_rx_ucast_listset(bnad->rx_info[0].rx, 0, NULL);\r\nreturn;\r\n}\r\nif (uc_count > bna_attr(&bnad->bna)->num_ucmac)\r\ngoto mode_default;\r\nmac_list = kzalloc(uc_count * ETH_ALEN, GFP_ATOMIC);\r\nif (mac_list == NULL)\r\ngoto mode_default;\r\nentry = 0;\r\nnetdev_for_each_uc_addr(ha, netdev) {\r\nether_addr_copy(&mac_list[entry * ETH_ALEN], &ha->addr[0]);\r\nentry++;\r\n}\r\nret = bna_rx_ucast_listset(bnad->rx_info[0].rx, entry, mac_list);\r\nkfree(mac_list);\r\nif (ret != BNA_CB_SUCCESS)\r\ngoto mode_default;\r\nreturn;\r\nmode_default:\r\nbnad->cfg_flags |= BNAD_CF_DEFAULT;\r\nbna_rx_ucast_listset(bnad->rx_info[0].rx, 0, NULL);\r\n}\r\nstatic void\r\nbnad_set_rx_mcast_fltr(struct bnad *bnad)\r\n{\r\nstruct net_device *netdev = bnad->netdev;\r\nint mc_count = netdev_mc_count(netdev);\r\nenum bna_cb_status ret;\r\nu8 *mac_list;\r\nif (netdev->flags & IFF_ALLMULTI)\r\ngoto mode_allmulti;\r\nif (netdev_mc_empty(netdev))\r\nreturn;\r\nif (mc_count > bna_attr(&bnad->bna)->num_mcmac)\r\ngoto mode_allmulti;\r\nmac_list = kzalloc((mc_count + 1) * ETH_ALEN, GFP_ATOMIC);\r\nif (mac_list == NULL)\r\ngoto mode_allmulti;\r\nether_addr_copy(&mac_list[0], &bnad_bcast_addr[0]);\r\nbnad_netdev_mc_list_get(netdev, mac_list);\r\nret = bna_rx_mcast_listset(bnad->rx_info[0].rx, mc_count + 1, mac_list);\r\nkfree(mac_list);\r\nif (ret != BNA_CB_SUCCESS)\r\ngoto mode_allmulti;\r\nreturn;\r\nmode_allmulti:\r\nbnad->cfg_flags |= BNAD_CF_ALLMULTI;\r\nbna_rx_mcast_delall(bnad->rx_info[0].rx);\r\n}\r\nvoid\r\nbnad_set_rx_mode(struct net_device *netdev)\r\n{\r\nstruct bnad *bnad = netdev_priv(netdev);\r\nenum bna_rxmode new_mode, mode_mask;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nif (bnad->rx_info[0].rx == NULL) {\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nreturn;\r\n}\r\nbnad->cfg_flags &= ~(BNAD_CF_PROMISC | BNAD_CF_DEFAULT |\r\nBNAD_CF_ALLMULTI);\r\nnew_mode = 0;\r\nif (netdev->flags & IFF_PROMISC) {\r\nnew_mode |= BNAD_RXMODE_PROMISC_DEFAULT;\r\nbnad->cfg_flags |= BNAD_CF_PROMISC;\r\n} else {\r\nbnad_set_rx_mcast_fltr(bnad);\r\nif (bnad->cfg_flags & BNAD_CF_ALLMULTI)\r\nnew_mode |= BNA_RXMODE_ALLMULTI;\r\nbnad_set_rx_ucast_fltr(bnad);\r\nif (bnad->cfg_flags & BNAD_CF_DEFAULT)\r\nnew_mode |= BNA_RXMODE_DEFAULT;\r\n}\r\nmode_mask = BNA_RXMODE_PROMISC | BNA_RXMODE_DEFAULT |\r\nBNA_RXMODE_ALLMULTI;\r\nbna_rx_mode_set(bnad->rx_info[0].rx, new_mode, mode_mask);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\n}\r\nstatic int\r\nbnad_set_mac_address(struct net_device *netdev, void *addr)\r\n{\r\nint err;\r\nstruct bnad *bnad = netdev_priv(netdev);\r\nstruct sockaddr *sa = (struct sockaddr *)addr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nerr = bnad_mac_addr_set_locked(bnad, sa->sa_data);\r\nif (!err)\r\nether_addr_copy(netdev->dev_addr, sa->sa_data);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nreturn err;\r\n}\r\nstatic int\r\nbnad_mtu_set(struct bnad *bnad, int frame_size)\r\n{\r\nunsigned long flags;\r\ninit_completion(&bnad->bnad_completions.mtu_comp);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_enet_mtu_set(&bnad->bna.enet, frame_size, bnad_cb_enet_mtu_set);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nwait_for_completion(&bnad->bnad_completions.mtu_comp);\r\nreturn bnad->bnad_completions.mtu_comp_status;\r\n}\r\nstatic int\r\nbnad_change_mtu(struct net_device *netdev, int new_mtu)\r\n{\r\nint err, mtu;\r\nstruct bnad *bnad = netdev_priv(netdev);\r\nu32 rx_count = 0, frame, new_frame;\r\nmutex_lock(&bnad->conf_mutex);\r\nmtu = netdev->mtu;\r\nnetdev->mtu = new_mtu;\r\nframe = BNAD_FRAME_SIZE(mtu);\r\nnew_frame = BNAD_FRAME_SIZE(new_mtu);\r\nif (BNAD_PCI_DEV_IS_CAT2(bnad) &&\r\nnetif_running(bnad->netdev)) {\r\nif ((frame <= 4096 && new_frame > 4096) ||\r\n(frame > 4096 && new_frame <= 4096))\r\nrx_count = bnad_reinit_rx(bnad);\r\n}\r\nerr = bnad_mtu_set(bnad, new_frame);\r\nif (err)\r\nerr = -EBUSY;\r\nmutex_unlock(&bnad->conf_mutex);\r\nreturn err;\r\n}\r\nstatic int\r\nbnad_vlan_rx_add_vid(struct net_device *netdev, __be16 proto, u16 vid)\r\n{\r\nstruct bnad *bnad = netdev_priv(netdev);\r\nunsigned long flags;\r\nif (!bnad->rx_info[0].rx)\r\nreturn 0;\r\nmutex_lock(&bnad->conf_mutex);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_rx_vlan_add(bnad->rx_info[0].rx, vid);\r\nset_bit(vid, bnad->active_vlans);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nmutex_unlock(&bnad->conf_mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\nbnad_vlan_rx_kill_vid(struct net_device *netdev, __be16 proto, u16 vid)\r\n{\r\nstruct bnad *bnad = netdev_priv(netdev);\r\nunsigned long flags;\r\nif (!bnad->rx_info[0].rx)\r\nreturn 0;\r\nmutex_lock(&bnad->conf_mutex);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nclear_bit(vid, bnad->active_vlans);\r\nbna_rx_vlan_del(bnad->rx_info[0].rx, vid);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nmutex_unlock(&bnad->conf_mutex);\r\nreturn 0;\r\n}\r\nstatic int bnad_set_features(struct net_device *dev, netdev_features_t features)\r\n{\r\nstruct bnad *bnad = netdev_priv(dev);\r\nnetdev_features_t changed = features ^ dev->features;\r\nif ((changed & NETIF_F_HW_VLAN_CTAG_RX) && netif_running(dev)) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nif (features & NETIF_F_HW_VLAN_CTAG_RX)\r\nbna_rx_vlan_strip_enable(bnad->rx_info[0].rx);\r\nelse\r\nbna_rx_vlan_strip_disable(bnad->rx_info[0].rx);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nbnad_netpoll(struct net_device *netdev)\r\n{\r\nstruct bnad *bnad = netdev_priv(netdev);\r\nstruct bnad_rx_info *rx_info;\r\nstruct bnad_rx_ctrl *rx_ctrl;\r\nu32 curr_mask;\r\nint i, j;\r\nif (!(bnad->cfg_flags & BNAD_CF_MSIX)) {\r\nbna_intx_disable(&bnad->bna, curr_mask);\r\nbnad_isr(bnad->pcidev->irq, netdev);\r\nbna_intx_enable(&bnad->bna, curr_mask);\r\n} else {\r\nfor (i = 0; i < bnad->num_rx; i++) {\r\nrx_info = &bnad->rx_info[i];\r\nif (!rx_info->rx)\r\ncontinue;\r\nfor (j = 0; j < bnad->num_rxp_per_rx; j++) {\r\nrx_ctrl = &rx_info->rx_ctrl[j];\r\nif (rx_ctrl->ccb)\r\nbnad_netif_rx_schedule_poll(bnad,\r\nrx_ctrl->ccb);\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nbnad_netdev_init(struct bnad *bnad, bool using_dac)\r\n{\r\nstruct net_device *netdev = bnad->netdev;\r\nnetdev->hw_features = NETIF_F_SG | NETIF_F_RXCSUM |\r\nNETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\r\nNETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_HW_VLAN_CTAG_TX |\r\nNETIF_F_HW_VLAN_CTAG_RX;\r\nnetdev->vlan_features = NETIF_F_SG | NETIF_F_HIGHDMA |\r\nNETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\r\nNETIF_F_TSO | NETIF_F_TSO6;\r\nnetdev->features |= netdev->hw_features | NETIF_F_HW_VLAN_CTAG_FILTER;\r\nif (using_dac)\r\nnetdev->features |= NETIF_F_HIGHDMA;\r\nnetdev->mem_start = bnad->mmio_start;\r\nnetdev->mem_end = bnad->mmio_start + bnad->mmio_len - 1;\r\nnetdev->min_mtu = ETH_ZLEN - ETH_HLEN;\r\nnetdev->max_mtu = BNAD_JUMBO_MTU;\r\nnetdev->netdev_ops = &bnad_netdev_ops;\r\nbnad_set_ethtool_ops(netdev);\r\n}\r\nstatic int\r\nbnad_init(struct bnad *bnad,\r\nstruct pci_dev *pdev, struct net_device *netdev)\r\n{\r\nunsigned long flags;\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\npci_set_drvdata(pdev, netdev);\r\nbnad->netdev = netdev;\r\nbnad->pcidev = pdev;\r\nbnad->mmio_start = pci_resource_start(pdev, 0);\r\nbnad->mmio_len = pci_resource_len(pdev, 0);\r\nbnad->bar0 = ioremap_nocache(bnad->mmio_start, bnad->mmio_len);\r\nif (!bnad->bar0) {\r\ndev_err(&pdev->dev, "ioremap for bar0 failed\n");\r\nreturn -ENOMEM;\r\n}\r\ndev_info(&pdev->dev, "bar0 mapped to %p, len %llu\n", bnad->bar0,\r\n(unsigned long long) bnad->mmio_len);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nif (!bnad_msix_disable)\r\nbnad->cfg_flags = BNAD_CF_MSIX;\r\nbnad->cfg_flags |= BNAD_CF_DIM_ENABLED;\r\nbnad_q_num_init(bnad);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nbnad->msix_num = (bnad->num_tx * bnad->num_txq_per_tx) +\r\n(bnad->num_rx * bnad->num_rxp_per_rx) +\r\nBNAD_MAILBOX_MSIX_VECTORS;\r\nbnad->txq_depth = BNAD_TXQ_DEPTH;\r\nbnad->rxq_depth = BNAD_RXQ_DEPTH;\r\nbnad->tx_coalescing_timeo = BFI_TX_COALESCING_TIMEO;\r\nbnad->rx_coalescing_timeo = BFI_RX_COALESCING_TIMEO;\r\nsprintf(bnad->wq_name, "%s_wq_%d", BNAD_NAME, bnad->id);\r\nbnad->work_q = create_singlethread_workqueue(bnad->wq_name);\r\nif (!bnad->work_q) {\r\niounmap(bnad->bar0);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nbnad_uninit(struct bnad *bnad)\r\n{\r\nif (bnad->work_q) {\r\nflush_workqueue(bnad->work_q);\r\ndestroy_workqueue(bnad->work_q);\r\nbnad->work_q = NULL;\r\n}\r\nif (bnad->bar0)\r\niounmap(bnad->bar0);\r\n}\r\nstatic void\r\nbnad_lock_init(struct bnad *bnad)\r\n{\r\nspin_lock_init(&bnad->bna_lock);\r\nmutex_init(&bnad->conf_mutex);\r\n}\r\nstatic void\r\nbnad_lock_uninit(struct bnad *bnad)\r\n{\r\nmutex_destroy(&bnad->conf_mutex);\r\n}\r\nstatic int\r\nbnad_pci_init(struct bnad *bnad,\r\nstruct pci_dev *pdev, bool *using_dac)\r\n{\r\nint err;\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\nreturn err;\r\nerr = pci_request_regions(pdev, BNAD_NAME);\r\nif (err)\r\ngoto disable_device;\r\nif (!dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64))) {\r\n*using_dac = true;\r\n} else {\r\nerr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\r\nif (err)\r\ngoto release_regions;\r\n*using_dac = false;\r\n}\r\npci_set_master(pdev);\r\nreturn 0;\r\nrelease_regions:\r\npci_release_regions(pdev);\r\ndisable_device:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void\r\nbnad_pci_uninit(struct pci_dev *pdev)\r\n{\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int\r\nbnad_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *pcidev_id)\r\n{\r\nbool using_dac;\r\nint err;\r\nstruct bnad *bnad;\r\nstruct bna *bna;\r\nstruct net_device *netdev;\r\nstruct bfa_pcidev pcidev_info;\r\nunsigned long flags;\r\nmutex_lock(&bnad_fwimg_mutex);\r\nif (!cna_get_firmware_buf(pdev)) {\r\nmutex_unlock(&bnad_fwimg_mutex);\r\ndev_err(&pdev->dev, "failed to load firmware image!\n");\r\nreturn -ENODEV;\r\n}\r\nmutex_unlock(&bnad_fwimg_mutex);\r\nnetdev = alloc_etherdev(sizeof(struct bnad));\r\nif (!netdev) {\r\nerr = -ENOMEM;\r\nreturn err;\r\n}\r\nbnad = netdev_priv(netdev);\r\nbnad_lock_init(bnad);\r\nbnad->id = atomic_inc_return(&bna_id) - 1;\r\nmutex_lock(&bnad->conf_mutex);\r\nusing_dac = false;\r\nerr = bnad_pci_init(bnad, pdev, &using_dac);\r\nif (err)\r\ngoto unlock_mutex;\r\nerr = bnad_init(bnad, pdev, netdev);\r\nif (err)\r\ngoto pci_uninit;\r\nbnad_netdev_init(bnad, using_dac);\r\nnetif_carrier_off(netdev);\r\nif (bna_debugfs_enable)\r\nbnad_debugfs_init(bnad);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_res_req(&bnad->res_info[0]);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nerr = bnad_res_alloc(bnad, &bnad->res_info[0], BNA_RES_T_MAX);\r\nif (err)\r\ngoto drv_uninit;\r\nbna = &bnad->bna;\r\npcidev_info.pci_slot = PCI_SLOT(bnad->pcidev->devfn);\r\npcidev_info.pci_func = PCI_FUNC(bnad->pcidev->devfn);\r\npcidev_info.device_id = bnad->pcidev->device;\r\npcidev_info.pci_bar_kva = bnad->bar0;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_init(bna, bnad, &pcidev_info, &bnad->res_info[0]);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nbnad->stats.bna_stats = &bna->stats;\r\nbnad_enable_msix(bnad);\r\nerr = bnad_mbox_irq_alloc(bnad);\r\nif (err)\r\ngoto res_free;\r\nsetup_timer(&bnad->bna.ioceth.ioc.ioc_timer, bnad_ioc_timeout,\r\n(unsigned long)bnad);\r\nsetup_timer(&bnad->bna.ioceth.ioc.hb_timer, bnad_ioc_hb_check,\r\n(unsigned long)bnad);\r\nsetup_timer(&bnad->bna.ioceth.ioc.iocpf_timer, bnad_iocpf_timeout,\r\n(unsigned long)bnad);\r\nsetup_timer(&bnad->bna.ioceth.ioc.sem_timer, bnad_iocpf_sem_timeout,\r\n(unsigned long)bnad);\r\nerr = bnad_ioceth_enable(bnad);\r\nif (err) {\r\ndev_err(&pdev->dev, "initialization failed err=%d\n", err);\r\ngoto probe_success;\r\n}\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nif (bna_num_txq_set(bna, BNAD_NUM_TXQ + 1) ||\r\nbna_num_rxp_set(bna, BNAD_NUM_RXP + 1)) {\r\nbnad_q_num_adjust(bnad, bna_attr(bna)->num_txq - 1,\r\nbna_attr(bna)->num_rxp - 1);\r\nif (bna_num_txq_set(bna, BNAD_NUM_TXQ + 1) ||\r\nbna_num_rxp_set(bna, BNAD_NUM_RXP + 1))\r\nerr = -EIO;\r\n}\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nif (err)\r\ngoto disable_ioceth;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_mod_res_req(&bnad->bna, &bnad->mod_res_info[0]);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nerr = bnad_res_alloc(bnad, &bnad->mod_res_info[0], BNA_MOD_RES_T_MAX);\r\nif (err) {\r\nerr = -EIO;\r\ngoto disable_ioceth;\r\n}\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_mod_init(&bnad->bna, &bnad->mod_res_info[0]);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_enet_perm_mac_get(&bna->enet, bnad->perm_addr);\r\nbnad_set_netdev_perm_addr(bnad);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nmutex_unlock(&bnad->conf_mutex);\r\nerr = register_netdev(netdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "registering net device failed\n");\r\ngoto probe_uninit;\r\n}\r\nset_bit(BNAD_RF_NETDEV_REGISTERED, &bnad->run_flags);\r\nreturn 0;\r\nprobe_success:\r\nmutex_unlock(&bnad->conf_mutex);\r\nreturn 0;\r\nprobe_uninit:\r\nmutex_lock(&bnad->conf_mutex);\r\nbnad_res_free(bnad, &bnad->mod_res_info[0], BNA_MOD_RES_T_MAX);\r\ndisable_ioceth:\r\nbnad_ioceth_disable(bnad);\r\ndel_timer_sync(&bnad->bna.ioceth.ioc.ioc_timer);\r\ndel_timer_sync(&bnad->bna.ioceth.ioc.sem_timer);\r\ndel_timer_sync(&bnad->bna.ioceth.ioc.hb_timer);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_uninit(bna);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nbnad_mbox_irq_free(bnad);\r\nbnad_disable_msix(bnad);\r\nres_free:\r\nbnad_res_free(bnad, &bnad->res_info[0], BNA_RES_T_MAX);\r\ndrv_uninit:\r\nkfree(bnad->regdata);\r\nbnad_debugfs_uninit(bnad);\r\nbnad_uninit(bnad);\r\npci_uninit:\r\nbnad_pci_uninit(pdev);\r\nunlock_mutex:\r\nmutex_unlock(&bnad->conf_mutex);\r\nbnad_lock_uninit(bnad);\r\nfree_netdev(netdev);\r\nreturn err;\r\n}\r\nstatic void\r\nbnad_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct bnad *bnad;\r\nstruct bna *bna;\r\nunsigned long flags;\r\nif (!netdev)\r\nreturn;\r\nbnad = netdev_priv(netdev);\r\nbna = &bnad->bna;\r\nif (test_and_clear_bit(BNAD_RF_NETDEV_REGISTERED, &bnad->run_flags))\r\nunregister_netdev(netdev);\r\nmutex_lock(&bnad->conf_mutex);\r\nbnad_ioceth_disable(bnad);\r\ndel_timer_sync(&bnad->bna.ioceth.ioc.ioc_timer);\r\ndel_timer_sync(&bnad->bna.ioceth.ioc.sem_timer);\r\ndel_timer_sync(&bnad->bna.ioceth.ioc.hb_timer);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbna_uninit(bna);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nbnad_res_free(bnad, &bnad->mod_res_info[0], BNA_MOD_RES_T_MAX);\r\nbnad_res_free(bnad, &bnad->res_info[0], BNA_RES_T_MAX);\r\nbnad_mbox_irq_free(bnad);\r\nbnad_disable_msix(bnad);\r\nbnad_pci_uninit(pdev);\r\nmutex_unlock(&bnad->conf_mutex);\r\nbnad_lock_uninit(bnad);\r\nkfree(bnad->regdata);\r\nbnad_debugfs_uninit(bnad);\r\nbnad_uninit(bnad);\r\nfree_netdev(netdev);\r\n}\r\nstatic int __init\r\nbnad_module_init(void)\r\n{\r\nint err;\r\npr_info("bna: QLogic BR-series 10G Ethernet driver - version: %s\n",\r\nBNAD_VERSION);\r\nbfa_nw_ioc_auto_recover(bnad_ioc_auto_recover);\r\nerr = pci_register_driver(&bnad_pci_driver);\r\nif (err < 0) {\r\npr_err("bna: PCI driver registration failed err=%d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nbnad_module_exit(void)\r\n{\r\npci_unregister_driver(&bnad_pci_driver);\r\nrelease_firmware(bfi_fw);\r\n}
