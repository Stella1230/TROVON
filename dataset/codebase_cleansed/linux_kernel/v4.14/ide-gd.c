static struct ide_disk_obj *ide_disk_get(struct gendisk *disk)\r\n{\r\nstruct ide_disk_obj *idkp = NULL;\r\nmutex_lock(&ide_disk_ref_mutex);\r\nidkp = ide_drv_g(disk, ide_disk_obj);\r\nif (idkp) {\r\nif (ide_device_get(idkp->drive))\r\nidkp = NULL;\r\nelse\r\nget_device(&idkp->dev);\r\n}\r\nmutex_unlock(&ide_disk_ref_mutex);\r\nreturn idkp;\r\n}\r\nstatic void ide_disk_put(struct ide_disk_obj *idkp)\r\n{\r\nide_drive_t *drive = idkp->drive;\r\nmutex_lock(&ide_disk_ref_mutex);\r\nput_device(&idkp->dev);\r\nide_device_put(drive);\r\nmutex_unlock(&ide_disk_ref_mutex);\r\n}\r\nsector_t ide_gd_capacity(ide_drive_t *drive)\r\n{\r\nreturn drive->capacity64;\r\n}\r\nstatic void ide_gd_remove(ide_drive_t *drive)\r\n{\r\nstruct ide_disk_obj *idkp = drive->driver_data;\r\nstruct gendisk *g = idkp->disk;\r\nide_proc_unregister_driver(drive, idkp->driver);\r\ndevice_del(&idkp->dev);\r\ndel_gendisk(g);\r\ndrive->disk_ops->flush(drive);\r\nmutex_lock(&ide_disk_ref_mutex);\r\nput_device(&idkp->dev);\r\nmutex_unlock(&ide_disk_ref_mutex);\r\n}\r\nstatic void ide_disk_release(struct device *dev)\r\n{\r\nstruct ide_disk_obj *idkp = to_ide_drv(dev, ide_disk_obj);\r\nide_drive_t *drive = idkp->drive;\r\nstruct gendisk *g = idkp->disk;\r\ndrive->disk_ops = NULL;\r\ndrive->driver_data = NULL;\r\ng->private_data = NULL;\r\nput_disk(g);\r\nkfree(idkp);\r\n}\r\nstatic void ide_gd_resume(ide_drive_t *drive)\r\n{\r\nif (ata_id_hpa_enabled(drive->id))\r\n(void)drive->disk_ops->get_capacity(drive);\r\n}\r\nstatic ide_proc_entry_t *ide_disk_proc_entries(ide_drive_t *drive)\r\n{\r\nreturn (drive->media == ide_disk) ? ide_disk_proc : ide_floppy_proc;\r\n}\r\nstatic const struct ide_proc_devset *ide_disk_proc_devsets(ide_drive_t *drive)\r\n{\r\nreturn (drive->media == ide_disk) ? ide_disk_settings\r\n: ide_floppy_settings;\r\n}\r\nstatic ide_startstop_t ide_gd_do_request(ide_drive_t *drive,\r\nstruct request *rq, sector_t sector)\r\n{\r\nreturn drive->disk_ops->do_request(drive, rq, sector);\r\n}\r\nstatic int ide_gd_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct gendisk *disk = bdev->bd_disk;\r\nstruct ide_disk_obj *idkp;\r\nide_drive_t *drive;\r\nint ret = 0;\r\nidkp = ide_disk_get(disk);\r\nif (idkp == NULL)\r\nreturn -ENXIO;\r\ndrive = idkp->drive;\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nidkp->openers++;\r\nif ((drive->dev_flags & IDE_DFLAG_REMOVABLE) && idkp->openers == 1) {\r\ndrive->dev_flags &= ~IDE_DFLAG_FORMAT_IN_PROGRESS;\r\nret = drive->disk_ops->init_media(drive, disk);\r\nif (ret && (mode & FMODE_NDELAY) == 0) {\r\nret = -EIO;\r\ngoto out_put_idkp;\r\n}\r\nif ((drive->dev_flags & IDE_DFLAG_WP) && (mode & FMODE_WRITE)) {\r\nret = -EROFS;\r\ngoto out_put_idkp;\r\n}\r\ndrive->disk_ops->set_doorlock(drive, disk, 1);\r\ndrive->dev_flags |= IDE_DFLAG_MEDIA_CHANGED;\r\ncheck_disk_change(bdev);\r\n} else if (drive->dev_flags & IDE_DFLAG_FORMAT_IN_PROGRESS) {\r\nret = -EBUSY;\r\ngoto out_put_idkp;\r\n}\r\nreturn 0;\r\nout_put_idkp:\r\nidkp->openers--;\r\nide_disk_put(idkp);\r\nreturn ret;\r\n}\r\nstatic int ide_gd_unlocked_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nint ret;\r\nmutex_lock(&ide_gd_mutex);\r\nret = ide_gd_open(bdev, mode);\r\nmutex_unlock(&ide_gd_mutex);\r\nreturn ret;\r\n}\r\nstatic void ide_gd_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct ide_disk_obj *idkp = ide_drv_g(disk, ide_disk_obj);\r\nide_drive_t *drive = idkp->drive;\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nmutex_lock(&ide_gd_mutex);\r\nif (idkp->openers == 1)\r\ndrive->disk_ops->flush(drive);\r\nif ((drive->dev_flags & IDE_DFLAG_REMOVABLE) && idkp->openers == 1) {\r\ndrive->disk_ops->set_doorlock(drive, disk, 0);\r\ndrive->dev_flags &= ~IDE_DFLAG_FORMAT_IN_PROGRESS;\r\n}\r\nidkp->openers--;\r\nide_disk_put(idkp);\r\nmutex_unlock(&ide_gd_mutex);\r\n}\r\nstatic int ide_gd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nstruct ide_disk_obj *idkp = ide_drv_g(bdev->bd_disk, ide_disk_obj);\r\nide_drive_t *drive = idkp->drive;\r\ngeo->heads = drive->bios_head;\r\ngeo->sectors = drive->bios_sect;\r\ngeo->cylinders = (u16)drive->bios_cyl;\r\nreturn 0;\r\n}\r\nstatic unsigned int ide_gd_check_events(struct gendisk *disk,\r\nunsigned int clearing)\r\n{\r\nstruct ide_disk_obj *idkp = ide_drv_g(disk, ide_disk_obj);\r\nide_drive_t *drive = idkp->drive;\r\nbool ret;\r\nif (drive->dev_flags & IDE_DFLAG_ATTACH) {\r\ndrive->dev_flags &= ~IDE_DFLAG_ATTACH;\r\nreturn 0;\r\n}\r\nret = drive->dev_flags & IDE_DFLAG_MEDIA_CHANGED;\r\ndrive->dev_flags &= ~IDE_DFLAG_MEDIA_CHANGED;\r\nreturn ret ? DISK_EVENT_MEDIA_CHANGE : 0;\r\n}\r\nstatic void ide_gd_unlock_native_capacity(struct gendisk *disk)\r\n{\r\nstruct ide_disk_obj *idkp = ide_drv_g(disk, ide_disk_obj);\r\nide_drive_t *drive = idkp->drive;\r\nconst struct ide_disk_ops *disk_ops = drive->disk_ops;\r\nif (disk_ops->unlock_native_capacity)\r\ndisk_ops->unlock_native_capacity(drive);\r\n}\r\nstatic int ide_gd_revalidate_disk(struct gendisk *disk)\r\n{\r\nstruct ide_disk_obj *idkp = ide_drv_g(disk, ide_disk_obj);\r\nide_drive_t *drive = idkp->drive;\r\nif (ide_gd_check_events(disk, 0))\r\ndrive->disk_ops->get_capacity(drive);\r\nset_capacity(disk, ide_gd_capacity(drive));\r\nreturn 0;\r\n}\r\nstatic int ide_gd_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct ide_disk_obj *idkp = ide_drv_g(bdev->bd_disk, ide_disk_obj);\r\nide_drive_t *drive = idkp->drive;\r\nreturn drive->disk_ops->ioctl(drive, bdev, mode, cmd, arg);\r\n}\r\nstatic int ide_gd_probe(ide_drive_t *drive)\r\n{\r\nconst struct ide_disk_ops *disk_ops = NULL;\r\nstruct ide_disk_obj *idkp;\r\nstruct gendisk *g;\r\nif (!strstr("ide-gd", drive->driver_req))\r\ngoto failed;\r\n#ifdef CONFIG_IDE_GD_ATA\r\nif (drive->media == ide_disk)\r\ndisk_ops = &ide_ata_disk_ops;\r\n#endif\r\n#ifdef CONFIG_IDE_GD_ATAPI\r\nif (drive->media == ide_floppy)\r\ndisk_ops = &ide_atapi_disk_ops;\r\n#endif\r\nif (disk_ops == NULL)\r\ngoto failed;\r\nif (disk_ops->check(drive, DRV_NAME) == 0) {\r\nprintk(KERN_ERR PFX "%s: not supported by this driver\n",\r\ndrive->name);\r\ngoto failed;\r\n}\r\nidkp = kzalloc(sizeof(*idkp), GFP_KERNEL);\r\nif (!idkp) {\r\nprintk(KERN_ERR PFX "%s: can't allocate a disk structure\n",\r\ndrive->name);\r\ngoto failed;\r\n}\r\ng = alloc_disk_node(IDE_DISK_MINORS, hwif_to_node(drive->hwif));\r\nif (!g)\r\ngoto out_free_idkp;\r\nide_init_disk(g, drive);\r\nidkp->dev.parent = &drive->gendev;\r\nidkp->dev.release = ide_disk_release;\r\ndev_set_name(&idkp->dev, "%s", dev_name(&drive->gendev));\r\nif (device_register(&idkp->dev))\r\ngoto out_free_disk;\r\nidkp->drive = drive;\r\nidkp->driver = &ide_gd_driver;\r\nidkp->disk = g;\r\ng->private_data = &idkp->driver;\r\ndrive->driver_data = idkp;\r\ndrive->debug_mask = debug_mask;\r\ndrive->disk_ops = disk_ops;\r\ndisk_ops->setup(drive);\r\nset_capacity(g, ide_gd_capacity(drive));\r\ng->minors = IDE_DISK_MINORS;\r\ng->flags |= GENHD_FL_EXT_DEVT;\r\nif (drive->dev_flags & IDE_DFLAG_REMOVABLE)\r\ng->flags = GENHD_FL_REMOVABLE;\r\ng->fops = &ide_gd_ops;\r\ndevice_add_disk(&drive->gendev, g);\r\nreturn 0;\r\nout_free_disk:\r\nput_disk(g);\r\nout_free_idkp:\r\nkfree(idkp);\r\nfailed:\r\nreturn -ENODEV;\r\n}\r\nstatic int __init ide_gd_init(void)\r\n{\r\nprintk(KERN_INFO DRV_NAME " driver " IDE_GD_VERSION "\n");\r\nreturn driver_register(&ide_gd_driver.gen_driver);\r\n}\r\nstatic void __exit ide_gd_exit(void)\r\n{\r\ndriver_unregister(&ide_gd_driver.gen_driver);\r\n}
