static unsigned __maybe_unused pcs_readb(void __iomem *reg)\r\n{\r\nreturn readb(reg);\r\n}\r\nstatic unsigned __maybe_unused pcs_readw(void __iomem *reg)\r\n{\r\nreturn readw(reg);\r\n}\r\nstatic unsigned __maybe_unused pcs_readl(void __iomem *reg)\r\n{\r\nreturn readl(reg);\r\n}\r\nstatic void __maybe_unused pcs_writeb(unsigned val, void __iomem *reg)\r\n{\r\nwriteb(val, reg);\r\n}\r\nstatic void __maybe_unused pcs_writew(unsigned val, void __iomem *reg)\r\n{\r\nwritew(val, reg);\r\n}\r\nstatic void __maybe_unused pcs_writel(unsigned val, void __iomem *reg)\r\n{\r\nwritel(val, reg);\r\n}\r\nstatic void pcs_pin_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s,\r\nunsigned pin)\r\n{\r\nstruct pcs_device *pcs;\r\nunsigned val, mux_bytes;\r\nunsigned long offset;\r\nsize_t pa;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nmux_bytes = pcs->width / BITS_PER_BYTE;\r\noffset = pin * mux_bytes;\r\nval = pcs->read(pcs->base + offset);\r\npa = pcs->res->start + offset;\r\nseq_printf(s, "%zx %08x %s ", pa, val, DRIVER_NAME);\r\n}\r\nstatic void pcs_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\nstruct pcs_device *pcs;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\ndevm_kfree(pcs->dev, map);\r\n}\r\nstatic int pcs_get_function(struct pinctrl_dev *pctldev, unsigned pin,\r\nstruct pcs_function **func)\r\n{\r\nstruct pcs_device *pcs = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pin_desc *pdesc = pin_desc_get(pctldev, pin);\r\nconst struct pinctrl_setting_mux *setting;\r\nstruct function_desc *function;\r\nunsigned fselector;\r\nsetting = pdesc->mux_setting;\r\nif (!setting)\r\nreturn -ENOTSUPP;\r\nfselector = setting->func;\r\nfunction = pinmux_generic_get_function(pctldev, fselector);\r\n*func = function->data;\r\nif (!(*func)) {\r\ndev_err(pcs->dev, "%s could not find function%i\n",\r\n__func__, fselector);\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcs_set_mux(struct pinctrl_dev *pctldev, unsigned fselector,\r\nunsigned group)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct function_desc *function;\r\nstruct pcs_function *func;\r\nint i;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nif (!pcs->fmask)\r\nreturn 0;\r\nfunction = pinmux_generic_get_function(pctldev, fselector);\r\nfunc = function->data;\r\nif (!func)\r\nreturn -EINVAL;\r\ndev_dbg(pcs->dev, "enabling %s function%i\n",\r\nfunc->name, fselector);\r\nfor (i = 0; i < func->nvals; i++) {\r\nstruct pcs_func_vals *vals;\r\nunsigned long flags;\r\nunsigned val, mask;\r\nvals = &func->vals[i];\r\nraw_spin_lock_irqsave(&pcs->lock, flags);\r\nval = pcs->read(vals->reg);\r\nif (pcs->bits_per_mux)\r\nmask = vals->mask;\r\nelse\r\nmask = pcs->fmask;\r\nval &= ~mask;\r\nval |= (vals->val & mask);\r\npcs->write(val, vals->reg);\r\nraw_spin_unlock_irqrestore(&pcs->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcs_request_gpio(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned pin)\r\n{\r\nstruct pcs_device *pcs = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pcs_gpiofunc_range *frange = NULL;\r\nstruct list_head *pos, *tmp;\r\nint mux_bytes = 0;\r\nunsigned data;\r\nif (!pcs->fmask)\r\nreturn -ENOTSUPP;\r\nlist_for_each_safe(pos, tmp, &pcs->gpiofuncs) {\r\nfrange = list_entry(pos, struct pcs_gpiofunc_range, node);\r\nif (pin >= frange->offset + frange->npins\r\n|| pin < frange->offset)\r\ncontinue;\r\nmux_bytes = pcs->width / BITS_PER_BYTE;\r\ndata = pcs->read(pcs->base + pin * mux_bytes) & ~pcs->fmask;\r\ndata |= frange->gpiofunc;\r\npcs->write(data, pcs->base + pin * mux_bytes);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcs_pinconf_clear_bias(struct pinctrl_dev *pctldev, unsigned pin)\r\n{\r\nunsigned long config;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pcs_bias); i++) {\r\nconfig = pinconf_to_config_packed(pcs_bias[i], 0);\r\npcs_pinconf_set(pctldev, pin, &config, 1);\r\n}\r\n}\r\nstatic bool pcs_pinconf_bias_disable(struct pinctrl_dev *pctldev, unsigned pin)\r\n{\r\nunsigned long config;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pcs_bias); i++) {\r\nconfig = pinconf_to_config_packed(pcs_bias[i], 0);\r\nif (!pcs_pinconf_get(pctldev, pin, &config))\r\ngoto out;\r\n}\r\nreturn true;\r\nout:\r\nreturn false;\r\n}\r\nstatic int pcs_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *config)\r\n{\r\nstruct pcs_device *pcs = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pcs_function *func;\r\nenum pin_config_param param;\r\nunsigned offset = 0, data = 0, i, j, ret;\r\nret = pcs_get_function(pctldev, pin, &func);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < func->nconfs; i++) {\r\nparam = pinconf_to_config_param(*config);\r\nif (param == PIN_CONFIG_BIAS_DISABLE) {\r\nif (pcs_pinconf_bias_disable(pctldev, pin)) {\r\n*config = 0;\r\nreturn 0;\r\n} else {\r\nreturn -ENOTSUPP;\r\n}\r\n} else if (param != func->conf[i].param) {\r\ncontinue;\r\n}\r\noffset = pin * (pcs->width / BITS_PER_BYTE);\r\ndata = pcs->read(pcs->base + offset) & func->conf[i].mask;\r\nswitch (func->conf[i].param) {\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\nif ((data != func->conf[i].enable) ||\r\n(data == func->conf[i].disable))\r\nreturn -ENOTSUPP;\r\n*config = 0;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_SCHMITT:\r\nfor (j = 0; j < func->nconfs; j++) {\r\nswitch (func->conf[j].param) {\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\nif (data != func->conf[j].enable)\r\nreturn -ENOTSUPP;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n*config = data;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\ncase PIN_CONFIG_SLEW_RATE:\r\ncase PIN_CONFIG_LOW_POWER_MODE:\r\ndefault:\r\n*config = data;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int pcs_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct pcs_device *pcs = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pcs_function *func;\r\nunsigned offset = 0, shift = 0, i, data, ret;\r\nu32 arg;\r\nint j;\r\nret = pcs_get_function(pctldev, pin, &func);\r\nif (ret)\r\nreturn ret;\r\nfor (j = 0; j < num_configs; j++) {\r\nfor (i = 0; i < func->nconfs; i++) {\r\nif (pinconf_to_config_param(configs[j])\r\n!= func->conf[i].param)\r\ncontinue;\r\noffset = pin * (pcs->width / BITS_PER_BYTE);\r\ndata = pcs->read(pcs->base + offset);\r\narg = pinconf_to_config_argument(configs[j]);\r\nswitch (func->conf[i].param) {\r\ncase PIN_CONFIG_INPUT_SCHMITT:\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\ncase PIN_CONFIG_SLEW_RATE:\r\ncase PIN_CONFIG_LOW_POWER_MODE:\r\nshift = ffs(func->conf[i].mask) - 1;\r\ndata &= ~func->conf[i].mask;\r\ndata |= (arg << shift) & func->conf[i].mask;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\npcs_pinconf_clear_bias(pctldev, pin);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nif (arg)\r\npcs_pinconf_clear_bias(pctldev, pin);\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\ndata &= ~func->conf[i].mask;\r\nif (arg)\r\ndata |= func->conf[i].enable;\r\nelse\r\ndata |= func->conf[i].disable;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\npcs->write(data, pcs->base + offset);\r\nbreak;\r\n}\r\nif (i >= func->nconfs)\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcs_pinconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long *config)\r\n{\r\nconst unsigned *pins;\r\nunsigned npins, old = 0;\r\nint i, ret;\r\nret = pinctrl_generic_get_group_pins(pctldev, group, &pins, &npins);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < npins; i++) {\r\nif (pcs_pinconf_get(pctldev, pins[i], config))\r\nreturn -ENOTSUPP;\r\nif (i && (old != *config))\r\nreturn -ENOTSUPP;\r\nold = *config;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcs_pinconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nconst unsigned *pins;\r\nunsigned npins;\r\nint i, ret;\r\nret = pinctrl_generic_get_group_pins(pctldev, group, &pins, &npins);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < npins; i++) {\r\nif (pcs_pinconf_set(pctldev, pins[i], configs, num_configs))\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcs_pinconf_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned pin)\r\n{\r\n}\r\nstatic void pcs_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned selector)\r\n{\r\n}\r\nstatic void pcs_pinconf_config_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s,\r\nunsigned long config)\r\n{\r\npinconf_generic_dump_config(pctldev, s, config);\r\n}\r\nstatic int pcs_add_pin(struct pcs_device *pcs, unsigned offset,\r\nunsigned pin_pos)\r\n{\r\nstruct pcs_soc_data *pcs_soc = &pcs->socdata;\r\nstruct pinctrl_pin_desc *pin;\r\nint i;\r\ni = pcs->pins.cur;\r\nif (i >= pcs->desc.npins) {\r\ndev_err(pcs->dev, "too many pins, max %i\n",\r\npcs->desc.npins);\r\nreturn -ENOMEM;\r\n}\r\nif (pcs_soc->irq_enable_mask) {\r\nunsigned val;\r\nval = pcs->read(pcs->base + offset);\r\nif (val & pcs_soc->irq_enable_mask) {\r\ndev_dbg(pcs->dev, "irq enabled at boot for pin at %lx (%x), clearing\n",\r\n(unsigned long)pcs->res->start + offset, val);\r\nval &= ~pcs_soc->irq_enable_mask;\r\npcs->write(val, pcs->base + offset);\r\n}\r\n}\r\npin = &pcs->pins.pa[i];\r\npin->number = i;\r\npcs->pins.cur++;\r\nreturn i;\r\n}\r\nstatic int pcs_allocate_pin_table(struct pcs_device *pcs)\r\n{\r\nint mux_bytes, nr_pins, i;\r\nint num_pins_in_register = 0;\r\nmux_bytes = pcs->width / BITS_PER_BYTE;\r\nif (pcs->bits_per_mux) {\r\npcs->bits_per_pin = fls(pcs->fmask);\r\nnr_pins = (pcs->size * BITS_PER_BYTE) / pcs->bits_per_pin;\r\nnum_pins_in_register = pcs->width / pcs->bits_per_pin;\r\n} else {\r\nnr_pins = pcs->size / mux_bytes;\r\n}\r\ndev_dbg(pcs->dev, "allocating %i pins\n", nr_pins);\r\npcs->pins.pa = devm_kzalloc(pcs->dev,\r\nsizeof(*pcs->pins.pa) * nr_pins,\r\nGFP_KERNEL);\r\nif (!pcs->pins.pa)\r\nreturn -ENOMEM;\r\npcs->desc.pins = pcs->pins.pa;\r\npcs->desc.npins = nr_pins;\r\nfor (i = 0; i < pcs->desc.npins; i++) {\r\nunsigned offset;\r\nint res;\r\nint byte_num;\r\nint pin_pos = 0;\r\nif (pcs->bits_per_mux) {\r\nbyte_num = (pcs->bits_per_pin * i) / BITS_PER_BYTE;\r\noffset = (byte_num / mux_bytes) * mux_bytes;\r\npin_pos = i % num_pins_in_register;\r\n} else {\r\noffset = i * mux_bytes;\r\n}\r\nres = pcs_add_pin(pcs, offset, pin_pos);\r\nif (res < 0) {\r\ndev_err(pcs->dev, "error adding pins: %i\n", res);\r\nreturn res;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct pcs_function *pcs_add_function(struct pcs_device *pcs,\r\nstruct device_node *np,\r\nconst char *name,\r\nstruct pcs_func_vals *vals,\r\nunsigned nvals,\r\nconst char **pgnames,\r\nunsigned npgnames)\r\n{\r\nstruct pcs_function *function;\r\nint res;\r\nfunction = devm_kzalloc(pcs->dev, sizeof(*function), GFP_KERNEL);\r\nif (!function)\r\nreturn NULL;\r\nfunction->vals = vals;\r\nfunction->nvals = nvals;\r\nres = pinmux_generic_add_function(pcs->pctl, name,\r\npgnames, npgnames,\r\nfunction);\r\nif (res)\r\nreturn NULL;\r\nreturn function;\r\n}\r\nstatic int pcs_get_pin_by_offset(struct pcs_device *pcs, unsigned offset)\r\n{\r\nunsigned index;\r\nif (offset >= pcs->size) {\r\ndev_err(pcs->dev, "mux offset out of range: 0x%x (0x%x)\n",\r\noffset, pcs->size);\r\nreturn -EINVAL;\r\n}\r\nif (pcs->bits_per_mux)\r\nindex = (offset * BITS_PER_BYTE) / pcs->bits_per_pin;\r\nelse\r\nindex = offset / (pcs->width / BITS_PER_BYTE);\r\nreturn index;\r\n}\r\nstatic int pcs_config_match(unsigned data, unsigned enable, unsigned disable)\r\n{\r\nint ret = -EINVAL;\r\nif (data == enable)\r\nret = 1;\r\nelse if (data == disable)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic void add_config(struct pcs_conf_vals **conf, enum pin_config_param param,\r\nunsigned value, unsigned enable, unsigned disable,\r\nunsigned mask)\r\n{\r\n(*conf)->param = param;\r\n(*conf)->val = value;\r\n(*conf)->enable = enable;\r\n(*conf)->disable = disable;\r\n(*conf)->mask = mask;\r\n(*conf)++;\r\n}\r\nstatic void add_setting(unsigned long **setting, enum pin_config_param param,\r\nunsigned arg)\r\n{\r\n**setting = pinconf_to_config_packed(param, arg);\r\n(*setting)++;\r\n}\r\nstatic void pcs_add_conf2(struct pcs_device *pcs, struct device_node *np,\r\nconst char *name, enum pin_config_param param,\r\nstruct pcs_conf_vals **conf, unsigned long **settings)\r\n{\r\nunsigned value[2], shift;\r\nint ret;\r\nret = of_property_read_u32_array(np, name, value, 2);\r\nif (ret)\r\nreturn;\r\nvalue[0] &= value[1];\r\nshift = ffs(value[1]) - 1;\r\nadd_config(conf, param, value[0], 0, 0, value[1]);\r\nadd_setting(settings, param, value[0] >> shift);\r\n}\r\nstatic void pcs_add_conf4(struct pcs_device *pcs, struct device_node *np,\r\nconst char *name, enum pin_config_param param,\r\nstruct pcs_conf_vals **conf, unsigned long **settings)\r\n{\r\nunsigned value[4];\r\nint ret;\r\nret = of_property_read_u32_array(np, name, value, 4);\r\nif (ret)\r\nreturn;\r\nif (!value[3]) {\r\ndev_err(pcs->dev, "mask field of the property can't be 0\n");\r\nreturn;\r\n}\r\nvalue[0] &= value[3];\r\nvalue[1] &= value[3];\r\nvalue[2] &= value[3];\r\nret = pcs_config_match(value[0], value[1], value[2]);\r\nif (ret < 0)\r\ndev_dbg(pcs->dev, "failed to match enable or disable bits\n");\r\nadd_config(conf, param, value[0], value[1], value[2], value[3]);\r\nadd_setting(settings, param, ret);\r\n}\r\nstatic int pcs_parse_pinconf(struct pcs_device *pcs, struct device_node *np,\r\nstruct pcs_function *func,\r\nstruct pinctrl_map **map)\r\n{\r\nstruct pinctrl_map *m = *map;\r\nint i = 0, nconfs = 0;\r\nunsigned long *settings = NULL, *s = NULL;\r\nstruct pcs_conf_vals *conf = NULL;\r\nstruct pcs_conf_type prop2[] = {\r\n{ "pinctrl-single,drive-strength", PIN_CONFIG_DRIVE_STRENGTH, },\r\n{ "pinctrl-single,slew-rate", PIN_CONFIG_SLEW_RATE, },\r\n{ "pinctrl-single,input-schmitt", PIN_CONFIG_INPUT_SCHMITT, },\r\n{ "pinctrl-single,low-power-mode", PIN_CONFIG_LOW_POWER_MODE, },\r\n};\r\nstruct pcs_conf_type prop4[] = {\r\n{ "pinctrl-single,bias-pullup", PIN_CONFIG_BIAS_PULL_UP, },\r\n{ "pinctrl-single,bias-pulldown", PIN_CONFIG_BIAS_PULL_DOWN, },\r\n{ "pinctrl-single,input-schmitt-enable",\r\nPIN_CONFIG_INPUT_SCHMITT_ENABLE, },\r\n};\r\nif (!PCS_HAS_PINCONF)\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(prop2); i++) {\r\nif (of_find_property(np, prop2[i].name, NULL))\r\nnconfs++;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(prop4); i++) {\r\nif (of_find_property(np, prop4[i].name, NULL))\r\nnconfs++;\r\n}\r\nif (!nconfs)\r\nreturn 0;\r\nfunc->conf = devm_kzalloc(pcs->dev,\r\nsizeof(struct pcs_conf_vals) * nconfs,\r\nGFP_KERNEL);\r\nif (!func->conf)\r\nreturn -ENOMEM;\r\nfunc->nconfs = nconfs;\r\nconf = &(func->conf[0]);\r\nm++;\r\nsettings = devm_kzalloc(pcs->dev, sizeof(unsigned long) * nconfs,\r\nGFP_KERNEL);\r\nif (!settings)\r\nreturn -ENOMEM;\r\ns = &settings[0];\r\nfor (i = 0; i < ARRAY_SIZE(prop2); i++)\r\npcs_add_conf2(pcs, np, prop2[i].name, prop2[i].param,\r\n&conf, &s);\r\nfor (i = 0; i < ARRAY_SIZE(prop4); i++)\r\npcs_add_conf4(pcs, np, prop4[i].name, prop4[i].param,\r\n&conf, &s);\r\nm->type = PIN_MAP_TYPE_CONFIGS_GROUP;\r\nm->data.configs.group_or_pin = np->name;\r\nm->data.configs.configs = settings;\r\nm->data.configs.num_configs = nconfs;\r\nreturn 0;\r\n}\r\nstatic int pcs_parse_one_pinctrl_entry(struct pcs_device *pcs,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned *num_maps,\r\nconst char **pgnames)\r\n{\r\nconst char *name = "pinctrl-single,pins";\r\nstruct pcs_func_vals *vals;\r\nint rows, *pins, found = 0, res = -ENOMEM, i;\r\nstruct pcs_function *function;\r\nrows = pinctrl_count_index_with_args(np, name);\r\nif (rows <= 0) {\r\ndev_err(pcs->dev, "Invalid number of rows: %d\n", rows);\r\nreturn -EINVAL;\r\n}\r\nvals = devm_kzalloc(pcs->dev, sizeof(*vals) * rows, GFP_KERNEL);\r\nif (!vals)\r\nreturn -ENOMEM;\r\npins = devm_kzalloc(pcs->dev, sizeof(*pins) * rows, GFP_KERNEL);\r\nif (!pins)\r\ngoto free_vals;\r\nfor (i = 0; i < rows; i++) {\r\nstruct of_phandle_args pinctrl_spec;\r\nunsigned int offset;\r\nint pin;\r\nres = pinctrl_parse_index_with_args(np, name, i, &pinctrl_spec);\r\nif (res)\r\nreturn res;\r\nif (pinctrl_spec.args_count < 2) {\r\ndev_err(pcs->dev, "invalid args_count for spec: %i\n",\r\npinctrl_spec.args_count);\r\nbreak;\r\n}\r\noffset = pinctrl_spec.args[0];\r\nvals[found].reg = pcs->base + offset;\r\nvals[found].val = pinctrl_spec.args[1];\r\ndev_dbg(pcs->dev, "%s index: 0x%x value: 0x%x\n",\r\npinctrl_spec.np->name, offset, pinctrl_spec.args[1]);\r\npin = pcs_get_pin_by_offset(pcs, offset);\r\nif (pin < 0) {\r\ndev_err(pcs->dev,\r\n"could not add functions for %s %ux\n",\r\nnp->name, offset);\r\nbreak;\r\n}\r\npins[found++] = pin;\r\n}\r\npgnames[0] = np->name;\r\nfunction = pcs_add_function(pcs, np, np->name, vals, found, pgnames, 1);\r\nif (!function) {\r\nres = -ENOMEM;\r\ngoto free_pins;\r\n}\r\nres = pinctrl_generic_add_group(pcs->pctl, np->name, pins, found, pcs);\r\nif (res < 0)\r\ngoto free_function;\r\n(*map)->type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)->data.mux.group = np->name;\r\n(*map)->data.mux.function = np->name;\r\nif (PCS_HAS_PINCONF) {\r\nres = pcs_parse_pinconf(pcs, np, function, map);\r\nif (res)\r\ngoto free_pingroups;\r\n*num_maps = 2;\r\n} else {\r\n*num_maps = 1;\r\n}\r\nreturn 0;\r\nfree_pingroups:\r\npinctrl_generic_remove_last_group(pcs->pctl);\r\n*num_maps = 1;\r\nfree_function:\r\npinmux_generic_remove_last_function(pcs->pctl);\r\nfree_pins:\r\ndevm_kfree(pcs->dev, pins);\r\nfree_vals:\r\ndevm_kfree(pcs->dev, vals);\r\nreturn res;\r\n}\r\nstatic int pcs_parse_bits_in_pinctrl_entry(struct pcs_device *pcs,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned *num_maps,\r\nconst char **pgnames)\r\n{\r\nconst char *name = "pinctrl-single,bits";\r\nstruct pcs_func_vals *vals;\r\nint rows, *pins, found = 0, res = -ENOMEM, i;\r\nint npins_in_row;\r\nstruct pcs_function *function;\r\nrows = pinctrl_count_index_with_args(np, name);\r\nif (rows <= 0) {\r\ndev_err(pcs->dev, "Invalid number of rows: %d\n", rows);\r\nreturn -EINVAL;\r\n}\r\nnpins_in_row = pcs->width / pcs->bits_per_pin;\r\nvals = devm_kzalloc(pcs->dev, sizeof(*vals) * rows * npins_in_row,\r\nGFP_KERNEL);\r\nif (!vals)\r\nreturn -ENOMEM;\r\npins = devm_kzalloc(pcs->dev, sizeof(*pins) * rows * npins_in_row,\r\nGFP_KERNEL);\r\nif (!pins)\r\ngoto free_vals;\r\nfor (i = 0; i < rows; i++) {\r\nstruct of_phandle_args pinctrl_spec;\r\nunsigned offset, val;\r\nunsigned mask, bit_pos, val_pos, mask_pos, submask;\r\nunsigned pin_num_from_lsb;\r\nint pin;\r\nres = pinctrl_parse_index_with_args(np, name, i, &pinctrl_spec);\r\nif (res)\r\nreturn res;\r\nif (pinctrl_spec.args_count < 3) {\r\ndev_err(pcs->dev, "invalid args_count for spec: %i\n",\r\npinctrl_spec.args_count);\r\nbreak;\r\n}\r\noffset = pinctrl_spec.args[0];\r\nval = pinctrl_spec.args[1];\r\nmask = pinctrl_spec.args[2];\r\ndev_dbg(pcs->dev, "%s index: 0x%x value: 0x%x mask: 0x%x\n",\r\npinctrl_spec.np->name, offset, val, mask);\r\nwhile (mask) {\r\nbit_pos = __ffs(mask);\r\npin_num_from_lsb = bit_pos / pcs->bits_per_pin;\r\nmask_pos = ((pcs->fmask) << bit_pos);\r\nval_pos = val & mask_pos;\r\nsubmask = mask & mask_pos;\r\nif ((mask & mask_pos) == 0) {\r\ndev_err(pcs->dev,\r\n"Invalid mask for %s at 0x%x\n",\r\nnp->name, offset);\r\nbreak;\r\n}\r\nmask &= ~mask_pos;\r\nif (submask != mask_pos) {\r\ndev_warn(pcs->dev,\r\n"Invalid submask 0x%x for %s at 0x%x\n",\r\nsubmask, np->name, offset);\r\ncontinue;\r\n}\r\nvals[found].mask = submask;\r\nvals[found].reg = pcs->base + offset;\r\nvals[found].val = val_pos;\r\npin = pcs_get_pin_by_offset(pcs, offset);\r\nif (pin < 0) {\r\ndev_err(pcs->dev,\r\n"could not add functions for %s %ux\n",\r\nnp->name, offset);\r\nbreak;\r\n}\r\npins[found++] = pin + pin_num_from_lsb;\r\n}\r\n}\r\npgnames[0] = np->name;\r\nfunction = pcs_add_function(pcs, np, np->name, vals, found, pgnames, 1);\r\nif (!function) {\r\nres = -ENOMEM;\r\ngoto free_pins;\r\n}\r\nres = pinctrl_generic_add_group(pcs->pctl, np->name, pins, found, pcs);\r\nif (res < 0)\r\ngoto free_function;\r\n(*map)->type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)->data.mux.group = np->name;\r\n(*map)->data.mux.function = np->name;\r\nif (PCS_HAS_PINCONF) {\r\ndev_err(pcs->dev, "pinconf not supported\n");\r\ngoto free_pingroups;\r\n}\r\n*num_maps = 1;\r\nreturn 0;\r\nfree_pingroups:\r\npinctrl_generic_remove_last_group(pcs->pctl);\r\n*num_maps = 1;\r\nfree_function:\r\npinmux_generic_remove_last_function(pcs->pctl);\r\nfree_pins:\r\ndevm_kfree(pcs->dev, pins);\r\nfree_vals:\r\ndevm_kfree(pcs->dev, vals);\r\nreturn res;\r\n}\r\nstatic int pcs_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nstruct pcs_device *pcs;\r\nconst char **pgnames;\r\nint ret;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\n*map = devm_kzalloc(pcs->dev, sizeof(**map) * 2, GFP_KERNEL);\r\nif (!*map)\r\nreturn -ENOMEM;\r\n*num_maps = 0;\r\npgnames = devm_kzalloc(pcs->dev, sizeof(*pgnames), GFP_KERNEL);\r\nif (!pgnames) {\r\nret = -ENOMEM;\r\ngoto free_map;\r\n}\r\nif (pcs->bits_per_mux) {\r\nret = pcs_parse_bits_in_pinctrl_entry(pcs, np_config, map,\r\nnum_maps, pgnames);\r\nif (ret < 0) {\r\ndev_err(pcs->dev, "no pins entries for %s\n",\r\nnp_config->name);\r\ngoto free_pgnames;\r\n}\r\n} else {\r\nret = pcs_parse_one_pinctrl_entry(pcs, np_config, map,\r\nnum_maps, pgnames);\r\nif (ret < 0) {\r\ndev_err(pcs->dev, "no pins entries for %s\n",\r\nnp_config->name);\r\ngoto free_pgnames;\r\n}\r\n}\r\nreturn 0;\r\nfree_pgnames:\r\ndevm_kfree(pcs->dev, pgnames);\r\nfree_map:\r\ndevm_kfree(pcs->dev, *map);\r\nreturn ret;\r\n}\r\nstatic void pcs_irq_free(struct pcs_device *pcs)\r\n{\r\nstruct pcs_soc_data *pcs_soc = &pcs->socdata;\r\nif (pcs_soc->irq < 0)\r\nreturn;\r\nif (pcs->domain)\r\nirq_domain_remove(pcs->domain);\r\nif (PCS_QUIRK_HAS_SHARED_IRQ)\r\nfree_irq(pcs_soc->irq, pcs_soc);\r\nelse\r\nirq_set_chained_handler(pcs_soc->irq, NULL);\r\n}\r\nstatic void pcs_free_resources(struct pcs_device *pcs)\r\n{\r\npcs_irq_free(pcs);\r\npinctrl_unregister(pcs->pctl);\r\n#if IS_BUILTIN(CONFIG_PINCTRL_SINGLE)\r\nif (pcs->missing_nr_pinctrl_cells)\r\nof_remove_property(pcs->np, pcs->missing_nr_pinctrl_cells);\r\n#endif\r\n}\r\nstatic int pcs_add_gpio_func(struct device_node *node, struct pcs_device *pcs)\r\n{\r\nconst char *propname = "pinctrl-single,gpio-range";\r\nconst char *cellname = "#pinctrl-single,gpio-range-cells";\r\nstruct of_phandle_args gpiospec;\r\nstruct pcs_gpiofunc_range *range;\r\nint ret, i;\r\nfor (i = 0; ; i++) {\r\nret = of_parse_phandle_with_args(node, propname, cellname,\r\ni, &gpiospec);\r\nif (ret) {\r\nret = 0;\r\nbreak;\r\n}\r\nrange = devm_kzalloc(pcs->dev, sizeof(*range), GFP_KERNEL);\r\nif (!range) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nrange->offset = gpiospec.args[0];\r\nrange->npins = gpiospec.args[1];\r\nrange->gpiofunc = gpiospec.args[2];\r\nmutex_lock(&pcs->mutex);\r\nlist_add_tail(&range->node, &pcs->gpiofuncs);\r\nmutex_unlock(&pcs->mutex);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void pcs_irq_set(struct pcs_soc_data *pcs_soc,\r\nint irq, const bool enable)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct list_head *pos;\r\nunsigned mask;\r\npcs = container_of(pcs_soc, struct pcs_device, socdata);\r\nlist_for_each(pos, &pcs->irqs) {\r\nstruct pcs_interrupt *pcswi;\r\nunsigned soc_mask;\r\npcswi = list_entry(pos, struct pcs_interrupt, node);\r\nif (irq != pcswi->irq)\r\ncontinue;\r\nsoc_mask = pcs_soc->irq_enable_mask;\r\nraw_spin_lock(&pcs->lock);\r\nmask = pcs->read(pcswi->reg);\r\nif (enable)\r\nmask |= soc_mask;\r\nelse\r\nmask &= ~soc_mask;\r\npcs->write(mask, pcswi->reg);\r\nmask = pcs->read(pcswi->reg);\r\nraw_spin_unlock(&pcs->lock);\r\n}\r\nif (pcs_soc->rearm)\r\npcs_soc->rearm();\r\n}\r\nstatic void pcs_irq_mask(struct irq_data *d)\r\n{\r\nstruct pcs_soc_data *pcs_soc = irq_data_get_irq_chip_data(d);\r\npcs_irq_set(pcs_soc, d->irq, false);\r\n}\r\nstatic void pcs_irq_unmask(struct irq_data *d)\r\n{\r\nstruct pcs_soc_data *pcs_soc = irq_data_get_irq_chip_data(d);\r\npcs_irq_set(pcs_soc, d->irq, true);\r\n}\r\nstatic int pcs_irq_set_wake(struct irq_data *d, unsigned int state)\r\n{\r\nif (state)\r\npcs_irq_unmask(d);\r\nelse\r\npcs_irq_mask(d);\r\nreturn 0;\r\n}\r\nstatic int pcs_irq_handle(struct pcs_soc_data *pcs_soc)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct list_head *pos;\r\nint count = 0;\r\npcs = container_of(pcs_soc, struct pcs_device, socdata);\r\nlist_for_each(pos, &pcs->irqs) {\r\nstruct pcs_interrupt *pcswi;\r\nunsigned mask;\r\npcswi = list_entry(pos, struct pcs_interrupt, node);\r\nraw_spin_lock(&pcs->lock);\r\nmask = pcs->read(pcswi->reg);\r\nraw_spin_unlock(&pcs->lock);\r\nif (mask & pcs_soc->irq_status_mask) {\r\ngeneric_handle_irq(irq_find_mapping(pcs->domain,\r\npcswi->hwirq));\r\ncount++;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic irqreturn_t pcs_irq_handler(int irq, void *d)\r\n{\r\nstruct pcs_soc_data *pcs_soc = d;\r\nreturn pcs_irq_handle(pcs_soc) ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void pcs_irq_chain_handler(struct irq_desc *desc)\r\n{\r\nstruct pcs_soc_data *pcs_soc = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip;\r\nchip = irq_desc_get_chip(desc);\r\nchained_irq_enter(chip, desc);\r\npcs_irq_handle(pcs_soc);\r\nchained_irq_exit(chip, desc);\r\nreturn;\r\n}\r\nstatic int pcs_irqdomain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct pcs_soc_data *pcs_soc = d->host_data;\r\nstruct pcs_device *pcs;\r\nstruct pcs_interrupt *pcswi;\r\npcs = container_of(pcs_soc, struct pcs_device, socdata);\r\npcswi = devm_kzalloc(pcs->dev, sizeof(*pcswi), GFP_KERNEL);\r\nif (!pcswi)\r\nreturn -ENOMEM;\r\npcswi->reg = pcs->base + hwirq;\r\npcswi->hwirq = hwirq;\r\npcswi->irq = irq;\r\nmutex_lock(&pcs->mutex);\r\nlist_add_tail(&pcswi->node, &pcs->irqs);\r\nmutex_unlock(&pcs->mutex);\r\nirq_set_chip_data(irq, pcs_soc);\r\nirq_set_chip_and_handler(irq, &pcs->chip,\r\nhandle_level_irq);\r\nirq_set_lockdep_class(irq, &pcs_lock_class);\r\nirq_set_noprobe(irq);\r\nreturn 0;\r\n}\r\nstatic int pcs_irq_init_chained_handler(struct pcs_device *pcs,\r\nstruct device_node *np)\r\n{\r\nstruct pcs_soc_data *pcs_soc = &pcs->socdata;\r\nconst char *name = "pinctrl";\r\nint num_irqs;\r\nif (!pcs_soc->irq_enable_mask ||\r\n!pcs_soc->irq_status_mask) {\r\npcs_soc->irq = -1;\r\nreturn -EINVAL;\r\n}\r\nINIT_LIST_HEAD(&pcs->irqs);\r\npcs->chip.name = name;\r\npcs->chip.irq_ack = pcs_irq_mask;\r\npcs->chip.irq_mask = pcs_irq_mask;\r\npcs->chip.irq_unmask = pcs_irq_unmask;\r\npcs->chip.irq_set_wake = pcs_irq_set_wake;\r\nif (PCS_QUIRK_HAS_SHARED_IRQ) {\r\nint res;\r\nres = request_irq(pcs_soc->irq, pcs_irq_handler,\r\nIRQF_SHARED | IRQF_NO_SUSPEND |\r\nIRQF_NO_THREAD,\r\nname, pcs_soc);\r\nif (res) {\r\npcs_soc->irq = -1;\r\nreturn res;\r\n}\r\n} else {\r\nirq_set_chained_handler_and_data(pcs_soc->irq,\r\npcs_irq_chain_handler,\r\npcs_soc);\r\n}\r\nnum_irqs = pcs->size;\r\npcs->domain = irq_domain_add_simple(np, num_irqs, 0,\r\n&pcs_irqdomain_ops,\r\npcs_soc);\r\nif (!pcs->domain) {\r\nirq_set_chained_handler(pcs_soc->irq, NULL);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pinctrl_single_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct pcs_device *pcs;\r\npcs = platform_get_drvdata(pdev);\r\nif (!pcs)\r\nreturn -EINVAL;\r\nreturn pinctrl_force_sleep(pcs->pctl);\r\n}\r\nstatic int pinctrl_single_resume(struct platform_device *pdev)\r\n{\r\nstruct pcs_device *pcs;\r\npcs = platform_get_drvdata(pdev);\r\nif (!pcs)\r\nreturn -EINVAL;\r\nreturn pinctrl_force_default(pcs->pctl);\r\n}\r\nstatic int pcs_quirk_missing_pinctrl_cells(struct pcs_device *pcs,\r\nstruct device_node *np,\r\nint cells)\r\n{\r\nstruct property *p;\r\nconst char *name = "#pinctrl-cells";\r\nint error;\r\nu32 val;\r\nerror = of_property_read_u32(np, name, &val);\r\nif (!error)\r\nreturn 0;\r\ndev_warn(pcs->dev, "please update dts to use %s = <%i>\n",\r\nname, cells);\r\np = devm_kzalloc(pcs->dev, sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->length = sizeof(__be32);\r\np->value = devm_kzalloc(pcs->dev, sizeof(__be32), GFP_KERNEL);\r\nif (!p->value)\r\nreturn -ENOMEM;\r\n*(__be32 *)p->value = cpu_to_be32(cells);\r\np->name = devm_kstrdup(pcs->dev, name, GFP_KERNEL);\r\nif (!p->name)\r\nreturn -ENOMEM;\r\npcs->missing_nr_pinctrl_cells = p;\r\n#if IS_BUILTIN(CONFIG_PINCTRL_SINGLE)\r\nerror = of_add_property(np, pcs->missing_nr_pinctrl_cells);\r\n#endif\r\nreturn error;\r\n}\r\nstatic int pcs_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct pcs_pdata *pdata;\r\nstruct resource *res;\r\nstruct pcs_device *pcs;\r\nconst struct pcs_soc_data *soc;\r\nint ret;\r\nsoc = of_device_get_match_data(&pdev->dev);\r\nif (WARN_ON(!soc))\r\nreturn -EINVAL;\r\npcs = devm_kzalloc(&pdev->dev, sizeof(*pcs), GFP_KERNEL);\r\nif (!pcs) {\r\ndev_err(&pdev->dev, "could not allocate\n");\r\nreturn -ENOMEM;\r\n}\r\npcs->dev = &pdev->dev;\r\npcs->np = np;\r\nraw_spin_lock_init(&pcs->lock);\r\nmutex_init(&pcs->mutex);\r\nINIT_LIST_HEAD(&pcs->gpiofuncs);\r\npcs->flags = soc->flags;\r\nmemcpy(&pcs->socdata, soc, sizeof(*soc));\r\nret = of_property_read_u32(np, "pinctrl-single,register-width",\r\n&pcs->width);\r\nif (ret) {\r\ndev_err(pcs->dev, "register width not specified\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "pinctrl-single,function-mask",\r\n&pcs->fmask);\r\nif (!ret) {\r\npcs->fshift = __ffs(pcs->fmask);\r\npcs->fmax = pcs->fmask >> pcs->fshift;\r\n} else {\r\npcs->fmask = 0;\r\npcs->fshift = 0;\r\npcs->fmax = 0;\r\n}\r\nret = of_property_read_u32(np, "pinctrl-single,function-off",\r\n&pcs->foff);\r\nif (ret)\r\npcs->foff = PCS_OFF_DISABLED;\r\npcs->bits_per_mux = of_property_read_bool(np,\r\n"pinctrl-single,bit-per-mux");\r\nret = pcs_quirk_missing_pinctrl_cells(pcs, np,\r\npcs->bits_per_mux ? 2 : 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to patch #pinctrl-cells\n");\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(pcs->dev, "could not get resource\n");\r\nreturn -ENODEV;\r\n}\r\npcs->res = devm_request_mem_region(pcs->dev, res->start,\r\nresource_size(res), DRIVER_NAME);\r\nif (!pcs->res) {\r\ndev_err(pcs->dev, "could not get mem_region\n");\r\nreturn -EBUSY;\r\n}\r\npcs->size = resource_size(pcs->res);\r\npcs->base = devm_ioremap(pcs->dev, pcs->res->start, pcs->size);\r\nif (!pcs->base) {\r\ndev_err(pcs->dev, "could not ioremap\n");\r\nreturn -ENODEV;\r\n}\r\nplatform_set_drvdata(pdev, pcs);\r\nswitch (pcs->width) {\r\ncase 8:\r\npcs->read = pcs_readb;\r\npcs->write = pcs_writeb;\r\nbreak;\r\ncase 16:\r\npcs->read = pcs_readw;\r\npcs->write = pcs_writew;\r\nbreak;\r\ncase 32:\r\npcs->read = pcs_readl;\r\npcs->write = pcs_writel;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npcs->desc.name = DRIVER_NAME;\r\npcs->desc.pctlops = &pcs_pinctrl_ops;\r\npcs->desc.pmxops = &pcs_pinmux_ops;\r\nif (PCS_HAS_PINCONF)\r\npcs->desc.confops = &pcs_pinconf_ops;\r\npcs->desc.owner = THIS_MODULE;\r\nret = pcs_allocate_pin_table(pcs);\r\nif (ret < 0)\r\ngoto free;\r\nret = pinctrl_register_and_init(&pcs->desc, pcs->dev, pcs, &pcs->pctl);\r\nif (ret) {\r\ndev_err(pcs->dev, "could not register single pinctrl driver\n");\r\ngoto free;\r\n}\r\nret = pcs_add_gpio_func(np, pcs);\r\nif (ret < 0)\r\ngoto free;\r\npcs->socdata.irq = irq_of_parse_and_map(np, 0);\r\nif (pcs->socdata.irq)\r\npcs->flags |= PCS_FEAT_IRQ;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (pdata) {\r\nif (pdata->rearm)\r\npcs->socdata.rearm = pdata->rearm;\r\nif (pdata->irq) {\r\npcs->socdata.irq = pdata->irq;\r\npcs->flags |= PCS_FEAT_IRQ;\r\n}\r\n}\r\nif (PCS_HAS_IRQ) {\r\nret = pcs_irq_init_chained_handler(pcs, np);\r\nif (ret < 0)\r\ndev_warn(pcs->dev, "initialized with no interrupts\n");\r\n}\r\ndev_info(pcs->dev, "%i pins at pa %p size %u\n",\r\npcs->desc.npins, pcs->base, pcs->size);\r\nreturn pinctrl_enable(pcs->pctl);\r\nfree:\r\npcs_free_resources(pcs);\r\nreturn ret;\r\n}\r\nstatic int pcs_remove(struct platform_device *pdev)\r\n{\r\nstruct pcs_device *pcs = platform_get_drvdata(pdev);\r\nif (!pcs)\r\nreturn 0;\r\npcs_free_resources(pcs);\r\nreturn 0;\r\n}
