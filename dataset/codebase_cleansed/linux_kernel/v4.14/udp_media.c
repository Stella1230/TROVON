static int tipc_udp_is_mcast_addr(struct udp_media_addr *addr)\r\n{\r\nif (ntohs(addr->proto) == ETH_P_IP)\r\nreturn ipv4_is_multicast(addr->ipv4.s_addr);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nelse\r\nreturn ipv6_addr_is_multicast(&addr->ipv6);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void tipc_udp_media_addr_set(struct tipc_media_addr *addr,\r\nstruct udp_media_addr *ua)\r\n{\r\nmemset(addr, 0, sizeof(struct tipc_media_addr));\r\naddr->media_id = TIPC_MEDIA_TYPE_UDP;\r\nmemcpy(addr->value, ua, sizeof(struct udp_media_addr));\r\nif (tipc_udp_is_mcast_addr(ua))\r\naddr->broadcast = TIPC_BROADCAST_SUPPORT;\r\n}\r\nstatic int tipc_udp_addr2str(struct tipc_media_addr *a, char *buf, int size)\r\n{\r\nstruct udp_media_addr *ua = (struct udp_media_addr *)&a->value;\r\nif (ntohs(ua->proto) == ETH_P_IP)\r\nsnprintf(buf, size, "%pI4:%u", &ua->ipv4, ntohs(ua->port));\r\nelse if (ntohs(ua->proto) == ETH_P_IPV6)\r\nsnprintf(buf, size, "%pI6:%u", &ua->ipv6, ntohs(ua->port));\r\nelse\r\npr_err("Invalid UDP media address\n");\r\nreturn 0;\r\n}\r\nstatic int tipc_udp_msg2addr(struct tipc_bearer *b, struct tipc_media_addr *a,\r\nchar *msg)\r\n{\r\nstruct udp_media_addr *ua;\r\nua = (struct udp_media_addr *) (msg + TIPC_MEDIA_ADDR_OFFSET);\r\nif (msg[TIPC_MEDIA_TYPE_OFFSET] != TIPC_MEDIA_TYPE_UDP)\r\nreturn -EINVAL;\r\ntipc_udp_media_addr_set(a, ua);\r\nreturn 0;\r\n}\r\nstatic int tipc_udp_addr2msg(char *msg, struct tipc_media_addr *a)\r\n{\r\nmemset(msg, 0, TIPC_MEDIA_INFO_SIZE);\r\nmsg[TIPC_MEDIA_TYPE_OFFSET] = TIPC_MEDIA_TYPE_UDP;\r\nmemcpy(msg + TIPC_MEDIA_ADDR_OFFSET, a->value,\r\nsizeof(struct udp_media_addr));\r\nreturn 0;\r\n}\r\nstatic int tipc_udp_xmit(struct net *net, struct sk_buff *skb,\r\nstruct udp_bearer *ub, struct udp_media_addr *src,\r\nstruct udp_media_addr *dst)\r\n{\r\nint ttl, err = 0;\r\nstruct rtable *rt;\r\nif (dst->proto == htons(ETH_P_IP)) {\r\nstruct flowi4 fl = {\r\n.daddr = dst->ipv4.s_addr,\r\n.saddr = src->ipv4.s_addr,\r\n.flowi4_mark = skb->mark,\r\n.flowi4_proto = IPPROTO_UDP\r\n};\r\nrt = ip_route_output_key(net, &fl);\r\nif (IS_ERR(rt)) {\r\nerr = PTR_ERR(rt);\r\ngoto tx_error;\r\n}\r\nskb->dev = rt->dst.dev;\r\nttl = ip4_dst_hoplimit(&rt->dst);\r\nudp_tunnel_xmit_skb(rt, ub->ubsock->sk, skb, src->ipv4.s_addr,\r\ndst->ipv4.s_addr, 0, ttl, 0, src->port,\r\ndst->port, false, true);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else {\r\nstruct dst_entry *ndst;\r\nstruct flowi6 fl6 = {\r\n.flowi6_oif = ub->ifindex,\r\n.daddr = dst->ipv6,\r\n.saddr = src->ipv6,\r\n.flowi6_proto = IPPROTO_UDP\r\n};\r\nerr = ipv6_stub->ipv6_dst_lookup(net, ub->ubsock->sk, &ndst,\r\n&fl6);\r\nif (err)\r\ngoto tx_error;\r\nttl = ip6_dst_hoplimit(ndst);\r\nerr = udp_tunnel6_xmit_skb(ndst, ub->ubsock->sk, skb,\r\nndst->dev, &src->ipv6,\r\n&dst->ipv6, 0, ttl, 0, src->port,\r\ndst->port, false);\r\n#endif\r\n}\r\nreturn err;\r\ntx_error:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic int tipc_udp_send_msg(struct net *net, struct sk_buff *skb,\r\nstruct tipc_bearer *b,\r\nstruct tipc_media_addr *addr)\r\n{\r\nstruct udp_media_addr *src = (struct udp_media_addr *)&b->addr.value;\r\nstruct udp_media_addr *dst = (struct udp_media_addr *)&addr->value;\r\nstruct udp_replicast *rcast;\r\nstruct udp_bearer *ub;\r\nint err = 0;\r\nif (skb_headroom(skb) < UDP_MIN_HEADROOM) {\r\nerr = pskb_expand_head(skb, UDP_MIN_HEADROOM, 0, GFP_ATOMIC);\r\nif (err)\r\ngoto out;\r\n}\r\nskb_set_inner_protocol(skb, htons(ETH_P_TIPC));\r\nub = rcu_dereference_rtnl(b->media_ptr);\r\nif (!ub) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nif (addr->broadcast != TIPC_REPLICAST_SUPPORT)\r\nreturn tipc_udp_xmit(net, skb, ub, src, dst);\r\nlist_for_each_entry_rcu(rcast, &ub->rcast.list, list) {\r\nstruct sk_buff *_skb;\r\n_skb = pskb_copy(skb, GFP_ATOMIC);\r\nif (!_skb) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = tipc_udp_xmit(net, _skb, ub, src, &rcast->addr);\r\nif (err) {\r\nkfree_skb(_skb);\r\ngoto out;\r\n}\r\n}\r\nerr = 0;\r\nout:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic bool tipc_udp_is_known_peer(struct tipc_bearer *b,\r\nstruct udp_media_addr *addr)\r\n{\r\nstruct udp_replicast *rcast, *tmp;\r\nstruct udp_bearer *ub;\r\nub = rcu_dereference_rtnl(b->media_ptr);\r\nif (!ub) {\r\npr_err_ratelimited("UDP bearer instance not found\n");\r\nreturn false;\r\n}\r\nlist_for_each_entry_safe(rcast, tmp, &ub->rcast.list, list) {\r\nif (!memcmp(&rcast->addr, addr, sizeof(struct udp_media_addr)))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int tipc_udp_rcast_add(struct tipc_bearer *b,\r\nstruct udp_media_addr *addr)\r\n{\r\nstruct udp_replicast *rcast;\r\nstruct udp_bearer *ub;\r\nub = rcu_dereference_rtnl(b->media_ptr);\r\nif (!ub)\r\nreturn -ENODEV;\r\nrcast = kmalloc(sizeof(*rcast), GFP_ATOMIC);\r\nif (!rcast)\r\nreturn -ENOMEM;\r\nmemcpy(&rcast->addr, addr, sizeof(struct udp_media_addr));\r\nif (ntohs(addr->proto) == ETH_P_IP)\r\npr_info("New replicast peer: %pI4\n", &rcast->addr.ipv4);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nelse if (ntohs(addr->proto) == ETH_P_IPV6)\r\npr_info("New replicast peer: %pI6\n", &rcast->addr.ipv6);\r\n#endif\r\nb->bcast_addr.broadcast = TIPC_REPLICAST_SUPPORT;\r\nlist_add_rcu(&rcast->list, &ub->rcast.list);\r\nreturn 0;\r\n}\r\nstatic int tipc_udp_rcast_disc(struct tipc_bearer *b, struct sk_buff *skb)\r\n{\r\nstruct udp_media_addr src = {0};\r\nstruct udp_media_addr *dst;\r\ndst = (struct udp_media_addr *)&b->bcast_addr.value;\r\nif (tipc_udp_is_mcast_addr(dst))\r\nreturn 0;\r\nsrc.port = udp_hdr(skb)->source;\r\nif (ip_hdr(skb)->version == 4) {\r\nstruct iphdr *iphdr = ip_hdr(skb);\r\nsrc.proto = htons(ETH_P_IP);\r\nsrc.ipv4.s_addr = iphdr->saddr;\r\nif (ipv4_is_multicast(iphdr->daddr))\r\nreturn 0;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else if (ip_hdr(skb)->version == 6) {\r\nstruct ipv6hdr *iphdr = ipv6_hdr(skb);\r\nsrc.proto = htons(ETH_P_IPV6);\r\nsrc.ipv6 = iphdr->saddr;\r\nif (ipv6_addr_is_multicast(&iphdr->daddr))\r\nreturn 0;\r\n#endif\r\n} else {\r\nreturn 0;\r\n}\r\nif (likely(tipc_udp_is_known_peer(b, &src)))\r\nreturn 0;\r\nreturn tipc_udp_rcast_add(b, &src);\r\n}\r\nstatic int tipc_udp_recv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct udp_bearer *ub;\r\nstruct tipc_bearer *b;\r\nstruct tipc_msg *hdr;\r\nint err;\r\nub = rcu_dereference_sk_user_data(sk);\r\nif (!ub) {\r\npr_err_ratelimited("Failed to get UDP bearer reference");\r\ngoto out;\r\n}\r\nskb_pull(skb, sizeof(struct udphdr));\r\nhdr = buf_msg(skb);\r\nrcu_read_lock();\r\nb = rcu_dereference_rtnl(ub->bearer);\r\nif (!b)\r\ngoto rcu_out;\r\nif (b && test_bit(0, &b->up)) {\r\ntipc_rcv(sock_net(sk), skb, b);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nif (unlikely(msg_user(hdr) == LINK_CONFIG)) {\r\nerr = tipc_udp_rcast_disc(b, skb);\r\nif (err)\r\ngoto rcu_out;\r\n}\r\ntipc_rcv(sock_net(sk), skb, b);\r\nrcu_read_unlock();\r\nreturn 0;\r\nrcu_out:\r\nrcu_read_unlock();\r\nout:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int enable_mcast(struct udp_bearer *ub, struct udp_media_addr *remote)\r\n{\r\nint err = 0;\r\nstruct ip_mreqn mreqn;\r\nstruct sock *sk = ub->ubsock->sk;\r\nif (ntohs(remote->proto) == ETH_P_IP) {\r\nmreqn.imr_multiaddr = remote->ipv4;\r\nmreqn.imr_ifindex = ub->ifindex;\r\nerr = ip_mc_join_group(sk, &mreqn);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else {\r\nerr = ipv6_stub->ipv6_sock_mc_join(sk, ub->ifindex,\r\n&remote->ipv6);\r\n#endif\r\n}\r\nreturn err;\r\n}\r\nstatic int __tipc_nl_add_udp_addr(struct sk_buff *skb,\r\nstruct udp_media_addr *addr, int nla_t)\r\n{\r\nif (ntohs(addr->proto) == ETH_P_IP) {\r\nstruct sockaddr_in ip4;\r\nmemset(&ip4, 0, sizeof(ip4));\r\nip4.sin_family = AF_INET;\r\nip4.sin_port = addr->port;\r\nip4.sin_addr.s_addr = addr->ipv4.s_addr;\r\nif (nla_put(skb, nla_t, sizeof(ip4), &ip4))\r\nreturn -EMSGSIZE;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else if (ntohs(addr->proto) == ETH_P_IPV6) {\r\nstruct sockaddr_in6 ip6;\r\nmemset(&ip6, 0, sizeof(ip6));\r\nip6.sin6_family = AF_INET6;\r\nip6.sin6_port = addr->port;\r\nmemcpy(&ip6.sin6_addr, &addr->ipv6, sizeof(struct in6_addr));\r\nif (nla_put(skb, nla_t, sizeof(ip6), &ip6))\r\nreturn -EMSGSIZE;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nint tipc_udp_nl_dump_remoteip(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nu32 bid = cb->args[0];\r\nu32 skip_cnt = cb->args[1];\r\nu32 portid = NETLINK_CB(cb->skb).portid;\r\nstruct udp_replicast *rcast, *tmp;\r\nstruct tipc_bearer *b;\r\nstruct udp_bearer *ub;\r\nvoid *hdr;\r\nint err;\r\nint i;\r\nif (!bid && !skip_cnt) {\r\nstruct net *net = sock_net(skb->sk);\r\nstruct nlattr *battrs[TIPC_NLA_BEARER_MAX + 1];\r\nstruct nlattr **attrs;\r\nchar *bname;\r\nerr = tipc_nlmsg_parse(cb->nlh, &attrs);\r\nif (err)\r\nreturn err;\r\nif (!attrs[TIPC_NLA_BEARER])\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(battrs, TIPC_NLA_BEARER_MAX,\r\nattrs[TIPC_NLA_BEARER],\r\ntipc_nl_bearer_policy, NULL);\r\nif (err)\r\nreturn err;\r\nif (!battrs[TIPC_NLA_BEARER_NAME])\r\nreturn -EINVAL;\r\nbname = nla_data(battrs[TIPC_NLA_BEARER_NAME]);\r\nrtnl_lock();\r\nb = tipc_bearer_find(net, bname);\r\nif (!b) {\r\nrtnl_unlock();\r\nreturn -EINVAL;\r\n}\r\nbid = b->identity;\r\n} else {\r\nstruct net *net = sock_net(skb->sk);\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nrtnl_lock();\r\nb = rtnl_dereference(tn->bearer_list[bid]);\r\nif (!b) {\r\nrtnl_unlock();\r\nreturn -EINVAL;\r\n}\r\n}\r\nub = rcu_dereference_rtnl(b->media_ptr);\r\nif (!ub) {\r\nrtnl_unlock();\r\nreturn -EINVAL;\r\n}\r\ni = 0;\r\nlist_for_each_entry_safe(rcast, tmp, &ub->rcast.list, list) {\r\nif (i < skip_cnt)\r\ngoto count;\r\nhdr = genlmsg_put(skb, portid, cb->nlh->nlmsg_seq,\r\n&tipc_genl_family, NLM_F_MULTI,\r\nTIPC_NL_BEARER_GET);\r\nif (!hdr)\r\ngoto done;\r\nerr = __tipc_nl_add_udp_addr(skb, &rcast->addr,\r\nTIPC_NLA_UDP_REMOTE);\r\nif (err) {\r\ngenlmsg_cancel(skb, hdr);\r\ngoto done;\r\n}\r\ngenlmsg_end(skb, hdr);\r\ncount:\r\ni++;\r\n}\r\ndone:\r\nrtnl_unlock();\r\ncb->args[0] = bid;\r\ncb->args[1] = i;\r\nreturn skb->len;\r\n}\r\nint tipc_udp_nl_add_bearer_data(struct tipc_nl_msg *msg, struct tipc_bearer *b)\r\n{\r\nstruct udp_media_addr *src = (struct udp_media_addr *)&b->addr.value;\r\nstruct udp_media_addr *dst;\r\nstruct udp_bearer *ub;\r\nstruct nlattr *nest;\r\nub = rcu_dereference_rtnl(b->media_ptr);\r\nif (!ub)\r\nreturn -ENODEV;\r\nnest = nla_nest_start(msg->skb, TIPC_NLA_BEARER_UDP_OPTS);\r\nif (!nest)\r\ngoto msg_full;\r\nif (__tipc_nl_add_udp_addr(msg->skb, src, TIPC_NLA_UDP_LOCAL))\r\ngoto msg_full;\r\ndst = (struct udp_media_addr *)&b->bcast_addr.value;\r\nif (__tipc_nl_add_udp_addr(msg->skb, dst, TIPC_NLA_UDP_REMOTE))\r\ngoto msg_full;\r\nif (!list_empty(&ub->rcast.list)) {\r\nif (nla_put_flag(msg->skb, TIPC_NLA_UDP_MULTI_REMOTEIP))\r\ngoto msg_full;\r\n}\r\nnla_nest_end(msg->skb, nest);\r\nreturn 0;\r\nmsg_full:\r\nnla_nest_cancel(msg->skb, nest);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int tipc_parse_udp_addr(struct nlattr *nla, struct udp_media_addr *addr,\r\nu32 *scope_id)\r\n{\r\nstruct sockaddr_storage sa;\r\nnla_memcpy(&sa, nla, sizeof(sa));\r\nif (sa.ss_family == AF_INET) {\r\nstruct sockaddr_in *ip4 = (struct sockaddr_in *)&sa;\r\naddr->proto = htons(ETH_P_IP);\r\naddr->port = ip4->sin_port;\r\naddr->ipv4.s_addr = ip4->sin_addr.s_addr;\r\nreturn 0;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else if (sa.ss_family == AF_INET6) {\r\nstruct sockaddr_in6 *ip6 = (struct sockaddr_in6 *)&sa;\r\naddr->proto = htons(ETH_P_IPV6);\r\naddr->port = ip6->sin6_port;\r\nmemcpy(&addr->ipv6, &ip6->sin6_addr, sizeof(struct in6_addr));\r\nif (scope_id) {\r\nint atype;\r\natype = ipv6_addr_type(&ip6->sin6_addr);\r\nif (__ipv6_addr_needs_scope_id(atype) &&\r\n!ip6->sin6_scope_id) {\r\nreturn -EINVAL;\r\n}\r\n*scope_id = ip6->sin6_scope_id ? : 0;\r\n}\r\nreturn 0;\r\n#endif\r\n}\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nint tipc_udp_nl_bearer_add(struct tipc_bearer *b, struct nlattr *attr)\r\n{\r\nint err;\r\nstruct udp_media_addr addr = {0};\r\nstruct nlattr *opts[TIPC_NLA_UDP_MAX + 1];\r\nstruct udp_media_addr *dst;\r\nif (nla_parse_nested(opts, TIPC_NLA_UDP_MAX, attr,\r\ntipc_nl_udp_policy, NULL))\r\nreturn -EINVAL;\r\nif (!opts[TIPC_NLA_UDP_REMOTE])\r\nreturn -EINVAL;\r\nerr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_REMOTE], &addr, NULL);\r\nif (err)\r\nreturn err;\r\ndst = (struct udp_media_addr *)&b->bcast_addr.value;\r\nif (tipc_udp_is_mcast_addr(dst)) {\r\npr_err("Can't add remote ip to TIPC UDP multicast bearer\n");\r\nreturn -EINVAL;\r\n}\r\nif (tipc_udp_is_known_peer(b, &addr))\r\nreturn 0;\r\nreturn tipc_udp_rcast_add(b, &addr);\r\n}\r\nstatic int tipc_udp_enable(struct net *net, struct tipc_bearer *b,\r\nstruct nlattr *attrs[])\r\n{\r\nint err = -EINVAL;\r\nstruct udp_bearer *ub;\r\nstruct udp_media_addr remote = {0};\r\nstruct udp_media_addr local = {0};\r\nstruct udp_port_cfg udp_conf = {0};\r\nstruct udp_tunnel_sock_cfg tuncfg = {NULL};\r\nstruct nlattr *opts[TIPC_NLA_UDP_MAX + 1];\r\nub = kzalloc(sizeof(*ub), GFP_ATOMIC);\r\nif (!ub)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&ub->rcast.list);\r\nif (!attrs[TIPC_NLA_BEARER_UDP_OPTS])\r\ngoto err;\r\nif (nla_parse_nested(opts, TIPC_NLA_UDP_MAX,\r\nattrs[TIPC_NLA_BEARER_UDP_OPTS],\r\ntipc_nl_udp_policy, NULL))\r\ngoto err;\r\nif (!opts[TIPC_NLA_UDP_LOCAL] || !opts[TIPC_NLA_UDP_REMOTE]) {\r\npr_err("Invalid UDP bearer configuration");\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\nerr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_LOCAL], &local,\r\n&ub->ifindex);\r\nif (err)\r\ngoto err;\r\nerr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_REMOTE], &remote, NULL);\r\nif (err)\r\ngoto err;\r\nb->bcast_addr.media_id = TIPC_MEDIA_TYPE_UDP;\r\nb->bcast_addr.broadcast = TIPC_BROADCAST_SUPPORT;\r\nrcu_assign_pointer(b->media_ptr, ub);\r\nrcu_assign_pointer(ub->bearer, b);\r\ntipc_udp_media_addr_set(&b->addr, &local);\r\nif (local.proto == htons(ETH_P_IP)) {\r\nstruct net_device *dev;\r\ndev = __ip_dev_find(net, local.ipv4.s_addr, false);\r\nif (!dev) {\r\nerr = -ENODEV;\r\ngoto err;\r\n}\r\nudp_conf.family = AF_INET;\r\nudp_conf.local_ip.s_addr = htonl(INADDR_ANY);\r\nudp_conf.use_udp_checksums = false;\r\nub->ifindex = dev->ifindex;\r\nif (tipc_mtu_bad(dev, sizeof(struct iphdr) +\r\nsizeof(struct udphdr))) {\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\nb->mtu = dev->mtu - sizeof(struct iphdr)\r\n- sizeof(struct udphdr);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else if (local.proto == htons(ETH_P_IPV6)) {\r\nudp_conf.family = AF_INET6;\r\nudp_conf.use_udp6_tx_checksums = true;\r\nudp_conf.use_udp6_rx_checksums = true;\r\nudp_conf.local_ip6 = in6addr_any;\r\nb->mtu = 1280;\r\n#endif\r\n} else {\r\nerr = -EAFNOSUPPORT;\r\ngoto err;\r\n}\r\nudp_conf.local_udp_port = local.port;\r\nerr = udp_sock_create(net, &udp_conf, &ub->ubsock);\r\nif (err)\r\ngoto err;\r\ntuncfg.sk_user_data = ub;\r\ntuncfg.encap_type = 1;\r\ntuncfg.encap_rcv = tipc_udp_recv;\r\ntuncfg.encap_destroy = NULL;\r\nsetup_udp_tunnel_sock(net, ub->ubsock, &tuncfg);\r\nmemcpy(&b->bcast_addr.value, &remote, sizeof(remote));\r\nif (tipc_udp_is_mcast_addr(&remote))\r\nerr = enable_mcast(ub, &remote);\r\nelse\r\nerr = tipc_udp_rcast_add(b, &remote);\r\nif (err)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nif (ub->ubsock)\r\nudp_tunnel_sock_release(ub->ubsock);\r\nkfree(ub);\r\nreturn err;\r\n}\r\nstatic void cleanup_bearer(struct work_struct *work)\r\n{\r\nstruct udp_bearer *ub = container_of(work, struct udp_bearer, work);\r\nstruct udp_replicast *rcast, *tmp;\r\nlist_for_each_entry_safe(rcast, tmp, &ub->rcast.list, list) {\r\nlist_del_rcu(&rcast->list);\r\nkfree_rcu(rcast, rcu);\r\n}\r\nif (ub->ubsock)\r\nudp_tunnel_sock_release(ub->ubsock);\r\nsynchronize_net();\r\nkfree(ub);\r\n}\r\nstatic void tipc_udp_disable(struct tipc_bearer *b)\r\n{\r\nstruct udp_bearer *ub;\r\nub = rcu_dereference_rtnl(b->media_ptr);\r\nif (!ub) {\r\npr_err("UDP bearer instance not found\n");\r\nreturn;\r\n}\r\nif (ub->ubsock)\r\nsock_set_flag(ub->ubsock->sk, SOCK_DEAD);\r\nRCU_INIT_POINTER(ub->bearer, NULL);\r\nINIT_WORK(&ub->work, cleanup_bearer);\r\nschedule_work(&ub->work);\r\n}
