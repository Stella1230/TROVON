int dell_smbios_error(int value)\r\n{\r\nswitch (value) {\r\ncase 0:\r\nreturn 0;\r\ncase -1:\r\nreturn -EIO;\r\ncase -2:\r\nreturn -ENXIO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstruct calling_interface_buffer *dell_smbios_get_buffer(void)\r\n{\r\nmutex_lock(&buffer_mutex);\r\ndell_smbios_clear_buffer();\r\nreturn buffer;\r\n}\r\nvoid dell_smbios_clear_buffer(void)\r\n{\r\nmemset(buffer, 0, sizeof(struct calling_interface_buffer));\r\n}\r\nvoid dell_smbios_release_buffer(void)\r\n{\r\nmutex_unlock(&buffer_mutex);\r\n}\r\nvoid dell_smbios_send_request(int class, int select)\r\n{\r\nstruct smi_cmd command;\r\ncommand.magic = SMI_CMD_MAGIC;\r\ncommand.command_address = da_command_address;\r\ncommand.command_code = da_command_code;\r\ncommand.ebx = virt_to_phys(buffer);\r\ncommand.ecx = 0x42534931;\r\nbuffer->class = class;\r\nbuffer->select = select;\r\ndcdbas_smi_request(&command);\r\n}\r\nstruct calling_interface_token *dell_smbios_find_token(int tokenid)\r\n{\r\nint i;\r\nfor (i = 0; i < da_num_tokens; i++) {\r\nif (da_tokens[i].tokenID == tokenid)\r\nreturn &da_tokens[i];\r\n}\r\nreturn NULL;\r\n}\r\nint dell_laptop_register_notifier(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_register(&dell_laptop_chain_head, nb);\r\n}\r\nint dell_laptop_unregister_notifier(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_unregister(&dell_laptop_chain_head, nb);\r\n}\r\nvoid dell_laptop_call_notifier(unsigned long action, void *data)\r\n{\r\nblocking_notifier_call_chain(&dell_laptop_chain_head, action, data);\r\n}\r\nstatic void __init parse_da_table(const struct dmi_header *dm)\r\n{\r\nint tokens = (dm->length-11)/sizeof(struct calling_interface_token)-1;\r\nstruct calling_interface_token *new_da_tokens;\r\nstruct calling_interface_structure *table =\r\ncontainer_of(dm, struct calling_interface_structure, header);\r\nif (dm->length < 17)\r\nreturn;\r\nda_command_address = table->cmdIOAddress;\r\nda_command_code = table->cmdIOCode;\r\nnew_da_tokens = krealloc(da_tokens, (da_num_tokens + tokens) *\r\nsizeof(struct calling_interface_token),\r\nGFP_KERNEL);\r\nif (!new_da_tokens)\r\nreturn;\r\nda_tokens = new_da_tokens;\r\nmemcpy(da_tokens+da_num_tokens, table->tokens,\r\nsizeof(struct calling_interface_token) * tokens);\r\nda_num_tokens += tokens;\r\n}\r\nstatic void __init find_tokens(const struct dmi_header *dm, void *dummy)\r\n{\r\nswitch (dm->type) {\r\ncase 0xd4:\r\ncase 0xd5:\r\ncase 0xd6:\r\nbreak;\r\ncase 0xda:\r\nparse_da_table(dm);\r\nbreak;\r\n}\r\n}\r\nstatic int __init dell_smbios_init(void)\r\n{\r\nint ret;\r\ndmi_walk(find_tokens, NULL);\r\nif (!da_tokens) {\r\npr_info("Unable to find dmi tokens\n");\r\nreturn -ENODEV;\r\n}\r\nbuffer = (void *)__get_free_page(GFP_KERNEL | GFP_DMA32);\r\nif (!buffer) {\r\nret = -ENOMEM;\r\ngoto fail_buffer;\r\n}\r\nreturn 0;\r\nfail_buffer:\r\nkfree(da_tokens);\r\nreturn ret;\r\n}\r\nstatic void __exit dell_smbios_exit(void)\r\n{\r\nkfree(da_tokens);\r\nfree_page((unsigned long)buffer);\r\n}
