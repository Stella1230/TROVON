static int tegra_bpmp_xlate_flags(u16 flags, u16 *out)\r\n{\r\nif (flags & I2C_M_TEN) {\r\n*out |= SERIALI2C_TEN;\r\nflags &= ~I2C_M_TEN;\r\n}\r\nif (flags & I2C_M_RD) {\r\n*out |= SERIALI2C_RD;\r\nflags &= ~I2C_M_RD;\r\n}\r\nif (flags & I2C_M_STOP) {\r\n*out |= SERIALI2C_STOP;\r\nflags &= ~I2C_M_STOP;\r\n}\r\nif (flags & I2C_M_NOSTART) {\r\n*out |= SERIALI2C_NOSTART;\r\nflags &= ~I2C_M_NOSTART;\r\n}\r\nif (flags & I2C_M_REV_DIR_ADDR) {\r\n*out |= SERIALI2C_REV_DIR_ADDR;\r\nflags &= ~I2C_M_REV_DIR_ADDR;\r\n}\r\nif (flags & I2C_M_IGNORE_NAK) {\r\n*out |= SERIALI2C_IGNORE_NAK;\r\nflags &= ~I2C_M_IGNORE_NAK;\r\n}\r\nif (flags & I2C_M_NO_RD_ACK) {\r\n*out |= SERIALI2C_NO_RD_ACK;\r\nflags &= ~I2C_M_NO_RD_ACK;\r\n}\r\nif (flags & I2C_M_RECV_LEN) {\r\n*out |= SERIALI2C_RECV_LEN;\r\nflags &= ~I2C_M_RECV_LEN;\r\n}\r\nreturn (flags != 0) ? -EINVAL : 0;\r\n}\r\nstatic int tegra_bpmp_serialize_i2c_msg(struct tegra_bpmp_i2c *i2c,\r\nstruct mrq_i2c_request *request,\r\nstruct i2c_msg *msgs,\r\nunsigned int num)\r\n{\r\nchar *buf = request->xfer.data_buf;\r\nunsigned int i, j, pos = 0;\r\nint err;\r\nfor (i = 0; i < num; i++) {\r\nstruct i2c_msg *msg = &msgs[i];\r\nu16 flags = 0;\r\nerr = tegra_bpmp_xlate_flags(msg->flags, &flags);\r\nif (err < 0)\r\nreturn err;\r\nbuf[pos++] = msg->addr & 0xff;\r\nbuf[pos++] = (msg->addr & 0xff00) >> 8;\r\nbuf[pos++] = flags & 0xff;\r\nbuf[pos++] = (flags & 0xff00) >> 8;\r\nbuf[pos++] = msg->len & 0xff;\r\nbuf[pos++] = (msg->len & 0xff00) >> 8;\r\nif ((flags & SERIALI2C_RD) == 0) {\r\nfor (j = 0; j < msg->len; j++)\r\nbuf[pos++] = msg->buf[j];\r\n}\r\n}\r\nrequest->xfer.data_size = pos;\r\nreturn 0;\r\n}\r\nstatic int tegra_bpmp_i2c_deserialize(struct tegra_bpmp_i2c *i2c,\r\nstruct mrq_i2c_response *response,\r\nstruct i2c_msg *msgs,\r\nunsigned int num)\r\n{\r\nsize_t size = response->xfer.data_size, len = 0, pos = 0;\r\nchar *buf = response->xfer.data_buf;\r\nunsigned int i;\r\nfor (i = 0; i < num; i++)\r\nif (msgs[i].flags & I2C_M_RD)\r\nlen += msgs[i].len;\r\nif (len != size)\r\nreturn -EINVAL;\r\nfor (i = 0; i < num; i++) {\r\nif (msgs[i].flags & I2C_M_RD) {\r\nmemcpy(msgs[i].buf, buf + pos, msgs[i].len);\r\npos += msgs[i].len;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_bpmp_i2c_msg_len_check(struct i2c_msg *msgs, unsigned int num)\r\n{\r\nsize_t tx_len = 0, rx_len = 0;\r\nunsigned int i;\r\nfor (i = 0; i < num; i++)\r\nif (!(msgs[i].flags & I2C_M_RD))\r\ntx_len += SERIALI2C_HDR_SIZE + msgs[i].len;\r\nif (tx_len > TEGRA_I2C_IPC_MAX_IN_BUF_SIZE)\r\nreturn -EINVAL;\r\nfor (i = 0; i < num; i++)\r\nif ((msgs[i].flags & I2C_M_RD))\r\nrx_len += msgs[i].len;\r\nif (rx_len > TEGRA_I2C_IPC_MAX_OUT_BUF_SIZE)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int tegra_bpmp_i2c_msg_xfer(struct tegra_bpmp_i2c *i2c,\r\nstruct mrq_i2c_request *request,\r\nstruct mrq_i2c_response *response)\r\n{\r\nstruct tegra_bpmp_message msg;\r\nint err;\r\nrequest->cmd = CMD_I2C_XFER;\r\nrequest->xfer.bus_id = i2c->bus;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.mrq = MRQ_I2C;\r\nmsg.tx.data = request;\r\nmsg.tx.size = sizeof(*request);\r\nmsg.rx.data = response;\r\nmsg.rx.size = sizeof(*response);\r\nif (irqs_disabled())\r\nerr = tegra_bpmp_transfer_atomic(i2c->bpmp, &msg);\r\nelse\r\nerr = tegra_bpmp_transfer(i2c->bpmp, &msg);\r\nreturn err;\r\n}\r\nstatic int tegra_bpmp_i2c_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct tegra_bpmp_i2c *i2c = i2c_get_adapdata(adapter);\r\nstruct mrq_i2c_response response;\r\nstruct mrq_i2c_request request;\r\nint err;\r\nerr = tegra_bpmp_i2c_msg_len_check(msgs, num);\r\nif (err < 0) {\r\ndev_err(i2c->dev, "unsupported message length\n");\r\nreturn err;\r\n}\r\nmemset(&request, 0, sizeof(request));\r\nmemset(&response, 0, sizeof(response));\r\nerr = tegra_bpmp_serialize_i2c_msg(i2c, &request, msgs, num);\r\nif (err < 0) {\r\ndev_err(i2c->dev, "failed to serialize message: %d\n", err);\r\nreturn err;\r\n}\r\nerr = tegra_bpmp_i2c_msg_xfer(i2c, &request, &response);\r\nif (err < 0) {\r\ndev_err(i2c->dev, "failed to transfer message: %d\n", err);\r\nreturn err;\r\n}\r\nerr = tegra_bpmp_i2c_deserialize(i2c, &response, msgs, num);\r\nif (err < 0) {\r\ndev_err(i2c->dev, "failed to deserialize message: %d\n", err);\r\nreturn err;\r\n}\r\nreturn num;\r\n}\r\nstatic u32 tegra_bpmp_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR |\r\nI2C_FUNC_PROTOCOL_MANGLING | I2C_FUNC_NOSTART;\r\n}\r\nstatic int tegra_bpmp_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra_bpmp_i2c *i2c;\r\nu32 value;\r\nint err;\r\ni2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\ni2c->dev = &pdev->dev;\r\ni2c->bpmp = dev_get_drvdata(pdev->dev.parent);\r\nif (!i2c->bpmp)\r\nreturn -ENODEV;\r\nerr = of_property_read_u32(pdev->dev.of_node, "nvidia,bpmp-bus-id",\r\n&value);\r\nif (err < 0)\r\nreturn err;\r\ni2c->bus = value;\r\ni2c_set_adapdata(&i2c->adapter, i2c);\r\ni2c->adapter.owner = THIS_MODULE;\r\nstrlcpy(i2c->adapter.name, "Tegra BPMP I2C adapter",\r\nsizeof(i2c->adapter.name));\r\ni2c->adapter.algo = &tegra_bpmp_i2c_algo;\r\ni2c->adapter.dev.parent = &pdev->dev;\r\ni2c->adapter.dev.of_node = pdev->dev.of_node;\r\nplatform_set_drvdata(pdev, i2c);\r\nreturn i2c_add_adapter(&i2c->adapter);\r\n}\r\nstatic int tegra_bpmp_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_bpmp_i2c *i2c = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&i2c->adapter);\r\nreturn 0;\r\n}
